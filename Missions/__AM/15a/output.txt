// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 21244 0 0
// InitNature ;
  19: CALL 17910 0 0
// InitArtifact ;
  23: CALL 18527 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5059 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 6831 0 0
// PrepareRussian ;
  52: CALL 8840 0 0
// PrepareLegion ;
  56: CALL 7263 0 0
// Action ;
  60: CALL 11473 0 0
// MC_Start ( ) ;
  64: CALL 23409 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 100
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 101
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 45094 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 46154 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 46247 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 105
 353: PUSH
 354: LD_EXP 105
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 45412 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 45597 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 46154 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 46247 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 45412 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 45597 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 46027 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 45094 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 46154 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 46247 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 105
 843: PUSH
 844: LD_EXP 105
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 45412 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 45597 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 46154 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 46247 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 46565 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 46359 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 45412 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 45597 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 45978 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// uc_side := 7 ;
1443: LD_ADDR_OWVAR 20
1447: PUSH
1448: LD_INT 7
1450: ST_TO_ADDR
// tmp := [ ] ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: EMPTY
1457: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1458: LD_ADDR_EXP 19
1462: PUSH
1463: LD_STRING JMM
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: LD_STRING 14a_
1474: PPUSH
1475: CALL 51848 0 3
1479: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1480: LD_ADDR_EXP 51
1484: PUSH
1485: LD_STRING Burlak
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: LD_STRING 14a_
1496: PPUSH
1497: CALL 51848 0 3
1501: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1502: LD_ADDR_EXP 34
1506: PUSH
1507: LD_STRING Joan
1509: PPUSH
1510: LD_EXP 1
1514: NOT
1515: PPUSH
1516: LD_STRING 13a_
1518: PPUSH
1519: CALL 51848 0 3
1523: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1524: LD_ADDR_EXP 20
1528: PUSH
1529: LD_STRING Roth
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_STRING 13a_
1540: PPUSH
1541: CALL 51848 0 3
1545: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1546: LD_ADDR_EXP 37
1550: PUSH
1551: LD_STRING Gossudarov
1553: PPUSH
1554: LD_EXP 1
1558: NOT
1559: PPUSH
1560: LD_STRING 13a_
1562: PPUSH
1563: CALL 51848 0 3
1567: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1568: LD_ADDR_EXP 25
1572: PUSH
1573: LD_STRING Denis
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 13a_
1584: PPUSH
1585: CALL 51848 0 3
1589: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING DeltaDoctor
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 13a_
1606: PPUSH
1607: CALL 51848 0 3
1611: ST_TO_ADDR
// if DeltaDoctor then
1612: LD_EXP 35
1616: IFFALSE 1634
// tmp := tmp ^ DeltaDoctor ;
1618: LD_ADDR_VAR 0 5
1622: PUSH
1623: LD_VAR 0 5
1627: PUSH
1628: LD_EXP 35
1632: ADD
1633: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1634: LD_ADDR_EXP 33
1638: PUSH
1639: LD_STRING Simms
1641: PPUSH
1642: LD_EXP 1
1646: NOT
1647: PPUSH
1648: LD_STRING 13a_
1650: PPUSH
1651: CALL 51848 0 3
1655: ST_TO_ADDR
// if Simms then
1656: LD_EXP 33
1660: IFFALSE 1678
// tmp := tmp ^ Simms ;
1662: LD_ADDR_VAR 0 5
1666: PUSH
1667: LD_VAR 0 5
1671: PUSH
1672: LD_EXP 33
1676: ADD
1677: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1678: LD_ADDR_EXP 31
1682: PUSH
1683: LD_STRING Frank
1685: PPUSH
1686: LD_EXP 1
1690: NOT
1691: PPUSH
1692: LD_STRING 13a_
1694: PPUSH
1695: CALL 51848 0 3
1699: ST_TO_ADDR
// if Frank then
1700: LD_EXP 31
1704: IFFALSE 1722
// tmp := tmp ^ Frank ;
1706: LD_ADDR_VAR 0 5
1710: PUSH
1711: LD_VAR 0 5
1715: PUSH
1716: LD_EXP 31
1720: ADD
1721: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1722: LD_ADDR_EXP 38
1726: PUSH
1727: LD_STRING Kirilenkova
1729: PPUSH
1730: LD_EXP 1
1734: NOT
1735: PPUSH
1736: LD_STRING 13a_
1738: PPUSH
1739: CALL 51848 0 3
1743: ST_TO_ADDR
// if Kirilenkova then
1744: LD_EXP 38
1748: IFFALSE 1766
// tmp := tmp ^ Kirilenkova ;
1750: LD_ADDR_VAR 0 5
1754: PUSH
1755: LD_VAR 0 5
1759: PUSH
1760: LD_EXP 38
1764: ADD
1765: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1766: LD_ADDR_EXP 39
1770: PUSH
1771: LD_STRING Titov
1773: PPUSH
1774: LD_EXP 1
1778: NOT
1779: PPUSH
1780: LD_STRING 13a_
1782: PPUSH
1783: CALL 51848 0 3
1787: ST_TO_ADDR
// if Titov then
1788: LD_EXP 39
1792: IFFALSE 1810
// tmp := tmp ^ Titov ;
1794: LD_ADDR_VAR 0 5
1798: PUSH
1799: LD_VAR 0 5
1803: PUSH
1804: LD_EXP 39
1808: ADD
1809: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1810: LD_ADDR_EXP 40
1814: PUSH
1815: LD_STRING Fadeev
1817: PPUSH
1818: LD_EXP 1
1822: NOT
1823: PPUSH
1824: LD_STRING 13a_
1826: PPUSH
1827: CALL 51848 0 3
1831: ST_TO_ADDR
// if Fadeev then
1832: LD_EXP 40
1836: IFFALSE 1854
// tmp := tmp ^ Fadeev ;
1838: LD_ADDR_VAR 0 5
1842: PUSH
1843: LD_VAR 0 5
1847: PUSH
1848: LD_EXP 40
1852: ADD
1853: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1854: LD_ADDR_EXP 41
1858: PUSH
1859: LD_STRING Dolgov
1861: PPUSH
1862: LD_EXP 1
1866: NOT
1867: PPUSH
1868: LD_STRING 13a_
1870: PPUSH
1871: CALL 51848 0 3
1875: ST_TO_ADDR
// if Dolgov then
1876: LD_EXP 41
1880: IFFALSE 1898
// tmp := tmp ^ Dolgov ;
1882: LD_ADDR_VAR 0 5
1886: PUSH
1887: LD_VAR 0 5
1891: PUSH
1892: LD_EXP 41
1896: ADD
1897: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1898: LD_ADDR_EXP 42
1902: PUSH
1903: LD_STRING Petrosyan
1905: PPUSH
1906: LD_EXP 1
1910: NOT
1911: PPUSH
1912: LD_STRING 13a_
1914: PPUSH
1915: CALL 51848 0 3
1919: ST_TO_ADDR
// if Petrosyan then
1920: LD_EXP 42
1924: IFFALSE 1942
// tmp := tmp ^ Petrosyan ;
1926: LD_ADDR_VAR 0 5
1930: PUSH
1931: LD_VAR 0 5
1935: PUSH
1936: LD_EXP 42
1940: ADD
1941: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1942: LD_ADDR_EXP 43
1946: PUSH
1947: LD_STRING Scholtze
1949: PPUSH
1950: LD_EXP 1
1954: NOT
1955: PPUSH
1956: LD_STRING 13a_
1958: PPUSH
1959: CALL 51848 0 3
1963: ST_TO_ADDR
// if Scholtze then
1964: LD_EXP 43
1968: IFFALSE 1986
// tmp := tmp ^ Scholtze ;
1970: LD_ADDR_VAR 0 5
1974: PUSH
1975: LD_VAR 0 5
1979: PUSH
1980: LD_EXP 43
1984: ADD
1985: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1986: LD_ADDR_EXP 44
1990: PUSH
1991: LD_STRING Oblukov
1993: PPUSH
1994: LD_EXP 1
1998: NOT
1999: PPUSH
2000: LD_STRING 13a_
2002: PPUSH
2003: CALL 51848 0 3
2007: ST_TO_ADDR
// if Oblukov then
2008: LD_EXP 44
2012: IFFALSE 2030
// tmp := tmp ^ Oblukov ;
2014: LD_ADDR_VAR 0 5
2018: PUSH
2019: LD_VAR 0 5
2023: PUSH
2024: LD_EXP 44
2028: ADD
2029: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2030: LD_ADDR_EXP 45
2034: PUSH
2035: LD_STRING Kapitsova
2037: PPUSH
2038: LD_EXP 1
2042: NOT
2043: PPUSH
2044: LD_STRING 13a_
2046: PPUSH
2047: CALL 51848 0 3
2051: ST_TO_ADDR
// if Kapitsova then
2052: LD_EXP 45
2056: IFFALSE 2074
// tmp := tmp ^ Kapitsova ;
2058: LD_ADDR_VAR 0 5
2062: PUSH
2063: LD_VAR 0 5
2067: PUSH
2068: LD_EXP 45
2072: ADD
2073: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2074: LD_ADDR_EXP 46
2078: PUSH
2079: LD_STRING Lipshchin
2081: PPUSH
2082: LD_EXP 1
2086: NOT
2087: PPUSH
2088: LD_STRING 13a_
2090: PPUSH
2091: CALL 51848 0 3
2095: ST_TO_ADDR
// if Lipshchin then
2096: LD_EXP 46
2100: IFFALSE 2118
// tmp := tmp ^ Lipshchin ;
2102: LD_ADDR_VAR 0 5
2106: PUSH
2107: LD_VAR 0 5
2111: PUSH
2112: LD_EXP 46
2116: ADD
2117: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2118: LD_ADDR_EXP 47
2122: PUSH
2123: LD_STRING Petrovova
2125: PPUSH
2126: LD_EXP 1
2130: NOT
2131: PPUSH
2132: LD_STRING 13a_
2134: PPUSH
2135: CALL 51848 0 3
2139: ST_TO_ADDR
// if Petrovova then
2140: LD_EXP 47
2144: IFFALSE 2162
// tmp := tmp ^ Petrovova ;
2146: LD_ADDR_VAR 0 5
2150: PUSH
2151: LD_VAR 0 5
2155: PUSH
2156: LD_EXP 47
2160: ADD
2161: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2162: LD_ADDR_EXP 48
2166: PUSH
2167: LD_STRING Kovalyuk
2169: PPUSH
2170: LD_EXP 1
2174: NOT
2175: PPUSH
2176: LD_STRING 13a_
2178: PPUSH
2179: CALL 51848 0 3
2183: ST_TO_ADDR
// if Kovalyuk then
2184: LD_EXP 48
2188: IFFALSE 2206
// tmp := tmp ^ Kovalyuk ;
2190: LD_ADDR_VAR 0 5
2194: PUSH
2195: LD_VAR 0 5
2199: PUSH
2200: LD_EXP 48
2204: ADD
2205: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2206: LD_ADDR_EXP 49
2210: PUSH
2211: LD_STRING Kuzmov
2213: PPUSH
2214: LD_EXP 1
2218: NOT
2219: PPUSH
2220: LD_STRING 13a_
2222: PPUSH
2223: CALL 51848 0 3
2227: ST_TO_ADDR
// if Kuzmov then
2228: LD_EXP 49
2232: IFFALSE 2250
// tmp := tmp ^ Kuzmov ;
2234: LD_ADDR_VAR 0 5
2238: PUSH
2239: LD_VAR 0 5
2243: PUSH
2244: LD_EXP 49
2248: ADD
2249: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2250: LD_ADDR_EXP 50
2254: PUSH
2255: LD_STRING Karamazov
2257: PPUSH
2258: LD_EXP 1
2262: NOT
2263: PPUSH
2264: LD_STRING 13a_
2266: PPUSH
2267: CALL 51848 0 3
2271: ST_TO_ADDR
// if Karamazov then
2272: LD_EXP 50
2276: IFFALSE 2294
// tmp := tmp ^ Karamazov ;
2278: LD_ADDR_VAR 0 5
2282: PUSH
2283: LD_VAR 0 5
2287: PUSH
2288: LD_EXP 50
2292: ADD
2293: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2294: LD_ADDR_EXP 52
2298: PUSH
2299: LD_STRING Belkov
2301: PPUSH
2302: LD_EXP 1
2306: NOT
2307: PPUSH
2308: LD_STRING 13a_
2310: PPUSH
2311: CALL 51848 0 3
2315: ST_TO_ADDR
// if Belkov then
2316: LD_EXP 52
2320: IFFALSE 2338
// tmp := tmp ^ Belkov ;
2322: LD_ADDR_VAR 0 5
2326: PUSH
2327: LD_VAR 0 5
2331: PUSH
2332: LD_EXP 52
2336: ADD
2337: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2338: LD_ADDR_EXP 53
2342: PUSH
2343: LD_STRING Gnyevko
2345: PPUSH
2346: LD_EXP 1
2350: NOT
2351: PPUSH
2352: LD_STRING 13a_
2354: PPUSH
2355: CALL 51848 0 3
2359: ST_TO_ADDR
// if Gnyevko then
2360: LD_EXP 53
2364: IFFALSE 2382
// tmp := tmp ^ Gnyevko ;
2366: LD_ADDR_VAR 0 5
2370: PUSH
2371: LD_VAR 0 5
2375: PUSH
2376: LD_EXP 53
2380: ADD
2381: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2382: LD_ADDR_EXP 36
2386: PUSH
2387: LD_STRING Coonie
2389: PPUSH
2390: CALL_OW 25
2394: ST_TO_ADDR
// if not Lisa then
2395: LD_EXP 21
2399: NOT
2400: IFFALSE 2446
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2402: LD_ADDR_EXP 21
2406: PUSH
2407: LD_STRING Lisa
2409: PPUSH
2410: LD_EXP 1
2414: NOT
2415: PPUSH
2416: LD_STRING 13a_
2418: PPUSH
2419: CALL 51848 0 3
2423: ST_TO_ADDR
// if Lisa then
2424: LD_EXP 21
2428: IFFALSE 2446
// tmp := tmp ^ Lisa ;
2430: LD_ADDR_VAR 0 5
2434: PUSH
2435: LD_VAR 0 5
2439: PUSH
2440: LD_EXP 21
2444: ADD
2445: ST_TO_ADDR
// end ; if not Donaldson then
2446: LD_EXP 22
2450: NOT
2451: IFFALSE 2497
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2453: LD_ADDR_EXP 22
2457: PUSH
2458: LD_STRING Donaldson
2460: PPUSH
2461: LD_EXP 1
2465: NOT
2466: PPUSH
2467: LD_STRING 13a_
2469: PPUSH
2470: CALL 51848 0 3
2474: ST_TO_ADDR
// if Donaldson then
2475: LD_EXP 22
2479: IFFALSE 2497
// tmp := tmp ^ Donaldson ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 5
2490: PUSH
2491: LD_EXP 22
2495: ADD
2496: ST_TO_ADDR
// end ; if not Bobby then
2497: LD_EXP 23
2501: NOT
2502: IFFALSE 2548
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2504: LD_ADDR_EXP 23
2508: PUSH
2509: LD_STRING Bobby
2511: PPUSH
2512: LD_EXP 1
2516: NOT
2517: PPUSH
2518: LD_STRING 13a_
2520: PPUSH
2521: CALL 51848 0 3
2525: ST_TO_ADDR
// if Bobby then
2526: LD_EXP 23
2530: IFFALSE 2548
// tmp := tmp ^ Bobby ;
2532: LD_ADDR_VAR 0 5
2536: PUSH
2537: LD_VAR 0 5
2541: PUSH
2542: LD_EXP 23
2546: ADD
2547: ST_TO_ADDR
// end ; if not Cyrus then
2548: LD_EXP 24
2552: NOT
2553: IFFALSE 2599
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2555: LD_ADDR_EXP 24
2559: PUSH
2560: LD_STRING Cyrus
2562: PPUSH
2563: LD_EXP 1
2567: NOT
2568: PPUSH
2569: LD_STRING 13a_
2571: PPUSH
2572: CALL 51848 0 3
2576: ST_TO_ADDR
// if Cyrus then
2577: LD_EXP 24
2581: IFFALSE 2599
// tmp := tmp ^ Cyrus ;
2583: LD_ADDR_VAR 0 5
2587: PUSH
2588: LD_VAR 0 5
2592: PUSH
2593: LD_EXP 24
2597: ADD
2598: ST_TO_ADDR
// end ; if not Brown then
2599: LD_EXP 26
2603: NOT
2604: IFFALSE 2650
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2606: LD_ADDR_EXP 26
2610: PUSH
2611: LD_STRING Brown
2613: PPUSH
2614: LD_EXP 1
2618: NOT
2619: PPUSH
2620: LD_STRING 13a_
2622: PPUSH
2623: CALL 51848 0 3
2627: ST_TO_ADDR
// if Brown then
2628: LD_EXP 26
2632: IFFALSE 2650
// tmp := tmp ^ Brown ;
2634: LD_ADDR_VAR 0 5
2638: PUSH
2639: LD_VAR 0 5
2643: PUSH
2644: LD_EXP 26
2648: ADD
2649: ST_TO_ADDR
// end ; if not Gladstone then
2650: LD_EXP 27
2654: NOT
2655: IFFALSE 2701
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2657: LD_ADDR_EXP 27
2661: PUSH
2662: LD_STRING Gladstone
2664: PPUSH
2665: LD_EXP 1
2669: NOT
2670: PPUSH
2671: LD_STRING 13a_
2673: PPUSH
2674: CALL 51848 0 3
2678: ST_TO_ADDR
// if Gladstone then
2679: LD_EXP 27
2683: IFFALSE 2701
// tmp := tmp ^ Gladstone ;
2685: LD_ADDR_VAR 0 5
2689: PUSH
2690: LD_VAR 0 5
2694: PUSH
2695: LD_EXP 27
2699: ADD
2700: ST_TO_ADDR
// end ; if not Cornel then
2701: LD_EXP 29
2705: NOT
2706: IFFALSE 2752
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2708: LD_ADDR_EXP 29
2712: PUSH
2713: LD_STRING Cornel
2715: PPUSH
2716: LD_EXP 1
2720: NOT
2721: PPUSH
2722: LD_STRING 13a_
2724: PPUSH
2725: CALL 51848 0 3
2729: ST_TO_ADDR
// if Cornel then
2730: LD_EXP 29
2734: IFFALSE 2752
// tmp := tmp ^ Cornel ;
2736: LD_ADDR_VAR 0 5
2740: PUSH
2741: LD_VAR 0 5
2745: PUSH
2746: LD_EXP 29
2750: ADD
2751: ST_TO_ADDR
// end ; if not Houten then
2752: LD_EXP 28
2756: NOT
2757: IFFALSE 2803
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2759: LD_ADDR_EXP 28
2763: PUSH
2764: LD_STRING Houten
2766: PPUSH
2767: LD_EXP 1
2771: NOT
2772: PPUSH
2773: LD_STRING 13a_
2775: PPUSH
2776: CALL 51848 0 3
2780: ST_TO_ADDR
// if Houten then
2781: LD_EXP 28
2785: IFFALSE 2803
// tmp := tmp ^ Houten ;
2787: LD_ADDR_VAR 0 5
2791: PUSH
2792: LD_VAR 0 5
2796: PUSH
2797: LD_EXP 28
2801: ADD
2802: ST_TO_ADDR
// end ; if not Gary then
2803: LD_EXP 30
2807: NOT
2808: IFFALSE 2854
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2810: LD_ADDR_EXP 30
2814: PUSH
2815: LD_STRING Gary
2817: PPUSH
2818: LD_EXP 1
2822: NOT
2823: PPUSH
2824: LD_STRING 13a_
2826: PPUSH
2827: CALL 51848 0 3
2831: ST_TO_ADDR
// if Gary then
2832: LD_EXP 30
2836: IFFALSE 2854
// tmp := tmp ^ Gary ;
2838: LD_ADDR_VAR 0 5
2842: PUSH
2843: LD_VAR 0 5
2847: PUSH
2848: LD_EXP 30
2852: ADD
2853: ST_TO_ADDR
// end ; if not Kikuchi then
2854: LD_EXP 32
2858: NOT
2859: IFFALSE 2905
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2861: LD_ADDR_EXP 32
2865: PUSH
2866: LD_STRING Kikuchi
2868: PPUSH
2869: LD_EXP 1
2873: NOT
2874: PPUSH
2875: LD_STRING 13a_
2877: PPUSH
2878: CALL 51848 0 3
2882: ST_TO_ADDR
// if Kikuchi then
2883: LD_EXP 32
2887: IFFALSE 2905
// tmp := tmp ^ Kikuchi ;
2889: LD_ADDR_VAR 0 5
2893: PUSH
2894: LD_VAR 0 5
2898: PUSH
2899: LD_EXP 32
2903: ADD
2904: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2905: LD_ADDR_VAR 0 5
2909: PUSH
2910: LD_VAR 0 5
2914: PUSH
2915: LD_STRING 13a_others
2917: PPUSH
2918: CALL_OW 31
2922: UNION
2923: ST_TO_ADDR
// tmp := tmp diff 0 ;
2924: LD_ADDR_VAR 0 5
2928: PUSH
2929: LD_VAR 0 5
2933: PUSH
2934: LD_INT 0
2936: DIFF
2937: ST_TO_ADDR
// if tmp < 15 then
2938: LD_VAR 0 5
2942: PUSH
2943: LD_INT 15
2945: LESS
2946: IFFALSE 3034
// for i = 15 downto tmp do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 15
2956: INC
2957: ST_TO_ADDR
2958: LD_VAR 0 5
2962: PUSH
2963: FOR_DOWNTO
2964: IFFALSE 3032
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2966: LD_ADDR_OWVAR 21
2970: PUSH
2971: LD_INT 1
2973: PUSH
2974: LD_INT 3
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: PUSH
2981: LD_INT 1
2983: PPUSH
2984: LD_INT 2
2986: PPUSH
2987: CALL_OW 12
2991: ARRAY
2992: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2993: LD_INT 0
2995: PPUSH
2996: LD_INT 1
2998: PPUSH
2999: LD_INT 4
3001: PPUSH
3002: CALL_OW 12
3006: PPUSH
3007: LD_INT 8
3009: PPUSH
3010: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3014: LD_ADDR_VAR 0 5
3018: PUSH
3019: LD_VAR 0 5
3023: PUSH
3024: CALL_OW 44
3028: ADD
3029: ST_TO_ADDR
// end ;
3030: GO 2963
3032: POP
3033: POP
// if not debug then
3034: LD_EXP 1
3038: NOT
3039: IFFALSE 3219
// selected = CharacterSelection (  , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3041: LD_ADDR_VAR 0 4
3045: PUSH
3046: LD_STRING 
3048: PPUSH
3049: LD_INT 14
3051: PUSH
3052: LD_INT 14
3054: PUSH
3055: LD_INT 13
3057: PUSH
3058: LD_INT 12
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: LIST
3065: LIST
3066: PUSH
3067: LD_OWVAR 67
3071: ARRAY
3072: PPUSH
3073: LD_INT 14
3075: PUSH
3076: LD_INT 14
3078: PUSH
3079: LD_INT 13
3081: PUSH
3082: LD_INT 12
3084: PUSH
3085: EMPTY
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_OWVAR 67
3095: ARRAY
3096: PPUSH
3097: LD_INT -5
3099: PUSH
3100: LD_EXP 19
3104: PUSH
3105: LD_EXP 51
3109: PUSH
3110: LD_EXP 20
3114: PUSH
3115: LD_EXP 34
3119: PUSH
3120: LD_EXP 25
3124: PUSH
3125: LD_EXP 37
3129: PUSH
3130: LD_INT -2
3132: PUSH
3133: LD_INT -3
3135: PUSH
3136: LD_INT -5
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_VAR 0 5
3155: ADD
3156: PPUSH
3157: LD_INT 1
3159: PUSH
3160: LD_INT 4
3162: PUSH
3163: LD_INT 2
3165: PUSH
3166: LD_INT 1
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: PUSH
3173: LD_INT 3
3175: PUSH
3176: LD_INT 5
3178: PUSH
3179: LD_INT 0
3181: PUSH
3182: LD_INT 3
3184: PUSH
3185: EMPTY
3186: LIST
3187: LIST
3188: LIST
3189: PUSH
3190: LD_INT 9
3192: PUSH
3193: LD_INT 0
3195: PUSH
3196: LD_INT 3
3198: PUSH
3199: EMPTY
3200: LIST
3201: LIST
3202: LIST
3203: PUSH
3204: EMPTY
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: LIST
3211: PPUSH
3212: CALL_OW 42
3216: ST_TO_ADDR
3217: GO 3268
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3219: LD_ADDR_VAR 0 4
3223: PUSH
3224: LD_EXP 39
3228: PUSH
3229: LD_EXP 40
3233: PUSH
3234: LD_EXP 41
3238: PUSH
3239: LD_EXP 42
3243: PUSH
3244: LD_EXP 43
3248: PUSH
3249: LD_EXP 44
3253: PUSH
3254: LD_EXP 45
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3268: LD_ADDR_EXP 17
3272: PUSH
3273: LD_VAR 0 5
3277: PUSH
3278: LD_VAR 0 4
3282: DIFF
3283: ST_TO_ADDR
// uc_nation := 1 ;
3284: LD_ADDR_OWVAR 21
3288: PUSH
3289: LD_INT 1
3291: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3292: LD_INT 5
3294: PPUSH
3295: LD_INT 3
3297: PPUSH
3298: LD_INT 1
3300: PPUSH
3301: LD_INT 6
3303: PPUSH
3304: LD_INT 100
3306: PPUSH
3307: CALL 56863 0 5
// veh := CreateVehicle ;
3311: LD_ADDR_VAR 0 3
3315: PUSH
3316: CALL_OW 45
3320: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3321: LD_VAR 0 3
3325: PPUSH
3326: LD_INT 7
3328: NEG
3329: PPUSH
3330: CALL_OW 242
// SetDir ( veh , 3 ) ;
3334: LD_VAR 0 3
3338: PPUSH
3339: LD_INT 3
3341: PPUSH
3342: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3346: LD_VAR 0 3
3350: PPUSH
3351: LD_INT 31
3353: PPUSH
3354: LD_INT 0
3356: PPUSH
3357: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3361: LD_EXP 19
3365: PPUSH
3366: LD_VAR 0 3
3370: PPUSH
3371: CALL_OW 52
// if Joan then
3375: LD_EXP 34
3379: IFFALSE 3451
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3381: LD_INT 3
3383: PPUSH
3384: LD_INT 3
3386: PPUSH
3387: LD_INT 1
3389: PPUSH
3390: LD_INT 11
3392: PPUSH
3393: LD_INT 100
3395: PPUSH
3396: CALL 56863 0 5
// veh := CreateVehicle ;
3400: LD_ADDR_VAR 0 3
3404: PUSH
3405: CALL_OW 45
3409: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3410: LD_VAR 0 3
3414: PPUSH
3415: LD_INT 3
3417: PPUSH
3418: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3422: LD_VAR 0 3
3426: PPUSH
3427: LD_INT 30
3429: PPUSH
3430: LD_INT 0
3432: PPUSH
3433: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3437: LD_EXP 34
3441: PPUSH
3442: LD_VAR 0 3
3446: PPUSH
3447: CALL_OW 52
// end ; if Roth then
3451: LD_EXP 20
3455: IFFALSE 3527
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3457: LD_INT 3
3459: PPUSH
3460: LD_INT 3
3462: PPUSH
3463: LD_INT 1
3465: PPUSH
3466: LD_INT 11
3468: PPUSH
3469: LD_INT 100
3471: PPUSH
3472: CALL 56863 0 5
// veh := CreateVehicle ;
3476: LD_ADDR_VAR 0 3
3480: PUSH
3481: CALL_OW 45
3485: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3486: LD_VAR 0 3
3490: PPUSH
3491: LD_INT 3
3493: PPUSH
3494: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3498: LD_VAR 0 3
3502: PPUSH
3503: LD_INT 30
3505: PPUSH
3506: LD_INT 0
3508: PPUSH
3509: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3513: LD_EXP 20
3517: PPUSH
3518: LD_VAR 0 3
3522: PPUSH
3523: CALL_OW 52
// end ; if Denis then
3527: LD_EXP 25
3531: IFFALSE 3603
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3533: LD_INT 5
3535: PPUSH
3536: LD_INT 3
3538: PPUSH
3539: LD_INT 1
3541: PPUSH
3542: LD_INT 9
3544: PPUSH
3545: LD_INT 100
3547: PPUSH
3548: CALL 56863 0 5
// veh := CreateVehicle ;
3552: LD_ADDR_VAR 0 3
3556: PUSH
3557: CALL_OW 45
3561: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3562: LD_VAR 0 3
3566: PPUSH
3567: LD_INT 3
3569: PPUSH
3570: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3574: LD_VAR 0 3
3578: PPUSH
3579: LD_INT 30
3581: PPUSH
3582: LD_INT 0
3584: PPUSH
3585: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3589: LD_EXP 25
3593: PPUSH
3594: LD_VAR 0 3
3598: PPUSH
3599: CALL_OW 52
// end ; uc_nation := 3 ;
3603: LD_ADDR_OWVAR 21
3607: PUSH
3608: LD_INT 3
3610: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3611: LD_INT 22
3613: PPUSH
3614: LD_INT 3
3616: PPUSH
3617: LD_INT 1
3619: PPUSH
3620: LD_INT 45
3622: PPUSH
3623: LD_INT 100
3625: PPUSH
3626: CALL 56863 0 5
// veh := CreateVehicle ;
3630: LD_ADDR_VAR 0 3
3634: PUSH
3635: CALL_OW 45
3639: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3640: LD_VAR 0 3
3644: PPUSH
3645: LD_INT 7
3647: NEG
3648: PPUSH
3649: CALL_OW 242
// SetDir ( veh , 3 ) ;
3653: LD_VAR 0 3
3657: PPUSH
3658: LD_INT 3
3660: PPUSH
3661: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3665: LD_VAR 0 3
3669: PPUSH
3670: LD_INT 31
3672: PPUSH
3673: LD_INT 0
3675: PPUSH
3676: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3680: LD_EXP 51
3684: PPUSH
3685: LD_VAR 0 3
3689: PPUSH
3690: CALL_OW 52
// if Gossudarov then
3694: LD_EXP 37
3698: IFFALSE 3785
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3700: LD_INT 22
3702: PPUSH
3703: LD_INT 3
3705: PPUSH
3706: LD_INT 1
3708: PPUSH
3709: LD_INT 51
3711: PPUSH
3712: LD_INT 100
3714: PPUSH
3715: CALL 56863 0 5
// veh := CreateVehicle ;
3719: LD_ADDR_VAR 0 3
3723: PUSH
3724: CALL_OW 45
3728: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3729: LD_VAR 0 3
3733: PPUSH
3734: LD_INT 3
3736: PPUSH
3737: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3741: LD_VAR 0 3
3745: PPUSH
3746: LD_INT 30
3748: PPUSH
3749: LD_INT 0
3751: PPUSH
3752: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3756: LD_EXP 37
3760: PPUSH
3761: LD_VAR 0 3
3765: PPUSH
3766: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3770: LD_VAR 0 3
3774: PPUSH
3775: LD_INT 1
3777: PPUSH
3778: LD_INT 100
3780: PPUSH
3781: CALL_OW 290
// end ; for i in selected do
3785: LD_ADDR_VAR 0 2
3789: PUSH
3790: LD_VAR 0 4
3794: PUSH
3795: FOR_IN
3796: IFFALSE 4354
// begin uc_nation := GetNation ( i ) ;
3798: LD_ADDR_OWVAR 21
3802: PUSH
3803: LD_VAR 0 2
3807: PPUSH
3808: CALL_OW 248
3812: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3813: LD_VAR 0 2
3817: PUSH
3818: LD_EXP 21
3822: PUSH
3823: LD_EXP 22
3827: PUSH
3828: LD_EXP 24
3832: PUSH
3833: LD_EXP 23
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: LIST
3842: LIST
3843: IN
3844: IFFALSE 3867
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3846: LD_INT 5
3848: PPUSH
3849: LD_INT 3
3851: PPUSH
3852: LD_INT 1
3854: PPUSH
3855: LD_INT 6
3857: PPUSH
3858: LD_INT 100
3860: PPUSH
3861: CALL 56863 0 5
3865: GO 4301
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3867: LD_VAR 0 2
3871: PUSH
3872: LD_EXP 44
3876: PUSH
3877: LD_EXP 49
3881: PUSH
3882: LD_EXP 47
3886: PUSH
3887: LD_EXP 39
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: LIST
3896: LIST
3897: IN
3898: IFFALSE 3929
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3900: LD_INT 24
3902: PPUSH
3903: LD_INT 1
3905: PPUSH
3906: LD_INT 1
3908: PPUSH
3909: LD_INT 46
3911: PPUSH
3912: LD_INT 65
3914: PPUSH
3915: LD_INT 75
3917: PPUSH
3918: CALL_OW 12
3922: PPUSH
3923: CALL 56863 0 5
3927: GO 4301
// if i = Karamazov then
3929: LD_VAR 0 2
3933: PUSH
3934: LD_EXP 50
3938: EQUAL
3939: IFFALSE 3962
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3941: LD_INT 22
3943: PPUSH
3944: LD_INT 3
3946: PPUSH
3947: LD_INT 1
3949: PPUSH
3950: LD_INT 52
3952: PPUSH
3953: LD_INT 100
3955: PPUSH
3956: CALL 56863 0 5
3960: GO 4301
// if i = Brown then
3962: LD_VAR 0 2
3966: PUSH
3967: LD_EXP 26
3971: EQUAL
3972: IFFALSE 3995
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3974: LD_INT 3
3976: PPUSH
3977: LD_INT 3
3979: PPUSH
3980: LD_INT 1
3982: PPUSH
3983: LD_INT 13
3985: PPUSH
3986: LD_INT 100
3988: PPUSH
3989: CALL 56863 0 5
3993: GO 4301
// if uc_nation = nation_american then
3995: LD_OWVAR 21
3999: PUSH
4000: LD_INT 1
4002: EQUAL
4003: IFFALSE 4154
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4005: LD_INT 3
4007: PUSH
4008: LD_INT 5
4010: PUSH
4011: LD_INT 5
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: LIST
4018: PUSH
4019: LD_OWVAR 21
4023: PUSH
4024: LD_INT 3
4026: MOD
4027: PUSH
4028: LD_INT 1
4030: PLUS
4031: ARRAY
4032: PPUSH
4033: LD_INT 1
4035: PUSH
4036: LD_INT 3
4038: PUSH
4039: LD_INT 1
4041: PUSH
4042: EMPTY
4043: LIST
4044: LIST
4045: LIST
4046: PUSH
4047: LD_OWVAR 21
4051: PUSH
4052: LD_INT 3
4054: MOD
4055: PUSH
4056: LD_INT 1
4058: PLUS
4059: ARRAY
4060: PPUSH
4061: LD_INT 1
4063: PPUSH
4064: LD_INT 11
4066: PUSH
4067: LD_INT 4
4069: PUSH
4070: LD_INT 5
4072: PUSH
4073: EMPTY
4074: LIST
4075: LIST
4076: LIST
4077: PUSH
4078: LD_INT 6
4080: PUSH
4081: LD_INT 7
4083: PUSH
4084: LD_INT 9
4086: PUSH
4087: EMPTY
4088: LIST
4089: LIST
4090: LIST
4091: PUSH
4092: LD_INT 6
4094: PUSH
4095: LD_INT 9
4097: PUSH
4098: LD_INT 12
4100: PUSH
4101: EMPTY
4102: LIST
4103: LIST
4104: LIST
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: LIST
4110: PUSH
4111: LD_OWVAR 21
4115: PUSH
4116: LD_INT 3
4118: MOD
4119: PUSH
4120: LD_INT 1
4122: PLUS
4123: ARRAY
4124: PUSH
4125: LD_INT 1
4127: PPUSH
4128: LD_INT 3
4130: PPUSH
4131: CALL_OW 12
4135: ARRAY
4136: PPUSH
4137: LD_INT 65
4139: PPUSH
4140: LD_INT 75
4142: PPUSH
4143: CALL_OW 12
4147: PPUSH
4148: CALL 56863 0 5
// end else
4152: GO 4301
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4154: LD_INT 22
4156: PUSH
4157: LD_INT 23
4159: PUSH
4160: LD_INT 23
4162: PUSH
4163: EMPTY
4164: LIST
4165: LIST
4166: LIST
4167: PUSH
4168: LD_OWVAR 21
4172: PUSH
4173: LD_INT 3
4175: MOD
4176: PUSH
4177: LD_INT 1
4179: PLUS
4180: ARRAY
4181: PPUSH
4182: LD_INT 1
4184: PUSH
4185: LD_INT 3
4187: PUSH
4188: LD_INT 1
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: LIST
4195: PUSH
4196: LD_OWVAR 21
4200: PUSH
4201: LD_INT 3
4203: MOD
4204: PUSH
4205: LD_INT 1
4207: PLUS
4208: ARRAY
4209: PPUSH
4210: LD_INT 1
4212: PPUSH
4213: LD_INT 45
4215: PUSH
4216: LD_INT 43
4218: PUSH
4219: LD_INT 44
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: LIST
4226: PUSH
4227: LD_INT 46
4229: PUSH
4230: LD_INT 45
4232: PUSH
4233: LD_INT 44
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 46
4243: PUSH
4244: LD_INT 43
4246: PUSH
4247: LD_INT 45
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: LIST
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: LIST
4259: PUSH
4260: LD_OWVAR 21
4264: PUSH
4265: LD_INT 3
4267: MOD
4268: PUSH
4269: LD_INT 1
4271: PLUS
4272: ARRAY
4273: PUSH
4274: LD_INT 1
4276: PPUSH
4277: LD_INT 3
4279: PPUSH
4280: CALL_OW 12
4284: ARRAY
4285: PPUSH
4286: LD_INT 65
4288: PPUSH
4289: LD_INT 75
4291: PPUSH
4292: CALL_OW 12
4296: PPUSH
4297: CALL 56863 0 5
// end ; veh := CreateVehicle ;
4301: LD_ADDR_VAR 0 3
4305: PUSH
4306: CALL_OW 45
4310: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4311: LD_VAR 0 3
4315: PPUSH
4316: LD_INT 3
4318: PPUSH
4319: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4323: LD_VAR 0 3
4327: PPUSH
4328: LD_INT 30
4330: PPUSH
4331: LD_INT 0
4333: PPUSH
4334: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4338: LD_VAR 0 2
4342: PPUSH
4343: LD_VAR 0 3
4347: PPUSH
4348: CALL_OW 52
// end ;
4352: GO 3795
4354: POP
4355: POP
// if artifactArCaptured then
4356: LD_EXP 9
4360: IFFALSE 4446
// begin uc_nation := nation_american ;
4362: LD_ADDR_OWVAR 21
4366: PUSH
4367: LD_INT 1
4369: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4370: LD_INT 3
4372: PPUSH
4373: LD_INT 3
4375: PPUSH
4376: LD_INT 3
4378: PPUSH
4379: LD_INT 12
4381: PPUSH
4382: LD_INT 100
4384: PPUSH
4385: CALL 56863 0 5
// veh := CreateVehicle ;
4389: LD_ADDR_VAR 0 3
4393: PUSH
4394: CALL_OW 45
4398: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4399: LD_VAR 0 3
4403: PPUSH
4404: LD_INT 3
4406: PPUSH
4407: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4411: LD_VAR 0 3
4415: PPUSH
4416: LD_INT 198
4418: PPUSH
4419: LD_INT 22
4421: PPUSH
4422: LD_INT 0
4424: PPUSH
4425: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4429: LD_VAR 0 3
4433: PPUSH
4434: LD_INT 4
4436: PPUSH
4437: LD_INT 50
4439: PPUSH
4440: CALL_OW 290
// end else
4444: GO 4465
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4446: LD_INT 4
4448: PPUSH
4449: LD_INT 5
4451: PPUSH
4452: LD_INT 267
4454: PPUSH
4455: LD_INT 226
4457: PPUSH
4458: LD_INT 0
4460: PPUSH
4461: CALL_OW 58
// end ; uc_nation := nation_american ;
4465: LD_ADDR_OWVAR 21
4469: PUSH
4470: LD_INT 1
4472: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4473: LD_INT 3
4475: PPUSH
4476: LD_INT 3
4478: PPUSH
4479: LD_INT 3
4481: PPUSH
4482: LD_INT 12
4484: PPUSH
4485: LD_INT 100
4487: PPUSH
4488: CALL 56863 0 5
// veh := CreateVehicle ;
4492: LD_ADDR_VAR 0 3
4496: PUSH
4497: CALL_OW 45
4501: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4502: LD_VAR 0 3
4506: PPUSH
4507: LD_INT 3
4509: PPUSH
4510: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4514: LD_VAR 0 3
4518: PPUSH
4519: LD_INT 218
4521: PPUSH
4522: LD_INT 23
4524: PPUSH
4525: LD_INT 0
4527: PPUSH
4528: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4532: LD_VAR 0 3
4536: PPUSH
4537: LD_INT 4
4539: PPUSH
4540: LD_INT 30
4542: PPUSH
4543: CALL_OW 290
// uc_nation := nation_russian ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 3
4554: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4555: LD_INT 22
4557: PPUSH
4558: LD_INT 3
4560: PPUSH
4561: LD_INT 3
4563: PPUSH
4564: LD_INT 51
4566: PPUSH
4567: LD_INT 100
4569: PPUSH
4570: CALL 56863 0 5
// veh := CreateVehicle ;
4574: LD_ADDR_VAR 0 3
4578: PUSH
4579: CALL_OW 45
4583: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4584: LD_VAR 0 3
4588: PPUSH
4589: LD_INT 3
4591: PPUSH
4592: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4596: LD_VAR 0 3
4600: PPUSH
4601: LD_INT 214
4603: PPUSH
4604: LD_INT 20
4606: PPUSH
4607: LD_INT 0
4609: PPUSH
4610: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4614: LD_VAR 0 3
4618: PPUSH
4619: LD_INT 4
4621: PPUSH
4622: LD_INT 40
4624: PPUSH
4625: CALL_OW 290
// end ;
4629: LD_VAR 0 1
4633: RET
// export function AllianceSupport ; var i , veh ; begin
4634: LD_INT 0
4636: PPUSH
4637: PPUSH
4638: PPUSH
// if not allianceTeam then
4639: LD_EXP 17
4643: NOT
4644: IFFALSE 4648
// exit ;
4646: GO 5054
// for i := 1 to 6 do
4648: LD_ADDR_VAR 0 2
4652: PUSH
4653: DOUBLE
4654: LD_INT 1
4656: DEC
4657: ST_TO_ADDR
4658: LD_INT 6
4660: PUSH
4661: FOR_TO
4662: IFFALSE 4958
// begin uc_side := 7 ;
4664: LD_ADDR_OWVAR 20
4668: PUSH
4669: LD_INT 7
4671: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4672: LD_ADDR_OWVAR 21
4676: PUSH
4677: LD_INT 1
4679: PUSH
4680: LD_INT 3
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: PUSH
4687: LD_VAR 0 2
4691: PUSH
4692: LD_INT 2
4694: MOD
4695: PUSH
4696: LD_INT 1
4698: PLUS
4699: ARRAY
4700: ST_TO_ADDR
// if uc_nation = 1 then
4701: LD_OWVAR 21
4705: PUSH
4706: LD_INT 1
4708: EQUAL
4709: IFFALSE 4751
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4711: LD_INT 5
4713: PPUSH
4714: LD_INT 3
4716: PPUSH
4717: LD_INT 1
4719: PPUSH
4720: LD_INT 6
4722: PUSH
4723: LD_INT 7
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 1
4732: PPUSH
4733: LD_INT 2
4735: PPUSH
4736: CALL_OW 12
4740: ARRAY
4741: PPUSH
4742: LD_INT 100
4744: PPUSH
4745: CALL 56863 0 5
4749: GO 4789
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4751: LD_INT 23
4753: PPUSH
4754: LD_INT 3
4756: PPUSH
4757: LD_INT 1
4759: PPUSH
4760: LD_INT 46
4762: PUSH
4763: LD_INT 47
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 2
4775: PPUSH
4776: CALL_OW 12
4780: ARRAY
4781: PPUSH
4782: LD_INT 100
4784: PPUSH
4785: CALL 56863 0 5
// if not allianceTeam then
4789: LD_EXP 17
4793: NOT
4794: IFFALSE 4798
// break ;
4796: GO 4958
// veh := CreateVehicle ;
4798: LD_ADDR_VAR 0 3
4802: PUSH
4803: CALL_OW 45
4807: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4808: LD_VAR 0 3
4812: PPUSH
4813: LD_INT 4
4815: PPUSH
4816: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4820: LD_VAR 0 3
4824: PPUSH
4825: LD_INT 38
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4835: LD_EXP 17
4839: PUSH
4840: LD_INT 1
4842: ARRAY
4843: PPUSH
4844: LD_INT 3
4846: PPUSH
4847: CALL_OW 259
4851: PUSH
4852: LD_INT 4
4854: GREATER
4855: IFFALSE 4873
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4857: LD_EXP 17
4861: PUSH
4862: LD_INT 1
4864: ARRAY
4865: PPUSH
4866: LD_INT 3
4868: PPUSH
4869: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4873: LD_EXP 17
4877: PUSH
4878: LD_INT 1
4880: ARRAY
4881: PPUSH
4882: LD_INT 4
4884: PPUSH
4885: CALL_OW 259
4889: PUSH
4890: LD_INT 8
4892: GREATER
4893: IFFALSE 4911
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4895: LD_EXP 17
4899: PUSH
4900: LD_INT 1
4902: ARRAY
4903: PPUSH
4904: LD_INT 4
4906: PPUSH
4907: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4911: LD_EXP 17
4915: PUSH
4916: LD_INT 1
4918: ARRAY
4919: PPUSH
4920: LD_VAR 0 3
4924: PPUSH
4925: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4929: LD_ADDR_EXP 17
4933: PUSH
4934: LD_EXP 17
4938: PPUSH
4939: LD_INT 1
4941: PPUSH
4942: CALL_OW 3
4946: ST_TO_ADDR
// ComHold ( veh ) ;
4947: LD_VAR 0 3
4951: PPUSH
4952: CALL_OW 140
// end ;
4956: GO 4661
4958: POP
4959: POP
// uc_side := 7 ;
4960: LD_ADDR_OWVAR 20
4964: PUSH
4965: LD_INT 7
4967: ST_TO_ADDR
// uc_nation := 1 ;
4968: LD_ADDR_OWVAR 21
4972: PUSH
4973: LD_INT 1
4975: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
4976: LD_INT 5
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: LD_INT 3
4984: PPUSH
4985: LD_INT 11
4987: PPUSH
4988: LD_INT 100
4990: PPUSH
4991: CALL 56863 0 5
// veh := CreateVehicle ;
4995: LD_ADDR_VAR 0 3
4999: PUSH
5000: CALL_OW 45
5004: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5005: LD_VAR 0 3
5009: PPUSH
5010: LD_INT 4
5012: PPUSH
5013: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5017: LD_VAR 0 3
5021: PPUSH
5022: LD_INT 305
5024: PPUSH
5025: LD_INT 218
5027: PPUSH
5028: LD_INT 0
5030: PPUSH
5031: CALL_OW 48
// ComHold ( veh ) ;
5035: LD_VAR 0 3
5039: PPUSH
5040: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5044: LD_INT 313
5046: PPUSH
5047: LD_INT 220
5049: PPUSH
5050: CALL_OW 86
// end ; end_of_file
5054: LD_VAR 0 1
5058: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5059: LD_INT 0
5061: PPUSH
5062: PPUSH
5063: PPUSH
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
// InitHc ;
5071: CALL_OW 19
// uc_side := 1 ;
5075: LD_ADDR_OWVAR 20
5079: PUSH
5080: LD_INT 1
5082: ST_TO_ADDR
// uc_nation := 1 ;
5083: LD_ADDR_OWVAR 21
5087: PUSH
5088: LD_INT 1
5090: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5091: LD_ADDR_VAR 0 2
5095: PUSH
5096: LD_INT 22
5098: PUSH
5099: LD_INT 1
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 21
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: PUSH
5125: FOR_IN
5126: IFFALSE 5142
// SetBLevel ( i , 10 ) ;
5128: LD_VAR 0 2
5132: PPUSH
5133: LD_INT 10
5135: PPUSH
5136: CALL_OW 241
5140: GO 5125
5142: POP
5143: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5144: LD_INT 387
5146: PPUSH
5147: CALL_OW 274
5151: PPUSH
5152: LD_INT 1
5154: PPUSH
5155: LD_INT 7500
5157: PPUSH
5158: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5162: LD_INT 387
5164: PPUSH
5165: CALL_OW 274
5169: PPUSH
5170: LD_INT 2
5172: PPUSH
5173: LD_INT 4000
5175: PPUSH
5176: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5180: LD_INT 387
5182: PPUSH
5183: CALL_OW 274
5187: PPUSH
5188: LD_INT 3
5190: PPUSH
5191: LD_INT 50
5193: PPUSH
5194: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5198: LD_INT 476
5200: PPUSH
5201: CALL_OW 274
5205: PPUSH
5206: LD_INT 1
5208: PPUSH
5209: LD_INT 5500
5211: PPUSH
5212: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5216: LD_INT 476
5218: PPUSH
5219: CALL_OW 274
5223: PPUSH
5224: LD_INT 2
5226: PPUSH
5227: LD_INT 4000
5229: PPUSH
5230: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5234: LD_INT 476
5236: PPUSH
5237: CALL_OW 274
5241: PPUSH
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 10
5247: PPUSH
5248: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5252: LD_ADDR_EXP 54
5256: PUSH
5257: LD_STRING Powell
5259: PPUSH
5260: CALL_OW 25
5264: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5265: LD_EXP 54
5269: PPUSH
5270: LD_INT 387
5272: PPUSH
5273: CALL_OW 52
// tmp := [ ] ;
5277: LD_ADDR_VAR 0 6
5281: PUSH
5282: EMPTY
5283: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5284: LD_ADDR_EXP 21
5288: PUSH
5289: LD_STRING Lisa
5291: PPUSH
5292: LD_EXP 1
5296: NOT
5297: PPUSH
5298: LD_STRING 12p_
5300: PPUSH
5301: CALL 51848 0 3
5305: ST_TO_ADDR
// if Lisa then
5306: LD_EXP 21
5310: IFFALSE 5328
// tmp := tmp ^ Lisa ;
5312: LD_ADDR_VAR 0 6
5316: PUSH
5317: LD_VAR 0 6
5321: PUSH
5322: LD_EXP 21
5326: ADD
5327: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5328: LD_ADDR_EXP 22
5332: PUSH
5333: LD_STRING Donaldson
5335: PPUSH
5336: LD_EXP 1
5340: NOT
5341: PPUSH
5342: LD_STRING 12p_
5344: PPUSH
5345: CALL 51848 0 3
5349: ST_TO_ADDR
// if Donaldson then
5350: LD_EXP 22
5354: IFFALSE 5372
// tmp := tmp ^ Donaldson ;
5356: LD_ADDR_VAR 0 6
5360: PUSH
5361: LD_VAR 0 6
5365: PUSH
5366: LD_EXP 22
5370: ADD
5371: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5372: LD_ADDR_EXP 23
5376: PUSH
5377: LD_STRING Bobby
5379: PPUSH
5380: LD_EXP 1
5384: NOT
5385: PPUSH
5386: LD_STRING 12p_
5388: PPUSH
5389: CALL 51848 0 3
5393: ST_TO_ADDR
// if Bobby then
5394: LD_EXP 23
5398: IFFALSE 5416
// tmp := tmp ^ Bobby ;
5400: LD_ADDR_VAR 0 6
5404: PUSH
5405: LD_VAR 0 6
5409: PUSH
5410: LD_EXP 23
5414: ADD
5415: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5416: LD_ADDR_EXP 24
5420: PUSH
5421: LD_STRING Cyrus
5423: PPUSH
5424: LD_EXP 1
5428: NOT
5429: PPUSH
5430: LD_STRING 12p_
5432: PPUSH
5433: CALL 51848 0 3
5437: ST_TO_ADDR
// if Cyrus then
5438: LD_EXP 24
5442: IFFALSE 5460
// tmp := tmp ^ Cyrus ;
5444: LD_ADDR_VAR 0 6
5448: PUSH
5449: LD_VAR 0 6
5453: PUSH
5454: LD_EXP 24
5458: ADD
5459: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5460: LD_ADDR_EXP 26
5464: PUSH
5465: LD_STRING Brown
5467: PPUSH
5468: LD_EXP 1
5472: NOT
5473: PPUSH
5474: LD_STRING 12p_
5476: PPUSH
5477: CALL 51848 0 3
5481: ST_TO_ADDR
// if Brown then
5482: LD_EXP 26
5486: IFFALSE 5504
// tmp := tmp ^ Brown ;
5488: LD_ADDR_VAR 0 6
5492: PUSH
5493: LD_VAR 0 6
5497: PUSH
5498: LD_EXP 26
5502: ADD
5503: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5504: LD_ADDR_EXP 27
5508: PUSH
5509: LD_STRING Gladstone
5511: PPUSH
5512: LD_EXP 1
5516: NOT
5517: PPUSH
5518: LD_STRING 12p_
5520: PPUSH
5521: CALL 51848 0 3
5525: ST_TO_ADDR
// if Gladstone then
5526: LD_EXP 27
5530: IFFALSE 5548
// tmp := tmp ^ Gladstone ;
5532: LD_ADDR_VAR 0 6
5536: PUSH
5537: LD_VAR 0 6
5541: PUSH
5542: LD_EXP 27
5546: ADD
5547: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5548: LD_ADDR_EXP 28
5552: PUSH
5553: LD_STRING Houten
5555: PPUSH
5556: LD_EXP 1
5560: NOT
5561: PPUSH
5562: LD_STRING 12p_
5564: PPUSH
5565: CALL 51848 0 3
5569: ST_TO_ADDR
// if Houten then
5570: LD_EXP 28
5574: IFFALSE 5592
// tmp := tmp ^ Houten ;
5576: LD_ADDR_VAR 0 6
5580: PUSH
5581: LD_VAR 0 6
5585: PUSH
5586: LD_EXP 28
5590: ADD
5591: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5592: LD_ADDR_EXP 29
5596: PUSH
5597: LD_STRING Cornel
5599: PPUSH
5600: LD_EXP 1
5604: NOT
5605: PPUSH
5606: LD_STRING 12p_
5608: PPUSH
5609: CALL 51848 0 3
5613: ST_TO_ADDR
// if Cornel then
5614: LD_EXP 29
5618: IFFALSE 5636
// tmp := tmp ^ Cornel ;
5620: LD_ADDR_VAR 0 6
5624: PUSH
5625: LD_VAR 0 6
5629: PUSH
5630: LD_EXP 29
5634: ADD
5635: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5636: LD_ADDR_EXP 30
5640: PUSH
5641: LD_STRING Gary
5643: PPUSH
5644: LD_EXP 1
5648: NOT
5649: PPUSH
5650: LD_STRING 12p_
5652: PPUSH
5653: CALL 51848 0 3
5657: ST_TO_ADDR
// if Gary then
5658: LD_EXP 30
5662: IFFALSE 5680
// tmp := tmp ^ Gary ;
5664: LD_ADDR_VAR 0 6
5668: PUSH
5669: LD_VAR 0 6
5673: PUSH
5674: LD_EXP 30
5678: ADD
5679: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5680: LD_ADDR_EXP 32
5684: PUSH
5685: LD_STRING Kikuchi
5687: PPUSH
5688: LD_EXP 1
5692: NOT
5693: PPUSH
5694: LD_STRING 12p_
5696: PPUSH
5697: CALL 51848 0 3
5701: ST_TO_ADDR
// if Kikuchi then
5702: LD_EXP 32
5706: IFFALSE 5724
// tmp := tmp ^ Kikuchi ;
5708: LD_ADDR_VAR 0 6
5712: PUSH
5713: LD_VAR 0 6
5717: PUSH
5718: LD_EXP 32
5722: ADD
5723: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5724: LD_ADDR_VAR 0 6
5728: PUSH
5729: LD_VAR 0 6
5733: PUSH
5734: LD_STRING 12p_others
5736: PPUSH
5737: CALL_OW 31
5741: UNION
5742: ST_TO_ADDR
// if tmp < 36 then
5743: LD_VAR 0 6
5747: PUSH
5748: LD_INT 36
5750: LESS
5751: IFFALSE 5818
// for i = 1 to 36 - tmp do
5753: LD_ADDR_VAR 0 2
5757: PUSH
5758: DOUBLE
5759: LD_INT 1
5761: DEC
5762: ST_TO_ADDR
5763: LD_INT 36
5765: PUSH
5766: LD_VAR 0 6
5770: MINUS
5771: PUSH
5772: FOR_TO
5773: IFFALSE 5816
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5775: LD_INT 1
5777: PPUSH
5778: LD_VAR 0 2
5782: PUSH
5783: LD_INT 4
5785: MOD
5786: PUSH
5787: LD_INT 1
5789: PLUS
5790: PPUSH
5791: LD_INT 10
5793: PPUSH
5794: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5798: LD_ADDR_VAR 0 6
5802: PUSH
5803: LD_VAR 0 6
5807: PUSH
5808: CALL_OW 44
5812: ADD
5813: ST_TO_ADDR
// end ;
5814: GO 5772
5816: POP
5817: POP
// for i in tmp do
5818: LD_ADDR_VAR 0 2
5822: PUSH
5823: LD_VAR 0 6
5827: PUSH
5828: FOR_IN
5829: IFFALSE 5854
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5831: LD_VAR 0 2
5835: PPUSH
5836: LD_INT 62
5838: PPUSH
5839: LD_INT 93
5841: PPUSH
5842: LD_INT 9
5844: PPUSH
5845: LD_INT 0
5847: PPUSH
5848: CALL_OW 50
5852: GO 5828
5854: POP
5855: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5856: LD_ADDR_EXP 76
5860: PUSH
5861: LD_EXP 76
5865: PPUSH
5866: LD_INT 4
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PPUSH
5879: CALL_OW 69
5883: PUSH
5884: LD_EXP 54
5888: DIFF
5889: PPUSH
5890: CALL_OW 1
5894: ST_TO_ADDR
// uc_side := 0 ;
5895: LD_ADDR_OWVAR 20
5899: PUSH
5900: LD_INT 0
5902: ST_TO_ADDR
// uc_nation := 0 ;
5903: LD_ADDR_OWVAR 21
5907: PUSH
5908: LD_INT 0
5910: ST_TO_ADDR
// for i = 1 to 4 do
5911: LD_ADDR_VAR 0 2
5915: PUSH
5916: DOUBLE
5917: LD_INT 1
5919: DEC
5920: ST_TO_ADDR
5921: LD_INT 4
5923: PUSH
5924: FOR_TO
5925: IFFALSE 5956
// begin InitHc ;
5927: CALL_OW 19
// hc_class := class_apeman ;
5931: LD_ADDR_OWVAR 28
5935: PUSH
5936: LD_INT 12
5938: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5939: CALL_OW 44
5943: PPUSH
5944: LD_INT 11
5946: PPUSH
5947: LD_INT 0
5949: PPUSH
5950: CALL_OW 49
// end ;
5954: GO 5924
5956: POP
5957: POP
// end ;
5958: LD_VAR 0 1
5962: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5963: LD_EXP 4
5967: NOT
5968: PUSH
5969: LD_INT 4
5971: PPUSH
5972: LD_INT 1
5974: PPUSH
5975: CALL 46878 0 2
5979: NOT
5980: AND
5981: IFFALSE 6753
5983: GO 5985
5985: DISABLE
5986: LD_INT 0
5988: PPUSH
5989: PPUSH
5990: PPUSH
// begin enable ;
5991: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5992: LD_INT 22
5994: PUSH
5995: LD_INT 1
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PUSH
6002: LD_INT 23
6004: PUSH
6005: LD_INT 1
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: PUSH
6012: LD_INT 30
6014: PUSH
6015: LD_INT 3
6017: PUSH
6018: EMPTY
6019: LIST
6020: LIST
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: LIST
6026: PPUSH
6027: CALL_OW 69
6031: NOT
6032: IFFALSE 6036
// exit ;
6034: GO 6753
// if Prob ( 40 ) then
6036: LD_INT 40
6038: PPUSH
6039: CALL_OW 13
6043: IFFALSE 6170
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6045: LD_INT 4
6047: PPUSH
6048: LD_INT 5
6050: PUSH
6051: LD_INT 1
6053: PUSH
6054: LD_INT 2
6056: PUSH
6057: LD_INT 7
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 5
6068: PUSH
6069: LD_INT 1
6071: PUSH
6072: LD_INT 2
6074: PUSH
6075: LD_INT 7
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 5
6086: PUSH
6087: LD_INT 1
6089: PUSH
6090: LD_INT 2
6092: PUSH
6093: LD_INT 7
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 5
6104: PUSH
6105: LD_INT 1
6107: PUSH
6108: LD_INT 2
6110: PUSH
6111: LD_INT 6
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 5
6122: PUSH
6123: LD_INT 1
6125: PUSH
6126: LD_INT 2
6128: PUSH
6129: LD_INT 6
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 5
6140: PUSH
6141: LD_INT 1
6143: PUSH
6144: LD_INT 2
6146: PUSH
6147: LD_INT 6
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: EMPTY
6157: LIST
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: LIST
6163: PPUSH
6164: CALL 45460 0 2
// end else
6168: GO 6293
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6170: LD_INT 4
6172: PPUSH
6173: LD_INT 5
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 2
6181: PUSH
6182: LD_INT 7
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: PUSH
6191: LD_INT 5
6193: PUSH
6194: LD_INT 1
6196: PUSH
6197: LD_INT 2
6199: PUSH
6200: LD_INT 9
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 5
6211: PUSH
6212: LD_INT 1
6214: PUSH
6215: LD_INT 2
6217: PUSH
6218: LD_INT 9
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 5
6229: PUSH
6230: LD_INT 1
6232: PUSH
6233: LD_INT 2
6235: PUSH
6236: LD_INT 6
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 5
6247: PUSH
6248: LD_INT 1
6250: PUSH
6251: LD_INT 2
6253: PUSH
6254: LD_INT 6
6256: PUSH
6257: EMPTY
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: PUSH
6263: LD_INT 5
6265: PUSH
6266: LD_INT 1
6268: PUSH
6269: LD_INT 2
6271: PUSH
6272: LD_INT 6
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PPUSH
6289: CALL 45460 0 2
// end ; repeat wait ( 0 0$1 ) ;
6293: LD_INT 35
6295: PPUSH
6296: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6300: LD_INT 4
6302: PPUSH
6303: LD_INT 1
6305: PPUSH
6306: CALL 46878 0 2
6310: PUSH
6311: LD_INT 6
6313: GREATEREQUAL
6314: IFFALSE 6293
// wait ( 0 0$30 ) ;
6316: LD_INT 1050
6318: PPUSH
6319: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6323: LD_ADDR_VAR 0 2
6327: PUSH
6328: LD_INT 4
6330: PPUSH
6331: LD_INT 1
6333: PPUSH
6334: CALL 46878 0 2
6338: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6339: LD_ADDR_EXP 95
6343: PUSH
6344: LD_EXP 95
6348: PPUSH
6349: LD_INT 4
6351: PPUSH
6352: LD_EXP 95
6356: PUSH
6357: LD_INT 4
6359: ARRAY
6360: PUSH
6361: LD_VAR 0 2
6365: DIFF
6366: PPUSH
6367: CALL_OW 1
6371: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6372: LD_ADDR_VAR 0 3
6376: PUSH
6377: LD_INT 0
6379: PPUSH
6380: LD_INT 2
6382: PPUSH
6383: CALL_OW 12
6387: ST_TO_ADDR
// if target then
6388: LD_VAR 0 3
6392: IFFALSE 6520
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6394: LD_ADDR_VAR 0 2
6398: PUSH
6399: LD_VAR 0 2
6403: PPUSH
6404: LD_INT 24
6406: PUSH
6407: LD_INT 250
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: PPUSH
6414: CALL_OW 72
6418: ST_TO_ADDR
// for i in tmp do
6419: LD_ADDR_VAR 0 1
6423: PUSH
6424: LD_VAR 0 2
6428: PUSH
6429: FOR_IN
6430: IFFALSE 6470
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6432: LD_VAR 0 1
6436: PPUSH
6437: LD_INT 114
6439: PPUSH
6440: LD_INT 108
6442: PPUSH
6443: CALL_OW 297
6447: PUSH
6448: LD_INT 9
6450: GREATER
6451: IFFALSE 6468
// ComMoveXY ( i , 114 , 108 ) ;
6453: LD_VAR 0 1
6457: PPUSH
6458: LD_INT 114
6460: PPUSH
6461: LD_INT 108
6463: PPUSH
6464: CALL_OW 111
6468: GO 6429
6470: POP
6471: POP
// wait ( 0 0$1 ) ;
6472: LD_INT 35
6474: PPUSH
6475: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6479: LD_VAR 0 2
6483: PPUSH
6484: LD_INT 92
6486: PUSH
6487: LD_INT 114
6489: PUSH
6490: LD_INT 108
6492: PUSH
6493: LD_INT 9
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: PPUSH
6502: CALL_OW 72
6506: PUSH
6507: LD_VAR 0 2
6511: PUSH
6512: LD_INT 1
6514: MINUS
6515: GREATEREQUAL
6516: IFFALSE 6394
// end else
6518: GO 6644
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6520: LD_ADDR_VAR 0 2
6524: PUSH
6525: LD_VAR 0 2
6529: PPUSH
6530: LD_INT 24
6532: PUSH
6533: LD_INT 250
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: PPUSH
6540: CALL_OW 72
6544: ST_TO_ADDR
// for i in tmp do
6545: LD_ADDR_VAR 0 1
6549: PUSH
6550: LD_VAR 0 2
6554: PUSH
6555: FOR_IN
6556: IFFALSE 6596
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6558: LD_VAR 0 1
6562: PPUSH
6563: LD_INT 129
6565: PPUSH
6566: LD_INT 139
6568: PPUSH
6569: CALL_OW 297
6573: PUSH
6574: LD_INT 9
6576: GREATER
6577: IFFALSE 6594
// ComMoveXY ( i , 129 , 139 ) ;
6579: LD_VAR 0 1
6583: PPUSH
6584: LD_INT 129
6586: PPUSH
6587: LD_INT 139
6589: PPUSH
6590: CALL_OW 111
6594: GO 6555
6596: POP
6597: POP
// wait ( 0 0$1 ) ;
6598: LD_INT 35
6600: PPUSH
6601: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6605: LD_VAR 0 2
6609: PPUSH
6610: LD_INT 92
6612: PUSH
6613: LD_INT 129
6615: PUSH
6616: LD_INT 139
6618: PUSH
6619: LD_INT 9
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PPUSH
6628: CALL_OW 72
6632: PUSH
6633: LD_VAR 0 2
6637: PUSH
6638: LD_INT 1
6640: MINUS
6641: GREATEREQUAL
6642: IFFALSE 6520
// end ; repeat wait ( 0 0$1 ) ;
6644: LD_INT 35
6646: PPUSH
6647: CALL_OW 67
// for i in tmp do
6651: LD_ADDR_VAR 0 1
6655: PUSH
6656: LD_VAR 0 2
6660: PUSH
6661: FOR_IN
6662: IFFALSE 6744
// begin if GetLives ( i ) > 251 then
6664: LD_VAR 0 1
6668: PPUSH
6669: CALL_OW 256
6673: PUSH
6674: LD_INT 251
6676: GREATER
6677: IFFALSE 6715
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6679: LD_VAR 0 1
6683: PPUSH
6684: LD_INT 81
6686: PUSH
6687: LD_INT 1
6689: PUSH
6690: EMPTY
6691: LIST
6692: LIST
6693: PPUSH
6694: CALL_OW 69
6698: PPUSH
6699: LD_VAR 0 1
6703: PPUSH
6704: CALL_OW 74
6708: PPUSH
6709: CALL_OW 115
6713: GO 6742
// if IsDead ( i ) then
6715: LD_VAR 0 1
6719: PPUSH
6720: CALL_OW 301
6724: IFFALSE 6742
// tmp := tmp diff i ;
6726: LD_ADDR_VAR 0 2
6730: PUSH
6731: LD_VAR 0 2
6735: PUSH
6736: LD_VAR 0 1
6740: DIFF
6741: ST_TO_ADDR
// end ;
6742: GO 6661
6744: POP
6745: POP
// until not tmp ;
6746: LD_VAR 0 2
6750: NOT
6751: IFFALSE 6644
// end ;
6753: PPOPN 3
6755: END
// every 30 30$00 trigger not americanDestroyed do
6756: LD_EXP 4
6760: NOT
6761: IFFALSE 6830
6763: GO 6765
6765: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6766: LD_INT 63000
6768: PUSH
6769: LD_INT 42000
6771: PUSH
6772: LD_INT 31500
6774: PUSH
6775: LD_INT 21000
6777: PUSH
6778: EMPTY
6779: LIST
6780: LIST
6781: LIST
6782: LIST
6783: PUSH
6784: LD_OWVAR 67
6788: ARRAY
6789: PPUSH
6790: CALL_OW 67
// if americanDestroyed then
6794: LD_EXP 4
6798: IFFALSE 6802
// exit ;
6800: GO 6830
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6802: LD_INT 4
6804: PPUSH
6805: LD_INT 5
6807: PUSH
6808: LD_INT 3
6810: PUSH
6811: LD_INT 1
6813: PUSH
6814: LD_INT 8
6816: PUSH
6817: EMPTY
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: PUSH
6823: EMPTY
6824: LIST
6825: PPUSH
6826: CALL 45460 0 2
// end ; end_of_file
6830: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6831: LD_INT 0
6833: PPUSH
6834: PPUSH
6835: PPUSH
6836: PPUSH
6837: PPUSH
// side := 2 ;
6838: LD_ADDR_VAR 0 5
6842: PUSH
6843: LD_INT 2
6845: ST_TO_ADDR
// InitHc ;
6846: CALL_OW 19
// uc_side := side ;
6850: LD_ADDR_OWVAR 20
6854: PUSH
6855: LD_VAR 0 5
6859: ST_TO_ADDR
// uc_nation := 2 ;
6860: LD_ADDR_OWVAR 21
6864: PUSH
6865: LD_INT 2
6867: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6868: LD_ADDR_VAR 0 2
6872: PUSH
6873: LD_INT 22
6875: PUSH
6876: LD_INT 2
6878: PUSH
6879: EMPTY
6880: LIST
6881: LIST
6882: PUSH
6883: LD_INT 21
6885: PUSH
6886: LD_INT 3
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PPUSH
6897: CALL_OW 69
6901: PUSH
6902: FOR_IN
6903: IFFALSE 6919
// SetBLevel ( i , 10 ) ;
6905: LD_VAR 0 2
6909: PPUSH
6910: LD_INT 10
6912: PPUSH
6913: CALL_OW 241
6917: GO 6902
6919: POP
6920: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6921: LD_ADDR_VAR 0 4
6925: PUSH
6926: LD_INT 22
6928: PUSH
6929: LD_VAR 0 5
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: PUSH
6938: LD_INT 30
6940: PUSH
6941: LD_INT 32
6943: PUSH
6944: EMPTY
6945: LIST
6946: LIST
6947: PUSH
6948: LD_INT 58
6950: PUSH
6951: EMPTY
6952: LIST
6953: PUSH
6954: EMPTY
6955: LIST
6956: LIST
6957: LIST
6958: PPUSH
6959: CALL_OW 69
6963: ST_TO_ADDR
// for i = 1 to 10 do
6964: LD_ADDR_VAR 0 2
6968: PUSH
6969: DOUBLE
6970: LD_INT 1
6972: DEC
6973: ST_TO_ADDR
6974: LD_INT 10
6976: PUSH
6977: FOR_TO
6978: IFFALSE 7050
// begin uc_nation := nation_nature ;
6980: LD_ADDR_OWVAR 21
6984: PUSH
6985: LD_INT 0
6987: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6988: LD_ADDR_OWVAR 28
6992: PUSH
6993: LD_INT 15
6995: ST_TO_ADDR
// hc_gallery :=  ;
6996: LD_ADDR_OWVAR 33
7000: PUSH
7001: LD_STRING 
7003: ST_TO_ADDR
// hc_name :=  ;
7004: LD_ADDR_OWVAR 26
7008: PUSH
7009: LD_STRING 
7011: ST_TO_ADDR
// un := CreateHuman ;
7012: LD_ADDR_VAR 0 3
7016: PUSH
7017: CALL_OW 44
7021: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7022: LD_VAR 0 3
7026: PPUSH
7027: LD_VAR 0 4
7031: PUSH
7032: LD_VAR 0 4
7036: PUSH
7037: LD_VAR 0 2
7041: MINUS
7042: ARRAY
7043: PPUSH
7044: CALL_OW 52
// end ;
7048: GO 6977
7050: POP
7051: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7052: LD_INT 503
7054: PPUSH
7055: LD_INT 27
7057: PPUSH
7058: LD_STRING 
7060: PPUSH
7061: LD_INT 8
7063: PUSH
7064: LD_INT 9
7066: PUSH
7067: LD_INT 10
7069: PUSH
7070: LD_INT 10
7072: PUSH
7073: EMPTY
7074: LIST
7075: LIST
7076: LIST
7077: LIST
7078: PUSH
7079: LD_OWVAR 67
7083: ARRAY
7084: PPUSH
7085: LD_INT 3000
7087: PUSH
7088: LD_INT 500
7090: PUSH
7091: LD_INT 150
7093: PUSH
7094: EMPTY
7095: LIST
7096: LIST
7097: LIST
7098: PPUSH
7099: LD_INT 16
7101: PUSH
7102: LD_INT 6
7104: PUSH
7105: LD_INT 6
7107: PUSH
7108: LD_INT 6
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: LIST
7115: LIST
7116: PPUSH
7117: CALL 60307 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7121: LD_ADDR_EXP 76
7125: PUSH
7126: LD_EXP 76
7130: PPUSH
7131: LD_INT 1
7133: PPUSH
7134: LD_INT 22
7136: PUSH
7137: LD_VAR 0 5
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: PUSH
7146: LD_INT 23
7148: PUSH
7149: LD_INT 2
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PUSH
7156: LD_INT 3
7158: PUSH
7159: LD_INT 21
7161: PUSH
7162: LD_INT 2
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: LIST
7177: PPUSH
7178: CALL_OW 69
7182: PPUSH
7183: CALL_OW 1
7187: ST_TO_ADDR
// end ;
7188: LD_VAR 0 1
7192: RET
// export Omar ; export function PrepareOmarAli ; begin
7193: LD_INT 0
7195: PPUSH
// uc_side := 5 ;
7196: LD_ADDR_OWVAR 20
7200: PUSH
7201: LD_INT 5
7203: ST_TO_ADDR
// uc_nation := 2 ;
7204: LD_ADDR_OWVAR 21
7208: PUSH
7209: LD_INT 2
7211: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7212: LD_ADDR_EXP 55
7216: PUSH
7217: LD_STRING Omar
7219: PPUSH
7220: CALL_OW 25
7224: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7225: LD_EXP 55
7229: PPUSH
7230: LD_INT 330
7232: PPUSH
7233: LD_INT 244
7235: PPUSH
7236: LD_INT 0
7238: PPUSH
7239: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7243: LD_EXP 55
7247: PPUSH
7248: LD_INT 252
7250: PPUSH
7251: LD_INT 220
7253: PPUSH
7254: CALL_OW 111
// end ; end_of_file
7258: LD_VAR 0 1
7262: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
7263: LD_INT 0
7265: PPUSH
7266: PPUSH
7267: PPUSH
7268: PPUSH
7269: PPUSH
// side := 8 ;
7270: LD_ADDR_VAR 0 3
7274: PUSH
7275: LD_INT 8
7277: ST_TO_ADDR
// InitHc ;
7278: CALL_OW 19
// uc_side := side ;
7282: LD_ADDR_OWVAR 20
7286: PUSH
7287: LD_VAR 0 3
7291: ST_TO_ADDR
// uc_nation := 2 ;
7292: LD_ADDR_OWVAR 21
7296: PUSH
7297: LD_INT 2
7299: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7300: LD_ADDR_VAR 0 2
7304: PUSH
7305: LD_INT 22
7307: PUSH
7308: LD_VAR 0 3
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PUSH
7317: LD_INT 21
7319: PUSH
7320: LD_INT 3
7322: PUSH
7323: EMPTY
7324: LIST
7325: LIST
7326: PUSH
7327: EMPTY
7328: LIST
7329: LIST
7330: PPUSH
7331: CALL_OW 69
7335: PUSH
7336: FOR_IN
7337: IFFALSE 7353
// SetBLevel ( i , 10 ) ;
7339: LD_VAR 0 2
7343: PPUSH
7344: LD_INT 10
7346: PPUSH
7347: CALL_OW 241
7351: GO 7336
7353: POP
7354: POP
// Schulz := NewCharacter ( Schulz ) ;
7355: LD_ADDR_EXP 56
7359: PUSH
7360: LD_STRING Schulz
7362: PPUSH
7363: CALL_OW 25
7367: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7368: LD_ADDR_EXP 57
7372: PUSH
7373: LD_STRING Kozlov
7375: PPUSH
7376: LD_INT 0
7378: PPUSH
7379: LD_STRING 
7381: PPUSH
7382: CALL 51848 0 3
7386: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7387: LD_EXP 57
7391: PPUSH
7392: LD_INT 22
7394: PUSH
7395: LD_INT 8
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: PUSH
7402: LD_INT 23
7404: PUSH
7405: LD_INT 3
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: PUSH
7412: LD_INT 30
7414: PUSH
7415: LD_INT 8
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: LIST
7426: PPUSH
7427: CALL_OW 69
7431: PUSH
7432: LD_INT 1
7434: ARRAY
7435: PPUSH
7436: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7440: LD_EXP 57
7444: PPUSH
7445: LD_INT 3
7447: PPUSH
7448: LD_INT 10
7450: PPUSH
7451: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7455: LD_ADDR_VAR 0 5
7459: PUSH
7460: LD_INT 22
7462: PUSH
7463: LD_VAR 0 3
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: PUSH
7472: LD_INT 30
7474: PUSH
7475: LD_INT 32
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: LD_INT 58
7484: PUSH
7485: EMPTY
7486: LIST
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: LIST
7492: PPUSH
7493: CALL_OW 69
7497: ST_TO_ADDR
// for i = 1 to 10 do
7498: LD_ADDR_VAR 0 2
7502: PUSH
7503: DOUBLE
7504: LD_INT 1
7506: DEC
7507: ST_TO_ADDR
7508: LD_INT 10
7510: PUSH
7511: FOR_TO
7512: IFFALSE 7584
// begin uc_nation := nation_nature ;
7514: LD_ADDR_OWVAR 21
7518: PUSH
7519: LD_INT 0
7521: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7522: LD_ADDR_OWVAR 28
7526: PUSH
7527: LD_INT 15
7529: ST_TO_ADDR
// hc_gallery :=  ;
7530: LD_ADDR_OWVAR 33
7534: PUSH
7535: LD_STRING 
7537: ST_TO_ADDR
// hc_name :=  ;
7538: LD_ADDR_OWVAR 26
7542: PUSH
7543: LD_STRING 
7545: ST_TO_ADDR
// un := CreateHuman ;
7546: LD_ADDR_VAR 0 4
7550: PUSH
7551: CALL_OW 44
7555: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7556: LD_VAR 0 4
7560: PPUSH
7561: LD_VAR 0 5
7565: PUSH
7566: LD_VAR 0 5
7570: PUSH
7571: LD_VAR 0 2
7575: MINUS
7576: ARRAY
7577: PPUSH
7578: CALL_OW 52
// end ;
7582: GO 7511
7584: POP
7585: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7586: LD_INT 324
7588: PPUSH
7589: LD_INT 3
7591: PPUSH
7592: LD_STRING 
7594: PPUSH
7595: LD_INT 8
7597: PUSH
7598: LD_INT 9
7600: PUSH
7601: LD_INT 10
7603: PUSH
7604: LD_INT 10
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_OWVAR 67
7617: ARRAY
7618: PPUSH
7619: LD_INT 3000
7621: PUSH
7622: LD_INT 500
7624: PUSH
7625: LD_INT 150
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: LIST
7632: PPUSH
7633: LD_INT 16
7635: PUSH
7636: LD_INT 6
7638: PUSH
7639: LD_INT 6
7641: PUSH
7642: LD_INT 8
7644: PUSH
7645: EMPTY
7646: LIST
7647: LIST
7648: LIST
7649: LIST
7650: PPUSH
7651: CALL 60307 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7655: LD_ADDR_EXP 76
7659: PUSH
7660: LD_EXP 76
7664: PPUSH
7665: LD_INT 3
7667: PPUSH
7668: LD_INT 22
7670: PUSH
7671: LD_VAR 0 3
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: PUSH
7680: LD_INT 23
7682: PUSH
7683: LD_INT 2
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 3
7692: PUSH
7693: LD_INT 21
7695: PUSH
7696: LD_INT 2
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: LIST
7711: PPUSH
7712: CALL_OW 69
7716: PUSH
7717: LD_EXP 56
7721: DIFF
7722: PPUSH
7723: CALL_OW 1
7727: ST_TO_ADDR
// end ;
7728: LD_VAR 0 1
7732: RET
// export function BuildKozlovBomb ; begin
7733: LD_INT 0
7735: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7736: LD_INT 332
7738: PPUSH
7739: CALL_OW 302
7743: NOT
7744: PUSH
7745: LD_INT 336
7747: PPUSH
7748: CALL_OW 302
7752: NOT
7753: OR
7754: IFFALSE 7758
// exit ;
7756: GO 7855
// ComChangeProfession ( Kozlov , 4 ) ;
7758: LD_EXP 57
7762: PPUSH
7763: LD_INT 4
7765: PPUSH
7766: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7770: LD_INT 336
7772: PPUSH
7773: LD_INT 25
7775: PPUSH
7776: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7780: LD_INT 35
7782: PPUSH
7783: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7787: LD_INT 25
7789: PPUSH
7790: LD_INT 8
7792: PPUSH
7793: CALL_OW 321
7797: PUSH
7798: LD_INT 2
7800: EQUAL
7801: IFFALSE 7780
// ComExitBuilding ( Kozlov ) ;
7803: LD_EXP 57
7807: PPUSH
7808: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7812: LD_EXP 57
7816: PPUSH
7817: LD_INT 332
7819: PPUSH
7820: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7824: LD_EXP 57
7828: PPUSH
7829: LD_INT 3
7831: PPUSH
7832: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7836: LD_INT 332
7838: PPUSH
7839: LD_INT 23
7841: PPUSH
7842: LD_INT 3
7844: PPUSH
7845: LD_INT 1
7847: PPUSH
7848: LD_INT 48
7850: PPUSH
7851: CALL_OW 125
// end ;
7855: LD_VAR 0 1
7859: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7860: LD_EXP 3
7864: NOT
7865: PUSH
7866: LD_INT 3
7868: PPUSH
7869: LD_INT 1
7871: PPUSH
7872: CALL 46878 0 2
7876: NOT
7877: AND
7878: IFFALSE 8734
7880: GO 7882
7882: DISABLE
7883: LD_INT 0
7885: PPUSH
7886: PPUSH
7887: PPUSH
// begin enable ;
7888: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7889: LD_INT 22
7891: PUSH
7892: LD_INT 8
7894: PUSH
7895: EMPTY
7896: LIST
7897: LIST
7898: PUSH
7899: LD_INT 23
7901: PUSH
7902: LD_INT 2
7904: PUSH
7905: EMPTY
7906: LIST
7907: LIST
7908: PUSH
7909: LD_INT 30
7911: PUSH
7912: LD_INT 3
7914: PUSH
7915: EMPTY
7916: LIST
7917: LIST
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: LIST
7923: PPUSH
7924: CALL_OW 69
7928: NOT
7929: IFFALSE 7933
// exit ;
7931: GO 8734
// if Prob ( 40 ) then
7933: LD_INT 40
7935: PPUSH
7936: CALL_OW 13
7940: IFFALSE 8067
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7942: LD_INT 3
7944: PPUSH
7945: LD_INT 14
7947: PUSH
7948: LD_INT 1
7950: PUSH
7951: LD_INT 2
7953: PUSH
7954: LD_INT 28
7956: PUSH
7957: EMPTY
7958: LIST
7959: LIST
7960: LIST
7961: LIST
7962: PUSH
7963: LD_INT 14
7965: PUSH
7966: LD_INT 1
7968: PUSH
7969: LD_INT 2
7971: PUSH
7972: LD_INT 28
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: LIST
7979: LIST
7980: PUSH
7981: LD_INT 14
7983: PUSH
7984: LD_INT 1
7986: PUSH
7987: LD_INT 2
7989: PUSH
7990: LD_INT 28
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: PUSH
7999: LD_INT 14
8001: PUSH
8002: LD_INT 1
8004: PUSH
8005: LD_INT 2
8007: PUSH
8008: LD_INT 28
8010: PUSH
8011: EMPTY
8012: LIST
8013: LIST
8014: LIST
8015: LIST
8016: PUSH
8017: LD_INT 14
8019: PUSH
8020: LD_INT 1
8022: PUSH
8023: LD_INT 2
8025: PUSH
8026: LD_INT 28
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: LIST
8033: LIST
8034: PUSH
8035: LD_INT 14
8037: PUSH
8038: LD_INT 1
8040: PUSH
8041: LD_INT 2
8043: PUSH
8044: LD_INT 26
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: LIST
8052: PUSH
8053: EMPTY
8054: LIST
8055: LIST
8056: LIST
8057: LIST
8058: LIST
8059: LIST
8060: PPUSH
8061: CALL 45460 0 2
// end else
8065: GO 8274
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8067: LD_INT 3
8069: PPUSH
8070: LD_INT 14
8072: PUSH
8073: LD_INT 1
8075: PUSH
8076: LD_INT 2
8078: PUSH
8079: LD_INT 27
8081: PUSH
8082: LD_INT 26
8084: PUSH
8085: LD_INT 26
8087: PUSH
8088: LD_INT 28
8090: PUSH
8091: EMPTY
8092: LIST
8093: LIST
8094: LIST
8095: LIST
8096: PUSH
8097: LD_OWVAR 67
8101: ARRAY
8102: PUSH
8103: EMPTY
8104: LIST
8105: LIST
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 14
8111: PUSH
8112: LD_INT 1
8114: PUSH
8115: LD_INT 2
8117: PUSH
8118: LD_INT 27
8120: PUSH
8121: LD_INT 26
8123: PUSH
8124: LD_INT 26
8126: PUSH
8127: LD_INT 26
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: LIST
8134: LIST
8135: PUSH
8136: LD_OWVAR 67
8140: ARRAY
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 14
8150: PUSH
8151: LD_INT 1
8153: PUSH
8154: LD_INT 2
8156: PUSH
8157: LD_INT 26
8159: PUSH
8160: LD_INT 26
8162: PUSH
8163: LD_INT 29
8165: PUSH
8166: LD_INT 29
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: LIST
8173: LIST
8174: PUSH
8175: LD_OWVAR 67
8179: ARRAY
8180: PUSH
8181: EMPTY
8182: LIST
8183: LIST
8184: LIST
8185: LIST
8186: PUSH
8187: LD_INT 13
8189: PUSH
8190: LD_INT 1
8192: PUSH
8193: LD_INT 2
8195: PUSH
8196: LD_INT 26
8198: PUSH
8199: LD_INT 29
8201: PUSH
8202: LD_INT 29
8204: PUSH
8205: LD_INT 29
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_OWVAR 67
8218: ARRAY
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: PUSH
8226: LD_INT 13
8228: PUSH
8229: LD_INT 1
8231: PUSH
8232: LD_INT 2
8234: PUSH
8235: LD_INT 29
8237: PUSH
8238: EMPTY
8239: LIST
8240: LIST
8241: LIST
8242: LIST
8243: PUSH
8244: LD_INT 14
8246: PUSH
8247: LD_INT 1
8249: PUSH
8250: LD_INT 2
8252: PUSH
8253: LD_INT 26
8255: PUSH
8256: EMPTY
8257: LIST
8258: LIST
8259: LIST
8260: LIST
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: PPUSH
8270: CALL 45460 0 2
// end ; repeat wait ( 0 0$1 ) ;
8274: LD_INT 35
8276: PPUSH
8277: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8281: LD_INT 3
8283: PPUSH
8284: LD_INT 1
8286: PPUSH
8287: CALL 46878 0 2
8291: PUSH
8292: LD_INT 6
8294: GREATEREQUAL
8295: IFFALSE 8274
// wait ( 0 0$30 ) ;
8297: LD_INT 1050
8299: PPUSH
8300: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8304: LD_ADDR_VAR 0 2
8308: PUSH
8309: LD_INT 3
8311: PPUSH
8312: LD_INT 1
8314: PPUSH
8315: CALL 46878 0 2
8319: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8320: LD_ADDR_EXP 95
8324: PUSH
8325: LD_EXP 95
8329: PPUSH
8330: LD_INT 3
8332: PPUSH
8333: LD_EXP 95
8337: PUSH
8338: LD_INT 3
8340: ARRAY
8341: PUSH
8342: LD_VAR 0 2
8346: DIFF
8347: PPUSH
8348: CALL_OW 1
8352: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8353: LD_ADDR_VAR 0 3
8357: PUSH
8358: LD_INT 0
8360: PPUSH
8361: LD_INT 2
8363: PPUSH
8364: CALL_OW 12
8368: ST_TO_ADDR
// if target then
8369: LD_VAR 0 3
8373: IFFALSE 8501
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8375: LD_ADDR_VAR 0 2
8379: PUSH
8380: LD_VAR 0 2
8384: PPUSH
8385: LD_INT 24
8387: PUSH
8388: LD_INT 250
8390: PUSH
8391: EMPTY
8392: LIST
8393: LIST
8394: PPUSH
8395: CALL_OW 72
8399: ST_TO_ADDR
// for i in tmp do
8400: LD_ADDR_VAR 0 1
8404: PUSH
8405: LD_VAR 0 2
8409: PUSH
8410: FOR_IN
8411: IFFALSE 8451
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8413: LD_VAR 0 1
8417: PPUSH
8418: LD_INT 89
8420: PPUSH
8421: LD_INT 71
8423: PPUSH
8424: CALL_OW 297
8428: PUSH
8429: LD_INT 9
8431: GREATER
8432: IFFALSE 8449
// ComMoveXY ( i , 89 , 71 ) ;
8434: LD_VAR 0 1
8438: PPUSH
8439: LD_INT 89
8441: PPUSH
8442: LD_INT 71
8444: PPUSH
8445: CALL_OW 111
8449: GO 8410
8451: POP
8452: POP
// wait ( 0 0$1 ) ;
8453: LD_INT 35
8455: PPUSH
8456: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8460: LD_VAR 0 2
8464: PPUSH
8465: LD_INT 92
8467: PUSH
8468: LD_INT 89
8470: PUSH
8471: LD_INT 71
8473: PUSH
8474: LD_INT 9
8476: PUSH
8477: EMPTY
8478: LIST
8479: LIST
8480: LIST
8481: LIST
8482: PPUSH
8483: CALL_OW 72
8487: PUSH
8488: LD_VAR 0 2
8492: PUSH
8493: LD_INT 1
8495: MINUS
8496: GREATEREQUAL
8497: IFFALSE 8375
// end else
8499: GO 8625
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8501: LD_ADDR_VAR 0 2
8505: PUSH
8506: LD_VAR 0 2
8510: PPUSH
8511: LD_INT 24
8513: PUSH
8514: LD_INT 250
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: PPUSH
8521: CALL_OW 72
8525: ST_TO_ADDR
// for i in tmp do
8526: LD_ADDR_VAR 0 1
8530: PUSH
8531: LD_VAR 0 2
8535: PUSH
8536: FOR_IN
8537: IFFALSE 8577
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8539: LD_VAR 0 1
8543: PPUSH
8544: LD_INT 147
8546: PPUSH
8547: LD_INT 4
8549: PPUSH
8550: CALL_OW 297
8554: PUSH
8555: LD_INT 9
8557: GREATER
8558: IFFALSE 8575
// ComMoveXY ( i , 147 , 4 ) ;
8560: LD_VAR 0 1
8564: PPUSH
8565: LD_INT 147
8567: PPUSH
8568: LD_INT 4
8570: PPUSH
8571: CALL_OW 111
8575: GO 8536
8577: POP
8578: POP
// wait ( 0 0$1 ) ;
8579: LD_INT 35
8581: PPUSH
8582: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8586: LD_VAR 0 2
8590: PPUSH
8591: LD_INT 92
8593: PUSH
8594: LD_INT 147
8596: PUSH
8597: LD_INT 4
8599: PUSH
8600: LD_INT 9
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: PPUSH
8609: CALL_OW 72
8613: PUSH
8614: LD_VAR 0 2
8618: PUSH
8619: LD_INT 1
8621: MINUS
8622: GREATEREQUAL
8623: IFFALSE 8501
// end ; repeat wait ( 0 0$1 ) ;
8625: LD_INT 35
8627: PPUSH
8628: CALL_OW 67
// for i in tmp do
8632: LD_ADDR_VAR 0 1
8636: PUSH
8637: LD_VAR 0 2
8641: PUSH
8642: FOR_IN
8643: IFFALSE 8725
// begin if GetLives ( i ) > 251 then
8645: LD_VAR 0 1
8649: PPUSH
8650: CALL_OW 256
8654: PUSH
8655: LD_INT 251
8657: GREATER
8658: IFFALSE 8696
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8660: LD_VAR 0 1
8664: PPUSH
8665: LD_INT 81
8667: PUSH
8668: LD_INT 8
8670: PUSH
8671: EMPTY
8672: LIST
8673: LIST
8674: PPUSH
8675: CALL_OW 69
8679: PPUSH
8680: LD_VAR 0 1
8684: PPUSH
8685: CALL_OW 74
8689: PPUSH
8690: CALL_OW 115
8694: GO 8723
// if IsDead ( i ) then
8696: LD_VAR 0 1
8700: PPUSH
8701: CALL_OW 301
8705: IFFALSE 8723
// tmp := tmp diff i ;
8707: LD_ADDR_VAR 0 2
8711: PUSH
8712: LD_VAR 0 2
8716: PUSH
8717: LD_VAR 0 1
8721: DIFF
8722: ST_TO_ADDR
// end ;
8723: GO 8642
8725: POP
8726: POP
// until not tmp ;
8727: LD_VAR 0 2
8731: NOT
8732: IFFALSE 8625
// end ;
8734: PPOPN 3
8736: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8737: LD_EXP 57
8741: PPUSH
8742: CALL_OW 302
8746: PUSH
8747: LD_EXP 3
8751: NOT
8752: AND
8753: IFFALSE 8762
8755: GO 8757
8757: DISABLE
// BuildKozlovBomb ;
8758: CALL 7733 0 0
8762: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8763: LD_INT 22
8765: PUSH
8766: LD_INT 8
8768: PUSH
8769: EMPTY
8770: LIST
8771: LIST
8772: PUSH
8773: LD_INT 34
8775: PUSH
8776: LD_INT 48
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: PUSH
8783: EMPTY
8784: LIST
8785: LIST
8786: PPUSH
8787: CALL_OW 69
8791: IFFALSE 8839
8793: GO 8795
8795: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8796: LD_INT 22
8798: PUSH
8799: LD_INT 8
8801: PUSH
8802: EMPTY
8803: LIST
8804: LIST
8805: PUSH
8806: LD_INT 34
8808: PUSH
8809: LD_INT 48
8811: PUSH
8812: EMPTY
8813: LIST
8814: LIST
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PPUSH
8820: CALL_OW 69
8824: PUSH
8825: LD_INT 1
8827: ARRAY
8828: PPUSH
8829: LD_INT 173
8831: PPUSH
8832: LD_INT 96
8834: PPUSH
8835: CALL_OW 116
// end ; end_of_file
8839: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8840: LD_INT 0
8842: PPUSH
8843: PPUSH
8844: PPUSH
8845: PPUSH
8846: PPUSH
8847: PPUSH
8848: PPUSH
8849: PPUSH
8850: PPUSH
// side := 3 ;
8851: LD_ADDR_VAR 0 6
8855: PUSH
8856: LD_INT 3
8858: ST_TO_ADDR
// InitHc ;
8859: CALL_OW 19
// uc_side := side ;
8863: LD_ADDR_OWVAR 20
8867: PUSH
8868: LD_VAR 0 6
8872: ST_TO_ADDR
// uc_nation := 3 ;
8873: LD_ADDR_OWVAR 21
8877: PUSH
8878: LD_INT 3
8880: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8881: LD_ADDR_VAR 0 2
8885: PUSH
8886: LD_INT 22
8888: PUSH
8889: LD_VAR 0 6
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: PUSH
8898: LD_INT 21
8900: PUSH
8901: LD_INT 3
8903: PUSH
8904: EMPTY
8905: LIST
8906: LIST
8907: PUSH
8908: EMPTY
8909: LIST
8910: LIST
8911: PPUSH
8912: CALL_OW 69
8916: PUSH
8917: FOR_IN
8918: IFFALSE 8934
// SetBLevel ( i , 10 ) ;
8920: LD_VAR 0 2
8924: PPUSH
8925: LD_INT 10
8927: PPUSH
8928: CALL_OW 241
8932: GO 8917
8934: POP
8935: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8936: LD_ADDR_VAR 0 9
8940: PUSH
8941: LD_INT 22
8943: PUSH
8944: LD_VAR 0 6
8948: PUSH
8949: EMPTY
8950: LIST
8951: LIST
8952: PUSH
8953: LD_INT 30
8955: PUSH
8956: LD_INT 34
8958: PUSH
8959: EMPTY
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: LIST
8966: PPUSH
8967: CALL_OW 69
8971: ST_TO_ADDR
// if teleport then
8972: LD_VAR 0 9
8976: IFFALSE 8997
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8978: LD_VAR 0 9
8982: PUSH
8983: LD_INT 1
8985: ARRAY
8986: PPUSH
8987: LD_INT 123
8989: PPUSH
8990: LD_INT 122
8992: PPUSH
8993: CALL_OW 243
// hc_importance := 0 ;
8997: LD_ADDR_OWVAR 32
9001: PUSH
9002: LD_INT 0
9004: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9005: LD_ADDR_EXP 58
9009: PUSH
9010: LD_STRING Platonov
9012: PPUSH
9013: CALL_OW 25
9017: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9018: LD_ADDR_EXP 59
9022: PUSH
9023: LD_STRING Yakotich
9025: PPUSH
9026: LD_EXP 1
9030: NOT
9031: PPUSH
9032: LD_STRING 09_
9034: PPUSH
9035: CALL 51848 0 3
9039: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9040: LD_ADDR_EXP 60
9044: PUSH
9045: LD_STRING Gleb
9047: PPUSH
9048: CALL_OW 25
9052: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9053: LD_STRING 03_Cornel
9055: PPUSH
9056: CALL_OW 28
9060: IFFALSE 9108
// begin Bierezov := NewCharacter ( Mikhail ) ;
9062: LD_ADDR_EXP 61
9066: PUSH
9067: LD_STRING Mikhail
9069: PPUSH
9070: CALL_OW 25
9074: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9075: LD_EXP 61
9079: PPUSH
9080: LD_INT 197
9082: PPUSH
9083: LD_INT 111
9085: PPUSH
9086: LD_INT 9
9088: PPUSH
9089: LD_INT 0
9091: PPUSH
9092: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9096: LD_EXP 61
9100: PPUSH
9101: LD_INT 3
9103: PPUSH
9104: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9108: LD_EXP 58
9112: PPUSH
9113: LD_INT 126
9115: PPUSH
9116: CALL_OW 52
// if Yakotich then
9120: LD_EXP 59
9124: IFFALSE 9147
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9126: LD_EXP 59
9130: PPUSH
9131: LD_INT 197
9133: PPUSH
9134: LD_INT 111
9136: PPUSH
9137: LD_INT 9
9139: PPUSH
9140: LD_INT 0
9142: PPUSH
9143: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9147: LD_EXP 60
9151: PPUSH
9152: LD_INT 197
9154: PPUSH
9155: LD_INT 111
9157: PPUSH
9158: LD_INT 9
9160: PPUSH
9161: LD_INT 0
9163: PPUSH
9164: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9168: LD_ADDR_VAR 0 5
9172: PUSH
9173: LD_INT 126
9175: PPUSH
9176: LD_INT 2
9178: PPUSH
9179: LD_STRING zhukov
9181: PPUSH
9182: LD_INT 9
9184: PUSH
9185: LD_INT 10
9187: PUSH
9188: LD_INT 10
9190: PUSH
9191: LD_INT 10
9193: PUSH
9194: EMPTY
9195: LIST
9196: LIST
9197: LIST
9198: LIST
9199: PUSH
9200: LD_OWVAR 67
9204: ARRAY
9205: PPUSH
9206: LD_INT 9000
9208: PUSH
9209: LD_INT 1000
9211: PUSH
9212: LD_INT 300
9214: PUSH
9215: EMPTY
9216: LIST
9217: LIST
9218: LIST
9219: PPUSH
9220: LD_INT 21
9222: PUSH
9223: LD_INT 8
9225: PUSH
9226: LD_INT 13
9228: PUSH
9229: LD_INT 8
9231: PUSH
9232: EMPTY
9233: LIST
9234: LIST
9235: LIST
9236: LIST
9237: PPUSH
9238: CALL 60307 0 6
9242: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9243: LD_ADDR_VAR 0 4
9247: PUSH
9248: LD_INT 267
9250: PPUSH
9251: CALL_OW 274
9255: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9256: LD_VAR 0 4
9260: PPUSH
9261: LD_INT 1
9263: PPUSH
9264: LD_INT 5000
9266: PPUSH
9267: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9271: LD_VAR 0 4
9275: PPUSH
9276: LD_INT 2
9278: PPUSH
9279: LD_INT 200
9281: PPUSH
9282: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9286: LD_VAR 0 4
9290: PPUSH
9291: LD_INT 3
9293: PPUSH
9294: LD_INT 200
9296: PPUSH
9297: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
9301: LD_ADDR_EXP 76
9305: PUSH
9306: LD_EXP 76
9310: PPUSH
9311: LD_INT 2
9313: PPUSH
9314: LD_VAR 0 5
9318: PUSH
9319: LD_INT 22
9321: PUSH
9322: LD_VAR 0 6
9326: PUSH
9327: EMPTY
9328: LIST
9329: LIST
9330: PUSH
9331: LD_INT 3
9333: PUSH
9334: LD_INT 21
9336: PUSH
9337: LD_INT 2
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL_OW 69
9356: UNION
9357: PUSH
9358: LD_EXP 58
9362: DIFF
9363: PPUSH
9364: CALL_OW 1
9368: ST_TO_ADDR
// behemoths := [ ] ;
9369: LD_ADDR_EXP 62
9373: PUSH
9374: EMPTY
9375: ST_TO_ADDR
// behemothBuilders := [ ] ;
9376: LD_ADDR_EXP 63
9380: PUSH
9381: EMPTY
9382: ST_TO_ADDR
// j := 3 ;
9383: LD_ADDR_VAR 0 3
9387: PUSH
9388: LD_INT 3
9390: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9391: LD_ADDR_VAR 0 2
9395: PUSH
9396: LD_INT 22
9398: PUSH
9399: LD_INT 3
9401: PUSH
9402: EMPTY
9403: LIST
9404: LIST
9405: PUSH
9406: LD_INT 25
9408: PUSH
9409: LD_INT 3
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: PPUSH
9420: CALL_OW 69
9424: PUSH
9425: FOR_IN
9426: IFFALSE 9476
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9428: LD_ADDR_EXP 63
9432: PUSH
9433: LD_EXP 63
9437: PPUSH
9438: LD_VAR 0 2
9442: PPUSH
9443: CALL 89224 0 2
9447: ST_TO_ADDR
// j := j - 1 ;
9448: LD_ADDR_VAR 0 3
9452: PUSH
9453: LD_VAR 0 3
9457: PUSH
9458: LD_INT 1
9460: MINUS
9461: ST_TO_ADDR
// if j = 0 then
9462: LD_VAR 0 3
9466: PUSH
9467: LD_INT 0
9469: EQUAL
9470: IFFALSE 9474
// break ;
9472: GO 9476
// end ;
9474: GO 9425
9476: POP
9477: POP
// end ;
9478: LD_VAR 0 1
9482: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9483: LD_INT 0
9485: PPUSH
9486: PPUSH
9487: PPUSH
9488: PPUSH
9489: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9490: LD_ADDR_VAR 0 4
9494: PUSH
9495: LD_INT 209
9497: PUSH
9498: LD_INT 149
9500: PUSH
9501: EMPTY
9502: LIST
9503: LIST
9504: PUSH
9505: LD_INT 219
9507: PUSH
9508: LD_INT 154
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: PUSH
9515: LD_INT 223
9517: PUSH
9518: LD_INT 149
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: PUSH
9525: LD_INT 232
9527: PUSH
9528: LD_INT 155
9530: PUSH
9531: EMPTY
9532: LIST
9533: LIST
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: LIST
9539: LIST
9540: ST_TO_ADDR
// if not behemothBuilders then
9541: LD_EXP 63
9545: NOT
9546: IFFALSE 9550
// exit ;
9548: GO 9654
// j := 1 ;
9550: LD_ADDR_VAR 0 3
9554: PUSH
9555: LD_INT 1
9557: ST_TO_ADDR
// for i in behemothBuilders do
9558: LD_ADDR_VAR 0 2
9562: PUSH
9563: LD_EXP 63
9567: PUSH
9568: FOR_IN
9569: IFFALSE 9652
// begin if IsInUnit ( i ) then
9571: LD_VAR 0 2
9575: PPUSH
9576: CALL_OW 310
9580: IFFALSE 9591
// ComExitBuilding ( i ) ;
9582: LD_VAR 0 2
9586: PPUSH
9587: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9591: LD_VAR 0 2
9595: PPUSH
9596: LD_INT 37
9598: PPUSH
9599: LD_VAR 0 4
9603: PUSH
9604: LD_VAR 0 3
9608: ARRAY
9609: PUSH
9610: LD_INT 1
9612: ARRAY
9613: PPUSH
9614: LD_VAR 0 4
9618: PUSH
9619: LD_VAR 0 3
9623: ARRAY
9624: PUSH
9625: LD_INT 2
9627: ARRAY
9628: PPUSH
9629: LD_INT 0
9631: PPUSH
9632: CALL_OW 230
// j := j + 1 ;
9636: LD_ADDR_VAR 0 3
9640: PUSH
9641: LD_VAR 0 3
9645: PUSH
9646: LD_INT 1
9648: PLUS
9649: ST_TO_ADDR
// end ;
9650: GO 9568
9652: POP
9653: POP
// end ;
9654: LD_VAR 0 1
9658: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9659: LD_INT 3
9661: PPUSH
9662: CALL 89285 0 1
9666: PUSH
9667: LD_INT 22
9669: PUSH
9670: LD_INT 3
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PUSH
9677: LD_INT 30
9679: PUSH
9680: LD_INT 37
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PPUSH
9691: CALL_OW 69
9695: NOT
9696: AND
9697: IFFALSE 9883
9699: GO 9701
9701: DISABLE
9702: LD_INT 0
9704: PPUSH
9705: PPUSH
// begin enable ;
9706: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9707: LD_ADDR_VAR 0 2
9711: PUSH
9712: LD_INT 3
9714: PPUSH
9715: CALL 89285 0 1
9719: ST_TO_ADDR
// for i in tmp do
9720: LD_ADDR_VAR 0 1
9724: PUSH
9725: LD_VAR 0 2
9729: PUSH
9730: FOR_IN
9731: IFFALSE 9881
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9733: LD_VAR 0 1
9737: PPUSH
9738: LD_INT 7
9740: PPUSH
9741: CALL_OW 308
9745: PUSH
9746: LD_VAR 0 1
9750: PPUSH
9751: CALL_OW 110
9755: PUSH
9756: LD_INT 2
9758: EQUAL
9759: NOT
9760: AND
9761: IFFALSE 9775
// SetTag ( i , 2 ) ;
9763: LD_VAR 0 1
9767: PPUSH
9768: LD_INT 2
9770: PPUSH
9771: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9775: LD_INT 81
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: EMPTY
9782: LIST
9783: LIST
9784: PUSH
9785: LD_INT 91
9787: PUSH
9788: LD_VAR 0 1
9792: PUSH
9793: LD_INT 12
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: LIST
9800: PUSH
9801: EMPTY
9802: LIST
9803: LIST
9804: PPUSH
9805: CALL_OW 69
9809: NOT
9810: PUSH
9811: LD_VAR 0 1
9815: PPUSH
9816: CALL_OW 110
9820: PUSH
9821: LD_INT 2
9823: EQUAL
9824: NOT
9825: AND
9826: IFFALSE 9845
// ComAgressiveMove ( i , 64 , 93 ) else
9828: LD_VAR 0 1
9832: PPUSH
9833: LD_INT 64
9835: PPUSH
9836: LD_INT 93
9838: PPUSH
9839: CALL_OW 114
9843: GO 9879
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9845: LD_VAR 0 1
9849: PPUSH
9850: LD_INT 81
9852: PUSH
9853: LD_INT 3
9855: PUSH
9856: EMPTY
9857: LIST
9858: LIST
9859: PPUSH
9860: CALL_OW 69
9864: PPUSH
9865: LD_VAR 0 1
9869: PPUSH
9870: CALL_OW 74
9874: PPUSH
9875: CALL_OW 115
// end ;
9879: GO 9730
9881: POP
9882: POP
// end ;
9883: PPOPN 2
9885: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9886: LD_EXP 2
9890: NOT
9891: PUSH
9892: LD_INT 2
9894: PPUSH
9895: LD_INT 1
9897: PPUSH
9898: CALL 46878 0 2
9902: NOT
9903: AND
9904: IFFALSE 10828
9906: GO 9908
9908: DISABLE
9909: LD_INT 0
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
// begin enable ;
9915: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9916: LD_INT 22
9918: PUSH
9919: LD_INT 3
9921: PUSH
9922: EMPTY
9923: LIST
9924: LIST
9925: PUSH
9926: LD_INT 30
9928: PUSH
9929: LD_INT 3
9931: PUSH
9932: EMPTY
9933: LIST
9934: LIST
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: PPUSH
9940: CALL_OW 69
9944: NOT
9945: IFFALSE 9949
// exit ;
9947: GO 10828
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9949: LD_ADDR_VAR 0 4
9953: PUSH
9954: LD_INT 22
9956: PUSH
9957: LD_INT 3
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PUSH
9964: LD_INT 30
9966: PUSH
9967: LD_INT 34
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PUSH
9974: EMPTY
9975: LIST
9976: LIST
9977: PPUSH
9978: CALL_OW 69
9982: ST_TO_ADDR
// if Prob ( 40 ) then
9983: LD_INT 40
9985: PPUSH
9986: CALL_OW 13
9990: IFFALSE 10117
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9992: LD_INT 2
9994: PPUSH
9995: LD_INT 22
9997: PUSH
9998: LD_INT 3
10000: PUSH
10001: LD_INT 3
10003: PUSH
10004: LD_INT 49
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: LIST
10011: LIST
10012: PUSH
10013: LD_INT 22
10015: PUSH
10016: LD_INT 3
10018: PUSH
10019: LD_INT 3
10021: PUSH
10022: LD_INT 49
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: LIST
10029: LIST
10030: PUSH
10031: LD_INT 22
10033: PUSH
10034: LD_INT 3
10036: PUSH
10037: LD_INT 3
10039: PUSH
10040: LD_INT 49
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: LIST
10048: PUSH
10049: LD_INT 24
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: LD_INT 46
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 24
10069: PUSH
10070: LD_INT 3
10072: PUSH
10073: LD_INT 3
10075: PUSH
10076: LD_INT 46
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 24
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 3
10093: PUSH
10094: LD_INT 46
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: PPUSH
10111: CALL 45460 0 2
// end else
10115: GO 10240
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10117: LD_INT 2
10119: PPUSH
10120: LD_INT 24
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: LD_INT 3
10128: PUSH
10129: LD_INT 47
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: PUSH
10138: LD_INT 24
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 3
10146: PUSH
10147: LD_INT 47
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 24
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 47
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 24
10176: PUSH
10177: LD_INT 3
10179: PUSH
10180: LD_INT 3
10182: PUSH
10183: LD_INT 46
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: PUSH
10192: LD_INT 24
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 3
10200: PUSH
10201: LD_INT 46
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: PUSH
10210: LD_INT 24
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 3
10218: PUSH
10219: LD_INT 46
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: LIST
10232: LIST
10233: LIST
10234: LIST
10235: PPUSH
10236: CALL 45460 0 2
// end ; if Difficulty > 1 then
10240: LD_OWVAR 67
10244: PUSH
10245: LD_INT 1
10247: GREATER
10248: IFFALSE 10278
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10250: LD_INT 2
10252: PPUSH
10253: LD_INT 24
10255: PUSH
10256: LD_INT 3
10258: PUSH
10259: LD_INT 3
10261: PUSH
10262: LD_INT 47
10264: PUSH
10265: EMPTY
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: PUSH
10271: EMPTY
10272: LIST
10273: PPUSH
10274: CALL 45460 0 2
// repeat wait ( 0 0$1 ) ;
10278: LD_INT 35
10280: PPUSH
10281: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10285: LD_INT 2
10287: PPUSH
10288: LD_INT 1
10290: PPUSH
10291: CALL 46878 0 2
10295: PUSH
10296: LD_INT 6
10298: PUSH
10299: LD_INT 7
10301: PUSH
10302: LD_INT 7
10304: PUSH
10305: LD_INT 7
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: LIST
10312: LIST
10313: PUSH
10314: LD_OWVAR 67
10318: ARRAY
10319: GREATEREQUAL
10320: IFFALSE 10278
// wait ( 0 0$30 ) ;
10322: LD_INT 1050
10324: PPUSH
10325: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10329: LD_ADDR_VAR 0 2
10333: PUSH
10334: LD_INT 2
10336: PPUSH
10337: LD_INT 1
10339: PPUSH
10340: CALL 46878 0 2
10344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10345: LD_ADDR_EXP 95
10349: PUSH
10350: LD_EXP 95
10354: PPUSH
10355: LD_INT 2
10357: PPUSH
10358: LD_EXP 95
10362: PUSH
10363: LD_INT 2
10365: ARRAY
10366: PUSH
10367: LD_VAR 0 2
10371: DIFF
10372: PPUSH
10373: CALL_OW 1
10377: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10378: LD_ADDR_VAR 0 3
10382: PUSH
10383: LD_INT 0
10385: PPUSH
10386: LD_INT 1
10388: PPUSH
10389: CALL_OW 12
10393: ST_TO_ADDR
// if target then
10394: LD_VAR 0 3
10398: IFFALSE 10526
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10400: LD_ADDR_VAR 0 2
10404: PUSH
10405: LD_VAR 0 2
10409: PPUSH
10410: LD_INT 24
10412: PUSH
10413: LD_INT 250
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: PPUSH
10420: CALL_OW 72
10424: ST_TO_ADDR
// for i in tmp do
10425: LD_ADDR_VAR 0 1
10429: PUSH
10430: LD_VAR 0 2
10434: PUSH
10435: FOR_IN
10436: IFFALSE 10476
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10438: LD_VAR 0 1
10442: PPUSH
10443: LD_INT 139
10445: PPUSH
10446: LD_INT 89
10448: PPUSH
10449: CALL_OW 297
10453: PUSH
10454: LD_INT 9
10456: GREATER
10457: IFFALSE 10474
// ComMoveXY ( i , 139 , 89 ) ;
10459: LD_VAR 0 1
10463: PPUSH
10464: LD_INT 139
10466: PPUSH
10467: LD_INT 89
10469: PPUSH
10470: CALL_OW 111
10474: GO 10435
10476: POP
10477: POP
// wait ( 0 0$1 ) ;
10478: LD_INT 35
10480: PPUSH
10481: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10485: LD_VAR 0 2
10489: PPUSH
10490: LD_INT 92
10492: PUSH
10493: LD_INT 139
10495: PUSH
10496: LD_INT 89
10498: PUSH
10499: LD_INT 9
10501: PUSH
10502: EMPTY
10503: LIST
10504: LIST
10505: LIST
10506: LIST
10507: PPUSH
10508: CALL_OW 72
10512: PUSH
10513: LD_VAR 0 2
10517: PUSH
10518: LD_INT 1
10520: MINUS
10521: GREATEREQUAL
10522: IFFALSE 10400
// end else
10524: GO 10668
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10526: LD_VAR 0 2
10530: PPUSH
10531: LD_VAR 0 4
10535: PUSH
10536: LD_INT 1
10538: ARRAY
10539: PPUSH
10540: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10544: LD_ADDR_VAR 0 2
10548: PUSH
10549: LD_VAR 0 2
10553: PPUSH
10554: LD_INT 24
10556: PUSH
10557: LD_INT 250
10559: PUSH
10560: EMPTY
10561: LIST
10562: LIST
10563: PPUSH
10564: CALL_OW 72
10568: ST_TO_ADDR
// for i in tmp do
10569: LD_ADDR_VAR 0 1
10573: PUSH
10574: LD_VAR 0 2
10578: PUSH
10579: FOR_IN
10580: IFFALSE 10620
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10582: LD_VAR 0 1
10586: PPUSH
10587: LD_INT 124
10589: PPUSH
10590: LD_INT 139
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 9
10600: GREATER
10601: IFFALSE 10618
// ComMoveXY ( i , 124 , 139 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 124
10610: PPUSH
10611: LD_INT 139
10613: PPUSH
10614: CALL_OW 111
10618: GO 10579
10620: POP
10621: POP
// wait ( 0 0$1 ) ;
10622: LD_INT 35
10624: PPUSH
10625: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10629: LD_VAR 0 2
10633: PPUSH
10634: LD_INT 92
10636: PUSH
10637: LD_INT 124
10639: PUSH
10640: LD_INT 139
10642: PUSH
10643: LD_INT 9
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: LIST
10650: LIST
10651: PPUSH
10652: CALL_OW 72
10656: PUSH
10657: LD_VAR 0 2
10661: PUSH
10662: LD_INT 1
10664: MINUS
10665: GREATEREQUAL
10666: IFFALSE 10544
// end ; repeat wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// for i in tmp do
10675: LD_ADDR_VAR 0 1
10679: PUSH
10680: LD_VAR 0 2
10684: PUSH
10685: FOR_IN
10686: IFFALSE 10819
// begin if GetLives ( i ) > 251 then
10688: LD_VAR 0 1
10692: PPUSH
10693: CALL_OW 256
10697: PUSH
10698: LD_INT 251
10700: GREATER
10701: IFFALSE 10790
// begin if GetWeapon ( i ) = ru_time_lapser then
10703: LD_VAR 0 1
10707: PPUSH
10708: CALL_OW 264
10712: PUSH
10713: LD_INT 49
10715: EQUAL
10716: IFFALSE 10754
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10718: LD_VAR 0 1
10722: PPUSH
10723: LD_INT 81
10725: PUSH
10726: LD_INT 3
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PPUSH
10733: CALL_OW 69
10737: PPUSH
10738: LD_VAR 0 1
10742: PPUSH
10743: CALL_OW 74
10747: PPUSH
10748: CALL_OW 112
10752: GO 10788
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10754: LD_VAR 0 1
10758: PPUSH
10759: LD_INT 81
10761: PUSH
10762: LD_INT 3
10764: PUSH
10765: EMPTY
10766: LIST
10767: LIST
10768: PPUSH
10769: CALL_OW 69
10773: PPUSH
10774: LD_VAR 0 1
10778: PPUSH
10779: CALL_OW 74
10783: PPUSH
10784: CALL_OW 115
// end else
10788: GO 10817
// if IsDead ( i ) then
10790: LD_VAR 0 1
10794: PPUSH
10795: CALL_OW 301
10799: IFFALSE 10817
// tmp := tmp diff i ;
10801: LD_ADDR_VAR 0 2
10805: PUSH
10806: LD_VAR 0 2
10810: PUSH
10811: LD_VAR 0 1
10815: DIFF
10816: ST_TO_ADDR
// end ;
10817: GO 10685
10819: POP
10820: POP
// until not tmp ;
10821: LD_VAR 0 2
10825: NOT
10826: IFFALSE 10668
// end ;
10828: PPOPN 4
10830: END
// every 30 30$00 trigger not russianDestroyed do
10831: LD_EXP 2
10835: NOT
10836: IFFALSE 10905
10838: GO 10840
10840: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10841: LD_INT 105000
10843: PUSH
10844: LD_INT 84000
10846: PUSH
10847: LD_INT 63000
10849: PUSH
10850: LD_INT 52500
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: LIST
10857: LIST
10858: PUSH
10859: LD_OWVAR 67
10863: ARRAY
10864: PPUSH
10865: CALL_OW 67
// if russianDestroyed then
10869: LD_EXP 2
10873: IFFALSE 10877
// exit ;
10875: GO 10905
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10877: LD_INT 2
10879: PPUSH
10880: LD_INT 23
10882: PUSH
10883: LD_INT 3
10885: PUSH
10886: LD_INT 1
10888: PUSH
10889: LD_INT 48
10891: PUSH
10892: EMPTY
10893: LIST
10894: LIST
10895: LIST
10896: LIST
10897: PUSH
10898: EMPTY
10899: LIST
10900: PPUSH
10901: CALL 45460 0 2
// end ; end_of_file
10905: END
// export function CustomEvent ( event ) ; begin
10906: LD_INT 0
10908: PPUSH
// end ;
10909: LD_VAR 0 2
10913: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10914: LD_VAR 0 2
10918: PPUSH
10919: LD_VAR 0 3
10923: PPUSH
10924: LD_INT 15
10926: PPUSH
10927: CALL_OW 309
10931: IFFALSE 10940
// YouLost ( MothContaminate ) ;
10933: LD_STRING MothContaminate
10935: PPUSH
10936: CALL_OW 104
// end ;
10940: PPOPN 3
10942: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10943: LD_VAR 0 2
10947: PPUSH
10948: LD_VAR 0 3
10952: PPUSH
10953: LD_INT 15
10955: PPUSH
10956: CALL_OW 309
10960: IFFALSE 10976
// begin wait ( 0 0$6 ) ;
10962: LD_INT 210
10964: PPUSH
10965: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10969: LD_STRING MothContaminateBomb
10971: PPUSH
10972: CALL_OW 104
// end ; end ;
10976: PPOPN 3
10978: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10979: LD_VAR 0 1
10983: PPUSH
10984: CALL 108682 0 1
// if un = JMM then
10988: LD_VAR 0 1
10992: PUSH
10993: LD_EXP 19
10997: EQUAL
10998: IFFALSE 11009
// begin YouLost ( JMM ) ;
11000: LD_STRING JMM
11002: PPUSH
11003: CALL_OW 104
// exit ;
11007: GO 11138
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11009: LD_VAR 0 1
11013: PPUSH
11014: CALL_OW 255
11018: PUSH
11019: LD_INT 2
11021: EQUAL
11022: PUSH
11023: LD_EXP 18
11027: NOT
11028: AND
11029: IFFALSE 11039
// arabianAttacked := true ;
11031: LD_ADDR_EXP 18
11035: PUSH
11036: LD_INT 1
11038: ST_TO_ADDR
// if un = Powell then
11039: LD_VAR 0 1
11043: PUSH
11044: LD_EXP 54
11048: EQUAL
11049: IFFALSE 11059
// americanDestroyed := true ;
11051: LD_ADDR_EXP 4
11055: PUSH
11056: LD_INT 1
11058: ST_TO_ADDR
// if un = Platonov then
11059: LD_VAR 0 1
11063: PUSH
11064: LD_EXP 58
11068: EQUAL
11069: IFFALSE 11079
// russianDestroyed := true ;
11071: LD_ADDR_EXP 2
11075: PUSH
11076: LD_INT 1
11078: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11079: LD_VAR 0 1
11083: PUSH
11084: LD_INT 22
11086: PUSH
11087: LD_INT 7
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: LD_INT 21
11096: PUSH
11097: LD_INT 2
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: PPUSH
11108: CALL_OW 69
11112: IN
11113: IFFALSE 11129
// vehicleLostCounter := vehicleLostCounter + 1 ;
11115: LD_ADDR_EXP 15
11119: PUSH
11120: LD_EXP 15
11124: PUSH
11125: LD_INT 1
11127: PLUS
11128: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11129: LD_VAR 0 1
11133: PPUSH
11134: CALL 48864 0 1
// end ;
11138: PPOPN 1
11140: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11141: LD_VAR 0 1
11145: PPUSH
11146: LD_VAR 0 2
11150: PPUSH
11151: CALL 51196 0 2
// end ;
11155: PPOPN 2
11157: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11158: LD_VAR 0 1
11162: PPUSH
11163: CALL 50264 0 1
// end ;
11167: PPOPN 1
11169: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11170: LD_VAR 0 1
11174: PUSH
11175: LD_INT 22
11177: PUSH
11178: LD_INT 8
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: LD_INT 30
11187: PUSH
11188: LD_INT 2
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PUSH
11195: LD_INT 23
11197: PUSH
11198: LD_INT 3
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PUSH
11205: EMPTY
11206: LIST
11207: LIST
11208: LIST
11209: PPUSH
11210: CALL_OW 69
11214: IN
11215: IFFALSE 11242
// begin ComUpgrade ( building ) ;
11217: LD_VAR 0 1
11221: PPUSH
11222: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11226: LD_EXP 57
11230: PPUSH
11231: LD_VAR 0 1
11235: PPUSH
11236: CALL 59846 0 2
// exit ;
11240: GO 11251
// end ; MCE_BuildingComplete ( building ) ;
11242: LD_VAR 0 1
11246: PPUSH
11247: CALL 50505 0 1
// end ;
11251: PPOPN 1
11253: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11254: LD_VAR 0 1
11258: PPUSH
11259: LD_VAR 0 2
11263: PPUSH
11264: CALL 48560 0 2
// end ;
11268: PPOPN 2
11270: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_VAR 0 2
11280: PPUSH
11281: LD_VAR 0 3
11285: PPUSH
11286: LD_VAR 0 4
11290: PPUSH
11291: LD_VAR 0 5
11295: PPUSH
11296: CALL 48180 0 5
// end ;
11300: PPOPN 5
11302: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11303: LD_VAR 0 1
11307: PPUSH
11308: LD_VAR 0 2
11312: PPUSH
11313: CALL 108802 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11317: LD_VAR 0 1
11321: PPUSH
11322: LD_VAR 0 2
11326: PPUSH
11327: CALL 47771 0 2
// end ;
11331: PPOPN 2
11333: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11334: LD_VAR 0 1
11338: PPUSH
11339: LD_VAR 0 2
11343: PPUSH
11344: LD_VAR 0 3
11348: PPUSH
11349: LD_VAR 0 4
11353: PPUSH
11354: CALL 47609 0 4
// end ;
11358: PPOPN 4
11360: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11361: LD_VAR 0 1
11365: PPUSH
11366: LD_VAR 0 2
11370: PPUSH
11371: LD_VAR 0 3
11375: PPUSH
11376: CALL 47384 0 3
// end ;
11380: PPOPN 3
11382: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11383: LD_VAR 0 1
11387: PPUSH
11388: LD_VAR 0 2
11392: PPUSH
11393: CALL 47269 0 2
// end ;
11397: PPOPN 2
11399: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11400: LD_VAR 0 1
11404: PPUSH
11405: LD_VAR 0 2
11409: PPUSH
11410: CALL 51491 0 2
// end ;
11414: PPOPN 2
11416: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11417: LD_VAR 0 1
11421: PPUSH
11422: LD_VAR 0 2
11426: PPUSH
11427: LD_VAR 0 3
11431: PPUSH
11432: LD_VAR 0 4
11436: PPUSH
11437: CALL 51707 0 4
// end ;
11441: PPOPN 4
11443: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11444: LD_VAR 0 1
11448: PPUSH
11449: LD_VAR 0 2
11453: PPUSH
11454: CALL 47078 0 2
// end ;
11458: PPOPN 2
11460: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11461: LD_VAR 0 1
11465: PPUSH
11466: CALL 108786 0 1
// end ; end_of_file
11470: PPOPN 1
11472: END
// export function Action ; begin
11473: LD_INT 0
11475: PPUSH
// InGameOn ;
11476: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11480: LD_INT 206
11482: PPUSH
11483: LD_INT 11
11485: PPUSH
11486: CALL_OW 86
// wait ( 0 0$1 ) ;
11490: LD_INT 35
11492: PPUSH
11493: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11497: LD_EXP 19
11501: PPUSH
11502: LD_STRING DStart-JMM-JMM-1
11504: PPUSH
11505: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11509: LD_EXP 51
11513: PPUSH
11514: LD_STRING DStart-JMM-Bur-1
11516: PPUSH
11517: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11521: LD_EXP 19
11525: PPUSH
11526: LD_STRING DStart-JMM-JMM-2
11528: PPUSH
11529: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11533: LD_EXP 51
11537: PPUSH
11538: LD_STRING DStart-JMM-Bur-2
11540: PPUSH
11541: CALL_OW 88
// InGameOff ;
11545: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11549: LD_STRING MStart
11551: PPUSH
11552: CALL_OW 337
// SaveForQuickRestart ;
11556: CALL_OW 22
// end ;
11560: LD_VAR 0 1
11564: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11565: LD_INT 7
11567: PPUSH
11568: LD_INT 255
11570: PPUSH
11571: LD_INT 219
11573: PPUSH
11574: CALL_OW 293
11578: IFFALSE 12187
11580: GO 11582
11582: DISABLE
11583: LD_INT 0
11585: PPUSH
// begin wait ( 0 0$3 ) ;
11586: LD_INT 105
11588: PPUSH
11589: CALL_OW 67
// alienSpotted := true ;
11593: LD_ADDR_EXP 10
11597: PUSH
11598: LD_INT 1
11600: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11601: LD_ADDR_VAR 0 1
11605: PUSH
11606: LD_INT 22
11608: PUSH
11609: LD_INT 7
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PUSH
11616: LD_INT 23
11618: PUSH
11619: LD_INT 3
11621: PUSH
11622: EMPTY
11623: LIST
11624: LIST
11625: PUSH
11626: LD_INT 21
11628: PUSH
11629: LD_INT 1
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: PUSH
11636: LD_INT 26
11638: PUSH
11639: LD_INT 1
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: EMPTY
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: PPUSH
11652: CALL_OW 69
11656: PUSH
11657: LD_EXP 51
11661: PUSH
11662: LD_EXP 39
11666: PUSH
11667: LD_EXP 41
11671: PUSH
11672: LD_EXP 42
11676: PUSH
11677: LD_EXP 49
11681: PUSH
11682: LD_EXP 48
11686: PUSH
11687: LD_EXP 43
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: DIFF
11701: ST_TO_ADDR
// DialogueOn ;
11702: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11706: LD_INT 255
11708: PPUSH
11709: LD_INT 219
11711: PPUSH
11712: LD_INT 7
11714: PPUSH
11715: LD_INT 20
11717: NEG
11718: PPUSH
11719: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11723: LD_INT 255
11725: PPUSH
11726: LD_INT 219
11728: PPUSH
11729: CALL_OW 86
// if speaker then
11733: LD_VAR 0 1
11737: IFFALSE 11755
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11739: LD_VAR 0 1
11743: PUSH
11744: LD_INT 1
11746: ARRAY
11747: PPUSH
11748: LD_STRING DAlienBase-RSol1-1
11750: PPUSH
11751: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11755: LD_EXP 19
11759: PPUSH
11760: LD_STRING DAlienBase-JMM-1
11762: PPUSH
11763: CALL_OW 88
// if IsOk ( Burlak ) then
11767: LD_EXP 51
11771: PPUSH
11772: CALL_OW 302
11776: IFFALSE 11797
// begin dwait ( 0 0$1 ) ;
11778: LD_INT 35
11780: PPUSH
11781: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11785: LD_EXP 51
11789: PPUSH
11790: LD_STRING DAlienBase-Bur-1
11792: PPUSH
11793: CALL_OW 88
// end ; if IsOk ( Roth ) then
11797: LD_EXP 20
11801: PPUSH
11802: CALL_OW 302
11806: IFFALSE 11820
// Say ( Roth , DAlienBase-Roth-1 ) ;
11808: LD_EXP 20
11812: PPUSH
11813: LD_STRING DAlienBase-Roth-1
11815: PPUSH
11816: CALL_OW 88
// if IsOk ( Gossudarov ) then
11820: LD_EXP 37
11824: PPUSH
11825: CALL_OW 302
11829: IFFALSE 11845
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11831: LD_EXP 37
11835: PPUSH
11836: LD_STRING DAlienBase-Gos-1
11838: PPUSH
11839: CALL_OW 88
11843: GO 11962
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11845: LD_ADDR_VAR 0 1
11849: PUSH
11850: LD_INT 22
11852: PUSH
11853: LD_INT 7
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 25
11862: PUSH
11863: LD_INT 4
11865: PUSH
11866: EMPTY
11867: LIST
11868: LIST
11869: PUSH
11870: LD_INT 21
11872: PUSH
11873: LD_INT 1
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PUSH
11880: LD_INT 26
11882: PUSH
11883: LD_INT 1
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: EMPTY
11891: LIST
11892: LIST
11893: LIST
11894: LIST
11895: PPUSH
11896: CALL_OW 69
11900: PUSH
11901: LD_EXP 20
11905: PUSH
11906: LD_EXP 19
11910: PUSH
11911: LD_EXP 51
11915: PUSH
11916: LD_EXP 39
11920: PUSH
11921: LD_EXP 49
11925: PUSH
11926: LD_EXP 48
11930: PUSH
11931: EMPTY
11932: LIST
11933: LIST
11934: LIST
11935: LIST
11936: LIST
11937: LIST
11938: DIFF
11939: ST_TO_ADDR
// if speaker then
11940: LD_VAR 0 1
11944: IFFALSE 11962
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11946: LD_VAR 0 1
11950: PUSH
11951: LD_INT 1
11953: ARRAY
11954: PPUSH
11955: LD_STRING DAlienBase-Sci1-1
11957: PPUSH
11958: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11962: LD_INT 255
11964: PPUSH
11965: LD_INT 219
11967: PPUSH
11968: LD_INT 7
11970: PPUSH
11971: CALL_OW 331
// DialogueOff ;
11975: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11979: LD_INT 35
11981: PPUSH
11982: CALL_OW 67
// until IsSelected ( alien ) ;
11986: LD_INT 1
11988: PPUSH
11989: CALL_OW 306
11993: IFFALSE 11979
// if not artifactIResearched or not artifactIIResearched then
11995: LD_EXP 12
11999: NOT
12000: PUSH
12001: LD_EXP 13
12005: NOT
12006: OR
12007: IFFALSE 12187
// begin if IsOk ( Roth ) then
12009: LD_EXP 20
12013: PPUSH
12014: CALL_OW 302
12018: IFFALSE 12034
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12020: LD_EXP 20
12024: PPUSH
12025: LD_STRING DAlieBaseNotReady-Roth-1
12027: PPUSH
12028: CALL_OW 88
12032: GO 12187
// if IsOk ( Gossudarov ) then
12034: LD_EXP 37
12038: PPUSH
12039: CALL_OW 302
12043: IFFALSE 12059
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12045: LD_EXP 37
12049: PPUSH
12050: LD_STRING DAlieBaseNotReady-Gos-1
12052: PPUSH
12053: CALL_OW 88
12057: GO 12187
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12059: LD_ADDR_VAR 0 1
12063: PUSH
12064: LD_INT 22
12066: PUSH
12067: LD_INT 7
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PUSH
12074: LD_INT 23
12076: PUSH
12077: LD_INT 3
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 25
12086: PUSH
12087: LD_INT 4
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: LD_INT 21
12096: PUSH
12097: LD_INT 1
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PUSH
12104: LD_INT 26
12106: PUSH
12107: LD_INT 1
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: PUSH
12114: EMPTY
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: PPUSH
12121: CALL_OW 69
12125: PUSH
12126: LD_EXP 20
12130: PUSH
12131: LD_EXP 19
12135: PUSH
12136: LD_EXP 51
12140: PUSH
12141: LD_EXP 39
12145: PUSH
12146: LD_EXP 49
12150: PUSH
12151: LD_EXP 48
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: DIFF
12164: ST_TO_ADDR
// if speaker then
12165: LD_VAR 0 1
12169: IFFALSE 12187
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12171: LD_VAR 0 1
12175: PUSH
12176: LD_INT 1
12178: ARRAY
12179: PPUSH
12180: LD_STRING DAlieBaseNotReady-RSci1-1
12182: PPUSH
12183: CALL_OW 88
// end ; end ; end ;
12187: PPOPN 1
12189: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12190: LD_INT 24
12192: PPUSH
12193: LD_INT 7
12195: PPUSH
12196: CALL_OW 321
12200: PUSH
12201: LD_INT 2
12203: EQUAL
12204: IFFALSE 12895
12206: GO 12208
12208: DISABLE
12209: LD_INT 0
12211: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12212: LD_ADDR_VAR 0 1
12216: PUSH
12217: LD_INT 22
12219: PUSH
12220: LD_INT 7
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: PUSH
12227: LD_INT 23
12229: PUSH
12230: LD_INT 3
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: PUSH
12237: LD_INT 25
12239: PUSH
12240: LD_INT 4
12242: PUSH
12243: EMPTY
12244: LIST
12245: LIST
12246: PUSH
12247: LD_INT 21
12249: PUSH
12250: LD_INT 1
12252: PUSH
12253: EMPTY
12254: LIST
12255: LIST
12256: PUSH
12257: LD_INT 26
12259: PUSH
12260: LD_INT 1
12262: PUSH
12263: EMPTY
12264: LIST
12265: LIST
12266: PUSH
12267: EMPTY
12268: LIST
12269: LIST
12270: LIST
12271: LIST
12272: LIST
12273: PPUSH
12274: CALL_OW 69
12278: PUSH
12279: LD_EXP 20
12283: PUSH
12284: LD_EXP 19
12288: PUSH
12289: LD_EXP 51
12293: PUSH
12294: LD_EXP 39
12298: PUSH
12299: LD_EXP 49
12303: PUSH
12304: LD_EXP 48
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: DIFF
12317: ST_TO_ADDR
// if not speaker then
12318: LD_VAR 0 1
12322: NOT
12323: IFFALSE 12327
// exit ;
12325: GO 12895
// DialogueOn ;
12327: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12331: LD_VAR 0 1
12335: PUSH
12336: LD_INT 1
12338: ARRAY
12339: PPUSH
12340: LD_STRING DArtefTechnology-RSci1-1
12342: PPUSH
12343: CALL_OW 88
// if IsOk ( Burlak ) then
12347: LD_EXP 51
12351: PPUSH
12352: CALL_OW 302
12356: IFFALSE 12370
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12358: LD_EXP 51
12362: PPUSH
12363: LD_STRING DArtefTechnology-Bur-1
12365: PPUSH
12366: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12370: LD_VAR 0 1
12374: PUSH
12375: LD_INT 1
12377: ARRAY
12378: PPUSH
12379: LD_STRING DArtefTechnology-RSci1-2
12381: PPUSH
12382: CALL_OW 88
// if Denis then
12386: LD_EXP 25
12390: IFFALSE 12407
// speaker := [ Denis ] else
12392: LD_ADDR_VAR 0 1
12396: PUSH
12397: LD_EXP 25
12401: PUSH
12402: EMPTY
12403: LIST
12404: ST_TO_ADDR
12405: GO 12513
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12407: LD_ADDR_VAR 0 1
12411: PUSH
12412: LD_INT 22
12414: PUSH
12415: LD_INT 7
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: PUSH
12422: LD_INT 23
12424: PUSH
12425: LD_INT 1
12427: PUSH
12428: EMPTY
12429: LIST
12430: LIST
12431: PUSH
12432: LD_INT 25
12434: PUSH
12435: LD_INT 4
12437: PUSH
12438: EMPTY
12439: LIST
12440: LIST
12441: PUSH
12442: LD_INT 21
12444: PUSH
12445: LD_INT 1
12447: PUSH
12448: EMPTY
12449: LIST
12450: LIST
12451: PUSH
12452: LD_INT 26
12454: PUSH
12455: LD_INT 1
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: PUSH
12462: EMPTY
12463: LIST
12464: LIST
12465: LIST
12466: LIST
12467: LIST
12468: PPUSH
12469: CALL_OW 69
12473: PUSH
12474: LD_EXP 20
12478: PUSH
12479: LD_EXP 19
12483: PUSH
12484: LD_EXP 51
12488: PUSH
12489: LD_EXP 39
12493: PUSH
12494: LD_EXP 49
12498: PUSH
12499: LD_EXP 48
12503: PUSH
12504: EMPTY
12505: LIST
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: LIST
12511: DIFF
12512: ST_TO_ADDR
// if speaker then
12513: LD_VAR 0 1
12517: IFFALSE 12535
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12519: LD_VAR 0 1
12523: PUSH
12524: LD_INT 1
12526: ARRAY
12527: PPUSH
12528: LD_STRING DArtefTechnology-Sci1-2
12530: PPUSH
12531: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12535: LD_ADDR_VAR 0 1
12539: PUSH
12540: LD_INT 22
12542: PUSH
12543: LD_INT 7
12545: PUSH
12546: EMPTY
12547: LIST
12548: LIST
12549: PUSH
12550: LD_INT 23
12552: PUSH
12553: LD_INT 3
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: PUSH
12560: LD_INT 25
12562: PUSH
12563: LD_INT 4
12565: PUSH
12566: EMPTY
12567: LIST
12568: LIST
12569: PUSH
12570: LD_INT 21
12572: PUSH
12573: LD_INT 1
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: PUSH
12580: LD_INT 26
12582: PUSH
12583: LD_INT 1
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: PPUSH
12597: CALL_OW 69
12601: PUSH
12602: LD_EXP 20
12606: PUSH
12607: LD_EXP 19
12611: PUSH
12612: LD_EXP 51
12616: PUSH
12617: LD_EXP 39
12621: PUSH
12622: LD_EXP 49
12626: PUSH
12627: LD_EXP 48
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: LIST
12636: LIST
12637: LIST
12638: LIST
12639: DIFF
12640: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12641: LD_VAR 0 1
12645: PUSH
12646: LD_EXP 9
12650: PUSH
12651: LD_EXP 5
12655: OR
12656: AND
12657: IFFALSE 12891
// begin if arabianDestroyed and IsOk ( Burlak ) then
12659: LD_EXP 5
12663: PUSH
12664: LD_EXP 51
12668: PPUSH
12669: CALL_OW 302
12673: AND
12674: IFFALSE 12690
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12676: LD_EXP 51
12680: PPUSH
12681: LD_STRING DArtefTechnology-Bur-2
12683: PPUSH
12684: CALL_OW 88
12688: GO 12702
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12690: LD_EXP 19
12694: PPUSH
12695: LD_STRING DArtefTechnology-JMM-2
12697: PPUSH
12698: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12702: LD_VAR 0 1
12706: PUSH
12707: LD_INT 1
12709: ARRAY
12710: PPUSH
12711: LD_STRING DArtefTechnology-RSci1-3
12713: PPUSH
12714: CALL_OW 88
// if Denis then
12718: LD_EXP 25
12722: IFFALSE 12739
// speaker := [ Denis ] else
12724: LD_ADDR_VAR 0 1
12728: PUSH
12729: LD_EXP 25
12733: PUSH
12734: EMPTY
12735: LIST
12736: ST_TO_ADDR
12737: GO 12845
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12739: LD_ADDR_VAR 0 1
12743: PUSH
12744: LD_INT 22
12746: PUSH
12747: LD_INT 7
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 23
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: LD_INT 25
12766: PUSH
12767: LD_INT 4
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: PUSH
12774: LD_INT 21
12776: PUSH
12777: LD_INT 1
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: PUSH
12784: LD_INT 26
12786: PUSH
12787: LD_INT 1
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: PPUSH
12801: CALL_OW 69
12805: PUSH
12806: LD_EXP 20
12810: PUSH
12811: LD_EXP 19
12815: PUSH
12816: LD_EXP 51
12820: PUSH
12821: LD_EXP 39
12825: PUSH
12826: LD_EXP 49
12830: PUSH
12831: LD_EXP 48
12835: PUSH
12836: EMPTY
12837: LIST
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: DIFF
12844: ST_TO_ADDR
// if speaker then
12845: LD_VAR 0 1
12849: IFFALSE 12891
// if alienSpotted then
12851: LD_EXP 10
12855: IFFALSE 12875
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12857: LD_VAR 0 1
12861: PUSH
12862: LD_INT 1
12864: ARRAY
12865: PPUSH
12866: LD_STRING DArtefTechnology-Sci1-3
12868: PPUSH
12869: CALL_OW 88
12873: GO 12891
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12875: LD_VAR 0 1
12879: PUSH
12880: LD_INT 1
12882: ARRAY
12883: PPUSH
12884: LD_STRING DArtefTechnology-Sci1-3a
12886: PPUSH
12887: CALL_OW 88
// end ; DialogueOff ;
12891: CALL_OW 7
// end ;
12895: PPOPN 1
12897: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12898: LD_EXP 12
12902: IFFALSE 13105
12904: GO 12906
12906: DISABLE
12907: LD_INT 0
12909: PPUSH
// begin if Denis then
12910: LD_EXP 25
12914: IFFALSE 12931
// speaker := [ Denis ] else
12916: LD_ADDR_VAR 0 1
12920: PUSH
12921: LD_EXP 25
12925: PUSH
12926: EMPTY
12927: LIST
12928: ST_TO_ADDR
12929: GO 13037
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12931: LD_ADDR_VAR 0 1
12935: PUSH
12936: LD_INT 22
12938: PUSH
12939: LD_INT 7
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 23
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: LD_INT 25
12958: PUSH
12959: LD_INT 4
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: LD_INT 21
12968: PUSH
12969: LD_INT 1
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PUSH
12976: LD_INT 26
12978: PUSH
12979: LD_INT 1
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: LIST
12992: PPUSH
12993: CALL_OW 69
12997: PUSH
12998: LD_EXP 20
13002: PUSH
13003: LD_EXP 19
13007: PUSH
13008: LD_EXP 51
13012: PUSH
13013: LD_EXP 39
13017: PUSH
13018: LD_EXP 49
13022: PUSH
13023: LD_EXP 48
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: DIFF
13036: ST_TO_ADDR
// if not speaker then
13037: LD_VAR 0 1
13041: NOT
13042: IFFALSE 13046
// exit ;
13044: GO 13105
// DialogueOn ;
13046: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13050: LD_VAR 0 1
13054: PUSH
13055: LD_INT 1
13057: ARRAY
13058: PPUSH
13059: LD_STRING DArtefTechnologyAm-Sci1-1
13061: PPUSH
13062: CALL_OW 88
// if IsOk ( Burlak ) then
13066: LD_EXP 51
13070: PPUSH
13071: CALL_OW 302
13075: IFFALSE 13089
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13077: LD_EXP 51
13081: PPUSH
13082: LD_STRING DArtefTechnologyAm-Bur-1
13084: PPUSH
13085: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13089: LD_EXP 19
13093: PPUSH
13094: LD_STRING DArtefTechnologyAm-JMM-1
13096: PPUSH
13097: CALL_OW 88
// DialogueOff ;
13101: CALL_OW 7
// end ;
13105: PPOPN 1
13107: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13108: LD_EXP 13
13112: IFFALSE 13314
13114: GO 13116
13116: DISABLE
13117: LD_INT 0
13119: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13120: LD_ADDR_VAR 0 1
13124: PUSH
13125: LD_INT 22
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: LD_INT 23
13137: PUSH
13138: LD_INT 3
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: LD_INT 25
13147: PUSH
13148: LD_INT 4
13150: PUSH
13151: EMPTY
13152: LIST
13153: LIST
13154: PUSH
13155: LD_INT 21
13157: PUSH
13158: LD_INT 1
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: LD_INT 26
13167: PUSH
13168: LD_INT 1
13170: PUSH
13171: EMPTY
13172: LIST
13173: LIST
13174: PUSH
13175: EMPTY
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: LIST
13181: PPUSH
13182: CALL_OW 69
13186: PUSH
13187: LD_EXP 20
13191: PUSH
13192: LD_EXP 19
13196: PUSH
13197: LD_EXP 51
13201: PUSH
13202: LD_EXP 39
13206: PUSH
13207: LD_EXP 49
13211: PUSH
13212: LD_EXP 48
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: DIFF
13225: ST_TO_ADDR
// if not speaker then
13226: LD_VAR 0 1
13230: NOT
13231: IFFALSE 13235
// exit ;
13233: GO 13314
// DialogueOn ;
13235: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13239: LD_VAR 0 1
13243: PUSH
13244: LD_VAR 0 1
13248: ARRAY
13249: PPUSH
13250: LD_STRING DArtefTechnologyRu-RSci1-1
13252: PPUSH
13253: CALL_OW 88
// if IsOk ( Burlak ) then
13257: LD_EXP 51
13261: PPUSH
13262: CALL_OW 302
13266: IFFALSE 13280
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13268: LD_EXP 51
13272: PPUSH
13273: LD_STRING DArtefTechnologyRu-Bur-1
13275: PPUSH
13276: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13280: LD_VAR 0 1
13284: PUSH
13285: LD_VAR 0 1
13289: ARRAY
13290: PPUSH
13291: LD_STRING DArtefTechnologyRu-RSci1-2
13293: PPUSH
13294: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13298: LD_EXP 19
13302: PPUSH
13303: LD_STRING DArtefTechnologyRu-JMM-1
13305: PPUSH
13306: CALL_OW 88
// DialogueOff ;
13310: CALL_OW 7
// end ;
13314: PPOPN 1
13316: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13317: LD_INT 24
13319: PPUSH
13320: LD_INT 7
13322: PPUSH
13323: CALL_OW 321
13327: PUSH
13328: LD_INT 2
13330: EQUAL
13331: PUSH
13332: LD_INT 1
13334: PPUSH
13335: CALL_OW 255
13339: PUSH
13340: LD_INT 7
13342: EQUAL
13343: AND
13344: IFFALSE 13512
13346: GO 13348
13348: DISABLE
13349: LD_INT 0
13351: PPUSH
// begin if Denis then
13352: LD_EXP 25
13356: IFFALSE 13373
// speaker := [ Denis ] else
13358: LD_ADDR_VAR 0 1
13362: PUSH
13363: LD_EXP 25
13367: PUSH
13368: EMPTY
13369: LIST
13370: ST_TO_ADDR
13371: GO 13479
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13373: LD_ADDR_VAR 0 1
13377: PUSH
13378: LD_INT 22
13380: PUSH
13381: LD_INT 7
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: PUSH
13388: LD_INT 23
13390: PUSH
13391: LD_INT 1
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: LD_INT 25
13400: PUSH
13401: LD_INT 4
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: PUSH
13408: LD_INT 21
13410: PUSH
13411: LD_INT 1
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: PUSH
13418: LD_INT 26
13420: PUSH
13421: LD_INT 1
13423: PUSH
13424: EMPTY
13425: LIST
13426: LIST
13427: PUSH
13428: EMPTY
13429: LIST
13430: LIST
13431: LIST
13432: LIST
13433: LIST
13434: PPUSH
13435: CALL_OW 69
13439: PUSH
13440: LD_EXP 20
13444: PUSH
13445: LD_EXP 19
13449: PUSH
13450: LD_EXP 51
13454: PUSH
13455: LD_EXP 39
13459: PUSH
13460: LD_EXP 49
13464: PUSH
13465: LD_EXP 48
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: LIST
13474: LIST
13475: LIST
13476: LIST
13477: DIFF
13478: ST_TO_ADDR
// if not speaker then
13479: LD_VAR 0 1
13483: NOT
13484: IFFALSE 13488
// exit ;
13486: GO 13512
// DialogueOn ;
13488: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13492: LD_VAR 0 1
13496: PUSH
13497: LD_INT 1
13499: ARRAY
13500: PPUSH
13501: LD_STRING DArtefTechnologyArStart-Sci1-1
13503: PPUSH
13504: CALL_OW 88
// DialogueOff ;
13508: CALL_OW 7
// end ;
13512: PPOPN 1
13514: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13515: LD_EXP 14
13519: IFFALSE 13800
13521: GO 13523
13523: DISABLE
13524: LD_INT 0
13526: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13527: LD_ADDR_VAR 0 1
13531: PUSH
13532: LD_INT 22
13534: PUSH
13535: LD_INT 7
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: PUSH
13542: LD_INT 23
13544: PUSH
13545: LD_INT 3
13547: PUSH
13548: EMPTY
13549: LIST
13550: LIST
13551: PUSH
13552: LD_INT 25
13554: PUSH
13555: LD_INT 4
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PUSH
13562: LD_INT 21
13564: PUSH
13565: LD_INT 1
13567: PUSH
13568: EMPTY
13569: LIST
13570: LIST
13571: PUSH
13572: LD_INT 26
13574: PUSH
13575: LD_INT 1
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: LIST
13586: LIST
13587: LIST
13588: PPUSH
13589: CALL_OW 69
13593: PUSH
13594: LD_EXP 20
13598: PUSH
13599: LD_EXP 19
13603: PUSH
13604: LD_EXP 51
13608: PUSH
13609: LD_EXP 39
13613: PUSH
13614: LD_EXP 49
13618: PUSH
13619: LD_EXP 48
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: LIST
13631: DIFF
13632: ST_TO_ADDR
// if not speaker then
13633: LD_VAR 0 1
13637: NOT
13638: IFFALSE 13642
// exit ;
13640: GO 13800
// DialogueOn ;
13642: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13646: LD_VAR 0 1
13650: PUSH
13651: LD_INT 1
13653: ARRAY
13654: PPUSH
13655: LD_STRING DArtefTechnologyAr-RSci1-1
13657: PPUSH
13658: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13662: LD_EXP 19
13666: PPUSH
13667: LD_STRING DArtefTechnologyAr-JMM-1
13669: PPUSH
13670: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13674: LD_VAR 0 1
13678: PUSH
13679: LD_INT 1
13681: ARRAY
13682: PPUSH
13683: LD_STRING DArtefTechnologyAr-RSci1-2
13685: PPUSH
13686: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13690: LD_EXP 19
13694: PPUSH
13695: LD_STRING DArtefTechnologyAr-JMM-2
13697: PPUSH
13698: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13702: LD_VAR 0 1
13706: PUSH
13707: LD_INT 1
13709: ARRAY
13710: PPUSH
13711: LD_STRING DArtefTechnologyAr-RSci1-3
13713: PPUSH
13714: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13718: LD_EXP 19
13722: PPUSH
13723: LD_STRING DArtefTechnologyAr-JMM-3
13725: PPUSH
13726: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13730: LD_VAR 0 1
13734: PUSH
13735: LD_INT 1
13737: ARRAY
13738: PPUSH
13739: LD_STRING DArtefTechnologyAr-RSci1-4
13741: PPUSH
13742: CALL_OW 88
// if IsOk ( Burlak ) then
13746: LD_EXP 51
13750: PPUSH
13751: CALL_OW 302
13755: IFFALSE 13769
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13757: LD_EXP 51
13761: PPUSH
13762: LD_STRING DArtefTechnologyAr-Bur-4
13764: PPUSH
13765: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13769: LD_EXP 19
13773: PPUSH
13774: LD_STRING DArtefTechnologyAr-JMM-4
13776: PPUSH
13777: CALL_OW 88
// DialogueOff ;
13781: CALL_OW 7
// wait ( 0 0$45 ) ;
13785: LD_INT 1575
13787: PPUSH
13788: CALL_OW 67
// spawnOmar := true ;
13792: LD_ADDR_EXP 11
13796: PUSH
13797: LD_INT 1
13799: ST_TO_ADDR
// end ;
13800: PPOPN 1
13802: END
// every 0 0$1 trigger spawnOmar do
13803: LD_EXP 11
13807: IFFALSE 14187
13809: GO 13811
13811: DISABLE
// begin PrepareOmarAli ;
13812: CALL 7193 0 0
// if not HasTask ( Omar ) then
13816: LD_EXP 55
13820: PPUSH
13821: CALL_OW 314
13825: NOT
13826: IFFALSE 13843
// ComMoveXY ( Omar , 252 , 220 ) ;
13828: LD_EXP 55
13832: PPUSH
13833: LD_INT 252
13835: PPUSH
13836: LD_INT 220
13838: PPUSH
13839: CALL_OW 111
// if not Omar then
13843: LD_EXP 55
13847: NOT
13848: IFFALSE 13852
// exit ;
13850: GO 14187
// repeat wait ( 0 0$1 ) ;
13852: LD_INT 35
13854: PPUSH
13855: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13859: LD_EXP 55
13863: PPUSH
13864: CALL_OW 314
13868: NOT
13869: PUSH
13870: LD_EXP 55
13874: PPUSH
13875: LD_INT 252
13877: PPUSH
13878: LD_INT 220
13880: PPUSH
13881: CALL_OW 297
13885: PUSH
13886: LD_INT 6
13888: GREATER
13889: AND
13890: IFFALSE 13907
// ComMoveXY ( Omar , 252 , 220 ) ;
13892: LD_EXP 55
13896: PPUSH
13897: LD_INT 252
13899: PPUSH
13900: LD_INT 220
13902: PPUSH
13903: CALL_OW 111
// until See ( 7 , Omar ) ;
13907: LD_INT 7
13909: PPUSH
13910: LD_EXP 55
13914: PPUSH
13915: CALL_OW 292
13919: IFFALSE 13852
// CenterNowOnUnits ( Omar ) ;
13921: LD_EXP 55
13925: PPUSH
13926: CALL_OW 87
// DialogueOn ;
13930: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13934: LD_EXP 55
13938: PPUSH
13939: LD_STRING DOmar-Omar-1
13941: PPUSH
13942: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13946: LD_EXP 19
13950: PPUSH
13951: LD_STRING DOmar-JMM-1
13953: PPUSH
13954: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13958: LD_EXP 55
13962: PPUSH
13963: LD_STRING DOmar-Omar-2
13965: PPUSH
13966: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13970: LD_EXP 19
13974: PPUSH
13975: LD_STRING DOmar-JMM-2
13977: PPUSH
13978: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13982: LD_EXP 55
13986: PPUSH
13987: LD_STRING DOmar-Omar-3
13989: PPUSH
13990: CALL_OW 88
// if IsOk ( Burlak ) then
13994: LD_EXP 51
13998: PPUSH
13999: CALL_OW 302
14003: IFFALSE 14019
// Say ( Burlak , DOmar-Bur-3 ) else
14005: LD_EXP 51
14009: PPUSH
14010: LD_STRING DOmar-Bur-3
14012: PPUSH
14013: CALL_OW 88
14017: GO 14031
// Say ( JMM , DOmar-JMM-3 ) ;
14019: LD_EXP 19
14023: PPUSH
14024: LD_STRING DOmar-JMM-3
14026: PPUSH
14027: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14031: LD_EXP 55
14035: PPUSH
14036: LD_STRING DOmar-Omar-4
14038: PPUSH
14039: CALL_OW 88
// case Query ( QAccept ) of 1 :
14043: LD_STRING QAccept
14045: PPUSH
14046: CALL_OW 97
14050: PUSH
14051: LD_INT 1
14053: DOUBLE
14054: EQUAL
14055: IFTRUE 14059
14057: GO 14095
14059: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14060: LD_EXP 19
14064: PPUSH
14065: LD_STRING DQrAccept#1-JMM-1
14067: PPUSH
14068: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14072: LD_EXP 55
14076: PPUSH
14077: LD_INT 7
14079: PPUSH
14080: CALL_OW 235
// ComStop ( Omar ) ;
14084: LD_EXP 55
14088: PPUSH
14089: CALL_OW 141
// end ; 2 :
14093: GO 14144
14095: LD_INT 2
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14143
14103: POP
// begin if IsOk ( Burlak ) then
14104: LD_EXP 51
14108: PPUSH
14109: CALL_OW 302
14113: IFFALSE 14129
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14115: LD_EXP 51
14119: PPUSH
14120: LD_STRING DQrAccept#2-Bur-1
14122: PPUSH
14123: CALL_OW 88
14127: GO 14141
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14129: LD_EXP 19
14133: PPUSH
14134: LD_STRING DQrAccept#2-JMM-1
14136: PPUSH
14137: CALL_OW 88
// end ; end ;
14141: GO 14144
14143: POP
// DialogueOff ;
14144: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14148: LD_EXP 55
14152: PPUSH
14153: CALL_OW 255
14157: PUSH
14158: LD_INT 7
14160: EQUAL
14161: IFFALSE 14172
// begin SetAchievement ( ACH_OMAR ) ;
14163: LD_STRING ACH_OMAR
14165: PPUSH
14166: CALL_OW 543
// exit ;
14170: GO 14187
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14172: LD_EXP 55
14176: PPUSH
14177: LD_INT 202
14179: PPUSH
14180: LD_INT 115
14182: PPUSH
14183: CALL_OW 111
// end ;
14187: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14188: LD_EXP 55
14192: PPUSH
14193: LD_INT 200
14195: PPUSH
14196: LD_INT 98
14198: PPUSH
14199: CALL_OW 297
14203: PUSH
14204: LD_INT 40
14206: LESS
14207: PUSH
14208: LD_EXP 2
14212: AND
14213: IFFALSE 14431
14215: GO 14217
14217: DISABLE
// begin SetSide ( Omar , 5 ) ;
14218: LD_EXP 55
14222: PPUSH
14223: LD_INT 5
14225: PPUSH
14226: CALL_OW 235
// if IsInUnit ( Omar ) then
14230: LD_EXP 55
14234: PPUSH
14235: CALL_OW 310
14239: IFFALSE 14250
// ComExitVehicle ( Omar ) ;
14241: LD_EXP 55
14245: PPUSH
14246: CALL_OW 121
// if IsInUnit ( Omar ) then
14250: LD_EXP 55
14254: PPUSH
14255: CALL_OW 310
14259: IFFALSE 14270
// ComExitBuilding ( Omar ) ;
14261: LD_EXP 55
14265: PPUSH
14266: CALL_OW 122
// wait ( 0 0$1 ) ;
14270: LD_INT 35
14272: PPUSH
14273: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14277: LD_EXP 55
14281: PPUSH
14282: LD_INT 203
14284: PPUSH
14285: LD_INT 120
14287: PPUSH
14288: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14292: LD_INT 35
14294: PPUSH
14295: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14299: LD_EXP 55
14303: PPUSH
14304: CALL_OW 306
14308: PUSH
14309: LD_EXP 55
14313: PPUSH
14314: LD_INT 203
14316: PPUSH
14317: LD_INT 120
14319: PPUSH
14320: CALL_OW 297
14324: PUSH
14325: LD_INT 6
14327: LESS
14328: OR
14329: IFFALSE 14292
// CenterNowOnUnits ( Omar ) ;
14331: LD_EXP 55
14335: PPUSH
14336: CALL_OW 87
// DialogueOn ;
14340: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14344: LD_EXP 19
14348: PPUSH
14349: LD_STRING DOmarContam-JMM-1
14351: PPUSH
14352: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14356: LD_EXP 55
14360: PPUSH
14361: LD_STRING DOmarContam-Omar-1
14363: PPUSH
14364: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14368: LD_EXP 19
14372: PPUSH
14373: LD_STRING DOmarContam-JMM-2
14375: PPUSH
14376: CALL_OW 88
// DialogueOff ;
14380: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14384: LD_INT 5
14386: PPUSH
14387: LD_INT 7
14389: PPUSH
14390: LD_INT 2
14392: PPUSH
14393: LD_INT 1
14395: PPUSH
14396: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14400: LD_INT 105
14402: PPUSH
14403: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14407: LD_EXP 55
14411: PPUSH
14412: LD_INT 203
14414: PPUSH
14415: LD_INT 120
14417: PPUSH
14418: CALL_OW 307
14422: IFFALSE 14400
// YouLost ( MothContaminate ) ;
14424: LD_STRING MothContaminate
14426: PPUSH
14427: CALL_OW 104
// end ;
14431: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14432: LD_EXP 4
14436: NOT
14437: PUSH
14438: LD_INT 22
14440: PUSH
14441: LD_INT 1
14443: PUSH
14444: EMPTY
14445: LIST
14446: LIST
14447: PUSH
14448: LD_INT 34
14450: PUSH
14451: LD_INT 8
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PPUSH
14462: CALL_OW 69
14466: AND
14467: IFFALSE 14586
14469: GO 14471
14471: DISABLE
// begin wait ( 0 0$5 ) ;
14472: LD_INT 175
14474: PPUSH
14475: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14479: LD_EXP 54
14483: PPUSH
14484: CALL_OW 302
14488: NOT
14489: PUSH
14490: LD_INT 22
14492: PUSH
14493: LD_INT 1
14495: PUSH
14496: EMPTY
14497: LIST
14498: LIST
14499: PUSH
14500: LD_INT 34
14502: PUSH
14503: LD_INT 8
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: PUSH
14510: EMPTY
14511: LIST
14512: LIST
14513: PPUSH
14514: CALL_OW 69
14518: NOT
14519: OR
14520: IFFALSE 14524
// exit ;
14522: GO 14586
// DialogueOn ;
14524: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14528: LD_EXP 54
14532: PPUSH
14533: LD_STRING DWinAmericans-Pow-1
14535: PPUSH
14536: CALL_OW 94
// if IsOk ( Burlak ) then
14540: LD_EXP 51
14544: PPUSH
14545: CALL_OW 302
14549: IFFALSE 14563
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14551: LD_EXP 51
14555: PPUSH
14556: LD_STRING DWinAmericans-Bur-1
14558: PPUSH
14559: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14563: LD_EXP 19
14567: PPUSH
14568: LD_STRING DWinAmericans-JMM-1
14570: PPUSH
14571: CALL_OW 88
// DialogueOff ;
14575: CALL_OW 7
// YouLost ( AmBomb ) ;
14579: LD_STRING AmBomb
14581: PPUSH
14582: CALL_OW 104
// end ;
14586: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14587: LD_EXP 2
14591: NOT
14592: PUSH
14593: LD_INT 22
14595: PUSH
14596: LD_INT 3
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: PUSH
14603: LD_INT 34
14605: PUSH
14606: LD_INT 48
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: PUSH
14613: EMPTY
14614: LIST
14615: LIST
14616: PPUSH
14617: CALL_OW 69
14621: AND
14622: IFFALSE 14741
14624: GO 14626
14626: DISABLE
// begin wait ( 0 0$5 ) ;
14627: LD_INT 175
14629: PPUSH
14630: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14634: LD_EXP 58
14638: PPUSH
14639: CALL_OW 302
14643: NOT
14644: PUSH
14645: LD_INT 22
14647: PUSH
14648: LD_INT 3
14650: PUSH
14651: EMPTY
14652: LIST
14653: LIST
14654: PUSH
14655: LD_INT 34
14657: PUSH
14658: LD_INT 48
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: PUSH
14665: EMPTY
14666: LIST
14667: LIST
14668: PPUSH
14669: CALL_OW 69
14673: NOT
14674: OR
14675: IFFALSE 14679
// exit ;
14677: GO 14741
// DialogueOn ;
14679: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14683: LD_EXP 58
14687: PPUSH
14688: LD_STRING DWinRussians-Pla-1
14690: PPUSH
14691: CALL_OW 94
// if IsOk ( Burlak ) then
14695: LD_EXP 51
14699: PPUSH
14700: CALL_OW 302
14704: IFFALSE 14718
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14706: LD_EXP 51
14710: PPUSH
14711: LD_STRING DWinRussians-Bur-1
14713: PPUSH
14714: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14718: LD_EXP 19
14722: PPUSH
14723: LD_STRING DWinRussians-JMM-1
14725: PPUSH
14726: CALL_OW 88
// DialogueOff ;
14730: CALL_OW 7
// YouLost ( RuBomb ) ;
14734: LD_STRING RuBomb
14736: PPUSH
14737: CALL_OW 104
// end ;
14741: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14742: LD_INT 7
14744: PPUSH
14745: LD_INT 22
14747: PUSH
14748: LD_INT 7
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: PPUSH
14755: CALL_OW 70
14759: PUSH
14760: LD_EXP 4
14764: NOT
14765: AND
14766: IFFALSE 14795
14768: GO 14770
14770: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14771: LD_EXP 54
14775: PPUSH
14776: LD_STRING DSurrenderAmericans-Pow-1
14778: PPUSH
14779: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14783: LD_EXP 19
14787: PPUSH
14788: LD_STRING DSurrenderAmericans-JMM-1
14790: PPUSH
14791: CALL_OW 88
// end ;
14795: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14796: LD_INT 2
14798: PPUSH
14799: LD_INT 22
14801: PUSH
14802: LD_INT 7
14804: PUSH
14805: EMPTY
14806: LIST
14807: LIST
14808: PPUSH
14809: CALL_OW 70
14813: PUSH
14814: LD_EXP 2
14818: NOT
14819: AND
14820: PUSH
14821: LD_EXP 51
14825: AND
14826: IFFALSE 14855
14828: GO 14830
14830: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14831: LD_EXP 58
14835: PPUSH
14836: LD_STRING DSurrenderRussians-Pla-1
14838: PPUSH
14839: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14843: LD_EXP 51
14847: PPUSH
14848: LD_STRING DSurrenderRussians-Bur-1
14850: PPUSH
14851: CALL_OW 88
// end ;
14855: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14856: LD_EXP 4
14860: IFFALSE 15243
14862: GO 14864
14864: DISABLE
14865: LD_INT 0
14867: PPUSH
14868: PPUSH
14869: PPUSH
// begin MC_Kill ( 4 ) ;
14870: LD_INT 4
14872: PPUSH
14873: CALL 21486 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14877: LD_INT 1
14879: PPUSH
14880: LD_INT 7
14882: PPUSH
14883: LD_INT 1
14885: PPUSH
14886: LD_INT 1
14888: PPUSH
14889: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14893: LD_ADDR_VAR 0 3
14897: PUSH
14898: LD_INT 22
14900: PUSH
14901: LD_INT 1
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PUSH
14908: LD_INT 26
14910: PUSH
14911: LD_INT 1
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PUSH
14918: LD_INT 23
14920: PUSH
14921: LD_INT 1
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: PUSH
14928: EMPTY
14929: LIST
14930: LIST
14931: LIST
14932: PPUSH
14933: CALL_OW 69
14937: PUSH
14938: LD_EXP 54
14942: PUSH
14943: LD_EXP 27
14947: PUSH
14948: LD_EXP 24
14952: PUSH
14953: LD_EXP 23
14957: PUSH
14958: LD_EXP 30
14962: PUSH
14963: LD_EXP 28
14967: PUSH
14968: EMPTY
14969: LIST
14970: LIST
14971: LIST
14972: LIST
14973: LIST
14974: LIST
14975: DIFF
14976: ST_TO_ADDR
// if speaker then
14977: LD_VAR 0 3
14981: IFFALSE 15007
// begin DialogueOn ;
14983: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14987: LD_VAR 0 3
14991: PUSH
14992: LD_INT 1
14994: ARRAY
14995: PPUSH
14996: LD_STRING DSurrenderAmericans-Sol1-1a
14998: PPUSH
14999: CALL_OW 94
// DialogueOff ;
15003: CALL_OW 7
// end ; americanCapitulated := true ;
15007: LD_ADDR_EXP 6
15011: PUSH
15012: LD_INT 1
15014: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15015: LD_ADDR_VAR 0 2
15019: PUSH
15020: LD_INT 22
15022: PUSH
15023: LD_INT 1
15025: PUSH
15026: EMPTY
15027: LIST
15028: LIST
15029: PUSH
15030: LD_INT 21
15032: PUSH
15033: LD_INT 1
15035: PUSH
15036: EMPTY
15037: LIST
15038: LIST
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: PPUSH
15044: CALL_OW 69
15048: PUSH
15049: LD_INT 22
15051: PUSH
15052: LD_INT 1
15054: PUSH
15055: EMPTY
15056: LIST
15057: LIST
15058: PUSH
15059: LD_INT 21
15061: PUSH
15062: LD_INT 2
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: PUSH
15069: LD_INT 1
15071: PUSH
15072: EMPTY
15073: LIST
15074: PUSH
15075: EMPTY
15076: LIST
15077: LIST
15078: LIST
15079: PPUSH
15080: CALL_OW 69
15084: ADD
15085: ST_TO_ADDR
// if tmp then
15086: LD_VAR 0 2
15090: IFFALSE 15243
// repeat wait ( 0 0$1 ) ;
15092: LD_INT 35
15094: PPUSH
15095: CALL_OW 67
// for i in tmp do
15099: LD_ADDR_VAR 0 1
15103: PUSH
15104: LD_VAR 0 2
15108: PUSH
15109: FOR_IN
15110: IFFALSE 15192
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15112: LD_VAR 0 1
15116: PPUSH
15117: CALL_OW 310
15121: PUSH
15122: LD_VAR 0 1
15126: PPUSH
15127: CALL_OW 310
15131: PPUSH
15132: CALL_OW 247
15136: PUSH
15137: LD_INT 3
15139: EQUAL
15140: AND
15141: IFFALSE 15152
// ComExitBuilding ( i ) ;
15143: LD_VAR 0 1
15147: PPUSH
15148: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15152: LD_VAR 0 1
15156: PPUSH
15157: LD_INT 122
15159: PPUSH
15160: LD_INT 242
15162: PPUSH
15163: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15167: LD_VAR 0 1
15171: PPUSH
15172: LD_INT 35
15174: PPUSH
15175: CALL_OW 308
15179: IFFALSE 15190
// RemoveUnit ( i ) ;
15181: LD_VAR 0 1
15185: PPUSH
15186: CALL_OW 64
// end ;
15190: GO 15109
15192: POP
15193: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15194: LD_INT 22
15196: PUSH
15197: LD_INT 1
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PUSH
15204: LD_INT 2
15206: PUSH
15207: LD_INT 21
15209: PUSH
15210: LD_INT 1
15212: PUSH
15213: EMPTY
15214: LIST
15215: LIST
15216: PUSH
15217: LD_INT 33
15219: PUSH
15220: LD_INT 1
15222: PUSH
15223: EMPTY
15224: LIST
15225: LIST
15226: PUSH
15227: EMPTY
15228: LIST
15229: LIST
15230: LIST
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PPUSH
15236: CALL_OW 69
15240: NOT
15241: IFFALSE 15092
// end ;
15243: PPOPN 3
15245: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15246: LD_EXP 2
15250: IFFALSE 15651
15252: GO 15254
15254: DISABLE
15255: LD_INT 0
15257: PPUSH
15258: PPUSH
15259: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15260: LD_INT 35
15262: PPUSH
15263: CALL_OW 67
// until IsDead ( Yakotich ) ;
15267: LD_EXP 59
15271: PPUSH
15272: CALL_OW 301
15276: IFFALSE 15260
// MC_Kill ( 2 ) ;
15278: LD_INT 2
15280: PPUSH
15281: CALL 21486 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15285: LD_INT 3
15287: PPUSH
15288: LD_INT 7
15290: PPUSH
15291: LD_INT 1
15293: PPUSH
15294: LD_INT 1
15296: PPUSH
15297: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15301: LD_ADDR_VAR 0 3
15305: PUSH
15306: LD_INT 22
15308: PUSH
15309: LD_INT 3
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PUSH
15316: LD_INT 26
15318: PUSH
15319: LD_INT 1
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: LD_INT 23
15328: PUSH
15329: LD_INT 3
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: LIST
15340: PPUSH
15341: CALL_OW 69
15345: PUSH
15346: LD_EXP 58
15350: PUSH
15351: LD_EXP 59
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: DIFF
15360: ST_TO_ADDR
// if speaker then
15361: LD_VAR 0 3
15365: IFFALSE 15415
// begin DialogueOn ;
15367: CALL_OW 6
// if Burlak then
15371: LD_EXP 51
15375: IFFALSE 15395
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15377: LD_VAR 0 3
15381: PUSH
15382: LD_INT 1
15384: ARRAY
15385: PPUSH
15386: LD_STRING DSurrenderRussians-RSol1-1
15388: PPUSH
15389: CALL_OW 94
15393: GO 15411
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15395: LD_VAR 0 3
15399: PUSH
15400: LD_INT 1
15402: ARRAY
15403: PPUSH
15404: LD_STRING DSurrenderRussians-RSol1-1a
15406: PPUSH
15407: CALL_OW 94
// DialogueOff ;
15411: CALL_OW 7
// end ; russianCapitulated := true ;
15415: LD_ADDR_EXP 7
15419: PUSH
15420: LD_INT 1
15422: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15423: LD_ADDR_VAR 0 2
15427: PUSH
15428: LD_INT 22
15430: PUSH
15431: LD_INT 3
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PUSH
15438: LD_INT 21
15440: PUSH
15441: LD_INT 1
15443: PUSH
15444: EMPTY
15445: LIST
15446: LIST
15447: PUSH
15448: EMPTY
15449: LIST
15450: LIST
15451: PPUSH
15452: CALL_OW 69
15456: PUSH
15457: LD_INT 22
15459: PUSH
15460: LD_INT 3
15462: PUSH
15463: EMPTY
15464: LIST
15465: LIST
15466: PUSH
15467: LD_INT 21
15469: PUSH
15470: LD_INT 2
15472: PUSH
15473: EMPTY
15474: LIST
15475: LIST
15476: PUSH
15477: LD_INT 1
15479: PUSH
15480: EMPTY
15481: LIST
15482: PUSH
15483: EMPTY
15484: LIST
15485: LIST
15486: LIST
15487: PPUSH
15488: CALL_OW 69
15492: ADD
15493: ST_TO_ADDR
// if tmp then
15494: LD_VAR 0 2
15498: IFFALSE 15651
// repeat wait ( 0 0$1 ) ;
15500: LD_INT 35
15502: PPUSH
15503: CALL_OW 67
// for i in tmp do
15507: LD_ADDR_VAR 0 1
15511: PUSH
15512: LD_VAR 0 2
15516: PUSH
15517: FOR_IN
15518: IFFALSE 15600
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15520: LD_VAR 0 1
15524: PPUSH
15525: CALL_OW 310
15529: PUSH
15530: LD_VAR 0 1
15534: PPUSH
15535: CALL_OW 310
15539: PPUSH
15540: CALL_OW 247
15544: PUSH
15545: LD_INT 3
15547: EQUAL
15548: AND
15549: IFFALSE 15560
// ComExitBuilding ( i ) ;
15551: LD_VAR 0 1
15555: PPUSH
15556: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15560: LD_VAR 0 1
15564: PPUSH
15565: LD_INT 154
15567: PPUSH
15568: LD_INT 1
15570: PPUSH
15571: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15575: LD_VAR 0 1
15579: PPUSH
15580: LD_INT 36
15582: PPUSH
15583: CALL_OW 308
15587: IFFALSE 15598
// RemoveUnit ( i ) ;
15589: LD_VAR 0 1
15593: PPUSH
15594: CALL_OW 64
// end ;
15598: GO 15517
15600: POP
15601: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15602: LD_INT 22
15604: PUSH
15605: LD_INT 3
15607: PUSH
15608: EMPTY
15609: LIST
15610: LIST
15611: PUSH
15612: LD_INT 2
15614: PUSH
15615: LD_INT 21
15617: PUSH
15618: LD_INT 1
15620: PUSH
15621: EMPTY
15622: LIST
15623: LIST
15624: PUSH
15625: LD_INT 33
15627: PUSH
15628: LD_INT 1
15630: PUSH
15631: EMPTY
15632: LIST
15633: LIST
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: LIST
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: PPUSH
15644: CALL_OW 69
15648: NOT
15649: IFFALSE 15500
// end ;
15651: PPOPN 3
15653: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15654: LD_INT 22
15656: PUSH
15657: LD_INT 8
15659: PUSH
15660: EMPTY
15661: LIST
15662: LIST
15663: PUSH
15664: LD_INT 21
15666: PUSH
15667: LD_INT 1
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: PUSH
15674: LD_INT 23
15676: PUSH
15677: LD_INT 2
15679: PUSH
15680: EMPTY
15681: LIST
15682: LIST
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: LIST
15688: PPUSH
15689: CALL_OW 69
15693: PUSH
15694: LD_INT 18
15696: LESS
15697: PUSH
15698: LD_EXP 57
15702: PPUSH
15703: CALL_OW 301
15707: OR
15708: PUSH
15709: LD_INT 324
15711: PPUSH
15712: CALL_OW 255
15716: PUSH
15717: LD_INT 7
15719: EQUAL
15720: OR
15721: IFFALSE 15734
15723: GO 15725
15725: DISABLE
// legionDestroyed := true ;
15726: LD_ADDR_EXP 3
15730: PUSH
15731: LD_INT 1
15733: ST_TO_ADDR
15734: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15735: LD_INT 22
15737: PUSH
15738: LD_INT 2
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: PUSH
15745: LD_INT 21
15747: PUSH
15748: LD_INT 1
15750: PUSH
15751: EMPTY
15752: LIST
15753: LIST
15754: PUSH
15755: LD_INT 23
15757: PUSH
15758: LD_INT 2
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: PUSH
15765: EMPTY
15766: LIST
15767: LIST
15768: LIST
15769: PPUSH
15770: CALL_OW 69
15774: PUSH
15775: LD_INT 9
15777: LESS
15778: IFFALSE 15791
15780: GO 15782
15782: DISABLE
// arabianDestroyed := true ;
15783: LD_ADDR_EXP 5
15787: PUSH
15788: LD_INT 1
15790: ST_TO_ADDR
15791: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15792: LD_EXP 5
15796: IFFALSE 16040
15798: GO 15800
15800: DISABLE
15801: LD_INT 0
15803: PPUSH
15804: PPUSH
// begin MC_Kill ( 1 ) ;
15805: LD_INT 1
15807: PPUSH
15808: CALL 21486 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15812: LD_ADDR_VAR 0 2
15816: PUSH
15817: LD_INT 22
15819: PUSH
15820: LD_INT 2
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: PPUSH
15841: CALL_OW 69
15845: PUSH
15846: LD_INT 22
15848: PUSH
15849: LD_INT 8
15851: PUSH
15852: EMPTY
15853: LIST
15854: LIST
15855: PUSH
15856: LD_INT 21
15858: PUSH
15859: LD_INT 2
15861: PUSH
15862: EMPTY
15863: LIST
15864: LIST
15865: PUSH
15866: LD_INT 1
15868: PUSH
15869: EMPTY
15870: LIST
15871: PUSH
15872: EMPTY
15873: LIST
15874: LIST
15875: LIST
15876: PPUSH
15877: CALL_OW 69
15881: ADD
15882: ST_TO_ADDR
// if tmp then
15883: LD_VAR 0 2
15887: IFFALSE 16040
// repeat wait ( 0 0$1 ) ;
15889: LD_INT 35
15891: PPUSH
15892: CALL_OW 67
// for i in tmp do
15896: LD_ADDR_VAR 0 1
15900: PUSH
15901: LD_VAR 0 2
15905: PUSH
15906: FOR_IN
15907: IFFALSE 15989
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15909: LD_VAR 0 1
15913: PPUSH
15914: CALL_OW 310
15918: PUSH
15919: LD_VAR 0 1
15923: PPUSH
15924: CALL_OW 310
15928: PPUSH
15929: CALL_OW 247
15933: PUSH
15934: LD_INT 3
15936: EQUAL
15937: AND
15938: IFFALSE 15949
// ComExitBuilding ( i ) ;
15940: LD_VAR 0 1
15944: PPUSH
15945: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15949: LD_VAR 0 1
15953: PPUSH
15954: LD_INT 254
15956: PPUSH
15957: LD_INT 268
15959: PPUSH
15960: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15964: LD_VAR 0 1
15968: PPUSH
15969: LD_INT 34
15971: PPUSH
15972: CALL_OW 308
15976: IFFALSE 15987
// RemoveUnit ( i ) ;
15978: LD_VAR 0 1
15982: PPUSH
15983: CALL_OW 64
// end ;
15987: GO 15906
15989: POP
15990: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15991: LD_INT 22
15993: PUSH
15994: LD_INT 2
15996: PUSH
15997: EMPTY
15998: LIST
15999: LIST
16000: PUSH
16001: LD_INT 2
16003: PUSH
16004: LD_INT 21
16006: PUSH
16007: LD_INT 1
16009: PUSH
16010: EMPTY
16011: LIST
16012: LIST
16013: PUSH
16014: LD_INT 33
16016: PUSH
16017: LD_INT 1
16019: PUSH
16020: EMPTY
16021: LIST
16022: LIST
16023: PUSH
16024: EMPTY
16025: LIST
16026: LIST
16027: LIST
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: PPUSH
16033: CALL_OW 69
16037: NOT
16038: IFFALSE 15889
// end ;
16040: PPOPN 2
16042: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16043: LD_EXP 3
16047: IFFALSE 16399
16049: GO 16051
16051: DISABLE
16052: LD_INT 0
16054: PPUSH
16055: PPUSH
// begin MC_Kill ( 3 ) ;
16056: LD_INT 3
16058: PPUSH
16059: CALL 21486 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16063: LD_INT 8
16065: PPUSH
16066: LD_INT 7
16068: PPUSH
16069: LD_INT 1
16071: PPUSH
16072: LD_INT 1
16074: PPUSH
16075: CALL_OW 80
// DialogueOn ;
16079: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16083: LD_EXP 56
16087: PPUSH
16088: LD_STRING D15-Szulc-1
16090: PPUSH
16091: CALL_OW 94
// DialogueOff ;
16095: CALL_OW 7
// legionCapitulated := true ;
16099: LD_ADDR_EXP 8
16103: PUSH
16104: LD_INT 1
16106: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16107: LD_ADDR_VAR 0 1
16111: PUSH
16112: LD_INT 22
16114: PUSH
16115: LD_INT 8
16117: PUSH
16118: EMPTY
16119: LIST
16120: LIST
16121: PUSH
16122: LD_INT 21
16124: PUSH
16125: LD_INT 3
16127: PUSH
16128: EMPTY
16129: LIST
16130: LIST
16131: PUSH
16132: LD_INT 23
16134: PUSH
16135: LD_INT 3
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: PPUSH
16147: CALL_OW 69
16151: PUSH
16152: FOR_IN
16153: IFFALSE 16169
// SetLives ( i , 3 ) ;
16155: LD_VAR 0 1
16159: PPUSH
16160: LD_INT 3
16162: PPUSH
16163: CALL_OW 234
16167: GO 16152
16169: POP
16170: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16171: LD_ADDR_VAR 0 2
16175: PUSH
16176: LD_INT 22
16178: PUSH
16179: LD_INT 8
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: PUSH
16186: LD_INT 21
16188: PUSH
16189: LD_INT 1
16191: PUSH
16192: EMPTY
16193: LIST
16194: LIST
16195: PUSH
16196: EMPTY
16197: LIST
16198: LIST
16199: PPUSH
16200: CALL_OW 69
16204: PUSH
16205: LD_INT 22
16207: PUSH
16208: LD_INT 8
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: PUSH
16215: LD_INT 21
16217: PUSH
16218: LD_INT 2
16220: PUSH
16221: EMPTY
16222: LIST
16223: LIST
16224: PUSH
16225: LD_INT 1
16227: PUSH
16228: EMPTY
16229: LIST
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: LIST
16235: PPUSH
16236: CALL_OW 69
16240: ADD
16241: ST_TO_ADDR
// if tmp then
16242: LD_VAR 0 2
16246: IFFALSE 16399
// repeat wait ( 0 0$1 ) ;
16248: LD_INT 35
16250: PPUSH
16251: CALL_OW 67
// for i in tmp do
16255: LD_ADDR_VAR 0 1
16259: PUSH
16260: LD_VAR 0 2
16264: PUSH
16265: FOR_IN
16266: IFFALSE 16348
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16268: LD_VAR 0 1
16272: PPUSH
16273: CALL_OW 310
16277: PUSH
16278: LD_VAR 0 1
16282: PPUSH
16283: CALL_OW 310
16287: PPUSH
16288: CALL_OW 247
16292: PUSH
16293: LD_INT 3
16295: EQUAL
16296: AND
16297: IFFALSE 16308
// ComExitBuilding ( i ) ;
16299: LD_VAR 0 1
16303: PPUSH
16304: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16308: LD_VAR 0 1
16312: PPUSH
16313: LD_INT 10
16315: PPUSH
16316: LD_INT 1
16318: PPUSH
16319: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16323: LD_VAR 0 1
16327: PPUSH
16328: LD_INT 32
16330: PPUSH
16331: CALL_OW 308
16335: IFFALSE 16346
// RemoveUnit ( i ) ;
16337: LD_VAR 0 1
16341: PPUSH
16342: CALL_OW 64
// end ;
16346: GO 16265
16348: POP
16349: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16350: LD_INT 22
16352: PUSH
16353: LD_INT 8
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: PUSH
16360: LD_INT 2
16362: PUSH
16363: LD_INT 21
16365: PUSH
16366: LD_INT 1
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PUSH
16373: LD_INT 33
16375: PUSH
16376: LD_INT 1
16378: PUSH
16379: EMPTY
16380: LIST
16381: LIST
16382: PUSH
16383: EMPTY
16384: LIST
16385: LIST
16386: LIST
16387: PUSH
16388: EMPTY
16389: LIST
16390: LIST
16391: PPUSH
16392: CALL_OW 69
16396: NOT
16397: IFFALSE 16248
// end ;
16399: PPOPN 2
16401: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 do
16402: LD_EXP 5
16406: NOT
16407: PUSH
16408: LD_OWVAR 1
16412: PUSH
16413: LD_INT 63000
16415: GREATEREQUAL
16416: AND
16417: IFFALSE 16426
16419: GO 16421
16421: DISABLE
// AllianceSupport ;
16422: CALL 4634 0 0
16426: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16427: LD_EXP 4
16431: PUSH
16432: LD_EXP 2
16436: AND
16437: PUSH
16438: LD_EXP 3
16442: AND
16443: PUSH
16444: LD_EXP 5
16448: AND
16449: PUSH
16450: LD_EXP 6
16454: AND
16455: PUSH
16456: LD_EXP 7
16460: AND
16461: PUSH
16462: LD_EXP 8
16466: AND
16467: PUSH
16468: LD_EXP 55
16472: PPUSH
16473: CALL_OW 255
16477: PUSH
16478: LD_INT 5
16480: NONEQUAL
16481: PUSH
16482: LD_EXP 55
16486: PPUSH
16487: CALL_OW 301
16491: OR
16492: PUSH
16493: LD_EXP 55
16497: PPUSH
16498: CALL_OW 305
16502: NOT
16503: OR
16504: AND
16505: IFFALSE 17907
16507: GO 16509
16509: DISABLE
16510: LD_INT 0
16512: PPUSH
16513: PPUSH
// begin wait ( 0 0$5 ) ;
16514: LD_INT 175
16516: PPUSH
16517: CALL_OW 67
// music_class := 5 ;
16521: LD_ADDR_OWVAR 72
16525: PUSH
16526: LD_INT 5
16528: ST_TO_ADDR
// music_nat := 5 ;
16529: LD_ADDR_OWVAR 71
16533: PUSH
16534: LD_INT 5
16536: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16537: LD_EXP 15
16541: PUSH
16542: LD_INT 3
16544: LESS
16545: IFFALSE 16554
// SetAchievement ( ACH_ECONOMY ) ;
16547: LD_STRING ACH_ECONOMY
16549: PPUSH
16550: CALL_OW 543
// if tick < 60 60$00 then
16554: LD_OWVAR 1
16558: PUSH
16559: LD_INT 126000
16561: LESS
16562: IFFALSE 16578
// begin wait ( 3 ) ;
16564: LD_INT 3
16566: PPUSH
16567: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16571: LD_STRING ACH_ASPEED_19
16573: PPUSH
16574: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16578: LD_EXP 19
16582: PPUSH
16583: CALL_OW 87
// InGameOn ;
16587: CALL_OW 8
// DialogueOn ;
16591: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16595: LD_EXP 19
16599: PPUSH
16600: LD_STRING DEnd-JMM-JMM-1
16602: PPUSH
16603: CALL_OW 88
// if Joan then
16607: LD_EXP 34
16611: IFFALSE 16627
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16613: LD_EXP 34
16617: PPUSH
16618: LD_STRING DEnd-JMM-Joan-1
16620: PPUSH
16621: CALL_OW 88
16625: GO 16671
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16627: LD_EXP 21
16631: PUSH
16632: LD_EXP 21
16636: PPUSH
16637: CALL_OW 255
16641: PUSH
16642: LD_INT 7
16644: EQUAL
16645: AND
16646: PUSH
16647: LD_EXP 21
16651: PPUSH
16652: CALL_OW 305
16656: AND
16657: IFFALSE 16671
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16659: LD_EXP 21
16663: PPUSH
16664: LD_STRING DEnd-JMM-Lisa-1
16666: PPUSH
16667: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16671: LD_EXP 31
16675: PUSH
16676: LD_EXP 31
16680: PPUSH
16681: CALL_OW 305
16685: AND
16686: IFFALSE 16700
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16688: LD_EXP 31
16692: PPUSH
16693: LD_STRING DEnd-JMM-Frank-1
16695: PPUSH
16696: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16700: LD_EXP 24
16704: PUSH
16705: LD_EXP 24
16709: PPUSH
16710: CALL_OW 255
16714: PUSH
16715: LD_INT 7
16717: EQUAL
16718: AND
16719: PUSH
16720: LD_EXP 24
16724: PPUSH
16725: CALL_OW 305
16729: AND
16730: IFFALSE 16744
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16732: LD_EXP 24
16736: PPUSH
16737: LD_STRING DEnd-JMM-Cyrus-1
16739: PPUSH
16740: CALL_OW 88
// if Burlak then
16744: LD_EXP 51
16748: IFFALSE 16762
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16750: LD_EXP 51
16754: PPUSH
16755: LD_STRING DEnd-JMM-Bur-1
16757: PPUSH
16758: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
16762: LD_EXP 34
16766: PUSH
16767: LD_EXP 21
16771: AND
16772: PUSH
16773: LD_EXP 21
16777: PPUSH
16778: CALL_OW 255
16782: PUSH
16783: LD_INT 7
16785: EQUAL
16786: AND
16787: PUSH
16788: LD_EXP 21
16792: PPUSH
16793: CALL_OW 305
16797: AND
16798: PUSH
16799: LD_EXP 51
16803: PPUSH
16804: CALL_OW 302
16808: AND
16809: IFFALSE 16823
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16811: LD_EXP 21
16815: PPUSH
16816: LD_STRING DEnd-Burlak-Lisa-1
16818: PPUSH
16819: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16823: LD_EXP 52
16827: PUSH
16828: LD_EXP 52
16832: PPUSH
16833: CALL_OW 305
16837: AND
16838: IFFALSE 16852
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16840: LD_EXP 52
16844: PPUSH
16845: LD_STRING DEnd-JMM-Bel-1
16847: PPUSH
16848: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16852: LD_EXP 53
16856: PUSH
16857: LD_EXP 53
16861: PPUSH
16862: CALL_OW 305
16866: AND
16867: IFFALSE 16881
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16869: LD_EXP 53
16873: PPUSH
16874: LD_STRING DEnd-JMM-Gny-1
16876: PPUSH
16877: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16881: LD_EXP 29
16885: PUSH
16886: LD_EXP 29
16890: PPUSH
16891: CALL_OW 255
16895: PUSH
16896: LD_INT 7
16898: EQUAL
16899: AND
16900: PUSH
16901: LD_EXP 29
16905: PPUSH
16906: CALL_OW 305
16910: AND
16911: IFFALSE 16925
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16913: LD_EXP 29
16917: PPUSH
16918: LD_STRING DEnd-JMM-Corn-1
16920: PPUSH
16921: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16925: LD_EXP 22
16929: PUSH
16930: LD_EXP 22
16934: PPUSH
16935: CALL_OW 255
16939: PUSH
16940: LD_INT 7
16942: EQUAL
16943: AND
16944: PUSH
16945: LD_EXP 22
16949: PPUSH
16950: CALL_OW 305
16954: AND
16955: IFFALSE 16969
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16957: LD_EXP 22
16961: PPUSH
16962: LD_STRING DEnd-JMM-Don-1
16964: PPUSH
16965: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16969: LD_EXP 23
16973: PUSH
16974: LD_EXP 23
16978: PPUSH
16979: CALL_OW 255
16983: PUSH
16984: LD_INT 7
16986: EQUAL
16987: AND
16988: PUSH
16989: LD_EXP 23
16993: PPUSH
16994: CALL_OW 305
16998: AND
16999: IFFALSE 17013
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17001: LD_EXP 23
17005: PPUSH
17006: LD_STRING DEnd-JMM-Bobby-1
17008: PPUSH
17009: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17013: LD_EXP 25
17017: PUSH
17018: LD_EXP 25
17022: PPUSH
17023: CALL_OW 255
17027: PUSH
17028: LD_INT 7
17030: EQUAL
17031: AND
17032: PUSH
17033: LD_EXP 25
17037: PPUSH
17038: CALL_OW 305
17042: AND
17043: IFFALSE 17057
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17045: LD_EXP 25
17049: PPUSH
17050: LD_STRING DEnd-JMM-Den-1
17052: PPUSH
17053: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17057: LD_EXP 27
17061: PUSH
17062: LD_EXP 27
17066: PPUSH
17067: CALL_OW 255
17071: PUSH
17072: LD_INT 7
17074: EQUAL
17075: AND
17076: PUSH
17077: LD_EXP 27
17081: PPUSH
17082: CALL_OW 305
17086: AND
17087: IFFALSE 17101
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17089: LD_EXP 27
17093: PPUSH
17094: LD_STRING DEnd-JMM-Glad-1
17096: PPUSH
17097: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17101: LD_EXP 32
17105: PUSH
17106: LD_EXP 32
17110: PPUSH
17111: CALL_OW 255
17115: PUSH
17116: LD_INT 7
17118: EQUAL
17119: AND
17120: PUSH
17121: LD_EXP 32
17125: PPUSH
17126: CALL_OW 305
17130: AND
17131: IFFALSE 17145
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17133: LD_EXP 32
17137: PPUSH
17138: LD_STRING DEnd-JMM-Yam-1
17140: PPUSH
17141: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17145: LD_EXP 26
17149: PUSH
17150: LD_EXP 26
17154: PPUSH
17155: CALL_OW 255
17159: PUSH
17160: LD_INT 7
17162: EQUAL
17163: AND
17164: PUSH
17165: LD_EXP 26
17169: PPUSH
17170: CALL_OW 305
17174: AND
17175: IFFALSE 17189
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17177: LD_EXP 26
17181: PPUSH
17182: LD_STRING DEnd-JMM-Brown-1
17184: PPUSH
17185: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17189: LD_EXP 36
17193: PUSH
17194: LD_EXP 36
17198: PPUSH
17199: CALL_OW 255
17203: PUSH
17204: LD_INT 7
17206: EQUAL
17207: AND
17208: PUSH
17209: LD_EXP 36
17213: PPUSH
17214: CALL_OW 305
17218: AND
17219: IFFALSE 17233
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17221: LD_EXP 36
17225: PPUSH
17226: LD_STRING DEnd-JMM-Con-1
17228: PPUSH
17229: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17233: LD_EXP 30
17237: PUSH
17238: LD_EXP 30
17242: PPUSH
17243: CALL_OW 255
17247: PUSH
17248: LD_INT 7
17250: EQUAL
17251: AND
17252: PUSH
17253: LD_EXP 30
17257: PPUSH
17258: CALL_OW 305
17262: AND
17263: IFFALSE 17277
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17265: LD_EXP 30
17269: PPUSH
17270: LD_STRING DEnd-JMM-Gary-1
17272: PPUSH
17273: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17277: LD_EXP 33
17281: PUSH
17282: LD_EXP 20
17286: AND
17287: PUSH
17288: LD_EXP 33
17292: PPUSH
17293: CALL_OW 305
17297: AND
17298: IFFALSE 17312
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17300: LD_EXP 33
17304: PPUSH
17305: LD_STRING DEnd-JMM-Sim-1
17307: PPUSH
17308: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17312: LD_EXP 28
17316: PUSH
17317: LD_EXP 28
17321: PPUSH
17322: CALL_OW 255
17326: PUSH
17327: LD_INT 7
17329: EQUAL
17330: AND
17331: PUSH
17332: LD_EXP 28
17336: PPUSH
17337: CALL_OW 305
17341: AND
17342: IFFALSE 17356
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17344: LD_EXP 28
17348: PPUSH
17349: LD_STRING DEnd-JMM-VanH-1
17351: PPUSH
17352: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17356: LD_EXP 41
17360: PUSH
17361: LD_EXP 41
17365: PPUSH
17366: CALL_OW 305
17370: AND
17371: IFFALSE 17385
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17373: LD_EXP 41
17377: PPUSH
17378: LD_STRING DEnd-JMM-Dol-1
17380: PPUSH
17381: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17385: LD_EXP 45
17389: PUSH
17390: LD_EXP 45
17394: PPUSH
17395: CALL_OW 305
17399: AND
17400: IFFALSE 17414
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17402: LD_EXP 45
17406: PPUSH
17407: LD_STRING DEnd-JMM-Kap-1
17409: PPUSH
17410: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17414: LD_EXP 48
17418: PUSH
17419: LD_EXP 48
17423: PPUSH
17424: CALL_OW 305
17428: AND
17429: IFFALSE 17443
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17431: LD_EXP 48
17435: PPUSH
17436: LD_STRING DEnd-JMM-Kov-1
17438: PPUSH
17439: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17443: LD_EXP 43
17447: PUSH
17448: LD_EXP 43
17452: PPUSH
17453: CALL_OW 305
17457: AND
17458: IFFALSE 17472
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17460: LD_EXP 43
17464: PPUSH
17465: LD_STRING DEnd-JMM-Sch-1
17467: PPUSH
17468: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17472: LD_EXP 39
17476: PUSH
17477: LD_EXP 39
17481: PPUSH
17482: CALL_OW 305
17486: AND
17487: IFFALSE 17501
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17489: LD_EXP 39
17493: PPUSH
17494: LD_STRING DEnd-JMM-Tit-1
17496: PPUSH
17497: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17501: LD_EXP 44
17505: PUSH
17506: LD_EXP 44
17510: PPUSH
17511: CALL_OW 305
17515: AND
17516: IFFALSE 17530
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17518: LD_EXP 44
17522: PPUSH
17523: LD_STRING DEnd-JMM-Obl-1
17525: PPUSH
17526: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17530: LD_EXP 46
17534: PUSH
17535: LD_EXP 46
17539: PPUSH
17540: CALL_OW 305
17544: AND
17545: IFFALSE 17559
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17547: LD_EXP 46
17551: PPUSH
17552: LD_STRING DEnd-JMM-Lip-1
17554: PPUSH
17555: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17559: LD_EXP 40
17563: PUSH
17564: LD_EXP 40
17568: PPUSH
17569: CALL_OW 305
17573: AND
17574: PUSH
17575: LD_EXP 51
17579: AND
17580: IFFALSE 17594
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17582: LD_EXP 40
17586: PPUSH
17587: LD_STRING DEnd-Burlak-Fad-1
17589: PPUSH
17590: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17594: LD_EXP 47
17598: PUSH
17599: LD_EXP 47
17603: PPUSH
17604: CALL_OW 305
17608: AND
17609: IFFALSE 17623
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17611: LD_EXP 47
17615: PPUSH
17616: LD_STRING DEnd-Burlak-Ptr-1
17618: PPUSH
17619: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17623: LD_EXP 49
17627: PUSH
17628: LD_EXP 49
17632: PPUSH
17633: CALL_OW 305
17637: AND
17638: IFFALSE 17652
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17640: LD_EXP 49
17644: PPUSH
17645: LD_STRING DEnd-Burlak-Kuz-1
17647: PPUSH
17648: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17652: LD_EXP 38
17656: PUSH
17657: LD_EXP 38
17661: PPUSH
17662: CALL_OW 305
17666: AND
17667: PUSH
17668: LD_EXP 51
17672: AND
17673: IFFALSE 17687
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17675: LD_EXP 38
17679: PPUSH
17680: LD_STRING DEnd-Burlak-Kir-1
17682: PPUSH
17683: CALL_OW 88
// if Burlak then
17687: LD_EXP 51
17691: IFFALSE 17705
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17693: LD_EXP 19
17697: PPUSH
17698: LD_STRING DEnd-Burlak-JMM-1
17700: PPUSH
17701: CALL_OW 88
// dwait ( 0 0$2 ) ;
17705: LD_INT 70
17707: PPUSH
17708: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17712: LD_EXP 56
17716: PPUSH
17717: LD_STRING DEnd-Szulc
17719: PPUSH
17720: CALL_OW 94
// dwait ( 0 0$1 ) ;
17724: LD_INT 35
17726: PPUSH
17727: CALL_OW 68
// if IsLive ( Burlak ) then
17731: LD_EXP 51
17735: PPUSH
17736: CALL_OW 300
17740: IFFALSE 17752
// med1 := 1 else
17742: LD_ADDR_VAR 0 1
17746: PUSH
17747: LD_INT 1
17749: ST_TO_ADDR
17750: GO 17761
// med1 := - 1 ;
17752: LD_ADDR_VAR 0 1
17756: PUSH
17757: LD_INT 1
17759: NEG
17760: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17761: LD_EXP 12
17765: PUSH
17766: LD_EXP 13
17770: AND
17771: PUSH
17772: LD_EXP 14
17776: AND
17777: IFFALSE 17789
// med2 := 1 else
17779: LD_ADDR_VAR 0 2
17783: PUSH
17784: LD_INT 1
17786: ST_TO_ADDR
17787: GO 17798
// med2 := - 1 ;
17789: LD_ADDR_VAR 0 2
17793: PUSH
17794: LD_INT 1
17796: NEG
17797: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17798: LD_STRING Hero
17800: PPUSH
17801: LD_INT 1
17803: PPUSH
17804: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17808: LD_STRING Artefact
17810: PPUSH
17811: LD_VAR 0 2
17815: PPUSH
17816: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17820: LD_STRING ReconcileBurlak
17822: PPUSH
17823: LD_VAR 0 1
17827: PPUSH
17828: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17832: LD_OWVAR 67
17836: PUSH
17837: LD_INT 3
17839: GREATEREQUAL
17840: PUSH
17841: LD_VAR 0 1
17845: PUSH
17846: LD_INT 1
17848: EQUAL
17849: AND
17850: PUSH
17851: LD_VAR 0 2
17855: PUSH
17856: LD_INT 1
17858: EQUAL
17859: AND
17860: IFFALSE 17872
// SetAchievementEX ( ACH_AMER , 19 ) ;
17862: LD_STRING ACH_AMER
17864: PPUSH
17865: LD_INT 19
17867: PPUSH
17868: CALL_OW 564
// GiveMedals ( MAIN ) ;
17872: LD_STRING MAIN
17874: PPUSH
17875: CALL_OW 102
// InGameOff ;
17879: CALL_OW 9
// DialogueOff ;
17883: CALL_OW 7
// music_nat := 1 ;
17887: LD_ADDR_OWVAR 71
17891: PUSH
17892: LD_INT 1
17894: ST_TO_ADDR
// music_class := 4 ;
17895: LD_ADDR_OWVAR 72
17899: PUSH
17900: LD_INT 4
17902: ST_TO_ADDR
// YouWin ;
17903: CALL_OW 103
// end ; end_of_file
17907: PPOPN 2
17909: END
// export function InitNature ; begin
17910: LD_INT 0
17912: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17913: LD_INT 3
17915: PPUSH
17916: LD_INT 3
17918: PPUSH
17919: LD_INT 2
17921: PPUSH
17922: LD_INT 1
17924: PPUSH
17925: LD_INT 1
17927: PPUSH
17928: LD_INT 0
17930: PPUSH
17931: LD_INT 0
17933: PPUSH
17934: LD_INT 17
17936: PPUSH
17937: LD_INT 0
17939: PPUSH
17940: CALL 85906 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17944: LD_INT 2
17946: PPUSH
17947: LD_INT 1
17949: PPUSH
17950: LD_INT 1
17952: PPUSH
17953: LD_INT 1
17955: PPUSH
17956: LD_INT 1
17958: PPUSH
17959: LD_INT 0
17961: PPUSH
17962: LD_INT 0
17964: PPUSH
17965: LD_INT 18
17967: PPUSH
17968: LD_INT 0
17970: PPUSH
17971: CALL 85906 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17975: LD_INT 4
17977: PPUSH
17978: LD_INT 1
17980: PPUSH
17981: LD_INT 2
17983: PPUSH
17984: LD_INT 4
17986: PPUSH
17987: LD_INT 2
17989: PPUSH
17990: LD_INT 1
17992: PPUSH
17993: LD_INT 0
17995: PPUSH
17996: LD_INT 19
17998: PPUSH
17999: LD_INT 0
18001: PPUSH
18002: CALL 85906 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18006: LD_INT 0
18008: PPUSH
18009: LD_INT 0
18011: PPUSH
18012: LD_INT 0
18014: PPUSH
18015: LD_INT 0
18017: PPUSH
18018: LD_INT 0
18020: PPUSH
18021: LD_INT 0
18023: PPUSH
18024: LD_INT 9
18026: PPUSH
18027: LD_INT 0
18029: PPUSH
18030: LD_INT 20
18032: PPUSH
18033: CALL 85906 0 9
// end ; end_of_file
18037: LD_VAR 0 1
18041: RET
// every 0 0$30 do var time ;
18042: GO 18044
18044: DISABLE
18045: LD_INT 0
18047: PPUSH
// begin time := 0 0$30 ;
18048: LD_ADDR_VAR 0 1
18052: PUSH
18053: LD_INT 1050
18055: ST_TO_ADDR
// repeat wait ( time ) ;
18056: LD_VAR 0 1
18060: PPUSH
18061: CALL_OW 67
// if Prob ( 50 ) then
18065: LD_INT 50
18067: PPUSH
18068: CALL_OW 13
18072: IFFALSE 18101
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18074: LD_INT 1
18076: PPUSH
18077: LD_INT 5
18079: PPUSH
18080: CALL_OW 12
18084: PPUSH
18085: LD_INT 106
18087: PPUSH
18088: LD_INT 89
18090: PPUSH
18091: LD_INT 45
18093: PPUSH
18094: LD_INT 1
18096: PPUSH
18097: CALL_OW 56
// time := time + 0 0$3 ;
18101: LD_ADDR_VAR 0 1
18105: PUSH
18106: LD_VAR 0 1
18110: PUSH
18111: LD_INT 105
18113: PLUS
18114: ST_TO_ADDR
// if Prob ( 30 ) then
18115: LD_INT 30
18117: PPUSH
18118: CALL_OW 13
18122: IFFALSE 18168
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18124: LD_INT 525
18126: PPUSH
18127: LD_INT 735
18129: PPUSH
18130: CALL_OW 12
18134: PPUSH
18135: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18139: LD_INT 1
18141: PPUSH
18142: LD_INT 5
18144: PPUSH
18145: CALL_OW 12
18149: PPUSH
18150: LD_INT 21
18152: PPUSH
18153: LD_INT 26
18155: PPUSH
18156: LD_INT 12
18158: PPUSH
18159: LD_INT 1
18161: PPUSH
18162: CALL_OW 56
// end else
18166: GO 18204
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18168: LD_INT 700
18170: PPUSH
18171: LD_INT 1225
18173: PPUSH
18174: CALL_OW 12
18178: PPUSH
18179: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18183: LD_INT 1
18185: PPUSH
18186: LD_INT 5
18188: PPUSH
18189: CALL_OW 12
18193: PPUSH
18194: LD_INT 14
18196: PPUSH
18197: LD_INT 1
18199: PPUSH
18200: CALL_OW 55
// end ; if Prob ( 50 ) then
18204: LD_INT 50
18206: PPUSH
18207: CALL_OW 13
18211: IFFALSE 18257
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18213: LD_INT 700
18215: PPUSH
18216: LD_INT 1050
18218: PPUSH
18219: CALL_OW 12
18223: PPUSH
18224: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18228: LD_INT 1
18230: PPUSH
18231: LD_INT 5
18233: PPUSH
18234: CALL_OW 12
18238: PPUSH
18239: LD_INT 181
18241: PPUSH
18242: LD_INT 218
18244: PPUSH
18245: LD_INT 16
18247: PPUSH
18248: LD_INT 1
18250: PPUSH
18251: CALL_OW 56
// end else
18255: GO 18329
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18257: LD_INT 350
18259: PPUSH
18260: LD_INT 525
18262: PPUSH
18263: CALL_OW 12
18267: PPUSH
18268: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18272: LD_INT 1
18274: PPUSH
18275: LD_INT 5
18277: PPUSH
18278: CALL_OW 12
18282: PPUSH
18283: LD_INT 13
18285: PPUSH
18286: LD_INT 1
18288: PPUSH
18289: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18293: LD_INT 350
18295: PPUSH
18296: LD_INT 700
18298: PPUSH
18299: CALL_OW 12
18303: PPUSH
18304: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18308: LD_INT 1
18310: PPUSH
18311: LD_INT 5
18313: PPUSH
18314: CALL_OW 12
18318: PPUSH
18319: LD_INT 33
18321: PPUSH
18322: LD_INT 1
18324: PPUSH
18325: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18329: LD_INT 65
18331: PUSH
18332: LD_INT 62
18334: PUSH
18335: LD_INT 55
18337: PUSH
18338: LD_INT 50
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: LIST
18345: LIST
18346: PUSH
18347: LD_OWVAR 67
18351: ARRAY
18352: PPUSH
18353: CALL_OW 13
18357: IFFALSE 18403
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18359: LD_INT 525
18361: PPUSH
18362: LD_INT 875
18364: PPUSH
18365: CALL_OW 12
18369: PPUSH
18370: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18374: LD_INT 1
18376: PPUSH
18377: LD_INT 5
18379: PPUSH
18380: CALL_OW 12
18384: PPUSH
18385: LD_INT 294
18387: PPUSH
18388: LD_INT 211
18390: PPUSH
18391: LD_INT 30
18393: PPUSH
18394: LD_INT 1
18396: PPUSH
18397: CALL_OW 56
// end else
18401: GO 18445
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18403: LD_INT 420
18405: PPUSH
18406: LD_INT 770
18408: PPUSH
18409: CALL_OW 12
18413: PPUSH
18414: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18418: LD_INT 1
18420: PPUSH
18421: LD_INT 5
18423: PPUSH
18424: CALL_OW 12
18428: PPUSH
18429: LD_INT 294
18431: PPUSH
18432: LD_INT 211
18434: PPUSH
18435: LD_INT 30
18437: PPUSH
18438: LD_INT 1
18440: PPUSH
18441: CALL_OW 56
// end ; if time > 2 2$20 then
18445: LD_VAR 0 1
18449: PUSH
18450: LD_INT 4900
18452: GREATER
18453: IFFALSE 18463
// time := 0 0$50 ;
18455: LD_ADDR_VAR 0 1
18459: PUSH
18460: LD_INT 1750
18462: ST_TO_ADDR
// until false ;
18463: LD_INT 0
18465: IFFALSE 18056
// end ;
18467: PPOPN 1
18469: END
// every 0 0$45 trigger tick < 10 10$00 do
18470: LD_OWVAR 1
18474: PUSH
18475: LD_INT 21000
18477: LESS
18478: IFFALSE 18526
18480: GO 18482
18482: DISABLE
// begin enable ;
18483: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18484: LD_INT 350
18486: PPUSH
18487: LD_INT 700
18489: PPUSH
18490: CALL_OW 12
18494: PPUSH
18495: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18499: LD_INT 3
18501: PPUSH
18502: LD_INT 5
18504: PPUSH
18505: CALL_OW 12
18509: PPUSH
18510: LD_INT 181
18512: PPUSH
18513: LD_INT 13
18515: PPUSH
18516: LD_INT 20
18518: PPUSH
18519: LD_INT 1
18521: PPUSH
18522: CALL_OW 56
// end ; end_of_file
18526: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18527: LD_INT 0
18529: PPUSH
// SetArtifactRes ( 7 , true ) ;
18530: LD_INT 7
18532: PPUSH
18533: LD_INT 1
18535: PPUSH
18536: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18540: LD_ADDR_EXP 64
18544: PUSH
18545: EMPTY
18546: PUSH
18547: EMPTY
18548: PUSH
18549: EMPTY
18550: PUSH
18551: EMPTY
18552: LIST
18553: LIST
18554: LIST
18555: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18556: LD_ADDR_EXP 65
18560: PUSH
18561: LD_INT 1050
18563: PUSH
18564: LD_OWVAR 67
18568: MUL
18569: PUSH
18570: LD_INT 2800
18572: PUSH
18573: LD_OWVAR 67
18577: MUL
18578: PUSH
18579: LD_INT 1
18581: NEG
18582: PUSH
18583: EMPTY
18584: LIST
18585: LIST
18586: LIST
18587: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18588: LD_ADDR_EXP 66
18592: PUSH
18593: LD_INT 10
18595: PUSH
18596: LD_INT 35
18598: PUSH
18599: LD_INT 100
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18607: LD_ADDR_EXP 67
18611: PUSH
18612: LD_INT 0
18614: PUSH
18615: LD_INT 0
18617: PUSH
18618: LD_INT 0
18620: PUSH
18621: EMPTY
18622: LIST
18623: LIST
18624: LIST
18625: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18626: LD_ADDR_EXP 69
18630: PUSH
18631: LD_INT 300
18633: PUSH
18634: LD_INT 500
18636: PUSH
18637: LD_INT 800
18639: PUSH
18640: EMPTY
18641: LIST
18642: LIST
18643: LIST
18644: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18645: LD_ADDR_EXP 70
18649: PUSH
18650: LD_INT 0
18652: PUSH
18653: LD_INT 0
18655: PUSH
18656: LD_INT 0
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: LIST
18663: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18664: LD_ADDR_EXP 71
18668: PUSH
18669: LD_INT 0
18671: PUSH
18672: LD_INT 0
18674: PUSH
18675: LD_INT 0
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: LIST
18682: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18683: LD_ADDR_EXP 68
18687: PUSH
18688: LD_INT 0
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: LIST
18701: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18702: LD_ADDR_EXP 72
18706: PUSH
18707: LD_INT 4
18709: PUSH
18710: LD_INT 3
18712: PUSH
18713: LD_INT 1
18715: PUSH
18716: EMPTY
18717: LIST
18718: LIST
18719: LIST
18720: PUSH
18721: LD_INT 5
18723: PUSH
18724: LD_INT 4
18726: PUSH
18727: LD_INT 2
18729: PUSH
18730: EMPTY
18731: LIST
18732: LIST
18733: LIST
18734: PUSH
18735: LD_INT 6
18737: PUSH
18738: LD_INT 3
18740: PUSH
18741: LD_INT 3
18743: PUSH
18744: EMPTY
18745: LIST
18746: LIST
18747: LIST
18748: PUSH
18749: EMPTY
18750: LIST
18751: LIST
18752: LIST
18753: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18754: LD_ADDR_EXP 73
18758: PUSH
18759: LD_INT 0
18761: PUSH
18762: LD_INT 0
18764: PUSH
18765: LD_INT 0
18767: PUSH
18768: EMPTY
18769: LIST
18770: LIST
18771: LIST
18772: ST_TO_ADDR
// end ;
18773: LD_VAR 0 1
18777: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18778: LD_INT 24
18780: PPUSH
18781: LD_INT 7
18783: PPUSH
18784: CALL_OW 321
18788: PUSH
18789: LD_INT 2
18791: EQUAL
18792: IFFALSE 19718
18794: GO 18796
18796: DISABLE
18797: LD_INT 0
18799: PPUSH
18800: PPUSH
18801: PPUSH
18802: PPUSH
18803: PPUSH
// begin enable ;
18804: ENABLE
// for i = 1 to 3 do
18805: LD_ADDR_VAR 0 1
18809: PUSH
18810: DOUBLE
18811: LD_INT 1
18813: DEC
18814: ST_TO_ADDR
18815: LD_INT 3
18817: PUSH
18818: FOR_TO
18819: IFFALSE 19716
// begin pos := FindArtifact ( i + 2 ) ;
18821: LD_ADDR_VAR 0 2
18825: PUSH
18826: LD_VAR 0 1
18830: PUSH
18831: LD_INT 2
18833: PLUS
18834: PPUSH
18835: CALL_OW 469
18839: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18840: LD_ADDR_EXP 64
18844: PUSH
18845: LD_EXP 64
18849: PPUSH
18850: LD_VAR 0 1
18854: PPUSH
18855: LD_VAR 0 2
18859: PPUSH
18860: CALL_OW 1
18864: ST_TO_ADDR
// if pos then
18865: LD_VAR 0 2
18869: IFFALSE 19577
// begin case i of 1 :
18871: LD_VAR 0 1
18875: PUSH
18876: LD_INT 1
18878: DOUBLE
18879: EQUAL
18880: IFTRUE 18884
18882: GO 18961
18884: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18885: LD_ADDR_VAR 0 4
18889: PUSH
18890: LD_INT 22
18892: PUSH
18893: LD_INT 7
18895: PUSH
18896: EMPTY
18897: LIST
18898: LIST
18899: PUSH
18900: LD_INT 23
18902: PUSH
18903: LD_INT 1
18905: PUSH
18906: EMPTY
18907: LIST
18908: LIST
18909: PUSH
18910: LD_INT 2
18912: PUSH
18913: LD_INT 30
18915: PUSH
18916: LD_INT 8
18918: PUSH
18919: EMPTY
18920: LIST
18921: LIST
18922: PUSH
18923: LD_INT 30
18925: PUSH
18926: LD_INT 7
18928: PUSH
18929: EMPTY
18930: LIST
18931: LIST
18932: PUSH
18933: LD_INT 30
18935: PUSH
18936: LD_INT 11
18938: PUSH
18939: EMPTY
18940: LIST
18941: LIST
18942: PUSH
18943: EMPTY
18944: LIST
18945: LIST
18946: LIST
18947: LIST
18948: PUSH
18949: EMPTY
18950: LIST
18951: LIST
18952: LIST
18953: PPUSH
18954: CALL_OW 69
18958: ST_TO_ADDR
18959: GO 19069
18961: LD_INT 2
18963: DOUBLE
18964: EQUAL
18965: IFTRUE 18969
18967: GO 19046
18969: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18970: LD_ADDR_VAR 0 4
18974: PUSH
18975: LD_INT 22
18977: PUSH
18978: LD_INT 7
18980: PUSH
18981: EMPTY
18982: LIST
18983: LIST
18984: PUSH
18985: LD_INT 23
18987: PUSH
18988: LD_INT 3
18990: PUSH
18991: EMPTY
18992: LIST
18993: LIST
18994: PUSH
18995: LD_INT 2
18997: PUSH
18998: LD_INT 30
19000: PUSH
19001: LD_INT 8
19003: PUSH
19004: EMPTY
19005: LIST
19006: LIST
19007: PUSH
19008: LD_INT 30
19010: PUSH
19011: LD_INT 7
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: PUSH
19018: LD_INT 30
19020: PUSH
19021: LD_INT 11
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PUSH
19028: EMPTY
19029: LIST
19030: LIST
19031: LIST
19032: LIST
19033: PUSH
19034: EMPTY
19035: LIST
19036: LIST
19037: LIST
19038: PPUSH
19039: CALL_OW 69
19043: ST_TO_ADDR
19044: GO 19069
19046: LD_INT 3
19048: DOUBLE
19049: EQUAL
19050: IFTRUE 19054
19052: GO 19068
19054: POP
// labs := [ alien ] ; end ;
19055: LD_ADDR_VAR 0 4
19059: PUSH
19060: LD_INT 1
19062: PUSH
19063: EMPTY
19064: LIST
19065: ST_TO_ADDR
19066: GO 19069
19068: POP
// if not labs then
19069: LD_VAR 0 4
19073: NOT
19074: IFFALSE 19078
// continue ;
19076: GO 18818
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19078: LD_ADDR_VAR 0 5
19082: PUSH
19083: LD_VAR 0 4
19087: PPUSH
19088: LD_EXP 64
19092: PUSH
19093: LD_VAR 0 1
19097: ARRAY
19098: PUSH
19099: LD_INT 1
19101: ARRAY
19102: PPUSH
19103: LD_EXP 64
19107: PUSH
19108: LD_VAR 0 1
19112: ARRAY
19113: PUSH
19114: LD_INT 2
19116: ARRAY
19117: PPUSH
19118: CALL_OW 73
19122: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19123: LD_VAR 0 5
19127: NOT
19128: PUSH
19129: LD_VAR 0 5
19133: PUSH
19134: LD_EXP 71
19138: PUSH
19139: LD_VAR 0 1
19143: ARRAY
19144: NONEQUAL
19145: OR
19146: IFFALSE 19251
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19148: LD_INT 7
19150: PPUSH
19151: LD_EXP 72
19155: PUSH
19156: LD_VAR 0 1
19160: ARRAY
19161: PUSH
19162: LD_INT 3
19164: ARRAY
19165: PPUSH
19166: LD_INT 0
19168: PPUSH
19169: LD_EXP 71
19173: PUSH
19174: LD_VAR 0 1
19178: ARRAY
19179: PPUSH
19180: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19184: LD_INT 7
19186: PPUSH
19187: LD_EXP 72
19191: PUSH
19192: LD_VAR 0 1
19196: ARRAY
19197: PUSH
19198: LD_INT 1
19200: ARRAY
19201: PPUSH
19202: LD_INT 0
19204: PPUSH
19205: LD_EXP 71
19209: PUSH
19210: LD_VAR 0 1
19214: ARRAY
19215: PPUSH
19216: CALL_OW 468
// if nearestLab then
19220: LD_VAR 0 5
19224: IFFALSE 19251
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19226: LD_ADDR_EXP 71
19230: PUSH
19231: LD_EXP 71
19235: PPUSH
19236: LD_VAR 0 1
19240: PPUSH
19241: LD_VAR 0 5
19245: PPUSH
19246: CALL_OW 1
19250: ST_TO_ADDR
// end ; if not nearestLab then
19251: LD_VAR 0 5
19255: NOT
19256: IFFALSE 19260
// continue ;
19258: GO 18818
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19260: LD_VAR 0 5
19264: PPUSH
19265: LD_EXP 64
19269: PUSH
19270: LD_VAR 0 1
19274: ARRAY
19275: PUSH
19276: LD_INT 1
19278: ARRAY
19279: PPUSH
19280: LD_EXP 64
19284: PUSH
19285: LD_VAR 0 1
19289: ARRAY
19290: PUSH
19291: LD_INT 2
19293: ARRAY
19294: PPUSH
19295: CALL_OW 297
19299: PUSH
19300: LD_INT 8
19302: LESS
19303: IFFALSE 19500
// begin if not artifactsResearched [ i ] then
19305: LD_EXP 67
19309: PUSH
19310: LD_VAR 0 1
19314: ARRAY
19315: NOT
19316: IFFALSE 19397
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19318: LD_VAR 0 5
19322: PPUSH
19323: CALL_OW 461
19327: PUSH
19328: LD_INT 2
19330: EQUAL
19331: IFFALSE 19365
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19333: LD_INT 7
19335: PPUSH
19336: LD_EXP 72
19340: PUSH
19341: LD_VAR 0 1
19345: ARRAY
19346: PUSH
19347: LD_INT 3
19349: ARRAY
19350: PPUSH
19351: LD_INT 2
19353: PPUSH
19354: LD_VAR 0 5
19358: PPUSH
19359: CALL_OW 468
19363: GO 19395
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19365: LD_INT 7
19367: PPUSH
19368: LD_EXP 72
19372: PUSH
19373: LD_VAR 0 1
19377: ARRAY
19378: PUSH
19379: LD_INT 3
19381: ARRAY
19382: PPUSH
19383: LD_INT 1
19385: PPUSH
19386: LD_VAR 0 5
19390: PPUSH
19391: CALL_OW 468
// end else
19395: GO 19498
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19397: LD_VAR 0 5
19401: PPUSH
19402: CALL_OW 461
19406: PUSH
19407: LD_INT 2
19409: EQUAL
19410: PUSH
19411: LD_EXP 73
19415: PUSH
19416: LD_VAR 0 1
19420: ARRAY
19421: AND
19422: IFFALSE 19468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19424: LD_INT 7
19426: PPUSH
19427: LD_EXP 72
19431: PUSH
19432: LD_VAR 0 1
19436: ARRAY
19437: PUSH
19438: LD_INT 1
19440: ARRAY
19441: PPUSH
19442: LD_EXP 72
19446: PUSH
19447: LD_VAR 0 1
19451: ARRAY
19452: PUSH
19453: LD_INT 2
19455: ARRAY
19456: PPUSH
19457: LD_VAR 0 5
19461: PPUSH
19462: CALL_OW 468
19466: GO 19498
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19468: LD_INT 7
19470: PPUSH
19471: LD_EXP 72
19475: PUSH
19476: LD_VAR 0 1
19480: ARRAY
19481: PUSH
19482: LD_INT 1
19484: ARRAY
19485: PPUSH
19486: LD_INT 1
19488: PPUSH
19489: LD_VAR 0 5
19493: PPUSH
19494: CALL_OW 468
// end else
19498: GO 19575
// begin if not artifactsResearched [ i ] then
19500: LD_EXP 67
19504: PUSH
19505: LD_VAR 0 1
19509: ARRAY
19510: NOT
19511: IFFALSE 19545
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19513: LD_INT 7
19515: PPUSH
19516: LD_EXP 72
19520: PUSH
19521: LD_VAR 0 1
19525: ARRAY
19526: PUSH
19527: LD_INT 3
19529: ARRAY
19530: PPUSH
19531: LD_INT 0
19533: PPUSH
19534: LD_VAR 0 5
19538: PPUSH
19539: CALL_OW 468
19543: GO 19575
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19545: LD_INT 7
19547: PPUSH
19548: LD_EXP 72
19552: PUSH
19553: LD_VAR 0 1
19557: ARRAY
19558: PUSH
19559: LD_INT 1
19561: ARRAY
19562: PPUSH
19563: LD_INT 0
19565: PPUSH
19566: LD_VAR 0 5
19570: PPUSH
19571: CALL_OW 468
// end ; end else
19575: GO 19714
// begin if not artifactsLabs [ i ] then
19577: LD_EXP 71
19581: PUSH
19582: LD_VAR 0 1
19586: ARRAY
19587: NOT
19588: IFFALSE 19592
// continue ;
19590: GO 18818
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19592: LD_INT 7
19594: PPUSH
19595: LD_EXP 72
19599: PUSH
19600: LD_VAR 0 1
19604: ARRAY
19605: PUSH
19606: LD_INT 3
19608: ARRAY
19609: PPUSH
19610: LD_INT 0
19612: PPUSH
19613: LD_EXP 71
19617: PUSH
19618: LD_VAR 0 1
19622: ARRAY
19623: PPUSH
19624: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19628: LD_INT 7
19630: PPUSH
19631: LD_EXP 72
19635: PUSH
19636: LD_VAR 0 1
19640: ARRAY
19641: PUSH
19642: LD_INT 1
19644: ARRAY
19645: PPUSH
19646: LD_INT 0
19648: PPUSH
19649: LD_EXP 71
19653: PUSH
19654: LD_VAR 0 1
19658: ARRAY
19659: PPUSH
19660: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19664: LD_EXP 68
19668: PUSH
19669: LD_VAR 0 1
19673: ARRAY
19674: IFFALSE 19714
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19676: LD_ADDR_EXP 68
19680: PUSH
19681: LD_EXP 68
19685: PPUSH
19686: LD_VAR 0 1
19690: PPUSH
19691: LD_INT 0
19693: PPUSH
19694: CALL_OW 1
19698: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19699: LD_EXP 71
19703: PUSH
19704: LD_VAR 0 1
19708: ARRAY
19709: PPUSH
19710: CALL_OW 127
// end ; end ; end ;
19714: GO 18818
19716: POP
19717: POP
// end ;
19718: PPOPN 5
19720: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19721: LD_INT 0
19723: PPUSH
19724: PPUSH
19725: PPUSH
19726: PPUSH
19727: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19728: LD_VAR 0 2
19732: PUSH
19733: LD_EXP 72
19737: PUSH
19738: LD_INT 1
19740: ARRAY
19741: PUSH
19742: LD_INT 3
19744: ARRAY
19745: EQUAL
19746: IFFALSE 19869
// begin lab := artifactsLabs [ 1 ] ;
19748: LD_ADDR_VAR 0 6
19752: PUSH
19753: LD_EXP 71
19757: PUSH
19758: LD_INT 1
19760: ARRAY
19761: ST_TO_ADDR
// if not lab then
19762: LD_VAR 0 6
19766: NOT
19767: IFFALSE 19771
// exit ;
19769: GO 20849
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19771: LD_VAR 0 6
19775: PPUSH
19776: LD_EXP 69
19780: PUSH
19781: LD_INT 1
19783: ARRAY
19784: PPUSH
19785: LD_INT 1
19787: PPUSH
19788: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19792: LD_EXP 70
19796: PUSH
19797: LD_INT 1
19799: ARRAY
19800: IFFALSE 19820
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19802: LD_VAR 0 6
19806: PPUSH
19807: LD_EXP 70
19811: PUSH
19812: LD_INT 1
19814: ARRAY
19815: PPUSH
19816: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19820: LD_ADDR_EXP 68
19824: PUSH
19825: LD_EXP 68
19829: PPUSH
19830: LD_INT 1
19832: PPUSH
19833: LD_INT 1
19835: PPUSH
19836: CALL_OW 1
19840: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19841: LD_INT 7
19843: PPUSH
19844: LD_EXP 72
19848: PUSH
19849: LD_INT 1
19851: ARRAY
19852: PUSH
19853: LD_INT 3
19855: ARRAY
19856: PPUSH
19857: LD_INT 0
19859: PPUSH
19860: LD_VAR 0 6
19864: PPUSH
19865: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19869: LD_VAR 0 2
19873: PUSH
19874: LD_EXP 72
19878: PUSH
19879: LD_INT 2
19881: ARRAY
19882: PUSH
19883: LD_INT 3
19885: ARRAY
19886: EQUAL
19887: IFFALSE 20010
// begin lab := artifactsLabs [ 2 ] ;
19889: LD_ADDR_VAR 0 6
19893: PUSH
19894: LD_EXP 71
19898: PUSH
19899: LD_INT 2
19901: ARRAY
19902: ST_TO_ADDR
// if not lab then
19903: LD_VAR 0 6
19907: NOT
19908: IFFALSE 19912
// exit ;
19910: GO 20849
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19912: LD_VAR 0 6
19916: PPUSH
19917: LD_EXP 69
19921: PUSH
19922: LD_INT 2
19924: ARRAY
19925: PPUSH
19926: LD_INT 1
19928: PPUSH
19929: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19933: LD_EXP 70
19937: PUSH
19938: LD_INT 2
19940: ARRAY
19941: IFFALSE 19961
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19943: LD_VAR 0 6
19947: PPUSH
19948: LD_EXP 70
19952: PUSH
19953: LD_INT 2
19955: ARRAY
19956: PPUSH
19957: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19961: LD_ADDR_EXP 68
19965: PUSH
19966: LD_EXP 68
19970: PPUSH
19971: LD_INT 2
19973: PPUSH
19974: LD_INT 1
19976: PPUSH
19977: CALL_OW 1
19981: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19982: LD_INT 7
19984: PPUSH
19985: LD_EXP 72
19989: PUSH
19990: LD_INT 2
19992: ARRAY
19993: PUSH
19994: LD_INT 3
19996: ARRAY
19997: PPUSH
19998: LD_INT 0
20000: PPUSH
20001: LD_VAR 0 6
20005: PPUSH
20006: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20010: LD_VAR 0 2
20014: PUSH
20015: LD_EXP 72
20019: PUSH
20020: LD_INT 3
20022: ARRAY
20023: PUSH
20024: LD_INT 3
20026: ARRAY
20027: EQUAL
20028: IFFALSE 20151
// begin lab := artifactsLabs [ 3 ] ;
20030: LD_ADDR_VAR 0 6
20034: PUSH
20035: LD_EXP 71
20039: PUSH
20040: LD_INT 3
20042: ARRAY
20043: ST_TO_ADDR
// if not lab then
20044: LD_VAR 0 6
20048: NOT
20049: IFFALSE 20053
// exit ;
20051: GO 20849
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20053: LD_VAR 0 6
20057: PPUSH
20058: LD_EXP 69
20062: PUSH
20063: LD_INT 3
20065: ARRAY
20066: PPUSH
20067: LD_INT 1
20069: PPUSH
20070: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20074: LD_EXP 70
20078: PUSH
20079: LD_INT 3
20081: ARRAY
20082: IFFALSE 20102
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20084: LD_VAR 0 6
20088: PPUSH
20089: LD_EXP 70
20093: PUSH
20094: LD_INT 3
20096: ARRAY
20097: PPUSH
20098: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20102: LD_ADDR_EXP 68
20106: PUSH
20107: LD_EXP 68
20111: PPUSH
20112: LD_INT 3
20114: PPUSH
20115: LD_INT 1
20117: PPUSH
20118: CALL_OW 1
20122: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20123: LD_INT 7
20125: PPUSH
20126: LD_EXP 72
20130: PUSH
20131: LD_INT 3
20133: ARRAY
20134: PUSH
20135: LD_INT 3
20137: ARRAY
20138: PPUSH
20139: LD_INT 0
20141: PPUSH
20142: LD_VAR 0 6
20146: PPUSH
20147: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20151: LD_VAR 0 2
20155: PUSH
20156: LD_EXP 72
20160: PUSH
20161: LD_INT 1
20163: ARRAY
20164: PUSH
20165: LD_INT 1
20167: ARRAY
20168: EQUAL
20169: IFFALSE 20327
// begin lab := artifactsLabs [ 1 ] ;
20171: LD_ADDR_VAR 0 6
20175: PUSH
20176: LD_EXP 71
20180: PUSH
20181: LD_INT 1
20183: ARRAY
20184: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20185: LD_VAR 0 6
20189: PPUSH
20190: CALL_OW 274
20194: PPUSH
20195: CALL 89454 0 1
20199: PUSH
20200: LD_INT 3
20202: ARRAY
20203: PUSH
20204: LD_EXP 66
20208: PUSH
20209: LD_INT 1
20211: ARRAY
20212: LESS
20213: IFFALSE 20227
// begin HintSpec ( ArtifactCost , 2 ) ;
20215: LD_STRING ArtifactCost
20217: PPUSH
20218: LD_INT 2
20220: PPUSH
20221: CALL_OW 338
// exit ;
20225: GO 20849
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20227: LD_ADDR_EXP 73
20231: PUSH
20232: LD_EXP 73
20236: PPUSH
20237: LD_INT 1
20239: PPUSH
20240: LD_INT 0
20242: PPUSH
20243: CALL_OW 1
20247: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20248: LD_VAR 0 3
20252: PPUSH
20253: LD_VAR 0 4
20257: PPUSH
20258: LD_INT 7
20260: PPUSH
20261: LD_INT 12
20263: NEG
20264: PPUSH
20265: CALL_OW 330
// wait ( 0 0$30 ) ;
20269: LD_INT 1050
20271: PPUSH
20272: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20276: LD_VAR 0 3
20280: PPUSH
20281: LD_VAR 0 4
20285: PPUSH
20286: LD_INT 7
20288: PPUSH
20289: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20293: LD_EXP 65
20297: PUSH
20298: LD_INT 1
20300: ARRAY
20301: PPUSH
20302: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20306: LD_ADDR_EXP 73
20310: PUSH
20311: LD_EXP 73
20315: PPUSH
20316: LD_INT 1
20318: PPUSH
20319: LD_INT 1
20321: PPUSH
20322: CALL_OW 1
20326: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20327: LD_VAR 0 2
20331: PUSH
20332: LD_EXP 72
20336: PUSH
20337: LD_INT 2
20339: ARRAY
20340: PUSH
20341: LD_INT 1
20343: ARRAY
20344: EQUAL
20345: IFFALSE 20582
// begin lab := artifactsLabs [ 2 ] ;
20347: LD_ADDR_VAR 0 6
20351: PUSH
20352: LD_EXP 71
20356: PUSH
20357: LD_INT 2
20359: ARRAY
20360: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20361: LD_VAR 0 3
20365: PUSH
20366: LD_INT 81
20368: PUSH
20369: LD_INT 7
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: PUSH
20376: LD_INT 2
20378: PUSH
20379: LD_INT 32
20381: PUSH
20382: LD_INT 3
20384: PUSH
20385: EMPTY
20386: LIST
20387: LIST
20388: PUSH
20389: LD_INT 30
20391: PUSH
20392: LD_INT 28
20394: PUSH
20395: EMPTY
20396: LIST
20397: LIST
20398: PUSH
20399: LD_INT 30
20401: PUSH
20402: LD_INT 30
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PUSH
20409: LD_INT 35
20411: PUSH
20412: LD_INT 49
20414: PUSH
20415: EMPTY
20416: LIST
20417: LIST
20418: PUSH
20419: LD_INT 34
20421: PUSH
20422: LD_INT 49
20424: PUSH
20425: EMPTY
20426: LIST
20427: LIST
20428: PUSH
20429: LD_INT 30
20431: PUSH
20432: LD_INT 21
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: LIST
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: PPUSH
20452: CALL_OW 69
20456: IN
20457: NOT
20458: IFFALSE 20462
// exit ;
20460: GO 20849
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20462: LD_VAR 0 6
20466: PPUSH
20467: CALL_OW 274
20471: PPUSH
20472: CALL 89454 0 1
20476: PUSH
20477: LD_INT 3
20479: ARRAY
20480: PUSH
20481: LD_EXP 66
20485: PUSH
20486: LD_INT 2
20488: ARRAY
20489: LESS
20490: IFFALSE 20504
// begin HintSpec ( ArtifactCost , 2 ) ;
20492: LD_STRING ArtifactCost
20494: PPUSH
20495: LD_INT 2
20497: PPUSH
20498: CALL_OW 338
// exit ;
20502: GO 20849
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20504: LD_ADDR_EXP 73
20508: PUSH
20509: LD_EXP 73
20513: PPUSH
20514: LD_INT 2
20516: PPUSH
20517: LD_INT 0
20519: PPUSH
20520: CALL_OW 1
20524: ST_TO_ADDR
// KillUnit ( x ) ;
20525: LD_VAR 0 3
20529: PPUSH
20530: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20534: LD_ADDR_EXP 16
20538: PUSH
20539: LD_EXP 16
20543: PUSH
20544: LD_INT 1
20546: PLUS
20547: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20548: LD_EXP 65
20552: PUSH
20553: LD_INT 2
20555: ARRAY
20556: PPUSH
20557: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20561: LD_ADDR_EXP 73
20565: PUSH
20566: LD_EXP 73
20570: PPUSH
20571: LD_INT 2
20573: PPUSH
20574: LD_INT 1
20576: PPUSH
20577: CALL_OW 1
20581: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20582: LD_VAR 0 2
20586: PUSH
20587: LD_EXP 72
20591: PUSH
20592: LD_INT 3
20594: ARRAY
20595: PUSH
20596: LD_INT 1
20598: ARRAY
20599: EQUAL
20600: IFFALSE 20849
// begin lab := artifactsLabs [ 3 ] ;
20602: LD_ADDR_VAR 0 6
20606: PUSH
20607: LD_EXP 71
20611: PUSH
20612: LD_INT 3
20614: ARRAY
20615: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20616: LD_VAR 0 6
20620: PPUSH
20621: CALL_OW 274
20625: PPUSH
20626: CALL 89454 0 1
20630: PUSH
20631: LD_INT 3
20633: ARRAY
20634: PUSH
20635: LD_EXP 66
20639: PUSH
20640: LD_INT 3
20642: ARRAY
20643: LESS
20644: IFFALSE 20658
// begin HintSpec ( ArtifactCost , 2 ) ;
20646: LD_STRING ArtifactCost
20648: PPUSH
20649: LD_INT 2
20651: PPUSH
20652: CALL_OW 338
// exit ;
20656: GO 20849
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20658: LD_INT 37
20660: PPUSH
20661: LD_INT 1
20663: PPUSH
20664: CALL_OW 424
// time := 0 0$30 ;
20668: LD_ADDR_VAR 0 7
20672: PUSH
20673: LD_INT 1050
20675: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20676: LD_ADDR_EXP 73
20680: PUSH
20681: LD_EXP 73
20685: PPUSH
20686: LD_INT 3
20688: PPUSH
20689: LD_INT 0
20691: PPUSH
20692: CALL_OW 1
20696: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20697: LD_ADDR_OWVAR 47
20701: PUSH
20702: LD_STRING #Am15a-1
20704: PUSH
20705: LD_VAR 0 7
20709: PUSH
20710: EMPTY
20711: LIST
20712: LIST
20713: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20714: LD_INT 35
20716: PPUSH
20717: CALL_OW 67
// time := time - 0 0$1 ;
20721: LD_ADDR_VAR 0 7
20725: PUSH
20726: LD_VAR 0 7
20730: PUSH
20731: LD_INT 35
20733: MINUS
20734: ST_TO_ADDR
// until time = 0 0$00 ;
20735: LD_VAR 0 7
20739: PUSH
20740: LD_INT 0
20742: EQUAL
20743: IFFALSE 20697
// display_strings :=  ;
20745: LD_ADDR_OWVAR 47
20749: PUSH
20750: LD_STRING 
20752: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20753: LD_INT 37
20755: PPUSH
20756: LD_INT 0
20758: PPUSH
20759: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20763: LD_ADDR_VAR 0 8
20767: PUSH
20768: LD_INT 37
20770: PPUSH
20771: LD_INT 3
20773: PUSH
20774: LD_INT 21
20776: PUSH
20777: LD_INT 3
20779: PUSH
20780: EMPTY
20781: LIST
20782: LIST
20783: PUSH
20784: EMPTY
20785: LIST
20786: LIST
20787: PPUSH
20788: CALL_OW 70
20792: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20793: LD_VAR 0 3
20797: PPUSH
20798: LD_VAR 0 4
20802: PPUSH
20803: CALL_OW 84
// for un in list do
20807: LD_ADDR_VAR 0 9
20811: PUSH
20812: LD_VAR 0 8
20816: PUSH
20817: FOR_IN
20818: IFFALSE 20847
// TeleportUnit ( un , x , y , 12 , true ) ;
20820: LD_VAR 0 9
20824: PPUSH
20825: LD_VAR 0 3
20829: PPUSH
20830: LD_VAR 0 4
20834: PPUSH
20835: LD_INT 12
20837: PPUSH
20838: LD_INT 1
20840: PPUSH
20841: CALL_OW 483
20845: GO 20817
20847: POP
20848: POP
// end ; end ;
20849: PPOPN 9
20851: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20852: LD_INT 0
20854: PPUSH
20855: PPUSH
// begin labNum := 0 ;
20856: LD_ADDR_VAR 0 4
20860: PUSH
20861: LD_INT 0
20863: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20864: LD_ADDR_VAR 0 3
20868: PUSH
20869: DOUBLE
20870: LD_INT 1
20872: DEC
20873: ST_TO_ADDR
20874: LD_EXP 71
20878: PUSH
20879: FOR_TO
20880: IFFALSE 20914
// if artifactsLabs [ i ] = lab then
20882: LD_EXP 71
20886: PUSH
20887: LD_VAR 0 3
20891: ARRAY
20892: PUSH
20893: LD_VAR 0 1
20897: EQUAL
20898: IFFALSE 20912
// begin labNum := i ;
20900: LD_ADDR_VAR 0 4
20904: PUSH
20905: LD_VAR 0 3
20909: ST_TO_ADDR
// break ;
20910: GO 20914
// end ;
20912: GO 20879
20914: POP
20915: POP
// if not labNum then
20916: LD_VAR 0 4
20920: NOT
20921: IFFALSE 20925
// exit ;
20923: GO 21003
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20925: LD_INT 7
20927: PPUSH
20928: LD_EXP 72
20932: PUSH
20933: LD_VAR 0 4
20937: ARRAY
20938: PUSH
20939: LD_INT 3
20941: ARRAY
20942: PPUSH
20943: LD_INT 2
20945: PPUSH
20946: LD_VAR 0 1
20950: PPUSH
20951: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20955: LD_ADDR_EXP 70
20959: PUSH
20960: LD_EXP 70
20964: PPUSH
20965: LD_VAR 0 4
20969: PPUSH
20970: LD_VAR 0 2
20974: PPUSH
20975: CALL_OW 1
20979: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20980: LD_ADDR_EXP 68
20984: PUSH
20985: LD_EXP 68
20989: PPUSH
20990: LD_VAR 0 4
20994: PPUSH
20995: LD_INT 0
20997: PPUSH
20998: CALL_OW 1
21002: ST_TO_ADDR
// end ;
21003: PPOPN 4
21005: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21006: LD_INT 0
21008: PPUSH
21009: PPUSH
// begin labNum := 0 ;
21010: LD_ADDR_VAR 0 3
21014: PUSH
21015: LD_INT 0
21017: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21018: LD_ADDR_VAR 0 2
21022: PUSH
21023: DOUBLE
21024: LD_INT 1
21026: DEC
21027: ST_TO_ADDR
21028: LD_EXP 71
21032: PUSH
21033: FOR_TO
21034: IFFALSE 21068
// if artifactsLabs [ i ] = lab then
21036: LD_EXP 71
21040: PUSH
21041: LD_VAR 0 2
21045: ARRAY
21046: PUSH
21047: LD_VAR 0 1
21051: EQUAL
21052: IFFALSE 21066
// begin labNum := i ;
21054: LD_ADDR_VAR 0 3
21058: PUSH
21059: LD_VAR 0 2
21063: ST_TO_ADDR
// break ;
21064: GO 21068
// end ;
21066: GO 21033
21068: POP
21069: POP
// if not labNum then
21070: LD_VAR 0 3
21074: NOT
21075: IFFALSE 21079
// exit ;
21077: GO 21241
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21079: LD_INT 7
21081: PPUSH
21082: LD_EXP 72
21086: PUSH
21087: LD_VAR 0 3
21091: ARRAY
21092: PUSH
21093: LD_INT 3
21095: ARRAY
21096: PPUSH
21097: LD_INT 0
21099: PPUSH
21100: LD_VAR 0 1
21104: PPUSH
21105: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21109: LD_ADDR_EXP 67
21113: PUSH
21114: LD_EXP 67
21118: PPUSH
21119: LD_VAR 0 3
21123: PPUSH
21124: LD_INT 1
21126: PPUSH
21127: CALL_OW 1
21131: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21132: LD_ADDR_EXP 73
21136: PUSH
21137: LD_EXP 73
21141: PPUSH
21142: LD_VAR 0 3
21146: PPUSH
21147: LD_INT 1
21149: PPUSH
21150: CALL_OW 1
21154: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21155: LD_ADDR_EXP 68
21159: PUSH
21160: LD_EXP 68
21164: PPUSH
21165: LD_VAR 0 3
21169: PPUSH
21170: LD_INT 0
21172: PPUSH
21173: CALL_OW 1
21177: ST_TO_ADDR
// case labNum of 1 :
21178: LD_VAR 0 3
21182: PUSH
21183: LD_INT 1
21185: DOUBLE
21186: EQUAL
21187: IFTRUE 21191
21189: GO 21202
21191: POP
// artifactIResearched := true ; 2 :
21192: LD_ADDR_EXP 12
21196: PUSH
21197: LD_INT 1
21199: ST_TO_ADDR
21200: GO 21241
21202: LD_INT 2
21204: DOUBLE
21205: EQUAL
21206: IFTRUE 21210
21208: GO 21221
21210: POP
// artifactIIResearched := true ; 3 :
21211: LD_ADDR_EXP 13
21215: PUSH
21216: LD_INT 1
21218: ST_TO_ADDR
21219: GO 21241
21221: LD_INT 3
21223: DOUBLE
21224: EQUAL
21225: IFTRUE 21229
21227: GO 21240
21229: POP
// artifactIIIResearched := true ; end ;
21230: LD_ADDR_EXP 14
21234: PUSH
21235: LD_INT 1
21237: ST_TO_ADDR
21238: GO 21241
21240: POP
// end ; end_of_file
21241: PPOPN 3
21243: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
21244: LD_INT 0
21246: PPUSH
21247: PPUSH
// skirmish := false ;
21248: LD_ADDR_EXP 74
21252: PUSH
21253: LD_INT 0
21255: ST_TO_ADDR
// debug_mc := false ;
21256: LD_ADDR_EXP 75
21260: PUSH
21261: LD_INT 0
21263: ST_TO_ADDR
// mc_bases := [ ] ;
21264: LD_ADDR_EXP 76
21268: PUSH
21269: EMPTY
21270: ST_TO_ADDR
// mc_sides := [ ] ;
21271: LD_ADDR_EXP 102
21275: PUSH
21276: EMPTY
21277: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21278: LD_ADDR_EXP 77
21282: PUSH
21283: EMPTY
21284: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21285: LD_ADDR_EXP 78
21289: PUSH
21290: EMPTY
21291: ST_TO_ADDR
// mc_need_heal := [ ] ;
21292: LD_ADDR_EXP 79
21296: PUSH
21297: EMPTY
21298: ST_TO_ADDR
// mc_healers := [ ] ;
21299: LD_ADDR_EXP 80
21303: PUSH
21304: EMPTY
21305: ST_TO_ADDR
// mc_build_list := [ ] ;
21306: LD_ADDR_EXP 81
21310: PUSH
21311: EMPTY
21312: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21313: LD_ADDR_EXP 108
21317: PUSH
21318: EMPTY
21319: ST_TO_ADDR
// mc_builders := [ ] ;
21320: LD_ADDR_EXP 82
21324: PUSH
21325: EMPTY
21326: ST_TO_ADDR
// mc_construct_list := [ ] ;
21327: LD_ADDR_EXP 83
21331: PUSH
21332: EMPTY
21333: ST_TO_ADDR
// mc_turret_list := [ ] ;
21334: LD_ADDR_EXP 84
21338: PUSH
21339: EMPTY
21340: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21341: LD_ADDR_EXP 85
21345: PUSH
21346: EMPTY
21347: ST_TO_ADDR
// mc_miners := [ ] ;
21348: LD_ADDR_EXP 90
21352: PUSH
21353: EMPTY
21354: ST_TO_ADDR
// mc_mines := [ ] ;
21355: LD_ADDR_EXP 89
21359: PUSH
21360: EMPTY
21361: ST_TO_ADDR
// mc_minefields := [ ] ;
21362: LD_ADDR_EXP 91
21366: PUSH
21367: EMPTY
21368: ST_TO_ADDR
// mc_crates := [ ] ;
21369: LD_ADDR_EXP 92
21373: PUSH
21374: EMPTY
21375: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21376: LD_ADDR_EXP 93
21380: PUSH
21381: EMPTY
21382: ST_TO_ADDR
// mc_crates_area := [ ] ;
21383: LD_ADDR_EXP 94
21387: PUSH
21388: EMPTY
21389: ST_TO_ADDR
// mc_vehicles := [ ] ;
21390: LD_ADDR_EXP 95
21394: PUSH
21395: EMPTY
21396: ST_TO_ADDR
// mc_attack := [ ] ;
21397: LD_ADDR_EXP 96
21401: PUSH
21402: EMPTY
21403: ST_TO_ADDR
// mc_produce := [ ] ;
21404: LD_ADDR_EXP 97
21408: PUSH
21409: EMPTY
21410: ST_TO_ADDR
// mc_defender := [ ] ;
21411: LD_ADDR_EXP 98
21415: PUSH
21416: EMPTY
21417: ST_TO_ADDR
// mc_parking := [ ] ;
21418: LD_ADDR_EXP 100
21422: PUSH
21423: EMPTY
21424: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21425: LD_ADDR_EXP 86
21429: PUSH
21430: EMPTY
21431: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21432: LD_ADDR_EXP 88
21436: PUSH
21437: EMPTY
21438: ST_TO_ADDR
// mc_scan := [ ] ;
21439: LD_ADDR_EXP 99
21443: PUSH
21444: EMPTY
21445: ST_TO_ADDR
// mc_scan_area := [ ] ;
21446: LD_ADDR_EXP 101
21450: PUSH
21451: EMPTY
21452: ST_TO_ADDR
// mc_tech := [ ] ;
21453: LD_ADDR_EXP 103
21457: PUSH
21458: EMPTY
21459: ST_TO_ADDR
// mc_class := [ ] ;
21460: LD_ADDR_EXP 117
21464: PUSH
21465: EMPTY
21466: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21467: LD_ADDR_EXP 118
21471: PUSH
21472: EMPTY
21473: ST_TO_ADDR
// mc_is_defending := [ ] ;
21474: LD_ADDR_EXP 119
21478: PUSH
21479: EMPTY
21480: ST_TO_ADDR
// end ;
21481: LD_VAR 0 1
21485: RET
// export function MC_Kill ( base ) ; begin
21486: LD_INT 0
21488: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21489: LD_ADDR_EXP 76
21493: PUSH
21494: LD_EXP 76
21498: PPUSH
21499: LD_VAR 0 1
21503: PPUSH
21504: EMPTY
21505: PPUSH
21506: CALL_OW 1
21510: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21511: LD_ADDR_EXP 77
21515: PUSH
21516: LD_EXP 77
21520: PPUSH
21521: LD_VAR 0 1
21525: PPUSH
21526: EMPTY
21527: PPUSH
21528: CALL_OW 1
21532: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21533: LD_ADDR_EXP 78
21537: PUSH
21538: LD_EXP 78
21542: PPUSH
21543: LD_VAR 0 1
21547: PPUSH
21548: EMPTY
21549: PPUSH
21550: CALL_OW 1
21554: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21555: LD_ADDR_EXP 79
21559: PUSH
21560: LD_EXP 79
21564: PPUSH
21565: LD_VAR 0 1
21569: PPUSH
21570: EMPTY
21571: PPUSH
21572: CALL_OW 1
21576: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21577: LD_ADDR_EXP 80
21581: PUSH
21582: LD_EXP 80
21586: PPUSH
21587: LD_VAR 0 1
21591: PPUSH
21592: EMPTY
21593: PPUSH
21594: CALL_OW 1
21598: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21599: LD_ADDR_EXP 81
21603: PUSH
21604: LD_EXP 81
21608: PPUSH
21609: LD_VAR 0 1
21613: PPUSH
21614: EMPTY
21615: PPUSH
21616: CALL_OW 1
21620: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21621: LD_ADDR_EXP 82
21625: PUSH
21626: LD_EXP 82
21630: PPUSH
21631: LD_VAR 0 1
21635: PPUSH
21636: EMPTY
21637: PPUSH
21638: CALL_OW 1
21642: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21643: LD_ADDR_EXP 83
21647: PUSH
21648: LD_EXP 83
21652: PPUSH
21653: LD_VAR 0 1
21657: PPUSH
21658: EMPTY
21659: PPUSH
21660: CALL_OW 1
21664: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21665: LD_ADDR_EXP 84
21669: PUSH
21670: LD_EXP 84
21674: PPUSH
21675: LD_VAR 0 1
21679: PPUSH
21680: EMPTY
21681: PPUSH
21682: CALL_OW 1
21686: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21687: LD_ADDR_EXP 85
21691: PUSH
21692: LD_EXP 85
21696: PPUSH
21697: LD_VAR 0 1
21701: PPUSH
21702: EMPTY
21703: PPUSH
21704: CALL_OW 1
21708: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21709: LD_ADDR_EXP 86
21713: PUSH
21714: LD_EXP 86
21718: PPUSH
21719: LD_VAR 0 1
21723: PPUSH
21724: EMPTY
21725: PPUSH
21726: CALL_OW 1
21730: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21731: LD_ADDR_EXP 87
21735: PUSH
21736: LD_EXP 87
21740: PPUSH
21741: LD_VAR 0 1
21745: PPUSH
21746: LD_INT 0
21748: PPUSH
21749: CALL_OW 1
21753: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21754: LD_ADDR_EXP 88
21758: PUSH
21759: LD_EXP 88
21763: PPUSH
21764: LD_VAR 0 1
21768: PPUSH
21769: EMPTY
21770: PPUSH
21771: CALL_OW 1
21775: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21776: LD_ADDR_EXP 89
21780: PUSH
21781: LD_EXP 89
21785: PPUSH
21786: LD_VAR 0 1
21790: PPUSH
21791: EMPTY
21792: PPUSH
21793: CALL_OW 1
21797: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21798: LD_ADDR_EXP 90
21802: PUSH
21803: LD_EXP 90
21807: PPUSH
21808: LD_VAR 0 1
21812: PPUSH
21813: EMPTY
21814: PPUSH
21815: CALL_OW 1
21819: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21820: LD_ADDR_EXP 91
21824: PUSH
21825: LD_EXP 91
21829: PPUSH
21830: LD_VAR 0 1
21834: PPUSH
21835: EMPTY
21836: PPUSH
21837: CALL_OW 1
21841: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21842: LD_ADDR_EXP 92
21846: PUSH
21847: LD_EXP 92
21851: PPUSH
21852: LD_VAR 0 1
21856: PPUSH
21857: EMPTY
21858: PPUSH
21859: CALL_OW 1
21863: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21864: LD_ADDR_EXP 93
21868: PUSH
21869: LD_EXP 93
21873: PPUSH
21874: LD_VAR 0 1
21878: PPUSH
21879: EMPTY
21880: PPUSH
21881: CALL_OW 1
21885: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21886: LD_ADDR_EXP 94
21890: PUSH
21891: LD_EXP 94
21895: PPUSH
21896: LD_VAR 0 1
21900: PPUSH
21901: EMPTY
21902: PPUSH
21903: CALL_OW 1
21907: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21908: LD_ADDR_EXP 95
21912: PUSH
21913: LD_EXP 95
21917: PPUSH
21918: LD_VAR 0 1
21922: PPUSH
21923: EMPTY
21924: PPUSH
21925: CALL_OW 1
21929: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21930: LD_ADDR_EXP 96
21934: PUSH
21935: LD_EXP 96
21939: PPUSH
21940: LD_VAR 0 1
21944: PPUSH
21945: EMPTY
21946: PPUSH
21947: CALL_OW 1
21951: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21952: LD_ADDR_EXP 97
21956: PUSH
21957: LD_EXP 97
21961: PPUSH
21962: LD_VAR 0 1
21966: PPUSH
21967: EMPTY
21968: PPUSH
21969: CALL_OW 1
21973: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21974: LD_ADDR_EXP 98
21978: PUSH
21979: LD_EXP 98
21983: PPUSH
21984: LD_VAR 0 1
21988: PPUSH
21989: EMPTY
21990: PPUSH
21991: CALL_OW 1
21995: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21996: LD_ADDR_EXP 99
22000: PUSH
22001: LD_EXP 99
22005: PPUSH
22006: LD_VAR 0 1
22010: PPUSH
22011: EMPTY
22012: PPUSH
22013: CALL_OW 1
22017: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22018: LD_ADDR_EXP 100
22022: PUSH
22023: LD_EXP 100
22027: PPUSH
22028: LD_VAR 0 1
22032: PPUSH
22033: EMPTY
22034: PPUSH
22035: CALL_OW 1
22039: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22040: LD_ADDR_EXP 101
22044: PUSH
22045: LD_EXP 101
22049: PPUSH
22050: LD_VAR 0 1
22054: PPUSH
22055: EMPTY
22056: PPUSH
22057: CALL_OW 1
22061: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22062: LD_ADDR_EXP 103
22066: PUSH
22067: LD_EXP 103
22071: PPUSH
22072: LD_VAR 0 1
22076: PPUSH
22077: EMPTY
22078: PPUSH
22079: CALL_OW 1
22083: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22084: LD_ADDR_EXP 105
22088: PUSH
22089: LD_EXP 105
22093: PPUSH
22094: LD_VAR 0 1
22098: PPUSH
22099: EMPTY
22100: PPUSH
22101: CALL_OW 1
22105: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22106: LD_ADDR_EXP 106
22110: PUSH
22111: LD_EXP 106
22115: PPUSH
22116: LD_VAR 0 1
22120: PPUSH
22121: EMPTY
22122: PPUSH
22123: CALL_OW 1
22127: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22128: LD_ADDR_EXP 107
22132: PUSH
22133: LD_EXP 107
22137: PPUSH
22138: LD_VAR 0 1
22142: PPUSH
22143: EMPTY
22144: PPUSH
22145: CALL_OW 1
22149: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22150: LD_ADDR_EXP 108
22154: PUSH
22155: LD_EXP 108
22159: PPUSH
22160: LD_VAR 0 1
22164: PPUSH
22165: EMPTY
22166: PPUSH
22167: CALL_OW 1
22171: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22172: LD_ADDR_EXP 109
22176: PUSH
22177: LD_EXP 109
22181: PPUSH
22182: LD_VAR 0 1
22186: PPUSH
22187: EMPTY
22188: PPUSH
22189: CALL_OW 1
22193: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22194: LD_ADDR_EXP 110
22198: PUSH
22199: LD_EXP 110
22203: PPUSH
22204: LD_VAR 0 1
22208: PPUSH
22209: EMPTY
22210: PPUSH
22211: CALL_OW 1
22215: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22216: LD_ADDR_EXP 111
22220: PUSH
22221: LD_EXP 111
22225: PPUSH
22226: LD_VAR 0 1
22230: PPUSH
22231: EMPTY
22232: PPUSH
22233: CALL_OW 1
22237: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22238: LD_ADDR_EXP 112
22242: PUSH
22243: LD_EXP 112
22247: PPUSH
22248: LD_VAR 0 1
22252: PPUSH
22253: EMPTY
22254: PPUSH
22255: CALL_OW 1
22259: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22260: LD_ADDR_EXP 113
22264: PUSH
22265: LD_EXP 113
22269: PPUSH
22270: LD_VAR 0 1
22274: PPUSH
22275: EMPTY
22276: PPUSH
22277: CALL_OW 1
22281: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22282: LD_ADDR_EXP 114
22286: PUSH
22287: LD_EXP 114
22291: PPUSH
22292: LD_VAR 0 1
22296: PPUSH
22297: EMPTY
22298: PPUSH
22299: CALL_OW 1
22303: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22304: LD_ADDR_EXP 115
22308: PUSH
22309: LD_EXP 115
22313: PPUSH
22314: LD_VAR 0 1
22318: PPUSH
22319: EMPTY
22320: PPUSH
22321: CALL_OW 1
22325: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22326: LD_ADDR_EXP 116
22330: PUSH
22331: LD_EXP 116
22335: PPUSH
22336: LD_VAR 0 1
22340: PPUSH
22341: EMPTY
22342: PPUSH
22343: CALL_OW 1
22347: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22348: LD_ADDR_EXP 117
22352: PUSH
22353: LD_EXP 117
22357: PPUSH
22358: LD_VAR 0 1
22362: PPUSH
22363: EMPTY
22364: PPUSH
22365: CALL_OW 1
22369: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22370: LD_ADDR_EXP 118
22374: PUSH
22375: LD_EXP 118
22379: PPUSH
22380: LD_VAR 0 1
22384: PPUSH
22385: LD_INT 0
22387: PPUSH
22388: CALL_OW 1
22392: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22393: LD_ADDR_EXP 119
22397: PUSH
22398: LD_EXP 119
22402: PPUSH
22403: LD_VAR 0 1
22407: PPUSH
22408: LD_INT 0
22410: PPUSH
22411: CALL_OW 1
22415: ST_TO_ADDR
// end ;
22416: LD_VAR 0 2
22420: RET
// export function MC_Add ( side , units ) ; var base ; begin
22421: LD_INT 0
22423: PPUSH
22424: PPUSH
// base := mc_bases + 1 ;
22425: LD_ADDR_VAR 0 4
22429: PUSH
22430: LD_EXP 76
22434: PUSH
22435: LD_INT 1
22437: PLUS
22438: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22439: LD_ADDR_EXP 102
22443: PUSH
22444: LD_EXP 102
22448: PPUSH
22449: LD_VAR 0 4
22453: PPUSH
22454: LD_VAR 0 1
22458: PPUSH
22459: CALL_OW 1
22463: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22464: LD_ADDR_EXP 76
22468: PUSH
22469: LD_EXP 76
22473: PPUSH
22474: LD_VAR 0 4
22478: PPUSH
22479: LD_VAR 0 2
22483: PPUSH
22484: CALL_OW 1
22488: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22489: LD_ADDR_EXP 77
22493: PUSH
22494: LD_EXP 77
22498: PPUSH
22499: LD_VAR 0 4
22503: PPUSH
22504: EMPTY
22505: PPUSH
22506: CALL_OW 1
22510: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22511: LD_ADDR_EXP 78
22515: PUSH
22516: LD_EXP 78
22520: PPUSH
22521: LD_VAR 0 4
22525: PPUSH
22526: EMPTY
22527: PPUSH
22528: CALL_OW 1
22532: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22533: LD_ADDR_EXP 79
22537: PUSH
22538: LD_EXP 79
22542: PPUSH
22543: LD_VAR 0 4
22547: PPUSH
22548: EMPTY
22549: PPUSH
22550: CALL_OW 1
22554: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22555: LD_ADDR_EXP 80
22559: PUSH
22560: LD_EXP 80
22564: PPUSH
22565: LD_VAR 0 4
22569: PPUSH
22570: EMPTY
22571: PPUSH
22572: CALL_OW 1
22576: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22577: LD_ADDR_EXP 81
22581: PUSH
22582: LD_EXP 81
22586: PPUSH
22587: LD_VAR 0 4
22591: PPUSH
22592: EMPTY
22593: PPUSH
22594: CALL_OW 1
22598: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22599: LD_ADDR_EXP 82
22603: PUSH
22604: LD_EXP 82
22608: PPUSH
22609: LD_VAR 0 4
22613: PPUSH
22614: EMPTY
22615: PPUSH
22616: CALL_OW 1
22620: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22621: LD_ADDR_EXP 83
22625: PUSH
22626: LD_EXP 83
22630: PPUSH
22631: LD_VAR 0 4
22635: PPUSH
22636: EMPTY
22637: PPUSH
22638: CALL_OW 1
22642: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22643: LD_ADDR_EXP 84
22647: PUSH
22648: LD_EXP 84
22652: PPUSH
22653: LD_VAR 0 4
22657: PPUSH
22658: EMPTY
22659: PPUSH
22660: CALL_OW 1
22664: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22665: LD_ADDR_EXP 85
22669: PUSH
22670: LD_EXP 85
22674: PPUSH
22675: LD_VAR 0 4
22679: PPUSH
22680: EMPTY
22681: PPUSH
22682: CALL_OW 1
22686: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22687: LD_ADDR_EXP 86
22691: PUSH
22692: LD_EXP 86
22696: PPUSH
22697: LD_VAR 0 4
22701: PPUSH
22702: EMPTY
22703: PPUSH
22704: CALL_OW 1
22708: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22709: LD_ADDR_EXP 87
22713: PUSH
22714: LD_EXP 87
22718: PPUSH
22719: LD_VAR 0 4
22723: PPUSH
22724: LD_INT 0
22726: PPUSH
22727: CALL_OW 1
22731: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22732: LD_ADDR_EXP 88
22736: PUSH
22737: LD_EXP 88
22741: PPUSH
22742: LD_VAR 0 4
22746: PPUSH
22747: EMPTY
22748: PPUSH
22749: CALL_OW 1
22753: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22754: LD_ADDR_EXP 89
22758: PUSH
22759: LD_EXP 89
22763: PPUSH
22764: LD_VAR 0 4
22768: PPUSH
22769: EMPTY
22770: PPUSH
22771: CALL_OW 1
22775: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22776: LD_ADDR_EXP 90
22780: PUSH
22781: LD_EXP 90
22785: PPUSH
22786: LD_VAR 0 4
22790: PPUSH
22791: EMPTY
22792: PPUSH
22793: CALL_OW 1
22797: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22798: LD_ADDR_EXP 91
22802: PUSH
22803: LD_EXP 91
22807: PPUSH
22808: LD_VAR 0 4
22812: PPUSH
22813: EMPTY
22814: PPUSH
22815: CALL_OW 1
22819: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22820: LD_ADDR_EXP 92
22824: PUSH
22825: LD_EXP 92
22829: PPUSH
22830: LD_VAR 0 4
22834: PPUSH
22835: EMPTY
22836: PPUSH
22837: CALL_OW 1
22841: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22842: LD_ADDR_EXP 93
22846: PUSH
22847: LD_EXP 93
22851: PPUSH
22852: LD_VAR 0 4
22856: PPUSH
22857: EMPTY
22858: PPUSH
22859: CALL_OW 1
22863: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22864: LD_ADDR_EXP 94
22868: PUSH
22869: LD_EXP 94
22873: PPUSH
22874: LD_VAR 0 4
22878: PPUSH
22879: EMPTY
22880: PPUSH
22881: CALL_OW 1
22885: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22886: LD_ADDR_EXP 95
22890: PUSH
22891: LD_EXP 95
22895: PPUSH
22896: LD_VAR 0 4
22900: PPUSH
22901: EMPTY
22902: PPUSH
22903: CALL_OW 1
22907: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22908: LD_ADDR_EXP 96
22912: PUSH
22913: LD_EXP 96
22917: PPUSH
22918: LD_VAR 0 4
22922: PPUSH
22923: EMPTY
22924: PPUSH
22925: CALL_OW 1
22929: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22930: LD_ADDR_EXP 97
22934: PUSH
22935: LD_EXP 97
22939: PPUSH
22940: LD_VAR 0 4
22944: PPUSH
22945: EMPTY
22946: PPUSH
22947: CALL_OW 1
22951: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22952: LD_ADDR_EXP 98
22956: PUSH
22957: LD_EXP 98
22961: PPUSH
22962: LD_VAR 0 4
22966: PPUSH
22967: EMPTY
22968: PPUSH
22969: CALL_OW 1
22973: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22974: LD_ADDR_EXP 99
22978: PUSH
22979: LD_EXP 99
22983: PPUSH
22984: LD_VAR 0 4
22988: PPUSH
22989: EMPTY
22990: PPUSH
22991: CALL_OW 1
22995: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22996: LD_ADDR_EXP 100
23000: PUSH
23001: LD_EXP 100
23005: PPUSH
23006: LD_VAR 0 4
23010: PPUSH
23011: EMPTY
23012: PPUSH
23013: CALL_OW 1
23017: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23018: LD_ADDR_EXP 101
23022: PUSH
23023: LD_EXP 101
23027: PPUSH
23028: LD_VAR 0 4
23032: PPUSH
23033: EMPTY
23034: PPUSH
23035: CALL_OW 1
23039: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23040: LD_ADDR_EXP 103
23044: PUSH
23045: LD_EXP 103
23049: PPUSH
23050: LD_VAR 0 4
23054: PPUSH
23055: EMPTY
23056: PPUSH
23057: CALL_OW 1
23061: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23062: LD_ADDR_EXP 105
23066: PUSH
23067: LD_EXP 105
23071: PPUSH
23072: LD_VAR 0 4
23076: PPUSH
23077: EMPTY
23078: PPUSH
23079: CALL_OW 1
23083: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23084: LD_ADDR_EXP 106
23088: PUSH
23089: LD_EXP 106
23093: PPUSH
23094: LD_VAR 0 4
23098: PPUSH
23099: EMPTY
23100: PPUSH
23101: CALL_OW 1
23105: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23106: LD_ADDR_EXP 107
23110: PUSH
23111: LD_EXP 107
23115: PPUSH
23116: LD_VAR 0 4
23120: PPUSH
23121: EMPTY
23122: PPUSH
23123: CALL_OW 1
23127: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23128: LD_ADDR_EXP 108
23132: PUSH
23133: LD_EXP 108
23137: PPUSH
23138: LD_VAR 0 4
23142: PPUSH
23143: EMPTY
23144: PPUSH
23145: CALL_OW 1
23149: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23150: LD_ADDR_EXP 109
23154: PUSH
23155: LD_EXP 109
23159: PPUSH
23160: LD_VAR 0 4
23164: PPUSH
23165: EMPTY
23166: PPUSH
23167: CALL_OW 1
23171: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23172: LD_ADDR_EXP 110
23176: PUSH
23177: LD_EXP 110
23181: PPUSH
23182: LD_VAR 0 4
23186: PPUSH
23187: EMPTY
23188: PPUSH
23189: CALL_OW 1
23193: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23194: LD_ADDR_EXP 111
23198: PUSH
23199: LD_EXP 111
23203: PPUSH
23204: LD_VAR 0 4
23208: PPUSH
23209: EMPTY
23210: PPUSH
23211: CALL_OW 1
23215: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23216: LD_ADDR_EXP 112
23220: PUSH
23221: LD_EXP 112
23225: PPUSH
23226: LD_VAR 0 4
23230: PPUSH
23231: EMPTY
23232: PPUSH
23233: CALL_OW 1
23237: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23238: LD_ADDR_EXP 113
23242: PUSH
23243: LD_EXP 113
23247: PPUSH
23248: LD_VAR 0 4
23252: PPUSH
23253: EMPTY
23254: PPUSH
23255: CALL_OW 1
23259: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23260: LD_ADDR_EXP 114
23264: PUSH
23265: LD_EXP 114
23269: PPUSH
23270: LD_VAR 0 4
23274: PPUSH
23275: EMPTY
23276: PPUSH
23277: CALL_OW 1
23281: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23282: LD_ADDR_EXP 115
23286: PUSH
23287: LD_EXP 115
23291: PPUSH
23292: LD_VAR 0 4
23296: PPUSH
23297: EMPTY
23298: PPUSH
23299: CALL_OW 1
23303: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23304: LD_ADDR_EXP 116
23308: PUSH
23309: LD_EXP 116
23313: PPUSH
23314: LD_VAR 0 4
23318: PPUSH
23319: EMPTY
23320: PPUSH
23321: CALL_OW 1
23325: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23326: LD_ADDR_EXP 117
23330: PUSH
23331: LD_EXP 117
23335: PPUSH
23336: LD_VAR 0 4
23340: PPUSH
23341: EMPTY
23342: PPUSH
23343: CALL_OW 1
23347: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23348: LD_ADDR_EXP 118
23352: PUSH
23353: LD_EXP 118
23357: PPUSH
23358: LD_VAR 0 4
23362: PPUSH
23363: LD_INT 0
23365: PPUSH
23366: CALL_OW 1
23370: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23371: LD_ADDR_EXP 119
23375: PUSH
23376: LD_EXP 119
23380: PPUSH
23381: LD_VAR 0 4
23385: PPUSH
23386: LD_INT 0
23388: PPUSH
23389: CALL_OW 1
23393: ST_TO_ADDR
// result := base ;
23394: LD_ADDR_VAR 0 3
23398: PUSH
23399: LD_VAR 0 4
23403: ST_TO_ADDR
// end ;
23404: LD_VAR 0 3
23408: RET
// export function MC_Start ( ) ; var i ; begin
23409: LD_INT 0
23411: PPUSH
23412: PPUSH
// for i = 1 to mc_bases do
23413: LD_ADDR_VAR 0 2
23417: PUSH
23418: DOUBLE
23419: LD_INT 1
23421: DEC
23422: ST_TO_ADDR
23423: LD_EXP 76
23427: PUSH
23428: FOR_TO
23429: IFFALSE 24529
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23431: LD_ADDR_EXP 76
23435: PUSH
23436: LD_EXP 76
23440: PPUSH
23441: LD_VAR 0 2
23445: PPUSH
23446: LD_EXP 76
23450: PUSH
23451: LD_VAR 0 2
23455: ARRAY
23456: PUSH
23457: LD_INT 0
23459: DIFF
23460: PPUSH
23461: CALL_OW 1
23465: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23466: LD_ADDR_EXP 77
23470: PUSH
23471: LD_EXP 77
23475: PPUSH
23476: LD_VAR 0 2
23480: PPUSH
23481: EMPTY
23482: PPUSH
23483: CALL_OW 1
23487: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23488: LD_ADDR_EXP 78
23492: PUSH
23493: LD_EXP 78
23497: PPUSH
23498: LD_VAR 0 2
23502: PPUSH
23503: EMPTY
23504: PPUSH
23505: CALL_OW 1
23509: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23510: LD_ADDR_EXP 79
23514: PUSH
23515: LD_EXP 79
23519: PPUSH
23520: LD_VAR 0 2
23524: PPUSH
23525: EMPTY
23526: PPUSH
23527: CALL_OW 1
23531: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23532: LD_ADDR_EXP 80
23536: PUSH
23537: LD_EXP 80
23541: PPUSH
23542: LD_VAR 0 2
23546: PPUSH
23547: EMPTY
23548: PUSH
23549: EMPTY
23550: PUSH
23551: EMPTY
23552: LIST
23553: LIST
23554: PPUSH
23555: CALL_OW 1
23559: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23560: LD_ADDR_EXP 81
23564: PUSH
23565: LD_EXP 81
23569: PPUSH
23570: LD_VAR 0 2
23574: PPUSH
23575: EMPTY
23576: PPUSH
23577: CALL_OW 1
23581: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23582: LD_ADDR_EXP 108
23586: PUSH
23587: LD_EXP 108
23591: PPUSH
23592: LD_VAR 0 2
23596: PPUSH
23597: EMPTY
23598: PPUSH
23599: CALL_OW 1
23603: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23604: LD_ADDR_EXP 82
23608: PUSH
23609: LD_EXP 82
23613: PPUSH
23614: LD_VAR 0 2
23618: PPUSH
23619: EMPTY
23620: PPUSH
23621: CALL_OW 1
23625: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23626: LD_ADDR_EXP 83
23630: PUSH
23631: LD_EXP 83
23635: PPUSH
23636: LD_VAR 0 2
23640: PPUSH
23641: EMPTY
23642: PPUSH
23643: CALL_OW 1
23647: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23648: LD_ADDR_EXP 84
23652: PUSH
23653: LD_EXP 84
23657: PPUSH
23658: LD_VAR 0 2
23662: PPUSH
23663: LD_EXP 76
23667: PUSH
23668: LD_VAR 0 2
23672: ARRAY
23673: PPUSH
23674: LD_INT 2
23676: PUSH
23677: LD_INT 30
23679: PUSH
23680: LD_INT 32
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: PUSH
23687: LD_INT 30
23689: PUSH
23690: LD_INT 33
23692: PUSH
23693: EMPTY
23694: LIST
23695: LIST
23696: PUSH
23697: EMPTY
23698: LIST
23699: LIST
23700: LIST
23701: PPUSH
23702: CALL_OW 72
23706: PPUSH
23707: CALL_OW 1
23711: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23712: LD_ADDR_EXP 85
23716: PUSH
23717: LD_EXP 85
23721: PPUSH
23722: LD_VAR 0 2
23726: PPUSH
23727: LD_EXP 76
23731: PUSH
23732: LD_VAR 0 2
23736: ARRAY
23737: PPUSH
23738: LD_INT 2
23740: PUSH
23741: LD_INT 30
23743: PUSH
23744: LD_INT 32
23746: PUSH
23747: EMPTY
23748: LIST
23749: LIST
23750: PUSH
23751: LD_INT 30
23753: PUSH
23754: LD_INT 31
23756: PUSH
23757: EMPTY
23758: LIST
23759: LIST
23760: PUSH
23761: EMPTY
23762: LIST
23763: LIST
23764: LIST
23765: PUSH
23766: LD_INT 58
23768: PUSH
23769: EMPTY
23770: LIST
23771: PUSH
23772: EMPTY
23773: LIST
23774: LIST
23775: PPUSH
23776: CALL_OW 72
23780: PPUSH
23781: CALL_OW 1
23785: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23786: LD_ADDR_EXP 86
23790: PUSH
23791: LD_EXP 86
23795: PPUSH
23796: LD_VAR 0 2
23800: PPUSH
23801: EMPTY
23802: PPUSH
23803: CALL_OW 1
23807: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23808: LD_ADDR_EXP 90
23812: PUSH
23813: LD_EXP 90
23817: PPUSH
23818: LD_VAR 0 2
23822: PPUSH
23823: EMPTY
23824: PPUSH
23825: CALL_OW 1
23829: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23830: LD_ADDR_EXP 89
23834: PUSH
23835: LD_EXP 89
23839: PPUSH
23840: LD_VAR 0 2
23844: PPUSH
23845: EMPTY
23846: PPUSH
23847: CALL_OW 1
23851: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23852: LD_ADDR_EXP 91
23856: PUSH
23857: LD_EXP 91
23861: PPUSH
23862: LD_VAR 0 2
23866: PPUSH
23867: EMPTY
23868: PPUSH
23869: CALL_OW 1
23873: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23874: LD_ADDR_EXP 92
23878: PUSH
23879: LD_EXP 92
23883: PPUSH
23884: LD_VAR 0 2
23888: PPUSH
23889: EMPTY
23890: PPUSH
23891: CALL_OW 1
23895: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23896: LD_ADDR_EXP 93
23900: PUSH
23901: LD_EXP 93
23905: PPUSH
23906: LD_VAR 0 2
23910: PPUSH
23911: EMPTY
23912: PPUSH
23913: CALL_OW 1
23917: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23918: LD_ADDR_EXP 94
23922: PUSH
23923: LD_EXP 94
23927: PPUSH
23928: LD_VAR 0 2
23932: PPUSH
23933: EMPTY
23934: PPUSH
23935: CALL_OW 1
23939: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23940: LD_ADDR_EXP 95
23944: PUSH
23945: LD_EXP 95
23949: PPUSH
23950: LD_VAR 0 2
23954: PPUSH
23955: EMPTY
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23962: LD_ADDR_EXP 96
23966: PUSH
23967: LD_EXP 96
23971: PPUSH
23972: LD_VAR 0 2
23976: PPUSH
23977: EMPTY
23978: PPUSH
23979: CALL_OW 1
23983: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23984: LD_ADDR_EXP 97
23988: PUSH
23989: LD_EXP 97
23993: PPUSH
23994: LD_VAR 0 2
23998: PPUSH
23999: EMPTY
24000: PPUSH
24001: CALL_OW 1
24005: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24006: LD_ADDR_EXP 98
24010: PUSH
24011: LD_EXP 98
24015: PPUSH
24016: LD_VAR 0 2
24020: PPUSH
24021: EMPTY
24022: PPUSH
24023: CALL_OW 1
24027: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24028: LD_ADDR_EXP 87
24032: PUSH
24033: LD_EXP 87
24037: PPUSH
24038: LD_VAR 0 2
24042: PPUSH
24043: LD_INT 0
24045: PPUSH
24046: CALL_OW 1
24050: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24051: LD_ADDR_EXP 100
24055: PUSH
24056: LD_EXP 100
24060: PPUSH
24061: LD_VAR 0 2
24065: PPUSH
24066: LD_INT 0
24068: PPUSH
24069: CALL_OW 1
24073: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24074: LD_ADDR_EXP 88
24078: PUSH
24079: LD_EXP 88
24083: PPUSH
24084: LD_VAR 0 2
24088: PPUSH
24089: EMPTY
24090: PPUSH
24091: CALL_OW 1
24095: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24096: LD_ADDR_EXP 99
24100: PUSH
24101: LD_EXP 99
24105: PPUSH
24106: LD_VAR 0 2
24110: PPUSH
24111: LD_INT 0
24113: PPUSH
24114: CALL_OW 1
24118: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24119: LD_ADDR_EXP 101
24123: PUSH
24124: LD_EXP 101
24128: PPUSH
24129: LD_VAR 0 2
24133: PPUSH
24134: EMPTY
24135: PPUSH
24136: CALL_OW 1
24140: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24141: LD_ADDR_EXP 104
24145: PUSH
24146: LD_EXP 104
24150: PPUSH
24151: LD_VAR 0 2
24155: PPUSH
24156: LD_INT 0
24158: PPUSH
24159: CALL_OW 1
24163: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24164: LD_ADDR_EXP 105
24168: PUSH
24169: LD_EXP 105
24173: PPUSH
24174: LD_VAR 0 2
24178: PPUSH
24179: EMPTY
24180: PPUSH
24181: CALL_OW 1
24185: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24186: LD_ADDR_EXP 106
24190: PUSH
24191: LD_EXP 106
24195: PPUSH
24196: LD_VAR 0 2
24200: PPUSH
24201: EMPTY
24202: PPUSH
24203: CALL_OW 1
24207: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24208: LD_ADDR_EXP 107
24212: PUSH
24213: LD_EXP 107
24217: PPUSH
24218: LD_VAR 0 2
24222: PPUSH
24223: EMPTY
24224: PPUSH
24225: CALL_OW 1
24229: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24230: LD_ADDR_EXP 109
24234: PUSH
24235: LD_EXP 109
24239: PPUSH
24240: LD_VAR 0 2
24244: PPUSH
24245: LD_EXP 76
24249: PUSH
24250: LD_VAR 0 2
24254: ARRAY
24255: PPUSH
24256: LD_INT 2
24258: PUSH
24259: LD_INT 30
24261: PUSH
24262: LD_INT 6
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PUSH
24269: LD_INT 30
24271: PUSH
24272: LD_INT 7
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: PUSH
24279: LD_INT 30
24281: PUSH
24282: LD_INT 8
24284: PUSH
24285: EMPTY
24286: LIST
24287: LIST
24288: PUSH
24289: EMPTY
24290: LIST
24291: LIST
24292: LIST
24293: LIST
24294: PPUSH
24295: CALL_OW 72
24299: PPUSH
24300: CALL_OW 1
24304: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24305: LD_ADDR_EXP 110
24309: PUSH
24310: LD_EXP 110
24314: PPUSH
24315: LD_VAR 0 2
24319: PPUSH
24320: EMPTY
24321: PPUSH
24322: CALL_OW 1
24326: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24327: LD_ADDR_EXP 111
24331: PUSH
24332: LD_EXP 111
24336: PPUSH
24337: LD_VAR 0 2
24341: PPUSH
24342: EMPTY
24343: PPUSH
24344: CALL_OW 1
24348: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24349: LD_ADDR_EXP 112
24353: PUSH
24354: LD_EXP 112
24358: PPUSH
24359: LD_VAR 0 2
24363: PPUSH
24364: EMPTY
24365: PPUSH
24366: CALL_OW 1
24370: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24371: LD_ADDR_EXP 113
24375: PUSH
24376: LD_EXP 113
24380: PPUSH
24381: LD_VAR 0 2
24385: PPUSH
24386: EMPTY
24387: PPUSH
24388: CALL_OW 1
24392: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24393: LD_ADDR_EXP 114
24397: PUSH
24398: LD_EXP 114
24402: PPUSH
24403: LD_VAR 0 2
24407: PPUSH
24408: EMPTY
24409: PPUSH
24410: CALL_OW 1
24414: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24415: LD_ADDR_EXP 115
24419: PUSH
24420: LD_EXP 115
24424: PPUSH
24425: LD_VAR 0 2
24429: PPUSH
24430: EMPTY
24431: PPUSH
24432: CALL_OW 1
24436: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24437: LD_ADDR_EXP 116
24441: PUSH
24442: LD_EXP 116
24446: PPUSH
24447: LD_VAR 0 2
24451: PPUSH
24452: EMPTY
24453: PPUSH
24454: CALL_OW 1
24458: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24459: LD_ADDR_EXP 117
24463: PUSH
24464: LD_EXP 117
24468: PPUSH
24469: LD_VAR 0 2
24473: PPUSH
24474: EMPTY
24475: PPUSH
24476: CALL_OW 1
24480: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24481: LD_ADDR_EXP 118
24485: PUSH
24486: LD_EXP 118
24490: PPUSH
24491: LD_VAR 0 2
24495: PPUSH
24496: LD_INT 0
24498: PPUSH
24499: CALL_OW 1
24503: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24504: LD_ADDR_EXP 119
24508: PUSH
24509: LD_EXP 119
24513: PPUSH
24514: LD_VAR 0 2
24518: PPUSH
24519: LD_INT 0
24521: PPUSH
24522: CALL_OW 1
24526: ST_TO_ADDR
// end ;
24527: GO 23428
24529: POP
24530: POP
// MC_InitSides ( ) ;
24531: CALL 24817 0 0
// MC_InitResearch ( ) ;
24535: CALL 24556 0 0
// CustomInitMacro ( ) ;
24539: CALL 228 0 0
// skirmish := true ;
24543: LD_ADDR_EXP 74
24547: PUSH
24548: LD_INT 1
24550: ST_TO_ADDR
// end ;
24551: LD_VAR 0 1
24555: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24556: LD_INT 0
24558: PPUSH
24559: PPUSH
24560: PPUSH
24561: PPUSH
24562: PPUSH
24563: PPUSH
// if not mc_bases then
24564: LD_EXP 76
24568: NOT
24569: IFFALSE 24573
// exit ;
24571: GO 24812
// for i = 1 to 8 do
24573: LD_ADDR_VAR 0 2
24577: PUSH
24578: DOUBLE
24579: LD_INT 1
24581: DEC
24582: ST_TO_ADDR
24583: LD_INT 8
24585: PUSH
24586: FOR_TO
24587: IFFALSE 24613
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24589: LD_ADDR_EXP 103
24593: PUSH
24594: LD_EXP 103
24598: PPUSH
24599: LD_VAR 0 2
24603: PPUSH
24604: EMPTY
24605: PPUSH
24606: CALL_OW 1
24610: ST_TO_ADDR
24611: GO 24586
24613: POP
24614: POP
// tmp := [ ] ;
24615: LD_ADDR_VAR 0 5
24619: PUSH
24620: EMPTY
24621: ST_TO_ADDR
// for i = 1 to mc_sides do
24622: LD_ADDR_VAR 0 2
24626: PUSH
24627: DOUBLE
24628: LD_INT 1
24630: DEC
24631: ST_TO_ADDR
24632: LD_EXP 102
24636: PUSH
24637: FOR_TO
24638: IFFALSE 24696
// if not mc_sides [ i ] in tmp then
24640: LD_EXP 102
24644: PUSH
24645: LD_VAR 0 2
24649: ARRAY
24650: PUSH
24651: LD_VAR 0 5
24655: IN
24656: NOT
24657: IFFALSE 24694
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24659: LD_ADDR_VAR 0 5
24663: PUSH
24664: LD_VAR 0 5
24668: PPUSH
24669: LD_VAR 0 5
24673: PUSH
24674: LD_INT 1
24676: PLUS
24677: PPUSH
24678: LD_EXP 102
24682: PUSH
24683: LD_VAR 0 2
24687: ARRAY
24688: PPUSH
24689: CALL_OW 2
24693: ST_TO_ADDR
24694: GO 24637
24696: POP
24697: POP
// if not tmp then
24698: LD_VAR 0 5
24702: NOT
24703: IFFALSE 24707
// exit ;
24705: GO 24812
// for j in tmp do
24707: LD_ADDR_VAR 0 3
24711: PUSH
24712: LD_VAR 0 5
24716: PUSH
24717: FOR_IN
24718: IFFALSE 24810
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24720: LD_ADDR_VAR 0 6
24724: PUSH
24725: LD_INT 22
24727: PUSH
24728: LD_VAR 0 3
24732: PUSH
24733: EMPTY
24734: LIST
24735: LIST
24736: PPUSH
24737: CALL_OW 69
24741: ST_TO_ADDR
// if not un then
24742: LD_VAR 0 6
24746: NOT
24747: IFFALSE 24751
// continue ;
24749: GO 24717
// nation := GetNation ( un [ 1 ] ) ;
24751: LD_ADDR_VAR 0 4
24755: PUSH
24756: LD_VAR 0 6
24760: PUSH
24761: LD_INT 1
24763: ARRAY
24764: PPUSH
24765: CALL_OW 248
24769: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24770: LD_ADDR_EXP 103
24774: PUSH
24775: LD_EXP 103
24779: PPUSH
24780: LD_VAR 0 3
24784: PPUSH
24785: LD_VAR 0 3
24789: PPUSH
24790: LD_VAR 0 4
24794: PPUSH
24795: LD_INT 1
24797: PPUSH
24798: CALL 51911 0 3
24802: PPUSH
24803: CALL_OW 1
24807: ST_TO_ADDR
// end ;
24808: GO 24717
24810: POP
24811: POP
// end ;
24812: LD_VAR 0 1
24816: RET
// export function MC_InitSides ( ) ; var i ; begin
24817: LD_INT 0
24819: PPUSH
24820: PPUSH
// if not mc_bases then
24821: LD_EXP 76
24825: NOT
24826: IFFALSE 24830
// exit ;
24828: GO 24904
// for i = 1 to mc_bases do
24830: LD_ADDR_VAR 0 2
24834: PUSH
24835: DOUBLE
24836: LD_INT 1
24838: DEC
24839: ST_TO_ADDR
24840: LD_EXP 76
24844: PUSH
24845: FOR_TO
24846: IFFALSE 24902
// if mc_bases [ i ] then
24848: LD_EXP 76
24852: PUSH
24853: LD_VAR 0 2
24857: ARRAY
24858: IFFALSE 24900
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24860: LD_ADDR_EXP 102
24864: PUSH
24865: LD_EXP 102
24869: PPUSH
24870: LD_VAR 0 2
24874: PPUSH
24875: LD_EXP 76
24879: PUSH
24880: LD_VAR 0 2
24884: ARRAY
24885: PUSH
24886: LD_INT 1
24888: ARRAY
24889: PPUSH
24890: CALL_OW 255
24894: PPUSH
24895: CALL_OW 1
24899: ST_TO_ADDR
24900: GO 24845
24902: POP
24903: POP
// end ;
24904: LD_VAR 0 1
24908: RET
// every 0 0$03 trigger skirmish do
24909: LD_EXP 74
24913: IFFALSE 25067
24915: GO 24917
24917: DISABLE
// begin enable ;
24918: ENABLE
// MC_CheckBuildings ( ) ;
24919: CALL 29565 0 0
// MC_CheckPeopleLife ( ) ;
24923: CALL 29726 0 0
// RaiseSailEvent ( 100 ) ;
24927: LD_INT 100
24929: PPUSH
24930: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24934: LD_INT 103
24936: PPUSH
24937: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24941: LD_INT 104
24943: PPUSH
24944: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24948: LD_INT 105
24950: PPUSH
24951: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24955: LD_INT 106
24957: PPUSH
24958: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24962: LD_INT 107
24964: PPUSH
24965: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24969: LD_INT 108
24971: PPUSH
24972: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24976: LD_INT 109
24978: PPUSH
24979: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24983: LD_INT 110
24985: PPUSH
24986: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24990: LD_INT 111
24992: PPUSH
24993: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24997: LD_INT 112
24999: PPUSH
25000: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25004: LD_INT 113
25006: PPUSH
25007: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25011: LD_INT 120
25013: PPUSH
25014: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25018: LD_INT 121
25020: PPUSH
25021: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25025: LD_INT 122
25027: PPUSH
25028: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25032: LD_INT 123
25034: PPUSH
25035: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25039: LD_INT 124
25041: PPUSH
25042: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25046: LD_INT 125
25048: PPUSH
25049: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25053: LD_INT 126
25055: PPUSH
25056: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25060: LD_INT 200
25062: PPUSH
25063: CALL_OW 427
// end ;
25067: END
// on SailEvent ( event ) do begin if event < 100 then
25068: LD_VAR 0 1
25072: PUSH
25073: LD_INT 100
25075: LESS
25076: IFFALSE 25087
// CustomEvent ( event ) ;
25078: LD_VAR 0 1
25082: PPUSH
25083: CALL 10906 0 1
// if event = 100 then
25087: LD_VAR 0 1
25091: PUSH
25092: LD_INT 100
25094: EQUAL
25095: IFFALSE 25101
// MC_ClassManager ( ) ;
25097: CALL 25493 0 0
// if event = 101 then
25101: LD_VAR 0 1
25105: PUSH
25106: LD_INT 101
25108: EQUAL
25109: IFFALSE 25115
// MC_RepairBuildings ( ) ;
25111: CALL 30311 0 0
// if event = 102 then
25115: LD_VAR 0 1
25119: PUSH
25120: LD_INT 102
25122: EQUAL
25123: IFFALSE 25129
// MC_Heal ( ) ;
25125: CALL 31214 0 0
// if event = 103 then
25129: LD_VAR 0 1
25133: PUSH
25134: LD_INT 103
25136: EQUAL
25137: IFFALSE 25143
// MC_Build ( ) ;
25139: CALL 31636 0 0
// if event = 104 then
25143: LD_VAR 0 1
25147: PUSH
25148: LD_INT 104
25150: EQUAL
25151: IFFALSE 25157
// MC_TurretWeapon ( ) ;
25153: CALL 33277 0 0
// if event = 105 then
25157: LD_VAR 0 1
25161: PUSH
25162: LD_INT 105
25164: EQUAL
25165: IFFALSE 25171
// MC_BuildUpgrade ( ) ;
25167: CALL 32828 0 0
// if event = 106 then
25171: LD_VAR 0 1
25175: PUSH
25176: LD_INT 106
25178: EQUAL
25179: IFFALSE 25185
// MC_PlantMines ( ) ;
25181: CALL 33707 0 0
// if event = 107 then
25185: LD_VAR 0 1
25189: PUSH
25190: LD_INT 107
25192: EQUAL
25193: IFFALSE 25199
// MC_CollectCrates ( ) ;
25195: CALL 34498 0 0
// if event = 108 then
25199: LD_VAR 0 1
25203: PUSH
25204: LD_INT 108
25206: EQUAL
25207: IFFALSE 25213
// MC_LinkRemoteControl ( ) ;
25209: CALL 36348 0 0
// if event = 109 then
25213: LD_VAR 0 1
25217: PUSH
25218: LD_INT 109
25220: EQUAL
25221: IFFALSE 25227
// MC_ProduceVehicle ( ) ;
25223: CALL 36529 0 0
// if event = 110 then
25227: LD_VAR 0 1
25231: PUSH
25232: LD_INT 110
25234: EQUAL
25235: IFFALSE 25241
// MC_SendAttack ( ) ;
25237: CALL 36995 0 0
// if event = 111 then
25241: LD_VAR 0 1
25245: PUSH
25246: LD_INT 111
25248: EQUAL
25249: IFFALSE 25255
// MC_Defend ( ) ;
25251: CALL 37103 0 0
// if event = 112 then
25255: LD_VAR 0 1
25259: PUSH
25260: LD_INT 112
25262: EQUAL
25263: IFFALSE 25269
// MC_Research ( ) ;
25265: CALL 37983 0 0
// if event = 113 then
25269: LD_VAR 0 1
25273: PUSH
25274: LD_INT 113
25276: EQUAL
25277: IFFALSE 25283
// MC_MinesTrigger ( ) ;
25279: CALL 39097 0 0
// if event = 120 then
25283: LD_VAR 0 1
25287: PUSH
25288: LD_INT 120
25290: EQUAL
25291: IFFALSE 25297
// MC_RepairVehicle ( ) ;
25293: CALL 39196 0 0
// if event = 121 then
25297: LD_VAR 0 1
25301: PUSH
25302: LD_INT 121
25304: EQUAL
25305: IFFALSE 25311
// MC_TameApe ( ) ;
25307: CALL 39937 0 0
// if event = 122 then
25311: LD_VAR 0 1
25315: PUSH
25316: LD_INT 122
25318: EQUAL
25319: IFFALSE 25325
// MC_ChangeApeClass ( ) ;
25321: CALL 40766 0 0
// if event = 123 then
25325: LD_VAR 0 1
25329: PUSH
25330: LD_INT 123
25332: EQUAL
25333: IFFALSE 25339
// MC_Bazooka ( ) ;
25335: CALL 41416 0 0
// if event = 124 then
25339: LD_VAR 0 1
25343: PUSH
25344: LD_INT 124
25346: EQUAL
25347: IFFALSE 25353
// MC_TeleportExit ( ) ;
25349: CALL 41614 0 0
// if event = 125 then
25353: LD_VAR 0 1
25357: PUSH
25358: LD_INT 125
25360: EQUAL
25361: IFFALSE 25367
// MC_Deposits ( ) ;
25363: CALL 42261 0 0
// if event = 126 then
25367: LD_VAR 0 1
25371: PUSH
25372: LD_INT 126
25374: EQUAL
25375: IFFALSE 25381
// MC_RemoteDriver ( ) ;
25377: CALL 42886 0 0
// if event = 200 then
25381: LD_VAR 0 1
25385: PUSH
25386: LD_INT 200
25388: EQUAL
25389: IFFALSE 25395
// MC_Idle ( ) ;
25391: CALL 44835 0 0
// end ;
25395: PPOPN 1
25397: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25398: LD_INT 0
25400: PPUSH
25401: PPUSH
// if not mc_bases [ base ] or not tag then
25402: LD_EXP 76
25406: PUSH
25407: LD_VAR 0 1
25411: ARRAY
25412: NOT
25413: PUSH
25414: LD_VAR 0 2
25418: NOT
25419: OR
25420: IFFALSE 25424
// exit ;
25422: GO 25488
// for i in mc_bases [ base ] union mc_ape [ base ] do
25424: LD_ADDR_VAR 0 4
25428: PUSH
25429: LD_EXP 76
25433: PUSH
25434: LD_VAR 0 1
25438: ARRAY
25439: PUSH
25440: LD_EXP 105
25444: PUSH
25445: LD_VAR 0 1
25449: ARRAY
25450: UNION
25451: PUSH
25452: FOR_IN
25453: IFFALSE 25486
// if GetTag ( i ) = tag then
25455: LD_VAR 0 4
25459: PPUSH
25460: CALL_OW 110
25464: PUSH
25465: LD_VAR 0 2
25469: EQUAL
25470: IFFALSE 25484
// SetTag ( i , 0 ) ;
25472: LD_VAR 0 4
25476: PPUSH
25477: LD_INT 0
25479: PPUSH
25480: CALL_OW 109
25484: GO 25452
25486: POP
25487: POP
// end ;
25488: LD_VAR 0 3
25492: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25493: LD_INT 0
25495: PPUSH
25496: PPUSH
25497: PPUSH
25498: PPUSH
25499: PPUSH
25500: PPUSH
25501: PPUSH
25502: PPUSH
// if not mc_bases then
25503: LD_EXP 76
25507: NOT
25508: IFFALSE 25512
// exit ;
25510: GO 25970
// for i = 1 to mc_bases do
25512: LD_ADDR_VAR 0 2
25516: PUSH
25517: DOUBLE
25518: LD_INT 1
25520: DEC
25521: ST_TO_ADDR
25522: LD_EXP 76
25526: PUSH
25527: FOR_TO
25528: IFFALSE 25968
// begin tmp := MC_ClassCheckReq ( i ) ;
25530: LD_ADDR_VAR 0 4
25534: PUSH
25535: LD_VAR 0 2
25539: PPUSH
25540: CALL 25975 0 1
25544: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25545: LD_ADDR_EXP 117
25549: PUSH
25550: LD_EXP 117
25554: PPUSH
25555: LD_VAR 0 2
25559: PPUSH
25560: LD_VAR 0 4
25564: PPUSH
25565: CALL_OW 1
25569: ST_TO_ADDR
// if not tmp then
25570: LD_VAR 0 4
25574: NOT
25575: IFFALSE 25579
// continue ;
25577: GO 25527
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25579: LD_ADDR_VAR 0 6
25583: PUSH
25584: LD_EXP 76
25588: PUSH
25589: LD_VAR 0 2
25593: ARRAY
25594: PPUSH
25595: LD_INT 2
25597: PUSH
25598: LD_INT 30
25600: PUSH
25601: LD_INT 4
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 30
25610: PUSH
25611: LD_INT 5
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: LIST
25622: PPUSH
25623: CALL_OW 72
25627: PUSH
25628: LD_EXP 76
25632: PUSH
25633: LD_VAR 0 2
25637: ARRAY
25638: PPUSH
25639: LD_INT 2
25641: PUSH
25642: LD_INT 30
25644: PUSH
25645: LD_INT 0
25647: PUSH
25648: EMPTY
25649: LIST
25650: LIST
25651: PUSH
25652: LD_INT 30
25654: PUSH
25655: LD_INT 1
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: LIST
25666: PPUSH
25667: CALL_OW 72
25671: PUSH
25672: LD_EXP 76
25676: PUSH
25677: LD_VAR 0 2
25681: ARRAY
25682: PPUSH
25683: LD_INT 30
25685: PUSH
25686: LD_INT 3
25688: PUSH
25689: EMPTY
25690: LIST
25691: LIST
25692: PPUSH
25693: CALL_OW 72
25697: PUSH
25698: LD_EXP 76
25702: PUSH
25703: LD_VAR 0 2
25707: ARRAY
25708: PPUSH
25709: LD_INT 2
25711: PUSH
25712: LD_INT 30
25714: PUSH
25715: LD_INT 6
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PUSH
25722: LD_INT 30
25724: PUSH
25725: LD_INT 7
25727: PUSH
25728: EMPTY
25729: LIST
25730: LIST
25731: PUSH
25732: LD_INT 30
25734: PUSH
25735: LD_INT 8
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: EMPTY
25743: LIST
25744: LIST
25745: LIST
25746: LIST
25747: PPUSH
25748: CALL_OW 72
25752: PUSH
25753: EMPTY
25754: LIST
25755: LIST
25756: LIST
25757: LIST
25758: ST_TO_ADDR
// for j = 1 to 4 do
25759: LD_ADDR_VAR 0 3
25763: PUSH
25764: DOUBLE
25765: LD_INT 1
25767: DEC
25768: ST_TO_ADDR
25769: LD_INT 4
25771: PUSH
25772: FOR_TO
25773: IFFALSE 25964
// begin if not tmp [ j ] then
25775: LD_VAR 0 4
25779: PUSH
25780: LD_VAR 0 3
25784: ARRAY
25785: NOT
25786: IFFALSE 25790
// continue ;
25788: GO 25772
// for p in tmp [ j ] do
25790: LD_ADDR_VAR 0 5
25794: PUSH
25795: LD_VAR 0 4
25799: PUSH
25800: LD_VAR 0 3
25804: ARRAY
25805: PUSH
25806: FOR_IN
25807: IFFALSE 25960
// begin if not b [ j ] then
25809: LD_VAR 0 6
25813: PUSH
25814: LD_VAR 0 3
25818: ARRAY
25819: NOT
25820: IFFALSE 25824
// break ;
25822: GO 25960
// e := 0 ;
25824: LD_ADDR_VAR 0 7
25828: PUSH
25829: LD_INT 0
25831: ST_TO_ADDR
// for k in b [ j ] do
25832: LD_ADDR_VAR 0 8
25836: PUSH
25837: LD_VAR 0 6
25841: PUSH
25842: LD_VAR 0 3
25846: ARRAY
25847: PUSH
25848: FOR_IN
25849: IFFALSE 25876
// if IsNotFull ( k ) then
25851: LD_VAR 0 8
25855: PPUSH
25856: CALL 54064 0 1
25860: IFFALSE 25874
// begin e := k ;
25862: LD_ADDR_VAR 0 7
25866: PUSH
25867: LD_VAR 0 8
25871: ST_TO_ADDR
// break ;
25872: GO 25876
// end ;
25874: GO 25848
25876: POP
25877: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25878: LD_VAR 0 7
25882: PUSH
25883: LD_VAR 0 5
25887: PPUSH
25888: LD_VAR 0 7
25892: PPUSH
25893: CALL 87870 0 2
25897: NOT
25898: AND
25899: IFFALSE 25958
// begin if IsInUnit ( p ) then
25901: LD_VAR 0 5
25905: PPUSH
25906: CALL_OW 310
25910: IFFALSE 25921
// ComExitBuilding ( p ) ;
25912: LD_VAR 0 5
25916: PPUSH
25917: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25921: LD_VAR 0 5
25925: PPUSH
25926: LD_VAR 0 7
25930: PPUSH
25931: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25935: LD_VAR 0 5
25939: PPUSH
25940: LD_VAR 0 3
25944: PPUSH
25945: CALL_OW 183
// AddComExitBuilding ( p ) ;
25949: LD_VAR 0 5
25953: PPUSH
25954: CALL_OW 182
// end ; end ;
25958: GO 25806
25960: POP
25961: POP
// end ;
25962: GO 25772
25964: POP
25965: POP
// end ;
25966: GO 25527
25968: POP
25969: POP
// end ;
25970: LD_VAR 0 1
25974: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25975: LD_INT 0
25977: PPUSH
25978: PPUSH
25979: PPUSH
25980: PPUSH
25981: PPUSH
25982: PPUSH
25983: PPUSH
25984: PPUSH
25985: PPUSH
25986: PPUSH
25987: PPUSH
25988: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25989: LD_VAR 0 1
25993: NOT
25994: PUSH
25995: LD_EXP 76
25999: PUSH
26000: LD_VAR 0 1
26004: ARRAY
26005: NOT
26006: OR
26007: PUSH
26008: LD_EXP 76
26012: PUSH
26013: LD_VAR 0 1
26017: ARRAY
26018: PPUSH
26019: LD_INT 2
26021: PUSH
26022: LD_INT 30
26024: PUSH
26025: LD_INT 0
26027: PUSH
26028: EMPTY
26029: LIST
26030: LIST
26031: PUSH
26032: LD_INT 30
26034: PUSH
26035: LD_INT 1
26037: PUSH
26038: EMPTY
26039: LIST
26040: LIST
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: LIST
26046: PPUSH
26047: CALL_OW 72
26051: NOT
26052: OR
26053: IFFALSE 26057
// exit ;
26055: GO 29560
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26057: LD_ADDR_VAR 0 4
26061: PUSH
26062: LD_EXP 76
26066: PUSH
26067: LD_VAR 0 1
26071: ARRAY
26072: PPUSH
26073: LD_INT 2
26075: PUSH
26076: LD_INT 25
26078: PUSH
26079: LD_INT 1
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: PUSH
26086: LD_INT 25
26088: PUSH
26089: LD_INT 2
26091: PUSH
26092: EMPTY
26093: LIST
26094: LIST
26095: PUSH
26096: LD_INT 25
26098: PUSH
26099: LD_INT 3
26101: PUSH
26102: EMPTY
26103: LIST
26104: LIST
26105: PUSH
26106: LD_INT 25
26108: PUSH
26109: LD_INT 4
26111: PUSH
26112: EMPTY
26113: LIST
26114: LIST
26115: PUSH
26116: LD_INT 25
26118: PUSH
26119: LD_INT 5
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: PUSH
26126: LD_INT 25
26128: PUSH
26129: LD_INT 8
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: LD_INT 25
26138: PUSH
26139: LD_INT 9
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: LIST
26150: LIST
26151: LIST
26152: LIST
26153: LIST
26154: LIST
26155: PPUSH
26156: CALL_OW 72
26160: ST_TO_ADDR
// if not tmp then
26161: LD_VAR 0 4
26165: NOT
26166: IFFALSE 26170
// exit ;
26168: GO 29560
// for i in tmp do
26170: LD_ADDR_VAR 0 3
26174: PUSH
26175: LD_VAR 0 4
26179: PUSH
26180: FOR_IN
26181: IFFALSE 26212
// if GetTag ( i ) then
26183: LD_VAR 0 3
26187: PPUSH
26188: CALL_OW 110
26192: IFFALSE 26210
// tmp := tmp diff i ;
26194: LD_ADDR_VAR 0 4
26198: PUSH
26199: LD_VAR 0 4
26203: PUSH
26204: LD_VAR 0 3
26208: DIFF
26209: ST_TO_ADDR
26210: GO 26180
26212: POP
26213: POP
// if not tmp then
26214: LD_VAR 0 4
26218: NOT
26219: IFFALSE 26223
// exit ;
26221: GO 29560
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26223: LD_ADDR_VAR 0 5
26227: PUSH
26228: LD_EXP 76
26232: PUSH
26233: LD_VAR 0 1
26237: ARRAY
26238: PPUSH
26239: LD_INT 2
26241: PUSH
26242: LD_INT 25
26244: PUSH
26245: LD_INT 1
26247: PUSH
26248: EMPTY
26249: LIST
26250: LIST
26251: PUSH
26252: LD_INT 25
26254: PUSH
26255: LD_INT 5
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: LD_INT 25
26264: PUSH
26265: LD_INT 8
26267: PUSH
26268: EMPTY
26269: LIST
26270: LIST
26271: PUSH
26272: LD_INT 25
26274: PUSH
26275: LD_INT 9
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: LIST
26286: LIST
26287: LIST
26288: PPUSH
26289: CALL_OW 72
26293: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26294: LD_ADDR_VAR 0 6
26298: PUSH
26299: LD_EXP 76
26303: PUSH
26304: LD_VAR 0 1
26308: ARRAY
26309: PPUSH
26310: LD_INT 25
26312: PUSH
26313: LD_INT 2
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PPUSH
26320: CALL_OW 72
26324: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26325: LD_ADDR_VAR 0 7
26329: PUSH
26330: LD_EXP 76
26334: PUSH
26335: LD_VAR 0 1
26339: ARRAY
26340: PPUSH
26341: LD_INT 25
26343: PUSH
26344: LD_INT 3
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: PPUSH
26351: CALL_OW 72
26355: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26356: LD_ADDR_VAR 0 8
26360: PUSH
26361: LD_EXP 76
26365: PUSH
26366: LD_VAR 0 1
26370: ARRAY
26371: PPUSH
26372: LD_INT 25
26374: PUSH
26375: LD_INT 4
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: PUSH
26382: LD_INT 24
26384: PUSH
26385: LD_INT 251
26387: PUSH
26388: EMPTY
26389: LIST
26390: LIST
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PPUSH
26396: CALL_OW 72
26400: ST_TO_ADDR
// if mc_is_defending [ base ] then
26401: LD_EXP 119
26405: PUSH
26406: LD_VAR 0 1
26410: ARRAY
26411: IFFALSE 26872
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26413: LD_ADDR_EXP 118
26417: PUSH
26418: LD_EXP 118
26422: PPUSH
26423: LD_VAR 0 1
26427: PPUSH
26428: LD_INT 4
26430: PPUSH
26431: CALL_OW 1
26435: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26436: LD_ADDR_VAR 0 12
26440: PUSH
26441: LD_EXP 76
26445: PUSH
26446: LD_VAR 0 1
26450: ARRAY
26451: PPUSH
26452: LD_INT 2
26454: PUSH
26455: LD_INT 30
26457: PUSH
26458: LD_INT 4
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PUSH
26465: LD_INT 30
26467: PUSH
26468: LD_INT 5
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: LIST
26479: PPUSH
26480: CALL_OW 72
26484: ST_TO_ADDR
// if not b then
26485: LD_VAR 0 12
26489: NOT
26490: IFFALSE 26494
// exit ;
26492: GO 29560
// p := [ ] ;
26494: LD_ADDR_VAR 0 11
26498: PUSH
26499: EMPTY
26500: ST_TO_ADDR
// if sci >= 2 then
26501: LD_VAR 0 8
26505: PUSH
26506: LD_INT 2
26508: GREATEREQUAL
26509: IFFALSE 26540
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26511: LD_ADDR_VAR 0 8
26515: PUSH
26516: LD_VAR 0 8
26520: PUSH
26521: LD_INT 1
26523: ARRAY
26524: PUSH
26525: LD_VAR 0 8
26529: PUSH
26530: LD_INT 2
26532: ARRAY
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: ST_TO_ADDR
26538: GO 26601
// if sci = 1 then
26540: LD_VAR 0 8
26544: PUSH
26545: LD_INT 1
26547: EQUAL
26548: IFFALSE 26569
// sci := [ sci [ 1 ] ] else
26550: LD_ADDR_VAR 0 8
26554: PUSH
26555: LD_VAR 0 8
26559: PUSH
26560: LD_INT 1
26562: ARRAY
26563: PUSH
26564: EMPTY
26565: LIST
26566: ST_TO_ADDR
26567: GO 26601
// if sci = 0 then
26569: LD_VAR 0 8
26573: PUSH
26574: LD_INT 0
26576: EQUAL
26577: IFFALSE 26601
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26579: LD_ADDR_VAR 0 11
26583: PUSH
26584: LD_VAR 0 4
26588: PPUSH
26589: LD_INT 4
26591: PPUSH
26592: CALL 87733 0 2
26596: PUSH
26597: LD_INT 1
26599: ARRAY
26600: ST_TO_ADDR
// if eng > 4 then
26601: LD_VAR 0 6
26605: PUSH
26606: LD_INT 4
26608: GREATER
26609: IFFALSE 26655
// for i = eng downto 4 do
26611: LD_ADDR_VAR 0 3
26615: PUSH
26616: DOUBLE
26617: LD_VAR 0 6
26621: INC
26622: ST_TO_ADDR
26623: LD_INT 4
26625: PUSH
26626: FOR_DOWNTO
26627: IFFALSE 26653
// eng := eng diff eng [ i ] ;
26629: LD_ADDR_VAR 0 6
26633: PUSH
26634: LD_VAR 0 6
26638: PUSH
26639: LD_VAR 0 6
26643: PUSH
26644: LD_VAR 0 3
26648: ARRAY
26649: DIFF
26650: ST_TO_ADDR
26651: GO 26626
26653: POP
26654: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26655: LD_ADDR_VAR 0 4
26659: PUSH
26660: LD_VAR 0 4
26664: PUSH
26665: LD_VAR 0 5
26669: PUSH
26670: LD_VAR 0 6
26674: UNION
26675: PUSH
26676: LD_VAR 0 7
26680: UNION
26681: PUSH
26682: LD_VAR 0 8
26686: UNION
26687: DIFF
26688: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26689: LD_ADDR_VAR 0 13
26693: PUSH
26694: LD_EXP 76
26698: PUSH
26699: LD_VAR 0 1
26703: ARRAY
26704: PPUSH
26705: LD_INT 2
26707: PUSH
26708: LD_INT 30
26710: PUSH
26711: LD_INT 32
26713: PUSH
26714: EMPTY
26715: LIST
26716: LIST
26717: PUSH
26718: LD_INT 30
26720: PUSH
26721: LD_INT 31
26723: PUSH
26724: EMPTY
26725: LIST
26726: LIST
26727: PUSH
26728: EMPTY
26729: LIST
26730: LIST
26731: LIST
26732: PPUSH
26733: CALL_OW 72
26737: PUSH
26738: LD_EXP 76
26742: PUSH
26743: LD_VAR 0 1
26747: ARRAY
26748: PPUSH
26749: LD_INT 2
26751: PUSH
26752: LD_INT 30
26754: PUSH
26755: LD_INT 4
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 30
26764: PUSH
26765: LD_INT 5
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: LIST
26776: PPUSH
26777: CALL_OW 72
26781: PUSH
26782: LD_INT 6
26784: MUL
26785: PLUS
26786: ST_TO_ADDR
// if bcount < tmp then
26787: LD_VAR 0 13
26791: PUSH
26792: LD_VAR 0 4
26796: LESS
26797: IFFALSE 26843
// for i = tmp downto bcount do
26799: LD_ADDR_VAR 0 3
26803: PUSH
26804: DOUBLE
26805: LD_VAR 0 4
26809: INC
26810: ST_TO_ADDR
26811: LD_VAR 0 13
26815: PUSH
26816: FOR_DOWNTO
26817: IFFALSE 26841
// tmp := Delete ( tmp , tmp ) ;
26819: LD_ADDR_VAR 0 4
26823: PUSH
26824: LD_VAR 0 4
26828: PPUSH
26829: LD_VAR 0 4
26833: PPUSH
26834: CALL_OW 3
26838: ST_TO_ADDR
26839: GO 26816
26841: POP
26842: POP
// result := [ tmp , 0 , 0 , p ] ;
26843: LD_ADDR_VAR 0 2
26847: PUSH
26848: LD_VAR 0 4
26852: PUSH
26853: LD_INT 0
26855: PUSH
26856: LD_INT 0
26858: PUSH
26859: LD_VAR 0 11
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: LIST
26868: LIST
26869: ST_TO_ADDR
// exit ;
26870: GO 29560
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26872: LD_EXP 76
26876: PUSH
26877: LD_VAR 0 1
26881: ARRAY
26882: PPUSH
26883: LD_INT 2
26885: PUSH
26886: LD_INT 30
26888: PUSH
26889: LD_INT 6
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: PUSH
26896: LD_INT 30
26898: PUSH
26899: LD_INT 7
26901: PUSH
26902: EMPTY
26903: LIST
26904: LIST
26905: PUSH
26906: LD_INT 30
26908: PUSH
26909: LD_INT 8
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: LIST
26920: LIST
26921: PPUSH
26922: CALL_OW 72
26926: NOT
26927: PUSH
26928: LD_EXP 76
26932: PUSH
26933: LD_VAR 0 1
26937: ARRAY
26938: PPUSH
26939: LD_INT 30
26941: PUSH
26942: LD_INT 3
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PPUSH
26949: CALL_OW 72
26953: NOT
26954: AND
26955: IFFALSE 27027
// begin if eng = tmp then
26957: LD_VAR 0 6
26961: PUSH
26962: LD_VAR 0 4
26966: EQUAL
26967: IFFALSE 26971
// exit ;
26969: GO 29560
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26971: LD_ADDR_EXP 118
26975: PUSH
26976: LD_EXP 118
26980: PPUSH
26981: LD_VAR 0 1
26985: PPUSH
26986: LD_INT 1
26988: PPUSH
26989: CALL_OW 1
26993: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26994: LD_ADDR_VAR 0 2
26998: PUSH
26999: LD_INT 0
27001: PUSH
27002: LD_VAR 0 4
27006: PUSH
27007: LD_VAR 0 6
27011: DIFF
27012: PUSH
27013: LD_INT 0
27015: PUSH
27016: LD_INT 0
27018: PUSH
27019: EMPTY
27020: LIST
27021: LIST
27022: LIST
27023: LIST
27024: ST_TO_ADDR
// exit ;
27025: GO 29560
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27027: LD_EXP 103
27031: PUSH
27032: LD_EXP 102
27036: PUSH
27037: LD_VAR 0 1
27041: ARRAY
27042: ARRAY
27043: PUSH
27044: LD_EXP 76
27048: PUSH
27049: LD_VAR 0 1
27053: ARRAY
27054: PPUSH
27055: LD_INT 2
27057: PUSH
27058: LD_INT 30
27060: PUSH
27061: LD_INT 6
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: PUSH
27068: LD_INT 30
27070: PUSH
27071: LD_INT 7
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: PUSH
27078: LD_INT 30
27080: PUSH
27081: LD_INT 8
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: PPUSH
27094: CALL_OW 72
27098: AND
27099: PUSH
27100: LD_EXP 76
27104: PUSH
27105: LD_VAR 0 1
27109: ARRAY
27110: PPUSH
27111: LD_INT 30
27113: PUSH
27114: LD_INT 3
27116: PUSH
27117: EMPTY
27118: LIST
27119: LIST
27120: PPUSH
27121: CALL_OW 72
27125: NOT
27126: AND
27127: IFFALSE 27341
// begin if sci >= 6 then
27129: LD_VAR 0 8
27133: PUSH
27134: LD_INT 6
27136: GREATEREQUAL
27137: IFFALSE 27141
// exit ;
27139: GO 29560
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27141: LD_ADDR_EXP 118
27145: PUSH
27146: LD_EXP 118
27150: PPUSH
27151: LD_VAR 0 1
27155: PPUSH
27156: LD_INT 2
27158: PPUSH
27159: CALL_OW 1
27163: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27164: LD_ADDR_VAR 0 9
27168: PUSH
27169: LD_VAR 0 4
27173: PUSH
27174: LD_VAR 0 8
27178: DIFF
27179: PPUSH
27180: LD_INT 4
27182: PPUSH
27183: CALL 87733 0 2
27187: ST_TO_ADDR
// p := [ ] ;
27188: LD_ADDR_VAR 0 11
27192: PUSH
27193: EMPTY
27194: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27195: LD_VAR 0 8
27199: PUSH
27200: LD_INT 6
27202: LESS
27203: PUSH
27204: LD_VAR 0 9
27208: PUSH
27209: LD_INT 6
27211: GREATER
27212: AND
27213: IFFALSE 27294
// begin for i = 1 to 6 - sci do
27215: LD_ADDR_VAR 0 3
27219: PUSH
27220: DOUBLE
27221: LD_INT 1
27223: DEC
27224: ST_TO_ADDR
27225: LD_INT 6
27227: PUSH
27228: LD_VAR 0 8
27232: MINUS
27233: PUSH
27234: FOR_TO
27235: IFFALSE 27290
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27237: LD_ADDR_VAR 0 11
27241: PUSH
27242: LD_VAR 0 11
27246: PPUSH
27247: LD_VAR 0 11
27251: PUSH
27252: LD_INT 1
27254: PLUS
27255: PPUSH
27256: LD_VAR 0 9
27260: PUSH
27261: LD_INT 1
27263: ARRAY
27264: PPUSH
27265: CALL_OW 2
27269: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27270: LD_ADDR_VAR 0 9
27274: PUSH
27275: LD_VAR 0 9
27279: PPUSH
27280: LD_INT 1
27282: PPUSH
27283: CALL_OW 3
27287: ST_TO_ADDR
// end ;
27288: GO 27234
27290: POP
27291: POP
// end else
27292: GO 27314
// if sort then
27294: LD_VAR 0 9
27298: IFFALSE 27314
// p := sort [ 1 ] ;
27300: LD_ADDR_VAR 0 11
27304: PUSH
27305: LD_VAR 0 9
27309: PUSH
27310: LD_INT 1
27312: ARRAY
27313: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27314: LD_ADDR_VAR 0 2
27318: PUSH
27319: LD_INT 0
27321: PUSH
27322: LD_INT 0
27324: PUSH
27325: LD_INT 0
27327: PUSH
27328: LD_VAR 0 11
27332: PUSH
27333: EMPTY
27334: LIST
27335: LIST
27336: LIST
27337: LIST
27338: ST_TO_ADDR
// exit ;
27339: GO 29560
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27341: LD_EXP 103
27345: PUSH
27346: LD_EXP 102
27350: PUSH
27351: LD_VAR 0 1
27355: ARRAY
27356: ARRAY
27357: PUSH
27358: LD_EXP 76
27362: PUSH
27363: LD_VAR 0 1
27367: ARRAY
27368: PPUSH
27369: LD_INT 2
27371: PUSH
27372: LD_INT 30
27374: PUSH
27375: LD_INT 6
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: LD_INT 30
27384: PUSH
27385: LD_INT 7
27387: PUSH
27388: EMPTY
27389: LIST
27390: LIST
27391: PUSH
27392: LD_INT 30
27394: PUSH
27395: LD_INT 8
27397: PUSH
27398: EMPTY
27399: LIST
27400: LIST
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: LIST
27406: LIST
27407: PPUSH
27408: CALL_OW 72
27412: AND
27413: PUSH
27414: LD_EXP 76
27418: PUSH
27419: LD_VAR 0 1
27423: ARRAY
27424: PPUSH
27425: LD_INT 30
27427: PUSH
27428: LD_INT 3
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: PPUSH
27435: CALL_OW 72
27439: AND
27440: IFFALSE 28174
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27442: LD_ADDR_EXP 118
27446: PUSH
27447: LD_EXP 118
27451: PPUSH
27452: LD_VAR 0 1
27456: PPUSH
27457: LD_INT 3
27459: PPUSH
27460: CALL_OW 1
27464: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27465: LD_ADDR_VAR 0 2
27469: PUSH
27470: LD_INT 0
27472: PUSH
27473: LD_INT 0
27475: PUSH
27476: LD_INT 0
27478: PUSH
27479: LD_INT 0
27481: PUSH
27482: EMPTY
27483: LIST
27484: LIST
27485: LIST
27486: LIST
27487: ST_TO_ADDR
// if not eng then
27488: LD_VAR 0 6
27492: NOT
27493: IFFALSE 27556
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27495: LD_ADDR_VAR 0 11
27499: PUSH
27500: LD_VAR 0 4
27504: PPUSH
27505: LD_INT 2
27507: PPUSH
27508: CALL 87733 0 2
27512: PUSH
27513: LD_INT 1
27515: ARRAY
27516: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27517: LD_ADDR_VAR 0 2
27521: PUSH
27522: LD_VAR 0 2
27526: PPUSH
27527: LD_INT 2
27529: PPUSH
27530: LD_VAR 0 11
27534: PPUSH
27535: CALL_OW 1
27539: ST_TO_ADDR
// tmp := tmp diff p ;
27540: LD_ADDR_VAR 0 4
27544: PUSH
27545: LD_VAR 0 4
27549: PUSH
27550: LD_VAR 0 11
27554: DIFF
27555: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27556: LD_VAR 0 4
27560: PUSH
27561: LD_VAR 0 8
27565: PUSH
27566: LD_INT 6
27568: LESS
27569: AND
27570: IFFALSE 27758
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27572: LD_ADDR_VAR 0 9
27576: PUSH
27577: LD_VAR 0 4
27581: PUSH
27582: LD_VAR 0 8
27586: PUSH
27587: LD_VAR 0 7
27591: UNION
27592: DIFF
27593: PPUSH
27594: LD_INT 4
27596: PPUSH
27597: CALL 87733 0 2
27601: ST_TO_ADDR
// p := [ ] ;
27602: LD_ADDR_VAR 0 11
27606: PUSH
27607: EMPTY
27608: ST_TO_ADDR
// if sort then
27609: LD_VAR 0 9
27613: IFFALSE 27729
// for i = 1 to 6 - sci do
27615: LD_ADDR_VAR 0 3
27619: PUSH
27620: DOUBLE
27621: LD_INT 1
27623: DEC
27624: ST_TO_ADDR
27625: LD_INT 6
27627: PUSH
27628: LD_VAR 0 8
27632: MINUS
27633: PUSH
27634: FOR_TO
27635: IFFALSE 27727
// begin if i = sort then
27637: LD_VAR 0 3
27641: PUSH
27642: LD_VAR 0 9
27646: EQUAL
27647: IFFALSE 27651
// break ;
27649: GO 27727
// if GetClass ( i ) = 4 then
27651: LD_VAR 0 3
27655: PPUSH
27656: CALL_OW 257
27660: PUSH
27661: LD_INT 4
27663: EQUAL
27664: IFFALSE 27668
// continue ;
27666: GO 27634
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27668: LD_ADDR_VAR 0 11
27672: PUSH
27673: LD_VAR 0 11
27677: PPUSH
27678: LD_VAR 0 11
27682: PUSH
27683: LD_INT 1
27685: PLUS
27686: PPUSH
27687: LD_VAR 0 9
27691: PUSH
27692: LD_VAR 0 3
27696: ARRAY
27697: PPUSH
27698: CALL_OW 2
27702: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27703: LD_ADDR_VAR 0 4
27707: PUSH
27708: LD_VAR 0 4
27712: PUSH
27713: LD_VAR 0 9
27717: PUSH
27718: LD_VAR 0 3
27722: ARRAY
27723: DIFF
27724: ST_TO_ADDR
// end ;
27725: GO 27634
27727: POP
27728: POP
// if p then
27729: LD_VAR 0 11
27733: IFFALSE 27758
// result := Replace ( result , 4 , p ) ;
27735: LD_ADDR_VAR 0 2
27739: PUSH
27740: LD_VAR 0 2
27744: PPUSH
27745: LD_INT 4
27747: PPUSH
27748: LD_VAR 0 11
27752: PPUSH
27753: CALL_OW 1
27757: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27758: LD_VAR 0 4
27762: PUSH
27763: LD_VAR 0 7
27767: PUSH
27768: LD_INT 6
27770: LESS
27771: AND
27772: IFFALSE 27960
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27774: LD_ADDR_VAR 0 9
27778: PUSH
27779: LD_VAR 0 4
27783: PUSH
27784: LD_VAR 0 8
27788: PUSH
27789: LD_VAR 0 7
27793: UNION
27794: DIFF
27795: PPUSH
27796: LD_INT 3
27798: PPUSH
27799: CALL 87733 0 2
27803: ST_TO_ADDR
// p := [ ] ;
27804: LD_ADDR_VAR 0 11
27808: PUSH
27809: EMPTY
27810: ST_TO_ADDR
// if sort then
27811: LD_VAR 0 9
27815: IFFALSE 27931
// for i = 1 to 6 - mech do
27817: LD_ADDR_VAR 0 3
27821: PUSH
27822: DOUBLE
27823: LD_INT 1
27825: DEC
27826: ST_TO_ADDR
27827: LD_INT 6
27829: PUSH
27830: LD_VAR 0 7
27834: MINUS
27835: PUSH
27836: FOR_TO
27837: IFFALSE 27929
// begin if i = sort then
27839: LD_VAR 0 3
27843: PUSH
27844: LD_VAR 0 9
27848: EQUAL
27849: IFFALSE 27853
// break ;
27851: GO 27929
// if GetClass ( i ) = 3 then
27853: LD_VAR 0 3
27857: PPUSH
27858: CALL_OW 257
27862: PUSH
27863: LD_INT 3
27865: EQUAL
27866: IFFALSE 27870
// continue ;
27868: GO 27836
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27870: LD_ADDR_VAR 0 11
27874: PUSH
27875: LD_VAR 0 11
27879: PPUSH
27880: LD_VAR 0 11
27884: PUSH
27885: LD_INT 1
27887: PLUS
27888: PPUSH
27889: LD_VAR 0 9
27893: PUSH
27894: LD_VAR 0 3
27898: ARRAY
27899: PPUSH
27900: CALL_OW 2
27904: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27905: LD_ADDR_VAR 0 4
27909: PUSH
27910: LD_VAR 0 4
27914: PUSH
27915: LD_VAR 0 9
27919: PUSH
27920: LD_VAR 0 3
27924: ARRAY
27925: DIFF
27926: ST_TO_ADDR
// end ;
27927: GO 27836
27929: POP
27930: POP
// if p then
27931: LD_VAR 0 11
27935: IFFALSE 27960
// result := Replace ( result , 3 , p ) ;
27937: LD_ADDR_VAR 0 2
27941: PUSH
27942: LD_VAR 0 2
27946: PPUSH
27947: LD_INT 3
27949: PPUSH
27950: LD_VAR 0 11
27954: PPUSH
27955: CALL_OW 1
27959: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27960: LD_VAR 0 4
27964: PUSH
27965: LD_INT 6
27967: GREATER
27968: PUSH
27969: LD_VAR 0 6
27973: PUSH
27974: LD_INT 6
27976: LESS
27977: AND
27978: IFFALSE 28172
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27980: LD_ADDR_VAR 0 9
27984: PUSH
27985: LD_VAR 0 4
27989: PUSH
27990: LD_VAR 0 8
27994: PUSH
27995: LD_VAR 0 7
27999: UNION
28000: PUSH
28001: LD_VAR 0 6
28005: UNION
28006: DIFF
28007: PPUSH
28008: LD_INT 2
28010: PPUSH
28011: CALL 87733 0 2
28015: ST_TO_ADDR
// p := [ ] ;
28016: LD_ADDR_VAR 0 11
28020: PUSH
28021: EMPTY
28022: ST_TO_ADDR
// if sort then
28023: LD_VAR 0 9
28027: IFFALSE 28143
// for i = 1 to 6 - eng do
28029: LD_ADDR_VAR 0 3
28033: PUSH
28034: DOUBLE
28035: LD_INT 1
28037: DEC
28038: ST_TO_ADDR
28039: LD_INT 6
28041: PUSH
28042: LD_VAR 0 6
28046: MINUS
28047: PUSH
28048: FOR_TO
28049: IFFALSE 28141
// begin if i = sort then
28051: LD_VAR 0 3
28055: PUSH
28056: LD_VAR 0 9
28060: EQUAL
28061: IFFALSE 28065
// break ;
28063: GO 28141
// if GetClass ( i ) = 2 then
28065: LD_VAR 0 3
28069: PPUSH
28070: CALL_OW 257
28074: PUSH
28075: LD_INT 2
28077: EQUAL
28078: IFFALSE 28082
// continue ;
28080: GO 28048
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28082: LD_ADDR_VAR 0 11
28086: PUSH
28087: LD_VAR 0 11
28091: PPUSH
28092: LD_VAR 0 11
28096: PUSH
28097: LD_INT 1
28099: PLUS
28100: PPUSH
28101: LD_VAR 0 9
28105: PUSH
28106: LD_VAR 0 3
28110: ARRAY
28111: PPUSH
28112: CALL_OW 2
28116: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28117: LD_ADDR_VAR 0 4
28121: PUSH
28122: LD_VAR 0 4
28126: PUSH
28127: LD_VAR 0 9
28131: PUSH
28132: LD_VAR 0 3
28136: ARRAY
28137: DIFF
28138: ST_TO_ADDR
// end ;
28139: GO 28048
28141: POP
28142: POP
// if p then
28143: LD_VAR 0 11
28147: IFFALSE 28172
// result := Replace ( result , 2 , p ) ;
28149: LD_ADDR_VAR 0 2
28153: PUSH
28154: LD_VAR 0 2
28158: PPUSH
28159: LD_INT 2
28161: PPUSH
28162: LD_VAR 0 11
28166: PPUSH
28167: CALL_OW 1
28171: ST_TO_ADDR
// end ; exit ;
28172: GO 29560
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28174: LD_EXP 103
28178: PUSH
28179: LD_EXP 102
28183: PUSH
28184: LD_VAR 0 1
28188: ARRAY
28189: ARRAY
28190: NOT
28191: PUSH
28192: LD_EXP 76
28196: PUSH
28197: LD_VAR 0 1
28201: ARRAY
28202: PPUSH
28203: LD_INT 30
28205: PUSH
28206: LD_INT 3
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PPUSH
28213: CALL_OW 72
28217: AND
28218: PUSH
28219: LD_EXP 81
28223: PUSH
28224: LD_VAR 0 1
28228: ARRAY
28229: AND
28230: IFFALSE 28838
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28232: LD_ADDR_EXP 118
28236: PUSH
28237: LD_EXP 118
28241: PPUSH
28242: LD_VAR 0 1
28246: PPUSH
28247: LD_INT 5
28249: PPUSH
28250: CALL_OW 1
28254: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28255: LD_ADDR_VAR 0 2
28259: PUSH
28260: LD_INT 0
28262: PUSH
28263: LD_INT 0
28265: PUSH
28266: LD_INT 0
28268: PUSH
28269: LD_INT 0
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: LIST
28276: LIST
28277: ST_TO_ADDR
// if sci > 1 then
28278: LD_VAR 0 8
28282: PUSH
28283: LD_INT 1
28285: GREATER
28286: IFFALSE 28314
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28288: LD_ADDR_VAR 0 4
28292: PUSH
28293: LD_VAR 0 4
28297: PUSH
28298: LD_VAR 0 8
28302: PUSH
28303: LD_VAR 0 8
28307: PUSH
28308: LD_INT 1
28310: ARRAY
28311: DIFF
28312: DIFF
28313: ST_TO_ADDR
// if tmp and not sci then
28314: LD_VAR 0 4
28318: PUSH
28319: LD_VAR 0 8
28323: NOT
28324: AND
28325: IFFALSE 28394
// begin sort := SortBySkill ( tmp , 4 ) ;
28327: LD_ADDR_VAR 0 9
28331: PUSH
28332: LD_VAR 0 4
28336: PPUSH
28337: LD_INT 4
28339: PPUSH
28340: CALL 87733 0 2
28344: ST_TO_ADDR
// if sort then
28345: LD_VAR 0 9
28349: IFFALSE 28365
// p := sort [ 1 ] ;
28351: LD_ADDR_VAR 0 11
28355: PUSH
28356: LD_VAR 0 9
28360: PUSH
28361: LD_INT 1
28363: ARRAY
28364: ST_TO_ADDR
// if p then
28365: LD_VAR 0 11
28369: IFFALSE 28394
// result := Replace ( result , 4 , p ) ;
28371: LD_ADDR_VAR 0 2
28375: PUSH
28376: LD_VAR 0 2
28380: PPUSH
28381: LD_INT 4
28383: PPUSH
28384: LD_VAR 0 11
28388: PPUSH
28389: CALL_OW 1
28393: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28394: LD_ADDR_VAR 0 4
28398: PUSH
28399: LD_VAR 0 4
28403: PUSH
28404: LD_VAR 0 7
28408: DIFF
28409: ST_TO_ADDR
// if tmp and mech < 6 then
28410: LD_VAR 0 4
28414: PUSH
28415: LD_VAR 0 7
28419: PUSH
28420: LD_INT 6
28422: LESS
28423: AND
28424: IFFALSE 28612
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28426: LD_ADDR_VAR 0 9
28430: PUSH
28431: LD_VAR 0 4
28435: PUSH
28436: LD_VAR 0 8
28440: PUSH
28441: LD_VAR 0 7
28445: UNION
28446: DIFF
28447: PPUSH
28448: LD_INT 3
28450: PPUSH
28451: CALL 87733 0 2
28455: ST_TO_ADDR
// p := [ ] ;
28456: LD_ADDR_VAR 0 11
28460: PUSH
28461: EMPTY
28462: ST_TO_ADDR
// if sort then
28463: LD_VAR 0 9
28467: IFFALSE 28583
// for i = 1 to 6 - mech do
28469: LD_ADDR_VAR 0 3
28473: PUSH
28474: DOUBLE
28475: LD_INT 1
28477: DEC
28478: ST_TO_ADDR
28479: LD_INT 6
28481: PUSH
28482: LD_VAR 0 7
28486: MINUS
28487: PUSH
28488: FOR_TO
28489: IFFALSE 28581
// begin if i = sort then
28491: LD_VAR 0 3
28495: PUSH
28496: LD_VAR 0 9
28500: EQUAL
28501: IFFALSE 28505
// break ;
28503: GO 28581
// if GetClass ( i ) = 3 then
28505: LD_VAR 0 3
28509: PPUSH
28510: CALL_OW 257
28514: PUSH
28515: LD_INT 3
28517: EQUAL
28518: IFFALSE 28522
// continue ;
28520: GO 28488
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28522: LD_ADDR_VAR 0 11
28526: PUSH
28527: LD_VAR 0 11
28531: PPUSH
28532: LD_VAR 0 11
28536: PUSH
28537: LD_INT 1
28539: PLUS
28540: PPUSH
28541: LD_VAR 0 9
28545: PUSH
28546: LD_VAR 0 3
28550: ARRAY
28551: PPUSH
28552: CALL_OW 2
28556: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28557: LD_ADDR_VAR 0 4
28561: PUSH
28562: LD_VAR 0 4
28566: PUSH
28567: LD_VAR 0 9
28571: PUSH
28572: LD_VAR 0 3
28576: ARRAY
28577: DIFF
28578: ST_TO_ADDR
// end ;
28579: GO 28488
28581: POP
28582: POP
// if p then
28583: LD_VAR 0 11
28587: IFFALSE 28612
// result := Replace ( result , 3 , p ) ;
28589: LD_ADDR_VAR 0 2
28593: PUSH
28594: LD_VAR 0 2
28598: PPUSH
28599: LD_INT 3
28601: PPUSH
28602: LD_VAR 0 11
28606: PPUSH
28607: CALL_OW 1
28611: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28612: LD_ADDR_VAR 0 4
28616: PUSH
28617: LD_VAR 0 4
28621: PUSH
28622: LD_VAR 0 6
28626: DIFF
28627: ST_TO_ADDR
// if tmp and eng < 6 then
28628: LD_VAR 0 4
28632: PUSH
28633: LD_VAR 0 6
28637: PUSH
28638: LD_INT 6
28640: LESS
28641: AND
28642: IFFALSE 28836
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28644: LD_ADDR_VAR 0 9
28648: PUSH
28649: LD_VAR 0 4
28653: PUSH
28654: LD_VAR 0 8
28658: PUSH
28659: LD_VAR 0 7
28663: UNION
28664: PUSH
28665: LD_VAR 0 6
28669: UNION
28670: DIFF
28671: PPUSH
28672: LD_INT 2
28674: PPUSH
28675: CALL 87733 0 2
28679: ST_TO_ADDR
// p := [ ] ;
28680: LD_ADDR_VAR 0 11
28684: PUSH
28685: EMPTY
28686: ST_TO_ADDR
// if sort then
28687: LD_VAR 0 9
28691: IFFALSE 28807
// for i = 1 to 6 - eng do
28693: LD_ADDR_VAR 0 3
28697: PUSH
28698: DOUBLE
28699: LD_INT 1
28701: DEC
28702: ST_TO_ADDR
28703: LD_INT 6
28705: PUSH
28706: LD_VAR 0 6
28710: MINUS
28711: PUSH
28712: FOR_TO
28713: IFFALSE 28805
// begin if i = sort then
28715: LD_VAR 0 3
28719: PUSH
28720: LD_VAR 0 9
28724: EQUAL
28725: IFFALSE 28729
// break ;
28727: GO 28805
// if GetClass ( i ) = 2 then
28729: LD_VAR 0 3
28733: PPUSH
28734: CALL_OW 257
28738: PUSH
28739: LD_INT 2
28741: EQUAL
28742: IFFALSE 28746
// continue ;
28744: GO 28712
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28746: LD_ADDR_VAR 0 11
28750: PUSH
28751: LD_VAR 0 11
28755: PPUSH
28756: LD_VAR 0 11
28760: PUSH
28761: LD_INT 1
28763: PLUS
28764: PPUSH
28765: LD_VAR 0 9
28769: PUSH
28770: LD_VAR 0 3
28774: ARRAY
28775: PPUSH
28776: CALL_OW 2
28780: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28781: LD_ADDR_VAR 0 4
28785: PUSH
28786: LD_VAR 0 4
28790: PUSH
28791: LD_VAR 0 9
28795: PUSH
28796: LD_VAR 0 3
28800: ARRAY
28801: DIFF
28802: ST_TO_ADDR
// end ;
28803: GO 28712
28805: POP
28806: POP
// if p then
28807: LD_VAR 0 11
28811: IFFALSE 28836
// result := Replace ( result , 2 , p ) ;
28813: LD_ADDR_VAR 0 2
28817: PUSH
28818: LD_VAR 0 2
28822: PPUSH
28823: LD_INT 2
28825: PPUSH
28826: LD_VAR 0 11
28830: PPUSH
28831: CALL_OW 1
28835: ST_TO_ADDR
// end ; exit ;
28836: GO 29560
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28838: LD_EXP 103
28842: PUSH
28843: LD_EXP 102
28847: PUSH
28848: LD_VAR 0 1
28852: ARRAY
28853: ARRAY
28854: NOT
28855: PUSH
28856: LD_EXP 76
28860: PUSH
28861: LD_VAR 0 1
28865: ARRAY
28866: PPUSH
28867: LD_INT 30
28869: PUSH
28870: LD_INT 3
28872: PUSH
28873: EMPTY
28874: LIST
28875: LIST
28876: PPUSH
28877: CALL_OW 72
28881: AND
28882: PUSH
28883: LD_EXP 81
28887: PUSH
28888: LD_VAR 0 1
28892: ARRAY
28893: NOT
28894: AND
28895: IFFALSE 29560
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28897: LD_ADDR_EXP 118
28901: PUSH
28902: LD_EXP 118
28906: PPUSH
28907: LD_VAR 0 1
28911: PPUSH
28912: LD_INT 6
28914: PPUSH
28915: CALL_OW 1
28919: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28920: LD_ADDR_VAR 0 2
28924: PUSH
28925: LD_INT 0
28927: PUSH
28928: LD_INT 0
28930: PUSH
28931: LD_INT 0
28933: PUSH
28934: LD_INT 0
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: ST_TO_ADDR
// if sci >= 1 then
28943: LD_VAR 0 8
28947: PUSH
28948: LD_INT 1
28950: GREATEREQUAL
28951: IFFALSE 28973
// tmp := tmp diff sci [ 1 ] ;
28953: LD_ADDR_VAR 0 4
28957: PUSH
28958: LD_VAR 0 4
28962: PUSH
28963: LD_VAR 0 8
28967: PUSH
28968: LD_INT 1
28970: ARRAY
28971: DIFF
28972: ST_TO_ADDR
// if tmp and not sci then
28973: LD_VAR 0 4
28977: PUSH
28978: LD_VAR 0 8
28982: NOT
28983: AND
28984: IFFALSE 29053
// begin sort := SortBySkill ( tmp , 4 ) ;
28986: LD_ADDR_VAR 0 9
28990: PUSH
28991: LD_VAR 0 4
28995: PPUSH
28996: LD_INT 4
28998: PPUSH
28999: CALL 87733 0 2
29003: ST_TO_ADDR
// if sort then
29004: LD_VAR 0 9
29008: IFFALSE 29024
// p := sort [ 1 ] ;
29010: LD_ADDR_VAR 0 11
29014: PUSH
29015: LD_VAR 0 9
29019: PUSH
29020: LD_INT 1
29022: ARRAY
29023: ST_TO_ADDR
// if p then
29024: LD_VAR 0 11
29028: IFFALSE 29053
// result := Replace ( result , 4 , p ) ;
29030: LD_ADDR_VAR 0 2
29034: PUSH
29035: LD_VAR 0 2
29039: PPUSH
29040: LD_INT 4
29042: PPUSH
29043: LD_VAR 0 11
29047: PPUSH
29048: CALL_OW 1
29052: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29053: LD_ADDR_VAR 0 4
29057: PUSH
29058: LD_VAR 0 4
29062: PUSH
29063: LD_VAR 0 7
29067: DIFF
29068: ST_TO_ADDR
// if tmp and mech < 6 then
29069: LD_VAR 0 4
29073: PUSH
29074: LD_VAR 0 7
29078: PUSH
29079: LD_INT 6
29081: LESS
29082: AND
29083: IFFALSE 29265
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29085: LD_ADDR_VAR 0 9
29089: PUSH
29090: LD_VAR 0 4
29094: PUSH
29095: LD_VAR 0 7
29099: DIFF
29100: PPUSH
29101: LD_INT 3
29103: PPUSH
29104: CALL 87733 0 2
29108: ST_TO_ADDR
// p := [ ] ;
29109: LD_ADDR_VAR 0 11
29113: PUSH
29114: EMPTY
29115: ST_TO_ADDR
// if sort then
29116: LD_VAR 0 9
29120: IFFALSE 29236
// for i = 1 to 6 - mech do
29122: LD_ADDR_VAR 0 3
29126: PUSH
29127: DOUBLE
29128: LD_INT 1
29130: DEC
29131: ST_TO_ADDR
29132: LD_INT 6
29134: PUSH
29135: LD_VAR 0 7
29139: MINUS
29140: PUSH
29141: FOR_TO
29142: IFFALSE 29234
// begin if i = sort then
29144: LD_VAR 0 3
29148: PUSH
29149: LD_VAR 0 9
29153: EQUAL
29154: IFFALSE 29158
// break ;
29156: GO 29234
// if GetClass ( i ) = 3 then
29158: LD_VAR 0 3
29162: PPUSH
29163: CALL_OW 257
29167: PUSH
29168: LD_INT 3
29170: EQUAL
29171: IFFALSE 29175
// continue ;
29173: GO 29141
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29175: LD_ADDR_VAR 0 11
29179: PUSH
29180: LD_VAR 0 11
29184: PPUSH
29185: LD_VAR 0 11
29189: PUSH
29190: LD_INT 1
29192: PLUS
29193: PPUSH
29194: LD_VAR 0 9
29198: PUSH
29199: LD_VAR 0 3
29203: ARRAY
29204: PPUSH
29205: CALL_OW 2
29209: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29210: LD_ADDR_VAR 0 4
29214: PUSH
29215: LD_VAR 0 4
29219: PUSH
29220: LD_VAR 0 9
29224: PUSH
29225: LD_VAR 0 3
29229: ARRAY
29230: DIFF
29231: ST_TO_ADDR
// end ;
29232: GO 29141
29234: POP
29235: POP
// if p then
29236: LD_VAR 0 11
29240: IFFALSE 29265
// result := Replace ( result , 3 , p ) ;
29242: LD_ADDR_VAR 0 2
29246: PUSH
29247: LD_VAR 0 2
29251: PPUSH
29252: LD_INT 3
29254: PPUSH
29255: LD_VAR 0 11
29259: PPUSH
29260: CALL_OW 1
29264: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29265: LD_ADDR_VAR 0 4
29269: PUSH
29270: LD_VAR 0 4
29274: PUSH
29275: LD_VAR 0 6
29279: DIFF
29280: ST_TO_ADDR
// if tmp and eng < 4 then
29281: LD_VAR 0 4
29285: PUSH
29286: LD_VAR 0 6
29290: PUSH
29291: LD_INT 4
29293: LESS
29294: AND
29295: IFFALSE 29485
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29297: LD_ADDR_VAR 0 9
29301: PUSH
29302: LD_VAR 0 4
29306: PUSH
29307: LD_VAR 0 7
29311: PUSH
29312: LD_VAR 0 6
29316: UNION
29317: DIFF
29318: PPUSH
29319: LD_INT 2
29321: PPUSH
29322: CALL 87733 0 2
29326: ST_TO_ADDR
// p := [ ] ;
29327: LD_ADDR_VAR 0 11
29331: PUSH
29332: EMPTY
29333: ST_TO_ADDR
// if sort then
29334: LD_VAR 0 9
29338: IFFALSE 29454
// for i = 1 to 4 - eng do
29340: LD_ADDR_VAR 0 3
29344: PUSH
29345: DOUBLE
29346: LD_INT 1
29348: DEC
29349: ST_TO_ADDR
29350: LD_INT 4
29352: PUSH
29353: LD_VAR 0 6
29357: MINUS
29358: PUSH
29359: FOR_TO
29360: IFFALSE 29452
// begin if i = sort then
29362: LD_VAR 0 3
29366: PUSH
29367: LD_VAR 0 9
29371: EQUAL
29372: IFFALSE 29376
// break ;
29374: GO 29452
// if GetClass ( i ) = 2 then
29376: LD_VAR 0 3
29380: PPUSH
29381: CALL_OW 257
29385: PUSH
29386: LD_INT 2
29388: EQUAL
29389: IFFALSE 29393
// continue ;
29391: GO 29359
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29393: LD_ADDR_VAR 0 11
29397: PUSH
29398: LD_VAR 0 11
29402: PPUSH
29403: LD_VAR 0 11
29407: PUSH
29408: LD_INT 1
29410: PLUS
29411: PPUSH
29412: LD_VAR 0 9
29416: PUSH
29417: LD_VAR 0 3
29421: ARRAY
29422: PPUSH
29423: CALL_OW 2
29427: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29428: LD_ADDR_VAR 0 4
29432: PUSH
29433: LD_VAR 0 4
29437: PUSH
29438: LD_VAR 0 9
29442: PUSH
29443: LD_VAR 0 3
29447: ARRAY
29448: DIFF
29449: ST_TO_ADDR
// end ;
29450: GO 29359
29452: POP
29453: POP
// if p then
29454: LD_VAR 0 11
29458: IFFALSE 29483
// result := Replace ( result , 2 , p ) ;
29460: LD_ADDR_VAR 0 2
29464: PUSH
29465: LD_VAR 0 2
29469: PPUSH
29470: LD_INT 2
29472: PPUSH
29473: LD_VAR 0 11
29477: PPUSH
29478: CALL_OW 1
29482: ST_TO_ADDR
// end else
29483: GO 29529
// for i = eng downto 5 do
29485: LD_ADDR_VAR 0 3
29489: PUSH
29490: DOUBLE
29491: LD_VAR 0 6
29495: INC
29496: ST_TO_ADDR
29497: LD_INT 5
29499: PUSH
29500: FOR_DOWNTO
29501: IFFALSE 29527
// tmp := tmp union eng [ i ] ;
29503: LD_ADDR_VAR 0 4
29507: PUSH
29508: LD_VAR 0 4
29512: PUSH
29513: LD_VAR 0 6
29517: PUSH
29518: LD_VAR 0 3
29522: ARRAY
29523: UNION
29524: ST_TO_ADDR
29525: GO 29500
29527: POP
29528: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29529: LD_ADDR_VAR 0 2
29533: PUSH
29534: LD_VAR 0 2
29538: PPUSH
29539: LD_INT 1
29541: PPUSH
29542: LD_VAR 0 4
29546: PUSH
29547: LD_VAR 0 5
29551: DIFF
29552: PPUSH
29553: CALL_OW 1
29557: ST_TO_ADDR
// exit ;
29558: GO 29560
// end ; end ;
29560: LD_VAR 0 2
29564: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29565: LD_INT 0
29567: PPUSH
29568: PPUSH
29569: PPUSH
// if not mc_bases then
29570: LD_EXP 76
29574: NOT
29575: IFFALSE 29579
// exit ;
29577: GO 29721
// for i = 1 to mc_bases do
29579: LD_ADDR_VAR 0 2
29583: PUSH
29584: DOUBLE
29585: LD_INT 1
29587: DEC
29588: ST_TO_ADDR
29589: LD_EXP 76
29593: PUSH
29594: FOR_TO
29595: IFFALSE 29712
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29597: LD_ADDR_VAR 0 3
29601: PUSH
29602: LD_EXP 76
29606: PUSH
29607: LD_VAR 0 2
29611: ARRAY
29612: PPUSH
29613: LD_INT 21
29615: PUSH
29616: LD_INT 3
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: LD_INT 3
29625: PUSH
29626: LD_INT 2
29628: PUSH
29629: LD_INT 30
29631: PUSH
29632: LD_INT 29
29634: PUSH
29635: EMPTY
29636: LIST
29637: LIST
29638: PUSH
29639: LD_INT 30
29641: PUSH
29642: LD_INT 30
29644: PUSH
29645: EMPTY
29646: LIST
29647: LIST
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: LIST
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PUSH
29658: LD_INT 3
29660: PUSH
29661: LD_INT 24
29663: PUSH
29664: LD_INT 1000
29666: PUSH
29667: EMPTY
29668: LIST
29669: LIST
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: LIST
29679: PPUSH
29680: CALL_OW 72
29684: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29685: LD_ADDR_EXP 77
29689: PUSH
29690: LD_EXP 77
29694: PPUSH
29695: LD_VAR 0 2
29699: PPUSH
29700: LD_VAR 0 3
29704: PPUSH
29705: CALL_OW 1
29709: ST_TO_ADDR
// end ;
29710: GO 29594
29712: POP
29713: POP
// RaiseSailEvent ( 101 ) ;
29714: LD_INT 101
29716: PPUSH
29717: CALL_OW 427
// end ;
29721: LD_VAR 0 1
29725: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29726: LD_INT 0
29728: PPUSH
29729: PPUSH
29730: PPUSH
29731: PPUSH
29732: PPUSH
29733: PPUSH
29734: PPUSH
// if not mc_bases then
29735: LD_EXP 76
29739: NOT
29740: IFFALSE 29744
// exit ;
29742: GO 30306
// for i = 1 to mc_bases do
29744: LD_ADDR_VAR 0 2
29748: PUSH
29749: DOUBLE
29750: LD_INT 1
29752: DEC
29753: ST_TO_ADDR
29754: LD_EXP 76
29758: PUSH
29759: FOR_TO
29760: IFFALSE 30297
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29762: LD_ADDR_VAR 0 5
29766: PUSH
29767: LD_EXP 76
29771: PUSH
29772: LD_VAR 0 2
29776: ARRAY
29777: PUSH
29778: LD_EXP 105
29782: PUSH
29783: LD_VAR 0 2
29787: ARRAY
29788: UNION
29789: PPUSH
29790: LD_INT 21
29792: PUSH
29793: LD_INT 1
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 1
29802: PUSH
29803: LD_INT 3
29805: PUSH
29806: LD_INT 54
29808: PUSH
29809: EMPTY
29810: LIST
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 3
29818: PUSH
29819: LD_INT 24
29821: PUSH
29822: LD_INT 1000
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: LIST
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PPUSH
29842: CALL_OW 72
29846: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29847: LD_ADDR_VAR 0 6
29851: PUSH
29852: LD_EXP 76
29856: PUSH
29857: LD_VAR 0 2
29861: ARRAY
29862: PPUSH
29863: LD_INT 21
29865: PUSH
29866: LD_INT 1
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: PUSH
29873: LD_INT 1
29875: PUSH
29876: LD_INT 3
29878: PUSH
29879: LD_INT 54
29881: PUSH
29882: EMPTY
29883: LIST
29884: PUSH
29885: EMPTY
29886: LIST
29887: LIST
29888: PUSH
29889: LD_INT 3
29891: PUSH
29892: LD_INT 24
29894: PUSH
29895: LD_INT 250
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: EMPTY
29907: LIST
29908: LIST
29909: LIST
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PPUSH
29915: CALL_OW 72
29919: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29920: LD_ADDR_VAR 0 7
29924: PUSH
29925: LD_VAR 0 5
29929: PUSH
29930: LD_VAR 0 6
29934: DIFF
29935: ST_TO_ADDR
// if not need_heal_1 then
29936: LD_VAR 0 6
29940: NOT
29941: IFFALSE 29974
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29943: LD_ADDR_EXP 79
29947: PUSH
29948: LD_EXP 79
29952: PPUSH
29953: LD_VAR 0 2
29957: PUSH
29958: LD_INT 1
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PPUSH
29965: EMPTY
29966: PPUSH
29967: CALL 56985 0 3
29971: ST_TO_ADDR
29972: GO 30044
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29974: LD_ADDR_EXP 79
29978: PUSH
29979: LD_EXP 79
29983: PPUSH
29984: LD_VAR 0 2
29988: PUSH
29989: LD_INT 1
29991: PUSH
29992: EMPTY
29993: LIST
29994: LIST
29995: PPUSH
29996: LD_EXP 79
30000: PUSH
30001: LD_VAR 0 2
30005: ARRAY
30006: PUSH
30007: LD_INT 1
30009: ARRAY
30010: PPUSH
30011: LD_INT 3
30013: PUSH
30014: LD_INT 24
30016: PUSH
30017: LD_INT 1000
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PPUSH
30028: CALL_OW 72
30032: PUSH
30033: LD_VAR 0 6
30037: UNION
30038: PPUSH
30039: CALL 56985 0 3
30043: ST_TO_ADDR
// if not need_heal_2 then
30044: LD_VAR 0 7
30048: NOT
30049: IFFALSE 30082
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30051: LD_ADDR_EXP 79
30055: PUSH
30056: LD_EXP 79
30060: PPUSH
30061: LD_VAR 0 2
30065: PUSH
30066: LD_INT 2
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PPUSH
30073: EMPTY
30074: PPUSH
30075: CALL 56985 0 3
30079: ST_TO_ADDR
30080: GO 30114
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30082: LD_ADDR_EXP 79
30086: PUSH
30087: LD_EXP 79
30091: PPUSH
30092: LD_VAR 0 2
30096: PUSH
30097: LD_INT 2
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PPUSH
30104: LD_VAR 0 7
30108: PPUSH
30109: CALL 56985 0 3
30113: ST_TO_ADDR
// if need_heal_2 then
30114: LD_VAR 0 7
30118: IFFALSE 30279
// for j in need_heal_2 do
30120: LD_ADDR_VAR 0 3
30124: PUSH
30125: LD_VAR 0 7
30129: PUSH
30130: FOR_IN
30131: IFFALSE 30277
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30133: LD_ADDR_VAR 0 5
30137: PUSH
30138: LD_EXP 76
30142: PUSH
30143: LD_VAR 0 2
30147: ARRAY
30148: PPUSH
30149: LD_INT 2
30151: PUSH
30152: LD_INT 30
30154: PUSH
30155: LD_INT 6
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 30
30164: PUSH
30165: LD_INT 7
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 30
30174: PUSH
30175: LD_INT 8
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 30
30184: PUSH
30185: LD_INT 0
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: LD_INT 30
30194: PUSH
30195: LD_INT 1
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: PUSH
30202: EMPTY
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: LIST
30209: PPUSH
30210: CALL_OW 72
30214: ST_TO_ADDR
// if tmp then
30215: LD_VAR 0 5
30219: IFFALSE 30275
// begin k := NearestUnitToUnit ( tmp , j ) ;
30221: LD_ADDR_VAR 0 4
30225: PUSH
30226: LD_VAR 0 5
30230: PPUSH
30231: LD_VAR 0 3
30235: PPUSH
30236: CALL_OW 74
30240: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30241: LD_VAR 0 3
30245: PPUSH
30246: LD_VAR 0 4
30250: PPUSH
30251: CALL_OW 296
30255: PUSH
30256: LD_INT 5
30258: GREATER
30259: IFFALSE 30275
// ComMoveToNearbyEntrance ( j , k ) ;
30261: LD_VAR 0 3
30265: PPUSH
30266: LD_VAR 0 4
30270: PPUSH
30271: CALL 90101 0 2
// end ; end ;
30275: GO 30130
30277: POP
30278: POP
// if not need_heal_1 and not need_heal_2 then
30279: LD_VAR 0 6
30283: NOT
30284: PUSH
30285: LD_VAR 0 7
30289: NOT
30290: AND
30291: IFFALSE 30295
// continue ;
30293: GO 29759
// end ;
30295: GO 29759
30297: POP
30298: POP
// RaiseSailEvent ( 102 ) ;
30299: LD_INT 102
30301: PPUSH
30302: CALL_OW 427
// end ;
30306: LD_VAR 0 1
30310: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30311: LD_INT 0
30313: PPUSH
30314: PPUSH
30315: PPUSH
30316: PPUSH
30317: PPUSH
30318: PPUSH
30319: PPUSH
30320: PPUSH
// if not mc_bases then
30321: LD_EXP 76
30325: NOT
30326: IFFALSE 30330
// exit ;
30328: GO 31209
// for i = 1 to mc_bases do
30330: LD_ADDR_VAR 0 2
30334: PUSH
30335: DOUBLE
30336: LD_INT 1
30338: DEC
30339: ST_TO_ADDR
30340: LD_EXP 76
30344: PUSH
30345: FOR_TO
30346: IFFALSE 31207
// begin if not mc_building_need_repair [ i ] then
30348: LD_EXP 77
30352: PUSH
30353: LD_VAR 0 2
30357: ARRAY
30358: NOT
30359: IFFALSE 30544
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30361: LD_ADDR_VAR 0 6
30365: PUSH
30366: LD_EXP 95
30370: PUSH
30371: LD_VAR 0 2
30375: ARRAY
30376: PPUSH
30377: LD_INT 3
30379: PUSH
30380: LD_INT 24
30382: PUSH
30383: LD_INT 1000
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: PUSH
30390: EMPTY
30391: LIST
30392: LIST
30393: PUSH
30394: LD_INT 2
30396: PUSH
30397: LD_INT 34
30399: PUSH
30400: LD_INT 13
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 34
30409: PUSH
30410: LD_INT 52
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 34
30419: PUSH
30420: LD_INT 88
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: EMPTY
30428: LIST
30429: LIST
30430: LIST
30431: LIST
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: PPUSH
30437: CALL_OW 72
30441: ST_TO_ADDR
// if cranes then
30442: LD_VAR 0 6
30446: IFFALSE 30508
// for j in cranes do
30448: LD_ADDR_VAR 0 3
30452: PUSH
30453: LD_VAR 0 6
30457: PUSH
30458: FOR_IN
30459: IFFALSE 30506
// if not IsInArea ( j , mc_parking [ i ] ) then
30461: LD_VAR 0 3
30465: PPUSH
30466: LD_EXP 100
30470: PUSH
30471: LD_VAR 0 2
30475: ARRAY
30476: PPUSH
30477: CALL_OW 308
30481: NOT
30482: IFFALSE 30504
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30484: LD_VAR 0 3
30488: PPUSH
30489: LD_EXP 100
30493: PUSH
30494: LD_VAR 0 2
30498: ARRAY
30499: PPUSH
30500: CALL_OW 113
30504: GO 30458
30506: POP
30507: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30508: LD_ADDR_EXP 78
30512: PUSH
30513: LD_EXP 78
30517: PPUSH
30518: LD_VAR 0 2
30522: PPUSH
30523: EMPTY
30524: PPUSH
30525: CALL_OW 1
30529: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30530: LD_VAR 0 2
30534: PPUSH
30535: LD_INT 101
30537: PPUSH
30538: CALL 25398 0 2
// continue ;
30542: GO 30345
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30544: LD_ADDR_EXP 82
30548: PUSH
30549: LD_EXP 82
30553: PPUSH
30554: LD_VAR 0 2
30558: PPUSH
30559: EMPTY
30560: PPUSH
30561: CALL_OW 1
30565: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30566: LD_VAR 0 2
30570: PPUSH
30571: LD_INT 103
30573: PPUSH
30574: CALL 25398 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30578: LD_ADDR_VAR 0 5
30582: PUSH
30583: LD_EXP 76
30587: PUSH
30588: LD_VAR 0 2
30592: ARRAY
30593: PUSH
30594: LD_EXP 105
30598: PUSH
30599: LD_VAR 0 2
30603: ARRAY
30604: UNION
30605: PPUSH
30606: LD_INT 2
30608: PUSH
30609: LD_INT 25
30611: PUSH
30612: LD_INT 2
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 25
30621: PUSH
30622: LD_INT 16
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: LIST
30633: PUSH
30634: EMPTY
30635: LIST
30636: PPUSH
30637: CALL_OW 72
30641: ST_TO_ADDR
// if mc_need_heal [ i ] then
30642: LD_EXP 79
30646: PUSH
30647: LD_VAR 0 2
30651: ARRAY
30652: IFFALSE 30696
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30654: LD_ADDR_VAR 0 5
30658: PUSH
30659: LD_VAR 0 5
30663: PUSH
30664: LD_EXP 79
30668: PUSH
30669: LD_VAR 0 2
30673: ARRAY
30674: PUSH
30675: LD_INT 1
30677: ARRAY
30678: PUSH
30679: LD_EXP 79
30683: PUSH
30684: LD_VAR 0 2
30688: ARRAY
30689: PUSH
30690: LD_INT 2
30692: ARRAY
30693: UNION
30694: DIFF
30695: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30696: LD_ADDR_VAR 0 6
30700: PUSH
30701: LD_EXP 95
30705: PUSH
30706: LD_VAR 0 2
30710: ARRAY
30711: PPUSH
30712: LD_INT 2
30714: PUSH
30715: LD_INT 34
30717: PUSH
30718: LD_INT 13
30720: PUSH
30721: EMPTY
30722: LIST
30723: LIST
30724: PUSH
30725: LD_INT 34
30727: PUSH
30728: LD_INT 52
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 34
30737: PUSH
30738: LD_INT 88
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: LIST
30749: LIST
30750: PPUSH
30751: CALL_OW 72
30755: ST_TO_ADDR
// if cranes then
30756: LD_VAR 0 6
30760: IFFALSE 30896
// begin for j in cranes do
30762: LD_ADDR_VAR 0 3
30766: PUSH
30767: LD_VAR 0 6
30771: PUSH
30772: FOR_IN
30773: IFFALSE 30894
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30775: LD_VAR 0 3
30779: PPUSH
30780: CALL_OW 256
30784: PUSH
30785: LD_INT 1000
30787: EQUAL
30788: PUSH
30789: LD_VAR 0 3
30793: PPUSH
30794: CALL_OW 314
30798: NOT
30799: AND
30800: IFFALSE 30834
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30802: LD_VAR 0 3
30806: PPUSH
30807: LD_EXP 77
30811: PUSH
30812: LD_VAR 0 2
30816: ARRAY
30817: PPUSH
30818: LD_VAR 0 3
30822: PPUSH
30823: CALL_OW 74
30827: PPUSH
30828: CALL_OW 130
30832: GO 30892
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30834: LD_VAR 0 3
30838: PPUSH
30839: CALL_OW 256
30843: PUSH
30844: LD_INT 500
30846: LESS
30847: PUSH
30848: LD_VAR 0 3
30852: PPUSH
30853: LD_EXP 100
30857: PUSH
30858: LD_VAR 0 2
30862: ARRAY
30863: PPUSH
30864: CALL_OW 308
30868: NOT
30869: AND
30870: IFFALSE 30892
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30872: LD_VAR 0 3
30876: PPUSH
30877: LD_EXP 100
30881: PUSH
30882: LD_VAR 0 2
30886: ARRAY
30887: PPUSH
30888: CALL_OW 113
// end ;
30892: GO 30772
30894: POP
30895: POP
// end ; if tmp > 3 then
30896: LD_VAR 0 5
30900: PUSH
30901: LD_INT 3
30903: GREATER
30904: IFFALSE 30924
// tmp := ShrinkArray ( tmp , 4 ) ;
30906: LD_ADDR_VAR 0 5
30910: PUSH
30911: LD_VAR 0 5
30915: PPUSH
30916: LD_INT 4
30918: PPUSH
30919: CALL 89539 0 2
30923: ST_TO_ADDR
// if not tmp then
30924: LD_VAR 0 5
30928: NOT
30929: IFFALSE 30933
// continue ;
30931: GO 30345
// for j in tmp do
30933: LD_ADDR_VAR 0 3
30937: PUSH
30938: LD_VAR 0 5
30942: PUSH
30943: FOR_IN
30944: IFFALSE 31203
// begin if IsInUnit ( j ) then
30946: LD_VAR 0 3
30950: PPUSH
30951: CALL_OW 310
30955: IFFALSE 30966
// ComExitBuilding ( j ) ;
30957: LD_VAR 0 3
30961: PPUSH
30962: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30966: LD_VAR 0 3
30970: PUSH
30971: LD_EXP 78
30975: PUSH
30976: LD_VAR 0 2
30980: ARRAY
30981: IN
30982: NOT
30983: IFFALSE 31041
// begin SetTag ( j , 101 ) ;
30985: LD_VAR 0 3
30989: PPUSH
30990: LD_INT 101
30992: PPUSH
30993: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30997: LD_ADDR_EXP 78
31001: PUSH
31002: LD_EXP 78
31006: PPUSH
31007: LD_VAR 0 2
31011: PUSH
31012: LD_EXP 78
31016: PUSH
31017: LD_VAR 0 2
31021: ARRAY
31022: PUSH
31023: LD_INT 1
31025: PLUS
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PPUSH
31031: LD_VAR 0 3
31035: PPUSH
31036: CALL 56985 0 3
31040: ST_TO_ADDR
// end ; wait ( 1 ) ;
31041: LD_INT 1
31043: PPUSH
31044: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31048: LD_ADDR_VAR 0 7
31052: PUSH
31053: LD_EXP 77
31057: PUSH
31058: LD_VAR 0 2
31062: ARRAY
31063: ST_TO_ADDR
// if mc_scan [ i ] then
31064: LD_EXP 99
31068: PUSH
31069: LD_VAR 0 2
31073: ARRAY
31074: IFFALSE 31136
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31076: LD_ADDR_VAR 0 7
31080: PUSH
31081: LD_EXP 77
31085: PUSH
31086: LD_VAR 0 2
31090: ARRAY
31091: PPUSH
31092: LD_INT 3
31094: PUSH
31095: LD_INT 30
31097: PUSH
31098: LD_INT 32
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 30
31107: PUSH
31108: LD_INT 33
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 30
31117: PUSH
31118: LD_INT 31
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: PPUSH
31131: CALL_OW 72
31135: ST_TO_ADDR
// if not to_repair_tmp then
31136: LD_VAR 0 7
31140: NOT
31141: IFFALSE 31145
// continue ;
31143: GO 30943
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31145: LD_ADDR_VAR 0 8
31149: PUSH
31150: LD_VAR 0 7
31154: PPUSH
31155: LD_VAR 0 3
31159: PPUSH
31160: CALL_OW 74
31164: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31165: LD_VAR 0 8
31169: PPUSH
31170: LD_INT 16
31172: PPUSH
31173: CALL 59582 0 2
31177: PUSH
31178: LD_INT 4
31180: ARRAY
31181: PUSH
31182: LD_INT 10
31184: LESS
31185: IFFALSE 31201
// ComRepairBuilding ( j , to_repair ) ;
31187: LD_VAR 0 3
31191: PPUSH
31192: LD_VAR 0 8
31196: PPUSH
31197: CALL_OW 130
// end ;
31201: GO 30943
31203: POP
31204: POP
// end ;
31205: GO 30345
31207: POP
31208: POP
// end ;
31209: LD_VAR 0 1
31213: RET
// export function MC_Heal ; var i , j , tmp ; begin
31214: LD_INT 0
31216: PPUSH
31217: PPUSH
31218: PPUSH
31219: PPUSH
// if not mc_bases then
31220: LD_EXP 76
31224: NOT
31225: IFFALSE 31229
// exit ;
31227: GO 31631
// for i = 1 to mc_bases do
31229: LD_ADDR_VAR 0 2
31233: PUSH
31234: DOUBLE
31235: LD_INT 1
31237: DEC
31238: ST_TO_ADDR
31239: LD_EXP 76
31243: PUSH
31244: FOR_TO
31245: IFFALSE 31629
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31247: LD_EXP 79
31251: PUSH
31252: LD_VAR 0 2
31256: ARRAY
31257: PUSH
31258: LD_INT 1
31260: ARRAY
31261: NOT
31262: PUSH
31263: LD_EXP 79
31267: PUSH
31268: LD_VAR 0 2
31272: ARRAY
31273: PUSH
31274: LD_INT 2
31276: ARRAY
31277: NOT
31278: AND
31279: IFFALSE 31317
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31281: LD_ADDR_EXP 80
31285: PUSH
31286: LD_EXP 80
31290: PPUSH
31291: LD_VAR 0 2
31295: PPUSH
31296: EMPTY
31297: PPUSH
31298: CALL_OW 1
31302: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31303: LD_VAR 0 2
31307: PPUSH
31308: LD_INT 102
31310: PPUSH
31311: CALL 25398 0 2
// continue ;
31315: GO 31244
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31317: LD_ADDR_VAR 0 4
31321: PUSH
31322: LD_EXP 76
31326: PUSH
31327: LD_VAR 0 2
31331: ARRAY
31332: PPUSH
31333: LD_INT 25
31335: PUSH
31336: LD_INT 4
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: PPUSH
31343: CALL_OW 72
31347: ST_TO_ADDR
// if not tmp then
31348: LD_VAR 0 4
31352: NOT
31353: IFFALSE 31357
// continue ;
31355: GO 31244
// if mc_taming [ i ] then
31357: LD_EXP 107
31361: PUSH
31362: LD_VAR 0 2
31366: ARRAY
31367: IFFALSE 31391
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31369: LD_ADDR_EXP 107
31373: PUSH
31374: LD_EXP 107
31378: PPUSH
31379: LD_VAR 0 2
31383: PPUSH
31384: EMPTY
31385: PPUSH
31386: CALL_OW 1
31390: ST_TO_ADDR
// for j in tmp do
31391: LD_ADDR_VAR 0 3
31395: PUSH
31396: LD_VAR 0 4
31400: PUSH
31401: FOR_IN
31402: IFFALSE 31625
// begin if IsInUnit ( j ) then
31404: LD_VAR 0 3
31408: PPUSH
31409: CALL_OW 310
31413: IFFALSE 31424
// ComExitBuilding ( j ) ;
31415: LD_VAR 0 3
31419: PPUSH
31420: CALL_OW 122
// if not j in mc_healers [ i ] then
31424: LD_VAR 0 3
31428: PUSH
31429: LD_EXP 80
31433: PUSH
31434: LD_VAR 0 2
31438: ARRAY
31439: IN
31440: NOT
31441: IFFALSE 31487
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31443: LD_ADDR_EXP 80
31447: PUSH
31448: LD_EXP 80
31452: PPUSH
31453: LD_VAR 0 2
31457: PUSH
31458: LD_EXP 80
31462: PUSH
31463: LD_VAR 0 2
31467: ARRAY
31468: PUSH
31469: LD_INT 1
31471: PLUS
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PPUSH
31477: LD_VAR 0 3
31481: PPUSH
31482: CALL 56985 0 3
31486: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31487: LD_VAR 0 3
31491: PPUSH
31492: CALL_OW 110
31496: PUSH
31497: LD_INT 102
31499: NONEQUAL
31500: IFFALSE 31514
// SetTag ( j , 102 ) ;
31502: LD_VAR 0 3
31506: PPUSH
31507: LD_INT 102
31509: PPUSH
31510: CALL_OW 109
// Wait ( 3 ) ;
31514: LD_INT 3
31516: PPUSH
31517: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31521: LD_EXP 79
31525: PUSH
31526: LD_VAR 0 2
31530: ARRAY
31531: PUSH
31532: LD_INT 1
31534: ARRAY
31535: IFFALSE 31567
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31537: LD_VAR 0 3
31541: PPUSH
31542: LD_EXP 79
31546: PUSH
31547: LD_VAR 0 2
31551: ARRAY
31552: PUSH
31553: LD_INT 1
31555: ARRAY
31556: PUSH
31557: LD_INT 1
31559: ARRAY
31560: PPUSH
31561: CALL_OW 128
31565: GO 31623
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31567: LD_VAR 0 3
31571: PPUSH
31572: CALL_OW 314
31576: NOT
31577: PUSH
31578: LD_EXP 79
31582: PUSH
31583: LD_VAR 0 2
31587: ARRAY
31588: PUSH
31589: LD_INT 2
31591: ARRAY
31592: AND
31593: IFFALSE 31623
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31595: LD_VAR 0 3
31599: PPUSH
31600: LD_EXP 79
31604: PUSH
31605: LD_VAR 0 2
31609: ARRAY
31610: PUSH
31611: LD_INT 2
31613: ARRAY
31614: PUSH
31615: LD_INT 1
31617: ARRAY
31618: PPUSH
31619: CALL_OW 128
// end ;
31623: GO 31401
31625: POP
31626: POP
// end ;
31627: GO 31244
31629: POP
31630: POP
// end ;
31631: LD_VAR 0 1
31635: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31636: LD_INT 0
31638: PPUSH
31639: PPUSH
31640: PPUSH
31641: PPUSH
31642: PPUSH
// if not mc_bases then
31643: LD_EXP 76
31647: NOT
31648: IFFALSE 31652
// exit ;
31650: GO 32823
// for i = 1 to mc_bases do
31652: LD_ADDR_VAR 0 2
31656: PUSH
31657: DOUBLE
31658: LD_INT 1
31660: DEC
31661: ST_TO_ADDR
31662: LD_EXP 76
31666: PUSH
31667: FOR_TO
31668: IFFALSE 32821
// begin if mc_scan [ i ] then
31670: LD_EXP 99
31674: PUSH
31675: LD_VAR 0 2
31679: ARRAY
31680: IFFALSE 31684
// continue ;
31682: GO 31667
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31684: LD_EXP 81
31688: PUSH
31689: LD_VAR 0 2
31693: ARRAY
31694: NOT
31695: PUSH
31696: LD_EXP 83
31700: PUSH
31701: LD_VAR 0 2
31705: ARRAY
31706: NOT
31707: AND
31708: PUSH
31709: LD_EXP 82
31713: PUSH
31714: LD_VAR 0 2
31718: ARRAY
31719: AND
31720: IFFALSE 31758
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31722: LD_ADDR_EXP 82
31726: PUSH
31727: LD_EXP 82
31731: PPUSH
31732: LD_VAR 0 2
31736: PPUSH
31737: EMPTY
31738: PPUSH
31739: CALL_OW 1
31743: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31744: LD_VAR 0 2
31748: PPUSH
31749: LD_INT 103
31751: PPUSH
31752: CALL 25398 0 2
// continue ;
31756: GO 31667
// end ; if mc_construct_list [ i ] then
31758: LD_EXP 83
31762: PUSH
31763: LD_VAR 0 2
31767: ARRAY
31768: IFFALSE 31988
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31770: LD_ADDR_VAR 0 4
31774: PUSH
31775: LD_EXP 76
31779: PUSH
31780: LD_VAR 0 2
31784: ARRAY
31785: PPUSH
31786: LD_INT 25
31788: PUSH
31789: LD_INT 2
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PPUSH
31796: CALL_OW 72
31800: PUSH
31801: LD_EXP 78
31805: PUSH
31806: LD_VAR 0 2
31810: ARRAY
31811: DIFF
31812: ST_TO_ADDR
// if not tmp then
31813: LD_VAR 0 4
31817: NOT
31818: IFFALSE 31822
// continue ;
31820: GO 31667
// for j in tmp do
31822: LD_ADDR_VAR 0 3
31826: PUSH
31827: LD_VAR 0 4
31831: PUSH
31832: FOR_IN
31833: IFFALSE 31984
// begin if not mc_builders [ i ] then
31835: LD_EXP 82
31839: PUSH
31840: LD_VAR 0 2
31844: ARRAY
31845: NOT
31846: IFFALSE 31904
// begin SetTag ( j , 103 ) ;
31848: LD_VAR 0 3
31852: PPUSH
31853: LD_INT 103
31855: PPUSH
31856: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31860: LD_ADDR_EXP 82
31864: PUSH
31865: LD_EXP 82
31869: PPUSH
31870: LD_VAR 0 2
31874: PUSH
31875: LD_EXP 82
31879: PUSH
31880: LD_VAR 0 2
31884: ARRAY
31885: PUSH
31886: LD_INT 1
31888: PLUS
31889: PUSH
31890: EMPTY
31891: LIST
31892: LIST
31893: PPUSH
31894: LD_VAR 0 3
31898: PPUSH
31899: CALL 56985 0 3
31903: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31904: LD_VAR 0 3
31908: PPUSH
31909: CALL_OW 310
31913: IFFALSE 31924
// ComExitBuilding ( j ) ;
31915: LD_VAR 0 3
31919: PPUSH
31920: CALL_OW 122
// wait ( 3 ) ;
31924: LD_INT 3
31926: PPUSH
31927: CALL_OW 67
// if not mc_construct_list [ i ] then
31931: LD_EXP 83
31935: PUSH
31936: LD_VAR 0 2
31940: ARRAY
31941: NOT
31942: IFFALSE 31946
// break ;
31944: GO 31984
// if not HasTask ( j ) then
31946: LD_VAR 0 3
31950: PPUSH
31951: CALL_OW 314
31955: NOT
31956: IFFALSE 31982
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31958: LD_VAR 0 3
31962: PPUSH
31963: LD_EXP 83
31967: PUSH
31968: LD_VAR 0 2
31972: ARRAY
31973: PUSH
31974: LD_INT 1
31976: ARRAY
31977: PPUSH
31978: CALL 59846 0 2
// end ;
31982: GO 31832
31984: POP
31985: POP
// end else
31986: GO 32819
// if mc_build_list [ i ] then
31988: LD_EXP 81
31992: PUSH
31993: LD_VAR 0 2
31997: ARRAY
31998: IFFALSE 32819
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32000: LD_ADDR_VAR 0 5
32004: PUSH
32005: LD_EXP 76
32009: PUSH
32010: LD_VAR 0 2
32014: ARRAY
32015: PPUSH
32016: LD_INT 2
32018: PUSH
32019: LD_INT 30
32021: PUSH
32022: LD_INT 0
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: LD_INT 30
32031: PUSH
32032: LD_INT 1
32034: PUSH
32035: EMPTY
32036: LIST
32037: LIST
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: LIST
32043: PPUSH
32044: CALL_OW 72
32048: ST_TO_ADDR
// if depot then
32049: LD_VAR 0 5
32053: IFFALSE 32071
// depot := depot [ 1 ] else
32055: LD_ADDR_VAR 0 5
32059: PUSH
32060: LD_VAR 0 5
32064: PUSH
32065: LD_INT 1
32067: ARRAY
32068: ST_TO_ADDR
32069: GO 32079
// depot := 0 ;
32071: LD_ADDR_VAR 0 5
32075: PUSH
32076: LD_INT 0
32078: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32079: LD_EXP 81
32083: PUSH
32084: LD_VAR 0 2
32088: ARRAY
32089: PUSH
32090: LD_INT 1
32092: ARRAY
32093: PUSH
32094: LD_INT 1
32096: ARRAY
32097: PPUSH
32098: CALL 59670 0 1
32102: PUSH
32103: LD_EXP 76
32107: PUSH
32108: LD_VAR 0 2
32112: ARRAY
32113: PPUSH
32114: LD_INT 2
32116: PUSH
32117: LD_INT 30
32119: PUSH
32120: LD_INT 2
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 30
32129: PUSH
32130: LD_INT 3
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: LIST
32141: PPUSH
32142: CALL_OW 72
32146: NOT
32147: AND
32148: IFFALSE 32253
// begin for j = 1 to mc_build_list [ i ] do
32150: LD_ADDR_VAR 0 3
32154: PUSH
32155: DOUBLE
32156: LD_INT 1
32158: DEC
32159: ST_TO_ADDR
32160: LD_EXP 81
32164: PUSH
32165: LD_VAR 0 2
32169: ARRAY
32170: PUSH
32171: FOR_TO
32172: IFFALSE 32251
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32174: LD_EXP 81
32178: PUSH
32179: LD_VAR 0 2
32183: ARRAY
32184: PUSH
32185: LD_VAR 0 3
32189: ARRAY
32190: PUSH
32191: LD_INT 1
32193: ARRAY
32194: PUSH
32195: LD_INT 2
32197: EQUAL
32198: IFFALSE 32249
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32200: LD_ADDR_EXP 81
32204: PUSH
32205: LD_EXP 81
32209: PPUSH
32210: LD_VAR 0 2
32214: PPUSH
32215: LD_EXP 81
32219: PUSH
32220: LD_VAR 0 2
32224: ARRAY
32225: PPUSH
32226: LD_VAR 0 3
32230: PPUSH
32231: LD_INT 1
32233: PPUSH
32234: LD_INT 0
32236: PPUSH
32237: CALL 56403 0 4
32241: PPUSH
32242: CALL_OW 1
32246: ST_TO_ADDR
// break ;
32247: GO 32251
// end ;
32249: GO 32171
32251: POP
32252: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
32253: LD_EXP 81
32257: PUSH
32258: LD_VAR 0 2
32262: ARRAY
32263: PUSH
32264: LD_INT 1
32266: ARRAY
32267: PUSH
32268: LD_INT 1
32270: ARRAY
32271: PUSH
32272: LD_INT 0
32274: EQUAL
32275: PUSH
32276: LD_VAR 0 5
32280: PUSH
32281: LD_VAR 0 5
32285: PPUSH
32286: LD_EXP 81
32290: PUSH
32291: LD_VAR 0 2
32295: ARRAY
32296: PUSH
32297: LD_INT 1
32299: ARRAY
32300: PUSH
32301: LD_INT 1
32303: ARRAY
32304: PPUSH
32305: LD_EXP 81
32309: PUSH
32310: LD_VAR 0 2
32314: ARRAY
32315: PUSH
32316: LD_INT 1
32318: ARRAY
32319: PUSH
32320: LD_INT 2
32322: ARRAY
32323: PPUSH
32324: LD_EXP 81
32328: PUSH
32329: LD_VAR 0 2
32333: ARRAY
32334: PUSH
32335: LD_INT 1
32337: ARRAY
32338: PUSH
32339: LD_INT 3
32341: ARRAY
32342: PPUSH
32343: LD_EXP 81
32347: PUSH
32348: LD_VAR 0 2
32352: ARRAY
32353: PUSH
32354: LD_INT 1
32356: ARRAY
32357: PUSH
32358: LD_INT 4
32360: ARRAY
32361: PPUSH
32362: CALL 65082 0 5
32366: AND
32367: OR
32368: IFFALSE 32649
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32370: LD_ADDR_VAR 0 4
32374: PUSH
32375: LD_EXP 76
32379: PUSH
32380: LD_VAR 0 2
32384: ARRAY
32385: PPUSH
32386: LD_INT 25
32388: PUSH
32389: LD_INT 2
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PPUSH
32396: CALL_OW 72
32400: PUSH
32401: LD_EXP 78
32405: PUSH
32406: LD_VAR 0 2
32410: ARRAY
32411: DIFF
32412: ST_TO_ADDR
// if not tmp then
32413: LD_VAR 0 4
32417: NOT
32418: IFFALSE 32422
// continue ;
32420: GO 31667
// for j in tmp do
32422: LD_ADDR_VAR 0 3
32426: PUSH
32427: LD_VAR 0 4
32431: PUSH
32432: FOR_IN
32433: IFFALSE 32645
// begin if not mc_builders [ i ] then
32435: LD_EXP 82
32439: PUSH
32440: LD_VAR 0 2
32444: ARRAY
32445: NOT
32446: IFFALSE 32504
// begin SetTag ( j , 103 ) ;
32448: LD_VAR 0 3
32452: PPUSH
32453: LD_INT 103
32455: PPUSH
32456: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32460: LD_ADDR_EXP 82
32464: PUSH
32465: LD_EXP 82
32469: PPUSH
32470: LD_VAR 0 2
32474: PUSH
32475: LD_EXP 82
32479: PUSH
32480: LD_VAR 0 2
32484: ARRAY
32485: PUSH
32486: LD_INT 1
32488: PLUS
32489: PUSH
32490: EMPTY
32491: LIST
32492: LIST
32493: PPUSH
32494: LD_VAR 0 3
32498: PPUSH
32499: CALL 56985 0 3
32503: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32504: LD_VAR 0 3
32508: PPUSH
32509: CALL_OW 310
32513: IFFALSE 32524
// ComExitBuilding ( j ) ;
32515: LD_VAR 0 3
32519: PPUSH
32520: CALL_OW 122
// wait ( 3 ) ;
32524: LD_INT 3
32526: PPUSH
32527: CALL_OW 67
// if not mc_build_list [ i ] then
32531: LD_EXP 81
32535: PUSH
32536: LD_VAR 0 2
32540: ARRAY
32541: NOT
32542: IFFALSE 32546
// break ;
32544: GO 32645
// if not HasTask ( j ) then
32546: LD_VAR 0 3
32550: PPUSH
32551: CALL_OW 314
32555: NOT
32556: IFFALSE 32643
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32558: LD_VAR 0 3
32562: PPUSH
32563: LD_EXP 81
32567: PUSH
32568: LD_VAR 0 2
32572: ARRAY
32573: PUSH
32574: LD_INT 1
32576: ARRAY
32577: PUSH
32578: LD_INT 1
32580: ARRAY
32581: PPUSH
32582: LD_EXP 81
32586: PUSH
32587: LD_VAR 0 2
32591: ARRAY
32592: PUSH
32593: LD_INT 1
32595: ARRAY
32596: PUSH
32597: LD_INT 2
32599: ARRAY
32600: PPUSH
32601: LD_EXP 81
32605: PUSH
32606: LD_VAR 0 2
32610: ARRAY
32611: PUSH
32612: LD_INT 1
32614: ARRAY
32615: PUSH
32616: LD_INT 3
32618: ARRAY
32619: PPUSH
32620: LD_EXP 81
32624: PUSH
32625: LD_VAR 0 2
32629: ARRAY
32630: PUSH
32631: LD_INT 1
32633: ARRAY
32634: PUSH
32635: LD_INT 4
32637: ARRAY
32638: PPUSH
32639: CALL_OW 145
// end ;
32643: GO 32432
32645: POP
32646: POP
// end else
32647: GO 32819
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32649: LD_EXP 76
32653: PUSH
32654: LD_VAR 0 2
32658: ARRAY
32659: PPUSH
32660: LD_EXP 81
32664: PUSH
32665: LD_VAR 0 2
32669: ARRAY
32670: PUSH
32671: LD_INT 1
32673: ARRAY
32674: PUSH
32675: LD_INT 1
32677: ARRAY
32678: PPUSH
32679: LD_EXP 81
32683: PUSH
32684: LD_VAR 0 2
32688: ARRAY
32689: PUSH
32690: LD_INT 1
32692: ARRAY
32693: PUSH
32694: LD_INT 2
32696: ARRAY
32697: PPUSH
32698: LD_EXP 81
32702: PUSH
32703: LD_VAR 0 2
32707: ARRAY
32708: PUSH
32709: LD_INT 1
32711: ARRAY
32712: PUSH
32713: LD_INT 3
32715: ARRAY
32716: PPUSH
32717: LD_EXP 81
32721: PUSH
32722: LD_VAR 0 2
32726: ARRAY
32727: PUSH
32728: LD_INT 1
32730: ARRAY
32731: PUSH
32732: LD_INT 4
32734: ARRAY
32735: PPUSH
32736: LD_EXP 76
32740: PUSH
32741: LD_VAR 0 2
32745: ARRAY
32746: PPUSH
32747: LD_INT 21
32749: PUSH
32750: LD_INT 3
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PPUSH
32757: CALL_OW 72
32761: PPUSH
32762: EMPTY
32763: PPUSH
32764: CALL 63836 0 7
32768: NOT
32769: IFFALSE 32819
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32771: LD_ADDR_EXP 81
32775: PUSH
32776: LD_EXP 81
32780: PPUSH
32781: LD_VAR 0 2
32785: PPUSH
32786: LD_EXP 81
32790: PUSH
32791: LD_VAR 0 2
32795: ARRAY
32796: PPUSH
32797: LD_INT 1
32799: PPUSH
32800: LD_INT 1
32802: NEG
32803: PPUSH
32804: LD_INT 0
32806: PPUSH
32807: CALL 56403 0 4
32811: PPUSH
32812: CALL_OW 1
32816: ST_TO_ADDR
// continue ;
32817: GO 31667
// end ; end ; end ;
32819: GO 31667
32821: POP
32822: POP
// end ;
32823: LD_VAR 0 1
32827: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32828: LD_INT 0
32830: PPUSH
32831: PPUSH
32832: PPUSH
32833: PPUSH
32834: PPUSH
32835: PPUSH
// if not mc_bases then
32836: LD_EXP 76
32840: NOT
32841: IFFALSE 32845
// exit ;
32843: GO 33272
// for i = 1 to mc_bases do
32845: LD_ADDR_VAR 0 2
32849: PUSH
32850: DOUBLE
32851: LD_INT 1
32853: DEC
32854: ST_TO_ADDR
32855: LD_EXP 76
32859: PUSH
32860: FOR_TO
32861: IFFALSE 33270
// begin tmp := mc_build_upgrade [ i ] ;
32863: LD_ADDR_VAR 0 4
32867: PUSH
32868: LD_EXP 108
32872: PUSH
32873: LD_VAR 0 2
32877: ARRAY
32878: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32879: LD_ADDR_VAR 0 6
32883: PUSH
32884: LD_EXP 109
32888: PUSH
32889: LD_VAR 0 2
32893: ARRAY
32894: PPUSH
32895: LD_INT 2
32897: PUSH
32898: LD_INT 30
32900: PUSH
32901: LD_INT 6
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 30
32910: PUSH
32911: LD_INT 7
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: LIST
32922: PPUSH
32923: CALL_OW 72
32927: ST_TO_ADDR
// if not tmp and not lab then
32928: LD_VAR 0 4
32932: NOT
32933: PUSH
32934: LD_VAR 0 6
32938: NOT
32939: AND
32940: IFFALSE 32944
// continue ;
32942: GO 32860
// if tmp then
32944: LD_VAR 0 4
32948: IFFALSE 33068
// for j in tmp do
32950: LD_ADDR_VAR 0 3
32954: PUSH
32955: LD_VAR 0 4
32959: PUSH
32960: FOR_IN
32961: IFFALSE 33066
// begin if UpgradeCost ( j ) then
32963: LD_VAR 0 3
32967: PPUSH
32968: CALL 63496 0 1
32972: IFFALSE 33064
// begin ComUpgrade ( j ) ;
32974: LD_VAR 0 3
32978: PPUSH
32979: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32983: LD_ADDR_EXP 108
32987: PUSH
32988: LD_EXP 108
32992: PPUSH
32993: LD_VAR 0 2
32997: PPUSH
32998: LD_EXP 108
33002: PUSH
33003: LD_VAR 0 2
33007: ARRAY
33008: PUSH
33009: LD_VAR 0 3
33013: DIFF
33014: PPUSH
33015: CALL_OW 1
33019: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33020: LD_ADDR_EXP 83
33024: PUSH
33025: LD_EXP 83
33029: PPUSH
33030: LD_VAR 0 2
33034: PUSH
33035: LD_EXP 83
33039: PUSH
33040: LD_VAR 0 2
33044: ARRAY
33045: PUSH
33046: LD_INT 1
33048: PLUS
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PPUSH
33054: LD_VAR 0 3
33058: PPUSH
33059: CALL 56985 0 3
33063: ST_TO_ADDR
// end ; end ;
33064: GO 32960
33066: POP
33067: POP
// if not lab or not mc_lab_upgrade [ i ] then
33068: LD_VAR 0 6
33072: NOT
33073: PUSH
33074: LD_EXP 110
33078: PUSH
33079: LD_VAR 0 2
33083: ARRAY
33084: NOT
33085: OR
33086: IFFALSE 33090
// continue ;
33088: GO 32860
// for j in lab do
33090: LD_ADDR_VAR 0 3
33094: PUSH
33095: LD_VAR 0 6
33099: PUSH
33100: FOR_IN
33101: IFFALSE 33266
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33103: LD_VAR 0 3
33107: PPUSH
33108: CALL_OW 266
33112: PUSH
33113: LD_INT 6
33115: PUSH
33116: LD_INT 7
33118: PUSH
33119: EMPTY
33120: LIST
33121: LIST
33122: IN
33123: PUSH
33124: LD_VAR 0 3
33128: PPUSH
33129: CALL_OW 461
33133: PUSH
33134: LD_INT 1
33136: NONEQUAL
33137: AND
33138: IFFALSE 33264
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33140: LD_VAR 0 3
33144: PPUSH
33145: LD_EXP 110
33149: PUSH
33150: LD_VAR 0 2
33154: ARRAY
33155: PUSH
33156: LD_INT 1
33158: ARRAY
33159: PPUSH
33160: CALL 63701 0 2
33164: IFFALSE 33264
// begin ComCancel ( j ) ;
33166: LD_VAR 0 3
33170: PPUSH
33171: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33175: LD_VAR 0 3
33179: PPUSH
33180: LD_EXP 110
33184: PUSH
33185: LD_VAR 0 2
33189: ARRAY
33190: PUSH
33191: LD_INT 1
33193: ARRAY
33194: PPUSH
33195: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33199: LD_VAR 0 3
33203: PUSH
33204: LD_EXP 83
33208: PUSH
33209: LD_VAR 0 2
33213: ARRAY
33214: IN
33215: NOT
33216: IFFALSE 33262
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33218: LD_ADDR_EXP 83
33222: PUSH
33223: LD_EXP 83
33227: PPUSH
33228: LD_VAR 0 2
33232: PUSH
33233: LD_EXP 83
33237: PUSH
33238: LD_VAR 0 2
33242: ARRAY
33243: PUSH
33244: LD_INT 1
33246: PLUS
33247: PUSH
33248: EMPTY
33249: LIST
33250: LIST
33251: PPUSH
33252: LD_VAR 0 3
33256: PPUSH
33257: CALL 56985 0 3
33261: ST_TO_ADDR
// break ;
33262: GO 33266
// end ; end ; end ;
33264: GO 33100
33266: POP
33267: POP
// end ;
33268: GO 32860
33270: POP
33271: POP
// end ;
33272: LD_VAR 0 1
33276: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33277: LD_INT 0
33279: PPUSH
33280: PPUSH
33281: PPUSH
33282: PPUSH
33283: PPUSH
33284: PPUSH
33285: PPUSH
33286: PPUSH
33287: PPUSH
// if not mc_bases then
33288: LD_EXP 76
33292: NOT
33293: IFFALSE 33297
// exit ;
33295: GO 33702
// for i = 1 to mc_bases do
33297: LD_ADDR_VAR 0 2
33301: PUSH
33302: DOUBLE
33303: LD_INT 1
33305: DEC
33306: ST_TO_ADDR
33307: LD_EXP 76
33311: PUSH
33312: FOR_TO
33313: IFFALSE 33700
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33315: LD_EXP 84
33319: PUSH
33320: LD_VAR 0 2
33324: ARRAY
33325: NOT
33326: PUSH
33327: LD_EXP 76
33331: PUSH
33332: LD_VAR 0 2
33336: ARRAY
33337: PPUSH
33338: LD_INT 30
33340: PUSH
33341: LD_INT 3
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PPUSH
33348: CALL_OW 72
33352: NOT
33353: OR
33354: IFFALSE 33358
// continue ;
33356: GO 33312
// busy := false ;
33358: LD_ADDR_VAR 0 8
33362: PUSH
33363: LD_INT 0
33365: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33366: LD_ADDR_VAR 0 4
33370: PUSH
33371: LD_EXP 76
33375: PUSH
33376: LD_VAR 0 2
33380: ARRAY
33381: PPUSH
33382: LD_INT 30
33384: PUSH
33385: LD_INT 3
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PPUSH
33392: CALL_OW 72
33396: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33397: LD_ADDR_VAR 0 6
33401: PUSH
33402: LD_EXP 84
33406: PUSH
33407: LD_VAR 0 2
33411: ARRAY
33412: PPUSH
33413: LD_INT 2
33415: PUSH
33416: LD_INT 30
33418: PUSH
33419: LD_INT 32
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 30
33428: PUSH
33429: LD_INT 33
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: LIST
33440: PPUSH
33441: CALL_OW 72
33445: ST_TO_ADDR
// if not t then
33446: LD_VAR 0 6
33450: NOT
33451: IFFALSE 33455
// continue ;
33453: GO 33312
// for j in tmp do
33455: LD_ADDR_VAR 0 3
33459: PUSH
33460: LD_VAR 0 4
33464: PUSH
33465: FOR_IN
33466: IFFALSE 33496
// if not BuildingStatus ( j ) = bs_idle then
33468: LD_VAR 0 3
33472: PPUSH
33473: CALL_OW 461
33477: PUSH
33478: LD_INT 2
33480: EQUAL
33481: NOT
33482: IFFALSE 33494
// begin busy := true ;
33484: LD_ADDR_VAR 0 8
33488: PUSH
33489: LD_INT 1
33491: ST_TO_ADDR
// break ;
33492: GO 33496
// end ;
33494: GO 33465
33496: POP
33497: POP
// if busy then
33498: LD_VAR 0 8
33502: IFFALSE 33506
// continue ;
33504: GO 33312
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33506: LD_ADDR_VAR 0 7
33510: PUSH
33511: LD_VAR 0 6
33515: PPUSH
33516: LD_INT 35
33518: PUSH
33519: LD_INT 0
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PPUSH
33526: CALL_OW 72
33530: ST_TO_ADDR
// if tw then
33531: LD_VAR 0 7
33535: IFFALSE 33612
// begin tw := tw [ 1 ] ;
33537: LD_ADDR_VAR 0 7
33541: PUSH
33542: LD_VAR 0 7
33546: PUSH
33547: LD_INT 1
33549: ARRAY
33550: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33551: LD_ADDR_VAR 0 9
33555: PUSH
33556: LD_VAR 0 7
33560: PPUSH
33561: LD_EXP 101
33565: PUSH
33566: LD_VAR 0 2
33570: ARRAY
33571: PPUSH
33572: CALL 61993 0 2
33576: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33577: LD_EXP 115
33581: PUSH
33582: LD_VAR 0 2
33586: ARRAY
33587: IFFALSE 33610
// if not weapon in mc_allowed_tower_weapons [ i ] then
33589: LD_VAR 0 9
33593: PUSH
33594: LD_EXP 115
33598: PUSH
33599: LD_VAR 0 2
33603: ARRAY
33604: IN
33605: NOT
33606: IFFALSE 33610
// continue ;
33608: GO 33312
// end else
33610: GO 33675
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33612: LD_ADDR_VAR 0 5
33616: PUSH
33617: LD_EXP 84
33621: PUSH
33622: LD_VAR 0 2
33626: ARRAY
33627: PPUSH
33628: LD_VAR 0 4
33632: PPUSH
33633: CALL 88772 0 2
33637: ST_TO_ADDR
// if not tmp2 then
33638: LD_VAR 0 5
33642: NOT
33643: IFFALSE 33647
// continue ;
33645: GO 33312
// tw := tmp2 [ 1 ] ;
33647: LD_ADDR_VAR 0 7
33651: PUSH
33652: LD_VAR 0 5
33656: PUSH
33657: LD_INT 1
33659: ARRAY
33660: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33661: LD_ADDR_VAR 0 9
33665: PUSH
33666: LD_VAR 0 5
33670: PUSH
33671: LD_INT 2
33673: ARRAY
33674: ST_TO_ADDR
// end ; if not weapon then
33675: LD_VAR 0 9
33679: NOT
33680: IFFALSE 33684
// continue ;
33682: GO 33312
// ComPlaceWeapon ( tw , weapon ) ;
33684: LD_VAR 0 7
33688: PPUSH
33689: LD_VAR 0 9
33693: PPUSH
33694: CALL_OW 148
// end ;
33698: GO 33312
33700: POP
33701: POP
// end ;
33702: LD_VAR 0 1
33706: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33707: LD_INT 0
33709: PPUSH
33710: PPUSH
33711: PPUSH
33712: PPUSH
33713: PPUSH
33714: PPUSH
33715: PPUSH
// if not mc_bases then
33716: LD_EXP 76
33720: NOT
33721: IFFALSE 33725
// exit ;
33723: GO 34493
// for i = 1 to mc_bases do
33725: LD_ADDR_VAR 0 2
33729: PUSH
33730: DOUBLE
33731: LD_INT 1
33733: DEC
33734: ST_TO_ADDR
33735: LD_EXP 76
33739: PUSH
33740: FOR_TO
33741: IFFALSE 34491
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33743: LD_EXP 89
33747: PUSH
33748: LD_VAR 0 2
33752: ARRAY
33753: NOT
33754: PUSH
33755: LD_EXP 89
33759: PUSH
33760: LD_VAR 0 2
33764: ARRAY
33765: PUSH
33766: LD_EXP 90
33770: PUSH
33771: LD_VAR 0 2
33775: ARRAY
33776: EQUAL
33777: OR
33778: PUSH
33779: LD_EXP 99
33783: PUSH
33784: LD_VAR 0 2
33788: ARRAY
33789: OR
33790: IFFALSE 33794
// continue ;
33792: GO 33740
// if mc_miners [ i ] then
33794: LD_EXP 90
33798: PUSH
33799: LD_VAR 0 2
33803: ARRAY
33804: IFFALSE 34178
// begin for j = mc_miners [ i ] downto 1 do
33806: LD_ADDR_VAR 0 3
33810: PUSH
33811: DOUBLE
33812: LD_EXP 90
33816: PUSH
33817: LD_VAR 0 2
33821: ARRAY
33822: INC
33823: ST_TO_ADDR
33824: LD_INT 1
33826: PUSH
33827: FOR_DOWNTO
33828: IFFALSE 34176
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33830: LD_EXP 90
33834: PUSH
33835: LD_VAR 0 2
33839: ARRAY
33840: PUSH
33841: LD_VAR 0 3
33845: ARRAY
33846: PPUSH
33847: CALL_OW 301
33851: PUSH
33852: LD_EXP 90
33856: PUSH
33857: LD_VAR 0 2
33861: ARRAY
33862: PUSH
33863: LD_VAR 0 3
33867: ARRAY
33868: PPUSH
33869: CALL_OW 257
33873: PUSH
33874: LD_INT 1
33876: NONEQUAL
33877: OR
33878: IFFALSE 33941
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33880: LD_ADDR_VAR 0 5
33884: PUSH
33885: LD_EXP 90
33889: PUSH
33890: LD_VAR 0 2
33894: ARRAY
33895: PUSH
33896: LD_EXP 90
33900: PUSH
33901: LD_VAR 0 2
33905: ARRAY
33906: PUSH
33907: LD_VAR 0 3
33911: ARRAY
33912: DIFF
33913: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33914: LD_ADDR_EXP 90
33918: PUSH
33919: LD_EXP 90
33923: PPUSH
33924: LD_VAR 0 2
33928: PPUSH
33929: LD_VAR 0 5
33933: PPUSH
33934: CALL_OW 1
33938: ST_TO_ADDR
// continue ;
33939: GO 33827
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33941: LD_EXP 90
33945: PUSH
33946: LD_VAR 0 2
33950: ARRAY
33951: PUSH
33952: LD_VAR 0 3
33956: ARRAY
33957: PPUSH
33958: CALL_OW 257
33962: PUSH
33963: LD_INT 1
33965: EQUAL
33966: PUSH
33967: LD_EXP 90
33971: PUSH
33972: LD_VAR 0 2
33976: ARRAY
33977: PUSH
33978: LD_VAR 0 3
33982: ARRAY
33983: PPUSH
33984: CALL_OW 459
33988: NOT
33989: AND
33990: PUSH
33991: LD_EXP 90
33995: PUSH
33996: LD_VAR 0 2
34000: ARRAY
34001: PUSH
34002: LD_VAR 0 3
34006: ARRAY
34007: PPUSH
34008: CALL_OW 314
34012: NOT
34013: AND
34014: IFFALSE 34174
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34016: LD_EXP 90
34020: PUSH
34021: LD_VAR 0 2
34025: ARRAY
34026: PUSH
34027: LD_VAR 0 3
34031: ARRAY
34032: PPUSH
34033: CALL_OW 310
34037: IFFALSE 34060
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34039: LD_EXP 90
34043: PUSH
34044: LD_VAR 0 2
34048: ARRAY
34049: PUSH
34050: LD_VAR 0 3
34054: ARRAY
34055: PPUSH
34056: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34060: LD_EXP 90
34064: PUSH
34065: LD_VAR 0 2
34069: ARRAY
34070: PUSH
34071: LD_VAR 0 3
34075: ARRAY
34076: PPUSH
34077: CALL_OW 314
34081: NOT
34082: IFFALSE 34174
// begin r := rand ( 1 , mc_mines [ i ] ) ;
34084: LD_ADDR_VAR 0 7
34088: PUSH
34089: LD_INT 1
34091: PPUSH
34092: LD_EXP 89
34096: PUSH
34097: LD_VAR 0 2
34101: ARRAY
34102: PPUSH
34103: CALL_OW 12
34107: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34108: LD_EXP 90
34112: PUSH
34113: LD_VAR 0 2
34117: ARRAY
34118: PUSH
34119: LD_VAR 0 3
34123: ARRAY
34124: PPUSH
34125: LD_EXP 89
34129: PUSH
34130: LD_VAR 0 2
34134: ARRAY
34135: PUSH
34136: LD_VAR 0 7
34140: ARRAY
34141: PUSH
34142: LD_INT 1
34144: ARRAY
34145: PPUSH
34146: LD_EXP 89
34150: PUSH
34151: LD_VAR 0 2
34155: ARRAY
34156: PUSH
34157: LD_VAR 0 7
34161: ARRAY
34162: PUSH
34163: LD_INT 2
34165: ARRAY
34166: PPUSH
34167: LD_INT 0
34169: PPUSH
34170: CALL_OW 193
// end ; end ; end ;
34174: GO 33827
34176: POP
34177: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34178: LD_ADDR_VAR 0 5
34182: PUSH
34183: LD_EXP 76
34187: PUSH
34188: LD_VAR 0 2
34192: ARRAY
34193: PPUSH
34194: LD_INT 2
34196: PUSH
34197: LD_INT 30
34199: PUSH
34200: LD_INT 4
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 30
34209: PUSH
34210: LD_INT 5
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 30
34219: PUSH
34220: LD_INT 32
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: EMPTY
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: PPUSH
34233: CALL_OW 72
34237: ST_TO_ADDR
// if not tmp then
34238: LD_VAR 0 5
34242: NOT
34243: IFFALSE 34247
// continue ;
34245: GO 33740
// list := [ ] ;
34247: LD_ADDR_VAR 0 6
34251: PUSH
34252: EMPTY
34253: ST_TO_ADDR
// for j in tmp do
34254: LD_ADDR_VAR 0 3
34258: PUSH
34259: LD_VAR 0 5
34263: PUSH
34264: FOR_IN
34265: IFFALSE 34334
// begin for k in UnitsInside ( j ) do
34267: LD_ADDR_VAR 0 4
34271: PUSH
34272: LD_VAR 0 3
34276: PPUSH
34277: CALL_OW 313
34281: PUSH
34282: FOR_IN
34283: IFFALSE 34330
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34285: LD_VAR 0 4
34289: PPUSH
34290: CALL_OW 257
34294: PUSH
34295: LD_INT 1
34297: EQUAL
34298: PUSH
34299: LD_VAR 0 4
34303: PPUSH
34304: CALL_OW 459
34308: NOT
34309: AND
34310: IFFALSE 34328
// list := list ^ k ;
34312: LD_ADDR_VAR 0 6
34316: PUSH
34317: LD_VAR 0 6
34321: PUSH
34322: LD_VAR 0 4
34326: ADD
34327: ST_TO_ADDR
34328: GO 34282
34330: POP
34331: POP
// end ;
34332: GO 34264
34334: POP
34335: POP
// list := list diff mc_miners [ i ] ;
34336: LD_ADDR_VAR 0 6
34340: PUSH
34341: LD_VAR 0 6
34345: PUSH
34346: LD_EXP 90
34350: PUSH
34351: LD_VAR 0 2
34355: ARRAY
34356: DIFF
34357: ST_TO_ADDR
// if not list then
34358: LD_VAR 0 6
34362: NOT
34363: IFFALSE 34367
// continue ;
34365: GO 33740
// k := mc_mines [ i ] - mc_miners [ i ] ;
34367: LD_ADDR_VAR 0 4
34371: PUSH
34372: LD_EXP 89
34376: PUSH
34377: LD_VAR 0 2
34381: ARRAY
34382: PUSH
34383: LD_EXP 90
34387: PUSH
34388: LD_VAR 0 2
34392: ARRAY
34393: MINUS
34394: ST_TO_ADDR
// if k > list then
34395: LD_VAR 0 4
34399: PUSH
34400: LD_VAR 0 6
34404: GREATER
34405: IFFALSE 34417
// k := list ;
34407: LD_ADDR_VAR 0 4
34411: PUSH
34412: LD_VAR 0 6
34416: ST_TO_ADDR
// for j = 1 to k do
34417: LD_ADDR_VAR 0 3
34421: PUSH
34422: DOUBLE
34423: LD_INT 1
34425: DEC
34426: ST_TO_ADDR
34427: LD_VAR 0 4
34431: PUSH
34432: FOR_TO
34433: IFFALSE 34487
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34435: LD_ADDR_EXP 90
34439: PUSH
34440: LD_EXP 90
34444: PPUSH
34445: LD_VAR 0 2
34449: PUSH
34450: LD_EXP 90
34454: PUSH
34455: LD_VAR 0 2
34459: ARRAY
34460: PUSH
34461: LD_INT 1
34463: PLUS
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PPUSH
34469: LD_VAR 0 6
34473: PUSH
34474: LD_VAR 0 3
34478: ARRAY
34479: PPUSH
34480: CALL 56985 0 3
34484: ST_TO_ADDR
34485: GO 34432
34487: POP
34488: POP
// end ;
34489: GO 33740
34491: POP
34492: POP
// end ;
34493: LD_VAR 0 1
34497: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34498: LD_INT 0
34500: PPUSH
34501: PPUSH
34502: PPUSH
34503: PPUSH
34504: PPUSH
34505: PPUSH
34506: PPUSH
34507: PPUSH
34508: PPUSH
34509: PPUSH
34510: PPUSH
// if not mc_bases then
34511: LD_EXP 76
34515: NOT
34516: IFFALSE 34520
// exit ;
34518: GO 36343
// for i = 1 to mc_bases do
34520: LD_ADDR_VAR 0 2
34524: PUSH
34525: DOUBLE
34526: LD_INT 1
34528: DEC
34529: ST_TO_ADDR
34530: LD_EXP 76
34534: PUSH
34535: FOR_TO
34536: IFFALSE 36341
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34538: LD_EXP 76
34542: PUSH
34543: LD_VAR 0 2
34547: ARRAY
34548: NOT
34549: PUSH
34550: LD_EXP 83
34554: PUSH
34555: LD_VAR 0 2
34559: ARRAY
34560: OR
34561: IFFALSE 34565
// continue ;
34563: GO 34535
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34565: LD_EXP 92
34569: PUSH
34570: LD_VAR 0 2
34574: ARRAY
34575: NOT
34576: PUSH
34577: LD_EXP 93
34581: PUSH
34582: LD_VAR 0 2
34586: ARRAY
34587: AND
34588: IFFALSE 34626
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34590: LD_ADDR_EXP 93
34594: PUSH
34595: LD_EXP 93
34599: PPUSH
34600: LD_VAR 0 2
34604: PPUSH
34605: EMPTY
34606: PPUSH
34607: CALL_OW 1
34611: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34612: LD_VAR 0 2
34616: PPUSH
34617: LD_INT 107
34619: PPUSH
34620: CALL 25398 0 2
// continue ;
34624: GO 34535
// end ; target := [ ] ;
34626: LD_ADDR_VAR 0 7
34630: PUSH
34631: EMPTY
34632: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34633: LD_ADDR_VAR 0 6
34637: PUSH
34638: LD_EXP 76
34642: PUSH
34643: LD_VAR 0 2
34647: ARRAY
34648: PUSH
34649: LD_INT 1
34651: ARRAY
34652: PPUSH
34653: CALL_OW 255
34657: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34658: LD_ADDR_VAR 0 9
34662: PUSH
34663: LD_EXP 76
34667: PUSH
34668: LD_VAR 0 2
34672: ARRAY
34673: PPUSH
34674: LD_INT 2
34676: PUSH
34677: LD_INT 30
34679: PUSH
34680: LD_INT 0
34682: PUSH
34683: EMPTY
34684: LIST
34685: LIST
34686: PUSH
34687: LD_INT 30
34689: PUSH
34690: LD_INT 1
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: EMPTY
34698: LIST
34699: LIST
34700: LIST
34701: PPUSH
34702: CALL_OW 72
34706: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34707: LD_ADDR_VAR 0 3
34711: PUSH
34712: DOUBLE
34713: LD_EXP 92
34717: PUSH
34718: LD_VAR 0 2
34722: ARRAY
34723: INC
34724: ST_TO_ADDR
34725: LD_INT 1
34727: PUSH
34728: FOR_DOWNTO
34729: IFFALSE 34974
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34731: LD_EXP 92
34735: PUSH
34736: LD_VAR 0 2
34740: ARRAY
34741: PUSH
34742: LD_VAR 0 3
34746: ARRAY
34747: PUSH
34748: LD_INT 2
34750: ARRAY
34751: PPUSH
34752: LD_EXP 92
34756: PUSH
34757: LD_VAR 0 2
34761: ARRAY
34762: PUSH
34763: LD_VAR 0 3
34767: ARRAY
34768: PUSH
34769: LD_INT 3
34771: ARRAY
34772: PPUSH
34773: CALL_OW 488
34777: PUSH
34778: LD_EXP 92
34782: PUSH
34783: LD_VAR 0 2
34787: ARRAY
34788: PUSH
34789: LD_VAR 0 3
34793: ARRAY
34794: PUSH
34795: LD_INT 2
34797: ARRAY
34798: PPUSH
34799: LD_EXP 92
34803: PUSH
34804: LD_VAR 0 2
34808: ARRAY
34809: PUSH
34810: LD_VAR 0 3
34814: ARRAY
34815: PUSH
34816: LD_INT 3
34818: ARRAY
34819: PPUSH
34820: CALL_OW 284
34824: PUSH
34825: LD_INT 0
34827: EQUAL
34828: AND
34829: IFFALSE 34884
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34831: LD_ADDR_VAR 0 5
34835: PUSH
34836: LD_EXP 92
34840: PUSH
34841: LD_VAR 0 2
34845: ARRAY
34846: PPUSH
34847: LD_VAR 0 3
34851: PPUSH
34852: CALL_OW 3
34856: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34857: LD_ADDR_EXP 92
34861: PUSH
34862: LD_EXP 92
34866: PPUSH
34867: LD_VAR 0 2
34871: PPUSH
34872: LD_VAR 0 5
34876: PPUSH
34877: CALL_OW 1
34881: ST_TO_ADDR
// continue ;
34882: GO 34728
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34884: LD_VAR 0 6
34888: PPUSH
34889: LD_EXP 92
34893: PUSH
34894: LD_VAR 0 2
34898: ARRAY
34899: PUSH
34900: LD_VAR 0 3
34904: ARRAY
34905: PUSH
34906: LD_INT 2
34908: ARRAY
34909: PPUSH
34910: LD_EXP 92
34914: PUSH
34915: LD_VAR 0 2
34919: ARRAY
34920: PUSH
34921: LD_VAR 0 3
34925: ARRAY
34926: PUSH
34927: LD_INT 3
34929: ARRAY
34930: PPUSH
34931: LD_INT 30
34933: PPUSH
34934: CALL 57881 0 4
34938: PUSH
34939: LD_INT 4
34941: ARRAY
34942: PUSH
34943: LD_INT 0
34945: EQUAL
34946: IFFALSE 34972
// begin target := mc_crates [ i ] [ j ] ;
34948: LD_ADDR_VAR 0 7
34952: PUSH
34953: LD_EXP 92
34957: PUSH
34958: LD_VAR 0 2
34962: ARRAY
34963: PUSH
34964: LD_VAR 0 3
34968: ARRAY
34969: ST_TO_ADDR
// break ;
34970: GO 34974
// end ; end ;
34972: GO 34728
34974: POP
34975: POP
// if not target then
34976: LD_VAR 0 7
34980: NOT
34981: IFFALSE 34985
// continue ;
34983: GO 34535
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34985: LD_ADDR_VAR 0 8
34989: PUSH
34990: LD_EXP 95
34994: PUSH
34995: LD_VAR 0 2
34999: ARRAY
35000: PPUSH
35001: LD_INT 2
35003: PUSH
35004: LD_INT 3
35006: PUSH
35007: LD_INT 58
35009: PUSH
35010: EMPTY
35011: LIST
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 61
35019: PUSH
35020: EMPTY
35021: LIST
35022: PUSH
35023: LD_INT 33
35025: PUSH
35026: LD_INT 5
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 33
35035: PUSH
35036: LD_INT 3
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: PUSH
35050: LD_INT 2
35052: PUSH
35053: LD_INT 34
35055: PUSH
35056: LD_INT 32
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 34
35065: PUSH
35066: LD_INT 51
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 34
35075: PUSH
35076: LD_INT 12
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: PUSH
35089: EMPTY
35090: LIST
35091: LIST
35092: PPUSH
35093: CALL_OW 72
35097: ST_TO_ADDR
// if not cargo then
35098: LD_VAR 0 8
35102: NOT
35103: IFFALSE 35809
// begin if mc_crates_collector [ i ] < 5 then
35105: LD_EXP 93
35109: PUSH
35110: LD_VAR 0 2
35114: ARRAY
35115: PUSH
35116: LD_INT 5
35118: LESS
35119: IFFALSE 35485
// begin if mc_ape [ i ] then
35121: LD_EXP 105
35125: PUSH
35126: LD_VAR 0 2
35130: ARRAY
35131: IFFALSE 35178
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35133: LD_ADDR_VAR 0 5
35137: PUSH
35138: LD_EXP 105
35142: PUSH
35143: LD_VAR 0 2
35147: ARRAY
35148: PPUSH
35149: LD_INT 25
35151: PUSH
35152: LD_INT 16
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 24
35161: PUSH
35162: LD_INT 750
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PPUSH
35173: CALL_OW 72
35177: ST_TO_ADDR
// if not tmp then
35178: LD_VAR 0 5
35182: NOT
35183: IFFALSE 35230
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35185: LD_ADDR_VAR 0 5
35189: PUSH
35190: LD_EXP 76
35194: PUSH
35195: LD_VAR 0 2
35199: ARRAY
35200: PPUSH
35201: LD_INT 25
35203: PUSH
35204: LD_INT 2
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 24
35213: PUSH
35214: LD_INT 750
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PPUSH
35225: CALL_OW 72
35229: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35230: LD_EXP 105
35234: PUSH
35235: LD_VAR 0 2
35239: ARRAY
35240: PUSH
35241: LD_EXP 76
35245: PUSH
35246: LD_VAR 0 2
35250: ARRAY
35251: PPUSH
35252: LD_INT 25
35254: PUSH
35255: LD_INT 2
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 24
35264: PUSH
35265: LD_INT 750
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PPUSH
35276: CALL_OW 72
35280: AND
35281: PUSH
35282: LD_VAR 0 5
35286: PUSH
35287: LD_INT 5
35289: LESS
35290: AND
35291: IFFALSE 35373
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35293: LD_ADDR_VAR 0 3
35297: PUSH
35298: LD_EXP 76
35302: PUSH
35303: LD_VAR 0 2
35307: ARRAY
35308: PPUSH
35309: LD_INT 25
35311: PUSH
35312: LD_INT 2
35314: PUSH
35315: EMPTY
35316: LIST
35317: LIST
35318: PUSH
35319: LD_INT 24
35321: PUSH
35322: LD_INT 750
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PPUSH
35333: CALL_OW 72
35337: PUSH
35338: FOR_IN
35339: IFFALSE 35371
// begin tmp := tmp union j ;
35341: LD_ADDR_VAR 0 5
35345: PUSH
35346: LD_VAR 0 5
35350: PUSH
35351: LD_VAR 0 3
35355: UNION
35356: ST_TO_ADDR
// if tmp >= 5 then
35357: LD_VAR 0 5
35361: PUSH
35362: LD_INT 5
35364: GREATEREQUAL
35365: IFFALSE 35369
// break ;
35367: GO 35371
// end ;
35369: GO 35338
35371: POP
35372: POP
// end ; if not tmp then
35373: LD_VAR 0 5
35377: NOT
35378: IFFALSE 35382
// continue ;
35380: GO 34535
// for j in tmp do
35382: LD_ADDR_VAR 0 3
35386: PUSH
35387: LD_VAR 0 5
35391: PUSH
35392: FOR_IN
35393: IFFALSE 35483
// if not GetTag ( j ) then
35395: LD_VAR 0 3
35399: PPUSH
35400: CALL_OW 110
35404: NOT
35405: IFFALSE 35481
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35407: LD_ADDR_EXP 93
35411: PUSH
35412: LD_EXP 93
35416: PPUSH
35417: LD_VAR 0 2
35421: PUSH
35422: LD_EXP 93
35426: PUSH
35427: LD_VAR 0 2
35431: ARRAY
35432: PUSH
35433: LD_INT 1
35435: PLUS
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PPUSH
35441: LD_VAR 0 3
35445: PPUSH
35446: CALL 56985 0 3
35450: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35451: LD_VAR 0 3
35455: PPUSH
35456: LD_INT 107
35458: PPUSH
35459: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35463: LD_EXP 93
35467: PUSH
35468: LD_VAR 0 2
35472: ARRAY
35473: PUSH
35474: LD_INT 5
35476: GREATEREQUAL
35477: IFFALSE 35481
// break ;
35479: GO 35483
// end ;
35481: GO 35392
35483: POP
35484: POP
// end ; if mc_crates_collector [ i ] and target then
35485: LD_EXP 93
35489: PUSH
35490: LD_VAR 0 2
35494: ARRAY
35495: PUSH
35496: LD_VAR 0 7
35500: AND
35501: IFFALSE 35807
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35503: LD_EXP 93
35507: PUSH
35508: LD_VAR 0 2
35512: ARRAY
35513: PUSH
35514: LD_VAR 0 7
35518: PUSH
35519: LD_INT 1
35521: ARRAY
35522: LESS
35523: IFFALSE 35543
// tmp := mc_crates_collector [ i ] else
35525: LD_ADDR_VAR 0 5
35529: PUSH
35530: LD_EXP 93
35534: PUSH
35535: LD_VAR 0 2
35539: ARRAY
35540: ST_TO_ADDR
35541: GO 35557
// tmp := target [ 1 ] ;
35543: LD_ADDR_VAR 0 5
35547: PUSH
35548: LD_VAR 0 7
35552: PUSH
35553: LD_INT 1
35555: ARRAY
35556: ST_TO_ADDR
// k := 0 ;
35557: LD_ADDR_VAR 0 4
35561: PUSH
35562: LD_INT 0
35564: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35565: LD_ADDR_VAR 0 3
35569: PUSH
35570: LD_EXP 93
35574: PUSH
35575: LD_VAR 0 2
35579: ARRAY
35580: PUSH
35581: FOR_IN
35582: IFFALSE 35805
// begin k := k + 1 ;
35584: LD_ADDR_VAR 0 4
35588: PUSH
35589: LD_VAR 0 4
35593: PUSH
35594: LD_INT 1
35596: PLUS
35597: ST_TO_ADDR
// if k > tmp then
35598: LD_VAR 0 4
35602: PUSH
35603: LD_VAR 0 5
35607: GREATER
35608: IFFALSE 35612
// break ;
35610: GO 35805
// if not GetClass ( j ) in [ 2 , 16 ] then
35612: LD_VAR 0 3
35616: PPUSH
35617: CALL_OW 257
35621: PUSH
35622: LD_INT 2
35624: PUSH
35625: LD_INT 16
35627: PUSH
35628: EMPTY
35629: LIST
35630: LIST
35631: IN
35632: NOT
35633: IFFALSE 35686
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35635: LD_ADDR_EXP 93
35639: PUSH
35640: LD_EXP 93
35644: PPUSH
35645: LD_VAR 0 2
35649: PPUSH
35650: LD_EXP 93
35654: PUSH
35655: LD_VAR 0 2
35659: ARRAY
35660: PUSH
35661: LD_VAR 0 3
35665: DIFF
35666: PPUSH
35667: CALL_OW 1
35671: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35672: LD_VAR 0 3
35676: PPUSH
35677: LD_INT 0
35679: PPUSH
35680: CALL_OW 109
// continue ;
35684: GO 35581
// end ; if IsInUnit ( j ) then
35686: LD_VAR 0 3
35690: PPUSH
35691: CALL_OW 310
35695: IFFALSE 35706
// ComExitBuilding ( j ) ;
35697: LD_VAR 0 3
35701: PPUSH
35702: CALL_OW 122
// wait ( 3 ) ;
35706: LD_INT 3
35708: PPUSH
35709: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35713: LD_VAR 0 3
35717: PPUSH
35718: CALL_OW 314
35722: PUSH
35723: LD_VAR 0 6
35727: PPUSH
35728: LD_VAR 0 7
35732: PUSH
35733: LD_INT 2
35735: ARRAY
35736: PPUSH
35737: LD_VAR 0 7
35741: PUSH
35742: LD_INT 3
35744: ARRAY
35745: PPUSH
35746: LD_INT 30
35748: PPUSH
35749: CALL 57881 0 4
35753: PUSH
35754: LD_INT 4
35756: ARRAY
35757: AND
35758: IFFALSE 35776
// ComStandNearbyBuilding ( j , depot ) else
35760: LD_VAR 0 3
35764: PPUSH
35765: LD_VAR 0 9
35769: PPUSH
35770: CALL 53412 0 2
35774: GO 35803
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35776: LD_VAR 0 3
35780: PPUSH
35781: LD_VAR 0 7
35785: PUSH
35786: LD_INT 2
35788: ARRAY
35789: PPUSH
35790: LD_VAR 0 7
35794: PUSH
35795: LD_INT 3
35797: ARRAY
35798: PPUSH
35799: CALL_OW 117
// end ;
35803: GO 35581
35805: POP
35806: POP
// end ; end else
35807: GO 36339
// begin for j in cargo do
35809: LD_ADDR_VAR 0 3
35813: PUSH
35814: LD_VAR 0 8
35818: PUSH
35819: FOR_IN
35820: IFFALSE 36337
// begin if GetTag ( j ) <> 0 then
35822: LD_VAR 0 3
35826: PPUSH
35827: CALL_OW 110
35831: PUSH
35832: LD_INT 0
35834: NONEQUAL
35835: IFFALSE 35839
// continue ;
35837: GO 35819
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35839: LD_VAR 0 3
35843: PPUSH
35844: CALL_OW 256
35848: PUSH
35849: LD_INT 1000
35851: LESS
35852: PUSH
35853: LD_VAR 0 3
35857: PPUSH
35858: LD_EXP 100
35862: PUSH
35863: LD_VAR 0 2
35867: ARRAY
35868: PPUSH
35869: CALL_OW 308
35873: NOT
35874: AND
35875: IFFALSE 35897
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35877: LD_VAR 0 3
35881: PPUSH
35882: LD_EXP 100
35886: PUSH
35887: LD_VAR 0 2
35891: ARRAY
35892: PPUSH
35893: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35897: LD_VAR 0 3
35901: PPUSH
35902: CALL_OW 256
35906: PUSH
35907: LD_INT 1000
35909: LESS
35910: PUSH
35911: LD_VAR 0 3
35915: PPUSH
35916: LD_EXP 100
35920: PUSH
35921: LD_VAR 0 2
35925: ARRAY
35926: PPUSH
35927: CALL_OW 308
35931: AND
35932: IFFALSE 35936
// continue ;
35934: GO 35819
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35936: LD_VAR 0 3
35940: PPUSH
35941: CALL_OW 262
35945: PUSH
35946: LD_INT 2
35948: EQUAL
35949: PUSH
35950: LD_VAR 0 3
35954: PPUSH
35955: CALL_OW 261
35959: PUSH
35960: LD_INT 15
35962: LESS
35963: AND
35964: IFFALSE 35968
// continue ;
35966: GO 35819
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35968: LD_VAR 0 3
35972: PPUSH
35973: CALL_OW 262
35977: PUSH
35978: LD_INT 1
35980: EQUAL
35981: PUSH
35982: LD_VAR 0 3
35986: PPUSH
35987: CALL_OW 261
35991: PUSH
35992: LD_INT 10
35994: LESS
35995: AND
35996: IFFALSE 36276
// begin if not depot then
35998: LD_VAR 0 9
36002: NOT
36003: IFFALSE 36007
// continue ;
36005: GO 35819
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36007: LD_VAR 0 3
36011: PPUSH
36012: LD_VAR 0 9
36016: PPUSH
36017: LD_VAR 0 3
36021: PPUSH
36022: CALL_OW 74
36026: PPUSH
36027: CALL_OW 296
36031: PUSH
36032: LD_INT 6
36034: LESS
36035: IFFALSE 36051
// SetFuel ( j , 100 ) else
36037: LD_VAR 0 3
36041: PPUSH
36042: LD_INT 100
36044: PPUSH
36045: CALL_OW 240
36049: GO 36276
// if GetFuel ( j ) = 0 then
36051: LD_VAR 0 3
36055: PPUSH
36056: CALL_OW 261
36060: PUSH
36061: LD_INT 0
36063: EQUAL
36064: IFFALSE 36276
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36066: LD_ADDR_EXP 95
36070: PUSH
36071: LD_EXP 95
36075: PPUSH
36076: LD_VAR 0 2
36080: PPUSH
36081: LD_EXP 95
36085: PUSH
36086: LD_VAR 0 2
36090: ARRAY
36091: PUSH
36092: LD_VAR 0 3
36096: DIFF
36097: PPUSH
36098: CALL_OW 1
36102: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36103: LD_VAR 0 3
36107: PPUSH
36108: CALL_OW 263
36112: PUSH
36113: LD_INT 1
36115: EQUAL
36116: IFFALSE 36132
// ComExitVehicle ( IsInUnit ( j ) ) ;
36118: LD_VAR 0 3
36122: PPUSH
36123: CALL_OW 310
36127: PPUSH
36128: CALL_OW 121
// if GetControl ( j ) = control_remote then
36132: LD_VAR 0 3
36136: PPUSH
36137: CALL_OW 263
36141: PUSH
36142: LD_INT 2
36144: EQUAL
36145: IFFALSE 36156
// ComUnlink ( j ) ;
36147: LD_VAR 0 3
36151: PPUSH
36152: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36156: LD_ADDR_VAR 0 10
36160: PUSH
36161: LD_VAR 0 2
36165: PPUSH
36166: LD_INT 3
36168: PPUSH
36169: CALL 45915 0 2
36173: ST_TO_ADDR
// if fac then
36174: LD_VAR 0 10
36178: IFFALSE 36274
// begin for k in fac do
36180: LD_ADDR_VAR 0 4
36184: PUSH
36185: LD_VAR 0 10
36189: PUSH
36190: FOR_IN
36191: IFFALSE 36272
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36193: LD_ADDR_VAR 0 11
36197: PUSH
36198: LD_VAR 0 10
36202: PPUSH
36203: LD_VAR 0 3
36207: PPUSH
36208: CALL_OW 265
36212: PPUSH
36213: LD_VAR 0 3
36217: PPUSH
36218: CALL_OW 262
36222: PPUSH
36223: LD_VAR 0 3
36227: PPUSH
36228: CALL_OW 263
36232: PPUSH
36233: LD_VAR 0 3
36237: PPUSH
36238: CALL_OW 264
36242: PPUSH
36243: CALL 54483 0 5
36247: ST_TO_ADDR
// if components then
36248: LD_VAR 0 11
36252: IFFALSE 36270
// begin MC_InsertProduceList ( i , components ) ;
36254: LD_VAR 0 2
36258: PPUSH
36259: LD_VAR 0 11
36263: PPUSH
36264: CALL 45460 0 2
// break ;
36268: GO 36272
// end ; end ;
36270: GO 36190
36272: POP
36273: POP
// end ; continue ;
36274: GO 35819
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36276: LD_VAR 0 3
36280: PPUSH
36281: LD_INT 1
36283: PPUSH
36284: CALL_OW 289
36288: PUSH
36289: LD_INT 100
36291: LESS
36292: PUSH
36293: LD_VAR 0 3
36297: PPUSH
36298: CALL_OW 314
36302: NOT
36303: AND
36304: IFFALSE 36333
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36306: LD_VAR 0 3
36310: PPUSH
36311: LD_VAR 0 7
36315: PUSH
36316: LD_INT 2
36318: ARRAY
36319: PPUSH
36320: LD_VAR 0 7
36324: PUSH
36325: LD_INT 3
36327: ARRAY
36328: PPUSH
36329: CALL_OW 117
// break ;
36333: GO 36337
// end ;
36335: GO 35819
36337: POP
36338: POP
// end ; end ;
36339: GO 34535
36341: POP
36342: POP
// end ;
36343: LD_VAR 0 1
36347: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36348: LD_INT 0
36350: PPUSH
36351: PPUSH
36352: PPUSH
36353: PPUSH
// if not mc_bases then
36354: LD_EXP 76
36358: NOT
36359: IFFALSE 36363
// exit ;
36361: GO 36524
// for i = 1 to mc_bases do
36363: LD_ADDR_VAR 0 2
36367: PUSH
36368: DOUBLE
36369: LD_INT 1
36371: DEC
36372: ST_TO_ADDR
36373: LD_EXP 76
36377: PUSH
36378: FOR_TO
36379: IFFALSE 36522
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36381: LD_ADDR_VAR 0 4
36385: PUSH
36386: LD_EXP 95
36390: PUSH
36391: LD_VAR 0 2
36395: ARRAY
36396: PUSH
36397: LD_EXP 98
36401: PUSH
36402: LD_VAR 0 2
36406: ARRAY
36407: UNION
36408: PPUSH
36409: LD_INT 33
36411: PUSH
36412: LD_INT 2
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PPUSH
36419: CALL_OW 72
36423: ST_TO_ADDR
// if tmp then
36424: LD_VAR 0 4
36428: IFFALSE 36520
// for j in tmp do
36430: LD_ADDR_VAR 0 3
36434: PUSH
36435: LD_VAR 0 4
36439: PUSH
36440: FOR_IN
36441: IFFALSE 36518
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36443: LD_VAR 0 3
36447: PPUSH
36448: CALL_OW 312
36452: NOT
36453: PUSH
36454: LD_VAR 0 3
36458: PPUSH
36459: CALL_OW 256
36463: PUSH
36464: LD_INT 250
36466: GREATEREQUAL
36467: AND
36468: IFFALSE 36481
// Connect ( j ) else
36470: LD_VAR 0 3
36474: PPUSH
36475: CALL 59954 0 1
36479: GO 36516
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36481: LD_VAR 0 3
36485: PPUSH
36486: CALL_OW 256
36490: PUSH
36491: LD_INT 250
36493: LESS
36494: PUSH
36495: LD_VAR 0 3
36499: PPUSH
36500: CALL_OW 312
36504: AND
36505: IFFALSE 36516
// ComUnlink ( j ) ;
36507: LD_VAR 0 3
36511: PPUSH
36512: CALL_OW 136
36516: GO 36440
36518: POP
36519: POP
// end ;
36520: GO 36378
36522: POP
36523: POP
// end ;
36524: LD_VAR 0 1
36528: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36529: LD_INT 0
36531: PPUSH
36532: PPUSH
36533: PPUSH
36534: PPUSH
36535: PPUSH
// if not mc_bases then
36536: LD_EXP 76
36540: NOT
36541: IFFALSE 36545
// exit ;
36543: GO 36990
// for i = 1 to mc_bases do
36545: LD_ADDR_VAR 0 2
36549: PUSH
36550: DOUBLE
36551: LD_INT 1
36553: DEC
36554: ST_TO_ADDR
36555: LD_EXP 76
36559: PUSH
36560: FOR_TO
36561: IFFALSE 36988
// begin if not mc_produce [ i ] then
36563: LD_EXP 97
36567: PUSH
36568: LD_VAR 0 2
36572: ARRAY
36573: NOT
36574: IFFALSE 36578
// continue ;
36576: GO 36560
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36578: LD_ADDR_VAR 0 5
36582: PUSH
36583: LD_EXP 76
36587: PUSH
36588: LD_VAR 0 2
36592: ARRAY
36593: PPUSH
36594: LD_INT 30
36596: PUSH
36597: LD_INT 3
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PPUSH
36604: CALL_OW 72
36608: ST_TO_ADDR
// if not fac then
36609: LD_VAR 0 5
36613: NOT
36614: IFFALSE 36618
// continue ;
36616: GO 36560
// for j in fac do
36618: LD_ADDR_VAR 0 3
36622: PUSH
36623: LD_VAR 0 5
36627: PUSH
36628: FOR_IN
36629: IFFALSE 36984
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36631: LD_VAR 0 3
36635: PPUSH
36636: CALL_OW 461
36640: PUSH
36641: LD_INT 2
36643: NONEQUAL
36644: PUSH
36645: LD_VAR 0 3
36649: PPUSH
36650: LD_INT 15
36652: PPUSH
36653: CALL 59582 0 2
36657: PUSH
36658: LD_INT 4
36660: ARRAY
36661: OR
36662: IFFALSE 36666
// continue ;
36664: GO 36628
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36666: LD_VAR 0 3
36670: PPUSH
36671: LD_EXP 97
36675: PUSH
36676: LD_VAR 0 2
36680: ARRAY
36681: PUSH
36682: LD_INT 1
36684: ARRAY
36685: PUSH
36686: LD_INT 1
36688: ARRAY
36689: PPUSH
36690: LD_EXP 97
36694: PUSH
36695: LD_VAR 0 2
36699: ARRAY
36700: PUSH
36701: LD_INT 1
36703: ARRAY
36704: PUSH
36705: LD_INT 2
36707: ARRAY
36708: PPUSH
36709: LD_EXP 97
36713: PUSH
36714: LD_VAR 0 2
36718: ARRAY
36719: PUSH
36720: LD_INT 1
36722: ARRAY
36723: PUSH
36724: LD_INT 3
36726: ARRAY
36727: PPUSH
36728: LD_EXP 97
36732: PUSH
36733: LD_VAR 0 2
36737: ARRAY
36738: PUSH
36739: LD_INT 1
36741: ARRAY
36742: PUSH
36743: LD_INT 4
36745: ARRAY
36746: PPUSH
36747: CALL_OW 448
36751: PUSH
36752: LD_VAR 0 3
36756: PPUSH
36757: LD_EXP 97
36761: PUSH
36762: LD_VAR 0 2
36766: ARRAY
36767: PUSH
36768: LD_INT 1
36770: ARRAY
36771: PUSH
36772: LD_INT 1
36774: ARRAY
36775: PUSH
36776: LD_EXP 97
36780: PUSH
36781: LD_VAR 0 2
36785: ARRAY
36786: PUSH
36787: LD_INT 1
36789: ARRAY
36790: PUSH
36791: LD_INT 2
36793: ARRAY
36794: PUSH
36795: LD_EXP 97
36799: PUSH
36800: LD_VAR 0 2
36804: ARRAY
36805: PUSH
36806: LD_INT 1
36808: ARRAY
36809: PUSH
36810: LD_INT 3
36812: ARRAY
36813: PUSH
36814: LD_EXP 97
36818: PUSH
36819: LD_VAR 0 2
36823: ARRAY
36824: PUSH
36825: LD_INT 1
36827: ARRAY
36828: PUSH
36829: LD_INT 4
36831: ARRAY
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: PPUSH
36839: CALL 63349 0 2
36843: AND
36844: IFFALSE 36982
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36846: LD_VAR 0 3
36850: PPUSH
36851: LD_EXP 97
36855: PUSH
36856: LD_VAR 0 2
36860: ARRAY
36861: PUSH
36862: LD_INT 1
36864: ARRAY
36865: PUSH
36866: LD_INT 1
36868: ARRAY
36869: PPUSH
36870: LD_EXP 97
36874: PUSH
36875: LD_VAR 0 2
36879: ARRAY
36880: PUSH
36881: LD_INT 1
36883: ARRAY
36884: PUSH
36885: LD_INT 2
36887: ARRAY
36888: PPUSH
36889: LD_EXP 97
36893: PUSH
36894: LD_VAR 0 2
36898: ARRAY
36899: PUSH
36900: LD_INT 1
36902: ARRAY
36903: PUSH
36904: LD_INT 3
36906: ARRAY
36907: PPUSH
36908: LD_EXP 97
36912: PUSH
36913: LD_VAR 0 2
36917: ARRAY
36918: PUSH
36919: LD_INT 1
36921: ARRAY
36922: PUSH
36923: LD_INT 4
36925: ARRAY
36926: PPUSH
36927: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36931: LD_ADDR_VAR 0 4
36935: PUSH
36936: LD_EXP 97
36940: PUSH
36941: LD_VAR 0 2
36945: ARRAY
36946: PPUSH
36947: LD_INT 1
36949: PPUSH
36950: CALL_OW 3
36954: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36955: LD_ADDR_EXP 97
36959: PUSH
36960: LD_EXP 97
36964: PPUSH
36965: LD_VAR 0 2
36969: PPUSH
36970: LD_VAR 0 4
36974: PPUSH
36975: CALL_OW 1
36979: ST_TO_ADDR
// break ;
36980: GO 36984
// end ; end ;
36982: GO 36628
36984: POP
36985: POP
// end ;
36986: GO 36560
36988: POP
36989: POP
// end ;
36990: LD_VAR 0 1
36994: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36995: LD_INT 0
36997: PPUSH
36998: PPUSH
36999: PPUSH
// if not mc_bases then
37000: LD_EXP 76
37004: NOT
37005: IFFALSE 37009
// exit ;
37007: GO 37098
// for i = 1 to mc_bases do
37009: LD_ADDR_VAR 0 2
37013: PUSH
37014: DOUBLE
37015: LD_INT 1
37017: DEC
37018: ST_TO_ADDR
37019: LD_EXP 76
37023: PUSH
37024: FOR_TO
37025: IFFALSE 37096
// begin if mc_attack [ i ] then
37027: LD_EXP 96
37031: PUSH
37032: LD_VAR 0 2
37036: ARRAY
37037: IFFALSE 37094
// begin tmp := mc_attack [ i ] [ 1 ] ;
37039: LD_ADDR_VAR 0 3
37043: PUSH
37044: LD_EXP 96
37048: PUSH
37049: LD_VAR 0 2
37053: ARRAY
37054: PUSH
37055: LD_INT 1
37057: ARRAY
37058: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37059: LD_ADDR_EXP 96
37063: PUSH
37064: LD_EXP 96
37068: PPUSH
37069: LD_VAR 0 2
37073: PPUSH
37074: EMPTY
37075: PPUSH
37076: CALL_OW 1
37080: ST_TO_ADDR
// Attack ( tmp ) ;
37081: LD_VAR 0 3
37085: PPUSH
37086: CALL 112971 0 1
// exit ;
37090: POP
37091: POP
37092: GO 37098
// end ; end ;
37094: GO 37024
37096: POP
37097: POP
// end ;
37098: LD_VAR 0 1
37102: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37103: LD_INT 0
37105: PPUSH
37106: PPUSH
37107: PPUSH
37108: PPUSH
37109: PPUSH
37110: PPUSH
37111: PPUSH
// if not mc_bases then
37112: LD_EXP 76
37116: NOT
37117: IFFALSE 37121
// exit ;
37119: GO 37978
// for i = 1 to mc_bases do
37121: LD_ADDR_VAR 0 2
37125: PUSH
37126: DOUBLE
37127: LD_INT 1
37129: DEC
37130: ST_TO_ADDR
37131: LD_EXP 76
37135: PUSH
37136: FOR_TO
37137: IFFALSE 37976
// begin if not mc_bases [ i ] then
37139: LD_EXP 76
37143: PUSH
37144: LD_VAR 0 2
37148: ARRAY
37149: NOT
37150: IFFALSE 37154
// continue ;
37152: GO 37136
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37154: LD_ADDR_VAR 0 7
37158: PUSH
37159: LD_EXP 76
37163: PUSH
37164: LD_VAR 0 2
37168: ARRAY
37169: PUSH
37170: LD_INT 1
37172: ARRAY
37173: PPUSH
37174: CALL 53634 0 1
37178: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37179: LD_ADDR_EXP 99
37183: PUSH
37184: LD_EXP 99
37188: PPUSH
37189: LD_VAR 0 2
37193: PPUSH
37194: LD_EXP 76
37198: PUSH
37199: LD_VAR 0 2
37203: ARRAY
37204: PUSH
37205: LD_INT 1
37207: ARRAY
37208: PPUSH
37209: CALL_OW 255
37213: PPUSH
37214: LD_EXP 101
37218: PUSH
37219: LD_VAR 0 2
37223: ARRAY
37224: PPUSH
37225: CALL 53599 0 2
37229: PPUSH
37230: CALL_OW 1
37234: ST_TO_ADDR
// if not mc_scan [ i ] then
37235: LD_EXP 99
37239: PUSH
37240: LD_VAR 0 2
37244: ARRAY
37245: NOT
37246: IFFALSE 37424
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37248: LD_ADDR_EXP 119
37252: PUSH
37253: LD_EXP 119
37257: PPUSH
37258: LD_VAR 0 2
37262: PPUSH
37263: LD_INT 0
37265: PPUSH
37266: CALL_OW 1
37270: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37271: LD_ADDR_VAR 0 4
37275: PUSH
37276: LD_EXP 76
37280: PUSH
37281: LD_VAR 0 2
37285: ARRAY
37286: PPUSH
37287: LD_INT 2
37289: PUSH
37290: LD_INT 25
37292: PUSH
37293: LD_INT 5
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 25
37302: PUSH
37303: LD_INT 8
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 25
37312: PUSH
37313: LD_INT 9
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: LIST
37324: LIST
37325: PPUSH
37326: CALL_OW 72
37330: ST_TO_ADDR
// if not tmp then
37331: LD_VAR 0 4
37335: NOT
37336: IFFALSE 37340
// continue ;
37338: GO 37136
// for j in tmp do
37340: LD_ADDR_VAR 0 3
37344: PUSH
37345: LD_VAR 0 4
37349: PUSH
37350: FOR_IN
37351: IFFALSE 37422
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37353: LD_VAR 0 3
37357: PPUSH
37358: CALL_OW 310
37362: PPUSH
37363: CALL_OW 266
37367: PUSH
37368: LD_INT 5
37370: EQUAL
37371: PUSH
37372: LD_VAR 0 3
37376: PPUSH
37377: CALL_OW 257
37381: PUSH
37382: LD_INT 1
37384: EQUAL
37385: AND
37386: PUSH
37387: LD_VAR 0 3
37391: PPUSH
37392: CALL_OW 459
37396: NOT
37397: AND
37398: PUSH
37399: LD_VAR 0 7
37403: AND
37404: IFFALSE 37420
// ComChangeProfession ( j , class ) ;
37406: LD_VAR 0 3
37410: PPUSH
37411: LD_VAR 0 7
37415: PPUSH
37416: CALL_OW 123
37420: GO 37350
37422: POP
37423: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37424: LD_EXP 99
37428: PUSH
37429: LD_VAR 0 2
37433: ARRAY
37434: PUSH
37435: LD_EXP 119
37439: PUSH
37440: LD_VAR 0 2
37444: ARRAY
37445: NOT
37446: AND
37447: PUSH
37448: LD_EXP 98
37452: PUSH
37453: LD_VAR 0 2
37457: ARRAY
37458: NOT
37459: AND
37460: PUSH
37461: LD_EXP 76
37465: PUSH
37466: LD_VAR 0 2
37470: ARRAY
37471: PPUSH
37472: LD_INT 50
37474: PUSH
37475: EMPTY
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: PUSH
37481: LD_INT 30
37483: PUSH
37484: LD_INT 32
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PUSH
37491: LD_INT 30
37493: PUSH
37494: LD_INT 33
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 30
37503: PUSH
37504: LD_INT 4
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 30
37513: PUSH
37514: LD_INT 5
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PPUSH
37532: CALL_OW 72
37536: PUSH
37537: LD_INT 4
37539: LESS
37540: PUSH
37541: LD_EXP 76
37545: PUSH
37546: LD_VAR 0 2
37550: ARRAY
37551: PPUSH
37552: LD_INT 3
37554: PUSH
37555: LD_INT 24
37557: PUSH
37558: LD_INT 1000
37560: PUSH
37561: EMPTY
37562: LIST
37563: LIST
37564: PUSH
37565: EMPTY
37566: LIST
37567: LIST
37568: PUSH
37569: LD_INT 2
37571: PUSH
37572: LD_INT 30
37574: PUSH
37575: LD_INT 0
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 30
37584: PUSH
37585: LD_INT 1
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: EMPTY
37593: LIST
37594: LIST
37595: LIST
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PPUSH
37601: CALL_OW 72
37605: OR
37606: AND
37607: IFFALSE 37858
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37609: LD_ADDR_EXP 119
37613: PUSH
37614: LD_EXP 119
37618: PPUSH
37619: LD_VAR 0 2
37623: PPUSH
37624: LD_INT 1
37626: PPUSH
37627: CALL_OW 1
37631: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37632: LD_ADDR_VAR 0 4
37636: PUSH
37637: LD_EXP 76
37641: PUSH
37642: LD_VAR 0 2
37646: ARRAY
37647: PPUSH
37648: LD_INT 2
37650: PUSH
37651: LD_INT 25
37653: PUSH
37654: LD_INT 1
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: LD_INT 25
37663: PUSH
37664: LD_INT 5
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 25
37673: PUSH
37674: LD_INT 8
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: PUSH
37681: LD_INT 25
37683: PUSH
37684: LD_INT 9
37686: PUSH
37687: EMPTY
37688: LIST
37689: LIST
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: PPUSH
37698: CALL_OW 72
37702: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37703: LD_ADDR_VAR 0 4
37707: PUSH
37708: LD_VAR 0 4
37712: PUSH
37713: LD_VAR 0 4
37717: PPUSH
37718: LD_INT 18
37720: PPUSH
37721: CALL 86798 0 2
37725: DIFF
37726: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37727: LD_VAR 0 4
37731: NOT
37732: PUSH
37733: LD_EXP 76
37737: PUSH
37738: LD_VAR 0 2
37742: ARRAY
37743: PPUSH
37744: LD_INT 2
37746: PUSH
37747: LD_INT 30
37749: PUSH
37750: LD_INT 4
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 30
37759: PUSH
37760: LD_INT 5
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: EMPTY
37768: LIST
37769: LIST
37770: LIST
37771: PPUSH
37772: CALL_OW 72
37776: NOT
37777: AND
37778: IFFALSE 37840
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37780: LD_ADDR_VAR 0 4
37784: PUSH
37785: LD_EXP 76
37789: PUSH
37790: LD_VAR 0 2
37794: ARRAY
37795: PPUSH
37796: LD_INT 2
37798: PUSH
37799: LD_INT 25
37801: PUSH
37802: LD_INT 2
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 25
37811: PUSH
37812: LD_INT 3
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 25
37821: PUSH
37822: LD_INT 4
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: LIST
37833: LIST
37834: PPUSH
37835: CALL_OW 72
37839: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
37840: LD_VAR 0 2
37844: PPUSH
37845: LD_VAR 0 4
37849: PPUSH
37850: CALL 117680 0 2
// exit ;
37854: POP
37855: POP
37856: GO 37978
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37858: LD_EXP 99
37862: PUSH
37863: LD_VAR 0 2
37867: ARRAY
37868: PUSH
37869: LD_EXP 119
37873: PUSH
37874: LD_VAR 0 2
37878: ARRAY
37879: NOT
37880: AND
37881: PUSH
37882: LD_EXP 98
37886: PUSH
37887: LD_VAR 0 2
37891: ARRAY
37892: AND
37893: IFFALSE 37974
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37895: LD_ADDR_EXP 119
37899: PUSH
37900: LD_EXP 119
37904: PPUSH
37905: LD_VAR 0 2
37909: PPUSH
37910: LD_INT 1
37912: PPUSH
37913: CALL_OW 1
37917: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
37918: LD_ADDR_VAR 0 4
37922: PUSH
37923: LD_EXP 98
37927: PUSH
37928: LD_VAR 0 2
37932: ARRAY
37933: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37934: LD_ADDR_EXP 98
37938: PUSH
37939: LD_EXP 98
37943: PPUSH
37944: LD_VAR 0 2
37948: PPUSH
37949: EMPTY
37950: PPUSH
37951: CALL_OW 1
37955: ST_TO_ADDR
// Defend ( i , tmp ) ;
37956: LD_VAR 0 2
37960: PPUSH
37961: LD_VAR 0 4
37965: PPUSH
37966: CALL 118276 0 2
// exit ;
37970: POP
37971: POP
37972: GO 37978
// end ; end ;
37974: GO 37136
37976: POP
37977: POP
// end ;
37978: LD_VAR 0 1
37982: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37983: LD_INT 0
37985: PPUSH
37986: PPUSH
37987: PPUSH
37988: PPUSH
37989: PPUSH
37990: PPUSH
37991: PPUSH
37992: PPUSH
37993: PPUSH
37994: PPUSH
37995: PPUSH
// if not mc_bases then
37996: LD_EXP 76
38000: NOT
38001: IFFALSE 38005
// exit ;
38003: GO 39092
// for i = 1 to mc_bases do
38005: LD_ADDR_VAR 0 2
38009: PUSH
38010: DOUBLE
38011: LD_INT 1
38013: DEC
38014: ST_TO_ADDR
38015: LD_EXP 76
38019: PUSH
38020: FOR_TO
38021: IFFALSE 39090
// begin tmp := mc_lab [ i ] ;
38023: LD_ADDR_VAR 0 6
38027: PUSH
38028: LD_EXP 109
38032: PUSH
38033: LD_VAR 0 2
38037: ARRAY
38038: ST_TO_ADDR
// if not tmp then
38039: LD_VAR 0 6
38043: NOT
38044: IFFALSE 38048
// continue ;
38046: GO 38020
// idle_lab := 0 ;
38048: LD_ADDR_VAR 0 11
38052: PUSH
38053: LD_INT 0
38055: ST_TO_ADDR
// for j in tmp do
38056: LD_ADDR_VAR 0 3
38060: PUSH
38061: LD_VAR 0 6
38065: PUSH
38066: FOR_IN
38067: IFFALSE 39086
// begin researching := false ;
38069: LD_ADDR_VAR 0 10
38073: PUSH
38074: LD_INT 0
38076: ST_TO_ADDR
// side := GetSide ( j ) ;
38077: LD_ADDR_VAR 0 4
38081: PUSH
38082: LD_VAR 0 3
38086: PPUSH
38087: CALL_OW 255
38091: ST_TO_ADDR
// if not mc_tech [ side ] then
38092: LD_EXP 103
38096: PUSH
38097: LD_VAR 0 4
38101: ARRAY
38102: NOT
38103: IFFALSE 38107
// continue ;
38105: GO 38066
// if BuildingStatus ( j ) = bs_idle then
38107: LD_VAR 0 3
38111: PPUSH
38112: CALL_OW 461
38116: PUSH
38117: LD_INT 2
38119: EQUAL
38120: IFFALSE 38308
// begin if idle_lab and UnitsInside ( j ) < 6 then
38122: LD_VAR 0 11
38126: PUSH
38127: LD_VAR 0 3
38131: PPUSH
38132: CALL_OW 313
38136: PUSH
38137: LD_INT 6
38139: LESS
38140: AND
38141: IFFALSE 38212
// begin tmp2 := UnitsInside ( idle_lab ) ;
38143: LD_ADDR_VAR 0 9
38147: PUSH
38148: LD_VAR 0 11
38152: PPUSH
38153: CALL_OW 313
38157: ST_TO_ADDR
// if tmp2 then
38158: LD_VAR 0 9
38162: IFFALSE 38204
// for x in tmp2 do
38164: LD_ADDR_VAR 0 7
38168: PUSH
38169: LD_VAR 0 9
38173: PUSH
38174: FOR_IN
38175: IFFALSE 38202
// begin ComExitBuilding ( x ) ;
38177: LD_VAR 0 7
38181: PPUSH
38182: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38186: LD_VAR 0 7
38190: PPUSH
38191: LD_VAR 0 3
38195: PPUSH
38196: CALL_OW 180
// end ;
38200: GO 38174
38202: POP
38203: POP
// idle_lab := 0 ;
38204: LD_ADDR_VAR 0 11
38208: PUSH
38209: LD_INT 0
38211: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38212: LD_ADDR_VAR 0 5
38216: PUSH
38217: LD_EXP 103
38221: PUSH
38222: LD_VAR 0 4
38226: ARRAY
38227: PUSH
38228: FOR_IN
38229: IFFALSE 38289
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38231: LD_VAR 0 3
38235: PPUSH
38236: LD_VAR 0 5
38240: PPUSH
38241: CALL_OW 430
38245: PUSH
38246: LD_VAR 0 4
38250: PPUSH
38251: LD_VAR 0 5
38255: PPUSH
38256: CALL 52704 0 2
38260: AND
38261: IFFALSE 38287
// begin researching := true ;
38263: LD_ADDR_VAR 0 10
38267: PUSH
38268: LD_INT 1
38270: ST_TO_ADDR
// ComResearch ( j , t ) ;
38271: LD_VAR 0 3
38275: PPUSH
38276: LD_VAR 0 5
38280: PPUSH
38281: CALL_OW 124
// break ;
38285: GO 38289
// end ;
38287: GO 38228
38289: POP
38290: POP
// if not researching then
38291: LD_VAR 0 10
38295: NOT
38296: IFFALSE 38308
// idle_lab := j ;
38298: LD_ADDR_VAR 0 11
38302: PUSH
38303: LD_VAR 0 3
38307: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38308: LD_VAR 0 3
38312: PPUSH
38313: CALL_OW 461
38317: PUSH
38318: LD_INT 10
38320: EQUAL
38321: IFFALSE 38909
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38323: LD_EXP 105
38327: PUSH
38328: LD_VAR 0 2
38332: ARRAY
38333: NOT
38334: PUSH
38335: LD_EXP 106
38339: PUSH
38340: LD_VAR 0 2
38344: ARRAY
38345: NOT
38346: AND
38347: PUSH
38348: LD_EXP 103
38352: PUSH
38353: LD_VAR 0 4
38357: ARRAY
38358: PUSH
38359: LD_INT 1
38361: GREATER
38362: AND
38363: IFFALSE 38494
// begin ComCancel ( j ) ;
38365: LD_VAR 0 3
38369: PPUSH
38370: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38374: LD_ADDR_EXP 103
38378: PUSH
38379: LD_EXP 103
38383: PPUSH
38384: LD_VAR 0 4
38388: PPUSH
38389: LD_EXP 103
38393: PUSH
38394: LD_VAR 0 4
38398: ARRAY
38399: PPUSH
38400: LD_EXP 103
38404: PUSH
38405: LD_VAR 0 4
38409: ARRAY
38410: PUSH
38411: LD_INT 1
38413: MINUS
38414: PPUSH
38415: LD_EXP 103
38419: PUSH
38420: LD_VAR 0 4
38424: ARRAY
38425: PPUSH
38426: LD_INT 0
38428: PPUSH
38429: CALL 56403 0 4
38433: PPUSH
38434: CALL_OW 1
38438: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38439: LD_ADDR_EXP 103
38443: PUSH
38444: LD_EXP 103
38448: PPUSH
38449: LD_VAR 0 4
38453: PPUSH
38454: LD_EXP 103
38458: PUSH
38459: LD_VAR 0 4
38463: ARRAY
38464: PPUSH
38465: LD_EXP 103
38469: PUSH
38470: LD_VAR 0 4
38474: ARRAY
38475: PPUSH
38476: LD_INT 1
38478: PPUSH
38479: LD_INT 0
38481: PPUSH
38482: CALL 56403 0 4
38486: PPUSH
38487: CALL_OW 1
38491: ST_TO_ADDR
// continue ;
38492: GO 38066
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38494: LD_EXP 105
38498: PUSH
38499: LD_VAR 0 2
38503: ARRAY
38504: PUSH
38505: LD_EXP 106
38509: PUSH
38510: LD_VAR 0 2
38514: ARRAY
38515: NOT
38516: AND
38517: IFFALSE 38644
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38519: LD_ADDR_EXP 106
38523: PUSH
38524: LD_EXP 106
38528: PPUSH
38529: LD_VAR 0 2
38533: PUSH
38534: LD_EXP 106
38538: PUSH
38539: LD_VAR 0 2
38543: ARRAY
38544: PUSH
38545: LD_INT 1
38547: PLUS
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PPUSH
38553: LD_EXP 105
38557: PUSH
38558: LD_VAR 0 2
38562: ARRAY
38563: PUSH
38564: LD_INT 1
38566: ARRAY
38567: PPUSH
38568: CALL 56985 0 3
38572: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38573: LD_EXP 105
38577: PUSH
38578: LD_VAR 0 2
38582: ARRAY
38583: PUSH
38584: LD_INT 1
38586: ARRAY
38587: PPUSH
38588: LD_INT 112
38590: PPUSH
38591: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38595: LD_ADDR_VAR 0 9
38599: PUSH
38600: LD_EXP 105
38604: PUSH
38605: LD_VAR 0 2
38609: ARRAY
38610: PPUSH
38611: LD_INT 1
38613: PPUSH
38614: CALL_OW 3
38618: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38619: LD_ADDR_EXP 105
38623: PUSH
38624: LD_EXP 105
38628: PPUSH
38629: LD_VAR 0 2
38633: PPUSH
38634: LD_VAR 0 9
38638: PPUSH
38639: CALL_OW 1
38643: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38644: LD_EXP 105
38648: PUSH
38649: LD_VAR 0 2
38653: ARRAY
38654: PUSH
38655: LD_EXP 106
38659: PUSH
38660: LD_VAR 0 2
38664: ARRAY
38665: AND
38666: PUSH
38667: LD_EXP 106
38671: PUSH
38672: LD_VAR 0 2
38676: ARRAY
38677: PUSH
38678: LD_INT 1
38680: ARRAY
38681: PPUSH
38682: CALL_OW 310
38686: NOT
38687: AND
38688: PUSH
38689: LD_VAR 0 3
38693: PPUSH
38694: CALL_OW 313
38698: PUSH
38699: LD_INT 6
38701: EQUAL
38702: AND
38703: IFFALSE 38759
// begin tmp2 := UnitsInside ( j ) ;
38705: LD_ADDR_VAR 0 9
38709: PUSH
38710: LD_VAR 0 3
38714: PPUSH
38715: CALL_OW 313
38719: ST_TO_ADDR
// if tmp2 = 6 then
38720: LD_VAR 0 9
38724: PUSH
38725: LD_INT 6
38727: EQUAL
38728: IFFALSE 38759
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38730: LD_VAR 0 9
38734: PUSH
38735: LD_INT 1
38737: ARRAY
38738: PPUSH
38739: LD_INT 112
38741: PPUSH
38742: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38746: LD_VAR 0 9
38750: PUSH
38751: LD_INT 1
38753: ARRAY
38754: PPUSH
38755: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38759: LD_EXP 106
38763: PUSH
38764: LD_VAR 0 2
38768: ARRAY
38769: PUSH
38770: LD_EXP 106
38774: PUSH
38775: LD_VAR 0 2
38779: ARRAY
38780: PUSH
38781: LD_INT 1
38783: ARRAY
38784: PPUSH
38785: CALL_OW 314
38789: NOT
38790: AND
38791: PUSH
38792: LD_EXP 106
38796: PUSH
38797: LD_VAR 0 2
38801: ARRAY
38802: PUSH
38803: LD_INT 1
38805: ARRAY
38806: PPUSH
38807: CALL_OW 310
38811: NOT
38812: AND
38813: IFFALSE 38839
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38815: LD_EXP 106
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_INT 1
38828: ARRAY
38829: PPUSH
38830: LD_VAR 0 3
38834: PPUSH
38835: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38839: LD_EXP 106
38843: PUSH
38844: LD_VAR 0 2
38848: ARRAY
38849: PUSH
38850: LD_INT 1
38852: ARRAY
38853: PPUSH
38854: CALL_OW 310
38858: PUSH
38859: LD_EXP 106
38863: PUSH
38864: LD_VAR 0 2
38868: ARRAY
38869: PUSH
38870: LD_INT 1
38872: ARRAY
38873: PPUSH
38874: CALL_OW 310
38878: PPUSH
38879: CALL_OW 461
38883: PUSH
38884: LD_INT 3
38886: NONEQUAL
38887: AND
38888: IFFALSE 38909
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
38890: LD_EXP 106
38894: PUSH
38895: LD_VAR 0 2
38899: ARRAY
38900: PUSH
38901: LD_INT 1
38903: ARRAY
38904: PPUSH
38905: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
38909: LD_VAR 0 3
38913: PPUSH
38914: CALL_OW 461
38918: PUSH
38919: LD_INT 6
38921: EQUAL
38922: PUSH
38923: LD_VAR 0 6
38927: PUSH
38928: LD_INT 1
38930: GREATER
38931: AND
38932: IFFALSE 39084
// begin sci := [ ] ;
38934: LD_ADDR_VAR 0 8
38938: PUSH
38939: EMPTY
38940: ST_TO_ADDR
// for x in ( tmp diff j ) do
38941: LD_ADDR_VAR 0 7
38945: PUSH
38946: LD_VAR 0 6
38950: PUSH
38951: LD_VAR 0 3
38955: DIFF
38956: PUSH
38957: FOR_IN
38958: IFFALSE 39010
// begin if sci = 6 then
38960: LD_VAR 0 8
38964: PUSH
38965: LD_INT 6
38967: EQUAL
38968: IFFALSE 38972
// break ;
38970: GO 39010
// if BuildingStatus ( x ) = bs_idle then
38972: LD_VAR 0 7
38976: PPUSH
38977: CALL_OW 461
38981: PUSH
38982: LD_INT 2
38984: EQUAL
38985: IFFALSE 39008
// sci := sci ^ UnitsInside ( x ) ;
38987: LD_ADDR_VAR 0 8
38991: PUSH
38992: LD_VAR 0 8
38996: PUSH
38997: LD_VAR 0 7
39001: PPUSH
39002: CALL_OW 313
39006: ADD
39007: ST_TO_ADDR
// end ;
39008: GO 38957
39010: POP
39011: POP
// if not sci then
39012: LD_VAR 0 8
39016: NOT
39017: IFFALSE 39021
// continue ;
39019: GO 38066
// for x in sci do
39021: LD_ADDR_VAR 0 7
39025: PUSH
39026: LD_VAR 0 8
39030: PUSH
39031: FOR_IN
39032: IFFALSE 39082
// if IsInUnit ( x ) and not HasTask ( x ) then
39034: LD_VAR 0 7
39038: PPUSH
39039: CALL_OW 310
39043: PUSH
39044: LD_VAR 0 7
39048: PPUSH
39049: CALL_OW 314
39053: NOT
39054: AND
39055: IFFALSE 39080
// begin ComExitBuilding ( x ) ;
39057: LD_VAR 0 7
39061: PPUSH
39062: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39066: LD_VAR 0 7
39070: PPUSH
39071: LD_VAR 0 3
39075: PPUSH
39076: CALL_OW 180
// end ;
39080: GO 39031
39082: POP
39083: POP
// end ; end ;
39084: GO 38066
39086: POP
39087: POP
// end ;
39088: GO 38020
39090: POP
39091: POP
// end ;
39092: LD_VAR 0 1
39096: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39097: LD_INT 0
39099: PPUSH
39100: PPUSH
// if not mc_bases then
39101: LD_EXP 76
39105: NOT
39106: IFFALSE 39110
// exit ;
39108: GO 39191
// for i = 1 to mc_bases do
39110: LD_ADDR_VAR 0 2
39114: PUSH
39115: DOUBLE
39116: LD_INT 1
39118: DEC
39119: ST_TO_ADDR
39120: LD_EXP 76
39124: PUSH
39125: FOR_TO
39126: IFFALSE 39189
// if mc_mines [ i ] and mc_miners [ i ] then
39128: LD_EXP 89
39132: PUSH
39133: LD_VAR 0 2
39137: ARRAY
39138: PUSH
39139: LD_EXP 90
39143: PUSH
39144: LD_VAR 0 2
39148: ARRAY
39149: AND
39150: IFFALSE 39187
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39152: LD_EXP 90
39156: PUSH
39157: LD_VAR 0 2
39161: ARRAY
39162: PUSH
39163: LD_INT 1
39165: ARRAY
39166: PPUSH
39167: CALL_OW 255
39171: PPUSH
39172: LD_EXP 89
39176: PUSH
39177: LD_VAR 0 2
39181: ARRAY
39182: PPUSH
39183: CALL 53787 0 2
39187: GO 39125
39189: POP
39190: POP
// end ;
39191: LD_VAR 0 1
39195: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39196: LD_INT 0
39198: PPUSH
39199: PPUSH
39200: PPUSH
39201: PPUSH
39202: PPUSH
39203: PPUSH
39204: PPUSH
39205: PPUSH
// if not mc_bases or not mc_parking then
39206: LD_EXP 76
39210: NOT
39211: PUSH
39212: LD_EXP 100
39216: NOT
39217: OR
39218: IFFALSE 39222
// exit ;
39220: GO 39932
// for i = 1 to mc_bases do
39222: LD_ADDR_VAR 0 2
39226: PUSH
39227: DOUBLE
39228: LD_INT 1
39230: DEC
39231: ST_TO_ADDR
39232: LD_EXP 76
39236: PUSH
39237: FOR_TO
39238: IFFALSE 39930
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39240: LD_EXP 76
39244: PUSH
39245: LD_VAR 0 2
39249: ARRAY
39250: NOT
39251: PUSH
39252: LD_EXP 100
39256: PUSH
39257: LD_VAR 0 2
39261: ARRAY
39262: NOT
39263: OR
39264: IFFALSE 39268
// continue ;
39266: GO 39237
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39268: LD_ADDR_VAR 0 5
39272: PUSH
39273: LD_EXP 76
39277: PUSH
39278: LD_VAR 0 2
39282: ARRAY
39283: PUSH
39284: LD_INT 1
39286: ARRAY
39287: PPUSH
39288: CALL_OW 255
39292: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39293: LD_ADDR_VAR 0 6
39297: PUSH
39298: LD_EXP 76
39302: PUSH
39303: LD_VAR 0 2
39307: ARRAY
39308: PPUSH
39309: LD_INT 30
39311: PUSH
39312: LD_INT 3
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PPUSH
39319: CALL_OW 72
39323: ST_TO_ADDR
// if not fac then
39324: LD_VAR 0 6
39328: NOT
39329: IFFALSE 39380
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39331: LD_ADDR_VAR 0 6
39335: PUSH
39336: LD_EXP 76
39340: PUSH
39341: LD_VAR 0 2
39345: ARRAY
39346: PPUSH
39347: LD_INT 2
39349: PUSH
39350: LD_INT 30
39352: PUSH
39353: LD_INT 0
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: LD_INT 30
39362: PUSH
39363: LD_INT 1
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: LIST
39374: PPUSH
39375: CALL_OW 72
39379: ST_TO_ADDR
// if not fac then
39380: LD_VAR 0 6
39384: NOT
39385: IFFALSE 39389
// continue ;
39387: GO 39237
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39389: LD_ADDR_VAR 0 7
39393: PUSH
39394: LD_EXP 100
39398: PUSH
39399: LD_VAR 0 2
39403: ARRAY
39404: PPUSH
39405: LD_INT 22
39407: PUSH
39408: LD_VAR 0 5
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 21
39419: PUSH
39420: LD_INT 2
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 3
39429: PUSH
39430: LD_INT 24
39432: PUSH
39433: LD_INT 1000
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: LIST
39448: PPUSH
39449: CALL_OW 70
39453: ST_TO_ADDR
// for j in fac do
39454: LD_ADDR_VAR 0 3
39458: PUSH
39459: LD_VAR 0 6
39463: PUSH
39464: FOR_IN
39465: IFFALSE 39546
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39467: LD_ADDR_VAR 0 7
39471: PUSH
39472: LD_VAR 0 7
39476: PUSH
39477: LD_INT 22
39479: PUSH
39480: LD_VAR 0 5
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 91
39491: PUSH
39492: LD_VAR 0 3
39496: PUSH
39497: LD_INT 15
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 21
39507: PUSH
39508: LD_INT 2
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 3
39517: PUSH
39518: LD_INT 24
39520: PUSH
39521: LD_INT 1000
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: PPUSH
39538: CALL_OW 69
39542: UNION
39543: ST_TO_ADDR
39544: GO 39464
39546: POP
39547: POP
// if not vehs then
39548: LD_VAR 0 7
39552: NOT
39553: IFFALSE 39579
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39555: LD_ADDR_EXP 88
39559: PUSH
39560: LD_EXP 88
39564: PPUSH
39565: LD_VAR 0 2
39569: PPUSH
39570: EMPTY
39571: PPUSH
39572: CALL_OW 1
39576: ST_TO_ADDR
// continue ;
39577: GO 39237
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39579: LD_ADDR_VAR 0 8
39583: PUSH
39584: LD_EXP 76
39588: PUSH
39589: LD_VAR 0 2
39593: ARRAY
39594: PPUSH
39595: LD_INT 30
39597: PUSH
39598: LD_INT 3
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PPUSH
39605: CALL_OW 72
39609: ST_TO_ADDR
// if tmp then
39610: LD_VAR 0 8
39614: IFFALSE 39717
// begin for j in tmp do
39616: LD_ADDR_VAR 0 3
39620: PUSH
39621: LD_VAR 0 8
39625: PUSH
39626: FOR_IN
39627: IFFALSE 39715
// for k in UnitsInside ( j ) do
39629: LD_ADDR_VAR 0 4
39633: PUSH
39634: LD_VAR 0 3
39638: PPUSH
39639: CALL_OW 313
39643: PUSH
39644: FOR_IN
39645: IFFALSE 39711
// if k then
39647: LD_VAR 0 4
39651: IFFALSE 39709
// if not k in mc_repair_vehicle [ i ] then
39653: LD_VAR 0 4
39657: PUSH
39658: LD_EXP 88
39662: PUSH
39663: LD_VAR 0 2
39667: ARRAY
39668: IN
39669: NOT
39670: IFFALSE 39709
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39672: LD_ADDR_EXP 88
39676: PUSH
39677: LD_EXP 88
39681: PPUSH
39682: LD_VAR 0 2
39686: PPUSH
39687: LD_EXP 88
39691: PUSH
39692: LD_VAR 0 2
39696: ARRAY
39697: PUSH
39698: LD_VAR 0 4
39702: UNION
39703: PPUSH
39704: CALL_OW 1
39708: ST_TO_ADDR
39709: GO 39644
39711: POP
39712: POP
39713: GO 39626
39715: POP
39716: POP
// end ; if not mc_repair_vehicle [ i ] then
39717: LD_EXP 88
39721: PUSH
39722: LD_VAR 0 2
39726: ARRAY
39727: NOT
39728: IFFALSE 39732
// continue ;
39730: GO 39237
// for j in mc_repair_vehicle [ i ] do
39732: LD_ADDR_VAR 0 3
39736: PUSH
39737: LD_EXP 88
39741: PUSH
39742: LD_VAR 0 2
39746: ARRAY
39747: PUSH
39748: FOR_IN
39749: IFFALSE 39926
// begin if GetClass ( j ) <> 3 then
39751: LD_VAR 0 3
39755: PPUSH
39756: CALL_OW 257
39760: PUSH
39761: LD_INT 3
39763: NONEQUAL
39764: IFFALSE 39805
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39766: LD_ADDR_EXP 88
39770: PUSH
39771: LD_EXP 88
39775: PPUSH
39776: LD_VAR 0 2
39780: PPUSH
39781: LD_EXP 88
39785: PUSH
39786: LD_VAR 0 2
39790: ARRAY
39791: PUSH
39792: LD_VAR 0 3
39796: DIFF
39797: PPUSH
39798: CALL_OW 1
39802: ST_TO_ADDR
// continue ;
39803: GO 39748
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39805: LD_VAR 0 3
39809: PPUSH
39810: CALL_OW 311
39814: NOT
39815: PUSH
39816: LD_VAR 0 3
39820: PUSH
39821: LD_EXP 79
39825: PUSH
39826: LD_VAR 0 2
39830: ARRAY
39831: PUSH
39832: LD_INT 1
39834: ARRAY
39835: IN
39836: NOT
39837: AND
39838: PUSH
39839: LD_VAR 0 3
39843: PUSH
39844: LD_EXP 79
39848: PUSH
39849: LD_VAR 0 2
39853: ARRAY
39854: PUSH
39855: LD_INT 2
39857: ARRAY
39858: IN
39859: NOT
39860: AND
39861: IFFALSE 39924
// begin if IsInUnit ( j ) then
39863: LD_VAR 0 3
39867: PPUSH
39868: CALL_OW 310
39872: IFFALSE 39885
// ComExitBuilding ( j ) else
39874: LD_VAR 0 3
39878: PPUSH
39879: CALL_OW 122
39883: GO 39924
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
39885: LD_VAR 0 3
39889: PPUSH
39890: LD_VAR 0 7
39894: PUSH
39895: LD_INT 1
39897: ARRAY
39898: PPUSH
39899: CALL 91289 0 2
39903: NOT
39904: IFFALSE 39924
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
39906: LD_VAR 0 3
39910: PPUSH
39911: LD_VAR 0 7
39915: PUSH
39916: LD_INT 1
39918: ARRAY
39919: PPUSH
39920: CALL_OW 129
// end ; end ;
39924: GO 39748
39926: POP
39927: POP
// end ;
39928: GO 39237
39930: POP
39931: POP
// end ;
39932: LD_VAR 0 1
39936: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
39937: LD_INT 0
39939: PPUSH
39940: PPUSH
39941: PPUSH
39942: PPUSH
39943: PPUSH
39944: PPUSH
39945: PPUSH
39946: PPUSH
39947: PPUSH
39948: PPUSH
39949: PPUSH
// if not mc_bases then
39950: LD_EXP 76
39954: NOT
39955: IFFALSE 39959
// exit ;
39957: GO 40761
// for i = 1 to mc_bases do
39959: LD_ADDR_VAR 0 2
39963: PUSH
39964: DOUBLE
39965: LD_INT 1
39967: DEC
39968: ST_TO_ADDR
39969: LD_EXP 76
39973: PUSH
39974: FOR_TO
39975: IFFALSE 40759
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39977: LD_EXP 104
39981: PUSH
39982: LD_VAR 0 2
39986: ARRAY
39987: NOT
39988: PUSH
39989: LD_EXP 79
39993: PUSH
39994: LD_VAR 0 2
39998: ARRAY
39999: PUSH
40000: LD_INT 1
40002: ARRAY
40003: OR
40004: PUSH
40005: LD_EXP 79
40009: PUSH
40010: LD_VAR 0 2
40014: ARRAY
40015: PUSH
40016: LD_INT 2
40018: ARRAY
40019: OR
40020: PUSH
40021: LD_EXP 102
40025: PUSH
40026: LD_VAR 0 2
40030: ARRAY
40031: PPUSH
40032: LD_INT 1
40034: PPUSH
40035: CALL_OW 325
40039: NOT
40040: OR
40041: PUSH
40042: LD_EXP 99
40046: PUSH
40047: LD_VAR 0 2
40051: ARRAY
40052: OR
40053: IFFALSE 40057
// continue ;
40055: GO 39974
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40057: LD_ADDR_VAR 0 8
40061: PUSH
40062: LD_EXP 76
40066: PUSH
40067: LD_VAR 0 2
40071: ARRAY
40072: PPUSH
40073: LD_INT 25
40075: PUSH
40076: LD_INT 4
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 50
40085: PUSH
40086: EMPTY
40087: LIST
40088: PUSH
40089: LD_INT 3
40091: PUSH
40092: LD_INT 60
40094: PUSH
40095: EMPTY
40096: LIST
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: LIST
40106: PPUSH
40107: CALL_OW 72
40111: PUSH
40112: LD_EXP 80
40116: PUSH
40117: LD_VAR 0 2
40121: ARRAY
40122: DIFF
40123: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40124: LD_ADDR_VAR 0 9
40128: PUSH
40129: LD_EXP 76
40133: PUSH
40134: LD_VAR 0 2
40138: ARRAY
40139: PPUSH
40140: LD_INT 2
40142: PUSH
40143: LD_INT 30
40145: PUSH
40146: LD_INT 0
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 30
40155: PUSH
40156: LD_INT 1
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: LIST
40167: PPUSH
40168: CALL_OW 72
40172: ST_TO_ADDR
// if not tmp or not dep then
40173: LD_VAR 0 8
40177: NOT
40178: PUSH
40179: LD_VAR 0 9
40183: NOT
40184: OR
40185: IFFALSE 40189
// continue ;
40187: GO 39974
// side := GetSide ( tmp [ 1 ] ) ;
40189: LD_ADDR_VAR 0 11
40193: PUSH
40194: LD_VAR 0 8
40198: PUSH
40199: LD_INT 1
40201: ARRAY
40202: PPUSH
40203: CALL_OW 255
40207: ST_TO_ADDR
// dep := dep [ 1 ] ;
40208: LD_ADDR_VAR 0 9
40212: PUSH
40213: LD_VAR 0 9
40217: PUSH
40218: LD_INT 1
40220: ARRAY
40221: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40222: LD_ADDR_VAR 0 7
40226: PUSH
40227: LD_EXP 104
40231: PUSH
40232: LD_VAR 0 2
40236: ARRAY
40237: PPUSH
40238: LD_INT 22
40240: PUSH
40241: LD_INT 0
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 25
40250: PUSH
40251: LD_INT 12
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PPUSH
40262: CALL_OW 70
40266: PUSH
40267: LD_INT 22
40269: PUSH
40270: LD_INT 0
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 25
40279: PUSH
40280: LD_INT 12
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 91
40289: PUSH
40290: LD_VAR 0 9
40294: PUSH
40295: LD_INT 20
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: LIST
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: LIST
40307: PPUSH
40308: CALL_OW 69
40312: UNION
40313: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40314: LD_ADDR_VAR 0 10
40318: PUSH
40319: LD_EXP 104
40323: PUSH
40324: LD_VAR 0 2
40328: ARRAY
40329: PPUSH
40330: LD_INT 81
40332: PUSH
40333: LD_VAR 0 11
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PPUSH
40342: CALL_OW 70
40346: ST_TO_ADDR
// if not apes or danger_at_area then
40347: LD_VAR 0 7
40351: NOT
40352: PUSH
40353: LD_VAR 0 10
40357: OR
40358: IFFALSE 40408
// begin if mc_taming [ i ] then
40360: LD_EXP 107
40364: PUSH
40365: LD_VAR 0 2
40369: ARRAY
40370: IFFALSE 40406
// begin MC_Reset ( i , 121 ) ;
40372: LD_VAR 0 2
40376: PPUSH
40377: LD_INT 121
40379: PPUSH
40380: CALL 25398 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40384: LD_ADDR_EXP 107
40388: PUSH
40389: LD_EXP 107
40393: PPUSH
40394: LD_VAR 0 2
40398: PPUSH
40399: EMPTY
40400: PPUSH
40401: CALL_OW 1
40405: ST_TO_ADDR
// end ; continue ;
40406: GO 39974
// end ; for j in tmp do
40408: LD_ADDR_VAR 0 3
40412: PUSH
40413: LD_VAR 0 8
40417: PUSH
40418: FOR_IN
40419: IFFALSE 40755
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40421: LD_VAR 0 3
40425: PUSH
40426: LD_EXP 107
40430: PUSH
40431: LD_VAR 0 2
40435: ARRAY
40436: IN
40437: NOT
40438: PUSH
40439: LD_EXP 107
40443: PUSH
40444: LD_VAR 0 2
40448: ARRAY
40449: PUSH
40450: LD_INT 3
40452: LESS
40453: AND
40454: IFFALSE 40512
// begin SetTag ( j , 121 ) ;
40456: LD_VAR 0 3
40460: PPUSH
40461: LD_INT 121
40463: PPUSH
40464: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40468: LD_ADDR_EXP 107
40472: PUSH
40473: LD_EXP 107
40477: PPUSH
40478: LD_VAR 0 2
40482: PUSH
40483: LD_EXP 107
40487: PUSH
40488: LD_VAR 0 2
40492: ARRAY
40493: PUSH
40494: LD_INT 1
40496: PLUS
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PPUSH
40502: LD_VAR 0 3
40506: PPUSH
40507: CALL 56985 0 3
40511: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40512: LD_VAR 0 3
40516: PUSH
40517: LD_EXP 107
40521: PUSH
40522: LD_VAR 0 2
40526: ARRAY
40527: IN
40528: IFFALSE 40753
// begin if GetClass ( j ) <> 4 then
40530: LD_VAR 0 3
40534: PPUSH
40535: CALL_OW 257
40539: PUSH
40540: LD_INT 4
40542: NONEQUAL
40543: IFFALSE 40596
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40545: LD_ADDR_EXP 107
40549: PUSH
40550: LD_EXP 107
40554: PPUSH
40555: LD_VAR 0 2
40559: PPUSH
40560: LD_EXP 107
40564: PUSH
40565: LD_VAR 0 2
40569: ARRAY
40570: PUSH
40571: LD_VAR 0 3
40575: DIFF
40576: PPUSH
40577: CALL_OW 1
40581: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40582: LD_VAR 0 3
40586: PPUSH
40587: LD_INT 0
40589: PPUSH
40590: CALL_OW 109
// continue ;
40594: GO 40418
// end ; if IsInUnit ( j ) then
40596: LD_VAR 0 3
40600: PPUSH
40601: CALL_OW 310
40605: IFFALSE 40616
// ComExitBuilding ( j ) ;
40607: LD_VAR 0 3
40611: PPUSH
40612: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40616: LD_ADDR_VAR 0 6
40620: PUSH
40621: LD_VAR 0 7
40625: PPUSH
40626: LD_VAR 0 3
40630: PPUSH
40631: CALL_OW 74
40635: ST_TO_ADDR
// if not ape then
40636: LD_VAR 0 6
40640: NOT
40641: IFFALSE 40645
// break ;
40643: GO 40755
// x := GetX ( ape ) ;
40645: LD_ADDR_VAR 0 4
40649: PUSH
40650: LD_VAR 0 6
40654: PPUSH
40655: CALL_OW 250
40659: ST_TO_ADDR
// y := GetY ( ape ) ;
40660: LD_ADDR_VAR 0 5
40664: PUSH
40665: LD_VAR 0 6
40669: PPUSH
40670: CALL_OW 251
40674: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40675: LD_VAR 0 4
40679: PPUSH
40680: LD_VAR 0 5
40684: PPUSH
40685: CALL_OW 488
40689: NOT
40690: PUSH
40691: LD_VAR 0 11
40695: PPUSH
40696: LD_VAR 0 4
40700: PPUSH
40701: LD_VAR 0 5
40705: PPUSH
40706: LD_INT 20
40708: PPUSH
40709: CALL 57881 0 4
40713: PUSH
40714: LD_INT 4
40716: ARRAY
40717: OR
40718: IFFALSE 40722
// break ;
40720: GO 40755
// if not HasTask ( j ) then
40722: LD_VAR 0 3
40726: PPUSH
40727: CALL_OW 314
40731: NOT
40732: IFFALSE 40753
// ComTameXY ( j , x , y ) ;
40734: LD_VAR 0 3
40738: PPUSH
40739: LD_VAR 0 4
40743: PPUSH
40744: LD_VAR 0 5
40748: PPUSH
40749: CALL_OW 131
// end ; end ;
40753: GO 40418
40755: POP
40756: POP
// end ;
40757: GO 39974
40759: POP
40760: POP
// end ;
40761: LD_VAR 0 1
40765: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40766: LD_INT 0
40768: PPUSH
40769: PPUSH
40770: PPUSH
40771: PPUSH
40772: PPUSH
40773: PPUSH
40774: PPUSH
40775: PPUSH
// if not mc_bases then
40776: LD_EXP 76
40780: NOT
40781: IFFALSE 40785
// exit ;
40783: GO 41411
// for i = 1 to mc_bases do
40785: LD_ADDR_VAR 0 2
40789: PUSH
40790: DOUBLE
40791: LD_INT 1
40793: DEC
40794: ST_TO_ADDR
40795: LD_EXP 76
40799: PUSH
40800: FOR_TO
40801: IFFALSE 41409
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40803: LD_EXP 105
40807: PUSH
40808: LD_VAR 0 2
40812: ARRAY
40813: NOT
40814: PUSH
40815: LD_EXP 105
40819: PUSH
40820: LD_VAR 0 2
40824: ARRAY
40825: PPUSH
40826: LD_INT 25
40828: PUSH
40829: LD_INT 12
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: PPUSH
40836: CALL_OW 72
40840: NOT
40841: OR
40842: IFFALSE 40846
// continue ;
40844: GO 40800
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40846: LD_ADDR_VAR 0 5
40850: PUSH
40851: LD_EXP 105
40855: PUSH
40856: LD_VAR 0 2
40860: ARRAY
40861: PUSH
40862: LD_INT 1
40864: ARRAY
40865: PPUSH
40866: CALL_OW 255
40870: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40871: LD_VAR 0 5
40875: PPUSH
40876: LD_INT 2
40878: PPUSH
40879: CALL_OW 325
40883: IFFALSE 41136
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40885: LD_ADDR_VAR 0 4
40889: PUSH
40890: LD_EXP 105
40894: PUSH
40895: LD_VAR 0 2
40899: ARRAY
40900: PPUSH
40901: LD_INT 25
40903: PUSH
40904: LD_INT 16
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PPUSH
40911: CALL_OW 72
40915: ST_TO_ADDR
// if tmp < 6 then
40916: LD_VAR 0 4
40920: PUSH
40921: LD_INT 6
40923: LESS
40924: IFFALSE 41136
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40926: LD_ADDR_VAR 0 6
40930: PUSH
40931: LD_EXP 76
40935: PUSH
40936: LD_VAR 0 2
40940: ARRAY
40941: PPUSH
40942: LD_INT 2
40944: PUSH
40945: LD_INT 30
40947: PUSH
40948: LD_INT 0
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 30
40957: PUSH
40958: LD_INT 1
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: LIST
40969: PPUSH
40970: CALL_OW 72
40974: ST_TO_ADDR
// if depot then
40975: LD_VAR 0 6
40979: IFFALSE 41136
// begin selected := 0 ;
40981: LD_ADDR_VAR 0 7
40985: PUSH
40986: LD_INT 0
40988: ST_TO_ADDR
// for j in depot do
40989: LD_ADDR_VAR 0 3
40993: PUSH
40994: LD_VAR 0 6
40998: PUSH
40999: FOR_IN
41000: IFFALSE 41031
// begin if UnitsInside ( j ) < 6 then
41002: LD_VAR 0 3
41006: PPUSH
41007: CALL_OW 313
41011: PUSH
41012: LD_INT 6
41014: LESS
41015: IFFALSE 41029
// begin selected := j ;
41017: LD_ADDR_VAR 0 7
41021: PUSH
41022: LD_VAR 0 3
41026: ST_TO_ADDR
// break ;
41027: GO 41031
// end ; end ;
41029: GO 40999
41031: POP
41032: POP
// if selected then
41033: LD_VAR 0 7
41037: IFFALSE 41136
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41039: LD_ADDR_VAR 0 3
41043: PUSH
41044: LD_EXP 105
41048: PUSH
41049: LD_VAR 0 2
41053: ARRAY
41054: PPUSH
41055: LD_INT 25
41057: PUSH
41058: LD_INT 12
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: PPUSH
41065: CALL_OW 72
41069: PUSH
41070: FOR_IN
41071: IFFALSE 41134
// if not HasTask ( j ) then
41073: LD_VAR 0 3
41077: PPUSH
41078: CALL_OW 314
41082: NOT
41083: IFFALSE 41132
// begin if not IsInUnit ( j ) then
41085: LD_VAR 0 3
41089: PPUSH
41090: CALL_OW 310
41094: NOT
41095: IFFALSE 41111
// ComEnterUnit ( j , selected ) ;
41097: LD_VAR 0 3
41101: PPUSH
41102: LD_VAR 0 7
41106: PPUSH
41107: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41111: LD_VAR 0 3
41115: PPUSH
41116: LD_INT 16
41118: PPUSH
41119: CALL_OW 183
// AddComExitBuilding ( j ) ;
41123: LD_VAR 0 3
41127: PPUSH
41128: CALL_OW 182
// end ;
41132: GO 41070
41134: POP
41135: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41136: LD_VAR 0 5
41140: PPUSH
41141: LD_INT 11
41143: PPUSH
41144: CALL_OW 325
41148: IFFALSE 41407
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41150: LD_ADDR_VAR 0 4
41154: PUSH
41155: LD_EXP 105
41159: PUSH
41160: LD_VAR 0 2
41164: ARRAY
41165: PPUSH
41166: LD_INT 25
41168: PUSH
41169: LD_INT 16
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PPUSH
41176: CALL_OW 72
41180: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41181: LD_VAR 0 4
41185: PUSH
41186: LD_INT 6
41188: GREATEREQUAL
41189: PUSH
41190: LD_VAR 0 5
41194: PPUSH
41195: LD_INT 2
41197: PPUSH
41198: CALL_OW 325
41202: NOT
41203: OR
41204: IFFALSE 41407
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41206: LD_ADDR_VAR 0 8
41210: PUSH
41211: LD_EXP 76
41215: PUSH
41216: LD_VAR 0 2
41220: ARRAY
41221: PPUSH
41222: LD_INT 2
41224: PUSH
41225: LD_INT 30
41227: PUSH
41228: LD_INT 4
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 30
41237: PUSH
41238: LD_INT 5
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: LIST
41249: PPUSH
41250: CALL_OW 72
41254: ST_TO_ADDR
// if barracks then
41255: LD_VAR 0 8
41259: IFFALSE 41407
// begin selected := 0 ;
41261: LD_ADDR_VAR 0 7
41265: PUSH
41266: LD_INT 0
41268: ST_TO_ADDR
// for j in barracks do
41269: LD_ADDR_VAR 0 3
41273: PUSH
41274: LD_VAR 0 8
41278: PUSH
41279: FOR_IN
41280: IFFALSE 41311
// begin if UnitsInside ( j ) < 6 then
41282: LD_VAR 0 3
41286: PPUSH
41287: CALL_OW 313
41291: PUSH
41292: LD_INT 6
41294: LESS
41295: IFFALSE 41309
// begin selected := j ;
41297: LD_ADDR_VAR 0 7
41301: PUSH
41302: LD_VAR 0 3
41306: ST_TO_ADDR
// break ;
41307: GO 41311
// end ; end ;
41309: GO 41279
41311: POP
41312: POP
// if selected then
41313: LD_VAR 0 7
41317: IFFALSE 41407
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41319: LD_ADDR_VAR 0 3
41323: PUSH
41324: LD_EXP 105
41328: PUSH
41329: LD_VAR 0 2
41333: ARRAY
41334: PPUSH
41335: LD_INT 25
41337: PUSH
41338: LD_INT 12
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PPUSH
41345: CALL_OW 72
41349: PUSH
41350: FOR_IN
41351: IFFALSE 41405
// if not IsInUnit ( j ) and not HasTask ( j ) then
41353: LD_VAR 0 3
41357: PPUSH
41358: CALL_OW 310
41362: NOT
41363: PUSH
41364: LD_VAR 0 3
41368: PPUSH
41369: CALL_OW 314
41373: NOT
41374: AND
41375: IFFALSE 41403
// begin ComEnterUnit ( j , selected ) ;
41377: LD_VAR 0 3
41381: PPUSH
41382: LD_VAR 0 7
41386: PPUSH
41387: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41391: LD_VAR 0 3
41395: PPUSH
41396: LD_INT 15
41398: PPUSH
41399: CALL_OW 183
// end ;
41403: GO 41350
41405: POP
41406: POP
// end ; end ; end ; end ; end ;
41407: GO 40800
41409: POP
41410: POP
// end ;
41411: LD_VAR 0 1
41415: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41416: LD_INT 0
41418: PPUSH
41419: PPUSH
41420: PPUSH
41421: PPUSH
// if not mc_bases then
41422: LD_EXP 76
41426: NOT
41427: IFFALSE 41431
// exit ;
41429: GO 41609
// for i = 1 to mc_bases do
41431: LD_ADDR_VAR 0 2
41435: PUSH
41436: DOUBLE
41437: LD_INT 1
41439: DEC
41440: ST_TO_ADDR
41441: LD_EXP 76
41445: PUSH
41446: FOR_TO
41447: IFFALSE 41607
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41449: LD_ADDR_VAR 0 4
41453: PUSH
41454: LD_EXP 76
41458: PUSH
41459: LD_VAR 0 2
41463: ARRAY
41464: PPUSH
41465: LD_INT 25
41467: PUSH
41468: LD_INT 9
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PPUSH
41475: CALL_OW 72
41479: ST_TO_ADDR
// if not tmp then
41480: LD_VAR 0 4
41484: NOT
41485: IFFALSE 41489
// continue ;
41487: GO 41446
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41489: LD_EXP 102
41493: PUSH
41494: LD_VAR 0 2
41498: ARRAY
41499: PPUSH
41500: LD_INT 29
41502: PPUSH
41503: CALL_OW 325
41507: NOT
41508: PUSH
41509: LD_EXP 102
41513: PUSH
41514: LD_VAR 0 2
41518: ARRAY
41519: PPUSH
41520: LD_INT 28
41522: PPUSH
41523: CALL_OW 325
41527: NOT
41528: AND
41529: IFFALSE 41533
// continue ;
41531: GO 41446
// for j in tmp do
41533: LD_ADDR_VAR 0 3
41537: PUSH
41538: LD_VAR 0 4
41542: PUSH
41543: FOR_IN
41544: IFFALSE 41603
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41546: LD_VAR 0 3
41550: PUSH
41551: LD_EXP 79
41555: PUSH
41556: LD_VAR 0 2
41560: ARRAY
41561: PUSH
41562: LD_INT 1
41564: ARRAY
41565: IN
41566: NOT
41567: PUSH
41568: LD_VAR 0 3
41572: PUSH
41573: LD_EXP 79
41577: PUSH
41578: LD_VAR 0 2
41582: ARRAY
41583: PUSH
41584: LD_INT 2
41586: ARRAY
41587: IN
41588: NOT
41589: AND
41590: IFFALSE 41601
// ComSpaceTimeShoot ( j ) ;
41592: LD_VAR 0 3
41596: PPUSH
41597: CALL 52795 0 1
41601: GO 41543
41603: POP
41604: POP
// end ;
41605: GO 41446
41607: POP
41608: POP
// end ;
41609: LD_VAR 0 1
41613: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41614: LD_INT 0
41616: PPUSH
41617: PPUSH
41618: PPUSH
41619: PPUSH
41620: PPUSH
41621: PPUSH
41622: PPUSH
41623: PPUSH
41624: PPUSH
// if not mc_bases then
41625: LD_EXP 76
41629: NOT
41630: IFFALSE 41634
// exit ;
41632: GO 42256
// for i = 1 to mc_bases do
41634: LD_ADDR_VAR 0 2
41638: PUSH
41639: DOUBLE
41640: LD_INT 1
41642: DEC
41643: ST_TO_ADDR
41644: LD_EXP 76
41648: PUSH
41649: FOR_TO
41650: IFFALSE 42254
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41652: LD_EXP 111
41656: PUSH
41657: LD_VAR 0 2
41661: ARRAY
41662: NOT
41663: PUSH
41664: LD_INT 38
41666: PPUSH
41667: LD_EXP 102
41671: PUSH
41672: LD_VAR 0 2
41676: ARRAY
41677: PPUSH
41678: CALL_OW 321
41682: PUSH
41683: LD_INT 2
41685: NONEQUAL
41686: OR
41687: IFFALSE 41691
// continue ;
41689: GO 41649
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41691: LD_ADDR_VAR 0 8
41695: PUSH
41696: LD_EXP 76
41700: PUSH
41701: LD_VAR 0 2
41705: ARRAY
41706: PPUSH
41707: LD_INT 30
41709: PUSH
41710: LD_INT 34
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PPUSH
41717: CALL_OW 72
41721: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41722: LD_ADDR_VAR 0 9
41726: PUSH
41727: LD_EXP 76
41731: PUSH
41732: LD_VAR 0 2
41736: ARRAY
41737: PPUSH
41738: LD_INT 25
41740: PUSH
41741: LD_INT 4
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PPUSH
41748: CALL_OW 72
41752: PPUSH
41753: LD_INT 0
41755: PPUSH
41756: CALL 86798 0 2
41760: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41761: LD_VAR 0 9
41765: NOT
41766: PUSH
41767: LD_VAR 0 8
41771: NOT
41772: OR
41773: PUSH
41774: LD_EXP 76
41778: PUSH
41779: LD_VAR 0 2
41783: ARRAY
41784: PPUSH
41785: LD_INT 124
41787: PPUSH
41788: CALL 86798 0 2
41792: OR
41793: IFFALSE 41797
// continue ;
41795: GO 41649
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41797: LD_EXP 112
41801: PUSH
41802: LD_VAR 0 2
41806: ARRAY
41807: PUSH
41808: LD_EXP 111
41812: PUSH
41813: LD_VAR 0 2
41817: ARRAY
41818: LESS
41819: PUSH
41820: LD_EXP 112
41824: PUSH
41825: LD_VAR 0 2
41829: ARRAY
41830: PUSH
41831: LD_VAR 0 8
41835: LESS
41836: AND
41837: IFFALSE 42252
// begin tmp := sci [ 1 ] ;
41839: LD_ADDR_VAR 0 7
41843: PUSH
41844: LD_VAR 0 9
41848: PUSH
41849: LD_INT 1
41851: ARRAY
41852: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41853: LD_VAR 0 7
41857: PPUSH
41858: LD_INT 124
41860: PPUSH
41861: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41865: LD_ADDR_VAR 0 3
41869: PUSH
41870: DOUBLE
41871: LD_EXP 111
41875: PUSH
41876: LD_VAR 0 2
41880: ARRAY
41881: INC
41882: ST_TO_ADDR
41883: LD_EXP 111
41887: PUSH
41888: LD_VAR 0 2
41892: ARRAY
41893: PUSH
41894: FOR_DOWNTO
41895: IFFALSE 42238
// begin if IsInUnit ( tmp ) then
41897: LD_VAR 0 7
41901: PPUSH
41902: CALL_OW 310
41906: IFFALSE 41917
// ComExitBuilding ( tmp ) ;
41908: LD_VAR 0 7
41912: PPUSH
41913: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
41917: LD_INT 35
41919: PPUSH
41920: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
41924: LD_VAR 0 7
41928: PPUSH
41929: CALL_OW 310
41933: NOT
41934: PUSH
41935: LD_VAR 0 7
41939: PPUSH
41940: CALL_OW 314
41944: NOT
41945: AND
41946: IFFALSE 41917
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
41948: LD_ADDR_VAR 0 6
41952: PUSH
41953: LD_VAR 0 7
41957: PPUSH
41958: CALL_OW 250
41962: PUSH
41963: LD_VAR 0 7
41967: PPUSH
41968: CALL_OW 251
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41977: LD_INT 35
41979: PPUSH
41980: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41984: LD_ADDR_VAR 0 4
41988: PUSH
41989: LD_EXP 111
41993: PUSH
41994: LD_VAR 0 2
41998: ARRAY
41999: PUSH
42000: LD_VAR 0 3
42004: ARRAY
42005: PUSH
42006: LD_INT 1
42008: ARRAY
42009: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42010: LD_ADDR_VAR 0 5
42014: PUSH
42015: LD_EXP 111
42019: PUSH
42020: LD_VAR 0 2
42024: ARRAY
42025: PUSH
42026: LD_VAR 0 3
42030: ARRAY
42031: PUSH
42032: LD_INT 2
42034: ARRAY
42035: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42036: LD_VAR 0 7
42040: PPUSH
42041: LD_INT 10
42043: PPUSH
42044: CALL 59582 0 2
42048: PUSH
42049: LD_INT 4
42051: ARRAY
42052: IFFALSE 42090
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42054: LD_VAR 0 7
42058: PPUSH
42059: LD_VAR 0 6
42063: PUSH
42064: LD_INT 1
42066: ARRAY
42067: PPUSH
42068: LD_VAR 0 6
42072: PUSH
42073: LD_INT 2
42075: ARRAY
42076: PPUSH
42077: CALL_OW 111
// wait ( 0 0$10 ) ;
42081: LD_INT 350
42083: PPUSH
42084: CALL_OW 67
// end else
42088: GO 42116
// begin ComMoveXY ( tmp , x , y ) ;
42090: LD_VAR 0 7
42094: PPUSH
42095: LD_VAR 0 4
42099: PPUSH
42100: LD_VAR 0 5
42104: PPUSH
42105: CALL_OW 111
// wait ( 0 0$3 ) ;
42109: LD_INT 105
42111: PPUSH
42112: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42116: LD_VAR 0 7
42120: PPUSH
42121: LD_VAR 0 4
42125: PPUSH
42126: LD_VAR 0 5
42130: PPUSH
42131: CALL_OW 307
42135: IFFALSE 41977
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42137: LD_VAR 0 7
42141: PPUSH
42142: LD_VAR 0 4
42146: PPUSH
42147: LD_VAR 0 5
42151: PPUSH
42152: LD_VAR 0 8
42156: PUSH
42157: LD_VAR 0 3
42161: ARRAY
42162: PPUSH
42163: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42167: LD_INT 35
42169: PPUSH
42170: CALL_OW 67
// until not HasTask ( tmp ) ;
42174: LD_VAR 0 7
42178: PPUSH
42179: CALL_OW 314
42183: NOT
42184: IFFALSE 42167
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42186: LD_ADDR_EXP 112
42190: PUSH
42191: LD_EXP 112
42195: PPUSH
42196: LD_VAR 0 2
42200: PUSH
42201: LD_EXP 112
42205: PUSH
42206: LD_VAR 0 2
42210: ARRAY
42211: PUSH
42212: LD_INT 1
42214: PLUS
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PPUSH
42220: LD_VAR 0 8
42224: PUSH
42225: LD_VAR 0 3
42229: ARRAY
42230: PPUSH
42231: CALL 56985 0 3
42235: ST_TO_ADDR
// end ;
42236: GO 41894
42238: POP
42239: POP
// MC_Reset ( i , 124 ) ;
42240: LD_VAR 0 2
42244: PPUSH
42245: LD_INT 124
42247: PPUSH
42248: CALL 25398 0 2
// end ; end ;
42252: GO 41649
42254: POP
42255: POP
// end ;
42256: LD_VAR 0 1
42260: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42261: LD_INT 0
42263: PPUSH
42264: PPUSH
42265: PPUSH
// if not mc_bases then
42266: LD_EXP 76
42270: NOT
42271: IFFALSE 42275
// exit ;
42273: GO 42881
// for i = 1 to mc_bases do
42275: LD_ADDR_VAR 0 2
42279: PUSH
42280: DOUBLE
42281: LD_INT 1
42283: DEC
42284: ST_TO_ADDR
42285: LD_EXP 76
42289: PUSH
42290: FOR_TO
42291: IFFALSE 42879
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42293: LD_ADDR_VAR 0 3
42297: PUSH
42298: LD_EXP 76
42302: PUSH
42303: LD_VAR 0 2
42307: ARRAY
42308: PPUSH
42309: LD_INT 25
42311: PUSH
42312: LD_INT 4
42314: PUSH
42315: EMPTY
42316: LIST
42317: LIST
42318: PPUSH
42319: CALL_OW 72
42323: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42324: LD_VAR 0 3
42328: NOT
42329: PUSH
42330: LD_EXP 113
42334: PUSH
42335: LD_VAR 0 2
42339: ARRAY
42340: NOT
42341: OR
42342: PUSH
42343: LD_EXP 76
42347: PUSH
42348: LD_VAR 0 2
42352: ARRAY
42353: PPUSH
42354: LD_INT 2
42356: PUSH
42357: LD_INT 30
42359: PUSH
42360: LD_INT 0
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: LD_INT 30
42369: PUSH
42370: LD_INT 1
42372: PUSH
42373: EMPTY
42374: LIST
42375: LIST
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: LIST
42381: PPUSH
42382: CALL_OW 72
42386: NOT
42387: OR
42388: IFFALSE 42438
// begin if mc_deposits_finder [ i ] then
42390: LD_EXP 114
42394: PUSH
42395: LD_VAR 0 2
42399: ARRAY
42400: IFFALSE 42436
// begin MC_Reset ( i , 125 ) ;
42402: LD_VAR 0 2
42406: PPUSH
42407: LD_INT 125
42409: PPUSH
42410: CALL 25398 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42414: LD_ADDR_EXP 114
42418: PUSH
42419: LD_EXP 114
42423: PPUSH
42424: LD_VAR 0 2
42428: PPUSH
42429: EMPTY
42430: PPUSH
42431: CALL_OW 1
42435: ST_TO_ADDR
// end ; continue ;
42436: GO 42290
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42438: LD_EXP 113
42442: PUSH
42443: LD_VAR 0 2
42447: ARRAY
42448: PUSH
42449: LD_INT 1
42451: ARRAY
42452: PUSH
42453: LD_INT 3
42455: ARRAY
42456: PUSH
42457: LD_INT 1
42459: EQUAL
42460: PUSH
42461: LD_INT 20
42463: PPUSH
42464: LD_EXP 102
42468: PUSH
42469: LD_VAR 0 2
42473: ARRAY
42474: PPUSH
42475: CALL_OW 321
42479: PUSH
42480: LD_INT 2
42482: NONEQUAL
42483: AND
42484: IFFALSE 42534
// begin if mc_deposits_finder [ i ] then
42486: LD_EXP 114
42490: PUSH
42491: LD_VAR 0 2
42495: ARRAY
42496: IFFALSE 42532
// begin MC_Reset ( i , 125 ) ;
42498: LD_VAR 0 2
42502: PPUSH
42503: LD_INT 125
42505: PPUSH
42506: CALL 25398 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42510: LD_ADDR_EXP 114
42514: PUSH
42515: LD_EXP 114
42519: PPUSH
42520: LD_VAR 0 2
42524: PPUSH
42525: EMPTY
42526: PPUSH
42527: CALL_OW 1
42531: ST_TO_ADDR
// end ; continue ;
42532: GO 42290
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42534: LD_EXP 113
42538: PUSH
42539: LD_VAR 0 2
42543: ARRAY
42544: PUSH
42545: LD_INT 1
42547: ARRAY
42548: PUSH
42549: LD_INT 1
42551: ARRAY
42552: PPUSH
42553: LD_EXP 113
42557: PUSH
42558: LD_VAR 0 2
42562: ARRAY
42563: PUSH
42564: LD_INT 1
42566: ARRAY
42567: PUSH
42568: LD_INT 2
42570: ARRAY
42571: PPUSH
42572: LD_EXP 102
42576: PUSH
42577: LD_VAR 0 2
42581: ARRAY
42582: PPUSH
42583: CALL_OW 440
42587: IFFALSE 42630
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42589: LD_ADDR_EXP 113
42593: PUSH
42594: LD_EXP 113
42598: PPUSH
42599: LD_VAR 0 2
42603: PPUSH
42604: LD_EXP 113
42608: PUSH
42609: LD_VAR 0 2
42613: ARRAY
42614: PPUSH
42615: LD_INT 1
42617: PPUSH
42618: CALL_OW 3
42622: PPUSH
42623: CALL_OW 1
42627: ST_TO_ADDR
42628: GO 42877
// begin if not mc_deposits_finder [ i ] then
42630: LD_EXP 114
42634: PUSH
42635: LD_VAR 0 2
42639: ARRAY
42640: NOT
42641: IFFALSE 42693
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42643: LD_ADDR_EXP 114
42647: PUSH
42648: LD_EXP 114
42652: PPUSH
42653: LD_VAR 0 2
42657: PPUSH
42658: LD_VAR 0 3
42662: PUSH
42663: LD_INT 1
42665: ARRAY
42666: PUSH
42667: EMPTY
42668: LIST
42669: PPUSH
42670: CALL_OW 1
42674: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42675: LD_VAR 0 3
42679: PUSH
42680: LD_INT 1
42682: ARRAY
42683: PPUSH
42684: LD_INT 125
42686: PPUSH
42687: CALL_OW 109
// end else
42691: GO 42877
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42693: LD_EXP 114
42697: PUSH
42698: LD_VAR 0 2
42702: ARRAY
42703: PUSH
42704: LD_INT 1
42706: ARRAY
42707: PPUSH
42708: CALL_OW 310
42712: IFFALSE 42735
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42714: LD_EXP 114
42718: PUSH
42719: LD_VAR 0 2
42723: ARRAY
42724: PUSH
42725: LD_INT 1
42727: ARRAY
42728: PPUSH
42729: CALL_OW 122
42733: GO 42877
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42735: LD_EXP 114
42739: PUSH
42740: LD_VAR 0 2
42744: ARRAY
42745: PUSH
42746: LD_INT 1
42748: ARRAY
42749: PPUSH
42750: CALL_OW 314
42754: NOT
42755: PUSH
42756: LD_EXP 114
42760: PUSH
42761: LD_VAR 0 2
42765: ARRAY
42766: PUSH
42767: LD_INT 1
42769: ARRAY
42770: PPUSH
42771: LD_EXP 113
42775: PUSH
42776: LD_VAR 0 2
42780: ARRAY
42781: PUSH
42782: LD_INT 1
42784: ARRAY
42785: PUSH
42786: LD_INT 1
42788: ARRAY
42789: PPUSH
42790: LD_EXP 113
42794: PUSH
42795: LD_VAR 0 2
42799: ARRAY
42800: PUSH
42801: LD_INT 1
42803: ARRAY
42804: PUSH
42805: LD_INT 2
42807: ARRAY
42808: PPUSH
42809: CALL_OW 297
42813: PUSH
42814: LD_INT 6
42816: GREATER
42817: AND
42818: IFFALSE 42877
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42820: LD_EXP 114
42824: PUSH
42825: LD_VAR 0 2
42829: ARRAY
42830: PUSH
42831: LD_INT 1
42833: ARRAY
42834: PPUSH
42835: LD_EXP 113
42839: PUSH
42840: LD_VAR 0 2
42844: ARRAY
42845: PUSH
42846: LD_INT 1
42848: ARRAY
42849: PUSH
42850: LD_INT 1
42852: ARRAY
42853: PPUSH
42854: LD_EXP 113
42858: PUSH
42859: LD_VAR 0 2
42863: ARRAY
42864: PUSH
42865: LD_INT 1
42867: ARRAY
42868: PUSH
42869: LD_INT 2
42871: ARRAY
42872: PPUSH
42873: CALL_OW 111
// end ; end ; end ;
42877: GO 42290
42879: POP
42880: POP
// end ;
42881: LD_VAR 0 1
42885: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
42886: LD_INT 0
42888: PPUSH
42889: PPUSH
42890: PPUSH
42891: PPUSH
42892: PPUSH
42893: PPUSH
42894: PPUSH
42895: PPUSH
42896: PPUSH
42897: PPUSH
42898: PPUSH
// if not mc_bases then
42899: LD_EXP 76
42903: NOT
42904: IFFALSE 42908
// exit ;
42906: GO 43848
// for i = 1 to mc_bases do
42908: LD_ADDR_VAR 0 2
42912: PUSH
42913: DOUBLE
42914: LD_INT 1
42916: DEC
42917: ST_TO_ADDR
42918: LD_EXP 76
42922: PUSH
42923: FOR_TO
42924: IFFALSE 43846
// begin if not mc_bases [ i ] or mc_scan [ i ] then
42926: LD_EXP 76
42930: PUSH
42931: LD_VAR 0 2
42935: ARRAY
42936: NOT
42937: PUSH
42938: LD_EXP 99
42942: PUSH
42943: LD_VAR 0 2
42947: ARRAY
42948: OR
42949: IFFALSE 42953
// continue ;
42951: GO 42923
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
42953: LD_ADDR_VAR 0 7
42957: PUSH
42958: LD_EXP 76
42962: PUSH
42963: LD_VAR 0 2
42967: ARRAY
42968: PUSH
42969: LD_INT 1
42971: ARRAY
42972: PPUSH
42973: CALL_OW 248
42977: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42978: LD_VAR 0 7
42982: PUSH
42983: LD_INT 3
42985: EQUAL
42986: PUSH
42987: LD_EXP 95
42991: PUSH
42992: LD_VAR 0 2
42996: ARRAY
42997: PUSH
42998: LD_EXP 98
43002: PUSH
43003: LD_VAR 0 2
43007: ARRAY
43008: UNION
43009: PPUSH
43010: LD_INT 33
43012: PUSH
43013: LD_INT 2
43015: PUSH
43016: EMPTY
43017: LIST
43018: LIST
43019: PPUSH
43020: CALL_OW 72
43024: NOT
43025: OR
43026: IFFALSE 43030
// continue ;
43028: GO 42923
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43030: LD_ADDR_VAR 0 9
43034: PUSH
43035: LD_EXP 76
43039: PUSH
43040: LD_VAR 0 2
43044: ARRAY
43045: PPUSH
43046: LD_INT 30
43048: PUSH
43049: LD_INT 36
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PPUSH
43056: CALL_OW 72
43060: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43061: LD_ADDR_VAR 0 10
43065: PUSH
43066: LD_EXP 95
43070: PUSH
43071: LD_VAR 0 2
43075: ARRAY
43076: PPUSH
43077: LD_INT 34
43079: PUSH
43080: LD_INT 31
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PPUSH
43087: CALL_OW 72
43091: ST_TO_ADDR
// if not cts and not mcts then
43092: LD_VAR 0 9
43096: NOT
43097: PUSH
43098: LD_VAR 0 10
43102: NOT
43103: AND
43104: IFFALSE 43108
// continue ;
43106: GO 42923
// x := cts ;
43108: LD_ADDR_VAR 0 11
43112: PUSH
43113: LD_VAR 0 9
43117: ST_TO_ADDR
// if not x then
43118: LD_VAR 0 11
43122: NOT
43123: IFFALSE 43135
// x := mcts ;
43125: LD_ADDR_VAR 0 11
43129: PUSH
43130: LD_VAR 0 10
43134: ST_TO_ADDR
// if not x then
43135: LD_VAR 0 11
43139: NOT
43140: IFFALSE 43144
// continue ;
43142: GO 42923
// if mc_remote_driver [ i ] then
43144: LD_EXP 116
43148: PUSH
43149: LD_VAR 0 2
43153: ARRAY
43154: IFFALSE 43541
// for j in mc_remote_driver [ i ] do
43156: LD_ADDR_VAR 0 3
43160: PUSH
43161: LD_EXP 116
43165: PUSH
43166: LD_VAR 0 2
43170: ARRAY
43171: PUSH
43172: FOR_IN
43173: IFFALSE 43539
// begin if GetClass ( j ) <> 3 then
43175: LD_VAR 0 3
43179: PPUSH
43180: CALL_OW 257
43184: PUSH
43185: LD_INT 3
43187: NONEQUAL
43188: IFFALSE 43241
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43190: LD_ADDR_EXP 116
43194: PUSH
43195: LD_EXP 116
43199: PPUSH
43200: LD_VAR 0 2
43204: PPUSH
43205: LD_EXP 116
43209: PUSH
43210: LD_VAR 0 2
43214: ARRAY
43215: PUSH
43216: LD_VAR 0 3
43220: DIFF
43221: PPUSH
43222: CALL_OW 1
43226: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43227: LD_VAR 0 3
43231: PPUSH
43232: LD_INT 0
43234: PPUSH
43235: CALL_OW 109
// continue ;
43239: GO 43172
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43241: LD_EXP 95
43245: PUSH
43246: LD_VAR 0 2
43250: ARRAY
43251: PPUSH
43252: LD_INT 34
43254: PUSH
43255: LD_INT 31
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: LD_INT 58
43264: PUSH
43265: EMPTY
43266: LIST
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PPUSH
43272: CALL_OW 72
43276: PUSH
43277: LD_VAR 0 3
43281: PPUSH
43282: CALL 86833 0 1
43286: NOT
43287: AND
43288: IFFALSE 43359
// begin if IsInUnit ( j ) then
43290: LD_VAR 0 3
43294: PPUSH
43295: CALL_OW 310
43299: IFFALSE 43310
// ComExitBuilding ( j ) ;
43301: LD_VAR 0 3
43305: PPUSH
43306: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43310: LD_VAR 0 3
43314: PPUSH
43315: LD_EXP 95
43319: PUSH
43320: LD_VAR 0 2
43324: ARRAY
43325: PPUSH
43326: LD_INT 34
43328: PUSH
43329: LD_INT 31
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: PUSH
43336: LD_INT 58
43338: PUSH
43339: EMPTY
43340: LIST
43341: PUSH
43342: EMPTY
43343: LIST
43344: LIST
43345: PPUSH
43346: CALL_OW 72
43350: PUSH
43351: LD_INT 1
43353: ARRAY
43354: PPUSH
43355: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43359: LD_VAR 0 3
43363: PPUSH
43364: CALL_OW 310
43368: NOT
43369: PUSH
43370: LD_VAR 0 3
43374: PPUSH
43375: CALL_OW 310
43379: PPUSH
43380: CALL_OW 266
43384: PUSH
43385: LD_INT 36
43387: NONEQUAL
43388: PUSH
43389: LD_VAR 0 3
43393: PPUSH
43394: CALL 86833 0 1
43398: NOT
43399: AND
43400: OR
43401: IFFALSE 43537
// begin if IsInUnit ( j ) then
43403: LD_VAR 0 3
43407: PPUSH
43408: CALL_OW 310
43412: IFFALSE 43423
// ComExitBuilding ( j ) ;
43414: LD_VAR 0 3
43418: PPUSH
43419: CALL_OW 122
// ct := 0 ;
43423: LD_ADDR_VAR 0 8
43427: PUSH
43428: LD_INT 0
43430: ST_TO_ADDR
// for k in x do
43431: LD_ADDR_VAR 0 4
43435: PUSH
43436: LD_VAR 0 11
43440: PUSH
43441: FOR_IN
43442: IFFALSE 43515
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43444: LD_VAR 0 4
43448: PPUSH
43449: CALL_OW 264
43453: PUSH
43454: LD_INT 31
43456: EQUAL
43457: PUSH
43458: LD_VAR 0 4
43462: PPUSH
43463: CALL_OW 311
43467: NOT
43468: AND
43469: PUSH
43470: LD_VAR 0 4
43474: PPUSH
43475: CALL_OW 266
43479: PUSH
43480: LD_INT 36
43482: EQUAL
43483: PUSH
43484: LD_VAR 0 4
43488: PPUSH
43489: CALL_OW 313
43493: PUSH
43494: LD_INT 3
43496: LESS
43497: AND
43498: OR
43499: IFFALSE 43513
// begin ct := k ;
43501: LD_ADDR_VAR 0 8
43505: PUSH
43506: LD_VAR 0 4
43510: ST_TO_ADDR
// break ;
43511: GO 43515
// end ;
43513: GO 43441
43515: POP
43516: POP
// if ct then
43517: LD_VAR 0 8
43521: IFFALSE 43537
// ComEnterUnit ( j , ct ) ;
43523: LD_VAR 0 3
43527: PPUSH
43528: LD_VAR 0 8
43532: PPUSH
43533: CALL_OW 120
// end ; end ;
43537: GO 43172
43539: POP
43540: POP
// places := 0 ;
43541: LD_ADDR_VAR 0 5
43545: PUSH
43546: LD_INT 0
43548: ST_TO_ADDR
// for j = 1 to x do
43549: LD_ADDR_VAR 0 3
43553: PUSH
43554: DOUBLE
43555: LD_INT 1
43557: DEC
43558: ST_TO_ADDR
43559: LD_VAR 0 11
43563: PUSH
43564: FOR_TO
43565: IFFALSE 43641
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43567: LD_VAR 0 11
43571: PUSH
43572: LD_VAR 0 3
43576: ARRAY
43577: PPUSH
43578: CALL_OW 264
43582: PUSH
43583: LD_INT 31
43585: EQUAL
43586: IFFALSE 43604
// places := places + 1 else
43588: LD_ADDR_VAR 0 5
43592: PUSH
43593: LD_VAR 0 5
43597: PUSH
43598: LD_INT 1
43600: PLUS
43601: ST_TO_ADDR
43602: GO 43639
// if GetBType ( x [ j ] ) = b_control_tower then
43604: LD_VAR 0 11
43608: PUSH
43609: LD_VAR 0 3
43613: ARRAY
43614: PPUSH
43615: CALL_OW 266
43619: PUSH
43620: LD_INT 36
43622: EQUAL
43623: IFFALSE 43639
// places := places + 3 ;
43625: LD_ADDR_VAR 0 5
43629: PUSH
43630: LD_VAR 0 5
43634: PUSH
43635: LD_INT 3
43637: PLUS
43638: ST_TO_ADDR
43639: GO 43564
43641: POP
43642: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43643: LD_VAR 0 5
43647: PUSH
43648: LD_INT 0
43650: EQUAL
43651: PUSH
43652: LD_VAR 0 5
43656: PUSH
43657: LD_EXP 116
43661: PUSH
43662: LD_VAR 0 2
43666: ARRAY
43667: LESSEQUAL
43668: OR
43669: IFFALSE 43673
// continue ;
43671: GO 42923
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43673: LD_ADDR_VAR 0 6
43677: PUSH
43678: LD_EXP 76
43682: PUSH
43683: LD_VAR 0 2
43687: ARRAY
43688: PPUSH
43689: LD_INT 25
43691: PUSH
43692: LD_INT 3
43694: PUSH
43695: EMPTY
43696: LIST
43697: LIST
43698: PPUSH
43699: CALL_OW 72
43703: PUSH
43704: LD_EXP 116
43708: PUSH
43709: LD_VAR 0 2
43713: ARRAY
43714: DIFF
43715: PPUSH
43716: LD_INT 3
43718: PPUSH
43719: CALL 87733 0 2
43723: ST_TO_ADDR
// for j in tmp do
43724: LD_ADDR_VAR 0 3
43728: PUSH
43729: LD_VAR 0 6
43733: PUSH
43734: FOR_IN
43735: IFFALSE 43770
// if GetTag ( j ) > 0 then
43737: LD_VAR 0 3
43741: PPUSH
43742: CALL_OW 110
43746: PUSH
43747: LD_INT 0
43749: GREATER
43750: IFFALSE 43768
// tmp := tmp diff j ;
43752: LD_ADDR_VAR 0 6
43756: PUSH
43757: LD_VAR 0 6
43761: PUSH
43762: LD_VAR 0 3
43766: DIFF
43767: ST_TO_ADDR
43768: GO 43734
43770: POP
43771: POP
// if not tmp then
43772: LD_VAR 0 6
43776: NOT
43777: IFFALSE 43781
// continue ;
43779: GO 42923
// if places then
43781: LD_VAR 0 5
43785: IFFALSE 43844
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43787: LD_ADDR_EXP 116
43791: PUSH
43792: LD_EXP 116
43796: PPUSH
43797: LD_VAR 0 2
43801: PPUSH
43802: LD_EXP 116
43806: PUSH
43807: LD_VAR 0 2
43811: ARRAY
43812: PUSH
43813: LD_VAR 0 6
43817: PUSH
43818: LD_INT 1
43820: ARRAY
43821: UNION
43822: PPUSH
43823: CALL_OW 1
43827: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43828: LD_VAR 0 6
43832: PUSH
43833: LD_INT 1
43835: ARRAY
43836: PPUSH
43837: LD_INT 126
43839: PPUSH
43840: CALL_OW 109
// end ; end ;
43844: GO 42923
43846: POP
43847: POP
// end ;
43848: LD_VAR 0 1
43852: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43853: LD_INT 0
43855: PPUSH
43856: PPUSH
43857: PPUSH
43858: PPUSH
43859: PPUSH
43860: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43861: LD_VAR 0 1
43865: NOT
43866: PUSH
43867: LD_VAR 0 2
43871: NOT
43872: OR
43873: PUSH
43874: LD_VAR 0 3
43878: NOT
43879: OR
43880: PUSH
43881: LD_VAR 0 4
43885: PUSH
43886: LD_INT 1
43888: PUSH
43889: LD_INT 2
43891: PUSH
43892: LD_INT 3
43894: PUSH
43895: LD_INT 4
43897: PUSH
43898: LD_INT 5
43900: PUSH
43901: LD_INT 8
43903: PUSH
43904: LD_INT 9
43906: PUSH
43907: LD_INT 15
43909: PUSH
43910: LD_INT 16
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: LIST
43923: IN
43924: NOT
43925: OR
43926: IFFALSE 43930
// exit ;
43928: GO 44830
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
43930: LD_ADDR_VAR 0 2
43934: PUSH
43935: LD_VAR 0 2
43939: PPUSH
43940: LD_INT 21
43942: PUSH
43943: LD_INT 3
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 24
43952: PUSH
43953: LD_INT 250
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PPUSH
43964: CALL_OW 72
43968: ST_TO_ADDR
// case class of 1 , 15 :
43969: LD_VAR 0 4
43973: PUSH
43974: LD_INT 1
43976: DOUBLE
43977: EQUAL
43978: IFTRUE 43988
43980: LD_INT 15
43982: DOUBLE
43983: EQUAL
43984: IFTRUE 43988
43986: GO 44073
43988: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43989: LD_ADDR_VAR 0 8
43993: PUSH
43994: LD_VAR 0 2
43998: PPUSH
43999: LD_INT 2
44001: PUSH
44002: LD_INT 30
44004: PUSH
44005: LD_INT 32
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 30
44014: PUSH
44015: LD_INT 31
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: LIST
44026: PPUSH
44027: CALL_OW 72
44031: PUSH
44032: LD_VAR 0 2
44036: PPUSH
44037: LD_INT 2
44039: PUSH
44040: LD_INT 30
44042: PUSH
44043: LD_INT 4
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 30
44052: PUSH
44053: LD_INT 5
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: LIST
44064: PPUSH
44065: CALL_OW 72
44069: ADD
44070: ST_TO_ADDR
44071: GO 44319
44073: LD_INT 2
44075: DOUBLE
44076: EQUAL
44077: IFTRUE 44087
44079: LD_INT 16
44081: DOUBLE
44082: EQUAL
44083: IFTRUE 44087
44085: GO 44133
44087: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44088: LD_ADDR_VAR 0 8
44092: PUSH
44093: LD_VAR 0 2
44097: PPUSH
44098: LD_INT 2
44100: PUSH
44101: LD_INT 30
44103: PUSH
44104: LD_INT 0
44106: PUSH
44107: EMPTY
44108: LIST
44109: LIST
44110: PUSH
44111: LD_INT 30
44113: PUSH
44114: LD_INT 1
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: LIST
44125: PPUSH
44126: CALL_OW 72
44130: ST_TO_ADDR
44131: GO 44319
44133: LD_INT 3
44135: DOUBLE
44136: EQUAL
44137: IFTRUE 44141
44139: GO 44187
44141: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44142: LD_ADDR_VAR 0 8
44146: PUSH
44147: LD_VAR 0 2
44151: PPUSH
44152: LD_INT 2
44154: PUSH
44155: LD_INT 30
44157: PUSH
44158: LD_INT 2
44160: PUSH
44161: EMPTY
44162: LIST
44163: LIST
44164: PUSH
44165: LD_INT 30
44167: PUSH
44168: LD_INT 3
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: LIST
44179: PPUSH
44180: CALL_OW 72
44184: ST_TO_ADDR
44185: GO 44319
44187: LD_INT 4
44189: DOUBLE
44190: EQUAL
44191: IFTRUE 44195
44193: GO 44252
44195: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44196: LD_ADDR_VAR 0 8
44200: PUSH
44201: LD_VAR 0 2
44205: PPUSH
44206: LD_INT 2
44208: PUSH
44209: LD_INT 30
44211: PUSH
44212: LD_INT 6
44214: PUSH
44215: EMPTY
44216: LIST
44217: LIST
44218: PUSH
44219: LD_INT 30
44221: PUSH
44222: LD_INT 7
44224: PUSH
44225: EMPTY
44226: LIST
44227: LIST
44228: PUSH
44229: LD_INT 30
44231: PUSH
44232: LD_INT 8
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: PPUSH
44245: CALL_OW 72
44249: ST_TO_ADDR
44250: GO 44319
44252: LD_INT 5
44254: DOUBLE
44255: EQUAL
44256: IFTRUE 44272
44258: LD_INT 8
44260: DOUBLE
44261: EQUAL
44262: IFTRUE 44272
44264: LD_INT 9
44266: DOUBLE
44267: EQUAL
44268: IFTRUE 44272
44270: GO 44318
44272: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44273: LD_ADDR_VAR 0 8
44277: PUSH
44278: LD_VAR 0 2
44282: PPUSH
44283: LD_INT 2
44285: PUSH
44286: LD_INT 30
44288: PUSH
44289: LD_INT 4
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 30
44298: PUSH
44299: LD_INT 5
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: LIST
44310: PPUSH
44311: CALL_OW 72
44315: ST_TO_ADDR
44316: GO 44319
44318: POP
// if not tmp then
44319: LD_VAR 0 8
44323: NOT
44324: IFFALSE 44328
// exit ;
44326: GO 44830
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44328: LD_VAR 0 4
44332: PUSH
44333: LD_INT 1
44335: PUSH
44336: LD_INT 15
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: IN
44343: PUSH
44344: LD_EXP 85
44348: PUSH
44349: LD_VAR 0 1
44353: ARRAY
44354: AND
44355: IFFALSE 44511
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44357: LD_ADDR_VAR 0 9
44361: PUSH
44362: LD_EXP 85
44366: PUSH
44367: LD_VAR 0 1
44371: ARRAY
44372: PUSH
44373: LD_INT 1
44375: ARRAY
44376: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44377: LD_VAR 0 9
44381: PUSH
44382: LD_EXP 86
44386: PUSH
44387: LD_VAR 0 1
44391: ARRAY
44392: IN
44393: NOT
44394: IFFALSE 44509
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44396: LD_ADDR_EXP 86
44400: PUSH
44401: LD_EXP 86
44405: PPUSH
44406: LD_VAR 0 1
44410: PUSH
44411: LD_EXP 86
44415: PUSH
44416: LD_VAR 0 1
44420: ARRAY
44421: PUSH
44422: LD_INT 1
44424: PLUS
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PPUSH
44430: LD_VAR 0 9
44434: PPUSH
44435: CALL 56985 0 3
44439: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44440: LD_ADDR_EXP 85
44444: PUSH
44445: LD_EXP 85
44449: PPUSH
44450: LD_VAR 0 1
44454: PPUSH
44455: LD_EXP 85
44459: PUSH
44460: LD_VAR 0 1
44464: ARRAY
44465: PUSH
44466: LD_VAR 0 9
44470: DIFF
44471: PPUSH
44472: CALL_OW 1
44476: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44477: LD_VAR 0 3
44481: PPUSH
44482: LD_EXP 86
44486: PUSH
44487: LD_VAR 0 1
44491: ARRAY
44492: PUSH
44493: LD_EXP 86
44497: PUSH
44498: LD_VAR 0 1
44502: ARRAY
44503: ARRAY
44504: PPUSH
44505: CALL_OW 120
// end ; exit ;
44509: GO 44830
// end ; if tmp > 1 then
44511: LD_VAR 0 8
44515: PUSH
44516: LD_INT 1
44518: GREATER
44519: IFFALSE 44623
// for i = 2 to tmp do
44521: LD_ADDR_VAR 0 6
44525: PUSH
44526: DOUBLE
44527: LD_INT 2
44529: DEC
44530: ST_TO_ADDR
44531: LD_VAR 0 8
44535: PUSH
44536: FOR_TO
44537: IFFALSE 44621
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44539: LD_VAR 0 8
44543: PUSH
44544: LD_VAR 0 6
44548: ARRAY
44549: PPUSH
44550: CALL_OW 461
44554: PUSH
44555: LD_INT 6
44557: EQUAL
44558: IFFALSE 44619
// begin x := tmp [ i ] ;
44560: LD_ADDR_VAR 0 9
44564: PUSH
44565: LD_VAR 0 8
44569: PUSH
44570: LD_VAR 0 6
44574: ARRAY
44575: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44576: LD_ADDR_VAR 0 8
44580: PUSH
44581: LD_VAR 0 8
44585: PPUSH
44586: LD_VAR 0 6
44590: PPUSH
44591: CALL_OW 3
44595: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44596: LD_ADDR_VAR 0 8
44600: PUSH
44601: LD_VAR 0 8
44605: PPUSH
44606: LD_INT 1
44608: PPUSH
44609: LD_VAR 0 9
44613: PPUSH
44614: CALL_OW 2
44618: ST_TO_ADDR
// end ;
44619: GO 44536
44621: POP
44622: POP
// for i in tmp do
44623: LD_ADDR_VAR 0 6
44627: PUSH
44628: LD_VAR 0 8
44632: PUSH
44633: FOR_IN
44634: IFFALSE 44703
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44636: LD_VAR 0 6
44640: PPUSH
44641: CALL_OW 313
44645: PUSH
44646: LD_INT 6
44648: LESS
44649: PUSH
44650: LD_VAR 0 6
44654: PPUSH
44655: CALL_OW 266
44659: PUSH
44660: LD_INT 31
44662: PUSH
44663: LD_INT 32
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: IN
44670: NOT
44671: AND
44672: PUSH
44673: LD_VAR 0 6
44677: PPUSH
44678: CALL_OW 313
44682: PUSH
44683: LD_INT 0
44685: EQUAL
44686: OR
44687: IFFALSE 44701
// begin j := i ;
44689: LD_ADDR_VAR 0 7
44693: PUSH
44694: LD_VAR 0 6
44698: ST_TO_ADDR
// break ;
44699: GO 44703
// end ; end ;
44701: GO 44633
44703: POP
44704: POP
// if j then
44705: LD_VAR 0 7
44709: IFFALSE 44727
// ComEnterUnit ( unit , j ) else
44711: LD_VAR 0 3
44715: PPUSH
44716: LD_VAR 0 7
44720: PPUSH
44721: CALL_OW 120
44725: GO 44830
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44727: LD_ADDR_VAR 0 10
44731: PUSH
44732: LD_VAR 0 2
44736: PPUSH
44737: LD_INT 2
44739: PUSH
44740: LD_INT 30
44742: PUSH
44743: LD_INT 0
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 30
44752: PUSH
44753: LD_INT 1
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: LIST
44764: PPUSH
44765: CALL_OW 72
44769: ST_TO_ADDR
// if depot then
44770: LD_VAR 0 10
44774: IFFALSE 44830
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44776: LD_ADDR_VAR 0 10
44780: PUSH
44781: LD_VAR 0 10
44785: PPUSH
44786: LD_VAR 0 3
44790: PPUSH
44791: CALL_OW 74
44795: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44796: LD_VAR 0 3
44800: PPUSH
44801: LD_VAR 0 10
44805: PPUSH
44806: CALL_OW 296
44810: PUSH
44811: LD_INT 10
44813: GREATER
44814: IFFALSE 44830
// ComStandNearbyBuilding ( unit , depot ) ;
44816: LD_VAR 0 3
44820: PPUSH
44821: LD_VAR 0 10
44825: PPUSH
44826: CALL 53412 0 2
// end ; end ; end ;
44830: LD_VAR 0 5
44834: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44835: LD_INT 0
44837: PPUSH
44838: PPUSH
44839: PPUSH
44840: PPUSH
// if not mc_bases then
44841: LD_EXP 76
44845: NOT
44846: IFFALSE 44850
// exit ;
44848: GO 45089
// for i = 1 to mc_bases do
44850: LD_ADDR_VAR 0 2
44854: PUSH
44855: DOUBLE
44856: LD_INT 1
44858: DEC
44859: ST_TO_ADDR
44860: LD_EXP 76
44864: PUSH
44865: FOR_TO
44866: IFFALSE 45087
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44868: LD_ADDR_VAR 0 4
44872: PUSH
44873: LD_EXP 76
44877: PUSH
44878: LD_VAR 0 2
44882: ARRAY
44883: PPUSH
44884: LD_INT 21
44886: PUSH
44887: LD_INT 1
44889: PUSH
44890: EMPTY
44891: LIST
44892: LIST
44893: PPUSH
44894: CALL_OW 72
44898: PUSH
44899: LD_EXP 105
44903: PUSH
44904: LD_VAR 0 2
44908: ARRAY
44909: UNION
44910: ST_TO_ADDR
// if not tmp then
44911: LD_VAR 0 4
44915: NOT
44916: IFFALSE 44920
// continue ;
44918: GO 44865
// for j in tmp do
44920: LD_ADDR_VAR 0 3
44924: PUSH
44925: LD_VAR 0 4
44929: PUSH
44930: FOR_IN
44931: IFFALSE 45083
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
44933: LD_VAR 0 3
44937: PPUSH
44938: CALL_OW 110
44942: NOT
44943: PUSH
44944: LD_VAR 0 3
44948: PPUSH
44949: CALL_OW 314
44953: NOT
44954: AND
44955: PUSH
44956: LD_VAR 0 3
44960: PPUSH
44961: CALL_OW 311
44965: NOT
44966: AND
44967: PUSH
44968: LD_VAR 0 3
44972: PPUSH
44973: CALL_OW 310
44977: NOT
44978: AND
44979: PUSH
44980: LD_VAR 0 3
44984: PUSH
44985: LD_EXP 79
44989: PUSH
44990: LD_VAR 0 2
44994: ARRAY
44995: PUSH
44996: LD_INT 1
44998: ARRAY
44999: IN
45000: NOT
45001: AND
45002: PUSH
45003: LD_VAR 0 3
45007: PUSH
45008: LD_EXP 79
45012: PUSH
45013: LD_VAR 0 2
45017: ARRAY
45018: PUSH
45019: LD_INT 2
45021: ARRAY
45022: IN
45023: NOT
45024: AND
45025: PUSH
45026: LD_VAR 0 3
45030: PUSH
45031: LD_EXP 88
45035: PUSH
45036: LD_VAR 0 2
45040: ARRAY
45041: IN
45042: NOT
45043: AND
45044: IFFALSE 45081
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45046: LD_VAR 0 2
45050: PPUSH
45051: LD_EXP 76
45055: PUSH
45056: LD_VAR 0 2
45060: ARRAY
45061: PPUSH
45062: LD_VAR 0 3
45066: PPUSH
45067: LD_VAR 0 3
45071: PPUSH
45072: CALL_OW 257
45076: PPUSH
45077: CALL 43853 0 4
// end ;
45081: GO 44930
45083: POP
45084: POP
// end ;
45085: GO 44865
45087: POP
45088: POP
// end ;
45089: LD_VAR 0 1
45093: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
45094: LD_INT 0
45096: PPUSH
45097: PPUSH
45098: PPUSH
45099: PPUSH
45100: PPUSH
45101: PPUSH
// if not mc_bases [ base ] then
45102: LD_EXP 76
45106: PUSH
45107: LD_VAR 0 1
45111: ARRAY
45112: NOT
45113: IFFALSE 45117
// exit ;
45115: GO 45299
// tmp := [ ] ;
45117: LD_ADDR_VAR 0 6
45121: PUSH
45122: EMPTY
45123: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45124: LD_ADDR_VAR 0 7
45128: PUSH
45129: LD_VAR 0 3
45133: PPUSH
45134: LD_INT 0
45136: PPUSH
45137: CALL_OW 517
45141: ST_TO_ADDR
// if not list then
45142: LD_VAR 0 7
45146: NOT
45147: IFFALSE 45151
// exit ;
45149: GO 45299
// for i = 1 to amount do
45151: LD_ADDR_VAR 0 5
45155: PUSH
45156: DOUBLE
45157: LD_INT 1
45159: DEC
45160: ST_TO_ADDR
45161: LD_VAR 0 2
45165: PUSH
45166: FOR_TO
45167: IFFALSE 45247
// begin x := rand ( 1 , list [ 1 ] ) ;
45169: LD_ADDR_VAR 0 8
45173: PUSH
45174: LD_INT 1
45176: PPUSH
45177: LD_VAR 0 7
45181: PUSH
45182: LD_INT 1
45184: ARRAY
45185: PPUSH
45186: CALL_OW 12
45190: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
45191: LD_ADDR_VAR 0 6
45195: PUSH
45196: LD_VAR 0 6
45200: PPUSH
45201: LD_VAR 0 5
45205: PPUSH
45206: LD_VAR 0 7
45210: PUSH
45211: LD_INT 1
45213: ARRAY
45214: PUSH
45215: LD_VAR 0 8
45219: ARRAY
45220: PUSH
45221: LD_VAR 0 7
45225: PUSH
45226: LD_INT 2
45228: ARRAY
45229: PUSH
45230: LD_VAR 0 8
45234: ARRAY
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: PPUSH
45240: CALL_OW 1
45244: ST_TO_ADDR
// end ;
45245: GO 45166
45247: POP
45248: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45249: LD_ADDR_EXP 89
45253: PUSH
45254: LD_EXP 89
45258: PPUSH
45259: LD_VAR 0 1
45263: PPUSH
45264: LD_VAR 0 6
45268: PPUSH
45269: CALL_OW 1
45273: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45274: LD_ADDR_EXP 91
45278: PUSH
45279: LD_EXP 91
45283: PPUSH
45284: LD_VAR 0 1
45288: PPUSH
45289: LD_VAR 0 3
45293: PPUSH
45294: CALL_OW 1
45298: ST_TO_ADDR
// end ;
45299: LD_VAR 0 4
45303: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45304: LD_INT 0
45306: PPUSH
// if not mc_bases [ base ] then
45307: LD_EXP 76
45311: PUSH
45312: LD_VAR 0 1
45316: ARRAY
45317: NOT
45318: IFFALSE 45322
// exit ;
45320: GO 45347
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45322: LD_ADDR_EXP 81
45326: PUSH
45327: LD_EXP 81
45331: PPUSH
45332: LD_VAR 0 1
45336: PPUSH
45337: LD_VAR 0 2
45341: PPUSH
45342: CALL_OW 1
45346: ST_TO_ADDR
// end ;
45347: LD_VAR 0 3
45351: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45352: LD_INT 0
45354: PPUSH
// if not mc_bases [ base ] then
45355: LD_EXP 76
45359: PUSH
45360: LD_VAR 0 1
45364: ARRAY
45365: NOT
45366: IFFALSE 45370
// exit ;
45368: GO 45407
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45370: LD_ADDR_EXP 81
45374: PUSH
45375: LD_EXP 81
45379: PPUSH
45380: LD_VAR 0 1
45384: PPUSH
45385: LD_EXP 81
45389: PUSH
45390: LD_VAR 0 1
45394: ARRAY
45395: PUSH
45396: LD_VAR 0 2
45400: UNION
45401: PPUSH
45402: CALL_OW 1
45406: ST_TO_ADDR
// end ;
45407: LD_VAR 0 3
45411: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45412: LD_INT 0
45414: PPUSH
// if not mc_bases [ base ] then
45415: LD_EXP 76
45419: PUSH
45420: LD_VAR 0 1
45424: ARRAY
45425: NOT
45426: IFFALSE 45430
// exit ;
45428: GO 45455
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45430: LD_ADDR_EXP 97
45434: PUSH
45435: LD_EXP 97
45439: PPUSH
45440: LD_VAR 0 1
45444: PPUSH
45445: LD_VAR 0 2
45449: PPUSH
45450: CALL_OW 1
45454: ST_TO_ADDR
// end ;
45455: LD_VAR 0 3
45459: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45460: LD_INT 0
45462: PPUSH
// if not mc_bases [ base ] then
45463: LD_EXP 76
45467: PUSH
45468: LD_VAR 0 1
45472: ARRAY
45473: NOT
45474: IFFALSE 45478
// exit ;
45476: GO 45515
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45478: LD_ADDR_EXP 97
45482: PUSH
45483: LD_EXP 97
45487: PPUSH
45488: LD_VAR 0 1
45492: PPUSH
45493: LD_EXP 97
45497: PUSH
45498: LD_VAR 0 1
45502: ARRAY
45503: PUSH
45504: LD_VAR 0 2
45508: ADD
45509: PPUSH
45510: CALL_OW 1
45514: ST_TO_ADDR
// end ;
45515: LD_VAR 0 3
45519: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45520: LD_INT 0
45522: PPUSH
// if not mc_bases [ base ] then
45523: LD_EXP 76
45527: PUSH
45528: LD_VAR 0 1
45532: ARRAY
45533: NOT
45534: IFFALSE 45538
// exit ;
45536: GO 45592
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45538: LD_ADDR_EXP 98
45542: PUSH
45543: LD_EXP 98
45547: PPUSH
45548: LD_VAR 0 1
45552: PPUSH
45553: LD_VAR 0 2
45557: PPUSH
45558: CALL_OW 1
45562: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45563: LD_ADDR_EXP 87
45567: PUSH
45568: LD_EXP 87
45572: PPUSH
45573: LD_VAR 0 1
45577: PPUSH
45578: LD_VAR 0 2
45582: PUSH
45583: LD_INT 0
45585: PLUS
45586: PPUSH
45587: CALL_OW 1
45591: ST_TO_ADDR
// end ;
45592: LD_VAR 0 3
45596: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45597: LD_INT 0
45599: PPUSH
// if not mc_bases [ base ] then
45600: LD_EXP 76
45604: PUSH
45605: LD_VAR 0 1
45609: ARRAY
45610: NOT
45611: IFFALSE 45615
// exit ;
45613: GO 45640
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45615: LD_ADDR_EXP 87
45619: PUSH
45620: LD_EXP 87
45624: PPUSH
45625: LD_VAR 0 1
45629: PPUSH
45630: LD_VAR 0 2
45634: PPUSH
45635: CALL_OW 1
45639: ST_TO_ADDR
// end ;
45640: LD_VAR 0 3
45644: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45645: LD_INT 0
45647: PPUSH
45648: PPUSH
45649: PPUSH
45650: PPUSH
// if not mc_bases [ base ] then
45651: LD_EXP 76
45655: PUSH
45656: LD_VAR 0 1
45660: ARRAY
45661: NOT
45662: IFFALSE 45666
// exit ;
45664: GO 45731
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45666: LD_ADDR_EXP 96
45670: PUSH
45671: LD_EXP 96
45675: PPUSH
45676: LD_VAR 0 1
45680: PUSH
45681: LD_EXP 96
45685: PUSH
45686: LD_VAR 0 1
45690: ARRAY
45691: PUSH
45692: LD_INT 1
45694: PLUS
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: PPUSH
45700: LD_VAR 0 1
45704: PUSH
45705: LD_VAR 0 2
45709: PUSH
45710: LD_VAR 0 3
45714: PUSH
45715: LD_VAR 0 4
45719: PUSH
45720: EMPTY
45721: LIST
45722: LIST
45723: LIST
45724: LIST
45725: PPUSH
45726: CALL 56985 0 3
45730: ST_TO_ADDR
// end ;
45731: LD_VAR 0 5
45735: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45736: LD_INT 0
45738: PPUSH
// if not mc_bases [ base ] then
45739: LD_EXP 76
45743: PUSH
45744: LD_VAR 0 1
45748: ARRAY
45749: NOT
45750: IFFALSE 45754
// exit ;
45752: GO 45779
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45754: LD_ADDR_EXP 113
45758: PUSH
45759: LD_EXP 113
45763: PPUSH
45764: LD_VAR 0 1
45768: PPUSH
45769: LD_VAR 0 2
45773: PPUSH
45774: CALL_OW 1
45778: ST_TO_ADDR
// end ;
45779: LD_VAR 0 3
45783: RET
// export function MC_GetMinesField ( base ) ; begin
45784: LD_INT 0
45786: PPUSH
// result := mc_mines [ base ] ;
45787: LD_ADDR_VAR 0 2
45791: PUSH
45792: LD_EXP 89
45796: PUSH
45797: LD_VAR 0 1
45801: ARRAY
45802: ST_TO_ADDR
// end ;
45803: LD_VAR 0 2
45807: RET
// export function MC_GetProduceList ( base ) ; begin
45808: LD_INT 0
45810: PPUSH
// result := mc_produce [ base ] ;
45811: LD_ADDR_VAR 0 2
45815: PUSH
45816: LD_EXP 97
45820: PUSH
45821: LD_VAR 0 1
45825: ARRAY
45826: ST_TO_ADDR
// end ;
45827: LD_VAR 0 2
45831: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45832: LD_INT 0
45834: PPUSH
45835: PPUSH
// if not mc_bases then
45836: LD_EXP 76
45840: NOT
45841: IFFALSE 45845
// exit ;
45843: GO 45910
// if mc_bases [ base ] then
45845: LD_EXP 76
45849: PUSH
45850: LD_VAR 0 1
45854: ARRAY
45855: IFFALSE 45910
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45857: LD_ADDR_VAR 0 3
45861: PUSH
45862: LD_EXP 76
45866: PUSH
45867: LD_VAR 0 1
45871: ARRAY
45872: PPUSH
45873: LD_INT 30
45875: PUSH
45876: LD_VAR 0 2
45880: PUSH
45881: EMPTY
45882: LIST
45883: LIST
45884: PPUSH
45885: CALL_OW 72
45889: ST_TO_ADDR
// if result then
45890: LD_VAR 0 3
45894: IFFALSE 45910
// result := result [ 1 ] ;
45896: LD_ADDR_VAR 0 3
45900: PUSH
45901: LD_VAR 0 3
45905: PUSH
45906: LD_INT 1
45908: ARRAY
45909: ST_TO_ADDR
// end ; end ;
45910: LD_VAR 0 3
45914: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
45915: LD_INT 0
45917: PPUSH
45918: PPUSH
// if not mc_bases then
45919: LD_EXP 76
45923: NOT
45924: IFFALSE 45928
// exit ;
45926: GO 45973
// if mc_bases [ base ] then
45928: LD_EXP 76
45932: PUSH
45933: LD_VAR 0 1
45937: ARRAY
45938: IFFALSE 45973
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45940: LD_ADDR_VAR 0 3
45944: PUSH
45945: LD_EXP 76
45949: PUSH
45950: LD_VAR 0 1
45954: ARRAY
45955: PPUSH
45956: LD_INT 30
45958: PUSH
45959: LD_VAR 0 2
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: PPUSH
45968: CALL_OW 72
45972: ST_TO_ADDR
// end ;
45973: LD_VAR 0 3
45977: RET
// export function MC_SetTame ( base , area ) ; begin
45978: LD_INT 0
45980: PPUSH
// if not mc_bases or not base then
45981: LD_EXP 76
45985: NOT
45986: PUSH
45987: LD_VAR 0 1
45991: NOT
45992: OR
45993: IFFALSE 45997
// exit ;
45995: GO 46022
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45997: LD_ADDR_EXP 104
46001: PUSH
46002: LD_EXP 104
46006: PPUSH
46007: LD_VAR 0 1
46011: PPUSH
46012: LD_VAR 0 2
46016: PPUSH
46017: CALL_OW 1
46021: ST_TO_ADDR
// end ;
46022: LD_VAR 0 3
46026: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46027: LD_INT 0
46029: PPUSH
46030: PPUSH
// if not mc_bases or not base then
46031: LD_EXP 76
46035: NOT
46036: PUSH
46037: LD_VAR 0 1
46041: NOT
46042: OR
46043: IFFALSE 46047
// exit ;
46045: GO 46149
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46047: LD_ADDR_VAR 0 4
46051: PUSH
46052: LD_EXP 76
46056: PUSH
46057: LD_VAR 0 1
46061: ARRAY
46062: PPUSH
46063: LD_INT 30
46065: PUSH
46066: LD_VAR 0 2
46070: PUSH
46071: EMPTY
46072: LIST
46073: LIST
46074: PPUSH
46075: CALL_OW 72
46079: ST_TO_ADDR
// if not tmp then
46080: LD_VAR 0 4
46084: NOT
46085: IFFALSE 46089
// exit ;
46087: GO 46149
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46089: LD_ADDR_EXP 108
46093: PUSH
46094: LD_EXP 108
46098: PPUSH
46099: LD_VAR 0 1
46103: PPUSH
46104: LD_EXP 108
46108: PUSH
46109: LD_VAR 0 1
46113: ARRAY
46114: PPUSH
46115: LD_EXP 108
46119: PUSH
46120: LD_VAR 0 1
46124: ARRAY
46125: PUSH
46126: LD_INT 1
46128: PLUS
46129: PPUSH
46130: LD_VAR 0 4
46134: PUSH
46135: LD_INT 1
46137: ARRAY
46138: PPUSH
46139: CALL_OW 2
46143: PPUSH
46144: CALL_OW 1
46148: ST_TO_ADDR
// end ;
46149: LD_VAR 0 3
46153: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46154: LD_INT 0
46156: PPUSH
46157: PPUSH
// if not mc_bases or not base or not kinds then
46158: LD_EXP 76
46162: NOT
46163: PUSH
46164: LD_VAR 0 1
46168: NOT
46169: OR
46170: PUSH
46171: LD_VAR 0 2
46175: NOT
46176: OR
46177: IFFALSE 46181
// exit ;
46179: GO 46242
// for i in kinds do
46181: LD_ADDR_VAR 0 4
46185: PUSH
46186: LD_VAR 0 2
46190: PUSH
46191: FOR_IN
46192: IFFALSE 46240
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46194: LD_ADDR_EXP 110
46198: PUSH
46199: LD_EXP 110
46203: PPUSH
46204: LD_VAR 0 1
46208: PUSH
46209: LD_EXP 110
46213: PUSH
46214: LD_VAR 0 1
46218: ARRAY
46219: PUSH
46220: LD_INT 1
46222: PLUS
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: PPUSH
46228: LD_VAR 0 4
46232: PPUSH
46233: CALL 56985 0 3
46237: ST_TO_ADDR
46238: GO 46191
46240: POP
46241: POP
// end ;
46242: LD_VAR 0 3
46246: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46247: LD_INT 0
46249: PPUSH
// if not mc_bases or not base or not areas then
46250: LD_EXP 76
46254: NOT
46255: PUSH
46256: LD_VAR 0 1
46260: NOT
46261: OR
46262: PUSH
46263: LD_VAR 0 2
46267: NOT
46268: OR
46269: IFFALSE 46273
// exit ;
46271: GO 46298
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46273: LD_ADDR_EXP 94
46277: PUSH
46278: LD_EXP 94
46282: PPUSH
46283: LD_VAR 0 1
46287: PPUSH
46288: LD_VAR 0 2
46292: PPUSH
46293: CALL_OW 1
46297: ST_TO_ADDR
// end ;
46298: LD_VAR 0 3
46302: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46303: LD_INT 0
46305: PPUSH
// if not mc_bases or not base or not teleports_exit then
46306: LD_EXP 76
46310: NOT
46311: PUSH
46312: LD_VAR 0 1
46316: NOT
46317: OR
46318: PUSH
46319: LD_VAR 0 2
46323: NOT
46324: OR
46325: IFFALSE 46329
// exit ;
46327: GO 46354
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46329: LD_ADDR_EXP 111
46333: PUSH
46334: LD_EXP 111
46338: PPUSH
46339: LD_VAR 0 1
46343: PPUSH
46344: LD_VAR 0 2
46348: PPUSH
46349: CALL_OW 1
46353: ST_TO_ADDR
// end ;
46354: LD_VAR 0 3
46358: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46359: LD_INT 0
46361: PPUSH
46362: PPUSH
46363: PPUSH
// if not mc_bases or not base or not ext_list then
46364: LD_EXP 76
46368: NOT
46369: PUSH
46370: LD_VAR 0 1
46374: NOT
46375: OR
46376: PUSH
46377: LD_VAR 0 5
46381: NOT
46382: OR
46383: IFFALSE 46387
// exit ;
46385: GO 46560
// tmp := GetFacExtXYD ( x , y , d ) ;
46387: LD_ADDR_VAR 0 8
46391: PUSH
46392: LD_VAR 0 2
46396: PPUSH
46397: LD_VAR 0 3
46401: PPUSH
46402: LD_VAR 0 4
46406: PPUSH
46407: CALL 86863 0 3
46411: ST_TO_ADDR
// if not tmp then
46412: LD_VAR 0 8
46416: NOT
46417: IFFALSE 46421
// exit ;
46419: GO 46560
// for i in tmp do
46421: LD_ADDR_VAR 0 7
46425: PUSH
46426: LD_VAR 0 8
46430: PUSH
46431: FOR_IN
46432: IFFALSE 46558
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46434: LD_ADDR_EXP 81
46438: PUSH
46439: LD_EXP 81
46443: PPUSH
46444: LD_VAR 0 1
46448: PPUSH
46449: LD_EXP 81
46453: PUSH
46454: LD_VAR 0 1
46458: ARRAY
46459: PPUSH
46460: LD_EXP 81
46464: PUSH
46465: LD_VAR 0 1
46469: ARRAY
46470: PUSH
46471: LD_INT 1
46473: PLUS
46474: PPUSH
46475: LD_VAR 0 5
46479: PUSH
46480: LD_INT 1
46482: ARRAY
46483: PUSH
46484: LD_VAR 0 7
46488: PUSH
46489: LD_INT 1
46491: ARRAY
46492: PUSH
46493: LD_VAR 0 7
46497: PUSH
46498: LD_INT 2
46500: ARRAY
46501: PUSH
46502: LD_VAR 0 7
46506: PUSH
46507: LD_INT 3
46509: ARRAY
46510: PUSH
46511: EMPTY
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: PPUSH
46517: CALL_OW 2
46521: PPUSH
46522: CALL_OW 1
46526: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46527: LD_ADDR_VAR 0 5
46531: PUSH
46532: LD_VAR 0 5
46536: PPUSH
46537: LD_INT 1
46539: PPUSH
46540: CALL_OW 3
46544: ST_TO_ADDR
// if not ext_list then
46545: LD_VAR 0 5
46549: NOT
46550: IFFALSE 46556
// exit ;
46552: POP
46553: POP
46554: GO 46560
// end ;
46556: GO 46431
46558: POP
46559: POP
// end ;
46560: LD_VAR 0 6
46564: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46565: LD_INT 0
46567: PPUSH
// if not mc_bases or not base or not weapon_list then
46568: LD_EXP 76
46572: NOT
46573: PUSH
46574: LD_VAR 0 1
46578: NOT
46579: OR
46580: PUSH
46581: LD_VAR 0 2
46585: NOT
46586: OR
46587: IFFALSE 46591
// exit ;
46589: GO 46616
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46591: LD_ADDR_EXP 115
46595: PUSH
46596: LD_EXP 115
46600: PPUSH
46601: LD_VAR 0 1
46605: PPUSH
46606: LD_VAR 0 2
46610: PPUSH
46611: CALL_OW 1
46615: ST_TO_ADDR
// end ;
46616: LD_VAR 0 3
46620: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46621: LD_INT 0
46623: PPUSH
// if not mc_bases or not base or not tech_list then
46624: LD_EXP 76
46628: NOT
46629: PUSH
46630: LD_VAR 0 1
46634: NOT
46635: OR
46636: PUSH
46637: LD_VAR 0 2
46641: NOT
46642: OR
46643: IFFALSE 46647
// exit ;
46645: GO 46672
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46647: LD_ADDR_EXP 103
46651: PUSH
46652: LD_EXP 103
46656: PPUSH
46657: LD_VAR 0 1
46661: PPUSH
46662: LD_VAR 0 2
46666: PPUSH
46667: CALL_OW 1
46671: ST_TO_ADDR
// end ;
46672: LD_VAR 0 3
46676: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46677: LD_INT 0
46679: PPUSH
// if not mc_bases or not parking_area or not base then
46680: LD_EXP 76
46684: NOT
46685: PUSH
46686: LD_VAR 0 2
46690: NOT
46691: OR
46692: PUSH
46693: LD_VAR 0 1
46697: NOT
46698: OR
46699: IFFALSE 46703
// exit ;
46701: GO 46728
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46703: LD_ADDR_EXP 100
46707: PUSH
46708: LD_EXP 100
46712: PPUSH
46713: LD_VAR 0 1
46717: PPUSH
46718: LD_VAR 0 2
46722: PPUSH
46723: CALL_OW 1
46727: ST_TO_ADDR
// end ;
46728: LD_VAR 0 3
46732: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46733: LD_INT 0
46735: PPUSH
// if not mc_bases or not base or not scan_area then
46736: LD_EXP 76
46740: NOT
46741: PUSH
46742: LD_VAR 0 1
46746: NOT
46747: OR
46748: PUSH
46749: LD_VAR 0 2
46753: NOT
46754: OR
46755: IFFALSE 46759
// exit ;
46757: GO 46784
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46759: LD_ADDR_EXP 101
46763: PUSH
46764: LD_EXP 101
46768: PPUSH
46769: LD_VAR 0 1
46773: PPUSH
46774: LD_VAR 0 2
46778: PPUSH
46779: CALL_OW 1
46783: ST_TO_ADDR
// end ;
46784: LD_VAR 0 3
46788: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46789: LD_INT 0
46791: PPUSH
46792: PPUSH
// if not mc_bases or not base then
46793: LD_EXP 76
46797: NOT
46798: PUSH
46799: LD_VAR 0 1
46803: NOT
46804: OR
46805: IFFALSE 46809
// exit ;
46807: GO 46873
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46809: LD_ADDR_VAR 0 3
46813: PUSH
46814: LD_INT 1
46816: PUSH
46817: LD_INT 2
46819: PUSH
46820: LD_INT 3
46822: PUSH
46823: LD_INT 4
46825: PUSH
46826: LD_INT 11
46828: PUSH
46829: EMPTY
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: LIST
46835: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46836: LD_ADDR_EXP 103
46840: PUSH
46841: LD_EXP 103
46845: PPUSH
46846: LD_VAR 0 1
46850: PPUSH
46851: LD_EXP 103
46855: PUSH
46856: LD_VAR 0 1
46860: ARRAY
46861: PUSH
46862: LD_VAR 0 3
46866: DIFF
46867: PPUSH
46868: CALL_OW 1
46872: ST_TO_ADDR
// end ;
46873: LD_VAR 0 2
46877: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
46878: LD_INT 0
46880: PPUSH
// result := mc_vehicles [ base ] ;
46881: LD_ADDR_VAR 0 3
46885: PUSH
46886: LD_EXP 95
46890: PUSH
46891: LD_VAR 0 1
46895: ARRAY
46896: ST_TO_ADDR
// if onlyCombat then
46897: LD_VAR 0 2
46901: IFFALSE 47073
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
46903: LD_ADDR_VAR 0 3
46907: PUSH
46908: LD_VAR 0 3
46912: PUSH
46913: LD_VAR 0 3
46917: PPUSH
46918: LD_INT 2
46920: PUSH
46921: LD_INT 34
46923: PUSH
46924: LD_INT 12
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PUSH
46931: LD_INT 34
46933: PUSH
46934: LD_INT 51
46936: PUSH
46937: EMPTY
46938: LIST
46939: LIST
46940: PUSH
46941: LD_INT 34
46943: PUSH
46944: LD_INT 89
46946: PUSH
46947: EMPTY
46948: LIST
46949: LIST
46950: PUSH
46951: LD_INT 34
46953: PUSH
46954: LD_INT 32
46956: PUSH
46957: EMPTY
46958: LIST
46959: LIST
46960: PUSH
46961: LD_INT 34
46963: PUSH
46964: LD_INT 13
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PUSH
46971: LD_INT 34
46973: PUSH
46974: LD_INT 52
46976: PUSH
46977: EMPTY
46978: LIST
46979: LIST
46980: PUSH
46981: LD_INT 34
46983: PUSH
46984: LD_INT 88
46986: PUSH
46987: EMPTY
46988: LIST
46989: LIST
46990: PUSH
46991: LD_INT 34
46993: PUSH
46994: LD_INT 14
46996: PUSH
46997: EMPTY
46998: LIST
46999: LIST
47000: PUSH
47001: LD_INT 34
47003: PUSH
47004: LD_INT 53
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: PUSH
47011: LD_INT 34
47013: PUSH
47014: LD_INT 98
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: PUSH
47021: LD_INT 34
47023: PUSH
47024: LD_INT 31
47026: PUSH
47027: EMPTY
47028: LIST
47029: LIST
47030: PUSH
47031: LD_INT 34
47033: PUSH
47034: LD_INT 48
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PUSH
47041: LD_INT 34
47043: PUSH
47044: LD_INT 8
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: PPUSH
47067: CALL_OW 72
47071: DIFF
47072: ST_TO_ADDR
// end ; end_of_file
47073: LD_VAR 0 3
47077: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47078: LD_INT 0
47080: PPUSH
47081: PPUSH
47082: PPUSH
// if not mc_bases or not skirmish then
47083: LD_EXP 76
47087: NOT
47088: PUSH
47089: LD_EXP 74
47093: NOT
47094: OR
47095: IFFALSE 47099
// exit ;
47097: GO 47264
// for i = 1 to mc_bases do
47099: LD_ADDR_VAR 0 4
47103: PUSH
47104: DOUBLE
47105: LD_INT 1
47107: DEC
47108: ST_TO_ADDR
47109: LD_EXP 76
47113: PUSH
47114: FOR_TO
47115: IFFALSE 47262
// begin if sci in mc_bases [ i ] then
47117: LD_VAR 0 2
47121: PUSH
47122: LD_EXP 76
47126: PUSH
47127: LD_VAR 0 4
47131: ARRAY
47132: IN
47133: IFFALSE 47260
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47135: LD_ADDR_EXP 105
47139: PUSH
47140: LD_EXP 105
47144: PPUSH
47145: LD_VAR 0 4
47149: PUSH
47150: LD_EXP 105
47154: PUSH
47155: LD_VAR 0 4
47159: ARRAY
47160: PUSH
47161: LD_INT 1
47163: PLUS
47164: PUSH
47165: EMPTY
47166: LIST
47167: LIST
47168: PPUSH
47169: LD_VAR 0 1
47173: PPUSH
47174: CALL 56985 0 3
47178: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47179: LD_ADDR_VAR 0 5
47183: PUSH
47184: LD_EXP 76
47188: PUSH
47189: LD_VAR 0 4
47193: ARRAY
47194: PPUSH
47195: LD_INT 2
47197: PUSH
47198: LD_INT 30
47200: PUSH
47201: LD_INT 0
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 30
47210: PUSH
47211: LD_INT 1
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: LIST
47222: PPUSH
47223: CALL_OW 72
47227: PPUSH
47228: LD_VAR 0 1
47232: PPUSH
47233: CALL_OW 74
47237: ST_TO_ADDR
// if tmp then
47238: LD_VAR 0 5
47242: IFFALSE 47258
// ComStandNearbyBuilding ( ape , tmp ) ;
47244: LD_VAR 0 1
47248: PPUSH
47249: LD_VAR 0 5
47253: PPUSH
47254: CALL 53412 0 2
// break ;
47258: GO 47262
// end ; end ;
47260: GO 47114
47262: POP
47263: POP
// end ;
47264: LD_VAR 0 3
47268: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47269: LD_INT 0
47271: PPUSH
47272: PPUSH
47273: PPUSH
// if not mc_bases or not skirmish then
47274: LD_EXP 76
47278: NOT
47279: PUSH
47280: LD_EXP 74
47284: NOT
47285: OR
47286: IFFALSE 47290
// exit ;
47288: GO 47379
// for i = 1 to mc_bases do
47290: LD_ADDR_VAR 0 4
47294: PUSH
47295: DOUBLE
47296: LD_INT 1
47298: DEC
47299: ST_TO_ADDR
47300: LD_EXP 76
47304: PUSH
47305: FOR_TO
47306: IFFALSE 47377
// begin if building in mc_busy_turret_list [ i ] then
47308: LD_VAR 0 1
47312: PUSH
47313: LD_EXP 86
47317: PUSH
47318: LD_VAR 0 4
47322: ARRAY
47323: IN
47324: IFFALSE 47375
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47326: LD_ADDR_VAR 0 5
47330: PUSH
47331: LD_EXP 86
47335: PUSH
47336: LD_VAR 0 4
47340: ARRAY
47341: PUSH
47342: LD_VAR 0 1
47346: DIFF
47347: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47348: LD_ADDR_EXP 86
47352: PUSH
47353: LD_EXP 86
47357: PPUSH
47358: LD_VAR 0 4
47362: PPUSH
47363: LD_VAR 0 5
47367: PPUSH
47368: CALL_OW 1
47372: ST_TO_ADDR
// break ;
47373: GO 47377
// end ; end ;
47375: GO 47305
47377: POP
47378: POP
// end ;
47379: LD_VAR 0 3
47383: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47384: LD_INT 0
47386: PPUSH
47387: PPUSH
47388: PPUSH
// if not mc_bases or not skirmish then
47389: LD_EXP 76
47393: NOT
47394: PUSH
47395: LD_EXP 74
47399: NOT
47400: OR
47401: IFFALSE 47405
// exit ;
47403: GO 47604
// for i = 1 to mc_bases do
47405: LD_ADDR_VAR 0 5
47409: PUSH
47410: DOUBLE
47411: LD_INT 1
47413: DEC
47414: ST_TO_ADDR
47415: LD_EXP 76
47419: PUSH
47420: FOR_TO
47421: IFFALSE 47602
// if building in mc_bases [ i ] then
47423: LD_VAR 0 1
47427: PUSH
47428: LD_EXP 76
47432: PUSH
47433: LD_VAR 0 5
47437: ARRAY
47438: IN
47439: IFFALSE 47600
// begin tmp := mc_bases [ i ] diff building ;
47441: LD_ADDR_VAR 0 6
47445: PUSH
47446: LD_EXP 76
47450: PUSH
47451: LD_VAR 0 5
47455: ARRAY
47456: PUSH
47457: LD_VAR 0 1
47461: DIFF
47462: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47463: LD_ADDR_EXP 76
47467: PUSH
47468: LD_EXP 76
47472: PPUSH
47473: LD_VAR 0 5
47477: PPUSH
47478: LD_VAR 0 6
47482: PPUSH
47483: CALL_OW 1
47487: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47488: LD_VAR 0 1
47492: PUSH
47493: LD_EXP 84
47497: PUSH
47498: LD_VAR 0 5
47502: ARRAY
47503: IN
47504: IFFALSE 47543
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47506: LD_ADDR_EXP 84
47510: PUSH
47511: LD_EXP 84
47515: PPUSH
47516: LD_VAR 0 5
47520: PPUSH
47521: LD_EXP 84
47525: PUSH
47526: LD_VAR 0 5
47530: ARRAY
47531: PUSH
47532: LD_VAR 0 1
47536: DIFF
47537: PPUSH
47538: CALL_OW 1
47542: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47543: LD_VAR 0 1
47547: PUSH
47548: LD_EXP 85
47552: PUSH
47553: LD_VAR 0 5
47557: ARRAY
47558: IN
47559: IFFALSE 47598
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47561: LD_ADDR_EXP 85
47565: PUSH
47566: LD_EXP 85
47570: PPUSH
47571: LD_VAR 0 5
47575: PPUSH
47576: LD_EXP 85
47580: PUSH
47581: LD_VAR 0 5
47585: ARRAY
47586: PUSH
47587: LD_VAR 0 1
47591: DIFF
47592: PPUSH
47593: CALL_OW 1
47597: ST_TO_ADDR
// break ;
47598: GO 47602
// end ;
47600: GO 47420
47602: POP
47603: POP
// end ;
47604: LD_VAR 0 4
47608: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47609: LD_INT 0
47611: PPUSH
47612: PPUSH
47613: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47614: LD_EXP 76
47618: NOT
47619: PUSH
47620: LD_EXP 74
47624: NOT
47625: OR
47626: PUSH
47627: LD_VAR 0 3
47631: PUSH
47632: LD_EXP 102
47636: IN
47637: NOT
47638: OR
47639: IFFALSE 47643
// exit ;
47641: GO 47766
// for i = 1 to mc_vehicles do
47643: LD_ADDR_VAR 0 6
47647: PUSH
47648: DOUBLE
47649: LD_INT 1
47651: DEC
47652: ST_TO_ADDR
47653: LD_EXP 95
47657: PUSH
47658: FOR_TO
47659: IFFALSE 47764
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47661: LD_VAR 0 2
47665: PUSH
47666: LD_EXP 95
47670: PUSH
47671: LD_VAR 0 6
47675: ARRAY
47676: IN
47677: PUSH
47678: LD_VAR 0 1
47682: PUSH
47683: LD_EXP 95
47687: PUSH
47688: LD_VAR 0 6
47692: ARRAY
47693: IN
47694: OR
47695: IFFALSE 47762
// begin tmp := mc_vehicles [ i ] diff old ;
47697: LD_ADDR_VAR 0 7
47701: PUSH
47702: LD_EXP 95
47706: PUSH
47707: LD_VAR 0 6
47711: ARRAY
47712: PUSH
47713: LD_VAR 0 2
47717: DIFF
47718: ST_TO_ADDR
// tmp := tmp diff new ;
47719: LD_ADDR_VAR 0 7
47723: PUSH
47724: LD_VAR 0 7
47728: PUSH
47729: LD_VAR 0 1
47733: DIFF
47734: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47735: LD_ADDR_EXP 95
47739: PUSH
47740: LD_EXP 95
47744: PPUSH
47745: LD_VAR 0 6
47749: PPUSH
47750: LD_VAR 0 7
47754: PPUSH
47755: CALL_OW 1
47759: ST_TO_ADDR
// break ;
47760: GO 47764
// end ;
47762: GO 47658
47764: POP
47765: POP
// end ;
47766: LD_VAR 0 5
47770: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47771: LD_INT 0
47773: PPUSH
47774: PPUSH
47775: PPUSH
47776: PPUSH
// if not mc_bases or not skirmish then
47777: LD_EXP 76
47781: NOT
47782: PUSH
47783: LD_EXP 74
47787: NOT
47788: OR
47789: IFFALSE 47793
// exit ;
47791: GO 48175
// side := GetSide ( vehicle ) ;
47793: LD_ADDR_VAR 0 5
47797: PUSH
47798: LD_VAR 0 1
47802: PPUSH
47803: CALL_OW 255
47807: ST_TO_ADDR
// for i = 1 to mc_bases do
47808: LD_ADDR_VAR 0 4
47812: PUSH
47813: DOUBLE
47814: LD_INT 1
47816: DEC
47817: ST_TO_ADDR
47818: LD_EXP 76
47822: PUSH
47823: FOR_TO
47824: IFFALSE 48173
// begin if factory in mc_bases [ i ] then
47826: LD_VAR 0 2
47830: PUSH
47831: LD_EXP 76
47835: PUSH
47836: LD_VAR 0 4
47840: ARRAY
47841: IN
47842: IFFALSE 48171
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47844: LD_EXP 98
47848: PUSH
47849: LD_VAR 0 4
47853: ARRAY
47854: PUSH
47855: LD_EXP 87
47859: PUSH
47860: LD_VAR 0 4
47864: ARRAY
47865: LESS
47866: PUSH
47867: LD_VAR 0 1
47871: PPUSH
47872: CALL_OW 264
47876: PUSH
47877: LD_INT 31
47879: PUSH
47880: LD_INT 32
47882: PUSH
47883: LD_INT 51
47885: PUSH
47886: LD_INT 89
47888: PUSH
47889: LD_INT 12
47891: PUSH
47892: LD_INT 30
47894: PUSH
47895: LD_INT 98
47897: PUSH
47898: LD_INT 11
47900: PUSH
47901: LD_INT 53
47903: PUSH
47904: LD_INT 14
47906: PUSH
47907: LD_INT 91
47909: PUSH
47910: LD_INT 29
47912: PUSH
47913: LD_INT 99
47915: PUSH
47916: LD_INT 13
47918: PUSH
47919: LD_INT 52
47921: PUSH
47922: LD_INT 88
47924: PUSH
47925: LD_INT 48
47927: PUSH
47928: LD_INT 8
47930: PUSH
47931: EMPTY
47932: LIST
47933: LIST
47934: LIST
47935: LIST
47936: LIST
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: LIST
47942: LIST
47943: LIST
47944: LIST
47945: LIST
47946: LIST
47947: LIST
47948: LIST
47949: LIST
47950: IN
47951: NOT
47952: AND
47953: IFFALSE 48001
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
47955: LD_ADDR_EXP 98
47959: PUSH
47960: LD_EXP 98
47964: PPUSH
47965: LD_VAR 0 4
47969: PUSH
47970: LD_EXP 98
47974: PUSH
47975: LD_VAR 0 4
47979: ARRAY
47980: PUSH
47981: LD_INT 1
47983: PLUS
47984: PUSH
47985: EMPTY
47986: LIST
47987: LIST
47988: PPUSH
47989: LD_VAR 0 1
47993: PPUSH
47994: CALL 56985 0 3
47998: ST_TO_ADDR
47999: GO 48045
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48001: LD_ADDR_EXP 95
48005: PUSH
48006: LD_EXP 95
48010: PPUSH
48011: LD_VAR 0 4
48015: PUSH
48016: LD_EXP 95
48020: PUSH
48021: LD_VAR 0 4
48025: ARRAY
48026: PUSH
48027: LD_INT 1
48029: PLUS
48030: PUSH
48031: EMPTY
48032: LIST
48033: LIST
48034: PPUSH
48035: LD_VAR 0 1
48039: PPUSH
48040: CALL 56985 0 3
48044: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48045: LD_VAR 0 1
48049: PPUSH
48050: CALL_OW 263
48054: PUSH
48055: LD_INT 2
48057: EQUAL
48058: IFFALSE 48087
// begin repeat wait ( 0 0$3 ) ;
48060: LD_INT 105
48062: PPUSH
48063: CALL_OW 67
// Connect ( vehicle ) ;
48067: LD_VAR 0 1
48071: PPUSH
48072: CALL 59954 0 1
// until IsControledBy ( vehicle ) ;
48076: LD_VAR 0 1
48080: PPUSH
48081: CALL_OW 312
48085: IFFALSE 48060
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48087: LD_VAR 0 1
48091: PPUSH
48092: LD_EXP 100
48096: PUSH
48097: LD_VAR 0 4
48101: ARRAY
48102: PPUSH
48103: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48107: LD_VAR 0 1
48111: PPUSH
48112: CALL_OW 263
48116: PUSH
48117: LD_INT 1
48119: NONEQUAL
48120: IFFALSE 48124
// break ;
48122: GO 48173
// repeat wait ( 0 0$1 ) ;
48124: LD_INT 35
48126: PPUSH
48127: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48131: LD_VAR 0 1
48135: PPUSH
48136: LD_EXP 100
48140: PUSH
48141: LD_VAR 0 4
48145: ARRAY
48146: PPUSH
48147: CALL_OW 308
48151: IFFALSE 48124
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48153: LD_VAR 0 1
48157: PPUSH
48158: CALL_OW 311
48162: PPUSH
48163: CALL_OW 121
// exit ;
48167: POP
48168: POP
48169: GO 48175
// end ; end ;
48171: GO 47823
48173: POP
48174: POP
// end ;
48175: LD_VAR 0 3
48179: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48180: LD_INT 0
48182: PPUSH
48183: PPUSH
48184: PPUSH
48185: PPUSH
// if not mc_bases or not skirmish then
48186: LD_EXP 76
48190: NOT
48191: PUSH
48192: LD_EXP 74
48196: NOT
48197: OR
48198: IFFALSE 48202
// exit ;
48200: GO 48555
// repeat wait ( 0 0$1 ) ;
48202: LD_INT 35
48204: PPUSH
48205: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48209: LD_VAR 0 2
48213: PPUSH
48214: LD_VAR 0 3
48218: PPUSH
48219: CALL_OW 284
48223: IFFALSE 48202
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48225: LD_VAR 0 2
48229: PPUSH
48230: LD_VAR 0 3
48234: PPUSH
48235: CALL_OW 283
48239: PUSH
48240: LD_INT 4
48242: EQUAL
48243: IFFALSE 48247
// exit ;
48245: GO 48555
// for i = 1 to mc_bases do
48247: LD_ADDR_VAR 0 7
48251: PUSH
48252: DOUBLE
48253: LD_INT 1
48255: DEC
48256: ST_TO_ADDR
48257: LD_EXP 76
48261: PUSH
48262: FOR_TO
48263: IFFALSE 48553
// begin if mc_crates_area [ i ] then
48265: LD_EXP 94
48269: PUSH
48270: LD_VAR 0 7
48274: ARRAY
48275: IFFALSE 48386
// for j in mc_crates_area [ i ] do
48277: LD_ADDR_VAR 0 8
48281: PUSH
48282: LD_EXP 94
48286: PUSH
48287: LD_VAR 0 7
48291: ARRAY
48292: PUSH
48293: FOR_IN
48294: IFFALSE 48384
// if InArea ( x , y , j ) then
48296: LD_VAR 0 2
48300: PPUSH
48301: LD_VAR 0 3
48305: PPUSH
48306: LD_VAR 0 8
48310: PPUSH
48311: CALL_OW 309
48315: IFFALSE 48382
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48317: LD_ADDR_EXP 92
48321: PUSH
48322: LD_EXP 92
48326: PPUSH
48327: LD_VAR 0 7
48331: PUSH
48332: LD_EXP 92
48336: PUSH
48337: LD_VAR 0 7
48341: ARRAY
48342: PUSH
48343: LD_INT 1
48345: PLUS
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: PPUSH
48351: LD_VAR 0 4
48355: PUSH
48356: LD_VAR 0 2
48360: PUSH
48361: LD_VAR 0 3
48365: PUSH
48366: EMPTY
48367: LIST
48368: LIST
48369: LIST
48370: PPUSH
48371: CALL 56985 0 3
48375: ST_TO_ADDR
// exit ;
48376: POP
48377: POP
48378: POP
48379: POP
48380: GO 48555
// end ;
48382: GO 48293
48384: POP
48385: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48386: LD_ADDR_VAR 0 9
48390: PUSH
48391: LD_EXP 76
48395: PUSH
48396: LD_VAR 0 7
48400: ARRAY
48401: PPUSH
48402: LD_INT 2
48404: PUSH
48405: LD_INT 30
48407: PUSH
48408: LD_INT 0
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 30
48417: PUSH
48418: LD_INT 1
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: PUSH
48425: EMPTY
48426: LIST
48427: LIST
48428: LIST
48429: PPUSH
48430: CALL_OW 72
48434: ST_TO_ADDR
// if not depot then
48435: LD_VAR 0 9
48439: NOT
48440: IFFALSE 48444
// continue ;
48442: GO 48262
// for j in depot do
48444: LD_ADDR_VAR 0 8
48448: PUSH
48449: LD_VAR 0 9
48453: PUSH
48454: FOR_IN
48455: IFFALSE 48549
// if GetDistUnitXY ( j , x , y ) < 30 then
48457: LD_VAR 0 8
48461: PPUSH
48462: LD_VAR 0 2
48466: PPUSH
48467: LD_VAR 0 3
48471: PPUSH
48472: CALL_OW 297
48476: PUSH
48477: LD_INT 30
48479: LESS
48480: IFFALSE 48547
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48482: LD_ADDR_EXP 92
48486: PUSH
48487: LD_EXP 92
48491: PPUSH
48492: LD_VAR 0 7
48496: PUSH
48497: LD_EXP 92
48501: PUSH
48502: LD_VAR 0 7
48506: ARRAY
48507: PUSH
48508: LD_INT 1
48510: PLUS
48511: PUSH
48512: EMPTY
48513: LIST
48514: LIST
48515: PPUSH
48516: LD_VAR 0 4
48520: PUSH
48521: LD_VAR 0 2
48525: PUSH
48526: LD_VAR 0 3
48530: PUSH
48531: EMPTY
48532: LIST
48533: LIST
48534: LIST
48535: PPUSH
48536: CALL 56985 0 3
48540: ST_TO_ADDR
// exit ;
48541: POP
48542: POP
48543: POP
48544: POP
48545: GO 48555
// end ;
48547: GO 48454
48549: POP
48550: POP
// end ;
48551: GO 48262
48553: POP
48554: POP
// end ;
48555: LD_VAR 0 6
48559: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48560: LD_INT 0
48562: PPUSH
48563: PPUSH
48564: PPUSH
48565: PPUSH
// if not mc_bases or not skirmish then
48566: LD_EXP 76
48570: NOT
48571: PUSH
48572: LD_EXP 74
48576: NOT
48577: OR
48578: IFFALSE 48582
// exit ;
48580: GO 48859
// side := GetSide ( lab ) ;
48582: LD_ADDR_VAR 0 4
48586: PUSH
48587: LD_VAR 0 2
48591: PPUSH
48592: CALL_OW 255
48596: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48597: LD_VAR 0 4
48601: PUSH
48602: LD_EXP 102
48606: IN
48607: NOT
48608: PUSH
48609: LD_EXP 103
48613: NOT
48614: OR
48615: PUSH
48616: LD_EXP 76
48620: NOT
48621: OR
48622: IFFALSE 48626
// exit ;
48624: GO 48859
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48626: LD_ADDR_EXP 103
48630: PUSH
48631: LD_EXP 103
48635: PPUSH
48636: LD_VAR 0 4
48640: PPUSH
48641: LD_EXP 103
48645: PUSH
48646: LD_VAR 0 4
48650: ARRAY
48651: PUSH
48652: LD_VAR 0 1
48656: DIFF
48657: PPUSH
48658: CALL_OW 1
48662: ST_TO_ADDR
// for i = 1 to mc_bases do
48663: LD_ADDR_VAR 0 5
48667: PUSH
48668: DOUBLE
48669: LD_INT 1
48671: DEC
48672: ST_TO_ADDR
48673: LD_EXP 76
48677: PUSH
48678: FOR_TO
48679: IFFALSE 48857
// begin if lab in mc_bases [ i ] then
48681: LD_VAR 0 2
48685: PUSH
48686: LD_EXP 76
48690: PUSH
48691: LD_VAR 0 5
48695: ARRAY
48696: IN
48697: IFFALSE 48855
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48699: LD_VAR 0 1
48703: PUSH
48704: LD_INT 11
48706: PUSH
48707: LD_INT 4
48709: PUSH
48710: LD_INT 3
48712: PUSH
48713: LD_INT 2
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: LIST
48720: LIST
48721: IN
48722: PUSH
48723: LD_EXP 106
48727: PUSH
48728: LD_VAR 0 5
48732: ARRAY
48733: AND
48734: IFFALSE 48855
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48736: LD_ADDR_VAR 0 6
48740: PUSH
48741: LD_EXP 106
48745: PUSH
48746: LD_VAR 0 5
48750: ARRAY
48751: PUSH
48752: LD_INT 1
48754: ARRAY
48755: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48756: LD_ADDR_EXP 106
48760: PUSH
48761: LD_EXP 106
48765: PPUSH
48766: LD_VAR 0 5
48770: PPUSH
48771: EMPTY
48772: PPUSH
48773: CALL_OW 1
48777: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48778: LD_VAR 0 6
48782: PPUSH
48783: LD_INT 0
48785: PPUSH
48786: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48790: LD_VAR 0 6
48794: PPUSH
48795: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48799: LD_ADDR_EXP 105
48803: PUSH
48804: LD_EXP 105
48808: PPUSH
48809: LD_VAR 0 5
48813: PPUSH
48814: LD_EXP 105
48818: PUSH
48819: LD_VAR 0 5
48823: ARRAY
48824: PPUSH
48825: LD_INT 1
48827: PPUSH
48828: LD_VAR 0 6
48832: PPUSH
48833: CALL_OW 2
48837: PPUSH
48838: CALL_OW 1
48842: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48843: LD_VAR 0 5
48847: PPUSH
48848: LD_INT 112
48850: PPUSH
48851: CALL 25398 0 2
// end ; end ; end ;
48855: GO 48678
48857: POP
48858: POP
// end ;
48859: LD_VAR 0 3
48863: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
48864: LD_INT 0
48866: PPUSH
48867: PPUSH
48868: PPUSH
48869: PPUSH
48870: PPUSH
48871: PPUSH
48872: PPUSH
48873: PPUSH
// if not mc_bases or not skirmish then
48874: LD_EXP 76
48878: NOT
48879: PUSH
48880: LD_EXP 74
48884: NOT
48885: OR
48886: IFFALSE 48890
// exit ;
48888: GO 50259
// for i = 1 to mc_bases do
48890: LD_ADDR_VAR 0 3
48894: PUSH
48895: DOUBLE
48896: LD_INT 1
48898: DEC
48899: ST_TO_ADDR
48900: LD_EXP 76
48904: PUSH
48905: FOR_TO
48906: IFFALSE 50257
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
48908: LD_VAR 0 1
48912: PUSH
48913: LD_EXP 76
48917: PUSH
48918: LD_VAR 0 3
48922: ARRAY
48923: IN
48924: PUSH
48925: LD_VAR 0 1
48929: PUSH
48930: LD_EXP 83
48934: PUSH
48935: LD_VAR 0 3
48939: ARRAY
48940: IN
48941: OR
48942: PUSH
48943: LD_VAR 0 1
48947: PUSH
48948: LD_EXP 98
48952: PUSH
48953: LD_VAR 0 3
48957: ARRAY
48958: IN
48959: OR
48960: PUSH
48961: LD_VAR 0 1
48965: PUSH
48966: LD_EXP 95
48970: PUSH
48971: LD_VAR 0 3
48975: ARRAY
48976: IN
48977: OR
48978: PUSH
48979: LD_VAR 0 1
48983: PUSH
48984: LD_EXP 105
48988: PUSH
48989: LD_VAR 0 3
48993: ARRAY
48994: IN
48995: OR
48996: PUSH
48997: LD_VAR 0 1
49001: PUSH
49002: LD_EXP 106
49006: PUSH
49007: LD_VAR 0 3
49011: ARRAY
49012: IN
49013: OR
49014: IFFALSE 50255
// begin if un in mc_ape [ i ] then
49016: LD_VAR 0 1
49020: PUSH
49021: LD_EXP 105
49025: PUSH
49026: LD_VAR 0 3
49030: ARRAY
49031: IN
49032: IFFALSE 49071
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49034: LD_ADDR_EXP 105
49038: PUSH
49039: LD_EXP 105
49043: PPUSH
49044: LD_VAR 0 3
49048: PPUSH
49049: LD_EXP 105
49053: PUSH
49054: LD_VAR 0 3
49058: ARRAY
49059: PUSH
49060: LD_VAR 0 1
49064: DIFF
49065: PPUSH
49066: CALL_OW 1
49070: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49071: LD_VAR 0 1
49075: PUSH
49076: LD_EXP 106
49080: PUSH
49081: LD_VAR 0 3
49085: ARRAY
49086: IN
49087: IFFALSE 49111
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49089: LD_ADDR_EXP 106
49093: PUSH
49094: LD_EXP 106
49098: PPUSH
49099: LD_VAR 0 3
49103: PPUSH
49104: EMPTY
49105: PPUSH
49106: CALL_OW 1
49110: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49111: LD_VAR 0 1
49115: PPUSH
49116: CALL_OW 247
49120: PUSH
49121: LD_INT 2
49123: EQUAL
49124: PUSH
49125: LD_VAR 0 1
49129: PPUSH
49130: CALL_OW 110
49134: PUSH
49135: LD_INT 20
49137: EQUAL
49138: PUSH
49139: LD_VAR 0 1
49143: PUSH
49144: LD_EXP 98
49148: PUSH
49149: LD_VAR 0 3
49153: ARRAY
49154: IN
49155: OR
49156: PUSH
49157: LD_VAR 0 1
49161: PPUSH
49162: CALL_OW 264
49166: PUSH
49167: LD_INT 12
49169: PUSH
49170: LD_INT 51
49172: PUSH
49173: LD_INT 89
49175: PUSH
49176: LD_INT 32
49178: PUSH
49179: LD_INT 13
49181: PUSH
49182: LD_INT 52
49184: PUSH
49185: LD_INT 31
49187: PUSH
49188: EMPTY
49189: LIST
49190: LIST
49191: LIST
49192: LIST
49193: LIST
49194: LIST
49195: LIST
49196: IN
49197: OR
49198: AND
49199: IFFALSE 49507
// begin if un in mc_defender [ i ] then
49201: LD_VAR 0 1
49205: PUSH
49206: LD_EXP 98
49210: PUSH
49211: LD_VAR 0 3
49215: ARRAY
49216: IN
49217: IFFALSE 49256
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49219: LD_ADDR_EXP 98
49223: PUSH
49224: LD_EXP 98
49228: PPUSH
49229: LD_VAR 0 3
49233: PPUSH
49234: LD_EXP 98
49238: PUSH
49239: LD_VAR 0 3
49243: ARRAY
49244: PUSH
49245: LD_VAR 0 1
49249: DIFF
49250: PPUSH
49251: CALL_OW 1
49255: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49256: LD_ADDR_VAR 0 8
49260: PUSH
49261: LD_VAR 0 3
49265: PPUSH
49266: LD_INT 3
49268: PPUSH
49269: CALL 45915 0 2
49273: ST_TO_ADDR
// if fac then
49274: LD_VAR 0 8
49278: IFFALSE 49507
// begin for j in fac do
49280: LD_ADDR_VAR 0 4
49284: PUSH
49285: LD_VAR 0 8
49289: PUSH
49290: FOR_IN
49291: IFFALSE 49505
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49293: LD_ADDR_VAR 0 9
49297: PUSH
49298: LD_VAR 0 8
49302: PPUSH
49303: LD_VAR 0 1
49307: PPUSH
49308: CALL_OW 265
49312: PPUSH
49313: LD_VAR 0 1
49317: PPUSH
49318: CALL_OW 262
49322: PPUSH
49323: LD_VAR 0 1
49327: PPUSH
49328: CALL_OW 263
49332: PPUSH
49333: LD_VAR 0 1
49337: PPUSH
49338: CALL_OW 264
49342: PPUSH
49343: CALL 54483 0 5
49347: ST_TO_ADDR
// if components then
49348: LD_VAR 0 9
49352: IFFALSE 49503
// begin if GetWeapon ( un ) = ar_control_tower then
49354: LD_VAR 0 1
49358: PPUSH
49359: CALL_OW 264
49363: PUSH
49364: LD_INT 31
49366: EQUAL
49367: IFFALSE 49484
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49369: LD_VAR 0 1
49373: PPUSH
49374: CALL_OW 311
49378: PPUSH
49379: LD_INT 0
49381: PPUSH
49382: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49386: LD_ADDR_EXP 116
49390: PUSH
49391: LD_EXP 116
49395: PPUSH
49396: LD_VAR 0 3
49400: PPUSH
49401: LD_EXP 116
49405: PUSH
49406: LD_VAR 0 3
49410: ARRAY
49411: PUSH
49412: LD_VAR 0 1
49416: PPUSH
49417: CALL_OW 311
49421: DIFF
49422: PPUSH
49423: CALL_OW 1
49427: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49428: LD_ADDR_VAR 0 7
49432: PUSH
49433: LD_EXP 97
49437: PUSH
49438: LD_VAR 0 3
49442: ARRAY
49443: PPUSH
49444: LD_INT 1
49446: PPUSH
49447: LD_VAR 0 9
49451: PPUSH
49452: CALL_OW 2
49456: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49457: LD_ADDR_EXP 97
49461: PUSH
49462: LD_EXP 97
49466: PPUSH
49467: LD_VAR 0 3
49471: PPUSH
49472: LD_VAR 0 7
49476: PPUSH
49477: CALL_OW 1
49481: ST_TO_ADDR
// end else
49482: GO 49501
// MC_InsertProduceList ( i , [ components ] ) ;
49484: LD_VAR 0 3
49488: PPUSH
49489: LD_VAR 0 9
49493: PUSH
49494: EMPTY
49495: LIST
49496: PPUSH
49497: CALL 45460 0 2
// break ;
49501: GO 49505
// end ; end ;
49503: GO 49290
49505: POP
49506: POP
// end ; end ; if GetType ( un ) = unit_building then
49507: LD_VAR 0 1
49511: PPUSH
49512: CALL_OW 247
49516: PUSH
49517: LD_INT 3
49519: EQUAL
49520: IFFALSE 49923
// begin btype := GetBType ( un ) ;
49522: LD_ADDR_VAR 0 5
49526: PUSH
49527: LD_VAR 0 1
49531: PPUSH
49532: CALL_OW 266
49536: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49537: LD_VAR 0 5
49541: PUSH
49542: LD_INT 29
49544: PUSH
49545: LD_INT 30
49547: PUSH
49548: EMPTY
49549: LIST
49550: LIST
49551: IN
49552: IFFALSE 49625
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49554: LD_VAR 0 1
49558: PPUSH
49559: CALL_OW 250
49563: PPUSH
49564: LD_VAR 0 1
49568: PPUSH
49569: CALL_OW 251
49573: PPUSH
49574: LD_VAR 0 1
49578: PPUSH
49579: CALL_OW 255
49583: PPUSH
49584: CALL_OW 440
49588: NOT
49589: IFFALSE 49625
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49591: LD_VAR 0 1
49595: PPUSH
49596: CALL_OW 250
49600: PPUSH
49601: LD_VAR 0 1
49605: PPUSH
49606: CALL_OW 251
49610: PPUSH
49611: LD_VAR 0 1
49615: PPUSH
49616: CALL_OW 255
49620: PPUSH
49621: CALL_OW 441
// end ; if btype = b_warehouse then
49625: LD_VAR 0 5
49629: PUSH
49630: LD_INT 1
49632: EQUAL
49633: IFFALSE 49651
// begin btype := b_depot ;
49635: LD_ADDR_VAR 0 5
49639: PUSH
49640: LD_INT 0
49642: ST_TO_ADDR
// pos := 1 ;
49643: LD_ADDR_VAR 0 6
49647: PUSH
49648: LD_INT 1
49650: ST_TO_ADDR
// end ; if btype = b_factory then
49651: LD_VAR 0 5
49655: PUSH
49656: LD_INT 3
49658: EQUAL
49659: IFFALSE 49677
// begin btype := b_workshop ;
49661: LD_ADDR_VAR 0 5
49665: PUSH
49666: LD_INT 2
49668: ST_TO_ADDR
// pos := 1 ;
49669: LD_ADDR_VAR 0 6
49673: PUSH
49674: LD_INT 1
49676: ST_TO_ADDR
// end ; if btype = b_barracks then
49677: LD_VAR 0 5
49681: PUSH
49682: LD_INT 5
49684: EQUAL
49685: IFFALSE 49695
// btype := b_armoury ;
49687: LD_ADDR_VAR 0 5
49691: PUSH
49692: LD_INT 4
49694: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49695: LD_VAR 0 5
49699: PUSH
49700: LD_INT 7
49702: PUSH
49703: LD_INT 8
49705: PUSH
49706: EMPTY
49707: LIST
49708: LIST
49709: IN
49710: IFFALSE 49720
// btype := b_lab ;
49712: LD_ADDR_VAR 0 5
49716: PUSH
49717: LD_INT 6
49719: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49720: LD_ADDR_EXP 81
49724: PUSH
49725: LD_EXP 81
49729: PPUSH
49730: LD_VAR 0 3
49734: PUSH
49735: LD_EXP 81
49739: PUSH
49740: LD_VAR 0 3
49744: ARRAY
49745: PUSH
49746: LD_INT 1
49748: PLUS
49749: PUSH
49750: EMPTY
49751: LIST
49752: LIST
49753: PPUSH
49754: LD_VAR 0 5
49758: PUSH
49759: LD_VAR 0 1
49763: PPUSH
49764: CALL_OW 250
49768: PUSH
49769: LD_VAR 0 1
49773: PPUSH
49774: CALL_OW 251
49778: PUSH
49779: LD_VAR 0 1
49783: PPUSH
49784: CALL_OW 254
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: PPUSH
49795: CALL 56985 0 3
49799: ST_TO_ADDR
// if pos = 1 then
49800: LD_VAR 0 6
49804: PUSH
49805: LD_INT 1
49807: EQUAL
49808: IFFALSE 49923
// begin tmp := mc_build_list [ i ] ;
49810: LD_ADDR_VAR 0 7
49814: PUSH
49815: LD_EXP 81
49819: PUSH
49820: LD_VAR 0 3
49824: ARRAY
49825: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49826: LD_VAR 0 7
49830: PPUSH
49831: LD_INT 2
49833: PUSH
49834: LD_INT 30
49836: PUSH
49837: LD_INT 0
49839: PUSH
49840: EMPTY
49841: LIST
49842: LIST
49843: PUSH
49844: LD_INT 30
49846: PUSH
49847: LD_INT 1
49849: PUSH
49850: EMPTY
49851: LIST
49852: LIST
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: LIST
49858: PPUSH
49859: CALL_OW 72
49863: IFFALSE 49873
// pos := 2 ;
49865: LD_ADDR_VAR 0 6
49869: PUSH
49870: LD_INT 2
49872: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
49873: LD_ADDR_VAR 0 7
49877: PUSH
49878: LD_VAR 0 7
49882: PPUSH
49883: LD_VAR 0 6
49887: PPUSH
49888: LD_VAR 0 7
49892: PPUSH
49893: CALL 57311 0 3
49897: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
49898: LD_ADDR_EXP 81
49902: PUSH
49903: LD_EXP 81
49907: PPUSH
49908: LD_VAR 0 3
49912: PPUSH
49913: LD_VAR 0 7
49917: PPUSH
49918: CALL_OW 1
49922: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
49923: LD_VAR 0 1
49927: PUSH
49928: LD_EXP 76
49932: PUSH
49933: LD_VAR 0 3
49937: ARRAY
49938: IN
49939: IFFALSE 49978
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
49941: LD_ADDR_EXP 76
49945: PUSH
49946: LD_EXP 76
49950: PPUSH
49951: LD_VAR 0 3
49955: PPUSH
49956: LD_EXP 76
49960: PUSH
49961: LD_VAR 0 3
49965: ARRAY
49966: PUSH
49967: LD_VAR 0 1
49971: DIFF
49972: PPUSH
49973: CALL_OW 1
49977: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49978: LD_VAR 0 1
49982: PUSH
49983: LD_EXP 83
49987: PUSH
49988: LD_VAR 0 3
49992: ARRAY
49993: IN
49994: IFFALSE 50033
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49996: LD_ADDR_EXP 83
50000: PUSH
50001: LD_EXP 83
50005: PPUSH
50006: LD_VAR 0 3
50010: PPUSH
50011: LD_EXP 83
50015: PUSH
50016: LD_VAR 0 3
50020: ARRAY
50021: PUSH
50022: LD_VAR 0 1
50026: DIFF
50027: PPUSH
50028: CALL_OW 1
50032: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50033: LD_VAR 0 1
50037: PUSH
50038: LD_EXP 95
50042: PUSH
50043: LD_VAR 0 3
50047: ARRAY
50048: IN
50049: IFFALSE 50088
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50051: LD_ADDR_EXP 95
50055: PUSH
50056: LD_EXP 95
50060: PPUSH
50061: LD_VAR 0 3
50065: PPUSH
50066: LD_EXP 95
50070: PUSH
50071: LD_VAR 0 3
50075: ARRAY
50076: PUSH
50077: LD_VAR 0 1
50081: DIFF
50082: PPUSH
50083: CALL_OW 1
50087: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50088: LD_VAR 0 1
50092: PUSH
50093: LD_EXP 98
50097: PUSH
50098: LD_VAR 0 3
50102: ARRAY
50103: IN
50104: IFFALSE 50143
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50106: LD_ADDR_EXP 98
50110: PUSH
50111: LD_EXP 98
50115: PPUSH
50116: LD_VAR 0 3
50120: PPUSH
50121: LD_EXP 98
50125: PUSH
50126: LD_VAR 0 3
50130: ARRAY
50131: PUSH
50132: LD_VAR 0 1
50136: DIFF
50137: PPUSH
50138: CALL_OW 1
50142: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50143: LD_VAR 0 1
50147: PUSH
50148: LD_EXP 85
50152: PUSH
50153: LD_VAR 0 3
50157: ARRAY
50158: IN
50159: IFFALSE 50198
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50161: LD_ADDR_EXP 85
50165: PUSH
50166: LD_EXP 85
50170: PPUSH
50171: LD_VAR 0 3
50175: PPUSH
50176: LD_EXP 85
50180: PUSH
50181: LD_VAR 0 3
50185: ARRAY
50186: PUSH
50187: LD_VAR 0 1
50191: DIFF
50192: PPUSH
50193: CALL_OW 1
50197: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50198: LD_VAR 0 1
50202: PUSH
50203: LD_EXP 84
50207: PUSH
50208: LD_VAR 0 3
50212: ARRAY
50213: IN
50214: IFFALSE 50253
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50216: LD_ADDR_EXP 84
50220: PUSH
50221: LD_EXP 84
50225: PPUSH
50226: LD_VAR 0 3
50230: PPUSH
50231: LD_EXP 84
50235: PUSH
50236: LD_VAR 0 3
50240: ARRAY
50241: PUSH
50242: LD_VAR 0 1
50246: DIFF
50247: PPUSH
50248: CALL_OW 1
50252: ST_TO_ADDR
// end ; break ;
50253: GO 50257
// end ;
50255: GO 48905
50257: POP
50258: POP
// end ;
50259: LD_VAR 0 2
50263: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50264: LD_INT 0
50266: PPUSH
50267: PPUSH
50268: PPUSH
// if not mc_bases or not skirmish then
50269: LD_EXP 76
50273: NOT
50274: PUSH
50275: LD_EXP 74
50279: NOT
50280: OR
50281: IFFALSE 50285
// exit ;
50283: GO 50500
// for i = 1 to mc_bases do
50285: LD_ADDR_VAR 0 3
50289: PUSH
50290: DOUBLE
50291: LD_INT 1
50293: DEC
50294: ST_TO_ADDR
50295: LD_EXP 76
50299: PUSH
50300: FOR_TO
50301: IFFALSE 50498
// begin if building in mc_construct_list [ i ] then
50303: LD_VAR 0 1
50307: PUSH
50308: LD_EXP 83
50312: PUSH
50313: LD_VAR 0 3
50317: ARRAY
50318: IN
50319: IFFALSE 50496
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50321: LD_ADDR_EXP 83
50325: PUSH
50326: LD_EXP 83
50330: PPUSH
50331: LD_VAR 0 3
50335: PPUSH
50336: LD_EXP 83
50340: PUSH
50341: LD_VAR 0 3
50345: ARRAY
50346: PUSH
50347: LD_VAR 0 1
50351: DIFF
50352: PPUSH
50353: CALL_OW 1
50357: ST_TO_ADDR
// if building in mc_lab [ i ] then
50358: LD_VAR 0 1
50362: PUSH
50363: LD_EXP 109
50367: PUSH
50368: LD_VAR 0 3
50372: ARRAY
50373: IN
50374: IFFALSE 50429
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50376: LD_ADDR_EXP 110
50380: PUSH
50381: LD_EXP 110
50385: PPUSH
50386: LD_VAR 0 3
50390: PPUSH
50391: LD_EXP 110
50395: PUSH
50396: LD_VAR 0 3
50400: ARRAY
50401: PPUSH
50402: LD_INT 1
50404: PPUSH
50405: LD_EXP 110
50409: PUSH
50410: LD_VAR 0 3
50414: ARRAY
50415: PPUSH
50416: LD_INT 0
50418: PPUSH
50419: CALL 56403 0 4
50423: PPUSH
50424: CALL_OW 1
50428: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50429: LD_VAR 0 1
50433: PUSH
50434: LD_EXP 76
50438: PUSH
50439: LD_VAR 0 3
50443: ARRAY
50444: IN
50445: NOT
50446: IFFALSE 50492
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50448: LD_ADDR_EXP 76
50452: PUSH
50453: LD_EXP 76
50457: PPUSH
50458: LD_VAR 0 3
50462: PUSH
50463: LD_EXP 76
50467: PUSH
50468: LD_VAR 0 3
50472: ARRAY
50473: PUSH
50474: LD_INT 1
50476: PLUS
50477: PUSH
50478: EMPTY
50479: LIST
50480: LIST
50481: PPUSH
50482: LD_VAR 0 1
50486: PPUSH
50487: CALL 56985 0 3
50491: ST_TO_ADDR
// exit ;
50492: POP
50493: POP
50494: GO 50500
// end ; end ;
50496: GO 50300
50498: POP
50499: POP
// end ;
50500: LD_VAR 0 2
50504: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50505: LD_INT 0
50507: PPUSH
50508: PPUSH
50509: PPUSH
50510: PPUSH
50511: PPUSH
50512: PPUSH
50513: PPUSH
// if not mc_bases or not skirmish then
50514: LD_EXP 76
50518: NOT
50519: PUSH
50520: LD_EXP 74
50524: NOT
50525: OR
50526: IFFALSE 50530
// exit ;
50528: GO 51191
// for i = 1 to mc_bases do
50530: LD_ADDR_VAR 0 3
50534: PUSH
50535: DOUBLE
50536: LD_INT 1
50538: DEC
50539: ST_TO_ADDR
50540: LD_EXP 76
50544: PUSH
50545: FOR_TO
50546: IFFALSE 51189
// begin if building in mc_construct_list [ i ] then
50548: LD_VAR 0 1
50552: PUSH
50553: LD_EXP 83
50557: PUSH
50558: LD_VAR 0 3
50562: ARRAY
50563: IN
50564: IFFALSE 51187
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50566: LD_ADDR_EXP 83
50570: PUSH
50571: LD_EXP 83
50575: PPUSH
50576: LD_VAR 0 3
50580: PPUSH
50581: LD_EXP 83
50585: PUSH
50586: LD_VAR 0 3
50590: ARRAY
50591: PUSH
50592: LD_VAR 0 1
50596: DIFF
50597: PPUSH
50598: CALL_OW 1
50602: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50603: LD_ADDR_EXP 76
50607: PUSH
50608: LD_EXP 76
50612: PPUSH
50613: LD_VAR 0 3
50617: PUSH
50618: LD_EXP 76
50622: PUSH
50623: LD_VAR 0 3
50627: ARRAY
50628: PUSH
50629: LD_INT 1
50631: PLUS
50632: PUSH
50633: EMPTY
50634: LIST
50635: LIST
50636: PPUSH
50637: LD_VAR 0 1
50641: PPUSH
50642: CALL 56985 0 3
50646: ST_TO_ADDR
// btype := GetBType ( building ) ;
50647: LD_ADDR_VAR 0 5
50651: PUSH
50652: LD_VAR 0 1
50656: PPUSH
50657: CALL_OW 266
50661: ST_TO_ADDR
// side := GetSide ( building ) ;
50662: LD_ADDR_VAR 0 8
50666: PUSH
50667: LD_VAR 0 1
50671: PPUSH
50672: CALL_OW 255
50676: ST_TO_ADDR
// if btype = b_lab then
50677: LD_VAR 0 5
50681: PUSH
50682: LD_INT 6
50684: EQUAL
50685: IFFALSE 50735
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50687: LD_ADDR_EXP 109
50691: PUSH
50692: LD_EXP 109
50696: PPUSH
50697: LD_VAR 0 3
50701: PUSH
50702: LD_EXP 109
50706: PUSH
50707: LD_VAR 0 3
50711: ARRAY
50712: PUSH
50713: LD_INT 1
50715: PLUS
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: PPUSH
50721: LD_VAR 0 1
50725: PPUSH
50726: CALL 56985 0 3
50730: ST_TO_ADDR
// exit ;
50731: POP
50732: POP
50733: GO 51191
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50735: LD_VAR 0 5
50739: PUSH
50740: LD_INT 0
50742: PUSH
50743: LD_INT 2
50745: PUSH
50746: LD_INT 4
50748: PUSH
50749: EMPTY
50750: LIST
50751: LIST
50752: LIST
50753: IN
50754: IFFALSE 50878
// begin if btype = b_armoury then
50756: LD_VAR 0 5
50760: PUSH
50761: LD_INT 4
50763: EQUAL
50764: IFFALSE 50774
// btype := b_barracks ;
50766: LD_ADDR_VAR 0 5
50770: PUSH
50771: LD_INT 5
50773: ST_TO_ADDR
// if btype = b_depot then
50774: LD_VAR 0 5
50778: PUSH
50779: LD_INT 0
50781: EQUAL
50782: IFFALSE 50792
// btype := b_warehouse ;
50784: LD_ADDR_VAR 0 5
50788: PUSH
50789: LD_INT 1
50791: ST_TO_ADDR
// if btype = b_workshop then
50792: LD_VAR 0 5
50796: PUSH
50797: LD_INT 2
50799: EQUAL
50800: IFFALSE 50810
// btype := b_factory ;
50802: LD_ADDR_VAR 0 5
50806: PUSH
50807: LD_INT 3
50809: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50810: LD_VAR 0 5
50814: PPUSH
50815: LD_VAR 0 8
50819: PPUSH
50820: CALL_OW 323
50824: PUSH
50825: LD_INT 1
50827: EQUAL
50828: IFFALSE 50874
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50830: LD_ADDR_EXP 108
50834: PUSH
50835: LD_EXP 108
50839: PPUSH
50840: LD_VAR 0 3
50844: PUSH
50845: LD_EXP 108
50849: PUSH
50850: LD_VAR 0 3
50854: ARRAY
50855: PUSH
50856: LD_INT 1
50858: PLUS
50859: PUSH
50860: EMPTY
50861: LIST
50862: LIST
50863: PPUSH
50864: LD_VAR 0 1
50868: PPUSH
50869: CALL 56985 0 3
50873: ST_TO_ADDR
// exit ;
50874: POP
50875: POP
50876: GO 51191
// end ; if btype in [ b_bunker , b_turret ] then
50878: LD_VAR 0 5
50882: PUSH
50883: LD_INT 32
50885: PUSH
50886: LD_INT 33
50888: PUSH
50889: EMPTY
50890: LIST
50891: LIST
50892: IN
50893: IFFALSE 51183
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
50895: LD_ADDR_EXP 84
50899: PUSH
50900: LD_EXP 84
50904: PPUSH
50905: LD_VAR 0 3
50909: PUSH
50910: LD_EXP 84
50914: PUSH
50915: LD_VAR 0 3
50919: ARRAY
50920: PUSH
50921: LD_INT 1
50923: PLUS
50924: PUSH
50925: EMPTY
50926: LIST
50927: LIST
50928: PPUSH
50929: LD_VAR 0 1
50933: PPUSH
50934: CALL 56985 0 3
50938: ST_TO_ADDR
// if btype = b_bunker then
50939: LD_VAR 0 5
50943: PUSH
50944: LD_INT 32
50946: EQUAL
50947: IFFALSE 51183
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50949: LD_ADDR_EXP 85
50953: PUSH
50954: LD_EXP 85
50958: PPUSH
50959: LD_VAR 0 3
50963: PUSH
50964: LD_EXP 85
50968: PUSH
50969: LD_VAR 0 3
50973: ARRAY
50974: PUSH
50975: LD_INT 1
50977: PLUS
50978: PUSH
50979: EMPTY
50980: LIST
50981: LIST
50982: PPUSH
50983: LD_VAR 0 1
50987: PPUSH
50988: CALL 56985 0 3
50992: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50993: LD_ADDR_VAR 0 6
50997: PUSH
50998: LD_EXP 76
51002: PUSH
51003: LD_VAR 0 3
51007: ARRAY
51008: PPUSH
51009: LD_INT 25
51011: PUSH
51012: LD_INT 1
51014: PUSH
51015: EMPTY
51016: LIST
51017: LIST
51018: PUSH
51019: LD_INT 3
51021: PUSH
51022: LD_INT 54
51024: PUSH
51025: EMPTY
51026: LIST
51027: PUSH
51028: EMPTY
51029: LIST
51030: LIST
51031: PUSH
51032: EMPTY
51033: LIST
51034: LIST
51035: PPUSH
51036: CALL_OW 72
51040: ST_TO_ADDR
// if tmp then
51041: LD_VAR 0 6
51045: IFFALSE 51051
// exit ;
51047: POP
51048: POP
51049: GO 51191
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51051: LD_ADDR_VAR 0 6
51055: PUSH
51056: LD_EXP 76
51060: PUSH
51061: LD_VAR 0 3
51065: ARRAY
51066: PPUSH
51067: LD_INT 2
51069: PUSH
51070: LD_INT 30
51072: PUSH
51073: LD_INT 4
51075: PUSH
51076: EMPTY
51077: LIST
51078: LIST
51079: PUSH
51080: LD_INT 30
51082: PUSH
51083: LD_INT 5
51085: PUSH
51086: EMPTY
51087: LIST
51088: LIST
51089: PUSH
51090: EMPTY
51091: LIST
51092: LIST
51093: LIST
51094: PPUSH
51095: CALL_OW 72
51099: ST_TO_ADDR
// if not tmp then
51100: LD_VAR 0 6
51104: NOT
51105: IFFALSE 51111
// exit ;
51107: POP
51108: POP
51109: GO 51191
// for j in tmp do
51111: LD_ADDR_VAR 0 4
51115: PUSH
51116: LD_VAR 0 6
51120: PUSH
51121: FOR_IN
51122: IFFALSE 51181
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51124: LD_ADDR_VAR 0 7
51128: PUSH
51129: LD_VAR 0 4
51133: PPUSH
51134: CALL_OW 313
51138: PPUSH
51139: LD_INT 25
51141: PUSH
51142: LD_INT 1
51144: PUSH
51145: EMPTY
51146: LIST
51147: LIST
51148: PPUSH
51149: CALL_OW 72
51153: ST_TO_ADDR
// if units then
51154: LD_VAR 0 7
51158: IFFALSE 51179
// begin ComExitBuilding ( units [ 1 ] ) ;
51160: LD_VAR 0 7
51164: PUSH
51165: LD_INT 1
51167: ARRAY
51168: PPUSH
51169: CALL_OW 122
// exit ;
51173: POP
51174: POP
51175: POP
51176: POP
51177: GO 51191
// end ; end ;
51179: GO 51121
51181: POP
51182: POP
// end ; end ; exit ;
51183: POP
51184: POP
51185: GO 51191
// end ; end ;
51187: GO 50545
51189: POP
51190: POP
// end ;
51191: LD_VAR 0 2
51195: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51196: LD_INT 0
51198: PPUSH
51199: PPUSH
51200: PPUSH
51201: PPUSH
51202: PPUSH
51203: PPUSH
51204: PPUSH
// if not mc_bases or not skirmish then
51205: LD_EXP 76
51209: NOT
51210: PUSH
51211: LD_EXP 74
51215: NOT
51216: OR
51217: IFFALSE 51221
// exit ;
51219: GO 51486
// btype := GetBType ( building ) ;
51221: LD_ADDR_VAR 0 6
51225: PUSH
51226: LD_VAR 0 1
51230: PPUSH
51231: CALL_OW 266
51235: ST_TO_ADDR
// x := GetX ( building ) ;
51236: LD_ADDR_VAR 0 7
51240: PUSH
51241: LD_VAR 0 1
51245: PPUSH
51246: CALL_OW 250
51250: ST_TO_ADDR
// y := GetY ( building ) ;
51251: LD_ADDR_VAR 0 8
51255: PUSH
51256: LD_VAR 0 1
51260: PPUSH
51261: CALL_OW 251
51265: ST_TO_ADDR
// d := GetDir ( building ) ;
51266: LD_ADDR_VAR 0 9
51270: PUSH
51271: LD_VAR 0 1
51275: PPUSH
51276: CALL_OW 254
51280: ST_TO_ADDR
// for i = 1 to mc_bases do
51281: LD_ADDR_VAR 0 4
51285: PUSH
51286: DOUBLE
51287: LD_INT 1
51289: DEC
51290: ST_TO_ADDR
51291: LD_EXP 76
51295: PUSH
51296: FOR_TO
51297: IFFALSE 51484
// begin if not mc_build_list [ i ] then
51299: LD_EXP 81
51303: PUSH
51304: LD_VAR 0 4
51308: ARRAY
51309: NOT
51310: IFFALSE 51314
// continue ;
51312: GO 51296
// for j := 1 to mc_build_list [ i ] do
51314: LD_ADDR_VAR 0 5
51318: PUSH
51319: DOUBLE
51320: LD_INT 1
51322: DEC
51323: ST_TO_ADDR
51324: LD_EXP 81
51328: PUSH
51329: LD_VAR 0 4
51333: ARRAY
51334: PUSH
51335: FOR_TO
51336: IFFALSE 51480
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51338: LD_VAR 0 6
51342: PUSH
51343: LD_VAR 0 7
51347: PUSH
51348: LD_VAR 0 8
51352: PUSH
51353: LD_VAR 0 9
51357: PUSH
51358: EMPTY
51359: LIST
51360: LIST
51361: LIST
51362: LIST
51363: PPUSH
51364: LD_EXP 81
51368: PUSH
51369: LD_VAR 0 4
51373: ARRAY
51374: PUSH
51375: LD_VAR 0 5
51379: ARRAY
51380: PPUSH
51381: CALL 63165 0 2
51385: IFFALSE 51478
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51387: LD_ADDR_EXP 81
51391: PUSH
51392: LD_EXP 81
51396: PPUSH
51397: LD_VAR 0 4
51401: PPUSH
51402: LD_EXP 81
51406: PUSH
51407: LD_VAR 0 4
51411: ARRAY
51412: PPUSH
51413: LD_VAR 0 5
51417: PPUSH
51418: CALL_OW 3
51422: PPUSH
51423: CALL_OW 1
51427: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51428: LD_ADDR_EXP 83
51432: PUSH
51433: LD_EXP 83
51437: PPUSH
51438: LD_VAR 0 4
51442: PUSH
51443: LD_EXP 83
51447: PUSH
51448: LD_VAR 0 4
51452: ARRAY
51453: PUSH
51454: LD_INT 1
51456: PLUS
51457: PUSH
51458: EMPTY
51459: LIST
51460: LIST
51461: PPUSH
51462: LD_VAR 0 1
51466: PPUSH
51467: CALL 56985 0 3
51471: ST_TO_ADDR
// exit ;
51472: POP
51473: POP
51474: POP
51475: POP
51476: GO 51486
// end ;
51478: GO 51335
51480: POP
51481: POP
// end ;
51482: GO 51296
51484: POP
51485: POP
// end ;
51486: LD_VAR 0 3
51490: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51491: LD_INT 0
51493: PPUSH
51494: PPUSH
51495: PPUSH
// if not mc_bases or not skirmish then
51496: LD_EXP 76
51500: NOT
51501: PUSH
51502: LD_EXP 74
51506: NOT
51507: OR
51508: IFFALSE 51512
// exit ;
51510: GO 51702
// for i = 1 to mc_bases do
51512: LD_ADDR_VAR 0 4
51516: PUSH
51517: DOUBLE
51518: LD_INT 1
51520: DEC
51521: ST_TO_ADDR
51522: LD_EXP 76
51526: PUSH
51527: FOR_TO
51528: IFFALSE 51615
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51530: LD_VAR 0 1
51534: PUSH
51535: LD_EXP 84
51539: PUSH
51540: LD_VAR 0 4
51544: ARRAY
51545: IN
51546: PUSH
51547: LD_VAR 0 1
51551: PUSH
51552: LD_EXP 85
51556: PUSH
51557: LD_VAR 0 4
51561: ARRAY
51562: IN
51563: NOT
51564: AND
51565: IFFALSE 51613
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51567: LD_ADDR_EXP 85
51571: PUSH
51572: LD_EXP 85
51576: PPUSH
51577: LD_VAR 0 4
51581: PUSH
51582: LD_EXP 85
51586: PUSH
51587: LD_VAR 0 4
51591: ARRAY
51592: PUSH
51593: LD_INT 1
51595: PLUS
51596: PUSH
51597: EMPTY
51598: LIST
51599: LIST
51600: PPUSH
51601: LD_VAR 0 1
51605: PPUSH
51606: CALL 56985 0 3
51610: ST_TO_ADDR
// break ;
51611: GO 51615
// end ; end ;
51613: GO 51527
51615: POP
51616: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51617: LD_VAR 0 1
51621: PPUSH
51622: CALL_OW 257
51626: PUSH
51627: LD_EXP 102
51631: IN
51632: PUSH
51633: LD_VAR 0 1
51637: PPUSH
51638: CALL_OW 266
51642: PUSH
51643: LD_INT 5
51645: EQUAL
51646: AND
51647: PUSH
51648: LD_VAR 0 2
51652: PPUSH
51653: CALL_OW 110
51657: PUSH
51658: LD_INT 18
51660: NONEQUAL
51661: AND
51662: IFFALSE 51702
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51664: LD_VAR 0 2
51668: PPUSH
51669: CALL_OW 257
51673: PUSH
51674: LD_INT 5
51676: PUSH
51677: LD_INT 8
51679: PUSH
51680: LD_INT 9
51682: PUSH
51683: EMPTY
51684: LIST
51685: LIST
51686: LIST
51687: IN
51688: IFFALSE 51702
// SetClass ( unit , 1 ) ;
51690: LD_VAR 0 2
51694: PPUSH
51695: LD_INT 1
51697: PPUSH
51698: CALL_OW 336
// end ;
51702: LD_VAR 0 3
51706: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51707: LD_INT 0
51709: PPUSH
51710: PPUSH
// if not mc_bases or not skirmish then
51711: LD_EXP 76
51715: NOT
51716: PUSH
51717: LD_EXP 74
51721: NOT
51722: OR
51723: IFFALSE 51727
// exit ;
51725: GO 51843
// if GetLives ( abandoned_vehicle ) > 250 then
51727: LD_VAR 0 2
51731: PPUSH
51732: CALL_OW 256
51736: PUSH
51737: LD_INT 250
51739: GREATER
51740: IFFALSE 51744
// exit ;
51742: GO 51843
// for i = 1 to mc_bases do
51744: LD_ADDR_VAR 0 6
51748: PUSH
51749: DOUBLE
51750: LD_INT 1
51752: DEC
51753: ST_TO_ADDR
51754: LD_EXP 76
51758: PUSH
51759: FOR_TO
51760: IFFALSE 51841
// begin if driver in mc_bases [ i ] then
51762: LD_VAR 0 1
51766: PUSH
51767: LD_EXP 76
51771: PUSH
51772: LD_VAR 0 6
51776: ARRAY
51777: IN
51778: IFFALSE 51839
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51780: LD_VAR 0 1
51784: PPUSH
51785: LD_EXP 76
51789: PUSH
51790: LD_VAR 0 6
51794: ARRAY
51795: PPUSH
51796: LD_INT 2
51798: PUSH
51799: LD_INT 30
51801: PUSH
51802: LD_INT 0
51804: PUSH
51805: EMPTY
51806: LIST
51807: LIST
51808: PUSH
51809: LD_INT 30
51811: PUSH
51812: LD_INT 1
51814: PUSH
51815: EMPTY
51816: LIST
51817: LIST
51818: PUSH
51819: EMPTY
51820: LIST
51821: LIST
51822: LIST
51823: PPUSH
51824: CALL_OW 72
51828: PUSH
51829: LD_INT 1
51831: ARRAY
51832: PPUSH
51833: CALL 90101 0 2
// break ;
51837: GO 51841
// end ; end ;
51839: GO 51759
51841: POP
51842: POP
// end ; end_of_file
51843: LD_VAR 0 5
51847: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51848: LD_INT 0
51850: PPUSH
51851: PPUSH
// if exist_mode then
51852: LD_VAR 0 2
51856: IFFALSE 51881
// unit := CreateCharacter ( prefix & ident ) else
51858: LD_ADDR_VAR 0 5
51862: PUSH
51863: LD_VAR 0 3
51867: PUSH
51868: LD_VAR 0 1
51872: STR
51873: PPUSH
51874: CALL_OW 34
51878: ST_TO_ADDR
51879: GO 51896
// unit := NewCharacter ( ident ) ;
51881: LD_ADDR_VAR 0 5
51885: PUSH
51886: LD_VAR 0 1
51890: PPUSH
51891: CALL_OW 25
51895: ST_TO_ADDR
// result := unit ;
51896: LD_ADDR_VAR 0 4
51900: PUSH
51901: LD_VAR 0 5
51905: ST_TO_ADDR
// end ;
51906: LD_VAR 0 4
51910: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
51911: LD_INT 0
51913: PPUSH
51914: PPUSH
// if not side or not nation then
51915: LD_VAR 0 1
51919: NOT
51920: PUSH
51921: LD_VAR 0 2
51925: NOT
51926: OR
51927: IFFALSE 51931
// exit ;
51929: GO 52699
// case nation of nation_american :
51931: LD_VAR 0 2
51935: PUSH
51936: LD_INT 1
51938: DOUBLE
51939: EQUAL
51940: IFTRUE 51944
51942: GO 52158
51944: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
51945: LD_ADDR_VAR 0 4
51949: PUSH
51950: LD_INT 35
51952: PUSH
51953: LD_INT 45
51955: PUSH
51956: LD_INT 46
51958: PUSH
51959: LD_INT 47
51961: PUSH
51962: LD_INT 82
51964: PUSH
51965: LD_INT 83
51967: PUSH
51968: LD_INT 84
51970: PUSH
51971: LD_INT 85
51973: PUSH
51974: LD_INT 86
51976: PUSH
51977: LD_INT 1
51979: PUSH
51980: LD_INT 2
51982: PUSH
51983: LD_INT 6
51985: PUSH
51986: LD_INT 15
51988: PUSH
51989: LD_INT 16
51991: PUSH
51992: LD_INT 7
51994: PUSH
51995: LD_INT 12
51997: PUSH
51998: LD_INT 13
52000: PUSH
52001: LD_INT 10
52003: PUSH
52004: LD_INT 14
52006: PUSH
52007: LD_INT 20
52009: PUSH
52010: LD_INT 21
52012: PUSH
52013: LD_INT 22
52015: PUSH
52016: LD_INT 25
52018: PUSH
52019: LD_INT 32
52021: PUSH
52022: LD_INT 27
52024: PUSH
52025: LD_INT 36
52027: PUSH
52028: LD_INT 69
52030: PUSH
52031: LD_INT 39
52033: PUSH
52034: LD_INT 34
52036: PUSH
52037: LD_INT 40
52039: PUSH
52040: LD_INT 48
52042: PUSH
52043: LD_INT 49
52045: PUSH
52046: LD_INT 50
52048: PUSH
52049: LD_INT 51
52051: PUSH
52052: LD_INT 52
52054: PUSH
52055: LD_INT 53
52057: PUSH
52058: LD_INT 54
52060: PUSH
52061: LD_INT 55
52063: PUSH
52064: LD_INT 56
52066: PUSH
52067: LD_INT 57
52069: PUSH
52070: LD_INT 58
52072: PUSH
52073: LD_INT 59
52075: PUSH
52076: LD_INT 60
52078: PUSH
52079: LD_INT 61
52081: PUSH
52082: LD_INT 62
52084: PUSH
52085: LD_INT 80
52087: PUSH
52088: LD_INT 82
52090: PUSH
52091: LD_INT 83
52093: PUSH
52094: LD_INT 84
52096: PUSH
52097: LD_INT 85
52099: PUSH
52100: LD_INT 86
52102: PUSH
52103: EMPTY
52104: LIST
52105: LIST
52106: LIST
52107: LIST
52108: LIST
52109: LIST
52110: LIST
52111: LIST
52112: LIST
52113: LIST
52114: LIST
52115: LIST
52116: LIST
52117: LIST
52118: LIST
52119: LIST
52120: LIST
52121: LIST
52122: LIST
52123: LIST
52124: LIST
52125: LIST
52126: LIST
52127: LIST
52128: LIST
52129: LIST
52130: LIST
52131: LIST
52132: LIST
52133: LIST
52134: LIST
52135: LIST
52136: LIST
52137: LIST
52138: LIST
52139: LIST
52140: LIST
52141: LIST
52142: LIST
52143: LIST
52144: LIST
52145: LIST
52146: LIST
52147: LIST
52148: LIST
52149: LIST
52150: LIST
52151: LIST
52152: LIST
52153: LIST
52154: LIST
52155: ST_TO_ADDR
52156: GO 52623
52158: LD_INT 2
52160: DOUBLE
52161: EQUAL
52162: IFTRUE 52166
52164: GO 52392
52166: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52167: LD_ADDR_VAR 0 4
52171: PUSH
52172: LD_INT 35
52174: PUSH
52175: LD_INT 45
52177: PUSH
52178: LD_INT 46
52180: PUSH
52181: LD_INT 47
52183: PUSH
52184: LD_INT 82
52186: PUSH
52187: LD_INT 83
52189: PUSH
52190: LD_INT 84
52192: PUSH
52193: LD_INT 85
52195: PUSH
52196: LD_INT 87
52198: PUSH
52199: LD_INT 70
52201: PUSH
52202: LD_INT 1
52204: PUSH
52205: LD_INT 11
52207: PUSH
52208: LD_INT 3
52210: PUSH
52211: LD_INT 4
52213: PUSH
52214: LD_INT 5
52216: PUSH
52217: LD_INT 6
52219: PUSH
52220: LD_INT 15
52222: PUSH
52223: LD_INT 18
52225: PUSH
52226: LD_INT 7
52228: PUSH
52229: LD_INT 17
52231: PUSH
52232: LD_INT 8
52234: PUSH
52235: LD_INT 20
52237: PUSH
52238: LD_INT 21
52240: PUSH
52241: LD_INT 22
52243: PUSH
52244: LD_INT 72
52246: PUSH
52247: LD_INT 26
52249: PUSH
52250: LD_INT 69
52252: PUSH
52253: LD_INT 39
52255: PUSH
52256: LD_INT 40
52258: PUSH
52259: LD_INT 41
52261: PUSH
52262: LD_INT 42
52264: PUSH
52265: LD_INT 43
52267: PUSH
52268: LD_INT 48
52270: PUSH
52271: LD_INT 49
52273: PUSH
52274: LD_INT 50
52276: PUSH
52277: LD_INT 51
52279: PUSH
52280: LD_INT 52
52282: PUSH
52283: LD_INT 53
52285: PUSH
52286: LD_INT 54
52288: PUSH
52289: LD_INT 55
52291: PUSH
52292: LD_INT 56
52294: PUSH
52295: LD_INT 60
52297: PUSH
52298: LD_INT 61
52300: PUSH
52301: LD_INT 62
52303: PUSH
52304: LD_INT 66
52306: PUSH
52307: LD_INT 67
52309: PUSH
52310: LD_INT 68
52312: PUSH
52313: LD_INT 81
52315: PUSH
52316: LD_INT 82
52318: PUSH
52319: LD_INT 83
52321: PUSH
52322: LD_INT 84
52324: PUSH
52325: LD_INT 85
52327: PUSH
52328: LD_INT 87
52330: PUSH
52331: LD_INT 88
52333: PUSH
52334: EMPTY
52335: LIST
52336: LIST
52337: LIST
52338: LIST
52339: LIST
52340: LIST
52341: LIST
52342: LIST
52343: LIST
52344: LIST
52345: LIST
52346: LIST
52347: LIST
52348: LIST
52349: LIST
52350: LIST
52351: LIST
52352: LIST
52353: LIST
52354: LIST
52355: LIST
52356: LIST
52357: LIST
52358: LIST
52359: LIST
52360: LIST
52361: LIST
52362: LIST
52363: LIST
52364: LIST
52365: LIST
52366: LIST
52367: LIST
52368: LIST
52369: LIST
52370: LIST
52371: LIST
52372: LIST
52373: LIST
52374: LIST
52375: LIST
52376: LIST
52377: LIST
52378: LIST
52379: LIST
52380: LIST
52381: LIST
52382: LIST
52383: LIST
52384: LIST
52385: LIST
52386: LIST
52387: LIST
52388: LIST
52389: ST_TO_ADDR
52390: GO 52623
52392: LD_INT 3
52394: DOUBLE
52395: EQUAL
52396: IFTRUE 52400
52398: GO 52622
52400: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52401: LD_ADDR_VAR 0 4
52405: PUSH
52406: LD_INT 46
52408: PUSH
52409: LD_INT 47
52411: PUSH
52412: LD_INT 1
52414: PUSH
52415: LD_INT 2
52417: PUSH
52418: LD_INT 82
52420: PUSH
52421: LD_INT 83
52423: PUSH
52424: LD_INT 84
52426: PUSH
52427: LD_INT 85
52429: PUSH
52430: LD_INT 86
52432: PUSH
52433: LD_INT 11
52435: PUSH
52436: LD_INT 9
52438: PUSH
52439: LD_INT 20
52441: PUSH
52442: LD_INT 19
52444: PUSH
52445: LD_INT 21
52447: PUSH
52448: LD_INT 24
52450: PUSH
52451: LD_INT 22
52453: PUSH
52454: LD_INT 25
52456: PUSH
52457: LD_INT 28
52459: PUSH
52460: LD_INT 29
52462: PUSH
52463: LD_INT 30
52465: PUSH
52466: LD_INT 31
52468: PUSH
52469: LD_INT 37
52471: PUSH
52472: LD_INT 38
52474: PUSH
52475: LD_INT 32
52477: PUSH
52478: LD_INT 27
52480: PUSH
52481: LD_INT 33
52483: PUSH
52484: LD_INT 69
52486: PUSH
52487: LD_INT 39
52489: PUSH
52490: LD_INT 34
52492: PUSH
52493: LD_INT 40
52495: PUSH
52496: LD_INT 71
52498: PUSH
52499: LD_INT 23
52501: PUSH
52502: LD_INT 44
52504: PUSH
52505: LD_INT 48
52507: PUSH
52508: LD_INT 49
52510: PUSH
52511: LD_INT 50
52513: PUSH
52514: LD_INT 51
52516: PUSH
52517: LD_INT 52
52519: PUSH
52520: LD_INT 53
52522: PUSH
52523: LD_INT 54
52525: PUSH
52526: LD_INT 55
52528: PUSH
52529: LD_INT 56
52531: PUSH
52532: LD_INT 57
52534: PUSH
52535: LD_INT 58
52537: PUSH
52538: LD_INT 59
52540: PUSH
52541: LD_INT 63
52543: PUSH
52544: LD_INT 64
52546: PUSH
52547: LD_INT 65
52549: PUSH
52550: LD_INT 82
52552: PUSH
52553: LD_INT 83
52555: PUSH
52556: LD_INT 84
52558: PUSH
52559: LD_INT 85
52561: PUSH
52562: LD_INT 86
52564: PUSH
52565: EMPTY
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: LIST
52571: LIST
52572: LIST
52573: LIST
52574: LIST
52575: LIST
52576: LIST
52577: LIST
52578: LIST
52579: LIST
52580: LIST
52581: LIST
52582: LIST
52583: LIST
52584: LIST
52585: LIST
52586: LIST
52587: LIST
52588: LIST
52589: LIST
52590: LIST
52591: LIST
52592: LIST
52593: LIST
52594: LIST
52595: LIST
52596: LIST
52597: LIST
52598: LIST
52599: LIST
52600: LIST
52601: LIST
52602: LIST
52603: LIST
52604: LIST
52605: LIST
52606: LIST
52607: LIST
52608: LIST
52609: LIST
52610: LIST
52611: LIST
52612: LIST
52613: LIST
52614: LIST
52615: LIST
52616: LIST
52617: LIST
52618: LIST
52619: ST_TO_ADDR
52620: GO 52623
52622: POP
// if state > - 1 and state < 3 then
52623: LD_VAR 0 3
52627: PUSH
52628: LD_INT 1
52630: NEG
52631: GREATER
52632: PUSH
52633: LD_VAR 0 3
52637: PUSH
52638: LD_INT 3
52640: LESS
52641: AND
52642: IFFALSE 52699
// for i in result do
52644: LD_ADDR_VAR 0 5
52648: PUSH
52649: LD_VAR 0 4
52653: PUSH
52654: FOR_IN
52655: IFFALSE 52697
// if GetTech ( i , side ) <> state then
52657: LD_VAR 0 5
52661: PPUSH
52662: LD_VAR 0 1
52666: PPUSH
52667: CALL_OW 321
52671: PUSH
52672: LD_VAR 0 3
52676: NONEQUAL
52677: IFFALSE 52695
// result := result diff i ;
52679: LD_ADDR_VAR 0 4
52683: PUSH
52684: LD_VAR 0 4
52688: PUSH
52689: LD_VAR 0 5
52693: DIFF
52694: ST_TO_ADDR
52695: GO 52654
52697: POP
52698: POP
// end ;
52699: LD_VAR 0 4
52703: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52704: LD_INT 0
52706: PPUSH
52707: PPUSH
52708: PPUSH
// result := true ;
52709: LD_ADDR_VAR 0 3
52713: PUSH
52714: LD_INT 1
52716: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52717: LD_ADDR_VAR 0 5
52721: PUSH
52722: LD_VAR 0 2
52726: PPUSH
52727: CALL_OW 480
52731: ST_TO_ADDR
// if not tmp then
52732: LD_VAR 0 5
52736: NOT
52737: IFFALSE 52741
// exit ;
52739: GO 52790
// for i in tmp do
52741: LD_ADDR_VAR 0 4
52745: PUSH
52746: LD_VAR 0 5
52750: PUSH
52751: FOR_IN
52752: IFFALSE 52788
// if GetTech ( i , side ) <> state_researched then
52754: LD_VAR 0 4
52758: PPUSH
52759: LD_VAR 0 1
52763: PPUSH
52764: CALL_OW 321
52768: PUSH
52769: LD_INT 2
52771: NONEQUAL
52772: IFFALSE 52786
// begin result := false ;
52774: LD_ADDR_VAR 0 3
52778: PUSH
52779: LD_INT 0
52781: ST_TO_ADDR
// exit ;
52782: POP
52783: POP
52784: GO 52790
// end ;
52786: GO 52751
52788: POP
52789: POP
// end ;
52790: LD_VAR 0 3
52794: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52795: LD_INT 0
52797: PPUSH
52798: PPUSH
52799: PPUSH
52800: PPUSH
52801: PPUSH
52802: PPUSH
52803: PPUSH
52804: PPUSH
52805: PPUSH
52806: PPUSH
52807: PPUSH
52808: PPUSH
52809: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52810: LD_VAR 0 1
52814: NOT
52815: PUSH
52816: LD_VAR 0 1
52820: PPUSH
52821: CALL_OW 257
52825: PUSH
52826: LD_INT 9
52828: NONEQUAL
52829: OR
52830: IFFALSE 52834
// exit ;
52832: GO 53407
// side := GetSide ( unit ) ;
52834: LD_ADDR_VAR 0 9
52838: PUSH
52839: LD_VAR 0 1
52843: PPUSH
52844: CALL_OW 255
52848: ST_TO_ADDR
// tech_space := tech_spacanom ;
52849: LD_ADDR_VAR 0 12
52853: PUSH
52854: LD_INT 29
52856: ST_TO_ADDR
// tech_time := tech_taurad ;
52857: LD_ADDR_VAR 0 13
52861: PUSH
52862: LD_INT 28
52864: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
52865: LD_ADDR_VAR 0 11
52869: PUSH
52870: LD_VAR 0 1
52874: PPUSH
52875: CALL_OW 310
52879: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
52880: LD_VAR 0 11
52884: PPUSH
52885: CALL_OW 247
52889: PUSH
52890: LD_INT 2
52892: EQUAL
52893: IFFALSE 52897
// exit ;
52895: GO 53407
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52897: LD_ADDR_VAR 0 8
52901: PUSH
52902: LD_INT 81
52904: PUSH
52905: LD_VAR 0 9
52909: PUSH
52910: EMPTY
52911: LIST
52912: LIST
52913: PUSH
52914: LD_INT 3
52916: PUSH
52917: LD_INT 21
52919: PUSH
52920: LD_INT 3
52922: PUSH
52923: EMPTY
52924: LIST
52925: LIST
52926: PUSH
52927: EMPTY
52928: LIST
52929: LIST
52930: PUSH
52931: EMPTY
52932: LIST
52933: LIST
52934: PPUSH
52935: CALL_OW 69
52939: ST_TO_ADDR
// if not tmp then
52940: LD_VAR 0 8
52944: NOT
52945: IFFALSE 52949
// exit ;
52947: GO 53407
// if in_unit then
52949: LD_VAR 0 11
52953: IFFALSE 52977
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
52955: LD_ADDR_VAR 0 10
52959: PUSH
52960: LD_VAR 0 8
52964: PPUSH
52965: LD_VAR 0 11
52969: PPUSH
52970: CALL_OW 74
52974: ST_TO_ADDR
52975: GO 52997
// enemy := NearestUnitToUnit ( tmp , unit ) ;
52977: LD_ADDR_VAR 0 10
52981: PUSH
52982: LD_VAR 0 8
52986: PPUSH
52987: LD_VAR 0 1
52991: PPUSH
52992: CALL_OW 74
52996: ST_TO_ADDR
// if not enemy then
52997: LD_VAR 0 10
53001: NOT
53002: IFFALSE 53006
// exit ;
53004: GO 53407
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53006: LD_VAR 0 11
53010: PUSH
53011: LD_VAR 0 11
53015: PPUSH
53016: LD_VAR 0 10
53020: PPUSH
53021: CALL_OW 296
53025: PUSH
53026: LD_INT 13
53028: GREATER
53029: AND
53030: PUSH
53031: LD_VAR 0 1
53035: PPUSH
53036: LD_VAR 0 10
53040: PPUSH
53041: CALL_OW 296
53045: PUSH
53046: LD_INT 12
53048: GREATER
53049: OR
53050: IFFALSE 53054
// exit ;
53052: GO 53407
// missile := [ 1 ] ;
53054: LD_ADDR_VAR 0 14
53058: PUSH
53059: LD_INT 1
53061: PUSH
53062: EMPTY
53063: LIST
53064: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53065: LD_VAR 0 9
53069: PPUSH
53070: LD_VAR 0 12
53074: PPUSH
53075: CALL_OW 325
53079: IFFALSE 53108
// missile := Replace ( missile , missile + 1 , 2 ) ;
53081: LD_ADDR_VAR 0 14
53085: PUSH
53086: LD_VAR 0 14
53090: PPUSH
53091: LD_VAR 0 14
53095: PUSH
53096: LD_INT 1
53098: PLUS
53099: PPUSH
53100: LD_INT 2
53102: PPUSH
53103: CALL_OW 1
53107: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53108: LD_VAR 0 9
53112: PPUSH
53113: LD_VAR 0 13
53117: PPUSH
53118: CALL_OW 325
53122: PUSH
53123: LD_VAR 0 10
53127: PPUSH
53128: CALL_OW 255
53132: PPUSH
53133: LD_VAR 0 13
53137: PPUSH
53138: CALL_OW 325
53142: NOT
53143: AND
53144: IFFALSE 53173
// missile := Replace ( missile , missile + 1 , 3 ) ;
53146: LD_ADDR_VAR 0 14
53150: PUSH
53151: LD_VAR 0 14
53155: PPUSH
53156: LD_VAR 0 14
53160: PUSH
53161: LD_INT 1
53163: PLUS
53164: PPUSH
53165: LD_INT 3
53167: PPUSH
53168: CALL_OW 1
53172: ST_TO_ADDR
// if missile < 2 then
53173: LD_VAR 0 14
53177: PUSH
53178: LD_INT 2
53180: LESS
53181: IFFALSE 53185
// exit ;
53183: GO 53407
// x := GetX ( enemy ) ;
53185: LD_ADDR_VAR 0 4
53189: PUSH
53190: LD_VAR 0 10
53194: PPUSH
53195: CALL_OW 250
53199: ST_TO_ADDR
// y := GetY ( enemy ) ;
53200: LD_ADDR_VAR 0 5
53204: PUSH
53205: LD_VAR 0 10
53209: PPUSH
53210: CALL_OW 251
53214: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53215: LD_ADDR_VAR 0 6
53219: PUSH
53220: LD_VAR 0 4
53224: PUSH
53225: LD_INT 1
53227: NEG
53228: PPUSH
53229: LD_INT 1
53231: PPUSH
53232: CALL_OW 12
53236: PLUS
53237: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53238: LD_ADDR_VAR 0 7
53242: PUSH
53243: LD_VAR 0 5
53247: PUSH
53248: LD_INT 1
53250: NEG
53251: PPUSH
53252: LD_INT 1
53254: PPUSH
53255: CALL_OW 12
53259: PLUS
53260: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53261: LD_VAR 0 6
53265: PPUSH
53266: LD_VAR 0 7
53270: PPUSH
53271: CALL_OW 488
53275: NOT
53276: IFFALSE 53298
// begin _x := x ;
53278: LD_ADDR_VAR 0 6
53282: PUSH
53283: LD_VAR 0 4
53287: ST_TO_ADDR
// _y := y ;
53288: LD_ADDR_VAR 0 7
53292: PUSH
53293: LD_VAR 0 5
53297: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53298: LD_ADDR_VAR 0 3
53302: PUSH
53303: LD_INT 1
53305: PPUSH
53306: LD_VAR 0 14
53310: PPUSH
53311: CALL_OW 12
53315: ST_TO_ADDR
// case i of 1 :
53316: LD_VAR 0 3
53320: PUSH
53321: LD_INT 1
53323: DOUBLE
53324: EQUAL
53325: IFTRUE 53329
53327: GO 53346
53329: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53330: LD_VAR 0 1
53334: PPUSH
53335: LD_VAR 0 10
53339: PPUSH
53340: CALL_OW 115
53344: GO 53407
53346: LD_INT 2
53348: DOUBLE
53349: EQUAL
53350: IFTRUE 53354
53352: GO 53376
53354: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53355: LD_VAR 0 1
53359: PPUSH
53360: LD_VAR 0 6
53364: PPUSH
53365: LD_VAR 0 7
53369: PPUSH
53370: CALL_OW 153
53374: GO 53407
53376: LD_INT 3
53378: DOUBLE
53379: EQUAL
53380: IFTRUE 53384
53382: GO 53406
53384: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53385: LD_VAR 0 1
53389: PPUSH
53390: LD_VAR 0 6
53394: PPUSH
53395: LD_VAR 0 7
53399: PPUSH
53400: CALL_OW 154
53404: GO 53407
53406: POP
// end ;
53407: LD_VAR 0 2
53411: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53412: LD_INT 0
53414: PPUSH
53415: PPUSH
53416: PPUSH
53417: PPUSH
53418: PPUSH
53419: PPUSH
// if not unit or not building then
53420: LD_VAR 0 1
53424: NOT
53425: PUSH
53426: LD_VAR 0 2
53430: NOT
53431: OR
53432: IFFALSE 53436
// exit ;
53434: GO 53594
// x := GetX ( building ) ;
53436: LD_ADDR_VAR 0 5
53440: PUSH
53441: LD_VAR 0 2
53445: PPUSH
53446: CALL_OW 250
53450: ST_TO_ADDR
// y := GetY ( building ) ;
53451: LD_ADDR_VAR 0 6
53455: PUSH
53456: LD_VAR 0 2
53460: PPUSH
53461: CALL_OW 251
53465: ST_TO_ADDR
// for i = 0 to 5 do
53466: LD_ADDR_VAR 0 4
53470: PUSH
53471: DOUBLE
53472: LD_INT 0
53474: DEC
53475: ST_TO_ADDR
53476: LD_INT 5
53478: PUSH
53479: FOR_TO
53480: IFFALSE 53592
// begin _x := ShiftX ( x , i , 3 ) ;
53482: LD_ADDR_VAR 0 7
53486: PUSH
53487: LD_VAR 0 5
53491: PPUSH
53492: LD_VAR 0 4
53496: PPUSH
53497: LD_INT 3
53499: PPUSH
53500: CALL_OW 272
53504: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53505: LD_ADDR_VAR 0 8
53509: PUSH
53510: LD_VAR 0 6
53514: PPUSH
53515: LD_VAR 0 4
53519: PPUSH
53520: LD_INT 3
53522: PPUSH
53523: CALL_OW 273
53527: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53528: LD_VAR 0 7
53532: PPUSH
53533: LD_VAR 0 8
53537: PPUSH
53538: CALL_OW 488
53542: NOT
53543: IFFALSE 53547
// continue ;
53545: GO 53479
// if HexInfo ( _x , _y ) = 0 then
53547: LD_VAR 0 7
53551: PPUSH
53552: LD_VAR 0 8
53556: PPUSH
53557: CALL_OW 428
53561: PUSH
53562: LD_INT 0
53564: EQUAL
53565: IFFALSE 53590
// begin ComMoveXY ( unit , _x , _y ) ;
53567: LD_VAR 0 1
53571: PPUSH
53572: LD_VAR 0 7
53576: PPUSH
53577: LD_VAR 0 8
53581: PPUSH
53582: CALL_OW 111
// exit ;
53586: POP
53587: POP
53588: GO 53594
// end ; end ;
53590: GO 53479
53592: POP
53593: POP
// end ;
53594: LD_VAR 0 3
53598: RET
// export function ScanBase ( side , base_area ) ; begin
53599: LD_INT 0
53601: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53602: LD_ADDR_VAR 0 3
53606: PUSH
53607: LD_VAR 0 2
53611: PPUSH
53612: LD_INT 81
53614: PUSH
53615: LD_VAR 0 1
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: PPUSH
53624: CALL_OW 70
53628: ST_TO_ADDR
// end ;
53629: LD_VAR 0 3
53633: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53634: LD_INT 0
53636: PPUSH
53637: PPUSH
53638: PPUSH
53639: PPUSH
// result := false ;
53640: LD_ADDR_VAR 0 2
53644: PUSH
53645: LD_INT 0
53647: ST_TO_ADDR
// side := GetSide ( unit ) ;
53648: LD_ADDR_VAR 0 3
53652: PUSH
53653: LD_VAR 0 1
53657: PPUSH
53658: CALL_OW 255
53662: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53663: LD_ADDR_VAR 0 4
53667: PUSH
53668: LD_VAR 0 1
53672: PPUSH
53673: CALL_OW 248
53677: ST_TO_ADDR
// case nat of 1 :
53678: LD_VAR 0 4
53682: PUSH
53683: LD_INT 1
53685: DOUBLE
53686: EQUAL
53687: IFTRUE 53691
53689: GO 53702
53691: POP
// tech := tech_lassight ; 2 :
53692: LD_ADDR_VAR 0 5
53696: PUSH
53697: LD_INT 12
53699: ST_TO_ADDR
53700: GO 53741
53702: LD_INT 2
53704: DOUBLE
53705: EQUAL
53706: IFTRUE 53710
53708: GO 53721
53710: POP
// tech := tech_mortar ; 3 :
53711: LD_ADDR_VAR 0 5
53715: PUSH
53716: LD_INT 41
53718: ST_TO_ADDR
53719: GO 53741
53721: LD_INT 3
53723: DOUBLE
53724: EQUAL
53725: IFTRUE 53729
53727: GO 53740
53729: POP
// tech := tech_bazooka ; end ;
53730: LD_ADDR_VAR 0 5
53734: PUSH
53735: LD_INT 44
53737: ST_TO_ADDR
53738: GO 53741
53740: POP
// if Researched ( side , tech ) then
53741: LD_VAR 0 3
53745: PPUSH
53746: LD_VAR 0 5
53750: PPUSH
53751: CALL_OW 325
53755: IFFALSE 53782
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53757: LD_ADDR_VAR 0 2
53761: PUSH
53762: LD_INT 5
53764: PUSH
53765: LD_INT 8
53767: PUSH
53768: LD_INT 9
53770: PUSH
53771: EMPTY
53772: LIST
53773: LIST
53774: LIST
53775: PUSH
53776: LD_VAR 0 4
53780: ARRAY
53781: ST_TO_ADDR
// end ;
53782: LD_VAR 0 2
53786: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53787: LD_INT 0
53789: PPUSH
53790: PPUSH
53791: PPUSH
// if not mines then
53792: LD_VAR 0 2
53796: NOT
53797: IFFALSE 53801
// exit ;
53799: GO 53945
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53801: LD_ADDR_VAR 0 5
53805: PUSH
53806: LD_INT 81
53808: PUSH
53809: LD_VAR 0 1
53813: PUSH
53814: EMPTY
53815: LIST
53816: LIST
53817: PUSH
53818: LD_INT 3
53820: PUSH
53821: LD_INT 21
53823: PUSH
53824: LD_INT 3
53826: PUSH
53827: EMPTY
53828: LIST
53829: LIST
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: PUSH
53835: EMPTY
53836: LIST
53837: LIST
53838: PPUSH
53839: CALL_OW 69
53843: ST_TO_ADDR
// for i in mines do
53844: LD_ADDR_VAR 0 4
53848: PUSH
53849: LD_VAR 0 2
53853: PUSH
53854: FOR_IN
53855: IFFALSE 53943
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53857: LD_VAR 0 4
53861: PUSH
53862: LD_INT 1
53864: ARRAY
53865: PPUSH
53866: LD_VAR 0 4
53870: PUSH
53871: LD_INT 2
53873: ARRAY
53874: PPUSH
53875: CALL_OW 458
53879: NOT
53880: IFFALSE 53884
// continue ;
53882: GO 53854
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53884: LD_VAR 0 4
53888: PUSH
53889: LD_INT 1
53891: ARRAY
53892: PPUSH
53893: LD_VAR 0 4
53897: PUSH
53898: LD_INT 2
53900: ARRAY
53901: PPUSH
53902: CALL_OW 428
53906: PUSH
53907: LD_VAR 0 5
53911: IN
53912: IFFALSE 53941
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53914: LD_VAR 0 4
53918: PUSH
53919: LD_INT 1
53921: ARRAY
53922: PPUSH
53923: LD_VAR 0 4
53927: PUSH
53928: LD_INT 2
53930: ARRAY
53931: PPUSH
53932: LD_VAR 0 1
53936: PPUSH
53937: CALL_OW 456
// end ;
53941: GO 53854
53943: POP
53944: POP
// end ;
53945: LD_VAR 0 3
53949: RET
// export function Count ( array ) ; var i ; begin
53950: LD_INT 0
53952: PPUSH
53953: PPUSH
// result := 0 ;
53954: LD_ADDR_VAR 0 2
53958: PUSH
53959: LD_INT 0
53961: ST_TO_ADDR
// for i in array do
53962: LD_ADDR_VAR 0 3
53966: PUSH
53967: LD_VAR 0 1
53971: PUSH
53972: FOR_IN
53973: IFFALSE 53997
// if i then
53975: LD_VAR 0 3
53979: IFFALSE 53995
// result := result + 1 ;
53981: LD_ADDR_VAR 0 2
53985: PUSH
53986: LD_VAR 0 2
53990: PUSH
53991: LD_INT 1
53993: PLUS
53994: ST_TO_ADDR
53995: GO 53972
53997: POP
53998: POP
// end ;
53999: LD_VAR 0 2
54003: RET
// export function IsEmpty ( building ) ; begin
54004: LD_INT 0
54006: PPUSH
// if not building then
54007: LD_VAR 0 1
54011: NOT
54012: IFFALSE 54016
// exit ;
54014: GO 54059
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54016: LD_ADDR_VAR 0 2
54020: PUSH
54021: LD_VAR 0 1
54025: PUSH
54026: LD_INT 22
54028: PUSH
54029: LD_VAR 0 1
54033: PPUSH
54034: CALL_OW 255
54038: PUSH
54039: EMPTY
54040: LIST
54041: LIST
54042: PUSH
54043: LD_INT 58
54045: PUSH
54046: EMPTY
54047: LIST
54048: PUSH
54049: EMPTY
54050: LIST
54051: LIST
54052: PPUSH
54053: CALL_OW 69
54057: IN
54058: ST_TO_ADDR
// end ;
54059: LD_VAR 0 2
54063: RET
// export function IsNotFull ( building ) ; var places ; begin
54064: LD_INT 0
54066: PPUSH
54067: PPUSH
// if not building then
54068: LD_VAR 0 1
54072: NOT
54073: IFFALSE 54077
// exit ;
54075: GO 54248
// result := false ;
54077: LD_ADDR_VAR 0 2
54081: PUSH
54082: LD_INT 0
54084: ST_TO_ADDR
// places := 0 ;
54085: LD_ADDR_VAR 0 3
54089: PUSH
54090: LD_INT 0
54092: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
54093: LD_VAR 0 1
54097: PPUSH
54098: CALL_OW 266
54102: PUSH
54103: LD_INT 0
54105: DOUBLE
54106: EQUAL
54107: IFTRUE 54165
54109: LD_INT 1
54111: DOUBLE
54112: EQUAL
54113: IFTRUE 54165
54115: LD_INT 6
54117: DOUBLE
54118: EQUAL
54119: IFTRUE 54165
54121: LD_INT 7
54123: DOUBLE
54124: EQUAL
54125: IFTRUE 54165
54127: LD_INT 8
54129: DOUBLE
54130: EQUAL
54131: IFTRUE 54165
54133: LD_INT 4
54135: DOUBLE
54136: EQUAL
54137: IFTRUE 54165
54139: LD_INT 5
54141: DOUBLE
54142: EQUAL
54143: IFTRUE 54165
54145: LD_INT 2
54147: DOUBLE
54148: EQUAL
54149: IFTRUE 54165
54151: LD_INT 3
54153: DOUBLE
54154: EQUAL
54155: IFTRUE 54165
54157: LD_INT 35
54159: DOUBLE
54160: EQUAL
54161: IFTRUE 54165
54163: GO 54176
54165: POP
// places := 6 ; b_bunker , b_breastwork :
54166: LD_ADDR_VAR 0 3
54170: PUSH
54171: LD_INT 6
54173: ST_TO_ADDR
54174: GO 54221
54176: LD_INT 32
54178: DOUBLE
54179: EQUAL
54180: IFTRUE 54190
54182: LD_INT 31
54184: DOUBLE
54185: EQUAL
54186: IFTRUE 54190
54188: GO 54201
54190: POP
// places := 1 ; b_control_tower :
54191: LD_ADDR_VAR 0 3
54195: PUSH
54196: LD_INT 1
54198: ST_TO_ADDR
54199: GO 54221
54201: LD_INT 36
54203: DOUBLE
54204: EQUAL
54205: IFTRUE 54209
54207: GO 54220
54209: POP
// places := 3 ; end ;
54210: LD_ADDR_VAR 0 3
54214: PUSH
54215: LD_INT 3
54217: ST_TO_ADDR
54218: GO 54221
54220: POP
// if places then
54221: LD_VAR 0 3
54225: IFFALSE 54248
// result := UnitsInside ( building ) < places ;
54227: LD_ADDR_VAR 0 2
54231: PUSH
54232: LD_VAR 0 1
54236: PPUSH
54237: CALL_OW 313
54241: PUSH
54242: LD_VAR 0 3
54246: LESS
54247: ST_TO_ADDR
// end ;
54248: LD_VAR 0 2
54252: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54253: LD_INT 0
54255: PPUSH
54256: PPUSH
54257: PPUSH
54258: PPUSH
// tmp := [ ] ;
54259: LD_ADDR_VAR 0 3
54263: PUSH
54264: EMPTY
54265: ST_TO_ADDR
// list := [ ] ;
54266: LD_ADDR_VAR 0 5
54270: PUSH
54271: EMPTY
54272: ST_TO_ADDR
// for i = 16 to 25 do
54273: LD_ADDR_VAR 0 4
54277: PUSH
54278: DOUBLE
54279: LD_INT 16
54281: DEC
54282: ST_TO_ADDR
54283: LD_INT 25
54285: PUSH
54286: FOR_TO
54287: IFFALSE 54360
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54289: LD_ADDR_VAR 0 3
54293: PUSH
54294: LD_VAR 0 3
54298: PUSH
54299: LD_INT 22
54301: PUSH
54302: LD_VAR 0 1
54306: PPUSH
54307: CALL_OW 255
54311: PUSH
54312: EMPTY
54313: LIST
54314: LIST
54315: PUSH
54316: LD_INT 91
54318: PUSH
54319: LD_VAR 0 1
54323: PUSH
54324: LD_INT 6
54326: PUSH
54327: EMPTY
54328: LIST
54329: LIST
54330: LIST
54331: PUSH
54332: LD_INT 30
54334: PUSH
54335: LD_VAR 0 4
54339: PUSH
54340: EMPTY
54341: LIST
54342: LIST
54343: PUSH
54344: EMPTY
54345: LIST
54346: LIST
54347: LIST
54348: PUSH
54349: EMPTY
54350: LIST
54351: PPUSH
54352: CALL_OW 69
54356: ADD
54357: ST_TO_ADDR
54358: GO 54286
54360: POP
54361: POP
// for i = 1 to tmp do
54362: LD_ADDR_VAR 0 4
54366: PUSH
54367: DOUBLE
54368: LD_INT 1
54370: DEC
54371: ST_TO_ADDR
54372: LD_VAR 0 3
54376: PUSH
54377: FOR_TO
54378: IFFALSE 54466
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54380: LD_ADDR_VAR 0 5
54384: PUSH
54385: LD_VAR 0 5
54389: PUSH
54390: LD_VAR 0 3
54394: PUSH
54395: LD_VAR 0 4
54399: ARRAY
54400: PPUSH
54401: CALL_OW 266
54405: PUSH
54406: LD_VAR 0 3
54410: PUSH
54411: LD_VAR 0 4
54415: ARRAY
54416: PPUSH
54417: CALL_OW 250
54421: PUSH
54422: LD_VAR 0 3
54426: PUSH
54427: LD_VAR 0 4
54431: ARRAY
54432: PPUSH
54433: CALL_OW 251
54437: PUSH
54438: LD_VAR 0 3
54442: PUSH
54443: LD_VAR 0 4
54447: ARRAY
54448: PPUSH
54449: CALL_OW 254
54453: PUSH
54454: EMPTY
54455: LIST
54456: LIST
54457: LIST
54458: LIST
54459: PUSH
54460: EMPTY
54461: LIST
54462: ADD
54463: ST_TO_ADDR
54464: GO 54377
54466: POP
54467: POP
// result := list ;
54468: LD_ADDR_VAR 0 2
54472: PUSH
54473: LD_VAR 0 5
54477: ST_TO_ADDR
// end ;
54478: LD_VAR 0 2
54482: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54483: LD_INT 0
54485: PPUSH
54486: PPUSH
54487: PPUSH
54488: PPUSH
54489: PPUSH
54490: PPUSH
54491: PPUSH
// if not factory then
54492: LD_VAR 0 1
54496: NOT
54497: IFFALSE 54501
// exit ;
54499: GO 55094
// if control = control_apeman then
54501: LD_VAR 0 4
54505: PUSH
54506: LD_INT 5
54508: EQUAL
54509: IFFALSE 54618
// begin tmp := UnitsInside ( factory ) ;
54511: LD_ADDR_VAR 0 8
54515: PUSH
54516: LD_VAR 0 1
54520: PPUSH
54521: CALL_OW 313
54525: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54526: LD_VAR 0 8
54530: PPUSH
54531: LD_INT 25
54533: PUSH
54534: LD_INT 12
54536: PUSH
54537: EMPTY
54538: LIST
54539: LIST
54540: PPUSH
54541: CALL_OW 72
54545: NOT
54546: IFFALSE 54556
// control := control_manual ;
54548: LD_ADDR_VAR 0 4
54552: PUSH
54553: LD_INT 1
54555: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54556: LD_ADDR_VAR 0 8
54560: PUSH
54561: LD_VAR 0 1
54565: PPUSH
54566: CALL 54253 0 1
54570: ST_TO_ADDR
// if tmp then
54571: LD_VAR 0 8
54575: IFFALSE 54618
// begin for i in tmp do
54577: LD_ADDR_VAR 0 7
54581: PUSH
54582: LD_VAR 0 8
54586: PUSH
54587: FOR_IN
54588: IFFALSE 54616
// if i [ 1 ] = b_ext_radio then
54590: LD_VAR 0 7
54594: PUSH
54595: LD_INT 1
54597: ARRAY
54598: PUSH
54599: LD_INT 22
54601: EQUAL
54602: IFFALSE 54614
// begin control := control_remote ;
54604: LD_ADDR_VAR 0 4
54608: PUSH
54609: LD_INT 2
54611: ST_TO_ADDR
// break ;
54612: GO 54616
// end ;
54614: GO 54587
54616: POP
54617: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54618: LD_VAR 0 1
54622: PPUSH
54623: LD_VAR 0 2
54627: PPUSH
54628: LD_VAR 0 3
54632: PPUSH
54633: LD_VAR 0 4
54637: PPUSH
54638: LD_VAR 0 5
54642: PPUSH
54643: CALL_OW 448
54647: IFFALSE 54682
// begin result := [ chassis , engine , control , weapon ] ;
54649: LD_ADDR_VAR 0 6
54653: PUSH
54654: LD_VAR 0 2
54658: PUSH
54659: LD_VAR 0 3
54663: PUSH
54664: LD_VAR 0 4
54668: PUSH
54669: LD_VAR 0 5
54673: PUSH
54674: EMPTY
54675: LIST
54676: LIST
54677: LIST
54678: LIST
54679: ST_TO_ADDR
// exit ;
54680: GO 55094
// end ; _chassis := AvailableChassisList ( factory ) ;
54682: LD_ADDR_VAR 0 9
54686: PUSH
54687: LD_VAR 0 1
54691: PPUSH
54692: CALL_OW 475
54696: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54697: LD_ADDR_VAR 0 11
54701: PUSH
54702: LD_VAR 0 1
54706: PPUSH
54707: CALL_OW 476
54711: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54712: LD_ADDR_VAR 0 12
54716: PUSH
54717: LD_VAR 0 1
54721: PPUSH
54722: CALL_OW 477
54726: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54727: LD_ADDR_VAR 0 10
54731: PUSH
54732: LD_VAR 0 1
54736: PPUSH
54737: CALL_OW 478
54741: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54742: LD_VAR 0 9
54746: NOT
54747: PUSH
54748: LD_VAR 0 11
54752: NOT
54753: OR
54754: PUSH
54755: LD_VAR 0 12
54759: NOT
54760: OR
54761: PUSH
54762: LD_VAR 0 10
54766: NOT
54767: OR
54768: IFFALSE 54803
// begin result := [ chassis , engine , control , weapon ] ;
54770: LD_ADDR_VAR 0 6
54774: PUSH
54775: LD_VAR 0 2
54779: PUSH
54780: LD_VAR 0 3
54784: PUSH
54785: LD_VAR 0 4
54789: PUSH
54790: LD_VAR 0 5
54794: PUSH
54795: EMPTY
54796: LIST
54797: LIST
54798: LIST
54799: LIST
54800: ST_TO_ADDR
// exit ;
54801: GO 55094
// end ; if not chassis in _chassis then
54803: LD_VAR 0 2
54807: PUSH
54808: LD_VAR 0 9
54812: IN
54813: NOT
54814: IFFALSE 54840
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54816: LD_ADDR_VAR 0 2
54820: PUSH
54821: LD_VAR 0 9
54825: PUSH
54826: LD_INT 1
54828: PPUSH
54829: LD_VAR 0 9
54833: PPUSH
54834: CALL_OW 12
54838: ARRAY
54839: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54840: LD_VAR 0 2
54844: PPUSH
54845: LD_VAR 0 3
54849: PPUSH
54850: CALL 55099 0 2
54854: NOT
54855: IFFALSE 54914
// repeat engine := _engine [ 1 ] ;
54857: LD_ADDR_VAR 0 3
54861: PUSH
54862: LD_VAR 0 11
54866: PUSH
54867: LD_INT 1
54869: ARRAY
54870: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54871: LD_ADDR_VAR 0 11
54875: PUSH
54876: LD_VAR 0 11
54880: PPUSH
54881: LD_INT 1
54883: PPUSH
54884: CALL_OW 3
54888: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54889: LD_VAR 0 2
54893: PPUSH
54894: LD_VAR 0 3
54898: PPUSH
54899: CALL 55099 0 2
54903: PUSH
54904: LD_VAR 0 11
54908: PUSH
54909: EMPTY
54910: EQUAL
54911: OR
54912: IFFALSE 54857
// if not control in _control then
54914: LD_VAR 0 4
54918: PUSH
54919: LD_VAR 0 12
54923: IN
54924: NOT
54925: IFFALSE 54951
// control := _control [ rand ( 1 , _control ) ] ;
54927: LD_ADDR_VAR 0 4
54931: PUSH
54932: LD_VAR 0 12
54936: PUSH
54937: LD_INT 1
54939: PPUSH
54940: LD_VAR 0 12
54944: PPUSH
54945: CALL_OW 12
54949: ARRAY
54950: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54951: LD_VAR 0 2
54955: PPUSH
54956: LD_VAR 0 5
54960: PPUSH
54961: CALL 55319 0 2
54965: NOT
54966: IFFALSE 55025
// repeat weapon := _weapon [ 1 ] ;
54968: LD_ADDR_VAR 0 5
54972: PUSH
54973: LD_VAR 0 10
54977: PUSH
54978: LD_INT 1
54980: ARRAY
54981: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54982: LD_ADDR_VAR 0 10
54986: PUSH
54987: LD_VAR 0 10
54991: PPUSH
54992: LD_INT 1
54994: PPUSH
54995: CALL_OW 3
54999: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55000: LD_VAR 0 2
55004: PPUSH
55005: LD_VAR 0 5
55009: PPUSH
55010: CALL 55319 0 2
55014: PUSH
55015: LD_VAR 0 10
55019: PUSH
55020: EMPTY
55021: EQUAL
55022: OR
55023: IFFALSE 54968
// result := [ ] ;
55025: LD_ADDR_VAR 0 6
55029: PUSH
55030: EMPTY
55031: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55032: LD_VAR 0 1
55036: PPUSH
55037: LD_VAR 0 2
55041: PPUSH
55042: LD_VAR 0 3
55046: PPUSH
55047: LD_VAR 0 4
55051: PPUSH
55052: LD_VAR 0 5
55056: PPUSH
55057: CALL_OW 448
55061: IFFALSE 55094
// result := [ chassis , engine , control , weapon ] ;
55063: LD_ADDR_VAR 0 6
55067: PUSH
55068: LD_VAR 0 2
55072: PUSH
55073: LD_VAR 0 3
55077: PUSH
55078: LD_VAR 0 4
55082: PUSH
55083: LD_VAR 0 5
55087: PUSH
55088: EMPTY
55089: LIST
55090: LIST
55091: LIST
55092: LIST
55093: ST_TO_ADDR
// end ;
55094: LD_VAR 0 6
55098: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55099: LD_INT 0
55101: PPUSH
// if not chassis or not engine then
55102: LD_VAR 0 1
55106: NOT
55107: PUSH
55108: LD_VAR 0 2
55112: NOT
55113: OR
55114: IFFALSE 55118
// exit ;
55116: GO 55314
// case engine of engine_solar :
55118: LD_VAR 0 2
55122: PUSH
55123: LD_INT 2
55125: DOUBLE
55126: EQUAL
55127: IFTRUE 55131
55129: GO 55169
55131: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55132: LD_ADDR_VAR 0 3
55136: PUSH
55137: LD_INT 11
55139: PUSH
55140: LD_INT 12
55142: PUSH
55143: LD_INT 13
55145: PUSH
55146: LD_INT 14
55148: PUSH
55149: LD_INT 1
55151: PUSH
55152: LD_INT 2
55154: PUSH
55155: LD_INT 3
55157: PUSH
55158: EMPTY
55159: LIST
55160: LIST
55161: LIST
55162: LIST
55163: LIST
55164: LIST
55165: LIST
55166: ST_TO_ADDR
55167: GO 55298
55169: LD_INT 1
55171: DOUBLE
55172: EQUAL
55173: IFTRUE 55177
55175: GO 55239
55177: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55178: LD_ADDR_VAR 0 3
55182: PUSH
55183: LD_INT 11
55185: PUSH
55186: LD_INT 12
55188: PUSH
55189: LD_INT 13
55191: PUSH
55192: LD_INT 14
55194: PUSH
55195: LD_INT 1
55197: PUSH
55198: LD_INT 2
55200: PUSH
55201: LD_INT 3
55203: PUSH
55204: LD_INT 4
55206: PUSH
55207: LD_INT 5
55209: PUSH
55210: LD_INT 21
55212: PUSH
55213: LD_INT 23
55215: PUSH
55216: LD_INT 22
55218: PUSH
55219: LD_INT 24
55221: PUSH
55222: EMPTY
55223: LIST
55224: LIST
55225: LIST
55226: LIST
55227: LIST
55228: LIST
55229: LIST
55230: LIST
55231: LIST
55232: LIST
55233: LIST
55234: LIST
55235: LIST
55236: ST_TO_ADDR
55237: GO 55298
55239: LD_INT 3
55241: DOUBLE
55242: EQUAL
55243: IFTRUE 55247
55245: GO 55297
55247: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55248: LD_ADDR_VAR 0 3
55252: PUSH
55253: LD_INT 13
55255: PUSH
55256: LD_INT 14
55258: PUSH
55259: LD_INT 2
55261: PUSH
55262: LD_INT 3
55264: PUSH
55265: LD_INT 4
55267: PUSH
55268: LD_INT 5
55270: PUSH
55271: LD_INT 21
55273: PUSH
55274: LD_INT 22
55276: PUSH
55277: LD_INT 23
55279: PUSH
55280: LD_INT 24
55282: PUSH
55283: EMPTY
55284: LIST
55285: LIST
55286: LIST
55287: LIST
55288: LIST
55289: LIST
55290: LIST
55291: LIST
55292: LIST
55293: LIST
55294: ST_TO_ADDR
55295: GO 55298
55297: POP
// result := ( chassis in result ) ;
55298: LD_ADDR_VAR 0 3
55302: PUSH
55303: LD_VAR 0 1
55307: PUSH
55308: LD_VAR 0 3
55312: IN
55313: ST_TO_ADDR
// end ;
55314: LD_VAR 0 3
55318: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55319: LD_INT 0
55321: PPUSH
// if not chassis or not weapon then
55322: LD_VAR 0 1
55326: NOT
55327: PUSH
55328: LD_VAR 0 2
55332: NOT
55333: OR
55334: IFFALSE 55338
// exit ;
55336: GO 56398
// case weapon of us_machine_gun :
55338: LD_VAR 0 2
55342: PUSH
55343: LD_INT 2
55345: DOUBLE
55346: EQUAL
55347: IFTRUE 55351
55349: GO 55381
55351: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55352: LD_ADDR_VAR 0 3
55356: PUSH
55357: LD_INT 1
55359: PUSH
55360: LD_INT 2
55362: PUSH
55363: LD_INT 3
55365: PUSH
55366: LD_INT 4
55368: PUSH
55369: LD_INT 5
55371: PUSH
55372: EMPTY
55373: LIST
55374: LIST
55375: LIST
55376: LIST
55377: LIST
55378: ST_TO_ADDR
55379: GO 56382
55381: LD_INT 3
55383: DOUBLE
55384: EQUAL
55385: IFTRUE 55389
55387: GO 55419
55389: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55390: LD_ADDR_VAR 0 3
55394: PUSH
55395: LD_INT 1
55397: PUSH
55398: LD_INT 2
55400: PUSH
55401: LD_INT 3
55403: PUSH
55404: LD_INT 4
55406: PUSH
55407: LD_INT 5
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: LIST
55414: LIST
55415: LIST
55416: ST_TO_ADDR
55417: GO 56382
55419: LD_INT 11
55421: DOUBLE
55422: EQUAL
55423: IFTRUE 55427
55425: GO 55457
55427: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55428: LD_ADDR_VAR 0 3
55432: PUSH
55433: LD_INT 1
55435: PUSH
55436: LD_INT 2
55438: PUSH
55439: LD_INT 3
55441: PUSH
55442: LD_INT 4
55444: PUSH
55445: LD_INT 5
55447: PUSH
55448: EMPTY
55449: LIST
55450: LIST
55451: LIST
55452: LIST
55453: LIST
55454: ST_TO_ADDR
55455: GO 56382
55457: LD_INT 4
55459: DOUBLE
55460: EQUAL
55461: IFTRUE 55465
55463: GO 55491
55465: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55466: LD_ADDR_VAR 0 3
55470: PUSH
55471: LD_INT 2
55473: PUSH
55474: LD_INT 3
55476: PUSH
55477: LD_INT 4
55479: PUSH
55480: LD_INT 5
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: LIST
55487: LIST
55488: ST_TO_ADDR
55489: GO 56382
55491: LD_INT 5
55493: DOUBLE
55494: EQUAL
55495: IFTRUE 55499
55497: GO 55525
55499: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55500: LD_ADDR_VAR 0 3
55504: PUSH
55505: LD_INT 2
55507: PUSH
55508: LD_INT 3
55510: PUSH
55511: LD_INT 4
55513: PUSH
55514: LD_INT 5
55516: PUSH
55517: EMPTY
55518: LIST
55519: LIST
55520: LIST
55521: LIST
55522: ST_TO_ADDR
55523: GO 56382
55525: LD_INT 9
55527: DOUBLE
55528: EQUAL
55529: IFTRUE 55533
55531: GO 55559
55533: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55534: LD_ADDR_VAR 0 3
55538: PUSH
55539: LD_INT 2
55541: PUSH
55542: LD_INT 3
55544: PUSH
55545: LD_INT 4
55547: PUSH
55548: LD_INT 5
55550: PUSH
55551: EMPTY
55552: LIST
55553: LIST
55554: LIST
55555: LIST
55556: ST_TO_ADDR
55557: GO 56382
55559: LD_INT 7
55561: DOUBLE
55562: EQUAL
55563: IFTRUE 55567
55565: GO 55593
55567: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55568: LD_ADDR_VAR 0 3
55572: PUSH
55573: LD_INT 2
55575: PUSH
55576: LD_INT 3
55578: PUSH
55579: LD_INT 4
55581: PUSH
55582: LD_INT 5
55584: PUSH
55585: EMPTY
55586: LIST
55587: LIST
55588: LIST
55589: LIST
55590: ST_TO_ADDR
55591: GO 56382
55593: LD_INT 12
55595: DOUBLE
55596: EQUAL
55597: IFTRUE 55601
55599: GO 55627
55601: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55602: LD_ADDR_VAR 0 3
55606: PUSH
55607: LD_INT 2
55609: PUSH
55610: LD_INT 3
55612: PUSH
55613: LD_INT 4
55615: PUSH
55616: LD_INT 5
55618: PUSH
55619: EMPTY
55620: LIST
55621: LIST
55622: LIST
55623: LIST
55624: ST_TO_ADDR
55625: GO 56382
55627: LD_INT 13
55629: DOUBLE
55630: EQUAL
55631: IFTRUE 55635
55633: GO 55661
55635: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55636: LD_ADDR_VAR 0 3
55640: PUSH
55641: LD_INT 2
55643: PUSH
55644: LD_INT 3
55646: PUSH
55647: LD_INT 4
55649: PUSH
55650: LD_INT 5
55652: PUSH
55653: EMPTY
55654: LIST
55655: LIST
55656: LIST
55657: LIST
55658: ST_TO_ADDR
55659: GO 56382
55661: LD_INT 14
55663: DOUBLE
55664: EQUAL
55665: IFTRUE 55669
55667: GO 55687
55669: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55670: LD_ADDR_VAR 0 3
55674: PUSH
55675: LD_INT 4
55677: PUSH
55678: LD_INT 5
55680: PUSH
55681: EMPTY
55682: LIST
55683: LIST
55684: ST_TO_ADDR
55685: GO 56382
55687: LD_INT 6
55689: DOUBLE
55690: EQUAL
55691: IFTRUE 55695
55693: GO 55713
55695: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55696: LD_ADDR_VAR 0 3
55700: PUSH
55701: LD_INT 4
55703: PUSH
55704: LD_INT 5
55706: PUSH
55707: EMPTY
55708: LIST
55709: LIST
55710: ST_TO_ADDR
55711: GO 56382
55713: LD_INT 10
55715: DOUBLE
55716: EQUAL
55717: IFTRUE 55721
55719: GO 55739
55721: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55722: LD_ADDR_VAR 0 3
55726: PUSH
55727: LD_INT 4
55729: PUSH
55730: LD_INT 5
55732: PUSH
55733: EMPTY
55734: LIST
55735: LIST
55736: ST_TO_ADDR
55737: GO 56382
55739: LD_INT 22
55741: DOUBLE
55742: EQUAL
55743: IFTRUE 55747
55745: GO 55773
55747: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55748: LD_ADDR_VAR 0 3
55752: PUSH
55753: LD_INT 11
55755: PUSH
55756: LD_INT 12
55758: PUSH
55759: LD_INT 13
55761: PUSH
55762: LD_INT 14
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: LIST
55769: LIST
55770: ST_TO_ADDR
55771: GO 56382
55773: LD_INT 23
55775: DOUBLE
55776: EQUAL
55777: IFTRUE 55781
55779: GO 55807
55781: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55782: LD_ADDR_VAR 0 3
55786: PUSH
55787: LD_INT 11
55789: PUSH
55790: LD_INT 12
55792: PUSH
55793: LD_INT 13
55795: PUSH
55796: LD_INT 14
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: LIST
55803: LIST
55804: ST_TO_ADDR
55805: GO 56382
55807: LD_INT 24
55809: DOUBLE
55810: EQUAL
55811: IFTRUE 55815
55813: GO 55841
55815: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55816: LD_ADDR_VAR 0 3
55820: PUSH
55821: LD_INT 11
55823: PUSH
55824: LD_INT 12
55826: PUSH
55827: LD_INT 13
55829: PUSH
55830: LD_INT 14
55832: PUSH
55833: EMPTY
55834: LIST
55835: LIST
55836: LIST
55837: LIST
55838: ST_TO_ADDR
55839: GO 56382
55841: LD_INT 30
55843: DOUBLE
55844: EQUAL
55845: IFTRUE 55849
55847: GO 55875
55849: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55850: LD_ADDR_VAR 0 3
55854: PUSH
55855: LD_INT 11
55857: PUSH
55858: LD_INT 12
55860: PUSH
55861: LD_INT 13
55863: PUSH
55864: LD_INT 14
55866: PUSH
55867: EMPTY
55868: LIST
55869: LIST
55870: LIST
55871: LIST
55872: ST_TO_ADDR
55873: GO 56382
55875: LD_INT 25
55877: DOUBLE
55878: EQUAL
55879: IFTRUE 55883
55881: GO 55901
55883: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55884: LD_ADDR_VAR 0 3
55888: PUSH
55889: LD_INT 13
55891: PUSH
55892: LD_INT 14
55894: PUSH
55895: EMPTY
55896: LIST
55897: LIST
55898: ST_TO_ADDR
55899: GO 56382
55901: LD_INT 27
55903: DOUBLE
55904: EQUAL
55905: IFTRUE 55909
55907: GO 55927
55909: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55910: LD_ADDR_VAR 0 3
55914: PUSH
55915: LD_INT 13
55917: PUSH
55918: LD_INT 14
55920: PUSH
55921: EMPTY
55922: LIST
55923: LIST
55924: ST_TO_ADDR
55925: GO 56382
55927: LD_INT 92
55929: DOUBLE
55930: EQUAL
55931: IFTRUE 55935
55933: GO 55961
55935: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55936: LD_ADDR_VAR 0 3
55940: PUSH
55941: LD_INT 11
55943: PUSH
55944: LD_INT 12
55946: PUSH
55947: LD_INT 13
55949: PUSH
55950: LD_INT 14
55952: PUSH
55953: EMPTY
55954: LIST
55955: LIST
55956: LIST
55957: LIST
55958: ST_TO_ADDR
55959: GO 56382
55961: LD_INT 28
55963: DOUBLE
55964: EQUAL
55965: IFTRUE 55969
55967: GO 55987
55969: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55970: LD_ADDR_VAR 0 3
55974: PUSH
55975: LD_INT 13
55977: PUSH
55978: LD_INT 14
55980: PUSH
55981: EMPTY
55982: LIST
55983: LIST
55984: ST_TO_ADDR
55985: GO 56382
55987: LD_INT 29
55989: DOUBLE
55990: EQUAL
55991: IFTRUE 55995
55993: GO 56013
55995: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55996: LD_ADDR_VAR 0 3
56000: PUSH
56001: LD_INT 13
56003: PUSH
56004: LD_INT 14
56006: PUSH
56007: EMPTY
56008: LIST
56009: LIST
56010: ST_TO_ADDR
56011: GO 56382
56013: LD_INT 31
56015: DOUBLE
56016: EQUAL
56017: IFTRUE 56021
56019: GO 56039
56021: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56022: LD_ADDR_VAR 0 3
56026: PUSH
56027: LD_INT 13
56029: PUSH
56030: LD_INT 14
56032: PUSH
56033: EMPTY
56034: LIST
56035: LIST
56036: ST_TO_ADDR
56037: GO 56382
56039: LD_INT 26
56041: DOUBLE
56042: EQUAL
56043: IFTRUE 56047
56045: GO 56065
56047: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56048: LD_ADDR_VAR 0 3
56052: PUSH
56053: LD_INT 13
56055: PUSH
56056: LD_INT 14
56058: PUSH
56059: EMPTY
56060: LIST
56061: LIST
56062: ST_TO_ADDR
56063: GO 56382
56065: LD_INT 42
56067: DOUBLE
56068: EQUAL
56069: IFTRUE 56073
56071: GO 56099
56073: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56074: LD_ADDR_VAR 0 3
56078: PUSH
56079: LD_INT 21
56081: PUSH
56082: LD_INT 22
56084: PUSH
56085: LD_INT 23
56087: PUSH
56088: LD_INT 24
56090: PUSH
56091: EMPTY
56092: LIST
56093: LIST
56094: LIST
56095: LIST
56096: ST_TO_ADDR
56097: GO 56382
56099: LD_INT 43
56101: DOUBLE
56102: EQUAL
56103: IFTRUE 56107
56105: GO 56133
56107: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56108: LD_ADDR_VAR 0 3
56112: PUSH
56113: LD_INT 21
56115: PUSH
56116: LD_INT 22
56118: PUSH
56119: LD_INT 23
56121: PUSH
56122: LD_INT 24
56124: PUSH
56125: EMPTY
56126: LIST
56127: LIST
56128: LIST
56129: LIST
56130: ST_TO_ADDR
56131: GO 56382
56133: LD_INT 44
56135: DOUBLE
56136: EQUAL
56137: IFTRUE 56141
56139: GO 56167
56141: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56142: LD_ADDR_VAR 0 3
56146: PUSH
56147: LD_INT 21
56149: PUSH
56150: LD_INT 22
56152: PUSH
56153: LD_INT 23
56155: PUSH
56156: LD_INT 24
56158: PUSH
56159: EMPTY
56160: LIST
56161: LIST
56162: LIST
56163: LIST
56164: ST_TO_ADDR
56165: GO 56382
56167: LD_INT 45
56169: DOUBLE
56170: EQUAL
56171: IFTRUE 56175
56173: GO 56201
56175: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56176: LD_ADDR_VAR 0 3
56180: PUSH
56181: LD_INT 21
56183: PUSH
56184: LD_INT 22
56186: PUSH
56187: LD_INT 23
56189: PUSH
56190: LD_INT 24
56192: PUSH
56193: EMPTY
56194: LIST
56195: LIST
56196: LIST
56197: LIST
56198: ST_TO_ADDR
56199: GO 56382
56201: LD_INT 49
56203: DOUBLE
56204: EQUAL
56205: IFTRUE 56209
56207: GO 56235
56209: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56210: LD_ADDR_VAR 0 3
56214: PUSH
56215: LD_INT 21
56217: PUSH
56218: LD_INT 22
56220: PUSH
56221: LD_INT 23
56223: PUSH
56224: LD_INT 24
56226: PUSH
56227: EMPTY
56228: LIST
56229: LIST
56230: LIST
56231: LIST
56232: ST_TO_ADDR
56233: GO 56382
56235: LD_INT 51
56237: DOUBLE
56238: EQUAL
56239: IFTRUE 56243
56241: GO 56269
56243: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56244: LD_ADDR_VAR 0 3
56248: PUSH
56249: LD_INT 21
56251: PUSH
56252: LD_INT 22
56254: PUSH
56255: LD_INT 23
56257: PUSH
56258: LD_INT 24
56260: PUSH
56261: EMPTY
56262: LIST
56263: LIST
56264: LIST
56265: LIST
56266: ST_TO_ADDR
56267: GO 56382
56269: LD_INT 52
56271: DOUBLE
56272: EQUAL
56273: IFTRUE 56277
56275: GO 56303
56277: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56278: LD_ADDR_VAR 0 3
56282: PUSH
56283: LD_INT 21
56285: PUSH
56286: LD_INT 22
56288: PUSH
56289: LD_INT 23
56291: PUSH
56292: LD_INT 24
56294: PUSH
56295: EMPTY
56296: LIST
56297: LIST
56298: LIST
56299: LIST
56300: ST_TO_ADDR
56301: GO 56382
56303: LD_INT 53
56305: DOUBLE
56306: EQUAL
56307: IFTRUE 56311
56309: GO 56329
56311: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56312: LD_ADDR_VAR 0 3
56316: PUSH
56317: LD_INT 23
56319: PUSH
56320: LD_INT 24
56322: PUSH
56323: EMPTY
56324: LIST
56325: LIST
56326: ST_TO_ADDR
56327: GO 56382
56329: LD_INT 46
56331: DOUBLE
56332: EQUAL
56333: IFTRUE 56337
56335: GO 56355
56337: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56338: LD_ADDR_VAR 0 3
56342: PUSH
56343: LD_INT 23
56345: PUSH
56346: LD_INT 24
56348: PUSH
56349: EMPTY
56350: LIST
56351: LIST
56352: ST_TO_ADDR
56353: GO 56382
56355: LD_INT 47
56357: DOUBLE
56358: EQUAL
56359: IFTRUE 56363
56361: GO 56381
56363: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56364: LD_ADDR_VAR 0 3
56368: PUSH
56369: LD_INT 23
56371: PUSH
56372: LD_INT 24
56374: PUSH
56375: EMPTY
56376: LIST
56377: LIST
56378: ST_TO_ADDR
56379: GO 56382
56381: POP
// result := ( chassis in result ) ;
56382: LD_ADDR_VAR 0 3
56386: PUSH
56387: LD_VAR 0 1
56391: PUSH
56392: LD_VAR 0 3
56396: IN
56397: ST_TO_ADDR
// end ;
56398: LD_VAR 0 3
56402: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56403: LD_INT 0
56405: PPUSH
56406: PPUSH
56407: PPUSH
56408: PPUSH
56409: PPUSH
56410: PPUSH
56411: PPUSH
// result := array ;
56412: LD_ADDR_VAR 0 5
56416: PUSH
56417: LD_VAR 0 1
56421: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56422: LD_VAR 0 1
56426: NOT
56427: PUSH
56428: LD_VAR 0 2
56432: NOT
56433: OR
56434: PUSH
56435: LD_VAR 0 3
56439: NOT
56440: OR
56441: PUSH
56442: LD_VAR 0 2
56446: PUSH
56447: LD_VAR 0 1
56451: GREATER
56452: OR
56453: PUSH
56454: LD_VAR 0 3
56458: PUSH
56459: LD_VAR 0 1
56463: GREATER
56464: OR
56465: IFFALSE 56469
// exit ;
56467: GO 56765
// if direction then
56469: LD_VAR 0 4
56473: IFFALSE 56537
// begin d := 1 ;
56475: LD_ADDR_VAR 0 9
56479: PUSH
56480: LD_INT 1
56482: ST_TO_ADDR
// if i_from > i_to then
56483: LD_VAR 0 2
56487: PUSH
56488: LD_VAR 0 3
56492: GREATER
56493: IFFALSE 56519
// length := ( array - i_from ) + i_to else
56495: LD_ADDR_VAR 0 11
56499: PUSH
56500: LD_VAR 0 1
56504: PUSH
56505: LD_VAR 0 2
56509: MINUS
56510: PUSH
56511: LD_VAR 0 3
56515: PLUS
56516: ST_TO_ADDR
56517: GO 56535
// length := i_to - i_from ;
56519: LD_ADDR_VAR 0 11
56523: PUSH
56524: LD_VAR 0 3
56528: PUSH
56529: LD_VAR 0 2
56533: MINUS
56534: ST_TO_ADDR
// end else
56535: GO 56598
// begin d := - 1 ;
56537: LD_ADDR_VAR 0 9
56541: PUSH
56542: LD_INT 1
56544: NEG
56545: ST_TO_ADDR
// if i_from > i_to then
56546: LD_VAR 0 2
56550: PUSH
56551: LD_VAR 0 3
56555: GREATER
56556: IFFALSE 56576
// length := i_from - i_to else
56558: LD_ADDR_VAR 0 11
56562: PUSH
56563: LD_VAR 0 2
56567: PUSH
56568: LD_VAR 0 3
56572: MINUS
56573: ST_TO_ADDR
56574: GO 56598
// length := ( array - i_to ) + i_from ;
56576: LD_ADDR_VAR 0 11
56580: PUSH
56581: LD_VAR 0 1
56585: PUSH
56586: LD_VAR 0 3
56590: MINUS
56591: PUSH
56592: LD_VAR 0 2
56596: PLUS
56597: ST_TO_ADDR
// end ; if not length then
56598: LD_VAR 0 11
56602: NOT
56603: IFFALSE 56607
// exit ;
56605: GO 56765
// tmp := array ;
56607: LD_ADDR_VAR 0 10
56611: PUSH
56612: LD_VAR 0 1
56616: ST_TO_ADDR
// for i = 1 to length do
56617: LD_ADDR_VAR 0 6
56621: PUSH
56622: DOUBLE
56623: LD_INT 1
56625: DEC
56626: ST_TO_ADDR
56627: LD_VAR 0 11
56631: PUSH
56632: FOR_TO
56633: IFFALSE 56753
// begin for j = 1 to array do
56635: LD_ADDR_VAR 0 7
56639: PUSH
56640: DOUBLE
56641: LD_INT 1
56643: DEC
56644: ST_TO_ADDR
56645: LD_VAR 0 1
56649: PUSH
56650: FOR_TO
56651: IFFALSE 56739
// begin k := j + d ;
56653: LD_ADDR_VAR 0 8
56657: PUSH
56658: LD_VAR 0 7
56662: PUSH
56663: LD_VAR 0 9
56667: PLUS
56668: ST_TO_ADDR
// if k > array then
56669: LD_VAR 0 8
56673: PUSH
56674: LD_VAR 0 1
56678: GREATER
56679: IFFALSE 56689
// k := 1 ;
56681: LD_ADDR_VAR 0 8
56685: PUSH
56686: LD_INT 1
56688: ST_TO_ADDR
// if not k then
56689: LD_VAR 0 8
56693: NOT
56694: IFFALSE 56706
// k := array ;
56696: LD_ADDR_VAR 0 8
56700: PUSH
56701: LD_VAR 0 1
56705: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56706: LD_ADDR_VAR 0 10
56710: PUSH
56711: LD_VAR 0 10
56715: PPUSH
56716: LD_VAR 0 8
56720: PPUSH
56721: LD_VAR 0 1
56725: PUSH
56726: LD_VAR 0 7
56730: ARRAY
56731: PPUSH
56732: CALL_OW 1
56736: ST_TO_ADDR
// end ;
56737: GO 56650
56739: POP
56740: POP
// array := tmp ;
56741: LD_ADDR_VAR 0 1
56745: PUSH
56746: LD_VAR 0 10
56750: ST_TO_ADDR
// end ;
56751: GO 56632
56753: POP
56754: POP
// result := array ;
56755: LD_ADDR_VAR 0 5
56759: PUSH
56760: LD_VAR 0 1
56764: ST_TO_ADDR
// end ;
56765: LD_VAR 0 5
56769: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56770: LD_INT 0
56772: PPUSH
56773: PPUSH
// result := 0 ;
56774: LD_ADDR_VAR 0 3
56778: PUSH
56779: LD_INT 0
56781: ST_TO_ADDR
// if not array or not value in array then
56782: LD_VAR 0 1
56786: NOT
56787: PUSH
56788: LD_VAR 0 2
56792: PUSH
56793: LD_VAR 0 1
56797: IN
56798: NOT
56799: OR
56800: IFFALSE 56804
// exit ;
56802: GO 56858
// for i = 1 to array do
56804: LD_ADDR_VAR 0 4
56808: PUSH
56809: DOUBLE
56810: LD_INT 1
56812: DEC
56813: ST_TO_ADDR
56814: LD_VAR 0 1
56818: PUSH
56819: FOR_TO
56820: IFFALSE 56856
// if value = array [ i ] then
56822: LD_VAR 0 2
56826: PUSH
56827: LD_VAR 0 1
56831: PUSH
56832: LD_VAR 0 4
56836: ARRAY
56837: EQUAL
56838: IFFALSE 56854
// begin result := i ;
56840: LD_ADDR_VAR 0 3
56844: PUSH
56845: LD_VAR 0 4
56849: ST_TO_ADDR
// exit ;
56850: POP
56851: POP
56852: GO 56858
// end ;
56854: GO 56819
56856: POP
56857: POP
// end ;
56858: LD_VAR 0 3
56862: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56863: LD_INT 0
56865: PPUSH
// vc_chassis := chassis ;
56866: LD_ADDR_OWVAR 37
56870: PUSH
56871: LD_VAR 0 1
56875: ST_TO_ADDR
// vc_engine := engine ;
56876: LD_ADDR_OWVAR 39
56880: PUSH
56881: LD_VAR 0 2
56885: ST_TO_ADDR
// vc_control := control ;
56886: LD_ADDR_OWVAR 38
56890: PUSH
56891: LD_VAR 0 3
56895: ST_TO_ADDR
// vc_weapon := weapon ;
56896: LD_ADDR_OWVAR 40
56900: PUSH
56901: LD_VAR 0 4
56905: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56906: LD_ADDR_OWVAR 41
56910: PUSH
56911: LD_VAR 0 5
56915: ST_TO_ADDR
// end ;
56916: LD_VAR 0 6
56920: RET
// export function WantPlant ( unit ) ; var task ; begin
56921: LD_INT 0
56923: PPUSH
56924: PPUSH
// result := false ;
56925: LD_ADDR_VAR 0 2
56929: PUSH
56930: LD_INT 0
56932: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56933: LD_ADDR_VAR 0 3
56937: PUSH
56938: LD_VAR 0 1
56942: PPUSH
56943: CALL_OW 437
56947: ST_TO_ADDR
// if task then
56948: LD_VAR 0 3
56952: IFFALSE 56980
// if task [ 1 ] [ 1 ] = p then
56954: LD_VAR 0 3
56958: PUSH
56959: LD_INT 1
56961: ARRAY
56962: PUSH
56963: LD_INT 1
56965: ARRAY
56966: PUSH
56967: LD_STRING p
56969: EQUAL
56970: IFFALSE 56980
// result := true ;
56972: LD_ADDR_VAR 0 2
56976: PUSH
56977: LD_INT 1
56979: ST_TO_ADDR
// end ;
56980: LD_VAR 0 2
56984: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56985: LD_INT 0
56987: PPUSH
56988: PPUSH
56989: PPUSH
56990: PPUSH
// if pos < 1 then
56991: LD_VAR 0 2
56995: PUSH
56996: LD_INT 1
56998: LESS
56999: IFFALSE 57003
// exit ;
57001: GO 57306
// if pos = 1 then
57003: LD_VAR 0 2
57007: PUSH
57008: LD_INT 1
57010: EQUAL
57011: IFFALSE 57044
// result := Replace ( arr , pos [ 1 ] , value ) else
57013: LD_ADDR_VAR 0 4
57017: PUSH
57018: LD_VAR 0 1
57022: PPUSH
57023: LD_VAR 0 2
57027: PUSH
57028: LD_INT 1
57030: ARRAY
57031: PPUSH
57032: LD_VAR 0 3
57036: PPUSH
57037: CALL_OW 1
57041: ST_TO_ADDR
57042: GO 57306
// begin tmp := arr ;
57044: LD_ADDR_VAR 0 6
57048: PUSH
57049: LD_VAR 0 1
57053: ST_TO_ADDR
// s_arr := [ tmp ] ;
57054: LD_ADDR_VAR 0 7
57058: PUSH
57059: LD_VAR 0 6
57063: PUSH
57064: EMPTY
57065: LIST
57066: ST_TO_ADDR
// for i = 1 to pos - 1 do
57067: LD_ADDR_VAR 0 5
57071: PUSH
57072: DOUBLE
57073: LD_INT 1
57075: DEC
57076: ST_TO_ADDR
57077: LD_VAR 0 2
57081: PUSH
57082: LD_INT 1
57084: MINUS
57085: PUSH
57086: FOR_TO
57087: IFFALSE 57132
// begin tmp := tmp [ pos [ i ] ] ;
57089: LD_ADDR_VAR 0 6
57093: PUSH
57094: LD_VAR 0 6
57098: PUSH
57099: LD_VAR 0 2
57103: PUSH
57104: LD_VAR 0 5
57108: ARRAY
57109: ARRAY
57110: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57111: LD_ADDR_VAR 0 7
57115: PUSH
57116: LD_VAR 0 7
57120: PUSH
57121: LD_VAR 0 6
57125: PUSH
57126: EMPTY
57127: LIST
57128: ADD
57129: ST_TO_ADDR
// end ;
57130: GO 57086
57132: POP
57133: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57134: LD_ADDR_VAR 0 6
57138: PUSH
57139: LD_VAR 0 6
57143: PPUSH
57144: LD_VAR 0 2
57148: PUSH
57149: LD_VAR 0 2
57153: ARRAY
57154: PPUSH
57155: LD_VAR 0 3
57159: PPUSH
57160: CALL_OW 1
57164: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57165: LD_ADDR_VAR 0 7
57169: PUSH
57170: LD_VAR 0 7
57174: PPUSH
57175: LD_VAR 0 7
57179: PPUSH
57180: LD_VAR 0 6
57184: PPUSH
57185: CALL_OW 1
57189: ST_TO_ADDR
// for i = s_arr downto 2 do
57190: LD_ADDR_VAR 0 5
57194: PUSH
57195: DOUBLE
57196: LD_VAR 0 7
57200: INC
57201: ST_TO_ADDR
57202: LD_INT 2
57204: PUSH
57205: FOR_DOWNTO
57206: IFFALSE 57290
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57208: LD_ADDR_VAR 0 6
57212: PUSH
57213: LD_VAR 0 7
57217: PUSH
57218: LD_VAR 0 5
57222: PUSH
57223: LD_INT 1
57225: MINUS
57226: ARRAY
57227: PPUSH
57228: LD_VAR 0 2
57232: PUSH
57233: LD_VAR 0 5
57237: PUSH
57238: LD_INT 1
57240: MINUS
57241: ARRAY
57242: PPUSH
57243: LD_VAR 0 7
57247: PUSH
57248: LD_VAR 0 5
57252: ARRAY
57253: PPUSH
57254: CALL_OW 1
57258: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57259: LD_ADDR_VAR 0 7
57263: PUSH
57264: LD_VAR 0 7
57268: PPUSH
57269: LD_VAR 0 5
57273: PUSH
57274: LD_INT 1
57276: MINUS
57277: PPUSH
57278: LD_VAR 0 6
57282: PPUSH
57283: CALL_OW 1
57287: ST_TO_ADDR
// end ;
57288: GO 57205
57290: POP
57291: POP
// result := s_arr [ 1 ] ;
57292: LD_ADDR_VAR 0 4
57296: PUSH
57297: LD_VAR 0 7
57301: PUSH
57302: LD_INT 1
57304: ARRAY
57305: ST_TO_ADDR
// end ; end ;
57306: LD_VAR 0 4
57310: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57311: LD_INT 0
57313: PPUSH
57314: PPUSH
// if not list then
57315: LD_VAR 0 1
57319: NOT
57320: IFFALSE 57324
// exit ;
57322: GO 57415
// i := list [ pos1 ] ;
57324: LD_ADDR_VAR 0 5
57328: PUSH
57329: LD_VAR 0 1
57333: PUSH
57334: LD_VAR 0 2
57338: ARRAY
57339: ST_TO_ADDR
// if not i then
57340: LD_VAR 0 5
57344: NOT
57345: IFFALSE 57349
// exit ;
57347: GO 57415
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57349: LD_ADDR_VAR 0 1
57353: PUSH
57354: LD_VAR 0 1
57358: PPUSH
57359: LD_VAR 0 2
57363: PPUSH
57364: LD_VAR 0 1
57368: PUSH
57369: LD_VAR 0 3
57373: ARRAY
57374: PPUSH
57375: CALL_OW 1
57379: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57380: LD_ADDR_VAR 0 1
57384: PUSH
57385: LD_VAR 0 1
57389: PPUSH
57390: LD_VAR 0 3
57394: PPUSH
57395: LD_VAR 0 5
57399: PPUSH
57400: CALL_OW 1
57404: ST_TO_ADDR
// result := list ;
57405: LD_ADDR_VAR 0 4
57409: PUSH
57410: LD_VAR 0 1
57414: ST_TO_ADDR
// end ;
57415: LD_VAR 0 4
57419: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57420: LD_INT 0
57422: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57423: LD_ADDR_VAR 0 5
57427: PUSH
57428: LD_VAR 0 1
57432: PPUSH
57433: CALL_OW 250
57437: PPUSH
57438: LD_VAR 0 1
57442: PPUSH
57443: CALL_OW 251
57447: PPUSH
57448: LD_VAR 0 2
57452: PPUSH
57453: LD_VAR 0 3
57457: PPUSH
57458: LD_VAR 0 4
57462: PPUSH
57463: CALL 57473 0 5
57467: ST_TO_ADDR
// end ;
57468: LD_VAR 0 5
57472: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57473: LD_INT 0
57475: PPUSH
57476: PPUSH
57477: PPUSH
57478: PPUSH
// if not list then
57479: LD_VAR 0 3
57483: NOT
57484: IFFALSE 57488
// exit ;
57486: GO 57876
// result := [ ] ;
57488: LD_ADDR_VAR 0 6
57492: PUSH
57493: EMPTY
57494: ST_TO_ADDR
// for i in list do
57495: LD_ADDR_VAR 0 7
57499: PUSH
57500: LD_VAR 0 3
57504: PUSH
57505: FOR_IN
57506: IFFALSE 57708
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57508: LD_ADDR_VAR 0 9
57512: PUSH
57513: LD_VAR 0 7
57517: PPUSH
57518: LD_VAR 0 1
57522: PPUSH
57523: LD_VAR 0 2
57527: PPUSH
57528: CALL_OW 297
57532: ST_TO_ADDR
// if not result then
57533: LD_VAR 0 6
57537: NOT
57538: IFFALSE 57564
// result := [ [ i , tmp ] ] else
57540: LD_ADDR_VAR 0 6
57544: PUSH
57545: LD_VAR 0 7
57549: PUSH
57550: LD_VAR 0 9
57554: PUSH
57555: EMPTY
57556: LIST
57557: LIST
57558: PUSH
57559: EMPTY
57560: LIST
57561: ST_TO_ADDR
57562: GO 57706
// begin if result [ result ] [ 2 ] < tmp then
57564: LD_VAR 0 6
57568: PUSH
57569: LD_VAR 0 6
57573: ARRAY
57574: PUSH
57575: LD_INT 2
57577: ARRAY
57578: PUSH
57579: LD_VAR 0 9
57583: LESS
57584: IFFALSE 57626
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57586: LD_ADDR_VAR 0 6
57590: PUSH
57591: LD_VAR 0 6
57595: PPUSH
57596: LD_VAR 0 6
57600: PUSH
57601: LD_INT 1
57603: PLUS
57604: PPUSH
57605: LD_VAR 0 7
57609: PUSH
57610: LD_VAR 0 9
57614: PUSH
57615: EMPTY
57616: LIST
57617: LIST
57618: PPUSH
57619: CALL_OW 2
57623: ST_TO_ADDR
57624: GO 57706
// for j = 1 to result do
57626: LD_ADDR_VAR 0 8
57630: PUSH
57631: DOUBLE
57632: LD_INT 1
57634: DEC
57635: ST_TO_ADDR
57636: LD_VAR 0 6
57640: PUSH
57641: FOR_TO
57642: IFFALSE 57704
// begin if tmp < result [ j ] [ 2 ] then
57644: LD_VAR 0 9
57648: PUSH
57649: LD_VAR 0 6
57653: PUSH
57654: LD_VAR 0 8
57658: ARRAY
57659: PUSH
57660: LD_INT 2
57662: ARRAY
57663: LESS
57664: IFFALSE 57702
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57666: LD_ADDR_VAR 0 6
57670: PUSH
57671: LD_VAR 0 6
57675: PPUSH
57676: LD_VAR 0 8
57680: PPUSH
57681: LD_VAR 0 7
57685: PUSH
57686: LD_VAR 0 9
57690: PUSH
57691: EMPTY
57692: LIST
57693: LIST
57694: PPUSH
57695: CALL_OW 2
57699: ST_TO_ADDR
// break ;
57700: GO 57704
// end ; end ;
57702: GO 57641
57704: POP
57705: POP
// end ; end ;
57706: GO 57505
57708: POP
57709: POP
// if result and not asc then
57710: LD_VAR 0 6
57714: PUSH
57715: LD_VAR 0 4
57719: NOT
57720: AND
57721: IFFALSE 57796
// begin tmp := result ;
57723: LD_ADDR_VAR 0 9
57727: PUSH
57728: LD_VAR 0 6
57732: ST_TO_ADDR
// for i = tmp downto 1 do
57733: LD_ADDR_VAR 0 7
57737: PUSH
57738: DOUBLE
57739: LD_VAR 0 9
57743: INC
57744: ST_TO_ADDR
57745: LD_INT 1
57747: PUSH
57748: FOR_DOWNTO
57749: IFFALSE 57794
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57751: LD_ADDR_VAR 0 6
57755: PUSH
57756: LD_VAR 0 6
57760: PPUSH
57761: LD_VAR 0 9
57765: PUSH
57766: LD_VAR 0 7
57770: MINUS
57771: PUSH
57772: LD_INT 1
57774: PLUS
57775: PPUSH
57776: LD_VAR 0 9
57780: PUSH
57781: LD_VAR 0 7
57785: ARRAY
57786: PPUSH
57787: CALL_OW 1
57791: ST_TO_ADDR
57792: GO 57748
57794: POP
57795: POP
// end ; tmp := [ ] ;
57796: LD_ADDR_VAR 0 9
57800: PUSH
57801: EMPTY
57802: ST_TO_ADDR
// if mode then
57803: LD_VAR 0 5
57807: IFFALSE 57876
// begin for i = 1 to result do
57809: LD_ADDR_VAR 0 7
57813: PUSH
57814: DOUBLE
57815: LD_INT 1
57817: DEC
57818: ST_TO_ADDR
57819: LD_VAR 0 6
57823: PUSH
57824: FOR_TO
57825: IFFALSE 57864
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57827: LD_ADDR_VAR 0 9
57831: PUSH
57832: LD_VAR 0 9
57836: PPUSH
57837: LD_VAR 0 7
57841: PPUSH
57842: LD_VAR 0 6
57846: PUSH
57847: LD_VAR 0 7
57851: ARRAY
57852: PUSH
57853: LD_INT 1
57855: ARRAY
57856: PPUSH
57857: CALL_OW 1
57861: ST_TO_ADDR
57862: GO 57824
57864: POP
57865: POP
// result := tmp ;
57866: LD_ADDR_VAR 0 6
57870: PUSH
57871: LD_VAR 0 9
57875: ST_TO_ADDR
// end ; end ;
57876: LD_VAR 0 6
57880: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57881: LD_INT 0
57883: PPUSH
57884: PPUSH
57885: PPUSH
57886: PPUSH
57887: PPUSH
57888: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57889: LD_ADDR_VAR 0 5
57893: PUSH
57894: LD_INT 0
57896: PUSH
57897: LD_INT 0
57899: PUSH
57900: LD_INT 0
57902: PUSH
57903: EMPTY
57904: PUSH
57905: EMPTY
57906: LIST
57907: LIST
57908: LIST
57909: LIST
57910: ST_TO_ADDR
// if not x or not y then
57911: LD_VAR 0 2
57915: NOT
57916: PUSH
57917: LD_VAR 0 3
57921: NOT
57922: OR
57923: IFFALSE 57927
// exit ;
57925: GO 59577
// if not range then
57927: LD_VAR 0 4
57931: NOT
57932: IFFALSE 57942
// range := 10 ;
57934: LD_ADDR_VAR 0 4
57938: PUSH
57939: LD_INT 10
57941: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57942: LD_ADDR_VAR 0 8
57946: PUSH
57947: LD_INT 81
57949: PUSH
57950: LD_VAR 0 1
57954: PUSH
57955: EMPTY
57956: LIST
57957: LIST
57958: PUSH
57959: LD_INT 92
57961: PUSH
57962: LD_VAR 0 2
57966: PUSH
57967: LD_VAR 0 3
57971: PUSH
57972: LD_VAR 0 4
57976: PUSH
57977: EMPTY
57978: LIST
57979: LIST
57980: LIST
57981: LIST
57982: PUSH
57983: LD_INT 3
57985: PUSH
57986: LD_INT 21
57988: PUSH
57989: LD_INT 3
57991: PUSH
57992: EMPTY
57993: LIST
57994: LIST
57995: PUSH
57996: EMPTY
57997: LIST
57998: LIST
57999: PUSH
58000: EMPTY
58001: LIST
58002: LIST
58003: LIST
58004: PPUSH
58005: CALL_OW 69
58009: ST_TO_ADDR
// if not tmp then
58010: LD_VAR 0 8
58014: NOT
58015: IFFALSE 58019
// exit ;
58017: GO 59577
// for i in tmp do
58019: LD_ADDR_VAR 0 6
58023: PUSH
58024: LD_VAR 0 8
58028: PUSH
58029: FOR_IN
58030: IFFALSE 59552
// begin points := [ 0 , 0 , 0 ] ;
58032: LD_ADDR_VAR 0 9
58036: PUSH
58037: LD_INT 0
58039: PUSH
58040: LD_INT 0
58042: PUSH
58043: LD_INT 0
58045: PUSH
58046: EMPTY
58047: LIST
58048: LIST
58049: LIST
58050: ST_TO_ADDR
// bpoints := 1 ;
58051: LD_ADDR_VAR 0 10
58055: PUSH
58056: LD_INT 1
58058: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58059: LD_VAR 0 6
58063: PPUSH
58064: CALL_OW 247
58068: PUSH
58069: LD_INT 1
58071: DOUBLE
58072: EQUAL
58073: IFTRUE 58077
58075: GO 58655
58077: POP
// begin if GetClass ( i ) = 1 then
58078: LD_VAR 0 6
58082: PPUSH
58083: CALL_OW 257
58087: PUSH
58088: LD_INT 1
58090: EQUAL
58091: IFFALSE 58112
// points := [ 10 , 5 , 3 ] ;
58093: LD_ADDR_VAR 0 9
58097: PUSH
58098: LD_INT 10
58100: PUSH
58101: LD_INT 5
58103: PUSH
58104: LD_INT 3
58106: PUSH
58107: EMPTY
58108: LIST
58109: LIST
58110: LIST
58111: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58112: LD_VAR 0 6
58116: PPUSH
58117: CALL_OW 257
58121: PUSH
58122: LD_INT 2
58124: PUSH
58125: LD_INT 3
58127: PUSH
58128: LD_INT 4
58130: PUSH
58131: EMPTY
58132: LIST
58133: LIST
58134: LIST
58135: IN
58136: IFFALSE 58157
// points := [ 3 , 2 , 1 ] ;
58138: LD_ADDR_VAR 0 9
58142: PUSH
58143: LD_INT 3
58145: PUSH
58146: LD_INT 2
58148: PUSH
58149: LD_INT 1
58151: PUSH
58152: EMPTY
58153: LIST
58154: LIST
58155: LIST
58156: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58157: LD_VAR 0 6
58161: PPUSH
58162: CALL_OW 257
58166: PUSH
58167: LD_INT 5
58169: EQUAL
58170: IFFALSE 58191
// points := [ 130 , 5 , 2 ] ;
58172: LD_ADDR_VAR 0 9
58176: PUSH
58177: LD_INT 130
58179: PUSH
58180: LD_INT 5
58182: PUSH
58183: LD_INT 2
58185: PUSH
58186: EMPTY
58187: LIST
58188: LIST
58189: LIST
58190: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58191: LD_VAR 0 6
58195: PPUSH
58196: CALL_OW 257
58200: PUSH
58201: LD_INT 8
58203: EQUAL
58204: IFFALSE 58225
// points := [ 35 , 35 , 30 ] ;
58206: LD_ADDR_VAR 0 9
58210: PUSH
58211: LD_INT 35
58213: PUSH
58214: LD_INT 35
58216: PUSH
58217: LD_INT 30
58219: PUSH
58220: EMPTY
58221: LIST
58222: LIST
58223: LIST
58224: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58225: LD_VAR 0 6
58229: PPUSH
58230: CALL_OW 257
58234: PUSH
58235: LD_INT 9
58237: EQUAL
58238: IFFALSE 58259
// points := [ 20 , 55 , 40 ] ;
58240: LD_ADDR_VAR 0 9
58244: PUSH
58245: LD_INT 20
58247: PUSH
58248: LD_INT 55
58250: PUSH
58251: LD_INT 40
58253: PUSH
58254: EMPTY
58255: LIST
58256: LIST
58257: LIST
58258: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58259: LD_VAR 0 6
58263: PPUSH
58264: CALL_OW 257
58268: PUSH
58269: LD_INT 12
58271: PUSH
58272: LD_INT 16
58274: PUSH
58275: EMPTY
58276: LIST
58277: LIST
58278: IN
58279: IFFALSE 58300
// points := [ 5 , 3 , 2 ] ;
58281: LD_ADDR_VAR 0 9
58285: PUSH
58286: LD_INT 5
58288: PUSH
58289: LD_INT 3
58291: PUSH
58292: LD_INT 2
58294: PUSH
58295: EMPTY
58296: LIST
58297: LIST
58298: LIST
58299: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58300: LD_VAR 0 6
58304: PPUSH
58305: CALL_OW 257
58309: PUSH
58310: LD_INT 17
58312: EQUAL
58313: IFFALSE 58334
// points := [ 100 , 50 , 75 ] ;
58315: LD_ADDR_VAR 0 9
58319: PUSH
58320: LD_INT 100
58322: PUSH
58323: LD_INT 50
58325: PUSH
58326: LD_INT 75
58328: PUSH
58329: EMPTY
58330: LIST
58331: LIST
58332: LIST
58333: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58334: LD_VAR 0 6
58338: PPUSH
58339: CALL_OW 257
58343: PUSH
58344: LD_INT 15
58346: EQUAL
58347: IFFALSE 58368
// points := [ 10 , 5 , 3 ] ;
58349: LD_ADDR_VAR 0 9
58353: PUSH
58354: LD_INT 10
58356: PUSH
58357: LD_INT 5
58359: PUSH
58360: LD_INT 3
58362: PUSH
58363: EMPTY
58364: LIST
58365: LIST
58366: LIST
58367: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58368: LD_VAR 0 6
58372: PPUSH
58373: CALL_OW 257
58377: PUSH
58378: LD_INT 14
58380: EQUAL
58381: IFFALSE 58402
// points := [ 10 , 0 , 0 ] ;
58383: LD_ADDR_VAR 0 9
58387: PUSH
58388: LD_INT 10
58390: PUSH
58391: LD_INT 0
58393: PUSH
58394: LD_INT 0
58396: PUSH
58397: EMPTY
58398: LIST
58399: LIST
58400: LIST
58401: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58402: LD_VAR 0 6
58406: PPUSH
58407: CALL_OW 257
58411: PUSH
58412: LD_INT 11
58414: EQUAL
58415: IFFALSE 58436
// points := [ 30 , 10 , 5 ] ;
58417: LD_ADDR_VAR 0 9
58421: PUSH
58422: LD_INT 30
58424: PUSH
58425: LD_INT 10
58427: PUSH
58428: LD_INT 5
58430: PUSH
58431: EMPTY
58432: LIST
58433: LIST
58434: LIST
58435: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58436: LD_VAR 0 1
58440: PPUSH
58441: LD_INT 5
58443: PPUSH
58444: CALL_OW 321
58448: PUSH
58449: LD_INT 2
58451: EQUAL
58452: IFFALSE 58469
// bpoints := bpoints * 1.8 ;
58454: LD_ADDR_VAR 0 10
58458: PUSH
58459: LD_VAR 0 10
58463: PUSH
58464: LD_REAL  1.80000000000000E+0000
58467: MUL
58468: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58469: LD_VAR 0 6
58473: PPUSH
58474: CALL_OW 257
58478: PUSH
58479: LD_INT 1
58481: PUSH
58482: LD_INT 2
58484: PUSH
58485: LD_INT 3
58487: PUSH
58488: LD_INT 4
58490: PUSH
58491: EMPTY
58492: LIST
58493: LIST
58494: LIST
58495: LIST
58496: IN
58497: PUSH
58498: LD_VAR 0 1
58502: PPUSH
58503: LD_INT 51
58505: PPUSH
58506: CALL_OW 321
58510: PUSH
58511: LD_INT 2
58513: EQUAL
58514: AND
58515: IFFALSE 58532
// bpoints := bpoints * 1.2 ;
58517: LD_ADDR_VAR 0 10
58521: PUSH
58522: LD_VAR 0 10
58526: PUSH
58527: LD_REAL  1.20000000000000E+0000
58530: MUL
58531: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58532: LD_VAR 0 6
58536: PPUSH
58537: CALL_OW 257
58541: PUSH
58542: LD_INT 5
58544: PUSH
58545: LD_INT 7
58547: PUSH
58548: LD_INT 9
58550: PUSH
58551: EMPTY
58552: LIST
58553: LIST
58554: LIST
58555: IN
58556: PUSH
58557: LD_VAR 0 1
58561: PPUSH
58562: LD_INT 52
58564: PPUSH
58565: CALL_OW 321
58569: PUSH
58570: LD_INT 2
58572: EQUAL
58573: AND
58574: IFFALSE 58591
// bpoints := bpoints * 1.5 ;
58576: LD_ADDR_VAR 0 10
58580: PUSH
58581: LD_VAR 0 10
58585: PUSH
58586: LD_REAL  1.50000000000000E+0000
58589: MUL
58590: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58591: LD_VAR 0 1
58595: PPUSH
58596: LD_INT 66
58598: PPUSH
58599: CALL_OW 321
58603: PUSH
58604: LD_INT 2
58606: EQUAL
58607: IFFALSE 58624
// bpoints := bpoints * 1.1 ;
58609: LD_ADDR_VAR 0 10
58613: PUSH
58614: LD_VAR 0 10
58618: PUSH
58619: LD_REAL  1.10000000000000E+0000
58622: MUL
58623: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58624: LD_ADDR_VAR 0 10
58628: PUSH
58629: LD_VAR 0 10
58633: PUSH
58634: LD_VAR 0 6
58638: PPUSH
58639: LD_INT 1
58641: PPUSH
58642: CALL_OW 259
58646: PUSH
58647: LD_REAL  1.15000000000000E+0000
58650: MUL
58651: MUL
58652: ST_TO_ADDR
// end ; unit_vehicle :
58653: GO 59481
58655: LD_INT 2
58657: DOUBLE
58658: EQUAL
58659: IFTRUE 58663
58661: GO 59469
58663: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58664: LD_VAR 0 6
58668: PPUSH
58669: CALL_OW 264
58673: PUSH
58674: LD_INT 2
58676: PUSH
58677: LD_INT 42
58679: PUSH
58680: LD_INT 24
58682: PUSH
58683: EMPTY
58684: LIST
58685: LIST
58686: LIST
58687: IN
58688: IFFALSE 58709
// points := [ 25 , 5 , 3 ] ;
58690: LD_ADDR_VAR 0 9
58694: PUSH
58695: LD_INT 25
58697: PUSH
58698: LD_INT 5
58700: PUSH
58701: LD_INT 3
58703: PUSH
58704: EMPTY
58705: LIST
58706: LIST
58707: LIST
58708: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58709: LD_VAR 0 6
58713: PPUSH
58714: CALL_OW 264
58718: PUSH
58719: LD_INT 4
58721: PUSH
58722: LD_INT 43
58724: PUSH
58725: LD_INT 25
58727: PUSH
58728: EMPTY
58729: LIST
58730: LIST
58731: LIST
58732: IN
58733: IFFALSE 58754
// points := [ 40 , 15 , 5 ] ;
58735: LD_ADDR_VAR 0 9
58739: PUSH
58740: LD_INT 40
58742: PUSH
58743: LD_INT 15
58745: PUSH
58746: LD_INT 5
58748: PUSH
58749: EMPTY
58750: LIST
58751: LIST
58752: LIST
58753: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58754: LD_VAR 0 6
58758: PPUSH
58759: CALL_OW 264
58763: PUSH
58764: LD_INT 3
58766: PUSH
58767: LD_INT 23
58769: PUSH
58770: EMPTY
58771: LIST
58772: LIST
58773: IN
58774: IFFALSE 58795
// points := [ 7 , 25 , 8 ] ;
58776: LD_ADDR_VAR 0 9
58780: PUSH
58781: LD_INT 7
58783: PUSH
58784: LD_INT 25
58786: PUSH
58787: LD_INT 8
58789: PUSH
58790: EMPTY
58791: LIST
58792: LIST
58793: LIST
58794: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58795: LD_VAR 0 6
58799: PPUSH
58800: CALL_OW 264
58804: PUSH
58805: LD_INT 5
58807: PUSH
58808: LD_INT 27
58810: PUSH
58811: LD_INT 44
58813: PUSH
58814: EMPTY
58815: LIST
58816: LIST
58817: LIST
58818: IN
58819: IFFALSE 58840
// points := [ 14 , 50 , 16 ] ;
58821: LD_ADDR_VAR 0 9
58825: PUSH
58826: LD_INT 14
58828: PUSH
58829: LD_INT 50
58831: PUSH
58832: LD_INT 16
58834: PUSH
58835: EMPTY
58836: LIST
58837: LIST
58838: LIST
58839: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58840: LD_VAR 0 6
58844: PPUSH
58845: CALL_OW 264
58849: PUSH
58850: LD_INT 6
58852: PUSH
58853: LD_INT 46
58855: PUSH
58856: EMPTY
58857: LIST
58858: LIST
58859: IN
58860: IFFALSE 58881
// points := [ 32 , 120 , 70 ] ;
58862: LD_ADDR_VAR 0 9
58866: PUSH
58867: LD_INT 32
58869: PUSH
58870: LD_INT 120
58872: PUSH
58873: LD_INT 70
58875: PUSH
58876: EMPTY
58877: LIST
58878: LIST
58879: LIST
58880: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58881: LD_VAR 0 6
58885: PPUSH
58886: CALL_OW 264
58890: PUSH
58891: LD_INT 7
58893: PUSH
58894: LD_INT 28
58896: PUSH
58897: LD_INT 45
58899: PUSH
58900: LD_INT 92
58902: PUSH
58903: EMPTY
58904: LIST
58905: LIST
58906: LIST
58907: LIST
58908: IN
58909: IFFALSE 58930
// points := [ 35 , 20 , 45 ] ;
58911: LD_ADDR_VAR 0 9
58915: PUSH
58916: LD_INT 35
58918: PUSH
58919: LD_INT 20
58921: PUSH
58922: LD_INT 45
58924: PUSH
58925: EMPTY
58926: LIST
58927: LIST
58928: LIST
58929: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58930: LD_VAR 0 6
58934: PPUSH
58935: CALL_OW 264
58939: PUSH
58940: LD_INT 47
58942: PUSH
58943: EMPTY
58944: LIST
58945: IN
58946: IFFALSE 58967
// points := [ 67 , 45 , 75 ] ;
58948: LD_ADDR_VAR 0 9
58952: PUSH
58953: LD_INT 67
58955: PUSH
58956: LD_INT 45
58958: PUSH
58959: LD_INT 75
58961: PUSH
58962: EMPTY
58963: LIST
58964: LIST
58965: LIST
58966: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58967: LD_VAR 0 6
58971: PPUSH
58972: CALL_OW 264
58976: PUSH
58977: LD_INT 26
58979: PUSH
58980: EMPTY
58981: LIST
58982: IN
58983: IFFALSE 59004
// points := [ 120 , 30 , 80 ] ;
58985: LD_ADDR_VAR 0 9
58989: PUSH
58990: LD_INT 120
58992: PUSH
58993: LD_INT 30
58995: PUSH
58996: LD_INT 80
58998: PUSH
58999: EMPTY
59000: LIST
59001: LIST
59002: LIST
59003: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59004: LD_VAR 0 6
59008: PPUSH
59009: CALL_OW 264
59013: PUSH
59014: LD_INT 22
59016: PUSH
59017: EMPTY
59018: LIST
59019: IN
59020: IFFALSE 59041
// points := [ 40 , 1 , 1 ] ;
59022: LD_ADDR_VAR 0 9
59026: PUSH
59027: LD_INT 40
59029: PUSH
59030: LD_INT 1
59032: PUSH
59033: LD_INT 1
59035: PUSH
59036: EMPTY
59037: LIST
59038: LIST
59039: LIST
59040: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59041: LD_VAR 0 6
59045: PPUSH
59046: CALL_OW 264
59050: PUSH
59051: LD_INT 29
59053: PUSH
59054: EMPTY
59055: LIST
59056: IN
59057: IFFALSE 59078
// points := [ 70 , 200 , 400 ] ;
59059: LD_ADDR_VAR 0 9
59063: PUSH
59064: LD_INT 70
59066: PUSH
59067: LD_INT 200
59069: PUSH
59070: LD_INT 400
59072: PUSH
59073: EMPTY
59074: LIST
59075: LIST
59076: LIST
59077: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59078: LD_VAR 0 6
59082: PPUSH
59083: CALL_OW 264
59087: PUSH
59088: LD_INT 14
59090: PUSH
59091: LD_INT 53
59093: PUSH
59094: EMPTY
59095: LIST
59096: LIST
59097: IN
59098: IFFALSE 59119
// points := [ 40 , 10 , 20 ] ;
59100: LD_ADDR_VAR 0 9
59104: PUSH
59105: LD_INT 40
59107: PUSH
59108: LD_INT 10
59110: PUSH
59111: LD_INT 20
59113: PUSH
59114: EMPTY
59115: LIST
59116: LIST
59117: LIST
59118: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59119: LD_VAR 0 6
59123: PPUSH
59124: CALL_OW 264
59128: PUSH
59129: LD_INT 9
59131: PUSH
59132: EMPTY
59133: LIST
59134: IN
59135: IFFALSE 59156
// points := [ 5 , 70 , 20 ] ;
59137: LD_ADDR_VAR 0 9
59141: PUSH
59142: LD_INT 5
59144: PUSH
59145: LD_INT 70
59147: PUSH
59148: LD_INT 20
59150: PUSH
59151: EMPTY
59152: LIST
59153: LIST
59154: LIST
59155: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59156: LD_VAR 0 6
59160: PPUSH
59161: CALL_OW 264
59165: PUSH
59166: LD_INT 10
59168: PUSH
59169: EMPTY
59170: LIST
59171: IN
59172: IFFALSE 59193
// points := [ 35 , 110 , 70 ] ;
59174: LD_ADDR_VAR 0 9
59178: PUSH
59179: LD_INT 35
59181: PUSH
59182: LD_INT 110
59184: PUSH
59185: LD_INT 70
59187: PUSH
59188: EMPTY
59189: LIST
59190: LIST
59191: LIST
59192: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59193: LD_VAR 0 6
59197: PPUSH
59198: CALL_OW 265
59202: PUSH
59203: LD_INT 25
59205: EQUAL
59206: IFFALSE 59227
// points := [ 80 , 65 , 100 ] ;
59208: LD_ADDR_VAR 0 9
59212: PUSH
59213: LD_INT 80
59215: PUSH
59216: LD_INT 65
59218: PUSH
59219: LD_INT 100
59221: PUSH
59222: EMPTY
59223: LIST
59224: LIST
59225: LIST
59226: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59227: LD_VAR 0 6
59231: PPUSH
59232: CALL_OW 263
59236: PUSH
59237: LD_INT 1
59239: EQUAL
59240: IFFALSE 59275
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59242: LD_ADDR_VAR 0 10
59246: PUSH
59247: LD_VAR 0 10
59251: PUSH
59252: LD_VAR 0 6
59256: PPUSH
59257: CALL_OW 311
59261: PPUSH
59262: LD_INT 3
59264: PPUSH
59265: CALL_OW 259
59269: PUSH
59270: LD_INT 4
59272: MUL
59273: MUL
59274: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59275: LD_VAR 0 6
59279: PPUSH
59280: CALL_OW 263
59284: PUSH
59285: LD_INT 2
59287: EQUAL
59288: IFFALSE 59339
// begin j := IsControledBy ( i ) ;
59290: LD_ADDR_VAR 0 7
59294: PUSH
59295: LD_VAR 0 6
59299: PPUSH
59300: CALL_OW 312
59304: ST_TO_ADDR
// if j then
59305: LD_VAR 0 7
59309: IFFALSE 59339
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59311: LD_ADDR_VAR 0 10
59315: PUSH
59316: LD_VAR 0 10
59320: PUSH
59321: LD_VAR 0 7
59325: PPUSH
59326: LD_INT 3
59328: PPUSH
59329: CALL_OW 259
59333: PUSH
59334: LD_INT 3
59336: MUL
59337: MUL
59338: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59339: LD_VAR 0 6
59343: PPUSH
59344: CALL_OW 264
59348: PUSH
59349: LD_INT 5
59351: PUSH
59352: LD_INT 6
59354: PUSH
59355: LD_INT 46
59357: PUSH
59358: LD_INT 44
59360: PUSH
59361: LD_INT 47
59363: PUSH
59364: LD_INT 45
59366: PUSH
59367: LD_INT 28
59369: PUSH
59370: LD_INT 7
59372: PUSH
59373: LD_INT 27
59375: PUSH
59376: LD_INT 29
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: LIST
59383: LIST
59384: LIST
59385: LIST
59386: LIST
59387: LIST
59388: LIST
59389: LIST
59390: IN
59391: PUSH
59392: LD_VAR 0 1
59396: PPUSH
59397: LD_INT 52
59399: PPUSH
59400: CALL_OW 321
59404: PUSH
59405: LD_INT 2
59407: EQUAL
59408: AND
59409: IFFALSE 59426
// bpoints := bpoints * 1.2 ;
59411: LD_ADDR_VAR 0 10
59415: PUSH
59416: LD_VAR 0 10
59420: PUSH
59421: LD_REAL  1.20000000000000E+0000
59424: MUL
59425: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59426: LD_VAR 0 6
59430: PPUSH
59431: CALL_OW 264
59435: PUSH
59436: LD_INT 6
59438: PUSH
59439: LD_INT 46
59441: PUSH
59442: LD_INT 47
59444: PUSH
59445: EMPTY
59446: LIST
59447: LIST
59448: LIST
59449: IN
59450: IFFALSE 59467
// bpoints := bpoints * 1.2 ;
59452: LD_ADDR_VAR 0 10
59456: PUSH
59457: LD_VAR 0 10
59461: PUSH
59462: LD_REAL  1.20000000000000E+0000
59465: MUL
59466: ST_TO_ADDR
// end ; unit_building :
59467: GO 59481
59469: LD_INT 3
59471: DOUBLE
59472: EQUAL
59473: IFTRUE 59477
59475: GO 59480
59477: POP
// ; end ;
59478: GO 59481
59480: POP
// for j = 1 to 3 do
59481: LD_ADDR_VAR 0 7
59485: PUSH
59486: DOUBLE
59487: LD_INT 1
59489: DEC
59490: ST_TO_ADDR
59491: LD_INT 3
59493: PUSH
59494: FOR_TO
59495: IFFALSE 59548
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59497: LD_ADDR_VAR 0 5
59501: PUSH
59502: LD_VAR 0 5
59506: PPUSH
59507: LD_VAR 0 7
59511: PPUSH
59512: LD_VAR 0 5
59516: PUSH
59517: LD_VAR 0 7
59521: ARRAY
59522: PUSH
59523: LD_VAR 0 9
59527: PUSH
59528: LD_VAR 0 7
59532: ARRAY
59533: PUSH
59534: LD_VAR 0 10
59538: MUL
59539: PLUS
59540: PPUSH
59541: CALL_OW 1
59545: ST_TO_ADDR
59546: GO 59494
59548: POP
59549: POP
// end ;
59550: GO 58029
59552: POP
59553: POP
// result := Replace ( result , 4 , tmp ) ;
59554: LD_ADDR_VAR 0 5
59558: PUSH
59559: LD_VAR 0 5
59563: PPUSH
59564: LD_INT 4
59566: PPUSH
59567: LD_VAR 0 8
59571: PPUSH
59572: CALL_OW 1
59576: ST_TO_ADDR
// end ;
59577: LD_VAR 0 5
59581: RET
// export function DangerAtRange ( unit , range ) ; begin
59582: LD_INT 0
59584: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59585: LD_ADDR_VAR 0 3
59589: PUSH
59590: LD_VAR 0 1
59594: PPUSH
59595: CALL_OW 255
59599: PPUSH
59600: LD_VAR 0 1
59604: PPUSH
59605: CALL_OW 250
59609: PPUSH
59610: LD_VAR 0 1
59614: PPUSH
59615: CALL_OW 251
59619: PPUSH
59620: LD_VAR 0 2
59624: PPUSH
59625: CALL 57881 0 4
59629: ST_TO_ADDR
// end ;
59630: LD_VAR 0 3
59634: RET
// export function DangerInArea ( side , area ) ; begin
59635: LD_INT 0
59637: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59638: LD_ADDR_VAR 0 3
59642: PUSH
59643: LD_VAR 0 2
59647: PPUSH
59648: LD_INT 81
59650: PUSH
59651: LD_VAR 0 1
59655: PUSH
59656: EMPTY
59657: LIST
59658: LIST
59659: PPUSH
59660: CALL_OW 70
59664: ST_TO_ADDR
// end ;
59665: LD_VAR 0 3
59669: RET
// export function IsExtension ( b ) ; begin
59670: LD_INT 0
59672: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59673: LD_ADDR_VAR 0 2
59677: PUSH
59678: LD_VAR 0 1
59682: PUSH
59683: LD_INT 23
59685: PUSH
59686: LD_INT 20
59688: PUSH
59689: LD_INT 22
59691: PUSH
59692: LD_INT 17
59694: PUSH
59695: LD_INT 24
59697: PUSH
59698: LD_INT 21
59700: PUSH
59701: LD_INT 19
59703: PUSH
59704: LD_INT 16
59706: PUSH
59707: LD_INT 25
59709: PUSH
59710: LD_INT 18
59712: PUSH
59713: EMPTY
59714: LIST
59715: LIST
59716: LIST
59717: LIST
59718: LIST
59719: LIST
59720: LIST
59721: LIST
59722: LIST
59723: LIST
59724: IN
59725: ST_TO_ADDR
// end ;
59726: LD_VAR 0 2
59730: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59731: LD_INT 0
59733: PPUSH
59734: PPUSH
59735: PPUSH
// result := [ ] ;
59736: LD_ADDR_VAR 0 4
59740: PUSH
59741: EMPTY
59742: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59743: LD_ADDR_VAR 0 5
59747: PUSH
59748: LD_VAR 0 2
59752: PPUSH
59753: LD_INT 21
59755: PUSH
59756: LD_INT 3
59758: PUSH
59759: EMPTY
59760: LIST
59761: LIST
59762: PPUSH
59763: CALL_OW 70
59767: ST_TO_ADDR
// if not tmp then
59768: LD_VAR 0 5
59772: NOT
59773: IFFALSE 59777
// exit ;
59775: GO 59841
// if checkLink then
59777: LD_VAR 0 3
59781: IFFALSE 59831
// begin for i in tmp do
59783: LD_ADDR_VAR 0 6
59787: PUSH
59788: LD_VAR 0 5
59792: PUSH
59793: FOR_IN
59794: IFFALSE 59829
// if GetBase ( i ) <> base then
59796: LD_VAR 0 6
59800: PPUSH
59801: CALL_OW 274
59805: PUSH
59806: LD_VAR 0 1
59810: NONEQUAL
59811: IFFALSE 59827
// ComLinkToBase ( base , i ) ;
59813: LD_VAR 0 1
59817: PPUSH
59818: LD_VAR 0 6
59822: PPUSH
59823: CALL_OW 169
59827: GO 59793
59829: POP
59830: POP
// end ; result := tmp ;
59831: LD_ADDR_VAR 0 4
59835: PUSH
59836: LD_VAR 0 5
59840: ST_TO_ADDR
// end ;
59841: LD_VAR 0 4
59845: RET
// export function ComComplete ( units , b ) ; var i ; begin
59846: LD_INT 0
59848: PPUSH
59849: PPUSH
// if not units then
59850: LD_VAR 0 1
59854: NOT
59855: IFFALSE 59859
// exit ;
59857: GO 59949
// for i in units do
59859: LD_ADDR_VAR 0 4
59863: PUSH
59864: LD_VAR 0 1
59868: PUSH
59869: FOR_IN
59870: IFFALSE 59947
// if BuildingStatus ( b ) = bs_build then
59872: LD_VAR 0 2
59876: PPUSH
59877: CALL_OW 461
59881: PUSH
59882: LD_INT 1
59884: EQUAL
59885: IFFALSE 59945
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59887: LD_VAR 0 4
59891: PPUSH
59892: LD_STRING h
59894: PUSH
59895: LD_VAR 0 2
59899: PPUSH
59900: CALL_OW 250
59904: PUSH
59905: LD_VAR 0 2
59909: PPUSH
59910: CALL_OW 251
59914: PUSH
59915: LD_VAR 0 2
59919: PUSH
59920: LD_INT 0
59922: PUSH
59923: LD_INT 0
59925: PUSH
59926: LD_INT 0
59928: PUSH
59929: EMPTY
59930: LIST
59931: LIST
59932: LIST
59933: LIST
59934: LIST
59935: LIST
59936: LIST
59937: PUSH
59938: EMPTY
59939: LIST
59940: PPUSH
59941: CALL_OW 446
59945: GO 59869
59947: POP
59948: POP
// end ;
59949: LD_VAR 0 3
59953: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59954: LD_INT 0
59956: PPUSH
59957: PPUSH
59958: PPUSH
59959: PPUSH
59960: PPUSH
59961: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
59962: LD_VAR 0 1
59966: NOT
59967: PUSH
59968: LD_VAR 0 1
59972: PPUSH
59973: CALL_OW 263
59977: PUSH
59978: LD_INT 2
59980: NONEQUAL
59981: OR
59982: IFFALSE 59986
// exit ;
59984: GO 60302
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59986: LD_ADDR_VAR 0 6
59990: PUSH
59991: LD_INT 22
59993: PUSH
59994: LD_VAR 0 1
59998: PPUSH
59999: CALL_OW 255
60003: PUSH
60004: EMPTY
60005: LIST
60006: LIST
60007: PUSH
60008: LD_INT 2
60010: PUSH
60011: LD_INT 30
60013: PUSH
60014: LD_INT 36
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: PUSH
60021: LD_INT 34
60023: PUSH
60024: LD_INT 31
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: PUSH
60031: EMPTY
60032: LIST
60033: LIST
60034: LIST
60035: PUSH
60036: EMPTY
60037: LIST
60038: LIST
60039: PPUSH
60040: CALL_OW 69
60044: ST_TO_ADDR
// if not tmp then
60045: LD_VAR 0 6
60049: NOT
60050: IFFALSE 60054
// exit ;
60052: GO 60302
// result := [ ] ;
60054: LD_ADDR_VAR 0 2
60058: PUSH
60059: EMPTY
60060: ST_TO_ADDR
// for i in tmp do
60061: LD_ADDR_VAR 0 3
60065: PUSH
60066: LD_VAR 0 6
60070: PUSH
60071: FOR_IN
60072: IFFALSE 60143
// begin t := UnitsInside ( i ) ;
60074: LD_ADDR_VAR 0 4
60078: PUSH
60079: LD_VAR 0 3
60083: PPUSH
60084: CALL_OW 313
60088: ST_TO_ADDR
// if t then
60089: LD_VAR 0 4
60093: IFFALSE 60141
// for j in t do
60095: LD_ADDR_VAR 0 7
60099: PUSH
60100: LD_VAR 0 4
60104: PUSH
60105: FOR_IN
60106: IFFALSE 60139
// result := Replace ( result , result + 1 , j ) ;
60108: LD_ADDR_VAR 0 2
60112: PUSH
60113: LD_VAR 0 2
60117: PPUSH
60118: LD_VAR 0 2
60122: PUSH
60123: LD_INT 1
60125: PLUS
60126: PPUSH
60127: LD_VAR 0 7
60131: PPUSH
60132: CALL_OW 1
60136: ST_TO_ADDR
60137: GO 60105
60139: POP
60140: POP
// end ;
60141: GO 60071
60143: POP
60144: POP
// if not result then
60145: LD_VAR 0 2
60149: NOT
60150: IFFALSE 60154
// exit ;
60152: GO 60302
// mech := result [ 1 ] ;
60154: LD_ADDR_VAR 0 5
60158: PUSH
60159: LD_VAR 0 2
60163: PUSH
60164: LD_INT 1
60166: ARRAY
60167: ST_TO_ADDR
// if result > 1 then
60168: LD_VAR 0 2
60172: PUSH
60173: LD_INT 1
60175: GREATER
60176: IFFALSE 60288
// begin for i = 2 to result do
60178: LD_ADDR_VAR 0 3
60182: PUSH
60183: DOUBLE
60184: LD_INT 2
60186: DEC
60187: ST_TO_ADDR
60188: LD_VAR 0 2
60192: PUSH
60193: FOR_TO
60194: IFFALSE 60286
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60196: LD_ADDR_VAR 0 4
60200: PUSH
60201: LD_VAR 0 2
60205: PUSH
60206: LD_VAR 0 3
60210: ARRAY
60211: PPUSH
60212: LD_INT 3
60214: PPUSH
60215: CALL_OW 259
60219: PUSH
60220: LD_VAR 0 2
60224: PUSH
60225: LD_VAR 0 3
60229: ARRAY
60230: PPUSH
60231: CALL_OW 432
60235: MINUS
60236: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60237: LD_VAR 0 4
60241: PUSH
60242: LD_VAR 0 5
60246: PPUSH
60247: LD_INT 3
60249: PPUSH
60250: CALL_OW 259
60254: PUSH
60255: LD_VAR 0 5
60259: PPUSH
60260: CALL_OW 432
60264: MINUS
60265: GREATEREQUAL
60266: IFFALSE 60284
// mech := result [ i ] ;
60268: LD_ADDR_VAR 0 5
60272: PUSH
60273: LD_VAR 0 2
60277: PUSH
60278: LD_VAR 0 3
60282: ARRAY
60283: ST_TO_ADDR
// end ;
60284: GO 60193
60286: POP
60287: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60288: LD_VAR 0 1
60292: PPUSH
60293: LD_VAR 0 5
60297: PPUSH
60298: CALL_OW 135
// end ;
60302: LD_VAR 0 2
60306: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60307: LD_INT 0
60309: PPUSH
60310: PPUSH
60311: PPUSH
60312: PPUSH
60313: PPUSH
60314: PPUSH
60315: PPUSH
60316: PPUSH
60317: PPUSH
60318: PPUSH
60319: PPUSH
60320: PPUSH
60321: PPUSH
// result := [ ] ;
60322: LD_ADDR_VAR 0 7
60326: PUSH
60327: EMPTY
60328: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60329: LD_VAR 0 1
60333: PPUSH
60334: CALL_OW 266
60338: PUSH
60339: LD_INT 0
60341: PUSH
60342: LD_INT 1
60344: PUSH
60345: EMPTY
60346: LIST
60347: LIST
60348: IN
60349: NOT
60350: IFFALSE 60354
// exit ;
60352: GO 61988
// if name then
60354: LD_VAR 0 3
60358: IFFALSE 60374
// SetBName ( base_dep , name ) ;
60360: LD_VAR 0 1
60364: PPUSH
60365: LD_VAR 0 3
60369: PPUSH
60370: CALL_OW 500
// base := GetBase ( base_dep ) ;
60374: LD_ADDR_VAR 0 15
60378: PUSH
60379: LD_VAR 0 1
60383: PPUSH
60384: CALL_OW 274
60388: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60389: LD_ADDR_VAR 0 16
60393: PUSH
60394: LD_VAR 0 1
60398: PPUSH
60399: CALL_OW 255
60403: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60404: LD_ADDR_VAR 0 17
60408: PUSH
60409: LD_VAR 0 1
60413: PPUSH
60414: CALL_OW 248
60418: ST_TO_ADDR
// if sources then
60419: LD_VAR 0 5
60423: IFFALSE 60470
// for i = 1 to 3 do
60425: LD_ADDR_VAR 0 8
60429: PUSH
60430: DOUBLE
60431: LD_INT 1
60433: DEC
60434: ST_TO_ADDR
60435: LD_INT 3
60437: PUSH
60438: FOR_TO
60439: IFFALSE 60468
// AddResourceType ( base , i , sources [ i ] ) ;
60441: LD_VAR 0 15
60445: PPUSH
60446: LD_VAR 0 8
60450: PPUSH
60451: LD_VAR 0 5
60455: PUSH
60456: LD_VAR 0 8
60460: ARRAY
60461: PPUSH
60462: CALL_OW 276
60466: GO 60438
60468: POP
60469: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60470: LD_ADDR_VAR 0 18
60474: PUSH
60475: LD_VAR 0 15
60479: PPUSH
60480: LD_VAR 0 2
60484: PPUSH
60485: LD_INT 1
60487: PPUSH
60488: CALL 59731 0 3
60492: ST_TO_ADDR
// InitHc ;
60493: CALL_OW 19
// InitUc ;
60497: CALL_OW 18
// uc_side := side ;
60501: LD_ADDR_OWVAR 20
60505: PUSH
60506: LD_VAR 0 16
60510: ST_TO_ADDR
// uc_nation := nation ;
60511: LD_ADDR_OWVAR 21
60515: PUSH
60516: LD_VAR 0 17
60520: ST_TO_ADDR
// if buildings then
60521: LD_VAR 0 18
60525: IFFALSE 61847
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60527: LD_ADDR_VAR 0 19
60531: PUSH
60532: LD_VAR 0 18
60536: PPUSH
60537: LD_INT 2
60539: PUSH
60540: LD_INT 30
60542: PUSH
60543: LD_INT 29
60545: PUSH
60546: EMPTY
60547: LIST
60548: LIST
60549: PUSH
60550: LD_INT 30
60552: PUSH
60553: LD_INT 30
60555: PUSH
60556: EMPTY
60557: LIST
60558: LIST
60559: PUSH
60560: EMPTY
60561: LIST
60562: LIST
60563: LIST
60564: PPUSH
60565: CALL_OW 72
60569: ST_TO_ADDR
// if tmp then
60570: LD_VAR 0 19
60574: IFFALSE 60622
// for i in tmp do
60576: LD_ADDR_VAR 0 8
60580: PUSH
60581: LD_VAR 0 19
60585: PUSH
60586: FOR_IN
60587: IFFALSE 60620
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60589: LD_VAR 0 8
60593: PPUSH
60594: CALL_OW 250
60598: PPUSH
60599: LD_VAR 0 8
60603: PPUSH
60604: CALL_OW 251
60608: PPUSH
60609: LD_VAR 0 16
60613: PPUSH
60614: CALL_OW 441
60618: GO 60586
60620: POP
60621: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60622: LD_VAR 0 18
60626: PPUSH
60627: LD_INT 2
60629: PUSH
60630: LD_INT 30
60632: PUSH
60633: LD_INT 32
60635: PUSH
60636: EMPTY
60637: LIST
60638: LIST
60639: PUSH
60640: LD_INT 30
60642: PUSH
60643: LD_INT 33
60645: PUSH
60646: EMPTY
60647: LIST
60648: LIST
60649: PUSH
60650: EMPTY
60651: LIST
60652: LIST
60653: LIST
60654: PPUSH
60655: CALL_OW 72
60659: IFFALSE 60747
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60661: LD_ADDR_VAR 0 8
60665: PUSH
60666: LD_VAR 0 18
60670: PPUSH
60671: LD_INT 2
60673: PUSH
60674: LD_INT 30
60676: PUSH
60677: LD_INT 32
60679: PUSH
60680: EMPTY
60681: LIST
60682: LIST
60683: PUSH
60684: LD_INT 30
60686: PUSH
60687: LD_INT 33
60689: PUSH
60690: EMPTY
60691: LIST
60692: LIST
60693: PUSH
60694: EMPTY
60695: LIST
60696: LIST
60697: LIST
60698: PPUSH
60699: CALL_OW 72
60703: PUSH
60704: FOR_IN
60705: IFFALSE 60745
// begin if not GetBWeapon ( i ) then
60707: LD_VAR 0 8
60711: PPUSH
60712: CALL_OW 269
60716: NOT
60717: IFFALSE 60743
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60719: LD_VAR 0 8
60723: PPUSH
60724: LD_VAR 0 8
60728: PPUSH
60729: LD_VAR 0 2
60733: PPUSH
60734: CALL 61993 0 2
60738: PPUSH
60739: CALL_OW 431
// end ;
60743: GO 60704
60745: POP
60746: POP
// end ; for i = 1 to personel do
60747: LD_ADDR_VAR 0 8
60751: PUSH
60752: DOUBLE
60753: LD_INT 1
60755: DEC
60756: ST_TO_ADDR
60757: LD_VAR 0 6
60761: PUSH
60762: FOR_TO
60763: IFFALSE 61827
// begin if i > 4 then
60765: LD_VAR 0 8
60769: PUSH
60770: LD_INT 4
60772: GREATER
60773: IFFALSE 60777
// break ;
60775: GO 61827
// case i of 1 :
60777: LD_VAR 0 8
60781: PUSH
60782: LD_INT 1
60784: DOUBLE
60785: EQUAL
60786: IFTRUE 60790
60788: GO 60870
60790: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60791: LD_ADDR_VAR 0 12
60795: PUSH
60796: LD_VAR 0 18
60800: PPUSH
60801: LD_INT 22
60803: PUSH
60804: LD_VAR 0 16
60808: PUSH
60809: EMPTY
60810: LIST
60811: LIST
60812: PUSH
60813: LD_INT 58
60815: PUSH
60816: EMPTY
60817: LIST
60818: PUSH
60819: LD_INT 2
60821: PUSH
60822: LD_INT 30
60824: PUSH
60825: LD_INT 32
60827: PUSH
60828: EMPTY
60829: LIST
60830: LIST
60831: PUSH
60832: LD_INT 30
60834: PUSH
60835: LD_INT 4
60837: PUSH
60838: EMPTY
60839: LIST
60840: LIST
60841: PUSH
60842: LD_INT 30
60844: PUSH
60845: LD_INT 5
60847: PUSH
60848: EMPTY
60849: LIST
60850: LIST
60851: PUSH
60852: EMPTY
60853: LIST
60854: LIST
60855: LIST
60856: LIST
60857: PUSH
60858: EMPTY
60859: LIST
60860: LIST
60861: LIST
60862: PPUSH
60863: CALL_OW 72
60867: ST_TO_ADDR
60868: GO 61092
60870: LD_INT 2
60872: DOUBLE
60873: EQUAL
60874: IFTRUE 60878
60876: GO 60940
60878: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60879: LD_ADDR_VAR 0 12
60883: PUSH
60884: LD_VAR 0 18
60888: PPUSH
60889: LD_INT 22
60891: PUSH
60892: LD_VAR 0 16
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: PUSH
60901: LD_INT 2
60903: PUSH
60904: LD_INT 30
60906: PUSH
60907: LD_INT 0
60909: PUSH
60910: EMPTY
60911: LIST
60912: LIST
60913: PUSH
60914: LD_INT 30
60916: PUSH
60917: LD_INT 1
60919: PUSH
60920: EMPTY
60921: LIST
60922: LIST
60923: PUSH
60924: EMPTY
60925: LIST
60926: LIST
60927: LIST
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PPUSH
60933: CALL_OW 72
60937: ST_TO_ADDR
60938: GO 61092
60940: LD_INT 3
60942: DOUBLE
60943: EQUAL
60944: IFTRUE 60948
60946: GO 61010
60948: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60949: LD_ADDR_VAR 0 12
60953: PUSH
60954: LD_VAR 0 18
60958: PPUSH
60959: LD_INT 22
60961: PUSH
60962: LD_VAR 0 16
60966: PUSH
60967: EMPTY
60968: LIST
60969: LIST
60970: PUSH
60971: LD_INT 2
60973: PUSH
60974: LD_INT 30
60976: PUSH
60977: LD_INT 2
60979: PUSH
60980: EMPTY
60981: LIST
60982: LIST
60983: PUSH
60984: LD_INT 30
60986: PUSH
60987: LD_INT 3
60989: PUSH
60990: EMPTY
60991: LIST
60992: LIST
60993: PUSH
60994: EMPTY
60995: LIST
60996: LIST
60997: LIST
60998: PUSH
60999: EMPTY
61000: LIST
61001: LIST
61002: PPUSH
61003: CALL_OW 72
61007: ST_TO_ADDR
61008: GO 61092
61010: LD_INT 4
61012: DOUBLE
61013: EQUAL
61014: IFTRUE 61018
61016: GO 61091
61018: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61019: LD_ADDR_VAR 0 12
61023: PUSH
61024: LD_VAR 0 18
61028: PPUSH
61029: LD_INT 22
61031: PUSH
61032: LD_VAR 0 16
61036: PUSH
61037: EMPTY
61038: LIST
61039: LIST
61040: PUSH
61041: LD_INT 2
61043: PUSH
61044: LD_INT 30
61046: PUSH
61047: LD_INT 6
61049: PUSH
61050: EMPTY
61051: LIST
61052: LIST
61053: PUSH
61054: LD_INT 30
61056: PUSH
61057: LD_INT 7
61059: PUSH
61060: EMPTY
61061: LIST
61062: LIST
61063: PUSH
61064: LD_INT 30
61066: PUSH
61067: LD_INT 8
61069: PUSH
61070: EMPTY
61071: LIST
61072: LIST
61073: PUSH
61074: EMPTY
61075: LIST
61076: LIST
61077: LIST
61078: LIST
61079: PUSH
61080: EMPTY
61081: LIST
61082: LIST
61083: PPUSH
61084: CALL_OW 72
61088: ST_TO_ADDR
61089: GO 61092
61091: POP
// if i = 1 then
61092: LD_VAR 0 8
61096: PUSH
61097: LD_INT 1
61099: EQUAL
61100: IFFALSE 61211
// begin tmp := [ ] ;
61102: LD_ADDR_VAR 0 19
61106: PUSH
61107: EMPTY
61108: ST_TO_ADDR
// for j in f do
61109: LD_ADDR_VAR 0 9
61113: PUSH
61114: LD_VAR 0 12
61118: PUSH
61119: FOR_IN
61120: IFFALSE 61193
// if GetBType ( j ) = b_bunker then
61122: LD_VAR 0 9
61126: PPUSH
61127: CALL_OW 266
61131: PUSH
61132: LD_INT 32
61134: EQUAL
61135: IFFALSE 61162
// tmp := Insert ( tmp , 1 , j ) else
61137: LD_ADDR_VAR 0 19
61141: PUSH
61142: LD_VAR 0 19
61146: PPUSH
61147: LD_INT 1
61149: PPUSH
61150: LD_VAR 0 9
61154: PPUSH
61155: CALL_OW 2
61159: ST_TO_ADDR
61160: GO 61191
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61162: LD_ADDR_VAR 0 19
61166: PUSH
61167: LD_VAR 0 19
61171: PPUSH
61172: LD_VAR 0 19
61176: PUSH
61177: LD_INT 1
61179: PLUS
61180: PPUSH
61181: LD_VAR 0 9
61185: PPUSH
61186: CALL_OW 2
61190: ST_TO_ADDR
61191: GO 61119
61193: POP
61194: POP
// if tmp then
61195: LD_VAR 0 19
61199: IFFALSE 61211
// f := tmp ;
61201: LD_ADDR_VAR 0 12
61205: PUSH
61206: LD_VAR 0 19
61210: ST_TO_ADDR
// end ; x := personel [ i ] ;
61211: LD_ADDR_VAR 0 13
61215: PUSH
61216: LD_VAR 0 6
61220: PUSH
61221: LD_VAR 0 8
61225: ARRAY
61226: ST_TO_ADDR
// if x = - 1 then
61227: LD_VAR 0 13
61231: PUSH
61232: LD_INT 1
61234: NEG
61235: EQUAL
61236: IFFALSE 61445
// begin for j in f do
61238: LD_ADDR_VAR 0 9
61242: PUSH
61243: LD_VAR 0 12
61247: PUSH
61248: FOR_IN
61249: IFFALSE 61441
// repeat InitHc ;
61251: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61255: LD_VAR 0 9
61259: PPUSH
61260: CALL_OW 266
61264: PUSH
61265: LD_INT 5
61267: EQUAL
61268: IFFALSE 61338
// begin if UnitsInside ( j ) < 3 then
61270: LD_VAR 0 9
61274: PPUSH
61275: CALL_OW 313
61279: PUSH
61280: LD_INT 3
61282: LESS
61283: IFFALSE 61319
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61285: LD_INT 0
61287: PPUSH
61288: LD_INT 5
61290: PUSH
61291: LD_INT 8
61293: PUSH
61294: LD_INT 9
61296: PUSH
61297: EMPTY
61298: LIST
61299: LIST
61300: LIST
61301: PUSH
61302: LD_VAR 0 17
61306: ARRAY
61307: PPUSH
61308: LD_VAR 0 4
61312: PPUSH
61313: CALL_OW 380
61317: GO 61336
// PrepareHuman ( false , i , skill ) ;
61319: LD_INT 0
61321: PPUSH
61322: LD_VAR 0 8
61326: PPUSH
61327: LD_VAR 0 4
61331: PPUSH
61332: CALL_OW 380
// end else
61336: GO 61355
// PrepareHuman ( false , i , skill ) ;
61338: LD_INT 0
61340: PPUSH
61341: LD_VAR 0 8
61345: PPUSH
61346: LD_VAR 0 4
61350: PPUSH
61351: CALL_OW 380
// un := CreateHuman ;
61355: LD_ADDR_VAR 0 14
61359: PUSH
61360: CALL_OW 44
61364: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61365: LD_ADDR_VAR 0 7
61369: PUSH
61370: LD_VAR 0 7
61374: PPUSH
61375: LD_INT 1
61377: PPUSH
61378: LD_VAR 0 14
61382: PPUSH
61383: CALL_OW 2
61387: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61388: LD_VAR 0 14
61392: PPUSH
61393: LD_VAR 0 9
61397: PPUSH
61398: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61402: LD_VAR 0 9
61406: PPUSH
61407: CALL_OW 313
61411: PUSH
61412: LD_INT 6
61414: EQUAL
61415: PUSH
61416: LD_VAR 0 9
61420: PPUSH
61421: CALL_OW 266
61425: PUSH
61426: LD_INT 32
61428: PUSH
61429: LD_INT 31
61431: PUSH
61432: EMPTY
61433: LIST
61434: LIST
61435: IN
61436: OR
61437: IFFALSE 61251
61439: GO 61248
61441: POP
61442: POP
// end else
61443: GO 61825
// for j = 1 to x do
61445: LD_ADDR_VAR 0 9
61449: PUSH
61450: DOUBLE
61451: LD_INT 1
61453: DEC
61454: ST_TO_ADDR
61455: LD_VAR 0 13
61459: PUSH
61460: FOR_TO
61461: IFFALSE 61823
// begin InitHc ;
61463: CALL_OW 19
// if not f then
61467: LD_VAR 0 12
61471: NOT
61472: IFFALSE 61561
// begin PrepareHuman ( false , i , skill ) ;
61474: LD_INT 0
61476: PPUSH
61477: LD_VAR 0 8
61481: PPUSH
61482: LD_VAR 0 4
61486: PPUSH
61487: CALL_OW 380
// un := CreateHuman ;
61491: LD_ADDR_VAR 0 14
61495: PUSH
61496: CALL_OW 44
61500: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61501: LD_ADDR_VAR 0 7
61505: PUSH
61506: LD_VAR 0 7
61510: PPUSH
61511: LD_INT 1
61513: PPUSH
61514: LD_VAR 0 14
61518: PPUSH
61519: CALL_OW 2
61523: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61524: LD_VAR 0 14
61528: PPUSH
61529: LD_VAR 0 1
61533: PPUSH
61534: CALL_OW 250
61538: PPUSH
61539: LD_VAR 0 1
61543: PPUSH
61544: CALL_OW 251
61548: PPUSH
61549: LD_INT 10
61551: PPUSH
61552: LD_INT 0
61554: PPUSH
61555: CALL_OW 50
// continue ;
61559: GO 61460
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61561: LD_VAR 0 12
61565: PUSH
61566: LD_INT 1
61568: ARRAY
61569: PPUSH
61570: CALL_OW 313
61574: PUSH
61575: LD_VAR 0 12
61579: PUSH
61580: LD_INT 1
61582: ARRAY
61583: PPUSH
61584: CALL_OW 266
61588: PUSH
61589: LD_INT 32
61591: PUSH
61592: LD_INT 31
61594: PUSH
61595: EMPTY
61596: LIST
61597: LIST
61598: IN
61599: AND
61600: PUSH
61601: LD_VAR 0 12
61605: PUSH
61606: LD_INT 1
61608: ARRAY
61609: PPUSH
61610: CALL_OW 313
61614: PUSH
61615: LD_INT 6
61617: EQUAL
61618: OR
61619: IFFALSE 61639
// f := Delete ( f , 1 ) ;
61621: LD_ADDR_VAR 0 12
61625: PUSH
61626: LD_VAR 0 12
61630: PPUSH
61631: LD_INT 1
61633: PPUSH
61634: CALL_OW 3
61638: ST_TO_ADDR
// if not f then
61639: LD_VAR 0 12
61643: NOT
61644: IFFALSE 61662
// begin x := x + 2 ;
61646: LD_ADDR_VAR 0 13
61650: PUSH
61651: LD_VAR 0 13
61655: PUSH
61656: LD_INT 2
61658: PLUS
61659: ST_TO_ADDR
// continue ;
61660: GO 61460
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61662: LD_VAR 0 12
61666: PUSH
61667: LD_INT 1
61669: ARRAY
61670: PPUSH
61671: CALL_OW 266
61675: PUSH
61676: LD_INT 5
61678: EQUAL
61679: IFFALSE 61753
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61681: LD_VAR 0 12
61685: PUSH
61686: LD_INT 1
61688: ARRAY
61689: PPUSH
61690: CALL_OW 313
61694: PUSH
61695: LD_INT 3
61697: LESS
61698: IFFALSE 61734
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61700: LD_INT 0
61702: PPUSH
61703: LD_INT 5
61705: PUSH
61706: LD_INT 8
61708: PUSH
61709: LD_INT 9
61711: PUSH
61712: EMPTY
61713: LIST
61714: LIST
61715: LIST
61716: PUSH
61717: LD_VAR 0 17
61721: ARRAY
61722: PPUSH
61723: LD_VAR 0 4
61727: PPUSH
61728: CALL_OW 380
61732: GO 61751
// PrepareHuman ( false , i , skill ) ;
61734: LD_INT 0
61736: PPUSH
61737: LD_VAR 0 8
61741: PPUSH
61742: LD_VAR 0 4
61746: PPUSH
61747: CALL_OW 380
// end else
61751: GO 61770
// PrepareHuman ( false , i , skill ) ;
61753: LD_INT 0
61755: PPUSH
61756: LD_VAR 0 8
61760: PPUSH
61761: LD_VAR 0 4
61765: PPUSH
61766: CALL_OW 380
// un := CreateHuman ;
61770: LD_ADDR_VAR 0 14
61774: PUSH
61775: CALL_OW 44
61779: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61780: LD_ADDR_VAR 0 7
61784: PUSH
61785: LD_VAR 0 7
61789: PPUSH
61790: LD_INT 1
61792: PPUSH
61793: LD_VAR 0 14
61797: PPUSH
61798: CALL_OW 2
61802: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61803: LD_VAR 0 14
61807: PPUSH
61808: LD_VAR 0 12
61812: PUSH
61813: LD_INT 1
61815: ARRAY
61816: PPUSH
61817: CALL_OW 52
// end ;
61821: GO 61460
61823: POP
61824: POP
// end ;
61825: GO 60762
61827: POP
61828: POP
// result := result ^ buildings ;
61829: LD_ADDR_VAR 0 7
61833: PUSH
61834: LD_VAR 0 7
61838: PUSH
61839: LD_VAR 0 18
61843: ADD
61844: ST_TO_ADDR
// end else
61845: GO 61988
// begin for i = 1 to personel do
61847: LD_ADDR_VAR 0 8
61851: PUSH
61852: DOUBLE
61853: LD_INT 1
61855: DEC
61856: ST_TO_ADDR
61857: LD_VAR 0 6
61861: PUSH
61862: FOR_TO
61863: IFFALSE 61986
// begin if i > 4 then
61865: LD_VAR 0 8
61869: PUSH
61870: LD_INT 4
61872: GREATER
61873: IFFALSE 61877
// break ;
61875: GO 61986
// x := personel [ i ] ;
61877: LD_ADDR_VAR 0 13
61881: PUSH
61882: LD_VAR 0 6
61886: PUSH
61887: LD_VAR 0 8
61891: ARRAY
61892: ST_TO_ADDR
// if x = - 1 then
61893: LD_VAR 0 13
61897: PUSH
61898: LD_INT 1
61900: NEG
61901: EQUAL
61902: IFFALSE 61906
// continue ;
61904: GO 61862
// PrepareHuman ( false , i , skill ) ;
61906: LD_INT 0
61908: PPUSH
61909: LD_VAR 0 8
61913: PPUSH
61914: LD_VAR 0 4
61918: PPUSH
61919: CALL_OW 380
// un := CreateHuman ;
61923: LD_ADDR_VAR 0 14
61927: PUSH
61928: CALL_OW 44
61932: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61933: LD_VAR 0 14
61937: PPUSH
61938: LD_VAR 0 1
61942: PPUSH
61943: CALL_OW 250
61947: PPUSH
61948: LD_VAR 0 1
61952: PPUSH
61953: CALL_OW 251
61957: PPUSH
61958: LD_INT 10
61960: PPUSH
61961: LD_INT 0
61963: PPUSH
61964: CALL_OW 50
// result := result ^ un ;
61968: LD_ADDR_VAR 0 7
61972: PUSH
61973: LD_VAR 0 7
61977: PUSH
61978: LD_VAR 0 14
61982: ADD
61983: ST_TO_ADDR
// end ;
61984: GO 61862
61986: POP
61987: POP
// end ; end ;
61988: LD_VAR 0 7
61992: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61993: LD_INT 0
61995: PPUSH
61996: PPUSH
61997: PPUSH
61998: PPUSH
61999: PPUSH
62000: PPUSH
62001: PPUSH
62002: PPUSH
62003: PPUSH
62004: PPUSH
62005: PPUSH
62006: PPUSH
62007: PPUSH
62008: PPUSH
62009: PPUSH
62010: PPUSH
// result := false ;
62011: LD_ADDR_VAR 0 3
62015: PUSH
62016: LD_INT 0
62018: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62019: LD_VAR 0 1
62023: NOT
62024: PUSH
62025: LD_VAR 0 1
62029: PPUSH
62030: CALL_OW 266
62034: PUSH
62035: LD_INT 32
62037: PUSH
62038: LD_INT 33
62040: PUSH
62041: EMPTY
62042: LIST
62043: LIST
62044: IN
62045: NOT
62046: OR
62047: IFFALSE 62051
// exit ;
62049: GO 63160
// nat := GetNation ( tower ) ;
62051: LD_ADDR_VAR 0 12
62055: PUSH
62056: LD_VAR 0 1
62060: PPUSH
62061: CALL_OW 248
62065: ST_TO_ADDR
// side := GetSide ( tower ) ;
62066: LD_ADDR_VAR 0 16
62070: PUSH
62071: LD_VAR 0 1
62075: PPUSH
62076: CALL_OW 255
62080: ST_TO_ADDR
// x := GetX ( tower ) ;
62081: LD_ADDR_VAR 0 10
62085: PUSH
62086: LD_VAR 0 1
62090: PPUSH
62091: CALL_OW 250
62095: ST_TO_ADDR
// y := GetY ( tower ) ;
62096: LD_ADDR_VAR 0 11
62100: PUSH
62101: LD_VAR 0 1
62105: PPUSH
62106: CALL_OW 251
62110: ST_TO_ADDR
// if not x or not y then
62111: LD_VAR 0 10
62115: NOT
62116: PUSH
62117: LD_VAR 0 11
62121: NOT
62122: OR
62123: IFFALSE 62127
// exit ;
62125: GO 63160
// weapon := 0 ;
62127: LD_ADDR_VAR 0 18
62131: PUSH
62132: LD_INT 0
62134: ST_TO_ADDR
// fac_list := [ ] ;
62135: LD_ADDR_VAR 0 17
62139: PUSH
62140: EMPTY
62141: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62142: LD_ADDR_VAR 0 6
62146: PUSH
62147: LD_VAR 0 1
62151: PPUSH
62152: CALL_OW 274
62156: PPUSH
62157: LD_VAR 0 2
62161: PPUSH
62162: LD_INT 0
62164: PPUSH
62165: CALL 59731 0 3
62169: PPUSH
62170: LD_INT 30
62172: PUSH
62173: LD_INT 3
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: PPUSH
62180: CALL_OW 72
62184: ST_TO_ADDR
// if not factories then
62185: LD_VAR 0 6
62189: NOT
62190: IFFALSE 62194
// exit ;
62192: GO 63160
// for i in factories do
62194: LD_ADDR_VAR 0 8
62198: PUSH
62199: LD_VAR 0 6
62203: PUSH
62204: FOR_IN
62205: IFFALSE 62230
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62207: LD_ADDR_VAR 0 17
62211: PUSH
62212: LD_VAR 0 17
62216: PUSH
62217: LD_VAR 0 8
62221: PPUSH
62222: CALL_OW 478
62226: UNION
62227: ST_TO_ADDR
62228: GO 62204
62230: POP
62231: POP
// if not fac_list then
62232: LD_VAR 0 17
62236: NOT
62237: IFFALSE 62241
// exit ;
62239: GO 63160
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62241: LD_ADDR_VAR 0 5
62245: PUSH
62246: LD_INT 4
62248: PUSH
62249: LD_INT 5
62251: PUSH
62252: LD_INT 9
62254: PUSH
62255: LD_INT 10
62257: PUSH
62258: LD_INT 6
62260: PUSH
62261: LD_INT 7
62263: PUSH
62264: LD_INT 11
62266: PUSH
62267: EMPTY
62268: LIST
62269: LIST
62270: LIST
62271: LIST
62272: LIST
62273: LIST
62274: LIST
62275: PUSH
62276: LD_INT 27
62278: PUSH
62279: LD_INT 28
62281: PUSH
62282: LD_INT 26
62284: PUSH
62285: LD_INT 30
62287: PUSH
62288: EMPTY
62289: LIST
62290: LIST
62291: LIST
62292: LIST
62293: PUSH
62294: LD_INT 43
62296: PUSH
62297: LD_INT 44
62299: PUSH
62300: LD_INT 46
62302: PUSH
62303: LD_INT 45
62305: PUSH
62306: LD_INT 47
62308: PUSH
62309: LD_INT 49
62311: PUSH
62312: EMPTY
62313: LIST
62314: LIST
62315: LIST
62316: LIST
62317: LIST
62318: LIST
62319: PUSH
62320: EMPTY
62321: LIST
62322: LIST
62323: LIST
62324: PUSH
62325: LD_VAR 0 12
62329: ARRAY
62330: ST_TO_ADDR
// list := list isect fac_list ;
62331: LD_ADDR_VAR 0 5
62335: PUSH
62336: LD_VAR 0 5
62340: PUSH
62341: LD_VAR 0 17
62345: ISECT
62346: ST_TO_ADDR
// if not list then
62347: LD_VAR 0 5
62351: NOT
62352: IFFALSE 62356
// exit ;
62354: GO 63160
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62356: LD_VAR 0 12
62360: PUSH
62361: LD_INT 3
62363: EQUAL
62364: PUSH
62365: LD_INT 49
62367: PUSH
62368: LD_VAR 0 5
62372: IN
62373: AND
62374: PUSH
62375: LD_INT 31
62377: PPUSH
62378: LD_VAR 0 16
62382: PPUSH
62383: CALL_OW 321
62387: PUSH
62388: LD_INT 2
62390: EQUAL
62391: AND
62392: IFFALSE 62452
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62394: LD_INT 22
62396: PUSH
62397: LD_VAR 0 16
62401: PUSH
62402: EMPTY
62403: LIST
62404: LIST
62405: PUSH
62406: LD_INT 35
62408: PUSH
62409: LD_INT 49
62411: PUSH
62412: EMPTY
62413: LIST
62414: LIST
62415: PUSH
62416: LD_INT 91
62418: PUSH
62419: LD_VAR 0 1
62423: PUSH
62424: LD_INT 10
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: LIST
62431: PUSH
62432: EMPTY
62433: LIST
62434: LIST
62435: LIST
62436: PPUSH
62437: CALL_OW 69
62441: NOT
62442: IFFALSE 62452
// weapon := ru_time_lapser ;
62444: LD_ADDR_VAR 0 18
62448: PUSH
62449: LD_INT 49
62451: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62452: LD_VAR 0 12
62456: PUSH
62457: LD_INT 1
62459: PUSH
62460: LD_INT 2
62462: PUSH
62463: EMPTY
62464: LIST
62465: LIST
62466: IN
62467: PUSH
62468: LD_INT 11
62470: PUSH
62471: LD_VAR 0 5
62475: IN
62476: PUSH
62477: LD_INT 30
62479: PUSH
62480: LD_VAR 0 5
62484: IN
62485: OR
62486: AND
62487: PUSH
62488: LD_INT 6
62490: PPUSH
62491: LD_VAR 0 16
62495: PPUSH
62496: CALL_OW 321
62500: PUSH
62501: LD_INT 2
62503: EQUAL
62504: AND
62505: IFFALSE 62670
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62507: LD_INT 22
62509: PUSH
62510: LD_VAR 0 16
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: PUSH
62519: LD_INT 2
62521: PUSH
62522: LD_INT 35
62524: PUSH
62525: LD_INT 11
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PUSH
62532: LD_INT 35
62534: PUSH
62535: LD_INT 30
62537: PUSH
62538: EMPTY
62539: LIST
62540: LIST
62541: PUSH
62542: EMPTY
62543: LIST
62544: LIST
62545: LIST
62546: PUSH
62547: LD_INT 91
62549: PUSH
62550: LD_VAR 0 1
62554: PUSH
62555: LD_INT 18
62557: PUSH
62558: EMPTY
62559: LIST
62560: LIST
62561: LIST
62562: PUSH
62563: EMPTY
62564: LIST
62565: LIST
62566: LIST
62567: PPUSH
62568: CALL_OW 69
62572: NOT
62573: PUSH
62574: LD_INT 22
62576: PUSH
62577: LD_VAR 0 16
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: PUSH
62586: LD_INT 2
62588: PUSH
62589: LD_INT 30
62591: PUSH
62592: LD_INT 32
62594: PUSH
62595: EMPTY
62596: LIST
62597: LIST
62598: PUSH
62599: LD_INT 30
62601: PUSH
62602: LD_INT 33
62604: PUSH
62605: EMPTY
62606: LIST
62607: LIST
62608: PUSH
62609: EMPTY
62610: LIST
62611: LIST
62612: LIST
62613: PUSH
62614: LD_INT 91
62616: PUSH
62617: LD_VAR 0 1
62621: PUSH
62622: LD_INT 12
62624: PUSH
62625: EMPTY
62626: LIST
62627: LIST
62628: LIST
62629: PUSH
62630: EMPTY
62631: LIST
62632: LIST
62633: LIST
62634: PUSH
62635: EMPTY
62636: LIST
62637: PPUSH
62638: CALL_OW 69
62642: PUSH
62643: LD_INT 2
62645: GREATER
62646: AND
62647: IFFALSE 62670
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62649: LD_ADDR_VAR 0 18
62653: PUSH
62654: LD_INT 11
62656: PUSH
62657: LD_INT 30
62659: PUSH
62660: EMPTY
62661: LIST
62662: LIST
62663: PUSH
62664: LD_VAR 0 12
62668: ARRAY
62669: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62670: LD_VAR 0 18
62674: NOT
62675: PUSH
62676: LD_INT 40
62678: PPUSH
62679: LD_VAR 0 16
62683: PPUSH
62684: CALL_OW 321
62688: PUSH
62689: LD_INT 2
62691: EQUAL
62692: AND
62693: PUSH
62694: LD_INT 7
62696: PUSH
62697: LD_VAR 0 5
62701: IN
62702: PUSH
62703: LD_INT 28
62705: PUSH
62706: LD_VAR 0 5
62710: IN
62711: OR
62712: PUSH
62713: LD_INT 45
62715: PUSH
62716: LD_VAR 0 5
62720: IN
62721: OR
62722: AND
62723: IFFALSE 62977
// begin hex := GetHexInfo ( x , y ) ;
62725: LD_ADDR_VAR 0 4
62729: PUSH
62730: LD_VAR 0 10
62734: PPUSH
62735: LD_VAR 0 11
62739: PPUSH
62740: CALL_OW 546
62744: ST_TO_ADDR
// if hex [ 1 ] then
62745: LD_VAR 0 4
62749: PUSH
62750: LD_INT 1
62752: ARRAY
62753: IFFALSE 62757
// exit ;
62755: GO 63160
// height := hex [ 2 ] ;
62757: LD_ADDR_VAR 0 15
62761: PUSH
62762: LD_VAR 0 4
62766: PUSH
62767: LD_INT 2
62769: ARRAY
62770: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62771: LD_ADDR_VAR 0 14
62775: PUSH
62776: LD_INT 0
62778: PUSH
62779: LD_INT 2
62781: PUSH
62782: LD_INT 3
62784: PUSH
62785: LD_INT 5
62787: PUSH
62788: EMPTY
62789: LIST
62790: LIST
62791: LIST
62792: LIST
62793: ST_TO_ADDR
// for i in tmp do
62794: LD_ADDR_VAR 0 8
62798: PUSH
62799: LD_VAR 0 14
62803: PUSH
62804: FOR_IN
62805: IFFALSE 62975
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62807: LD_ADDR_VAR 0 9
62811: PUSH
62812: LD_VAR 0 10
62816: PPUSH
62817: LD_VAR 0 8
62821: PPUSH
62822: LD_INT 5
62824: PPUSH
62825: CALL_OW 272
62829: PUSH
62830: LD_VAR 0 11
62834: PPUSH
62835: LD_VAR 0 8
62839: PPUSH
62840: LD_INT 5
62842: PPUSH
62843: CALL_OW 273
62847: PUSH
62848: EMPTY
62849: LIST
62850: LIST
62851: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62852: LD_VAR 0 9
62856: PUSH
62857: LD_INT 1
62859: ARRAY
62860: PPUSH
62861: LD_VAR 0 9
62865: PUSH
62866: LD_INT 2
62868: ARRAY
62869: PPUSH
62870: CALL_OW 488
62874: IFFALSE 62973
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62876: LD_ADDR_VAR 0 4
62880: PUSH
62881: LD_VAR 0 9
62885: PUSH
62886: LD_INT 1
62888: ARRAY
62889: PPUSH
62890: LD_VAR 0 9
62894: PUSH
62895: LD_INT 2
62897: ARRAY
62898: PPUSH
62899: CALL_OW 546
62903: ST_TO_ADDR
// if hex [ 1 ] then
62904: LD_VAR 0 4
62908: PUSH
62909: LD_INT 1
62911: ARRAY
62912: IFFALSE 62916
// continue ;
62914: GO 62804
// h := hex [ 2 ] ;
62916: LD_ADDR_VAR 0 13
62920: PUSH
62921: LD_VAR 0 4
62925: PUSH
62926: LD_INT 2
62928: ARRAY
62929: ST_TO_ADDR
// if h + 7 < height then
62930: LD_VAR 0 13
62934: PUSH
62935: LD_INT 7
62937: PLUS
62938: PUSH
62939: LD_VAR 0 15
62943: LESS
62944: IFFALSE 62973
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62946: LD_ADDR_VAR 0 18
62950: PUSH
62951: LD_INT 7
62953: PUSH
62954: LD_INT 28
62956: PUSH
62957: LD_INT 45
62959: PUSH
62960: EMPTY
62961: LIST
62962: LIST
62963: LIST
62964: PUSH
62965: LD_VAR 0 12
62969: ARRAY
62970: ST_TO_ADDR
// break ;
62971: GO 62975
// end ; end ; end ;
62973: GO 62804
62975: POP
62976: POP
// end ; if not weapon then
62977: LD_VAR 0 18
62981: NOT
62982: IFFALSE 63042
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62984: LD_ADDR_VAR 0 5
62988: PUSH
62989: LD_VAR 0 5
62993: PUSH
62994: LD_INT 11
62996: PUSH
62997: LD_INT 30
62999: PUSH
63000: LD_INT 49
63002: PUSH
63003: EMPTY
63004: LIST
63005: LIST
63006: LIST
63007: DIFF
63008: ST_TO_ADDR
// if not list then
63009: LD_VAR 0 5
63013: NOT
63014: IFFALSE 63018
// exit ;
63016: GO 63160
// weapon := list [ rand ( 1 , list ) ] ;
63018: LD_ADDR_VAR 0 18
63022: PUSH
63023: LD_VAR 0 5
63027: PUSH
63028: LD_INT 1
63030: PPUSH
63031: LD_VAR 0 5
63035: PPUSH
63036: CALL_OW 12
63040: ARRAY
63041: ST_TO_ADDR
// end ; if weapon then
63042: LD_VAR 0 18
63046: IFFALSE 63160
// begin tmp := CostOfWeapon ( weapon ) ;
63048: LD_ADDR_VAR 0 14
63052: PUSH
63053: LD_VAR 0 18
63057: PPUSH
63058: CALL_OW 451
63062: ST_TO_ADDR
// j := GetBase ( tower ) ;
63063: LD_ADDR_VAR 0 9
63067: PUSH
63068: LD_VAR 0 1
63072: PPUSH
63073: CALL_OW 274
63077: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63078: LD_VAR 0 9
63082: PPUSH
63083: LD_INT 1
63085: PPUSH
63086: CALL_OW 275
63090: PUSH
63091: LD_VAR 0 14
63095: PUSH
63096: LD_INT 1
63098: ARRAY
63099: GREATEREQUAL
63100: PUSH
63101: LD_VAR 0 9
63105: PPUSH
63106: LD_INT 2
63108: PPUSH
63109: CALL_OW 275
63113: PUSH
63114: LD_VAR 0 14
63118: PUSH
63119: LD_INT 2
63121: ARRAY
63122: GREATEREQUAL
63123: AND
63124: PUSH
63125: LD_VAR 0 9
63129: PPUSH
63130: LD_INT 3
63132: PPUSH
63133: CALL_OW 275
63137: PUSH
63138: LD_VAR 0 14
63142: PUSH
63143: LD_INT 3
63145: ARRAY
63146: GREATEREQUAL
63147: AND
63148: IFFALSE 63160
// result := weapon ;
63150: LD_ADDR_VAR 0 3
63154: PUSH
63155: LD_VAR 0 18
63159: ST_TO_ADDR
// end ; end ;
63160: LD_VAR 0 3
63164: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63165: LD_INT 0
63167: PPUSH
63168: PPUSH
// result := true ;
63169: LD_ADDR_VAR 0 3
63173: PUSH
63174: LD_INT 1
63176: ST_TO_ADDR
// if array1 = array2 then
63177: LD_VAR 0 1
63181: PUSH
63182: LD_VAR 0 2
63186: EQUAL
63187: IFFALSE 63247
// begin for i = 1 to array1 do
63189: LD_ADDR_VAR 0 4
63193: PUSH
63194: DOUBLE
63195: LD_INT 1
63197: DEC
63198: ST_TO_ADDR
63199: LD_VAR 0 1
63203: PUSH
63204: FOR_TO
63205: IFFALSE 63243
// if array1 [ i ] <> array2 [ i ] then
63207: LD_VAR 0 1
63211: PUSH
63212: LD_VAR 0 4
63216: ARRAY
63217: PUSH
63218: LD_VAR 0 2
63222: PUSH
63223: LD_VAR 0 4
63227: ARRAY
63228: NONEQUAL
63229: IFFALSE 63241
// begin result := false ;
63231: LD_ADDR_VAR 0 3
63235: PUSH
63236: LD_INT 0
63238: ST_TO_ADDR
// break ;
63239: GO 63243
// end ;
63241: GO 63204
63243: POP
63244: POP
// end else
63245: GO 63255
// result := false ;
63247: LD_ADDR_VAR 0 3
63251: PUSH
63252: LD_INT 0
63254: ST_TO_ADDR
// end ;
63255: LD_VAR 0 3
63259: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63260: LD_INT 0
63262: PPUSH
63263: PPUSH
// if not array1 or not array2 then
63264: LD_VAR 0 1
63268: NOT
63269: PUSH
63270: LD_VAR 0 2
63274: NOT
63275: OR
63276: IFFALSE 63280
// exit ;
63278: GO 63344
// result := true ;
63280: LD_ADDR_VAR 0 3
63284: PUSH
63285: LD_INT 1
63287: ST_TO_ADDR
// for i = 1 to array1 do
63288: LD_ADDR_VAR 0 4
63292: PUSH
63293: DOUBLE
63294: LD_INT 1
63296: DEC
63297: ST_TO_ADDR
63298: LD_VAR 0 1
63302: PUSH
63303: FOR_TO
63304: IFFALSE 63342
// if array1 [ i ] <> array2 [ i ] then
63306: LD_VAR 0 1
63310: PUSH
63311: LD_VAR 0 4
63315: ARRAY
63316: PUSH
63317: LD_VAR 0 2
63321: PUSH
63322: LD_VAR 0 4
63326: ARRAY
63327: NONEQUAL
63328: IFFALSE 63340
// begin result := false ;
63330: LD_ADDR_VAR 0 3
63334: PUSH
63335: LD_INT 0
63337: ST_TO_ADDR
// break ;
63338: GO 63342
// end ;
63340: GO 63303
63342: POP
63343: POP
// end ;
63344: LD_VAR 0 3
63348: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63349: LD_INT 0
63351: PPUSH
63352: PPUSH
63353: PPUSH
// pom := GetBase ( fac ) ;
63354: LD_ADDR_VAR 0 5
63358: PUSH
63359: LD_VAR 0 1
63363: PPUSH
63364: CALL_OW 274
63368: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63369: LD_ADDR_VAR 0 4
63373: PUSH
63374: LD_VAR 0 2
63378: PUSH
63379: LD_INT 1
63381: ARRAY
63382: PPUSH
63383: LD_VAR 0 2
63387: PUSH
63388: LD_INT 2
63390: ARRAY
63391: PPUSH
63392: LD_VAR 0 2
63396: PUSH
63397: LD_INT 3
63399: ARRAY
63400: PPUSH
63401: LD_VAR 0 2
63405: PUSH
63406: LD_INT 4
63408: ARRAY
63409: PPUSH
63410: CALL_OW 449
63414: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63415: LD_ADDR_VAR 0 3
63419: PUSH
63420: LD_VAR 0 5
63424: PPUSH
63425: LD_INT 1
63427: PPUSH
63428: CALL_OW 275
63432: PUSH
63433: LD_VAR 0 4
63437: PUSH
63438: LD_INT 1
63440: ARRAY
63441: GREATEREQUAL
63442: PUSH
63443: LD_VAR 0 5
63447: PPUSH
63448: LD_INT 2
63450: PPUSH
63451: CALL_OW 275
63455: PUSH
63456: LD_VAR 0 4
63460: PUSH
63461: LD_INT 2
63463: ARRAY
63464: GREATEREQUAL
63465: AND
63466: PUSH
63467: LD_VAR 0 5
63471: PPUSH
63472: LD_INT 3
63474: PPUSH
63475: CALL_OW 275
63479: PUSH
63480: LD_VAR 0 4
63484: PUSH
63485: LD_INT 3
63487: ARRAY
63488: GREATEREQUAL
63489: AND
63490: ST_TO_ADDR
// end ;
63491: LD_VAR 0 3
63495: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63496: LD_INT 0
63498: PPUSH
63499: PPUSH
63500: PPUSH
63501: PPUSH
// pom := GetBase ( building ) ;
63502: LD_ADDR_VAR 0 3
63506: PUSH
63507: LD_VAR 0 1
63511: PPUSH
63512: CALL_OW 274
63516: ST_TO_ADDR
// if not pom then
63517: LD_VAR 0 3
63521: NOT
63522: IFFALSE 63526
// exit ;
63524: GO 63696
// btype := GetBType ( building ) ;
63526: LD_ADDR_VAR 0 5
63530: PUSH
63531: LD_VAR 0 1
63535: PPUSH
63536: CALL_OW 266
63540: ST_TO_ADDR
// if btype = b_armoury then
63541: LD_VAR 0 5
63545: PUSH
63546: LD_INT 4
63548: EQUAL
63549: IFFALSE 63559
// btype := b_barracks ;
63551: LD_ADDR_VAR 0 5
63555: PUSH
63556: LD_INT 5
63558: ST_TO_ADDR
// if btype = b_depot then
63559: LD_VAR 0 5
63563: PUSH
63564: LD_INT 0
63566: EQUAL
63567: IFFALSE 63577
// btype := b_warehouse ;
63569: LD_ADDR_VAR 0 5
63573: PUSH
63574: LD_INT 1
63576: ST_TO_ADDR
// if btype = b_workshop then
63577: LD_VAR 0 5
63581: PUSH
63582: LD_INT 2
63584: EQUAL
63585: IFFALSE 63595
// btype := b_factory ;
63587: LD_ADDR_VAR 0 5
63591: PUSH
63592: LD_INT 3
63594: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63595: LD_ADDR_VAR 0 4
63599: PUSH
63600: LD_VAR 0 5
63604: PPUSH
63605: LD_VAR 0 1
63609: PPUSH
63610: CALL_OW 248
63614: PPUSH
63615: CALL_OW 450
63619: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63620: LD_ADDR_VAR 0 2
63624: PUSH
63625: LD_VAR 0 3
63629: PPUSH
63630: LD_INT 1
63632: PPUSH
63633: CALL_OW 275
63637: PUSH
63638: LD_VAR 0 4
63642: PUSH
63643: LD_INT 1
63645: ARRAY
63646: GREATEREQUAL
63647: PUSH
63648: LD_VAR 0 3
63652: PPUSH
63653: LD_INT 2
63655: PPUSH
63656: CALL_OW 275
63660: PUSH
63661: LD_VAR 0 4
63665: PUSH
63666: LD_INT 2
63668: ARRAY
63669: GREATEREQUAL
63670: AND
63671: PUSH
63672: LD_VAR 0 3
63676: PPUSH
63677: LD_INT 3
63679: PPUSH
63680: CALL_OW 275
63684: PUSH
63685: LD_VAR 0 4
63689: PUSH
63690: LD_INT 3
63692: ARRAY
63693: GREATEREQUAL
63694: AND
63695: ST_TO_ADDR
// end ;
63696: LD_VAR 0 2
63700: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63701: LD_INT 0
63703: PPUSH
63704: PPUSH
63705: PPUSH
// pom := GetBase ( building ) ;
63706: LD_ADDR_VAR 0 4
63710: PUSH
63711: LD_VAR 0 1
63715: PPUSH
63716: CALL_OW 274
63720: ST_TO_ADDR
// if not pom then
63721: LD_VAR 0 4
63725: NOT
63726: IFFALSE 63730
// exit ;
63728: GO 63831
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63730: LD_ADDR_VAR 0 5
63734: PUSH
63735: LD_VAR 0 2
63739: PPUSH
63740: LD_VAR 0 1
63744: PPUSH
63745: CALL_OW 248
63749: PPUSH
63750: CALL_OW 450
63754: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63755: LD_ADDR_VAR 0 3
63759: PUSH
63760: LD_VAR 0 4
63764: PPUSH
63765: LD_INT 1
63767: PPUSH
63768: CALL_OW 275
63772: PUSH
63773: LD_VAR 0 5
63777: PUSH
63778: LD_INT 1
63780: ARRAY
63781: GREATEREQUAL
63782: PUSH
63783: LD_VAR 0 4
63787: PPUSH
63788: LD_INT 2
63790: PPUSH
63791: CALL_OW 275
63795: PUSH
63796: LD_VAR 0 5
63800: PUSH
63801: LD_INT 2
63803: ARRAY
63804: GREATEREQUAL
63805: AND
63806: PUSH
63807: LD_VAR 0 4
63811: PPUSH
63812: LD_INT 3
63814: PPUSH
63815: CALL_OW 275
63819: PUSH
63820: LD_VAR 0 5
63824: PUSH
63825: LD_INT 3
63827: ARRAY
63828: GREATEREQUAL
63829: AND
63830: ST_TO_ADDR
// end ;
63831: LD_VAR 0 3
63835: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63836: LD_INT 0
63838: PPUSH
63839: PPUSH
63840: PPUSH
63841: PPUSH
63842: PPUSH
63843: PPUSH
63844: PPUSH
63845: PPUSH
63846: PPUSH
63847: PPUSH
63848: PPUSH
// result := false ;
63849: LD_ADDR_VAR 0 8
63853: PUSH
63854: LD_INT 0
63856: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63857: LD_VAR 0 5
63861: NOT
63862: PUSH
63863: LD_VAR 0 1
63867: NOT
63868: OR
63869: PUSH
63870: LD_VAR 0 2
63874: NOT
63875: OR
63876: PUSH
63877: LD_VAR 0 3
63881: NOT
63882: OR
63883: IFFALSE 63887
// exit ;
63885: GO 64701
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63887: LD_ADDR_VAR 0 14
63891: PUSH
63892: LD_VAR 0 1
63896: PPUSH
63897: LD_VAR 0 2
63901: PPUSH
63902: LD_VAR 0 3
63906: PPUSH
63907: LD_VAR 0 4
63911: PPUSH
63912: LD_VAR 0 5
63916: PUSH
63917: LD_INT 1
63919: ARRAY
63920: PPUSH
63921: CALL_OW 248
63925: PPUSH
63926: LD_INT 0
63928: PPUSH
63929: CALL 65934 0 6
63933: ST_TO_ADDR
// if not hexes then
63934: LD_VAR 0 14
63938: NOT
63939: IFFALSE 63943
// exit ;
63941: GO 64701
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63943: LD_ADDR_VAR 0 17
63947: PUSH
63948: LD_VAR 0 5
63952: PPUSH
63953: LD_INT 22
63955: PUSH
63956: LD_VAR 0 13
63960: PPUSH
63961: CALL_OW 255
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 2
63972: PUSH
63973: LD_INT 30
63975: PUSH
63976: LD_INT 0
63978: PUSH
63979: EMPTY
63980: LIST
63981: LIST
63982: PUSH
63983: LD_INT 30
63985: PUSH
63986: LD_INT 1
63988: PUSH
63989: EMPTY
63990: LIST
63991: LIST
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: LIST
63997: PUSH
63998: EMPTY
63999: LIST
64000: LIST
64001: PPUSH
64002: CALL_OW 72
64006: ST_TO_ADDR
// for i = 1 to hexes do
64007: LD_ADDR_VAR 0 9
64011: PUSH
64012: DOUBLE
64013: LD_INT 1
64015: DEC
64016: ST_TO_ADDR
64017: LD_VAR 0 14
64021: PUSH
64022: FOR_TO
64023: IFFALSE 64699
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64025: LD_ADDR_VAR 0 13
64029: PUSH
64030: LD_VAR 0 14
64034: PUSH
64035: LD_VAR 0 9
64039: ARRAY
64040: PUSH
64041: LD_INT 1
64043: ARRAY
64044: PPUSH
64045: LD_VAR 0 14
64049: PUSH
64050: LD_VAR 0 9
64054: ARRAY
64055: PUSH
64056: LD_INT 2
64058: ARRAY
64059: PPUSH
64060: CALL_OW 428
64064: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64065: LD_VAR 0 14
64069: PUSH
64070: LD_VAR 0 9
64074: ARRAY
64075: PUSH
64076: LD_INT 1
64078: ARRAY
64079: PPUSH
64080: LD_VAR 0 14
64084: PUSH
64085: LD_VAR 0 9
64089: ARRAY
64090: PUSH
64091: LD_INT 2
64093: ARRAY
64094: PPUSH
64095: CALL_OW 351
64099: PUSH
64100: LD_VAR 0 14
64104: PUSH
64105: LD_VAR 0 9
64109: ARRAY
64110: PUSH
64111: LD_INT 1
64113: ARRAY
64114: PPUSH
64115: LD_VAR 0 14
64119: PUSH
64120: LD_VAR 0 9
64124: ARRAY
64125: PUSH
64126: LD_INT 2
64128: ARRAY
64129: PPUSH
64130: CALL_OW 488
64134: NOT
64135: OR
64136: PUSH
64137: LD_VAR 0 13
64141: PPUSH
64142: CALL_OW 247
64146: PUSH
64147: LD_INT 3
64149: EQUAL
64150: OR
64151: IFFALSE 64157
// exit ;
64153: POP
64154: POP
64155: GO 64701
// if not tmp then
64157: LD_VAR 0 13
64161: NOT
64162: IFFALSE 64166
// continue ;
64164: GO 64022
// result := true ;
64166: LD_ADDR_VAR 0 8
64170: PUSH
64171: LD_INT 1
64173: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64174: LD_VAR 0 6
64178: PUSH
64179: LD_VAR 0 13
64183: PPUSH
64184: CALL_OW 247
64188: PUSH
64189: LD_INT 2
64191: EQUAL
64192: AND
64193: PUSH
64194: LD_VAR 0 13
64198: PPUSH
64199: CALL_OW 263
64203: PUSH
64204: LD_INT 1
64206: EQUAL
64207: AND
64208: IFFALSE 64372
// begin if IsDrivenBy ( tmp ) then
64210: LD_VAR 0 13
64214: PPUSH
64215: CALL_OW 311
64219: IFFALSE 64223
// continue ;
64221: GO 64022
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64223: LD_VAR 0 6
64227: PPUSH
64228: LD_INT 3
64230: PUSH
64231: LD_INT 60
64233: PUSH
64234: EMPTY
64235: LIST
64236: PUSH
64237: EMPTY
64238: LIST
64239: LIST
64240: PUSH
64241: LD_INT 3
64243: PUSH
64244: LD_INT 55
64246: PUSH
64247: EMPTY
64248: LIST
64249: PUSH
64250: EMPTY
64251: LIST
64252: LIST
64253: PUSH
64254: EMPTY
64255: LIST
64256: LIST
64257: PPUSH
64258: CALL_OW 72
64262: IFFALSE 64370
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64264: LD_ADDR_VAR 0 18
64268: PUSH
64269: LD_VAR 0 6
64273: PPUSH
64274: LD_INT 3
64276: PUSH
64277: LD_INT 60
64279: PUSH
64280: EMPTY
64281: LIST
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PUSH
64287: LD_INT 3
64289: PUSH
64290: LD_INT 55
64292: PUSH
64293: EMPTY
64294: LIST
64295: PUSH
64296: EMPTY
64297: LIST
64298: LIST
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PPUSH
64304: CALL_OW 72
64308: PUSH
64309: LD_INT 1
64311: ARRAY
64312: ST_TO_ADDR
// if IsInUnit ( driver ) then
64313: LD_VAR 0 18
64317: PPUSH
64318: CALL_OW 310
64322: IFFALSE 64333
// ComExit ( driver ) ;
64324: LD_VAR 0 18
64328: PPUSH
64329: CALL 89622 0 1
// AddComEnterUnit ( driver , tmp ) ;
64333: LD_VAR 0 18
64337: PPUSH
64338: LD_VAR 0 13
64342: PPUSH
64343: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64347: LD_VAR 0 18
64351: PPUSH
64352: LD_VAR 0 7
64356: PPUSH
64357: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64361: LD_VAR 0 18
64365: PPUSH
64366: CALL_OW 181
// end ; continue ;
64370: GO 64022
// end ; if not cleaners or not tmp in cleaners then
64372: LD_VAR 0 6
64376: NOT
64377: PUSH
64378: LD_VAR 0 13
64382: PUSH
64383: LD_VAR 0 6
64387: IN
64388: NOT
64389: OR
64390: IFFALSE 64697
// begin if dep then
64392: LD_VAR 0 17
64396: IFFALSE 64532
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64398: LD_ADDR_VAR 0 16
64402: PUSH
64403: LD_VAR 0 17
64407: PUSH
64408: LD_INT 1
64410: ARRAY
64411: PPUSH
64412: CALL_OW 250
64416: PPUSH
64417: LD_VAR 0 17
64421: PUSH
64422: LD_INT 1
64424: ARRAY
64425: PPUSH
64426: CALL_OW 254
64430: PPUSH
64431: LD_INT 5
64433: PPUSH
64434: CALL_OW 272
64438: PUSH
64439: LD_VAR 0 17
64443: PUSH
64444: LD_INT 1
64446: ARRAY
64447: PPUSH
64448: CALL_OW 251
64452: PPUSH
64453: LD_VAR 0 17
64457: PUSH
64458: LD_INT 1
64460: ARRAY
64461: PPUSH
64462: CALL_OW 254
64466: PPUSH
64467: LD_INT 5
64469: PPUSH
64470: CALL_OW 273
64474: PUSH
64475: EMPTY
64476: LIST
64477: LIST
64478: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64479: LD_VAR 0 16
64483: PUSH
64484: LD_INT 1
64486: ARRAY
64487: PPUSH
64488: LD_VAR 0 16
64492: PUSH
64493: LD_INT 2
64495: ARRAY
64496: PPUSH
64497: CALL_OW 488
64501: IFFALSE 64532
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64503: LD_VAR 0 13
64507: PPUSH
64508: LD_VAR 0 16
64512: PUSH
64513: LD_INT 1
64515: ARRAY
64516: PPUSH
64517: LD_VAR 0 16
64521: PUSH
64522: LD_INT 2
64524: ARRAY
64525: PPUSH
64526: CALL_OW 111
// continue ;
64530: GO 64022
// end ; end ; r := GetDir ( tmp ) ;
64532: LD_ADDR_VAR 0 15
64536: PUSH
64537: LD_VAR 0 13
64541: PPUSH
64542: CALL_OW 254
64546: ST_TO_ADDR
// if r = 5 then
64547: LD_VAR 0 15
64551: PUSH
64552: LD_INT 5
64554: EQUAL
64555: IFFALSE 64565
// r := 0 ;
64557: LD_ADDR_VAR 0 15
64561: PUSH
64562: LD_INT 0
64564: ST_TO_ADDR
// for j = r to 5 do
64565: LD_ADDR_VAR 0 10
64569: PUSH
64570: DOUBLE
64571: LD_VAR 0 15
64575: DEC
64576: ST_TO_ADDR
64577: LD_INT 5
64579: PUSH
64580: FOR_TO
64581: IFFALSE 64695
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64583: LD_ADDR_VAR 0 11
64587: PUSH
64588: LD_VAR 0 13
64592: PPUSH
64593: CALL_OW 250
64597: PPUSH
64598: LD_VAR 0 10
64602: PPUSH
64603: LD_INT 2
64605: PPUSH
64606: CALL_OW 272
64610: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64611: LD_ADDR_VAR 0 12
64615: PUSH
64616: LD_VAR 0 13
64620: PPUSH
64621: CALL_OW 251
64625: PPUSH
64626: LD_VAR 0 10
64630: PPUSH
64631: LD_INT 2
64633: PPUSH
64634: CALL_OW 273
64638: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64639: LD_VAR 0 11
64643: PPUSH
64644: LD_VAR 0 12
64648: PPUSH
64649: CALL_OW 488
64653: PUSH
64654: LD_VAR 0 11
64658: PPUSH
64659: LD_VAR 0 12
64663: PPUSH
64664: CALL_OW 428
64668: NOT
64669: AND
64670: IFFALSE 64693
// begin ComMoveXY ( tmp , _x , _y ) ;
64672: LD_VAR 0 13
64676: PPUSH
64677: LD_VAR 0 11
64681: PPUSH
64682: LD_VAR 0 12
64686: PPUSH
64687: CALL_OW 111
// break ;
64691: GO 64695
// end ; end ;
64693: GO 64580
64695: POP
64696: POP
// end ; end ;
64697: GO 64022
64699: POP
64700: POP
// end ;
64701: LD_VAR 0 8
64705: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64706: LD_INT 0
64708: PPUSH
// result := true ;
64709: LD_ADDR_VAR 0 3
64713: PUSH
64714: LD_INT 1
64716: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64717: LD_VAR 0 2
64721: PUSH
64722: LD_INT 24
64724: DOUBLE
64725: EQUAL
64726: IFTRUE 64736
64728: LD_INT 33
64730: DOUBLE
64731: EQUAL
64732: IFTRUE 64736
64734: GO 64761
64736: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64737: LD_ADDR_VAR 0 3
64741: PUSH
64742: LD_INT 32
64744: PPUSH
64745: LD_VAR 0 1
64749: PPUSH
64750: CALL_OW 321
64754: PUSH
64755: LD_INT 2
64757: EQUAL
64758: ST_TO_ADDR
64759: GO 65077
64761: LD_INT 20
64763: DOUBLE
64764: EQUAL
64765: IFTRUE 64769
64767: GO 64794
64769: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64770: LD_ADDR_VAR 0 3
64774: PUSH
64775: LD_INT 6
64777: PPUSH
64778: LD_VAR 0 1
64782: PPUSH
64783: CALL_OW 321
64787: PUSH
64788: LD_INT 2
64790: EQUAL
64791: ST_TO_ADDR
64792: GO 65077
64794: LD_INT 22
64796: DOUBLE
64797: EQUAL
64798: IFTRUE 64808
64800: LD_INT 36
64802: DOUBLE
64803: EQUAL
64804: IFTRUE 64808
64806: GO 64833
64808: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64809: LD_ADDR_VAR 0 3
64813: PUSH
64814: LD_INT 15
64816: PPUSH
64817: LD_VAR 0 1
64821: PPUSH
64822: CALL_OW 321
64826: PUSH
64827: LD_INT 2
64829: EQUAL
64830: ST_TO_ADDR
64831: GO 65077
64833: LD_INT 30
64835: DOUBLE
64836: EQUAL
64837: IFTRUE 64841
64839: GO 64866
64841: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64842: LD_ADDR_VAR 0 3
64846: PUSH
64847: LD_INT 20
64849: PPUSH
64850: LD_VAR 0 1
64854: PPUSH
64855: CALL_OW 321
64859: PUSH
64860: LD_INT 2
64862: EQUAL
64863: ST_TO_ADDR
64864: GO 65077
64866: LD_INT 28
64868: DOUBLE
64869: EQUAL
64870: IFTRUE 64880
64872: LD_INT 21
64874: DOUBLE
64875: EQUAL
64876: IFTRUE 64880
64878: GO 64905
64880: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64881: LD_ADDR_VAR 0 3
64885: PUSH
64886: LD_INT 21
64888: PPUSH
64889: LD_VAR 0 1
64893: PPUSH
64894: CALL_OW 321
64898: PUSH
64899: LD_INT 2
64901: EQUAL
64902: ST_TO_ADDR
64903: GO 65077
64905: LD_INT 16
64907: DOUBLE
64908: EQUAL
64909: IFTRUE 64913
64911: GO 64938
64913: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64914: LD_ADDR_VAR 0 3
64918: PUSH
64919: LD_INT 84
64921: PPUSH
64922: LD_VAR 0 1
64926: PPUSH
64927: CALL_OW 321
64931: PUSH
64932: LD_INT 2
64934: EQUAL
64935: ST_TO_ADDR
64936: GO 65077
64938: LD_INT 19
64940: DOUBLE
64941: EQUAL
64942: IFTRUE 64952
64944: LD_INT 23
64946: DOUBLE
64947: EQUAL
64948: IFTRUE 64952
64950: GO 64977
64952: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64953: LD_ADDR_VAR 0 3
64957: PUSH
64958: LD_INT 83
64960: PPUSH
64961: LD_VAR 0 1
64965: PPUSH
64966: CALL_OW 321
64970: PUSH
64971: LD_INT 2
64973: EQUAL
64974: ST_TO_ADDR
64975: GO 65077
64977: LD_INT 17
64979: DOUBLE
64980: EQUAL
64981: IFTRUE 64985
64983: GO 65010
64985: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
64986: LD_ADDR_VAR 0 3
64990: PUSH
64991: LD_INT 39
64993: PPUSH
64994: LD_VAR 0 1
64998: PPUSH
64999: CALL_OW 321
65003: PUSH
65004: LD_INT 2
65006: EQUAL
65007: ST_TO_ADDR
65008: GO 65077
65010: LD_INT 18
65012: DOUBLE
65013: EQUAL
65014: IFTRUE 65018
65016: GO 65043
65018: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65019: LD_ADDR_VAR 0 3
65023: PUSH
65024: LD_INT 40
65026: PPUSH
65027: LD_VAR 0 1
65031: PPUSH
65032: CALL_OW 321
65036: PUSH
65037: LD_INT 2
65039: EQUAL
65040: ST_TO_ADDR
65041: GO 65077
65043: LD_INT 27
65045: DOUBLE
65046: EQUAL
65047: IFTRUE 65051
65049: GO 65076
65051: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65052: LD_ADDR_VAR 0 3
65056: PUSH
65057: LD_INT 35
65059: PPUSH
65060: LD_VAR 0 1
65064: PPUSH
65065: CALL_OW 321
65069: PUSH
65070: LD_INT 2
65072: EQUAL
65073: ST_TO_ADDR
65074: GO 65077
65076: POP
// end ;
65077: LD_VAR 0 3
65081: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65082: LD_INT 0
65084: PPUSH
65085: PPUSH
65086: PPUSH
65087: PPUSH
65088: PPUSH
65089: PPUSH
65090: PPUSH
65091: PPUSH
65092: PPUSH
65093: PPUSH
65094: PPUSH
// result := false ;
65095: LD_ADDR_VAR 0 6
65099: PUSH
65100: LD_INT 0
65102: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65103: LD_VAR 0 1
65107: NOT
65108: PUSH
65109: LD_VAR 0 1
65113: PPUSH
65114: CALL_OW 266
65118: PUSH
65119: LD_INT 0
65121: PUSH
65122: LD_INT 1
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: IN
65129: NOT
65130: OR
65131: PUSH
65132: LD_VAR 0 2
65136: NOT
65137: OR
65138: PUSH
65139: LD_VAR 0 5
65143: PUSH
65144: LD_INT 0
65146: PUSH
65147: LD_INT 1
65149: PUSH
65150: LD_INT 2
65152: PUSH
65153: LD_INT 3
65155: PUSH
65156: LD_INT 4
65158: PUSH
65159: LD_INT 5
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: IN
65170: NOT
65171: OR
65172: PUSH
65173: LD_VAR 0 3
65177: PPUSH
65178: LD_VAR 0 4
65182: PPUSH
65183: CALL_OW 488
65187: NOT
65188: OR
65189: IFFALSE 65193
// exit ;
65191: GO 65929
// side := GetSide ( depot ) ;
65193: LD_ADDR_VAR 0 9
65197: PUSH
65198: LD_VAR 0 1
65202: PPUSH
65203: CALL_OW 255
65207: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65208: LD_VAR 0 9
65212: PPUSH
65213: LD_VAR 0 2
65217: PPUSH
65218: CALL 64706 0 2
65222: NOT
65223: IFFALSE 65227
// exit ;
65225: GO 65929
// pom := GetBase ( depot ) ;
65227: LD_ADDR_VAR 0 10
65231: PUSH
65232: LD_VAR 0 1
65236: PPUSH
65237: CALL_OW 274
65241: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65242: LD_ADDR_VAR 0 11
65246: PUSH
65247: LD_VAR 0 2
65251: PPUSH
65252: LD_VAR 0 1
65256: PPUSH
65257: CALL_OW 248
65261: PPUSH
65262: CALL_OW 450
65266: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65267: LD_VAR 0 10
65271: PPUSH
65272: LD_INT 1
65274: PPUSH
65275: CALL_OW 275
65279: PUSH
65280: LD_VAR 0 11
65284: PUSH
65285: LD_INT 1
65287: ARRAY
65288: GREATEREQUAL
65289: PUSH
65290: LD_VAR 0 10
65294: PPUSH
65295: LD_INT 2
65297: PPUSH
65298: CALL_OW 275
65302: PUSH
65303: LD_VAR 0 11
65307: PUSH
65308: LD_INT 2
65310: ARRAY
65311: GREATEREQUAL
65312: AND
65313: PUSH
65314: LD_VAR 0 10
65318: PPUSH
65319: LD_INT 3
65321: PPUSH
65322: CALL_OW 275
65326: PUSH
65327: LD_VAR 0 11
65331: PUSH
65332: LD_INT 3
65334: ARRAY
65335: GREATEREQUAL
65336: AND
65337: NOT
65338: IFFALSE 65342
// exit ;
65340: GO 65929
// if GetBType ( depot ) = b_depot then
65342: LD_VAR 0 1
65346: PPUSH
65347: CALL_OW 266
65351: PUSH
65352: LD_INT 0
65354: EQUAL
65355: IFFALSE 65367
// dist := 28 else
65357: LD_ADDR_VAR 0 14
65361: PUSH
65362: LD_INT 28
65364: ST_TO_ADDR
65365: GO 65375
// dist := 36 ;
65367: LD_ADDR_VAR 0 14
65371: PUSH
65372: LD_INT 36
65374: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65375: LD_VAR 0 1
65379: PPUSH
65380: LD_VAR 0 3
65384: PPUSH
65385: LD_VAR 0 4
65389: PPUSH
65390: CALL_OW 297
65394: PUSH
65395: LD_VAR 0 14
65399: GREATER
65400: IFFALSE 65404
// exit ;
65402: GO 65929
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65404: LD_ADDR_VAR 0 12
65408: PUSH
65409: LD_VAR 0 2
65413: PPUSH
65414: LD_VAR 0 3
65418: PPUSH
65419: LD_VAR 0 4
65423: PPUSH
65424: LD_VAR 0 5
65428: PPUSH
65429: LD_VAR 0 1
65433: PPUSH
65434: CALL_OW 248
65438: PPUSH
65439: LD_INT 0
65441: PPUSH
65442: CALL 65934 0 6
65446: ST_TO_ADDR
// if not hexes then
65447: LD_VAR 0 12
65451: NOT
65452: IFFALSE 65456
// exit ;
65454: GO 65929
// hex := GetHexInfo ( x , y ) ;
65456: LD_ADDR_VAR 0 15
65460: PUSH
65461: LD_VAR 0 3
65465: PPUSH
65466: LD_VAR 0 4
65470: PPUSH
65471: CALL_OW 546
65475: ST_TO_ADDR
// if hex [ 1 ] then
65476: LD_VAR 0 15
65480: PUSH
65481: LD_INT 1
65483: ARRAY
65484: IFFALSE 65488
// exit ;
65486: GO 65929
// height := hex [ 2 ] ;
65488: LD_ADDR_VAR 0 13
65492: PUSH
65493: LD_VAR 0 15
65497: PUSH
65498: LD_INT 2
65500: ARRAY
65501: ST_TO_ADDR
// for i = 1 to hexes do
65502: LD_ADDR_VAR 0 7
65506: PUSH
65507: DOUBLE
65508: LD_INT 1
65510: DEC
65511: ST_TO_ADDR
65512: LD_VAR 0 12
65516: PUSH
65517: FOR_TO
65518: IFFALSE 65848
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65520: LD_VAR 0 12
65524: PUSH
65525: LD_VAR 0 7
65529: ARRAY
65530: PUSH
65531: LD_INT 1
65533: ARRAY
65534: PPUSH
65535: LD_VAR 0 12
65539: PUSH
65540: LD_VAR 0 7
65544: ARRAY
65545: PUSH
65546: LD_INT 2
65548: ARRAY
65549: PPUSH
65550: CALL_OW 488
65554: NOT
65555: PUSH
65556: LD_VAR 0 12
65560: PUSH
65561: LD_VAR 0 7
65565: ARRAY
65566: PUSH
65567: LD_INT 1
65569: ARRAY
65570: PPUSH
65571: LD_VAR 0 12
65575: PUSH
65576: LD_VAR 0 7
65580: ARRAY
65581: PUSH
65582: LD_INT 2
65584: ARRAY
65585: PPUSH
65586: CALL_OW 428
65590: PUSH
65591: LD_INT 0
65593: GREATER
65594: OR
65595: PUSH
65596: LD_VAR 0 12
65600: PUSH
65601: LD_VAR 0 7
65605: ARRAY
65606: PUSH
65607: LD_INT 1
65609: ARRAY
65610: PPUSH
65611: LD_VAR 0 12
65615: PUSH
65616: LD_VAR 0 7
65620: ARRAY
65621: PUSH
65622: LD_INT 2
65624: ARRAY
65625: PPUSH
65626: CALL_OW 351
65630: OR
65631: IFFALSE 65637
// exit ;
65633: POP
65634: POP
65635: GO 65929
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65637: LD_ADDR_VAR 0 8
65641: PUSH
65642: LD_VAR 0 12
65646: PUSH
65647: LD_VAR 0 7
65651: ARRAY
65652: PUSH
65653: LD_INT 1
65655: ARRAY
65656: PPUSH
65657: LD_VAR 0 12
65661: PUSH
65662: LD_VAR 0 7
65666: ARRAY
65667: PUSH
65668: LD_INT 2
65670: ARRAY
65671: PPUSH
65672: CALL_OW 546
65676: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65677: LD_VAR 0 8
65681: PUSH
65682: LD_INT 1
65684: ARRAY
65685: PUSH
65686: LD_VAR 0 8
65690: PUSH
65691: LD_INT 2
65693: ARRAY
65694: PUSH
65695: LD_VAR 0 13
65699: PUSH
65700: LD_INT 2
65702: PLUS
65703: GREATER
65704: OR
65705: PUSH
65706: LD_VAR 0 8
65710: PUSH
65711: LD_INT 2
65713: ARRAY
65714: PUSH
65715: LD_VAR 0 13
65719: PUSH
65720: LD_INT 2
65722: MINUS
65723: LESS
65724: OR
65725: PUSH
65726: LD_VAR 0 8
65730: PUSH
65731: LD_INT 3
65733: ARRAY
65734: PUSH
65735: LD_INT 0
65737: PUSH
65738: LD_INT 8
65740: PUSH
65741: LD_INT 9
65743: PUSH
65744: LD_INT 10
65746: PUSH
65747: LD_INT 11
65749: PUSH
65750: LD_INT 12
65752: PUSH
65753: LD_INT 13
65755: PUSH
65756: LD_INT 16
65758: PUSH
65759: LD_INT 17
65761: PUSH
65762: LD_INT 18
65764: PUSH
65765: LD_INT 19
65767: PUSH
65768: LD_INT 20
65770: PUSH
65771: LD_INT 21
65773: PUSH
65774: EMPTY
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: LIST
65785: LIST
65786: LIST
65787: LIST
65788: IN
65789: NOT
65790: OR
65791: PUSH
65792: LD_VAR 0 8
65796: PUSH
65797: LD_INT 5
65799: ARRAY
65800: NOT
65801: OR
65802: PUSH
65803: LD_VAR 0 8
65807: PUSH
65808: LD_INT 6
65810: ARRAY
65811: PUSH
65812: LD_INT 1
65814: PUSH
65815: LD_INT 2
65817: PUSH
65818: LD_INT 7
65820: PUSH
65821: LD_INT 9
65823: PUSH
65824: LD_INT 10
65826: PUSH
65827: LD_INT 11
65829: PUSH
65830: EMPTY
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: IN
65838: NOT
65839: OR
65840: IFFALSE 65846
// exit ;
65842: POP
65843: POP
65844: GO 65929
// end ;
65846: GO 65517
65848: POP
65849: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65850: LD_VAR 0 9
65854: PPUSH
65855: LD_VAR 0 3
65859: PPUSH
65860: LD_VAR 0 4
65864: PPUSH
65865: LD_INT 20
65867: PPUSH
65868: CALL 57881 0 4
65872: PUSH
65873: LD_INT 4
65875: ARRAY
65876: IFFALSE 65880
// exit ;
65878: GO 65929
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65880: LD_VAR 0 2
65884: PUSH
65885: LD_INT 29
65887: PUSH
65888: LD_INT 30
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: IN
65895: PUSH
65896: LD_VAR 0 3
65900: PPUSH
65901: LD_VAR 0 4
65905: PPUSH
65906: LD_VAR 0 9
65910: PPUSH
65911: CALL_OW 440
65915: NOT
65916: AND
65917: IFFALSE 65921
// exit ;
65919: GO 65929
// result := true ;
65921: LD_ADDR_VAR 0 6
65925: PUSH
65926: LD_INT 1
65928: ST_TO_ADDR
// end ;
65929: LD_VAR 0 6
65933: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65934: LD_INT 0
65936: PPUSH
65937: PPUSH
65938: PPUSH
65939: PPUSH
65940: PPUSH
65941: PPUSH
65942: PPUSH
65943: PPUSH
65944: PPUSH
65945: PPUSH
65946: PPUSH
65947: PPUSH
65948: PPUSH
65949: PPUSH
65950: PPUSH
65951: PPUSH
65952: PPUSH
65953: PPUSH
65954: PPUSH
65955: PPUSH
65956: PPUSH
65957: PPUSH
65958: PPUSH
65959: PPUSH
65960: PPUSH
65961: PPUSH
65962: PPUSH
65963: PPUSH
65964: PPUSH
65965: PPUSH
65966: PPUSH
65967: PPUSH
65968: PPUSH
65969: PPUSH
65970: PPUSH
65971: PPUSH
65972: PPUSH
65973: PPUSH
65974: PPUSH
65975: PPUSH
65976: PPUSH
65977: PPUSH
65978: PPUSH
65979: PPUSH
65980: PPUSH
65981: PPUSH
65982: PPUSH
65983: PPUSH
65984: PPUSH
65985: PPUSH
65986: PPUSH
65987: PPUSH
65988: PPUSH
65989: PPUSH
65990: PPUSH
65991: PPUSH
65992: PPUSH
65993: PPUSH
// result = [ ] ;
65994: LD_ADDR_VAR 0 7
65998: PUSH
65999: EMPTY
66000: ST_TO_ADDR
// temp_list = [ ] ;
66001: LD_ADDR_VAR 0 9
66005: PUSH
66006: EMPTY
66007: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66008: LD_VAR 0 4
66012: PUSH
66013: LD_INT 0
66015: PUSH
66016: LD_INT 1
66018: PUSH
66019: LD_INT 2
66021: PUSH
66022: LD_INT 3
66024: PUSH
66025: LD_INT 4
66027: PUSH
66028: LD_INT 5
66030: PUSH
66031: EMPTY
66032: LIST
66033: LIST
66034: LIST
66035: LIST
66036: LIST
66037: LIST
66038: IN
66039: NOT
66040: PUSH
66041: LD_VAR 0 1
66045: PUSH
66046: LD_INT 0
66048: PUSH
66049: LD_INT 1
66051: PUSH
66052: EMPTY
66053: LIST
66054: LIST
66055: IN
66056: PUSH
66057: LD_VAR 0 5
66061: PUSH
66062: LD_INT 1
66064: PUSH
66065: LD_INT 2
66067: PUSH
66068: LD_INT 3
66070: PUSH
66071: EMPTY
66072: LIST
66073: LIST
66074: LIST
66075: IN
66076: NOT
66077: AND
66078: OR
66079: IFFALSE 66083
// exit ;
66081: GO 84474
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66083: LD_VAR 0 1
66087: PUSH
66088: LD_INT 6
66090: PUSH
66091: LD_INT 7
66093: PUSH
66094: LD_INT 8
66096: PUSH
66097: LD_INT 13
66099: PUSH
66100: LD_INT 12
66102: PUSH
66103: LD_INT 15
66105: PUSH
66106: LD_INT 11
66108: PUSH
66109: LD_INT 14
66111: PUSH
66112: LD_INT 10
66114: PUSH
66115: EMPTY
66116: LIST
66117: LIST
66118: LIST
66119: LIST
66120: LIST
66121: LIST
66122: LIST
66123: LIST
66124: LIST
66125: IN
66126: IFFALSE 66136
// btype = b_lab ;
66128: LD_ADDR_VAR 0 1
66132: PUSH
66133: LD_INT 6
66135: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66136: LD_VAR 0 6
66140: PUSH
66141: LD_INT 0
66143: PUSH
66144: LD_INT 1
66146: PUSH
66147: LD_INT 2
66149: PUSH
66150: EMPTY
66151: LIST
66152: LIST
66153: LIST
66154: IN
66155: NOT
66156: PUSH
66157: LD_VAR 0 1
66161: PUSH
66162: LD_INT 0
66164: PUSH
66165: LD_INT 1
66167: PUSH
66168: LD_INT 2
66170: PUSH
66171: LD_INT 3
66173: PUSH
66174: LD_INT 6
66176: PUSH
66177: LD_INT 36
66179: PUSH
66180: LD_INT 4
66182: PUSH
66183: LD_INT 5
66185: PUSH
66186: LD_INT 31
66188: PUSH
66189: LD_INT 32
66191: PUSH
66192: LD_INT 33
66194: PUSH
66195: EMPTY
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: IN
66208: NOT
66209: PUSH
66210: LD_VAR 0 6
66214: PUSH
66215: LD_INT 1
66217: EQUAL
66218: AND
66219: OR
66220: PUSH
66221: LD_VAR 0 1
66225: PUSH
66226: LD_INT 2
66228: PUSH
66229: LD_INT 3
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: IN
66236: NOT
66237: PUSH
66238: LD_VAR 0 6
66242: PUSH
66243: LD_INT 2
66245: EQUAL
66246: AND
66247: OR
66248: IFFALSE 66258
// mode = 0 ;
66250: LD_ADDR_VAR 0 6
66254: PUSH
66255: LD_INT 0
66257: ST_TO_ADDR
// case mode of 0 :
66258: LD_VAR 0 6
66262: PUSH
66263: LD_INT 0
66265: DOUBLE
66266: EQUAL
66267: IFTRUE 66271
66269: GO 77724
66271: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66272: LD_ADDR_VAR 0 11
66276: PUSH
66277: LD_INT 0
66279: PUSH
66280: LD_INT 0
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PUSH
66287: LD_INT 0
66289: PUSH
66290: LD_INT 1
66292: NEG
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: PUSH
66298: LD_INT 1
66300: PUSH
66301: LD_INT 0
66303: PUSH
66304: EMPTY
66305: LIST
66306: LIST
66307: PUSH
66308: LD_INT 1
66310: PUSH
66311: LD_INT 1
66313: PUSH
66314: EMPTY
66315: LIST
66316: LIST
66317: PUSH
66318: LD_INT 0
66320: PUSH
66321: LD_INT 1
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PUSH
66328: LD_INT 1
66330: NEG
66331: PUSH
66332: LD_INT 0
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: PUSH
66339: LD_INT 1
66341: NEG
66342: PUSH
66343: LD_INT 1
66345: NEG
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: LD_INT 1
66353: NEG
66354: PUSH
66355: LD_INT 2
66357: NEG
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: PUSH
66363: LD_INT 0
66365: PUSH
66366: LD_INT 2
66368: NEG
66369: PUSH
66370: EMPTY
66371: LIST
66372: LIST
66373: PUSH
66374: LD_INT 1
66376: PUSH
66377: LD_INT 1
66379: NEG
66380: PUSH
66381: EMPTY
66382: LIST
66383: LIST
66384: PUSH
66385: LD_INT 1
66387: PUSH
66388: LD_INT 2
66390: PUSH
66391: EMPTY
66392: LIST
66393: LIST
66394: PUSH
66395: LD_INT 0
66397: PUSH
66398: LD_INT 2
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: LD_INT 1
66407: NEG
66408: PUSH
66409: LD_INT 1
66411: PUSH
66412: EMPTY
66413: LIST
66414: LIST
66415: PUSH
66416: LD_INT 1
66418: PUSH
66419: LD_INT 3
66421: PUSH
66422: EMPTY
66423: LIST
66424: LIST
66425: PUSH
66426: LD_INT 0
66428: PUSH
66429: LD_INT 3
66431: PUSH
66432: EMPTY
66433: LIST
66434: LIST
66435: PUSH
66436: LD_INT 1
66438: NEG
66439: PUSH
66440: LD_INT 2
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PUSH
66447: EMPTY
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: LIST
66462: LIST
66463: LIST
66464: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66465: LD_ADDR_VAR 0 12
66469: PUSH
66470: LD_INT 0
66472: PUSH
66473: LD_INT 0
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: PUSH
66480: LD_INT 0
66482: PUSH
66483: LD_INT 1
66485: NEG
66486: PUSH
66487: EMPTY
66488: LIST
66489: LIST
66490: PUSH
66491: LD_INT 1
66493: PUSH
66494: LD_INT 0
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: LD_INT 1
66503: PUSH
66504: LD_INT 1
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: PUSH
66511: LD_INT 0
66513: PUSH
66514: LD_INT 1
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PUSH
66521: LD_INT 1
66523: NEG
66524: PUSH
66525: LD_INT 0
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 1
66534: NEG
66535: PUSH
66536: LD_INT 1
66538: NEG
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: PUSH
66544: LD_INT 1
66546: PUSH
66547: LD_INT 1
66549: NEG
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: PUSH
66555: LD_INT 2
66557: PUSH
66558: LD_INT 0
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 2
66567: PUSH
66568: LD_INT 1
66570: PUSH
66571: EMPTY
66572: LIST
66573: LIST
66574: PUSH
66575: LD_INT 1
66577: NEG
66578: PUSH
66579: LD_INT 1
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: PUSH
66586: LD_INT 2
66588: NEG
66589: PUSH
66590: LD_INT 0
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 2
66599: NEG
66600: PUSH
66601: LD_INT 1
66603: NEG
66604: PUSH
66605: EMPTY
66606: LIST
66607: LIST
66608: PUSH
66609: LD_INT 2
66611: NEG
66612: PUSH
66613: LD_INT 1
66615: PUSH
66616: EMPTY
66617: LIST
66618: LIST
66619: PUSH
66620: LD_INT 3
66622: NEG
66623: PUSH
66624: LD_INT 0
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: PUSH
66631: LD_INT 3
66633: NEG
66634: PUSH
66635: LD_INT 1
66637: NEG
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66661: LD_ADDR_VAR 0 13
66665: PUSH
66666: LD_INT 0
66668: PUSH
66669: LD_INT 0
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: LD_INT 0
66678: PUSH
66679: LD_INT 1
66681: NEG
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: LD_INT 1
66689: PUSH
66690: LD_INT 0
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 1
66699: PUSH
66700: LD_INT 1
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PUSH
66707: LD_INT 0
66709: PUSH
66710: LD_INT 1
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PUSH
66717: LD_INT 1
66719: NEG
66720: PUSH
66721: LD_INT 0
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 1
66730: NEG
66731: PUSH
66732: LD_INT 1
66734: NEG
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: PUSH
66740: LD_INT 1
66742: NEG
66743: PUSH
66744: LD_INT 2
66746: NEG
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: PUSH
66752: LD_INT 2
66754: PUSH
66755: LD_INT 1
66757: PUSH
66758: EMPTY
66759: LIST
66760: LIST
66761: PUSH
66762: LD_INT 2
66764: PUSH
66765: LD_INT 2
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: LD_INT 1
66774: PUSH
66775: LD_INT 2
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: LD_INT 2
66784: NEG
66785: PUSH
66786: LD_INT 1
66788: NEG
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: PUSH
66794: LD_INT 2
66796: NEG
66797: PUSH
66798: LD_INT 2
66800: NEG
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PUSH
66806: LD_INT 2
66808: NEG
66809: PUSH
66810: LD_INT 3
66812: NEG
66813: PUSH
66814: EMPTY
66815: LIST
66816: LIST
66817: PUSH
66818: LD_INT 3
66820: NEG
66821: PUSH
66822: LD_INT 2
66824: NEG
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 3
66832: NEG
66833: PUSH
66834: LD_INT 3
66836: NEG
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: LIST
66855: LIST
66856: LIST
66857: LIST
66858: LIST
66859: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66860: LD_ADDR_VAR 0 14
66864: PUSH
66865: LD_INT 0
66867: PUSH
66868: LD_INT 0
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 0
66877: PUSH
66878: LD_INT 1
66880: NEG
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: LD_INT 1
66888: PUSH
66889: LD_INT 0
66891: PUSH
66892: EMPTY
66893: LIST
66894: LIST
66895: PUSH
66896: LD_INT 1
66898: PUSH
66899: LD_INT 1
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 0
66908: PUSH
66909: LD_INT 1
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 1
66918: NEG
66919: PUSH
66920: LD_INT 0
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 1
66929: NEG
66930: PUSH
66931: LD_INT 1
66933: NEG
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: LD_INT 1
66941: NEG
66942: PUSH
66943: LD_INT 2
66945: NEG
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: PUSH
66951: LD_INT 0
66953: PUSH
66954: LD_INT 2
66956: NEG
66957: PUSH
66958: EMPTY
66959: LIST
66960: LIST
66961: PUSH
66962: LD_INT 1
66964: PUSH
66965: LD_INT 1
66967: NEG
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 1
66975: PUSH
66976: LD_INT 2
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 0
66985: PUSH
66986: LD_INT 2
66988: PUSH
66989: EMPTY
66990: LIST
66991: LIST
66992: PUSH
66993: LD_INT 1
66995: NEG
66996: PUSH
66997: LD_INT 1
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: PUSH
67004: LD_INT 1
67006: NEG
67007: PUSH
67008: LD_INT 3
67010: NEG
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 0
67018: PUSH
67019: LD_INT 3
67021: NEG
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: LD_INT 1
67029: PUSH
67030: LD_INT 2
67032: NEG
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: PUSH
67038: EMPTY
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: LIST
67052: LIST
67053: LIST
67054: LIST
67055: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67056: LD_ADDR_VAR 0 15
67060: PUSH
67061: LD_INT 0
67063: PUSH
67064: LD_INT 0
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: LD_INT 0
67073: PUSH
67074: LD_INT 1
67076: NEG
67077: PUSH
67078: EMPTY
67079: LIST
67080: LIST
67081: PUSH
67082: LD_INT 1
67084: PUSH
67085: LD_INT 0
67087: PUSH
67088: EMPTY
67089: LIST
67090: LIST
67091: PUSH
67092: LD_INT 1
67094: PUSH
67095: LD_INT 1
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: PUSH
67102: LD_INT 0
67104: PUSH
67105: LD_INT 1
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PUSH
67112: LD_INT 1
67114: NEG
67115: PUSH
67116: LD_INT 0
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: LD_INT 1
67125: NEG
67126: PUSH
67127: LD_INT 1
67129: NEG
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 1
67137: PUSH
67138: LD_INT 1
67140: NEG
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: LD_INT 2
67148: PUSH
67149: LD_INT 0
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 2
67158: PUSH
67159: LD_INT 1
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 1
67168: NEG
67169: PUSH
67170: LD_INT 1
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 2
67179: NEG
67180: PUSH
67181: LD_INT 0
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: LD_INT 2
67190: NEG
67191: PUSH
67192: LD_INT 1
67194: NEG
67195: PUSH
67196: EMPTY
67197: LIST
67198: LIST
67199: PUSH
67200: LD_INT 2
67202: PUSH
67203: LD_INT 1
67205: NEG
67206: PUSH
67207: EMPTY
67208: LIST
67209: LIST
67210: PUSH
67211: LD_INT 3
67213: PUSH
67214: LD_INT 0
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 3
67223: PUSH
67224: LD_INT 1
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: PUSH
67231: EMPTY
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67249: LD_ADDR_VAR 0 16
67253: PUSH
67254: LD_INT 0
67256: PUSH
67257: LD_INT 0
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: LD_INT 0
67266: PUSH
67267: LD_INT 1
67269: NEG
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: LD_INT 1
67277: PUSH
67278: LD_INT 0
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: LD_INT 1
67287: PUSH
67288: LD_INT 1
67290: PUSH
67291: EMPTY
67292: LIST
67293: LIST
67294: PUSH
67295: LD_INT 0
67297: PUSH
67298: LD_INT 1
67300: PUSH
67301: EMPTY
67302: LIST
67303: LIST
67304: PUSH
67305: LD_INT 1
67307: NEG
67308: PUSH
67309: LD_INT 0
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 1
67318: NEG
67319: PUSH
67320: LD_INT 1
67322: NEG
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 1
67330: NEG
67331: PUSH
67332: LD_INT 2
67334: NEG
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 2
67342: PUSH
67343: LD_INT 1
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 2
67352: PUSH
67353: LD_INT 2
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 1
67362: PUSH
67363: LD_INT 2
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 2
67372: NEG
67373: PUSH
67374: LD_INT 1
67376: NEG
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: LD_INT 2
67384: NEG
67385: PUSH
67386: LD_INT 2
67388: NEG
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: LD_INT 3
67396: PUSH
67397: LD_INT 2
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: LD_INT 3
67406: PUSH
67407: LD_INT 3
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: LD_INT 2
67416: PUSH
67417: LD_INT 3
67419: PUSH
67420: EMPTY
67421: LIST
67422: LIST
67423: PUSH
67424: EMPTY
67425: LIST
67426: LIST
67427: LIST
67428: LIST
67429: LIST
67430: LIST
67431: LIST
67432: LIST
67433: LIST
67434: LIST
67435: LIST
67436: LIST
67437: LIST
67438: LIST
67439: LIST
67440: LIST
67441: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67442: LD_ADDR_VAR 0 17
67446: PUSH
67447: LD_INT 0
67449: PUSH
67450: LD_INT 0
67452: PUSH
67453: EMPTY
67454: LIST
67455: LIST
67456: PUSH
67457: LD_INT 0
67459: PUSH
67460: LD_INT 1
67462: NEG
67463: PUSH
67464: EMPTY
67465: LIST
67466: LIST
67467: PUSH
67468: LD_INT 1
67470: PUSH
67471: LD_INT 0
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: PUSH
67478: LD_INT 1
67480: PUSH
67481: LD_INT 1
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 0
67490: PUSH
67491: LD_INT 1
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 1
67500: NEG
67501: PUSH
67502: LD_INT 0
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: PUSH
67509: LD_INT 1
67511: NEG
67512: PUSH
67513: LD_INT 1
67515: NEG
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: LD_INT 1
67523: NEG
67524: PUSH
67525: LD_INT 2
67527: NEG
67528: PUSH
67529: EMPTY
67530: LIST
67531: LIST
67532: PUSH
67533: LD_INT 0
67535: PUSH
67536: LD_INT 2
67538: NEG
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 1
67546: PUSH
67547: LD_INT 1
67549: NEG
67550: PUSH
67551: EMPTY
67552: LIST
67553: LIST
67554: PUSH
67555: LD_INT 2
67557: PUSH
67558: LD_INT 0
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 2
67567: PUSH
67568: LD_INT 1
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 2
67577: PUSH
67578: LD_INT 2
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 1
67587: PUSH
67588: LD_INT 2
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 0
67597: PUSH
67598: LD_INT 2
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 1
67607: NEG
67608: PUSH
67609: LD_INT 1
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PUSH
67616: LD_INT 2
67618: NEG
67619: PUSH
67620: LD_INT 0
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: PUSH
67627: LD_INT 2
67629: NEG
67630: PUSH
67631: LD_INT 1
67633: NEG
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: PUSH
67639: LD_INT 2
67641: NEG
67642: PUSH
67643: LD_INT 2
67645: NEG
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: LIST
67658: LIST
67659: LIST
67660: LIST
67661: LIST
67662: LIST
67663: LIST
67664: LIST
67665: LIST
67666: LIST
67667: LIST
67668: LIST
67669: LIST
67670: LIST
67671: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67672: LD_ADDR_VAR 0 18
67676: PUSH
67677: LD_INT 0
67679: PUSH
67680: LD_INT 0
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PUSH
67687: LD_INT 0
67689: PUSH
67690: LD_INT 1
67692: NEG
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: LD_INT 1
67700: PUSH
67701: LD_INT 0
67703: PUSH
67704: EMPTY
67705: LIST
67706: LIST
67707: PUSH
67708: LD_INT 1
67710: PUSH
67711: LD_INT 1
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 0
67720: PUSH
67721: LD_INT 1
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 1
67730: NEG
67731: PUSH
67732: LD_INT 0
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 1
67741: NEG
67742: PUSH
67743: LD_INT 1
67745: NEG
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 1
67753: NEG
67754: PUSH
67755: LD_INT 2
67757: NEG
67758: PUSH
67759: EMPTY
67760: LIST
67761: LIST
67762: PUSH
67763: LD_INT 0
67765: PUSH
67766: LD_INT 2
67768: NEG
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 1
67776: PUSH
67777: LD_INT 1
67779: NEG
67780: PUSH
67781: EMPTY
67782: LIST
67783: LIST
67784: PUSH
67785: LD_INT 2
67787: PUSH
67788: LD_INT 0
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: PUSH
67795: LD_INT 2
67797: PUSH
67798: LD_INT 1
67800: PUSH
67801: EMPTY
67802: LIST
67803: LIST
67804: PUSH
67805: LD_INT 2
67807: PUSH
67808: LD_INT 2
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PUSH
67815: LD_INT 1
67817: PUSH
67818: LD_INT 2
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 0
67827: PUSH
67828: LD_INT 2
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: LD_INT 1
67837: NEG
67838: PUSH
67839: LD_INT 1
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PUSH
67846: LD_INT 2
67848: NEG
67849: PUSH
67850: LD_INT 0
67852: PUSH
67853: EMPTY
67854: LIST
67855: LIST
67856: PUSH
67857: LD_INT 2
67859: NEG
67860: PUSH
67861: LD_INT 1
67863: NEG
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 2
67871: NEG
67872: PUSH
67873: LD_INT 2
67875: NEG
67876: PUSH
67877: EMPTY
67878: LIST
67879: LIST
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: LIST
67885: LIST
67886: LIST
67887: LIST
67888: LIST
67889: LIST
67890: LIST
67891: LIST
67892: LIST
67893: LIST
67894: LIST
67895: LIST
67896: LIST
67897: LIST
67898: LIST
67899: LIST
67900: LIST
67901: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67902: LD_ADDR_VAR 0 19
67906: PUSH
67907: LD_INT 0
67909: PUSH
67910: LD_INT 0
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: PUSH
67917: LD_INT 0
67919: PUSH
67920: LD_INT 1
67922: NEG
67923: PUSH
67924: EMPTY
67925: LIST
67926: LIST
67927: PUSH
67928: LD_INT 1
67930: PUSH
67931: LD_INT 0
67933: PUSH
67934: EMPTY
67935: LIST
67936: LIST
67937: PUSH
67938: LD_INT 1
67940: PUSH
67941: LD_INT 1
67943: PUSH
67944: EMPTY
67945: LIST
67946: LIST
67947: PUSH
67948: LD_INT 0
67950: PUSH
67951: LD_INT 1
67953: PUSH
67954: EMPTY
67955: LIST
67956: LIST
67957: PUSH
67958: LD_INT 1
67960: NEG
67961: PUSH
67962: LD_INT 0
67964: PUSH
67965: EMPTY
67966: LIST
67967: LIST
67968: PUSH
67969: LD_INT 1
67971: NEG
67972: PUSH
67973: LD_INT 1
67975: NEG
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 1
67983: NEG
67984: PUSH
67985: LD_INT 2
67987: NEG
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 0
67995: PUSH
67996: LD_INT 2
67998: NEG
67999: PUSH
68000: EMPTY
68001: LIST
68002: LIST
68003: PUSH
68004: LD_INT 1
68006: PUSH
68007: LD_INT 1
68009: NEG
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: LD_INT 2
68017: PUSH
68018: LD_INT 0
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: LD_INT 2
68027: PUSH
68028: LD_INT 1
68030: PUSH
68031: EMPTY
68032: LIST
68033: LIST
68034: PUSH
68035: LD_INT 2
68037: PUSH
68038: LD_INT 2
68040: PUSH
68041: EMPTY
68042: LIST
68043: LIST
68044: PUSH
68045: LD_INT 1
68047: PUSH
68048: LD_INT 2
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: PUSH
68055: LD_INT 0
68057: PUSH
68058: LD_INT 2
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: PUSH
68065: LD_INT 1
68067: NEG
68068: PUSH
68069: LD_INT 1
68071: PUSH
68072: EMPTY
68073: LIST
68074: LIST
68075: PUSH
68076: LD_INT 2
68078: NEG
68079: PUSH
68080: LD_INT 0
68082: PUSH
68083: EMPTY
68084: LIST
68085: LIST
68086: PUSH
68087: LD_INT 2
68089: NEG
68090: PUSH
68091: LD_INT 1
68093: NEG
68094: PUSH
68095: EMPTY
68096: LIST
68097: LIST
68098: PUSH
68099: LD_INT 2
68101: NEG
68102: PUSH
68103: LD_INT 2
68105: NEG
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: PUSH
68111: EMPTY
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: LIST
68129: LIST
68130: LIST
68131: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68132: LD_ADDR_VAR 0 20
68136: PUSH
68137: LD_INT 0
68139: PUSH
68140: LD_INT 0
68142: PUSH
68143: EMPTY
68144: LIST
68145: LIST
68146: PUSH
68147: LD_INT 0
68149: PUSH
68150: LD_INT 1
68152: NEG
68153: PUSH
68154: EMPTY
68155: LIST
68156: LIST
68157: PUSH
68158: LD_INT 1
68160: PUSH
68161: LD_INT 0
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: PUSH
68168: LD_INT 1
68170: PUSH
68171: LD_INT 1
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PUSH
68178: LD_INT 0
68180: PUSH
68181: LD_INT 1
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PUSH
68188: LD_INT 1
68190: NEG
68191: PUSH
68192: LD_INT 0
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: PUSH
68199: LD_INT 1
68201: NEG
68202: PUSH
68203: LD_INT 1
68205: NEG
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 1
68213: NEG
68214: PUSH
68215: LD_INT 2
68217: NEG
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: LD_INT 0
68225: PUSH
68226: LD_INT 2
68228: NEG
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 1
68236: PUSH
68237: LD_INT 1
68239: NEG
68240: PUSH
68241: EMPTY
68242: LIST
68243: LIST
68244: PUSH
68245: LD_INT 2
68247: PUSH
68248: LD_INT 0
68250: PUSH
68251: EMPTY
68252: LIST
68253: LIST
68254: PUSH
68255: LD_INT 2
68257: PUSH
68258: LD_INT 1
68260: PUSH
68261: EMPTY
68262: LIST
68263: LIST
68264: PUSH
68265: LD_INT 2
68267: PUSH
68268: LD_INT 2
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: PUSH
68275: LD_INT 1
68277: PUSH
68278: LD_INT 2
68280: PUSH
68281: EMPTY
68282: LIST
68283: LIST
68284: PUSH
68285: LD_INT 0
68287: PUSH
68288: LD_INT 2
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 1
68297: NEG
68298: PUSH
68299: LD_INT 1
68301: PUSH
68302: EMPTY
68303: LIST
68304: LIST
68305: PUSH
68306: LD_INT 2
68308: NEG
68309: PUSH
68310: LD_INT 0
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: PUSH
68317: LD_INT 2
68319: NEG
68320: PUSH
68321: LD_INT 1
68323: NEG
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: PUSH
68329: LD_INT 2
68331: NEG
68332: PUSH
68333: LD_INT 2
68335: NEG
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: LIST
68353: LIST
68354: LIST
68355: LIST
68356: LIST
68357: LIST
68358: LIST
68359: LIST
68360: LIST
68361: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68362: LD_ADDR_VAR 0 21
68366: PUSH
68367: LD_INT 0
68369: PUSH
68370: LD_INT 0
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 0
68379: PUSH
68380: LD_INT 1
68382: NEG
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 1
68390: PUSH
68391: LD_INT 0
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 1
68400: PUSH
68401: LD_INT 1
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: LD_INT 0
68410: PUSH
68411: LD_INT 1
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: LD_INT 1
68420: NEG
68421: PUSH
68422: LD_INT 0
68424: PUSH
68425: EMPTY
68426: LIST
68427: LIST
68428: PUSH
68429: LD_INT 1
68431: NEG
68432: PUSH
68433: LD_INT 1
68435: NEG
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: PUSH
68441: LD_INT 1
68443: NEG
68444: PUSH
68445: LD_INT 2
68447: NEG
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 0
68455: PUSH
68456: LD_INT 2
68458: NEG
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 1
68466: PUSH
68467: LD_INT 1
68469: NEG
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: PUSH
68475: LD_INT 2
68477: PUSH
68478: LD_INT 0
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: PUSH
68485: LD_INT 2
68487: PUSH
68488: LD_INT 1
68490: PUSH
68491: EMPTY
68492: LIST
68493: LIST
68494: PUSH
68495: LD_INT 2
68497: PUSH
68498: LD_INT 2
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: PUSH
68505: LD_INT 1
68507: PUSH
68508: LD_INT 2
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: LD_INT 0
68517: PUSH
68518: LD_INT 2
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 1
68527: NEG
68528: PUSH
68529: LD_INT 1
68531: PUSH
68532: EMPTY
68533: LIST
68534: LIST
68535: PUSH
68536: LD_INT 2
68538: NEG
68539: PUSH
68540: LD_INT 0
68542: PUSH
68543: EMPTY
68544: LIST
68545: LIST
68546: PUSH
68547: LD_INT 2
68549: NEG
68550: PUSH
68551: LD_INT 1
68553: NEG
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: LD_INT 2
68561: NEG
68562: PUSH
68563: LD_INT 2
68565: NEG
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: LIST
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: LIST
68589: LIST
68590: LIST
68591: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68592: LD_ADDR_VAR 0 22
68596: PUSH
68597: LD_INT 0
68599: PUSH
68600: LD_INT 0
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 0
68609: PUSH
68610: LD_INT 1
68612: NEG
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: PUSH
68618: LD_INT 1
68620: PUSH
68621: LD_INT 0
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: LD_INT 1
68630: PUSH
68631: LD_INT 1
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PUSH
68638: LD_INT 0
68640: PUSH
68641: LD_INT 1
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 1
68650: NEG
68651: PUSH
68652: LD_INT 0
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: PUSH
68659: LD_INT 1
68661: NEG
68662: PUSH
68663: LD_INT 1
68665: NEG
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 1
68673: NEG
68674: PUSH
68675: LD_INT 2
68677: NEG
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: PUSH
68683: LD_INT 0
68685: PUSH
68686: LD_INT 2
68688: NEG
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: LD_INT 1
68696: PUSH
68697: LD_INT 1
68699: NEG
68700: PUSH
68701: EMPTY
68702: LIST
68703: LIST
68704: PUSH
68705: LD_INT 2
68707: PUSH
68708: LD_INT 0
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 2
68717: PUSH
68718: LD_INT 1
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 2
68727: PUSH
68728: LD_INT 2
68730: PUSH
68731: EMPTY
68732: LIST
68733: LIST
68734: PUSH
68735: LD_INT 1
68737: PUSH
68738: LD_INT 2
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 0
68747: PUSH
68748: LD_INT 2
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PUSH
68755: LD_INT 1
68757: NEG
68758: PUSH
68759: LD_INT 1
68761: PUSH
68762: EMPTY
68763: LIST
68764: LIST
68765: PUSH
68766: LD_INT 2
68768: NEG
68769: PUSH
68770: LD_INT 0
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 2
68779: NEG
68780: PUSH
68781: LD_INT 1
68783: NEG
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: PUSH
68789: LD_INT 2
68791: NEG
68792: PUSH
68793: LD_INT 2
68795: NEG
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: LIST
68805: LIST
68806: LIST
68807: LIST
68808: LIST
68809: LIST
68810: LIST
68811: LIST
68812: LIST
68813: LIST
68814: LIST
68815: LIST
68816: LIST
68817: LIST
68818: LIST
68819: LIST
68820: LIST
68821: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68822: LD_ADDR_VAR 0 23
68826: PUSH
68827: LD_INT 0
68829: PUSH
68830: LD_INT 0
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 0
68839: PUSH
68840: LD_INT 1
68842: NEG
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: LD_INT 1
68850: PUSH
68851: LD_INT 0
68853: PUSH
68854: EMPTY
68855: LIST
68856: LIST
68857: PUSH
68858: LD_INT 1
68860: PUSH
68861: LD_INT 1
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: PUSH
68868: LD_INT 0
68870: PUSH
68871: LD_INT 1
68873: PUSH
68874: EMPTY
68875: LIST
68876: LIST
68877: PUSH
68878: LD_INT 1
68880: NEG
68881: PUSH
68882: LD_INT 0
68884: PUSH
68885: EMPTY
68886: LIST
68887: LIST
68888: PUSH
68889: LD_INT 1
68891: NEG
68892: PUSH
68893: LD_INT 1
68895: NEG
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 1
68903: NEG
68904: PUSH
68905: LD_INT 2
68907: NEG
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: LD_INT 0
68915: PUSH
68916: LD_INT 2
68918: NEG
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 1
68926: PUSH
68927: LD_INT 1
68929: NEG
68930: PUSH
68931: EMPTY
68932: LIST
68933: LIST
68934: PUSH
68935: LD_INT 2
68937: PUSH
68938: LD_INT 0
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PUSH
68945: LD_INT 2
68947: PUSH
68948: LD_INT 1
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 2
68957: PUSH
68958: LD_INT 2
68960: PUSH
68961: EMPTY
68962: LIST
68963: LIST
68964: PUSH
68965: LD_INT 1
68967: PUSH
68968: LD_INT 2
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 0
68977: PUSH
68978: LD_INT 2
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: PUSH
68985: LD_INT 1
68987: NEG
68988: PUSH
68989: LD_INT 1
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: PUSH
68996: LD_INT 2
68998: NEG
68999: PUSH
69000: LD_INT 0
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 2
69009: NEG
69010: PUSH
69011: LD_INT 1
69013: NEG
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: LD_INT 2
69021: NEG
69022: PUSH
69023: LD_INT 2
69025: NEG
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: PUSH
69031: LD_INT 2
69033: NEG
69034: PUSH
69035: LD_INT 3
69037: NEG
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: PUSH
69043: LD_INT 1
69045: NEG
69046: PUSH
69047: LD_INT 3
69049: NEG
69050: PUSH
69051: EMPTY
69052: LIST
69053: LIST
69054: PUSH
69055: LD_INT 1
69057: PUSH
69058: LD_INT 2
69060: NEG
69061: PUSH
69062: EMPTY
69063: LIST
69064: LIST
69065: PUSH
69066: LD_INT 2
69068: PUSH
69069: LD_INT 1
69071: NEG
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: LIST
69096: LIST
69097: LIST
69098: LIST
69099: LIST
69100: LIST
69101: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69102: LD_ADDR_VAR 0 24
69106: PUSH
69107: LD_INT 0
69109: PUSH
69110: LD_INT 0
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: LD_INT 0
69119: PUSH
69120: LD_INT 1
69122: NEG
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 1
69130: PUSH
69131: LD_INT 0
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 1
69140: PUSH
69141: LD_INT 1
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 0
69150: PUSH
69151: LD_INT 1
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 1
69160: NEG
69161: PUSH
69162: LD_INT 0
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 1
69171: NEG
69172: PUSH
69173: LD_INT 1
69175: NEG
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 1
69183: NEG
69184: PUSH
69185: LD_INT 2
69187: NEG
69188: PUSH
69189: EMPTY
69190: LIST
69191: LIST
69192: PUSH
69193: LD_INT 0
69195: PUSH
69196: LD_INT 2
69198: NEG
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 1
69206: PUSH
69207: LD_INT 1
69209: NEG
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 2
69217: PUSH
69218: LD_INT 0
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: LD_INT 2
69227: PUSH
69228: LD_INT 1
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: PUSH
69235: LD_INT 2
69237: PUSH
69238: LD_INT 2
69240: PUSH
69241: EMPTY
69242: LIST
69243: LIST
69244: PUSH
69245: LD_INT 1
69247: PUSH
69248: LD_INT 2
69250: PUSH
69251: EMPTY
69252: LIST
69253: LIST
69254: PUSH
69255: LD_INT 0
69257: PUSH
69258: LD_INT 2
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 1
69267: NEG
69268: PUSH
69269: LD_INT 1
69271: PUSH
69272: EMPTY
69273: LIST
69274: LIST
69275: PUSH
69276: LD_INT 2
69278: NEG
69279: PUSH
69280: LD_INT 0
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PUSH
69287: LD_INT 2
69289: NEG
69290: PUSH
69291: LD_INT 1
69293: NEG
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 2
69301: NEG
69302: PUSH
69303: LD_INT 2
69305: NEG
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 1
69313: PUSH
69314: LD_INT 2
69316: NEG
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 2
69324: PUSH
69325: LD_INT 1
69327: NEG
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: LD_INT 3
69335: PUSH
69336: LD_INT 1
69338: PUSH
69339: EMPTY
69340: LIST
69341: LIST
69342: PUSH
69343: LD_INT 3
69345: PUSH
69346: LD_INT 2
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: LIST
69367: LIST
69368: LIST
69369: LIST
69370: LIST
69371: LIST
69372: LIST
69373: LIST
69374: LIST
69375: LIST
69376: LIST
69377: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69378: LD_ADDR_VAR 0 25
69382: PUSH
69383: LD_INT 0
69385: PUSH
69386: LD_INT 0
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 0
69395: PUSH
69396: LD_INT 1
69398: NEG
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 1
69406: PUSH
69407: LD_INT 0
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 1
69416: PUSH
69417: LD_INT 1
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: LD_INT 0
69426: PUSH
69427: LD_INT 1
69429: PUSH
69430: EMPTY
69431: LIST
69432: LIST
69433: PUSH
69434: LD_INT 1
69436: NEG
69437: PUSH
69438: LD_INT 0
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: PUSH
69445: LD_INT 1
69447: NEG
69448: PUSH
69449: LD_INT 1
69451: NEG
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 1
69459: NEG
69460: PUSH
69461: LD_INT 2
69463: NEG
69464: PUSH
69465: EMPTY
69466: LIST
69467: LIST
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: LD_INT 2
69474: NEG
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: LD_INT 1
69482: PUSH
69483: LD_INT 1
69485: NEG
69486: PUSH
69487: EMPTY
69488: LIST
69489: LIST
69490: PUSH
69491: LD_INT 2
69493: PUSH
69494: LD_INT 0
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 2
69503: PUSH
69504: LD_INT 1
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PUSH
69511: LD_INT 2
69513: PUSH
69514: LD_INT 2
69516: PUSH
69517: EMPTY
69518: LIST
69519: LIST
69520: PUSH
69521: LD_INT 1
69523: PUSH
69524: LD_INT 2
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 0
69533: PUSH
69534: LD_INT 2
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 1
69543: NEG
69544: PUSH
69545: LD_INT 1
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 2
69554: NEG
69555: PUSH
69556: LD_INT 0
69558: PUSH
69559: EMPTY
69560: LIST
69561: LIST
69562: PUSH
69563: LD_INT 2
69565: NEG
69566: PUSH
69567: LD_INT 1
69569: NEG
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 2
69577: NEG
69578: PUSH
69579: LD_INT 2
69581: NEG
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 3
69589: PUSH
69590: LD_INT 1
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 3
69599: PUSH
69600: LD_INT 2
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 2
69609: PUSH
69610: LD_INT 3
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: LD_INT 1
69619: PUSH
69620: LD_INT 3
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: LIST
69647: LIST
69648: LIST
69649: LIST
69650: LIST
69651: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69652: LD_ADDR_VAR 0 26
69656: PUSH
69657: LD_INT 0
69659: PUSH
69660: LD_INT 0
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 0
69669: PUSH
69670: LD_INT 1
69672: NEG
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: PUSH
69678: LD_INT 1
69680: PUSH
69681: LD_INT 0
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: PUSH
69688: LD_INT 1
69690: PUSH
69691: LD_INT 1
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: LD_INT 0
69700: PUSH
69701: LD_INT 1
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PUSH
69708: LD_INT 1
69710: NEG
69711: PUSH
69712: LD_INT 0
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 1
69721: NEG
69722: PUSH
69723: LD_INT 1
69725: NEG
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 1
69733: NEG
69734: PUSH
69735: LD_INT 2
69737: NEG
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: PUSH
69743: LD_INT 0
69745: PUSH
69746: LD_INT 2
69748: NEG
69749: PUSH
69750: EMPTY
69751: LIST
69752: LIST
69753: PUSH
69754: LD_INT 1
69756: PUSH
69757: LD_INT 1
69759: NEG
69760: PUSH
69761: EMPTY
69762: LIST
69763: LIST
69764: PUSH
69765: LD_INT 2
69767: PUSH
69768: LD_INT 0
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: PUSH
69775: LD_INT 2
69777: PUSH
69778: LD_INT 1
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: PUSH
69785: LD_INT 2
69787: PUSH
69788: LD_INT 2
69790: PUSH
69791: EMPTY
69792: LIST
69793: LIST
69794: PUSH
69795: LD_INT 1
69797: PUSH
69798: LD_INT 2
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PUSH
69805: LD_INT 0
69807: PUSH
69808: LD_INT 2
69810: PUSH
69811: EMPTY
69812: LIST
69813: LIST
69814: PUSH
69815: LD_INT 1
69817: NEG
69818: PUSH
69819: LD_INT 1
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: PUSH
69826: LD_INT 2
69828: NEG
69829: PUSH
69830: LD_INT 0
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: PUSH
69837: LD_INT 2
69839: NEG
69840: PUSH
69841: LD_INT 1
69843: NEG
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: LD_INT 2
69851: NEG
69852: PUSH
69853: LD_INT 2
69855: NEG
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 2
69863: PUSH
69864: LD_INT 3
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 1
69873: PUSH
69874: LD_INT 3
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: LD_INT 1
69883: NEG
69884: PUSH
69885: LD_INT 2
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: PUSH
69892: LD_INT 2
69894: NEG
69895: PUSH
69896: LD_INT 1
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: LIST
69907: LIST
69908: LIST
69909: LIST
69910: LIST
69911: LIST
69912: LIST
69913: LIST
69914: LIST
69915: LIST
69916: LIST
69917: LIST
69918: LIST
69919: LIST
69920: LIST
69921: LIST
69922: LIST
69923: LIST
69924: LIST
69925: LIST
69926: LIST
69927: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69928: LD_ADDR_VAR 0 27
69932: PUSH
69933: LD_INT 0
69935: PUSH
69936: LD_INT 0
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 0
69945: PUSH
69946: LD_INT 1
69948: NEG
69949: PUSH
69950: EMPTY
69951: LIST
69952: LIST
69953: PUSH
69954: LD_INT 1
69956: PUSH
69957: LD_INT 0
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: LD_INT 1
69966: PUSH
69967: LD_INT 1
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: PUSH
69974: LD_INT 0
69976: PUSH
69977: LD_INT 1
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: LD_INT 1
69986: NEG
69987: PUSH
69988: LD_INT 0
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: PUSH
69995: LD_INT 1
69997: NEG
69998: PUSH
69999: LD_INT 1
70001: NEG
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: LD_INT 1
70009: NEG
70010: PUSH
70011: LD_INT 2
70013: NEG
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: PUSH
70019: LD_INT 0
70021: PUSH
70022: LD_INT 2
70024: NEG
70025: PUSH
70026: EMPTY
70027: LIST
70028: LIST
70029: PUSH
70030: LD_INT 1
70032: PUSH
70033: LD_INT 1
70035: NEG
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: PUSH
70041: LD_INT 2
70043: PUSH
70044: LD_INT 0
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 2
70053: PUSH
70054: LD_INT 1
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: LD_INT 2
70063: PUSH
70064: LD_INT 2
70066: PUSH
70067: EMPTY
70068: LIST
70069: LIST
70070: PUSH
70071: LD_INT 1
70073: PUSH
70074: LD_INT 2
70076: PUSH
70077: EMPTY
70078: LIST
70079: LIST
70080: PUSH
70081: LD_INT 0
70083: PUSH
70084: LD_INT 2
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 1
70093: NEG
70094: PUSH
70095: LD_INT 1
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: PUSH
70102: LD_INT 2
70104: NEG
70105: PUSH
70106: LD_INT 0
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 2
70115: NEG
70116: PUSH
70117: LD_INT 1
70119: NEG
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 2
70127: NEG
70128: PUSH
70129: LD_INT 2
70131: NEG
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 1
70139: NEG
70140: PUSH
70141: LD_INT 2
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 2
70150: NEG
70151: PUSH
70152: LD_INT 1
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 3
70161: NEG
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 3
70173: NEG
70174: PUSH
70175: LD_INT 2
70177: NEG
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70208: LD_ADDR_VAR 0 28
70212: PUSH
70213: LD_INT 0
70215: PUSH
70216: LD_INT 0
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: LD_INT 0
70225: PUSH
70226: LD_INT 1
70228: NEG
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 1
70236: PUSH
70237: LD_INT 0
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 1
70246: PUSH
70247: LD_INT 1
70249: PUSH
70250: EMPTY
70251: LIST
70252: LIST
70253: PUSH
70254: LD_INT 0
70256: PUSH
70257: LD_INT 1
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 1
70266: NEG
70267: PUSH
70268: LD_INT 0
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PUSH
70279: LD_INT 1
70281: NEG
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 1
70289: NEG
70290: PUSH
70291: LD_INT 2
70293: NEG
70294: PUSH
70295: EMPTY
70296: LIST
70297: LIST
70298: PUSH
70299: LD_INT 0
70301: PUSH
70302: LD_INT 2
70304: NEG
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 1
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: PUSH
70321: LD_INT 2
70323: PUSH
70324: LD_INT 0
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: PUSH
70331: LD_INT 2
70333: PUSH
70334: LD_INT 1
70336: PUSH
70337: EMPTY
70338: LIST
70339: LIST
70340: PUSH
70341: LD_INT 2
70343: PUSH
70344: LD_INT 2
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: PUSH
70351: LD_INT 1
70353: PUSH
70354: LD_INT 2
70356: PUSH
70357: EMPTY
70358: LIST
70359: LIST
70360: PUSH
70361: LD_INT 0
70363: PUSH
70364: LD_INT 2
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: LD_INT 1
70373: NEG
70374: PUSH
70375: LD_INT 1
70377: PUSH
70378: EMPTY
70379: LIST
70380: LIST
70381: PUSH
70382: LD_INT 2
70384: NEG
70385: PUSH
70386: LD_INT 0
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: PUSH
70393: LD_INT 2
70395: NEG
70396: PUSH
70397: LD_INT 1
70399: NEG
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 2
70407: NEG
70408: PUSH
70409: LD_INT 2
70411: NEG
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 2
70419: NEG
70420: PUSH
70421: LD_INT 3
70423: NEG
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 1
70431: NEG
70432: PUSH
70433: LD_INT 3
70435: NEG
70436: PUSH
70437: EMPTY
70438: LIST
70439: LIST
70440: PUSH
70441: LD_INT 3
70443: NEG
70444: PUSH
70445: LD_INT 1
70447: NEG
70448: PUSH
70449: EMPTY
70450: LIST
70451: LIST
70452: PUSH
70453: LD_INT 3
70455: NEG
70456: PUSH
70457: LD_INT 2
70459: NEG
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: LIST
70481: LIST
70482: LIST
70483: LIST
70484: LIST
70485: LIST
70486: LIST
70487: LIST
70488: LIST
70489: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70490: LD_ADDR_VAR 0 29
70494: PUSH
70495: LD_INT 0
70497: PUSH
70498: LD_INT 0
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PUSH
70505: LD_INT 0
70507: PUSH
70508: LD_INT 1
70510: NEG
70511: PUSH
70512: EMPTY
70513: LIST
70514: LIST
70515: PUSH
70516: LD_INT 1
70518: PUSH
70519: LD_INT 0
70521: PUSH
70522: EMPTY
70523: LIST
70524: LIST
70525: PUSH
70526: LD_INT 1
70528: PUSH
70529: LD_INT 1
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: PUSH
70536: LD_INT 0
70538: PUSH
70539: LD_INT 1
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 1
70548: NEG
70549: PUSH
70550: LD_INT 0
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: PUSH
70557: LD_INT 1
70559: NEG
70560: PUSH
70561: LD_INT 1
70563: NEG
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 1
70571: NEG
70572: PUSH
70573: LD_INT 2
70575: NEG
70576: PUSH
70577: EMPTY
70578: LIST
70579: LIST
70580: PUSH
70581: LD_INT 0
70583: PUSH
70584: LD_INT 2
70586: NEG
70587: PUSH
70588: EMPTY
70589: LIST
70590: LIST
70591: PUSH
70592: LD_INT 1
70594: PUSH
70595: LD_INT 1
70597: NEG
70598: PUSH
70599: EMPTY
70600: LIST
70601: LIST
70602: PUSH
70603: LD_INT 2
70605: PUSH
70606: LD_INT 0
70608: PUSH
70609: EMPTY
70610: LIST
70611: LIST
70612: PUSH
70613: LD_INT 2
70615: PUSH
70616: LD_INT 1
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: PUSH
70623: LD_INT 1
70625: PUSH
70626: LD_INT 2
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: LD_INT 0
70635: PUSH
70636: LD_INT 2
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 1
70645: NEG
70646: PUSH
70647: LD_INT 1
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: PUSH
70654: LD_INT 2
70656: NEG
70657: PUSH
70658: LD_INT 1
70660: NEG
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PUSH
70666: LD_INT 2
70668: NEG
70669: PUSH
70670: LD_INT 2
70672: NEG
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 2
70680: NEG
70681: PUSH
70682: LD_INT 3
70684: NEG
70685: PUSH
70686: EMPTY
70687: LIST
70688: LIST
70689: PUSH
70690: LD_INT 2
70692: PUSH
70693: LD_INT 1
70695: NEG
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 3
70703: PUSH
70704: LD_INT 1
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PUSH
70711: LD_INT 1
70713: PUSH
70714: LD_INT 3
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PUSH
70721: LD_INT 1
70723: NEG
70724: PUSH
70725: LD_INT 2
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PUSH
70732: LD_INT 3
70734: NEG
70735: PUSH
70736: LD_INT 2
70738: NEG
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: EMPTY
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: LIST
70765: LIST
70766: LIST
70767: LIST
70768: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70769: LD_ADDR_VAR 0 30
70773: PUSH
70774: LD_INT 0
70776: PUSH
70777: LD_INT 0
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 0
70786: PUSH
70787: LD_INT 1
70789: NEG
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: LD_INT 1
70797: PUSH
70798: LD_INT 0
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: PUSH
70805: LD_INT 1
70807: PUSH
70808: LD_INT 1
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: PUSH
70815: LD_INT 0
70817: PUSH
70818: LD_INT 1
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: PUSH
70825: LD_INT 1
70827: NEG
70828: PUSH
70829: LD_INT 0
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: PUSH
70836: LD_INT 1
70838: NEG
70839: PUSH
70840: LD_INT 1
70842: NEG
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: PUSH
70848: LD_INT 1
70850: NEG
70851: PUSH
70852: LD_INT 2
70854: NEG
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: PUSH
70860: LD_INT 0
70862: PUSH
70863: LD_INT 2
70865: NEG
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: PUSH
70871: LD_INT 1
70873: PUSH
70874: LD_INT 1
70876: NEG
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 2
70884: PUSH
70885: LD_INT 0
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 2
70894: PUSH
70895: LD_INT 1
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: PUSH
70902: LD_INT 2
70904: PUSH
70905: LD_INT 2
70907: PUSH
70908: EMPTY
70909: LIST
70910: LIST
70911: PUSH
70912: LD_INT 1
70914: PUSH
70915: LD_INT 2
70917: PUSH
70918: EMPTY
70919: LIST
70920: LIST
70921: PUSH
70922: LD_INT 1
70924: NEG
70925: PUSH
70926: LD_INT 1
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: LD_INT 2
70935: NEG
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: LD_INT 2
70946: NEG
70947: PUSH
70948: LD_INT 1
70950: NEG
70951: PUSH
70952: EMPTY
70953: LIST
70954: LIST
70955: PUSH
70956: LD_INT 1
70958: NEG
70959: PUSH
70960: LD_INT 3
70962: NEG
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PUSH
70968: LD_INT 1
70970: PUSH
70971: LD_INT 2
70973: NEG
70974: PUSH
70975: EMPTY
70976: LIST
70977: LIST
70978: PUSH
70979: LD_INT 3
70981: PUSH
70982: LD_INT 2
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: PUSH
70989: LD_INT 2
70991: PUSH
70992: LD_INT 3
70994: PUSH
70995: EMPTY
70996: LIST
70997: LIST
70998: PUSH
70999: LD_INT 2
71001: NEG
71002: PUSH
71003: LD_INT 1
71005: PUSH
71006: EMPTY
71007: LIST
71008: LIST
71009: PUSH
71010: LD_INT 3
71012: NEG
71013: PUSH
71014: LD_INT 1
71016: NEG
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: EMPTY
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: LIST
71045: LIST
71046: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71047: LD_ADDR_VAR 0 31
71051: PUSH
71052: LD_INT 0
71054: PUSH
71055: LD_INT 0
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 0
71064: PUSH
71065: LD_INT 1
71067: NEG
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 1
71075: PUSH
71076: LD_INT 0
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: LD_INT 1
71085: PUSH
71086: LD_INT 1
71088: PUSH
71089: EMPTY
71090: LIST
71091: LIST
71092: PUSH
71093: LD_INT 0
71095: PUSH
71096: LD_INT 1
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 1
71105: NEG
71106: PUSH
71107: LD_INT 0
71109: PUSH
71110: EMPTY
71111: LIST
71112: LIST
71113: PUSH
71114: LD_INT 1
71116: NEG
71117: PUSH
71118: LD_INT 1
71120: NEG
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 1
71128: NEG
71129: PUSH
71130: LD_INT 2
71132: NEG
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 1
71140: PUSH
71141: LD_INT 1
71143: NEG
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 2
71151: PUSH
71152: LD_INT 0
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 2
71161: PUSH
71162: LD_INT 1
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 2
71171: PUSH
71172: LD_INT 2
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 1
71181: PUSH
71182: LD_INT 2
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 0
71191: PUSH
71192: LD_INT 2
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 1
71201: NEG
71202: PUSH
71203: LD_INT 1
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 2
71212: NEG
71213: PUSH
71214: LD_INT 1
71216: NEG
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: LD_INT 2
71224: NEG
71225: PUSH
71226: LD_INT 2
71228: NEG
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 2
71236: NEG
71237: PUSH
71238: LD_INT 3
71240: NEG
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: PUSH
71246: LD_INT 2
71248: PUSH
71249: LD_INT 1
71251: NEG
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 3
71259: PUSH
71260: LD_INT 1
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 1
71269: PUSH
71270: LD_INT 3
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: PUSH
71277: LD_INT 1
71279: NEG
71280: PUSH
71281: LD_INT 2
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 3
71290: NEG
71291: PUSH
71292: LD_INT 2
71294: NEG
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: EMPTY
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71325: LD_ADDR_VAR 0 32
71329: PUSH
71330: LD_INT 0
71332: PUSH
71333: LD_INT 0
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 0
71342: PUSH
71343: LD_INT 1
71345: NEG
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 1
71353: PUSH
71354: LD_INT 0
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: PUSH
71361: LD_INT 1
71363: PUSH
71364: LD_INT 1
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: PUSH
71371: LD_INT 0
71373: PUSH
71374: LD_INT 1
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: PUSH
71381: LD_INT 1
71383: NEG
71384: PUSH
71385: LD_INT 0
71387: PUSH
71388: EMPTY
71389: LIST
71390: LIST
71391: PUSH
71392: LD_INT 1
71394: NEG
71395: PUSH
71396: LD_INT 1
71398: NEG
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 1
71406: NEG
71407: PUSH
71408: LD_INT 2
71410: NEG
71411: PUSH
71412: EMPTY
71413: LIST
71414: LIST
71415: PUSH
71416: LD_INT 0
71418: PUSH
71419: LD_INT 2
71421: NEG
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 1
71429: PUSH
71430: LD_INT 1
71432: NEG
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 2
71440: PUSH
71441: LD_INT 1
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: PUSH
71448: LD_INT 2
71450: PUSH
71451: LD_INT 2
71453: PUSH
71454: EMPTY
71455: LIST
71456: LIST
71457: PUSH
71458: LD_INT 1
71460: PUSH
71461: LD_INT 2
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: LD_INT 0
71470: PUSH
71471: LD_INT 2
71473: PUSH
71474: EMPTY
71475: LIST
71476: LIST
71477: PUSH
71478: LD_INT 1
71480: NEG
71481: PUSH
71482: LD_INT 1
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: PUSH
71489: LD_INT 2
71491: NEG
71492: PUSH
71493: LD_INT 0
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 2
71502: NEG
71503: PUSH
71504: LD_INT 1
71506: NEG
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PUSH
71512: LD_INT 1
71514: NEG
71515: PUSH
71516: LD_INT 3
71518: NEG
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PUSH
71524: LD_INT 1
71526: PUSH
71527: LD_INT 2
71529: NEG
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 3
71537: PUSH
71538: LD_INT 2
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: LD_INT 2
71547: PUSH
71548: LD_INT 3
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: PUSH
71555: LD_INT 2
71557: NEG
71558: PUSH
71559: LD_INT 1
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 3
71568: NEG
71569: PUSH
71570: LD_INT 1
71572: NEG
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: LIST
71582: LIST
71583: LIST
71584: LIST
71585: LIST
71586: LIST
71587: LIST
71588: LIST
71589: LIST
71590: LIST
71591: LIST
71592: LIST
71593: LIST
71594: LIST
71595: LIST
71596: LIST
71597: LIST
71598: LIST
71599: LIST
71600: LIST
71601: LIST
71602: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71603: LD_ADDR_VAR 0 33
71607: PUSH
71608: LD_INT 0
71610: PUSH
71611: LD_INT 0
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 0
71620: PUSH
71621: LD_INT 1
71623: NEG
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: LD_INT 1
71631: PUSH
71632: LD_INT 0
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 1
71641: PUSH
71642: LD_INT 1
71644: PUSH
71645: EMPTY
71646: LIST
71647: LIST
71648: PUSH
71649: LD_INT 0
71651: PUSH
71652: LD_INT 1
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: PUSH
71659: LD_INT 1
71661: NEG
71662: PUSH
71663: LD_INT 0
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 1
71672: NEG
71673: PUSH
71674: LD_INT 1
71676: NEG
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 1
71684: NEG
71685: PUSH
71686: LD_INT 2
71688: NEG
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: LD_INT 1
71696: PUSH
71697: LD_INT 1
71699: NEG
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: LD_INT 2
71707: PUSH
71708: LD_INT 0
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 2
71717: PUSH
71718: LD_INT 1
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: PUSH
71725: LD_INT 1
71727: PUSH
71728: LD_INT 2
71730: PUSH
71731: EMPTY
71732: LIST
71733: LIST
71734: PUSH
71735: LD_INT 0
71737: PUSH
71738: LD_INT 2
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 1
71747: NEG
71748: PUSH
71749: LD_INT 1
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: PUSH
71756: LD_INT 2
71758: NEG
71759: PUSH
71760: LD_INT 0
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: LD_INT 2
71769: NEG
71770: PUSH
71771: LD_INT 1
71773: NEG
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: PUSH
71779: LD_INT 2
71781: NEG
71782: PUSH
71783: LD_INT 2
71785: NEG
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: PUSH
71791: LD_INT 2
71793: NEG
71794: PUSH
71795: LD_INT 3
71797: NEG
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: PUSH
71803: LD_INT 2
71805: PUSH
71806: LD_INT 1
71808: NEG
71809: PUSH
71810: EMPTY
71811: LIST
71812: LIST
71813: PUSH
71814: LD_INT 3
71816: PUSH
71817: LD_INT 1
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 1
71826: PUSH
71827: LD_INT 3
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: PUSH
71834: LD_INT 1
71836: NEG
71837: PUSH
71838: LD_INT 2
71840: PUSH
71841: EMPTY
71842: LIST
71843: LIST
71844: PUSH
71845: LD_INT 3
71847: NEG
71848: PUSH
71849: LD_INT 2
71851: NEG
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: EMPTY
71858: LIST
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: LIST
71881: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71882: LD_ADDR_VAR 0 34
71886: PUSH
71887: LD_INT 0
71889: PUSH
71890: LD_INT 0
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: PUSH
71897: LD_INT 0
71899: PUSH
71900: LD_INT 1
71902: NEG
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: PUSH
71908: LD_INT 1
71910: PUSH
71911: LD_INT 0
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: PUSH
71918: LD_INT 1
71920: PUSH
71921: LD_INT 1
71923: PUSH
71924: EMPTY
71925: LIST
71926: LIST
71927: PUSH
71928: LD_INT 0
71930: PUSH
71931: LD_INT 1
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: PUSH
71938: LD_INT 1
71940: NEG
71941: PUSH
71942: LD_INT 0
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 1
71951: NEG
71952: PUSH
71953: LD_INT 1
71955: NEG
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PUSH
71961: LD_INT 1
71963: NEG
71964: PUSH
71965: LD_INT 2
71967: NEG
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: LD_INT 0
71975: PUSH
71976: LD_INT 2
71978: NEG
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: PUSH
71984: LD_INT 1
71986: PUSH
71987: LD_INT 1
71989: NEG
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PUSH
71995: LD_INT 2
71997: PUSH
71998: LD_INT 1
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 2
72007: PUSH
72008: LD_INT 2
72010: PUSH
72011: EMPTY
72012: LIST
72013: LIST
72014: PUSH
72015: LD_INT 1
72017: PUSH
72018: LD_INT 2
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 1
72027: NEG
72028: PUSH
72029: LD_INT 1
72031: PUSH
72032: EMPTY
72033: LIST
72034: LIST
72035: PUSH
72036: LD_INT 2
72038: NEG
72039: PUSH
72040: LD_INT 0
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: LD_INT 2
72049: NEG
72050: PUSH
72051: LD_INT 1
72053: NEG
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: LD_INT 2
72061: NEG
72062: PUSH
72063: LD_INT 2
72065: NEG
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 1
72073: NEG
72074: PUSH
72075: LD_INT 3
72077: NEG
72078: PUSH
72079: EMPTY
72080: LIST
72081: LIST
72082: PUSH
72083: LD_INT 1
72085: PUSH
72086: LD_INT 2
72088: NEG
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PUSH
72094: LD_INT 3
72096: PUSH
72097: LD_INT 2
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 2
72106: PUSH
72107: LD_INT 3
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 2
72116: NEG
72117: PUSH
72118: LD_INT 1
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: PUSH
72125: LD_INT 3
72127: NEG
72128: PUSH
72129: LD_INT 1
72131: NEG
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: LIST
72141: LIST
72142: LIST
72143: LIST
72144: LIST
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: LIST
72150: LIST
72151: LIST
72152: LIST
72153: LIST
72154: LIST
72155: LIST
72156: LIST
72157: LIST
72158: LIST
72159: LIST
72160: LIST
72161: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72162: LD_ADDR_VAR 0 35
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: LD_INT 0
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 0
72179: PUSH
72180: LD_INT 1
72182: NEG
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PUSH
72188: LD_INT 1
72190: PUSH
72191: LD_INT 0
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: LD_INT 1
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 0
72210: PUSH
72211: LD_INT 1
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 1
72220: NEG
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 1
72231: NEG
72232: PUSH
72233: LD_INT 1
72235: NEG
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 2
72243: PUSH
72244: LD_INT 1
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 2
72253: NEG
72254: PUSH
72255: LD_INT 1
72257: NEG
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: LIST
72267: LIST
72268: LIST
72269: LIST
72270: LIST
72271: LIST
72272: LIST
72273: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72274: LD_ADDR_VAR 0 36
72278: PUSH
72279: LD_INT 0
72281: PUSH
72282: LD_INT 0
72284: PUSH
72285: EMPTY
72286: LIST
72287: LIST
72288: PUSH
72289: LD_INT 0
72291: PUSH
72292: LD_INT 1
72294: NEG
72295: PUSH
72296: EMPTY
72297: LIST
72298: LIST
72299: PUSH
72300: LD_INT 1
72302: PUSH
72303: LD_INT 0
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: LD_INT 1
72312: PUSH
72313: LD_INT 1
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: PUSH
72320: LD_INT 0
72322: PUSH
72323: LD_INT 1
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PUSH
72330: LD_INT 1
72332: NEG
72333: PUSH
72334: LD_INT 0
72336: PUSH
72337: EMPTY
72338: LIST
72339: LIST
72340: PUSH
72341: LD_INT 1
72343: NEG
72344: PUSH
72345: LD_INT 1
72347: NEG
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: PUSH
72353: LD_INT 1
72355: NEG
72356: PUSH
72357: LD_INT 2
72359: NEG
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: LD_INT 2
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72386: LD_ADDR_VAR 0 37
72390: PUSH
72391: LD_INT 0
72393: PUSH
72394: LD_INT 0
72396: PUSH
72397: EMPTY
72398: LIST
72399: LIST
72400: PUSH
72401: LD_INT 0
72403: PUSH
72404: LD_INT 1
72406: NEG
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: LD_INT 1
72414: PUSH
72415: LD_INT 0
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 1
72424: PUSH
72425: LD_INT 1
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: LD_INT 0
72434: PUSH
72435: LD_INT 1
72437: PUSH
72438: EMPTY
72439: LIST
72440: LIST
72441: PUSH
72442: LD_INT 1
72444: NEG
72445: PUSH
72446: LD_INT 0
72448: PUSH
72449: EMPTY
72450: LIST
72451: LIST
72452: PUSH
72453: LD_INT 1
72455: NEG
72456: PUSH
72457: LD_INT 1
72459: NEG
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 1
72467: PUSH
72468: LD_INT 1
72470: NEG
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 1
72478: NEG
72479: PUSH
72480: LD_INT 1
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: LIST
72493: LIST
72494: LIST
72495: LIST
72496: LIST
72497: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72498: LD_ADDR_VAR 0 38
72502: PUSH
72503: LD_INT 0
72505: PUSH
72506: LD_INT 0
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 0
72515: PUSH
72516: LD_INT 1
72518: NEG
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PUSH
72524: LD_INT 1
72526: PUSH
72527: LD_INT 0
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 1
72536: PUSH
72537: LD_INT 1
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 0
72546: PUSH
72547: LD_INT 1
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 1
72556: NEG
72557: PUSH
72558: LD_INT 0
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: LD_INT 1
72567: NEG
72568: PUSH
72569: LD_INT 1
72571: NEG
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 2
72579: PUSH
72580: LD_INT 1
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: PUSH
72587: LD_INT 2
72589: NEG
72590: PUSH
72591: LD_INT 1
72593: NEG
72594: PUSH
72595: EMPTY
72596: LIST
72597: LIST
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: LIST
72603: LIST
72604: LIST
72605: LIST
72606: LIST
72607: LIST
72608: LIST
72609: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72610: LD_ADDR_VAR 0 39
72614: PUSH
72615: LD_INT 0
72617: PUSH
72618: LD_INT 0
72620: PUSH
72621: EMPTY
72622: LIST
72623: LIST
72624: PUSH
72625: LD_INT 0
72627: PUSH
72628: LD_INT 1
72630: NEG
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 1
72638: PUSH
72639: LD_INT 0
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: PUSH
72646: LD_INT 1
72648: PUSH
72649: LD_INT 1
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 0
72658: PUSH
72659: LD_INT 1
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 1
72668: NEG
72669: PUSH
72670: LD_INT 0
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: PUSH
72677: LD_INT 1
72679: NEG
72680: PUSH
72681: LD_INT 1
72683: NEG
72684: PUSH
72685: EMPTY
72686: LIST
72687: LIST
72688: PUSH
72689: LD_INT 1
72691: NEG
72692: PUSH
72693: LD_INT 2
72695: NEG
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: PUSH
72701: LD_INT 1
72703: PUSH
72704: LD_INT 2
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: LIST
72715: LIST
72716: LIST
72717: LIST
72718: LIST
72719: LIST
72720: LIST
72721: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72722: LD_ADDR_VAR 0 40
72726: PUSH
72727: LD_INT 0
72729: PUSH
72730: LD_INT 0
72732: PUSH
72733: EMPTY
72734: LIST
72735: LIST
72736: PUSH
72737: LD_INT 0
72739: PUSH
72740: LD_INT 1
72742: NEG
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 1
72750: PUSH
72751: LD_INT 0
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 1
72760: PUSH
72761: LD_INT 1
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PUSH
72768: LD_INT 0
72770: PUSH
72771: LD_INT 1
72773: PUSH
72774: EMPTY
72775: LIST
72776: LIST
72777: PUSH
72778: LD_INT 1
72780: NEG
72781: PUSH
72782: LD_INT 0
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: LD_INT 1
72791: NEG
72792: PUSH
72793: LD_INT 1
72795: NEG
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 1
72803: PUSH
72804: LD_INT 1
72806: NEG
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: PUSH
72812: LD_INT 1
72814: NEG
72815: PUSH
72816: LD_INT 1
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: LIST
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72834: LD_ADDR_VAR 0 41
72838: PUSH
72839: LD_INT 0
72841: PUSH
72842: LD_INT 0
72844: PUSH
72845: EMPTY
72846: LIST
72847: LIST
72848: PUSH
72849: LD_INT 0
72851: PUSH
72852: LD_INT 1
72854: NEG
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: PUSH
72860: LD_INT 1
72862: PUSH
72863: LD_INT 0
72865: PUSH
72866: EMPTY
72867: LIST
72868: LIST
72869: PUSH
72870: LD_INT 1
72872: PUSH
72873: LD_INT 1
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 0
72882: PUSH
72883: LD_INT 1
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: PUSH
72890: LD_INT 1
72892: NEG
72893: PUSH
72894: LD_INT 0
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: LD_INT 1
72903: NEG
72904: PUSH
72905: LD_INT 1
72907: NEG
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 1
72915: NEG
72916: PUSH
72917: LD_INT 2
72919: NEG
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: LD_INT 1
72927: PUSH
72928: LD_INT 1
72930: NEG
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 2
72938: PUSH
72939: LD_INT 0
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 2
72948: PUSH
72949: LD_INT 1
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: PUSH
72956: LD_INT 2
72958: PUSH
72959: LD_INT 2
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: PUSH
72966: LD_INT 1
72968: PUSH
72969: LD_INT 2
72971: PUSH
72972: EMPTY
72973: LIST
72974: LIST
72975: PUSH
72976: LD_INT 1
72978: NEG
72979: PUSH
72980: LD_INT 1
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: LD_INT 2
72989: NEG
72990: PUSH
72991: LD_INT 0
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: LD_INT 2
73000: NEG
73001: PUSH
73002: LD_INT 1
73004: NEG
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 2
73012: NEG
73013: PUSH
73014: LD_INT 2
73016: NEG
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PUSH
73022: LD_INT 2
73024: NEG
73025: PUSH
73026: LD_INT 3
73028: NEG
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: LD_INT 2
73036: PUSH
73037: LD_INT 1
73039: NEG
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 3
73047: PUSH
73048: LD_INT 0
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 3
73057: PUSH
73058: LD_INT 1
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 3
73067: PUSH
73068: LD_INT 2
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 3
73077: PUSH
73078: LD_INT 3
73080: PUSH
73081: EMPTY
73082: LIST
73083: LIST
73084: PUSH
73085: LD_INT 2
73087: PUSH
73088: LD_INT 3
73090: PUSH
73091: EMPTY
73092: LIST
73093: LIST
73094: PUSH
73095: LD_INT 2
73097: NEG
73098: PUSH
73099: LD_INT 1
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: PUSH
73106: LD_INT 3
73108: NEG
73109: PUSH
73110: LD_INT 0
73112: PUSH
73113: EMPTY
73114: LIST
73115: LIST
73116: PUSH
73117: LD_INT 3
73119: NEG
73120: PUSH
73121: LD_INT 1
73123: NEG
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PUSH
73129: LD_INT 3
73131: NEG
73132: PUSH
73133: LD_INT 2
73135: NEG
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: PUSH
73141: LD_INT 3
73143: NEG
73144: PUSH
73145: LD_INT 3
73147: NEG
73148: PUSH
73149: EMPTY
73150: LIST
73151: LIST
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: LIST
73157: LIST
73158: LIST
73159: LIST
73160: LIST
73161: LIST
73162: LIST
73163: LIST
73164: LIST
73165: LIST
73166: LIST
73167: LIST
73168: LIST
73169: LIST
73170: LIST
73171: LIST
73172: LIST
73173: LIST
73174: LIST
73175: LIST
73176: LIST
73177: LIST
73178: LIST
73179: LIST
73180: LIST
73181: LIST
73182: LIST
73183: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73184: LD_ADDR_VAR 0 42
73188: PUSH
73189: LD_INT 0
73191: PUSH
73192: LD_INT 0
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: PUSH
73199: LD_INT 0
73201: PUSH
73202: LD_INT 1
73204: NEG
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: PUSH
73210: LD_INT 1
73212: PUSH
73213: LD_INT 0
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: LD_INT 1
73222: PUSH
73223: LD_INT 1
73225: PUSH
73226: EMPTY
73227: LIST
73228: LIST
73229: PUSH
73230: LD_INT 0
73232: PUSH
73233: LD_INT 1
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: PUSH
73240: LD_INT 1
73242: NEG
73243: PUSH
73244: LD_INT 0
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: LD_INT 1
73253: NEG
73254: PUSH
73255: LD_INT 1
73257: NEG
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 1
73265: NEG
73266: PUSH
73267: LD_INT 2
73269: NEG
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 0
73277: PUSH
73278: LD_INT 2
73280: NEG
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: PUSH
73286: LD_INT 1
73288: PUSH
73289: LD_INT 1
73291: NEG
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: PUSH
73297: LD_INT 2
73299: PUSH
73300: LD_INT 1
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: PUSH
73307: LD_INT 2
73309: PUSH
73310: LD_INT 2
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: PUSH
73317: LD_INT 1
73319: PUSH
73320: LD_INT 2
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: PUSH
73327: LD_INT 0
73329: PUSH
73330: LD_INT 2
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: PUSH
73337: LD_INT 1
73339: NEG
73340: PUSH
73341: LD_INT 1
73343: PUSH
73344: EMPTY
73345: LIST
73346: LIST
73347: PUSH
73348: LD_INT 2
73350: NEG
73351: PUSH
73352: LD_INT 1
73354: NEG
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 2
73362: NEG
73363: PUSH
73364: LD_INT 2
73366: NEG
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: LD_INT 2
73374: NEG
73375: PUSH
73376: LD_INT 3
73378: NEG
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: PUSH
73384: LD_INT 1
73386: NEG
73387: PUSH
73388: LD_INT 3
73390: NEG
73391: PUSH
73392: EMPTY
73393: LIST
73394: LIST
73395: PUSH
73396: LD_INT 0
73398: PUSH
73399: LD_INT 3
73401: NEG
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 1
73409: PUSH
73410: LD_INT 2
73412: NEG
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 3
73420: PUSH
73421: LD_INT 2
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 3
73430: PUSH
73431: LD_INT 3
73433: PUSH
73434: EMPTY
73435: LIST
73436: LIST
73437: PUSH
73438: LD_INT 2
73440: PUSH
73441: LD_INT 3
73443: PUSH
73444: EMPTY
73445: LIST
73446: LIST
73447: PUSH
73448: LD_INT 1
73450: PUSH
73451: LD_INT 3
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: PUSH
73458: LD_INT 0
73460: PUSH
73461: LD_INT 3
73463: PUSH
73464: EMPTY
73465: LIST
73466: LIST
73467: PUSH
73468: LD_INT 1
73470: NEG
73471: PUSH
73472: LD_INT 2
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: PUSH
73479: LD_INT 3
73481: NEG
73482: PUSH
73483: LD_INT 2
73485: NEG
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: PUSH
73491: LD_INT 3
73493: NEG
73494: PUSH
73495: LD_INT 3
73497: NEG
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73534: LD_ADDR_VAR 0 43
73538: PUSH
73539: LD_INT 0
73541: PUSH
73542: LD_INT 0
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: LD_INT 0
73551: PUSH
73552: LD_INT 1
73554: NEG
73555: PUSH
73556: EMPTY
73557: LIST
73558: LIST
73559: PUSH
73560: LD_INT 1
73562: PUSH
73563: LD_INT 0
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 1
73572: PUSH
73573: LD_INT 1
73575: PUSH
73576: EMPTY
73577: LIST
73578: LIST
73579: PUSH
73580: LD_INT 0
73582: PUSH
73583: LD_INT 1
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 1
73592: NEG
73593: PUSH
73594: LD_INT 0
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PUSH
73601: LD_INT 1
73603: NEG
73604: PUSH
73605: LD_INT 1
73607: NEG
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: PUSH
73613: LD_INT 1
73615: NEG
73616: PUSH
73617: LD_INT 2
73619: NEG
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 0
73627: PUSH
73628: LD_INT 2
73630: NEG
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 1
73638: PUSH
73639: LD_INT 1
73641: NEG
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 2
73649: PUSH
73650: LD_INT 0
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: LD_INT 2
73659: PUSH
73660: LD_INT 1
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: PUSH
73667: LD_INT 1
73669: PUSH
73670: LD_INT 2
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 0
73679: PUSH
73680: LD_INT 2
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PUSH
73687: LD_INT 1
73689: NEG
73690: PUSH
73691: LD_INT 1
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: PUSH
73698: LD_INT 2
73700: NEG
73701: PUSH
73702: LD_INT 0
73704: PUSH
73705: EMPTY
73706: LIST
73707: LIST
73708: PUSH
73709: LD_INT 2
73711: NEG
73712: PUSH
73713: LD_INT 1
73715: NEG
73716: PUSH
73717: EMPTY
73718: LIST
73719: LIST
73720: PUSH
73721: LD_INT 1
73723: NEG
73724: PUSH
73725: LD_INT 3
73727: NEG
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PUSH
73733: LD_INT 0
73735: PUSH
73736: LD_INT 3
73738: NEG
73739: PUSH
73740: EMPTY
73741: LIST
73742: LIST
73743: PUSH
73744: LD_INT 1
73746: PUSH
73747: LD_INT 2
73749: NEG
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: LD_INT 2
73757: PUSH
73758: LD_INT 1
73760: NEG
73761: PUSH
73762: EMPTY
73763: LIST
73764: LIST
73765: PUSH
73766: LD_INT 3
73768: PUSH
73769: LD_INT 0
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: PUSH
73776: LD_INT 3
73778: PUSH
73779: LD_INT 1
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PUSH
73786: LD_INT 1
73788: PUSH
73789: LD_INT 3
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: PUSH
73796: LD_INT 0
73798: PUSH
73799: LD_INT 3
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 1
73808: NEG
73809: PUSH
73810: LD_INT 2
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: LD_INT 2
73819: NEG
73820: PUSH
73821: LD_INT 1
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: PUSH
73828: LD_INT 3
73830: NEG
73831: PUSH
73832: LD_INT 0
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 3
73841: NEG
73842: PUSH
73843: LD_INT 1
73845: NEG
73846: PUSH
73847: EMPTY
73848: LIST
73849: LIST
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: LIST
73855: LIST
73856: LIST
73857: LIST
73858: LIST
73859: LIST
73860: LIST
73861: LIST
73862: LIST
73863: LIST
73864: LIST
73865: LIST
73866: LIST
73867: LIST
73868: LIST
73869: LIST
73870: LIST
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: LIST
73877: LIST
73878: LIST
73879: LIST
73880: LIST
73881: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73882: LD_ADDR_VAR 0 44
73886: PUSH
73887: LD_INT 0
73889: PUSH
73890: LD_INT 0
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: PUSH
73897: LD_INT 0
73899: PUSH
73900: LD_INT 1
73902: NEG
73903: PUSH
73904: EMPTY
73905: LIST
73906: LIST
73907: PUSH
73908: LD_INT 1
73910: PUSH
73911: LD_INT 0
73913: PUSH
73914: EMPTY
73915: LIST
73916: LIST
73917: PUSH
73918: LD_INT 1
73920: PUSH
73921: LD_INT 1
73923: PUSH
73924: EMPTY
73925: LIST
73926: LIST
73927: PUSH
73928: LD_INT 0
73930: PUSH
73931: LD_INT 1
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: LD_INT 1
73940: NEG
73941: PUSH
73942: LD_INT 0
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: LD_INT 1
73951: NEG
73952: PUSH
73953: LD_INT 1
73955: NEG
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 1
73963: NEG
73964: PUSH
73965: LD_INT 2
73967: NEG
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 1
73975: PUSH
73976: LD_INT 1
73978: NEG
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 2
73986: PUSH
73987: LD_INT 0
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 2
73996: PUSH
73997: LD_INT 1
73999: PUSH
74000: EMPTY
74001: LIST
74002: LIST
74003: PUSH
74004: LD_INT 2
74006: PUSH
74007: LD_INT 2
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PUSH
74014: LD_INT 1
74016: PUSH
74017: LD_INT 2
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 1
74026: NEG
74027: PUSH
74028: LD_INT 1
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: PUSH
74035: LD_INT 2
74037: NEG
74038: PUSH
74039: LD_INT 0
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 2
74048: NEG
74049: PUSH
74050: LD_INT 1
74052: NEG
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: PUSH
74058: LD_INT 2
74060: NEG
74061: PUSH
74062: LD_INT 2
74064: NEG
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PUSH
74070: LD_INT 2
74072: NEG
74073: PUSH
74074: LD_INT 3
74076: NEG
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: LD_INT 2
74084: PUSH
74085: LD_INT 1
74087: NEG
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PUSH
74093: LD_INT 3
74095: PUSH
74096: LD_INT 0
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 3
74105: PUSH
74106: LD_INT 1
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: PUSH
74113: LD_INT 3
74115: PUSH
74116: LD_INT 2
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 3
74125: PUSH
74126: LD_INT 3
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: PUSH
74133: LD_INT 2
74135: PUSH
74136: LD_INT 3
74138: PUSH
74139: EMPTY
74140: LIST
74141: LIST
74142: PUSH
74143: LD_INT 2
74145: NEG
74146: PUSH
74147: LD_INT 1
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: LD_INT 3
74156: NEG
74157: PUSH
74158: LD_INT 0
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 3
74167: NEG
74168: PUSH
74169: LD_INT 1
74171: NEG
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: LD_INT 3
74179: NEG
74180: PUSH
74181: LD_INT 2
74183: NEG
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: PUSH
74189: LD_INT 3
74191: NEG
74192: PUSH
74193: LD_INT 3
74195: NEG
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: LIST
74207: LIST
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: LIST
74218: LIST
74219: LIST
74220: LIST
74221: LIST
74222: LIST
74223: LIST
74224: LIST
74225: LIST
74226: LIST
74227: LIST
74228: LIST
74229: LIST
74230: LIST
74231: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74232: LD_ADDR_VAR 0 45
74236: PUSH
74237: LD_INT 0
74239: PUSH
74240: LD_INT 0
74242: PUSH
74243: EMPTY
74244: LIST
74245: LIST
74246: PUSH
74247: LD_INT 0
74249: PUSH
74250: LD_INT 1
74252: NEG
74253: PUSH
74254: EMPTY
74255: LIST
74256: LIST
74257: PUSH
74258: LD_INT 1
74260: PUSH
74261: LD_INT 0
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PUSH
74268: LD_INT 1
74270: PUSH
74271: LD_INT 1
74273: PUSH
74274: EMPTY
74275: LIST
74276: LIST
74277: PUSH
74278: LD_INT 0
74280: PUSH
74281: LD_INT 1
74283: PUSH
74284: EMPTY
74285: LIST
74286: LIST
74287: PUSH
74288: LD_INT 1
74290: NEG
74291: PUSH
74292: LD_INT 0
74294: PUSH
74295: EMPTY
74296: LIST
74297: LIST
74298: PUSH
74299: LD_INT 1
74301: NEG
74302: PUSH
74303: LD_INT 1
74305: NEG
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 1
74313: NEG
74314: PUSH
74315: LD_INT 2
74317: NEG
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: PUSH
74323: LD_INT 0
74325: PUSH
74326: LD_INT 2
74328: NEG
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 1
74336: PUSH
74337: LD_INT 1
74339: NEG
74340: PUSH
74341: EMPTY
74342: LIST
74343: LIST
74344: PUSH
74345: LD_INT 2
74347: PUSH
74348: LD_INT 1
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: PUSH
74355: LD_INT 2
74357: PUSH
74358: LD_INT 2
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 1
74367: PUSH
74368: LD_INT 2
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: LD_INT 0
74377: PUSH
74378: LD_INT 2
74380: PUSH
74381: EMPTY
74382: LIST
74383: LIST
74384: PUSH
74385: LD_INT 1
74387: NEG
74388: PUSH
74389: LD_INT 1
74391: PUSH
74392: EMPTY
74393: LIST
74394: LIST
74395: PUSH
74396: LD_INT 2
74398: NEG
74399: PUSH
74400: LD_INT 1
74402: NEG
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 2
74410: NEG
74411: PUSH
74412: LD_INT 2
74414: NEG
74415: PUSH
74416: EMPTY
74417: LIST
74418: LIST
74419: PUSH
74420: LD_INT 2
74422: NEG
74423: PUSH
74424: LD_INT 3
74426: NEG
74427: PUSH
74428: EMPTY
74429: LIST
74430: LIST
74431: PUSH
74432: LD_INT 1
74434: NEG
74435: PUSH
74436: LD_INT 3
74438: NEG
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: PUSH
74444: LD_INT 0
74446: PUSH
74447: LD_INT 3
74449: NEG
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: LD_INT 1
74457: PUSH
74458: LD_INT 2
74460: NEG
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PUSH
74466: LD_INT 3
74468: PUSH
74469: LD_INT 2
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 3
74478: PUSH
74479: LD_INT 3
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: PUSH
74486: LD_INT 2
74488: PUSH
74489: LD_INT 3
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 1
74498: PUSH
74499: LD_INT 3
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: LD_INT 0
74508: PUSH
74509: LD_INT 3
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: PUSH
74516: LD_INT 1
74518: NEG
74519: PUSH
74520: LD_INT 2
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 3
74529: NEG
74530: PUSH
74531: LD_INT 2
74533: NEG
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: PUSH
74539: LD_INT 3
74541: NEG
74542: PUSH
74543: LD_INT 3
74545: NEG
74546: PUSH
74547: EMPTY
74548: LIST
74549: LIST
74550: PUSH
74551: EMPTY
74552: LIST
74553: LIST
74554: LIST
74555: LIST
74556: LIST
74557: LIST
74558: LIST
74559: LIST
74560: LIST
74561: LIST
74562: LIST
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: LIST
74571: LIST
74572: LIST
74573: LIST
74574: LIST
74575: LIST
74576: LIST
74577: LIST
74578: LIST
74579: LIST
74580: LIST
74581: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74582: LD_ADDR_VAR 0 46
74586: PUSH
74587: LD_INT 0
74589: PUSH
74590: LD_INT 0
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 0
74599: PUSH
74600: LD_INT 1
74602: NEG
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 1
74610: PUSH
74611: LD_INT 0
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 1
74620: PUSH
74621: LD_INT 1
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 0
74630: PUSH
74631: LD_INT 1
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: PUSH
74638: LD_INT 1
74640: NEG
74641: PUSH
74642: LD_INT 0
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PUSH
74649: LD_INT 1
74651: NEG
74652: PUSH
74653: LD_INT 1
74655: NEG
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 1
74663: NEG
74664: PUSH
74665: LD_INT 2
74667: NEG
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: PUSH
74673: LD_INT 0
74675: PUSH
74676: LD_INT 2
74678: NEG
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 1
74686: PUSH
74687: LD_INT 1
74689: NEG
74690: PUSH
74691: EMPTY
74692: LIST
74693: LIST
74694: PUSH
74695: LD_INT 2
74697: PUSH
74698: LD_INT 0
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: PUSH
74705: LD_INT 2
74707: PUSH
74708: LD_INT 1
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 1
74717: PUSH
74718: LD_INT 2
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 0
74727: PUSH
74728: LD_INT 2
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: LD_INT 1
74737: NEG
74738: PUSH
74739: LD_INT 1
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PUSH
74746: LD_INT 2
74748: NEG
74749: PUSH
74750: LD_INT 0
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PUSH
74757: LD_INT 2
74759: NEG
74760: PUSH
74761: LD_INT 1
74763: NEG
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 1
74771: NEG
74772: PUSH
74773: LD_INT 3
74775: NEG
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: LD_INT 0
74783: PUSH
74784: LD_INT 3
74786: NEG
74787: PUSH
74788: EMPTY
74789: LIST
74790: LIST
74791: PUSH
74792: LD_INT 1
74794: PUSH
74795: LD_INT 2
74797: NEG
74798: PUSH
74799: EMPTY
74800: LIST
74801: LIST
74802: PUSH
74803: LD_INT 2
74805: PUSH
74806: LD_INT 1
74808: NEG
74809: PUSH
74810: EMPTY
74811: LIST
74812: LIST
74813: PUSH
74814: LD_INT 3
74816: PUSH
74817: LD_INT 0
74819: PUSH
74820: EMPTY
74821: LIST
74822: LIST
74823: PUSH
74824: LD_INT 3
74826: PUSH
74827: LD_INT 1
74829: PUSH
74830: EMPTY
74831: LIST
74832: LIST
74833: PUSH
74834: LD_INT 1
74836: PUSH
74837: LD_INT 3
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: PUSH
74844: LD_INT 0
74846: PUSH
74847: LD_INT 3
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: LD_INT 1
74856: NEG
74857: PUSH
74858: LD_INT 2
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 2
74867: NEG
74868: PUSH
74869: LD_INT 1
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: PUSH
74876: LD_INT 3
74878: NEG
74879: PUSH
74880: LD_INT 0
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 3
74889: NEG
74890: PUSH
74891: LD_INT 1
74893: NEG
74894: PUSH
74895: EMPTY
74896: LIST
74897: LIST
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: LIST
74903: LIST
74904: LIST
74905: LIST
74906: LIST
74907: LIST
74908: LIST
74909: LIST
74910: LIST
74911: LIST
74912: LIST
74913: LIST
74914: LIST
74915: LIST
74916: LIST
74917: LIST
74918: LIST
74919: LIST
74920: LIST
74921: LIST
74922: LIST
74923: LIST
74924: LIST
74925: LIST
74926: LIST
74927: LIST
74928: LIST
74929: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74930: LD_ADDR_VAR 0 47
74934: PUSH
74935: LD_INT 0
74937: PUSH
74938: LD_INT 0
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 0
74947: PUSH
74948: LD_INT 1
74950: NEG
74951: PUSH
74952: EMPTY
74953: LIST
74954: LIST
74955: PUSH
74956: LD_INT 1
74958: PUSH
74959: LD_INT 0
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 1
74968: PUSH
74969: LD_INT 1
74971: PUSH
74972: EMPTY
74973: LIST
74974: LIST
74975: PUSH
74976: LD_INT 0
74978: PUSH
74979: LD_INT 1
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 1
74988: NEG
74989: PUSH
74990: LD_INT 0
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: LD_INT 1
74999: NEG
75000: PUSH
75001: LD_INT 1
75003: NEG
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: LD_INT 1
75011: NEG
75012: PUSH
75013: LD_INT 2
75015: NEG
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 0
75023: PUSH
75024: LD_INT 2
75026: NEG
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 1
75034: PUSH
75035: LD_INT 1
75037: NEG
75038: PUSH
75039: EMPTY
75040: LIST
75041: LIST
75042: PUSH
75043: LD_INT 2
75045: NEG
75046: PUSH
75047: LD_INT 1
75049: NEG
75050: PUSH
75051: EMPTY
75052: LIST
75053: LIST
75054: PUSH
75055: LD_INT 2
75057: NEG
75058: PUSH
75059: LD_INT 2
75061: NEG
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: LIST
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: LIST
75076: LIST
75077: LIST
75078: LIST
75079: LIST
75080: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75081: LD_ADDR_VAR 0 48
75085: PUSH
75086: LD_INT 0
75088: PUSH
75089: LD_INT 0
75091: PUSH
75092: EMPTY
75093: LIST
75094: LIST
75095: PUSH
75096: LD_INT 0
75098: PUSH
75099: LD_INT 1
75101: NEG
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: PUSH
75107: LD_INT 1
75109: PUSH
75110: LD_INT 0
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 1
75119: PUSH
75120: LD_INT 1
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 0
75129: PUSH
75130: LD_INT 1
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: LD_INT 1
75139: NEG
75140: PUSH
75141: LD_INT 0
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 1
75150: NEG
75151: PUSH
75152: LD_INT 1
75154: NEG
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 1
75162: NEG
75163: PUSH
75164: LD_INT 2
75166: NEG
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 0
75174: PUSH
75175: LD_INT 2
75177: NEG
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 1
75185: PUSH
75186: LD_INT 1
75188: NEG
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 2
75196: PUSH
75197: LD_INT 0
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: LD_INT 2
75206: PUSH
75207: LD_INT 1
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: PUSH
75214: EMPTY
75215: LIST
75216: LIST
75217: LIST
75218: LIST
75219: LIST
75220: LIST
75221: LIST
75222: LIST
75223: LIST
75224: LIST
75225: LIST
75226: LIST
75227: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75228: LD_ADDR_VAR 0 49
75232: PUSH
75233: LD_INT 0
75235: PUSH
75236: LD_INT 0
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 0
75245: PUSH
75246: LD_INT 1
75248: NEG
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 1
75256: PUSH
75257: LD_INT 0
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: LD_INT 1
75266: PUSH
75267: LD_INT 1
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: PUSH
75274: LD_INT 0
75276: PUSH
75277: LD_INT 1
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: PUSH
75284: LD_INT 1
75286: NEG
75287: PUSH
75288: LD_INT 0
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 1
75297: NEG
75298: PUSH
75299: LD_INT 1
75301: NEG
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PUSH
75307: LD_INT 1
75309: PUSH
75310: LD_INT 1
75312: NEG
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 2
75320: PUSH
75321: LD_INT 0
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PUSH
75328: LD_INT 2
75330: PUSH
75331: LD_INT 1
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: PUSH
75338: LD_INT 2
75340: PUSH
75341: LD_INT 2
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PUSH
75348: LD_INT 1
75350: PUSH
75351: LD_INT 2
75353: PUSH
75354: EMPTY
75355: LIST
75356: LIST
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: LIST
75362: LIST
75363: LIST
75364: LIST
75365: LIST
75366: LIST
75367: LIST
75368: LIST
75369: LIST
75370: LIST
75371: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75372: LD_ADDR_VAR 0 50
75376: PUSH
75377: LD_INT 0
75379: PUSH
75380: LD_INT 0
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PUSH
75387: LD_INT 0
75389: PUSH
75390: LD_INT 1
75392: NEG
75393: PUSH
75394: EMPTY
75395: LIST
75396: LIST
75397: PUSH
75398: LD_INT 1
75400: PUSH
75401: LD_INT 0
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 1
75410: PUSH
75411: LD_INT 1
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 0
75420: PUSH
75421: LD_INT 1
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 1
75430: NEG
75431: PUSH
75432: LD_INT 0
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PUSH
75439: LD_INT 1
75441: NEG
75442: PUSH
75443: LD_INT 1
75445: NEG
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 2
75453: PUSH
75454: LD_INT 1
75456: PUSH
75457: EMPTY
75458: LIST
75459: LIST
75460: PUSH
75461: LD_INT 2
75463: PUSH
75464: LD_INT 2
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 1
75473: PUSH
75474: LD_INT 2
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: LD_INT 0
75483: PUSH
75484: LD_INT 2
75486: PUSH
75487: EMPTY
75488: LIST
75489: LIST
75490: PUSH
75491: LD_INT 1
75493: NEG
75494: PUSH
75495: LD_INT 1
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: LIST
75506: LIST
75507: LIST
75508: LIST
75509: LIST
75510: LIST
75511: LIST
75512: LIST
75513: LIST
75514: LIST
75515: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75516: LD_ADDR_VAR 0 51
75520: PUSH
75521: LD_INT 0
75523: PUSH
75524: LD_INT 0
75526: PUSH
75527: EMPTY
75528: LIST
75529: LIST
75530: PUSH
75531: LD_INT 0
75533: PUSH
75534: LD_INT 1
75536: NEG
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 1
75544: PUSH
75545: LD_INT 0
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 1
75554: PUSH
75555: LD_INT 1
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: LD_INT 0
75564: PUSH
75565: LD_INT 1
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: PUSH
75572: LD_INT 1
75574: NEG
75575: PUSH
75576: LD_INT 0
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: PUSH
75583: LD_INT 1
75585: NEG
75586: PUSH
75587: LD_INT 1
75589: NEG
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 1
75597: PUSH
75598: LD_INT 2
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: LD_INT 0
75607: PUSH
75608: LD_INT 2
75610: PUSH
75611: EMPTY
75612: LIST
75613: LIST
75614: PUSH
75615: LD_INT 1
75617: NEG
75618: PUSH
75619: LD_INT 1
75621: PUSH
75622: EMPTY
75623: LIST
75624: LIST
75625: PUSH
75626: LD_INT 2
75628: NEG
75629: PUSH
75630: LD_INT 0
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 2
75639: NEG
75640: PUSH
75641: LD_INT 1
75643: NEG
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: LIST
75653: LIST
75654: LIST
75655: LIST
75656: LIST
75657: LIST
75658: LIST
75659: LIST
75660: LIST
75661: LIST
75662: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75663: LD_ADDR_VAR 0 52
75667: PUSH
75668: LD_INT 0
75670: PUSH
75671: LD_INT 0
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 0
75680: PUSH
75681: LD_INT 1
75683: NEG
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: LD_INT 1
75691: PUSH
75692: LD_INT 0
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: PUSH
75699: LD_INT 1
75701: PUSH
75702: LD_INT 1
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 0
75711: PUSH
75712: LD_INT 1
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: LD_INT 1
75721: NEG
75722: PUSH
75723: LD_INT 0
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PUSH
75730: LD_INT 1
75732: NEG
75733: PUSH
75734: LD_INT 1
75736: NEG
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 1
75744: NEG
75745: PUSH
75746: LD_INT 2
75748: NEG
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: PUSH
75754: LD_INT 1
75756: NEG
75757: PUSH
75758: LD_INT 1
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 2
75767: NEG
75768: PUSH
75769: LD_INT 0
75771: PUSH
75772: EMPTY
75773: LIST
75774: LIST
75775: PUSH
75776: LD_INT 2
75778: NEG
75779: PUSH
75780: LD_INT 1
75782: NEG
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: PUSH
75788: LD_INT 2
75790: NEG
75791: PUSH
75792: LD_INT 2
75794: NEG
75795: PUSH
75796: EMPTY
75797: LIST
75798: LIST
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: LIST
75804: LIST
75805: LIST
75806: LIST
75807: LIST
75808: LIST
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75814: LD_ADDR_VAR 0 53
75818: PUSH
75819: LD_INT 0
75821: PUSH
75822: LD_INT 0
75824: PUSH
75825: EMPTY
75826: LIST
75827: LIST
75828: PUSH
75829: LD_INT 0
75831: PUSH
75832: LD_INT 1
75834: NEG
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: LD_INT 1
75842: PUSH
75843: LD_INT 0
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 1
75852: PUSH
75853: LD_INT 1
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: LD_INT 0
75862: PUSH
75863: LD_INT 1
75865: PUSH
75866: EMPTY
75867: LIST
75868: LIST
75869: PUSH
75870: LD_INT 1
75872: NEG
75873: PUSH
75874: LD_INT 0
75876: PUSH
75877: EMPTY
75878: LIST
75879: LIST
75880: PUSH
75881: LD_INT 1
75883: NEG
75884: PUSH
75885: LD_INT 1
75887: NEG
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 1
75895: NEG
75896: PUSH
75897: LD_INT 2
75899: NEG
75900: PUSH
75901: EMPTY
75902: LIST
75903: LIST
75904: PUSH
75905: LD_INT 0
75907: PUSH
75908: LD_INT 2
75910: NEG
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: PUSH
75916: LD_INT 1
75918: PUSH
75919: LD_INT 1
75921: NEG
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: PUSH
75927: LD_INT 2
75929: PUSH
75930: LD_INT 0
75932: PUSH
75933: EMPTY
75934: LIST
75935: LIST
75936: PUSH
75937: LD_INT 2
75939: PUSH
75940: LD_INT 1
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 2
75949: PUSH
75950: LD_INT 2
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 1
75959: PUSH
75960: LD_INT 2
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PUSH
75967: LD_INT 0
75969: PUSH
75970: LD_INT 2
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 1
75979: NEG
75980: PUSH
75981: LD_INT 1
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 2
75990: NEG
75991: PUSH
75992: LD_INT 0
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: LD_INT 2
76001: NEG
76002: PUSH
76003: LD_INT 1
76005: NEG
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 2
76013: NEG
76014: PUSH
76015: LD_INT 2
76017: NEG
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: EMPTY
76024: LIST
76025: LIST
76026: LIST
76027: LIST
76028: LIST
76029: LIST
76030: LIST
76031: LIST
76032: LIST
76033: LIST
76034: LIST
76035: LIST
76036: LIST
76037: LIST
76038: LIST
76039: LIST
76040: LIST
76041: LIST
76042: LIST
76043: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76044: LD_ADDR_VAR 0 54
76048: PUSH
76049: LD_INT 0
76051: PUSH
76052: LD_INT 0
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PUSH
76059: LD_INT 0
76061: PUSH
76062: LD_INT 1
76064: NEG
76065: PUSH
76066: EMPTY
76067: LIST
76068: LIST
76069: PUSH
76070: LD_INT 1
76072: PUSH
76073: LD_INT 0
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PUSH
76080: LD_INT 1
76082: PUSH
76083: LD_INT 1
76085: PUSH
76086: EMPTY
76087: LIST
76088: LIST
76089: PUSH
76090: LD_INT 0
76092: PUSH
76093: LD_INT 1
76095: PUSH
76096: EMPTY
76097: LIST
76098: LIST
76099: PUSH
76100: LD_INT 1
76102: NEG
76103: PUSH
76104: LD_INT 0
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: LD_INT 1
76113: NEG
76114: PUSH
76115: LD_INT 1
76117: NEG
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 1
76125: NEG
76126: PUSH
76127: LD_INT 2
76129: NEG
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: LD_INT 0
76137: PUSH
76138: LD_INT 2
76140: NEG
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 1
76148: PUSH
76149: LD_INT 1
76151: NEG
76152: PUSH
76153: EMPTY
76154: LIST
76155: LIST
76156: PUSH
76157: LD_INT 2
76159: PUSH
76160: LD_INT 0
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: LD_INT 2
76169: PUSH
76170: LD_INT 1
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 2
76179: PUSH
76180: LD_INT 2
76182: PUSH
76183: EMPTY
76184: LIST
76185: LIST
76186: PUSH
76187: LD_INT 1
76189: PUSH
76190: LD_INT 2
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: LD_INT 0
76199: PUSH
76200: LD_INT 2
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 1
76209: NEG
76210: PUSH
76211: LD_INT 1
76213: PUSH
76214: EMPTY
76215: LIST
76216: LIST
76217: PUSH
76218: LD_INT 2
76220: NEG
76221: PUSH
76222: LD_INT 0
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: PUSH
76229: LD_INT 2
76231: NEG
76232: PUSH
76233: LD_INT 1
76235: NEG
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PUSH
76241: LD_INT 2
76243: NEG
76244: PUSH
76245: LD_INT 2
76247: NEG
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: LIST
76257: LIST
76258: LIST
76259: LIST
76260: LIST
76261: LIST
76262: LIST
76263: LIST
76264: LIST
76265: LIST
76266: LIST
76267: LIST
76268: LIST
76269: LIST
76270: LIST
76271: LIST
76272: LIST
76273: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76274: LD_ADDR_VAR 0 55
76278: PUSH
76279: LD_INT 0
76281: PUSH
76282: LD_INT 0
76284: PUSH
76285: EMPTY
76286: LIST
76287: LIST
76288: PUSH
76289: LD_INT 0
76291: PUSH
76292: LD_INT 1
76294: NEG
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: PUSH
76300: LD_INT 1
76302: PUSH
76303: LD_INT 0
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: PUSH
76310: LD_INT 1
76312: PUSH
76313: LD_INT 1
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PUSH
76320: LD_INT 0
76322: PUSH
76323: LD_INT 1
76325: PUSH
76326: EMPTY
76327: LIST
76328: LIST
76329: PUSH
76330: LD_INT 1
76332: NEG
76333: PUSH
76334: LD_INT 0
76336: PUSH
76337: EMPTY
76338: LIST
76339: LIST
76340: PUSH
76341: LD_INT 1
76343: NEG
76344: PUSH
76345: LD_INT 1
76347: NEG
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 1
76355: NEG
76356: PUSH
76357: LD_INT 2
76359: NEG
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 0
76367: PUSH
76368: LD_INT 2
76370: NEG
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 1
76378: PUSH
76379: LD_INT 1
76381: NEG
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: LD_INT 2
76389: PUSH
76390: LD_INT 0
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: LD_INT 2
76399: PUSH
76400: LD_INT 1
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: PUSH
76407: LD_INT 2
76409: PUSH
76410: LD_INT 2
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PUSH
76417: LD_INT 1
76419: PUSH
76420: LD_INT 2
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 0
76429: PUSH
76430: LD_INT 2
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 1
76439: NEG
76440: PUSH
76441: LD_INT 1
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PUSH
76448: LD_INT 2
76450: NEG
76451: PUSH
76452: LD_INT 0
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PUSH
76459: LD_INT 2
76461: NEG
76462: PUSH
76463: LD_INT 1
76465: NEG
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 2
76473: NEG
76474: PUSH
76475: LD_INT 2
76477: NEG
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: LIST
76487: LIST
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: LIST
76493: LIST
76494: LIST
76495: LIST
76496: LIST
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: LIST
76502: LIST
76503: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76504: LD_ADDR_VAR 0 56
76508: PUSH
76509: LD_INT 0
76511: PUSH
76512: LD_INT 0
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: LD_INT 0
76521: PUSH
76522: LD_INT 1
76524: NEG
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 1
76532: PUSH
76533: LD_INT 0
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: LD_INT 1
76542: PUSH
76543: LD_INT 1
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: PUSH
76550: LD_INT 0
76552: PUSH
76553: LD_INT 1
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: LD_INT 1
76562: NEG
76563: PUSH
76564: LD_INT 0
76566: PUSH
76567: EMPTY
76568: LIST
76569: LIST
76570: PUSH
76571: LD_INT 1
76573: NEG
76574: PUSH
76575: LD_INT 1
76577: NEG
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: LD_INT 1
76585: NEG
76586: PUSH
76587: LD_INT 2
76589: NEG
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PUSH
76595: LD_INT 0
76597: PUSH
76598: LD_INT 2
76600: NEG
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: PUSH
76606: LD_INT 1
76608: PUSH
76609: LD_INT 1
76611: NEG
76612: PUSH
76613: EMPTY
76614: LIST
76615: LIST
76616: PUSH
76617: LD_INT 2
76619: PUSH
76620: LD_INT 0
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: PUSH
76627: LD_INT 2
76629: PUSH
76630: LD_INT 1
76632: PUSH
76633: EMPTY
76634: LIST
76635: LIST
76636: PUSH
76637: LD_INT 2
76639: PUSH
76640: LD_INT 2
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: LD_INT 1
76649: PUSH
76650: LD_INT 2
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PUSH
76657: LD_INT 0
76659: PUSH
76660: LD_INT 2
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 1
76669: NEG
76670: PUSH
76671: LD_INT 1
76673: PUSH
76674: EMPTY
76675: LIST
76676: LIST
76677: PUSH
76678: LD_INT 2
76680: NEG
76681: PUSH
76682: LD_INT 0
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: PUSH
76689: LD_INT 2
76691: NEG
76692: PUSH
76693: LD_INT 1
76695: NEG
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: LD_INT 2
76703: NEG
76704: PUSH
76705: LD_INT 2
76707: NEG
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: LIST
76717: LIST
76718: LIST
76719: LIST
76720: LIST
76721: LIST
76722: LIST
76723: LIST
76724: LIST
76725: LIST
76726: LIST
76727: LIST
76728: LIST
76729: LIST
76730: LIST
76731: LIST
76732: LIST
76733: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76734: LD_ADDR_VAR 0 57
76738: PUSH
76739: LD_INT 0
76741: PUSH
76742: LD_INT 0
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: PUSH
76749: LD_INT 0
76751: PUSH
76752: LD_INT 1
76754: NEG
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PUSH
76760: LD_INT 1
76762: PUSH
76763: LD_INT 0
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: PUSH
76770: LD_INT 1
76772: PUSH
76773: LD_INT 1
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 0
76782: PUSH
76783: LD_INT 1
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: PUSH
76790: LD_INT 1
76792: NEG
76793: PUSH
76794: LD_INT 0
76796: PUSH
76797: EMPTY
76798: LIST
76799: LIST
76800: PUSH
76801: LD_INT 1
76803: NEG
76804: PUSH
76805: LD_INT 1
76807: NEG
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 1
76815: NEG
76816: PUSH
76817: LD_INT 2
76819: NEG
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: PUSH
76825: LD_INT 0
76827: PUSH
76828: LD_INT 2
76830: NEG
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 1
76838: PUSH
76839: LD_INT 1
76841: NEG
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: PUSH
76847: LD_INT 2
76849: PUSH
76850: LD_INT 0
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: PUSH
76857: LD_INT 2
76859: PUSH
76860: LD_INT 1
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: LD_INT 2
76869: PUSH
76870: LD_INT 2
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: PUSH
76877: LD_INT 1
76879: PUSH
76880: LD_INT 2
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: LD_INT 0
76889: PUSH
76890: LD_INT 2
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: PUSH
76897: LD_INT 1
76899: NEG
76900: PUSH
76901: LD_INT 1
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: PUSH
76908: LD_INT 2
76910: NEG
76911: PUSH
76912: LD_INT 0
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: LD_INT 2
76921: NEG
76922: PUSH
76923: LD_INT 1
76925: NEG
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: PUSH
76931: LD_INT 2
76933: NEG
76934: PUSH
76935: LD_INT 2
76937: NEG
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: PUSH
76943: EMPTY
76944: LIST
76945: LIST
76946: LIST
76947: LIST
76948: LIST
76949: LIST
76950: LIST
76951: LIST
76952: LIST
76953: LIST
76954: LIST
76955: LIST
76956: LIST
76957: LIST
76958: LIST
76959: LIST
76960: LIST
76961: LIST
76962: LIST
76963: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76964: LD_ADDR_VAR 0 58
76968: PUSH
76969: LD_INT 0
76971: PUSH
76972: LD_INT 0
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 0
76981: PUSH
76982: LD_INT 1
76984: NEG
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 1
76992: PUSH
76993: LD_INT 0
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: LD_INT 1
77002: PUSH
77003: LD_INT 1
77005: PUSH
77006: EMPTY
77007: LIST
77008: LIST
77009: PUSH
77010: LD_INT 0
77012: PUSH
77013: LD_INT 1
77015: PUSH
77016: EMPTY
77017: LIST
77018: LIST
77019: PUSH
77020: LD_INT 1
77022: NEG
77023: PUSH
77024: LD_INT 0
77026: PUSH
77027: EMPTY
77028: LIST
77029: LIST
77030: PUSH
77031: LD_INT 1
77033: NEG
77034: PUSH
77035: LD_INT 1
77037: NEG
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: PUSH
77043: LD_INT 1
77045: NEG
77046: PUSH
77047: LD_INT 2
77049: NEG
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: PUSH
77055: LD_INT 0
77057: PUSH
77058: LD_INT 2
77060: NEG
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 1
77068: PUSH
77069: LD_INT 1
77071: NEG
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: LD_INT 2
77079: PUSH
77080: LD_INT 0
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PUSH
77087: LD_INT 2
77089: PUSH
77090: LD_INT 1
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 2
77099: PUSH
77100: LD_INT 2
77102: PUSH
77103: EMPTY
77104: LIST
77105: LIST
77106: PUSH
77107: LD_INT 1
77109: PUSH
77110: LD_INT 2
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 0
77119: PUSH
77120: LD_INT 2
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 1
77129: NEG
77130: PUSH
77131: LD_INT 1
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: LD_INT 2
77140: NEG
77141: PUSH
77142: LD_INT 0
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 2
77151: NEG
77152: PUSH
77153: LD_INT 1
77155: NEG
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: LD_INT 2
77163: NEG
77164: PUSH
77165: LD_INT 2
77167: NEG
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: LIST
77177: LIST
77178: LIST
77179: LIST
77180: LIST
77181: LIST
77182: LIST
77183: LIST
77184: LIST
77185: LIST
77186: LIST
77187: LIST
77188: LIST
77189: LIST
77190: LIST
77191: LIST
77192: LIST
77193: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77194: LD_ADDR_VAR 0 59
77198: PUSH
77199: LD_INT 0
77201: PUSH
77202: LD_INT 0
77204: PUSH
77205: EMPTY
77206: LIST
77207: LIST
77208: PUSH
77209: LD_INT 0
77211: PUSH
77212: LD_INT 1
77214: NEG
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: PUSH
77220: LD_INT 1
77222: PUSH
77223: LD_INT 0
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: LD_INT 1
77232: PUSH
77233: LD_INT 1
77235: PUSH
77236: EMPTY
77237: LIST
77238: LIST
77239: PUSH
77240: LD_INT 0
77242: PUSH
77243: LD_INT 1
77245: PUSH
77246: EMPTY
77247: LIST
77248: LIST
77249: PUSH
77250: LD_INT 1
77252: NEG
77253: PUSH
77254: LD_INT 0
77256: PUSH
77257: EMPTY
77258: LIST
77259: LIST
77260: PUSH
77261: LD_INT 1
77263: NEG
77264: PUSH
77265: LD_INT 1
77267: NEG
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: PUSH
77273: EMPTY
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: LIST
77280: LIST
77281: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77282: LD_ADDR_VAR 0 60
77286: PUSH
77287: LD_INT 0
77289: PUSH
77290: LD_INT 0
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: PUSH
77297: LD_INT 0
77299: PUSH
77300: LD_INT 1
77302: NEG
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 1
77310: PUSH
77311: LD_INT 0
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 1
77320: PUSH
77321: LD_INT 1
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PUSH
77328: LD_INT 0
77330: PUSH
77331: LD_INT 1
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 1
77340: NEG
77341: PUSH
77342: LD_INT 0
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 1
77351: NEG
77352: PUSH
77353: LD_INT 1
77355: NEG
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: LIST
77365: LIST
77366: LIST
77367: LIST
77368: LIST
77369: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77370: LD_ADDR_VAR 0 61
77374: PUSH
77375: LD_INT 0
77377: PUSH
77378: LD_INT 0
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PUSH
77385: LD_INT 0
77387: PUSH
77388: LD_INT 1
77390: NEG
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: LD_INT 1
77398: PUSH
77399: LD_INT 0
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 1
77408: PUSH
77409: LD_INT 1
77411: PUSH
77412: EMPTY
77413: LIST
77414: LIST
77415: PUSH
77416: LD_INT 0
77418: PUSH
77419: LD_INT 1
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PUSH
77426: LD_INT 1
77428: NEG
77429: PUSH
77430: LD_INT 0
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: LD_INT 1
77439: NEG
77440: PUSH
77441: LD_INT 1
77443: NEG
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: LIST
77453: LIST
77454: LIST
77455: LIST
77456: LIST
77457: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77458: LD_ADDR_VAR 0 62
77462: PUSH
77463: LD_INT 0
77465: PUSH
77466: LD_INT 0
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: PUSH
77473: LD_INT 0
77475: PUSH
77476: LD_INT 1
77478: NEG
77479: PUSH
77480: EMPTY
77481: LIST
77482: LIST
77483: PUSH
77484: LD_INT 1
77486: PUSH
77487: LD_INT 0
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: PUSH
77494: LD_INT 1
77496: PUSH
77497: LD_INT 1
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: LD_INT 0
77506: PUSH
77507: LD_INT 1
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 1
77516: NEG
77517: PUSH
77518: LD_INT 0
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 1
77527: NEG
77528: PUSH
77529: LD_INT 1
77531: NEG
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: LIST
77541: LIST
77542: LIST
77543: LIST
77544: LIST
77545: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77546: LD_ADDR_VAR 0 63
77550: PUSH
77551: LD_INT 0
77553: PUSH
77554: LD_INT 0
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: LD_INT 0
77563: PUSH
77564: LD_INT 1
77566: NEG
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PUSH
77572: LD_INT 1
77574: PUSH
77575: LD_INT 0
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 1
77584: PUSH
77585: LD_INT 1
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: LD_INT 0
77594: PUSH
77595: LD_INT 1
77597: PUSH
77598: EMPTY
77599: LIST
77600: LIST
77601: PUSH
77602: LD_INT 1
77604: NEG
77605: PUSH
77606: LD_INT 0
77608: PUSH
77609: EMPTY
77610: LIST
77611: LIST
77612: PUSH
77613: LD_INT 1
77615: NEG
77616: PUSH
77617: LD_INT 1
77619: NEG
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: LIST
77629: LIST
77630: LIST
77631: LIST
77632: LIST
77633: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77634: LD_ADDR_VAR 0 64
77638: PUSH
77639: LD_INT 0
77641: PUSH
77642: LD_INT 0
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: PUSH
77649: LD_INT 0
77651: PUSH
77652: LD_INT 1
77654: NEG
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 1
77662: PUSH
77663: LD_INT 0
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: LD_INT 1
77672: PUSH
77673: LD_INT 1
77675: PUSH
77676: EMPTY
77677: LIST
77678: LIST
77679: PUSH
77680: LD_INT 0
77682: PUSH
77683: LD_INT 1
77685: PUSH
77686: EMPTY
77687: LIST
77688: LIST
77689: PUSH
77690: LD_INT 1
77692: NEG
77693: PUSH
77694: LD_INT 0
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: PUSH
77701: LD_INT 1
77703: NEG
77704: PUSH
77705: LD_INT 1
77707: NEG
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: LIST
77721: ST_TO_ADDR
// end ; 1 :
77722: GO 83619
77724: LD_INT 1
77726: DOUBLE
77727: EQUAL
77728: IFTRUE 77732
77730: GO 80355
77732: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77733: LD_ADDR_VAR 0 11
77737: PUSH
77738: LD_INT 1
77740: NEG
77741: PUSH
77742: LD_INT 3
77744: NEG
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: LD_INT 0
77752: PUSH
77753: LD_INT 3
77755: NEG
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PUSH
77761: LD_INT 1
77763: PUSH
77764: LD_INT 2
77766: NEG
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: LIST
77776: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77777: LD_ADDR_VAR 0 12
77781: PUSH
77782: LD_INT 2
77784: PUSH
77785: LD_INT 1
77787: NEG
77788: PUSH
77789: EMPTY
77790: LIST
77791: LIST
77792: PUSH
77793: LD_INT 3
77795: PUSH
77796: LD_INT 0
77798: PUSH
77799: EMPTY
77800: LIST
77801: LIST
77802: PUSH
77803: LD_INT 3
77805: PUSH
77806: LD_INT 1
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: LIST
77817: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77818: LD_ADDR_VAR 0 13
77822: PUSH
77823: LD_INT 3
77825: PUSH
77826: LD_INT 2
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 3
77835: PUSH
77836: LD_INT 3
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: LD_INT 2
77845: PUSH
77846: LD_INT 3
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: EMPTY
77854: LIST
77855: LIST
77856: LIST
77857: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77858: LD_ADDR_VAR 0 14
77862: PUSH
77863: LD_INT 1
77865: PUSH
77866: LD_INT 3
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 0
77875: PUSH
77876: LD_INT 3
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 1
77885: NEG
77886: PUSH
77887: LD_INT 2
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: EMPTY
77895: LIST
77896: LIST
77897: LIST
77898: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77899: LD_ADDR_VAR 0 15
77903: PUSH
77904: LD_INT 2
77906: NEG
77907: PUSH
77908: LD_INT 1
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 3
77917: NEG
77918: PUSH
77919: LD_INT 0
77921: PUSH
77922: EMPTY
77923: LIST
77924: LIST
77925: PUSH
77926: LD_INT 3
77928: NEG
77929: PUSH
77930: LD_INT 1
77932: NEG
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: LIST
77942: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77943: LD_ADDR_VAR 0 16
77947: PUSH
77948: LD_INT 2
77950: NEG
77951: PUSH
77952: LD_INT 3
77954: NEG
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PUSH
77960: LD_INT 3
77962: NEG
77963: PUSH
77964: LD_INT 2
77966: NEG
77967: PUSH
77968: EMPTY
77969: LIST
77970: LIST
77971: PUSH
77972: LD_INT 3
77974: NEG
77975: PUSH
77976: LD_INT 3
77978: NEG
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: LIST
77988: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77989: LD_ADDR_VAR 0 17
77993: PUSH
77994: LD_INT 1
77996: NEG
77997: PUSH
77998: LD_INT 3
78000: NEG
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: PUSH
78006: LD_INT 0
78008: PUSH
78009: LD_INT 3
78011: NEG
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: LD_INT 1
78019: PUSH
78020: LD_INT 2
78022: NEG
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: LIST
78032: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78033: LD_ADDR_VAR 0 18
78037: PUSH
78038: LD_INT 2
78040: PUSH
78041: LD_INT 1
78043: NEG
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 3
78051: PUSH
78052: LD_INT 0
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 3
78061: PUSH
78062: LD_INT 1
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: LIST
78073: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78074: LD_ADDR_VAR 0 19
78078: PUSH
78079: LD_INT 3
78081: PUSH
78082: LD_INT 2
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PUSH
78089: LD_INT 3
78091: PUSH
78092: LD_INT 3
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: PUSH
78099: LD_INT 2
78101: PUSH
78102: LD_INT 3
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: LIST
78113: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78114: LD_ADDR_VAR 0 20
78118: PUSH
78119: LD_INT 1
78121: PUSH
78122: LD_INT 3
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 0
78131: PUSH
78132: LD_INT 3
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: LD_INT 1
78141: NEG
78142: PUSH
78143: LD_INT 2
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: LIST
78154: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78155: LD_ADDR_VAR 0 21
78159: PUSH
78160: LD_INT 2
78162: NEG
78163: PUSH
78164: LD_INT 1
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: PUSH
78171: LD_INT 3
78173: NEG
78174: PUSH
78175: LD_INT 0
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 3
78184: NEG
78185: PUSH
78186: LD_INT 1
78188: NEG
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: EMPTY
78195: LIST
78196: LIST
78197: LIST
78198: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78199: LD_ADDR_VAR 0 22
78203: PUSH
78204: LD_INT 2
78206: NEG
78207: PUSH
78208: LD_INT 3
78210: NEG
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: PUSH
78216: LD_INT 3
78218: NEG
78219: PUSH
78220: LD_INT 2
78222: NEG
78223: PUSH
78224: EMPTY
78225: LIST
78226: LIST
78227: PUSH
78228: LD_INT 3
78230: NEG
78231: PUSH
78232: LD_INT 3
78234: NEG
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: EMPTY
78241: LIST
78242: LIST
78243: LIST
78244: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78245: LD_ADDR_VAR 0 23
78249: PUSH
78250: LD_INT 0
78252: PUSH
78253: LD_INT 3
78255: NEG
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: LD_INT 1
78263: NEG
78264: PUSH
78265: LD_INT 4
78267: NEG
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: LD_INT 1
78275: PUSH
78276: LD_INT 3
78278: NEG
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: EMPTY
78285: LIST
78286: LIST
78287: LIST
78288: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78289: LD_ADDR_VAR 0 24
78293: PUSH
78294: LD_INT 3
78296: PUSH
78297: LD_INT 0
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PUSH
78304: LD_INT 3
78306: PUSH
78307: LD_INT 1
78309: NEG
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: LD_INT 4
78317: PUSH
78318: LD_INT 1
78320: PUSH
78321: EMPTY
78322: LIST
78323: LIST
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: LIST
78329: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78330: LD_ADDR_VAR 0 25
78334: PUSH
78335: LD_INT 3
78337: PUSH
78338: LD_INT 3
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: PUSH
78345: LD_INT 4
78347: PUSH
78348: LD_INT 3
78350: PUSH
78351: EMPTY
78352: LIST
78353: LIST
78354: PUSH
78355: LD_INT 3
78357: PUSH
78358: LD_INT 4
78360: PUSH
78361: EMPTY
78362: LIST
78363: LIST
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: LIST
78369: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78370: LD_ADDR_VAR 0 26
78374: PUSH
78375: LD_INT 0
78377: PUSH
78378: LD_INT 3
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 1
78387: PUSH
78388: LD_INT 4
78390: PUSH
78391: EMPTY
78392: LIST
78393: LIST
78394: PUSH
78395: LD_INT 1
78397: NEG
78398: PUSH
78399: LD_INT 3
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: LIST
78410: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78411: LD_ADDR_VAR 0 27
78415: PUSH
78416: LD_INT 3
78418: NEG
78419: PUSH
78420: LD_INT 0
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: PUSH
78427: LD_INT 3
78429: NEG
78430: PUSH
78431: LD_INT 1
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 4
78440: NEG
78441: PUSH
78442: LD_INT 1
78444: NEG
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: LIST
78454: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78455: LD_ADDR_VAR 0 28
78459: PUSH
78460: LD_INT 3
78462: NEG
78463: PUSH
78464: LD_INT 3
78466: NEG
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 3
78474: NEG
78475: PUSH
78476: LD_INT 4
78478: NEG
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: PUSH
78484: LD_INT 4
78486: NEG
78487: PUSH
78488: LD_INT 3
78490: NEG
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: LIST
78500: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78501: LD_ADDR_VAR 0 29
78505: PUSH
78506: LD_INT 1
78508: NEG
78509: PUSH
78510: LD_INT 3
78512: NEG
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PUSH
78518: LD_INT 0
78520: PUSH
78521: LD_INT 3
78523: NEG
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 1
78531: PUSH
78532: LD_INT 2
78534: NEG
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 1
78542: NEG
78543: PUSH
78544: LD_INT 4
78546: NEG
78547: PUSH
78548: EMPTY
78549: LIST
78550: LIST
78551: PUSH
78552: LD_INT 0
78554: PUSH
78555: LD_INT 4
78557: NEG
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PUSH
78563: LD_INT 1
78565: PUSH
78566: LD_INT 3
78568: NEG
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 1
78576: NEG
78577: PUSH
78578: LD_INT 5
78580: NEG
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 0
78588: PUSH
78589: LD_INT 5
78591: NEG
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PUSH
78597: LD_INT 1
78599: PUSH
78600: LD_INT 4
78602: NEG
78603: PUSH
78604: EMPTY
78605: LIST
78606: LIST
78607: PUSH
78608: LD_INT 1
78610: NEG
78611: PUSH
78612: LD_INT 6
78614: NEG
78615: PUSH
78616: EMPTY
78617: LIST
78618: LIST
78619: PUSH
78620: LD_INT 0
78622: PUSH
78623: LD_INT 6
78625: NEG
78626: PUSH
78627: EMPTY
78628: LIST
78629: LIST
78630: PUSH
78631: LD_INT 1
78633: PUSH
78634: LD_INT 5
78636: NEG
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: LIST
78646: LIST
78647: LIST
78648: LIST
78649: LIST
78650: LIST
78651: LIST
78652: LIST
78653: LIST
78654: LIST
78655: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78656: LD_ADDR_VAR 0 30
78660: PUSH
78661: LD_INT 2
78663: PUSH
78664: LD_INT 1
78666: NEG
78667: PUSH
78668: EMPTY
78669: LIST
78670: LIST
78671: PUSH
78672: LD_INT 3
78674: PUSH
78675: LD_INT 0
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 3
78684: PUSH
78685: LD_INT 1
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 3
78694: PUSH
78695: LD_INT 1
78697: NEG
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 4
78705: PUSH
78706: LD_INT 0
78708: PUSH
78709: EMPTY
78710: LIST
78711: LIST
78712: PUSH
78713: LD_INT 4
78715: PUSH
78716: LD_INT 1
78718: PUSH
78719: EMPTY
78720: LIST
78721: LIST
78722: PUSH
78723: LD_INT 4
78725: PUSH
78726: LD_INT 1
78728: NEG
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: PUSH
78734: LD_INT 5
78736: PUSH
78737: LD_INT 0
78739: PUSH
78740: EMPTY
78741: LIST
78742: LIST
78743: PUSH
78744: LD_INT 5
78746: PUSH
78747: LD_INT 1
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 5
78756: PUSH
78757: LD_INT 1
78759: NEG
78760: PUSH
78761: EMPTY
78762: LIST
78763: LIST
78764: PUSH
78765: LD_INT 6
78767: PUSH
78768: LD_INT 0
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 6
78777: PUSH
78778: LD_INT 1
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: EMPTY
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78799: LD_ADDR_VAR 0 31
78803: PUSH
78804: LD_INT 3
78806: PUSH
78807: LD_INT 2
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: PUSH
78814: LD_INT 3
78816: PUSH
78817: LD_INT 3
78819: PUSH
78820: EMPTY
78821: LIST
78822: LIST
78823: PUSH
78824: LD_INT 2
78826: PUSH
78827: LD_INT 3
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: LD_INT 4
78836: PUSH
78837: LD_INT 3
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 4
78846: PUSH
78847: LD_INT 4
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: PUSH
78854: LD_INT 3
78856: PUSH
78857: LD_INT 4
78859: PUSH
78860: EMPTY
78861: LIST
78862: LIST
78863: PUSH
78864: LD_INT 5
78866: PUSH
78867: LD_INT 4
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: PUSH
78874: LD_INT 5
78876: PUSH
78877: LD_INT 5
78879: PUSH
78880: EMPTY
78881: LIST
78882: LIST
78883: PUSH
78884: LD_INT 4
78886: PUSH
78887: LD_INT 5
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: PUSH
78894: LD_INT 6
78896: PUSH
78897: LD_INT 5
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: LD_INT 6
78906: PUSH
78907: LD_INT 6
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 5
78916: PUSH
78917: LD_INT 6
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: LIST
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: LIST
78935: LIST
78936: LIST
78937: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78938: LD_ADDR_VAR 0 32
78942: PUSH
78943: LD_INT 1
78945: PUSH
78946: LD_INT 3
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 0
78955: PUSH
78956: LD_INT 3
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 1
78965: NEG
78966: PUSH
78967: LD_INT 2
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 1
78976: PUSH
78977: LD_INT 4
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PUSH
78984: LD_INT 0
78986: PUSH
78987: LD_INT 4
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 1
78996: NEG
78997: PUSH
78998: LD_INT 3
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 1
79007: PUSH
79008: LD_INT 5
79010: PUSH
79011: EMPTY
79012: LIST
79013: LIST
79014: PUSH
79015: LD_INT 0
79017: PUSH
79018: LD_INT 5
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: PUSH
79025: LD_INT 1
79027: NEG
79028: PUSH
79029: LD_INT 4
79031: PUSH
79032: EMPTY
79033: LIST
79034: LIST
79035: PUSH
79036: LD_INT 1
79038: PUSH
79039: LD_INT 6
79041: PUSH
79042: EMPTY
79043: LIST
79044: LIST
79045: PUSH
79046: LD_INT 0
79048: PUSH
79049: LD_INT 6
79051: PUSH
79052: EMPTY
79053: LIST
79054: LIST
79055: PUSH
79056: LD_INT 1
79058: NEG
79059: PUSH
79060: LD_INT 5
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: LIST
79077: LIST
79078: LIST
79079: LIST
79080: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79081: LD_ADDR_VAR 0 33
79085: PUSH
79086: LD_INT 2
79088: NEG
79089: PUSH
79090: LD_INT 1
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: PUSH
79097: LD_INT 3
79099: NEG
79100: PUSH
79101: LD_INT 0
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: LD_INT 3
79110: NEG
79111: PUSH
79112: LD_INT 1
79114: NEG
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 3
79122: NEG
79123: PUSH
79124: LD_INT 1
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: PUSH
79131: LD_INT 4
79133: NEG
79134: PUSH
79135: LD_INT 0
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: LD_INT 4
79144: NEG
79145: PUSH
79146: LD_INT 1
79148: NEG
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: LD_INT 4
79156: NEG
79157: PUSH
79158: LD_INT 1
79160: PUSH
79161: EMPTY
79162: LIST
79163: LIST
79164: PUSH
79165: LD_INT 5
79167: NEG
79168: PUSH
79169: LD_INT 0
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 5
79178: NEG
79179: PUSH
79180: LD_INT 1
79182: NEG
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PUSH
79188: LD_INT 5
79190: NEG
79191: PUSH
79192: LD_INT 1
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PUSH
79199: LD_INT 6
79201: NEG
79202: PUSH
79203: LD_INT 0
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 6
79212: NEG
79213: PUSH
79214: LD_INT 1
79216: NEG
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: LIST
79226: LIST
79227: LIST
79228: LIST
79229: LIST
79230: LIST
79231: LIST
79232: LIST
79233: LIST
79234: LIST
79235: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79236: LD_ADDR_VAR 0 34
79240: PUSH
79241: LD_INT 2
79243: NEG
79244: PUSH
79245: LD_INT 3
79247: NEG
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 3
79255: NEG
79256: PUSH
79257: LD_INT 2
79259: NEG
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: LD_INT 3
79267: NEG
79268: PUSH
79269: LD_INT 3
79271: NEG
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 3
79279: NEG
79280: PUSH
79281: LD_INT 4
79283: NEG
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 4
79291: NEG
79292: PUSH
79293: LD_INT 3
79295: NEG
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PUSH
79301: LD_INT 4
79303: NEG
79304: PUSH
79305: LD_INT 4
79307: NEG
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 4
79315: NEG
79316: PUSH
79317: LD_INT 5
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 5
79327: NEG
79328: PUSH
79329: LD_INT 4
79331: NEG
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 5
79339: NEG
79340: PUSH
79341: LD_INT 5
79343: NEG
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 5
79351: NEG
79352: PUSH
79353: LD_INT 6
79355: NEG
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 6
79363: NEG
79364: PUSH
79365: LD_INT 5
79367: NEG
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: LD_INT 6
79375: NEG
79376: PUSH
79377: LD_INT 6
79379: NEG
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79399: LD_ADDR_VAR 0 41
79403: PUSH
79404: LD_INT 0
79406: PUSH
79407: LD_INT 2
79409: NEG
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 1
79417: NEG
79418: PUSH
79419: LD_INT 3
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 1
79429: PUSH
79430: LD_INT 2
79432: NEG
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: LIST
79442: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79443: LD_ADDR_VAR 0 42
79447: PUSH
79448: LD_INT 2
79450: PUSH
79451: LD_INT 0
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 2
79460: PUSH
79461: LD_INT 1
79463: NEG
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 3
79471: PUSH
79472: LD_INT 1
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: LIST
79483: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79484: LD_ADDR_VAR 0 43
79488: PUSH
79489: LD_INT 2
79491: PUSH
79492: LD_INT 2
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 3
79501: PUSH
79502: LD_INT 2
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: LD_INT 2
79511: PUSH
79512: LD_INT 3
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: LIST
79523: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79524: LD_ADDR_VAR 0 44
79528: PUSH
79529: LD_INT 0
79531: PUSH
79532: LD_INT 2
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 1
79541: PUSH
79542: LD_INT 3
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 1
79551: NEG
79552: PUSH
79553: LD_INT 2
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: LIST
79564: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79565: LD_ADDR_VAR 0 45
79569: PUSH
79570: LD_INT 2
79572: NEG
79573: PUSH
79574: LD_INT 0
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: LD_INT 2
79583: NEG
79584: PUSH
79585: LD_INT 1
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: LD_INT 3
79594: NEG
79595: PUSH
79596: LD_INT 1
79598: NEG
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: LIST
79608: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79609: LD_ADDR_VAR 0 46
79613: PUSH
79614: LD_INT 2
79616: NEG
79617: PUSH
79618: LD_INT 2
79620: NEG
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 2
79628: NEG
79629: PUSH
79630: LD_INT 3
79632: NEG
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 3
79640: NEG
79641: PUSH
79642: LD_INT 2
79644: NEG
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: LIST
79654: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79655: LD_ADDR_VAR 0 47
79659: PUSH
79660: LD_INT 2
79662: NEG
79663: PUSH
79664: LD_INT 3
79666: NEG
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 1
79674: NEG
79675: PUSH
79676: LD_INT 3
79678: NEG
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79688: LD_ADDR_VAR 0 48
79692: PUSH
79693: LD_INT 1
79695: PUSH
79696: LD_INT 2
79698: NEG
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 2
79706: PUSH
79707: LD_INT 1
79709: NEG
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79719: LD_ADDR_VAR 0 49
79723: PUSH
79724: LD_INT 3
79726: PUSH
79727: LD_INT 1
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 3
79736: PUSH
79737: LD_INT 2
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79748: LD_ADDR_VAR 0 50
79752: PUSH
79753: LD_INT 2
79755: PUSH
79756: LD_INT 3
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 1
79765: PUSH
79766: LD_INT 3
79768: PUSH
79769: EMPTY
79770: LIST
79771: LIST
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79777: LD_ADDR_VAR 0 51
79781: PUSH
79782: LD_INT 1
79784: NEG
79785: PUSH
79786: LD_INT 2
79788: PUSH
79789: EMPTY
79790: LIST
79791: LIST
79792: PUSH
79793: LD_INT 2
79795: NEG
79796: PUSH
79797: LD_INT 1
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79808: LD_ADDR_VAR 0 52
79812: PUSH
79813: LD_INT 3
79815: NEG
79816: PUSH
79817: LD_INT 1
79819: NEG
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 3
79827: NEG
79828: PUSH
79829: LD_INT 2
79831: NEG
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79841: LD_ADDR_VAR 0 53
79845: PUSH
79846: LD_INT 1
79848: NEG
79849: PUSH
79850: LD_INT 3
79852: NEG
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 0
79860: PUSH
79861: LD_INT 3
79863: NEG
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 1
79871: PUSH
79872: LD_INT 2
79874: NEG
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: LIST
79884: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79885: LD_ADDR_VAR 0 54
79889: PUSH
79890: LD_INT 2
79892: PUSH
79893: LD_INT 1
79895: NEG
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: PUSH
79901: LD_INT 3
79903: PUSH
79904: LD_INT 0
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: LD_INT 3
79913: PUSH
79914: LD_INT 1
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: LIST
79925: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79926: LD_ADDR_VAR 0 55
79930: PUSH
79931: LD_INT 3
79933: PUSH
79934: LD_INT 2
79936: PUSH
79937: EMPTY
79938: LIST
79939: LIST
79940: PUSH
79941: LD_INT 3
79943: PUSH
79944: LD_INT 3
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 2
79953: PUSH
79954: LD_INT 3
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: LIST
79965: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79966: LD_ADDR_VAR 0 56
79970: PUSH
79971: LD_INT 1
79973: PUSH
79974: LD_INT 3
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: LD_INT 0
79983: PUSH
79984: LD_INT 3
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 1
79993: NEG
79994: PUSH
79995: LD_INT 2
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: LIST
80006: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80007: LD_ADDR_VAR 0 57
80011: PUSH
80012: LD_INT 2
80014: NEG
80015: PUSH
80016: LD_INT 1
80018: PUSH
80019: EMPTY
80020: LIST
80021: LIST
80022: PUSH
80023: LD_INT 3
80025: NEG
80026: PUSH
80027: LD_INT 0
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 3
80036: NEG
80037: PUSH
80038: LD_INT 1
80040: NEG
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: EMPTY
80047: LIST
80048: LIST
80049: LIST
80050: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80051: LD_ADDR_VAR 0 58
80055: PUSH
80056: LD_INT 2
80058: NEG
80059: PUSH
80060: LD_INT 3
80062: NEG
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 3
80070: NEG
80071: PUSH
80072: LD_INT 2
80074: NEG
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 3
80082: NEG
80083: PUSH
80084: LD_INT 3
80086: NEG
80087: PUSH
80088: EMPTY
80089: LIST
80090: LIST
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: LIST
80096: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80097: LD_ADDR_VAR 0 59
80101: PUSH
80102: LD_INT 1
80104: NEG
80105: PUSH
80106: LD_INT 2
80108: NEG
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 0
80116: PUSH
80117: LD_INT 2
80119: NEG
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 1
80127: PUSH
80128: LD_INT 1
80130: NEG
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: LIST
80140: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80141: LD_ADDR_VAR 0 60
80145: PUSH
80146: LD_INT 1
80148: PUSH
80149: LD_INT 1
80151: NEG
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PUSH
80157: LD_INT 2
80159: PUSH
80160: LD_INT 0
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 2
80169: PUSH
80170: LD_INT 1
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: LIST
80181: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80182: LD_ADDR_VAR 0 61
80186: PUSH
80187: LD_INT 2
80189: PUSH
80190: LD_INT 1
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 2
80199: PUSH
80200: LD_INT 2
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 1
80209: PUSH
80210: LD_INT 2
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: LIST
80221: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80222: LD_ADDR_VAR 0 62
80226: PUSH
80227: LD_INT 1
80229: PUSH
80230: LD_INT 2
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 0
80239: PUSH
80240: LD_INT 2
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 1
80249: NEG
80250: PUSH
80251: LD_INT 1
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: LIST
80262: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80263: LD_ADDR_VAR 0 63
80267: PUSH
80268: LD_INT 1
80270: NEG
80271: PUSH
80272: LD_INT 1
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 2
80281: NEG
80282: PUSH
80283: LD_INT 0
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 2
80292: NEG
80293: PUSH
80294: LD_INT 1
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: LIST
80306: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80307: LD_ADDR_VAR 0 64
80311: PUSH
80312: LD_INT 1
80314: NEG
80315: PUSH
80316: LD_INT 2
80318: NEG
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 2
80326: NEG
80327: PUSH
80328: LD_INT 1
80330: NEG
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 2
80338: NEG
80339: PUSH
80340: LD_INT 2
80342: NEG
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: LIST
80352: ST_TO_ADDR
// end ; 2 :
80353: GO 83619
80355: LD_INT 2
80357: DOUBLE
80358: EQUAL
80359: IFTRUE 80363
80361: GO 83618
80363: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80364: LD_ADDR_VAR 0 29
80368: PUSH
80369: LD_INT 4
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 4
80381: PUSH
80382: LD_INT 1
80384: NEG
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 5
80392: PUSH
80393: LD_INT 0
80395: PUSH
80396: EMPTY
80397: LIST
80398: LIST
80399: PUSH
80400: LD_INT 5
80402: PUSH
80403: LD_INT 1
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: PUSH
80410: LD_INT 4
80412: PUSH
80413: LD_INT 1
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 3
80422: PUSH
80423: LD_INT 0
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: PUSH
80430: LD_INT 3
80432: PUSH
80433: LD_INT 1
80435: NEG
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: PUSH
80441: LD_INT 3
80443: PUSH
80444: LD_INT 2
80446: NEG
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: LD_INT 5
80454: PUSH
80455: LD_INT 2
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 3
80464: PUSH
80465: LD_INT 3
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: LD_INT 3
80474: PUSH
80475: LD_INT 2
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 4
80484: PUSH
80485: LD_INT 3
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PUSH
80492: LD_INT 4
80494: PUSH
80495: LD_INT 4
80497: PUSH
80498: EMPTY
80499: LIST
80500: LIST
80501: PUSH
80502: LD_INT 3
80504: PUSH
80505: LD_INT 4
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 2
80514: PUSH
80515: LD_INT 3
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: PUSH
80522: LD_INT 2
80524: PUSH
80525: LD_INT 2
80527: PUSH
80528: EMPTY
80529: LIST
80530: LIST
80531: PUSH
80532: LD_INT 4
80534: PUSH
80535: LD_INT 2
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 2
80544: PUSH
80545: LD_INT 4
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: LD_INT 0
80554: PUSH
80555: LD_INT 4
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 0
80564: PUSH
80565: LD_INT 3
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: PUSH
80572: LD_INT 1
80574: PUSH
80575: LD_INT 4
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: PUSH
80582: LD_INT 1
80584: PUSH
80585: LD_INT 5
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: PUSH
80592: LD_INT 0
80594: PUSH
80595: LD_INT 5
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 1
80604: NEG
80605: PUSH
80606: LD_INT 4
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: PUSH
80613: LD_INT 1
80615: NEG
80616: PUSH
80617: LD_INT 3
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 2
80626: PUSH
80627: LD_INT 5
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: PUSH
80634: LD_INT 2
80636: NEG
80637: PUSH
80638: LD_INT 3
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 3
80647: NEG
80648: PUSH
80649: LD_INT 0
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 3
80658: NEG
80659: PUSH
80660: LD_INT 1
80662: NEG
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 2
80670: NEG
80671: PUSH
80672: LD_INT 0
80674: PUSH
80675: EMPTY
80676: LIST
80677: LIST
80678: PUSH
80679: LD_INT 2
80681: NEG
80682: PUSH
80683: LD_INT 1
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 3
80692: NEG
80693: PUSH
80694: LD_INT 1
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 4
80703: NEG
80704: PUSH
80705: LD_INT 0
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 4
80714: NEG
80715: PUSH
80716: LD_INT 1
80718: NEG
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 4
80726: NEG
80727: PUSH
80728: LD_INT 2
80730: NEG
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 2
80738: NEG
80739: PUSH
80740: LD_INT 2
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PUSH
80747: LD_INT 4
80749: NEG
80750: PUSH
80751: LD_INT 4
80753: NEG
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 4
80761: NEG
80762: PUSH
80763: LD_INT 5
80765: NEG
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 3
80773: NEG
80774: PUSH
80775: LD_INT 4
80777: NEG
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: PUSH
80783: LD_INT 3
80785: NEG
80786: PUSH
80787: LD_INT 3
80789: NEG
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 4
80797: NEG
80798: PUSH
80799: LD_INT 3
80801: NEG
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 5
80809: NEG
80810: PUSH
80811: LD_INT 4
80813: NEG
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 5
80821: NEG
80822: PUSH
80823: LD_INT 5
80825: NEG
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: PUSH
80831: LD_INT 3
80833: NEG
80834: PUSH
80835: LD_INT 5
80837: NEG
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 5
80845: NEG
80846: PUSH
80847: LD_INT 3
80849: NEG
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: LIST
80859: LIST
80860: LIST
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: LIST
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: LIST
80871: LIST
80872: LIST
80873: LIST
80874: LIST
80875: LIST
80876: LIST
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: LIST
80883: LIST
80884: LIST
80885: LIST
80886: LIST
80887: LIST
80888: LIST
80889: LIST
80890: LIST
80891: LIST
80892: LIST
80893: LIST
80894: LIST
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80902: LD_ADDR_VAR 0 30
80906: PUSH
80907: LD_INT 4
80909: PUSH
80910: LD_INT 4
80912: PUSH
80913: EMPTY
80914: LIST
80915: LIST
80916: PUSH
80917: LD_INT 4
80919: PUSH
80920: LD_INT 3
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 5
80929: PUSH
80930: LD_INT 4
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 5
80939: PUSH
80940: LD_INT 5
80942: PUSH
80943: EMPTY
80944: LIST
80945: LIST
80946: PUSH
80947: LD_INT 4
80949: PUSH
80950: LD_INT 5
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 3
80959: PUSH
80960: LD_INT 4
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PUSH
80967: LD_INT 3
80969: PUSH
80970: LD_INT 3
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 5
80979: PUSH
80980: LD_INT 3
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 3
80989: PUSH
80990: LD_INT 5
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 0
80999: PUSH
81000: LD_INT 3
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 0
81009: PUSH
81010: LD_INT 2
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 1
81019: PUSH
81020: LD_INT 3
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 1
81029: PUSH
81030: LD_INT 4
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: LD_INT 0
81039: PUSH
81040: LD_INT 4
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 1
81049: NEG
81050: PUSH
81051: LD_INT 3
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 1
81060: NEG
81061: PUSH
81062: LD_INT 2
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 2
81071: PUSH
81072: LD_INT 4
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 2
81081: NEG
81082: PUSH
81083: LD_INT 2
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 4
81092: NEG
81093: PUSH
81094: LD_INT 0
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 4
81103: NEG
81104: PUSH
81105: LD_INT 1
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 3
81115: NEG
81116: PUSH
81117: LD_INT 0
81119: PUSH
81120: EMPTY
81121: LIST
81122: LIST
81123: PUSH
81124: LD_INT 3
81126: NEG
81127: PUSH
81128: LD_INT 1
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 4
81137: NEG
81138: PUSH
81139: LD_INT 1
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 5
81148: NEG
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 5
81159: NEG
81160: PUSH
81161: LD_INT 1
81163: NEG
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 5
81171: NEG
81172: PUSH
81173: LD_INT 2
81175: NEG
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: PUSH
81181: LD_INT 3
81183: NEG
81184: PUSH
81185: LD_INT 2
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 3
81194: NEG
81195: PUSH
81196: LD_INT 3
81198: NEG
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 3
81206: NEG
81207: PUSH
81208: LD_INT 4
81210: NEG
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 2
81218: NEG
81219: PUSH
81220: LD_INT 3
81222: NEG
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 2
81230: NEG
81231: PUSH
81232: LD_INT 2
81234: NEG
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 3
81242: NEG
81243: PUSH
81244: LD_INT 2
81246: NEG
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 4
81254: NEG
81255: PUSH
81256: LD_INT 3
81258: NEG
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 4
81266: NEG
81267: PUSH
81268: LD_INT 4
81270: NEG
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: LD_INT 2
81278: NEG
81279: PUSH
81280: LD_INT 4
81282: NEG
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 4
81290: NEG
81291: PUSH
81292: LD_INT 2
81294: NEG
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 0
81302: PUSH
81303: LD_INT 4
81305: NEG
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: LD_INT 0
81313: PUSH
81314: LD_INT 5
81316: NEG
81317: PUSH
81318: EMPTY
81319: LIST
81320: LIST
81321: PUSH
81322: LD_INT 1
81324: PUSH
81325: LD_INT 4
81327: NEG
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PUSH
81333: LD_INT 1
81335: PUSH
81336: LD_INT 3
81338: NEG
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 0
81346: PUSH
81347: LD_INT 3
81349: NEG
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 1
81357: NEG
81358: PUSH
81359: LD_INT 4
81361: NEG
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 1
81369: NEG
81370: PUSH
81371: LD_INT 5
81373: NEG
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 2
81381: PUSH
81382: LD_INT 3
81384: NEG
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 2
81392: NEG
81393: PUSH
81394: LD_INT 5
81396: NEG
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: LIST
81406: LIST
81407: LIST
81408: LIST
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: LIST
81424: LIST
81425: LIST
81426: LIST
81427: LIST
81428: LIST
81429: LIST
81430: LIST
81431: LIST
81432: LIST
81433: LIST
81434: LIST
81435: LIST
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: LIST
81442: LIST
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81449: LD_ADDR_VAR 0 31
81453: PUSH
81454: LD_INT 0
81456: PUSH
81457: LD_INT 4
81459: PUSH
81460: EMPTY
81461: LIST
81462: LIST
81463: PUSH
81464: LD_INT 0
81466: PUSH
81467: LD_INT 3
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 1
81476: PUSH
81477: LD_INT 4
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 1
81486: PUSH
81487: LD_INT 5
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 0
81496: PUSH
81497: LD_INT 5
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 1
81506: NEG
81507: PUSH
81508: LD_INT 4
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 1
81517: NEG
81518: PUSH
81519: LD_INT 3
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 2
81528: PUSH
81529: LD_INT 5
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 2
81538: NEG
81539: PUSH
81540: LD_INT 3
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 3
81549: NEG
81550: PUSH
81551: LD_INT 0
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 3
81560: NEG
81561: PUSH
81562: LD_INT 1
81564: NEG
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: LD_INT 2
81572: NEG
81573: PUSH
81574: LD_INT 0
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: PUSH
81581: LD_INT 2
81583: NEG
81584: PUSH
81585: LD_INT 1
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 3
81594: NEG
81595: PUSH
81596: LD_INT 1
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: PUSH
81603: LD_INT 4
81605: NEG
81606: PUSH
81607: LD_INT 0
81609: PUSH
81610: EMPTY
81611: LIST
81612: LIST
81613: PUSH
81614: LD_INT 4
81616: NEG
81617: PUSH
81618: LD_INT 1
81620: NEG
81621: PUSH
81622: EMPTY
81623: LIST
81624: LIST
81625: PUSH
81626: LD_INT 4
81628: NEG
81629: PUSH
81630: LD_INT 2
81632: NEG
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 2
81640: NEG
81641: PUSH
81642: LD_INT 2
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 4
81651: NEG
81652: PUSH
81653: LD_INT 4
81655: NEG
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 4
81663: NEG
81664: PUSH
81665: LD_INT 5
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 3
81675: NEG
81676: PUSH
81677: LD_INT 4
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 3
81687: NEG
81688: PUSH
81689: LD_INT 3
81691: NEG
81692: PUSH
81693: EMPTY
81694: LIST
81695: LIST
81696: PUSH
81697: LD_INT 4
81699: NEG
81700: PUSH
81701: LD_INT 3
81703: NEG
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 5
81711: NEG
81712: PUSH
81713: LD_INT 4
81715: NEG
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 5
81723: NEG
81724: PUSH
81725: LD_INT 5
81727: NEG
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 3
81735: NEG
81736: PUSH
81737: LD_INT 5
81739: NEG
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 5
81747: NEG
81748: PUSH
81749: LD_INT 3
81751: NEG
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 0
81759: PUSH
81760: LD_INT 3
81762: NEG
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 0
81770: PUSH
81771: LD_INT 4
81773: NEG
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 1
81781: PUSH
81782: LD_INT 3
81784: NEG
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: PUSH
81790: LD_INT 1
81792: PUSH
81793: LD_INT 2
81795: NEG
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: PUSH
81801: LD_INT 0
81803: PUSH
81804: LD_INT 2
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 1
81814: NEG
81815: PUSH
81816: LD_INT 3
81818: NEG
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: PUSH
81824: LD_INT 1
81826: NEG
81827: PUSH
81828: LD_INT 4
81830: NEG
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 2
81838: PUSH
81839: LD_INT 2
81841: NEG
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PUSH
81847: LD_INT 2
81849: NEG
81850: PUSH
81851: LD_INT 4
81853: NEG
81854: PUSH
81855: EMPTY
81856: LIST
81857: LIST
81858: PUSH
81859: LD_INT 4
81861: PUSH
81862: LD_INT 0
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PUSH
81869: LD_INT 4
81871: PUSH
81872: LD_INT 1
81874: NEG
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 5
81882: PUSH
81883: LD_INT 0
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 5
81892: PUSH
81893: LD_INT 1
81895: PUSH
81896: EMPTY
81897: LIST
81898: LIST
81899: PUSH
81900: LD_INT 4
81902: PUSH
81903: LD_INT 1
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 3
81912: PUSH
81913: LD_INT 0
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 3
81922: PUSH
81923: LD_INT 1
81925: NEG
81926: PUSH
81927: EMPTY
81928: LIST
81929: LIST
81930: PUSH
81931: LD_INT 3
81933: PUSH
81934: LD_INT 2
81936: NEG
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: LD_INT 5
81944: PUSH
81945: LD_INT 2
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: PUSH
81952: EMPTY
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: LIST
81958: LIST
81959: LIST
81960: LIST
81961: LIST
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: LIST
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81999: LD_ADDR_VAR 0 32
82003: PUSH
82004: LD_INT 4
82006: NEG
82007: PUSH
82008: LD_INT 0
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 4
82017: NEG
82018: PUSH
82019: LD_INT 1
82021: NEG
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 3
82029: NEG
82030: PUSH
82031: LD_INT 0
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 3
82040: NEG
82041: PUSH
82042: LD_INT 1
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 4
82051: NEG
82052: PUSH
82053: LD_INT 1
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 5
82062: NEG
82063: PUSH
82064: LD_INT 0
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 5
82073: NEG
82074: PUSH
82075: LD_INT 1
82077: NEG
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 5
82085: NEG
82086: PUSH
82087: LD_INT 2
82089: NEG
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: PUSH
82095: LD_INT 3
82097: NEG
82098: PUSH
82099: LD_INT 2
82101: PUSH
82102: EMPTY
82103: LIST
82104: LIST
82105: PUSH
82106: LD_INT 3
82108: NEG
82109: PUSH
82110: LD_INT 3
82112: NEG
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 3
82120: NEG
82121: PUSH
82122: LD_INT 4
82124: NEG
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 2
82132: NEG
82133: PUSH
82134: LD_INT 3
82136: NEG
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 2
82144: NEG
82145: PUSH
82146: LD_INT 2
82148: NEG
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 3
82156: NEG
82157: PUSH
82158: LD_INT 2
82160: NEG
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: LD_INT 4
82168: NEG
82169: PUSH
82170: LD_INT 3
82172: NEG
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 4
82180: NEG
82181: PUSH
82182: LD_INT 4
82184: NEG
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 2
82192: NEG
82193: PUSH
82194: LD_INT 4
82196: NEG
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: LD_INT 4
82204: NEG
82205: PUSH
82206: LD_INT 2
82208: NEG
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 0
82216: PUSH
82217: LD_INT 4
82219: NEG
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 0
82227: PUSH
82228: LD_INT 5
82230: NEG
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_INT 1
82238: PUSH
82239: LD_INT 4
82241: NEG
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: LD_INT 1
82249: PUSH
82250: LD_INT 3
82252: NEG
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: LD_INT 3
82263: NEG
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 1
82271: NEG
82272: PUSH
82273: LD_INT 4
82275: NEG
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 1
82283: NEG
82284: PUSH
82285: LD_INT 5
82287: NEG
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 2
82295: PUSH
82296: LD_INT 3
82298: NEG
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: PUSH
82304: LD_INT 2
82306: NEG
82307: PUSH
82308: LD_INT 5
82310: NEG
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PUSH
82316: LD_INT 3
82318: PUSH
82319: LD_INT 0
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 3
82328: PUSH
82329: LD_INT 1
82331: NEG
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 4
82339: PUSH
82340: LD_INT 0
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 4
82349: PUSH
82350: LD_INT 1
82352: PUSH
82353: EMPTY
82354: LIST
82355: LIST
82356: PUSH
82357: LD_INT 3
82359: PUSH
82360: LD_INT 1
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 2
82369: PUSH
82370: LD_INT 0
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 2
82379: PUSH
82380: LD_INT 1
82382: NEG
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: LD_INT 2
82390: PUSH
82391: LD_INT 2
82393: NEG
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 4
82401: PUSH
82402: LD_INT 2
82404: PUSH
82405: EMPTY
82406: LIST
82407: LIST
82408: PUSH
82409: LD_INT 4
82411: PUSH
82412: LD_INT 4
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: PUSH
82419: LD_INT 4
82421: PUSH
82422: LD_INT 3
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 5
82431: PUSH
82432: LD_INT 4
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 5
82441: PUSH
82442: LD_INT 5
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 4
82451: PUSH
82452: LD_INT 5
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 3
82461: PUSH
82462: LD_INT 4
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 3
82471: PUSH
82472: LD_INT 3
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 5
82481: PUSH
82482: LD_INT 3
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 3
82491: PUSH
82492: LD_INT 5
82494: PUSH
82495: EMPTY
82496: LIST
82497: LIST
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: LIST
82505: LIST
82506: LIST
82507: LIST
82508: LIST
82509: LIST
82510: LIST
82511: LIST
82512: LIST
82513: LIST
82514: LIST
82515: LIST
82516: LIST
82517: LIST
82518: LIST
82519: LIST
82520: LIST
82521: LIST
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82546: LD_ADDR_VAR 0 33
82550: PUSH
82551: LD_INT 4
82553: NEG
82554: PUSH
82555: LD_INT 4
82557: NEG
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 4
82565: NEG
82566: PUSH
82567: LD_INT 5
82569: NEG
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 3
82577: NEG
82578: PUSH
82579: LD_INT 4
82581: NEG
82582: PUSH
82583: EMPTY
82584: LIST
82585: LIST
82586: PUSH
82587: LD_INT 3
82589: NEG
82590: PUSH
82591: LD_INT 3
82593: NEG
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 4
82601: NEG
82602: PUSH
82603: LD_INT 3
82605: NEG
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 5
82613: NEG
82614: PUSH
82615: LD_INT 4
82617: NEG
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 5
82625: NEG
82626: PUSH
82627: LD_INT 5
82629: NEG
82630: PUSH
82631: EMPTY
82632: LIST
82633: LIST
82634: PUSH
82635: LD_INT 3
82637: NEG
82638: PUSH
82639: LD_INT 5
82641: NEG
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 5
82649: NEG
82650: PUSH
82651: LD_INT 3
82653: NEG
82654: PUSH
82655: EMPTY
82656: LIST
82657: LIST
82658: PUSH
82659: LD_INT 0
82661: PUSH
82662: LD_INT 3
82664: NEG
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 0
82672: PUSH
82673: LD_INT 4
82675: NEG
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 1
82683: PUSH
82684: LD_INT 3
82686: NEG
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 1
82694: PUSH
82695: LD_INT 2
82697: NEG
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 0
82705: PUSH
82706: LD_INT 2
82708: NEG
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: NEG
82717: PUSH
82718: LD_INT 3
82720: NEG
82721: PUSH
82722: EMPTY
82723: LIST
82724: LIST
82725: PUSH
82726: LD_INT 1
82728: NEG
82729: PUSH
82730: LD_INT 4
82732: NEG
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: LD_INT 2
82740: PUSH
82741: LD_INT 2
82743: NEG
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 2
82751: NEG
82752: PUSH
82753: LD_INT 4
82755: NEG
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 4
82763: PUSH
82764: LD_INT 0
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 4
82773: PUSH
82774: LD_INT 1
82776: NEG
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 5
82784: PUSH
82785: LD_INT 0
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 5
82794: PUSH
82795: LD_INT 1
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: LD_INT 4
82804: PUSH
82805: LD_INT 1
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 3
82814: PUSH
82815: LD_INT 0
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 3
82824: PUSH
82825: LD_INT 1
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 3
82835: PUSH
82836: LD_INT 2
82838: NEG
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 5
82846: PUSH
82847: LD_INT 2
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 3
82856: PUSH
82857: LD_INT 3
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: PUSH
82864: LD_INT 3
82866: PUSH
82867: LD_INT 2
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: PUSH
82874: LD_INT 4
82876: PUSH
82877: LD_INT 3
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 4
82886: PUSH
82887: LD_INT 4
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 3
82896: PUSH
82897: LD_INT 4
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: PUSH
82904: LD_INT 2
82906: PUSH
82907: LD_INT 3
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: LD_INT 2
82916: PUSH
82917: LD_INT 2
82919: PUSH
82920: EMPTY
82921: LIST
82922: LIST
82923: PUSH
82924: LD_INT 4
82926: PUSH
82927: LD_INT 2
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 2
82936: PUSH
82937: LD_INT 4
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 0
82946: PUSH
82947: LD_INT 4
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: PUSH
82954: LD_INT 0
82956: PUSH
82957: LD_INT 3
82959: PUSH
82960: EMPTY
82961: LIST
82962: LIST
82963: PUSH
82964: LD_INT 1
82966: PUSH
82967: LD_INT 4
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 1
82976: PUSH
82977: LD_INT 5
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: PUSH
82984: LD_INT 0
82986: PUSH
82987: LD_INT 5
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 1
82996: NEG
82997: PUSH
82998: LD_INT 4
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: PUSH
83005: LD_INT 1
83007: NEG
83008: PUSH
83009: LD_INT 3
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 2
83018: PUSH
83019: LD_INT 5
83021: PUSH
83022: EMPTY
83023: LIST
83024: LIST
83025: PUSH
83026: LD_INT 2
83028: NEG
83029: PUSH
83030: LD_INT 3
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: LIST
83061: LIST
83062: LIST
83063: LIST
83064: LIST
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83084: LD_ADDR_VAR 0 34
83088: PUSH
83089: LD_INT 0
83091: PUSH
83092: LD_INT 4
83094: NEG
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: LD_INT 0
83102: PUSH
83103: LD_INT 5
83105: NEG
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: PUSH
83111: LD_INT 1
83113: PUSH
83114: LD_INT 4
83116: NEG
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: PUSH
83122: LD_INT 1
83124: PUSH
83125: LD_INT 3
83127: NEG
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 0
83135: PUSH
83136: LD_INT 3
83138: NEG
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: PUSH
83144: LD_INT 1
83146: NEG
83147: PUSH
83148: LD_INT 4
83150: NEG
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PUSH
83156: LD_INT 1
83158: NEG
83159: PUSH
83160: LD_INT 5
83162: NEG
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 2
83170: PUSH
83171: LD_INT 3
83173: NEG
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 2
83181: NEG
83182: PUSH
83183: LD_INT 5
83185: NEG
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 3
83193: PUSH
83194: LD_INT 0
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 3
83203: PUSH
83204: LD_INT 1
83206: NEG
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 4
83214: PUSH
83215: LD_INT 0
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: PUSH
83222: LD_INT 4
83224: PUSH
83225: LD_INT 1
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_INT 3
83234: PUSH
83235: LD_INT 1
83237: PUSH
83238: EMPTY
83239: LIST
83240: LIST
83241: PUSH
83242: LD_INT 2
83244: PUSH
83245: LD_INT 0
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PUSH
83252: LD_INT 2
83254: PUSH
83255: LD_INT 1
83257: NEG
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 2
83265: PUSH
83266: LD_INT 2
83268: NEG
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 4
83276: PUSH
83277: LD_INT 2
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 4
83286: PUSH
83287: LD_INT 4
83289: PUSH
83290: EMPTY
83291: LIST
83292: LIST
83293: PUSH
83294: LD_INT 4
83296: PUSH
83297: LD_INT 3
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: LD_INT 5
83306: PUSH
83307: LD_INT 4
83309: PUSH
83310: EMPTY
83311: LIST
83312: LIST
83313: PUSH
83314: LD_INT 5
83316: PUSH
83317: LD_INT 5
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: PUSH
83324: LD_INT 4
83326: PUSH
83327: LD_INT 5
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 3
83336: PUSH
83337: LD_INT 4
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 3
83346: PUSH
83347: LD_INT 3
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 5
83356: PUSH
83357: LD_INT 3
83359: PUSH
83360: EMPTY
83361: LIST
83362: LIST
83363: PUSH
83364: LD_INT 3
83366: PUSH
83367: LD_INT 5
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: PUSH
83374: LD_INT 0
83376: PUSH
83377: LD_INT 3
83379: PUSH
83380: EMPTY
83381: LIST
83382: LIST
83383: PUSH
83384: LD_INT 0
83386: PUSH
83387: LD_INT 2
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: PUSH
83394: LD_INT 1
83396: PUSH
83397: LD_INT 3
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: PUSH
83404: LD_INT 1
83406: PUSH
83407: LD_INT 4
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: LD_INT 0
83416: PUSH
83417: LD_INT 4
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 1
83426: NEG
83427: PUSH
83428: LD_INT 3
83430: PUSH
83431: EMPTY
83432: LIST
83433: LIST
83434: PUSH
83435: LD_INT 1
83437: NEG
83438: PUSH
83439: LD_INT 2
83441: PUSH
83442: EMPTY
83443: LIST
83444: LIST
83445: PUSH
83446: LD_INT 2
83448: PUSH
83449: LD_INT 4
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 2
83458: NEG
83459: PUSH
83460: LD_INT 2
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 4
83469: NEG
83470: PUSH
83471: LD_INT 0
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: PUSH
83478: LD_INT 4
83480: NEG
83481: PUSH
83482: LD_INT 1
83484: NEG
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PUSH
83490: LD_INT 3
83492: NEG
83493: PUSH
83494: LD_INT 0
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 3
83503: NEG
83504: PUSH
83505: LD_INT 1
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 4
83514: NEG
83515: PUSH
83516: LD_INT 1
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 5
83525: NEG
83526: PUSH
83527: LD_INT 0
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 5
83536: NEG
83537: PUSH
83538: LD_INT 1
83540: NEG
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 5
83548: NEG
83549: PUSH
83550: LD_INT 2
83552: NEG
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 3
83560: NEG
83561: PUSH
83562: LD_INT 2
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: LIST
83590: LIST
83591: LIST
83592: LIST
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: ST_TO_ADDR
// end ; end ;
83616: GO 83619
83618: POP
// case btype of b_depot , b_warehouse :
83619: LD_VAR 0 1
83623: PUSH
83624: LD_INT 0
83626: DOUBLE
83627: EQUAL
83628: IFTRUE 83638
83630: LD_INT 1
83632: DOUBLE
83633: EQUAL
83634: IFTRUE 83638
83636: GO 83839
83638: POP
// case nation of nation_american :
83639: LD_VAR 0 5
83643: PUSH
83644: LD_INT 1
83646: DOUBLE
83647: EQUAL
83648: IFTRUE 83652
83650: GO 83708
83652: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83653: LD_ADDR_VAR 0 9
83657: PUSH
83658: LD_VAR 0 11
83662: PUSH
83663: LD_VAR 0 12
83667: PUSH
83668: LD_VAR 0 13
83672: PUSH
83673: LD_VAR 0 14
83677: PUSH
83678: LD_VAR 0 15
83682: PUSH
83683: LD_VAR 0 16
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: PUSH
83696: LD_VAR 0 4
83700: PUSH
83701: LD_INT 1
83703: PLUS
83704: ARRAY
83705: ST_TO_ADDR
83706: GO 83837
83708: LD_INT 2
83710: DOUBLE
83711: EQUAL
83712: IFTRUE 83716
83714: GO 83772
83716: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83717: LD_ADDR_VAR 0 9
83721: PUSH
83722: LD_VAR 0 17
83726: PUSH
83727: LD_VAR 0 18
83731: PUSH
83732: LD_VAR 0 19
83736: PUSH
83737: LD_VAR 0 20
83741: PUSH
83742: LD_VAR 0 21
83746: PUSH
83747: LD_VAR 0 22
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: PUSH
83760: LD_VAR 0 4
83764: PUSH
83765: LD_INT 1
83767: PLUS
83768: ARRAY
83769: ST_TO_ADDR
83770: GO 83837
83772: LD_INT 3
83774: DOUBLE
83775: EQUAL
83776: IFTRUE 83780
83778: GO 83836
83780: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83781: LD_ADDR_VAR 0 9
83785: PUSH
83786: LD_VAR 0 23
83790: PUSH
83791: LD_VAR 0 24
83795: PUSH
83796: LD_VAR 0 25
83800: PUSH
83801: LD_VAR 0 26
83805: PUSH
83806: LD_VAR 0 27
83810: PUSH
83811: LD_VAR 0 28
83815: PUSH
83816: EMPTY
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: PUSH
83824: LD_VAR 0 4
83828: PUSH
83829: LD_INT 1
83831: PLUS
83832: ARRAY
83833: ST_TO_ADDR
83834: GO 83837
83836: POP
83837: GO 84392
83839: LD_INT 2
83841: DOUBLE
83842: EQUAL
83843: IFTRUE 83853
83845: LD_INT 3
83847: DOUBLE
83848: EQUAL
83849: IFTRUE 83853
83851: GO 83909
83853: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83854: LD_ADDR_VAR 0 9
83858: PUSH
83859: LD_VAR 0 29
83863: PUSH
83864: LD_VAR 0 30
83868: PUSH
83869: LD_VAR 0 31
83873: PUSH
83874: LD_VAR 0 32
83878: PUSH
83879: LD_VAR 0 33
83883: PUSH
83884: LD_VAR 0 34
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: LIST
83896: PUSH
83897: LD_VAR 0 4
83901: PUSH
83902: LD_INT 1
83904: PLUS
83905: ARRAY
83906: ST_TO_ADDR
83907: GO 84392
83909: LD_INT 16
83911: DOUBLE
83912: EQUAL
83913: IFTRUE 83971
83915: LD_INT 17
83917: DOUBLE
83918: EQUAL
83919: IFTRUE 83971
83921: LD_INT 18
83923: DOUBLE
83924: EQUAL
83925: IFTRUE 83971
83927: LD_INT 19
83929: DOUBLE
83930: EQUAL
83931: IFTRUE 83971
83933: LD_INT 22
83935: DOUBLE
83936: EQUAL
83937: IFTRUE 83971
83939: LD_INT 20
83941: DOUBLE
83942: EQUAL
83943: IFTRUE 83971
83945: LD_INT 21
83947: DOUBLE
83948: EQUAL
83949: IFTRUE 83971
83951: LD_INT 23
83953: DOUBLE
83954: EQUAL
83955: IFTRUE 83971
83957: LD_INT 24
83959: DOUBLE
83960: EQUAL
83961: IFTRUE 83971
83963: LD_INT 25
83965: DOUBLE
83966: EQUAL
83967: IFTRUE 83971
83969: GO 84027
83971: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83972: LD_ADDR_VAR 0 9
83976: PUSH
83977: LD_VAR 0 35
83981: PUSH
83982: LD_VAR 0 36
83986: PUSH
83987: LD_VAR 0 37
83991: PUSH
83992: LD_VAR 0 38
83996: PUSH
83997: LD_VAR 0 39
84001: PUSH
84002: LD_VAR 0 40
84006: PUSH
84007: EMPTY
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: PUSH
84015: LD_VAR 0 4
84019: PUSH
84020: LD_INT 1
84022: PLUS
84023: ARRAY
84024: ST_TO_ADDR
84025: GO 84392
84027: LD_INT 6
84029: DOUBLE
84030: EQUAL
84031: IFTRUE 84083
84033: LD_INT 7
84035: DOUBLE
84036: EQUAL
84037: IFTRUE 84083
84039: LD_INT 8
84041: DOUBLE
84042: EQUAL
84043: IFTRUE 84083
84045: LD_INT 13
84047: DOUBLE
84048: EQUAL
84049: IFTRUE 84083
84051: LD_INT 12
84053: DOUBLE
84054: EQUAL
84055: IFTRUE 84083
84057: LD_INT 15
84059: DOUBLE
84060: EQUAL
84061: IFTRUE 84083
84063: LD_INT 11
84065: DOUBLE
84066: EQUAL
84067: IFTRUE 84083
84069: LD_INT 14
84071: DOUBLE
84072: EQUAL
84073: IFTRUE 84083
84075: LD_INT 10
84077: DOUBLE
84078: EQUAL
84079: IFTRUE 84083
84081: GO 84139
84083: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84084: LD_ADDR_VAR 0 9
84088: PUSH
84089: LD_VAR 0 41
84093: PUSH
84094: LD_VAR 0 42
84098: PUSH
84099: LD_VAR 0 43
84103: PUSH
84104: LD_VAR 0 44
84108: PUSH
84109: LD_VAR 0 45
84113: PUSH
84114: LD_VAR 0 46
84118: PUSH
84119: EMPTY
84120: LIST
84121: LIST
84122: LIST
84123: LIST
84124: LIST
84125: LIST
84126: PUSH
84127: LD_VAR 0 4
84131: PUSH
84132: LD_INT 1
84134: PLUS
84135: ARRAY
84136: ST_TO_ADDR
84137: GO 84392
84139: LD_INT 36
84141: DOUBLE
84142: EQUAL
84143: IFTRUE 84147
84145: GO 84203
84147: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84148: LD_ADDR_VAR 0 9
84152: PUSH
84153: LD_VAR 0 47
84157: PUSH
84158: LD_VAR 0 48
84162: PUSH
84163: LD_VAR 0 49
84167: PUSH
84168: LD_VAR 0 50
84172: PUSH
84173: LD_VAR 0 51
84177: PUSH
84178: LD_VAR 0 52
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: LIST
84187: LIST
84188: LIST
84189: LIST
84190: PUSH
84191: LD_VAR 0 4
84195: PUSH
84196: LD_INT 1
84198: PLUS
84199: ARRAY
84200: ST_TO_ADDR
84201: GO 84392
84203: LD_INT 4
84205: DOUBLE
84206: EQUAL
84207: IFTRUE 84229
84209: LD_INT 5
84211: DOUBLE
84212: EQUAL
84213: IFTRUE 84229
84215: LD_INT 34
84217: DOUBLE
84218: EQUAL
84219: IFTRUE 84229
84221: LD_INT 37
84223: DOUBLE
84224: EQUAL
84225: IFTRUE 84229
84227: GO 84285
84229: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84230: LD_ADDR_VAR 0 9
84234: PUSH
84235: LD_VAR 0 53
84239: PUSH
84240: LD_VAR 0 54
84244: PUSH
84245: LD_VAR 0 55
84249: PUSH
84250: LD_VAR 0 56
84254: PUSH
84255: LD_VAR 0 57
84259: PUSH
84260: LD_VAR 0 58
84264: PUSH
84265: EMPTY
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: PUSH
84273: LD_VAR 0 4
84277: PUSH
84278: LD_INT 1
84280: PLUS
84281: ARRAY
84282: ST_TO_ADDR
84283: GO 84392
84285: LD_INT 31
84287: DOUBLE
84288: EQUAL
84289: IFTRUE 84335
84291: LD_INT 32
84293: DOUBLE
84294: EQUAL
84295: IFTRUE 84335
84297: LD_INT 33
84299: DOUBLE
84300: EQUAL
84301: IFTRUE 84335
84303: LD_INT 27
84305: DOUBLE
84306: EQUAL
84307: IFTRUE 84335
84309: LD_INT 26
84311: DOUBLE
84312: EQUAL
84313: IFTRUE 84335
84315: LD_INT 28
84317: DOUBLE
84318: EQUAL
84319: IFTRUE 84335
84321: LD_INT 29
84323: DOUBLE
84324: EQUAL
84325: IFTRUE 84335
84327: LD_INT 30
84329: DOUBLE
84330: EQUAL
84331: IFTRUE 84335
84333: GO 84391
84335: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84336: LD_ADDR_VAR 0 9
84340: PUSH
84341: LD_VAR 0 59
84345: PUSH
84346: LD_VAR 0 60
84350: PUSH
84351: LD_VAR 0 61
84355: PUSH
84356: LD_VAR 0 62
84360: PUSH
84361: LD_VAR 0 63
84365: PUSH
84366: LD_VAR 0 64
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: PUSH
84379: LD_VAR 0 4
84383: PUSH
84384: LD_INT 1
84386: PLUS
84387: ARRAY
84388: ST_TO_ADDR
84389: GO 84392
84391: POP
// temp_list2 = [ ] ;
84392: LD_ADDR_VAR 0 10
84396: PUSH
84397: EMPTY
84398: ST_TO_ADDR
// for i in temp_list do
84399: LD_ADDR_VAR 0 8
84403: PUSH
84404: LD_VAR 0 9
84408: PUSH
84409: FOR_IN
84410: IFFALSE 84462
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84412: LD_ADDR_VAR 0 10
84416: PUSH
84417: LD_VAR 0 10
84421: PUSH
84422: LD_VAR 0 8
84426: PUSH
84427: LD_INT 1
84429: ARRAY
84430: PUSH
84431: LD_VAR 0 2
84435: PLUS
84436: PUSH
84437: LD_VAR 0 8
84441: PUSH
84442: LD_INT 2
84444: ARRAY
84445: PUSH
84446: LD_VAR 0 3
84450: PLUS
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: EMPTY
84457: LIST
84458: ADD
84459: ST_TO_ADDR
84460: GO 84409
84462: POP
84463: POP
// result = temp_list2 ;
84464: LD_ADDR_VAR 0 7
84468: PUSH
84469: LD_VAR 0 10
84473: ST_TO_ADDR
// end ;
84474: LD_VAR 0 7
84478: RET
// export function EnemyInRange ( unit , dist ) ; begin
84479: LD_INT 0
84481: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84482: LD_ADDR_VAR 0 3
84486: PUSH
84487: LD_VAR 0 1
84491: PPUSH
84492: CALL_OW 255
84496: PPUSH
84497: LD_VAR 0 1
84501: PPUSH
84502: CALL_OW 250
84506: PPUSH
84507: LD_VAR 0 1
84511: PPUSH
84512: CALL_OW 251
84516: PPUSH
84517: LD_VAR 0 2
84521: PPUSH
84522: CALL 57881 0 4
84526: PUSH
84527: LD_INT 4
84529: ARRAY
84530: ST_TO_ADDR
// end ;
84531: LD_VAR 0 3
84535: RET
// export function PlayerSeeMe ( unit ) ; begin
84536: LD_INT 0
84538: PPUSH
// result := See ( your_side , unit ) ;
84539: LD_ADDR_VAR 0 2
84543: PUSH
84544: LD_OWVAR 2
84548: PPUSH
84549: LD_VAR 0 1
84553: PPUSH
84554: CALL_OW 292
84558: ST_TO_ADDR
// end ;
84559: LD_VAR 0 2
84563: RET
// export function ReverseDir ( unit ) ; begin
84564: LD_INT 0
84566: PPUSH
// if not unit then
84567: LD_VAR 0 1
84571: NOT
84572: IFFALSE 84576
// exit ;
84574: GO 84599
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84576: LD_ADDR_VAR 0 2
84580: PUSH
84581: LD_VAR 0 1
84585: PPUSH
84586: CALL_OW 254
84590: PUSH
84591: LD_INT 3
84593: PLUS
84594: PUSH
84595: LD_INT 6
84597: MOD
84598: ST_TO_ADDR
// end ;
84599: LD_VAR 0 2
84603: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
84604: LD_INT 0
84606: PPUSH
84607: PPUSH
84608: PPUSH
84609: PPUSH
84610: PPUSH
84611: PPUSH
// if not unit or not hexes then
84612: LD_VAR 0 1
84616: NOT
84617: PUSH
84618: LD_VAR 0 2
84622: NOT
84623: OR
84624: IFFALSE 84628
// exit ;
84626: GO 84751
// dist := 9999 ;
84628: LD_ADDR_VAR 0 5
84632: PUSH
84633: LD_INT 9999
84635: ST_TO_ADDR
// for i = 1 to hexes do
84636: LD_ADDR_VAR 0 4
84640: PUSH
84641: DOUBLE
84642: LD_INT 1
84644: DEC
84645: ST_TO_ADDR
84646: LD_VAR 0 2
84650: PUSH
84651: FOR_TO
84652: IFFALSE 84739
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84654: LD_ADDR_VAR 0 6
84658: PUSH
84659: LD_VAR 0 1
84663: PPUSH
84664: LD_VAR 0 2
84668: PUSH
84669: LD_VAR 0 4
84673: ARRAY
84674: PUSH
84675: LD_INT 1
84677: ARRAY
84678: PPUSH
84679: LD_VAR 0 2
84683: PUSH
84684: LD_VAR 0 4
84688: ARRAY
84689: PUSH
84690: LD_INT 2
84692: ARRAY
84693: PPUSH
84694: CALL_OW 297
84698: ST_TO_ADDR
// if tdist < dist then
84699: LD_VAR 0 6
84703: PUSH
84704: LD_VAR 0 5
84708: LESS
84709: IFFALSE 84737
// begin hex := hexes [ i ] ;
84711: LD_ADDR_VAR 0 8
84715: PUSH
84716: LD_VAR 0 2
84720: PUSH
84721: LD_VAR 0 4
84725: ARRAY
84726: ST_TO_ADDR
// dist := tdist ;
84727: LD_ADDR_VAR 0 5
84731: PUSH
84732: LD_VAR 0 6
84736: ST_TO_ADDR
// end ; end ;
84737: GO 84651
84739: POP
84740: POP
// result := hex ;
84741: LD_ADDR_VAR 0 3
84745: PUSH
84746: LD_VAR 0 8
84750: ST_TO_ADDR
// end ;
84751: LD_VAR 0 3
84755: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84756: LD_INT 0
84758: PPUSH
84759: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84760: LD_VAR 0 1
84764: NOT
84765: PUSH
84766: LD_VAR 0 1
84770: PUSH
84771: LD_INT 21
84773: PUSH
84774: LD_INT 2
84776: PUSH
84777: EMPTY
84778: LIST
84779: LIST
84780: PUSH
84781: LD_INT 23
84783: PUSH
84784: LD_INT 2
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: PPUSH
84795: CALL_OW 69
84799: IN
84800: NOT
84801: OR
84802: IFFALSE 84806
// exit ;
84804: GO 84853
// for i = 1 to 3 do
84806: LD_ADDR_VAR 0 3
84810: PUSH
84811: DOUBLE
84812: LD_INT 1
84814: DEC
84815: ST_TO_ADDR
84816: LD_INT 3
84818: PUSH
84819: FOR_TO
84820: IFFALSE 84851
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84822: LD_VAR 0 1
84826: PPUSH
84827: CALL_OW 250
84831: PPUSH
84832: LD_VAR 0 1
84836: PPUSH
84837: CALL_OW 251
84841: PPUSH
84842: LD_INT 1
84844: PPUSH
84845: CALL_OW 453
84849: GO 84819
84851: POP
84852: POP
// end ;
84853: LD_VAR 0 2
84857: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84858: LD_INT 0
84860: PPUSH
84861: PPUSH
84862: PPUSH
84863: PPUSH
84864: PPUSH
84865: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84866: LD_VAR 0 1
84870: NOT
84871: PUSH
84872: LD_VAR 0 2
84876: NOT
84877: OR
84878: PUSH
84879: LD_VAR 0 1
84883: PPUSH
84884: CALL_OW 314
84888: OR
84889: IFFALSE 84893
// exit ;
84891: GO 85334
// x := GetX ( enemy_unit ) ;
84893: LD_ADDR_VAR 0 7
84897: PUSH
84898: LD_VAR 0 2
84902: PPUSH
84903: CALL_OW 250
84907: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84908: LD_ADDR_VAR 0 8
84912: PUSH
84913: LD_VAR 0 2
84917: PPUSH
84918: CALL_OW 251
84922: ST_TO_ADDR
// if not x or not y then
84923: LD_VAR 0 7
84927: NOT
84928: PUSH
84929: LD_VAR 0 8
84933: NOT
84934: OR
84935: IFFALSE 84939
// exit ;
84937: GO 85334
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84939: LD_ADDR_VAR 0 6
84943: PUSH
84944: LD_VAR 0 7
84948: PPUSH
84949: LD_INT 0
84951: PPUSH
84952: LD_INT 4
84954: PPUSH
84955: CALL_OW 272
84959: PUSH
84960: LD_VAR 0 8
84964: PPUSH
84965: LD_INT 0
84967: PPUSH
84968: LD_INT 4
84970: PPUSH
84971: CALL_OW 273
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_VAR 0 7
84984: PPUSH
84985: LD_INT 1
84987: PPUSH
84988: LD_INT 4
84990: PPUSH
84991: CALL_OW 272
84995: PUSH
84996: LD_VAR 0 8
85000: PPUSH
85001: LD_INT 1
85003: PPUSH
85004: LD_INT 4
85006: PPUSH
85007: CALL_OW 273
85011: PUSH
85012: EMPTY
85013: LIST
85014: LIST
85015: PUSH
85016: LD_VAR 0 7
85020: PPUSH
85021: LD_INT 2
85023: PPUSH
85024: LD_INT 4
85026: PPUSH
85027: CALL_OW 272
85031: PUSH
85032: LD_VAR 0 8
85036: PPUSH
85037: LD_INT 2
85039: PPUSH
85040: LD_INT 4
85042: PPUSH
85043: CALL_OW 273
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PUSH
85052: LD_VAR 0 7
85056: PPUSH
85057: LD_INT 3
85059: PPUSH
85060: LD_INT 4
85062: PPUSH
85063: CALL_OW 272
85067: PUSH
85068: LD_VAR 0 8
85072: PPUSH
85073: LD_INT 3
85075: PPUSH
85076: LD_INT 4
85078: PPUSH
85079: CALL_OW 273
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_VAR 0 7
85092: PPUSH
85093: LD_INT 4
85095: PPUSH
85096: LD_INT 4
85098: PPUSH
85099: CALL_OW 272
85103: PUSH
85104: LD_VAR 0 8
85108: PPUSH
85109: LD_INT 4
85111: PPUSH
85112: LD_INT 4
85114: PPUSH
85115: CALL_OW 273
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_VAR 0 7
85128: PPUSH
85129: LD_INT 5
85131: PPUSH
85132: LD_INT 4
85134: PPUSH
85135: CALL_OW 272
85139: PUSH
85140: LD_VAR 0 8
85144: PPUSH
85145: LD_INT 5
85147: PPUSH
85148: LD_INT 4
85150: PPUSH
85151: CALL_OW 273
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: LIST
85164: LIST
85165: LIST
85166: LIST
85167: ST_TO_ADDR
// for i = tmp downto 1 do
85168: LD_ADDR_VAR 0 4
85172: PUSH
85173: DOUBLE
85174: LD_VAR 0 6
85178: INC
85179: ST_TO_ADDR
85180: LD_INT 1
85182: PUSH
85183: FOR_DOWNTO
85184: IFFALSE 85285
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85186: LD_VAR 0 6
85190: PUSH
85191: LD_VAR 0 4
85195: ARRAY
85196: PUSH
85197: LD_INT 1
85199: ARRAY
85200: PPUSH
85201: LD_VAR 0 6
85205: PUSH
85206: LD_VAR 0 4
85210: ARRAY
85211: PUSH
85212: LD_INT 2
85214: ARRAY
85215: PPUSH
85216: CALL_OW 488
85220: NOT
85221: PUSH
85222: LD_VAR 0 6
85226: PUSH
85227: LD_VAR 0 4
85231: ARRAY
85232: PUSH
85233: LD_INT 1
85235: ARRAY
85236: PPUSH
85237: LD_VAR 0 6
85241: PUSH
85242: LD_VAR 0 4
85246: ARRAY
85247: PUSH
85248: LD_INT 2
85250: ARRAY
85251: PPUSH
85252: CALL_OW 428
85256: PUSH
85257: LD_INT 0
85259: NONEQUAL
85260: OR
85261: IFFALSE 85283
// tmp := Delete ( tmp , i ) ;
85263: LD_ADDR_VAR 0 6
85267: PUSH
85268: LD_VAR 0 6
85272: PPUSH
85273: LD_VAR 0 4
85277: PPUSH
85278: CALL_OW 3
85282: ST_TO_ADDR
85283: GO 85183
85285: POP
85286: POP
// j := GetClosestHex ( unit , tmp ) ;
85287: LD_ADDR_VAR 0 5
85291: PUSH
85292: LD_VAR 0 1
85296: PPUSH
85297: LD_VAR 0 6
85301: PPUSH
85302: CALL 84604 0 2
85306: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85307: LD_VAR 0 1
85311: PPUSH
85312: LD_VAR 0 5
85316: PUSH
85317: LD_INT 1
85319: ARRAY
85320: PPUSH
85321: LD_VAR 0 5
85325: PUSH
85326: LD_INT 2
85328: ARRAY
85329: PPUSH
85330: CALL_OW 111
// end ;
85334: LD_VAR 0 3
85338: RET
// export function PrepareApemanSoldier ( ) ; begin
85339: LD_INT 0
85341: PPUSH
// uc_nation := 0 ;
85342: LD_ADDR_OWVAR 21
85346: PUSH
85347: LD_INT 0
85349: ST_TO_ADDR
// hc_sex := sex_male ;
85350: LD_ADDR_OWVAR 27
85354: PUSH
85355: LD_INT 1
85357: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
85358: LD_ADDR_OWVAR 28
85362: PUSH
85363: LD_INT 15
85365: ST_TO_ADDR
// hc_gallery :=  ;
85366: LD_ADDR_OWVAR 33
85370: PUSH
85371: LD_STRING 
85373: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85374: LD_ADDR_OWVAR 31
85378: PUSH
85379: LD_INT 0
85381: PPUSH
85382: LD_INT 3
85384: PPUSH
85385: CALL_OW 12
85389: PUSH
85390: LD_INT 0
85392: PPUSH
85393: LD_INT 3
85395: PPUSH
85396: CALL_OW 12
85400: PUSH
85401: LD_INT 0
85403: PUSH
85404: LD_INT 0
85406: PUSH
85407: EMPTY
85408: LIST
85409: LIST
85410: LIST
85411: LIST
85412: ST_TO_ADDR
// end ;
85413: LD_VAR 0 1
85417: RET
// export function PrepareApemanEngineer ( ) ; begin
85418: LD_INT 0
85420: PPUSH
// uc_nation := 0 ;
85421: LD_ADDR_OWVAR 21
85425: PUSH
85426: LD_INT 0
85428: ST_TO_ADDR
// hc_sex := sex_male ;
85429: LD_ADDR_OWVAR 27
85433: PUSH
85434: LD_INT 1
85436: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
85437: LD_ADDR_OWVAR 28
85441: PUSH
85442: LD_INT 16
85444: ST_TO_ADDR
// hc_gallery :=  ;
85445: LD_ADDR_OWVAR 33
85449: PUSH
85450: LD_STRING 
85452: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85453: LD_ADDR_OWVAR 31
85457: PUSH
85458: LD_INT 0
85460: PPUSH
85461: LD_INT 3
85463: PPUSH
85464: CALL_OW 12
85468: PUSH
85469: LD_INT 0
85471: PPUSH
85472: LD_INT 3
85474: PPUSH
85475: CALL_OW 12
85479: PUSH
85480: LD_INT 0
85482: PUSH
85483: LD_INT 0
85485: PUSH
85486: EMPTY
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: ST_TO_ADDR
// end ;
85492: LD_VAR 0 1
85496: RET
// export function PrepareApeman ( agressivity ) ; begin
85497: LD_INT 0
85499: PPUSH
// uc_side := 0 ;
85500: LD_ADDR_OWVAR 20
85504: PUSH
85505: LD_INT 0
85507: ST_TO_ADDR
// uc_nation := 0 ;
85508: LD_ADDR_OWVAR 21
85512: PUSH
85513: LD_INT 0
85515: ST_TO_ADDR
// hc_sex := sex_male ;
85516: LD_ADDR_OWVAR 27
85520: PUSH
85521: LD_INT 1
85523: ST_TO_ADDR
// hc_class := class_apeman ;
85524: LD_ADDR_OWVAR 28
85528: PUSH
85529: LD_INT 12
85531: ST_TO_ADDR
// hc_gallery :=  ;
85532: LD_ADDR_OWVAR 33
85536: PUSH
85537: LD_STRING 
85539: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85540: LD_ADDR_OWVAR 35
85544: PUSH
85545: LD_VAR 0 1
85549: NEG
85550: PPUSH
85551: LD_VAR 0 1
85555: PPUSH
85556: CALL_OW 12
85560: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85561: LD_ADDR_OWVAR 31
85565: PUSH
85566: LD_INT 0
85568: PPUSH
85569: LD_INT 3
85571: PPUSH
85572: CALL_OW 12
85576: PUSH
85577: LD_INT 0
85579: PPUSH
85580: LD_INT 3
85582: PPUSH
85583: CALL_OW 12
85587: PUSH
85588: LD_INT 0
85590: PUSH
85591: LD_INT 0
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: ST_TO_ADDR
// end ;
85600: LD_VAR 0 2
85604: RET
// export function PrepareTiger ( agressivity ) ; begin
85605: LD_INT 0
85607: PPUSH
// uc_side := 0 ;
85608: LD_ADDR_OWVAR 20
85612: PUSH
85613: LD_INT 0
85615: ST_TO_ADDR
// uc_nation := 0 ;
85616: LD_ADDR_OWVAR 21
85620: PUSH
85621: LD_INT 0
85623: ST_TO_ADDR
// hc_class := class_tiger ;
85624: LD_ADDR_OWVAR 28
85628: PUSH
85629: LD_INT 14
85631: ST_TO_ADDR
// hc_gallery :=  ;
85632: LD_ADDR_OWVAR 33
85636: PUSH
85637: LD_STRING 
85639: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85640: LD_ADDR_OWVAR 35
85644: PUSH
85645: LD_VAR 0 1
85649: NEG
85650: PPUSH
85651: LD_VAR 0 1
85655: PPUSH
85656: CALL_OW 12
85660: ST_TO_ADDR
// end ;
85661: LD_VAR 0 2
85665: RET
// export function PrepareEnchidna ( ) ; begin
85666: LD_INT 0
85668: PPUSH
// uc_side := 0 ;
85669: LD_ADDR_OWVAR 20
85673: PUSH
85674: LD_INT 0
85676: ST_TO_ADDR
// uc_nation := 0 ;
85677: LD_ADDR_OWVAR 21
85681: PUSH
85682: LD_INT 0
85684: ST_TO_ADDR
// hc_class := class_baggie ;
85685: LD_ADDR_OWVAR 28
85689: PUSH
85690: LD_INT 13
85692: ST_TO_ADDR
// hc_gallery :=  ;
85693: LD_ADDR_OWVAR 33
85697: PUSH
85698: LD_STRING 
85700: ST_TO_ADDR
// end ;
85701: LD_VAR 0 1
85705: RET
// export function PrepareFrog ( ) ; begin
85706: LD_INT 0
85708: PPUSH
// uc_side := 0 ;
85709: LD_ADDR_OWVAR 20
85713: PUSH
85714: LD_INT 0
85716: ST_TO_ADDR
// uc_nation := 0 ;
85717: LD_ADDR_OWVAR 21
85721: PUSH
85722: LD_INT 0
85724: ST_TO_ADDR
// hc_class := class_frog ;
85725: LD_ADDR_OWVAR 28
85729: PUSH
85730: LD_INT 19
85732: ST_TO_ADDR
// hc_gallery :=  ;
85733: LD_ADDR_OWVAR 33
85737: PUSH
85738: LD_STRING 
85740: ST_TO_ADDR
// end ;
85741: LD_VAR 0 1
85745: RET
// export function PrepareFish ( ) ; begin
85746: LD_INT 0
85748: PPUSH
// uc_side := 0 ;
85749: LD_ADDR_OWVAR 20
85753: PUSH
85754: LD_INT 0
85756: ST_TO_ADDR
// uc_nation := 0 ;
85757: LD_ADDR_OWVAR 21
85761: PUSH
85762: LD_INT 0
85764: ST_TO_ADDR
// hc_class := class_fish ;
85765: LD_ADDR_OWVAR 28
85769: PUSH
85770: LD_INT 20
85772: ST_TO_ADDR
// hc_gallery :=  ;
85773: LD_ADDR_OWVAR 33
85777: PUSH
85778: LD_STRING 
85780: ST_TO_ADDR
// end ;
85781: LD_VAR 0 1
85785: RET
// export function PrepareBird ( ) ; begin
85786: LD_INT 0
85788: PPUSH
// uc_side := 0 ;
85789: LD_ADDR_OWVAR 20
85793: PUSH
85794: LD_INT 0
85796: ST_TO_ADDR
// uc_nation := 0 ;
85797: LD_ADDR_OWVAR 21
85801: PUSH
85802: LD_INT 0
85804: ST_TO_ADDR
// hc_class := class_phororhacos ;
85805: LD_ADDR_OWVAR 28
85809: PUSH
85810: LD_INT 18
85812: ST_TO_ADDR
// hc_gallery :=  ;
85813: LD_ADDR_OWVAR 33
85817: PUSH
85818: LD_STRING 
85820: ST_TO_ADDR
// end ;
85821: LD_VAR 0 1
85825: RET
// export function PrepareHorse ( ) ; begin
85826: LD_INT 0
85828: PPUSH
// uc_side := 0 ;
85829: LD_ADDR_OWVAR 20
85833: PUSH
85834: LD_INT 0
85836: ST_TO_ADDR
// uc_nation := 0 ;
85837: LD_ADDR_OWVAR 21
85841: PUSH
85842: LD_INT 0
85844: ST_TO_ADDR
// hc_class := class_horse ;
85845: LD_ADDR_OWVAR 28
85849: PUSH
85850: LD_INT 21
85852: ST_TO_ADDR
// hc_gallery :=  ;
85853: LD_ADDR_OWVAR 33
85857: PUSH
85858: LD_STRING 
85860: ST_TO_ADDR
// end ;
85861: LD_VAR 0 1
85865: RET
// export function PrepareMastodont ( ) ; begin
85866: LD_INT 0
85868: PPUSH
// uc_side := 0 ;
85869: LD_ADDR_OWVAR 20
85873: PUSH
85874: LD_INT 0
85876: ST_TO_ADDR
// uc_nation := 0 ;
85877: LD_ADDR_OWVAR 21
85881: PUSH
85882: LD_INT 0
85884: ST_TO_ADDR
// vc_chassis := class_mastodont ;
85885: LD_ADDR_OWVAR 37
85889: PUSH
85890: LD_INT 31
85892: ST_TO_ADDR
// vc_control := control_rider ;
85893: LD_ADDR_OWVAR 38
85897: PUSH
85898: LD_INT 4
85900: ST_TO_ADDR
// end ;
85901: LD_VAR 0 1
85905: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85906: LD_INT 0
85908: PPUSH
85909: PPUSH
85910: PPUSH
// uc_side = 0 ;
85911: LD_ADDR_OWVAR 20
85915: PUSH
85916: LD_INT 0
85918: ST_TO_ADDR
// uc_nation = 0 ;
85919: LD_ADDR_OWVAR 21
85923: PUSH
85924: LD_INT 0
85926: ST_TO_ADDR
// InitHc_All ( ) ;
85927: CALL_OW 584
// InitVc ;
85931: CALL_OW 20
// if mastodonts then
85935: LD_VAR 0 6
85939: IFFALSE 86006
// for i = 1 to mastodonts do
85941: LD_ADDR_VAR 0 11
85945: PUSH
85946: DOUBLE
85947: LD_INT 1
85949: DEC
85950: ST_TO_ADDR
85951: LD_VAR 0 6
85955: PUSH
85956: FOR_TO
85957: IFFALSE 86004
// begin vc_chassis := 31 ;
85959: LD_ADDR_OWVAR 37
85963: PUSH
85964: LD_INT 31
85966: ST_TO_ADDR
// vc_control := control_rider ;
85967: LD_ADDR_OWVAR 38
85971: PUSH
85972: LD_INT 4
85974: ST_TO_ADDR
// animal := CreateVehicle ;
85975: LD_ADDR_VAR 0 12
85979: PUSH
85980: CALL_OW 45
85984: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85985: LD_VAR 0 12
85989: PPUSH
85990: LD_VAR 0 8
85994: PPUSH
85995: LD_INT 0
85997: PPUSH
85998: CALL 88141 0 3
// end ;
86002: GO 85956
86004: POP
86005: POP
// if horses then
86006: LD_VAR 0 5
86010: IFFALSE 86077
// for i = 1 to horses do
86012: LD_ADDR_VAR 0 11
86016: PUSH
86017: DOUBLE
86018: LD_INT 1
86020: DEC
86021: ST_TO_ADDR
86022: LD_VAR 0 5
86026: PUSH
86027: FOR_TO
86028: IFFALSE 86075
// begin hc_class := 21 ;
86030: LD_ADDR_OWVAR 28
86034: PUSH
86035: LD_INT 21
86037: ST_TO_ADDR
// hc_gallery :=  ;
86038: LD_ADDR_OWVAR 33
86042: PUSH
86043: LD_STRING 
86045: ST_TO_ADDR
// animal := CreateHuman ;
86046: LD_ADDR_VAR 0 12
86050: PUSH
86051: CALL_OW 44
86055: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86056: LD_VAR 0 12
86060: PPUSH
86061: LD_VAR 0 8
86065: PPUSH
86066: LD_INT 0
86068: PPUSH
86069: CALL 88141 0 3
// end ;
86073: GO 86027
86075: POP
86076: POP
// if birds then
86077: LD_VAR 0 1
86081: IFFALSE 86148
// for i = 1 to birds do
86083: LD_ADDR_VAR 0 11
86087: PUSH
86088: DOUBLE
86089: LD_INT 1
86091: DEC
86092: ST_TO_ADDR
86093: LD_VAR 0 1
86097: PUSH
86098: FOR_TO
86099: IFFALSE 86146
// begin hc_class = 18 ;
86101: LD_ADDR_OWVAR 28
86105: PUSH
86106: LD_INT 18
86108: ST_TO_ADDR
// hc_gallery =  ;
86109: LD_ADDR_OWVAR 33
86113: PUSH
86114: LD_STRING 
86116: ST_TO_ADDR
// animal := CreateHuman ;
86117: LD_ADDR_VAR 0 12
86121: PUSH
86122: CALL_OW 44
86126: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86127: LD_VAR 0 12
86131: PPUSH
86132: LD_VAR 0 8
86136: PPUSH
86137: LD_INT 0
86139: PPUSH
86140: CALL 88141 0 3
// end ;
86144: GO 86098
86146: POP
86147: POP
// if tigers then
86148: LD_VAR 0 2
86152: IFFALSE 86236
// for i = 1 to tigers do
86154: LD_ADDR_VAR 0 11
86158: PUSH
86159: DOUBLE
86160: LD_INT 1
86162: DEC
86163: ST_TO_ADDR
86164: LD_VAR 0 2
86168: PUSH
86169: FOR_TO
86170: IFFALSE 86234
// begin hc_class = class_tiger ;
86172: LD_ADDR_OWVAR 28
86176: PUSH
86177: LD_INT 14
86179: ST_TO_ADDR
// hc_gallery =  ;
86180: LD_ADDR_OWVAR 33
86184: PUSH
86185: LD_STRING 
86187: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
86188: LD_ADDR_OWVAR 35
86192: PUSH
86193: LD_INT 7
86195: NEG
86196: PPUSH
86197: LD_INT 7
86199: PPUSH
86200: CALL_OW 12
86204: ST_TO_ADDR
// animal := CreateHuman ;
86205: LD_ADDR_VAR 0 12
86209: PUSH
86210: CALL_OW 44
86214: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86215: LD_VAR 0 12
86219: PPUSH
86220: LD_VAR 0 8
86224: PPUSH
86225: LD_INT 0
86227: PPUSH
86228: CALL 88141 0 3
// end ;
86232: GO 86169
86234: POP
86235: POP
// if apemans then
86236: LD_VAR 0 3
86240: IFFALSE 86363
// for i = 1 to apemans do
86242: LD_ADDR_VAR 0 11
86246: PUSH
86247: DOUBLE
86248: LD_INT 1
86250: DEC
86251: ST_TO_ADDR
86252: LD_VAR 0 3
86256: PUSH
86257: FOR_TO
86258: IFFALSE 86361
// begin hc_class = class_apeman ;
86260: LD_ADDR_OWVAR 28
86264: PUSH
86265: LD_INT 12
86267: ST_TO_ADDR
// hc_gallery =  ;
86268: LD_ADDR_OWVAR 33
86272: PUSH
86273: LD_STRING 
86275: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
86276: LD_ADDR_OWVAR 35
86280: PUSH
86281: LD_INT 2
86283: NEG
86284: PPUSH
86285: LD_INT 2
86287: PPUSH
86288: CALL_OW 12
86292: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
86293: LD_ADDR_OWVAR 31
86297: PUSH
86298: LD_INT 1
86300: PPUSH
86301: LD_INT 3
86303: PPUSH
86304: CALL_OW 12
86308: PUSH
86309: LD_INT 1
86311: PPUSH
86312: LD_INT 3
86314: PPUSH
86315: CALL_OW 12
86319: PUSH
86320: LD_INT 0
86322: PUSH
86323: LD_INT 0
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: LIST
86330: LIST
86331: ST_TO_ADDR
// animal := CreateHuman ;
86332: LD_ADDR_VAR 0 12
86336: PUSH
86337: CALL_OW 44
86341: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86342: LD_VAR 0 12
86346: PPUSH
86347: LD_VAR 0 8
86351: PPUSH
86352: LD_INT 0
86354: PPUSH
86355: CALL 88141 0 3
// end ;
86359: GO 86257
86361: POP
86362: POP
// if enchidnas then
86363: LD_VAR 0 4
86367: IFFALSE 86434
// for i = 1 to enchidnas do
86369: LD_ADDR_VAR 0 11
86373: PUSH
86374: DOUBLE
86375: LD_INT 1
86377: DEC
86378: ST_TO_ADDR
86379: LD_VAR 0 4
86383: PUSH
86384: FOR_TO
86385: IFFALSE 86432
// begin hc_class = 13 ;
86387: LD_ADDR_OWVAR 28
86391: PUSH
86392: LD_INT 13
86394: ST_TO_ADDR
// hc_gallery =  ;
86395: LD_ADDR_OWVAR 33
86399: PUSH
86400: LD_STRING 
86402: ST_TO_ADDR
// animal := CreateHuman ;
86403: LD_ADDR_VAR 0 12
86407: PUSH
86408: CALL_OW 44
86412: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86413: LD_VAR 0 12
86417: PPUSH
86418: LD_VAR 0 8
86422: PPUSH
86423: LD_INT 0
86425: PPUSH
86426: CALL 88141 0 3
// end ;
86430: GO 86384
86432: POP
86433: POP
// if fishes then
86434: LD_VAR 0 7
86438: IFFALSE 86505
// for i = 1 to fishes do
86440: LD_ADDR_VAR 0 11
86444: PUSH
86445: DOUBLE
86446: LD_INT 1
86448: DEC
86449: ST_TO_ADDR
86450: LD_VAR 0 7
86454: PUSH
86455: FOR_TO
86456: IFFALSE 86503
// begin hc_class = 20 ;
86458: LD_ADDR_OWVAR 28
86462: PUSH
86463: LD_INT 20
86465: ST_TO_ADDR
// hc_gallery =  ;
86466: LD_ADDR_OWVAR 33
86470: PUSH
86471: LD_STRING 
86473: ST_TO_ADDR
// animal := CreateHuman ;
86474: LD_ADDR_VAR 0 12
86478: PUSH
86479: CALL_OW 44
86483: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
86484: LD_VAR 0 12
86488: PPUSH
86489: LD_VAR 0 9
86493: PPUSH
86494: LD_INT 0
86496: PPUSH
86497: CALL 88141 0 3
// end ;
86501: GO 86455
86503: POP
86504: POP
// end ;
86505: LD_VAR 0 10
86509: RET
// export function WantHeal ( sci , unit ) ; begin
86510: LD_INT 0
86512: PPUSH
// if GetTaskList ( sci ) > 0 then
86513: LD_VAR 0 1
86517: PPUSH
86518: CALL_OW 437
86522: PUSH
86523: LD_INT 0
86525: GREATER
86526: IFFALSE 86596
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86528: LD_VAR 0 1
86532: PPUSH
86533: CALL_OW 437
86537: PUSH
86538: LD_INT 1
86540: ARRAY
86541: PUSH
86542: LD_INT 1
86544: ARRAY
86545: PUSH
86546: LD_STRING l
86548: EQUAL
86549: PUSH
86550: LD_VAR 0 1
86554: PPUSH
86555: CALL_OW 437
86559: PUSH
86560: LD_INT 1
86562: ARRAY
86563: PUSH
86564: LD_INT 4
86566: ARRAY
86567: PUSH
86568: LD_VAR 0 2
86572: EQUAL
86573: AND
86574: IFFALSE 86586
// result := true else
86576: LD_ADDR_VAR 0 3
86580: PUSH
86581: LD_INT 1
86583: ST_TO_ADDR
86584: GO 86594
// result := false ;
86586: LD_ADDR_VAR 0 3
86590: PUSH
86591: LD_INT 0
86593: ST_TO_ADDR
// end else
86594: GO 86604
// result := false ;
86596: LD_ADDR_VAR 0 3
86600: PUSH
86601: LD_INT 0
86603: ST_TO_ADDR
// end ;
86604: LD_VAR 0 3
86608: RET
// export function HealTarget ( sci ) ; begin
86609: LD_INT 0
86611: PPUSH
// if not sci then
86612: LD_VAR 0 1
86616: NOT
86617: IFFALSE 86621
// exit ;
86619: GO 86686
// result := 0 ;
86621: LD_ADDR_VAR 0 2
86625: PUSH
86626: LD_INT 0
86628: ST_TO_ADDR
// if GetTaskList ( sci ) then
86629: LD_VAR 0 1
86633: PPUSH
86634: CALL_OW 437
86638: IFFALSE 86686
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86640: LD_VAR 0 1
86644: PPUSH
86645: CALL_OW 437
86649: PUSH
86650: LD_INT 1
86652: ARRAY
86653: PUSH
86654: LD_INT 1
86656: ARRAY
86657: PUSH
86658: LD_STRING l
86660: EQUAL
86661: IFFALSE 86686
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86663: LD_ADDR_VAR 0 2
86667: PUSH
86668: LD_VAR 0 1
86672: PPUSH
86673: CALL_OW 437
86677: PUSH
86678: LD_INT 1
86680: ARRAY
86681: PUSH
86682: LD_INT 4
86684: ARRAY
86685: ST_TO_ADDR
// end ;
86686: LD_VAR 0 2
86690: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86691: LD_INT 0
86693: PPUSH
86694: PPUSH
86695: PPUSH
86696: PPUSH
// if not base_units then
86697: LD_VAR 0 1
86701: NOT
86702: IFFALSE 86706
// exit ;
86704: GO 86793
// result := false ;
86706: LD_ADDR_VAR 0 2
86710: PUSH
86711: LD_INT 0
86713: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
86714: LD_ADDR_VAR 0 5
86718: PUSH
86719: LD_VAR 0 1
86723: PPUSH
86724: LD_INT 21
86726: PUSH
86727: LD_INT 3
86729: PUSH
86730: EMPTY
86731: LIST
86732: LIST
86733: PPUSH
86734: CALL_OW 72
86738: ST_TO_ADDR
// if not tmp then
86739: LD_VAR 0 5
86743: NOT
86744: IFFALSE 86748
// exit ;
86746: GO 86793
// for i in tmp do
86748: LD_ADDR_VAR 0 3
86752: PUSH
86753: LD_VAR 0 5
86757: PUSH
86758: FOR_IN
86759: IFFALSE 86791
// begin result := EnemyInRange ( i , 22 ) ;
86761: LD_ADDR_VAR 0 2
86765: PUSH
86766: LD_VAR 0 3
86770: PPUSH
86771: LD_INT 22
86773: PPUSH
86774: CALL 84479 0 2
86778: ST_TO_ADDR
// if result then
86779: LD_VAR 0 2
86783: IFFALSE 86789
// exit ;
86785: POP
86786: POP
86787: GO 86793
// end ;
86789: GO 86758
86791: POP
86792: POP
// end ;
86793: LD_VAR 0 2
86797: RET
// export function FilterByTag ( units , tag ) ; begin
86798: LD_INT 0
86800: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
86801: LD_ADDR_VAR 0 3
86805: PUSH
86806: LD_VAR 0 1
86810: PPUSH
86811: LD_INT 120
86813: PUSH
86814: LD_VAR 0 2
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PPUSH
86823: CALL_OW 72
86827: ST_TO_ADDR
// end ;
86828: LD_VAR 0 3
86832: RET
// export function IsDriver ( un ) ; begin
86833: LD_INT 0
86835: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
86836: LD_ADDR_VAR 0 2
86840: PUSH
86841: LD_VAR 0 1
86845: PUSH
86846: LD_INT 55
86848: PUSH
86849: EMPTY
86850: LIST
86851: PPUSH
86852: CALL_OW 69
86856: IN
86857: ST_TO_ADDR
// end ;
86858: LD_VAR 0 2
86862: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
86863: LD_INT 0
86865: PPUSH
86866: PPUSH
// list := [ ] ;
86867: LD_ADDR_VAR 0 5
86871: PUSH
86872: EMPTY
86873: ST_TO_ADDR
// case d of 0 :
86874: LD_VAR 0 3
86878: PUSH
86879: LD_INT 0
86881: DOUBLE
86882: EQUAL
86883: IFTRUE 86887
86885: GO 87020
86887: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
86888: LD_ADDR_VAR 0 5
86892: PUSH
86893: LD_VAR 0 1
86897: PUSH
86898: LD_INT 4
86900: MINUS
86901: PUSH
86902: LD_VAR 0 2
86906: PUSH
86907: LD_INT 4
86909: MINUS
86910: PUSH
86911: LD_INT 2
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: LIST
86918: PUSH
86919: LD_VAR 0 1
86923: PUSH
86924: LD_INT 3
86926: MINUS
86927: PUSH
86928: LD_VAR 0 2
86932: PUSH
86933: LD_INT 1
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: LIST
86940: PUSH
86941: LD_VAR 0 1
86945: PUSH
86946: LD_INT 4
86948: PLUS
86949: PUSH
86950: LD_VAR 0 2
86954: PUSH
86955: LD_INT 4
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: LIST
86962: PUSH
86963: LD_VAR 0 1
86967: PUSH
86968: LD_INT 3
86970: PLUS
86971: PUSH
86972: LD_VAR 0 2
86976: PUSH
86977: LD_INT 3
86979: PLUS
86980: PUSH
86981: LD_INT 5
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: LIST
86988: PUSH
86989: LD_VAR 0 1
86993: PUSH
86994: LD_VAR 0 2
86998: PUSH
86999: LD_INT 4
87001: PLUS
87002: PUSH
87003: LD_INT 0
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: LIST
87010: PUSH
87011: EMPTY
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: ST_TO_ADDR
// end ; 1 :
87018: GO 87718
87020: LD_INT 1
87022: DOUBLE
87023: EQUAL
87024: IFTRUE 87028
87026: GO 87161
87028: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87029: LD_ADDR_VAR 0 5
87033: PUSH
87034: LD_VAR 0 1
87038: PUSH
87039: LD_VAR 0 2
87043: PUSH
87044: LD_INT 4
87046: MINUS
87047: PUSH
87048: LD_INT 3
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: LIST
87055: PUSH
87056: LD_VAR 0 1
87060: PUSH
87061: LD_INT 3
87063: MINUS
87064: PUSH
87065: LD_VAR 0 2
87069: PUSH
87070: LD_INT 3
87072: MINUS
87073: PUSH
87074: LD_INT 2
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: LIST
87081: PUSH
87082: LD_VAR 0 1
87086: PUSH
87087: LD_INT 4
87089: MINUS
87090: PUSH
87091: LD_VAR 0 2
87095: PUSH
87096: LD_INT 1
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: LIST
87103: PUSH
87104: LD_VAR 0 1
87108: PUSH
87109: LD_VAR 0 2
87113: PUSH
87114: LD_INT 3
87116: PLUS
87117: PUSH
87118: LD_INT 0
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: LIST
87125: PUSH
87126: LD_VAR 0 1
87130: PUSH
87131: LD_INT 4
87133: PLUS
87134: PUSH
87135: LD_VAR 0 2
87139: PUSH
87140: LD_INT 4
87142: PLUS
87143: PUSH
87144: LD_INT 5
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: LIST
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: ST_TO_ADDR
// end ; 2 :
87159: GO 87718
87161: LD_INT 2
87163: DOUBLE
87164: EQUAL
87165: IFTRUE 87169
87167: GO 87298
87169: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
87170: LD_ADDR_VAR 0 5
87174: PUSH
87175: LD_VAR 0 1
87179: PUSH
87180: LD_VAR 0 2
87184: PUSH
87185: LD_INT 3
87187: MINUS
87188: PUSH
87189: LD_INT 3
87191: PUSH
87192: EMPTY
87193: LIST
87194: LIST
87195: LIST
87196: PUSH
87197: LD_VAR 0 1
87201: PUSH
87202: LD_INT 4
87204: PLUS
87205: PUSH
87206: LD_VAR 0 2
87210: PUSH
87211: LD_INT 4
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: LIST
87218: PUSH
87219: LD_VAR 0 1
87223: PUSH
87224: LD_VAR 0 2
87228: PUSH
87229: LD_INT 4
87231: PLUS
87232: PUSH
87233: LD_INT 0
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: LIST
87240: PUSH
87241: LD_VAR 0 1
87245: PUSH
87246: LD_INT 3
87248: MINUS
87249: PUSH
87250: LD_VAR 0 2
87254: PUSH
87255: LD_INT 1
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: LIST
87262: PUSH
87263: LD_VAR 0 1
87267: PUSH
87268: LD_INT 4
87270: MINUS
87271: PUSH
87272: LD_VAR 0 2
87276: PUSH
87277: LD_INT 4
87279: MINUS
87280: PUSH
87281: LD_INT 2
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: LIST
87288: PUSH
87289: EMPTY
87290: LIST
87291: LIST
87292: LIST
87293: LIST
87294: LIST
87295: ST_TO_ADDR
// end ; 3 :
87296: GO 87718
87298: LD_INT 3
87300: DOUBLE
87301: EQUAL
87302: IFTRUE 87306
87304: GO 87439
87306: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
87307: LD_ADDR_VAR 0 5
87311: PUSH
87312: LD_VAR 0 1
87316: PUSH
87317: LD_INT 3
87319: PLUS
87320: PUSH
87321: LD_VAR 0 2
87325: PUSH
87326: LD_INT 4
87328: PUSH
87329: EMPTY
87330: LIST
87331: LIST
87332: LIST
87333: PUSH
87334: LD_VAR 0 1
87338: PUSH
87339: LD_INT 4
87341: PLUS
87342: PUSH
87343: LD_VAR 0 2
87347: PUSH
87348: LD_INT 4
87350: PLUS
87351: PUSH
87352: LD_INT 5
87354: PUSH
87355: EMPTY
87356: LIST
87357: LIST
87358: LIST
87359: PUSH
87360: LD_VAR 0 1
87364: PUSH
87365: LD_INT 4
87367: MINUS
87368: PUSH
87369: LD_VAR 0 2
87373: PUSH
87374: LD_INT 1
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: LIST
87381: PUSH
87382: LD_VAR 0 1
87386: PUSH
87387: LD_VAR 0 2
87391: PUSH
87392: LD_INT 4
87394: MINUS
87395: PUSH
87396: LD_INT 3
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: LIST
87403: PUSH
87404: LD_VAR 0 1
87408: PUSH
87409: LD_INT 3
87411: MINUS
87412: PUSH
87413: LD_VAR 0 2
87417: PUSH
87418: LD_INT 3
87420: MINUS
87421: PUSH
87422: LD_INT 2
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: LIST
87429: PUSH
87430: EMPTY
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: ST_TO_ADDR
// end ; 4 :
87437: GO 87718
87439: LD_INT 4
87441: DOUBLE
87442: EQUAL
87443: IFTRUE 87447
87445: GO 87580
87447: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
87448: LD_ADDR_VAR 0 5
87452: PUSH
87453: LD_VAR 0 1
87457: PUSH
87458: LD_VAR 0 2
87462: PUSH
87463: LD_INT 4
87465: PLUS
87466: PUSH
87467: LD_INT 0
87469: PUSH
87470: EMPTY
87471: LIST
87472: LIST
87473: LIST
87474: PUSH
87475: LD_VAR 0 1
87479: PUSH
87480: LD_INT 3
87482: PLUS
87483: PUSH
87484: LD_VAR 0 2
87488: PUSH
87489: LD_INT 3
87491: PLUS
87492: PUSH
87493: LD_INT 5
87495: PUSH
87496: EMPTY
87497: LIST
87498: LIST
87499: LIST
87500: PUSH
87501: LD_VAR 0 1
87505: PUSH
87506: LD_INT 4
87508: PLUS
87509: PUSH
87510: LD_VAR 0 2
87514: PUSH
87515: LD_INT 4
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: LIST
87522: PUSH
87523: LD_VAR 0 1
87527: PUSH
87528: LD_VAR 0 2
87532: PUSH
87533: LD_INT 3
87535: MINUS
87536: PUSH
87537: LD_INT 3
87539: PUSH
87540: EMPTY
87541: LIST
87542: LIST
87543: LIST
87544: PUSH
87545: LD_VAR 0 1
87549: PUSH
87550: LD_INT 4
87552: MINUS
87553: PUSH
87554: LD_VAR 0 2
87558: PUSH
87559: LD_INT 4
87561: MINUS
87562: PUSH
87563: LD_INT 2
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: LIST
87570: PUSH
87571: EMPTY
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: ST_TO_ADDR
// end ; 5 :
87578: GO 87718
87580: LD_INT 5
87582: DOUBLE
87583: EQUAL
87584: IFTRUE 87588
87586: GO 87717
87588: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87589: LD_ADDR_VAR 0 5
87593: PUSH
87594: LD_VAR 0 1
87598: PUSH
87599: LD_INT 4
87601: MINUS
87602: PUSH
87603: LD_VAR 0 2
87607: PUSH
87608: LD_INT 1
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: LIST
87615: PUSH
87616: LD_VAR 0 1
87620: PUSH
87621: LD_VAR 0 2
87625: PUSH
87626: LD_INT 4
87628: MINUS
87629: PUSH
87630: LD_INT 3
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: LIST
87637: PUSH
87638: LD_VAR 0 1
87642: PUSH
87643: LD_INT 4
87645: PLUS
87646: PUSH
87647: LD_VAR 0 2
87651: PUSH
87652: LD_INT 4
87654: PLUS
87655: PUSH
87656: LD_INT 5
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: LIST
87663: PUSH
87664: LD_VAR 0 1
87668: PUSH
87669: LD_INT 3
87671: PLUS
87672: PUSH
87673: LD_VAR 0 2
87677: PUSH
87678: LD_INT 4
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: LIST
87685: PUSH
87686: LD_VAR 0 1
87690: PUSH
87691: LD_VAR 0 2
87695: PUSH
87696: LD_INT 3
87698: PLUS
87699: PUSH
87700: LD_INT 0
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: LIST
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: LIST
87712: LIST
87713: LIST
87714: ST_TO_ADDR
// end ; end ;
87715: GO 87718
87717: POP
// result := list ;
87718: LD_ADDR_VAR 0 4
87722: PUSH
87723: LD_VAR 0 5
87727: ST_TO_ADDR
// end ;
87728: LD_VAR 0 4
87732: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
87733: LD_INT 0
87735: PPUSH
87736: PPUSH
87737: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
87738: LD_VAR 0 1
87742: NOT
87743: PUSH
87744: LD_VAR 0 2
87748: PUSH
87749: LD_INT 1
87751: PUSH
87752: LD_INT 2
87754: PUSH
87755: LD_INT 3
87757: PUSH
87758: LD_INT 4
87760: PUSH
87761: EMPTY
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: IN
87767: NOT
87768: OR
87769: IFFALSE 87773
// exit ;
87771: GO 87865
// tmp := [ ] ;
87773: LD_ADDR_VAR 0 5
87777: PUSH
87778: EMPTY
87779: ST_TO_ADDR
// for i in units do
87780: LD_ADDR_VAR 0 4
87784: PUSH
87785: LD_VAR 0 1
87789: PUSH
87790: FOR_IN
87791: IFFALSE 87834
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
87793: LD_ADDR_VAR 0 5
87797: PUSH
87798: LD_VAR 0 5
87802: PPUSH
87803: LD_VAR 0 5
87807: PUSH
87808: LD_INT 1
87810: PLUS
87811: PPUSH
87812: LD_VAR 0 4
87816: PPUSH
87817: LD_VAR 0 2
87821: PPUSH
87822: CALL_OW 259
87826: PPUSH
87827: CALL_OW 2
87831: ST_TO_ADDR
87832: GO 87790
87834: POP
87835: POP
// if not tmp then
87836: LD_VAR 0 5
87840: NOT
87841: IFFALSE 87845
// exit ;
87843: GO 87865
// result := SortListByListDesc ( units , tmp ) ;
87845: LD_ADDR_VAR 0 3
87849: PUSH
87850: LD_VAR 0 1
87854: PPUSH
87855: LD_VAR 0 5
87859: PPUSH
87860: CALL_OW 77
87864: ST_TO_ADDR
// end ;
87865: LD_VAR 0 3
87869: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
87870: LD_INT 0
87872: PPUSH
87873: PPUSH
87874: PPUSH
// result := false ;
87875: LD_ADDR_VAR 0 3
87879: PUSH
87880: LD_INT 0
87882: ST_TO_ADDR
// x := GetX ( building ) ;
87883: LD_ADDR_VAR 0 4
87887: PUSH
87888: LD_VAR 0 2
87892: PPUSH
87893: CALL_OW 250
87897: ST_TO_ADDR
// y := GetY ( building ) ;
87898: LD_ADDR_VAR 0 5
87902: PUSH
87903: LD_VAR 0 2
87907: PPUSH
87908: CALL_OW 251
87912: ST_TO_ADDR
// if not building or not x or not y then
87913: LD_VAR 0 2
87917: NOT
87918: PUSH
87919: LD_VAR 0 4
87923: NOT
87924: OR
87925: PUSH
87926: LD_VAR 0 5
87930: NOT
87931: OR
87932: IFFALSE 87936
// exit ;
87934: GO 88028
// if GetTaskList ( unit ) then
87936: LD_VAR 0 1
87940: PPUSH
87941: CALL_OW 437
87945: IFFALSE 88028
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87947: LD_STRING e
87949: PUSH
87950: LD_VAR 0 1
87954: PPUSH
87955: CALL_OW 437
87959: PUSH
87960: LD_INT 1
87962: ARRAY
87963: PUSH
87964: LD_INT 1
87966: ARRAY
87967: EQUAL
87968: PUSH
87969: LD_VAR 0 4
87973: PUSH
87974: LD_VAR 0 1
87978: PPUSH
87979: CALL_OW 437
87983: PUSH
87984: LD_INT 1
87986: ARRAY
87987: PUSH
87988: LD_INT 2
87990: ARRAY
87991: EQUAL
87992: AND
87993: PUSH
87994: LD_VAR 0 5
87998: PUSH
87999: LD_VAR 0 1
88003: PPUSH
88004: CALL_OW 437
88008: PUSH
88009: LD_INT 1
88011: ARRAY
88012: PUSH
88013: LD_INT 3
88015: ARRAY
88016: EQUAL
88017: AND
88018: IFFALSE 88028
// result := true end ;
88020: LD_ADDR_VAR 0 3
88024: PUSH
88025: LD_INT 1
88027: ST_TO_ADDR
// end ;
88028: LD_VAR 0 3
88032: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
88033: LD_INT 0
88035: PPUSH
// result := false ;
88036: LD_ADDR_VAR 0 4
88040: PUSH
88041: LD_INT 0
88043: ST_TO_ADDR
// if GetTaskList ( unit ) then
88044: LD_VAR 0 1
88048: PPUSH
88049: CALL_OW 437
88053: IFFALSE 88136
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88055: LD_STRING M
88057: PUSH
88058: LD_VAR 0 1
88062: PPUSH
88063: CALL_OW 437
88067: PUSH
88068: LD_INT 1
88070: ARRAY
88071: PUSH
88072: LD_INT 1
88074: ARRAY
88075: EQUAL
88076: PUSH
88077: LD_VAR 0 2
88081: PUSH
88082: LD_VAR 0 1
88086: PPUSH
88087: CALL_OW 437
88091: PUSH
88092: LD_INT 1
88094: ARRAY
88095: PUSH
88096: LD_INT 2
88098: ARRAY
88099: EQUAL
88100: AND
88101: PUSH
88102: LD_VAR 0 3
88106: PUSH
88107: LD_VAR 0 1
88111: PPUSH
88112: CALL_OW 437
88116: PUSH
88117: LD_INT 1
88119: ARRAY
88120: PUSH
88121: LD_INT 3
88123: ARRAY
88124: EQUAL
88125: AND
88126: IFFALSE 88136
// result := true ;
88128: LD_ADDR_VAR 0 4
88132: PUSH
88133: LD_INT 1
88135: ST_TO_ADDR
// end ; end ;
88136: LD_VAR 0 4
88140: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
88141: LD_INT 0
88143: PPUSH
88144: PPUSH
88145: PPUSH
88146: PPUSH
// if not unit or not area then
88147: LD_VAR 0 1
88151: NOT
88152: PUSH
88153: LD_VAR 0 2
88157: NOT
88158: OR
88159: IFFALSE 88163
// exit ;
88161: GO 88327
// tmp := AreaToList ( area , i ) ;
88163: LD_ADDR_VAR 0 6
88167: PUSH
88168: LD_VAR 0 2
88172: PPUSH
88173: LD_VAR 0 5
88177: PPUSH
88178: CALL_OW 517
88182: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
88183: LD_ADDR_VAR 0 5
88187: PUSH
88188: DOUBLE
88189: LD_INT 1
88191: DEC
88192: ST_TO_ADDR
88193: LD_VAR 0 6
88197: PUSH
88198: LD_INT 1
88200: ARRAY
88201: PUSH
88202: FOR_TO
88203: IFFALSE 88325
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
88205: LD_ADDR_VAR 0 7
88209: PUSH
88210: LD_VAR 0 6
88214: PUSH
88215: LD_INT 1
88217: ARRAY
88218: PUSH
88219: LD_VAR 0 5
88223: ARRAY
88224: PUSH
88225: LD_VAR 0 6
88229: PUSH
88230: LD_INT 2
88232: ARRAY
88233: PUSH
88234: LD_VAR 0 5
88238: ARRAY
88239: PUSH
88240: EMPTY
88241: LIST
88242: LIST
88243: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
88244: LD_VAR 0 7
88248: PUSH
88249: LD_INT 1
88251: ARRAY
88252: PPUSH
88253: LD_VAR 0 7
88257: PUSH
88258: LD_INT 2
88260: ARRAY
88261: PPUSH
88262: CALL_OW 428
88266: PUSH
88267: LD_INT 0
88269: EQUAL
88270: IFFALSE 88323
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
88272: LD_VAR 0 1
88276: PPUSH
88277: LD_VAR 0 7
88281: PUSH
88282: LD_INT 1
88284: ARRAY
88285: PPUSH
88286: LD_VAR 0 7
88290: PUSH
88291: LD_INT 2
88293: ARRAY
88294: PPUSH
88295: LD_VAR 0 3
88299: PPUSH
88300: CALL_OW 48
// result := IsPlaced ( unit ) ;
88304: LD_ADDR_VAR 0 4
88308: PUSH
88309: LD_VAR 0 1
88313: PPUSH
88314: CALL_OW 305
88318: ST_TO_ADDR
// exit ;
88319: POP
88320: POP
88321: GO 88327
// end ; end ;
88323: GO 88202
88325: POP
88326: POP
// end ;
88327: LD_VAR 0 4
88331: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
88332: LD_INT 0
88334: PPUSH
88335: PPUSH
88336: PPUSH
// if not side or side > 8 then
88337: LD_VAR 0 1
88341: NOT
88342: PUSH
88343: LD_VAR 0 1
88347: PUSH
88348: LD_INT 8
88350: GREATER
88351: OR
88352: IFFALSE 88356
// exit ;
88354: GO 88543
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
88356: LD_ADDR_VAR 0 4
88360: PUSH
88361: LD_INT 22
88363: PUSH
88364: LD_VAR 0 1
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: LD_INT 21
88375: PUSH
88376: LD_INT 3
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PPUSH
88387: CALL_OW 69
88391: ST_TO_ADDR
// if not tmp then
88392: LD_VAR 0 4
88396: NOT
88397: IFFALSE 88401
// exit ;
88399: GO 88543
// enable_addtolog := true ;
88401: LD_ADDR_OWVAR 81
88405: PUSH
88406: LD_INT 1
88408: ST_TO_ADDR
// AddToLog ( [ ) ;
88409: LD_STRING [
88411: PPUSH
88412: CALL_OW 561
// for i in tmp do
88416: LD_ADDR_VAR 0 3
88420: PUSH
88421: LD_VAR 0 4
88425: PUSH
88426: FOR_IN
88427: IFFALSE 88534
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
88429: LD_STRING [
88431: PUSH
88432: LD_VAR 0 3
88436: PPUSH
88437: CALL_OW 266
88441: STR
88442: PUSH
88443: LD_STRING , 
88445: STR
88446: PUSH
88447: LD_VAR 0 3
88451: PPUSH
88452: CALL_OW 250
88456: STR
88457: PUSH
88458: LD_STRING , 
88460: STR
88461: PUSH
88462: LD_VAR 0 3
88466: PPUSH
88467: CALL_OW 251
88471: STR
88472: PUSH
88473: LD_STRING , 
88475: STR
88476: PUSH
88477: LD_VAR 0 3
88481: PPUSH
88482: CALL_OW 254
88486: STR
88487: PUSH
88488: LD_STRING , 
88490: STR
88491: PUSH
88492: LD_VAR 0 3
88496: PPUSH
88497: LD_INT 1
88499: PPUSH
88500: CALL_OW 268
88504: STR
88505: PUSH
88506: LD_STRING , 
88508: STR
88509: PUSH
88510: LD_VAR 0 3
88514: PPUSH
88515: LD_INT 2
88517: PPUSH
88518: CALL_OW 268
88522: STR
88523: PUSH
88524: LD_STRING ],
88526: STR
88527: PPUSH
88528: CALL_OW 561
// end ;
88532: GO 88426
88534: POP
88535: POP
// AddToLog ( ]; ) ;
88536: LD_STRING ];
88538: PPUSH
88539: CALL_OW 561
// end ;
88543: LD_VAR 0 2
88547: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88548: LD_INT 0
88550: PPUSH
88551: PPUSH
88552: PPUSH
88553: PPUSH
88554: PPUSH
// if not area or not rate or not max then
88555: LD_VAR 0 1
88559: NOT
88560: PUSH
88561: LD_VAR 0 2
88565: NOT
88566: OR
88567: PUSH
88568: LD_VAR 0 4
88572: NOT
88573: OR
88574: IFFALSE 88578
// exit ;
88576: GO 88767
// while 1 do
88578: LD_INT 1
88580: IFFALSE 88767
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88582: LD_ADDR_VAR 0 9
88586: PUSH
88587: LD_VAR 0 1
88591: PPUSH
88592: LD_INT 1
88594: PPUSH
88595: CALL_OW 287
88599: PUSH
88600: LD_INT 10
88602: MUL
88603: ST_TO_ADDR
// r := rate / 10 ;
88604: LD_ADDR_VAR 0 7
88608: PUSH
88609: LD_VAR 0 2
88613: PUSH
88614: LD_INT 10
88616: DIVREAL
88617: ST_TO_ADDR
// time := 1 1$00 ;
88618: LD_ADDR_VAR 0 8
88622: PUSH
88623: LD_INT 2100
88625: ST_TO_ADDR
// if amount < min then
88626: LD_VAR 0 9
88630: PUSH
88631: LD_VAR 0 3
88635: LESS
88636: IFFALSE 88654
// r := r * 2 else
88638: LD_ADDR_VAR 0 7
88642: PUSH
88643: LD_VAR 0 7
88647: PUSH
88648: LD_INT 2
88650: MUL
88651: ST_TO_ADDR
88652: GO 88680
// if amount > max then
88654: LD_VAR 0 9
88658: PUSH
88659: LD_VAR 0 4
88663: GREATER
88664: IFFALSE 88680
// r := r / 2 ;
88666: LD_ADDR_VAR 0 7
88670: PUSH
88671: LD_VAR 0 7
88675: PUSH
88676: LD_INT 2
88678: DIVREAL
88679: ST_TO_ADDR
// time := time / r ;
88680: LD_ADDR_VAR 0 8
88684: PUSH
88685: LD_VAR 0 8
88689: PUSH
88690: LD_VAR 0 7
88694: DIVREAL
88695: ST_TO_ADDR
// if time < 0 then
88696: LD_VAR 0 8
88700: PUSH
88701: LD_INT 0
88703: LESS
88704: IFFALSE 88721
// time := time * - 1 ;
88706: LD_ADDR_VAR 0 8
88710: PUSH
88711: LD_VAR 0 8
88715: PUSH
88716: LD_INT 1
88718: NEG
88719: MUL
88720: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
88721: LD_VAR 0 8
88725: PUSH
88726: LD_INT 35
88728: PPUSH
88729: LD_INT 875
88731: PPUSH
88732: CALL_OW 12
88736: PLUS
88737: PPUSH
88738: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
88742: LD_INT 1
88744: PPUSH
88745: LD_INT 5
88747: PPUSH
88748: CALL_OW 12
88752: PPUSH
88753: LD_VAR 0 1
88757: PPUSH
88758: LD_INT 1
88760: PPUSH
88761: CALL_OW 55
// end ;
88765: GO 88578
// end ;
88767: LD_VAR 0 5
88771: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
88772: LD_INT 0
88774: PPUSH
88775: PPUSH
88776: PPUSH
88777: PPUSH
88778: PPUSH
88779: PPUSH
88780: PPUSH
88781: PPUSH
// if not turrets or not factories then
88782: LD_VAR 0 1
88786: NOT
88787: PUSH
88788: LD_VAR 0 2
88792: NOT
88793: OR
88794: IFFALSE 88798
// exit ;
88796: GO 89105
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
88798: LD_ADDR_VAR 0 10
88802: PUSH
88803: LD_INT 5
88805: PUSH
88806: LD_INT 6
88808: PUSH
88809: EMPTY
88810: LIST
88811: LIST
88812: PUSH
88813: LD_INT 2
88815: PUSH
88816: LD_INT 4
88818: PUSH
88819: EMPTY
88820: LIST
88821: LIST
88822: PUSH
88823: LD_INT 3
88825: PUSH
88826: LD_INT 5
88828: PUSH
88829: EMPTY
88830: LIST
88831: LIST
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: LIST
88837: PUSH
88838: LD_INT 24
88840: PUSH
88841: LD_INT 25
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 23
88850: PUSH
88851: LD_INT 27
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PUSH
88858: EMPTY
88859: LIST
88860: LIST
88861: PUSH
88862: LD_INT 42
88864: PUSH
88865: LD_INT 43
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: LD_INT 44
88874: PUSH
88875: LD_INT 46
88877: PUSH
88878: EMPTY
88879: LIST
88880: LIST
88881: PUSH
88882: LD_INT 45
88884: PUSH
88885: LD_INT 47
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: PUSH
88892: EMPTY
88893: LIST
88894: LIST
88895: LIST
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: LIST
88901: ST_TO_ADDR
// result := [ ] ;
88902: LD_ADDR_VAR 0 3
88906: PUSH
88907: EMPTY
88908: ST_TO_ADDR
// for i in turrets do
88909: LD_ADDR_VAR 0 4
88913: PUSH
88914: LD_VAR 0 1
88918: PUSH
88919: FOR_IN
88920: IFFALSE 89103
// begin nat := GetNation ( i ) ;
88922: LD_ADDR_VAR 0 7
88926: PUSH
88927: LD_VAR 0 4
88931: PPUSH
88932: CALL_OW 248
88936: ST_TO_ADDR
// weapon := 0 ;
88937: LD_ADDR_VAR 0 8
88941: PUSH
88942: LD_INT 0
88944: ST_TO_ADDR
// if not nat then
88945: LD_VAR 0 7
88949: NOT
88950: IFFALSE 88954
// continue ;
88952: GO 88919
// for j in list [ nat ] do
88954: LD_ADDR_VAR 0 5
88958: PUSH
88959: LD_VAR 0 10
88963: PUSH
88964: LD_VAR 0 7
88968: ARRAY
88969: PUSH
88970: FOR_IN
88971: IFFALSE 89012
// if GetBWeapon ( i ) = j [ 1 ] then
88973: LD_VAR 0 4
88977: PPUSH
88978: CALL_OW 269
88982: PUSH
88983: LD_VAR 0 5
88987: PUSH
88988: LD_INT 1
88990: ARRAY
88991: EQUAL
88992: IFFALSE 89010
// begin weapon := j [ 2 ] ;
88994: LD_ADDR_VAR 0 8
88998: PUSH
88999: LD_VAR 0 5
89003: PUSH
89004: LD_INT 2
89006: ARRAY
89007: ST_TO_ADDR
// break ;
89008: GO 89012
// end ;
89010: GO 88970
89012: POP
89013: POP
// if not weapon then
89014: LD_VAR 0 8
89018: NOT
89019: IFFALSE 89023
// continue ;
89021: GO 88919
// for k in factories do
89023: LD_ADDR_VAR 0 6
89027: PUSH
89028: LD_VAR 0 2
89032: PUSH
89033: FOR_IN
89034: IFFALSE 89099
// begin weapons := AvailableWeaponList ( k ) ;
89036: LD_ADDR_VAR 0 9
89040: PUSH
89041: LD_VAR 0 6
89045: PPUSH
89046: CALL_OW 478
89050: ST_TO_ADDR
// if not weapons then
89051: LD_VAR 0 9
89055: NOT
89056: IFFALSE 89060
// continue ;
89058: GO 89033
// if weapon in weapons then
89060: LD_VAR 0 8
89064: PUSH
89065: LD_VAR 0 9
89069: IN
89070: IFFALSE 89097
// begin result := [ i , weapon ] ;
89072: LD_ADDR_VAR 0 3
89076: PUSH
89077: LD_VAR 0 4
89081: PUSH
89082: LD_VAR 0 8
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: ST_TO_ADDR
// exit ;
89091: POP
89092: POP
89093: POP
89094: POP
89095: GO 89105
// end ; end ;
89097: GO 89033
89099: POP
89100: POP
// end ;
89101: GO 88919
89103: POP
89104: POP
// end ;
89105: LD_VAR 0 3
89109: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
89110: LD_INT 0
89112: PPUSH
// if not side or side > 8 then
89113: LD_VAR 0 3
89117: NOT
89118: PUSH
89119: LD_VAR 0 3
89123: PUSH
89124: LD_INT 8
89126: GREATER
89127: OR
89128: IFFALSE 89132
// exit ;
89130: GO 89191
// if not range then
89132: LD_VAR 0 4
89136: NOT
89137: IFFALSE 89148
// range := - 12 ;
89139: LD_ADDR_VAR 0 4
89143: PUSH
89144: LD_INT 12
89146: NEG
89147: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
89148: LD_VAR 0 1
89152: PPUSH
89153: LD_VAR 0 2
89157: PPUSH
89158: LD_VAR 0 3
89162: PPUSH
89163: LD_VAR 0 4
89167: PPUSH
89168: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
89172: LD_VAR 0 1
89176: PPUSH
89177: LD_VAR 0 2
89181: PPUSH
89182: LD_VAR 0 3
89186: PPUSH
89187: CALL_OW 331
// end ;
89191: LD_VAR 0 5
89195: RET
// export function Video ( mode ) ; begin
89196: LD_INT 0
89198: PPUSH
// ingame_video = mode ;
89199: LD_ADDR_OWVAR 52
89203: PUSH
89204: LD_VAR 0 1
89208: ST_TO_ADDR
// interface_hidden = mode ;
89209: LD_ADDR_OWVAR 54
89213: PUSH
89214: LD_VAR 0 1
89218: ST_TO_ADDR
// end ;
89219: LD_VAR 0 2
89223: RET
// export function Join ( array , element ) ; begin
89224: LD_INT 0
89226: PPUSH
// result := Replace ( array , array + 1 , element ) ;
89227: LD_ADDR_VAR 0 3
89231: PUSH
89232: LD_VAR 0 1
89236: PPUSH
89237: LD_VAR 0 1
89241: PUSH
89242: LD_INT 1
89244: PLUS
89245: PPUSH
89246: LD_VAR 0 2
89250: PPUSH
89251: CALL_OW 1
89255: ST_TO_ADDR
// end ;
89256: LD_VAR 0 3
89260: RET
// export function JoinUnion ( array , element ) ; begin
89261: LD_INT 0
89263: PPUSH
// result := array union element ;
89264: LD_ADDR_VAR 0 3
89268: PUSH
89269: LD_VAR 0 1
89273: PUSH
89274: LD_VAR 0 2
89278: UNION
89279: ST_TO_ADDR
// end ;
89280: LD_VAR 0 3
89284: RET
// export function GetBehemoths ( side ) ; begin
89285: LD_INT 0
89287: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
89288: LD_ADDR_VAR 0 2
89292: PUSH
89293: LD_INT 22
89295: PUSH
89296: LD_VAR 0 1
89300: PUSH
89301: EMPTY
89302: LIST
89303: LIST
89304: PUSH
89305: LD_INT 31
89307: PUSH
89308: LD_INT 25
89310: PUSH
89311: EMPTY
89312: LIST
89313: LIST
89314: PUSH
89315: EMPTY
89316: LIST
89317: LIST
89318: PPUSH
89319: CALL_OW 69
89323: ST_TO_ADDR
// end ;
89324: LD_VAR 0 2
89328: RET
// export function Shuffle ( array ) ; var i , index ; begin
89329: LD_INT 0
89331: PPUSH
89332: PPUSH
89333: PPUSH
// result := [ ] ;
89334: LD_ADDR_VAR 0 2
89338: PUSH
89339: EMPTY
89340: ST_TO_ADDR
// if not array then
89341: LD_VAR 0 1
89345: NOT
89346: IFFALSE 89350
// exit ;
89348: GO 89449
// Randomize ;
89350: CALL_OW 10
// for i = array downto 1 do
89354: LD_ADDR_VAR 0 3
89358: PUSH
89359: DOUBLE
89360: LD_VAR 0 1
89364: INC
89365: ST_TO_ADDR
89366: LD_INT 1
89368: PUSH
89369: FOR_DOWNTO
89370: IFFALSE 89447
// begin index := rand ( 1 , array ) ;
89372: LD_ADDR_VAR 0 4
89376: PUSH
89377: LD_INT 1
89379: PPUSH
89380: LD_VAR 0 1
89384: PPUSH
89385: CALL_OW 12
89389: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
89390: LD_ADDR_VAR 0 2
89394: PUSH
89395: LD_VAR 0 2
89399: PPUSH
89400: LD_VAR 0 2
89404: PUSH
89405: LD_INT 1
89407: PLUS
89408: PPUSH
89409: LD_VAR 0 1
89413: PUSH
89414: LD_VAR 0 4
89418: ARRAY
89419: PPUSH
89420: CALL_OW 2
89424: ST_TO_ADDR
// array := Delete ( array , index ) ;
89425: LD_ADDR_VAR 0 1
89429: PUSH
89430: LD_VAR 0 1
89434: PPUSH
89435: LD_VAR 0 4
89439: PPUSH
89440: CALL_OW 3
89444: ST_TO_ADDR
// end ;
89445: GO 89369
89447: POP
89448: POP
// end ;
89449: LD_VAR 0 2
89453: RET
// export function GetBaseMaterials ( base ) ; begin
89454: LD_INT 0
89456: PPUSH
// result := [ 0 , 0 , 0 ] ;
89457: LD_ADDR_VAR 0 2
89461: PUSH
89462: LD_INT 0
89464: PUSH
89465: LD_INT 0
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: LIST
89475: ST_TO_ADDR
// if not base then
89476: LD_VAR 0 1
89480: NOT
89481: IFFALSE 89485
// exit ;
89483: GO 89534
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89485: LD_ADDR_VAR 0 2
89489: PUSH
89490: LD_VAR 0 1
89494: PPUSH
89495: LD_INT 1
89497: PPUSH
89498: CALL_OW 275
89502: PUSH
89503: LD_VAR 0 1
89507: PPUSH
89508: LD_INT 2
89510: PPUSH
89511: CALL_OW 275
89515: PUSH
89516: LD_VAR 0 1
89520: PPUSH
89521: LD_INT 3
89523: PPUSH
89524: CALL_OW 275
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: LIST
89533: ST_TO_ADDR
// end ;
89534: LD_VAR 0 2
89538: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89539: LD_INT 0
89541: PPUSH
89542: PPUSH
// result := array ;
89543: LD_ADDR_VAR 0 3
89547: PUSH
89548: LD_VAR 0 1
89552: ST_TO_ADDR
// if size >= result then
89553: LD_VAR 0 2
89557: PUSH
89558: LD_VAR 0 3
89562: GREATEREQUAL
89563: IFFALSE 89567
// exit ;
89565: GO 89617
// if size then
89567: LD_VAR 0 2
89571: IFFALSE 89617
// for i := array downto size do
89573: LD_ADDR_VAR 0 4
89577: PUSH
89578: DOUBLE
89579: LD_VAR 0 1
89583: INC
89584: ST_TO_ADDR
89585: LD_VAR 0 2
89589: PUSH
89590: FOR_DOWNTO
89591: IFFALSE 89615
// result := Delete ( result , result ) ;
89593: LD_ADDR_VAR 0 3
89597: PUSH
89598: LD_VAR 0 3
89602: PPUSH
89603: LD_VAR 0 3
89607: PPUSH
89608: CALL_OW 3
89612: ST_TO_ADDR
89613: GO 89590
89615: POP
89616: POP
// end ;
89617: LD_VAR 0 3
89621: RET
// export function ComExit ( unit ) ; var tmp ; begin
89622: LD_INT 0
89624: PPUSH
89625: PPUSH
// if not IsInUnit ( unit ) then
89626: LD_VAR 0 1
89630: PPUSH
89631: CALL_OW 310
89635: NOT
89636: IFFALSE 89640
// exit ;
89638: GO 89700
// tmp := IsInUnit ( unit ) ;
89640: LD_ADDR_VAR 0 3
89644: PUSH
89645: LD_VAR 0 1
89649: PPUSH
89650: CALL_OW 310
89654: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89655: LD_VAR 0 3
89659: PPUSH
89660: CALL_OW 247
89664: PUSH
89665: LD_INT 2
89667: EQUAL
89668: IFFALSE 89681
// ComExitVehicle ( unit ) else
89670: LD_VAR 0 1
89674: PPUSH
89675: CALL_OW 121
89679: GO 89690
// ComExitBuilding ( unit ) ;
89681: LD_VAR 0 1
89685: PPUSH
89686: CALL_OW 122
// result := tmp ;
89690: LD_ADDR_VAR 0 2
89694: PUSH
89695: LD_VAR 0 3
89699: ST_TO_ADDR
// end ;
89700: LD_VAR 0 2
89704: RET
// export function ComExitAll ( units ) ; var i ; begin
89705: LD_INT 0
89707: PPUSH
89708: PPUSH
// if not units then
89709: LD_VAR 0 1
89713: NOT
89714: IFFALSE 89718
// exit ;
89716: GO 89744
// for i in units do
89718: LD_ADDR_VAR 0 3
89722: PUSH
89723: LD_VAR 0 1
89727: PUSH
89728: FOR_IN
89729: IFFALSE 89742
// ComExit ( i ) ;
89731: LD_VAR 0 3
89735: PPUSH
89736: CALL 89622 0 1
89740: GO 89728
89742: POP
89743: POP
// end ;
89744: LD_VAR 0 2
89748: RET
// export function ResetHc ; begin
89749: LD_INT 0
89751: PPUSH
// InitHc ;
89752: CALL_OW 19
// hc_importance := 0 ;
89756: LD_ADDR_OWVAR 32
89760: PUSH
89761: LD_INT 0
89763: ST_TO_ADDR
// end ;
89764: LD_VAR 0 1
89768: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
89769: LD_INT 0
89771: PPUSH
89772: PPUSH
89773: PPUSH
// _x := ( x1 + x2 ) div 2 ;
89774: LD_ADDR_VAR 0 6
89778: PUSH
89779: LD_VAR 0 1
89783: PUSH
89784: LD_VAR 0 3
89788: PLUS
89789: PUSH
89790: LD_INT 2
89792: DIV
89793: ST_TO_ADDR
// if _x < 0 then
89794: LD_VAR 0 6
89798: PUSH
89799: LD_INT 0
89801: LESS
89802: IFFALSE 89819
// _x := _x * - 1 ;
89804: LD_ADDR_VAR 0 6
89808: PUSH
89809: LD_VAR 0 6
89813: PUSH
89814: LD_INT 1
89816: NEG
89817: MUL
89818: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
89819: LD_ADDR_VAR 0 7
89823: PUSH
89824: LD_VAR 0 2
89828: PUSH
89829: LD_VAR 0 4
89833: PLUS
89834: PUSH
89835: LD_INT 2
89837: DIV
89838: ST_TO_ADDR
// if _y < 0 then
89839: LD_VAR 0 7
89843: PUSH
89844: LD_INT 0
89846: LESS
89847: IFFALSE 89864
// _y := _y * - 1 ;
89849: LD_ADDR_VAR 0 7
89853: PUSH
89854: LD_VAR 0 7
89858: PUSH
89859: LD_INT 1
89861: NEG
89862: MUL
89863: ST_TO_ADDR
// result := [ _x , _y ] ;
89864: LD_ADDR_VAR 0 5
89868: PUSH
89869: LD_VAR 0 6
89873: PUSH
89874: LD_VAR 0 7
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: ST_TO_ADDR
// end ;
89883: LD_VAR 0 5
89887: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
89888: LD_INT 0
89890: PPUSH
89891: PPUSH
89892: PPUSH
89893: PPUSH
// task := GetTaskList ( unit ) ;
89894: LD_ADDR_VAR 0 7
89898: PUSH
89899: LD_VAR 0 1
89903: PPUSH
89904: CALL_OW 437
89908: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
89909: LD_VAR 0 7
89913: NOT
89914: PUSH
89915: LD_VAR 0 1
89919: PPUSH
89920: LD_VAR 0 2
89924: PPUSH
89925: CALL_OW 308
89929: NOT
89930: AND
89931: IFFALSE 89935
// exit ;
89933: GO 90053
// if IsInArea ( unit , area ) then
89935: LD_VAR 0 1
89939: PPUSH
89940: LD_VAR 0 2
89944: PPUSH
89945: CALL_OW 308
89949: IFFALSE 89967
// begin ComMoveToArea ( unit , goAway ) ;
89951: LD_VAR 0 1
89955: PPUSH
89956: LD_VAR 0 3
89960: PPUSH
89961: CALL_OW 113
// exit ;
89965: GO 90053
// end ; if task [ 1 ] [ 1 ] <> M then
89967: LD_VAR 0 7
89971: PUSH
89972: LD_INT 1
89974: ARRAY
89975: PUSH
89976: LD_INT 1
89978: ARRAY
89979: PUSH
89980: LD_STRING M
89982: NONEQUAL
89983: IFFALSE 89987
// exit ;
89985: GO 90053
// x := task [ 1 ] [ 2 ] ;
89987: LD_ADDR_VAR 0 5
89991: PUSH
89992: LD_VAR 0 7
89996: PUSH
89997: LD_INT 1
89999: ARRAY
90000: PUSH
90001: LD_INT 2
90003: ARRAY
90004: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
90005: LD_ADDR_VAR 0 6
90009: PUSH
90010: LD_VAR 0 7
90014: PUSH
90015: LD_INT 1
90017: ARRAY
90018: PUSH
90019: LD_INT 3
90021: ARRAY
90022: ST_TO_ADDR
// if InArea ( x , y , area ) then
90023: LD_VAR 0 5
90027: PPUSH
90028: LD_VAR 0 6
90032: PPUSH
90033: LD_VAR 0 2
90037: PPUSH
90038: CALL_OW 309
90042: IFFALSE 90053
// ComStop ( unit ) ;
90044: LD_VAR 0 1
90048: PPUSH
90049: CALL_OW 141
// end ;
90053: LD_VAR 0 4
90057: RET
// export function Abs ( value ) ; begin
90058: LD_INT 0
90060: PPUSH
// result := value ;
90061: LD_ADDR_VAR 0 2
90065: PUSH
90066: LD_VAR 0 1
90070: ST_TO_ADDR
// if value < 0 then
90071: LD_VAR 0 1
90075: PUSH
90076: LD_INT 0
90078: LESS
90079: IFFALSE 90096
// result := value * - 1 ;
90081: LD_ADDR_VAR 0 2
90085: PUSH
90086: LD_VAR 0 1
90090: PUSH
90091: LD_INT 1
90093: NEG
90094: MUL
90095: ST_TO_ADDR
// end ;
90096: LD_VAR 0 2
90100: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
90101: LD_INT 0
90103: PPUSH
90104: PPUSH
90105: PPUSH
90106: PPUSH
90107: PPUSH
90108: PPUSH
90109: PPUSH
90110: PPUSH
// if not unit or not building then
90111: LD_VAR 0 1
90115: NOT
90116: PUSH
90117: LD_VAR 0 2
90121: NOT
90122: OR
90123: IFFALSE 90127
// exit ;
90125: GO 90353
// x := GetX ( building ) ;
90127: LD_ADDR_VAR 0 4
90131: PUSH
90132: LD_VAR 0 2
90136: PPUSH
90137: CALL_OW 250
90141: ST_TO_ADDR
// y := GetY ( building ) ;
90142: LD_ADDR_VAR 0 6
90146: PUSH
90147: LD_VAR 0 2
90151: PPUSH
90152: CALL_OW 251
90156: ST_TO_ADDR
// d := GetDir ( building ) ;
90157: LD_ADDR_VAR 0 8
90161: PUSH
90162: LD_VAR 0 2
90166: PPUSH
90167: CALL_OW 254
90171: ST_TO_ADDR
// r := 4 ;
90172: LD_ADDR_VAR 0 9
90176: PUSH
90177: LD_INT 4
90179: ST_TO_ADDR
// for i := 1 to 5 do
90180: LD_ADDR_VAR 0 10
90184: PUSH
90185: DOUBLE
90186: LD_INT 1
90188: DEC
90189: ST_TO_ADDR
90190: LD_INT 5
90192: PUSH
90193: FOR_TO
90194: IFFALSE 90351
// begin _x := ShiftX ( x , d , r + i ) ;
90196: LD_ADDR_VAR 0 5
90200: PUSH
90201: LD_VAR 0 4
90205: PPUSH
90206: LD_VAR 0 8
90210: PPUSH
90211: LD_VAR 0 9
90215: PUSH
90216: LD_VAR 0 10
90220: PLUS
90221: PPUSH
90222: CALL_OW 272
90226: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
90227: LD_ADDR_VAR 0 7
90231: PUSH
90232: LD_VAR 0 6
90236: PPUSH
90237: LD_VAR 0 8
90241: PPUSH
90242: LD_VAR 0 9
90246: PUSH
90247: LD_VAR 0 10
90251: PLUS
90252: PPUSH
90253: CALL_OW 273
90257: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
90258: LD_VAR 0 5
90262: PPUSH
90263: LD_VAR 0 7
90267: PPUSH
90268: CALL_OW 488
90272: PUSH
90273: LD_VAR 0 5
90277: PPUSH
90278: LD_VAR 0 7
90282: PPUSH
90283: CALL_OW 428
90287: PPUSH
90288: CALL_OW 247
90292: PUSH
90293: LD_INT 3
90295: PUSH
90296: LD_INT 2
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: IN
90303: NOT
90304: AND
90305: IFFALSE 90349
// begin ComMoveXY ( unit , _x , _y ) ;
90307: LD_VAR 0 1
90311: PPUSH
90312: LD_VAR 0 5
90316: PPUSH
90317: LD_VAR 0 7
90321: PPUSH
90322: CALL_OW 111
// result := [ _x , _y ] ;
90326: LD_ADDR_VAR 0 3
90330: PUSH
90331: LD_VAR 0 5
90335: PUSH
90336: LD_VAR 0 7
90340: PUSH
90341: EMPTY
90342: LIST
90343: LIST
90344: ST_TO_ADDR
// exit ;
90345: POP
90346: POP
90347: GO 90353
// end ; end ;
90349: GO 90193
90351: POP
90352: POP
// end ;
90353: LD_VAR 0 3
90357: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
90358: LD_INT 0
90360: PPUSH
90361: PPUSH
90362: PPUSH
// result := 0 ;
90363: LD_ADDR_VAR 0 3
90367: PUSH
90368: LD_INT 0
90370: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
90371: LD_VAR 0 1
90375: PUSH
90376: LD_INT 0
90378: LESS
90379: PUSH
90380: LD_VAR 0 1
90384: PUSH
90385: LD_INT 8
90387: GREATER
90388: OR
90389: PUSH
90390: LD_VAR 0 2
90394: PUSH
90395: LD_INT 0
90397: LESS
90398: OR
90399: PUSH
90400: LD_VAR 0 2
90404: PUSH
90405: LD_INT 8
90407: GREATER
90408: OR
90409: IFFALSE 90413
// exit ;
90411: GO 90488
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
90413: LD_ADDR_VAR 0 4
90417: PUSH
90418: LD_INT 22
90420: PUSH
90421: LD_VAR 0 2
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PPUSH
90430: CALL_OW 69
90434: PUSH
90435: FOR_IN
90436: IFFALSE 90486
// begin un := UnitShoot ( i ) ;
90438: LD_ADDR_VAR 0 5
90442: PUSH
90443: LD_VAR 0 4
90447: PPUSH
90448: CALL_OW 504
90452: ST_TO_ADDR
// if GetSide ( un ) = side1 then
90453: LD_VAR 0 5
90457: PPUSH
90458: CALL_OW 255
90462: PUSH
90463: LD_VAR 0 1
90467: EQUAL
90468: IFFALSE 90484
// begin result := un ;
90470: LD_ADDR_VAR 0 3
90474: PUSH
90475: LD_VAR 0 5
90479: ST_TO_ADDR
// exit ;
90480: POP
90481: POP
90482: GO 90488
// end ; end ;
90484: GO 90435
90486: POP
90487: POP
// end ;
90488: LD_VAR 0 3
90492: RET
// export function GetCargoBay ( units ) ; begin
90493: LD_INT 0
90495: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
90496: LD_ADDR_VAR 0 2
90500: PUSH
90501: LD_VAR 0 1
90505: PPUSH
90506: LD_INT 2
90508: PUSH
90509: LD_INT 34
90511: PUSH
90512: LD_INT 12
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 34
90521: PUSH
90522: LD_INT 51
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 34
90531: PUSH
90532: LD_INT 32
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 34
90541: PUSH
90542: LD_INT 89
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: PPUSH
90556: CALL_OW 72
90560: ST_TO_ADDR
// end ;
90561: LD_VAR 0 2
90565: RET
// export function Negate ( value ) ; begin
90566: LD_INT 0
90568: PPUSH
// result := not value ;
90569: LD_ADDR_VAR 0 2
90573: PUSH
90574: LD_VAR 0 1
90578: NOT
90579: ST_TO_ADDR
// end ;
90580: LD_VAR 0 2
90584: RET
// export function Inc ( value ) ; begin
90585: LD_INT 0
90587: PPUSH
// result := value + 1 ;
90588: LD_ADDR_VAR 0 2
90592: PUSH
90593: LD_VAR 0 1
90597: PUSH
90598: LD_INT 1
90600: PLUS
90601: ST_TO_ADDR
// end ;
90602: LD_VAR 0 2
90606: RET
// export function Dec ( value ) ; begin
90607: LD_INT 0
90609: PPUSH
// result := value - 1 ;
90610: LD_ADDR_VAR 0 2
90614: PUSH
90615: LD_VAR 0 1
90619: PUSH
90620: LD_INT 1
90622: MINUS
90623: ST_TO_ADDR
// end ;
90624: LD_VAR 0 2
90628: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
90629: LD_INT 0
90631: PPUSH
90632: PPUSH
90633: PPUSH
90634: PPUSH
90635: PPUSH
90636: PPUSH
90637: PPUSH
90638: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
90639: LD_VAR 0 1
90643: PPUSH
90644: LD_VAR 0 2
90648: PPUSH
90649: CALL_OW 488
90653: NOT
90654: PUSH
90655: LD_VAR 0 3
90659: PPUSH
90660: LD_VAR 0 4
90664: PPUSH
90665: CALL_OW 488
90669: NOT
90670: OR
90671: IFFALSE 90684
// begin result := - 1 ;
90673: LD_ADDR_VAR 0 5
90677: PUSH
90678: LD_INT 1
90680: NEG
90681: ST_TO_ADDR
// exit ;
90682: GO 90919
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
90684: LD_ADDR_VAR 0 12
90688: PUSH
90689: LD_VAR 0 1
90693: PPUSH
90694: LD_VAR 0 2
90698: PPUSH
90699: LD_VAR 0 3
90703: PPUSH
90704: LD_VAR 0 4
90708: PPUSH
90709: CALL 89769 0 4
90713: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
90714: LD_ADDR_VAR 0 11
90718: PUSH
90719: LD_VAR 0 1
90723: PPUSH
90724: LD_VAR 0 2
90728: PPUSH
90729: LD_VAR 0 12
90733: PUSH
90734: LD_INT 1
90736: ARRAY
90737: PPUSH
90738: LD_VAR 0 12
90742: PUSH
90743: LD_INT 2
90745: ARRAY
90746: PPUSH
90747: CALL_OW 298
90751: ST_TO_ADDR
// distance := 9999 ;
90752: LD_ADDR_VAR 0 10
90756: PUSH
90757: LD_INT 9999
90759: ST_TO_ADDR
// for i := 0 to 5 do
90760: LD_ADDR_VAR 0 6
90764: PUSH
90765: DOUBLE
90766: LD_INT 0
90768: DEC
90769: ST_TO_ADDR
90770: LD_INT 5
90772: PUSH
90773: FOR_TO
90774: IFFALSE 90917
// begin _x := ShiftX ( x1 , i , centerDist ) ;
90776: LD_ADDR_VAR 0 7
90780: PUSH
90781: LD_VAR 0 1
90785: PPUSH
90786: LD_VAR 0 6
90790: PPUSH
90791: LD_VAR 0 11
90795: PPUSH
90796: CALL_OW 272
90800: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
90801: LD_ADDR_VAR 0 8
90805: PUSH
90806: LD_VAR 0 2
90810: PPUSH
90811: LD_VAR 0 6
90815: PPUSH
90816: LD_VAR 0 11
90820: PPUSH
90821: CALL_OW 273
90825: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
90826: LD_VAR 0 7
90830: PPUSH
90831: LD_VAR 0 8
90835: PPUSH
90836: CALL_OW 488
90840: NOT
90841: IFFALSE 90845
// continue ;
90843: GO 90773
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
90845: LD_ADDR_VAR 0 9
90849: PUSH
90850: LD_VAR 0 12
90854: PUSH
90855: LD_INT 1
90857: ARRAY
90858: PPUSH
90859: LD_VAR 0 12
90863: PUSH
90864: LD_INT 2
90866: ARRAY
90867: PPUSH
90868: LD_VAR 0 7
90872: PPUSH
90873: LD_VAR 0 8
90877: PPUSH
90878: CALL_OW 298
90882: ST_TO_ADDR
// if tmp < distance then
90883: LD_VAR 0 9
90887: PUSH
90888: LD_VAR 0 10
90892: LESS
90893: IFFALSE 90915
// begin result := i ;
90895: LD_ADDR_VAR 0 5
90899: PUSH
90900: LD_VAR 0 6
90904: ST_TO_ADDR
// distance := tmp ;
90905: LD_ADDR_VAR 0 10
90909: PUSH
90910: LD_VAR 0 9
90914: ST_TO_ADDR
// end ; end ;
90915: GO 90773
90917: POP
90918: POP
// end ;
90919: LD_VAR 0 5
90923: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90924: LD_INT 0
90926: PPUSH
90927: PPUSH
// if not driver or not IsInUnit ( driver ) then
90928: LD_VAR 0 1
90932: NOT
90933: PUSH
90934: LD_VAR 0 1
90938: PPUSH
90939: CALL_OW 310
90943: NOT
90944: OR
90945: IFFALSE 90949
// exit ;
90947: GO 91039
// vehicle := IsInUnit ( driver ) ;
90949: LD_ADDR_VAR 0 3
90953: PUSH
90954: LD_VAR 0 1
90958: PPUSH
90959: CALL_OW 310
90963: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90964: LD_VAR 0 1
90968: PPUSH
90969: LD_STRING \
90971: PUSH
90972: LD_INT 0
90974: PUSH
90975: LD_INT 0
90977: PUSH
90978: LD_INT 0
90980: PUSH
90981: LD_INT 0
90983: PUSH
90984: LD_INT 0
90986: PUSH
90987: LD_INT 0
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: PUSH
90999: LD_STRING E
91001: PUSH
91002: LD_INT 0
91004: PUSH
91005: LD_INT 0
91007: PUSH
91008: LD_VAR 0 3
91012: PUSH
91013: LD_INT 0
91015: PUSH
91016: LD_INT 0
91018: PUSH
91019: LD_INT 0
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: PUSH
91031: EMPTY
91032: LIST
91033: LIST
91034: PPUSH
91035: CALL_OW 446
// end ;
91039: LD_VAR 0 2
91043: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91044: LD_INT 0
91046: PPUSH
91047: PPUSH
// if not driver or not IsInUnit ( driver ) then
91048: LD_VAR 0 1
91052: NOT
91053: PUSH
91054: LD_VAR 0 1
91058: PPUSH
91059: CALL_OW 310
91063: NOT
91064: OR
91065: IFFALSE 91069
// exit ;
91067: GO 91159
// vehicle := IsInUnit ( driver ) ;
91069: LD_ADDR_VAR 0 3
91073: PUSH
91074: LD_VAR 0 1
91078: PPUSH
91079: CALL_OW 310
91083: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91084: LD_VAR 0 1
91088: PPUSH
91089: LD_STRING \
91091: PUSH
91092: LD_INT 0
91094: PUSH
91095: LD_INT 0
91097: PUSH
91098: LD_INT 0
91100: PUSH
91101: LD_INT 0
91103: PUSH
91104: LD_INT 0
91106: PUSH
91107: LD_INT 0
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: LIST
91116: LIST
91117: LIST
91118: PUSH
91119: LD_STRING E
91121: PUSH
91122: LD_INT 0
91124: PUSH
91125: LD_INT 0
91127: PUSH
91128: LD_VAR 0 3
91132: PUSH
91133: LD_INT 0
91135: PUSH
91136: LD_INT 0
91138: PUSH
91139: LD_INT 0
91141: PUSH
91142: EMPTY
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: LIST
91150: PUSH
91151: EMPTY
91152: LIST
91153: LIST
91154: PPUSH
91155: CALL_OW 447
// end ;
91159: LD_VAR 0 2
91163: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
91164: LD_INT 0
91166: PPUSH
91167: PPUSH
91168: PPUSH
// tmp := [ ] ;
91169: LD_ADDR_VAR 0 5
91173: PUSH
91174: EMPTY
91175: ST_TO_ADDR
// for i in units do
91176: LD_ADDR_VAR 0 4
91180: PUSH
91181: LD_VAR 0 1
91185: PUSH
91186: FOR_IN
91187: IFFALSE 91225
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
91189: LD_ADDR_VAR 0 5
91193: PUSH
91194: LD_VAR 0 5
91198: PPUSH
91199: LD_VAR 0 5
91203: PUSH
91204: LD_INT 1
91206: PLUS
91207: PPUSH
91208: LD_VAR 0 4
91212: PPUSH
91213: CALL_OW 256
91217: PPUSH
91218: CALL_OW 2
91222: ST_TO_ADDR
91223: GO 91186
91225: POP
91226: POP
// if not tmp then
91227: LD_VAR 0 5
91231: NOT
91232: IFFALSE 91236
// exit ;
91234: GO 91284
// if asc then
91236: LD_VAR 0 2
91240: IFFALSE 91264
// result := SortListByListAsc ( units , tmp ) else
91242: LD_ADDR_VAR 0 3
91246: PUSH
91247: LD_VAR 0 1
91251: PPUSH
91252: LD_VAR 0 5
91256: PPUSH
91257: CALL_OW 76
91261: ST_TO_ADDR
91262: GO 91284
// result := SortListByListDesc ( units , tmp ) ;
91264: LD_ADDR_VAR 0 3
91268: PUSH
91269: LD_VAR 0 1
91273: PPUSH
91274: LD_VAR 0 5
91278: PPUSH
91279: CALL_OW 77
91283: ST_TO_ADDR
// end ;
91284: LD_VAR 0 3
91288: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
91289: LD_INT 0
91291: PPUSH
91292: PPUSH
// task := GetTaskList ( mech ) ;
91293: LD_ADDR_VAR 0 4
91297: PUSH
91298: LD_VAR 0 1
91302: PPUSH
91303: CALL_OW 437
91307: ST_TO_ADDR
// if not task then
91308: LD_VAR 0 4
91312: NOT
91313: IFFALSE 91317
// exit ;
91315: GO 91359
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
91317: LD_ADDR_VAR 0 3
91321: PUSH
91322: LD_VAR 0 4
91326: PUSH
91327: LD_INT 1
91329: ARRAY
91330: PUSH
91331: LD_INT 1
91333: ARRAY
91334: PUSH
91335: LD_STRING r
91337: EQUAL
91338: PUSH
91339: LD_VAR 0 4
91343: PUSH
91344: LD_INT 1
91346: ARRAY
91347: PUSH
91348: LD_INT 4
91350: ARRAY
91351: PUSH
91352: LD_VAR 0 2
91356: EQUAL
91357: AND
91358: ST_TO_ADDR
// end ;
91359: LD_VAR 0 3
91363: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
91364: LD_INT 0
91366: PPUSH
// SetDir ( unit , d ) ;
91367: LD_VAR 0 1
91371: PPUSH
91372: LD_VAR 0 4
91376: PPUSH
91377: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
91381: LD_VAR 0 1
91385: PPUSH
91386: LD_VAR 0 2
91390: PPUSH
91391: LD_VAR 0 3
91395: PPUSH
91396: LD_VAR 0 5
91400: PPUSH
91401: CALL_OW 48
// end ;
91405: LD_VAR 0 6
91409: RET
// export function ToNaturalNumber ( number ) ; begin
91410: LD_INT 0
91412: PPUSH
// result := number div 1 ;
91413: LD_ADDR_VAR 0 2
91417: PUSH
91418: LD_VAR 0 1
91422: PUSH
91423: LD_INT 1
91425: DIV
91426: ST_TO_ADDR
// if number < 0 then
91427: LD_VAR 0 1
91431: PUSH
91432: LD_INT 0
91434: LESS
91435: IFFALSE 91445
// result := 0 ;
91437: LD_ADDR_VAR 0 2
91441: PUSH
91442: LD_INT 0
91444: ST_TO_ADDR
// end ;
91445: LD_VAR 0 2
91449: RET
// export function SortByClass ( units , class ) ; var un ; begin
91450: LD_INT 0
91452: PPUSH
91453: PPUSH
// if not units or not class then
91454: LD_VAR 0 1
91458: NOT
91459: PUSH
91460: LD_VAR 0 2
91464: NOT
91465: OR
91466: IFFALSE 91470
// exit ;
91468: GO 91565
// result := [ ] ;
91470: LD_ADDR_VAR 0 3
91474: PUSH
91475: EMPTY
91476: ST_TO_ADDR
// for un in units do
91477: LD_ADDR_VAR 0 4
91481: PUSH
91482: LD_VAR 0 1
91486: PUSH
91487: FOR_IN
91488: IFFALSE 91563
// if GetClass ( un ) = class then
91490: LD_VAR 0 4
91494: PPUSH
91495: CALL_OW 257
91499: PUSH
91500: LD_VAR 0 2
91504: EQUAL
91505: IFFALSE 91532
// result := Insert ( result , 1 , un ) else
91507: LD_ADDR_VAR 0 3
91511: PUSH
91512: LD_VAR 0 3
91516: PPUSH
91517: LD_INT 1
91519: PPUSH
91520: LD_VAR 0 4
91524: PPUSH
91525: CALL_OW 2
91529: ST_TO_ADDR
91530: GO 91561
// result := Replace ( result , result + 1 , un ) ;
91532: LD_ADDR_VAR 0 3
91536: PUSH
91537: LD_VAR 0 3
91541: PPUSH
91542: LD_VAR 0 3
91546: PUSH
91547: LD_INT 1
91549: PLUS
91550: PPUSH
91551: LD_VAR 0 4
91555: PPUSH
91556: CALL_OW 1
91560: ST_TO_ADDR
91561: GO 91487
91563: POP
91564: POP
// end ;
91565: LD_VAR 0 3
91569: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
91570: LD_INT 0
91572: PPUSH
91573: PPUSH
91574: PPUSH
91575: PPUSH
91576: PPUSH
91577: PPUSH
91578: PPUSH
// result := [ ] ;
91579: LD_ADDR_VAR 0 4
91583: PUSH
91584: EMPTY
91585: ST_TO_ADDR
// if x - r < 0 then
91586: LD_VAR 0 1
91590: PUSH
91591: LD_VAR 0 3
91595: MINUS
91596: PUSH
91597: LD_INT 0
91599: LESS
91600: IFFALSE 91612
// min_x := 0 else
91602: LD_ADDR_VAR 0 8
91606: PUSH
91607: LD_INT 0
91609: ST_TO_ADDR
91610: GO 91628
// min_x := x - r ;
91612: LD_ADDR_VAR 0 8
91616: PUSH
91617: LD_VAR 0 1
91621: PUSH
91622: LD_VAR 0 3
91626: MINUS
91627: ST_TO_ADDR
// if y - r < 0 then
91628: LD_VAR 0 2
91632: PUSH
91633: LD_VAR 0 3
91637: MINUS
91638: PUSH
91639: LD_INT 0
91641: LESS
91642: IFFALSE 91654
// min_y := 0 else
91644: LD_ADDR_VAR 0 7
91648: PUSH
91649: LD_INT 0
91651: ST_TO_ADDR
91652: GO 91670
// min_y := y - r ;
91654: LD_ADDR_VAR 0 7
91658: PUSH
91659: LD_VAR 0 2
91663: PUSH
91664: LD_VAR 0 3
91668: MINUS
91669: ST_TO_ADDR
// max_x := x + r ;
91670: LD_ADDR_VAR 0 9
91674: PUSH
91675: LD_VAR 0 1
91679: PUSH
91680: LD_VAR 0 3
91684: PLUS
91685: ST_TO_ADDR
// max_y := y + r ;
91686: LD_ADDR_VAR 0 10
91690: PUSH
91691: LD_VAR 0 2
91695: PUSH
91696: LD_VAR 0 3
91700: PLUS
91701: ST_TO_ADDR
// for _x = min_x to max_x do
91702: LD_ADDR_VAR 0 5
91706: PUSH
91707: DOUBLE
91708: LD_VAR 0 8
91712: DEC
91713: ST_TO_ADDR
91714: LD_VAR 0 9
91718: PUSH
91719: FOR_TO
91720: IFFALSE 91821
// for _y = min_y to max_y do
91722: LD_ADDR_VAR 0 6
91726: PUSH
91727: DOUBLE
91728: LD_VAR 0 7
91732: DEC
91733: ST_TO_ADDR
91734: LD_VAR 0 10
91738: PUSH
91739: FOR_TO
91740: IFFALSE 91817
// begin if not ValidHex ( _x , _y ) then
91742: LD_VAR 0 5
91746: PPUSH
91747: LD_VAR 0 6
91751: PPUSH
91752: CALL_OW 488
91756: NOT
91757: IFFALSE 91761
// continue ;
91759: GO 91739
// if GetResourceTypeXY ( _x , _y ) then
91761: LD_VAR 0 5
91765: PPUSH
91766: LD_VAR 0 6
91770: PPUSH
91771: CALL_OW 283
91775: IFFALSE 91815
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
91777: LD_ADDR_VAR 0 4
91781: PUSH
91782: LD_VAR 0 4
91786: PPUSH
91787: LD_VAR 0 4
91791: PUSH
91792: LD_INT 1
91794: PLUS
91795: PPUSH
91796: LD_VAR 0 5
91800: PUSH
91801: LD_VAR 0 6
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: PPUSH
91810: CALL_OW 1
91814: ST_TO_ADDR
// end ;
91815: GO 91739
91817: POP
91818: POP
91819: GO 91719
91821: POP
91822: POP
// end ;
91823: LD_VAR 0 4
91827: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
91828: LD_INT 0
91830: PPUSH
91831: PPUSH
91832: PPUSH
91833: PPUSH
91834: PPUSH
91835: PPUSH
91836: PPUSH
91837: PPUSH
// if not units then
91838: LD_VAR 0 1
91842: NOT
91843: IFFALSE 91847
// exit ;
91845: GO 92371
// result := UnitFilter ( units , [ f_ok ] ) ;
91847: LD_ADDR_VAR 0 3
91851: PUSH
91852: LD_VAR 0 1
91856: PPUSH
91857: LD_INT 50
91859: PUSH
91860: EMPTY
91861: LIST
91862: PPUSH
91863: CALL_OW 72
91867: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
91868: LD_ADDR_VAR 0 8
91872: PUSH
91873: LD_VAR 0 1
91877: PUSH
91878: LD_INT 1
91880: ARRAY
91881: PPUSH
91882: CALL_OW 255
91886: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
91887: LD_ADDR_VAR 0 10
91891: PUSH
91892: LD_INT 29
91894: PUSH
91895: LD_INT 91
91897: PUSH
91898: LD_INT 49
91900: PUSH
91901: EMPTY
91902: LIST
91903: LIST
91904: LIST
91905: ST_TO_ADDR
// if not result then
91906: LD_VAR 0 3
91910: NOT
91911: IFFALSE 91915
// exit ;
91913: GO 92371
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
91915: LD_ADDR_VAR 0 5
91919: PUSH
91920: LD_INT 81
91922: PUSH
91923: LD_VAR 0 8
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PPUSH
91932: CALL_OW 69
91936: ST_TO_ADDR
// for i in result do
91937: LD_ADDR_VAR 0 4
91941: PUSH
91942: LD_VAR 0 3
91946: PUSH
91947: FOR_IN
91948: IFFALSE 92369
// begin tag := GetTag ( i ) + 1 ;
91950: LD_ADDR_VAR 0 9
91954: PUSH
91955: LD_VAR 0 4
91959: PPUSH
91960: CALL_OW 110
91964: PUSH
91965: LD_INT 1
91967: PLUS
91968: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
91969: LD_ADDR_VAR 0 7
91973: PUSH
91974: LD_VAR 0 4
91978: PPUSH
91979: CALL_OW 250
91983: PPUSH
91984: LD_VAR 0 4
91988: PPUSH
91989: CALL_OW 251
91993: PPUSH
91994: LD_INT 6
91996: PPUSH
91997: CALL 91570 0 3
92001: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
92002: LD_VAR 0 4
92006: PPUSH
92007: CALL_OW 247
92011: PUSH
92012: LD_INT 2
92014: EQUAL
92015: PUSH
92016: LD_VAR 0 7
92020: AND
92021: PUSH
92022: LD_VAR 0 4
92026: PPUSH
92027: CALL_OW 264
92031: PUSH
92032: LD_VAR 0 10
92036: IN
92037: NOT
92038: AND
92039: IFFALSE 92078
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
92041: LD_VAR 0 4
92045: PPUSH
92046: LD_VAR 0 7
92050: PUSH
92051: LD_INT 1
92053: ARRAY
92054: PUSH
92055: LD_INT 1
92057: ARRAY
92058: PPUSH
92059: LD_VAR 0 7
92063: PUSH
92064: LD_INT 1
92066: ARRAY
92067: PUSH
92068: LD_INT 2
92070: ARRAY
92071: PPUSH
92072: CALL_OW 116
92076: GO 92367
// if path > tag then
92078: LD_VAR 0 2
92082: PUSH
92083: LD_VAR 0 9
92087: GREATER
92088: IFFALSE 92296
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
92090: LD_ADDR_VAR 0 6
92094: PUSH
92095: LD_VAR 0 5
92099: PPUSH
92100: LD_INT 91
92102: PUSH
92103: LD_VAR 0 4
92107: PUSH
92108: LD_INT 8
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: LIST
92115: PPUSH
92116: CALL_OW 72
92120: ST_TO_ADDR
// if nearEnemy then
92121: LD_VAR 0 6
92125: IFFALSE 92194
// begin if GetWeapon ( i ) = ru_time_lapser then
92127: LD_VAR 0 4
92131: PPUSH
92132: CALL_OW 264
92136: PUSH
92137: LD_INT 49
92139: EQUAL
92140: IFFALSE 92168
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
92142: LD_VAR 0 4
92146: PPUSH
92147: LD_VAR 0 6
92151: PPUSH
92152: LD_VAR 0 4
92156: PPUSH
92157: CALL_OW 74
92161: PPUSH
92162: CALL_OW 112
92166: GO 92192
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
92168: LD_VAR 0 4
92172: PPUSH
92173: LD_VAR 0 6
92177: PPUSH
92178: LD_VAR 0 4
92182: PPUSH
92183: CALL_OW 74
92187: PPUSH
92188: CALL_OW 115
// end else
92192: GO 92294
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
92194: LD_VAR 0 4
92198: PPUSH
92199: LD_VAR 0 2
92203: PUSH
92204: LD_VAR 0 9
92208: ARRAY
92209: PUSH
92210: LD_INT 1
92212: ARRAY
92213: PPUSH
92214: LD_VAR 0 2
92218: PUSH
92219: LD_VAR 0 9
92223: ARRAY
92224: PUSH
92225: LD_INT 2
92227: ARRAY
92228: PPUSH
92229: CALL_OW 297
92233: PUSH
92234: LD_INT 6
92236: GREATER
92237: IFFALSE 92280
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
92239: LD_VAR 0 4
92243: PPUSH
92244: LD_VAR 0 2
92248: PUSH
92249: LD_VAR 0 9
92253: ARRAY
92254: PUSH
92255: LD_INT 1
92257: ARRAY
92258: PPUSH
92259: LD_VAR 0 2
92263: PUSH
92264: LD_VAR 0 9
92268: ARRAY
92269: PUSH
92270: LD_INT 2
92272: ARRAY
92273: PPUSH
92274: CALL_OW 114
92278: GO 92294
// SetTag ( i , tag ) ;
92280: LD_VAR 0 4
92284: PPUSH
92285: LD_VAR 0 9
92289: PPUSH
92290: CALL_OW 109
// end else
92294: GO 92367
// if enemy then
92296: LD_VAR 0 5
92300: IFFALSE 92367
// begin if GetWeapon ( i ) = ru_time_lapser then
92302: LD_VAR 0 4
92306: PPUSH
92307: CALL_OW 264
92311: PUSH
92312: LD_INT 49
92314: EQUAL
92315: IFFALSE 92343
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
92317: LD_VAR 0 4
92321: PPUSH
92322: LD_VAR 0 5
92326: PPUSH
92327: LD_VAR 0 4
92331: PPUSH
92332: CALL_OW 74
92336: PPUSH
92337: CALL_OW 112
92341: GO 92367
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
92343: LD_VAR 0 4
92347: PPUSH
92348: LD_VAR 0 5
92352: PPUSH
92353: LD_VAR 0 4
92357: PPUSH
92358: CALL_OW 74
92362: PPUSH
92363: CALL_OW 115
// end ; end ;
92367: GO 91947
92369: POP
92370: POP
// end ;
92371: LD_VAR 0 3
92375: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
92376: LD_INT 0
92378: PPUSH
92379: PPUSH
92380: PPUSH
// if not unit or IsInUnit ( unit ) then
92381: LD_VAR 0 1
92385: NOT
92386: PUSH
92387: LD_VAR 0 1
92391: PPUSH
92392: CALL_OW 310
92396: OR
92397: IFFALSE 92401
// exit ;
92399: GO 92492
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
92401: LD_ADDR_VAR 0 4
92405: PUSH
92406: LD_VAR 0 1
92410: PPUSH
92411: CALL_OW 250
92415: PPUSH
92416: LD_VAR 0 2
92420: PPUSH
92421: LD_INT 1
92423: PPUSH
92424: CALL_OW 272
92428: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
92429: LD_ADDR_VAR 0 5
92433: PUSH
92434: LD_VAR 0 1
92438: PPUSH
92439: CALL_OW 251
92443: PPUSH
92444: LD_VAR 0 2
92448: PPUSH
92449: LD_INT 1
92451: PPUSH
92452: CALL_OW 273
92456: ST_TO_ADDR
// if ValidHex ( x , y ) then
92457: LD_VAR 0 4
92461: PPUSH
92462: LD_VAR 0 5
92466: PPUSH
92467: CALL_OW 488
92471: IFFALSE 92492
// ComTurnXY ( unit , x , y ) ;
92473: LD_VAR 0 1
92477: PPUSH
92478: LD_VAR 0 4
92482: PPUSH
92483: LD_VAR 0 5
92487: PPUSH
92488: CALL_OW 118
// end ;
92492: LD_VAR 0 3
92496: RET
// export function SeeUnits ( side , units ) ; var i ; begin
92497: LD_INT 0
92499: PPUSH
92500: PPUSH
// result := false ;
92501: LD_ADDR_VAR 0 3
92505: PUSH
92506: LD_INT 0
92508: ST_TO_ADDR
// if not units then
92509: LD_VAR 0 2
92513: NOT
92514: IFFALSE 92518
// exit ;
92516: GO 92563
// for i in units do
92518: LD_ADDR_VAR 0 4
92522: PUSH
92523: LD_VAR 0 2
92527: PUSH
92528: FOR_IN
92529: IFFALSE 92561
// if See ( side , i ) then
92531: LD_VAR 0 1
92535: PPUSH
92536: LD_VAR 0 4
92540: PPUSH
92541: CALL_OW 292
92545: IFFALSE 92559
// begin result := true ;
92547: LD_ADDR_VAR 0 3
92551: PUSH
92552: LD_INT 1
92554: ST_TO_ADDR
// exit ;
92555: POP
92556: POP
92557: GO 92563
// end ;
92559: GO 92528
92561: POP
92562: POP
// end ;
92563: LD_VAR 0 3
92567: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
92568: LD_INT 0
92570: PPUSH
92571: PPUSH
92572: PPUSH
92573: PPUSH
// if not unit or not points then
92574: LD_VAR 0 1
92578: NOT
92579: PUSH
92580: LD_VAR 0 2
92584: NOT
92585: OR
92586: IFFALSE 92590
// exit ;
92588: GO 92680
// dist := 99999 ;
92590: LD_ADDR_VAR 0 5
92594: PUSH
92595: LD_INT 99999
92597: ST_TO_ADDR
// for i in points do
92598: LD_ADDR_VAR 0 4
92602: PUSH
92603: LD_VAR 0 2
92607: PUSH
92608: FOR_IN
92609: IFFALSE 92678
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
92611: LD_ADDR_VAR 0 6
92615: PUSH
92616: LD_VAR 0 1
92620: PPUSH
92621: LD_VAR 0 4
92625: PUSH
92626: LD_INT 1
92628: ARRAY
92629: PPUSH
92630: LD_VAR 0 4
92634: PUSH
92635: LD_INT 2
92637: ARRAY
92638: PPUSH
92639: CALL_OW 297
92643: ST_TO_ADDR
// if tmpDist < dist then
92644: LD_VAR 0 6
92648: PUSH
92649: LD_VAR 0 5
92653: LESS
92654: IFFALSE 92676
// begin result := i ;
92656: LD_ADDR_VAR 0 3
92660: PUSH
92661: LD_VAR 0 4
92665: ST_TO_ADDR
// dist := tmpDist ;
92666: LD_ADDR_VAR 0 5
92670: PUSH
92671: LD_VAR 0 6
92675: ST_TO_ADDR
// end ; end ;
92676: GO 92608
92678: POP
92679: POP
// end ;
92680: LD_VAR 0 3
92684: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
92685: LD_INT 0
92687: PPUSH
// uc_side := side ;
92688: LD_ADDR_OWVAR 20
92692: PUSH
92693: LD_VAR 0 1
92697: ST_TO_ADDR
// uc_nation := 3 ;
92698: LD_ADDR_OWVAR 21
92702: PUSH
92703: LD_INT 3
92705: ST_TO_ADDR
// vc_chassis := 25 ;
92706: LD_ADDR_OWVAR 37
92710: PUSH
92711: LD_INT 25
92713: ST_TO_ADDR
// vc_engine := engine_siberite ;
92714: LD_ADDR_OWVAR 39
92718: PUSH
92719: LD_INT 3
92721: ST_TO_ADDR
// vc_control := control_computer ;
92722: LD_ADDR_OWVAR 38
92726: PUSH
92727: LD_INT 3
92729: ST_TO_ADDR
// vc_weapon := 59 ;
92730: LD_ADDR_OWVAR 40
92734: PUSH
92735: LD_INT 59
92737: ST_TO_ADDR
// result := CreateVehicle ;
92738: LD_ADDR_VAR 0 5
92742: PUSH
92743: CALL_OW 45
92747: ST_TO_ADDR
// SetDir ( result , d ) ;
92748: LD_VAR 0 5
92752: PPUSH
92753: LD_VAR 0 4
92757: PPUSH
92758: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
92762: LD_VAR 0 5
92766: PPUSH
92767: LD_VAR 0 2
92771: PPUSH
92772: LD_VAR 0 3
92776: PPUSH
92777: LD_INT 0
92779: PPUSH
92780: CALL_OW 48
// end ;
92784: LD_VAR 0 5
92788: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
92789: LD_INT 0
92791: PPUSH
92792: PPUSH
92793: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
92794: LD_ADDR_VAR 0 2
92798: PUSH
92799: LD_INT 0
92801: PUSH
92802: LD_INT 0
92804: PUSH
92805: LD_INT 0
92807: PUSH
92808: LD_INT 0
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
92817: LD_VAR 0 1
92821: NOT
92822: PUSH
92823: LD_VAR 0 1
92827: PPUSH
92828: CALL_OW 264
92832: PUSH
92833: LD_INT 12
92835: PUSH
92836: LD_INT 51
92838: PUSH
92839: LD_INT 32
92841: PUSH
92842: LD_INT 89
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: IN
92851: NOT
92852: OR
92853: IFFALSE 92857
// exit ;
92855: GO 92955
// for i := 1 to 3 do
92857: LD_ADDR_VAR 0 3
92861: PUSH
92862: DOUBLE
92863: LD_INT 1
92865: DEC
92866: ST_TO_ADDR
92867: LD_INT 3
92869: PUSH
92870: FOR_TO
92871: IFFALSE 92953
// begin tmp := GetCargo ( cargo , i ) ;
92873: LD_ADDR_VAR 0 4
92877: PUSH
92878: LD_VAR 0 1
92882: PPUSH
92883: LD_VAR 0 3
92887: PPUSH
92888: CALL_OW 289
92892: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
92893: LD_ADDR_VAR 0 2
92897: PUSH
92898: LD_VAR 0 2
92902: PPUSH
92903: LD_VAR 0 3
92907: PPUSH
92908: LD_VAR 0 4
92912: PPUSH
92913: CALL_OW 1
92917: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
92918: LD_ADDR_VAR 0 2
92922: PUSH
92923: LD_VAR 0 2
92927: PPUSH
92928: LD_INT 4
92930: PPUSH
92931: LD_VAR 0 2
92935: PUSH
92936: LD_INT 4
92938: ARRAY
92939: PUSH
92940: LD_VAR 0 4
92944: PLUS
92945: PPUSH
92946: CALL_OW 1
92950: ST_TO_ADDR
// end ;
92951: GO 92870
92953: POP
92954: POP
// end ;
92955: LD_VAR 0 2
92959: RET
// export function Length ( array ) ; begin
92960: LD_INT 0
92962: PPUSH
// result := array + 0 ;
92963: LD_ADDR_VAR 0 2
92967: PUSH
92968: LD_VAR 0 1
92972: PUSH
92973: LD_INT 0
92975: PLUS
92976: ST_TO_ADDR
// end ;
92977: LD_VAR 0 2
92981: RET
// export function PrepareArray ( array ) ; begin
92982: LD_INT 0
92984: PPUSH
// result := array diff 0 ;
92985: LD_ADDR_VAR 0 2
92989: PUSH
92990: LD_VAR 0 1
92994: PUSH
92995: LD_INT 0
92997: DIFF
92998: ST_TO_ADDR
// if not result [ 1 ] then
92999: LD_VAR 0 2
93003: PUSH
93004: LD_INT 1
93006: ARRAY
93007: NOT
93008: IFFALSE 93028
// result := Delete ( result , 1 ) ;
93010: LD_ADDR_VAR 0 2
93014: PUSH
93015: LD_VAR 0 2
93019: PPUSH
93020: LD_INT 1
93022: PPUSH
93023: CALL_OW 3
93027: ST_TO_ADDR
// end ; end_of_file end_of_file
93028: LD_VAR 0 2
93032: RET
// every 0 0$1 do
93033: GO 93035
93035: DISABLE
// begin enable ;
93036: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93037: LD_STRING updateTimer(
93039: PUSH
93040: LD_OWVAR 1
93044: STR
93045: PUSH
93046: LD_STRING );
93048: STR
93049: PPUSH
93050: CALL_OW 559
// end ;
93054: END
// export function SOS_MapStart ( ) ; begin
93055: LD_INT 0
93057: PPUSH
// if streamModeActive then
93058: LD_EXP 120
93062: IFFALSE 93071
// DefineStreamItems ( true ) ;
93064: LD_INT 1
93066: PPUSH
93067: CALL 94725 0 1
// UpdateFactoryWaypoints ( ) ;
93071: CALL 107586 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93075: CALL 107843 0 0
// end ;
93079: LD_VAR 0 1
93083: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93084: LD_INT 0
93086: PPUSH
// if p2 = 100 then
93087: LD_VAR 0 2
93091: PUSH
93092: LD_INT 100
93094: EQUAL
93095: IFFALSE 94098
// begin if not StreamModeActive then
93097: LD_EXP 120
93101: NOT
93102: IFFALSE 93112
// StreamModeActive := true ;
93104: LD_ADDR_EXP 120
93108: PUSH
93109: LD_INT 1
93111: ST_TO_ADDR
// if p3 = 0 then
93112: LD_VAR 0 3
93116: PUSH
93117: LD_INT 0
93119: EQUAL
93120: IFFALSE 93126
// InitStreamMode ;
93122: CALL 94261 0 0
// if p3 = 1 then
93126: LD_VAR 0 3
93130: PUSH
93131: LD_INT 1
93133: EQUAL
93134: IFFALSE 93144
// sRocket := true ;
93136: LD_ADDR_EXP 125
93140: PUSH
93141: LD_INT 1
93143: ST_TO_ADDR
// if p3 = 2 then
93144: LD_VAR 0 3
93148: PUSH
93149: LD_INT 2
93151: EQUAL
93152: IFFALSE 93162
// sSpeed := true ;
93154: LD_ADDR_EXP 124
93158: PUSH
93159: LD_INT 1
93161: ST_TO_ADDR
// if p3 = 3 then
93162: LD_VAR 0 3
93166: PUSH
93167: LD_INT 3
93169: EQUAL
93170: IFFALSE 93180
// sEngine := true ;
93172: LD_ADDR_EXP 126
93176: PUSH
93177: LD_INT 1
93179: ST_TO_ADDR
// if p3 = 4 then
93180: LD_VAR 0 3
93184: PUSH
93185: LD_INT 4
93187: EQUAL
93188: IFFALSE 93198
// sSpec := true ;
93190: LD_ADDR_EXP 123
93194: PUSH
93195: LD_INT 1
93197: ST_TO_ADDR
// if p3 = 5 then
93198: LD_VAR 0 3
93202: PUSH
93203: LD_INT 5
93205: EQUAL
93206: IFFALSE 93216
// sLevel := true ;
93208: LD_ADDR_EXP 127
93212: PUSH
93213: LD_INT 1
93215: ST_TO_ADDR
// if p3 = 6 then
93216: LD_VAR 0 3
93220: PUSH
93221: LD_INT 6
93223: EQUAL
93224: IFFALSE 93234
// sArmoury := true ;
93226: LD_ADDR_EXP 128
93230: PUSH
93231: LD_INT 1
93233: ST_TO_ADDR
// if p3 = 7 then
93234: LD_VAR 0 3
93238: PUSH
93239: LD_INT 7
93241: EQUAL
93242: IFFALSE 93252
// sRadar := true ;
93244: LD_ADDR_EXP 129
93248: PUSH
93249: LD_INT 1
93251: ST_TO_ADDR
// if p3 = 8 then
93252: LD_VAR 0 3
93256: PUSH
93257: LD_INT 8
93259: EQUAL
93260: IFFALSE 93270
// sBunker := true ;
93262: LD_ADDR_EXP 130
93266: PUSH
93267: LD_INT 1
93269: ST_TO_ADDR
// if p3 = 9 then
93270: LD_VAR 0 3
93274: PUSH
93275: LD_INT 9
93277: EQUAL
93278: IFFALSE 93288
// sHack := true ;
93280: LD_ADDR_EXP 131
93284: PUSH
93285: LD_INT 1
93287: ST_TO_ADDR
// if p3 = 10 then
93288: LD_VAR 0 3
93292: PUSH
93293: LD_INT 10
93295: EQUAL
93296: IFFALSE 93306
// sFire := true ;
93298: LD_ADDR_EXP 132
93302: PUSH
93303: LD_INT 1
93305: ST_TO_ADDR
// if p3 = 11 then
93306: LD_VAR 0 3
93310: PUSH
93311: LD_INT 11
93313: EQUAL
93314: IFFALSE 93324
// sRefresh := true ;
93316: LD_ADDR_EXP 133
93320: PUSH
93321: LD_INT 1
93323: ST_TO_ADDR
// if p3 = 12 then
93324: LD_VAR 0 3
93328: PUSH
93329: LD_INT 12
93331: EQUAL
93332: IFFALSE 93342
// sExp := true ;
93334: LD_ADDR_EXP 134
93338: PUSH
93339: LD_INT 1
93341: ST_TO_ADDR
// if p3 = 13 then
93342: LD_VAR 0 3
93346: PUSH
93347: LD_INT 13
93349: EQUAL
93350: IFFALSE 93360
// sDepot := true ;
93352: LD_ADDR_EXP 135
93356: PUSH
93357: LD_INT 1
93359: ST_TO_ADDR
// if p3 = 14 then
93360: LD_VAR 0 3
93364: PUSH
93365: LD_INT 14
93367: EQUAL
93368: IFFALSE 93378
// sFlag := true ;
93370: LD_ADDR_EXP 136
93374: PUSH
93375: LD_INT 1
93377: ST_TO_ADDR
// if p3 = 15 then
93378: LD_VAR 0 3
93382: PUSH
93383: LD_INT 15
93385: EQUAL
93386: IFFALSE 93396
// sKamikadze := true ;
93388: LD_ADDR_EXP 144
93392: PUSH
93393: LD_INT 1
93395: ST_TO_ADDR
// if p3 = 16 then
93396: LD_VAR 0 3
93400: PUSH
93401: LD_INT 16
93403: EQUAL
93404: IFFALSE 93414
// sTroll := true ;
93406: LD_ADDR_EXP 145
93410: PUSH
93411: LD_INT 1
93413: ST_TO_ADDR
// if p3 = 17 then
93414: LD_VAR 0 3
93418: PUSH
93419: LD_INT 17
93421: EQUAL
93422: IFFALSE 93432
// sSlow := true ;
93424: LD_ADDR_EXP 146
93428: PUSH
93429: LD_INT 1
93431: ST_TO_ADDR
// if p3 = 18 then
93432: LD_VAR 0 3
93436: PUSH
93437: LD_INT 18
93439: EQUAL
93440: IFFALSE 93450
// sLack := true ;
93442: LD_ADDR_EXP 147
93446: PUSH
93447: LD_INT 1
93449: ST_TO_ADDR
// if p3 = 19 then
93450: LD_VAR 0 3
93454: PUSH
93455: LD_INT 19
93457: EQUAL
93458: IFFALSE 93468
// sTank := true ;
93460: LD_ADDR_EXP 149
93464: PUSH
93465: LD_INT 1
93467: ST_TO_ADDR
// if p3 = 20 then
93468: LD_VAR 0 3
93472: PUSH
93473: LD_INT 20
93475: EQUAL
93476: IFFALSE 93486
// sRemote := true ;
93478: LD_ADDR_EXP 150
93482: PUSH
93483: LD_INT 1
93485: ST_TO_ADDR
// if p3 = 21 then
93486: LD_VAR 0 3
93490: PUSH
93491: LD_INT 21
93493: EQUAL
93494: IFFALSE 93504
// sPowell := true ;
93496: LD_ADDR_EXP 151
93500: PUSH
93501: LD_INT 1
93503: ST_TO_ADDR
// if p3 = 22 then
93504: LD_VAR 0 3
93508: PUSH
93509: LD_INT 22
93511: EQUAL
93512: IFFALSE 93522
// sTeleport := true ;
93514: LD_ADDR_EXP 154
93518: PUSH
93519: LD_INT 1
93521: ST_TO_ADDR
// if p3 = 23 then
93522: LD_VAR 0 3
93526: PUSH
93527: LD_INT 23
93529: EQUAL
93530: IFFALSE 93540
// sOilTower := true ;
93532: LD_ADDR_EXP 156
93536: PUSH
93537: LD_INT 1
93539: ST_TO_ADDR
// if p3 = 24 then
93540: LD_VAR 0 3
93544: PUSH
93545: LD_INT 24
93547: EQUAL
93548: IFFALSE 93558
// sShovel := true ;
93550: LD_ADDR_EXP 157
93554: PUSH
93555: LD_INT 1
93557: ST_TO_ADDR
// if p3 = 25 then
93558: LD_VAR 0 3
93562: PUSH
93563: LD_INT 25
93565: EQUAL
93566: IFFALSE 93576
// sSheik := true ;
93568: LD_ADDR_EXP 158
93572: PUSH
93573: LD_INT 1
93575: ST_TO_ADDR
// if p3 = 26 then
93576: LD_VAR 0 3
93580: PUSH
93581: LD_INT 26
93583: EQUAL
93584: IFFALSE 93594
// sEarthquake := true ;
93586: LD_ADDR_EXP 160
93590: PUSH
93591: LD_INT 1
93593: ST_TO_ADDR
// if p3 = 27 then
93594: LD_VAR 0 3
93598: PUSH
93599: LD_INT 27
93601: EQUAL
93602: IFFALSE 93612
// sAI := true ;
93604: LD_ADDR_EXP 161
93608: PUSH
93609: LD_INT 1
93611: ST_TO_ADDR
// if p3 = 28 then
93612: LD_VAR 0 3
93616: PUSH
93617: LD_INT 28
93619: EQUAL
93620: IFFALSE 93630
// sCargo := true ;
93622: LD_ADDR_EXP 164
93626: PUSH
93627: LD_INT 1
93629: ST_TO_ADDR
// if p3 = 29 then
93630: LD_VAR 0 3
93634: PUSH
93635: LD_INT 29
93637: EQUAL
93638: IFFALSE 93648
// sDLaser := true ;
93640: LD_ADDR_EXP 165
93644: PUSH
93645: LD_INT 1
93647: ST_TO_ADDR
// if p3 = 30 then
93648: LD_VAR 0 3
93652: PUSH
93653: LD_INT 30
93655: EQUAL
93656: IFFALSE 93666
// sExchange := true ;
93658: LD_ADDR_EXP 166
93662: PUSH
93663: LD_INT 1
93665: ST_TO_ADDR
// if p3 = 31 then
93666: LD_VAR 0 3
93670: PUSH
93671: LD_INT 31
93673: EQUAL
93674: IFFALSE 93684
// sFac := true ;
93676: LD_ADDR_EXP 167
93680: PUSH
93681: LD_INT 1
93683: ST_TO_ADDR
// if p3 = 32 then
93684: LD_VAR 0 3
93688: PUSH
93689: LD_INT 32
93691: EQUAL
93692: IFFALSE 93702
// sPower := true ;
93694: LD_ADDR_EXP 168
93698: PUSH
93699: LD_INT 1
93701: ST_TO_ADDR
// if p3 = 33 then
93702: LD_VAR 0 3
93706: PUSH
93707: LD_INT 33
93709: EQUAL
93710: IFFALSE 93720
// sRandom := true ;
93712: LD_ADDR_EXP 169
93716: PUSH
93717: LD_INT 1
93719: ST_TO_ADDR
// if p3 = 34 then
93720: LD_VAR 0 3
93724: PUSH
93725: LD_INT 34
93727: EQUAL
93728: IFFALSE 93738
// sShield := true ;
93730: LD_ADDR_EXP 170
93734: PUSH
93735: LD_INT 1
93737: ST_TO_ADDR
// if p3 = 35 then
93738: LD_VAR 0 3
93742: PUSH
93743: LD_INT 35
93745: EQUAL
93746: IFFALSE 93756
// sTime := true ;
93748: LD_ADDR_EXP 171
93752: PUSH
93753: LD_INT 1
93755: ST_TO_ADDR
// if p3 = 36 then
93756: LD_VAR 0 3
93760: PUSH
93761: LD_INT 36
93763: EQUAL
93764: IFFALSE 93774
// sTools := true ;
93766: LD_ADDR_EXP 172
93770: PUSH
93771: LD_INT 1
93773: ST_TO_ADDR
// if p3 = 101 then
93774: LD_VAR 0 3
93778: PUSH
93779: LD_INT 101
93781: EQUAL
93782: IFFALSE 93792
// sSold := true ;
93784: LD_ADDR_EXP 137
93788: PUSH
93789: LD_INT 1
93791: ST_TO_ADDR
// if p3 = 102 then
93792: LD_VAR 0 3
93796: PUSH
93797: LD_INT 102
93799: EQUAL
93800: IFFALSE 93810
// sDiff := true ;
93802: LD_ADDR_EXP 138
93806: PUSH
93807: LD_INT 1
93809: ST_TO_ADDR
// if p3 = 103 then
93810: LD_VAR 0 3
93814: PUSH
93815: LD_INT 103
93817: EQUAL
93818: IFFALSE 93828
// sFog := true ;
93820: LD_ADDR_EXP 141
93824: PUSH
93825: LD_INT 1
93827: ST_TO_ADDR
// if p3 = 104 then
93828: LD_VAR 0 3
93832: PUSH
93833: LD_INT 104
93835: EQUAL
93836: IFFALSE 93846
// sReset := true ;
93838: LD_ADDR_EXP 142
93842: PUSH
93843: LD_INT 1
93845: ST_TO_ADDR
// if p3 = 105 then
93846: LD_VAR 0 3
93850: PUSH
93851: LD_INT 105
93853: EQUAL
93854: IFFALSE 93864
// sSun := true ;
93856: LD_ADDR_EXP 143
93860: PUSH
93861: LD_INT 1
93863: ST_TO_ADDR
// if p3 = 106 then
93864: LD_VAR 0 3
93868: PUSH
93869: LD_INT 106
93871: EQUAL
93872: IFFALSE 93882
// sTiger := true ;
93874: LD_ADDR_EXP 139
93878: PUSH
93879: LD_INT 1
93881: ST_TO_ADDR
// if p3 = 107 then
93882: LD_VAR 0 3
93886: PUSH
93887: LD_INT 107
93889: EQUAL
93890: IFFALSE 93900
// sBomb := true ;
93892: LD_ADDR_EXP 140
93896: PUSH
93897: LD_INT 1
93899: ST_TO_ADDR
// if p3 = 108 then
93900: LD_VAR 0 3
93904: PUSH
93905: LD_INT 108
93907: EQUAL
93908: IFFALSE 93918
// sWound := true ;
93910: LD_ADDR_EXP 148
93914: PUSH
93915: LD_INT 1
93917: ST_TO_ADDR
// if p3 = 109 then
93918: LD_VAR 0 3
93922: PUSH
93923: LD_INT 109
93925: EQUAL
93926: IFFALSE 93936
// sBetray := true ;
93928: LD_ADDR_EXP 152
93932: PUSH
93933: LD_INT 1
93935: ST_TO_ADDR
// if p3 = 110 then
93936: LD_VAR 0 3
93940: PUSH
93941: LD_INT 110
93943: EQUAL
93944: IFFALSE 93954
// sContamin := true ;
93946: LD_ADDR_EXP 153
93950: PUSH
93951: LD_INT 1
93953: ST_TO_ADDR
// if p3 = 111 then
93954: LD_VAR 0 3
93958: PUSH
93959: LD_INT 111
93961: EQUAL
93962: IFFALSE 93972
// sOil := true ;
93964: LD_ADDR_EXP 155
93968: PUSH
93969: LD_INT 1
93971: ST_TO_ADDR
// if p3 = 112 then
93972: LD_VAR 0 3
93976: PUSH
93977: LD_INT 112
93979: EQUAL
93980: IFFALSE 93990
// sStu := true ;
93982: LD_ADDR_EXP 159
93986: PUSH
93987: LD_INT 1
93989: ST_TO_ADDR
// if p3 = 113 then
93990: LD_VAR 0 3
93994: PUSH
93995: LD_INT 113
93997: EQUAL
93998: IFFALSE 94008
// sBazooka := true ;
94000: LD_ADDR_EXP 162
94004: PUSH
94005: LD_INT 1
94007: ST_TO_ADDR
// if p3 = 114 then
94008: LD_VAR 0 3
94012: PUSH
94013: LD_INT 114
94015: EQUAL
94016: IFFALSE 94026
// sMortar := true ;
94018: LD_ADDR_EXP 163
94022: PUSH
94023: LD_INT 1
94025: ST_TO_ADDR
// if p3 = 115 then
94026: LD_VAR 0 3
94030: PUSH
94031: LD_INT 115
94033: EQUAL
94034: IFFALSE 94044
// sRanger := true ;
94036: LD_ADDR_EXP 173
94040: PUSH
94041: LD_INT 1
94043: ST_TO_ADDR
// if p3 = 116 then
94044: LD_VAR 0 3
94048: PUSH
94049: LD_INT 116
94051: EQUAL
94052: IFFALSE 94062
// sComputer := true ;
94054: LD_ADDR_EXP 174
94058: PUSH
94059: LD_INT 1
94061: ST_TO_ADDR
// if p3 = 117 then
94062: LD_VAR 0 3
94066: PUSH
94067: LD_INT 117
94069: EQUAL
94070: IFFALSE 94080
// s30 := true ;
94072: LD_ADDR_EXP 175
94076: PUSH
94077: LD_INT 1
94079: ST_TO_ADDR
// if p3 = 118 then
94080: LD_VAR 0 3
94084: PUSH
94085: LD_INT 118
94087: EQUAL
94088: IFFALSE 94098
// s60 := true ;
94090: LD_ADDR_EXP 176
94094: PUSH
94095: LD_INT 1
94097: ST_TO_ADDR
// end ; if p2 = 101 then
94098: LD_VAR 0 2
94102: PUSH
94103: LD_INT 101
94105: EQUAL
94106: IFFALSE 94234
// begin case p3 of 1 :
94108: LD_VAR 0 3
94112: PUSH
94113: LD_INT 1
94115: DOUBLE
94116: EQUAL
94117: IFTRUE 94121
94119: GO 94128
94121: POP
// hHackUnlimitedResources ; 2 :
94122: CALL 106332 0 0
94126: GO 94234
94128: LD_INT 2
94130: DOUBLE
94131: EQUAL
94132: IFTRUE 94136
94134: GO 94143
94136: POP
// hHackSetLevel10 ; 3 :
94137: CALL 106465 0 0
94141: GO 94234
94143: LD_INT 3
94145: DOUBLE
94146: EQUAL
94147: IFTRUE 94151
94149: GO 94158
94151: POP
// hHackSetLevel10YourUnits ; 4 :
94152: CALL 106550 0 0
94156: GO 94234
94158: LD_INT 4
94160: DOUBLE
94161: EQUAL
94162: IFTRUE 94166
94164: GO 94173
94166: POP
// hHackInvincible ; 5 :
94167: CALL 106998 0 0
94171: GO 94234
94173: LD_INT 5
94175: DOUBLE
94176: EQUAL
94177: IFTRUE 94181
94179: GO 94188
94181: POP
// hHackInvisible ; 6 :
94182: CALL 107109 0 0
94186: GO 94234
94188: LD_INT 6
94190: DOUBLE
94191: EQUAL
94192: IFTRUE 94196
94194: GO 94203
94196: POP
// hHackChangeYourSide ; 7 :
94197: CALL 107166 0 0
94201: GO 94234
94203: LD_INT 7
94205: DOUBLE
94206: EQUAL
94207: IFTRUE 94211
94209: GO 94218
94211: POP
// hHackChangeUnitSide ; 8 :
94212: CALL 107208 0 0
94216: GO 94234
94218: LD_INT 8
94220: DOUBLE
94221: EQUAL
94222: IFTRUE 94226
94224: GO 94233
94226: POP
// hHackFog ; end ;
94227: CALL 107309 0 0
94231: GO 94234
94233: POP
// end ; end ;
94234: LD_VAR 0 7
94238: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
94239: GO 94241
94241: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
94242: LD_STRING initStreamRollete();
94244: PPUSH
94245: CALL_OW 559
// InitStreamMode ;
94249: CALL 94261 0 0
// DefineStreamItems ( false ) ;
94253: LD_INT 0
94255: PPUSH
94256: CALL 94725 0 1
// end ;
94260: END
// function InitStreamMode ; begin
94261: LD_INT 0
94263: PPUSH
// streamModeActive := false ;
94264: LD_ADDR_EXP 120
94268: PUSH
94269: LD_INT 0
94271: ST_TO_ADDR
// normalCounter := 36 ;
94272: LD_ADDR_EXP 121
94276: PUSH
94277: LD_INT 36
94279: ST_TO_ADDR
// hardcoreCounter := 18 ;
94280: LD_ADDR_EXP 122
94284: PUSH
94285: LD_INT 18
94287: ST_TO_ADDR
// sRocket := false ;
94288: LD_ADDR_EXP 125
94292: PUSH
94293: LD_INT 0
94295: ST_TO_ADDR
// sSpeed := false ;
94296: LD_ADDR_EXP 124
94300: PUSH
94301: LD_INT 0
94303: ST_TO_ADDR
// sEngine := false ;
94304: LD_ADDR_EXP 126
94308: PUSH
94309: LD_INT 0
94311: ST_TO_ADDR
// sSpec := false ;
94312: LD_ADDR_EXP 123
94316: PUSH
94317: LD_INT 0
94319: ST_TO_ADDR
// sLevel := false ;
94320: LD_ADDR_EXP 127
94324: PUSH
94325: LD_INT 0
94327: ST_TO_ADDR
// sArmoury := false ;
94328: LD_ADDR_EXP 128
94332: PUSH
94333: LD_INT 0
94335: ST_TO_ADDR
// sRadar := false ;
94336: LD_ADDR_EXP 129
94340: PUSH
94341: LD_INT 0
94343: ST_TO_ADDR
// sBunker := false ;
94344: LD_ADDR_EXP 130
94348: PUSH
94349: LD_INT 0
94351: ST_TO_ADDR
// sHack := false ;
94352: LD_ADDR_EXP 131
94356: PUSH
94357: LD_INT 0
94359: ST_TO_ADDR
// sFire := false ;
94360: LD_ADDR_EXP 132
94364: PUSH
94365: LD_INT 0
94367: ST_TO_ADDR
// sRefresh := false ;
94368: LD_ADDR_EXP 133
94372: PUSH
94373: LD_INT 0
94375: ST_TO_ADDR
// sExp := false ;
94376: LD_ADDR_EXP 134
94380: PUSH
94381: LD_INT 0
94383: ST_TO_ADDR
// sDepot := false ;
94384: LD_ADDR_EXP 135
94388: PUSH
94389: LD_INT 0
94391: ST_TO_ADDR
// sFlag := false ;
94392: LD_ADDR_EXP 136
94396: PUSH
94397: LD_INT 0
94399: ST_TO_ADDR
// sKamikadze := false ;
94400: LD_ADDR_EXP 144
94404: PUSH
94405: LD_INT 0
94407: ST_TO_ADDR
// sTroll := false ;
94408: LD_ADDR_EXP 145
94412: PUSH
94413: LD_INT 0
94415: ST_TO_ADDR
// sSlow := false ;
94416: LD_ADDR_EXP 146
94420: PUSH
94421: LD_INT 0
94423: ST_TO_ADDR
// sLack := false ;
94424: LD_ADDR_EXP 147
94428: PUSH
94429: LD_INT 0
94431: ST_TO_ADDR
// sTank := false ;
94432: LD_ADDR_EXP 149
94436: PUSH
94437: LD_INT 0
94439: ST_TO_ADDR
// sRemote := false ;
94440: LD_ADDR_EXP 150
94444: PUSH
94445: LD_INT 0
94447: ST_TO_ADDR
// sPowell := false ;
94448: LD_ADDR_EXP 151
94452: PUSH
94453: LD_INT 0
94455: ST_TO_ADDR
// sTeleport := false ;
94456: LD_ADDR_EXP 154
94460: PUSH
94461: LD_INT 0
94463: ST_TO_ADDR
// sOilTower := false ;
94464: LD_ADDR_EXP 156
94468: PUSH
94469: LD_INT 0
94471: ST_TO_ADDR
// sShovel := false ;
94472: LD_ADDR_EXP 157
94476: PUSH
94477: LD_INT 0
94479: ST_TO_ADDR
// sSheik := false ;
94480: LD_ADDR_EXP 158
94484: PUSH
94485: LD_INT 0
94487: ST_TO_ADDR
// sEarthquake := false ;
94488: LD_ADDR_EXP 160
94492: PUSH
94493: LD_INT 0
94495: ST_TO_ADDR
// sAI := false ;
94496: LD_ADDR_EXP 161
94500: PUSH
94501: LD_INT 0
94503: ST_TO_ADDR
// sCargo := false ;
94504: LD_ADDR_EXP 164
94508: PUSH
94509: LD_INT 0
94511: ST_TO_ADDR
// sDLaser := false ;
94512: LD_ADDR_EXP 165
94516: PUSH
94517: LD_INT 0
94519: ST_TO_ADDR
// sExchange := false ;
94520: LD_ADDR_EXP 166
94524: PUSH
94525: LD_INT 0
94527: ST_TO_ADDR
// sFac := false ;
94528: LD_ADDR_EXP 167
94532: PUSH
94533: LD_INT 0
94535: ST_TO_ADDR
// sPower := false ;
94536: LD_ADDR_EXP 168
94540: PUSH
94541: LD_INT 0
94543: ST_TO_ADDR
// sRandom := false ;
94544: LD_ADDR_EXP 169
94548: PUSH
94549: LD_INT 0
94551: ST_TO_ADDR
// sShield := false ;
94552: LD_ADDR_EXP 170
94556: PUSH
94557: LD_INT 0
94559: ST_TO_ADDR
// sTime := false ;
94560: LD_ADDR_EXP 171
94564: PUSH
94565: LD_INT 0
94567: ST_TO_ADDR
// sTools := false ;
94568: LD_ADDR_EXP 172
94572: PUSH
94573: LD_INT 0
94575: ST_TO_ADDR
// sSold := false ;
94576: LD_ADDR_EXP 137
94580: PUSH
94581: LD_INT 0
94583: ST_TO_ADDR
// sDiff := false ;
94584: LD_ADDR_EXP 138
94588: PUSH
94589: LD_INT 0
94591: ST_TO_ADDR
// sFog := false ;
94592: LD_ADDR_EXP 141
94596: PUSH
94597: LD_INT 0
94599: ST_TO_ADDR
// sReset := false ;
94600: LD_ADDR_EXP 142
94604: PUSH
94605: LD_INT 0
94607: ST_TO_ADDR
// sSun := false ;
94608: LD_ADDR_EXP 143
94612: PUSH
94613: LD_INT 0
94615: ST_TO_ADDR
// sTiger := false ;
94616: LD_ADDR_EXP 139
94620: PUSH
94621: LD_INT 0
94623: ST_TO_ADDR
// sBomb := false ;
94624: LD_ADDR_EXP 140
94628: PUSH
94629: LD_INT 0
94631: ST_TO_ADDR
// sWound := false ;
94632: LD_ADDR_EXP 148
94636: PUSH
94637: LD_INT 0
94639: ST_TO_ADDR
// sBetray := false ;
94640: LD_ADDR_EXP 152
94644: PUSH
94645: LD_INT 0
94647: ST_TO_ADDR
// sContamin := false ;
94648: LD_ADDR_EXP 153
94652: PUSH
94653: LD_INT 0
94655: ST_TO_ADDR
// sOil := false ;
94656: LD_ADDR_EXP 155
94660: PUSH
94661: LD_INT 0
94663: ST_TO_ADDR
// sStu := false ;
94664: LD_ADDR_EXP 159
94668: PUSH
94669: LD_INT 0
94671: ST_TO_ADDR
// sBazooka := false ;
94672: LD_ADDR_EXP 162
94676: PUSH
94677: LD_INT 0
94679: ST_TO_ADDR
// sMortar := false ;
94680: LD_ADDR_EXP 163
94684: PUSH
94685: LD_INT 0
94687: ST_TO_ADDR
// sRanger := false ;
94688: LD_ADDR_EXP 173
94692: PUSH
94693: LD_INT 0
94695: ST_TO_ADDR
// sComputer := false ;
94696: LD_ADDR_EXP 174
94700: PUSH
94701: LD_INT 0
94703: ST_TO_ADDR
// s30 := false ;
94704: LD_ADDR_EXP 175
94708: PUSH
94709: LD_INT 0
94711: ST_TO_ADDR
// s60 := false ;
94712: LD_ADDR_EXP 176
94716: PUSH
94717: LD_INT 0
94719: ST_TO_ADDR
// end ;
94720: LD_VAR 0 1
94724: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
94725: LD_INT 0
94727: PPUSH
94728: PPUSH
94729: PPUSH
94730: PPUSH
94731: PPUSH
94732: PPUSH
94733: PPUSH
// result := [ ] ;
94734: LD_ADDR_VAR 0 2
94738: PUSH
94739: EMPTY
94740: ST_TO_ADDR
// if campaign_id = 1 then
94741: LD_OWVAR 69
94745: PUSH
94746: LD_INT 1
94748: EQUAL
94749: IFFALSE 97915
// begin case mission_number of 1 :
94751: LD_OWVAR 70
94755: PUSH
94756: LD_INT 1
94758: DOUBLE
94759: EQUAL
94760: IFTRUE 94764
94762: GO 94840
94764: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
94765: LD_ADDR_VAR 0 2
94769: PUSH
94770: LD_INT 2
94772: PUSH
94773: LD_INT 4
94775: PUSH
94776: LD_INT 11
94778: PUSH
94779: LD_INT 12
94781: PUSH
94782: LD_INT 15
94784: PUSH
94785: LD_INT 16
94787: PUSH
94788: LD_INT 22
94790: PUSH
94791: LD_INT 23
94793: PUSH
94794: LD_INT 26
94796: PUSH
94797: EMPTY
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: PUSH
94808: LD_INT 101
94810: PUSH
94811: LD_INT 102
94813: PUSH
94814: LD_INT 106
94816: PUSH
94817: LD_INT 116
94819: PUSH
94820: LD_INT 117
94822: PUSH
94823: LD_INT 118
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: ST_TO_ADDR
94838: GO 97913
94840: LD_INT 2
94842: DOUBLE
94843: EQUAL
94844: IFTRUE 94848
94846: GO 94932
94848: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
94849: LD_ADDR_VAR 0 2
94853: PUSH
94854: LD_INT 2
94856: PUSH
94857: LD_INT 4
94859: PUSH
94860: LD_INT 11
94862: PUSH
94863: LD_INT 12
94865: PUSH
94866: LD_INT 15
94868: PUSH
94869: LD_INT 16
94871: PUSH
94872: LD_INT 22
94874: PUSH
94875: LD_INT 23
94877: PUSH
94878: LD_INT 26
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: PUSH
94892: LD_INT 101
94894: PUSH
94895: LD_INT 102
94897: PUSH
94898: LD_INT 105
94900: PUSH
94901: LD_INT 106
94903: PUSH
94904: LD_INT 108
94906: PUSH
94907: LD_INT 116
94909: PUSH
94910: LD_INT 117
94912: PUSH
94913: LD_INT 118
94915: PUSH
94916: EMPTY
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: PUSH
94926: EMPTY
94927: LIST
94928: LIST
94929: ST_TO_ADDR
94930: GO 97913
94932: LD_INT 3
94934: DOUBLE
94935: EQUAL
94936: IFTRUE 94940
94938: GO 95028
94940: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94941: LD_ADDR_VAR 0 2
94945: PUSH
94946: LD_INT 2
94948: PUSH
94949: LD_INT 4
94951: PUSH
94952: LD_INT 5
94954: PUSH
94955: LD_INT 11
94957: PUSH
94958: LD_INT 12
94960: PUSH
94961: LD_INT 15
94963: PUSH
94964: LD_INT 16
94966: PUSH
94967: LD_INT 22
94969: PUSH
94970: LD_INT 26
94972: PUSH
94973: LD_INT 36
94975: PUSH
94976: EMPTY
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 101
94990: PUSH
94991: LD_INT 102
94993: PUSH
94994: LD_INT 105
94996: PUSH
94997: LD_INT 106
94999: PUSH
95000: LD_INT 108
95002: PUSH
95003: LD_INT 116
95005: PUSH
95006: LD_INT 117
95008: PUSH
95009: LD_INT 118
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: ST_TO_ADDR
95026: GO 97913
95028: LD_INT 4
95030: DOUBLE
95031: EQUAL
95032: IFTRUE 95036
95034: GO 95132
95036: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95037: LD_ADDR_VAR 0 2
95041: PUSH
95042: LD_INT 2
95044: PUSH
95045: LD_INT 4
95047: PUSH
95048: LD_INT 5
95050: PUSH
95051: LD_INT 8
95053: PUSH
95054: LD_INT 11
95056: PUSH
95057: LD_INT 12
95059: PUSH
95060: LD_INT 15
95062: PUSH
95063: LD_INT 16
95065: PUSH
95066: LD_INT 22
95068: PUSH
95069: LD_INT 23
95071: PUSH
95072: LD_INT 26
95074: PUSH
95075: LD_INT 36
95077: PUSH
95078: EMPTY
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 101
95094: PUSH
95095: LD_INT 102
95097: PUSH
95098: LD_INT 105
95100: PUSH
95101: LD_INT 106
95103: PUSH
95104: LD_INT 108
95106: PUSH
95107: LD_INT 116
95109: PUSH
95110: LD_INT 117
95112: PUSH
95113: LD_INT 118
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: PUSH
95126: EMPTY
95127: LIST
95128: LIST
95129: ST_TO_ADDR
95130: GO 97913
95132: LD_INT 5
95134: DOUBLE
95135: EQUAL
95136: IFTRUE 95140
95138: GO 95252
95140: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95141: LD_ADDR_VAR 0 2
95145: PUSH
95146: LD_INT 2
95148: PUSH
95149: LD_INT 4
95151: PUSH
95152: LD_INT 5
95154: PUSH
95155: LD_INT 6
95157: PUSH
95158: LD_INT 8
95160: PUSH
95161: LD_INT 11
95163: PUSH
95164: LD_INT 12
95166: PUSH
95167: LD_INT 15
95169: PUSH
95170: LD_INT 16
95172: PUSH
95173: LD_INT 22
95175: PUSH
95176: LD_INT 23
95178: PUSH
95179: LD_INT 25
95181: PUSH
95182: LD_INT 26
95184: PUSH
95185: LD_INT 36
95187: PUSH
95188: EMPTY
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: PUSH
95204: LD_INT 101
95206: PUSH
95207: LD_INT 102
95209: PUSH
95210: LD_INT 105
95212: PUSH
95213: LD_INT 106
95215: PUSH
95216: LD_INT 108
95218: PUSH
95219: LD_INT 109
95221: PUSH
95222: LD_INT 112
95224: PUSH
95225: LD_INT 116
95227: PUSH
95228: LD_INT 117
95230: PUSH
95231: LD_INT 118
95233: PUSH
95234: EMPTY
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: PUSH
95246: EMPTY
95247: LIST
95248: LIST
95249: ST_TO_ADDR
95250: GO 97913
95252: LD_INT 6
95254: DOUBLE
95255: EQUAL
95256: IFTRUE 95260
95258: GO 95392
95260: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
95261: LD_ADDR_VAR 0 2
95265: PUSH
95266: LD_INT 2
95268: PUSH
95269: LD_INT 4
95271: PUSH
95272: LD_INT 5
95274: PUSH
95275: LD_INT 6
95277: PUSH
95278: LD_INT 8
95280: PUSH
95281: LD_INT 11
95283: PUSH
95284: LD_INT 12
95286: PUSH
95287: LD_INT 15
95289: PUSH
95290: LD_INT 16
95292: PUSH
95293: LD_INT 20
95295: PUSH
95296: LD_INT 21
95298: PUSH
95299: LD_INT 22
95301: PUSH
95302: LD_INT 23
95304: PUSH
95305: LD_INT 25
95307: PUSH
95308: LD_INT 26
95310: PUSH
95311: LD_INT 30
95313: PUSH
95314: LD_INT 31
95316: PUSH
95317: LD_INT 32
95319: PUSH
95320: LD_INT 36
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: PUSH
95344: LD_INT 101
95346: PUSH
95347: LD_INT 102
95349: PUSH
95350: LD_INT 105
95352: PUSH
95353: LD_INT 106
95355: PUSH
95356: LD_INT 108
95358: PUSH
95359: LD_INT 109
95361: PUSH
95362: LD_INT 112
95364: PUSH
95365: LD_INT 116
95367: PUSH
95368: LD_INT 117
95370: PUSH
95371: LD_INT 118
95373: PUSH
95374: EMPTY
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: PUSH
95386: EMPTY
95387: LIST
95388: LIST
95389: ST_TO_ADDR
95390: GO 97913
95392: LD_INT 7
95394: DOUBLE
95395: EQUAL
95396: IFTRUE 95400
95398: GO 95512
95400: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95401: LD_ADDR_VAR 0 2
95405: PUSH
95406: LD_INT 2
95408: PUSH
95409: LD_INT 4
95411: PUSH
95412: LD_INT 5
95414: PUSH
95415: LD_INT 7
95417: PUSH
95418: LD_INT 11
95420: PUSH
95421: LD_INT 12
95423: PUSH
95424: LD_INT 15
95426: PUSH
95427: LD_INT 16
95429: PUSH
95430: LD_INT 20
95432: PUSH
95433: LD_INT 21
95435: PUSH
95436: LD_INT 22
95438: PUSH
95439: LD_INT 23
95441: PUSH
95442: LD_INT 25
95444: PUSH
95445: LD_INT 26
95447: PUSH
95448: EMPTY
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: PUSH
95464: LD_INT 101
95466: PUSH
95467: LD_INT 102
95469: PUSH
95470: LD_INT 103
95472: PUSH
95473: LD_INT 105
95475: PUSH
95476: LD_INT 106
95478: PUSH
95479: LD_INT 108
95481: PUSH
95482: LD_INT 112
95484: PUSH
95485: LD_INT 116
95487: PUSH
95488: LD_INT 117
95490: PUSH
95491: LD_INT 118
95493: PUSH
95494: EMPTY
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: PUSH
95506: EMPTY
95507: LIST
95508: LIST
95509: ST_TO_ADDR
95510: GO 97913
95512: LD_INT 8
95514: DOUBLE
95515: EQUAL
95516: IFTRUE 95520
95518: GO 95660
95520: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95521: LD_ADDR_VAR 0 2
95525: PUSH
95526: LD_INT 2
95528: PUSH
95529: LD_INT 4
95531: PUSH
95532: LD_INT 5
95534: PUSH
95535: LD_INT 6
95537: PUSH
95538: LD_INT 7
95540: PUSH
95541: LD_INT 8
95543: PUSH
95544: LD_INT 11
95546: PUSH
95547: LD_INT 12
95549: PUSH
95550: LD_INT 15
95552: PUSH
95553: LD_INT 16
95555: PUSH
95556: LD_INT 20
95558: PUSH
95559: LD_INT 21
95561: PUSH
95562: LD_INT 22
95564: PUSH
95565: LD_INT 23
95567: PUSH
95568: LD_INT 25
95570: PUSH
95571: LD_INT 26
95573: PUSH
95574: LD_INT 30
95576: PUSH
95577: LD_INT 31
95579: PUSH
95580: LD_INT 32
95582: PUSH
95583: LD_INT 36
95585: PUSH
95586: EMPTY
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: PUSH
95608: LD_INT 101
95610: PUSH
95611: LD_INT 102
95613: PUSH
95614: LD_INT 103
95616: PUSH
95617: LD_INT 105
95619: PUSH
95620: LD_INT 106
95622: PUSH
95623: LD_INT 108
95625: PUSH
95626: LD_INT 109
95628: PUSH
95629: LD_INT 112
95631: PUSH
95632: LD_INT 116
95634: PUSH
95635: LD_INT 117
95637: PUSH
95638: LD_INT 118
95640: PUSH
95641: EMPTY
95642: LIST
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: ST_TO_ADDR
95658: GO 97913
95660: LD_INT 9
95662: DOUBLE
95663: EQUAL
95664: IFTRUE 95668
95666: GO 95816
95668: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
95669: LD_ADDR_VAR 0 2
95673: PUSH
95674: LD_INT 2
95676: PUSH
95677: LD_INT 4
95679: PUSH
95680: LD_INT 5
95682: PUSH
95683: LD_INT 6
95685: PUSH
95686: LD_INT 7
95688: PUSH
95689: LD_INT 8
95691: PUSH
95692: LD_INT 11
95694: PUSH
95695: LD_INT 12
95697: PUSH
95698: LD_INT 15
95700: PUSH
95701: LD_INT 16
95703: PUSH
95704: LD_INT 20
95706: PUSH
95707: LD_INT 21
95709: PUSH
95710: LD_INT 22
95712: PUSH
95713: LD_INT 23
95715: PUSH
95716: LD_INT 25
95718: PUSH
95719: LD_INT 26
95721: PUSH
95722: LD_INT 28
95724: PUSH
95725: LD_INT 30
95727: PUSH
95728: LD_INT 31
95730: PUSH
95731: LD_INT 32
95733: PUSH
95734: LD_INT 36
95736: PUSH
95737: EMPTY
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: PUSH
95760: LD_INT 101
95762: PUSH
95763: LD_INT 102
95765: PUSH
95766: LD_INT 103
95768: PUSH
95769: LD_INT 105
95771: PUSH
95772: LD_INT 106
95774: PUSH
95775: LD_INT 108
95777: PUSH
95778: LD_INT 109
95780: PUSH
95781: LD_INT 112
95783: PUSH
95784: LD_INT 114
95786: PUSH
95787: LD_INT 116
95789: PUSH
95790: LD_INT 117
95792: PUSH
95793: LD_INT 118
95795: PUSH
95796: EMPTY
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: PUSH
95810: EMPTY
95811: LIST
95812: LIST
95813: ST_TO_ADDR
95814: GO 97913
95816: LD_INT 10
95818: DOUBLE
95819: EQUAL
95820: IFTRUE 95824
95822: GO 96020
95824: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
95825: LD_ADDR_VAR 0 2
95829: PUSH
95830: LD_INT 2
95832: PUSH
95833: LD_INT 4
95835: PUSH
95836: LD_INT 5
95838: PUSH
95839: LD_INT 6
95841: PUSH
95842: LD_INT 7
95844: PUSH
95845: LD_INT 8
95847: PUSH
95848: LD_INT 9
95850: PUSH
95851: LD_INT 10
95853: PUSH
95854: LD_INT 11
95856: PUSH
95857: LD_INT 12
95859: PUSH
95860: LD_INT 13
95862: PUSH
95863: LD_INT 14
95865: PUSH
95866: LD_INT 15
95868: PUSH
95869: LD_INT 16
95871: PUSH
95872: LD_INT 17
95874: PUSH
95875: LD_INT 18
95877: PUSH
95878: LD_INT 19
95880: PUSH
95881: LD_INT 20
95883: PUSH
95884: LD_INT 21
95886: PUSH
95887: LD_INT 22
95889: PUSH
95890: LD_INT 23
95892: PUSH
95893: LD_INT 24
95895: PUSH
95896: LD_INT 25
95898: PUSH
95899: LD_INT 26
95901: PUSH
95902: LD_INT 28
95904: PUSH
95905: LD_INT 30
95907: PUSH
95908: LD_INT 31
95910: PUSH
95911: LD_INT 32
95913: PUSH
95914: LD_INT 36
95916: PUSH
95917: EMPTY
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: PUSH
95948: LD_INT 101
95950: PUSH
95951: LD_INT 102
95953: PUSH
95954: LD_INT 103
95956: PUSH
95957: LD_INT 104
95959: PUSH
95960: LD_INT 105
95962: PUSH
95963: LD_INT 106
95965: PUSH
95966: LD_INT 107
95968: PUSH
95969: LD_INT 108
95971: PUSH
95972: LD_INT 109
95974: PUSH
95975: LD_INT 110
95977: PUSH
95978: LD_INT 111
95980: PUSH
95981: LD_INT 112
95983: PUSH
95984: LD_INT 114
95986: PUSH
95987: LD_INT 116
95989: PUSH
95990: LD_INT 117
95992: PUSH
95993: LD_INT 118
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: LIST
96000: LIST
96001: LIST
96002: LIST
96003: LIST
96004: LIST
96005: LIST
96006: LIST
96007: LIST
96008: LIST
96009: LIST
96010: LIST
96011: LIST
96012: LIST
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: ST_TO_ADDR
96018: GO 97913
96020: LD_INT 11
96022: DOUBLE
96023: EQUAL
96024: IFTRUE 96028
96026: GO 96232
96028: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96029: LD_ADDR_VAR 0 2
96033: PUSH
96034: LD_INT 2
96036: PUSH
96037: LD_INT 3
96039: PUSH
96040: LD_INT 4
96042: PUSH
96043: LD_INT 5
96045: PUSH
96046: LD_INT 6
96048: PUSH
96049: LD_INT 7
96051: PUSH
96052: LD_INT 8
96054: PUSH
96055: LD_INT 9
96057: PUSH
96058: LD_INT 10
96060: PUSH
96061: LD_INT 11
96063: PUSH
96064: LD_INT 12
96066: PUSH
96067: LD_INT 13
96069: PUSH
96070: LD_INT 14
96072: PUSH
96073: LD_INT 15
96075: PUSH
96076: LD_INT 16
96078: PUSH
96079: LD_INT 17
96081: PUSH
96082: LD_INT 18
96084: PUSH
96085: LD_INT 19
96087: PUSH
96088: LD_INT 20
96090: PUSH
96091: LD_INT 21
96093: PUSH
96094: LD_INT 22
96096: PUSH
96097: LD_INT 23
96099: PUSH
96100: LD_INT 24
96102: PUSH
96103: LD_INT 25
96105: PUSH
96106: LD_INT 26
96108: PUSH
96109: LD_INT 28
96111: PUSH
96112: LD_INT 30
96114: PUSH
96115: LD_INT 31
96117: PUSH
96118: LD_INT 32
96120: PUSH
96121: LD_INT 34
96123: PUSH
96124: LD_INT 36
96126: PUSH
96127: EMPTY
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 101
96162: PUSH
96163: LD_INT 102
96165: PUSH
96166: LD_INT 103
96168: PUSH
96169: LD_INT 104
96171: PUSH
96172: LD_INT 105
96174: PUSH
96175: LD_INT 106
96177: PUSH
96178: LD_INT 107
96180: PUSH
96181: LD_INT 108
96183: PUSH
96184: LD_INT 109
96186: PUSH
96187: LD_INT 110
96189: PUSH
96190: LD_INT 111
96192: PUSH
96193: LD_INT 112
96195: PUSH
96196: LD_INT 114
96198: PUSH
96199: LD_INT 116
96201: PUSH
96202: LD_INT 117
96204: PUSH
96205: LD_INT 118
96207: PUSH
96208: EMPTY
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: LIST
96216: LIST
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: LIST
96223: LIST
96224: LIST
96225: PUSH
96226: EMPTY
96227: LIST
96228: LIST
96229: ST_TO_ADDR
96230: GO 97913
96232: LD_INT 12
96234: DOUBLE
96235: EQUAL
96236: IFTRUE 96240
96238: GO 96460
96240: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
96241: LD_ADDR_VAR 0 2
96245: PUSH
96246: LD_INT 1
96248: PUSH
96249: LD_INT 2
96251: PUSH
96252: LD_INT 3
96254: PUSH
96255: LD_INT 4
96257: PUSH
96258: LD_INT 5
96260: PUSH
96261: LD_INT 6
96263: PUSH
96264: LD_INT 7
96266: PUSH
96267: LD_INT 8
96269: PUSH
96270: LD_INT 9
96272: PUSH
96273: LD_INT 10
96275: PUSH
96276: LD_INT 11
96278: PUSH
96279: LD_INT 12
96281: PUSH
96282: LD_INT 13
96284: PUSH
96285: LD_INT 14
96287: PUSH
96288: LD_INT 15
96290: PUSH
96291: LD_INT 16
96293: PUSH
96294: LD_INT 17
96296: PUSH
96297: LD_INT 18
96299: PUSH
96300: LD_INT 19
96302: PUSH
96303: LD_INT 20
96305: PUSH
96306: LD_INT 21
96308: PUSH
96309: LD_INT 22
96311: PUSH
96312: LD_INT 23
96314: PUSH
96315: LD_INT 24
96317: PUSH
96318: LD_INT 25
96320: PUSH
96321: LD_INT 26
96323: PUSH
96324: LD_INT 27
96326: PUSH
96327: LD_INT 28
96329: PUSH
96330: LD_INT 30
96332: PUSH
96333: LD_INT 31
96335: PUSH
96336: LD_INT 32
96338: PUSH
96339: LD_INT 33
96341: PUSH
96342: LD_INT 34
96344: PUSH
96345: LD_INT 36
96347: PUSH
96348: EMPTY
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: LIST
96380: LIST
96381: LIST
96382: LIST
96383: PUSH
96384: LD_INT 101
96386: PUSH
96387: LD_INT 102
96389: PUSH
96390: LD_INT 103
96392: PUSH
96393: LD_INT 104
96395: PUSH
96396: LD_INT 105
96398: PUSH
96399: LD_INT 106
96401: PUSH
96402: LD_INT 107
96404: PUSH
96405: LD_INT 108
96407: PUSH
96408: LD_INT 109
96410: PUSH
96411: LD_INT 110
96413: PUSH
96414: LD_INT 111
96416: PUSH
96417: LD_INT 112
96419: PUSH
96420: LD_INT 113
96422: PUSH
96423: LD_INT 114
96425: PUSH
96426: LD_INT 116
96428: PUSH
96429: LD_INT 117
96431: PUSH
96432: LD_INT 118
96434: PUSH
96435: EMPTY
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: ST_TO_ADDR
96458: GO 97913
96460: LD_INT 13
96462: DOUBLE
96463: EQUAL
96464: IFTRUE 96468
96466: GO 96676
96468: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96469: LD_ADDR_VAR 0 2
96473: PUSH
96474: LD_INT 1
96476: PUSH
96477: LD_INT 2
96479: PUSH
96480: LD_INT 3
96482: PUSH
96483: LD_INT 4
96485: PUSH
96486: LD_INT 5
96488: PUSH
96489: LD_INT 8
96491: PUSH
96492: LD_INT 9
96494: PUSH
96495: LD_INT 10
96497: PUSH
96498: LD_INT 11
96500: PUSH
96501: LD_INT 12
96503: PUSH
96504: LD_INT 14
96506: PUSH
96507: LD_INT 15
96509: PUSH
96510: LD_INT 16
96512: PUSH
96513: LD_INT 17
96515: PUSH
96516: LD_INT 18
96518: PUSH
96519: LD_INT 19
96521: PUSH
96522: LD_INT 20
96524: PUSH
96525: LD_INT 21
96527: PUSH
96528: LD_INT 22
96530: PUSH
96531: LD_INT 23
96533: PUSH
96534: LD_INT 24
96536: PUSH
96537: LD_INT 25
96539: PUSH
96540: LD_INT 26
96542: PUSH
96543: LD_INT 27
96545: PUSH
96546: LD_INT 28
96548: PUSH
96549: LD_INT 30
96551: PUSH
96552: LD_INT 31
96554: PUSH
96555: LD_INT 32
96557: PUSH
96558: LD_INT 33
96560: PUSH
96561: LD_INT 34
96563: PUSH
96564: LD_INT 36
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: PUSH
96600: LD_INT 101
96602: PUSH
96603: LD_INT 102
96605: PUSH
96606: LD_INT 103
96608: PUSH
96609: LD_INT 104
96611: PUSH
96612: LD_INT 105
96614: PUSH
96615: LD_INT 106
96617: PUSH
96618: LD_INT 107
96620: PUSH
96621: LD_INT 108
96623: PUSH
96624: LD_INT 109
96626: PUSH
96627: LD_INT 110
96629: PUSH
96630: LD_INT 111
96632: PUSH
96633: LD_INT 112
96635: PUSH
96636: LD_INT 113
96638: PUSH
96639: LD_INT 114
96641: PUSH
96642: LD_INT 116
96644: PUSH
96645: LD_INT 117
96647: PUSH
96648: LD_INT 118
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: PUSH
96670: EMPTY
96671: LIST
96672: LIST
96673: ST_TO_ADDR
96674: GO 97913
96676: LD_INT 14
96678: DOUBLE
96679: EQUAL
96680: IFTRUE 96684
96682: GO 96908
96684: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
96685: LD_ADDR_VAR 0 2
96689: PUSH
96690: LD_INT 1
96692: PUSH
96693: LD_INT 2
96695: PUSH
96696: LD_INT 3
96698: PUSH
96699: LD_INT 4
96701: PUSH
96702: LD_INT 5
96704: PUSH
96705: LD_INT 6
96707: PUSH
96708: LD_INT 7
96710: PUSH
96711: LD_INT 8
96713: PUSH
96714: LD_INT 9
96716: PUSH
96717: LD_INT 10
96719: PUSH
96720: LD_INT 11
96722: PUSH
96723: LD_INT 12
96725: PUSH
96726: LD_INT 13
96728: PUSH
96729: LD_INT 14
96731: PUSH
96732: LD_INT 15
96734: PUSH
96735: LD_INT 16
96737: PUSH
96738: LD_INT 17
96740: PUSH
96741: LD_INT 18
96743: PUSH
96744: LD_INT 19
96746: PUSH
96747: LD_INT 20
96749: PUSH
96750: LD_INT 21
96752: PUSH
96753: LD_INT 22
96755: PUSH
96756: LD_INT 23
96758: PUSH
96759: LD_INT 24
96761: PUSH
96762: LD_INT 25
96764: PUSH
96765: LD_INT 26
96767: PUSH
96768: LD_INT 27
96770: PUSH
96771: LD_INT 28
96773: PUSH
96774: LD_INT 29
96776: PUSH
96777: LD_INT 30
96779: PUSH
96780: LD_INT 31
96782: PUSH
96783: LD_INT 32
96785: PUSH
96786: LD_INT 33
96788: PUSH
96789: LD_INT 34
96791: PUSH
96792: LD_INT 36
96794: PUSH
96795: EMPTY
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: PUSH
96832: LD_INT 101
96834: PUSH
96835: LD_INT 102
96837: PUSH
96838: LD_INT 103
96840: PUSH
96841: LD_INT 104
96843: PUSH
96844: LD_INT 105
96846: PUSH
96847: LD_INT 106
96849: PUSH
96850: LD_INT 107
96852: PUSH
96853: LD_INT 108
96855: PUSH
96856: LD_INT 109
96858: PUSH
96859: LD_INT 110
96861: PUSH
96862: LD_INT 111
96864: PUSH
96865: LD_INT 112
96867: PUSH
96868: LD_INT 113
96870: PUSH
96871: LD_INT 114
96873: PUSH
96874: LD_INT 116
96876: PUSH
96877: LD_INT 117
96879: PUSH
96880: LD_INT 118
96882: PUSH
96883: EMPTY
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: ST_TO_ADDR
96906: GO 97913
96908: LD_INT 15
96910: DOUBLE
96911: EQUAL
96912: IFTRUE 96916
96914: GO 97140
96916: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96917: LD_ADDR_VAR 0 2
96921: PUSH
96922: LD_INT 1
96924: PUSH
96925: LD_INT 2
96927: PUSH
96928: LD_INT 3
96930: PUSH
96931: LD_INT 4
96933: PUSH
96934: LD_INT 5
96936: PUSH
96937: LD_INT 6
96939: PUSH
96940: LD_INT 7
96942: PUSH
96943: LD_INT 8
96945: PUSH
96946: LD_INT 9
96948: PUSH
96949: LD_INT 10
96951: PUSH
96952: LD_INT 11
96954: PUSH
96955: LD_INT 12
96957: PUSH
96958: LD_INT 13
96960: PUSH
96961: LD_INT 14
96963: PUSH
96964: LD_INT 15
96966: PUSH
96967: LD_INT 16
96969: PUSH
96970: LD_INT 17
96972: PUSH
96973: LD_INT 18
96975: PUSH
96976: LD_INT 19
96978: PUSH
96979: LD_INT 20
96981: PUSH
96982: LD_INT 21
96984: PUSH
96985: LD_INT 22
96987: PUSH
96988: LD_INT 23
96990: PUSH
96991: LD_INT 24
96993: PUSH
96994: LD_INT 25
96996: PUSH
96997: LD_INT 26
96999: PUSH
97000: LD_INT 27
97002: PUSH
97003: LD_INT 28
97005: PUSH
97006: LD_INT 29
97008: PUSH
97009: LD_INT 30
97011: PUSH
97012: LD_INT 31
97014: PUSH
97015: LD_INT 32
97017: PUSH
97018: LD_INT 33
97020: PUSH
97021: LD_INT 34
97023: PUSH
97024: LD_INT 36
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: LIST
97053: LIST
97054: LIST
97055: LIST
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: PUSH
97064: LD_INT 101
97066: PUSH
97067: LD_INT 102
97069: PUSH
97070: LD_INT 103
97072: PUSH
97073: LD_INT 104
97075: PUSH
97076: LD_INT 105
97078: PUSH
97079: LD_INT 106
97081: PUSH
97082: LD_INT 107
97084: PUSH
97085: LD_INT 108
97087: PUSH
97088: LD_INT 109
97090: PUSH
97091: LD_INT 110
97093: PUSH
97094: LD_INT 111
97096: PUSH
97097: LD_INT 112
97099: PUSH
97100: LD_INT 113
97102: PUSH
97103: LD_INT 114
97105: PUSH
97106: LD_INT 116
97108: PUSH
97109: LD_INT 117
97111: PUSH
97112: LD_INT 118
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: PUSH
97134: EMPTY
97135: LIST
97136: LIST
97137: ST_TO_ADDR
97138: GO 97913
97140: LD_INT 16
97142: DOUBLE
97143: EQUAL
97144: IFTRUE 97148
97146: GO 97284
97148: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97149: LD_ADDR_VAR 0 2
97153: PUSH
97154: LD_INT 2
97156: PUSH
97157: LD_INT 4
97159: PUSH
97160: LD_INT 5
97162: PUSH
97163: LD_INT 7
97165: PUSH
97166: LD_INT 11
97168: PUSH
97169: LD_INT 12
97171: PUSH
97172: LD_INT 15
97174: PUSH
97175: LD_INT 16
97177: PUSH
97178: LD_INT 20
97180: PUSH
97181: LD_INT 21
97183: PUSH
97184: LD_INT 22
97186: PUSH
97187: LD_INT 23
97189: PUSH
97190: LD_INT 25
97192: PUSH
97193: LD_INT 26
97195: PUSH
97196: LD_INT 30
97198: PUSH
97199: LD_INT 31
97201: PUSH
97202: LD_INT 32
97204: PUSH
97205: LD_INT 33
97207: PUSH
97208: LD_INT 34
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: PUSH
97232: LD_INT 101
97234: PUSH
97235: LD_INT 102
97237: PUSH
97238: LD_INT 103
97240: PUSH
97241: LD_INT 106
97243: PUSH
97244: LD_INT 108
97246: PUSH
97247: LD_INT 112
97249: PUSH
97250: LD_INT 113
97252: PUSH
97253: LD_INT 114
97255: PUSH
97256: LD_INT 116
97258: PUSH
97259: LD_INT 117
97261: PUSH
97262: LD_INT 118
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: PUSH
97278: EMPTY
97279: LIST
97280: LIST
97281: ST_TO_ADDR
97282: GO 97913
97284: LD_INT 17
97286: DOUBLE
97287: EQUAL
97288: IFTRUE 97292
97290: GO 97516
97292: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97293: LD_ADDR_VAR 0 2
97297: PUSH
97298: LD_INT 1
97300: PUSH
97301: LD_INT 2
97303: PUSH
97304: LD_INT 3
97306: PUSH
97307: LD_INT 4
97309: PUSH
97310: LD_INT 5
97312: PUSH
97313: LD_INT 6
97315: PUSH
97316: LD_INT 7
97318: PUSH
97319: LD_INT 8
97321: PUSH
97322: LD_INT 9
97324: PUSH
97325: LD_INT 10
97327: PUSH
97328: LD_INT 11
97330: PUSH
97331: LD_INT 12
97333: PUSH
97334: LD_INT 13
97336: PUSH
97337: LD_INT 14
97339: PUSH
97340: LD_INT 15
97342: PUSH
97343: LD_INT 16
97345: PUSH
97346: LD_INT 17
97348: PUSH
97349: LD_INT 18
97351: PUSH
97352: LD_INT 19
97354: PUSH
97355: LD_INT 20
97357: PUSH
97358: LD_INT 21
97360: PUSH
97361: LD_INT 22
97363: PUSH
97364: LD_INT 23
97366: PUSH
97367: LD_INT 24
97369: PUSH
97370: LD_INT 25
97372: PUSH
97373: LD_INT 26
97375: PUSH
97376: LD_INT 27
97378: PUSH
97379: LD_INT 28
97381: PUSH
97382: LD_INT 29
97384: PUSH
97385: LD_INT 30
97387: PUSH
97388: LD_INT 31
97390: PUSH
97391: LD_INT 32
97393: PUSH
97394: LD_INT 33
97396: PUSH
97397: LD_INT 34
97399: PUSH
97400: LD_INT 36
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: PUSH
97440: LD_INT 101
97442: PUSH
97443: LD_INT 102
97445: PUSH
97446: LD_INT 103
97448: PUSH
97449: LD_INT 104
97451: PUSH
97452: LD_INT 105
97454: PUSH
97455: LD_INT 106
97457: PUSH
97458: LD_INT 107
97460: PUSH
97461: LD_INT 108
97463: PUSH
97464: LD_INT 109
97466: PUSH
97467: LD_INT 110
97469: PUSH
97470: LD_INT 111
97472: PUSH
97473: LD_INT 112
97475: PUSH
97476: LD_INT 113
97478: PUSH
97479: LD_INT 114
97481: PUSH
97482: LD_INT 116
97484: PUSH
97485: LD_INT 117
97487: PUSH
97488: LD_INT 118
97490: PUSH
97491: EMPTY
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: PUSH
97510: EMPTY
97511: LIST
97512: LIST
97513: ST_TO_ADDR
97514: GO 97913
97516: LD_INT 18
97518: DOUBLE
97519: EQUAL
97520: IFTRUE 97524
97522: GO 97672
97524: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97525: LD_ADDR_VAR 0 2
97529: PUSH
97530: LD_INT 2
97532: PUSH
97533: LD_INT 4
97535: PUSH
97536: LD_INT 5
97538: PUSH
97539: LD_INT 7
97541: PUSH
97542: LD_INT 11
97544: PUSH
97545: LD_INT 12
97547: PUSH
97548: LD_INT 15
97550: PUSH
97551: LD_INT 16
97553: PUSH
97554: LD_INT 20
97556: PUSH
97557: LD_INT 21
97559: PUSH
97560: LD_INT 22
97562: PUSH
97563: LD_INT 23
97565: PUSH
97566: LD_INT 25
97568: PUSH
97569: LD_INT 26
97571: PUSH
97572: LD_INT 30
97574: PUSH
97575: LD_INT 31
97577: PUSH
97578: LD_INT 32
97580: PUSH
97581: LD_INT 33
97583: PUSH
97584: LD_INT 34
97586: PUSH
97587: LD_INT 35
97589: PUSH
97590: LD_INT 36
97592: PUSH
97593: EMPTY
97594: LIST
97595: LIST
97596: LIST
97597: LIST
97598: LIST
97599: LIST
97600: LIST
97601: LIST
97602: LIST
97603: LIST
97604: LIST
97605: LIST
97606: LIST
97607: LIST
97608: LIST
97609: LIST
97610: LIST
97611: LIST
97612: LIST
97613: LIST
97614: LIST
97615: PUSH
97616: LD_INT 101
97618: PUSH
97619: LD_INT 102
97621: PUSH
97622: LD_INT 103
97624: PUSH
97625: LD_INT 106
97627: PUSH
97628: LD_INT 108
97630: PUSH
97631: LD_INT 112
97633: PUSH
97634: LD_INT 113
97636: PUSH
97637: LD_INT 114
97639: PUSH
97640: LD_INT 115
97642: PUSH
97643: LD_INT 116
97645: PUSH
97646: LD_INT 117
97648: PUSH
97649: LD_INT 118
97651: PUSH
97652: EMPTY
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: PUSH
97666: EMPTY
97667: LIST
97668: LIST
97669: ST_TO_ADDR
97670: GO 97913
97672: LD_INT 19
97674: DOUBLE
97675: EQUAL
97676: IFTRUE 97680
97678: GO 97912
97680: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
97681: LD_ADDR_VAR 0 2
97685: PUSH
97686: LD_INT 1
97688: PUSH
97689: LD_INT 2
97691: PUSH
97692: LD_INT 3
97694: PUSH
97695: LD_INT 4
97697: PUSH
97698: LD_INT 5
97700: PUSH
97701: LD_INT 6
97703: PUSH
97704: LD_INT 7
97706: PUSH
97707: LD_INT 8
97709: PUSH
97710: LD_INT 9
97712: PUSH
97713: LD_INT 10
97715: PUSH
97716: LD_INT 11
97718: PUSH
97719: LD_INT 12
97721: PUSH
97722: LD_INT 13
97724: PUSH
97725: LD_INT 14
97727: PUSH
97728: LD_INT 15
97730: PUSH
97731: LD_INT 16
97733: PUSH
97734: LD_INT 17
97736: PUSH
97737: LD_INT 18
97739: PUSH
97740: LD_INT 19
97742: PUSH
97743: LD_INT 20
97745: PUSH
97746: LD_INT 21
97748: PUSH
97749: LD_INT 22
97751: PUSH
97752: LD_INT 23
97754: PUSH
97755: LD_INT 24
97757: PUSH
97758: LD_INT 25
97760: PUSH
97761: LD_INT 26
97763: PUSH
97764: LD_INT 27
97766: PUSH
97767: LD_INT 28
97769: PUSH
97770: LD_INT 29
97772: PUSH
97773: LD_INT 30
97775: PUSH
97776: LD_INT 31
97778: PUSH
97779: LD_INT 32
97781: PUSH
97782: LD_INT 33
97784: PUSH
97785: LD_INT 34
97787: PUSH
97788: LD_INT 35
97790: PUSH
97791: LD_INT 36
97793: PUSH
97794: EMPTY
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: PUSH
97832: LD_INT 101
97834: PUSH
97835: LD_INT 102
97837: PUSH
97838: LD_INT 103
97840: PUSH
97841: LD_INT 104
97843: PUSH
97844: LD_INT 105
97846: PUSH
97847: LD_INT 106
97849: PUSH
97850: LD_INT 107
97852: PUSH
97853: LD_INT 108
97855: PUSH
97856: LD_INT 109
97858: PUSH
97859: LD_INT 110
97861: PUSH
97862: LD_INT 111
97864: PUSH
97865: LD_INT 112
97867: PUSH
97868: LD_INT 113
97870: PUSH
97871: LD_INT 114
97873: PUSH
97874: LD_INT 115
97876: PUSH
97877: LD_INT 116
97879: PUSH
97880: LD_INT 117
97882: PUSH
97883: LD_INT 118
97885: PUSH
97886: EMPTY
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: PUSH
97906: EMPTY
97907: LIST
97908: LIST
97909: ST_TO_ADDR
97910: GO 97913
97912: POP
// end else
97913: GO 98144
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97915: LD_ADDR_VAR 0 2
97919: PUSH
97920: LD_INT 1
97922: PUSH
97923: LD_INT 2
97925: PUSH
97926: LD_INT 3
97928: PUSH
97929: LD_INT 4
97931: PUSH
97932: LD_INT 5
97934: PUSH
97935: LD_INT 6
97937: PUSH
97938: LD_INT 7
97940: PUSH
97941: LD_INT 8
97943: PUSH
97944: LD_INT 9
97946: PUSH
97947: LD_INT 10
97949: PUSH
97950: LD_INT 11
97952: PUSH
97953: LD_INT 12
97955: PUSH
97956: LD_INT 13
97958: PUSH
97959: LD_INT 14
97961: PUSH
97962: LD_INT 15
97964: PUSH
97965: LD_INT 16
97967: PUSH
97968: LD_INT 17
97970: PUSH
97971: LD_INT 18
97973: PUSH
97974: LD_INT 19
97976: PUSH
97977: LD_INT 20
97979: PUSH
97980: LD_INT 21
97982: PUSH
97983: LD_INT 22
97985: PUSH
97986: LD_INT 23
97988: PUSH
97989: LD_INT 24
97991: PUSH
97992: LD_INT 25
97994: PUSH
97995: LD_INT 26
97997: PUSH
97998: LD_INT 27
98000: PUSH
98001: LD_INT 28
98003: PUSH
98004: LD_INT 29
98006: PUSH
98007: LD_INT 30
98009: PUSH
98010: LD_INT 31
98012: PUSH
98013: LD_INT 32
98015: PUSH
98016: LD_INT 33
98018: PUSH
98019: LD_INT 34
98021: PUSH
98022: LD_INT 35
98024: PUSH
98025: LD_INT 36
98027: PUSH
98028: EMPTY
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: LIST
98041: LIST
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: LIST
98056: LIST
98057: LIST
98058: LIST
98059: LIST
98060: LIST
98061: LIST
98062: LIST
98063: LIST
98064: LIST
98065: PUSH
98066: LD_INT 101
98068: PUSH
98069: LD_INT 102
98071: PUSH
98072: LD_INT 103
98074: PUSH
98075: LD_INT 104
98077: PUSH
98078: LD_INT 105
98080: PUSH
98081: LD_INT 106
98083: PUSH
98084: LD_INT 107
98086: PUSH
98087: LD_INT 108
98089: PUSH
98090: LD_INT 109
98092: PUSH
98093: LD_INT 110
98095: PUSH
98096: LD_INT 111
98098: PUSH
98099: LD_INT 112
98101: PUSH
98102: LD_INT 113
98104: PUSH
98105: LD_INT 114
98107: PUSH
98108: LD_INT 115
98110: PUSH
98111: LD_INT 116
98113: PUSH
98114: LD_INT 117
98116: PUSH
98117: LD_INT 118
98119: PUSH
98120: EMPTY
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: LIST
98128: LIST
98129: LIST
98130: LIST
98131: LIST
98132: LIST
98133: LIST
98134: LIST
98135: LIST
98136: LIST
98137: LIST
98138: LIST
98139: PUSH
98140: EMPTY
98141: LIST
98142: LIST
98143: ST_TO_ADDR
// if result then
98144: LD_VAR 0 2
98148: IFFALSE 98934
// begin normal :=  ;
98150: LD_ADDR_VAR 0 5
98154: PUSH
98155: LD_STRING 
98157: ST_TO_ADDR
// hardcore :=  ;
98158: LD_ADDR_VAR 0 6
98162: PUSH
98163: LD_STRING 
98165: ST_TO_ADDR
// active :=  ;
98166: LD_ADDR_VAR 0 7
98170: PUSH
98171: LD_STRING 
98173: ST_TO_ADDR
// for i = 1 to normalCounter do
98174: LD_ADDR_VAR 0 8
98178: PUSH
98179: DOUBLE
98180: LD_INT 1
98182: DEC
98183: ST_TO_ADDR
98184: LD_EXP 121
98188: PUSH
98189: FOR_TO
98190: IFFALSE 98291
// begin tmp := 0 ;
98192: LD_ADDR_VAR 0 3
98196: PUSH
98197: LD_STRING 0
98199: ST_TO_ADDR
// if result [ 1 ] then
98200: LD_VAR 0 2
98204: PUSH
98205: LD_INT 1
98207: ARRAY
98208: IFFALSE 98273
// if result [ 1 ] [ 1 ] = i then
98210: LD_VAR 0 2
98214: PUSH
98215: LD_INT 1
98217: ARRAY
98218: PUSH
98219: LD_INT 1
98221: ARRAY
98222: PUSH
98223: LD_VAR 0 8
98227: EQUAL
98228: IFFALSE 98273
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
98230: LD_ADDR_VAR 0 2
98234: PUSH
98235: LD_VAR 0 2
98239: PPUSH
98240: LD_INT 1
98242: PPUSH
98243: LD_VAR 0 2
98247: PUSH
98248: LD_INT 1
98250: ARRAY
98251: PPUSH
98252: LD_INT 1
98254: PPUSH
98255: CALL_OW 3
98259: PPUSH
98260: CALL_OW 1
98264: ST_TO_ADDR
// tmp := 1 ;
98265: LD_ADDR_VAR 0 3
98269: PUSH
98270: LD_STRING 1
98272: ST_TO_ADDR
// end ; normal := normal & tmp ;
98273: LD_ADDR_VAR 0 5
98277: PUSH
98278: LD_VAR 0 5
98282: PUSH
98283: LD_VAR 0 3
98287: STR
98288: ST_TO_ADDR
// end ;
98289: GO 98189
98291: POP
98292: POP
// for i = 1 to hardcoreCounter do
98293: LD_ADDR_VAR 0 8
98297: PUSH
98298: DOUBLE
98299: LD_INT 1
98301: DEC
98302: ST_TO_ADDR
98303: LD_EXP 122
98307: PUSH
98308: FOR_TO
98309: IFFALSE 98414
// begin tmp := 0 ;
98311: LD_ADDR_VAR 0 3
98315: PUSH
98316: LD_STRING 0
98318: ST_TO_ADDR
// if result [ 2 ] then
98319: LD_VAR 0 2
98323: PUSH
98324: LD_INT 2
98326: ARRAY
98327: IFFALSE 98396
// if result [ 2 ] [ 1 ] = 100 + i then
98329: LD_VAR 0 2
98333: PUSH
98334: LD_INT 2
98336: ARRAY
98337: PUSH
98338: LD_INT 1
98340: ARRAY
98341: PUSH
98342: LD_INT 100
98344: PUSH
98345: LD_VAR 0 8
98349: PLUS
98350: EQUAL
98351: IFFALSE 98396
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
98353: LD_ADDR_VAR 0 2
98357: PUSH
98358: LD_VAR 0 2
98362: PPUSH
98363: LD_INT 2
98365: PPUSH
98366: LD_VAR 0 2
98370: PUSH
98371: LD_INT 2
98373: ARRAY
98374: PPUSH
98375: LD_INT 1
98377: PPUSH
98378: CALL_OW 3
98382: PPUSH
98383: CALL_OW 1
98387: ST_TO_ADDR
// tmp := 1 ;
98388: LD_ADDR_VAR 0 3
98392: PUSH
98393: LD_STRING 1
98395: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98396: LD_ADDR_VAR 0 6
98400: PUSH
98401: LD_VAR 0 6
98405: PUSH
98406: LD_VAR 0 3
98410: STR
98411: ST_TO_ADDR
// end ;
98412: GO 98308
98414: POP
98415: POP
// if isGameLoad then
98416: LD_VAR 0 1
98420: IFFALSE 98895
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
98422: LD_ADDR_VAR 0 4
98426: PUSH
98427: LD_EXP 125
98431: PUSH
98432: LD_EXP 124
98436: PUSH
98437: LD_EXP 126
98441: PUSH
98442: LD_EXP 123
98446: PUSH
98447: LD_EXP 127
98451: PUSH
98452: LD_EXP 128
98456: PUSH
98457: LD_EXP 129
98461: PUSH
98462: LD_EXP 130
98466: PUSH
98467: LD_EXP 131
98471: PUSH
98472: LD_EXP 132
98476: PUSH
98477: LD_EXP 133
98481: PUSH
98482: LD_EXP 134
98486: PUSH
98487: LD_EXP 135
98491: PUSH
98492: LD_EXP 136
98496: PUSH
98497: LD_EXP 144
98501: PUSH
98502: LD_EXP 145
98506: PUSH
98507: LD_EXP 146
98511: PUSH
98512: LD_EXP 147
98516: PUSH
98517: LD_EXP 149
98521: PUSH
98522: LD_EXP 150
98526: PUSH
98527: LD_EXP 151
98531: PUSH
98532: LD_EXP 154
98536: PUSH
98537: LD_EXP 156
98541: PUSH
98542: LD_EXP 157
98546: PUSH
98547: LD_EXP 158
98551: PUSH
98552: LD_EXP 160
98556: PUSH
98557: LD_EXP 161
98561: PUSH
98562: LD_EXP 164
98566: PUSH
98567: LD_EXP 165
98571: PUSH
98572: LD_EXP 166
98576: PUSH
98577: LD_EXP 167
98581: PUSH
98582: LD_EXP 168
98586: PUSH
98587: LD_EXP 169
98591: PUSH
98592: LD_EXP 170
98596: PUSH
98597: LD_EXP 171
98601: PUSH
98602: LD_EXP 172
98606: PUSH
98607: LD_EXP 137
98611: PUSH
98612: LD_EXP 138
98616: PUSH
98617: LD_EXP 141
98621: PUSH
98622: LD_EXP 142
98626: PUSH
98627: LD_EXP 143
98631: PUSH
98632: LD_EXP 139
98636: PUSH
98637: LD_EXP 140
98641: PUSH
98642: LD_EXP 148
98646: PUSH
98647: LD_EXP 152
98651: PUSH
98652: LD_EXP 153
98656: PUSH
98657: LD_EXP 155
98661: PUSH
98662: LD_EXP 159
98666: PUSH
98667: LD_EXP 162
98671: PUSH
98672: LD_EXP 163
98676: PUSH
98677: LD_EXP 173
98681: PUSH
98682: LD_EXP 174
98686: PUSH
98687: LD_EXP 175
98691: PUSH
98692: LD_EXP 176
98696: PUSH
98697: EMPTY
98698: LIST
98699: LIST
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: ST_TO_ADDR
// tmp :=  ;
98753: LD_ADDR_VAR 0 3
98757: PUSH
98758: LD_STRING 
98760: ST_TO_ADDR
// for i = 1 to normalCounter do
98761: LD_ADDR_VAR 0 8
98765: PUSH
98766: DOUBLE
98767: LD_INT 1
98769: DEC
98770: ST_TO_ADDR
98771: LD_EXP 121
98775: PUSH
98776: FOR_TO
98777: IFFALSE 98813
// begin if flags [ i ] then
98779: LD_VAR 0 4
98783: PUSH
98784: LD_VAR 0 8
98788: ARRAY
98789: IFFALSE 98811
// tmp := tmp & i & ; ;
98791: LD_ADDR_VAR 0 3
98795: PUSH
98796: LD_VAR 0 3
98800: PUSH
98801: LD_VAR 0 8
98805: STR
98806: PUSH
98807: LD_STRING ;
98809: STR
98810: ST_TO_ADDR
// end ;
98811: GO 98776
98813: POP
98814: POP
// for i = 1 to hardcoreCounter do
98815: LD_ADDR_VAR 0 8
98819: PUSH
98820: DOUBLE
98821: LD_INT 1
98823: DEC
98824: ST_TO_ADDR
98825: LD_EXP 122
98829: PUSH
98830: FOR_TO
98831: IFFALSE 98877
// begin if flags [ normalCounter + i ] then
98833: LD_VAR 0 4
98837: PUSH
98838: LD_EXP 121
98842: PUSH
98843: LD_VAR 0 8
98847: PLUS
98848: ARRAY
98849: IFFALSE 98875
// tmp := tmp & ( 100 + i ) & ; ;
98851: LD_ADDR_VAR 0 3
98855: PUSH
98856: LD_VAR 0 3
98860: PUSH
98861: LD_INT 100
98863: PUSH
98864: LD_VAR 0 8
98868: PLUS
98869: STR
98870: PUSH
98871: LD_STRING ;
98873: STR
98874: ST_TO_ADDR
// end ;
98875: GO 98830
98877: POP
98878: POP
// if tmp then
98879: LD_VAR 0 3
98883: IFFALSE 98895
// active := tmp ;
98885: LD_ADDR_VAR 0 7
98889: PUSH
98890: LD_VAR 0 3
98894: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
98895: LD_STRING getStreamItemsFromMission("
98897: PUSH
98898: LD_VAR 0 5
98902: STR
98903: PUSH
98904: LD_STRING ","
98906: STR
98907: PUSH
98908: LD_VAR 0 6
98912: STR
98913: PUSH
98914: LD_STRING ","
98916: STR
98917: PUSH
98918: LD_VAR 0 7
98922: STR
98923: PUSH
98924: LD_STRING ")
98926: STR
98927: PPUSH
98928: CALL_OW 559
// end else
98932: GO 98941
// ToLua ( getStreamItemsFromMission("","","") ) ;
98934: LD_STRING getStreamItemsFromMission("","","")
98936: PPUSH
98937: CALL_OW 559
// end ;
98941: LD_VAR 0 2
98945: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98946: LD_EXP 120
98950: PUSH
98951: LD_EXP 125
98955: AND
98956: IFFALSE 99080
98958: GO 98960
98960: DISABLE
98961: LD_INT 0
98963: PPUSH
98964: PPUSH
// begin enable ;
98965: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98966: LD_ADDR_VAR 0 2
98970: PUSH
98971: LD_INT 22
98973: PUSH
98974: LD_OWVAR 2
98978: PUSH
98979: EMPTY
98980: LIST
98981: LIST
98982: PUSH
98983: LD_INT 2
98985: PUSH
98986: LD_INT 34
98988: PUSH
98989: LD_INT 7
98991: PUSH
98992: EMPTY
98993: LIST
98994: LIST
98995: PUSH
98996: LD_INT 34
98998: PUSH
98999: LD_INT 45
99001: PUSH
99002: EMPTY
99003: LIST
99004: LIST
99005: PUSH
99006: LD_INT 34
99008: PUSH
99009: LD_INT 28
99011: PUSH
99012: EMPTY
99013: LIST
99014: LIST
99015: PUSH
99016: LD_INT 34
99018: PUSH
99019: LD_INT 47
99021: PUSH
99022: EMPTY
99023: LIST
99024: LIST
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: LIST
99030: LIST
99031: LIST
99032: PUSH
99033: EMPTY
99034: LIST
99035: LIST
99036: PPUSH
99037: CALL_OW 69
99041: ST_TO_ADDR
// if not tmp then
99042: LD_VAR 0 2
99046: NOT
99047: IFFALSE 99051
// exit ;
99049: GO 99080
// for i in tmp do
99051: LD_ADDR_VAR 0 1
99055: PUSH
99056: LD_VAR 0 2
99060: PUSH
99061: FOR_IN
99062: IFFALSE 99078
// begin SetLives ( i , 0 ) ;
99064: LD_VAR 0 1
99068: PPUSH
99069: LD_INT 0
99071: PPUSH
99072: CALL_OW 234
// end ;
99076: GO 99061
99078: POP
99079: POP
// end ;
99080: PPOPN 2
99082: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99083: LD_EXP 120
99087: PUSH
99088: LD_EXP 126
99092: AND
99093: IFFALSE 99177
99095: GO 99097
99097: DISABLE
99098: LD_INT 0
99100: PPUSH
99101: PPUSH
// begin enable ;
99102: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99103: LD_ADDR_VAR 0 2
99107: PUSH
99108: LD_INT 22
99110: PUSH
99111: LD_OWVAR 2
99115: PUSH
99116: EMPTY
99117: LIST
99118: LIST
99119: PUSH
99120: LD_INT 32
99122: PUSH
99123: LD_INT 3
99125: PUSH
99126: EMPTY
99127: LIST
99128: LIST
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: PPUSH
99134: CALL_OW 69
99138: ST_TO_ADDR
// if not tmp then
99139: LD_VAR 0 2
99143: NOT
99144: IFFALSE 99148
// exit ;
99146: GO 99177
// for i in tmp do
99148: LD_ADDR_VAR 0 1
99152: PUSH
99153: LD_VAR 0 2
99157: PUSH
99158: FOR_IN
99159: IFFALSE 99175
// begin SetLives ( i , 0 ) ;
99161: LD_VAR 0 1
99165: PPUSH
99166: LD_INT 0
99168: PPUSH
99169: CALL_OW 234
// end ;
99173: GO 99158
99175: POP
99176: POP
// end ;
99177: PPOPN 2
99179: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
99180: LD_EXP 120
99184: PUSH
99185: LD_EXP 123
99189: AND
99190: IFFALSE 99283
99192: GO 99194
99194: DISABLE
99195: LD_INT 0
99197: PPUSH
// begin enable ;
99198: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
99199: LD_ADDR_VAR 0 1
99203: PUSH
99204: LD_INT 22
99206: PUSH
99207: LD_OWVAR 2
99211: PUSH
99212: EMPTY
99213: LIST
99214: LIST
99215: PUSH
99216: LD_INT 2
99218: PUSH
99219: LD_INT 25
99221: PUSH
99222: LD_INT 5
99224: PUSH
99225: EMPTY
99226: LIST
99227: LIST
99228: PUSH
99229: LD_INT 25
99231: PUSH
99232: LD_INT 9
99234: PUSH
99235: EMPTY
99236: LIST
99237: LIST
99238: PUSH
99239: LD_INT 25
99241: PUSH
99242: LD_INT 8
99244: PUSH
99245: EMPTY
99246: LIST
99247: LIST
99248: PUSH
99249: EMPTY
99250: LIST
99251: LIST
99252: LIST
99253: LIST
99254: PUSH
99255: EMPTY
99256: LIST
99257: LIST
99258: PPUSH
99259: CALL_OW 69
99263: PUSH
99264: FOR_IN
99265: IFFALSE 99281
// begin SetClass ( i , 1 ) ;
99267: LD_VAR 0 1
99271: PPUSH
99272: LD_INT 1
99274: PPUSH
99275: CALL_OW 336
// end ;
99279: GO 99264
99281: POP
99282: POP
// end ;
99283: PPOPN 1
99285: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
99286: LD_EXP 120
99290: PUSH
99291: LD_EXP 124
99295: AND
99296: PUSH
99297: LD_OWVAR 65
99301: PUSH
99302: LD_INT 7
99304: LESS
99305: AND
99306: IFFALSE 99320
99308: GO 99310
99310: DISABLE
// begin enable ;
99311: ENABLE
// game_speed := 7 ;
99312: LD_ADDR_OWVAR 65
99316: PUSH
99317: LD_INT 7
99319: ST_TO_ADDR
// end ;
99320: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
99321: LD_EXP 120
99325: PUSH
99326: LD_EXP 127
99330: AND
99331: IFFALSE 99533
99333: GO 99335
99335: DISABLE
99336: LD_INT 0
99338: PPUSH
99339: PPUSH
99340: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99341: LD_ADDR_VAR 0 3
99345: PUSH
99346: LD_INT 81
99348: PUSH
99349: LD_OWVAR 2
99353: PUSH
99354: EMPTY
99355: LIST
99356: LIST
99357: PUSH
99358: LD_INT 21
99360: PUSH
99361: LD_INT 1
99363: PUSH
99364: EMPTY
99365: LIST
99366: LIST
99367: PUSH
99368: EMPTY
99369: LIST
99370: LIST
99371: PPUSH
99372: CALL_OW 69
99376: ST_TO_ADDR
// if not tmp then
99377: LD_VAR 0 3
99381: NOT
99382: IFFALSE 99386
// exit ;
99384: GO 99533
// if tmp > 5 then
99386: LD_VAR 0 3
99390: PUSH
99391: LD_INT 5
99393: GREATER
99394: IFFALSE 99406
// k := 5 else
99396: LD_ADDR_VAR 0 2
99400: PUSH
99401: LD_INT 5
99403: ST_TO_ADDR
99404: GO 99416
// k := tmp ;
99406: LD_ADDR_VAR 0 2
99410: PUSH
99411: LD_VAR 0 3
99415: ST_TO_ADDR
// for i := 1 to k do
99416: LD_ADDR_VAR 0 1
99420: PUSH
99421: DOUBLE
99422: LD_INT 1
99424: DEC
99425: ST_TO_ADDR
99426: LD_VAR 0 2
99430: PUSH
99431: FOR_TO
99432: IFFALSE 99531
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
99434: LD_VAR 0 3
99438: PUSH
99439: LD_VAR 0 1
99443: ARRAY
99444: PPUSH
99445: LD_VAR 0 1
99449: PUSH
99450: LD_INT 4
99452: MOD
99453: PUSH
99454: LD_INT 1
99456: PLUS
99457: PPUSH
99458: CALL_OW 259
99462: PUSH
99463: LD_INT 10
99465: LESS
99466: IFFALSE 99529
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99468: LD_VAR 0 3
99472: PUSH
99473: LD_VAR 0 1
99477: ARRAY
99478: PPUSH
99479: LD_VAR 0 1
99483: PUSH
99484: LD_INT 4
99486: MOD
99487: PUSH
99488: LD_INT 1
99490: PLUS
99491: PPUSH
99492: LD_VAR 0 3
99496: PUSH
99497: LD_VAR 0 1
99501: ARRAY
99502: PPUSH
99503: LD_VAR 0 1
99507: PUSH
99508: LD_INT 4
99510: MOD
99511: PUSH
99512: LD_INT 1
99514: PLUS
99515: PPUSH
99516: CALL_OW 259
99520: PUSH
99521: LD_INT 1
99523: PLUS
99524: PPUSH
99525: CALL_OW 237
99529: GO 99431
99531: POP
99532: POP
// end ;
99533: PPOPN 3
99535: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99536: LD_EXP 120
99540: PUSH
99541: LD_EXP 128
99545: AND
99546: IFFALSE 99566
99548: GO 99550
99550: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99551: LD_INT 4
99553: PPUSH
99554: LD_OWVAR 2
99558: PPUSH
99559: LD_INT 0
99561: PPUSH
99562: CALL_OW 324
99566: END
// every 0 0$1 trigger StreamModeActive and sShovel do
99567: LD_EXP 120
99571: PUSH
99572: LD_EXP 157
99576: AND
99577: IFFALSE 99597
99579: GO 99581
99581: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
99582: LD_INT 19
99584: PPUSH
99585: LD_OWVAR 2
99589: PPUSH
99590: LD_INT 0
99592: PPUSH
99593: CALL_OW 324
99597: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
99598: LD_EXP 120
99602: PUSH
99603: LD_EXP 129
99607: AND
99608: IFFALSE 99710
99610: GO 99612
99612: DISABLE
99613: LD_INT 0
99615: PPUSH
99616: PPUSH
// begin enable ;
99617: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
99618: LD_ADDR_VAR 0 2
99622: PUSH
99623: LD_INT 22
99625: PUSH
99626: LD_OWVAR 2
99630: PUSH
99631: EMPTY
99632: LIST
99633: LIST
99634: PUSH
99635: LD_INT 2
99637: PUSH
99638: LD_INT 34
99640: PUSH
99641: LD_INT 11
99643: PUSH
99644: EMPTY
99645: LIST
99646: LIST
99647: PUSH
99648: LD_INT 34
99650: PUSH
99651: LD_INT 30
99653: PUSH
99654: EMPTY
99655: LIST
99656: LIST
99657: PUSH
99658: EMPTY
99659: LIST
99660: LIST
99661: LIST
99662: PUSH
99663: EMPTY
99664: LIST
99665: LIST
99666: PPUSH
99667: CALL_OW 69
99671: ST_TO_ADDR
// if not tmp then
99672: LD_VAR 0 2
99676: NOT
99677: IFFALSE 99681
// exit ;
99679: GO 99710
// for i in tmp do
99681: LD_ADDR_VAR 0 1
99685: PUSH
99686: LD_VAR 0 2
99690: PUSH
99691: FOR_IN
99692: IFFALSE 99708
// begin SetLives ( i , 0 ) ;
99694: LD_VAR 0 1
99698: PPUSH
99699: LD_INT 0
99701: PPUSH
99702: CALL_OW 234
// end ;
99706: GO 99691
99708: POP
99709: POP
// end ;
99710: PPOPN 2
99712: END
// every 0 0$1 trigger StreamModeActive and sBunker do
99713: LD_EXP 120
99717: PUSH
99718: LD_EXP 130
99722: AND
99723: IFFALSE 99743
99725: GO 99727
99727: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
99728: LD_INT 32
99730: PPUSH
99731: LD_OWVAR 2
99735: PPUSH
99736: LD_INT 0
99738: PPUSH
99739: CALL_OW 324
99743: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
99744: LD_EXP 120
99748: PUSH
99749: LD_EXP 131
99753: AND
99754: IFFALSE 99935
99756: GO 99758
99758: DISABLE
99759: LD_INT 0
99761: PPUSH
99762: PPUSH
99763: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99764: LD_ADDR_VAR 0 2
99768: PUSH
99769: LD_INT 22
99771: PUSH
99772: LD_OWVAR 2
99776: PUSH
99777: EMPTY
99778: LIST
99779: LIST
99780: PUSH
99781: LD_INT 33
99783: PUSH
99784: LD_INT 3
99786: PUSH
99787: EMPTY
99788: LIST
99789: LIST
99790: PUSH
99791: EMPTY
99792: LIST
99793: LIST
99794: PPUSH
99795: CALL_OW 69
99799: ST_TO_ADDR
// if not tmp then
99800: LD_VAR 0 2
99804: NOT
99805: IFFALSE 99809
// exit ;
99807: GO 99935
// side := 0 ;
99809: LD_ADDR_VAR 0 3
99813: PUSH
99814: LD_INT 0
99816: ST_TO_ADDR
// for i := 1 to 8 do
99817: LD_ADDR_VAR 0 1
99821: PUSH
99822: DOUBLE
99823: LD_INT 1
99825: DEC
99826: ST_TO_ADDR
99827: LD_INT 8
99829: PUSH
99830: FOR_TO
99831: IFFALSE 99879
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99833: LD_OWVAR 2
99837: PUSH
99838: LD_VAR 0 1
99842: NONEQUAL
99843: PUSH
99844: LD_OWVAR 2
99848: PPUSH
99849: LD_VAR 0 1
99853: PPUSH
99854: CALL_OW 81
99858: PUSH
99859: LD_INT 2
99861: EQUAL
99862: AND
99863: IFFALSE 99877
// begin side := i ;
99865: LD_ADDR_VAR 0 3
99869: PUSH
99870: LD_VAR 0 1
99874: ST_TO_ADDR
// break ;
99875: GO 99879
// end ;
99877: GO 99830
99879: POP
99880: POP
// if not side then
99881: LD_VAR 0 3
99885: NOT
99886: IFFALSE 99890
// exit ;
99888: GO 99935
// for i := 1 to tmp do
99890: LD_ADDR_VAR 0 1
99894: PUSH
99895: DOUBLE
99896: LD_INT 1
99898: DEC
99899: ST_TO_ADDR
99900: LD_VAR 0 2
99904: PUSH
99905: FOR_TO
99906: IFFALSE 99933
// if Prob ( 60 ) then
99908: LD_INT 60
99910: PPUSH
99911: CALL_OW 13
99915: IFFALSE 99931
// SetSide ( i , side ) ;
99917: LD_VAR 0 1
99921: PPUSH
99922: LD_VAR 0 3
99926: PPUSH
99927: CALL_OW 235
99931: GO 99905
99933: POP
99934: POP
// end ;
99935: PPOPN 3
99937: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99938: LD_EXP 120
99942: PUSH
99943: LD_EXP 133
99947: AND
99948: IFFALSE 100067
99950: GO 99952
99952: DISABLE
99953: LD_INT 0
99955: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99956: LD_ADDR_VAR 0 1
99960: PUSH
99961: LD_INT 22
99963: PUSH
99964: LD_OWVAR 2
99968: PUSH
99969: EMPTY
99970: LIST
99971: LIST
99972: PUSH
99973: LD_INT 21
99975: PUSH
99976: LD_INT 1
99978: PUSH
99979: EMPTY
99980: LIST
99981: LIST
99982: PUSH
99983: LD_INT 3
99985: PUSH
99986: LD_INT 23
99988: PUSH
99989: LD_INT 0
99991: PUSH
99992: EMPTY
99993: LIST
99994: LIST
99995: PUSH
99996: EMPTY
99997: LIST
99998: LIST
99999: PUSH
100000: EMPTY
100001: LIST
100002: LIST
100003: LIST
100004: PPUSH
100005: CALL_OW 69
100009: PUSH
100010: FOR_IN
100011: IFFALSE 100065
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100013: LD_VAR 0 1
100017: PPUSH
100018: CALL_OW 257
100022: PUSH
100023: LD_INT 1
100025: PUSH
100026: LD_INT 2
100028: PUSH
100029: LD_INT 3
100031: PUSH
100032: LD_INT 4
100034: PUSH
100035: EMPTY
100036: LIST
100037: LIST
100038: LIST
100039: LIST
100040: IN
100041: IFFALSE 100063
// SetClass ( un , rand ( 1 , 4 ) ) ;
100043: LD_VAR 0 1
100047: PPUSH
100048: LD_INT 1
100050: PPUSH
100051: LD_INT 4
100053: PPUSH
100054: CALL_OW 12
100058: PPUSH
100059: CALL_OW 336
100063: GO 100010
100065: POP
100066: POP
// end ;
100067: PPOPN 1
100069: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100070: LD_EXP 120
100074: PUSH
100075: LD_EXP 132
100079: AND
100080: IFFALSE 100159
100082: GO 100084
100084: DISABLE
100085: LD_INT 0
100087: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100088: LD_ADDR_VAR 0 1
100092: PUSH
100093: LD_INT 22
100095: PUSH
100096: LD_OWVAR 2
100100: PUSH
100101: EMPTY
100102: LIST
100103: LIST
100104: PUSH
100105: LD_INT 21
100107: PUSH
100108: LD_INT 3
100110: PUSH
100111: EMPTY
100112: LIST
100113: LIST
100114: PUSH
100115: EMPTY
100116: LIST
100117: LIST
100118: PPUSH
100119: CALL_OW 69
100123: ST_TO_ADDR
// if not tmp then
100124: LD_VAR 0 1
100128: NOT
100129: IFFALSE 100133
// exit ;
100131: GO 100159
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100133: LD_VAR 0 1
100137: PUSH
100138: LD_INT 1
100140: PPUSH
100141: LD_VAR 0 1
100145: PPUSH
100146: CALL_OW 12
100150: ARRAY
100151: PPUSH
100152: LD_INT 100
100154: PPUSH
100155: CALL_OW 234
// end ;
100159: PPOPN 1
100161: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
100162: LD_EXP 120
100166: PUSH
100167: LD_EXP 134
100171: AND
100172: IFFALSE 100270
100174: GO 100176
100176: DISABLE
100177: LD_INT 0
100179: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100180: LD_ADDR_VAR 0 1
100184: PUSH
100185: LD_INT 22
100187: PUSH
100188: LD_OWVAR 2
100192: PUSH
100193: EMPTY
100194: LIST
100195: LIST
100196: PUSH
100197: LD_INT 21
100199: PUSH
100200: LD_INT 1
100202: PUSH
100203: EMPTY
100204: LIST
100205: LIST
100206: PUSH
100207: EMPTY
100208: LIST
100209: LIST
100210: PPUSH
100211: CALL_OW 69
100215: ST_TO_ADDR
// if not tmp then
100216: LD_VAR 0 1
100220: NOT
100221: IFFALSE 100225
// exit ;
100223: GO 100270
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
100225: LD_VAR 0 1
100229: PUSH
100230: LD_INT 1
100232: PPUSH
100233: LD_VAR 0 1
100237: PPUSH
100238: CALL_OW 12
100242: ARRAY
100243: PPUSH
100244: LD_INT 1
100246: PPUSH
100247: LD_INT 4
100249: PPUSH
100250: CALL_OW 12
100254: PPUSH
100255: LD_INT 3000
100257: PPUSH
100258: LD_INT 9000
100260: PPUSH
100261: CALL_OW 12
100265: PPUSH
100266: CALL_OW 492
// end ;
100270: PPOPN 1
100272: END
// every 0 0$1 trigger StreamModeActive and sDepot do
100273: LD_EXP 120
100277: PUSH
100278: LD_EXP 135
100282: AND
100283: IFFALSE 100303
100285: GO 100287
100287: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
100288: LD_INT 1
100290: PPUSH
100291: LD_OWVAR 2
100295: PPUSH
100296: LD_INT 0
100298: PPUSH
100299: CALL_OW 324
100303: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
100304: LD_EXP 120
100308: PUSH
100309: LD_EXP 136
100313: AND
100314: IFFALSE 100397
100316: GO 100318
100318: DISABLE
100319: LD_INT 0
100321: PPUSH
100322: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100323: LD_ADDR_VAR 0 2
100327: PUSH
100328: LD_INT 22
100330: PUSH
100331: LD_OWVAR 2
100335: PUSH
100336: EMPTY
100337: LIST
100338: LIST
100339: PUSH
100340: LD_INT 21
100342: PUSH
100343: LD_INT 3
100345: PUSH
100346: EMPTY
100347: LIST
100348: LIST
100349: PUSH
100350: EMPTY
100351: LIST
100352: LIST
100353: PPUSH
100354: CALL_OW 69
100358: ST_TO_ADDR
// if not tmp then
100359: LD_VAR 0 2
100363: NOT
100364: IFFALSE 100368
// exit ;
100366: GO 100397
// for i in tmp do
100368: LD_ADDR_VAR 0 1
100372: PUSH
100373: LD_VAR 0 2
100377: PUSH
100378: FOR_IN
100379: IFFALSE 100395
// SetBLevel ( i , 10 ) ;
100381: LD_VAR 0 1
100385: PPUSH
100386: LD_INT 10
100388: PPUSH
100389: CALL_OW 241
100393: GO 100378
100395: POP
100396: POP
// end ;
100397: PPOPN 2
100399: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100400: LD_EXP 120
100404: PUSH
100405: LD_EXP 137
100409: AND
100410: IFFALSE 100521
100412: GO 100414
100414: DISABLE
100415: LD_INT 0
100417: PPUSH
100418: PPUSH
100419: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100420: LD_ADDR_VAR 0 3
100424: PUSH
100425: LD_INT 22
100427: PUSH
100428: LD_OWVAR 2
100432: PUSH
100433: EMPTY
100434: LIST
100435: LIST
100436: PUSH
100437: LD_INT 25
100439: PUSH
100440: LD_INT 1
100442: PUSH
100443: EMPTY
100444: LIST
100445: LIST
100446: PUSH
100447: EMPTY
100448: LIST
100449: LIST
100450: PPUSH
100451: CALL_OW 69
100455: ST_TO_ADDR
// if not tmp then
100456: LD_VAR 0 3
100460: NOT
100461: IFFALSE 100465
// exit ;
100463: GO 100521
// un := tmp [ rand ( 1 , tmp ) ] ;
100465: LD_ADDR_VAR 0 2
100469: PUSH
100470: LD_VAR 0 3
100474: PUSH
100475: LD_INT 1
100477: PPUSH
100478: LD_VAR 0 3
100482: PPUSH
100483: CALL_OW 12
100487: ARRAY
100488: ST_TO_ADDR
// if Crawls ( un ) then
100489: LD_VAR 0 2
100493: PPUSH
100494: CALL_OW 318
100498: IFFALSE 100509
// ComWalk ( un ) ;
100500: LD_VAR 0 2
100504: PPUSH
100505: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100509: LD_VAR 0 2
100513: PPUSH
100514: LD_INT 5
100516: PPUSH
100517: CALL_OW 336
// end ;
100521: PPOPN 3
100523: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
100524: LD_EXP 120
100528: PUSH
100529: LD_EXP 138
100533: AND
100534: PUSH
100535: LD_OWVAR 67
100539: PUSH
100540: LD_INT 4
100542: LESS
100543: AND
100544: IFFALSE 100563
100546: GO 100548
100548: DISABLE
// begin Difficulty := Difficulty + 1 ;
100549: LD_ADDR_OWVAR 67
100553: PUSH
100554: LD_OWVAR 67
100558: PUSH
100559: LD_INT 1
100561: PLUS
100562: ST_TO_ADDR
// end ;
100563: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
100564: LD_EXP 120
100568: PUSH
100569: LD_EXP 139
100573: AND
100574: IFFALSE 100677
100576: GO 100578
100578: DISABLE
100579: LD_INT 0
100581: PPUSH
// begin for i := 1 to 5 do
100582: LD_ADDR_VAR 0 1
100586: PUSH
100587: DOUBLE
100588: LD_INT 1
100590: DEC
100591: ST_TO_ADDR
100592: LD_INT 5
100594: PUSH
100595: FOR_TO
100596: IFFALSE 100675
// begin uc_nation := nation_nature ;
100598: LD_ADDR_OWVAR 21
100602: PUSH
100603: LD_INT 0
100605: ST_TO_ADDR
// uc_side := 0 ;
100606: LD_ADDR_OWVAR 20
100610: PUSH
100611: LD_INT 0
100613: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100614: LD_ADDR_OWVAR 29
100618: PUSH
100619: LD_INT 12
100621: PUSH
100622: LD_INT 12
100624: PUSH
100625: EMPTY
100626: LIST
100627: LIST
100628: ST_TO_ADDR
// hc_agressivity := 20 ;
100629: LD_ADDR_OWVAR 35
100633: PUSH
100634: LD_INT 20
100636: ST_TO_ADDR
// hc_class := class_tiger ;
100637: LD_ADDR_OWVAR 28
100641: PUSH
100642: LD_INT 14
100644: ST_TO_ADDR
// hc_gallery :=  ;
100645: LD_ADDR_OWVAR 33
100649: PUSH
100650: LD_STRING 
100652: ST_TO_ADDR
// hc_name :=  ;
100653: LD_ADDR_OWVAR 26
100657: PUSH
100658: LD_STRING 
100660: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
100661: CALL_OW 44
100665: PPUSH
100666: LD_INT 0
100668: PPUSH
100669: CALL_OW 51
// end ;
100673: GO 100595
100675: POP
100676: POP
// end ;
100677: PPOPN 1
100679: END
// every 0 0$1 trigger StreamModeActive and sBomb do
100680: LD_EXP 120
100684: PUSH
100685: LD_EXP 140
100689: AND
100690: IFFALSE 100699
100692: GO 100694
100694: DISABLE
// StreamSibBomb ;
100695: CALL 100700 0 0
100699: END
// export function StreamSibBomb ; var i , x , y ; begin
100700: LD_INT 0
100702: PPUSH
100703: PPUSH
100704: PPUSH
100705: PPUSH
// result := false ;
100706: LD_ADDR_VAR 0 1
100710: PUSH
100711: LD_INT 0
100713: ST_TO_ADDR
// for i := 1 to 16 do
100714: LD_ADDR_VAR 0 2
100718: PUSH
100719: DOUBLE
100720: LD_INT 1
100722: DEC
100723: ST_TO_ADDR
100724: LD_INT 16
100726: PUSH
100727: FOR_TO
100728: IFFALSE 100927
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100730: LD_ADDR_VAR 0 3
100734: PUSH
100735: LD_INT 10
100737: PUSH
100738: LD_INT 20
100740: PUSH
100741: LD_INT 30
100743: PUSH
100744: LD_INT 40
100746: PUSH
100747: LD_INT 50
100749: PUSH
100750: LD_INT 60
100752: PUSH
100753: LD_INT 70
100755: PUSH
100756: LD_INT 80
100758: PUSH
100759: LD_INT 90
100761: PUSH
100762: LD_INT 100
100764: PUSH
100765: LD_INT 110
100767: PUSH
100768: LD_INT 120
100770: PUSH
100771: LD_INT 130
100773: PUSH
100774: LD_INT 140
100776: PUSH
100777: LD_INT 150
100779: PUSH
100780: EMPTY
100781: LIST
100782: LIST
100783: LIST
100784: LIST
100785: LIST
100786: LIST
100787: LIST
100788: LIST
100789: LIST
100790: LIST
100791: LIST
100792: LIST
100793: LIST
100794: LIST
100795: LIST
100796: PUSH
100797: LD_INT 1
100799: PPUSH
100800: LD_INT 15
100802: PPUSH
100803: CALL_OW 12
100807: ARRAY
100808: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100809: LD_ADDR_VAR 0 4
100813: PUSH
100814: LD_INT 10
100816: PUSH
100817: LD_INT 20
100819: PUSH
100820: LD_INT 30
100822: PUSH
100823: LD_INT 40
100825: PUSH
100826: LD_INT 50
100828: PUSH
100829: LD_INT 60
100831: PUSH
100832: LD_INT 70
100834: PUSH
100835: LD_INT 80
100837: PUSH
100838: LD_INT 90
100840: PUSH
100841: LD_INT 100
100843: PUSH
100844: LD_INT 110
100846: PUSH
100847: LD_INT 120
100849: PUSH
100850: LD_INT 130
100852: PUSH
100853: LD_INT 140
100855: PUSH
100856: LD_INT 150
100858: PUSH
100859: EMPTY
100860: LIST
100861: LIST
100862: LIST
100863: LIST
100864: LIST
100865: LIST
100866: LIST
100867: LIST
100868: LIST
100869: LIST
100870: LIST
100871: LIST
100872: LIST
100873: LIST
100874: LIST
100875: PUSH
100876: LD_INT 1
100878: PPUSH
100879: LD_INT 15
100881: PPUSH
100882: CALL_OW 12
100886: ARRAY
100887: ST_TO_ADDR
// if ValidHex ( x , y ) then
100888: LD_VAR 0 3
100892: PPUSH
100893: LD_VAR 0 4
100897: PPUSH
100898: CALL_OW 488
100902: IFFALSE 100925
// begin result := [ x , y ] ;
100904: LD_ADDR_VAR 0 1
100908: PUSH
100909: LD_VAR 0 3
100913: PUSH
100914: LD_VAR 0 4
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: ST_TO_ADDR
// break ;
100923: GO 100927
// end ; end ;
100925: GO 100727
100927: POP
100928: POP
// if result then
100929: LD_VAR 0 1
100933: IFFALSE 100993
// begin ToLua ( playSibBomb() ) ;
100935: LD_STRING playSibBomb()
100937: PPUSH
100938: CALL_OW 559
// wait ( 0 0$14 ) ;
100942: LD_INT 490
100944: PPUSH
100945: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100949: LD_VAR 0 1
100953: PUSH
100954: LD_INT 1
100956: ARRAY
100957: PPUSH
100958: LD_VAR 0 1
100962: PUSH
100963: LD_INT 2
100965: ARRAY
100966: PPUSH
100967: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100971: LD_VAR 0 1
100975: PUSH
100976: LD_INT 1
100978: ARRAY
100979: PPUSH
100980: LD_VAR 0 1
100984: PUSH
100985: LD_INT 2
100987: ARRAY
100988: PPUSH
100989: CALL_OW 429
// end ; end ;
100993: LD_VAR 0 1
100997: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100998: LD_EXP 120
101002: PUSH
101003: LD_EXP 142
101007: AND
101008: IFFALSE 101020
101010: GO 101012
101012: DISABLE
// YouLost (  ) ;
101013: LD_STRING 
101015: PPUSH
101016: CALL_OW 104
101020: END
// every 0 0$1 trigger StreamModeActive and sFog do
101021: LD_EXP 120
101025: PUSH
101026: LD_EXP 141
101030: AND
101031: IFFALSE 101045
101033: GO 101035
101035: DISABLE
// FogOff ( your_side ) ;
101036: LD_OWVAR 2
101040: PPUSH
101041: CALL_OW 344
101045: END
// every 0 0$1 trigger StreamModeActive and sSun do
101046: LD_EXP 120
101050: PUSH
101051: LD_EXP 143
101055: AND
101056: IFFALSE 101084
101058: GO 101060
101060: DISABLE
// begin solar_recharge_percent := 0 ;
101061: LD_ADDR_OWVAR 79
101065: PUSH
101066: LD_INT 0
101068: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101069: LD_INT 10500
101071: PPUSH
101072: CALL_OW 67
// solar_recharge_percent := 100 ;
101076: LD_ADDR_OWVAR 79
101080: PUSH
101081: LD_INT 100
101083: ST_TO_ADDR
// end ;
101084: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101085: LD_EXP 120
101089: PUSH
101090: LD_EXP 144
101094: AND
101095: IFFALSE 101334
101097: GO 101099
101099: DISABLE
101100: LD_INT 0
101102: PPUSH
101103: PPUSH
101104: PPUSH
// begin tmp := [ ] ;
101105: LD_ADDR_VAR 0 3
101109: PUSH
101110: EMPTY
101111: ST_TO_ADDR
// for i := 1 to 6 do
101112: LD_ADDR_VAR 0 1
101116: PUSH
101117: DOUBLE
101118: LD_INT 1
101120: DEC
101121: ST_TO_ADDR
101122: LD_INT 6
101124: PUSH
101125: FOR_TO
101126: IFFALSE 101231
// begin uc_nation := nation_nature ;
101128: LD_ADDR_OWVAR 21
101132: PUSH
101133: LD_INT 0
101135: ST_TO_ADDR
// uc_side := 0 ;
101136: LD_ADDR_OWVAR 20
101140: PUSH
101141: LD_INT 0
101143: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101144: LD_ADDR_OWVAR 29
101148: PUSH
101149: LD_INT 12
101151: PUSH
101152: LD_INT 12
101154: PUSH
101155: EMPTY
101156: LIST
101157: LIST
101158: ST_TO_ADDR
// hc_agressivity := 20 ;
101159: LD_ADDR_OWVAR 35
101163: PUSH
101164: LD_INT 20
101166: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
101167: LD_ADDR_OWVAR 28
101171: PUSH
101172: LD_INT 17
101174: ST_TO_ADDR
// hc_gallery :=  ;
101175: LD_ADDR_OWVAR 33
101179: PUSH
101180: LD_STRING 
101182: ST_TO_ADDR
// hc_name :=  ;
101183: LD_ADDR_OWVAR 26
101187: PUSH
101188: LD_STRING 
101190: ST_TO_ADDR
// un := CreateHuman ;
101191: LD_ADDR_VAR 0 2
101195: PUSH
101196: CALL_OW 44
101200: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
101201: LD_VAR 0 2
101205: PPUSH
101206: LD_INT 1
101208: PPUSH
101209: CALL_OW 51
// tmp := tmp ^ un ;
101213: LD_ADDR_VAR 0 3
101217: PUSH
101218: LD_VAR 0 3
101222: PUSH
101223: LD_VAR 0 2
101227: ADD
101228: ST_TO_ADDR
// end ;
101229: GO 101125
101231: POP
101232: POP
// repeat wait ( 0 0$1 ) ;
101233: LD_INT 35
101235: PPUSH
101236: CALL_OW 67
// for un in tmp do
101240: LD_ADDR_VAR 0 2
101244: PUSH
101245: LD_VAR 0 3
101249: PUSH
101250: FOR_IN
101251: IFFALSE 101325
// begin if IsDead ( un ) then
101253: LD_VAR 0 2
101257: PPUSH
101258: CALL_OW 301
101262: IFFALSE 101282
// begin tmp := tmp diff un ;
101264: LD_ADDR_VAR 0 3
101268: PUSH
101269: LD_VAR 0 3
101273: PUSH
101274: LD_VAR 0 2
101278: DIFF
101279: ST_TO_ADDR
// continue ;
101280: GO 101250
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
101282: LD_VAR 0 2
101286: PPUSH
101287: LD_INT 3
101289: PUSH
101290: LD_INT 22
101292: PUSH
101293: LD_INT 0
101295: PUSH
101296: EMPTY
101297: LIST
101298: LIST
101299: PUSH
101300: EMPTY
101301: LIST
101302: LIST
101303: PPUSH
101304: CALL_OW 69
101308: PPUSH
101309: LD_VAR 0 2
101313: PPUSH
101314: CALL_OW 74
101318: PPUSH
101319: CALL_OW 115
// end ;
101323: GO 101250
101325: POP
101326: POP
// until not tmp ;
101327: LD_VAR 0 3
101331: NOT
101332: IFFALSE 101233
// end ;
101334: PPOPN 3
101336: END
// every 0 0$1 trigger StreamModeActive and sTroll do
101337: LD_EXP 120
101341: PUSH
101342: LD_EXP 145
101346: AND
101347: IFFALSE 101401
101349: GO 101351
101351: DISABLE
// begin ToLua ( displayTroll(); ) ;
101352: LD_STRING displayTroll();
101354: PPUSH
101355: CALL_OW 559
// wait ( 3 3$00 ) ;
101359: LD_INT 6300
101361: PPUSH
101362: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101366: LD_STRING hideTroll();
101368: PPUSH
101369: CALL_OW 559
// wait ( 1 1$00 ) ;
101373: LD_INT 2100
101375: PPUSH
101376: CALL_OW 67
// ToLua ( displayTroll(); ) ;
101380: LD_STRING displayTroll();
101382: PPUSH
101383: CALL_OW 559
// wait ( 1 1$00 ) ;
101387: LD_INT 2100
101389: PPUSH
101390: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101394: LD_STRING hideTroll();
101396: PPUSH
101397: CALL_OW 559
// end ;
101401: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101402: LD_EXP 120
101406: PUSH
101407: LD_EXP 146
101411: AND
101412: IFFALSE 101475
101414: GO 101416
101416: DISABLE
101417: LD_INT 0
101419: PPUSH
// begin p := 0 ;
101420: LD_ADDR_VAR 0 1
101424: PUSH
101425: LD_INT 0
101427: ST_TO_ADDR
// repeat game_speed := 1 ;
101428: LD_ADDR_OWVAR 65
101432: PUSH
101433: LD_INT 1
101435: ST_TO_ADDR
// wait ( 0 0$1 ) ;
101436: LD_INT 35
101438: PPUSH
101439: CALL_OW 67
// p := p + 1 ;
101443: LD_ADDR_VAR 0 1
101447: PUSH
101448: LD_VAR 0 1
101452: PUSH
101453: LD_INT 1
101455: PLUS
101456: ST_TO_ADDR
// until p >= 60 ;
101457: LD_VAR 0 1
101461: PUSH
101462: LD_INT 60
101464: GREATEREQUAL
101465: IFFALSE 101428
// game_speed := 4 ;
101467: LD_ADDR_OWVAR 65
101471: PUSH
101472: LD_INT 4
101474: ST_TO_ADDR
// end ;
101475: PPOPN 1
101477: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101478: LD_EXP 120
101482: PUSH
101483: LD_EXP 147
101487: AND
101488: IFFALSE 101634
101490: GO 101492
101492: DISABLE
101493: LD_INT 0
101495: PPUSH
101496: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101497: LD_ADDR_VAR 0 1
101501: PUSH
101502: LD_INT 22
101504: PUSH
101505: LD_OWVAR 2
101509: PUSH
101510: EMPTY
101511: LIST
101512: LIST
101513: PUSH
101514: LD_INT 2
101516: PUSH
101517: LD_INT 30
101519: PUSH
101520: LD_INT 0
101522: PUSH
101523: EMPTY
101524: LIST
101525: LIST
101526: PUSH
101527: LD_INT 30
101529: PUSH
101530: LD_INT 1
101532: PUSH
101533: EMPTY
101534: LIST
101535: LIST
101536: PUSH
101537: EMPTY
101538: LIST
101539: LIST
101540: LIST
101541: PUSH
101542: EMPTY
101543: LIST
101544: LIST
101545: PPUSH
101546: CALL_OW 69
101550: ST_TO_ADDR
// if not depot then
101551: LD_VAR 0 1
101555: NOT
101556: IFFALSE 101560
// exit ;
101558: GO 101634
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
101560: LD_ADDR_VAR 0 2
101564: PUSH
101565: LD_VAR 0 1
101569: PUSH
101570: LD_INT 1
101572: PPUSH
101573: LD_VAR 0 1
101577: PPUSH
101578: CALL_OW 12
101582: ARRAY
101583: PPUSH
101584: CALL_OW 274
101588: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
101589: LD_VAR 0 2
101593: PPUSH
101594: LD_INT 1
101596: PPUSH
101597: LD_INT 0
101599: PPUSH
101600: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
101604: LD_VAR 0 2
101608: PPUSH
101609: LD_INT 2
101611: PPUSH
101612: LD_INT 0
101614: PPUSH
101615: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
101619: LD_VAR 0 2
101623: PPUSH
101624: LD_INT 3
101626: PPUSH
101627: LD_INT 0
101629: PPUSH
101630: CALL_OW 277
// end ;
101634: PPOPN 2
101636: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
101637: LD_EXP 120
101641: PUSH
101642: LD_EXP 148
101646: AND
101647: IFFALSE 101744
101649: GO 101651
101651: DISABLE
101652: LD_INT 0
101654: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101655: LD_ADDR_VAR 0 1
101659: PUSH
101660: LD_INT 22
101662: PUSH
101663: LD_OWVAR 2
101667: PUSH
101668: EMPTY
101669: LIST
101670: LIST
101671: PUSH
101672: LD_INT 21
101674: PUSH
101675: LD_INT 1
101677: PUSH
101678: EMPTY
101679: LIST
101680: LIST
101681: PUSH
101682: LD_INT 3
101684: PUSH
101685: LD_INT 23
101687: PUSH
101688: LD_INT 0
101690: PUSH
101691: EMPTY
101692: LIST
101693: LIST
101694: PUSH
101695: EMPTY
101696: LIST
101697: LIST
101698: PUSH
101699: EMPTY
101700: LIST
101701: LIST
101702: LIST
101703: PPUSH
101704: CALL_OW 69
101708: ST_TO_ADDR
// if not tmp then
101709: LD_VAR 0 1
101713: NOT
101714: IFFALSE 101718
// exit ;
101716: GO 101744
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
101718: LD_VAR 0 1
101722: PUSH
101723: LD_INT 1
101725: PPUSH
101726: LD_VAR 0 1
101730: PPUSH
101731: CALL_OW 12
101735: ARRAY
101736: PPUSH
101737: LD_INT 200
101739: PPUSH
101740: CALL_OW 234
// end ;
101744: PPOPN 1
101746: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
101747: LD_EXP 120
101751: PUSH
101752: LD_EXP 149
101756: AND
101757: IFFALSE 101836
101759: GO 101761
101761: DISABLE
101762: LD_INT 0
101764: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101765: LD_ADDR_VAR 0 1
101769: PUSH
101770: LD_INT 22
101772: PUSH
101773: LD_OWVAR 2
101777: PUSH
101778: EMPTY
101779: LIST
101780: LIST
101781: PUSH
101782: LD_INT 21
101784: PUSH
101785: LD_INT 2
101787: PUSH
101788: EMPTY
101789: LIST
101790: LIST
101791: PUSH
101792: EMPTY
101793: LIST
101794: LIST
101795: PPUSH
101796: CALL_OW 69
101800: ST_TO_ADDR
// if not tmp then
101801: LD_VAR 0 1
101805: NOT
101806: IFFALSE 101810
// exit ;
101808: GO 101836
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101810: LD_VAR 0 1
101814: PUSH
101815: LD_INT 1
101817: PPUSH
101818: LD_VAR 0 1
101822: PPUSH
101823: CALL_OW 12
101827: ARRAY
101828: PPUSH
101829: LD_INT 60
101831: PPUSH
101832: CALL_OW 234
// end ;
101836: PPOPN 1
101838: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101839: LD_EXP 120
101843: PUSH
101844: LD_EXP 150
101848: AND
101849: IFFALSE 101948
101851: GO 101853
101853: DISABLE
101854: LD_INT 0
101856: PPUSH
101857: PPUSH
// begin enable ;
101858: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101859: LD_ADDR_VAR 0 1
101863: PUSH
101864: LD_INT 22
101866: PUSH
101867: LD_OWVAR 2
101871: PUSH
101872: EMPTY
101873: LIST
101874: LIST
101875: PUSH
101876: LD_INT 61
101878: PUSH
101879: EMPTY
101880: LIST
101881: PUSH
101882: LD_INT 33
101884: PUSH
101885: LD_INT 2
101887: PUSH
101888: EMPTY
101889: LIST
101890: LIST
101891: PUSH
101892: EMPTY
101893: LIST
101894: LIST
101895: LIST
101896: PPUSH
101897: CALL_OW 69
101901: ST_TO_ADDR
// if not tmp then
101902: LD_VAR 0 1
101906: NOT
101907: IFFALSE 101911
// exit ;
101909: GO 101948
// for i in tmp do
101911: LD_ADDR_VAR 0 2
101915: PUSH
101916: LD_VAR 0 1
101920: PUSH
101921: FOR_IN
101922: IFFALSE 101946
// if IsControledBy ( i ) then
101924: LD_VAR 0 2
101928: PPUSH
101929: CALL_OW 312
101933: IFFALSE 101944
// ComUnlink ( i ) ;
101935: LD_VAR 0 2
101939: PPUSH
101940: CALL_OW 136
101944: GO 101921
101946: POP
101947: POP
// end ;
101948: PPOPN 2
101950: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101951: LD_EXP 120
101955: PUSH
101956: LD_EXP 151
101960: AND
101961: IFFALSE 102101
101963: GO 101965
101965: DISABLE
101966: LD_INT 0
101968: PPUSH
101969: PPUSH
// begin ToLua ( displayPowell(); ) ;
101970: LD_STRING displayPowell();
101972: PPUSH
101973: CALL_OW 559
// uc_side := 0 ;
101977: LD_ADDR_OWVAR 20
101981: PUSH
101982: LD_INT 0
101984: ST_TO_ADDR
// uc_nation := 2 ;
101985: LD_ADDR_OWVAR 21
101989: PUSH
101990: LD_INT 2
101992: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101993: LD_ADDR_OWVAR 37
101997: PUSH
101998: LD_INT 14
102000: ST_TO_ADDR
// vc_engine := engine_siberite ;
102001: LD_ADDR_OWVAR 39
102005: PUSH
102006: LD_INT 3
102008: ST_TO_ADDR
// vc_control := control_apeman ;
102009: LD_ADDR_OWVAR 38
102013: PUSH
102014: LD_INT 5
102016: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102017: LD_ADDR_OWVAR 40
102021: PUSH
102022: LD_INT 29
102024: ST_TO_ADDR
// un := CreateVehicle ;
102025: LD_ADDR_VAR 0 2
102029: PUSH
102030: CALL_OW 45
102034: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102035: LD_VAR 0 2
102039: PPUSH
102040: LD_INT 1
102042: PPUSH
102043: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102047: LD_INT 35
102049: PPUSH
102050: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102054: LD_VAR 0 2
102058: PPUSH
102059: LD_INT 22
102061: PUSH
102062: LD_OWVAR 2
102066: PUSH
102067: EMPTY
102068: LIST
102069: LIST
102070: PPUSH
102071: CALL_OW 69
102075: PPUSH
102076: LD_VAR 0 2
102080: PPUSH
102081: CALL_OW 74
102085: PPUSH
102086: CALL_OW 115
// until IsDead ( un ) ;
102090: LD_VAR 0 2
102094: PPUSH
102095: CALL_OW 301
102099: IFFALSE 102047
// end ;
102101: PPOPN 2
102103: END
// every 0 0$1 trigger StreamModeActive and sStu do
102104: LD_EXP 120
102108: PUSH
102109: LD_EXP 159
102113: AND
102114: IFFALSE 102130
102116: GO 102118
102118: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102119: LD_STRING displayStucuk();
102121: PPUSH
102122: CALL_OW 559
// ResetFog ;
102126: CALL_OW 335
// end ;
102130: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102131: LD_EXP 120
102135: PUSH
102136: LD_EXP 152
102140: AND
102141: IFFALSE 102282
102143: GO 102145
102145: DISABLE
102146: LD_INT 0
102148: PPUSH
102149: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102150: LD_ADDR_VAR 0 2
102154: PUSH
102155: LD_INT 22
102157: PUSH
102158: LD_OWVAR 2
102162: PUSH
102163: EMPTY
102164: LIST
102165: LIST
102166: PUSH
102167: LD_INT 21
102169: PUSH
102170: LD_INT 1
102172: PUSH
102173: EMPTY
102174: LIST
102175: LIST
102176: PUSH
102177: EMPTY
102178: LIST
102179: LIST
102180: PPUSH
102181: CALL_OW 69
102185: ST_TO_ADDR
// if not tmp then
102186: LD_VAR 0 2
102190: NOT
102191: IFFALSE 102195
// exit ;
102193: GO 102282
// un := tmp [ rand ( 1 , tmp ) ] ;
102195: LD_ADDR_VAR 0 1
102199: PUSH
102200: LD_VAR 0 2
102204: PUSH
102205: LD_INT 1
102207: PPUSH
102208: LD_VAR 0 2
102212: PPUSH
102213: CALL_OW 12
102217: ARRAY
102218: ST_TO_ADDR
// SetSide ( un , 0 ) ;
102219: LD_VAR 0 1
102223: PPUSH
102224: LD_INT 0
102226: PPUSH
102227: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
102231: LD_VAR 0 1
102235: PPUSH
102236: LD_OWVAR 3
102240: PUSH
102241: LD_VAR 0 1
102245: DIFF
102246: PPUSH
102247: LD_VAR 0 1
102251: PPUSH
102252: CALL_OW 74
102256: PPUSH
102257: CALL_OW 115
// wait ( 0 0$20 ) ;
102261: LD_INT 700
102263: PPUSH
102264: CALL_OW 67
// SetSide ( un , your_side ) ;
102268: LD_VAR 0 1
102272: PPUSH
102273: LD_OWVAR 2
102277: PPUSH
102278: CALL_OW 235
// end ;
102282: PPOPN 2
102284: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
102285: LD_EXP 120
102289: PUSH
102290: LD_EXP 153
102294: AND
102295: IFFALSE 102401
102297: GO 102299
102299: DISABLE
102300: LD_INT 0
102302: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102303: LD_ADDR_VAR 0 1
102307: PUSH
102308: LD_INT 22
102310: PUSH
102311: LD_OWVAR 2
102315: PUSH
102316: EMPTY
102317: LIST
102318: LIST
102319: PUSH
102320: LD_INT 2
102322: PUSH
102323: LD_INT 30
102325: PUSH
102326: LD_INT 0
102328: PUSH
102329: EMPTY
102330: LIST
102331: LIST
102332: PUSH
102333: LD_INT 30
102335: PUSH
102336: LD_INT 1
102338: PUSH
102339: EMPTY
102340: LIST
102341: LIST
102342: PUSH
102343: EMPTY
102344: LIST
102345: LIST
102346: LIST
102347: PUSH
102348: EMPTY
102349: LIST
102350: LIST
102351: PPUSH
102352: CALL_OW 69
102356: ST_TO_ADDR
// if not depot then
102357: LD_VAR 0 1
102361: NOT
102362: IFFALSE 102366
// exit ;
102364: GO 102401
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
102366: LD_VAR 0 1
102370: PUSH
102371: LD_INT 1
102373: ARRAY
102374: PPUSH
102375: CALL_OW 250
102379: PPUSH
102380: LD_VAR 0 1
102384: PUSH
102385: LD_INT 1
102387: ARRAY
102388: PPUSH
102389: CALL_OW 251
102393: PPUSH
102394: LD_INT 70
102396: PPUSH
102397: CALL_OW 495
// end ;
102401: PPOPN 1
102403: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102404: LD_EXP 120
102408: PUSH
102409: LD_EXP 154
102413: AND
102414: IFFALSE 102625
102416: GO 102418
102418: DISABLE
102419: LD_INT 0
102421: PPUSH
102422: PPUSH
102423: PPUSH
102424: PPUSH
102425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102426: LD_ADDR_VAR 0 5
102430: PUSH
102431: LD_INT 22
102433: PUSH
102434: LD_OWVAR 2
102438: PUSH
102439: EMPTY
102440: LIST
102441: LIST
102442: PUSH
102443: LD_INT 21
102445: PUSH
102446: LD_INT 1
102448: PUSH
102449: EMPTY
102450: LIST
102451: LIST
102452: PUSH
102453: EMPTY
102454: LIST
102455: LIST
102456: PPUSH
102457: CALL_OW 69
102461: ST_TO_ADDR
// if not tmp then
102462: LD_VAR 0 5
102466: NOT
102467: IFFALSE 102471
// exit ;
102469: GO 102625
// for i in tmp do
102471: LD_ADDR_VAR 0 1
102475: PUSH
102476: LD_VAR 0 5
102480: PUSH
102481: FOR_IN
102482: IFFALSE 102623
// begin d := rand ( 0 , 5 ) ;
102484: LD_ADDR_VAR 0 4
102488: PUSH
102489: LD_INT 0
102491: PPUSH
102492: LD_INT 5
102494: PPUSH
102495: CALL_OW 12
102499: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
102500: LD_ADDR_VAR 0 2
102504: PUSH
102505: LD_VAR 0 1
102509: PPUSH
102510: CALL_OW 250
102514: PPUSH
102515: LD_VAR 0 4
102519: PPUSH
102520: LD_INT 3
102522: PPUSH
102523: LD_INT 12
102525: PPUSH
102526: CALL_OW 12
102530: PPUSH
102531: CALL_OW 272
102535: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102536: LD_ADDR_VAR 0 3
102540: PUSH
102541: LD_VAR 0 1
102545: PPUSH
102546: CALL_OW 251
102550: PPUSH
102551: LD_VAR 0 4
102555: PPUSH
102556: LD_INT 3
102558: PPUSH
102559: LD_INT 12
102561: PPUSH
102562: CALL_OW 12
102566: PPUSH
102567: CALL_OW 273
102571: ST_TO_ADDR
// if ValidHex ( x , y ) then
102572: LD_VAR 0 2
102576: PPUSH
102577: LD_VAR 0 3
102581: PPUSH
102582: CALL_OW 488
102586: IFFALSE 102621
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
102588: LD_VAR 0 1
102592: PPUSH
102593: LD_VAR 0 2
102597: PPUSH
102598: LD_VAR 0 3
102602: PPUSH
102603: LD_INT 3
102605: PPUSH
102606: LD_INT 6
102608: PPUSH
102609: CALL_OW 12
102613: PPUSH
102614: LD_INT 1
102616: PPUSH
102617: CALL_OW 483
// end ;
102621: GO 102481
102623: POP
102624: POP
// end ;
102625: PPOPN 5
102627: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
102628: LD_EXP 120
102632: PUSH
102633: LD_EXP 155
102637: AND
102638: IFFALSE 102732
102640: GO 102642
102642: DISABLE
102643: LD_INT 0
102645: PPUSH
102646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
102647: LD_ADDR_VAR 0 2
102651: PUSH
102652: LD_INT 22
102654: PUSH
102655: LD_OWVAR 2
102659: PUSH
102660: EMPTY
102661: LIST
102662: LIST
102663: PUSH
102664: LD_INT 32
102666: PUSH
102667: LD_INT 1
102669: PUSH
102670: EMPTY
102671: LIST
102672: LIST
102673: PUSH
102674: LD_INT 21
102676: PUSH
102677: LD_INT 2
102679: PUSH
102680: EMPTY
102681: LIST
102682: LIST
102683: PUSH
102684: EMPTY
102685: LIST
102686: LIST
102687: LIST
102688: PPUSH
102689: CALL_OW 69
102693: ST_TO_ADDR
// if not tmp then
102694: LD_VAR 0 2
102698: NOT
102699: IFFALSE 102703
// exit ;
102701: GO 102732
// for i in tmp do
102703: LD_ADDR_VAR 0 1
102707: PUSH
102708: LD_VAR 0 2
102712: PUSH
102713: FOR_IN
102714: IFFALSE 102730
// SetFuel ( i , 0 ) ;
102716: LD_VAR 0 1
102720: PPUSH
102721: LD_INT 0
102723: PPUSH
102724: CALL_OW 240
102728: GO 102713
102730: POP
102731: POP
// end ;
102732: PPOPN 2
102734: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
102735: LD_EXP 120
102739: PUSH
102740: LD_EXP 156
102744: AND
102745: IFFALSE 102811
102747: GO 102749
102749: DISABLE
102750: LD_INT 0
102752: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102753: LD_ADDR_VAR 0 1
102757: PUSH
102758: LD_INT 22
102760: PUSH
102761: LD_OWVAR 2
102765: PUSH
102766: EMPTY
102767: LIST
102768: LIST
102769: PUSH
102770: LD_INT 30
102772: PUSH
102773: LD_INT 29
102775: PUSH
102776: EMPTY
102777: LIST
102778: LIST
102779: PUSH
102780: EMPTY
102781: LIST
102782: LIST
102783: PPUSH
102784: CALL_OW 69
102788: ST_TO_ADDR
// if not tmp then
102789: LD_VAR 0 1
102793: NOT
102794: IFFALSE 102798
// exit ;
102796: GO 102811
// DestroyUnit ( tmp [ 1 ] ) ;
102798: LD_VAR 0 1
102802: PUSH
102803: LD_INT 1
102805: ARRAY
102806: PPUSH
102807: CALL_OW 65
// end ;
102811: PPOPN 1
102813: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102814: LD_EXP 120
102818: PUSH
102819: LD_EXP 158
102823: AND
102824: IFFALSE 102953
102826: GO 102828
102828: DISABLE
102829: LD_INT 0
102831: PPUSH
// begin uc_side := 0 ;
102832: LD_ADDR_OWVAR 20
102836: PUSH
102837: LD_INT 0
102839: ST_TO_ADDR
// uc_nation := nation_arabian ;
102840: LD_ADDR_OWVAR 21
102844: PUSH
102845: LD_INT 2
102847: ST_TO_ADDR
// hc_gallery :=  ;
102848: LD_ADDR_OWVAR 33
102852: PUSH
102853: LD_STRING 
102855: ST_TO_ADDR
// hc_name :=  ;
102856: LD_ADDR_OWVAR 26
102860: PUSH
102861: LD_STRING 
102863: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102864: LD_INT 1
102866: PPUSH
102867: LD_INT 11
102869: PPUSH
102870: LD_INT 10
102872: PPUSH
102873: CALL_OW 380
// un := CreateHuman ;
102877: LD_ADDR_VAR 0 1
102881: PUSH
102882: CALL_OW 44
102886: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102887: LD_VAR 0 1
102891: PPUSH
102892: LD_INT 1
102894: PPUSH
102895: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102899: LD_INT 35
102901: PPUSH
102902: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102906: LD_VAR 0 1
102910: PPUSH
102911: LD_INT 22
102913: PUSH
102914: LD_OWVAR 2
102918: PUSH
102919: EMPTY
102920: LIST
102921: LIST
102922: PPUSH
102923: CALL_OW 69
102927: PPUSH
102928: LD_VAR 0 1
102932: PPUSH
102933: CALL_OW 74
102937: PPUSH
102938: CALL_OW 115
// until IsDead ( un ) ;
102942: LD_VAR 0 1
102946: PPUSH
102947: CALL_OW 301
102951: IFFALSE 102899
// end ;
102953: PPOPN 1
102955: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102956: LD_EXP 120
102960: PUSH
102961: LD_EXP 160
102965: AND
102966: IFFALSE 102978
102968: GO 102970
102970: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102971: LD_STRING earthquake(getX(game), 0, 32)
102973: PPUSH
102974: CALL_OW 559
102978: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102979: LD_EXP 120
102983: PUSH
102984: LD_EXP 161
102988: AND
102989: IFFALSE 103080
102991: GO 102993
102993: DISABLE
102994: LD_INT 0
102996: PPUSH
// begin enable ;
102997: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102998: LD_ADDR_VAR 0 1
103002: PUSH
103003: LD_INT 22
103005: PUSH
103006: LD_OWVAR 2
103010: PUSH
103011: EMPTY
103012: LIST
103013: LIST
103014: PUSH
103015: LD_INT 21
103017: PUSH
103018: LD_INT 2
103020: PUSH
103021: EMPTY
103022: LIST
103023: LIST
103024: PUSH
103025: LD_INT 33
103027: PUSH
103028: LD_INT 3
103030: PUSH
103031: EMPTY
103032: LIST
103033: LIST
103034: PUSH
103035: EMPTY
103036: LIST
103037: LIST
103038: LIST
103039: PPUSH
103040: CALL_OW 69
103044: ST_TO_ADDR
// if not tmp then
103045: LD_VAR 0 1
103049: NOT
103050: IFFALSE 103054
// exit ;
103052: GO 103080
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103054: LD_VAR 0 1
103058: PUSH
103059: LD_INT 1
103061: PPUSH
103062: LD_VAR 0 1
103066: PPUSH
103067: CALL_OW 12
103071: ARRAY
103072: PPUSH
103073: LD_INT 1
103075: PPUSH
103076: CALL_OW 234
// end ;
103080: PPOPN 1
103082: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103083: LD_EXP 120
103087: PUSH
103088: LD_EXP 162
103092: AND
103093: IFFALSE 103234
103095: GO 103097
103097: DISABLE
103098: LD_INT 0
103100: PPUSH
103101: PPUSH
103102: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103103: LD_ADDR_VAR 0 3
103107: PUSH
103108: LD_INT 22
103110: PUSH
103111: LD_OWVAR 2
103115: PUSH
103116: EMPTY
103117: LIST
103118: LIST
103119: PUSH
103120: LD_INT 25
103122: PUSH
103123: LD_INT 1
103125: PUSH
103126: EMPTY
103127: LIST
103128: LIST
103129: PUSH
103130: EMPTY
103131: LIST
103132: LIST
103133: PPUSH
103134: CALL_OW 69
103138: ST_TO_ADDR
// if not tmp then
103139: LD_VAR 0 3
103143: NOT
103144: IFFALSE 103148
// exit ;
103146: GO 103234
// un := tmp [ rand ( 1 , tmp ) ] ;
103148: LD_ADDR_VAR 0 2
103152: PUSH
103153: LD_VAR 0 3
103157: PUSH
103158: LD_INT 1
103160: PPUSH
103161: LD_VAR 0 3
103165: PPUSH
103166: CALL_OW 12
103170: ARRAY
103171: ST_TO_ADDR
// if Crawls ( un ) then
103172: LD_VAR 0 2
103176: PPUSH
103177: CALL_OW 318
103181: IFFALSE 103192
// ComWalk ( un ) ;
103183: LD_VAR 0 2
103187: PPUSH
103188: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
103192: LD_VAR 0 2
103196: PPUSH
103197: LD_INT 9
103199: PPUSH
103200: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
103204: LD_INT 28
103206: PPUSH
103207: LD_OWVAR 2
103211: PPUSH
103212: LD_INT 2
103214: PPUSH
103215: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
103219: LD_INT 29
103221: PPUSH
103222: LD_OWVAR 2
103226: PPUSH
103227: LD_INT 2
103229: PPUSH
103230: CALL_OW 322
// end ;
103234: PPOPN 3
103236: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
103237: LD_EXP 120
103241: PUSH
103242: LD_EXP 163
103246: AND
103247: IFFALSE 103358
103249: GO 103251
103251: DISABLE
103252: LD_INT 0
103254: PPUSH
103255: PPUSH
103256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103257: LD_ADDR_VAR 0 3
103261: PUSH
103262: LD_INT 22
103264: PUSH
103265: LD_OWVAR 2
103269: PUSH
103270: EMPTY
103271: LIST
103272: LIST
103273: PUSH
103274: LD_INT 25
103276: PUSH
103277: LD_INT 1
103279: PUSH
103280: EMPTY
103281: LIST
103282: LIST
103283: PUSH
103284: EMPTY
103285: LIST
103286: LIST
103287: PPUSH
103288: CALL_OW 69
103292: ST_TO_ADDR
// if not tmp then
103293: LD_VAR 0 3
103297: NOT
103298: IFFALSE 103302
// exit ;
103300: GO 103358
// un := tmp [ rand ( 1 , tmp ) ] ;
103302: LD_ADDR_VAR 0 2
103306: PUSH
103307: LD_VAR 0 3
103311: PUSH
103312: LD_INT 1
103314: PPUSH
103315: LD_VAR 0 3
103319: PPUSH
103320: CALL_OW 12
103324: ARRAY
103325: ST_TO_ADDR
// if Crawls ( un ) then
103326: LD_VAR 0 2
103330: PPUSH
103331: CALL_OW 318
103335: IFFALSE 103346
// ComWalk ( un ) ;
103337: LD_VAR 0 2
103341: PPUSH
103342: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103346: LD_VAR 0 2
103350: PPUSH
103351: LD_INT 8
103353: PPUSH
103354: CALL_OW 336
// end ;
103358: PPOPN 3
103360: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
103361: LD_EXP 120
103365: PUSH
103366: LD_EXP 164
103370: AND
103371: IFFALSE 103515
103373: GO 103375
103375: DISABLE
103376: LD_INT 0
103378: PPUSH
103379: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
103380: LD_ADDR_VAR 0 2
103384: PUSH
103385: LD_INT 22
103387: PUSH
103388: LD_OWVAR 2
103392: PUSH
103393: EMPTY
103394: LIST
103395: LIST
103396: PUSH
103397: LD_INT 21
103399: PUSH
103400: LD_INT 2
103402: PUSH
103403: EMPTY
103404: LIST
103405: LIST
103406: PUSH
103407: LD_INT 2
103409: PUSH
103410: LD_INT 34
103412: PUSH
103413: LD_INT 12
103415: PUSH
103416: EMPTY
103417: LIST
103418: LIST
103419: PUSH
103420: LD_INT 34
103422: PUSH
103423: LD_INT 51
103425: PUSH
103426: EMPTY
103427: LIST
103428: LIST
103429: PUSH
103430: LD_INT 34
103432: PUSH
103433: LD_INT 32
103435: PUSH
103436: EMPTY
103437: LIST
103438: LIST
103439: PUSH
103440: EMPTY
103441: LIST
103442: LIST
103443: LIST
103444: LIST
103445: PUSH
103446: EMPTY
103447: LIST
103448: LIST
103449: LIST
103450: PPUSH
103451: CALL_OW 69
103455: ST_TO_ADDR
// if not tmp then
103456: LD_VAR 0 2
103460: NOT
103461: IFFALSE 103465
// exit ;
103463: GO 103515
// for i in tmp do
103465: LD_ADDR_VAR 0 1
103469: PUSH
103470: LD_VAR 0 2
103474: PUSH
103475: FOR_IN
103476: IFFALSE 103513
// if GetCargo ( i , mat_artifact ) = 0 then
103478: LD_VAR 0 1
103482: PPUSH
103483: LD_INT 4
103485: PPUSH
103486: CALL_OW 289
103490: PUSH
103491: LD_INT 0
103493: EQUAL
103494: IFFALSE 103511
// SetCargo ( i , mat_siberit , 100 ) ;
103496: LD_VAR 0 1
103500: PPUSH
103501: LD_INT 3
103503: PPUSH
103504: LD_INT 100
103506: PPUSH
103507: CALL_OW 290
103511: GO 103475
103513: POP
103514: POP
// end ;
103515: PPOPN 2
103517: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103518: LD_EXP 120
103522: PUSH
103523: LD_EXP 165
103527: AND
103528: IFFALSE 103711
103530: GO 103532
103532: DISABLE
103533: LD_INT 0
103535: PPUSH
103536: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103537: LD_ADDR_VAR 0 2
103541: PUSH
103542: LD_INT 22
103544: PUSH
103545: LD_OWVAR 2
103549: PUSH
103550: EMPTY
103551: LIST
103552: LIST
103553: PPUSH
103554: CALL_OW 69
103558: ST_TO_ADDR
// if not tmp then
103559: LD_VAR 0 2
103563: NOT
103564: IFFALSE 103568
// exit ;
103566: GO 103711
// for i := 1 to 2 do
103568: LD_ADDR_VAR 0 1
103572: PUSH
103573: DOUBLE
103574: LD_INT 1
103576: DEC
103577: ST_TO_ADDR
103578: LD_INT 2
103580: PUSH
103581: FOR_TO
103582: IFFALSE 103709
// begin uc_side := your_side ;
103584: LD_ADDR_OWVAR 20
103588: PUSH
103589: LD_OWVAR 2
103593: ST_TO_ADDR
// uc_nation := nation_american ;
103594: LD_ADDR_OWVAR 21
103598: PUSH
103599: LD_INT 1
103601: ST_TO_ADDR
// vc_chassis := us_morphling ;
103602: LD_ADDR_OWVAR 37
103606: PUSH
103607: LD_INT 5
103609: ST_TO_ADDR
// vc_engine := engine_siberite ;
103610: LD_ADDR_OWVAR 39
103614: PUSH
103615: LD_INT 3
103617: ST_TO_ADDR
// vc_control := control_computer ;
103618: LD_ADDR_OWVAR 38
103622: PUSH
103623: LD_INT 3
103625: ST_TO_ADDR
// vc_weapon := us_double_laser ;
103626: LD_ADDR_OWVAR 40
103630: PUSH
103631: LD_INT 10
103633: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
103634: LD_VAR 0 2
103638: PUSH
103639: LD_INT 1
103641: ARRAY
103642: PPUSH
103643: CALL_OW 310
103647: NOT
103648: IFFALSE 103695
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
103650: CALL_OW 45
103654: PPUSH
103655: LD_VAR 0 2
103659: PUSH
103660: LD_INT 1
103662: ARRAY
103663: PPUSH
103664: CALL_OW 250
103668: PPUSH
103669: LD_VAR 0 2
103673: PUSH
103674: LD_INT 1
103676: ARRAY
103677: PPUSH
103678: CALL_OW 251
103682: PPUSH
103683: LD_INT 12
103685: PPUSH
103686: LD_INT 1
103688: PPUSH
103689: CALL_OW 50
103693: GO 103707
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
103695: CALL_OW 45
103699: PPUSH
103700: LD_INT 1
103702: PPUSH
103703: CALL_OW 51
// end ;
103707: GO 103581
103709: POP
103710: POP
// end ;
103711: PPOPN 2
103713: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
103714: LD_EXP 120
103718: PUSH
103719: LD_EXP 166
103723: AND
103724: IFFALSE 103946
103726: GO 103728
103728: DISABLE
103729: LD_INT 0
103731: PPUSH
103732: PPUSH
103733: PPUSH
103734: PPUSH
103735: PPUSH
103736: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103737: LD_ADDR_VAR 0 6
103741: PUSH
103742: LD_INT 22
103744: PUSH
103745: LD_OWVAR 2
103749: PUSH
103750: EMPTY
103751: LIST
103752: LIST
103753: PUSH
103754: LD_INT 21
103756: PUSH
103757: LD_INT 1
103759: PUSH
103760: EMPTY
103761: LIST
103762: LIST
103763: PUSH
103764: LD_INT 3
103766: PUSH
103767: LD_INT 23
103769: PUSH
103770: LD_INT 0
103772: PUSH
103773: EMPTY
103774: LIST
103775: LIST
103776: PUSH
103777: EMPTY
103778: LIST
103779: LIST
103780: PUSH
103781: EMPTY
103782: LIST
103783: LIST
103784: LIST
103785: PPUSH
103786: CALL_OW 69
103790: ST_TO_ADDR
// if not tmp then
103791: LD_VAR 0 6
103795: NOT
103796: IFFALSE 103800
// exit ;
103798: GO 103946
// s1 := rand ( 1 , 4 ) ;
103800: LD_ADDR_VAR 0 2
103804: PUSH
103805: LD_INT 1
103807: PPUSH
103808: LD_INT 4
103810: PPUSH
103811: CALL_OW 12
103815: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103816: LD_ADDR_VAR 0 4
103820: PUSH
103821: LD_VAR 0 6
103825: PUSH
103826: LD_INT 1
103828: ARRAY
103829: PPUSH
103830: LD_VAR 0 2
103834: PPUSH
103835: CALL_OW 259
103839: ST_TO_ADDR
// if s1 = 1 then
103840: LD_VAR 0 2
103844: PUSH
103845: LD_INT 1
103847: EQUAL
103848: IFFALSE 103868
// s2 := rand ( 2 , 4 ) else
103850: LD_ADDR_VAR 0 3
103854: PUSH
103855: LD_INT 2
103857: PPUSH
103858: LD_INT 4
103860: PPUSH
103861: CALL_OW 12
103865: ST_TO_ADDR
103866: GO 103876
// s2 := 1 ;
103868: LD_ADDR_VAR 0 3
103872: PUSH
103873: LD_INT 1
103875: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103876: LD_ADDR_VAR 0 5
103880: PUSH
103881: LD_VAR 0 6
103885: PUSH
103886: LD_INT 1
103888: ARRAY
103889: PPUSH
103890: LD_VAR 0 3
103894: PPUSH
103895: CALL_OW 259
103899: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103900: LD_VAR 0 6
103904: PUSH
103905: LD_INT 1
103907: ARRAY
103908: PPUSH
103909: LD_VAR 0 2
103913: PPUSH
103914: LD_VAR 0 5
103918: PPUSH
103919: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103923: LD_VAR 0 6
103927: PUSH
103928: LD_INT 1
103930: ARRAY
103931: PPUSH
103932: LD_VAR 0 3
103936: PPUSH
103937: LD_VAR 0 4
103941: PPUSH
103942: CALL_OW 237
// end ;
103946: PPOPN 6
103948: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103949: LD_EXP 120
103953: PUSH
103954: LD_EXP 167
103958: AND
103959: IFFALSE 104038
103961: GO 103963
103963: DISABLE
103964: LD_INT 0
103966: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103967: LD_ADDR_VAR 0 1
103971: PUSH
103972: LD_INT 22
103974: PUSH
103975: LD_OWVAR 2
103979: PUSH
103980: EMPTY
103981: LIST
103982: LIST
103983: PUSH
103984: LD_INT 30
103986: PUSH
103987: LD_INT 3
103989: PUSH
103990: EMPTY
103991: LIST
103992: LIST
103993: PUSH
103994: EMPTY
103995: LIST
103996: LIST
103997: PPUSH
103998: CALL_OW 69
104002: ST_TO_ADDR
// if not tmp then
104003: LD_VAR 0 1
104007: NOT
104008: IFFALSE 104012
// exit ;
104010: GO 104038
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104012: LD_VAR 0 1
104016: PUSH
104017: LD_INT 1
104019: PPUSH
104020: LD_VAR 0 1
104024: PPUSH
104025: CALL_OW 12
104029: ARRAY
104030: PPUSH
104031: LD_INT 1
104033: PPUSH
104034: CALL_OW 234
// end ;
104038: PPOPN 1
104040: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104041: LD_EXP 120
104045: PUSH
104046: LD_EXP 168
104050: AND
104051: IFFALSE 104163
104053: GO 104055
104055: DISABLE
104056: LD_INT 0
104058: PPUSH
104059: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104060: LD_ADDR_VAR 0 2
104064: PUSH
104065: LD_INT 22
104067: PUSH
104068: LD_OWVAR 2
104072: PUSH
104073: EMPTY
104074: LIST
104075: LIST
104076: PUSH
104077: LD_INT 2
104079: PUSH
104080: LD_INT 30
104082: PUSH
104083: LD_INT 27
104085: PUSH
104086: EMPTY
104087: LIST
104088: LIST
104089: PUSH
104090: LD_INT 30
104092: PUSH
104093: LD_INT 26
104095: PUSH
104096: EMPTY
104097: LIST
104098: LIST
104099: PUSH
104100: LD_INT 30
104102: PUSH
104103: LD_INT 28
104105: PUSH
104106: EMPTY
104107: LIST
104108: LIST
104109: PUSH
104110: EMPTY
104111: LIST
104112: LIST
104113: LIST
104114: LIST
104115: PUSH
104116: EMPTY
104117: LIST
104118: LIST
104119: PPUSH
104120: CALL_OW 69
104124: ST_TO_ADDR
// if not tmp then
104125: LD_VAR 0 2
104129: NOT
104130: IFFALSE 104134
// exit ;
104132: GO 104163
// for i in tmp do
104134: LD_ADDR_VAR 0 1
104138: PUSH
104139: LD_VAR 0 2
104143: PUSH
104144: FOR_IN
104145: IFFALSE 104161
// SetLives ( i , 1 ) ;
104147: LD_VAR 0 1
104151: PPUSH
104152: LD_INT 1
104154: PPUSH
104155: CALL_OW 234
104159: GO 104144
104161: POP
104162: POP
// end ;
104163: PPOPN 2
104165: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
104166: LD_EXP 120
104170: PUSH
104171: LD_EXP 169
104175: AND
104176: IFFALSE 104463
104178: GO 104180
104180: DISABLE
104181: LD_INT 0
104183: PPUSH
104184: PPUSH
104185: PPUSH
// begin i := rand ( 1 , 7 ) ;
104186: LD_ADDR_VAR 0 1
104190: PUSH
104191: LD_INT 1
104193: PPUSH
104194: LD_INT 7
104196: PPUSH
104197: CALL_OW 12
104201: ST_TO_ADDR
// case i of 1 :
104202: LD_VAR 0 1
104206: PUSH
104207: LD_INT 1
104209: DOUBLE
104210: EQUAL
104211: IFTRUE 104215
104213: GO 104225
104215: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
104216: LD_STRING earthquake(getX(game), 0, 32)
104218: PPUSH
104219: CALL_OW 559
104223: GO 104463
104225: LD_INT 2
104227: DOUBLE
104228: EQUAL
104229: IFTRUE 104233
104231: GO 104247
104233: POP
// begin ToLua ( displayStucuk(); ) ;
104234: LD_STRING displayStucuk();
104236: PPUSH
104237: CALL_OW 559
// ResetFog ;
104241: CALL_OW 335
// end ; 3 :
104245: GO 104463
104247: LD_INT 3
104249: DOUBLE
104250: EQUAL
104251: IFTRUE 104255
104253: GO 104359
104255: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104256: LD_ADDR_VAR 0 2
104260: PUSH
104261: LD_INT 22
104263: PUSH
104264: LD_OWVAR 2
104268: PUSH
104269: EMPTY
104270: LIST
104271: LIST
104272: PUSH
104273: LD_INT 25
104275: PUSH
104276: LD_INT 1
104278: PUSH
104279: EMPTY
104280: LIST
104281: LIST
104282: PUSH
104283: EMPTY
104284: LIST
104285: LIST
104286: PPUSH
104287: CALL_OW 69
104291: ST_TO_ADDR
// if not tmp then
104292: LD_VAR 0 2
104296: NOT
104297: IFFALSE 104301
// exit ;
104299: GO 104463
// un := tmp [ rand ( 1 , tmp ) ] ;
104301: LD_ADDR_VAR 0 3
104305: PUSH
104306: LD_VAR 0 2
104310: PUSH
104311: LD_INT 1
104313: PPUSH
104314: LD_VAR 0 2
104318: PPUSH
104319: CALL_OW 12
104323: ARRAY
104324: ST_TO_ADDR
// if Crawls ( un ) then
104325: LD_VAR 0 3
104329: PPUSH
104330: CALL_OW 318
104334: IFFALSE 104345
// ComWalk ( un ) ;
104336: LD_VAR 0 3
104340: PPUSH
104341: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104345: LD_VAR 0 3
104349: PPUSH
104350: LD_INT 8
104352: PPUSH
104353: CALL_OW 336
// end ; 4 :
104357: GO 104463
104359: LD_INT 4
104361: DOUBLE
104362: EQUAL
104363: IFTRUE 104367
104365: GO 104441
104367: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104368: LD_ADDR_VAR 0 2
104372: PUSH
104373: LD_INT 22
104375: PUSH
104376: LD_OWVAR 2
104380: PUSH
104381: EMPTY
104382: LIST
104383: LIST
104384: PUSH
104385: LD_INT 30
104387: PUSH
104388: LD_INT 29
104390: PUSH
104391: EMPTY
104392: LIST
104393: LIST
104394: PUSH
104395: EMPTY
104396: LIST
104397: LIST
104398: PPUSH
104399: CALL_OW 69
104403: ST_TO_ADDR
// if not tmp then
104404: LD_VAR 0 2
104408: NOT
104409: IFFALSE 104413
// exit ;
104411: GO 104463
// CenterNowOnUnits ( tmp [ 1 ] ) ;
104413: LD_VAR 0 2
104417: PUSH
104418: LD_INT 1
104420: ARRAY
104421: PPUSH
104422: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
104426: LD_VAR 0 2
104430: PUSH
104431: LD_INT 1
104433: ARRAY
104434: PPUSH
104435: CALL_OW 65
// end ; 5 .. 7 :
104439: GO 104463
104441: LD_INT 5
104443: DOUBLE
104444: GREATEREQUAL
104445: IFFALSE 104453
104447: LD_INT 7
104449: DOUBLE
104450: LESSEQUAL
104451: IFTRUE 104455
104453: GO 104462
104455: POP
// StreamSibBomb ; end ;
104456: CALL 100700 0 0
104460: GO 104463
104462: POP
// end ;
104463: PPOPN 3
104465: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
104466: LD_EXP 120
104470: PUSH
104471: LD_EXP 170
104475: AND
104476: IFFALSE 104632
104478: GO 104480
104480: DISABLE
104481: LD_INT 0
104483: PPUSH
104484: PPUSH
104485: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
104486: LD_ADDR_VAR 0 2
104490: PUSH
104491: LD_INT 81
104493: PUSH
104494: LD_OWVAR 2
104498: PUSH
104499: EMPTY
104500: LIST
104501: LIST
104502: PUSH
104503: LD_INT 2
104505: PUSH
104506: LD_INT 21
104508: PUSH
104509: LD_INT 1
104511: PUSH
104512: EMPTY
104513: LIST
104514: LIST
104515: PUSH
104516: LD_INT 21
104518: PUSH
104519: LD_INT 2
104521: PUSH
104522: EMPTY
104523: LIST
104524: LIST
104525: PUSH
104526: EMPTY
104527: LIST
104528: LIST
104529: LIST
104530: PUSH
104531: EMPTY
104532: LIST
104533: LIST
104534: PPUSH
104535: CALL_OW 69
104539: ST_TO_ADDR
// if not tmp then
104540: LD_VAR 0 2
104544: NOT
104545: IFFALSE 104549
// exit ;
104547: GO 104632
// p := 0 ;
104549: LD_ADDR_VAR 0 3
104553: PUSH
104554: LD_INT 0
104556: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104557: LD_INT 35
104559: PPUSH
104560: CALL_OW 67
// p := p + 1 ;
104564: LD_ADDR_VAR 0 3
104568: PUSH
104569: LD_VAR 0 3
104573: PUSH
104574: LD_INT 1
104576: PLUS
104577: ST_TO_ADDR
// for i in tmp do
104578: LD_ADDR_VAR 0 1
104582: PUSH
104583: LD_VAR 0 2
104587: PUSH
104588: FOR_IN
104589: IFFALSE 104620
// if GetLives ( i ) < 1000 then
104591: LD_VAR 0 1
104595: PPUSH
104596: CALL_OW 256
104600: PUSH
104601: LD_INT 1000
104603: LESS
104604: IFFALSE 104618
// SetLives ( i , 1000 ) ;
104606: LD_VAR 0 1
104610: PPUSH
104611: LD_INT 1000
104613: PPUSH
104614: CALL_OW 234
104618: GO 104588
104620: POP
104621: POP
// until p > 20 ;
104622: LD_VAR 0 3
104626: PUSH
104627: LD_INT 20
104629: GREATER
104630: IFFALSE 104557
// end ;
104632: PPOPN 3
104634: END
// every 0 0$1 trigger StreamModeActive and sTime do
104635: LD_EXP 120
104639: PUSH
104640: LD_EXP 171
104644: AND
104645: IFFALSE 104680
104647: GO 104649
104649: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
104650: LD_INT 28
104652: PPUSH
104653: LD_OWVAR 2
104657: PPUSH
104658: LD_INT 2
104660: PPUSH
104661: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
104665: LD_INT 30
104667: PPUSH
104668: LD_OWVAR 2
104672: PPUSH
104673: LD_INT 2
104675: PPUSH
104676: CALL_OW 322
// end ;
104680: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
104681: LD_EXP 120
104685: PUSH
104686: LD_EXP 172
104690: AND
104691: IFFALSE 104812
104693: GO 104695
104695: DISABLE
104696: LD_INT 0
104698: PPUSH
104699: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104700: LD_ADDR_VAR 0 2
104704: PUSH
104705: LD_INT 22
104707: PUSH
104708: LD_OWVAR 2
104712: PUSH
104713: EMPTY
104714: LIST
104715: LIST
104716: PUSH
104717: LD_INT 21
104719: PUSH
104720: LD_INT 1
104722: PUSH
104723: EMPTY
104724: LIST
104725: LIST
104726: PUSH
104727: LD_INT 3
104729: PUSH
104730: LD_INT 23
104732: PUSH
104733: LD_INT 0
104735: PUSH
104736: EMPTY
104737: LIST
104738: LIST
104739: PUSH
104740: EMPTY
104741: LIST
104742: LIST
104743: PUSH
104744: EMPTY
104745: LIST
104746: LIST
104747: LIST
104748: PPUSH
104749: CALL_OW 69
104753: ST_TO_ADDR
// if not tmp then
104754: LD_VAR 0 2
104758: NOT
104759: IFFALSE 104763
// exit ;
104761: GO 104812
// for i in tmp do
104763: LD_ADDR_VAR 0 1
104767: PUSH
104768: LD_VAR 0 2
104772: PUSH
104773: FOR_IN
104774: IFFALSE 104810
// begin if Crawls ( i ) then
104776: LD_VAR 0 1
104780: PPUSH
104781: CALL_OW 318
104785: IFFALSE 104796
// ComWalk ( i ) ;
104787: LD_VAR 0 1
104791: PPUSH
104792: CALL_OW 138
// SetClass ( i , 2 ) ;
104796: LD_VAR 0 1
104800: PPUSH
104801: LD_INT 2
104803: PPUSH
104804: CALL_OW 336
// end ;
104808: GO 104773
104810: POP
104811: POP
// end ;
104812: PPOPN 2
104814: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104815: LD_EXP 120
104819: PUSH
104820: LD_EXP 173
104824: AND
104825: IFFALSE 105113
104827: GO 104829
104829: DISABLE
104830: LD_INT 0
104832: PPUSH
104833: PPUSH
104834: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104835: LD_OWVAR 2
104839: PPUSH
104840: LD_INT 9
104842: PPUSH
104843: LD_INT 1
104845: PPUSH
104846: LD_INT 1
104848: PPUSH
104849: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104853: LD_INT 9
104855: PPUSH
104856: LD_OWVAR 2
104860: PPUSH
104861: CALL_OW 343
// uc_side := 9 ;
104865: LD_ADDR_OWVAR 20
104869: PUSH
104870: LD_INT 9
104872: ST_TO_ADDR
// uc_nation := 2 ;
104873: LD_ADDR_OWVAR 21
104877: PUSH
104878: LD_INT 2
104880: ST_TO_ADDR
// hc_name := Dark Warrior ;
104881: LD_ADDR_OWVAR 26
104885: PUSH
104886: LD_STRING Dark Warrior
104888: ST_TO_ADDR
// hc_gallery :=  ;
104889: LD_ADDR_OWVAR 33
104893: PUSH
104894: LD_STRING 
104896: ST_TO_ADDR
// hc_noskilllimit := true ;
104897: LD_ADDR_OWVAR 76
104901: PUSH
104902: LD_INT 1
104904: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104905: LD_ADDR_OWVAR 31
104909: PUSH
104910: LD_INT 30
104912: PUSH
104913: LD_INT 30
104915: PUSH
104916: LD_INT 30
104918: PUSH
104919: LD_INT 30
104921: PUSH
104922: EMPTY
104923: LIST
104924: LIST
104925: LIST
104926: LIST
104927: ST_TO_ADDR
// un := CreateHuman ;
104928: LD_ADDR_VAR 0 3
104932: PUSH
104933: CALL_OW 44
104937: ST_TO_ADDR
// hc_noskilllimit := false ;
104938: LD_ADDR_OWVAR 76
104942: PUSH
104943: LD_INT 0
104945: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104946: LD_VAR 0 3
104950: PPUSH
104951: LD_INT 1
104953: PPUSH
104954: CALL_OW 51
// ToLua ( playRanger() ) ;
104958: LD_STRING playRanger()
104960: PPUSH
104961: CALL_OW 559
// p := 0 ;
104965: LD_ADDR_VAR 0 2
104969: PUSH
104970: LD_INT 0
104972: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104973: LD_INT 35
104975: PPUSH
104976: CALL_OW 67
// p := p + 1 ;
104980: LD_ADDR_VAR 0 2
104984: PUSH
104985: LD_VAR 0 2
104989: PUSH
104990: LD_INT 1
104992: PLUS
104993: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104994: LD_VAR 0 3
104998: PPUSH
104999: CALL_OW 256
105003: PUSH
105004: LD_INT 1000
105006: LESS
105007: IFFALSE 105021
// SetLives ( un , 1000 ) ;
105009: LD_VAR 0 3
105013: PPUSH
105014: LD_INT 1000
105016: PPUSH
105017: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105021: LD_VAR 0 3
105025: PPUSH
105026: LD_INT 81
105028: PUSH
105029: LD_OWVAR 2
105033: PUSH
105034: EMPTY
105035: LIST
105036: LIST
105037: PUSH
105038: LD_INT 91
105040: PUSH
105041: LD_VAR 0 3
105045: PUSH
105046: LD_INT 30
105048: PUSH
105049: EMPTY
105050: LIST
105051: LIST
105052: LIST
105053: PUSH
105054: EMPTY
105055: LIST
105056: LIST
105057: PPUSH
105058: CALL_OW 69
105062: PPUSH
105063: LD_VAR 0 3
105067: PPUSH
105068: CALL_OW 74
105072: PPUSH
105073: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105077: LD_VAR 0 2
105081: PUSH
105082: LD_INT 80
105084: GREATER
105085: PUSH
105086: LD_VAR 0 3
105090: PPUSH
105091: CALL_OW 301
105095: OR
105096: IFFALSE 104973
// if un then
105098: LD_VAR 0 3
105102: IFFALSE 105113
// RemoveUnit ( un ) ;
105104: LD_VAR 0 3
105108: PPUSH
105109: CALL_OW 64
// end ;
105113: PPOPN 3
105115: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105116: LD_EXP 174
105120: IFFALSE 105236
105122: GO 105124
105124: DISABLE
105125: LD_INT 0
105127: PPUSH
105128: PPUSH
105129: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105130: LD_ADDR_VAR 0 2
105134: PUSH
105135: LD_INT 81
105137: PUSH
105138: LD_OWVAR 2
105142: PUSH
105143: EMPTY
105144: LIST
105145: LIST
105146: PUSH
105147: LD_INT 21
105149: PUSH
105150: LD_INT 1
105152: PUSH
105153: EMPTY
105154: LIST
105155: LIST
105156: PUSH
105157: EMPTY
105158: LIST
105159: LIST
105160: PPUSH
105161: CALL_OW 69
105165: ST_TO_ADDR
// ToLua ( playComputer() ) ;
105166: LD_STRING playComputer()
105168: PPUSH
105169: CALL_OW 559
// if not tmp then
105173: LD_VAR 0 2
105177: NOT
105178: IFFALSE 105182
// exit ;
105180: GO 105236
// for i in tmp do
105182: LD_ADDR_VAR 0 1
105186: PUSH
105187: LD_VAR 0 2
105191: PUSH
105192: FOR_IN
105193: IFFALSE 105234
// for j := 1 to 4 do
105195: LD_ADDR_VAR 0 3
105199: PUSH
105200: DOUBLE
105201: LD_INT 1
105203: DEC
105204: ST_TO_ADDR
105205: LD_INT 4
105207: PUSH
105208: FOR_TO
105209: IFFALSE 105230
// SetSkill ( i , j , 10 ) ;
105211: LD_VAR 0 1
105215: PPUSH
105216: LD_VAR 0 3
105220: PPUSH
105221: LD_INT 10
105223: PPUSH
105224: CALL_OW 237
105228: GO 105208
105230: POP
105231: POP
105232: GO 105192
105234: POP
105235: POP
// end ;
105236: PPOPN 3
105238: END
// every 0 0$1 trigger s30 do var i , tmp ;
105239: LD_EXP 175
105243: IFFALSE 105312
105245: GO 105247
105247: DISABLE
105248: LD_INT 0
105250: PPUSH
105251: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105252: LD_ADDR_VAR 0 2
105256: PUSH
105257: LD_INT 22
105259: PUSH
105260: LD_OWVAR 2
105264: PUSH
105265: EMPTY
105266: LIST
105267: LIST
105268: PPUSH
105269: CALL_OW 69
105273: ST_TO_ADDR
// if not tmp then
105274: LD_VAR 0 2
105278: NOT
105279: IFFALSE 105283
// exit ;
105281: GO 105312
// for i in tmp do
105283: LD_ADDR_VAR 0 1
105287: PUSH
105288: LD_VAR 0 2
105292: PUSH
105293: FOR_IN
105294: IFFALSE 105310
// SetLives ( i , 300 ) ;
105296: LD_VAR 0 1
105300: PPUSH
105301: LD_INT 300
105303: PPUSH
105304: CALL_OW 234
105308: GO 105293
105310: POP
105311: POP
// end ;
105312: PPOPN 2
105314: END
// every 0 0$1 trigger s60 do var i , tmp ;
105315: LD_EXP 176
105319: IFFALSE 105388
105321: GO 105323
105323: DISABLE
105324: LD_INT 0
105326: PPUSH
105327: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105328: LD_ADDR_VAR 0 2
105332: PUSH
105333: LD_INT 22
105335: PUSH
105336: LD_OWVAR 2
105340: PUSH
105341: EMPTY
105342: LIST
105343: LIST
105344: PPUSH
105345: CALL_OW 69
105349: ST_TO_ADDR
// if not tmp then
105350: LD_VAR 0 2
105354: NOT
105355: IFFALSE 105359
// exit ;
105357: GO 105388
// for i in tmp do
105359: LD_ADDR_VAR 0 1
105363: PUSH
105364: LD_VAR 0 2
105368: PUSH
105369: FOR_IN
105370: IFFALSE 105386
// SetLives ( i , 600 ) ;
105372: LD_VAR 0 1
105376: PPUSH
105377: LD_INT 600
105379: PPUSH
105380: CALL_OW 234
105384: GO 105369
105386: POP
105387: POP
// end ;
105388: PPOPN 2
105390: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105391: LD_INT 0
105393: PPUSH
// case cmd of 301 :
105394: LD_VAR 0 1
105398: PUSH
105399: LD_INT 301
105401: DOUBLE
105402: EQUAL
105403: IFTRUE 105407
105405: GO 105439
105407: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
105408: LD_VAR 0 6
105412: PPUSH
105413: LD_VAR 0 7
105417: PPUSH
105418: LD_VAR 0 8
105422: PPUSH
105423: LD_VAR 0 4
105427: PPUSH
105428: LD_VAR 0 5
105432: PPUSH
105433: CALL 106640 0 5
105437: GO 105560
105439: LD_INT 302
105441: DOUBLE
105442: EQUAL
105443: IFTRUE 105447
105445: GO 105484
105447: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
105448: LD_VAR 0 6
105452: PPUSH
105453: LD_VAR 0 7
105457: PPUSH
105458: LD_VAR 0 8
105462: PPUSH
105463: LD_VAR 0 9
105467: PPUSH
105468: LD_VAR 0 4
105472: PPUSH
105473: LD_VAR 0 5
105477: PPUSH
105478: CALL 106731 0 6
105482: GO 105560
105484: LD_INT 303
105486: DOUBLE
105487: EQUAL
105488: IFTRUE 105492
105490: GO 105529
105492: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
105493: LD_VAR 0 6
105497: PPUSH
105498: LD_VAR 0 7
105502: PPUSH
105503: LD_VAR 0 8
105507: PPUSH
105508: LD_VAR 0 9
105512: PPUSH
105513: LD_VAR 0 4
105517: PPUSH
105518: LD_VAR 0 5
105522: PPUSH
105523: CALL 105565 0 6
105527: GO 105560
105529: LD_INT 304
105531: DOUBLE
105532: EQUAL
105533: IFTRUE 105537
105535: GO 105559
105537: POP
// hHackTeleport ( unit , x , y ) ; end ;
105538: LD_VAR 0 2
105542: PPUSH
105543: LD_VAR 0 4
105547: PPUSH
105548: LD_VAR 0 5
105552: PPUSH
105553: CALL 107324 0 3
105557: GO 105560
105559: POP
// end ;
105560: LD_VAR 0 12
105564: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
105565: LD_INT 0
105567: PPUSH
105568: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
105569: LD_VAR 0 1
105573: PUSH
105574: LD_INT 1
105576: LESS
105577: PUSH
105578: LD_VAR 0 1
105582: PUSH
105583: LD_INT 3
105585: GREATER
105586: OR
105587: PUSH
105588: LD_VAR 0 5
105592: PPUSH
105593: LD_VAR 0 6
105597: PPUSH
105598: CALL_OW 428
105602: OR
105603: IFFALSE 105607
// exit ;
105605: GO 106327
// uc_side := your_side ;
105607: LD_ADDR_OWVAR 20
105611: PUSH
105612: LD_OWVAR 2
105616: ST_TO_ADDR
// uc_nation := nation ;
105617: LD_ADDR_OWVAR 21
105621: PUSH
105622: LD_VAR 0 1
105626: ST_TO_ADDR
// bc_level = 1 ;
105627: LD_ADDR_OWVAR 43
105631: PUSH
105632: LD_INT 1
105634: ST_TO_ADDR
// case btype of 1 :
105635: LD_VAR 0 2
105639: PUSH
105640: LD_INT 1
105642: DOUBLE
105643: EQUAL
105644: IFTRUE 105648
105646: GO 105659
105648: POP
// bc_type := b_depot ; 2 :
105649: LD_ADDR_OWVAR 42
105653: PUSH
105654: LD_INT 0
105656: ST_TO_ADDR
105657: GO 106271
105659: LD_INT 2
105661: DOUBLE
105662: EQUAL
105663: IFTRUE 105667
105665: GO 105678
105667: POP
// bc_type := b_warehouse ; 3 :
105668: LD_ADDR_OWVAR 42
105672: PUSH
105673: LD_INT 1
105675: ST_TO_ADDR
105676: GO 106271
105678: LD_INT 3
105680: DOUBLE
105681: EQUAL
105682: IFTRUE 105686
105684: GO 105697
105686: POP
// bc_type := b_lab ; 4 .. 9 :
105687: LD_ADDR_OWVAR 42
105691: PUSH
105692: LD_INT 6
105694: ST_TO_ADDR
105695: GO 106271
105697: LD_INT 4
105699: DOUBLE
105700: GREATEREQUAL
105701: IFFALSE 105709
105703: LD_INT 9
105705: DOUBLE
105706: LESSEQUAL
105707: IFTRUE 105711
105709: GO 105763
105711: POP
// begin bc_type := b_lab_half ;
105712: LD_ADDR_OWVAR 42
105716: PUSH
105717: LD_INT 7
105719: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
105720: LD_ADDR_OWVAR 44
105724: PUSH
105725: LD_INT 10
105727: PUSH
105728: LD_INT 11
105730: PUSH
105731: LD_INT 12
105733: PUSH
105734: LD_INT 15
105736: PUSH
105737: LD_INT 14
105739: PUSH
105740: LD_INT 13
105742: PUSH
105743: EMPTY
105744: LIST
105745: LIST
105746: LIST
105747: LIST
105748: LIST
105749: LIST
105750: PUSH
105751: LD_VAR 0 2
105755: PUSH
105756: LD_INT 3
105758: MINUS
105759: ARRAY
105760: ST_TO_ADDR
// end ; 10 .. 13 :
105761: GO 106271
105763: LD_INT 10
105765: DOUBLE
105766: GREATEREQUAL
105767: IFFALSE 105775
105769: LD_INT 13
105771: DOUBLE
105772: LESSEQUAL
105773: IFTRUE 105777
105775: GO 105854
105777: POP
// begin bc_type := b_lab_full ;
105778: LD_ADDR_OWVAR 42
105782: PUSH
105783: LD_INT 8
105785: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
105786: LD_ADDR_OWVAR 44
105790: PUSH
105791: LD_INT 10
105793: PUSH
105794: LD_INT 12
105796: PUSH
105797: LD_INT 14
105799: PUSH
105800: LD_INT 13
105802: PUSH
105803: EMPTY
105804: LIST
105805: LIST
105806: LIST
105807: LIST
105808: PUSH
105809: LD_VAR 0 2
105813: PUSH
105814: LD_INT 9
105816: MINUS
105817: ARRAY
105818: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105819: LD_ADDR_OWVAR 45
105823: PUSH
105824: LD_INT 11
105826: PUSH
105827: LD_INT 15
105829: PUSH
105830: LD_INT 12
105832: PUSH
105833: LD_INT 15
105835: PUSH
105836: EMPTY
105837: LIST
105838: LIST
105839: LIST
105840: LIST
105841: PUSH
105842: LD_VAR 0 2
105846: PUSH
105847: LD_INT 9
105849: MINUS
105850: ARRAY
105851: ST_TO_ADDR
// end ; 14 :
105852: GO 106271
105854: LD_INT 14
105856: DOUBLE
105857: EQUAL
105858: IFTRUE 105862
105860: GO 105873
105862: POP
// bc_type := b_workshop ; 15 :
105863: LD_ADDR_OWVAR 42
105867: PUSH
105868: LD_INT 2
105870: ST_TO_ADDR
105871: GO 106271
105873: LD_INT 15
105875: DOUBLE
105876: EQUAL
105877: IFTRUE 105881
105879: GO 105892
105881: POP
// bc_type := b_factory ; 16 :
105882: LD_ADDR_OWVAR 42
105886: PUSH
105887: LD_INT 3
105889: ST_TO_ADDR
105890: GO 106271
105892: LD_INT 16
105894: DOUBLE
105895: EQUAL
105896: IFTRUE 105900
105898: GO 105911
105900: POP
// bc_type := b_ext_gun ; 17 :
105901: LD_ADDR_OWVAR 42
105905: PUSH
105906: LD_INT 17
105908: ST_TO_ADDR
105909: GO 106271
105911: LD_INT 17
105913: DOUBLE
105914: EQUAL
105915: IFTRUE 105919
105917: GO 105947
105919: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105920: LD_ADDR_OWVAR 42
105924: PUSH
105925: LD_INT 19
105927: PUSH
105928: LD_INT 23
105930: PUSH
105931: LD_INT 19
105933: PUSH
105934: EMPTY
105935: LIST
105936: LIST
105937: LIST
105938: PUSH
105939: LD_VAR 0 1
105943: ARRAY
105944: ST_TO_ADDR
105945: GO 106271
105947: LD_INT 18
105949: DOUBLE
105950: EQUAL
105951: IFTRUE 105955
105953: GO 105966
105955: POP
// bc_type := b_ext_radar ; 19 :
105956: LD_ADDR_OWVAR 42
105960: PUSH
105961: LD_INT 20
105963: ST_TO_ADDR
105964: GO 106271
105966: LD_INT 19
105968: DOUBLE
105969: EQUAL
105970: IFTRUE 105974
105972: GO 105985
105974: POP
// bc_type := b_ext_radio ; 20 :
105975: LD_ADDR_OWVAR 42
105979: PUSH
105980: LD_INT 22
105982: ST_TO_ADDR
105983: GO 106271
105985: LD_INT 20
105987: DOUBLE
105988: EQUAL
105989: IFTRUE 105993
105991: GO 106004
105993: POP
// bc_type := b_ext_siberium ; 21 :
105994: LD_ADDR_OWVAR 42
105998: PUSH
105999: LD_INT 21
106001: ST_TO_ADDR
106002: GO 106271
106004: LD_INT 21
106006: DOUBLE
106007: EQUAL
106008: IFTRUE 106012
106010: GO 106023
106012: POP
// bc_type := b_ext_computer ; 22 :
106013: LD_ADDR_OWVAR 42
106017: PUSH
106018: LD_INT 24
106020: ST_TO_ADDR
106021: GO 106271
106023: LD_INT 22
106025: DOUBLE
106026: EQUAL
106027: IFTRUE 106031
106029: GO 106042
106031: POP
// bc_type := b_ext_track ; 23 :
106032: LD_ADDR_OWVAR 42
106036: PUSH
106037: LD_INT 16
106039: ST_TO_ADDR
106040: GO 106271
106042: LD_INT 23
106044: DOUBLE
106045: EQUAL
106046: IFTRUE 106050
106048: GO 106061
106050: POP
// bc_type := b_ext_laser ; 24 :
106051: LD_ADDR_OWVAR 42
106055: PUSH
106056: LD_INT 25
106058: ST_TO_ADDR
106059: GO 106271
106061: LD_INT 24
106063: DOUBLE
106064: EQUAL
106065: IFTRUE 106069
106067: GO 106080
106069: POP
// bc_type := b_control_tower ; 25 :
106070: LD_ADDR_OWVAR 42
106074: PUSH
106075: LD_INT 36
106077: ST_TO_ADDR
106078: GO 106271
106080: LD_INT 25
106082: DOUBLE
106083: EQUAL
106084: IFTRUE 106088
106086: GO 106099
106088: POP
// bc_type := b_breastwork ; 26 :
106089: LD_ADDR_OWVAR 42
106093: PUSH
106094: LD_INT 31
106096: ST_TO_ADDR
106097: GO 106271
106099: LD_INT 26
106101: DOUBLE
106102: EQUAL
106103: IFTRUE 106107
106105: GO 106118
106107: POP
// bc_type := b_bunker ; 27 :
106108: LD_ADDR_OWVAR 42
106112: PUSH
106113: LD_INT 32
106115: ST_TO_ADDR
106116: GO 106271
106118: LD_INT 27
106120: DOUBLE
106121: EQUAL
106122: IFTRUE 106126
106124: GO 106137
106126: POP
// bc_type := b_turret ; 28 :
106127: LD_ADDR_OWVAR 42
106131: PUSH
106132: LD_INT 33
106134: ST_TO_ADDR
106135: GO 106271
106137: LD_INT 28
106139: DOUBLE
106140: EQUAL
106141: IFTRUE 106145
106143: GO 106156
106145: POP
// bc_type := b_armoury ; 29 :
106146: LD_ADDR_OWVAR 42
106150: PUSH
106151: LD_INT 4
106153: ST_TO_ADDR
106154: GO 106271
106156: LD_INT 29
106158: DOUBLE
106159: EQUAL
106160: IFTRUE 106164
106162: GO 106175
106164: POP
// bc_type := b_barracks ; 30 :
106165: LD_ADDR_OWVAR 42
106169: PUSH
106170: LD_INT 5
106172: ST_TO_ADDR
106173: GO 106271
106175: LD_INT 30
106177: DOUBLE
106178: EQUAL
106179: IFTRUE 106183
106181: GO 106194
106183: POP
// bc_type := b_solar_power ; 31 :
106184: LD_ADDR_OWVAR 42
106188: PUSH
106189: LD_INT 27
106191: ST_TO_ADDR
106192: GO 106271
106194: LD_INT 31
106196: DOUBLE
106197: EQUAL
106198: IFTRUE 106202
106200: GO 106213
106202: POP
// bc_type := b_oil_power ; 32 :
106203: LD_ADDR_OWVAR 42
106207: PUSH
106208: LD_INT 26
106210: ST_TO_ADDR
106211: GO 106271
106213: LD_INT 32
106215: DOUBLE
106216: EQUAL
106217: IFTRUE 106221
106219: GO 106232
106221: POP
// bc_type := b_siberite_power ; 33 :
106222: LD_ADDR_OWVAR 42
106226: PUSH
106227: LD_INT 28
106229: ST_TO_ADDR
106230: GO 106271
106232: LD_INT 33
106234: DOUBLE
106235: EQUAL
106236: IFTRUE 106240
106238: GO 106251
106240: POP
// bc_type := b_oil_mine ; 34 :
106241: LD_ADDR_OWVAR 42
106245: PUSH
106246: LD_INT 29
106248: ST_TO_ADDR
106249: GO 106271
106251: LD_INT 34
106253: DOUBLE
106254: EQUAL
106255: IFTRUE 106259
106257: GO 106270
106259: POP
// bc_type := b_siberite_mine ; end ;
106260: LD_ADDR_OWVAR 42
106264: PUSH
106265: LD_INT 30
106267: ST_TO_ADDR
106268: GO 106271
106270: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
106271: LD_ADDR_VAR 0 8
106275: PUSH
106276: LD_VAR 0 5
106280: PPUSH
106281: LD_VAR 0 6
106285: PPUSH
106286: LD_VAR 0 3
106290: PPUSH
106291: CALL_OW 47
106295: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
106296: LD_OWVAR 42
106300: PUSH
106301: LD_INT 32
106303: PUSH
106304: LD_INT 33
106306: PUSH
106307: EMPTY
106308: LIST
106309: LIST
106310: IN
106311: IFFALSE 106327
// PlaceWeaponTurret ( b , weapon ) ;
106313: LD_VAR 0 8
106317: PPUSH
106318: LD_VAR 0 4
106322: PPUSH
106323: CALL_OW 431
// end ;
106327: LD_VAR 0 7
106331: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
106332: LD_INT 0
106334: PPUSH
106335: PPUSH
106336: PPUSH
106337: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106338: LD_ADDR_VAR 0 4
106342: PUSH
106343: LD_INT 22
106345: PUSH
106346: LD_OWVAR 2
106350: PUSH
106351: EMPTY
106352: LIST
106353: LIST
106354: PUSH
106355: LD_INT 2
106357: PUSH
106358: LD_INT 30
106360: PUSH
106361: LD_INT 0
106363: PUSH
106364: EMPTY
106365: LIST
106366: LIST
106367: PUSH
106368: LD_INT 30
106370: PUSH
106371: LD_INT 1
106373: PUSH
106374: EMPTY
106375: LIST
106376: LIST
106377: PUSH
106378: EMPTY
106379: LIST
106380: LIST
106381: LIST
106382: PUSH
106383: EMPTY
106384: LIST
106385: LIST
106386: PPUSH
106387: CALL_OW 69
106391: ST_TO_ADDR
// if not tmp then
106392: LD_VAR 0 4
106396: NOT
106397: IFFALSE 106401
// exit ;
106399: GO 106460
// for i in tmp do
106401: LD_ADDR_VAR 0 2
106405: PUSH
106406: LD_VAR 0 4
106410: PUSH
106411: FOR_IN
106412: IFFALSE 106458
// for j = 1 to 3 do
106414: LD_ADDR_VAR 0 3
106418: PUSH
106419: DOUBLE
106420: LD_INT 1
106422: DEC
106423: ST_TO_ADDR
106424: LD_INT 3
106426: PUSH
106427: FOR_TO
106428: IFFALSE 106454
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
106430: LD_VAR 0 2
106434: PPUSH
106435: CALL_OW 274
106439: PPUSH
106440: LD_VAR 0 3
106444: PPUSH
106445: LD_INT 99999
106447: PPUSH
106448: CALL_OW 277
106452: GO 106427
106454: POP
106455: POP
106456: GO 106411
106458: POP
106459: POP
// end ;
106460: LD_VAR 0 1
106464: RET
// export function hHackSetLevel10 ; var i , j ; begin
106465: LD_INT 0
106467: PPUSH
106468: PPUSH
106469: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106470: LD_ADDR_VAR 0 2
106474: PUSH
106475: LD_INT 21
106477: PUSH
106478: LD_INT 1
106480: PUSH
106481: EMPTY
106482: LIST
106483: LIST
106484: PPUSH
106485: CALL_OW 69
106489: PUSH
106490: FOR_IN
106491: IFFALSE 106543
// if IsSelected ( i ) then
106493: LD_VAR 0 2
106497: PPUSH
106498: CALL_OW 306
106502: IFFALSE 106541
// begin for j := 1 to 4 do
106504: LD_ADDR_VAR 0 3
106508: PUSH
106509: DOUBLE
106510: LD_INT 1
106512: DEC
106513: ST_TO_ADDR
106514: LD_INT 4
106516: PUSH
106517: FOR_TO
106518: IFFALSE 106539
// SetSkill ( i , j , 10 ) ;
106520: LD_VAR 0 2
106524: PPUSH
106525: LD_VAR 0 3
106529: PPUSH
106530: LD_INT 10
106532: PPUSH
106533: CALL_OW 237
106537: GO 106517
106539: POP
106540: POP
// end ;
106541: GO 106490
106543: POP
106544: POP
// end ;
106545: LD_VAR 0 1
106549: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
106550: LD_INT 0
106552: PPUSH
106553: PPUSH
106554: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
106555: LD_ADDR_VAR 0 2
106559: PUSH
106560: LD_INT 22
106562: PUSH
106563: LD_OWVAR 2
106567: PUSH
106568: EMPTY
106569: LIST
106570: LIST
106571: PUSH
106572: LD_INT 21
106574: PUSH
106575: LD_INT 1
106577: PUSH
106578: EMPTY
106579: LIST
106580: LIST
106581: PUSH
106582: EMPTY
106583: LIST
106584: LIST
106585: PPUSH
106586: CALL_OW 69
106590: PUSH
106591: FOR_IN
106592: IFFALSE 106633
// begin for j := 1 to 4 do
106594: LD_ADDR_VAR 0 3
106598: PUSH
106599: DOUBLE
106600: LD_INT 1
106602: DEC
106603: ST_TO_ADDR
106604: LD_INT 4
106606: PUSH
106607: FOR_TO
106608: IFFALSE 106629
// SetSkill ( i , j , 10 ) ;
106610: LD_VAR 0 2
106614: PPUSH
106615: LD_VAR 0 3
106619: PPUSH
106620: LD_INT 10
106622: PPUSH
106623: CALL_OW 237
106627: GO 106607
106629: POP
106630: POP
// end ;
106631: GO 106591
106633: POP
106634: POP
// end ;
106635: LD_VAR 0 1
106639: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
106640: LD_INT 0
106642: PPUSH
// uc_side := your_side ;
106643: LD_ADDR_OWVAR 20
106647: PUSH
106648: LD_OWVAR 2
106652: ST_TO_ADDR
// uc_nation := nation ;
106653: LD_ADDR_OWVAR 21
106657: PUSH
106658: LD_VAR 0 1
106662: ST_TO_ADDR
// InitHc ;
106663: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
106667: LD_INT 0
106669: PPUSH
106670: LD_VAR 0 2
106674: PPUSH
106675: LD_VAR 0 3
106679: PPUSH
106680: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
106684: LD_VAR 0 4
106688: PPUSH
106689: LD_VAR 0 5
106693: PPUSH
106694: CALL_OW 428
106698: PUSH
106699: LD_INT 0
106701: EQUAL
106702: IFFALSE 106726
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
106704: CALL_OW 44
106708: PPUSH
106709: LD_VAR 0 4
106713: PPUSH
106714: LD_VAR 0 5
106718: PPUSH
106719: LD_INT 1
106721: PPUSH
106722: CALL_OW 48
// end ;
106726: LD_VAR 0 6
106730: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
106731: LD_INT 0
106733: PPUSH
106734: PPUSH
// uc_side := your_side ;
106735: LD_ADDR_OWVAR 20
106739: PUSH
106740: LD_OWVAR 2
106744: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
106745: LD_VAR 0 1
106749: PUSH
106750: LD_INT 1
106752: PUSH
106753: LD_INT 2
106755: PUSH
106756: LD_INT 3
106758: PUSH
106759: LD_INT 4
106761: PUSH
106762: LD_INT 5
106764: PUSH
106765: EMPTY
106766: LIST
106767: LIST
106768: LIST
106769: LIST
106770: LIST
106771: IN
106772: IFFALSE 106784
// uc_nation := nation_american else
106774: LD_ADDR_OWVAR 21
106778: PUSH
106779: LD_INT 1
106781: ST_TO_ADDR
106782: GO 106827
// if chassis in [ 11 , 12 , 13 , 14 ] then
106784: LD_VAR 0 1
106788: PUSH
106789: LD_INT 11
106791: PUSH
106792: LD_INT 12
106794: PUSH
106795: LD_INT 13
106797: PUSH
106798: LD_INT 14
106800: PUSH
106801: EMPTY
106802: LIST
106803: LIST
106804: LIST
106805: LIST
106806: IN
106807: IFFALSE 106819
// uc_nation := nation_arabian else
106809: LD_ADDR_OWVAR 21
106813: PUSH
106814: LD_INT 2
106816: ST_TO_ADDR
106817: GO 106827
// uc_nation := nation_russian ;
106819: LD_ADDR_OWVAR 21
106823: PUSH
106824: LD_INT 3
106826: ST_TO_ADDR
// vc_chassis := chassis ;
106827: LD_ADDR_OWVAR 37
106831: PUSH
106832: LD_VAR 0 1
106836: ST_TO_ADDR
// vc_engine := engine ;
106837: LD_ADDR_OWVAR 39
106841: PUSH
106842: LD_VAR 0 2
106846: ST_TO_ADDR
// vc_control := control ;
106847: LD_ADDR_OWVAR 38
106851: PUSH
106852: LD_VAR 0 3
106856: ST_TO_ADDR
// vc_weapon := weapon ;
106857: LD_ADDR_OWVAR 40
106861: PUSH
106862: LD_VAR 0 4
106866: ST_TO_ADDR
// un := CreateVehicle ;
106867: LD_ADDR_VAR 0 8
106871: PUSH
106872: CALL_OW 45
106876: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106877: LD_VAR 0 8
106881: PPUSH
106882: LD_INT 0
106884: PPUSH
106885: LD_INT 5
106887: PPUSH
106888: CALL_OW 12
106892: PPUSH
106893: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106897: LD_VAR 0 8
106901: PPUSH
106902: LD_VAR 0 5
106906: PPUSH
106907: LD_VAR 0 6
106911: PPUSH
106912: LD_INT 1
106914: PPUSH
106915: CALL_OW 48
// end ;
106919: LD_VAR 0 7
106923: RET
// export hInvincible ; every 1 do
106924: GO 106926
106926: DISABLE
// hInvincible := [ ] ;
106927: LD_ADDR_EXP 177
106931: PUSH
106932: EMPTY
106933: ST_TO_ADDR
106934: END
// every 10 do var i ;
106935: GO 106937
106937: DISABLE
106938: LD_INT 0
106940: PPUSH
// begin enable ;
106941: ENABLE
// if not hInvincible then
106942: LD_EXP 177
106946: NOT
106947: IFFALSE 106951
// exit ;
106949: GO 106995
// for i in hInvincible do
106951: LD_ADDR_VAR 0 1
106955: PUSH
106956: LD_EXP 177
106960: PUSH
106961: FOR_IN
106962: IFFALSE 106993
// if GetLives ( i ) < 1000 then
106964: LD_VAR 0 1
106968: PPUSH
106969: CALL_OW 256
106973: PUSH
106974: LD_INT 1000
106976: LESS
106977: IFFALSE 106991
// SetLives ( i , 1000 ) ;
106979: LD_VAR 0 1
106983: PPUSH
106984: LD_INT 1000
106986: PPUSH
106987: CALL_OW 234
106991: GO 106961
106993: POP
106994: POP
// end ;
106995: PPOPN 1
106997: END
// export function hHackInvincible ; var i ; begin
106998: LD_INT 0
107000: PPUSH
107001: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107002: LD_ADDR_VAR 0 2
107006: PUSH
107007: LD_INT 2
107009: PUSH
107010: LD_INT 21
107012: PUSH
107013: LD_INT 1
107015: PUSH
107016: EMPTY
107017: LIST
107018: LIST
107019: PUSH
107020: LD_INT 21
107022: PUSH
107023: LD_INT 2
107025: PUSH
107026: EMPTY
107027: LIST
107028: LIST
107029: PUSH
107030: EMPTY
107031: LIST
107032: LIST
107033: LIST
107034: PPUSH
107035: CALL_OW 69
107039: PUSH
107040: FOR_IN
107041: IFFALSE 107102
// if IsSelected ( i ) then
107043: LD_VAR 0 2
107047: PPUSH
107048: CALL_OW 306
107052: IFFALSE 107100
// begin if i in hInvincible then
107054: LD_VAR 0 2
107058: PUSH
107059: LD_EXP 177
107063: IN
107064: IFFALSE 107084
// hInvincible := hInvincible diff i else
107066: LD_ADDR_EXP 177
107070: PUSH
107071: LD_EXP 177
107075: PUSH
107076: LD_VAR 0 2
107080: DIFF
107081: ST_TO_ADDR
107082: GO 107100
// hInvincible := hInvincible union i ;
107084: LD_ADDR_EXP 177
107088: PUSH
107089: LD_EXP 177
107093: PUSH
107094: LD_VAR 0 2
107098: UNION
107099: ST_TO_ADDR
// end ;
107100: GO 107040
107102: POP
107103: POP
// end ;
107104: LD_VAR 0 1
107108: RET
// export function hHackInvisible ; var i , j ; begin
107109: LD_INT 0
107111: PPUSH
107112: PPUSH
107113: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107114: LD_ADDR_VAR 0 2
107118: PUSH
107119: LD_INT 21
107121: PUSH
107122: LD_INT 1
107124: PUSH
107125: EMPTY
107126: LIST
107127: LIST
107128: PPUSH
107129: CALL_OW 69
107133: PUSH
107134: FOR_IN
107135: IFFALSE 107159
// if IsSelected ( i ) then
107137: LD_VAR 0 2
107141: PPUSH
107142: CALL_OW 306
107146: IFFALSE 107157
// ComForceInvisible ( i ) ;
107148: LD_VAR 0 2
107152: PPUSH
107153: CALL_OW 496
107157: GO 107134
107159: POP
107160: POP
// end ;
107161: LD_VAR 0 1
107165: RET
// export function hHackChangeYourSide ; begin
107166: LD_INT 0
107168: PPUSH
// if your_side = 8 then
107169: LD_OWVAR 2
107173: PUSH
107174: LD_INT 8
107176: EQUAL
107177: IFFALSE 107189
// your_side := 0 else
107179: LD_ADDR_OWVAR 2
107183: PUSH
107184: LD_INT 0
107186: ST_TO_ADDR
107187: GO 107203
// your_side := your_side + 1 ;
107189: LD_ADDR_OWVAR 2
107193: PUSH
107194: LD_OWVAR 2
107198: PUSH
107199: LD_INT 1
107201: PLUS
107202: ST_TO_ADDR
// end ;
107203: LD_VAR 0 1
107207: RET
// export function hHackChangeUnitSide ; var i , j ; begin
107208: LD_INT 0
107210: PPUSH
107211: PPUSH
107212: PPUSH
// for i in all_units do
107213: LD_ADDR_VAR 0 2
107217: PUSH
107218: LD_OWVAR 3
107222: PUSH
107223: FOR_IN
107224: IFFALSE 107302
// if IsSelected ( i ) then
107226: LD_VAR 0 2
107230: PPUSH
107231: CALL_OW 306
107235: IFFALSE 107300
// begin j := GetSide ( i ) ;
107237: LD_ADDR_VAR 0 3
107241: PUSH
107242: LD_VAR 0 2
107246: PPUSH
107247: CALL_OW 255
107251: ST_TO_ADDR
// if j = 8 then
107252: LD_VAR 0 3
107256: PUSH
107257: LD_INT 8
107259: EQUAL
107260: IFFALSE 107272
// j := 0 else
107262: LD_ADDR_VAR 0 3
107266: PUSH
107267: LD_INT 0
107269: ST_TO_ADDR
107270: GO 107286
// j := j + 1 ;
107272: LD_ADDR_VAR 0 3
107276: PUSH
107277: LD_VAR 0 3
107281: PUSH
107282: LD_INT 1
107284: PLUS
107285: ST_TO_ADDR
// SetSide ( i , j ) ;
107286: LD_VAR 0 2
107290: PPUSH
107291: LD_VAR 0 3
107295: PPUSH
107296: CALL_OW 235
// end ;
107300: GO 107223
107302: POP
107303: POP
// end ;
107304: LD_VAR 0 1
107308: RET
// export function hHackFog ; begin
107309: LD_INT 0
107311: PPUSH
// FogOff ( true ) ;
107312: LD_INT 1
107314: PPUSH
107315: CALL_OW 344
// end ;
107319: LD_VAR 0 1
107323: RET
// export function hHackTeleport ( unit , x , y ) ; begin
107324: LD_INT 0
107326: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
107327: LD_VAR 0 1
107331: PPUSH
107332: LD_VAR 0 2
107336: PPUSH
107337: LD_VAR 0 3
107341: PPUSH
107342: LD_INT 1
107344: PPUSH
107345: LD_INT 1
107347: PPUSH
107348: CALL_OW 483
// CenterOnXY ( x , y ) ;
107352: LD_VAR 0 2
107356: PPUSH
107357: LD_VAR 0 3
107361: PPUSH
107362: CALL_OW 84
// end ;
107366: LD_VAR 0 4
107370: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107371: LD_INT 0
107373: PPUSH
107374: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107375: LD_VAR 0 1
107379: NOT
107380: PUSH
107381: LD_VAR 0 2
107385: PPUSH
107386: LD_VAR 0 3
107390: PPUSH
107391: CALL_OW 488
107395: NOT
107396: OR
107397: PUSH
107398: LD_VAR 0 1
107402: PPUSH
107403: CALL_OW 266
107407: PUSH
107408: LD_INT 3
107410: NONEQUAL
107411: PUSH
107412: LD_VAR 0 1
107416: PPUSH
107417: CALL_OW 247
107421: PUSH
107422: LD_INT 1
107424: EQUAL
107425: NOT
107426: AND
107427: OR
107428: IFFALSE 107432
// exit ;
107430: GO 107581
// if GetType ( factory ) = unit_human then
107432: LD_VAR 0 1
107436: PPUSH
107437: CALL_OW 247
107441: PUSH
107442: LD_INT 1
107444: EQUAL
107445: IFFALSE 107462
// factory := IsInUnit ( factory ) ;
107447: LD_ADDR_VAR 0 1
107451: PUSH
107452: LD_VAR 0 1
107456: PPUSH
107457: CALL_OW 310
107461: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
107462: LD_VAR 0 1
107466: PPUSH
107467: CALL_OW 266
107471: PUSH
107472: LD_INT 3
107474: NONEQUAL
107475: IFFALSE 107479
// exit ;
107477: GO 107581
// if HexInfo ( x , y ) = factory then
107479: LD_VAR 0 2
107483: PPUSH
107484: LD_VAR 0 3
107488: PPUSH
107489: CALL_OW 428
107493: PUSH
107494: LD_VAR 0 1
107498: EQUAL
107499: IFFALSE 107526
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
107501: LD_ADDR_EXP 178
107505: PUSH
107506: LD_EXP 178
107510: PPUSH
107511: LD_VAR 0 1
107515: PPUSH
107516: LD_INT 0
107518: PPUSH
107519: CALL_OW 1
107523: ST_TO_ADDR
107524: GO 107577
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
107526: LD_ADDR_EXP 178
107530: PUSH
107531: LD_EXP 178
107535: PPUSH
107536: LD_VAR 0 1
107540: PPUSH
107541: LD_VAR 0 1
107545: PPUSH
107546: CALL_OW 255
107550: PUSH
107551: LD_VAR 0 1
107555: PUSH
107556: LD_VAR 0 2
107560: PUSH
107561: LD_VAR 0 3
107565: PUSH
107566: EMPTY
107567: LIST
107568: LIST
107569: LIST
107570: LIST
107571: PPUSH
107572: CALL_OW 1
107576: ST_TO_ADDR
// UpdateFactoryWaypoints ;
107577: CALL 107586 0 0
// end ;
107581: LD_VAR 0 4
107585: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
107586: LD_INT 0
107588: PPUSH
107589: PPUSH
107590: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
107591: LD_STRING resetFactoryWaypoint();
107593: PPUSH
107594: CALL_OW 559
// if factoryWaypoints then
107598: LD_EXP 178
107602: IFFALSE 107728
// begin list := PrepareArray ( factoryWaypoints ) ;
107604: LD_ADDR_VAR 0 3
107608: PUSH
107609: LD_EXP 178
107613: PPUSH
107614: CALL 92982 0 1
107618: ST_TO_ADDR
// for i := 1 to list do
107619: LD_ADDR_VAR 0 2
107623: PUSH
107624: DOUBLE
107625: LD_INT 1
107627: DEC
107628: ST_TO_ADDR
107629: LD_VAR 0 3
107633: PUSH
107634: FOR_TO
107635: IFFALSE 107726
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107637: LD_STRING setFactoryWaypointXY(
107639: PUSH
107640: LD_VAR 0 3
107644: PUSH
107645: LD_VAR 0 2
107649: ARRAY
107650: PUSH
107651: LD_INT 1
107653: ARRAY
107654: STR
107655: PUSH
107656: LD_STRING ,
107658: STR
107659: PUSH
107660: LD_VAR 0 3
107664: PUSH
107665: LD_VAR 0 2
107669: ARRAY
107670: PUSH
107671: LD_INT 2
107673: ARRAY
107674: STR
107675: PUSH
107676: LD_STRING ,
107678: STR
107679: PUSH
107680: LD_VAR 0 3
107684: PUSH
107685: LD_VAR 0 2
107689: ARRAY
107690: PUSH
107691: LD_INT 3
107693: ARRAY
107694: STR
107695: PUSH
107696: LD_STRING ,
107698: STR
107699: PUSH
107700: LD_VAR 0 3
107704: PUSH
107705: LD_VAR 0 2
107709: ARRAY
107710: PUSH
107711: LD_INT 4
107713: ARRAY
107714: STR
107715: PUSH
107716: LD_STRING )
107718: STR
107719: PPUSH
107720: CALL_OW 559
107724: GO 107634
107726: POP
107727: POP
// end ; end ;
107728: LD_VAR 0 1
107732: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
107733: LD_INT 0
107735: PPUSH
// if HexInfo ( x , y ) = warehouse then
107736: LD_VAR 0 2
107740: PPUSH
107741: LD_VAR 0 3
107745: PPUSH
107746: CALL_OW 428
107750: PUSH
107751: LD_VAR 0 1
107755: EQUAL
107756: IFFALSE 107783
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
107758: LD_ADDR_EXP 179
107762: PUSH
107763: LD_EXP 179
107767: PPUSH
107768: LD_VAR 0 1
107772: PPUSH
107773: LD_INT 0
107775: PPUSH
107776: CALL_OW 1
107780: ST_TO_ADDR
107781: GO 107834
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
107783: LD_ADDR_EXP 179
107787: PUSH
107788: LD_EXP 179
107792: PPUSH
107793: LD_VAR 0 1
107797: PPUSH
107798: LD_VAR 0 1
107802: PPUSH
107803: CALL_OW 255
107807: PUSH
107808: LD_VAR 0 1
107812: PUSH
107813: LD_VAR 0 2
107817: PUSH
107818: LD_VAR 0 3
107822: PUSH
107823: EMPTY
107824: LIST
107825: LIST
107826: LIST
107827: LIST
107828: PPUSH
107829: CALL_OW 1
107833: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
107834: CALL 107843 0 0
// end ;
107838: LD_VAR 0 4
107842: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
107843: LD_INT 0
107845: PPUSH
107846: PPUSH
107847: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
107848: LD_STRING resetWarehouseGatheringPoints();
107850: PPUSH
107851: CALL_OW 559
// if warehouseGatheringPoints then
107855: LD_EXP 179
107859: IFFALSE 107985
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
107861: LD_ADDR_VAR 0 3
107865: PUSH
107866: LD_EXP 179
107870: PPUSH
107871: CALL 92982 0 1
107875: ST_TO_ADDR
// for i := 1 to list do
107876: LD_ADDR_VAR 0 2
107880: PUSH
107881: DOUBLE
107882: LD_INT 1
107884: DEC
107885: ST_TO_ADDR
107886: LD_VAR 0 3
107890: PUSH
107891: FOR_TO
107892: IFFALSE 107983
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107894: LD_STRING setWarehouseGatheringPointXY(
107896: PUSH
107897: LD_VAR 0 3
107901: PUSH
107902: LD_VAR 0 2
107906: ARRAY
107907: PUSH
107908: LD_INT 1
107910: ARRAY
107911: STR
107912: PUSH
107913: LD_STRING ,
107915: STR
107916: PUSH
107917: LD_VAR 0 3
107921: PUSH
107922: LD_VAR 0 2
107926: ARRAY
107927: PUSH
107928: LD_INT 2
107930: ARRAY
107931: STR
107932: PUSH
107933: LD_STRING ,
107935: STR
107936: PUSH
107937: LD_VAR 0 3
107941: PUSH
107942: LD_VAR 0 2
107946: ARRAY
107947: PUSH
107948: LD_INT 3
107950: ARRAY
107951: STR
107952: PUSH
107953: LD_STRING ,
107955: STR
107956: PUSH
107957: LD_VAR 0 3
107961: PUSH
107962: LD_VAR 0 2
107966: ARRAY
107967: PUSH
107968: LD_INT 4
107970: ARRAY
107971: STR
107972: PUSH
107973: LD_STRING )
107975: STR
107976: PPUSH
107977: CALL_OW 559
107981: GO 107891
107983: POP
107984: POP
// end ; end ;
107985: LD_VAR 0 1
107989: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107990: LD_EXP 179
107994: IFFALSE 108679
107996: GO 107998
107998: DISABLE
107999: LD_INT 0
108001: PPUSH
108002: PPUSH
108003: PPUSH
108004: PPUSH
108005: PPUSH
108006: PPUSH
108007: PPUSH
108008: PPUSH
108009: PPUSH
// begin enable ;
108010: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108011: LD_ADDR_VAR 0 3
108015: PUSH
108016: LD_EXP 179
108020: PPUSH
108021: CALL 92982 0 1
108025: ST_TO_ADDR
// if not list then
108026: LD_VAR 0 3
108030: NOT
108031: IFFALSE 108035
// exit ;
108033: GO 108679
// for i := 1 to list do
108035: LD_ADDR_VAR 0 1
108039: PUSH
108040: DOUBLE
108041: LD_INT 1
108043: DEC
108044: ST_TO_ADDR
108045: LD_VAR 0 3
108049: PUSH
108050: FOR_TO
108051: IFFALSE 108677
// begin depot := list [ i ] [ 2 ] ;
108053: LD_ADDR_VAR 0 8
108057: PUSH
108058: LD_VAR 0 3
108062: PUSH
108063: LD_VAR 0 1
108067: ARRAY
108068: PUSH
108069: LD_INT 2
108071: ARRAY
108072: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108073: LD_ADDR_VAR 0 5
108077: PUSH
108078: LD_VAR 0 3
108082: PUSH
108083: LD_VAR 0 1
108087: ARRAY
108088: PUSH
108089: LD_INT 1
108091: ARRAY
108092: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108093: LD_VAR 0 8
108097: PPUSH
108098: CALL_OW 301
108102: PUSH
108103: LD_VAR 0 5
108107: PUSH
108108: LD_VAR 0 8
108112: PPUSH
108113: CALL_OW 255
108117: NONEQUAL
108118: OR
108119: IFFALSE 108148
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108121: LD_ADDR_EXP 179
108125: PUSH
108126: LD_EXP 179
108130: PPUSH
108131: LD_VAR 0 8
108135: PPUSH
108136: LD_INT 0
108138: PPUSH
108139: CALL_OW 1
108143: ST_TO_ADDR
// exit ;
108144: POP
108145: POP
108146: GO 108679
// end ; x := list [ i ] [ 3 ] ;
108148: LD_ADDR_VAR 0 6
108152: PUSH
108153: LD_VAR 0 3
108157: PUSH
108158: LD_VAR 0 1
108162: ARRAY
108163: PUSH
108164: LD_INT 3
108166: ARRAY
108167: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
108168: LD_ADDR_VAR 0 7
108172: PUSH
108173: LD_VAR 0 3
108177: PUSH
108178: LD_VAR 0 1
108182: ARRAY
108183: PUSH
108184: LD_INT 4
108186: ARRAY
108187: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
108188: LD_ADDR_VAR 0 9
108192: PUSH
108193: LD_VAR 0 6
108197: PPUSH
108198: LD_VAR 0 7
108202: PPUSH
108203: LD_INT 16
108205: PPUSH
108206: CALL 91570 0 3
108210: ST_TO_ADDR
// if not cratesNearbyPoint then
108211: LD_VAR 0 9
108215: NOT
108216: IFFALSE 108222
// exit ;
108218: POP
108219: POP
108220: GO 108679
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
108222: LD_ADDR_VAR 0 4
108226: PUSH
108227: LD_INT 22
108229: PUSH
108230: LD_VAR 0 5
108234: PUSH
108235: EMPTY
108236: LIST
108237: LIST
108238: PUSH
108239: LD_INT 3
108241: PUSH
108242: LD_INT 60
108244: PUSH
108245: EMPTY
108246: LIST
108247: PUSH
108248: EMPTY
108249: LIST
108250: LIST
108251: PUSH
108252: LD_INT 91
108254: PUSH
108255: LD_VAR 0 8
108259: PUSH
108260: LD_INT 6
108262: PUSH
108263: EMPTY
108264: LIST
108265: LIST
108266: LIST
108267: PUSH
108268: LD_INT 2
108270: PUSH
108271: LD_INT 25
108273: PUSH
108274: LD_INT 2
108276: PUSH
108277: EMPTY
108278: LIST
108279: LIST
108280: PUSH
108281: LD_INT 25
108283: PUSH
108284: LD_INT 16
108286: PUSH
108287: EMPTY
108288: LIST
108289: LIST
108290: PUSH
108291: EMPTY
108292: LIST
108293: LIST
108294: LIST
108295: PUSH
108296: EMPTY
108297: LIST
108298: LIST
108299: LIST
108300: LIST
108301: PPUSH
108302: CALL_OW 69
108306: PUSH
108307: LD_VAR 0 8
108311: PPUSH
108312: CALL_OW 313
108316: PPUSH
108317: LD_INT 3
108319: PUSH
108320: LD_INT 60
108322: PUSH
108323: EMPTY
108324: LIST
108325: PUSH
108326: EMPTY
108327: LIST
108328: LIST
108329: PUSH
108330: LD_INT 2
108332: PUSH
108333: LD_INT 25
108335: PUSH
108336: LD_INT 2
108338: PUSH
108339: EMPTY
108340: LIST
108341: LIST
108342: PUSH
108343: LD_INT 25
108345: PUSH
108346: LD_INT 16
108348: PUSH
108349: EMPTY
108350: LIST
108351: LIST
108352: PUSH
108353: EMPTY
108354: LIST
108355: LIST
108356: LIST
108357: PUSH
108358: EMPTY
108359: LIST
108360: LIST
108361: PPUSH
108362: CALL_OW 72
108366: UNION
108367: ST_TO_ADDR
// if tmp then
108368: LD_VAR 0 4
108372: IFFALSE 108452
// begin tmp := ShrinkArray ( tmp , 3 ) ;
108374: LD_ADDR_VAR 0 4
108378: PUSH
108379: LD_VAR 0 4
108383: PPUSH
108384: LD_INT 3
108386: PPUSH
108387: CALL 89539 0 2
108391: ST_TO_ADDR
// for j in tmp do
108392: LD_ADDR_VAR 0 2
108396: PUSH
108397: LD_VAR 0 4
108401: PUSH
108402: FOR_IN
108403: IFFALSE 108446
// begin if IsInUnit ( j ) then
108405: LD_VAR 0 2
108409: PPUSH
108410: CALL_OW 310
108414: IFFALSE 108425
// ComExit ( j ) ;
108416: LD_VAR 0 2
108420: PPUSH
108421: CALL 89622 0 1
// AddComCollect ( j , x , y ) ;
108425: LD_VAR 0 2
108429: PPUSH
108430: LD_VAR 0 6
108434: PPUSH
108435: LD_VAR 0 7
108439: PPUSH
108440: CALL_OW 177
// end ;
108444: GO 108402
108446: POP
108447: POP
// exit ;
108448: POP
108449: POP
108450: GO 108679
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
108452: LD_ADDR_VAR 0 4
108456: PUSH
108457: LD_INT 22
108459: PUSH
108460: LD_VAR 0 5
108464: PUSH
108465: EMPTY
108466: LIST
108467: LIST
108468: PUSH
108469: LD_INT 91
108471: PUSH
108472: LD_VAR 0 8
108476: PUSH
108477: LD_INT 8
108479: PUSH
108480: EMPTY
108481: LIST
108482: LIST
108483: LIST
108484: PUSH
108485: LD_INT 2
108487: PUSH
108488: LD_INT 34
108490: PUSH
108491: LD_INT 12
108493: PUSH
108494: EMPTY
108495: LIST
108496: LIST
108497: PUSH
108498: LD_INT 34
108500: PUSH
108501: LD_INT 51
108503: PUSH
108504: EMPTY
108505: LIST
108506: LIST
108507: PUSH
108508: LD_INT 34
108510: PUSH
108511: LD_INT 32
108513: PUSH
108514: EMPTY
108515: LIST
108516: LIST
108517: PUSH
108518: LD_INT 34
108520: PUSH
108521: LD_INT 89
108523: PUSH
108524: EMPTY
108525: LIST
108526: LIST
108527: PUSH
108528: EMPTY
108529: LIST
108530: LIST
108531: LIST
108532: LIST
108533: LIST
108534: PUSH
108535: EMPTY
108536: LIST
108537: LIST
108538: LIST
108539: PPUSH
108540: CALL_OW 69
108544: ST_TO_ADDR
// if tmp then
108545: LD_VAR 0 4
108549: IFFALSE 108675
// begin for j in tmp do
108551: LD_ADDR_VAR 0 2
108555: PUSH
108556: LD_VAR 0 4
108560: PUSH
108561: FOR_IN
108562: IFFALSE 108673
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
108564: LD_VAR 0 2
108568: PPUSH
108569: CALL_OW 262
108573: PUSH
108574: LD_INT 3
108576: EQUAL
108577: PUSH
108578: LD_VAR 0 2
108582: PPUSH
108583: CALL_OW 261
108587: PUSH
108588: LD_INT 20
108590: GREATER
108591: OR
108592: PUSH
108593: LD_VAR 0 2
108597: PPUSH
108598: CALL_OW 314
108602: NOT
108603: AND
108604: PUSH
108605: LD_VAR 0 2
108609: PPUSH
108610: CALL_OW 263
108614: PUSH
108615: LD_INT 1
108617: NONEQUAL
108618: PUSH
108619: LD_VAR 0 2
108623: PPUSH
108624: CALL_OW 311
108628: OR
108629: AND
108630: IFFALSE 108671
// begin ComCollect ( j , x , y ) ;
108632: LD_VAR 0 2
108636: PPUSH
108637: LD_VAR 0 6
108641: PPUSH
108642: LD_VAR 0 7
108646: PPUSH
108647: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
108651: LD_VAR 0 2
108655: PPUSH
108656: LD_VAR 0 8
108660: PPUSH
108661: CALL_OW 172
// exit ;
108665: POP
108666: POP
108667: POP
108668: POP
108669: GO 108679
// end ;
108671: GO 108561
108673: POP
108674: POP
// end ; end ;
108675: GO 108050
108677: POP
108678: POP
// end ; end_of_file
108679: PPOPN 9
108681: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
108682: LD_INT 0
108684: PPUSH
108685: PPUSH
108686: PPUSH
108687: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
108688: LD_VAR 0 1
108692: PPUSH
108693: CALL_OW 264
108697: PUSH
108698: LD_INT 91
108700: EQUAL
108701: IFFALSE 108773
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
108703: LD_INT 68
108705: PPUSH
108706: LD_VAR 0 1
108710: PPUSH
108711: CALL_OW 255
108715: PPUSH
108716: CALL_OW 321
108720: PUSH
108721: LD_INT 2
108723: EQUAL
108724: IFFALSE 108736
// eff := 70 else
108726: LD_ADDR_VAR 0 4
108730: PUSH
108731: LD_INT 70
108733: ST_TO_ADDR
108734: GO 108744
// eff := 30 ;
108736: LD_ADDR_VAR 0 4
108740: PUSH
108741: LD_INT 30
108743: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
108744: LD_VAR 0 1
108748: PPUSH
108749: CALL_OW 250
108753: PPUSH
108754: LD_VAR 0 1
108758: PPUSH
108759: CALL_OW 251
108763: PPUSH
108764: LD_VAR 0 4
108768: PPUSH
108769: CALL_OW 495
// end ; end ;
108773: LD_VAR 0 2
108777: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
108778: LD_INT 0
108780: PPUSH
// end ;
108781: LD_VAR 0 4
108785: RET
// export function SOS_Command ( cmd ) ; begin
108786: LD_INT 0
108788: PPUSH
// end ;
108789: LD_VAR 0 2
108793: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
108794: LD_INT 0
108796: PPUSH
// end ;
108797: LD_VAR 0 6
108801: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
108802: LD_INT 0
108804: PPUSH
108805: PPUSH
// if not vehicle or not factory then
108806: LD_VAR 0 1
108810: NOT
108811: PUSH
108812: LD_VAR 0 2
108816: NOT
108817: OR
108818: IFFALSE 108822
// exit ;
108820: GO 109053
// if factoryWaypoints >= factory then
108822: LD_EXP 178
108826: PUSH
108827: LD_VAR 0 2
108831: GREATEREQUAL
108832: IFFALSE 109053
// if factoryWaypoints [ factory ] then
108834: LD_EXP 178
108838: PUSH
108839: LD_VAR 0 2
108843: ARRAY
108844: IFFALSE 109053
// begin if GetControl ( vehicle ) = control_manual then
108846: LD_VAR 0 1
108850: PPUSH
108851: CALL_OW 263
108855: PUSH
108856: LD_INT 1
108858: EQUAL
108859: IFFALSE 108940
// begin driver := IsDrivenBy ( vehicle ) ;
108861: LD_ADDR_VAR 0 4
108865: PUSH
108866: LD_VAR 0 1
108870: PPUSH
108871: CALL_OW 311
108875: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108876: LD_VAR 0 4
108880: PPUSH
108881: LD_EXP 178
108885: PUSH
108886: LD_VAR 0 2
108890: ARRAY
108891: PUSH
108892: LD_INT 3
108894: ARRAY
108895: PPUSH
108896: LD_EXP 178
108900: PUSH
108901: LD_VAR 0 2
108905: ARRAY
108906: PUSH
108907: LD_INT 4
108909: ARRAY
108910: PPUSH
108911: CALL_OW 171
// AddComExitVehicle ( driver ) ;
108915: LD_VAR 0 4
108919: PPUSH
108920: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
108924: LD_VAR 0 4
108928: PPUSH
108929: LD_VAR 0 2
108933: PPUSH
108934: CALL_OW 180
// end else
108938: GO 109053
// if GetControl ( vehicle ) = control_remote then
108940: LD_VAR 0 1
108944: PPUSH
108945: CALL_OW 263
108949: PUSH
108950: LD_INT 2
108952: EQUAL
108953: IFFALSE 109014
// begin wait ( 0 0$2 ) ;
108955: LD_INT 70
108957: PPUSH
108958: CALL_OW 67
// if Connect ( vehicle ) then
108962: LD_VAR 0 1
108966: PPUSH
108967: CALL 59954 0 1
108971: IFFALSE 109012
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108973: LD_VAR 0 1
108977: PPUSH
108978: LD_EXP 178
108982: PUSH
108983: LD_VAR 0 2
108987: ARRAY
108988: PUSH
108989: LD_INT 3
108991: ARRAY
108992: PPUSH
108993: LD_EXP 178
108997: PUSH
108998: LD_VAR 0 2
109002: ARRAY
109003: PUSH
109004: LD_INT 4
109006: ARRAY
109007: PPUSH
109008: CALL_OW 171
// end else
109012: GO 109053
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109014: LD_VAR 0 1
109018: PPUSH
109019: LD_EXP 178
109023: PUSH
109024: LD_VAR 0 2
109028: ARRAY
109029: PUSH
109030: LD_INT 3
109032: ARRAY
109033: PPUSH
109034: LD_EXP 178
109038: PUSH
109039: LD_VAR 0 2
109043: ARRAY
109044: PUSH
109045: LD_INT 4
109047: ARRAY
109048: PPUSH
109049: CALL_OW 171
// end ; end ;
109053: LD_VAR 0 3
109057: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
109058: LD_INT 0
109060: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
109061: LD_VAR 0 1
109065: PUSH
109066: LD_INT 250
109068: EQUAL
109069: PUSH
109070: LD_VAR 0 2
109074: PPUSH
109075: CALL_OW 264
109079: PUSH
109080: LD_INT 81
109082: EQUAL
109083: AND
109084: IFFALSE 109105
// MinerPlaceMine ( unit , x , y ) ;
109086: LD_VAR 0 2
109090: PPUSH
109091: LD_VAR 0 4
109095: PPUSH
109096: LD_VAR 0 5
109100: PPUSH
109101: CALL 111490 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
109105: LD_VAR 0 1
109109: PUSH
109110: LD_INT 251
109112: EQUAL
109113: PUSH
109114: LD_VAR 0 2
109118: PPUSH
109119: CALL_OW 264
109123: PUSH
109124: LD_INT 81
109126: EQUAL
109127: AND
109128: IFFALSE 109149
// MinerDetonateMine ( unit , x , y ) ;
109130: LD_VAR 0 2
109134: PPUSH
109135: LD_VAR 0 4
109139: PPUSH
109140: LD_VAR 0 5
109144: PPUSH
109145: CALL 111765 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
109149: LD_VAR 0 1
109153: PUSH
109154: LD_INT 252
109156: EQUAL
109157: PUSH
109158: LD_VAR 0 2
109162: PPUSH
109163: CALL_OW 264
109167: PUSH
109168: LD_INT 81
109170: EQUAL
109171: AND
109172: IFFALSE 109193
// MinerCreateMinefield ( unit , x , y ) ;
109174: LD_VAR 0 2
109178: PPUSH
109179: LD_VAR 0 4
109183: PPUSH
109184: LD_VAR 0 5
109188: PPUSH
109189: CALL 112182 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
109193: LD_VAR 0 1
109197: PUSH
109198: LD_INT 253
109200: EQUAL
109201: PUSH
109202: LD_VAR 0 2
109206: PPUSH
109207: CALL_OW 257
109211: PUSH
109212: LD_INT 5
109214: EQUAL
109215: AND
109216: IFFALSE 109237
// ComBinocular ( unit , x , y ) ;
109218: LD_VAR 0 2
109222: PPUSH
109223: LD_VAR 0 4
109227: PPUSH
109228: LD_VAR 0 5
109232: PPUSH
109233: CALL 112551 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
109237: LD_VAR 0 1
109241: PUSH
109242: LD_INT 254
109244: EQUAL
109245: PUSH
109246: LD_VAR 0 2
109250: PPUSH
109251: CALL_OW 264
109255: PUSH
109256: LD_INT 99
109258: EQUAL
109259: AND
109260: PUSH
109261: LD_VAR 0 3
109265: PPUSH
109266: CALL_OW 263
109270: PUSH
109271: LD_INT 3
109273: EQUAL
109274: AND
109275: IFFALSE 109291
// HackDestroyVehicle ( unit , selectedUnit ) ;
109277: LD_VAR 0 2
109281: PPUSH
109282: LD_VAR 0 3
109286: PPUSH
109287: CALL 110854 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
109291: LD_VAR 0 1
109295: PUSH
109296: LD_INT 255
109298: EQUAL
109299: PUSH
109300: LD_VAR 0 2
109304: PPUSH
109305: CALL_OW 264
109309: PUSH
109310: LD_INT 14
109312: PUSH
109313: LD_INT 53
109315: PUSH
109316: EMPTY
109317: LIST
109318: LIST
109319: IN
109320: AND
109321: PUSH
109322: LD_VAR 0 4
109326: PPUSH
109327: LD_VAR 0 5
109331: PPUSH
109332: CALL_OW 488
109336: AND
109337: IFFALSE 109361
// CutTreeXYR ( unit , x , y , 12 ) ;
109339: LD_VAR 0 2
109343: PPUSH
109344: LD_VAR 0 4
109348: PPUSH
109349: LD_VAR 0 5
109353: PPUSH
109354: LD_INT 12
109356: PPUSH
109357: CALL 109424 0 4
// if cmd = 256 then
109361: LD_VAR 0 1
109365: PUSH
109366: LD_INT 256
109368: EQUAL
109369: IFFALSE 109390
// SetFactoryWaypoint ( unit , x , y ) ;
109371: LD_VAR 0 2
109375: PPUSH
109376: LD_VAR 0 4
109380: PPUSH
109381: LD_VAR 0 5
109385: PPUSH
109386: CALL 107371 0 3
// if cmd = 257 then
109390: LD_VAR 0 1
109394: PUSH
109395: LD_INT 257
109397: EQUAL
109398: IFFALSE 109419
// SetWarehouseGatheringPoint ( unit , x , y ) ;
109400: LD_VAR 0 2
109404: PPUSH
109405: LD_VAR 0 4
109409: PPUSH
109410: LD_VAR 0 5
109414: PPUSH
109415: CALL 107733 0 3
// end ;
109419: LD_VAR 0 6
109423: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109424: LD_INT 0
109426: PPUSH
109427: PPUSH
109428: PPUSH
109429: PPUSH
109430: PPUSH
109431: PPUSH
109432: PPUSH
109433: PPUSH
109434: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
109435: LD_VAR 0 1
109439: NOT
109440: PUSH
109441: LD_VAR 0 2
109445: PPUSH
109446: LD_VAR 0 3
109450: PPUSH
109451: CALL_OW 488
109455: NOT
109456: OR
109457: PUSH
109458: LD_VAR 0 4
109462: NOT
109463: OR
109464: IFFALSE 109468
// exit ;
109466: GO 109808
// list := [ ] ;
109468: LD_ADDR_VAR 0 13
109472: PUSH
109473: EMPTY
109474: ST_TO_ADDR
// if x - r < 0 then
109475: LD_VAR 0 2
109479: PUSH
109480: LD_VAR 0 4
109484: MINUS
109485: PUSH
109486: LD_INT 0
109488: LESS
109489: IFFALSE 109501
// min_x := 0 else
109491: LD_ADDR_VAR 0 7
109495: PUSH
109496: LD_INT 0
109498: ST_TO_ADDR
109499: GO 109517
// min_x := x - r ;
109501: LD_ADDR_VAR 0 7
109505: PUSH
109506: LD_VAR 0 2
109510: PUSH
109511: LD_VAR 0 4
109515: MINUS
109516: ST_TO_ADDR
// if y - r < 0 then
109517: LD_VAR 0 3
109521: PUSH
109522: LD_VAR 0 4
109526: MINUS
109527: PUSH
109528: LD_INT 0
109530: LESS
109531: IFFALSE 109543
// min_y := 0 else
109533: LD_ADDR_VAR 0 8
109537: PUSH
109538: LD_INT 0
109540: ST_TO_ADDR
109541: GO 109559
// min_y := y - r ;
109543: LD_ADDR_VAR 0 8
109547: PUSH
109548: LD_VAR 0 3
109552: PUSH
109553: LD_VAR 0 4
109557: MINUS
109558: ST_TO_ADDR
// max_x := x + r ;
109559: LD_ADDR_VAR 0 9
109563: PUSH
109564: LD_VAR 0 2
109568: PUSH
109569: LD_VAR 0 4
109573: PLUS
109574: ST_TO_ADDR
// max_y := y + r ;
109575: LD_ADDR_VAR 0 10
109579: PUSH
109580: LD_VAR 0 3
109584: PUSH
109585: LD_VAR 0 4
109589: PLUS
109590: ST_TO_ADDR
// for _x = min_x to max_x do
109591: LD_ADDR_VAR 0 11
109595: PUSH
109596: DOUBLE
109597: LD_VAR 0 7
109601: DEC
109602: ST_TO_ADDR
109603: LD_VAR 0 9
109607: PUSH
109608: FOR_TO
109609: IFFALSE 109726
// for _y = min_y to max_y do
109611: LD_ADDR_VAR 0 12
109615: PUSH
109616: DOUBLE
109617: LD_VAR 0 8
109621: DEC
109622: ST_TO_ADDR
109623: LD_VAR 0 10
109627: PUSH
109628: FOR_TO
109629: IFFALSE 109722
// begin if not ValidHex ( _x , _y ) then
109631: LD_VAR 0 11
109635: PPUSH
109636: LD_VAR 0 12
109640: PPUSH
109641: CALL_OW 488
109645: NOT
109646: IFFALSE 109650
// continue ;
109648: GO 109628
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109650: LD_VAR 0 11
109654: PPUSH
109655: LD_VAR 0 12
109659: PPUSH
109660: CALL_OW 351
109664: PUSH
109665: LD_VAR 0 11
109669: PPUSH
109670: LD_VAR 0 12
109674: PPUSH
109675: CALL_OW 554
109679: AND
109680: IFFALSE 109720
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109682: LD_ADDR_VAR 0 13
109686: PUSH
109687: LD_VAR 0 13
109691: PPUSH
109692: LD_VAR 0 13
109696: PUSH
109697: LD_INT 1
109699: PLUS
109700: PPUSH
109701: LD_VAR 0 11
109705: PUSH
109706: LD_VAR 0 12
109710: PUSH
109711: EMPTY
109712: LIST
109713: LIST
109714: PPUSH
109715: CALL_OW 2
109719: ST_TO_ADDR
// end ;
109720: GO 109628
109722: POP
109723: POP
109724: GO 109608
109726: POP
109727: POP
// if not list then
109728: LD_VAR 0 13
109732: NOT
109733: IFFALSE 109737
// exit ;
109735: GO 109808
// for i in list do
109737: LD_ADDR_VAR 0 6
109741: PUSH
109742: LD_VAR 0 13
109746: PUSH
109747: FOR_IN
109748: IFFALSE 109806
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
109750: LD_VAR 0 1
109754: PPUSH
109755: LD_STRING M
109757: PUSH
109758: LD_VAR 0 6
109762: PUSH
109763: LD_INT 1
109765: ARRAY
109766: PUSH
109767: LD_VAR 0 6
109771: PUSH
109772: LD_INT 2
109774: ARRAY
109775: PUSH
109776: LD_INT 0
109778: PUSH
109779: LD_INT 0
109781: PUSH
109782: LD_INT 0
109784: PUSH
109785: LD_INT 0
109787: PUSH
109788: EMPTY
109789: LIST
109790: LIST
109791: LIST
109792: LIST
109793: LIST
109794: LIST
109795: LIST
109796: PUSH
109797: EMPTY
109798: LIST
109799: PPUSH
109800: CALL_OW 447
109804: GO 109747
109806: POP
109807: POP
// end ;
109808: LD_VAR 0 5
109812: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
109813: LD_EXP 181
109817: NOT
109818: IFFALSE 109868
109820: GO 109822
109822: DISABLE
// begin initHack := true ;
109823: LD_ADDR_EXP 181
109827: PUSH
109828: LD_INT 1
109830: ST_TO_ADDR
// hackTanks := [ ] ;
109831: LD_ADDR_EXP 182
109835: PUSH
109836: EMPTY
109837: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
109838: LD_ADDR_EXP 183
109842: PUSH
109843: EMPTY
109844: ST_TO_ADDR
// hackLimit := 3 ;
109845: LD_ADDR_EXP 184
109849: PUSH
109850: LD_INT 3
109852: ST_TO_ADDR
// hackDist := 12 ;
109853: LD_ADDR_EXP 185
109857: PUSH
109858: LD_INT 12
109860: ST_TO_ADDR
// hackCounter := [ ] ;
109861: LD_ADDR_EXP 186
109865: PUSH
109866: EMPTY
109867: ST_TO_ADDR
// end ;
109868: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
109869: LD_EXP 181
109873: PUSH
109874: LD_INT 34
109876: PUSH
109877: LD_INT 99
109879: PUSH
109880: EMPTY
109881: LIST
109882: LIST
109883: PPUSH
109884: CALL_OW 69
109888: AND
109889: IFFALSE 110142
109891: GO 109893
109893: DISABLE
109894: LD_INT 0
109896: PPUSH
109897: PPUSH
// begin enable ;
109898: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
109899: LD_ADDR_VAR 0 1
109903: PUSH
109904: LD_INT 34
109906: PUSH
109907: LD_INT 99
109909: PUSH
109910: EMPTY
109911: LIST
109912: LIST
109913: PPUSH
109914: CALL_OW 69
109918: PUSH
109919: FOR_IN
109920: IFFALSE 110140
// begin if not i in hackTanks then
109922: LD_VAR 0 1
109926: PUSH
109927: LD_EXP 182
109931: IN
109932: NOT
109933: IFFALSE 110016
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
109935: LD_ADDR_EXP 182
109939: PUSH
109940: LD_EXP 182
109944: PPUSH
109945: LD_EXP 182
109949: PUSH
109950: LD_INT 1
109952: PLUS
109953: PPUSH
109954: LD_VAR 0 1
109958: PPUSH
109959: CALL_OW 1
109963: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
109964: LD_ADDR_EXP 183
109968: PUSH
109969: LD_EXP 183
109973: PPUSH
109974: LD_EXP 183
109978: PUSH
109979: LD_INT 1
109981: PLUS
109982: PPUSH
109983: EMPTY
109984: PPUSH
109985: CALL_OW 1
109989: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
109990: LD_ADDR_EXP 186
109994: PUSH
109995: LD_EXP 186
109999: PPUSH
110000: LD_EXP 186
110004: PUSH
110005: LD_INT 1
110007: PLUS
110008: PPUSH
110009: EMPTY
110010: PPUSH
110011: CALL_OW 1
110015: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110016: LD_VAR 0 1
110020: PPUSH
110021: CALL_OW 302
110025: NOT
110026: IFFALSE 110039
// begin HackUnlinkAll ( i ) ;
110028: LD_VAR 0 1
110032: PPUSH
110033: CALL 110145 0 1
// continue ;
110037: GO 109919
// end ; HackCheckCapturedStatus ( i ) ;
110039: LD_VAR 0 1
110043: PPUSH
110044: CALL 110588 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110048: LD_ADDR_VAR 0 2
110052: PUSH
110053: LD_INT 81
110055: PUSH
110056: LD_VAR 0 1
110060: PPUSH
110061: CALL_OW 255
110065: PUSH
110066: EMPTY
110067: LIST
110068: LIST
110069: PUSH
110070: LD_INT 33
110072: PUSH
110073: LD_INT 3
110075: PUSH
110076: EMPTY
110077: LIST
110078: LIST
110079: PUSH
110080: LD_INT 91
110082: PUSH
110083: LD_VAR 0 1
110087: PUSH
110088: LD_EXP 185
110092: PUSH
110093: EMPTY
110094: LIST
110095: LIST
110096: LIST
110097: PUSH
110098: LD_INT 50
110100: PUSH
110101: EMPTY
110102: LIST
110103: PUSH
110104: EMPTY
110105: LIST
110106: LIST
110107: LIST
110108: LIST
110109: PPUSH
110110: CALL_OW 69
110114: ST_TO_ADDR
// if not tmp then
110115: LD_VAR 0 2
110119: NOT
110120: IFFALSE 110124
// continue ;
110122: GO 109919
// HackLink ( i , tmp ) ;
110124: LD_VAR 0 1
110128: PPUSH
110129: LD_VAR 0 2
110133: PPUSH
110134: CALL 110281 0 2
// end ;
110138: GO 109919
110140: POP
110141: POP
// end ;
110142: PPOPN 2
110144: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110145: LD_INT 0
110147: PPUSH
110148: PPUSH
110149: PPUSH
// if not hack in hackTanks then
110150: LD_VAR 0 1
110154: PUSH
110155: LD_EXP 182
110159: IN
110160: NOT
110161: IFFALSE 110165
// exit ;
110163: GO 110276
// index := GetElementIndex ( hackTanks , hack ) ;
110165: LD_ADDR_VAR 0 4
110169: PUSH
110170: LD_EXP 182
110174: PPUSH
110175: LD_VAR 0 1
110179: PPUSH
110180: CALL 56770 0 2
110184: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110185: LD_EXP 183
110189: PUSH
110190: LD_VAR 0 4
110194: ARRAY
110195: IFFALSE 110276
// begin for i in hackTanksCaptured [ index ] do
110197: LD_ADDR_VAR 0 3
110201: PUSH
110202: LD_EXP 183
110206: PUSH
110207: LD_VAR 0 4
110211: ARRAY
110212: PUSH
110213: FOR_IN
110214: IFFALSE 110240
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110216: LD_VAR 0 3
110220: PUSH
110221: LD_INT 1
110223: ARRAY
110224: PPUSH
110225: LD_VAR 0 3
110229: PUSH
110230: LD_INT 2
110232: ARRAY
110233: PPUSH
110234: CALL_OW 235
110238: GO 110213
110240: POP
110241: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110242: LD_ADDR_EXP 183
110246: PUSH
110247: LD_EXP 183
110251: PPUSH
110252: LD_VAR 0 4
110256: PPUSH
110257: EMPTY
110258: PPUSH
110259: CALL_OW 1
110263: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110264: LD_VAR 0 1
110268: PPUSH
110269: LD_INT 0
110271: PPUSH
110272: CALL_OW 505
// end ; end ;
110276: LD_VAR 0 2
110280: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110281: LD_INT 0
110283: PPUSH
110284: PPUSH
110285: PPUSH
// if not hack in hackTanks or not vehicles then
110286: LD_VAR 0 1
110290: PUSH
110291: LD_EXP 182
110295: IN
110296: NOT
110297: PUSH
110298: LD_VAR 0 2
110302: NOT
110303: OR
110304: IFFALSE 110308
// exit ;
110306: GO 110583
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110308: LD_ADDR_VAR 0 2
110312: PUSH
110313: LD_VAR 0 1
110317: PPUSH
110318: LD_VAR 0 2
110322: PPUSH
110323: LD_INT 1
110325: PPUSH
110326: LD_INT 1
110328: PPUSH
110329: CALL 57420 0 4
110333: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110334: LD_ADDR_VAR 0 5
110338: PUSH
110339: LD_EXP 182
110343: PPUSH
110344: LD_VAR 0 1
110348: PPUSH
110349: CALL 56770 0 2
110353: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110354: LD_EXP 183
110358: PUSH
110359: LD_VAR 0 5
110363: ARRAY
110364: PUSH
110365: LD_EXP 184
110369: LESS
110370: IFFALSE 110559
// begin for i := 1 to vehicles do
110372: LD_ADDR_VAR 0 4
110376: PUSH
110377: DOUBLE
110378: LD_INT 1
110380: DEC
110381: ST_TO_ADDR
110382: LD_VAR 0 2
110386: PUSH
110387: FOR_TO
110388: IFFALSE 110557
// begin if hackTanksCaptured [ index ] = hackLimit then
110390: LD_EXP 183
110394: PUSH
110395: LD_VAR 0 5
110399: ARRAY
110400: PUSH
110401: LD_EXP 184
110405: EQUAL
110406: IFFALSE 110410
// break ;
110408: GO 110557
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110410: LD_ADDR_EXP 186
110414: PUSH
110415: LD_EXP 186
110419: PPUSH
110420: LD_VAR 0 5
110424: PPUSH
110425: LD_EXP 186
110429: PUSH
110430: LD_VAR 0 5
110434: ARRAY
110435: PUSH
110436: LD_INT 1
110438: PLUS
110439: PPUSH
110440: CALL_OW 1
110444: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110445: LD_ADDR_EXP 183
110449: PUSH
110450: LD_EXP 183
110454: PPUSH
110455: LD_VAR 0 5
110459: PUSH
110460: LD_EXP 183
110464: PUSH
110465: LD_VAR 0 5
110469: ARRAY
110470: PUSH
110471: LD_INT 1
110473: PLUS
110474: PUSH
110475: EMPTY
110476: LIST
110477: LIST
110478: PPUSH
110479: LD_VAR 0 2
110483: PUSH
110484: LD_VAR 0 4
110488: ARRAY
110489: PUSH
110490: LD_VAR 0 2
110494: PUSH
110495: LD_VAR 0 4
110499: ARRAY
110500: PPUSH
110501: CALL_OW 255
110505: PUSH
110506: EMPTY
110507: LIST
110508: LIST
110509: PPUSH
110510: CALL 56985 0 3
110514: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110515: LD_VAR 0 2
110519: PUSH
110520: LD_VAR 0 4
110524: ARRAY
110525: PPUSH
110526: LD_VAR 0 1
110530: PPUSH
110531: CALL_OW 255
110535: PPUSH
110536: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110540: LD_VAR 0 2
110544: PUSH
110545: LD_VAR 0 4
110549: ARRAY
110550: PPUSH
110551: CALL_OW 141
// end ;
110555: GO 110387
110557: POP
110558: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110559: LD_VAR 0 1
110563: PPUSH
110564: LD_EXP 183
110568: PUSH
110569: LD_VAR 0 5
110573: ARRAY
110574: PUSH
110575: LD_INT 0
110577: PLUS
110578: PPUSH
110579: CALL_OW 505
// end ;
110583: LD_VAR 0 3
110587: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110588: LD_INT 0
110590: PPUSH
110591: PPUSH
110592: PPUSH
110593: PPUSH
// if not hack in hackTanks then
110594: LD_VAR 0 1
110598: PUSH
110599: LD_EXP 182
110603: IN
110604: NOT
110605: IFFALSE 110609
// exit ;
110607: GO 110849
// index := GetElementIndex ( hackTanks , hack ) ;
110609: LD_ADDR_VAR 0 4
110613: PUSH
110614: LD_EXP 182
110618: PPUSH
110619: LD_VAR 0 1
110623: PPUSH
110624: CALL 56770 0 2
110628: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
110629: LD_ADDR_VAR 0 3
110633: PUSH
110634: DOUBLE
110635: LD_EXP 183
110639: PUSH
110640: LD_VAR 0 4
110644: ARRAY
110645: INC
110646: ST_TO_ADDR
110647: LD_INT 1
110649: PUSH
110650: FOR_DOWNTO
110651: IFFALSE 110823
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
110653: LD_ADDR_VAR 0 5
110657: PUSH
110658: LD_EXP 183
110662: PUSH
110663: LD_VAR 0 4
110667: ARRAY
110668: PUSH
110669: LD_VAR 0 3
110673: ARRAY
110674: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
110675: LD_VAR 0 5
110679: PUSH
110680: LD_INT 1
110682: ARRAY
110683: PPUSH
110684: CALL_OW 302
110688: NOT
110689: PUSH
110690: LD_VAR 0 5
110694: PUSH
110695: LD_INT 1
110697: ARRAY
110698: PPUSH
110699: CALL_OW 255
110703: PUSH
110704: LD_VAR 0 1
110708: PPUSH
110709: CALL_OW 255
110713: NONEQUAL
110714: OR
110715: IFFALSE 110821
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
110717: LD_VAR 0 5
110721: PUSH
110722: LD_INT 1
110724: ARRAY
110725: PPUSH
110726: CALL_OW 305
110730: PUSH
110731: LD_VAR 0 5
110735: PUSH
110736: LD_INT 1
110738: ARRAY
110739: PPUSH
110740: CALL_OW 255
110744: PUSH
110745: LD_VAR 0 1
110749: PPUSH
110750: CALL_OW 255
110754: EQUAL
110755: AND
110756: IFFALSE 110780
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
110758: LD_VAR 0 5
110762: PUSH
110763: LD_INT 1
110765: ARRAY
110766: PPUSH
110767: LD_VAR 0 5
110771: PUSH
110772: LD_INT 2
110774: ARRAY
110775: PPUSH
110776: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
110780: LD_ADDR_EXP 183
110784: PUSH
110785: LD_EXP 183
110789: PPUSH
110790: LD_VAR 0 4
110794: PPUSH
110795: LD_EXP 183
110799: PUSH
110800: LD_VAR 0 4
110804: ARRAY
110805: PPUSH
110806: LD_VAR 0 3
110810: PPUSH
110811: CALL_OW 3
110815: PPUSH
110816: CALL_OW 1
110820: ST_TO_ADDR
// end ; end ;
110821: GO 110650
110823: POP
110824: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110825: LD_VAR 0 1
110829: PPUSH
110830: LD_EXP 183
110834: PUSH
110835: LD_VAR 0 4
110839: ARRAY
110840: PUSH
110841: LD_INT 0
110843: PLUS
110844: PPUSH
110845: CALL_OW 505
// end ;
110849: LD_VAR 0 2
110853: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
110854: LD_INT 0
110856: PPUSH
110857: PPUSH
110858: PPUSH
110859: PPUSH
// if not hack in hackTanks then
110860: LD_VAR 0 1
110864: PUSH
110865: LD_EXP 182
110869: IN
110870: NOT
110871: IFFALSE 110875
// exit ;
110873: GO 110960
// index := GetElementIndex ( hackTanks , hack ) ;
110875: LD_ADDR_VAR 0 5
110879: PUSH
110880: LD_EXP 182
110884: PPUSH
110885: LD_VAR 0 1
110889: PPUSH
110890: CALL 56770 0 2
110894: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
110895: LD_ADDR_VAR 0 4
110899: PUSH
110900: DOUBLE
110901: LD_INT 1
110903: DEC
110904: ST_TO_ADDR
110905: LD_EXP 183
110909: PUSH
110910: LD_VAR 0 5
110914: ARRAY
110915: PUSH
110916: FOR_TO
110917: IFFALSE 110958
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
110919: LD_EXP 183
110923: PUSH
110924: LD_VAR 0 5
110928: ARRAY
110929: PUSH
110930: LD_VAR 0 4
110934: ARRAY
110935: PUSH
110936: LD_INT 1
110938: ARRAY
110939: PUSH
110940: LD_VAR 0 2
110944: EQUAL
110945: IFFALSE 110956
// KillUnit ( vehicle ) ;
110947: LD_VAR 0 2
110951: PPUSH
110952: CALL_OW 66
110956: GO 110916
110958: POP
110959: POP
// end ;
110960: LD_VAR 0 3
110964: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
110965: LD_EXP 187
110969: NOT
110970: IFFALSE 111005
110972: GO 110974
110974: DISABLE
// begin initMiner := true ;
110975: LD_ADDR_EXP 187
110979: PUSH
110980: LD_INT 1
110982: ST_TO_ADDR
// minersList := [ ] ;
110983: LD_ADDR_EXP 188
110987: PUSH
110988: EMPTY
110989: ST_TO_ADDR
// minerMinesList := [ ] ;
110990: LD_ADDR_EXP 189
110994: PUSH
110995: EMPTY
110996: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
110997: LD_ADDR_EXP 190
111001: PUSH
111002: LD_INT 5
111004: ST_TO_ADDR
// end ;
111005: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111006: LD_EXP 187
111010: PUSH
111011: LD_INT 34
111013: PUSH
111014: LD_INT 81
111016: PUSH
111017: EMPTY
111018: LIST
111019: LIST
111020: PPUSH
111021: CALL_OW 69
111025: AND
111026: IFFALSE 111487
111028: GO 111030
111030: DISABLE
111031: LD_INT 0
111033: PPUSH
111034: PPUSH
111035: PPUSH
111036: PPUSH
// begin enable ;
111037: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111038: LD_ADDR_VAR 0 1
111042: PUSH
111043: LD_INT 34
111045: PUSH
111046: LD_INT 81
111048: PUSH
111049: EMPTY
111050: LIST
111051: LIST
111052: PPUSH
111053: CALL_OW 69
111057: PUSH
111058: FOR_IN
111059: IFFALSE 111131
// begin if not i in minersList then
111061: LD_VAR 0 1
111065: PUSH
111066: LD_EXP 188
111070: IN
111071: NOT
111072: IFFALSE 111129
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111074: LD_ADDR_EXP 188
111078: PUSH
111079: LD_EXP 188
111083: PPUSH
111084: LD_EXP 188
111088: PUSH
111089: LD_INT 1
111091: PLUS
111092: PPUSH
111093: LD_VAR 0 1
111097: PPUSH
111098: CALL_OW 1
111102: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111103: LD_ADDR_EXP 189
111107: PUSH
111108: LD_EXP 189
111112: PPUSH
111113: LD_EXP 189
111117: PUSH
111118: LD_INT 1
111120: PLUS
111121: PPUSH
111122: EMPTY
111123: PPUSH
111124: CALL_OW 1
111128: ST_TO_ADDR
// end end ;
111129: GO 111058
111131: POP
111132: POP
// for i := minerMinesList downto 1 do
111133: LD_ADDR_VAR 0 1
111137: PUSH
111138: DOUBLE
111139: LD_EXP 189
111143: INC
111144: ST_TO_ADDR
111145: LD_INT 1
111147: PUSH
111148: FOR_DOWNTO
111149: IFFALSE 111485
// begin if IsLive ( minersList [ i ] ) then
111151: LD_EXP 188
111155: PUSH
111156: LD_VAR 0 1
111160: ARRAY
111161: PPUSH
111162: CALL_OW 300
111166: IFFALSE 111194
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111168: LD_EXP 188
111172: PUSH
111173: LD_VAR 0 1
111177: ARRAY
111178: PPUSH
111179: LD_EXP 189
111183: PUSH
111184: LD_VAR 0 1
111188: ARRAY
111189: PPUSH
111190: CALL_OW 505
// if not minerMinesList [ i ] then
111194: LD_EXP 189
111198: PUSH
111199: LD_VAR 0 1
111203: ARRAY
111204: NOT
111205: IFFALSE 111209
// continue ;
111207: GO 111148
// for j := minerMinesList [ i ] downto 1 do
111209: LD_ADDR_VAR 0 2
111213: PUSH
111214: DOUBLE
111215: LD_EXP 189
111219: PUSH
111220: LD_VAR 0 1
111224: ARRAY
111225: INC
111226: ST_TO_ADDR
111227: LD_INT 1
111229: PUSH
111230: FOR_DOWNTO
111231: IFFALSE 111481
// begin side := GetSide ( minersList [ i ] ) ;
111233: LD_ADDR_VAR 0 3
111237: PUSH
111238: LD_EXP 188
111242: PUSH
111243: LD_VAR 0 1
111247: ARRAY
111248: PPUSH
111249: CALL_OW 255
111253: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111254: LD_ADDR_VAR 0 4
111258: PUSH
111259: LD_EXP 189
111263: PUSH
111264: LD_VAR 0 1
111268: ARRAY
111269: PUSH
111270: LD_VAR 0 2
111274: ARRAY
111275: PUSH
111276: LD_INT 1
111278: ARRAY
111279: PPUSH
111280: LD_EXP 189
111284: PUSH
111285: LD_VAR 0 1
111289: ARRAY
111290: PUSH
111291: LD_VAR 0 2
111295: ARRAY
111296: PUSH
111297: LD_INT 2
111299: ARRAY
111300: PPUSH
111301: CALL_OW 428
111305: ST_TO_ADDR
// if not tmp then
111306: LD_VAR 0 4
111310: NOT
111311: IFFALSE 111315
// continue ;
111313: GO 111230
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111315: LD_VAR 0 4
111319: PUSH
111320: LD_INT 81
111322: PUSH
111323: LD_VAR 0 3
111327: PUSH
111328: EMPTY
111329: LIST
111330: LIST
111331: PPUSH
111332: CALL_OW 69
111336: IN
111337: PUSH
111338: LD_EXP 189
111342: PUSH
111343: LD_VAR 0 1
111347: ARRAY
111348: PUSH
111349: LD_VAR 0 2
111353: ARRAY
111354: PUSH
111355: LD_INT 1
111357: ARRAY
111358: PPUSH
111359: LD_EXP 189
111363: PUSH
111364: LD_VAR 0 1
111368: ARRAY
111369: PUSH
111370: LD_VAR 0 2
111374: ARRAY
111375: PUSH
111376: LD_INT 2
111378: ARRAY
111379: PPUSH
111380: CALL_OW 458
111384: AND
111385: IFFALSE 111479
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111387: LD_EXP 189
111391: PUSH
111392: LD_VAR 0 1
111396: ARRAY
111397: PUSH
111398: LD_VAR 0 2
111402: ARRAY
111403: PUSH
111404: LD_INT 1
111406: ARRAY
111407: PPUSH
111408: LD_EXP 189
111412: PUSH
111413: LD_VAR 0 1
111417: ARRAY
111418: PUSH
111419: LD_VAR 0 2
111423: ARRAY
111424: PUSH
111425: LD_INT 2
111427: ARRAY
111428: PPUSH
111429: LD_VAR 0 3
111433: PPUSH
111434: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111438: LD_ADDR_EXP 189
111442: PUSH
111443: LD_EXP 189
111447: PPUSH
111448: LD_VAR 0 1
111452: PPUSH
111453: LD_EXP 189
111457: PUSH
111458: LD_VAR 0 1
111462: ARRAY
111463: PPUSH
111464: LD_VAR 0 2
111468: PPUSH
111469: CALL_OW 3
111473: PPUSH
111474: CALL_OW 1
111478: ST_TO_ADDR
// end ; end ;
111479: GO 111230
111481: POP
111482: POP
// end ;
111483: GO 111148
111485: POP
111486: POP
// end ;
111487: PPOPN 4
111489: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111490: LD_INT 0
111492: PPUSH
111493: PPUSH
// result := false ;
111494: LD_ADDR_VAR 0 4
111498: PUSH
111499: LD_INT 0
111501: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111502: LD_VAR 0 1
111506: PPUSH
111507: CALL_OW 264
111511: PUSH
111512: LD_INT 81
111514: EQUAL
111515: NOT
111516: IFFALSE 111520
// exit ;
111518: GO 111760
// index := GetElementIndex ( minersList , unit ) ;
111520: LD_ADDR_VAR 0 5
111524: PUSH
111525: LD_EXP 188
111529: PPUSH
111530: LD_VAR 0 1
111534: PPUSH
111535: CALL 56770 0 2
111539: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111540: LD_EXP 189
111544: PUSH
111545: LD_VAR 0 5
111549: ARRAY
111550: PUSH
111551: LD_EXP 190
111555: GREATEREQUAL
111556: IFFALSE 111560
// exit ;
111558: GO 111760
// ComMoveXY ( unit , x , y ) ;
111560: LD_VAR 0 1
111564: PPUSH
111565: LD_VAR 0 2
111569: PPUSH
111570: LD_VAR 0 3
111574: PPUSH
111575: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111579: LD_INT 35
111581: PPUSH
111582: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111586: LD_VAR 0 1
111590: PPUSH
111591: LD_VAR 0 2
111595: PPUSH
111596: LD_VAR 0 3
111600: PPUSH
111601: CALL 88033 0 3
111605: NOT
111606: PUSH
111607: LD_VAR 0 1
111611: PPUSH
111612: CALL_OW 314
111616: AND
111617: IFFALSE 111621
// exit ;
111619: GO 111760
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
111621: LD_VAR 0 2
111625: PPUSH
111626: LD_VAR 0 3
111630: PPUSH
111631: CALL_OW 428
111635: PUSH
111636: LD_VAR 0 1
111640: EQUAL
111641: PUSH
111642: LD_VAR 0 1
111646: PPUSH
111647: CALL_OW 314
111651: NOT
111652: AND
111653: IFFALSE 111579
// PlaySoundXY ( x , y , PlantMine ) ;
111655: LD_VAR 0 2
111659: PPUSH
111660: LD_VAR 0 3
111664: PPUSH
111665: LD_STRING PlantMine
111667: PPUSH
111668: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
111672: LD_VAR 0 2
111676: PPUSH
111677: LD_VAR 0 3
111681: PPUSH
111682: LD_VAR 0 1
111686: PPUSH
111687: CALL_OW 255
111691: PPUSH
111692: LD_INT 0
111694: PPUSH
111695: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
111699: LD_ADDR_EXP 189
111703: PUSH
111704: LD_EXP 189
111708: PPUSH
111709: LD_VAR 0 5
111713: PUSH
111714: LD_EXP 189
111718: PUSH
111719: LD_VAR 0 5
111723: ARRAY
111724: PUSH
111725: LD_INT 1
111727: PLUS
111728: PUSH
111729: EMPTY
111730: LIST
111731: LIST
111732: PPUSH
111733: LD_VAR 0 2
111737: PUSH
111738: LD_VAR 0 3
111742: PUSH
111743: EMPTY
111744: LIST
111745: LIST
111746: PPUSH
111747: CALL 56985 0 3
111751: ST_TO_ADDR
// result := true ;
111752: LD_ADDR_VAR 0 4
111756: PUSH
111757: LD_INT 1
111759: ST_TO_ADDR
// end ;
111760: LD_VAR 0 4
111764: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
111765: LD_INT 0
111767: PPUSH
111768: PPUSH
111769: PPUSH
// if not unit in minersList then
111770: LD_VAR 0 1
111774: PUSH
111775: LD_EXP 188
111779: IN
111780: NOT
111781: IFFALSE 111785
// exit ;
111783: GO 112177
// index := GetElementIndex ( minersList , unit ) ;
111785: LD_ADDR_VAR 0 6
111789: PUSH
111790: LD_EXP 188
111794: PPUSH
111795: LD_VAR 0 1
111799: PPUSH
111800: CALL 56770 0 2
111804: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
111805: LD_ADDR_VAR 0 5
111809: PUSH
111810: DOUBLE
111811: LD_EXP 189
111815: PUSH
111816: LD_VAR 0 6
111820: ARRAY
111821: INC
111822: ST_TO_ADDR
111823: LD_INT 1
111825: PUSH
111826: FOR_DOWNTO
111827: IFFALSE 111988
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
111829: LD_EXP 189
111833: PUSH
111834: LD_VAR 0 6
111838: ARRAY
111839: PUSH
111840: LD_VAR 0 5
111844: ARRAY
111845: PUSH
111846: LD_INT 1
111848: ARRAY
111849: PUSH
111850: LD_VAR 0 2
111854: EQUAL
111855: PUSH
111856: LD_EXP 189
111860: PUSH
111861: LD_VAR 0 6
111865: ARRAY
111866: PUSH
111867: LD_VAR 0 5
111871: ARRAY
111872: PUSH
111873: LD_INT 2
111875: ARRAY
111876: PUSH
111877: LD_VAR 0 3
111881: EQUAL
111882: AND
111883: IFFALSE 111986
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111885: LD_EXP 189
111889: PUSH
111890: LD_VAR 0 6
111894: ARRAY
111895: PUSH
111896: LD_VAR 0 5
111900: ARRAY
111901: PUSH
111902: LD_INT 1
111904: ARRAY
111905: PPUSH
111906: LD_EXP 189
111910: PUSH
111911: LD_VAR 0 6
111915: ARRAY
111916: PUSH
111917: LD_VAR 0 5
111921: ARRAY
111922: PUSH
111923: LD_INT 2
111925: ARRAY
111926: PPUSH
111927: LD_VAR 0 1
111931: PPUSH
111932: CALL_OW 255
111936: PPUSH
111937: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111941: LD_ADDR_EXP 189
111945: PUSH
111946: LD_EXP 189
111950: PPUSH
111951: LD_VAR 0 6
111955: PPUSH
111956: LD_EXP 189
111960: PUSH
111961: LD_VAR 0 6
111965: ARRAY
111966: PPUSH
111967: LD_VAR 0 5
111971: PPUSH
111972: CALL_OW 3
111976: PPUSH
111977: CALL_OW 1
111981: ST_TO_ADDR
// exit ;
111982: POP
111983: POP
111984: GO 112177
// end ; end ;
111986: GO 111826
111988: POP
111989: POP
// for i := minerMinesList [ index ] downto 1 do
111990: LD_ADDR_VAR 0 5
111994: PUSH
111995: DOUBLE
111996: LD_EXP 189
112000: PUSH
112001: LD_VAR 0 6
112005: ARRAY
112006: INC
112007: ST_TO_ADDR
112008: LD_INT 1
112010: PUSH
112011: FOR_DOWNTO
112012: IFFALSE 112175
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112014: LD_EXP 189
112018: PUSH
112019: LD_VAR 0 6
112023: ARRAY
112024: PUSH
112025: LD_VAR 0 5
112029: ARRAY
112030: PUSH
112031: LD_INT 1
112033: ARRAY
112034: PPUSH
112035: LD_EXP 189
112039: PUSH
112040: LD_VAR 0 6
112044: ARRAY
112045: PUSH
112046: LD_VAR 0 5
112050: ARRAY
112051: PUSH
112052: LD_INT 2
112054: ARRAY
112055: PPUSH
112056: LD_VAR 0 2
112060: PPUSH
112061: LD_VAR 0 3
112065: PPUSH
112066: CALL_OW 298
112070: PUSH
112071: LD_INT 6
112073: LESS
112074: IFFALSE 112173
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112076: LD_EXP 189
112080: PUSH
112081: LD_VAR 0 6
112085: ARRAY
112086: PUSH
112087: LD_VAR 0 5
112091: ARRAY
112092: PUSH
112093: LD_INT 1
112095: ARRAY
112096: PPUSH
112097: LD_EXP 189
112101: PUSH
112102: LD_VAR 0 6
112106: ARRAY
112107: PUSH
112108: LD_VAR 0 5
112112: ARRAY
112113: PUSH
112114: LD_INT 2
112116: ARRAY
112117: PPUSH
112118: LD_VAR 0 1
112122: PPUSH
112123: CALL_OW 255
112127: PPUSH
112128: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112132: LD_ADDR_EXP 189
112136: PUSH
112137: LD_EXP 189
112141: PPUSH
112142: LD_VAR 0 6
112146: PPUSH
112147: LD_EXP 189
112151: PUSH
112152: LD_VAR 0 6
112156: ARRAY
112157: PPUSH
112158: LD_VAR 0 5
112162: PPUSH
112163: CALL_OW 3
112167: PPUSH
112168: CALL_OW 1
112172: ST_TO_ADDR
// end ; end ;
112173: GO 112011
112175: POP
112176: POP
// end ;
112177: LD_VAR 0 4
112181: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112182: LD_INT 0
112184: PPUSH
112185: PPUSH
112186: PPUSH
112187: PPUSH
112188: PPUSH
112189: PPUSH
112190: PPUSH
112191: PPUSH
112192: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112193: LD_VAR 0 1
112197: PPUSH
112198: CALL_OW 264
112202: PUSH
112203: LD_INT 81
112205: EQUAL
112206: NOT
112207: PUSH
112208: LD_VAR 0 1
112212: PUSH
112213: LD_EXP 188
112217: IN
112218: NOT
112219: OR
112220: IFFALSE 112224
// exit ;
112222: GO 112546
// index := GetElementIndex ( minersList , unit ) ;
112224: LD_ADDR_VAR 0 6
112228: PUSH
112229: LD_EXP 188
112233: PPUSH
112234: LD_VAR 0 1
112238: PPUSH
112239: CALL 56770 0 2
112243: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112244: LD_ADDR_VAR 0 8
112248: PUSH
112249: LD_EXP 190
112253: PUSH
112254: LD_EXP 189
112258: PUSH
112259: LD_VAR 0 6
112263: ARRAY
112264: MINUS
112265: ST_TO_ADDR
// if not minesFreeAmount then
112266: LD_VAR 0 8
112270: NOT
112271: IFFALSE 112275
// exit ;
112273: GO 112546
// tmp := [ ] ;
112275: LD_ADDR_VAR 0 7
112279: PUSH
112280: EMPTY
112281: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112282: LD_ADDR_VAR 0 5
112286: PUSH
112287: DOUBLE
112288: LD_INT 1
112290: DEC
112291: ST_TO_ADDR
112292: LD_VAR 0 8
112296: PUSH
112297: FOR_TO
112298: IFFALSE 112493
// begin _d := rand ( 0 , 5 ) ;
112300: LD_ADDR_VAR 0 11
112304: PUSH
112305: LD_INT 0
112307: PPUSH
112308: LD_INT 5
112310: PPUSH
112311: CALL_OW 12
112315: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112316: LD_ADDR_VAR 0 12
112320: PUSH
112321: LD_INT 2
112323: PPUSH
112324: LD_INT 6
112326: PPUSH
112327: CALL_OW 12
112331: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112332: LD_ADDR_VAR 0 9
112336: PUSH
112337: LD_VAR 0 2
112341: PPUSH
112342: LD_VAR 0 11
112346: PPUSH
112347: LD_VAR 0 12
112351: PPUSH
112352: CALL_OW 272
112356: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112357: LD_ADDR_VAR 0 10
112361: PUSH
112362: LD_VAR 0 3
112366: PPUSH
112367: LD_VAR 0 11
112371: PPUSH
112372: LD_VAR 0 12
112376: PPUSH
112377: CALL_OW 273
112381: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112382: LD_VAR 0 9
112386: PPUSH
112387: LD_VAR 0 10
112391: PPUSH
112392: CALL_OW 488
112396: PUSH
112397: LD_VAR 0 9
112401: PUSH
112402: LD_VAR 0 10
112406: PUSH
112407: EMPTY
112408: LIST
112409: LIST
112410: PUSH
112411: LD_VAR 0 7
112415: IN
112416: NOT
112417: AND
112418: PUSH
112419: LD_VAR 0 9
112423: PPUSH
112424: LD_VAR 0 10
112428: PPUSH
112429: CALL_OW 458
112433: NOT
112434: AND
112435: IFFALSE 112477
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112437: LD_ADDR_VAR 0 7
112441: PUSH
112442: LD_VAR 0 7
112446: PPUSH
112447: LD_VAR 0 7
112451: PUSH
112452: LD_INT 1
112454: PLUS
112455: PPUSH
112456: LD_VAR 0 9
112460: PUSH
112461: LD_VAR 0 10
112465: PUSH
112466: EMPTY
112467: LIST
112468: LIST
112469: PPUSH
112470: CALL_OW 1
112474: ST_TO_ADDR
112475: GO 112491
// i := i - 1 ;
112477: LD_ADDR_VAR 0 5
112481: PUSH
112482: LD_VAR 0 5
112486: PUSH
112487: LD_INT 1
112489: MINUS
112490: ST_TO_ADDR
// end ;
112491: GO 112297
112493: POP
112494: POP
// for i in tmp do
112495: LD_ADDR_VAR 0 5
112499: PUSH
112500: LD_VAR 0 7
112504: PUSH
112505: FOR_IN
112506: IFFALSE 112544
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112508: LD_VAR 0 1
112512: PPUSH
112513: LD_VAR 0 5
112517: PUSH
112518: LD_INT 1
112520: ARRAY
112521: PPUSH
112522: LD_VAR 0 5
112526: PUSH
112527: LD_INT 2
112529: ARRAY
112530: PPUSH
112531: CALL 111490 0 3
112535: NOT
112536: IFFALSE 112542
// exit ;
112538: POP
112539: POP
112540: GO 112546
112542: GO 112505
112544: POP
112545: POP
// end ;
112546: LD_VAR 0 4
112550: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
112551: LD_INT 0
112553: PPUSH
112554: PPUSH
112555: PPUSH
112556: PPUSH
112557: PPUSH
112558: PPUSH
112559: PPUSH
// if not GetClass ( unit ) = class_sniper then
112560: LD_VAR 0 1
112564: PPUSH
112565: CALL_OW 257
112569: PUSH
112570: LD_INT 5
112572: EQUAL
112573: NOT
112574: IFFALSE 112578
// exit ;
112576: GO 112966
// dist := 8 ;
112578: LD_ADDR_VAR 0 5
112582: PUSH
112583: LD_INT 8
112585: ST_TO_ADDR
// viewRange := 12 ;
112586: LD_ADDR_VAR 0 7
112590: PUSH
112591: LD_INT 12
112593: ST_TO_ADDR
// side := GetSide ( unit ) ;
112594: LD_ADDR_VAR 0 6
112598: PUSH
112599: LD_VAR 0 1
112603: PPUSH
112604: CALL_OW 255
112608: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
112609: LD_INT 61
112611: PPUSH
112612: LD_VAR 0 6
112616: PPUSH
112617: CALL_OW 321
112621: PUSH
112622: LD_INT 2
112624: EQUAL
112625: IFFALSE 112635
// viewRange := 16 ;
112627: LD_ADDR_VAR 0 7
112631: PUSH
112632: LD_INT 16
112634: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
112635: LD_VAR 0 1
112639: PPUSH
112640: LD_VAR 0 2
112644: PPUSH
112645: LD_VAR 0 3
112649: PPUSH
112650: CALL_OW 297
112654: PUSH
112655: LD_VAR 0 5
112659: GREATER
112660: IFFALSE 112739
// begin ComMoveXY ( unit , x , y ) ;
112662: LD_VAR 0 1
112666: PPUSH
112667: LD_VAR 0 2
112671: PPUSH
112672: LD_VAR 0 3
112676: PPUSH
112677: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112681: LD_INT 35
112683: PPUSH
112684: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
112688: LD_VAR 0 1
112692: PPUSH
112693: LD_VAR 0 2
112697: PPUSH
112698: LD_VAR 0 3
112702: PPUSH
112703: CALL 88033 0 3
112707: NOT
112708: IFFALSE 112712
// exit ;
112710: GO 112966
// until GetDistUnitXY ( unit , x , y ) < dist ;
112712: LD_VAR 0 1
112716: PPUSH
112717: LD_VAR 0 2
112721: PPUSH
112722: LD_VAR 0 3
112726: PPUSH
112727: CALL_OW 297
112731: PUSH
112732: LD_VAR 0 5
112736: LESS
112737: IFFALSE 112681
// end ; ComTurnXY ( unit , x , y ) ;
112739: LD_VAR 0 1
112743: PPUSH
112744: LD_VAR 0 2
112748: PPUSH
112749: LD_VAR 0 3
112753: PPUSH
112754: CALL_OW 118
// wait ( 5 ) ;
112758: LD_INT 5
112760: PPUSH
112761: CALL_OW 67
// _d := GetDir ( unit ) ;
112765: LD_ADDR_VAR 0 10
112769: PUSH
112770: LD_VAR 0 1
112774: PPUSH
112775: CALL_OW 254
112779: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
112780: LD_ADDR_VAR 0 8
112784: PUSH
112785: LD_VAR 0 1
112789: PPUSH
112790: CALL_OW 250
112794: PPUSH
112795: LD_VAR 0 10
112799: PPUSH
112800: LD_VAR 0 5
112804: PPUSH
112805: CALL_OW 272
112809: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
112810: LD_ADDR_VAR 0 9
112814: PUSH
112815: LD_VAR 0 1
112819: PPUSH
112820: CALL_OW 251
112824: PPUSH
112825: LD_VAR 0 10
112829: PPUSH
112830: LD_VAR 0 5
112834: PPUSH
112835: CALL_OW 273
112839: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
112840: LD_VAR 0 8
112844: PPUSH
112845: LD_VAR 0 9
112849: PPUSH
112850: CALL_OW 488
112854: NOT
112855: IFFALSE 112859
// exit ;
112857: GO 112966
// ComAnimCustom ( unit , 1 ) ;
112859: LD_VAR 0 1
112863: PPUSH
112864: LD_INT 1
112866: PPUSH
112867: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
112871: LD_VAR 0 8
112875: PPUSH
112876: LD_VAR 0 9
112880: PPUSH
112881: LD_VAR 0 6
112885: PPUSH
112886: LD_VAR 0 7
112890: PPUSH
112891: CALL_OW 330
// repeat wait ( 1 ) ;
112895: LD_INT 1
112897: PPUSH
112898: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
112902: LD_VAR 0 1
112906: PPUSH
112907: CALL_OW 316
112911: PUSH
112912: LD_VAR 0 1
112916: PPUSH
112917: CALL_OW 314
112921: OR
112922: PUSH
112923: LD_VAR 0 1
112927: PPUSH
112928: CALL_OW 302
112932: NOT
112933: OR
112934: PUSH
112935: LD_VAR 0 1
112939: PPUSH
112940: CALL_OW 301
112944: OR
112945: IFFALSE 112895
// RemoveSeeing ( _x , _y , side ) ;
112947: LD_VAR 0 8
112951: PPUSH
112952: LD_VAR 0 9
112956: PPUSH
112957: LD_VAR 0 6
112961: PPUSH
112962: CALL_OW 331
// end ; end_of_file
112966: LD_VAR 0 4
112970: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112971: LD_INT 0
112973: PPUSH
112974: PPUSH
112975: PPUSH
112976: PPUSH
112977: PPUSH
112978: PPUSH
112979: PPUSH
112980: PPUSH
112981: PPUSH
112982: PPUSH
112983: PPUSH
112984: PPUSH
112985: PPUSH
112986: PPUSH
112987: PPUSH
112988: PPUSH
112989: PPUSH
112990: PPUSH
112991: PPUSH
112992: PPUSH
112993: PPUSH
112994: PPUSH
112995: PPUSH
112996: PPUSH
112997: PPUSH
112998: PPUSH
112999: PPUSH
113000: PPUSH
113001: PPUSH
113002: PPUSH
113003: PPUSH
113004: PPUSH
113005: PPUSH
113006: PPUSH
// if not list then
113007: LD_VAR 0 1
113011: NOT
113012: IFFALSE 113016
// exit ;
113014: GO 117675
// base := list [ 1 ] ;
113016: LD_ADDR_VAR 0 3
113020: PUSH
113021: LD_VAR 0 1
113025: PUSH
113026: LD_INT 1
113028: ARRAY
113029: ST_TO_ADDR
// group := list [ 2 ] ;
113030: LD_ADDR_VAR 0 4
113034: PUSH
113035: LD_VAR 0 1
113039: PUSH
113040: LD_INT 2
113042: ARRAY
113043: ST_TO_ADDR
// path := list [ 3 ] ;
113044: LD_ADDR_VAR 0 5
113048: PUSH
113049: LD_VAR 0 1
113053: PUSH
113054: LD_INT 3
113056: ARRAY
113057: ST_TO_ADDR
// flags := list [ 4 ] ;
113058: LD_ADDR_VAR 0 6
113062: PUSH
113063: LD_VAR 0 1
113067: PUSH
113068: LD_INT 4
113070: ARRAY
113071: ST_TO_ADDR
// mined := [ ] ;
113072: LD_ADDR_VAR 0 27
113076: PUSH
113077: EMPTY
113078: ST_TO_ADDR
// bombed := [ ] ;
113079: LD_ADDR_VAR 0 28
113083: PUSH
113084: EMPTY
113085: ST_TO_ADDR
// healers := [ ] ;
113086: LD_ADDR_VAR 0 31
113090: PUSH
113091: EMPTY
113092: ST_TO_ADDR
// to_heal := [ ] ;
113093: LD_ADDR_VAR 0 30
113097: PUSH
113098: EMPTY
113099: ST_TO_ADDR
// repairs := [ ] ;
113100: LD_ADDR_VAR 0 33
113104: PUSH
113105: EMPTY
113106: ST_TO_ADDR
// to_repair := [ ] ;
113107: LD_ADDR_VAR 0 32
113111: PUSH
113112: EMPTY
113113: ST_TO_ADDR
// if not group or not path then
113114: LD_VAR 0 4
113118: NOT
113119: PUSH
113120: LD_VAR 0 5
113124: NOT
113125: OR
113126: IFFALSE 113130
// exit ;
113128: GO 117675
// side := GetSide ( group [ 1 ] ) ;
113130: LD_ADDR_VAR 0 35
113134: PUSH
113135: LD_VAR 0 4
113139: PUSH
113140: LD_INT 1
113142: ARRAY
113143: PPUSH
113144: CALL_OW 255
113148: ST_TO_ADDR
// if flags then
113149: LD_VAR 0 6
113153: IFFALSE 113297
// begin f_ignore_area := flags [ 1 ] ;
113155: LD_ADDR_VAR 0 17
113159: PUSH
113160: LD_VAR 0 6
113164: PUSH
113165: LD_INT 1
113167: ARRAY
113168: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113169: LD_ADDR_VAR 0 18
113173: PUSH
113174: LD_VAR 0 6
113178: PUSH
113179: LD_INT 2
113181: ARRAY
113182: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113183: LD_ADDR_VAR 0 19
113187: PUSH
113188: LD_VAR 0 6
113192: PUSH
113193: LD_INT 3
113195: ARRAY
113196: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113197: LD_ADDR_VAR 0 20
113201: PUSH
113202: LD_VAR 0 6
113206: PUSH
113207: LD_INT 4
113209: ARRAY
113210: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113211: LD_ADDR_VAR 0 21
113215: PUSH
113216: LD_VAR 0 6
113220: PUSH
113221: LD_INT 5
113223: ARRAY
113224: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113225: LD_ADDR_VAR 0 22
113229: PUSH
113230: LD_VAR 0 6
113234: PUSH
113235: LD_INT 6
113237: ARRAY
113238: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113239: LD_ADDR_VAR 0 23
113243: PUSH
113244: LD_VAR 0 6
113248: PUSH
113249: LD_INT 7
113251: ARRAY
113252: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113253: LD_ADDR_VAR 0 24
113257: PUSH
113258: LD_VAR 0 6
113262: PUSH
113263: LD_INT 8
113265: ARRAY
113266: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113267: LD_ADDR_VAR 0 25
113271: PUSH
113272: LD_VAR 0 6
113276: PUSH
113277: LD_INT 9
113279: ARRAY
113280: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113281: LD_ADDR_VAR 0 26
113285: PUSH
113286: LD_VAR 0 6
113290: PUSH
113291: LD_INT 10
113293: ARRAY
113294: ST_TO_ADDR
// end else
113295: GO 113377
// begin f_ignore_area := false ;
113297: LD_ADDR_VAR 0 17
113301: PUSH
113302: LD_INT 0
113304: ST_TO_ADDR
// f_capture := false ;
113305: LD_ADDR_VAR 0 18
113309: PUSH
113310: LD_INT 0
113312: ST_TO_ADDR
// f_ignore_civ := false ;
113313: LD_ADDR_VAR 0 19
113317: PUSH
113318: LD_INT 0
113320: ST_TO_ADDR
// f_murder := false ;
113321: LD_ADDR_VAR 0 20
113325: PUSH
113326: LD_INT 0
113328: ST_TO_ADDR
// f_mines := false ;
113329: LD_ADDR_VAR 0 21
113333: PUSH
113334: LD_INT 0
113336: ST_TO_ADDR
// f_repair := false ;
113337: LD_ADDR_VAR 0 22
113341: PUSH
113342: LD_INT 0
113344: ST_TO_ADDR
// f_heal := false ;
113345: LD_ADDR_VAR 0 23
113349: PUSH
113350: LD_INT 0
113352: ST_TO_ADDR
// f_spacetime := false ;
113353: LD_ADDR_VAR 0 24
113357: PUSH
113358: LD_INT 0
113360: ST_TO_ADDR
// f_attack_depot := false ;
113361: LD_ADDR_VAR 0 25
113365: PUSH
113366: LD_INT 0
113368: ST_TO_ADDR
// f_crawl := false ;
113369: LD_ADDR_VAR 0 26
113373: PUSH
113374: LD_INT 0
113376: ST_TO_ADDR
// end ; if f_heal then
113377: LD_VAR 0 23
113381: IFFALSE 113408
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113383: LD_ADDR_VAR 0 31
113387: PUSH
113388: LD_VAR 0 4
113392: PPUSH
113393: LD_INT 25
113395: PUSH
113396: LD_INT 4
113398: PUSH
113399: EMPTY
113400: LIST
113401: LIST
113402: PPUSH
113403: CALL_OW 72
113407: ST_TO_ADDR
// if f_repair then
113408: LD_VAR 0 22
113412: IFFALSE 113439
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113414: LD_ADDR_VAR 0 33
113418: PUSH
113419: LD_VAR 0 4
113423: PPUSH
113424: LD_INT 25
113426: PUSH
113427: LD_INT 3
113429: PUSH
113430: EMPTY
113431: LIST
113432: LIST
113433: PPUSH
113434: CALL_OW 72
113438: ST_TO_ADDR
// units_path := [ ] ;
113439: LD_ADDR_VAR 0 16
113443: PUSH
113444: EMPTY
113445: ST_TO_ADDR
// for i = 1 to group do
113446: LD_ADDR_VAR 0 7
113450: PUSH
113451: DOUBLE
113452: LD_INT 1
113454: DEC
113455: ST_TO_ADDR
113456: LD_VAR 0 4
113460: PUSH
113461: FOR_TO
113462: IFFALSE 113491
// units_path := Replace ( units_path , i , path ) ;
113464: LD_ADDR_VAR 0 16
113468: PUSH
113469: LD_VAR 0 16
113473: PPUSH
113474: LD_VAR 0 7
113478: PPUSH
113479: LD_VAR 0 5
113483: PPUSH
113484: CALL_OW 1
113488: ST_TO_ADDR
113489: GO 113461
113491: POP
113492: POP
// repeat for i = group downto 1 do
113493: LD_ADDR_VAR 0 7
113497: PUSH
113498: DOUBLE
113499: LD_VAR 0 4
113503: INC
113504: ST_TO_ADDR
113505: LD_INT 1
113507: PUSH
113508: FOR_DOWNTO
113509: IFFALSE 117631
// begin wait ( 5 ) ;
113511: LD_INT 5
113513: PPUSH
113514: CALL_OW 67
// tmp := [ ] ;
113518: LD_ADDR_VAR 0 14
113522: PUSH
113523: EMPTY
113524: ST_TO_ADDR
// attacking := false ;
113525: LD_ADDR_VAR 0 29
113529: PUSH
113530: LD_INT 0
113532: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113533: LD_VAR 0 4
113537: PUSH
113538: LD_VAR 0 7
113542: ARRAY
113543: PPUSH
113544: CALL_OW 301
113548: PUSH
113549: LD_VAR 0 4
113553: PUSH
113554: LD_VAR 0 7
113558: ARRAY
113559: NOT
113560: OR
113561: IFFALSE 113670
// begin if GetType ( group [ i ] ) = unit_human then
113563: LD_VAR 0 4
113567: PUSH
113568: LD_VAR 0 7
113572: ARRAY
113573: PPUSH
113574: CALL_OW 247
113578: PUSH
113579: LD_INT 1
113581: EQUAL
113582: IFFALSE 113628
// begin to_heal := to_heal diff group [ i ] ;
113584: LD_ADDR_VAR 0 30
113588: PUSH
113589: LD_VAR 0 30
113593: PUSH
113594: LD_VAR 0 4
113598: PUSH
113599: LD_VAR 0 7
113603: ARRAY
113604: DIFF
113605: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113606: LD_ADDR_VAR 0 31
113610: PUSH
113611: LD_VAR 0 31
113615: PUSH
113616: LD_VAR 0 4
113620: PUSH
113621: LD_VAR 0 7
113625: ARRAY
113626: DIFF
113627: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113628: LD_ADDR_VAR 0 4
113632: PUSH
113633: LD_VAR 0 4
113637: PPUSH
113638: LD_VAR 0 7
113642: PPUSH
113643: CALL_OW 3
113647: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113648: LD_ADDR_VAR 0 16
113652: PUSH
113653: LD_VAR 0 16
113657: PPUSH
113658: LD_VAR 0 7
113662: PPUSH
113663: CALL_OW 3
113667: ST_TO_ADDR
// continue ;
113668: GO 113508
// end ; if f_repair then
113670: LD_VAR 0 22
113674: IFFALSE 114163
// begin if GetType ( group [ i ] ) = unit_vehicle then
113676: LD_VAR 0 4
113680: PUSH
113681: LD_VAR 0 7
113685: ARRAY
113686: PPUSH
113687: CALL_OW 247
113691: PUSH
113692: LD_INT 2
113694: EQUAL
113695: IFFALSE 113885
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113697: LD_VAR 0 4
113701: PUSH
113702: LD_VAR 0 7
113706: ARRAY
113707: PPUSH
113708: CALL_OW 256
113712: PUSH
113713: LD_INT 700
113715: LESS
113716: PUSH
113717: LD_VAR 0 4
113721: PUSH
113722: LD_VAR 0 7
113726: ARRAY
113727: PUSH
113728: LD_VAR 0 32
113732: IN
113733: NOT
113734: AND
113735: IFFALSE 113759
// to_repair := to_repair union group [ i ] ;
113737: LD_ADDR_VAR 0 32
113741: PUSH
113742: LD_VAR 0 32
113746: PUSH
113747: LD_VAR 0 4
113751: PUSH
113752: LD_VAR 0 7
113756: ARRAY
113757: UNION
113758: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113759: LD_VAR 0 4
113763: PUSH
113764: LD_VAR 0 7
113768: ARRAY
113769: PPUSH
113770: CALL_OW 256
113774: PUSH
113775: LD_INT 1000
113777: EQUAL
113778: PUSH
113779: LD_VAR 0 4
113783: PUSH
113784: LD_VAR 0 7
113788: ARRAY
113789: PUSH
113790: LD_VAR 0 32
113794: IN
113795: AND
113796: IFFALSE 113820
// to_repair := to_repair diff group [ i ] ;
113798: LD_ADDR_VAR 0 32
113802: PUSH
113803: LD_VAR 0 32
113807: PUSH
113808: LD_VAR 0 4
113812: PUSH
113813: LD_VAR 0 7
113817: ARRAY
113818: DIFF
113819: ST_TO_ADDR
// if group [ i ] in to_repair then
113820: LD_VAR 0 4
113824: PUSH
113825: LD_VAR 0 7
113829: ARRAY
113830: PUSH
113831: LD_VAR 0 32
113835: IN
113836: IFFALSE 113883
// begin if not IsInArea ( group [ i ] , f_repair ) then
113838: LD_VAR 0 4
113842: PUSH
113843: LD_VAR 0 7
113847: ARRAY
113848: PPUSH
113849: LD_VAR 0 22
113853: PPUSH
113854: CALL_OW 308
113858: NOT
113859: IFFALSE 113881
// ComMoveToArea ( group [ i ] , f_repair ) ;
113861: LD_VAR 0 4
113865: PUSH
113866: LD_VAR 0 7
113870: ARRAY
113871: PPUSH
113872: LD_VAR 0 22
113876: PPUSH
113877: CALL_OW 113
// continue ;
113881: GO 113508
// end ; end else
113883: GO 114163
// if group [ i ] in repairs then
113885: LD_VAR 0 4
113889: PUSH
113890: LD_VAR 0 7
113894: ARRAY
113895: PUSH
113896: LD_VAR 0 33
113900: IN
113901: IFFALSE 114163
// begin if IsInUnit ( group [ i ] ) then
113903: LD_VAR 0 4
113907: PUSH
113908: LD_VAR 0 7
113912: ARRAY
113913: PPUSH
113914: CALL_OW 310
113918: IFFALSE 113986
// begin z := IsInUnit ( group [ i ] ) ;
113920: LD_ADDR_VAR 0 13
113924: PUSH
113925: LD_VAR 0 4
113929: PUSH
113930: LD_VAR 0 7
113934: ARRAY
113935: PPUSH
113936: CALL_OW 310
113940: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113941: LD_VAR 0 13
113945: PUSH
113946: LD_VAR 0 32
113950: IN
113951: PUSH
113952: LD_VAR 0 13
113956: PPUSH
113957: LD_VAR 0 22
113961: PPUSH
113962: CALL_OW 308
113966: AND
113967: IFFALSE 113984
// ComExitVehicle ( group [ i ] ) ;
113969: LD_VAR 0 4
113973: PUSH
113974: LD_VAR 0 7
113978: ARRAY
113979: PPUSH
113980: CALL_OW 121
// end else
113984: GO 114163
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113986: LD_ADDR_VAR 0 13
113990: PUSH
113991: LD_VAR 0 4
113995: PPUSH
113996: LD_INT 95
113998: PUSH
113999: LD_VAR 0 22
114003: PUSH
114004: EMPTY
114005: LIST
114006: LIST
114007: PUSH
114008: LD_INT 58
114010: PUSH
114011: EMPTY
114012: LIST
114013: PUSH
114014: EMPTY
114015: LIST
114016: LIST
114017: PPUSH
114018: CALL_OW 72
114022: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114023: LD_VAR 0 4
114027: PUSH
114028: LD_VAR 0 7
114032: ARRAY
114033: PPUSH
114034: CALL_OW 314
114038: NOT
114039: IFFALSE 114161
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114041: LD_ADDR_VAR 0 10
114045: PUSH
114046: LD_VAR 0 13
114050: PPUSH
114051: LD_VAR 0 4
114055: PUSH
114056: LD_VAR 0 7
114060: ARRAY
114061: PPUSH
114062: CALL_OW 74
114066: ST_TO_ADDR
// if not x then
114067: LD_VAR 0 10
114071: NOT
114072: IFFALSE 114076
// continue ;
114074: GO 113508
// if GetLives ( x ) < 1000 then
114076: LD_VAR 0 10
114080: PPUSH
114081: CALL_OW 256
114085: PUSH
114086: LD_INT 1000
114088: LESS
114089: IFFALSE 114113
// ComRepairVehicle ( group [ i ] , x ) else
114091: LD_VAR 0 4
114095: PUSH
114096: LD_VAR 0 7
114100: ARRAY
114101: PPUSH
114102: LD_VAR 0 10
114106: PPUSH
114107: CALL_OW 129
114111: GO 114161
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114113: LD_VAR 0 23
114117: PUSH
114118: LD_VAR 0 4
114122: PUSH
114123: LD_VAR 0 7
114127: ARRAY
114128: PPUSH
114129: CALL_OW 256
114133: PUSH
114134: LD_INT 1000
114136: LESS
114137: AND
114138: NOT
114139: IFFALSE 114161
// ComEnterUnit ( group [ i ] , x ) ;
114141: LD_VAR 0 4
114145: PUSH
114146: LD_VAR 0 7
114150: ARRAY
114151: PPUSH
114152: LD_VAR 0 10
114156: PPUSH
114157: CALL_OW 120
// end ; continue ;
114161: GO 113508
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114163: LD_VAR 0 23
114167: PUSH
114168: LD_VAR 0 4
114172: PUSH
114173: LD_VAR 0 7
114177: ARRAY
114178: PPUSH
114179: CALL_OW 247
114183: PUSH
114184: LD_INT 1
114186: EQUAL
114187: AND
114188: IFFALSE 114666
// begin if group [ i ] in healers then
114190: LD_VAR 0 4
114194: PUSH
114195: LD_VAR 0 7
114199: ARRAY
114200: PUSH
114201: LD_VAR 0 31
114205: IN
114206: IFFALSE 114479
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114208: LD_VAR 0 4
114212: PUSH
114213: LD_VAR 0 7
114217: ARRAY
114218: PPUSH
114219: LD_VAR 0 23
114223: PPUSH
114224: CALL_OW 308
114228: NOT
114229: PUSH
114230: LD_VAR 0 4
114234: PUSH
114235: LD_VAR 0 7
114239: ARRAY
114240: PPUSH
114241: CALL_OW 314
114245: NOT
114246: AND
114247: IFFALSE 114271
// ComMoveToArea ( group [ i ] , f_heal ) else
114249: LD_VAR 0 4
114253: PUSH
114254: LD_VAR 0 7
114258: ARRAY
114259: PPUSH
114260: LD_VAR 0 23
114264: PPUSH
114265: CALL_OW 113
114269: GO 114477
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114271: LD_VAR 0 4
114275: PUSH
114276: LD_VAR 0 7
114280: ARRAY
114281: PPUSH
114282: CALL 86609 0 1
114286: PPUSH
114287: CALL_OW 256
114291: PUSH
114292: LD_INT 1000
114294: EQUAL
114295: IFFALSE 114314
// ComStop ( group [ i ] ) else
114297: LD_VAR 0 4
114301: PUSH
114302: LD_VAR 0 7
114306: ARRAY
114307: PPUSH
114308: CALL_OW 141
114312: GO 114477
// if not HasTask ( group [ i ] ) and to_heal then
114314: LD_VAR 0 4
114318: PUSH
114319: LD_VAR 0 7
114323: ARRAY
114324: PPUSH
114325: CALL_OW 314
114329: NOT
114330: PUSH
114331: LD_VAR 0 30
114335: AND
114336: IFFALSE 114477
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114338: LD_ADDR_VAR 0 13
114342: PUSH
114343: LD_VAR 0 30
114347: PPUSH
114348: LD_INT 3
114350: PUSH
114351: LD_INT 54
114353: PUSH
114354: EMPTY
114355: LIST
114356: PUSH
114357: EMPTY
114358: LIST
114359: LIST
114360: PPUSH
114361: CALL_OW 72
114365: PPUSH
114366: LD_VAR 0 4
114370: PUSH
114371: LD_VAR 0 7
114375: ARRAY
114376: PPUSH
114377: CALL_OW 74
114381: ST_TO_ADDR
// if z then
114382: LD_VAR 0 13
114386: IFFALSE 114477
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114388: LD_INT 91
114390: PUSH
114391: LD_VAR 0 13
114395: PUSH
114396: LD_INT 10
114398: PUSH
114399: EMPTY
114400: LIST
114401: LIST
114402: LIST
114403: PUSH
114404: LD_INT 81
114406: PUSH
114407: LD_VAR 0 13
114411: PPUSH
114412: CALL_OW 255
114416: PUSH
114417: EMPTY
114418: LIST
114419: LIST
114420: PUSH
114421: EMPTY
114422: LIST
114423: LIST
114424: PPUSH
114425: CALL_OW 69
114429: PUSH
114430: LD_INT 0
114432: EQUAL
114433: IFFALSE 114457
// ComHeal ( group [ i ] , z ) else
114435: LD_VAR 0 4
114439: PUSH
114440: LD_VAR 0 7
114444: ARRAY
114445: PPUSH
114446: LD_VAR 0 13
114450: PPUSH
114451: CALL_OW 128
114455: GO 114477
// ComMoveToArea ( group [ i ] , f_heal ) ;
114457: LD_VAR 0 4
114461: PUSH
114462: LD_VAR 0 7
114466: ARRAY
114467: PPUSH
114468: LD_VAR 0 23
114472: PPUSH
114473: CALL_OW 113
// end ; continue ;
114477: GO 113508
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114479: LD_VAR 0 4
114483: PUSH
114484: LD_VAR 0 7
114488: ARRAY
114489: PPUSH
114490: CALL_OW 256
114494: PUSH
114495: LD_INT 700
114497: LESS
114498: PUSH
114499: LD_VAR 0 4
114503: PUSH
114504: LD_VAR 0 7
114508: ARRAY
114509: PUSH
114510: LD_VAR 0 30
114514: IN
114515: NOT
114516: AND
114517: IFFALSE 114541
// to_heal := to_heal union group [ i ] ;
114519: LD_ADDR_VAR 0 30
114523: PUSH
114524: LD_VAR 0 30
114528: PUSH
114529: LD_VAR 0 4
114533: PUSH
114534: LD_VAR 0 7
114538: ARRAY
114539: UNION
114540: ST_TO_ADDR
// if group [ i ] in to_heal then
114541: LD_VAR 0 4
114545: PUSH
114546: LD_VAR 0 7
114550: ARRAY
114551: PUSH
114552: LD_VAR 0 30
114556: IN
114557: IFFALSE 114666
// begin if GetLives ( group [ i ] ) = 1000 then
114559: LD_VAR 0 4
114563: PUSH
114564: LD_VAR 0 7
114568: ARRAY
114569: PPUSH
114570: CALL_OW 256
114574: PUSH
114575: LD_INT 1000
114577: EQUAL
114578: IFFALSE 114604
// to_heal := to_heal diff group [ i ] else
114580: LD_ADDR_VAR 0 30
114584: PUSH
114585: LD_VAR 0 30
114589: PUSH
114590: LD_VAR 0 4
114594: PUSH
114595: LD_VAR 0 7
114599: ARRAY
114600: DIFF
114601: ST_TO_ADDR
114602: GO 114666
// begin if not IsInArea ( group [ i ] , to_heal ) then
114604: LD_VAR 0 4
114608: PUSH
114609: LD_VAR 0 7
114613: ARRAY
114614: PPUSH
114615: LD_VAR 0 30
114619: PPUSH
114620: CALL_OW 308
114624: NOT
114625: IFFALSE 114649
// ComMoveToArea ( group [ i ] , f_heal ) else
114627: LD_VAR 0 4
114631: PUSH
114632: LD_VAR 0 7
114636: ARRAY
114637: PPUSH
114638: LD_VAR 0 23
114642: PPUSH
114643: CALL_OW 113
114647: GO 114664
// ComHold ( group [ i ] ) ;
114649: LD_VAR 0 4
114653: PUSH
114654: LD_VAR 0 7
114658: ARRAY
114659: PPUSH
114660: CALL_OW 140
// continue ;
114664: GO 113508
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114666: LD_VAR 0 4
114670: PUSH
114671: LD_VAR 0 7
114675: ARRAY
114676: PPUSH
114677: LD_INT 10
114679: PPUSH
114680: CALL 84479 0 2
114684: NOT
114685: PUSH
114686: LD_VAR 0 16
114690: PUSH
114691: LD_VAR 0 7
114695: ARRAY
114696: PUSH
114697: EMPTY
114698: EQUAL
114699: NOT
114700: AND
114701: IFFALSE 114967
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114703: LD_VAR 0 4
114707: PUSH
114708: LD_VAR 0 7
114712: ARRAY
114713: PPUSH
114714: CALL_OW 262
114718: PUSH
114719: LD_INT 1
114721: PUSH
114722: LD_INT 2
114724: PUSH
114725: EMPTY
114726: LIST
114727: LIST
114728: IN
114729: IFFALSE 114770
// if GetFuel ( group [ i ] ) < 10 then
114731: LD_VAR 0 4
114735: PUSH
114736: LD_VAR 0 7
114740: ARRAY
114741: PPUSH
114742: CALL_OW 261
114746: PUSH
114747: LD_INT 10
114749: LESS
114750: IFFALSE 114770
// SetFuel ( group [ i ] , 12 ) ;
114752: LD_VAR 0 4
114756: PUSH
114757: LD_VAR 0 7
114761: ARRAY
114762: PPUSH
114763: LD_INT 12
114765: PPUSH
114766: CALL_OW 240
// if units_path [ i ] then
114770: LD_VAR 0 16
114774: PUSH
114775: LD_VAR 0 7
114779: ARRAY
114780: IFFALSE 114965
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114782: LD_VAR 0 4
114786: PUSH
114787: LD_VAR 0 7
114791: ARRAY
114792: PPUSH
114793: LD_VAR 0 16
114797: PUSH
114798: LD_VAR 0 7
114802: ARRAY
114803: PUSH
114804: LD_INT 1
114806: ARRAY
114807: PUSH
114808: LD_INT 1
114810: ARRAY
114811: PPUSH
114812: LD_VAR 0 16
114816: PUSH
114817: LD_VAR 0 7
114821: ARRAY
114822: PUSH
114823: LD_INT 1
114825: ARRAY
114826: PUSH
114827: LD_INT 2
114829: ARRAY
114830: PPUSH
114831: CALL_OW 297
114835: PUSH
114836: LD_INT 6
114838: GREATER
114839: IFFALSE 114914
// begin if not HasTask ( group [ i ] ) then
114841: LD_VAR 0 4
114845: PUSH
114846: LD_VAR 0 7
114850: ARRAY
114851: PPUSH
114852: CALL_OW 314
114856: NOT
114857: IFFALSE 114912
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114859: LD_VAR 0 4
114863: PUSH
114864: LD_VAR 0 7
114868: ARRAY
114869: PPUSH
114870: LD_VAR 0 16
114874: PUSH
114875: LD_VAR 0 7
114879: ARRAY
114880: PUSH
114881: LD_INT 1
114883: ARRAY
114884: PUSH
114885: LD_INT 1
114887: ARRAY
114888: PPUSH
114889: LD_VAR 0 16
114893: PUSH
114894: LD_VAR 0 7
114898: ARRAY
114899: PUSH
114900: LD_INT 1
114902: ARRAY
114903: PUSH
114904: LD_INT 2
114906: ARRAY
114907: PPUSH
114908: CALL_OW 114
// end else
114912: GO 114965
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114914: LD_ADDR_VAR 0 15
114918: PUSH
114919: LD_VAR 0 16
114923: PUSH
114924: LD_VAR 0 7
114928: ARRAY
114929: PPUSH
114930: LD_INT 1
114932: PPUSH
114933: CALL_OW 3
114937: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
114938: LD_ADDR_VAR 0 16
114942: PUSH
114943: LD_VAR 0 16
114947: PPUSH
114948: LD_VAR 0 7
114952: PPUSH
114953: LD_VAR 0 15
114957: PPUSH
114958: CALL_OW 1
114962: ST_TO_ADDR
// continue ;
114963: GO 113508
// end ; end ; end else
114965: GO 117629
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114967: LD_ADDR_VAR 0 14
114971: PUSH
114972: LD_INT 81
114974: PUSH
114975: LD_VAR 0 4
114979: PUSH
114980: LD_VAR 0 7
114984: ARRAY
114985: PPUSH
114986: CALL_OW 255
114990: PUSH
114991: EMPTY
114992: LIST
114993: LIST
114994: PPUSH
114995: CALL_OW 69
114999: ST_TO_ADDR
// if not tmp then
115000: LD_VAR 0 14
115004: NOT
115005: IFFALSE 115009
// continue ;
115007: GO 113508
// if f_ignore_area then
115009: LD_VAR 0 17
115013: IFFALSE 115101
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115015: LD_ADDR_VAR 0 15
115019: PUSH
115020: LD_VAR 0 14
115024: PPUSH
115025: LD_INT 3
115027: PUSH
115028: LD_INT 92
115030: PUSH
115031: LD_VAR 0 17
115035: PUSH
115036: LD_INT 1
115038: ARRAY
115039: PUSH
115040: LD_VAR 0 17
115044: PUSH
115045: LD_INT 2
115047: ARRAY
115048: PUSH
115049: LD_VAR 0 17
115053: PUSH
115054: LD_INT 3
115056: ARRAY
115057: PUSH
115058: EMPTY
115059: LIST
115060: LIST
115061: LIST
115062: LIST
115063: PUSH
115064: EMPTY
115065: LIST
115066: LIST
115067: PPUSH
115068: CALL_OW 72
115072: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115073: LD_VAR 0 14
115077: PUSH
115078: LD_VAR 0 15
115082: DIFF
115083: IFFALSE 115101
// tmp := tmp diff tmp2 ;
115085: LD_ADDR_VAR 0 14
115089: PUSH
115090: LD_VAR 0 14
115094: PUSH
115095: LD_VAR 0 15
115099: DIFF
115100: ST_TO_ADDR
// end ; if not f_murder then
115101: LD_VAR 0 20
115105: NOT
115106: IFFALSE 115164
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115108: LD_ADDR_VAR 0 15
115112: PUSH
115113: LD_VAR 0 14
115117: PPUSH
115118: LD_INT 3
115120: PUSH
115121: LD_INT 50
115123: PUSH
115124: EMPTY
115125: LIST
115126: PUSH
115127: EMPTY
115128: LIST
115129: LIST
115130: PPUSH
115131: CALL_OW 72
115135: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115136: LD_VAR 0 14
115140: PUSH
115141: LD_VAR 0 15
115145: DIFF
115146: IFFALSE 115164
// tmp := tmp diff tmp2 ;
115148: LD_ADDR_VAR 0 14
115152: PUSH
115153: LD_VAR 0 14
115157: PUSH
115158: LD_VAR 0 15
115162: DIFF
115163: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115164: LD_ADDR_VAR 0 14
115168: PUSH
115169: LD_VAR 0 4
115173: PUSH
115174: LD_VAR 0 7
115178: ARRAY
115179: PPUSH
115180: LD_VAR 0 14
115184: PPUSH
115185: LD_INT 1
115187: PPUSH
115188: LD_INT 1
115190: PPUSH
115191: CALL 57420 0 4
115195: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115196: LD_VAR 0 4
115200: PUSH
115201: LD_VAR 0 7
115205: ARRAY
115206: PPUSH
115207: CALL_OW 257
115211: PUSH
115212: LD_INT 1
115214: EQUAL
115215: IFFALSE 115663
// begin if WantPlant ( group [ i ] ) then
115217: LD_VAR 0 4
115221: PUSH
115222: LD_VAR 0 7
115226: ARRAY
115227: PPUSH
115228: CALL 56921 0 1
115232: IFFALSE 115236
// continue ;
115234: GO 113508
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115236: LD_VAR 0 18
115240: PUSH
115241: LD_VAR 0 4
115245: PUSH
115246: LD_VAR 0 7
115250: ARRAY
115251: PPUSH
115252: CALL_OW 310
115256: NOT
115257: AND
115258: PUSH
115259: LD_VAR 0 14
115263: PUSH
115264: LD_INT 1
115266: ARRAY
115267: PUSH
115268: LD_VAR 0 14
115272: PPUSH
115273: LD_INT 21
115275: PUSH
115276: LD_INT 2
115278: PUSH
115279: EMPTY
115280: LIST
115281: LIST
115282: PUSH
115283: LD_INT 58
115285: PUSH
115286: EMPTY
115287: LIST
115288: PUSH
115289: EMPTY
115290: LIST
115291: LIST
115292: PPUSH
115293: CALL_OW 72
115297: IN
115298: AND
115299: IFFALSE 115335
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115301: LD_VAR 0 4
115305: PUSH
115306: LD_VAR 0 7
115310: ARRAY
115311: PPUSH
115312: LD_VAR 0 14
115316: PUSH
115317: LD_INT 1
115319: ARRAY
115320: PPUSH
115321: CALL_OW 120
// attacking := true ;
115325: LD_ADDR_VAR 0 29
115329: PUSH
115330: LD_INT 1
115332: ST_TO_ADDR
// continue ;
115333: GO 113508
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115335: LD_VAR 0 26
115339: PUSH
115340: LD_VAR 0 4
115344: PUSH
115345: LD_VAR 0 7
115349: ARRAY
115350: PPUSH
115351: CALL_OW 257
115355: PUSH
115356: LD_INT 1
115358: EQUAL
115359: AND
115360: PUSH
115361: LD_VAR 0 4
115365: PUSH
115366: LD_VAR 0 7
115370: ARRAY
115371: PPUSH
115372: CALL_OW 256
115376: PUSH
115377: LD_INT 800
115379: LESS
115380: AND
115381: PUSH
115382: LD_VAR 0 4
115386: PUSH
115387: LD_VAR 0 7
115391: ARRAY
115392: PPUSH
115393: CALL_OW 318
115397: NOT
115398: AND
115399: IFFALSE 115416
// ComCrawl ( group [ i ] ) ;
115401: LD_VAR 0 4
115405: PUSH
115406: LD_VAR 0 7
115410: ARRAY
115411: PPUSH
115412: CALL_OW 137
// if f_mines then
115416: LD_VAR 0 21
115420: IFFALSE 115663
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115422: LD_VAR 0 14
115426: PUSH
115427: LD_INT 1
115429: ARRAY
115430: PPUSH
115431: CALL_OW 247
115435: PUSH
115436: LD_INT 3
115438: EQUAL
115439: PUSH
115440: LD_VAR 0 14
115444: PUSH
115445: LD_INT 1
115447: ARRAY
115448: PUSH
115449: LD_VAR 0 27
115453: IN
115454: NOT
115455: AND
115456: IFFALSE 115663
// begin x := GetX ( tmp [ 1 ] ) ;
115458: LD_ADDR_VAR 0 10
115462: PUSH
115463: LD_VAR 0 14
115467: PUSH
115468: LD_INT 1
115470: ARRAY
115471: PPUSH
115472: CALL_OW 250
115476: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115477: LD_ADDR_VAR 0 11
115481: PUSH
115482: LD_VAR 0 14
115486: PUSH
115487: LD_INT 1
115489: ARRAY
115490: PPUSH
115491: CALL_OW 251
115495: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115496: LD_ADDR_VAR 0 12
115500: PUSH
115501: LD_VAR 0 4
115505: PUSH
115506: LD_VAR 0 7
115510: ARRAY
115511: PPUSH
115512: CALL 84564 0 1
115516: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115517: LD_VAR 0 4
115521: PUSH
115522: LD_VAR 0 7
115526: ARRAY
115527: PPUSH
115528: LD_VAR 0 10
115532: PPUSH
115533: LD_VAR 0 11
115537: PPUSH
115538: LD_VAR 0 14
115542: PUSH
115543: LD_INT 1
115545: ARRAY
115546: PPUSH
115547: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115551: LD_VAR 0 4
115555: PUSH
115556: LD_VAR 0 7
115560: ARRAY
115561: PPUSH
115562: LD_VAR 0 10
115566: PPUSH
115567: LD_VAR 0 12
115571: PPUSH
115572: LD_INT 7
115574: PPUSH
115575: CALL_OW 272
115579: PPUSH
115580: LD_VAR 0 11
115584: PPUSH
115585: LD_VAR 0 12
115589: PPUSH
115590: LD_INT 7
115592: PPUSH
115593: CALL_OW 273
115597: PPUSH
115598: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115602: LD_VAR 0 4
115606: PUSH
115607: LD_VAR 0 7
115611: ARRAY
115612: PPUSH
115613: LD_INT 71
115615: PPUSH
115616: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115620: LD_ADDR_VAR 0 27
115624: PUSH
115625: LD_VAR 0 27
115629: PPUSH
115630: LD_VAR 0 27
115634: PUSH
115635: LD_INT 1
115637: PLUS
115638: PPUSH
115639: LD_VAR 0 14
115643: PUSH
115644: LD_INT 1
115646: ARRAY
115647: PPUSH
115648: CALL_OW 1
115652: ST_TO_ADDR
// attacking := true ;
115653: LD_ADDR_VAR 0 29
115657: PUSH
115658: LD_INT 1
115660: ST_TO_ADDR
// continue ;
115661: GO 113508
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115663: LD_VAR 0 4
115667: PUSH
115668: LD_VAR 0 7
115672: ARRAY
115673: PPUSH
115674: CALL_OW 257
115678: PUSH
115679: LD_INT 17
115681: EQUAL
115682: PUSH
115683: LD_VAR 0 4
115687: PUSH
115688: LD_VAR 0 7
115692: ARRAY
115693: PPUSH
115694: CALL_OW 110
115698: PUSH
115699: LD_INT 71
115701: EQUAL
115702: NOT
115703: AND
115704: IFFALSE 115850
// begin attacking := false ;
115706: LD_ADDR_VAR 0 29
115710: PUSH
115711: LD_INT 0
115713: ST_TO_ADDR
// k := 5 ;
115714: LD_ADDR_VAR 0 9
115718: PUSH
115719: LD_INT 5
115721: ST_TO_ADDR
// if tmp < k then
115722: LD_VAR 0 14
115726: PUSH
115727: LD_VAR 0 9
115731: LESS
115732: IFFALSE 115744
// k := tmp ;
115734: LD_ADDR_VAR 0 9
115738: PUSH
115739: LD_VAR 0 14
115743: ST_TO_ADDR
// for j = 1 to k do
115744: LD_ADDR_VAR 0 8
115748: PUSH
115749: DOUBLE
115750: LD_INT 1
115752: DEC
115753: ST_TO_ADDR
115754: LD_VAR 0 9
115758: PUSH
115759: FOR_TO
115760: IFFALSE 115848
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115762: LD_VAR 0 14
115766: PUSH
115767: LD_VAR 0 8
115771: ARRAY
115772: PUSH
115773: LD_VAR 0 14
115777: PPUSH
115778: LD_INT 58
115780: PUSH
115781: EMPTY
115782: LIST
115783: PPUSH
115784: CALL_OW 72
115788: IN
115789: NOT
115790: IFFALSE 115846
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115792: LD_VAR 0 4
115796: PUSH
115797: LD_VAR 0 7
115801: ARRAY
115802: PPUSH
115803: LD_VAR 0 14
115807: PUSH
115808: LD_VAR 0 8
115812: ARRAY
115813: PPUSH
115814: CALL_OW 115
// attacking := true ;
115818: LD_ADDR_VAR 0 29
115822: PUSH
115823: LD_INT 1
115825: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115826: LD_VAR 0 4
115830: PUSH
115831: LD_VAR 0 7
115835: ARRAY
115836: PPUSH
115837: LD_INT 71
115839: PPUSH
115840: CALL_OW 109
// continue ;
115844: GO 115759
// end ; end ;
115846: GO 115759
115848: POP
115849: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115850: LD_VAR 0 4
115854: PUSH
115855: LD_VAR 0 7
115859: ARRAY
115860: PPUSH
115861: CALL_OW 257
115865: PUSH
115866: LD_INT 8
115868: EQUAL
115869: PUSH
115870: LD_VAR 0 4
115874: PUSH
115875: LD_VAR 0 7
115879: ARRAY
115880: PPUSH
115881: CALL_OW 264
115885: PUSH
115886: LD_INT 28
115888: PUSH
115889: LD_INT 45
115891: PUSH
115892: LD_INT 7
115894: PUSH
115895: LD_INT 47
115897: PUSH
115898: EMPTY
115899: LIST
115900: LIST
115901: LIST
115902: LIST
115903: IN
115904: OR
115905: IFFALSE 116161
// begin attacking := false ;
115907: LD_ADDR_VAR 0 29
115911: PUSH
115912: LD_INT 0
115914: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115915: LD_VAR 0 14
115919: PUSH
115920: LD_INT 1
115922: ARRAY
115923: PPUSH
115924: CALL_OW 266
115928: PUSH
115929: LD_INT 32
115931: PUSH
115932: LD_INT 31
115934: PUSH
115935: LD_INT 33
115937: PUSH
115938: LD_INT 4
115940: PUSH
115941: LD_INT 5
115943: PUSH
115944: EMPTY
115945: LIST
115946: LIST
115947: LIST
115948: LIST
115949: LIST
115950: IN
115951: IFFALSE 116137
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115953: LD_ADDR_VAR 0 9
115957: PUSH
115958: LD_VAR 0 14
115962: PUSH
115963: LD_INT 1
115965: ARRAY
115966: PPUSH
115967: CALL_OW 266
115971: PPUSH
115972: LD_VAR 0 14
115976: PUSH
115977: LD_INT 1
115979: ARRAY
115980: PPUSH
115981: CALL_OW 250
115985: PPUSH
115986: LD_VAR 0 14
115990: PUSH
115991: LD_INT 1
115993: ARRAY
115994: PPUSH
115995: CALL_OW 251
115999: PPUSH
116000: LD_VAR 0 14
116004: PUSH
116005: LD_INT 1
116007: ARRAY
116008: PPUSH
116009: CALL_OW 254
116013: PPUSH
116014: LD_VAR 0 14
116018: PUSH
116019: LD_INT 1
116021: ARRAY
116022: PPUSH
116023: CALL_OW 248
116027: PPUSH
116028: LD_INT 0
116030: PPUSH
116031: CALL 65934 0 6
116035: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116036: LD_ADDR_VAR 0 8
116040: PUSH
116041: LD_VAR 0 4
116045: PUSH
116046: LD_VAR 0 7
116050: ARRAY
116051: PPUSH
116052: LD_VAR 0 9
116056: PPUSH
116057: CALL 84604 0 2
116061: ST_TO_ADDR
// if j then
116062: LD_VAR 0 8
116066: IFFALSE 116135
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116068: LD_VAR 0 8
116072: PUSH
116073: LD_INT 1
116075: ARRAY
116076: PPUSH
116077: LD_VAR 0 8
116081: PUSH
116082: LD_INT 2
116084: ARRAY
116085: PPUSH
116086: CALL_OW 488
116090: IFFALSE 116135
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116092: LD_VAR 0 4
116096: PUSH
116097: LD_VAR 0 7
116101: ARRAY
116102: PPUSH
116103: LD_VAR 0 8
116107: PUSH
116108: LD_INT 1
116110: ARRAY
116111: PPUSH
116112: LD_VAR 0 8
116116: PUSH
116117: LD_INT 2
116119: ARRAY
116120: PPUSH
116121: CALL_OW 116
// attacking := true ;
116125: LD_ADDR_VAR 0 29
116129: PUSH
116130: LD_INT 1
116132: ST_TO_ADDR
// continue ;
116133: GO 113508
// end ; end else
116135: GO 116161
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116137: LD_VAR 0 4
116141: PUSH
116142: LD_VAR 0 7
116146: ARRAY
116147: PPUSH
116148: LD_VAR 0 14
116152: PUSH
116153: LD_INT 1
116155: ARRAY
116156: PPUSH
116157: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116161: LD_VAR 0 4
116165: PUSH
116166: LD_VAR 0 7
116170: ARRAY
116171: PPUSH
116172: CALL_OW 265
116176: PUSH
116177: LD_INT 11
116179: EQUAL
116180: IFFALSE 116458
// begin k := 10 ;
116182: LD_ADDR_VAR 0 9
116186: PUSH
116187: LD_INT 10
116189: ST_TO_ADDR
// x := 0 ;
116190: LD_ADDR_VAR 0 10
116194: PUSH
116195: LD_INT 0
116197: ST_TO_ADDR
// if tmp < k then
116198: LD_VAR 0 14
116202: PUSH
116203: LD_VAR 0 9
116207: LESS
116208: IFFALSE 116220
// k := tmp ;
116210: LD_ADDR_VAR 0 9
116214: PUSH
116215: LD_VAR 0 14
116219: ST_TO_ADDR
// for j = k downto 1 do
116220: LD_ADDR_VAR 0 8
116224: PUSH
116225: DOUBLE
116226: LD_VAR 0 9
116230: INC
116231: ST_TO_ADDR
116232: LD_INT 1
116234: PUSH
116235: FOR_DOWNTO
116236: IFFALSE 116311
// begin if GetType ( tmp [ j ] ) = unit_human then
116238: LD_VAR 0 14
116242: PUSH
116243: LD_VAR 0 8
116247: ARRAY
116248: PPUSH
116249: CALL_OW 247
116253: PUSH
116254: LD_INT 1
116256: EQUAL
116257: IFFALSE 116309
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116259: LD_VAR 0 4
116263: PUSH
116264: LD_VAR 0 7
116268: ARRAY
116269: PPUSH
116270: LD_VAR 0 14
116274: PUSH
116275: LD_VAR 0 8
116279: ARRAY
116280: PPUSH
116281: CALL 84858 0 2
// x := tmp [ j ] ;
116285: LD_ADDR_VAR 0 10
116289: PUSH
116290: LD_VAR 0 14
116294: PUSH
116295: LD_VAR 0 8
116299: ARRAY
116300: ST_TO_ADDR
// attacking := true ;
116301: LD_ADDR_VAR 0 29
116305: PUSH
116306: LD_INT 1
116308: ST_TO_ADDR
// end ; end ;
116309: GO 116235
116311: POP
116312: POP
// if not x then
116313: LD_VAR 0 10
116317: NOT
116318: IFFALSE 116458
// begin attacking := true ;
116320: LD_ADDR_VAR 0 29
116324: PUSH
116325: LD_INT 1
116327: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116328: LD_VAR 0 4
116332: PUSH
116333: LD_VAR 0 7
116337: ARRAY
116338: PPUSH
116339: CALL_OW 250
116343: PPUSH
116344: LD_VAR 0 4
116348: PUSH
116349: LD_VAR 0 7
116353: ARRAY
116354: PPUSH
116355: CALL_OW 251
116359: PPUSH
116360: CALL_OW 546
116364: PUSH
116365: LD_INT 2
116367: ARRAY
116368: PUSH
116369: LD_VAR 0 14
116373: PUSH
116374: LD_INT 1
116376: ARRAY
116377: PPUSH
116378: CALL_OW 250
116382: PPUSH
116383: LD_VAR 0 14
116387: PUSH
116388: LD_INT 1
116390: ARRAY
116391: PPUSH
116392: CALL_OW 251
116396: PPUSH
116397: CALL_OW 546
116401: PUSH
116402: LD_INT 2
116404: ARRAY
116405: EQUAL
116406: IFFALSE 116434
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116408: LD_VAR 0 4
116412: PUSH
116413: LD_VAR 0 7
116417: ARRAY
116418: PPUSH
116419: LD_VAR 0 14
116423: PUSH
116424: LD_INT 1
116426: ARRAY
116427: PPUSH
116428: CALL 84858 0 2
116432: GO 116458
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116434: LD_VAR 0 4
116438: PUSH
116439: LD_VAR 0 7
116443: ARRAY
116444: PPUSH
116445: LD_VAR 0 14
116449: PUSH
116450: LD_INT 1
116452: ARRAY
116453: PPUSH
116454: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116458: LD_VAR 0 4
116462: PUSH
116463: LD_VAR 0 7
116467: ARRAY
116468: PPUSH
116469: CALL_OW 264
116473: PUSH
116474: LD_INT 29
116476: EQUAL
116477: IFFALSE 116843
// begin if WantsToAttack ( group [ i ] ) in bombed then
116479: LD_VAR 0 4
116483: PUSH
116484: LD_VAR 0 7
116488: ARRAY
116489: PPUSH
116490: CALL_OW 319
116494: PUSH
116495: LD_VAR 0 28
116499: IN
116500: IFFALSE 116504
// continue ;
116502: GO 113508
// k := 8 ;
116504: LD_ADDR_VAR 0 9
116508: PUSH
116509: LD_INT 8
116511: ST_TO_ADDR
// x := 0 ;
116512: LD_ADDR_VAR 0 10
116516: PUSH
116517: LD_INT 0
116519: ST_TO_ADDR
// if tmp < k then
116520: LD_VAR 0 14
116524: PUSH
116525: LD_VAR 0 9
116529: LESS
116530: IFFALSE 116542
// k := tmp ;
116532: LD_ADDR_VAR 0 9
116536: PUSH
116537: LD_VAR 0 14
116541: ST_TO_ADDR
// for j = 1 to k do
116542: LD_ADDR_VAR 0 8
116546: PUSH
116547: DOUBLE
116548: LD_INT 1
116550: DEC
116551: ST_TO_ADDR
116552: LD_VAR 0 9
116556: PUSH
116557: FOR_TO
116558: IFFALSE 116690
// begin if GetType ( tmp [ j ] ) = unit_building then
116560: LD_VAR 0 14
116564: PUSH
116565: LD_VAR 0 8
116569: ARRAY
116570: PPUSH
116571: CALL_OW 247
116575: PUSH
116576: LD_INT 3
116578: EQUAL
116579: IFFALSE 116688
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116581: LD_VAR 0 14
116585: PUSH
116586: LD_VAR 0 8
116590: ARRAY
116591: PUSH
116592: LD_VAR 0 28
116596: IN
116597: NOT
116598: PUSH
116599: LD_VAR 0 14
116603: PUSH
116604: LD_VAR 0 8
116608: ARRAY
116609: PPUSH
116610: CALL_OW 313
116614: AND
116615: IFFALSE 116688
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116617: LD_VAR 0 4
116621: PUSH
116622: LD_VAR 0 7
116626: ARRAY
116627: PPUSH
116628: LD_VAR 0 14
116632: PUSH
116633: LD_VAR 0 8
116637: ARRAY
116638: PPUSH
116639: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116643: LD_ADDR_VAR 0 28
116647: PUSH
116648: LD_VAR 0 28
116652: PPUSH
116653: LD_VAR 0 28
116657: PUSH
116658: LD_INT 1
116660: PLUS
116661: PPUSH
116662: LD_VAR 0 14
116666: PUSH
116667: LD_VAR 0 8
116671: ARRAY
116672: PPUSH
116673: CALL_OW 1
116677: ST_TO_ADDR
// attacking := true ;
116678: LD_ADDR_VAR 0 29
116682: PUSH
116683: LD_INT 1
116685: ST_TO_ADDR
// break ;
116686: GO 116690
// end ; end ;
116688: GO 116557
116690: POP
116691: POP
// if not attacking and f_attack_depot then
116692: LD_VAR 0 29
116696: NOT
116697: PUSH
116698: LD_VAR 0 25
116702: AND
116703: IFFALSE 116798
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116705: LD_ADDR_VAR 0 13
116709: PUSH
116710: LD_VAR 0 14
116714: PPUSH
116715: LD_INT 2
116717: PUSH
116718: LD_INT 30
116720: PUSH
116721: LD_INT 0
116723: PUSH
116724: EMPTY
116725: LIST
116726: LIST
116727: PUSH
116728: LD_INT 30
116730: PUSH
116731: LD_INT 1
116733: PUSH
116734: EMPTY
116735: LIST
116736: LIST
116737: PUSH
116738: EMPTY
116739: LIST
116740: LIST
116741: LIST
116742: PPUSH
116743: CALL_OW 72
116747: ST_TO_ADDR
// if z then
116748: LD_VAR 0 13
116752: IFFALSE 116798
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116754: LD_VAR 0 4
116758: PUSH
116759: LD_VAR 0 7
116763: ARRAY
116764: PPUSH
116765: LD_VAR 0 13
116769: PPUSH
116770: LD_VAR 0 4
116774: PUSH
116775: LD_VAR 0 7
116779: ARRAY
116780: PPUSH
116781: CALL_OW 74
116785: PPUSH
116786: CALL_OW 115
// attacking := true ;
116790: LD_ADDR_VAR 0 29
116794: PUSH
116795: LD_INT 1
116797: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116798: LD_VAR 0 4
116802: PUSH
116803: LD_VAR 0 7
116807: ARRAY
116808: PPUSH
116809: CALL_OW 256
116813: PUSH
116814: LD_INT 500
116816: LESS
116817: IFFALSE 116843
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116819: LD_VAR 0 4
116823: PUSH
116824: LD_VAR 0 7
116828: ARRAY
116829: PPUSH
116830: LD_VAR 0 14
116834: PUSH
116835: LD_INT 1
116837: ARRAY
116838: PPUSH
116839: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116843: LD_VAR 0 4
116847: PUSH
116848: LD_VAR 0 7
116852: ARRAY
116853: PPUSH
116854: CALL_OW 264
116858: PUSH
116859: LD_INT 49
116861: EQUAL
116862: IFFALSE 116983
// begin if not HasTask ( group [ i ] ) then
116864: LD_VAR 0 4
116868: PUSH
116869: LD_VAR 0 7
116873: ARRAY
116874: PPUSH
116875: CALL_OW 314
116879: NOT
116880: IFFALSE 116983
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116882: LD_ADDR_VAR 0 9
116886: PUSH
116887: LD_INT 81
116889: PUSH
116890: LD_VAR 0 4
116894: PUSH
116895: LD_VAR 0 7
116899: ARRAY
116900: PPUSH
116901: CALL_OW 255
116905: PUSH
116906: EMPTY
116907: LIST
116908: LIST
116909: PPUSH
116910: CALL_OW 69
116914: PPUSH
116915: LD_VAR 0 4
116919: PUSH
116920: LD_VAR 0 7
116924: ARRAY
116925: PPUSH
116926: CALL_OW 74
116930: ST_TO_ADDR
// if k then
116931: LD_VAR 0 9
116935: IFFALSE 116983
// if GetDistUnits ( group [ i ] , k ) > 10 then
116937: LD_VAR 0 4
116941: PUSH
116942: LD_VAR 0 7
116946: ARRAY
116947: PPUSH
116948: LD_VAR 0 9
116952: PPUSH
116953: CALL_OW 296
116957: PUSH
116958: LD_INT 10
116960: GREATER
116961: IFFALSE 116983
// ComMoveUnit ( group [ i ] , k ) ;
116963: LD_VAR 0 4
116967: PUSH
116968: LD_VAR 0 7
116972: ARRAY
116973: PPUSH
116974: LD_VAR 0 9
116978: PPUSH
116979: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116983: LD_VAR 0 4
116987: PUSH
116988: LD_VAR 0 7
116992: ARRAY
116993: PPUSH
116994: CALL_OW 256
116998: PUSH
116999: LD_INT 250
117001: LESS
117002: PUSH
117003: LD_VAR 0 4
117007: PUSH
117008: LD_VAR 0 7
117012: ARRAY
117013: PUSH
117014: LD_INT 21
117016: PUSH
117017: LD_INT 2
117019: PUSH
117020: EMPTY
117021: LIST
117022: LIST
117023: PUSH
117024: LD_INT 23
117026: PUSH
117027: LD_INT 2
117029: PUSH
117030: EMPTY
117031: LIST
117032: LIST
117033: PUSH
117034: EMPTY
117035: LIST
117036: LIST
117037: PPUSH
117038: CALL_OW 69
117042: IN
117043: AND
117044: IFFALSE 117169
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117046: LD_ADDR_VAR 0 9
117050: PUSH
117051: LD_OWVAR 3
117055: PUSH
117056: LD_VAR 0 4
117060: PUSH
117061: LD_VAR 0 7
117065: ARRAY
117066: DIFF
117067: PPUSH
117068: LD_VAR 0 4
117072: PUSH
117073: LD_VAR 0 7
117077: ARRAY
117078: PPUSH
117079: CALL_OW 74
117083: ST_TO_ADDR
// if not k then
117084: LD_VAR 0 9
117088: NOT
117089: IFFALSE 117093
// continue ;
117091: GO 113508
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117093: LD_VAR 0 9
117097: PUSH
117098: LD_INT 81
117100: PUSH
117101: LD_VAR 0 4
117105: PUSH
117106: LD_VAR 0 7
117110: ARRAY
117111: PPUSH
117112: CALL_OW 255
117116: PUSH
117117: EMPTY
117118: LIST
117119: LIST
117120: PPUSH
117121: CALL_OW 69
117125: IN
117126: PUSH
117127: LD_VAR 0 9
117131: PPUSH
117132: LD_VAR 0 4
117136: PUSH
117137: LD_VAR 0 7
117141: ARRAY
117142: PPUSH
117143: CALL_OW 296
117147: PUSH
117148: LD_INT 5
117150: LESS
117151: AND
117152: IFFALSE 117169
// ComAutodestruct ( group [ i ] ) ;
117154: LD_VAR 0 4
117158: PUSH
117159: LD_VAR 0 7
117163: ARRAY
117164: PPUSH
117165: CALL 84756 0 1
// end ; if f_attack_depot then
117169: LD_VAR 0 25
117173: IFFALSE 117285
// begin k := 6 ;
117175: LD_ADDR_VAR 0 9
117179: PUSH
117180: LD_INT 6
117182: ST_TO_ADDR
// if tmp < k then
117183: LD_VAR 0 14
117187: PUSH
117188: LD_VAR 0 9
117192: LESS
117193: IFFALSE 117205
// k := tmp ;
117195: LD_ADDR_VAR 0 9
117199: PUSH
117200: LD_VAR 0 14
117204: ST_TO_ADDR
// for j = 1 to k do
117205: LD_ADDR_VAR 0 8
117209: PUSH
117210: DOUBLE
117211: LD_INT 1
117213: DEC
117214: ST_TO_ADDR
117215: LD_VAR 0 9
117219: PUSH
117220: FOR_TO
117221: IFFALSE 117283
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117223: LD_VAR 0 8
117227: PPUSH
117228: CALL_OW 266
117232: PUSH
117233: LD_INT 0
117235: PUSH
117236: LD_INT 1
117238: PUSH
117239: EMPTY
117240: LIST
117241: LIST
117242: IN
117243: IFFALSE 117281
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117245: LD_VAR 0 4
117249: PUSH
117250: LD_VAR 0 7
117254: ARRAY
117255: PPUSH
117256: LD_VAR 0 14
117260: PUSH
117261: LD_VAR 0 8
117265: ARRAY
117266: PPUSH
117267: CALL_OW 115
// attacking := true ;
117271: LD_ADDR_VAR 0 29
117275: PUSH
117276: LD_INT 1
117278: ST_TO_ADDR
// break ;
117279: GO 117283
// end ;
117281: GO 117220
117283: POP
117284: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117285: LD_VAR 0 4
117289: PUSH
117290: LD_VAR 0 7
117294: ARRAY
117295: PPUSH
117296: CALL_OW 302
117300: PUSH
117301: LD_VAR 0 29
117305: NOT
117306: AND
117307: IFFALSE 117629
// begin if GetTag ( group [ i ] ) = 71 then
117309: LD_VAR 0 4
117313: PUSH
117314: LD_VAR 0 7
117318: ARRAY
117319: PPUSH
117320: CALL_OW 110
117324: PUSH
117325: LD_INT 71
117327: EQUAL
117328: IFFALSE 117369
// begin if HasTask ( group [ i ] ) then
117330: LD_VAR 0 4
117334: PUSH
117335: LD_VAR 0 7
117339: ARRAY
117340: PPUSH
117341: CALL_OW 314
117345: IFFALSE 117351
// continue else
117347: GO 113508
117349: GO 117369
// SetTag ( group [ i ] , 0 ) ;
117351: LD_VAR 0 4
117355: PUSH
117356: LD_VAR 0 7
117360: ARRAY
117361: PPUSH
117362: LD_INT 0
117364: PPUSH
117365: CALL_OW 109
// end ; k := 8 ;
117369: LD_ADDR_VAR 0 9
117373: PUSH
117374: LD_INT 8
117376: ST_TO_ADDR
// x := 0 ;
117377: LD_ADDR_VAR 0 10
117381: PUSH
117382: LD_INT 0
117384: ST_TO_ADDR
// if tmp < k then
117385: LD_VAR 0 14
117389: PUSH
117390: LD_VAR 0 9
117394: LESS
117395: IFFALSE 117407
// k := tmp ;
117397: LD_ADDR_VAR 0 9
117401: PUSH
117402: LD_VAR 0 14
117406: ST_TO_ADDR
// for j = 1 to k do
117407: LD_ADDR_VAR 0 8
117411: PUSH
117412: DOUBLE
117413: LD_INT 1
117415: DEC
117416: ST_TO_ADDR
117417: LD_VAR 0 9
117421: PUSH
117422: FOR_TO
117423: IFFALSE 117521
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117425: LD_VAR 0 14
117429: PUSH
117430: LD_VAR 0 8
117434: ARRAY
117435: PPUSH
117436: CALL_OW 247
117440: PUSH
117441: LD_INT 1
117443: EQUAL
117444: PUSH
117445: LD_VAR 0 14
117449: PUSH
117450: LD_VAR 0 8
117454: ARRAY
117455: PPUSH
117456: CALL_OW 256
117460: PUSH
117461: LD_INT 250
117463: LESS
117464: PUSH
117465: LD_VAR 0 20
117469: AND
117470: PUSH
117471: LD_VAR 0 20
117475: NOT
117476: PUSH
117477: LD_VAR 0 14
117481: PUSH
117482: LD_VAR 0 8
117486: ARRAY
117487: PPUSH
117488: CALL_OW 256
117492: PUSH
117493: LD_INT 250
117495: GREATEREQUAL
117496: AND
117497: OR
117498: AND
117499: IFFALSE 117519
// begin x := tmp [ j ] ;
117501: LD_ADDR_VAR 0 10
117505: PUSH
117506: LD_VAR 0 14
117510: PUSH
117511: LD_VAR 0 8
117515: ARRAY
117516: ST_TO_ADDR
// break ;
117517: GO 117521
// end ;
117519: GO 117422
117521: POP
117522: POP
// if x then
117523: LD_VAR 0 10
117527: IFFALSE 117551
// ComAttackUnit ( group [ i ] , x ) else
117529: LD_VAR 0 4
117533: PUSH
117534: LD_VAR 0 7
117538: ARRAY
117539: PPUSH
117540: LD_VAR 0 10
117544: PPUSH
117545: CALL_OW 115
117549: GO 117575
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117551: LD_VAR 0 4
117555: PUSH
117556: LD_VAR 0 7
117560: ARRAY
117561: PPUSH
117562: LD_VAR 0 14
117566: PUSH
117567: LD_INT 1
117569: ARRAY
117570: PPUSH
117571: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117575: LD_VAR 0 4
117579: PUSH
117580: LD_VAR 0 7
117584: ARRAY
117585: PPUSH
117586: CALL_OW 314
117590: NOT
117591: IFFALSE 117629
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117593: LD_VAR 0 4
117597: PUSH
117598: LD_VAR 0 7
117602: ARRAY
117603: PPUSH
117604: LD_VAR 0 14
117608: PPUSH
117609: LD_VAR 0 4
117613: PUSH
117614: LD_VAR 0 7
117618: ARRAY
117619: PPUSH
117620: CALL_OW 74
117624: PPUSH
117625: CALL_OW 115
// end ; end ; end ;
117629: GO 113508
117631: POP
117632: POP
// wait ( 0 0$2 ) ;
117633: LD_INT 70
117635: PPUSH
117636: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117640: LD_VAR 0 4
117644: NOT
117645: PUSH
117646: LD_VAR 0 4
117650: PUSH
117651: EMPTY
117652: EQUAL
117653: OR
117654: PUSH
117655: LD_INT 81
117657: PUSH
117658: LD_VAR 0 35
117662: PUSH
117663: EMPTY
117664: LIST
117665: LIST
117666: PPUSH
117667: CALL_OW 69
117671: NOT
117672: OR
117673: IFFALSE 113493
// end ;
117675: LD_VAR 0 2
117679: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
117680: LD_INT 0
117682: PPUSH
117683: PPUSH
117684: PPUSH
117685: PPUSH
117686: PPUSH
117687: PPUSH
// if not base or not mc_bases [ base ] or not solds then
117688: LD_VAR 0 1
117692: NOT
117693: PUSH
117694: LD_EXP 76
117698: PUSH
117699: LD_VAR 0 1
117703: ARRAY
117704: NOT
117705: OR
117706: PUSH
117707: LD_VAR 0 2
117711: NOT
117712: OR
117713: IFFALSE 117717
// exit ;
117715: GO 118271
// side := mc_sides [ base ] ;
117717: LD_ADDR_VAR 0 6
117721: PUSH
117722: LD_EXP 102
117726: PUSH
117727: LD_VAR 0 1
117731: ARRAY
117732: ST_TO_ADDR
// if not side then
117733: LD_VAR 0 6
117737: NOT
117738: IFFALSE 117742
// exit ;
117740: GO 118271
// for i in solds do
117742: LD_ADDR_VAR 0 7
117746: PUSH
117747: LD_VAR 0 2
117751: PUSH
117752: FOR_IN
117753: IFFALSE 117814
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117755: LD_VAR 0 7
117759: PPUSH
117760: CALL_OW 310
117764: PPUSH
117765: CALL_OW 266
117769: PUSH
117770: LD_INT 32
117772: PUSH
117773: LD_INT 31
117775: PUSH
117776: EMPTY
117777: LIST
117778: LIST
117779: IN
117780: IFFALSE 117800
// solds := solds diff i else
117782: LD_ADDR_VAR 0 2
117786: PUSH
117787: LD_VAR 0 2
117791: PUSH
117792: LD_VAR 0 7
117796: DIFF
117797: ST_TO_ADDR
117798: GO 117812
// SetTag ( i , 18 ) ;
117800: LD_VAR 0 7
117804: PPUSH
117805: LD_INT 18
117807: PPUSH
117808: CALL_OW 109
117812: GO 117752
117814: POP
117815: POP
// if not solds then
117816: LD_VAR 0 2
117820: NOT
117821: IFFALSE 117825
// exit ;
117823: GO 118271
// repeat wait ( 0 0$2 ) ;
117825: LD_INT 70
117827: PPUSH
117828: CALL_OW 67
// enemy := mc_scan [ base ] ;
117832: LD_ADDR_VAR 0 4
117836: PUSH
117837: LD_EXP 99
117841: PUSH
117842: LD_VAR 0 1
117846: ARRAY
117847: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117848: LD_EXP 76
117852: PUSH
117853: LD_VAR 0 1
117857: ARRAY
117858: NOT
117859: PUSH
117860: LD_EXP 76
117864: PUSH
117865: LD_VAR 0 1
117869: ARRAY
117870: PUSH
117871: EMPTY
117872: EQUAL
117873: OR
117874: IFFALSE 117911
// begin for i in solds do
117876: LD_ADDR_VAR 0 7
117880: PUSH
117881: LD_VAR 0 2
117885: PUSH
117886: FOR_IN
117887: IFFALSE 117900
// ComStop ( i ) ;
117889: LD_VAR 0 7
117893: PPUSH
117894: CALL_OW 141
117898: GO 117886
117900: POP
117901: POP
// solds := [ ] ;
117902: LD_ADDR_VAR 0 2
117906: PUSH
117907: EMPTY
117908: ST_TO_ADDR
// exit ;
117909: GO 118271
// end ; for i in solds do
117911: LD_ADDR_VAR 0 7
117915: PUSH
117916: LD_VAR 0 2
117920: PUSH
117921: FOR_IN
117922: IFFALSE 118243
// begin if IsInUnit ( i ) then
117924: LD_VAR 0 7
117928: PPUSH
117929: CALL_OW 310
117933: IFFALSE 117944
// ComExitBuilding ( i ) ;
117935: LD_VAR 0 7
117939: PPUSH
117940: CALL_OW 122
// if GetLives ( i ) > 500 then
117944: LD_VAR 0 7
117948: PPUSH
117949: CALL_OW 256
117953: PUSH
117954: LD_INT 500
117956: GREATER
117957: IFFALSE 118010
// begin e := NearestUnitToUnit ( enemy , i ) ;
117959: LD_ADDR_VAR 0 5
117963: PUSH
117964: LD_VAR 0 4
117968: PPUSH
117969: LD_VAR 0 7
117973: PPUSH
117974: CALL_OW 74
117978: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
117979: LD_VAR 0 7
117983: PPUSH
117984: LD_VAR 0 5
117988: PPUSH
117989: CALL_OW 250
117993: PPUSH
117994: LD_VAR 0 5
117998: PPUSH
117999: CALL_OW 251
118003: PPUSH
118004: CALL_OW 114
// end else
118008: GO 118241
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
118010: LD_VAR 0 7
118014: PPUSH
118015: LD_EXP 76
118019: PUSH
118020: LD_VAR 0 1
118024: ARRAY
118025: PPUSH
118026: LD_INT 2
118028: PUSH
118029: LD_INT 30
118031: PUSH
118032: LD_INT 0
118034: PUSH
118035: EMPTY
118036: LIST
118037: LIST
118038: PUSH
118039: LD_INT 30
118041: PUSH
118042: LD_INT 1
118044: PUSH
118045: EMPTY
118046: LIST
118047: LIST
118048: PUSH
118049: LD_INT 30
118051: PUSH
118052: LD_INT 6
118054: PUSH
118055: EMPTY
118056: LIST
118057: LIST
118058: PUSH
118059: EMPTY
118060: LIST
118061: LIST
118062: LIST
118063: LIST
118064: PPUSH
118065: CALL_OW 72
118069: PPUSH
118070: LD_VAR 0 7
118074: PPUSH
118075: CALL_OW 74
118079: PPUSH
118080: CALL_OW 296
118084: PUSH
118085: LD_INT 10
118087: GREATER
118088: IFFALSE 118241
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118090: LD_ADDR_VAR 0 8
118094: PUSH
118095: LD_EXP 76
118099: PUSH
118100: LD_VAR 0 1
118104: ARRAY
118105: PPUSH
118106: LD_INT 2
118108: PUSH
118109: LD_INT 30
118111: PUSH
118112: LD_INT 0
118114: PUSH
118115: EMPTY
118116: LIST
118117: LIST
118118: PUSH
118119: LD_INT 30
118121: PUSH
118122: LD_INT 1
118124: PUSH
118125: EMPTY
118126: LIST
118127: LIST
118128: PUSH
118129: LD_INT 30
118131: PUSH
118132: LD_INT 6
118134: PUSH
118135: EMPTY
118136: LIST
118137: LIST
118138: PUSH
118139: EMPTY
118140: LIST
118141: LIST
118142: LIST
118143: LIST
118144: PPUSH
118145: CALL_OW 72
118149: PPUSH
118150: LD_VAR 0 7
118154: PPUSH
118155: CALL_OW 74
118159: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118160: LD_VAR 0 7
118164: PPUSH
118165: LD_VAR 0 8
118169: PPUSH
118170: CALL_OW 250
118174: PPUSH
118175: LD_INT 3
118177: PPUSH
118178: LD_INT 5
118180: PPUSH
118181: CALL_OW 272
118185: PPUSH
118186: LD_VAR 0 8
118190: PPUSH
118191: CALL_OW 251
118195: PPUSH
118196: LD_INT 3
118198: PPUSH
118199: LD_INT 5
118201: PPUSH
118202: CALL_OW 273
118206: PPUSH
118207: CALL_OW 111
// SetTag ( i , 0 ) ;
118211: LD_VAR 0 7
118215: PPUSH
118216: LD_INT 0
118218: PPUSH
118219: CALL_OW 109
// solds := solds diff i ;
118223: LD_ADDR_VAR 0 2
118227: PUSH
118228: LD_VAR 0 2
118232: PUSH
118233: LD_VAR 0 7
118237: DIFF
118238: ST_TO_ADDR
// continue ;
118239: GO 117921
// end ; end ;
118241: GO 117921
118243: POP
118244: POP
// until not solds or not enemy ;
118245: LD_VAR 0 2
118249: NOT
118250: PUSH
118251: LD_VAR 0 4
118255: NOT
118256: OR
118257: IFFALSE 117825
// MC_Reset ( base , 18 ) ;
118259: LD_VAR 0 1
118263: PPUSH
118264: LD_INT 18
118266: PPUSH
118267: CALL 25398 0 2
// end ;
118271: LD_VAR 0 3
118275: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
118276: LD_INT 0
118278: PPUSH
118279: PPUSH
118280: PPUSH
118281: PPUSH
118282: PPUSH
118283: PPUSH
118284: PPUSH
118285: PPUSH
118286: PPUSH
118287: PPUSH
118288: PPUSH
118289: PPUSH
118290: PPUSH
118291: PPUSH
118292: PPUSH
118293: PPUSH
118294: PPUSH
118295: PPUSH
118296: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118297: LD_ADDR_VAR 0 12
118301: PUSH
118302: LD_EXP 76
118306: PUSH
118307: LD_VAR 0 1
118311: ARRAY
118312: PPUSH
118313: LD_INT 25
118315: PUSH
118316: LD_INT 3
118318: PUSH
118319: EMPTY
118320: LIST
118321: LIST
118322: PPUSH
118323: CALL_OW 72
118327: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118328: LD_EXP 116
118332: PUSH
118333: LD_VAR 0 1
118337: ARRAY
118338: IFFALSE 118362
// mechs := mechs diff mc_remote_driver [ base ] ;
118340: LD_ADDR_VAR 0 12
118344: PUSH
118345: LD_VAR 0 12
118349: PUSH
118350: LD_EXP 116
118354: PUSH
118355: LD_VAR 0 1
118359: ARRAY
118360: DIFF
118361: ST_TO_ADDR
// for i in mechs do
118362: LD_ADDR_VAR 0 4
118366: PUSH
118367: LD_VAR 0 12
118371: PUSH
118372: FOR_IN
118373: IFFALSE 118408
// if GetTag ( i ) > 0 then
118375: LD_VAR 0 4
118379: PPUSH
118380: CALL_OW 110
118384: PUSH
118385: LD_INT 0
118387: GREATER
118388: IFFALSE 118406
// mechs := mechs diff i ;
118390: LD_ADDR_VAR 0 12
118394: PUSH
118395: LD_VAR 0 12
118399: PUSH
118400: LD_VAR 0 4
118404: DIFF
118405: ST_TO_ADDR
118406: GO 118372
118408: POP
118409: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118410: LD_ADDR_VAR 0 8
118414: PUSH
118415: LD_EXP 76
118419: PUSH
118420: LD_VAR 0 1
118424: ARRAY
118425: PPUSH
118426: LD_INT 2
118428: PUSH
118429: LD_INT 25
118431: PUSH
118432: LD_INT 1
118434: PUSH
118435: EMPTY
118436: LIST
118437: LIST
118438: PUSH
118439: LD_INT 25
118441: PUSH
118442: LD_INT 5
118444: PUSH
118445: EMPTY
118446: LIST
118447: LIST
118448: PUSH
118449: LD_INT 25
118451: PUSH
118452: LD_INT 8
118454: PUSH
118455: EMPTY
118456: LIST
118457: LIST
118458: PUSH
118459: LD_INT 25
118461: PUSH
118462: LD_INT 9
118464: PUSH
118465: EMPTY
118466: LIST
118467: LIST
118468: PUSH
118469: EMPTY
118470: LIST
118471: LIST
118472: LIST
118473: LIST
118474: LIST
118475: PPUSH
118476: CALL_OW 72
118480: ST_TO_ADDR
// if not defenders and not solds then
118481: LD_VAR 0 2
118485: NOT
118486: PUSH
118487: LD_VAR 0 8
118491: NOT
118492: AND
118493: IFFALSE 118497
// exit ;
118495: GO 120267
// depot_under_attack := false ;
118497: LD_ADDR_VAR 0 16
118501: PUSH
118502: LD_INT 0
118504: ST_TO_ADDR
// sold_defenders := [ ] ;
118505: LD_ADDR_VAR 0 17
118509: PUSH
118510: EMPTY
118511: ST_TO_ADDR
// if mechs then
118512: LD_VAR 0 12
118516: IFFALSE 118669
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
118518: LD_ADDR_VAR 0 4
118522: PUSH
118523: LD_VAR 0 2
118527: PPUSH
118528: LD_INT 21
118530: PUSH
118531: LD_INT 2
118533: PUSH
118534: EMPTY
118535: LIST
118536: LIST
118537: PPUSH
118538: CALL_OW 72
118542: PUSH
118543: FOR_IN
118544: IFFALSE 118667
// begin if GetTag ( i ) <> 20 then
118546: LD_VAR 0 4
118550: PPUSH
118551: CALL_OW 110
118555: PUSH
118556: LD_INT 20
118558: NONEQUAL
118559: IFFALSE 118573
// SetTag ( i , 20 ) ;
118561: LD_VAR 0 4
118565: PPUSH
118566: LD_INT 20
118568: PPUSH
118569: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
118573: LD_VAR 0 4
118577: PPUSH
118578: CALL_OW 263
118582: PUSH
118583: LD_INT 1
118585: EQUAL
118586: PUSH
118587: LD_VAR 0 4
118591: PPUSH
118592: CALL_OW 311
118596: NOT
118597: AND
118598: IFFALSE 118665
// begin un := mechs [ 1 ] ;
118600: LD_ADDR_VAR 0 10
118604: PUSH
118605: LD_VAR 0 12
118609: PUSH
118610: LD_INT 1
118612: ARRAY
118613: ST_TO_ADDR
// ComExit ( un ) ;
118614: LD_VAR 0 10
118618: PPUSH
118619: CALL 89622 0 1
// AddComEnterUnit ( un , i ) ;
118623: LD_VAR 0 10
118627: PPUSH
118628: LD_VAR 0 4
118632: PPUSH
118633: CALL_OW 180
// SetTag ( un , 19 ) ;
118637: LD_VAR 0 10
118641: PPUSH
118642: LD_INT 19
118644: PPUSH
118645: CALL_OW 109
// mechs := mechs diff un ;
118649: LD_ADDR_VAR 0 12
118653: PUSH
118654: LD_VAR 0 12
118658: PUSH
118659: LD_VAR 0 10
118663: DIFF
118664: ST_TO_ADDR
// end ; end ;
118665: GO 118543
118667: POP
118668: POP
// if solds then
118669: LD_VAR 0 8
118673: IFFALSE 118732
// for i in solds do
118675: LD_ADDR_VAR 0 4
118679: PUSH
118680: LD_VAR 0 8
118684: PUSH
118685: FOR_IN
118686: IFFALSE 118730
// if not GetTag ( i ) then
118688: LD_VAR 0 4
118692: PPUSH
118693: CALL_OW 110
118697: NOT
118698: IFFALSE 118728
// begin defenders := defenders union i ;
118700: LD_ADDR_VAR 0 2
118704: PUSH
118705: LD_VAR 0 2
118709: PUSH
118710: LD_VAR 0 4
118714: UNION
118715: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118716: LD_VAR 0 4
118720: PPUSH
118721: LD_INT 18
118723: PPUSH
118724: CALL_OW 109
// end ;
118728: GO 118685
118730: POP
118731: POP
// repeat wait ( 0 0$2 ) ;
118732: LD_INT 70
118734: PPUSH
118735: CALL_OW 67
// enemy := mc_scan [ base ] ;
118739: LD_ADDR_VAR 0 21
118743: PUSH
118744: LD_EXP 99
118748: PUSH
118749: LD_VAR 0 1
118753: ARRAY
118754: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118755: LD_EXP 76
118759: PUSH
118760: LD_VAR 0 1
118764: ARRAY
118765: NOT
118766: PUSH
118767: LD_EXP 76
118771: PUSH
118772: LD_VAR 0 1
118776: ARRAY
118777: PUSH
118778: EMPTY
118779: EQUAL
118780: OR
118781: IFFALSE 118818
// begin for i in defenders do
118783: LD_ADDR_VAR 0 4
118787: PUSH
118788: LD_VAR 0 2
118792: PUSH
118793: FOR_IN
118794: IFFALSE 118807
// ComStop ( i ) ;
118796: LD_VAR 0 4
118800: PPUSH
118801: CALL_OW 141
118805: GO 118793
118807: POP
118808: POP
// defenders := [ ] ;
118809: LD_ADDR_VAR 0 2
118813: PUSH
118814: EMPTY
118815: ST_TO_ADDR
// exit ;
118816: GO 120267
// end ; for i in defenders do
118818: LD_ADDR_VAR 0 4
118822: PUSH
118823: LD_VAR 0 2
118827: PUSH
118828: FOR_IN
118829: IFFALSE 119727
// begin e := NearestUnitToUnit ( enemy , i ) ;
118831: LD_ADDR_VAR 0 13
118835: PUSH
118836: LD_VAR 0 21
118840: PPUSH
118841: LD_VAR 0 4
118845: PPUSH
118846: CALL_OW 74
118850: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118851: LD_ADDR_VAR 0 7
118855: PUSH
118856: LD_EXP 76
118860: PUSH
118861: LD_VAR 0 1
118865: ARRAY
118866: PPUSH
118867: LD_INT 2
118869: PUSH
118870: LD_INT 30
118872: PUSH
118873: LD_INT 0
118875: PUSH
118876: EMPTY
118877: LIST
118878: LIST
118879: PUSH
118880: LD_INT 30
118882: PUSH
118883: LD_INT 1
118885: PUSH
118886: EMPTY
118887: LIST
118888: LIST
118889: PUSH
118890: EMPTY
118891: LIST
118892: LIST
118893: LIST
118894: PPUSH
118895: CALL_OW 72
118899: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118900: LD_ADDR_VAR 0 16
118904: PUSH
118905: LD_VAR 0 7
118909: NOT
118910: PUSH
118911: LD_VAR 0 7
118915: PPUSH
118916: LD_INT 3
118918: PUSH
118919: LD_INT 24
118921: PUSH
118922: LD_INT 600
118924: PUSH
118925: EMPTY
118926: LIST
118927: LIST
118928: PUSH
118929: EMPTY
118930: LIST
118931: LIST
118932: PPUSH
118933: CALL_OW 72
118937: OR
118938: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118939: LD_VAR 0 4
118943: PPUSH
118944: CALL_OW 247
118948: PUSH
118949: LD_INT 2
118951: DOUBLE
118952: EQUAL
118953: IFTRUE 118957
118955: GO 119353
118957: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118958: LD_VAR 0 4
118962: PPUSH
118963: CALL_OW 256
118967: PUSH
118968: LD_INT 1000
118970: EQUAL
118971: PUSH
118972: LD_VAR 0 4
118976: PPUSH
118977: LD_VAR 0 13
118981: PPUSH
118982: CALL_OW 296
118986: PUSH
118987: LD_INT 40
118989: LESS
118990: PUSH
118991: LD_VAR 0 13
118995: PPUSH
118996: LD_EXP 101
119000: PUSH
119001: LD_VAR 0 1
119005: ARRAY
119006: PPUSH
119007: CALL_OW 308
119011: OR
119012: AND
119013: IFFALSE 119135
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119015: LD_VAR 0 4
119019: PPUSH
119020: CALL_OW 262
119024: PUSH
119025: LD_INT 1
119027: EQUAL
119028: PUSH
119029: LD_VAR 0 4
119033: PPUSH
119034: CALL_OW 261
119038: PUSH
119039: LD_INT 30
119041: LESS
119042: AND
119043: PUSH
119044: LD_VAR 0 7
119048: AND
119049: IFFALSE 119119
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119051: LD_VAR 0 4
119055: PPUSH
119056: LD_VAR 0 7
119060: PPUSH
119061: LD_VAR 0 4
119065: PPUSH
119066: CALL_OW 74
119070: PPUSH
119071: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119075: LD_VAR 0 4
119079: PPUSH
119080: LD_VAR 0 7
119084: PPUSH
119085: LD_VAR 0 4
119089: PPUSH
119090: CALL_OW 74
119094: PPUSH
119095: CALL_OW 296
119099: PUSH
119100: LD_INT 6
119102: LESS
119103: IFFALSE 119117
// SetFuel ( i , 100 ) ;
119105: LD_VAR 0 4
119109: PPUSH
119110: LD_INT 100
119112: PPUSH
119113: CALL_OW 240
// end else
119117: GO 119133
// ComAttackUnit ( i , e ) ;
119119: LD_VAR 0 4
119123: PPUSH
119124: LD_VAR 0 13
119128: PPUSH
119129: CALL_OW 115
// end else
119133: GO 119236
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119135: LD_VAR 0 13
119139: PPUSH
119140: LD_EXP 101
119144: PUSH
119145: LD_VAR 0 1
119149: ARRAY
119150: PPUSH
119151: CALL_OW 308
119155: NOT
119156: PUSH
119157: LD_VAR 0 4
119161: PPUSH
119162: LD_VAR 0 13
119166: PPUSH
119167: CALL_OW 296
119171: PUSH
119172: LD_INT 40
119174: GREATEREQUAL
119175: AND
119176: PUSH
119177: LD_VAR 0 4
119181: PPUSH
119182: CALL_OW 256
119186: PUSH
119187: LD_INT 650
119189: LESSEQUAL
119190: OR
119191: PUSH
119192: LD_VAR 0 4
119196: PPUSH
119197: LD_EXP 100
119201: PUSH
119202: LD_VAR 0 1
119206: ARRAY
119207: PPUSH
119208: CALL_OW 308
119212: NOT
119213: AND
119214: IFFALSE 119236
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119216: LD_VAR 0 4
119220: PPUSH
119221: LD_EXP 100
119225: PUSH
119226: LD_VAR 0 1
119230: ARRAY
119231: PPUSH
119232: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119236: LD_VAR 0 4
119240: PPUSH
119241: CALL_OW 256
119245: PUSH
119246: LD_INT 1000
119248: LESS
119249: PUSH
119250: LD_VAR 0 4
119254: PPUSH
119255: CALL_OW 263
119259: PUSH
119260: LD_INT 1
119262: EQUAL
119263: AND
119264: PUSH
119265: LD_VAR 0 4
119269: PPUSH
119270: CALL_OW 311
119274: AND
119275: PUSH
119276: LD_VAR 0 4
119280: PPUSH
119281: LD_EXP 100
119285: PUSH
119286: LD_VAR 0 1
119290: ARRAY
119291: PPUSH
119292: CALL_OW 308
119296: AND
119297: IFFALSE 119351
// begin mech := IsDrivenBy ( i ) ;
119299: LD_ADDR_VAR 0 9
119303: PUSH
119304: LD_VAR 0 4
119308: PPUSH
119309: CALL_OW 311
119313: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119314: LD_VAR 0 9
119318: PPUSH
119319: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119323: LD_VAR 0 9
119327: PPUSH
119328: LD_VAR 0 4
119332: PPUSH
119333: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119337: LD_VAR 0 9
119341: PPUSH
119342: LD_VAR 0 4
119346: PPUSH
119347: CALL_OW 180
// end ; end ; unit_human :
119351: GO 119698
119353: LD_INT 1
119355: DOUBLE
119356: EQUAL
119357: IFTRUE 119361
119359: GO 119697
119361: POP
// begin b := IsInUnit ( i ) ;
119362: LD_ADDR_VAR 0 18
119366: PUSH
119367: LD_VAR 0 4
119371: PPUSH
119372: CALL_OW 310
119376: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119377: LD_ADDR_VAR 0 19
119381: PUSH
119382: LD_VAR 0 18
119386: NOT
119387: PUSH
119388: LD_VAR 0 18
119392: PPUSH
119393: CALL_OW 266
119397: PUSH
119398: LD_INT 32
119400: PUSH
119401: LD_INT 31
119403: PUSH
119404: EMPTY
119405: LIST
119406: LIST
119407: IN
119408: OR
119409: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
119410: LD_VAR 0 18
119414: PPUSH
119415: CALL_OW 266
119419: PUSH
119420: LD_INT 5
119422: EQUAL
119423: PUSH
119424: LD_VAR 0 4
119428: PPUSH
119429: CALL_OW 257
119433: PUSH
119434: LD_INT 1
119436: PUSH
119437: LD_INT 2
119439: PUSH
119440: LD_INT 3
119442: PUSH
119443: LD_INT 4
119445: PUSH
119446: EMPTY
119447: LIST
119448: LIST
119449: LIST
119450: LIST
119451: IN
119452: AND
119453: IFFALSE 119490
// begin class := AllowSpecClass ( i ) ;
119455: LD_ADDR_VAR 0 20
119459: PUSH
119460: LD_VAR 0 4
119464: PPUSH
119465: CALL 53634 0 1
119469: ST_TO_ADDR
// if class then
119470: LD_VAR 0 20
119474: IFFALSE 119490
// ComChangeProfession ( i , class ) ;
119476: LD_VAR 0 4
119480: PPUSH
119481: LD_VAR 0 20
119485: PPUSH
119486: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119490: LD_VAR 0 16
119494: PUSH
119495: LD_VAR 0 2
119499: PPUSH
119500: LD_INT 21
119502: PUSH
119503: LD_INT 2
119505: PUSH
119506: EMPTY
119507: LIST
119508: LIST
119509: PPUSH
119510: CALL_OW 72
119514: PUSH
119515: LD_INT 1
119517: LESSEQUAL
119518: OR
119519: PUSH
119520: LD_VAR 0 19
119524: AND
119525: PUSH
119526: LD_VAR 0 4
119530: PUSH
119531: LD_VAR 0 17
119535: IN
119536: NOT
119537: AND
119538: IFFALSE 119631
// begin if b then
119540: LD_VAR 0 18
119544: IFFALSE 119593
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119546: LD_VAR 0 18
119550: PPUSH
119551: LD_VAR 0 21
119555: PPUSH
119556: LD_VAR 0 18
119560: PPUSH
119561: CALL_OW 74
119565: PPUSH
119566: CALL_OW 296
119570: PUSH
119571: LD_INT 10
119573: LESS
119574: PUSH
119575: LD_VAR 0 18
119579: PPUSH
119580: CALL_OW 461
119584: PUSH
119585: LD_INT 7
119587: NONEQUAL
119588: AND
119589: IFFALSE 119593
// continue ;
119591: GO 118828
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119593: LD_ADDR_VAR 0 17
119597: PUSH
119598: LD_VAR 0 17
119602: PPUSH
119603: LD_VAR 0 17
119607: PUSH
119608: LD_INT 1
119610: PLUS
119611: PPUSH
119612: LD_VAR 0 4
119616: PPUSH
119617: CALL_OW 1
119621: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119622: LD_VAR 0 4
119626: PPUSH
119627: CALL_OW 122
// end ; if sold_defenders then
119631: LD_VAR 0 17
119635: IFFALSE 119695
// if i in sold_defenders then
119637: LD_VAR 0 4
119641: PUSH
119642: LD_VAR 0 17
119646: IN
119647: IFFALSE 119695
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119649: LD_VAR 0 4
119653: PPUSH
119654: CALL_OW 314
119658: NOT
119659: PUSH
119660: LD_VAR 0 4
119664: PPUSH
119665: LD_VAR 0 13
119669: PPUSH
119670: CALL_OW 296
119674: PUSH
119675: LD_INT 30
119677: LESS
119678: AND
119679: IFFALSE 119695
// ComAttackUnit ( i , e ) ;
119681: LD_VAR 0 4
119685: PPUSH
119686: LD_VAR 0 13
119690: PPUSH
119691: CALL_OW 115
// end ; end ; end ;
119695: GO 119698
119697: POP
// if IsDead ( i ) then
119698: LD_VAR 0 4
119702: PPUSH
119703: CALL_OW 301
119707: IFFALSE 119725
// defenders := defenders diff i ;
119709: LD_ADDR_VAR 0 2
119713: PUSH
119714: LD_VAR 0 2
119718: PUSH
119719: LD_VAR 0 4
119723: DIFF
119724: ST_TO_ADDR
// end ;
119725: GO 118828
119727: POP
119728: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119729: LD_VAR 0 21
119733: NOT
119734: PUSH
119735: LD_VAR 0 2
119739: NOT
119740: OR
119741: PUSH
119742: LD_EXP 76
119746: PUSH
119747: LD_VAR 0 1
119751: ARRAY
119752: NOT
119753: OR
119754: IFFALSE 118732
// MC_Reset ( base , 18 ) ;
119756: LD_VAR 0 1
119760: PPUSH
119761: LD_INT 18
119763: PPUSH
119764: CALL 25398 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119768: LD_ADDR_VAR 0 2
119772: PUSH
119773: LD_VAR 0 2
119777: PUSH
119778: LD_VAR 0 2
119782: PPUSH
119783: LD_INT 2
119785: PUSH
119786: LD_INT 25
119788: PUSH
119789: LD_INT 1
119791: PUSH
119792: EMPTY
119793: LIST
119794: LIST
119795: PUSH
119796: LD_INT 25
119798: PUSH
119799: LD_INT 5
119801: PUSH
119802: EMPTY
119803: LIST
119804: LIST
119805: PUSH
119806: LD_INT 25
119808: PUSH
119809: LD_INT 8
119811: PUSH
119812: EMPTY
119813: LIST
119814: LIST
119815: PUSH
119816: LD_INT 25
119818: PUSH
119819: LD_INT 9
119821: PUSH
119822: EMPTY
119823: LIST
119824: LIST
119825: PUSH
119826: EMPTY
119827: LIST
119828: LIST
119829: LIST
119830: LIST
119831: LIST
119832: PPUSH
119833: CALL_OW 72
119837: DIFF
119838: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119839: LD_VAR 0 21
119843: NOT
119844: PUSH
119845: LD_VAR 0 2
119849: PPUSH
119850: LD_INT 21
119852: PUSH
119853: LD_INT 2
119855: PUSH
119856: EMPTY
119857: LIST
119858: LIST
119859: PPUSH
119860: CALL_OW 72
119864: AND
119865: IFFALSE 120203
// begin tmp := FilterByTag ( defenders , 19 ) ;
119867: LD_ADDR_VAR 0 11
119871: PUSH
119872: LD_VAR 0 2
119876: PPUSH
119877: LD_INT 19
119879: PPUSH
119880: CALL 86798 0 2
119884: ST_TO_ADDR
// if tmp then
119885: LD_VAR 0 11
119889: IFFALSE 119959
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119891: LD_ADDR_VAR 0 11
119895: PUSH
119896: LD_VAR 0 11
119900: PPUSH
119901: LD_INT 25
119903: PUSH
119904: LD_INT 3
119906: PUSH
119907: EMPTY
119908: LIST
119909: LIST
119910: PPUSH
119911: CALL_OW 72
119915: ST_TO_ADDR
// if tmp then
119916: LD_VAR 0 11
119920: IFFALSE 119959
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119922: LD_ADDR_EXP 88
119926: PUSH
119927: LD_EXP 88
119931: PPUSH
119932: LD_VAR 0 1
119936: PPUSH
119937: LD_EXP 88
119941: PUSH
119942: LD_VAR 0 1
119946: ARRAY
119947: PUSH
119948: LD_VAR 0 11
119952: UNION
119953: PPUSH
119954: CALL_OW 1
119958: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119959: LD_VAR 0 1
119963: PPUSH
119964: LD_INT 19
119966: PPUSH
119967: CALL 25398 0 2
// repeat wait ( 0 0$1 ) ;
119971: LD_INT 35
119973: PPUSH
119974: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119978: LD_EXP 76
119982: PUSH
119983: LD_VAR 0 1
119987: ARRAY
119988: NOT
119989: PUSH
119990: LD_EXP 76
119994: PUSH
119995: LD_VAR 0 1
119999: ARRAY
120000: PUSH
120001: EMPTY
120002: EQUAL
120003: OR
120004: IFFALSE 120041
// begin for i in defenders do
120006: LD_ADDR_VAR 0 4
120010: PUSH
120011: LD_VAR 0 2
120015: PUSH
120016: FOR_IN
120017: IFFALSE 120030
// ComStop ( i ) ;
120019: LD_VAR 0 4
120023: PPUSH
120024: CALL_OW 141
120028: GO 120016
120030: POP
120031: POP
// defenders := [ ] ;
120032: LD_ADDR_VAR 0 2
120036: PUSH
120037: EMPTY
120038: ST_TO_ADDR
// exit ;
120039: GO 120267
// end ; for i in defenders do
120041: LD_ADDR_VAR 0 4
120045: PUSH
120046: LD_VAR 0 2
120050: PUSH
120051: FOR_IN
120052: IFFALSE 120141
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120054: LD_VAR 0 4
120058: PPUSH
120059: LD_EXP 100
120063: PUSH
120064: LD_VAR 0 1
120068: ARRAY
120069: PPUSH
120070: CALL_OW 308
120074: NOT
120075: IFFALSE 120099
// ComMoveToArea ( i , mc_parking [ base ] ) else
120077: LD_VAR 0 4
120081: PPUSH
120082: LD_EXP 100
120086: PUSH
120087: LD_VAR 0 1
120091: ARRAY
120092: PPUSH
120093: CALL_OW 113
120097: GO 120139
// if GetControl ( i ) = control_manual then
120099: LD_VAR 0 4
120103: PPUSH
120104: CALL_OW 263
120108: PUSH
120109: LD_INT 1
120111: EQUAL
120112: IFFALSE 120139
// if IsDrivenBy ( i ) then
120114: LD_VAR 0 4
120118: PPUSH
120119: CALL_OW 311
120123: IFFALSE 120139
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120125: LD_VAR 0 4
120129: PPUSH
120130: CALL_OW 311
120134: PPUSH
120135: CALL_OW 121
// end ;
120139: GO 120051
120141: POP
120142: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120143: LD_VAR 0 2
120147: PPUSH
120148: LD_INT 95
120150: PUSH
120151: LD_EXP 100
120155: PUSH
120156: LD_VAR 0 1
120160: ARRAY
120161: PUSH
120162: EMPTY
120163: LIST
120164: LIST
120165: PPUSH
120166: CALL_OW 72
120170: PUSH
120171: LD_VAR 0 2
120175: EQUAL
120176: PUSH
120177: LD_EXP 99
120181: PUSH
120182: LD_VAR 0 1
120186: ARRAY
120187: OR
120188: PUSH
120189: LD_EXP 76
120193: PUSH
120194: LD_VAR 0 1
120198: ARRAY
120199: NOT
120200: OR
120201: IFFALSE 119971
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
120203: LD_ADDR_EXP 98
120207: PUSH
120208: LD_EXP 98
120212: PPUSH
120213: LD_VAR 0 1
120217: PPUSH
120218: LD_VAR 0 2
120222: PPUSH
120223: LD_INT 21
120225: PUSH
120226: LD_INT 2
120228: PUSH
120229: EMPTY
120230: LIST
120231: LIST
120232: PPUSH
120233: CALL_OW 72
120237: PPUSH
120238: CALL_OW 1
120242: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
120243: LD_VAR 0 1
120247: PPUSH
120248: LD_INT 19
120250: PPUSH
120251: CALL 25398 0 2
// MC_Reset ( base , 20 ) ;
120255: LD_VAR 0 1
120259: PPUSH
120260: LD_INT 20
120262: PPUSH
120263: CALL 25398 0 2
// end ; end_of_file
120267: LD_VAR 0 3
120271: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
120272: LD_VAR 0 1
120276: PUSH
120277: LD_INT 200
120279: DOUBLE
120280: GREATEREQUAL
120281: IFFALSE 120289
120283: LD_INT 299
120285: DOUBLE
120286: LESSEQUAL
120287: IFTRUE 120291
120289: GO 120323
120291: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
120292: LD_VAR 0 1
120296: PPUSH
120297: LD_VAR 0 2
120301: PPUSH
120302: LD_VAR 0 3
120306: PPUSH
120307: LD_VAR 0 4
120311: PPUSH
120312: LD_VAR 0 5
120316: PPUSH
120317: CALL 109058 0 5
120321: GO 120400
120323: LD_INT 300
120325: DOUBLE
120326: GREATEREQUAL
120327: IFFALSE 120335
120329: LD_INT 399
120331: DOUBLE
120332: LESSEQUAL
120333: IFTRUE 120337
120335: GO 120399
120337: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120338: LD_VAR 0 1
120342: PPUSH
120343: LD_VAR 0 2
120347: PPUSH
120348: LD_VAR 0 3
120352: PPUSH
120353: LD_VAR 0 4
120357: PPUSH
120358: LD_VAR 0 5
120362: PPUSH
120363: LD_VAR 0 6
120367: PPUSH
120368: LD_VAR 0 7
120372: PPUSH
120373: LD_VAR 0 8
120377: PPUSH
120378: LD_VAR 0 9
120382: PPUSH
120383: LD_VAR 0 10
120387: PPUSH
120388: LD_VAR 0 11
120392: PPUSH
120393: CALL 105391 0 11
120397: GO 120400
120399: POP
// end ;
120400: PPOPN 11
120402: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
120403: LD_VAR 0 1
120407: PPUSH
120408: LD_VAR 0 2
120412: PPUSH
120413: LD_VAR 0 3
120417: PPUSH
120418: LD_VAR 0 4
120422: PPUSH
120423: LD_VAR 0 5
120427: PPUSH
120428: CALL 108794 0 5
// end ; end_of_file
120432: PPOPN 5
120434: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
120435: LD_VAR 0 1
120439: PPUSH
120440: LD_VAR 0 2
120444: PPUSH
120445: LD_VAR 0 3
120449: PPUSH
120450: LD_VAR 0 4
120454: PPUSH
120455: LD_VAR 0 5
120459: PPUSH
120460: LD_VAR 0 6
120464: PPUSH
120465: CALL 93084 0 6
// end ;
120469: PPOPN 6
120471: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
120472: LD_INT 0
120474: PPUSH
// begin if not units then
120475: LD_VAR 0 1
120479: NOT
120480: IFFALSE 120484
// exit ;
120482: GO 120484
// end ;
120484: PPOPN 7
120486: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
120487: CALL 93055 0 0
// end ;
120491: PPOPN 1
120493: END
