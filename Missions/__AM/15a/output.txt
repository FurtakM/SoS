// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20724 0 0
// InitNature ;
  19: CALL 17258 0 0
// InitArtifact ;
  23: CALL 17871 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4579 0 0
// PrepareAlliance ;
  44: CALL 1375 0 0
// PrepareArabian ;
  48: CALL 6347 0 0
// PrepareRussian ;
  52: CALL 8332 0 0
// PrepareLegion ;
  56: CALL 6775 0 0
// Action ;
  60: CALL 10885 0 0
// MC_Start ( ) ;
  64: CALL 22836 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// end ;
 208: LD_VAR 0 1
 212: RET
// export function CustomInitMacro ( ) ; begin
 213: LD_INT 0
 215: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 216: LD_ADDR_EXP 113
 220: PUSH
 221: LD_INT 26
 223: PUSH
 224: LD_INT 1
 226: PUSH
 227: LD_INT 4
 229: PUSH
 230: LD_INT 8
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 239: LD_ADDR_EXP 114
 243: PUSH
 244: LD_INT 27
 246: PUSH
 247: LD_INT 2
 249: PUSH
 250: LD_INT 3
 252: PUSH
 253: LD_INT 7
 255: PUSH
 256: EMPTY
 257: LIST
 258: LIST
 259: LIST
 260: LIST
 261: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 262: LD_INT 1
 264: PPUSH
 265: LD_INT 6
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: LD_INT 9
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: PPUSH
 285: LD_INT 28
 287: PPUSH
 288: CALL 44037 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 10
 297: PUSH
 298: LD_INT 11
 300: PUSH
 301: LD_INT 13
 303: PUSH
 304: LD_INT 15
 306: PUSH
 307: EMPTY
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: PPUSH
 313: CALL 45097 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 317: LD_INT 1
 319: PPUSH
 320: LD_INT 29
 322: PUSH
 323: EMPTY
 324: LIST
 325: PPUSH
 326: CALL 45190 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 330: LD_ADDR_EXP 118
 334: PUSH
 335: LD_EXP 118
 339: PPUSH
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 22
 345: PUSH
 346: LD_INT 2
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: PUSH
 353: LD_INT 25
 355: PUSH
 356: LD_INT 15
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PPUSH
 367: CALL_OW 69
 371: PPUSH
 372: CALL_OW 1
 376: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 377: LD_INT 1
 379: PPUSH
 380: LD_INT 13
 382: PUSH
 383: LD_INT 2
 385: PUSH
 386: LD_INT 1
 388: PUSH
 389: LD_INT 31
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: PUSH
 398: LD_INT 13
 400: PUSH
 401: LD_INT 2
 403: PUSH
 404: LD_INT 1
 406: PUSH
 407: LD_INT 31
 409: PUSH
 410: EMPTY
 411: LIST
 412: LIST
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 13
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 1
 424: PUSH
 425: LD_INT 28
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PUSH
 434: LD_INT 13
 436: PUSH
 437: LD_INT 1
 439: PUSH
 440: LD_INT 1
 442: PUSH
 443: LD_INT 28
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: PUSH
 452: LD_INT 13
 454: PUSH
 455: LD_INT 1
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: LD_INT 28
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: PUSH
 470: LD_INT 13
 472: PUSH
 473: LD_INT 1
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: LD_INT 28
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: LIST
 486: LIST
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PPUSH
 496: CALL 44355 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 500: LD_INT 1
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL 44540 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 510: LD_INT 2
 512: PPUSH
 513: LD_INT 10
 515: PUSH
 516: LD_INT 11
 518: PUSH
 519: LD_INT 12
 521: PUSH
 522: LD_INT 14
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PPUSH
 531: CALL 45097 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 14
 540: PUSH
 541: EMPTY
 542: LIST
 543: PPUSH
 544: CALL 45190 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 21
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 51
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 22
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 52
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 22
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 3
 595: PUSH
 596: LD_INT 52
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 3
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: LD_INT 24
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 3
 631: PUSH
 632: LD_INT 47
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: PUSH
 641: LD_INT 24
 643: PUSH
 644: LD_INT 3
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 47
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 24
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 47
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 24
 679: PUSH
 680: LD_INT 3
 682: PUSH
 683: LD_INT 3
 685: PUSH
 686: LD_INT 47
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: EMPTY
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: LIST
 703: LIST
 704: PPUSH
 705: CALL 44355 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 709: LD_INT 2
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL 44540 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 719: LD_INT 2
 721: PPUSH
 722: LD_INT 0
 724: PPUSH
 725: CALL 44970 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 729: LD_INT 3
 731: PPUSH
 732: LD_INT 10
 734: PUSH
 735: LD_INT 12
 737: PUSH
 738: LD_INT 15
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_OWVAR 67
 750: ARRAY
 751: PPUSH
 752: LD_INT 24
 754: PPUSH
 755: CALL 44037 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 759: LD_INT 3
 761: PPUSH
 762: LD_INT 10
 764: PUSH
 765: LD_INT 11
 767: PUSH
 768: LD_INT 13
 770: PUSH
 771: LD_INT 15
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: LIST
 779: PPUSH
 780: CALL 45097 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 13
 789: PUSH
 790: EMPTY
 791: LIST
 792: PPUSH
 793: CALL 45190 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 797: LD_ADDR_EXP 118
 801: PUSH
 802: LD_EXP 118
 806: PPUSH
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 22
 812: PUSH
 813: LD_INT 8
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: PUSH
 820: LD_INT 25
 822: PUSH
 823: LD_INT 15
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: CALL_OW 1
 843: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 844: LD_INT 3
 846: PPUSH
 847: LD_INT 13
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: LD_INT 31
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: LD_INT 13
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 1
 873: PUSH
 874: LD_INT 31
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 13
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 2
 891: PUSH
 892: LD_INT 32
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PUSH
 901: LD_INT 14
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: LD_INT 28
 912: PUSH
 913: EMPTY
 914: LIST
 915: LIST
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 14
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: LD_INT 1
 927: PUSH
 928: LD_INT 28
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 14
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 1
 945: PUSH
 946: LD_INT 28
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 14
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 28
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PPUSH
 982: CALL 44355 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 986: LD_INT 3
 988: PPUSH
 989: LD_INT 4
 991: PPUSH
 992: CALL 44540 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: LD_INT 11
1007: PUSH
1008: LD_INT 15
1010: PUSH
1011: EMPTY
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL 45097 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1021: LD_INT 4
1023: PPUSH
1024: LD_INT 33
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL 45190 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1034: LD_INT 4
1036: PPUSH
1037: LD_INT 5
1039: PUSH
1040: LD_INT 6
1042: PUSH
1043: LD_INT 7
1045: PUSH
1046: LD_INT 9
1048: PUSH
1049: LD_INT 10
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PPUSH
1059: CALL 45508 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1063: LD_INT 4
1065: PPUSH
1066: LD_INT 54
1068: PPUSH
1069: LD_INT 85
1071: PPUSH
1072: LD_INT 2
1074: PPUSH
1075: LD_INT 25
1077: PUSH
1078: LD_INT 16
1080: PUSH
1081: LD_INT 17
1083: PUSH
1084: LD_INT 18
1086: PUSH
1087: LD_INT 22
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: LIST
1096: PPUSH
1097: CALL 45302 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1101: LD_INT 4
1103: PPUSH
1104: LD_INT 5
1106: PUSH
1107: LD_INT 1
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: LD_INT 7
1115: PUSH
1116: EMPTY
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 1
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: LD_INT 6
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 5
1142: PUSH
1143: LD_INT 1
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: LD_INT 7
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 6
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 3
1184: PUSH
1185: LD_INT 12
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 3
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 3
1202: PUSH
1203: LD_INT 13
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PPUSH
1220: CALL 44355 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1224: LD_INT 4
1226: PPUSH
1227: LD_INT 4
1229: PPUSH
1230: CALL 44540 0 2
// MC_SetTame ( 4 , powellApe ) ;
1234: LD_INT 4
1236: PPUSH
1237: LD_INT 11
1239: PPUSH
1240: CALL 44921 0 2
// end ;
1244: LD_VAR 0 1
1248: RET
// every 0 0$1 trigger debug do var i ;
1249: LD_EXP 1
1253: IFFALSE 1351
1255: GO 1257
1257: DISABLE
1258: LD_INT 0
1260: PPUSH
// begin enable ;
1261: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1262: LD_ADDR_VAR 0 1
1266: PUSH
1267: LD_INT 22
1269: PUSH
1270: LD_INT 7
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 2
1279: PUSH
1280: LD_INT 21
1282: PUSH
1283: LD_INT 1
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 2
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 3
1307: PUSH
1308: LD_INT 24
1310: PUSH
1311: LD_INT 1000
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL_OW 69
1331: PUSH
1332: FOR_IN
1333: IFFALSE 1349
// SetLives ( i , 1000 ) ;
1335: LD_VAR 0 1
1339: PPUSH
1340: LD_INT 1000
1342: PPUSH
1343: CALL_OW 234
1347: GO 1332
1349: POP
1350: POP
// end ;
1351: PPOPN 1
1353: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1354: LD_EXP 16
1358: PUSH
1359: LD_INT 5
1361: GREATEREQUAL
1362: IFFALSE 1374
1364: GO 1366
1366: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1367: LD_STRING ACH_ARTIFACT
1369: PPUSH
1370: CALL_OW 543
1374: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1375: LD_INT 0
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// uc_side := 7 ;
1382: LD_ADDR_OWVAR 20
1386: PUSH
1387: LD_INT 7
1389: ST_TO_ADDR
// tmp := [ ] ;
1390: LD_ADDR_VAR 0 5
1394: PUSH
1395: EMPTY
1396: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1397: LD_ADDR_EXP 17
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: LD_STRING 14a_
1413: PPUSH
1414: CALL 50747 0 3
1418: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1419: LD_ADDR_EXP 49
1423: PUSH
1424: LD_STRING Burlak
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: LD_STRING 14a_
1435: PPUSH
1436: CALL 50747 0 3
1440: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1441: LD_ADDR_EXP 32
1445: PUSH
1446: LD_STRING Joan
1448: PPUSH
1449: LD_EXP 1
1453: NOT
1454: PPUSH
1455: LD_STRING 13a_
1457: PPUSH
1458: CALL 50747 0 3
1462: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1463: LD_ADDR_EXP 18
1467: PUSH
1468: LD_STRING Roth
1470: PPUSH
1471: LD_EXP 1
1475: NOT
1476: PPUSH
1477: LD_STRING 13a_
1479: PPUSH
1480: CALL 50747 0 3
1484: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1485: LD_ADDR_EXP 35
1489: PUSH
1490: LD_STRING Gossudarov
1492: PPUSH
1493: LD_EXP 1
1497: NOT
1498: PPUSH
1499: LD_STRING 13a_
1501: PPUSH
1502: CALL 50747 0 3
1506: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1507: LD_ADDR_EXP 23
1511: PUSH
1512: LD_STRING Denis
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: LD_STRING 13a_
1523: PPUSH
1524: CALL 50747 0 3
1528: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1529: LD_ADDR_EXP 33
1533: PUSH
1534: LD_STRING DeltaDoctor
1536: PPUSH
1537: LD_EXP 1
1541: NOT
1542: PPUSH
1543: LD_STRING 13a_
1545: PPUSH
1546: CALL 50747 0 3
1550: ST_TO_ADDR
// if DeltaDoctor then
1551: LD_EXP 33
1555: IFFALSE 1573
// tmp := tmp ^ DeltaDoctor ;
1557: LD_ADDR_VAR 0 5
1561: PUSH
1562: LD_VAR 0 5
1566: PUSH
1567: LD_EXP 33
1571: ADD
1572: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1573: LD_ADDR_EXP 31
1577: PUSH
1578: LD_STRING Simms
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 13a_
1589: PPUSH
1590: CALL 50747 0 3
1594: ST_TO_ADDR
// if Simms then
1595: LD_EXP 31
1599: IFFALSE 1617
// tmp := tmp ^ Simms ;
1601: LD_ADDR_VAR 0 5
1605: PUSH
1606: LD_VAR 0 5
1610: PUSH
1611: LD_EXP 31
1615: ADD
1616: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1617: LD_ADDR_EXP 29
1621: PUSH
1622: LD_STRING Frank
1624: PPUSH
1625: LD_EXP 1
1629: NOT
1630: PPUSH
1631: LD_STRING 13a_
1633: PPUSH
1634: CALL 50747 0 3
1638: ST_TO_ADDR
// if Frank then
1639: LD_EXP 29
1643: IFFALSE 1661
// tmp := tmp ^ Frank ;
1645: LD_ADDR_VAR 0 5
1649: PUSH
1650: LD_VAR 0 5
1654: PUSH
1655: LD_EXP 29
1659: ADD
1660: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1661: LD_ADDR_EXP 36
1665: PUSH
1666: LD_STRING Kirilenkova
1668: PPUSH
1669: LD_EXP 1
1673: NOT
1674: PPUSH
1675: LD_STRING 13a_
1677: PPUSH
1678: CALL 50747 0 3
1682: ST_TO_ADDR
// if Kirilenkova then
1683: LD_EXP 36
1687: IFFALSE 1705
// tmp := tmp ^ Kirilenkova ;
1689: LD_ADDR_VAR 0 5
1693: PUSH
1694: LD_VAR 0 5
1698: PUSH
1699: LD_EXP 36
1703: ADD
1704: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1705: LD_ADDR_EXP 37
1709: PUSH
1710: LD_STRING Titov
1712: PPUSH
1713: LD_EXP 1
1717: NOT
1718: PPUSH
1719: LD_STRING 13a_
1721: PPUSH
1722: CALL 50747 0 3
1726: ST_TO_ADDR
// if Titov then
1727: LD_EXP 37
1731: IFFALSE 1749
// tmp := tmp ^ Titov ;
1733: LD_ADDR_VAR 0 5
1737: PUSH
1738: LD_VAR 0 5
1742: PUSH
1743: LD_EXP 37
1747: ADD
1748: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Fadeev
1756: PPUSH
1757: LD_EXP 1
1761: NOT
1762: PPUSH
1763: LD_STRING 13a_
1765: PPUSH
1766: CALL 50747 0 3
1770: ST_TO_ADDR
// if Fadeev then
1771: LD_EXP 38
1775: IFFALSE 1793
// tmp := tmp ^ Fadeev ;
1777: LD_ADDR_VAR 0 5
1781: PUSH
1782: LD_VAR 0 5
1786: PUSH
1787: LD_EXP 38
1791: ADD
1792: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1793: LD_ADDR_EXP 39
1797: PUSH
1798: LD_STRING Dolgov
1800: PPUSH
1801: LD_EXP 1
1805: NOT
1806: PPUSH
1807: LD_STRING 13a_
1809: PPUSH
1810: CALL 50747 0 3
1814: ST_TO_ADDR
// if Dolgov then
1815: LD_EXP 39
1819: IFFALSE 1837
// tmp := tmp ^ Dolgov ;
1821: LD_ADDR_VAR 0 5
1825: PUSH
1826: LD_VAR 0 5
1830: PUSH
1831: LD_EXP 39
1835: ADD
1836: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING Petrosyan
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 13a_
1853: PPUSH
1854: CALL 50747 0 3
1858: ST_TO_ADDR
// if Petrosyan then
1859: LD_EXP 40
1863: IFFALSE 1881
// tmp := tmp ^ Petrosyan ;
1865: LD_ADDR_VAR 0 5
1869: PUSH
1870: LD_VAR 0 5
1874: PUSH
1875: LD_EXP 40
1879: ADD
1880: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1881: LD_ADDR_EXP 41
1885: PUSH
1886: LD_STRING Scholtze
1888: PPUSH
1889: LD_EXP 1
1893: NOT
1894: PPUSH
1895: LD_STRING 13a_
1897: PPUSH
1898: CALL 50747 0 3
1902: ST_TO_ADDR
// if Scholtze then
1903: LD_EXP 41
1907: IFFALSE 1925
// tmp := tmp ^ Scholtze ;
1909: LD_ADDR_VAR 0 5
1913: PUSH
1914: LD_VAR 0 5
1918: PUSH
1919: LD_EXP 41
1923: ADD
1924: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1925: LD_ADDR_EXP 42
1929: PUSH
1930: LD_STRING Oblukov
1932: PPUSH
1933: LD_EXP 1
1937: NOT
1938: PPUSH
1939: LD_STRING 13a_
1941: PPUSH
1942: CALL 50747 0 3
1946: ST_TO_ADDR
// if Oblukov then
1947: LD_EXP 42
1951: IFFALSE 1969
// tmp := tmp ^ Oblukov ;
1953: LD_ADDR_VAR 0 5
1957: PUSH
1958: LD_VAR 0 5
1962: PUSH
1963: LD_EXP 42
1967: ADD
1968: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1969: LD_ADDR_EXP 43
1973: PUSH
1974: LD_STRING Kapitsova
1976: PPUSH
1977: LD_EXP 1
1981: NOT
1982: PPUSH
1983: LD_STRING 13a_
1985: PPUSH
1986: CALL 50747 0 3
1990: ST_TO_ADDR
// if Kapitsova then
1991: LD_EXP 43
1995: IFFALSE 2013
// tmp := tmp ^ Kapitsova ;
1997: LD_ADDR_VAR 0 5
2001: PUSH
2002: LD_VAR 0 5
2006: PUSH
2007: LD_EXP 43
2011: ADD
2012: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2013: LD_ADDR_EXP 44
2017: PUSH
2018: LD_STRING Lipshchin
2020: PPUSH
2021: LD_EXP 1
2025: NOT
2026: PPUSH
2027: LD_STRING 13a_
2029: PPUSH
2030: CALL 50747 0 3
2034: ST_TO_ADDR
// if Lipshchin then
2035: LD_EXP 44
2039: IFFALSE 2057
// tmp := tmp ^ Lipshchin ;
2041: LD_ADDR_VAR 0 5
2045: PUSH
2046: LD_VAR 0 5
2050: PUSH
2051: LD_EXP 44
2055: ADD
2056: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2057: LD_ADDR_EXP 45
2061: PUSH
2062: LD_STRING Petrovova
2064: PPUSH
2065: LD_EXP 1
2069: NOT
2070: PPUSH
2071: LD_STRING 13a_
2073: PPUSH
2074: CALL 50747 0 3
2078: ST_TO_ADDR
// if Petrovova then
2079: LD_EXP 45
2083: IFFALSE 2101
// tmp := tmp ^ Petrovova ;
2085: LD_ADDR_VAR 0 5
2089: PUSH
2090: LD_VAR 0 5
2094: PUSH
2095: LD_EXP 45
2099: ADD
2100: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2101: LD_ADDR_EXP 46
2105: PUSH
2106: LD_STRING Kovalyuk
2108: PPUSH
2109: LD_EXP 1
2113: NOT
2114: PPUSH
2115: LD_STRING 13a_
2117: PPUSH
2118: CALL 50747 0 3
2122: ST_TO_ADDR
// if Kovalyuk then
2123: LD_EXP 46
2127: IFFALSE 2145
// tmp := tmp ^ Kovalyuk ;
2129: LD_ADDR_VAR 0 5
2133: PUSH
2134: LD_VAR 0 5
2138: PUSH
2139: LD_EXP 46
2143: ADD
2144: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2145: LD_ADDR_EXP 47
2149: PUSH
2150: LD_STRING Kuzmov
2152: PPUSH
2153: LD_EXP 1
2157: NOT
2158: PPUSH
2159: LD_STRING 13a_
2161: PPUSH
2162: CALL 50747 0 3
2166: ST_TO_ADDR
// if Kuzmov then
2167: LD_EXP 47
2171: IFFALSE 2189
// tmp := tmp ^ Kuzmov ;
2173: LD_ADDR_VAR 0 5
2177: PUSH
2178: LD_VAR 0 5
2182: PUSH
2183: LD_EXP 47
2187: ADD
2188: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2189: LD_ADDR_EXP 48
2193: PUSH
2194: LD_STRING Karamazov
2196: PPUSH
2197: LD_EXP 1
2201: NOT
2202: PPUSH
2203: LD_STRING 13a_
2205: PPUSH
2206: CALL 50747 0 3
2210: ST_TO_ADDR
// if Karamazov then
2211: LD_EXP 48
2215: IFFALSE 2233
// tmp := tmp ^ Karamazov ;
2217: LD_ADDR_VAR 0 5
2221: PUSH
2222: LD_VAR 0 5
2226: PUSH
2227: LD_EXP 48
2231: ADD
2232: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2233: LD_ADDR_EXP 50
2237: PUSH
2238: LD_STRING Belkov
2240: PPUSH
2241: LD_EXP 1
2245: NOT
2246: PPUSH
2247: LD_STRING 13a_
2249: PPUSH
2250: CALL 50747 0 3
2254: ST_TO_ADDR
// if Belkov then
2255: LD_EXP 50
2259: IFFALSE 2277
// tmp := tmp ^ Belkov ;
2261: LD_ADDR_VAR 0 5
2265: PUSH
2266: LD_VAR 0 5
2270: PUSH
2271: LD_EXP 50
2275: ADD
2276: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2277: LD_ADDR_EXP 51
2281: PUSH
2282: LD_STRING Gnyevko
2284: PPUSH
2285: LD_EXP 1
2289: NOT
2290: PPUSH
2291: LD_STRING 13a_
2293: PPUSH
2294: CALL 50747 0 3
2298: ST_TO_ADDR
// if Gnyevko then
2299: LD_EXP 51
2303: IFFALSE 2321
// tmp := tmp ^ Gnyevko ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PUSH
2315: LD_EXP 51
2319: ADD
2320: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2321: LD_ADDR_EXP 34
2325: PUSH
2326: LD_STRING Coonie
2328: PPUSH
2329: CALL_OW 25
2333: ST_TO_ADDR
// if not Lisa then
2334: LD_EXP 19
2338: NOT
2339: IFFALSE 2385
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2341: LD_ADDR_EXP 19
2345: PUSH
2346: LD_STRING Lisa
2348: PPUSH
2349: LD_EXP 1
2353: NOT
2354: PPUSH
2355: LD_STRING 13a_
2357: PPUSH
2358: CALL 50747 0 3
2362: ST_TO_ADDR
// if Lisa then
2363: LD_EXP 19
2367: IFFALSE 2385
// tmp := tmp ^ Lisa ;
2369: LD_ADDR_VAR 0 5
2373: PUSH
2374: LD_VAR 0 5
2378: PUSH
2379: LD_EXP 19
2383: ADD
2384: ST_TO_ADDR
// end ; if not Donaldson then
2385: LD_EXP 20
2389: NOT
2390: IFFALSE 2436
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2392: LD_ADDR_EXP 20
2396: PUSH
2397: LD_STRING Donaldson
2399: PPUSH
2400: LD_EXP 1
2404: NOT
2405: PPUSH
2406: LD_STRING 13a_
2408: PPUSH
2409: CALL 50747 0 3
2413: ST_TO_ADDR
// if Donaldson then
2414: LD_EXP 20
2418: IFFALSE 2436
// tmp := tmp ^ Donaldson ;
2420: LD_ADDR_VAR 0 5
2424: PUSH
2425: LD_VAR 0 5
2429: PUSH
2430: LD_EXP 20
2434: ADD
2435: ST_TO_ADDR
// end ; if not Bobby then
2436: LD_EXP 21
2440: NOT
2441: IFFALSE 2487
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2443: LD_ADDR_EXP 21
2447: PUSH
2448: LD_STRING Bobby
2450: PPUSH
2451: LD_EXP 1
2455: NOT
2456: PPUSH
2457: LD_STRING 13a_
2459: PPUSH
2460: CALL 50747 0 3
2464: ST_TO_ADDR
// if Bobby then
2465: LD_EXP 21
2469: IFFALSE 2487
// tmp := tmp ^ Bobby ;
2471: LD_ADDR_VAR 0 5
2475: PUSH
2476: LD_VAR 0 5
2480: PUSH
2481: LD_EXP 21
2485: ADD
2486: ST_TO_ADDR
// end ; if not Cyrus then
2487: LD_EXP 22
2491: NOT
2492: IFFALSE 2538
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2494: LD_ADDR_EXP 22
2498: PUSH
2499: LD_STRING Cyrus
2501: PPUSH
2502: LD_EXP 1
2506: NOT
2507: PPUSH
2508: LD_STRING 13a_
2510: PPUSH
2511: CALL 50747 0 3
2515: ST_TO_ADDR
// if Cyrus then
2516: LD_EXP 22
2520: IFFALSE 2538
// tmp := tmp ^ Cyrus ;
2522: LD_ADDR_VAR 0 5
2526: PUSH
2527: LD_VAR 0 5
2531: PUSH
2532: LD_EXP 22
2536: ADD
2537: ST_TO_ADDR
// end ; if not Brown then
2538: LD_EXP 24
2542: NOT
2543: IFFALSE 2589
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2545: LD_ADDR_EXP 24
2549: PUSH
2550: LD_STRING Brown
2552: PPUSH
2553: LD_EXP 1
2557: NOT
2558: PPUSH
2559: LD_STRING 13a_
2561: PPUSH
2562: CALL 50747 0 3
2566: ST_TO_ADDR
// if Brown then
2567: LD_EXP 24
2571: IFFALSE 2589
// tmp := tmp ^ Brown ;
2573: LD_ADDR_VAR 0 5
2577: PUSH
2578: LD_VAR 0 5
2582: PUSH
2583: LD_EXP 24
2587: ADD
2588: ST_TO_ADDR
// end ; if not Gladstone then
2589: LD_EXP 25
2593: NOT
2594: IFFALSE 2640
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2596: LD_ADDR_EXP 25
2600: PUSH
2601: LD_STRING Gladstone
2603: PPUSH
2604: LD_EXP 1
2608: NOT
2609: PPUSH
2610: LD_STRING 13a_
2612: PPUSH
2613: CALL 50747 0 3
2617: ST_TO_ADDR
// if Gladstone then
2618: LD_EXP 25
2622: IFFALSE 2640
// tmp := tmp ^ Gladstone ;
2624: LD_ADDR_VAR 0 5
2628: PUSH
2629: LD_VAR 0 5
2633: PUSH
2634: LD_EXP 25
2638: ADD
2639: ST_TO_ADDR
// end ; if not Cornel then
2640: LD_EXP 27
2644: NOT
2645: IFFALSE 2691
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2647: LD_ADDR_EXP 27
2651: PUSH
2652: LD_STRING Cornel
2654: PPUSH
2655: LD_EXP 1
2659: NOT
2660: PPUSH
2661: LD_STRING 13a_
2663: PPUSH
2664: CALL 50747 0 3
2668: ST_TO_ADDR
// if Cornel then
2669: LD_EXP 27
2673: IFFALSE 2691
// tmp := tmp ^ Cornel ;
2675: LD_ADDR_VAR 0 5
2679: PUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_EXP 27
2689: ADD
2690: ST_TO_ADDR
// end ; if not Houten then
2691: LD_EXP 26
2695: NOT
2696: IFFALSE 2742
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2698: LD_ADDR_EXP 26
2702: PUSH
2703: LD_STRING Houten
2705: PPUSH
2706: LD_EXP 1
2710: NOT
2711: PPUSH
2712: LD_STRING 13a_
2714: PPUSH
2715: CALL 50747 0 3
2719: ST_TO_ADDR
// if Houten then
2720: LD_EXP 26
2724: IFFALSE 2742
// tmp := tmp ^ Houten ;
2726: LD_ADDR_VAR 0 5
2730: PUSH
2731: LD_VAR 0 5
2735: PUSH
2736: LD_EXP 26
2740: ADD
2741: ST_TO_ADDR
// end ; if not Gary then
2742: LD_EXP 28
2746: NOT
2747: IFFALSE 2793
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2749: LD_ADDR_EXP 28
2753: PUSH
2754: LD_STRING Gary
2756: PPUSH
2757: LD_EXP 1
2761: NOT
2762: PPUSH
2763: LD_STRING 13a_
2765: PPUSH
2766: CALL 50747 0 3
2770: ST_TO_ADDR
// if Gary then
2771: LD_EXP 28
2775: IFFALSE 2793
// tmp := tmp ^ Gary ;
2777: LD_ADDR_VAR 0 5
2781: PUSH
2782: LD_VAR 0 5
2786: PUSH
2787: LD_EXP 28
2791: ADD
2792: ST_TO_ADDR
// end ; if not Kikuchi then
2793: LD_EXP 30
2797: NOT
2798: IFFALSE 2844
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2800: LD_ADDR_EXP 30
2804: PUSH
2805: LD_STRING Kikuchi
2807: PPUSH
2808: LD_EXP 1
2812: NOT
2813: PPUSH
2814: LD_STRING 13a_
2816: PPUSH
2817: CALL 50747 0 3
2821: ST_TO_ADDR
// if Kikuchi then
2822: LD_EXP 30
2826: IFFALSE 2844
// tmp := tmp ^ Kikuchi ;
2828: LD_ADDR_VAR 0 5
2832: PUSH
2833: LD_VAR 0 5
2837: PUSH
2838: LD_EXP 30
2842: ADD
2843: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_VAR 0 5
2853: PUSH
2854: LD_STRING 13a_others
2856: PPUSH
2857: CALL_OW 31
2861: UNION
2862: ST_TO_ADDR
// tmp := tmp diff 0 ;
2863: LD_ADDR_VAR 0 5
2867: PUSH
2868: LD_VAR 0 5
2872: PUSH
2873: LD_INT 0
2875: DIFF
2876: ST_TO_ADDR
// if tmp < 15 then
2877: LD_VAR 0 5
2881: PUSH
2882: LD_INT 15
2884: LESS
2885: IFFALSE 2973
// for i = 15 downto tmp do
2887: LD_ADDR_VAR 0 2
2891: PUSH
2892: DOUBLE
2893: LD_INT 15
2895: INC
2896: ST_TO_ADDR
2897: LD_VAR 0 5
2901: PUSH
2902: FOR_DOWNTO
2903: IFFALSE 2971
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2905: LD_ADDR_OWVAR 21
2909: PUSH
2910: LD_INT 1
2912: PUSH
2913: LD_INT 3
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 1
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: CALL_OW 12
2930: ARRAY
2931: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2932: LD_INT 0
2934: PPUSH
2935: LD_INT 1
2937: PPUSH
2938: LD_INT 4
2940: PPUSH
2941: CALL_OW 12
2945: PPUSH
2946: LD_INT 8
2948: PPUSH
2949: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2953: LD_ADDR_VAR 0 5
2957: PUSH
2958: LD_VAR 0 5
2962: PUSH
2963: CALL_OW 44
2967: ADD
2968: ST_TO_ADDR
// end ;
2969: GO 2902
2971: POP
2972: POP
// if not debug then
2973: LD_EXP 1
2977: NOT
2978: IFFALSE 3150
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2980: LD_ADDR_VAR 0 4
2984: PUSH
2985: LD_STRING 
2987: PPUSH
2988: LD_INT 15
2990: PUSH
2991: LD_INT 14
2993: PUSH
2994: LD_INT 13
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: LIST
3001: PUSH
3002: LD_OWVAR 67
3006: ARRAY
3007: PPUSH
3008: LD_INT 15
3010: PUSH
3011: LD_INT 14
3013: PUSH
3014: LD_INT 13
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: LIST
3021: PUSH
3022: LD_OWVAR 67
3026: ARRAY
3027: PPUSH
3028: LD_INT -6
3030: PUSH
3031: LD_EXP 17
3035: PUSH
3036: LD_EXP 49
3040: PUSH
3041: LD_EXP 18
3045: PUSH
3046: LD_EXP 32
3050: PUSH
3051: LD_EXP 23
3055: PUSH
3056: LD_EXP 35
3060: PUSH
3061: LD_INT -2
3063: PUSH
3064: LD_INT -3
3066: PUSH
3067: LD_INT -5
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PUSH
3082: LD_VAR 0 5
3086: ADD
3087: PPUSH
3088: LD_INT 1
3090: PUSH
3091: LD_INT 4
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: LD_INT 1
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 3
3106: PUSH
3107: LD_INT 5
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 9
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 3
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PPUSH
3143: CALL_OW 42
3147: ST_TO_ADDR
3148: GO 3229
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3150: LD_ADDR_VAR 0 4
3154: PUSH
3155: LD_EXP 37
3159: PUSH
3160: LD_EXP 38
3164: PUSH
3165: LD_EXP 39
3169: PUSH
3170: LD_EXP 40
3174: PUSH
3175: LD_EXP 41
3179: PUSH
3180: LD_EXP 42
3184: PUSH
3185: LD_EXP 43
3189: PUSH
3190: LD_EXP 44
3194: PUSH
3195: LD_EXP 45
3199: PUSH
3200: LD_EXP 46
3204: PUSH
3205: LD_EXP 47
3209: PUSH
3210: LD_EXP 48
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: ST_TO_ADDR
// uc_nation := 1 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 1
3236: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3237: LD_INT 5
3239: PPUSH
3240: LD_INT 3
3242: PPUSH
3243: LD_INT 1
3245: PPUSH
3246: LD_INT 6
3248: PPUSH
3249: LD_INT 100
3251: PPUSH
3252: CALL 55571 0 5
// veh := CreateVehicle ;
3256: LD_ADDR_VAR 0 3
3260: PUSH
3261: CALL_OW 45
3265: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3266: LD_VAR 0 3
3270: PPUSH
3271: LD_INT 7
3273: NEG
3274: PPUSH
3275: CALL_OW 242
// SetDir ( veh , 3 ) ;
3279: LD_VAR 0 3
3283: PPUSH
3284: LD_INT 3
3286: PPUSH
3287: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3291: LD_VAR 0 3
3295: PPUSH
3296: LD_INT 31
3298: PPUSH
3299: LD_INT 0
3301: PPUSH
3302: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3306: LD_EXP 17
3310: PPUSH
3311: LD_VAR 0 3
3315: PPUSH
3316: CALL_OW 52
// if Joan then
3320: LD_EXP 32
3324: IFFALSE 3396
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3326: LD_INT 3
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: LD_INT 1
3334: PPUSH
3335: LD_INT 11
3337: PPUSH
3338: LD_INT 100
3340: PPUSH
3341: CALL 55571 0 5
// veh := CreateVehicle ;
3345: LD_ADDR_VAR 0 3
3349: PUSH
3350: CALL_OW 45
3354: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3355: LD_VAR 0 3
3359: PPUSH
3360: LD_INT 3
3362: PPUSH
3363: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3367: LD_VAR 0 3
3371: PPUSH
3372: LD_INT 30
3374: PPUSH
3375: LD_INT 0
3377: PPUSH
3378: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3382: LD_EXP 32
3386: PPUSH
3387: LD_VAR 0 3
3391: PPUSH
3392: CALL_OW 52
// end ; if Roth then
3396: LD_EXP 18
3400: IFFALSE 3472
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3402: LD_INT 3
3404: PPUSH
3405: LD_INT 3
3407: PPUSH
3408: LD_INT 1
3410: PPUSH
3411: LD_INT 11
3413: PPUSH
3414: LD_INT 100
3416: PPUSH
3417: CALL 55571 0 5
// veh := CreateVehicle ;
3421: LD_ADDR_VAR 0 3
3425: PUSH
3426: CALL_OW 45
3430: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3431: LD_VAR 0 3
3435: PPUSH
3436: LD_INT 3
3438: PPUSH
3439: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3443: LD_VAR 0 3
3447: PPUSH
3448: LD_INT 30
3450: PPUSH
3451: LD_INT 0
3453: PPUSH
3454: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3458: LD_EXP 18
3462: PPUSH
3463: LD_VAR 0 3
3467: PPUSH
3468: CALL_OW 52
// end ; if Denis then
3472: LD_EXP 23
3476: IFFALSE 3548
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3478: LD_INT 5
3480: PPUSH
3481: LD_INT 3
3483: PPUSH
3484: LD_INT 1
3486: PPUSH
3487: LD_INT 9
3489: PPUSH
3490: LD_INT 100
3492: PPUSH
3493: CALL 55571 0 5
// veh := CreateVehicle ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: CALL_OW 45
3506: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3507: LD_VAR 0 3
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3519: LD_VAR 0 3
3523: PPUSH
3524: LD_INT 30
3526: PPUSH
3527: LD_INT 0
3529: PPUSH
3530: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3534: LD_EXP 23
3538: PPUSH
3539: LD_VAR 0 3
3543: PPUSH
3544: CALL_OW 52
// end ; uc_nation := 3 ;
3548: LD_ADDR_OWVAR 21
3552: PUSH
3553: LD_INT 3
3555: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3556: LD_INT 22
3558: PPUSH
3559: LD_INT 3
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: LD_INT 45
3567: PPUSH
3568: LD_INT 100
3570: PPUSH
3571: CALL 55571 0 5
// veh := CreateVehicle ;
3575: LD_ADDR_VAR 0 3
3579: PUSH
3580: CALL_OW 45
3584: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3585: LD_VAR 0 3
3589: PPUSH
3590: LD_INT 7
3592: NEG
3593: PPUSH
3594: CALL_OW 242
// SetDir ( veh , 3 ) ;
3598: LD_VAR 0 3
3602: PPUSH
3603: LD_INT 3
3605: PPUSH
3606: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3610: LD_VAR 0 3
3614: PPUSH
3615: LD_INT 31
3617: PPUSH
3618: LD_INT 0
3620: PPUSH
3621: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3625: LD_EXP 49
3629: PPUSH
3630: LD_VAR 0 3
3634: PPUSH
3635: CALL_OW 52
// if Gossudarov then
3639: LD_EXP 35
3643: IFFALSE 3730
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3645: LD_INT 22
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: LD_INT 1
3653: PPUSH
3654: LD_INT 51
3656: PPUSH
3657: LD_INT 100
3659: PPUSH
3660: CALL 55571 0 5
// veh := CreateVehicle ;
3664: LD_ADDR_VAR 0 3
3668: PUSH
3669: CALL_OW 45
3673: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3674: LD_VAR 0 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3686: LD_VAR 0 3
3690: PPUSH
3691: LD_INT 30
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3701: LD_EXP 35
3705: PPUSH
3706: LD_VAR 0 3
3710: PPUSH
3711: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3715: LD_VAR 0 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_INT 100
3725: PPUSH
3726: CALL_OW 290
// end ; for i in selected do
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: LD_VAR 0 4
3739: PUSH
3740: FOR_IN
3741: IFFALSE 4299
// begin uc_nation := GetNation ( i ) ;
3743: LD_ADDR_OWVAR 21
3747: PUSH
3748: LD_VAR 0 2
3752: PPUSH
3753: CALL_OW 248
3757: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3758: LD_VAR 0 2
3762: PUSH
3763: LD_EXP 19
3767: PUSH
3768: LD_EXP 20
3772: PUSH
3773: LD_EXP 22
3777: PUSH
3778: LD_EXP 21
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: LIST
3788: IN
3789: IFFALSE 3812
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3791: LD_INT 5
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 6
3802: PPUSH
3803: LD_INT 100
3805: PPUSH
3806: CALL 55571 0 5
3810: GO 4246
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3812: LD_VAR 0 2
3816: PUSH
3817: LD_EXP 42
3821: PUSH
3822: LD_EXP 47
3826: PUSH
3827: LD_EXP 45
3831: PUSH
3832: LD_EXP 37
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: IN
3843: IFFALSE 3874
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3845: LD_INT 24
3847: PPUSH
3848: LD_INT 1
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 46
3856: PPUSH
3857: LD_INT 65
3859: PPUSH
3860: LD_INT 75
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL 55571 0 5
3872: GO 4246
// if i = Karamazov then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 48
3883: EQUAL
3884: IFFALSE 3907
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3886: LD_INT 22
3888: PPUSH
3889: LD_INT 3
3891: PPUSH
3892: LD_INT 1
3894: PPUSH
3895: LD_INT 52
3897: PPUSH
3898: LD_INT 100
3900: PPUSH
3901: CALL 55571 0 5
3905: GO 4246
// if i = Brown then
3907: LD_VAR 0 2
3911: PUSH
3912: LD_EXP 24
3916: EQUAL
3917: IFFALSE 3940
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3919: LD_INT 3
3921: PPUSH
3922: LD_INT 3
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 13
3930: PPUSH
3931: LD_INT 100
3933: PPUSH
3934: CALL 55571 0 5
3938: GO 4246
// if uc_nation = nation_american then
3940: LD_OWVAR 21
3944: PUSH
3945: LD_INT 1
3947: EQUAL
3948: IFFALSE 4099
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3950: LD_INT 3
3952: PUSH
3953: LD_INT 5
3955: PUSH
3956: LD_INT 5
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 21
3968: PUSH
3969: LD_INT 3
3971: MOD
3972: PUSH
3973: LD_INT 1
3975: PLUS
3976: ARRAY
3977: PPUSH
3978: LD_INT 1
3980: PUSH
3981: LD_INT 3
3983: PUSH
3984: LD_INT 1
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: LIST
3991: PUSH
3992: LD_OWVAR 21
3996: PUSH
3997: LD_INT 3
3999: MOD
4000: PUSH
4001: LD_INT 1
4003: PLUS
4004: ARRAY
4005: PPUSH
4006: LD_INT 1
4008: PPUSH
4009: LD_INT 11
4011: PUSH
4012: LD_INT 4
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: LIST
4022: PUSH
4023: LD_INT 6
4025: PUSH
4026: LD_INT 7
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 6
4039: PUSH
4040: LD_INT 9
4042: PUSH
4043: LD_INT 12
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_OWVAR 21
4060: PUSH
4061: LD_INT 3
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 3
4075: PPUSH
4076: CALL_OW 12
4080: ARRAY
4081: PPUSH
4082: LD_INT 65
4084: PPUSH
4085: LD_INT 75
4087: PPUSH
4088: CALL_OW 12
4092: PPUSH
4093: CALL 55571 0 5
// end else
4097: GO 4246
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4099: LD_INT 22
4101: PUSH
4102: LD_INT 23
4104: PUSH
4105: LD_INT 23
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_OWVAR 21
4117: PUSH
4118: LD_INT 3
4120: MOD
4121: PUSH
4122: LD_INT 1
4124: PLUS
4125: ARRAY
4126: PPUSH
4127: LD_INT 1
4129: PUSH
4130: LD_INT 3
4132: PUSH
4133: LD_INT 1
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: LIST
4140: PUSH
4141: LD_OWVAR 21
4145: PUSH
4146: LD_INT 3
4148: MOD
4149: PUSH
4150: LD_INT 1
4152: PLUS
4153: ARRAY
4154: PPUSH
4155: LD_INT 1
4157: PPUSH
4158: LD_INT 45
4160: PUSH
4161: LD_INT 43
4163: PUSH
4164: LD_INT 44
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 46
4174: PUSH
4175: LD_INT 45
4177: PUSH
4178: LD_INT 44
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 46
4188: PUSH
4189: LD_INT 43
4191: PUSH
4192: LD_INT 45
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: LIST
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: LIST
4204: PUSH
4205: LD_OWVAR 21
4209: PUSH
4210: LD_INT 3
4212: MOD
4213: PUSH
4214: LD_INT 1
4216: PLUS
4217: ARRAY
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 65
4233: PPUSH
4234: LD_INT 75
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 55571 0 5
// end ; veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 3
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4256: LD_VAR 0 3
4260: PPUSH
4261: LD_INT 3
4263: PPUSH
4264: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4268: LD_VAR 0 3
4272: PPUSH
4273: LD_INT 30
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_VAR 0 3
4292: PPUSH
4293: CALL_OW 52
// end ;
4297: GO 3740
4299: POP
4300: POP
// if artifactArCaptured then
4301: LD_EXP 9
4305: IFFALSE 4391
// begin uc_nation := nation_american ;
4307: LD_ADDR_OWVAR 21
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4315: LD_INT 3
4317: PPUSH
4318: LD_INT 3
4320: PPUSH
4321: LD_INT 3
4323: PPUSH
4324: LD_INT 12
4326: PPUSH
4327: LD_INT 100
4329: PPUSH
4330: CALL 55571 0 5
// veh := CreateVehicle ;
4334: LD_ADDR_VAR 0 3
4338: PUSH
4339: CALL_OW 45
4343: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4344: LD_VAR 0 3
4348: PPUSH
4349: LD_INT 3
4351: PPUSH
4352: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4356: LD_VAR 0 3
4360: PPUSH
4361: LD_INT 198
4363: PPUSH
4364: LD_INT 22
4366: PPUSH
4367: LD_INT 0
4369: PPUSH
4370: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4374: LD_VAR 0 3
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: LD_INT 50
4384: PPUSH
4385: CALL_OW 290
// end else
4389: GO 4410
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4391: LD_INT 4
4393: PPUSH
4394: LD_INT 267
4396: PPUSH
4397: LD_INT 226
4399: PPUSH
4400: LD_INT 5
4402: PPUSH
4403: LD_INT 0
4405: PPUSH
4406: CALL_OW 58
// end ; uc_nation := nation_american ;
4410: LD_ADDR_OWVAR 21
4414: PUSH
4415: LD_INT 1
4417: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4418: LD_INT 3
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: LD_INT 3
4426: PPUSH
4427: LD_INT 12
4429: PPUSH
4430: LD_INT 100
4432: PPUSH
4433: CALL 55571 0 5
// veh := CreateVehicle ;
4437: LD_ADDR_VAR 0 3
4441: PUSH
4442: CALL_OW 45
4446: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4447: LD_VAR 0 3
4451: PPUSH
4452: LD_INT 3
4454: PPUSH
4455: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4459: LD_VAR 0 3
4463: PPUSH
4464: LD_INT 218
4466: PPUSH
4467: LD_INT 23
4469: PPUSH
4470: LD_INT 0
4472: PPUSH
4473: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4477: LD_VAR 0 3
4481: PPUSH
4482: LD_INT 4
4484: PPUSH
4485: LD_INT 30
4487: PPUSH
4488: CALL_OW 290
// uc_nation := nation_russian ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4500: LD_INT 22
4502: PPUSH
4503: LD_INT 3
4505: PPUSH
4506: LD_INT 3
4508: PPUSH
4509: LD_INT 51
4511: PPUSH
4512: LD_INT 100
4514: PPUSH
4515: CALL 55571 0 5
// veh := CreateVehicle ;
4519: LD_ADDR_VAR 0 3
4523: PUSH
4524: CALL_OW 45
4528: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4529: LD_VAR 0 3
4533: PPUSH
4534: LD_INT 3
4536: PPUSH
4537: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4541: LD_VAR 0 3
4545: PPUSH
4546: LD_INT 214
4548: PPUSH
4549: LD_INT 20
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4559: LD_VAR 0 3
4563: PPUSH
4564: LD_INT 4
4566: PPUSH
4567: LD_INT 40
4569: PPUSH
4570: CALL_OW 290
// end ; end_of_file
4574: LD_VAR 0 1
4578: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4579: LD_INT 0
4581: PPUSH
4582: PPUSH
4583: PPUSH
4584: PPUSH
4585: PPUSH
4586: PPUSH
4587: PPUSH
4588: PPUSH
4589: PPUSH
4590: PPUSH
// InitHc ;
4591: CALL_OW 19
// uc_side := 1 ;
4595: LD_ADDR_OWVAR 20
4599: PUSH
4600: LD_INT 1
4602: ST_TO_ADDR
// uc_nation := 1 ;
4603: LD_ADDR_OWVAR 21
4607: PUSH
4608: LD_INT 1
4610: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4611: LD_ADDR_VAR 0 2
4615: PUSH
4616: LD_INT 22
4618: PUSH
4619: LD_INT 1
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PUSH
4626: LD_INT 21
4628: PUSH
4629: LD_INT 3
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 69
4644: PUSH
4645: FOR_IN
4646: IFFALSE 4662
// SetBLevel ( i , 10 ) ;
4648: LD_VAR 0 2
4652: PPUSH
4653: LD_INT 10
4655: PPUSH
4656: CALL_OW 241
4660: GO 4645
4662: POP
4663: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4664: LD_INT 387
4666: PPUSH
4667: CALL_OW 274
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: LD_INT 7500
4677: PPUSH
4678: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4682: LD_INT 387
4684: PPUSH
4685: CALL_OW 274
4689: PPUSH
4690: LD_INT 2
4692: PPUSH
4693: LD_INT 4000
4695: PPUSH
4696: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4700: LD_INT 387
4702: PPUSH
4703: CALL_OW 274
4707: PPUSH
4708: LD_INT 3
4710: PPUSH
4711: LD_INT 50
4713: PPUSH
4714: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4718: LD_INT 476
4720: PPUSH
4721: CALL_OW 274
4725: PPUSH
4726: LD_INT 1
4728: PPUSH
4729: LD_INT 5500
4731: PPUSH
4732: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4736: LD_INT 476
4738: PPUSH
4739: CALL_OW 274
4743: PPUSH
4744: LD_INT 2
4746: PPUSH
4747: LD_INT 4000
4749: PPUSH
4750: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4754: LD_INT 476
4756: PPUSH
4757: CALL_OW 274
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4772: LD_ADDR_EXP 52
4776: PUSH
4777: LD_STRING Powell
4779: PPUSH
4780: CALL_OW 25
4784: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4785: LD_EXP 52
4789: PPUSH
4790: LD_INT 387
4792: PPUSH
4793: CALL_OW 52
// tmp := [ ] ;
4797: LD_ADDR_VAR 0 6
4801: PUSH
4802: EMPTY
4803: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4804: LD_ADDR_EXP 19
4808: PUSH
4809: LD_STRING Lisa
4811: PPUSH
4812: LD_EXP 1
4816: NOT
4817: PPUSH
4818: LD_STRING 12p_
4820: PPUSH
4821: CALL 50747 0 3
4825: ST_TO_ADDR
// if Lisa then
4826: LD_EXP 19
4830: IFFALSE 4848
// tmp := tmp ^ Lisa ;
4832: LD_ADDR_VAR 0 6
4836: PUSH
4837: LD_VAR 0 6
4841: PUSH
4842: LD_EXP 19
4846: ADD
4847: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4848: LD_ADDR_EXP 20
4852: PUSH
4853: LD_STRING Donaldson
4855: PPUSH
4856: LD_EXP 1
4860: NOT
4861: PPUSH
4862: LD_STRING 12p_
4864: PPUSH
4865: CALL 50747 0 3
4869: ST_TO_ADDR
// if Donaldson then
4870: LD_EXP 20
4874: IFFALSE 4892
// tmp := tmp ^ Donaldson ;
4876: LD_ADDR_VAR 0 6
4880: PUSH
4881: LD_VAR 0 6
4885: PUSH
4886: LD_EXP 20
4890: ADD
4891: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4892: LD_ADDR_EXP 21
4896: PUSH
4897: LD_STRING Bobby
4899: PPUSH
4900: LD_EXP 1
4904: NOT
4905: PPUSH
4906: LD_STRING 12p_
4908: PPUSH
4909: CALL 50747 0 3
4913: ST_TO_ADDR
// if Bobby then
4914: LD_EXP 21
4918: IFFALSE 4936
// tmp := tmp ^ Bobby ;
4920: LD_ADDR_VAR 0 6
4924: PUSH
4925: LD_VAR 0 6
4929: PUSH
4930: LD_EXP 21
4934: ADD
4935: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4936: LD_ADDR_EXP 22
4940: PUSH
4941: LD_STRING Cyrus
4943: PPUSH
4944: LD_EXP 1
4948: NOT
4949: PPUSH
4950: LD_STRING 12p_
4952: PPUSH
4953: CALL 50747 0 3
4957: ST_TO_ADDR
// if Cyrus then
4958: LD_EXP 22
4962: IFFALSE 4980
// tmp := tmp ^ Cyrus ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_VAR 0 6
4973: PUSH
4974: LD_EXP 22
4978: ADD
4979: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4980: LD_ADDR_EXP 24
4984: PUSH
4985: LD_STRING Brown
4987: PPUSH
4988: LD_EXP 1
4992: NOT
4993: PPUSH
4994: LD_STRING 12p_
4996: PPUSH
4997: CALL 50747 0 3
5001: ST_TO_ADDR
// if Brown then
5002: LD_EXP 24
5006: IFFALSE 5024
// tmp := tmp ^ Brown ;
5008: LD_ADDR_VAR 0 6
5012: PUSH
5013: LD_VAR 0 6
5017: PUSH
5018: LD_EXP 24
5022: ADD
5023: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5024: LD_ADDR_EXP 25
5028: PUSH
5029: LD_STRING Gladstone
5031: PPUSH
5032: LD_EXP 1
5036: NOT
5037: PPUSH
5038: LD_STRING 12p_
5040: PPUSH
5041: CALL 50747 0 3
5045: ST_TO_ADDR
// if Gladstone then
5046: LD_EXP 25
5050: IFFALSE 5068
// tmp := tmp ^ Gladstone ;
5052: LD_ADDR_VAR 0 6
5056: PUSH
5057: LD_VAR 0 6
5061: PUSH
5062: LD_EXP 25
5066: ADD
5067: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5068: LD_ADDR_EXP 26
5072: PUSH
5073: LD_STRING Houten
5075: PPUSH
5076: LD_EXP 1
5080: NOT
5081: PPUSH
5082: LD_STRING 12p_
5084: PPUSH
5085: CALL 50747 0 3
5089: ST_TO_ADDR
// if Houten then
5090: LD_EXP 26
5094: IFFALSE 5112
// tmp := tmp ^ Houten ;
5096: LD_ADDR_VAR 0 6
5100: PUSH
5101: LD_VAR 0 6
5105: PUSH
5106: LD_EXP 26
5110: ADD
5111: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5112: LD_ADDR_EXP 27
5116: PUSH
5117: LD_STRING Cornel
5119: PPUSH
5120: LD_EXP 1
5124: NOT
5125: PPUSH
5126: LD_STRING 12p_
5128: PPUSH
5129: CALL 50747 0 3
5133: ST_TO_ADDR
// if Cornel then
5134: LD_EXP 27
5138: IFFALSE 5156
// tmp := tmp ^ Cornel ;
5140: LD_ADDR_VAR 0 6
5144: PUSH
5145: LD_VAR 0 6
5149: PUSH
5150: LD_EXP 27
5154: ADD
5155: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5156: LD_ADDR_EXP 28
5160: PUSH
5161: LD_STRING Gary
5163: PPUSH
5164: LD_EXP 1
5168: NOT
5169: PPUSH
5170: LD_STRING 12p_
5172: PPUSH
5173: CALL 50747 0 3
5177: ST_TO_ADDR
// if Gary then
5178: LD_EXP 28
5182: IFFALSE 5200
// tmp := tmp ^ Gary ;
5184: LD_ADDR_VAR 0 6
5188: PUSH
5189: LD_VAR 0 6
5193: PUSH
5194: LD_EXP 28
5198: ADD
5199: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5200: LD_ADDR_EXP 30
5204: PUSH
5205: LD_STRING Kikuchi
5207: PPUSH
5208: LD_EXP 1
5212: NOT
5213: PPUSH
5214: LD_STRING 12p_
5216: PPUSH
5217: CALL 50747 0 3
5221: ST_TO_ADDR
// if Kikuchi then
5222: LD_EXP 30
5226: IFFALSE 5244
// tmp := tmp ^ Kikuchi ;
5228: LD_ADDR_VAR 0 6
5232: PUSH
5233: LD_VAR 0 6
5237: PUSH
5238: LD_EXP 30
5242: ADD
5243: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5244: LD_ADDR_VAR 0 6
5248: PUSH
5249: LD_VAR 0 6
5253: PUSH
5254: LD_STRING 12p_others
5256: PPUSH
5257: CALL_OW 31
5261: UNION
5262: ST_TO_ADDR
// if tmp < 36 then
5263: LD_VAR 0 6
5267: PUSH
5268: LD_INT 36
5270: LESS
5271: IFFALSE 5338
// for i = 1 to 36 - tmp do
5273: LD_ADDR_VAR 0 2
5277: PUSH
5278: DOUBLE
5279: LD_INT 1
5281: DEC
5282: ST_TO_ADDR
5283: LD_INT 36
5285: PUSH
5286: LD_VAR 0 6
5290: MINUS
5291: PUSH
5292: FOR_TO
5293: IFFALSE 5336
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5295: LD_INT 1
5297: PPUSH
5298: LD_VAR 0 2
5302: PUSH
5303: LD_INT 4
5305: MOD
5306: PUSH
5307: LD_INT 1
5309: PLUS
5310: PPUSH
5311: LD_INT 10
5313: PPUSH
5314: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5318: LD_ADDR_VAR 0 6
5322: PUSH
5323: LD_VAR 0 6
5327: PUSH
5328: CALL_OW 44
5332: ADD
5333: ST_TO_ADDR
// end ;
5334: GO 5292
5336: POP
5337: POP
// for i in tmp do
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: LD_VAR 0 6
5347: PUSH
5348: FOR_IN
5349: IFFALSE 5374
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5351: LD_VAR 0 2
5355: PPUSH
5356: LD_INT 62
5358: PPUSH
5359: LD_INT 93
5361: PPUSH
5362: LD_INT 9
5364: PPUSH
5365: LD_INT 0
5367: PPUSH
5368: CALL_OW 50
5372: GO 5348
5374: POP
5375: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5376: LD_ADDR_EXP 89
5380: PUSH
5381: LD_EXP 89
5385: PPUSH
5386: LD_INT 4
5388: PPUSH
5389: LD_INT 22
5391: PUSH
5392: LD_INT 1
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PPUSH
5399: CALL_OW 69
5403: PUSH
5404: LD_EXP 52
5408: DIFF
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// uc_side := 0 ;
5415: LD_ADDR_OWVAR 20
5419: PUSH
5420: LD_INT 0
5422: ST_TO_ADDR
// uc_nation := 0 ;
5423: LD_ADDR_OWVAR 21
5427: PUSH
5428: LD_INT 0
5430: ST_TO_ADDR
// for i = 1 to 4 do
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: DOUBLE
5437: LD_INT 1
5439: DEC
5440: ST_TO_ADDR
5441: LD_INT 4
5443: PUSH
5444: FOR_TO
5445: IFFALSE 5476
// begin InitHc ;
5447: CALL_OW 19
// hc_class := class_apeman ;
5451: LD_ADDR_OWVAR 28
5455: PUSH
5456: LD_INT 12
5458: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5459: CALL_OW 44
5463: PPUSH
5464: LD_INT 11
5466: PPUSH
5467: LD_INT 0
5469: PPUSH
5470: CALL_OW 49
// end ;
5474: GO 5444
5476: POP
5477: POP
// end ;
5478: LD_VAR 0 1
5482: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5483: LD_EXP 4
5487: NOT
5488: PUSH
5489: LD_INT 4
5491: PPUSH
5492: LD_INT 1
5494: PPUSH
5495: CALL 45821 0 2
5499: NOT
5500: AND
5501: IFFALSE 6273
5503: GO 5505
5505: DISABLE
5506: LD_INT 0
5508: PPUSH
5509: PPUSH
5510: PPUSH
// begin enable ;
5511: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5512: LD_INT 22
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 23
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: PUSH
5532: LD_INT 30
5534: PUSH
5535: LD_INT 3
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: LIST
5546: PPUSH
5547: CALL_OW 69
5551: NOT
5552: IFFALSE 5556
// exit ;
5554: GO 6273
// if Prob ( 40 ) then
5556: LD_INT 40
5558: PPUSH
5559: CALL_OW 13
5563: IFFALSE 5690
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5565: LD_INT 4
5567: PPUSH
5568: LD_INT 5
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: LD_INT 2
5576: PUSH
5577: LD_INT 7
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 5
5588: PUSH
5589: LD_INT 1
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: LD_INT 7
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 7
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 5
5624: PUSH
5625: LD_INT 1
5627: PUSH
5628: LD_INT 2
5630: PUSH
5631: LD_INT 6
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_INT 5
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 2
5648: PUSH
5649: LD_INT 6
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: PUSH
5658: LD_INT 5
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 2
5666: PUSH
5667: LD_INT 6
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PPUSH
5684: CALL 44403 0 2
// end else
5688: GO 5813
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5690: LD_INT 4
5692: PPUSH
5693: LD_INT 5
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: LD_INT 7
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 5
5713: PUSH
5714: LD_INT 1
5716: PUSH
5717: LD_INT 2
5719: PUSH
5720: LD_INT 9
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 5
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 9
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 5
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 6
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 5
5767: PUSH
5768: LD_INT 1
5770: PUSH
5771: LD_INT 2
5773: PUSH
5774: LD_INT 6
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 5
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 6
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: LIST
5799: LIST
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PPUSH
5809: CALL 44403 0 2
// end ; repeat wait ( 0 0$1 ) ;
5813: LD_INT 35
5815: PPUSH
5816: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5820: LD_INT 4
5822: PPUSH
5823: LD_INT 1
5825: PPUSH
5826: CALL 45821 0 2
5830: PUSH
5831: LD_INT 6
5833: GREATEREQUAL
5834: IFFALSE 5813
// wait ( 0 0$30 ) ;
5836: LD_INT 1050
5838: PPUSH
5839: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 4
5850: PPUSH
5851: LD_INT 1
5853: PPUSH
5854: CALL 45821 0 2
5858: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5859: LD_ADDR_EXP 108
5863: PUSH
5864: LD_EXP 108
5868: PPUSH
5869: LD_INT 4
5871: PPUSH
5872: LD_EXP 108
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: LD_VAR 0 2
5885: DIFF
5886: PPUSH
5887: CALL_OW 1
5891: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5892: LD_ADDR_VAR 0 3
5896: PUSH
5897: LD_INT 0
5899: PPUSH
5900: LD_INT 2
5902: PPUSH
5903: CALL_OW 12
5907: ST_TO_ADDR
// if target then
5908: LD_VAR 0 3
5912: IFFALSE 6040
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5914: LD_ADDR_VAR 0 2
5918: PUSH
5919: LD_VAR 0 2
5923: PPUSH
5924: LD_INT 24
5926: PUSH
5927: LD_INT 250
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PPUSH
5934: CALL_OW 72
5938: ST_TO_ADDR
// for i in tmp do
5939: LD_ADDR_VAR 0 1
5943: PUSH
5944: LD_VAR 0 2
5948: PUSH
5949: FOR_IN
5950: IFFALSE 5990
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5952: LD_VAR 0 1
5956: PPUSH
5957: LD_INT 114
5959: PPUSH
5960: LD_INT 108
5962: PPUSH
5963: CALL_OW 297
5967: PUSH
5968: LD_INT 9
5970: GREATER
5971: IFFALSE 5988
// ComMoveXY ( i , 114 , 108 ) ;
5973: LD_VAR 0 1
5977: PPUSH
5978: LD_INT 114
5980: PPUSH
5981: LD_INT 108
5983: PPUSH
5984: CALL_OW 111
5988: GO 5949
5990: POP
5991: POP
// wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5999: LD_VAR 0 2
6003: PPUSH
6004: LD_INT 92
6006: PUSH
6007: LD_INT 114
6009: PUSH
6010: LD_INT 108
6012: PUSH
6013: LD_INT 9
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PPUSH
6022: CALL_OW 72
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: LD_INT 1
6034: MINUS
6035: GREATEREQUAL
6036: IFFALSE 5914
// end else
6038: GO 6164
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6040: LD_ADDR_VAR 0 2
6044: PUSH
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 24
6052: PUSH
6053: LD_INT 250
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL_OW 72
6064: ST_TO_ADDR
// for i in tmp do
6065: LD_ADDR_VAR 0 1
6069: PUSH
6070: LD_VAR 0 2
6074: PUSH
6075: FOR_IN
6076: IFFALSE 6116
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 129
6085: PPUSH
6086: LD_INT 139
6088: PPUSH
6089: CALL_OW 297
6093: PUSH
6094: LD_INT 9
6096: GREATER
6097: IFFALSE 6114
// ComMoveXY ( i , 129 , 139 ) ;
6099: LD_VAR 0 1
6103: PPUSH
6104: LD_INT 129
6106: PPUSH
6107: LD_INT 139
6109: PPUSH
6110: CALL_OW 111
6114: GO 6075
6116: POP
6117: POP
// wait ( 0 0$1 ) ;
6118: LD_INT 35
6120: PPUSH
6121: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6125: LD_VAR 0 2
6129: PPUSH
6130: LD_INT 92
6132: PUSH
6133: LD_INT 129
6135: PUSH
6136: LD_INT 139
6138: PUSH
6139: LD_INT 9
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PPUSH
6148: CALL_OW 72
6152: PUSH
6153: LD_VAR 0 2
6157: PUSH
6158: LD_INT 1
6160: MINUS
6161: GREATEREQUAL
6162: IFFALSE 6040
// end ; repeat wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// for i in tmp do
6171: LD_ADDR_VAR 0 1
6175: PUSH
6176: LD_VAR 0 2
6180: PUSH
6181: FOR_IN
6182: IFFALSE 6264
// begin if GetLives ( i ) > 251 then
6184: LD_VAR 0 1
6188: PPUSH
6189: CALL_OW 256
6193: PUSH
6194: LD_INT 251
6196: GREATER
6197: IFFALSE 6235
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6199: LD_VAR 0 1
6203: PPUSH
6204: LD_INT 81
6206: PUSH
6207: LD_INT 1
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: PPUSH
6214: CALL_OW 69
6218: PPUSH
6219: LD_VAR 0 1
6223: PPUSH
6224: CALL_OW 74
6228: PPUSH
6229: CALL_OW 115
6233: GO 6262
// if IsDead ( i ) then
6235: LD_VAR 0 1
6239: PPUSH
6240: CALL_OW 301
6244: IFFALSE 6262
// tmp := tmp diff i ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PUSH
6256: LD_VAR 0 1
6260: DIFF
6261: ST_TO_ADDR
// end ;
6262: GO 6181
6264: POP
6265: POP
// until not tmp ;
6266: LD_VAR 0 2
6270: NOT
6271: IFFALSE 6164
// end ;
6273: PPOPN 3
6275: END
// every 30 30$00 trigger not americanDestroyed do
6276: LD_EXP 4
6280: NOT
6281: IFFALSE 6346
6283: GO 6285
6285: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6286: LD_INT 63000
6288: PUSH
6289: LD_INT 42000
6291: PUSH
6292: LD_INT 21000
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PPUSH
6306: CALL_OW 67
// if americanDestroyed then
6310: LD_EXP 4
6314: IFFALSE 6318
// exit ;
6316: GO 6346
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6318: LD_INT 4
6320: PPUSH
6321: LD_INT 5
6323: PUSH
6324: LD_INT 3
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: LD_INT 8
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: EMPTY
6340: LIST
6341: PPUSH
6342: CALL 44403 0 2
// end ; end_of_file
6346: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6347: LD_INT 0
6349: PPUSH
6350: PPUSH
6351: PPUSH
6352: PPUSH
6353: PPUSH
// side := 2 ;
6354: LD_ADDR_VAR 0 5
6358: PUSH
6359: LD_INT 2
6361: ST_TO_ADDR
// InitHc ;
6362: CALL_OW 19
// uc_side := side ;
6366: LD_ADDR_OWVAR 20
6370: PUSH
6371: LD_VAR 0 5
6375: ST_TO_ADDR
// uc_nation := 2 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 2
6383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_INT 2
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 21
6401: PUSH
6402: LD_INT 3
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6435
// SetBLevel ( i , 10 ) ;
6421: LD_VAR 0 2
6425: PPUSH
6426: LD_INT 10
6428: PPUSH
6429: CALL_OW 241
6433: GO 6418
6435: POP
6436: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6437: LD_ADDR_VAR 0 4
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_VAR 0 5
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 30
6456: PUSH
6457: LD_INT 32
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 58
6466: PUSH
6467: EMPTY
6468: LIST
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: LIST
6474: PPUSH
6475: CALL_OW 69
6479: ST_TO_ADDR
// for i = 1 to 10 do
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: DOUBLE
6486: LD_INT 1
6488: DEC
6489: ST_TO_ADDR
6490: LD_INT 10
6492: PUSH
6493: FOR_TO
6494: IFFALSE 6566
// begin uc_nation := nation_nature ;
6496: LD_ADDR_OWVAR 21
6500: PUSH
6501: LD_INT 0
6503: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6504: LD_ADDR_OWVAR 28
6508: PUSH
6509: LD_INT 15
6511: ST_TO_ADDR
// hc_gallery :=  ;
6512: LD_ADDR_OWVAR 33
6516: PUSH
6517: LD_STRING 
6519: ST_TO_ADDR
// hc_name :=  ;
6520: LD_ADDR_OWVAR 26
6524: PUSH
6525: LD_STRING 
6527: ST_TO_ADDR
// un := CreateHuman ;
6528: LD_ADDR_VAR 0 3
6532: PUSH
6533: CALL_OW 44
6537: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6538: LD_VAR 0 3
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_VAR 0 4
6552: PUSH
6553: LD_VAR 0 2
6557: MINUS
6558: ARRAY
6559: PPUSH
6560: CALL_OW 52
// end ;
6564: GO 6493
6566: POP
6567: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6568: LD_INT 503
6570: PPUSH
6571: LD_INT 27
6573: PPUSH
6574: LD_STRING 
6576: PPUSH
6577: LD_INT 8
6579: PUSH
6580: LD_INT 9
6582: PUSH
6583: LD_INT 10
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: PUSH
6591: LD_OWVAR 67
6595: ARRAY
6596: PPUSH
6597: LD_INT 3000
6599: PUSH
6600: LD_INT 500
6602: PUSH
6603: LD_INT 150
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: PPUSH
6611: LD_INT 16
6613: PUSH
6614: LD_INT 6
6616: PUSH
6617: LD_INT 6
6619: PUSH
6620: LD_INT 6
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PPUSH
6629: CALL 58980 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6633: LD_ADDR_EXP 89
6637: PUSH
6638: LD_EXP 89
6642: PPUSH
6643: LD_INT 1
6645: PPUSH
6646: LD_INT 22
6648: PUSH
6649: LD_VAR 0 5
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PUSH
6658: LD_INT 23
6660: PUSH
6661: LD_INT 2
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 3
6670: PUSH
6671: LD_INT 21
6673: PUSH
6674: LD_INT 2
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: LIST
6689: PPUSH
6690: CALL_OW 69
6694: PPUSH
6695: CALL_OW 1
6699: ST_TO_ADDR
// end ;
6700: LD_VAR 0 1
6704: RET
// export Omar ; export function PrepareOmarAli ; begin
6705: LD_INT 0
6707: PPUSH
// uc_side := 5 ;
6708: LD_ADDR_OWVAR 20
6712: PUSH
6713: LD_INT 5
6715: ST_TO_ADDR
// uc_nation := 2 ;
6716: LD_ADDR_OWVAR 21
6720: PUSH
6721: LD_INT 2
6723: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6724: LD_ADDR_EXP 53
6728: PUSH
6729: LD_STRING Omar
6731: PPUSH
6732: CALL_OW 25
6736: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6737: LD_EXP 53
6741: PPUSH
6742: LD_INT 330
6744: PPUSH
6745: LD_INT 244
6747: PPUSH
6748: LD_INT 0
6750: PPUSH
6751: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6755: LD_EXP 53
6759: PPUSH
6760: LD_INT 252
6762: PPUSH
6763: LD_INT 220
6765: PPUSH
6766: CALL_OW 111
// end ; end_of_file
6770: LD_VAR 0 1
6774: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6775: LD_INT 0
6777: PPUSH
6778: PPUSH
6779: PPUSH
6780: PPUSH
6781: PPUSH
// side := 8 ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_INT 8
6789: ST_TO_ADDR
// InitHc ;
6790: CALL_OW 19
// uc_side := side ;
6794: LD_ADDR_OWVAR 20
6798: PUSH
6799: LD_VAR 0 3
6803: ST_TO_ADDR
// uc_nation := 2 ;
6804: LD_ADDR_OWVAR 21
6808: PUSH
6809: LD_INT 2
6811: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 21
6831: PUSH
6832: LD_INT 3
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PPUSH
6843: CALL_OW 69
6847: PUSH
6848: FOR_IN
6849: IFFALSE 6865
// SetBLevel ( i , 10 ) ;
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_INT 10
6858: PPUSH
6859: CALL_OW 241
6863: GO 6848
6865: POP
6866: POP
// Schulz := NewCharacter ( Schulz ) ;
6867: LD_ADDR_EXP 54
6871: PUSH
6872: LD_STRING Schulz
6874: PPUSH
6875: CALL_OW 25
6879: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6880: LD_ADDR_EXP 55
6884: PUSH
6885: LD_STRING Kozlov
6887: PPUSH
6888: LD_INT 0
6890: PPUSH
6891: LD_STRING 
6893: PPUSH
6894: CALL 50747 0 3
6898: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6899: LD_EXP 55
6903: PPUSH
6904: LD_INT 22
6906: PUSH
6907: LD_INT 8
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PUSH
6914: LD_INT 23
6916: PUSH
6917: LD_INT 3
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 30
6926: PUSH
6927: LD_INT 8
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: PPUSH
6939: CALL_OW 69
6943: PUSH
6944: LD_INT 1
6946: ARRAY
6947: PPUSH
6948: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6952: LD_EXP 55
6956: PPUSH
6957: LD_INT 3
6959: PPUSH
6960: LD_INT 10
6962: PPUSH
6963: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6967: LD_ADDR_VAR 0 5
6971: PUSH
6972: LD_INT 22
6974: PUSH
6975: LD_VAR 0 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 30
6986: PUSH
6987: LD_INT 32
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 58
6996: PUSH
6997: EMPTY
6998: LIST
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: LIST
7004: PPUSH
7005: CALL_OW 69
7009: ST_TO_ADDR
// for i = 1 to 10 do
7010: LD_ADDR_VAR 0 2
7014: PUSH
7015: DOUBLE
7016: LD_INT 1
7018: DEC
7019: ST_TO_ADDR
7020: LD_INT 10
7022: PUSH
7023: FOR_TO
7024: IFFALSE 7096
// begin uc_nation := nation_nature ;
7026: LD_ADDR_OWVAR 21
7030: PUSH
7031: LD_INT 0
7033: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7034: LD_ADDR_OWVAR 28
7038: PUSH
7039: LD_INT 15
7041: ST_TO_ADDR
// hc_gallery :=  ;
7042: LD_ADDR_OWVAR 33
7046: PUSH
7047: LD_STRING 
7049: ST_TO_ADDR
// hc_name :=  ;
7050: LD_ADDR_OWVAR 26
7054: PUSH
7055: LD_STRING 
7057: ST_TO_ADDR
// un := CreateHuman ;
7058: LD_ADDR_VAR 0 4
7062: PUSH
7063: CALL_OW 44
7067: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7068: LD_VAR 0 4
7072: PPUSH
7073: LD_VAR 0 5
7077: PUSH
7078: LD_VAR 0 5
7082: PUSH
7083: LD_VAR 0 2
7087: MINUS
7088: ARRAY
7089: PPUSH
7090: CALL_OW 52
// end ;
7094: GO 7023
7096: POP
7097: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7098: LD_INT 324
7100: PPUSH
7101: LD_INT 3
7103: PPUSH
7104: LD_STRING 
7106: PPUSH
7107: LD_INT 8
7109: PUSH
7110: LD_INT 9
7112: PUSH
7113: LD_INT 10
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: PUSH
7121: LD_OWVAR 67
7125: ARRAY
7126: PPUSH
7127: LD_INT 3000
7129: PUSH
7130: LD_INT 500
7132: PUSH
7133: LD_INT 150
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PPUSH
7141: LD_INT 16
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 6
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: PPUSH
7159: CALL 58980 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7163: LD_ADDR_EXP 89
7167: PUSH
7168: LD_EXP 89
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: LD_INT 22
7178: PUSH
7179: LD_VAR 0 3
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: LD_INT 23
7190: PUSH
7191: LD_INT 2
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: LD_INT 3
7200: PUSH
7201: LD_INT 21
7203: PUSH
7204: LD_INT 2
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: CALL_OW 69
7224: PUSH
7225: LD_EXP 54
7229: DIFF
7230: PPUSH
7231: CALL_OW 1
7235: ST_TO_ADDR
// end ;
7236: LD_VAR 0 1
7240: RET
// export function BuildKozlovBomb ; begin
7241: LD_INT 0
7243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7244: LD_INT 332
7246: PPUSH
7247: CALL_OW 302
7251: NOT
7252: PUSH
7253: LD_INT 336
7255: PPUSH
7256: CALL_OW 302
7260: NOT
7261: OR
7262: IFFALSE 7266
// exit ;
7264: GO 7363
// ComChangeProfession ( Kozlov , 4 ) ;
7266: LD_EXP 55
7270: PPUSH
7271: LD_INT 4
7273: PPUSH
7274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7278: LD_INT 336
7280: PPUSH
7281: LD_INT 25
7283: PPUSH
7284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7288: LD_INT 35
7290: PPUSH
7291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7295: LD_INT 25
7297: PPUSH
7298: LD_INT 8
7300: PPUSH
7301: CALL_OW 321
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7288
// ComExitBuilding ( Kozlov ) ;
7311: LD_EXP 55
7315: PPUSH
7316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7320: LD_EXP 55
7324: PPUSH
7325: LD_INT 332
7327: PPUSH
7328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7332: LD_EXP 55
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7344: LD_INT 332
7346: PPUSH
7347: LD_INT 23
7349: PPUSH
7350: LD_INT 3
7352: PPUSH
7353: LD_INT 1
7355: PPUSH
7356: LD_INT 48
7358: PPUSH
7359: CALL_OW 125
// end ;
7363: LD_VAR 0 1
7367: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7368: LD_EXP 3
7372: NOT
7373: PUSH
7374: LD_INT 3
7376: PPUSH
7377: LD_INT 1
7379: PPUSH
7380: CALL 45821 0 2
7384: NOT
7385: AND
7386: IFFALSE 8226
7388: GO 7390
7390: DISABLE
7391: LD_INT 0
7393: PPUSH
7394: PPUSH
7395: PPUSH
// begin enable ;
7396: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7397: LD_INT 22
7399: PUSH
7400: LD_INT 8
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PUSH
7407: LD_INT 23
7409: PUSH
7410: LD_INT 2
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 30
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: PPUSH
7432: CALL_OW 69
7436: NOT
7437: IFFALSE 7441
// exit ;
7439: GO 8226
// if Prob ( 40 ) then
7441: LD_INT 40
7443: PPUSH
7444: CALL_OW 13
7448: IFFALSE 7575
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7450: LD_INT 3
7452: PPUSH
7453: LD_INT 14
7455: PUSH
7456: LD_INT 1
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: LD_INT 28
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PUSH
7471: LD_INT 14
7473: PUSH
7474: LD_INT 1
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 28
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 14
7491: PUSH
7492: LD_INT 1
7494: PUSH
7495: LD_INT 2
7497: PUSH
7498: LD_INT 28
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 14
7509: PUSH
7510: LD_INT 1
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 28
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: LD_INT 14
7527: PUSH
7528: LD_INT 1
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: LD_INT 28
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: LD_INT 14
7545: PUSH
7546: LD_INT 1
7548: PUSH
7549: LD_INT 2
7551: PUSH
7552: LD_INT 26
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: PPUSH
7569: CALL 44403 0 2
// end else
7573: GO 7766
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7575: LD_INT 3
7577: PPUSH
7578: LD_INT 14
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 2
7586: PUSH
7587: LD_INT 27
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: LD_INT 26
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: PUSH
7601: LD_OWVAR 67
7605: ARRAY
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 14
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: LD_INT 2
7621: PUSH
7622: LD_INT 27
7624: PUSH
7625: LD_INT 26
7627: PUSH
7628: LD_INT 26
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: LD_OWVAR 67
7640: ARRAY
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: LIST
7647: PUSH
7648: LD_INT 14
7650: PUSH
7651: LD_INT 1
7653: PUSH
7654: LD_INT 2
7656: PUSH
7657: LD_INT 26
7659: PUSH
7660: LD_INT 26
7662: PUSH
7663: LD_INT 29
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_OWVAR 67
7675: ARRAY
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 13
7685: PUSH
7686: LD_INT 1
7688: PUSH
7689: LD_INT 2
7691: PUSH
7692: LD_INT 26
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: LD_INT 29
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: PUSH
7706: LD_OWVAR 67
7710: ARRAY
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 13
7720: PUSH
7721: LD_INT 1
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: LD_INT 29
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 14
7738: PUSH
7739: LD_INT 1
7741: PUSH
7742: LD_INT 2
7744: PUSH
7745: LD_INT 26
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PPUSH
7762: CALL 44403 0 2
// end ; repeat wait ( 0 0$1 ) ;
7766: LD_INT 35
7768: PPUSH
7769: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7773: LD_INT 3
7775: PPUSH
7776: LD_INT 1
7778: PPUSH
7779: CALL 45821 0 2
7783: PUSH
7784: LD_INT 6
7786: GREATEREQUAL
7787: IFFALSE 7766
// wait ( 0 0$30 ) ;
7789: LD_INT 1050
7791: PPUSH
7792: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7796: LD_ADDR_VAR 0 2
7800: PUSH
7801: LD_INT 3
7803: PPUSH
7804: LD_INT 1
7806: PPUSH
7807: CALL 45821 0 2
7811: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7812: LD_ADDR_EXP 108
7816: PUSH
7817: LD_EXP 108
7821: PPUSH
7822: LD_INT 3
7824: PPUSH
7825: LD_EXP 108
7829: PUSH
7830: LD_INT 3
7832: ARRAY
7833: PUSH
7834: LD_VAR 0 2
7838: DIFF
7839: PPUSH
7840: CALL_OW 1
7844: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7845: LD_ADDR_VAR 0 3
7849: PUSH
7850: LD_INT 0
7852: PPUSH
7853: LD_INT 2
7855: PPUSH
7856: CALL_OW 12
7860: ST_TO_ADDR
// if target then
7861: LD_VAR 0 3
7865: IFFALSE 7993
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7867: LD_ADDR_VAR 0 2
7871: PUSH
7872: LD_VAR 0 2
7876: PPUSH
7877: LD_INT 24
7879: PUSH
7880: LD_INT 250
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 72
7891: ST_TO_ADDR
// for i in tmp do
7892: LD_ADDR_VAR 0 1
7896: PUSH
7897: LD_VAR 0 2
7901: PUSH
7902: FOR_IN
7903: IFFALSE 7943
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7905: LD_VAR 0 1
7909: PPUSH
7910: LD_INT 89
7912: PPUSH
7913: LD_INT 71
7915: PPUSH
7916: CALL_OW 297
7920: PUSH
7921: LD_INT 9
7923: GREATER
7924: IFFALSE 7941
// ComMoveXY ( i , 89 , 71 ) ;
7926: LD_VAR 0 1
7930: PPUSH
7931: LD_INT 89
7933: PPUSH
7934: LD_INT 71
7936: PPUSH
7937: CALL_OW 111
7941: GO 7902
7943: POP
7944: POP
// wait ( 0 0$1 ) ;
7945: LD_INT 35
7947: PPUSH
7948: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7952: LD_VAR 0 2
7956: PPUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 89
7962: PUSH
7963: LD_INT 71
7965: PUSH
7966: LD_INT 9
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PPUSH
7975: CALL_OW 72
7979: PUSH
7980: LD_VAR 0 2
7984: PUSH
7985: LD_INT 1
7987: MINUS
7988: GREATEREQUAL
7989: IFFALSE 7867
// end else
7991: GO 8117
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7993: LD_ADDR_VAR 0 2
7997: PUSH
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 24
8005: PUSH
8006: LD_INT 250
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// for i in tmp do
8018: LD_ADDR_VAR 0 1
8022: PUSH
8023: LD_VAR 0 2
8027: PUSH
8028: FOR_IN
8029: IFFALSE 8069
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8031: LD_VAR 0 1
8035: PPUSH
8036: LD_INT 147
8038: PPUSH
8039: LD_INT 4
8041: PPUSH
8042: CALL_OW 297
8046: PUSH
8047: LD_INT 9
8049: GREATER
8050: IFFALSE 8067
// ComMoveXY ( i , 147 , 4 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 147
8059: PPUSH
8060: LD_INT 4
8062: PPUSH
8063: CALL_OW 111
8067: GO 8028
8069: POP
8070: POP
// wait ( 0 0$1 ) ;
8071: LD_INT 35
8073: PPUSH
8074: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8078: LD_VAR 0 2
8082: PPUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 147
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 9
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 72
8105: PUSH
8106: LD_VAR 0 2
8110: PUSH
8111: LD_INT 1
8113: MINUS
8114: GREATEREQUAL
8115: IFFALSE 7993
// end ; repeat wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// for i in tmp do
8124: LD_ADDR_VAR 0 1
8128: PUSH
8129: LD_VAR 0 2
8133: PUSH
8134: FOR_IN
8135: IFFALSE 8217
// begin if GetLives ( i ) > 251 then
8137: LD_VAR 0 1
8141: PPUSH
8142: CALL_OW 256
8146: PUSH
8147: LD_INT 251
8149: GREATER
8150: IFFALSE 8188
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8152: LD_VAR 0 1
8156: PPUSH
8157: LD_INT 81
8159: PUSH
8160: LD_INT 8
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: PPUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: CALL_OW 74
8181: PPUSH
8182: CALL_OW 115
8186: GO 8215
// if IsDead ( i ) then
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 301
8197: IFFALSE 8215
// tmp := tmp diff i ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_VAR 0 2
8208: PUSH
8209: LD_VAR 0 1
8213: DIFF
8214: ST_TO_ADDR
// end ;
8215: GO 8134
8217: POP
8218: POP
// until not tmp ;
8219: LD_VAR 0 2
8223: NOT
8224: IFFALSE 8117
// end ;
8226: PPOPN 3
8228: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8229: LD_EXP 55
8233: PPUSH
8234: CALL_OW 302
8238: PUSH
8239: LD_EXP 3
8243: NOT
8244: AND
8245: IFFALSE 8254
8247: GO 8249
8249: DISABLE
// BuildKozlovBomb ;
8250: CALL 7241 0 0
8254: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8255: LD_INT 22
8257: PUSH
8258: LD_INT 8
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 34
8267: PUSH
8268: LD_INT 48
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PPUSH
8279: CALL_OW 69
8283: IFFALSE 8331
8285: GO 8287
8287: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8288: LD_INT 22
8290: PUSH
8291: LD_INT 8
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: LD_INT 34
8300: PUSH
8301: LD_INT 48
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 69
8316: PUSH
8317: LD_INT 1
8319: ARRAY
8320: PPUSH
8321: LD_INT 173
8323: PPUSH
8324: LD_INT 96
8326: PPUSH
8327: CALL_OW 116
// end ; end_of_file
8331: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8332: LD_INT 0
8334: PPUSH
8335: PPUSH
8336: PPUSH
8337: PPUSH
8338: PPUSH
8339: PPUSH
8340: PPUSH
8341: PPUSH
8342: PPUSH
// side := 3 ;
8343: LD_ADDR_VAR 0 6
8347: PUSH
8348: LD_INT 3
8350: ST_TO_ADDR
// InitHc ;
8351: CALL_OW 19
// uc_side := side ;
8355: LD_ADDR_OWVAR 20
8359: PUSH
8360: LD_VAR 0 6
8364: ST_TO_ADDR
// uc_nation := 3 ;
8365: LD_ADDR_OWVAR 21
8369: PUSH
8370: LD_INT 3
8372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_VAR 0 6
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 21
8392: PUSH
8393: LD_INT 3
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PPUSH
8404: CALL_OW 69
8408: PUSH
8409: FOR_IN
8410: IFFALSE 8426
// SetBLevel ( i , 10 ) ;
8412: LD_VAR 0 2
8416: PPUSH
8417: LD_INT 10
8419: PPUSH
8420: CALL_OW 241
8424: GO 8409
8426: POP
8427: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8428: LD_ADDR_VAR 0 9
8432: PUSH
8433: LD_INT 22
8435: PUSH
8436: LD_VAR 0 6
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: PUSH
8445: LD_INT 30
8447: PUSH
8448: LD_INT 34
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: PPUSH
8459: CALL_OW 69
8463: ST_TO_ADDR
// if teleport then
8464: LD_VAR 0 9
8468: IFFALSE 8489
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8470: LD_VAR 0 9
8474: PUSH
8475: LD_INT 1
8477: ARRAY
8478: PPUSH
8479: LD_INT 123
8481: PPUSH
8482: LD_INT 122
8484: PPUSH
8485: CALL_OW 243
// hc_importance := 0 ;
8489: LD_ADDR_OWVAR 32
8493: PUSH
8494: LD_INT 0
8496: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8497: LD_ADDR_EXP 56
8501: PUSH
8502: LD_STRING Platonov
8504: PPUSH
8505: CALL_OW 25
8509: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8510: LD_ADDR_EXP 57
8514: PUSH
8515: LD_STRING Yakotich
8517: PPUSH
8518: CALL_OW 25
8522: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8523: LD_ADDR_EXP 58
8527: PUSH
8528: LD_STRING Gleb
8530: PPUSH
8531: CALL_OW 25
8535: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8536: LD_STRING 03_Cornel
8538: PPUSH
8539: CALL_OW 28
8543: IFFALSE 8591
// begin Bierezov := NewCharacter ( Mikhail ) ;
8545: LD_ADDR_EXP 59
8549: PUSH
8550: LD_STRING Mikhail
8552: PPUSH
8553: CALL_OW 25
8557: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8558: LD_EXP 59
8562: PPUSH
8563: LD_INT 197
8565: PPUSH
8566: LD_INT 111
8568: PPUSH
8569: LD_INT 9
8571: PPUSH
8572: LD_INT 0
8574: PPUSH
8575: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8579: LD_EXP 59
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8591: LD_EXP 56
8595: PPUSH
8596: LD_INT 126
8598: PPUSH
8599: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8603: LD_EXP 57
8607: PPUSH
8608: LD_INT 197
8610: PPUSH
8611: LD_INT 111
8613: PPUSH
8614: LD_INT 9
8616: PPUSH
8617: LD_INT 0
8619: PPUSH
8620: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8624: LD_EXP 58
8628: PPUSH
8629: LD_INT 197
8631: PPUSH
8632: LD_INT 111
8634: PPUSH
8635: LD_INT 9
8637: PPUSH
8638: LD_INT 0
8640: PPUSH
8641: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8645: LD_ADDR_VAR 0 5
8649: PUSH
8650: LD_INT 126
8652: PPUSH
8653: LD_INT 2
8655: PPUSH
8656: LD_STRING zhukov
8658: PPUSH
8659: LD_INT 9
8661: PUSH
8662: LD_INT 10
8664: PUSH
8665: LD_INT 10
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_OWVAR 67
8677: ARRAY
8678: PPUSH
8679: LD_INT 9000
8681: PUSH
8682: LD_INT 1000
8684: PUSH
8685: LD_INT 300
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: LD_INT 21
8695: PUSH
8696: LD_INT 8
8698: PUSH
8699: LD_INT 13
8701: PUSH
8702: LD_INT 8
8704: PUSH
8705: EMPTY
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL 58980 0 6
8715: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8716: LD_ADDR_VAR 0 4
8720: PUSH
8721: LD_INT 267
8723: PPUSH
8724: CALL_OW 274
8728: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8729: LD_VAR 0 4
8733: PPUSH
8734: LD_INT 1
8736: PPUSH
8737: LD_INT 5000
8739: PPUSH
8740: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8744: LD_VAR 0 4
8748: PPUSH
8749: LD_INT 2
8751: PPUSH
8752: LD_INT 200
8754: PPUSH
8755: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8759: LD_VAR 0 4
8763: PPUSH
8764: LD_INT 3
8766: PPUSH
8767: LD_INT 200
8769: PPUSH
8770: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8774: LD_ADDR_EXP 89
8778: PUSH
8779: LD_EXP 89
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: LD_VAR 0 5
8791: PUSH
8792: LD_INT 22
8794: PUSH
8795: LD_VAR 0 6
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 2
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PPUSH
8825: CALL_OW 69
8829: UNION
8830: PUSH
8831: LD_EXP 56
8835: DIFF
8836: PPUSH
8837: CALL_OW 1
8841: ST_TO_ADDR
// behemoths := [ ] ;
8842: LD_ADDR_EXP 60
8846: PUSH
8847: EMPTY
8848: ST_TO_ADDR
// behemothBuilders := [ ] ;
8849: LD_ADDR_EXP 61
8853: PUSH
8854: EMPTY
8855: ST_TO_ADDR
// j := 3 ;
8856: LD_ADDR_VAR 0 3
8860: PUSH
8861: LD_INT 3
8863: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8864: LD_ADDR_VAR 0 2
8868: PUSH
8869: LD_INT 22
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 25
8881: PUSH
8882: LD_INT 3
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PPUSH
8893: CALL_OW 69
8897: PUSH
8898: FOR_IN
8899: IFFALSE 8949
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8901: LD_ADDR_EXP 61
8905: PUSH
8906: LD_EXP 61
8910: PPUSH
8911: LD_VAR 0 2
8915: PPUSH
8916: CALL 86617 0 2
8920: ST_TO_ADDR
// j := j - 1 ;
8921: LD_ADDR_VAR 0 3
8925: PUSH
8926: LD_VAR 0 3
8930: PUSH
8931: LD_INT 1
8933: MINUS
8934: ST_TO_ADDR
// if j = 0 then
8935: LD_VAR 0 3
8939: PUSH
8940: LD_INT 0
8942: EQUAL
8943: IFFALSE 8947
// break ;
8945: GO 8949
// end ;
8947: GO 8898
8949: POP
8950: POP
// end ;
8951: LD_VAR 0 1
8955: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8956: LD_INT 0
8958: PPUSH
8959: PPUSH
8960: PPUSH
8961: PPUSH
8962: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8963: LD_ADDR_VAR 0 4
8967: PUSH
8968: LD_INT 209
8970: PUSH
8971: LD_INT 149
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PUSH
8978: LD_INT 219
8980: PUSH
8981: LD_INT 154
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: PUSH
8988: LD_INT 223
8990: PUSH
8991: LD_INT 149
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: PUSH
8998: LD_INT 232
9000: PUSH
9001: LD_INT 155
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: ST_TO_ADDR
// if not behemothBuilders then
9014: LD_EXP 61
9018: NOT
9019: IFFALSE 9023
// exit ;
9021: GO 9127
// j := 1 ;
9023: LD_ADDR_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ST_TO_ADDR
// for i in behemothBuilders do
9031: LD_ADDR_VAR 0 2
9035: PUSH
9036: LD_EXP 61
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9125
// begin if IsInUnit ( i ) then
9044: LD_VAR 0 2
9048: PPUSH
9049: CALL_OW 310
9053: IFFALSE 9064
// ComExitBuilding ( i ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9064: LD_VAR 0 2
9068: PPUSH
9069: LD_INT 37
9071: PPUSH
9072: LD_VAR 0 4
9076: PUSH
9077: LD_VAR 0 3
9081: ARRAY
9082: PUSH
9083: LD_INT 1
9085: ARRAY
9086: PPUSH
9087: LD_VAR 0 4
9091: PUSH
9092: LD_VAR 0 3
9096: ARRAY
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_INT 0
9104: PPUSH
9105: CALL_OW 230
// j := j + 1 ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_VAR 0 3
9118: PUSH
9119: LD_INT 1
9121: PLUS
9122: ST_TO_ADDR
// end ;
9123: GO 9041
9125: POP
9126: POP
// end ;
9127: LD_VAR 0 1
9131: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9132: LD_INT 3
9134: PPUSH
9135: CALL 86678 0 1
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 30
9152: PUSH
9153: LD_INT 37
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: NOT
9169: AND
9170: IFFALSE 9356
9172: GO 9174
9174: DISABLE
9175: LD_INT 0
9177: PPUSH
9178: PPUSH
// begin enable ;
9179: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9180: LD_ADDR_VAR 0 2
9184: PUSH
9185: LD_INT 3
9187: PPUSH
9188: CALL 86678 0 1
9192: ST_TO_ADDR
// for i in tmp do
9193: LD_ADDR_VAR 0 1
9197: PUSH
9198: LD_VAR 0 2
9202: PUSH
9203: FOR_IN
9204: IFFALSE 9354
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_INT 7
9213: PPUSH
9214: CALL_OW 308
9218: PUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: CALL_OW 110
9228: PUSH
9229: LD_INT 2
9231: EQUAL
9232: NOT
9233: AND
9234: IFFALSE 9248
// SetTag ( i , 2 ) ;
9236: LD_VAR 0 1
9240: PPUSH
9241: LD_INT 2
9243: PPUSH
9244: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9248: LD_INT 81
9250: PUSH
9251: LD_INT 3
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: LD_INT 91
9260: PUSH
9261: LD_VAR 0 1
9265: PUSH
9266: LD_INT 12
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 69
9282: NOT
9283: PUSH
9284: LD_VAR 0 1
9288: PPUSH
9289: CALL_OW 110
9293: PUSH
9294: LD_INT 2
9296: EQUAL
9297: NOT
9298: AND
9299: IFFALSE 9318
// ComAgressiveMove ( i , 64 , 93 ) else
9301: LD_VAR 0 1
9305: PPUSH
9306: LD_INT 64
9308: PPUSH
9309: LD_INT 93
9311: PPUSH
9312: CALL_OW 114
9316: GO 9352
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_INT 81
9325: PUSH
9326: LD_INT 3
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: PPUSH
9333: CALL_OW 69
9337: PPUSH
9338: LD_VAR 0 1
9342: PPUSH
9343: CALL_OW 74
9347: PPUSH
9348: CALL_OW 115
// end ;
9352: GO 9203
9354: POP
9355: POP
// end ;
9356: PPOPN 2
9358: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9359: LD_EXP 2
9363: NOT
9364: PUSH
9365: LD_INT 2
9367: PPUSH
9368: LD_INT 1
9370: PPUSH
9371: CALL 45821 0 2
9375: NOT
9376: AND
9377: IFFALSE 10297
9379: GO 9381
9381: DISABLE
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// begin enable ;
9388: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 30
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: NOT
9418: IFFALSE 9422
// exit ;
9420: GO 10297
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9422: LD_ADDR_VAR 0 4
9426: PUSH
9427: LD_INT 22
9429: PUSH
9430: LD_INT 3
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PUSH
9437: LD_INT 30
9439: PUSH
9440: LD_INT 34
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: ST_TO_ADDR
// if Prob ( 40 ) then
9456: LD_INT 40
9458: PPUSH
9459: CALL_OW 13
9463: IFFALSE 9590
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9465: LD_INT 2
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: LD_INT 49
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 22
9488: PUSH
9489: LD_INT 3
9491: PUSH
9492: LD_INT 3
9494: PUSH
9495: LD_INT 49
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: PUSH
9504: LD_INT 22
9506: PUSH
9507: LD_INT 3
9509: PUSH
9510: LD_INT 3
9512: PUSH
9513: LD_INT 49
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: PUSH
9522: LD_INT 24
9524: PUSH
9525: LD_INT 3
9527: PUSH
9528: LD_INT 3
9530: PUSH
9531: LD_INT 46
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 24
9542: PUSH
9543: LD_INT 3
9545: PUSH
9546: LD_INT 3
9548: PUSH
9549: LD_INT 46
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 24
9560: PUSH
9561: LD_INT 3
9563: PUSH
9564: LD_INT 3
9566: PUSH
9567: LD_INT 46
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: PPUSH
9584: CALL 44403 0 2
// end else
9588: GO 9713
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9590: LD_INT 2
9592: PPUSH
9593: LD_INT 24
9595: PUSH
9596: LD_INT 3
9598: PUSH
9599: LD_INT 3
9601: PUSH
9602: LD_INT 47
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: PUSH
9611: LD_INT 24
9613: PUSH
9614: LD_INT 3
9616: PUSH
9617: LD_INT 3
9619: PUSH
9620: LD_INT 47
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_INT 24
9631: PUSH
9632: LD_INT 3
9634: PUSH
9635: LD_INT 3
9637: PUSH
9638: LD_INT 47
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 24
9649: PUSH
9650: LD_INT 3
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: LD_INT 46
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 24
9667: PUSH
9668: LD_INT 3
9670: PUSH
9671: LD_INT 3
9673: PUSH
9674: LD_INT 46
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: PUSH
9683: LD_INT 24
9685: PUSH
9686: LD_INT 3
9688: PUSH
9689: LD_INT 3
9691: PUSH
9692: LD_INT 46
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: PPUSH
9709: CALL 44403 0 2
// end ; if Difficulty > 1 then
9713: LD_OWVAR 67
9717: PUSH
9718: LD_INT 1
9720: GREATER
9721: IFFALSE 9751
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9723: LD_INT 2
9725: PPUSH
9726: LD_INT 24
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 47
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: PPUSH
9747: CALL 44403 0 2
// repeat wait ( 0 0$1 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9758: LD_INT 2
9760: PPUSH
9761: LD_INT 1
9763: PPUSH
9764: CALL 45821 0 2
9768: PUSH
9769: LD_INT 6
9771: PUSH
9772: LD_INT 7
9774: PUSH
9775: LD_INT 7
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_OWVAR 67
9787: ARRAY
9788: GREATEREQUAL
9789: IFFALSE 9751
// wait ( 0 0$30 ) ;
9791: LD_INT 1050
9793: PPUSH
9794: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 2
9805: PPUSH
9806: LD_INT 1
9808: PPUSH
9809: CALL 45821 0 2
9813: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9814: LD_ADDR_EXP 108
9818: PUSH
9819: LD_EXP 108
9823: PPUSH
9824: LD_INT 2
9826: PPUSH
9827: LD_EXP 108
9831: PUSH
9832: LD_INT 2
9834: ARRAY
9835: PUSH
9836: LD_VAR 0 2
9840: DIFF
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9847: LD_ADDR_VAR 0 3
9851: PUSH
9852: LD_INT 0
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL_OW 12
9862: ST_TO_ADDR
// if target then
9863: LD_VAR 0 3
9867: IFFALSE 9995
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9869: LD_ADDR_VAR 0 2
9873: PUSH
9874: LD_VAR 0 2
9878: PPUSH
9879: LD_INT 24
9881: PUSH
9882: LD_INT 250
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: CALL_OW 72
9893: ST_TO_ADDR
// for i in tmp do
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_VAR 0 2
9903: PUSH
9904: FOR_IN
9905: IFFALSE 9945
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 139
9914: PPUSH
9915: LD_INT 89
9917: PPUSH
9918: CALL_OW 297
9922: PUSH
9923: LD_INT 9
9925: GREATER
9926: IFFALSE 9943
// ComMoveXY ( i , 139 , 89 ) ;
9928: LD_VAR 0 1
9932: PPUSH
9933: LD_INT 139
9935: PPUSH
9936: LD_INT 89
9938: PPUSH
9939: CALL_OW 111
9943: GO 9904
9945: POP
9946: POP
// wait ( 0 0$1 ) ;
9947: LD_INT 35
9949: PPUSH
9950: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9954: LD_VAR 0 2
9958: PPUSH
9959: LD_INT 92
9961: PUSH
9962: LD_INT 139
9964: PUSH
9965: LD_INT 89
9967: PUSH
9968: LD_INT 9
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: PPUSH
9977: CALL_OW 72
9981: PUSH
9982: LD_VAR 0 2
9986: PUSH
9987: LD_INT 1
9989: MINUS
9990: GREATEREQUAL
9991: IFFALSE 9869
// end else
9993: GO 10137
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9995: LD_VAR 0 2
9999: PPUSH
10000: LD_VAR 0 4
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PPUSH
10009: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10013: LD_ADDR_VAR 0 2
10017: PUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: LD_INT 24
10025: PUSH
10026: LD_INT 250
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PPUSH
10033: CALL_OW 72
10037: ST_TO_ADDR
// for i in tmp do
10038: LD_ADDR_VAR 0 1
10042: PUSH
10043: LD_VAR 0 2
10047: PUSH
10048: FOR_IN
10049: IFFALSE 10089
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10051: LD_VAR 0 1
10055: PPUSH
10056: LD_INT 124
10058: PPUSH
10059: LD_INT 139
10061: PPUSH
10062: CALL_OW 297
10066: PUSH
10067: LD_INT 9
10069: GREATER
10070: IFFALSE 10087
// ComMoveXY ( i , 124 , 139 ) ;
10072: LD_VAR 0 1
10076: PPUSH
10077: LD_INT 124
10079: PPUSH
10080: LD_INT 139
10082: PPUSH
10083: CALL_OW 111
10087: GO 10048
10089: POP
10090: POP
// wait ( 0 0$1 ) ;
10091: LD_INT 35
10093: PPUSH
10094: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10098: LD_VAR 0 2
10102: PPUSH
10103: LD_INT 92
10105: PUSH
10106: LD_INT 124
10108: PUSH
10109: LD_INT 139
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 72
10125: PUSH
10126: LD_VAR 0 2
10130: PUSH
10131: LD_INT 1
10133: MINUS
10134: GREATEREQUAL
10135: IFFALSE 10013
// end ; repeat wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// for i in tmp do
10144: LD_ADDR_VAR 0 1
10148: PUSH
10149: LD_VAR 0 2
10153: PUSH
10154: FOR_IN
10155: IFFALSE 10288
// begin if GetLives ( i ) > 251 then
10157: LD_VAR 0 1
10161: PPUSH
10162: CALL_OW 256
10166: PUSH
10167: LD_INT 251
10169: GREATER
10170: IFFALSE 10259
// begin if GetWeapon ( i ) = ru_time_lapser then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 264
10181: PUSH
10182: LD_INT 49
10184: EQUAL
10185: IFFALSE 10223
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10187: LD_VAR 0 1
10191: PPUSH
10192: LD_INT 81
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PPUSH
10202: CALL_OW 69
10206: PPUSH
10207: LD_VAR 0 1
10211: PPUSH
10212: CALL_OW 74
10216: PPUSH
10217: CALL_OW 112
10221: GO 10257
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 81
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PPUSH
10238: CALL_OW 69
10242: PPUSH
10243: LD_VAR 0 1
10247: PPUSH
10248: CALL_OW 74
10252: PPUSH
10253: CALL_OW 115
// end else
10257: GO 10286
// if IsDead ( i ) then
10259: LD_VAR 0 1
10263: PPUSH
10264: CALL_OW 301
10268: IFFALSE 10286
// tmp := tmp diff i ;
10270: LD_ADDR_VAR 0 2
10274: PUSH
10275: LD_VAR 0 2
10279: PUSH
10280: LD_VAR 0 1
10284: DIFF
10285: ST_TO_ADDR
// end ;
10286: GO 10154
10288: POP
10289: POP
// until not tmp ;
10290: LD_VAR 0 2
10294: NOT
10295: IFFALSE 10137
// end ;
10297: PPOPN 4
10299: END
// every 30 30$00 trigger not russianDestroyed do
10300: LD_EXP 2
10304: NOT
10305: IFFALSE 10370
10307: GO 10309
10309: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10310: LD_INT 105000
10312: PUSH
10313: LD_INT 84000
10315: PUSH
10316: LD_INT 63000
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: PUSH
10324: LD_OWVAR 67
10328: ARRAY
10329: PPUSH
10330: CALL_OW 67
// if russianDestroyed then
10334: LD_EXP 2
10338: IFFALSE 10342
// exit ;
10340: GO 10370
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 23
10347: PUSH
10348: LD_INT 3
10350: PUSH
10351: LD_INT 1
10353: PUSH
10354: LD_INT 48
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PUSH
10363: EMPTY
10364: LIST
10365: PPUSH
10366: CALL 44403 0 2
// end ; end_of_file
10370: END
// export function CustomEvent ( event ) ; begin
10371: LD_INT 0
10373: PPUSH
// end ;
10374: LD_VAR 0 2
10378: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10379: LD_VAR 0 2
10383: PPUSH
10384: LD_VAR 0 3
10388: PPUSH
10389: LD_INT 15
10391: PPUSH
10392: CALL_OW 309
10396: IFFALSE 10405
// YouLost ( MothContaminate ) ;
10398: LD_STRING MothContaminate
10400: PPUSH
10401: CALL_OW 104
// end ;
10405: PPOPN 3
10407: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10408: LD_VAR 0 2
10412: PPUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 15
10420: PPUSH
10421: CALL_OW 309
10425: IFFALSE 10441
// begin wait ( 0 0$6 ) ;
10427: LD_INT 210
10429: PPUSH
10430: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10434: LD_STRING MothContaminateBomb
10436: PPUSH
10437: CALL_OW 104
// end ; end ;
10441: PPOPN 3
10443: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10444: LD_VAR 0 1
10448: PUSH
10449: LD_EXP 17
10453: EQUAL
10454: IFFALSE 10465
// begin YouLost ( JMM ) ;
10456: LD_STRING JMM
10458: PPUSH
10459: CALL_OW 104
// exit ;
10463: GO 10564
// end ; if un = Powell then
10465: LD_VAR 0 1
10469: PUSH
10470: LD_EXP 52
10474: EQUAL
10475: IFFALSE 10485
// americanDestroyed := true ;
10477: LD_ADDR_EXP 4
10481: PUSH
10482: LD_INT 1
10484: ST_TO_ADDR
// if un = Platonov then
10485: LD_VAR 0 1
10489: PUSH
10490: LD_EXP 56
10494: EQUAL
10495: IFFALSE 10505
// russianDestroyed := true ;
10497: LD_ADDR_EXP 2
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10505: LD_VAR 0 1
10509: PUSH
10510: LD_INT 22
10512: PUSH
10513: LD_INT 7
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 21
10522: PUSH
10523: LD_INT 2
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IN
10539: IFFALSE 10555
// vehicleLostCounter := vehicleLostCounter + 1 ;
10541: LD_ADDR_EXP 15
10545: PUSH
10546: LD_EXP 15
10550: PUSH
10551: LD_INT 1
10553: PLUS
10554: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL 47795 0 1
// end ;
10564: PPOPN 1
10566: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10567: LD_VAR 0 1
10571: PPUSH
10572: LD_VAR 0 2
10576: PPUSH
10577: CALL 50129 0 2
// end ;
10581: PPOPN 2
10583: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10584: LD_VAR 0 1
10588: PPUSH
10589: CALL 49197 0 1
// end ;
10593: PPOPN 1
10595: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10596: LD_VAR 0 1
10600: PUSH
10601: LD_INT 22
10603: PUSH
10604: LD_INT 8
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 30
10613: PUSH
10614: LD_INT 2
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 23
10623: PUSH
10624: LD_INT 3
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10668
// begin ComUpgrade ( building ) ;
10643: LD_VAR 0 1
10647: PPUSH
10648: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10652: LD_EXP 55
10656: PPUSH
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 58544 0 2
// exit ;
10666: GO 10677
// end ; MCE_BuildingComplete ( building ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 49438 0 1
// end ;
10677: PPOPN 1
10679: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10680: LD_VAR 0 1
10684: PPUSH
10685: LD_VAR 0 2
10689: PPUSH
10690: CALL 47491 0 2
// end ;
10694: PPOPN 2
10696: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_VAR 0 2
10706: PPUSH
10707: LD_VAR 0 3
10711: PPUSH
10712: LD_VAR 0 4
10716: PPUSH
10717: LD_VAR 0 5
10721: PPUSH
10722: CALL 47111 0 5
// end ;
10726: PPOPN 5
10728: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10729: LD_VAR 0 1
10733: PPUSH
10734: LD_VAR 0 2
10738: PPUSH
10739: CALL 46707 0 2
// end ;
10743: PPOPN 2
10745: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10746: LD_VAR 0 1
10750: PPUSH
10751: LD_VAR 0 2
10755: PPUSH
10756: LD_VAR 0 3
10760: PPUSH
10761: LD_VAR 0 4
10765: PPUSH
10766: CALL 46545 0 4
// end ;
10770: PPOPN 4
10772: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10773: LD_VAR 0 1
10777: PPUSH
10778: LD_VAR 0 2
10782: PPUSH
10783: LD_VAR 0 3
10787: PPUSH
10788: CALL 46320 0 3
// end ;
10792: PPOPN 3
10794: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10795: LD_VAR 0 1
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: CALL 46205 0 2
// end ;
10809: PPOPN 2
10811: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_VAR 0 2
10821: PPUSH
10822: CALL 50390 0 2
// end ;
10826: PPOPN 2
10828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10829: LD_VAR 0 1
10833: PPUSH
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_VAR 0 3
10843: PPUSH
10844: LD_VAR 0 4
10848: PPUSH
10849: CALL 50606 0 4
// end ;
10853: PPOPN 4
10855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: LD_VAR 0 2
10865: PPUSH
10866: CALL 46014 0 2
// end ;
10870: PPOPN 2
10872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10873: LD_VAR 0 1
10877: PPUSH
10878: CALL 99904 0 1
// end ; end_of_file
10882: PPOPN 1
10884: END
// export function Action ; begin
10885: LD_INT 0
10887: PPUSH
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10892: LD_INT 206
10894: PPUSH
10895: LD_INT 11
10897: PPUSH
10898: CALL_OW 86
// wait ( 0 0$1 ) ;
10902: LD_INT 35
10904: PPUSH
10905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10909: LD_EXP 17
10913: PPUSH
10914: LD_STRING DStart-JMM-JMM-1
10916: PPUSH
10917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10921: LD_EXP 49
10925: PPUSH
10926: LD_STRING DStart-JMM-Bur-1
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10933: LD_EXP 17
10937: PPUSH
10938: LD_STRING DStart-JMM-JMM-2
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10945: LD_EXP 49
10949: PPUSH
10950: LD_STRING DStart-JMM-Bur-2
10952: PPUSH
10953: CALL_OW 88
// InGameOff ;
10957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10961: LD_STRING MStart
10963: PPUSH
10964: CALL_OW 337
// SaveForQuickRestart ;
10968: CALL_OW 22
// end ;
10972: LD_VAR 0 1
10976: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10977: LD_INT 7
10979: PPUSH
10980: LD_INT 255
10982: PPUSH
10983: LD_INT 219
10985: PPUSH
10986: CALL_OW 293
10990: IFFALSE 11599
10992: GO 10994
10994: DISABLE
10995: LD_INT 0
10997: PPUSH
// begin wait ( 0 0$3 ) ;
10998: LD_INT 105
11000: PPUSH
11001: CALL_OW 67
// alienSpotted := true ;
11005: LD_ADDR_EXP 10
11009: PUSH
11010: LD_INT 1
11012: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11013: LD_ADDR_VAR 0 1
11017: PUSH
11018: LD_INT 22
11020: PUSH
11021: LD_INT 7
11023: PUSH
11024: EMPTY
11025: LIST
11026: LIST
11027: PUSH
11028: LD_INT 23
11030: PUSH
11031: LD_INT 3
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PUSH
11038: LD_INT 21
11040: PUSH
11041: LD_INT 1
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PUSH
11048: LD_INT 26
11050: PUSH
11051: LD_INT 1
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: LIST
11062: LIST
11063: PPUSH
11064: CALL_OW 69
11068: PUSH
11069: LD_EXP 49
11073: PUSH
11074: LD_EXP 37
11078: PUSH
11079: LD_EXP 39
11083: PUSH
11084: LD_EXP 40
11088: PUSH
11089: LD_EXP 47
11093: PUSH
11094: LD_EXP 46
11098: PUSH
11099: LD_EXP 41
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: DIFF
11113: ST_TO_ADDR
// DialogueOn ;
11114: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11118: LD_INT 255
11120: PPUSH
11121: LD_INT 219
11123: PPUSH
11124: LD_INT 7
11126: PPUSH
11127: LD_INT 20
11129: NEG
11130: PPUSH
11131: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11135: LD_INT 255
11137: PPUSH
11138: LD_INT 219
11140: PPUSH
11141: CALL_OW 86
// if speaker then
11145: LD_VAR 0 1
11149: IFFALSE 11167
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11151: LD_VAR 0 1
11155: PUSH
11156: LD_INT 1
11158: ARRAY
11159: PPUSH
11160: LD_STRING DAlienBase-RSol1-1
11162: PPUSH
11163: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11167: LD_EXP 17
11171: PPUSH
11172: LD_STRING DAlienBase-JMM-1
11174: PPUSH
11175: CALL_OW 88
// if IsOk ( Burlak ) then
11179: LD_EXP 49
11183: PPUSH
11184: CALL_OW 302
11188: IFFALSE 11209
// begin dwait ( 0 0$1 ) ;
11190: LD_INT 35
11192: PPUSH
11193: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11197: LD_EXP 49
11201: PPUSH
11202: LD_STRING DAlienBase-Bur-1
11204: PPUSH
11205: CALL_OW 88
// end ; if IsOk ( Roth ) then
11209: LD_EXP 18
11213: PPUSH
11214: CALL_OW 302
11218: IFFALSE 11232
// Say ( Roth , DAlienBase-Roth-1 ) ;
11220: LD_EXP 18
11224: PPUSH
11225: LD_STRING DAlienBase-Roth-1
11227: PPUSH
11228: CALL_OW 88
// if IsOk ( Gossudarov ) then
11232: LD_EXP 35
11236: PPUSH
11237: CALL_OW 302
11241: IFFALSE 11257
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11243: LD_EXP 35
11247: PPUSH
11248: LD_STRING DAlienBase-Gos-1
11250: PPUSH
11251: CALL_OW 88
11255: GO 11374
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11257: LD_ADDR_VAR 0 1
11261: PUSH
11262: LD_INT 22
11264: PUSH
11265: LD_INT 7
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: PUSH
11272: LD_INT 25
11274: PUSH
11275: LD_INT 4
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: PUSH
11282: LD_INT 21
11284: PUSH
11285: LD_INT 1
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PUSH
11292: LD_INT 26
11294: PUSH
11295: LD_INT 1
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: PPUSH
11308: CALL_OW 69
11312: PUSH
11313: LD_EXP 18
11317: PUSH
11318: LD_EXP 17
11322: PUSH
11323: LD_EXP 49
11327: PUSH
11328: LD_EXP 37
11332: PUSH
11333: LD_EXP 47
11337: PUSH
11338: LD_EXP 46
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: LIST
11347: LIST
11348: LIST
11349: LIST
11350: DIFF
11351: ST_TO_ADDR
// if speaker then
11352: LD_VAR 0 1
11356: IFFALSE 11374
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11358: LD_VAR 0 1
11362: PUSH
11363: LD_INT 1
11365: ARRAY
11366: PPUSH
11367: LD_STRING DAlienBase-Sci1-1
11369: PPUSH
11370: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11374: LD_INT 255
11376: PPUSH
11377: LD_INT 219
11379: PPUSH
11380: LD_INT 7
11382: PPUSH
11383: CALL_OW 331
// DialogueOff ;
11387: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// until IsSelected ( alien ) ;
11398: LD_INT 1
11400: PPUSH
11401: CALL_OW 306
11405: IFFALSE 11391
// if not artifactIResearched or not artifactIIResearched then
11407: LD_EXP 12
11411: NOT
11412: PUSH
11413: LD_EXP 13
11417: NOT
11418: OR
11419: IFFALSE 11599
// begin if IsOk ( Roth ) then
11421: LD_EXP 18
11425: PPUSH
11426: CALL_OW 302
11430: IFFALSE 11446
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11432: LD_EXP 18
11436: PPUSH
11437: LD_STRING DAlieBaseNotReady-Roth-1
11439: PPUSH
11440: CALL_OW 88
11444: GO 11599
// if IsOk ( Gossudarov ) then
11446: LD_EXP 35
11450: PPUSH
11451: CALL_OW 302
11455: IFFALSE 11471
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11457: LD_EXP 35
11461: PPUSH
11462: LD_STRING DAlieBaseNotReady-Gos-1
11464: PPUSH
11465: CALL_OW 88
11469: GO 11599
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11471: LD_ADDR_VAR 0 1
11475: PUSH
11476: LD_INT 22
11478: PUSH
11479: LD_INT 7
11481: PUSH
11482: EMPTY
11483: LIST
11484: LIST
11485: PUSH
11486: LD_INT 23
11488: PUSH
11489: LD_INT 3
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: PUSH
11496: LD_INT 25
11498: PUSH
11499: LD_INT 4
11501: PUSH
11502: EMPTY
11503: LIST
11504: LIST
11505: PUSH
11506: LD_INT 21
11508: PUSH
11509: LD_INT 1
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: PUSH
11516: LD_INT 26
11518: PUSH
11519: LD_INT 1
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: PUSH
11526: EMPTY
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: PPUSH
11533: CALL_OW 69
11537: PUSH
11538: LD_EXP 18
11542: PUSH
11543: LD_EXP 17
11547: PUSH
11548: LD_EXP 49
11552: PUSH
11553: LD_EXP 37
11557: PUSH
11558: LD_EXP 47
11562: PUSH
11563: LD_EXP 46
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: LIST
11572: LIST
11573: LIST
11574: LIST
11575: DIFF
11576: ST_TO_ADDR
// if speaker then
11577: LD_VAR 0 1
11581: IFFALSE 11599
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11583: LD_VAR 0 1
11587: PUSH
11588: LD_INT 1
11590: ARRAY
11591: PPUSH
11592: LD_STRING DAlieBaseNotReady-RSci1-1
11594: PPUSH
11595: CALL_OW 88
// end ; end ; end ;
11599: PPOPN 1
11601: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11602: LD_INT 24
11604: PPUSH
11605: LD_INT 7
11607: PPUSH
11608: CALL_OW 321
11612: PUSH
11613: LD_INT 2
11615: EQUAL
11616: IFFALSE 12307
11618: GO 11620
11620: DISABLE
11621: LD_INT 0
11623: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11624: LD_ADDR_VAR 0 1
11628: PUSH
11629: LD_INT 22
11631: PUSH
11632: LD_INT 7
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: PUSH
11639: LD_INT 23
11641: PUSH
11642: LD_INT 3
11644: PUSH
11645: EMPTY
11646: LIST
11647: LIST
11648: PUSH
11649: LD_INT 25
11651: PUSH
11652: LD_INT 4
11654: PUSH
11655: EMPTY
11656: LIST
11657: LIST
11658: PUSH
11659: LD_INT 21
11661: PUSH
11662: LD_INT 1
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: PUSH
11669: LD_INT 26
11671: PUSH
11672: LD_INT 1
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: PPUSH
11686: CALL_OW 69
11690: PUSH
11691: LD_EXP 18
11695: PUSH
11696: LD_EXP 17
11700: PUSH
11701: LD_EXP 49
11705: PUSH
11706: LD_EXP 37
11710: PUSH
11711: LD_EXP 47
11715: PUSH
11716: LD_EXP 46
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: DIFF
11729: ST_TO_ADDR
// if not speaker then
11730: LD_VAR 0 1
11734: NOT
11735: IFFALSE 11739
// exit ;
11737: GO 12307
// DialogueOn ;
11739: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11743: LD_VAR 0 1
11747: PUSH
11748: LD_INT 1
11750: ARRAY
11751: PPUSH
11752: LD_STRING DArtefTechnology-RSci1-1
11754: PPUSH
11755: CALL_OW 88
// if IsOk ( Burlak ) then
11759: LD_EXP 49
11763: PPUSH
11764: CALL_OW 302
11768: IFFALSE 11782
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11770: LD_EXP 49
11774: PPUSH
11775: LD_STRING DArtefTechnology-Bur-1
11777: PPUSH
11778: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11782: LD_VAR 0 1
11786: PUSH
11787: LD_INT 1
11789: ARRAY
11790: PPUSH
11791: LD_STRING DArtefTechnology-RSci1-2
11793: PPUSH
11794: CALL_OW 88
// if Denis then
11798: LD_EXP 23
11802: IFFALSE 11819
// speaker := [ Denis ] else
11804: LD_ADDR_VAR 0 1
11808: PUSH
11809: LD_EXP 23
11813: PUSH
11814: EMPTY
11815: LIST
11816: ST_TO_ADDR
11817: GO 11925
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11819: LD_ADDR_VAR 0 1
11823: PUSH
11824: LD_INT 22
11826: PUSH
11827: LD_INT 7
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: LD_INT 23
11836: PUSH
11837: LD_INT 1
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: PUSH
11844: LD_INT 25
11846: PUSH
11847: LD_INT 4
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: LD_INT 21
11856: PUSH
11857: LD_INT 1
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PUSH
11864: LD_INT 26
11866: PUSH
11867: LD_INT 1
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: PPUSH
11881: CALL_OW 69
11885: PUSH
11886: LD_EXP 18
11890: PUSH
11891: LD_EXP 17
11895: PUSH
11896: LD_EXP 49
11900: PUSH
11901: LD_EXP 37
11905: PUSH
11906: LD_EXP 47
11910: PUSH
11911: LD_EXP 46
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: LIST
11920: LIST
11921: LIST
11922: LIST
11923: DIFF
11924: ST_TO_ADDR
// if speaker then
11925: LD_VAR 0 1
11929: IFFALSE 11947
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11931: LD_VAR 0 1
11935: PUSH
11936: LD_INT 1
11938: ARRAY
11939: PPUSH
11940: LD_STRING DArtefTechnology-Sci1-2
11942: PPUSH
11943: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11947: LD_ADDR_VAR 0 1
11951: PUSH
11952: LD_INT 22
11954: PUSH
11955: LD_INT 7
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: PUSH
11962: LD_INT 23
11964: PUSH
11965: LD_INT 3
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 25
11974: PUSH
11975: LD_INT 4
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_INT 21
11984: PUSH
11985: LD_INT 1
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PUSH
11992: LD_INT 26
11994: PUSH
11995: LD_INT 1
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: PPUSH
12009: CALL_OW 69
12013: PUSH
12014: LD_EXP 18
12018: PUSH
12019: LD_EXP 17
12023: PUSH
12024: LD_EXP 49
12028: PUSH
12029: LD_EXP 37
12033: PUSH
12034: LD_EXP 47
12038: PUSH
12039: LD_EXP 46
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: LIST
12048: LIST
12049: LIST
12050: LIST
12051: DIFF
12052: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12053: LD_VAR 0 1
12057: PUSH
12058: LD_EXP 9
12062: PUSH
12063: LD_EXP 5
12067: OR
12068: AND
12069: IFFALSE 12303
// begin if arabianDestroyed and IsOk ( Burlak ) then
12071: LD_EXP 5
12075: PUSH
12076: LD_EXP 49
12080: PPUSH
12081: CALL_OW 302
12085: AND
12086: IFFALSE 12102
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12088: LD_EXP 49
12092: PPUSH
12093: LD_STRING DArtefTechnology-Bur-2
12095: PPUSH
12096: CALL_OW 88
12100: GO 12114
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12102: LD_EXP 17
12106: PPUSH
12107: LD_STRING DArtefTechnology-JMM-2
12109: PPUSH
12110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12114: LD_VAR 0 1
12118: PUSH
12119: LD_INT 1
12121: ARRAY
12122: PPUSH
12123: LD_STRING DArtefTechnology-RSci1-3
12125: PPUSH
12126: CALL_OW 88
// if Denis then
12130: LD_EXP 23
12134: IFFALSE 12151
// speaker := [ Denis ] else
12136: LD_ADDR_VAR 0 1
12140: PUSH
12141: LD_EXP 23
12145: PUSH
12146: EMPTY
12147: LIST
12148: ST_TO_ADDR
12149: GO 12257
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12151: LD_ADDR_VAR 0 1
12155: PUSH
12156: LD_INT 22
12158: PUSH
12159: LD_INT 7
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PUSH
12166: LD_INT 23
12168: PUSH
12169: LD_INT 1
12171: PUSH
12172: EMPTY
12173: LIST
12174: LIST
12175: PUSH
12176: LD_INT 25
12178: PUSH
12179: LD_INT 4
12181: PUSH
12182: EMPTY
12183: LIST
12184: LIST
12185: PUSH
12186: LD_INT 21
12188: PUSH
12189: LD_INT 1
12191: PUSH
12192: EMPTY
12193: LIST
12194: LIST
12195: PUSH
12196: LD_INT 26
12198: PUSH
12199: LD_INT 1
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: LIST
12210: LIST
12211: LIST
12212: PPUSH
12213: CALL_OW 69
12217: PUSH
12218: LD_EXP 18
12222: PUSH
12223: LD_EXP 17
12227: PUSH
12228: LD_EXP 49
12232: PUSH
12233: LD_EXP 37
12237: PUSH
12238: LD_EXP 47
12242: PUSH
12243: LD_EXP 46
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: DIFF
12256: ST_TO_ADDR
// if speaker then
12257: LD_VAR 0 1
12261: IFFALSE 12303
// if alienSpotted then
12263: LD_EXP 10
12267: IFFALSE 12287
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12269: LD_VAR 0 1
12273: PUSH
12274: LD_INT 1
12276: ARRAY
12277: PPUSH
12278: LD_STRING DArtefTechnology-Sci1-3
12280: PPUSH
12281: CALL_OW 88
12285: GO 12303
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12287: LD_VAR 0 1
12291: PUSH
12292: LD_INT 1
12294: ARRAY
12295: PPUSH
12296: LD_STRING DArtefTechnology-Sci1-3a
12298: PPUSH
12299: CALL_OW 88
// end ; DialogueOff ;
12303: CALL_OW 7
// end ;
12307: PPOPN 1
12309: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12310: LD_EXP 12
12314: IFFALSE 12509
12316: GO 12318
12318: DISABLE
12319: LD_INT 0
12321: PPUSH
// begin if Denis then
12322: LD_EXP 23
12326: IFFALSE 12343
// speaker := [ Denis ] else
12328: LD_ADDR_VAR 0 1
12332: PUSH
12333: LD_EXP 23
12337: PUSH
12338: EMPTY
12339: LIST
12340: ST_TO_ADDR
12341: GO 12449
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12343: LD_ADDR_VAR 0 1
12347: PUSH
12348: LD_INT 22
12350: PUSH
12351: LD_INT 7
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_INT 23
12360: PUSH
12361: LD_INT 1
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: LD_INT 25
12370: PUSH
12371: LD_INT 4
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PUSH
12378: LD_INT 21
12380: PUSH
12381: LD_INT 1
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: PUSH
12388: LD_INT 26
12390: PUSH
12391: LD_INT 1
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: PPUSH
12405: CALL_OW 69
12409: PUSH
12410: LD_EXP 18
12414: PUSH
12415: LD_EXP 17
12419: PUSH
12420: LD_EXP 49
12424: PUSH
12425: LD_EXP 37
12429: PUSH
12430: LD_EXP 47
12434: PUSH
12435: LD_EXP 46
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: DIFF
12448: ST_TO_ADDR
// if not speaker then
12449: LD_VAR 0 1
12453: NOT
12454: IFFALSE 12458
// exit ;
12456: GO 12509
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12458: LD_VAR 0 1
12462: PUSH
12463: LD_INT 1
12465: ARRAY
12466: PPUSH
12467: LD_STRING DArtefTechnologyAm-Sci1-1
12469: PPUSH
12470: CALL_OW 88
// if IsOk ( Burlak ) then
12474: LD_EXP 49
12478: PPUSH
12479: CALL_OW 302
12483: IFFALSE 12497
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12485: LD_EXP 49
12489: PPUSH
12490: LD_STRING DArtefTechnologyAm-Bur-1
12492: PPUSH
12493: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12497: LD_EXP 17
12501: PPUSH
12502: LD_STRING DArtefTechnologyAm-JMM-1
12504: PPUSH
12505: CALL_OW 88
// end ;
12509: PPOPN 1
12511: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12512: LD_EXP 13
12516: IFFALSE 12706
12518: GO 12520
12520: DISABLE
12521: LD_INT 0
12523: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12524: LD_ADDR_VAR 0 1
12528: PUSH
12529: LD_INT 22
12531: PUSH
12532: LD_INT 7
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 23
12541: PUSH
12542: LD_INT 3
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 4
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 21
12561: PUSH
12562: LD_INT 1
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 26
12571: PUSH
12572: LD_INT 1
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: PPUSH
12586: CALL_OW 69
12590: PUSH
12591: LD_EXP 18
12595: PUSH
12596: LD_EXP 17
12600: PUSH
12601: LD_EXP 49
12605: PUSH
12606: LD_EXP 37
12610: PUSH
12611: LD_EXP 47
12615: PUSH
12616: LD_EXP 46
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: LIST
12625: LIST
12626: LIST
12627: LIST
12628: DIFF
12629: ST_TO_ADDR
// if not speaker then
12630: LD_VAR 0 1
12634: NOT
12635: IFFALSE 12639
// exit ;
12637: GO 12706
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12639: LD_VAR 0 1
12643: PUSH
12644: LD_INT 1
12646: ARRAY
12647: PPUSH
12648: LD_STRING DArtefTechnologyRu-RSci1-1
12650: PPUSH
12651: CALL_OW 88
// if IsOk ( Burlak ) then
12655: LD_EXP 49
12659: PPUSH
12660: CALL_OW 302
12664: IFFALSE 12678
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12666: LD_EXP 49
12670: PPUSH
12671: LD_STRING DArtefTechnologyRu-Bur-1
12673: PPUSH
12674: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12678: LD_VAR 0 1
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_STRING DArtefTechnologyRu-RSci1-2
12689: PPUSH
12690: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12694: LD_EXP 17
12698: PPUSH
12699: LD_STRING DArtefTechnologyRu-JMM-1
12701: PPUSH
12702: CALL_OW 88
// end ;
12706: PPOPN 1
12708: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12709: LD_INT 24
12711: PPUSH
12712: LD_INT 7
12714: PPUSH
12715: CALL_OW 321
12719: PUSH
12720: LD_INT 2
12722: EQUAL
12723: PUSH
12724: LD_INT 1
12726: PPUSH
12727: CALL_OW 255
12731: PUSH
12732: LD_INT 7
12734: EQUAL
12735: AND
12736: IFFALSE 12896
12738: GO 12740
12740: DISABLE
12741: LD_INT 0
12743: PPUSH
// begin if Denis then
12744: LD_EXP 23
12748: IFFALSE 12765
// speaker := [ Denis ] else
12750: LD_ADDR_VAR 0 1
12754: PUSH
12755: LD_EXP 23
12759: PUSH
12760: EMPTY
12761: LIST
12762: ST_TO_ADDR
12763: GO 12871
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12765: LD_ADDR_VAR 0 1
12769: PUSH
12770: LD_INT 22
12772: PUSH
12773: LD_INT 7
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: LD_INT 23
12782: PUSH
12783: LD_INT 1
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 25
12792: PUSH
12793: LD_INT 4
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 21
12802: PUSH
12803: LD_INT 1
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 26
12812: PUSH
12813: LD_INT 1
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: PPUSH
12827: CALL_OW 69
12831: PUSH
12832: LD_EXP 18
12836: PUSH
12837: LD_EXP 17
12841: PUSH
12842: LD_EXP 49
12846: PUSH
12847: LD_EXP 37
12851: PUSH
12852: LD_EXP 47
12856: PUSH
12857: LD_EXP 46
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: DIFF
12870: ST_TO_ADDR
// if not speaker then
12871: LD_VAR 0 1
12875: NOT
12876: IFFALSE 12880
// exit ;
12878: GO 12896
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12880: LD_VAR 0 1
12884: PUSH
12885: LD_INT 1
12887: ARRAY
12888: PPUSH
12889: LD_STRING DArtefTechnologyArStart-Sci1-1
12891: PPUSH
12892: CALL_OW 88
// end ;
12896: PPOPN 1
12898: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12899: LD_EXP 14
12903: IFFALSE 13184
12905: GO 12907
12907: DISABLE
12908: LD_INT 0
12910: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12911: LD_ADDR_VAR 0 1
12915: PUSH
12916: LD_INT 22
12918: PUSH
12919: LD_INT 7
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 23
12928: PUSH
12929: LD_INT 3
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: PUSH
12936: LD_INT 25
12938: PUSH
12939: LD_INT 4
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 21
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: LD_INT 26
12958: PUSH
12959: LD_INT 1
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PPUSH
12973: CALL_OW 69
12977: PUSH
12978: LD_EXP 18
12982: PUSH
12983: LD_EXP 17
12987: PUSH
12988: LD_EXP 49
12992: PUSH
12993: LD_EXP 37
12997: PUSH
12998: LD_EXP 47
13002: PUSH
13003: LD_EXP 46
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: DIFF
13016: ST_TO_ADDR
// if not speaker then
13017: LD_VAR 0 1
13021: NOT
13022: IFFALSE 13026
// exit ;
13024: GO 13184
// DialogueOn ;
13026: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13030: LD_VAR 0 1
13034: PUSH
13035: LD_INT 1
13037: ARRAY
13038: PPUSH
13039: LD_STRING DArtefTechnologyAr-RSci1-1
13041: PPUSH
13042: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13046: LD_EXP 17
13050: PPUSH
13051: LD_STRING DArtefTechnologyAr-JMM-1
13053: PPUSH
13054: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13058: LD_VAR 0 1
13062: PUSH
13063: LD_INT 1
13065: ARRAY
13066: PPUSH
13067: LD_STRING DArtefTechnologyAr-RSci1-2
13069: PPUSH
13070: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13074: LD_EXP 17
13078: PPUSH
13079: LD_STRING DArtefTechnologyAr-JMM-2
13081: PPUSH
13082: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13086: LD_VAR 0 1
13090: PUSH
13091: LD_INT 1
13093: ARRAY
13094: PPUSH
13095: LD_STRING DArtefTechnologyAr-RSci1-3
13097: PPUSH
13098: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13102: LD_EXP 17
13106: PPUSH
13107: LD_STRING DArtefTechnologyAr-JMM-3
13109: PPUSH
13110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13114: LD_VAR 0 1
13118: PUSH
13119: LD_INT 1
13121: ARRAY
13122: PPUSH
13123: LD_STRING DArtefTechnologyAr-RSci1-4
13125: PPUSH
13126: CALL_OW 88
// if IsOk ( Burlak ) then
13130: LD_EXP 49
13134: PPUSH
13135: CALL_OW 302
13139: IFFALSE 13153
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13141: LD_EXP 49
13145: PPUSH
13146: LD_STRING DArtefTechnologyAr-Bur-4
13148: PPUSH
13149: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13153: LD_EXP 17
13157: PPUSH
13158: LD_STRING DArtefTechnologyAr-JMM-4
13160: PPUSH
13161: CALL_OW 88
// DialogueOff ;
13165: CALL_OW 7
// wait ( 0 0$45 ) ;
13169: LD_INT 1575
13171: PPUSH
13172: CALL_OW 67
// spawnOmar := true ;
13176: LD_ADDR_EXP 11
13180: PUSH
13181: LD_INT 1
13183: ST_TO_ADDR
// end ;
13184: PPOPN 1
13186: END
// every 0 0$1 trigger spawnOmar do
13187: LD_EXP 11
13191: IFFALSE 13571
13193: GO 13195
13195: DISABLE
// begin PrepareOmarAli ;
13196: CALL 6705 0 0
// if not HasTask ( Omar ) then
13200: LD_EXP 53
13204: PPUSH
13205: CALL_OW 314
13209: NOT
13210: IFFALSE 13227
// ComMoveXY ( Omar , 252 , 220 ) ;
13212: LD_EXP 53
13216: PPUSH
13217: LD_INT 252
13219: PPUSH
13220: LD_INT 220
13222: PPUSH
13223: CALL_OW 111
// if not Omar then
13227: LD_EXP 53
13231: NOT
13232: IFFALSE 13236
// exit ;
13234: GO 13571
// repeat wait ( 0 0$1 ) ;
13236: LD_INT 35
13238: PPUSH
13239: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13243: LD_EXP 53
13247: PPUSH
13248: CALL_OW 314
13252: NOT
13253: PUSH
13254: LD_EXP 53
13258: PPUSH
13259: LD_INT 252
13261: PPUSH
13262: LD_INT 220
13264: PPUSH
13265: CALL_OW 297
13269: PUSH
13270: LD_INT 6
13272: GREATER
13273: AND
13274: IFFALSE 13291
// ComMoveXY ( Omar , 252 , 220 ) ;
13276: LD_EXP 53
13280: PPUSH
13281: LD_INT 252
13283: PPUSH
13284: LD_INT 220
13286: PPUSH
13287: CALL_OW 111
// until See ( 7 , Omar ) ;
13291: LD_INT 7
13293: PPUSH
13294: LD_EXP 53
13298: PPUSH
13299: CALL_OW 292
13303: IFFALSE 13236
// CenterNowOnUnits ( Omar ) ;
13305: LD_EXP 53
13309: PPUSH
13310: CALL_OW 87
// DialogueOn ;
13314: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13318: LD_EXP 53
13322: PPUSH
13323: LD_STRING DOmar-Omar-1
13325: PPUSH
13326: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13330: LD_EXP 17
13334: PPUSH
13335: LD_STRING DOmar-JMM-1
13337: PPUSH
13338: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13342: LD_EXP 53
13346: PPUSH
13347: LD_STRING DOmar-Omar-2
13349: PPUSH
13350: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13354: LD_EXP 17
13358: PPUSH
13359: LD_STRING DOmar-JMM-2
13361: PPUSH
13362: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13366: LD_EXP 53
13370: PPUSH
13371: LD_STRING DOmar-Omar-3
13373: PPUSH
13374: CALL_OW 88
// if IsOk ( Burlak ) then
13378: LD_EXP 49
13382: PPUSH
13383: CALL_OW 302
13387: IFFALSE 13403
// Say ( Burlak , DOmar-Bur-3 ) else
13389: LD_EXP 49
13393: PPUSH
13394: LD_STRING DOmar-Bur-3
13396: PPUSH
13397: CALL_OW 88
13401: GO 13415
// Say ( JMM , DOmar-JMM-3 ) ;
13403: LD_EXP 17
13407: PPUSH
13408: LD_STRING DOmar-JMM-3
13410: PPUSH
13411: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13415: LD_EXP 53
13419: PPUSH
13420: LD_STRING DOmar-Omar-4
13422: PPUSH
13423: CALL_OW 88
// case Query ( QAccept ) of 1 :
13427: LD_STRING QAccept
13429: PPUSH
13430: CALL_OW 97
13434: PUSH
13435: LD_INT 1
13437: DOUBLE
13438: EQUAL
13439: IFTRUE 13443
13441: GO 13479
13443: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13444: LD_EXP 17
13448: PPUSH
13449: LD_STRING DQrAccept#1-JMM-1
13451: PPUSH
13452: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13456: LD_EXP 53
13460: PPUSH
13461: LD_INT 7
13463: PPUSH
13464: CALL_OW 235
// ComStop ( Omar ) ;
13468: LD_EXP 53
13472: PPUSH
13473: CALL_OW 141
// end ; 2 :
13477: GO 13528
13479: LD_INT 2
13481: DOUBLE
13482: EQUAL
13483: IFTRUE 13487
13485: GO 13527
13487: POP
// begin if IsOk ( Burlak ) then
13488: LD_EXP 49
13492: PPUSH
13493: CALL_OW 302
13497: IFFALSE 13513
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13499: LD_EXP 49
13503: PPUSH
13504: LD_STRING DQrAccept#2-Bur-1
13506: PPUSH
13507: CALL_OW 88
13511: GO 13525
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13513: LD_EXP 17
13517: PPUSH
13518: LD_STRING DQrAccept#2-JMM-1
13520: PPUSH
13521: CALL_OW 88
// end ; end ;
13525: GO 13528
13527: POP
// DialogueOff ;
13528: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13532: LD_EXP 53
13536: PPUSH
13537: CALL_OW 255
13541: PUSH
13542: LD_INT 7
13544: EQUAL
13545: IFFALSE 13556
// begin SetAchievement ( ACH_OMAR ) ;
13547: LD_STRING ACH_OMAR
13549: PPUSH
13550: CALL_OW 543
// exit ;
13554: GO 13571
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13556: LD_EXP 53
13560: PPUSH
13561: LD_INT 202
13563: PPUSH
13564: LD_INT 115
13566: PPUSH
13567: CALL_OW 111
// end ;
13571: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13572: LD_EXP 53
13576: PPUSH
13577: LD_INT 200
13579: PPUSH
13580: LD_INT 98
13582: PPUSH
13583: CALL_OW 297
13587: PUSH
13588: LD_INT 40
13590: LESS
13591: PUSH
13592: LD_EXP 2
13596: AND
13597: IFFALSE 13815
13599: GO 13601
13601: DISABLE
// begin SetSide ( Omar , 5 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 5
13609: PPUSH
13610: CALL_OW 235
// if IsInUnit ( Omar ) then
13614: LD_EXP 53
13618: PPUSH
13619: CALL_OW 310
13623: IFFALSE 13634
// ComExitVehicle ( Omar ) ;
13625: LD_EXP 53
13629: PPUSH
13630: CALL_OW 121
// if IsInUnit ( Omar ) then
13634: LD_EXP 53
13638: PPUSH
13639: CALL_OW 310
13643: IFFALSE 13654
// ComExitBuilding ( Omar ) ;
13645: LD_EXP 53
13649: PPUSH
13650: CALL_OW 122
// wait ( 0 0$1 ) ;
13654: LD_INT 35
13656: PPUSH
13657: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13661: LD_EXP 53
13665: PPUSH
13666: LD_INT 203
13668: PPUSH
13669: LD_INT 120
13671: PPUSH
13672: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13676: LD_INT 35
13678: PPUSH
13679: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13683: LD_EXP 53
13687: PPUSH
13688: CALL_OW 306
13692: PUSH
13693: LD_EXP 53
13697: PPUSH
13698: LD_INT 203
13700: PPUSH
13701: LD_INT 120
13703: PPUSH
13704: CALL_OW 297
13708: PUSH
13709: LD_INT 6
13711: LESS
13712: OR
13713: IFFALSE 13676
// CenterNowOnUnits ( Omar ) ;
13715: LD_EXP 53
13719: PPUSH
13720: CALL_OW 87
// DialogueOn ;
13724: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13728: LD_EXP 17
13732: PPUSH
13733: LD_STRING DOmarContam-JMM-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13740: LD_EXP 53
13744: PPUSH
13745: LD_STRING DOmarContam-Omar-1
13747: PPUSH
13748: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13752: LD_EXP 17
13756: PPUSH
13757: LD_STRING DOmarContam-JMM-2
13759: PPUSH
13760: CALL_OW 88
// DialogueOff ;
13764: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13768: LD_INT 5
13770: PPUSH
13771: LD_INT 7
13773: PPUSH
13774: LD_INT 2
13776: PPUSH
13777: LD_INT 1
13779: PPUSH
13780: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13784: LD_INT 105
13786: PPUSH
13787: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13791: LD_EXP 53
13795: PPUSH
13796: LD_INT 203
13798: PPUSH
13799: LD_INT 120
13801: PPUSH
13802: CALL_OW 307
13806: IFFALSE 13784
// YouLost ( MothContaminate ) ;
13808: LD_STRING MothContaminate
13810: PPUSH
13811: CALL_OW 104
// end ;
13815: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13816: LD_EXP 4
13820: NOT
13821: PUSH
13822: LD_INT 22
13824: PUSH
13825: LD_INT 1
13827: PUSH
13828: EMPTY
13829: LIST
13830: LIST
13831: PUSH
13832: LD_INT 34
13834: PUSH
13835: LD_INT 8
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: PPUSH
13846: CALL_OW 69
13850: AND
13851: IFFALSE 13970
13853: GO 13855
13855: DISABLE
// begin wait ( 0 0$5 ) ;
13856: LD_INT 175
13858: PPUSH
13859: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13863: LD_EXP 52
13867: PPUSH
13868: CALL_OW 302
13872: NOT
13873: PUSH
13874: LD_INT 22
13876: PUSH
13877: LD_INT 1
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: PUSH
13884: LD_INT 34
13886: PUSH
13887: LD_INT 8
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: PUSH
13894: EMPTY
13895: LIST
13896: LIST
13897: PPUSH
13898: CALL_OW 69
13902: NOT
13903: OR
13904: IFFALSE 13908
// exit ;
13906: GO 13970
// DialogueOn ;
13908: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13912: LD_EXP 52
13916: PPUSH
13917: LD_STRING DWinAmericans-Pow-1
13919: PPUSH
13920: CALL_OW 94
// if IsOk ( Burlak ) then
13924: LD_EXP 49
13928: PPUSH
13929: CALL_OW 302
13933: IFFALSE 13947
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13935: LD_EXP 49
13939: PPUSH
13940: LD_STRING DWinAmericans-Bur-1
13942: PPUSH
13943: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13947: LD_EXP 17
13951: PPUSH
13952: LD_STRING DWinAmericans-JMM-1
13954: PPUSH
13955: CALL_OW 88
// DialogueOff ;
13959: CALL_OW 7
// YouLost ( AmBomb ) ;
13963: LD_STRING AmBomb
13965: PPUSH
13966: CALL_OW 104
// end ;
13970: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13971: LD_EXP 2
13975: NOT
13976: PUSH
13977: LD_INT 22
13979: PUSH
13980: LD_INT 3
13982: PUSH
13983: EMPTY
13984: LIST
13985: LIST
13986: PUSH
13987: LD_INT 34
13989: PUSH
13990: LD_INT 48
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: PUSH
13997: EMPTY
13998: LIST
13999: LIST
14000: PPUSH
14001: CALL_OW 69
14005: AND
14006: IFFALSE 14125
14008: GO 14010
14010: DISABLE
// begin wait ( 0 0$5 ) ;
14011: LD_INT 175
14013: PPUSH
14014: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14018: LD_EXP 56
14022: PPUSH
14023: CALL_OW 302
14027: NOT
14028: PUSH
14029: LD_INT 22
14031: PUSH
14032: LD_INT 3
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: LD_INT 34
14041: PUSH
14042: LD_INT 48
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: PPUSH
14053: CALL_OW 69
14057: NOT
14058: OR
14059: IFFALSE 14063
// exit ;
14061: GO 14125
// DialogueOn ;
14063: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14067: LD_EXP 56
14071: PPUSH
14072: LD_STRING DWinRussians-Pla-1
14074: PPUSH
14075: CALL_OW 94
// if IsOk ( Burlak ) then
14079: LD_EXP 49
14083: PPUSH
14084: CALL_OW 302
14088: IFFALSE 14102
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14090: LD_EXP 49
14094: PPUSH
14095: LD_STRING DWinRussians-Bur-1
14097: PPUSH
14098: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14102: LD_EXP 17
14106: PPUSH
14107: LD_STRING DWinRussians-JMM-1
14109: PPUSH
14110: CALL_OW 88
// DialogueOff ;
14114: CALL_OW 7
// YouLost ( RuBomb ) ;
14118: LD_STRING RuBomb
14120: PPUSH
14121: CALL_OW 104
// end ;
14125: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14126: LD_INT 7
14128: PPUSH
14129: LD_INT 22
14131: PUSH
14132: LD_INT 7
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: PPUSH
14139: CALL_OW 70
14143: PUSH
14144: LD_EXP 4
14148: NOT
14149: AND
14150: IFFALSE 14179
14152: GO 14154
14154: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14155: LD_EXP 52
14159: PPUSH
14160: LD_STRING DSurrenderAmericans-Pow-1
14162: PPUSH
14163: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14167: LD_EXP 17
14171: PPUSH
14172: LD_STRING DSurrenderAmericans-JMM-1
14174: PPUSH
14175: CALL_OW 88
// end ;
14179: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14180: LD_INT 2
14182: PPUSH
14183: LD_INT 22
14185: PUSH
14186: LD_INT 7
14188: PUSH
14189: EMPTY
14190: LIST
14191: LIST
14192: PPUSH
14193: CALL_OW 70
14197: PUSH
14198: LD_EXP 2
14202: NOT
14203: AND
14204: PUSH
14205: LD_EXP 49
14209: AND
14210: IFFALSE 14239
14212: GO 14214
14214: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14215: LD_EXP 56
14219: PPUSH
14220: LD_STRING DSurrenderRussians-Pla-1
14222: PPUSH
14223: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14227: LD_EXP 49
14231: PPUSH
14232: LD_STRING DSurrenderRussians-Bur-1
14234: PPUSH
14235: CALL_OW 88
// end ;
14239: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14240: LD_EXP 4
14244: IFFALSE 14627
14246: GO 14248
14248: DISABLE
14249: LD_INT 0
14251: PPUSH
14252: PPUSH
14253: PPUSH
// begin MC_Kill ( 4 ) ;
14254: LD_INT 4
14256: PPUSH
14257: CALL 20959 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14261: LD_INT 1
14263: PPUSH
14264: LD_INT 7
14266: PPUSH
14267: LD_INT 1
14269: PPUSH
14270: LD_INT 1
14272: PPUSH
14273: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14277: LD_ADDR_VAR 0 3
14281: PUSH
14282: LD_INT 22
14284: PUSH
14285: LD_INT 1
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: PUSH
14292: LD_INT 26
14294: PUSH
14295: LD_INT 1
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: PUSH
14302: LD_INT 23
14304: PUSH
14305: LD_INT 1
14307: PUSH
14308: EMPTY
14309: LIST
14310: LIST
14311: PUSH
14312: EMPTY
14313: LIST
14314: LIST
14315: LIST
14316: PPUSH
14317: CALL_OW 69
14321: PUSH
14322: LD_EXP 52
14326: PUSH
14327: LD_EXP 25
14331: PUSH
14332: LD_EXP 22
14336: PUSH
14337: LD_EXP 21
14341: PUSH
14342: LD_EXP 28
14346: PUSH
14347: LD_EXP 26
14351: PUSH
14352: EMPTY
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: DIFF
14360: ST_TO_ADDR
// if speaker then
14361: LD_VAR 0 3
14365: IFFALSE 14391
// begin DialogueOn ;
14367: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14371: LD_VAR 0 3
14375: PUSH
14376: LD_INT 1
14378: ARRAY
14379: PPUSH
14380: LD_STRING DSurrenderAmericans-Sol1-1a
14382: PPUSH
14383: CALL_OW 94
// DialogueOff ;
14387: CALL_OW 7
// end ; americanCapitulated := true ;
14391: LD_ADDR_EXP 6
14395: PUSH
14396: LD_INT 1
14398: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14399: LD_ADDR_VAR 0 2
14403: PUSH
14404: LD_INT 22
14406: PUSH
14407: LD_INT 1
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PUSH
14414: LD_INT 21
14416: PUSH
14417: LD_INT 1
14419: PUSH
14420: EMPTY
14421: LIST
14422: LIST
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PPUSH
14428: CALL_OW 69
14432: PUSH
14433: LD_INT 22
14435: PUSH
14436: LD_INT 1
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PUSH
14443: LD_INT 21
14445: PUSH
14446: LD_INT 2
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: EMPTY
14457: LIST
14458: PUSH
14459: EMPTY
14460: LIST
14461: LIST
14462: LIST
14463: PPUSH
14464: CALL_OW 69
14468: ADD
14469: ST_TO_ADDR
// if tmp then
14470: LD_VAR 0 2
14474: IFFALSE 14627
// repeat wait ( 0 0$1 ) ;
14476: LD_INT 35
14478: PPUSH
14479: CALL_OW 67
// for i in tmp do
14483: LD_ADDR_VAR 0 1
14487: PUSH
14488: LD_VAR 0 2
14492: PUSH
14493: FOR_IN
14494: IFFALSE 14576
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14496: LD_VAR 0 1
14500: PPUSH
14501: CALL_OW 310
14505: PUSH
14506: LD_VAR 0 1
14510: PPUSH
14511: CALL_OW 310
14515: PPUSH
14516: CALL_OW 247
14520: PUSH
14521: LD_INT 3
14523: EQUAL
14524: AND
14525: IFFALSE 14536
// ComExitBuilding ( i ) ;
14527: LD_VAR 0 1
14531: PPUSH
14532: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14536: LD_VAR 0 1
14540: PPUSH
14541: LD_INT 122
14543: PPUSH
14544: LD_INT 242
14546: PPUSH
14547: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14551: LD_VAR 0 1
14555: PPUSH
14556: LD_INT 35
14558: PPUSH
14559: CALL_OW 308
14563: IFFALSE 14574
// RemoveUnit ( i ) ;
14565: LD_VAR 0 1
14569: PPUSH
14570: CALL_OW 64
// end ;
14574: GO 14493
14576: POP
14577: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14578: LD_INT 22
14580: PUSH
14581: LD_INT 1
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: PUSH
14588: LD_INT 2
14590: PUSH
14591: LD_INT 21
14593: PUSH
14594: LD_INT 1
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PUSH
14601: LD_INT 33
14603: PUSH
14604: LD_INT 1
14606: PUSH
14607: EMPTY
14608: LIST
14609: LIST
14610: PUSH
14611: EMPTY
14612: LIST
14613: LIST
14614: LIST
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: PPUSH
14620: CALL_OW 69
14624: NOT
14625: IFFALSE 14476
// end ;
14627: PPOPN 3
14629: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14630: LD_EXP 2
14634: IFFALSE 15035
14636: GO 14638
14638: DISABLE
14639: LD_INT 0
14641: PPUSH
14642: PPUSH
14643: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14644: LD_INT 35
14646: PPUSH
14647: CALL_OW 67
// until IsDead ( Yakotich ) ;
14651: LD_EXP 57
14655: PPUSH
14656: CALL_OW 301
14660: IFFALSE 14644
// MC_Kill ( 2 ) ;
14662: LD_INT 2
14664: PPUSH
14665: CALL 20959 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14669: LD_INT 3
14671: PPUSH
14672: LD_INT 7
14674: PPUSH
14675: LD_INT 1
14677: PPUSH
14678: LD_INT 1
14680: PPUSH
14681: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14685: LD_ADDR_VAR 0 3
14689: PUSH
14690: LD_INT 22
14692: PUSH
14693: LD_INT 3
14695: PUSH
14696: EMPTY
14697: LIST
14698: LIST
14699: PUSH
14700: LD_INT 26
14702: PUSH
14703: LD_INT 1
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PUSH
14710: LD_INT 23
14712: PUSH
14713: LD_INT 3
14715: PUSH
14716: EMPTY
14717: LIST
14718: LIST
14719: PUSH
14720: EMPTY
14721: LIST
14722: LIST
14723: LIST
14724: PPUSH
14725: CALL_OW 69
14729: PUSH
14730: LD_EXP 56
14734: PUSH
14735: LD_EXP 57
14739: PUSH
14740: EMPTY
14741: LIST
14742: LIST
14743: DIFF
14744: ST_TO_ADDR
// if speaker then
14745: LD_VAR 0 3
14749: IFFALSE 14799
// begin DialogueOn ;
14751: CALL_OW 6
// if Burlak then
14755: LD_EXP 49
14759: IFFALSE 14779
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14761: LD_VAR 0 3
14765: PUSH
14766: LD_INT 1
14768: ARRAY
14769: PPUSH
14770: LD_STRING DSurrenderRussians-RSol1-1
14772: PPUSH
14773: CALL_OW 94
14777: GO 14795
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14779: LD_VAR 0 3
14783: PUSH
14784: LD_INT 1
14786: ARRAY
14787: PPUSH
14788: LD_STRING DSurrenderRussians-RSol1-1a
14790: PPUSH
14791: CALL_OW 94
// DialogueOff ;
14795: CALL_OW 7
// end ; russianCapitulated := true ;
14799: LD_ADDR_EXP 7
14803: PUSH
14804: LD_INT 1
14806: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14807: LD_ADDR_VAR 0 2
14811: PUSH
14812: LD_INT 22
14814: PUSH
14815: LD_INT 3
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PUSH
14822: LD_INT 21
14824: PUSH
14825: LD_INT 1
14827: PUSH
14828: EMPTY
14829: LIST
14830: LIST
14831: PUSH
14832: EMPTY
14833: LIST
14834: LIST
14835: PPUSH
14836: CALL_OW 69
14840: PUSH
14841: LD_INT 22
14843: PUSH
14844: LD_INT 3
14846: PUSH
14847: EMPTY
14848: LIST
14849: LIST
14850: PUSH
14851: LD_INT 21
14853: PUSH
14854: LD_INT 2
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: PUSH
14861: LD_INT 1
14863: PUSH
14864: EMPTY
14865: LIST
14866: PUSH
14867: EMPTY
14868: LIST
14869: LIST
14870: LIST
14871: PPUSH
14872: CALL_OW 69
14876: ADD
14877: ST_TO_ADDR
// if tmp then
14878: LD_VAR 0 2
14882: IFFALSE 15035
// repeat wait ( 0 0$1 ) ;
14884: LD_INT 35
14886: PPUSH
14887: CALL_OW 67
// for i in tmp do
14891: LD_ADDR_VAR 0 1
14895: PUSH
14896: LD_VAR 0 2
14900: PUSH
14901: FOR_IN
14902: IFFALSE 14984
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14904: LD_VAR 0 1
14908: PPUSH
14909: CALL_OW 310
14913: PUSH
14914: LD_VAR 0 1
14918: PPUSH
14919: CALL_OW 310
14923: PPUSH
14924: CALL_OW 247
14928: PUSH
14929: LD_INT 3
14931: EQUAL
14932: AND
14933: IFFALSE 14944
// ComExitBuilding ( i ) ;
14935: LD_VAR 0 1
14939: PPUSH
14940: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14944: LD_VAR 0 1
14948: PPUSH
14949: LD_INT 154
14951: PPUSH
14952: LD_INT 1
14954: PPUSH
14955: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14959: LD_VAR 0 1
14963: PPUSH
14964: LD_INT 36
14966: PPUSH
14967: CALL_OW 308
14971: IFFALSE 14982
// RemoveUnit ( i ) ;
14973: LD_VAR 0 1
14977: PPUSH
14978: CALL_OW 64
// end ;
14982: GO 14901
14984: POP
14985: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14986: LD_INT 22
14988: PUSH
14989: LD_INT 3
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: PUSH
14996: LD_INT 2
14998: PUSH
14999: LD_INT 21
15001: PUSH
15002: LD_INT 1
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: PUSH
15009: LD_INT 33
15011: PUSH
15012: LD_INT 1
15014: PUSH
15015: EMPTY
15016: LIST
15017: LIST
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: LIST
15023: PUSH
15024: EMPTY
15025: LIST
15026: LIST
15027: PPUSH
15028: CALL_OW 69
15032: NOT
15033: IFFALSE 14884
// end ;
15035: PPOPN 3
15037: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15038: LD_INT 22
15040: PUSH
15041: LD_INT 8
15043: PUSH
15044: EMPTY
15045: LIST
15046: LIST
15047: PUSH
15048: LD_INT 21
15050: PUSH
15051: LD_INT 1
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: PUSH
15058: LD_INT 23
15060: PUSH
15061: LD_INT 2
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: LIST
15072: PPUSH
15073: CALL_OW 69
15077: PUSH
15078: LD_INT 18
15080: LESS
15081: PUSH
15082: LD_EXP 55
15086: PPUSH
15087: CALL_OW 301
15091: OR
15092: PUSH
15093: LD_INT 324
15095: PPUSH
15096: CALL_OW 255
15100: PUSH
15101: LD_INT 7
15103: EQUAL
15104: OR
15105: IFFALSE 15118
15107: GO 15109
15109: DISABLE
// legionDestroyed := true ;
15110: LD_ADDR_EXP 3
15114: PUSH
15115: LD_INT 1
15117: ST_TO_ADDR
15118: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15119: LD_INT 22
15121: PUSH
15122: LD_INT 2
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: PUSH
15129: LD_INT 21
15131: PUSH
15132: LD_INT 1
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: PUSH
15139: LD_INT 23
15141: PUSH
15142: LD_INT 2
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PUSH
15149: EMPTY
15150: LIST
15151: LIST
15152: LIST
15153: PPUSH
15154: CALL_OW 69
15158: PUSH
15159: LD_INT 9
15161: LESS
15162: IFFALSE 15175
15164: GO 15166
15166: DISABLE
// arabianDestroyed := true ;
15167: LD_ADDR_EXP 5
15171: PUSH
15172: LD_INT 1
15174: ST_TO_ADDR
15175: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15176: LD_EXP 5
15180: IFFALSE 15424
15182: GO 15184
15184: DISABLE
15185: LD_INT 0
15187: PPUSH
15188: PPUSH
// begin MC_Kill ( 1 ) ;
15189: LD_INT 1
15191: PPUSH
15192: CALL 20959 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15196: LD_ADDR_VAR 0 2
15200: PUSH
15201: LD_INT 22
15203: PUSH
15204: LD_INT 2
15206: PUSH
15207: EMPTY
15208: LIST
15209: LIST
15210: PUSH
15211: LD_INT 21
15213: PUSH
15214: LD_INT 1
15216: PUSH
15217: EMPTY
15218: LIST
15219: LIST
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: PPUSH
15225: CALL_OW 69
15229: PUSH
15230: LD_INT 22
15232: PUSH
15233: LD_INT 8
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PUSH
15240: LD_INT 21
15242: PUSH
15243: LD_INT 2
15245: PUSH
15246: EMPTY
15247: LIST
15248: LIST
15249: PUSH
15250: LD_INT 1
15252: PUSH
15253: EMPTY
15254: LIST
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: LIST
15260: PPUSH
15261: CALL_OW 69
15265: ADD
15266: ST_TO_ADDR
// if tmp then
15267: LD_VAR 0 2
15271: IFFALSE 15424
// repeat wait ( 0 0$1 ) ;
15273: LD_INT 35
15275: PPUSH
15276: CALL_OW 67
// for i in tmp do
15280: LD_ADDR_VAR 0 1
15284: PUSH
15285: LD_VAR 0 2
15289: PUSH
15290: FOR_IN
15291: IFFALSE 15373
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15293: LD_VAR 0 1
15297: PPUSH
15298: CALL_OW 310
15302: PUSH
15303: LD_VAR 0 1
15307: PPUSH
15308: CALL_OW 310
15312: PPUSH
15313: CALL_OW 247
15317: PUSH
15318: LD_INT 3
15320: EQUAL
15321: AND
15322: IFFALSE 15333
// ComExitBuilding ( i ) ;
15324: LD_VAR 0 1
15328: PPUSH
15329: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15333: LD_VAR 0 1
15337: PPUSH
15338: LD_INT 254
15340: PPUSH
15341: LD_INT 268
15343: PPUSH
15344: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15348: LD_VAR 0 1
15352: PPUSH
15353: LD_INT 34
15355: PPUSH
15356: CALL_OW 308
15360: IFFALSE 15371
// RemoveUnit ( i ) ;
15362: LD_VAR 0 1
15366: PPUSH
15367: CALL_OW 64
// end ;
15371: GO 15290
15373: POP
15374: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15375: LD_INT 22
15377: PUSH
15378: LD_INT 2
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PUSH
15385: LD_INT 2
15387: PUSH
15388: LD_INT 21
15390: PUSH
15391: LD_INT 1
15393: PUSH
15394: EMPTY
15395: LIST
15396: LIST
15397: PUSH
15398: LD_INT 33
15400: PUSH
15401: LD_INT 1
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PUSH
15408: EMPTY
15409: LIST
15410: LIST
15411: LIST
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: PPUSH
15417: CALL_OW 69
15421: NOT
15422: IFFALSE 15273
// end ;
15424: PPOPN 2
15426: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15427: LD_EXP 3
15431: IFFALSE 15783
15433: GO 15435
15435: DISABLE
15436: LD_INT 0
15438: PPUSH
15439: PPUSH
// begin MC_Kill ( 3 ) ;
15440: LD_INT 3
15442: PPUSH
15443: CALL 20959 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15447: LD_INT 8
15449: PPUSH
15450: LD_INT 7
15452: PPUSH
15453: LD_INT 1
15455: PPUSH
15456: LD_INT 1
15458: PPUSH
15459: CALL_OW 80
// DialogueOn ;
15463: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15467: LD_EXP 54
15471: PPUSH
15472: LD_STRING D15-Szulc-1
15474: PPUSH
15475: CALL_OW 94
// DialogueOff ;
15479: CALL_OW 7
// legionCapitulated := true ;
15483: LD_ADDR_EXP 8
15487: PUSH
15488: LD_INT 1
15490: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15491: LD_ADDR_VAR 0 1
15495: PUSH
15496: LD_INT 22
15498: PUSH
15499: LD_INT 8
15501: PUSH
15502: EMPTY
15503: LIST
15504: LIST
15505: PUSH
15506: LD_INT 21
15508: PUSH
15509: LD_INT 3
15511: PUSH
15512: EMPTY
15513: LIST
15514: LIST
15515: PUSH
15516: LD_INT 23
15518: PUSH
15519: LD_INT 3
15521: PUSH
15522: EMPTY
15523: LIST
15524: LIST
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: LIST
15530: PPUSH
15531: CALL_OW 69
15535: PUSH
15536: FOR_IN
15537: IFFALSE 15553
// SetLives ( i , 3 ) ;
15539: LD_VAR 0 1
15543: PPUSH
15544: LD_INT 3
15546: PPUSH
15547: CALL_OW 234
15551: GO 15536
15553: POP
15554: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15555: LD_ADDR_VAR 0 2
15559: PUSH
15560: LD_INT 22
15562: PUSH
15563: LD_INT 8
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: PUSH
15570: LD_INT 21
15572: PUSH
15573: LD_INT 1
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: PUSH
15580: EMPTY
15581: LIST
15582: LIST
15583: PPUSH
15584: CALL_OW 69
15588: PUSH
15589: LD_INT 22
15591: PUSH
15592: LD_INT 8
15594: PUSH
15595: EMPTY
15596: LIST
15597: LIST
15598: PUSH
15599: LD_INT 21
15601: PUSH
15602: LD_INT 2
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: PUSH
15609: LD_INT 1
15611: PUSH
15612: EMPTY
15613: LIST
15614: PUSH
15615: EMPTY
15616: LIST
15617: LIST
15618: LIST
15619: PPUSH
15620: CALL_OW 69
15624: ADD
15625: ST_TO_ADDR
// if tmp then
15626: LD_VAR 0 2
15630: IFFALSE 15783
// repeat wait ( 0 0$1 ) ;
15632: LD_INT 35
15634: PPUSH
15635: CALL_OW 67
// for i in tmp do
15639: LD_ADDR_VAR 0 1
15643: PUSH
15644: LD_VAR 0 2
15648: PUSH
15649: FOR_IN
15650: IFFALSE 15732
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15652: LD_VAR 0 1
15656: PPUSH
15657: CALL_OW 310
15661: PUSH
15662: LD_VAR 0 1
15666: PPUSH
15667: CALL_OW 310
15671: PPUSH
15672: CALL_OW 247
15676: PUSH
15677: LD_INT 3
15679: EQUAL
15680: AND
15681: IFFALSE 15692
// ComExitBuilding ( i ) ;
15683: LD_VAR 0 1
15687: PPUSH
15688: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15692: LD_VAR 0 1
15696: PPUSH
15697: LD_INT 10
15699: PPUSH
15700: LD_INT 1
15702: PPUSH
15703: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15707: LD_VAR 0 1
15711: PPUSH
15712: LD_INT 32
15714: PPUSH
15715: CALL_OW 308
15719: IFFALSE 15730
// RemoveUnit ( i ) ;
15721: LD_VAR 0 1
15725: PPUSH
15726: CALL_OW 64
// end ;
15730: GO 15649
15732: POP
15733: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15734: LD_INT 22
15736: PUSH
15737: LD_INT 8
15739: PUSH
15740: EMPTY
15741: LIST
15742: LIST
15743: PUSH
15744: LD_INT 2
15746: PUSH
15747: LD_INT 21
15749: PUSH
15750: LD_INT 1
15752: PUSH
15753: EMPTY
15754: LIST
15755: LIST
15756: PUSH
15757: LD_INT 33
15759: PUSH
15760: LD_INT 1
15762: PUSH
15763: EMPTY
15764: LIST
15765: LIST
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: NOT
15781: IFFALSE 15632
// end ;
15783: PPOPN 2
15785: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15786: LD_EXP 4
15790: PUSH
15791: LD_EXP 2
15795: AND
15796: PUSH
15797: LD_EXP 3
15801: AND
15802: PUSH
15803: LD_EXP 5
15807: AND
15808: PUSH
15809: LD_EXP 6
15813: AND
15814: PUSH
15815: LD_EXP 7
15819: AND
15820: PUSH
15821: LD_EXP 8
15825: AND
15826: PUSH
15827: LD_EXP 53
15831: PPUSH
15832: CALL_OW 255
15836: PUSH
15837: LD_INT 5
15839: NONEQUAL
15840: PUSH
15841: LD_EXP 53
15845: PPUSH
15846: CALL_OW 301
15850: OR
15851: PUSH
15852: LD_EXP 53
15856: PPUSH
15857: CALL_OW 305
15861: NOT
15862: OR
15863: AND
15864: IFFALSE 17255
15866: GO 15868
15868: DISABLE
15869: LD_INT 0
15871: PPUSH
15872: PPUSH
// begin wait ( 0 0$5 ) ;
15873: LD_INT 175
15875: PPUSH
15876: CALL_OW 67
// music_class := 5 ;
15880: LD_ADDR_OWVAR 72
15884: PUSH
15885: LD_INT 5
15887: ST_TO_ADDR
// music_nat := 5 ;
15888: LD_ADDR_OWVAR 71
15892: PUSH
15893: LD_INT 5
15895: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15896: LD_EXP 15
15900: PUSH
15901: LD_INT 3
15903: LESS
15904: IFFALSE 15913
// SetAchievement ( ACH_ECONOMY ) ;
15906: LD_STRING ACH_ECONOMY
15908: PPUSH
15909: CALL_OW 543
// if tick < 60 60$00 then
15913: LD_OWVAR 1
15917: PUSH
15918: LD_INT 126000
15920: LESS
15921: IFFALSE 15937
// begin wait ( 3 ) ;
15923: LD_INT 3
15925: PPUSH
15926: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15930: LD_STRING ACH_ASPEED_19
15932: PPUSH
15933: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15937: LD_EXP 17
15941: PPUSH
15942: CALL_OW 87
// InGameOn ;
15946: CALL_OW 8
// DialogueOn ;
15950: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15954: LD_EXP 17
15958: PPUSH
15959: LD_STRING DEnd-JMM-JMM-1
15961: PPUSH
15962: CALL_OW 88
// if Joan then
15966: LD_EXP 32
15970: IFFALSE 15986
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15972: LD_EXP 32
15976: PPUSH
15977: LD_STRING DEnd-JMM-Joan-1
15979: PPUSH
15980: CALL_OW 88
15984: GO 16030
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15986: LD_EXP 19
15990: PUSH
15991: LD_EXP 19
15995: PPUSH
15996: CALL_OW 255
16000: PUSH
16001: LD_INT 7
16003: EQUAL
16004: AND
16005: PUSH
16006: LD_EXP 19
16010: PPUSH
16011: CALL_OW 305
16015: AND
16016: IFFALSE 16030
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16018: LD_EXP 19
16022: PPUSH
16023: LD_STRING DEnd-JMM-Lisa-1
16025: PPUSH
16026: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16030: LD_EXP 29
16034: PUSH
16035: LD_EXP 29
16039: PPUSH
16040: CALL_OW 305
16044: AND
16045: IFFALSE 16059
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16047: LD_EXP 29
16051: PPUSH
16052: LD_STRING DEnd-JMM-Frank-1
16054: PPUSH
16055: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16059: LD_EXP 22
16063: PUSH
16064: LD_EXP 22
16068: PPUSH
16069: CALL_OW 255
16073: PUSH
16074: LD_INT 7
16076: EQUAL
16077: AND
16078: PUSH
16079: LD_EXP 22
16083: PPUSH
16084: CALL_OW 305
16088: AND
16089: IFFALSE 16103
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16091: LD_EXP 22
16095: PPUSH
16096: LD_STRING DEnd-JMM-Cyrus-1
16098: PPUSH
16099: CALL_OW 88
// if Burlak then
16103: LD_EXP 49
16107: IFFALSE 16121
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16109: LD_EXP 49
16113: PPUSH
16114: LD_STRING DEnd-JMM-Bur-1
16116: PPUSH
16117: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16121: LD_EXP 32
16125: PUSH
16126: LD_EXP 19
16130: AND
16131: PUSH
16132: LD_EXP 19
16136: PPUSH
16137: CALL_OW 255
16141: PUSH
16142: LD_INT 7
16144: EQUAL
16145: AND
16146: PUSH
16147: LD_EXP 19
16151: PPUSH
16152: CALL_OW 305
16156: AND
16157: IFFALSE 16171
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16159: LD_EXP 19
16163: PPUSH
16164: LD_STRING DEnd-Burlak-Lisa-1
16166: PPUSH
16167: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16171: LD_EXP 50
16175: PUSH
16176: LD_EXP 50
16180: PPUSH
16181: CALL_OW 305
16185: AND
16186: IFFALSE 16200
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16188: LD_EXP 50
16192: PPUSH
16193: LD_STRING DEnd-JMM-Bel-1
16195: PPUSH
16196: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16200: LD_EXP 51
16204: PUSH
16205: LD_EXP 51
16209: PPUSH
16210: CALL_OW 305
16214: AND
16215: IFFALSE 16229
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16217: LD_EXP 51
16221: PPUSH
16222: LD_STRING DEnd-JMM-Gny-1
16224: PPUSH
16225: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16229: LD_EXP 27
16233: PUSH
16234: LD_EXP 27
16238: PPUSH
16239: CALL_OW 255
16243: PUSH
16244: LD_INT 7
16246: EQUAL
16247: AND
16248: PUSH
16249: LD_EXP 27
16253: PPUSH
16254: CALL_OW 305
16258: AND
16259: IFFALSE 16273
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16261: LD_EXP 27
16265: PPUSH
16266: LD_STRING DEnd-JMM-Corn-1
16268: PPUSH
16269: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16273: LD_EXP 20
16277: PUSH
16278: LD_EXP 20
16282: PPUSH
16283: CALL_OW 255
16287: PUSH
16288: LD_INT 7
16290: EQUAL
16291: AND
16292: PUSH
16293: LD_EXP 20
16297: PPUSH
16298: CALL_OW 305
16302: AND
16303: IFFALSE 16317
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16305: LD_EXP 20
16309: PPUSH
16310: LD_STRING DEnd-JMM-Don-1
16312: PPUSH
16313: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16317: LD_EXP 21
16321: PUSH
16322: LD_EXP 21
16326: PPUSH
16327: CALL_OW 255
16331: PUSH
16332: LD_INT 7
16334: EQUAL
16335: AND
16336: PUSH
16337: LD_EXP 21
16341: PPUSH
16342: CALL_OW 305
16346: AND
16347: IFFALSE 16361
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16349: LD_EXP 21
16353: PPUSH
16354: LD_STRING DEnd-JMM-Bobby-1
16356: PPUSH
16357: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16361: LD_EXP 23
16365: PUSH
16366: LD_EXP 23
16370: PPUSH
16371: CALL_OW 255
16375: PUSH
16376: LD_INT 7
16378: EQUAL
16379: AND
16380: PUSH
16381: LD_EXP 23
16385: PPUSH
16386: CALL_OW 305
16390: AND
16391: IFFALSE 16405
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16393: LD_EXP 23
16397: PPUSH
16398: LD_STRING DEnd-JMM-Den-1
16400: PPUSH
16401: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16405: LD_EXP 25
16409: PUSH
16410: LD_EXP 25
16414: PPUSH
16415: CALL_OW 255
16419: PUSH
16420: LD_INT 7
16422: EQUAL
16423: AND
16424: PUSH
16425: LD_EXP 25
16429: PPUSH
16430: CALL_OW 305
16434: AND
16435: IFFALSE 16449
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16437: LD_EXP 25
16441: PPUSH
16442: LD_STRING DEnd-JMM-Glad-1
16444: PPUSH
16445: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16449: LD_EXP 30
16453: PUSH
16454: LD_EXP 30
16458: PPUSH
16459: CALL_OW 255
16463: PUSH
16464: LD_INT 7
16466: EQUAL
16467: AND
16468: PUSH
16469: LD_EXP 30
16473: PPUSH
16474: CALL_OW 305
16478: AND
16479: IFFALSE 16493
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16481: LD_EXP 30
16485: PPUSH
16486: LD_STRING DEnd-JMM-Yam-1
16488: PPUSH
16489: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16493: LD_EXP 24
16497: PUSH
16498: LD_EXP 24
16502: PPUSH
16503: CALL_OW 255
16507: PUSH
16508: LD_INT 7
16510: EQUAL
16511: AND
16512: PUSH
16513: LD_EXP 24
16517: PPUSH
16518: CALL_OW 305
16522: AND
16523: IFFALSE 16537
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16525: LD_EXP 24
16529: PPUSH
16530: LD_STRING DEnd-JMM-Brown-1
16532: PPUSH
16533: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16537: LD_EXP 34
16541: PUSH
16542: LD_EXP 34
16546: PPUSH
16547: CALL_OW 255
16551: PUSH
16552: LD_INT 7
16554: EQUAL
16555: AND
16556: PUSH
16557: LD_EXP 34
16561: PPUSH
16562: CALL_OW 305
16566: AND
16567: IFFALSE 16581
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16569: LD_EXP 34
16573: PPUSH
16574: LD_STRING DEnd-JMM-Con-1
16576: PPUSH
16577: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16581: LD_EXP 28
16585: PUSH
16586: LD_EXP 28
16590: PPUSH
16591: CALL_OW 255
16595: PUSH
16596: LD_INT 7
16598: EQUAL
16599: AND
16600: PUSH
16601: LD_EXP 28
16605: PPUSH
16606: CALL_OW 305
16610: AND
16611: IFFALSE 16625
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16613: LD_EXP 28
16617: PPUSH
16618: LD_STRING DEnd-JMM-Gary-1
16620: PPUSH
16621: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16625: LD_EXP 31
16629: PUSH
16630: LD_EXP 18
16634: AND
16635: PUSH
16636: LD_EXP 31
16640: PPUSH
16641: CALL_OW 305
16645: AND
16646: IFFALSE 16660
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16648: LD_EXP 31
16652: PPUSH
16653: LD_STRING DEnd-JMM-Sim-1
16655: PPUSH
16656: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16660: LD_EXP 26
16664: PUSH
16665: LD_EXP 26
16669: PPUSH
16670: CALL_OW 255
16674: PUSH
16675: LD_INT 7
16677: EQUAL
16678: AND
16679: PUSH
16680: LD_EXP 26
16684: PPUSH
16685: CALL_OW 305
16689: AND
16690: IFFALSE 16704
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16692: LD_EXP 26
16696: PPUSH
16697: LD_STRING DEnd-JMM-VanH-1
16699: PPUSH
16700: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16704: LD_EXP 39
16708: PUSH
16709: LD_EXP 39
16713: PPUSH
16714: CALL_OW 305
16718: AND
16719: IFFALSE 16733
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16721: LD_EXP 39
16725: PPUSH
16726: LD_STRING DEnd-JMM-Dol-1
16728: PPUSH
16729: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16733: LD_EXP 43
16737: PUSH
16738: LD_EXP 43
16742: PPUSH
16743: CALL_OW 305
16747: AND
16748: IFFALSE 16762
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16750: LD_EXP 43
16754: PPUSH
16755: LD_STRING DEnd-JMM-Kap-1
16757: PPUSH
16758: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16762: LD_EXP 46
16766: PUSH
16767: LD_EXP 46
16771: PPUSH
16772: CALL_OW 305
16776: AND
16777: IFFALSE 16791
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16779: LD_EXP 46
16783: PPUSH
16784: LD_STRING DEnd-JMM-Kov-1
16786: PPUSH
16787: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16791: LD_EXP 41
16795: PUSH
16796: LD_EXP 41
16800: PPUSH
16801: CALL_OW 305
16805: AND
16806: IFFALSE 16820
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16808: LD_EXP 41
16812: PPUSH
16813: LD_STRING DEnd-JMM-Sch-1
16815: PPUSH
16816: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16820: LD_EXP 37
16824: PUSH
16825: LD_EXP 37
16829: PPUSH
16830: CALL_OW 305
16834: AND
16835: IFFALSE 16849
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16837: LD_EXP 37
16841: PPUSH
16842: LD_STRING DEnd-JMM-Tit-1
16844: PPUSH
16845: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16849: LD_EXP 42
16853: PUSH
16854: LD_EXP 42
16858: PPUSH
16859: CALL_OW 305
16863: AND
16864: IFFALSE 16878
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16866: LD_EXP 42
16870: PPUSH
16871: LD_STRING DEnd-JMM-Obl-1
16873: PPUSH
16874: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16878: LD_EXP 44
16882: PUSH
16883: LD_EXP 44
16887: PPUSH
16888: CALL_OW 305
16892: AND
16893: IFFALSE 16907
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16895: LD_EXP 44
16899: PPUSH
16900: LD_STRING DEnd-JMM-Lip-1
16902: PPUSH
16903: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16907: LD_EXP 38
16911: PUSH
16912: LD_EXP 38
16916: PPUSH
16917: CALL_OW 305
16921: AND
16922: PUSH
16923: LD_EXP 49
16927: AND
16928: IFFALSE 16942
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16930: LD_EXP 38
16934: PPUSH
16935: LD_STRING DEnd-Burlak-Fad-1
16937: PPUSH
16938: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16942: LD_EXP 45
16946: PUSH
16947: LD_EXP 45
16951: PPUSH
16952: CALL_OW 305
16956: AND
16957: IFFALSE 16971
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16959: LD_EXP 45
16963: PPUSH
16964: LD_STRING DEnd-Burlak-Ptr-1
16966: PPUSH
16967: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16971: LD_EXP 47
16975: PUSH
16976: LD_EXP 47
16980: PPUSH
16981: CALL_OW 305
16985: AND
16986: IFFALSE 17000
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16988: LD_EXP 47
16992: PPUSH
16993: LD_STRING DEnd-Burlak-Kuz-1
16995: PPUSH
16996: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17000: LD_EXP 36
17004: PUSH
17005: LD_EXP 36
17009: PPUSH
17010: CALL_OW 305
17014: AND
17015: PUSH
17016: LD_EXP 49
17020: AND
17021: IFFALSE 17035
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17023: LD_EXP 36
17027: PPUSH
17028: LD_STRING DEnd-Burlak-Kir-1
17030: PPUSH
17031: CALL_OW 88
// if Burlak then
17035: LD_EXP 49
17039: IFFALSE 17053
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17041: LD_EXP 17
17045: PPUSH
17046: LD_STRING DEnd-Burlak-JMM-1
17048: PPUSH
17049: CALL_OW 88
// dwait ( 0 0$2 ) ;
17053: LD_INT 70
17055: PPUSH
17056: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17060: LD_EXP 54
17064: PPUSH
17065: LD_STRING DEnd-Szulc
17067: PPUSH
17068: CALL_OW 94
// dwait ( 0 0$1 ) ;
17072: LD_INT 35
17074: PPUSH
17075: CALL_OW 68
// if IsLive ( Burlak ) then
17079: LD_EXP 49
17083: PPUSH
17084: CALL_OW 300
17088: IFFALSE 17100
// med1 := 1 else
17090: LD_ADDR_VAR 0 1
17094: PUSH
17095: LD_INT 1
17097: ST_TO_ADDR
17098: GO 17109
// med1 := - 1 ;
17100: LD_ADDR_VAR 0 1
17104: PUSH
17105: LD_INT 1
17107: NEG
17108: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17109: LD_EXP 12
17113: PUSH
17114: LD_EXP 13
17118: AND
17119: PUSH
17120: LD_EXP 14
17124: AND
17125: IFFALSE 17137
// med2 := 1 else
17127: LD_ADDR_VAR 0 2
17131: PUSH
17132: LD_INT 1
17134: ST_TO_ADDR
17135: GO 17146
// med2 := - 1 ;
17137: LD_ADDR_VAR 0 2
17141: PUSH
17142: LD_INT 1
17144: NEG
17145: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17146: LD_STRING Hero
17148: PPUSH
17149: LD_INT 1
17151: PPUSH
17152: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17156: LD_STRING Artefact
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17168: LD_STRING ReconcileBurlak
17170: PPUSH
17171: LD_VAR 0 1
17175: PPUSH
17176: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17180: LD_OWVAR 67
17184: PUSH
17185: LD_INT 3
17187: EQUAL
17188: PUSH
17189: LD_VAR 0 1
17193: PUSH
17194: LD_INT 1
17196: EQUAL
17197: AND
17198: PUSH
17199: LD_VAR 0 2
17203: PUSH
17204: LD_INT 1
17206: EQUAL
17207: AND
17208: IFFALSE 17220
// SetAchievementEX ( ACH_AMER , 19 ) ;
17210: LD_STRING ACH_AMER
17212: PPUSH
17213: LD_INT 19
17215: PPUSH
17216: CALL_OW 564
// GiveMedals ( MAIN ) ;
17220: LD_STRING MAIN
17222: PPUSH
17223: CALL_OW 102
// InGameOff ;
17227: CALL_OW 9
// DialogueOff ;
17231: CALL_OW 7
// music_nat := 1 ;
17235: LD_ADDR_OWVAR 71
17239: PUSH
17240: LD_INT 1
17242: ST_TO_ADDR
// music_class := 4 ;
17243: LD_ADDR_OWVAR 72
17247: PUSH
17248: LD_INT 4
17250: ST_TO_ADDR
// YouWin ;
17251: CALL_OW 103
// end ; end_of_file
17255: PPOPN 2
17257: END
// export function InitNature ; begin
17258: LD_INT 0
17260: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17261: LD_INT 3
17263: PPUSH
17264: LD_INT 3
17266: PPUSH
17267: LD_INT 2
17269: PPUSH
17270: LD_INT 1
17272: PPUSH
17273: LD_INT 1
17275: PPUSH
17276: LD_INT 0
17278: PPUSH
17279: LD_INT 0
17281: PPUSH
17282: LD_INT 17
17284: PPUSH
17285: LD_INT 0
17287: PPUSH
17288: CALL 83362 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17292: LD_INT 2
17294: PPUSH
17295: LD_INT 1
17297: PPUSH
17298: LD_INT 1
17300: PPUSH
17301: LD_INT 1
17303: PPUSH
17304: LD_INT 1
17306: PPUSH
17307: LD_INT 0
17309: PPUSH
17310: LD_INT 0
17312: PPUSH
17313: LD_INT 18
17315: PPUSH
17316: LD_INT 0
17318: PPUSH
17319: CALL 83362 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17323: LD_INT 4
17325: PPUSH
17326: LD_INT 1
17328: PPUSH
17329: LD_INT 2
17331: PPUSH
17332: LD_INT 4
17334: PPUSH
17335: LD_INT 2
17337: PPUSH
17338: LD_INT 1
17340: PPUSH
17341: LD_INT 0
17343: PPUSH
17344: LD_INT 19
17346: PPUSH
17347: LD_INT 0
17349: PPUSH
17350: CALL 83362 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17354: LD_INT 0
17356: PPUSH
17357: LD_INT 0
17359: PPUSH
17360: LD_INT 0
17362: PPUSH
17363: LD_INT 0
17365: PPUSH
17366: LD_INT 0
17368: PPUSH
17369: LD_INT 0
17371: PPUSH
17372: LD_INT 9
17374: PPUSH
17375: LD_INT 0
17377: PPUSH
17378: LD_INT 20
17380: PPUSH
17381: CALL 83362 0 9
// end ; end_of_file
17385: LD_VAR 0 1
17389: RET
// every 0 0$30 do var time ;
17390: GO 17392
17392: DISABLE
17393: LD_INT 0
17395: PPUSH
// begin time := 0 0$50 ;
17396: LD_ADDR_VAR 0 1
17400: PUSH
17401: LD_INT 1750
17403: ST_TO_ADDR
// repeat wait ( time ) ;
17404: LD_VAR 0 1
17408: PPUSH
17409: CALL_OW 67
// if Prob ( 50 ) then
17413: LD_INT 50
17415: PPUSH
17416: CALL_OW 13
17420: IFFALSE 17449
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17422: LD_INT 1
17424: PPUSH
17425: LD_INT 5
17427: PPUSH
17428: CALL_OW 12
17432: PPUSH
17433: LD_INT 106
17435: PPUSH
17436: LD_INT 89
17438: PPUSH
17439: LD_INT 45
17441: PPUSH
17442: LD_INT 1
17444: PPUSH
17445: CALL_OW 56
// time := time + 0 0$3 ;
17449: LD_ADDR_VAR 0 1
17453: PUSH
17454: LD_VAR 0 1
17458: PUSH
17459: LD_INT 105
17461: PLUS
17462: ST_TO_ADDR
// if Prob ( 30 ) then
17463: LD_INT 30
17465: PPUSH
17466: CALL_OW 13
17470: IFFALSE 17516
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17472: LD_INT 525
17474: PPUSH
17475: LD_INT 735
17477: PPUSH
17478: CALL_OW 12
17482: PPUSH
17483: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17487: LD_INT 1
17489: PPUSH
17490: LD_INT 5
17492: PPUSH
17493: CALL_OW 12
17497: PPUSH
17498: LD_INT 21
17500: PPUSH
17501: LD_INT 26
17503: PPUSH
17504: LD_INT 12
17506: PPUSH
17507: LD_INT 1
17509: PPUSH
17510: CALL_OW 56
// end else
17514: GO 17552
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17516: LD_INT 700
17518: PPUSH
17519: LD_INT 1225
17521: PPUSH
17522: CALL_OW 12
17526: PPUSH
17527: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17531: LD_INT 1
17533: PPUSH
17534: LD_INT 5
17536: PPUSH
17537: CALL_OW 12
17541: PPUSH
17542: LD_INT 14
17544: PPUSH
17545: LD_INT 1
17547: PPUSH
17548: CALL_OW 55
// end ; if Prob ( 50 ) then
17552: LD_INT 50
17554: PPUSH
17555: CALL_OW 13
17559: IFFALSE 17605
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17561: LD_INT 700
17563: PPUSH
17564: LD_INT 1050
17566: PPUSH
17567: CALL_OW 12
17571: PPUSH
17572: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17576: LD_INT 1
17578: PPUSH
17579: LD_INT 5
17581: PPUSH
17582: CALL_OW 12
17586: PPUSH
17587: LD_INT 181
17589: PPUSH
17590: LD_INT 218
17592: PPUSH
17593: LD_INT 16
17595: PPUSH
17596: LD_INT 1
17598: PPUSH
17599: CALL_OW 56
// end else
17603: GO 17677
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17605: LD_INT 350
17607: PPUSH
17608: LD_INT 525
17610: PPUSH
17611: CALL_OW 12
17615: PPUSH
17616: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17620: LD_INT 1
17622: PPUSH
17623: LD_INT 5
17625: PPUSH
17626: CALL_OW 12
17630: PPUSH
17631: LD_INT 13
17633: PPUSH
17634: LD_INT 1
17636: PPUSH
17637: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17641: LD_INT 350
17643: PPUSH
17644: LD_INT 700
17646: PPUSH
17647: CALL_OW 12
17651: PPUSH
17652: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17656: LD_INT 1
17658: PPUSH
17659: LD_INT 5
17661: PPUSH
17662: CALL_OW 12
17666: PPUSH
17667: LD_INT 33
17669: PPUSH
17670: LD_INT 1
17672: PPUSH
17673: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17677: LD_INT 65
17679: PUSH
17680: LD_INT 62
17682: PUSH
17683: LD_INT 55
17685: PUSH
17686: EMPTY
17687: LIST
17688: LIST
17689: LIST
17690: PUSH
17691: LD_OWVAR 67
17695: ARRAY
17696: PPUSH
17697: CALL_OW 13
17701: IFFALSE 17747
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17703: LD_INT 525
17705: PPUSH
17706: LD_INT 875
17708: PPUSH
17709: CALL_OW 12
17713: PPUSH
17714: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17718: LD_INT 1
17720: PPUSH
17721: LD_INT 5
17723: PPUSH
17724: CALL_OW 12
17728: PPUSH
17729: LD_INT 294
17731: PPUSH
17732: LD_INT 211
17734: PPUSH
17735: LD_INT 30
17737: PPUSH
17738: LD_INT 1
17740: PPUSH
17741: CALL_OW 56
// end else
17745: GO 17789
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17747: LD_INT 420
17749: PPUSH
17750: LD_INT 770
17752: PPUSH
17753: CALL_OW 12
17757: PPUSH
17758: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17762: LD_INT 1
17764: PPUSH
17765: LD_INT 5
17767: PPUSH
17768: CALL_OW 12
17772: PPUSH
17773: LD_INT 294
17775: PPUSH
17776: LD_INT 211
17778: PPUSH
17779: LD_INT 30
17781: PPUSH
17782: LD_INT 1
17784: PPUSH
17785: CALL_OW 56
// end ; if time > 2 2$20 then
17789: LD_VAR 0 1
17793: PUSH
17794: LD_INT 4900
17796: GREATER
17797: IFFALSE 17807
// time := 0 0$50 ;
17799: LD_ADDR_VAR 0 1
17803: PUSH
17804: LD_INT 1750
17806: ST_TO_ADDR
// until false ;
17807: LD_INT 0
17809: IFFALSE 17404
// end ;
17811: PPOPN 1
17813: END
// every 0 0$45 trigger tick < 10 10$00 do
17814: LD_OWVAR 1
17818: PUSH
17819: LD_INT 21000
17821: LESS
17822: IFFALSE 17870
17824: GO 17826
17826: DISABLE
// begin enable ;
17827: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17828: LD_INT 350
17830: PPUSH
17831: LD_INT 700
17833: PPUSH
17834: CALL_OW 12
17838: PPUSH
17839: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17843: LD_INT 3
17845: PPUSH
17846: LD_INT 5
17848: PPUSH
17849: CALL_OW 12
17853: PPUSH
17854: LD_INT 181
17856: PPUSH
17857: LD_INT 13
17859: PPUSH
17860: LD_INT 20
17862: PPUSH
17863: LD_INT 1
17865: PPUSH
17866: CALL_OW 56
// end ; end_of_file
17870: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17871: LD_INT 0
17873: PPUSH
// SetArtifactRes ( 7 , true ) ;
17874: LD_INT 7
17876: PPUSH
17877: LD_INT 1
17879: PPUSH
17880: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17884: LD_ADDR_EXP 62
17888: PUSH
17889: EMPTY
17890: PUSH
17891: EMPTY
17892: PUSH
17893: EMPTY
17894: PUSH
17895: EMPTY
17896: LIST
17897: LIST
17898: LIST
17899: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17900: LD_ADDR_EXP 63
17904: PUSH
17905: LD_INT 1050
17907: PUSH
17908: LD_OWVAR 67
17912: MUL
17913: PUSH
17914: LD_INT 2800
17916: PUSH
17917: LD_OWVAR 67
17921: MUL
17922: PUSH
17923: LD_INT 1
17925: NEG
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: LIST
17931: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17932: LD_ADDR_EXP 64
17936: PUSH
17937: LD_INT 10
17939: PUSH
17940: LD_INT 35
17942: PUSH
17943: LD_INT 100
17945: PUSH
17946: EMPTY
17947: LIST
17948: LIST
17949: LIST
17950: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17951: LD_ADDR_EXP 65
17955: PUSH
17956: LD_INT 0
17958: PUSH
17959: LD_INT 0
17961: PUSH
17962: LD_INT 0
17964: PUSH
17965: EMPTY
17966: LIST
17967: LIST
17968: LIST
17969: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17970: LD_ADDR_EXP 67
17974: PUSH
17975: LD_INT 300
17977: PUSH
17978: LD_INT 500
17980: PUSH
17981: LD_INT 800
17983: PUSH
17984: EMPTY
17985: LIST
17986: LIST
17987: LIST
17988: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17989: LD_ADDR_EXP 68
17993: PUSH
17994: LD_INT 0
17996: PUSH
17997: LD_INT 0
17999: PUSH
18000: LD_INT 0
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: LIST
18007: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18008: LD_ADDR_EXP 69
18012: PUSH
18013: LD_INT 0
18015: PUSH
18016: LD_INT 0
18018: PUSH
18019: LD_INT 0
18021: PUSH
18022: EMPTY
18023: LIST
18024: LIST
18025: LIST
18026: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18027: LD_ADDR_EXP 66
18031: PUSH
18032: LD_INT 0
18034: PUSH
18035: LD_INT 0
18037: PUSH
18038: LD_INT 0
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: LIST
18045: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18046: LD_ADDR_EXP 70
18050: PUSH
18051: LD_INT 4
18053: PUSH
18054: LD_INT 3
18056: PUSH
18057: LD_INT 1
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: LIST
18064: PUSH
18065: LD_INT 5
18067: PUSH
18068: LD_INT 4
18070: PUSH
18071: LD_INT 2
18073: PUSH
18074: EMPTY
18075: LIST
18076: LIST
18077: LIST
18078: PUSH
18079: LD_INT 6
18081: PUSH
18082: LD_INT 3
18084: PUSH
18085: LD_INT 3
18087: PUSH
18088: EMPTY
18089: LIST
18090: LIST
18091: LIST
18092: PUSH
18093: EMPTY
18094: LIST
18095: LIST
18096: LIST
18097: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18098: LD_ADDR_EXP 71
18102: PUSH
18103: LD_INT 0
18105: PUSH
18106: LD_INT 0
18108: PUSH
18109: LD_INT 0
18111: PUSH
18112: EMPTY
18113: LIST
18114: LIST
18115: LIST
18116: ST_TO_ADDR
// end ;
18117: LD_VAR 0 1
18121: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18122: LD_INT 24
18124: PPUSH
18125: LD_INT 7
18127: PPUSH
18128: CALL_OW 321
18132: PUSH
18133: LD_INT 2
18135: EQUAL
18136: IFFALSE 19062
18138: GO 18140
18140: DISABLE
18141: LD_INT 0
18143: PPUSH
18144: PPUSH
18145: PPUSH
18146: PPUSH
18147: PPUSH
// begin enable ;
18148: ENABLE
// for i = 1 to 3 do
18149: LD_ADDR_VAR 0 1
18153: PUSH
18154: DOUBLE
18155: LD_INT 1
18157: DEC
18158: ST_TO_ADDR
18159: LD_INT 3
18161: PUSH
18162: FOR_TO
18163: IFFALSE 19060
// begin pos := FindArtifact ( i + 2 ) ;
18165: LD_ADDR_VAR 0 2
18169: PUSH
18170: LD_VAR 0 1
18174: PUSH
18175: LD_INT 2
18177: PLUS
18178: PPUSH
18179: CALL_OW 469
18183: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18184: LD_ADDR_EXP 62
18188: PUSH
18189: LD_EXP 62
18193: PPUSH
18194: LD_VAR 0 1
18198: PPUSH
18199: LD_VAR 0 2
18203: PPUSH
18204: CALL_OW 1
18208: ST_TO_ADDR
// if pos then
18209: LD_VAR 0 2
18213: IFFALSE 18921
// begin case i of 1 :
18215: LD_VAR 0 1
18219: PUSH
18220: LD_INT 1
18222: DOUBLE
18223: EQUAL
18224: IFTRUE 18228
18226: GO 18305
18228: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18229: LD_ADDR_VAR 0 4
18233: PUSH
18234: LD_INT 22
18236: PUSH
18237: LD_INT 7
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: PUSH
18244: LD_INT 23
18246: PUSH
18247: LD_INT 1
18249: PUSH
18250: EMPTY
18251: LIST
18252: LIST
18253: PUSH
18254: LD_INT 2
18256: PUSH
18257: LD_INT 30
18259: PUSH
18260: LD_INT 8
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: PUSH
18267: LD_INT 30
18269: PUSH
18270: LD_INT 7
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: PUSH
18277: LD_INT 30
18279: PUSH
18280: LD_INT 11
18282: PUSH
18283: EMPTY
18284: LIST
18285: LIST
18286: PUSH
18287: EMPTY
18288: LIST
18289: LIST
18290: LIST
18291: LIST
18292: PUSH
18293: EMPTY
18294: LIST
18295: LIST
18296: LIST
18297: PPUSH
18298: CALL_OW 69
18302: ST_TO_ADDR
18303: GO 18413
18305: LD_INT 2
18307: DOUBLE
18308: EQUAL
18309: IFTRUE 18313
18311: GO 18390
18313: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18314: LD_ADDR_VAR 0 4
18318: PUSH
18319: LD_INT 22
18321: PUSH
18322: LD_INT 7
18324: PUSH
18325: EMPTY
18326: LIST
18327: LIST
18328: PUSH
18329: LD_INT 23
18331: PUSH
18332: LD_INT 3
18334: PUSH
18335: EMPTY
18336: LIST
18337: LIST
18338: PUSH
18339: LD_INT 2
18341: PUSH
18342: LD_INT 30
18344: PUSH
18345: LD_INT 8
18347: PUSH
18348: EMPTY
18349: LIST
18350: LIST
18351: PUSH
18352: LD_INT 30
18354: PUSH
18355: LD_INT 7
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: PUSH
18362: LD_INT 30
18364: PUSH
18365: LD_INT 11
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: PUSH
18372: EMPTY
18373: LIST
18374: LIST
18375: LIST
18376: LIST
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: LIST
18382: PPUSH
18383: CALL_OW 69
18387: ST_TO_ADDR
18388: GO 18413
18390: LD_INT 3
18392: DOUBLE
18393: EQUAL
18394: IFTRUE 18398
18396: GO 18412
18398: POP
// labs := [ alien ] ; end ;
18399: LD_ADDR_VAR 0 4
18403: PUSH
18404: LD_INT 1
18406: PUSH
18407: EMPTY
18408: LIST
18409: ST_TO_ADDR
18410: GO 18413
18412: POP
// if not labs then
18413: LD_VAR 0 4
18417: NOT
18418: IFFALSE 18422
// continue ;
18420: GO 18162
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18422: LD_ADDR_VAR 0 5
18426: PUSH
18427: LD_VAR 0 4
18431: PPUSH
18432: LD_EXP 62
18436: PUSH
18437: LD_VAR 0 1
18441: ARRAY
18442: PUSH
18443: LD_INT 1
18445: ARRAY
18446: PPUSH
18447: LD_EXP 62
18451: PUSH
18452: LD_VAR 0 1
18456: ARRAY
18457: PUSH
18458: LD_INT 2
18460: ARRAY
18461: PPUSH
18462: CALL_OW 73
18466: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18467: LD_VAR 0 5
18471: NOT
18472: PUSH
18473: LD_VAR 0 5
18477: PUSH
18478: LD_EXP 69
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: NONEQUAL
18489: OR
18490: IFFALSE 18595
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18492: LD_INT 7
18494: PPUSH
18495: LD_EXP 70
18499: PUSH
18500: LD_VAR 0 1
18504: ARRAY
18505: PUSH
18506: LD_INT 3
18508: ARRAY
18509: PPUSH
18510: LD_INT 0
18512: PPUSH
18513: LD_EXP 69
18517: PUSH
18518: LD_VAR 0 1
18522: ARRAY
18523: PPUSH
18524: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18528: LD_INT 7
18530: PPUSH
18531: LD_EXP 70
18535: PUSH
18536: LD_VAR 0 1
18540: ARRAY
18541: PUSH
18542: LD_INT 1
18544: ARRAY
18545: PPUSH
18546: LD_INT 0
18548: PPUSH
18549: LD_EXP 69
18553: PUSH
18554: LD_VAR 0 1
18558: ARRAY
18559: PPUSH
18560: CALL_OW 468
// if nearestLab then
18564: LD_VAR 0 5
18568: IFFALSE 18595
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18570: LD_ADDR_EXP 69
18574: PUSH
18575: LD_EXP 69
18579: PPUSH
18580: LD_VAR 0 1
18584: PPUSH
18585: LD_VAR 0 5
18589: PPUSH
18590: CALL_OW 1
18594: ST_TO_ADDR
// end ; if not nearestLab then
18595: LD_VAR 0 5
18599: NOT
18600: IFFALSE 18604
// continue ;
18602: GO 18162
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18604: LD_VAR 0 5
18608: PPUSH
18609: LD_EXP 62
18613: PUSH
18614: LD_VAR 0 1
18618: ARRAY
18619: PUSH
18620: LD_INT 1
18622: ARRAY
18623: PPUSH
18624: LD_EXP 62
18628: PUSH
18629: LD_VAR 0 1
18633: ARRAY
18634: PUSH
18635: LD_INT 2
18637: ARRAY
18638: PPUSH
18639: CALL_OW 297
18643: PUSH
18644: LD_INT 8
18646: LESS
18647: IFFALSE 18844
// begin if not artifactsResearched [ i ] then
18649: LD_EXP 65
18653: PUSH
18654: LD_VAR 0 1
18658: ARRAY
18659: NOT
18660: IFFALSE 18741
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18662: LD_VAR 0 5
18666: PPUSH
18667: CALL_OW 461
18671: PUSH
18672: LD_INT 2
18674: EQUAL
18675: IFFALSE 18709
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18677: LD_INT 7
18679: PPUSH
18680: LD_EXP 70
18684: PUSH
18685: LD_VAR 0 1
18689: ARRAY
18690: PUSH
18691: LD_INT 3
18693: ARRAY
18694: PPUSH
18695: LD_INT 2
18697: PPUSH
18698: LD_VAR 0 5
18702: PPUSH
18703: CALL_OW 468
18707: GO 18739
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18709: LD_INT 7
18711: PPUSH
18712: LD_EXP 70
18716: PUSH
18717: LD_VAR 0 1
18721: ARRAY
18722: PUSH
18723: LD_INT 3
18725: ARRAY
18726: PPUSH
18727: LD_INT 1
18729: PPUSH
18730: LD_VAR 0 5
18734: PPUSH
18735: CALL_OW 468
// end else
18739: GO 18842
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18741: LD_VAR 0 5
18745: PPUSH
18746: CALL_OW 461
18750: PUSH
18751: LD_INT 2
18753: EQUAL
18754: PUSH
18755: LD_EXP 71
18759: PUSH
18760: LD_VAR 0 1
18764: ARRAY
18765: AND
18766: IFFALSE 18812
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18768: LD_INT 7
18770: PPUSH
18771: LD_EXP 70
18775: PUSH
18776: LD_VAR 0 1
18780: ARRAY
18781: PUSH
18782: LD_INT 1
18784: ARRAY
18785: PPUSH
18786: LD_EXP 70
18790: PUSH
18791: LD_VAR 0 1
18795: ARRAY
18796: PUSH
18797: LD_INT 2
18799: ARRAY
18800: PPUSH
18801: LD_VAR 0 5
18805: PPUSH
18806: CALL_OW 468
18810: GO 18842
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18812: LD_INT 7
18814: PPUSH
18815: LD_EXP 70
18819: PUSH
18820: LD_VAR 0 1
18824: ARRAY
18825: PUSH
18826: LD_INT 1
18828: ARRAY
18829: PPUSH
18830: LD_INT 1
18832: PPUSH
18833: LD_VAR 0 5
18837: PPUSH
18838: CALL_OW 468
// end else
18842: GO 18919
// begin if not artifactsResearched [ i ] then
18844: LD_EXP 65
18848: PUSH
18849: LD_VAR 0 1
18853: ARRAY
18854: NOT
18855: IFFALSE 18889
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18857: LD_INT 7
18859: PPUSH
18860: LD_EXP 70
18864: PUSH
18865: LD_VAR 0 1
18869: ARRAY
18870: PUSH
18871: LD_INT 3
18873: ARRAY
18874: PPUSH
18875: LD_INT 0
18877: PPUSH
18878: LD_VAR 0 5
18882: PPUSH
18883: CALL_OW 468
18887: GO 18919
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18889: LD_INT 7
18891: PPUSH
18892: LD_EXP 70
18896: PUSH
18897: LD_VAR 0 1
18901: ARRAY
18902: PUSH
18903: LD_INT 1
18905: ARRAY
18906: PPUSH
18907: LD_INT 0
18909: PPUSH
18910: LD_VAR 0 5
18914: PPUSH
18915: CALL_OW 468
// end ; end else
18919: GO 19058
// begin if not artifactsLabs [ i ] then
18921: LD_EXP 69
18925: PUSH
18926: LD_VAR 0 1
18930: ARRAY
18931: NOT
18932: IFFALSE 18936
// continue ;
18934: GO 18162
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18936: LD_INT 7
18938: PPUSH
18939: LD_EXP 70
18943: PUSH
18944: LD_VAR 0 1
18948: ARRAY
18949: PUSH
18950: LD_INT 3
18952: ARRAY
18953: PPUSH
18954: LD_INT 0
18956: PPUSH
18957: LD_EXP 69
18961: PUSH
18962: LD_VAR 0 1
18966: ARRAY
18967: PPUSH
18968: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18972: LD_INT 7
18974: PPUSH
18975: LD_EXP 70
18979: PUSH
18980: LD_VAR 0 1
18984: ARRAY
18985: PUSH
18986: LD_INT 1
18988: ARRAY
18989: PPUSH
18990: LD_INT 0
18992: PPUSH
18993: LD_EXP 69
18997: PUSH
18998: LD_VAR 0 1
19002: ARRAY
19003: PPUSH
19004: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19008: LD_EXP 66
19012: PUSH
19013: LD_VAR 0 1
19017: ARRAY
19018: IFFALSE 19058
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19020: LD_ADDR_EXP 66
19024: PUSH
19025: LD_EXP 66
19029: PPUSH
19030: LD_VAR 0 1
19034: PPUSH
19035: LD_INT 0
19037: PPUSH
19038: CALL_OW 1
19042: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19043: LD_EXP 69
19047: PUSH
19048: LD_VAR 0 1
19052: ARRAY
19053: PPUSH
19054: CALL_OW 127
// end ; end ; end ;
19058: GO 18162
19060: POP
19061: POP
// end ;
19062: PPOPN 5
19064: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19065: LD_INT 0
19067: PPUSH
19068: PPUSH
19069: PPUSH
19070: PPUSH
19071: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19072: LD_VAR 0 2
19076: PUSH
19077: LD_EXP 70
19081: PUSH
19082: LD_INT 1
19084: ARRAY
19085: PUSH
19086: LD_INT 3
19088: ARRAY
19089: EQUAL
19090: IFFALSE 19213
// begin lab := artifactsLabs [ 1 ] ;
19092: LD_ADDR_VAR 0 6
19096: PUSH
19097: LD_EXP 69
19101: PUSH
19102: LD_INT 1
19104: ARRAY
19105: ST_TO_ADDR
// if not lab then
19106: LD_VAR 0 6
19110: NOT
19111: IFFALSE 19115
// exit ;
19113: GO 20193
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19115: LD_VAR 0 6
19119: PPUSH
19120: LD_EXP 67
19124: PUSH
19125: LD_INT 1
19127: ARRAY
19128: PPUSH
19129: LD_INT 1
19131: PPUSH
19132: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19136: LD_EXP 68
19140: PUSH
19141: LD_INT 1
19143: ARRAY
19144: IFFALSE 19164
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19146: LD_VAR 0 6
19150: PPUSH
19151: LD_EXP 68
19155: PUSH
19156: LD_INT 1
19158: ARRAY
19159: PPUSH
19160: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19164: LD_ADDR_EXP 66
19168: PUSH
19169: LD_EXP 66
19173: PPUSH
19174: LD_INT 1
19176: PPUSH
19177: LD_INT 1
19179: PPUSH
19180: CALL_OW 1
19184: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19185: LD_INT 7
19187: PPUSH
19188: LD_EXP 70
19192: PUSH
19193: LD_INT 1
19195: ARRAY
19196: PUSH
19197: LD_INT 3
19199: ARRAY
19200: PPUSH
19201: LD_INT 0
19203: PPUSH
19204: LD_VAR 0 6
19208: PPUSH
19209: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19213: LD_VAR 0 2
19217: PUSH
19218: LD_EXP 70
19222: PUSH
19223: LD_INT 2
19225: ARRAY
19226: PUSH
19227: LD_INT 3
19229: ARRAY
19230: EQUAL
19231: IFFALSE 19354
// begin lab := artifactsLabs [ 2 ] ;
19233: LD_ADDR_VAR 0 6
19237: PUSH
19238: LD_EXP 69
19242: PUSH
19243: LD_INT 2
19245: ARRAY
19246: ST_TO_ADDR
// if not lab then
19247: LD_VAR 0 6
19251: NOT
19252: IFFALSE 19256
// exit ;
19254: GO 20193
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19256: LD_VAR 0 6
19260: PPUSH
19261: LD_EXP 67
19265: PUSH
19266: LD_INT 2
19268: ARRAY
19269: PPUSH
19270: LD_INT 1
19272: PPUSH
19273: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19277: LD_EXP 68
19281: PUSH
19282: LD_INT 2
19284: ARRAY
19285: IFFALSE 19305
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19287: LD_VAR 0 6
19291: PPUSH
19292: LD_EXP 68
19296: PUSH
19297: LD_INT 2
19299: ARRAY
19300: PPUSH
19301: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19305: LD_ADDR_EXP 66
19309: PUSH
19310: LD_EXP 66
19314: PPUSH
19315: LD_INT 2
19317: PPUSH
19318: LD_INT 1
19320: PPUSH
19321: CALL_OW 1
19325: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19326: LD_INT 7
19328: PPUSH
19329: LD_EXP 70
19333: PUSH
19334: LD_INT 2
19336: ARRAY
19337: PUSH
19338: LD_INT 3
19340: ARRAY
19341: PPUSH
19342: LD_INT 0
19344: PPUSH
19345: LD_VAR 0 6
19349: PPUSH
19350: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19354: LD_VAR 0 2
19358: PUSH
19359: LD_EXP 70
19363: PUSH
19364: LD_INT 3
19366: ARRAY
19367: PUSH
19368: LD_INT 3
19370: ARRAY
19371: EQUAL
19372: IFFALSE 19495
// begin lab := artifactsLabs [ 3 ] ;
19374: LD_ADDR_VAR 0 6
19378: PUSH
19379: LD_EXP 69
19383: PUSH
19384: LD_INT 3
19386: ARRAY
19387: ST_TO_ADDR
// if not lab then
19388: LD_VAR 0 6
19392: NOT
19393: IFFALSE 19397
// exit ;
19395: GO 20193
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19397: LD_VAR 0 6
19401: PPUSH
19402: LD_EXP 67
19406: PUSH
19407: LD_INT 3
19409: ARRAY
19410: PPUSH
19411: LD_INT 1
19413: PPUSH
19414: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19418: LD_EXP 68
19422: PUSH
19423: LD_INT 3
19425: ARRAY
19426: IFFALSE 19446
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19428: LD_VAR 0 6
19432: PPUSH
19433: LD_EXP 68
19437: PUSH
19438: LD_INT 3
19440: ARRAY
19441: PPUSH
19442: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19446: LD_ADDR_EXP 66
19450: PUSH
19451: LD_EXP 66
19455: PPUSH
19456: LD_INT 3
19458: PPUSH
19459: LD_INT 1
19461: PPUSH
19462: CALL_OW 1
19466: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19467: LD_INT 7
19469: PPUSH
19470: LD_EXP 70
19474: PUSH
19475: LD_INT 3
19477: ARRAY
19478: PUSH
19479: LD_INT 3
19481: ARRAY
19482: PPUSH
19483: LD_INT 0
19485: PPUSH
19486: LD_VAR 0 6
19490: PPUSH
19491: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19495: LD_VAR 0 2
19499: PUSH
19500: LD_EXP 70
19504: PUSH
19505: LD_INT 1
19507: ARRAY
19508: PUSH
19509: LD_INT 1
19511: ARRAY
19512: EQUAL
19513: IFFALSE 19671
// begin lab := artifactsLabs [ 1 ] ;
19515: LD_ADDR_VAR 0 6
19519: PUSH
19520: LD_EXP 69
19524: PUSH
19525: LD_INT 1
19527: ARRAY
19528: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19529: LD_VAR 0 6
19533: PPUSH
19534: CALL_OW 274
19538: PPUSH
19539: CALL 86847 0 1
19543: PUSH
19544: LD_INT 3
19546: ARRAY
19547: PUSH
19548: LD_EXP 64
19552: PUSH
19553: LD_INT 1
19555: ARRAY
19556: LESS
19557: IFFALSE 19571
// begin HintSpec ( ArtifactCost , 2 ) ;
19559: LD_STRING ArtifactCost
19561: PPUSH
19562: LD_INT 2
19564: PPUSH
19565: CALL_OW 338
// exit ;
19569: GO 20193
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19571: LD_ADDR_EXP 71
19575: PUSH
19576: LD_EXP 71
19580: PPUSH
19581: LD_INT 1
19583: PPUSH
19584: LD_INT 0
19586: PPUSH
19587: CALL_OW 1
19591: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19592: LD_VAR 0 3
19596: PPUSH
19597: LD_VAR 0 4
19601: PPUSH
19602: LD_INT 7
19604: PPUSH
19605: LD_INT 12
19607: NEG
19608: PPUSH
19609: CALL_OW 330
// wait ( 0 0$30 ) ;
19613: LD_INT 1050
19615: PPUSH
19616: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19620: LD_VAR 0 3
19624: PPUSH
19625: LD_VAR 0 4
19629: PPUSH
19630: LD_INT 7
19632: PPUSH
19633: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19637: LD_EXP 63
19641: PUSH
19642: LD_INT 1
19644: ARRAY
19645: PPUSH
19646: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19650: LD_ADDR_EXP 71
19654: PUSH
19655: LD_EXP 71
19659: PPUSH
19660: LD_INT 1
19662: PPUSH
19663: LD_INT 1
19665: PPUSH
19666: CALL_OW 1
19670: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19671: LD_VAR 0 2
19675: PUSH
19676: LD_EXP 70
19680: PUSH
19681: LD_INT 2
19683: ARRAY
19684: PUSH
19685: LD_INT 1
19687: ARRAY
19688: EQUAL
19689: IFFALSE 19926
// begin lab := artifactsLabs [ 2 ] ;
19691: LD_ADDR_VAR 0 6
19695: PUSH
19696: LD_EXP 69
19700: PUSH
19701: LD_INT 2
19703: ARRAY
19704: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19705: LD_VAR 0 3
19709: PUSH
19710: LD_INT 81
19712: PUSH
19713: LD_INT 7
19715: PUSH
19716: EMPTY
19717: LIST
19718: LIST
19719: PUSH
19720: LD_INT 2
19722: PUSH
19723: LD_INT 32
19725: PUSH
19726: LD_INT 3
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: PUSH
19733: LD_INT 30
19735: PUSH
19736: LD_INT 28
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: PUSH
19743: LD_INT 30
19745: PUSH
19746: LD_INT 30
19748: PUSH
19749: EMPTY
19750: LIST
19751: LIST
19752: PUSH
19753: LD_INT 35
19755: PUSH
19756: LD_INT 49
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: LD_INT 34
19765: PUSH
19766: LD_INT 49
19768: PUSH
19769: EMPTY
19770: LIST
19771: LIST
19772: PUSH
19773: LD_INT 30
19775: PUSH
19776: LD_INT 21
19778: PUSH
19779: EMPTY
19780: LIST
19781: LIST
19782: PUSH
19783: EMPTY
19784: LIST
19785: LIST
19786: LIST
19787: LIST
19788: LIST
19789: LIST
19790: LIST
19791: PUSH
19792: EMPTY
19793: LIST
19794: LIST
19795: PPUSH
19796: CALL_OW 69
19800: IN
19801: NOT
19802: IFFALSE 19806
// exit ;
19804: GO 20193
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19806: LD_VAR 0 6
19810: PPUSH
19811: CALL_OW 274
19815: PPUSH
19816: CALL 86847 0 1
19820: PUSH
19821: LD_INT 3
19823: ARRAY
19824: PUSH
19825: LD_EXP 64
19829: PUSH
19830: LD_INT 2
19832: ARRAY
19833: LESS
19834: IFFALSE 19848
// begin HintSpec ( ArtifactCost , 2 ) ;
19836: LD_STRING ArtifactCost
19838: PPUSH
19839: LD_INT 2
19841: PPUSH
19842: CALL_OW 338
// exit ;
19846: GO 20193
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19848: LD_ADDR_EXP 71
19852: PUSH
19853: LD_EXP 71
19857: PPUSH
19858: LD_INT 2
19860: PPUSH
19861: LD_INT 0
19863: PPUSH
19864: CALL_OW 1
19868: ST_TO_ADDR
// KillUnit ( x ) ;
19869: LD_VAR 0 3
19873: PPUSH
19874: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19878: LD_ADDR_EXP 16
19882: PUSH
19883: LD_EXP 16
19887: PUSH
19888: LD_INT 1
19890: PLUS
19891: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19892: LD_EXP 63
19896: PUSH
19897: LD_INT 2
19899: ARRAY
19900: PPUSH
19901: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19905: LD_ADDR_EXP 71
19909: PUSH
19910: LD_EXP 71
19914: PPUSH
19915: LD_INT 2
19917: PPUSH
19918: LD_INT 1
19920: PPUSH
19921: CALL_OW 1
19925: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19926: LD_VAR 0 2
19930: PUSH
19931: LD_EXP 70
19935: PUSH
19936: LD_INT 3
19938: ARRAY
19939: PUSH
19940: LD_INT 1
19942: ARRAY
19943: EQUAL
19944: IFFALSE 20193
// begin lab := artifactsLabs [ 3 ] ;
19946: LD_ADDR_VAR 0 6
19950: PUSH
19951: LD_EXP 69
19955: PUSH
19956: LD_INT 3
19958: ARRAY
19959: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19960: LD_VAR 0 6
19964: PPUSH
19965: CALL_OW 274
19969: PPUSH
19970: CALL 86847 0 1
19974: PUSH
19975: LD_INT 3
19977: ARRAY
19978: PUSH
19979: LD_EXP 64
19983: PUSH
19984: LD_INT 3
19986: ARRAY
19987: LESS
19988: IFFALSE 20002
// begin HintSpec ( ArtifactCost , 2 ) ;
19990: LD_STRING ArtifactCost
19992: PPUSH
19993: LD_INT 2
19995: PPUSH
19996: CALL_OW 338
// exit ;
20000: GO 20193
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20002: LD_INT 37
20004: PPUSH
20005: LD_INT 1
20007: PPUSH
20008: CALL_OW 424
// time := 0 0$30 ;
20012: LD_ADDR_VAR 0 7
20016: PUSH
20017: LD_INT 1050
20019: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20020: LD_ADDR_EXP 71
20024: PUSH
20025: LD_EXP 71
20029: PPUSH
20030: LD_INT 3
20032: PPUSH
20033: LD_INT 0
20035: PPUSH
20036: CALL_OW 1
20040: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20041: LD_ADDR_OWVAR 47
20045: PUSH
20046: LD_STRING #Am15a-1
20048: PUSH
20049: LD_VAR 0 7
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20058: LD_INT 35
20060: PPUSH
20061: CALL_OW 67
// time := time - 0 0$1 ;
20065: LD_ADDR_VAR 0 7
20069: PUSH
20070: LD_VAR 0 7
20074: PUSH
20075: LD_INT 35
20077: MINUS
20078: ST_TO_ADDR
// until time = 0 0$00 ;
20079: LD_VAR 0 7
20083: PUSH
20084: LD_INT 0
20086: EQUAL
20087: IFFALSE 20041
// display_strings :=  ;
20089: LD_ADDR_OWVAR 47
20093: PUSH
20094: LD_STRING 
20096: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20097: LD_INT 37
20099: PPUSH
20100: LD_INT 0
20102: PPUSH
20103: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20107: LD_ADDR_VAR 0 8
20111: PUSH
20112: LD_INT 37
20114: PPUSH
20115: LD_INT 3
20117: PUSH
20118: LD_INT 21
20120: PUSH
20121: LD_INT 3
20123: PUSH
20124: EMPTY
20125: LIST
20126: LIST
20127: PUSH
20128: EMPTY
20129: LIST
20130: LIST
20131: PPUSH
20132: CALL_OW 70
20136: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20137: LD_VAR 0 3
20141: PPUSH
20142: LD_VAR 0 4
20146: PPUSH
20147: CALL_OW 84
// for un in list do
20151: LD_ADDR_VAR 0 9
20155: PUSH
20156: LD_VAR 0 8
20160: PUSH
20161: FOR_IN
20162: IFFALSE 20191
// TeleportUnit ( un , x , y , 12 , true ) ;
20164: LD_VAR 0 9
20168: PPUSH
20169: LD_VAR 0 3
20173: PPUSH
20174: LD_VAR 0 4
20178: PPUSH
20179: LD_INT 12
20181: PPUSH
20182: LD_INT 1
20184: PPUSH
20185: CALL_OW 483
20189: GO 20161
20191: POP
20192: POP
// end ; end ;
20193: PPOPN 9
20195: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20196: LD_INT 0
20198: PPUSH
20199: PPUSH
// begin labNum := 0 ;
20200: LD_ADDR_VAR 0 4
20204: PUSH
20205: LD_INT 0
20207: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20208: LD_ADDR_VAR 0 3
20212: PUSH
20213: DOUBLE
20214: LD_INT 1
20216: DEC
20217: ST_TO_ADDR
20218: LD_EXP 69
20222: PUSH
20223: FOR_TO
20224: IFFALSE 20258
// if artifactsLabs [ i ] = lab then
20226: LD_EXP 69
20230: PUSH
20231: LD_VAR 0 3
20235: ARRAY
20236: PUSH
20237: LD_VAR 0 1
20241: EQUAL
20242: IFFALSE 20256
// begin labNum := i ;
20244: LD_ADDR_VAR 0 4
20248: PUSH
20249: LD_VAR 0 3
20253: ST_TO_ADDR
// break ;
20254: GO 20258
// end ;
20256: GO 20223
20258: POP
20259: POP
// if not labNum then
20260: LD_VAR 0 4
20264: NOT
20265: IFFALSE 20269
// exit ;
20267: GO 20347
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20269: LD_INT 7
20271: PPUSH
20272: LD_EXP 70
20276: PUSH
20277: LD_VAR 0 4
20281: ARRAY
20282: PUSH
20283: LD_INT 3
20285: ARRAY
20286: PPUSH
20287: LD_INT 2
20289: PPUSH
20290: LD_VAR 0 1
20294: PPUSH
20295: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20299: LD_ADDR_EXP 68
20303: PUSH
20304: LD_EXP 68
20308: PPUSH
20309: LD_VAR 0 4
20313: PPUSH
20314: LD_VAR 0 2
20318: PPUSH
20319: CALL_OW 1
20323: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20324: LD_ADDR_EXP 66
20328: PUSH
20329: LD_EXP 66
20333: PPUSH
20334: LD_VAR 0 4
20338: PPUSH
20339: LD_INT 0
20341: PPUSH
20342: CALL_OW 1
20346: ST_TO_ADDR
// end ;
20347: PPOPN 4
20349: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20350: LD_INT 0
20352: PPUSH
20353: PPUSH
// begin labNum := 0 ;
20354: LD_ADDR_VAR 0 3
20358: PUSH
20359: LD_INT 0
20361: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20362: LD_ADDR_VAR 0 2
20366: PUSH
20367: DOUBLE
20368: LD_INT 1
20370: DEC
20371: ST_TO_ADDR
20372: LD_EXP 69
20376: PUSH
20377: FOR_TO
20378: IFFALSE 20412
// if artifactsLabs [ i ] = lab then
20380: LD_EXP 69
20384: PUSH
20385: LD_VAR 0 2
20389: ARRAY
20390: PUSH
20391: LD_VAR 0 1
20395: EQUAL
20396: IFFALSE 20410
// begin labNum := i ;
20398: LD_ADDR_VAR 0 3
20402: PUSH
20403: LD_VAR 0 2
20407: ST_TO_ADDR
// break ;
20408: GO 20412
// end ;
20410: GO 20377
20412: POP
20413: POP
// if not labNum then
20414: LD_VAR 0 3
20418: NOT
20419: IFFALSE 20423
// exit ;
20421: GO 20585
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20423: LD_INT 7
20425: PPUSH
20426: LD_EXP 70
20430: PUSH
20431: LD_VAR 0 3
20435: ARRAY
20436: PUSH
20437: LD_INT 3
20439: ARRAY
20440: PPUSH
20441: LD_INT 0
20443: PPUSH
20444: LD_VAR 0 1
20448: PPUSH
20449: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20453: LD_ADDR_EXP 65
20457: PUSH
20458: LD_EXP 65
20462: PPUSH
20463: LD_VAR 0 3
20467: PPUSH
20468: LD_INT 1
20470: PPUSH
20471: CALL_OW 1
20475: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20476: LD_ADDR_EXP 71
20480: PUSH
20481: LD_EXP 71
20485: PPUSH
20486: LD_VAR 0 3
20490: PPUSH
20491: LD_INT 1
20493: PPUSH
20494: CALL_OW 1
20498: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20499: LD_ADDR_EXP 66
20503: PUSH
20504: LD_EXP 66
20508: PPUSH
20509: LD_VAR 0 3
20513: PPUSH
20514: LD_INT 0
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// case labNum of 1 :
20522: LD_VAR 0 3
20526: PUSH
20527: LD_INT 1
20529: DOUBLE
20530: EQUAL
20531: IFTRUE 20535
20533: GO 20546
20535: POP
// artifactIResearched := true ; 2 :
20536: LD_ADDR_EXP 12
20540: PUSH
20541: LD_INT 1
20543: ST_TO_ADDR
20544: GO 20585
20546: LD_INT 2
20548: DOUBLE
20549: EQUAL
20550: IFTRUE 20554
20552: GO 20565
20554: POP
// artifactIIResearched := true ; 3 :
20555: LD_ADDR_EXP 13
20559: PUSH
20560: LD_INT 1
20562: ST_TO_ADDR
20563: GO 20585
20565: LD_INT 3
20567: DOUBLE
20568: EQUAL
20569: IFTRUE 20573
20571: GO 20584
20573: POP
// artifactIIIResearched := true ; end ;
20574: LD_ADDR_EXP 14
20578: PUSH
20579: LD_INT 1
20581: ST_TO_ADDR
20582: GO 20585
20584: POP
// end ; end_of_file
20585: PPOPN 3
20587: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
20588: LD_INT 0
20590: PPUSH
// ar_crane := 88 ;
20591: LD_ADDR_EXP 78
20595: PUSH
20596: LD_INT 88
20598: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20599: LD_ADDR_EXP 73
20603: PUSH
20604: LD_INT 89
20606: ST_TO_ADDR
// us_hack := 99 ;
20607: LD_ADDR_EXP 74
20611: PUSH
20612: LD_INT 99
20614: ST_TO_ADDR
// us_artillery := 97 ;
20615: LD_ADDR_EXP 75
20619: PUSH
20620: LD_INT 97
20622: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20623: LD_ADDR_EXP 76
20627: PUSH
20628: LD_INT 91
20630: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
20631: LD_ADDR_EXP 77
20635: PUSH
20636: LD_INT 92
20638: ST_TO_ADDR
// ru_radar := 98 ;
20639: LD_ADDR_EXP 72
20643: PUSH
20644: LD_INT 98
20646: ST_TO_ADDR
// tech_Artillery := 80 ;
20647: LD_ADDR_EXP 79
20651: PUSH
20652: LD_INT 80
20654: ST_TO_ADDR
// tech_RadMat := 81 ;
20655: LD_ADDR_EXP 80
20659: PUSH
20660: LD_INT 81
20662: ST_TO_ADDR
// tech_BasicTools := 82 ;
20663: LD_ADDR_EXP 81
20667: PUSH
20668: LD_INT 82
20670: ST_TO_ADDR
// tech_Cargo := 83 ;
20671: LD_ADDR_EXP 82
20675: PUSH
20676: LD_INT 83
20678: ST_TO_ADDR
// tech_Track := 84 ;
20679: LD_ADDR_EXP 83
20683: PUSH
20684: LD_INT 84
20686: ST_TO_ADDR
// tech_Crane := 85 ;
20687: LD_ADDR_EXP 84
20691: PUSH
20692: LD_INT 85
20694: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20695: LD_ADDR_EXP 85
20699: PUSH
20700: LD_INT 86
20702: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20703: LD_ADDR_EXP 86
20707: PUSH
20708: LD_INT 87
20710: ST_TO_ADDR
// end ;
20711: LD_VAR 0 1
20715: RET
// every 1 do
20716: GO 20718
20718: DISABLE
// InitGlobalVariables ; end_of_file
20719: CALL 20588 0 0
20723: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20724: LD_INT 0
20726: PPUSH
20727: PPUSH
// skirmish := false ;
20728: LD_ADDR_EXP 87
20732: PUSH
20733: LD_INT 0
20735: ST_TO_ADDR
// debug_mc := false ;
20736: LD_ADDR_EXP 88
20740: PUSH
20741: LD_INT 0
20743: ST_TO_ADDR
// mc_bases := [ ] ;
20744: LD_ADDR_EXP 89
20748: PUSH
20749: EMPTY
20750: ST_TO_ADDR
// mc_sides := [ ] ;
20751: LD_ADDR_EXP 115
20755: PUSH
20756: EMPTY
20757: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20758: LD_ADDR_EXP 90
20762: PUSH
20763: EMPTY
20764: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20765: LD_ADDR_EXP 91
20769: PUSH
20770: EMPTY
20771: ST_TO_ADDR
// mc_need_heal := [ ] ;
20772: LD_ADDR_EXP 92
20776: PUSH
20777: EMPTY
20778: ST_TO_ADDR
// mc_healers := [ ] ;
20779: LD_ADDR_EXP 93
20783: PUSH
20784: EMPTY
20785: ST_TO_ADDR
// mc_build_list := [ ] ;
20786: LD_ADDR_EXP 94
20790: PUSH
20791: EMPTY
20792: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20793: LD_ADDR_EXP 121
20797: PUSH
20798: EMPTY
20799: ST_TO_ADDR
// mc_builders := [ ] ;
20800: LD_ADDR_EXP 95
20804: PUSH
20805: EMPTY
20806: ST_TO_ADDR
// mc_construct_list := [ ] ;
20807: LD_ADDR_EXP 96
20811: PUSH
20812: EMPTY
20813: ST_TO_ADDR
// mc_turret_list := [ ] ;
20814: LD_ADDR_EXP 97
20818: PUSH
20819: EMPTY
20820: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20821: LD_ADDR_EXP 98
20825: PUSH
20826: EMPTY
20827: ST_TO_ADDR
// mc_miners := [ ] ;
20828: LD_ADDR_EXP 103
20832: PUSH
20833: EMPTY
20834: ST_TO_ADDR
// mc_mines := [ ] ;
20835: LD_ADDR_EXP 102
20839: PUSH
20840: EMPTY
20841: ST_TO_ADDR
// mc_minefields := [ ] ;
20842: LD_ADDR_EXP 104
20846: PUSH
20847: EMPTY
20848: ST_TO_ADDR
// mc_crates := [ ] ;
20849: LD_ADDR_EXP 105
20853: PUSH
20854: EMPTY
20855: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20856: LD_ADDR_EXP 106
20860: PUSH
20861: EMPTY
20862: ST_TO_ADDR
// mc_crates_area := [ ] ;
20863: LD_ADDR_EXP 107
20867: PUSH
20868: EMPTY
20869: ST_TO_ADDR
// mc_vehicles := [ ] ;
20870: LD_ADDR_EXP 108
20874: PUSH
20875: EMPTY
20876: ST_TO_ADDR
// mc_attack := [ ] ;
20877: LD_ADDR_EXP 109
20881: PUSH
20882: EMPTY
20883: ST_TO_ADDR
// mc_produce := [ ] ;
20884: LD_ADDR_EXP 110
20888: PUSH
20889: EMPTY
20890: ST_TO_ADDR
// mc_defender := [ ] ;
20891: LD_ADDR_EXP 111
20895: PUSH
20896: EMPTY
20897: ST_TO_ADDR
// mc_parking := [ ] ;
20898: LD_ADDR_EXP 113
20902: PUSH
20903: EMPTY
20904: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20905: LD_ADDR_EXP 99
20909: PUSH
20910: EMPTY
20911: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20912: LD_ADDR_EXP 101
20916: PUSH
20917: EMPTY
20918: ST_TO_ADDR
// mc_scan := [ ] ;
20919: LD_ADDR_EXP 112
20923: PUSH
20924: EMPTY
20925: ST_TO_ADDR
// mc_scan_area := [ ] ;
20926: LD_ADDR_EXP 114
20930: PUSH
20931: EMPTY
20932: ST_TO_ADDR
// mc_tech := [ ] ;
20933: LD_ADDR_EXP 116
20937: PUSH
20938: EMPTY
20939: ST_TO_ADDR
// mc_class := [ ] ;
20940: LD_ADDR_EXP 130
20944: PUSH
20945: EMPTY
20946: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20947: LD_ADDR_EXP 131
20951: PUSH
20952: EMPTY
20953: ST_TO_ADDR
// end ;
20954: LD_VAR 0 1
20958: RET
// export function MC_Kill ( base ) ; begin
20959: LD_INT 0
20961: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20962: LD_ADDR_EXP 89
20966: PUSH
20967: LD_EXP 89
20971: PPUSH
20972: LD_VAR 0 1
20976: PPUSH
20977: EMPTY
20978: PPUSH
20979: CALL_OW 1
20983: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20984: LD_ADDR_EXP 90
20988: PUSH
20989: LD_EXP 90
20993: PPUSH
20994: LD_VAR 0 1
20998: PPUSH
20999: EMPTY
21000: PPUSH
21001: CALL_OW 1
21005: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21006: LD_ADDR_EXP 91
21010: PUSH
21011: LD_EXP 91
21015: PPUSH
21016: LD_VAR 0 1
21020: PPUSH
21021: EMPTY
21022: PPUSH
21023: CALL_OW 1
21027: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21028: LD_ADDR_EXP 92
21032: PUSH
21033: LD_EXP 92
21037: PPUSH
21038: LD_VAR 0 1
21042: PPUSH
21043: EMPTY
21044: PPUSH
21045: CALL_OW 1
21049: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21050: LD_ADDR_EXP 93
21054: PUSH
21055: LD_EXP 93
21059: PPUSH
21060: LD_VAR 0 1
21064: PPUSH
21065: EMPTY
21066: PPUSH
21067: CALL_OW 1
21071: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21072: LD_ADDR_EXP 94
21076: PUSH
21077: LD_EXP 94
21081: PPUSH
21082: LD_VAR 0 1
21086: PPUSH
21087: EMPTY
21088: PPUSH
21089: CALL_OW 1
21093: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21094: LD_ADDR_EXP 95
21098: PUSH
21099: LD_EXP 95
21103: PPUSH
21104: LD_VAR 0 1
21108: PPUSH
21109: EMPTY
21110: PPUSH
21111: CALL_OW 1
21115: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21116: LD_ADDR_EXP 96
21120: PUSH
21121: LD_EXP 96
21125: PPUSH
21126: LD_VAR 0 1
21130: PPUSH
21131: EMPTY
21132: PPUSH
21133: CALL_OW 1
21137: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21138: LD_ADDR_EXP 97
21142: PUSH
21143: LD_EXP 97
21147: PPUSH
21148: LD_VAR 0 1
21152: PPUSH
21153: EMPTY
21154: PPUSH
21155: CALL_OW 1
21159: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21160: LD_ADDR_EXP 98
21164: PUSH
21165: LD_EXP 98
21169: PPUSH
21170: LD_VAR 0 1
21174: PPUSH
21175: EMPTY
21176: PPUSH
21177: CALL_OW 1
21181: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21182: LD_ADDR_EXP 99
21186: PUSH
21187: LD_EXP 99
21191: PPUSH
21192: LD_VAR 0 1
21196: PPUSH
21197: EMPTY
21198: PPUSH
21199: CALL_OW 1
21203: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21204: LD_ADDR_EXP 100
21208: PUSH
21209: LD_EXP 100
21213: PPUSH
21214: LD_VAR 0 1
21218: PPUSH
21219: LD_INT 0
21221: PPUSH
21222: CALL_OW 1
21226: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21227: LD_ADDR_EXP 101
21231: PUSH
21232: LD_EXP 101
21236: PPUSH
21237: LD_VAR 0 1
21241: PPUSH
21242: EMPTY
21243: PPUSH
21244: CALL_OW 1
21248: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21249: LD_ADDR_EXP 102
21253: PUSH
21254: LD_EXP 102
21258: PPUSH
21259: LD_VAR 0 1
21263: PPUSH
21264: EMPTY
21265: PPUSH
21266: CALL_OW 1
21270: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21271: LD_ADDR_EXP 103
21275: PUSH
21276: LD_EXP 103
21280: PPUSH
21281: LD_VAR 0 1
21285: PPUSH
21286: EMPTY
21287: PPUSH
21288: CALL_OW 1
21292: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21293: LD_ADDR_EXP 104
21297: PUSH
21298: LD_EXP 104
21302: PPUSH
21303: LD_VAR 0 1
21307: PPUSH
21308: EMPTY
21309: PPUSH
21310: CALL_OW 1
21314: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21315: LD_ADDR_EXP 105
21319: PUSH
21320: LD_EXP 105
21324: PPUSH
21325: LD_VAR 0 1
21329: PPUSH
21330: EMPTY
21331: PPUSH
21332: CALL_OW 1
21336: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21337: LD_ADDR_EXP 106
21341: PUSH
21342: LD_EXP 106
21346: PPUSH
21347: LD_VAR 0 1
21351: PPUSH
21352: EMPTY
21353: PPUSH
21354: CALL_OW 1
21358: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21359: LD_ADDR_EXP 107
21363: PUSH
21364: LD_EXP 107
21368: PPUSH
21369: LD_VAR 0 1
21373: PPUSH
21374: EMPTY
21375: PPUSH
21376: CALL_OW 1
21380: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21381: LD_ADDR_EXP 108
21385: PUSH
21386: LD_EXP 108
21390: PPUSH
21391: LD_VAR 0 1
21395: PPUSH
21396: EMPTY
21397: PPUSH
21398: CALL_OW 1
21402: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21403: LD_ADDR_EXP 109
21407: PUSH
21408: LD_EXP 109
21412: PPUSH
21413: LD_VAR 0 1
21417: PPUSH
21418: EMPTY
21419: PPUSH
21420: CALL_OW 1
21424: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21425: LD_ADDR_EXP 110
21429: PUSH
21430: LD_EXP 110
21434: PPUSH
21435: LD_VAR 0 1
21439: PPUSH
21440: EMPTY
21441: PPUSH
21442: CALL_OW 1
21446: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21447: LD_ADDR_EXP 111
21451: PUSH
21452: LD_EXP 111
21456: PPUSH
21457: LD_VAR 0 1
21461: PPUSH
21462: EMPTY
21463: PPUSH
21464: CALL_OW 1
21468: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21469: LD_ADDR_EXP 112
21473: PUSH
21474: LD_EXP 112
21478: PPUSH
21479: LD_VAR 0 1
21483: PPUSH
21484: EMPTY
21485: PPUSH
21486: CALL_OW 1
21490: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21491: LD_ADDR_EXP 113
21495: PUSH
21496: LD_EXP 113
21500: PPUSH
21501: LD_VAR 0 1
21505: PPUSH
21506: EMPTY
21507: PPUSH
21508: CALL_OW 1
21512: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21513: LD_ADDR_EXP 114
21517: PUSH
21518: LD_EXP 114
21522: PPUSH
21523: LD_VAR 0 1
21527: PPUSH
21528: EMPTY
21529: PPUSH
21530: CALL_OW 1
21534: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21535: LD_ADDR_EXP 116
21539: PUSH
21540: LD_EXP 116
21544: PPUSH
21545: LD_VAR 0 1
21549: PPUSH
21550: EMPTY
21551: PPUSH
21552: CALL_OW 1
21556: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21557: LD_ADDR_EXP 118
21561: PUSH
21562: LD_EXP 118
21566: PPUSH
21567: LD_VAR 0 1
21571: PPUSH
21572: EMPTY
21573: PPUSH
21574: CALL_OW 1
21578: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21579: LD_ADDR_EXP 119
21583: PUSH
21584: LD_EXP 119
21588: PPUSH
21589: LD_VAR 0 1
21593: PPUSH
21594: EMPTY
21595: PPUSH
21596: CALL_OW 1
21600: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21601: LD_ADDR_EXP 120
21605: PUSH
21606: LD_EXP 120
21610: PPUSH
21611: LD_VAR 0 1
21615: PPUSH
21616: EMPTY
21617: PPUSH
21618: CALL_OW 1
21622: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21623: LD_ADDR_EXP 121
21627: PUSH
21628: LD_EXP 121
21632: PPUSH
21633: LD_VAR 0 1
21637: PPUSH
21638: EMPTY
21639: PPUSH
21640: CALL_OW 1
21644: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21645: LD_ADDR_EXP 122
21649: PUSH
21650: LD_EXP 122
21654: PPUSH
21655: LD_VAR 0 1
21659: PPUSH
21660: EMPTY
21661: PPUSH
21662: CALL_OW 1
21666: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21667: LD_ADDR_EXP 123
21671: PUSH
21672: LD_EXP 123
21676: PPUSH
21677: LD_VAR 0 1
21681: PPUSH
21682: EMPTY
21683: PPUSH
21684: CALL_OW 1
21688: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21689: LD_ADDR_EXP 124
21693: PUSH
21694: LD_EXP 124
21698: PPUSH
21699: LD_VAR 0 1
21703: PPUSH
21704: EMPTY
21705: PPUSH
21706: CALL_OW 1
21710: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21711: LD_ADDR_EXP 125
21715: PUSH
21716: LD_EXP 125
21720: PPUSH
21721: LD_VAR 0 1
21725: PPUSH
21726: EMPTY
21727: PPUSH
21728: CALL_OW 1
21732: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21733: LD_ADDR_EXP 126
21737: PUSH
21738: LD_EXP 126
21742: PPUSH
21743: LD_VAR 0 1
21747: PPUSH
21748: EMPTY
21749: PPUSH
21750: CALL_OW 1
21754: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21755: LD_ADDR_EXP 127
21759: PUSH
21760: LD_EXP 127
21764: PPUSH
21765: LD_VAR 0 1
21769: PPUSH
21770: EMPTY
21771: PPUSH
21772: CALL_OW 1
21776: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21777: LD_ADDR_EXP 128
21781: PUSH
21782: LD_EXP 128
21786: PPUSH
21787: LD_VAR 0 1
21791: PPUSH
21792: EMPTY
21793: PPUSH
21794: CALL_OW 1
21798: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21799: LD_ADDR_EXP 129
21803: PUSH
21804: LD_EXP 129
21808: PPUSH
21809: LD_VAR 0 1
21813: PPUSH
21814: EMPTY
21815: PPUSH
21816: CALL_OW 1
21820: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21821: LD_ADDR_EXP 130
21825: PUSH
21826: LD_EXP 130
21830: PPUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: EMPTY
21837: PPUSH
21838: CALL_OW 1
21842: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21843: LD_ADDR_EXP 131
21847: PUSH
21848: LD_EXP 131
21852: PPUSH
21853: LD_VAR 0 1
21857: PPUSH
21858: LD_INT 0
21860: PPUSH
21861: CALL_OW 1
21865: ST_TO_ADDR
// end ;
21866: LD_VAR 0 2
21870: RET
// export function MC_Add ( side , units ) ; var base ; begin
21871: LD_INT 0
21873: PPUSH
21874: PPUSH
// base := mc_bases + 1 ;
21875: LD_ADDR_VAR 0 4
21879: PUSH
21880: LD_EXP 89
21884: PUSH
21885: LD_INT 1
21887: PLUS
21888: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21889: LD_ADDR_EXP 115
21893: PUSH
21894: LD_EXP 115
21898: PPUSH
21899: LD_VAR 0 4
21903: PPUSH
21904: LD_VAR 0 1
21908: PPUSH
21909: CALL_OW 1
21913: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21914: LD_ADDR_EXP 89
21918: PUSH
21919: LD_EXP 89
21923: PPUSH
21924: LD_VAR 0 4
21928: PPUSH
21929: LD_VAR 0 2
21933: PPUSH
21934: CALL_OW 1
21938: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21939: LD_ADDR_EXP 90
21943: PUSH
21944: LD_EXP 90
21948: PPUSH
21949: LD_VAR 0 4
21953: PPUSH
21954: EMPTY
21955: PPUSH
21956: CALL_OW 1
21960: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21961: LD_ADDR_EXP 91
21965: PUSH
21966: LD_EXP 91
21970: PPUSH
21971: LD_VAR 0 4
21975: PPUSH
21976: EMPTY
21977: PPUSH
21978: CALL_OW 1
21982: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21983: LD_ADDR_EXP 92
21987: PUSH
21988: LD_EXP 92
21992: PPUSH
21993: LD_VAR 0 4
21997: PPUSH
21998: EMPTY
21999: PPUSH
22000: CALL_OW 1
22004: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22005: LD_ADDR_EXP 93
22009: PUSH
22010: LD_EXP 93
22014: PPUSH
22015: LD_VAR 0 4
22019: PPUSH
22020: EMPTY
22021: PPUSH
22022: CALL_OW 1
22026: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22027: LD_ADDR_EXP 94
22031: PUSH
22032: LD_EXP 94
22036: PPUSH
22037: LD_VAR 0 4
22041: PPUSH
22042: EMPTY
22043: PPUSH
22044: CALL_OW 1
22048: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22049: LD_ADDR_EXP 95
22053: PUSH
22054: LD_EXP 95
22058: PPUSH
22059: LD_VAR 0 4
22063: PPUSH
22064: EMPTY
22065: PPUSH
22066: CALL_OW 1
22070: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22071: LD_ADDR_EXP 96
22075: PUSH
22076: LD_EXP 96
22080: PPUSH
22081: LD_VAR 0 4
22085: PPUSH
22086: EMPTY
22087: PPUSH
22088: CALL_OW 1
22092: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22093: LD_ADDR_EXP 97
22097: PUSH
22098: LD_EXP 97
22102: PPUSH
22103: LD_VAR 0 4
22107: PPUSH
22108: EMPTY
22109: PPUSH
22110: CALL_OW 1
22114: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22115: LD_ADDR_EXP 98
22119: PUSH
22120: LD_EXP 98
22124: PPUSH
22125: LD_VAR 0 4
22129: PPUSH
22130: EMPTY
22131: PPUSH
22132: CALL_OW 1
22136: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22137: LD_ADDR_EXP 99
22141: PUSH
22142: LD_EXP 99
22146: PPUSH
22147: LD_VAR 0 4
22151: PPUSH
22152: EMPTY
22153: PPUSH
22154: CALL_OW 1
22158: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22159: LD_ADDR_EXP 100
22163: PUSH
22164: LD_EXP 100
22168: PPUSH
22169: LD_VAR 0 4
22173: PPUSH
22174: LD_INT 0
22176: PPUSH
22177: CALL_OW 1
22181: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22182: LD_ADDR_EXP 101
22186: PUSH
22187: LD_EXP 101
22191: PPUSH
22192: LD_VAR 0 4
22196: PPUSH
22197: EMPTY
22198: PPUSH
22199: CALL_OW 1
22203: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22204: LD_ADDR_EXP 102
22208: PUSH
22209: LD_EXP 102
22213: PPUSH
22214: LD_VAR 0 4
22218: PPUSH
22219: EMPTY
22220: PPUSH
22221: CALL_OW 1
22225: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22226: LD_ADDR_EXP 103
22230: PUSH
22231: LD_EXP 103
22235: PPUSH
22236: LD_VAR 0 4
22240: PPUSH
22241: EMPTY
22242: PPUSH
22243: CALL_OW 1
22247: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22248: LD_ADDR_EXP 104
22252: PUSH
22253: LD_EXP 104
22257: PPUSH
22258: LD_VAR 0 4
22262: PPUSH
22263: EMPTY
22264: PPUSH
22265: CALL_OW 1
22269: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22270: LD_ADDR_EXP 105
22274: PUSH
22275: LD_EXP 105
22279: PPUSH
22280: LD_VAR 0 4
22284: PPUSH
22285: EMPTY
22286: PPUSH
22287: CALL_OW 1
22291: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22292: LD_ADDR_EXP 106
22296: PUSH
22297: LD_EXP 106
22301: PPUSH
22302: LD_VAR 0 4
22306: PPUSH
22307: EMPTY
22308: PPUSH
22309: CALL_OW 1
22313: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22314: LD_ADDR_EXP 107
22318: PUSH
22319: LD_EXP 107
22323: PPUSH
22324: LD_VAR 0 4
22328: PPUSH
22329: EMPTY
22330: PPUSH
22331: CALL_OW 1
22335: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22336: LD_ADDR_EXP 108
22340: PUSH
22341: LD_EXP 108
22345: PPUSH
22346: LD_VAR 0 4
22350: PPUSH
22351: EMPTY
22352: PPUSH
22353: CALL_OW 1
22357: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22358: LD_ADDR_EXP 109
22362: PUSH
22363: LD_EXP 109
22367: PPUSH
22368: LD_VAR 0 4
22372: PPUSH
22373: EMPTY
22374: PPUSH
22375: CALL_OW 1
22379: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22380: LD_ADDR_EXP 110
22384: PUSH
22385: LD_EXP 110
22389: PPUSH
22390: LD_VAR 0 4
22394: PPUSH
22395: EMPTY
22396: PPUSH
22397: CALL_OW 1
22401: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22402: LD_ADDR_EXP 111
22406: PUSH
22407: LD_EXP 111
22411: PPUSH
22412: LD_VAR 0 4
22416: PPUSH
22417: EMPTY
22418: PPUSH
22419: CALL_OW 1
22423: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22424: LD_ADDR_EXP 112
22428: PUSH
22429: LD_EXP 112
22433: PPUSH
22434: LD_VAR 0 4
22438: PPUSH
22439: EMPTY
22440: PPUSH
22441: CALL_OW 1
22445: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22446: LD_ADDR_EXP 113
22450: PUSH
22451: LD_EXP 113
22455: PPUSH
22456: LD_VAR 0 4
22460: PPUSH
22461: EMPTY
22462: PPUSH
22463: CALL_OW 1
22467: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22468: LD_ADDR_EXP 114
22472: PUSH
22473: LD_EXP 114
22477: PPUSH
22478: LD_VAR 0 4
22482: PPUSH
22483: EMPTY
22484: PPUSH
22485: CALL_OW 1
22489: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22490: LD_ADDR_EXP 116
22494: PUSH
22495: LD_EXP 116
22499: PPUSH
22500: LD_VAR 0 4
22504: PPUSH
22505: EMPTY
22506: PPUSH
22507: CALL_OW 1
22511: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22512: LD_ADDR_EXP 118
22516: PUSH
22517: LD_EXP 118
22521: PPUSH
22522: LD_VAR 0 4
22526: PPUSH
22527: EMPTY
22528: PPUSH
22529: CALL_OW 1
22533: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22534: LD_ADDR_EXP 119
22538: PUSH
22539: LD_EXP 119
22543: PPUSH
22544: LD_VAR 0 4
22548: PPUSH
22549: EMPTY
22550: PPUSH
22551: CALL_OW 1
22555: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22556: LD_ADDR_EXP 120
22560: PUSH
22561: LD_EXP 120
22565: PPUSH
22566: LD_VAR 0 4
22570: PPUSH
22571: EMPTY
22572: PPUSH
22573: CALL_OW 1
22577: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22578: LD_ADDR_EXP 121
22582: PUSH
22583: LD_EXP 121
22587: PPUSH
22588: LD_VAR 0 4
22592: PPUSH
22593: EMPTY
22594: PPUSH
22595: CALL_OW 1
22599: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22600: LD_ADDR_EXP 122
22604: PUSH
22605: LD_EXP 122
22609: PPUSH
22610: LD_VAR 0 4
22614: PPUSH
22615: EMPTY
22616: PPUSH
22617: CALL_OW 1
22621: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22622: LD_ADDR_EXP 123
22626: PUSH
22627: LD_EXP 123
22631: PPUSH
22632: LD_VAR 0 4
22636: PPUSH
22637: EMPTY
22638: PPUSH
22639: CALL_OW 1
22643: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22644: LD_ADDR_EXP 124
22648: PUSH
22649: LD_EXP 124
22653: PPUSH
22654: LD_VAR 0 4
22658: PPUSH
22659: EMPTY
22660: PPUSH
22661: CALL_OW 1
22665: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22666: LD_ADDR_EXP 125
22670: PUSH
22671: LD_EXP 125
22675: PPUSH
22676: LD_VAR 0 4
22680: PPUSH
22681: EMPTY
22682: PPUSH
22683: CALL_OW 1
22687: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22688: LD_ADDR_EXP 126
22692: PUSH
22693: LD_EXP 126
22697: PPUSH
22698: LD_VAR 0 4
22702: PPUSH
22703: EMPTY
22704: PPUSH
22705: CALL_OW 1
22709: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22710: LD_ADDR_EXP 127
22714: PUSH
22715: LD_EXP 127
22719: PPUSH
22720: LD_VAR 0 4
22724: PPUSH
22725: EMPTY
22726: PPUSH
22727: CALL_OW 1
22731: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22732: LD_ADDR_EXP 128
22736: PUSH
22737: LD_EXP 128
22741: PPUSH
22742: LD_VAR 0 4
22746: PPUSH
22747: EMPTY
22748: PPUSH
22749: CALL_OW 1
22753: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22754: LD_ADDR_EXP 129
22758: PUSH
22759: LD_EXP 129
22763: PPUSH
22764: LD_VAR 0 4
22768: PPUSH
22769: EMPTY
22770: PPUSH
22771: CALL_OW 1
22775: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22776: LD_ADDR_EXP 130
22780: PUSH
22781: LD_EXP 130
22785: PPUSH
22786: LD_VAR 0 4
22790: PPUSH
22791: EMPTY
22792: PPUSH
22793: CALL_OW 1
22797: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22798: LD_ADDR_EXP 131
22802: PUSH
22803: LD_EXP 131
22807: PPUSH
22808: LD_VAR 0 4
22812: PPUSH
22813: LD_INT 0
22815: PPUSH
22816: CALL_OW 1
22820: ST_TO_ADDR
// result := base ;
22821: LD_ADDR_VAR 0 3
22825: PUSH
22826: LD_VAR 0 4
22830: ST_TO_ADDR
// end ;
22831: LD_VAR 0 3
22835: RET
// export function MC_Start ( ) ; var i ; begin
22836: LD_INT 0
22838: PPUSH
22839: PPUSH
// for i = 1 to mc_bases do
22840: LD_ADDR_VAR 0 2
22844: PUSH
22845: DOUBLE
22846: LD_INT 1
22848: DEC
22849: ST_TO_ADDR
22850: LD_EXP 89
22854: PUSH
22855: FOR_TO
22856: IFFALSE 23933
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22858: LD_ADDR_EXP 89
22862: PUSH
22863: LD_EXP 89
22867: PPUSH
22868: LD_VAR 0 2
22872: PPUSH
22873: LD_EXP 89
22877: PUSH
22878: LD_VAR 0 2
22882: ARRAY
22883: PUSH
22884: LD_INT 0
22886: DIFF
22887: PPUSH
22888: CALL_OW 1
22892: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22893: LD_ADDR_EXP 90
22897: PUSH
22898: LD_EXP 90
22902: PPUSH
22903: LD_VAR 0 2
22907: PPUSH
22908: EMPTY
22909: PPUSH
22910: CALL_OW 1
22914: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22915: LD_ADDR_EXP 91
22919: PUSH
22920: LD_EXP 91
22924: PPUSH
22925: LD_VAR 0 2
22929: PPUSH
22930: EMPTY
22931: PPUSH
22932: CALL_OW 1
22936: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22937: LD_ADDR_EXP 92
22941: PUSH
22942: LD_EXP 92
22946: PPUSH
22947: LD_VAR 0 2
22951: PPUSH
22952: EMPTY
22953: PPUSH
22954: CALL_OW 1
22958: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22959: LD_ADDR_EXP 93
22963: PUSH
22964: LD_EXP 93
22968: PPUSH
22969: LD_VAR 0 2
22973: PPUSH
22974: EMPTY
22975: PUSH
22976: EMPTY
22977: PUSH
22978: EMPTY
22979: LIST
22980: LIST
22981: PPUSH
22982: CALL_OW 1
22986: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22987: LD_ADDR_EXP 94
22991: PUSH
22992: LD_EXP 94
22996: PPUSH
22997: LD_VAR 0 2
23001: PPUSH
23002: EMPTY
23003: PPUSH
23004: CALL_OW 1
23008: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23009: LD_ADDR_EXP 121
23013: PUSH
23014: LD_EXP 121
23018: PPUSH
23019: LD_VAR 0 2
23023: PPUSH
23024: EMPTY
23025: PPUSH
23026: CALL_OW 1
23030: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23031: LD_ADDR_EXP 95
23035: PUSH
23036: LD_EXP 95
23040: PPUSH
23041: LD_VAR 0 2
23045: PPUSH
23046: EMPTY
23047: PPUSH
23048: CALL_OW 1
23052: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23053: LD_ADDR_EXP 96
23057: PUSH
23058: LD_EXP 96
23062: PPUSH
23063: LD_VAR 0 2
23067: PPUSH
23068: EMPTY
23069: PPUSH
23070: CALL_OW 1
23074: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23075: LD_ADDR_EXP 97
23079: PUSH
23080: LD_EXP 97
23084: PPUSH
23085: LD_VAR 0 2
23089: PPUSH
23090: LD_EXP 89
23094: PUSH
23095: LD_VAR 0 2
23099: ARRAY
23100: PPUSH
23101: LD_INT 2
23103: PUSH
23104: LD_INT 30
23106: PUSH
23107: LD_INT 32
23109: PUSH
23110: EMPTY
23111: LIST
23112: LIST
23113: PUSH
23114: LD_INT 30
23116: PUSH
23117: LD_INT 33
23119: PUSH
23120: EMPTY
23121: LIST
23122: LIST
23123: PUSH
23124: EMPTY
23125: LIST
23126: LIST
23127: LIST
23128: PPUSH
23129: CALL_OW 72
23133: PPUSH
23134: CALL_OW 1
23138: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23139: LD_ADDR_EXP 98
23143: PUSH
23144: LD_EXP 98
23148: PPUSH
23149: LD_VAR 0 2
23153: PPUSH
23154: LD_EXP 89
23158: PUSH
23159: LD_VAR 0 2
23163: ARRAY
23164: PPUSH
23165: LD_INT 2
23167: PUSH
23168: LD_INT 30
23170: PUSH
23171: LD_INT 32
23173: PUSH
23174: EMPTY
23175: LIST
23176: LIST
23177: PUSH
23178: LD_INT 30
23180: PUSH
23181: LD_INT 31
23183: PUSH
23184: EMPTY
23185: LIST
23186: LIST
23187: PUSH
23188: EMPTY
23189: LIST
23190: LIST
23191: LIST
23192: PUSH
23193: LD_INT 58
23195: PUSH
23196: EMPTY
23197: LIST
23198: PUSH
23199: EMPTY
23200: LIST
23201: LIST
23202: PPUSH
23203: CALL_OW 72
23207: PPUSH
23208: CALL_OW 1
23212: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23213: LD_ADDR_EXP 99
23217: PUSH
23218: LD_EXP 99
23222: PPUSH
23223: LD_VAR 0 2
23227: PPUSH
23228: EMPTY
23229: PPUSH
23230: CALL_OW 1
23234: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23235: LD_ADDR_EXP 103
23239: PUSH
23240: LD_EXP 103
23244: PPUSH
23245: LD_VAR 0 2
23249: PPUSH
23250: EMPTY
23251: PPUSH
23252: CALL_OW 1
23256: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23257: LD_ADDR_EXP 102
23261: PUSH
23262: LD_EXP 102
23266: PPUSH
23267: LD_VAR 0 2
23271: PPUSH
23272: EMPTY
23273: PPUSH
23274: CALL_OW 1
23278: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23279: LD_ADDR_EXP 104
23283: PUSH
23284: LD_EXP 104
23288: PPUSH
23289: LD_VAR 0 2
23293: PPUSH
23294: EMPTY
23295: PPUSH
23296: CALL_OW 1
23300: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23301: LD_ADDR_EXP 105
23305: PUSH
23306: LD_EXP 105
23310: PPUSH
23311: LD_VAR 0 2
23315: PPUSH
23316: EMPTY
23317: PPUSH
23318: CALL_OW 1
23322: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23323: LD_ADDR_EXP 106
23327: PUSH
23328: LD_EXP 106
23332: PPUSH
23333: LD_VAR 0 2
23337: PPUSH
23338: EMPTY
23339: PPUSH
23340: CALL_OW 1
23344: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23345: LD_ADDR_EXP 107
23349: PUSH
23350: LD_EXP 107
23354: PPUSH
23355: LD_VAR 0 2
23359: PPUSH
23360: EMPTY
23361: PPUSH
23362: CALL_OW 1
23366: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23367: LD_ADDR_EXP 108
23371: PUSH
23372: LD_EXP 108
23376: PPUSH
23377: LD_VAR 0 2
23381: PPUSH
23382: EMPTY
23383: PPUSH
23384: CALL_OW 1
23388: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23389: LD_ADDR_EXP 109
23393: PUSH
23394: LD_EXP 109
23398: PPUSH
23399: LD_VAR 0 2
23403: PPUSH
23404: EMPTY
23405: PPUSH
23406: CALL_OW 1
23410: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23411: LD_ADDR_EXP 110
23415: PUSH
23416: LD_EXP 110
23420: PPUSH
23421: LD_VAR 0 2
23425: PPUSH
23426: EMPTY
23427: PPUSH
23428: CALL_OW 1
23432: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23433: LD_ADDR_EXP 111
23437: PUSH
23438: LD_EXP 111
23442: PPUSH
23443: LD_VAR 0 2
23447: PPUSH
23448: EMPTY
23449: PPUSH
23450: CALL_OW 1
23454: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23455: LD_ADDR_EXP 100
23459: PUSH
23460: LD_EXP 100
23464: PPUSH
23465: LD_VAR 0 2
23469: PPUSH
23470: LD_INT 0
23472: PPUSH
23473: CALL_OW 1
23477: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23478: LD_ADDR_EXP 113
23482: PUSH
23483: LD_EXP 113
23487: PPUSH
23488: LD_VAR 0 2
23492: PPUSH
23493: LD_INT 0
23495: PPUSH
23496: CALL_OW 1
23500: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23501: LD_ADDR_EXP 101
23505: PUSH
23506: LD_EXP 101
23510: PPUSH
23511: LD_VAR 0 2
23515: PPUSH
23516: EMPTY
23517: PPUSH
23518: CALL_OW 1
23522: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23523: LD_ADDR_EXP 112
23527: PUSH
23528: LD_EXP 112
23532: PPUSH
23533: LD_VAR 0 2
23537: PPUSH
23538: LD_INT 0
23540: PPUSH
23541: CALL_OW 1
23545: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23546: LD_ADDR_EXP 114
23550: PUSH
23551: LD_EXP 114
23555: PPUSH
23556: LD_VAR 0 2
23560: PPUSH
23561: EMPTY
23562: PPUSH
23563: CALL_OW 1
23567: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23568: LD_ADDR_EXP 117
23572: PUSH
23573: LD_EXP 117
23577: PPUSH
23578: LD_VAR 0 2
23582: PPUSH
23583: LD_INT 0
23585: PPUSH
23586: CALL_OW 1
23590: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23591: LD_ADDR_EXP 118
23595: PUSH
23596: LD_EXP 118
23600: PPUSH
23601: LD_VAR 0 2
23605: PPUSH
23606: EMPTY
23607: PPUSH
23608: CALL_OW 1
23612: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23613: LD_ADDR_EXP 119
23617: PUSH
23618: LD_EXP 119
23622: PPUSH
23623: LD_VAR 0 2
23627: PPUSH
23628: EMPTY
23629: PPUSH
23630: CALL_OW 1
23634: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23635: LD_ADDR_EXP 120
23639: PUSH
23640: LD_EXP 120
23644: PPUSH
23645: LD_VAR 0 2
23649: PPUSH
23650: EMPTY
23651: PPUSH
23652: CALL_OW 1
23656: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23657: LD_ADDR_EXP 122
23661: PUSH
23662: LD_EXP 122
23666: PPUSH
23667: LD_VAR 0 2
23671: PPUSH
23672: LD_EXP 89
23676: PUSH
23677: LD_VAR 0 2
23681: ARRAY
23682: PPUSH
23683: LD_INT 2
23685: PUSH
23686: LD_INT 30
23688: PUSH
23689: LD_INT 6
23691: PUSH
23692: EMPTY
23693: LIST
23694: LIST
23695: PUSH
23696: LD_INT 30
23698: PUSH
23699: LD_INT 7
23701: PUSH
23702: EMPTY
23703: LIST
23704: LIST
23705: PUSH
23706: LD_INT 30
23708: PUSH
23709: LD_INT 8
23711: PUSH
23712: EMPTY
23713: LIST
23714: LIST
23715: PUSH
23716: EMPTY
23717: LIST
23718: LIST
23719: LIST
23720: LIST
23721: PPUSH
23722: CALL_OW 72
23726: PPUSH
23727: CALL_OW 1
23731: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23732: LD_ADDR_EXP 123
23736: PUSH
23737: LD_EXP 123
23741: PPUSH
23742: LD_VAR 0 2
23746: PPUSH
23747: EMPTY
23748: PPUSH
23749: CALL_OW 1
23753: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23754: LD_ADDR_EXP 124
23758: PUSH
23759: LD_EXP 124
23763: PPUSH
23764: LD_VAR 0 2
23768: PPUSH
23769: EMPTY
23770: PPUSH
23771: CALL_OW 1
23775: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23776: LD_ADDR_EXP 125
23780: PUSH
23781: LD_EXP 125
23785: PPUSH
23786: LD_VAR 0 2
23790: PPUSH
23791: EMPTY
23792: PPUSH
23793: CALL_OW 1
23797: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23798: LD_ADDR_EXP 126
23802: PUSH
23803: LD_EXP 126
23807: PPUSH
23808: LD_VAR 0 2
23812: PPUSH
23813: EMPTY
23814: PPUSH
23815: CALL_OW 1
23819: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23820: LD_ADDR_EXP 127
23824: PUSH
23825: LD_EXP 127
23829: PPUSH
23830: LD_VAR 0 2
23834: PPUSH
23835: EMPTY
23836: PPUSH
23837: CALL_OW 1
23841: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23842: LD_ADDR_EXP 128
23846: PUSH
23847: LD_EXP 128
23851: PPUSH
23852: LD_VAR 0 2
23856: PPUSH
23857: EMPTY
23858: PPUSH
23859: CALL_OW 1
23863: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23864: LD_ADDR_EXP 129
23868: PUSH
23869: LD_EXP 129
23873: PPUSH
23874: LD_VAR 0 2
23878: PPUSH
23879: EMPTY
23880: PPUSH
23881: CALL_OW 1
23885: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23886: LD_ADDR_EXP 130
23890: PUSH
23891: LD_EXP 130
23895: PPUSH
23896: LD_VAR 0 2
23900: PPUSH
23901: EMPTY
23902: PPUSH
23903: CALL_OW 1
23907: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23908: LD_ADDR_EXP 131
23912: PUSH
23913: LD_EXP 131
23917: PPUSH
23918: LD_VAR 0 2
23922: PPUSH
23923: LD_INT 0
23925: PPUSH
23926: CALL_OW 1
23930: ST_TO_ADDR
// end ;
23931: GO 22855
23933: POP
23934: POP
// MC_InitSides ( ) ;
23935: CALL 24221 0 0
// MC_InitResearch ( ) ;
23939: CALL 23960 0 0
// CustomInitMacro ( ) ;
23943: CALL 213 0 0
// skirmish := true ;
23947: LD_ADDR_EXP 87
23951: PUSH
23952: LD_INT 1
23954: ST_TO_ADDR
// end ;
23955: LD_VAR 0 1
23959: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23960: LD_INT 0
23962: PPUSH
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
// if not mc_bases then
23968: LD_EXP 89
23972: NOT
23973: IFFALSE 23977
// exit ;
23975: GO 24216
// for i = 1 to 8 do
23977: LD_ADDR_VAR 0 2
23981: PUSH
23982: DOUBLE
23983: LD_INT 1
23985: DEC
23986: ST_TO_ADDR
23987: LD_INT 8
23989: PUSH
23990: FOR_TO
23991: IFFALSE 24017
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23993: LD_ADDR_EXP 116
23997: PUSH
23998: LD_EXP 116
24002: PPUSH
24003: LD_VAR 0 2
24007: PPUSH
24008: EMPTY
24009: PPUSH
24010: CALL_OW 1
24014: ST_TO_ADDR
24015: GO 23990
24017: POP
24018: POP
// tmp := [ ] ;
24019: LD_ADDR_VAR 0 5
24023: PUSH
24024: EMPTY
24025: ST_TO_ADDR
// for i = 1 to mc_sides do
24026: LD_ADDR_VAR 0 2
24030: PUSH
24031: DOUBLE
24032: LD_INT 1
24034: DEC
24035: ST_TO_ADDR
24036: LD_EXP 115
24040: PUSH
24041: FOR_TO
24042: IFFALSE 24100
// if not mc_sides [ i ] in tmp then
24044: LD_EXP 115
24048: PUSH
24049: LD_VAR 0 2
24053: ARRAY
24054: PUSH
24055: LD_VAR 0 5
24059: IN
24060: NOT
24061: IFFALSE 24098
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24063: LD_ADDR_VAR 0 5
24067: PUSH
24068: LD_VAR 0 5
24072: PPUSH
24073: LD_VAR 0 5
24077: PUSH
24078: LD_INT 1
24080: PLUS
24081: PPUSH
24082: LD_EXP 115
24086: PUSH
24087: LD_VAR 0 2
24091: ARRAY
24092: PPUSH
24093: CALL_OW 2
24097: ST_TO_ADDR
24098: GO 24041
24100: POP
24101: POP
// if not tmp then
24102: LD_VAR 0 5
24106: NOT
24107: IFFALSE 24111
// exit ;
24109: GO 24216
// for j in tmp do
24111: LD_ADDR_VAR 0 3
24115: PUSH
24116: LD_VAR 0 5
24120: PUSH
24121: FOR_IN
24122: IFFALSE 24214
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24124: LD_ADDR_VAR 0 6
24128: PUSH
24129: LD_INT 22
24131: PUSH
24132: LD_VAR 0 3
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: PPUSH
24141: CALL_OW 69
24145: ST_TO_ADDR
// if not un then
24146: LD_VAR 0 6
24150: NOT
24151: IFFALSE 24155
// continue ;
24153: GO 24121
// nation := GetNation ( un [ 1 ] ) ;
24155: LD_ADDR_VAR 0 4
24159: PUSH
24160: LD_VAR 0 6
24164: PUSH
24165: LD_INT 1
24167: ARRAY
24168: PPUSH
24169: CALL_OW 248
24173: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24174: LD_ADDR_EXP 116
24178: PUSH
24179: LD_EXP 116
24183: PPUSH
24184: LD_VAR 0 3
24188: PPUSH
24189: LD_VAR 0 3
24193: PPUSH
24194: LD_VAR 0 4
24198: PPUSH
24199: LD_INT 1
24201: PPUSH
24202: CALL 50810 0 3
24206: PPUSH
24207: CALL_OW 1
24211: ST_TO_ADDR
// end ;
24212: GO 24121
24214: POP
24215: POP
// end ;
24216: LD_VAR 0 1
24220: RET
// export function MC_InitSides ( ) ; var i ; begin
24221: LD_INT 0
24223: PPUSH
24224: PPUSH
// if not mc_bases then
24225: LD_EXP 89
24229: NOT
24230: IFFALSE 24234
// exit ;
24232: GO 24308
// for i = 1 to mc_bases do
24234: LD_ADDR_VAR 0 2
24238: PUSH
24239: DOUBLE
24240: LD_INT 1
24242: DEC
24243: ST_TO_ADDR
24244: LD_EXP 89
24248: PUSH
24249: FOR_TO
24250: IFFALSE 24306
// if mc_bases [ i ] then
24252: LD_EXP 89
24256: PUSH
24257: LD_VAR 0 2
24261: ARRAY
24262: IFFALSE 24304
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24264: LD_ADDR_EXP 115
24268: PUSH
24269: LD_EXP 115
24273: PPUSH
24274: LD_VAR 0 2
24278: PPUSH
24279: LD_EXP 89
24283: PUSH
24284: LD_VAR 0 2
24288: ARRAY
24289: PUSH
24290: LD_INT 1
24292: ARRAY
24293: PPUSH
24294: CALL_OW 255
24298: PPUSH
24299: CALL_OW 1
24303: ST_TO_ADDR
24304: GO 24249
24306: POP
24307: POP
// end ;
24308: LD_VAR 0 1
24312: RET
// every 0 0$01 trigger skirmish do
24313: LD_EXP 87
24317: IFFALSE 24471
24319: GO 24321
24321: DISABLE
// begin enable ;
24322: ENABLE
// MC_CheckBuildings ( ) ;
24323: CALL 28969 0 0
// MC_CheckPeopleLife ( ) ;
24327: CALL 29094 0 0
// RaiseSailEvent ( 100 ) ;
24331: LD_INT 100
24333: PPUSH
24334: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24338: LD_INT 103
24340: PPUSH
24341: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24345: LD_INT 104
24347: PPUSH
24348: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24352: LD_INT 105
24354: PPUSH
24355: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24359: LD_INT 106
24361: PPUSH
24362: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24366: LD_INT 107
24368: PPUSH
24369: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24373: LD_INT 108
24375: PPUSH
24376: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24380: LD_INT 109
24382: PPUSH
24383: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24387: LD_INT 110
24389: PPUSH
24390: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24394: LD_INT 111
24396: PPUSH
24397: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24401: LD_INT 112
24403: PPUSH
24404: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24408: LD_INT 113
24410: PPUSH
24411: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24415: LD_INT 120
24417: PPUSH
24418: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24422: LD_INT 121
24424: PPUSH
24425: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24429: LD_INT 122
24431: PPUSH
24432: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24436: LD_INT 123
24438: PPUSH
24439: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24443: LD_INT 124
24445: PPUSH
24446: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24450: LD_INT 125
24452: PPUSH
24453: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24457: LD_INT 126
24459: PPUSH
24460: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24464: LD_INT 200
24466: PPUSH
24467: CALL_OW 427
// end ;
24471: END
// on SailEvent ( event ) do begin if event < 100 then
24472: LD_VAR 0 1
24476: PUSH
24477: LD_INT 100
24479: LESS
24480: IFFALSE 24491
// CustomEvent ( event ) ;
24482: LD_VAR 0 1
24486: PPUSH
24487: CALL 10371 0 1
// if event = 100 then
24491: LD_VAR 0 1
24495: PUSH
24496: LD_INT 100
24498: EQUAL
24499: IFFALSE 24505
// MC_ClassManager ( ) ;
24501: CALL 24897 0 0
// if event = 101 then
24505: LD_VAR 0 1
24509: PUSH
24510: LD_INT 101
24512: EQUAL
24513: IFFALSE 24519
// MC_RepairBuildings ( ) ;
24515: CALL 29679 0 0
// if event = 102 then
24519: LD_VAR 0 1
24523: PUSH
24524: LD_INT 102
24526: EQUAL
24527: IFFALSE 24533
// MC_Heal ( ) ;
24529: CALL 30538 0 0
// if event = 103 then
24533: LD_VAR 0 1
24537: PUSH
24538: LD_INT 103
24540: EQUAL
24541: IFFALSE 24547
// MC_Build ( ) ;
24543: CALL 30960 0 0
// if event = 104 then
24547: LD_VAR 0 1
24551: PUSH
24552: LD_INT 104
24554: EQUAL
24555: IFFALSE 24561
// MC_TurretWeapon ( ) ;
24557: CALL 32573 0 0
// if event = 105 then
24561: LD_VAR 0 1
24565: PUSH
24566: LD_INT 105
24568: EQUAL
24569: IFFALSE 24575
// MC_BuildUpgrade ( ) ;
24571: CALL 32124 0 0
// if event = 106 then
24575: LD_VAR 0 1
24579: PUSH
24580: LD_INT 106
24582: EQUAL
24583: IFFALSE 24589
// MC_PlantMines ( ) ;
24585: CALL 33003 0 0
// if event = 107 then
24589: LD_VAR 0 1
24593: PUSH
24594: LD_INT 107
24596: EQUAL
24597: IFFALSE 24603
// MC_CollectCrates ( ) ;
24599: CALL 33801 0 0
// if event = 108 then
24603: LD_VAR 0 1
24607: PUSH
24608: LD_INT 108
24610: EQUAL
24611: IFFALSE 24617
// MC_LinkRemoteControl ( ) ;
24613: CALL 35577 0 0
// if event = 109 then
24617: LD_VAR 0 1
24621: PUSH
24622: LD_INT 109
24624: EQUAL
24625: IFFALSE 24631
// MC_ProduceVehicle ( ) ;
24627: CALL 35758 0 0
// if event = 110 then
24631: LD_VAR 0 1
24635: PUSH
24636: LD_INT 110
24638: EQUAL
24639: IFFALSE 24645
// MC_SendAttack ( ) ;
24641: CALL 36224 0 0
// if event = 111 then
24645: LD_VAR 0 1
24649: PUSH
24650: LD_INT 111
24652: EQUAL
24653: IFFALSE 24659
// MC_Defend ( ) ;
24655: CALL 36332 0 0
// if event = 112 then
24659: LD_VAR 0 1
24663: PUSH
24664: LD_INT 112
24666: EQUAL
24667: IFFALSE 24673
// MC_Research ( ) ;
24669: CALL 36937 0 0
// if event = 113 then
24673: LD_VAR 0 1
24677: PUSH
24678: LD_INT 113
24680: EQUAL
24681: IFFALSE 24687
// MC_MinesTrigger ( ) ;
24683: CALL 38051 0 0
// if event = 120 then
24687: LD_VAR 0 1
24691: PUSH
24692: LD_INT 120
24694: EQUAL
24695: IFFALSE 24701
// MC_RepairVehicle ( ) ;
24697: CALL 38150 0 0
// if event = 121 then
24701: LD_VAR 0 1
24705: PUSH
24706: LD_INT 121
24708: EQUAL
24709: IFFALSE 24715
// MC_TameApe ( ) ;
24711: CALL 38880 0 0
// if event = 122 then
24715: LD_VAR 0 1
24719: PUSH
24720: LD_INT 122
24722: EQUAL
24723: IFFALSE 24729
// MC_ChangeApeClass ( ) ;
24725: CALL 39709 0 0
// if event = 123 then
24729: LD_VAR 0 1
24733: PUSH
24734: LD_INT 123
24736: EQUAL
24737: IFFALSE 24743
// MC_Bazooka ( ) ;
24739: CALL 40359 0 0
// if event = 124 then
24743: LD_VAR 0 1
24747: PUSH
24748: LD_INT 124
24750: EQUAL
24751: IFFALSE 24757
// MC_TeleportExit ( ) ;
24753: CALL 40557 0 0
// if event = 125 then
24757: LD_VAR 0 1
24761: PUSH
24762: LD_INT 125
24764: EQUAL
24765: IFFALSE 24771
// MC_Deposits ( ) ;
24767: CALL 41204 0 0
// if event = 126 then
24771: LD_VAR 0 1
24775: PUSH
24776: LD_INT 126
24778: EQUAL
24779: IFFALSE 24785
// MC_RemoteDriver ( ) ;
24781: CALL 41829 0 0
// if event = 200 then
24785: LD_VAR 0 1
24789: PUSH
24790: LD_INT 200
24792: EQUAL
24793: IFFALSE 24799
// MC_Idle ( ) ;
24795: CALL 43778 0 0
// end ;
24799: PPOPN 1
24801: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24802: LD_INT 0
24804: PPUSH
24805: PPUSH
// if not mc_bases [ base ] or not tag then
24806: LD_EXP 89
24810: PUSH
24811: LD_VAR 0 1
24815: ARRAY
24816: NOT
24817: PUSH
24818: LD_VAR 0 2
24822: NOT
24823: OR
24824: IFFALSE 24828
// exit ;
24826: GO 24892
// for i in mc_bases [ base ] union mc_ape [ base ] do
24828: LD_ADDR_VAR 0 4
24832: PUSH
24833: LD_EXP 89
24837: PUSH
24838: LD_VAR 0 1
24842: ARRAY
24843: PUSH
24844: LD_EXP 118
24848: PUSH
24849: LD_VAR 0 1
24853: ARRAY
24854: UNION
24855: PUSH
24856: FOR_IN
24857: IFFALSE 24890
// if GetTag ( i ) = tag then
24859: LD_VAR 0 4
24863: PPUSH
24864: CALL_OW 110
24868: PUSH
24869: LD_VAR 0 2
24873: EQUAL
24874: IFFALSE 24888
// SetTag ( i , 0 ) ;
24876: LD_VAR 0 4
24880: PPUSH
24881: LD_INT 0
24883: PPUSH
24884: CALL_OW 109
24888: GO 24856
24890: POP
24891: POP
// end ;
24892: LD_VAR 0 3
24896: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24897: LD_INT 0
24899: PPUSH
24900: PPUSH
24901: PPUSH
24902: PPUSH
24903: PPUSH
24904: PPUSH
24905: PPUSH
24906: PPUSH
// if not mc_bases then
24907: LD_EXP 89
24911: NOT
24912: IFFALSE 24916
// exit ;
24914: GO 25374
// for i = 1 to mc_bases do
24916: LD_ADDR_VAR 0 2
24920: PUSH
24921: DOUBLE
24922: LD_INT 1
24924: DEC
24925: ST_TO_ADDR
24926: LD_EXP 89
24930: PUSH
24931: FOR_TO
24932: IFFALSE 25372
// begin tmp := MC_ClassCheckReq ( i ) ;
24934: LD_ADDR_VAR 0 4
24938: PUSH
24939: LD_VAR 0 2
24943: PPUSH
24944: CALL 25379 0 1
24948: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24949: LD_ADDR_EXP 130
24953: PUSH
24954: LD_EXP 130
24958: PPUSH
24959: LD_VAR 0 2
24963: PPUSH
24964: LD_VAR 0 4
24968: PPUSH
24969: CALL_OW 1
24973: ST_TO_ADDR
// if not tmp then
24974: LD_VAR 0 4
24978: NOT
24979: IFFALSE 24983
// continue ;
24981: GO 24931
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24983: LD_ADDR_VAR 0 6
24987: PUSH
24988: LD_EXP 89
24992: PUSH
24993: LD_VAR 0 2
24997: ARRAY
24998: PPUSH
24999: LD_INT 2
25001: PUSH
25002: LD_INT 30
25004: PUSH
25005: LD_INT 4
25007: PUSH
25008: EMPTY
25009: LIST
25010: LIST
25011: PUSH
25012: LD_INT 30
25014: PUSH
25015: LD_INT 5
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: LIST
25026: PPUSH
25027: CALL_OW 72
25031: PUSH
25032: LD_EXP 89
25036: PUSH
25037: LD_VAR 0 2
25041: ARRAY
25042: PPUSH
25043: LD_INT 2
25045: PUSH
25046: LD_INT 30
25048: PUSH
25049: LD_INT 0
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: PUSH
25056: LD_INT 30
25058: PUSH
25059: LD_INT 1
25061: PUSH
25062: EMPTY
25063: LIST
25064: LIST
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: LIST
25070: PPUSH
25071: CALL_OW 72
25075: PUSH
25076: LD_EXP 89
25080: PUSH
25081: LD_VAR 0 2
25085: ARRAY
25086: PPUSH
25087: LD_INT 30
25089: PUSH
25090: LD_INT 3
25092: PUSH
25093: EMPTY
25094: LIST
25095: LIST
25096: PPUSH
25097: CALL_OW 72
25101: PUSH
25102: LD_EXP 89
25106: PUSH
25107: LD_VAR 0 2
25111: ARRAY
25112: PPUSH
25113: LD_INT 2
25115: PUSH
25116: LD_INT 30
25118: PUSH
25119: LD_INT 6
25121: PUSH
25122: EMPTY
25123: LIST
25124: LIST
25125: PUSH
25126: LD_INT 30
25128: PUSH
25129: LD_INT 7
25131: PUSH
25132: EMPTY
25133: LIST
25134: LIST
25135: PUSH
25136: LD_INT 30
25138: PUSH
25139: LD_INT 8
25141: PUSH
25142: EMPTY
25143: LIST
25144: LIST
25145: PUSH
25146: EMPTY
25147: LIST
25148: LIST
25149: LIST
25150: LIST
25151: PPUSH
25152: CALL_OW 72
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: LIST
25161: LIST
25162: ST_TO_ADDR
// for j = 1 to 4 do
25163: LD_ADDR_VAR 0 3
25167: PUSH
25168: DOUBLE
25169: LD_INT 1
25171: DEC
25172: ST_TO_ADDR
25173: LD_INT 4
25175: PUSH
25176: FOR_TO
25177: IFFALSE 25368
// begin if not tmp [ j ] then
25179: LD_VAR 0 4
25183: PUSH
25184: LD_VAR 0 3
25188: ARRAY
25189: NOT
25190: IFFALSE 25194
// continue ;
25192: GO 25176
// for p in tmp [ j ] do
25194: LD_ADDR_VAR 0 5
25198: PUSH
25199: LD_VAR 0 4
25203: PUSH
25204: LD_VAR 0 3
25208: ARRAY
25209: PUSH
25210: FOR_IN
25211: IFFALSE 25364
// begin if not b [ j ] then
25213: LD_VAR 0 6
25217: PUSH
25218: LD_VAR 0 3
25222: ARRAY
25223: NOT
25224: IFFALSE 25228
// break ;
25226: GO 25364
// e := 0 ;
25228: LD_ADDR_VAR 0 7
25232: PUSH
25233: LD_INT 0
25235: ST_TO_ADDR
// for k in b [ j ] do
25236: LD_ADDR_VAR 0 8
25240: PUSH
25241: LD_VAR 0 6
25245: PUSH
25246: LD_VAR 0 3
25250: ARRAY
25251: PUSH
25252: FOR_IN
25253: IFFALSE 25280
// if IsNotFull ( k ) then
25255: LD_VAR 0 8
25259: PPUSH
25260: CALL 52959 0 1
25264: IFFALSE 25278
// begin e := k ;
25266: LD_ADDR_VAR 0 7
25270: PUSH
25271: LD_VAR 0 8
25275: ST_TO_ADDR
// break ;
25276: GO 25280
// end ;
25278: GO 25252
25280: POP
25281: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25282: LD_VAR 0 7
25286: PUSH
25287: LD_VAR 0 5
25291: PPUSH
25292: LD_VAR 0 7
25296: PPUSH
25297: CALL 85379 0 2
25301: NOT
25302: AND
25303: IFFALSE 25362
// begin if IsInUnit ( p ) then
25305: LD_VAR 0 5
25309: PPUSH
25310: CALL_OW 310
25314: IFFALSE 25325
// ComExitBuilding ( p ) ;
25316: LD_VAR 0 5
25320: PPUSH
25321: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25325: LD_VAR 0 5
25329: PPUSH
25330: LD_VAR 0 7
25334: PPUSH
25335: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25339: LD_VAR 0 5
25343: PPUSH
25344: LD_VAR 0 3
25348: PPUSH
25349: CALL_OW 183
// AddComExitBuilding ( p ) ;
25353: LD_VAR 0 5
25357: PPUSH
25358: CALL_OW 182
// end ; end ;
25362: GO 25210
25364: POP
25365: POP
// end ;
25366: GO 25176
25368: POP
25369: POP
// end ;
25370: GO 24931
25372: POP
25373: POP
// end ;
25374: LD_VAR 0 1
25378: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25379: LD_INT 0
25381: PPUSH
25382: PPUSH
25383: PPUSH
25384: PPUSH
25385: PPUSH
25386: PPUSH
25387: PPUSH
25388: PPUSH
25389: PPUSH
25390: PPUSH
25391: PPUSH
25392: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25393: LD_VAR 0 1
25397: NOT
25398: PUSH
25399: LD_EXP 89
25403: PUSH
25404: LD_VAR 0 1
25408: ARRAY
25409: NOT
25410: OR
25411: PUSH
25412: LD_EXP 89
25416: PUSH
25417: LD_VAR 0 1
25421: ARRAY
25422: PPUSH
25423: LD_INT 2
25425: PUSH
25426: LD_INT 30
25428: PUSH
25429: LD_INT 0
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: PUSH
25436: LD_INT 30
25438: PUSH
25439: LD_INT 1
25441: PUSH
25442: EMPTY
25443: LIST
25444: LIST
25445: PUSH
25446: EMPTY
25447: LIST
25448: LIST
25449: LIST
25450: PPUSH
25451: CALL_OW 72
25455: NOT
25456: OR
25457: IFFALSE 25461
// exit ;
25459: GO 28964
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25461: LD_ADDR_VAR 0 4
25465: PUSH
25466: LD_EXP 89
25470: PUSH
25471: LD_VAR 0 1
25475: ARRAY
25476: PPUSH
25477: LD_INT 2
25479: PUSH
25480: LD_INT 25
25482: PUSH
25483: LD_INT 1
25485: PUSH
25486: EMPTY
25487: LIST
25488: LIST
25489: PUSH
25490: LD_INT 25
25492: PUSH
25493: LD_INT 2
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: PUSH
25500: LD_INT 25
25502: PUSH
25503: LD_INT 3
25505: PUSH
25506: EMPTY
25507: LIST
25508: LIST
25509: PUSH
25510: LD_INT 25
25512: PUSH
25513: LD_INT 4
25515: PUSH
25516: EMPTY
25517: LIST
25518: LIST
25519: PUSH
25520: LD_INT 25
25522: PUSH
25523: LD_INT 5
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 25
25532: PUSH
25533: LD_INT 8
25535: PUSH
25536: EMPTY
25537: LIST
25538: LIST
25539: PUSH
25540: LD_INT 25
25542: PUSH
25543: LD_INT 9
25545: PUSH
25546: EMPTY
25547: LIST
25548: LIST
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: LIST
25554: LIST
25555: LIST
25556: LIST
25557: LIST
25558: LIST
25559: PPUSH
25560: CALL_OW 72
25564: ST_TO_ADDR
// if not tmp then
25565: LD_VAR 0 4
25569: NOT
25570: IFFALSE 25574
// exit ;
25572: GO 28964
// for i in tmp do
25574: LD_ADDR_VAR 0 3
25578: PUSH
25579: LD_VAR 0 4
25583: PUSH
25584: FOR_IN
25585: IFFALSE 25616
// if GetTag ( i ) then
25587: LD_VAR 0 3
25591: PPUSH
25592: CALL_OW 110
25596: IFFALSE 25614
// tmp := tmp diff i ;
25598: LD_ADDR_VAR 0 4
25602: PUSH
25603: LD_VAR 0 4
25607: PUSH
25608: LD_VAR 0 3
25612: DIFF
25613: ST_TO_ADDR
25614: GO 25584
25616: POP
25617: POP
// if not tmp then
25618: LD_VAR 0 4
25622: NOT
25623: IFFALSE 25627
// exit ;
25625: GO 28964
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25627: LD_ADDR_VAR 0 5
25631: PUSH
25632: LD_EXP 89
25636: PUSH
25637: LD_VAR 0 1
25641: ARRAY
25642: PPUSH
25643: LD_INT 2
25645: PUSH
25646: LD_INT 25
25648: PUSH
25649: LD_INT 1
25651: PUSH
25652: EMPTY
25653: LIST
25654: LIST
25655: PUSH
25656: LD_INT 25
25658: PUSH
25659: LD_INT 5
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: PUSH
25666: LD_INT 25
25668: PUSH
25669: LD_INT 8
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PUSH
25676: LD_INT 25
25678: PUSH
25679: LD_INT 9
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: LIST
25690: LIST
25691: LIST
25692: PPUSH
25693: CALL_OW 72
25697: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25698: LD_ADDR_VAR 0 6
25702: PUSH
25703: LD_EXP 89
25707: PUSH
25708: LD_VAR 0 1
25712: ARRAY
25713: PPUSH
25714: LD_INT 25
25716: PUSH
25717: LD_INT 2
25719: PUSH
25720: EMPTY
25721: LIST
25722: LIST
25723: PPUSH
25724: CALL_OW 72
25728: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25729: LD_ADDR_VAR 0 7
25733: PUSH
25734: LD_EXP 89
25738: PUSH
25739: LD_VAR 0 1
25743: ARRAY
25744: PPUSH
25745: LD_INT 25
25747: PUSH
25748: LD_INT 3
25750: PUSH
25751: EMPTY
25752: LIST
25753: LIST
25754: PPUSH
25755: CALL_OW 72
25759: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25760: LD_ADDR_VAR 0 8
25764: PUSH
25765: LD_EXP 89
25769: PUSH
25770: LD_VAR 0 1
25774: ARRAY
25775: PPUSH
25776: LD_INT 25
25778: PUSH
25779: LD_INT 4
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: PUSH
25786: LD_INT 24
25788: PUSH
25789: LD_INT 251
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: EMPTY
25797: LIST
25798: LIST
25799: PPUSH
25800: CALL_OW 72
25804: ST_TO_ADDR
// if mc_scan [ base ] then
25805: LD_EXP 112
25809: PUSH
25810: LD_VAR 0 1
25814: ARRAY
25815: IFFALSE 26276
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25817: LD_ADDR_EXP 131
25821: PUSH
25822: LD_EXP 131
25826: PPUSH
25827: LD_VAR 0 1
25831: PPUSH
25832: LD_INT 4
25834: PPUSH
25835: CALL_OW 1
25839: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25840: LD_ADDR_VAR 0 12
25844: PUSH
25845: LD_EXP 89
25849: PUSH
25850: LD_VAR 0 1
25854: ARRAY
25855: PPUSH
25856: LD_INT 2
25858: PUSH
25859: LD_INT 30
25861: PUSH
25862: LD_INT 4
25864: PUSH
25865: EMPTY
25866: LIST
25867: LIST
25868: PUSH
25869: LD_INT 30
25871: PUSH
25872: LD_INT 5
25874: PUSH
25875: EMPTY
25876: LIST
25877: LIST
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: LIST
25883: PPUSH
25884: CALL_OW 72
25888: ST_TO_ADDR
// if not b then
25889: LD_VAR 0 12
25893: NOT
25894: IFFALSE 25898
// exit ;
25896: GO 28964
// p := [ ] ;
25898: LD_ADDR_VAR 0 11
25902: PUSH
25903: EMPTY
25904: ST_TO_ADDR
// if sci >= 2 then
25905: LD_VAR 0 8
25909: PUSH
25910: LD_INT 2
25912: GREATEREQUAL
25913: IFFALSE 25944
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25915: LD_ADDR_VAR 0 8
25919: PUSH
25920: LD_VAR 0 8
25924: PUSH
25925: LD_INT 1
25927: ARRAY
25928: PUSH
25929: LD_VAR 0 8
25933: PUSH
25934: LD_INT 2
25936: ARRAY
25937: PUSH
25938: EMPTY
25939: LIST
25940: LIST
25941: ST_TO_ADDR
25942: GO 26005
// if sci = 1 then
25944: LD_VAR 0 8
25948: PUSH
25949: LD_INT 1
25951: EQUAL
25952: IFFALSE 25973
// sci := [ sci [ 1 ] ] else
25954: LD_ADDR_VAR 0 8
25958: PUSH
25959: LD_VAR 0 8
25963: PUSH
25964: LD_INT 1
25966: ARRAY
25967: PUSH
25968: EMPTY
25969: LIST
25970: ST_TO_ADDR
25971: GO 26005
// if sci = 0 then
25973: LD_VAR 0 8
25977: PUSH
25978: LD_INT 0
25980: EQUAL
25981: IFFALSE 26005
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25983: LD_ADDR_VAR 0 11
25987: PUSH
25988: LD_VAR 0 4
25992: PPUSH
25993: LD_INT 4
25995: PPUSH
25996: CALL 85242 0 2
26000: PUSH
26001: LD_INT 1
26003: ARRAY
26004: ST_TO_ADDR
// if eng > 4 then
26005: LD_VAR 0 6
26009: PUSH
26010: LD_INT 4
26012: GREATER
26013: IFFALSE 26059
// for i = eng downto 4 do
26015: LD_ADDR_VAR 0 3
26019: PUSH
26020: DOUBLE
26021: LD_VAR 0 6
26025: INC
26026: ST_TO_ADDR
26027: LD_INT 4
26029: PUSH
26030: FOR_DOWNTO
26031: IFFALSE 26057
// eng := eng diff eng [ i ] ;
26033: LD_ADDR_VAR 0 6
26037: PUSH
26038: LD_VAR 0 6
26042: PUSH
26043: LD_VAR 0 6
26047: PUSH
26048: LD_VAR 0 3
26052: ARRAY
26053: DIFF
26054: ST_TO_ADDR
26055: GO 26030
26057: POP
26058: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26059: LD_ADDR_VAR 0 4
26063: PUSH
26064: LD_VAR 0 4
26068: PUSH
26069: LD_VAR 0 5
26073: PUSH
26074: LD_VAR 0 6
26078: UNION
26079: PUSH
26080: LD_VAR 0 7
26084: UNION
26085: PUSH
26086: LD_VAR 0 8
26090: UNION
26091: DIFF
26092: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26093: LD_ADDR_VAR 0 13
26097: PUSH
26098: LD_EXP 89
26102: PUSH
26103: LD_VAR 0 1
26107: ARRAY
26108: PPUSH
26109: LD_INT 2
26111: PUSH
26112: LD_INT 30
26114: PUSH
26115: LD_INT 32
26117: PUSH
26118: EMPTY
26119: LIST
26120: LIST
26121: PUSH
26122: LD_INT 30
26124: PUSH
26125: LD_INT 31
26127: PUSH
26128: EMPTY
26129: LIST
26130: LIST
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: LIST
26136: PPUSH
26137: CALL_OW 72
26141: PUSH
26142: LD_EXP 89
26146: PUSH
26147: LD_VAR 0 1
26151: ARRAY
26152: PPUSH
26153: LD_INT 2
26155: PUSH
26156: LD_INT 30
26158: PUSH
26159: LD_INT 4
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: LD_INT 30
26168: PUSH
26169: LD_INT 5
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: EMPTY
26177: LIST
26178: LIST
26179: LIST
26180: PPUSH
26181: CALL_OW 72
26185: PUSH
26186: LD_INT 6
26188: MUL
26189: PLUS
26190: ST_TO_ADDR
// if bcount < tmp then
26191: LD_VAR 0 13
26195: PUSH
26196: LD_VAR 0 4
26200: LESS
26201: IFFALSE 26247
// for i = tmp downto bcount do
26203: LD_ADDR_VAR 0 3
26207: PUSH
26208: DOUBLE
26209: LD_VAR 0 4
26213: INC
26214: ST_TO_ADDR
26215: LD_VAR 0 13
26219: PUSH
26220: FOR_DOWNTO
26221: IFFALSE 26245
// tmp := Delete ( tmp , tmp ) ;
26223: LD_ADDR_VAR 0 4
26227: PUSH
26228: LD_VAR 0 4
26232: PPUSH
26233: LD_VAR 0 4
26237: PPUSH
26238: CALL_OW 3
26242: ST_TO_ADDR
26243: GO 26220
26245: POP
26246: POP
// result := [ tmp , 0 , 0 , p ] ;
26247: LD_ADDR_VAR 0 2
26251: PUSH
26252: LD_VAR 0 4
26256: PUSH
26257: LD_INT 0
26259: PUSH
26260: LD_INT 0
26262: PUSH
26263: LD_VAR 0 11
26267: PUSH
26268: EMPTY
26269: LIST
26270: LIST
26271: LIST
26272: LIST
26273: ST_TO_ADDR
// exit ;
26274: GO 28964
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26276: LD_EXP 89
26280: PUSH
26281: LD_VAR 0 1
26285: ARRAY
26286: PPUSH
26287: LD_INT 2
26289: PUSH
26290: LD_INT 30
26292: PUSH
26293: LD_INT 6
26295: PUSH
26296: EMPTY
26297: LIST
26298: LIST
26299: PUSH
26300: LD_INT 30
26302: PUSH
26303: LD_INT 7
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: PUSH
26310: LD_INT 30
26312: PUSH
26313: LD_INT 8
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: EMPTY
26321: LIST
26322: LIST
26323: LIST
26324: LIST
26325: PPUSH
26326: CALL_OW 72
26330: NOT
26331: PUSH
26332: LD_EXP 89
26336: PUSH
26337: LD_VAR 0 1
26341: ARRAY
26342: PPUSH
26343: LD_INT 30
26345: PUSH
26346: LD_INT 3
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: PPUSH
26353: CALL_OW 72
26357: NOT
26358: AND
26359: IFFALSE 26431
// begin if eng = tmp then
26361: LD_VAR 0 6
26365: PUSH
26366: LD_VAR 0 4
26370: EQUAL
26371: IFFALSE 26375
// exit ;
26373: GO 28964
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26375: LD_ADDR_EXP 131
26379: PUSH
26380: LD_EXP 131
26384: PPUSH
26385: LD_VAR 0 1
26389: PPUSH
26390: LD_INT 1
26392: PPUSH
26393: CALL_OW 1
26397: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26398: LD_ADDR_VAR 0 2
26402: PUSH
26403: LD_INT 0
26405: PUSH
26406: LD_VAR 0 4
26410: PUSH
26411: LD_VAR 0 6
26415: DIFF
26416: PUSH
26417: LD_INT 0
26419: PUSH
26420: LD_INT 0
26422: PUSH
26423: EMPTY
26424: LIST
26425: LIST
26426: LIST
26427: LIST
26428: ST_TO_ADDR
// exit ;
26429: GO 28964
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26431: LD_EXP 116
26435: PUSH
26436: LD_EXP 115
26440: PUSH
26441: LD_VAR 0 1
26445: ARRAY
26446: ARRAY
26447: PUSH
26448: LD_EXP 89
26452: PUSH
26453: LD_VAR 0 1
26457: ARRAY
26458: PPUSH
26459: LD_INT 2
26461: PUSH
26462: LD_INT 30
26464: PUSH
26465: LD_INT 6
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: PUSH
26472: LD_INT 30
26474: PUSH
26475: LD_INT 7
26477: PUSH
26478: EMPTY
26479: LIST
26480: LIST
26481: PUSH
26482: LD_INT 30
26484: PUSH
26485: LD_INT 8
26487: PUSH
26488: EMPTY
26489: LIST
26490: LIST
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: LIST
26496: LIST
26497: PPUSH
26498: CALL_OW 72
26502: AND
26503: PUSH
26504: LD_EXP 89
26508: PUSH
26509: LD_VAR 0 1
26513: ARRAY
26514: PPUSH
26515: LD_INT 30
26517: PUSH
26518: LD_INT 3
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: PPUSH
26525: CALL_OW 72
26529: NOT
26530: AND
26531: IFFALSE 26745
// begin if sci >= 6 then
26533: LD_VAR 0 8
26537: PUSH
26538: LD_INT 6
26540: GREATEREQUAL
26541: IFFALSE 26545
// exit ;
26543: GO 28964
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26545: LD_ADDR_EXP 131
26549: PUSH
26550: LD_EXP 131
26554: PPUSH
26555: LD_VAR 0 1
26559: PPUSH
26560: LD_INT 2
26562: PPUSH
26563: CALL_OW 1
26567: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26568: LD_ADDR_VAR 0 9
26572: PUSH
26573: LD_VAR 0 4
26577: PUSH
26578: LD_VAR 0 8
26582: DIFF
26583: PPUSH
26584: LD_INT 4
26586: PPUSH
26587: CALL 85242 0 2
26591: ST_TO_ADDR
// p := [ ] ;
26592: LD_ADDR_VAR 0 11
26596: PUSH
26597: EMPTY
26598: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26599: LD_VAR 0 8
26603: PUSH
26604: LD_INT 6
26606: LESS
26607: PUSH
26608: LD_VAR 0 9
26612: PUSH
26613: LD_INT 6
26615: GREATER
26616: AND
26617: IFFALSE 26698
// begin for i = 1 to 6 - sci do
26619: LD_ADDR_VAR 0 3
26623: PUSH
26624: DOUBLE
26625: LD_INT 1
26627: DEC
26628: ST_TO_ADDR
26629: LD_INT 6
26631: PUSH
26632: LD_VAR 0 8
26636: MINUS
26637: PUSH
26638: FOR_TO
26639: IFFALSE 26694
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26641: LD_ADDR_VAR 0 11
26645: PUSH
26646: LD_VAR 0 11
26650: PPUSH
26651: LD_VAR 0 11
26655: PUSH
26656: LD_INT 1
26658: PLUS
26659: PPUSH
26660: LD_VAR 0 9
26664: PUSH
26665: LD_INT 1
26667: ARRAY
26668: PPUSH
26669: CALL_OW 2
26673: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26674: LD_ADDR_VAR 0 9
26678: PUSH
26679: LD_VAR 0 9
26683: PPUSH
26684: LD_INT 1
26686: PPUSH
26687: CALL_OW 3
26691: ST_TO_ADDR
// end ;
26692: GO 26638
26694: POP
26695: POP
// end else
26696: GO 26718
// if sort then
26698: LD_VAR 0 9
26702: IFFALSE 26718
// p := sort [ 1 ] ;
26704: LD_ADDR_VAR 0 11
26708: PUSH
26709: LD_VAR 0 9
26713: PUSH
26714: LD_INT 1
26716: ARRAY
26717: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26718: LD_ADDR_VAR 0 2
26722: PUSH
26723: LD_INT 0
26725: PUSH
26726: LD_INT 0
26728: PUSH
26729: LD_INT 0
26731: PUSH
26732: LD_VAR 0 11
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: LIST
26741: LIST
26742: ST_TO_ADDR
// exit ;
26743: GO 28964
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26745: LD_EXP 116
26749: PUSH
26750: LD_EXP 115
26754: PUSH
26755: LD_VAR 0 1
26759: ARRAY
26760: ARRAY
26761: PUSH
26762: LD_EXP 89
26766: PUSH
26767: LD_VAR 0 1
26771: ARRAY
26772: PPUSH
26773: LD_INT 2
26775: PUSH
26776: LD_INT 30
26778: PUSH
26779: LD_INT 6
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PUSH
26786: LD_INT 30
26788: PUSH
26789: LD_INT 7
26791: PUSH
26792: EMPTY
26793: LIST
26794: LIST
26795: PUSH
26796: LD_INT 30
26798: PUSH
26799: LD_INT 8
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: EMPTY
26807: LIST
26808: LIST
26809: LIST
26810: LIST
26811: PPUSH
26812: CALL_OW 72
26816: AND
26817: PUSH
26818: LD_EXP 89
26822: PUSH
26823: LD_VAR 0 1
26827: ARRAY
26828: PPUSH
26829: LD_INT 30
26831: PUSH
26832: LD_INT 3
26834: PUSH
26835: EMPTY
26836: LIST
26837: LIST
26838: PPUSH
26839: CALL_OW 72
26843: AND
26844: IFFALSE 27578
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26846: LD_ADDR_EXP 131
26850: PUSH
26851: LD_EXP 131
26855: PPUSH
26856: LD_VAR 0 1
26860: PPUSH
26861: LD_INT 3
26863: PPUSH
26864: CALL_OW 1
26868: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26869: LD_ADDR_VAR 0 2
26873: PUSH
26874: LD_INT 0
26876: PUSH
26877: LD_INT 0
26879: PUSH
26880: LD_INT 0
26882: PUSH
26883: LD_INT 0
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: LIST
26890: LIST
26891: ST_TO_ADDR
// if not eng then
26892: LD_VAR 0 6
26896: NOT
26897: IFFALSE 26960
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26899: LD_ADDR_VAR 0 11
26903: PUSH
26904: LD_VAR 0 4
26908: PPUSH
26909: LD_INT 2
26911: PPUSH
26912: CALL 85242 0 2
26916: PUSH
26917: LD_INT 1
26919: ARRAY
26920: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26921: LD_ADDR_VAR 0 2
26925: PUSH
26926: LD_VAR 0 2
26930: PPUSH
26931: LD_INT 2
26933: PPUSH
26934: LD_VAR 0 11
26938: PPUSH
26939: CALL_OW 1
26943: ST_TO_ADDR
// tmp := tmp diff p ;
26944: LD_ADDR_VAR 0 4
26948: PUSH
26949: LD_VAR 0 4
26953: PUSH
26954: LD_VAR 0 11
26958: DIFF
26959: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26960: LD_VAR 0 4
26964: PUSH
26965: LD_VAR 0 8
26969: PUSH
26970: LD_INT 6
26972: LESS
26973: AND
26974: IFFALSE 27162
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26976: LD_ADDR_VAR 0 9
26980: PUSH
26981: LD_VAR 0 4
26985: PUSH
26986: LD_VAR 0 8
26990: PUSH
26991: LD_VAR 0 7
26995: UNION
26996: DIFF
26997: PPUSH
26998: LD_INT 4
27000: PPUSH
27001: CALL 85242 0 2
27005: ST_TO_ADDR
// p := [ ] ;
27006: LD_ADDR_VAR 0 11
27010: PUSH
27011: EMPTY
27012: ST_TO_ADDR
// if sort then
27013: LD_VAR 0 9
27017: IFFALSE 27133
// for i = 1 to 6 - sci do
27019: LD_ADDR_VAR 0 3
27023: PUSH
27024: DOUBLE
27025: LD_INT 1
27027: DEC
27028: ST_TO_ADDR
27029: LD_INT 6
27031: PUSH
27032: LD_VAR 0 8
27036: MINUS
27037: PUSH
27038: FOR_TO
27039: IFFALSE 27131
// begin if i = sort then
27041: LD_VAR 0 3
27045: PUSH
27046: LD_VAR 0 9
27050: EQUAL
27051: IFFALSE 27055
// break ;
27053: GO 27131
// if GetClass ( i ) = 4 then
27055: LD_VAR 0 3
27059: PPUSH
27060: CALL_OW 257
27064: PUSH
27065: LD_INT 4
27067: EQUAL
27068: IFFALSE 27072
// continue ;
27070: GO 27038
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27072: LD_ADDR_VAR 0 11
27076: PUSH
27077: LD_VAR 0 11
27081: PPUSH
27082: LD_VAR 0 11
27086: PUSH
27087: LD_INT 1
27089: PLUS
27090: PPUSH
27091: LD_VAR 0 9
27095: PUSH
27096: LD_VAR 0 3
27100: ARRAY
27101: PPUSH
27102: CALL_OW 2
27106: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27107: LD_ADDR_VAR 0 4
27111: PUSH
27112: LD_VAR 0 4
27116: PUSH
27117: LD_VAR 0 9
27121: PUSH
27122: LD_VAR 0 3
27126: ARRAY
27127: DIFF
27128: ST_TO_ADDR
// end ;
27129: GO 27038
27131: POP
27132: POP
// if p then
27133: LD_VAR 0 11
27137: IFFALSE 27162
// result := Replace ( result , 4 , p ) ;
27139: LD_ADDR_VAR 0 2
27143: PUSH
27144: LD_VAR 0 2
27148: PPUSH
27149: LD_INT 4
27151: PPUSH
27152: LD_VAR 0 11
27156: PPUSH
27157: CALL_OW 1
27161: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27162: LD_VAR 0 4
27166: PUSH
27167: LD_VAR 0 7
27171: PUSH
27172: LD_INT 6
27174: LESS
27175: AND
27176: IFFALSE 27364
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27178: LD_ADDR_VAR 0 9
27182: PUSH
27183: LD_VAR 0 4
27187: PUSH
27188: LD_VAR 0 8
27192: PUSH
27193: LD_VAR 0 7
27197: UNION
27198: DIFF
27199: PPUSH
27200: LD_INT 3
27202: PPUSH
27203: CALL 85242 0 2
27207: ST_TO_ADDR
// p := [ ] ;
27208: LD_ADDR_VAR 0 11
27212: PUSH
27213: EMPTY
27214: ST_TO_ADDR
// if sort then
27215: LD_VAR 0 9
27219: IFFALSE 27335
// for i = 1 to 6 - mech do
27221: LD_ADDR_VAR 0 3
27225: PUSH
27226: DOUBLE
27227: LD_INT 1
27229: DEC
27230: ST_TO_ADDR
27231: LD_INT 6
27233: PUSH
27234: LD_VAR 0 7
27238: MINUS
27239: PUSH
27240: FOR_TO
27241: IFFALSE 27333
// begin if i = sort then
27243: LD_VAR 0 3
27247: PUSH
27248: LD_VAR 0 9
27252: EQUAL
27253: IFFALSE 27257
// break ;
27255: GO 27333
// if GetClass ( i ) = 3 then
27257: LD_VAR 0 3
27261: PPUSH
27262: CALL_OW 257
27266: PUSH
27267: LD_INT 3
27269: EQUAL
27270: IFFALSE 27274
// continue ;
27272: GO 27240
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27274: LD_ADDR_VAR 0 11
27278: PUSH
27279: LD_VAR 0 11
27283: PPUSH
27284: LD_VAR 0 11
27288: PUSH
27289: LD_INT 1
27291: PLUS
27292: PPUSH
27293: LD_VAR 0 9
27297: PUSH
27298: LD_VAR 0 3
27302: ARRAY
27303: PPUSH
27304: CALL_OW 2
27308: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27309: LD_ADDR_VAR 0 4
27313: PUSH
27314: LD_VAR 0 4
27318: PUSH
27319: LD_VAR 0 9
27323: PUSH
27324: LD_VAR 0 3
27328: ARRAY
27329: DIFF
27330: ST_TO_ADDR
// end ;
27331: GO 27240
27333: POP
27334: POP
// if p then
27335: LD_VAR 0 11
27339: IFFALSE 27364
// result := Replace ( result , 3 , p ) ;
27341: LD_ADDR_VAR 0 2
27345: PUSH
27346: LD_VAR 0 2
27350: PPUSH
27351: LD_INT 3
27353: PPUSH
27354: LD_VAR 0 11
27358: PPUSH
27359: CALL_OW 1
27363: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27364: LD_VAR 0 4
27368: PUSH
27369: LD_INT 6
27371: GREATER
27372: PUSH
27373: LD_VAR 0 6
27377: PUSH
27378: LD_INT 6
27380: LESS
27381: AND
27382: IFFALSE 27576
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27384: LD_ADDR_VAR 0 9
27388: PUSH
27389: LD_VAR 0 4
27393: PUSH
27394: LD_VAR 0 8
27398: PUSH
27399: LD_VAR 0 7
27403: UNION
27404: PUSH
27405: LD_VAR 0 6
27409: UNION
27410: DIFF
27411: PPUSH
27412: LD_INT 2
27414: PPUSH
27415: CALL 85242 0 2
27419: ST_TO_ADDR
// p := [ ] ;
27420: LD_ADDR_VAR 0 11
27424: PUSH
27425: EMPTY
27426: ST_TO_ADDR
// if sort then
27427: LD_VAR 0 9
27431: IFFALSE 27547
// for i = 1 to 6 - eng do
27433: LD_ADDR_VAR 0 3
27437: PUSH
27438: DOUBLE
27439: LD_INT 1
27441: DEC
27442: ST_TO_ADDR
27443: LD_INT 6
27445: PUSH
27446: LD_VAR 0 6
27450: MINUS
27451: PUSH
27452: FOR_TO
27453: IFFALSE 27545
// begin if i = sort then
27455: LD_VAR 0 3
27459: PUSH
27460: LD_VAR 0 9
27464: EQUAL
27465: IFFALSE 27469
// break ;
27467: GO 27545
// if GetClass ( i ) = 2 then
27469: LD_VAR 0 3
27473: PPUSH
27474: CALL_OW 257
27478: PUSH
27479: LD_INT 2
27481: EQUAL
27482: IFFALSE 27486
// continue ;
27484: GO 27452
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27486: LD_ADDR_VAR 0 11
27490: PUSH
27491: LD_VAR 0 11
27495: PPUSH
27496: LD_VAR 0 11
27500: PUSH
27501: LD_INT 1
27503: PLUS
27504: PPUSH
27505: LD_VAR 0 9
27509: PUSH
27510: LD_VAR 0 3
27514: ARRAY
27515: PPUSH
27516: CALL_OW 2
27520: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27521: LD_ADDR_VAR 0 4
27525: PUSH
27526: LD_VAR 0 4
27530: PUSH
27531: LD_VAR 0 9
27535: PUSH
27536: LD_VAR 0 3
27540: ARRAY
27541: DIFF
27542: ST_TO_ADDR
// end ;
27543: GO 27452
27545: POP
27546: POP
// if p then
27547: LD_VAR 0 11
27551: IFFALSE 27576
// result := Replace ( result , 2 , p ) ;
27553: LD_ADDR_VAR 0 2
27557: PUSH
27558: LD_VAR 0 2
27562: PPUSH
27563: LD_INT 2
27565: PPUSH
27566: LD_VAR 0 11
27570: PPUSH
27571: CALL_OW 1
27575: ST_TO_ADDR
// end ; exit ;
27576: GO 28964
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27578: LD_EXP 116
27582: PUSH
27583: LD_EXP 115
27587: PUSH
27588: LD_VAR 0 1
27592: ARRAY
27593: ARRAY
27594: NOT
27595: PUSH
27596: LD_EXP 89
27600: PUSH
27601: LD_VAR 0 1
27605: ARRAY
27606: PPUSH
27607: LD_INT 30
27609: PUSH
27610: LD_INT 3
27612: PUSH
27613: EMPTY
27614: LIST
27615: LIST
27616: PPUSH
27617: CALL_OW 72
27621: AND
27622: PUSH
27623: LD_EXP 94
27627: PUSH
27628: LD_VAR 0 1
27632: ARRAY
27633: AND
27634: IFFALSE 28242
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27636: LD_ADDR_EXP 131
27640: PUSH
27641: LD_EXP 131
27645: PPUSH
27646: LD_VAR 0 1
27650: PPUSH
27651: LD_INT 5
27653: PPUSH
27654: CALL_OW 1
27658: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27659: LD_ADDR_VAR 0 2
27663: PUSH
27664: LD_INT 0
27666: PUSH
27667: LD_INT 0
27669: PUSH
27670: LD_INT 0
27672: PUSH
27673: LD_INT 0
27675: PUSH
27676: EMPTY
27677: LIST
27678: LIST
27679: LIST
27680: LIST
27681: ST_TO_ADDR
// if sci > 1 then
27682: LD_VAR 0 8
27686: PUSH
27687: LD_INT 1
27689: GREATER
27690: IFFALSE 27718
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27692: LD_ADDR_VAR 0 4
27696: PUSH
27697: LD_VAR 0 4
27701: PUSH
27702: LD_VAR 0 8
27706: PUSH
27707: LD_VAR 0 8
27711: PUSH
27712: LD_INT 1
27714: ARRAY
27715: DIFF
27716: DIFF
27717: ST_TO_ADDR
// if tmp and not sci then
27718: LD_VAR 0 4
27722: PUSH
27723: LD_VAR 0 8
27727: NOT
27728: AND
27729: IFFALSE 27798
// begin sort := SortBySkill ( tmp , 4 ) ;
27731: LD_ADDR_VAR 0 9
27735: PUSH
27736: LD_VAR 0 4
27740: PPUSH
27741: LD_INT 4
27743: PPUSH
27744: CALL 85242 0 2
27748: ST_TO_ADDR
// if sort then
27749: LD_VAR 0 9
27753: IFFALSE 27769
// p := sort [ 1 ] ;
27755: LD_ADDR_VAR 0 11
27759: PUSH
27760: LD_VAR 0 9
27764: PUSH
27765: LD_INT 1
27767: ARRAY
27768: ST_TO_ADDR
// if p then
27769: LD_VAR 0 11
27773: IFFALSE 27798
// result := Replace ( result , 4 , p ) ;
27775: LD_ADDR_VAR 0 2
27779: PUSH
27780: LD_VAR 0 2
27784: PPUSH
27785: LD_INT 4
27787: PPUSH
27788: LD_VAR 0 11
27792: PPUSH
27793: CALL_OW 1
27797: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27798: LD_ADDR_VAR 0 4
27802: PUSH
27803: LD_VAR 0 4
27807: PUSH
27808: LD_VAR 0 7
27812: DIFF
27813: ST_TO_ADDR
// if tmp and mech < 6 then
27814: LD_VAR 0 4
27818: PUSH
27819: LD_VAR 0 7
27823: PUSH
27824: LD_INT 6
27826: LESS
27827: AND
27828: IFFALSE 28016
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27830: LD_ADDR_VAR 0 9
27834: PUSH
27835: LD_VAR 0 4
27839: PUSH
27840: LD_VAR 0 8
27844: PUSH
27845: LD_VAR 0 7
27849: UNION
27850: DIFF
27851: PPUSH
27852: LD_INT 3
27854: PPUSH
27855: CALL 85242 0 2
27859: ST_TO_ADDR
// p := [ ] ;
27860: LD_ADDR_VAR 0 11
27864: PUSH
27865: EMPTY
27866: ST_TO_ADDR
// if sort then
27867: LD_VAR 0 9
27871: IFFALSE 27987
// for i = 1 to 6 - mech do
27873: LD_ADDR_VAR 0 3
27877: PUSH
27878: DOUBLE
27879: LD_INT 1
27881: DEC
27882: ST_TO_ADDR
27883: LD_INT 6
27885: PUSH
27886: LD_VAR 0 7
27890: MINUS
27891: PUSH
27892: FOR_TO
27893: IFFALSE 27985
// begin if i = sort then
27895: LD_VAR 0 3
27899: PUSH
27900: LD_VAR 0 9
27904: EQUAL
27905: IFFALSE 27909
// break ;
27907: GO 27985
// if GetClass ( i ) = 3 then
27909: LD_VAR 0 3
27913: PPUSH
27914: CALL_OW 257
27918: PUSH
27919: LD_INT 3
27921: EQUAL
27922: IFFALSE 27926
// continue ;
27924: GO 27892
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27926: LD_ADDR_VAR 0 11
27930: PUSH
27931: LD_VAR 0 11
27935: PPUSH
27936: LD_VAR 0 11
27940: PUSH
27941: LD_INT 1
27943: PLUS
27944: PPUSH
27945: LD_VAR 0 9
27949: PUSH
27950: LD_VAR 0 3
27954: ARRAY
27955: PPUSH
27956: CALL_OW 2
27960: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27961: LD_ADDR_VAR 0 4
27965: PUSH
27966: LD_VAR 0 4
27970: PUSH
27971: LD_VAR 0 9
27975: PUSH
27976: LD_VAR 0 3
27980: ARRAY
27981: DIFF
27982: ST_TO_ADDR
// end ;
27983: GO 27892
27985: POP
27986: POP
// if p then
27987: LD_VAR 0 11
27991: IFFALSE 28016
// result := Replace ( result , 3 , p ) ;
27993: LD_ADDR_VAR 0 2
27997: PUSH
27998: LD_VAR 0 2
28002: PPUSH
28003: LD_INT 3
28005: PPUSH
28006: LD_VAR 0 11
28010: PPUSH
28011: CALL_OW 1
28015: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28016: LD_ADDR_VAR 0 4
28020: PUSH
28021: LD_VAR 0 4
28025: PUSH
28026: LD_VAR 0 6
28030: DIFF
28031: ST_TO_ADDR
// if tmp and eng < 6 then
28032: LD_VAR 0 4
28036: PUSH
28037: LD_VAR 0 6
28041: PUSH
28042: LD_INT 6
28044: LESS
28045: AND
28046: IFFALSE 28240
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28048: LD_ADDR_VAR 0 9
28052: PUSH
28053: LD_VAR 0 4
28057: PUSH
28058: LD_VAR 0 8
28062: PUSH
28063: LD_VAR 0 7
28067: UNION
28068: PUSH
28069: LD_VAR 0 6
28073: UNION
28074: DIFF
28075: PPUSH
28076: LD_INT 2
28078: PPUSH
28079: CALL 85242 0 2
28083: ST_TO_ADDR
// p := [ ] ;
28084: LD_ADDR_VAR 0 11
28088: PUSH
28089: EMPTY
28090: ST_TO_ADDR
// if sort then
28091: LD_VAR 0 9
28095: IFFALSE 28211
// for i = 1 to 6 - eng do
28097: LD_ADDR_VAR 0 3
28101: PUSH
28102: DOUBLE
28103: LD_INT 1
28105: DEC
28106: ST_TO_ADDR
28107: LD_INT 6
28109: PUSH
28110: LD_VAR 0 6
28114: MINUS
28115: PUSH
28116: FOR_TO
28117: IFFALSE 28209
// begin if i = sort then
28119: LD_VAR 0 3
28123: PUSH
28124: LD_VAR 0 9
28128: EQUAL
28129: IFFALSE 28133
// break ;
28131: GO 28209
// if GetClass ( i ) = 2 then
28133: LD_VAR 0 3
28137: PPUSH
28138: CALL_OW 257
28142: PUSH
28143: LD_INT 2
28145: EQUAL
28146: IFFALSE 28150
// continue ;
28148: GO 28116
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28150: LD_ADDR_VAR 0 11
28154: PUSH
28155: LD_VAR 0 11
28159: PPUSH
28160: LD_VAR 0 11
28164: PUSH
28165: LD_INT 1
28167: PLUS
28168: PPUSH
28169: LD_VAR 0 9
28173: PUSH
28174: LD_VAR 0 3
28178: ARRAY
28179: PPUSH
28180: CALL_OW 2
28184: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28185: LD_ADDR_VAR 0 4
28189: PUSH
28190: LD_VAR 0 4
28194: PUSH
28195: LD_VAR 0 9
28199: PUSH
28200: LD_VAR 0 3
28204: ARRAY
28205: DIFF
28206: ST_TO_ADDR
// end ;
28207: GO 28116
28209: POP
28210: POP
// if p then
28211: LD_VAR 0 11
28215: IFFALSE 28240
// result := Replace ( result , 2 , p ) ;
28217: LD_ADDR_VAR 0 2
28221: PUSH
28222: LD_VAR 0 2
28226: PPUSH
28227: LD_INT 2
28229: PPUSH
28230: LD_VAR 0 11
28234: PPUSH
28235: CALL_OW 1
28239: ST_TO_ADDR
// end ; exit ;
28240: GO 28964
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28242: LD_EXP 116
28246: PUSH
28247: LD_EXP 115
28251: PUSH
28252: LD_VAR 0 1
28256: ARRAY
28257: ARRAY
28258: NOT
28259: PUSH
28260: LD_EXP 89
28264: PUSH
28265: LD_VAR 0 1
28269: ARRAY
28270: PPUSH
28271: LD_INT 30
28273: PUSH
28274: LD_INT 3
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PPUSH
28281: CALL_OW 72
28285: AND
28286: PUSH
28287: LD_EXP 94
28291: PUSH
28292: LD_VAR 0 1
28296: ARRAY
28297: NOT
28298: AND
28299: IFFALSE 28964
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28301: LD_ADDR_EXP 131
28305: PUSH
28306: LD_EXP 131
28310: PPUSH
28311: LD_VAR 0 1
28315: PPUSH
28316: LD_INT 6
28318: PPUSH
28319: CALL_OW 1
28323: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28324: LD_ADDR_VAR 0 2
28328: PUSH
28329: LD_INT 0
28331: PUSH
28332: LD_INT 0
28334: PUSH
28335: LD_INT 0
28337: PUSH
28338: LD_INT 0
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: LIST
28345: LIST
28346: ST_TO_ADDR
// if sci >= 1 then
28347: LD_VAR 0 8
28351: PUSH
28352: LD_INT 1
28354: GREATEREQUAL
28355: IFFALSE 28377
// tmp := tmp diff sci [ 1 ] ;
28357: LD_ADDR_VAR 0 4
28361: PUSH
28362: LD_VAR 0 4
28366: PUSH
28367: LD_VAR 0 8
28371: PUSH
28372: LD_INT 1
28374: ARRAY
28375: DIFF
28376: ST_TO_ADDR
// if tmp and not sci then
28377: LD_VAR 0 4
28381: PUSH
28382: LD_VAR 0 8
28386: NOT
28387: AND
28388: IFFALSE 28457
// begin sort := SortBySkill ( tmp , 4 ) ;
28390: LD_ADDR_VAR 0 9
28394: PUSH
28395: LD_VAR 0 4
28399: PPUSH
28400: LD_INT 4
28402: PPUSH
28403: CALL 85242 0 2
28407: ST_TO_ADDR
// if sort then
28408: LD_VAR 0 9
28412: IFFALSE 28428
// p := sort [ 1 ] ;
28414: LD_ADDR_VAR 0 11
28418: PUSH
28419: LD_VAR 0 9
28423: PUSH
28424: LD_INT 1
28426: ARRAY
28427: ST_TO_ADDR
// if p then
28428: LD_VAR 0 11
28432: IFFALSE 28457
// result := Replace ( result , 4 , p ) ;
28434: LD_ADDR_VAR 0 2
28438: PUSH
28439: LD_VAR 0 2
28443: PPUSH
28444: LD_INT 4
28446: PPUSH
28447: LD_VAR 0 11
28451: PPUSH
28452: CALL_OW 1
28456: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28457: LD_ADDR_VAR 0 4
28461: PUSH
28462: LD_VAR 0 4
28466: PUSH
28467: LD_VAR 0 7
28471: DIFF
28472: ST_TO_ADDR
// if tmp and mech < 6 then
28473: LD_VAR 0 4
28477: PUSH
28478: LD_VAR 0 7
28482: PUSH
28483: LD_INT 6
28485: LESS
28486: AND
28487: IFFALSE 28669
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28489: LD_ADDR_VAR 0 9
28493: PUSH
28494: LD_VAR 0 4
28498: PUSH
28499: LD_VAR 0 7
28503: DIFF
28504: PPUSH
28505: LD_INT 3
28507: PPUSH
28508: CALL 85242 0 2
28512: ST_TO_ADDR
// p := [ ] ;
28513: LD_ADDR_VAR 0 11
28517: PUSH
28518: EMPTY
28519: ST_TO_ADDR
// if sort then
28520: LD_VAR 0 9
28524: IFFALSE 28640
// for i = 1 to 6 - mech do
28526: LD_ADDR_VAR 0 3
28530: PUSH
28531: DOUBLE
28532: LD_INT 1
28534: DEC
28535: ST_TO_ADDR
28536: LD_INT 6
28538: PUSH
28539: LD_VAR 0 7
28543: MINUS
28544: PUSH
28545: FOR_TO
28546: IFFALSE 28638
// begin if i = sort then
28548: LD_VAR 0 3
28552: PUSH
28553: LD_VAR 0 9
28557: EQUAL
28558: IFFALSE 28562
// break ;
28560: GO 28638
// if GetClass ( i ) = 3 then
28562: LD_VAR 0 3
28566: PPUSH
28567: CALL_OW 257
28571: PUSH
28572: LD_INT 3
28574: EQUAL
28575: IFFALSE 28579
// continue ;
28577: GO 28545
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28579: LD_ADDR_VAR 0 11
28583: PUSH
28584: LD_VAR 0 11
28588: PPUSH
28589: LD_VAR 0 11
28593: PUSH
28594: LD_INT 1
28596: PLUS
28597: PPUSH
28598: LD_VAR 0 9
28602: PUSH
28603: LD_VAR 0 3
28607: ARRAY
28608: PPUSH
28609: CALL_OW 2
28613: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28614: LD_ADDR_VAR 0 4
28618: PUSH
28619: LD_VAR 0 4
28623: PUSH
28624: LD_VAR 0 9
28628: PUSH
28629: LD_VAR 0 3
28633: ARRAY
28634: DIFF
28635: ST_TO_ADDR
// end ;
28636: GO 28545
28638: POP
28639: POP
// if p then
28640: LD_VAR 0 11
28644: IFFALSE 28669
// result := Replace ( result , 3 , p ) ;
28646: LD_ADDR_VAR 0 2
28650: PUSH
28651: LD_VAR 0 2
28655: PPUSH
28656: LD_INT 3
28658: PPUSH
28659: LD_VAR 0 11
28663: PPUSH
28664: CALL_OW 1
28668: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28669: LD_ADDR_VAR 0 4
28673: PUSH
28674: LD_VAR 0 4
28678: PUSH
28679: LD_VAR 0 6
28683: DIFF
28684: ST_TO_ADDR
// if tmp and eng < 4 then
28685: LD_VAR 0 4
28689: PUSH
28690: LD_VAR 0 6
28694: PUSH
28695: LD_INT 4
28697: LESS
28698: AND
28699: IFFALSE 28889
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28701: LD_ADDR_VAR 0 9
28705: PUSH
28706: LD_VAR 0 4
28710: PUSH
28711: LD_VAR 0 7
28715: PUSH
28716: LD_VAR 0 6
28720: UNION
28721: DIFF
28722: PPUSH
28723: LD_INT 2
28725: PPUSH
28726: CALL 85242 0 2
28730: ST_TO_ADDR
// p := [ ] ;
28731: LD_ADDR_VAR 0 11
28735: PUSH
28736: EMPTY
28737: ST_TO_ADDR
// if sort then
28738: LD_VAR 0 9
28742: IFFALSE 28858
// for i = 1 to 4 - eng do
28744: LD_ADDR_VAR 0 3
28748: PUSH
28749: DOUBLE
28750: LD_INT 1
28752: DEC
28753: ST_TO_ADDR
28754: LD_INT 4
28756: PUSH
28757: LD_VAR 0 6
28761: MINUS
28762: PUSH
28763: FOR_TO
28764: IFFALSE 28856
// begin if i = sort then
28766: LD_VAR 0 3
28770: PUSH
28771: LD_VAR 0 9
28775: EQUAL
28776: IFFALSE 28780
// break ;
28778: GO 28856
// if GetClass ( i ) = 2 then
28780: LD_VAR 0 3
28784: PPUSH
28785: CALL_OW 257
28789: PUSH
28790: LD_INT 2
28792: EQUAL
28793: IFFALSE 28797
// continue ;
28795: GO 28763
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28797: LD_ADDR_VAR 0 11
28801: PUSH
28802: LD_VAR 0 11
28806: PPUSH
28807: LD_VAR 0 11
28811: PUSH
28812: LD_INT 1
28814: PLUS
28815: PPUSH
28816: LD_VAR 0 9
28820: PUSH
28821: LD_VAR 0 3
28825: ARRAY
28826: PPUSH
28827: CALL_OW 2
28831: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28832: LD_ADDR_VAR 0 4
28836: PUSH
28837: LD_VAR 0 4
28841: PUSH
28842: LD_VAR 0 9
28846: PUSH
28847: LD_VAR 0 3
28851: ARRAY
28852: DIFF
28853: ST_TO_ADDR
// end ;
28854: GO 28763
28856: POP
28857: POP
// if p then
28858: LD_VAR 0 11
28862: IFFALSE 28887
// result := Replace ( result , 2 , p ) ;
28864: LD_ADDR_VAR 0 2
28868: PUSH
28869: LD_VAR 0 2
28873: PPUSH
28874: LD_INT 2
28876: PPUSH
28877: LD_VAR 0 11
28881: PPUSH
28882: CALL_OW 1
28886: ST_TO_ADDR
// end else
28887: GO 28933
// for i = eng downto 5 do
28889: LD_ADDR_VAR 0 3
28893: PUSH
28894: DOUBLE
28895: LD_VAR 0 6
28899: INC
28900: ST_TO_ADDR
28901: LD_INT 5
28903: PUSH
28904: FOR_DOWNTO
28905: IFFALSE 28931
// tmp := tmp union eng [ i ] ;
28907: LD_ADDR_VAR 0 4
28911: PUSH
28912: LD_VAR 0 4
28916: PUSH
28917: LD_VAR 0 6
28921: PUSH
28922: LD_VAR 0 3
28926: ARRAY
28927: UNION
28928: ST_TO_ADDR
28929: GO 28904
28931: POP
28932: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28933: LD_ADDR_VAR 0 2
28937: PUSH
28938: LD_VAR 0 2
28942: PPUSH
28943: LD_INT 1
28945: PPUSH
28946: LD_VAR 0 4
28950: PUSH
28951: LD_VAR 0 5
28955: DIFF
28956: PPUSH
28957: CALL_OW 1
28961: ST_TO_ADDR
// exit ;
28962: GO 28964
// end ; end ;
28964: LD_VAR 0 2
28968: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28969: LD_INT 0
28971: PPUSH
28972: PPUSH
28973: PPUSH
// if not mc_bases then
28974: LD_EXP 89
28978: NOT
28979: IFFALSE 28983
// exit ;
28981: GO 29089
// for i = 1 to mc_bases do
28983: LD_ADDR_VAR 0 2
28987: PUSH
28988: DOUBLE
28989: LD_INT 1
28991: DEC
28992: ST_TO_ADDR
28993: LD_EXP 89
28997: PUSH
28998: FOR_TO
28999: IFFALSE 29080
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29001: LD_ADDR_VAR 0 3
29005: PUSH
29006: LD_EXP 89
29010: PUSH
29011: LD_VAR 0 2
29015: ARRAY
29016: PPUSH
29017: LD_INT 21
29019: PUSH
29020: LD_INT 3
29022: PUSH
29023: EMPTY
29024: LIST
29025: LIST
29026: PUSH
29027: LD_INT 3
29029: PUSH
29030: LD_INT 24
29032: PUSH
29033: LD_INT 1000
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PPUSH
29048: CALL_OW 72
29052: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29053: LD_ADDR_EXP 90
29057: PUSH
29058: LD_EXP 90
29062: PPUSH
29063: LD_VAR 0 2
29067: PPUSH
29068: LD_VAR 0 3
29072: PPUSH
29073: CALL_OW 1
29077: ST_TO_ADDR
// end ;
29078: GO 28998
29080: POP
29081: POP
// RaiseSailEvent ( 101 ) ;
29082: LD_INT 101
29084: PPUSH
29085: CALL_OW 427
// end ;
29089: LD_VAR 0 1
29093: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29094: LD_INT 0
29096: PPUSH
29097: PPUSH
29098: PPUSH
29099: PPUSH
29100: PPUSH
29101: PPUSH
29102: PPUSH
// if not mc_bases then
29103: LD_EXP 89
29107: NOT
29108: IFFALSE 29112
// exit ;
29110: GO 29674
// for i = 1 to mc_bases do
29112: LD_ADDR_VAR 0 2
29116: PUSH
29117: DOUBLE
29118: LD_INT 1
29120: DEC
29121: ST_TO_ADDR
29122: LD_EXP 89
29126: PUSH
29127: FOR_TO
29128: IFFALSE 29665
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
29130: LD_ADDR_VAR 0 5
29134: PUSH
29135: LD_EXP 89
29139: PUSH
29140: LD_VAR 0 2
29144: ARRAY
29145: PUSH
29146: LD_EXP 118
29150: PUSH
29151: LD_VAR 0 2
29155: ARRAY
29156: UNION
29157: PPUSH
29158: LD_INT 21
29160: PUSH
29161: LD_INT 1
29163: PUSH
29164: EMPTY
29165: LIST
29166: LIST
29167: PUSH
29168: LD_INT 1
29170: PUSH
29171: LD_INT 3
29173: PUSH
29174: LD_INT 54
29176: PUSH
29177: EMPTY
29178: LIST
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: LD_INT 3
29186: PUSH
29187: LD_INT 24
29189: PUSH
29190: LD_INT 800
29192: PUSH
29193: EMPTY
29194: LIST
29195: LIST
29196: PUSH
29197: EMPTY
29198: LIST
29199: LIST
29200: PUSH
29201: EMPTY
29202: LIST
29203: LIST
29204: LIST
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PPUSH
29210: CALL_OW 72
29214: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29215: LD_ADDR_VAR 0 6
29219: PUSH
29220: LD_EXP 89
29224: PUSH
29225: LD_VAR 0 2
29229: ARRAY
29230: PPUSH
29231: LD_INT 21
29233: PUSH
29234: LD_INT 1
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 1
29243: PUSH
29244: LD_INT 3
29246: PUSH
29247: LD_INT 54
29249: PUSH
29250: EMPTY
29251: LIST
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 3
29259: PUSH
29260: LD_INT 24
29262: PUSH
29263: LD_INT 250
29265: PUSH
29266: EMPTY
29267: LIST
29268: LIST
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: LIST
29278: PUSH
29279: EMPTY
29280: LIST
29281: LIST
29282: PPUSH
29283: CALL_OW 72
29287: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29288: LD_ADDR_VAR 0 7
29292: PUSH
29293: LD_VAR 0 5
29297: PUSH
29298: LD_VAR 0 6
29302: DIFF
29303: ST_TO_ADDR
// if not need_heal_1 then
29304: LD_VAR 0 6
29308: NOT
29309: IFFALSE 29342
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29311: LD_ADDR_EXP 92
29315: PUSH
29316: LD_EXP 92
29320: PPUSH
29321: LD_VAR 0 2
29325: PUSH
29326: LD_INT 1
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PPUSH
29333: EMPTY
29334: PPUSH
29335: CALL 55693 0 3
29339: ST_TO_ADDR
29340: GO 29412
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29342: LD_ADDR_EXP 92
29346: PUSH
29347: LD_EXP 92
29351: PPUSH
29352: LD_VAR 0 2
29356: PUSH
29357: LD_INT 1
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PPUSH
29364: LD_EXP 92
29368: PUSH
29369: LD_VAR 0 2
29373: ARRAY
29374: PUSH
29375: LD_INT 1
29377: ARRAY
29378: PPUSH
29379: LD_INT 3
29381: PUSH
29382: LD_INT 24
29384: PUSH
29385: LD_INT 1000
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PPUSH
29396: CALL_OW 72
29400: PUSH
29401: LD_VAR 0 6
29405: UNION
29406: PPUSH
29407: CALL 55693 0 3
29411: ST_TO_ADDR
// if not need_heal_2 then
29412: LD_VAR 0 7
29416: NOT
29417: IFFALSE 29450
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29419: LD_ADDR_EXP 92
29423: PUSH
29424: LD_EXP 92
29428: PPUSH
29429: LD_VAR 0 2
29433: PUSH
29434: LD_INT 2
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PPUSH
29441: EMPTY
29442: PPUSH
29443: CALL 55693 0 3
29447: ST_TO_ADDR
29448: GO 29482
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29450: LD_ADDR_EXP 92
29454: PUSH
29455: LD_EXP 92
29459: PPUSH
29460: LD_VAR 0 2
29464: PUSH
29465: LD_INT 2
29467: PUSH
29468: EMPTY
29469: LIST
29470: LIST
29471: PPUSH
29472: LD_VAR 0 7
29476: PPUSH
29477: CALL 55693 0 3
29481: ST_TO_ADDR
// if need_heal_2 then
29482: LD_VAR 0 7
29486: IFFALSE 29647
// for j in need_heal_2 do
29488: LD_ADDR_VAR 0 3
29492: PUSH
29493: LD_VAR 0 7
29497: PUSH
29498: FOR_IN
29499: IFFALSE 29645
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29501: LD_ADDR_VAR 0 5
29505: PUSH
29506: LD_EXP 89
29510: PUSH
29511: LD_VAR 0 2
29515: ARRAY
29516: PPUSH
29517: LD_INT 2
29519: PUSH
29520: LD_INT 30
29522: PUSH
29523: LD_INT 6
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: LD_INT 30
29532: PUSH
29533: LD_INT 7
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 30
29542: PUSH
29543: LD_INT 8
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 30
29552: PUSH
29553: LD_INT 0
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PUSH
29560: LD_INT 30
29562: PUSH
29563: LD_INT 1
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: LIST
29574: LIST
29575: LIST
29576: LIST
29577: PPUSH
29578: CALL_OW 72
29582: ST_TO_ADDR
// if tmp then
29583: LD_VAR 0 5
29587: IFFALSE 29643
// begin k := NearestUnitToUnit ( tmp , j ) ;
29589: LD_ADDR_VAR 0 4
29593: PUSH
29594: LD_VAR 0 5
29598: PPUSH
29599: LD_VAR 0 3
29603: PPUSH
29604: CALL_OW 74
29608: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29609: LD_VAR 0 3
29613: PPUSH
29614: LD_VAR 0 4
29618: PPUSH
29619: CALL_OW 296
29623: PUSH
29624: LD_INT 5
29626: GREATER
29627: IFFALSE 29643
// ComMoveUnit ( j , k ) ;
29629: LD_VAR 0 3
29633: PPUSH
29634: LD_VAR 0 4
29638: PPUSH
29639: CALL_OW 112
// end ; end ;
29643: GO 29498
29645: POP
29646: POP
// if not need_heal_1 and not need_heal_2 then
29647: LD_VAR 0 6
29651: NOT
29652: PUSH
29653: LD_VAR 0 7
29657: NOT
29658: AND
29659: IFFALSE 29663
// continue ;
29661: GO 29127
// end ;
29663: GO 29127
29665: POP
29666: POP
// RaiseSailEvent ( 102 ) ;
29667: LD_INT 102
29669: PPUSH
29670: CALL_OW 427
// end ;
29674: LD_VAR 0 1
29678: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29679: LD_INT 0
29681: PPUSH
29682: PPUSH
29683: PPUSH
29684: PPUSH
29685: PPUSH
29686: PPUSH
29687: PPUSH
29688: PPUSH
// if not mc_bases then
29689: LD_EXP 89
29693: NOT
29694: IFFALSE 29698
// exit ;
29696: GO 30533
// for i = 1 to mc_bases do
29698: LD_ADDR_VAR 0 2
29702: PUSH
29703: DOUBLE
29704: LD_INT 1
29706: DEC
29707: ST_TO_ADDR
29708: LD_EXP 89
29712: PUSH
29713: FOR_TO
29714: IFFALSE 30531
// begin if not mc_building_need_repair [ i ] then
29716: LD_EXP 90
29720: PUSH
29721: LD_VAR 0 2
29725: ARRAY
29726: NOT
29727: IFFALSE 29901
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29729: LD_ADDR_VAR 0 6
29733: PUSH
29734: LD_EXP 108
29738: PUSH
29739: LD_VAR 0 2
29743: ARRAY
29744: PPUSH
29745: LD_INT 3
29747: PUSH
29748: LD_INT 24
29750: PUSH
29751: LD_INT 1000
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 2
29764: PUSH
29765: LD_INT 34
29767: PUSH
29768: LD_INT 13
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 34
29777: PUSH
29778: LD_INT 52
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: LIST
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PPUSH
29794: CALL_OW 72
29798: ST_TO_ADDR
// if cranes then
29799: LD_VAR 0 6
29803: IFFALSE 29865
// for j in cranes do
29805: LD_ADDR_VAR 0 3
29809: PUSH
29810: LD_VAR 0 6
29814: PUSH
29815: FOR_IN
29816: IFFALSE 29863
// if not IsInArea ( j , mc_parking [ i ] ) then
29818: LD_VAR 0 3
29822: PPUSH
29823: LD_EXP 113
29827: PUSH
29828: LD_VAR 0 2
29832: ARRAY
29833: PPUSH
29834: CALL_OW 308
29838: NOT
29839: IFFALSE 29861
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29841: LD_VAR 0 3
29845: PPUSH
29846: LD_EXP 113
29850: PUSH
29851: LD_VAR 0 2
29855: ARRAY
29856: PPUSH
29857: CALL_OW 113
29861: GO 29815
29863: POP
29864: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29865: LD_ADDR_EXP 91
29869: PUSH
29870: LD_EXP 91
29874: PPUSH
29875: LD_VAR 0 2
29879: PPUSH
29880: EMPTY
29881: PPUSH
29882: CALL_OW 1
29886: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29887: LD_VAR 0 2
29891: PPUSH
29892: LD_INT 101
29894: PPUSH
29895: CALL 24802 0 2
// continue ;
29899: GO 29713
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29901: LD_ADDR_EXP 95
29905: PUSH
29906: LD_EXP 95
29910: PPUSH
29911: LD_VAR 0 2
29915: PPUSH
29916: EMPTY
29917: PPUSH
29918: CALL_OW 1
29922: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29923: LD_VAR 0 2
29927: PPUSH
29928: LD_INT 103
29930: PPUSH
29931: CALL 24802 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
29935: LD_ADDR_VAR 0 5
29939: PUSH
29940: LD_EXP 89
29944: PUSH
29945: LD_VAR 0 2
29949: ARRAY
29950: PUSH
29951: LD_EXP 118
29955: PUSH
29956: LD_VAR 0 2
29960: ARRAY
29961: UNION
29962: PPUSH
29963: LD_INT 2
29965: PUSH
29966: LD_INT 25
29968: PUSH
29969: LD_INT 2
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 25
29978: PUSH
29979: LD_INT 16
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: LIST
29990: PUSH
29991: EMPTY
29992: LIST
29993: PPUSH
29994: CALL_OW 72
29998: PUSH
29999: LD_EXP 92
30003: PUSH
30004: LD_VAR 0 2
30008: ARRAY
30009: PUSH
30010: LD_INT 1
30012: ARRAY
30013: PUSH
30014: LD_EXP 92
30018: PUSH
30019: LD_VAR 0 2
30023: ARRAY
30024: PUSH
30025: LD_INT 2
30027: ARRAY
30028: UNION
30029: DIFF
30030: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
30031: LD_ADDR_VAR 0 6
30035: PUSH
30036: LD_EXP 108
30040: PUSH
30041: LD_VAR 0 2
30045: ARRAY
30046: PPUSH
30047: LD_INT 2
30049: PUSH
30050: LD_INT 34
30052: PUSH
30053: LD_INT 13
30055: PUSH
30056: EMPTY
30057: LIST
30058: LIST
30059: PUSH
30060: LD_INT 34
30062: PUSH
30063: LD_INT 52
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: LIST
30074: PPUSH
30075: CALL_OW 72
30079: ST_TO_ADDR
// if cranes then
30080: LD_VAR 0 6
30084: IFFALSE 30220
// begin for j in cranes do
30086: LD_ADDR_VAR 0 3
30090: PUSH
30091: LD_VAR 0 6
30095: PUSH
30096: FOR_IN
30097: IFFALSE 30218
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
30099: LD_VAR 0 3
30103: PPUSH
30104: CALL_OW 256
30108: PUSH
30109: LD_INT 500
30111: GREATEREQUAL
30112: PUSH
30113: LD_VAR 0 3
30117: PPUSH
30118: CALL_OW 314
30122: NOT
30123: AND
30124: IFFALSE 30158
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30126: LD_VAR 0 3
30130: PPUSH
30131: LD_EXP 90
30135: PUSH
30136: LD_VAR 0 2
30140: ARRAY
30141: PPUSH
30142: LD_VAR 0 3
30146: PPUSH
30147: CALL_OW 74
30151: PPUSH
30152: CALL_OW 130
30156: GO 30216
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30158: LD_VAR 0 3
30162: PPUSH
30163: CALL_OW 256
30167: PUSH
30168: LD_INT 500
30170: LESS
30171: PUSH
30172: LD_VAR 0 3
30176: PPUSH
30177: LD_EXP 113
30181: PUSH
30182: LD_VAR 0 2
30186: ARRAY
30187: PPUSH
30188: CALL_OW 308
30192: NOT
30193: AND
30194: IFFALSE 30216
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30196: LD_VAR 0 3
30200: PPUSH
30201: LD_EXP 113
30205: PUSH
30206: LD_VAR 0 2
30210: ARRAY
30211: PPUSH
30212: CALL_OW 113
30216: GO 30096
30218: POP
30219: POP
// end ; if tmp > 3 then
30220: LD_VAR 0 5
30224: PUSH
30225: LD_INT 3
30227: GREATER
30228: IFFALSE 30248
// tmp := ShrinkArray ( tmp , 4 ) ;
30230: LD_ADDR_VAR 0 5
30234: PUSH
30235: LD_VAR 0 5
30239: PPUSH
30240: LD_INT 4
30242: PPUSH
30243: CALL 86932 0 2
30247: ST_TO_ADDR
// if not tmp then
30248: LD_VAR 0 5
30252: NOT
30253: IFFALSE 30257
// continue ;
30255: GO 29713
// for j in tmp do
30257: LD_ADDR_VAR 0 3
30261: PUSH
30262: LD_VAR 0 5
30266: PUSH
30267: FOR_IN
30268: IFFALSE 30527
// begin if IsInUnit ( j ) then
30270: LD_VAR 0 3
30274: PPUSH
30275: CALL_OW 310
30279: IFFALSE 30290
// ComExitBuilding ( j ) ;
30281: LD_VAR 0 3
30285: PPUSH
30286: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30290: LD_VAR 0 3
30294: PUSH
30295: LD_EXP 91
30299: PUSH
30300: LD_VAR 0 2
30304: ARRAY
30305: IN
30306: NOT
30307: IFFALSE 30365
// begin SetTag ( j , 101 ) ;
30309: LD_VAR 0 3
30313: PPUSH
30314: LD_INT 101
30316: PPUSH
30317: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30321: LD_ADDR_EXP 91
30325: PUSH
30326: LD_EXP 91
30330: PPUSH
30331: LD_VAR 0 2
30335: PUSH
30336: LD_EXP 91
30340: PUSH
30341: LD_VAR 0 2
30345: ARRAY
30346: PUSH
30347: LD_INT 1
30349: PLUS
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PPUSH
30355: LD_VAR 0 3
30359: PPUSH
30360: CALL 55693 0 3
30364: ST_TO_ADDR
// end ; wait ( 1 ) ;
30365: LD_INT 1
30367: PPUSH
30368: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30372: LD_ADDR_VAR 0 7
30376: PUSH
30377: LD_EXP 90
30381: PUSH
30382: LD_VAR 0 2
30386: ARRAY
30387: ST_TO_ADDR
// if mc_scan [ i ] then
30388: LD_EXP 112
30392: PUSH
30393: LD_VAR 0 2
30397: ARRAY
30398: IFFALSE 30460
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30400: LD_ADDR_VAR 0 7
30404: PUSH
30405: LD_EXP 90
30409: PUSH
30410: LD_VAR 0 2
30414: ARRAY
30415: PPUSH
30416: LD_INT 3
30418: PUSH
30419: LD_INT 30
30421: PUSH
30422: LD_INT 32
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 30
30431: PUSH
30432: LD_INT 33
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: PUSH
30439: LD_INT 30
30441: PUSH
30442: LD_INT 31
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: PPUSH
30455: CALL_OW 72
30459: ST_TO_ADDR
// if not to_repair_tmp then
30460: LD_VAR 0 7
30464: NOT
30465: IFFALSE 30469
// continue ;
30467: GO 30267
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30469: LD_ADDR_VAR 0 8
30473: PUSH
30474: LD_VAR 0 7
30478: PPUSH
30479: LD_VAR 0 3
30483: PPUSH
30484: CALL_OW 74
30488: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
30489: LD_VAR 0 8
30493: PPUSH
30494: LD_INT 16
30496: PPUSH
30497: CALL 58286 0 2
30501: PUSH
30502: LD_INT 4
30504: ARRAY
30505: PUSH
30506: LD_INT 5
30508: LESS
30509: IFFALSE 30525
// ComRepairBuilding ( j , to_repair ) ;
30511: LD_VAR 0 3
30515: PPUSH
30516: LD_VAR 0 8
30520: PPUSH
30521: CALL_OW 130
// end ;
30525: GO 30267
30527: POP
30528: POP
// end ;
30529: GO 29713
30531: POP
30532: POP
// end ;
30533: LD_VAR 0 1
30537: RET
// export function MC_Heal ; var i , j , tmp ; begin
30538: LD_INT 0
30540: PPUSH
30541: PPUSH
30542: PPUSH
30543: PPUSH
// if not mc_bases then
30544: LD_EXP 89
30548: NOT
30549: IFFALSE 30553
// exit ;
30551: GO 30955
// for i = 1 to mc_bases do
30553: LD_ADDR_VAR 0 2
30557: PUSH
30558: DOUBLE
30559: LD_INT 1
30561: DEC
30562: ST_TO_ADDR
30563: LD_EXP 89
30567: PUSH
30568: FOR_TO
30569: IFFALSE 30953
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30571: LD_EXP 92
30575: PUSH
30576: LD_VAR 0 2
30580: ARRAY
30581: PUSH
30582: LD_INT 1
30584: ARRAY
30585: NOT
30586: PUSH
30587: LD_EXP 92
30591: PUSH
30592: LD_VAR 0 2
30596: ARRAY
30597: PUSH
30598: LD_INT 2
30600: ARRAY
30601: NOT
30602: AND
30603: IFFALSE 30641
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30605: LD_ADDR_EXP 93
30609: PUSH
30610: LD_EXP 93
30614: PPUSH
30615: LD_VAR 0 2
30619: PPUSH
30620: EMPTY
30621: PPUSH
30622: CALL_OW 1
30626: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30627: LD_VAR 0 2
30631: PPUSH
30632: LD_INT 102
30634: PPUSH
30635: CALL 24802 0 2
// continue ;
30639: GO 30568
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30641: LD_ADDR_VAR 0 4
30645: PUSH
30646: LD_EXP 89
30650: PUSH
30651: LD_VAR 0 2
30655: ARRAY
30656: PPUSH
30657: LD_INT 25
30659: PUSH
30660: LD_INT 4
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PPUSH
30667: CALL_OW 72
30671: ST_TO_ADDR
// if not tmp then
30672: LD_VAR 0 4
30676: NOT
30677: IFFALSE 30681
// continue ;
30679: GO 30568
// if mc_taming [ i ] then
30681: LD_EXP 120
30685: PUSH
30686: LD_VAR 0 2
30690: ARRAY
30691: IFFALSE 30715
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30693: LD_ADDR_EXP 120
30697: PUSH
30698: LD_EXP 120
30702: PPUSH
30703: LD_VAR 0 2
30707: PPUSH
30708: EMPTY
30709: PPUSH
30710: CALL_OW 1
30714: ST_TO_ADDR
// for j in tmp do
30715: LD_ADDR_VAR 0 3
30719: PUSH
30720: LD_VAR 0 4
30724: PUSH
30725: FOR_IN
30726: IFFALSE 30949
// begin if IsInUnit ( j ) then
30728: LD_VAR 0 3
30732: PPUSH
30733: CALL_OW 310
30737: IFFALSE 30748
// ComExitBuilding ( j ) ;
30739: LD_VAR 0 3
30743: PPUSH
30744: CALL_OW 122
// if not j in mc_healers [ i ] then
30748: LD_VAR 0 3
30752: PUSH
30753: LD_EXP 93
30757: PUSH
30758: LD_VAR 0 2
30762: ARRAY
30763: IN
30764: NOT
30765: IFFALSE 30811
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30767: LD_ADDR_EXP 93
30771: PUSH
30772: LD_EXP 93
30776: PPUSH
30777: LD_VAR 0 2
30781: PUSH
30782: LD_EXP 93
30786: PUSH
30787: LD_VAR 0 2
30791: ARRAY
30792: PUSH
30793: LD_INT 1
30795: PLUS
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PPUSH
30801: LD_VAR 0 3
30805: PPUSH
30806: CALL 55693 0 3
30810: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30811: LD_VAR 0 3
30815: PPUSH
30816: CALL_OW 110
30820: PUSH
30821: LD_INT 102
30823: NONEQUAL
30824: IFFALSE 30838
// SetTag ( j , 102 ) ;
30826: LD_VAR 0 3
30830: PPUSH
30831: LD_INT 102
30833: PPUSH
30834: CALL_OW 109
// Wait ( 3 ) ;
30838: LD_INT 3
30840: PPUSH
30841: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30845: LD_EXP 92
30849: PUSH
30850: LD_VAR 0 2
30854: ARRAY
30855: PUSH
30856: LD_INT 1
30858: ARRAY
30859: IFFALSE 30891
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30861: LD_VAR 0 3
30865: PPUSH
30866: LD_EXP 92
30870: PUSH
30871: LD_VAR 0 2
30875: ARRAY
30876: PUSH
30877: LD_INT 1
30879: ARRAY
30880: PUSH
30881: LD_INT 1
30883: ARRAY
30884: PPUSH
30885: CALL_OW 128
30889: GO 30947
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30891: LD_VAR 0 3
30895: PPUSH
30896: CALL_OW 314
30900: NOT
30901: PUSH
30902: LD_EXP 92
30906: PUSH
30907: LD_VAR 0 2
30911: ARRAY
30912: PUSH
30913: LD_INT 2
30915: ARRAY
30916: AND
30917: IFFALSE 30947
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30919: LD_VAR 0 3
30923: PPUSH
30924: LD_EXP 92
30928: PUSH
30929: LD_VAR 0 2
30933: ARRAY
30934: PUSH
30935: LD_INT 2
30937: ARRAY
30938: PUSH
30939: LD_INT 1
30941: ARRAY
30942: PPUSH
30943: CALL_OW 128
// end ;
30947: GO 30725
30949: POP
30950: POP
// end ;
30951: GO 30568
30953: POP
30954: POP
// end ;
30955: LD_VAR 0 1
30959: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30960: LD_INT 0
30962: PPUSH
30963: PPUSH
30964: PPUSH
30965: PPUSH
30966: PPUSH
// if not mc_bases then
30967: LD_EXP 89
30971: NOT
30972: IFFALSE 30976
// exit ;
30974: GO 32119
// for i = 1 to mc_bases do
30976: LD_ADDR_VAR 0 2
30980: PUSH
30981: DOUBLE
30982: LD_INT 1
30984: DEC
30985: ST_TO_ADDR
30986: LD_EXP 89
30990: PUSH
30991: FOR_TO
30992: IFFALSE 32117
// begin if mc_scan [ i ] then
30994: LD_EXP 112
30998: PUSH
30999: LD_VAR 0 2
31003: ARRAY
31004: IFFALSE 31008
// continue ;
31006: GO 30991
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31008: LD_EXP 94
31012: PUSH
31013: LD_VAR 0 2
31017: ARRAY
31018: NOT
31019: PUSH
31020: LD_EXP 96
31024: PUSH
31025: LD_VAR 0 2
31029: ARRAY
31030: NOT
31031: AND
31032: PUSH
31033: LD_EXP 95
31037: PUSH
31038: LD_VAR 0 2
31042: ARRAY
31043: AND
31044: IFFALSE 31082
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31046: LD_ADDR_EXP 95
31050: PUSH
31051: LD_EXP 95
31055: PPUSH
31056: LD_VAR 0 2
31060: PPUSH
31061: EMPTY
31062: PPUSH
31063: CALL_OW 1
31067: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31068: LD_VAR 0 2
31072: PPUSH
31073: LD_INT 103
31075: PPUSH
31076: CALL 24802 0 2
// continue ;
31080: GO 30991
// end ; if mc_construct_list [ i ] then
31082: LD_EXP 96
31086: PUSH
31087: LD_VAR 0 2
31091: ARRAY
31092: IFFALSE 31312
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31094: LD_ADDR_VAR 0 4
31098: PUSH
31099: LD_EXP 89
31103: PUSH
31104: LD_VAR 0 2
31108: ARRAY
31109: PPUSH
31110: LD_INT 25
31112: PUSH
31113: LD_INT 2
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PPUSH
31120: CALL_OW 72
31124: PUSH
31125: LD_EXP 91
31129: PUSH
31130: LD_VAR 0 2
31134: ARRAY
31135: DIFF
31136: ST_TO_ADDR
// if not tmp then
31137: LD_VAR 0 4
31141: NOT
31142: IFFALSE 31146
// continue ;
31144: GO 30991
// for j in tmp do
31146: LD_ADDR_VAR 0 3
31150: PUSH
31151: LD_VAR 0 4
31155: PUSH
31156: FOR_IN
31157: IFFALSE 31308
// begin if not mc_builders [ i ] then
31159: LD_EXP 95
31163: PUSH
31164: LD_VAR 0 2
31168: ARRAY
31169: NOT
31170: IFFALSE 31228
// begin SetTag ( j , 103 ) ;
31172: LD_VAR 0 3
31176: PPUSH
31177: LD_INT 103
31179: PPUSH
31180: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31184: LD_ADDR_EXP 95
31188: PUSH
31189: LD_EXP 95
31193: PPUSH
31194: LD_VAR 0 2
31198: PUSH
31199: LD_EXP 95
31203: PUSH
31204: LD_VAR 0 2
31208: ARRAY
31209: PUSH
31210: LD_INT 1
31212: PLUS
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PPUSH
31218: LD_VAR 0 3
31222: PPUSH
31223: CALL 55693 0 3
31227: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31228: LD_VAR 0 3
31232: PPUSH
31233: CALL_OW 310
31237: IFFALSE 31248
// ComExitBuilding ( j ) ;
31239: LD_VAR 0 3
31243: PPUSH
31244: CALL_OW 122
// wait ( 3 ) ;
31248: LD_INT 3
31250: PPUSH
31251: CALL_OW 67
// if not mc_construct_list [ i ] then
31255: LD_EXP 96
31259: PUSH
31260: LD_VAR 0 2
31264: ARRAY
31265: NOT
31266: IFFALSE 31270
// break ;
31268: GO 31308
// if not HasTask ( j ) then
31270: LD_VAR 0 3
31274: PPUSH
31275: CALL_OW 314
31279: NOT
31280: IFFALSE 31306
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31282: LD_VAR 0 3
31286: PPUSH
31287: LD_EXP 96
31291: PUSH
31292: LD_VAR 0 2
31296: ARRAY
31297: PUSH
31298: LD_INT 1
31300: ARRAY
31301: PPUSH
31302: CALL 58544 0 2
// end ;
31306: GO 31156
31308: POP
31309: POP
// end else
31310: GO 32115
// if mc_build_list [ i ] then
31312: LD_EXP 94
31316: PUSH
31317: LD_VAR 0 2
31321: ARRAY
31322: IFFALSE 32115
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31324: LD_ADDR_VAR 0 5
31328: PUSH
31329: LD_EXP 89
31333: PUSH
31334: LD_VAR 0 2
31338: ARRAY
31339: PPUSH
31340: LD_INT 2
31342: PUSH
31343: LD_INT 30
31345: PUSH
31346: LD_INT 0
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 30
31355: PUSH
31356: LD_INT 1
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: LIST
31367: PPUSH
31368: CALL_OW 72
31372: ST_TO_ADDR
// if depot then
31373: LD_VAR 0 5
31377: IFFALSE 31395
// depot := depot [ 1 ] else
31379: LD_ADDR_VAR 0 5
31383: PUSH
31384: LD_VAR 0 5
31388: PUSH
31389: LD_INT 1
31391: ARRAY
31392: ST_TO_ADDR
31393: GO 31403
// depot := 0 ;
31395: LD_ADDR_VAR 0 5
31399: PUSH
31400: LD_INT 0
31402: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31403: LD_EXP 94
31407: PUSH
31408: LD_VAR 0 2
31412: ARRAY
31413: PUSH
31414: LD_INT 1
31416: ARRAY
31417: PUSH
31418: LD_INT 1
31420: ARRAY
31421: PPUSH
31422: CALL 58374 0 1
31426: PUSH
31427: LD_EXP 89
31431: PUSH
31432: LD_VAR 0 2
31436: ARRAY
31437: PPUSH
31438: LD_INT 2
31440: PUSH
31441: LD_INT 30
31443: PUSH
31444: LD_INT 2
31446: PUSH
31447: EMPTY
31448: LIST
31449: LIST
31450: PUSH
31451: LD_INT 30
31453: PUSH
31454: LD_INT 3
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: LIST
31465: PPUSH
31466: CALL_OW 72
31470: NOT
31471: AND
31472: IFFALSE 31577
// begin for j = 1 to mc_build_list [ i ] do
31474: LD_ADDR_VAR 0 3
31478: PUSH
31479: DOUBLE
31480: LD_INT 1
31482: DEC
31483: ST_TO_ADDR
31484: LD_EXP 94
31488: PUSH
31489: LD_VAR 0 2
31493: ARRAY
31494: PUSH
31495: FOR_TO
31496: IFFALSE 31575
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31498: LD_EXP 94
31502: PUSH
31503: LD_VAR 0 2
31507: ARRAY
31508: PUSH
31509: LD_VAR 0 3
31513: ARRAY
31514: PUSH
31515: LD_INT 1
31517: ARRAY
31518: PUSH
31519: LD_INT 2
31521: EQUAL
31522: IFFALSE 31573
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31524: LD_ADDR_EXP 94
31528: PUSH
31529: LD_EXP 94
31533: PPUSH
31534: LD_VAR 0 2
31538: PPUSH
31539: LD_EXP 94
31543: PUSH
31544: LD_VAR 0 2
31548: ARRAY
31549: PPUSH
31550: LD_VAR 0 3
31554: PPUSH
31555: LD_INT 1
31557: PPUSH
31558: LD_INT 0
31560: PPUSH
31561: CALL 55111 0 4
31565: PPUSH
31566: CALL_OW 1
31570: ST_TO_ADDR
// break ;
31571: GO 31575
// end ;
31573: GO 31495
31575: POP
31576: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31577: LD_EXP 94
31581: PUSH
31582: LD_VAR 0 2
31586: ARRAY
31587: PUSH
31588: LD_INT 1
31590: ARRAY
31591: PUSH
31592: LD_INT 1
31594: ARRAY
31595: PUSH
31596: LD_INT 0
31598: EQUAL
31599: PUSH
31600: LD_VAR 0 5
31604: PUSH
31605: LD_VAR 0 5
31609: PPUSH
31610: LD_EXP 94
31614: PUSH
31615: LD_VAR 0 2
31619: ARRAY
31620: PUSH
31621: LD_INT 1
31623: ARRAY
31624: PUSH
31625: LD_INT 1
31627: ARRAY
31628: PPUSH
31629: LD_EXP 94
31633: PUSH
31634: LD_VAR 0 2
31638: ARRAY
31639: PUSH
31640: LD_INT 1
31642: ARRAY
31643: PUSH
31644: LD_INT 2
31646: ARRAY
31647: PPUSH
31648: LD_EXP 94
31652: PUSH
31653: LD_VAR 0 2
31657: ARRAY
31658: PUSH
31659: LD_INT 1
31661: ARRAY
31662: PUSH
31663: LD_INT 3
31665: ARRAY
31666: PPUSH
31667: LD_EXP 94
31671: PUSH
31672: LD_VAR 0 2
31676: ARRAY
31677: PUSH
31678: LD_INT 1
31680: ARRAY
31681: PUSH
31682: LD_INT 4
31684: ARRAY
31685: PPUSH
31686: CALL 63108 0 5
31690: AND
31691: OR
31692: IFFALSE 31973
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31694: LD_ADDR_VAR 0 4
31698: PUSH
31699: LD_EXP 89
31703: PUSH
31704: LD_VAR 0 2
31708: ARRAY
31709: PPUSH
31710: LD_INT 25
31712: PUSH
31713: LD_INT 2
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PPUSH
31720: CALL_OW 72
31724: PUSH
31725: LD_EXP 91
31729: PUSH
31730: LD_VAR 0 2
31734: ARRAY
31735: DIFF
31736: ST_TO_ADDR
// if not tmp then
31737: LD_VAR 0 4
31741: NOT
31742: IFFALSE 31746
// continue ;
31744: GO 30991
// for j in tmp do
31746: LD_ADDR_VAR 0 3
31750: PUSH
31751: LD_VAR 0 4
31755: PUSH
31756: FOR_IN
31757: IFFALSE 31969
// begin if not mc_builders [ i ] then
31759: LD_EXP 95
31763: PUSH
31764: LD_VAR 0 2
31768: ARRAY
31769: NOT
31770: IFFALSE 31828
// begin SetTag ( j , 103 ) ;
31772: LD_VAR 0 3
31776: PPUSH
31777: LD_INT 103
31779: PPUSH
31780: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31784: LD_ADDR_EXP 95
31788: PUSH
31789: LD_EXP 95
31793: PPUSH
31794: LD_VAR 0 2
31798: PUSH
31799: LD_EXP 95
31803: PUSH
31804: LD_VAR 0 2
31808: ARRAY
31809: PUSH
31810: LD_INT 1
31812: PLUS
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PPUSH
31818: LD_VAR 0 3
31822: PPUSH
31823: CALL 55693 0 3
31827: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31828: LD_VAR 0 3
31832: PPUSH
31833: CALL_OW 310
31837: IFFALSE 31848
// ComExitBuilding ( j ) ;
31839: LD_VAR 0 3
31843: PPUSH
31844: CALL_OW 122
// wait ( 3 ) ;
31848: LD_INT 3
31850: PPUSH
31851: CALL_OW 67
// if not mc_build_list [ i ] then
31855: LD_EXP 94
31859: PUSH
31860: LD_VAR 0 2
31864: ARRAY
31865: NOT
31866: IFFALSE 31870
// break ;
31868: GO 31969
// if not HasTask ( j ) then
31870: LD_VAR 0 3
31874: PPUSH
31875: CALL_OW 314
31879: NOT
31880: IFFALSE 31967
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31882: LD_VAR 0 3
31886: PPUSH
31887: LD_EXP 94
31891: PUSH
31892: LD_VAR 0 2
31896: ARRAY
31897: PUSH
31898: LD_INT 1
31900: ARRAY
31901: PUSH
31902: LD_INT 1
31904: ARRAY
31905: PPUSH
31906: LD_EXP 94
31910: PUSH
31911: LD_VAR 0 2
31915: ARRAY
31916: PUSH
31917: LD_INT 1
31919: ARRAY
31920: PUSH
31921: LD_INT 2
31923: ARRAY
31924: PPUSH
31925: LD_EXP 94
31929: PUSH
31930: LD_VAR 0 2
31934: ARRAY
31935: PUSH
31936: LD_INT 1
31938: ARRAY
31939: PUSH
31940: LD_INT 3
31942: ARRAY
31943: PPUSH
31944: LD_EXP 94
31948: PUSH
31949: LD_VAR 0 2
31953: ARRAY
31954: PUSH
31955: LD_INT 1
31957: ARRAY
31958: PUSH
31959: LD_INT 4
31961: ARRAY
31962: PPUSH
31963: CALL_OW 145
// end ;
31967: GO 31756
31969: POP
31970: POP
// end else
31971: GO 32115
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31973: LD_EXP 89
31977: PUSH
31978: LD_VAR 0 2
31982: ARRAY
31983: PPUSH
31984: LD_EXP 94
31988: PUSH
31989: LD_VAR 0 2
31993: ARRAY
31994: PUSH
31995: LD_INT 1
31997: ARRAY
31998: PUSH
31999: LD_INT 1
32001: ARRAY
32002: PPUSH
32003: LD_EXP 94
32007: PUSH
32008: LD_VAR 0 2
32012: ARRAY
32013: PUSH
32014: LD_INT 1
32016: ARRAY
32017: PUSH
32018: LD_INT 2
32020: ARRAY
32021: PPUSH
32022: LD_EXP 94
32026: PUSH
32027: LD_VAR 0 2
32031: ARRAY
32032: PUSH
32033: LD_INT 1
32035: ARRAY
32036: PUSH
32037: LD_INT 3
32039: ARRAY
32040: PPUSH
32041: LD_EXP 94
32045: PUSH
32046: LD_VAR 0 2
32050: ARRAY
32051: PUSH
32052: LD_INT 1
32054: ARRAY
32055: PUSH
32056: LD_INT 4
32058: ARRAY
32059: PPUSH
32060: CALL 62444 0 5
32064: NOT
32065: IFFALSE 32115
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32067: LD_ADDR_EXP 94
32071: PUSH
32072: LD_EXP 94
32076: PPUSH
32077: LD_VAR 0 2
32081: PPUSH
32082: LD_EXP 94
32086: PUSH
32087: LD_VAR 0 2
32091: ARRAY
32092: PPUSH
32093: LD_INT 1
32095: PPUSH
32096: LD_INT 1
32098: NEG
32099: PPUSH
32100: LD_INT 0
32102: PPUSH
32103: CALL 55111 0 4
32107: PPUSH
32108: CALL_OW 1
32112: ST_TO_ADDR
// continue ;
32113: GO 30991
// end ; end ; end ;
32115: GO 30991
32117: POP
32118: POP
// end ;
32119: LD_VAR 0 1
32123: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32124: LD_INT 0
32126: PPUSH
32127: PPUSH
32128: PPUSH
32129: PPUSH
32130: PPUSH
32131: PPUSH
// if not mc_bases then
32132: LD_EXP 89
32136: NOT
32137: IFFALSE 32141
// exit ;
32139: GO 32568
// for i = 1 to mc_bases do
32141: LD_ADDR_VAR 0 2
32145: PUSH
32146: DOUBLE
32147: LD_INT 1
32149: DEC
32150: ST_TO_ADDR
32151: LD_EXP 89
32155: PUSH
32156: FOR_TO
32157: IFFALSE 32566
// begin tmp := mc_build_upgrade [ i ] ;
32159: LD_ADDR_VAR 0 4
32163: PUSH
32164: LD_EXP 121
32168: PUSH
32169: LD_VAR 0 2
32173: ARRAY
32174: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32175: LD_ADDR_VAR 0 6
32179: PUSH
32180: LD_EXP 122
32184: PUSH
32185: LD_VAR 0 2
32189: ARRAY
32190: PPUSH
32191: LD_INT 2
32193: PUSH
32194: LD_INT 30
32196: PUSH
32197: LD_INT 6
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 30
32206: PUSH
32207: LD_INT 7
32209: PUSH
32210: EMPTY
32211: LIST
32212: LIST
32213: PUSH
32214: EMPTY
32215: LIST
32216: LIST
32217: LIST
32218: PPUSH
32219: CALL_OW 72
32223: ST_TO_ADDR
// if not tmp and not lab then
32224: LD_VAR 0 4
32228: NOT
32229: PUSH
32230: LD_VAR 0 6
32234: NOT
32235: AND
32236: IFFALSE 32240
// continue ;
32238: GO 32156
// if tmp then
32240: LD_VAR 0 4
32244: IFFALSE 32364
// for j in tmp do
32246: LD_ADDR_VAR 0 3
32250: PUSH
32251: LD_VAR 0 4
32255: PUSH
32256: FOR_IN
32257: IFFALSE 32362
// begin if UpgradeCost ( j ) then
32259: LD_VAR 0 3
32263: PPUSH
32264: CALL 62104 0 1
32268: IFFALSE 32360
// begin ComUpgrade ( j ) ;
32270: LD_VAR 0 3
32274: PPUSH
32275: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32279: LD_ADDR_EXP 121
32283: PUSH
32284: LD_EXP 121
32288: PPUSH
32289: LD_VAR 0 2
32293: PPUSH
32294: LD_EXP 121
32298: PUSH
32299: LD_VAR 0 2
32303: ARRAY
32304: PUSH
32305: LD_VAR 0 3
32309: DIFF
32310: PPUSH
32311: CALL_OW 1
32315: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32316: LD_ADDR_EXP 96
32320: PUSH
32321: LD_EXP 96
32325: PPUSH
32326: LD_VAR 0 2
32330: PUSH
32331: LD_EXP 96
32335: PUSH
32336: LD_VAR 0 2
32340: ARRAY
32341: PUSH
32342: LD_INT 1
32344: PLUS
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PPUSH
32350: LD_VAR 0 3
32354: PPUSH
32355: CALL 55693 0 3
32359: ST_TO_ADDR
// end ; end ;
32360: GO 32256
32362: POP
32363: POP
// if not lab or not mc_lab_upgrade [ i ] then
32364: LD_VAR 0 6
32368: NOT
32369: PUSH
32370: LD_EXP 123
32374: PUSH
32375: LD_VAR 0 2
32379: ARRAY
32380: NOT
32381: OR
32382: IFFALSE 32386
// continue ;
32384: GO 32156
// for j in lab do
32386: LD_ADDR_VAR 0 3
32390: PUSH
32391: LD_VAR 0 6
32395: PUSH
32396: FOR_IN
32397: IFFALSE 32562
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32399: LD_VAR 0 3
32403: PPUSH
32404: CALL_OW 266
32408: PUSH
32409: LD_INT 6
32411: PUSH
32412: LD_INT 7
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: IN
32419: PUSH
32420: LD_VAR 0 3
32424: PPUSH
32425: CALL_OW 461
32429: PUSH
32430: LD_INT 1
32432: NONEQUAL
32433: AND
32434: IFFALSE 32560
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32436: LD_VAR 0 3
32440: PPUSH
32441: LD_EXP 123
32445: PUSH
32446: LD_VAR 0 2
32450: ARRAY
32451: PUSH
32452: LD_INT 1
32454: ARRAY
32455: PPUSH
32456: CALL 62309 0 2
32460: IFFALSE 32560
// begin ComCancel ( j ) ;
32462: LD_VAR 0 3
32466: PPUSH
32467: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32471: LD_VAR 0 3
32475: PPUSH
32476: LD_EXP 123
32480: PUSH
32481: LD_VAR 0 2
32485: ARRAY
32486: PUSH
32487: LD_INT 1
32489: ARRAY
32490: PPUSH
32491: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32495: LD_VAR 0 3
32499: PUSH
32500: LD_EXP 96
32504: PUSH
32505: LD_VAR 0 2
32509: ARRAY
32510: IN
32511: NOT
32512: IFFALSE 32558
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32514: LD_ADDR_EXP 96
32518: PUSH
32519: LD_EXP 96
32523: PPUSH
32524: LD_VAR 0 2
32528: PUSH
32529: LD_EXP 96
32533: PUSH
32534: LD_VAR 0 2
32538: ARRAY
32539: PUSH
32540: LD_INT 1
32542: PLUS
32543: PUSH
32544: EMPTY
32545: LIST
32546: LIST
32547: PPUSH
32548: LD_VAR 0 3
32552: PPUSH
32553: CALL 55693 0 3
32557: ST_TO_ADDR
// break ;
32558: GO 32562
// end ; end ; end ;
32560: GO 32396
32562: POP
32563: POP
// end ;
32564: GO 32156
32566: POP
32567: POP
// end ;
32568: LD_VAR 0 1
32572: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32573: LD_INT 0
32575: PPUSH
32576: PPUSH
32577: PPUSH
32578: PPUSH
32579: PPUSH
32580: PPUSH
32581: PPUSH
32582: PPUSH
32583: PPUSH
// if not mc_bases then
32584: LD_EXP 89
32588: NOT
32589: IFFALSE 32593
// exit ;
32591: GO 32998
// for i = 1 to mc_bases do
32593: LD_ADDR_VAR 0 2
32597: PUSH
32598: DOUBLE
32599: LD_INT 1
32601: DEC
32602: ST_TO_ADDR
32603: LD_EXP 89
32607: PUSH
32608: FOR_TO
32609: IFFALSE 32996
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32611: LD_EXP 97
32615: PUSH
32616: LD_VAR 0 2
32620: ARRAY
32621: NOT
32622: PUSH
32623: LD_EXP 89
32627: PUSH
32628: LD_VAR 0 2
32632: ARRAY
32633: PPUSH
32634: LD_INT 30
32636: PUSH
32637: LD_INT 3
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PPUSH
32644: CALL_OW 72
32648: NOT
32649: OR
32650: IFFALSE 32654
// continue ;
32652: GO 32608
// busy := false ;
32654: LD_ADDR_VAR 0 8
32658: PUSH
32659: LD_INT 0
32661: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32662: LD_ADDR_VAR 0 4
32666: PUSH
32667: LD_EXP 89
32671: PUSH
32672: LD_VAR 0 2
32676: ARRAY
32677: PPUSH
32678: LD_INT 30
32680: PUSH
32681: LD_INT 3
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PPUSH
32688: CALL_OW 72
32692: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32693: LD_ADDR_VAR 0 6
32697: PUSH
32698: LD_EXP 97
32702: PUSH
32703: LD_VAR 0 2
32707: ARRAY
32708: PPUSH
32709: LD_INT 2
32711: PUSH
32712: LD_INT 30
32714: PUSH
32715: LD_INT 32
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 30
32724: PUSH
32725: LD_INT 33
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: LIST
32736: PPUSH
32737: CALL_OW 72
32741: ST_TO_ADDR
// if not t then
32742: LD_VAR 0 6
32746: NOT
32747: IFFALSE 32751
// continue ;
32749: GO 32608
// for j in tmp do
32751: LD_ADDR_VAR 0 3
32755: PUSH
32756: LD_VAR 0 4
32760: PUSH
32761: FOR_IN
32762: IFFALSE 32792
// if not BuildingStatus ( j ) = bs_idle then
32764: LD_VAR 0 3
32768: PPUSH
32769: CALL_OW 461
32773: PUSH
32774: LD_INT 2
32776: EQUAL
32777: NOT
32778: IFFALSE 32790
// begin busy := true ;
32780: LD_ADDR_VAR 0 8
32784: PUSH
32785: LD_INT 1
32787: ST_TO_ADDR
// break ;
32788: GO 32792
// end ;
32790: GO 32761
32792: POP
32793: POP
// if busy then
32794: LD_VAR 0 8
32798: IFFALSE 32802
// continue ;
32800: GO 32608
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32802: LD_ADDR_VAR 0 7
32806: PUSH
32807: LD_VAR 0 6
32811: PPUSH
32812: LD_INT 35
32814: PUSH
32815: LD_INT 0
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PPUSH
32822: CALL_OW 72
32826: ST_TO_ADDR
// if tw then
32827: LD_VAR 0 7
32831: IFFALSE 32908
// begin tw := tw [ 1 ] ;
32833: LD_ADDR_VAR 0 7
32837: PUSH
32838: LD_VAR 0 7
32842: PUSH
32843: LD_INT 1
32845: ARRAY
32846: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32847: LD_ADDR_VAR 0 9
32851: PUSH
32852: LD_VAR 0 7
32856: PPUSH
32857: LD_EXP 114
32861: PUSH
32862: LD_VAR 0 2
32866: ARRAY
32867: PPUSH
32868: CALL 60663 0 2
32872: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32873: LD_EXP 128
32877: PUSH
32878: LD_VAR 0 2
32882: ARRAY
32883: IFFALSE 32906
// if not weapon in mc_allowed_tower_weapons [ i ] then
32885: LD_VAR 0 9
32889: PUSH
32890: LD_EXP 128
32894: PUSH
32895: LD_VAR 0 2
32899: ARRAY
32900: IN
32901: NOT
32902: IFFALSE 32906
// continue ;
32904: GO 32608
// end else
32906: GO 32971
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32908: LD_ADDR_VAR 0 5
32912: PUSH
32913: LD_EXP 97
32917: PUSH
32918: LD_VAR 0 2
32922: ARRAY
32923: PPUSH
32924: LD_VAR 0 4
32928: PPUSH
32929: CALL 86165 0 2
32933: ST_TO_ADDR
// if not tmp2 then
32934: LD_VAR 0 5
32938: NOT
32939: IFFALSE 32943
// continue ;
32941: GO 32608
// tw := tmp2 [ 1 ] ;
32943: LD_ADDR_VAR 0 7
32947: PUSH
32948: LD_VAR 0 5
32952: PUSH
32953: LD_INT 1
32955: ARRAY
32956: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32957: LD_ADDR_VAR 0 9
32961: PUSH
32962: LD_VAR 0 5
32966: PUSH
32967: LD_INT 2
32969: ARRAY
32970: ST_TO_ADDR
// end ; if not weapon then
32971: LD_VAR 0 9
32975: NOT
32976: IFFALSE 32980
// continue ;
32978: GO 32608
// ComPlaceWeapon ( tw , weapon ) ;
32980: LD_VAR 0 7
32984: PPUSH
32985: LD_VAR 0 9
32989: PPUSH
32990: CALL_OW 148
// end ;
32994: GO 32608
32996: POP
32997: POP
// end ;
32998: LD_VAR 0 1
33002: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
33003: LD_INT 0
33005: PPUSH
33006: PPUSH
33007: PPUSH
33008: PPUSH
33009: PPUSH
33010: PPUSH
// if not mc_bases then
33011: LD_EXP 89
33015: NOT
33016: IFFALSE 33020
// exit ;
33018: GO 33796
// for i = 1 to mc_bases do
33020: LD_ADDR_VAR 0 2
33024: PUSH
33025: DOUBLE
33026: LD_INT 1
33028: DEC
33029: ST_TO_ADDR
33030: LD_EXP 89
33034: PUSH
33035: FOR_TO
33036: IFFALSE 33794
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33038: LD_EXP 102
33042: PUSH
33043: LD_VAR 0 2
33047: ARRAY
33048: NOT
33049: PUSH
33050: LD_EXP 102
33054: PUSH
33055: LD_VAR 0 2
33059: ARRAY
33060: PUSH
33061: LD_EXP 103
33065: PUSH
33066: LD_VAR 0 2
33070: ARRAY
33071: EQUAL
33072: OR
33073: PUSH
33074: LD_EXP 112
33078: PUSH
33079: LD_VAR 0 2
33083: ARRAY
33084: OR
33085: IFFALSE 33089
// continue ;
33087: GO 33035
// if mc_miners [ i ] then
33089: LD_EXP 103
33093: PUSH
33094: LD_VAR 0 2
33098: ARRAY
33099: IFFALSE 33481
// begin for j = mc_miners [ i ] downto 1 do
33101: LD_ADDR_VAR 0 3
33105: PUSH
33106: DOUBLE
33107: LD_EXP 103
33111: PUSH
33112: LD_VAR 0 2
33116: ARRAY
33117: INC
33118: ST_TO_ADDR
33119: LD_INT 1
33121: PUSH
33122: FOR_DOWNTO
33123: IFFALSE 33479
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33125: LD_EXP 103
33129: PUSH
33130: LD_VAR 0 2
33134: ARRAY
33135: PUSH
33136: LD_VAR 0 3
33140: ARRAY
33141: PPUSH
33142: CALL_OW 301
33146: PUSH
33147: LD_EXP 103
33151: PUSH
33152: LD_VAR 0 2
33156: ARRAY
33157: PUSH
33158: LD_VAR 0 3
33162: ARRAY
33163: PPUSH
33164: CALL_OW 257
33168: PUSH
33169: LD_INT 1
33171: NONEQUAL
33172: OR
33173: IFFALSE 33236
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33175: LD_ADDR_VAR 0 5
33179: PUSH
33180: LD_EXP 103
33184: PUSH
33185: LD_VAR 0 2
33189: ARRAY
33190: PUSH
33191: LD_EXP 103
33195: PUSH
33196: LD_VAR 0 2
33200: ARRAY
33201: PUSH
33202: LD_VAR 0 3
33206: ARRAY
33207: DIFF
33208: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33209: LD_ADDR_EXP 103
33213: PUSH
33214: LD_EXP 103
33218: PPUSH
33219: LD_VAR 0 2
33223: PPUSH
33224: LD_VAR 0 5
33228: PPUSH
33229: CALL_OW 1
33233: ST_TO_ADDR
// continue ;
33234: GO 33122
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33236: LD_EXP 103
33240: PUSH
33241: LD_VAR 0 2
33245: ARRAY
33246: PUSH
33247: LD_VAR 0 3
33251: ARRAY
33252: PPUSH
33253: CALL_OW 257
33257: PUSH
33258: LD_INT 1
33260: EQUAL
33261: PUSH
33262: LD_EXP 103
33266: PUSH
33267: LD_VAR 0 2
33271: ARRAY
33272: PUSH
33273: LD_VAR 0 3
33277: ARRAY
33278: PPUSH
33279: CALL_OW 459
33283: NOT
33284: AND
33285: PUSH
33286: LD_EXP 103
33290: PUSH
33291: LD_VAR 0 2
33295: ARRAY
33296: PUSH
33297: LD_VAR 0 3
33301: ARRAY
33302: PPUSH
33303: CALL_OW 314
33307: NOT
33308: AND
33309: IFFALSE 33477
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33311: LD_EXP 103
33315: PUSH
33316: LD_VAR 0 2
33320: ARRAY
33321: PUSH
33322: LD_VAR 0 3
33326: ARRAY
33327: PPUSH
33328: CALL_OW 310
33332: IFFALSE 33355
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33334: LD_EXP 103
33338: PUSH
33339: LD_VAR 0 2
33343: ARRAY
33344: PUSH
33345: LD_VAR 0 3
33349: ARRAY
33350: PPUSH
33351: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33355: LD_EXP 103
33359: PUSH
33360: LD_VAR 0 2
33364: ARRAY
33365: PUSH
33366: LD_VAR 0 3
33370: ARRAY
33371: PPUSH
33372: CALL_OW 314
33376: NOT
33377: IFFALSE 33477
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33379: LD_EXP 103
33383: PUSH
33384: LD_VAR 0 2
33388: ARRAY
33389: PUSH
33390: LD_VAR 0 3
33394: ARRAY
33395: PPUSH
33396: LD_EXP 102
33400: PUSH
33401: LD_VAR 0 2
33405: ARRAY
33406: PUSH
33407: LD_VAR 0 3
33411: PUSH
33412: LD_EXP 102
33416: PUSH
33417: LD_VAR 0 2
33421: ARRAY
33422: MOD
33423: PUSH
33424: LD_INT 1
33426: PLUS
33427: ARRAY
33428: PUSH
33429: LD_INT 1
33431: ARRAY
33432: PPUSH
33433: LD_EXP 102
33437: PUSH
33438: LD_VAR 0 2
33442: ARRAY
33443: PUSH
33444: LD_VAR 0 3
33448: PUSH
33449: LD_EXP 102
33453: PUSH
33454: LD_VAR 0 2
33458: ARRAY
33459: MOD
33460: PUSH
33461: LD_INT 1
33463: PLUS
33464: ARRAY
33465: PUSH
33466: LD_INT 2
33468: ARRAY
33469: PPUSH
33470: LD_INT 0
33472: PPUSH
33473: CALL_OW 193
// end ; end ;
33477: GO 33122
33479: POP
33480: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33481: LD_ADDR_VAR 0 5
33485: PUSH
33486: LD_EXP 89
33490: PUSH
33491: LD_VAR 0 2
33495: ARRAY
33496: PPUSH
33497: LD_INT 2
33499: PUSH
33500: LD_INT 30
33502: PUSH
33503: LD_INT 4
33505: PUSH
33506: EMPTY
33507: LIST
33508: LIST
33509: PUSH
33510: LD_INT 30
33512: PUSH
33513: LD_INT 5
33515: PUSH
33516: EMPTY
33517: LIST
33518: LIST
33519: PUSH
33520: LD_INT 30
33522: PUSH
33523: LD_INT 32
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: LIST
33534: LIST
33535: PPUSH
33536: CALL_OW 72
33540: ST_TO_ADDR
// if not tmp then
33541: LD_VAR 0 5
33545: NOT
33546: IFFALSE 33550
// continue ;
33548: GO 33035
// list := [ ] ;
33550: LD_ADDR_VAR 0 6
33554: PUSH
33555: EMPTY
33556: ST_TO_ADDR
// for j in tmp do
33557: LD_ADDR_VAR 0 3
33561: PUSH
33562: LD_VAR 0 5
33566: PUSH
33567: FOR_IN
33568: IFFALSE 33637
// begin for k in UnitsInside ( j ) do
33570: LD_ADDR_VAR 0 4
33574: PUSH
33575: LD_VAR 0 3
33579: PPUSH
33580: CALL_OW 313
33584: PUSH
33585: FOR_IN
33586: IFFALSE 33633
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33588: LD_VAR 0 4
33592: PPUSH
33593: CALL_OW 257
33597: PUSH
33598: LD_INT 1
33600: EQUAL
33601: PUSH
33602: LD_VAR 0 4
33606: PPUSH
33607: CALL_OW 459
33611: NOT
33612: AND
33613: IFFALSE 33631
// list := list ^ k ;
33615: LD_ADDR_VAR 0 6
33619: PUSH
33620: LD_VAR 0 6
33624: PUSH
33625: LD_VAR 0 4
33629: ADD
33630: ST_TO_ADDR
33631: GO 33585
33633: POP
33634: POP
// end ;
33635: GO 33567
33637: POP
33638: POP
// list := list diff mc_miners [ i ] ;
33639: LD_ADDR_VAR 0 6
33643: PUSH
33644: LD_VAR 0 6
33648: PUSH
33649: LD_EXP 103
33653: PUSH
33654: LD_VAR 0 2
33658: ARRAY
33659: DIFF
33660: ST_TO_ADDR
// if not list then
33661: LD_VAR 0 6
33665: NOT
33666: IFFALSE 33670
// continue ;
33668: GO 33035
// k := mc_mines [ i ] - mc_miners [ i ] ;
33670: LD_ADDR_VAR 0 4
33674: PUSH
33675: LD_EXP 102
33679: PUSH
33680: LD_VAR 0 2
33684: ARRAY
33685: PUSH
33686: LD_EXP 103
33690: PUSH
33691: LD_VAR 0 2
33695: ARRAY
33696: MINUS
33697: ST_TO_ADDR
// if k > list then
33698: LD_VAR 0 4
33702: PUSH
33703: LD_VAR 0 6
33707: GREATER
33708: IFFALSE 33720
// k := list ;
33710: LD_ADDR_VAR 0 4
33714: PUSH
33715: LD_VAR 0 6
33719: ST_TO_ADDR
// for j = 1 to k do
33720: LD_ADDR_VAR 0 3
33724: PUSH
33725: DOUBLE
33726: LD_INT 1
33728: DEC
33729: ST_TO_ADDR
33730: LD_VAR 0 4
33734: PUSH
33735: FOR_TO
33736: IFFALSE 33790
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33738: LD_ADDR_EXP 103
33742: PUSH
33743: LD_EXP 103
33747: PPUSH
33748: LD_VAR 0 2
33752: PUSH
33753: LD_EXP 103
33757: PUSH
33758: LD_VAR 0 2
33762: ARRAY
33763: PUSH
33764: LD_INT 1
33766: PLUS
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: PPUSH
33772: LD_VAR 0 6
33776: PUSH
33777: LD_VAR 0 3
33781: ARRAY
33782: PPUSH
33783: CALL 55693 0 3
33787: ST_TO_ADDR
33788: GO 33735
33790: POP
33791: POP
// end ;
33792: GO 33035
33794: POP
33795: POP
// end ;
33796: LD_VAR 0 1
33800: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33801: LD_INT 0
33803: PPUSH
33804: PPUSH
33805: PPUSH
33806: PPUSH
33807: PPUSH
33808: PPUSH
33809: PPUSH
33810: PPUSH
33811: PPUSH
33812: PPUSH
// if not mc_bases then
33813: LD_EXP 89
33817: NOT
33818: IFFALSE 33822
// exit ;
33820: GO 35572
// for i = 1 to mc_bases do
33822: LD_ADDR_VAR 0 2
33826: PUSH
33827: DOUBLE
33828: LD_INT 1
33830: DEC
33831: ST_TO_ADDR
33832: LD_EXP 89
33836: PUSH
33837: FOR_TO
33838: IFFALSE 35570
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33840: LD_EXP 89
33844: PUSH
33845: LD_VAR 0 2
33849: ARRAY
33850: NOT
33851: PUSH
33852: LD_EXP 96
33856: PUSH
33857: LD_VAR 0 2
33861: ARRAY
33862: OR
33863: IFFALSE 33867
// continue ;
33865: GO 33837
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33867: LD_EXP 105
33871: PUSH
33872: LD_VAR 0 2
33876: ARRAY
33877: NOT
33878: PUSH
33879: LD_EXP 106
33883: PUSH
33884: LD_VAR 0 2
33888: ARRAY
33889: AND
33890: IFFALSE 33928
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33892: LD_ADDR_EXP 106
33896: PUSH
33897: LD_EXP 106
33901: PPUSH
33902: LD_VAR 0 2
33906: PPUSH
33907: EMPTY
33908: PPUSH
33909: CALL_OW 1
33913: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33914: LD_VAR 0 2
33918: PPUSH
33919: LD_INT 107
33921: PPUSH
33922: CALL 24802 0 2
// continue ;
33926: GO 33837
// end ; target := [ ] ;
33928: LD_ADDR_VAR 0 6
33932: PUSH
33933: EMPTY
33934: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33935: LD_ADDR_VAR 0 3
33939: PUSH
33940: DOUBLE
33941: LD_EXP 105
33945: PUSH
33946: LD_VAR 0 2
33950: ARRAY
33951: INC
33952: ST_TO_ADDR
33953: LD_INT 1
33955: PUSH
33956: FOR_DOWNTO
33957: IFFALSE 34217
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33959: LD_EXP 105
33963: PUSH
33964: LD_VAR 0 2
33968: ARRAY
33969: PUSH
33970: LD_VAR 0 3
33974: ARRAY
33975: PUSH
33976: LD_INT 2
33978: ARRAY
33979: PPUSH
33980: LD_EXP 105
33984: PUSH
33985: LD_VAR 0 2
33989: ARRAY
33990: PUSH
33991: LD_VAR 0 3
33995: ARRAY
33996: PUSH
33997: LD_INT 3
33999: ARRAY
34000: PPUSH
34001: CALL_OW 488
34005: PUSH
34006: LD_EXP 105
34010: PUSH
34011: LD_VAR 0 2
34015: ARRAY
34016: PUSH
34017: LD_VAR 0 3
34021: ARRAY
34022: PUSH
34023: LD_INT 2
34025: ARRAY
34026: PPUSH
34027: LD_EXP 105
34031: PUSH
34032: LD_VAR 0 2
34036: ARRAY
34037: PUSH
34038: LD_VAR 0 3
34042: ARRAY
34043: PUSH
34044: LD_INT 3
34046: ARRAY
34047: PPUSH
34048: CALL_OW 284
34052: PUSH
34053: LD_INT 0
34055: EQUAL
34056: AND
34057: IFFALSE 34112
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34059: LD_ADDR_VAR 0 5
34063: PUSH
34064: LD_EXP 105
34068: PUSH
34069: LD_VAR 0 2
34073: ARRAY
34074: PPUSH
34075: LD_VAR 0 3
34079: PPUSH
34080: CALL_OW 3
34084: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34085: LD_ADDR_EXP 105
34089: PUSH
34090: LD_EXP 105
34094: PPUSH
34095: LD_VAR 0 2
34099: PPUSH
34100: LD_VAR 0 5
34104: PPUSH
34105: CALL_OW 1
34109: ST_TO_ADDR
// continue ;
34110: GO 33956
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34112: LD_EXP 89
34116: PUSH
34117: LD_VAR 0 2
34121: ARRAY
34122: PUSH
34123: LD_INT 1
34125: ARRAY
34126: PPUSH
34127: CALL_OW 255
34131: PPUSH
34132: LD_EXP 105
34136: PUSH
34137: LD_VAR 0 2
34141: ARRAY
34142: PUSH
34143: LD_VAR 0 3
34147: ARRAY
34148: PUSH
34149: LD_INT 2
34151: ARRAY
34152: PPUSH
34153: LD_EXP 105
34157: PUSH
34158: LD_VAR 0 2
34162: ARRAY
34163: PUSH
34164: LD_VAR 0 3
34168: ARRAY
34169: PUSH
34170: LD_INT 3
34172: ARRAY
34173: PPUSH
34174: LD_INT 30
34176: PPUSH
34177: CALL 56589 0 4
34181: PUSH
34182: LD_INT 4
34184: ARRAY
34185: PUSH
34186: LD_INT 0
34188: EQUAL
34189: IFFALSE 34215
// begin target := mc_crates [ i ] [ j ] ;
34191: LD_ADDR_VAR 0 6
34195: PUSH
34196: LD_EXP 105
34200: PUSH
34201: LD_VAR 0 2
34205: ARRAY
34206: PUSH
34207: LD_VAR 0 3
34211: ARRAY
34212: ST_TO_ADDR
// break ;
34213: GO 34217
// end ; end ;
34215: GO 33956
34217: POP
34218: POP
// if not target then
34219: LD_VAR 0 6
34223: NOT
34224: IFFALSE 34228
// continue ;
34226: GO 33837
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34228: LD_ADDR_VAR 0 7
34232: PUSH
34233: LD_EXP 108
34237: PUSH
34238: LD_VAR 0 2
34242: ARRAY
34243: PPUSH
34244: LD_INT 2
34246: PUSH
34247: LD_INT 3
34249: PUSH
34250: LD_INT 58
34252: PUSH
34253: EMPTY
34254: LIST
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: LD_INT 61
34262: PUSH
34263: EMPTY
34264: LIST
34265: PUSH
34266: LD_INT 33
34268: PUSH
34269: LD_INT 5
34271: PUSH
34272: EMPTY
34273: LIST
34274: LIST
34275: PUSH
34276: LD_INT 33
34278: PUSH
34279: LD_INT 3
34281: PUSH
34282: EMPTY
34283: LIST
34284: LIST
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: LIST
34290: LIST
34291: LIST
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: LD_INT 34
34298: PUSH
34299: LD_INT 32
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 34
34308: PUSH
34309: LD_INT 51
34311: PUSH
34312: EMPTY
34313: LIST
34314: LIST
34315: PUSH
34316: LD_INT 34
34318: PUSH
34319: LD_INT 12
34321: PUSH
34322: EMPTY
34323: LIST
34324: LIST
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: LIST
34330: LIST
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PPUSH
34336: CALL_OW 72
34340: ST_TO_ADDR
// if not cargo then
34341: LD_VAR 0 7
34345: NOT
34346: IFFALSE 34989
// begin if mc_crates_collector [ i ] < 5 then
34348: LD_EXP 106
34352: PUSH
34353: LD_VAR 0 2
34357: ARRAY
34358: PUSH
34359: LD_INT 5
34361: LESS
34362: IFFALSE 34728
// begin if mc_ape [ i ] then
34364: LD_EXP 118
34368: PUSH
34369: LD_VAR 0 2
34373: ARRAY
34374: IFFALSE 34421
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34376: LD_ADDR_VAR 0 5
34380: PUSH
34381: LD_EXP 118
34385: PUSH
34386: LD_VAR 0 2
34390: ARRAY
34391: PPUSH
34392: LD_INT 25
34394: PUSH
34395: LD_INT 16
34397: PUSH
34398: EMPTY
34399: LIST
34400: LIST
34401: PUSH
34402: LD_INT 24
34404: PUSH
34405: LD_INT 750
34407: PUSH
34408: EMPTY
34409: LIST
34410: LIST
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PPUSH
34416: CALL_OW 72
34420: ST_TO_ADDR
// if not tmp then
34421: LD_VAR 0 5
34425: NOT
34426: IFFALSE 34473
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34428: LD_ADDR_VAR 0 5
34432: PUSH
34433: LD_EXP 89
34437: PUSH
34438: LD_VAR 0 2
34442: ARRAY
34443: PPUSH
34444: LD_INT 25
34446: PUSH
34447: LD_INT 2
34449: PUSH
34450: EMPTY
34451: LIST
34452: LIST
34453: PUSH
34454: LD_INT 24
34456: PUSH
34457: LD_INT 750
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: EMPTY
34465: LIST
34466: LIST
34467: PPUSH
34468: CALL_OW 72
34472: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34473: LD_EXP 118
34477: PUSH
34478: LD_VAR 0 2
34482: ARRAY
34483: PUSH
34484: LD_EXP 89
34488: PUSH
34489: LD_VAR 0 2
34493: ARRAY
34494: PPUSH
34495: LD_INT 25
34497: PUSH
34498: LD_INT 2
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 24
34507: PUSH
34508: LD_INT 750
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PPUSH
34519: CALL_OW 72
34523: AND
34524: PUSH
34525: LD_VAR 0 5
34529: PUSH
34530: LD_INT 5
34532: LESS
34533: AND
34534: IFFALSE 34616
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34536: LD_ADDR_VAR 0 3
34540: PUSH
34541: LD_EXP 89
34545: PUSH
34546: LD_VAR 0 2
34550: ARRAY
34551: PPUSH
34552: LD_INT 25
34554: PUSH
34555: LD_INT 2
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: PUSH
34562: LD_INT 24
34564: PUSH
34565: LD_INT 750
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PPUSH
34576: CALL_OW 72
34580: PUSH
34581: FOR_IN
34582: IFFALSE 34614
// begin tmp := tmp union j ;
34584: LD_ADDR_VAR 0 5
34588: PUSH
34589: LD_VAR 0 5
34593: PUSH
34594: LD_VAR 0 3
34598: UNION
34599: ST_TO_ADDR
// if tmp >= 5 then
34600: LD_VAR 0 5
34604: PUSH
34605: LD_INT 5
34607: GREATEREQUAL
34608: IFFALSE 34612
// break ;
34610: GO 34614
// end ;
34612: GO 34581
34614: POP
34615: POP
// end ; if not tmp then
34616: LD_VAR 0 5
34620: NOT
34621: IFFALSE 34625
// continue ;
34623: GO 33837
// for j in tmp do
34625: LD_ADDR_VAR 0 3
34629: PUSH
34630: LD_VAR 0 5
34634: PUSH
34635: FOR_IN
34636: IFFALSE 34726
// if not GetTag ( j ) then
34638: LD_VAR 0 3
34642: PPUSH
34643: CALL_OW 110
34647: NOT
34648: IFFALSE 34724
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34650: LD_ADDR_EXP 106
34654: PUSH
34655: LD_EXP 106
34659: PPUSH
34660: LD_VAR 0 2
34664: PUSH
34665: LD_EXP 106
34669: PUSH
34670: LD_VAR 0 2
34674: ARRAY
34675: PUSH
34676: LD_INT 1
34678: PLUS
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PPUSH
34684: LD_VAR 0 3
34688: PPUSH
34689: CALL 55693 0 3
34693: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34694: LD_VAR 0 3
34698: PPUSH
34699: LD_INT 107
34701: PPUSH
34702: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34706: LD_EXP 106
34710: PUSH
34711: LD_VAR 0 2
34715: ARRAY
34716: PUSH
34717: LD_INT 5
34719: GREATEREQUAL
34720: IFFALSE 34724
// break ;
34722: GO 34726
// end ;
34724: GO 34635
34726: POP
34727: POP
// end ; if mc_crates_collector [ i ] and target then
34728: LD_EXP 106
34732: PUSH
34733: LD_VAR 0 2
34737: ARRAY
34738: PUSH
34739: LD_VAR 0 6
34743: AND
34744: IFFALSE 34987
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34746: LD_EXP 106
34750: PUSH
34751: LD_VAR 0 2
34755: ARRAY
34756: PUSH
34757: LD_VAR 0 6
34761: PUSH
34762: LD_INT 1
34764: ARRAY
34765: LESS
34766: IFFALSE 34786
// tmp := mc_crates_collector [ i ] else
34768: LD_ADDR_VAR 0 5
34772: PUSH
34773: LD_EXP 106
34777: PUSH
34778: LD_VAR 0 2
34782: ARRAY
34783: ST_TO_ADDR
34784: GO 34800
// tmp := target [ 1 ] ;
34786: LD_ADDR_VAR 0 5
34790: PUSH
34791: LD_VAR 0 6
34795: PUSH
34796: LD_INT 1
34798: ARRAY
34799: ST_TO_ADDR
// k := 0 ;
34800: LD_ADDR_VAR 0 4
34804: PUSH
34805: LD_INT 0
34807: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34808: LD_ADDR_VAR 0 3
34812: PUSH
34813: LD_EXP 106
34817: PUSH
34818: LD_VAR 0 2
34822: ARRAY
34823: PUSH
34824: FOR_IN
34825: IFFALSE 34985
// begin k := k + 1 ;
34827: LD_ADDR_VAR 0 4
34831: PUSH
34832: LD_VAR 0 4
34836: PUSH
34837: LD_INT 1
34839: PLUS
34840: ST_TO_ADDR
// if k > tmp then
34841: LD_VAR 0 4
34845: PUSH
34846: LD_VAR 0 5
34850: GREATER
34851: IFFALSE 34855
// break ;
34853: GO 34985
// if not GetClass ( j ) in [ 2 , 16 ] then
34855: LD_VAR 0 3
34859: PPUSH
34860: CALL_OW 257
34864: PUSH
34865: LD_INT 2
34867: PUSH
34868: LD_INT 16
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: IN
34875: NOT
34876: IFFALSE 34929
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34878: LD_ADDR_EXP 106
34882: PUSH
34883: LD_EXP 106
34887: PPUSH
34888: LD_VAR 0 2
34892: PPUSH
34893: LD_EXP 106
34897: PUSH
34898: LD_VAR 0 2
34902: ARRAY
34903: PUSH
34904: LD_VAR 0 3
34908: DIFF
34909: PPUSH
34910: CALL_OW 1
34914: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34915: LD_VAR 0 3
34919: PPUSH
34920: LD_INT 0
34922: PPUSH
34923: CALL_OW 109
// continue ;
34927: GO 34824
// end ; if IsInUnit ( j ) then
34929: LD_VAR 0 3
34933: PPUSH
34934: CALL_OW 310
34938: IFFALSE 34949
// ComExitBuilding ( j ) ;
34940: LD_VAR 0 3
34944: PPUSH
34945: CALL_OW 122
// wait ( 3 ) ;
34949: LD_INT 3
34951: PPUSH
34952: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34956: LD_VAR 0 3
34960: PPUSH
34961: LD_VAR 0 6
34965: PUSH
34966: LD_INT 2
34968: ARRAY
34969: PPUSH
34970: LD_VAR 0 6
34974: PUSH
34975: LD_INT 3
34977: ARRAY
34978: PPUSH
34979: CALL_OW 117
// end ;
34983: GO 34824
34985: POP
34986: POP
// end ; end else
34987: GO 35568
// begin for j in cargo do
34989: LD_ADDR_VAR 0 3
34993: PUSH
34994: LD_VAR 0 7
34998: PUSH
34999: FOR_IN
35000: IFFALSE 35566
// begin if GetTag ( j ) <> 0 then
35002: LD_VAR 0 3
35006: PPUSH
35007: CALL_OW 110
35011: PUSH
35012: LD_INT 0
35014: NONEQUAL
35015: IFFALSE 35019
// continue ;
35017: GO 34999
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35019: LD_VAR 0 3
35023: PPUSH
35024: CALL_OW 256
35028: PUSH
35029: LD_INT 1000
35031: LESS
35032: PUSH
35033: LD_VAR 0 3
35037: PPUSH
35038: LD_EXP 113
35042: PUSH
35043: LD_VAR 0 2
35047: ARRAY
35048: PPUSH
35049: CALL_OW 308
35053: NOT
35054: AND
35055: IFFALSE 35077
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35057: LD_VAR 0 3
35061: PPUSH
35062: LD_EXP 113
35066: PUSH
35067: LD_VAR 0 2
35071: ARRAY
35072: PPUSH
35073: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35077: LD_VAR 0 3
35081: PPUSH
35082: CALL_OW 256
35086: PUSH
35087: LD_INT 1000
35089: LESS
35090: PUSH
35091: LD_VAR 0 3
35095: PPUSH
35096: LD_EXP 113
35100: PUSH
35101: LD_VAR 0 2
35105: ARRAY
35106: PPUSH
35107: CALL_OW 308
35111: AND
35112: IFFALSE 35116
// continue ;
35114: GO 34999
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35116: LD_VAR 0 3
35120: PPUSH
35121: CALL_OW 262
35125: PUSH
35126: LD_INT 2
35128: EQUAL
35129: PUSH
35130: LD_VAR 0 3
35134: PPUSH
35135: CALL_OW 261
35139: PUSH
35140: LD_INT 15
35142: LESS
35143: AND
35144: IFFALSE 35148
// continue ;
35146: GO 34999
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35148: LD_VAR 0 3
35152: PPUSH
35153: CALL_OW 262
35157: PUSH
35158: LD_INT 1
35160: EQUAL
35161: PUSH
35162: LD_VAR 0 3
35166: PPUSH
35167: CALL_OW 261
35171: PUSH
35172: LD_INT 10
35174: LESS
35175: AND
35176: IFFALSE 35505
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35178: LD_ADDR_VAR 0 8
35182: PUSH
35183: LD_EXP 89
35187: PUSH
35188: LD_VAR 0 2
35192: ARRAY
35193: PPUSH
35194: LD_INT 2
35196: PUSH
35197: LD_INT 30
35199: PUSH
35200: LD_INT 0
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 30
35209: PUSH
35210: LD_INT 1
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: LIST
35221: PPUSH
35222: CALL_OW 72
35226: ST_TO_ADDR
// if not depot then
35227: LD_VAR 0 8
35231: NOT
35232: IFFALSE 35236
// continue ;
35234: GO 34999
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35236: LD_VAR 0 3
35240: PPUSH
35241: LD_VAR 0 8
35245: PPUSH
35246: LD_VAR 0 3
35250: PPUSH
35251: CALL_OW 74
35255: PPUSH
35256: CALL_OW 296
35260: PUSH
35261: LD_INT 6
35263: LESS
35264: IFFALSE 35280
// SetFuel ( j , 100 ) else
35266: LD_VAR 0 3
35270: PPUSH
35271: LD_INT 100
35273: PPUSH
35274: CALL_OW 240
35278: GO 35505
// if GetFuel ( j ) = 0 then
35280: LD_VAR 0 3
35284: PPUSH
35285: CALL_OW 261
35289: PUSH
35290: LD_INT 0
35292: EQUAL
35293: IFFALSE 35505
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35295: LD_ADDR_EXP 108
35299: PUSH
35300: LD_EXP 108
35304: PPUSH
35305: LD_VAR 0 2
35309: PPUSH
35310: LD_EXP 108
35314: PUSH
35315: LD_VAR 0 2
35319: ARRAY
35320: PUSH
35321: LD_VAR 0 3
35325: DIFF
35326: PPUSH
35327: CALL_OW 1
35331: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35332: LD_VAR 0 3
35336: PPUSH
35337: CALL_OW 263
35341: PUSH
35342: LD_INT 1
35344: EQUAL
35345: IFFALSE 35361
// ComExitVehicle ( IsInUnit ( j ) ) ;
35347: LD_VAR 0 3
35351: PPUSH
35352: CALL_OW 310
35356: PPUSH
35357: CALL_OW 121
// if GetControl ( j ) = control_remote then
35361: LD_VAR 0 3
35365: PPUSH
35366: CALL_OW 263
35370: PUSH
35371: LD_INT 2
35373: EQUAL
35374: IFFALSE 35385
// ComUnlink ( j ) ;
35376: LD_VAR 0 3
35380: PPUSH
35381: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35385: LD_ADDR_VAR 0 9
35389: PUSH
35390: LD_VAR 0 2
35394: PPUSH
35395: LD_INT 3
35397: PPUSH
35398: CALL 44858 0 2
35402: ST_TO_ADDR
// if fac then
35403: LD_VAR 0 9
35407: IFFALSE 35503
// begin for k in fac do
35409: LD_ADDR_VAR 0 4
35413: PUSH
35414: LD_VAR 0 9
35418: PUSH
35419: FOR_IN
35420: IFFALSE 35501
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35422: LD_ADDR_VAR 0 10
35426: PUSH
35427: LD_VAR 0 9
35431: PPUSH
35432: LD_VAR 0 3
35436: PPUSH
35437: CALL_OW 265
35441: PPUSH
35442: LD_VAR 0 3
35446: PPUSH
35447: CALL_OW 262
35451: PPUSH
35452: LD_VAR 0 3
35456: PPUSH
35457: CALL_OW 263
35461: PPUSH
35462: LD_VAR 0 3
35466: PPUSH
35467: CALL_OW 264
35471: PPUSH
35472: CALL 53225 0 5
35476: ST_TO_ADDR
// if components then
35477: LD_VAR 0 10
35481: IFFALSE 35499
// begin MC_InsertProduceList ( i , components ) ;
35483: LD_VAR 0 2
35487: PPUSH
35488: LD_VAR 0 10
35492: PPUSH
35493: CALL 44403 0 2
// break ;
35497: GO 35501
// end ; end ;
35499: GO 35419
35501: POP
35502: POP
// end ; continue ;
35503: GO 34999
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35505: LD_VAR 0 3
35509: PPUSH
35510: LD_INT 1
35512: PPUSH
35513: CALL_OW 289
35517: PUSH
35518: LD_INT 100
35520: LESS
35521: PUSH
35522: LD_VAR 0 3
35526: PPUSH
35527: CALL_OW 314
35531: NOT
35532: AND
35533: IFFALSE 35562
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35535: LD_VAR 0 3
35539: PPUSH
35540: LD_VAR 0 6
35544: PUSH
35545: LD_INT 2
35547: ARRAY
35548: PPUSH
35549: LD_VAR 0 6
35553: PUSH
35554: LD_INT 3
35556: ARRAY
35557: PPUSH
35558: CALL_OW 117
// break ;
35562: GO 35566
// end ;
35564: GO 34999
35566: POP
35567: POP
// end ; end ;
35568: GO 33837
35570: POP
35571: POP
// end ;
35572: LD_VAR 0 1
35576: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35577: LD_INT 0
35579: PPUSH
35580: PPUSH
35581: PPUSH
35582: PPUSH
// if not mc_bases then
35583: LD_EXP 89
35587: NOT
35588: IFFALSE 35592
// exit ;
35590: GO 35753
// for i = 1 to mc_bases do
35592: LD_ADDR_VAR 0 2
35596: PUSH
35597: DOUBLE
35598: LD_INT 1
35600: DEC
35601: ST_TO_ADDR
35602: LD_EXP 89
35606: PUSH
35607: FOR_TO
35608: IFFALSE 35751
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35610: LD_ADDR_VAR 0 4
35614: PUSH
35615: LD_EXP 108
35619: PUSH
35620: LD_VAR 0 2
35624: ARRAY
35625: PUSH
35626: LD_EXP 111
35630: PUSH
35631: LD_VAR 0 2
35635: ARRAY
35636: UNION
35637: PPUSH
35638: LD_INT 33
35640: PUSH
35641: LD_INT 2
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PPUSH
35648: CALL_OW 72
35652: ST_TO_ADDR
// if tmp then
35653: LD_VAR 0 4
35657: IFFALSE 35749
// for j in tmp do
35659: LD_ADDR_VAR 0 3
35663: PUSH
35664: LD_VAR 0 4
35668: PUSH
35669: FOR_IN
35670: IFFALSE 35747
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35672: LD_VAR 0 3
35676: PPUSH
35677: CALL_OW 312
35681: NOT
35682: PUSH
35683: LD_VAR 0 3
35687: PPUSH
35688: CALL_OW 256
35692: PUSH
35693: LD_INT 250
35695: GREATEREQUAL
35696: AND
35697: IFFALSE 35710
// Connect ( j ) else
35699: LD_VAR 0 3
35703: PPUSH
35704: CALL 58626 0 1
35708: GO 35745
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35710: LD_VAR 0 3
35714: PPUSH
35715: CALL_OW 256
35719: PUSH
35720: LD_INT 250
35722: LESS
35723: PUSH
35724: LD_VAR 0 3
35728: PPUSH
35729: CALL_OW 312
35733: AND
35734: IFFALSE 35745
// ComUnlink ( j ) ;
35736: LD_VAR 0 3
35740: PPUSH
35741: CALL_OW 136
35745: GO 35669
35747: POP
35748: POP
// end ;
35749: GO 35607
35751: POP
35752: POP
// end ;
35753: LD_VAR 0 1
35757: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35758: LD_INT 0
35760: PPUSH
35761: PPUSH
35762: PPUSH
35763: PPUSH
35764: PPUSH
// if not mc_bases then
35765: LD_EXP 89
35769: NOT
35770: IFFALSE 35774
// exit ;
35772: GO 36219
// for i = 1 to mc_bases do
35774: LD_ADDR_VAR 0 2
35778: PUSH
35779: DOUBLE
35780: LD_INT 1
35782: DEC
35783: ST_TO_ADDR
35784: LD_EXP 89
35788: PUSH
35789: FOR_TO
35790: IFFALSE 36217
// begin if not mc_produce [ i ] then
35792: LD_EXP 110
35796: PUSH
35797: LD_VAR 0 2
35801: ARRAY
35802: NOT
35803: IFFALSE 35807
// continue ;
35805: GO 35789
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35807: LD_ADDR_VAR 0 5
35811: PUSH
35812: LD_EXP 89
35816: PUSH
35817: LD_VAR 0 2
35821: ARRAY
35822: PPUSH
35823: LD_INT 30
35825: PUSH
35826: LD_INT 3
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PPUSH
35833: CALL_OW 72
35837: ST_TO_ADDR
// if not fac then
35838: LD_VAR 0 5
35842: NOT
35843: IFFALSE 35847
// continue ;
35845: GO 35789
// for j in fac do
35847: LD_ADDR_VAR 0 3
35851: PUSH
35852: LD_VAR 0 5
35856: PUSH
35857: FOR_IN
35858: IFFALSE 36213
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35860: LD_VAR 0 3
35864: PPUSH
35865: CALL_OW 461
35869: PUSH
35870: LD_INT 2
35872: NONEQUAL
35873: PUSH
35874: LD_VAR 0 3
35878: PPUSH
35879: LD_INT 15
35881: PPUSH
35882: CALL 58286 0 2
35886: PUSH
35887: LD_INT 4
35889: ARRAY
35890: OR
35891: IFFALSE 35895
// continue ;
35893: GO 35857
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35895: LD_VAR 0 3
35899: PPUSH
35900: LD_EXP 110
35904: PUSH
35905: LD_VAR 0 2
35909: ARRAY
35910: PUSH
35911: LD_INT 1
35913: ARRAY
35914: PUSH
35915: LD_INT 1
35917: ARRAY
35918: PPUSH
35919: LD_EXP 110
35923: PUSH
35924: LD_VAR 0 2
35928: ARRAY
35929: PUSH
35930: LD_INT 1
35932: ARRAY
35933: PUSH
35934: LD_INT 2
35936: ARRAY
35937: PPUSH
35938: LD_EXP 110
35942: PUSH
35943: LD_VAR 0 2
35947: ARRAY
35948: PUSH
35949: LD_INT 1
35951: ARRAY
35952: PUSH
35953: LD_INT 3
35955: ARRAY
35956: PPUSH
35957: LD_EXP 110
35961: PUSH
35962: LD_VAR 0 2
35966: ARRAY
35967: PUSH
35968: LD_INT 1
35970: ARRAY
35971: PUSH
35972: LD_INT 4
35974: ARRAY
35975: PPUSH
35976: CALL_OW 448
35980: PUSH
35981: LD_VAR 0 3
35985: PPUSH
35986: LD_EXP 110
35990: PUSH
35991: LD_VAR 0 2
35995: ARRAY
35996: PUSH
35997: LD_INT 1
35999: ARRAY
36000: PUSH
36001: LD_INT 1
36003: ARRAY
36004: PUSH
36005: LD_EXP 110
36009: PUSH
36010: LD_VAR 0 2
36014: ARRAY
36015: PUSH
36016: LD_INT 1
36018: ARRAY
36019: PUSH
36020: LD_INT 2
36022: ARRAY
36023: PUSH
36024: LD_EXP 110
36028: PUSH
36029: LD_VAR 0 2
36033: ARRAY
36034: PUSH
36035: LD_INT 1
36037: ARRAY
36038: PUSH
36039: LD_INT 3
36041: ARRAY
36042: PUSH
36043: LD_EXP 110
36047: PUSH
36048: LD_VAR 0 2
36052: ARRAY
36053: PUSH
36054: LD_INT 1
36056: ARRAY
36057: PUSH
36058: LD_INT 4
36060: ARRAY
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: LIST
36066: LIST
36067: PPUSH
36068: CALL 61957 0 2
36072: AND
36073: IFFALSE 36211
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36075: LD_VAR 0 3
36079: PPUSH
36080: LD_EXP 110
36084: PUSH
36085: LD_VAR 0 2
36089: ARRAY
36090: PUSH
36091: LD_INT 1
36093: ARRAY
36094: PUSH
36095: LD_INT 1
36097: ARRAY
36098: PPUSH
36099: LD_EXP 110
36103: PUSH
36104: LD_VAR 0 2
36108: ARRAY
36109: PUSH
36110: LD_INT 1
36112: ARRAY
36113: PUSH
36114: LD_INT 2
36116: ARRAY
36117: PPUSH
36118: LD_EXP 110
36122: PUSH
36123: LD_VAR 0 2
36127: ARRAY
36128: PUSH
36129: LD_INT 1
36131: ARRAY
36132: PUSH
36133: LD_INT 3
36135: ARRAY
36136: PPUSH
36137: LD_EXP 110
36141: PUSH
36142: LD_VAR 0 2
36146: ARRAY
36147: PUSH
36148: LD_INT 1
36150: ARRAY
36151: PUSH
36152: LD_INT 4
36154: ARRAY
36155: PPUSH
36156: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36160: LD_ADDR_VAR 0 4
36164: PUSH
36165: LD_EXP 110
36169: PUSH
36170: LD_VAR 0 2
36174: ARRAY
36175: PPUSH
36176: LD_INT 1
36178: PPUSH
36179: CALL_OW 3
36183: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36184: LD_ADDR_EXP 110
36188: PUSH
36189: LD_EXP 110
36193: PPUSH
36194: LD_VAR 0 2
36198: PPUSH
36199: LD_VAR 0 4
36203: PPUSH
36204: CALL_OW 1
36208: ST_TO_ADDR
// break ;
36209: GO 36213
// end ; end ;
36211: GO 35857
36213: POP
36214: POP
// end ;
36215: GO 35789
36217: POP
36218: POP
// end ;
36219: LD_VAR 0 1
36223: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36224: LD_INT 0
36226: PPUSH
36227: PPUSH
36228: PPUSH
// if not mc_bases then
36229: LD_EXP 89
36233: NOT
36234: IFFALSE 36238
// exit ;
36236: GO 36327
// for i = 1 to mc_bases do
36238: LD_ADDR_VAR 0 2
36242: PUSH
36243: DOUBLE
36244: LD_INT 1
36246: DEC
36247: ST_TO_ADDR
36248: LD_EXP 89
36252: PUSH
36253: FOR_TO
36254: IFFALSE 36325
// begin if mc_attack [ i ] then
36256: LD_EXP 109
36260: PUSH
36261: LD_VAR 0 2
36265: ARRAY
36266: IFFALSE 36323
// begin tmp := mc_attack [ i ] [ 1 ] ;
36268: LD_ADDR_VAR 0 3
36272: PUSH
36273: LD_EXP 109
36277: PUSH
36278: LD_VAR 0 2
36282: ARRAY
36283: PUSH
36284: LD_INT 1
36286: ARRAY
36287: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36288: LD_ADDR_EXP 109
36292: PUSH
36293: LD_EXP 109
36297: PPUSH
36298: LD_VAR 0 2
36302: PPUSH
36303: EMPTY
36304: PPUSH
36305: CALL_OW 1
36309: ST_TO_ADDR
// Attack ( tmp ) ;
36310: LD_VAR 0 3
36314: PPUSH
36315: CALL 101591 0 1
// exit ;
36319: POP
36320: POP
36321: GO 36327
// end ; end ;
36323: GO 36253
36325: POP
36326: POP
// end ;
36327: LD_VAR 0 1
36331: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36332: LD_INT 0
36334: PPUSH
36335: PPUSH
36336: PPUSH
36337: PPUSH
36338: PPUSH
36339: PPUSH
36340: PPUSH
// if not mc_bases then
36341: LD_EXP 89
36345: NOT
36346: IFFALSE 36350
// exit ;
36348: GO 36932
// for i = 1 to mc_bases do
36350: LD_ADDR_VAR 0 2
36354: PUSH
36355: DOUBLE
36356: LD_INT 1
36358: DEC
36359: ST_TO_ADDR
36360: LD_EXP 89
36364: PUSH
36365: FOR_TO
36366: IFFALSE 36930
// begin if not mc_bases [ i ] then
36368: LD_EXP 89
36372: PUSH
36373: LD_VAR 0 2
36377: ARRAY
36378: NOT
36379: IFFALSE 36383
// continue ;
36381: GO 36365
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36383: LD_ADDR_VAR 0 7
36387: PUSH
36388: LD_EXP 89
36392: PUSH
36393: LD_VAR 0 2
36397: ARRAY
36398: PUSH
36399: LD_INT 1
36401: ARRAY
36402: PPUSH
36403: CALL 52529 0 1
36407: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36408: LD_ADDR_EXP 112
36412: PUSH
36413: LD_EXP 112
36417: PPUSH
36418: LD_VAR 0 2
36422: PPUSH
36423: LD_EXP 89
36427: PUSH
36428: LD_VAR 0 2
36432: ARRAY
36433: PUSH
36434: LD_INT 1
36436: ARRAY
36437: PPUSH
36438: CALL_OW 255
36442: PPUSH
36443: LD_EXP 114
36447: PUSH
36448: LD_VAR 0 2
36452: ARRAY
36453: PPUSH
36454: CALL 52494 0 2
36458: PPUSH
36459: CALL_OW 1
36463: ST_TO_ADDR
// if not mc_scan [ i ] then
36464: LD_EXP 112
36468: PUSH
36469: LD_VAR 0 2
36473: ARRAY
36474: NOT
36475: IFFALSE 36630
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36477: LD_ADDR_VAR 0 4
36481: PUSH
36482: LD_EXP 89
36486: PUSH
36487: LD_VAR 0 2
36491: ARRAY
36492: PPUSH
36493: LD_INT 2
36495: PUSH
36496: LD_INT 25
36498: PUSH
36499: LD_INT 5
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 25
36508: PUSH
36509: LD_INT 8
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: LD_INT 25
36518: PUSH
36519: LD_INT 9
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: PPUSH
36532: CALL_OW 72
36536: ST_TO_ADDR
// if not tmp then
36537: LD_VAR 0 4
36541: NOT
36542: IFFALSE 36546
// continue ;
36544: GO 36365
// for j in tmp do
36546: LD_ADDR_VAR 0 3
36550: PUSH
36551: LD_VAR 0 4
36555: PUSH
36556: FOR_IN
36557: IFFALSE 36628
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36559: LD_VAR 0 3
36563: PPUSH
36564: CALL_OW 310
36568: PPUSH
36569: CALL_OW 266
36573: PUSH
36574: LD_INT 5
36576: EQUAL
36577: PUSH
36578: LD_VAR 0 3
36582: PPUSH
36583: CALL_OW 257
36587: PUSH
36588: LD_INT 1
36590: EQUAL
36591: AND
36592: PUSH
36593: LD_VAR 0 3
36597: PPUSH
36598: CALL_OW 459
36602: NOT
36603: AND
36604: PUSH
36605: LD_VAR 0 7
36609: AND
36610: IFFALSE 36626
// ComChangeProfession ( j , class ) ;
36612: LD_VAR 0 3
36616: PPUSH
36617: LD_VAR 0 7
36621: PPUSH
36622: CALL_OW 123
36626: GO 36556
36628: POP
36629: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36630: LD_EXP 112
36634: PUSH
36635: LD_VAR 0 2
36639: ARRAY
36640: PUSH
36641: LD_EXP 111
36645: PUSH
36646: LD_VAR 0 2
36650: ARRAY
36651: NOT
36652: AND
36653: PUSH
36654: LD_EXP 89
36658: PUSH
36659: LD_VAR 0 2
36663: ARRAY
36664: PPUSH
36665: LD_INT 30
36667: PUSH
36668: LD_INT 32
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PPUSH
36675: CALL_OW 72
36679: NOT
36680: AND
36681: PUSH
36682: LD_EXP 89
36686: PUSH
36687: LD_VAR 0 2
36691: ARRAY
36692: PPUSH
36693: LD_INT 2
36695: PUSH
36696: LD_INT 30
36698: PUSH
36699: LD_INT 4
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 30
36708: PUSH
36709: LD_INT 5
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: LIST
36720: PPUSH
36721: CALL_OW 72
36725: NOT
36726: AND
36727: IFFALSE 36859
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36729: LD_ADDR_VAR 0 4
36733: PUSH
36734: LD_EXP 89
36738: PUSH
36739: LD_VAR 0 2
36743: ARRAY
36744: PPUSH
36745: LD_INT 2
36747: PUSH
36748: LD_INT 25
36750: PUSH
36751: LD_INT 1
36753: PUSH
36754: EMPTY
36755: LIST
36756: LIST
36757: PUSH
36758: LD_INT 25
36760: PUSH
36761: LD_INT 5
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 25
36770: PUSH
36771: LD_INT 8
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 25
36780: PUSH
36781: LD_INT 9
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: PPUSH
36795: CALL_OW 72
36799: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36800: LD_ADDR_VAR 0 4
36804: PUSH
36805: LD_VAR 0 4
36809: PUSH
36810: LD_VAR 0 4
36814: PPUSH
36815: LD_INT 18
36817: PPUSH
36818: CALL 84254 0 2
36822: DIFF
36823: ST_TO_ADDR
// if tmp then
36824: LD_VAR 0 4
36828: IFFALSE 36859
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36830: LD_VAR 0 2
36834: PPUSH
36835: LD_VAR 0 4
36839: PPUSH
36840: LD_EXP 114
36844: PUSH
36845: LD_VAR 0 2
36849: ARRAY
36850: PPUSH
36851: CALL 106300 0 3
// exit ;
36855: POP
36856: POP
36857: GO 36932
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36859: LD_EXP 112
36863: PUSH
36864: LD_VAR 0 2
36868: ARRAY
36869: PUSH
36870: LD_EXP 111
36874: PUSH
36875: LD_VAR 0 2
36879: ARRAY
36880: AND
36881: IFFALSE 36928
// begin tmp := mc_defender [ i ] ;
36883: LD_ADDR_VAR 0 4
36887: PUSH
36888: LD_EXP 111
36892: PUSH
36893: LD_VAR 0 2
36897: ARRAY
36898: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36899: LD_VAR 0 2
36903: PPUSH
36904: LD_VAR 0 4
36908: PPUSH
36909: LD_EXP 112
36913: PUSH
36914: LD_VAR 0 2
36918: ARRAY
36919: PPUSH
36920: CALL 106861 0 3
// exit ;
36924: POP
36925: POP
36926: GO 36932
// end ; end ;
36928: GO 36365
36930: POP
36931: POP
// end ;
36932: LD_VAR 0 1
36936: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36937: LD_INT 0
36939: PPUSH
36940: PPUSH
36941: PPUSH
36942: PPUSH
36943: PPUSH
36944: PPUSH
36945: PPUSH
36946: PPUSH
36947: PPUSH
36948: PPUSH
36949: PPUSH
// if not mc_bases then
36950: LD_EXP 89
36954: NOT
36955: IFFALSE 36959
// exit ;
36957: GO 38046
// for i = 1 to mc_bases do
36959: LD_ADDR_VAR 0 2
36963: PUSH
36964: DOUBLE
36965: LD_INT 1
36967: DEC
36968: ST_TO_ADDR
36969: LD_EXP 89
36973: PUSH
36974: FOR_TO
36975: IFFALSE 38044
// begin tmp := mc_lab [ i ] ;
36977: LD_ADDR_VAR 0 6
36981: PUSH
36982: LD_EXP 122
36986: PUSH
36987: LD_VAR 0 2
36991: ARRAY
36992: ST_TO_ADDR
// if not tmp then
36993: LD_VAR 0 6
36997: NOT
36998: IFFALSE 37002
// continue ;
37000: GO 36974
// idle_lab := 0 ;
37002: LD_ADDR_VAR 0 11
37006: PUSH
37007: LD_INT 0
37009: ST_TO_ADDR
// for j in tmp do
37010: LD_ADDR_VAR 0 3
37014: PUSH
37015: LD_VAR 0 6
37019: PUSH
37020: FOR_IN
37021: IFFALSE 38040
// begin researching := false ;
37023: LD_ADDR_VAR 0 10
37027: PUSH
37028: LD_INT 0
37030: ST_TO_ADDR
// side := GetSide ( j ) ;
37031: LD_ADDR_VAR 0 4
37035: PUSH
37036: LD_VAR 0 3
37040: PPUSH
37041: CALL_OW 255
37045: ST_TO_ADDR
// if not mc_tech [ side ] then
37046: LD_EXP 116
37050: PUSH
37051: LD_VAR 0 4
37055: ARRAY
37056: NOT
37057: IFFALSE 37061
// continue ;
37059: GO 37020
// if BuildingStatus ( j ) = bs_idle then
37061: LD_VAR 0 3
37065: PPUSH
37066: CALL_OW 461
37070: PUSH
37071: LD_INT 2
37073: EQUAL
37074: IFFALSE 37262
// begin if idle_lab and UnitsInside ( j ) < 6 then
37076: LD_VAR 0 11
37080: PUSH
37081: LD_VAR 0 3
37085: PPUSH
37086: CALL_OW 313
37090: PUSH
37091: LD_INT 6
37093: LESS
37094: AND
37095: IFFALSE 37166
// begin tmp2 := UnitsInside ( idle_lab ) ;
37097: LD_ADDR_VAR 0 9
37101: PUSH
37102: LD_VAR 0 11
37106: PPUSH
37107: CALL_OW 313
37111: ST_TO_ADDR
// if tmp2 then
37112: LD_VAR 0 9
37116: IFFALSE 37158
// for x in tmp2 do
37118: LD_ADDR_VAR 0 7
37122: PUSH
37123: LD_VAR 0 9
37127: PUSH
37128: FOR_IN
37129: IFFALSE 37156
// begin ComExitBuilding ( x ) ;
37131: LD_VAR 0 7
37135: PPUSH
37136: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37140: LD_VAR 0 7
37144: PPUSH
37145: LD_VAR 0 3
37149: PPUSH
37150: CALL_OW 180
// end ;
37154: GO 37128
37156: POP
37157: POP
// idle_lab := 0 ;
37158: LD_ADDR_VAR 0 11
37162: PUSH
37163: LD_INT 0
37165: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37166: LD_ADDR_VAR 0 5
37170: PUSH
37171: LD_EXP 116
37175: PUSH
37176: LD_VAR 0 4
37180: ARRAY
37181: PUSH
37182: FOR_IN
37183: IFFALSE 37243
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37185: LD_VAR 0 3
37189: PPUSH
37190: LD_VAR 0 5
37194: PPUSH
37195: CALL_OW 430
37199: PUSH
37200: LD_VAR 0 4
37204: PPUSH
37205: LD_VAR 0 5
37209: PPUSH
37210: CALL 51599 0 2
37214: AND
37215: IFFALSE 37241
// begin researching := true ;
37217: LD_ADDR_VAR 0 10
37221: PUSH
37222: LD_INT 1
37224: ST_TO_ADDR
// ComResearch ( j , t ) ;
37225: LD_VAR 0 3
37229: PPUSH
37230: LD_VAR 0 5
37234: PPUSH
37235: CALL_OW 124
// break ;
37239: GO 37243
// end ;
37241: GO 37182
37243: POP
37244: POP
// if not researching then
37245: LD_VAR 0 10
37249: NOT
37250: IFFALSE 37262
// idle_lab := j ;
37252: LD_ADDR_VAR 0 11
37256: PUSH
37257: LD_VAR 0 3
37261: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37262: LD_VAR 0 3
37266: PPUSH
37267: CALL_OW 461
37271: PUSH
37272: LD_INT 10
37274: EQUAL
37275: IFFALSE 37863
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37277: LD_EXP 118
37281: PUSH
37282: LD_VAR 0 2
37286: ARRAY
37287: NOT
37288: PUSH
37289: LD_EXP 119
37293: PUSH
37294: LD_VAR 0 2
37298: ARRAY
37299: NOT
37300: AND
37301: PUSH
37302: LD_EXP 116
37306: PUSH
37307: LD_VAR 0 4
37311: ARRAY
37312: PUSH
37313: LD_INT 1
37315: GREATER
37316: AND
37317: IFFALSE 37448
// begin ComCancel ( j ) ;
37319: LD_VAR 0 3
37323: PPUSH
37324: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37328: LD_ADDR_EXP 116
37332: PUSH
37333: LD_EXP 116
37337: PPUSH
37338: LD_VAR 0 4
37342: PPUSH
37343: LD_EXP 116
37347: PUSH
37348: LD_VAR 0 4
37352: ARRAY
37353: PPUSH
37354: LD_EXP 116
37358: PUSH
37359: LD_VAR 0 4
37363: ARRAY
37364: PUSH
37365: LD_INT 1
37367: MINUS
37368: PPUSH
37369: LD_EXP 116
37373: PUSH
37374: LD_VAR 0 4
37378: ARRAY
37379: PPUSH
37380: LD_INT 0
37382: PPUSH
37383: CALL 55111 0 4
37387: PPUSH
37388: CALL_OW 1
37392: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37393: LD_ADDR_EXP 116
37397: PUSH
37398: LD_EXP 116
37402: PPUSH
37403: LD_VAR 0 4
37407: PPUSH
37408: LD_EXP 116
37412: PUSH
37413: LD_VAR 0 4
37417: ARRAY
37418: PPUSH
37419: LD_EXP 116
37423: PUSH
37424: LD_VAR 0 4
37428: ARRAY
37429: PPUSH
37430: LD_INT 1
37432: PPUSH
37433: LD_INT 0
37435: PPUSH
37436: CALL 55111 0 4
37440: PPUSH
37441: CALL_OW 1
37445: ST_TO_ADDR
// continue ;
37446: GO 37020
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37448: LD_EXP 118
37452: PUSH
37453: LD_VAR 0 2
37457: ARRAY
37458: PUSH
37459: LD_EXP 119
37463: PUSH
37464: LD_VAR 0 2
37468: ARRAY
37469: NOT
37470: AND
37471: IFFALSE 37598
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37473: LD_ADDR_EXP 119
37477: PUSH
37478: LD_EXP 119
37482: PPUSH
37483: LD_VAR 0 2
37487: PUSH
37488: LD_EXP 119
37492: PUSH
37493: LD_VAR 0 2
37497: ARRAY
37498: PUSH
37499: LD_INT 1
37501: PLUS
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PPUSH
37507: LD_EXP 118
37511: PUSH
37512: LD_VAR 0 2
37516: ARRAY
37517: PUSH
37518: LD_INT 1
37520: ARRAY
37521: PPUSH
37522: CALL 55693 0 3
37526: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37527: LD_EXP 118
37531: PUSH
37532: LD_VAR 0 2
37536: ARRAY
37537: PUSH
37538: LD_INT 1
37540: ARRAY
37541: PPUSH
37542: LD_INT 112
37544: PPUSH
37545: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37549: LD_ADDR_VAR 0 9
37553: PUSH
37554: LD_EXP 118
37558: PUSH
37559: LD_VAR 0 2
37563: ARRAY
37564: PPUSH
37565: LD_INT 1
37567: PPUSH
37568: CALL_OW 3
37572: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37573: LD_ADDR_EXP 118
37577: PUSH
37578: LD_EXP 118
37582: PPUSH
37583: LD_VAR 0 2
37587: PPUSH
37588: LD_VAR 0 9
37592: PPUSH
37593: CALL_OW 1
37597: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37598: LD_EXP 118
37602: PUSH
37603: LD_VAR 0 2
37607: ARRAY
37608: PUSH
37609: LD_EXP 119
37613: PUSH
37614: LD_VAR 0 2
37618: ARRAY
37619: AND
37620: PUSH
37621: LD_EXP 119
37625: PUSH
37626: LD_VAR 0 2
37630: ARRAY
37631: PUSH
37632: LD_INT 1
37634: ARRAY
37635: PPUSH
37636: CALL_OW 310
37640: NOT
37641: AND
37642: PUSH
37643: LD_VAR 0 3
37647: PPUSH
37648: CALL_OW 313
37652: PUSH
37653: LD_INT 6
37655: EQUAL
37656: AND
37657: IFFALSE 37713
// begin tmp2 := UnitsInside ( j ) ;
37659: LD_ADDR_VAR 0 9
37663: PUSH
37664: LD_VAR 0 3
37668: PPUSH
37669: CALL_OW 313
37673: ST_TO_ADDR
// if tmp2 = 6 then
37674: LD_VAR 0 9
37678: PUSH
37679: LD_INT 6
37681: EQUAL
37682: IFFALSE 37713
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37684: LD_VAR 0 9
37688: PUSH
37689: LD_INT 1
37691: ARRAY
37692: PPUSH
37693: LD_INT 112
37695: PPUSH
37696: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37700: LD_VAR 0 9
37704: PUSH
37705: LD_INT 1
37707: ARRAY
37708: PPUSH
37709: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37713: LD_EXP 119
37717: PUSH
37718: LD_VAR 0 2
37722: ARRAY
37723: PUSH
37724: LD_EXP 119
37728: PUSH
37729: LD_VAR 0 2
37733: ARRAY
37734: PUSH
37735: LD_INT 1
37737: ARRAY
37738: PPUSH
37739: CALL_OW 314
37743: NOT
37744: AND
37745: PUSH
37746: LD_EXP 119
37750: PUSH
37751: LD_VAR 0 2
37755: ARRAY
37756: PUSH
37757: LD_INT 1
37759: ARRAY
37760: PPUSH
37761: CALL_OW 310
37765: NOT
37766: AND
37767: IFFALSE 37793
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37769: LD_EXP 119
37773: PUSH
37774: LD_VAR 0 2
37778: ARRAY
37779: PUSH
37780: LD_INT 1
37782: ARRAY
37783: PPUSH
37784: LD_VAR 0 3
37788: PPUSH
37789: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37793: LD_EXP 119
37797: PUSH
37798: LD_VAR 0 2
37802: ARRAY
37803: PUSH
37804: LD_INT 1
37806: ARRAY
37807: PPUSH
37808: CALL_OW 310
37812: PUSH
37813: LD_EXP 119
37817: PUSH
37818: LD_VAR 0 2
37822: ARRAY
37823: PUSH
37824: LD_INT 1
37826: ARRAY
37827: PPUSH
37828: CALL_OW 310
37832: PPUSH
37833: CALL_OW 461
37837: PUSH
37838: LD_INT 3
37840: NONEQUAL
37841: AND
37842: IFFALSE 37863
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37844: LD_EXP 119
37848: PUSH
37849: LD_VAR 0 2
37853: ARRAY
37854: PUSH
37855: LD_INT 1
37857: ARRAY
37858: PPUSH
37859: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37863: LD_VAR 0 3
37867: PPUSH
37868: CALL_OW 461
37872: PUSH
37873: LD_INT 6
37875: EQUAL
37876: PUSH
37877: LD_VAR 0 6
37881: PUSH
37882: LD_INT 1
37884: GREATER
37885: AND
37886: IFFALSE 38038
// begin sci := [ ] ;
37888: LD_ADDR_VAR 0 8
37892: PUSH
37893: EMPTY
37894: ST_TO_ADDR
// for x in ( tmp diff j ) do
37895: LD_ADDR_VAR 0 7
37899: PUSH
37900: LD_VAR 0 6
37904: PUSH
37905: LD_VAR 0 3
37909: DIFF
37910: PUSH
37911: FOR_IN
37912: IFFALSE 37964
// begin if sci = 6 then
37914: LD_VAR 0 8
37918: PUSH
37919: LD_INT 6
37921: EQUAL
37922: IFFALSE 37926
// break ;
37924: GO 37964
// if BuildingStatus ( x ) = bs_idle then
37926: LD_VAR 0 7
37930: PPUSH
37931: CALL_OW 461
37935: PUSH
37936: LD_INT 2
37938: EQUAL
37939: IFFALSE 37962
// sci := sci ^ UnitsInside ( x ) ;
37941: LD_ADDR_VAR 0 8
37945: PUSH
37946: LD_VAR 0 8
37950: PUSH
37951: LD_VAR 0 7
37955: PPUSH
37956: CALL_OW 313
37960: ADD
37961: ST_TO_ADDR
// end ;
37962: GO 37911
37964: POP
37965: POP
// if not sci then
37966: LD_VAR 0 8
37970: NOT
37971: IFFALSE 37975
// continue ;
37973: GO 37020
// for x in sci do
37975: LD_ADDR_VAR 0 7
37979: PUSH
37980: LD_VAR 0 8
37984: PUSH
37985: FOR_IN
37986: IFFALSE 38036
// if IsInUnit ( x ) and not HasTask ( x ) then
37988: LD_VAR 0 7
37992: PPUSH
37993: CALL_OW 310
37997: PUSH
37998: LD_VAR 0 7
38002: PPUSH
38003: CALL_OW 314
38007: NOT
38008: AND
38009: IFFALSE 38034
// begin ComExitBuilding ( x ) ;
38011: LD_VAR 0 7
38015: PPUSH
38016: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38020: LD_VAR 0 7
38024: PPUSH
38025: LD_VAR 0 3
38029: PPUSH
38030: CALL_OW 180
// end ;
38034: GO 37985
38036: POP
38037: POP
// end ; end ;
38038: GO 37020
38040: POP
38041: POP
// end ;
38042: GO 36974
38044: POP
38045: POP
// end ;
38046: LD_VAR 0 1
38050: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38051: LD_INT 0
38053: PPUSH
38054: PPUSH
// if not mc_bases then
38055: LD_EXP 89
38059: NOT
38060: IFFALSE 38064
// exit ;
38062: GO 38145
// for i = 1 to mc_bases do
38064: LD_ADDR_VAR 0 2
38068: PUSH
38069: DOUBLE
38070: LD_INT 1
38072: DEC
38073: ST_TO_ADDR
38074: LD_EXP 89
38078: PUSH
38079: FOR_TO
38080: IFFALSE 38143
// if mc_mines [ i ] and mc_miners [ i ] then
38082: LD_EXP 102
38086: PUSH
38087: LD_VAR 0 2
38091: ARRAY
38092: PUSH
38093: LD_EXP 103
38097: PUSH
38098: LD_VAR 0 2
38102: ARRAY
38103: AND
38104: IFFALSE 38141
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38106: LD_EXP 103
38110: PUSH
38111: LD_VAR 0 2
38115: ARRAY
38116: PUSH
38117: LD_INT 1
38119: ARRAY
38120: PPUSH
38121: CALL_OW 255
38125: PPUSH
38126: LD_EXP 102
38130: PUSH
38131: LD_VAR 0 2
38135: ARRAY
38136: PPUSH
38137: CALL 52682 0 2
38141: GO 38079
38143: POP
38144: POP
// end ;
38145: LD_VAR 0 1
38149: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38150: LD_INT 0
38152: PPUSH
38153: PPUSH
38154: PPUSH
38155: PPUSH
38156: PPUSH
38157: PPUSH
38158: PPUSH
38159: PPUSH
// if not mc_bases or not mc_parking then
38160: LD_EXP 89
38164: NOT
38165: PUSH
38166: LD_EXP 113
38170: NOT
38171: OR
38172: IFFALSE 38176
// exit ;
38174: GO 38875
// for i = 1 to mc_bases do
38176: LD_ADDR_VAR 0 2
38180: PUSH
38181: DOUBLE
38182: LD_INT 1
38184: DEC
38185: ST_TO_ADDR
38186: LD_EXP 89
38190: PUSH
38191: FOR_TO
38192: IFFALSE 38873
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38194: LD_EXP 89
38198: PUSH
38199: LD_VAR 0 2
38203: ARRAY
38204: NOT
38205: PUSH
38206: LD_EXP 113
38210: PUSH
38211: LD_VAR 0 2
38215: ARRAY
38216: NOT
38217: OR
38218: IFFALSE 38222
// continue ;
38220: GO 38191
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38222: LD_ADDR_VAR 0 5
38226: PUSH
38227: LD_EXP 89
38231: PUSH
38232: LD_VAR 0 2
38236: ARRAY
38237: PUSH
38238: LD_INT 1
38240: ARRAY
38241: PPUSH
38242: CALL_OW 255
38246: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38247: LD_ADDR_VAR 0 6
38251: PUSH
38252: LD_EXP 89
38256: PUSH
38257: LD_VAR 0 2
38261: ARRAY
38262: PPUSH
38263: LD_INT 30
38265: PUSH
38266: LD_INT 3
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PPUSH
38273: CALL_OW 72
38277: ST_TO_ADDR
// if not fac then
38278: LD_VAR 0 6
38282: NOT
38283: IFFALSE 38334
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38285: LD_ADDR_VAR 0 6
38289: PUSH
38290: LD_EXP 89
38294: PUSH
38295: LD_VAR 0 2
38299: ARRAY
38300: PPUSH
38301: LD_INT 2
38303: PUSH
38304: LD_INT 30
38306: PUSH
38307: LD_INT 0
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 30
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: LIST
38328: PPUSH
38329: CALL_OW 72
38333: ST_TO_ADDR
// if not fac then
38334: LD_VAR 0 6
38338: NOT
38339: IFFALSE 38343
// continue ;
38341: GO 38191
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38343: LD_ADDR_VAR 0 7
38347: PUSH
38348: LD_EXP 113
38352: PUSH
38353: LD_VAR 0 2
38357: ARRAY
38358: PPUSH
38359: LD_INT 22
38361: PUSH
38362: LD_VAR 0 5
38366: PUSH
38367: EMPTY
38368: LIST
38369: LIST
38370: PUSH
38371: LD_INT 21
38373: PUSH
38374: LD_INT 2
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: PUSH
38381: LD_INT 3
38383: PUSH
38384: LD_INT 24
38386: PUSH
38387: LD_INT 1000
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: LIST
38402: PPUSH
38403: CALL_OW 70
38407: ST_TO_ADDR
// for j in fac do
38408: LD_ADDR_VAR 0 3
38412: PUSH
38413: LD_VAR 0 6
38417: PUSH
38418: FOR_IN
38419: IFFALSE 38500
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38421: LD_ADDR_VAR 0 7
38425: PUSH
38426: LD_VAR 0 7
38430: PUSH
38431: LD_INT 22
38433: PUSH
38434: LD_VAR 0 5
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 91
38445: PUSH
38446: LD_VAR 0 3
38450: PUSH
38451: LD_INT 15
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 21
38461: PUSH
38462: LD_INT 2
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 3
38471: PUSH
38472: LD_INT 24
38474: PUSH
38475: LD_INT 1000
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: LIST
38490: LIST
38491: PPUSH
38492: CALL_OW 69
38496: UNION
38497: ST_TO_ADDR
38498: GO 38418
38500: POP
38501: POP
// if not vehs then
38502: LD_VAR 0 7
38506: NOT
38507: IFFALSE 38533
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38509: LD_ADDR_EXP 101
38513: PUSH
38514: LD_EXP 101
38518: PPUSH
38519: LD_VAR 0 2
38523: PPUSH
38524: EMPTY
38525: PPUSH
38526: CALL_OW 1
38530: ST_TO_ADDR
// continue ;
38531: GO 38191
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38533: LD_ADDR_VAR 0 8
38537: PUSH
38538: LD_EXP 89
38542: PUSH
38543: LD_VAR 0 2
38547: ARRAY
38548: PPUSH
38549: LD_INT 30
38551: PUSH
38552: LD_INT 3
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PPUSH
38559: CALL_OW 72
38563: ST_TO_ADDR
// if tmp then
38564: LD_VAR 0 8
38568: IFFALSE 38671
// begin for j in tmp do
38570: LD_ADDR_VAR 0 3
38574: PUSH
38575: LD_VAR 0 8
38579: PUSH
38580: FOR_IN
38581: IFFALSE 38669
// for k in UnitsInside ( j ) do
38583: LD_ADDR_VAR 0 4
38587: PUSH
38588: LD_VAR 0 3
38592: PPUSH
38593: CALL_OW 313
38597: PUSH
38598: FOR_IN
38599: IFFALSE 38665
// if k then
38601: LD_VAR 0 4
38605: IFFALSE 38663
// if not k in mc_repair_vehicle [ i ] then
38607: LD_VAR 0 4
38611: PUSH
38612: LD_EXP 101
38616: PUSH
38617: LD_VAR 0 2
38621: ARRAY
38622: IN
38623: NOT
38624: IFFALSE 38663
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38626: LD_ADDR_EXP 101
38630: PUSH
38631: LD_EXP 101
38635: PPUSH
38636: LD_VAR 0 2
38640: PPUSH
38641: LD_EXP 101
38645: PUSH
38646: LD_VAR 0 2
38650: ARRAY
38651: PUSH
38652: LD_VAR 0 4
38656: UNION
38657: PPUSH
38658: CALL_OW 1
38662: ST_TO_ADDR
38663: GO 38598
38665: POP
38666: POP
38667: GO 38580
38669: POP
38670: POP
// end ; if not mc_repair_vehicle [ i ] then
38671: LD_EXP 101
38675: PUSH
38676: LD_VAR 0 2
38680: ARRAY
38681: NOT
38682: IFFALSE 38686
// continue ;
38684: GO 38191
// for j in mc_repair_vehicle [ i ] do
38686: LD_ADDR_VAR 0 3
38690: PUSH
38691: LD_EXP 101
38695: PUSH
38696: LD_VAR 0 2
38700: ARRAY
38701: PUSH
38702: FOR_IN
38703: IFFALSE 38869
// begin if GetClass ( j ) <> 3 then
38705: LD_VAR 0 3
38709: PPUSH
38710: CALL_OW 257
38714: PUSH
38715: LD_INT 3
38717: NONEQUAL
38718: IFFALSE 38759
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38720: LD_ADDR_EXP 101
38724: PUSH
38725: LD_EXP 101
38729: PPUSH
38730: LD_VAR 0 2
38734: PPUSH
38735: LD_EXP 101
38739: PUSH
38740: LD_VAR 0 2
38744: ARRAY
38745: PUSH
38746: LD_VAR 0 3
38750: DIFF
38751: PPUSH
38752: CALL_OW 1
38756: ST_TO_ADDR
// continue ;
38757: GO 38702
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38759: LD_VAR 0 3
38763: PPUSH
38764: CALL_OW 311
38768: NOT
38769: PUSH
38770: LD_VAR 0 3
38774: PUSH
38775: LD_EXP 92
38779: PUSH
38780: LD_VAR 0 2
38784: ARRAY
38785: PUSH
38786: LD_INT 1
38788: ARRAY
38789: IN
38790: NOT
38791: AND
38792: PUSH
38793: LD_VAR 0 3
38797: PUSH
38798: LD_EXP 92
38802: PUSH
38803: LD_VAR 0 2
38807: ARRAY
38808: PUSH
38809: LD_INT 2
38811: ARRAY
38812: IN
38813: NOT
38814: AND
38815: IFFALSE 38867
// begin if IsInUnit ( j ) then
38817: LD_VAR 0 3
38821: PPUSH
38822: CALL_OW 310
38826: IFFALSE 38837
// ComExitBuilding ( j ) ;
38828: LD_VAR 0 3
38832: PPUSH
38833: CALL_OW 122
// if not HasTask ( j ) then
38837: LD_VAR 0 3
38841: PPUSH
38842: CALL_OW 314
38846: NOT
38847: IFFALSE 38867
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38849: LD_VAR 0 3
38853: PPUSH
38854: LD_VAR 0 7
38858: PUSH
38859: LD_INT 1
38861: ARRAY
38862: PPUSH
38863: CALL_OW 189
// end ; end ;
38867: GO 38702
38869: POP
38870: POP
// end ;
38871: GO 38191
38873: POP
38874: POP
// end ;
38875: LD_VAR 0 1
38879: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38880: LD_INT 0
38882: PPUSH
38883: PPUSH
38884: PPUSH
38885: PPUSH
38886: PPUSH
38887: PPUSH
38888: PPUSH
38889: PPUSH
38890: PPUSH
38891: PPUSH
38892: PPUSH
// if not mc_bases then
38893: LD_EXP 89
38897: NOT
38898: IFFALSE 38902
// exit ;
38900: GO 39704
// for i = 1 to mc_bases do
38902: LD_ADDR_VAR 0 2
38906: PUSH
38907: DOUBLE
38908: LD_INT 1
38910: DEC
38911: ST_TO_ADDR
38912: LD_EXP 89
38916: PUSH
38917: FOR_TO
38918: IFFALSE 39702
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38920: LD_EXP 117
38924: PUSH
38925: LD_VAR 0 2
38929: ARRAY
38930: NOT
38931: PUSH
38932: LD_EXP 92
38936: PUSH
38937: LD_VAR 0 2
38941: ARRAY
38942: PUSH
38943: LD_INT 1
38945: ARRAY
38946: OR
38947: PUSH
38948: LD_EXP 92
38952: PUSH
38953: LD_VAR 0 2
38957: ARRAY
38958: PUSH
38959: LD_INT 2
38961: ARRAY
38962: OR
38963: PUSH
38964: LD_EXP 115
38968: PUSH
38969: LD_VAR 0 2
38973: ARRAY
38974: PPUSH
38975: LD_INT 1
38977: PPUSH
38978: CALL_OW 325
38982: NOT
38983: OR
38984: PUSH
38985: LD_EXP 112
38989: PUSH
38990: LD_VAR 0 2
38994: ARRAY
38995: OR
38996: IFFALSE 39000
// continue ;
38998: GO 38917
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39000: LD_ADDR_VAR 0 8
39004: PUSH
39005: LD_EXP 89
39009: PUSH
39010: LD_VAR 0 2
39014: ARRAY
39015: PPUSH
39016: LD_INT 25
39018: PUSH
39019: LD_INT 4
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PUSH
39026: LD_INT 50
39028: PUSH
39029: EMPTY
39030: LIST
39031: PUSH
39032: LD_INT 3
39034: PUSH
39035: LD_INT 60
39037: PUSH
39038: EMPTY
39039: LIST
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: LIST
39049: PPUSH
39050: CALL_OW 72
39054: PUSH
39055: LD_EXP 93
39059: PUSH
39060: LD_VAR 0 2
39064: ARRAY
39065: DIFF
39066: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39067: LD_ADDR_VAR 0 9
39071: PUSH
39072: LD_EXP 89
39076: PUSH
39077: LD_VAR 0 2
39081: ARRAY
39082: PPUSH
39083: LD_INT 2
39085: PUSH
39086: LD_INT 30
39088: PUSH
39089: LD_INT 0
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: PUSH
39096: LD_INT 30
39098: PUSH
39099: LD_INT 1
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: LIST
39110: PPUSH
39111: CALL_OW 72
39115: ST_TO_ADDR
// if not tmp or not dep then
39116: LD_VAR 0 8
39120: NOT
39121: PUSH
39122: LD_VAR 0 9
39126: NOT
39127: OR
39128: IFFALSE 39132
// continue ;
39130: GO 38917
// side := GetSide ( tmp [ 1 ] ) ;
39132: LD_ADDR_VAR 0 11
39136: PUSH
39137: LD_VAR 0 8
39141: PUSH
39142: LD_INT 1
39144: ARRAY
39145: PPUSH
39146: CALL_OW 255
39150: ST_TO_ADDR
// dep := dep [ 1 ] ;
39151: LD_ADDR_VAR 0 9
39155: PUSH
39156: LD_VAR 0 9
39160: PUSH
39161: LD_INT 1
39163: ARRAY
39164: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39165: LD_ADDR_VAR 0 7
39169: PUSH
39170: LD_EXP 117
39174: PUSH
39175: LD_VAR 0 2
39179: ARRAY
39180: PPUSH
39181: LD_INT 22
39183: PUSH
39184: LD_INT 0
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 25
39193: PUSH
39194: LD_INT 12
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PPUSH
39205: CALL_OW 70
39209: PUSH
39210: LD_INT 22
39212: PUSH
39213: LD_INT 0
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 25
39222: PUSH
39223: LD_INT 12
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: PUSH
39230: LD_INT 91
39232: PUSH
39233: LD_VAR 0 9
39237: PUSH
39238: LD_INT 20
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: LIST
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: LIST
39250: PPUSH
39251: CALL_OW 69
39255: UNION
39256: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39257: LD_ADDR_VAR 0 10
39261: PUSH
39262: LD_EXP 117
39266: PUSH
39267: LD_VAR 0 2
39271: ARRAY
39272: PPUSH
39273: LD_INT 81
39275: PUSH
39276: LD_VAR 0 11
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PPUSH
39285: CALL_OW 70
39289: ST_TO_ADDR
// if not apes or danger_at_area then
39290: LD_VAR 0 7
39294: NOT
39295: PUSH
39296: LD_VAR 0 10
39300: OR
39301: IFFALSE 39351
// begin if mc_taming [ i ] then
39303: LD_EXP 120
39307: PUSH
39308: LD_VAR 0 2
39312: ARRAY
39313: IFFALSE 39349
// begin MC_Reset ( i , 121 ) ;
39315: LD_VAR 0 2
39319: PPUSH
39320: LD_INT 121
39322: PPUSH
39323: CALL 24802 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39327: LD_ADDR_EXP 120
39331: PUSH
39332: LD_EXP 120
39336: PPUSH
39337: LD_VAR 0 2
39341: PPUSH
39342: EMPTY
39343: PPUSH
39344: CALL_OW 1
39348: ST_TO_ADDR
// end ; continue ;
39349: GO 38917
// end ; for j in tmp do
39351: LD_ADDR_VAR 0 3
39355: PUSH
39356: LD_VAR 0 8
39360: PUSH
39361: FOR_IN
39362: IFFALSE 39698
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39364: LD_VAR 0 3
39368: PUSH
39369: LD_EXP 120
39373: PUSH
39374: LD_VAR 0 2
39378: ARRAY
39379: IN
39380: NOT
39381: PUSH
39382: LD_EXP 120
39386: PUSH
39387: LD_VAR 0 2
39391: ARRAY
39392: PUSH
39393: LD_INT 3
39395: LESS
39396: AND
39397: IFFALSE 39455
// begin SetTag ( j , 121 ) ;
39399: LD_VAR 0 3
39403: PPUSH
39404: LD_INT 121
39406: PPUSH
39407: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39411: LD_ADDR_EXP 120
39415: PUSH
39416: LD_EXP 120
39420: PPUSH
39421: LD_VAR 0 2
39425: PUSH
39426: LD_EXP 120
39430: PUSH
39431: LD_VAR 0 2
39435: ARRAY
39436: PUSH
39437: LD_INT 1
39439: PLUS
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PPUSH
39445: LD_VAR 0 3
39449: PPUSH
39450: CALL 55693 0 3
39454: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39455: LD_VAR 0 3
39459: PUSH
39460: LD_EXP 120
39464: PUSH
39465: LD_VAR 0 2
39469: ARRAY
39470: IN
39471: IFFALSE 39696
// begin if GetClass ( j ) <> 4 then
39473: LD_VAR 0 3
39477: PPUSH
39478: CALL_OW 257
39482: PUSH
39483: LD_INT 4
39485: NONEQUAL
39486: IFFALSE 39539
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39488: LD_ADDR_EXP 120
39492: PUSH
39493: LD_EXP 120
39497: PPUSH
39498: LD_VAR 0 2
39502: PPUSH
39503: LD_EXP 120
39507: PUSH
39508: LD_VAR 0 2
39512: ARRAY
39513: PUSH
39514: LD_VAR 0 3
39518: DIFF
39519: PPUSH
39520: CALL_OW 1
39524: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39525: LD_VAR 0 3
39529: PPUSH
39530: LD_INT 0
39532: PPUSH
39533: CALL_OW 109
// continue ;
39537: GO 39361
// end ; if IsInUnit ( j ) then
39539: LD_VAR 0 3
39543: PPUSH
39544: CALL_OW 310
39548: IFFALSE 39559
// ComExitBuilding ( j ) ;
39550: LD_VAR 0 3
39554: PPUSH
39555: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39559: LD_ADDR_VAR 0 6
39563: PUSH
39564: LD_VAR 0 7
39568: PPUSH
39569: LD_VAR 0 3
39573: PPUSH
39574: CALL_OW 74
39578: ST_TO_ADDR
// if not ape then
39579: LD_VAR 0 6
39583: NOT
39584: IFFALSE 39588
// break ;
39586: GO 39698
// x := GetX ( ape ) ;
39588: LD_ADDR_VAR 0 4
39592: PUSH
39593: LD_VAR 0 6
39597: PPUSH
39598: CALL_OW 250
39602: ST_TO_ADDR
// y := GetY ( ape ) ;
39603: LD_ADDR_VAR 0 5
39607: PUSH
39608: LD_VAR 0 6
39612: PPUSH
39613: CALL_OW 251
39617: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39618: LD_VAR 0 4
39622: PPUSH
39623: LD_VAR 0 5
39627: PPUSH
39628: CALL_OW 488
39632: NOT
39633: PUSH
39634: LD_VAR 0 11
39638: PPUSH
39639: LD_VAR 0 4
39643: PPUSH
39644: LD_VAR 0 5
39648: PPUSH
39649: LD_INT 20
39651: PPUSH
39652: CALL 56589 0 4
39656: PUSH
39657: LD_INT 4
39659: ARRAY
39660: OR
39661: IFFALSE 39665
// break ;
39663: GO 39698
// if not HasTask ( j ) then
39665: LD_VAR 0 3
39669: PPUSH
39670: CALL_OW 314
39674: NOT
39675: IFFALSE 39696
// ComTameXY ( j , x , y ) ;
39677: LD_VAR 0 3
39681: PPUSH
39682: LD_VAR 0 4
39686: PPUSH
39687: LD_VAR 0 5
39691: PPUSH
39692: CALL_OW 131
// end ; end ;
39696: GO 39361
39698: POP
39699: POP
// end ;
39700: GO 38917
39702: POP
39703: POP
// end ;
39704: LD_VAR 0 1
39708: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39709: LD_INT 0
39711: PPUSH
39712: PPUSH
39713: PPUSH
39714: PPUSH
39715: PPUSH
39716: PPUSH
39717: PPUSH
39718: PPUSH
// if not mc_bases then
39719: LD_EXP 89
39723: NOT
39724: IFFALSE 39728
// exit ;
39726: GO 40354
// for i = 1 to mc_bases do
39728: LD_ADDR_VAR 0 2
39732: PUSH
39733: DOUBLE
39734: LD_INT 1
39736: DEC
39737: ST_TO_ADDR
39738: LD_EXP 89
39742: PUSH
39743: FOR_TO
39744: IFFALSE 40352
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39746: LD_EXP 118
39750: PUSH
39751: LD_VAR 0 2
39755: ARRAY
39756: NOT
39757: PUSH
39758: LD_EXP 118
39762: PUSH
39763: LD_VAR 0 2
39767: ARRAY
39768: PPUSH
39769: LD_INT 25
39771: PUSH
39772: LD_INT 12
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PPUSH
39779: CALL_OW 72
39783: NOT
39784: OR
39785: IFFALSE 39789
// continue ;
39787: GO 39743
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39789: LD_ADDR_VAR 0 5
39793: PUSH
39794: LD_EXP 118
39798: PUSH
39799: LD_VAR 0 2
39803: ARRAY
39804: PUSH
39805: LD_INT 1
39807: ARRAY
39808: PPUSH
39809: CALL_OW 255
39813: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39814: LD_VAR 0 5
39818: PPUSH
39819: LD_INT 2
39821: PPUSH
39822: CALL_OW 325
39826: IFFALSE 40079
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39828: LD_ADDR_VAR 0 4
39832: PUSH
39833: LD_EXP 118
39837: PUSH
39838: LD_VAR 0 2
39842: ARRAY
39843: PPUSH
39844: LD_INT 25
39846: PUSH
39847: LD_INT 16
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PPUSH
39854: CALL_OW 72
39858: ST_TO_ADDR
// if tmp < 6 then
39859: LD_VAR 0 4
39863: PUSH
39864: LD_INT 6
39866: LESS
39867: IFFALSE 40079
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39869: LD_ADDR_VAR 0 6
39873: PUSH
39874: LD_EXP 89
39878: PUSH
39879: LD_VAR 0 2
39883: ARRAY
39884: PPUSH
39885: LD_INT 2
39887: PUSH
39888: LD_INT 30
39890: PUSH
39891: LD_INT 0
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: LD_INT 30
39900: PUSH
39901: LD_INT 1
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: LIST
39912: PPUSH
39913: CALL_OW 72
39917: ST_TO_ADDR
// if depot then
39918: LD_VAR 0 6
39922: IFFALSE 40079
// begin selected := 0 ;
39924: LD_ADDR_VAR 0 7
39928: PUSH
39929: LD_INT 0
39931: ST_TO_ADDR
// for j in depot do
39932: LD_ADDR_VAR 0 3
39936: PUSH
39937: LD_VAR 0 6
39941: PUSH
39942: FOR_IN
39943: IFFALSE 39974
// begin if UnitsInside ( j ) < 6 then
39945: LD_VAR 0 3
39949: PPUSH
39950: CALL_OW 313
39954: PUSH
39955: LD_INT 6
39957: LESS
39958: IFFALSE 39972
// begin selected := j ;
39960: LD_ADDR_VAR 0 7
39964: PUSH
39965: LD_VAR 0 3
39969: ST_TO_ADDR
// break ;
39970: GO 39974
// end ; end ;
39972: GO 39942
39974: POP
39975: POP
// if selected then
39976: LD_VAR 0 7
39980: IFFALSE 40079
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39982: LD_ADDR_VAR 0 3
39986: PUSH
39987: LD_EXP 118
39991: PUSH
39992: LD_VAR 0 2
39996: ARRAY
39997: PPUSH
39998: LD_INT 25
40000: PUSH
40001: LD_INT 12
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PPUSH
40008: CALL_OW 72
40012: PUSH
40013: FOR_IN
40014: IFFALSE 40077
// if not HasTask ( j ) then
40016: LD_VAR 0 3
40020: PPUSH
40021: CALL_OW 314
40025: NOT
40026: IFFALSE 40075
// begin if not IsInUnit ( j ) then
40028: LD_VAR 0 3
40032: PPUSH
40033: CALL_OW 310
40037: NOT
40038: IFFALSE 40054
// ComEnterUnit ( j , selected ) ;
40040: LD_VAR 0 3
40044: PPUSH
40045: LD_VAR 0 7
40049: PPUSH
40050: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40054: LD_VAR 0 3
40058: PPUSH
40059: LD_INT 16
40061: PPUSH
40062: CALL_OW 183
// AddComExitBuilding ( j ) ;
40066: LD_VAR 0 3
40070: PPUSH
40071: CALL_OW 182
// end ;
40075: GO 40013
40077: POP
40078: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40079: LD_VAR 0 5
40083: PPUSH
40084: LD_INT 11
40086: PPUSH
40087: CALL_OW 325
40091: IFFALSE 40350
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40093: LD_ADDR_VAR 0 4
40097: PUSH
40098: LD_EXP 118
40102: PUSH
40103: LD_VAR 0 2
40107: ARRAY
40108: PPUSH
40109: LD_INT 25
40111: PUSH
40112: LD_INT 16
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PPUSH
40119: CALL_OW 72
40123: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40124: LD_VAR 0 4
40128: PUSH
40129: LD_INT 6
40131: GREATEREQUAL
40132: PUSH
40133: LD_VAR 0 5
40137: PPUSH
40138: LD_INT 2
40140: PPUSH
40141: CALL_OW 325
40145: NOT
40146: OR
40147: IFFALSE 40350
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40149: LD_ADDR_VAR 0 8
40153: PUSH
40154: LD_EXP 89
40158: PUSH
40159: LD_VAR 0 2
40163: ARRAY
40164: PPUSH
40165: LD_INT 2
40167: PUSH
40168: LD_INT 30
40170: PUSH
40171: LD_INT 4
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 30
40180: PUSH
40181: LD_INT 5
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: LIST
40192: PPUSH
40193: CALL_OW 72
40197: ST_TO_ADDR
// if barracks then
40198: LD_VAR 0 8
40202: IFFALSE 40350
// begin selected := 0 ;
40204: LD_ADDR_VAR 0 7
40208: PUSH
40209: LD_INT 0
40211: ST_TO_ADDR
// for j in barracks do
40212: LD_ADDR_VAR 0 3
40216: PUSH
40217: LD_VAR 0 8
40221: PUSH
40222: FOR_IN
40223: IFFALSE 40254
// begin if UnitsInside ( j ) < 6 then
40225: LD_VAR 0 3
40229: PPUSH
40230: CALL_OW 313
40234: PUSH
40235: LD_INT 6
40237: LESS
40238: IFFALSE 40252
// begin selected := j ;
40240: LD_ADDR_VAR 0 7
40244: PUSH
40245: LD_VAR 0 3
40249: ST_TO_ADDR
// break ;
40250: GO 40254
// end ; end ;
40252: GO 40222
40254: POP
40255: POP
// if selected then
40256: LD_VAR 0 7
40260: IFFALSE 40350
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40262: LD_ADDR_VAR 0 3
40266: PUSH
40267: LD_EXP 118
40271: PUSH
40272: LD_VAR 0 2
40276: ARRAY
40277: PPUSH
40278: LD_INT 25
40280: PUSH
40281: LD_INT 12
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PPUSH
40288: CALL_OW 72
40292: PUSH
40293: FOR_IN
40294: IFFALSE 40348
// if not IsInUnit ( j ) and not HasTask ( j ) then
40296: LD_VAR 0 3
40300: PPUSH
40301: CALL_OW 310
40305: NOT
40306: PUSH
40307: LD_VAR 0 3
40311: PPUSH
40312: CALL_OW 314
40316: NOT
40317: AND
40318: IFFALSE 40346
// begin ComEnterUnit ( j , selected ) ;
40320: LD_VAR 0 3
40324: PPUSH
40325: LD_VAR 0 7
40329: PPUSH
40330: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40334: LD_VAR 0 3
40338: PPUSH
40339: LD_INT 15
40341: PPUSH
40342: CALL_OW 183
// end ;
40346: GO 40293
40348: POP
40349: POP
// end ; end ; end ; end ; end ;
40350: GO 39743
40352: POP
40353: POP
// end ;
40354: LD_VAR 0 1
40358: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40359: LD_INT 0
40361: PPUSH
40362: PPUSH
40363: PPUSH
40364: PPUSH
// if not mc_bases then
40365: LD_EXP 89
40369: NOT
40370: IFFALSE 40374
// exit ;
40372: GO 40552
// for i = 1 to mc_bases do
40374: LD_ADDR_VAR 0 2
40378: PUSH
40379: DOUBLE
40380: LD_INT 1
40382: DEC
40383: ST_TO_ADDR
40384: LD_EXP 89
40388: PUSH
40389: FOR_TO
40390: IFFALSE 40550
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40392: LD_ADDR_VAR 0 4
40396: PUSH
40397: LD_EXP 89
40401: PUSH
40402: LD_VAR 0 2
40406: ARRAY
40407: PPUSH
40408: LD_INT 25
40410: PUSH
40411: LD_INT 9
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PPUSH
40418: CALL_OW 72
40422: ST_TO_ADDR
// if not tmp then
40423: LD_VAR 0 4
40427: NOT
40428: IFFALSE 40432
// continue ;
40430: GO 40389
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40432: LD_EXP 115
40436: PUSH
40437: LD_VAR 0 2
40441: ARRAY
40442: PPUSH
40443: LD_INT 29
40445: PPUSH
40446: CALL_OW 325
40450: NOT
40451: PUSH
40452: LD_EXP 115
40456: PUSH
40457: LD_VAR 0 2
40461: ARRAY
40462: PPUSH
40463: LD_INT 28
40465: PPUSH
40466: CALL_OW 325
40470: NOT
40471: AND
40472: IFFALSE 40476
// continue ;
40474: GO 40389
// for j in tmp do
40476: LD_ADDR_VAR 0 3
40480: PUSH
40481: LD_VAR 0 4
40485: PUSH
40486: FOR_IN
40487: IFFALSE 40546
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40489: LD_VAR 0 3
40493: PUSH
40494: LD_EXP 92
40498: PUSH
40499: LD_VAR 0 2
40503: ARRAY
40504: PUSH
40505: LD_INT 1
40507: ARRAY
40508: IN
40509: NOT
40510: PUSH
40511: LD_VAR 0 3
40515: PUSH
40516: LD_EXP 92
40520: PUSH
40521: LD_VAR 0 2
40525: ARRAY
40526: PUSH
40527: LD_INT 2
40529: ARRAY
40530: IN
40531: NOT
40532: AND
40533: IFFALSE 40544
// ComSpaceTimeShoot ( j ) ;
40535: LD_VAR 0 3
40539: PPUSH
40540: CALL 51690 0 1
40544: GO 40486
40546: POP
40547: POP
// end ;
40548: GO 40389
40550: POP
40551: POP
// end ;
40552: LD_VAR 0 1
40556: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40557: LD_INT 0
40559: PPUSH
40560: PPUSH
40561: PPUSH
40562: PPUSH
40563: PPUSH
40564: PPUSH
40565: PPUSH
40566: PPUSH
40567: PPUSH
// if not mc_bases then
40568: LD_EXP 89
40572: NOT
40573: IFFALSE 40577
// exit ;
40575: GO 41199
// for i = 1 to mc_bases do
40577: LD_ADDR_VAR 0 2
40581: PUSH
40582: DOUBLE
40583: LD_INT 1
40585: DEC
40586: ST_TO_ADDR
40587: LD_EXP 89
40591: PUSH
40592: FOR_TO
40593: IFFALSE 41197
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40595: LD_EXP 124
40599: PUSH
40600: LD_VAR 0 2
40604: ARRAY
40605: NOT
40606: PUSH
40607: LD_INT 38
40609: PPUSH
40610: LD_EXP 115
40614: PUSH
40615: LD_VAR 0 2
40619: ARRAY
40620: PPUSH
40621: CALL_OW 321
40625: PUSH
40626: LD_INT 2
40628: NONEQUAL
40629: OR
40630: IFFALSE 40634
// continue ;
40632: GO 40592
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40634: LD_ADDR_VAR 0 8
40638: PUSH
40639: LD_EXP 89
40643: PUSH
40644: LD_VAR 0 2
40648: ARRAY
40649: PPUSH
40650: LD_INT 30
40652: PUSH
40653: LD_INT 34
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PPUSH
40660: CALL_OW 72
40664: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40665: LD_ADDR_VAR 0 9
40669: PUSH
40670: LD_EXP 89
40674: PUSH
40675: LD_VAR 0 2
40679: ARRAY
40680: PPUSH
40681: LD_INT 25
40683: PUSH
40684: LD_INT 4
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PPUSH
40691: CALL_OW 72
40695: PPUSH
40696: LD_INT 0
40698: PPUSH
40699: CALL 84254 0 2
40703: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40704: LD_VAR 0 9
40708: NOT
40709: PUSH
40710: LD_VAR 0 8
40714: NOT
40715: OR
40716: PUSH
40717: LD_EXP 89
40721: PUSH
40722: LD_VAR 0 2
40726: ARRAY
40727: PPUSH
40728: LD_INT 124
40730: PPUSH
40731: CALL 84254 0 2
40735: OR
40736: IFFALSE 40740
// continue ;
40738: GO 40592
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40740: LD_EXP 125
40744: PUSH
40745: LD_VAR 0 2
40749: ARRAY
40750: PUSH
40751: LD_EXP 124
40755: PUSH
40756: LD_VAR 0 2
40760: ARRAY
40761: LESS
40762: PUSH
40763: LD_EXP 125
40767: PUSH
40768: LD_VAR 0 2
40772: ARRAY
40773: PUSH
40774: LD_VAR 0 8
40778: LESS
40779: AND
40780: IFFALSE 41195
// begin tmp := sci [ 1 ] ;
40782: LD_ADDR_VAR 0 7
40786: PUSH
40787: LD_VAR 0 9
40791: PUSH
40792: LD_INT 1
40794: ARRAY
40795: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40796: LD_VAR 0 7
40800: PPUSH
40801: LD_INT 124
40803: PPUSH
40804: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40808: LD_ADDR_VAR 0 3
40812: PUSH
40813: DOUBLE
40814: LD_EXP 124
40818: PUSH
40819: LD_VAR 0 2
40823: ARRAY
40824: INC
40825: ST_TO_ADDR
40826: LD_EXP 124
40830: PUSH
40831: LD_VAR 0 2
40835: ARRAY
40836: PUSH
40837: FOR_DOWNTO
40838: IFFALSE 41181
// begin if IsInUnit ( tmp ) then
40840: LD_VAR 0 7
40844: PPUSH
40845: CALL_OW 310
40849: IFFALSE 40860
// ComExitBuilding ( tmp ) ;
40851: LD_VAR 0 7
40855: PPUSH
40856: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40860: LD_INT 35
40862: PPUSH
40863: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40867: LD_VAR 0 7
40871: PPUSH
40872: CALL_OW 310
40876: NOT
40877: PUSH
40878: LD_VAR 0 7
40882: PPUSH
40883: CALL_OW 314
40887: NOT
40888: AND
40889: IFFALSE 40860
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40891: LD_ADDR_VAR 0 6
40895: PUSH
40896: LD_VAR 0 7
40900: PPUSH
40901: CALL_OW 250
40905: PUSH
40906: LD_VAR 0 7
40910: PPUSH
40911: CALL_OW 251
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40920: LD_INT 35
40922: PPUSH
40923: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40927: LD_ADDR_VAR 0 4
40931: PUSH
40932: LD_EXP 124
40936: PUSH
40937: LD_VAR 0 2
40941: ARRAY
40942: PUSH
40943: LD_VAR 0 3
40947: ARRAY
40948: PUSH
40949: LD_INT 1
40951: ARRAY
40952: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40953: LD_ADDR_VAR 0 5
40957: PUSH
40958: LD_EXP 124
40962: PUSH
40963: LD_VAR 0 2
40967: ARRAY
40968: PUSH
40969: LD_VAR 0 3
40973: ARRAY
40974: PUSH
40975: LD_INT 2
40977: ARRAY
40978: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40979: LD_VAR 0 7
40983: PPUSH
40984: LD_INT 10
40986: PPUSH
40987: CALL 58286 0 2
40991: PUSH
40992: LD_INT 4
40994: ARRAY
40995: IFFALSE 41033
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40997: LD_VAR 0 7
41001: PPUSH
41002: LD_VAR 0 6
41006: PUSH
41007: LD_INT 1
41009: ARRAY
41010: PPUSH
41011: LD_VAR 0 6
41015: PUSH
41016: LD_INT 2
41018: ARRAY
41019: PPUSH
41020: CALL_OW 111
// wait ( 0 0$10 ) ;
41024: LD_INT 350
41026: PPUSH
41027: CALL_OW 67
// end else
41031: GO 41059
// begin ComMoveXY ( tmp , x , y ) ;
41033: LD_VAR 0 7
41037: PPUSH
41038: LD_VAR 0 4
41042: PPUSH
41043: LD_VAR 0 5
41047: PPUSH
41048: CALL_OW 111
// wait ( 0 0$3 ) ;
41052: LD_INT 105
41054: PPUSH
41055: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41059: LD_VAR 0 7
41063: PPUSH
41064: LD_VAR 0 4
41068: PPUSH
41069: LD_VAR 0 5
41073: PPUSH
41074: CALL_OW 307
41078: IFFALSE 40920
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41080: LD_VAR 0 7
41084: PPUSH
41085: LD_VAR 0 4
41089: PPUSH
41090: LD_VAR 0 5
41094: PPUSH
41095: LD_VAR 0 8
41099: PUSH
41100: LD_VAR 0 3
41104: ARRAY
41105: PPUSH
41106: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41110: LD_INT 35
41112: PPUSH
41113: CALL_OW 67
// until not HasTask ( tmp ) ;
41117: LD_VAR 0 7
41121: PPUSH
41122: CALL_OW 314
41126: NOT
41127: IFFALSE 41110
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41129: LD_ADDR_EXP 125
41133: PUSH
41134: LD_EXP 125
41138: PPUSH
41139: LD_VAR 0 2
41143: PUSH
41144: LD_EXP 125
41148: PUSH
41149: LD_VAR 0 2
41153: ARRAY
41154: PUSH
41155: LD_INT 1
41157: PLUS
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PPUSH
41163: LD_VAR 0 8
41167: PUSH
41168: LD_VAR 0 3
41172: ARRAY
41173: PPUSH
41174: CALL 55693 0 3
41178: ST_TO_ADDR
// end ;
41179: GO 40837
41181: POP
41182: POP
// MC_Reset ( i , 124 ) ;
41183: LD_VAR 0 2
41187: PPUSH
41188: LD_INT 124
41190: PPUSH
41191: CALL 24802 0 2
// end ; end ;
41195: GO 40592
41197: POP
41198: POP
// end ;
41199: LD_VAR 0 1
41203: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41204: LD_INT 0
41206: PPUSH
41207: PPUSH
41208: PPUSH
// if not mc_bases then
41209: LD_EXP 89
41213: NOT
41214: IFFALSE 41218
// exit ;
41216: GO 41824
// for i = 1 to mc_bases do
41218: LD_ADDR_VAR 0 2
41222: PUSH
41223: DOUBLE
41224: LD_INT 1
41226: DEC
41227: ST_TO_ADDR
41228: LD_EXP 89
41232: PUSH
41233: FOR_TO
41234: IFFALSE 41822
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41236: LD_ADDR_VAR 0 3
41240: PUSH
41241: LD_EXP 89
41245: PUSH
41246: LD_VAR 0 2
41250: ARRAY
41251: PPUSH
41252: LD_INT 25
41254: PUSH
41255: LD_INT 4
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PPUSH
41262: CALL_OW 72
41266: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41267: LD_VAR 0 3
41271: NOT
41272: PUSH
41273: LD_EXP 126
41277: PUSH
41278: LD_VAR 0 2
41282: ARRAY
41283: NOT
41284: OR
41285: PUSH
41286: LD_EXP 89
41290: PUSH
41291: LD_VAR 0 2
41295: ARRAY
41296: PPUSH
41297: LD_INT 2
41299: PUSH
41300: LD_INT 30
41302: PUSH
41303: LD_INT 0
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 30
41312: PUSH
41313: LD_INT 1
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: LIST
41324: PPUSH
41325: CALL_OW 72
41329: NOT
41330: OR
41331: IFFALSE 41381
// begin if mc_deposits_finder [ i ] then
41333: LD_EXP 127
41337: PUSH
41338: LD_VAR 0 2
41342: ARRAY
41343: IFFALSE 41379
// begin MC_Reset ( i , 125 ) ;
41345: LD_VAR 0 2
41349: PPUSH
41350: LD_INT 125
41352: PPUSH
41353: CALL 24802 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41357: LD_ADDR_EXP 127
41361: PUSH
41362: LD_EXP 127
41366: PPUSH
41367: LD_VAR 0 2
41371: PPUSH
41372: EMPTY
41373: PPUSH
41374: CALL_OW 1
41378: ST_TO_ADDR
// end ; continue ;
41379: GO 41233
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41381: LD_EXP 126
41385: PUSH
41386: LD_VAR 0 2
41390: ARRAY
41391: PUSH
41392: LD_INT 1
41394: ARRAY
41395: PUSH
41396: LD_INT 3
41398: ARRAY
41399: PUSH
41400: LD_INT 1
41402: EQUAL
41403: PUSH
41404: LD_INT 20
41406: PPUSH
41407: LD_EXP 115
41411: PUSH
41412: LD_VAR 0 2
41416: ARRAY
41417: PPUSH
41418: CALL_OW 321
41422: PUSH
41423: LD_INT 2
41425: NONEQUAL
41426: AND
41427: IFFALSE 41477
// begin if mc_deposits_finder [ i ] then
41429: LD_EXP 127
41433: PUSH
41434: LD_VAR 0 2
41438: ARRAY
41439: IFFALSE 41475
// begin MC_Reset ( i , 125 ) ;
41441: LD_VAR 0 2
41445: PPUSH
41446: LD_INT 125
41448: PPUSH
41449: CALL 24802 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41453: LD_ADDR_EXP 127
41457: PUSH
41458: LD_EXP 127
41462: PPUSH
41463: LD_VAR 0 2
41467: PPUSH
41468: EMPTY
41469: PPUSH
41470: CALL_OW 1
41474: ST_TO_ADDR
// end ; continue ;
41475: GO 41233
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41477: LD_EXP 126
41481: PUSH
41482: LD_VAR 0 2
41486: ARRAY
41487: PUSH
41488: LD_INT 1
41490: ARRAY
41491: PUSH
41492: LD_INT 1
41494: ARRAY
41495: PPUSH
41496: LD_EXP 126
41500: PUSH
41501: LD_VAR 0 2
41505: ARRAY
41506: PUSH
41507: LD_INT 1
41509: ARRAY
41510: PUSH
41511: LD_INT 2
41513: ARRAY
41514: PPUSH
41515: LD_EXP 115
41519: PUSH
41520: LD_VAR 0 2
41524: ARRAY
41525: PPUSH
41526: CALL_OW 440
41530: IFFALSE 41573
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41532: LD_ADDR_EXP 126
41536: PUSH
41537: LD_EXP 126
41541: PPUSH
41542: LD_VAR 0 2
41546: PPUSH
41547: LD_EXP 126
41551: PUSH
41552: LD_VAR 0 2
41556: ARRAY
41557: PPUSH
41558: LD_INT 1
41560: PPUSH
41561: CALL_OW 3
41565: PPUSH
41566: CALL_OW 1
41570: ST_TO_ADDR
41571: GO 41820
// begin if not mc_deposits_finder [ i ] then
41573: LD_EXP 127
41577: PUSH
41578: LD_VAR 0 2
41582: ARRAY
41583: NOT
41584: IFFALSE 41636
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41586: LD_ADDR_EXP 127
41590: PUSH
41591: LD_EXP 127
41595: PPUSH
41596: LD_VAR 0 2
41600: PPUSH
41601: LD_VAR 0 3
41605: PUSH
41606: LD_INT 1
41608: ARRAY
41609: PUSH
41610: EMPTY
41611: LIST
41612: PPUSH
41613: CALL_OW 1
41617: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41618: LD_VAR 0 3
41622: PUSH
41623: LD_INT 1
41625: ARRAY
41626: PPUSH
41627: LD_INT 125
41629: PPUSH
41630: CALL_OW 109
// end else
41634: GO 41820
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41636: LD_EXP 127
41640: PUSH
41641: LD_VAR 0 2
41645: ARRAY
41646: PUSH
41647: LD_INT 1
41649: ARRAY
41650: PPUSH
41651: CALL_OW 310
41655: IFFALSE 41678
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41657: LD_EXP 127
41661: PUSH
41662: LD_VAR 0 2
41666: ARRAY
41667: PUSH
41668: LD_INT 1
41670: ARRAY
41671: PPUSH
41672: CALL_OW 122
41676: GO 41820
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41678: LD_EXP 127
41682: PUSH
41683: LD_VAR 0 2
41687: ARRAY
41688: PUSH
41689: LD_INT 1
41691: ARRAY
41692: PPUSH
41693: CALL_OW 314
41697: NOT
41698: PUSH
41699: LD_EXP 127
41703: PUSH
41704: LD_VAR 0 2
41708: ARRAY
41709: PUSH
41710: LD_INT 1
41712: ARRAY
41713: PPUSH
41714: LD_EXP 126
41718: PUSH
41719: LD_VAR 0 2
41723: ARRAY
41724: PUSH
41725: LD_INT 1
41727: ARRAY
41728: PUSH
41729: LD_INT 1
41731: ARRAY
41732: PPUSH
41733: LD_EXP 126
41737: PUSH
41738: LD_VAR 0 2
41742: ARRAY
41743: PUSH
41744: LD_INT 1
41746: ARRAY
41747: PUSH
41748: LD_INT 2
41750: ARRAY
41751: PPUSH
41752: CALL_OW 297
41756: PUSH
41757: LD_INT 6
41759: GREATER
41760: AND
41761: IFFALSE 41820
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41763: LD_EXP 127
41767: PUSH
41768: LD_VAR 0 2
41772: ARRAY
41773: PUSH
41774: LD_INT 1
41776: ARRAY
41777: PPUSH
41778: LD_EXP 126
41782: PUSH
41783: LD_VAR 0 2
41787: ARRAY
41788: PUSH
41789: LD_INT 1
41791: ARRAY
41792: PUSH
41793: LD_INT 1
41795: ARRAY
41796: PPUSH
41797: LD_EXP 126
41801: PUSH
41802: LD_VAR 0 2
41806: ARRAY
41807: PUSH
41808: LD_INT 1
41810: ARRAY
41811: PUSH
41812: LD_INT 2
41814: ARRAY
41815: PPUSH
41816: CALL_OW 111
// end ; end ; end ;
41820: GO 41233
41822: POP
41823: POP
// end ;
41824: LD_VAR 0 1
41828: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41829: LD_INT 0
41831: PPUSH
41832: PPUSH
41833: PPUSH
41834: PPUSH
41835: PPUSH
41836: PPUSH
41837: PPUSH
41838: PPUSH
41839: PPUSH
41840: PPUSH
41841: PPUSH
// if not mc_bases then
41842: LD_EXP 89
41846: NOT
41847: IFFALSE 41851
// exit ;
41849: GO 42791
// for i = 1 to mc_bases do
41851: LD_ADDR_VAR 0 2
41855: PUSH
41856: DOUBLE
41857: LD_INT 1
41859: DEC
41860: ST_TO_ADDR
41861: LD_EXP 89
41865: PUSH
41866: FOR_TO
41867: IFFALSE 42789
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41869: LD_EXP 89
41873: PUSH
41874: LD_VAR 0 2
41878: ARRAY
41879: NOT
41880: PUSH
41881: LD_EXP 112
41885: PUSH
41886: LD_VAR 0 2
41890: ARRAY
41891: OR
41892: IFFALSE 41896
// continue ;
41894: GO 41866
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41896: LD_ADDR_VAR 0 7
41900: PUSH
41901: LD_EXP 89
41905: PUSH
41906: LD_VAR 0 2
41910: ARRAY
41911: PUSH
41912: LD_INT 1
41914: ARRAY
41915: PPUSH
41916: CALL_OW 248
41920: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41921: LD_VAR 0 7
41925: PUSH
41926: LD_INT 3
41928: EQUAL
41929: PUSH
41930: LD_EXP 108
41934: PUSH
41935: LD_VAR 0 2
41939: ARRAY
41940: PUSH
41941: LD_EXP 111
41945: PUSH
41946: LD_VAR 0 2
41950: ARRAY
41951: UNION
41952: PPUSH
41953: LD_INT 33
41955: PUSH
41956: LD_INT 2
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PPUSH
41963: CALL_OW 72
41967: NOT
41968: OR
41969: IFFALSE 41973
// continue ;
41971: GO 41866
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41973: LD_ADDR_VAR 0 9
41977: PUSH
41978: LD_EXP 89
41982: PUSH
41983: LD_VAR 0 2
41987: ARRAY
41988: PPUSH
41989: LD_INT 30
41991: PUSH
41992: LD_INT 36
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PPUSH
41999: CALL_OW 72
42003: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42004: LD_ADDR_VAR 0 10
42008: PUSH
42009: LD_EXP 108
42013: PUSH
42014: LD_VAR 0 2
42018: ARRAY
42019: PPUSH
42020: LD_INT 34
42022: PUSH
42023: LD_INT 31
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PPUSH
42030: CALL_OW 72
42034: ST_TO_ADDR
// if not cts and not mcts then
42035: LD_VAR 0 9
42039: NOT
42040: PUSH
42041: LD_VAR 0 10
42045: NOT
42046: AND
42047: IFFALSE 42051
// continue ;
42049: GO 41866
// x := cts ;
42051: LD_ADDR_VAR 0 11
42055: PUSH
42056: LD_VAR 0 9
42060: ST_TO_ADDR
// if not x then
42061: LD_VAR 0 11
42065: NOT
42066: IFFALSE 42078
// x := mcts ;
42068: LD_ADDR_VAR 0 11
42072: PUSH
42073: LD_VAR 0 10
42077: ST_TO_ADDR
// if not x then
42078: LD_VAR 0 11
42082: NOT
42083: IFFALSE 42087
// continue ;
42085: GO 41866
// if mc_remote_driver [ i ] then
42087: LD_EXP 129
42091: PUSH
42092: LD_VAR 0 2
42096: ARRAY
42097: IFFALSE 42484
// for j in mc_remote_driver [ i ] do
42099: LD_ADDR_VAR 0 3
42103: PUSH
42104: LD_EXP 129
42108: PUSH
42109: LD_VAR 0 2
42113: ARRAY
42114: PUSH
42115: FOR_IN
42116: IFFALSE 42482
// begin if GetClass ( j ) <> 3 then
42118: LD_VAR 0 3
42122: PPUSH
42123: CALL_OW 257
42127: PUSH
42128: LD_INT 3
42130: NONEQUAL
42131: IFFALSE 42184
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42133: LD_ADDR_EXP 129
42137: PUSH
42138: LD_EXP 129
42142: PPUSH
42143: LD_VAR 0 2
42147: PPUSH
42148: LD_EXP 129
42152: PUSH
42153: LD_VAR 0 2
42157: ARRAY
42158: PUSH
42159: LD_VAR 0 3
42163: DIFF
42164: PPUSH
42165: CALL_OW 1
42169: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42170: LD_VAR 0 3
42174: PPUSH
42175: LD_INT 0
42177: PPUSH
42178: CALL_OW 109
// continue ;
42182: GO 42115
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42184: LD_EXP 108
42188: PUSH
42189: LD_VAR 0 2
42193: ARRAY
42194: PPUSH
42195: LD_INT 34
42197: PUSH
42198: LD_INT 31
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 58
42207: PUSH
42208: EMPTY
42209: LIST
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PPUSH
42215: CALL_OW 72
42219: PUSH
42220: LD_VAR 0 3
42224: PPUSH
42225: CALL 84342 0 1
42229: NOT
42230: AND
42231: IFFALSE 42302
// begin if IsInUnit ( j ) then
42233: LD_VAR 0 3
42237: PPUSH
42238: CALL_OW 310
42242: IFFALSE 42253
// ComExitBuilding ( j ) ;
42244: LD_VAR 0 3
42248: PPUSH
42249: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42253: LD_VAR 0 3
42257: PPUSH
42258: LD_EXP 108
42262: PUSH
42263: LD_VAR 0 2
42267: ARRAY
42268: PPUSH
42269: LD_INT 34
42271: PUSH
42272: LD_INT 31
42274: PUSH
42275: EMPTY
42276: LIST
42277: LIST
42278: PUSH
42279: LD_INT 58
42281: PUSH
42282: EMPTY
42283: LIST
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PPUSH
42289: CALL_OW 72
42293: PUSH
42294: LD_INT 1
42296: ARRAY
42297: PPUSH
42298: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42302: LD_VAR 0 3
42306: PPUSH
42307: CALL_OW 310
42311: NOT
42312: PUSH
42313: LD_VAR 0 3
42317: PPUSH
42318: CALL_OW 310
42322: PPUSH
42323: CALL_OW 266
42327: PUSH
42328: LD_INT 36
42330: NONEQUAL
42331: PUSH
42332: LD_VAR 0 3
42336: PPUSH
42337: CALL 84342 0 1
42341: NOT
42342: AND
42343: OR
42344: IFFALSE 42480
// begin if IsInUnit ( j ) then
42346: LD_VAR 0 3
42350: PPUSH
42351: CALL_OW 310
42355: IFFALSE 42366
// ComExitBuilding ( j ) ;
42357: LD_VAR 0 3
42361: PPUSH
42362: CALL_OW 122
// ct := 0 ;
42366: LD_ADDR_VAR 0 8
42370: PUSH
42371: LD_INT 0
42373: ST_TO_ADDR
// for k in x do
42374: LD_ADDR_VAR 0 4
42378: PUSH
42379: LD_VAR 0 11
42383: PUSH
42384: FOR_IN
42385: IFFALSE 42458
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42387: LD_VAR 0 4
42391: PPUSH
42392: CALL_OW 264
42396: PUSH
42397: LD_INT 31
42399: EQUAL
42400: PUSH
42401: LD_VAR 0 4
42405: PPUSH
42406: CALL_OW 311
42410: NOT
42411: AND
42412: PUSH
42413: LD_VAR 0 4
42417: PPUSH
42418: CALL_OW 266
42422: PUSH
42423: LD_INT 36
42425: EQUAL
42426: PUSH
42427: LD_VAR 0 4
42431: PPUSH
42432: CALL_OW 313
42436: PUSH
42437: LD_INT 3
42439: LESS
42440: AND
42441: OR
42442: IFFALSE 42456
// begin ct := k ;
42444: LD_ADDR_VAR 0 8
42448: PUSH
42449: LD_VAR 0 4
42453: ST_TO_ADDR
// break ;
42454: GO 42458
// end ;
42456: GO 42384
42458: POP
42459: POP
// if ct then
42460: LD_VAR 0 8
42464: IFFALSE 42480
// ComEnterUnit ( j , ct ) ;
42466: LD_VAR 0 3
42470: PPUSH
42471: LD_VAR 0 8
42475: PPUSH
42476: CALL_OW 120
// end ; end ;
42480: GO 42115
42482: POP
42483: POP
// places := 0 ;
42484: LD_ADDR_VAR 0 5
42488: PUSH
42489: LD_INT 0
42491: ST_TO_ADDR
// for j = 1 to x do
42492: LD_ADDR_VAR 0 3
42496: PUSH
42497: DOUBLE
42498: LD_INT 1
42500: DEC
42501: ST_TO_ADDR
42502: LD_VAR 0 11
42506: PUSH
42507: FOR_TO
42508: IFFALSE 42584
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42510: LD_VAR 0 11
42514: PUSH
42515: LD_VAR 0 3
42519: ARRAY
42520: PPUSH
42521: CALL_OW 264
42525: PUSH
42526: LD_INT 31
42528: EQUAL
42529: IFFALSE 42547
// places := places + 1 else
42531: LD_ADDR_VAR 0 5
42535: PUSH
42536: LD_VAR 0 5
42540: PUSH
42541: LD_INT 1
42543: PLUS
42544: ST_TO_ADDR
42545: GO 42582
// if GetBType ( x [ j ] ) = b_control_tower then
42547: LD_VAR 0 11
42551: PUSH
42552: LD_VAR 0 3
42556: ARRAY
42557: PPUSH
42558: CALL_OW 266
42562: PUSH
42563: LD_INT 36
42565: EQUAL
42566: IFFALSE 42582
// places := places + 3 ;
42568: LD_ADDR_VAR 0 5
42572: PUSH
42573: LD_VAR 0 5
42577: PUSH
42578: LD_INT 3
42580: PLUS
42581: ST_TO_ADDR
42582: GO 42507
42584: POP
42585: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42586: LD_VAR 0 5
42590: PUSH
42591: LD_INT 0
42593: EQUAL
42594: PUSH
42595: LD_VAR 0 5
42599: PUSH
42600: LD_EXP 129
42604: PUSH
42605: LD_VAR 0 2
42609: ARRAY
42610: LESSEQUAL
42611: OR
42612: IFFALSE 42616
// continue ;
42614: GO 41866
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42616: LD_ADDR_VAR 0 6
42620: PUSH
42621: LD_EXP 89
42625: PUSH
42626: LD_VAR 0 2
42630: ARRAY
42631: PPUSH
42632: LD_INT 25
42634: PUSH
42635: LD_INT 3
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PPUSH
42642: CALL_OW 72
42646: PUSH
42647: LD_EXP 129
42651: PUSH
42652: LD_VAR 0 2
42656: ARRAY
42657: DIFF
42658: PPUSH
42659: LD_INT 3
42661: PPUSH
42662: CALL 85242 0 2
42666: ST_TO_ADDR
// for j in tmp do
42667: LD_ADDR_VAR 0 3
42671: PUSH
42672: LD_VAR 0 6
42676: PUSH
42677: FOR_IN
42678: IFFALSE 42713
// if GetTag ( j ) > 0 then
42680: LD_VAR 0 3
42684: PPUSH
42685: CALL_OW 110
42689: PUSH
42690: LD_INT 0
42692: GREATER
42693: IFFALSE 42711
// tmp := tmp diff j ;
42695: LD_ADDR_VAR 0 6
42699: PUSH
42700: LD_VAR 0 6
42704: PUSH
42705: LD_VAR 0 3
42709: DIFF
42710: ST_TO_ADDR
42711: GO 42677
42713: POP
42714: POP
// if not tmp then
42715: LD_VAR 0 6
42719: NOT
42720: IFFALSE 42724
// continue ;
42722: GO 41866
// if places then
42724: LD_VAR 0 5
42728: IFFALSE 42787
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42730: LD_ADDR_EXP 129
42734: PUSH
42735: LD_EXP 129
42739: PPUSH
42740: LD_VAR 0 2
42744: PPUSH
42745: LD_EXP 129
42749: PUSH
42750: LD_VAR 0 2
42754: ARRAY
42755: PUSH
42756: LD_VAR 0 6
42760: PUSH
42761: LD_INT 1
42763: ARRAY
42764: UNION
42765: PPUSH
42766: CALL_OW 1
42770: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42771: LD_VAR 0 6
42775: PUSH
42776: LD_INT 1
42778: ARRAY
42779: PPUSH
42780: LD_INT 126
42782: PPUSH
42783: CALL_OW 109
// end ; end ;
42787: GO 41866
42789: POP
42790: POP
// end ;
42791: LD_VAR 0 1
42795: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42796: LD_INT 0
42798: PPUSH
42799: PPUSH
42800: PPUSH
42801: PPUSH
42802: PPUSH
42803: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42804: LD_VAR 0 1
42808: NOT
42809: PUSH
42810: LD_VAR 0 2
42814: NOT
42815: OR
42816: PUSH
42817: LD_VAR 0 3
42821: NOT
42822: OR
42823: PUSH
42824: LD_VAR 0 4
42828: PUSH
42829: LD_INT 1
42831: PUSH
42832: LD_INT 2
42834: PUSH
42835: LD_INT 3
42837: PUSH
42838: LD_INT 4
42840: PUSH
42841: LD_INT 5
42843: PUSH
42844: LD_INT 8
42846: PUSH
42847: LD_INT 9
42849: PUSH
42850: LD_INT 15
42852: PUSH
42853: LD_INT 16
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: LIST
42860: LIST
42861: LIST
42862: LIST
42863: LIST
42864: LIST
42865: LIST
42866: IN
42867: NOT
42868: OR
42869: IFFALSE 42873
// exit ;
42871: GO 43773
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42873: LD_ADDR_VAR 0 2
42877: PUSH
42878: LD_VAR 0 2
42882: PPUSH
42883: LD_INT 21
42885: PUSH
42886: LD_INT 3
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: PUSH
42893: LD_INT 24
42895: PUSH
42896: LD_INT 250
42898: PUSH
42899: EMPTY
42900: LIST
42901: LIST
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PPUSH
42907: CALL_OW 72
42911: ST_TO_ADDR
// case class of 1 , 15 :
42912: LD_VAR 0 4
42916: PUSH
42917: LD_INT 1
42919: DOUBLE
42920: EQUAL
42921: IFTRUE 42931
42923: LD_INT 15
42925: DOUBLE
42926: EQUAL
42927: IFTRUE 42931
42929: GO 43016
42931: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42932: LD_ADDR_VAR 0 8
42936: PUSH
42937: LD_VAR 0 2
42941: PPUSH
42942: LD_INT 2
42944: PUSH
42945: LD_INT 30
42947: PUSH
42948: LD_INT 32
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 30
42957: PUSH
42958: LD_INT 31
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: LIST
42969: PPUSH
42970: CALL_OW 72
42974: PUSH
42975: LD_VAR 0 2
42979: PPUSH
42980: LD_INT 2
42982: PUSH
42983: LD_INT 30
42985: PUSH
42986: LD_INT 4
42988: PUSH
42989: EMPTY
42990: LIST
42991: LIST
42992: PUSH
42993: LD_INT 30
42995: PUSH
42996: LD_INT 5
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: LIST
43007: PPUSH
43008: CALL_OW 72
43012: ADD
43013: ST_TO_ADDR
43014: GO 43262
43016: LD_INT 2
43018: DOUBLE
43019: EQUAL
43020: IFTRUE 43030
43022: LD_INT 16
43024: DOUBLE
43025: EQUAL
43026: IFTRUE 43030
43028: GO 43076
43030: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43031: LD_ADDR_VAR 0 8
43035: PUSH
43036: LD_VAR 0 2
43040: PPUSH
43041: LD_INT 2
43043: PUSH
43044: LD_INT 30
43046: PUSH
43047: LD_INT 0
43049: PUSH
43050: EMPTY
43051: LIST
43052: LIST
43053: PUSH
43054: LD_INT 30
43056: PUSH
43057: LD_INT 1
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: LIST
43068: PPUSH
43069: CALL_OW 72
43073: ST_TO_ADDR
43074: GO 43262
43076: LD_INT 3
43078: DOUBLE
43079: EQUAL
43080: IFTRUE 43084
43082: GO 43130
43084: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43085: LD_ADDR_VAR 0 8
43089: PUSH
43090: LD_VAR 0 2
43094: PPUSH
43095: LD_INT 2
43097: PUSH
43098: LD_INT 30
43100: PUSH
43101: LD_INT 2
43103: PUSH
43104: EMPTY
43105: LIST
43106: LIST
43107: PUSH
43108: LD_INT 30
43110: PUSH
43111: LD_INT 3
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: PUSH
43118: EMPTY
43119: LIST
43120: LIST
43121: LIST
43122: PPUSH
43123: CALL_OW 72
43127: ST_TO_ADDR
43128: GO 43262
43130: LD_INT 4
43132: DOUBLE
43133: EQUAL
43134: IFTRUE 43138
43136: GO 43195
43138: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43139: LD_ADDR_VAR 0 8
43143: PUSH
43144: LD_VAR 0 2
43148: PPUSH
43149: LD_INT 2
43151: PUSH
43152: LD_INT 30
43154: PUSH
43155: LD_INT 6
43157: PUSH
43158: EMPTY
43159: LIST
43160: LIST
43161: PUSH
43162: LD_INT 30
43164: PUSH
43165: LD_INT 7
43167: PUSH
43168: EMPTY
43169: LIST
43170: LIST
43171: PUSH
43172: LD_INT 30
43174: PUSH
43175: LD_INT 8
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: PUSH
43182: EMPTY
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: PPUSH
43188: CALL_OW 72
43192: ST_TO_ADDR
43193: GO 43262
43195: LD_INT 5
43197: DOUBLE
43198: EQUAL
43199: IFTRUE 43215
43201: LD_INT 8
43203: DOUBLE
43204: EQUAL
43205: IFTRUE 43215
43207: LD_INT 9
43209: DOUBLE
43210: EQUAL
43211: IFTRUE 43215
43213: GO 43261
43215: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43216: LD_ADDR_VAR 0 8
43220: PUSH
43221: LD_VAR 0 2
43225: PPUSH
43226: LD_INT 2
43228: PUSH
43229: LD_INT 30
43231: PUSH
43232: LD_INT 4
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 30
43241: PUSH
43242: LD_INT 5
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: LIST
43253: PPUSH
43254: CALL_OW 72
43258: ST_TO_ADDR
43259: GO 43262
43261: POP
// if not tmp then
43262: LD_VAR 0 8
43266: NOT
43267: IFFALSE 43271
// exit ;
43269: GO 43773
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43271: LD_VAR 0 4
43275: PUSH
43276: LD_INT 1
43278: PUSH
43279: LD_INT 15
43281: PUSH
43282: EMPTY
43283: LIST
43284: LIST
43285: IN
43286: PUSH
43287: LD_EXP 98
43291: PUSH
43292: LD_VAR 0 1
43296: ARRAY
43297: AND
43298: IFFALSE 43454
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43300: LD_ADDR_VAR 0 9
43304: PUSH
43305: LD_EXP 98
43309: PUSH
43310: LD_VAR 0 1
43314: ARRAY
43315: PUSH
43316: LD_INT 1
43318: ARRAY
43319: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43320: LD_VAR 0 9
43324: PUSH
43325: LD_EXP 99
43329: PUSH
43330: LD_VAR 0 1
43334: ARRAY
43335: IN
43336: NOT
43337: IFFALSE 43452
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43339: LD_ADDR_EXP 99
43343: PUSH
43344: LD_EXP 99
43348: PPUSH
43349: LD_VAR 0 1
43353: PUSH
43354: LD_EXP 99
43358: PUSH
43359: LD_VAR 0 1
43363: ARRAY
43364: PUSH
43365: LD_INT 1
43367: PLUS
43368: PUSH
43369: EMPTY
43370: LIST
43371: LIST
43372: PPUSH
43373: LD_VAR 0 9
43377: PPUSH
43378: CALL 55693 0 3
43382: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43383: LD_ADDR_EXP 98
43387: PUSH
43388: LD_EXP 98
43392: PPUSH
43393: LD_VAR 0 1
43397: PPUSH
43398: LD_EXP 98
43402: PUSH
43403: LD_VAR 0 1
43407: ARRAY
43408: PUSH
43409: LD_VAR 0 9
43413: DIFF
43414: PPUSH
43415: CALL_OW 1
43419: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43420: LD_VAR 0 3
43424: PPUSH
43425: LD_EXP 99
43429: PUSH
43430: LD_VAR 0 1
43434: ARRAY
43435: PUSH
43436: LD_EXP 99
43440: PUSH
43441: LD_VAR 0 1
43445: ARRAY
43446: ARRAY
43447: PPUSH
43448: CALL_OW 120
// end ; exit ;
43452: GO 43773
// end ; if tmp > 1 then
43454: LD_VAR 0 8
43458: PUSH
43459: LD_INT 1
43461: GREATER
43462: IFFALSE 43566
// for i = 2 to tmp do
43464: LD_ADDR_VAR 0 6
43468: PUSH
43469: DOUBLE
43470: LD_INT 2
43472: DEC
43473: ST_TO_ADDR
43474: LD_VAR 0 8
43478: PUSH
43479: FOR_TO
43480: IFFALSE 43564
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43482: LD_VAR 0 8
43486: PUSH
43487: LD_VAR 0 6
43491: ARRAY
43492: PPUSH
43493: CALL_OW 461
43497: PUSH
43498: LD_INT 6
43500: EQUAL
43501: IFFALSE 43562
// begin x := tmp [ i ] ;
43503: LD_ADDR_VAR 0 9
43507: PUSH
43508: LD_VAR 0 8
43512: PUSH
43513: LD_VAR 0 6
43517: ARRAY
43518: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43519: LD_ADDR_VAR 0 8
43523: PUSH
43524: LD_VAR 0 8
43528: PPUSH
43529: LD_VAR 0 6
43533: PPUSH
43534: CALL_OW 3
43538: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43539: LD_ADDR_VAR 0 8
43543: PUSH
43544: LD_VAR 0 8
43548: PPUSH
43549: LD_INT 1
43551: PPUSH
43552: LD_VAR 0 9
43556: PPUSH
43557: CALL_OW 2
43561: ST_TO_ADDR
// end ;
43562: GO 43479
43564: POP
43565: POP
// for i in tmp do
43566: LD_ADDR_VAR 0 6
43570: PUSH
43571: LD_VAR 0 8
43575: PUSH
43576: FOR_IN
43577: IFFALSE 43646
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43579: LD_VAR 0 6
43583: PPUSH
43584: CALL_OW 313
43588: PUSH
43589: LD_INT 6
43591: LESS
43592: PUSH
43593: LD_VAR 0 6
43597: PPUSH
43598: CALL_OW 266
43602: PUSH
43603: LD_INT 31
43605: PUSH
43606: LD_INT 32
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: IN
43613: NOT
43614: AND
43615: PUSH
43616: LD_VAR 0 6
43620: PPUSH
43621: CALL_OW 313
43625: PUSH
43626: LD_INT 0
43628: EQUAL
43629: OR
43630: IFFALSE 43644
// begin j := i ;
43632: LD_ADDR_VAR 0 7
43636: PUSH
43637: LD_VAR 0 6
43641: ST_TO_ADDR
// break ;
43642: GO 43646
// end ; end ;
43644: GO 43576
43646: POP
43647: POP
// if j then
43648: LD_VAR 0 7
43652: IFFALSE 43670
// ComEnterUnit ( unit , j ) else
43654: LD_VAR 0 3
43658: PPUSH
43659: LD_VAR 0 7
43663: PPUSH
43664: CALL_OW 120
43668: GO 43773
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43670: LD_ADDR_VAR 0 10
43674: PUSH
43675: LD_VAR 0 2
43679: PPUSH
43680: LD_INT 2
43682: PUSH
43683: LD_INT 30
43685: PUSH
43686: LD_INT 0
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 30
43695: PUSH
43696: LD_INT 1
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: EMPTY
43704: LIST
43705: LIST
43706: LIST
43707: PPUSH
43708: CALL_OW 72
43712: ST_TO_ADDR
// if depot then
43713: LD_VAR 0 10
43717: IFFALSE 43773
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43719: LD_ADDR_VAR 0 10
43723: PUSH
43724: LD_VAR 0 10
43728: PPUSH
43729: LD_VAR 0 3
43733: PPUSH
43734: CALL_OW 74
43738: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43739: LD_VAR 0 3
43743: PPUSH
43744: LD_VAR 0 10
43748: PPUSH
43749: CALL_OW 296
43753: PUSH
43754: LD_INT 10
43756: GREATER
43757: IFFALSE 43773
// ComStandNearbyBuilding ( unit , depot ) ;
43759: LD_VAR 0 3
43763: PPUSH
43764: LD_VAR 0 10
43768: PPUSH
43769: CALL 52307 0 2
// end ; end ; end ;
43773: LD_VAR 0 5
43777: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43778: LD_INT 0
43780: PPUSH
43781: PPUSH
43782: PPUSH
43783: PPUSH
// if not mc_bases then
43784: LD_EXP 89
43788: NOT
43789: IFFALSE 43793
// exit ;
43791: GO 44032
// for i = 1 to mc_bases do
43793: LD_ADDR_VAR 0 2
43797: PUSH
43798: DOUBLE
43799: LD_INT 1
43801: DEC
43802: ST_TO_ADDR
43803: LD_EXP 89
43807: PUSH
43808: FOR_TO
43809: IFFALSE 44030
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43811: LD_ADDR_VAR 0 4
43815: PUSH
43816: LD_EXP 89
43820: PUSH
43821: LD_VAR 0 2
43825: ARRAY
43826: PPUSH
43827: LD_INT 21
43829: PUSH
43830: LD_INT 1
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PPUSH
43837: CALL_OW 72
43841: PUSH
43842: LD_EXP 118
43846: PUSH
43847: LD_VAR 0 2
43851: ARRAY
43852: UNION
43853: ST_TO_ADDR
// if not tmp then
43854: LD_VAR 0 4
43858: NOT
43859: IFFALSE 43863
// continue ;
43861: GO 43808
// for j in tmp do
43863: LD_ADDR_VAR 0 3
43867: PUSH
43868: LD_VAR 0 4
43872: PUSH
43873: FOR_IN
43874: IFFALSE 44026
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43876: LD_VAR 0 3
43880: PPUSH
43881: CALL_OW 110
43885: NOT
43886: PUSH
43887: LD_VAR 0 3
43891: PPUSH
43892: CALL_OW 314
43896: NOT
43897: AND
43898: PUSH
43899: LD_VAR 0 3
43903: PPUSH
43904: CALL_OW 311
43908: NOT
43909: AND
43910: PUSH
43911: LD_VAR 0 3
43915: PPUSH
43916: CALL_OW 310
43920: NOT
43921: AND
43922: PUSH
43923: LD_VAR 0 3
43927: PUSH
43928: LD_EXP 92
43932: PUSH
43933: LD_VAR 0 2
43937: ARRAY
43938: PUSH
43939: LD_INT 1
43941: ARRAY
43942: IN
43943: NOT
43944: AND
43945: PUSH
43946: LD_VAR 0 3
43950: PUSH
43951: LD_EXP 92
43955: PUSH
43956: LD_VAR 0 2
43960: ARRAY
43961: PUSH
43962: LD_INT 2
43964: ARRAY
43965: IN
43966: NOT
43967: AND
43968: PUSH
43969: LD_VAR 0 3
43973: PUSH
43974: LD_EXP 101
43978: PUSH
43979: LD_VAR 0 2
43983: ARRAY
43984: IN
43985: NOT
43986: AND
43987: IFFALSE 44024
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43989: LD_VAR 0 2
43993: PPUSH
43994: LD_EXP 89
43998: PUSH
43999: LD_VAR 0 2
44003: ARRAY
44004: PPUSH
44005: LD_VAR 0 3
44009: PPUSH
44010: LD_VAR 0 3
44014: PPUSH
44015: CALL_OW 257
44019: PPUSH
44020: CALL 42796 0 4
// end ;
44024: GO 43873
44026: POP
44027: POP
// end ;
44028: GO 43808
44030: POP
44031: POP
// end ;
44032: LD_VAR 0 1
44036: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44037: LD_INT 0
44039: PPUSH
44040: PPUSH
44041: PPUSH
44042: PPUSH
44043: PPUSH
44044: PPUSH
// if not mc_bases [ base ] then
44045: LD_EXP 89
44049: PUSH
44050: LD_VAR 0 1
44054: ARRAY
44055: NOT
44056: IFFALSE 44060
// exit ;
44058: GO 44242
// tmp := [ ] ;
44060: LD_ADDR_VAR 0 6
44064: PUSH
44065: EMPTY
44066: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44067: LD_ADDR_VAR 0 7
44071: PUSH
44072: LD_VAR 0 3
44076: PPUSH
44077: LD_INT 0
44079: PPUSH
44080: CALL_OW 517
44084: ST_TO_ADDR
// if not list then
44085: LD_VAR 0 7
44089: NOT
44090: IFFALSE 44094
// exit ;
44092: GO 44242
// for i = 1 to amount do
44094: LD_ADDR_VAR 0 5
44098: PUSH
44099: DOUBLE
44100: LD_INT 1
44102: DEC
44103: ST_TO_ADDR
44104: LD_VAR 0 2
44108: PUSH
44109: FOR_TO
44110: IFFALSE 44190
// begin x := rand ( 1 , list [ 1 ] ) ;
44112: LD_ADDR_VAR 0 8
44116: PUSH
44117: LD_INT 1
44119: PPUSH
44120: LD_VAR 0 7
44124: PUSH
44125: LD_INT 1
44127: ARRAY
44128: PPUSH
44129: CALL_OW 12
44133: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44134: LD_ADDR_VAR 0 6
44138: PUSH
44139: LD_VAR 0 6
44143: PPUSH
44144: LD_VAR 0 5
44148: PPUSH
44149: LD_VAR 0 7
44153: PUSH
44154: LD_INT 1
44156: ARRAY
44157: PUSH
44158: LD_VAR 0 8
44162: ARRAY
44163: PUSH
44164: LD_VAR 0 7
44168: PUSH
44169: LD_INT 2
44171: ARRAY
44172: PUSH
44173: LD_VAR 0 8
44177: ARRAY
44178: PUSH
44179: EMPTY
44180: LIST
44181: LIST
44182: PPUSH
44183: CALL_OW 1
44187: ST_TO_ADDR
// end ;
44188: GO 44109
44190: POP
44191: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44192: LD_ADDR_EXP 102
44196: PUSH
44197: LD_EXP 102
44201: PPUSH
44202: LD_VAR 0 1
44206: PPUSH
44207: LD_VAR 0 6
44211: PPUSH
44212: CALL_OW 1
44216: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44217: LD_ADDR_EXP 104
44221: PUSH
44222: LD_EXP 104
44226: PPUSH
44227: LD_VAR 0 1
44231: PPUSH
44232: LD_VAR 0 3
44236: PPUSH
44237: CALL_OW 1
44241: ST_TO_ADDR
// end ;
44242: LD_VAR 0 4
44246: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44247: LD_INT 0
44249: PPUSH
// if not mc_bases [ base ] then
44250: LD_EXP 89
44254: PUSH
44255: LD_VAR 0 1
44259: ARRAY
44260: NOT
44261: IFFALSE 44265
// exit ;
44263: GO 44290
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44265: LD_ADDR_EXP 94
44269: PUSH
44270: LD_EXP 94
44274: PPUSH
44275: LD_VAR 0 1
44279: PPUSH
44280: LD_VAR 0 2
44284: PPUSH
44285: CALL_OW 1
44289: ST_TO_ADDR
// end ;
44290: LD_VAR 0 3
44294: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44295: LD_INT 0
44297: PPUSH
// if not mc_bases [ base ] then
44298: LD_EXP 89
44302: PUSH
44303: LD_VAR 0 1
44307: ARRAY
44308: NOT
44309: IFFALSE 44313
// exit ;
44311: GO 44350
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44313: LD_ADDR_EXP 94
44317: PUSH
44318: LD_EXP 94
44322: PPUSH
44323: LD_VAR 0 1
44327: PPUSH
44328: LD_EXP 94
44332: PUSH
44333: LD_VAR 0 1
44337: ARRAY
44338: PUSH
44339: LD_VAR 0 2
44343: UNION
44344: PPUSH
44345: CALL_OW 1
44349: ST_TO_ADDR
// end ;
44350: LD_VAR 0 3
44354: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44355: LD_INT 0
44357: PPUSH
// if not mc_bases [ base ] then
44358: LD_EXP 89
44362: PUSH
44363: LD_VAR 0 1
44367: ARRAY
44368: NOT
44369: IFFALSE 44373
// exit ;
44371: GO 44398
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44373: LD_ADDR_EXP 110
44377: PUSH
44378: LD_EXP 110
44382: PPUSH
44383: LD_VAR 0 1
44387: PPUSH
44388: LD_VAR 0 2
44392: PPUSH
44393: CALL_OW 1
44397: ST_TO_ADDR
// end ;
44398: LD_VAR 0 3
44402: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44403: LD_INT 0
44405: PPUSH
// if not mc_bases [ base ] then
44406: LD_EXP 89
44410: PUSH
44411: LD_VAR 0 1
44415: ARRAY
44416: NOT
44417: IFFALSE 44421
// exit ;
44419: GO 44458
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44421: LD_ADDR_EXP 110
44425: PUSH
44426: LD_EXP 110
44430: PPUSH
44431: LD_VAR 0 1
44435: PPUSH
44436: LD_EXP 110
44440: PUSH
44441: LD_VAR 0 1
44445: ARRAY
44446: PUSH
44447: LD_VAR 0 2
44451: ADD
44452: PPUSH
44453: CALL_OW 1
44457: ST_TO_ADDR
// end ;
44458: LD_VAR 0 3
44462: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44463: LD_INT 0
44465: PPUSH
// if not mc_bases [ base ] then
44466: LD_EXP 89
44470: PUSH
44471: LD_VAR 0 1
44475: ARRAY
44476: NOT
44477: IFFALSE 44481
// exit ;
44479: GO 44535
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44481: LD_ADDR_EXP 111
44485: PUSH
44486: LD_EXP 111
44490: PPUSH
44491: LD_VAR 0 1
44495: PPUSH
44496: LD_VAR 0 2
44500: PPUSH
44501: CALL_OW 1
44505: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44506: LD_ADDR_EXP 100
44510: PUSH
44511: LD_EXP 100
44515: PPUSH
44516: LD_VAR 0 1
44520: PPUSH
44521: LD_VAR 0 2
44525: PUSH
44526: LD_INT 0
44528: PLUS
44529: PPUSH
44530: CALL_OW 1
44534: ST_TO_ADDR
// end ;
44535: LD_VAR 0 3
44539: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44540: LD_INT 0
44542: PPUSH
// if not mc_bases [ base ] then
44543: LD_EXP 89
44547: PUSH
44548: LD_VAR 0 1
44552: ARRAY
44553: NOT
44554: IFFALSE 44558
// exit ;
44556: GO 44583
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44558: LD_ADDR_EXP 100
44562: PUSH
44563: LD_EXP 100
44567: PPUSH
44568: LD_VAR 0 1
44572: PPUSH
44573: LD_VAR 0 2
44577: PPUSH
44578: CALL_OW 1
44582: ST_TO_ADDR
// end ;
44583: LD_VAR 0 3
44587: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44588: LD_INT 0
44590: PPUSH
44591: PPUSH
44592: PPUSH
44593: PPUSH
// if not mc_bases [ base ] then
44594: LD_EXP 89
44598: PUSH
44599: LD_VAR 0 1
44603: ARRAY
44604: NOT
44605: IFFALSE 44609
// exit ;
44607: GO 44674
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44609: LD_ADDR_EXP 109
44613: PUSH
44614: LD_EXP 109
44618: PPUSH
44619: LD_VAR 0 1
44623: PUSH
44624: LD_EXP 109
44628: PUSH
44629: LD_VAR 0 1
44633: ARRAY
44634: PUSH
44635: LD_INT 1
44637: PLUS
44638: PUSH
44639: EMPTY
44640: LIST
44641: LIST
44642: PPUSH
44643: LD_VAR 0 1
44647: PUSH
44648: LD_VAR 0 2
44652: PUSH
44653: LD_VAR 0 3
44657: PUSH
44658: LD_VAR 0 4
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: PPUSH
44669: CALL 55693 0 3
44673: ST_TO_ADDR
// end ;
44674: LD_VAR 0 5
44678: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44679: LD_INT 0
44681: PPUSH
// if not mc_bases [ base ] then
44682: LD_EXP 89
44686: PUSH
44687: LD_VAR 0 1
44691: ARRAY
44692: NOT
44693: IFFALSE 44697
// exit ;
44695: GO 44722
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44697: LD_ADDR_EXP 126
44701: PUSH
44702: LD_EXP 126
44706: PPUSH
44707: LD_VAR 0 1
44711: PPUSH
44712: LD_VAR 0 2
44716: PPUSH
44717: CALL_OW 1
44721: ST_TO_ADDR
// end ;
44722: LD_VAR 0 3
44726: RET
// export function MC_GetMinesField ( base ) ; begin
44727: LD_INT 0
44729: PPUSH
// result := mc_mines [ base ] ;
44730: LD_ADDR_VAR 0 2
44734: PUSH
44735: LD_EXP 102
44739: PUSH
44740: LD_VAR 0 1
44744: ARRAY
44745: ST_TO_ADDR
// end ;
44746: LD_VAR 0 2
44750: RET
// export function MC_GetProduceList ( base ) ; begin
44751: LD_INT 0
44753: PPUSH
// result := mc_produce [ base ] ;
44754: LD_ADDR_VAR 0 2
44758: PUSH
44759: LD_EXP 110
44763: PUSH
44764: LD_VAR 0 1
44768: ARRAY
44769: ST_TO_ADDR
// end ;
44770: LD_VAR 0 2
44774: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44775: LD_INT 0
44777: PPUSH
44778: PPUSH
// if not mc_bases then
44779: LD_EXP 89
44783: NOT
44784: IFFALSE 44788
// exit ;
44786: GO 44853
// if mc_bases [ base ] then
44788: LD_EXP 89
44792: PUSH
44793: LD_VAR 0 1
44797: ARRAY
44798: IFFALSE 44853
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44800: LD_ADDR_VAR 0 3
44804: PUSH
44805: LD_EXP 89
44809: PUSH
44810: LD_VAR 0 1
44814: ARRAY
44815: PPUSH
44816: LD_INT 30
44818: PUSH
44819: LD_VAR 0 2
44823: PUSH
44824: EMPTY
44825: LIST
44826: LIST
44827: PPUSH
44828: CALL_OW 72
44832: ST_TO_ADDR
// if result then
44833: LD_VAR 0 3
44837: IFFALSE 44853
// result := result [ 1 ] ;
44839: LD_ADDR_VAR 0 3
44843: PUSH
44844: LD_VAR 0 3
44848: PUSH
44849: LD_INT 1
44851: ARRAY
44852: ST_TO_ADDR
// end ; end ;
44853: LD_VAR 0 3
44857: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44858: LD_INT 0
44860: PPUSH
44861: PPUSH
// if not mc_bases then
44862: LD_EXP 89
44866: NOT
44867: IFFALSE 44871
// exit ;
44869: GO 44916
// if mc_bases [ base ] then
44871: LD_EXP 89
44875: PUSH
44876: LD_VAR 0 1
44880: ARRAY
44881: IFFALSE 44916
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44883: LD_ADDR_VAR 0 3
44887: PUSH
44888: LD_EXP 89
44892: PUSH
44893: LD_VAR 0 1
44897: ARRAY
44898: PPUSH
44899: LD_INT 30
44901: PUSH
44902: LD_VAR 0 2
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PPUSH
44911: CALL_OW 72
44915: ST_TO_ADDR
// end ;
44916: LD_VAR 0 3
44920: RET
// export function MC_SetTame ( base , area ) ; begin
44921: LD_INT 0
44923: PPUSH
// if not mc_bases or not base then
44924: LD_EXP 89
44928: NOT
44929: PUSH
44930: LD_VAR 0 1
44934: NOT
44935: OR
44936: IFFALSE 44940
// exit ;
44938: GO 44965
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44940: LD_ADDR_EXP 117
44944: PUSH
44945: LD_EXP 117
44949: PPUSH
44950: LD_VAR 0 1
44954: PPUSH
44955: LD_VAR 0 2
44959: PPUSH
44960: CALL_OW 1
44964: ST_TO_ADDR
// end ;
44965: LD_VAR 0 3
44969: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44970: LD_INT 0
44972: PPUSH
44973: PPUSH
// if not mc_bases or not base then
44974: LD_EXP 89
44978: NOT
44979: PUSH
44980: LD_VAR 0 1
44984: NOT
44985: OR
44986: IFFALSE 44990
// exit ;
44988: GO 45092
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44990: LD_ADDR_VAR 0 4
44994: PUSH
44995: LD_EXP 89
44999: PUSH
45000: LD_VAR 0 1
45004: ARRAY
45005: PPUSH
45006: LD_INT 30
45008: PUSH
45009: LD_VAR 0 2
45013: PUSH
45014: EMPTY
45015: LIST
45016: LIST
45017: PPUSH
45018: CALL_OW 72
45022: ST_TO_ADDR
// if not tmp then
45023: LD_VAR 0 4
45027: NOT
45028: IFFALSE 45032
// exit ;
45030: GO 45092
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45032: LD_ADDR_EXP 121
45036: PUSH
45037: LD_EXP 121
45041: PPUSH
45042: LD_VAR 0 1
45046: PPUSH
45047: LD_EXP 121
45051: PUSH
45052: LD_VAR 0 1
45056: ARRAY
45057: PPUSH
45058: LD_EXP 121
45062: PUSH
45063: LD_VAR 0 1
45067: ARRAY
45068: PUSH
45069: LD_INT 1
45071: PLUS
45072: PPUSH
45073: LD_VAR 0 4
45077: PUSH
45078: LD_INT 1
45080: ARRAY
45081: PPUSH
45082: CALL_OW 2
45086: PPUSH
45087: CALL_OW 1
45091: ST_TO_ADDR
// end ;
45092: LD_VAR 0 3
45096: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45097: LD_INT 0
45099: PPUSH
45100: PPUSH
// if not mc_bases or not base or not kinds then
45101: LD_EXP 89
45105: NOT
45106: PUSH
45107: LD_VAR 0 1
45111: NOT
45112: OR
45113: PUSH
45114: LD_VAR 0 2
45118: NOT
45119: OR
45120: IFFALSE 45124
// exit ;
45122: GO 45185
// for i in kinds do
45124: LD_ADDR_VAR 0 4
45128: PUSH
45129: LD_VAR 0 2
45133: PUSH
45134: FOR_IN
45135: IFFALSE 45183
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45137: LD_ADDR_EXP 123
45141: PUSH
45142: LD_EXP 123
45146: PPUSH
45147: LD_VAR 0 1
45151: PUSH
45152: LD_EXP 123
45156: PUSH
45157: LD_VAR 0 1
45161: ARRAY
45162: PUSH
45163: LD_INT 1
45165: PLUS
45166: PUSH
45167: EMPTY
45168: LIST
45169: LIST
45170: PPUSH
45171: LD_VAR 0 4
45175: PPUSH
45176: CALL 55693 0 3
45180: ST_TO_ADDR
45181: GO 45134
45183: POP
45184: POP
// end ;
45185: LD_VAR 0 3
45189: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45190: LD_INT 0
45192: PPUSH
// if not mc_bases or not base or not areas then
45193: LD_EXP 89
45197: NOT
45198: PUSH
45199: LD_VAR 0 1
45203: NOT
45204: OR
45205: PUSH
45206: LD_VAR 0 2
45210: NOT
45211: OR
45212: IFFALSE 45216
// exit ;
45214: GO 45241
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45216: LD_ADDR_EXP 107
45220: PUSH
45221: LD_EXP 107
45225: PPUSH
45226: LD_VAR 0 1
45230: PPUSH
45231: LD_VAR 0 2
45235: PPUSH
45236: CALL_OW 1
45240: ST_TO_ADDR
// end ;
45241: LD_VAR 0 3
45245: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45246: LD_INT 0
45248: PPUSH
// if not mc_bases or not base or not teleports_exit then
45249: LD_EXP 89
45253: NOT
45254: PUSH
45255: LD_VAR 0 1
45259: NOT
45260: OR
45261: PUSH
45262: LD_VAR 0 2
45266: NOT
45267: OR
45268: IFFALSE 45272
// exit ;
45270: GO 45297
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45272: LD_ADDR_EXP 124
45276: PUSH
45277: LD_EXP 124
45281: PPUSH
45282: LD_VAR 0 1
45286: PPUSH
45287: LD_VAR 0 2
45291: PPUSH
45292: CALL_OW 1
45296: ST_TO_ADDR
// end ;
45297: LD_VAR 0 3
45301: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45302: LD_INT 0
45304: PPUSH
45305: PPUSH
45306: PPUSH
// if not mc_bases or not base or not ext_list then
45307: LD_EXP 89
45311: NOT
45312: PUSH
45313: LD_VAR 0 1
45317: NOT
45318: OR
45319: PUSH
45320: LD_VAR 0 5
45324: NOT
45325: OR
45326: IFFALSE 45330
// exit ;
45328: GO 45503
// tmp := GetFacExtXYD ( x , y , d ) ;
45330: LD_ADDR_VAR 0 8
45334: PUSH
45335: LD_VAR 0 2
45339: PPUSH
45340: LD_VAR 0 3
45344: PPUSH
45345: LD_VAR 0 4
45349: PPUSH
45350: CALL 84372 0 3
45354: ST_TO_ADDR
// if not tmp then
45355: LD_VAR 0 8
45359: NOT
45360: IFFALSE 45364
// exit ;
45362: GO 45503
// for i in tmp do
45364: LD_ADDR_VAR 0 7
45368: PUSH
45369: LD_VAR 0 8
45373: PUSH
45374: FOR_IN
45375: IFFALSE 45501
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45377: LD_ADDR_EXP 94
45381: PUSH
45382: LD_EXP 94
45386: PPUSH
45387: LD_VAR 0 1
45391: PPUSH
45392: LD_EXP 94
45396: PUSH
45397: LD_VAR 0 1
45401: ARRAY
45402: PPUSH
45403: LD_EXP 94
45407: PUSH
45408: LD_VAR 0 1
45412: ARRAY
45413: PUSH
45414: LD_INT 1
45416: PLUS
45417: PPUSH
45418: LD_VAR 0 5
45422: PUSH
45423: LD_INT 1
45425: ARRAY
45426: PUSH
45427: LD_VAR 0 7
45431: PUSH
45432: LD_INT 1
45434: ARRAY
45435: PUSH
45436: LD_VAR 0 7
45440: PUSH
45441: LD_INT 2
45443: ARRAY
45444: PUSH
45445: LD_VAR 0 7
45449: PUSH
45450: LD_INT 3
45452: ARRAY
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: PPUSH
45460: CALL_OW 2
45464: PPUSH
45465: CALL_OW 1
45469: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45470: LD_ADDR_VAR 0 5
45474: PUSH
45475: LD_VAR 0 5
45479: PPUSH
45480: LD_INT 1
45482: PPUSH
45483: CALL_OW 3
45487: ST_TO_ADDR
// if not ext_list then
45488: LD_VAR 0 5
45492: NOT
45493: IFFALSE 45499
// exit ;
45495: POP
45496: POP
45497: GO 45503
// end ;
45499: GO 45374
45501: POP
45502: POP
// end ;
45503: LD_VAR 0 6
45507: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45508: LD_INT 0
45510: PPUSH
// if not mc_bases or not base or not weapon_list then
45511: LD_EXP 89
45515: NOT
45516: PUSH
45517: LD_VAR 0 1
45521: NOT
45522: OR
45523: PUSH
45524: LD_VAR 0 2
45528: NOT
45529: OR
45530: IFFALSE 45534
// exit ;
45532: GO 45559
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45534: LD_ADDR_EXP 128
45538: PUSH
45539: LD_EXP 128
45543: PPUSH
45544: LD_VAR 0 1
45548: PPUSH
45549: LD_VAR 0 2
45553: PPUSH
45554: CALL_OW 1
45558: ST_TO_ADDR
// end ;
45559: LD_VAR 0 3
45563: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45564: LD_INT 0
45566: PPUSH
// if not mc_bases or not base or not tech_list then
45567: LD_EXP 89
45571: NOT
45572: PUSH
45573: LD_VAR 0 1
45577: NOT
45578: OR
45579: PUSH
45580: LD_VAR 0 2
45584: NOT
45585: OR
45586: IFFALSE 45590
// exit ;
45588: GO 45615
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45590: LD_ADDR_EXP 116
45594: PUSH
45595: LD_EXP 116
45599: PPUSH
45600: LD_VAR 0 1
45604: PPUSH
45605: LD_VAR 0 2
45609: PPUSH
45610: CALL_OW 1
45614: ST_TO_ADDR
// end ;
45615: LD_VAR 0 3
45619: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45620: LD_INT 0
45622: PPUSH
// if not mc_bases or not parking_area or not base then
45623: LD_EXP 89
45627: NOT
45628: PUSH
45629: LD_VAR 0 2
45633: NOT
45634: OR
45635: PUSH
45636: LD_VAR 0 1
45640: NOT
45641: OR
45642: IFFALSE 45646
// exit ;
45644: GO 45671
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45646: LD_ADDR_EXP 113
45650: PUSH
45651: LD_EXP 113
45655: PPUSH
45656: LD_VAR 0 1
45660: PPUSH
45661: LD_VAR 0 2
45665: PPUSH
45666: CALL_OW 1
45670: ST_TO_ADDR
// end ;
45671: LD_VAR 0 3
45675: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45676: LD_INT 0
45678: PPUSH
// if not mc_bases or not base or not scan_area then
45679: LD_EXP 89
45683: NOT
45684: PUSH
45685: LD_VAR 0 1
45689: NOT
45690: OR
45691: PUSH
45692: LD_VAR 0 2
45696: NOT
45697: OR
45698: IFFALSE 45702
// exit ;
45700: GO 45727
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45702: LD_ADDR_EXP 114
45706: PUSH
45707: LD_EXP 114
45711: PPUSH
45712: LD_VAR 0 1
45716: PPUSH
45717: LD_VAR 0 2
45721: PPUSH
45722: CALL_OW 1
45726: ST_TO_ADDR
// end ;
45727: LD_VAR 0 3
45731: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45732: LD_INT 0
45734: PPUSH
45735: PPUSH
// if not mc_bases or not base then
45736: LD_EXP 89
45740: NOT
45741: PUSH
45742: LD_VAR 0 1
45746: NOT
45747: OR
45748: IFFALSE 45752
// exit ;
45750: GO 45816
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45752: LD_ADDR_VAR 0 3
45756: PUSH
45757: LD_INT 1
45759: PUSH
45760: LD_INT 2
45762: PUSH
45763: LD_INT 3
45765: PUSH
45766: LD_INT 4
45768: PUSH
45769: LD_INT 11
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: LIST
45776: LIST
45777: LIST
45778: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45779: LD_ADDR_EXP 116
45783: PUSH
45784: LD_EXP 116
45788: PPUSH
45789: LD_VAR 0 1
45793: PPUSH
45794: LD_EXP 116
45798: PUSH
45799: LD_VAR 0 1
45803: ARRAY
45804: PUSH
45805: LD_VAR 0 3
45809: DIFF
45810: PPUSH
45811: CALL_OW 1
45815: ST_TO_ADDR
// end ;
45816: LD_VAR 0 2
45820: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45821: LD_INT 0
45823: PPUSH
// result := mc_vehicles [ base ] ;
45824: LD_ADDR_VAR 0 3
45828: PUSH
45829: LD_EXP 108
45833: PUSH
45834: LD_VAR 0 1
45838: ARRAY
45839: ST_TO_ADDR
// if onlyCombat then
45840: LD_VAR 0 2
45844: IFFALSE 46009
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45846: LD_ADDR_VAR 0 3
45850: PUSH
45851: LD_VAR 0 3
45855: PUSH
45856: LD_VAR 0 3
45860: PPUSH
45861: LD_INT 2
45863: PUSH
45864: LD_INT 34
45866: PUSH
45867: LD_INT 12
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 34
45876: PUSH
45877: LD_INT 51
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: LD_INT 34
45886: PUSH
45887: LD_EXP 73
45891: PUSH
45892: EMPTY
45893: LIST
45894: LIST
45895: PUSH
45896: LD_INT 34
45898: PUSH
45899: LD_INT 32
45901: PUSH
45902: EMPTY
45903: LIST
45904: LIST
45905: PUSH
45906: LD_INT 34
45908: PUSH
45909: LD_INT 13
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: PUSH
45916: LD_INT 34
45918: PUSH
45919: LD_INT 52
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: PUSH
45926: LD_INT 34
45928: PUSH
45929: LD_INT 14
45931: PUSH
45932: EMPTY
45933: LIST
45934: LIST
45935: PUSH
45936: LD_INT 34
45938: PUSH
45939: LD_INT 53
45941: PUSH
45942: EMPTY
45943: LIST
45944: LIST
45945: PUSH
45946: LD_INT 34
45948: PUSH
45949: LD_EXP 72
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: PUSH
45958: LD_INT 34
45960: PUSH
45961: LD_INT 31
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: PUSH
45968: LD_INT 34
45970: PUSH
45971: LD_INT 48
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 34
45980: PUSH
45981: LD_INT 8
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: PPUSH
46003: CALL_OW 72
46007: DIFF
46008: ST_TO_ADDR
// end ; end_of_file
46009: LD_VAR 0 3
46013: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46014: LD_INT 0
46016: PPUSH
46017: PPUSH
46018: PPUSH
// if not mc_bases or not skirmish then
46019: LD_EXP 89
46023: NOT
46024: PUSH
46025: LD_EXP 87
46029: NOT
46030: OR
46031: IFFALSE 46035
// exit ;
46033: GO 46200
// for i = 1 to mc_bases do
46035: LD_ADDR_VAR 0 4
46039: PUSH
46040: DOUBLE
46041: LD_INT 1
46043: DEC
46044: ST_TO_ADDR
46045: LD_EXP 89
46049: PUSH
46050: FOR_TO
46051: IFFALSE 46198
// begin if sci in mc_bases [ i ] then
46053: LD_VAR 0 2
46057: PUSH
46058: LD_EXP 89
46062: PUSH
46063: LD_VAR 0 4
46067: ARRAY
46068: IN
46069: IFFALSE 46196
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46071: LD_ADDR_EXP 118
46075: PUSH
46076: LD_EXP 118
46080: PPUSH
46081: LD_VAR 0 4
46085: PUSH
46086: LD_EXP 118
46090: PUSH
46091: LD_VAR 0 4
46095: ARRAY
46096: PUSH
46097: LD_INT 1
46099: PLUS
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PPUSH
46105: LD_VAR 0 1
46109: PPUSH
46110: CALL 55693 0 3
46114: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46115: LD_ADDR_VAR 0 5
46119: PUSH
46120: LD_EXP 89
46124: PUSH
46125: LD_VAR 0 4
46129: ARRAY
46130: PPUSH
46131: LD_INT 2
46133: PUSH
46134: LD_INT 30
46136: PUSH
46137: LD_INT 0
46139: PUSH
46140: EMPTY
46141: LIST
46142: LIST
46143: PUSH
46144: LD_INT 30
46146: PUSH
46147: LD_INT 1
46149: PUSH
46150: EMPTY
46151: LIST
46152: LIST
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: LIST
46158: PPUSH
46159: CALL_OW 72
46163: PPUSH
46164: LD_VAR 0 1
46168: PPUSH
46169: CALL_OW 74
46173: ST_TO_ADDR
// if tmp then
46174: LD_VAR 0 5
46178: IFFALSE 46194
// ComStandNearbyBuilding ( ape , tmp ) ;
46180: LD_VAR 0 1
46184: PPUSH
46185: LD_VAR 0 5
46189: PPUSH
46190: CALL 52307 0 2
// break ;
46194: GO 46198
// end ; end ;
46196: GO 46050
46198: POP
46199: POP
// end ;
46200: LD_VAR 0 3
46204: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46205: LD_INT 0
46207: PPUSH
46208: PPUSH
46209: PPUSH
// if not mc_bases or not skirmish then
46210: LD_EXP 89
46214: NOT
46215: PUSH
46216: LD_EXP 87
46220: NOT
46221: OR
46222: IFFALSE 46226
// exit ;
46224: GO 46315
// for i = 1 to mc_bases do
46226: LD_ADDR_VAR 0 4
46230: PUSH
46231: DOUBLE
46232: LD_INT 1
46234: DEC
46235: ST_TO_ADDR
46236: LD_EXP 89
46240: PUSH
46241: FOR_TO
46242: IFFALSE 46313
// begin if building in mc_busy_turret_list [ i ] then
46244: LD_VAR 0 1
46248: PUSH
46249: LD_EXP 99
46253: PUSH
46254: LD_VAR 0 4
46258: ARRAY
46259: IN
46260: IFFALSE 46311
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46262: LD_ADDR_VAR 0 5
46266: PUSH
46267: LD_EXP 99
46271: PUSH
46272: LD_VAR 0 4
46276: ARRAY
46277: PUSH
46278: LD_VAR 0 1
46282: DIFF
46283: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46284: LD_ADDR_EXP 99
46288: PUSH
46289: LD_EXP 99
46293: PPUSH
46294: LD_VAR 0 4
46298: PPUSH
46299: LD_VAR 0 5
46303: PPUSH
46304: CALL_OW 1
46308: ST_TO_ADDR
// break ;
46309: GO 46313
// end ; end ;
46311: GO 46241
46313: POP
46314: POP
// end ;
46315: LD_VAR 0 3
46319: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46320: LD_INT 0
46322: PPUSH
46323: PPUSH
46324: PPUSH
// if not mc_bases or not skirmish then
46325: LD_EXP 89
46329: NOT
46330: PUSH
46331: LD_EXP 87
46335: NOT
46336: OR
46337: IFFALSE 46341
// exit ;
46339: GO 46540
// for i = 1 to mc_bases do
46341: LD_ADDR_VAR 0 5
46345: PUSH
46346: DOUBLE
46347: LD_INT 1
46349: DEC
46350: ST_TO_ADDR
46351: LD_EXP 89
46355: PUSH
46356: FOR_TO
46357: IFFALSE 46538
// if building in mc_bases [ i ] then
46359: LD_VAR 0 1
46363: PUSH
46364: LD_EXP 89
46368: PUSH
46369: LD_VAR 0 5
46373: ARRAY
46374: IN
46375: IFFALSE 46536
// begin tmp := mc_bases [ i ] diff building ;
46377: LD_ADDR_VAR 0 6
46381: PUSH
46382: LD_EXP 89
46386: PUSH
46387: LD_VAR 0 5
46391: ARRAY
46392: PUSH
46393: LD_VAR 0 1
46397: DIFF
46398: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46399: LD_ADDR_EXP 89
46403: PUSH
46404: LD_EXP 89
46408: PPUSH
46409: LD_VAR 0 5
46413: PPUSH
46414: LD_VAR 0 6
46418: PPUSH
46419: CALL_OW 1
46423: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46424: LD_VAR 0 1
46428: PUSH
46429: LD_EXP 97
46433: PUSH
46434: LD_VAR 0 5
46438: ARRAY
46439: IN
46440: IFFALSE 46479
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46442: LD_ADDR_EXP 97
46446: PUSH
46447: LD_EXP 97
46451: PPUSH
46452: LD_VAR 0 5
46456: PPUSH
46457: LD_EXP 97
46461: PUSH
46462: LD_VAR 0 5
46466: ARRAY
46467: PUSH
46468: LD_VAR 0 1
46472: DIFF
46473: PPUSH
46474: CALL_OW 1
46478: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46479: LD_VAR 0 1
46483: PUSH
46484: LD_EXP 98
46488: PUSH
46489: LD_VAR 0 5
46493: ARRAY
46494: IN
46495: IFFALSE 46534
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46497: LD_ADDR_EXP 98
46501: PUSH
46502: LD_EXP 98
46506: PPUSH
46507: LD_VAR 0 5
46511: PPUSH
46512: LD_EXP 98
46516: PUSH
46517: LD_VAR 0 5
46521: ARRAY
46522: PUSH
46523: LD_VAR 0 1
46527: DIFF
46528: PPUSH
46529: CALL_OW 1
46533: ST_TO_ADDR
// break ;
46534: GO 46538
// end ;
46536: GO 46356
46538: POP
46539: POP
// end ;
46540: LD_VAR 0 4
46544: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46545: LD_INT 0
46547: PPUSH
46548: PPUSH
46549: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46550: LD_EXP 89
46554: NOT
46555: PUSH
46556: LD_EXP 87
46560: NOT
46561: OR
46562: PUSH
46563: LD_VAR 0 3
46567: PUSH
46568: LD_EXP 115
46572: IN
46573: NOT
46574: OR
46575: IFFALSE 46579
// exit ;
46577: GO 46702
// for i = 1 to mc_vehicles do
46579: LD_ADDR_VAR 0 6
46583: PUSH
46584: DOUBLE
46585: LD_INT 1
46587: DEC
46588: ST_TO_ADDR
46589: LD_EXP 108
46593: PUSH
46594: FOR_TO
46595: IFFALSE 46700
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46597: LD_VAR 0 2
46601: PUSH
46602: LD_EXP 108
46606: PUSH
46607: LD_VAR 0 6
46611: ARRAY
46612: IN
46613: PUSH
46614: LD_VAR 0 1
46618: PUSH
46619: LD_EXP 108
46623: PUSH
46624: LD_VAR 0 6
46628: ARRAY
46629: IN
46630: OR
46631: IFFALSE 46698
// begin tmp := mc_vehicles [ i ] diff old ;
46633: LD_ADDR_VAR 0 7
46637: PUSH
46638: LD_EXP 108
46642: PUSH
46643: LD_VAR 0 6
46647: ARRAY
46648: PUSH
46649: LD_VAR 0 2
46653: DIFF
46654: ST_TO_ADDR
// tmp := tmp diff new ;
46655: LD_ADDR_VAR 0 7
46659: PUSH
46660: LD_VAR 0 7
46664: PUSH
46665: LD_VAR 0 1
46669: DIFF
46670: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46671: LD_ADDR_EXP 108
46675: PUSH
46676: LD_EXP 108
46680: PPUSH
46681: LD_VAR 0 6
46685: PPUSH
46686: LD_VAR 0 7
46690: PPUSH
46691: CALL_OW 1
46695: ST_TO_ADDR
// break ;
46696: GO 46700
// end ;
46698: GO 46594
46700: POP
46701: POP
// end ;
46702: LD_VAR 0 5
46706: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46707: LD_INT 0
46709: PPUSH
46710: PPUSH
46711: PPUSH
46712: PPUSH
// if not mc_bases or not skirmish then
46713: LD_EXP 89
46717: NOT
46718: PUSH
46719: LD_EXP 87
46723: NOT
46724: OR
46725: IFFALSE 46729
// exit ;
46727: GO 47106
// side := GetSide ( vehicle ) ;
46729: LD_ADDR_VAR 0 5
46733: PUSH
46734: LD_VAR 0 1
46738: PPUSH
46739: CALL_OW 255
46743: ST_TO_ADDR
// for i = 1 to mc_bases do
46744: LD_ADDR_VAR 0 4
46748: PUSH
46749: DOUBLE
46750: LD_INT 1
46752: DEC
46753: ST_TO_ADDR
46754: LD_EXP 89
46758: PUSH
46759: FOR_TO
46760: IFFALSE 47104
// begin if factory in mc_bases [ i ] then
46762: LD_VAR 0 2
46766: PUSH
46767: LD_EXP 89
46771: PUSH
46772: LD_VAR 0 4
46776: ARRAY
46777: IN
46778: IFFALSE 47102
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46780: LD_EXP 111
46784: PUSH
46785: LD_VAR 0 4
46789: ARRAY
46790: PUSH
46791: LD_EXP 100
46795: PUSH
46796: LD_VAR 0 4
46800: ARRAY
46801: LESS
46802: PUSH
46803: LD_VAR 0 1
46807: PPUSH
46808: CALL_OW 264
46812: PUSH
46813: LD_INT 31
46815: PUSH
46816: LD_INT 32
46818: PUSH
46819: LD_INT 51
46821: PUSH
46822: LD_EXP 73
46826: PUSH
46827: LD_INT 12
46829: PUSH
46830: LD_INT 30
46832: PUSH
46833: LD_EXP 72
46837: PUSH
46838: LD_INT 11
46840: PUSH
46841: LD_INT 53
46843: PUSH
46844: LD_INT 14
46846: PUSH
46847: LD_EXP 76
46851: PUSH
46852: LD_INT 29
46854: PUSH
46855: LD_EXP 74
46859: PUSH
46860: LD_INT 13
46862: PUSH
46863: LD_INT 52
46865: PUSH
46866: LD_INT 48
46868: PUSH
46869: LD_INT 8
46871: PUSH
46872: EMPTY
46873: LIST
46874: LIST
46875: LIST
46876: LIST
46877: LIST
46878: LIST
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: IN
46891: NOT
46892: AND
46893: IFFALSE 46941
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46895: LD_ADDR_EXP 111
46899: PUSH
46900: LD_EXP 111
46904: PPUSH
46905: LD_VAR 0 4
46909: PUSH
46910: LD_EXP 111
46914: PUSH
46915: LD_VAR 0 4
46919: ARRAY
46920: PUSH
46921: LD_INT 1
46923: PLUS
46924: PUSH
46925: EMPTY
46926: LIST
46927: LIST
46928: PPUSH
46929: LD_VAR 0 1
46933: PPUSH
46934: CALL 55693 0 3
46938: ST_TO_ADDR
46939: GO 46985
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46941: LD_ADDR_EXP 108
46945: PUSH
46946: LD_EXP 108
46950: PPUSH
46951: LD_VAR 0 4
46955: PUSH
46956: LD_EXP 108
46960: PUSH
46961: LD_VAR 0 4
46965: ARRAY
46966: PUSH
46967: LD_INT 1
46969: PLUS
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PPUSH
46975: LD_VAR 0 1
46979: PPUSH
46980: CALL 55693 0 3
46984: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46985: LD_VAR 0 1
46989: PPUSH
46990: CALL_OW 263
46994: PUSH
46995: LD_INT 2
46997: EQUAL
46998: IFFALSE 47018
// begin repeat wait ( 0 0$1 ) ;
47000: LD_INT 35
47002: PPUSH
47003: CALL_OW 67
// until IsControledBy ( vehicle ) ;
47007: LD_VAR 0 1
47011: PPUSH
47012: CALL_OW 312
47016: IFFALSE 47000
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47018: LD_VAR 0 1
47022: PPUSH
47023: LD_EXP 113
47027: PUSH
47028: LD_VAR 0 4
47032: ARRAY
47033: PPUSH
47034: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47038: LD_VAR 0 1
47042: PPUSH
47043: CALL_OW 263
47047: PUSH
47048: LD_INT 1
47050: NONEQUAL
47051: IFFALSE 47055
// break ;
47053: GO 47104
// repeat wait ( 0 0$1 ) ;
47055: LD_INT 35
47057: PPUSH
47058: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47062: LD_VAR 0 1
47066: PPUSH
47067: LD_EXP 113
47071: PUSH
47072: LD_VAR 0 4
47076: ARRAY
47077: PPUSH
47078: CALL_OW 308
47082: IFFALSE 47055
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47084: LD_VAR 0 1
47088: PPUSH
47089: CALL_OW 311
47093: PPUSH
47094: CALL_OW 121
// exit ;
47098: POP
47099: POP
47100: GO 47106
// end ; end ;
47102: GO 46759
47104: POP
47105: POP
// end ;
47106: LD_VAR 0 3
47110: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47111: LD_INT 0
47113: PPUSH
47114: PPUSH
47115: PPUSH
47116: PPUSH
// if not mc_bases or not skirmish then
47117: LD_EXP 89
47121: NOT
47122: PUSH
47123: LD_EXP 87
47127: NOT
47128: OR
47129: IFFALSE 47133
// exit ;
47131: GO 47486
// repeat wait ( 0 0$1 ) ;
47133: LD_INT 35
47135: PPUSH
47136: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47140: LD_VAR 0 2
47144: PPUSH
47145: LD_VAR 0 3
47149: PPUSH
47150: CALL_OW 284
47154: IFFALSE 47133
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47156: LD_VAR 0 2
47160: PPUSH
47161: LD_VAR 0 3
47165: PPUSH
47166: CALL_OW 283
47170: PUSH
47171: LD_INT 4
47173: EQUAL
47174: IFFALSE 47178
// exit ;
47176: GO 47486
// for i = 1 to mc_bases do
47178: LD_ADDR_VAR 0 7
47182: PUSH
47183: DOUBLE
47184: LD_INT 1
47186: DEC
47187: ST_TO_ADDR
47188: LD_EXP 89
47192: PUSH
47193: FOR_TO
47194: IFFALSE 47484
// begin if mc_crates_area [ i ] then
47196: LD_EXP 107
47200: PUSH
47201: LD_VAR 0 7
47205: ARRAY
47206: IFFALSE 47317
// for j in mc_crates_area [ i ] do
47208: LD_ADDR_VAR 0 8
47212: PUSH
47213: LD_EXP 107
47217: PUSH
47218: LD_VAR 0 7
47222: ARRAY
47223: PUSH
47224: FOR_IN
47225: IFFALSE 47315
// if InArea ( x , y , j ) then
47227: LD_VAR 0 2
47231: PPUSH
47232: LD_VAR 0 3
47236: PPUSH
47237: LD_VAR 0 8
47241: PPUSH
47242: CALL_OW 309
47246: IFFALSE 47313
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47248: LD_ADDR_EXP 105
47252: PUSH
47253: LD_EXP 105
47257: PPUSH
47258: LD_VAR 0 7
47262: PUSH
47263: LD_EXP 105
47267: PUSH
47268: LD_VAR 0 7
47272: ARRAY
47273: PUSH
47274: LD_INT 1
47276: PLUS
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: PPUSH
47282: LD_VAR 0 4
47286: PUSH
47287: LD_VAR 0 2
47291: PUSH
47292: LD_VAR 0 3
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: LIST
47301: PPUSH
47302: CALL 55693 0 3
47306: ST_TO_ADDR
// exit ;
47307: POP
47308: POP
47309: POP
47310: POP
47311: GO 47486
// end ;
47313: GO 47224
47315: POP
47316: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47317: LD_ADDR_VAR 0 9
47321: PUSH
47322: LD_EXP 89
47326: PUSH
47327: LD_VAR 0 7
47331: ARRAY
47332: PPUSH
47333: LD_INT 2
47335: PUSH
47336: LD_INT 30
47338: PUSH
47339: LD_INT 0
47341: PUSH
47342: EMPTY
47343: LIST
47344: LIST
47345: PUSH
47346: LD_INT 30
47348: PUSH
47349: LD_INT 1
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: EMPTY
47357: LIST
47358: LIST
47359: LIST
47360: PPUSH
47361: CALL_OW 72
47365: ST_TO_ADDR
// if not depot then
47366: LD_VAR 0 9
47370: NOT
47371: IFFALSE 47375
// continue ;
47373: GO 47193
// for j in depot do
47375: LD_ADDR_VAR 0 8
47379: PUSH
47380: LD_VAR 0 9
47384: PUSH
47385: FOR_IN
47386: IFFALSE 47480
// if GetDistUnitXY ( j , x , y ) < 30 then
47388: LD_VAR 0 8
47392: PPUSH
47393: LD_VAR 0 2
47397: PPUSH
47398: LD_VAR 0 3
47402: PPUSH
47403: CALL_OW 297
47407: PUSH
47408: LD_INT 30
47410: LESS
47411: IFFALSE 47478
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47413: LD_ADDR_EXP 105
47417: PUSH
47418: LD_EXP 105
47422: PPUSH
47423: LD_VAR 0 7
47427: PUSH
47428: LD_EXP 105
47432: PUSH
47433: LD_VAR 0 7
47437: ARRAY
47438: PUSH
47439: LD_INT 1
47441: PLUS
47442: PUSH
47443: EMPTY
47444: LIST
47445: LIST
47446: PPUSH
47447: LD_VAR 0 4
47451: PUSH
47452: LD_VAR 0 2
47456: PUSH
47457: LD_VAR 0 3
47461: PUSH
47462: EMPTY
47463: LIST
47464: LIST
47465: LIST
47466: PPUSH
47467: CALL 55693 0 3
47471: ST_TO_ADDR
// exit ;
47472: POP
47473: POP
47474: POP
47475: POP
47476: GO 47486
// end ;
47478: GO 47385
47480: POP
47481: POP
// end ;
47482: GO 47193
47484: POP
47485: POP
// end ;
47486: LD_VAR 0 6
47490: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47491: LD_INT 0
47493: PPUSH
47494: PPUSH
47495: PPUSH
47496: PPUSH
// if not mc_bases or not skirmish then
47497: LD_EXP 89
47501: NOT
47502: PUSH
47503: LD_EXP 87
47507: NOT
47508: OR
47509: IFFALSE 47513
// exit ;
47511: GO 47790
// side := GetSide ( lab ) ;
47513: LD_ADDR_VAR 0 4
47517: PUSH
47518: LD_VAR 0 2
47522: PPUSH
47523: CALL_OW 255
47527: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47528: LD_VAR 0 4
47532: PUSH
47533: LD_EXP 115
47537: IN
47538: NOT
47539: PUSH
47540: LD_EXP 116
47544: NOT
47545: OR
47546: PUSH
47547: LD_EXP 89
47551: NOT
47552: OR
47553: IFFALSE 47557
// exit ;
47555: GO 47790
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47557: LD_ADDR_EXP 116
47561: PUSH
47562: LD_EXP 116
47566: PPUSH
47567: LD_VAR 0 4
47571: PPUSH
47572: LD_EXP 116
47576: PUSH
47577: LD_VAR 0 4
47581: ARRAY
47582: PUSH
47583: LD_VAR 0 1
47587: DIFF
47588: PPUSH
47589: CALL_OW 1
47593: ST_TO_ADDR
// for i = 1 to mc_bases do
47594: LD_ADDR_VAR 0 5
47598: PUSH
47599: DOUBLE
47600: LD_INT 1
47602: DEC
47603: ST_TO_ADDR
47604: LD_EXP 89
47608: PUSH
47609: FOR_TO
47610: IFFALSE 47788
// begin if lab in mc_bases [ i ] then
47612: LD_VAR 0 2
47616: PUSH
47617: LD_EXP 89
47621: PUSH
47622: LD_VAR 0 5
47626: ARRAY
47627: IN
47628: IFFALSE 47786
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47630: LD_VAR 0 1
47634: PUSH
47635: LD_INT 11
47637: PUSH
47638: LD_INT 4
47640: PUSH
47641: LD_INT 3
47643: PUSH
47644: LD_INT 2
47646: PUSH
47647: EMPTY
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: IN
47653: PUSH
47654: LD_EXP 119
47658: PUSH
47659: LD_VAR 0 5
47663: ARRAY
47664: AND
47665: IFFALSE 47786
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47667: LD_ADDR_VAR 0 6
47671: PUSH
47672: LD_EXP 119
47676: PUSH
47677: LD_VAR 0 5
47681: ARRAY
47682: PUSH
47683: LD_INT 1
47685: ARRAY
47686: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47687: LD_ADDR_EXP 119
47691: PUSH
47692: LD_EXP 119
47696: PPUSH
47697: LD_VAR 0 5
47701: PPUSH
47702: EMPTY
47703: PPUSH
47704: CALL_OW 1
47708: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47709: LD_VAR 0 6
47713: PPUSH
47714: LD_INT 0
47716: PPUSH
47717: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47721: LD_VAR 0 6
47725: PPUSH
47726: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47730: LD_ADDR_EXP 118
47734: PUSH
47735: LD_EXP 118
47739: PPUSH
47740: LD_VAR 0 5
47744: PPUSH
47745: LD_EXP 118
47749: PUSH
47750: LD_VAR 0 5
47754: ARRAY
47755: PPUSH
47756: LD_INT 1
47758: PPUSH
47759: LD_VAR 0 6
47763: PPUSH
47764: CALL_OW 2
47768: PPUSH
47769: CALL_OW 1
47773: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47774: LD_VAR 0 5
47778: PPUSH
47779: LD_INT 112
47781: PPUSH
47782: CALL 24802 0 2
// end ; end ; end ;
47786: GO 47609
47788: POP
47789: POP
// end ;
47790: LD_VAR 0 3
47794: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47795: LD_INT 0
47797: PPUSH
47798: PPUSH
47799: PPUSH
47800: PPUSH
47801: PPUSH
47802: PPUSH
47803: PPUSH
47804: PPUSH
// if not mc_bases or not skirmish then
47805: LD_EXP 89
47809: NOT
47810: PUSH
47811: LD_EXP 87
47815: NOT
47816: OR
47817: IFFALSE 47821
// exit ;
47819: GO 49192
// for i = 1 to mc_bases do
47821: LD_ADDR_VAR 0 3
47825: PUSH
47826: DOUBLE
47827: LD_INT 1
47829: DEC
47830: ST_TO_ADDR
47831: LD_EXP 89
47835: PUSH
47836: FOR_TO
47837: IFFALSE 49190
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47839: LD_VAR 0 1
47843: PUSH
47844: LD_EXP 89
47848: PUSH
47849: LD_VAR 0 3
47853: ARRAY
47854: IN
47855: PUSH
47856: LD_VAR 0 1
47860: PUSH
47861: LD_EXP 96
47865: PUSH
47866: LD_VAR 0 3
47870: ARRAY
47871: IN
47872: OR
47873: PUSH
47874: LD_VAR 0 1
47878: PUSH
47879: LD_EXP 111
47883: PUSH
47884: LD_VAR 0 3
47888: ARRAY
47889: IN
47890: OR
47891: PUSH
47892: LD_VAR 0 1
47896: PUSH
47897: LD_EXP 108
47901: PUSH
47902: LD_VAR 0 3
47906: ARRAY
47907: IN
47908: OR
47909: PUSH
47910: LD_VAR 0 1
47914: PUSH
47915: LD_EXP 118
47919: PUSH
47920: LD_VAR 0 3
47924: ARRAY
47925: IN
47926: OR
47927: PUSH
47928: LD_VAR 0 1
47932: PUSH
47933: LD_EXP 119
47937: PUSH
47938: LD_VAR 0 3
47942: ARRAY
47943: IN
47944: OR
47945: IFFALSE 49188
// begin if un in mc_ape [ i ] then
47947: LD_VAR 0 1
47951: PUSH
47952: LD_EXP 118
47956: PUSH
47957: LD_VAR 0 3
47961: ARRAY
47962: IN
47963: IFFALSE 48002
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47965: LD_ADDR_EXP 118
47969: PUSH
47970: LD_EXP 118
47974: PPUSH
47975: LD_VAR 0 3
47979: PPUSH
47980: LD_EXP 118
47984: PUSH
47985: LD_VAR 0 3
47989: ARRAY
47990: PUSH
47991: LD_VAR 0 1
47995: DIFF
47996: PPUSH
47997: CALL_OW 1
48001: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48002: LD_VAR 0 1
48006: PUSH
48007: LD_EXP 119
48011: PUSH
48012: LD_VAR 0 3
48016: ARRAY
48017: IN
48018: IFFALSE 48042
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48020: LD_ADDR_EXP 119
48024: PUSH
48025: LD_EXP 119
48029: PPUSH
48030: LD_VAR 0 3
48034: PPUSH
48035: EMPTY
48036: PPUSH
48037: CALL_OW 1
48041: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48042: LD_VAR 0 1
48046: PPUSH
48047: CALL_OW 247
48051: PUSH
48052: LD_INT 2
48054: EQUAL
48055: PUSH
48056: LD_VAR 0 1
48060: PPUSH
48061: CALL_OW 110
48065: PUSH
48066: LD_INT 20
48068: EQUAL
48069: PUSH
48070: LD_VAR 0 1
48074: PUSH
48075: LD_EXP 111
48079: PUSH
48080: LD_VAR 0 3
48084: ARRAY
48085: IN
48086: OR
48087: PUSH
48088: LD_VAR 0 1
48092: PPUSH
48093: CALL_OW 264
48097: PUSH
48098: LD_INT 12
48100: PUSH
48101: LD_INT 51
48103: PUSH
48104: LD_EXP 73
48108: PUSH
48109: LD_INT 32
48111: PUSH
48112: LD_INT 13
48114: PUSH
48115: LD_INT 52
48117: PUSH
48118: LD_INT 31
48120: PUSH
48121: EMPTY
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: IN
48130: OR
48131: AND
48132: IFFALSE 48440
// begin if un in mc_defender [ i ] then
48134: LD_VAR 0 1
48138: PUSH
48139: LD_EXP 111
48143: PUSH
48144: LD_VAR 0 3
48148: ARRAY
48149: IN
48150: IFFALSE 48189
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48152: LD_ADDR_EXP 111
48156: PUSH
48157: LD_EXP 111
48161: PPUSH
48162: LD_VAR 0 3
48166: PPUSH
48167: LD_EXP 111
48171: PUSH
48172: LD_VAR 0 3
48176: ARRAY
48177: PUSH
48178: LD_VAR 0 1
48182: DIFF
48183: PPUSH
48184: CALL_OW 1
48188: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48189: LD_ADDR_VAR 0 8
48193: PUSH
48194: LD_VAR 0 3
48198: PPUSH
48199: LD_INT 3
48201: PPUSH
48202: CALL 44858 0 2
48206: ST_TO_ADDR
// if fac then
48207: LD_VAR 0 8
48211: IFFALSE 48440
// begin for j in fac do
48213: LD_ADDR_VAR 0 4
48217: PUSH
48218: LD_VAR 0 8
48222: PUSH
48223: FOR_IN
48224: IFFALSE 48438
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48226: LD_ADDR_VAR 0 9
48230: PUSH
48231: LD_VAR 0 8
48235: PPUSH
48236: LD_VAR 0 1
48240: PPUSH
48241: CALL_OW 265
48245: PPUSH
48246: LD_VAR 0 1
48250: PPUSH
48251: CALL_OW 262
48255: PPUSH
48256: LD_VAR 0 1
48260: PPUSH
48261: CALL_OW 263
48265: PPUSH
48266: LD_VAR 0 1
48270: PPUSH
48271: CALL_OW 264
48275: PPUSH
48276: CALL 53225 0 5
48280: ST_TO_ADDR
// if components then
48281: LD_VAR 0 9
48285: IFFALSE 48436
// begin if GetWeapon ( un ) = ar_control_tower then
48287: LD_VAR 0 1
48291: PPUSH
48292: CALL_OW 264
48296: PUSH
48297: LD_INT 31
48299: EQUAL
48300: IFFALSE 48417
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48302: LD_VAR 0 1
48306: PPUSH
48307: CALL_OW 311
48311: PPUSH
48312: LD_INT 0
48314: PPUSH
48315: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48319: LD_ADDR_EXP 129
48323: PUSH
48324: LD_EXP 129
48328: PPUSH
48329: LD_VAR 0 3
48333: PPUSH
48334: LD_EXP 129
48338: PUSH
48339: LD_VAR 0 3
48343: ARRAY
48344: PUSH
48345: LD_VAR 0 1
48349: PPUSH
48350: CALL_OW 311
48354: DIFF
48355: PPUSH
48356: CALL_OW 1
48360: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48361: LD_ADDR_VAR 0 7
48365: PUSH
48366: LD_EXP 110
48370: PUSH
48371: LD_VAR 0 3
48375: ARRAY
48376: PPUSH
48377: LD_INT 1
48379: PPUSH
48380: LD_VAR 0 9
48384: PPUSH
48385: CALL_OW 2
48389: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48390: LD_ADDR_EXP 110
48394: PUSH
48395: LD_EXP 110
48399: PPUSH
48400: LD_VAR 0 3
48404: PPUSH
48405: LD_VAR 0 7
48409: PPUSH
48410: CALL_OW 1
48414: ST_TO_ADDR
// end else
48415: GO 48434
// MC_InsertProduceList ( i , [ components ] ) ;
48417: LD_VAR 0 3
48421: PPUSH
48422: LD_VAR 0 9
48426: PUSH
48427: EMPTY
48428: LIST
48429: PPUSH
48430: CALL 44403 0 2
// break ;
48434: GO 48438
// end ; end ;
48436: GO 48223
48438: POP
48439: POP
// end ; end ; if GetType ( un ) = unit_building then
48440: LD_VAR 0 1
48444: PPUSH
48445: CALL_OW 247
48449: PUSH
48450: LD_INT 3
48452: EQUAL
48453: IFFALSE 48856
// begin btype := GetBType ( un ) ;
48455: LD_ADDR_VAR 0 5
48459: PUSH
48460: LD_VAR 0 1
48464: PPUSH
48465: CALL_OW 266
48469: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48470: LD_VAR 0 5
48474: PUSH
48475: LD_INT 29
48477: PUSH
48478: LD_INT 30
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: IN
48485: IFFALSE 48558
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48487: LD_VAR 0 1
48491: PPUSH
48492: CALL_OW 250
48496: PPUSH
48497: LD_VAR 0 1
48501: PPUSH
48502: CALL_OW 251
48506: PPUSH
48507: LD_VAR 0 1
48511: PPUSH
48512: CALL_OW 255
48516: PPUSH
48517: CALL_OW 440
48521: NOT
48522: IFFALSE 48558
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48524: LD_VAR 0 1
48528: PPUSH
48529: CALL_OW 250
48533: PPUSH
48534: LD_VAR 0 1
48538: PPUSH
48539: CALL_OW 251
48543: PPUSH
48544: LD_VAR 0 1
48548: PPUSH
48549: CALL_OW 255
48553: PPUSH
48554: CALL_OW 441
// end ; if btype = b_warehouse then
48558: LD_VAR 0 5
48562: PUSH
48563: LD_INT 1
48565: EQUAL
48566: IFFALSE 48584
// begin btype := b_depot ;
48568: LD_ADDR_VAR 0 5
48572: PUSH
48573: LD_INT 0
48575: ST_TO_ADDR
// pos := 1 ;
48576: LD_ADDR_VAR 0 6
48580: PUSH
48581: LD_INT 1
48583: ST_TO_ADDR
// end ; if btype = b_factory then
48584: LD_VAR 0 5
48588: PUSH
48589: LD_INT 3
48591: EQUAL
48592: IFFALSE 48610
// begin btype := b_workshop ;
48594: LD_ADDR_VAR 0 5
48598: PUSH
48599: LD_INT 2
48601: ST_TO_ADDR
// pos := 1 ;
48602: LD_ADDR_VAR 0 6
48606: PUSH
48607: LD_INT 1
48609: ST_TO_ADDR
// end ; if btype = b_barracks then
48610: LD_VAR 0 5
48614: PUSH
48615: LD_INT 5
48617: EQUAL
48618: IFFALSE 48628
// btype := b_armoury ;
48620: LD_ADDR_VAR 0 5
48624: PUSH
48625: LD_INT 4
48627: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48628: LD_VAR 0 5
48632: PUSH
48633: LD_INT 7
48635: PUSH
48636: LD_INT 8
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: IN
48643: IFFALSE 48653
// btype := b_lab ;
48645: LD_ADDR_VAR 0 5
48649: PUSH
48650: LD_INT 6
48652: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48653: LD_ADDR_EXP 94
48657: PUSH
48658: LD_EXP 94
48662: PPUSH
48663: LD_VAR 0 3
48667: PUSH
48668: LD_EXP 94
48672: PUSH
48673: LD_VAR 0 3
48677: ARRAY
48678: PUSH
48679: LD_INT 1
48681: PLUS
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: PPUSH
48687: LD_VAR 0 5
48691: PUSH
48692: LD_VAR 0 1
48696: PPUSH
48697: CALL_OW 250
48701: PUSH
48702: LD_VAR 0 1
48706: PPUSH
48707: CALL_OW 251
48711: PUSH
48712: LD_VAR 0 1
48716: PPUSH
48717: CALL_OW 254
48721: PUSH
48722: EMPTY
48723: LIST
48724: LIST
48725: LIST
48726: LIST
48727: PPUSH
48728: CALL 55693 0 3
48732: ST_TO_ADDR
// if pos = 1 then
48733: LD_VAR 0 6
48737: PUSH
48738: LD_INT 1
48740: EQUAL
48741: IFFALSE 48856
// begin tmp := mc_build_list [ i ] ;
48743: LD_ADDR_VAR 0 7
48747: PUSH
48748: LD_EXP 94
48752: PUSH
48753: LD_VAR 0 3
48757: ARRAY
48758: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48759: LD_VAR 0 7
48763: PPUSH
48764: LD_INT 2
48766: PUSH
48767: LD_INT 30
48769: PUSH
48770: LD_INT 0
48772: PUSH
48773: EMPTY
48774: LIST
48775: LIST
48776: PUSH
48777: LD_INT 30
48779: PUSH
48780: LD_INT 1
48782: PUSH
48783: EMPTY
48784: LIST
48785: LIST
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: LIST
48791: PPUSH
48792: CALL_OW 72
48796: IFFALSE 48806
// pos := 2 ;
48798: LD_ADDR_VAR 0 6
48802: PUSH
48803: LD_INT 2
48805: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48806: LD_ADDR_VAR 0 7
48810: PUSH
48811: LD_VAR 0 7
48815: PPUSH
48816: LD_VAR 0 6
48820: PPUSH
48821: LD_VAR 0 7
48825: PPUSH
48826: CALL 56019 0 3
48830: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48831: LD_ADDR_EXP 94
48835: PUSH
48836: LD_EXP 94
48840: PPUSH
48841: LD_VAR 0 3
48845: PPUSH
48846: LD_VAR 0 7
48850: PPUSH
48851: CALL_OW 1
48855: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48856: LD_VAR 0 1
48860: PUSH
48861: LD_EXP 89
48865: PUSH
48866: LD_VAR 0 3
48870: ARRAY
48871: IN
48872: IFFALSE 48911
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48874: LD_ADDR_EXP 89
48878: PUSH
48879: LD_EXP 89
48883: PPUSH
48884: LD_VAR 0 3
48888: PPUSH
48889: LD_EXP 89
48893: PUSH
48894: LD_VAR 0 3
48898: ARRAY
48899: PUSH
48900: LD_VAR 0 1
48904: DIFF
48905: PPUSH
48906: CALL_OW 1
48910: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48911: LD_VAR 0 1
48915: PUSH
48916: LD_EXP 96
48920: PUSH
48921: LD_VAR 0 3
48925: ARRAY
48926: IN
48927: IFFALSE 48966
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48929: LD_ADDR_EXP 96
48933: PUSH
48934: LD_EXP 96
48938: PPUSH
48939: LD_VAR 0 3
48943: PPUSH
48944: LD_EXP 96
48948: PUSH
48949: LD_VAR 0 3
48953: ARRAY
48954: PUSH
48955: LD_VAR 0 1
48959: DIFF
48960: PPUSH
48961: CALL_OW 1
48965: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48966: LD_VAR 0 1
48970: PUSH
48971: LD_EXP 108
48975: PUSH
48976: LD_VAR 0 3
48980: ARRAY
48981: IN
48982: IFFALSE 49021
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48984: LD_ADDR_EXP 108
48988: PUSH
48989: LD_EXP 108
48993: PPUSH
48994: LD_VAR 0 3
48998: PPUSH
48999: LD_EXP 108
49003: PUSH
49004: LD_VAR 0 3
49008: ARRAY
49009: PUSH
49010: LD_VAR 0 1
49014: DIFF
49015: PPUSH
49016: CALL_OW 1
49020: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49021: LD_VAR 0 1
49025: PUSH
49026: LD_EXP 111
49030: PUSH
49031: LD_VAR 0 3
49035: ARRAY
49036: IN
49037: IFFALSE 49076
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49039: LD_ADDR_EXP 111
49043: PUSH
49044: LD_EXP 111
49048: PPUSH
49049: LD_VAR 0 3
49053: PPUSH
49054: LD_EXP 111
49058: PUSH
49059: LD_VAR 0 3
49063: ARRAY
49064: PUSH
49065: LD_VAR 0 1
49069: DIFF
49070: PPUSH
49071: CALL_OW 1
49075: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49076: LD_VAR 0 1
49080: PUSH
49081: LD_EXP 98
49085: PUSH
49086: LD_VAR 0 3
49090: ARRAY
49091: IN
49092: IFFALSE 49131
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49094: LD_ADDR_EXP 98
49098: PUSH
49099: LD_EXP 98
49103: PPUSH
49104: LD_VAR 0 3
49108: PPUSH
49109: LD_EXP 98
49113: PUSH
49114: LD_VAR 0 3
49118: ARRAY
49119: PUSH
49120: LD_VAR 0 1
49124: DIFF
49125: PPUSH
49126: CALL_OW 1
49130: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49131: LD_VAR 0 1
49135: PUSH
49136: LD_EXP 97
49140: PUSH
49141: LD_VAR 0 3
49145: ARRAY
49146: IN
49147: IFFALSE 49186
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49149: LD_ADDR_EXP 97
49153: PUSH
49154: LD_EXP 97
49158: PPUSH
49159: LD_VAR 0 3
49163: PPUSH
49164: LD_EXP 97
49168: PUSH
49169: LD_VAR 0 3
49173: ARRAY
49174: PUSH
49175: LD_VAR 0 1
49179: DIFF
49180: PPUSH
49181: CALL_OW 1
49185: ST_TO_ADDR
// end ; break ;
49186: GO 49190
// end ;
49188: GO 47836
49190: POP
49191: POP
// end ;
49192: LD_VAR 0 2
49196: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49197: LD_INT 0
49199: PPUSH
49200: PPUSH
49201: PPUSH
// if not mc_bases or not skirmish then
49202: LD_EXP 89
49206: NOT
49207: PUSH
49208: LD_EXP 87
49212: NOT
49213: OR
49214: IFFALSE 49218
// exit ;
49216: GO 49433
// for i = 1 to mc_bases do
49218: LD_ADDR_VAR 0 3
49222: PUSH
49223: DOUBLE
49224: LD_INT 1
49226: DEC
49227: ST_TO_ADDR
49228: LD_EXP 89
49232: PUSH
49233: FOR_TO
49234: IFFALSE 49431
// begin if building in mc_construct_list [ i ] then
49236: LD_VAR 0 1
49240: PUSH
49241: LD_EXP 96
49245: PUSH
49246: LD_VAR 0 3
49250: ARRAY
49251: IN
49252: IFFALSE 49429
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49254: LD_ADDR_EXP 96
49258: PUSH
49259: LD_EXP 96
49263: PPUSH
49264: LD_VAR 0 3
49268: PPUSH
49269: LD_EXP 96
49273: PUSH
49274: LD_VAR 0 3
49278: ARRAY
49279: PUSH
49280: LD_VAR 0 1
49284: DIFF
49285: PPUSH
49286: CALL_OW 1
49290: ST_TO_ADDR
// if building in mc_lab [ i ] then
49291: LD_VAR 0 1
49295: PUSH
49296: LD_EXP 122
49300: PUSH
49301: LD_VAR 0 3
49305: ARRAY
49306: IN
49307: IFFALSE 49362
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49309: LD_ADDR_EXP 123
49313: PUSH
49314: LD_EXP 123
49318: PPUSH
49319: LD_VAR 0 3
49323: PPUSH
49324: LD_EXP 123
49328: PUSH
49329: LD_VAR 0 3
49333: ARRAY
49334: PPUSH
49335: LD_INT 1
49337: PPUSH
49338: LD_EXP 123
49342: PUSH
49343: LD_VAR 0 3
49347: ARRAY
49348: PPUSH
49349: LD_INT 0
49351: PPUSH
49352: CALL 55111 0 4
49356: PPUSH
49357: CALL_OW 1
49361: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49362: LD_VAR 0 1
49366: PUSH
49367: LD_EXP 89
49371: PUSH
49372: LD_VAR 0 3
49376: ARRAY
49377: IN
49378: NOT
49379: IFFALSE 49425
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49381: LD_ADDR_EXP 89
49385: PUSH
49386: LD_EXP 89
49390: PPUSH
49391: LD_VAR 0 3
49395: PUSH
49396: LD_EXP 89
49400: PUSH
49401: LD_VAR 0 3
49405: ARRAY
49406: PUSH
49407: LD_INT 1
49409: PLUS
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: PPUSH
49415: LD_VAR 0 1
49419: PPUSH
49420: CALL 55693 0 3
49424: ST_TO_ADDR
// exit ;
49425: POP
49426: POP
49427: GO 49433
// end ; end ;
49429: GO 49233
49431: POP
49432: POP
// end ;
49433: LD_VAR 0 2
49437: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49438: LD_INT 0
49440: PPUSH
49441: PPUSH
49442: PPUSH
49443: PPUSH
49444: PPUSH
49445: PPUSH
49446: PPUSH
// if not mc_bases or not skirmish then
49447: LD_EXP 89
49451: NOT
49452: PUSH
49453: LD_EXP 87
49457: NOT
49458: OR
49459: IFFALSE 49463
// exit ;
49461: GO 50124
// for i = 1 to mc_bases do
49463: LD_ADDR_VAR 0 3
49467: PUSH
49468: DOUBLE
49469: LD_INT 1
49471: DEC
49472: ST_TO_ADDR
49473: LD_EXP 89
49477: PUSH
49478: FOR_TO
49479: IFFALSE 50122
// begin if building in mc_construct_list [ i ] then
49481: LD_VAR 0 1
49485: PUSH
49486: LD_EXP 96
49490: PUSH
49491: LD_VAR 0 3
49495: ARRAY
49496: IN
49497: IFFALSE 50120
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49499: LD_ADDR_EXP 96
49503: PUSH
49504: LD_EXP 96
49508: PPUSH
49509: LD_VAR 0 3
49513: PPUSH
49514: LD_EXP 96
49518: PUSH
49519: LD_VAR 0 3
49523: ARRAY
49524: PUSH
49525: LD_VAR 0 1
49529: DIFF
49530: PPUSH
49531: CALL_OW 1
49535: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49536: LD_ADDR_EXP 89
49540: PUSH
49541: LD_EXP 89
49545: PPUSH
49546: LD_VAR 0 3
49550: PUSH
49551: LD_EXP 89
49555: PUSH
49556: LD_VAR 0 3
49560: ARRAY
49561: PUSH
49562: LD_INT 1
49564: PLUS
49565: PUSH
49566: EMPTY
49567: LIST
49568: LIST
49569: PPUSH
49570: LD_VAR 0 1
49574: PPUSH
49575: CALL 55693 0 3
49579: ST_TO_ADDR
// btype := GetBType ( building ) ;
49580: LD_ADDR_VAR 0 5
49584: PUSH
49585: LD_VAR 0 1
49589: PPUSH
49590: CALL_OW 266
49594: ST_TO_ADDR
// side := GetSide ( building ) ;
49595: LD_ADDR_VAR 0 8
49599: PUSH
49600: LD_VAR 0 1
49604: PPUSH
49605: CALL_OW 255
49609: ST_TO_ADDR
// if btype = b_lab then
49610: LD_VAR 0 5
49614: PUSH
49615: LD_INT 6
49617: EQUAL
49618: IFFALSE 49668
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49620: LD_ADDR_EXP 122
49624: PUSH
49625: LD_EXP 122
49629: PPUSH
49630: LD_VAR 0 3
49634: PUSH
49635: LD_EXP 122
49639: PUSH
49640: LD_VAR 0 3
49644: ARRAY
49645: PUSH
49646: LD_INT 1
49648: PLUS
49649: PUSH
49650: EMPTY
49651: LIST
49652: LIST
49653: PPUSH
49654: LD_VAR 0 1
49658: PPUSH
49659: CALL 55693 0 3
49663: ST_TO_ADDR
// exit ;
49664: POP
49665: POP
49666: GO 50124
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49668: LD_VAR 0 5
49672: PUSH
49673: LD_INT 0
49675: PUSH
49676: LD_INT 2
49678: PUSH
49679: LD_INT 4
49681: PUSH
49682: EMPTY
49683: LIST
49684: LIST
49685: LIST
49686: IN
49687: IFFALSE 49811
// begin if btype = b_armoury then
49689: LD_VAR 0 5
49693: PUSH
49694: LD_INT 4
49696: EQUAL
49697: IFFALSE 49707
// btype := b_barracks ;
49699: LD_ADDR_VAR 0 5
49703: PUSH
49704: LD_INT 5
49706: ST_TO_ADDR
// if btype = b_depot then
49707: LD_VAR 0 5
49711: PUSH
49712: LD_INT 0
49714: EQUAL
49715: IFFALSE 49725
// btype := b_warehouse ;
49717: LD_ADDR_VAR 0 5
49721: PUSH
49722: LD_INT 1
49724: ST_TO_ADDR
// if btype = b_workshop then
49725: LD_VAR 0 5
49729: PUSH
49730: LD_INT 2
49732: EQUAL
49733: IFFALSE 49743
// btype := b_factory ;
49735: LD_ADDR_VAR 0 5
49739: PUSH
49740: LD_INT 3
49742: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49743: LD_VAR 0 5
49747: PPUSH
49748: LD_VAR 0 8
49752: PPUSH
49753: CALL_OW 323
49757: PUSH
49758: LD_INT 1
49760: EQUAL
49761: IFFALSE 49807
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49763: LD_ADDR_EXP 121
49767: PUSH
49768: LD_EXP 121
49772: PPUSH
49773: LD_VAR 0 3
49777: PUSH
49778: LD_EXP 121
49782: PUSH
49783: LD_VAR 0 3
49787: ARRAY
49788: PUSH
49789: LD_INT 1
49791: PLUS
49792: PUSH
49793: EMPTY
49794: LIST
49795: LIST
49796: PPUSH
49797: LD_VAR 0 1
49801: PPUSH
49802: CALL 55693 0 3
49806: ST_TO_ADDR
// exit ;
49807: POP
49808: POP
49809: GO 50124
// end ; if btype in [ b_bunker , b_turret ] then
49811: LD_VAR 0 5
49815: PUSH
49816: LD_INT 32
49818: PUSH
49819: LD_INT 33
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: IN
49826: IFFALSE 50116
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49828: LD_ADDR_EXP 97
49832: PUSH
49833: LD_EXP 97
49837: PPUSH
49838: LD_VAR 0 3
49842: PUSH
49843: LD_EXP 97
49847: PUSH
49848: LD_VAR 0 3
49852: ARRAY
49853: PUSH
49854: LD_INT 1
49856: PLUS
49857: PUSH
49858: EMPTY
49859: LIST
49860: LIST
49861: PPUSH
49862: LD_VAR 0 1
49866: PPUSH
49867: CALL 55693 0 3
49871: ST_TO_ADDR
// if btype = b_bunker then
49872: LD_VAR 0 5
49876: PUSH
49877: LD_INT 32
49879: EQUAL
49880: IFFALSE 50116
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49882: LD_ADDR_EXP 98
49886: PUSH
49887: LD_EXP 98
49891: PPUSH
49892: LD_VAR 0 3
49896: PUSH
49897: LD_EXP 98
49901: PUSH
49902: LD_VAR 0 3
49906: ARRAY
49907: PUSH
49908: LD_INT 1
49910: PLUS
49911: PUSH
49912: EMPTY
49913: LIST
49914: LIST
49915: PPUSH
49916: LD_VAR 0 1
49920: PPUSH
49921: CALL 55693 0 3
49925: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49926: LD_ADDR_VAR 0 6
49930: PUSH
49931: LD_EXP 89
49935: PUSH
49936: LD_VAR 0 3
49940: ARRAY
49941: PPUSH
49942: LD_INT 25
49944: PUSH
49945: LD_INT 1
49947: PUSH
49948: EMPTY
49949: LIST
49950: LIST
49951: PUSH
49952: LD_INT 3
49954: PUSH
49955: LD_INT 54
49957: PUSH
49958: EMPTY
49959: LIST
49960: PUSH
49961: EMPTY
49962: LIST
49963: LIST
49964: PUSH
49965: EMPTY
49966: LIST
49967: LIST
49968: PPUSH
49969: CALL_OW 72
49973: ST_TO_ADDR
// if tmp then
49974: LD_VAR 0 6
49978: IFFALSE 49984
// exit ;
49980: POP
49981: POP
49982: GO 50124
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49984: LD_ADDR_VAR 0 6
49988: PUSH
49989: LD_EXP 89
49993: PUSH
49994: LD_VAR 0 3
49998: ARRAY
49999: PPUSH
50000: LD_INT 2
50002: PUSH
50003: LD_INT 30
50005: PUSH
50006: LD_INT 4
50008: PUSH
50009: EMPTY
50010: LIST
50011: LIST
50012: PUSH
50013: LD_INT 30
50015: PUSH
50016: LD_INT 5
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: PUSH
50023: EMPTY
50024: LIST
50025: LIST
50026: LIST
50027: PPUSH
50028: CALL_OW 72
50032: ST_TO_ADDR
// if not tmp then
50033: LD_VAR 0 6
50037: NOT
50038: IFFALSE 50044
// exit ;
50040: POP
50041: POP
50042: GO 50124
// for j in tmp do
50044: LD_ADDR_VAR 0 4
50048: PUSH
50049: LD_VAR 0 6
50053: PUSH
50054: FOR_IN
50055: IFFALSE 50114
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50057: LD_ADDR_VAR 0 7
50061: PUSH
50062: LD_VAR 0 4
50066: PPUSH
50067: CALL_OW 313
50071: PPUSH
50072: LD_INT 25
50074: PUSH
50075: LD_INT 1
50077: PUSH
50078: EMPTY
50079: LIST
50080: LIST
50081: PPUSH
50082: CALL_OW 72
50086: ST_TO_ADDR
// if units then
50087: LD_VAR 0 7
50091: IFFALSE 50112
// begin ComExitBuilding ( units [ 1 ] ) ;
50093: LD_VAR 0 7
50097: PUSH
50098: LD_INT 1
50100: ARRAY
50101: PPUSH
50102: CALL_OW 122
// exit ;
50106: POP
50107: POP
50108: POP
50109: POP
50110: GO 50124
// end ; end ;
50112: GO 50054
50114: POP
50115: POP
// end ; end ; exit ;
50116: POP
50117: POP
50118: GO 50124
// end ; end ;
50120: GO 49478
50122: POP
50123: POP
// end ;
50124: LD_VAR 0 2
50128: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50129: LD_INT 0
50131: PPUSH
50132: PPUSH
50133: PPUSH
50134: PPUSH
50135: PPUSH
50136: PPUSH
50137: PPUSH
// if not mc_bases or not skirmish then
50138: LD_EXP 89
50142: NOT
50143: PUSH
50144: LD_EXP 87
50148: NOT
50149: OR
50150: IFFALSE 50154
// exit ;
50152: GO 50385
// btype := GetBType ( building ) ;
50154: LD_ADDR_VAR 0 6
50158: PUSH
50159: LD_VAR 0 1
50163: PPUSH
50164: CALL_OW 266
50168: ST_TO_ADDR
// x := GetX ( building ) ;
50169: LD_ADDR_VAR 0 7
50173: PUSH
50174: LD_VAR 0 1
50178: PPUSH
50179: CALL_OW 250
50183: ST_TO_ADDR
// y := GetY ( building ) ;
50184: LD_ADDR_VAR 0 8
50188: PUSH
50189: LD_VAR 0 1
50193: PPUSH
50194: CALL_OW 251
50198: ST_TO_ADDR
// d := GetDir ( building ) ;
50199: LD_ADDR_VAR 0 9
50203: PUSH
50204: LD_VAR 0 1
50208: PPUSH
50209: CALL_OW 254
50213: ST_TO_ADDR
// for i = 1 to mc_bases do
50214: LD_ADDR_VAR 0 4
50218: PUSH
50219: DOUBLE
50220: LD_INT 1
50222: DEC
50223: ST_TO_ADDR
50224: LD_EXP 89
50228: PUSH
50229: FOR_TO
50230: IFFALSE 50383
// begin if not mc_build_list [ i ] then
50232: LD_EXP 94
50236: PUSH
50237: LD_VAR 0 4
50241: ARRAY
50242: NOT
50243: IFFALSE 50247
// continue ;
50245: GO 50229
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50247: LD_VAR 0 6
50251: PUSH
50252: LD_VAR 0 7
50256: PUSH
50257: LD_VAR 0 8
50261: PUSH
50262: LD_VAR 0 9
50266: PUSH
50267: EMPTY
50268: LIST
50269: LIST
50270: LIST
50271: LIST
50272: PPUSH
50273: LD_EXP 94
50277: PUSH
50278: LD_VAR 0 4
50282: ARRAY
50283: PUSH
50284: LD_INT 1
50286: ARRAY
50287: PPUSH
50288: CALL 61862 0 2
50292: IFFALSE 50381
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50294: LD_ADDR_EXP 94
50298: PUSH
50299: LD_EXP 94
50303: PPUSH
50304: LD_VAR 0 4
50308: PPUSH
50309: LD_EXP 94
50313: PUSH
50314: LD_VAR 0 4
50318: ARRAY
50319: PPUSH
50320: LD_INT 1
50322: PPUSH
50323: CALL_OW 3
50327: PPUSH
50328: CALL_OW 1
50332: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50333: LD_ADDR_EXP 96
50337: PUSH
50338: LD_EXP 96
50342: PPUSH
50343: LD_VAR 0 4
50347: PUSH
50348: LD_EXP 96
50352: PUSH
50353: LD_VAR 0 4
50357: ARRAY
50358: PUSH
50359: LD_INT 1
50361: PLUS
50362: PUSH
50363: EMPTY
50364: LIST
50365: LIST
50366: PPUSH
50367: LD_VAR 0 1
50371: PPUSH
50372: CALL 55693 0 3
50376: ST_TO_ADDR
// exit ;
50377: POP
50378: POP
50379: GO 50385
// end ; end ;
50381: GO 50229
50383: POP
50384: POP
// end ;
50385: LD_VAR 0 3
50389: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50390: LD_INT 0
50392: PPUSH
50393: PPUSH
50394: PPUSH
// if not mc_bases or not skirmish then
50395: LD_EXP 89
50399: NOT
50400: PUSH
50401: LD_EXP 87
50405: NOT
50406: OR
50407: IFFALSE 50411
// exit ;
50409: GO 50601
// for i = 1 to mc_bases do
50411: LD_ADDR_VAR 0 4
50415: PUSH
50416: DOUBLE
50417: LD_INT 1
50419: DEC
50420: ST_TO_ADDR
50421: LD_EXP 89
50425: PUSH
50426: FOR_TO
50427: IFFALSE 50514
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50429: LD_VAR 0 1
50433: PUSH
50434: LD_EXP 97
50438: PUSH
50439: LD_VAR 0 4
50443: ARRAY
50444: IN
50445: PUSH
50446: LD_VAR 0 1
50450: PUSH
50451: LD_EXP 98
50455: PUSH
50456: LD_VAR 0 4
50460: ARRAY
50461: IN
50462: NOT
50463: AND
50464: IFFALSE 50512
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50466: LD_ADDR_EXP 98
50470: PUSH
50471: LD_EXP 98
50475: PPUSH
50476: LD_VAR 0 4
50480: PUSH
50481: LD_EXP 98
50485: PUSH
50486: LD_VAR 0 4
50490: ARRAY
50491: PUSH
50492: LD_INT 1
50494: PLUS
50495: PUSH
50496: EMPTY
50497: LIST
50498: LIST
50499: PPUSH
50500: LD_VAR 0 1
50504: PPUSH
50505: CALL 55693 0 3
50509: ST_TO_ADDR
// break ;
50510: GO 50514
// end ; end ;
50512: GO 50426
50514: POP
50515: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50516: LD_VAR 0 1
50520: PPUSH
50521: CALL_OW 257
50525: PUSH
50526: LD_EXP 115
50530: IN
50531: PUSH
50532: LD_VAR 0 1
50536: PPUSH
50537: CALL_OW 266
50541: PUSH
50542: LD_INT 5
50544: EQUAL
50545: AND
50546: PUSH
50547: LD_VAR 0 2
50551: PPUSH
50552: CALL_OW 110
50556: PUSH
50557: LD_INT 18
50559: NONEQUAL
50560: AND
50561: IFFALSE 50601
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50563: LD_VAR 0 2
50567: PPUSH
50568: CALL_OW 257
50572: PUSH
50573: LD_INT 5
50575: PUSH
50576: LD_INT 8
50578: PUSH
50579: LD_INT 9
50581: PUSH
50582: EMPTY
50583: LIST
50584: LIST
50585: LIST
50586: IN
50587: IFFALSE 50601
// SetClass ( unit , 1 ) ;
50589: LD_VAR 0 2
50593: PPUSH
50594: LD_INT 1
50596: PPUSH
50597: CALL_OW 336
// end ;
50601: LD_VAR 0 3
50605: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50606: LD_INT 0
50608: PPUSH
50609: PPUSH
// if not mc_bases or not skirmish then
50610: LD_EXP 89
50614: NOT
50615: PUSH
50616: LD_EXP 87
50620: NOT
50621: OR
50622: IFFALSE 50626
// exit ;
50624: GO 50742
// if GetLives ( abandoned_vehicle ) > 250 then
50626: LD_VAR 0 2
50630: PPUSH
50631: CALL_OW 256
50635: PUSH
50636: LD_INT 250
50638: GREATER
50639: IFFALSE 50643
// exit ;
50641: GO 50742
// for i = 1 to mc_bases do
50643: LD_ADDR_VAR 0 6
50647: PUSH
50648: DOUBLE
50649: LD_INT 1
50651: DEC
50652: ST_TO_ADDR
50653: LD_EXP 89
50657: PUSH
50658: FOR_TO
50659: IFFALSE 50740
// begin if driver in mc_bases [ i ] then
50661: LD_VAR 0 1
50665: PUSH
50666: LD_EXP 89
50670: PUSH
50671: LD_VAR 0 6
50675: ARRAY
50676: IN
50677: IFFALSE 50738
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50679: LD_VAR 0 1
50683: PPUSH
50684: LD_EXP 89
50688: PUSH
50689: LD_VAR 0 6
50693: ARRAY
50694: PPUSH
50695: LD_INT 2
50697: PUSH
50698: LD_INT 30
50700: PUSH
50701: LD_INT 0
50703: PUSH
50704: EMPTY
50705: LIST
50706: LIST
50707: PUSH
50708: LD_INT 30
50710: PUSH
50711: LD_INT 1
50713: PUSH
50714: EMPTY
50715: LIST
50716: LIST
50717: PUSH
50718: EMPTY
50719: LIST
50720: LIST
50721: LIST
50722: PPUSH
50723: CALL_OW 72
50727: PUSH
50728: LD_INT 1
50730: ARRAY
50731: PPUSH
50732: CALL_OW 112
// break ;
50736: GO 50740
// end ; end ;
50738: GO 50658
50740: POP
50741: POP
// end ; end_of_file
50742: LD_VAR 0 5
50746: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50747: LD_INT 0
50749: PPUSH
50750: PPUSH
// if exist_mode then
50751: LD_VAR 0 2
50755: IFFALSE 50780
// unit := CreateCharacter ( prefix & ident ) else
50757: LD_ADDR_VAR 0 5
50761: PUSH
50762: LD_VAR 0 3
50766: PUSH
50767: LD_VAR 0 1
50771: STR
50772: PPUSH
50773: CALL_OW 34
50777: ST_TO_ADDR
50778: GO 50795
// unit := NewCharacter ( ident ) ;
50780: LD_ADDR_VAR 0 5
50784: PUSH
50785: LD_VAR 0 1
50789: PPUSH
50790: CALL_OW 25
50794: ST_TO_ADDR
// result := unit ;
50795: LD_ADDR_VAR 0 4
50799: PUSH
50800: LD_VAR 0 5
50804: ST_TO_ADDR
// end ;
50805: LD_VAR 0 4
50809: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50810: LD_INT 0
50812: PPUSH
50813: PPUSH
// if not side or not nation then
50814: LD_VAR 0 1
50818: NOT
50819: PUSH
50820: LD_VAR 0 2
50824: NOT
50825: OR
50826: IFFALSE 50830
// exit ;
50828: GO 51594
// case nation of nation_american :
50830: LD_VAR 0 2
50834: PUSH
50835: LD_INT 1
50837: DOUBLE
50838: EQUAL
50839: IFTRUE 50843
50841: GO 51057
50843: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
50844: LD_ADDR_VAR 0 4
50848: PUSH
50849: LD_INT 35
50851: PUSH
50852: LD_INT 45
50854: PUSH
50855: LD_INT 46
50857: PUSH
50858: LD_INT 47
50860: PUSH
50861: LD_INT 82
50863: PUSH
50864: LD_INT 83
50866: PUSH
50867: LD_INT 84
50869: PUSH
50870: LD_INT 85
50872: PUSH
50873: LD_INT 86
50875: PUSH
50876: LD_INT 1
50878: PUSH
50879: LD_INT 2
50881: PUSH
50882: LD_INT 6
50884: PUSH
50885: LD_INT 15
50887: PUSH
50888: LD_INT 16
50890: PUSH
50891: LD_INT 7
50893: PUSH
50894: LD_INT 12
50896: PUSH
50897: LD_INT 13
50899: PUSH
50900: LD_INT 10
50902: PUSH
50903: LD_INT 14
50905: PUSH
50906: LD_INT 20
50908: PUSH
50909: LD_INT 21
50911: PUSH
50912: LD_INT 22
50914: PUSH
50915: LD_INT 25
50917: PUSH
50918: LD_INT 32
50920: PUSH
50921: LD_INT 27
50923: PUSH
50924: LD_INT 36
50926: PUSH
50927: LD_INT 69
50929: PUSH
50930: LD_INT 39
50932: PUSH
50933: LD_INT 34
50935: PUSH
50936: LD_INT 40
50938: PUSH
50939: LD_INT 48
50941: PUSH
50942: LD_INT 49
50944: PUSH
50945: LD_INT 50
50947: PUSH
50948: LD_INT 51
50950: PUSH
50951: LD_INT 52
50953: PUSH
50954: LD_INT 53
50956: PUSH
50957: LD_INT 54
50959: PUSH
50960: LD_INT 55
50962: PUSH
50963: LD_INT 56
50965: PUSH
50966: LD_INT 57
50968: PUSH
50969: LD_INT 58
50971: PUSH
50972: LD_INT 59
50974: PUSH
50975: LD_INT 60
50977: PUSH
50978: LD_INT 61
50980: PUSH
50981: LD_INT 62
50983: PUSH
50984: LD_INT 80
50986: PUSH
50987: LD_INT 82
50989: PUSH
50990: LD_INT 83
50992: PUSH
50993: LD_INT 84
50995: PUSH
50996: LD_INT 85
50998: PUSH
50999: LD_INT 86
51001: PUSH
51002: EMPTY
51003: LIST
51004: LIST
51005: LIST
51006: LIST
51007: LIST
51008: LIST
51009: LIST
51010: LIST
51011: LIST
51012: LIST
51013: LIST
51014: LIST
51015: LIST
51016: LIST
51017: LIST
51018: LIST
51019: LIST
51020: LIST
51021: LIST
51022: LIST
51023: LIST
51024: LIST
51025: LIST
51026: LIST
51027: LIST
51028: LIST
51029: LIST
51030: LIST
51031: LIST
51032: LIST
51033: LIST
51034: LIST
51035: LIST
51036: LIST
51037: LIST
51038: LIST
51039: LIST
51040: LIST
51041: LIST
51042: LIST
51043: LIST
51044: LIST
51045: LIST
51046: LIST
51047: LIST
51048: LIST
51049: LIST
51050: LIST
51051: LIST
51052: LIST
51053: LIST
51054: ST_TO_ADDR
51055: GO 51518
51057: LD_INT 2
51059: DOUBLE
51060: EQUAL
51061: IFTRUE 51065
51063: GO 51287
51065: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
51066: LD_ADDR_VAR 0 4
51070: PUSH
51071: LD_INT 35
51073: PUSH
51074: LD_INT 45
51076: PUSH
51077: LD_INT 46
51079: PUSH
51080: LD_INT 47
51082: PUSH
51083: LD_INT 82
51085: PUSH
51086: LD_INT 83
51088: PUSH
51089: LD_INT 84
51091: PUSH
51092: LD_INT 85
51094: PUSH
51095: LD_INT 87
51097: PUSH
51098: LD_INT 70
51100: PUSH
51101: LD_INT 1
51103: PUSH
51104: LD_INT 11
51106: PUSH
51107: LD_INT 3
51109: PUSH
51110: LD_INT 4
51112: PUSH
51113: LD_INT 5
51115: PUSH
51116: LD_INT 6
51118: PUSH
51119: LD_INT 15
51121: PUSH
51122: LD_INT 18
51124: PUSH
51125: LD_INT 7
51127: PUSH
51128: LD_INT 17
51130: PUSH
51131: LD_INT 8
51133: PUSH
51134: LD_INT 20
51136: PUSH
51137: LD_INT 21
51139: PUSH
51140: LD_INT 22
51142: PUSH
51143: LD_INT 72
51145: PUSH
51146: LD_INT 26
51148: PUSH
51149: LD_INT 69
51151: PUSH
51152: LD_INT 39
51154: PUSH
51155: LD_INT 40
51157: PUSH
51158: LD_INT 41
51160: PUSH
51161: LD_INT 42
51163: PUSH
51164: LD_INT 43
51166: PUSH
51167: LD_INT 48
51169: PUSH
51170: LD_INT 49
51172: PUSH
51173: LD_INT 50
51175: PUSH
51176: LD_INT 51
51178: PUSH
51179: LD_INT 52
51181: PUSH
51182: LD_INT 53
51184: PUSH
51185: LD_INT 54
51187: PUSH
51188: LD_INT 55
51190: PUSH
51191: LD_INT 56
51193: PUSH
51194: LD_INT 60
51196: PUSH
51197: LD_INT 61
51199: PUSH
51200: LD_INT 62
51202: PUSH
51203: LD_INT 66
51205: PUSH
51206: LD_INT 67
51208: PUSH
51209: LD_INT 68
51211: PUSH
51212: LD_INT 81
51214: PUSH
51215: LD_INT 82
51217: PUSH
51218: LD_INT 83
51220: PUSH
51221: LD_INT 84
51223: PUSH
51224: LD_INT 85
51226: PUSH
51227: LD_INT 87
51229: PUSH
51230: EMPTY
51231: LIST
51232: LIST
51233: LIST
51234: LIST
51235: LIST
51236: LIST
51237: LIST
51238: LIST
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: LIST
51246: LIST
51247: LIST
51248: LIST
51249: LIST
51250: LIST
51251: LIST
51252: LIST
51253: LIST
51254: LIST
51255: LIST
51256: LIST
51257: LIST
51258: LIST
51259: LIST
51260: LIST
51261: LIST
51262: LIST
51263: LIST
51264: LIST
51265: LIST
51266: LIST
51267: LIST
51268: LIST
51269: LIST
51270: LIST
51271: LIST
51272: LIST
51273: LIST
51274: LIST
51275: LIST
51276: LIST
51277: LIST
51278: LIST
51279: LIST
51280: LIST
51281: LIST
51282: LIST
51283: LIST
51284: ST_TO_ADDR
51285: GO 51518
51287: LD_INT 3
51289: DOUBLE
51290: EQUAL
51291: IFTRUE 51295
51293: GO 51517
51295: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51296: LD_ADDR_VAR 0 4
51300: PUSH
51301: LD_INT 46
51303: PUSH
51304: LD_INT 47
51306: PUSH
51307: LD_INT 1
51309: PUSH
51310: LD_INT 2
51312: PUSH
51313: LD_INT 82
51315: PUSH
51316: LD_INT 83
51318: PUSH
51319: LD_INT 84
51321: PUSH
51322: LD_INT 85
51324: PUSH
51325: LD_INT 86
51327: PUSH
51328: LD_INT 11
51330: PUSH
51331: LD_INT 9
51333: PUSH
51334: LD_INT 20
51336: PUSH
51337: LD_INT 19
51339: PUSH
51340: LD_INT 21
51342: PUSH
51343: LD_INT 24
51345: PUSH
51346: LD_INT 22
51348: PUSH
51349: LD_INT 25
51351: PUSH
51352: LD_INT 28
51354: PUSH
51355: LD_INT 29
51357: PUSH
51358: LD_INT 30
51360: PUSH
51361: LD_INT 31
51363: PUSH
51364: LD_INT 37
51366: PUSH
51367: LD_INT 38
51369: PUSH
51370: LD_INT 32
51372: PUSH
51373: LD_INT 27
51375: PUSH
51376: LD_INT 33
51378: PUSH
51379: LD_INT 69
51381: PUSH
51382: LD_INT 39
51384: PUSH
51385: LD_INT 34
51387: PUSH
51388: LD_INT 40
51390: PUSH
51391: LD_INT 71
51393: PUSH
51394: LD_INT 23
51396: PUSH
51397: LD_INT 44
51399: PUSH
51400: LD_INT 48
51402: PUSH
51403: LD_INT 49
51405: PUSH
51406: LD_INT 50
51408: PUSH
51409: LD_INT 51
51411: PUSH
51412: LD_INT 52
51414: PUSH
51415: LD_INT 53
51417: PUSH
51418: LD_INT 54
51420: PUSH
51421: LD_INT 55
51423: PUSH
51424: LD_INT 56
51426: PUSH
51427: LD_INT 57
51429: PUSH
51430: LD_INT 58
51432: PUSH
51433: LD_INT 59
51435: PUSH
51436: LD_INT 63
51438: PUSH
51439: LD_INT 64
51441: PUSH
51442: LD_INT 65
51444: PUSH
51445: LD_INT 82
51447: PUSH
51448: LD_INT 83
51450: PUSH
51451: LD_INT 84
51453: PUSH
51454: LD_INT 85
51456: PUSH
51457: LD_INT 86
51459: PUSH
51460: EMPTY
51461: LIST
51462: LIST
51463: LIST
51464: LIST
51465: LIST
51466: LIST
51467: LIST
51468: LIST
51469: LIST
51470: LIST
51471: LIST
51472: LIST
51473: LIST
51474: LIST
51475: LIST
51476: LIST
51477: LIST
51478: LIST
51479: LIST
51480: LIST
51481: LIST
51482: LIST
51483: LIST
51484: LIST
51485: LIST
51486: LIST
51487: LIST
51488: LIST
51489: LIST
51490: LIST
51491: LIST
51492: LIST
51493: LIST
51494: LIST
51495: LIST
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: LIST
51501: LIST
51502: LIST
51503: LIST
51504: LIST
51505: LIST
51506: LIST
51507: LIST
51508: LIST
51509: LIST
51510: LIST
51511: LIST
51512: LIST
51513: LIST
51514: ST_TO_ADDR
51515: GO 51518
51517: POP
// if state > - 1 and state < 3 then
51518: LD_VAR 0 3
51522: PUSH
51523: LD_INT 1
51525: NEG
51526: GREATER
51527: PUSH
51528: LD_VAR 0 3
51532: PUSH
51533: LD_INT 3
51535: LESS
51536: AND
51537: IFFALSE 51594
// for i in result do
51539: LD_ADDR_VAR 0 5
51543: PUSH
51544: LD_VAR 0 4
51548: PUSH
51549: FOR_IN
51550: IFFALSE 51592
// if GetTech ( i , side ) <> state then
51552: LD_VAR 0 5
51556: PPUSH
51557: LD_VAR 0 1
51561: PPUSH
51562: CALL_OW 321
51566: PUSH
51567: LD_VAR 0 3
51571: NONEQUAL
51572: IFFALSE 51590
// result := result diff i ;
51574: LD_ADDR_VAR 0 4
51578: PUSH
51579: LD_VAR 0 4
51583: PUSH
51584: LD_VAR 0 5
51588: DIFF
51589: ST_TO_ADDR
51590: GO 51549
51592: POP
51593: POP
// end ;
51594: LD_VAR 0 4
51598: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51599: LD_INT 0
51601: PPUSH
51602: PPUSH
51603: PPUSH
// result := true ;
51604: LD_ADDR_VAR 0 3
51608: PUSH
51609: LD_INT 1
51611: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51612: LD_ADDR_VAR 0 5
51616: PUSH
51617: LD_VAR 0 2
51621: PPUSH
51622: CALL_OW 480
51626: ST_TO_ADDR
// if not tmp then
51627: LD_VAR 0 5
51631: NOT
51632: IFFALSE 51636
// exit ;
51634: GO 51685
// for i in tmp do
51636: LD_ADDR_VAR 0 4
51640: PUSH
51641: LD_VAR 0 5
51645: PUSH
51646: FOR_IN
51647: IFFALSE 51683
// if GetTech ( i , side ) <> state_researched then
51649: LD_VAR 0 4
51653: PPUSH
51654: LD_VAR 0 1
51658: PPUSH
51659: CALL_OW 321
51663: PUSH
51664: LD_INT 2
51666: NONEQUAL
51667: IFFALSE 51681
// begin result := false ;
51669: LD_ADDR_VAR 0 3
51673: PUSH
51674: LD_INT 0
51676: ST_TO_ADDR
// exit ;
51677: POP
51678: POP
51679: GO 51685
// end ;
51681: GO 51646
51683: POP
51684: POP
// end ;
51685: LD_VAR 0 3
51689: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51690: LD_INT 0
51692: PPUSH
51693: PPUSH
51694: PPUSH
51695: PPUSH
51696: PPUSH
51697: PPUSH
51698: PPUSH
51699: PPUSH
51700: PPUSH
51701: PPUSH
51702: PPUSH
51703: PPUSH
51704: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51705: LD_VAR 0 1
51709: NOT
51710: PUSH
51711: LD_VAR 0 1
51715: PPUSH
51716: CALL_OW 257
51720: PUSH
51721: LD_INT 9
51723: NONEQUAL
51724: OR
51725: IFFALSE 51729
// exit ;
51727: GO 52302
// side := GetSide ( unit ) ;
51729: LD_ADDR_VAR 0 9
51733: PUSH
51734: LD_VAR 0 1
51738: PPUSH
51739: CALL_OW 255
51743: ST_TO_ADDR
// tech_space := tech_spacanom ;
51744: LD_ADDR_VAR 0 12
51748: PUSH
51749: LD_INT 29
51751: ST_TO_ADDR
// tech_time := tech_taurad ;
51752: LD_ADDR_VAR 0 13
51756: PUSH
51757: LD_INT 28
51759: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51760: LD_ADDR_VAR 0 11
51764: PUSH
51765: LD_VAR 0 1
51769: PPUSH
51770: CALL_OW 310
51774: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51775: LD_VAR 0 11
51779: PPUSH
51780: CALL_OW 247
51784: PUSH
51785: LD_INT 2
51787: EQUAL
51788: IFFALSE 51792
// exit ;
51790: GO 52302
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51792: LD_ADDR_VAR 0 8
51796: PUSH
51797: LD_INT 81
51799: PUSH
51800: LD_VAR 0 9
51804: PUSH
51805: EMPTY
51806: LIST
51807: LIST
51808: PUSH
51809: LD_INT 3
51811: PUSH
51812: LD_INT 21
51814: PUSH
51815: LD_INT 3
51817: PUSH
51818: EMPTY
51819: LIST
51820: LIST
51821: PUSH
51822: EMPTY
51823: LIST
51824: LIST
51825: PUSH
51826: EMPTY
51827: LIST
51828: LIST
51829: PPUSH
51830: CALL_OW 69
51834: ST_TO_ADDR
// if not tmp then
51835: LD_VAR 0 8
51839: NOT
51840: IFFALSE 51844
// exit ;
51842: GO 52302
// if in_unit then
51844: LD_VAR 0 11
51848: IFFALSE 51872
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51850: LD_ADDR_VAR 0 10
51854: PUSH
51855: LD_VAR 0 8
51859: PPUSH
51860: LD_VAR 0 11
51864: PPUSH
51865: CALL_OW 74
51869: ST_TO_ADDR
51870: GO 51892
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51872: LD_ADDR_VAR 0 10
51876: PUSH
51877: LD_VAR 0 8
51881: PPUSH
51882: LD_VAR 0 1
51886: PPUSH
51887: CALL_OW 74
51891: ST_TO_ADDR
// if not enemy then
51892: LD_VAR 0 10
51896: NOT
51897: IFFALSE 51901
// exit ;
51899: GO 52302
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51901: LD_VAR 0 11
51905: PUSH
51906: LD_VAR 0 11
51910: PPUSH
51911: LD_VAR 0 10
51915: PPUSH
51916: CALL_OW 296
51920: PUSH
51921: LD_INT 13
51923: GREATER
51924: AND
51925: PUSH
51926: LD_VAR 0 1
51930: PPUSH
51931: LD_VAR 0 10
51935: PPUSH
51936: CALL_OW 296
51940: PUSH
51941: LD_INT 12
51943: GREATER
51944: OR
51945: IFFALSE 51949
// exit ;
51947: GO 52302
// missile := [ 1 ] ;
51949: LD_ADDR_VAR 0 14
51953: PUSH
51954: LD_INT 1
51956: PUSH
51957: EMPTY
51958: LIST
51959: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51960: LD_VAR 0 9
51964: PPUSH
51965: LD_VAR 0 12
51969: PPUSH
51970: CALL_OW 325
51974: IFFALSE 52003
// missile := Insert ( missile , missile + 1 , 2 ) ;
51976: LD_ADDR_VAR 0 14
51980: PUSH
51981: LD_VAR 0 14
51985: PPUSH
51986: LD_VAR 0 14
51990: PUSH
51991: LD_INT 1
51993: PLUS
51994: PPUSH
51995: LD_INT 2
51997: PPUSH
51998: CALL_OW 2
52002: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52003: LD_VAR 0 9
52007: PPUSH
52008: LD_VAR 0 13
52012: PPUSH
52013: CALL_OW 325
52017: PUSH
52018: LD_VAR 0 10
52022: PPUSH
52023: CALL_OW 255
52027: PPUSH
52028: LD_VAR 0 13
52032: PPUSH
52033: CALL_OW 325
52037: NOT
52038: AND
52039: IFFALSE 52068
// missile := Insert ( missile , missile + 1 , 3 ) ;
52041: LD_ADDR_VAR 0 14
52045: PUSH
52046: LD_VAR 0 14
52050: PPUSH
52051: LD_VAR 0 14
52055: PUSH
52056: LD_INT 1
52058: PLUS
52059: PPUSH
52060: LD_INT 3
52062: PPUSH
52063: CALL_OW 2
52067: ST_TO_ADDR
// if missile < 2 then
52068: LD_VAR 0 14
52072: PUSH
52073: LD_INT 2
52075: LESS
52076: IFFALSE 52080
// exit ;
52078: GO 52302
// x := GetX ( enemy ) ;
52080: LD_ADDR_VAR 0 4
52084: PUSH
52085: LD_VAR 0 10
52089: PPUSH
52090: CALL_OW 250
52094: ST_TO_ADDR
// y := GetY ( enemy ) ;
52095: LD_ADDR_VAR 0 5
52099: PUSH
52100: LD_VAR 0 10
52104: PPUSH
52105: CALL_OW 251
52109: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52110: LD_ADDR_VAR 0 6
52114: PUSH
52115: LD_VAR 0 4
52119: PUSH
52120: LD_INT 1
52122: NEG
52123: PPUSH
52124: LD_INT 1
52126: PPUSH
52127: CALL_OW 12
52131: PLUS
52132: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52133: LD_ADDR_VAR 0 7
52137: PUSH
52138: LD_VAR 0 5
52142: PUSH
52143: LD_INT 1
52145: NEG
52146: PPUSH
52147: LD_INT 1
52149: PPUSH
52150: CALL_OW 12
52154: PLUS
52155: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52156: LD_VAR 0 6
52160: PPUSH
52161: LD_VAR 0 7
52165: PPUSH
52166: CALL_OW 488
52170: NOT
52171: IFFALSE 52193
// begin _x := x ;
52173: LD_ADDR_VAR 0 6
52177: PUSH
52178: LD_VAR 0 4
52182: ST_TO_ADDR
// _y := y ;
52183: LD_ADDR_VAR 0 7
52187: PUSH
52188: LD_VAR 0 5
52192: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52193: LD_ADDR_VAR 0 3
52197: PUSH
52198: LD_INT 1
52200: PPUSH
52201: LD_VAR 0 14
52205: PPUSH
52206: CALL_OW 12
52210: ST_TO_ADDR
// case i of 1 :
52211: LD_VAR 0 3
52215: PUSH
52216: LD_INT 1
52218: DOUBLE
52219: EQUAL
52220: IFTRUE 52224
52222: GO 52241
52224: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52225: LD_VAR 0 1
52229: PPUSH
52230: LD_VAR 0 10
52234: PPUSH
52235: CALL_OW 115
52239: GO 52302
52241: LD_INT 2
52243: DOUBLE
52244: EQUAL
52245: IFTRUE 52249
52247: GO 52271
52249: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52250: LD_VAR 0 1
52254: PPUSH
52255: LD_VAR 0 6
52259: PPUSH
52260: LD_VAR 0 7
52264: PPUSH
52265: CALL_OW 153
52269: GO 52302
52271: LD_INT 3
52273: DOUBLE
52274: EQUAL
52275: IFTRUE 52279
52277: GO 52301
52279: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52280: LD_VAR 0 1
52284: PPUSH
52285: LD_VAR 0 6
52289: PPUSH
52290: LD_VAR 0 7
52294: PPUSH
52295: CALL_OW 154
52299: GO 52302
52301: POP
// end ;
52302: LD_VAR 0 2
52306: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52307: LD_INT 0
52309: PPUSH
52310: PPUSH
52311: PPUSH
52312: PPUSH
52313: PPUSH
52314: PPUSH
// if not unit or not building then
52315: LD_VAR 0 1
52319: NOT
52320: PUSH
52321: LD_VAR 0 2
52325: NOT
52326: OR
52327: IFFALSE 52331
// exit ;
52329: GO 52489
// x := GetX ( building ) ;
52331: LD_ADDR_VAR 0 5
52335: PUSH
52336: LD_VAR 0 2
52340: PPUSH
52341: CALL_OW 250
52345: ST_TO_ADDR
// y := GetY ( building ) ;
52346: LD_ADDR_VAR 0 6
52350: PUSH
52351: LD_VAR 0 2
52355: PPUSH
52356: CALL_OW 251
52360: ST_TO_ADDR
// for i = 0 to 5 do
52361: LD_ADDR_VAR 0 4
52365: PUSH
52366: DOUBLE
52367: LD_INT 0
52369: DEC
52370: ST_TO_ADDR
52371: LD_INT 5
52373: PUSH
52374: FOR_TO
52375: IFFALSE 52487
// begin _x := ShiftX ( x , i , 3 ) ;
52377: LD_ADDR_VAR 0 7
52381: PUSH
52382: LD_VAR 0 5
52386: PPUSH
52387: LD_VAR 0 4
52391: PPUSH
52392: LD_INT 3
52394: PPUSH
52395: CALL_OW 272
52399: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52400: LD_ADDR_VAR 0 8
52404: PUSH
52405: LD_VAR 0 6
52409: PPUSH
52410: LD_VAR 0 4
52414: PPUSH
52415: LD_INT 3
52417: PPUSH
52418: CALL_OW 273
52422: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52423: LD_VAR 0 7
52427: PPUSH
52428: LD_VAR 0 8
52432: PPUSH
52433: CALL_OW 488
52437: NOT
52438: IFFALSE 52442
// continue ;
52440: GO 52374
// if HexInfo ( _x , _y ) = 0 then
52442: LD_VAR 0 7
52446: PPUSH
52447: LD_VAR 0 8
52451: PPUSH
52452: CALL_OW 428
52456: PUSH
52457: LD_INT 0
52459: EQUAL
52460: IFFALSE 52485
// begin ComMoveXY ( unit , _x , _y ) ;
52462: LD_VAR 0 1
52466: PPUSH
52467: LD_VAR 0 7
52471: PPUSH
52472: LD_VAR 0 8
52476: PPUSH
52477: CALL_OW 111
// exit ;
52481: POP
52482: POP
52483: GO 52489
// end ; end ;
52485: GO 52374
52487: POP
52488: POP
// end ;
52489: LD_VAR 0 3
52493: RET
// export function ScanBase ( side , base_area ) ; begin
52494: LD_INT 0
52496: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52497: LD_ADDR_VAR 0 3
52501: PUSH
52502: LD_VAR 0 2
52506: PPUSH
52507: LD_INT 81
52509: PUSH
52510: LD_VAR 0 1
52514: PUSH
52515: EMPTY
52516: LIST
52517: LIST
52518: PPUSH
52519: CALL_OW 70
52523: ST_TO_ADDR
// end ;
52524: LD_VAR 0 3
52528: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52529: LD_INT 0
52531: PPUSH
52532: PPUSH
52533: PPUSH
52534: PPUSH
// result := false ;
52535: LD_ADDR_VAR 0 2
52539: PUSH
52540: LD_INT 0
52542: ST_TO_ADDR
// side := GetSide ( unit ) ;
52543: LD_ADDR_VAR 0 3
52547: PUSH
52548: LD_VAR 0 1
52552: PPUSH
52553: CALL_OW 255
52557: ST_TO_ADDR
// nat := GetNation ( unit ) ;
52558: LD_ADDR_VAR 0 4
52562: PUSH
52563: LD_VAR 0 1
52567: PPUSH
52568: CALL_OW 248
52572: ST_TO_ADDR
// case nat of 1 :
52573: LD_VAR 0 4
52577: PUSH
52578: LD_INT 1
52580: DOUBLE
52581: EQUAL
52582: IFTRUE 52586
52584: GO 52597
52586: POP
// tech := tech_lassight ; 2 :
52587: LD_ADDR_VAR 0 5
52591: PUSH
52592: LD_INT 12
52594: ST_TO_ADDR
52595: GO 52636
52597: LD_INT 2
52599: DOUBLE
52600: EQUAL
52601: IFTRUE 52605
52603: GO 52616
52605: POP
// tech := tech_mortar ; 3 :
52606: LD_ADDR_VAR 0 5
52610: PUSH
52611: LD_INT 41
52613: ST_TO_ADDR
52614: GO 52636
52616: LD_INT 3
52618: DOUBLE
52619: EQUAL
52620: IFTRUE 52624
52622: GO 52635
52624: POP
// tech := tech_bazooka ; end ;
52625: LD_ADDR_VAR 0 5
52629: PUSH
52630: LD_INT 44
52632: ST_TO_ADDR
52633: GO 52636
52635: POP
// if Researched ( side , tech ) then
52636: LD_VAR 0 3
52640: PPUSH
52641: LD_VAR 0 5
52645: PPUSH
52646: CALL_OW 325
52650: IFFALSE 52677
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
52652: LD_ADDR_VAR 0 2
52656: PUSH
52657: LD_INT 5
52659: PUSH
52660: LD_INT 8
52662: PUSH
52663: LD_INT 9
52665: PUSH
52666: EMPTY
52667: LIST
52668: LIST
52669: LIST
52670: PUSH
52671: LD_VAR 0 4
52675: ARRAY
52676: ST_TO_ADDR
// end ;
52677: LD_VAR 0 2
52681: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
52682: LD_INT 0
52684: PPUSH
52685: PPUSH
52686: PPUSH
// if not mines then
52687: LD_VAR 0 2
52691: NOT
52692: IFFALSE 52696
// exit ;
52694: GO 52840
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52696: LD_ADDR_VAR 0 5
52700: PUSH
52701: LD_INT 81
52703: PUSH
52704: LD_VAR 0 1
52708: PUSH
52709: EMPTY
52710: LIST
52711: LIST
52712: PUSH
52713: LD_INT 3
52715: PUSH
52716: LD_INT 21
52718: PUSH
52719: LD_INT 3
52721: PUSH
52722: EMPTY
52723: LIST
52724: LIST
52725: PUSH
52726: EMPTY
52727: LIST
52728: LIST
52729: PUSH
52730: EMPTY
52731: LIST
52732: LIST
52733: PPUSH
52734: CALL_OW 69
52738: ST_TO_ADDR
// for i in mines do
52739: LD_ADDR_VAR 0 4
52743: PUSH
52744: LD_VAR 0 2
52748: PUSH
52749: FOR_IN
52750: IFFALSE 52838
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
52752: LD_VAR 0 4
52756: PUSH
52757: LD_INT 1
52759: ARRAY
52760: PPUSH
52761: LD_VAR 0 4
52765: PUSH
52766: LD_INT 2
52768: ARRAY
52769: PPUSH
52770: CALL_OW 458
52774: NOT
52775: IFFALSE 52779
// continue ;
52777: GO 52749
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
52779: LD_VAR 0 4
52783: PUSH
52784: LD_INT 1
52786: ARRAY
52787: PPUSH
52788: LD_VAR 0 4
52792: PUSH
52793: LD_INT 2
52795: ARRAY
52796: PPUSH
52797: CALL_OW 428
52801: PUSH
52802: LD_VAR 0 5
52806: IN
52807: IFFALSE 52836
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
52809: LD_VAR 0 4
52813: PUSH
52814: LD_INT 1
52816: ARRAY
52817: PPUSH
52818: LD_VAR 0 4
52822: PUSH
52823: LD_INT 2
52825: ARRAY
52826: PPUSH
52827: LD_VAR 0 1
52831: PPUSH
52832: CALL_OW 456
// end ;
52836: GO 52749
52838: POP
52839: POP
// end ;
52840: LD_VAR 0 3
52844: RET
// export function Count ( array ) ; var i ; begin
52845: LD_INT 0
52847: PPUSH
52848: PPUSH
// result := 0 ;
52849: LD_ADDR_VAR 0 2
52853: PUSH
52854: LD_INT 0
52856: ST_TO_ADDR
// for i in array do
52857: LD_ADDR_VAR 0 3
52861: PUSH
52862: LD_VAR 0 1
52866: PUSH
52867: FOR_IN
52868: IFFALSE 52892
// if i then
52870: LD_VAR 0 3
52874: IFFALSE 52890
// result := result + 1 ;
52876: LD_ADDR_VAR 0 2
52880: PUSH
52881: LD_VAR 0 2
52885: PUSH
52886: LD_INT 1
52888: PLUS
52889: ST_TO_ADDR
52890: GO 52867
52892: POP
52893: POP
// end ;
52894: LD_VAR 0 2
52898: RET
// export function IsEmpty ( building ) ; begin
52899: LD_INT 0
52901: PPUSH
// if not building then
52902: LD_VAR 0 1
52906: NOT
52907: IFFALSE 52911
// exit ;
52909: GO 52954
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
52911: LD_ADDR_VAR 0 2
52915: PUSH
52916: LD_VAR 0 1
52920: PUSH
52921: LD_INT 22
52923: PUSH
52924: LD_VAR 0 1
52928: PPUSH
52929: CALL_OW 255
52933: PUSH
52934: EMPTY
52935: LIST
52936: LIST
52937: PUSH
52938: LD_INT 58
52940: PUSH
52941: EMPTY
52942: LIST
52943: PUSH
52944: EMPTY
52945: LIST
52946: LIST
52947: PPUSH
52948: CALL_OW 69
52952: IN
52953: ST_TO_ADDR
// end ;
52954: LD_VAR 0 2
52958: RET
// export function IsNotFull ( building ) ; begin
52959: LD_INT 0
52961: PPUSH
// if not building then
52962: LD_VAR 0 1
52966: NOT
52967: IFFALSE 52971
// exit ;
52969: GO 52990
// result := UnitsInside ( building ) < 6 ;
52971: LD_ADDR_VAR 0 2
52975: PUSH
52976: LD_VAR 0 1
52980: PPUSH
52981: CALL_OW 313
52985: PUSH
52986: LD_INT 6
52988: LESS
52989: ST_TO_ADDR
// end ;
52990: LD_VAR 0 2
52994: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
52995: LD_INT 0
52997: PPUSH
52998: PPUSH
52999: PPUSH
53000: PPUSH
// tmp := [ ] ;
53001: LD_ADDR_VAR 0 3
53005: PUSH
53006: EMPTY
53007: ST_TO_ADDR
// list := [ ] ;
53008: LD_ADDR_VAR 0 5
53012: PUSH
53013: EMPTY
53014: ST_TO_ADDR
// for i = 16 to 25 do
53015: LD_ADDR_VAR 0 4
53019: PUSH
53020: DOUBLE
53021: LD_INT 16
53023: DEC
53024: ST_TO_ADDR
53025: LD_INT 25
53027: PUSH
53028: FOR_TO
53029: IFFALSE 53102
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53031: LD_ADDR_VAR 0 3
53035: PUSH
53036: LD_VAR 0 3
53040: PUSH
53041: LD_INT 22
53043: PUSH
53044: LD_VAR 0 1
53048: PPUSH
53049: CALL_OW 255
53053: PUSH
53054: EMPTY
53055: LIST
53056: LIST
53057: PUSH
53058: LD_INT 91
53060: PUSH
53061: LD_VAR 0 1
53065: PUSH
53066: LD_INT 6
53068: PUSH
53069: EMPTY
53070: LIST
53071: LIST
53072: LIST
53073: PUSH
53074: LD_INT 30
53076: PUSH
53077: LD_VAR 0 4
53081: PUSH
53082: EMPTY
53083: LIST
53084: LIST
53085: PUSH
53086: EMPTY
53087: LIST
53088: LIST
53089: LIST
53090: PUSH
53091: EMPTY
53092: LIST
53093: PPUSH
53094: CALL_OW 69
53098: ADD
53099: ST_TO_ADDR
53100: GO 53028
53102: POP
53103: POP
// for i = 1 to tmp do
53104: LD_ADDR_VAR 0 4
53108: PUSH
53109: DOUBLE
53110: LD_INT 1
53112: DEC
53113: ST_TO_ADDR
53114: LD_VAR 0 3
53118: PUSH
53119: FOR_TO
53120: IFFALSE 53208
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53122: LD_ADDR_VAR 0 5
53126: PUSH
53127: LD_VAR 0 5
53131: PUSH
53132: LD_VAR 0 3
53136: PUSH
53137: LD_VAR 0 4
53141: ARRAY
53142: PPUSH
53143: CALL_OW 266
53147: PUSH
53148: LD_VAR 0 3
53152: PUSH
53153: LD_VAR 0 4
53157: ARRAY
53158: PPUSH
53159: CALL_OW 250
53163: PUSH
53164: LD_VAR 0 3
53168: PUSH
53169: LD_VAR 0 4
53173: ARRAY
53174: PPUSH
53175: CALL_OW 251
53179: PUSH
53180: LD_VAR 0 3
53184: PUSH
53185: LD_VAR 0 4
53189: ARRAY
53190: PPUSH
53191: CALL_OW 254
53195: PUSH
53196: EMPTY
53197: LIST
53198: LIST
53199: LIST
53200: LIST
53201: PUSH
53202: EMPTY
53203: LIST
53204: ADD
53205: ST_TO_ADDR
53206: GO 53119
53208: POP
53209: POP
// result := list ;
53210: LD_ADDR_VAR 0 2
53214: PUSH
53215: LD_VAR 0 5
53219: ST_TO_ADDR
// end ;
53220: LD_VAR 0 2
53224: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53225: LD_INT 0
53227: PPUSH
53228: PPUSH
53229: PPUSH
53230: PPUSH
53231: PPUSH
53232: PPUSH
53233: PPUSH
// if not factory then
53234: LD_VAR 0 1
53238: NOT
53239: IFFALSE 53243
// exit ;
53241: GO 53836
// if control = control_apeman then
53243: LD_VAR 0 4
53247: PUSH
53248: LD_INT 5
53250: EQUAL
53251: IFFALSE 53360
// begin tmp := UnitsInside ( factory ) ;
53253: LD_ADDR_VAR 0 8
53257: PUSH
53258: LD_VAR 0 1
53262: PPUSH
53263: CALL_OW 313
53267: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53268: LD_VAR 0 8
53272: PPUSH
53273: LD_INT 25
53275: PUSH
53276: LD_INT 12
53278: PUSH
53279: EMPTY
53280: LIST
53281: LIST
53282: PPUSH
53283: CALL_OW 72
53287: NOT
53288: IFFALSE 53298
// control := control_manual ;
53290: LD_ADDR_VAR 0 4
53294: PUSH
53295: LD_INT 1
53297: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53298: LD_ADDR_VAR 0 8
53302: PUSH
53303: LD_VAR 0 1
53307: PPUSH
53308: CALL 52995 0 1
53312: ST_TO_ADDR
// if tmp then
53313: LD_VAR 0 8
53317: IFFALSE 53360
// begin for i in tmp do
53319: LD_ADDR_VAR 0 7
53323: PUSH
53324: LD_VAR 0 8
53328: PUSH
53329: FOR_IN
53330: IFFALSE 53358
// if i [ 1 ] = b_ext_radio then
53332: LD_VAR 0 7
53336: PUSH
53337: LD_INT 1
53339: ARRAY
53340: PUSH
53341: LD_INT 22
53343: EQUAL
53344: IFFALSE 53356
// begin control := control_remote ;
53346: LD_ADDR_VAR 0 4
53350: PUSH
53351: LD_INT 2
53353: ST_TO_ADDR
// break ;
53354: GO 53358
// end ;
53356: GO 53329
53358: POP
53359: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53360: LD_VAR 0 1
53364: PPUSH
53365: LD_VAR 0 2
53369: PPUSH
53370: LD_VAR 0 3
53374: PPUSH
53375: LD_VAR 0 4
53379: PPUSH
53380: LD_VAR 0 5
53384: PPUSH
53385: CALL_OW 448
53389: IFFALSE 53424
// begin result := [ chassis , engine , control , weapon ] ;
53391: LD_ADDR_VAR 0 6
53395: PUSH
53396: LD_VAR 0 2
53400: PUSH
53401: LD_VAR 0 3
53405: PUSH
53406: LD_VAR 0 4
53410: PUSH
53411: LD_VAR 0 5
53415: PUSH
53416: EMPTY
53417: LIST
53418: LIST
53419: LIST
53420: LIST
53421: ST_TO_ADDR
// exit ;
53422: GO 53836
// end ; _chassis := AvailableChassisList ( factory ) ;
53424: LD_ADDR_VAR 0 9
53428: PUSH
53429: LD_VAR 0 1
53433: PPUSH
53434: CALL_OW 475
53438: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53439: LD_ADDR_VAR 0 11
53443: PUSH
53444: LD_VAR 0 1
53448: PPUSH
53449: CALL_OW 476
53453: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53454: LD_ADDR_VAR 0 12
53458: PUSH
53459: LD_VAR 0 1
53463: PPUSH
53464: CALL_OW 477
53468: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53469: LD_ADDR_VAR 0 10
53473: PUSH
53474: LD_VAR 0 1
53478: PPUSH
53479: CALL_OW 478
53483: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53484: LD_VAR 0 9
53488: NOT
53489: PUSH
53490: LD_VAR 0 11
53494: NOT
53495: OR
53496: PUSH
53497: LD_VAR 0 12
53501: NOT
53502: OR
53503: PUSH
53504: LD_VAR 0 10
53508: NOT
53509: OR
53510: IFFALSE 53545
// begin result := [ chassis , engine , control , weapon ] ;
53512: LD_ADDR_VAR 0 6
53516: PUSH
53517: LD_VAR 0 2
53521: PUSH
53522: LD_VAR 0 3
53526: PUSH
53527: LD_VAR 0 4
53531: PUSH
53532: LD_VAR 0 5
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: LIST
53541: LIST
53542: ST_TO_ADDR
// exit ;
53543: GO 53836
// end ; if not chassis in _chassis then
53545: LD_VAR 0 2
53549: PUSH
53550: LD_VAR 0 9
53554: IN
53555: NOT
53556: IFFALSE 53582
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
53558: LD_ADDR_VAR 0 2
53562: PUSH
53563: LD_VAR 0 9
53567: PUSH
53568: LD_INT 1
53570: PPUSH
53571: LD_VAR 0 9
53575: PPUSH
53576: CALL_OW 12
53580: ARRAY
53581: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
53582: LD_VAR 0 2
53586: PPUSH
53587: LD_VAR 0 3
53591: PPUSH
53592: CALL 53841 0 2
53596: NOT
53597: IFFALSE 53656
// repeat engine := _engine [ 1 ] ;
53599: LD_ADDR_VAR 0 3
53603: PUSH
53604: LD_VAR 0 11
53608: PUSH
53609: LD_INT 1
53611: ARRAY
53612: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
53613: LD_ADDR_VAR 0 11
53617: PUSH
53618: LD_VAR 0 11
53622: PPUSH
53623: LD_INT 1
53625: PPUSH
53626: CALL_OW 3
53630: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
53631: LD_VAR 0 2
53635: PPUSH
53636: LD_VAR 0 3
53640: PPUSH
53641: CALL 53841 0 2
53645: PUSH
53646: LD_VAR 0 11
53650: PUSH
53651: EMPTY
53652: EQUAL
53653: OR
53654: IFFALSE 53599
// if not control in _control then
53656: LD_VAR 0 4
53660: PUSH
53661: LD_VAR 0 12
53665: IN
53666: NOT
53667: IFFALSE 53693
// control := _control [ rand ( 1 , _control ) ] ;
53669: LD_ADDR_VAR 0 4
53673: PUSH
53674: LD_VAR 0 12
53678: PUSH
53679: LD_INT 1
53681: PPUSH
53682: LD_VAR 0 12
53686: PPUSH
53687: CALL_OW 12
53691: ARRAY
53692: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
53693: LD_VAR 0 2
53697: PPUSH
53698: LD_VAR 0 5
53702: PPUSH
53703: CALL 54061 0 2
53707: NOT
53708: IFFALSE 53767
// repeat weapon := _weapon [ 1 ] ;
53710: LD_ADDR_VAR 0 5
53714: PUSH
53715: LD_VAR 0 10
53719: PUSH
53720: LD_INT 1
53722: ARRAY
53723: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
53724: LD_ADDR_VAR 0 10
53728: PUSH
53729: LD_VAR 0 10
53733: PPUSH
53734: LD_INT 1
53736: PPUSH
53737: CALL_OW 3
53741: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
53742: LD_VAR 0 2
53746: PPUSH
53747: LD_VAR 0 5
53751: PPUSH
53752: CALL 54061 0 2
53756: PUSH
53757: LD_VAR 0 10
53761: PUSH
53762: EMPTY
53763: EQUAL
53764: OR
53765: IFFALSE 53710
// result := [ ] ;
53767: LD_ADDR_VAR 0 6
53771: PUSH
53772: EMPTY
53773: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53774: LD_VAR 0 1
53778: PPUSH
53779: LD_VAR 0 2
53783: PPUSH
53784: LD_VAR 0 3
53788: PPUSH
53789: LD_VAR 0 4
53793: PPUSH
53794: LD_VAR 0 5
53798: PPUSH
53799: CALL_OW 448
53803: IFFALSE 53836
// result := [ chassis , engine , control , weapon ] ;
53805: LD_ADDR_VAR 0 6
53809: PUSH
53810: LD_VAR 0 2
53814: PUSH
53815: LD_VAR 0 3
53819: PUSH
53820: LD_VAR 0 4
53824: PUSH
53825: LD_VAR 0 5
53829: PUSH
53830: EMPTY
53831: LIST
53832: LIST
53833: LIST
53834: LIST
53835: ST_TO_ADDR
// end ;
53836: LD_VAR 0 6
53840: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
53841: LD_INT 0
53843: PPUSH
// if not chassis or not engine then
53844: LD_VAR 0 1
53848: NOT
53849: PUSH
53850: LD_VAR 0 2
53854: NOT
53855: OR
53856: IFFALSE 53860
// exit ;
53858: GO 54056
// case engine of engine_solar :
53860: LD_VAR 0 2
53864: PUSH
53865: LD_INT 2
53867: DOUBLE
53868: EQUAL
53869: IFTRUE 53873
53871: GO 53911
53873: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
53874: LD_ADDR_VAR 0 3
53878: PUSH
53879: LD_INT 11
53881: PUSH
53882: LD_INT 12
53884: PUSH
53885: LD_INT 13
53887: PUSH
53888: LD_INT 14
53890: PUSH
53891: LD_INT 1
53893: PUSH
53894: LD_INT 2
53896: PUSH
53897: LD_INT 3
53899: PUSH
53900: EMPTY
53901: LIST
53902: LIST
53903: LIST
53904: LIST
53905: LIST
53906: LIST
53907: LIST
53908: ST_TO_ADDR
53909: GO 54040
53911: LD_INT 1
53913: DOUBLE
53914: EQUAL
53915: IFTRUE 53919
53917: GO 53981
53919: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
53920: LD_ADDR_VAR 0 3
53924: PUSH
53925: LD_INT 11
53927: PUSH
53928: LD_INT 12
53930: PUSH
53931: LD_INT 13
53933: PUSH
53934: LD_INT 14
53936: PUSH
53937: LD_INT 1
53939: PUSH
53940: LD_INT 2
53942: PUSH
53943: LD_INT 3
53945: PUSH
53946: LD_INT 4
53948: PUSH
53949: LD_INT 5
53951: PUSH
53952: LD_INT 21
53954: PUSH
53955: LD_INT 23
53957: PUSH
53958: LD_INT 22
53960: PUSH
53961: LD_INT 24
53963: PUSH
53964: EMPTY
53965: LIST
53966: LIST
53967: LIST
53968: LIST
53969: LIST
53970: LIST
53971: LIST
53972: LIST
53973: LIST
53974: LIST
53975: LIST
53976: LIST
53977: LIST
53978: ST_TO_ADDR
53979: GO 54040
53981: LD_INT 3
53983: DOUBLE
53984: EQUAL
53985: IFTRUE 53989
53987: GO 54039
53989: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53990: LD_ADDR_VAR 0 3
53994: PUSH
53995: LD_INT 13
53997: PUSH
53998: LD_INT 14
54000: PUSH
54001: LD_INT 2
54003: PUSH
54004: LD_INT 3
54006: PUSH
54007: LD_INT 4
54009: PUSH
54010: LD_INT 5
54012: PUSH
54013: LD_INT 21
54015: PUSH
54016: LD_INT 22
54018: PUSH
54019: LD_INT 23
54021: PUSH
54022: LD_INT 24
54024: PUSH
54025: EMPTY
54026: LIST
54027: LIST
54028: LIST
54029: LIST
54030: LIST
54031: LIST
54032: LIST
54033: LIST
54034: LIST
54035: LIST
54036: ST_TO_ADDR
54037: GO 54040
54039: POP
// result := ( chassis in result ) ;
54040: LD_ADDR_VAR 0 3
54044: PUSH
54045: LD_VAR 0 1
54049: PUSH
54050: LD_VAR 0 3
54054: IN
54055: ST_TO_ADDR
// end ;
54056: LD_VAR 0 3
54060: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54061: LD_INT 0
54063: PPUSH
// if not chassis or not weapon then
54064: LD_VAR 0 1
54068: NOT
54069: PUSH
54070: LD_VAR 0 2
54074: NOT
54075: OR
54076: IFFALSE 54080
// exit ;
54078: GO 55106
// case weapon of us_machine_gun :
54080: LD_VAR 0 2
54084: PUSH
54085: LD_INT 2
54087: DOUBLE
54088: EQUAL
54089: IFTRUE 54093
54091: GO 54123
54093: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54094: LD_ADDR_VAR 0 3
54098: PUSH
54099: LD_INT 1
54101: PUSH
54102: LD_INT 2
54104: PUSH
54105: LD_INT 3
54107: PUSH
54108: LD_INT 4
54110: PUSH
54111: LD_INT 5
54113: PUSH
54114: EMPTY
54115: LIST
54116: LIST
54117: LIST
54118: LIST
54119: LIST
54120: ST_TO_ADDR
54121: GO 55090
54123: LD_INT 3
54125: DOUBLE
54126: EQUAL
54127: IFTRUE 54131
54129: GO 54161
54131: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54132: LD_ADDR_VAR 0 3
54136: PUSH
54137: LD_INT 1
54139: PUSH
54140: LD_INT 2
54142: PUSH
54143: LD_INT 3
54145: PUSH
54146: LD_INT 4
54148: PUSH
54149: LD_INT 5
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: LIST
54156: LIST
54157: LIST
54158: ST_TO_ADDR
54159: GO 55090
54161: LD_INT 11
54163: DOUBLE
54164: EQUAL
54165: IFTRUE 54169
54167: GO 54199
54169: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54170: LD_ADDR_VAR 0 3
54174: PUSH
54175: LD_INT 1
54177: PUSH
54178: LD_INT 2
54180: PUSH
54181: LD_INT 3
54183: PUSH
54184: LD_INT 4
54186: PUSH
54187: LD_INT 5
54189: PUSH
54190: EMPTY
54191: LIST
54192: LIST
54193: LIST
54194: LIST
54195: LIST
54196: ST_TO_ADDR
54197: GO 55090
54199: LD_INT 4
54201: DOUBLE
54202: EQUAL
54203: IFTRUE 54207
54205: GO 54233
54207: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54208: LD_ADDR_VAR 0 3
54212: PUSH
54213: LD_INT 2
54215: PUSH
54216: LD_INT 3
54218: PUSH
54219: LD_INT 4
54221: PUSH
54222: LD_INT 5
54224: PUSH
54225: EMPTY
54226: LIST
54227: LIST
54228: LIST
54229: LIST
54230: ST_TO_ADDR
54231: GO 55090
54233: LD_INT 5
54235: DOUBLE
54236: EQUAL
54237: IFTRUE 54241
54239: GO 54267
54241: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54242: LD_ADDR_VAR 0 3
54246: PUSH
54247: LD_INT 2
54249: PUSH
54250: LD_INT 3
54252: PUSH
54253: LD_INT 4
54255: PUSH
54256: LD_INT 5
54258: PUSH
54259: EMPTY
54260: LIST
54261: LIST
54262: LIST
54263: LIST
54264: ST_TO_ADDR
54265: GO 55090
54267: LD_INT 9
54269: DOUBLE
54270: EQUAL
54271: IFTRUE 54275
54273: GO 54301
54275: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54276: LD_ADDR_VAR 0 3
54280: PUSH
54281: LD_INT 2
54283: PUSH
54284: LD_INT 3
54286: PUSH
54287: LD_INT 4
54289: PUSH
54290: LD_INT 5
54292: PUSH
54293: EMPTY
54294: LIST
54295: LIST
54296: LIST
54297: LIST
54298: ST_TO_ADDR
54299: GO 55090
54301: LD_INT 7
54303: DOUBLE
54304: EQUAL
54305: IFTRUE 54309
54307: GO 54335
54309: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54310: LD_ADDR_VAR 0 3
54314: PUSH
54315: LD_INT 2
54317: PUSH
54318: LD_INT 3
54320: PUSH
54321: LD_INT 4
54323: PUSH
54324: LD_INT 5
54326: PUSH
54327: EMPTY
54328: LIST
54329: LIST
54330: LIST
54331: LIST
54332: ST_TO_ADDR
54333: GO 55090
54335: LD_INT 12
54337: DOUBLE
54338: EQUAL
54339: IFTRUE 54343
54341: GO 54369
54343: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54344: LD_ADDR_VAR 0 3
54348: PUSH
54349: LD_INT 2
54351: PUSH
54352: LD_INT 3
54354: PUSH
54355: LD_INT 4
54357: PUSH
54358: LD_INT 5
54360: PUSH
54361: EMPTY
54362: LIST
54363: LIST
54364: LIST
54365: LIST
54366: ST_TO_ADDR
54367: GO 55090
54369: LD_INT 13
54371: DOUBLE
54372: EQUAL
54373: IFTRUE 54377
54375: GO 54403
54377: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54378: LD_ADDR_VAR 0 3
54382: PUSH
54383: LD_INT 2
54385: PUSH
54386: LD_INT 3
54388: PUSH
54389: LD_INT 4
54391: PUSH
54392: LD_INT 5
54394: PUSH
54395: EMPTY
54396: LIST
54397: LIST
54398: LIST
54399: LIST
54400: ST_TO_ADDR
54401: GO 55090
54403: LD_INT 14
54405: DOUBLE
54406: EQUAL
54407: IFTRUE 54411
54409: GO 54429
54411: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54412: LD_ADDR_VAR 0 3
54416: PUSH
54417: LD_INT 4
54419: PUSH
54420: LD_INT 5
54422: PUSH
54423: EMPTY
54424: LIST
54425: LIST
54426: ST_TO_ADDR
54427: GO 55090
54429: LD_INT 6
54431: DOUBLE
54432: EQUAL
54433: IFTRUE 54437
54435: GO 54455
54437: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54438: LD_ADDR_VAR 0 3
54442: PUSH
54443: LD_INT 4
54445: PUSH
54446: LD_INT 5
54448: PUSH
54449: EMPTY
54450: LIST
54451: LIST
54452: ST_TO_ADDR
54453: GO 55090
54455: LD_INT 10
54457: DOUBLE
54458: EQUAL
54459: IFTRUE 54463
54461: GO 54481
54463: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54464: LD_ADDR_VAR 0 3
54468: PUSH
54469: LD_INT 4
54471: PUSH
54472: LD_INT 5
54474: PUSH
54475: EMPTY
54476: LIST
54477: LIST
54478: ST_TO_ADDR
54479: GO 55090
54481: LD_INT 22
54483: DOUBLE
54484: EQUAL
54485: IFTRUE 54489
54487: GO 54515
54489: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54490: LD_ADDR_VAR 0 3
54494: PUSH
54495: LD_INT 11
54497: PUSH
54498: LD_INT 12
54500: PUSH
54501: LD_INT 13
54503: PUSH
54504: LD_INT 14
54506: PUSH
54507: EMPTY
54508: LIST
54509: LIST
54510: LIST
54511: LIST
54512: ST_TO_ADDR
54513: GO 55090
54515: LD_INT 23
54517: DOUBLE
54518: EQUAL
54519: IFTRUE 54523
54521: GO 54549
54523: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54524: LD_ADDR_VAR 0 3
54528: PUSH
54529: LD_INT 11
54531: PUSH
54532: LD_INT 12
54534: PUSH
54535: LD_INT 13
54537: PUSH
54538: LD_INT 14
54540: PUSH
54541: EMPTY
54542: LIST
54543: LIST
54544: LIST
54545: LIST
54546: ST_TO_ADDR
54547: GO 55090
54549: LD_INT 24
54551: DOUBLE
54552: EQUAL
54553: IFTRUE 54557
54555: GO 54583
54557: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
54558: LD_ADDR_VAR 0 3
54562: PUSH
54563: LD_INT 11
54565: PUSH
54566: LD_INT 12
54568: PUSH
54569: LD_INT 13
54571: PUSH
54572: LD_INT 14
54574: PUSH
54575: EMPTY
54576: LIST
54577: LIST
54578: LIST
54579: LIST
54580: ST_TO_ADDR
54581: GO 55090
54583: LD_INT 30
54585: DOUBLE
54586: EQUAL
54587: IFTRUE 54591
54589: GO 54617
54591: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
54592: LD_ADDR_VAR 0 3
54596: PUSH
54597: LD_INT 11
54599: PUSH
54600: LD_INT 12
54602: PUSH
54603: LD_INT 13
54605: PUSH
54606: LD_INT 14
54608: PUSH
54609: EMPTY
54610: LIST
54611: LIST
54612: LIST
54613: LIST
54614: ST_TO_ADDR
54615: GO 55090
54617: LD_INT 25
54619: DOUBLE
54620: EQUAL
54621: IFTRUE 54625
54623: GO 54643
54625: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
54626: LD_ADDR_VAR 0 3
54630: PUSH
54631: LD_INT 13
54633: PUSH
54634: LD_INT 14
54636: PUSH
54637: EMPTY
54638: LIST
54639: LIST
54640: ST_TO_ADDR
54641: GO 55090
54643: LD_INT 27
54645: DOUBLE
54646: EQUAL
54647: IFTRUE 54651
54649: GO 54669
54651: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
54652: LD_ADDR_VAR 0 3
54656: PUSH
54657: LD_INT 13
54659: PUSH
54660: LD_INT 14
54662: PUSH
54663: EMPTY
54664: LIST
54665: LIST
54666: ST_TO_ADDR
54667: GO 55090
54669: LD_INT 28
54671: DOUBLE
54672: EQUAL
54673: IFTRUE 54677
54675: GO 54695
54677: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
54678: LD_ADDR_VAR 0 3
54682: PUSH
54683: LD_INT 13
54685: PUSH
54686: LD_INT 14
54688: PUSH
54689: EMPTY
54690: LIST
54691: LIST
54692: ST_TO_ADDR
54693: GO 55090
54695: LD_INT 29
54697: DOUBLE
54698: EQUAL
54699: IFTRUE 54703
54701: GO 54721
54703: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
54704: LD_ADDR_VAR 0 3
54708: PUSH
54709: LD_INT 13
54711: PUSH
54712: LD_INT 14
54714: PUSH
54715: EMPTY
54716: LIST
54717: LIST
54718: ST_TO_ADDR
54719: GO 55090
54721: LD_INT 31
54723: DOUBLE
54724: EQUAL
54725: IFTRUE 54729
54727: GO 54747
54729: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
54730: LD_ADDR_VAR 0 3
54734: PUSH
54735: LD_INT 13
54737: PUSH
54738: LD_INT 14
54740: PUSH
54741: EMPTY
54742: LIST
54743: LIST
54744: ST_TO_ADDR
54745: GO 55090
54747: LD_INT 26
54749: DOUBLE
54750: EQUAL
54751: IFTRUE 54755
54753: GO 54773
54755: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
54756: LD_ADDR_VAR 0 3
54760: PUSH
54761: LD_INT 13
54763: PUSH
54764: LD_INT 14
54766: PUSH
54767: EMPTY
54768: LIST
54769: LIST
54770: ST_TO_ADDR
54771: GO 55090
54773: LD_INT 42
54775: DOUBLE
54776: EQUAL
54777: IFTRUE 54781
54779: GO 54807
54781: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
54782: LD_ADDR_VAR 0 3
54786: PUSH
54787: LD_INT 21
54789: PUSH
54790: LD_INT 22
54792: PUSH
54793: LD_INT 23
54795: PUSH
54796: LD_INT 24
54798: PUSH
54799: EMPTY
54800: LIST
54801: LIST
54802: LIST
54803: LIST
54804: ST_TO_ADDR
54805: GO 55090
54807: LD_INT 43
54809: DOUBLE
54810: EQUAL
54811: IFTRUE 54815
54813: GO 54841
54815: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
54816: LD_ADDR_VAR 0 3
54820: PUSH
54821: LD_INT 21
54823: PUSH
54824: LD_INT 22
54826: PUSH
54827: LD_INT 23
54829: PUSH
54830: LD_INT 24
54832: PUSH
54833: EMPTY
54834: LIST
54835: LIST
54836: LIST
54837: LIST
54838: ST_TO_ADDR
54839: GO 55090
54841: LD_INT 44
54843: DOUBLE
54844: EQUAL
54845: IFTRUE 54849
54847: GO 54875
54849: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
54850: LD_ADDR_VAR 0 3
54854: PUSH
54855: LD_INT 21
54857: PUSH
54858: LD_INT 22
54860: PUSH
54861: LD_INT 23
54863: PUSH
54864: LD_INT 24
54866: PUSH
54867: EMPTY
54868: LIST
54869: LIST
54870: LIST
54871: LIST
54872: ST_TO_ADDR
54873: GO 55090
54875: LD_INT 45
54877: DOUBLE
54878: EQUAL
54879: IFTRUE 54883
54881: GO 54909
54883: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
54884: LD_ADDR_VAR 0 3
54888: PUSH
54889: LD_INT 21
54891: PUSH
54892: LD_INT 22
54894: PUSH
54895: LD_INT 23
54897: PUSH
54898: LD_INT 24
54900: PUSH
54901: EMPTY
54902: LIST
54903: LIST
54904: LIST
54905: LIST
54906: ST_TO_ADDR
54907: GO 55090
54909: LD_INT 49
54911: DOUBLE
54912: EQUAL
54913: IFTRUE 54917
54915: GO 54943
54917: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
54918: LD_ADDR_VAR 0 3
54922: PUSH
54923: LD_INT 21
54925: PUSH
54926: LD_INT 22
54928: PUSH
54929: LD_INT 23
54931: PUSH
54932: LD_INT 24
54934: PUSH
54935: EMPTY
54936: LIST
54937: LIST
54938: LIST
54939: LIST
54940: ST_TO_ADDR
54941: GO 55090
54943: LD_INT 51
54945: DOUBLE
54946: EQUAL
54947: IFTRUE 54951
54949: GO 54977
54951: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
54952: LD_ADDR_VAR 0 3
54956: PUSH
54957: LD_INT 21
54959: PUSH
54960: LD_INT 22
54962: PUSH
54963: LD_INT 23
54965: PUSH
54966: LD_INT 24
54968: PUSH
54969: EMPTY
54970: LIST
54971: LIST
54972: LIST
54973: LIST
54974: ST_TO_ADDR
54975: GO 55090
54977: LD_INT 52
54979: DOUBLE
54980: EQUAL
54981: IFTRUE 54985
54983: GO 55011
54985: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
54986: LD_ADDR_VAR 0 3
54990: PUSH
54991: LD_INT 21
54993: PUSH
54994: LD_INT 22
54996: PUSH
54997: LD_INT 23
54999: PUSH
55000: LD_INT 24
55002: PUSH
55003: EMPTY
55004: LIST
55005: LIST
55006: LIST
55007: LIST
55008: ST_TO_ADDR
55009: GO 55090
55011: LD_INT 53
55013: DOUBLE
55014: EQUAL
55015: IFTRUE 55019
55017: GO 55037
55019: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55020: LD_ADDR_VAR 0 3
55024: PUSH
55025: LD_INT 23
55027: PUSH
55028: LD_INT 24
55030: PUSH
55031: EMPTY
55032: LIST
55033: LIST
55034: ST_TO_ADDR
55035: GO 55090
55037: LD_INT 46
55039: DOUBLE
55040: EQUAL
55041: IFTRUE 55045
55043: GO 55063
55045: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55046: LD_ADDR_VAR 0 3
55050: PUSH
55051: LD_INT 23
55053: PUSH
55054: LD_INT 24
55056: PUSH
55057: EMPTY
55058: LIST
55059: LIST
55060: ST_TO_ADDR
55061: GO 55090
55063: LD_INT 47
55065: DOUBLE
55066: EQUAL
55067: IFTRUE 55071
55069: GO 55089
55071: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55072: LD_ADDR_VAR 0 3
55076: PUSH
55077: LD_INT 23
55079: PUSH
55080: LD_INT 24
55082: PUSH
55083: EMPTY
55084: LIST
55085: LIST
55086: ST_TO_ADDR
55087: GO 55090
55089: POP
// result := ( chassis in result ) ;
55090: LD_ADDR_VAR 0 3
55094: PUSH
55095: LD_VAR 0 1
55099: PUSH
55100: LD_VAR 0 3
55104: IN
55105: ST_TO_ADDR
// end ;
55106: LD_VAR 0 3
55110: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55111: LD_INT 0
55113: PPUSH
55114: PPUSH
55115: PPUSH
55116: PPUSH
55117: PPUSH
55118: PPUSH
55119: PPUSH
// result := array ;
55120: LD_ADDR_VAR 0 5
55124: PUSH
55125: LD_VAR 0 1
55129: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55130: LD_VAR 0 1
55134: NOT
55135: PUSH
55136: LD_VAR 0 2
55140: NOT
55141: OR
55142: PUSH
55143: LD_VAR 0 3
55147: NOT
55148: OR
55149: PUSH
55150: LD_VAR 0 2
55154: PUSH
55155: LD_VAR 0 1
55159: GREATER
55160: OR
55161: PUSH
55162: LD_VAR 0 3
55166: PUSH
55167: LD_VAR 0 1
55171: GREATER
55172: OR
55173: IFFALSE 55177
// exit ;
55175: GO 55473
// if direction then
55177: LD_VAR 0 4
55181: IFFALSE 55245
// begin d := 1 ;
55183: LD_ADDR_VAR 0 9
55187: PUSH
55188: LD_INT 1
55190: ST_TO_ADDR
// if i_from > i_to then
55191: LD_VAR 0 2
55195: PUSH
55196: LD_VAR 0 3
55200: GREATER
55201: IFFALSE 55227
// length := ( array - i_from ) + i_to else
55203: LD_ADDR_VAR 0 11
55207: PUSH
55208: LD_VAR 0 1
55212: PUSH
55213: LD_VAR 0 2
55217: MINUS
55218: PUSH
55219: LD_VAR 0 3
55223: PLUS
55224: ST_TO_ADDR
55225: GO 55243
// length := i_to - i_from ;
55227: LD_ADDR_VAR 0 11
55231: PUSH
55232: LD_VAR 0 3
55236: PUSH
55237: LD_VAR 0 2
55241: MINUS
55242: ST_TO_ADDR
// end else
55243: GO 55306
// begin d := - 1 ;
55245: LD_ADDR_VAR 0 9
55249: PUSH
55250: LD_INT 1
55252: NEG
55253: ST_TO_ADDR
// if i_from > i_to then
55254: LD_VAR 0 2
55258: PUSH
55259: LD_VAR 0 3
55263: GREATER
55264: IFFALSE 55284
// length := i_from - i_to else
55266: LD_ADDR_VAR 0 11
55270: PUSH
55271: LD_VAR 0 2
55275: PUSH
55276: LD_VAR 0 3
55280: MINUS
55281: ST_TO_ADDR
55282: GO 55306
// length := ( array - i_to ) + i_from ;
55284: LD_ADDR_VAR 0 11
55288: PUSH
55289: LD_VAR 0 1
55293: PUSH
55294: LD_VAR 0 3
55298: MINUS
55299: PUSH
55300: LD_VAR 0 2
55304: PLUS
55305: ST_TO_ADDR
// end ; if not length then
55306: LD_VAR 0 11
55310: NOT
55311: IFFALSE 55315
// exit ;
55313: GO 55473
// tmp := array ;
55315: LD_ADDR_VAR 0 10
55319: PUSH
55320: LD_VAR 0 1
55324: ST_TO_ADDR
// for i = 1 to length do
55325: LD_ADDR_VAR 0 6
55329: PUSH
55330: DOUBLE
55331: LD_INT 1
55333: DEC
55334: ST_TO_ADDR
55335: LD_VAR 0 11
55339: PUSH
55340: FOR_TO
55341: IFFALSE 55461
// begin for j = 1 to array do
55343: LD_ADDR_VAR 0 7
55347: PUSH
55348: DOUBLE
55349: LD_INT 1
55351: DEC
55352: ST_TO_ADDR
55353: LD_VAR 0 1
55357: PUSH
55358: FOR_TO
55359: IFFALSE 55447
// begin k := j + d ;
55361: LD_ADDR_VAR 0 8
55365: PUSH
55366: LD_VAR 0 7
55370: PUSH
55371: LD_VAR 0 9
55375: PLUS
55376: ST_TO_ADDR
// if k > array then
55377: LD_VAR 0 8
55381: PUSH
55382: LD_VAR 0 1
55386: GREATER
55387: IFFALSE 55397
// k := 1 ;
55389: LD_ADDR_VAR 0 8
55393: PUSH
55394: LD_INT 1
55396: ST_TO_ADDR
// if not k then
55397: LD_VAR 0 8
55401: NOT
55402: IFFALSE 55414
// k := array ;
55404: LD_ADDR_VAR 0 8
55408: PUSH
55409: LD_VAR 0 1
55413: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55414: LD_ADDR_VAR 0 10
55418: PUSH
55419: LD_VAR 0 10
55423: PPUSH
55424: LD_VAR 0 8
55428: PPUSH
55429: LD_VAR 0 1
55433: PUSH
55434: LD_VAR 0 7
55438: ARRAY
55439: PPUSH
55440: CALL_OW 1
55444: ST_TO_ADDR
// end ;
55445: GO 55358
55447: POP
55448: POP
// array := tmp ;
55449: LD_ADDR_VAR 0 1
55453: PUSH
55454: LD_VAR 0 10
55458: ST_TO_ADDR
// end ;
55459: GO 55340
55461: POP
55462: POP
// result := array ;
55463: LD_ADDR_VAR 0 5
55467: PUSH
55468: LD_VAR 0 1
55472: ST_TO_ADDR
// end ;
55473: LD_VAR 0 5
55477: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55478: LD_INT 0
55480: PPUSH
55481: PPUSH
// result := 0 ;
55482: LD_ADDR_VAR 0 3
55486: PUSH
55487: LD_INT 0
55489: ST_TO_ADDR
// if not array or not value in array then
55490: LD_VAR 0 1
55494: NOT
55495: PUSH
55496: LD_VAR 0 2
55500: PUSH
55501: LD_VAR 0 1
55505: IN
55506: NOT
55507: OR
55508: IFFALSE 55512
// exit ;
55510: GO 55566
// for i = 1 to array do
55512: LD_ADDR_VAR 0 4
55516: PUSH
55517: DOUBLE
55518: LD_INT 1
55520: DEC
55521: ST_TO_ADDR
55522: LD_VAR 0 1
55526: PUSH
55527: FOR_TO
55528: IFFALSE 55564
// if value = array [ i ] then
55530: LD_VAR 0 2
55534: PUSH
55535: LD_VAR 0 1
55539: PUSH
55540: LD_VAR 0 4
55544: ARRAY
55545: EQUAL
55546: IFFALSE 55562
// begin result := i ;
55548: LD_ADDR_VAR 0 3
55552: PUSH
55553: LD_VAR 0 4
55557: ST_TO_ADDR
// exit ;
55558: POP
55559: POP
55560: GO 55566
// end ;
55562: GO 55527
55564: POP
55565: POP
// end ;
55566: LD_VAR 0 3
55570: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
55571: LD_INT 0
55573: PPUSH
// vc_chassis := chassis ;
55574: LD_ADDR_OWVAR 37
55578: PUSH
55579: LD_VAR 0 1
55583: ST_TO_ADDR
// vc_engine := engine ;
55584: LD_ADDR_OWVAR 39
55588: PUSH
55589: LD_VAR 0 2
55593: ST_TO_ADDR
// vc_control := control ;
55594: LD_ADDR_OWVAR 38
55598: PUSH
55599: LD_VAR 0 3
55603: ST_TO_ADDR
// vc_weapon := weapon ;
55604: LD_ADDR_OWVAR 40
55608: PUSH
55609: LD_VAR 0 4
55613: ST_TO_ADDR
// vc_fuel_battery := fuel ;
55614: LD_ADDR_OWVAR 41
55618: PUSH
55619: LD_VAR 0 5
55623: ST_TO_ADDR
// end ;
55624: LD_VAR 0 6
55628: RET
// export function WantPlant ( unit ) ; var task ; begin
55629: LD_INT 0
55631: PPUSH
55632: PPUSH
// result := false ;
55633: LD_ADDR_VAR 0 2
55637: PUSH
55638: LD_INT 0
55640: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
55641: LD_ADDR_VAR 0 3
55645: PUSH
55646: LD_VAR 0 1
55650: PPUSH
55651: CALL_OW 437
55655: ST_TO_ADDR
// if task then
55656: LD_VAR 0 3
55660: IFFALSE 55688
// if task [ 1 ] [ 1 ] = p then
55662: LD_VAR 0 3
55666: PUSH
55667: LD_INT 1
55669: ARRAY
55670: PUSH
55671: LD_INT 1
55673: ARRAY
55674: PUSH
55675: LD_STRING p
55677: EQUAL
55678: IFFALSE 55688
// result := true ;
55680: LD_ADDR_VAR 0 2
55684: PUSH
55685: LD_INT 1
55687: ST_TO_ADDR
// end ;
55688: LD_VAR 0 2
55692: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
55693: LD_INT 0
55695: PPUSH
55696: PPUSH
55697: PPUSH
55698: PPUSH
// if pos < 1 then
55699: LD_VAR 0 2
55703: PUSH
55704: LD_INT 1
55706: LESS
55707: IFFALSE 55711
// exit ;
55709: GO 56014
// if pos = 1 then
55711: LD_VAR 0 2
55715: PUSH
55716: LD_INT 1
55718: EQUAL
55719: IFFALSE 55752
// result := Replace ( arr , pos [ 1 ] , value ) else
55721: LD_ADDR_VAR 0 4
55725: PUSH
55726: LD_VAR 0 1
55730: PPUSH
55731: LD_VAR 0 2
55735: PUSH
55736: LD_INT 1
55738: ARRAY
55739: PPUSH
55740: LD_VAR 0 3
55744: PPUSH
55745: CALL_OW 1
55749: ST_TO_ADDR
55750: GO 56014
// begin tmp := arr ;
55752: LD_ADDR_VAR 0 6
55756: PUSH
55757: LD_VAR 0 1
55761: ST_TO_ADDR
// s_arr := [ tmp ] ;
55762: LD_ADDR_VAR 0 7
55766: PUSH
55767: LD_VAR 0 6
55771: PUSH
55772: EMPTY
55773: LIST
55774: ST_TO_ADDR
// for i = 1 to pos - 1 do
55775: LD_ADDR_VAR 0 5
55779: PUSH
55780: DOUBLE
55781: LD_INT 1
55783: DEC
55784: ST_TO_ADDR
55785: LD_VAR 0 2
55789: PUSH
55790: LD_INT 1
55792: MINUS
55793: PUSH
55794: FOR_TO
55795: IFFALSE 55840
// begin tmp := tmp [ pos [ i ] ] ;
55797: LD_ADDR_VAR 0 6
55801: PUSH
55802: LD_VAR 0 6
55806: PUSH
55807: LD_VAR 0 2
55811: PUSH
55812: LD_VAR 0 5
55816: ARRAY
55817: ARRAY
55818: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
55819: LD_ADDR_VAR 0 7
55823: PUSH
55824: LD_VAR 0 7
55828: PUSH
55829: LD_VAR 0 6
55833: PUSH
55834: EMPTY
55835: LIST
55836: ADD
55837: ST_TO_ADDR
// end ;
55838: GO 55794
55840: POP
55841: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
55842: LD_ADDR_VAR 0 6
55846: PUSH
55847: LD_VAR 0 6
55851: PPUSH
55852: LD_VAR 0 2
55856: PUSH
55857: LD_VAR 0 2
55861: ARRAY
55862: PPUSH
55863: LD_VAR 0 3
55867: PPUSH
55868: CALL_OW 1
55872: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
55873: LD_ADDR_VAR 0 7
55877: PUSH
55878: LD_VAR 0 7
55882: PPUSH
55883: LD_VAR 0 7
55887: PPUSH
55888: LD_VAR 0 6
55892: PPUSH
55893: CALL_OW 1
55897: ST_TO_ADDR
// for i = s_arr downto 2 do
55898: LD_ADDR_VAR 0 5
55902: PUSH
55903: DOUBLE
55904: LD_VAR 0 7
55908: INC
55909: ST_TO_ADDR
55910: LD_INT 2
55912: PUSH
55913: FOR_DOWNTO
55914: IFFALSE 55998
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
55916: LD_ADDR_VAR 0 6
55920: PUSH
55921: LD_VAR 0 7
55925: PUSH
55926: LD_VAR 0 5
55930: PUSH
55931: LD_INT 1
55933: MINUS
55934: ARRAY
55935: PPUSH
55936: LD_VAR 0 2
55940: PUSH
55941: LD_VAR 0 5
55945: PUSH
55946: LD_INT 1
55948: MINUS
55949: ARRAY
55950: PPUSH
55951: LD_VAR 0 7
55955: PUSH
55956: LD_VAR 0 5
55960: ARRAY
55961: PPUSH
55962: CALL_OW 1
55966: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
55967: LD_ADDR_VAR 0 7
55971: PUSH
55972: LD_VAR 0 7
55976: PPUSH
55977: LD_VAR 0 5
55981: PUSH
55982: LD_INT 1
55984: MINUS
55985: PPUSH
55986: LD_VAR 0 6
55990: PPUSH
55991: CALL_OW 1
55995: ST_TO_ADDR
// end ;
55996: GO 55913
55998: POP
55999: POP
// result := s_arr [ 1 ] ;
56000: LD_ADDR_VAR 0 4
56004: PUSH
56005: LD_VAR 0 7
56009: PUSH
56010: LD_INT 1
56012: ARRAY
56013: ST_TO_ADDR
// end ; end ;
56014: LD_VAR 0 4
56018: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56019: LD_INT 0
56021: PPUSH
56022: PPUSH
// if not list then
56023: LD_VAR 0 1
56027: NOT
56028: IFFALSE 56032
// exit ;
56030: GO 56123
// i := list [ pos1 ] ;
56032: LD_ADDR_VAR 0 5
56036: PUSH
56037: LD_VAR 0 1
56041: PUSH
56042: LD_VAR 0 2
56046: ARRAY
56047: ST_TO_ADDR
// if not i then
56048: LD_VAR 0 5
56052: NOT
56053: IFFALSE 56057
// exit ;
56055: GO 56123
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56057: LD_ADDR_VAR 0 1
56061: PUSH
56062: LD_VAR 0 1
56066: PPUSH
56067: LD_VAR 0 2
56071: PPUSH
56072: LD_VAR 0 1
56076: PUSH
56077: LD_VAR 0 3
56081: ARRAY
56082: PPUSH
56083: CALL_OW 1
56087: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56088: LD_ADDR_VAR 0 1
56092: PUSH
56093: LD_VAR 0 1
56097: PPUSH
56098: LD_VAR 0 3
56102: PPUSH
56103: LD_VAR 0 5
56107: PPUSH
56108: CALL_OW 1
56112: ST_TO_ADDR
// result := list ;
56113: LD_ADDR_VAR 0 4
56117: PUSH
56118: LD_VAR 0 1
56122: ST_TO_ADDR
// end ;
56123: LD_VAR 0 4
56127: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56128: LD_INT 0
56130: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56131: LD_ADDR_VAR 0 5
56135: PUSH
56136: LD_VAR 0 1
56140: PPUSH
56141: CALL_OW 250
56145: PPUSH
56146: LD_VAR 0 1
56150: PPUSH
56151: CALL_OW 251
56155: PPUSH
56156: LD_VAR 0 2
56160: PPUSH
56161: LD_VAR 0 3
56165: PPUSH
56166: LD_VAR 0 4
56170: PPUSH
56171: CALL 56181 0 5
56175: ST_TO_ADDR
// end ;
56176: LD_VAR 0 5
56180: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56181: LD_INT 0
56183: PPUSH
56184: PPUSH
56185: PPUSH
56186: PPUSH
// if not list then
56187: LD_VAR 0 3
56191: NOT
56192: IFFALSE 56196
// exit ;
56194: GO 56584
// result := [ ] ;
56196: LD_ADDR_VAR 0 6
56200: PUSH
56201: EMPTY
56202: ST_TO_ADDR
// for i in list do
56203: LD_ADDR_VAR 0 7
56207: PUSH
56208: LD_VAR 0 3
56212: PUSH
56213: FOR_IN
56214: IFFALSE 56416
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56216: LD_ADDR_VAR 0 9
56220: PUSH
56221: LD_VAR 0 7
56225: PPUSH
56226: LD_VAR 0 1
56230: PPUSH
56231: LD_VAR 0 2
56235: PPUSH
56236: CALL_OW 297
56240: ST_TO_ADDR
// if not result then
56241: LD_VAR 0 6
56245: NOT
56246: IFFALSE 56272
// result := [ [ i , tmp ] ] else
56248: LD_ADDR_VAR 0 6
56252: PUSH
56253: LD_VAR 0 7
56257: PUSH
56258: LD_VAR 0 9
56262: PUSH
56263: EMPTY
56264: LIST
56265: LIST
56266: PUSH
56267: EMPTY
56268: LIST
56269: ST_TO_ADDR
56270: GO 56414
// begin if result [ result ] [ 2 ] < tmp then
56272: LD_VAR 0 6
56276: PUSH
56277: LD_VAR 0 6
56281: ARRAY
56282: PUSH
56283: LD_INT 2
56285: ARRAY
56286: PUSH
56287: LD_VAR 0 9
56291: LESS
56292: IFFALSE 56334
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56294: LD_ADDR_VAR 0 6
56298: PUSH
56299: LD_VAR 0 6
56303: PPUSH
56304: LD_VAR 0 6
56308: PUSH
56309: LD_INT 1
56311: PLUS
56312: PPUSH
56313: LD_VAR 0 7
56317: PUSH
56318: LD_VAR 0 9
56322: PUSH
56323: EMPTY
56324: LIST
56325: LIST
56326: PPUSH
56327: CALL_OW 2
56331: ST_TO_ADDR
56332: GO 56414
// for j = 1 to result do
56334: LD_ADDR_VAR 0 8
56338: PUSH
56339: DOUBLE
56340: LD_INT 1
56342: DEC
56343: ST_TO_ADDR
56344: LD_VAR 0 6
56348: PUSH
56349: FOR_TO
56350: IFFALSE 56412
// begin if tmp < result [ j ] [ 2 ] then
56352: LD_VAR 0 9
56356: PUSH
56357: LD_VAR 0 6
56361: PUSH
56362: LD_VAR 0 8
56366: ARRAY
56367: PUSH
56368: LD_INT 2
56370: ARRAY
56371: LESS
56372: IFFALSE 56410
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56374: LD_ADDR_VAR 0 6
56378: PUSH
56379: LD_VAR 0 6
56383: PPUSH
56384: LD_VAR 0 8
56388: PPUSH
56389: LD_VAR 0 7
56393: PUSH
56394: LD_VAR 0 9
56398: PUSH
56399: EMPTY
56400: LIST
56401: LIST
56402: PPUSH
56403: CALL_OW 2
56407: ST_TO_ADDR
// break ;
56408: GO 56412
// end ; end ;
56410: GO 56349
56412: POP
56413: POP
// end ; end ;
56414: GO 56213
56416: POP
56417: POP
// if result and not asc then
56418: LD_VAR 0 6
56422: PUSH
56423: LD_VAR 0 4
56427: NOT
56428: AND
56429: IFFALSE 56504
// begin tmp := result ;
56431: LD_ADDR_VAR 0 9
56435: PUSH
56436: LD_VAR 0 6
56440: ST_TO_ADDR
// for i = tmp downto 1 do
56441: LD_ADDR_VAR 0 7
56445: PUSH
56446: DOUBLE
56447: LD_VAR 0 9
56451: INC
56452: ST_TO_ADDR
56453: LD_INT 1
56455: PUSH
56456: FOR_DOWNTO
56457: IFFALSE 56502
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56459: LD_ADDR_VAR 0 6
56463: PUSH
56464: LD_VAR 0 6
56468: PPUSH
56469: LD_VAR 0 9
56473: PUSH
56474: LD_VAR 0 7
56478: MINUS
56479: PUSH
56480: LD_INT 1
56482: PLUS
56483: PPUSH
56484: LD_VAR 0 9
56488: PUSH
56489: LD_VAR 0 7
56493: ARRAY
56494: PPUSH
56495: CALL_OW 1
56499: ST_TO_ADDR
56500: GO 56456
56502: POP
56503: POP
// end ; tmp := [ ] ;
56504: LD_ADDR_VAR 0 9
56508: PUSH
56509: EMPTY
56510: ST_TO_ADDR
// if mode then
56511: LD_VAR 0 5
56515: IFFALSE 56584
// begin for i = 1 to result do
56517: LD_ADDR_VAR 0 7
56521: PUSH
56522: DOUBLE
56523: LD_INT 1
56525: DEC
56526: ST_TO_ADDR
56527: LD_VAR 0 6
56531: PUSH
56532: FOR_TO
56533: IFFALSE 56572
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56535: LD_ADDR_VAR 0 9
56539: PUSH
56540: LD_VAR 0 9
56544: PPUSH
56545: LD_VAR 0 7
56549: PPUSH
56550: LD_VAR 0 6
56554: PUSH
56555: LD_VAR 0 7
56559: ARRAY
56560: PUSH
56561: LD_INT 1
56563: ARRAY
56564: PPUSH
56565: CALL_OW 1
56569: ST_TO_ADDR
56570: GO 56532
56572: POP
56573: POP
// result := tmp ;
56574: LD_ADDR_VAR 0 6
56578: PUSH
56579: LD_VAR 0 9
56583: ST_TO_ADDR
// end ; end ;
56584: LD_VAR 0 6
56588: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
56589: LD_INT 0
56591: PPUSH
56592: PPUSH
56593: PPUSH
56594: PPUSH
56595: PPUSH
56596: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
56597: LD_ADDR_VAR 0 5
56601: PUSH
56602: LD_INT 0
56604: PUSH
56605: LD_INT 0
56607: PUSH
56608: LD_INT 0
56610: PUSH
56611: EMPTY
56612: PUSH
56613: EMPTY
56614: LIST
56615: LIST
56616: LIST
56617: LIST
56618: ST_TO_ADDR
// if not x or not y then
56619: LD_VAR 0 2
56623: NOT
56624: PUSH
56625: LD_VAR 0 3
56629: NOT
56630: OR
56631: IFFALSE 56635
// exit ;
56633: GO 58281
// if not range then
56635: LD_VAR 0 4
56639: NOT
56640: IFFALSE 56650
// range := 10 ;
56642: LD_ADDR_VAR 0 4
56646: PUSH
56647: LD_INT 10
56649: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56650: LD_ADDR_VAR 0 8
56654: PUSH
56655: LD_INT 81
56657: PUSH
56658: LD_VAR 0 1
56662: PUSH
56663: EMPTY
56664: LIST
56665: LIST
56666: PUSH
56667: LD_INT 92
56669: PUSH
56670: LD_VAR 0 2
56674: PUSH
56675: LD_VAR 0 3
56679: PUSH
56680: LD_VAR 0 4
56684: PUSH
56685: EMPTY
56686: LIST
56687: LIST
56688: LIST
56689: LIST
56690: PUSH
56691: LD_INT 3
56693: PUSH
56694: LD_INT 21
56696: PUSH
56697: LD_INT 3
56699: PUSH
56700: EMPTY
56701: LIST
56702: LIST
56703: PUSH
56704: EMPTY
56705: LIST
56706: LIST
56707: PUSH
56708: EMPTY
56709: LIST
56710: LIST
56711: LIST
56712: PPUSH
56713: CALL_OW 69
56717: ST_TO_ADDR
// if not tmp then
56718: LD_VAR 0 8
56722: NOT
56723: IFFALSE 56727
// exit ;
56725: GO 58281
// for i in tmp do
56727: LD_ADDR_VAR 0 6
56731: PUSH
56732: LD_VAR 0 8
56736: PUSH
56737: FOR_IN
56738: IFFALSE 58256
// begin points := [ 0 , 0 , 0 ] ;
56740: LD_ADDR_VAR 0 9
56744: PUSH
56745: LD_INT 0
56747: PUSH
56748: LD_INT 0
56750: PUSH
56751: LD_INT 0
56753: PUSH
56754: EMPTY
56755: LIST
56756: LIST
56757: LIST
56758: ST_TO_ADDR
// bpoints := 1 ;
56759: LD_ADDR_VAR 0 10
56763: PUSH
56764: LD_INT 1
56766: ST_TO_ADDR
// case GetType ( i ) of unit_human :
56767: LD_VAR 0 6
56771: PPUSH
56772: CALL_OW 247
56776: PUSH
56777: LD_INT 1
56779: DOUBLE
56780: EQUAL
56781: IFTRUE 56785
56783: GO 57363
56785: POP
// begin if GetClass ( i ) = 1 then
56786: LD_VAR 0 6
56790: PPUSH
56791: CALL_OW 257
56795: PUSH
56796: LD_INT 1
56798: EQUAL
56799: IFFALSE 56820
// points := [ 10 , 5 , 3 ] ;
56801: LD_ADDR_VAR 0 9
56805: PUSH
56806: LD_INT 10
56808: PUSH
56809: LD_INT 5
56811: PUSH
56812: LD_INT 3
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: LIST
56819: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
56820: LD_VAR 0 6
56824: PPUSH
56825: CALL_OW 257
56829: PUSH
56830: LD_INT 2
56832: PUSH
56833: LD_INT 3
56835: PUSH
56836: LD_INT 4
56838: PUSH
56839: EMPTY
56840: LIST
56841: LIST
56842: LIST
56843: IN
56844: IFFALSE 56865
// points := [ 3 , 2 , 1 ] ;
56846: LD_ADDR_VAR 0 9
56850: PUSH
56851: LD_INT 3
56853: PUSH
56854: LD_INT 2
56856: PUSH
56857: LD_INT 1
56859: PUSH
56860: EMPTY
56861: LIST
56862: LIST
56863: LIST
56864: ST_TO_ADDR
// if GetClass ( i ) = 5 then
56865: LD_VAR 0 6
56869: PPUSH
56870: CALL_OW 257
56874: PUSH
56875: LD_INT 5
56877: EQUAL
56878: IFFALSE 56899
// points := [ 130 , 5 , 2 ] ;
56880: LD_ADDR_VAR 0 9
56884: PUSH
56885: LD_INT 130
56887: PUSH
56888: LD_INT 5
56890: PUSH
56891: LD_INT 2
56893: PUSH
56894: EMPTY
56895: LIST
56896: LIST
56897: LIST
56898: ST_TO_ADDR
// if GetClass ( i ) = 8 then
56899: LD_VAR 0 6
56903: PPUSH
56904: CALL_OW 257
56908: PUSH
56909: LD_INT 8
56911: EQUAL
56912: IFFALSE 56933
// points := [ 35 , 35 , 30 ] ;
56914: LD_ADDR_VAR 0 9
56918: PUSH
56919: LD_INT 35
56921: PUSH
56922: LD_INT 35
56924: PUSH
56925: LD_INT 30
56927: PUSH
56928: EMPTY
56929: LIST
56930: LIST
56931: LIST
56932: ST_TO_ADDR
// if GetClass ( i ) = 9 then
56933: LD_VAR 0 6
56937: PPUSH
56938: CALL_OW 257
56942: PUSH
56943: LD_INT 9
56945: EQUAL
56946: IFFALSE 56967
// points := [ 20 , 55 , 40 ] ;
56948: LD_ADDR_VAR 0 9
56952: PUSH
56953: LD_INT 20
56955: PUSH
56956: LD_INT 55
56958: PUSH
56959: LD_INT 40
56961: PUSH
56962: EMPTY
56963: LIST
56964: LIST
56965: LIST
56966: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
56967: LD_VAR 0 6
56971: PPUSH
56972: CALL_OW 257
56976: PUSH
56977: LD_INT 12
56979: PUSH
56980: LD_INT 16
56982: PUSH
56983: EMPTY
56984: LIST
56985: LIST
56986: IN
56987: IFFALSE 57008
// points := [ 5 , 3 , 2 ] ;
56989: LD_ADDR_VAR 0 9
56993: PUSH
56994: LD_INT 5
56996: PUSH
56997: LD_INT 3
56999: PUSH
57000: LD_INT 2
57002: PUSH
57003: EMPTY
57004: LIST
57005: LIST
57006: LIST
57007: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57008: LD_VAR 0 6
57012: PPUSH
57013: CALL_OW 257
57017: PUSH
57018: LD_INT 17
57020: EQUAL
57021: IFFALSE 57042
// points := [ 100 , 50 , 75 ] ;
57023: LD_ADDR_VAR 0 9
57027: PUSH
57028: LD_INT 100
57030: PUSH
57031: LD_INT 50
57033: PUSH
57034: LD_INT 75
57036: PUSH
57037: EMPTY
57038: LIST
57039: LIST
57040: LIST
57041: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57042: LD_VAR 0 6
57046: PPUSH
57047: CALL_OW 257
57051: PUSH
57052: LD_INT 15
57054: EQUAL
57055: IFFALSE 57076
// points := [ 10 , 5 , 3 ] ;
57057: LD_ADDR_VAR 0 9
57061: PUSH
57062: LD_INT 10
57064: PUSH
57065: LD_INT 5
57067: PUSH
57068: LD_INT 3
57070: PUSH
57071: EMPTY
57072: LIST
57073: LIST
57074: LIST
57075: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57076: LD_VAR 0 6
57080: PPUSH
57081: CALL_OW 257
57085: PUSH
57086: LD_INT 14
57088: EQUAL
57089: IFFALSE 57110
// points := [ 10 , 0 , 0 ] ;
57091: LD_ADDR_VAR 0 9
57095: PUSH
57096: LD_INT 10
57098: PUSH
57099: LD_INT 0
57101: PUSH
57102: LD_INT 0
57104: PUSH
57105: EMPTY
57106: LIST
57107: LIST
57108: LIST
57109: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57110: LD_VAR 0 6
57114: PPUSH
57115: CALL_OW 257
57119: PUSH
57120: LD_INT 11
57122: EQUAL
57123: IFFALSE 57144
// points := [ 30 , 10 , 5 ] ;
57125: LD_ADDR_VAR 0 9
57129: PUSH
57130: LD_INT 30
57132: PUSH
57133: LD_INT 10
57135: PUSH
57136: LD_INT 5
57138: PUSH
57139: EMPTY
57140: LIST
57141: LIST
57142: LIST
57143: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57144: LD_VAR 0 1
57148: PPUSH
57149: LD_INT 5
57151: PPUSH
57152: CALL_OW 321
57156: PUSH
57157: LD_INT 2
57159: EQUAL
57160: IFFALSE 57177
// bpoints := bpoints * 1.8 ;
57162: LD_ADDR_VAR 0 10
57166: PUSH
57167: LD_VAR 0 10
57171: PUSH
57172: LD_REAL  1.80000000000000E+0000
57175: MUL
57176: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57177: LD_VAR 0 6
57181: PPUSH
57182: CALL_OW 257
57186: PUSH
57187: LD_INT 1
57189: PUSH
57190: LD_INT 2
57192: PUSH
57193: LD_INT 3
57195: PUSH
57196: LD_INT 4
57198: PUSH
57199: EMPTY
57200: LIST
57201: LIST
57202: LIST
57203: LIST
57204: IN
57205: PUSH
57206: LD_VAR 0 1
57210: PPUSH
57211: LD_INT 51
57213: PPUSH
57214: CALL_OW 321
57218: PUSH
57219: LD_INT 2
57221: EQUAL
57222: AND
57223: IFFALSE 57240
// bpoints := bpoints * 1.2 ;
57225: LD_ADDR_VAR 0 10
57229: PUSH
57230: LD_VAR 0 10
57234: PUSH
57235: LD_REAL  1.20000000000000E+0000
57238: MUL
57239: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57240: LD_VAR 0 6
57244: PPUSH
57245: CALL_OW 257
57249: PUSH
57250: LD_INT 5
57252: PUSH
57253: LD_INT 7
57255: PUSH
57256: LD_INT 9
57258: PUSH
57259: EMPTY
57260: LIST
57261: LIST
57262: LIST
57263: IN
57264: PUSH
57265: LD_VAR 0 1
57269: PPUSH
57270: LD_INT 52
57272: PPUSH
57273: CALL_OW 321
57277: PUSH
57278: LD_INT 2
57280: EQUAL
57281: AND
57282: IFFALSE 57299
// bpoints := bpoints * 1.5 ;
57284: LD_ADDR_VAR 0 10
57288: PUSH
57289: LD_VAR 0 10
57293: PUSH
57294: LD_REAL  1.50000000000000E+0000
57297: MUL
57298: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57299: LD_VAR 0 1
57303: PPUSH
57304: LD_INT 66
57306: PPUSH
57307: CALL_OW 321
57311: PUSH
57312: LD_INT 2
57314: EQUAL
57315: IFFALSE 57332
// bpoints := bpoints * 1.1 ;
57317: LD_ADDR_VAR 0 10
57321: PUSH
57322: LD_VAR 0 10
57326: PUSH
57327: LD_REAL  1.10000000000000E+0000
57330: MUL
57331: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57332: LD_ADDR_VAR 0 10
57336: PUSH
57337: LD_VAR 0 10
57341: PUSH
57342: LD_VAR 0 6
57346: PPUSH
57347: LD_INT 1
57349: PPUSH
57350: CALL_OW 259
57354: PUSH
57355: LD_REAL  1.15000000000000E+0000
57358: MUL
57359: MUL
57360: ST_TO_ADDR
// end ; unit_vehicle :
57361: GO 58185
57363: LD_INT 2
57365: DOUBLE
57366: EQUAL
57367: IFTRUE 57371
57369: GO 58173
57371: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57372: LD_VAR 0 6
57376: PPUSH
57377: CALL_OW 264
57381: PUSH
57382: LD_INT 2
57384: PUSH
57385: LD_INT 42
57387: PUSH
57388: LD_INT 24
57390: PUSH
57391: EMPTY
57392: LIST
57393: LIST
57394: LIST
57395: IN
57396: IFFALSE 57417
// points := [ 25 , 5 , 3 ] ;
57398: LD_ADDR_VAR 0 9
57402: PUSH
57403: LD_INT 25
57405: PUSH
57406: LD_INT 5
57408: PUSH
57409: LD_INT 3
57411: PUSH
57412: EMPTY
57413: LIST
57414: LIST
57415: LIST
57416: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57417: LD_VAR 0 6
57421: PPUSH
57422: CALL_OW 264
57426: PUSH
57427: LD_INT 4
57429: PUSH
57430: LD_INT 43
57432: PUSH
57433: LD_INT 25
57435: PUSH
57436: EMPTY
57437: LIST
57438: LIST
57439: LIST
57440: IN
57441: IFFALSE 57462
// points := [ 40 , 15 , 5 ] ;
57443: LD_ADDR_VAR 0 9
57447: PUSH
57448: LD_INT 40
57450: PUSH
57451: LD_INT 15
57453: PUSH
57454: LD_INT 5
57456: PUSH
57457: EMPTY
57458: LIST
57459: LIST
57460: LIST
57461: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57462: LD_VAR 0 6
57466: PPUSH
57467: CALL_OW 264
57471: PUSH
57472: LD_INT 3
57474: PUSH
57475: LD_INT 23
57477: PUSH
57478: EMPTY
57479: LIST
57480: LIST
57481: IN
57482: IFFALSE 57503
// points := [ 7 , 25 , 8 ] ;
57484: LD_ADDR_VAR 0 9
57488: PUSH
57489: LD_INT 7
57491: PUSH
57492: LD_INT 25
57494: PUSH
57495: LD_INT 8
57497: PUSH
57498: EMPTY
57499: LIST
57500: LIST
57501: LIST
57502: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57503: LD_VAR 0 6
57507: PPUSH
57508: CALL_OW 264
57512: PUSH
57513: LD_INT 5
57515: PUSH
57516: LD_INT 27
57518: PUSH
57519: LD_INT 44
57521: PUSH
57522: EMPTY
57523: LIST
57524: LIST
57525: LIST
57526: IN
57527: IFFALSE 57548
// points := [ 14 , 50 , 16 ] ;
57529: LD_ADDR_VAR 0 9
57533: PUSH
57534: LD_INT 14
57536: PUSH
57537: LD_INT 50
57539: PUSH
57540: LD_INT 16
57542: PUSH
57543: EMPTY
57544: LIST
57545: LIST
57546: LIST
57547: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57548: LD_VAR 0 6
57552: PPUSH
57553: CALL_OW 264
57557: PUSH
57558: LD_INT 6
57560: PUSH
57561: LD_INT 46
57563: PUSH
57564: EMPTY
57565: LIST
57566: LIST
57567: IN
57568: IFFALSE 57589
// points := [ 32 , 120 , 70 ] ;
57570: LD_ADDR_VAR 0 9
57574: PUSH
57575: LD_INT 32
57577: PUSH
57578: LD_INT 120
57580: PUSH
57581: LD_INT 70
57583: PUSH
57584: EMPTY
57585: LIST
57586: LIST
57587: LIST
57588: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
57589: LD_VAR 0 6
57593: PPUSH
57594: CALL_OW 264
57598: PUSH
57599: LD_INT 7
57601: PUSH
57602: LD_INT 28
57604: PUSH
57605: LD_INT 45
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: LIST
57612: IN
57613: IFFALSE 57634
// points := [ 35 , 20 , 45 ] ;
57615: LD_ADDR_VAR 0 9
57619: PUSH
57620: LD_INT 35
57622: PUSH
57623: LD_INT 20
57625: PUSH
57626: LD_INT 45
57628: PUSH
57629: EMPTY
57630: LIST
57631: LIST
57632: LIST
57633: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
57634: LD_VAR 0 6
57638: PPUSH
57639: CALL_OW 264
57643: PUSH
57644: LD_INT 47
57646: PUSH
57647: EMPTY
57648: LIST
57649: IN
57650: IFFALSE 57671
// points := [ 67 , 45 , 75 ] ;
57652: LD_ADDR_VAR 0 9
57656: PUSH
57657: LD_INT 67
57659: PUSH
57660: LD_INT 45
57662: PUSH
57663: LD_INT 75
57665: PUSH
57666: EMPTY
57667: LIST
57668: LIST
57669: LIST
57670: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
57671: LD_VAR 0 6
57675: PPUSH
57676: CALL_OW 264
57680: PUSH
57681: LD_INT 26
57683: PUSH
57684: EMPTY
57685: LIST
57686: IN
57687: IFFALSE 57708
// points := [ 120 , 30 , 80 ] ;
57689: LD_ADDR_VAR 0 9
57693: PUSH
57694: LD_INT 120
57696: PUSH
57697: LD_INT 30
57699: PUSH
57700: LD_INT 80
57702: PUSH
57703: EMPTY
57704: LIST
57705: LIST
57706: LIST
57707: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
57708: LD_VAR 0 6
57712: PPUSH
57713: CALL_OW 264
57717: PUSH
57718: LD_INT 22
57720: PUSH
57721: EMPTY
57722: LIST
57723: IN
57724: IFFALSE 57745
// points := [ 40 , 1 , 1 ] ;
57726: LD_ADDR_VAR 0 9
57730: PUSH
57731: LD_INT 40
57733: PUSH
57734: LD_INT 1
57736: PUSH
57737: LD_INT 1
57739: PUSH
57740: EMPTY
57741: LIST
57742: LIST
57743: LIST
57744: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
57745: LD_VAR 0 6
57749: PPUSH
57750: CALL_OW 264
57754: PUSH
57755: LD_INT 29
57757: PUSH
57758: EMPTY
57759: LIST
57760: IN
57761: IFFALSE 57782
// points := [ 70 , 200 , 400 ] ;
57763: LD_ADDR_VAR 0 9
57767: PUSH
57768: LD_INT 70
57770: PUSH
57771: LD_INT 200
57773: PUSH
57774: LD_INT 400
57776: PUSH
57777: EMPTY
57778: LIST
57779: LIST
57780: LIST
57781: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
57782: LD_VAR 0 6
57786: PPUSH
57787: CALL_OW 264
57791: PUSH
57792: LD_INT 14
57794: PUSH
57795: LD_INT 53
57797: PUSH
57798: EMPTY
57799: LIST
57800: LIST
57801: IN
57802: IFFALSE 57823
// points := [ 40 , 10 , 20 ] ;
57804: LD_ADDR_VAR 0 9
57808: PUSH
57809: LD_INT 40
57811: PUSH
57812: LD_INT 10
57814: PUSH
57815: LD_INT 20
57817: PUSH
57818: EMPTY
57819: LIST
57820: LIST
57821: LIST
57822: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
57823: LD_VAR 0 6
57827: PPUSH
57828: CALL_OW 264
57832: PUSH
57833: LD_INT 9
57835: PUSH
57836: EMPTY
57837: LIST
57838: IN
57839: IFFALSE 57860
// points := [ 5 , 70 , 20 ] ;
57841: LD_ADDR_VAR 0 9
57845: PUSH
57846: LD_INT 5
57848: PUSH
57849: LD_INT 70
57851: PUSH
57852: LD_INT 20
57854: PUSH
57855: EMPTY
57856: LIST
57857: LIST
57858: LIST
57859: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
57860: LD_VAR 0 6
57864: PPUSH
57865: CALL_OW 264
57869: PUSH
57870: LD_INT 10
57872: PUSH
57873: EMPTY
57874: LIST
57875: IN
57876: IFFALSE 57897
// points := [ 35 , 110 , 70 ] ;
57878: LD_ADDR_VAR 0 9
57882: PUSH
57883: LD_INT 35
57885: PUSH
57886: LD_INT 110
57888: PUSH
57889: LD_INT 70
57891: PUSH
57892: EMPTY
57893: LIST
57894: LIST
57895: LIST
57896: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
57897: LD_VAR 0 6
57901: PPUSH
57902: CALL_OW 265
57906: PUSH
57907: LD_INT 25
57909: EQUAL
57910: IFFALSE 57931
// points := [ 80 , 65 , 100 ] ;
57912: LD_ADDR_VAR 0 9
57916: PUSH
57917: LD_INT 80
57919: PUSH
57920: LD_INT 65
57922: PUSH
57923: LD_INT 100
57925: PUSH
57926: EMPTY
57927: LIST
57928: LIST
57929: LIST
57930: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
57931: LD_VAR 0 6
57935: PPUSH
57936: CALL_OW 263
57940: PUSH
57941: LD_INT 1
57943: EQUAL
57944: IFFALSE 57979
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
57946: LD_ADDR_VAR 0 10
57950: PUSH
57951: LD_VAR 0 10
57955: PUSH
57956: LD_VAR 0 6
57960: PPUSH
57961: CALL_OW 311
57965: PPUSH
57966: LD_INT 3
57968: PPUSH
57969: CALL_OW 259
57973: PUSH
57974: LD_INT 4
57976: MUL
57977: MUL
57978: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
57979: LD_VAR 0 6
57983: PPUSH
57984: CALL_OW 263
57988: PUSH
57989: LD_INT 2
57991: EQUAL
57992: IFFALSE 58043
// begin j := IsControledBy ( i ) ;
57994: LD_ADDR_VAR 0 7
57998: PUSH
57999: LD_VAR 0 6
58003: PPUSH
58004: CALL_OW 312
58008: ST_TO_ADDR
// if j then
58009: LD_VAR 0 7
58013: IFFALSE 58043
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58015: LD_ADDR_VAR 0 10
58019: PUSH
58020: LD_VAR 0 10
58024: PUSH
58025: LD_VAR 0 7
58029: PPUSH
58030: LD_INT 3
58032: PPUSH
58033: CALL_OW 259
58037: PUSH
58038: LD_INT 3
58040: MUL
58041: MUL
58042: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58043: LD_VAR 0 6
58047: PPUSH
58048: CALL_OW 264
58052: PUSH
58053: LD_INT 5
58055: PUSH
58056: LD_INT 6
58058: PUSH
58059: LD_INT 46
58061: PUSH
58062: LD_INT 44
58064: PUSH
58065: LD_INT 47
58067: PUSH
58068: LD_INT 45
58070: PUSH
58071: LD_INT 28
58073: PUSH
58074: LD_INT 7
58076: PUSH
58077: LD_INT 27
58079: PUSH
58080: LD_INT 29
58082: PUSH
58083: EMPTY
58084: LIST
58085: LIST
58086: LIST
58087: LIST
58088: LIST
58089: LIST
58090: LIST
58091: LIST
58092: LIST
58093: LIST
58094: IN
58095: PUSH
58096: LD_VAR 0 1
58100: PPUSH
58101: LD_INT 52
58103: PPUSH
58104: CALL_OW 321
58108: PUSH
58109: LD_INT 2
58111: EQUAL
58112: AND
58113: IFFALSE 58130
// bpoints := bpoints * 1.2 ;
58115: LD_ADDR_VAR 0 10
58119: PUSH
58120: LD_VAR 0 10
58124: PUSH
58125: LD_REAL  1.20000000000000E+0000
58128: MUL
58129: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58130: LD_VAR 0 6
58134: PPUSH
58135: CALL_OW 264
58139: PUSH
58140: LD_INT 6
58142: PUSH
58143: LD_INT 46
58145: PUSH
58146: LD_INT 47
58148: PUSH
58149: EMPTY
58150: LIST
58151: LIST
58152: LIST
58153: IN
58154: IFFALSE 58171
// bpoints := bpoints * 1.2 ;
58156: LD_ADDR_VAR 0 10
58160: PUSH
58161: LD_VAR 0 10
58165: PUSH
58166: LD_REAL  1.20000000000000E+0000
58169: MUL
58170: ST_TO_ADDR
// end ; unit_building :
58171: GO 58185
58173: LD_INT 3
58175: DOUBLE
58176: EQUAL
58177: IFTRUE 58181
58179: GO 58184
58181: POP
// ; end ;
58182: GO 58185
58184: POP
// for j = 1 to 3 do
58185: LD_ADDR_VAR 0 7
58189: PUSH
58190: DOUBLE
58191: LD_INT 1
58193: DEC
58194: ST_TO_ADDR
58195: LD_INT 3
58197: PUSH
58198: FOR_TO
58199: IFFALSE 58252
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58201: LD_ADDR_VAR 0 5
58205: PUSH
58206: LD_VAR 0 5
58210: PPUSH
58211: LD_VAR 0 7
58215: PPUSH
58216: LD_VAR 0 5
58220: PUSH
58221: LD_VAR 0 7
58225: ARRAY
58226: PUSH
58227: LD_VAR 0 9
58231: PUSH
58232: LD_VAR 0 7
58236: ARRAY
58237: PUSH
58238: LD_VAR 0 10
58242: MUL
58243: PLUS
58244: PPUSH
58245: CALL_OW 1
58249: ST_TO_ADDR
58250: GO 58198
58252: POP
58253: POP
// end ;
58254: GO 56737
58256: POP
58257: POP
// result := Replace ( result , 4 , tmp ) ;
58258: LD_ADDR_VAR 0 5
58262: PUSH
58263: LD_VAR 0 5
58267: PPUSH
58268: LD_INT 4
58270: PPUSH
58271: LD_VAR 0 8
58275: PPUSH
58276: CALL_OW 1
58280: ST_TO_ADDR
// end ;
58281: LD_VAR 0 5
58285: RET
// export function DangerAtRange ( unit , range ) ; begin
58286: LD_INT 0
58288: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58289: LD_ADDR_VAR 0 3
58293: PUSH
58294: LD_VAR 0 1
58298: PPUSH
58299: CALL_OW 255
58303: PPUSH
58304: LD_VAR 0 1
58308: PPUSH
58309: CALL_OW 250
58313: PPUSH
58314: LD_VAR 0 1
58318: PPUSH
58319: CALL_OW 251
58323: PPUSH
58324: LD_VAR 0 2
58328: PPUSH
58329: CALL 56589 0 4
58333: ST_TO_ADDR
// end ;
58334: LD_VAR 0 3
58338: RET
// export function DangerInArea ( side , area ) ; begin
58339: LD_INT 0
58341: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58342: LD_ADDR_VAR 0 3
58346: PUSH
58347: LD_VAR 0 2
58351: PPUSH
58352: LD_INT 81
58354: PUSH
58355: LD_VAR 0 1
58359: PUSH
58360: EMPTY
58361: LIST
58362: LIST
58363: PPUSH
58364: CALL_OW 70
58368: ST_TO_ADDR
// end ;
58369: LD_VAR 0 3
58373: RET
// export function IsExtension ( b ) ; begin
58374: LD_INT 0
58376: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58377: LD_ADDR_VAR 0 2
58381: PUSH
58382: LD_VAR 0 1
58386: PUSH
58387: LD_INT 23
58389: PUSH
58390: LD_INT 20
58392: PUSH
58393: LD_INT 22
58395: PUSH
58396: LD_INT 17
58398: PUSH
58399: LD_INT 24
58401: PUSH
58402: LD_INT 21
58404: PUSH
58405: LD_INT 19
58407: PUSH
58408: LD_INT 16
58410: PUSH
58411: LD_INT 25
58413: PUSH
58414: LD_INT 18
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: LIST
58421: LIST
58422: LIST
58423: LIST
58424: LIST
58425: LIST
58426: LIST
58427: LIST
58428: IN
58429: ST_TO_ADDR
// end ;
58430: LD_VAR 0 2
58434: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
58435: LD_INT 0
58437: PPUSH
58438: PPUSH
58439: PPUSH
// result := [ ] ;
58440: LD_ADDR_VAR 0 3
58444: PUSH
58445: EMPTY
58446: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58447: LD_ADDR_VAR 0 4
58451: PUSH
58452: LD_VAR 0 2
58456: PPUSH
58457: LD_INT 21
58459: PUSH
58460: LD_INT 3
58462: PUSH
58463: EMPTY
58464: LIST
58465: LIST
58466: PPUSH
58467: CALL_OW 70
58471: ST_TO_ADDR
// if not tmp then
58472: LD_VAR 0 4
58476: NOT
58477: IFFALSE 58481
// exit ;
58479: GO 58539
// for i in tmp do
58481: LD_ADDR_VAR 0 5
58485: PUSH
58486: LD_VAR 0 4
58490: PUSH
58491: FOR_IN
58492: IFFALSE 58527
// if GetBase ( i ) <> base then
58494: LD_VAR 0 5
58498: PPUSH
58499: CALL_OW 274
58503: PUSH
58504: LD_VAR 0 1
58508: NONEQUAL
58509: IFFALSE 58525
// ComLinkToBase ( base , i ) ;
58511: LD_VAR 0 1
58515: PPUSH
58516: LD_VAR 0 5
58520: PPUSH
58521: CALL_OW 169
58525: GO 58491
58527: POP
58528: POP
// result := tmp ;
58529: LD_ADDR_VAR 0 3
58533: PUSH
58534: LD_VAR 0 4
58538: ST_TO_ADDR
// end ;
58539: LD_VAR 0 3
58543: RET
// export function ComComplete ( unit , b ) ; var i ; begin
58544: LD_INT 0
58546: PPUSH
58547: PPUSH
// if BuildingStatus ( b ) = bs_build then
58548: LD_VAR 0 2
58552: PPUSH
58553: CALL_OW 461
58557: PUSH
58558: LD_INT 1
58560: EQUAL
58561: IFFALSE 58621
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
58563: LD_VAR 0 1
58567: PPUSH
58568: LD_STRING h
58570: PUSH
58571: LD_VAR 0 2
58575: PPUSH
58576: CALL_OW 250
58580: PUSH
58581: LD_VAR 0 2
58585: PPUSH
58586: CALL_OW 251
58590: PUSH
58591: LD_VAR 0 2
58595: PUSH
58596: LD_INT 0
58598: PUSH
58599: LD_INT 0
58601: PUSH
58602: LD_INT 0
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: LIST
58609: LIST
58610: LIST
58611: LIST
58612: LIST
58613: PUSH
58614: EMPTY
58615: LIST
58616: PPUSH
58617: CALL_OW 446
// end ;
58621: LD_VAR 0 3
58625: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
58626: LD_INT 0
58628: PPUSH
58629: PPUSH
58630: PPUSH
58631: PPUSH
58632: PPUSH
58633: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
58634: LD_VAR 0 1
58638: NOT
58639: PUSH
58640: LD_VAR 0 1
58644: PPUSH
58645: CALL_OW 263
58649: PUSH
58650: LD_INT 2
58652: EQUAL
58653: NOT
58654: OR
58655: IFFALSE 58659
// exit ;
58657: GO 58975
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
58659: LD_ADDR_VAR 0 6
58663: PUSH
58664: LD_INT 22
58666: PUSH
58667: LD_VAR 0 1
58671: PPUSH
58672: CALL_OW 255
58676: PUSH
58677: EMPTY
58678: LIST
58679: LIST
58680: PUSH
58681: LD_INT 2
58683: PUSH
58684: LD_INT 30
58686: PUSH
58687: LD_INT 36
58689: PUSH
58690: EMPTY
58691: LIST
58692: LIST
58693: PUSH
58694: LD_INT 34
58696: PUSH
58697: LD_INT 31
58699: PUSH
58700: EMPTY
58701: LIST
58702: LIST
58703: PUSH
58704: EMPTY
58705: LIST
58706: LIST
58707: LIST
58708: PUSH
58709: EMPTY
58710: LIST
58711: LIST
58712: PPUSH
58713: CALL_OW 69
58717: ST_TO_ADDR
// if not tmp then
58718: LD_VAR 0 6
58722: NOT
58723: IFFALSE 58727
// exit ;
58725: GO 58975
// result := [ ] ;
58727: LD_ADDR_VAR 0 2
58731: PUSH
58732: EMPTY
58733: ST_TO_ADDR
// for i in tmp do
58734: LD_ADDR_VAR 0 3
58738: PUSH
58739: LD_VAR 0 6
58743: PUSH
58744: FOR_IN
58745: IFFALSE 58816
// begin t := UnitsInside ( i ) ;
58747: LD_ADDR_VAR 0 4
58751: PUSH
58752: LD_VAR 0 3
58756: PPUSH
58757: CALL_OW 313
58761: ST_TO_ADDR
// if t then
58762: LD_VAR 0 4
58766: IFFALSE 58814
// for j in t do
58768: LD_ADDR_VAR 0 7
58772: PUSH
58773: LD_VAR 0 4
58777: PUSH
58778: FOR_IN
58779: IFFALSE 58812
// result := Insert ( result , result + 1 , j ) ;
58781: LD_ADDR_VAR 0 2
58785: PUSH
58786: LD_VAR 0 2
58790: PPUSH
58791: LD_VAR 0 2
58795: PUSH
58796: LD_INT 1
58798: PLUS
58799: PPUSH
58800: LD_VAR 0 7
58804: PPUSH
58805: CALL_OW 2
58809: ST_TO_ADDR
58810: GO 58778
58812: POP
58813: POP
// end ;
58814: GO 58744
58816: POP
58817: POP
// if not result then
58818: LD_VAR 0 2
58822: NOT
58823: IFFALSE 58827
// exit ;
58825: GO 58975
// mech := result [ 1 ] ;
58827: LD_ADDR_VAR 0 5
58831: PUSH
58832: LD_VAR 0 2
58836: PUSH
58837: LD_INT 1
58839: ARRAY
58840: ST_TO_ADDR
// if result > 1 then
58841: LD_VAR 0 2
58845: PUSH
58846: LD_INT 1
58848: GREATER
58849: IFFALSE 58961
// for i = 2 to result do
58851: LD_ADDR_VAR 0 3
58855: PUSH
58856: DOUBLE
58857: LD_INT 2
58859: DEC
58860: ST_TO_ADDR
58861: LD_VAR 0 2
58865: PUSH
58866: FOR_TO
58867: IFFALSE 58959
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
58869: LD_ADDR_VAR 0 4
58873: PUSH
58874: LD_VAR 0 2
58878: PUSH
58879: LD_VAR 0 3
58883: ARRAY
58884: PPUSH
58885: LD_INT 3
58887: PPUSH
58888: CALL_OW 259
58892: PUSH
58893: LD_VAR 0 2
58897: PUSH
58898: LD_VAR 0 3
58902: ARRAY
58903: PPUSH
58904: CALL_OW 432
58908: MINUS
58909: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
58910: LD_VAR 0 4
58914: PUSH
58915: LD_VAR 0 5
58919: PPUSH
58920: LD_INT 3
58922: PPUSH
58923: CALL_OW 259
58927: PUSH
58928: LD_VAR 0 5
58932: PPUSH
58933: CALL_OW 432
58937: MINUS
58938: GREATEREQUAL
58939: IFFALSE 58957
// mech := result [ i ] ;
58941: LD_ADDR_VAR 0 5
58945: PUSH
58946: LD_VAR 0 2
58950: PUSH
58951: LD_VAR 0 3
58955: ARRAY
58956: ST_TO_ADDR
// end ;
58957: GO 58866
58959: POP
58960: POP
// ComLinkTo ( vehicle , mech ) ;
58961: LD_VAR 0 1
58965: PPUSH
58966: LD_VAR 0 5
58970: PPUSH
58971: CALL_OW 135
// end ;
58975: LD_VAR 0 2
58979: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
58980: LD_INT 0
58982: PPUSH
58983: PPUSH
58984: PPUSH
58985: PPUSH
58986: PPUSH
58987: PPUSH
58988: PPUSH
58989: PPUSH
58990: PPUSH
58991: PPUSH
58992: PPUSH
58993: PPUSH
58994: PPUSH
// result := [ ] ;
58995: LD_ADDR_VAR 0 7
58999: PUSH
59000: EMPTY
59001: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59002: LD_VAR 0 1
59006: PPUSH
59007: CALL_OW 266
59011: PUSH
59012: LD_INT 0
59014: PUSH
59015: LD_INT 1
59017: PUSH
59018: EMPTY
59019: LIST
59020: LIST
59021: IN
59022: NOT
59023: IFFALSE 59027
// exit ;
59025: GO 60658
// if name then
59027: LD_VAR 0 3
59031: IFFALSE 59047
// SetBName ( base_dep , name ) ;
59033: LD_VAR 0 1
59037: PPUSH
59038: LD_VAR 0 3
59042: PPUSH
59043: CALL_OW 500
// base := GetBase ( base_dep ) ;
59047: LD_ADDR_VAR 0 15
59051: PUSH
59052: LD_VAR 0 1
59056: PPUSH
59057: CALL_OW 274
59061: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59062: LD_ADDR_VAR 0 16
59066: PUSH
59067: LD_VAR 0 1
59071: PPUSH
59072: CALL_OW 255
59076: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59077: LD_ADDR_VAR 0 17
59081: PUSH
59082: LD_VAR 0 1
59086: PPUSH
59087: CALL_OW 248
59091: ST_TO_ADDR
// if sources then
59092: LD_VAR 0 5
59096: IFFALSE 59143
// for i = 1 to 3 do
59098: LD_ADDR_VAR 0 8
59102: PUSH
59103: DOUBLE
59104: LD_INT 1
59106: DEC
59107: ST_TO_ADDR
59108: LD_INT 3
59110: PUSH
59111: FOR_TO
59112: IFFALSE 59141
// AddResourceType ( base , i , sources [ i ] ) ;
59114: LD_VAR 0 15
59118: PPUSH
59119: LD_VAR 0 8
59123: PPUSH
59124: LD_VAR 0 5
59128: PUSH
59129: LD_VAR 0 8
59133: ARRAY
59134: PPUSH
59135: CALL_OW 276
59139: GO 59111
59141: POP
59142: POP
// buildings := GetBaseBuildings ( base , area ) ;
59143: LD_ADDR_VAR 0 18
59147: PUSH
59148: LD_VAR 0 15
59152: PPUSH
59153: LD_VAR 0 2
59157: PPUSH
59158: CALL 58435 0 2
59162: ST_TO_ADDR
// InitHc ;
59163: CALL_OW 19
// InitUc ;
59167: CALL_OW 18
// uc_side := side ;
59171: LD_ADDR_OWVAR 20
59175: PUSH
59176: LD_VAR 0 16
59180: ST_TO_ADDR
// uc_nation := nation ;
59181: LD_ADDR_OWVAR 21
59185: PUSH
59186: LD_VAR 0 17
59190: ST_TO_ADDR
// if buildings then
59191: LD_VAR 0 18
59195: IFFALSE 60517
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59197: LD_ADDR_VAR 0 19
59201: PUSH
59202: LD_VAR 0 18
59206: PPUSH
59207: LD_INT 2
59209: PUSH
59210: LD_INT 30
59212: PUSH
59213: LD_INT 29
59215: PUSH
59216: EMPTY
59217: LIST
59218: LIST
59219: PUSH
59220: LD_INT 30
59222: PUSH
59223: LD_INT 30
59225: PUSH
59226: EMPTY
59227: LIST
59228: LIST
59229: PUSH
59230: EMPTY
59231: LIST
59232: LIST
59233: LIST
59234: PPUSH
59235: CALL_OW 72
59239: ST_TO_ADDR
// if tmp then
59240: LD_VAR 0 19
59244: IFFALSE 59292
// for i in tmp do
59246: LD_ADDR_VAR 0 8
59250: PUSH
59251: LD_VAR 0 19
59255: PUSH
59256: FOR_IN
59257: IFFALSE 59290
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59259: LD_VAR 0 8
59263: PPUSH
59264: CALL_OW 250
59268: PPUSH
59269: LD_VAR 0 8
59273: PPUSH
59274: CALL_OW 251
59278: PPUSH
59279: LD_VAR 0 16
59283: PPUSH
59284: CALL_OW 441
59288: GO 59256
59290: POP
59291: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59292: LD_VAR 0 18
59296: PPUSH
59297: LD_INT 2
59299: PUSH
59300: LD_INT 30
59302: PUSH
59303: LD_INT 32
59305: PUSH
59306: EMPTY
59307: LIST
59308: LIST
59309: PUSH
59310: LD_INT 30
59312: PUSH
59313: LD_INT 33
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: PUSH
59320: EMPTY
59321: LIST
59322: LIST
59323: LIST
59324: PPUSH
59325: CALL_OW 72
59329: IFFALSE 59417
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59331: LD_ADDR_VAR 0 8
59335: PUSH
59336: LD_VAR 0 18
59340: PPUSH
59341: LD_INT 2
59343: PUSH
59344: LD_INT 30
59346: PUSH
59347: LD_INT 32
59349: PUSH
59350: EMPTY
59351: LIST
59352: LIST
59353: PUSH
59354: LD_INT 30
59356: PUSH
59357: LD_INT 33
59359: PUSH
59360: EMPTY
59361: LIST
59362: LIST
59363: PUSH
59364: EMPTY
59365: LIST
59366: LIST
59367: LIST
59368: PPUSH
59369: CALL_OW 72
59373: PUSH
59374: FOR_IN
59375: IFFALSE 59415
// begin if not GetBWeapon ( i ) then
59377: LD_VAR 0 8
59381: PPUSH
59382: CALL_OW 269
59386: NOT
59387: IFFALSE 59413
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59389: LD_VAR 0 8
59393: PPUSH
59394: LD_VAR 0 8
59398: PPUSH
59399: LD_VAR 0 2
59403: PPUSH
59404: CALL 60663 0 2
59408: PPUSH
59409: CALL_OW 431
// end ;
59413: GO 59374
59415: POP
59416: POP
// end ; for i = 1 to personel do
59417: LD_ADDR_VAR 0 8
59421: PUSH
59422: DOUBLE
59423: LD_INT 1
59425: DEC
59426: ST_TO_ADDR
59427: LD_VAR 0 6
59431: PUSH
59432: FOR_TO
59433: IFFALSE 60497
// begin if i > 4 then
59435: LD_VAR 0 8
59439: PUSH
59440: LD_INT 4
59442: GREATER
59443: IFFALSE 59447
// break ;
59445: GO 60497
// case i of 1 :
59447: LD_VAR 0 8
59451: PUSH
59452: LD_INT 1
59454: DOUBLE
59455: EQUAL
59456: IFTRUE 59460
59458: GO 59540
59460: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59461: LD_ADDR_VAR 0 12
59465: PUSH
59466: LD_VAR 0 18
59470: PPUSH
59471: LD_INT 22
59473: PUSH
59474: LD_VAR 0 16
59478: PUSH
59479: EMPTY
59480: LIST
59481: LIST
59482: PUSH
59483: LD_INT 58
59485: PUSH
59486: EMPTY
59487: LIST
59488: PUSH
59489: LD_INT 2
59491: PUSH
59492: LD_INT 30
59494: PUSH
59495: LD_INT 32
59497: PUSH
59498: EMPTY
59499: LIST
59500: LIST
59501: PUSH
59502: LD_INT 30
59504: PUSH
59505: LD_INT 4
59507: PUSH
59508: EMPTY
59509: LIST
59510: LIST
59511: PUSH
59512: LD_INT 30
59514: PUSH
59515: LD_INT 5
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: LIST
59526: LIST
59527: PUSH
59528: EMPTY
59529: LIST
59530: LIST
59531: LIST
59532: PPUSH
59533: CALL_OW 72
59537: ST_TO_ADDR
59538: GO 59762
59540: LD_INT 2
59542: DOUBLE
59543: EQUAL
59544: IFTRUE 59548
59546: GO 59610
59548: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
59549: LD_ADDR_VAR 0 12
59553: PUSH
59554: LD_VAR 0 18
59558: PPUSH
59559: LD_INT 22
59561: PUSH
59562: LD_VAR 0 16
59566: PUSH
59567: EMPTY
59568: LIST
59569: LIST
59570: PUSH
59571: LD_INT 2
59573: PUSH
59574: LD_INT 30
59576: PUSH
59577: LD_INT 0
59579: PUSH
59580: EMPTY
59581: LIST
59582: LIST
59583: PUSH
59584: LD_INT 30
59586: PUSH
59587: LD_INT 1
59589: PUSH
59590: EMPTY
59591: LIST
59592: LIST
59593: PUSH
59594: EMPTY
59595: LIST
59596: LIST
59597: LIST
59598: PUSH
59599: EMPTY
59600: LIST
59601: LIST
59602: PPUSH
59603: CALL_OW 72
59607: ST_TO_ADDR
59608: GO 59762
59610: LD_INT 3
59612: DOUBLE
59613: EQUAL
59614: IFTRUE 59618
59616: GO 59680
59618: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
59619: LD_ADDR_VAR 0 12
59623: PUSH
59624: LD_VAR 0 18
59628: PPUSH
59629: LD_INT 22
59631: PUSH
59632: LD_VAR 0 16
59636: PUSH
59637: EMPTY
59638: LIST
59639: LIST
59640: PUSH
59641: LD_INT 2
59643: PUSH
59644: LD_INT 30
59646: PUSH
59647: LD_INT 2
59649: PUSH
59650: EMPTY
59651: LIST
59652: LIST
59653: PUSH
59654: LD_INT 30
59656: PUSH
59657: LD_INT 3
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: PUSH
59664: EMPTY
59665: LIST
59666: LIST
59667: LIST
59668: PUSH
59669: EMPTY
59670: LIST
59671: LIST
59672: PPUSH
59673: CALL_OW 72
59677: ST_TO_ADDR
59678: GO 59762
59680: LD_INT 4
59682: DOUBLE
59683: EQUAL
59684: IFTRUE 59688
59686: GO 59761
59688: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
59689: LD_ADDR_VAR 0 12
59693: PUSH
59694: LD_VAR 0 18
59698: PPUSH
59699: LD_INT 22
59701: PUSH
59702: LD_VAR 0 16
59706: PUSH
59707: EMPTY
59708: LIST
59709: LIST
59710: PUSH
59711: LD_INT 2
59713: PUSH
59714: LD_INT 30
59716: PUSH
59717: LD_INT 6
59719: PUSH
59720: EMPTY
59721: LIST
59722: LIST
59723: PUSH
59724: LD_INT 30
59726: PUSH
59727: LD_INT 7
59729: PUSH
59730: EMPTY
59731: LIST
59732: LIST
59733: PUSH
59734: LD_INT 30
59736: PUSH
59737: LD_INT 8
59739: PUSH
59740: EMPTY
59741: LIST
59742: LIST
59743: PUSH
59744: EMPTY
59745: LIST
59746: LIST
59747: LIST
59748: LIST
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: PPUSH
59754: CALL_OW 72
59758: ST_TO_ADDR
59759: GO 59762
59761: POP
// if i = 1 then
59762: LD_VAR 0 8
59766: PUSH
59767: LD_INT 1
59769: EQUAL
59770: IFFALSE 59881
// begin tmp := [ ] ;
59772: LD_ADDR_VAR 0 19
59776: PUSH
59777: EMPTY
59778: ST_TO_ADDR
// for j in f do
59779: LD_ADDR_VAR 0 9
59783: PUSH
59784: LD_VAR 0 12
59788: PUSH
59789: FOR_IN
59790: IFFALSE 59863
// if GetBType ( j ) = b_bunker then
59792: LD_VAR 0 9
59796: PPUSH
59797: CALL_OW 266
59801: PUSH
59802: LD_INT 32
59804: EQUAL
59805: IFFALSE 59832
// tmp := Insert ( tmp , 1 , j ) else
59807: LD_ADDR_VAR 0 19
59811: PUSH
59812: LD_VAR 0 19
59816: PPUSH
59817: LD_INT 1
59819: PPUSH
59820: LD_VAR 0 9
59824: PPUSH
59825: CALL_OW 2
59829: ST_TO_ADDR
59830: GO 59861
// tmp := Insert ( tmp , tmp + 1 , j ) ;
59832: LD_ADDR_VAR 0 19
59836: PUSH
59837: LD_VAR 0 19
59841: PPUSH
59842: LD_VAR 0 19
59846: PUSH
59847: LD_INT 1
59849: PLUS
59850: PPUSH
59851: LD_VAR 0 9
59855: PPUSH
59856: CALL_OW 2
59860: ST_TO_ADDR
59861: GO 59789
59863: POP
59864: POP
// if tmp then
59865: LD_VAR 0 19
59869: IFFALSE 59881
// f := tmp ;
59871: LD_ADDR_VAR 0 12
59875: PUSH
59876: LD_VAR 0 19
59880: ST_TO_ADDR
// end ; x := personel [ i ] ;
59881: LD_ADDR_VAR 0 13
59885: PUSH
59886: LD_VAR 0 6
59890: PUSH
59891: LD_VAR 0 8
59895: ARRAY
59896: ST_TO_ADDR
// if x = - 1 then
59897: LD_VAR 0 13
59901: PUSH
59902: LD_INT 1
59904: NEG
59905: EQUAL
59906: IFFALSE 60115
// begin for j in f do
59908: LD_ADDR_VAR 0 9
59912: PUSH
59913: LD_VAR 0 12
59917: PUSH
59918: FOR_IN
59919: IFFALSE 60111
// repeat InitHc ;
59921: CALL_OW 19
// if GetBType ( j ) = b_barracks then
59925: LD_VAR 0 9
59929: PPUSH
59930: CALL_OW 266
59934: PUSH
59935: LD_INT 5
59937: EQUAL
59938: IFFALSE 60008
// begin if UnitsInside ( j ) < 3 then
59940: LD_VAR 0 9
59944: PPUSH
59945: CALL_OW 313
59949: PUSH
59950: LD_INT 3
59952: LESS
59953: IFFALSE 59989
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59955: LD_INT 0
59957: PPUSH
59958: LD_INT 5
59960: PUSH
59961: LD_INT 8
59963: PUSH
59964: LD_INT 9
59966: PUSH
59967: EMPTY
59968: LIST
59969: LIST
59970: LIST
59971: PUSH
59972: LD_VAR 0 17
59976: ARRAY
59977: PPUSH
59978: LD_VAR 0 4
59982: PPUSH
59983: CALL_OW 380
59987: GO 60006
// PrepareHuman ( false , i , skill ) ;
59989: LD_INT 0
59991: PPUSH
59992: LD_VAR 0 8
59996: PPUSH
59997: LD_VAR 0 4
60001: PPUSH
60002: CALL_OW 380
// end else
60006: GO 60025
// PrepareHuman ( false , i , skill ) ;
60008: LD_INT 0
60010: PPUSH
60011: LD_VAR 0 8
60015: PPUSH
60016: LD_VAR 0 4
60020: PPUSH
60021: CALL_OW 380
// un := CreateHuman ;
60025: LD_ADDR_VAR 0 14
60029: PUSH
60030: CALL_OW 44
60034: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60035: LD_ADDR_VAR 0 7
60039: PUSH
60040: LD_VAR 0 7
60044: PPUSH
60045: LD_INT 1
60047: PPUSH
60048: LD_VAR 0 14
60052: PPUSH
60053: CALL_OW 2
60057: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60058: LD_VAR 0 14
60062: PPUSH
60063: LD_VAR 0 9
60067: PPUSH
60068: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60072: LD_VAR 0 9
60076: PPUSH
60077: CALL_OW 313
60081: PUSH
60082: LD_INT 6
60084: EQUAL
60085: PUSH
60086: LD_VAR 0 9
60090: PPUSH
60091: CALL_OW 266
60095: PUSH
60096: LD_INT 32
60098: PUSH
60099: LD_INT 31
60101: PUSH
60102: EMPTY
60103: LIST
60104: LIST
60105: IN
60106: OR
60107: IFFALSE 59921
60109: GO 59918
60111: POP
60112: POP
// end else
60113: GO 60495
// for j = 1 to x do
60115: LD_ADDR_VAR 0 9
60119: PUSH
60120: DOUBLE
60121: LD_INT 1
60123: DEC
60124: ST_TO_ADDR
60125: LD_VAR 0 13
60129: PUSH
60130: FOR_TO
60131: IFFALSE 60493
// begin InitHc ;
60133: CALL_OW 19
// if not f then
60137: LD_VAR 0 12
60141: NOT
60142: IFFALSE 60231
// begin PrepareHuman ( false , i , skill ) ;
60144: LD_INT 0
60146: PPUSH
60147: LD_VAR 0 8
60151: PPUSH
60152: LD_VAR 0 4
60156: PPUSH
60157: CALL_OW 380
// un := CreateHuman ;
60161: LD_ADDR_VAR 0 14
60165: PUSH
60166: CALL_OW 44
60170: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60171: LD_ADDR_VAR 0 7
60175: PUSH
60176: LD_VAR 0 7
60180: PPUSH
60181: LD_INT 1
60183: PPUSH
60184: LD_VAR 0 14
60188: PPUSH
60189: CALL_OW 2
60193: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60194: LD_VAR 0 14
60198: PPUSH
60199: LD_VAR 0 1
60203: PPUSH
60204: CALL_OW 250
60208: PPUSH
60209: LD_VAR 0 1
60213: PPUSH
60214: CALL_OW 251
60218: PPUSH
60219: LD_INT 10
60221: PPUSH
60222: LD_INT 0
60224: PPUSH
60225: CALL_OW 50
// continue ;
60229: GO 60130
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60231: LD_VAR 0 12
60235: PUSH
60236: LD_INT 1
60238: ARRAY
60239: PPUSH
60240: CALL_OW 313
60244: PUSH
60245: LD_VAR 0 12
60249: PUSH
60250: LD_INT 1
60252: ARRAY
60253: PPUSH
60254: CALL_OW 266
60258: PUSH
60259: LD_INT 32
60261: PUSH
60262: LD_INT 31
60264: PUSH
60265: EMPTY
60266: LIST
60267: LIST
60268: IN
60269: AND
60270: PUSH
60271: LD_VAR 0 12
60275: PUSH
60276: LD_INT 1
60278: ARRAY
60279: PPUSH
60280: CALL_OW 313
60284: PUSH
60285: LD_INT 6
60287: EQUAL
60288: OR
60289: IFFALSE 60309
// f := Delete ( f , 1 ) ;
60291: LD_ADDR_VAR 0 12
60295: PUSH
60296: LD_VAR 0 12
60300: PPUSH
60301: LD_INT 1
60303: PPUSH
60304: CALL_OW 3
60308: ST_TO_ADDR
// if not f then
60309: LD_VAR 0 12
60313: NOT
60314: IFFALSE 60332
// begin x := x + 2 ;
60316: LD_ADDR_VAR 0 13
60320: PUSH
60321: LD_VAR 0 13
60325: PUSH
60326: LD_INT 2
60328: PLUS
60329: ST_TO_ADDR
// continue ;
60330: GO 60130
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60332: LD_VAR 0 12
60336: PUSH
60337: LD_INT 1
60339: ARRAY
60340: PPUSH
60341: CALL_OW 266
60345: PUSH
60346: LD_INT 5
60348: EQUAL
60349: IFFALSE 60423
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60351: LD_VAR 0 12
60355: PUSH
60356: LD_INT 1
60358: ARRAY
60359: PPUSH
60360: CALL_OW 313
60364: PUSH
60365: LD_INT 3
60367: LESS
60368: IFFALSE 60404
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60370: LD_INT 0
60372: PPUSH
60373: LD_INT 5
60375: PUSH
60376: LD_INT 8
60378: PUSH
60379: LD_INT 9
60381: PUSH
60382: EMPTY
60383: LIST
60384: LIST
60385: LIST
60386: PUSH
60387: LD_VAR 0 17
60391: ARRAY
60392: PPUSH
60393: LD_VAR 0 4
60397: PPUSH
60398: CALL_OW 380
60402: GO 60421
// PrepareHuman ( false , i , skill ) ;
60404: LD_INT 0
60406: PPUSH
60407: LD_VAR 0 8
60411: PPUSH
60412: LD_VAR 0 4
60416: PPUSH
60417: CALL_OW 380
// end else
60421: GO 60440
// PrepareHuman ( false , i , skill ) ;
60423: LD_INT 0
60425: PPUSH
60426: LD_VAR 0 8
60430: PPUSH
60431: LD_VAR 0 4
60435: PPUSH
60436: CALL_OW 380
// un := CreateHuman ;
60440: LD_ADDR_VAR 0 14
60444: PUSH
60445: CALL_OW 44
60449: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60450: LD_ADDR_VAR 0 7
60454: PUSH
60455: LD_VAR 0 7
60459: PPUSH
60460: LD_INT 1
60462: PPUSH
60463: LD_VAR 0 14
60467: PPUSH
60468: CALL_OW 2
60472: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60473: LD_VAR 0 14
60477: PPUSH
60478: LD_VAR 0 12
60482: PUSH
60483: LD_INT 1
60485: ARRAY
60486: PPUSH
60487: CALL_OW 52
// end ;
60491: GO 60130
60493: POP
60494: POP
// end ;
60495: GO 59432
60497: POP
60498: POP
// result := result ^ buildings ;
60499: LD_ADDR_VAR 0 7
60503: PUSH
60504: LD_VAR 0 7
60508: PUSH
60509: LD_VAR 0 18
60513: ADD
60514: ST_TO_ADDR
// end else
60515: GO 60658
// begin for i = 1 to personel do
60517: LD_ADDR_VAR 0 8
60521: PUSH
60522: DOUBLE
60523: LD_INT 1
60525: DEC
60526: ST_TO_ADDR
60527: LD_VAR 0 6
60531: PUSH
60532: FOR_TO
60533: IFFALSE 60656
// begin if i > 4 then
60535: LD_VAR 0 8
60539: PUSH
60540: LD_INT 4
60542: GREATER
60543: IFFALSE 60547
// break ;
60545: GO 60656
// x := personel [ i ] ;
60547: LD_ADDR_VAR 0 13
60551: PUSH
60552: LD_VAR 0 6
60556: PUSH
60557: LD_VAR 0 8
60561: ARRAY
60562: ST_TO_ADDR
// if x = - 1 then
60563: LD_VAR 0 13
60567: PUSH
60568: LD_INT 1
60570: NEG
60571: EQUAL
60572: IFFALSE 60576
// continue ;
60574: GO 60532
// PrepareHuman ( false , i , skill ) ;
60576: LD_INT 0
60578: PPUSH
60579: LD_VAR 0 8
60583: PPUSH
60584: LD_VAR 0 4
60588: PPUSH
60589: CALL_OW 380
// un := CreateHuman ;
60593: LD_ADDR_VAR 0 14
60597: PUSH
60598: CALL_OW 44
60602: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60603: LD_VAR 0 14
60607: PPUSH
60608: LD_VAR 0 1
60612: PPUSH
60613: CALL_OW 250
60617: PPUSH
60618: LD_VAR 0 1
60622: PPUSH
60623: CALL_OW 251
60627: PPUSH
60628: LD_INT 10
60630: PPUSH
60631: LD_INT 0
60633: PPUSH
60634: CALL_OW 50
// result := result ^ un ;
60638: LD_ADDR_VAR 0 7
60642: PUSH
60643: LD_VAR 0 7
60647: PUSH
60648: LD_VAR 0 14
60652: ADD
60653: ST_TO_ADDR
// end ;
60654: GO 60532
60656: POP
60657: POP
// end ; end ;
60658: LD_VAR 0 7
60662: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
60663: LD_INT 0
60665: PPUSH
60666: PPUSH
60667: PPUSH
60668: PPUSH
60669: PPUSH
60670: PPUSH
60671: PPUSH
60672: PPUSH
60673: PPUSH
60674: PPUSH
60675: PPUSH
60676: PPUSH
60677: PPUSH
60678: PPUSH
60679: PPUSH
60680: PPUSH
// result := false ;
60681: LD_ADDR_VAR 0 3
60685: PUSH
60686: LD_INT 0
60688: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
60689: LD_VAR 0 1
60693: NOT
60694: PUSH
60695: LD_VAR 0 1
60699: PPUSH
60700: CALL_OW 266
60704: PUSH
60705: LD_INT 32
60707: PUSH
60708: LD_INT 33
60710: PUSH
60711: EMPTY
60712: LIST
60713: LIST
60714: IN
60715: NOT
60716: OR
60717: IFFALSE 60721
// exit ;
60719: GO 61857
// nat := GetNation ( tower ) ;
60721: LD_ADDR_VAR 0 12
60725: PUSH
60726: LD_VAR 0 1
60730: PPUSH
60731: CALL_OW 248
60735: ST_TO_ADDR
// side := GetSide ( tower ) ;
60736: LD_ADDR_VAR 0 16
60740: PUSH
60741: LD_VAR 0 1
60745: PPUSH
60746: CALL_OW 255
60750: ST_TO_ADDR
// x := GetX ( tower ) ;
60751: LD_ADDR_VAR 0 10
60755: PUSH
60756: LD_VAR 0 1
60760: PPUSH
60761: CALL_OW 250
60765: ST_TO_ADDR
// y := GetY ( tower ) ;
60766: LD_ADDR_VAR 0 11
60770: PUSH
60771: LD_VAR 0 1
60775: PPUSH
60776: CALL_OW 251
60780: ST_TO_ADDR
// if not x or not y then
60781: LD_VAR 0 10
60785: NOT
60786: PUSH
60787: LD_VAR 0 11
60791: NOT
60792: OR
60793: IFFALSE 60797
// exit ;
60795: GO 61857
// weapon := 0 ;
60797: LD_ADDR_VAR 0 18
60801: PUSH
60802: LD_INT 0
60804: ST_TO_ADDR
// fac_list := [ ] ;
60805: LD_ADDR_VAR 0 17
60809: PUSH
60810: EMPTY
60811: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
60812: LD_ADDR_VAR 0 6
60816: PUSH
60817: LD_VAR 0 1
60821: PPUSH
60822: CALL_OW 274
60826: PPUSH
60827: LD_VAR 0 2
60831: PPUSH
60832: CALL 58435 0 2
60836: PPUSH
60837: LD_INT 30
60839: PUSH
60840: LD_INT 3
60842: PUSH
60843: EMPTY
60844: LIST
60845: LIST
60846: PPUSH
60847: CALL_OW 72
60851: ST_TO_ADDR
// if not factories then
60852: LD_VAR 0 6
60856: NOT
60857: IFFALSE 60861
// exit ;
60859: GO 61857
// for i in factories do
60861: LD_ADDR_VAR 0 8
60865: PUSH
60866: LD_VAR 0 6
60870: PUSH
60871: FOR_IN
60872: IFFALSE 60897
// fac_list := fac_list union AvailableWeaponList ( i ) ;
60874: LD_ADDR_VAR 0 17
60878: PUSH
60879: LD_VAR 0 17
60883: PUSH
60884: LD_VAR 0 8
60888: PPUSH
60889: CALL_OW 478
60893: UNION
60894: ST_TO_ADDR
60895: GO 60871
60897: POP
60898: POP
// if not fac_list then
60899: LD_VAR 0 17
60903: NOT
60904: IFFALSE 60908
// exit ;
60906: GO 61857
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
60908: LD_ADDR_VAR 0 5
60912: PUSH
60913: LD_INT 4
60915: PUSH
60916: LD_INT 5
60918: PUSH
60919: LD_INT 9
60921: PUSH
60922: LD_INT 10
60924: PUSH
60925: LD_INT 6
60927: PUSH
60928: LD_INT 7
60930: PUSH
60931: LD_INT 11
60933: PUSH
60934: EMPTY
60935: LIST
60936: LIST
60937: LIST
60938: LIST
60939: LIST
60940: LIST
60941: LIST
60942: PUSH
60943: LD_INT 27
60945: PUSH
60946: LD_INT 28
60948: PUSH
60949: LD_INT 26
60951: PUSH
60952: LD_INT 30
60954: PUSH
60955: EMPTY
60956: LIST
60957: LIST
60958: LIST
60959: LIST
60960: PUSH
60961: LD_INT 43
60963: PUSH
60964: LD_INT 44
60966: PUSH
60967: LD_INT 46
60969: PUSH
60970: LD_INT 45
60972: PUSH
60973: LD_INT 47
60975: PUSH
60976: LD_INT 49
60978: PUSH
60979: EMPTY
60980: LIST
60981: LIST
60982: LIST
60983: LIST
60984: LIST
60985: LIST
60986: PUSH
60987: EMPTY
60988: LIST
60989: LIST
60990: LIST
60991: PUSH
60992: LD_VAR 0 12
60996: ARRAY
60997: ST_TO_ADDR
// for i in list do
60998: LD_ADDR_VAR 0 8
61002: PUSH
61003: LD_VAR 0 5
61007: PUSH
61008: FOR_IN
61009: IFFALSE 61042
// if not i in fac_list then
61011: LD_VAR 0 8
61015: PUSH
61016: LD_VAR 0 17
61020: IN
61021: NOT
61022: IFFALSE 61040
// list := list diff i ;
61024: LD_ADDR_VAR 0 5
61028: PUSH
61029: LD_VAR 0 5
61033: PUSH
61034: LD_VAR 0 8
61038: DIFF
61039: ST_TO_ADDR
61040: GO 61008
61042: POP
61043: POP
// if not list then
61044: LD_VAR 0 5
61048: NOT
61049: IFFALSE 61053
// exit ;
61051: GO 61857
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61053: LD_VAR 0 12
61057: PUSH
61058: LD_INT 3
61060: EQUAL
61061: PUSH
61062: LD_INT 49
61064: PUSH
61065: LD_VAR 0 5
61069: IN
61070: AND
61071: PUSH
61072: LD_INT 31
61074: PPUSH
61075: LD_VAR 0 16
61079: PPUSH
61080: CALL_OW 321
61084: PUSH
61085: LD_INT 2
61087: EQUAL
61088: AND
61089: IFFALSE 61149
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61091: LD_INT 22
61093: PUSH
61094: LD_VAR 0 16
61098: PUSH
61099: EMPTY
61100: LIST
61101: LIST
61102: PUSH
61103: LD_INT 35
61105: PUSH
61106: LD_INT 49
61108: PUSH
61109: EMPTY
61110: LIST
61111: LIST
61112: PUSH
61113: LD_INT 91
61115: PUSH
61116: LD_VAR 0 1
61120: PUSH
61121: LD_INT 10
61123: PUSH
61124: EMPTY
61125: LIST
61126: LIST
61127: LIST
61128: PUSH
61129: EMPTY
61130: LIST
61131: LIST
61132: LIST
61133: PPUSH
61134: CALL_OW 69
61138: NOT
61139: IFFALSE 61149
// weapon := ru_time_lapser ;
61141: LD_ADDR_VAR 0 18
61145: PUSH
61146: LD_INT 49
61148: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61149: LD_VAR 0 12
61153: PUSH
61154: LD_INT 1
61156: PUSH
61157: LD_INT 2
61159: PUSH
61160: EMPTY
61161: LIST
61162: LIST
61163: IN
61164: PUSH
61165: LD_INT 11
61167: PUSH
61168: LD_VAR 0 5
61172: IN
61173: PUSH
61174: LD_INT 30
61176: PUSH
61177: LD_VAR 0 5
61181: IN
61182: OR
61183: AND
61184: PUSH
61185: LD_INT 6
61187: PPUSH
61188: LD_VAR 0 16
61192: PPUSH
61193: CALL_OW 321
61197: PUSH
61198: LD_INT 2
61200: EQUAL
61201: AND
61202: IFFALSE 61367
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61204: LD_INT 22
61206: PUSH
61207: LD_VAR 0 16
61211: PUSH
61212: EMPTY
61213: LIST
61214: LIST
61215: PUSH
61216: LD_INT 2
61218: PUSH
61219: LD_INT 35
61221: PUSH
61222: LD_INT 11
61224: PUSH
61225: EMPTY
61226: LIST
61227: LIST
61228: PUSH
61229: LD_INT 35
61231: PUSH
61232: LD_INT 30
61234: PUSH
61235: EMPTY
61236: LIST
61237: LIST
61238: PUSH
61239: EMPTY
61240: LIST
61241: LIST
61242: LIST
61243: PUSH
61244: LD_INT 91
61246: PUSH
61247: LD_VAR 0 1
61251: PUSH
61252: LD_INT 18
61254: PUSH
61255: EMPTY
61256: LIST
61257: LIST
61258: LIST
61259: PUSH
61260: EMPTY
61261: LIST
61262: LIST
61263: LIST
61264: PPUSH
61265: CALL_OW 69
61269: NOT
61270: PUSH
61271: LD_INT 22
61273: PUSH
61274: LD_VAR 0 16
61278: PUSH
61279: EMPTY
61280: LIST
61281: LIST
61282: PUSH
61283: LD_INT 2
61285: PUSH
61286: LD_INT 30
61288: PUSH
61289: LD_INT 32
61291: PUSH
61292: EMPTY
61293: LIST
61294: LIST
61295: PUSH
61296: LD_INT 30
61298: PUSH
61299: LD_INT 33
61301: PUSH
61302: EMPTY
61303: LIST
61304: LIST
61305: PUSH
61306: EMPTY
61307: LIST
61308: LIST
61309: LIST
61310: PUSH
61311: LD_INT 91
61313: PUSH
61314: LD_VAR 0 1
61318: PUSH
61319: LD_INT 12
61321: PUSH
61322: EMPTY
61323: LIST
61324: LIST
61325: LIST
61326: PUSH
61327: EMPTY
61328: LIST
61329: LIST
61330: LIST
61331: PUSH
61332: EMPTY
61333: LIST
61334: PPUSH
61335: CALL_OW 69
61339: PUSH
61340: LD_INT 2
61342: GREATER
61343: AND
61344: IFFALSE 61367
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61346: LD_ADDR_VAR 0 18
61350: PUSH
61351: LD_INT 11
61353: PUSH
61354: LD_INT 30
61356: PUSH
61357: EMPTY
61358: LIST
61359: LIST
61360: PUSH
61361: LD_VAR 0 12
61365: ARRAY
61366: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61367: LD_VAR 0 18
61371: NOT
61372: PUSH
61373: LD_INT 40
61375: PPUSH
61376: LD_VAR 0 16
61380: PPUSH
61381: CALL_OW 321
61385: PUSH
61386: LD_INT 2
61388: EQUAL
61389: AND
61390: PUSH
61391: LD_INT 7
61393: PUSH
61394: LD_VAR 0 5
61398: IN
61399: PUSH
61400: LD_INT 28
61402: PUSH
61403: LD_VAR 0 5
61407: IN
61408: OR
61409: PUSH
61410: LD_INT 45
61412: PUSH
61413: LD_VAR 0 5
61417: IN
61418: OR
61419: AND
61420: IFFALSE 61674
// begin hex := GetHexInfo ( x , y ) ;
61422: LD_ADDR_VAR 0 4
61426: PUSH
61427: LD_VAR 0 10
61431: PPUSH
61432: LD_VAR 0 11
61436: PPUSH
61437: CALL_OW 546
61441: ST_TO_ADDR
// if hex [ 1 ] then
61442: LD_VAR 0 4
61446: PUSH
61447: LD_INT 1
61449: ARRAY
61450: IFFALSE 61454
// exit ;
61452: GO 61857
// height := hex [ 2 ] ;
61454: LD_ADDR_VAR 0 15
61458: PUSH
61459: LD_VAR 0 4
61463: PUSH
61464: LD_INT 2
61466: ARRAY
61467: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61468: LD_ADDR_VAR 0 14
61472: PUSH
61473: LD_INT 0
61475: PUSH
61476: LD_INT 2
61478: PUSH
61479: LD_INT 3
61481: PUSH
61482: LD_INT 5
61484: PUSH
61485: EMPTY
61486: LIST
61487: LIST
61488: LIST
61489: LIST
61490: ST_TO_ADDR
// for i in tmp do
61491: LD_ADDR_VAR 0 8
61495: PUSH
61496: LD_VAR 0 14
61500: PUSH
61501: FOR_IN
61502: IFFALSE 61672
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61504: LD_ADDR_VAR 0 9
61508: PUSH
61509: LD_VAR 0 10
61513: PPUSH
61514: LD_VAR 0 8
61518: PPUSH
61519: LD_INT 5
61521: PPUSH
61522: CALL_OW 272
61526: PUSH
61527: LD_VAR 0 11
61531: PPUSH
61532: LD_VAR 0 8
61536: PPUSH
61537: LD_INT 5
61539: PPUSH
61540: CALL_OW 273
61544: PUSH
61545: EMPTY
61546: LIST
61547: LIST
61548: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61549: LD_VAR 0 9
61553: PUSH
61554: LD_INT 1
61556: ARRAY
61557: PPUSH
61558: LD_VAR 0 9
61562: PUSH
61563: LD_INT 2
61565: ARRAY
61566: PPUSH
61567: CALL_OW 488
61571: IFFALSE 61670
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61573: LD_ADDR_VAR 0 4
61577: PUSH
61578: LD_VAR 0 9
61582: PUSH
61583: LD_INT 1
61585: ARRAY
61586: PPUSH
61587: LD_VAR 0 9
61591: PUSH
61592: LD_INT 2
61594: ARRAY
61595: PPUSH
61596: CALL_OW 546
61600: ST_TO_ADDR
// if hex [ 1 ] then
61601: LD_VAR 0 4
61605: PUSH
61606: LD_INT 1
61608: ARRAY
61609: IFFALSE 61613
// continue ;
61611: GO 61501
// h := hex [ 2 ] ;
61613: LD_ADDR_VAR 0 13
61617: PUSH
61618: LD_VAR 0 4
61622: PUSH
61623: LD_INT 2
61625: ARRAY
61626: ST_TO_ADDR
// if h + 7 < height then
61627: LD_VAR 0 13
61631: PUSH
61632: LD_INT 7
61634: PLUS
61635: PUSH
61636: LD_VAR 0 15
61640: LESS
61641: IFFALSE 61670
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
61643: LD_ADDR_VAR 0 18
61647: PUSH
61648: LD_INT 7
61650: PUSH
61651: LD_INT 28
61653: PUSH
61654: LD_INT 45
61656: PUSH
61657: EMPTY
61658: LIST
61659: LIST
61660: LIST
61661: PUSH
61662: LD_VAR 0 12
61666: ARRAY
61667: ST_TO_ADDR
// break ;
61668: GO 61672
// end ; end ; end ;
61670: GO 61501
61672: POP
61673: POP
// end ; if not weapon then
61674: LD_VAR 0 18
61678: NOT
61679: IFFALSE 61739
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
61681: LD_ADDR_VAR 0 5
61685: PUSH
61686: LD_VAR 0 5
61690: PUSH
61691: LD_INT 11
61693: PUSH
61694: LD_INT 30
61696: PUSH
61697: LD_INT 49
61699: PUSH
61700: EMPTY
61701: LIST
61702: LIST
61703: LIST
61704: DIFF
61705: ST_TO_ADDR
// if not list then
61706: LD_VAR 0 5
61710: NOT
61711: IFFALSE 61715
// exit ;
61713: GO 61857
// weapon := list [ rand ( 1 , list ) ] ;
61715: LD_ADDR_VAR 0 18
61719: PUSH
61720: LD_VAR 0 5
61724: PUSH
61725: LD_INT 1
61727: PPUSH
61728: LD_VAR 0 5
61732: PPUSH
61733: CALL_OW 12
61737: ARRAY
61738: ST_TO_ADDR
// end ; if weapon then
61739: LD_VAR 0 18
61743: IFFALSE 61857
// begin tmp := CostOfWeapon ( weapon ) ;
61745: LD_ADDR_VAR 0 14
61749: PUSH
61750: LD_VAR 0 18
61754: PPUSH
61755: CALL_OW 451
61759: ST_TO_ADDR
// j := GetBase ( tower ) ;
61760: LD_ADDR_VAR 0 9
61764: PUSH
61765: LD_VAR 0 1
61769: PPUSH
61770: CALL_OW 274
61774: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
61775: LD_VAR 0 9
61779: PPUSH
61780: LD_INT 1
61782: PPUSH
61783: CALL_OW 275
61787: PUSH
61788: LD_VAR 0 14
61792: PUSH
61793: LD_INT 1
61795: ARRAY
61796: GREATEREQUAL
61797: PUSH
61798: LD_VAR 0 9
61802: PPUSH
61803: LD_INT 2
61805: PPUSH
61806: CALL_OW 275
61810: PUSH
61811: LD_VAR 0 14
61815: PUSH
61816: LD_INT 2
61818: ARRAY
61819: GREATEREQUAL
61820: AND
61821: PUSH
61822: LD_VAR 0 9
61826: PPUSH
61827: LD_INT 3
61829: PPUSH
61830: CALL_OW 275
61834: PUSH
61835: LD_VAR 0 14
61839: PUSH
61840: LD_INT 3
61842: ARRAY
61843: GREATEREQUAL
61844: AND
61845: IFFALSE 61857
// result := weapon ;
61847: LD_ADDR_VAR 0 3
61851: PUSH
61852: LD_VAR 0 18
61856: ST_TO_ADDR
// end ; end ;
61857: LD_VAR 0 3
61861: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
61862: LD_INT 0
61864: PPUSH
61865: PPUSH
// result := true ;
61866: LD_ADDR_VAR 0 3
61870: PUSH
61871: LD_INT 1
61873: ST_TO_ADDR
// if array1 = array2 then
61874: LD_VAR 0 1
61878: PUSH
61879: LD_VAR 0 2
61883: EQUAL
61884: IFFALSE 61944
// begin for i = 1 to array1 do
61886: LD_ADDR_VAR 0 4
61890: PUSH
61891: DOUBLE
61892: LD_INT 1
61894: DEC
61895: ST_TO_ADDR
61896: LD_VAR 0 1
61900: PUSH
61901: FOR_TO
61902: IFFALSE 61940
// if array1 [ i ] <> array2 [ i ] then
61904: LD_VAR 0 1
61908: PUSH
61909: LD_VAR 0 4
61913: ARRAY
61914: PUSH
61915: LD_VAR 0 2
61919: PUSH
61920: LD_VAR 0 4
61924: ARRAY
61925: NONEQUAL
61926: IFFALSE 61938
// begin result := false ;
61928: LD_ADDR_VAR 0 3
61932: PUSH
61933: LD_INT 0
61935: ST_TO_ADDR
// break ;
61936: GO 61940
// end ;
61938: GO 61901
61940: POP
61941: POP
// end else
61942: GO 61952
// result := false ;
61944: LD_ADDR_VAR 0 3
61948: PUSH
61949: LD_INT 0
61951: ST_TO_ADDR
// end ;
61952: LD_VAR 0 3
61956: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
61957: LD_INT 0
61959: PPUSH
61960: PPUSH
61961: PPUSH
// pom := GetBase ( fac ) ;
61962: LD_ADDR_VAR 0 5
61966: PUSH
61967: LD_VAR 0 1
61971: PPUSH
61972: CALL_OW 274
61976: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
61977: LD_ADDR_VAR 0 4
61981: PUSH
61982: LD_VAR 0 2
61986: PUSH
61987: LD_INT 1
61989: ARRAY
61990: PPUSH
61991: LD_VAR 0 2
61995: PUSH
61996: LD_INT 2
61998: ARRAY
61999: PPUSH
62000: LD_VAR 0 2
62004: PUSH
62005: LD_INT 3
62007: ARRAY
62008: PPUSH
62009: LD_VAR 0 2
62013: PUSH
62014: LD_INT 4
62016: ARRAY
62017: PPUSH
62018: CALL_OW 449
62022: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62023: LD_ADDR_VAR 0 3
62027: PUSH
62028: LD_VAR 0 5
62032: PPUSH
62033: LD_INT 1
62035: PPUSH
62036: CALL_OW 275
62040: PUSH
62041: LD_VAR 0 4
62045: PUSH
62046: LD_INT 1
62048: ARRAY
62049: GREATEREQUAL
62050: PUSH
62051: LD_VAR 0 5
62055: PPUSH
62056: LD_INT 2
62058: PPUSH
62059: CALL_OW 275
62063: PUSH
62064: LD_VAR 0 4
62068: PUSH
62069: LD_INT 2
62071: ARRAY
62072: GREATEREQUAL
62073: AND
62074: PUSH
62075: LD_VAR 0 5
62079: PPUSH
62080: LD_INT 3
62082: PPUSH
62083: CALL_OW 275
62087: PUSH
62088: LD_VAR 0 4
62092: PUSH
62093: LD_INT 3
62095: ARRAY
62096: GREATEREQUAL
62097: AND
62098: ST_TO_ADDR
// end ;
62099: LD_VAR 0 3
62103: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62104: LD_INT 0
62106: PPUSH
62107: PPUSH
62108: PPUSH
62109: PPUSH
// pom := GetBase ( building ) ;
62110: LD_ADDR_VAR 0 3
62114: PUSH
62115: LD_VAR 0 1
62119: PPUSH
62120: CALL_OW 274
62124: ST_TO_ADDR
// if not pom then
62125: LD_VAR 0 3
62129: NOT
62130: IFFALSE 62134
// exit ;
62132: GO 62304
// btype := GetBType ( building ) ;
62134: LD_ADDR_VAR 0 5
62138: PUSH
62139: LD_VAR 0 1
62143: PPUSH
62144: CALL_OW 266
62148: ST_TO_ADDR
// if btype = b_armoury then
62149: LD_VAR 0 5
62153: PUSH
62154: LD_INT 4
62156: EQUAL
62157: IFFALSE 62167
// btype := b_barracks ;
62159: LD_ADDR_VAR 0 5
62163: PUSH
62164: LD_INT 5
62166: ST_TO_ADDR
// if btype = b_depot then
62167: LD_VAR 0 5
62171: PUSH
62172: LD_INT 0
62174: EQUAL
62175: IFFALSE 62185
// btype := b_warehouse ;
62177: LD_ADDR_VAR 0 5
62181: PUSH
62182: LD_INT 1
62184: ST_TO_ADDR
// if btype = b_workshop then
62185: LD_VAR 0 5
62189: PUSH
62190: LD_INT 2
62192: EQUAL
62193: IFFALSE 62203
// btype := b_factory ;
62195: LD_ADDR_VAR 0 5
62199: PUSH
62200: LD_INT 3
62202: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62203: LD_ADDR_VAR 0 4
62207: PUSH
62208: LD_VAR 0 5
62212: PPUSH
62213: LD_VAR 0 1
62217: PPUSH
62218: CALL_OW 248
62222: PPUSH
62223: CALL_OW 450
62227: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62228: LD_ADDR_VAR 0 2
62232: PUSH
62233: LD_VAR 0 3
62237: PPUSH
62238: LD_INT 1
62240: PPUSH
62241: CALL_OW 275
62245: PUSH
62246: LD_VAR 0 4
62250: PUSH
62251: LD_INT 1
62253: ARRAY
62254: GREATEREQUAL
62255: PUSH
62256: LD_VAR 0 3
62260: PPUSH
62261: LD_INT 2
62263: PPUSH
62264: CALL_OW 275
62268: PUSH
62269: LD_VAR 0 4
62273: PUSH
62274: LD_INT 2
62276: ARRAY
62277: GREATEREQUAL
62278: AND
62279: PUSH
62280: LD_VAR 0 3
62284: PPUSH
62285: LD_INT 3
62287: PPUSH
62288: CALL_OW 275
62292: PUSH
62293: LD_VAR 0 4
62297: PUSH
62298: LD_INT 3
62300: ARRAY
62301: GREATEREQUAL
62302: AND
62303: ST_TO_ADDR
// end ;
62304: LD_VAR 0 2
62308: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62309: LD_INT 0
62311: PPUSH
62312: PPUSH
62313: PPUSH
// pom := GetBase ( building ) ;
62314: LD_ADDR_VAR 0 4
62318: PUSH
62319: LD_VAR 0 1
62323: PPUSH
62324: CALL_OW 274
62328: ST_TO_ADDR
// if not pom then
62329: LD_VAR 0 4
62333: NOT
62334: IFFALSE 62338
// exit ;
62336: GO 62439
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62338: LD_ADDR_VAR 0 5
62342: PUSH
62343: LD_VAR 0 2
62347: PPUSH
62348: LD_VAR 0 1
62352: PPUSH
62353: CALL_OW 248
62357: PPUSH
62358: CALL_OW 450
62362: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62363: LD_ADDR_VAR 0 3
62367: PUSH
62368: LD_VAR 0 4
62372: PPUSH
62373: LD_INT 1
62375: PPUSH
62376: CALL_OW 275
62380: PUSH
62381: LD_VAR 0 5
62385: PUSH
62386: LD_INT 1
62388: ARRAY
62389: GREATEREQUAL
62390: PUSH
62391: LD_VAR 0 4
62395: PPUSH
62396: LD_INT 2
62398: PPUSH
62399: CALL_OW 275
62403: PUSH
62404: LD_VAR 0 5
62408: PUSH
62409: LD_INT 2
62411: ARRAY
62412: GREATEREQUAL
62413: AND
62414: PUSH
62415: LD_VAR 0 4
62419: PPUSH
62420: LD_INT 3
62422: PPUSH
62423: CALL_OW 275
62427: PUSH
62428: LD_VAR 0 5
62432: PUSH
62433: LD_INT 3
62435: ARRAY
62436: GREATEREQUAL
62437: AND
62438: ST_TO_ADDR
// end ;
62439: LD_VAR 0 3
62443: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
62444: LD_INT 0
62446: PPUSH
62447: PPUSH
62448: PPUSH
62449: PPUSH
62450: PPUSH
62451: PPUSH
62452: PPUSH
62453: PPUSH
62454: PPUSH
62455: PPUSH
// result := false ;
62456: LD_ADDR_VAR 0 6
62460: PUSH
62461: LD_INT 0
62463: ST_TO_ADDR
// if not base or not btype or not x or not y then
62464: LD_VAR 0 1
62468: NOT
62469: PUSH
62470: LD_VAR 0 2
62474: NOT
62475: OR
62476: PUSH
62477: LD_VAR 0 3
62481: NOT
62482: OR
62483: PUSH
62484: LD_VAR 0 4
62488: NOT
62489: OR
62490: IFFALSE 62494
// exit ;
62492: GO 63103
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
62494: LD_ADDR_VAR 0 12
62498: PUSH
62499: LD_VAR 0 2
62503: PPUSH
62504: LD_VAR 0 3
62508: PPUSH
62509: LD_VAR 0 4
62513: PPUSH
62514: LD_VAR 0 5
62518: PPUSH
62519: LD_VAR 0 1
62523: PUSH
62524: LD_INT 1
62526: ARRAY
62527: PPUSH
62528: CALL_OW 248
62532: PPUSH
62533: LD_INT 0
62535: PPUSH
62536: CALL 63940 0 6
62540: ST_TO_ADDR
// if not hexes then
62541: LD_VAR 0 12
62545: NOT
62546: IFFALSE 62550
// exit ;
62548: GO 63103
// for i = 1 to hexes do
62550: LD_ADDR_VAR 0 7
62554: PUSH
62555: DOUBLE
62556: LD_INT 1
62558: DEC
62559: ST_TO_ADDR
62560: LD_VAR 0 12
62564: PUSH
62565: FOR_TO
62566: IFFALSE 63101
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62568: LD_ADDR_VAR 0 11
62572: PUSH
62573: LD_VAR 0 12
62577: PUSH
62578: LD_VAR 0 7
62582: ARRAY
62583: PUSH
62584: LD_INT 1
62586: ARRAY
62587: PPUSH
62588: LD_VAR 0 12
62592: PUSH
62593: LD_VAR 0 7
62597: ARRAY
62598: PUSH
62599: LD_INT 2
62601: ARRAY
62602: PPUSH
62603: CALL_OW 428
62607: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
62608: LD_VAR 0 12
62612: PUSH
62613: LD_VAR 0 7
62617: ARRAY
62618: PUSH
62619: LD_INT 1
62621: ARRAY
62622: PPUSH
62623: LD_VAR 0 12
62627: PUSH
62628: LD_VAR 0 7
62632: ARRAY
62633: PUSH
62634: LD_INT 2
62636: ARRAY
62637: PPUSH
62638: CALL_OW 351
62642: PUSH
62643: LD_VAR 0 12
62647: PUSH
62648: LD_VAR 0 7
62652: ARRAY
62653: PUSH
62654: LD_INT 1
62656: ARRAY
62657: PPUSH
62658: LD_VAR 0 12
62662: PUSH
62663: LD_VAR 0 7
62667: ARRAY
62668: PUSH
62669: LD_INT 2
62671: ARRAY
62672: PPUSH
62673: CALL_OW 488
62677: NOT
62678: OR
62679: PUSH
62680: LD_VAR 0 11
62684: PPUSH
62685: CALL_OW 247
62689: PUSH
62690: LD_INT 3
62692: EQUAL
62693: OR
62694: IFFALSE 62700
// exit ;
62696: POP
62697: POP
62698: GO 63103
// if not tmp or not tmp in base then
62700: LD_VAR 0 11
62704: NOT
62705: PUSH
62706: LD_VAR 0 11
62710: PUSH
62711: LD_VAR 0 1
62715: IN
62716: NOT
62717: OR
62718: IFFALSE 62722
// continue ;
62720: GO 62565
// result := true ;
62722: LD_ADDR_VAR 0 6
62726: PUSH
62727: LD_INT 1
62729: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
62730: LD_ADDR_VAR 0 15
62734: PUSH
62735: LD_VAR 0 1
62739: PPUSH
62740: LD_INT 22
62742: PUSH
62743: LD_VAR 0 11
62747: PPUSH
62748: CALL_OW 255
62752: PUSH
62753: EMPTY
62754: LIST
62755: LIST
62756: PUSH
62757: LD_INT 2
62759: PUSH
62760: LD_INT 30
62762: PUSH
62763: LD_INT 0
62765: PUSH
62766: EMPTY
62767: LIST
62768: LIST
62769: PUSH
62770: LD_INT 30
62772: PUSH
62773: LD_INT 1
62775: PUSH
62776: EMPTY
62777: LIST
62778: LIST
62779: PUSH
62780: EMPTY
62781: LIST
62782: LIST
62783: LIST
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: PPUSH
62789: CALL_OW 72
62793: ST_TO_ADDR
// if dep then
62794: LD_VAR 0 15
62798: IFFALSE 62934
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
62800: LD_ADDR_VAR 0 14
62804: PUSH
62805: LD_VAR 0 15
62809: PUSH
62810: LD_INT 1
62812: ARRAY
62813: PPUSH
62814: CALL_OW 250
62818: PPUSH
62819: LD_VAR 0 15
62823: PUSH
62824: LD_INT 1
62826: ARRAY
62827: PPUSH
62828: CALL_OW 254
62832: PPUSH
62833: LD_INT 5
62835: PPUSH
62836: CALL_OW 272
62840: PUSH
62841: LD_VAR 0 15
62845: PUSH
62846: LD_INT 1
62848: ARRAY
62849: PPUSH
62850: CALL_OW 251
62854: PPUSH
62855: LD_VAR 0 15
62859: PUSH
62860: LD_INT 1
62862: ARRAY
62863: PPUSH
62864: CALL_OW 254
62868: PPUSH
62869: LD_INT 5
62871: PPUSH
62872: CALL_OW 273
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
62881: LD_VAR 0 14
62885: PUSH
62886: LD_INT 1
62888: ARRAY
62889: PPUSH
62890: LD_VAR 0 14
62894: PUSH
62895: LD_INT 2
62897: ARRAY
62898: PPUSH
62899: CALL_OW 488
62903: IFFALSE 62934
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
62905: LD_VAR 0 11
62909: PPUSH
62910: LD_VAR 0 14
62914: PUSH
62915: LD_INT 1
62917: ARRAY
62918: PPUSH
62919: LD_VAR 0 14
62923: PUSH
62924: LD_INT 2
62926: ARRAY
62927: PPUSH
62928: CALL_OW 111
// continue ;
62932: GO 62565
// end ; end ; r := GetDir ( tmp ) ;
62934: LD_ADDR_VAR 0 13
62938: PUSH
62939: LD_VAR 0 11
62943: PPUSH
62944: CALL_OW 254
62948: ST_TO_ADDR
// if r = 5 then
62949: LD_VAR 0 13
62953: PUSH
62954: LD_INT 5
62956: EQUAL
62957: IFFALSE 62967
// r := 0 ;
62959: LD_ADDR_VAR 0 13
62963: PUSH
62964: LD_INT 0
62966: ST_TO_ADDR
// for j = r to 5 do
62967: LD_ADDR_VAR 0 8
62971: PUSH
62972: DOUBLE
62973: LD_VAR 0 13
62977: DEC
62978: ST_TO_ADDR
62979: LD_INT 5
62981: PUSH
62982: FOR_TO
62983: IFFALSE 63097
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62985: LD_ADDR_VAR 0 9
62989: PUSH
62990: LD_VAR 0 11
62994: PPUSH
62995: CALL_OW 250
62999: PPUSH
63000: LD_VAR 0 8
63004: PPUSH
63005: LD_INT 2
63007: PPUSH
63008: CALL_OW 272
63012: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63013: LD_ADDR_VAR 0 10
63017: PUSH
63018: LD_VAR 0 11
63022: PPUSH
63023: CALL_OW 251
63027: PPUSH
63028: LD_VAR 0 8
63032: PPUSH
63033: LD_INT 2
63035: PPUSH
63036: CALL_OW 273
63040: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63041: LD_VAR 0 9
63045: PPUSH
63046: LD_VAR 0 10
63050: PPUSH
63051: CALL_OW 488
63055: PUSH
63056: LD_VAR 0 9
63060: PPUSH
63061: LD_VAR 0 10
63065: PPUSH
63066: CALL_OW 428
63070: NOT
63071: AND
63072: IFFALSE 63095
// begin ComMoveXY ( tmp , _x , _y ) ;
63074: LD_VAR 0 11
63078: PPUSH
63079: LD_VAR 0 9
63083: PPUSH
63084: LD_VAR 0 10
63088: PPUSH
63089: CALL_OW 111
// break ;
63093: GO 63097
// end ; end ;
63095: GO 62982
63097: POP
63098: POP
// end ;
63099: GO 62565
63101: POP
63102: POP
// end ;
63103: LD_VAR 0 6
63107: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
63108: LD_INT 0
63110: PPUSH
63111: PPUSH
63112: PPUSH
63113: PPUSH
63114: PPUSH
63115: PPUSH
63116: PPUSH
63117: PPUSH
63118: PPUSH
63119: PPUSH
// result := false ;
63120: LD_ADDR_VAR 0 6
63124: PUSH
63125: LD_INT 0
63127: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63128: LD_VAR 0 1
63132: NOT
63133: PUSH
63134: LD_VAR 0 1
63138: PPUSH
63139: CALL_OW 266
63143: PUSH
63144: LD_INT 0
63146: PUSH
63147: LD_INT 1
63149: PUSH
63150: EMPTY
63151: LIST
63152: LIST
63153: IN
63154: NOT
63155: OR
63156: PUSH
63157: LD_VAR 0 2
63161: NOT
63162: OR
63163: PUSH
63164: LD_VAR 0 5
63168: PUSH
63169: LD_INT 0
63171: PUSH
63172: LD_INT 1
63174: PUSH
63175: LD_INT 2
63177: PUSH
63178: LD_INT 3
63180: PUSH
63181: LD_INT 4
63183: PUSH
63184: LD_INT 5
63186: PUSH
63187: EMPTY
63188: LIST
63189: LIST
63190: LIST
63191: LIST
63192: LIST
63193: LIST
63194: IN
63195: NOT
63196: OR
63197: PUSH
63198: LD_VAR 0 3
63202: PPUSH
63203: LD_VAR 0 4
63207: PPUSH
63208: CALL_OW 488
63212: NOT
63213: OR
63214: IFFALSE 63218
// exit ;
63216: GO 63935
// pom := GetBase ( depot ) ;
63218: LD_ADDR_VAR 0 10
63222: PUSH
63223: LD_VAR 0 1
63227: PPUSH
63228: CALL_OW 274
63232: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63233: LD_ADDR_VAR 0 11
63237: PUSH
63238: LD_VAR 0 2
63242: PPUSH
63243: LD_VAR 0 1
63247: PPUSH
63248: CALL_OW 248
63252: PPUSH
63253: CALL_OW 450
63257: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63258: LD_VAR 0 10
63262: PPUSH
63263: LD_INT 1
63265: PPUSH
63266: CALL_OW 275
63270: PUSH
63271: LD_VAR 0 11
63275: PUSH
63276: LD_INT 1
63278: ARRAY
63279: GREATEREQUAL
63280: PUSH
63281: LD_VAR 0 10
63285: PPUSH
63286: LD_INT 2
63288: PPUSH
63289: CALL_OW 275
63293: PUSH
63294: LD_VAR 0 11
63298: PUSH
63299: LD_INT 2
63301: ARRAY
63302: GREATEREQUAL
63303: AND
63304: PUSH
63305: LD_VAR 0 10
63309: PPUSH
63310: LD_INT 3
63312: PPUSH
63313: CALL_OW 275
63317: PUSH
63318: LD_VAR 0 11
63322: PUSH
63323: LD_INT 3
63325: ARRAY
63326: GREATEREQUAL
63327: AND
63328: NOT
63329: IFFALSE 63333
// exit ;
63331: GO 63935
// if GetBType ( depot ) = b_depot then
63333: LD_VAR 0 1
63337: PPUSH
63338: CALL_OW 266
63342: PUSH
63343: LD_INT 0
63345: EQUAL
63346: IFFALSE 63358
// dist := 28 else
63348: LD_ADDR_VAR 0 14
63352: PUSH
63353: LD_INT 28
63355: ST_TO_ADDR
63356: GO 63366
// dist := 36 ;
63358: LD_ADDR_VAR 0 14
63362: PUSH
63363: LD_INT 36
63365: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63366: LD_VAR 0 1
63370: PPUSH
63371: LD_VAR 0 3
63375: PPUSH
63376: LD_VAR 0 4
63380: PPUSH
63381: CALL_OW 297
63385: PUSH
63386: LD_VAR 0 14
63390: GREATER
63391: IFFALSE 63395
// exit ;
63393: GO 63935
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63395: LD_ADDR_VAR 0 12
63399: PUSH
63400: LD_VAR 0 2
63404: PPUSH
63405: LD_VAR 0 3
63409: PPUSH
63410: LD_VAR 0 4
63414: PPUSH
63415: LD_VAR 0 5
63419: PPUSH
63420: LD_VAR 0 1
63424: PPUSH
63425: CALL_OW 248
63429: PPUSH
63430: LD_INT 0
63432: PPUSH
63433: CALL 63940 0 6
63437: ST_TO_ADDR
// if not hexes then
63438: LD_VAR 0 12
63442: NOT
63443: IFFALSE 63447
// exit ;
63445: GO 63935
// hex := GetHexInfo ( x , y ) ;
63447: LD_ADDR_VAR 0 15
63451: PUSH
63452: LD_VAR 0 3
63456: PPUSH
63457: LD_VAR 0 4
63461: PPUSH
63462: CALL_OW 546
63466: ST_TO_ADDR
// if hex [ 1 ] then
63467: LD_VAR 0 15
63471: PUSH
63472: LD_INT 1
63474: ARRAY
63475: IFFALSE 63479
// exit ;
63477: GO 63935
// height := hex [ 2 ] ;
63479: LD_ADDR_VAR 0 13
63483: PUSH
63484: LD_VAR 0 15
63488: PUSH
63489: LD_INT 2
63491: ARRAY
63492: ST_TO_ADDR
// for i = 1 to hexes do
63493: LD_ADDR_VAR 0 7
63497: PUSH
63498: DOUBLE
63499: LD_INT 1
63501: DEC
63502: ST_TO_ADDR
63503: LD_VAR 0 12
63507: PUSH
63508: FOR_TO
63509: IFFALSE 63839
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63511: LD_VAR 0 12
63515: PUSH
63516: LD_VAR 0 7
63520: ARRAY
63521: PUSH
63522: LD_INT 1
63524: ARRAY
63525: PPUSH
63526: LD_VAR 0 12
63530: PUSH
63531: LD_VAR 0 7
63535: ARRAY
63536: PUSH
63537: LD_INT 2
63539: ARRAY
63540: PPUSH
63541: CALL_OW 488
63545: NOT
63546: PUSH
63547: LD_VAR 0 12
63551: PUSH
63552: LD_VAR 0 7
63556: ARRAY
63557: PUSH
63558: LD_INT 1
63560: ARRAY
63561: PPUSH
63562: LD_VAR 0 12
63566: PUSH
63567: LD_VAR 0 7
63571: ARRAY
63572: PUSH
63573: LD_INT 2
63575: ARRAY
63576: PPUSH
63577: CALL_OW 428
63581: PUSH
63582: LD_INT 0
63584: GREATER
63585: OR
63586: PUSH
63587: LD_VAR 0 12
63591: PUSH
63592: LD_VAR 0 7
63596: ARRAY
63597: PUSH
63598: LD_INT 1
63600: ARRAY
63601: PPUSH
63602: LD_VAR 0 12
63606: PUSH
63607: LD_VAR 0 7
63611: ARRAY
63612: PUSH
63613: LD_INT 2
63615: ARRAY
63616: PPUSH
63617: CALL_OW 351
63621: OR
63622: IFFALSE 63628
// exit ;
63624: POP
63625: POP
63626: GO 63935
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63628: LD_ADDR_VAR 0 8
63632: PUSH
63633: LD_VAR 0 12
63637: PUSH
63638: LD_VAR 0 7
63642: ARRAY
63643: PUSH
63644: LD_INT 1
63646: ARRAY
63647: PPUSH
63648: LD_VAR 0 12
63652: PUSH
63653: LD_VAR 0 7
63657: ARRAY
63658: PUSH
63659: LD_INT 2
63661: ARRAY
63662: PPUSH
63663: CALL_OW 546
63667: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63668: LD_VAR 0 8
63672: PUSH
63673: LD_INT 1
63675: ARRAY
63676: PUSH
63677: LD_VAR 0 8
63681: PUSH
63682: LD_INT 2
63684: ARRAY
63685: PUSH
63686: LD_VAR 0 13
63690: PUSH
63691: LD_INT 2
63693: PLUS
63694: GREATER
63695: OR
63696: PUSH
63697: LD_VAR 0 8
63701: PUSH
63702: LD_INT 2
63704: ARRAY
63705: PUSH
63706: LD_VAR 0 13
63710: PUSH
63711: LD_INT 2
63713: MINUS
63714: LESS
63715: OR
63716: PUSH
63717: LD_VAR 0 8
63721: PUSH
63722: LD_INT 3
63724: ARRAY
63725: PUSH
63726: LD_INT 0
63728: PUSH
63729: LD_INT 8
63731: PUSH
63732: LD_INT 9
63734: PUSH
63735: LD_INT 10
63737: PUSH
63738: LD_INT 11
63740: PUSH
63741: LD_INT 12
63743: PUSH
63744: LD_INT 13
63746: PUSH
63747: LD_INT 16
63749: PUSH
63750: LD_INT 17
63752: PUSH
63753: LD_INT 18
63755: PUSH
63756: LD_INT 19
63758: PUSH
63759: LD_INT 20
63761: PUSH
63762: LD_INT 21
63764: PUSH
63765: EMPTY
63766: LIST
63767: LIST
63768: LIST
63769: LIST
63770: LIST
63771: LIST
63772: LIST
63773: LIST
63774: LIST
63775: LIST
63776: LIST
63777: LIST
63778: LIST
63779: IN
63780: NOT
63781: OR
63782: PUSH
63783: LD_VAR 0 8
63787: PUSH
63788: LD_INT 5
63790: ARRAY
63791: NOT
63792: OR
63793: PUSH
63794: LD_VAR 0 8
63798: PUSH
63799: LD_INT 6
63801: ARRAY
63802: PUSH
63803: LD_INT 1
63805: PUSH
63806: LD_INT 2
63808: PUSH
63809: LD_INT 7
63811: PUSH
63812: LD_INT 9
63814: PUSH
63815: LD_INT 10
63817: PUSH
63818: LD_INT 11
63820: PUSH
63821: EMPTY
63822: LIST
63823: LIST
63824: LIST
63825: LIST
63826: LIST
63827: LIST
63828: IN
63829: NOT
63830: OR
63831: IFFALSE 63837
// exit ;
63833: POP
63834: POP
63835: GO 63935
// end ;
63837: GO 63508
63839: POP
63840: POP
// side := GetSide ( depot ) ;
63841: LD_ADDR_VAR 0 9
63845: PUSH
63846: LD_VAR 0 1
63850: PPUSH
63851: CALL_OW 255
63855: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63856: LD_VAR 0 9
63860: PPUSH
63861: LD_VAR 0 3
63865: PPUSH
63866: LD_VAR 0 4
63870: PPUSH
63871: LD_INT 20
63873: PPUSH
63874: CALL 56589 0 4
63878: PUSH
63879: LD_INT 4
63881: ARRAY
63882: IFFALSE 63886
// exit ;
63884: GO 63935
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63886: LD_VAR 0 2
63890: PUSH
63891: LD_INT 29
63893: PUSH
63894: LD_INT 30
63896: PUSH
63897: EMPTY
63898: LIST
63899: LIST
63900: IN
63901: PUSH
63902: LD_VAR 0 3
63906: PPUSH
63907: LD_VAR 0 4
63911: PPUSH
63912: LD_VAR 0 9
63916: PPUSH
63917: CALL_OW 440
63921: NOT
63922: AND
63923: IFFALSE 63927
// exit ;
63925: GO 63935
// result := true ;
63927: LD_ADDR_VAR 0 6
63931: PUSH
63932: LD_INT 1
63934: ST_TO_ADDR
// end ;
63935: LD_VAR 0 6
63939: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
63940: LD_INT 0
63942: PPUSH
63943: PPUSH
63944: PPUSH
63945: PPUSH
63946: PPUSH
63947: PPUSH
63948: PPUSH
63949: PPUSH
63950: PPUSH
63951: PPUSH
63952: PPUSH
63953: PPUSH
63954: PPUSH
63955: PPUSH
63956: PPUSH
63957: PPUSH
63958: PPUSH
63959: PPUSH
63960: PPUSH
63961: PPUSH
63962: PPUSH
63963: PPUSH
63964: PPUSH
63965: PPUSH
63966: PPUSH
63967: PPUSH
63968: PPUSH
63969: PPUSH
63970: PPUSH
63971: PPUSH
63972: PPUSH
63973: PPUSH
63974: PPUSH
63975: PPUSH
63976: PPUSH
63977: PPUSH
63978: PPUSH
63979: PPUSH
63980: PPUSH
63981: PPUSH
63982: PPUSH
63983: PPUSH
63984: PPUSH
63985: PPUSH
63986: PPUSH
63987: PPUSH
63988: PPUSH
63989: PPUSH
63990: PPUSH
63991: PPUSH
63992: PPUSH
63993: PPUSH
63994: PPUSH
63995: PPUSH
63996: PPUSH
63997: PPUSH
63998: PPUSH
63999: PPUSH
// result = [ ] ;
64000: LD_ADDR_VAR 0 7
64004: PUSH
64005: EMPTY
64006: ST_TO_ADDR
// temp_list = [ ] ;
64007: LD_ADDR_VAR 0 9
64011: PUSH
64012: EMPTY
64013: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
64014: LD_VAR 0 4
64018: PUSH
64019: LD_INT 0
64021: PUSH
64022: LD_INT 1
64024: PUSH
64025: LD_INT 2
64027: PUSH
64028: LD_INT 3
64030: PUSH
64031: LD_INT 4
64033: PUSH
64034: LD_INT 5
64036: PUSH
64037: EMPTY
64038: LIST
64039: LIST
64040: LIST
64041: LIST
64042: LIST
64043: LIST
64044: IN
64045: NOT
64046: PUSH
64047: LD_VAR 0 1
64051: PUSH
64052: LD_INT 0
64054: PUSH
64055: LD_INT 1
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: IN
64062: PUSH
64063: LD_VAR 0 5
64067: PUSH
64068: LD_INT 1
64070: PUSH
64071: LD_INT 2
64073: PUSH
64074: LD_INT 3
64076: PUSH
64077: EMPTY
64078: LIST
64079: LIST
64080: LIST
64081: IN
64082: NOT
64083: AND
64084: OR
64085: IFFALSE 64089
// exit ;
64087: GO 82480
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64089: LD_VAR 0 1
64093: PUSH
64094: LD_INT 6
64096: PUSH
64097: LD_INT 7
64099: PUSH
64100: LD_INT 8
64102: PUSH
64103: LD_INT 13
64105: PUSH
64106: LD_INT 12
64108: PUSH
64109: LD_INT 15
64111: PUSH
64112: LD_INT 11
64114: PUSH
64115: LD_INT 14
64117: PUSH
64118: LD_INT 10
64120: PUSH
64121: EMPTY
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: IN
64132: IFFALSE 64142
// btype = b_lab ;
64134: LD_ADDR_VAR 0 1
64138: PUSH
64139: LD_INT 6
64141: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64142: LD_VAR 0 6
64146: PUSH
64147: LD_INT 0
64149: PUSH
64150: LD_INT 1
64152: PUSH
64153: LD_INT 2
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: LIST
64160: IN
64161: NOT
64162: PUSH
64163: LD_VAR 0 1
64167: PUSH
64168: LD_INT 0
64170: PUSH
64171: LD_INT 1
64173: PUSH
64174: LD_INT 2
64176: PUSH
64177: LD_INT 3
64179: PUSH
64180: LD_INT 6
64182: PUSH
64183: LD_INT 36
64185: PUSH
64186: LD_INT 4
64188: PUSH
64189: LD_INT 5
64191: PUSH
64192: LD_INT 31
64194: PUSH
64195: LD_INT 32
64197: PUSH
64198: LD_INT 33
64200: PUSH
64201: EMPTY
64202: LIST
64203: LIST
64204: LIST
64205: LIST
64206: LIST
64207: LIST
64208: LIST
64209: LIST
64210: LIST
64211: LIST
64212: LIST
64213: IN
64214: NOT
64215: PUSH
64216: LD_VAR 0 6
64220: PUSH
64221: LD_INT 1
64223: EQUAL
64224: AND
64225: OR
64226: PUSH
64227: LD_VAR 0 1
64231: PUSH
64232: LD_INT 2
64234: PUSH
64235: LD_INT 3
64237: PUSH
64238: EMPTY
64239: LIST
64240: LIST
64241: IN
64242: NOT
64243: PUSH
64244: LD_VAR 0 6
64248: PUSH
64249: LD_INT 2
64251: EQUAL
64252: AND
64253: OR
64254: IFFALSE 64264
// mode = 0 ;
64256: LD_ADDR_VAR 0 6
64260: PUSH
64261: LD_INT 0
64263: ST_TO_ADDR
// case mode of 0 :
64264: LD_VAR 0 6
64268: PUSH
64269: LD_INT 0
64271: DOUBLE
64272: EQUAL
64273: IFTRUE 64277
64275: GO 75730
64277: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64278: LD_ADDR_VAR 0 11
64282: PUSH
64283: LD_INT 0
64285: PUSH
64286: LD_INT 0
64288: PUSH
64289: EMPTY
64290: LIST
64291: LIST
64292: PUSH
64293: LD_INT 0
64295: PUSH
64296: LD_INT 1
64298: NEG
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: LD_INT 1
64306: PUSH
64307: LD_INT 0
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: LD_INT 1
64316: PUSH
64317: LD_INT 1
64319: PUSH
64320: EMPTY
64321: LIST
64322: LIST
64323: PUSH
64324: LD_INT 0
64326: PUSH
64327: LD_INT 1
64329: PUSH
64330: EMPTY
64331: LIST
64332: LIST
64333: PUSH
64334: LD_INT 1
64336: NEG
64337: PUSH
64338: LD_INT 0
64340: PUSH
64341: EMPTY
64342: LIST
64343: LIST
64344: PUSH
64345: LD_INT 1
64347: NEG
64348: PUSH
64349: LD_INT 1
64351: NEG
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: PUSH
64357: LD_INT 1
64359: NEG
64360: PUSH
64361: LD_INT 2
64363: NEG
64364: PUSH
64365: EMPTY
64366: LIST
64367: LIST
64368: PUSH
64369: LD_INT 0
64371: PUSH
64372: LD_INT 2
64374: NEG
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PUSH
64380: LD_INT 1
64382: PUSH
64383: LD_INT 1
64385: NEG
64386: PUSH
64387: EMPTY
64388: LIST
64389: LIST
64390: PUSH
64391: LD_INT 1
64393: PUSH
64394: LD_INT 2
64396: PUSH
64397: EMPTY
64398: LIST
64399: LIST
64400: PUSH
64401: LD_INT 0
64403: PUSH
64404: LD_INT 2
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PUSH
64411: LD_INT 1
64413: NEG
64414: PUSH
64415: LD_INT 1
64417: PUSH
64418: EMPTY
64419: LIST
64420: LIST
64421: PUSH
64422: LD_INT 1
64424: PUSH
64425: LD_INT 3
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: PUSH
64432: LD_INT 0
64434: PUSH
64435: LD_INT 3
64437: PUSH
64438: EMPTY
64439: LIST
64440: LIST
64441: PUSH
64442: LD_INT 1
64444: NEG
64445: PUSH
64446: LD_INT 2
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: EMPTY
64454: LIST
64455: LIST
64456: LIST
64457: LIST
64458: LIST
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64471: LD_ADDR_VAR 0 12
64475: PUSH
64476: LD_INT 0
64478: PUSH
64479: LD_INT 0
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: PUSH
64486: LD_INT 0
64488: PUSH
64489: LD_INT 1
64491: NEG
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: LD_INT 1
64499: PUSH
64500: LD_INT 0
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: PUSH
64507: LD_INT 1
64509: PUSH
64510: LD_INT 1
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: PUSH
64517: LD_INT 0
64519: PUSH
64520: LD_INT 1
64522: PUSH
64523: EMPTY
64524: LIST
64525: LIST
64526: PUSH
64527: LD_INT 1
64529: NEG
64530: PUSH
64531: LD_INT 0
64533: PUSH
64534: EMPTY
64535: LIST
64536: LIST
64537: PUSH
64538: LD_INT 1
64540: NEG
64541: PUSH
64542: LD_INT 1
64544: NEG
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 1
64552: PUSH
64553: LD_INT 1
64555: NEG
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: LD_INT 2
64563: PUSH
64564: LD_INT 0
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: PUSH
64571: LD_INT 2
64573: PUSH
64574: LD_INT 1
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: PUSH
64581: LD_INT 1
64583: NEG
64584: PUSH
64585: LD_INT 1
64587: PUSH
64588: EMPTY
64589: LIST
64590: LIST
64591: PUSH
64592: LD_INT 2
64594: NEG
64595: PUSH
64596: LD_INT 0
64598: PUSH
64599: EMPTY
64600: LIST
64601: LIST
64602: PUSH
64603: LD_INT 2
64605: NEG
64606: PUSH
64607: LD_INT 1
64609: NEG
64610: PUSH
64611: EMPTY
64612: LIST
64613: LIST
64614: PUSH
64615: LD_INT 2
64617: NEG
64618: PUSH
64619: LD_INT 1
64621: PUSH
64622: EMPTY
64623: LIST
64624: LIST
64625: PUSH
64626: LD_INT 3
64628: NEG
64629: PUSH
64630: LD_INT 0
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: PUSH
64637: LD_INT 3
64639: NEG
64640: PUSH
64641: LD_INT 1
64643: NEG
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: EMPTY
64650: LIST
64651: LIST
64652: LIST
64653: LIST
64654: LIST
64655: LIST
64656: LIST
64657: LIST
64658: LIST
64659: LIST
64660: LIST
64661: LIST
64662: LIST
64663: LIST
64664: LIST
64665: LIST
64666: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64667: LD_ADDR_VAR 0 13
64671: PUSH
64672: LD_INT 0
64674: PUSH
64675: LD_INT 0
64677: PUSH
64678: EMPTY
64679: LIST
64680: LIST
64681: PUSH
64682: LD_INT 0
64684: PUSH
64685: LD_INT 1
64687: NEG
64688: PUSH
64689: EMPTY
64690: LIST
64691: LIST
64692: PUSH
64693: LD_INT 1
64695: PUSH
64696: LD_INT 0
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: PUSH
64703: LD_INT 1
64705: PUSH
64706: LD_INT 1
64708: PUSH
64709: EMPTY
64710: LIST
64711: LIST
64712: PUSH
64713: LD_INT 0
64715: PUSH
64716: LD_INT 1
64718: PUSH
64719: EMPTY
64720: LIST
64721: LIST
64722: PUSH
64723: LD_INT 1
64725: NEG
64726: PUSH
64727: LD_INT 0
64729: PUSH
64730: EMPTY
64731: LIST
64732: LIST
64733: PUSH
64734: LD_INT 1
64736: NEG
64737: PUSH
64738: LD_INT 1
64740: NEG
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: PUSH
64746: LD_INT 1
64748: NEG
64749: PUSH
64750: LD_INT 2
64752: NEG
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PUSH
64758: LD_INT 2
64760: PUSH
64761: LD_INT 1
64763: PUSH
64764: EMPTY
64765: LIST
64766: LIST
64767: PUSH
64768: LD_INT 2
64770: PUSH
64771: LD_INT 2
64773: PUSH
64774: EMPTY
64775: LIST
64776: LIST
64777: PUSH
64778: LD_INT 1
64780: PUSH
64781: LD_INT 2
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: LD_INT 2
64790: NEG
64791: PUSH
64792: LD_INT 1
64794: NEG
64795: PUSH
64796: EMPTY
64797: LIST
64798: LIST
64799: PUSH
64800: LD_INT 2
64802: NEG
64803: PUSH
64804: LD_INT 2
64806: NEG
64807: PUSH
64808: EMPTY
64809: LIST
64810: LIST
64811: PUSH
64812: LD_INT 2
64814: NEG
64815: PUSH
64816: LD_INT 3
64818: NEG
64819: PUSH
64820: EMPTY
64821: LIST
64822: LIST
64823: PUSH
64824: LD_INT 3
64826: NEG
64827: PUSH
64828: LD_INT 2
64830: NEG
64831: PUSH
64832: EMPTY
64833: LIST
64834: LIST
64835: PUSH
64836: LD_INT 3
64838: NEG
64839: PUSH
64840: LD_INT 3
64842: NEG
64843: PUSH
64844: EMPTY
64845: LIST
64846: LIST
64847: PUSH
64848: EMPTY
64849: LIST
64850: LIST
64851: LIST
64852: LIST
64853: LIST
64854: LIST
64855: LIST
64856: LIST
64857: LIST
64858: LIST
64859: LIST
64860: LIST
64861: LIST
64862: LIST
64863: LIST
64864: LIST
64865: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64866: LD_ADDR_VAR 0 14
64870: PUSH
64871: LD_INT 0
64873: PUSH
64874: LD_INT 0
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PUSH
64881: LD_INT 0
64883: PUSH
64884: LD_INT 1
64886: NEG
64887: PUSH
64888: EMPTY
64889: LIST
64890: LIST
64891: PUSH
64892: LD_INT 1
64894: PUSH
64895: LD_INT 0
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: PUSH
64902: LD_INT 1
64904: PUSH
64905: LD_INT 1
64907: PUSH
64908: EMPTY
64909: LIST
64910: LIST
64911: PUSH
64912: LD_INT 0
64914: PUSH
64915: LD_INT 1
64917: PUSH
64918: EMPTY
64919: LIST
64920: LIST
64921: PUSH
64922: LD_INT 1
64924: NEG
64925: PUSH
64926: LD_INT 0
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: PUSH
64933: LD_INT 1
64935: NEG
64936: PUSH
64937: LD_INT 1
64939: NEG
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PUSH
64945: LD_INT 1
64947: NEG
64948: PUSH
64949: LD_INT 2
64951: NEG
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 0
64959: PUSH
64960: LD_INT 2
64962: NEG
64963: PUSH
64964: EMPTY
64965: LIST
64966: LIST
64967: PUSH
64968: LD_INT 1
64970: PUSH
64971: LD_INT 1
64973: NEG
64974: PUSH
64975: EMPTY
64976: LIST
64977: LIST
64978: PUSH
64979: LD_INT 1
64981: PUSH
64982: LD_INT 2
64984: PUSH
64985: EMPTY
64986: LIST
64987: LIST
64988: PUSH
64989: LD_INT 0
64991: PUSH
64992: LD_INT 2
64994: PUSH
64995: EMPTY
64996: LIST
64997: LIST
64998: PUSH
64999: LD_INT 1
65001: NEG
65002: PUSH
65003: LD_INT 1
65005: PUSH
65006: EMPTY
65007: LIST
65008: LIST
65009: PUSH
65010: LD_INT 1
65012: NEG
65013: PUSH
65014: LD_INT 3
65016: NEG
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: PUSH
65022: LD_INT 0
65024: PUSH
65025: LD_INT 3
65027: NEG
65028: PUSH
65029: EMPTY
65030: LIST
65031: LIST
65032: PUSH
65033: LD_INT 1
65035: PUSH
65036: LD_INT 2
65038: NEG
65039: PUSH
65040: EMPTY
65041: LIST
65042: LIST
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: LIST
65048: LIST
65049: LIST
65050: LIST
65051: LIST
65052: LIST
65053: LIST
65054: LIST
65055: LIST
65056: LIST
65057: LIST
65058: LIST
65059: LIST
65060: LIST
65061: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
65062: LD_ADDR_VAR 0 15
65066: PUSH
65067: LD_INT 0
65069: PUSH
65070: LD_INT 0
65072: PUSH
65073: EMPTY
65074: LIST
65075: LIST
65076: PUSH
65077: LD_INT 0
65079: PUSH
65080: LD_INT 1
65082: NEG
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PUSH
65088: LD_INT 1
65090: PUSH
65091: LD_INT 0
65093: PUSH
65094: EMPTY
65095: LIST
65096: LIST
65097: PUSH
65098: LD_INT 1
65100: PUSH
65101: LD_INT 1
65103: PUSH
65104: EMPTY
65105: LIST
65106: LIST
65107: PUSH
65108: LD_INT 0
65110: PUSH
65111: LD_INT 1
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 1
65120: NEG
65121: PUSH
65122: LD_INT 0
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: PUSH
65129: LD_INT 1
65131: NEG
65132: PUSH
65133: LD_INT 1
65135: NEG
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: LD_INT 1
65143: PUSH
65144: LD_INT 1
65146: NEG
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: PUSH
65152: LD_INT 2
65154: PUSH
65155: LD_INT 0
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: PUSH
65162: LD_INT 2
65164: PUSH
65165: LD_INT 1
65167: PUSH
65168: EMPTY
65169: LIST
65170: LIST
65171: PUSH
65172: LD_INT 1
65174: NEG
65175: PUSH
65176: LD_INT 1
65178: PUSH
65179: EMPTY
65180: LIST
65181: LIST
65182: PUSH
65183: LD_INT 2
65185: NEG
65186: PUSH
65187: LD_INT 0
65189: PUSH
65190: EMPTY
65191: LIST
65192: LIST
65193: PUSH
65194: LD_INT 2
65196: NEG
65197: PUSH
65198: LD_INT 1
65200: NEG
65201: PUSH
65202: EMPTY
65203: LIST
65204: LIST
65205: PUSH
65206: LD_INT 2
65208: PUSH
65209: LD_INT 1
65211: NEG
65212: PUSH
65213: EMPTY
65214: LIST
65215: LIST
65216: PUSH
65217: LD_INT 3
65219: PUSH
65220: LD_INT 0
65222: PUSH
65223: EMPTY
65224: LIST
65225: LIST
65226: PUSH
65227: LD_INT 3
65229: PUSH
65230: LD_INT 1
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: LIST
65243: LIST
65244: LIST
65245: LIST
65246: LIST
65247: LIST
65248: LIST
65249: LIST
65250: LIST
65251: LIST
65252: LIST
65253: LIST
65254: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65255: LD_ADDR_VAR 0 16
65259: PUSH
65260: LD_INT 0
65262: PUSH
65263: LD_INT 0
65265: PUSH
65266: EMPTY
65267: LIST
65268: LIST
65269: PUSH
65270: LD_INT 0
65272: PUSH
65273: LD_INT 1
65275: NEG
65276: PUSH
65277: EMPTY
65278: LIST
65279: LIST
65280: PUSH
65281: LD_INT 1
65283: PUSH
65284: LD_INT 0
65286: PUSH
65287: EMPTY
65288: LIST
65289: LIST
65290: PUSH
65291: LD_INT 1
65293: PUSH
65294: LD_INT 1
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: PUSH
65301: LD_INT 0
65303: PUSH
65304: LD_INT 1
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: PUSH
65311: LD_INT 1
65313: NEG
65314: PUSH
65315: LD_INT 0
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: PUSH
65322: LD_INT 1
65324: NEG
65325: PUSH
65326: LD_INT 1
65328: NEG
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: LD_INT 1
65336: NEG
65337: PUSH
65338: LD_INT 2
65340: NEG
65341: PUSH
65342: EMPTY
65343: LIST
65344: LIST
65345: PUSH
65346: LD_INT 2
65348: PUSH
65349: LD_INT 1
65351: PUSH
65352: EMPTY
65353: LIST
65354: LIST
65355: PUSH
65356: LD_INT 2
65358: PUSH
65359: LD_INT 2
65361: PUSH
65362: EMPTY
65363: LIST
65364: LIST
65365: PUSH
65366: LD_INT 1
65368: PUSH
65369: LD_INT 2
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: PUSH
65376: LD_INT 2
65378: NEG
65379: PUSH
65380: LD_INT 1
65382: NEG
65383: PUSH
65384: EMPTY
65385: LIST
65386: LIST
65387: PUSH
65388: LD_INT 2
65390: NEG
65391: PUSH
65392: LD_INT 2
65394: NEG
65395: PUSH
65396: EMPTY
65397: LIST
65398: LIST
65399: PUSH
65400: LD_INT 3
65402: PUSH
65403: LD_INT 2
65405: PUSH
65406: EMPTY
65407: LIST
65408: LIST
65409: PUSH
65410: LD_INT 3
65412: PUSH
65413: LD_INT 3
65415: PUSH
65416: EMPTY
65417: LIST
65418: LIST
65419: PUSH
65420: LD_INT 2
65422: PUSH
65423: LD_INT 3
65425: PUSH
65426: EMPTY
65427: LIST
65428: LIST
65429: PUSH
65430: EMPTY
65431: LIST
65432: LIST
65433: LIST
65434: LIST
65435: LIST
65436: LIST
65437: LIST
65438: LIST
65439: LIST
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65448: LD_ADDR_VAR 0 17
65452: PUSH
65453: LD_INT 0
65455: PUSH
65456: LD_INT 0
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PUSH
65463: LD_INT 0
65465: PUSH
65466: LD_INT 1
65468: NEG
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: LD_INT 1
65476: PUSH
65477: LD_INT 0
65479: PUSH
65480: EMPTY
65481: LIST
65482: LIST
65483: PUSH
65484: LD_INT 1
65486: PUSH
65487: LD_INT 1
65489: PUSH
65490: EMPTY
65491: LIST
65492: LIST
65493: PUSH
65494: LD_INT 0
65496: PUSH
65497: LD_INT 1
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: PUSH
65504: LD_INT 1
65506: NEG
65507: PUSH
65508: LD_INT 0
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PUSH
65515: LD_INT 1
65517: NEG
65518: PUSH
65519: LD_INT 1
65521: NEG
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: PUSH
65527: LD_INT 1
65529: NEG
65530: PUSH
65531: LD_INT 2
65533: NEG
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: LD_INT 0
65541: PUSH
65542: LD_INT 2
65544: NEG
65545: PUSH
65546: EMPTY
65547: LIST
65548: LIST
65549: PUSH
65550: LD_INT 1
65552: PUSH
65553: LD_INT 1
65555: NEG
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 2
65563: PUSH
65564: LD_INT 0
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: PUSH
65571: LD_INT 2
65573: PUSH
65574: LD_INT 1
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: LD_INT 2
65583: PUSH
65584: LD_INT 2
65586: PUSH
65587: EMPTY
65588: LIST
65589: LIST
65590: PUSH
65591: LD_INT 1
65593: PUSH
65594: LD_INT 2
65596: PUSH
65597: EMPTY
65598: LIST
65599: LIST
65600: PUSH
65601: LD_INT 0
65603: PUSH
65604: LD_INT 2
65606: PUSH
65607: EMPTY
65608: LIST
65609: LIST
65610: PUSH
65611: LD_INT 1
65613: NEG
65614: PUSH
65615: LD_INT 1
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: PUSH
65622: LD_INT 2
65624: NEG
65625: PUSH
65626: LD_INT 0
65628: PUSH
65629: EMPTY
65630: LIST
65631: LIST
65632: PUSH
65633: LD_INT 2
65635: NEG
65636: PUSH
65637: LD_INT 1
65639: NEG
65640: PUSH
65641: EMPTY
65642: LIST
65643: LIST
65644: PUSH
65645: LD_INT 2
65647: NEG
65648: PUSH
65649: LD_INT 2
65651: NEG
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PUSH
65657: EMPTY
65658: LIST
65659: LIST
65660: LIST
65661: LIST
65662: LIST
65663: LIST
65664: LIST
65665: LIST
65666: LIST
65667: LIST
65668: LIST
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65678: LD_ADDR_VAR 0 18
65682: PUSH
65683: LD_INT 0
65685: PUSH
65686: LD_INT 0
65688: PUSH
65689: EMPTY
65690: LIST
65691: LIST
65692: PUSH
65693: LD_INT 0
65695: PUSH
65696: LD_INT 1
65698: NEG
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: LD_INT 1
65706: PUSH
65707: LD_INT 0
65709: PUSH
65710: EMPTY
65711: LIST
65712: LIST
65713: PUSH
65714: LD_INT 1
65716: PUSH
65717: LD_INT 1
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 0
65726: PUSH
65727: LD_INT 1
65729: PUSH
65730: EMPTY
65731: LIST
65732: LIST
65733: PUSH
65734: LD_INT 1
65736: NEG
65737: PUSH
65738: LD_INT 0
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: PUSH
65745: LD_INT 1
65747: NEG
65748: PUSH
65749: LD_INT 1
65751: NEG
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 1
65759: NEG
65760: PUSH
65761: LD_INT 2
65763: NEG
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PUSH
65769: LD_INT 0
65771: PUSH
65772: LD_INT 2
65774: NEG
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PUSH
65780: LD_INT 1
65782: PUSH
65783: LD_INT 1
65785: NEG
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 2
65793: PUSH
65794: LD_INT 0
65796: PUSH
65797: EMPTY
65798: LIST
65799: LIST
65800: PUSH
65801: LD_INT 2
65803: PUSH
65804: LD_INT 1
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: PUSH
65811: LD_INT 2
65813: PUSH
65814: LD_INT 2
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: PUSH
65821: LD_INT 1
65823: PUSH
65824: LD_INT 2
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PUSH
65831: LD_INT 0
65833: PUSH
65834: LD_INT 2
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PUSH
65841: LD_INT 1
65843: NEG
65844: PUSH
65845: LD_INT 1
65847: PUSH
65848: EMPTY
65849: LIST
65850: LIST
65851: PUSH
65852: LD_INT 2
65854: NEG
65855: PUSH
65856: LD_INT 0
65858: PUSH
65859: EMPTY
65860: LIST
65861: LIST
65862: PUSH
65863: LD_INT 2
65865: NEG
65866: PUSH
65867: LD_INT 1
65869: NEG
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: PUSH
65875: LD_INT 2
65877: NEG
65878: PUSH
65879: LD_INT 2
65881: NEG
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: EMPTY
65888: LIST
65889: LIST
65890: LIST
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65908: LD_ADDR_VAR 0 19
65912: PUSH
65913: LD_INT 0
65915: PUSH
65916: LD_INT 0
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: LD_INT 0
65925: PUSH
65926: LD_INT 1
65928: NEG
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 1
65936: PUSH
65937: LD_INT 0
65939: PUSH
65940: EMPTY
65941: LIST
65942: LIST
65943: PUSH
65944: LD_INT 1
65946: PUSH
65947: LD_INT 1
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 0
65956: PUSH
65957: LD_INT 1
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 1
65966: NEG
65967: PUSH
65968: LD_INT 0
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 1
65977: NEG
65978: PUSH
65979: LD_INT 1
65981: NEG
65982: PUSH
65983: EMPTY
65984: LIST
65985: LIST
65986: PUSH
65987: LD_INT 1
65989: NEG
65990: PUSH
65991: LD_INT 2
65993: NEG
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: PUSH
65999: LD_INT 0
66001: PUSH
66002: LD_INT 2
66004: NEG
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PUSH
66010: LD_INT 1
66012: PUSH
66013: LD_INT 1
66015: NEG
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: LD_INT 2
66023: PUSH
66024: LD_INT 0
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 2
66033: PUSH
66034: LD_INT 1
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: LD_INT 2
66043: PUSH
66044: LD_INT 2
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: PUSH
66051: LD_INT 1
66053: PUSH
66054: LD_INT 2
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 0
66063: PUSH
66064: LD_INT 2
66066: PUSH
66067: EMPTY
66068: LIST
66069: LIST
66070: PUSH
66071: LD_INT 1
66073: NEG
66074: PUSH
66075: LD_INT 1
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 2
66084: NEG
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: LD_INT 2
66095: NEG
66096: PUSH
66097: LD_INT 1
66099: NEG
66100: PUSH
66101: EMPTY
66102: LIST
66103: LIST
66104: PUSH
66105: LD_INT 2
66107: NEG
66108: PUSH
66109: LD_INT 2
66111: NEG
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: EMPTY
66118: LIST
66119: LIST
66120: LIST
66121: LIST
66122: LIST
66123: LIST
66124: LIST
66125: LIST
66126: LIST
66127: LIST
66128: LIST
66129: LIST
66130: LIST
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66138: LD_ADDR_VAR 0 20
66142: PUSH
66143: LD_INT 0
66145: PUSH
66146: LD_INT 0
66148: PUSH
66149: EMPTY
66150: LIST
66151: LIST
66152: PUSH
66153: LD_INT 0
66155: PUSH
66156: LD_INT 1
66158: NEG
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PUSH
66164: LD_INT 1
66166: PUSH
66167: LD_INT 0
66169: PUSH
66170: EMPTY
66171: LIST
66172: LIST
66173: PUSH
66174: LD_INT 1
66176: PUSH
66177: LD_INT 1
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 0
66186: PUSH
66187: LD_INT 1
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: PUSH
66194: LD_INT 1
66196: NEG
66197: PUSH
66198: LD_INT 0
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PUSH
66205: LD_INT 1
66207: NEG
66208: PUSH
66209: LD_INT 1
66211: NEG
66212: PUSH
66213: EMPTY
66214: LIST
66215: LIST
66216: PUSH
66217: LD_INT 1
66219: NEG
66220: PUSH
66221: LD_INT 2
66223: NEG
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: PUSH
66229: LD_INT 0
66231: PUSH
66232: LD_INT 2
66234: NEG
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 1
66242: PUSH
66243: LD_INT 1
66245: NEG
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: PUSH
66251: LD_INT 2
66253: PUSH
66254: LD_INT 0
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 2
66263: PUSH
66264: LD_INT 1
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PUSH
66271: LD_INT 2
66273: PUSH
66274: LD_INT 2
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 1
66283: PUSH
66284: LD_INT 2
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: LD_INT 0
66293: PUSH
66294: LD_INT 2
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PUSH
66301: LD_INT 1
66303: NEG
66304: PUSH
66305: LD_INT 1
66307: PUSH
66308: EMPTY
66309: LIST
66310: LIST
66311: PUSH
66312: LD_INT 2
66314: NEG
66315: PUSH
66316: LD_INT 0
66318: PUSH
66319: EMPTY
66320: LIST
66321: LIST
66322: PUSH
66323: LD_INT 2
66325: NEG
66326: PUSH
66327: LD_INT 1
66329: NEG
66330: PUSH
66331: EMPTY
66332: LIST
66333: LIST
66334: PUSH
66335: LD_INT 2
66337: NEG
66338: PUSH
66339: LD_INT 2
66341: NEG
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: LIST
66355: LIST
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66368: LD_ADDR_VAR 0 21
66372: PUSH
66373: LD_INT 0
66375: PUSH
66376: LD_INT 0
66378: PUSH
66379: EMPTY
66380: LIST
66381: LIST
66382: PUSH
66383: LD_INT 0
66385: PUSH
66386: LD_INT 1
66388: NEG
66389: PUSH
66390: EMPTY
66391: LIST
66392: LIST
66393: PUSH
66394: LD_INT 1
66396: PUSH
66397: LD_INT 0
66399: PUSH
66400: EMPTY
66401: LIST
66402: LIST
66403: PUSH
66404: LD_INT 1
66406: PUSH
66407: LD_INT 1
66409: PUSH
66410: EMPTY
66411: LIST
66412: LIST
66413: PUSH
66414: LD_INT 0
66416: PUSH
66417: LD_INT 1
66419: PUSH
66420: EMPTY
66421: LIST
66422: LIST
66423: PUSH
66424: LD_INT 1
66426: NEG
66427: PUSH
66428: LD_INT 0
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: PUSH
66435: LD_INT 1
66437: NEG
66438: PUSH
66439: LD_INT 1
66441: NEG
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PUSH
66447: LD_INT 1
66449: NEG
66450: PUSH
66451: LD_INT 2
66453: NEG
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PUSH
66459: LD_INT 0
66461: PUSH
66462: LD_INT 2
66464: NEG
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PUSH
66470: LD_INT 1
66472: PUSH
66473: LD_INT 1
66475: NEG
66476: PUSH
66477: EMPTY
66478: LIST
66479: LIST
66480: PUSH
66481: LD_INT 2
66483: PUSH
66484: LD_INT 0
66486: PUSH
66487: EMPTY
66488: LIST
66489: LIST
66490: PUSH
66491: LD_INT 2
66493: PUSH
66494: LD_INT 1
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: LD_INT 2
66503: PUSH
66504: LD_INT 2
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: PUSH
66511: LD_INT 1
66513: PUSH
66514: LD_INT 2
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PUSH
66521: LD_INT 0
66523: PUSH
66524: LD_INT 2
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: PUSH
66531: LD_INT 1
66533: NEG
66534: PUSH
66535: LD_INT 1
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: LD_INT 2
66544: NEG
66545: PUSH
66546: LD_INT 0
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PUSH
66553: LD_INT 2
66555: NEG
66556: PUSH
66557: LD_INT 1
66559: NEG
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 2
66567: NEG
66568: PUSH
66569: LD_INT 2
66571: NEG
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: LIST
66581: LIST
66582: LIST
66583: LIST
66584: LIST
66585: LIST
66586: LIST
66587: LIST
66588: LIST
66589: LIST
66590: LIST
66591: LIST
66592: LIST
66593: LIST
66594: LIST
66595: LIST
66596: LIST
66597: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66598: LD_ADDR_VAR 0 22
66602: PUSH
66603: LD_INT 0
66605: PUSH
66606: LD_INT 0
66608: PUSH
66609: EMPTY
66610: LIST
66611: LIST
66612: PUSH
66613: LD_INT 0
66615: PUSH
66616: LD_INT 1
66618: NEG
66619: PUSH
66620: EMPTY
66621: LIST
66622: LIST
66623: PUSH
66624: LD_INT 1
66626: PUSH
66627: LD_INT 0
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: PUSH
66634: LD_INT 1
66636: PUSH
66637: LD_INT 1
66639: PUSH
66640: EMPTY
66641: LIST
66642: LIST
66643: PUSH
66644: LD_INT 0
66646: PUSH
66647: LD_INT 1
66649: PUSH
66650: EMPTY
66651: LIST
66652: LIST
66653: PUSH
66654: LD_INT 1
66656: NEG
66657: PUSH
66658: LD_INT 0
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 1
66667: NEG
66668: PUSH
66669: LD_INT 1
66671: NEG
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 1
66679: NEG
66680: PUSH
66681: LD_INT 2
66683: NEG
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 0
66691: PUSH
66692: LD_INT 2
66694: NEG
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: LD_INT 1
66702: PUSH
66703: LD_INT 1
66705: NEG
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: PUSH
66711: LD_INT 2
66713: PUSH
66714: LD_INT 0
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: LD_INT 2
66723: PUSH
66724: LD_INT 1
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: PUSH
66731: LD_INT 2
66733: PUSH
66734: LD_INT 2
66736: PUSH
66737: EMPTY
66738: LIST
66739: LIST
66740: PUSH
66741: LD_INT 1
66743: PUSH
66744: LD_INT 2
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PUSH
66751: LD_INT 0
66753: PUSH
66754: LD_INT 2
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 1
66763: NEG
66764: PUSH
66765: LD_INT 1
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: LD_INT 2
66774: NEG
66775: PUSH
66776: LD_INT 0
66778: PUSH
66779: EMPTY
66780: LIST
66781: LIST
66782: PUSH
66783: LD_INT 2
66785: NEG
66786: PUSH
66787: LD_INT 1
66789: NEG
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: LD_INT 2
66797: NEG
66798: PUSH
66799: LD_INT 2
66801: NEG
66802: PUSH
66803: EMPTY
66804: LIST
66805: LIST
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: LIST
66811: LIST
66812: LIST
66813: LIST
66814: LIST
66815: LIST
66816: LIST
66817: LIST
66818: LIST
66819: LIST
66820: LIST
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: LIST
66826: LIST
66827: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66828: LD_ADDR_VAR 0 23
66832: PUSH
66833: LD_INT 0
66835: PUSH
66836: LD_INT 0
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: PUSH
66843: LD_INT 0
66845: PUSH
66846: LD_INT 1
66848: NEG
66849: PUSH
66850: EMPTY
66851: LIST
66852: LIST
66853: PUSH
66854: LD_INT 1
66856: PUSH
66857: LD_INT 0
66859: PUSH
66860: EMPTY
66861: LIST
66862: LIST
66863: PUSH
66864: LD_INT 1
66866: PUSH
66867: LD_INT 1
66869: PUSH
66870: EMPTY
66871: LIST
66872: LIST
66873: PUSH
66874: LD_INT 0
66876: PUSH
66877: LD_INT 1
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: PUSH
66884: LD_INT 1
66886: NEG
66887: PUSH
66888: LD_INT 0
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 1
66897: NEG
66898: PUSH
66899: LD_INT 1
66901: NEG
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: LD_INT 1
66909: NEG
66910: PUSH
66911: LD_INT 2
66913: NEG
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: LD_INT 0
66921: PUSH
66922: LD_INT 2
66924: NEG
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: PUSH
66930: LD_INT 1
66932: PUSH
66933: LD_INT 1
66935: NEG
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 2
66943: PUSH
66944: LD_INT 0
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: PUSH
66951: LD_INT 2
66953: PUSH
66954: LD_INT 1
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: PUSH
66961: LD_INT 2
66963: PUSH
66964: LD_INT 2
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PUSH
66971: LD_INT 1
66973: PUSH
66974: LD_INT 2
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: PUSH
66981: LD_INT 0
66983: PUSH
66984: LD_INT 2
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: PUSH
66991: LD_INT 1
66993: NEG
66994: PUSH
66995: LD_INT 1
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 2
67004: NEG
67005: PUSH
67006: LD_INT 0
67008: PUSH
67009: EMPTY
67010: LIST
67011: LIST
67012: PUSH
67013: LD_INT 2
67015: NEG
67016: PUSH
67017: LD_INT 1
67019: NEG
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PUSH
67025: LD_INT 2
67027: NEG
67028: PUSH
67029: LD_INT 2
67031: NEG
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: PUSH
67037: LD_INT 2
67039: NEG
67040: PUSH
67041: LD_INT 3
67043: NEG
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: PUSH
67049: LD_INT 1
67051: NEG
67052: PUSH
67053: LD_INT 3
67055: NEG
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: PUSH
67061: LD_INT 1
67063: PUSH
67064: LD_INT 2
67066: NEG
67067: PUSH
67068: EMPTY
67069: LIST
67070: LIST
67071: PUSH
67072: LD_INT 2
67074: PUSH
67075: LD_INT 1
67077: NEG
67078: PUSH
67079: EMPTY
67080: LIST
67081: LIST
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: LIST
67087: LIST
67088: LIST
67089: LIST
67090: LIST
67091: LIST
67092: LIST
67093: LIST
67094: LIST
67095: LIST
67096: LIST
67097: LIST
67098: LIST
67099: LIST
67100: LIST
67101: LIST
67102: LIST
67103: LIST
67104: LIST
67105: LIST
67106: LIST
67107: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67108: LD_ADDR_VAR 0 24
67112: PUSH
67113: LD_INT 0
67115: PUSH
67116: LD_INT 0
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: LD_INT 0
67125: PUSH
67126: LD_INT 1
67128: NEG
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 1
67136: PUSH
67137: LD_INT 0
67139: PUSH
67140: EMPTY
67141: LIST
67142: LIST
67143: PUSH
67144: LD_INT 1
67146: PUSH
67147: LD_INT 1
67149: PUSH
67150: EMPTY
67151: LIST
67152: LIST
67153: PUSH
67154: LD_INT 0
67156: PUSH
67157: LD_INT 1
67159: PUSH
67160: EMPTY
67161: LIST
67162: LIST
67163: PUSH
67164: LD_INT 1
67166: NEG
67167: PUSH
67168: LD_INT 0
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 1
67177: NEG
67178: PUSH
67179: LD_INT 1
67181: NEG
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: LD_INT 1
67189: NEG
67190: PUSH
67191: LD_INT 2
67193: NEG
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 0
67201: PUSH
67202: LD_INT 2
67204: NEG
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 1
67212: PUSH
67213: LD_INT 1
67215: NEG
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 2
67223: PUSH
67224: LD_INT 0
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: PUSH
67231: LD_INT 2
67233: PUSH
67234: LD_INT 1
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 2
67243: PUSH
67244: LD_INT 2
67246: PUSH
67247: EMPTY
67248: LIST
67249: LIST
67250: PUSH
67251: LD_INT 1
67253: PUSH
67254: LD_INT 2
67256: PUSH
67257: EMPTY
67258: LIST
67259: LIST
67260: PUSH
67261: LD_INT 0
67263: PUSH
67264: LD_INT 2
67266: PUSH
67267: EMPTY
67268: LIST
67269: LIST
67270: PUSH
67271: LD_INT 1
67273: NEG
67274: PUSH
67275: LD_INT 1
67277: PUSH
67278: EMPTY
67279: LIST
67280: LIST
67281: PUSH
67282: LD_INT 2
67284: NEG
67285: PUSH
67286: LD_INT 0
67288: PUSH
67289: EMPTY
67290: LIST
67291: LIST
67292: PUSH
67293: LD_INT 2
67295: NEG
67296: PUSH
67297: LD_INT 1
67299: NEG
67300: PUSH
67301: EMPTY
67302: LIST
67303: LIST
67304: PUSH
67305: LD_INT 2
67307: NEG
67308: PUSH
67309: LD_INT 2
67311: NEG
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 1
67319: PUSH
67320: LD_INT 2
67322: NEG
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 2
67330: PUSH
67331: LD_INT 1
67333: NEG
67334: PUSH
67335: EMPTY
67336: LIST
67337: LIST
67338: PUSH
67339: LD_INT 3
67341: PUSH
67342: LD_INT 1
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 3
67351: PUSH
67352: LD_INT 2
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: EMPTY
67360: LIST
67361: LIST
67362: LIST
67363: LIST
67364: LIST
67365: LIST
67366: LIST
67367: LIST
67368: LIST
67369: LIST
67370: LIST
67371: LIST
67372: LIST
67373: LIST
67374: LIST
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67384: LD_ADDR_VAR 0 25
67388: PUSH
67389: LD_INT 0
67391: PUSH
67392: LD_INT 0
67394: PUSH
67395: EMPTY
67396: LIST
67397: LIST
67398: PUSH
67399: LD_INT 0
67401: PUSH
67402: LD_INT 1
67404: NEG
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 1
67412: PUSH
67413: LD_INT 0
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 1
67422: PUSH
67423: LD_INT 1
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: PUSH
67430: LD_INT 0
67432: PUSH
67433: LD_INT 1
67435: PUSH
67436: EMPTY
67437: LIST
67438: LIST
67439: PUSH
67440: LD_INT 1
67442: NEG
67443: PUSH
67444: LD_INT 0
67446: PUSH
67447: EMPTY
67448: LIST
67449: LIST
67450: PUSH
67451: LD_INT 1
67453: NEG
67454: PUSH
67455: LD_INT 1
67457: NEG
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: PUSH
67463: LD_INT 1
67465: NEG
67466: PUSH
67467: LD_INT 2
67469: NEG
67470: PUSH
67471: EMPTY
67472: LIST
67473: LIST
67474: PUSH
67475: LD_INT 0
67477: PUSH
67478: LD_INT 2
67480: NEG
67481: PUSH
67482: EMPTY
67483: LIST
67484: LIST
67485: PUSH
67486: LD_INT 1
67488: PUSH
67489: LD_INT 1
67491: NEG
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: PUSH
67497: LD_INT 2
67499: PUSH
67500: LD_INT 0
67502: PUSH
67503: EMPTY
67504: LIST
67505: LIST
67506: PUSH
67507: LD_INT 2
67509: PUSH
67510: LD_INT 1
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 2
67519: PUSH
67520: LD_INT 2
67522: PUSH
67523: EMPTY
67524: LIST
67525: LIST
67526: PUSH
67527: LD_INT 1
67529: PUSH
67530: LD_INT 2
67532: PUSH
67533: EMPTY
67534: LIST
67535: LIST
67536: PUSH
67537: LD_INT 0
67539: PUSH
67540: LD_INT 2
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 1
67549: NEG
67550: PUSH
67551: LD_INT 1
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 2
67560: NEG
67561: PUSH
67562: LD_INT 0
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 2
67571: NEG
67572: PUSH
67573: LD_INT 1
67575: NEG
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: LD_INT 2
67583: NEG
67584: PUSH
67585: LD_INT 2
67587: NEG
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PUSH
67593: LD_INT 3
67595: PUSH
67596: LD_INT 1
67598: PUSH
67599: EMPTY
67600: LIST
67601: LIST
67602: PUSH
67603: LD_INT 3
67605: PUSH
67606: LD_INT 2
67608: PUSH
67609: EMPTY
67610: LIST
67611: LIST
67612: PUSH
67613: LD_INT 2
67615: PUSH
67616: LD_INT 3
67618: PUSH
67619: EMPTY
67620: LIST
67621: LIST
67622: PUSH
67623: LD_INT 1
67625: PUSH
67626: LD_INT 3
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67658: LD_ADDR_VAR 0 26
67662: PUSH
67663: LD_INT 0
67665: PUSH
67666: LD_INT 0
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 0
67675: PUSH
67676: LD_INT 1
67678: NEG
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: LD_INT 1
67686: PUSH
67687: LD_INT 0
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 1
67696: PUSH
67697: LD_INT 1
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: LD_INT 0
67706: PUSH
67707: LD_INT 1
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: LD_INT 1
67716: NEG
67717: PUSH
67718: LD_INT 0
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: LD_INT 1
67727: NEG
67728: PUSH
67729: LD_INT 1
67731: NEG
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: LD_INT 1
67739: NEG
67740: PUSH
67741: LD_INT 2
67743: NEG
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: PUSH
67749: LD_INT 0
67751: PUSH
67752: LD_INT 2
67754: NEG
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 1
67762: PUSH
67763: LD_INT 1
67765: NEG
67766: PUSH
67767: EMPTY
67768: LIST
67769: LIST
67770: PUSH
67771: LD_INT 2
67773: PUSH
67774: LD_INT 0
67776: PUSH
67777: EMPTY
67778: LIST
67779: LIST
67780: PUSH
67781: LD_INT 2
67783: PUSH
67784: LD_INT 1
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PUSH
67791: LD_INT 2
67793: PUSH
67794: LD_INT 2
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 1
67803: PUSH
67804: LD_INT 2
67806: PUSH
67807: EMPTY
67808: LIST
67809: LIST
67810: PUSH
67811: LD_INT 0
67813: PUSH
67814: LD_INT 2
67816: PUSH
67817: EMPTY
67818: LIST
67819: LIST
67820: PUSH
67821: LD_INT 1
67823: NEG
67824: PUSH
67825: LD_INT 1
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 2
67834: NEG
67835: PUSH
67836: LD_INT 0
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: LD_INT 2
67845: NEG
67846: PUSH
67847: LD_INT 1
67849: NEG
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 2
67857: NEG
67858: PUSH
67859: LD_INT 2
67861: NEG
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: PUSH
67867: LD_INT 2
67869: PUSH
67870: LD_INT 3
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PUSH
67877: LD_INT 1
67879: PUSH
67880: LD_INT 3
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: PUSH
67887: LD_INT 1
67889: NEG
67890: PUSH
67891: LD_INT 2
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: PUSH
67898: LD_INT 2
67900: NEG
67901: PUSH
67902: LD_INT 1
67904: PUSH
67905: EMPTY
67906: LIST
67907: LIST
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67934: LD_ADDR_VAR 0 27
67938: PUSH
67939: LD_INT 0
67941: PUSH
67942: LD_INT 0
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 0
67951: PUSH
67952: LD_INT 1
67954: NEG
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 1
67962: PUSH
67963: LD_INT 0
67965: PUSH
67966: EMPTY
67967: LIST
67968: LIST
67969: PUSH
67970: LD_INT 1
67972: PUSH
67973: LD_INT 1
67975: PUSH
67976: EMPTY
67977: LIST
67978: LIST
67979: PUSH
67980: LD_INT 0
67982: PUSH
67983: LD_INT 1
67985: PUSH
67986: EMPTY
67987: LIST
67988: LIST
67989: PUSH
67990: LD_INT 1
67992: NEG
67993: PUSH
67994: LD_INT 0
67996: PUSH
67997: EMPTY
67998: LIST
67999: LIST
68000: PUSH
68001: LD_INT 1
68003: NEG
68004: PUSH
68005: LD_INT 1
68007: NEG
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 1
68015: NEG
68016: PUSH
68017: LD_INT 2
68019: NEG
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: LD_INT 0
68027: PUSH
68028: LD_INT 2
68030: NEG
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: PUSH
68036: LD_INT 1
68038: PUSH
68039: LD_INT 1
68041: NEG
68042: PUSH
68043: EMPTY
68044: LIST
68045: LIST
68046: PUSH
68047: LD_INT 2
68049: PUSH
68050: LD_INT 0
68052: PUSH
68053: EMPTY
68054: LIST
68055: LIST
68056: PUSH
68057: LD_INT 2
68059: PUSH
68060: LD_INT 1
68062: PUSH
68063: EMPTY
68064: LIST
68065: LIST
68066: PUSH
68067: LD_INT 2
68069: PUSH
68070: LD_INT 2
68072: PUSH
68073: EMPTY
68074: LIST
68075: LIST
68076: PUSH
68077: LD_INT 1
68079: PUSH
68080: LD_INT 2
68082: PUSH
68083: EMPTY
68084: LIST
68085: LIST
68086: PUSH
68087: LD_INT 0
68089: PUSH
68090: LD_INT 2
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PUSH
68097: LD_INT 1
68099: NEG
68100: PUSH
68101: LD_INT 1
68103: PUSH
68104: EMPTY
68105: LIST
68106: LIST
68107: PUSH
68108: LD_INT 2
68110: NEG
68111: PUSH
68112: LD_INT 0
68114: PUSH
68115: EMPTY
68116: LIST
68117: LIST
68118: PUSH
68119: LD_INT 2
68121: NEG
68122: PUSH
68123: LD_INT 1
68125: NEG
68126: PUSH
68127: EMPTY
68128: LIST
68129: LIST
68130: PUSH
68131: LD_INT 2
68133: NEG
68134: PUSH
68135: LD_INT 2
68137: NEG
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PUSH
68143: LD_INT 1
68145: NEG
68146: PUSH
68147: LD_INT 2
68149: PUSH
68150: EMPTY
68151: LIST
68152: LIST
68153: PUSH
68154: LD_INT 2
68156: NEG
68157: PUSH
68158: LD_INT 1
68160: PUSH
68161: EMPTY
68162: LIST
68163: LIST
68164: PUSH
68165: LD_INT 3
68167: NEG
68168: PUSH
68169: LD_INT 1
68171: NEG
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 3
68179: NEG
68180: PUSH
68181: LD_INT 2
68183: NEG
68184: PUSH
68185: EMPTY
68186: LIST
68187: LIST
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: LIST
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: LIST
68211: LIST
68212: LIST
68213: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68214: LD_ADDR_VAR 0 28
68218: PUSH
68219: LD_INT 0
68221: PUSH
68222: LD_INT 0
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 0
68231: PUSH
68232: LD_INT 1
68234: NEG
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 1
68242: PUSH
68243: LD_INT 0
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 1
68252: PUSH
68253: LD_INT 1
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 0
68262: PUSH
68263: LD_INT 1
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 1
68272: NEG
68273: PUSH
68274: LD_INT 0
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: PUSH
68281: LD_INT 1
68283: NEG
68284: PUSH
68285: LD_INT 1
68287: NEG
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 1
68295: NEG
68296: PUSH
68297: LD_INT 2
68299: NEG
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 0
68307: PUSH
68308: LD_INT 2
68310: NEG
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 1
68318: PUSH
68319: LD_INT 1
68321: NEG
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PUSH
68327: LD_INT 2
68329: PUSH
68330: LD_INT 0
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 2
68339: PUSH
68340: LD_INT 1
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: PUSH
68347: LD_INT 2
68349: PUSH
68350: LD_INT 2
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 1
68359: PUSH
68360: LD_INT 2
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 0
68369: PUSH
68370: LD_INT 2
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 1
68379: NEG
68380: PUSH
68381: LD_INT 1
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 2
68390: NEG
68391: PUSH
68392: LD_INT 0
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: PUSH
68399: LD_INT 2
68401: NEG
68402: PUSH
68403: LD_INT 1
68405: NEG
68406: PUSH
68407: EMPTY
68408: LIST
68409: LIST
68410: PUSH
68411: LD_INT 2
68413: NEG
68414: PUSH
68415: LD_INT 2
68417: NEG
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 2
68425: NEG
68426: PUSH
68427: LD_INT 3
68429: NEG
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 1
68437: NEG
68438: PUSH
68439: LD_INT 3
68441: NEG
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: PUSH
68447: LD_INT 3
68449: NEG
68450: PUSH
68451: LD_INT 1
68453: NEG
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 3
68461: NEG
68462: PUSH
68463: LD_INT 2
68465: NEG
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: LIST
68475: LIST
68476: LIST
68477: LIST
68478: LIST
68479: LIST
68480: LIST
68481: LIST
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68496: LD_ADDR_VAR 0 29
68500: PUSH
68501: LD_INT 0
68503: PUSH
68504: LD_INT 0
68506: PUSH
68507: EMPTY
68508: LIST
68509: LIST
68510: PUSH
68511: LD_INT 0
68513: PUSH
68514: LD_INT 1
68516: NEG
68517: PUSH
68518: EMPTY
68519: LIST
68520: LIST
68521: PUSH
68522: LD_INT 1
68524: PUSH
68525: LD_INT 0
68527: PUSH
68528: EMPTY
68529: LIST
68530: LIST
68531: PUSH
68532: LD_INT 1
68534: PUSH
68535: LD_INT 1
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 0
68544: PUSH
68545: LD_INT 1
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 1
68554: NEG
68555: PUSH
68556: LD_INT 0
68558: PUSH
68559: EMPTY
68560: LIST
68561: LIST
68562: PUSH
68563: LD_INT 1
68565: NEG
68566: PUSH
68567: LD_INT 1
68569: NEG
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: PUSH
68575: LD_INT 1
68577: NEG
68578: PUSH
68579: LD_INT 2
68581: NEG
68582: PUSH
68583: EMPTY
68584: LIST
68585: LIST
68586: PUSH
68587: LD_INT 0
68589: PUSH
68590: LD_INT 2
68592: NEG
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 1
68600: PUSH
68601: LD_INT 1
68603: NEG
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: LD_INT 2
68611: PUSH
68612: LD_INT 0
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: LD_INT 2
68621: PUSH
68622: LD_INT 1
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: PUSH
68629: LD_INT 1
68631: PUSH
68632: LD_INT 2
68634: PUSH
68635: EMPTY
68636: LIST
68637: LIST
68638: PUSH
68639: LD_INT 0
68641: PUSH
68642: LD_INT 2
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: PUSH
68649: LD_INT 1
68651: NEG
68652: PUSH
68653: LD_INT 1
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: PUSH
68660: LD_INT 2
68662: NEG
68663: PUSH
68664: LD_INT 1
68666: NEG
68667: PUSH
68668: EMPTY
68669: LIST
68670: LIST
68671: PUSH
68672: LD_INT 2
68674: NEG
68675: PUSH
68676: LD_INT 2
68678: NEG
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: LD_INT 2
68686: NEG
68687: PUSH
68688: LD_INT 3
68690: NEG
68691: PUSH
68692: EMPTY
68693: LIST
68694: LIST
68695: PUSH
68696: LD_INT 2
68698: PUSH
68699: LD_INT 1
68701: NEG
68702: PUSH
68703: EMPTY
68704: LIST
68705: LIST
68706: PUSH
68707: LD_INT 3
68709: PUSH
68710: LD_INT 1
68712: PUSH
68713: EMPTY
68714: LIST
68715: LIST
68716: PUSH
68717: LD_INT 1
68719: PUSH
68720: LD_INT 3
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: PUSH
68727: LD_INT 1
68729: NEG
68730: PUSH
68731: LD_INT 2
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 3
68740: NEG
68741: PUSH
68742: LD_INT 2
68744: NEG
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: LIST
68754: LIST
68755: LIST
68756: LIST
68757: LIST
68758: LIST
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: LIST
68768: LIST
68769: LIST
68770: LIST
68771: LIST
68772: LIST
68773: LIST
68774: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68775: LD_ADDR_VAR 0 30
68779: PUSH
68780: LD_INT 0
68782: PUSH
68783: LD_INT 0
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: LD_INT 0
68792: PUSH
68793: LD_INT 1
68795: NEG
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PUSH
68801: LD_INT 1
68803: PUSH
68804: LD_INT 0
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PUSH
68811: LD_INT 1
68813: PUSH
68814: LD_INT 1
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 0
68823: PUSH
68824: LD_INT 1
68826: PUSH
68827: EMPTY
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 1
68833: NEG
68834: PUSH
68835: LD_INT 0
68837: PUSH
68838: EMPTY
68839: LIST
68840: LIST
68841: PUSH
68842: LD_INT 1
68844: NEG
68845: PUSH
68846: LD_INT 1
68848: NEG
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: LD_INT 1
68856: NEG
68857: PUSH
68858: LD_INT 2
68860: NEG
68861: PUSH
68862: EMPTY
68863: LIST
68864: LIST
68865: PUSH
68866: LD_INT 0
68868: PUSH
68869: LD_INT 2
68871: NEG
68872: PUSH
68873: EMPTY
68874: LIST
68875: LIST
68876: PUSH
68877: LD_INT 1
68879: PUSH
68880: LD_INT 1
68882: NEG
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: PUSH
68888: LD_INT 2
68890: PUSH
68891: LD_INT 0
68893: PUSH
68894: EMPTY
68895: LIST
68896: LIST
68897: PUSH
68898: LD_INT 2
68900: PUSH
68901: LD_INT 1
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 2
68910: PUSH
68911: LD_INT 2
68913: PUSH
68914: EMPTY
68915: LIST
68916: LIST
68917: PUSH
68918: LD_INT 1
68920: PUSH
68921: LD_INT 2
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: PUSH
68928: LD_INT 1
68930: NEG
68931: PUSH
68932: LD_INT 1
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 2
68941: NEG
68942: PUSH
68943: LD_INT 0
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: PUSH
68950: LD_INT 2
68952: NEG
68953: PUSH
68954: LD_INT 1
68956: NEG
68957: PUSH
68958: EMPTY
68959: LIST
68960: LIST
68961: PUSH
68962: LD_INT 1
68964: NEG
68965: PUSH
68966: LD_INT 3
68968: NEG
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 1
68976: PUSH
68977: LD_INT 2
68979: NEG
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: PUSH
68985: LD_INT 3
68987: PUSH
68988: LD_INT 2
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 2
68997: PUSH
68998: LD_INT 3
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: LD_INT 2
69007: NEG
69008: PUSH
69009: LD_INT 1
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: PUSH
69016: LD_INT 3
69018: NEG
69019: PUSH
69020: LD_INT 1
69022: NEG
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: EMPTY
69029: LIST
69030: LIST
69031: LIST
69032: LIST
69033: LIST
69034: LIST
69035: LIST
69036: LIST
69037: LIST
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: LIST
69051: LIST
69052: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69053: LD_ADDR_VAR 0 31
69057: PUSH
69058: LD_INT 0
69060: PUSH
69061: LD_INT 0
69063: PUSH
69064: EMPTY
69065: LIST
69066: LIST
69067: PUSH
69068: LD_INT 0
69070: PUSH
69071: LD_INT 1
69073: NEG
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: LD_INT 1
69081: PUSH
69082: LD_INT 0
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: PUSH
69089: LD_INT 1
69091: PUSH
69092: LD_INT 1
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 0
69101: PUSH
69102: LD_INT 1
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: PUSH
69109: LD_INT 1
69111: NEG
69112: PUSH
69113: LD_INT 0
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 1
69122: NEG
69123: PUSH
69124: LD_INT 1
69126: NEG
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 1
69134: NEG
69135: PUSH
69136: LD_INT 2
69138: NEG
69139: PUSH
69140: EMPTY
69141: LIST
69142: LIST
69143: PUSH
69144: LD_INT 1
69146: PUSH
69147: LD_INT 1
69149: NEG
69150: PUSH
69151: EMPTY
69152: LIST
69153: LIST
69154: PUSH
69155: LD_INT 2
69157: PUSH
69158: LD_INT 0
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: PUSH
69165: LD_INT 2
69167: PUSH
69168: LD_INT 1
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PUSH
69175: LD_INT 2
69177: PUSH
69178: LD_INT 2
69180: PUSH
69181: EMPTY
69182: LIST
69183: LIST
69184: PUSH
69185: LD_INT 1
69187: PUSH
69188: LD_INT 2
69190: PUSH
69191: EMPTY
69192: LIST
69193: LIST
69194: PUSH
69195: LD_INT 0
69197: PUSH
69198: LD_INT 2
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 1
69207: NEG
69208: PUSH
69209: LD_INT 1
69211: PUSH
69212: EMPTY
69213: LIST
69214: LIST
69215: PUSH
69216: LD_INT 2
69218: NEG
69219: PUSH
69220: LD_INT 1
69222: NEG
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PUSH
69228: LD_INT 2
69230: NEG
69231: PUSH
69232: LD_INT 2
69234: NEG
69235: PUSH
69236: EMPTY
69237: LIST
69238: LIST
69239: PUSH
69240: LD_INT 2
69242: NEG
69243: PUSH
69244: LD_INT 3
69246: NEG
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: PUSH
69252: LD_INT 2
69254: PUSH
69255: LD_INT 1
69257: NEG
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 3
69265: PUSH
69266: LD_INT 1
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: LD_INT 1
69275: PUSH
69276: LD_INT 3
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 1
69285: NEG
69286: PUSH
69287: LD_INT 2
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: PUSH
69294: LD_INT 3
69296: NEG
69297: PUSH
69298: LD_INT 2
69300: NEG
69301: PUSH
69302: EMPTY
69303: LIST
69304: LIST
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: LIST
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69331: LD_ADDR_VAR 0 32
69335: PUSH
69336: LD_INT 0
69338: PUSH
69339: LD_INT 0
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 0
69348: PUSH
69349: LD_INT 1
69351: NEG
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 1
69359: PUSH
69360: LD_INT 0
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 1
69369: PUSH
69370: LD_INT 1
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: PUSH
69377: LD_INT 0
69379: PUSH
69380: LD_INT 1
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 1
69389: NEG
69390: PUSH
69391: LD_INT 0
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: PUSH
69398: LD_INT 1
69400: NEG
69401: PUSH
69402: LD_INT 1
69404: NEG
69405: PUSH
69406: EMPTY
69407: LIST
69408: LIST
69409: PUSH
69410: LD_INT 1
69412: NEG
69413: PUSH
69414: LD_INT 2
69416: NEG
69417: PUSH
69418: EMPTY
69419: LIST
69420: LIST
69421: PUSH
69422: LD_INT 0
69424: PUSH
69425: LD_INT 2
69427: NEG
69428: PUSH
69429: EMPTY
69430: LIST
69431: LIST
69432: PUSH
69433: LD_INT 1
69435: PUSH
69436: LD_INT 1
69438: NEG
69439: PUSH
69440: EMPTY
69441: LIST
69442: LIST
69443: PUSH
69444: LD_INT 2
69446: PUSH
69447: LD_INT 1
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 2
69456: PUSH
69457: LD_INT 2
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: PUSH
69464: LD_INT 1
69466: PUSH
69467: LD_INT 2
69469: PUSH
69470: EMPTY
69471: LIST
69472: LIST
69473: PUSH
69474: LD_INT 0
69476: PUSH
69477: LD_INT 2
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: LD_INT 1
69486: NEG
69487: PUSH
69488: LD_INT 1
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: LD_INT 2
69497: NEG
69498: PUSH
69499: LD_INT 0
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 2
69508: NEG
69509: PUSH
69510: LD_INT 1
69512: NEG
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: LD_INT 1
69520: NEG
69521: PUSH
69522: LD_INT 3
69524: NEG
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 1
69532: PUSH
69533: LD_INT 2
69535: NEG
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 3
69543: PUSH
69544: LD_INT 2
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: LD_INT 2
69553: PUSH
69554: LD_INT 3
69556: PUSH
69557: EMPTY
69558: LIST
69559: LIST
69560: PUSH
69561: LD_INT 2
69563: NEG
69564: PUSH
69565: LD_INT 1
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 3
69574: NEG
69575: PUSH
69576: LD_INT 1
69578: NEG
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69609: LD_ADDR_VAR 0 33
69613: PUSH
69614: LD_INT 0
69616: PUSH
69617: LD_INT 0
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 0
69626: PUSH
69627: LD_INT 1
69629: NEG
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 1
69637: PUSH
69638: LD_INT 0
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 1
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 0
69657: PUSH
69658: LD_INT 1
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 1
69667: NEG
69668: PUSH
69669: LD_INT 0
69671: PUSH
69672: EMPTY
69673: LIST
69674: LIST
69675: PUSH
69676: LD_INT 1
69678: NEG
69679: PUSH
69680: LD_INT 1
69682: NEG
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: PUSH
69688: LD_INT 1
69690: NEG
69691: PUSH
69692: LD_INT 2
69694: NEG
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: PUSH
69700: LD_INT 1
69702: PUSH
69703: LD_INT 1
69705: NEG
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 2
69713: PUSH
69714: LD_INT 0
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: PUSH
69721: LD_INT 2
69723: PUSH
69724: LD_INT 1
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 1
69733: PUSH
69734: LD_INT 2
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 0
69743: PUSH
69744: LD_INT 2
69746: PUSH
69747: EMPTY
69748: LIST
69749: LIST
69750: PUSH
69751: LD_INT 1
69753: NEG
69754: PUSH
69755: LD_INT 1
69757: PUSH
69758: EMPTY
69759: LIST
69760: LIST
69761: PUSH
69762: LD_INT 2
69764: NEG
69765: PUSH
69766: LD_INT 0
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PUSH
69773: LD_INT 2
69775: NEG
69776: PUSH
69777: LD_INT 1
69779: NEG
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: PUSH
69785: LD_INT 2
69787: NEG
69788: PUSH
69789: LD_INT 2
69791: NEG
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 2
69799: NEG
69800: PUSH
69801: LD_INT 3
69803: NEG
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 2
69811: PUSH
69812: LD_INT 1
69814: NEG
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 3
69822: PUSH
69823: LD_INT 1
69825: PUSH
69826: EMPTY
69827: LIST
69828: LIST
69829: PUSH
69830: LD_INT 1
69832: PUSH
69833: LD_INT 3
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: PUSH
69840: LD_INT 1
69842: NEG
69843: PUSH
69844: LD_INT 2
69846: PUSH
69847: EMPTY
69848: LIST
69849: LIST
69850: PUSH
69851: LD_INT 3
69853: NEG
69854: PUSH
69855: LD_INT 2
69857: NEG
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: LIST
69884: LIST
69885: LIST
69886: LIST
69887: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69888: LD_ADDR_VAR 0 34
69892: PUSH
69893: LD_INT 0
69895: PUSH
69896: LD_INT 0
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: PUSH
69903: LD_INT 0
69905: PUSH
69906: LD_INT 1
69908: NEG
69909: PUSH
69910: EMPTY
69911: LIST
69912: LIST
69913: PUSH
69914: LD_INT 1
69916: PUSH
69917: LD_INT 0
69919: PUSH
69920: EMPTY
69921: LIST
69922: LIST
69923: PUSH
69924: LD_INT 1
69926: PUSH
69927: LD_INT 1
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 0
69936: PUSH
69937: LD_INT 1
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 1
69946: NEG
69947: PUSH
69948: LD_INT 0
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 1
69957: NEG
69958: PUSH
69959: LD_INT 1
69961: NEG
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PUSH
69967: LD_INT 1
69969: NEG
69970: PUSH
69971: LD_INT 2
69973: NEG
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 0
69981: PUSH
69982: LD_INT 2
69984: NEG
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: LD_INT 1
69992: PUSH
69993: LD_INT 1
69995: NEG
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: PUSH
70001: LD_INT 2
70003: PUSH
70004: LD_INT 1
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PUSH
70011: LD_INT 2
70013: PUSH
70014: LD_INT 2
70016: PUSH
70017: EMPTY
70018: LIST
70019: LIST
70020: PUSH
70021: LD_INT 1
70023: PUSH
70024: LD_INT 2
70026: PUSH
70027: EMPTY
70028: LIST
70029: LIST
70030: PUSH
70031: LD_INT 1
70033: NEG
70034: PUSH
70035: LD_INT 1
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: PUSH
70042: LD_INT 2
70044: NEG
70045: PUSH
70046: LD_INT 0
70048: PUSH
70049: EMPTY
70050: LIST
70051: LIST
70052: PUSH
70053: LD_INT 2
70055: NEG
70056: PUSH
70057: LD_INT 1
70059: NEG
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: LD_INT 2
70067: NEG
70068: PUSH
70069: LD_INT 2
70071: NEG
70072: PUSH
70073: EMPTY
70074: LIST
70075: LIST
70076: PUSH
70077: LD_INT 1
70079: NEG
70080: PUSH
70081: LD_INT 3
70083: NEG
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PUSH
70089: LD_INT 1
70091: PUSH
70092: LD_INT 2
70094: NEG
70095: PUSH
70096: EMPTY
70097: LIST
70098: LIST
70099: PUSH
70100: LD_INT 3
70102: PUSH
70103: LD_INT 2
70105: PUSH
70106: EMPTY
70107: LIST
70108: LIST
70109: PUSH
70110: LD_INT 2
70112: PUSH
70113: LD_INT 3
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: PUSH
70120: LD_INT 2
70122: NEG
70123: PUSH
70124: LD_INT 1
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 3
70133: NEG
70134: PUSH
70135: LD_INT 1
70137: NEG
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: LIST
70147: LIST
70148: LIST
70149: LIST
70150: LIST
70151: LIST
70152: LIST
70153: LIST
70154: LIST
70155: LIST
70156: LIST
70157: LIST
70158: LIST
70159: LIST
70160: LIST
70161: LIST
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: LIST
70167: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70168: LD_ADDR_VAR 0 35
70172: PUSH
70173: LD_INT 0
70175: PUSH
70176: LD_INT 0
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: PUSH
70183: LD_INT 0
70185: PUSH
70186: LD_INT 1
70188: NEG
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: PUSH
70194: LD_INT 1
70196: PUSH
70197: LD_INT 0
70199: PUSH
70200: EMPTY
70201: LIST
70202: LIST
70203: PUSH
70204: LD_INT 1
70206: PUSH
70207: LD_INT 1
70209: PUSH
70210: EMPTY
70211: LIST
70212: LIST
70213: PUSH
70214: LD_INT 0
70216: PUSH
70217: LD_INT 1
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: PUSH
70224: LD_INT 1
70226: NEG
70227: PUSH
70228: LD_INT 0
70230: PUSH
70231: EMPTY
70232: LIST
70233: LIST
70234: PUSH
70235: LD_INT 1
70237: NEG
70238: PUSH
70239: LD_INT 1
70241: NEG
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: LD_INT 2
70249: PUSH
70250: LD_INT 1
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 2
70259: NEG
70260: PUSH
70261: LD_INT 1
70263: NEG
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70280: LD_ADDR_VAR 0 36
70284: PUSH
70285: LD_INT 0
70287: PUSH
70288: LD_INT 0
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 0
70297: PUSH
70298: LD_INT 1
70300: NEG
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: LD_INT 1
70308: PUSH
70309: LD_INT 0
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 1
70318: PUSH
70319: LD_INT 1
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 0
70328: PUSH
70329: LD_INT 1
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 1
70338: NEG
70339: PUSH
70340: LD_INT 0
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: LD_INT 1
70349: NEG
70350: PUSH
70351: LD_INT 1
70353: NEG
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 1
70361: NEG
70362: PUSH
70363: LD_INT 2
70365: NEG
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: LD_INT 1
70373: PUSH
70374: LD_INT 2
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: LIST
70389: LIST
70390: LIST
70391: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70392: LD_ADDR_VAR 0 37
70396: PUSH
70397: LD_INT 0
70399: PUSH
70400: LD_INT 0
70402: PUSH
70403: EMPTY
70404: LIST
70405: LIST
70406: PUSH
70407: LD_INT 0
70409: PUSH
70410: LD_INT 1
70412: NEG
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PUSH
70418: LD_INT 1
70420: PUSH
70421: LD_INT 0
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 1
70430: PUSH
70431: LD_INT 1
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: PUSH
70438: LD_INT 0
70440: PUSH
70441: LD_INT 1
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 1
70450: NEG
70451: PUSH
70452: LD_INT 0
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 1
70461: NEG
70462: PUSH
70463: LD_INT 1
70465: NEG
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: PUSH
70471: LD_INT 1
70473: PUSH
70474: LD_INT 1
70476: NEG
70477: PUSH
70478: EMPTY
70479: LIST
70480: LIST
70481: PUSH
70482: LD_INT 1
70484: NEG
70485: PUSH
70486: LD_INT 1
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: LIST
70497: LIST
70498: LIST
70499: LIST
70500: LIST
70501: LIST
70502: LIST
70503: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70504: LD_ADDR_VAR 0 38
70508: PUSH
70509: LD_INT 0
70511: PUSH
70512: LD_INT 0
70514: PUSH
70515: EMPTY
70516: LIST
70517: LIST
70518: PUSH
70519: LD_INT 0
70521: PUSH
70522: LD_INT 1
70524: NEG
70525: PUSH
70526: EMPTY
70527: LIST
70528: LIST
70529: PUSH
70530: LD_INT 1
70532: PUSH
70533: LD_INT 0
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: PUSH
70540: LD_INT 1
70542: PUSH
70543: LD_INT 1
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: PUSH
70550: LD_INT 0
70552: PUSH
70553: LD_INT 1
70555: PUSH
70556: EMPTY
70557: LIST
70558: LIST
70559: PUSH
70560: LD_INT 1
70562: NEG
70563: PUSH
70564: LD_INT 0
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PUSH
70571: LD_INT 1
70573: NEG
70574: PUSH
70575: LD_INT 1
70577: NEG
70578: PUSH
70579: EMPTY
70580: LIST
70581: LIST
70582: PUSH
70583: LD_INT 2
70585: PUSH
70586: LD_INT 1
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: PUSH
70593: LD_INT 2
70595: NEG
70596: PUSH
70597: LD_INT 1
70599: NEG
70600: PUSH
70601: EMPTY
70602: LIST
70603: LIST
70604: PUSH
70605: EMPTY
70606: LIST
70607: LIST
70608: LIST
70609: LIST
70610: LIST
70611: LIST
70612: LIST
70613: LIST
70614: LIST
70615: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70616: LD_ADDR_VAR 0 39
70620: PUSH
70621: LD_INT 0
70623: PUSH
70624: LD_INT 0
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 0
70633: PUSH
70634: LD_INT 1
70636: NEG
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: PUSH
70642: LD_INT 1
70644: PUSH
70645: LD_INT 0
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: PUSH
70652: LD_INT 1
70654: PUSH
70655: LD_INT 1
70657: PUSH
70658: EMPTY
70659: LIST
70660: LIST
70661: PUSH
70662: LD_INT 0
70664: PUSH
70665: LD_INT 1
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: PUSH
70672: LD_INT 1
70674: NEG
70675: PUSH
70676: LD_INT 0
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: PUSH
70683: LD_INT 1
70685: NEG
70686: PUSH
70687: LD_INT 1
70689: NEG
70690: PUSH
70691: EMPTY
70692: LIST
70693: LIST
70694: PUSH
70695: LD_INT 1
70697: NEG
70698: PUSH
70699: LD_INT 2
70701: NEG
70702: PUSH
70703: EMPTY
70704: LIST
70705: LIST
70706: PUSH
70707: LD_INT 1
70709: PUSH
70710: LD_INT 2
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70728: LD_ADDR_VAR 0 40
70732: PUSH
70733: LD_INT 0
70735: PUSH
70736: LD_INT 0
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: PUSH
70743: LD_INT 0
70745: PUSH
70746: LD_INT 1
70748: NEG
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 1
70756: PUSH
70757: LD_INT 0
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 1
70766: PUSH
70767: LD_INT 1
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: PUSH
70774: LD_INT 0
70776: PUSH
70777: LD_INT 1
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 1
70786: NEG
70787: PUSH
70788: LD_INT 0
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: LD_INT 1
70797: NEG
70798: PUSH
70799: LD_INT 1
70801: NEG
70802: PUSH
70803: EMPTY
70804: LIST
70805: LIST
70806: PUSH
70807: LD_INT 1
70809: PUSH
70810: LD_INT 1
70812: NEG
70813: PUSH
70814: EMPTY
70815: LIST
70816: LIST
70817: PUSH
70818: LD_INT 1
70820: NEG
70821: PUSH
70822: LD_INT 1
70824: PUSH
70825: EMPTY
70826: LIST
70827: LIST
70828: PUSH
70829: EMPTY
70830: LIST
70831: LIST
70832: LIST
70833: LIST
70834: LIST
70835: LIST
70836: LIST
70837: LIST
70838: LIST
70839: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70840: LD_ADDR_VAR 0 41
70844: PUSH
70845: LD_INT 0
70847: PUSH
70848: LD_INT 0
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 0
70857: PUSH
70858: LD_INT 1
70860: NEG
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 1
70868: PUSH
70869: LD_INT 0
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: LD_INT 1
70878: PUSH
70879: LD_INT 1
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 0
70888: PUSH
70889: LD_INT 1
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: NEG
70899: PUSH
70900: LD_INT 0
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 1
70909: NEG
70910: PUSH
70911: LD_INT 1
70913: NEG
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PUSH
70919: LD_INT 1
70921: NEG
70922: PUSH
70923: LD_INT 2
70925: NEG
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 1
70933: PUSH
70934: LD_INT 1
70936: NEG
70937: PUSH
70938: EMPTY
70939: LIST
70940: LIST
70941: PUSH
70942: LD_INT 2
70944: PUSH
70945: LD_INT 0
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: PUSH
70952: LD_INT 2
70954: PUSH
70955: LD_INT 1
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: PUSH
70962: LD_INT 2
70964: PUSH
70965: LD_INT 2
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: PUSH
70972: LD_INT 1
70974: PUSH
70975: LD_INT 2
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: LD_INT 1
70984: NEG
70985: PUSH
70986: LD_INT 1
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 2
70995: NEG
70996: PUSH
70997: LD_INT 0
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: LD_INT 2
71006: NEG
71007: PUSH
71008: LD_INT 1
71010: NEG
71011: PUSH
71012: EMPTY
71013: LIST
71014: LIST
71015: PUSH
71016: LD_INT 2
71018: NEG
71019: PUSH
71020: LD_INT 2
71022: NEG
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 2
71030: NEG
71031: PUSH
71032: LD_INT 3
71034: NEG
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 2
71042: PUSH
71043: LD_INT 1
71045: NEG
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 3
71053: PUSH
71054: LD_INT 0
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 3
71063: PUSH
71064: LD_INT 1
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 3
71073: PUSH
71074: LD_INT 2
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: PUSH
71081: LD_INT 3
71083: PUSH
71084: LD_INT 3
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 2
71093: PUSH
71094: LD_INT 3
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: PUSH
71101: LD_INT 2
71103: NEG
71104: PUSH
71105: LD_INT 1
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 3
71114: NEG
71115: PUSH
71116: LD_INT 0
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: LD_INT 3
71125: NEG
71126: PUSH
71127: LD_INT 1
71129: NEG
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 3
71137: NEG
71138: PUSH
71139: LD_INT 2
71141: NEG
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: LD_INT 3
71149: NEG
71150: PUSH
71151: LD_INT 3
71153: NEG
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: LIST
71163: LIST
71164: LIST
71165: LIST
71166: LIST
71167: LIST
71168: LIST
71169: LIST
71170: LIST
71171: LIST
71172: LIST
71173: LIST
71174: LIST
71175: LIST
71176: LIST
71177: LIST
71178: LIST
71179: LIST
71180: LIST
71181: LIST
71182: LIST
71183: LIST
71184: LIST
71185: LIST
71186: LIST
71187: LIST
71188: LIST
71189: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71190: LD_ADDR_VAR 0 42
71194: PUSH
71195: LD_INT 0
71197: PUSH
71198: LD_INT 0
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 0
71207: PUSH
71208: LD_INT 1
71210: NEG
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 1
71218: PUSH
71219: LD_INT 0
71221: PUSH
71222: EMPTY
71223: LIST
71224: LIST
71225: PUSH
71226: LD_INT 1
71228: PUSH
71229: LD_INT 1
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: LD_INT 0
71238: PUSH
71239: LD_INT 1
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: PUSH
71246: LD_INT 1
71248: NEG
71249: PUSH
71250: LD_INT 0
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 1
71259: NEG
71260: PUSH
71261: LD_INT 1
71263: NEG
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: PUSH
71269: LD_INT 1
71271: NEG
71272: PUSH
71273: LD_INT 2
71275: NEG
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: PUSH
71281: LD_INT 0
71283: PUSH
71284: LD_INT 2
71286: NEG
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 1
71294: PUSH
71295: LD_INT 1
71297: NEG
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 2
71305: PUSH
71306: LD_INT 1
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 2
71315: PUSH
71316: LD_INT 2
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 1
71325: PUSH
71326: LD_INT 2
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: LD_INT 0
71335: PUSH
71336: LD_INT 2
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 1
71345: NEG
71346: PUSH
71347: LD_INT 1
71349: PUSH
71350: EMPTY
71351: LIST
71352: LIST
71353: PUSH
71354: LD_INT 2
71356: NEG
71357: PUSH
71358: LD_INT 1
71360: NEG
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 2
71368: NEG
71369: PUSH
71370: LD_INT 2
71372: NEG
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 2
71380: NEG
71381: PUSH
71382: LD_INT 3
71384: NEG
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 1
71392: NEG
71393: PUSH
71394: LD_INT 3
71396: NEG
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: LD_INT 0
71404: PUSH
71405: LD_INT 3
71407: NEG
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 1
71415: PUSH
71416: LD_INT 2
71418: NEG
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 3
71426: PUSH
71427: LD_INT 2
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 3
71436: PUSH
71437: LD_INT 3
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PUSH
71444: LD_INT 2
71446: PUSH
71447: LD_INT 3
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 1
71456: PUSH
71457: LD_INT 3
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 0
71466: PUSH
71467: LD_INT 3
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: PUSH
71474: LD_INT 1
71476: NEG
71477: PUSH
71478: LD_INT 2
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: LD_INT 3
71487: NEG
71488: PUSH
71489: LD_INT 2
71491: NEG
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: PUSH
71497: LD_INT 3
71499: NEG
71500: PUSH
71501: LD_INT 3
71503: NEG
71504: PUSH
71505: EMPTY
71506: LIST
71507: LIST
71508: PUSH
71509: EMPTY
71510: LIST
71511: LIST
71512: LIST
71513: LIST
71514: LIST
71515: LIST
71516: LIST
71517: LIST
71518: LIST
71519: LIST
71520: LIST
71521: LIST
71522: LIST
71523: LIST
71524: LIST
71525: LIST
71526: LIST
71527: LIST
71528: LIST
71529: LIST
71530: LIST
71531: LIST
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: LIST
71539: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71540: LD_ADDR_VAR 0 43
71544: PUSH
71545: LD_INT 0
71547: PUSH
71548: LD_INT 0
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: PUSH
71555: LD_INT 0
71557: PUSH
71558: LD_INT 1
71560: NEG
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 1
71568: PUSH
71569: LD_INT 0
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: LD_INT 1
71578: PUSH
71579: LD_INT 1
71581: PUSH
71582: EMPTY
71583: LIST
71584: LIST
71585: PUSH
71586: LD_INT 0
71588: PUSH
71589: LD_INT 1
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: PUSH
71596: LD_INT 1
71598: NEG
71599: PUSH
71600: LD_INT 0
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 1
71609: NEG
71610: PUSH
71611: LD_INT 1
71613: NEG
71614: PUSH
71615: EMPTY
71616: LIST
71617: LIST
71618: PUSH
71619: LD_INT 1
71621: NEG
71622: PUSH
71623: LD_INT 2
71625: NEG
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: PUSH
71631: LD_INT 0
71633: PUSH
71634: LD_INT 2
71636: NEG
71637: PUSH
71638: EMPTY
71639: LIST
71640: LIST
71641: PUSH
71642: LD_INT 1
71644: PUSH
71645: LD_INT 1
71647: NEG
71648: PUSH
71649: EMPTY
71650: LIST
71651: LIST
71652: PUSH
71653: LD_INT 2
71655: PUSH
71656: LD_INT 0
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: PUSH
71663: LD_INT 2
71665: PUSH
71666: LD_INT 1
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: PUSH
71673: LD_INT 1
71675: PUSH
71676: LD_INT 2
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 0
71685: PUSH
71686: LD_INT 2
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: LD_INT 1
71695: NEG
71696: PUSH
71697: LD_INT 1
71699: PUSH
71700: EMPTY
71701: LIST
71702: LIST
71703: PUSH
71704: LD_INT 2
71706: NEG
71707: PUSH
71708: LD_INT 0
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 2
71717: NEG
71718: PUSH
71719: LD_INT 1
71721: NEG
71722: PUSH
71723: EMPTY
71724: LIST
71725: LIST
71726: PUSH
71727: LD_INT 1
71729: NEG
71730: PUSH
71731: LD_INT 3
71733: NEG
71734: PUSH
71735: EMPTY
71736: LIST
71737: LIST
71738: PUSH
71739: LD_INT 0
71741: PUSH
71742: LD_INT 3
71744: NEG
71745: PUSH
71746: EMPTY
71747: LIST
71748: LIST
71749: PUSH
71750: LD_INT 1
71752: PUSH
71753: LD_INT 2
71755: NEG
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 2
71763: PUSH
71764: LD_INT 1
71766: NEG
71767: PUSH
71768: EMPTY
71769: LIST
71770: LIST
71771: PUSH
71772: LD_INT 3
71774: PUSH
71775: LD_INT 0
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 3
71784: PUSH
71785: LD_INT 1
71787: PUSH
71788: EMPTY
71789: LIST
71790: LIST
71791: PUSH
71792: LD_INT 1
71794: PUSH
71795: LD_INT 3
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 0
71804: PUSH
71805: LD_INT 3
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 1
71814: NEG
71815: PUSH
71816: LD_INT 2
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: PUSH
71823: LD_INT 2
71825: NEG
71826: PUSH
71827: LD_INT 1
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: PUSH
71834: LD_INT 3
71836: NEG
71837: PUSH
71838: LD_INT 0
71840: PUSH
71841: EMPTY
71842: LIST
71843: LIST
71844: PUSH
71845: LD_INT 3
71847: NEG
71848: PUSH
71849: LD_INT 1
71851: NEG
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: EMPTY
71858: LIST
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: LIST
71881: LIST
71882: LIST
71883: LIST
71884: LIST
71885: LIST
71886: LIST
71887: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71888: LD_ADDR_VAR 0 44
71892: PUSH
71893: LD_INT 0
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 0
71905: PUSH
71906: LD_INT 1
71908: NEG
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 1
71916: PUSH
71917: LD_INT 0
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: LD_INT 1
71926: PUSH
71927: LD_INT 1
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 0
71936: PUSH
71937: LD_INT 1
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: LD_INT 1
71946: NEG
71947: PUSH
71948: LD_INT 0
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 1
71957: NEG
71958: PUSH
71959: LD_INT 1
71961: NEG
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 1
71969: NEG
71970: PUSH
71971: LD_INT 2
71973: NEG
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 1
71981: PUSH
71982: LD_INT 1
71984: NEG
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: PUSH
71990: LD_INT 2
71992: PUSH
71993: LD_INT 0
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 2
72002: PUSH
72003: LD_INT 1
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: LD_INT 2
72012: PUSH
72013: LD_INT 2
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 1
72022: PUSH
72023: LD_INT 2
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PUSH
72030: LD_INT 1
72032: NEG
72033: PUSH
72034: LD_INT 1
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 2
72043: NEG
72044: PUSH
72045: LD_INT 0
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: PUSH
72052: LD_INT 2
72054: NEG
72055: PUSH
72056: LD_INT 1
72058: NEG
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: LD_INT 2
72066: NEG
72067: PUSH
72068: LD_INT 2
72070: NEG
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 2
72078: NEG
72079: PUSH
72080: LD_INT 3
72082: NEG
72083: PUSH
72084: EMPTY
72085: LIST
72086: LIST
72087: PUSH
72088: LD_INT 2
72090: PUSH
72091: LD_INT 1
72093: NEG
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: PUSH
72099: LD_INT 3
72101: PUSH
72102: LD_INT 0
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: PUSH
72109: LD_INT 3
72111: PUSH
72112: LD_INT 1
72114: PUSH
72115: EMPTY
72116: LIST
72117: LIST
72118: PUSH
72119: LD_INT 3
72121: PUSH
72122: LD_INT 2
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: PUSH
72129: LD_INT 3
72131: PUSH
72132: LD_INT 3
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PUSH
72139: LD_INT 2
72141: PUSH
72142: LD_INT 3
72144: PUSH
72145: EMPTY
72146: LIST
72147: LIST
72148: PUSH
72149: LD_INT 2
72151: NEG
72152: PUSH
72153: LD_INT 1
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: PUSH
72160: LD_INT 3
72162: NEG
72163: PUSH
72164: LD_INT 0
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 3
72173: NEG
72174: PUSH
72175: LD_INT 1
72177: NEG
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: PUSH
72183: LD_INT 3
72185: NEG
72186: PUSH
72187: LD_INT 2
72189: NEG
72190: PUSH
72191: EMPTY
72192: LIST
72193: LIST
72194: PUSH
72195: LD_INT 3
72197: NEG
72198: PUSH
72199: LD_INT 3
72201: NEG
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: PUSH
72207: EMPTY
72208: LIST
72209: LIST
72210: LIST
72211: LIST
72212: LIST
72213: LIST
72214: LIST
72215: LIST
72216: LIST
72217: LIST
72218: LIST
72219: LIST
72220: LIST
72221: LIST
72222: LIST
72223: LIST
72224: LIST
72225: LIST
72226: LIST
72227: LIST
72228: LIST
72229: LIST
72230: LIST
72231: LIST
72232: LIST
72233: LIST
72234: LIST
72235: LIST
72236: LIST
72237: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72238: LD_ADDR_VAR 0 45
72242: PUSH
72243: LD_INT 0
72245: PUSH
72246: LD_INT 0
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 0
72255: PUSH
72256: LD_INT 1
72258: NEG
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 1
72266: PUSH
72267: LD_INT 0
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PUSH
72274: LD_INT 1
72276: PUSH
72277: LD_INT 1
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 0
72286: PUSH
72287: LD_INT 1
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 1
72296: NEG
72297: PUSH
72298: LD_INT 0
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 1
72307: NEG
72308: PUSH
72309: LD_INT 1
72311: NEG
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: LD_INT 1
72319: NEG
72320: PUSH
72321: LD_INT 2
72323: NEG
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: PUSH
72329: LD_INT 0
72331: PUSH
72332: LD_INT 2
72334: NEG
72335: PUSH
72336: EMPTY
72337: LIST
72338: LIST
72339: PUSH
72340: LD_INT 1
72342: PUSH
72343: LD_INT 1
72345: NEG
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: LD_INT 2
72353: PUSH
72354: LD_INT 1
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: PUSH
72361: LD_INT 2
72363: PUSH
72364: LD_INT 2
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PUSH
72371: LD_INT 1
72373: PUSH
72374: LD_INT 2
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: PUSH
72381: LD_INT 0
72383: PUSH
72384: LD_INT 2
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 1
72393: NEG
72394: PUSH
72395: LD_INT 1
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: PUSH
72402: LD_INT 2
72404: NEG
72405: PUSH
72406: LD_INT 1
72408: NEG
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PUSH
72414: LD_INT 2
72416: NEG
72417: PUSH
72418: LD_INT 2
72420: NEG
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 2
72428: NEG
72429: PUSH
72430: LD_INT 3
72432: NEG
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 1
72440: NEG
72441: PUSH
72442: LD_INT 3
72444: NEG
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PUSH
72450: LD_INT 0
72452: PUSH
72453: LD_INT 3
72455: NEG
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 1
72463: PUSH
72464: LD_INT 2
72466: NEG
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: LD_INT 3
72474: PUSH
72475: LD_INT 2
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 3
72484: PUSH
72485: LD_INT 3
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PUSH
72492: LD_INT 2
72494: PUSH
72495: LD_INT 3
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 1
72504: PUSH
72505: LD_INT 3
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: PUSH
72512: LD_INT 0
72514: PUSH
72515: LD_INT 3
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 1
72524: NEG
72525: PUSH
72526: LD_INT 2
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: LD_INT 3
72535: NEG
72536: PUSH
72537: LD_INT 2
72539: NEG
72540: PUSH
72541: EMPTY
72542: LIST
72543: LIST
72544: PUSH
72545: LD_INT 3
72547: NEG
72548: PUSH
72549: LD_INT 3
72551: NEG
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: LIST
72561: LIST
72562: LIST
72563: LIST
72564: LIST
72565: LIST
72566: LIST
72567: LIST
72568: LIST
72569: LIST
72570: LIST
72571: LIST
72572: LIST
72573: LIST
72574: LIST
72575: LIST
72576: LIST
72577: LIST
72578: LIST
72579: LIST
72580: LIST
72581: LIST
72582: LIST
72583: LIST
72584: LIST
72585: LIST
72586: LIST
72587: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72588: LD_ADDR_VAR 0 46
72592: PUSH
72593: LD_INT 0
72595: PUSH
72596: LD_INT 0
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 0
72605: PUSH
72606: LD_INT 1
72608: NEG
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: LD_INT 1
72616: PUSH
72617: LD_INT 0
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 1
72626: PUSH
72627: LD_INT 1
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 0
72636: PUSH
72637: LD_INT 1
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 1
72646: NEG
72647: PUSH
72648: LD_INT 0
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: LD_INT 1
72657: NEG
72658: PUSH
72659: LD_INT 1
72661: NEG
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: PUSH
72667: LD_INT 1
72669: NEG
72670: PUSH
72671: LD_INT 2
72673: NEG
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PUSH
72679: LD_INT 0
72681: PUSH
72682: LD_INT 2
72684: NEG
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: PUSH
72690: LD_INT 1
72692: PUSH
72693: LD_INT 1
72695: NEG
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: PUSH
72701: LD_INT 2
72703: PUSH
72704: LD_INT 0
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: PUSH
72711: LD_INT 2
72713: PUSH
72714: LD_INT 1
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PUSH
72721: LD_INT 1
72723: PUSH
72724: LD_INT 2
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: PUSH
72731: LD_INT 0
72733: PUSH
72734: LD_INT 2
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PUSH
72741: LD_INT 1
72743: NEG
72744: PUSH
72745: LD_INT 1
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: LD_INT 2
72754: NEG
72755: PUSH
72756: LD_INT 0
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 2
72765: NEG
72766: PUSH
72767: LD_INT 1
72769: NEG
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: PUSH
72775: LD_INT 1
72777: NEG
72778: PUSH
72779: LD_INT 3
72781: NEG
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 0
72789: PUSH
72790: LD_INT 3
72792: NEG
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: LD_INT 1
72800: PUSH
72801: LD_INT 2
72803: NEG
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: PUSH
72809: LD_INT 2
72811: PUSH
72812: LD_INT 1
72814: NEG
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: LD_INT 3
72822: PUSH
72823: LD_INT 0
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: LD_INT 3
72832: PUSH
72833: LD_INT 1
72835: PUSH
72836: EMPTY
72837: LIST
72838: LIST
72839: PUSH
72840: LD_INT 1
72842: PUSH
72843: LD_INT 3
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: PUSH
72850: LD_INT 0
72852: PUSH
72853: LD_INT 3
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: PUSH
72860: LD_INT 1
72862: NEG
72863: PUSH
72864: LD_INT 2
72866: PUSH
72867: EMPTY
72868: LIST
72869: LIST
72870: PUSH
72871: LD_INT 2
72873: NEG
72874: PUSH
72875: LD_INT 1
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: PUSH
72882: LD_INT 3
72884: NEG
72885: PUSH
72886: LD_INT 0
72888: PUSH
72889: EMPTY
72890: LIST
72891: LIST
72892: PUSH
72893: LD_INT 3
72895: NEG
72896: PUSH
72897: LD_INT 1
72899: NEG
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: LIST
72909: LIST
72910: LIST
72911: LIST
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: LIST
72925: LIST
72926: LIST
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72936: LD_ADDR_VAR 0 47
72940: PUSH
72941: LD_INT 0
72943: PUSH
72944: LD_INT 0
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 0
72953: PUSH
72954: LD_INT 1
72956: NEG
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 1
72964: PUSH
72965: LD_INT 0
72967: PUSH
72968: EMPTY
72969: LIST
72970: LIST
72971: PUSH
72972: LD_INT 1
72974: PUSH
72975: LD_INT 1
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 0
72984: PUSH
72985: LD_INT 1
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 1
72994: NEG
72995: PUSH
72996: LD_INT 0
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 1
73005: NEG
73006: PUSH
73007: LD_INT 1
73009: NEG
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: PUSH
73015: LD_INT 1
73017: NEG
73018: PUSH
73019: LD_INT 2
73021: NEG
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: PUSH
73027: LD_INT 0
73029: PUSH
73030: LD_INT 2
73032: NEG
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 1
73040: PUSH
73041: LD_INT 1
73043: NEG
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 2
73051: NEG
73052: PUSH
73053: LD_INT 1
73055: NEG
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: PUSH
73061: LD_INT 2
73063: NEG
73064: PUSH
73065: LD_INT 2
73067: NEG
73068: PUSH
73069: EMPTY
73070: LIST
73071: LIST
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73087: LD_ADDR_VAR 0 48
73091: PUSH
73092: LD_INT 0
73094: PUSH
73095: LD_INT 0
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: LD_INT 0
73104: PUSH
73105: LD_INT 1
73107: NEG
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: PUSH
73113: LD_INT 1
73115: PUSH
73116: LD_INT 0
73118: PUSH
73119: EMPTY
73120: LIST
73121: LIST
73122: PUSH
73123: LD_INT 1
73125: PUSH
73126: LD_INT 1
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: PUSH
73133: LD_INT 0
73135: PUSH
73136: LD_INT 1
73138: PUSH
73139: EMPTY
73140: LIST
73141: LIST
73142: PUSH
73143: LD_INT 1
73145: NEG
73146: PUSH
73147: LD_INT 0
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 1
73156: NEG
73157: PUSH
73158: LD_INT 1
73160: NEG
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: PUSH
73166: LD_INT 1
73168: NEG
73169: PUSH
73170: LD_INT 2
73172: NEG
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 0
73180: PUSH
73181: LD_INT 2
73183: NEG
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 1
73191: PUSH
73192: LD_INT 1
73194: NEG
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PUSH
73200: LD_INT 2
73202: PUSH
73203: LD_INT 0
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: PUSH
73210: LD_INT 2
73212: PUSH
73213: LD_INT 1
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73234: LD_ADDR_VAR 0 49
73238: PUSH
73239: LD_INT 0
73241: PUSH
73242: LD_INT 0
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: PUSH
73249: LD_INT 0
73251: PUSH
73252: LD_INT 1
73254: NEG
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: PUSH
73260: LD_INT 1
73262: PUSH
73263: LD_INT 0
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: PUSH
73270: LD_INT 1
73272: PUSH
73273: LD_INT 1
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PUSH
73280: LD_INT 0
73282: PUSH
73283: LD_INT 1
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 1
73292: NEG
73293: PUSH
73294: LD_INT 0
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PUSH
73301: LD_INT 1
73303: NEG
73304: PUSH
73305: LD_INT 1
73307: NEG
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 1
73315: PUSH
73316: LD_INT 1
73318: NEG
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: PUSH
73324: LD_INT 2
73326: PUSH
73327: LD_INT 0
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 2
73336: PUSH
73337: LD_INT 1
73339: PUSH
73340: EMPTY
73341: LIST
73342: LIST
73343: PUSH
73344: LD_INT 2
73346: PUSH
73347: LD_INT 2
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 1
73356: PUSH
73357: LD_INT 2
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73378: LD_ADDR_VAR 0 50
73382: PUSH
73383: LD_INT 0
73385: PUSH
73386: LD_INT 0
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 0
73395: PUSH
73396: LD_INT 1
73398: NEG
73399: PUSH
73400: EMPTY
73401: LIST
73402: LIST
73403: PUSH
73404: LD_INT 1
73406: PUSH
73407: LD_INT 0
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: PUSH
73414: LD_INT 1
73416: PUSH
73417: LD_INT 1
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: LD_INT 0
73426: PUSH
73427: LD_INT 1
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 1
73436: NEG
73437: PUSH
73438: LD_INT 0
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: PUSH
73445: LD_INT 1
73447: NEG
73448: PUSH
73449: LD_INT 1
73451: NEG
73452: PUSH
73453: EMPTY
73454: LIST
73455: LIST
73456: PUSH
73457: LD_INT 2
73459: PUSH
73460: LD_INT 1
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: LD_INT 2
73469: PUSH
73470: LD_INT 2
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: LD_INT 1
73479: PUSH
73480: LD_INT 2
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: LD_INT 0
73489: PUSH
73490: LD_INT 2
73492: PUSH
73493: EMPTY
73494: LIST
73495: LIST
73496: PUSH
73497: LD_INT 1
73499: NEG
73500: PUSH
73501: LD_INT 1
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73522: LD_ADDR_VAR 0 51
73526: PUSH
73527: LD_INT 0
73529: PUSH
73530: LD_INT 0
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 0
73539: PUSH
73540: LD_INT 1
73542: NEG
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 1
73550: PUSH
73551: LD_INT 0
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 1
73560: PUSH
73561: LD_INT 1
73563: PUSH
73564: EMPTY
73565: LIST
73566: LIST
73567: PUSH
73568: LD_INT 0
73570: PUSH
73571: LD_INT 1
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 1
73580: NEG
73581: PUSH
73582: LD_INT 0
73584: PUSH
73585: EMPTY
73586: LIST
73587: LIST
73588: PUSH
73589: LD_INT 1
73591: NEG
73592: PUSH
73593: LD_INT 1
73595: NEG
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PUSH
73601: LD_INT 1
73603: PUSH
73604: LD_INT 2
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: PUSH
73611: LD_INT 0
73613: PUSH
73614: LD_INT 2
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: LD_INT 1
73623: NEG
73624: PUSH
73625: LD_INT 1
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PUSH
73632: LD_INT 2
73634: NEG
73635: PUSH
73636: LD_INT 0
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: PUSH
73643: LD_INT 2
73645: NEG
73646: PUSH
73647: LD_INT 1
73649: NEG
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: LIST
73659: LIST
73660: LIST
73661: LIST
73662: LIST
73663: LIST
73664: LIST
73665: LIST
73666: LIST
73667: LIST
73668: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73669: LD_ADDR_VAR 0 52
73673: PUSH
73674: LD_INT 0
73676: PUSH
73677: LD_INT 0
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 0
73686: PUSH
73687: LD_INT 1
73689: NEG
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: LD_INT 1
73697: PUSH
73698: LD_INT 0
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: LD_INT 1
73707: PUSH
73708: LD_INT 1
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 0
73717: PUSH
73718: LD_INT 1
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PUSH
73725: LD_INT 1
73727: NEG
73728: PUSH
73729: LD_INT 0
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PUSH
73736: LD_INT 1
73738: NEG
73739: PUSH
73740: LD_INT 1
73742: NEG
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: PUSH
73748: LD_INT 1
73750: NEG
73751: PUSH
73752: LD_INT 2
73754: NEG
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PUSH
73760: LD_INT 1
73762: NEG
73763: PUSH
73764: LD_INT 1
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: PUSH
73771: LD_INT 2
73773: NEG
73774: PUSH
73775: LD_INT 0
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 2
73784: NEG
73785: PUSH
73786: LD_INT 1
73788: NEG
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 2
73796: NEG
73797: PUSH
73798: LD_INT 2
73800: NEG
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: EMPTY
73807: LIST
73808: LIST
73809: LIST
73810: LIST
73811: LIST
73812: LIST
73813: LIST
73814: LIST
73815: LIST
73816: LIST
73817: LIST
73818: LIST
73819: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73820: LD_ADDR_VAR 0 53
73824: PUSH
73825: LD_INT 0
73827: PUSH
73828: LD_INT 0
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 0
73837: PUSH
73838: LD_INT 1
73840: NEG
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 1
73848: PUSH
73849: LD_INT 0
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 1
73858: PUSH
73859: LD_INT 1
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 0
73868: PUSH
73869: LD_INT 1
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: PUSH
73876: LD_INT 1
73878: NEG
73879: PUSH
73880: LD_INT 0
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: LD_INT 1
73889: NEG
73890: PUSH
73891: LD_INT 1
73893: NEG
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 1
73901: NEG
73902: PUSH
73903: LD_INT 2
73905: NEG
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: LD_INT 0
73913: PUSH
73914: LD_INT 2
73916: NEG
73917: PUSH
73918: EMPTY
73919: LIST
73920: LIST
73921: PUSH
73922: LD_INT 1
73924: PUSH
73925: LD_INT 1
73927: NEG
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 2
73935: PUSH
73936: LD_INT 0
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: LD_INT 2
73945: PUSH
73946: LD_INT 1
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 2
73955: PUSH
73956: LD_INT 2
73958: PUSH
73959: EMPTY
73960: LIST
73961: LIST
73962: PUSH
73963: LD_INT 1
73965: PUSH
73966: LD_INT 2
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 0
73975: PUSH
73976: LD_INT 2
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PUSH
73983: LD_INT 1
73985: NEG
73986: PUSH
73987: LD_INT 1
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 2
73996: NEG
73997: PUSH
73998: LD_INT 0
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_INT 2
74007: NEG
74008: PUSH
74009: LD_INT 1
74011: NEG
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 2
74019: NEG
74020: PUSH
74021: LD_INT 2
74023: NEG
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: LIST
74033: LIST
74034: LIST
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: LIST
74040: LIST
74041: LIST
74042: LIST
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74050: LD_ADDR_VAR 0 54
74054: PUSH
74055: LD_INT 0
74057: PUSH
74058: LD_INT 0
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: LD_INT 0
74067: PUSH
74068: LD_INT 1
74070: NEG
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 1
74078: PUSH
74079: LD_INT 0
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 1
74088: PUSH
74089: LD_INT 1
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 0
74098: PUSH
74099: LD_INT 1
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: LD_INT 1
74108: NEG
74109: PUSH
74110: LD_INT 0
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: PUSH
74117: LD_INT 1
74119: NEG
74120: PUSH
74121: LD_INT 1
74123: NEG
74124: PUSH
74125: EMPTY
74126: LIST
74127: LIST
74128: PUSH
74129: LD_INT 1
74131: NEG
74132: PUSH
74133: LD_INT 2
74135: NEG
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: PUSH
74141: LD_INT 0
74143: PUSH
74144: LD_INT 2
74146: NEG
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: PUSH
74152: LD_INT 1
74154: PUSH
74155: LD_INT 1
74157: NEG
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_INT 2
74165: PUSH
74166: LD_INT 0
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: LD_INT 2
74175: PUSH
74176: LD_INT 1
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: LD_INT 2
74185: PUSH
74186: LD_INT 2
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: LD_INT 1
74195: PUSH
74196: LD_INT 2
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: PUSH
74203: LD_INT 0
74205: PUSH
74206: LD_INT 2
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 1
74215: NEG
74216: PUSH
74217: LD_INT 1
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PUSH
74224: LD_INT 2
74226: NEG
74227: PUSH
74228: LD_INT 0
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: LD_INT 2
74237: NEG
74238: PUSH
74239: LD_INT 1
74241: NEG
74242: PUSH
74243: EMPTY
74244: LIST
74245: LIST
74246: PUSH
74247: LD_INT 2
74249: NEG
74250: PUSH
74251: LD_INT 2
74253: NEG
74254: PUSH
74255: EMPTY
74256: LIST
74257: LIST
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: LIST
74263: LIST
74264: LIST
74265: LIST
74266: LIST
74267: LIST
74268: LIST
74269: LIST
74270: LIST
74271: LIST
74272: LIST
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: LIST
74278: LIST
74279: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74280: LD_ADDR_VAR 0 55
74284: PUSH
74285: LD_INT 0
74287: PUSH
74288: LD_INT 0
74290: PUSH
74291: EMPTY
74292: LIST
74293: LIST
74294: PUSH
74295: LD_INT 0
74297: PUSH
74298: LD_INT 1
74300: NEG
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 1
74308: PUSH
74309: LD_INT 0
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 1
74318: PUSH
74319: LD_INT 1
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 0
74328: PUSH
74329: LD_INT 1
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 1
74338: NEG
74339: PUSH
74340: LD_INT 0
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 1
74349: NEG
74350: PUSH
74351: LD_INT 1
74353: NEG
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: LD_INT 1
74361: NEG
74362: PUSH
74363: LD_INT 2
74365: NEG
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 0
74373: PUSH
74374: LD_INT 2
74376: NEG
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 1
74384: PUSH
74385: LD_INT 1
74387: NEG
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 2
74395: PUSH
74396: LD_INT 0
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 2
74405: PUSH
74406: LD_INT 1
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: LD_INT 2
74415: PUSH
74416: LD_INT 2
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: LD_INT 1
74425: PUSH
74426: LD_INT 2
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PUSH
74433: LD_INT 0
74435: PUSH
74436: LD_INT 2
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: LD_INT 1
74445: NEG
74446: PUSH
74447: LD_INT 1
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: PUSH
74454: LD_INT 2
74456: NEG
74457: PUSH
74458: LD_INT 0
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 2
74467: NEG
74468: PUSH
74469: LD_INT 1
74471: NEG
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 2
74479: NEG
74480: PUSH
74481: LD_INT 2
74483: NEG
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: LIST
74493: LIST
74494: LIST
74495: LIST
74496: LIST
74497: LIST
74498: LIST
74499: LIST
74500: LIST
74501: LIST
74502: LIST
74503: LIST
74504: LIST
74505: LIST
74506: LIST
74507: LIST
74508: LIST
74509: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74510: LD_ADDR_VAR 0 56
74514: PUSH
74515: LD_INT 0
74517: PUSH
74518: LD_INT 0
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_INT 0
74527: PUSH
74528: LD_INT 1
74530: NEG
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: PUSH
74536: LD_INT 1
74538: PUSH
74539: LD_INT 0
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: LD_INT 1
74548: PUSH
74549: LD_INT 1
74551: PUSH
74552: EMPTY
74553: LIST
74554: LIST
74555: PUSH
74556: LD_INT 0
74558: PUSH
74559: LD_INT 1
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PUSH
74566: LD_INT 1
74568: NEG
74569: PUSH
74570: LD_INT 0
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 1
74579: NEG
74580: PUSH
74581: LD_INT 1
74583: NEG
74584: PUSH
74585: EMPTY
74586: LIST
74587: LIST
74588: PUSH
74589: LD_INT 1
74591: NEG
74592: PUSH
74593: LD_INT 2
74595: NEG
74596: PUSH
74597: EMPTY
74598: LIST
74599: LIST
74600: PUSH
74601: LD_INT 0
74603: PUSH
74604: LD_INT 2
74606: NEG
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 1
74614: PUSH
74615: LD_INT 1
74617: NEG
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: PUSH
74623: LD_INT 2
74625: PUSH
74626: LD_INT 0
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: PUSH
74633: LD_INT 2
74635: PUSH
74636: LD_INT 1
74638: PUSH
74639: EMPTY
74640: LIST
74641: LIST
74642: PUSH
74643: LD_INT 2
74645: PUSH
74646: LD_INT 2
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 1
74655: PUSH
74656: LD_INT 2
74658: PUSH
74659: EMPTY
74660: LIST
74661: LIST
74662: PUSH
74663: LD_INT 0
74665: PUSH
74666: LD_INT 2
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: PUSH
74673: LD_INT 1
74675: NEG
74676: PUSH
74677: LD_INT 1
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 2
74686: NEG
74687: PUSH
74688: LD_INT 0
74690: PUSH
74691: EMPTY
74692: LIST
74693: LIST
74694: PUSH
74695: LD_INT 2
74697: NEG
74698: PUSH
74699: LD_INT 1
74701: NEG
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: PUSH
74707: LD_INT 2
74709: NEG
74710: PUSH
74711: LD_INT 2
74713: NEG
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: LIST
74723: LIST
74724: LIST
74725: LIST
74726: LIST
74727: LIST
74728: LIST
74729: LIST
74730: LIST
74731: LIST
74732: LIST
74733: LIST
74734: LIST
74735: LIST
74736: LIST
74737: LIST
74738: LIST
74739: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74740: LD_ADDR_VAR 0 57
74744: PUSH
74745: LD_INT 0
74747: PUSH
74748: LD_INT 0
74750: PUSH
74751: EMPTY
74752: LIST
74753: LIST
74754: PUSH
74755: LD_INT 0
74757: PUSH
74758: LD_INT 1
74760: NEG
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: LD_INT 1
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 1
74778: PUSH
74779: LD_INT 1
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: PUSH
74786: LD_INT 0
74788: PUSH
74789: LD_INT 1
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: PUSH
74796: LD_INT 1
74798: NEG
74799: PUSH
74800: LD_INT 0
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 1
74809: NEG
74810: PUSH
74811: LD_INT 1
74813: NEG
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 1
74821: NEG
74822: PUSH
74823: LD_INT 2
74825: NEG
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 0
74833: PUSH
74834: LD_INT 2
74836: NEG
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 1
74844: PUSH
74845: LD_INT 1
74847: NEG
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 2
74855: PUSH
74856: LD_INT 0
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 2
74865: PUSH
74866: LD_INT 1
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: PUSH
74873: LD_INT 2
74875: PUSH
74876: LD_INT 2
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: LD_INT 1
74885: PUSH
74886: LD_INT 2
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 0
74895: PUSH
74896: LD_INT 2
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 1
74905: NEG
74906: PUSH
74907: LD_INT 1
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 2
74916: NEG
74917: PUSH
74918: LD_INT 0
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: PUSH
74925: LD_INT 2
74927: NEG
74928: PUSH
74929: LD_INT 1
74931: NEG
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: LD_INT 2
74939: NEG
74940: PUSH
74941: LD_INT 2
74943: NEG
74944: PUSH
74945: EMPTY
74946: LIST
74947: LIST
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: LIST
74953: LIST
74954: LIST
74955: LIST
74956: LIST
74957: LIST
74958: LIST
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: LIST
74968: LIST
74969: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74970: LD_ADDR_VAR 0 58
74974: PUSH
74975: LD_INT 0
74977: PUSH
74978: LD_INT 0
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 0
74987: PUSH
74988: LD_INT 1
74990: NEG
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: LD_INT 1
74998: PUSH
74999: LD_INT 0
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: LD_INT 1
75008: PUSH
75009: LD_INT 1
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: LD_INT 0
75018: PUSH
75019: LD_INT 1
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 1
75028: NEG
75029: PUSH
75030: LD_INT 0
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 1
75039: NEG
75040: PUSH
75041: LD_INT 1
75043: NEG
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: LD_INT 1
75051: NEG
75052: PUSH
75053: LD_INT 2
75055: NEG
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 0
75063: PUSH
75064: LD_INT 2
75066: NEG
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 1
75074: PUSH
75075: LD_INT 1
75077: NEG
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 2
75085: PUSH
75086: LD_INT 0
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 2
75095: PUSH
75096: LD_INT 1
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 2
75105: PUSH
75106: LD_INT 2
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 1
75115: PUSH
75116: LD_INT 2
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: PUSH
75123: LD_INT 0
75125: PUSH
75126: LD_INT 2
75128: PUSH
75129: EMPTY
75130: LIST
75131: LIST
75132: PUSH
75133: LD_INT 1
75135: NEG
75136: PUSH
75137: LD_INT 1
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 2
75146: NEG
75147: PUSH
75148: LD_INT 0
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: PUSH
75155: LD_INT 2
75157: NEG
75158: PUSH
75159: LD_INT 1
75161: NEG
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 2
75169: NEG
75170: PUSH
75171: LD_INT 2
75173: NEG
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: LIST
75183: LIST
75184: LIST
75185: LIST
75186: LIST
75187: LIST
75188: LIST
75189: LIST
75190: LIST
75191: LIST
75192: LIST
75193: LIST
75194: LIST
75195: LIST
75196: LIST
75197: LIST
75198: LIST
75199: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75200: LD_ADDR_VAR 0 59
75204: PUSH
75205: LD_INT 0
75207: PUSH
75208: LD_INT 0
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: PUSH
75215: LD_INT 0
75217: PUSH
75218: LD_INT 1
75220: NEG
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PUSH
75226: LD_INT 1
75228: PUSH
75229: LD_INT 0
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: LD_INT 1
75238: PUSH
75239: LD_INT 1
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: PUSH
75246: LD_INT 0
75248: PUSH
75249: LD_INT 1
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 1
75258: NEG
75259: PUSH
75260: LD_INT 0
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: PUSH
75267: LD_INT 1
75269: NEG
75270: PUSH
75271: LD_INT 1
75273: NEG
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: LIST
75283: LIST
75284: LIST
75285: LIST
75286: LIST
75287: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75288: LD_ADDR_VAR 0 60
75292: PUSH
75293: LD_INT 0
75295: PUSH
75296: LD_INT 0
75298: PUSH
75299: EMPTY
75300: LIST
75301: LIST
75302: PUSH
75303: LD_INT 0
75305: PUSH
75306: LD_INT 1
75308: NEG
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: PUSH
75314: LD_INT 1
75316: PUSH
75317: LD_INT 0
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PUSH
75324: LD_INT 1
75326: PUSH
75327: LD_INT 1
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: PUSH
75334: LD_INT 0
75336: PUSH
75337: LD_INT 1
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PUSH
75344: LD_INT 1
75346: NEG
75347: PUSH
75348: LD_INT 0
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 1
75357: NEG
75358: PUSH
75359: LD_INT 1
75361: NEG
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: EMPTY
75368: LIST
75369: LIST
75370: LIST
75371: LIST
75372: LIST
75373: LIST
75374: LIST
75375: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75376: LD_ADDR_VAR 0 61
75380: PUSH
75381: LD_INT 0
75383: PUSH
75384: LD_INT 0
75386: PUSH
75387: EMPTY
75388: LIST
75389: LIST
75390: PUSH
75391: LD_INT 0
75393: PUSH
75394: LD_INT 1
75396: NEG
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PUSH
75402: LD_INT 1
75404: PUSH
75405: LD_INT 0
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: LD_INT 1
75414: PUSH
75415: LD_INT 1
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: PUSH
75422: LD_INT 0
75424: PUSH
75425: LD_INT 1
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 1
75434: NEG
75435: PUSH
75436: LD_INT 0
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 1
75445: NEG
75446: PUSH
75447: LD_INT 1
75449: NEG
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: LIST
75459: LIST
75460: LIST
75461: LIST
75462: LIST
75463: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75464: LD_ADDR_VAR 0 62
75468: PUSH
75469: LD_INT 0
75471: PUSH
75472: LD_INT 0
75474: PUSH
75475: EMPTY
75476: LIST
75477: LIST
75478: PUSH
75479: LD_INT 0
75481: PUSH
75482: LD_INT 1
75484: NEG
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: PUSH
75490: LD_INT 1
75492: PUSH
75493: LD_INT 0
75495: PUSH
75496: EMPTY
75497: LIST
75498: LIST
75499: PUSH
75500: LD_INT 1
75502: PUSH
75503: LD_INT 1
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PUSH
75510: LD_INT 0
75512: PUSH
75513: LD_INT 1
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PUSH
75520: LD_INT 1
75522: NEG
75523: PUSH
75524: LD_INT 0
75526: PUSH
75527: EMPTY
75528: LIST
75529: LIST
75530: PUSH
75531: LD_INT 1
75533: NEG
75534: PUSH
75535: LD_INT 1
75537: NEG
75538: PUSH
75539: EMPTY
75540: LIST
75541: LIST
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: LIST
75547: LIST
75548: LIST
75549: LIST
75550: LIST
75551: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75552: LD_ADDR_VAR 0 63
75556: PUSH
75557: LD_INT 0
75559: PUSH
75560: LD_INT 0
75562: PUSH
75563: EMPTY
75564: LIST
75565: LIST
75566: PUSH
75567: LD_INT 0
75569: PUSH
75570: LD_INT 1
75572: NEG
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: PUSH
75578: LD_INT 1
75580: PUSH
75581: LD_INT 0
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: LD_INT 1
75590: PUSH
75591: LD_INT 1
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: LD_INT 0
75600: PUSH
75601: LD_INT 1
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 1
75610: NEG
75611: PUSH
75612: LD_INT 0
75614: PUSH
75615: EMPTY
75616: LIST
75617: LIST
75618: PUSH
75619: LD_INT 1
75621: NEG
75622: PUSH
75623: LD_INT 1
75625: NEG
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: LIST
75635: LIST
75636: LIST
75637: LIST
75638: LIST
75639: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75640: LD_ADDR_VAR 0 64
75644: PUSH
75645: LD_INT 0
75647: PUSH
75648: LD_INT 0
75650: PUSH
75651: EMPTY
75652: LIST
75653: LIST
75654: PUSH
75655: LD_INT 0
75657: PUSH
75658: LD_INT 1
75660: NEG
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: PUSH
75666: LD_INT 1
75668: PUSH
75669: LD_INT 0
75671: PUSH
75672: EMPTY
75673: LIST
75674: LIST
75675: PUSH
75676: LD_INT 1
75678: PUSH
75679: LD_INT 1
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: LD_INT 0
75688: PUSH
75689: LD_INT 1
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: LD_INT 1
75698: NEG
75699: PUSH
75700: LD_INT 0
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: LD_INT 1
75709: NEG
75710: PUSH
75711: LD_INT 1
75713: NEG
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: LIST
75723: LIST
75724: LIST
75725: LIST
75726: LIST
75727: ST_TO_ADDR
// end ; 1 :
75728: GO 81625
75730: LD_INT 1
75732: DOUBLE
75733: EQUAL
75734: IFTRUE 75738
75736: GO 78361
75738: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75739: LD_ADDR_VAR 0 11
75743: PUSH
75744: LD_INT 1
75746: NEG
75747: PUSH
75748: LD_INT 3
75750: NEG
75751: PUSH
75752: EMPTY
75753: LIST
75754: LIST
75755: PUSH
75756: LD_INT 0
75758: PUSH
75759: LD_INT 3
75761: NEG
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: PUSH
75767: LD_INT 1
75769: PUSH
75770: LD_INT 2
75772: NEG
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: LIST
75782: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75783: LD_ADDR_VAR 0 12
75787: PUSH
75788: LD_INT 2
75790: PUSH
75791: LD_INT 1
75793: NEG
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 3
75801: PUSH
75802: LD_INT 0
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 3
75811: PUSH
75812: LD_INT 1
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: EMPTY
75820: LIST
75821: LIST
75822: LIST
75823: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75824: LD_ADDR_VAR 0 13
75828: PUSH
75829: LD_INT 3
75831: PUSH
75832: LD_INT 2
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 3
75841: PUSH
75842: LD_INT 3
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: LD_INT 2
75851: PUSH
75852: LD_INT 3
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: LIST
75863: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75864: LD_ADDR_VAR 0 14
75868: PUSH
75869: LD_INT 1
75871: PUSH
75872: LD_INT 3
75874: PUSH
75875: EMPTY
75876: LIST
75877: LIST
75878: PUSH
75879: LD_INT 0
75881: PUSH
75882: LD_INT 3
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: PUSH
75889: LD_INT 1
75891: NEG
75892: PUSH
75893: LD_INT 2
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: LIST
75904: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75905: LD_ADDR_VAR 0 15
75909: PUSH
75910: LD_INT 2
75912: NEG
75913: PUSH
75914: LD_INT 1
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PUSH
75921: LD_INT 3
75923: NEG
75924: PUSH
75925: LD_INT 0
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 3
75934: NEG
75935: PUSH
75936: LD_INT 1
75938: NEG
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: EMPTY
75945: LIST
75946: LIST
75947: LIST
75948: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75949: LD_ADDR_VAR 0 16
75953: PUSH
75954: LD_INT 2
75956: NEG
75957: PUSH
75958: LD_INT 3
75960: NEG
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 3
75968: NEG
75969: PUSH
75970: LD_INT 2
75972: NEG
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: PUSH
75978: LD_INT 3
75980: NEG
75981: PUSH
75982: LD_INT 3
75984: NEG
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: LIST
75994: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75995: LD_ADDR_VAR 0 17
75999: PUSH
76000: LD_INT 1
76002: NEG
76003: PUSH
76004: LD_INT 3
76006: NEG
76007: PUSH
76008: EMPTY
76009: LIST
76010: LIST
76011: PUSH
76012: LD_INT 0
76014: PUSH
76015: LD_INT 3
76017: NEG
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 1
76025: PUSH
76026: LD_INT 2
76028: NEG
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: EMPTY
76035: LIST
76036: LIST
76037: LIST
76038: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76039: LD_ADDR_VAR 0 18
76043: PUSH
76044: LD_INT 2
76046: PUSH
76047: LD_INT 1
76049: NEG
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PUSH
76055: LD_INT 3
76057: PUSH
76058: LD_INT 0
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 3
76067: PUSH
76068: LD_INT 1
76070: PUSH
76071: EMPTY
76072: LIST
76073: LIST
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: LIST
76079: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76080: LD_ADDR_VAR 0 19
76084: PUSH
76085: LD_INT 3
76087: PUSH
76088: LD_INT 2
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 3
76097: PUSH
76098: LD_INT 3
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 2
76107: PUSH
76108: LD_INT 3
76110: PUSH
76111: EMPTY
76112: LIST
76113: LIST
76114: PUSH
76115: EMPTY
76116: LIST
76117: LIST
76118: LIST
76119: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76120: LD_ADDR_VAR 0 20
76124: PUSH
76125: LD_INT 1
76127: PUSH
76128: LD_INT 3
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: LD_INT 0
76137: PUSH
76138: LD_INT 3
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PUSH
76145: LD_INT 1
76147: NEG
76148: PUSH
76149: LD_INT 2
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: EMPTY
76157: LIST
76158: LIST
76159: LIST
76160: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76161: LD_ADDR_VAR 0 21
76165: PUSH
76166: LD_INT 2
76168: NEG
76169: PUSH
76170: LD_INT 1
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 3
76179: NEG
76180: PUSH
76181: LD_INT 0
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: PUSH
76188: LD_INT 3
76190: NEG
76191: PUSH
76192: LD_INT 1
76194: NEG
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: LIST
76204: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76205: LD_ADDR_VAR 0 22
76209: PUSH
76210: LD_INT 2
76212: NEG
76213: PUSH
76214: LD_INT 3
76216: NEG
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: PUSH
76222: LD_INT 3
76224: NEG
76225: PUSH
76226: LD_INT 2
76228: NEG
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 3
76236: NEG
76237: PUSH
76238: LD_INT 3
76240: NEG
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: LIST
76250: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76251: LD_ADDR_VAR 0 23
76255: PUSH
76256: LD_INT 0
76258: PUSH
76259: LD_INT 3
76261: NEG
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 1
76269: NEG
76270: PUSH
76271: LD_INT 4
76273: NEG
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: LD_INT 1
76281: PUSH
76282: LD_INT 3
76284: NEG
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: LIST
76294: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76295: LD_ADDR_VAR 0 24
76299: PUSH
76300: LD_INT 3
76302: PUSH
76303: LD_INT 0
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: PUSH
76310: LD_INT 3
76312: PUSH
76313: LD_INT 1
76315: NEG
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PUSH
76321: LD_INT 4
76323: PUSH
76324: LD_INT 1
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: LIST
76335: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76336: LD_ADDR_VAR 0 25
76340: PUSH
76341: LD_INT 3
76343: PUSH
76344: LD_INT 3
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: PUSH
76351: LD_INT 4
76353: PUSH
76354: LD_INT 3
76356: PUSH
76357: EMPTY
76358: LIST
76359: LIST
76360: PUSH
76361: LD_INT 3
76363: PUSH
76364: LD_INT 4
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PUSH
76371: EMPTY
76372: LIST
76373: LIST
76374: LIST
76375: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76376: LD_ADDR_VAR 0 26
76380: PUSH
76381: LD_INT 0
76383: PUSH
76384: LD_INT 3
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PUSH
76391: LD_INT 1
76393: PUSH
76394: LD_INT 4
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 1
76403: NEG
76404: PUSH
76405: LD_INT 3
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: LIST
76416: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76417: LD_ADDR_VAR 0 27
76421: PUSH
76422: LD_INT 3
76424: NEG
76425: PUSH
76426: LD_INT 0
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: LD_INT 3
76435: NEG
76436: PUSH
76437: LD_INT 1
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 4
76446: NEG
76447: PUSH
76448: LD_INT 1
76450: NEG
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: LIST
76460: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76461: LD_ADDR_VAR 0 28
76465: PUSH
76466: LD_INT 3
76468: NEG
76469: PUSH
76470: LD_INT 3
76472: NEG
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: PUSH
76478: LD_INT 3
76480: NEG
76481: PUSH
76482: LD_INT 4
76484: NEG
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 4
76492: NEG
76493: PUSH
76494: LD_INT 3
76496: NEG
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: LIST
76506: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76507: LD_ADDR_VAR 0 29
76511: PUSH
76512: LD_INT 1
76514: NEG
76515: PUSH
76516: LD_INT 3
76518: NEG
76519: PUSH
76520: EMPTY
76521: LIST
76522: LIST
76523: PUSH
76524: LD_INT 0
76526: PUSH
76527: LD_INT 3
76529: NEG
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PUSH
76535: LD_INT 1
76537: PUSH
76538: LD_INT 2
76540: NEG
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: LD_INT 1
76548: NEG
76549: PUSH
76550: LD_INT 4
76552: NEG
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: PUSH
76558: LD_INT 0
76560: PUSH
76561: LD_INT 4
76563: NEG
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 1
76571: PUSH
76572: LD_INT 3
76574: NEG
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 1
76582: NEG
76583: PUSH
76584: LD_INT 5
76586: NEG
76587: PUSH
76588: EMPTY
76589: LIST
76590: LIST
76591: PUSH
76592: LD_INT 0
76594: PUSH
76595: LD_INT 5
76597: NEG
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PUSH
76603: LD_INT 1
76605: PUSH
76606: LD_INT 4
76608: NEG
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: LD_INT 1
76616: NEG
76617: PUSH
76618: LD_INT 6
76620: NEG
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PUSH
76626: LD_INT 0
76628: PUSH
76629: LD_INT 6
76631: NEG
76632: PUSH
76633: EMPTY
76634: LIST
76635: LIST
76636: PUSH
76637: LD_INT 1
76639: PUSH
76640: LD_INT 5
76642: NEG
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: LIST
76652: LIST
76653: LIST
76654: LIST
76655: LIST
76656: LIST
76657: LIST
76658: LIST
76659: LIST
76660: LIST
76661: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76662: LD_ADDR_VAR 0 30
76666: PUSH
76667: LD_INT 2
76669: PUSH
76670: LD_INT 1
76672: NEG
76673: PUSH
76674: EMPTY
76675: LIST
76676: LIST
76677: PUSH
76678: LD_INT 3
76680: PUSH
76681: LD_INT 0
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: PUSH
76688: LD_INT 3
76690: PUSH
76691: LD_INT 1
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PUSH
76698: LD_INT 3
76700: PUSH
76701: LD_INT 1
76703: NEG
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: PUSH
76709: LD_INT 4
76711: PUSH
76712: LD_INT 0
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 4
76721: PUSH
76722: LD_INT 1
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 4
76731: PUSH
76732: LD_INT 1
76734: NEG
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: PUSH
76740: LD_INT 5
76742: PUSH
76743: LD_INT 0
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: PUSH
76750: LD_INT 5
76752: PUSH
76753: LD_INT 1
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PUSH
76760: LD_INT 5
76762: PUSH
76763: LD_INT 1
76765: NEG
76766: PUSH
76767: EMPTY
76768: LIST
76769: LIST
76770: PUSH
76771: LD_INT 6
76773: PUSH
76774: LD_INT 0
76776: PUSH
76777: EMPTY
76778: LIST
76779: LIST
76780: PUSH
76781: LD_INT 6
76783: PUSH
76784: LD_INT 1
76786: PUSH
76787: EMPTY
76788: LIST
76789: LIST
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: LIST
76795: LIST
76796: LIST
76797: LIST
76798: LIST
76799: LIST
76800: LIST
76801: LIST
76802: LIST
76803: LIST
76804: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76805: LD_ADDR_VAR 0 31
76809: PUSH
76810: LD_INT 3
76812: PUSH
76813: LD_INT 2
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: LD_INT 3
76822: PUSH
76823: LD_INT 3
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: PUSH
76830: LD_INT 2
76832: PUSH
76833: LD_INT 3
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 4
76842: PUSH
76843: LD_INT 3
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 4
76852: PUSH
76853: LD_INT 4
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: LD_INT 3
76862: PUSH
76863: LD_INT 4
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 5
76872: PUSH
76873: LD_INT 4
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 5
76882: PUSH
76883: LD_INT 5
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 4
76892: PUSH
76893: LD_INT 5
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: LD_INT 6
76902: PUSH
76903: LD_INT 5
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: PUSH
76910: LD_INT 6
76912: PUSH
76913: LD_INT 6
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: PUSH
76920: LD_INT 5
76922: PUSH
76923: LD_INT 6
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: PUSH
76930: EMPTY
76931: LIST
76932: LIST
76933: LIST
76934: LIST
76935: LIST
76936: LIST
76937: LIST
76938: LIST
76939: LIST
76940: LIST
76941: LIST
76942: LIST
76943: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76944: LD_ADDR_VAR 0 32
76948: PUSH
76949: LD_INT 1
76951: PUSH
76952: LD_INT 3
76954: PUSH
76955: EMPTY
76956: LIST
76957: LIST
76958: PUSH
76959: LD_INT 0
76961: PUSH
76962: LD_INT 3
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 1
76971: NEG
76972: PUSH
76973: LD_INT 2
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 1
76982: PUSH
76983: LD_INT 4
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 0
76992: PUSH
76993: LD_INT 4
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: LD_INT 1
77002: NEG
77003: PUSH
77004: LD_INT 3
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: PUSH
77011: LD_INT 1
77013: PUSH
77014: LD_INT 5
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: PUSH
77021: LD_INT 0
77023: PUSH
77024: LD_INT 5
77026: PUSH
77027: EMPTY
77028: LIST
77029: LIST
77030: PUSH
77031: LD_INT 1
77033: NEG
77034: PUSH
77035: LD_INT 4
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: PUSH
77042: LD_INT 1
77044: PUSH
77045: LD_INT 6
77047: PUSH
77048: EMPTY
77049: LIST
77050: LIST
77051: PUSH
77052: LD_INT 0
77054: PUSH
77055: LD_INT 6
77057: PUSH
77058: EMPTY
77059: LIST
77060: LIST
77061: PUSH
77062: LD_INT 1
77064: NEG
77065: PUSH
77066: LD_INT 5
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: LIST
77077: LIST
77078: LIST
77079: LIST
77080: LIST
77081: LIST
77082: LIST
77083: LIST
77084: LIST
77085: LIST
77086: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77087: LD_ADDR_VAR 0 33
77091: PUSH
77092: LD_INT 2
77094: NEG
77095: PUSH
77096: LD_INT 1
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 3
77105: NEG
77106: PUSH
77107: LD_INT 0
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PUSH
77114: LD_INT 3
77116: NEG
77117: PUSH
77118: LD_INT 1
77120: NEG
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PUSH
77126: LD_INT 3
77128: NEG
77129: PUSH
77130: LD_INT 1
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 4
77139: NEG
77140: PUSH
77141: LD_INT 0
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: LD_INT 4
77150: NEG
77151: PUSH
77152: LD_INT 1
77154: NEG
77155: PUSH
77156: EMPTY
77157: LIST
77158: LIST
77159: PUSH
77160: LD_INT 4
77162: NEG
77163: PUSH
77164: LD_INT 1
77166: PUSH
77167: EMPTY
77168: LIST
77169: LIST
77170: PUSH
77171: LD_INT 5
77173: NEG
77174: PUSH
77175: LD_INT 0
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: LD_INT 5
77184: NEG
77185: PUSH
77186: LD_INT 1
77188: NEG
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 5
77196: NEG
77197: PUSH
77198: LD_INT 1
77200: PUSH
77201: EMPTY
77202: LIST
77203: LIST
77204: PUSH
77205: LD_INT 6
77207: NEG
77208: PUSH
77209: LD_INT 0
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: LD_INT 6
77218: NEG
77219: PUSH
77220: LD_INT 1
77222: NEG
77223: PUSH
77224: EMPTY
77225: LIST
77226: LIST
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: LIST
77232: LIST
77233: LIST
77234: LIST
77235: LIST
77236: LIST
77237: LIST
77238: LIST
77239: LIST
77240: LIST
77241: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77242: LD_ADDR_VAR 0 34
77246: PUSH
77247: LD_INT 2
77249: NEG
77250: PUSH
77251: LD_INT 3
77253: NEG
77254: PUSH
77255: EMPTY
77256: LIST
77257: LIST
77258: PUSH
77259: LD_INT 3
77261: NEG
77262: PUSH
77263: LD_INT 2
77265: NEG
77266: PUSH
77267: EMPTY
77268: LIST
77269: LIST
77270: PUSH
77271: LD_INT 3
77273: NEG
77274: PUSH
77275: LD_INT 3
77277: NEG
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: PUSH
77283: LD_INT 3
77285: NEG
77286: PUSH
77287: LD_INT 4
77289: NEG
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 4
77297: NEG
77298: PUSH
77299: LD_INT 3
77301: NEG
77302: PUSH
77303: EMPTY
77304: LIST
77305: LIST
77306: PUSH
77307: LD_INT 4
77309: NEG
77310: PUSH
77311: LD_INT 4
77313: NEG
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: PUSH
77319: LD_INT 4
77321: NEG
77322: PUSH
77323: LD_INT 5
77325: NEG
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: PUSH
77331: LD_INT 5
77333: NEG
77334: PUSH
77335: LD_INT 4
77337: NEG
77338: PUSH
77339: EMPTY
77340: LIST
77341: LIST
77342: PUSH
77343: LD_INT 5
77345: NEG
77346: PUSH
77347: LD_INT 5
77349: NEG
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PUSH
77355: LD_INT 5
77357: NEG
77358: PUSH
77359: LD_INT 6
77361: NEG
77362: PUSH
77363: EMPTY
77364: LIST
77365: LIST
77366: PUSH
77367: LD_INT 6
77369: NEG
77370: PUSH
77371: LD_INT 5
77373: NEG
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: PUSH
77379: LD_INT 6
77381: NEG
77382: PUSH
77383: LD_INT 6
77385: NEG
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: LIST
77395: LIST
77396: LIST
77397: LIST
77398: LIST
77399: LIST
77400: LIST
77401: LIST
77402: LIST
77403: LIST
77404: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77405: LD_ADDR_VAR 0 41
77409: PUSH
77410: LD_INT 0
77412: PUSH
77413: LD_INT 2
77415: NEG
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 1
77423: NEG
77424: PUSH
77425: LD_INT 3
77427: NEG
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: LD_INT 1
77435: PUSH
77436: LD_INT 2
77438: NEG
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: LIST
77448: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77449: LD_ADDR_VAR 0 42
77453: PUSH
77454: LD_INT 2
77456: PUSH
77457: LD_INT 0
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: LD_INT 2
77466: PUSH
77467: LD_INT 1
77469: NEG
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: PUSH
77475: LD_INT 3
77477: PUSH
77478: LD_INT 1
77480: PUSH
77481: EMPTY
77482: LIST
77483: LIST
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: LIST
77489: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77490: LD_ADDR_VAR 0 43
77494: PUSH
77495: LD_INT 2
77497: PUSH
77498: LD_INT 2
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 3
77507: PUSH
77508: LD_INT 2
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: LD_INT 2
77517: PUSH
77518: LD_INT 3
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: LIST
77529: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77530: LD_ADDR_VAR 0 44
77534: PUSH
77535: LD_INT 0
77537: PUSH
77538: LD_INT 2
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PUSH
77545: LD_INT 1
77547: PUSH
77548: LD_INT 3
77550: PUSH
77551: EMPTY
77552: LIST
77553: LIST
77554: PUSH
77555: LD_INT 1
77557: NEG
77558: PUSH
77559: LD_INT 2
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: LIST
77570: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77571: LD_ADDR_VAR 0 45
77575: PUSH
77576: LD_INT 2
77578: NEG
77579: PUSH
77580: LD_INT 0
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 2
77589: NEG
77590: PUSH
77591: LD_INT 1
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 3
77600: NEG
77601: PUSH
77602: LD_INT 1
77604: NEG
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: LIST
77614: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77615: LD_ADDR_VAR 0 46
77619: PUSH
77620: LD_INT 2
77622: NEG
77623: PUSH
77624: LD_INT 2
77626: NEG
77627: PUSH
77628: EMPTY
77629: LIST
77630: LIST
77631: PUSH
77632: LD_INT 2
77634: NEG
77635: PUSH
77636: LD_INT 3
77638: NEG
77639: PUSH
77640: EMPTY
77641: LIST
77642: LIST
77643: PUSH
77644: LD_INT 3
77646: NEG
77647: PUSH
77648: LD_INT 2
77650: NEG
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: LIST
77660: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77661: LD_ADDR_VAR 0 47
77665: PUSH
77666: LD_INT 2
77668: NEG
77669: PUSH
77670: LD_INT 3
77672: NEG
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: PUSH
77678: LD_INT 1
77680: NEG
77681: PUSH
77682: LD_INT 3
77684: NEG
77685: PUSH
77686: EMPTY
77687: LIST
77688: LIST
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77694: LD_ADDR_VAR 0 48
77698: PUSH
77699: LD_INT 1
77701: PUSH
77702: LD_INT 2
77704: NEG
77705: PUSH
77706: EMPTY
77707: LIST
77708: LIST
77709: PUSH
77710: LD_INT 2
77712: PUSH
77713: LD_INT 1
77715: NEG
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77725: LD_ADDR_VAR 0 49
77729: PUSH
77730: LD_INT 3
77732: PUSH
77733: LD_INT 1
77735: PUSH
77736: EMPTY
77737: LIST
77738: LIST
77739: PUSH
77740: LD_INT 3
77742: PUSH
77743: LD_INT 2
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77754: LD_ADDR_VAR 0 50
77758: PUSH
77759: LD_INT 2
77761: PUSH
77762: LD_INT 3
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: LD_INT 1
77771: PUSH
77772: LD_INT 3
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77783: LD_ADDR_VAR 0 51
77787: PUSH
77788: LD_INT 1
77790: NEG
77791: PUSH
77792: LD_INT 2
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 2
77801: NEG
77802: PUSH
77803: LD_INT 1
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77814: LD_ADDR_VAR 0 52
77818: PUSH
77819: LD_INT 3
77821: NEG
77822: PUSH
77823: LD_INT 1
77825: NEG
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 3
77833: NEG
77834: PUSH
77835: LD_INT 2
77837: NEG
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77847: LD_ADDR_VAR 0 53
77851: PUSH
77852: LD_INT 1
77854: NEG
77855: PUSH
77856: LD_INT 3
77858: NEG
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 0
77866: PUSH
77867: LD_INT 3
77869: NEG
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: LD_INT 1
77877: PUSH
77878: LD_INT 2
77880: NEG
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: LIST
77890: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77891: LD_ADDR_VAR 0 54
77895: PUSH
77896: LD_INT 2
77898: PUSH
77899: LD_INT 1
77901: NEG
77902: PUSH
77903: EMPTY
77904: LIST
77905: LIST
77906: PUSH
77907: LD_INT 3
77909: PUSH
77910: LD_INT 0
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: PUSH
77917: LD_INT 3
77919: PUSH
77920: LD_INT 1
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: LIST
77931: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77932: LD_ADDR_VAR 0 55
77936: PUSH
77937: LD_INT 3
77939: PUSH
77940: LD_INT 2
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 3
77949: PUSH
77950: LD_INT 3
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: PUSH
77957: LD_INT 2
77959: PUSH
77960: LD_INT 3
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: LIST
77971: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77972: LD_ADDR_VAR 0 56
77976: PUSH
77977: LD_INT 1
77979: PUSH
77980: LD_INT 3
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: PUSH
77987: LD_INT 0
77989: PUSH
77990: LD_INT 3
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: PUSH
77997: LD_INT 1
77999: NEG
78000: PUSH
78001: LD_INT 2
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: EMPTY
78009: LIST
78010: LIST
78011: LIST
78012: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78013: LD_ADDR_VAR 0 57
78017: PUSH
78018: LD_INT 2
78020: NEG
78021: PUSH
78022: LD_INT 1
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: LD_INT 3
78031: NEG
78032: PUSH
78033: LD_INT 0
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: LD_INT 3
78042: NEG
78043: PUSH
78044: LD_INT 1
78046: NEG
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: LIST
78056: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78057: LD_ADDR_VAR 0 58
78061: PUSH
78062: LD_INT 2
78064: NEG
78065: PUSH
78066: LD_INT 3
78068: NEG
78069: PUSH
78070: EMPTY
78071: LIST
78072: LIST
78073: PUSH
78074: LD_INT 3
78076: NEG
78077: PUSH
78078: LD_INT 2
78080: NEG
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 3
78088: NEG
78089: PUSH
78090: LD_INT 3
78092: NEG
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: LIST
78102: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78103: LD_ADDR_VAR 0 59
78107: PUSH
78108: LD_INT 1
78110: NEG
78111: PUSH
78112: LD_INT 2
78114: NEG
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 0
78122: PUSH
78123: LD_INT 2
78125: NEG
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: PUSH
78131: LD_INT 1
78133: PUSH
78134: LD_INT 1
78136: NEG
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: LIST
78146: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78147: LD_ADDR_VAR 0 60
78151: PUSH
78152: LD_INT 1
78154: PUSH
78155: LD_INT 1
78157: NEG
78158: PUSH
78159: EMPTY
78160: LIST
78161: LIST
78162: PUSH
78163: LD_INT 2
78165: PUSH
78166: LD_INT 0
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: PUSH
78173: LD_INT 2
78175: PUSH
78176: LD_INT 1
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: LIST
78187: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78188: LD_ADDR_VAR 0 61
78192: PUSH
78193: LD_INT 2
78195: PUSH
78196: LD_INT 1
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: PUSH
78203: LD_INT 2
78205: PUSH
78206: LD_INT 2
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PUSH
78213: LD_INT 1
78215: PUSH
78216: LD_INT 2
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: LIST
78227: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78228: LD_ADDR_VAR 0 62
78232: PUSH
78233: LD_INT 1
78235: PUSH
78236: LD_INT 2
78238: PUSH
78239: EMPTY
78240: LIST
78241: LIST
78242: PUSH
78243: LD_INT 0
78245: PUSH
78246: LD_INT 2
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: PUSH
78253: LD_INT 1
78255: NEG
78256: PUSH
78257: LD_INT 1
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: LIST
78268: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78269: LD_ADDR_VAR 0 63
78273: PUSH
78274: LD_INT 1
78276: NEG
78277: PUSH
78278: LD_INT 1
78280: PUSH
78281: EMPTY
78282: LIST
78283: LIST
78284: PUSH
78285: LD_INT 2
78287: NEG
78288: PUSH
78289: LD_INT 0
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: LD_INT 2
78298: NEG
78299: PUSH
78300: LD_INT 1
78302: NEG
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: LIST
78312: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78313: LD_ADDR_VAR 0 64
78317: PUSH
78318: LD_INT 1
78320: NEG
78321: PUSH
78322: LD_INT 2
78324: NEG
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 2
78332: NEG
78333: PUSH
78334: LD_INT 1
78336: NEG
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 2
78344: NEG
78345: PUSH
78346: LD_INT 2
78348: NEG
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: LIST
78358: ST_TO_ADDR
// end ; 2 :
78359: GO 81625
78361: LD_INT 2
78363: DOUBLE
78364: EQUAL
78365: IFTRUE 78369
78367: GO 81624
78369: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78370: LD_ADDR_VAR 0 29
78374: PUSH
78375: LD_INT 4
78377: PUSH
78378: LD_INT 0
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 4
78387: PUSH
78388: LD_INT 1
78390: NEG
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 5
78398: PUSH
78399: LD_INT 0
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: LD_INT 5
78408: PUSH
78409: LD_INT 1
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PUSH
78416: LD_INT 4
78418: PUSH
78419: LD_INT 1
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 3
78428: PUSH
78429: LD_INT 0
78431: PUSH
78432: EMPTY
78433: LIST
78434: LIST
78435: PUSH
78436: LD_INT 3
78438: PUSH
78439: LD_INT 1
78441: NEG
78442: PUSH
78443: EMPTY
78444: LIST
78445: LIST
78446: PUSH
78447: LD_INT 3
78449: PUSH
78450: LD_INT 2
78452: NEG
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: PUSH
78458: LD_INT 5
78460: PUSH
78461: LD_INT 2
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: LD_INT 3
78470: PUSH
78471: LD_INT 3
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: PUSH
78478: LD_INT 3
78480: PUSH
78481: LD_INT 2
78483: PUSH
78484: EMPTY
78485: LIST
78486: LIST
78487: PUSH
78488: LD_INT 4
78490: PUSH
78491: LD_INT 3
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: PUSH
78498: LD_INT 4
78500: PUSH
78501: LD_INT 4
78503: PUSH
78504: EMPTY
78505: LIST
78506: LIST
78507: PUSH
78508: LD_INT 3
78510: PUSH
78511: LD_INT 4
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PUSH
78518: LD_INT 2
78520: PUSH
78521: LD_INT 3
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: PUSH
78528: LD_INT 2
78530: PUSH
78531: LD_INT 2
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: PUSH
78538: LD_INT 4
78540: PUSH
78541: LD_INT 2
78543: PUSH
78544: EMPTY
78545: LIST
78546: LIST
78547: PUSH
78548: LD_INT 2
78550: PUSH
78551: LD_INT 4
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 0
78560: PUSH
78561: LD_INT 4
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 0
78570: PUSH
78571: LD_INT 3
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 1
78580: PUSH
78581: LD_INT 4
78583: PUSH
78584: EMPTY
78585: LIST
78586: LIST
78587: PUSH
78588: LD_INT 1
78590: PUSH
78591: LD_INT 5
78593: PUSH
78594: EMPTY
78595: LIST
78596: LIST
78597: PUSH
78598: LD_INT 0
78600: PUSH
78601: LD_INT 5
78603: PUSH
78604: EMPTY
78605: LIST
78606: LIST
78607: PUSH
78608: LD_INT 1
78610: NEG
78611: PUSH
78612: LD_INT 4
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 1
78621: NEG
78622: PUSH
78623: LD_INT 3
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 2
78632: PUSH
78633: LD_INT 5
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: LD_INT 2
78642: NEG
78643: PUSH
78644: LD_INT 3
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: LD_INT 3
78653: NEG
78654: PUSH
78655: LD_INT 0
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: PUSH
78662: LD_INT 3
78664: NEG
78665: PUSH
78666: LD_INT 1
78668: NEG
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 2
78676: NEG
78677: PUSH
78678: LD_INT 0
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: LD_INT 2
78687: NEG
78688: PUSH
78689: LD_INT 1
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PUSH
78696: LD_INT 3
78698: NEG
78699: PUSH
78700: LD_INT 1
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: LD_INT 4
78709: NEG
78710: PUSH
78711: LD_INT 0
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 4
78720: NEG
78721: PUSH
78722: LD_INT 1
78724: NEG
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: LD_INT 4
78732: NEG
78733: PUSH
78734: LD_INT 2
78736: NEG
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: LD_INT 2
78744: NEG
78745: PUSH
78746: LD_INT 2
78748: PUSH
78749: EMPTY
78750: LIST
78751: LIST
78752: PUSH
78753: LD_INT 4
78755: NEG
78756: PUSH
78757: LD_INT 4
78759: NEG
78760: PUSH
78761: EMPTY
78762: LIST
78763: LIST
78764: PUSH
78765: LD_INT 4
78767: NEG
78768: PUSH
78769: LD_INT 5
78771: NEG
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 3
78779: NEG
78780: PUSH
78781: LD_INT 4
78783: NEG
78784: PUSH
78785: EMPTY
78786: LIST
78787: LIST
78788: PUSH
78789: LD_INT 3
78791: NEG
78792: PUSH
78793: LD_INT 3
78795: NEG
78796: PUSH
78797: EMPTY
78798: LIST
78799: LIST
78800: PUSH
78801: LD_INT 4
78803: NEG
78804: PUSH
78805: LD_INT 3
78807: NEG
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 5
78815: NEG
78816: PUSH
78817: LD_INT 4
78819: NEG
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: LD_INT 5
78827: NEG
78828: PUSH
78829: LD_INT 5
78831: NEG
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 3
78839: NEG
78840: PUSH
78841: LD_INT 5
78843: NEG
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PUSH
78849: LD_INT 5
78851: NEG
78852: PUSH
78853: LD_INT 3
78855: NEG
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PUSH
78861: EMPTY
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: LIST
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: LIST
78880: LIST
78881: LIST
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: LIST
78905: LIST
78906: LIST
78907: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78908: LD_ADDR_VAR 0 30
78912: PUSH
78913: LD_INT 4
78915: PUSH
78916: LD_INT 4
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: LD_INT 4
78925: PUSH
78926: LD_INT 3
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: LD_INT 5
78935: PUSH
78936: LD_INT 4
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 5
78945: PUSH
78946: LD_INT 5
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 4
78955: PUSH
78956: LD_INT 5
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 3
78965: PUSH
78966: LD_INT 4
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 3
78975: PUSH
78976: LD_INT 3
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 5
78985: PUSH
78986: LD_INT 3
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 3
78995: PUSH
78996: LD_INT 5
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 0
79005: PUSH
79006: LD_INT 3
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 0
79015: PUSH
79016: LD_INT 2
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: PUSH
79023: LD_INT 1
79025: PUSH
79026: LD_INT 3
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 1
79035: PUSH
79036: LD_INT 4
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 0
79045: PUSH
79046: LD_INT 4
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 1
79055: NEG
79056: PUSH
79057: LD_INT 3
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 1
79066: NEG
79067: PUSH
79068: LD_INT 2
79070: PUSH
79071: EMPTY
79072: LIST
79073: LIST
79074: PUSH
79075: LD_INT 2
79077: PUSH
79078: LD_INT 4
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 2
79087: NEG
79088: PUSH
79089: LD_INT 2
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 4
79098: NEG
79099: PUSH
79100: LD_INT 0
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: PUSH
79107: LD_INT 4
79109: NEG
79110: PUSH
79111: LD_INT 1
79113: NEG
79114: PUSH
79115: EMPTY
79116: LIST
79117: LIST
79118: PUSH
79119: LD_INT 3
79121: NEG
79122: PUSH
79123: LD_INT 0
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: LD_INT 3
79132: NEG
79133: PUSH
79134: LD_INT 1
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 4
79143: NEG
79144: PUSH
79145: LD_INT 1
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: LD_INT 5
79154: NEG
79155: PUSH
79156: LD_INT 0
79158: PUSH
79159: EMPTY
79160: LIST
79161: LIST
79162: PUSH
79163: LD_INT 5
79165: NEG
79166: PUSH
79167: LD_INT 1
79169: NEG
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: PUSH
79175: LD_INT 5
79177: NEG
79178: PUSH
79179: LD_INT 2
79181: NEG
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 3
79189: NEG
79190: PUSH
79191: LD_INT 2
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 3
79200: NEG
79201: PUSH
79202: LD_INT 3
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 3
79212: NEG
79213: PUSH
79214: LD_INT 4
79216: NEG
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: LD_INT 2
79224: NEG
79225: PUSH
79226: LD_INT 3
79228: NEG
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: LD_INT 2
79236: NEG
79237: PUSH
79238: LD_INT 2
79240: NEG
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: PUSH
79246: LD_INT 3
79248: NEG
79249: PUSH
79250: LD_INT 2
79252: NEG
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 4
79260: NEG
79261: PUSH
79262: LD_INT 3
79264: NEG
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PUSH
79270: LD_INT 4
79272: NEG
79273: PUSH
79274: LD_INT 4
79276: NEG
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: PUSH
79282: LD_INT 2
79284: NEG
79285: PUSH
79286: LD_INT 4
79288: NEG
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 4
79296: NEG
79297: PUSH
79298: LD_INT 2
79300: NEG
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: LD_INT 0
79308: PUSH
79309: LD_INT 4
79311: NEG
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PUSH
79317: LD_INT 0
79319: PUSH
79320: LD_INT 5
79322: NEG
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: PUSH
79328: LD_INT 1
79330: PUSH
79331: LD_INT 4
79333: NEG
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: PUSH
79339: LD_INT 1
79341: PUSH
79342: LD_INT 3
79344: NEG
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: PUSH
79350: LD_INT 0
79352: PUSH
79353: LD_INT 3
79355: NEG
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 1
79363: NEG
79364: PUSH
79365: LD_INT 4
79367: NEG
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: LD_INT 1
79375: NEG
79376: PUSH
79377: LD_INT 5
79379: NEG
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 2
79387: PUSH
79388: LD_INT 3
79390: NEG
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 2
79398: NEG
79399: PUSH
79400: LD_INT 5
79402: NEG
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: PUSH
79408: EMPTY
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79455: LD_ADDR_VAR 0 31
79459: PUSH
79460: LD_INT 0
79462: PUSH
79463: LD_INT 4
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 0
79472: PUSH
79473: LD_INT 3
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: LD_INT 1
79482: PUSH
79483: LD_INT 4
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 1
79492: PUSH
79493: LD_INT 5
79495: PUSH
79496: EMPTY
79497: LIST
79498: LIST
79499: PUSH
79500: LD_INT 0
79502: PUSH
79503: LD_INT 5
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 1
79512: NEG
79513: PUSH
79514: LD_INT 4
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: PUSH
79521: LD_INT 1
79523: NEG
79524: PUSH
79525: LD_INT 3
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PUSH
79532: LD_INT 2
79534: PUSH
79535: LD_INT 5
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 2
79544: NEG
79545: PUSH
79546: LD_INT 3
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 3
79555: NEG
79556: PUSH
79557: LD_INT 0
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 3
79566: NEG
79567: PUSH
79568: LD_INT 1
79570: NEG
79571: PUSH
79572: EMPTY
79573: LIST
79574: LIST
79575: PUSH
79576: LD_INT 2
79578: NEG
79579: PUSH
79580: LD_INT 0
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 2
79589: NEG
79590: PUSH
79591: LD_INT 1
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: PUSH
79598: LD_INT 3
79600: NEG
79601: PUSH
79602: LD_INT 1
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 4
79611: NEG
79612: PUSH
79613: LD_INT 0
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 4
79622: NEG
79623: PUSH
79624: LD_INT 1
79626: NEG
79627: PUSH
79628: EMPTY
79629: LIST
79630: LIST
79631: PUSH
79632: LD_INT 4
79634: NEG
79635: PUSH
79636: LD_INT 2
79638: NEG
79639: PUSH
79640: EMPTY
79641: LIST
79642: LIST
79643: PUSH
79644: LD_INT 2
79646: NEG
79647: PUSH
79648: LD_INT 2
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: PUSH
79655: LD_INT 4
79657: NEG
79658: PUSH
79659: LD_INT 4
79661: NEG
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 4
79669: NEG
79670: PUSH
79671: LD_INT 5
79673: NEG
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: PUSH
79679: LD_INT 3
79681: NEG
79682: PUSH
79683: LD_INT 4
79685: NEG
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: LD_INT 3
79693: NEG
79694: PUSH
79695: LD_INT 3
79697: NEG
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PUSH
79703: LD_INT 4
79705: NEG
79706: PUSH
79707: LD_INT 3
79709: NEG
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: PUSH
79715: LD_INT 5
79717: NEG
79718: PUSH
79719: LD_INT 4
79721: NEG
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: LD_INT 5
79729: NEG
79730: PUSH
79731: LD_INT 5
79733: NEG
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 3
79741: NEG
79742: PUSH
79743: LD_INT 5
79745: NEG
79746: PUSH
79747: EMPTY
79748: LIST
79749: LIST
79750: PUSH
79751: LD_INT 5
79753: NEG
79754: PUSH
79755: LD_INT 3
79757: NEG
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 0
79765: PUSH
79766: LD_INT 3
79768: NEG
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 0
79776: PUSH
79777: LD_INT 4
79779: NEG
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_INT 1
79787: PUSH
79788: LD_INT 3
79790: NEG
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 1
79798: PUSH
79799: LD_INT 2
79801: NEG
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 0
79809: PUSH
79810: LD_INT 2
79812: NEG
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 1
79820: NEG
79821: PUSH
79822: LD_INT 3
79824: NEG
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 1
79832: NEG
79833: PUSH
79834: LD_INT 4
79836: NEG
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_INT 2
79844: PUSH
79845: LD_INT 2
79847: NEG
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PUSH
79853: LD_INT 2
79855: NEG
79856: PUSH
79857: LD_INT 4
79859: NEG
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: PUSH
79865: LD_INT 4
79867: PUSH
79868: LD_INT 0
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: LD_INT 4
79877: PUSH
79878: LD_INT 1
79880: NEG
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 5
79888: PUSH
79889: LD_INT 0
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 5
79898: PUSH
79899: LD_INT 1
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 4
79908: PUSH
79909: LD_INT 1
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 3
79918: PUSH
79919: LD_INT 0
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 3
79928: PUSH
79929: LD_INT 1
79931: NEG
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: PUSH
79937: LD_INT 3
79939: PUSH
79940: LD_INT 2
79942: NEG
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 5
79950: PUSH
79951: LD_INT 2
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: LIST
79962: LIST
79963: LIST
79964: LIST
79965: LIST
79966: LIST
79967: LIST
79968: LIST
79969: LIST
79970: LIST
79971: LIST
79972: LIST
79973: LIST
79974: LIST
79975: LIST
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
80005: LD_ADDR_VAR 0 32
80009: PUSH
80010: LD_INT 4
80012: NEG
80013: PUSH
80014: LD_INT 0
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: LD_INT 4
80023: NEG
80024: PUSH
80025: LD_INT 1
80027: NEG
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 3
80035: NEG
80036: PUSH
80037: LD_INT 0
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 3
80046: NEG
80047: PUSH
80048: LD_INT 1
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 4
80057: NEG
80058: PUSH
80059: LD_INT 1
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 5
80068: NEG
80069: PUSH
80070: LD_INT 0
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 5
80079: NEG
80080: PUSH
80081: LD_INT 1
80083: NEG
80084: PUSH
80085: EMPTY
80086: LIST
80087: LIST
80088: PUSH
80089: LD_INT 5
80091: NEG
80092: PUSH
80093: LD_INT 2
80095: NEG
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 3
80103: NEG
80104: PUSH
80105: LD_INT 2
80107: PUSH
80108: EMPTY
80109: LIST
80110: LIST
80111: PUSH
80112: LD_INT 3
80114: NEG
80115: PUSH
80116: LD_INT 3
80118: NEG
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: LD_INT 3
80126: NEG
80127: PUSH
80128: LD_INT 4
80130: NEG
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 2
80138: NEG
80139: PUSH
80140: LD_INT 3
80142: NEG
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: LD_INT 2
80150: NEG
80151: PUSH
80152: LD_INT 2
80154: NEG
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: LD_INT 3
80162: NEG
80163: PUSH
80164: LD_INT 2
80166: NEG
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 4
80174: NEG
80175: PUSH
80176: LD_INT 3
80178: NEG
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 4
80186: NEG
80187: PUSH
80188: LD_INT 4
80190: NEG
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 2
80198: NEG
80199: PUSH
80200: LD_INT 4
80202: NEG
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: LD_INT 4
80210: NEG
80211: PUSH
80212: LD_INT 2
80214: NEG
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 0
80222: PUSH
80223: LD_INT 4
80225: NEG
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 0
80233: PUSH
80234: LD_INT 5
80236: NEG
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 1
80244: PUSH
80245: LD_INT 4
80247: NEG
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: LD_INT 1
80255: PUSH
80256: LD_INT 3
80258: NEG
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: PUSH
80264: LD_INT 0
80266: PUSH
80267: LD_INT 3
80269: NEG
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 1
80277: NEG
80278: PUSH
80279: LD_INT 4
80281: NEG
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 1
80289: NEG
80290: PUSH
80291: LD_INT 5
80293: NEG
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 2
80301: PUSH
80302: LD_INT 3
80304: NEG
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 2
80312: NEG
80313: PUSH
80314: LD_INT 5
80316: NEG
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: LD_INT 3
80324: PUSH
80325: LD_INT 0
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 3
80334: PUSH
80335: LD_INT 1
80337: NEG
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 4
80345: PUSH
80346: LD_INT 0
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 4
80355: PUSH
80356: LD_INT 1
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: PUSH
80363: LD_INT 3
80365: PUSH
80366: LD_INT 1
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PUSH
80373: LD_INT 2
80375: PUSH
80376: LD_INT 0
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: PUSH
80383: LD_INT 2
80385: PUSH
80386: LD_INT 1
80388: NEG
80389: PUSH
80390: EMPTY
80391: LIST
80392: LIST
80393: PUSH
80394: LD_INT 2
80396: PUSH
80397: LD_INT 2
80399: NEG
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 4
80407: PUSH
80408: LD_INT 2
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 4
80417: PUSH
80418: LD_INT 4
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 4
80427: PUSH
80428: LD_INT 3
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 5
80437: PUSH
80438: LD_INT 4
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 5
80447: PUSH
80448: LD_INT 5
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: PUSH
80455: LD_INT 4
80457: PUSH
80458: LD_INT 5
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PUSH
80465: LD_INT 3
80467: PUSH
80468: LD_INT 4
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 3
80477: PUSH
80478: LD_INT 3
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 5
80487: PUSH
80488: LD_INT 3
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 3
80497: PUSH
80498: LD_INT 5
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: LIST
80509: LIST
80510: LIST
80511: LIST
80512: LIST
80513: LIST
80514: LIST
80515: LIST
80516: LIST
80517: LIST
80518: LIST
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80552: LD_ADDR_VAR 0 33
80556: PUSH
80557: LD_INT 4
80559: NEG
80560: PUSH
80561: LD_INT 4
80563: NEG
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 4
80571: NEG
80572: PUSH
80573: LD_INT 5
80575: NEG
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 3
80583: NEG
80584: PUSH
80585: LD_INT 4
80587: NEG
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: LD_INT 3
80595: NEG
80596: PUSH
80597: LD_INT 3
80599: NEG
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 4
80607: NEG
80608: PUSH
80609: LD_INT 3
80611: NEG
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: LD_INT 5
80619: NEG
80620: PUSH
80621: LD_INT 4
80623: NEG
80624: PUSH
80625: EMPTY
80626: LIST
80627: LIST
80628: PUSH
80629: LD_INT 5
80631: NEG
80632: PUSH
80633: LD_INT 5
80635: NEG
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 3
80643: NEG
80644: PUSH
80645: LD_INT 5
80647: NEG
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: PUSH
80653: LD_INT 5
80655: NEG
80656: PUSH
80657: LD_INT 3
80659: NEG
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: LD_INT 0
80667: PUSH
80668: LD_INT 3
80670: NEG
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 0
80678: PUSH
80679: LD_INT 4
80681: NEG
80682: PUSH
80683: EMPTY
80684: LIST
80685: LIST
80686: PUSH
80687: LD_INT 1
80689: PUSH
80690: LD_INT 3
80692: NEG
80693: PUSH
80694: EMPTY
80695: LIST
80696: LIST
80697: PUSH
80698: LD_INT 1
80700: PUSH
80701: LD_INT 2
80703: NEG
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: PUSH
80709: LD_INT 0
80711: PUSH
80712: LD_INT 2
80714: NEG
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 1
80722: NEG
80723: PUSH
80724: LD_INT 3
80726: NEG
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 1
80734: NEG
80735: PUSH
80736: LD_INT 4
80738: NEG
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 2
80746: PUSH
80747: LD_INT 2
80749: NEG
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: LD_INT 2
80757: NEG
80758: PUSH
80759: LD_INT 4
80761: NEG
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 4
80769: PUSH
80770: LD_INT 0
80772: PUSH
80773: EMPTY
80774: LIST
80775: LIST
80776: PUSH
80777: LD_INT 4
80779: PUSH
80780: LD_INT 1
80782: NEG
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 5
80790: PUSH
80791: LD_INT 0
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 5
80800: PUSH
80801: LD_INT 1
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 4
80810: PUSH
80811: LD_INT 1
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 3
80820: PUSH
80821: LD_INT 0
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 3
80830: PUSH
80831: LD_INT 1
80833: NEG
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 3
80841: PUSH
80842: LD_INT 2
80844: NEG
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 5
80852: PUSH
80853: LD_INT 2
80855: PUSH
80856: EMPTY
80857: LIST
80858: LIST
80859: PUSH
80860: LD_INT 3
80862: PUSH
80863: LD_INT 3
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 3
80872: PUSH
80873: LD_INT 2
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 4
80882: PUSH
80883: LD_INT 3
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PUSH
80890: LD_INT 4
80892: PUSH
80893: LD_INT 4
80895: PUSH
80896: EMPTY
80897: LIST
80898: LIST
80899: PUSH
80900: LD_INT 3
80902: PUSH
80903: LD_INT 4
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 2
80912: PUSH
80913: LD_INT 3
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 2
80922: PUSH
80923: LD_INT 2
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 4
80932: PUSH
80933: LD_INT 2
80935: PUSH
80936: EMPTY
80937: LIST
80938: LIST
80939: PUSH
80940: LD_INT 2
80942: PUSH
80943: LD_INT 4
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 0
80952: PUSH
80953: LD_INT 4
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 0
80962: PUSH
80963: LD_INT 3
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: PUSH
80970: LD_INT 1
80972: PUSH
80973: LD_INT 4
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 1
80982: PUSH
80983: LD_INT 5
80985: PUSH
80986: EMPTY
80987: LIST
80988: LIST
80989: PUSH
80990: LD_INT 0
80992: PUSH
80993: LD_INT 5
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 1
81002: NEG
81003: PUSH
81004: LD_INT 4
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 1
81013: NEG
81014: PUSH
81015: LD_INT 3
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 2
81024: PUSH
81025: LD_INT 5
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 2
81034: NEG
81035: PUSH
81036: LD_INT 3
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81090: LD_ADDR_VAR 0 34
81094: PUSH
81095: LD_INT 0
81097: PUSH
81098: LD_INT 4
81100: NEG
81101: PUSH
81102: EMPTY
81103: LIST
81104: LIST
81105: PUSH
81106: LD_INT 0
81108: PUSH
81109: LD_INT 5
81111: NEG
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 1
81119: PUSH
81120: LD_INT 4
81122: NEG
81123: PUSH
81124: EMPTY
81125: LIST
81126: LIST
81127: PUSH
81128: LD_INT 1
81130: PUSH
81131: LD_INT 3
81133: NEG
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 0
81141: PUSH
81142: LD_INT 3
81144: NEG
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 1
81152: NEG
81153: PUSH
81154: LD_INT 4
81156: NEG
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 1
81164: NEG
81165: PUSH
81166: LD_INT 5
81168: NEG
81169: PUSH
81170: EMPTY
81171: LIST
81172: LIST
81173: PUSH
81174: LD_INT 2
81176: PUSH
81177: LD_INT 3
81179: NEG
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 2
81187: NEG
81188: PUSH
81189: LD_INT 5
81191: NEG
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 3
81199: PUSH
81200: LD_INT 0
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 3
81209: PUSH
81210: LD_INT 1
81212: NEG
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 4
81220: PUSH
81221: LD_INT 0
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 4
81230: PUSH
81231: LD_INT 1
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 3
81240: PUSH
81241: LD_INT 1
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 2
81250: PUSH
81251: LD_INT 0
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 2
81260: PUSH
81261: LD_INT 1
81263: NEG
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: LD_INT 2
81271: PUSH
81272: LD_INT 2
81274: NEG
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 4
81282: PUSH
81283: LD_INT 2
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 4
81292: PUSH
81293: LD_INT 4
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 4
81302: PUSH
81303: LD_INT 3
81305: PUSH
81306: EMPTY
81307: LIST
81308: LIST
81309: PUSH
81310: LD_INT 5
81312: PUSH
81313: LD_INT 4
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 5
81322: PUSH
81323: LD_INT 5
81325: PUSH
81326: EMPTY
81327: LIST
81328: LIST
81329: PUSH
81330: LD_INT 4
81332: PUSH
81333: LD_INT 5
81335: PUSH
81336: EMPTY
81337: LIST
81338: LIST
81339: PUSH
81340: LD_INT 3
81342: PUSH
81343: LD_INT 4
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: PUSH
81350: LD_INT 3
81352: PUSH
81353: LD_INT 3
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 5
81362: PUSH
81363: LD_INT 3
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 3
81372: PUSH
81373: LD_INT 5
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 0
81382: PUSH
81383: LD_INT 3
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 0
81392: PUSH
81393: LD_INT 2
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: PUSH
81400: LD_INT 1
81402: PUSH
81403: LD_INT 3
81405: PUSH
81406: EMPTY
81407: LIST
81408: LIST
81409: PUSH
81410: LD_INT 1
81412: PUSH
81413: LD_INT 4
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 0
81422: PUSH
81423: LD_INT 4
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 1
81432: NEG
81433: PUSH
81434: LD_INT 3
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 1
81443: NEG
81444: PUSH
81445: LD_INT 2
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 2
81454: PUSH
81455: LD_INT 4
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: LD_INT 2
81464: NEG
81465: PUSH
81466: LD_INT 2
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 4
81475: NEG
81476: PUSH
81477: LD_INT 0
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 4
81486: NEG
81487: PUSH
81488: LD_INT 1
81490: NEG
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: PUSH
81496: LD_INT 3
81498: NEG
81499: PUSH
81500: LD_INT 0
81502: PUSH
81503: EMPTY
81504: LIST
81505: LIST
81506: PUSH
81507: LD_INT 3
81509: NEG
81510: PUSH
81511: LD_INT 1
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: LD_INT 4
81520: NEG
81521: PUSH
81522: LD_INT 1
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: LD_INT 5
81531: NEG
81532: PUSH
81533: LD_INT 0
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: LD_INT 5
81542: NEG
81543: PUSH
81544: LD_INT 1
81546: NEG
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: PUSH
81552: LD_INT 5
81554: NEG
81555: PUSH
81556: LD_INT 2
81558: NEG
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PUSH
81564: LD_INT 3
81566: NEG
81567: PUSH
81568: LD_INT 2
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: LIST
81585: LIST
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: ST_TO_ADDR
// end ; end ;
81622: GO 81625
81624: POP
// case btype of b_depot , b_warehouse :
81625: LD_VAR 0 1
81629: PUSH
81630: LD_INT 0
81632: DOUBLE
81633: EQUAL
81634: IFTRUE 81644
81636: LD_INT 1
81638: DOUBLE
81639: EQUAL
81640: IFTRUE 81644
81642: GO 81845
81644: POP
// case nation of nation_american :
81645: LD_VAR 0 5
81649: PUSH
81650: LD_INT 1
81652: DOUBLE
81653: EQUAL
81654: IFTRUE 81658
81656: GO 81714
81658: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
81659: LD_ADDR_VAR 0 9
81663: PUSH
81664: LD_VAR 0 11
81668: PUSH
81669: LD_VAR 0 12
81673: PUSH
81674: LD_VAR 0 13
81678: PUSH
81679: LD_VAR 0 14
81683: PUSH
81684: LD_VAR 0 15
81688: PUSH
81689: LD_VAR 0 16
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: PUSH
81702: LD_VAR 0 4
81706: PUSH
81707: LD_INT 1
81709: PLUS
81710: ARRAY
81711: ST_TO_ADDR
81712: GO 81843
81714: LD_INT 2
81716: DOUBLE
81717: EQUAL
81718: IFTRUE 81722
81720: GO 81778
81722: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
81723: LD_ADDR_VAR 0 9
81727: PUSH
81728: LD_VAR 0 17
81732: PUSH
81733: LD_VAR 0 18
81737: PUSH
81738: LD_VAR 0 19
81742: PUSH
81743: LD_VAR 0 20
81747: PUSH
81748: LD_VAR 0 21
81752: PUSH
81753: LD_VAR 0 22
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: LIST
81765: PUSH
81766: LD_VAR 0 4
81770: PUSH
81771: LD_INT 1
81773: PLUS
81774: ARRAY
81775: ST_TO_ADDR
81776: GO 81843
81778: LD_INT 3
81780: DOUBLE
81781: EQUAL
81782: IFTRUE 81786
81784: GO 81842
81786: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81787: LD_ADDR_VAR 0 9
81791: PUSH
81792: LD_VAR 0 23
81796: PUSH
81797: LD_VAR 0 24
81801: PUSH
81802: LD_VAR 0 25
81806: PUSH
81807: LD_VAR 0 26
81811: PUSH
81812: LD_VAR 0 27
81816: PUSH
81817: LD_VAR 0 28
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: PUSH
81830: LD_VAR 0 4
81834: PUSH
81835: LD_INT 1
81837: PLUS
81838: ARRAY
81839: ST_TO_ADDR
81840: GO 81843
81842: POP
81843: GO 82398
81845: LD_INT 2
81847: DOUBLE
81848: EQUAL
81849: IFTRUE 81859
81851: LD_INT 3
81853: DOUBLE
81854: EQUAL
81855: IFTRUE 81859
81857: GO 81915
81859: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81860: LD_ADDR_VAR 0 9
81864: PUSH
81865: LD_VAR 0 29
81869: PUSH
81870: LD_VAR 0 30
81874: PUSH
81875: LD_VAR 0 31
81879: PUSH
81880: LD_VAR 0 32
81884: PUSH
81885: LD_VAR 0 33
81889: PUSH
81890: LD_VAR 0 34
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: LIST
81899: LIST
81900: LIST
81901: LIST
81902: PUSH
81903: LD_VAR 0 4
81907: PUSH
81908: LD_INT 1
81910: PLUS
81911: ARRAY
81912: ST_TO_ADDR
81913: GO 82398
81915: LD_INT 16
81917: DOUBLE
81918: EQUAL
81919: IFTRUE 81977
81921: LD_INT 17
81923: DOUBLE
81924: EQUAL
81925: IFTRUE 81977
81927: LD_INT 18
81929: DOUBLE
81930: EQUAL
81931: IFTRUE 81977
81933: LD_INT 19
81935: DOUBLE
81936: EQUAL
81937: IFTRUE 81977
81939: LD_INT 22
81941: DOUBLE
81942: EQUAL
81943: IFTRUE 81977
81945: LD_INT 20
81947: DOUBLE
81948: EQUAL
81949: IFTRUE 81977
81951: LD_INT 21
81953: DOUBLE
81954: EQUAL
81955: IFTRUE 81977
81957: LD_INT 23
81959: DOUBLE
81960: EQUAL
81961: IFTRUE 81977
81963: LD_INT 24
81965: DOUBLE
81966: EQUAL
81967: IFTRUE 81977
81969: LD_INT 25
81971: DOUBLE
81972: EQUAL
81973: IFTRUE 81977
81975: GO 82033
81977: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81978: LD_ADDR_VAR 0 9
81982: PUSH
81983: LD_VAR 0 35
81987: PUSH
81988: LD_VAR 0 36
81992: PUSH
81993: LD_VAR 0 37
81997: PUSH
81998: LD_VAR 0 38
82002: PUSH
82003: LD_VAR 0 39
82007: PUSH
82008: LD_VAR 0 40
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: PUSH
82021: LD_VAR 0 4
82025: PUSH
82026: LD_INT 1
82028: PLUS
82029: ARRAY
82030: ST_TO_ADDR
82031: GO 82398
82033: LD_INT 6
82035: DOUBLE
82036: EQUAL
82037: IFTRUE 82089
82039: LD_INT 7
82041: DOUBLE
82042: EQUAL
82043: IFTRUE 82089
82045: LD_INT 8
82047: DOUBLE
82048: EQUAL
82049: IFTRUE 82089
82051: LD_INT 13
82053: DOUBLE
82054: EQUAL
82055: IFTRUE 82089
82057: LD_INT 12
82059: DOUBLE
82060: EQUAL
82061: IFTRUE 82089
82063: LD_INT 15
82065: DOUBLE
82066: EQUAL
82067: IFTRUE 82089
82069: LD_INT 11
82071: DOUBLE
82072: EQUAL
82073: IFTRUE 82089
82075: LD_INT 14
82077: DOUBLE
82078: EQUAL
82079: IFTRUE 82089
82081: LD_INT 10
82083: DOUBLE
82084: EQUAL
82085: IFTRUE 82089
82087: GO 82145
82089: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
82090: LD_ADDR_VAR 0 9
82094: PUSH
82095: LD_VAR 0 41
82099: PUSH
82100: LD_VAR 0 42
82104: PUSH
82105: LD_VAR 0 43
82109: PUSH
82110: LD_VAR 0 44
82114: PUSH
82115: LD_VAR 0 45
82119: PUSH
82120: LD_VAR 0 46
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: LIST
82129: LIST
82130: LIST
82131: LIST
82132: PUSH
82133: LD_VAR 0 4
82137: PUSH
82138: LD_INT 1
82140: PLUS
82141: ARRAY
82142: ST_TO_ADDR
82143: GO 82398
82145: LD_INT 36
82147: DOUBLE
82148: EQUAL
82149: IFTRUE 82153
82151: GO 82209
82153: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82154: LD_ADDR_VAR 0 9
82158: PUSH
82159: LD_VAR 0 47
82163: PUSH
82164: LD_VAR 0 48
82168: PUSH
82169: LD_VAR 0 49
82173: PUSH
82174: LD_VAR 0 50
82178: PUSH
82179: LD_VAR 0 51
82183: PUSH
82184: LD_VAR 0 52
82188: PUSH
82189: EMPTY
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: PUSH
82197: LD_VAR 0 4
82201: PUSH
82202: LD_INT 1
82204: PLUS
82205: ARRAY
82206: ST_TO_ADDR
82207: GO 82398
82209: LD_INT 4
82211: DOUBLE
82212: EQUAL
82213: IFTRUE 82235
82215: LD_INT 5
82217: DOUBLE
82218: EQUAL
82219: IFTRUE 82235
82221: LD_INT 34
82223: DOUBLE
82224: EQUAL
82225: IFTRUE 82235
82227: LD_INT 37
82229: DOUBLE
82230: EQUAL
82231: IFTRUE 82235
82233: GO 82291
82235: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82236: LD_ADDR_VAR 0 9
82240: PUSH
82241: LD_VAR 0 53
82245: PUSH
82246: LD_VAR 0 54
82250: PUSH
82251: LD_VAR 0 55
82255: PUSH
82256: LD_VAR 0 56
82260: PUSH
82261: LD_VAR 0 57
82265: PUSH
82266: LD_VAR 0 58
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: LIST
82275: LIST
82276: LIST
82277: LIST
82278: PUSH
82279: LD_VAR 0 4
82283: PUSH
82284: LD_INT 1
82286: PLUS
82287: ARRAY
82288: ST_TO_ADDR
82289: GO 82398
82291: LD_INT 31
82293: DOUBLE
82294: EQUAL
82295: IFTRUE 82341
82297: LD_INT 32
82299: DOUBLE
82300: EQUAL
82301: IFTRUE 82341
82303: LD_INT 33
82305: DOUBLE
82306: EQUAL
82307: IFTRUE 82341
82309: LD_INT 27
82311: DOUBLE
82312: EQUAL
82313: IFTRUE 82341
82315: LD_INT 26
82317: DOUBLE
82318: EQUAL
82319: IFTRUE 82341
82321: LD_INT 28
82323: DOUBLE
82324: EQUAL
82325: IFTRUE 82341
82327: LD_INT 29
82329: DOUBLE
82330: EQUAL
82331: IFTRUE 82341
82333: LD_INT 30
82335: DOUBLE
82336: EQUAL
82337: IFTRUE 82341
82339: GO 82397
82341: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
82342: LD_ADDR_VAR 0 9
82346: PUSH
82347: LD_VAR 0 59
82351: PUSH
82352: LD_VAR 0 60
82356: PUSH
82357: LD_VAR 0 61
82361: PUSH
82362: LD_VAR 0 62
82366: PUSH
82367: LD_VAR 0 63
82371: PUSH
82372: LD_VAR 0 64
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: PUSH
82385: LD_VAR 0 4
82389: PUSH
82390: LD_INT 1
82392: PLUS
82393: ARRAY
82394: ST_TO_ADDR
82395: GO 82398
82397: POP
// temp_list2 = [ ] ;
82398: LD_ADDR_VAR 0 10
82402: PUSH
82403: EMPTY
82404: ST_TO_ADDR
// for i in temp_list do
82405: LD_ADDR_VAR 0 8
82409: PUSH
82410: LD_VAR 0 9
82414: PUSH
82415: FOR_IN
82416: IFFALSE 82468
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82418: LD_ADDR_VAR 0 10
82422: PUSH
82423: LD_VAR 0 10
82427: PUSH
82428: LD_VAR 0 8
82432: PUSH
82433: LD_INT 1
82435: ARRAY
82436: PUSH
82437: LD_VAR 0 2
82441: PLUS
82442: PUSH
82443: LD_VAR 0 8
82447: PUSH
82448: LD_INT 2
82450: ARRAY
82451: PUSH
82452: LD_VAR 0 3
82456: PLUS
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: EMPTY
82463: LIST
82464: ADD
82465: ST_TO_ADDR
82466: GO 82415
82468: POP
82469: POP
// result = temp_list2 ;
82470: LD_ADDR_VAR 0 7
82474: PUSH
82475: LD_VAR 0 10
82479: ST_TO_ADDR
// end ;
82480: LD_VAR 0 7
82484: RET
// export function EnemyInRange ( unit , dist ) ; begin
82485: LD_INT 0
82487: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82488: LD_ADDR_VAR 0 3
82492: PUSH
82493: LD_VAR 0 1
82497: PPUSH
82498: CALL_OW 255
82502: PPUSH
82503: LD_VAR 0 1
82507: PPUSH
82508: CALL_OW 250
82512: PPUSH
82513: LD_VAR 0 1
82517: PPUSH
82518: CALL_OW 251
82522: PPUSH
82523: LD_VAR 0 2
82527: PPUSH
82528: CALL 56589 0 4
82532: PUSH
82533: LD_INT 4
82535: ARRAY
82536: ST_TO_ADDR
// end ;
82537: LD_VAR 0 3
82541: RET
// export function PlayerSeeMe ( unit ) ; begin
82542: LD_INT 0
82544: PPUSH
// result := See ( your_side , unit ) ;
82545: LD_ADDR_VAR 0 2
82549: PUSH
82550: LD_OWVAR 2
82554: PPUSH
82555: LD_VAR 0 1
82559: PPUSH
82560: CALL_OW 292
82564: ST_TO_ADDR
// end ;
82565: LD_VAR 0 2
82569: RET
// export function ReverseDir ( unit ) ; begin
82570: LD_INT 0
82572: PPUSH
// if not unit then
82573: LD_VAR 0 1
82577: NOT
82578: IFFALSE 82582
// exit ;
82580: GO 82605
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82582: LD_ADDR_VAR 0 2
82586: PUSH
82587: LD_VAR 0 1
82591: PPUSH
82592: CALL_OW 254
82596: PUSH
82597: LD_INT 3
82599: PLUS
82600: PUSH
82601: LD_INT 6
82603: MOD
82604: ST_TO_ADDR
// end ;
82605: LD_VAR 0 2
82609: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
82610: LD_INT 0
82612: PPUSH
82613: PPUSH
82614: PPUSH
82615: PPUSH
82616: PPUSH
// if not hexes then
82617: LD_VAR 0 2
82621: NOT
82622: IFFALSE 82626
// exit ;
82624: GO 82774
// dist := 9999 ;
82626: LD_ADDR_VAR 0 5
82630: PUSH
82631: LD_INT 9999
82633: ST_TO_ADDR
// for i = 1 to hexes do
82634: LD_ADDR_VAR 0 4
82638: PUSH
82639: DOUBLE
82640: LD_INT 1
82642: DEC
82643: ST_TO_ADDR
82644: LD_VAR 0 2
82648: PUSH
82649: FOR_TO
82650: IFFALSE 82762
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
82652: LD_VAR 0 1
82656: PPUSH
82657: LD_VAR 0 2
82661: PUSH
82662: LD_VAR 0 4
82666: ARRAY
82667: PUSH
82668: LD_INT 1
82670: ARRAY
82671: PPUSH
82672: LD_VAR 0 2
82676: PUSH
82677: LD_VAR 0 4
82681: ARRAY
82682: PUSH
82683: LD_INT 2
82685: ARRAY
82686: PPUSH
82687: CALL_OW 297
82691: PUSH
82692: LD_VAR 0 5
82696: LESS
82697: IFFALSE 82760
// begin hex := hexes [ i ] ;
82699: LD_ADDR_VAR 0 7
82703: PUSH
82704: LD_VAR 0 2
82708: PUSH
82709: LD_VAR 0 4
82713: ARRAY
82714: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82715: LD_ADDR_VAR 0 5
82719: PUSH
82720: LD_VAR 0 1
82724: PPUSH
82725: LD_VAR 0 2
82729: PUSH
82730: LD_VAR 0 4
82734: ARRAY
82735: PUSH
82736: LD_INT 1
82738: ARRAY
82739: PPUSH
82740: LD_VAR 0 2
82744: PUSH
82745: LD_VAR 0 4
82749: ARRAY
82750: PUSH
82751: LD_INT 2
82753: ARRAY
82754: PPUSH
82755: CALL_OW 297
82759: ST_TO_ADDR
// end ; end ;
82760: GO 82649
82762: POP
82763: POP
// result := hex ;
82764: LD_ADDR_VAR 0 3
82768: PUSH
82769: LD_VAR 0 7
82773: ST_TO_ADDR
// end ;
82774: LD_VAR 0 3
82778: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82779: LD_INT 0
82781: PPUSH
82782: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82783: LD_VAR 0 1
82787: NOT
82788: PUSH
82789: LD_VAR 0 1
82793: PUSH
82794: LD_INT 21
82796: PUSH
82797: LD_INT 2
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 23
82806: PUSH
82807: LD_INT 2
82809: PUSH
82810: EMPTY
82811: LIST
82812: LIST
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: PPUSH
82818: CALL_OW 69
82822: IN
82823: NOT
82824: OR
82825: IFFALSE 82829
// exit ;
82827: GO 82876
// for i = 1 to 3 do
82829: LD_ADDR_VAR 0 3
82833: PUSH
82834: DOUBLE
82835: LD_INT 1
82837: DEC
82838: ST_TO_ADDR
82839: LD_INT 3
82841: PUSH
82842: FOR_TO
82843: IFFALSE 82874
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82845: LD_VAR 0 1
82849: PPUSH
82850: CALL_OW 250
82854: PPUSH
82855: LD_VAR 0 1
82859: PPUSH
82860: CALL_OW 251
82864: PPUSH
82865: LD_INT 1
82867: PPUSH
82868: CALL_OW 453
82872: GO 82842
82874: POP
82875: POP
// end ;
82876: LD_VAR 0 2
82880: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82881: LD_INT 0
82883: PPUSH
82884: PPUSH
82885: PPUSH
82886: PPUSH
82887: PPUSH
82888: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82889: LD_VAR 0 1
82893: NOT
82894: PUSH
82895: LD_VAR 0 2
82899: NOT
82900: OR
82901: PUSH
82902: LD_VAR 0 1
82906: PPUSH
82907: CALL_OW 314
82911: OR
82912: IFFALSE 82916
// exit ;
82914: GO 83357
// x := GetX ( enemy_unit ) ;
82916: LD_ADDR_VAR 0 7
82920: PUSH
82921: LD_VAR 0 2
82925: PPUSH
82926: CALL_OW 250
82930: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82931: LD_ADDR_VAR 0 8
82935: PUSH
82936: LD_VAR 0 2
82940: PPUSH
82941: CALL_OW 251
82945: ST_TO_ADDR
// if not x or not y then
82946: LD_VAR 0 7
82950: NOT
82951: PUSH
82952: LD_VAR 0 8
82956: NOT
82957: OR
82958: IFFALSE 82962
// exit ;
82960: GO 83357
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82962: LD_ADDR_VAR 0 6
82966: PUSH
82967: LD_VAR 0 7
82971: PPUSH
82972: LD_INT 0
82974: PPUSH
82975: LD_INT 4
82977: PPUSH
82978: CALL_OW 272
82982: PUSH
82983: LD_VAR 0 8
82987: PPUSH
82988: LD_INT 0
82990: PPUSH
82991: LD_INT 4
82993: PPUSH
82994: CALL_OW 273
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: LD_VAR 0 7
83007: PPUSH
83008: LD_INT 1
83010: PPUSH
83011: LD_INT 4
83013: PPUSH
83014: CALL_OW 272
83018: PUSH
83019: LD_VAR 0 8
83023: PPUSH
83024: LD_INT 1
83026: PPUSH
83027: LD_INT 4
83029: PPUSH
83030: CALL_OW 273
83034: PUSH
83035: EMPTY
83036: LIST
83037: LIST
83038: PUSH
83039: LD_VAR 0 7
83043: PPUSH
83044: LD_INT 2
83046: PPUSH
83047: LD_INT 4
83049: PPUSH
83050: CALL_OW 272
83054: PUSH
83055: LD_VAR 0 8
83059: PPUSH
83060: LD_INT 2
83062: PPUSH
83063: LD_INT 4
83065: PPUSH
83066: CALL_OW 273
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_VAR 0 7
83079: PPUSH
83080: LD_INT 3
83082: PPUSH
83083: LD_INT 4
83085: PPUSH
83086: CALL_OW 272
83090: PUSH
83091: LD_VAR 0 8
83095: PPUSH
83096: LD_INT 3
83098: PPUSH
83099: LD_INT 4
83101: PPUSH
83102: CALL_OW 273
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: PUSH
83111: LD_VAR 0 7
83115: PPUSH
83116: LD_INT 4
83118: PPUSH
83119: LD_INT 4
83121: PPUSH
83122: CALL_OW 272
83126: PUSH
83127: LD_VAR 0 8
83131: PPUSH
83132: LD_INT 4
83134: PPUSH
83135: LD_INT 4
83137: PPUSH
83138: CALL_OW 273
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_VAR 0 7
83151: PPUSH
83152: LD_INT 5
83154: PPUSH
83155: LD_INT 4
83157: PPUSH
83158: CALL_OW 272
83162: PUSH
83163: LD_VAR 0 8
83167: PPUSH
83168: LD_INT 5
83170: PPUSH
83171: LD_INT 4
83173: PPUSH
83174: CALL_OW 273
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: LIST
83189: LIST
83190: ST_TO_ADDR
// for i = tmp downto 1 do
83191: LD_ADDR_VAR 0 4
83195: PUSH
83196: DOUBLE
83197: LD_VAR 0 6
83201: INC
83202: ST_TO_ADDR
83203: LD_INT 1
83205: PUSH
83206: FOR_DOWNTO
83207: IFFALSE 83308
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83209: LD_VAR 0 6
83213: PUSH
83214: LD_VAR 0 4
83218: ARRAY
83219: PUSH
83220: LD_INT 1
83222: ARRAY
83223: PPUSH
83224: LD_VAR 0 6
83228: PUSH
83229: LD_VAR 0 4
83233: ARRAY
83234: PUSH
83235: LD_INT 2
83237: ARRAY
83238: PPUSH
83239: CALL_OW 488
83243: NOT
83244: PUSH
83245: LD_VAR 0 6
83249: PUSH
83250: LD_VAR 0 4
83254: ARRAY
83255: PUSH
83256: LD_INT 1
83258: ARRAY
83259: PPUSH
83260: LD_VAR 0 6
83264: PUSH
83265: LD_VAR 0 4
83269: ARRAY
83270: PUSH
83271: LD_INT 2
83273: ARRAY
83274: PPUSH
83275: CALL_OW 428
83279: PUSH
83280: LD_INT 0
83282: NONEQUAL
83283: OR
83284: IFFALSE 83306
// tmp := Delete ( tmp , i ) ;
83286: LD_ADDR_VAR 0 6
83290: PUSH
83291: LD_VAR 0 6
83295: PPUSH
83296: LD_VAR 0 4
83300: PPUSH
83301: CALL_OW 3
83305: ST_TO_ADDR
83306: GO 83206
83308: POP
83309: POP
// j := GetClosestHex ( unit , tmp ) ;
83310: LD_ADDR_VAR 0 5
83314: PUSH
83315: LD_VAR 0 1
83319: PPUSH
83320: LD_VAR 0 6
83324: PPUSH
83325: CALL 82610 0 2
83329: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83330: LD_VAR 0 1
83334: PPUSH
83335: LD_VAR 0 5
83339: PUSH
83340: LD_INT 1
83342: ARRAY
83343: PPUSH
83344: LD_VAR 0 5
83348: PUSH
83349: LD_INT 2
83351: ARRAY
83352: PPUSH
83353: CALL_OW 111
// end ;
83357: LD_VAR 0 3
83361: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83362: LD_INT 0
83364: PPUSH
83365: PPUSH
83366: PPUSH
// uc_side = 0 ;
83367: LD_ADDR_OWVAR 20
83371: PUSH
83372: LD_INT 0
83374: ST_TO_ADDR
// uc_nation = 0 ;
83375: LD_ADDR_OWVAR 21
83379: PUSH
83380: LD_INT 0
83382: ST_TO_ADDR
// InitHc ;
83383: CALL_OW 19
// InitVc ;
83387: CALL_OW 20
// if mastodonts then
83391: LD_VAR 0 6
83395: IFFALSE 83462
// for i = 1 to mastodonts do
83397: LD_ADDR_VAR 0 11
83401: PUSH
83402: DOUBLE
83403: LD_INT 1
83405: DEC
83406: ST_TO_ADDR
83407: LD_VAR 0 6
83411: PUSH
83412: FOR_TO
83413: IFFALSE 83460
// begin vc_chassis := 31 ;
83415: LD_ADDR_OWVAR 37
83419: PUSH
83420: LD_INT 31
83422: ST_TO_ADDR
// vc_control := control_rider ;
83423: LD_ADDR_OWVAR 38
83427: PUSH
83428: LD_INT 4
83430: ST_TO_ADDR
// animal := CreateVehicle ;
83431: LD_ADDR_VAR 0 12
83435: PUSH
83436: CALL_OW 45
83440: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83441: LD_VAR 0 12
83445: PPUSH
83446: LD_VAR 0 8
83450: PPUSH
83451: LD_INT 0
83453: PPUSH
83454: CALL 85531 0 3
// end ;
83458: GO 83412
83460: POP
83461: POP
// if horses then
83462: LD_VAR 0 5
83466: IFFALSE 83533
// for i = 1 to horses do
83468: LD_ADDR_VAR 0 11
83472: PUSH
83473: DOUBLE
83474: LD_INT 1
83476: DEC
83477: ST_TO_ADDR
83478: LD_VAR 0 5
83482: PUSH
83483: FOR_TO
83484: IFFALSE 83531
// begin hc_class := 21 ;
83486: LD_ADDR_OWVAR 28
83490: PUSH
83491: LD_INT 21
83493: ST_TO_ADDR
// hc_gallery :=  ;
83494: LD_ADDR_OWVAR 33
83498: PUSH
83499: LD_STRING 
83501: ST_TO_ADDR
// animal := CreateHuman ;
83502: LD_ADDR_VAR 0 12
83506: PUSH
83507: CALL_OW 44
83511: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83512: LD_VAR 0 12
83516: PPUSH
83517: LD_VAR 0 8
83521: PPUSH
83522: LD_INT 0
83524: PPUSH
83525: CALL 85531 0 3
// end ;
83529: GO 83483
83531: POP
83532: POP
// if birds then
83533: LD_VAR 0 1
83537: IFFALSE 83604
// for i = 1 to birds do
83539: LD_ADDR_VAR 0 11
83543: PUSH
83544: DOUBLE
83545: LD_INT 1
83547: DEC
83548: ST_TO_ADDR
83549: LD_VAR 0 1
83553: PUSH
83554: FOR_TO
83555: IFFALSE 83602
// begin hc_class = 18 ;
83557: LD_ADDR_OWVAR 28
83561: PUSH
83562: LD_INT 18
83564: ST_TO_ADDR
// hc_gallery =  ;
83565: LD_ADDR_OWVAR 33
83569: PUSH
83570: LD_STRING 
83572: ST_TO_ADDR
// animal := CreateHuman ;
83573: LD_ADDR_VAR 0 12
83577: PUSH
83578: CALL_OW 44
83582: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83583: LD_VAR 0 12
83587: PPUSH
83588: LD_VAR 0 8
83592: PPUSH
83593: LD_INT 0
83595: PPUSH
83596: CALL 85531 0 3
// end ;
83600: GO 83554
83602: POP
83603: POP
// if tigers then
83604: LD_VAR 0 2
83608: IFFALSE 83692
// for i = 1 to tigers do
83610: LD_ADDR_VAR 0 11
83614: PUSH
83615: DOUBLE
83616: LD_INT 1
83618: DEC
83619: ST_TO_ADDR
83620: LD_VAR 0 2
83624: PUSH
83625: FOR_TO
83626: IFFALSE 83690
// begin hc_class = class_tiger ;
83628: LD_ADDR_OWVAR 28
83632: PUSH
83633: LD_INT 14
83635: ST_TO_ADDR
// hc_gallery =  ;
83636: LD_ADDR_OWVAR 33
83640: PUSH
83641: LD_STRING 
83643: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83644: LD_ADDR_OWVAR 35
83648: PUSH
83649: LD_INT 7
83651: NEG
83652: PPUSH
83653: LD_INT 7
83655: PPUSH
83656: CALL_OW 12
83660: ST_TO_ADDR
// animal := CreateHuman ;
83661: LD_ADDR_VAR 0 12
83665: PUSH
83666: CALL_OW 44
83670: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83671: LD_VAR 0 12
83675: PPUSH
83676: LD_VAR 0 8
83680: PPUSH
83681: LD_INT 0
83683: PPUSH
83684: CALL 85531 0 3
// end ;
83688: GO 83625
83690: POP
83691: POP
// if apemans then
83692: LD_VAR 0 3
83696: IFFALSE 83819
// for i = 1 to apemans do
83698: LD_ADDR_VAR 0 11
83702: PUSH
83703: DOUBLE
83704: LD_INT 1
83706: DEC
83707: ST_TO_ADDR
83708: LD_VAR 0 3
83712: PUSH
83713: FOR_TO
83714: IFFALSE 83817
// begin hc_class = class_apeman ;
83716: LD_ADDR_OWVAR 28
83720: PUSH
83721: LD_INT 12
83723: ST_TO_ADDR
// hc_gallery =  ;
83724: LD_ADDR_OWVAR 33
83728: PUSH
83729: LD_STRING 
83731: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
83732: LD_ADDR_OWVAR 35
83736: PUSH
83737: LD_INT 5
83739: NEG
83740: PPUSH
83741: LD_INT 5
83743: PPUSH
83744: CALL_OW 12
83748: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83749: LD_ADDR_OWVAR 31
83753: PUSH
83754: LD_INT 1
83756: PPUSH
83757: LD_INT 3
83759: PPUSH
83760: CALL_OW 12
83764: PUSH
83765: LD_INT 1
83767: PPUSH
83768: LD_INT 3
83770: PPUSH
83771: CALL_OW 12
83775: PUSH
83776: LD_INT 0
83778: PUSH
83779: LD_INT 0
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: ST_TO_ADDR
// animal := CreateHuman ;
83788: LD_ADDR_VAR 0 12
83792: PUSH
83793: CALL_OW 44
83797: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83798: LD_VAR 0 12
83802: PPUSH
83803: LD_VAR 0 8
83807: PPUSH
83808: LD_INT 0
83810: PPUSH
83811: CALL 85531 0 3
// end ;
83815: GO 83713
83817: POP
83818: POP
// if enchidnas then
83819: LD_VAR 0 4
83823: IFFALSE 83890
// for i = 1 to enchidnas do
83825: LD_ADDR_VAR 0 11
83829: PUSH
83830: DOUBLE
83831: LD_INT 1
83833: DEC
83834: ST_TO_ADDR
83835: LD_VAR 0 4
83839: PUSH
83840: FOR_TO
83841: IFFALSE 83888
// begin hc_class = 13 ;
83843: LD_ADDR_OWVAR 28
83847: PUSH
83848: LD_INT 13
83850: ST_TO_ADDR
// hc_gallery =  ;
83851: LD_ADDR_OWVAR 33
83855: PUSH
83856: LD_STRING 
83858: ST_TO_ADDR
// animal := CreateHuman ;
83859: LD_ADDR_VAR 0 12
83863: PUSH
83864: CALL_OW 44
83868: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83869: LD_VAR 0 12
83873: PPUSH
83874: LD_VAR 0 8
83878: PPUSH
83879: LD_INT 0
83881: PPUSH
83882: CALL 85531 0 3
// end ;
83886: GO 83840
83888: POP
83889: POP
// if fishes then
83890: LD_VAR 0 7
83894: IFFALSE 83961
// for i = 1 to fishes do
83896: LD_ADDR_VAR 0 11
83900: PUSH
83901: DOUBLE
83902: LD_INT 1
83904: DEC
83905: ST_TO_ADDR
83906: LD_VAR 0 7
83910: PUSH
83911: FOR_TO
83912: IFFALSE 83959
// begin hc_class = 20 ;
83914: LD_ADDR_OWVAR 28
83918: PUSH
83919: LD_INT 20
83921: ST_TO_ADDR
// hc_gallery =  ;
83922: LD_ADDR_OWVAR 33
83926: PUSH
83927: LD_STRING 
83929: ST_TO_ADDR
// animal := CreateHuman ;
83930: LD_ADDR_VAR 0 12
83934: PUSH
83935: CALL_OW 44
83939: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83940: LD_VAR 0 12
83944: PPUSH
83945: LD_VAR 0 9
83949: PPUSH
83950: LD_INT 0
83952: PPUSH
83953: CALL 85531 0 3
// end ;
83957: GO 83911
83959: POP
83960: POP
// end ;
83961: LD_VAR 0 10
83965: RET
// export function WantHeal ( sci , unit ) ; begin
83966: LD_INT 0
83968: PPUSH
// if GetTaskList ( sci ) > 0 then
83969: LD_VAR 0 1
83973: PPUSH
83974: CALL_OW 437
83978: PUSH
83979: LD_INT 0
83981: GREATER
83982: IFFALSE 84052
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83984: LD_VAR 0 1
83988: PPUSH
83989: CALL_OW 437
83993: PUSH
83994: LD_INT 1
83996: ARRAY
83997: PUSH
83998: LD_INT 1
84000: ARRAY
84001: PUSH
84002: LD_STRING l
84004: EQUAL
84005: PUSH
84006: LD_VAR 0 1
84010: PPUSH
84011: CALL_OW 437
84015: PUSH
84016: LD_INT 1
84018: ARRAY
84019: PUSH
84020: LD_INT 4
84022: ARRAY
84023: PUSH
84024: LD_VAR 0 2
84028: EQUAL
84029: AND
84030: IFFALSE 84042
// result := true else
84032: LD_ADDR_VAR 0 3
84036: PUSH
84037: LD_INT 1
84039: ST_TO_ADDR
84040: GO 84050
// result := false ;
84042: LD_ADDR_VAR 0 3
84046: PUSH
84047: LD_INT 0
84049: ST_TO_ADDR
// end else
84050: GO 84060
// result := false ;
84052: LD_ADDR_VAR 0 3
84056: PUSH
84057: LD_INT 0
84059: ST_TO_ADDR
// end ;
84060: LD_VAR 0 3
84064: RET
// export function HealTarget ( sci ) ; begin
84065: LD_INT 0
84067: PPUSH
// if not sci then
84068: LD_VAR 0 1
84072: NOT
84073: IFFALSE 84077
// exit ;
84075: GO 84142
// result := 0 ;
84077: LD_ADDR_VAR 0 2
84081: PUSH
84082: LD_INT 0
84084: ST_TO_ADDR
// if GetTaskList ( sci ) then
84085: LD_VAR 0 1
84089: PPUSH
84090: CALL_OW 437
84094: IFFALSE 84142
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84096: LD_VAR 0 1
84100: PPUSH
84101: CALL_OW 437
84105: PUSH
84106: LD_INT 1
84108: ARRAY
84109: PUSH
84110: LD_INT 1
84112: ARRAY
84113: PUSH
84114: LD_STRING l
84116: EQUAL
84117: IFFALSE 84142
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84119: LD_ADDR_VAR 0 2
84123: PUSH
84124: LD_VAR 0 1
84128: PPUSH
84129: CALL_OW 437
84133: PUSH
84134: LD_INT 1
84136: ARRAY
84137: PUSH
84138: LD_INT 4
84140: ARRAY
84141: ST_TO_ADDR
// end ;
84142: LD_VAR 0 2
84146: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84147: LD_INT 0
84149: PPUSH
84150: PPUSH
84151: PPUSH
84152: PPUSH
// if not base_units then
84153: LD_VAR 0 1
84157: NOT
84158: IFFALSE 84162
// exit ;
84160: GO 84249
// result := false ;
84162: LD_ADDR_VAR 0 2
84166: PUSH
84167: LD_INT 0
84169: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84170: LD_ADDR_VAR 0 5
84174: PUSH
84175: LD_VAR 0 1
84179: PPUSH
84180: LD_INT 21
84182: PUSH
84183: LD_INT 3
84185: PUSH
84186: EMPTY
84187: LIST
84188: LIST
84189: PPUSH
84190: CALL_OW 72
84194: ST_TO_ADDR
// if not tmp then
84195: LD_VAR 0 5
84199: NOT
84200: IFFALSE 84204
// exit ;
84202: GO 84249
// for i in tmp do
84204: LD_ADDR_VAR 0 3
84208: PUSH
84209: LD_VAR 0 5
84213: PUSH
84214: FOR_IN
84215: IFFALSE 84247
// begin result := EnemyInRange ( i , 22 ) ;
84217: LD_ADDR_VAR 0 2
84221: PUSH
84222: LD_VAR 0 3
84226: PPUSH
84227: LD_INT 22
84229: PPUSH
84230: CALL 82485 0 2
84234: ST_TO_ADDR
// if result then
84235: LD_VAR 0 2
84239: IFFALSE 84245
// exit ;
84241: POP
84242: POP
84243: GO 84249
// end ;
84245: GO 84214
84247: POP
84248: POP
// end ;
84249: LD_VAR 0 2
84253: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84254: LD_INT 0
84256: PPUSH
84257: PPUSH
// if not units then
84258: LD_VAR 0 1
84262: NOT
84263: IFFALSE 84267
// exit ;
84265: GO 84337
// result := [ ] ;
84267: LD_ADDR_VAR 0 3
84271: PUSH
84272: EMPTY
84273: ST_TO_ADDR
// for i in units do
84274: LD_ADDR_VAR 0 4
84278: PUSH
84279: LD_VAR 0 1
84283: PUSH
84284: FOR_IN
84285: IFFALSE 84335
// if GetTag ( i ) = tag then
84287: LD_VAR 0 4
84291: PPUSH
84292: CALL_OW 110
84296: PUSH
84297: LD_VAR 0 2
84301: EQUAL
84302: IFFALSE 84333
// result := Insert ( result , result + 1 , i ) ;
84304: LD_ADDR_VAR 0 3
84308: PUSH
84309: LD_VAR 0 3
84313: PPUSH
84314: LD_VAR 0 3
84318: PUSH
84319: LD_INT 1
84321: PLUS
84322: PPUSH
84323: LD_VAR 0 4
84327: PPUSH
84328: CALL_OW 2
84332: ST_TO_ADDR
84333: GO 84284
84335: POP
84336: POP
// end ;
84337: LD_VAR 0 3
84341: RET
// export function IsDriver ( un ) ; begin
84342: LD_INT 0
84344: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84345: LD_ADDR_VAR 0 2
84349: PUSH
84350: LD_VAR 0 1
84354: PUSH
84355: LD_INT 55
84357: PUSH
84358: EMPTY
84359: LIST
84360: PPUSH
84361: CALL_OW 69
84365: IN
84366: ST_TO_ADDR
// end ;
84367: LD_VAR 0 2
84371: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84372: LD_INT 0
84374: PPUSH
84375: PPUSH
// list := [ ] ;
84376: LD_ADDR_VAR 0 5
84380: PUSH
84381: EMPTY
84382: ST_TO_ADDR
// case d of 0 :
84383: LD_VAR 0 3
84387: PUSH
84388: LD_INT 0
84390: DOUBLE
84391: EQUAL
84392: IFTRUE 84396
84394: GO 84529
84396: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84397: LD_ADDR_VAR 0 5
84401: PUSH
84402: LD_VAR 0 1
84406: PUSH
84407: LD_INT 4
84409: MINUS
84410: PUSH
84411: LD_VAR 0 2
84415: PUSH
84416: LD_INT 4
84418: MINUS
84419: PUSH
84420: LD_INT 2
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: LIST
84427: PUSH
84428: LD_VAR 0 1
84432: PUSH
84433: LD_INT 3
84435: MINUS
84436: PUSH
84437: LD_VAR 0 2
84441: PUSH
84442: LD_INT 1
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: LIST
84449: PUSH
84450: LD_VAR 0 1
84454: PUSH
84455: LD_INT 4
84457: PLUS
84458: PUSH
84459: LD_VAR 0 2
84463: PUSH
84464: LD_INT 4
84466: PUSH
84467: EMPTY
84468: LIST
84469: LIST
84470: LIST
84471: PUSH
84472: LD_VAR 0 1
84476: PUSH
84477: LD_INT 3
84479: PLUS
84480: PUSH
84481: LD_VAR 0 2
84485: PUSH
84486: LD_INT 3
84488: PLUS
84489: PUSH
84490: LD_INT 5
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: LIST
84497: PUSH
84498: LD_VAR 0 1
84502: PUSH
84503: LD_VAR 0 2
84507: PUSH
84508: LD_INT 4
84510: PLUS
84511: PUSH
84512: LD_INT 0
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: LIST
84519: PUSH
84520: EMPTY
84521: LIST
84522: LIST
84523: LIST
84524: LIST
84525: LIST
84526: ST_TO_ADDR
// end ; 1 :
84527: GO 85227
84529: LD_INT 1
84531: DOUBLE
84532: EQUAL
84533: IFTRUE 84537
84535: GO 84670
84537: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84538: LD_ADDR_VAR 0 5
84542: PUSH
84543: LD_VAR 0 1
84547: PUSH
84548: LD_VAR 0 2
84552: PUSH
84553: LD_INT 4
84555: MINUS
84556: PUSH
84557: LD_INT 3
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: LIST
84564: PUSH
84565: LD_VAR 0 1
84569: PUSH
84570: LD_INT 3
84572: MINUS
84573: PUSH
84574: LD_VAR 0 2
84578: PUSH
84579: LD_INT 3
84581: MINUS
84582: PUSH
84583: LD_INT 2
84585: PUSH
84586: EMPTY
84587: LIST
84588: LIST
84589: LIST
84590: PUSH
84591: LD_VAR 0 1
84595: PUSH
84596: LD_INT 4
84598: MINUS
84599: PUSH
84600: LD_VAR 0 2
84604: PUSH
84605: LD_INT 1
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: LIST
84612: PUSH
84613: LD_VAR 0 1
84617: PUSH
84618: LD_VAR 0 2
84622: PUSH
84623: LD_INT 3
84625: PLUS
84626: PUSH
84627: LD_INT 0
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: LIST
84634: PUSH
84635: LD_VAR 0 1
84639: PUSH
84640: LD_INT 4
84642: PLUS
84643: PUSH
84644: LD_VAR 0 2
84648: PUSH
84649: LD_INT 4
84651: PLUS
84652: PUSH
84653: LD_INT 5
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: LIST
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: ST_TO_ADDR
// end ; 2 :
84668: GO 85227
84670: LD_INT 2
84672: DOUBLE
84673: EQUAL
84674: IFTRUE 84678
84676: GO 84807
84678: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84679: LD_ADDR_VAR 0 5
84683: PUSH
84684: LD_VAR 0 1
84688: PUSH
84689: LD_VAR 0 2
84693: PUSH
84694: LD_INT 3
84696: MINUS
84697: PUSH
84698: LD_INT 3
84700: PUSH
84701: EMPTY
84702: LIST
84703: LIST
84704: LIST
84705: PUSH
84706: LD_VAR 0 1
84710: PUSH
84711: LD_INT 4
84713: PLUS
84714: PUSH
84715: LD_VAR 0 2
84719: PUSH
84720: LD_INT 4
84722: PUSH
84723: EMPTY
84724: LIST
84725: LIST
84726: LIST
84727: PUSH
84728: LD_VAR 0 1
84732: PUSH
84733: LD_VAR 0 2
84737: PUSH
84738: LD_INT 4
84740: PLUS
84741: PUSH
84742: LD_INT 0
84744: PUSH
84745: EMPTY
84746: LIST
84747: LIST
84748: LIST
84749: PUSH
84750: LD_VAR 0 1
84754: PUSH
84755: LD_INT 3
84757: MINUS
84758: PUSH
84759: LD_VAR 0 2
84763: PUSH
84764: LD_INT 1
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: LIST
84771: PUSH
84772: LD_VAR 0 1
84776: PUSH
84777: LD_INT 4
84779: MINUS
84780: PUSH
84781: LD_VAR 0 2
84785: PUSH
84786: LD_INT 4
84788: MINUS
84789: PUSH
84790: LD_INT 2
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: LIST
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: LIST
84804: ST_TO_ADDR
// end ; 3 :
84805: GO 85227
84807: LD_INT 3
84809: DOUBLE
84810: EQUAL
84811: IFTRUE 84815
84813: GO 84948
84815: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84816: LD_ADDR_VAR 0 5
84820: PUSH
84821: LD_VAR 0 1
84825: PUSH
84826: LD_INT 3
84828: PLUS
84829: PUSH
84830: LD_VAR 0 2
84834: PUSH
84835: LD_INT 4
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: LIST
84842: PUSH
84843: LD_VAR 0 1
84847: PUSH
84848: LD_INT 4
84850: PLUS
84851: PUSH
84852: LD_VAR 0 2
84856: PUSH
84857: LD_INT 4
84859: PLUS
84860: PUSH
84861: LD_INT 5
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: LIST
84868: PUSH
84869: LD_VAR 0 1
84873: PUSH
84874: LD_INT 4
84876: MINUS
84877: PUSH
84878: LD_VAR 0 2
84882: PUSH
84883: LD_INT 1
84885: PUSH
84886: EMPTY
84887: LIST
84888: LIST
84889: LIST
84890: PUSH
84891: LD_VAR 0 1
84895: PUSH
84896: LD_VAR 0 2
84900: PUSH
84901: LD_INT 4
84903: MINUS
84904: PUSH
84905: LD_INT 3
84907: PUSH
84908: EMPTY
84909: LIST
84910: LIST
84911: LIST
84912: PUSH
84913: LD_VAR 0 1
84917: PUSH
84918: LD_INT 3
84920: MINUS
84921: PUSH
84922: LD_VAR 0 2
84926: PUSH
84927: LD_INT 3
84929: MINUS
84930: PUSH
84931: LD_INT 2
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: LIST
84938: PUSH
84939: EMPTY
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: ST_TO_ADDR
// end ; 4 :
84946: GO 85227
84948: LD_INT 4
84950: DOUBLE
84951: EQUAL
84952: IFTRUE 84956
84954: GO 85089
84956: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84957: LD_ADDR_VAR 0 5
84961: PUSH
84962: LD_VAR 0 1
84966: PUSH
84967: LD_VAR 0 2
84971: PUSH
84972: LD_INT 4
84974: PLUS
84975: PUSH
84976: LD_INT 0
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: LIST
84983: PUSH
84984: LD_VAR 0 1
84988: PUSH
84989: LD_INT 3
84991: PLUS
84992: PUSH
84993: LD_VAR 0 2
84997: PUSH
84998: LD_INT 3
85000: PLUS
85001: PUSH
85002: LD_INT 5
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: LIST
85009: PUSH
85010: LD_VAR 0 1
85014: PUSH
85015: LD_INT 4
85017: PLUS
85018: PUSH
85019: LD_VAR 0 2
85023: PUSH
85024: LD_INT 4
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: LIST
85031: PUSH
85032: LD_VAR 0 1
85036: PUSH
85037: LD_VAR 0 2
85041: PUSH
85042: LD_INT 3
85044: MINUS
85045: PUSH
85046: LD_INT 3
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: LIST
85053: PUSH
85054: LD_VAR 0 1
85058: PUSH
85059: LD_INT 4
85061: MINUS
85062: PUSH
85063: LD_VAR 0 2
85067: PUSH
85068: LD_INT 4
85070: MINUS
85071: PUSH
85072: LD_INT 2
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: LIST
85079: PUSH
85080: EMPTY
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: ST_TO_ADDR
// end ; 5 :
85087: GO 85227
85089: LD_INT 5
85091: DOUBLE
85092: EQUAL
85093: IFTRUE 85097
85095: GO 85226
85097: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85098: LD_ADDR_VAR 0 5
85102: PUSH
85103: LD_VAR 0 1
85107: PUSH
85108: LD_INT 4
85110: MINUS
85111: PUSH
85112: LD_VAR 0 2
85116: PUSH
85117: LD_INT 1
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: LIST
85124: PUSH
85125: LD_VAR 0 1
85129: PUSH
85130: LD_VAR 0 2
85134: PUSH
85135: LD_INT 4
85137: MINUS
85138: PUSH
85139: LD_INT 3
85141: PUSH
85142: EMPTY
85143: LIST
85144: LIST
85145: LIST
85146: PUSH
85147: LD_VAR 0 1
85151: PUSH
85152: LD_INT 4
85154: PLUS
85155: PUSH
85156: LD_VAR 0 2
85160: PUSH
85161: LD_INT 4
85163: PLUS
85164: PUSH
85165: LD_INT 5
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: LIST
85172: PUSH
85173: LD_VAR 0 1
85177: PUSH
85178: LD_INT 3
85180: PLUS
85181: PUSH
85182: LD_VAR 0 2
85186: PUSH
85187: LD_INT 4
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: LIST
85194: PUSH
85195: LD_VAR 0 1
85199: PUSH
85200: LD_VAR 0 2
85204: PUSH
85205: LD_INT 3
85207: PLUS
85208: PUSH
85209: LD_INT 0
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: LIST
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: ST_TO_ADDR
// end ; end ;
85224: GO 85227
85226: POP
// result := list ;
85227: LD_ADDR_VAR 0 4
85231: PUSH
85232: LD_VAR 0 5
85236: ST_TO_ADDR
// end ;
85237: LD_VAR 0 4
85241: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85242: LD_INT 0
85244: PPUSH
85245: PPUSH
85246: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85247: LD_VAR 0 1
85251: NOT
85252: PUSH
85253: LD_VAR 0 2
85257: PUSH
85258: LD_INT 1
85260: PUSH
85261: LD_INT 2
85263: PUSH
85264: LD_INT 3
85266: PUSH
85267: LD_INT 4
85269: PUSH
85270: EMPTY
85271: LIST
85272: LIST
85273: LIST
85274: LIST
85275: IN
85276: NOT
85277: OR
85278: IFFALSE 85282
// exit ;
85280: GO 85374
// tmp := [ ] ;
85282: LD_ADDR_VAR 0 5
85286: PUSH
85287: EMPTY
85288: ST_TO_ADDR
// for i in units do
85289: LD_ADDR_VAR 0 4
85293: PUSH
85294: LD_VAR 0 1
85298: PUSH
85299: FOR_IN
85300: IFFALSE 85343
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85302: LD_ADDR_VAR 0 5
85306: PUSH
85307: LD_VAR 0 5
85311: PPUSH
85312: LD_VAR 0 5
85316: PUSH
85317: LD_INT 1
85319: PLUS
85320: PPUSH
85321: LD_VAR 0 4
85325: PPUSH
85326: LD_VAR 0 2
85330: PPUSH
85331: CALL_OW 259
85335: PPUSH
85336: CALL_OW 2
85340: ST_TO_ADDR
85341: GO 85299
85343: POP
85344: POP
// if not tmp then
85345: LD_VAR 0 5
85349: NOT
85350: IFFALSE 85354
// exit ;
85352: GO 85374
// result := SortListByListDesc ( units , tmp ) ;
85354: LD_ADDR_VAR 0 3
85358: PUSH
85359: LD_VAR 0 1
85363: PPUSH
85364: LD_VAR 0 5
85368: PPUSH
85369: CALL_OW 77
85373: ST_TO_ADDR
// end ;
85374: LD_VAR 0 3
85378: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85379: LD_INT 0
85381: PPUSH
85382: PPUSH
85383: PPUSH
// x := GetX ( building ) ;
85384: LD_ADDR_VAR 0 4
85388: PUSH
85389: LD_VAR 0 2
85393: PPUSH
85394: CALL_OW 250
85398: ST_TO_ADDR
// y := GetY ( building ) ;
85399: LD_ADDR_VAR 0 5
85403: PUSH
85404: LD_VAR 0 2
85408: PPUSH
85409: CALL_OW 251
85413: ST_TO_ADDR
// if GetTaskList ( unit ) then
85414: LD_VAR 0 1
85418: PPUSH
85419: CALL_OW 437
85423: IFFALSE 85518
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85425: LD_STRING e
85427: PUSH
85428: LD_VAR 0 1
85432: PPUSH
85433: CALL_OW 437
85437: PUSH
85438: LD_INT 1
85440: ARRAY
85441: PUSH
85442: LD_INT 1
85444: ARRAY
85445: EQUAL
85446: PUSH
85447: LD_VAR 0 4
85451: PUSH
85452: LD_VAR 0 1
85456: PPUSH
85457: CALL_OW 437
85461: PUSH
85462: LD_INT 1
85464: ARRAY
85465: PUSH
85466: LD_INT 2
85468: ARRAY
85469: EQUAL
85470: AND
85471: PUSH
85472: LD_VAR 0 5
85476: PUSH
85477: LD_VAR 0 1
85481: PPUSH
85482: CALL_OW 437
85486: PUSH
85487: LD_INT 1
85489: ARRAY
85490: PUSH
85491: LD_INT 3
85493: ARRAY
85494: EQUAL
85495: AND
85496: IFFALSE 85508
// result := true else
85498: LD_ADDR_VAR 0 3
85502: PUSH
85503: LD_INT 1
85505: ST_TO_ADDR
85506: GO 85516
// result := false ;
85508: LD_ADDR_VAR 0 3
85512: PUSH
85513: LD_INT 0
85515: ST_TO_ADDR
// end else
85516: GO 85526
// result := false ;
85518: LD_ADDR_VAR 0 3
85522: PUSH
85523: LD_INT 0
85525: ST_TO_ADDR
// end ;
85526: LD_VAR 0 3
85530: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85531: LD_INT 0
85533: PPUSH
85534: PPUSH
85535: PPUSH
85536: PPUSH
// if not unit or not area then
85537: LD_VAR 0 1
85541: NOT
85542: PUSH
85543: LD_VAR 0 2
85547: NOT
85548: OR
85549: IFFALSE 85553
// exit ;
85551: GO 85717
// tmp := AreaToList ( area , i ) ;
85553: LD_ADDR_VAR 0 6
85557: PUSH
85558: LD_VAR 0 2
85562: PPUSH
85563: LD_VAR 0 5
85567: PPUSH
85568: CALL_OW 517
85572: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85573: LD_ADDR_VAR 0 5
85577: PUSH
85578: DOUBLE
85579: LD_INT 1
85581: DEC
85582: ST_TO_ADDR
85583: LD_VAR 0 6
85587: PUSH
85588: LD_INT 1
85590: ARRAY
85591: PUSH
85592: FOR_TO
85593: IFFALSE 85715
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85595: LD_ADDR_VAR 0 7
85599: PUSH
85600: LD_VAR 0 6
85604: PUSH
85605: LD_INT 1
85607: ARRAY
85608: PUSH
85609: LD_VAR 0 5
85613: ARRAY
85614: PUSH
85615: LD_VAR 0 6
85619: PUSH
85620: LD_INT 2
85622: ARRAY
85623: PUSH
85624: LD_VAR 0 5
85628: ARRAY
85629: PUSH
85630: EMPTY
85631: LIST
85632: LIST
85633: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85634: LD_VAR 0 7
85638: PUSH
85639: LD_INT 1
85641: ARRAY
85642: PPUSH
85643: LD_VAR 0 7
85647: PUSH
85648: LD_INT 2
85650: ARRAY
85651: PPUSH
85652: CALL_OW 428
85656: PUSH
85657: LD_INT 0
85659: EQUAL
85660: IFFALSE 85713
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85662: LD_VAR 0 1
85666: PPUSH
85667: LD_VAR 0 7
85671: PUSH
85672: LD_INT 1
85674: ARRAY
85675: PPUSH
85676: LD_VAR 0 7
85680: PUSH
85681: LD_INT 2
85683: ARRAY
85684: PPUSH
85685: LD_VAR 0 3
85689: PPUSH
85690: CALL_OW 48
// result := IsPlaced ( unit ) ;
85694: LD_ADDR_VAR 0 4
85698: PUSH
85699: LD_VAR 0 1
85703: PPUSH
85704: CALL_OW 305
85708: ST_TO_ADDR
// exit ;
85709: POP
85710: POP
85711: GO 85717
// end ; end ;
85713: GO 85592
85715: POP
85716: POP
// end ;
85717: LD_VAR 0 4
85721: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85722: LD_INT 0
85724: PPUSH
85725: PPUSH
85726: PPUSH
// if not side or side > 8 then
85727: LD_VAR 0 1
85731: NOT
85732: PUSH
85733: LD_VAR 0 1
85737: PUSH
85738: LD_INT 8
85740: GREATER
85741: OR
85742: IFFALSE 85746
// exit ;
85744: GO 85933
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85746: LD_ADDR_VAR 0 4
85750: PUSH
85751: LD_INT 22
85753: PUSH
85754: LD_VAR 0 1
85758: PUSH
85759: EMPTY
85760: LIST
85761: LIST
85762: PUSH
85763: LD_INT 21
85765: PUSH
85766: LD_INT 3
85768: PUSH
85769: EMPTY
85770: LIST
85771: LIST
85772: PUSH
85773: EMPTY
85774: LIST
85775: LIST
85776: PPUSH
85777: CALL_OW 69
85781: ST_TO_ADDR
// if not tmp then
85782: LD_VAR 0 4
85786: NOT
85787: IFFALSE 85791
// exit ;
85789: GO 85933
// enable_addtolog := true ;
85791: LD_ADDR_OWVAR 81
85795: PUSH
85796: LD_INT 1
85798: ST_TO_ADDR
// AddToLog ( [ ) ;
85799: LD_STRING [
85801: PPUSH
85802: CALL_OW 561
// for i in tmp do
85806: LD_ADDR_VAR 0 3
85810: PUSH
85811: LD_VAR 0 4
85815: PUSH
85816: FOR_IN
85817: IFFALSE 85924
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85819: LD_STRING [
85821: PUSH
85822: LD_VAR 0 3
85826: PPUSH
85827: CALL_OW 266
85831: STR
85832: PUSH
85833: LD_STRING , 
85835: STR
85836: PUSH
85837: LD_VAR 0 3
85841: PPUSH
85842: CALL_OW 250
85846: STR
85847: PUSH
85848: LD_STRING , 
85850: STR
85851: PUSH
85852: LD_VAR 0 3
85856: PPUSH
85857: CALL_OW 251
85861: STR
85862: PUSH
85863: LD_STRING , 
85865: STR
85866: PUSH
85867: LD_VAR 0 3
85871: PPUSH
85872: CALL_OW 254
85876: STR
85877: PUSH
85878: LD_STRING , 
85880: STR
85881: PUSH
85882: LD_VAR 0 3
85886: PPUSH
85887: LD_INT 1
85889: PPUSH
85890: CALL_OW 268
85894: STR
85895: PUSH
85896: LD_STRING , 
85898: STR
85899: PUSH
85900: LD_VAR 0 3
85904: PPUSH
85905: LD_INT 2
85907: PPUSH
85908: CALL_OW 268
85912: STR
85913: PUSH
85914: LD_STRING ],
85916: STR
85917: PPUSH
85918: CALL_OW 561
// end ;
85922: GO 85816
85924: POP
85925: POP
// AddToLog ( ]; ) ;
85926: LD_STRING ];
85928: PPUSH
85929: CALL_OW 561
// end ;
85933: LD_VAR 0 2
85937: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85938: LD_INT 0
85940: PPUSH
85941: PPUSH
85942: PPUSH
85943: PPUSH
85944: PPUSH
// if not area or not rate or not max then
85945: LD_VAR 0 1
85949: NOT
85950: PUSH
85951: LD_VAR 0 2
85955: NOT
85956: OR
85957: PUSH
85958: LD_VAR 0 4
85962: NOT
85963: OR
85964: IFFALSE 85968
// exit ;
85966: GO 86160
// while 1 do
85968: LD_INT 1
85970: IFFALSE 86160
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85972: LD_ADDR_VAR 0 9
85976: PUSH
85977: LD_VAR 0 1
85981: PPUSH
85982: LD_INT 1
85984: PPUSH
85985: CALL_OW 287
85989: PUSH
85990: LD_INT 10
85992: MUL
85993: ST_TO_ADDR
// r := rate / 10 ;
85994: LD_ADDR_VAR 0 7
85998: PUSH
85999: LD_VAR 0 2
86003: PUSH
86004: LD_INT 10
86006: DIVREAL
86007: ST_TO_ADDR
// time := 1 1$00 ;
86008: LD_ADDR_VAR 0 8
86012: PUSH
86013: LD_INT 2100
86015: ST_TO_ADDR
// if amount < min then
86016: LD_VAR 0 9
86020: PUSH
86021: LD_VAR 0 3
86025: LESS
86026: IFFALSE 86044
// r := r * 2 else
86028: LD_ADDR_VAR 0 7
86032: PUSH
86033: LD_VAR 0 7
86037: PUSH
86038: LD_INT 2
86040: MUL
86041: ST_TO_ADDR
86042: GO 86070
// if amount > max then
86044: LD_VAR 0 9
86048: PUSH
86049: LD_VAR 0 4
86053: GREATER
86054: IFFALSE 86070
// r := r / 2 ;
86056: LD_ADDR_VAR 0 7
86060: PUSH
86061: LD_VAR 0 7
86065: PUSH
86066: LD_INT 2
86068: DIVREAL
86069: ST_TO_ADDR
// time := time / r ;
86070: LD_ADDR_VAR 0 8
86074: PUSH
86075: LD_VAR 0 8
86079: PUSH
86080: LD_VAR 0 7
86084: DIVREAL
86085: ST_TO_ADDR
// if time < 0 then
86086: LD_VAR 0 8
86090: PUSH
86091: LD_INT 0
86093: LESS
86094: IFFALSE 86111
// time := time * - 1 ;
86096: LD_ADDR_VAR 0 8
86100: PUSH
86101: LD_VAR 0 8
86105: PUSH
86106: LD_INT 1
86108: NEG
86109: MUL
86110: ST_TO_ADDR
// wait ( time ) ;
86111: LD_VAR 0 8
86115: PPUSH
86116: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
86120: LD_INT 35
86122: PPUSH
86123: LD_INT 875
86125: PPUSH
86126: CALL_OW 12
86130: PPUSH
86131: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86135: LD_INT 1
86137: PPUSH
86138: LD_INT 5
86140: PPUSH
86141: CALL_OW 12
86145: PPUSH
86146: LD_VAR 0 1
86150: PPUSH
86151: LD_INT 1
86153: PPUSH
86154: CALL_OW 55
// end ;
86158: GO 85968
// end ;
86160: LD_VAR 0 5
86164: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86165: LD_INT 0
86167: PPUSH
86168: PPUSH
86169: PPUSH
86170: PPUSH
86171: PPUSH
86172: PPUSH
86173: PPUSH
86174: PPUSH
// if not turrets or not factories then
86175: LD_VAR 0 1
86179: NOT
86180: PUSH
86181: LD_VAR 0 2
86185: NOT
86186: OR
86187: IFFALSE 86191
// exit ;
86189: GO 86498
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86191: LD_ADDR_VAR 0 10
86195: PUSH
86196: LD_INT 5
86198: PUSH
86199: LD_INT 6
86201: PUSH
86202: EMPTY
86203: LIST
86204: LIST
86205: PUSH
86206: LD_INT 2
86208: PUSH
86209: LD_INT 4
86211: PUSH
86212: EMPTY
86213: LIST
86214: LIST
86215: PUSH
86216: LD_INT 3
86218: PUSH
86219: LD_INT 5
86221: PUSH
86222: EMPTY
86223: LIST
86224: LIST
86225: PUSH
86226: EMPTY
86227: LIST
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 24
86233: PUSH
86234: LD_INT 25
86236: PUSH
86237: EMPTY
86238: LIST
86239: LIST
86240: PUSH
86241: LD_INT 23
86243: PUSH
86244: LD_INT 27
86246: PUSH
86247: EMPTY
86248: LIST
86249: LIST
86250: PUSH
86251: EMPTY
86252: LIST
86253: LIST
86254: PUSH
86255: LD_INT 42
86257: PUSH
86258: LD_INT 43
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: PUSH
86265: LD_INT 44
86267: PUSH
86268: LD_INT 46
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 45
86277: PUSH
86278: LD_INT 47
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: LIST
86289: PUSH
86290: EMPTY
86291: LIST
86292: LIST
86293: LIST
86294: ST_TO_ADDR
// result := [ ] ;
86295: LD_ADDR_VAR 0 3
86299: PUSH
86300: EMPTY
86301: ST_TO_ADDR
// for i in turrets do
86302: LD_ADDR_VAR 0 4
86306: PUSH
86307: LD_VAR 0 1
86311: PUSH
86312: FOR_IN
86313: IFFALSE 86496
// begin nat := GetNation ( i ) ;
86315: LD_ADDR_VAR 0 7
86319: PUSH
86320: LD_VAR 0 4
86324: PPUSH
86325: CALL_OW 248
86329: ST_TO_ADDR
// weapon := 0 ;
86330: LD_ADDR_VAR 0 8
86334: PUSH
86335: LD_INT 0
86337: ST_TO_ADDR
// if not nat then
86338: LD_VAR 0 7
86342: NOT
86343: IFFALSE 86347
// continue ;
86345: GO 86312
// for j in list [ nat ] do
86347: LD_ADDR_VAR 0 5
86351: PUSH
86352: LD_VAR 0 10
86356: PUSH
86357: LD_VAR 0 7
86361: ARRAY
86362: PUSH
86363: FOR_IN
86364: IFFALSE 86405
// if GetBWeapon ( i ) = j [ 1 ] then
86366: LD_VAR 0 4
86370: PPUSH
86371: CALL_OW 269
86375: PUSH
86376: LD_VAR 0 5
86380: PUSH
86381: LD_INT 1
86383: ARRAY
86384: EQUAL
86385: IFFALSE 86403
// begin weapon := j [ 2 ] ;
86387: LD_ADDR_VAR 0 8
86391: PUSH
86392: LD_VAR 0 5
86396: PUSH
86397: LD_INT 2
86399: ARRAY
86400: ST_TO_ADDR
// break ;
86401: GO 86405
// end ;
86403: GO 86363
86405: POP
86406: POP
// if not weapon then
86407: LD_VAR 0 8
86411: NOT
86412: IFFALSE 86416
// continue ;
86414: GO 86312
// for k in factories do
86416: LD_ADDR_VAR 0 6
86420: PUSH
86421: LD_VAR 0 2
86425: PUSH
86426: FOR_IN
86427: IFFALSE 86492
// begin weapons := AvailableWeaponList ( k ) ;
86429: LD_ADDR_VAR 0 9
86433: PUSH
86434: LD_VAR 0 6
86438: PPUSH
86439: CALL_OW 478
86443: ST_TO_ADDR
// if not weapons then
86444: LD_VAR 0 9
86448: NOT
86449: IFFALSE 86453
// continue ;
86451: GO 86426
// if weapon in weapons then
86453: LD_VAR 0 8
86457: PUSH
86458: LD_VAR 0 9
86462: IN
86463: IFFALSE 86490
// begin result := [ i , weapon ] ;
86465: LD_ADDR_VAR 0 3
86469: PUSH
86470: LD_VAR 0 4
86474: PUSH
86475: LD_VAR 0 8
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: ST_TO_ADDR
// exit ;
86484: POP
86485: POP
86486: POP
86487: POP
86488: GO 86498
// end ; end ;
86490: GO 86426
86492: POP
86493: POP
// end ;
86494: GO 86312
86496: POP
86497: POP
// end ;
86498: LD_VAR 0 3
86502: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86503: LD_INT 0
86505: PPUSH
// if not side or side > 8 then
86506: LD_VAR 0 3
86510: NOT
86511: PUSH
86512: LD_VAR 0 3
86516: PUSH
86517: LD_INT 8
86519: GREATER
86520: OR
86521: IFFALSE 86525
// exit ;
86523: GO 86584
// if not range then
86525: LD_VAR 0 4
86529: NOT
86530: IFFALSE 86541
// range := - 12 ;
86532: LD_ADDR_VAR 0 4
86536: PUSH
86537: LD_INT 12
86539: NEG
86540: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86541: LD_VAR 0 1
86545: PPUSH
86546: LD_VAR 0 2
86550: PPUSH
86551: LD_VAR 0 3
86555: PPUSH
86556: LD_VAR 0 4
86560: PPUSH
86561: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86565: LD_VAR 0 1
86569: PPUSH
86570: LD_VAR 0 2
86574: PPUSH
86575: LD_VAR 0 3
86579: PPUSH
86580: CALL_OW 331
// end ;
86584: LD_VAR 0 5
86588: RET
// export function Video ( mode ) ; begin
86589: LD_INT 0
86591: PPUSH
// ingame_video = mode ;
86592: LD_ADDR_OWVAR 52
86596: PUSH
86597: LD_VAR 0 1
86601: ST_TO_ADDR
// interface_hidden = mode ;
86602: LD_ADDR_OWVAR 54
86606: PUSH
86607: LD_VAR 0 1
86611: ST_TO_ADDR
// end ;
86612: LD_VAR 0 2
86616: RET
// export function Join ( array , element ) ; begin
86617: LD_INT 0
86619: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86620: LD_ADDR_VAR 0 3
86624: PUSH
86625: LD_VAR 0 1
86629: PPUSH
86630: LD_VAR 0 1
86634: PUSH
86635: LD_INT 1
86637: PLUS
86638: PPUSH
86639: LD_VAR 0 2
86643: PPUSH
86644: CALL_OW 1
86648: ST_TO_ADDR
// end ;
86649: LD_VAR 0 3
86653: RET
// export function JoinUnion ( array , element ) ; begin
86654: LD_INT 0
86656: PPUSH
// result := array union element ;
86657: LD_ADDR_VAR 0 3
86661: PUSH
86662: LD_VAR 0 1
86666: PUSH
86667: LD_VAR 0 2
86671: UNION
86672: ST_TO_ADDR
// end ;
86673: LD_VAR 0 3
86677: RET
// export function GetBehemoths ( side ) ; begin
86678: LD_INT 0
86680: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
86681: LD_ADDR_VAR 0 2
86685: PUSH
86686: LD_INT 22
86688: PUSH
86689: LD_VAR 0 1
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 31
86700: PUSH
86701: LD_INT 25
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: PPUSH
86712: CALL_OW 69
86716: ST_TO_ADDR
// end ;
86717: LD_VAR 0 2
86721: RET
// export function Shuffle ( array ) ; var i , index ; begin
86722: LD_INT 0
86724: PPUSH
86725: PPUSH
86726: PPUSH
// result := [ ] ;
86727: LD_ADDR_VAR 0 2
86731: PUSH
86732: EMPTY
86733: ST_TO_ADDR
// if not array then
86734: LD_VAR 0 1
86738: NOT
86739: IFFALSE 86743
// exit ;
86741: GO 86842
// Randomize ;
86743: CALL_OW 10
// for i = array downto 1 do
86747: LD_ADDR_VAR 0 3
86751: PUSH
86752: DOUBLE
86753: LD_VAR 0 1
86757: INC
86758: ST_TO_ADDR
86759: LD_INT 1
86761: PUSH
86762: FOR_DOWNTO
86763: IFFALSE 86840
// begin index := rand ( 1 , array ) ;
86765: LD_ADDR_VAR 0 4
86769: PUSH
86770: LD_INT 1
86772: PPUSH
86773: LD_VAR 0 1
86777: PPUSH
86778: CALL_OW 12
86782: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86783: LD_ADDR_VAR 0 2
86787: PUSH
86788: LD_VAR 0 2
86792: PPUSH
86793: LD_VAR 0 2
86797: PUSH
86798: LD_INT 1
86800: PLUS
86801: PPUSH
86802: LD_VAR 0 1
86806: PUSH
86807: LD_VAR 0 4
86811: ARRAY
86812: PPUSH
86813: CALL_OW 2
86817: ST_TO_ADDR
// array := Delete ( array , index ) ;
86818: LD_ADDR_VAR 0 1
86822: PUSH
86823: LD_VAR 0 1
86827: PPUSH
86828: LD_VAR 0 4
86832: PPUSH
86833: CALL_OW 3
86837: ST_TO_ADDR
// end ;
86838: GO 86762
86840: POP
86841: POP
// end ;
86842: LD_VAR 0 2
86846: RET
// export function GetBaseMaterials ( base ) ; begin
86847: LD_INT 0
86849: PPUSH
// result := [ 0 , 0 , 0 ] ;
86850: LD_ADDR_VAR 0 2
86854: PUSH
86855: LD_INT 0
86857: PUSH
86858: LD_INT 0
86860: PUSH
86861: LD_INT 0
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: LIST
86868: ST_TO_ADDR
// if not base then
86869: LD_VAR 0 1
86873: NOT
86874: IFFALSE 86878
// exit ;
86876: GO 86927
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86878: LD_ADDR_VAR 0 2
86882: PUSH
86883: LD_VAR 0 1
86887: PPUSH
86888: LD_INT 1
86890: PPUSH
86891: CALL_OW 275
86895: PUSH
86896: LD_VAR 0 1
86900: PPUSH
86901: LD_INT 2
86903: PPUSH
86904: CALL_OW 275
86908: PUSH
86909: LD_VAR 0 1
86913: PPUSH
86914: LD_INT 3
86916: PPUSH
86917: CALL_OW 275
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: LIST
86926: ST_TO_ADDR
// end ;
86927: LD_VAR 0 2
86931: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86932: LD_INT 0
86934: PPUSH
86935: PPUSH
// result := array ;
86936: LD_ADDR_VAR 0 3
86940: PUSH
86941: LD_VAR 0 1
86945: ST_TO_ADDR
// if size > 0 then
86946: LD_VAR 0 2
86950: PUSH
86951: LD_INT 0
86953: GREATER
86954: IFFALSE 87000
// for i := array downto size do
86956: LD_ADDR_VAR 0 4
86960: PUSH
86961: DOUBLE
86962: LD_VAR 0 1
86966: INC
86967: ST_TO_ADDR
86968: LD_VAR 0 2
86972: PUSH
86973: FOR_DOWNTO
86974: IFFALSE 86998
// result := Delete ( result , result ) ;
86976: LD_ADDR_VAR 0 3
86980: PUSH
86981: LD_VAR 0 3
86985: PPUSH
86986: LD_VAR 0 3
86990: PPUSH
86991: CALL_OW 3
86995: ST_TO_ADDR
86996: GO 86973
86998: POP
86999: POP
// end ;
87000: LD_VAR 0 3
87004: RET
// export function ComExit ( unit ) ; var tmp ; begin
87005: LD_INT 0
87007: PPUSH
87008: PPUSH
// if not IsInUnit ( unit ) then
87009: LD_VAR 0 1
87013: PPUSH
87014: CALL_OW 310
87018: NOT
87019: IFFALSE 87023
// exit ;
87021: GO 87083
// tmp := IsInUnit ( unit ) ;
87023: LD_ADDR_VAR 0 3
87027: PUSH
87028: LD_VAR 0 1
87032: PPUSH
87033: CALL_OW 310
87037: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87038: LD_VAR 0 3
87042: PPUSH
87043: CALL_OW 247
87047: PUSH
87048: LD_INT 2
87050: EQUAL
87051: IFFALSE 87064
// ComExitVehicle ( unit ) else
87053: LD_VAR 0 1
87057: PPUSH
87058: CALL_OW 121
87062: GO 87073
// ComExitBuilding ( unit ) ;
87064: LD_VAR 0 1
87068: PPUSH
87069: CALL_OW 122
// result := tmp ;
87073: LD_ADDR_VAR 0 2
87077: PUSH
87078: LD_VAR 0 3
87082: ST_TO_ADDR
// end ;
87083: LD_VAR 0 2
87087: RET
// export function ResetHc ; begin
87088: LD_INT 0
87090: PPUSH
// InitHc ;
87091: CALL_OW 19
// hc_importance := 0 ;
87095: LD_ADDR_OWVAR 32
87099: PUSH
87100: LD_INT 0
87102: ST_TO_ADDR
// end ; end_of_file end_of_file
87103: LD_VAR 0 1
87107: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y ) do begin SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ;
87108: LD_VAR 0 1
87112: PPUSH
87113: LD_VAR 0 2
87117: PPUSH
87118: LD_VAR 0 3
87122: PPUSH
87123: LD_VAR 0 4
87127: PPUSH
87128: LD_VAR 0 5
87132: PPUSH
87133: CALL 99912 0 5
// end ;
87137: PPOPN 5
87139: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
87140: LD_VAR 0 2
87144: PUSH
87145: LD_INT 100
87147: EQUAL
87148: IFFALSE 88097
// begin if not StreamModeActive then
87150: LD_EXP 132
87154: NOT
87155: IFFALSE 87165
// StreamModeActive := true ;
87157: LD_ADDR_EXP 132
87161: PUSH
87162: LD_INT 1
87164: ST_TO_ADDR
// if p3 = 0 then
87165: LD_VAR 0 3
87169: PUSH
87170: LD_INT 0
87172: EQUAL
87173: IFFALSE 87179
// InitStreamMode ;
87175: CALL 88330 0 0
// if p3 = 1 then
87179: LD_VAR 0 3
87183: PUSH
87184: LD_INT 1
87186: EQUAL
87187: IFFALSE 87197
// sRocket := true ;
87189: LD_ADDR_EXP 137
87193: PUSH
87194: LD_INT 1
87196: ST_TO_ADDR
// if p3 = 2 then
87197: LD_VAR 0 3
87201: PUSH
87202: LD_INT 2
87204: EQUAL
87205: IFFALSE 87215
// sSpeed := true ;
87207: LD_ADDR_EXP 136
87211: PUSH
87212: LD_INT 1
87214: ST_TO_ADDR
// if p3 = 3 then
87215: LD_VAR 0 3
87219: PUSH
87220: LD_INT 3
87222: EQUAL
87223: IFFALSE 87233
// sEngine := true ;
87225: LD_ADDR_EXP 138
87229: PUSH
87230: LD_INT 1
87232: ST_TO_ADDR
// if p3 = 4 then
87233: LD_VAR 0 3
87237: PUSH
87238: LD_INT 4
87240: EQUAL
87241: IFFALSE 87251
// sSpec := true ;
87243: LD_ADDR_EXP 135
87247: PUSH
87248: LD_INT 1
87250: ST_TO_ADDR
// if p3 = 5 then
87251: LD_VAR 0 3
87255: PUSH
87256: LD_INT 5
87258: EQUAL
87259: IFFALSE 87269
// sLevel := true ;
87261: LD_ADDR_EXP 139
87265: PUSH
87266: LD_INT 1
87268: ST_TO_ADDR
// if p3 = 6 then
87269: LD_VAR 0 3
87273: PUSH
87274: LD_INT 6
87276: EQUAL
87277: IFFALSE 87287
// sArmoury := true ;
87279: LD_ADDR_EXP 140
87283: PUSH
87284: LD_INT 1
87286: ST_TO_ADDR
// if p3 = 7 then
87287: LD_VAR 0 3
87291: PUSH
87292: LD_INT 7
87294: EQUAL
87295: IFFALSE 87305
// sRadar := true ;
87297: LD_ADDR_EXP 141
87301: PUSH
87302: LD_INT 1
87304: ST_TO_ADDR
// if p3 = 8 then
87305: LD_VAR 0 3
87309: PUSH
87310: LD_INT 8
87312: EQUAL
87313: IFFALSE 87323
// sBunker := true ;
87315: LD_ADDR_EXP 142
87319: PUSH
87320: LD_INT 1
87322: ST_TO_ADDR
// if p3 = 9 then
87323: LD_VAR 0 3
87327: PUSH
87328: LD_INT 9
87330: EQUAL
87331: IFFALSE 87341
// sHack := true ;
87333: LD_ADDR_EXP 143
87337: PUSH
87338: LD_INT 1
87340: ST_TO_ADDR
// if p3 = 10 then
87341: LD_VAR 0 3
87345: PUSH
87346: LD_INT 10
87348: EQUAL
87349: IFFALSE 87359
// sFire := true ;
87351: LD_ADDR_EXP 144
87355: PUSH
87356: LD_INT 1
87358: ST_TO_ADDR
// if p3 = 11 then
87359: LD_VAR 0 3
87363: PUSH
87364: LD_INT 11
87366: EQUAL
87367: IFFALSE 87377
// sRefresh := true ;
87369: LD_ADDR_EXP 145
87373: PUSH
87374: LD_INT 1
87376: ST_TO_ADDR
// if p3 = 12 then
87377: LD_VAR 0 3
87381: PUSH
87382: LD_INT 12
87384: EQUAL
87385: IFFALSE 87395
// sExp := true ;
87387: LD_ADDR_EXP 146
87391: PUSH
87392: LD_INT 1
87394: ST_TO_ADDR
// if p3 = 13 then
87395: LD_VAR 0 3
87399: PUSH
87400: LD_INT 13
87402: EQUAL
87403: IFFALSE 87413
// sDepot := true ;
87405: LD_ADDR_EXP 147
87409: PUSH
87410: LD_INT 1
87412: ST_TO_ADDR
// if p3 = 14 then
87413: LD_VAR 0 3
87417: PUSH
87418: LD_INT 14
87420: EQUAL
87421: IFFALSE 87431
// sFlag := true ;
87423: LD_ADDR_EXP 148
87427: PUSH
87428: LD_INT 1
87430: ST_TO_ADDR
// if p3 = 15 then
87431: LD_VAR 0 3
87435: PUSH
87436: LD_INT 15
87438: EQUAL
87439: IFFALSE 87449
// sKamikadze := true ;
87441: LD_ADDR_EXP 156
87445: PUSH
87446: LD_INT 1
87448: ST_TO_ADDR
// if p3 = 16 then
87449: LD_VAR 0 3
87453: PUSH
87454: LD_INT 16
87456: EQUAL
87457: IFFALSE 87467
// sTroll := true ;
87459: LD_ADDR_EXP 157
87463: PUSH
87464: LD_INT 1
87466: ST_TO_ADDR
// if p3 = 17 then
87467: LD_VAR 0 3
87471: PUSH
87472: LD_INT 17
87474: EQUAL
87475: IFFALSE 87485
// sSlow := true ;
87477: LD_ADDR_EXP 158
87481: PUSH
87482: LD_INT 1
87484: ST_TO_ADDR
// if p3 = 18 then
87485: LD_VAR 0 3
87489: PUSH
87490: LD_INT 18
87492: EQUAL
87493: IFFALSE 87503
// sLack := true ;
87495: LD_ADDR_EXP 159
87499: PUSH
87500: LD_INT 1
87502: ST_TO_ADDR
// if p3 = 19 then
87503: LD_VAR 0 3
87507: PUSH
87508: LD_INT 19
87510: EQUAL
87511: IFFALSE 87521
// sTank := true ;
87513: LD_ADDR_EXP 161
87517: PUSH
87518: LD_INT 1
87520: ST_TO_ADDR
// if p3 = 20 then
87521: LD_VAR 0 3
87525: PUSH
87526: LD_INT 20
87528: EQUAL
87529: IFFALSE 87539
// sRemote := true ;
87531: LD_ADDR_EXP 162
87535: PUSH
87536: LD_INT 1
87538: ST_TO_ADDR
// if p3 = 21 then
87539: LD_VAR 0 3
87543: PUSH
87544: LD_INT 21
87546: EQUAL
87547: IFFALSE 87557
// sPowell := true ;
87549: LD_ADDR_EXP 163
87553: PUSH
87554: LD_INT 1
87556: ST_TO_ADDR
// if p3 = 22 then
87557: LD_VAR 0 3
87561: PUSH
87562: LD_INT 22
87564: EQUAL
87565: IFFALSE 87575
// sTeleport := true ;
87567: LD_ADDR_EXP 166
87571: PUSH
87572: LD_INT 1
87574: ST_TO_ADDR
// if p3 = 23 then
87575: LD_VAR 0 3
87579: PUSH
87580: LD_INT 23
87582: EQUAL
87583: IFFALSE 87593
// sOilTower := true ;
87585: LD_ADDR_EXP 168
87589: PUSH
87590: LD_INT 1
87592: ST_TO_ADDR
// if p3 = 24 then
87593: LD_VAR 0 3
87597: PUSH
87598: LD_INT 24
87600: EQUAL
87601: IFFALSE 87611
// sShovel := true ;
87603: LD_ADDR_EXP 169
87607: PUSH
87608: LD_INT 1
87610: ST_TO_ADDR
// if p3 = 25 then
87611: LD_VAR 0 3
87615: PUSH
87616: LD_INT 25
87618: EQUAL
87619: IFFALSE 87629
// sSheik := true ;
87621: LD_ADDR_EXP 170
87625: PUSH
87626: LD_INT 1
87628: ST_TO_ADDR
// if p3 = 26 then
87629: LD_VAR 0 3
87633: PUSH
87634: LD_INT 26
87636: EQUAL
87637: IFFALSE 87647
// sEarthquake := true ;
87639: LD_ADDR_EXP 172
87643: PUSH
87644: LD_INT 1
87646: ST_TO_ADDR
// if p3 = 27 then
87647: LD_VAR 0 3
87651: PUSH
87652: LD_INT 27
87654: EQUAL
87655: IFFALSE 87665
// sAI := true ;
87657: LD_ADDR_EXP 173
87661: PUSH
87662: LD_INT 1
87664: ST_TO_ADDR
// if p3 = 28 then
87665: LD_VAR 0 3
87669: PUSH
87670: LD_INT 28
87672: EQUAL
87673: IFFALSE 87683
// sCargo := true ;
87675: LD_ADDR_EXP 176
87679: PUSH
87680: LD_INT 1
87682: ST_TO_ADDR
// if p3 = 29 then
87683: LD_VAR 0 3
87687: PUSH
87688: LD_INT 29
87690: EQUAL
87691: IFFALSE 87701
// sDLaser := true ;
87693: LD_ADDR_EXP 177
87697: PUSH
87698: LD_INT 1
87700: ST_TO_ADDR
// if p3 = 30 then
87701: LD_VAR 0 3
87705: PUSH
87706: LD_INT 30
87708: EQUAL
87709: IFFALSE 87719
// sExchange := true ;
87711: LD_ADDR_EXP 178
87715: PUSH
87716: LD_INT 1
87718: ST_TO_ADDR
// if p3 = 31 then
87719: LD_VAR 0 3
87723: PUSH
87724: LD_INT 31
87726: EQUAL
87727: IFFALSE 87737
// sFac := true ;
87729: LD_ADDR_EXP 179
87733: PUSH
87734: LD_INT 1
87736: ST_TO_ADDR
// if p3 = 32 then
87737: LD_VAR 0 3
87741: PUSH
87742: LD_INT 32
87744: EQUAL
87745: IFFALSE 87755
// sPower := true ;
87747: LD_ADDR_EXP 180
87751: PUSH
87752: LD_INT 1
87754: ST_TO_ADDR
// if p3 = 33 then
87755: LD_VAR 0 3
87759: PUSH
87760: LD_INT 33
87762: EQUAL
87763: IFFALSE 87773
// sRandom := true ;
87765: LD_ADDR_EXP 181
87769: PUSH
87770: LD_INT 1
87772: ST_TO_ADDR
// if p3 = 34 then
87773: LD_VAR 0 3
87777: PUSH
87778: LD_INT 34
87780: EQUAL
87781: IFFALSE 87791
// sShield := true ;
87783: LD_ADDR_EXP 182
87787: PUSH
87788: LD_INT 1
87790: ST_TO_ADDR
// if p3 = 35 then
87791: LD_VAR 0 3
87795: PUSH
87796: LD_INT 35
87798: EQUAL
87799: IFFALSE 87809
// sTime := true ;
87801: LD_ADDR_EXP 183
87805: PUSH
87806: LD_INT 1
87808: ST_TO_ADDR
// if p3 = 36 then
87809: LD_VAR 0 3
87813: PUSH
87814: LD_INT 36
87816: EQUAL
87817: IFFALSE 87827
// sTools := true ;
87819: LD_ADDR_EXP 184
87823: PUSH
87824: LD_INT 1
87826: ST_TO_ADDR
// if p3 = 101 then
87827: LD_VAR 0 3
87831: PUSH
87832: LD_INT 101
87834: EQUAL
87835: IFFALSE 87845
// sSold := true ;
87837: LD_ADDR_EXP 149
87841: PUSH
87842: LD_INT 1
87844: ST_TO_ADDR
// if p3 = 102 then
87845: LD_VAR 0 3
87849: PUSH
87850: LD_INT 102
87852: EQUAL
87853: IFFALSE 87863
// sDiff := true ;
87855: LD_ADDR_EXP 150
87859: PUSH
87860: LD_INT 1
87862: ST_TO_ADDR
// if p3 = 103 then
87863: LD_VAR 0 3
87867: PUSH
87868: LD_INT 103
87870: EQUAL
87871: IFFALSE 87881
// sFog := true ;
87873: LD_ADDR_EXP 153
87877: PUSH
87878: LD_INT 1
87880: ST_TO_ADDR
// if p3 = 104 then
87881: LD_VAR 0 3
87885: PUSH
87886: LD_INT 104
87888: EQUAL
87889: IFFALSE 87899
// sReset := true ;
87891: LD_ADDR_EXP 154
87895: PUSH
87896: LD_INT 1
87898: ST_TO_ADDR
// if p3 = 105 then
87899: LD_VAR 0 3
87903: PUSH
87904: LD_INT 105
87906: EQUAL
87907: IFFALSE 87917
// sSun := true ;
87909: LD_ADDR_EXP 155
87913: PUSH
87914: LD_INT 1
87916: ST_TO_ADDR
// if p3 = 106 then
87917: LD_VAR 0 3
87921: PUSH
87922: LD_INT 106
87924: EQUAL
87925: IFFALSE 87935
// sTiger := true ;
87927: LD_ADDR_EXP 151
87931: PUSH
87932: LD_INT 1
87934: ST_TO_ADDR
// if p3 = 107 then
87935: LD_VAR 0 3
87939: PUSH
87940: LD_INT 107
87942: EQUAL
87943: IFFALSE 87953
// sBomb := true ;
87945: LD_ADDR_EXP 152
87949: PUSH
87950: LD_INT 1
87952: ST_TO_ADDR
// if p3 = 108 then
87953: LD_VAR 0 3
87957: PUSH
87958: LD_INT 108
87960: EQUAL
87961: IFFALSE 87971
// sWound := true ;
87963: LD_ADDR_EXP 160
87967: PUSH
87968: LD_INT 1
87970: ST_TO_ADDR
// if p3 = 109 then
87971: LD_VAR 0 3
87975: PUSH
87976: LD_INT 109
87978: EQUAL
87979: IFFALSE 87989
// sBetray := true ;
87981: LD_ADDR_EXP 164
87985: PUSH
87986: LD_INT 1
87988: ST_TO_ADDR
// if p3 = 110 then
87989: LD_VAR 0 3
87993: PUSH
87994: LD_INT 110
87996: EQUAL
87997: IFFALSE 88007
// sContamin := true ;
87999: LD_ADDR_EXP 165
88003: PUSH
88004: LD_INT 1
88006: ST_TO_ADDR
// if p3 = 111 then
88007: LD_VAR 0 3
88011: PUSH
88012: LD_INT 111
88014: EQUAL
88015: IFFALSE 88025
// sOil := true ;
88017: LD_ADDR_EXP 167
88021: PUSH
88022: LD_INT 1
88024: ST_TO_ADDR
// if p3 = 112 then
88025: LD_VAR 0 3
88029: PUSH
88030: LD_INT 112
88032: EQUAL
88033: IFFALSE 88043
// sStu := true ;
88035: LD_ADDR_EXP 171
88039: PUSH
88040: LD_INT 1
88042: ST_TO_ADDR
// if p3 = 113 then
88043: LD_VAR 0 3
88047: PUSH
88048: LD_INT 113
88050: EQUAL
88051: IFFALSE 88061
// sBazooka := true ;
88053: LD_ADDR_EXP 174
88057: PUSH
88058: LD_INT 1
88060: ST_TO_ADDR
// if p3 = 114 then
88061: LD_VAR 0 3
88065: PUSH
88066: LD_INT 114
88068: EQUAL
88069: IFFALSE 88079
// sMortar := true ;
88071: LD_ADDR_EXP 175
88075: PUSH
88076: LD_INT 1
88078: ST_TO_ADDR
// if p3 = 115 then
88079: LD_VAR 0 3
88083: PUSH
88084: LD_INT 115
88086: EQUAL
88087: IFFALSE 88097
// sRanger := true ;
88089: LD_ADDR_EXP 185
88093: PUSH
88094: LD_INT 1
88096: ST_TO_ADDR
// end ; if p2 = 101 then
88097: LD_VAR 0 2
88101: PUSH
88102: LD_INT 101
88104: EQUAL
88105: IFFALSE 88308
// begin case p3 of 1 :
88107: LD_VAR 0 3
88111: PUSH
88112: LD_INT 1
88114: DOUBLE
88115: EQUAL
88116: IFTRUE 88120
88118: GO 88127
88120: POP
// hHackUnlimitedResources ; 2 :
88121: CALL 98402 0 0
88125: GO 88308
88127: LD_INT 2
88129: DOUBLE
88130: EQUAL
88131: IFTRUE 88135
88133: GO 88142
88135: POP
// hHackSetLevel10 ; 3 :
88136: CALL 98535 0 0
88140: GO 88308
88142: LD_INT 3
88144: DOUBLE
88145: EQUAL
88146: IFTRUE 88150
88148: GO 88157
88150: POP
// hHackSetLevel10YourUnits ; 4 :
88151: CALL 98620 0 0
88155: GO 88308
88157: LD_INT 4
88159: DOUBLE
88160: EQUAL
88161: IFTRUE 88165
88163: GO 88187
88165: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
88166: LD_VAR 0 4
88170: PPUSH
88171: LD_VAR 0 5
88175: PPUSH
88176: LD_VAR 0 6
88180: PPUSH
88181: CALL 98710 0 3
88185: GO 88308
88187: LD_INT 5
88189: DOUBLE
88190: EQUAL
88191: IFTRUE 88195
88193: GO 88202
88195: POP
// hHackSpawnVehicle ; 6 :
88196: CALL 98771 0 0
88200: GO 88308
88202: LD_INT 6
88204: DOUBLE
88205: EQUAL
88206: IFTRUE 88210
88208: GO 88217
88210: POP
// hHackInvincible ; 7 :
88211: CALL 99317 0 0
88215: GO 88308
88217: LD_INT 7
88219: DOUBLE
88220: EQUAL
88221: IFTRUE 88225
88223: GO 88232
88225: POP
// hHackInvisible ; 8 :
88226: CALL 99428 0 0
88230: GO 88308
88232: LD_INT 8
88234: DOUBLE
88235: EQUAL
88236: IFTRUE 88240
88238: GO 88247
88240: POP
// hHackChangeYourSide ; 9 :
88241: CALL 99485 0 0
88245: GO 88308
88247: LD_INT 9
88249: DOUBLE
88250: EQUAL
88251: IFTRUE 88255
88253: GO 88262
88255: POP
// hHackChangeUnitSide ; 10 :
88256: CALL 99527 0 0
88260: GO 88308
88262: LD_INT 10
88264: DOUBLE
88265: EQUAL
88266: IFTRUE 88270
88268: GO 88277
88270: POP
// hHackFog ; 11 :
88271: CALL 99628 0 0
88275: GO 88308
88277: LD_INT 11
88279: DOUBLE
88280: EQUAL
88281: IFTRUE 88285
88283: GO 88292
88285: POP
// hHackApeman ; 12 :
88286: CALL 99643 0 0
88290: GO 88308
88292: LD_INT 12
88294: DOUBLE
88295: EQUAL
88296: IFTRUE 88300
88298: GO 88307
88300: POP
// hHackBoom ; end ;
88301: CALL 99728 0 0
88305: GO 88308
88307: POP
// end ; end ;
88308: PPOPN 6
88310: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
88311: GO 88313
88313: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
88314: LD_STRING initStreamRollete();
88316: PPUSH
88317: CALL_OW 559
// InitStreamMode ;
88321: CALL 88330 0 0
// DefineStreamItems ( ) ;
88325: CALL 88770 0 0
// end ;
88329: END
// function InitStreamMode ; begin
88330: LD_INT 0
88332: PPUSH
// streamModeActive := false ;
88333: LD_ADDR_EXP 132
88337: PUSH
88338: LD_INT 0
88340: ST_TO_ADDR
// normalCounter := 36 ;
88341: LD_ADDR_EXP 133
88345: PUSH
88346: LD_INT 36
88348: ST_TO_ADDR
// hardcoreCounter := 16 ;
88349: LD_ADDR_EXP 134
88353: PUSH
88354: LD_INT 16
88356: ST_TO_ADDR
// sRocket := false ;
88357: LD_ADDR_EXP 137
88361: PUSH
88362: LD_INT 0
88364: ST_TO_ADDR
// sSpeed := false ;
88365: LD_ADDR_EXP 136
88369: PUSH
88370: LD_INT 0
88372: ST_TO_ADDR
// sEngine := false ;
88373: LD_ADDR_EXP 138
88377: PUSH
88378: LD_INT 0
88380: ST_TO_ADDR
// sSpec := false ;
88381: LD_ADDR_EXP 135
88385: PUSH
88386: LD_INT 0
88388: ST_TO_ADDR
// sLevel := false ;
88389: LD_ADDR_EXP 139
88393: PUSH
88394: LD_INT 0
88396: ST_TO_ADDR
// sArmoury := false ;
88397: LD_ADDR_EXP 140
88401: PUSH
88402: LD_INT 0
88404: ST_TO_ADDR
// sRadar := false ;
88405: LD_ADDR_EXP 141
88409: PUSH
88410: LD_INT 0
88412: ST_TO_ADDR
// sBunker := false ;
88413: LD_ADDR_EXP 142
88417: PUSH
88418: LD_INT 0
88420: ST_TO_ADDR
// sHack := false ;
88421: LD_ADDR_EXP 143
88425: PUSH
88426: LD_INT 0
88428: ST_TO_ADDR
// sFire := false ;
88429: LD_ADDR_EXP 144
88433: PUSH
88434: LD_INT 0
88436: ST_TO_ADDR
// sRefresh := false ;
88437: LD_ADDR_EXP 145
88441: PUSH
88442: LD_INT 0
88444: ST_TO_ADDR
// sExp := false ;
88445: LD_ADDR_EXP 146
88449: PUSH
88450: LD_INT 0
88452: ST_TO_ADDR
// sDepot := false ;
88453: LD_ADDR_EXP 147
88457: PUSH
88458: LD_INT 0
88460: ST_TO_ADDR
// sFlag := false ;
88461: LD_ADDR_EXP 148
88465: PUSH
88466: LD_INT 0
88468: ST_TO_ADDR
// sKamikadze := false ;
88469: LD_ADDR_EXP 156
88473: PUSH
88474: LD_INT 0
88476: ST_TO_ADDR
// sTroll := false ;
88477: LD_ADDR_EXP 157
88481: PUSH
88482: LD_INT 0
88484: ST_TO_ADDR
// sSlow := false ;
88485: LD_ADDR_EXP 158
88489: PUSH
88490: LD_INT 0
88492: ST_TO_ADDR
// sLack := false ;
88493: LD_ADDR_EXP 159
88497: PUSH
88498: LD_INT 0
88500: ST_TO_ADDR
// sTank := false ;
88501: LD_ADDR_EXP 161
88505: PUSH
88506: LD_INT 0
88508: ST_TO_ADDR
// sRemote := false ;
88509: LD_ADDR_EXP 162
88513: PUSH
88514: LD_INT 0
88516: ST_TO_ADDR
// sPowell := false ;
88517: LD_ADDR_EXP 163
88521: PUSH
88522: LD_INT 0
88524: ST_TO_ADDR
// sTeleport := false ;
88525: LD_ADDR_EXP 166
88529: PUSH
88530: LD_INT 0
88532: ST_TO_ADDR
// sOilTower := false ;
88533: LD_ADDR_EXP 168
88537: PUSH
88538: LD_INT 0
88540: ST_TO_ADDR
// sShovel := false ;
88541: LD_ADDR_EXP 169
88545: PUSH
88546: LD_INT 0
88548: ST_TO_ADDR
// sSheik := false ;
88549: LD_ADDR_EXP 170
88553: PUSH
88554: LD_INT 0
88556: ST_TO_ADDR
// sEarthquake := false ;
88557: LD_ADDR_EXP 172
88561: PUSH
88562: LD_INT 0
88564: ST_TO_ADDR
// sAI := false ;
88565: LD_ADDR_EXP 173
88569: PUSH
88570: LD_INT 0
88572: ST_TO_ADDR
// sCargo := false ;
88573: LD_ADDR_EXP 176
88577: PUSH
88578: LD_INT 0
88580: ST_TO_ADDR
// sDLaser := false ;
88581: LD_ADDR_EXP 177
88585: PUSH
88586: LD_INT 0
88588: ST_TO_ADDR
// sExchange := false ;
88589: LD_ADDR_EXP 178
88593: PUSH
88594: LD_INT 0
88596: ST_TO_ADDR
// sFac := false ;
88597: LD_ADDR_EXP 179
88601: PUSH
88602: LD_INT 0
88604: ST_TO_ADDR
// sPower := false ;
88605: LD_ADDR_EXP 180
88609: PUSH
88610: LD_INT 0
88612: ST_TO_ADDR
// sRandom := false ;
88613: LD_ADDR_EXP 181
88617: PUSH
88618: LD_INT 0
88620: ST_TO_ADDR
// sShield := false ;
88621: LD_ADDR_EXP 182
88625: PUSH
88626: LD_INT 0
88628: ST_TO_ADDR
// sTime := false ;
88629: LD_ADDR_EXP 183
88633: PUSH
88634: LD_INT 0
88636: ST_TO_ADDR
// sTools := false ;
88637: LD_ADDR_EXP 184
88641: PUSH
88642: LD_INT 0
88644: ST_TO_ADDR
// sSold := false ;
88645: LD_ADDR_EXP 149
88649: PUSH
88650: LD_INT 0
88652: ST_TO_ADDR
// sDiff := false ;
88653: LD_ADDR_EXP 150
88657: PUSH
88658: LD_INT 0
88660: ST_TO_ADDR
// sFog := false ;
88661: LD_ADDR_EXP 153
88665: PUSH
88666: LD_INT 0
88668: ST_TO_ADDR
// sReset := false ;
88669: LD_ADDR_EXP 154
88673: PUSH
88674: LD_INT 0
88676: ST_TO_ADDR
// sSun := false ;
88677: LD_ADDR_EXP 155
88681: PUSH
88682: LD_INT 0
88684: ST_TO_ADDR
// sTiger := false ;
88685: LD_ADDR_EXP 151
88689: PUSH
88690: LD_INT 0
88692: ST_TO_ADDR
// sBomb := false ;
88693: LD_ADDR_EXP 152
88697: PUSH
88698: LD_INT 0
88700: ST_TO_ADDR
// sWound := false ;
88701: LD_ADDR_EXP 160
88705: PUSH
88706: LD_INT 0
88708: ST_TO_ADDR
// sBetray := false ;
88709: LD_ADDR_EXP 164
88713: PUSH
88714: LD_INT 0
88716: ST_TO_ADDR
// sContamin := false ;
88717: LD_ADDR_EXP 165
88721: PUSH
88722: LD_INT 0
88724: ST_TO_ADDR
// sOil := false ;
88725: LD_ADDR_EXP 167
88729: PUSH
88730: LD_INT 0
88732: ST_TO_ADDR
// sStu := false ;
88733: LD_ADDR_EXP 171
88737: PUSH
88738: LD_INT 0
88740: ST_TO_ADDR
// sBazooka := false ;
88741: LD_ADDR_EXP 174
88745: PUSH
88746: LD_INT 0
88748: ST_TO_ADDR
// sMortar := false ;
88749: LD_ADDR_EXP 175
88753: PUSH
88754: LD_INT 0
88756: ST_TO_ADDR
// sRanger := false ;
88757: LD_ADDR_EXP 185
88761: PUSH
88762: LD_INT 0
88764: ST_TO_ADDR
// end ;
88765: LD_VAR 0 1
88769: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
88770: LD_INT 0
88772: PPUSH
88773: PPUSH
88774: PPUSH
88775: PPUSH
88776: PPUSH
// result := [ ] ;
88777: LD_ADDR_VAR 0 1
88781: PUSH
88782: EMPTY
88783: ST_TO_ADDR
// if campaign_id = 1 then
88784: LD_OWVAR 69
88788: PUSH
88789: LD_INT 1
88791: EQUAL
88792: IFFALSE 91730
// begin case mission_number of 1 :
88794: LD_OWVAR 70
88798: PUSH
88799: LD_INT 1
88801: DOUBLE
88802: EQUAL
88803: IFTRUE 88807
88805: GO 88871
88807: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
88808: LD_ADDR_VAR 0 1
88812: PUSH
88813: LD_INT 2
88815: PUSH
88816: LD_INT 4
88818: PUSH
88819: LD_INT 11
88821: PUSH
88822: LD_INT 12
88824: PUSH
88825: LD_INT 15
88827: PUSH
88828: LD_INT 16
88830: PUSH
88831: LD_INT 22
88833: PUSH
88834: LD_INT 23
88836: PUSH
88837: LD_INT 26
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: PUSH
88851: LD_INT 101
88853: PUSH
88854: LD_INT 102
88856: PUSH
88857: LD_INT 106
88859: PUSH
88860: EMPTY
88861: LIST
88862: LIST
88863: LIST
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: ST_TO_ADDR
88869: GO 91728
88871: LD_INT 2
88873: DOUBLE
88874: EQUAL
88875: IFTRUE 88879
88877: GO 88951
88879: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
88880: LD_ADDR_VAR 0 1
88884: PUSH
88885: LD_INT 2
88887: PUSH
88888: LD_INT 4
88890: PUSH
88891: LD_INT 11
88893: PUSH
88894: LD_INT 12
88896: PUSH
88897: LD_INT 15
88899: PUSH
88900: LD_INT 16
88902: PUSH
88903: LD_INT 22
88905: PUSH
88906: LD_INT 23
88908: PUSH
88909: LD_INT 26
88911: PUSH
88912: EMPTY
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: PUSH
88923: LD_INT 101
88925: PUSH
88926: LD_INT 102
88928: PUSH
88929: LD_INT 105
88931: PUSH
88932: LD_INT 106
88934: PUSH
88935: LD_INT 108
88937: PUSH
88938: EMPTY
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: ST_TO_ADDR
88949: GO 91728
88951: LD_INT 3
88953: DOUBLE
88954: EQUAL
88955: IFTRUE 88959
88957: GO 89035
88959: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
88960: LD_ADDR_VAR 0 1
88964: PUSH
88965: LD_INT 2
88967: PUSH
88968: LD_INT 4
88970: PUSH
88971: LD_INT 5
88973: PUSH
88974: LD_INT 11
88976: PUSH
88977: LD_INT 12
88979: PUSH
88980: LD_INT 15
88982: PUSH
88983: LD_INT 16
88985: PUSH
88986: LD_INT 22
88988: PUSH
88989: LD_INT 26
88991: PUSH
88992: LD_INT 36
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: PUSH
89007: LD_INT 101
89009: PUSH
89010: LD_INT 102
89012: PUSH
89013: LD_INT 105
89015: PUSH
89016: LD_INT 106
89018: PUSH
89019: LD_INT 108
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: PUSH
89029: EMPTY
89030: LIST
89031: LIST
89032: ST_TO_ADDR
89033: GO 91728
89035: LD_INT 4
89037: DOUBLE
89038: EQUAL
89039: IFTRUE 89043
89041: GO 89127
89043: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
89044: LD_ADDR_VAR 0 1
89048: PUSH
89049: LD_INT 2
89051: PUSH
89052: LD_INT 4
89054: PUSH
89055: LD_INT 5
89057: PUSH
89058: LD_INT 8
89060: PUSH
89061: LD_INT 11
89063: PUSH
89064: LD_INT 12
89066: PUSH
89067: LD_INT 15
89069: PUSH
89070: LD_INT 16
89072: PUSH
89073: LD_INT 22
89075: PUSH
89076: LD_INT 23
89078: PUSH
89079: LD_INT 26
89081: PUSH
89082: LD_INT 36
89084: PUSH
89085: EMPTY
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: LIST
89092: LIST
89093: LIST
89094: LIST
89095: LIST
89096: LIST
89097: LIST
89098: PUSH
89099: LD_INT 101
89101: PUSH
89102: LD_INT 102
89104: PUSH
89105: LD_INT 105
89107: PUSH
89108: LD_INT 106
89110: PUSH
89111: LD_INT 108
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: ST_TO_ADDR
89125: GO 91728
89127: LD_INT 5
89129: DOUBLE
89130: EQUAL
89131: IFTRUE 89135
89133: GO 89235
89135: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
89136: LD_ADDR_VAR 0 1
89140: PUSH
89141: LD_INT 2
89143: PUSH
89144: LD_INT 4
89146: PUSH
89147: LD_INT 5
89149: PUSH
89150: LD_INT 6
89152: PUSH
89153: LD_INT 8
89155: PUSH
89156: LD_INT 11
89158: PUSH
89159: LD_INT 12
89161: PUSH
89162: LD_INT 15
89164: PUSH
89165: LD_INT 16
89167: PUSH
89168: LD_INT 22
89170: PUSH
89171: LD_INT 23
89173: PUSH
89174: LD_INT 25
89176: PUSH
89177: LD_INT 26
89179: PUSH
89180: LD_INT 36
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 101
89201: PUSH
89202: LD_INT 102
89204: PUSH
89205: LD_INT 105
89207: PUSH
89208: LD_INT 106
89210: PUSH
89211: LD_INT 108
89213: PUSH
89214: LD_INT 109
89216: PUSH
89217: LD_INT 112
89219: PUSH
89220: EMPTY
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: PUSH
89229: EMPTY
89230: LIST
89231: LIST
89232: ST_TO_ADDR
89233: GO 91728
89235: LD_INT 6
89237: DOUBLE
89238: EQUAL
89239: IFTRUE 89243
89241: GO 89363
89243: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
89244: LD_ADDR_VAR 0 1
89248: PUSH
89249: LD_INT 2
89251: PUSH
89252: LD_INT 4
89254: PUSH
89255: LD_INT 5
89257: PUSH
89258: LD_INT 6
89260: PUSH
89261: LD_INT 8
89263: PUSH
89264: LD_INT 11
89266: PUSH
89267: LD_INT 12
89269: PUSH
89270: LD_INT 15
89272: PUSH
89273: LD_INT 16
89275: PUSH
89276: LD_INT 20
89278: PUSH
89279: LD_INT 21
89281: PUSH
89282: LD_INT 22
89284: PUSH
89285: LD_INT 23
89287: PUSH
89288: LD_INT 25
89290: PUSH
89291: LD_INT 26
89293: PUSH
89294: LD_INT 30
89296: PUSH
89297: LD_INT 31
89299: PUSH
89300: LD_INT 32
89302: PUSH
89303: LD_INT 36
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: LIST
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: LIST
89326: PUSH
89327: LD_INT 101
89329: PUSH
89330: LD_INT 102
89332: PUSH
89333: LD_INT 105
89335: PUSH
89336: LD_INT 106
89338: PUSH
89339: LD_INT 108
89341: PUSH
89342: LD_INT 109
89344: PUSH
89345: LD_INT 112
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: ST_TO_ADDR
89361: GO 91728
89363: LD_INT 7
89365: DOUBLE
89366: EQUAL
89367: IFTRUE 89371
89369: GO 89471
89371: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
89372: LD_ADDR_VAR 0 1
89376: PUSH
89377: LD_INT 2
89379: PUSH
89380: LD_INT 4
89382: PUSH
89383: LD_INT 5
89385: PUSH
89386: LD_INT 7
89388: PUSH
89389: LD_INT 11
89391: PUSH
89392: LD_INT 12
89394: PUSH
89395: LD_INT 15
89397: PUSH
89398: LD_INT 16
89400: PUSH
89401: LD_INT 20
89403: PUSH
89404: LD_INT 21
89406: PUSH
89407: LD_INT 22
89409: PUSH
89410: LD_INT 23
89412: PUSH
89413: LD_INT 25
89415: PUSH
89416: LD_INT 26
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: PUSH
89435: LD_INT 101
89437: PUSH
89438: LD_INT 102
89440: PUSH
89441: LD_INT 103
89443: PUSH
89444: LD_INT 105
89446: PUSH
89447: LD_INT 106
89449: PUSH
89450: LD_INT 108
89452: PUSH
89453: LD_INT 112
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: ST_TO_ADDR
89469: GO 91728
89471: LD_INT 8
89473: DOUBLE
89474: EQUAL
89475: IFTRUE 89479
89477: GO 89607
89479: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
89480: LD_ADDR_VAR 0 1
89484: PUSH
89485: LD_INT 2
89487: PUSH
89488: LD_INT 4
89490: PUSH
89491: LD_INT 5
89493: PUSH
89494: LD_INT 6
89496: PUSH
89497: LD_INT 7
89499: PUSH
89500: LD_INT 8
89502: PUSH
89503: LD_INT 11
89505: PUSH
89506: LD_INT 12
89508: PUSH
89509: LD_INT 15
89511: PUSH
89512: LD_INT 16
89514: PUSH
89515: LD_INT 20
89517: PUSH
89518: LD_INT 21
89520: PUSH
89521: LD_INT 22
89523: PUSH
89524: LD_INT 23
89526: PUSH
89527: LD_INT 25
89529: PUSH
89530: LD_INT 26
89532: PUSH
89533: LD_INT 30
89535: PUSH
89536: LD_INT 31
89538: PUSH
89539: LD_INT 32
89541: PUSH
89542: LD_INT 36
89544: PUSH
89545: EMPTY
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: PUSH
89567: LD_INT 101
89569: PUSH
89570: LD_INT 102
89572: PUSH
89573: LD_INT 103
89575: PUSH
89576: LD_INT 105
89578: PUSH
89579: LD_INT 106
89581: PUSH
89582: LD_INT 108
89584: PUSH
89585: LD_INT 109
89587: PUSH
89588: LD_INT 112
89590: PUSH
89591: EMPTY
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: LIST
89599: LIST
89600: PUSH
89601: EMPTY
89602: LIST
89603: LIST
89604: ST_TO_ADDR
89605: GO 91728
89607: LD_INT 9
89609: DOUBLE
89610: EQUAL
89611: IFTRUE 89615
89613: GO 89751
89615: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
89616: LD_ADDR_VAR 0 1
89620: PUSH
89621: LD_INT 2
89623: PUSH
89624: LD_INT 4
89626: PUSH
89627: LD_INT 5
89629: PUSH
89630: LD_INT 6
89632: PUSH
89633: LD_INT 7
89635: PUSH
89636: LD_INT 8
89638: PUSH
89639: LD_INT 11
89641: PUSH
89642: LD_INT 12
89644: PUSH
89645: LD_INT 15
89647: PUSH
89648: LD_INT 16
89650: PUSH
89651: LD_INT 20
89653: PUSH
89654: LD_INT 21
89656: PUSH
89657: LD_INT 22
89659: PUSH
89660: LD_INT 23
89662: PUSH
89663: LD_INT 25
89665: PUSH
89666: LD_INT 26
89668: PUSH
89669: LD_INT 28
89671: PUSH
89672: LD_INT 30
89674: PUSH
89675: LD_INT 31
89677: PUSH
89678: LD_INT 32
89680: PUSH
89681: LD_INT 36
89683: PUSH
89684: EMPTY
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: PUSH
89707: LD_INT 101
89709: PUSH
89710: LD_INT 102
89712: PUSH
89713: LD_INT 103
89715: PUSH
89716: LD_INT 105
89718: PUSH
89719: LD_INT 106
89721: PUSH
89722: LD_INT 108
89724: PUSH
89725: LD_INT 109
89727: PUSH
89728: LD_INT 112
89730: PUSH
89731: LD_INT 114
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: LIST
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: LIST
89743: LIST
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: ST_TO_ADDR
89749: GO 91728
89751: LD_INT 10
89753: DOUBLE
89754: EQUAL
89755: IFTRUE 89759
89757: GO 89943
89759: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
89760: LD_ADDR_VAR 0 1
89764: PUSH
89765: LD_INT 2
89767: PUSH
89768: LD_INT 4
89770: PUSH
89771: LD_INT 5
89773: PUSH
89774: LD_INT 6
89776: PUSH
89777: LD_INT 7
89779: PUSH
89780: LD_INT 8
89782: PUSH
89783: LD_INT 9
89785: PUSH
89786: LD_INT 10
89788: PUSH
89789: LD_INT 11
89791: PUSH
89792: LD_INT 12
89794: PUSH
89795: LD_INT 13
89797: PUSH
89798: LD_INT 14
89800: PUSH
89801: LD_INT 15
89803: PUSH
89804: LD_INT 16
89806: PUSH
89807: LD_INT 17
89809: PUSH
89810: LD_INT 18
89812: PUSH
89813: LD_INT 19
89815: PUSH
89816: LD_INT 20
89818: PUSH
89819: LD_INT 21
89821: PUSH
89822: LD_INT 22
89824: PUSH
89825: LD_INT 23
89827: PUSH
89828: LD_INT 24
89830: PUSH
89831: LD_INT 25
89833: PUSH
89834: LD_INT 26
89836: PUSH
89837: LD_INT 28
89839: PUSH
89840: LD_INT 30
89842: PUSH
89843: LD_INT 31
89845: PUSH
89846: LD_INT 32
89848: PUSH
89849: LD_INT 36
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: LIST
89856: LIST
89857: LIST
89858: LIST
89859: LIST
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: LIST
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 101
89885: PUSH
89886: LD_INT 102
89888: PUSH
89889: LD_INT 103
89891: PUSH
89892: LD_INT 104
89894: PUSH
89895: LD_INT 105
89897: PUSH
89898: LD_INT 106
89900: PUSH
89901: LD_INT 107
89903: PUSH
89904: LD_INT 108
89906: PUSH
89907: LD_INT 109
89909: PUSH
89910: LD_INT 110
89912: PUSH
89913: LD_INT 111
89915: PUSH
89916: LD_INT 112
89918: PUSH
89919: LD_INT 114
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: LIST
89929: LIST
89930: LIST
89931: LIST
89932: LIST
89933: LIST
89934: LIST
89935: LIST
89936: PUSH
89937: EMPTY
89938: LIST
89939: LIST
89940: ST_TO_ADDR
89941: GO 91728
89943: LD_INT 11
89945: DOUBLE
89946: EQUAL
89947: IFTRUE 89951
89949: GO 90143
89951: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
89952: LD_ADDR_VAR 0 1
89956: PUSH
89957: LD_INT 2
89959: PUSH
89960: LD_INT 3
89962: PUSH
89963: LD_INT 4
89965: PUSH
89966: LD_INT 5
89968: PUSH
89969: LD_INT 6
89971: PUSH
89972: LD_INT 7
89974: PUSH
89975: LD_INT 8
89977: PUSH
89978: LD_INT 9
89980: PUSH
89981: LD_INT 10
89983: PUSH
89984: LD_INT 11
89986: PUSH
89987: LD_INT 12
89989: PUSH
89990: LD_INT 13
89992: PUSH
89993: LD_INT 14
89995: PUSH
89996: LD_INT 15
89998: PUSH
89999: LD_INT 16
90001: PUSH
90002: LD_INT 17
90004: PUSH
90005: LD_INT 18
90007: PUSH
90008: LD_INT 19
90010: PUSH
90011: LD_INT 20
90013: PUSH
90014: LD_INT 21
90016: PUSH
90017: LD_INT 22
90019: PUSH
90020: LD_INT 23
90022: PUSH
90023: LD_INT 24
90025: PUSH
90026: LD_INT 25
90028: PUSH
90029: LD_INT 26
90031: PUSH
90032: LD_INT 28
90034: PUSH
90035: LD_INT 30
90037: PUSH
90038: LD_INT 31
90040: PUSH
90041: LD_INT 32
90043: PUSH
90044: LD_INT 34
90046: PUSH
90047: LD_INT 36
90049: PUSH
90050: EMPTY
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 101
90085: PUSH
90086: LD_INT 102
90088: PUSH
90089: LD_INT 103
90091: PUSH
90092: LD_INT 104
90094: PUSH
90095: LD_INT 105
90097: PUSH
90098: LD_INT 106
90100: PUSH
90101: LD_INT 107
90103: PUSH
90104: LD_INT 108
90106: PUSH
90107: LD_INT 109
90109: PUSH
90110: LD_INT 110
90112: PUSH
90113: LD_INT 111
90115: PUSH
90116: LD_INT 112
90118: PUSH
90119: LD_INT 114
90121: PUSH
90122: EMPTY
90123: LIST
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: LIST
90134: LIST
90135: LIST
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: ST_TO_ADDR
90141: GO 91728
90143: LD_INT 12
90145: DOUBLE
90146: EQUAL
90147: IFTRUE 90151
90149: GO 90359
90151: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
90152: LD_ADDR_VAR 0 1
90156: PUSH
90157: LD_INT 1
90159: PUSH
90160: LD_INT 2
90162: PUSH
90163: LD_INT 3
90165: PUSH
90166: LD_INT 4
90168: PUSH
90169: LD_INT 5
90171: PUSH
90172: LD_INT 6
90174: PUSH
90175: LD_INT 7
90177: PUSH
90178: LD_INT 8
90180: PUSH
90181: LD_INT 9
90183: PUSH
90184: LD_INT 10
90186: PUSH
90187: LD_INT 11
90189: PUSH
90190: LD_INT 12
90192: PUSH
90193: LD_INT 13
90195: PUSH
90196: LD_INT 14
90198: PUSH
90199: LD_INT 15
90201: PUSH
90202: LD_INT 16
90204: PUSH
90205: LD_INT 17
90207: PUSH
90208: LD_INT 18
90210: PUSH
90211: LD_INT 19
90213: PUSH
90214: LD_INT 20
90216: PUSH
90217: LD_INT 21
90219: PUSH
90220: LD_INT 22
90222: PUSH
90223: LD_INT 23
90225: PUSH
90226: LD_INT 24
90228: PUSH
90229: LD_INT 25
90231: PUSH
90232: LD_INT 26
90234: PUSH
90235: LD_INT 27
90237: PUSH
90238: LD_INT 28
90240: PUSH
90241: LD_INT 30
90243: PUSH
90244: LD_INT 31
90246: PUSH
90247: LD_INT 32
90249: PUSH
90250: LD_INT 33
90252: PUSH
90253: LD_INT 34
90255: PUSH
90256: LD_INT 36
90258: PUSH
90259: EMPTY
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 101
90297: PUSH
90298: LD_INT 102
90300: PUSH
90301: LD_INT 103
90303: PUSH
90304: LD_INT 104
90306: PUSH
90307: LD_INT 105
90309: PUSH
90310: LD_INT 106
90312: PUSH
90313: LD_INT 107
90315: PUSH
90316: LD_INT 108
90318: PUSH
90319: LD_INT 109
90321: PUSH
90322: LD_INT 110
90324: PUSH
90325: LD_INT 111
90327: PUSH
90328: LD_INT 112
90330: PUSH
90331: LD_INT 113
90333: PUSH
90334: LD_INT 114
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: ST_TO_ADDR
90357: GO 91728
90359: LD_INT 13
90361: DOUBLE
90362: EQUAL
90363: IFTRUE 90367
90365: GO 90563
90367: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
90368: LD_ADDR_VAR 0 1
90372: PUSH
90373: LD_INT 1
90375: PUSH
90376: LD_INT 2
90378: PUSH
90379: LD_INT 3
90381: PUSH
90382: LD_INT 4
90384: PUSH
90385: LD_INT 5
90387: PUSH
90388: LD_INT 8
90390: PUSH
90391: LD_INT 9
90393: PUSH
90394: LD_INT 10
90396: PUSH
90397: LD_INT 11
90399: PUSH
90400: LD_INT 12
90402: PUSH
90403: LD_INT 14
90405: PUSH
90406: LD_INT 15
90408: PUSH
90409: LD_INT 16
90411: PUSH
90412: LD_INT 17
90414: PUSH
90415: LD_INT 18
90417: PUSH
90418: LD_INT 19
90420: PUSH
90421: LD_INT 20
90423: PUSH
90424: LD_INT 21
90426: PUSH
90427: LD_INT 22
90429: PUSH
90430: LD_INT 23
90432: PUSH
90433: LD_INT 24
90435: PUSH
90436: LD_INT 25
90438: PUSH
90439: LD_INT 26
90441: PUSH
90442: LD_INT 27
90444: PUSH
90445: LD_INT 28
90447: PUSH
90448: LD_INT 30
90450: PUSH
90451: LD_INT 31
90453: PUSH
90454: LD_INT 32
90456: PUSH
90457: LD_INT 33
90459: PUSH
90460: LD_INT 34
90462: PUSH
90463: LD_INT 36
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: LIST
90488: LIST
90489: LIST
90490: LIST
90491: LIST
90492: LIST
90493: LIST
90494: LIST
90495: LIST
90496: LIST
90497: LIST
90498: PUSH
90499: LD_INT 101
90501: PUSH
90502: LD_INT 102
90504: PUSH
90505: LD_INT 103
90507: PUSH
90508: LD_INT 104
90510: PUSH
90511: LD_INT 105
90513: PUSH
90514: LD_INT 106
90516: PUSH
90517: LD_INT 107
90519: PUSH
90520: LD_INT 108
90522: PUSH
90523: LD_INT 109
90525: PUSH
90526: LD_INT 110
90528: PUSH
90529: LD_INT 111
90531: PUSH
90532: LD_INT 112
90534: PUSH
90535: LD_INT 113
90537: PUSH
90538: LD_INT 114
90540: PUSH
90541: EMPTY
90542: LIST
90543: LIST
90544: LIST
90545: LIST
90546: LIST
90547: LIST
90548: LIST
90549: LIST
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: ST_TO_ADDR
90561: GO 91728
90563: LD_INT 14
90565: DOUBLE
90566: EQUAL
90567: IFTRUE 90571
90569: GO 90783
90571: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
90572: LD_ADDR_VAR 0 1
90576: PUSH
90577: LD_INT 1
90579: PUSH
90580: LD_INT 2
90582: PUSH
90583: LD_INT 3
90585: PUSH
90586: LD_INT 4
90588: PUSH
90589: LD_INT 5
90591: PUSH
90592: LD_INT 6
90594: PUSH
90595: LD_INT 7
90597: PUSH
90598: LD_INT 8
90600: PUSH
90601: LD_INT 9
90603: PUSH
90604: LD_INT 10
90606: PUSH
90607: LD_INT 11
90609: PUSH
90610: LD_INT 12
90612: PUSH
90613: LD_INT 13
90615: PUSH
90616: LD_INT 14
90618: PUSH
90619: LD_INT 15
90621: PUSH
90622: LD_INT 16
90624: PUSH
90625: LD_INT 17
90627: PUSH
90628: LD_INT 18
90630: PUSH
90631: LD_INT 19
90633: PUSH
90634: LD_INT 20
90636: PUSH
90637: LD_INT 21
90639: PUSH
90640: LD_INT 22
90642: PUSH
90643: LD_INT 23
90645: PUSH
90646: LD_INT 24
90648: PUSH
90649: LD_INT 25
90651: PUSH
90652: LD_INT 26
90654: PUSH
90655: LD_INT 27
90657: PUSH
90658: LD_INT 28
90660: PUSH
90661: LD_INT 29
90663: PUSH
90664: LD_INT 30
90666: PUSH
90667: LD_INT 31
90669: PUSH
90670: LD_INT 32
90672: PUSH
90673: LD_INT 33
90675: PUSH
90676: LD_INT 34
90678: PUSH
90679: LD_INT 36
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: LIST
90717: LIST
90718: PUSH
90719: LD_INT 101
90721: PUSH
90722: LD_INT 102
90724: PUSH
90725: LD_INT 103
90727: PUSH
90728: LD_INT 104
90730: PUSH
90731: LD_INT 105
90733: PUSH
90734: LD_INT 106
90736: PUSH
90737: LD_INT 107
90739: PUSH
90740: LD_INT 108
90742: PUSH
90743: LD_INT 109
90745: PUSH
90746: LD_INT 110
90748: PUSH
90749: LD_INT 111
90751: PUSH
90752: LD_INT 112
90754: PUSH
90755: LD_INT 113
90757: PUSH
90758: LD_INT 114
90760: PUSH
90761: EMPTY
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: LIST
90775: LIST
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: ST_TO_ADDR
90781: GO 91728
90783: LD_INT 15
90785: DOUBLE
90786: EQUAL
90787: IFTRUE 90791
90789: GO 91003
90791: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
90792: LD_ADDR_VAR 0 1
90796: PUSH
90797: LD_INT 1
90799: PUSH
90800: LD_INT 2
90802: PUSH
90803: LD_INT 3
90805: PUSH
90806: LD_INT 4
90808: PUSH
90809: LD_INT 5
90811: PUSH
90812: LD_INT 6
90814: PUSH
90815: LD_INT 7
90817: PUSH
90818: LD_INT 8
90820: PUSH
90821: LD_INT 9
90823: PUSH
90824: LD_INT 10
90826: PUSH
90827: LD_INT 11
90829: PUSH
90830: LD_INT 12
90832: PUSH
90833: LD_INT 13
90835: PUSH
90836: LD_INT 14
90838: PUSH
90839: LD_INT 15
90841: PUSH
90842: LD_INT 16
90844: PUSH
90845: LD_INT 17
90847: PUSH
90848: LD_INT 18
90850: PUSH
90851: LD_INT 19
90853: PUSH
90854: LD_INT 20
90856: PUSH
90857: LD_INT 21
90859: PUSH
90860: LD_INT 22
90862: PUSH
90863: LD_INT 23
90865: PUSH
90866: LD_INT 24
90868: PUSH
90869: LD_INT 25
90871: PUSH
90872: LD_INT 26
90874: PUSH
90875: LD_INT 27
90877: PUSH
90878: LD_INT 28
90880: PUSH
90881: LD_INT 29
90883: PUSH
90884: LD_INT 30
90886: PUSH
90887: LD_INT 31
90889: PUSH
90890: LD_INT 32
90892: PUSH
90893: LD_INT 33
90895: PUSH
90896: LD_INT 34
90898: PUSH
90899: LD_INT 36
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: LIST
90911: LIST
90912: LIST
90913: LIST
90914: LIST
90915: LIST
90916: LIST
90917: LIST
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: LIST
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: PUSH
90939: LD_INT 101
90941: PUSH
90942: LD_INT 102
90944: PUSH
90945: LD_INT 103
90947: PUSH
90948: LD_INT 104
90950: PUSH
90951: LD_INT 105
90953: PUSH
90954: LD_INT 106
90956: PUSH
90957: LD_INT 107
90959: PUSH
90960: LD_INT 108
90962: PUSH
90963: LD_INT 109
90965: PUSH
90966: LD_INT 110
90968: PUSH
90969: LD_INT 111
90971: PUSH
90972: LD_INT 112
90974: PUSH
90975: LD_INT 113
90977: PUSH
90978: LD_INT 114
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: ST_TO_ADDR
91001: GO 91728
91003: LD_INT 16
91005: DOUBLE
91006: EQUAL
91007: IFTRUE 91011
91009: GO 91135
91011: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
91012: LD_ADDR_VAR 0 1
91016: PUSH
91017: LD_INT 2
91019: PUSH
91020: LD_INT 4
91022: PUSH
91023: LD_INT 5
91025: PUSH
91026: LD_INT 7
91028: PUSH
91029: LD_INT 11
91031: PUSH
91032: LD_INT 12
91034: PUSH
91035: LD_INT 15
91037: PUSH
91038: LD_INT 16
91040: PUSH
91041: LD_INT 20
91043: PUSH
91044: LD_INT 21
91046: PUSH
91047: LD_INT 22
91049: PUSH
91050: LD_INT 23
91052: PUSH
91053: LD_INT 25
91055: PUSH
91056: LD_INT 26
91058: PUSH
91059: LD_INT 30
91061: PUSH
91062: LD_INT 31
91064: PUSH
91065: LD_INT 32
91067: PUSH
91068: LD_INT 33
91070: PUSH
91071: LD_INT 34
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: LIST
91078: LIST
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: PUSH
91095: LD_INT 101
91097: PUSH
91098: LD_INT 102
91100: PUSH
91101: LD_INT 103
91103: PUSH
91104: LD_INT 106
91106: PUSH
91107: LD_INT 108
91109: PUSH
91110: LD_INT 112
91112: PUSH
91113: LD_INT 113
91115: PUSH
91116: LD_INT 114
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: LIST
91123: LIST
91124: LIST
91125: LIST
91126: LIST
91127: LIST
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: ST_TO_ADDR
91133: GO 91728
91135: LD_INT 17
91137: DOUBLE
91138: EQUAL
91139: IFTRUE 91143
91141: GO 91355
91143: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
91144: LD_ADDR_VAR 0 1
91148: PUSH
91149: LD_INT 1
91151: PUSH
91152: LD_INT 2
91154: PUSH
91155: LD_INT 3
91157: PUSH
91158: LD_INT 4
91160: PUSH
91161: LD_INT 5
91163: PUSH
91164: LD_INT 6
91166: PUSH
91167: LD_INT 7
91169: PUSH
91170: LD_INT 8
91172: PUSH
91173: LD_INT 9
91175: PUSH
91176: LD_INT 10
91178: PUSH
91179: LD_INT 11
91181: PUSH
91182: LD_INT 12
91184: PUSH
91185: LD_INT 13
91187: PUSH
91188: LD_INT 14
91190: PUSH
91191: LD_INT 15
91193: PUSH
91194: LD_INT 16
91196: PUSH
91197: LD_INT 17
91199: PUSH
91200: LD_INT 18
91202: PUSH
91203: LD_INT 19
91205: PUSH
91206: LD_INT 20
91208: PUSH
91209: LD_INT 21
91211: PUSH
91212: LD_INT 22
91214: PUSH
91215: LD_INT 23
91217: PUSH
91218: LD_INT 24
91220: PUSH
91221: LD_INT 25
91223: PUSH
91224: LD_INT 26
91226: PUSH
91227: LD_INT 27
91229: PUSH
91230: LD_INT 28
91232: PUSH
91233: LD_INT 29
91235: PUSH
91236: LD_INT 30
91238: PUSH
91239: LD_INT 31
91241: PUSH
91242: LD_INT 32
91244: PUSH
91245: LD_INT 33
91247: PUSH
91248: LD_INT 34
91250: PUSH
91251: LD_INT 36
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 101
91293: PUSH
91294: LD_INT 102
91296: PUSH
91297: LD_INT 103
91299: PUSH
91300: LD_INT 104
91302: PUSH
91303: LD_INT 105
91305: PUSH
91306: LD_INT 106
91308: PUSH
91309: LD_INT 107
91311: PUSH
91312: LD_INT 108
91314: PUSH
91315: LD_INT 109
91317: PUSH
91318: LD_INT 110
91320: PUSH
91321: LD_INT 111
91323: PUSH
91324: LD_INT 112
91326: PUSH
91327: LD_INT 113
91329: PUSH
91330: LD_INT 114
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: PUSH
91349: EMPTY
91350: LIST
91351: LIST
91352: ST_TO_ADDR
91353: GO 91728
91355: LD_INT 18
91357: DOUBLE
91358: EQUAL
91359: IFTRUE 91363
91361: GO 91499
91363: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
91364: LD_ADDR_VAR 0 1
91368: PUSH
91369: LD_INT 2
91371: PUSH
91372: LD_INT 4
91374: PUSH
91375: LD_INT 5
91377: PUSH
91378: LD_INT 7
91380: PUSH
91381: LD_INT 11
91383: PUSH
91384: LD_INT 12
91386: PUSH
91387: LD_INT 15
91389: PUSH
91390: LD_INT 16
91392: PUSH
91393: LD_INT 20
91395: PUSH
91396: LD_INT 21
91398: PUSH
91399: LD_INT 22
91401: PUSH
91402: LD_INT 23
91404: PUSH
91405: LD_INT 25
91407: PUSH
91408: LD_INT 26
91410: PUSH
91411: LD_INT 30
91413: PUSH
91414: LD_INT 31
91416: PUSH
91417: LD_INT 32
91419: PUSH
91420: LD_INT 33
91422: PUSH
91423: LD_INT 34
91425: PUSH
91426: LD_INT 35
91428: PUSH
91429: LD_INT 36
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: PUSH
91455: LD_INT 101
91457: PUSH
91458: LD_INT 102
91460: PUSH
91461: LD_INT 103
91463: PUSH
91464: LD_INT 106
91466: PUSH
91467: LD_INT 108
91469: PUSH
91470: LD_INT 112
91472: PUSH
91473: LD_INT 113
91475: PUSH
91476: LD_INT 114
91478: PUSH
91479: LD_INT 115
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: LIST
91486: LIST
91487: LIST
91488: LIST
91489: LIST
91490: LIST
91491: LIST
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: ST_TO_ADDR
91497: GO 91728
91499: LD_INT 19
91501: DOUBLE
91502: EQUAL
91503: IFTRUE 91507
91505: GO 91727
91507: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
91508: LD_ADDR_VAR 0 1
91512: PUSH
91513: LD_INT 1
91515: PUSH
91516: LD_INT 2
91518: PUSH
91519: LD_INT 3
91521: PUSH
91522: LD_INT 4
91524: PUSH
91525: LD_INT 5
91527: PUSH
91528: LD_INT 6
91530: PUSH
91531: LD_INT 7
91533: PUSH
91534: LD_INT 8
91536: PUSH
91537: LD_INT 9
91539: PUSH
91540: LD_INT 10
91542: PUSH
91543: LD_INT 11
91545: PUSH
91546: LD_INT 12
91548: PUSH
91549: LD_INT 13
91551: PUSH
91552: LD_INT 14
91554: PUSH
91555: LD_INT 15
91557: PUSH
91558: LD_INT 16
91560: PUSH
91561: LD_INT 17
91563: PUSH
91564: LD_INT 18
91566: PUSH
91567: LD_INT 19
91569: PUSH
91570: LD_INT 20
91572: PUSH
91573: LD_INT 21
91575: PUSH
91576: LD_INT 22
91578: PUSH
91579: LD_INT 23
91581: PUSH
91582: LD_INT 24
91584: PUSH
91585: LD_INT 25
91587: PUSH
91588: LD_INT 26
91590: PUSH
91591: LD_INT 27
91593: PUSH
91594: LD_INT 28
91596: PUSH
91597: LD_INT 29
91599: PUSH
91600: LD_INT 30
91602: PUSH
91603: LD_INT 31
91605: PUSH
91606: LD_INT 32
91608: PUSH
91609: LD_INT 33
91611: PUSH
91612: LD_INT 34
91614: PUSH
91615: LD_INT 35
91617: PUSH
91618: LD_INT 36
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: LIST
91642: LIST
91643: LIST
91644: LIST
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: LIST
91653: LIST
91654: LIST
91655: LIST
91656: LIST
91657: LIST
91658: PUSH
91659: LD_INT 101
91661: PUSH
91662: LD_INT 102
91664: PUSH
91665: LD_INT 103
91667: PUSH
91668: LD_INT 104
91670: PUSH
91671: LD_INT 105
91673: PUSH
91674: LD_INT 106
91676: PUSH
91677: LD_INT 107
91679: PUSH
91680: LD_INT 108
91682: PUSH
91683: LD_INT 109
91685: PUSH
91686: LD_INT 110
91688: PUSH
91689: LD_INT 111
91691: PUSH
91692: LD_INT 112
91694: PUSH
91695: LD_INT 113
91697: PUSH
91698: LD_INT 114
91700: PUSH
91701: LD_INT 115
91703: PUSH
91704: EMPTY
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: LIST
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: ST_TO_ADDR
91725: GO 91728
91727: POP
// end else
91728: GO 91947
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
91730: LD_ADDR_VAR 0 1
91734: PUSH
91735: LD_INT 1
91737: PUSH
91738: LD_INT 2
91740: PUSH
91741: LD_INT 3
91743: PUSH
91744: LD_INT 4
91746: PUSH
91747: LD_INT 5
91749: PUSH
91750: LD_INT 6
91752: PUSH
91753: LD_INT 7
91755: PUSH
91756: LD_INT 8
91758: PUSH
91759: LD_INT 9
91761: PUSH
91762: LD_INT 10
91764: PUSH
91765: LD_INT 11
91767: PUSH
91768: LD_INT 12
91770: PUSH
91771: LD_INT 13
91773: PUSH
91774: LD_INT 14
91776: PUSH
91777: LD_INT 15
91779: PUSH
91780: LD_INT 16
91782: PUSH
91783: LD_INT 17
91785: PUSH
91786: LD_INT 18
91788: PUSH
91789: LD_INT 19
91791: PUSH
91792: LD_INT 20
91794: PUSH
91795: LD_INT 21
91797: PUSH
91798: LD_INT 22
91800: PUSH
91801: LD_INT 23
91803: PUSH
91804: LD_INT 24
91806: PUSH
91807: LD_INT 25
91809: PUSH
91810: LD_INT 26
91812: PUSH
91813: LD_INT 27
91815: PUSH
91816: LD_INT 28
91818: PUSH
91819: LD_INT 29
91821: PUSH
91822: LD_INT 30
91824: PUSH
91825: LD_INT 31
91827: PUSH
91828: LD_INT 32
91830: PUSH
91831: LD_INT 33
91833: PUSH
91834: LD_INT 34
91836: PUSH
91837: LD_INT 35
91839: PUSH
91840: LD_INT 36
91842: PUSH
91843: EMPTY
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: LIST
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: PUSH
91881: LD_INT 101
91883: PUSH
91884: LD_INT 102
91886: PUSH
91887: LD_INT 103
91889: PUSH
91890: LD_INT 104
91892: PUSH
91893: LD_INT 105
91895: PUSH
91896: LD_INT 106
91898: PUSH
91899: LD_INT 107
91901: PUSH
91902: LD_INT 108
91904: PUSH
91905: LD_INT 109
91907: PUSH
91908: LD_INT 110
91910: PUSH
91911: LD_INT 111
91913: PUSH
91914: LD_INT 112
91916: PUSH
91917: LD_INT 113
91919: PUSH
91920: LD_INT 114
91922: PUSH
91923: LD_INT 115
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: PUSH
91943: EMPTY
91944: LIST
91945: LIST
91946: ST_TO_ADDR
// if result then
91947: LD_VAR 0 1
91951: IFFALSE 92240
// begin normal :=  ;
91953: LD_ADDR_VAR 0 3
91957: PUSH
91958: LD_STRING 
91960: ST_TO_ADDR
// hardcore :=  ;
91961: LD_ADDR_VAR 0 4
91965: PUSH
91966: LD_STRING 
91968: ST_TO_ADDR
// for i = 1 to normalCounter do
91969: LD_ADDR_VAR 0 5
91973: PUSH
91974: DOUBLE
91975: LD_INT 1
91977: DEC
91978: ST_TO_ADDR
91979: LD_EXP 133
91983: PUSH
91984: FOR_TO
91985: IFFALSE 92086
// begin tmp := 0 ;
91987: LD_ADDR_VAR 0 2
91991: PUSH
91992: LD_STRING 0
91994: ST_TO_ADDR
// if result [ 1 ] then
91995: LD_VAR 0 1
91999: PUSH
92000: LD_INT 1
92002: ARRAY
92003: IFFALSE 92068
// if result [ 1 ] [ 1 ] = i then
92005: LD_VAR 0 1
92009: PUSH
92010: LD_INT 1
92012: ARRAY
92013: PUSH
92014: LD_INT 1
92016: ARRAY
92017: PUSH
92018: LD_VAR 0 5
92022: EQUAL
92023: IFFALSE 92068
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92025: LD_ADDR_VAR 0 1
92029: PUSH
92030: LD_VAR 0 1
92034: PPUSH
92035: LD_INT 1
92037: PPUSH
92038: LD_VAR 0 1
92042: PUSH
92043: LD_INT 1
92045: ARRAY
92046: PPUSH
92047: LD_INT 1
92049: PPUSH
92050: CALL_OW 3
92054: PPUSH
92055: CALL_OW 1
92059: ST_TO_ADDR
// tmp := 1 ;
92060: LD_ADDR_VAR 0 2
92064: PUSH
92065: LD_STRING 1
92067: ST_TO_ADDR
// end ; normal := normal & tmp ;
92068: LD_ADDR_VAR 0 3
92072: PUSH
92073: LD_VAR 0 3
92077: PUSH
92078: LD_VAR 0 2
92082: STR
92083: ST_TO_ADDR
// end ;
92084: GO 91984
92086: POP
92087: POP
// for i = 1 to hardcoreCounter do
92088: LD_ADDR_VAR 0 5
92092: PUSH
92093: DOUBLE
92094: LD_INT 1
92096: DEC
92097: ST_TO_ADDR
92098: LD_EXP 134
92102: PUSH
92103: FOR_TO
92104: IFFALSE 92209
// begin tmp := 0 ;
92106: LD_ADDR_VAR 0 2
92110: PUSH
92111: LD_STRING 0
92113: ST_TO_ADDR
// if result [ 2 ] then
92114: LD_VAR 0 1
92118: PUSH
92119: LD_INT 2
92121: ARRAY
92122: IFFALSE 92191
// if result [ 2 ] [ 1 ] = 100 + i then
92124: LD_VAR 0 1
92128: PUSH
92129: LD_INT 2
92131: ARRAY
92132: PUSH
92133: LD_INT 1
92135: ARRAY
92136: PUSH
92137: LD_INT 100
92139: PUSH
92140: LD_VAR 0 5
92144: PLUS
92145: EQUAL
92146: IFFALSE 92191
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92148: LD_ADDR_VAR 0 1
92152: PUSH
92153: LD_VAR 0 1
92157: PPUSH
92158: LD_INT 2
92160: PPUSH
92161: LD_VAR 0 1
92165: PUSH
92166: LD_INT 2
92168: ARRAY
92169: PPUSH
92170: LD_INT 1
92172: PPUSH
92173: CALL_OW 3
92177: PPUSH
92178: CALL_OW 1
92182: ST_TO_ADDR
// tmp := 1 ;
92183: LD_ADDR_VAR 0 2
92187: PUSH
92188: LD_STRING 1
92190: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92191: LD_ADDR_VAR 0 4
92195: PUSH
92196: LD_VAR 0 4
92200: PUSH
92201: LD_VAR 0 2
92205: STR
92206: ST_TO_ADDR
// end ;
92207: GO 92103
92209: POP
92210: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
92211: LD_STRING getStreamItemsFromMission("
92213: PUSH
92214: LD_VAR 0 3
92218: STR
92219: PUSH
92220: LD_STRING ","
92222: STR
92223: PUSH
92224: LD_VAR 0 4
92228: STR
92229: PUSH
92230: LD_STRING ")
92232: STR
92233: PPUSH
92234: CALL_OW 559
// end else
92238: GO 92247
// ToLua ( getStreamItemsFromMission("","") ) ;
92240: LD_STRING getStreamItemsFromMission("","")
92242: PPUSH
92243: CALL_OW 559
// end ;
92247: LD_VAR 0 1
92251: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92252: LD_EXP 132
92256: PUSH
92257: LD_EXP 137
92261: AND
92262: IFFALSE 92386
92264: GO 92266
92266: DISABLE
92267: LD_INT 0
92269: PPUSH
92270: PPUSH
// begin enable ;
92271: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92272: LD_ADDR_VAR 0 2
92276: PUSH
92277: LD_INT 22
92279: PUSH
92280: LD_OWVAR 2
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: PUSH
92289: LD_INT 2
92291: PUSH
92292: LD_INT 34
92294: PUSH
92295: LD_INT 7
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: PUSH
92302: LD_INT 34
92304: PUSH
92305: LD_INT 45
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: PUSH
92312: LD_INT 34
92314: PUSH
92315: LD_INT 28
92317: PUSH
92318: EMPTY
92319: LIST
92320: LIST
92321: PUSH
92322: LD_INT 34
92324: PUSH
92325: LD_INT 47
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: EMPTY
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: PPUSH
92343: CALL_OW 69
92347: ST_TO_ADDR
// if not tmp then
92348: LD_VAR 0 2
92352: NOT
92353: IFFALSE 92357
// exit ;
92355: GO 92386
// for i in tmp do
92357: LD_ADDR_VAR 0 1
92361: PUSH
92362: LD_VAR 0 2
92366: PUSH
92367: FOR_IN
92368: IFFALSE 92384
// begin SetLives ( i , 0 ) ;
92370: LD_VAR 0 1
92374: PPUSH
92375: LD_INT 0
92377: PPUSH
92378: CALL_OW 234
// end ;
92382: GO 92367
92384: POP
92385: POP
// end ;
92386: PPOPN 2
92388: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92389: LD_EXP 132
92393: PUSH
92394: LD_EXP 138
92398: AND
92399: IFFALSE 92483
92401: GO 92403
92403: DISABLE
92404: LD_INT 0
92406: PPUSH
92407: PPUSH
// begin enable ;
92408: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92409: LD_ADDR_VAR 0 2
92413: PUSH
92414: LD_INT 22
92416: PUSH
92417: LD_OWVAR 2
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: LD_INT 32
92428: PUSH
92429: LD_INT 3
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: EMPTY
92437: LIST
92438: LIST
92439: PPUSH
92440: CALL_OW 69
92444: ST_TO_ADDR
// if not tmp then
92445: LD_VAR 0 2
92449: NOT
92450: IFFALSE 92454
// exit ;
92452: GO 92483
// for i in tmp do
92454: LD_ADDR_VAR 0 1
92458: PUSH
92459: LD_VAR 0 2
92463: PUSH
92464: FOR_IN
92465: IFFALSE 92481
// begin SetLives ( i , 0 ) ;
92467: LD_VAR 0 1
92471: PPUSH
92472: LD_INT 0
92474: PPUSH
92475: CALL_OW 234
// end ;
92479: GO 92464
92481: POP
92482: POP
// end ;
92483: PPOPN 2
92485: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92486: LD_EXP 132
92490: PUSH
92491: LD_EXP 135
92495: AND
92496: IFFALSE 92589
92498: GO 92500
92500: DISABLE
92501: LD_INT 0
92503: PPUSH
// begin enable ;
92504: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92505: LD_ADDR_VAR 0 1
92509: PUSH
92510: LD_INT 22
92512: PUSH
92513: LD_OWVAR 2
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: PUSH
92522: LD_INT 2
92524: PUSH
92525: LD_INT 25
92527: PUSH
92528: LD_INT 5
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 25
92537: PUSH
92538: LD_INT 9
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: PUSH
92545: LD_INT 25
92547: PUSH
92548: LD_INT 8
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: PPUSH
92565: CALL_OW 69
92569: PUSH
92570: FOR_IN
92571: IFFALSE 92587
// begin SetClass ( i , 1 ) ;
92573: LD_VAR 0 1
92577: PPUSH
92578: LD_INT 1
92580: PPUSH
92581: CALL_OW 336
// end ;
92585: GO 92570
92587: POP
92588: POP
// end ;
92589: PPOPN 1
92591: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92592: LD_EXP 132
92596: PUSH
92597: LD_EXP 136
92601: AND
92602: PUSH
92603: LD_OWVAR 65
92607: PUSH
92608: LD_INT 7
92610: LESS
92611: AND
92612: IFFALSE 92626
92614: GO 92616
92616: DISABLE
// begin enable ;
92617: ENABLE
// game_speed := 7 ;
92618: LD_ADDR_OWVAR 65
92622: PUSH
92623: LD_INT 7
92625: ST_TO_ADDR
// end ;
92626: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92627: LD_EXP 132
92631: PUSH
92632: LD_EXP 139
92636: AND
92637: IFFALSE 92839
92639: GO 92641
92641: DISABLE
92642: LD_INT 0
92644: PPUSH
92645: PPUSH
92646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92647: LD_ADDR_VAR 0 3
92651: PUSH
92652: LD_INT 81
92654: PUSH
92655: LD_OWVAR 2
92659: PUSH
92660: EMPTY
92661: LIST
92662: LIST
92663: PUSH
92664: LD_INT 21
92666: PUSH
92667: LD_INT 1
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: PPUSH
92678: CALL_OW 69
92682: ST_TO_ADDR
// if not tmp then
92683: LD_VAR 0 3
92687: NOT
92688: IFFALSE 92692
// exit ;
92690: GO 92839
// if tmp > 5 then
92692: LD_VAR 0 3
92696: PUSH
92697: LD_INT 5
92699: GREATER
92700: IFFALSE 92712
// k := 5 else
92702: LD_ADDR_VAR 0 2
92706: PUSH
92707: LD_INT 5
92709: ST_TO_ADDR
92710: GO 92722
// k := tmp ;
92712: LD_ADDR_VAR 0 2
92716: PUSH
92717: LD_VAR 0 3
92721: ST_TO_ADDR
// for i := 1 to k do
92722: LD_ADDR_VAR 0 1
92726: PUSH
92727: DOUBLE
92728: LD_INT 1
92730: DEC
92731: ST_TO_ADDR
92732: LD_VAR 0 2
92736: PUSH
92737: FOR_TO
92738: IFFALSE 92837
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92740: LD_VAR 0 3
92744: PUSH
92745: LD_VAR 0 1
92749: ARRAY
92750: PPUSH
92751: LD_VAR 0 1
92755: PUSH
92756: LD_INT 4
92758: MOD
92759: PUSH
92760: LD_INT 1
92762: PLUS
92763: PPUSH
92764: CALL_OW 259
92768: PUSH
92769: LD_INT 10
92771: LESS
92772: IFFALSE 92835
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92774: LD_VAR 0 3
92778: PUSH
92779: LD_VAR 0 1
92783: ARRAY
92784: PPUSH
92785: LD_VAR 0 1
92789: PUSH
92790: LD_INT 4
92792: MOD
92793: PUSH
92794: LD_INT 1
92796: PLUS
92797: PPUSH
92798: LD_VAR 0 3
92802: PUSH
92803: LD_VAR 0 1
92807: ARRAY
92808: PPUSH
92809: LD_VAR 0 1
92813: PUSH
92814: LD_INT 4
92816: MOD
92817: PUSH
92818: LD_INT 1
92820: PLUS
92821: PPUSH
92822: CALL_OW 259
92826: PUSH
92827: LD_INT 1
92829: PLUS
92830: PPUSH
92831: CALL_OW 237
92835: GO 92737
92837: POP
92838: POP
// end ;
92839: PPOPN 3
92841: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92842: LD_EXP 132
92846: PUSH
92847: LD_EXP 140
92851: AND
92852: IFFALSE 92872
92854: GO 92856
92856: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92857: LD_INT 4
92859: PPUSH
92860: LD_OWVAR 2
92864: PPUSH
92865: LD_INT 0
92867: PPUSH
92868: CALL_OW 324
92872: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92873: LD_EXP 132
92877: PUSH
92878: LD_EXP 169
92882: AND
92883: IFFALSE 92903
92885: GO 92887
92887: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92888: LD_INT 19
92890: PPUSH
92891: LD_OWVAR 2
92895: PPUSH
92896: LD_INT 0
92898: PPUSH
92899: CALL_OW 324
92903: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92904: LD_EXP 132
92908: PUSH
92909: LD_EXP 141
92913: AND
92914: IFFALSE 93016
92916: GO 92918
92918: DISABLE
92919: LD_INT 0
92921: PPUSH
92922: PPUSH
// begin enable ;
92923: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92924: LD_ADDR_VAR 0 2
92928: PUSH
92929: LD_INT 22
92931: PUSH
92932: LD_OWVAR 2
92936: PUSH
92937: EMPTY
92938: LIST
92939: LIST
92940: PUSH
92941: LD_INT 2
92943: PUSH
92944: LD_INT 34
92946: PUSH
92947: LD_INT 11
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: PUSH
92954: LD_INT 34
92956: PUSH
92957: LD_INT 30
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: LIST
92968: PUSH
92969: EMPTY
92970: LIST
92971: LIST
92972: PPUSH
92973: CALL_OW 69
92977: ST_TO_ADDR
// if not tmp then
92978: LD_VAR 0 2
92982: NOT
92983: IFFALSE 92987
// exit ;
92985: GO 93016
// for i in tmp do
92987: LD_ADDR_VAR 0 1
92991: PUSH
92992: LD_VAR 0 2
92996: PUSH
92997: FOR_IN
92998: IFFALSE 93014
// begin SetLives ( i , 0 ) ;
93000: LD_VAR 0 1
93004: PPUSH
93005: LD_INT 0
93007: PPUSH
93008: CALL_OW 234
// end ;
93012: GO 92997
93014: POP
93015: POP
// end ;
93016: PPOPN 2
93018: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93019: LD_EXP 132
93023: PUSH
93024: LD_EXP 142
93028: AND
93029: IFFALSE 93049
93031: GO 93033
93033: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93034: LD_INT 32
93036: PPUSH
93037: LD_OWVAR 2
93041: PPUSH
93042: LD_INT 0
93044: PPUSH
93045: CALL_OW 324
93049: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93050: LD_EXP 132
93054: PUSH
93055: LD_EXP 143
93059: AND
93060: IFFALSE 93241
93062: GO 93064
93064: DISABLE
93065: LD_INT 0
93067: PPUSH
93068: PPUSH
93069: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93070: LD_ADDR_VAR 0 2
93074: PUSH
93075: LD_INT 22
93077: PUSH
93078: LD_OWVAR 2
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 33
93089: PUSH
93090: LD_INT 3
93092: PUSH
93093: EMPTY
93094: LIST
93095: LIST
93096: PUSH
93097: EMPTY
93098: LIST
93099: LIST
93100: PPUSH
93101: CALL_OW 69
93105: ST_TO_ADDR
// if not tmp then
93106: LD_VAR 0 2
93110: NOT
93111: IFFALSE 93115
// exit ;
93113: GO 93241
// side := 0 ;
93115: LD_ADDR_VAR 0 3
93119: PUSH
93120: LD_INT 0
93122: ST_TO_ADDR
// for i := 1 to 8 do
93123: LD_ADDR_VAR 0 1
93127: PUSH
93128: DOUBLE
93129: LD_INT 1
93131: DEC
93132: ST_TO_ADDR
93133: LD_INT 8
93135: PUSH
93136: FOR_TO
93137: IFFALSE 93185
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93139: LD_OWVAR 2
93143: PUSH
93144: LD_VAR 0 1
93148: NONEQUAL
93149: PUSH
93150: LD_OWVAR 2
93154: PPUSH
93155: LD_VAR 0 1
93159: PPUSH
93160: CALL_OW 81
93164: PUSH
93165: LD_INT 2
93167: EQUAL
93168: AND
93169: IFFALSE 93183
// begin side := i ;
93171: LD_ADDR_VAR 0 3
93175: PUSH
93176: LD_VAR 0 1
93180: ST_TO_ADDR
// break ;
93181: GO 93185
// end ;
93183: GO 93136
93185: POP
93186: POP
// if not side then
93187: LD_VAR 0 3
93191: NOT
93192: IFFALSE 93196
// exit ;
93194: GO 93241
// for i := 1 to tmp do
93196: LD_ADDR_VAR 0 1
93200: PUSH
93201: DOUBLE
93202: LD_INT 1
93204: DEC
93205: ST_TO_ADDR
93206: LD_VAR 0 2
93210: PUSH
93211: FOR_TO
93212: IFFALSE 93239
// if Prob ( 60 ) then
93214: LD_INT 60
93216: PPUSH
93217: CALL_OW 13
93221: IFFALSE 93237
// SetSide ( i , side ) ;
93223: LD_VAR 0 1
93227: PPUSH
93228: LD_VAR 0 3
93232: PPUSH
93233: CALL_OW 235
93237: GO 93211
93239: POP
93240: POP
// end ;
93241: PPOPN 3
93243: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93244: LD_EXP 132
93248: PUSH
93249: LD_EXP 145
93253: AND
93254: IFFALSE 93373
93256: GO 93258
93258: DISABLE
93259: LD_INT 0
93261: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93262: LD_ADDR_VAR 0 1
93266: PUSH
93267: LD_INT 22
93269: PUSH
93270: LD_OWVAR 2
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: LD_INT 21
93281: PUSH
93282: LD_INT 1
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PUSH
93289: LD_INT 3
93291: PUSH
93292: LD_INT 23
93294: PUSH
93295: LD_INT 0
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: EMPTY
93307: LIST
93308: LIST
93309: LIST
93310: PPUSH
93311: CALL_OW 69
93315: PUSH
93316: FOR_IN
93317: IFFALSE 93371
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93319: LD_VAR 0 1
93323: PPUSH
93324: CALL_OW 257
93328: PUSH
93329: LD_INT 1
93331: PUSH
93332: LD_INT 2
93334: PUSH
93335: LD_INT 3
93337: PUSH
93338: LD_INT 4
93340: PUSH
93341: EMPTY
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: IN
93347: IFFALSE 93369
// SetClass ( un , rand ( 1 , 4 ) ) ;
93349: LD_VAR 0 1
93353: PPUSH
93354: LD_INT 1
93356: PPUSH
93357: LD_INT 4
93359: PPUSH
93360: CALL_OW 12
93364: PPUSH
93365: CALL_OW 336
93369: GO 93316
93371: POP
93372: POP
// end ;
93373: PPOPN 1
93375: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93376: LD_EXP 132
93380: PUSH
93381: LD_EXP 144
93385: AND
93386: IFFALSE 93465
93388: GO 93390
93390: DISABLE
93391: LD_INT 0
93393: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93394: LD_ADDR_VAR 0 1
93398: PUSH
93399: LD_INT 22
93401: PUSH
93402: LD_OWVAR 2
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: PUSH
93411: LD_INT 21
93413: PUSH
93414: LD_INT 3
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PPUSH
93425: CALL_OW 69
93429: ST_TO_ADDR
// if not tmp then
93430: LD_VAR 0 1
93434: NOT
93435: IFFALSE 93439
// exit ;
93437: GO 93465
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93439: LD_VAR 0 1
93443: PUSH
93444: LD_INT 1
93446: PPUSH
93447: LD_VAR 0 1
93451: PPUSH
93452: CALL_OW 12
93456: ARRAY
93457: PPUSH
93458: LD_INT 100
93460: PPUSH
93461: CALL_OW 234
// end ;
93465: PPOPN 1
93467: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93468: LD_EXP 132
93472: PUSH
93473: LD_EXP 146
93477: AND
93478: IFFALSE 93576
93480: GO 93482
93482: DISABLE
93483: LD_INT 0
93485: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93486: LD_ADDR_VAR 0 1
93490: PUSH
93491: LD_INT 22
93493: PUSH
93494: LD_OWVAR 2
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: PUSH
93503: LD_INT 21
93505: PUSH
93506: LD_INT 1
93508: PUSH
93509: EMPTY
93510: LIST
93511: LIST
93512: PUSH
93513: EMPTY
93514: LIST
93515: LIST
93516: PPUSH
93517: CALL_OW 69
93521: ST_TO_ADDR
// if not tmp then
93522: LD_VAR 0 1
93526: NOT
93527: IFFALSE 93531
// exit ;
93529: GO 93576
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93531: LD_VAR 0 1
93535: PUSH
93536: LD_INT 1
93538: PPUSH
93539: LD_VAR 0 1
93543: PPUSH
93544: CALL_OW 12
93548: ARRAY
93549: PPUSH
93550: LD_INT 1
93552: PPUSH
93553: LD_INT 4
93555: PPUSH
93556: CALL_OW 12
93560: PPUSH
93561: LD_INT 3000
93563: PPUSH
93564: LD_INT 9000
93566: PPUSH
93567: CALL_OW 12
93571: PPUSH
93572: CALL_OW 492
// end ;
93576: PPOPN 1
93578: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93579: LD_EXP 132
93583: PUSH
93584: LD_EXP 147
93588: AND
93589: IFFALSE 93609
93591: GO 93593
93593: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93594: LD_INT 1
93596: PPUSH
93597: LD_OWVAR 2
93601: PPUSH
93602: LD_INT 0
93604: PPUSH
93605: CALL_OW 324
93609: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93610: LD_EXP 132
93614: PUSH
93615: LD_EXP 148
93619: AND
93620: IFFALSE 93703
93622: GO 93624
93624: DISABLE
93625: LD_INT 0
93627: PPUSH
93628: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93629: LD_ADDR_VAR 0 2
93633: PUSH
93634: LD_INT 22
93636: PUSH
93637: LD_OWVAR 2
93641: PUSH
93642: EMPTY
93643: LIST
93644: LIST
93645: PUSH
93646: LD_INT 21
93648: PUSH
93649: LD_INT 3
93651: PUSH
93652: EMPTY
93653: LIST
93654: LIST
93655: PUSH
93656: EMPTY
93657: LIST
93658: LIST
93659: PPUSH
93660: CALL_OW 69
93664: ST_TO_ADDR
// if not tmp then
93665: LD_VAR 0 2
93669: NOT
93670: IFFALSE 93674
// exit ;
93672: GO 93703
// for i in tmp do
93674: LD_ADDR_VAR 0 1
93678: PUSH
93679: LD_VAR 0 2
93683: PUSH
93684: FOR_IN
93685: IFFALSE 93701
// SetBLevel ( i , 10 ) ;
93687: LD_VAR 0 1
93691: PPUSH
93692: LD_INT 10
93694: PPUSH
93695: CALL_OW 241
93699: GO 93684
93701: POP
93702: POP
// end ;
93703: PPOPN 2
93705: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93706: LD_EXP 132
93710: PUSH
93711: LD_EXP 149
93715: AND
93716: IFFALSE 93827
93718: GO 93720
93720: DISABLE
93721: LD_INT 0
93723: PPUSH
93724: PPUSH
93725: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93726: LD_ADDR_VAR 0 3
93730: PUSH
93731: LD_INT 22
93733: PUSH
93734: LD_OWVAR 2
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: LD_INT 25
93745: PUSH
93746: LD_INT 1
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PPUSH
93757: CALL_OW 69
93761: ST_TO_ADDR
// if not tmp then
93762: LD_VAR 0 3
93766: NOT
93767: IFFALSE 93771
// exit ;
93769: GO 93827
// un := tmp [ rand ( 1 , tmp ) ] ;
93771: LD_ADDR_VAR 0 2
93775: PUSH
93776: LD_VAR 0 3
93780: PUSH
93781: LD_INT 1
93783: PPUSH
93784: LD_VAR 0 3
93788: PPUSH
93789: CALL_OW 12
93793: ARRAY
93794: ST_TO_ADDR
// if Crawls ( un ) then
93795: LD_VAR 0 2
93799: PPUSH
93800: CALL_OW 318
93804: IFFALSE 93815
// ComWalk ( un ) ;
93806: LD_VAR 0 2
93810: PPUSH
93811: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93815: LD_VAR 0 2
93819: PPUSH
93820: LD_INT 5
93822: PPUSH
93823: CALL_OW 336
// end ;
93827: PPOPN 3
93829: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
93830: LD_EXP 132
93834: PUSH
93835: LD_EXP 150
93839: AND
93840: PUSH
93841: LD_OWVAR 67
93845: PUSH
93846: LD_INT 3
93848: LESS
93849: AND
93850: IFFALSE 93869
93852: GO 93854
93854: DISABLE
// Difficulty := Difficulty + 1 ;
93855: LD_ADDR_OWVAR 67
93859: PUSH
93860: LD_OWVAR 67
93864: PUSH
93865: LD_INT 1
93867: PLUS
93868: ST_TO_ADDR
93869: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93870: LD_EXP 132
93874: PUSH
93875: LD_EXP 151
93879: AND
93880: IFFALSE 93983
93882: GO 93884
93884: DISABLE
93885: LD_INT 0
93887: PPUSH
// begin for i := 1 to 5 do
93888: LD_ADDR_VAR 0 1
93892: PUSH
93893: DOUBLE
93894: LD_INT 1
93896: DEC
93897: ST_TO_ADDR
93898: LD_INT 5
93900: PUSH
93901: FOR_TO
93902: IFFALSE 93981
// begin uc_nation := nation_nature ;
93904: LD_ADDR_OWVAR 21
93908: PUSH
93909: LD_INT 0
93911: ST_TO_ADDR
// uc_side := 0 ;
93912: LD_ADDR_OWVAR 20
93916: PUSH
93917: LD_INT 0
93919: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93920: LD_ADDR_OWVAR 29
93924: PUSH
93925: LD_INT 12
93927: PUSH
93928: LD_INT 12
93930: PUSH
93931: EMPTY
93932: LIST
93933: LIST
93934: ST_TO_ADDR
// hc_agressivity := 20 ;
93935: LD_ADDR_OWVAR 35
93939: PUSH
93940: LD_INT 20
93942: ST_TO_ADDR
// hc_class := class_tiger ;
93943: LD_ADDR_OWVAR 28
93947: PUSH
93948: LD_INT 14
93950: ST_TO_ADDR
// hc_gallery :=  ;
93951: LD_ADDR_OWVAR 33
93955: PUSH
93956: LD_STRING 
93958: ST_TO_ADDR
// hc_name :=  ;
93959: LD_ADDR_OWVAR 26
93963: PUSH
93964: LD_STRING 
93966: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93967: CALL_OW 44
93971: PPUSH
93972: LD_INT 0
93974: PPUSH
93975: CALL_OW 51
// end ;
93979: GO 93901
93981: POP
93982: POP
// end ;
93983: PPOPN 1
93985: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93986: LD_EXP 132
93990: PUSH
93991: LD_EXP 152
93995: AND
93996: IFFALSE 94005
93998: GO 94000
94000: DISABLE
// StreamSibBomb ;
94001: CALL 94006 0 0
94005: END
// export function StreamSibBomb ; var i , x , y ; begin
94006: LD_INT 0
94008: PPUSH
94009: PPUSH
94010: PPUSH
94011: PPUSH
// result := false ;
94012: LD_ADDR_VAR 0 1
94016: PUSH
94017: LD_INT 0
94019: ST_TO_ADDR
// for i := 1 to 16 do
94020: LD_ADDR_VAR 0 2
94024: PUSH
94025: DOUBLE
94026: LD_INT 1
94028: DEC
94029: ST_TO_ADDR
94030: LD_INT 16
94032: PUSH
94033: FOR_TO
94034: IFFALSE 94233
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94036: LD_ADDR_VAR 0 3
94040: PUSH
94041: LD_INT 10
94043: PUSH
94044: LD_INT 20
94046: PUSH
94047: LD_INT 30
94049: PUSH
94050: LD_INT 40
94052: PUSH
94053: LD_INT 50
94055: PUSH
94056: LD_INT 60
94058: PUSH
94059: LD_INT 70
94061: PUSH
94062: LD_INT 80
94064: PUSH
94065: LD_INT 90
94067: PUSH
94068: LD_INT 100
94070: PUSH
94071: LD_INT 110
94073: PUSH
94074: LD_INT 120
94076: PUSH
94077: LD_INT 130
94079: PUSH
94080: LD_INT 140
94082: PUSH
94083: LD_INT 150
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 1
94105: PPUSH
94106: LD_INT 15
94108: PPUSH
94109: CALL_OW 12
94113: ARRAY
94114: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94115: LD_ADDR_VAR 0 4
94119: PUSH
94120: LD_INT 10
94122: PUSH
94123: LD_INT 20
94125: PUSH
94126: LD_INT 30
94128: PUSH
94129: LD_INT 40
94131: PUSH
94132: LD_INT 50
94134: PUSH
94135: LD_INT 60
94137: PUSH
94138: LD_INT 70
94140: PUSH
94141: LD_INT 80
94143: PUSH
94144: LD_INT 90
94146: PUSH
94147: LD_INT 100
94149: PUSH
94150: LD_INT 110
94152: PUSH
94153: LD_INT 120
94155: PUSH
94156: LD_INT 130
94158: PUSH
94159: LD_INT 140
94161: PUSH
94162: LD_INT 150
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: PUSH
94182: LD_INT 1
94184: PPUSH
94185: LD_INT 15
94187: PPUSH
94188: CALL_OW 12
94192: ARRAY
94193: ST_TO_ADDR
// if ValidHex ( x , y ) then
94194: LD_VAR 0 3
94198: PPUSH
94199: LD_VAR 0 4
94203: PPUSH
94204: CALL_OW 488
94208: IFFALSE 94231
// begin result := [ x , y ] ;
94210: LD_ADDR_VAR 0 1
94214: PUSH
94215: LD_VAR 0 3
94219: PUSH
94220: LD_VAR 0 4
94224: PUSH
94225: EMPTY
94226: LIST
94227: LIST
94228: ST_TO_ADDR
// break ;
94229: GO 94233
// end ; end ;
94231: GO 94033
94233: POP
94234: POP
// if result then
94235: LD_VAR 0 1
94239: IFFALSE 94299
// begin ToLua ( playSibBomb() ) ;
94241: LD_STRING playSibBomb()
94243: PPUSH
94244: CALL_OW 559
// wait ( 0 0$14 ) ;
94248: LD_INT 490
94250: PPUSH
94251: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94255: LD_VAR 0 1
94259: PUSH
94260: LD_INT 1
94262: ARRAY
94263: PPUSH
94264: LD_VAR 0 1
94268: PUSH
94269: LD_INT 2
94271: ARRAY
94272: PPUSH
94273: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94277: LD_VAR 0 1
94281: PUSH
94282: LD_INT 1
94284: ARRAY
94285: PPUSH
94286: LD_VAR 0 1
94290: PUSH
94291: LD_INT 2
94293: ARRAY
94294: PPUSH
94295: CALL_OW 429
// end ; end ;
94299: LD_VAR 0 1
94303: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94304: LD_EXP 132
94308: PUSH
94309: LD_EXP 154
94313: AND
94314: IFFALSE 94326
94316: GO 94318
94318: DISABLE
// YouLost (  ) ;
94319: LD_STRING 
94321: PPUSH
94322: CALL_OW 104
94326: END
// every 0 0$1 trigger StreamModeActive and sFog do
94327: LD_EXP 132
94331: PUSH
94332: LD_EXP 153
94336: AND
94337: IFFALSE 94351
94339: GO 94341
94341: DISABLE
// FogOff ( your_side ) ;
94342: LD_OWVAR 2
94346: PPUSH
94347: CALL_OW 344
94351: END
// every 0 0$1 trigger StreamModeActive and sSun do
94352: LD_EXP 132
94356: PUSH
94357: LD_EXP 155
94361: AND
94362: IFFALSE 94390
94364: GO 94366
94366: DISABLE
// begin solar_recharge_percent := 0 ;
94367: LD_ADDR_OWVAR 79
94371: PUSH
94372: LD_INT 0
94374: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94375: LD_INT 10500
94377: PPUSH
94378: CALL_OW 67
// solar_recharge_percent := 100 ;
94382: LD_ADDR_OWVAR 79
94386: PUSH
94387: LD_INT 100
94389: ST_TO_ADDR
// end ;
94390: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94391: LD_EXP 132
94395: PUSH
94396: LD_EXP 156
94400: AND
94401: IFFALSE 94640
94403: GO 94405
94405: DISABLE
94406: LD_INT 0
94408: PPUSH
94409: PPUSH
94410: PPUSH
// begin tmp := [ ] ;
94411: LD_ADDR_VAR 0 3
94415: PUSH
94416: EMPTY
94417: ST_TO_ADDR
// for i := 1 to 6 do
94418: LD_ADDR_VAR 0 1
94422: PUSH
94423: DOUBLE
94424: LD_INT 1
94426: DEC
94427: ST_TO_ADDR
94428: LD_INT 6
94430: PUSH
94431: FOR_TO
94432: IFFALSE 94537
// begin uc_nation := nation_nature ;
94434: LD_ADDR_OWVAR 21
94438: PUSH
94439: LD_INT 0
94441: ST_TO_ADDR
// uc_side := 0 ;
94442: LD_ADDR_OWVAR 20
94446: PUSH
94447: LD_INT 0
94449: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94450: LD_ADDR_OWVAR 29
94454: PUSH
94455: LD_INT 12
94457: PUSH
94458: LD_INT 12
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: ST_TO_ADDR
// hc_agressivity := 20 ;
94465: LD_ADDR_OWVAR 35
94469: PUSH
94470: LD_INT 20
94472: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94473: LD_ADDR_OWVAR 28
94477: PUSH
94478: LD_INT 17
94480: ST_TO_ADDR
// hc_gallery :=  ;
94481: LD_ADDR_OWVAR 33
94485: PUSH
94486: LD_STRING 
94488: ST_TO_ADDR
// hc_name :=  ;
94489: LD_ADDR_OWVAR 26
94493: PUSH
94494: LD_STRING 
94496: ST_TO_ADDR
// un := CreateHuman ;
94497: LD_ADDR_VAR 0 2
94501: PUSH
94502: CALL_OW 44
94506: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94507: LD_VAR 0 2
94511: PPUSH
94512: LD_INT 1
94514: PPUSH
94515: CALL_OW 51
// tmp := tmp ^ un ;
94519: LD_ADDR_VAR 0 3
94523: PUSH
94524: LD_VAR 0 3
94528: PUSH
94529: LD_VAR 0 2
94533: ADD
94534: ST_TO_ADDR
// end ;
94535: GO 94431
94537: POP
94538: POP
// repeat wait ( 0 0$1 ) ;
94539: LD_INT 35
94541: PPUSH
94542: CALL_OW 67
// for un in tmp do
94546: LD_ADDR_VAR 0 2
94550: PUSH
94551: LD_VAR 0 3
94555: PUSH
94556: FOR_IN
94557: IFFALSE 94631
// begin if IsDead ( un ) then
94559: LD_VAR 0 2
94563: PPUSH
94564: CALL_OW 301
94568: IFFALSE 94588
// begin tmp := tmp diff un ;
94570: LD_ADDR_VAR 0 3
94574: PUSH
94575: LD_VAR 0 3
94579: PUSH
94580: LD_VAR 0 2
94584: DIFF
94585: ST_TO_ADDR
// continue ;
94586: GO 94556
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94588: LD_VAR 0 2
94592: PPUSH
94593: LD_INT 3
94595: PUSH
94596: LD_INT 22
94598: PUSH
94599: LD_INT 0
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: PUSH
94606: EMPTY
94607: LIST
94608: LIST
94609: PPUSH
94610: CALL_OW 69
94614: PPUSH
94615: LD_VAR 0 2
94619: PPUSH
94620: CALL_OW 74
94624: PPUSH
94625: CALL_OW 115
// end ;
94629: GO 94556
94631: POP
94632: POP
// until not tmp ;
94633: LD_VAR 0 3
94637: NOT
94638: IFFALSE 94539
// end ;
94640: PPOPN 3
94642: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94643: LD_EXP 132
94647: PUSH
94648: LD_EXP 157
94652: AND
94653: IFFALSE 94707
94655: GO 94657
94657: DISABLE
// begin ToLua ( displayTroll(); ) ;
94658: LD_STRING displayTroll();
94660: PPUSH
94661: CALL_OW 559
// wait ( 3 3$00 ) ;
94665: LD_INT 6300
94667: PPUSH
94668: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94672: LD_STRING hideTroll();
94674: PPUSH
94675: CALL_OW 559
// wait ( 1 1$00 ) ;
94679: LD_INT 2100
94681: PPUSH
94682: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94686: LD_STRING displayTroll();
94688: PPUSH
94689: CALL_OW 559
// wait ( 1 1$00 ) ;
94693: LD_INT 2100
94695: PPUSH
94696: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94700: LD_STRING hideTroll();
94702: PPUSH
94703: CALL_OW 559
// end ;
94707: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94708: LD_EXP 132
94712: PUSH
94713: LD_EXP 158
94717: AND
94718: IFFALSE 94781
94720: GO 94722
94722: DISABLE
94723: LD_INT 0
94725: PPUSH
// begin p := 0 ;
94726: LD_ADDR_VAR 0 1
94730: PUSH
94731: LD_INT 0
94733: ST_TO_ADDR
// repeat game_speed := 1 ;
94734: LD_ADDR_OWVAR 65
94738: PUSH
94739: LD_INT 1
94741: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94742: LD_INT 35
94744: PPUSH
94745: CALL_OW 67
// p := p + 1 ;
94749: LD_ADDR_VAR 0 1
94753: PUSH
94754: LD_VAR 0 1
94758: PUSH
94759: LD_INT 1
94761: PLUS
94762: ST_TO_ADDR
// until p >= 60 ;
94763: LD_VAR 0 1
94767: PUSH
94768: LD_INT 60
94770: GREATEREQUAL
94771: IFFALSE 94734
// game_speed := 4 ;
94773: LD_ADDR_OWVAR 65
94777: PUSH
94778: LD_INT 4
94780: ST_TO_ADDR
// end ;
94781: PPOPN 1
94783: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94784: LD_EXP 132
94788: PUSH
94789: LD_EXP 159
94793: AND
94794: IFFALSE 94940
94796: GO 94798
94798: DISABLE
94799: LD_INT 0
94801: PPUSH
94802: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94803: LD_ADDR_VAR 0 1
94807: PUSH
94808: LD_INT 22
94810: PUSH
94811: LD_OWVAR 2
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: PUSH
94820: LD_INT 2
94822: PUSH
94823: LD_INT 30
94825: PUSH
94826: LD_INT 0
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 30
94835: PUSH
94836: LD_INT 1
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: LIST
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: PPUSH
94852: CALL_OW 69
94856: ST_TO_ADDR
// if not depot then
94857: LD_VAR 0 1
94861: NOT
94862: IFFALSE 94866
// exit ;
94864: GO 94940
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94866: LD_ADDR_VAR 0 2
94870: PUSH
94871: LD_VAR 0 1
94875: PUSH
94876: LD_INT 1
94878: PPUSH
94879: LD_VAR 0 1
94883: PPUSH
94884: CALL_OW 12
94888: ARRAY
94889: PPUSH
94890: CALL_OW 274
94894: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94895: LD_VAR 0 2
94899: PPUSH
94900: LD_INT 1
94902: PPUSH
94903: LD_INT 0
94905: PPUSH
94906: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94910: LD_VAR 0 2
94914: PPUSH
94915: LD_INT 2
94917: PPUSH
94918: LD_INT 0
94920: PPUSH
94921: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94925: LD_VAR 0 2
94929: PPUSH
94930: LD_INT 3
94932: PPUSH
94933: LD_INT 0
94935: PPUSH
94936: CALL_OW 277
// end ;
94940: PPOPN 2
94942: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94943: LD_EXP 132
94947: PUSH
94948: LD_EXP 160
94952: AND
94953: IFFALSE 95050
94955: GO 94957
94957: DISABLE
94958: LD_INT 0
94960: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94961: LD_ADDR_VAR 0 1
94965: PUSH
94966: LD_INT 22
94968: PUSH
94969: LD_OWVAR 2
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PUSH
94978: LD_INT 21
94980: PUSH
94981: LD_INT 1
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 3
94990: PUSH
94991: LD_INT 23
94993: PUSH
94994: LD_INT 0
94996: PUSH
94997: EMPTY
94998: LIST
94999: LIST
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: PUSH
95005: EMPTY
95006: LIST
95007: LIST
95008: LIST
95009: PPUSH
95010: CALL_OW 69
95014: ST_TO_ADDR
// if not tmp then
95015: LD_VAR 0 1
95019: NOT
95020: IFFALSE 95024
// exit ;
95022: GO 95050
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95024: LD_VAR 0 1
95028: PUSH
95029: LD_INT 1
95031: PPUSH
95032: LD_VAR 0 1
95036: PPUSH
95037: CALL_OW 12
95041: ARRAY
95042: PPUSH
95043: LD_INT 200
95045: PPUSH
95046: CALL_OW 234
// end ;
95050: PPOPN 1
95052: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95053: LD_EXP 132
95057: PUSH
95058: LD_EXP 161
95062: AND
95063: IFFALSE 95142
95065: GO 95067
95067: DISABLE
95068: LD_INT 0
95070: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95071: LD_ADDR_VAR 0 1
95075: PUSH
95076: LD_INT 22
95078: PUSH
95079: LD_OWVAR 2
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: PUSH
95088: LD_INT 21
95090: PUSH
95091: LD_INT 2
95093: PUSH
95094: EMPTY
95095: LIST
95096: LIST
95097: PUSH
95098: EMPTY
95099: LIST
95100: LIST
95101: PPUSH
95102: CALL_OW 69
95106: ST_TO_ADDR
// if not tmp then
95107: LD_VAR 0 1
95111: NOT
95112: IFFALSE 95116
// exit ;
95114: GO 95142
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95116: LD_VAR 0 1
95120: PUSH
95121: LD_INT 1
95123: PPUSH
95124: LD_VAR 0 1
95128: PPUSH
95129: CALL_OW 12
95133: ARRAY
95134: PPUSH
95135: LD_INT 60
95137: PPUSH
95138: CALL_OW 234
// end ;
95142: PPOPN 1
95144: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95145: LD_EXP 132
95149: PUSH
95150: LD_EXP 162
95154: AND
95155: IFFALSE 95254
95157: GO 95159
95159: DISABLE
95160: LD_INT 0
95162: PPUSH
95163: PPUSH
// begin enable ;
95164: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95165: LD_ADDR_VAR 0 1
95169: PUSH
95170: LD_INT 22
95172: PUSH
95173: LD_OWVAR 2
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: PUSH
95182: LD_INT 61
95184: PUSH
95185: EMPTY
95186: LIST
95187: PUSH
95188: LD_INT 33
95190: PUSH
95191: LD_INT 2
95193: PUSH
95194: EMPTY
95195: LIST
95196: LIST
95197: PUSH
95198: EMPTY
95199: LIST
95200: LIST
95201: LIST
95202: PPUSH
95203: CALL_OW 69
95207: ST_TO_ADDR
// if not tmp then
95208: LD_VAR 0 1
95212: NOT
95213: IFFALSE 95217
// exit ;
95215: GO 95254
// for i in tmp do
95217: LD_ADDR_VAR 0 2
95221: PUSH
95222: LD_VAR 0 1
95226: PUSH
95227: FOR_IN
95228: IFFALSE 95252
// if IsControledBy ( i ) then
95230: LD_VAR 0 2
95234: PPUSH
95235: CALL_OW 312
95239: IFFALSE 95250
// ComUnlink ( i ) ;
95241: LD_VAR 0 2
95245: PPUSH
95246: CALL_OW 136
95250: GO 95227
95252: POP
95253: POP
// end ;
95254: PPOPN 2
95256: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95257: LD_EXP 132
95261: PUSH
95262: LD_EXP 163
95266: AND
95267: IFFALSE 95407
95269: GO 95271
95271: DISABLE
95272: LD_INT 0
95274: PPUSH
95275: PPUSH
// begin ToLua ( displayPowell(); ) ;
95276: LD_STRING displayPowell();
95278: PPUSH
95279: CALL_OW 559
// uc_side := 0 ;
95283: LD_ADDR_OWVAR 20
95287: PUSH
95288: LD_INT 0
95290: ST_TO_ADDR
// uc_nation := 2 ;
95291: LD_ADDR_OWVAR 21
95295: PUSH
95296: LD_INT 2
95298: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95299: LD_ADDR_OWVAR 37
95303: PUSH
95304: LD_INT 14
95306: ST_TO_ADDR
// vc_engine := engine_siberite ;
95307: LD_ADDR_OWVAR 39
95311: PUSH
95312: LD_INT 3
95314: ST_TO_ADDR
// vc_control := control_apeman ;
95315: LD_ADDR_OWVAR 38
95319: PUSH
95320: LD_INT 5
95322: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95323: LD_ADDR_OWVAR 40
95327: PUSH
95328: LD_INT 29
95330: ST_TO_ADDR
// un := CreateVehicle ;
95331: LD_ADDR_VAR 0 2
95335: PUSH
95336: CALL_OW 45
95340: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95341: LD_VAR 0 2
95345: PPUSH
95346: LD_INT 1
95348: PPUSH
95349: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95353: LD_INT 35
95355: PPUSH
95356: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95360: LD_VAR 0 2
95364: PPUSH
95365: LD_INT 22
95367: PUSH
95368: LD_OWVAR 2
95372: PUSH
95373: EMPTY
95374: LIST
95375: LIST
95376: PPUSH
95377: CALL_OW 69
95381: PPUSH
95382: LD_VAR 0 2
95386: PPUSH
95387: CALL_OW 74
95391: PPUSH
95392: CALL_OW 115
// until IsDead ( un ) ;
95396: LD_VAR 0 2
95400: PPUSH
95401: CALL_OW 301
95405: IFFALSE 95353
// end ;
95407: PPOPN 2
95409: END
// every 0 0$1 trigger StreamModeActive and sStu do
95410: LD_EXP 132
95414: PUSH
95415: LD_EXP 171
95419: AND
95420: IFFALSE 95436
95422: GO 95424
95424: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95425: LD_STRING displayStucuk();
95427: PPUSH
95428: CALL_OW 559
// ResetFog ;
95432: CALL_OW 335
// end ;
95436: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95437: LD_EXP 132
95441: PUSH
95442: LD_EXP 164
95446: AND
95447: IFFALSE 95588
95449: GO 95451
95451: DISABLE
95452: LD_INT 0
95454: PPUSH
95455: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95456: LD_ADDR_VAR 0 2
95460: PUSH
95461: LD_INT 22
95463: PUSH
95464: LD_OWVAR 2
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: PUSH
95473: LD_INT 21
95475: PUSH
95476: LD_INT 1
95478: PUSH
95479: EMPTY
95480: LIST
95481: LIST
95482: PUSH
95483: EMPTY
95484: LIST
95485: LIST
95486: PPUSH
95487: CALL_OW 69
95491: ST_TO_ADDR
// if not tmp then
95492: LD_VAR 0 2
95496: NOT
95497: IFFALSE 95501
// exit ;
95499: GO 95588
// un := tmp [ rand ( 1 , tmp ) ] ;
95501: LD_ADDR_VAR 0 1
95505: PUSH
95506: LD_VAR 0 2
95510: PUSH
95511: LD_INT 1
95513: PPUSH
95514: LD_VAR 0 2
95518: PPUSH
95519: CALL_OW 12
95523: ARRAY
95524: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95525: LD_VAR 0 1
95529: PPUSH
95530: LD_INT 0
95532: PPUSH
95533: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95537: LD_VAR 0 1
95541: PPUSH
95542: LD_OWVAR 3
95546: PUSH
95547: LD_VAR 0 1
95551: DIFF
95552: PPUSH
95553: LD_VAR 0 1
95557: PPUSH
95558: CALL_OW 74
95562: PPUSH
95563: CALL_OW 115
// wait ( 0 0$20 ) ;
95567: LD_INT 700
95569: PPUSH
95570: CALL_OW 67
// SetSide ( un , your_side ) ;
95574: LD_VAR 0 1
95578: PPUSH
95579: LD_OWVAR 2
95583: PPUSH
95584: CALL_OW 235
// end ;
95588: PPOPN 2
95590: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95591: LD_EXP 132
95595: PUSH
95596: LD_EXP 165
95600: AND
95601: IFFALSE 95707
95603: GO 95605
95605: DISABLE
95606: LD_INT 0
95608: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95609: LD_ADDR_VAR 0 1
95613: PUSH
95614: LD_INT 22
95616: PUSH
95617: LD_OWVAR 2
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: PUSH
95626: LD_INT 2
95628: PUSH
95629: LD_INT 30
95631: PUSH
95632: LD_INT 0
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: PUSH
95639: LD_INT 30
95641: PUSH
95642: LD_INT 1
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: LIST
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PPUSH
95658: CALL_OW 69
95662: ST_TO_ADDR
// if not depot then
95663: LD_VAR 0 1
95667: NOT
95668: IFFALSE 95672
// exit ;
95670: GO 95707
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95672: LD_VAR 0 1
95676: PUSH
95677: LD_INT 1
95679: ARRAY
95680: PPUSH
95681: CALL_OW 250
95685: PPUSH
95686: LD_VAR 0 1
95690: PUSH
95691: LD_INT 1
95693: ARRAY
95694: PPUSH
95695: CALL_OW 251
95699: PPUSH
95700: LD_INT 70
95702: PPUSH
95703: CALL_OW 495
// end ;
95707: PPOPN 1
95709: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95710: LD_EXP 132
95714: PUSH
95715: LD_EXP 166
95719: AND
95720: IFFALSE 95931
95722: GO 95724
95724: DISABLE
95725: LD_INT 0
95727: PPUSH
95728: PPUSH
95729: PPUSH
95730: PPUSH
95731: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95732: LD_ADDR_VAR 0 5
95736: PUSH
95737: LD_INT 22
95739: PUSH
95740: LD_OWVAR 2
95744: PUSH
95745: EMPTY
95746: LIST
95747: LIST
95748: PUSH
95749: LD_INT 21
95751: PUSH
95752: LD_INT 1
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: EMPTY
95760: LIST
95761: LIST
95762: PPUSH
95763: CALL_OW 69
95767: ST_TO_ADDR
// if not tmp then
95768: LD_VAR 0 5
95772: NOT
95773: IFFALSE 95777
// exit ;
95775: GO 95931
// for i in tmp do
95777: LD_ADDR_VAR 0 1
95781: PUSH
95782: LD_VAR 0 5
95786: PUSH
95787: FOR_IN
95788: IFFALSE 95929
// begin d := rand ( 0 , 5 ) ;
95790: LD_ADDR_VAR 0 4
95794: PUSH
95795: LD_INT 0
95797: PPUSH
95798: LD_INT 5
95800: PPUSH
95801: CALL_OW 12
95805: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95806: LD_ADDR_VAR 0 2
95810: PUSH
95811: LD_VAR 0 1
95815: PPUSH
95816: CALL_OW 250
95820: PPUSH
95821: LD_VAR 0 4
95825: PPUSH
95826: LD_INT 3
95828: PPUSH
95829: LD_INT 12
95831: PPUSH
95832: CALL_OW 12
95836: PPUSH
95837: CALL_OW 272
95841: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95842: LD_ADDR_VAR 0 3
95846: PUSH
95847: LD_VAR 0 1
95851: PPUSH
95852: CALL_OW 251
95856: PPUSH
95857: LD_VAR 0 4
95861: PPUSH
95862: LD_INT 3
95864: PPUSH
95865: LD_INT 12
95867: PPUSH
95868: CALL_OW 12
95872: PPUSH
95873: CALL_OW 273
95877: ST_TO_ADDR
// if ValidHex ( x , y ) then
95878: LD_VAR 0 2
95882: PPUSH
95883: LD_VAR 0 3
95887: PPUSH
95888: CALL_OW 488
95892: IFFALSE 95927
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95894: LD_VAR 0 1
95898: PPUSH
95899: LD_VAR 0 2
95903: PPUSH
95904: LD_VAR 0 3
95908: PPUSH
95909: LD_INT 3
95911: PPUSH
95912: LD_INT 6
95914: PPUSH
95915: CALL_OW 12
95919: PPUSH
95920: LD_INT 1
95922: PPUSH
95923: CALL_OW 483
// end ;
95927: GO 95787
95929: POP
95930: POP
// end ;
95931: PPOPN 5
95933: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95934: LD_EXP 132
95938: PUSH
95939: LD_EXP 167
95943: AND
95944: IFFALSE 96038
95946: GO 95948
95948: DISABLE
95949: LD_INT 0
95951: PPUSH
95952: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95953: LD_ADDR_VAR 0 2
95957: PUSH
95958: LD_INT 22
95960: PUSH
95961: LD_OWVAR 2
95965: PUSH
95966: EMPTY
95967: LIST
95968: LIST
95969: PUSH
95970: LD_INT 32
95972: PUSH
95973: LD_INT 1
95975: PUSH
95976: EMPTY
95977: LIST
95978: LIST
95979: PUSH
95980: LD_INT 21
95982: PUSH
95983: LD_INT 2
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: LIST
95994: PPUSH
95995: CALL_OW 69
95999: ST_TO_ADDR
// if not tmp then
96000: LD_VAR 0 2
96004: NOT
96005: IFFALSE 96009
// exit ;
96007: GO 96038
// for i in tmp do
96009: LD_ADDR_VAR 0 1
96013: PUSH
96014: LD_VAR 0 2
96018: PUSH
96019: FOR_IN
96020: IFFALSE 96036
// SetFuel ( i , 0 ) ;
96022: LD_VAR 0 1
96026: PPUSH
96027: LD_INT 0
96029: PPUSH
96030: CALL_OW 240
96034: GO 96019
96036: POP
96037: POP
// end ;
96038: PPOPN 2
96040: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96041: LD_EXP 132
96045: PUSH
96046: LD_EXP 168
96050: AND
96051: IFFALSE 96117
96053: GO 96055
96055: DISABLE
96056: LD_INT 0
96058: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96059: LD_ADDR_VAR 0 1
96063: PUSH
96064: LD_INT 22
96066: PUSH
96067: LD_OWVAR 2
96071: PUSH
96072: EMPTY
96073: LIST
96074: LIST
96075: PUSH
96076: LD_INT 30
96078: PUSH
96079: LD_INT 29
96081: PUSH
96082: EMPTY
96083: LIST
96084: LIST
96085: PUSH
96086: EMPTY
96087: LIST
96088: LIST
96089: PPUSH
96090: CALL_OW 69
96094: ST_TO_ADDR
// if not tmp then
96095: LD_VAR 0 1
96099: NOT
96100: IFFALSE 96104
// exit ;
96102: GO 96117
// DestroyUnit ( tmp [ 1 ] ) ;
96104: LD_VAR 0 1
96108: PUSH
96109: LD_INT 1
96111: ARRAY
96112: PPUSH
96113: CALL_OW 65
// end ;
96117: PPOPN 1
96119: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96120: LD_EXP 132
96124: PUSH
96125: LD_EXP 170
96129: AND
96130: IFFALSE 96259
96132: GO 96134
96134: DISABLE
96135: LD_INT 0
96137: PPUSH
// begin uc_side := 0 ;
96138: LD_ADDR_OWVAR 20
96142: PUSH
96143: LD_INT 0
96145: ST_TO_ADDR
// uc_nation := nation_arabian ;
96146: LD_ADDR_OWVAR 21
96150: PUSH
96151: LD_INT 2
96153: ST_TO_ADDR
// hc_gallery :=  ;
96154: LD_ADDR_OWVAR 33
96158: PUSH
96159: LD_STRING 
96161: ST_TO_ADDR
// hc_name :=  ;
96162: LD_ADDR_OWVAR 26
96166: PUSH
96167: LD_STRING 
96169: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96170: LD_INT 1
96172: PPUSH
96173: LD_INT 11
96175: PPUSH
96176: LD_INT 10
96178: PPUSH
96179: CALL_OW 380
// un := CreateHuman ;
96183: LD_ADDR_VAR 0 1
96187: PUSH
96188: CALL_OW 44
96192: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96193: LD_VAR 0 1
96197: PPUSH
96198: LD_INT 1
96200: PPUSH
96201: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96205: LD_INT 35
96207: PPUSH
96208: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96212: LD_VAR 0 1
96216: PPUSH
96217: LD_INT 22
96219: PUSH
96220: LD_OWVAR 2
96224: PUSH
96225: EMPTY
96226: LIST
96227: LIST
96228: PPUSH
96229: CALL_OW 69
96233: PPUSH
96234: LD_VAR 0 1
96238: PPUSH
96239: CALL_OW 74
96243: PPUSH
96244: CALL_OW 115
// until IsDead ( un ) ;
96248: LD_VAR 0 1
96252: PPUSH
96253: CALL_OW 301
96257: IFFALSE 96205
// end ;
96259: PPOPN 1
96261: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96262: LD_EXP 132
96266: PUSH
96267: LD_EXP 172
96271: AND
96272: IFFALSE 96284
96274: GO 96276
96276: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96277: LD_STRING earthquake(getX(game), 0, 32)
96279: PPUSH
96280: CALL_OW 559
96284: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96285: LD_EXP 132
96289: PUSH
96290: LD_EXP 173
96294: AND
96295: IFFALSE 96386
96297: GO 96299
96299: DISABLE
96300: LD_INT 0
96302: PPUSH
// begin enable ;
96303: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96304: LD_ADDR_VAR 0 1
96308: PUSH
96309: LD_INT 22
96311: PUSH
96312: LD_OWVAR 2
96316: PUSH
96317: EMPTY
96318: LIST
96319: LIST
96320: PUSH
96321: LD_INT 21
96323: PUSH
96324: LD_INT 2
96326: PUSH
96327: EMPTY
96328: LIST
96329: LIST
96330: PUSH
96331: LD_INT 33
96333: PUSH
96334: LD_INT 3
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: EMPTY
96342: LIST
96343: LIST
96344: LIST
96345: PPUSH
96346: CALL_OW 69
96350: ST_TO_ADDR
// if not tmp then
96351: LD_VAR 0 1
96355: NOT
96356: IFFALSE 96360
// exit ;
96358: GO 96386
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96360: LD_VAR 0 1
96364: PUSH
96365: LD_INT 1
96367: PPUSH
96368: LD_VAR 0 1
96372: PPUSH
96373: CALL_OW 12
96377: ARRAY
96378: PPUSH
96379: LD_INT 1
96381: PPUSH
96382: CALL_OW 234
// end ;
96386: PPOPN 1
96388: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96389: LD_EXP 132
96393: PUSH
96394: LD_EXP 174
96398: AND
96399: IFFALSE 96540
96401: GO 96403
96403: DISABLE
96404: LD_INT 0
96406: PPUSH
96407: PPUSH
96408: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96409: LD_ADDR_VAR 0 3
96413: PUSH
96414: LD_INT 22
96416: PUSH
96417: LD_OWVAR 2
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: PUSH
96426: LD_INT 25
96428: PUSH
96429: LD_INT 1
96431: PUSH
96432: EMPTY
96433: LIST
96434: LIST
96435: PUSH
96436: EMPTY
96437: LIST
96438: LIST
96439: PPUSH
96440: CALL_OW 69
96444: ST_TO_ADDR
// if not tmp then
96445: LD_VAR 0 3
96449: NOT
96450: IFFALSE 96454
// exit ;
96452: GO 96540
// un := tmp [ rand ( 1 , tmp ) ] ;
96454: LD_ADDR_VAR 0 2
96458: PUSH
96459: LD_VAR 0 3
96463: PUSH
96464: LD_INT 1
96466: PPUSH
96467: LD_VAR 0 3
96471: PPUSH
96472: CALL_OW 12
96476: ARRAY
96477: ST_TO_ADDR
// if Crawls ( un ) then
96478: LD_VAR 0 2
96482: PPUSH
96483: CALL_OW 318
96487: IFFALSE 96498
// ComWalk ( un ) ;
96489: LD_VAR 0 2
96493: PPUSH
96494: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96498: LD_VAR 0 2
96502: PPUSH
96503: LD_INT 9
96505: PPUSH
96506: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96510: LD_INT 28
96512: PPUSH
96513: LD_OWVAR 2
96517: PPUSH
96518: LD_INT 2
96520: PPUSH
96521: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96525: LD_INT 29
96527: PPUSH
96528: LD_OWVAR 2
96532: PPUSH
96533: LD_INT 2
96535: PPUSH
96536: CALL_OW 322
// end ;
96540: PPOPN 3
96542: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96543: LD_EXP 132
96547: PUSH
96548: LD_EXP 175
96552: AND
96553: IFFALSE 96664
96555: GO 96557
96557: DISABLE
96558: LD_INT 0
96560: PPUSH
96561: PPUSH
96562: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96563: LD_ADDR_VAR 0 3
96567: PUSH
96568: LD_INT 22
96570: PUSH
96571: LD_OWVAR 2
96575: PUSH
96576: EMPTY
96577: LIST
96578: LIST
96579: PUSH
96580: LD_INT 25
96582: PUSH
96583: LD_INT 1
96585: PUSH
96586: EMPTY
96587: LIST
96588: LIST
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: PPUSH
96594: CALL_OW 69
96598: ST_TO_ADDR
// if not tmp then
96599: LD_VAR 0 3
96603: NOT
96604: IFFALSE 96608
// exit ;
96606: GO 96664
// un := tmp [ rand ( 1 , tmp ) ] ;
96608: LD_ADDR_VAR 0 2
96612: PUSH
96613: LD_VAR 0 3
96617: PUSH
96618: LD_INT 1
96620: PPUSH
96621: LD_VAR 0 3
96625: PPUSH
96626: CALL_OW 12
96630: ARRAY
96631: ST_TO_ADDR
// if Crawls ( un ) then
96632: LD_VAR 0 2
96636: PPUSH
96637: CALL_OW 318
96641: IFFALSE 96652
// ComWalk ( un ) ;
96643: LD_VAR 0 2
96647: PPUSH
96648: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96652: LD_VAR 0 2
96656: PPUSH
96657: LD_INT 8
96659: PPUSH
96660: CALL_OW 336
// end ;
96664: PPOPN 3
96666: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96667: LD_EXP 132
96671: PUSH
96672: LD_EXP 176
96676: AND
96677: IFFALSE 96821
96679: GO 96681
96681: DISABLE
96682: LD_INT 0
96684: PPUSH
96685: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96686: LD_ADDR_VAR 0 2
96690: PUSH
96691: LD_INT 22
96693: PUSH
96694: LD_OWVAR 2
96698: PUSH
96699: EMPTY
96700: LIST
96701: LIST
96702: PUSH
96703: LD_INT 21
96705: PUSH
96706: LD_INT 2
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: PUSH
96713: LD_INT 2
96715: PUSH
96716: LD_INT 34
96718: PUSH
96719: LD_INT 12
96721: PUSH
96722: EMPTY
96723: LIST
96724: LIST
96725: PUSH
96726: LD_INT 34
96728: PUSH
96729: LD_INT 51
96731: PUSH
96732: EMPTY
96733: LIST
96734: LIST
96735: PUSH
96736: LD_INT 34
96738: PUSH
96739: LD_INT 32
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: EMPTY
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: LIST
96756: PPUSH
96757: CALL_OW 69
96761: ST_TO_ADDR
// if not tmp then
96762: LD_VAR 0 2
96766: NOT
96767: IFFALSE 96771
// exit ;
96769: GO 96821
// for i in tmp do
96771: LD_ADDR_VAR 0 1
96775: PUSH
96776: LD_VAR 0 2
96780: PUSH
96781: FOR_IN
96782: IFFALSE 96819
// if GetCargo ( i , mat_artifact ) = 0 then
96784: LD_VAR 0 1
96788: PPUSH
96789: LD_INT 4
96791: PPUSH
96792: CALL_OW 289
96796: PUSH
96797: LD_INT 0
96799: EQUAL
96800: IFFALSE 96817
// SetCargo ( i , mat_siberit , 100 ) ;
96802: LD_VAR 0 1
96806: PPUSH
96807: LD_INT 3
96809: PPUSH
96810: LD_INT 100
96812: PPUSH
96813: CALL_OW 290
96817: GO 96781
96819: POP
96820: POP
// end ;
96821: PPOPN 2
96823: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96824: LD_EXP 132
96828: PUSH
96829: LD_EXP 177
96833: AND
96834: IFFALSE 97017
96836: GO 96838
96838: DISABLE
96839: LD_INT 0
96841: PPUSH
96842: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96843: LD_ADDR_VAR 0 2
96847: PUSH
96848: LD_INT 22
96850: PUSH
96851: LD_OWVAR 2
96855: PUSH
96856: EMPTY
96857: LIST
96858: LIST
96859: PPUSH
96860: CALL_OW 69
96864: ST_TO_ADDR
// if not tmp then
96865: LD_VAR 0 2
96869: NOT
96870: IFFALSE 96874
// exit ;
96872: GO 97017
// for i := 1 to 2 do
96874: LD_ADDR_VAR 0 1
96878: PUSH
96879: DOUBLE
96880: LD_INT 1
96882: DEC
96883: ST_TO_ADDR
96884: LD_INT 2
96886: PUSH
96887: FOR_TO
96888: IFFALSE 97015
// begin uc_side := your_side ;
96890: LD_ADDR_OWVAR 20
96894: PUSH
96895: LD_OWVAR 2
96899: ST_TO_ADDR
// uc_nation := nation_american ;
96900: LD_ADDR_OWVAR 21
96904: PUSH
96905: LD_INT 1
96907: ST_TO_ADDR
// vc_chassis := us_morphling ;
96908: LD_ADDR_OWVAR 37
96912: PUSH
96913: LD_INT 5
96915: ST_TO_ADDR
// vc_engine := engine_siberite ;
96916: LD_ADDR_OWVAR 39
96920: PUSH
96921: LD_INT 3
96923: ST_TO_ADDR
// vc_control := control_computer ;
96924: LD_ADDR_OWVAR 38
96928: PUSH
96929: LD_INT 3
96931: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96932: LD_ADDR_OWVAR 40
96936: PUSH
96937: LD_INT 10
96939: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96940: LD_VAR 0 2
96944: PUSH
96945: LD_INT 1
96947: ARRAY
96948: PPUSH
96949: CALL_OW 310
96953: NOT
96954: IFFALSE 97001
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96956: CALL_OW 45
96960: PPUSH
96961: LD_VAR 0 2
96965: PUSH
96966: LD_INT 1
96968: ARRAY
96969: PPUSH
96970: CALL_OW 250
96974: PPUSH
96975: LD_VAR 0 2
96979: PUSH
96980: LD_INT 1
96982: ARRAY
96983: PPUSH
96984: CALL_OW 251
96988: PPUSH
96989: LD_INT 12
96991: PPUSH
96992: LD_INT 1
96994: PPUSH
96995: CALL_OW 50
96999: GO 97013
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97001: CALL_OW 45
97005: PPUSH
97006: LD_INT 1
97008: PPUSH
97009: CALL_OW 51
// end ;
97013: GO 96887
97015: POP
97016: POP
// end ;
97017: PPOPN 2
97019: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97020: LD_EXP 132
97024: PUSH
97025: LD_EXP 178
97029: AND
97030: IFFALSE 97252
97032: GO 97034
97034: DISABLE
97035: LD_INT 0
97037: PPUSH
97038: PPUSH
97039: PPUSH
97040: PPUSH
97041: PPUSH
97042: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97043: LD_ADDR_VAR 0 6
97047: PUSH
97048: LD_INT 22
97050: PUSH
97051: LD_OWVAR 2
97055: PUSH
97056: EMPTY
97057: LIST
97058: LIST
97059: PUSH
97060: LD_INT 21
97062: PUSH
97063: LD_INT 1
97065: PUSH
97066: EMPTY
97067: LIST
97068: LIST
97069: PUSH
97070: LD_INT 3
97072: PUSH
97073: LD_INT 23
97075: PUSH
97076: LD_INT 0
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: PUSH
97083: EMPTY
97084: LIST
97085: LIST
97086: PUSH
97087: EMPTY
97088: LIST
97089: LIST
97090: LIST
97091: PPUSH
97092: CALL_OW 69
97096: ST_TO_ADDR
// if not tmp then
97097: LD_VAR 0 6
97101: NOT
97102: IFFALSE 97106
// exit ;
97104: GO 97252
// s1 := rand ( 1 , 4 ) ;
97106: LD_ADDR_VAR 0 2
97110: PUSH
97111: LD_INT 1
97113: PPUSH
97114: LD_INT 4
97116: PPUSH
97117: CALL_OW 12
97121: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97122: LD_ADDR_VAR 0 4
97126: PUSH
97127: LD_VAR 0 6
97131: PUSH
97132: LD_INT 1
97134: ARRAY
97135: PPUSH
97136: LD_VAR 0 2
97140: PPUSH
97141: CALL_OW 259
97145: ST_TO_ADDR
// if s1 = 1 then
97146: LD_VAR 0 2
97150: PUSH
97151: LD_INT 1
97153: EQUAL
97154: IFFALSE 97174
// s2 := rand ( 2 , 4 ) else
97156: LD_ADDR_VAR 0 3
97160: PUSH
97161: LD_INT 2
97163: PPUSH
97164: LD_INT 4
97166: PPUSH
97167: CALL_OW 12
97171: ST_TO_ADDR
97172: GO 97182
// s2 := 1 ;
97174: LD_ADDR_VAR 0 3
97178: PUSH
97179: LD_INT 1
97181: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97182: LD_ADDR_VAR 0 5
97186: PUSH
97187: LD_VAR 0 6
97191: PUSH
97192: LD_INT 1
97194: ARRAY
97195: PPUSH
97196: LD_VAR 0 3
97200: PPUSH
97201: CALL_OW 259
97205: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97206: LD_VAR 0 6
97210: PUSH
97211: LD_INT 1
97213: ARRAY
97214: PPUSH
97215: LD_VAR 0 2
97219: PPUSH
97220: LD_VAR 0 5
97224: PPUSH
97225: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97229: LD_VAR 0 6
97233: PUSH
97234: LD_INT 1
97236: ARRAY
97237: PPUSH
97238: LD_VAR 0 3
97242: PPUSH
97243: LD_VAR 0 4
97247: PPUSH
97248: CALL_OW 237
// end ;
97252: PPOPN 6
97254: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97255: LD_EXP 132
97259: PUSH
97260: LD_EXP 179
97264: AND
97265: IFFALSE 97344
97267: GO 97269
97269: DISABLE
97270: LD_INT 0
97272: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97273: LD_ADDR_VAR 0 1
97277: PUSH
97278: LD_INT 22
97280: PUSH
97281: LD_OWVAR 2
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PUSH
97290: LD_INT 30
97292: PUSH
97293: LD_INT 3
97295: PUSH
97296: EMPTY
97297: LIST
97298: LIST
97299: PUSH
97300: EMPTY
97301: LIST
97302: LIST
97303: PPUSH
97304: CALL_OW 69
97308: ST_TO_ADDR
// if not tmp then
97309: LD_VAR 0 1
97313: NOT
97314: IFFALSE 97318
// exit ;
97316: GO 97344
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97318: LD_VAR 0 1
97322: PUSH
97323: LD_INT 1
97325: PPUSH
97326: LD_VAR 0 1
97330: PPUSH
97331: CALL_OW 12
97335: ARRAY
97336: PPUSH
97337: LD_INT 1
97339: PPUSH
97340: CALL_OW 234
// end ;
97344: PPOPN 1
97346: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97347: LD_EXP 132
97351: PUSH
97352: LD_EXP 180
97356: AND
97357: IFFALSE 97469
97359: GO 97361
97361: DISABLE
97362: LD_INT 0
97364: PPUSH
97365: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97366: LD_ADDR_VAR 0 2
97370: PUSH
97371: LD_INT 22
97373: PUSH
97374: LD_OWVAR 2
97378: PUSH
97379: EMPTY
97380: LIST
97381: LIST
97382: PUSH
97383: LD_INT 2
97385: PUSH
97386: LD_INT 30
97388: PUSH
97389: LD_INT 27
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: LD_INT 30
97398: PUSH
97399: LD_INT 26
97401: PUSH
97402: EMPTY
97403: LIST
97404: LIST
97405: PUSH
97406: LD_INT 30
97408: PUSH
97409: LD_INT 28
97411: PUSH
97412: EMPTY
97413: LIST
97414: LIST
97415: PUSH
97416: EMPTY
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: PPUSH
97426: CALL_OW 69
97430: ST_TO_ADDR
// if not tmp then
97431: LD_VAR 0 2
97435: NOT
97436: IFFALSE 97440
// exit ;
97438: GO 97469
// for i in tmp do
97440: LD_ADDR_VAR 0 1
97444: PUSH
97445: LD_VAR 0 2
97449: PUSH
97450: FOR_IN
97451: IFFALSE 97467
// SetLives ( i , 1 ) ;
97453: LD_VAR 0 1
97457: PPUSH
97458: LD_INT 1
97460: PPUSH
97461: CALL_OW 234
97465: GO 97450
97467: POP
97468: POP
// end ;
97469: PPOPN 2
97471: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97472: LD_EXP 132
97476: PUSH
97477: LD_EXP 181
97481: AND
97482: IFFALSE 97756
97484: GO 97486
97486: DISABLE
97487: LD_INT 0
97489: PPUSH
97490: PPUSH
97491: PPUSH
// begin i := rand ( 1 , 7 ) ;
97492: LD_ADDR_VAR 0 1
97496: PUSH
97497: LD_INT 1
97499: PPUSH
97500: LD_INT 7
97502: PPUSH
97503: CALL_OW 12
97507: ST_TO_ADDR
// case i of 1 :
97508: LD_VAR 0 1
97512: PUSH
97513: LD_INT 1
97515: DOUBLE
97516: EQUAL
97517: IFTRUE 97521
97519: GO 97531
97521: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97522: LD_STRING earthquake(getX(game), 0, 32)
97524: PPUSH
97525: CALL_OW 559
97529: GO 97756
97531: LD_INT 2
97533: DOUBLE
97534: EQUAL
97535: IFTRUE 97539
97537: GO 97553
97539: POP
// begin ToLua ( displayStucuk(); ) ;
97540: LD_STRING displayStucuk();
97542: PPUSH
97543: CALL_OW 559
// ResetFog ;
97547: CALL_OW 335
// end ; 3 :
97551: GO 97756
97553: LD_INT 3
97555: DOUBLE
97556: EQUAL
97557: IFTRUE 97561
97559: GO 97665
97561: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97562: LD_ADDR_VAR 0 2
97566: PUSH
97567: LD_INT 22
97569: PUSH
97570: LD_OWVAR 2
97574: PUSH
97575: EMPTY
97576: LIST
97577: LIST
97578: PUSH
97579: LD_INT 25
97581: PUSH
97582: LD_INT 1
97584: PUSH
97585: EMPTY
97586: LIST
97587: LIST
97588: PUSH
97589: EMPTY
97590: LIST
97591: LIST
97592: PPUSH
97593: CALL_OW 69
97597: ST_TO_ADDR
// if not tmp then
97598: LD_VAR 0 2
97602: NOT
97603: IFFALSE 97607
// exit ;
97605: GO 97756
// un := tmp [ rand ( 1 , tmp ) ] ;
97607: LD_ADDR_VAR 0 3
97611: PUSH
97612: LD_VAR 0 2
97616: PUSH
97617: LD_INT 1
97619: PPUSH
97620: LD_VAR 0 2
97624: PPUSH
97625: CALL_OW 12
97629: ARRAY
97630: ST_TO_ADDR
// if Crawls ( un ) then
97631: LD_VAR 0 3
97635: PPUSH
97636: CALL_OW 318
97640: IFFALSE 97651
// ComWalk ( un ) ;
97642: LD_VAR 0 3
97646: PPUSH
97647: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97651: LD_VAR 0 3
97655: PPUSH
97656: LD_INT 8
97658: PPUSH
97659: CALL_OW 336
// end ; 4 :
97663: GO 97756
97665: LD_INT 4
97667: DOUBLE
97668: EQUAL
97669: IFTRUE 97673
97671: GO 97734
97673: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97674: LD_ADDR_VAR 0 2
97678: PUSH
97679: LD_INT 22
97681: PUSH
97682: LD_OWVAR 2
97686: PUSH
97687: EMPTY
97688: LIST
97689: LIST
97690: PUSH
97691: LD_INT 30
97693: PUSH
97694: LD_INT 29
97696: PUSH
97697: EMPTY
97698: LIST
97699: LIST
97700: PUSH
97701: EMPTY
97702: LIST
97703: LIST
97704: PPUSH
97705: CALL_OW 69
97709: ST_TO_ADDR
// if not tmp then
97710: LD_VAR 0 2
97714: NOT
97715: IFFALSE 97719
// exit ;
97717: GO 97756
// DestroyUnit ( tmp [ 1 ] ) ;
97719: LD_VAR 0 2
97723: PUSH
97724: LD_INT 1
97726: ARRAY
97727: PPUSH
97728: CALL_OW 65
// end ; 5 .. 7 :
97732: GO 97756
97734: LD_INT 5
97736: DOUBLE
97737: GREATEREQUAL
97738: IFFALSE 97746
97740: LD_INT 7
97742: DOUBLE
97743: LESSEQUAL
97744: IFTRUE 97748
97746: GO 97755
97748: POP
// StreamSibBomb ; end ;
97749: CALL 94006 0 0
97753: GO 97756
97755: POP
// end ;
97756: PPOPN 3
97758: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97759: LD_EXP 132
97763: PUSH
97764: LD_EXP 182
97768: AND
97769: IFFALSE 97925
97771: GO 97773
97773: DISABLE
97774: LD_INT 0
97776: PPUSH
97777: PPUSH
97778: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97779: LD_ADDR_VAR 0 2
97783: PUSH
97784: LD_INT 81
97786: PUSH
97787: LD_OWVAR 2
97791: PUSH
97792: EMPTY
97793: LIST
97794: LIST
97795: PUSH
97796: LD_INT 2
97798: PUSH
97799: LD_INT 21
97801: PUSH
97802: LD_INT 1
97804: PUSH
97805: EMPTY
97806: LIST
97807: LIST
97808: PUSH
97809: LD_INT 21
97811: PUSH
97812: LD_INT 2
97814: PUSH
97815: EMPTY
97816: LIST
97817: LIST
97818: PUSH
97819: EMPTY
97820: LIST
97821: LIST
97822: LIST
97823: PUSH
97824: EMPTY
97825: LIST
97826: LIST
97827: PPUSH
97828: CALL_OW 69
97832: ST_TO_ADDR
// if not tmp then
97833: LD_VAR 0 2
97837: NOT
97838: IFFALSE 97842
// exit ;
97840: GO 97925
// p := 0 ;
97842: LD_ADDR_VAR 0 3
97846: PUSH
97847: LD_INT 0
97849: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97850: LD_INT 35
97852: PPUSH
97853: CALL_OW 67
// p := p + 1 ;
97857: LD_ADDR_VAR 0 3
97861: PUSH
97862: LD_VAR 0 3
97866: PUSH
97867: LD_INT 1
97869: PLUS
97870: ST_TO_ADDR
// for i in tmp do
97871: LD_ADDR_VAR 0 1
97875: PUSH
97876: LD_VAR 0 2
97880: PUSH
97881: FOR_IN
97882: IFFALSE 97913
// if GetLives ( i ) < 1000 then
97884: LD_VAR 0 1
97888: PPUSH
97889: CALL_OW 256
97893: PUSH
97894: LD_INT 1000
97896: LESS
97897: IFFALSE 97911
// SetLives ( i , 1000 ) ;
97899: LD_VAR 0 1
97903: PPUSH
97904: LD_INT 1000
97906: PPUSH
97907: CALL_OW 234
97911: GO 97881
97913: POP
97914: POP
// until p > 20 ;
97915: LD_VAR 0 3
97919: PUSH
97920: LD_INT 20
97922: GREATER
97923: IFFALSE 97850
// end ;
97925: PPOPN 3
97927: END
// every 0 0$1 trigger StreamModeActive and sTime do
97928: LD_EXP 132
97932: PUSH
97933: LD_EXP 183
97937: AND
97938: IFFALSE 97973
97940: GO 97942
97942: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97943: LD_INT 28
97945: PPUSH
97946: LD_OWVAR 2
97950: PPUSH
97951: LD_INT 2
97953: PPUSH
97954: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97958: LD_INT 30
97960: PPUSH
97961: LD_OWVAR 2
97965: PPUSH
97966: LD_INT 2
97968: PPUSH
97969: CALL_OW 322
// end ;
97973: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97974: LD_EXP 132
97978: PUSH
97979: LD_EXP 184
97983: AND
97984: IFFALSE 98105
97986: GO 97988
97988: DISABLE
97989: LD_INT 0
97991: PPUSH
97992: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97993: LD_ADDR_VAR 0 2
97997: PUSH
97998: LD_INT 22
98000: PUSH
98001: LD_OWVAR 2
98005: PUSH
98006: EMPTY
98007: LIST
98008: LIST
98009: PUSH
98010: LD_INT 21
98012: PUSH
98013: LD_INT 1
98015: PUSH
98016: EMPTY
98017: LIST
98018: LIST
98019: PUSH
98020: LD_INT 3
98022: PUSH
98023: LD_INT 23
98025: PUSH
98026: LD_INT 0
98028: PUSH
98029: EMPTY
98030: LIST
98031: LIST
98032: PUSH
98033: EMPTY
98034: LIST
98035: LIST
98036: PUSH
98037: EMPTY
98038: LIST
98039: LIST
98040: LIST
98041: PPUSH
98042: CALL_OW 69
98046: ST_TO_ADDR
// if not tmp then
98047: LD_VAR 0 2
98051: NOT
98052: IFFALSE 98056
// exit ;
98054: GO 98105
// for i in tmp do
98056: LD_ADDR_VAR 0 1
98060: PUSH
98061: LD_VAR 0 2
98065: PUSH
98066: FOR_IN
98067: IFFALSE 98103
// begin if Crawls ( i ) then
98069: LD_VAR 0 1
98073: PPUSH
98074: CALL_OW 318
98078: IFFALSE 98089
// ComWalk ( i ) ;
98080: LD_VAR 0 1
98084: PPUSH
98085: CALL_OW 138
// SetClass ( i , 2 ) ;
98089: LD_VAR 0 1
98093: PPUSH
98094: LD_INT 2
98096: PPUSH
98097: CALL_OW 336
// end ;
98101: GO 98066
98103: POP
98104: POP
// end ;
98105: PPOPN 2
98107: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98108: LD_EXP 132
98112: PUSH
98113: LD_EXP 185
98117: AND
98118: IFFALSE 98399
98120: GO 98122
98122: DISABLE
98123: LD_INT 0
98125: PPUSH
98126: PPUSH
98127: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98128: LD_OWVAR 2
98132: PPUSH
98133: LD_INT 9
98135: PPUSH
98136: LD_INT 1
98138: PPUSH
98139: LD_INT 1
98141: PPUSH
98142: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98146: LD_INT 9
98148: PPUSH
98149: LD_OWVAR 2
98153: PPUSH
98154: CALL_OW 343
// uc_side := 9 ;
98158: LD_ADDR_OWVAR 20
98162: PUSH
98163: LD_INT 9
98165: ST_TO_ADDR
// uc_nation := 2 ;
98166: LD_ADDR_OWVAR 21
98170: PUSH
98171: LD_INT 2
98173: ST_TO_ADDR
// hc_name := Dark Warrior ;
98174: LD_ADDR_OWVAR 26
98178: PUSH
98179: LD_STRING Dark Warrior
98181: ST_TO_ADDR
// hc_gallery :=  ;
98182: LD_ADDR_OWVAR 33
98186: PUSH
98187: LD_STRING 
98189: ST_TO_ADDR
// hc_noskilllimit := true ;
98190: LD_ADDR_OWVAR 76
98194: PUSH
98195: LD_INT 1
98197: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98198: LD_ADDR_OWVAR 31
98202: PUSH
98203: LD_INT 30
98205: PUSH
98206: LD_INT 30
98208: PUSH
98209: LD_INT 30
98211: PUSH
98212: LD_INT 30
98214: PUSH
98215: EMPTY
98216: LIST
98217: LIST
98218: LIST
98219: LIST
98220: ST_TO_ADDR
// un := CreateHuman ;
98221: LD_ADDR_VAR 0 3
98225: PUSH
98226: CALL_OW 44
98230: ST_TO_ADDR
// hc_noskilllimit := false ;
98231: LD_ADDR_OWVAR 76
98235: PUSH
98236: LD_INT 0
98238: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98239: LD_VAR 0 3
98243: PPUSH
98244: LD_INT 1
98246: PPUSH
98247: CALL_OW 51
// p := 0 ;
98251: LD_ADDR_VAR 0 2
98255: PUSH
98256: LD_INT 0
98258: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98259: LD_INT 35
98261: PPUSH
98262: CALL_OW 67
// p := p + 1 ;
98266: LD_ADDR_VAR 0 2
98270: PUSH
98271: LD_VAR 0 2
98275: PUSH
98276: LD_INT 1
98278: PLUS
98279: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98280: LD_VAR 0 3
98284: PPUSH
98285: CALL_OW 256
98289: PUSH
98290: LD_INT 1000
98292: LESS
98293: IFFALSE 98307
// SetLives ( un , 1000 ) ;
98295: LD_VAR 0 3
98299: PPUSH
98300: LD_INT 1000
98302: PPUSH
98303: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
98307: LD_VAR 0 3
98311: PPUSH
98312: LD_INT 81
98314: PUSH
98315: LD_OWVAR 2
98319: PUSH
98320: EMPTY
98321: LIST
98322: LIST
98323: PUSH
98324: LD_INT 91
98326: PUSH
98327: LD_VAR 0 3
98331: PUSH
98332: LD_INT 30
98334: PUSH
98335: EMPTY
98336: LIST
98337: LIST
98338: LIST
98339: PUSH
98340: EMPTY
98341: LIST
98342: LIST
98343: PPUSH
98344: CALL_OW 69
98348: PPUSH
98349: LD_VAR 0 3
98353: PPUSH
98354: CALL_OW 74
98358: PPUSH
98359: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
98363: LD_VAR 0 2
98367: PUSH
98368: LD_INT 60
98370: GREATER
98371: PUSH
98372: LD_VAR 0 3
98376: PPUSH
98377: CALL_OW 301
98381: OR
98382: IFFALSE 98259
// if un then
98384: LD_VAR 0 3
98388: IFFALSE 98399
// RemoveUnit ( un ) ;
98390: LD_VAR 0 3
98394: PPUSH
98395: CALL_OW 64
// end ;
98399: PPOPN 3
98401: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
98402: LD_INT 0
98404: PPUSH
98405: PPUSH
98406: PPUSH
98407: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98408: LD_ADDR_VAR 0 4
98412: PUSH
98413: LD_INT 22
98415: PUSH
98416: LD_OWVAR 2
98420: PUSH
98421: EMPTY
98422: LIST
98423: LIST
98424: PUSH
98425: LD_INT 2
98427: PUSH
98428: LD_INT 30
98430: PUSH
98431: LD_INT 0
98433: PUSH
98434: EMPTY
98435: LIST
98436: LIST
98437: PUSH
98438: LD_INT 30
98440: PUSH
98441: LD_INT 1
98443: PUSH
98444: EMPTY
98445: LIST
98446: LIST
98447: PUSH
98448: EMPTY
98449: LIST
98450: LIST
98451: LIST
98452: PUSH
98453: EMPTY
98454: LIST
98455: LIST
98456: PPUSH
98457: CALL_OW 69
98461: ST_TO_ADDR
// if not tmp then
98462: LD_VAR 0 4
98466: NOT
98467: IFFALSE 98471
// exit ;
98469: GO 98530
// for i in tmp do
98471: LD_ADDR_VAR 0 2
98475: PUSH
98476: LD_VAR 0 4
98480: PUSH
98481: FOR_IN
98482: IFFALSE 98528
// for j = 1 to 3 do
98484: LD_ADDR_VAR 0 3
98488: PUSH
98489: DOUBLE
98490: LD_INT 1
98492: DEC
98493: ST_TO_ADDR
98494: LD_INT 3
98496: PUSH
98497: FOR_TO
98498: IFFALSE 98524
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
98500: LD_VAR 0 2
98504: PPUSH
98505: CALL_OW 274
98509: PPUSH
98510: LD_VAR 0 3
98514: PPUSH
98515: LD_INT 99999
98517: PPUSH
98518: CALL_OW 277
98522: GO 98497
98524: POP
98525: POP
98526: GO 98481
98528: POP
98529: POP
// end ;
98530: LD_VAR 0 1
98534: RET
// export function hHackSetLevel10 ; var i , j ; begin
98535: LD_INT 0
98537: PPUSH
98538: PPUSH
98539: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98540: LD_ADDR_VAR 0 2
98544: PUSH
98545: LD_INT 21
98547: PUSH
98548: LD_INT 1
98550: PUSH
98551: EMPTY
98552: LIST
98553: LIST
98554: PPUSH
98555: CALL_OW 69
98559: PUSH
98560: FOR_IN
98561: IFFALSE 98613
// if IsSelected ( i ) then
98563: LD_VAR 0 2
98567: PPUSH
98568: CALL_OW 306
98572: IFFALSE 98611
// begin for j := 1 to 4 do
98574: LD_ADDR_VAR 0 3
98578: PUSH
98579: DOUBLE
98580: LD_INT 1
98582: DEC
98583: ST_TO_ADDR
98584: LD_INT 4
98586: PUSH
98587: FOR_TO
98588: IFFALSE 98609
// SetSkill ( i , j , 10 ) ;
98590: LD_VAR 0 2
98594: PPUSH
98595: LD_VAR 0 3
98599: PPUSH
98600: LD_INT 10
98602: PPUSH
98603: CALL_OW 237
98607: GO 98587
98609: POP
98610: POP
// end ;
98611: GO 98560
98613: POP
98614: POP
// end ;
98615: LD_VAR 0 1
98619: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
98620: LD_INT 0
98622: PPUSH
98623: PPUSH
98624: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
98625: LD_ADDR_VAR 0 2
98629: PUSH
98630: LD_INT 22
98632: PUSH
98633: LD_OWVAR 2
98637: PUSH
98638: EMPTY
98639: LIST
98640: LIST
98641: PUSH
98642: LD_INT 21
98644: PUSH
98645: LD_INT 1
98647: PUSH
98648: EMPTY
98649: LIST
98650: LIST
98651: PUSH
98652: EMPTY
98653: LIST
98654: LIST
98655: PPUSH
98656: CALL_OW 69
98660: PUSH
98661: FOR_IN
98662: IFFALSE 98703
// begin for j := 1 to 4 do
98664: LD_ADDR_VAR 0 3
98668: PUSH
98669: DOUBLE
98670: LD_INT 1
98672: DEC
98673: ST_TO_ADDR
98674: LD_INT 4
98676: PUSH
98677: FOR_TO
98678: IFFALSE 98699
// SetSkill ( i , j , 10 ) ;
98680: LD_VAR 0 2
98684: PPUSH
98685: LD_VAR 0 3
98689: PPUSH
98690: LD_INT 10
98692: PPUSH
98693: CALL_OW 237
98697: GO 98677
98699: POP
98700: POP
// end ;
98701: GO 98661
98703: POP
98704: POP
// end ;
98705: LD_VAR 0 1
98709: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
98710: LD_INT 0
98712: PPUSH
// uc_side := your_side ;
98713: LD_ADDR_OWVAR 20
98717: PUSH
98718: LD_OWVAR 2
98722: ST_TO_ADDR
// uc_nation := nation ;
98723: LD_ADDR_OWVAR 21
98727: PUSH
98728: LD_VAR 0 1
98732: ST_TO_ADDR
// InitHc ;
98733: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
98737: LD_INT 0
98739: PPUSH
98740: LD_VAR 0 2
98744: PPUSH
98745: LD_VAR 0 3
98749: PPUSH
98750: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
98754: CALL_OW 44
98758: PPUSH
98759: LD_INT 1
98761: PPUSH
98762: CALL_OW 51
// end ;
98766: LD_VAR 0 4
98770: RET
// export function hHackSpawnVehicle ; begin
98771: LD_INT 0
98773: PPUSH
// uc_side := your_side ;
98774: LD_ADDR_OWVAR 20
98778: PUSH
98779: LD_OWVAR 2
98783: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
98784: LD_ADDR_OWVAR 21
98788: PUSH
98789: LD_INT 1
98791: PPUSH
98792: LD_INT 3
98794: PPUSH
98795: CALL_OW 12
98799: ST_TO_ADDR
// InitVc ;
98800: CALL_OW 20
// case uc_nation of 1 :
98804: LD_OWVAR 21
98808: PUSH
98809: LD_INT 1
98811: DOUBLE
98812: EQUAL
98813: IFTRUE 98817
98815: GO 98961
98817: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
98818: LD_ADDR_OWVAR 37
98822: PUSH
98823: LD_INT 1
98825: PUSH
98826: LD_INT 2
98828: PUSH
98829: LD_INT 3
98831: PUSH
98832: LD_INT 4
98834: PUSH
98835: LD_INT 5
98837: PUSH
98838: EMPTY
98839: LIST
98840: LIST
98841: LIST
98842: LIST
98843: LIST
98844: PUSH
98845: LD_INT 1
98847: PPUSH
98848: LD_INT 5
98850: PPUSH
98851: CALL_OW 12
98855: ARRAY
98856: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
98857: LD_ADDR_OWVAR 39
98861: PUSH
98862: LD_INT 1
98864: PPUSH
98865: LD_INT 3
98867: PPUSH
98868: CALL_OW 12
98872: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
98873: LD_ADDR_OWVAR 38
98877: PUSH
98878: LD_INT 1
98880: PUSH
98881: LD_INT 2
98883: PUSH
98884: LD_INT 3
98886: PUSH
98887: EMPTY
98888: LIST
98889: LIST
98890: LIST
98891: PUSH
98892: LD_INT 1
98894: PPUSH
98895: LD_INT 3
98897: PPUSH
98898: CALL_OW 12
98902: ARRAY
98903: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
98904: LD_ADDR_OWVAR 40
98908: PUSH
98909: LD_INT 2
98911: PUSH
98912: LD_INT 4
98914: PUSH
98915: LD_INT 5
98917: PUSH
98918: LD_INT 3
98920: PUSH
98921: LD_INT 7
98923: PUSH
98924: LD_INT 8
98926: PUSH
98927: LD_INT 9
98929: PUSH
98930: LD_INT 10
98932: PUSH
98933: LD_INT 6
98935: PUSH
98936: EMPTY
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: LIST
98946: PUSH
98947: LD_INT 1
98949: PPUSH
98950: LD_INT 9
98952: PPUSH
98953: CALL_OW 12
98957: ARRAY
98958: ST_TO_ADDR
// end ; 2 :
98959: GO 99226
98961: LD_INT 2
98963: DOUBLE
98964: EQUAL
98965: IFTRUE 98969
98967: GO 99093
98969: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
98970: LD_ADDR_OWVAR 37
98974: PUSH
98975: LD_INT 11
98977: PUSH
98978: LD_INT 12
98980: PUSH
98981: LD_INT 13
98983: PUSH
98984: LD_INT 14
98986: PUSH
98987: EMPTY
98988: LIST
98989: LIST
98990: LIST
98991: LIST
98992: PUSH
98993: LD_INT 1
98995: PPUSH
98996: LD_INT 4
98998: PPUSH
98999: CALL_OW 12
99003: ARRAY
99004: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
99005: LD_ADDR_OWVAR 39
99009: PUSH
99010: LD_INT 1
99012: PPUSH
99013: LD_INT 3
99015: PPUSH
99016: CALL_OW 12
99020: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
99021: LD_ADDR_OWVAR 38
99025: PUSH
99026: LD_INT 1
99028: PUSH
99029: LD_INT 2
99031: PUSH
99032: LD_INT 5
99034: PUSH
99035: EMPTY
99036: LIST
99037: LIST
99038: LIST
99039: PUSH
99040: LD_INT 1
99042: PPUSH
99043: LD_INT 3
99045: PPUSH
99046: CALL_OW 12
99050: ARRAY
99051: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
99052: LD_ADDR_OWVAR 40
99056: PUSH
99057: LD_INT 24
99059: PUSH
99060: LD_INT 26
99062: PUSH
99063: LD_INT 27
99065: PUSH
99066: LD_INT 28
99068: PUSH
99069: LD_INT 29
99071: PUSH
99072: EMPTY
99073: LIST
99074: LIST
99075: LIST
99076: LIST
99077: LIST
99078: PUSH
99079: LD_INT 1
99081: PPUSH
99082: LD_INT 5
99084: PPUSH
99085: CALL_OW 12
99089: ARRAY
99090: ST_TO_ADDR
// end ; 3 :
99091: GO 99226
99093: LD_INT 3
99095: DOUBLE
99096: EQUAL
99097: IFTRUE 99101
99099: GO 99225
99101: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
99102: LD_ADDR_OWVAR 37
99106: PUSH
99107: LD_INT 21
99109: PUSH
99110: LD_INT 23
99112: PUSH
99113: LD_INT 22
99115: PUSH
99116: LD_INT 24
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: PUSH
99125: LD_INT 1
99127: PPUSH
99128: LD_INT 4
99130: PPUSH
99131: CALL_OW 12
99135: ARRAY
99136: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
99137: LD_ADDR_OWVAR 39
99141: PUSH
99142: LD_INT 1
99144: PPUSH
99145: LD_INT 3
99147: PPUSH
99148: CALL_OW 12
99152: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
99153: LD_ADDR_OWVAR 38
99157: PUSH
99158: LD_INT 1
99160: PUSH
99161: LD_INT 3
99163: PUSH
99164: EMPTY
99165: LIST
99166: LIST
99167: PUSH
99168: LD_INT 1
99170: PPUSH
99171: LD_INT 2
99173: PPUSH
99174: CALL_OW 12
99178: ARRAY
99179: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
99180: LD_ADDR_OWVAR 40
99184: PUSH
99185: LD_INT 42
99187: PUSH
99188: LD_INT 43
99190: PUSH
99191: LD_INT 44
99193: PUSH
99194: LD_INT 46
99196: PUSH
99197: LD_INT 48
99199: PUSH
99200: LD_INT 47
99202: PUSH
99203: EMPTY
99204: LIST
99205: LIST
99206: LIST
99207: LIST
99208: LIST
99209: LIST
99210: PUSH
99211: LD_INT 1
99213: PPUSH
99214: LD_INT 6
99216: PPUSH
99217: CALL_OW 12
99221: ARRAY
99222: ST_TO_ADDR
// end ; end ;
99223: GO 99226
99225: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99226: CALL_OW 45
99230: PPUSH
99231: LD_INT 1
99233: PPUSH
99234: CALL_OW 51
// end ;
99238: LD_VAR 0 1
99242: RET
// export hInvincible ; every 1 do
99243: GO 99245
99245: DISABLE
// hInvincible := [ ] ;
99246: LD_ADDR_EXP 186
99250: PUSH
99251: EMPTY
99252: ST_TO_ADDR
99253: END
// every 10 do var i ;
99254: GO 99256
99256: DISABLE
99257: LD_INT 0
99259: PPUSH
// begin enable ;
99260: ENABLE
// if not hInvincible then
99261: LD_EXP 186
99265: NOT
99266: IFFALSE 99270
// exit ;
99268: GO 99314
// for i in hInvincible do
99270: LD_ADDR_VAR 0 1
99274: PUSH
99275: LD_EXP 186
99279: PUSH
99280: FOR_IN
99281: IFFALSE 99312
// if GetLives ( i ) < 1000 then
99283: LD_VAR 0 1
99287: PPUSH
99288: CALL_OW 256
99292: PUSH
99293: LD_INT 1000
99295: LESS
99296: IFFALSE 99310
// SetLives ( i , 1000 ) ;
99298: LD_VAR 0 1
99302: PPUSH
99303: LD_INT 1000
99305: PPUSH
99306: CALL_OW 234
99310: GO 99280
99312: POP
99313: POP
// end ;
99314: PPOPN 1
99316: END
// export function hHackInvincible ; var i ; begin
99317: LD_INT 0
99319: PPUSH
99320: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
99321: LD_ADDR_VAR 0 2
99325: PUSH
99326: LD_INT 2
99328: PUSH
99329: LD_INT 21
99331: PUSH
99332: LD_INT 1
99334: PUSH
99335: EMPTY
99336: LIST
99337: LIST
99338: PUSH
99339: LD_INT 21
99341: PUSH
99342: LD_INT 2
99344: PUSH
99345: EMPTY
99346: LIST
99347: LIST
99348: PUSH
99349: EMPTY
99350: LIST
99351: LIST
99352: LIST
99353: PPUSH
99354: CALL_OW 69
99358: PUSH
99359: FOR_IN
99360: IFFALSE 99421
// if IsSelected ( i ) then
99362: LD_VAR 0 2
99366: PPUSH
99367: CALL_OW 306
99371: IFFALSE 99419
// begin if i in hInvincible then
99373: LD_VAR 0 2
99377: PUSH
99378: LD_EXP 186
99382: IN
99383: IFFALSE 99403
// hInvincible := hInvincible diff i else
99385: LD_ADDR_EXP 186
99389: PUSH
99390: LD_EXP 186
99394: PUSH
99395: LD_VAR 0 2
99399: DIFF
99400: ST_TO_ADDR
99401: GO 99419
// hInvincible := hInvincible union i ;
99403: LD_ADDR_EXP 186
99407: PUSH
99408: LD_EXP 186
99412: PUSH
99413: LD_VAR 0 2
99417: UNION
99418: ST_TO_ADDR
// end ;
99419: GO 99359
99421: POP
99422: POP
// end ;
99423: LD_VAR 0 1
99427: RET
// export function hHackInvisible ; var i , j ; begin
99428: LD_INT 0
99430: PPUSH
99431: PPUSH
99432: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99433: LD_ADDR_VAR 0 2
99437: PUSH
99438: LD_INT 21
99440: PUSH
99441: LD_INT 1
99443: PUSH
99444: EMPTY
99445: LIST
99446: LIST
99447: PPUSH
99448: CALL_OW 69
99452: PUSH
99453: FOR_IN
99454: IFFALSE 99478
// if IsSelected ( i ) then
99456: LD_VAR 0 2
99460: PPUSH
99461: CALL_OW 306
99465: IFFALSE 99476
// ComForceInvisible ( i ) ;
99467: LD_VAR 0 2
99471: PPUSH
99472: CALL_OW 496
99476: GO 99453
99478: POP
99479: POP
// end ;
99480: LD_VAR 0 1
99484: RET
// export function hHackChangeYourSide ; begin
99485: LD_INT 0
99487: PPUSH
// if your_side = 8 then
99488: LD_OWVAR 2
99492: PUSH
99493: LD_INT 8
99495: EQUAL
99496: IFFALSE 99508
// your_side := 0 else
99498: LD_ADDR_OWVAR 2
99502: PUSH
99503: LD_INT 0
99505: ST_TO_ADDR
99506: GO 99522
// your_side := your_side + 1 ;
99508: LD_ADDR_OWVAR 2
99512: PUSH
99513: LD_OWVAR 2
99517: PUSH
99518: LD_INT 1
99520: PLUS
99521: ST_TO_ADDR
// end ;
99522: LD_VAR 0 1
99526: RET
// export function hHackChangeUnitSide ; var i , j ; begin
99527: LD_INT 0
99529: PPUSH
99530: PPUSH
99531: PPUSH
// for i in all_units do
99532: LD_ADDR_VAR 0 2
99536: PUSH
99537: LD_OWVAR 3
99541: PUSH
99542: FOR_IN
99543: IFFALSE 99621
// if IsSelected ( i ) then
99545: LD_VAR 0 2
99549: PPUSH
99550: CALL_OW 306
99554: IFFALSE 99619
// begin j := GetSide ( i ) ;
99556: LD_ADDR_VAR 0 3
99560: PUSH
99561: LD_VAR 0 2
99565: PPUSH
99566: CALL_OW 255
99570: ST_TO_ADDR
// if j = 8 then
99571: LD_VAR 0 3
99575: PUSH
99576: LD_INT 8
99578: EQUAL
99579: IFFALSE 99591
// j := 0 else
99581: LD_ADDR_VAR 0 3
99585: PUSH
99586: LD_INT 0
99588: ST_TO_ADDR
99589: GO 99605
// j := j + 1 ;
99591: LD_ADDR_VAR 0 3
99595: PUSH
99596: LD_VAR 0 3
99600: PUSH
99601: LD_INT 1
99603: PLUS
99604: ST_TO_ADDR
// SetSide ( i , j ) ;
99605: LD_VAR 0 2
99609: PPUSH
99610: LD_VAR 0 3
99614: PPUSH
99615: CALL_OW 235
// end ;
99619: GO 99542
99621: POP
99622: POP
// end ;
99623: LD_VAR 0 1
99627: RET
// export function hHackFog ; begin
99628: LD_INT 0
99630: PPUSH
// FogOff ( true ) ;
99631: LD_INT 1
99633: PPUSH
99634: CALL_OW 344
// end ;
99638: LD_VAR 0 1
99642: RET
// export function hHackApeman ; begin
99643: LD_INT 0
99645: PPUSH
// uc_side := your_side ;
99646: LD_ADDR_OWVAR 20
99650: PUSH
99651: LD_OWVAR 2
99655: ST_TO_ADDR
// uc_nation := 0 ;
99656: LD_ADDR_OWVAR 21
99660: PUSH
99661: LD_INT 0
99663: ST_TO_ADDR
// hc_name :=  ;
99664: LD_ADDR_OWVAR 26
99668: PUSH
99669: LD_STRING 
99671: ST_TO_ADDR
// hc_gallery :=  ;
99672: LD_ADDR_OWVAR 33
99676: PUSH
99677: LD_STRING 
99679: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
99680: LD_ADDR_OWVAR 31
99684: PUSH
99685: LD_INT 0
99687: PUSH
99688: LD_INT 0
99690: PUSH
99691: LD_INT 0
99693: PUSH
99694: LD_INT 0
99696: PUSH
99697: EMPTY
99698: LIST
99699: LIST
99700: LIST
99701: LIST
99702: ST_TO_ADDR
// hc_class := class_apeman ;
99703: LD_ADDR_OWVAR 28
99707: PUSH
99708: LD_INT 12
99710: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
99711: CALL_OW 44
99715: PPUSH
99716: LD_INT 1
99718: PPUSH
99719: CALL_OW 51
// end ;
99723: LD_VAR 0 1
99727: RET
// export function hHackBoom ; begin
99728: LD_INT 0
99730: PPUSH
// uc_side := your_side ;
99731: LD_ADDR_OWVAR 20
99735: PUSH
99736: LD_OWVAR 2
99740: ST_TO_ADDR
// uc_nation := 1 ;
99741: LD_ADDR_OWVAR 21
99745: PUSH
99746: LD_INT 1
99748: ST_TO_ADDR
// vc_chassis := us_morphling ;
99749: LD_ADDR_OWVAR 37
99753: PUSH
99754: LD_INT 5
99756: ST_TO_ADDR
// vc_engine := engine_siberite ;
99757: LD_ADDR_OWVAR 39
99761: PUSH
99762: LD_INT 3
99764: ST_TO_ADDR
// vc_control := control_computer ;
99765: LD_ADDR_OWVAR 38
99769: PUSH
99770: LD_INT 3
99772: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
99773: LD_ADDR_OWVAR 40
99777: PUSH
99778: LD_INT 8
99780: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99781: CALL_OW 45
99785: PPUSH
99786: LD_INT 1
99788: PPUSH
99789: CALL_OW 51
// end ; end_of_file
99793: LD_VAR 0 1
99797: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
99798: LD_INT 0
99800: PPUSH
99801: PPUSH
99802: PPUSH
99803: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
99804: LD_VAR 0 1
99808: PPUSH
99809: CALL_OW 264
99813: PUSH
99814: LD_EXP 76
99818: EQUAL
99819: IFFALSE 99891
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
99821: LD_INT 68
99823: PPUSH
99824: LD_VAR 0 1
99828: PPUSH
99829: CALL_OW 255
99833: PPUSH
99834: CALL_OW 321
99838: PUSH
99839: LD_INT 2
99841: EQUAL
99842: IFFALSE 99854
// eff := 70 else
99844: LD_ADDR_VAR 0 4
99848: PUSH
99849: LD_INT 70
99851: ST_TO_ADDR
99852: GO 99862
// eff := 30 ;
99854: LD_ADDR_VAR 0 4
99858: PUSH
99859: LD_INT 30
99861: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
99862: LD_VAR 0 1
99866: PPUSH
99867: CALL_OW 250
99871: PPUSH
99872: LD_VAR 0 1
99876: PPUSH
99877: CALL_OW 251
99881: PPUSH
99882: LD_VAR 0 4
99886: PPUSH
99887: CALL_OW 495
// end ; end ;
99891: LD_VAR 0 2
99895: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
99896: LD_INT 0
99898: PPUSH
// end ;
99899: LD_VAR 0 4
99903: RET
// export function SOS_Command ( cmd ) ; begin
99904: LD_INT 0
99906: PPUSH
// end ;
99907: LD_VAR 0 2
99911: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
99912: LD_INT 0
99914: PPUSH
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
99915: LD_VAR 0 1
99919: PUSH
99920: LD_INT 254
99922: EQUAL
99923: PUSH
99924: LD_VAR 0 2
99928: PPUSH
99929: CALL_OW 264
99933: PUSH
99934: LD_EXP 74
99938: EQUAL
99939: AND
99940: PUSH
99941: LD_VAR 0 3
99945: PPUSH
99946: CALL_OW 263
99950: PUSH
99951: LD_INT 3
99953: EQUAL
99954: AND
99955: IFFALSE 99971
// HackDestroyVehicle ( unit , selectedUnit ) ;
99957: LD_VAR 0 2
99961: PPUSH
99962: LD_VAR 0 3
99966: PPUSH
99967: CALL 101480 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
99971: LD_VAR 0 1
99975: PUSH
99976: LD_INT 255
99978: EQUAL
99979: PUSH
99980: LD_VAR 0 2
99984: PPUSH
99985: CALL_OW 264
99989: PUSH
99990: LD_INT 14
99992: PUSH
99993: LD_INT 53
99995: PUSH
99996: EMPTY
99997: LIST
99998: LIST
99999: IN
100000: AND
100001: PUSH
100002: LD_VAR 0 4
100006: PPUSH
100007: LD_VAR 0 5
100011: PPUSH
100012: CALL_OW 488
100016: AND
100017: IFFALSE 100041
// CutTreeXYR ( unit , x , y , 12 ) ;
100019: LD_VAR 0 2
100023: PPUSH
100024: LD_VAR 0 4
100028: PPUSH
100029: LD_VAR 0 5
100033: PPUSH
100034: LD_INT 12
100036: PPUSH
100037: CALL 100046 0 4
// end ;
100041: LD_VAR 0 6
100045: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
100046: LD_INT 0
100048: PPUSH
100049: PPUSH
100050: PPUSH
100051: PPUSH
100052: PPUSH
100053: PPUSH
100054: PPUSH
100055: PPUSH
100056: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
100057: LD_VAR 0 1
100061: NOT
100062: PUSH
100063: LD_VAR 0 2
100067: PPUSH
100068: LD_VAR 0 3
100072: PPUSH
100073: CALL_OW 488
100077: NOT
100078: OR
100079: PUSH
100080: LD_VAR 0 4
100084: NOT
100085: OR
100086: IFFALSE 100090
// exit ;
100088: GO 100430
// list := [ ] ;
100090: LD_ADDR_VAR 0 13
100094: PUSH
100095: EMPTY
100096: ST_TO_ADDR
// if x - r < 0 then
100097: LD_VAR 0 2
100101: PUSH
100102: LD_VAR 0 4
100106: MINUS
100107: PUSH
100108: LD_INT 0
100110: LESS
100111: IFFALSE 100123
// min_x := 0 else
100113: LD_ADDR_VAR 0 7
100117: PUSH
100118: LD_INT 0
100120: ST_TO_ADDR
100121: GO 100139
// min_x := x - r ;
100123: LD_ADDR_VAR 0 7
100127: PUSH
100128: LD_VAR 0 2
100132: PUSH
100133: LD_VAR 0 4
100137: MINUS
100138: ST_TO_ADDR
// if y - r < 0 then
100139: LD_VAR 0 3
100143: PUSH
100144: LD_VAR 0 4
100148: MINUS
100149: PUSH
100150: LD_INT 0
100152: LESS
100153: IFFALSE 100165
// min_y := 0 else
100155: LD_ADDR_VAR 0 8
100159: PUSH
100160: LD_INT 0
100162: ST_TO_ADDR
100163: GO 100181
// min_y := y - r ;
100165: LD_ADDR_VAR 0 8
100169: PUSH
100170: LD_VAR 0 3
100174: PUSH
100175: LD_VAR 0 4
100179: MINUS
100180: ST_TO_ADDR
// max_x := x + r ;
100181: LD_ADDR_VAR 0 9
100185: PUSH
100186: LD_VAR 0 2
100190: PUSH
100191: LD_VAR 0 4
100195: PLUS
100196: ST_TO_ADDR
// max_y := y + r ;
100197: LD_ADDR_VAR 0 10
100201: PUSH
100202: LD_VAR 0 3
100206: PUSH
100207: LD_VAR 0 4
100211: PLUS
100212: ST_TO_ADDR
// for _x = min_x to max_x do
100213: LD_ADDR_VAR 0 11
100217: PUSH
100218: DOUBLE
100219: LD_VAR 0 7
100223: DEC
100224: ST_TO_ADDR
100225: LD_VAR 0 9
100229: PUSH
100230: FOR_TO
100231: IFFALSE 100348
// for _y = min_y to max_y do
100233: LD_ADDR_VAR 0 12
100237: PUSH
100238: DOUBLE
100239: LD_VAR 0 8
100243: DEC
100244: ST_TO_ADDR
100245: LD_VAR 0 10
100249: PUSH
100250: FOR_TO
100251: IFFALSE 100344
// begin if not ValidHex ( _x , _y ) then
100253: LD_VAR 0 11
100257: PPUSH
100258: LD_VAR 0 12
100262: PPUSH
100263: CALL_OW 488
100267: NOT
100268: IFFALSE 100272
// continue ;
100270: GO 100250
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
100272: LD_VAR 0 11
100276: PPUSH
100277: LD_VAR 0 12
100281: PPUSH
100282: CALL_OW 351
100286: PUSH
100287: LD_VAR 0 11
100291: PPUSH
100292: LD_VAR 0 12
100296: PPUSH
100297: CALL_OW 554
100301: AND
100302: IFFALSE 100342
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
100304: LD_ADDR_VAR 0 13
100308: PUSH
100309: LD_VAR 0 13
100313: PPUSH
100314: LD_VAR 0 13
100318: PUSH
100319: LD_INT 1
100321: PLUS
100322: PPUSH
100323: LD_VAR 0 11
100327: PUSH
100328: LD_VAR 0 12
100332: PUSH
100333: EMPTY
100334: LIST
100335: LIST
100336: PPUSH
100337: CALL_OW 2
100341: ST_TO_ADDR
// end ;
100342: GO 100250
100344: POP
100345: POP
100346: GO 100230
100348: POP
100349: POP
// if not list then
100350: LD_VAR 0 13
100354: NOT
100355: IFFALSE 100359
// exit ;
100357: GO 100430
// for i in list do
100359: LD_ADDR_VAR 0 6
100363: PUSH
100364: LD_VAR 0 13
100368: PUSH
100369: FOR_IN
100370: IFFALSE 100428
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
100372: LD_VAR 0 1
100376: PPUSH
100377: LD_STRING M
100379: PUSH
100380: LD_VAR 0 6
100384: PUSH
100385: LD_INT 1
100387: ARRAY
100388: PUSH
100389: LD_VAR 0 6
100393: PUSH
100394: LD_INT 2
100396: ARRAY
100397: PUSH
100398: LD_INT 0
100400: PUSH
100401: LD_INT 0
100403: PUSH
100404: LD_INT 0
100406: PUSH
100407: LD_INT 0
100409: PUSH
100410: EMPTY
100411: LIST
100412: LIST
100413: LIST
100414: LIST
100415: LIST
100416: LIST
100417: LIST
100418: PUSH
100419: EMPTY
100420: LIST
100421: PPUSH
100422: CALL_OW 447
100426: GO 100369
100428: POP
100429: POP
// end ;
100430: LD_VAR 0 5
100434: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
100435: LD_EXP 187
100439: NOT
100440: IFFALSE 100490
100442: GO 100444
100444: DISABLE
// begin initHack := true ;
100445: LD_ADDR_EXP 187
100449: PUSH
100450: LD_INT 1
100452: ST_TO_ADDR
// hackTanks := [ ] ;
100453: LD_ADDR_EXP 188
100457: PUSH
100458: EMPTY
100459: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
100460: LD_ADDR_EXP 189
100464: PUSH
100465: EMPTY
100466: ST_TO_ADDR
// hackLimit := 3 ;
100467: LD_ADDR_EXP 190
100471: PUSH
100472: LD_INT 3
100474: ST_TO_ADDR
// hackDist := 12 ;
100475: LD_ADDR_EXP 191
100479: PUSH
100480: LD_INT 12
100482: ST_TO_ADDR
// hackCounter := [ ] ;
100483: LD_ADDR_EXP 192
100487: PUSH
100488: EMPTY
100489: ST_TO_ADDR
// end ;
100490: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
100491: LD_EXP 187
100495: PUSH
100496: LD_INT 34
100498: PUSH
100499: LD_EXP 74
100503: PUSH
100504: EMPTY
100505: LIST
100506: LIST
100507: PPUSH
100508: CALL_OW 69
100512: AND
100513: IFFALSE 100768
100515: GO 100517
100517: DISABLE
100518: LD_INT 0
100520: PPUSH
100521: PPUSH
// begin enable ;
100522: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
100523: LD_ADDR_VAR 0 1
100527: PUSH
100528: LD_INT 34
100530: PUSH
100531: LD_EXP 74
100535: PUSH
100536: EMPTY
100537: LIST
100538: LIST
100539: PPUSH
100540: CALL_OW 69
100544: PUSH
100545: FOR_IN
100546: IFFALSE 100766
// begin if not i in hackTanks then
100548: LD_VAR 0 1
100552: PUSH
100553: LD_EXP 188
100557: IN
100558: NOT
100559: IFFALSE 100642
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
100561: LD_ADDR_EXP 188
100565: PUSH
100566: LD_EXP 188
100570: PPUSH
100571: LD_EXP 188
100575: PUSH
100576: LD_INT 1
100578: PLUS
100579: PPUSH
100580: LD_VAR 0 1
100584: PPUSH
100585: CALL_OW 1
100589: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
100590: LD_ADDR_EXP 189
100594: PUSH
100595: LD_EXP 189
100599: PPUSH
100600: LD_EXP 189
100604: PUSH
100605: LD_INT 1
100607: PLUS
100608: PPUSH
100609: EMPTY
100610: PPUSH
100611: CALL_OW 1
100615: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
100616: LD_ADDR_EXP 192
100620: PUSH
100621: LD_EXP 192
100625: PPUSH
100626: LD_EXP 192
100630: PUSH
100631: LD_INT 1
100633: PLUS
100634: PPUSH
100635: EMPTY
100636: PPUSH
100637: CALL_OW 1
100641: ST_TO_ADDR
// end ; if not IsOk ( i ) then
100642: LD_VAR 0 1
100646: PPUSH
100647: CALL_OW 302
100651: NOT
100652: IFFALSE 100665
// begin HackUnlinkAll ( i ) ;
100654: LD_VAR 0 1
100658: PPUSH
100659: CALL 100771 0 1
// continue ;
100663: GO 100545
// end ; HackCheckCapturedStatus ( i ) ;
100665: LD_VAR 0 1
100669: PPUSH
100670: CALL 101214 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
100674: LD_ADDR_VAR 0 2
100678: PUSH
100679: LD_INT 81
100681: PUSH
100682: LD_VAR 0 1
100686: PPUSH
100687: CALL_OW 255
100691: PUSH
100692: EMPTY
100693: LIST
100694: LIST
100695: PUSH
100696: LD_INT 33
100698: PUSH
100699: LD_INT 3
100701: PUSH
100702: EMPTY
100703: LIST
100704: LIST
100705: PUSH
100706: LD_INT 91
100708: PUSH
100709: LD_VAR 0 1
100713: PUSH
100714: LD_EXP 191
100718: PUSH
100719: EMPTY
100720: LIST
100721: LIST
100722: LIST
100723: PUSH
100724: LD_INT 50
100726: PUSH
100727: EMPTY
100728: LIST
100729: PUSH
100730: EMPTY
100731: LIST
100732: LIST
100733: LIST
100734: LIST
100735: PPUSH
100736: CALL_OW 69
100740: ST_TO_ADDR
// if not tmp then
100741: LD_VAR 0 2
100745: NOT
100746: IFFALSE 100750
// continue ;
100748: GO 100545
// HackLink ( i , tmp ) ;
100750: LD_VAR 0 1
100754: PPUSH
100755: LD_VAR 0 2
100759: PPUSH
100760: CALL 100907 0 2
// end ;
100764: GO 100545
100766: POP
100767: POP
// end ;
100768: PPOPN 2
100770: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
100771: LD_INT 0
100773: PPUSH
100774: PPUSH
100775: PPUSH
// if not hack in hackTanks then
100776: LD_VAR 0 1
100780: PUSH
100781: LD_EXP 188
100785: IN
100786: NOT
100787: IFFALSE 100791
// exit ;
100789: GO 100902
// index := GetElementIndex ( hackTanks , hack ) ;
100791: LD_ADDR_VAR 0 4
100795: PUSH
100796: LD_EXP 188
100800: PPUSH
100801: LD_VAR 0 1
100805: PPUSH
100806: CALL 55478 0 2
100810: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
100811: LD_EXP 189
100815: PUSH
100816: LD_VAR 0 4
100820: ARRAY
100821: IFFALSE 100902
// begin for i in hackTanksCaptured [ index ] do
100823: LD_ADDR_VAR 0 3
100827: PUSH
100828: LD_EXP 189
100832: PUSH
100833: LD_VAR 0 4
100837: ARRAY
100838: PUSH
100839: FOR_IN
100840: IFFALSE 100866
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
100842: LD_VAR 0 3
100846: PUSH
100847: LD_INT 1
100849: ARRAY
100850: PPUSH
100851: LD_VAR 0 3
100855: PUSH
100856: LD_INT 2
100858: ARRAY
100859: PPUSH
100860: CALL_OW 235
100864: GO 100839
100866: POP
100867: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
100868: LD_ADDR_EXP 189
100872: PUSH
100873: LD_EXP 189
100877: PPUSH
100878: LD_VAR 0 4
100882: PPUSH
100883: EMPTY
100884: PPUSH
100885: CALL_OW 1
100889: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
100890: LD_VAR 0 1
100894: PPUSH
100895: LD_INT 0
100897: PPUSH
100898: CALL_OW 505
// end ; end ;
100902: LD_VAR 0 2
100906: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
100907: LD_INT 0
100909: PPUSH
100910: PPUSH
100911: PPUSH
// if not hack in hackTanks or not vehicles then
100912: LD_VAR 0 1
100916: PUSH
100917: LD_EXP 188
100921: IN
100922: NOT
100923: PUSH
100924: LD_VAR 0 2
100928: NOT
100929: OR
100930: IFFALSE 100934
// exit ;
100932: GO 101209
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
100934: LD_ADDR_VAR 0 2
100938: PUSH
100939: LD_VAR 0 1
100943: PPUSH
100944: LD_VAR 0 2
100948: PPUSH
100949: LD_INT 1
100951: PPUSH
100952: LD_INT 1
100954: PPUSH
100955: CALL 56128 0 4
100959: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
100960: LD_ADDR_VAR 0 5
100964: PUSH
100965: LD_EXP 188
100969: PPUSH
100970: LD_VAR 0 1
100974: PPUSH
100975: CALL 55478 0 2
100979: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
100980: LD_EXP 189
100984: PUSH
100985: LD_VAR 0 5
100989: ARRAY
100990: PUSH
100991: LD_EXP 190
100995: LESS
100996: IFFALSE 101185
// begin for i := 1 to vehicles do
100998: LD_ADDR_VAR 0 4
101002: PUSH
101003: DOUBLE
101004: LD_INT 1
101006: DEC
101007: ST_TO_ADDR
101008: LD_VAR 0 2
101012: PUSH
101013: FOR_TO
101014: IFFALSE 101183
// begin if hackTanksCaptured [ index ] = hackLimit then
101016: LD_EXP 189
101020: PUSH
101021: LD_VAR 0 5
101025: ARRAY
101026: PUSH
101027: LD_EXP 190
101031: EQUAL
101032: IFFALSE 101036
// break ;
101034: GO 101183
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
101036: LD_ADDR_EXP 192
101040: PUSH
101041: LD_EXP 192
101045: PPUSH
101046: LD_VAR 0 5
101050: PPUSH
101051: LD_EXP 192
101055: PUSH
101056: LD_VAR 0 5
101060: ARRAY
101061: PUSH
101062: LD_INT 1
101064: PLUS
101065: PPUSH
101066: CALL_OW 1
101070: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
101071: LD_ADDR_EXP 189
101075: PUSH
101076: LD_EXP 189
101080: PPUSH
101081: LD_VAR 0 5
101085: PUSH
101086: LD_EXP 189
101090: PUSH
101091: LD_VAR 0 5
101095: ARRAY
101096: PUSH
101097: LD_INT 1
101099: PLUS
101100: PUSH
101101: EMPTY
101102: LIST
101103: LIST
101104: PPUSH
101105: LD_VAR 0 2
101109: PUSH
101110: LD_VAR 0 4
101114: ARRAY
101115: PUSH
101116: LD_VAR 0 2
101120: PUSH
101121: LD_VAR 0 4
101125: ARRAY
101126: PPUSH
101127: CALL_OW 255
101131: PUSH
101132: EMPTY
101133: LIST
101134: LIST
101135: PPUSH
101136: CALL 55693 0 3
101140: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
101141: LD_VAR 0 2
101145: PUSH
101146: LD_VAR 0 4
101150: ARRAY
101151: PPUSH
101152: LD_VAR 0 1
101156: PPUSH
101157: CALL_OW 255
101161: PPUSH
101162: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
101166: LD_VAR 0 2
101170: PUSH
101171: LD_VAR 0 4
101175: ARRAY
101176: PPUSH
101177: CALL_OW 141
// end ;
101181: GO 101013
101183: POP
101184: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
101185: LD_VAR 0 1
101189: PPUSH
101190: LD_EXP 189
101194: PUSH
101195: LD_VAR 0 5
101199: ARRAY
101200: PUSH
101201: LD_INT 0
101203: PLUS
101204: PPUSH
101205: CALL_OW 505
// end ;
101209: LD_VAR 0 3
101213: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
101214: LD_INT 0
101216: PPUSH
101217: PPUSH
101218: PPUSH
101219: PPUSH
// if not hack in hackTanks then
101220: LD_VAR 0 1
101224: PUSH
101225: LD_EXP 188
101229: IN
101230: NOT
101231: IFFALSE 101235
// exit ;
101233: GO 101475
// index := GetElementIndex ( hackTanks , hack ) ;
101235: LD_ADDR_VAR 0 4
101239: PUSH
101240: LD_EXP 188
101244: PPUSH
101245: LD_VAR 0 1
101249: PPUSH
101250: CALL 55478 0 2
101254: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
101255: LD_ADDR_VAR 0 3
101259: PUSH
101260: DOUBLE
101261: LD_EXP 189
101265: PUSH
101266: LD_VAR 0 4
101270: ARRAY
101271: INC
101272: ST_TO_ADDR
101273: LD_INT 1
101275: PUSH
101276: FOR_DOWNTO
101277: IFFALSE 101449
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
101279: LD_ADDR_VAR 0 5
101283: PUSH
101284: LD_EXP 189
101288: PUSH
101289: LD_VAR 0 4
101293: ARRAY
101294: PUSH
101295: LD_VAR 0 3
101299: ARRAY
101300: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
101301: LD_VAR 0 5
101305: PUSH
101306: LD_INT 1
101308: ARRAY
101309: PPUSH
101310: CALL_OW 302
101314: NOT
101315: PUSH
101316: LD_VAR 0 5
101320: PUSH
101321: LD_INT 1
101323: ARRAY
101324: PPUSH
101325: CALL_OW 255
101329: PUSH
101330: LD_VAR 0 1
101334: PPUSH
101335: CALL_OW 255
101339: NONEQUAL
101340: OR
101341: IFFALSE 101447
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
101343: LD_VAR 0 5
101347: PUSH
101348: LD_INT 1
101350: ARRAY
101351: PPUSH
101352: CALL_OW 305
101356: PUSH
101357: LD_VAR 0 5
101361: PUSH
101362: LD_INT 1
101364: ARRAY
101365: PPUSH
101366: CALL_OW 255
101370: PUSH
101371: LD_VAR 0 1
101375: PPUSH
101376: CALL_OW 255
101380: EQUAL
101381: AND
101382: IFFALSE 101406
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
101384: LD_VAR 0 5
101388: PUSH
101389: LD_INT 1
101391: ARRAY
101392: PPUSH
101393: LD_VAR 0 5
101397: PUSH
101398: LD_INT 2
101400: ARRAY
101401: PPUSH
101402: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
101406: LD_ADDR_EXP 189
101410: PUSH
101411: LD_EXP 189
101415: PPUSH
101416: LD_VAR 0 4
101420: PPUSH
101421: LD_EXP 189
101425: PUSH
101426: LD_VAR 0 4
101430: ARRAY
101431: PPUSH
101432: LD_VAR 0 3
101436: PPUSH
101437: CALL_OW 3
101441: PPUSH
101442: CALL_OW 1
101446: ST_TO_ADDR
// end ; end ;
101447: GO 101276
101449: POP
101450: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
101451: LD_VAR 0 1
101455: PPUSH
101456: LD_EXP 189
101460: PUSH
101461: LD_VAR 0 4
101465: ARRAY
101466: PUSH
101467: LD_INT 0
101469: PLUS
101470: PPUSH
101471: CALL_OW 505
// end ;
101475: LD_VAR 0 2
101479: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
101480: LD_INT 0
101482: PPUSH
101483: PPUSH
101484: PPUSH
101485: PPUSH
// if not hack in hackTanks then
101486: LD_VAR 0 1
101490: PUSH
101491: LD_EXP 188
101495: IN
101496: NOT
101497: IFFALSE 101501
// exit ;
101499: GO 101586
// index := GetElementIndex ( hackTanks , hack ) ;
101501: LD_ADDR_VAR 0 5
101505: PUSH
101506: LD_EXP 188
101510: PPUSH
101511: LD_VAR 0 1
101515: PPUSH
101516: CALL 55478 0 2
101520: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
101521: LD_ADDR_VAR 0 4
101525: PUSH
101526: DOUBLE
101527: LD_INT 1
101529: DEC
101530: ST_TO_ADDR
101531: LD_EXP 189
101535: PUSH
101536: LD_VAR 0 5
101540: ARRAY
101541: PUSH
101542: FOR_TO
101543: IFFALSE 101584
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
101545: LD_EXP 189
101549: PUSH
101550: LD_VAR 0 5
101554: ARRAY
101555: PUSH
101556: LD_VAR 0 4
101560: ARRAY
101561: PUSH
101562: LD_INT 1
101564: ARRAY
101565: PUSH
101566: LD_VAR 0 2
101570: EQUAL
101571: IFFALSE 101582
// KillUnit ( vehicle ) ;
101573: LD_VAR 0 2
101577: PPUSH
101578: CALL_OW 66
101582: GO 101542
101584: POP
101585: POP
// end ; end_of_file
101586: LD_VAR 0 3
101590: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
101591: LD_INT 0
101593: PPUSH
101594: PPUSH
101595: PPUSH
101596: PPUSH
101597: PPUSH
101598: PPUSH
101599: PPUSH
101600: PPUSH
101601: PPUSH
101602: PPUSH
101603: PPUSH
101604: PPUSH
101605: PPUSH
101606: PPUSH
101607: PPUSH
101608: PPUSH
101609: PPUSH
101610: PPUSH
101611: PPUSH
101612: PPUSH
101613: PPUSH
101614: PPUSH
101615: PPUSH
101616: PPUSH
101617: PPUSH
101618: PPUSH
101619: PPUSH
101620: PPUSH
101621: PPUSH
101622: PPUSH
101623: PPUSH
101624: PPUSH
101625: PPUSH
101626: PPUSH
// if not list then
101627: LD_VAR 0 1
101631: NOT
101632: IFFALSE 101636
// exit ;
101634: GO 106295
// base := list [ 1 ] ;
101636: LD_ADDR_VAR 0 3
101640: PUSH
101641: LD_VAR 0 1
101645: PUSH
101646: LD_INT 1
101648: ARRAY
101649: ST_TO_ADDR
// group := list [ 2 ] ;
101650: LD_ADDR_VAR 0 4
101654: PUSH
101655: LD_VAR 0 1
101659: PUSH
101660: LD_INT 2
101662: ARRAY
101663: ST_TO_ADDR
// path := list [ 3 ] ;
101664: LD_ADDR_VAR 0 5
101668: PUSH
101669: LD_VAR 0 1
101673: PUSH
101674: LD_INT 3
101676: ARRAY
101677: ST_TO_ADDR
// flags := list [ 4 ] ;
101678: LD_ADDR_VAR 0 6
101682: PUSH
101683: LD_VAR 0 1
101687: PUSH
101688: LD_INT 4
101690: ARRAY
101691: ST_TO_ADDR
// mined := [ ] ;
101692: LD_ADDR_VAR 0 27
101696: PUSH
101697: EMPTY
101698: ST_TO_ADDR
// bombed := [ ] ;
101699: LD_ADDR_VAR 0 28
101703: PUSH
101704: EMPTY
101705: ST_TO_ADDR
// healers := [ ] ;
101706: LD_ADDR_VAR 0 31
101710: PUSH
101711: EMPTY
101712: ST_TO_ADDR
// to_heal := [ ] ;
101713: LD_ADDR_VAR 0 30
101717: PUSH
101718: EMPTY
101719: ST_TO_ADDR
// repairs := [ ] ;
101720: LD_ADDR_VAR 0 33
101724: PUSH
101725: EMPTY
101726: ST_TO_ADDR
// to_repair := [ ] ;
101727: LD_ADDR_VAR 0 32
101731: PUSH
101732: EMPTY
101733: ST_TO_ADDR
// if not group or not path then
101734: LD_VAR 0 4
101738: NOT
101739: PUSH
101740: LD_VAR 0 5
101744: NOT
101745: OR
101746: IFFALSE 101750
// exit ;
101748: GO 106295
// side := GetSide ( group [ 1 ] ) ;
101750: LD_ADDR_VAR 0 35
101754: PUSH
101755: LD_VAR 0 4
101759: PUSH
101760: LD_INT 1
101762: ARRAY
101763: PPUSH
101764: CALL_OW 255
101768: ST_TO_ADDR
// if flags then
101769: LD_VAR 0 6
101773: IFFALSE 101917
// begin f_ignore_area := flags [ 1 ] ;
101775: LD_ADDR_VAR 0 17
101779: PUSH
101780: LD_VAR 0 6
101784: PUSH
101785: LD_INT 1
101787: ARRAY
101788: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
101789: LD_ADDR_VAR 0 18
101793: PUSH
101794: LD_VAR 0 6
101798: PUSH
101799: LD_INT 2
101801: ARRAY
101802: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
101803: LD_ADDR_VAR 0 19
101807: PUSH
101808: LD_VAR 0 6
101812: PUSH
101813: LD_INT 3
101815: ARRAY
101816: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
101817: LD_ADDR_VAR 0 20
101821: PUSH
101822: LD_VAR 0 6
101826: PUSH
101827: LD_INT 4
101829: ARRAY
101830: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
101831: LD_ADDR_VAR 0 21
101835: PUSH
101836: LD_VAR 0 6
101840: PUSH
101841: LD_INT 5
101843: ARRAY
101844: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
101845: LD_ADDR_VAR 0 22
101849: PUSH
101850: LD_VAR 0 6
101854: PUSH
101855: LD_INT 6
101857: ARRAY
101858: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
101859: LD_ADDR_VAR 0 23
101863: PUSH
101864: LD_VAR 0 6
101868: PUSH
101869: LD_INT 7
101871: ARRAY
101872: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
101873: LD_ADDR_VAR 0 24
101877: PUSH
101878: LD_VAR 0 6
101882: PUSH
101883: LD_INT 8
101885: ARRAY
101886: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
101887: LD_ADDR_VAR 0 25
101891: PUSH
101892: LD_VAR 0 6
101896: PUSH
101897: LD_INT 9
101899: ARRAY
101900: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
101901: LD_ADDR_VAR 0 26
101905: PUSH
101906: LD_VAR 0 6
101910: PUSH
101911: LD_INT 10
101913: ARRAY
101914: ST_TO_ADDR
// end else
101915: GO 101997
// begin f_ignore_area := false ;
101917: LD_ADDR_VAR 0 17
101921: PUSH
101922: LD_INT 0
101924: ST_TO_ADDR
// f_capture := false ;
101925: LD_ADDR_VAR 0 18
101929: PUSH
101930: LD_INT 0
101932: ST_TO_ADDR
// f_ignore_civ := false ;
101933: LD_ADDR_VAR 0 19
101937: PUSH
101938: LD_INT 0
101940: ST_TO_ADDR
// f_murder := false ;
101941: LD_ADDR_VAR 0 20
101945: PUSH
101946: LD_INT 0
101948: ST_TO_ADDR
// f_mines := false ;
101949: LD_ADDR_VAR 0 21
101953: PUSH
101954: LD_INT 0
101956: ST_TO_ADDR
// f_repair := false ;
101957: LD_ADDR_VAR 0 22
101961: PUSH
101962: LD_INT 0
101964: ST_TO_ADDR
// f_heal := false ;
101965: LD_ADDR_VAR 0 23
101969: PUSH
101970: LD_INT 0
101972: ST_TO_ADDR
// f_spacetime := false ;
101973: LD_ADDR_VAR 0 24
101977: PUSH
101978: LD_INT 0
101980: ST_TO_ADDR
// f_attack_depot := false ;
101981: LD_ADDR_VAR 0 25
101985: PUSH
101986: LD_INT 0
101988: ST_TO_ADDR
// f_crawl := false ;
101989: LD_ADDR_VAR 0 26
101993: PUSH
101994: LD_INT 0
101996: ST_TO_ADDR
// end ; if f_heal then
101997: LD_VAR 0 23
102001: IFFALSE 102028
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
102003: LD_ADDR_VAR 0 31
102007: PUSH
102008: LD_VAR 0 4
102012: PPUSH
102013: LD_INT 25
102015: PUSH
102016: LD_INT 4
102018: PUSH
102019: EMPTY
102020: LIST
102021: LIST
102022: PPUSH
102023: CALL_OW 72
102027: ST_TO_ADDR
// if f_repair then
102028: LD_VAR 0 22
102032: IFFALSE 102059
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
102034: LD_ADDR_VAR 0 33
102038: PUSH
102039: LD_VAR 0 4
102043: PPUSH
102044: LD_INT 25
102046: PUSH
102047: LD_INT 3
102049: PUSH
102050: EMPTY
102051: LIST
102052: LIST
102053: PPUSH
102054: CALL_OW 72
102058: ST_TO_ADDR
// units_path := [ ] ;
102059: LD_ADDR_VAR 0 16
102063: PUSH
102064: EMPTY
102065: ST_TO_ADDR
// for i = 1 to group do
102066: LD_ADDR_VAR 0 7
102070: PUSH
102071: DOUBLE
102072: LD_INT 1
102074: DEC
102075: ST_TO_ADDR
102076: LD_VAR 0 4
102080: PUSH
102081: FOR_TO
102082: IFFALSE 102111
// units_path := Replace ( units_path , i , path ) ;
102084: LD_ADDR_VAR 0 16
102088: PUSH
102089: LD_VAR 0 16
102093: PPUSH
102094: LD_VAR 0 7
102098: PPUSH
102099: LD_VAR 0 5
102103: PPUSH
102104: CALL_OW 1
102108: ST_TO_ADDR
102109: GO 102081
102111: POP
102112: POP
// repeat for i = group downto 1 do
102113: LD_ADDR_VAR 0 7
102117: PUSH
102118: DOUBLE
102119: LD_VAR 0 4
102123: INC
102124: ST_TO_ADDR
102125: LD_INT 1
102127: PUSH
102128: FOR_DOWNTO
102129: IFFALSE 106251
// begin wait ( 5 ) ;
102131: LD_INT 5
102133: PPUSH
102134: CALL_OW 67
// tmp := [ ] ;
102138: LD_ADDR_VAR 0 14
102142: PUSH
102143: EMPTY
102144: ST_TO_ADDR
// attacking := false ;
102145: LD_ADDR_VAR 0 29
102149: PUSH
102150: LD_INT 0
102152: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
102153: LD_VAR 0 4
102157: PUSH
102158: LD_VAR 0 7
102162: ARRAY
102163: PPUSH
102164: CALL_OW 301
102168: PUSH
102169: LD_VAR 0 4
102173: PUSH
102174: LD_VAR 0 7
102178: ARRAY
102179: NOT
102180: OR
102181: IFFALSE 102290
// begin if GetType ( group [ i ] ) = unit_human then
102183: LD_VAR 0 4
102187: PUSH
102188: LD_VAR 0 7
102192: ARRAY
102193: PPUSH
102194: CALL_OW 247
102198: PUSH
102199: LD_INT 1
102201: EQUAL
102202: IFFALSE 102248
// begin to_heal := to_heal diff group [ i ] ;
102204: LD_ADDR_VAR 0 30
102208: PUSH
102209: LD_VAR 0 30
102213: PUSH
102214: LD_VAR 0 4
102218: PUSH
102219: LD_VAR 0 7
102223: ARRAY
102224: DIFF
102225: ST_TO_ADDR
// healers := healers diff group [ i ] ;
102226: LD_ADDR_VAR 0 31
102230: PUSH
102231: LD_VAR 0 31
102235: PUSH
102236: LD_VAR 0 4
102240: PUSH
102241: LD_VAR 0 7
102245: ARRAY
102246: DIFF
102247: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
102248: LD_ADDR_VAR 0 4
102252: PUSH
102253: LD_VAR 0 4
102257: PPUSH
102258: LD_VAR 0 7
102262: PPUSH
102263: CALL_OW 3
102267: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
102268: LD_ADDR_VAR 0 16
102272: PUSH
102273: LD_VAR 0 16
102277: PPUSH
102278: LD_VAR 0 7
102282: PPUSH
102283: CALL_OW 3
102287: ST_TO_ADDR
// continue ;
102288: GO 102128
// end ; if f_repair then
102290: LD_VAR 0 22
102294: IFFALSE 102783
// begin if GetType ( group [ i ] ) = unit_vehicle then
102296: LD_VAR 0 4
102300: PUSH
102301: LD_VAR 0 7
102305: ARRAY
102306: PPUSH
102307: CALL_OW 247
102311: PUSH
102312: LD_INT 2
102314: EQUAL
102315: IFFALSE 102505
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
102317: LD_VAR 0 4
102321: PUSH
102322: LD_VAR 0 7
102326: ARRAY
102327: PPUSH
102328: CALL_OW 256
102332: PUSH
102333: LD_INT 700
102335: LESS
102336: PUSH
102337: LD_VAR 0 4
102341: PUSH
102342: LD_VAR 0 7
102346: ARRAY
102347: PUSH
102348: LD_VAR 0 32
102352: IN
102353: NOT
102354: AND
102355: IFFALSE 102379
// to_repair := to_repair union group [ i ] ;
102357: LD_ADDR_VAR 0 32
102361: PUSH
102362: LD_VAR 0 32
102366: PUSH
102367: LD_VAR 0 4
102371: PUSH
102372: LD_VAR 0 7
102376: ARRAY
102377: UNION
102378: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
102379: LD_VAR 0 4
102383: PUSH
102384: LD_VAR 0 7
102388: ARRAY
102389: PPUSH
102390: CALL_OW 256
102394: PUSH
102395: LD_INT 1000
102397: EQUAL
102398: PUSH
102399: LD_VAR 0 4
102403: PUSH
102404: LD_VAR 0 7
102408: ARRAY
102409: PUSH
102410: LD_VAR 0 32
102414: IN
102415: AND
102416: IFFALSE 102440
// to_repair := to_repair diff group [ i ] ;
102418: LD_ADDR_VAR 0 32
102422: PUSH
102423: LD_VAR 0 32
102427: PUSH
102428: LD_VAR 0 4
102432: PUSH
102433: LD_VAR 0 7
102437: ARRAY
102438: DIFF
102439: ST_TO_ADDR
// if group [ i ] in to_repair then
102440: LD_VAR 0 4
102444: PUSH
102445: LD_VAR 0 7
102449: ARRAY
102450: PUSH
102451: LD_VAR 0 32
102455: IN
102456: IFFALSE 102503
// begin if not IsInArea ( group [ i ] , f_repair ) then
102458: LD_VAR 0 4
102462: PUSH
102463: LD_VAR 0 7
102467: ARRAY
102468: PPUSH
102469: LD_VAR 0 22
102473: PPUSH
102474: CALL_OW 308
102478: NOT
102479: IFFALSE 102501
// ComMoveToArea ( group [ i ] , f_repair ) ;
102481: LD_VAR 0 4
102485: PUSH
102486: LD_VAR 0 7
102490: ARRAY
102491: PPUSH
102492: LD_VAR 0 22
102496: PPUSH
102497: CALL_OW 113
// continue ;
102501: GO 102128
// end ; end else
102503: GO 102783
// if group [ i ] in repairs then
102505: LD_VAR 0 4
102509: PUSH
102510: LD_VAR 0 7
102514: ARRAY
102515: PUSH
102516: LD_VAR 0 33
102520: IN
102521: IFFALSE 102783
// begin if IsInUnit ( group [ i ] ) then
102523: LD_VAR 0 4
102527: PUSH
102528: LD_VAR 0 7
102532: ARRAY
102533: PPUSH
102534: CALL_OW 310
102538: IFFALSE 102606
// begin z := IsInUnit ( group [ i ] ) ;
102540: LD_ADDR_VAR 0 13
102544: PUSH
102545: LD_VAR 0 4
102549: PUSH
102550: LD_VAR 0 7
102554: ARRAY
102555: PPUSH
102556: CALL_OW 310
102560: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
102561: LD_VAR 0 13
102565: PUSH
102566: LD_VAR 0 32
102570: IN
102571: PUSH
102572: LD_VAR 0 13
102576: PPUSH
102577: LD_VAR 0 22
102581: PPUSH
102582: CALL_OW 308
102586: AND
102587: IFFALSE 102604
// ComExitVehicle ( group [ i ] ) ;
102589: LD_VAR 0 4
102593: PUSH
102594: LD_VAR 0 7
102598: ARRAY
102599: PPUSH
102600: CALL_OW 121
// end else
102604: GO 102783
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
102606: LD_ADDR_VAR 0 13
102610: PUSH
102611: LD_VAR 0 4
102615: PPUSH
102616: LD_INT 95
102618: PUSH
102619: LD_VAR 0 22
102623: PUSH
102624: EMPTY
102625: LIST
102626: LIST
102627: PUSH
102628: LD_INT 58
102630: PUSH
102631: EMPTY
102632: LIST
102633: PUSH
102634: EMPTY
102635: LIST
102636: LIST
102637: PPUSH
102638: CALL_OW 72
102642: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
102643: LD_VAR 0 4
102647: PUSH
102648: LD_VAR 0 7
102652: ARRAY
102653: PPUSH
102654: CALL_OW 314
102658: NOT
102659: IFFALSE 102781
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
102661: LD_ADDR_VAR 0 10
102665: PUSH
102666: LD_VAR 0 13
102670: PPUSH
102671: LD_VAR 0 4
102675: PUSH
102676: LD_VAR 0 7
102680: ARRAY
102681: PPUSH
102682: CALL_OW 74
102686: ST_TO_ADDR
// if not x then
102687: LD_VAR 0 10
102691: NOT
102692: IFFALSE 102696
// continue ;
102694: GO 102128
// if GetLives ( x ) < 1000 then
102696: LD_VAR 0 10
102700: PPUSH
102701: CALL_OW 256
102705: PUSH
102706: LD_INT 1000
102708: LESS
102709: IFFALSE 102733
// ComRepairVehicle ( group [ i ] , x ) else
102711: LD_VAR 0 4
102715: PUSH
102716: LD_VAR 0 7
102720: ARRAY
102721: PPUSH
102722: LD_VAR 0 10
102726: PPUSH
102727: CALL_OW 129
102731: GO 102781
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
102733: LD_VAR 0 23
102737: PUSH
102738: LD_VAR 0 4
102742: PUSH
102743: LD_VAR 0 7
102747: ARRAY
102748: PPUSH
102749: CALL_OW 256
102753: PUSH
102754: LD_INT 1000
102756: LESS
102757: AND
102758: NOT
102759: IFFALSE 102781
// ComEnterUnit ( group [ i ] , x ) ;
102761: LD_VAR 0 4
102765: PUSH
102766: LD_VAR 0 7
102770: ARRAY
102771: PPUSH
102772: LD_VAR 0 10
102776: PPUSH
102777: CALL_OW 120
// end ; continue ;
102781: GO 102128
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
102783: LD_VAR 0 23
102787: PUSH
102788: LD_VAR 0 4
102792: PUSH
102793: LD_VAR 0 7
102797: ARRAY
102798: PPUSH
102799: CALL_OW 247
102803: PUSH
102804: LD_INT 1
102806: EQUAL
102807: AND
102808: IFFALSE 103286
// begin if group [ i ] in healers then
102810: LD_VAR 0 4
102814: PUSH
102815: LD_VAR 0 7
102819: ARRAY
102820: PUSH
102821: LD_VAR 0 31
102825: IN
102826: IFFALSE 103099
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
102828: LD_VAR 0 4
102832: PUSH
102833: LD_VAR 0 7
102837: ARRAY
102838: PPUSH
102839: LD_VAR 0 23
102843: PPUSH
102844: CALL_OW 308
102848: NOT
102849: PUSH
102850: LD_VAR 0 4
102854: PUSH
102855: LD_VAR 0 7
102859: ARRAY
102860: PPUSH
102861: CALL_OW 314
102865: NOT
102866: AND
102867: IFFALSE 102891
// ComMoveToArea ( group [ i ] , f_heal ) else
102869: LD_VAR 0 4
102873: PUSH
102874: LD_VAR 0 7
102878: ARRAY
102879: PPUSH
102880: LD_VAR 0 23
102884: PPUSH
102885: CALL_OW 113
102889: GO 103097
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
102891: LD_VAR 0 4
102895: PUSH
102896: LD_VAR 0 7
102900: ARRAY
102901: PPUSH
102902: CALL 84065 0 1
102906: PPUSH
102907: CALL_OW 256
102911: PUSH
102912: LD_INT 1000
102914: EQUAL
102915: IFFALSE 102934
// ComStop ( group [ i ] ) else
102917: LD_VAR 0 4
102921: PUSH
102922: LD_VAR 0 7
102926: ARRAY
102927: PPUSH
102928: CALL_OW 141
102932: GO 103097
// if not HasTask ( group [ i ] ) and to_heal then
102934: LD_VAR 0 4
102938: PUSH
102939: LD_VAR 0 7
102943: ARRAY
102944: PPUSH
102945: CALL_OW 314
102949: NOT
102950: PUSH
102951: LD_VAR 0 30
102955: AND
102956: IFFALSE 103097
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
102958: LD_ADDR_VAR 0 13
102962: PUSH
102963: LD_VAR 0 30
102967: PPUSH
102968: LD_INT 3
102970: PUSH
102971: LD_INT 54
102973: PUSH
102974: EMPTY
102975: LIST
102976: PUSH
102977: EMPTY
102978: LIST
102979: LIST
102980: PPUSH
102981: CALL_OW 72
102985: PPUSH
102986: LD_VAR 0 4
102990: PUSH
102991: LD_VAR 0 7
102995: ARRAY
102996: PPUSH
102997: CALL_OW 74
103001: ST_TO_ADDR
// if z then
103002: LD_VAR 0 13
103006: IFFALSE 103097
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
103008: LD_INT 91
103010: PUSH
103011: LD_VAR 0 13
103015: PUSH
103016: LD_INT 10
103018: PUSH
103019: EMPTY
103020: LIST
103021: LIST
103022: LIST
103023: PUSH
103024: LD_INT 81
103026: PUSH
103027: LD_VAR 0 13
103031: PPUSH
103032: CALL_OW 255
103036: PUSH
103037: EMPTY
103038: LIST
103039: LIST
103040: PUSH
103041: EMPTY
103042: LIST
103043: LIST
103044: PPUSH
103045: CALL_OW 69
103049: PUSH
103050: LD_INT 0
103052: EQUAL
103053: IFFALSE 103077
// ComHeal ( group [ i ] , z ) else
103055: LD_VAR 0 4
103059: PUSH
103060: LD_VAR 0 7
103064: ARRAY
103065: PPUSH
103066: LD_VAR 0 13
103070: PPUSH
103071: CALL_OW 128
103075: GO 103097
// ComMoveToArea ( group [ i ] , f_heal ) ;
103077: LD_VAR 0 4
103081: PUSH
103082: LD_VAR 0 7
103086: ARRAY
103087: PPUSH
103088: LD_VAR 0 23
103092: PPUSH
103093: CALL_OW 113
// end ; continue ;
103097: GO 102128
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
103099: LD_VAR 0 4
103103: PUSH
103104: LD_VAR 0 7
103108: ARRAY
103109: PPUSH
103110: CALL_OW 256
103114: PUSH
103115: LD_INT 700
103117: LESS
103118: PUSH
103119: LD_VAR 0 4
103123: PUSH
103124: LD_VAR 0 7
103128: ARRAY
103129: PUSH
103130: LD_VAR 0 30
103134: IN
103135: NOT
103136: AND
103137: IFFALSE 103161
// to_heal := to_heal union group [ i ] ;
103139: LD_ADDR_VAR 0 30
103143: PUSH
103144: LD_VAR 0 30
103148: PUSH
103149: LD_VAR 0 4
103153: PUSH
103154: LD_VAR 0 7
103158: ARRAY
103159: UNION
103160: ST_TO_ADDR
// if group [ i ] in to_heal then
103161: LD_VAR 0 4
103165: PUSH
103166: LD_VAR 0 7
103170: ARRAY
103171: PUSH
103172: LD_VAR 0 30
103176: IN
103177: IFFALSE 103286
// begin if GetLives ( group [ i ] ) = 1000 then
103179: LD_VAR 0 4
103183: PUSH
103184: LD_VAR 0 7
103188: ARRAY
103189: PPUSH
103190: CALL_OW 256
103194: PUSH
103195: LD_INT 1000
103197: EQUAL
103198: IFFALSE 103224
// to_heal := to_heal diff group [ i ] else
103200: LD_ADDR_VAR 0 30
103204: PUSH
103205: LD_VAR 0 30
103209: PUSH
103210: LD_VAR 0 4
103214: PUSH
103215: LD_VAR 0 7
103219: ARRAY
103220: DIFF
103221: ST_TO_ADDR
103222: GO 103286
// begin if not IsInArea ( group [ i ] , to_heal ) then
103224: LD_VAR 0 4
103228: PUSH
103229: LD_VAR 0 7
103233: ARRAY
103234: PPUSH
103235: LD_VAR 0 30
103239: PPUSH
103240: CALL_OW 308
103244: NOT
103245: IFFALSE 103269
// ComMoveToArea ( group [ i ] , f_heal ) else
103247: LD_VAR 0 4
103251: PUSH
103252: LD_VAR 0 7
103256: ARRAY
103257: PPUSH
103258: LD_VAR 0 23
103262: PPUSH
103263: CALL_OW 113
103267: GO 103284
// ComHold ( group [ i ] ) ;
103269: LD_VAR 0 4
103273: PUSH
103274: LD_VAR 0 7
103278: ARRAY
103279: PPUSH
103280: CALL_OW 140
// continue ;
103284: GO 102128
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
103286: LD_VAR 0 4
103290: PUSH
103291: LD_VAR 0 7
103295: ARRAY
103296: PPUSH
103297: LD_INT 10
103299: PPUSH
103300: CALL 82485 0 2
103304: NOT
103305: PUSH
103306: LD_VAR 0 16
103310: PUSH
103311: LD_VAR 0 7
103315: ARRAY
103316: PUSH
103317: EMPTY
103318: EQUAL
103319: NOT
103320: AND
103321: IFFALSE 103587
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
103323: LD_VAR 0 4
103327: PUSH
103328: LD_VAR 0 7
103332: ARRAY
103333: PPUSH
103334: CALL_OW 262
103338: PUSH
103339: LD_INT 1
103341: PUSH
103342: LD_INT 2
103344: PUSH
103345: EMPTY
103346: LIST
103347: LIST
103348: IN
103349: IFFALSE 103390
// if GetFuel ( group [ i ] ) < 10 then
103351: LD_VAR 0 4
103355: PUSH
103356: LD_VAR 0 7
103360: ARRAY
103361: PPUSH
103362: CALL_OW 261
103366: PUSH
103367: LD_INT 10
103369: LESS
103370: IFFALSE 103390
// SetFuel ( group [ i ] , 12 ) ;
103372: LD_VAR 0 4
103376: PUSH
103377: LD_VAR 0 7
103381: ARRAY
103382: PPUSH
103383: LD_INT 12
103385: PPUSH
103386: CALL_OW 240
// if units_path [ i ] then
103390: LD_VAR 0 16
103394: PUSH
103395: LD_VAR 0 7
103399: ARRAY
103400: IFFALSE 103585
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
103402: LD_VAR 0 4
103406: PUSH
103407: LD_VAR 0 7
103411: ARRAY
103412: PPUSH
103413: LD_VAR 0 16
103417: PUSH
103418: LD_VAR 0 7
103422: ARRAY
103423: PUSH
103424: LD_INT 1
103426: ARRAY
103427: PUSH
103428: LD_INT 1
103430: ARRAY
103431: PPUSH
103432: LD_VAR 0 16
103436: PUSH
103437: LD_VAR 0 7
103441: ARRAY
103442: PUSH
103443: LD_INT 1
103445: ARRAY
103446: PUSH
103447: LD_INT 2
103449: ARRAY
103450: PPUSH
103451: CALL_OW 297
103455: PUSH
103456: LD_INT 6
103458: GREATER
103459: IFFALSE 103534
// begin if not HasTask ( group [ i ] ) then
103461: LD_VAR 0 4
103465: PUSH
103466: LD_VAR 0 7
103470: ARRAY
103471: PPUSH
103472: CALL_OW 314
103476: NOT
103477: IFFALSE 103532
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
103479: LD_VAR 0 4
103483: PUSH
103484: LD_VAR 0 7
103488: ARRAY
103489: PPUSH
103490: LD_VAR 0 16
103494: PUSH
103495: LD_VAR 0 7
103499: ARRAY
103500: PUSH
103501: LD_INT 1
103503: ARRAY
103504: PUSH
103505: LD_INT 1
103507: ARRAY
103508: PPUSH
103509: LD_VAR 0 16
103513: PUSH
103514: LD_VAR 0 7
103518: ARRAY
103519: PUSH
103520: LD_INT 1
103522: ARRAY
103523: PUSH
103524: LD_INT 2
103526: ARRAY
103527: PPUSH
103528: CALL_OW 114
// end else
103532: GO 103585
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
103534: LD_ADDR_VAR 0 15
103538: PUSH
103539: LD_VAR 0 16
103543: PUSH
103544: LD_VAR 0 7
103548: ARRAY
103549: PPUSH
103550: LD_INT 1
103552: PPUSH
103553: CALL_OW 3
103557: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
103558: LD_ADDR_VAR 0 16
103562: PUSH
103563: LD_VAR 0 16
103567: PPUSH
103568: LD_VAR 0 7
103572: PPUSH
103573: LD_VAR 0 15
103577: PPUSH
103578: CALL_OW 1
103582: ST_TO_ADDR
// continue ;
103583: GO 102128
// end ; end ; end else
103585: GO 106249
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
103587: LD_ADDR_VAR 0 14
103591: PUSH
103592: LD_INT 81
103594: PUSH
103595: LD_VAR 0 4
103599: PUSH
103600: LD_VAR 0 7
103604: ARRAY
103605: PPUSH
103606: CALL_OW 255
103610: PUSH
103611: EMPTY
103612: LIST
103613: LIST
103614: PPUSH
103615: CALL_OW 69
103619: ST_TO_ADDR
// if not tmp then
103620: LD_VAR 0 14
103624: NOT
103625: IFFALSE 103629
// continue ;
103627: GO 102128
// if f_ignore_area then
103629: LD_VAR 0 17
103633: IFFALSE 103721
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
103635: LD_ADDR_VAR 0 15
103639: PUSH
103640: LD_VAR 0 14
103644: PPUSH
103645: LD_INT 3
103647: PUSH
103648: LD_INT 92
103650: PUSH
103651: LD_VAR 0 17
103655: PUSH
103656: LD_INT 1
103658: ARRAY
103659: PUSH
103660: LD_VAR 0 17
103664: PUSH
103665: LD_INT 2
103667: ARRAY
103668: PUSH
103669: LD_VAR 0 17
103673: PUSH
103674: LD_INT 3
103676: ARRAY
103677: PUSH
103678: EMPTY
103679: LIST
103680: LIST
103681: LIST
103682: LIST
103683: PUSH
103684: EMPTY
103685: LIST
103686: LIST
103687: PPUSH
103688: CALL_OW 72
103692: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103693: LD_VAR 0 14
103697: PUSH
103698: LD_VAR 0 15
103702: DIFF
103703: IFFALSE 103721
// tmp := tmp diff tmp2 ;
103705: LD_ADDR_VAR 0 14
103709: PUSH
103710: LD_VAR 0 14
103714: PUSH
103715: LD_VAR 0 15
103719: DIFF
103720: ST_TO_ADDR
// end ; if not f_murder then
103721: LD_VAR 0 20
103725: NOT
103726: IFFALSE 103784
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
103728: LD_ADDR_VAR 0 15
103732: PUSH
103733: LD_VAR 0 14
103737: PPUSH
103738: LD_INT 3
103740: PUSH
103741: LD_INT 50
103743: PUSH
103744: EMPTY
103745: LIST
103746: PUSH
103747: EMPTY
103748: LIST
103749: LIST
103750: PPUSH
103751: CALL_OW 72
103755: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103756: LD_VAR 0 14
103760: PUSH
103761: LD_VAR 0 15
103765: DIFF
103766: IFFALSE 103784
// tmp := tmp diff tmp2 ;
103768: LD_ADDR_VAR 0 14
103772: PUSH
103773: LD_VAR 0 14
103777: PUSH
103778: LD_VAR 0 15
103782: DIFF
103783: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
103784: LD_ADDR_VAR 0 14
103788: PUSH
103789: LD_VAR 0 4
103793: PUSH
103794: LD_VAR 0 7
103798: ARRAY
103799: PPUSH
103800: LD_VAR 0 14
103804: PPUSH
103805: LD_INT 1
103807: PPUSH
103808: LD_INT 1
103810: PPUSH
103811: CALL 56128 0 4
103815: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
103816: LD_VAR 0 4
103820: PUSH
103821: LD_VAR 0 7
103825: ARRAY
103826: PPUSH
103827: CALL_OW 257
103831: PUSH
103832: LD_INT 1
103834: EQUAL
103835: IFFALSE 104283
// begin if WantPlant ( group [ i ] ) then
103837: LD_VAR 0 4
103841: PUSH
103842: LD_VAR 0 7
103846: ARRAY
103847: PPUSH
103848: CALL 55629 0 1
103852: IFFALSE 103856
// continue ;
103854: GO 102128
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
103856: LD_VAR 0 18
103860: PUSH
103861: LD_VAR 0 4
103865: PUSH
103866: LD_VAR 0 7
103870: ARRAY
103871: PPUSH
103872: CALL_OW 310
103876: NOT
103877: AND
103878: PUSH
103879: LD_VAR 0 14
103883: PUSH
103884: LD_INT 1
103886: ARRAY
103887: PUSH
103888: LD_VAR 0 14
103892: PPUSH
103893: LD_INT 21
103895: PUSH
103896: LD_INT 2
103898: PUSH
103899: EMPTY
103900: LIST
103901: LIST
103902: PUSH
103903: LD_INT 58
103905: PUSH
103906: EMPTY
103907: LIST
103908: PUSH
103909: EMPTY
103910: LIST
103911: LIST
103912: PPUSH
103913: CALL_OW 72
103917: IN
103918: AND
103919: IFFALSE 103955
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
103921: LD_VAR 0 4
103925: PUSH
103926: LD_VAR 0 7
103930: ARRAY
103931: PPUSH
103932: LD_VAR 0 14
103936: PUSH
103937: LD_INT 1
103939: ARRAY
103940: PPUSH
103941: CALL_OW 120
// attacking := true ;
103945: LD_ADDR_VAR 0 29
103949: PUSH
103950: LD_INT 1
103952: ST_TO_ADDR
// continue ;
103953: GO 102128
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
103955: LD_VAR 0 26
103959: PUSH
103960: LD_VAR 0 4
103964: PUSH
103965: LD_VAR 0 7
103969: ARRAY
103970: PPUSH
103971: CALL_OW 257
103975: PUSH
103976: LD_INT 1
103978: EQUAL
103979: AND
103980: PUSH
103981: LD_VAR 0 4
103985: PUSH
103986: LD_VAR 0 7
103990: ARRAY
103991: PPUSH
103992: CALL_OW 256
103996: PUSH
103997: LD_INT 800
103999: LESS
104000: AND
104001: PUSH
104002: LD_VAR 0 4
104006: PUSH
104007: LD_VAR 0 7
104011: ARRAY
104012: PPUSH
104013: CALL_OW 318
104017: NOT
104018: AND
104019: IFFALSE 104036
// ComCrawl ( group [ i ] ) ;
104021: LD_VAR 0 4
104025: PUSH
104026: LD_VAR 0 7
104030: ARRAY
104031: PPUSH
104032: CALL_OW 137
// if f_mines then
104036: LD_VAR 0 21
104040: IFFALSE 104283
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
104042: LD_VAR 0 14
104046: PUSH
104047: LD_INT 1
104049: ARRAY
104050: PPUSH
104051: CALL_OW 247
104055: PUSH
104056: LD_INT 3
104058: EQUAL
104059: PUSH
104060: LD_VAR 0 14
104064: PUSH
104065: LD_INT 1
104067: ARRAY
104068: PUSH
104069: LD_VAR 0 27
104073: IN
104074: NOT
104075: AND
104076: IFFALSE 104283
// begin x := GetX ( tmp [ 1 ] ) ;
104078: LD_ADDR_VAR 0 10
104082: PUSH
104083: LD_VAR 0 14
104087: PUSH
104088: LD_INT 1
104090: ARRAY
104091: PPUSH
104092: CALL_OW 250
104096: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
104097: LD_ADDR_VAR 0 11
104101: PUSH
104102: LD_VAR 0 14
104106: PUSH
104107: LD_INT 1
104109: ARRAY
104110: PPUSH
104111: CALL_OW 251
104115: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
104116: LD_ADDR_VAR 0 12
104120: PUSH
104121: LD_VAR 0 4
104125: PUSH
104126: LD_VAR 0 7
104130: ARRAY
104131: PPUSH
104132: CALL 82570 0 1
104136: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
104137: LD_VAR 0 4
104141: PUSH
104142: LD_VAR 0 7
104146: ARRAY
104147: PPUSH
104148: LD_VAR 0 10
104152: PPUSH
104153: LD_VAR 0 11
104157: PPUSH
104158: LD_VAR 0 14
104162: PUSH
104163: LD_INT 1
104165: ARRAY
104166: PPUSH
104167: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
104171: LD_VAR 0 4
104175: PUSH
104176: LD_VAR 0 7
104180: ARRAY
104181: PPUSH
104182: LD_VAR 0 10
104186: PPUSH
104187: LD_VAR 0 12
104191: PPUSH
104192: LD_INT 7
104194: PPUSH
104195: CALL_OW 272
104199: PPUSH
104200: LD_VAR 0 11
104204: PPUSH
104205: LD_VAR 0 12
104209: PPUSH
104210: LD_INT 7
104212: PPUSH
104213: CALL_OW 273
104217: PPUSH
104218: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
104222: LD_VAR 0 4
104226: PUSH
104227: LD_VAR 0 7
104231: ARRAY
104232: PPUSH
104233: LD_INT 71
104235: PPUSH
104236: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
104240: LD_ADDR_VAR 0 27
104244: PUSH
104245: LD_VAR 0 27
104249: PPUSH
104250: LD_VAR 0 27
104254: PUSH
104255: LD_INT 1
104257: PLUS
104258: PPUSH
104259: LD_VAR 0 14
104263: PUSH
104264: LD_INT 1
104266: ARRAY
104267: PPUSH
104268: CALL_OW 1
104272: ST_TO_ADDR
// attacking := true ;
104273: LD_ADDR_VAR 0 29
104277: PUSH
104278: LD_INT 1
104280: ST_TO_ADDR
// continue ;
104281: GO 102128
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
104283: LD_VAR 0 4
104287: PUSH
104288: LD_VAR 0 7
104292: ARRAY
104293: PPUSH
104294: CALL_OW 257
104298: PUSH
104299: LD_INT 17
104301: EQUAL
104302: PUSH
104303: LD_VAR 0 4
104307: PUSH
104308: LD_VAR 0 7
104312: ARRAY
104313: PPUSH
104314: CALL_OW 110
104318: PUSH
104319: LD_INT 71
104321: EQUAL
104322: NOT
104323: AND
104324: IFFALSE 104470
// begin attacking := false ;
104326: LD_ADDR_VAR 0 29
104330: PUSH
104331: LD_INT 0
104333: ST_TO_ADDR
// k := 5 ;
104334: LD_ADDR_VAR 0 9
104338: PUSH
104339: LD_INT 5
104341: ST_TO_ADDR
// if tmp < k then
104342: LD_VAR 0 14
104346: PUSH
104347: LD_VAR 0 9
104351: LESS
104352: IFFALSE 104364
// k := tmp ;
104354: LD_ADDR_VAR 0 9
104358: PUSH
104359: LD_VAR 0 14
104363: ST_TO_ADDR
// for j = 1 to k do
104364: LD_ADDR_VAR 0 8
104368: PUSH
104369: DOUBLE
104370: LD_INT 1
104372: DEC
104373: ST_TO_ADDR
104374: LD_VAR 0 9
104378: PUSH
104379: FOR_TO
104380: IFFALSE 104468
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
104382: LD_VAR 0 14
104386: PUSH
104387: LD_VAR 0 8
104391: ARRAY
104392: PUSH
104393: LD_VAR 0 14
104397: PPUSH
104398: LD_INT 58
104400: PUSH
104401: EMPTY
104402: LIST
104403: PPUSH
104404: CALL_OW 72
104408: IN
104409: NOT
104410: IFFALSE 104466
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104412: LD_VAR 0 4
104416: PUSH
104417: LD_VAR 0 7
104421: ARRAY
104422: PPUSH
104423: LD_VAR 0 14
104427: PUSH
104428: LD_VAR 0 8
104432: ARRAY
104433: PPUSH
104434: CALL_OW 115
// attacking := true ;
104438: LD_ADDR_VAR 0 29
104442: PUSH
104443: LD_INT 1
104445: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
104446: LD_VAR 0 4
104450: PUSH
104451: LD_VAR 0 7
104455: ARRAY
104456: PPUSH
104457: LD_INT 71
104459: PPUSH
104460: CALL_OW 109
// continue ;
104464: GO 104379
// end ; end ;
104466: GO 104379
104468: POP
104469: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
104470: LD_VAR 0 4
104474: PUSH
104475: LD_VAR 0 7
104479: ARRAY
104480: PPUSH
104481: CALL_OW 257
104485: PUSH
104486: LD_INT 8
104488: EQUAL
104489: PUSH
104490: LD_VAR 0 4
104494: PUSH
104495: LD_VAR 0 7
104499: ARRAY
104500: PPUSH
104501: CALL_OW 264
104505: PUSH
104506: LD_INT 28
104508: PUSH
104509: LD_INT 45
104511: PUSH
104512: LD_INT 7
104514: PUSH
104515: LD_INT 47
104517: PUSH
104518: EMPTY
104519: LIST
104520: LIST
104521: LIST
104522: LIST
104523: IN
104524: OR
104525: IFFALSE 104781
// begin attacking := false ;
104527: LD_ADDR_VAR 0 29
104531: PUSH
104532: LD_INT 0
104534: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
104535: LD_VAR 0 14
104539: PUSH
104540: LD_INT 1
104542: ARRAY
104543: PPUSH
104544: CALL_OW 266
104548: PUSH
104549: LD_INT 32
104551: PUSH
104552: LD_INT 31
104554: PUSH
104555: LD_INT 33
104557: PUSH
104558: LD_INT 4
104560: PUSH
104561: LD_INT 5
104563: PUSH
104564: EMPTY
104565: LIST
104566: LIST
104567: LIST
104568: LIST
104569: LIST
104570: IN
104571: IFFALSE 104757
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
104573: LD_ADDR_VAR 0 9
104577: PUSH
104578: LD_VAR 0 14
104582: PUSH
104583: LD_INT 1
104585: ARRAY
104586: PPUSH
104587: CALL_OW 266
104591: PPUSH
104592: LD_VAR 0 14
104596: PUSH
104597: LD_INT 1
104599: ARRAY
104600: PPUSH
104601: CALL_OW 250
104605: PPUSH
104606: LD_VAR 0 14
104610: PUSH
104611: LD_INT 1
104613: ARRAY
104614: PPUSH
104615: CALL_OW 251
104619: PPUSH
104620: LD_VAR 0 14
104624: PUSH
104625: LD_INT 1
104627: ARRAY
104628: PPUSH
104629: CALL_OW 254
104633: PPUSH
104634: LD_VAR 0 14
104638: PUSH
104639: LD_INT 1
104641: ARRAY
104642: PPUSH
104643: CALL_OW 248
104647: PPUSH
104648: LD_INT 0
104650: PPUSH
104651: CALL 63940 0 6
104655: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
104656: LD_ADDR_VAR 0 8
104660: PUSH
104661: LD_VAR 0 4
104665: PUSH
104666: LD_VAR 0 7
104670: ARRAY
104671: PPUSH
104672: LD_VAR 0 9
104676: PPUSH
104677: CALL 82610 0 2
104681: ST_TO_ADDR
// if j then
104682: LD_VAR 0 8
104686: IFFALSE 104755
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
104688: LD_VAR 0 8
104692: PUSH
104693: LD_INT 1
104695: ARRAY
104696: PPUSH
104697: LD_VAR 0 8
104701: PUSH
104702: LD_INT 2
104704: ARRAY
104705: PPUSH
104706: CALL_OW 488
104710: IFFALSE 104755
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
104712: LD_VAR 0 4
104716: PUSH
104717: LD_VAR 0 7
104721: ARRAY
104722: PPUSH
104723: LD_VAR 0 8
104727: PUSH
104728: LD_INT 1
104730: ARRAY
104731: PPUSH
104732: LD_VAR 0 8
104736: PUSH
104737: LD_INT 2
104739: ARRAY
104740: PPUSH
104741: CALL_OW 116
// attacking := true ;
104745: LD_ADDR_VAR 0 29
104749: PUSH
104750: LD_INT 1
104752: ST_TO_ADDR
// continue ;
104753: GO 102128
// end ; end else
104755: GO 104781
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104757: LD_VAR 0 4
104761: PUSH
104762: LD_VAR 0 7
104766: ARRAY
104767: PPUSH
104768: LD_VAR 0 14
104772: PUSH
104773: LD_INT 1
104775: ARRAY
104776: PPUSH
104777: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
104781: LD_VAR 0 4
104785: PUSH
104786: LD_VAR 0 7
104790: ARRAY
104791: PPUSH
104792: CALL_OW 265
104796: PUSH
104797: LD_INT 11
104799: EQUAL
104800: IFFALSE 105078
// begin k := 10 ;
104802: LD_ADDR_VAR 0 9
104806: PUSH
104807: LD_INT 10
104809: ST_TO_ADDR
// x := 0 ;
104810: LD_ADDR_VAR 0 10
104814: PUSH
104815: LD_INT 0
104817: ST_TO_ADDR
// if tmp < k then
104818: LD_VAR 0 14
104822: PUSH
104823: LD_VAR 0 9
104827: LESS
104828: IFFALSE 104840
// k := tmp ;
104830: LD_ADDR_VAR 0 9
104834: PUSH
104835: LD_VAR 0 14
104839: ST_TO_ADDR
// for j = k downto 1 do
104840: LD_ADDR_VAR 0 8
104844: PUSH
104845: DOUBLE
104846: LD_VAR 0 9
104850: INC
104851: ST_TO_ADDR
104852: LD_INT 1
104854: PUSH
104855: FOR_DOWNTO
104856: IFFALSE 104931
// begin if GetType ( tmp [ j ] ) = unit_human then
104858: LD_VAR 0 14
104862: PUSH
104863: LD_VAR 0 8
104867: ARRAY
104868: PPUSH
104869: CALL_OW 247
104873: PUSH
104874: LD_INT 1
104876: EQUAL
104877: IFFALSE 104929
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
104879: LD_VAR 0 4
104883: PUSH
104884: LD_VAR 0 7
104888: ARRAY
104889: PPUSH
104890: LD_VAR 0 14
104894: PUSH
104895: LD_VAR 0 8
104899: ARRAY
104900: PPUSH
104901: CALL 82881 0 2
// x := tmp [ j ] ;
104905: LD_ADDR_VAR 0 10
104909: PUSH
104910: LD_VAR 0 14
104914: PUSH
104915: LD_VAR 0 8
104919: ARRAY
104920: ST_TO_ADDR
// attacking := true ;
104921: LD_ADDR_VAR 0 29
104925: PUSH
104926: LD_INT 1
104928: ST_TO_ADDR
// end ; end ;
104929: GO 104855
104931: POP
104932: POP
// if not x then
104933: LD_VAR 0 10
104937: NOT
104938: IFFALSE 105078
// begin attacking := true ;
104940: LD_ADDR_VAR 0 29
104944: PUSH
104945: LD_INT 1
104947: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
104948: LD_VAR 0 4
104952: PUSH
104953: LD_VAR 0 7
104957: ARRAY
104958: PPUSH
104959: CALL_OW 250
104963: PPUSH
104964: LD_VAR 0 4
104968: PUSH
104969: LD_VAR 0 7
104973: ARRAY
104974: PPUSH
104975: CALL_OW 251
104979: PPUSH
104980: CALL_OW 546
104984: PUSH
104985: LD_INT 2
104987: ARRAY
104988: PUSH
104989: LD_VAR 0 14
104993: PUSH
104994: LD_INT 1
104996: ARRAY
104997: PPUSH
104998: CALL_OW 250
105002: PPUSH
105003: LD_VAR 0 14
105007: PUSH
105008: LD_INT 1
105010: ARRAY
105011: PPUSH
105012: CALL_OW 251
105016: PPUSH
105017: CALL_OW 546
105021: PUSH
105022: LD_INT 2
105024: ARRAY
105025: EQUAL
105026: IFFALSE 105054
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
105028: LD_VAR 0 4
105032: PUSH
105033: LD_VAR 0 7
105037: ARRAY
105038: PPUSH
105039: LD_VAR 0 14
105043: PUSH
105044: LD_INT 1
105046: ARRAY
105047: PPUSH
105048: CALL 82881 0 2
105052: GO 105078
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105054: LD_VAR 0 4
105058: PUSH
105059: LD_VAR 0 7
105063: ARRAY
105064: PPUSH
105065: LD_VAR 0 14
105069: PUSH
105070: LD_INT 1
105072: ARRAY
105073: PPUSH
105074: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
105078: LD_VAR 0 4
105082: PUSH
105083: LD_VAR 0 7
105087: ARRAY
105088: PPUSH
105089: CALL_OW 264
105093: PUSH
105094: LD_INT 29
105096: EQUAL
105097: IFFALSE 105463
// begin if WantsToAttack ( group [ i ] ) in bombed then
105099: LD_VAR 0 4
105103: PUSH
105104: LD_VAR 0 7
105108: ARRAY
105109: PPUSH
105110: CALL_OW 319
105114: PUSH
105115: LD_VAR 0 28
105119: IN
105120: IFFALSE 105124
// continue ;
105122: GO 102128
// k := 8 ;
105124: LD_ADDR_VAR 0 9
105128: PUSH
105129: LD_INT 8
105131: ST_TO_ADDR
// x := 0 ;
105132: LD_ADDR_VAR 0 10
105136: PUSH
105137: LD_INT 0
105139: ST_TO_ADDR
// if tmp < k then
105140: LD_VAR 0 14
105144: PUSH
105145: LD_VAR 0 9
105149: LESS
105150: IFFALSE 105162
// k := tmp ;
105152: LD_ADDR_VAR 0 9
105156: PUSH
105157: LD_VAR 0 14
105161: ST_TO_ADDR
// for j = 1 to k do
105162: LD_ADDR_VAR 0 8
105166: PUSH
105167: DOUBLE
105168: LD_INT 1
105170: DEC
105171: ST_TO_ADDR
105172: LD_VAR 0 9
105176: PUSH
105177: FOR_TO
105178: IFFALSE 105310
// begin if GetType ( tmp [ j ] ) = unit_building then
105180: LD_VAR 0 14
105184: PUSH
105185: LD_VAR 0 8
105189: ARRAY
105190: PPUSH
105191: CALL_OW 247
105195: PUSH
105196: LD_INT 3
105198: EQUAL
105199: IFFALSE 105308
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
105201: LD_VAR 0 14
105205: PUSH
105206: LD_VAR 0 8
105210: ARRAY
105211: PUSH
105212: LD_VAR 0 28
105216: IN
105217: NOT
105218: PUSH
105219: LD_VAR 0 14
105223: PUSH
105224: LD_VAR 0 8
105228: ARRAY
105229: PPUSH
105230: CALL_OW 313
105234: AND
105235: IFFALSE 105308
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105237: LD_VAR 0 4
105241: PUSH
105242: LD_VAR 0 7
105246: ARRAY
105247: PPUSH
105248: LD_VAR 0 14
105252: PUSH
105253: LD_VAR 0 8
105257: ARRAY
105258: PPUSH
105259: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
105263: LD_ADDR_VAR 0 28
105267: PUSH
105268: LD_VAR 0 28
105272: PPUSH
105273: LD_VAR 0 28
105277: PUSH
105278: LD_INT 1
105280: PLUS
105281: PPUSH
105282: LD_VAR 0 14
105286: PUSH
105287: LD_VAR 0 8
105291: ARRAY
105292: PPUSH
105293: CALL_OW 1
105297: ST_TO_ADDR
// attacking := true ;
105298: LD_ADDR_VAR 0 29
105302: PUSH
105303: LD_INT 1
105305: ST_TO_ADDR
// break ;
105306: GO 105310
// end ; end ;
105308: GO 105177
105310: POP
105311: POP
// if not attacking and f_attack_depot then
105312: LD_VAR 0 29
105316: NOT
105317: PUSH
105318: LD_VAR 0 25
105322: AND
105323: IFFALSE 105418
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105325: LD_ADDR_VAR 0 13
105329: PUSH
105330: LD_VAR 0 14
105334: PPUSH
105335: LD_INT 2
105337: PUSH
105338: LD_INT 30
105340: PUSH
105341: LD_INT 0
105343: PUSH
105344: EMPTY
105345: LIST
105346: LIST
105347: PUSH
105348: LD_INT 30
105350: PUSH
105351: LD_INT 1
105353: PUSH
105354: EMPTY
105355: LIST
105356: LIST
105357: PUSH
105358: EMPTY
105359: LIST
105360: LIST
105361: LIST
105362: PPUSH
105363: CALL_OW 72
105367: ST_TO_ADDR
// if z then
105368: LD_VAR 0 13
105372: IFFALSE 105418
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
105374: LD_VAR 0 4
105378: PUSH
105379: LD_VAR 0 7
105383: ARRAY
105384: PPUSH
105385: LD_VAR 0 13
105389: PPUSH
105390: LD_VAR 0 4
105394: PUSH
105395: LD_VAR 0 7
105399: ARRAY
105400: PPUSH
105401: CALL_OW 74
105405: PPUSH
105406: CALL_OW 115
// attacking := true ;
105410: LD_ADDR_VAR 0 29
105414: PUSH
105415: LD_INT 1
105417: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
105418: LD_VAR 0 4
105422: PUSH
105423: LD_VAR 0 7
105427: ARRAY
105428: PPUSH
105429: CALL_OW 256
105433: PUSH
105434: LD_INT 500
105436: LESS
105437: IFFALSE 105463
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105439: LD_VAR 0 4
105443: PUSH
105444: LD_VAR 0 7
105448: ARRAY
105449: PPUSH
105450: LD_VAR 0 14
105454: PUSH
105455: LD_INT 1
105457: ARRAY
105458: PPUSH
105459: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
105463: LD_VAR 0 4
105467: PUSH
105468: LD_VAR 0 7
105472: ARRAY
105473: PPUSH
105474: CALL_OW 264
105478: PUSH
105479: LD_INT 49
105481: EQUAL
105482: IFFALSE 105603
// begin if not HasTask ( group [ i ] ) then
105484: LD_VAR 0 4
105488: PUSH
105489: LD_VAR 0 7
105493: ARRAY
105494: PPUSH
105495: CALL_OW 314
105499: NOT
105500: IFFALSE 105603
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
105502: LD_ADDR_VAR 0 9
105506: PUSH
105507: LD_INT 81
105509: PUSH
105510: LD_VAR 0 4
105514: PUSH
105515: LD_VAR 0 7
105519: ARRAY
105520: PPUSH
105521: CALL_OW 255
105525: PUSH
105526: EMPTY
105527: LIST
105528: LIST
105529: PPUSH
105530: CALL_OW 69
105534: PPUSH
105535: LD_VAR 0 4
105539: PUSH
105540: LD_VAR 0 7
105544: ARRAY
105545: PPUSH
105546: CALL_OW 74
105550: ST_TO_ADDR
// if k then
105551: LD_VAR 0 9
105555: IFFALSE 105603
// if GetDistUnits ( group [ i ] , k ) > 10 then
105557: LD_VAR 0 4
105561: PUSH
105562: LD_VAR 0 7
105566: ARRAY
105567: PPUSH
105568: LD_VAR 0 9
105572: PPUSH
105573: CALL_OW 296
105577: PUSH
105578: LD_INT 10
105580: GREATER
105581: IFFALSE 105603
// ComMoveUnit ( group [ i ] , k ) ;
105583: LD_VAR 0 4
105587: PUSH
105588: LD_VAR 0 7
105592: ARRAY
105593: PPUSH
105594: LD_VAR 0 9
105598: PPUSH
105599: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
105603: LD_VAR 0 4
105607: PUSH
105608: LD_VAR 0 7
105612: ARRAY
105613: PPUSH
105614: CALL_OW 256
105618: PUSH
105619: LD_INT 250
105621: LESS
105622: PUSH
105623: LD_VAR 0 4
105627: PUSH
105628: LD_VAR 0 7
105632: ARRAY
105633: PUSH
105634: LD_INT 21
105636: PUSH
105637: LD_INT 2
105639: PUSH
105640: EMPTY
105641: LIST
105642: LIST
105643: PUSH
105644: LD_INT 23
105646: PUSH
105647: LD_INT 2
105649: PUSH
105650: EMPTY
105651: LIST
105652: LIST
105653: PUSH
105654: EMPTY
105655: LIST
105656: LIST
105657: PPUSH
105658: CALL_OW 69
105662: IN
105663: AND
105664: IFFALSE 105789
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
105666: LD_ADDR_VAR 0 9
105670: PUSH
105671: LD_OWVAR 3
105675: PUSH
105676: LD_VAR 0 4
105680: PUSH
105681: LD_VAR 0 7
105685: ARRAY
105686: DIFF
105687: PPUSH
105688: LD_VAR 0 4
105692: PUSH
105693: LD_VAR 0 7
105697: ARRAY
105698: PPUSH
105699: CALL_OW 74
105703: ST_TO_ADDR
// if not k then
105704: LD_VAR 0 9
105708: NOT
105709: IFFALSE 105713
// continue ;
105711: GO 102128
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
105713: LD_VAR 0 9
105717: PUSH
105718: LD_INT 81
105720: PUSH
105721: LD_VAR 0 4
105725: PUSH
105726: LD_VAR 0 7
105730: ARRAY
105731: PPUSH
105732: CALL_OW 255
105736: PUSH
105737: EMPTY
105738: LIST
105739: LIST
105740: PPUSH
105741: CALL_OW 69
105745: IN
105746: PUSH
105747: LD_VAR 0 9
105751: PPUSH
105752: LD_VAR 0 4
105756: PUSH
105757: LD_VAR 0 7
105761: ARRAY
105762: PPUSH
105763: CALL_OW 296
105767: PUSH
105768: LD_INT 5
105770: LESS
105771: AND
105772: IFFALSE 105789
// ComAutodestruct ( group [ i ] ) ;
105774: LD_VAR 0 4
105778: PUSH
105779: LD_VAR 0 7
105783: ARRAY
105784: PPUSH
105785: CALL 82779 0 1
// end ; if f_attack_depot then
105789: LD_VAR 0 25
105793: IFFALSE 105905
// begin k := 6 ;
105795: LD_ADDR_VAR 0 9
105799: PUSH
105800: LD_INT 6
105802: ST_TO_ADDR
// if tmp < k then
105803: LD_VAR 0 14
105807: PUSH
105808: LD_VAR 0 9
105812: LESS
105813: IFFALSE 105825
// k := tmp ;
105815: LD_ADDR_VAR 0 9
105819: PUSH
105820: LD_VAR 0 14
105824: ST_TO_ADDR
// for j = 1 to k do
105825: LD_ADDR_VAR 0 8
105829: PUSH
105830: DOUBLE
105831: LD_INT 1
105833: DEC
105834: ST_TO_ADDR
105835: LD_VAR 0 9
105839: PUSH
105840: FOR_TO
105841: IFFALSE 105903
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
105843: LD_VAR 0 8
105847: PPUSH
105848: CALL_OW 266
105852: PUSH
105853: LD_INT 0
105855: PUSH
105856: LD_INT 1
105858: PUSH
105859: EMPTY
105860: LIST
105861: LIST
105862: IN
105863: IFFALSE 105901
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105865: LD_VAR 0 4
105869: PUSH
105870: LD_VAR 0 7
105874: ARRAY
105875: PPUSH
105876: LD_VAR 0 14
105880: PUSH
105881: LD_VAR 0 8
105885: ARRAY
105886: PPUSH
105887: CALL_OW 115
// attacking := true ;
105891: LD_ADDR_VAR 0 29
105895: PUSH
105896: LD_INT 1
105898: ST_TO_ADDR
// break ;
105899: GO 105903
// end ;
105901: GO 105840
105903: POP
105904: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
105905: LD_VAR 0 4
105909: PUSH
105910: LD_VAR 0 7
105914: ARRAY
105915: PPUSH
105916: CALL_OW 302
105920: PUSH
105921: LD_VAR 0 29
105925: NOT
105926: AND
105927: IFFALSE 106249
// begin if GetTag ( group [ i ] ) = 71 then
105929: LD_VAR 0 4
105933: PUSH
105934: LD_VAR 0 7
105938: ARRAY
105939: PPUSH
105940: CALL_OW 110
105944: PUSH
105945: LD_INT 71
105947: EQUAL
105948: IFFALSE 105989
// begin if HasTask ( group [ i ] ) then
105950: LD_VAR 0 4
105954: PUSH
105955: LD_VAR 0 7
105959: ARRAY
105960: PPUSH
105961: CALL_OW 314
105965: IFFALSE 105971
// continue else
105967: GO 102128
105969: GO 105989
// SetTag ( group [ i ] , 0 ) ;
105971: LD_VAR 0 4
105975: PUSH
105976: LD_VAR 0 7
105980: ARRAY
105981: PPUSH
105982: LD_INT 0
105984: PPUSH
105985: CALL_OW 109
// end ; k := 8 ;
105989: LD_ADDR_VAR 0 9
105993: PUSH
105994: LD_INT 8
105996: ST_TO_ADDR
// x := 0 ;
105997: LD_ADDR_VAR 0 10
106001: PUSH
106002: LD_INT 0
106004: ST_TO_ADDR
// if tmp < k then
106005: LD_VAR 0 14
106009: PUSH
106010: LD_VAR 0 9
106014: LESS
106015: IFFALSE 106027
// k := tmp ;
106017: LD_ADDR_VAR 0 9
106021: PUSH
106022: LD_VAR 0 14
106026: ST_TO_ADDR
// for j = 1 to k do
106027: LD_ADDR_VAR 0 8
106031: PUSH
106032: DOUBLE
106033: LD_INT 1
106035: DEC
106036: ST_TO_ADDR
106037: LD_VAR 0 9
106041: PUSH
106042: FOR_TO
106043: IFFALSE 106141
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
106045: LD_VAR 0 14
106049: PUSH
106050: LD_VAR 0 8
106054: ARRAY
106055: PPUSH
106056: CALL_OW 247
106060: PUSH
106061: LD_INT 1
106063: EQUAL
106064: PUSH
106065: LD_VAR 0 14
106069: PUSH
106070: LD_VAR 0 8
106074: ARRAY
106075: PPUSH
106076: CALL_OW 256
106080: PUSH
106081: LD_INT 250
106083: LESS
106084: PUSH
106085: LD_VAR 0 20
106089: AND
106090: PUSH
106091: LD_VAR 0 20
106095: NOT
106096: PUSH
106097: LD_VAR 0 14
106101: PUSH
106102: LD_VAR 0 8
106106: ARRAY
106107: PPUSH
106108: CALL_OW 256
106112: PUSH
106113: LD_INT 250
106115: GREATEREQUAL
106116: AND
106117: OR
106118: AND
106119: IFFALSE 106139
// begin x := tmp [ j ] ;
106121: LD_ADDR_VAR 0 10
106125: PUSH
106126: LD_VAR 0 14
106130: PUSH
106131: LD_VAR 0 8
106135: ARRAY
106136: ST_TO_ADDR
// break ;
106137: GO 106141
// end ;
106139: GO 106042
106141: POP
106142: POP
// if x then
106143: LD_VAR 0 10
106147: IFFALSE 106171
// ComAttackUnit ( group [ i ] , x ) else
106149: LD_VAR 0 4
106153: PUSH
106154: LD_VAR 0 7
106158: ARRAY
106159: PPUSH
106160: LD_VAR 0 10
106164: PPUSH
106165: CALL_OW 115
106169: GO 106195
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106171: LD_VAR 0 4
106175: PUSH
106176: LD_VAR 0 7
106180: ARRAY
106181: PPUSH
106182: LD_VAR 0 14
106186: PUSH
106187: LD_INT 1
106189: ARRAY
106190: PPUSH
106191: CALL_OW 115
// if not HasTask ( group [ i ] ) then
106195: LD_VAR 0 4
106199: PUSH
106200: LD_VAR 0 7
106204: ARRAY
106205: PPUSH
106206: CALL_OW 314
106210: NOT
106211: IFFALSE 106249
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
106213: LD_VAR 0 4
106217: PUSH
106218: LD_VAR 0 7
106222: ARRAY
106223: PPUSH
106224: LD_VAR 0 14
106228: PPUSH
106229: LD_VAR 0 4
106233: PUSH
106234: LD_VAR 0 7
106238: ARRAY
106239: PPUSH
106240: CALL_OW 74
106244: PPUSH
106245: CALL_OW 115
// end ; end ; end ;
106249: GO 102128
106251: POP
106252: POP
// wait ( 0 0$2 ) ;
106253: LD_INT 70
106255: PPUSH
106256: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
106260: LD_VAR 0 4
106264: NOT
106265: PUSH
106266: LD_VAR 0 4
106270: PUSH
106271: EMPTY
106272: EQUAL
106273: OR
106274: PUSH
106275: LD_INT 81
106277: PUSH
106278: LD_VAR 0 35
106282: PUSH
106283: EMPTY
106284: LIST
106285: LIST
106286: PPUSH
106287: CALL_OW 69
106291: NOT
106292: OR
106293: IFFALSE 102113
// end ;
106295: LD_VAR 0 2
106299: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
106300: LD_INT 0
106302: PPUSH
106303: PPUSH
106304: PPUSH
106305: PPUSH
106306: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
106307: LD_VAR 0 1
106311: NOT
106312: PUSH
106313: LD_EXP 89
106317: PUSH
106318: LD_VAR 0 1
106322: ARRAY
106323: NOT
106324: OR
106325: PUSH
106326: LD_VAR 0 2
106330: NOT
106331: OR
106332: PUSH
106333: LD_VAR 0 3
106337: NOT
106338: OR
106339: IFFALSE 106343
// exit ;
106341: GO 106856
// side := mc_sides [ base ] ;
106343: LD_ADDR_VAR 0 6
106347: PUSH
106348: LD_EXP 115
106352: PUSH
106353: LD_VAR 0 1
106357: ARRAY
106358: ST_TO_ADDR
// if not side then
106359: LD_VAR 0 6
106363: NOT
106364: IFFALSE 106368
// exit ;
106366: GO 106856
// for i in solds do
106368: LD_ADDR_VAR 0 7
106372: PUSH
106373: LD_VAR 0 2
106377: PUSH
106378: FOR_IN
106379: IFFALSE 106440
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
106381: LD_VAR 0 7
106385: PPUSH
106386: CALL_OW 310
106390: PPUSH
106391: CALL_OW 266
106395: PUSH
106396: LD_INT 32
106398: PUSH
106399: LD_INT 31
106401: PUSH
106402: EMPTY
106403: LIST
106404: LIST
106405: IN
106406: IFFALSE 106426
// solds := solds diff i else
106408: LD_ADDR_VAR 0 2
106412: PUSH
106413: LD_VAR 0 2
106417: PUSH
106418: LD_VAR 0 7
106422: DIFF
106423: ST_TO_ADDR
106424: GO 106438
// SetTag ( i , 18 ) ;
106426: LD_VAR 0 7
106430: PPUSH
106431: LD_INT 18
106433: PPUSH
106434: CALL_OW 109
106438: GO 106378
106440: POP
106441: POP
// if not solds then
106442: LD_VAR 0 2
106446: NOT
106447: IFFALSE 106451
// exit ;
106449: GO 106856
// repeat wait ( 0 0$1 ) ;
106451: LD_INT 35
106453: PPUSH
106454: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
106458: LD_ADDR_VAR 0 5
106462: PUSH
106463: LD_VAR 0 6
106467: PPUSH
106468: LD_VAR 0 3
106472: PPUSH
106473: CALL 52494 0 2
106477: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106478: LD_EXP 89
106482: PUSH
106483: LD_VAR 0 1
106487: ARRAY
106488: NOT
106489: PUSH
106490: LD_EXP 89
106494: PUSH
106495: LD_VAR 0 1
106499: ARRAY
106500: PUSH
106501: EMPTY
106502: EQUAL
106503: OR
106504: IFFALSE 106541
// begin for i in solds do
106506: LD_ADDR_VAR 0 7
106510: PUSH
106511: LD_VAR 0 2
106515: PUSH
106516: FOR_IN
106517: IFFALSE 106530
// ComStop ( i ) ;
106519: LD_VAR 0 7
106523: PPUSH
106524: CALL_OW 141
106528: GO 106516
106530: POP
106531: POP
// solds := [ ] ;
106532: LD_ADDR_VAR 0 2
106536: PUSH
106537: EMPTY
106538: ST_TO_ADDR
// exit ;
106539: GO 106856
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
106541: LD_VAR 0 5
106545: NOT
106546: PUSH
106547: LD_VAR 0 5
106551: PUSH
106552: LD_INT 3
106554: GREATER
106555: OR
106556: PUSH
106557: LD_EXP 111
106561: PUSH
106562: LD_VAR 0 1
106566: ARRAY
106567: OR
106568: IFFALSE 106609
// begin for i in solds do
106570: LD_ADDR_VAR 0 7
106574: PUSH
106575: LD_VAR 0 2
106579: PUSH
106580: FOR_IN
106581: IFFALSE 106605
// if HasTask ( i ) then
106583: LD_VAR 0 7
106587: PPUSH
106588: CALL_OW 314
106592: IFFALSE 106603
// ComStop ( i ) ;
106594: LD_VAR 0 7
106598: PPUSH
106599: CALL_OW 141
106603: GO 106580
106605: POP
106606: POP
// break ;
106607: GO 106844
// end ; for i in solds do
106609: LD_ADDR_VAR 0 7
106613: PUSH
106614: LD_VAR 0 2
106618: PUSH
106619: FOR_IN
106620: IFFALSE 106836
// begin if IsInUnit ( i ) then
106622: LD_VAR 0 7
106626: PPUSH
106627: CALL_OW 310
106631: IFFALSE 106642
// ComExitBuilding ( i ) ;
106633: LD_VAR 0 7
106637: PPUSH
106638: CALL_OW 122
// if GetLives ( i ) > 333 then
106642: LD_VAR 0 7
106646: PPUSH
106647: CALL_OW 256
106651: PUSH
106652: LD_INT 333
106654: GREATER
106655: IFFALSE 106683
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
106657: LD_VAR 0 7
106661: PPUSH
106662: LD_VAR 0 5
106666: PPUSH
106667: LD_VAR 0 7
106671: PPUSH
106672: CALL_OW 74
106676: PPUSH
106677: CALL_OW 115
106681: GO 106834
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
106683: LD_ADDR_VAR 0 8
106687: PUSH
106688: LD_EXP 89
106692: PUSH
106693: LD_VAR 0 1
106697: ARRAY
106698: PPUSH
106699: LD_INT 2
106701: PUSH
106702: LD_INT 30
106704: PUSH
106705: LD_INT 0
106707: PUSH
106708: EMPTY
106709: LIST
106710: LIST
106711: PUSH
106712: LD_INT 30
106714: PUSH
106715: LD_INT 1
106717: PUSH
106718: EMPTY
106719: LIST
106720: LIST
106721: PUSH
106722: LD_INT 30
106724: PUSH
106725: LD_INT 6
106727: PUSH
106728: EMPTY
106729: LIST
106730: LIST
106731: PUSH
106732: EMPTY
106733: LIST
106734: LIST
106735: LIST
106736: LIST
106737: PPUSH
106738: CALL_OW 72
106742: PPUSH
106743: LD_VAR 0 7
106747: PPUSH
106748: CALL_OW 74
106752: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
106753: LD_VAR 0 7
106757: PPUSH
106758: LD_VAR 0 8
106762: PPUSH
106763: CALL_OW 250
106767: PPUSH
106768: LD_INT 3
106770: PPUSH
106771: LD_INT 5
106773: PPUSH
106774: CALL_OW 272
106778: PPUSH
106779: LD_VAR 0 8
106783: PPUSH
106784: CALL_OW 251
106788: PPUSH
106789: LD_INT 3
106791: PPUSH
106792: LD_INT 5
106794: PPUSH
106795: CALL_OW 273
106799: PPUSH
106800: CALL_OW 111
// SetTag ( i , 0 ) ;
106804: LD_VAR 0 7
106808: PPUSH
106809: LD_INT 0
106811: PPUSH
106812: CALL_OW 109
// solds := solds diff i ;
106816: LD_ADDR_VAR 0 2
106820: PUSH
106821: LD_VAR 0 2
106825: PUSH
106826: LD_VAR 0 7
106830: DIFF
106831: ST_TO_ADDR
// continue ;
106832: GO 106619
// end ; end ;
106834: GO 106619
106836: POP
106837: POP
// until solds ;
106838: LD_VAR 0 2
106842: IFFALSE 106451
// MC_Reset ( base , 18 ) ;
106844: LD_VAR 0 1
106848: PPUSH
106849: LD_INT 18
106851: PPUSH
106852: CALL 24802 0 2
// end ;
106856: LD_VAR 0 4
106860: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
106861: LD_INT 0
106863: PPUSH
106864: PPUSH
106865: PPUSH
106866: PPUSH
106867: PPUSH
106868: PPUSH
106869: PPUSH
106870: PPUSH
106871: PPUSH
106872: PPUSH
106873: PPUSH
106874: PPUSH
106875: PPUSH
106876: PPUSH
106877: PPUSH
106878: PPUSH
106879: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
106880: LD_ADDR_VAR 0 13
106884: PUSH
106885: LD_EXP 89
106889: PUSH
106890: LD_VAR 0 1
106894: ARRAY
106895: PPUSH
106896: LD_INT 25
106898: PUSH
106899: LD_INT 3
106901: PUSH
106902: EMPTY
106903: LIST
106904: LIST
106905: PPUSH
106906: CALL_OW 72
106910: ST_TO_ADDR
// if mc_remote_driver [ base ] then
106911: LD_EXP 129
106915: PUSH
106916: LD_VAR 0 1
106920: ARRAY
106921: IFFALSE 106945
// mechs := mechs diff mc_remote_driver [ base ] ;
106923: LD_ADDR_VAR 0 13
106927: PUSH
106928: LD_VAR 0 13
106932: PUSH
106933: LD_EXP 129
106937: PUSH
106938: LD_VAR 0 1
106942: ARRAY
106943: DIFF
106944: ST_TO_ADDR
// for i in mechs do
106945: LD_ADDR_VAR 0 5
106949: PUSH
106950: LD_VAR 0 13
106954: PUSH
106955: FOR_IN
106956: IFFALSE 106991
// if GetTag ( i ) > 0 then
106958: LD_VAR 0 5
106962: PPUSH
106963: CALL_OW 110
106967: PUSH
106968: LD_INT 0
106970: GREATER
106971: IFFALSE 106989
// mechs := mechs diff i ;
106973: LD_ADDR_VAR 0 13
106977: PUSH
106978: LD_VAR 0 13
106982: PUSH
106983: LD_VAR 0 5
106987: DIFF
106988: ST_TO_ADDR
106989: GO 106955
106991: POP
106992: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
106993: LD_ADDR_VAR 0 9
106997: PUSH
106998: LD_EXP 89
107002: PUSH
107003: LD_VAR 0 1
107007: ARRAY
107008: PPUSH
107009: LD_INT 2
107011: PUSH
107012: LD_INT 25
107014: PUSH
107015: LD_INT 1
107017: PUSH
107018: EMPTY
107019: LIST
107020: LIST
107021: PUSH
107022: LD_INT 25
107024: PUSH
107025: LD_INT 5
107027: PUSH
107028: EMPTY
107029: LIST
107030: LIST
107031: PUSH
107032: LD_INT 25
107034: PUSH
107035: LD_INT 8
107037: PUSH
107038: EMPTY
107039: LIST
107040: LIST
107041: PUSH
107042: LD_INT 25
107044: PUSH
107045: LD_INT 9
107047: PUSH
107048: EMPTY
107049: LIST
107050: LIST
107051: PUSH
107052: EMPTY
107053: LIST
107054: LIST
107055: LIST
107056: LIST
107057: LIST
107058: PPUSH
107059: CALL_OW 72
107063: ST_TO_ADDR
// if not defenders and not solds then
107064: LD_VAR 0 2
107068: NOT
107069: PUSH
107070: LD_VAR 0 9
107074: NOT
107075: AND
107076: IFFALSE 107080
// exit ;
107078: GO 108706
// depot_under_attack := false ;
107080: LD_ADDR_VAR 0 17
107084: PUSH
107085: LD_INT 0
107087: ST_TO_ADDR
// sold_defenders := [ ] ;
107088: LD_ADDR_VAR 0 18
107092: PUSH
107093: EMPTY
107094: ST_TO_ADDR
// if mechs then
107095: LD_VAR 0 13
107099: IFFALSE 107228
// for i in defenders do
107101: LD_ADDR_VAR 0 5
107105: PUSH
107106: LD_VAR 0 2
107110: PUSH
107111: FOR_IN
107112: IFFALSE 107226
// begin SetTag ( i , 20 ) ;
107114: LD_VAR 0 5
107118: PPUSH
107119: LD_INT 20
107121: PPUSH
107122: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
107126: LD_VAR 0 5
107130: PPUSH
107131: CALL_OW 263
107135: PUSH
107136: LD_INT 1
107138: EQUAL
107139: PUSH
107140: LD_VAR 0 5
107144: PPUSH
107145: CALL_OW 311
107149: NOT
107150: AND
107151: PUSH
107152: LD_VAR 0 13
107156: AND
107157: IFFALSE 107224
// begin un := mechs [ 1 ] ;
107159: LD_ADDR_VAR 0 11
107163: PUSH
107164: LD_VAR 0 13
107168: PUSH
107169: LD_INT 1
107171: ARRAY
107172: ST_TO_ADDR
// ComExitBuilding ( un ) ;
107173: LD_VAR 0 11
107177: PPUSH
107178: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
107182: LD_VAR 0 11
107186: PPUSH
107187: LD_VAR 0 5
107191: PPUSH
107192: CALL_OW 180
// SetTag ( un , 19 ) ;
107196: LD_VAR 0 11
107200: PPUSH
107201: LD_INT 19
107203: PPUSH
107204: CALL_OW 109
// mechs := mechs diff un ;
107208: LD_ADDR_VAR 0 13
107212: PUSH
107213: LD_VAR 0 13
107217: PUSH
107218: LD_VAR 0 11
107222: DIFF
107223: ST_TO_ADDR
// end ; end ;
107224: GO 107111
107226: POP
107227: POP
// if solds then
107228: LD_VAR 0 9
107232: IFFALSE 107291
// for i in solds do
107234: LD_ADDR_VAR 0 5
107238: PUSH
107239: LD_VAR 0 9
107243: PUSH
107244: FOR_IN
107245: IFFALSE 107289
// if not GetTag ( i ) then
107247: LD_VAR 0 5
107251: PPUSH
107252: CALL_OW 110
107256: NOT
107257: IFFALSE 107287
// begin defenders := defenders union i ;
107259: LD_ADDR_VAR 0 2
107263: PUSH
107264: LD_VAR 0 2
107268: PUSH
107269: LD_VAR 0 5
107273: UNION
107274: ST_TO_ADDR
// SetTag ( i , 18 ) ;
107275: LD_VAR 0 5
107279: PPUSH
107280: LD_INT 18
107282: PPUSH
107283: CALL_OW 109
// end ;
107287: GO 107244
107289: POP
107290: POP
// repeat wait ( 0 0$1 ) ;
107291: LD_INT 35
107293: PPUSH
107294: CALL_OW 67
// enemy := mc_scan [ base ] ;
107298: LD_ADDR_VAR 0 3
107302: PUSH
107303: LD_EXP 112
107307: PUSH
107308: LD_VAR 0 1
107312: ARRAY
107313: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107314: LD_EXP 89
107318: PUSH
107319: LD_VAR 0 1
107323: ARRAY
107324: NOT
107325: PUSH
107326: LD_EXP 89
107330: PUSH
107331: LD_VAR 0 1
107335: ARRAY
107336: PUSH
107337: EMPTY
107338: EQUAL
107339: OR
107340: IFFALSE 107377
// begin for i in defenders do
107342: LD_ADDR_VAR 0 5
107346: PUSH
107347: LD_VAR 0 2
107351: PUSH
107352: FOR_IN
107353: IFFALSE 107366
// ComStop ( i ) ;
107355: LD_VAR 0 5
107359: PPUSH
107360: CALL_OW 141
107364: GO 107352
107366: POP
107367: POP
// defenders := [ ] ;
107368: LD_ADDR_VAR 0 2
107372: PUSH
107373: EMPTY
107374: ST_TO_ADDR
// exit ;
107375: GO 108706
// end ; for i in defenders do
107377: LD_ADDR_VAR 0 5
107381: PUSH
107382: LD_VAR 0 2
107386: PUSH
107387: FOR_IN
107388: IFFALSE 108206
// begin e := NearestUnitToUnit ( enemy , i ) ;
107390: LD_ADDR_VAR 0 14
107394: PUSH
107395: LD_VAR 0 3
107399: PPUSH
107400: LD_VAR 0 5
107404: PPUSH
107405: CALL_OW 74
107409: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107410: LD_ADDR_VAR 0 8
107414: PUSH
107415: LD_EXP 89
107419: PUSH
107420: LD_VAR 0 1
107424: ARRAY
107425: PPUSH
107426: LD_INT 2
107428: PUSH
107429: LD_INT 30
107431: PUSH
107432: LD_INT 0
107434: PUSH
107435: EMPTY
107436: LIST
107437: LIST
107438: PUSH
107439: LD_INT 30
107441: PUSH
107442: LD_INT 1
107444: PUSH
107445: EMPTY
107446: LIST
107447: LIST
107448: PUSH
107449: EMPTY
107450: LIST
107451: LIST
107452: LIST
107453: PPUSH
107454: CALL_OW 72
107458: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
107459: LD_ADDR_VAR 0 17
107463: PUSH
107464: LD_VAR 0 8
107468: NOT
107469: PUSH
107470: LD_VAR 0 8
107474: PPUSH
107475: LD_INT 3
107477: PUSH
107478: LD_INT 24
107480: PUSH
107481: LD_INT 600
107483: PUSH
107484: EMPTY
107485: LIST
107486: LIST
107487: PUSH
107488: EMPTY
107489: LIST
107490: LIST
107491: PPUSH
107492: CALL_OW 72
107496: OR
107497: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
107498: LD_VAR 0 5
107502: PPUSH
107503: CALL_OW 247
107507: PUSH
107508: LD_INT 2
107510: DOUBLE
107511: EQUAL
107512: IFTRUE 107516
107514: GO 107912
107516: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
107517: LD_VAR 0 5
107521: PPUSH
107522: CALL_OW 256
107526: PUSH
107527: LD_INT 650
107529: GREATER
107530: PUSH
107531: LD_VAR 0 5
107535: PPUSH
107536: LD_VAR 0 14
107540: PPUSH
107541: CALL_OW 296
107545: PUSH
107546: LD_INT 40
107548: LESS
107549: PUSH
107550: LD_VAR 0 14
107554: PPUSH
107555: LD_EXP 114
107559: PUSH
107560: LD_VAR 0 1
107564: ARRAY
107565: PPUSH
107566: CALL_OW 308
107570: OR
107571: AND
107572: IFFALSE 107694
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
107574: LD_VAR 0 5
107578: PPUSH
107579: CALL_OW 262
107583: PUSH
107584: LD_INT 1
107586: EQUAL
107587: PUSH
107588: LD_VAR 0 5
107592: PPUSH
107593: CALL_OW 261
107597: PUSH
107598: LD_INT 30
107600: LESS
107601: AND
107602: PUSH
107603: LD_VAR 0 8
107607: AND
107608: IFFALSE 107678
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
107610: LD_VAR 0 5
107614: PPUSH
107615: LD_VAR 0 8
107619: PPUSH
107620: LD_VAR 0 5
107624: PPUSH
107625: CALL_OW 74
107629: PPUSH
107630: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
107634: LD_VAR 0 5
107638: PPUSH
107639: LD_VAR 0 8
107643: PPUSH
107644: LD_VAR 0 5
107648: PPUSH
107649: CALL_OW 74
107653: PPUSH
107654: CALL_OW 296
107658: PUSH
107659: LD_INT 6
107661: LESS
107662: IFFALSE 107676
// SetFuel ( i , 100 ) ;
107664: LD_VAR 0 5
107668: PPUSH
107669: LD_INT 100
107671: PPUSH
107672: CALL_OW 240
// end else
107676: GO 107692
// ComAttackUnit ( i , e ) ;
107678: LD_VAR 0 5
107682: PPUSH
107683: LD_VAR 0 14
107687: PPUSH
107688: CALL_OW 115
// end else
107692: GO 107795
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
107694: LD_VAR 0 14
107698: PPUSH
107699: LD_EXP 114
107703: PUSH
107704: LD_VAR 0 1
107708: ARRAY
107709: PPUSH
107710: CALL_OW 308
107714: NOT
107715: PUSH
107716: LD_VAR 0 5
107720: PPUSH
107721: LD_VAR 0 14
107725: PPUSH
107726: CALL_OW 296
107730: PUSH
107731: LD_INT 40
107733: GREATEREQUAL
107734: AND
107735: PUSH
107736: LD_VAR 0 5
107740: PPUSH
107741: CALL_OW 256
107745: PUSH
107746: LD_INT 650
107748: LESSEQUAL
107749: OR
107750: PUSH
107751: LD_VAR 0 5
107755: PPUSH
107756: LD_EXP 113
107760: PUSH
107761: LD_VAR 0 1
107765: ARRAY
107766: PPUSH
107767: CALL_OW 308
107771: NOT
107772: AND
107773: IFFALSE 107795
// ComMoveToArea ( i , mc_parking [ base ] ) ;
107775: LD_VAR 0 5
107779: PPUSH
107780: LD_EXP 113
107784: PUSH
107785: LD_VAR 0 1
107789: ARRAY
107790: PPUSH
107791: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
107795: LD_VAR 0 5
107799: PPUSH
107800: CALL_OW 256
107804: PUSH
107805: LD_INT 998
107807: LESS
107808: PUSH
107809: LD_VAR 0 5
107813: PPUSH
107814: CALL_OW 263
107818: PUSH
107819: LD_INT 1
107821: EQUAL
107822: AND
107823: PUSH
107824: LD_VAR 0 5
107828: PPUSH
107829: CALL_OW 311
107833: AND
107834: PUSH
107835: LD_VAR 0 5
107839: PPUSH
107840: LD_EXP 113
107844: PUSH
107845: LD_VAR 0 1
107849: ARRAY
107850: PPUSH
107851: CALL_OW 308
107855: AND
107856: IFFALSE 107910
// begin mech := IsDrivenBy ( i ) ;
107858: LD_ADDR_VAR 0 10
107862: PUSH
107863: LD_VAR 0 5
107867: PPUSH
107868: CALL_OW 311
107872: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
107873: LD_VAR 0 10
107877: PPUSH
107878: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
107882: LD_VAR 0 10
107886: PPUSH
107887: LD_VAR 0 5
107891: PPUSH
107892: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
107896: LD_VAR 0 10
107900: PPUSH
107901: LD_VAR 0 5
107905: PPUSH
107906: CALL_OW 180
// end ; end ; unit_human :
107910: GO 108177
107912: LD_INT 1
107914: DOUBLE
107915: EQUAL
107916: IFTRUE 107920
107918: GO 108176
107920: POP
// begin b := IsInUnit ( i ) ;
107921: LD_ADDR_VAR 0 19
107925: PUSH
107926: LD_VAR 0 5
107930: PPUSH
107931: CALL_OW 310
107935: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
107936: LD_ADDR_VAR 0 20
107940: PUSH
107941: LD_VAR 0 19
107945: NOT
107946: PUSH
107947: LD_VAR 0 19
107951: PPUSH
107952: CALL_OW 266
107956: PUSH
107957: LD_INT 32
107959: PUSH
107960: LD_INT 31
107962: PUSH
107963: EMPTY
107964: LIST
107965: LIST
107966: IN
107967: OR
107968: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
107969: LD_VAR 0 17
107973: PUSH
107974: LD_VAR 0 2
107978: PPUSH
107979: LD_INT 21
107981: PUSH
107982: LD_INT 2
107984: PUSH
107985: EMPTY
107986: LIST
107987: LIST
107988: PPUSH
107989: CALL_OW 72
107993: PUSH
107994: LD_INT 1
107996: LESSEQUAL
107997: OR
107998: PUSH
107999: LD_VAR 0 20
108003: AND
108004: PUSH
108005: LD_VAR 0 5
108009: PUSH
108010: LD_VAR 0 18
108014: IN
108015: NOT
108016: AND
108017: IFFALSE 108110
// begin if b then
108019: LD_VAR 0 19
108023: IFFALSE 108072
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
108025: LD_VAR 0 19
108029: PPUSH
108030: LD_VAR 0 3
108034: PPUSH
108035: LD_VAR 0 19
108039: PPUSH
108040: CALL_OW 74
108044: PPUSH
108045: CALL_OW 296
108049: PUSH
108050: LD_INT 10
108052: LESS
108053: PUSH
108054: LD_VAR 0 19
108058: PPUSH
108059: CALL_OW 461
108063: PUSH
108064: LD_INT 7
108066: NONEQUAL
108067: AND
108068: IFFALSE 108072
// continue ;
108070: GO 107387
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
108072: LD_ADDR_VAR 0 18
108076: PUSH
108077: LD_VAR 0 18
108081: PPUSH
108082: LD_VAR 0 18
108086: PUSH
108087: LD_INT 1
108089: PLUS
108090: PPUSH
108091: LD_VAR 0 5
108095: PPUSH
108096: CALL_OW 1
108100: ST_TO_ADDR
// ComExitBuilding ( i ) ;
108101: LD_VAR 0 5
108105: PPUSH
108106: CALL_OW 122
// end ; if sold_defenders then
108110: LD_VAR 0 18
108114: IFFALSE 108174
// if i in sold_defenders then
108116: LD_VAR 0 5
108120: PUSH
108121: LD_VAR 0 18
108125: IN
108126: IFFALSE 108174
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
108128: LD_VAR 0 5
108132: PPUSH
108133: CALL_OW 314
108137: NOT
108138: PUSH
108139: LD_VAR 0 5
108143: PPUSH
108144: LD_VAR 0 14
108148: PPUSH
108149: CALL_OW 296
108153: PUSH
108154: LD_INT 30
108156: LESS
108157: AND
108158: IFFALSE 108174
// ComAttackUnit ( i , e ) ;
108160: LD_VAR 0 5
108164: PPUSH
108165: LD_VAR 0 14
108169: PPUSH
108170: CALL_OW 115
// end ; end ; end ;
108174: GO 108177
108176: POP
// if IsDead ( i ) then
108177: LD_VAR 0 5
108181: PPUSH
108182: CALL_OW 301
108186: IFFALSE 108204
// defenders := defenders diff i ;
108188: LD_ADDR_VAR 0 2
108192: PUSH
108193: LD_VAR 0 2
108197: PUSH
108198: LD_VAR 0 5
108202: DIFF
108203: ST_TO_ADDR
// end ;
108204: GO 107387
108206: POP
108207: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
108208: LD_VAR 0 3
108212: NOT
108213: PUSH
108214: LD_VAR 0 2
108218: NOT
108219: OR
108220: PUSH
108221: LD_EXP 89
108225: PUSH
108226: LD_VAR 0 1
108230: ARRAY
108231: NOT
108232: OR
108233: IFFALSE 107291
// MC_Reset ( base , 18 ) ;
108235: LD_VAR 0 1
108239: PPUSH
108240: LD_INT 18
108242: PPUSH
108243: CALL 24802 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108247: LD_ADDR_VAR 0 2
108251: PUSH
108252: LD_VAR 0 2
108256: PUSH
108257: LD_VAR 0 2
108261: PPUSH
108262: LD_INT 2
108264: PUSH
108265: LD_INT 25
108267: PUSH
108268: LD_INT 1
108270: PUSH
108271: EMPTY
108272: LIST
108273: LIST
108274: PUSH
108275: LD_INT 25
108277: PUSH
108278: LD_INT 5
108280: PUSH
108281: EMPTY
108282: LIST
108283: LIST
108284: PUSH
108285: LD_INT 25
108287: PUSH
108288: LD_INT 8
108290: PUSH
108291: EMPTY
108292: LIST
108293: LIST
108294: PUSH
108295: LD_INT 25
108297: PUSH
108298: LD_INT 9
108300: PUSH
108301: EMPTY
108302: LIST
108303: LIST
108304: PUSH
108305: EMPTY
108306: LIST
108307: LIST
108308: LIST
108309: LIST
108310: LIST
108311: PPUSH
108312: CALL_OW 72
108316: DIFF
108317: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
108318: LD_VAR 0 3
108322: NOT
108323: PUSH
108324: LD_VAR 0 2
108328: PPUSH
108329: LD_INT 21
108331: PUSH
108332: LD_INT 2
108334: PUSH
108335: EMPTY
108336: LIST
108337: LIST
108338: PPUSH
108339: CALL_OW 72
108343: AND
108344: IFFALSE 108682
// begin tmp := FilterByTag ( defenders , 19 ) ;
108346: LD_ADDR_VAR 0 12
108350: PUSH
108351: LD_VAR 0 2
108355: PPUSH
108356: LD_INT 19
108358: PPUSH
108359: CALL 84254 0 2
108363: ST_TO_ADDR
// if tmp then
108364: LD_VAR 0 12
108368: IFFALSE 108438
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
108370: LD_ADDR_VAR 0 12
108374: PUSH
108375: LD_VAR 0 12
108379: PPUSH
108380: LD_INT 25
108382: PUSH
108383: LD_INT 3
108385: PUSH
108386: EMPTY
108387: LIST
108388: LIST
108389: PPUSH
108390: CALL_OW 72
108394: ST_TO_ADDR
// if tmp then
108395: LD_VAR 0 12
108399: IFFALSE 108438
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
108401: LD_ADDR_EXP 101
108405: PUSH
108406: LD_EXP 101
108410: PPUSH
108411: LD_VAR 0 1
108415: PPUSH
108416: LD_EXP 101
108420: PUSH
108421: LD_VAR 0 1
108425: ARRAY
108426: PUSH
108427: LD_VAR 0 12
108431: UNION
108432: PPUSH
108433: CALL_OW 1
108437: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
108438: LD_VAR 0 1
108442: PPUSH
108443: LD_INT 19
108445: PPUSH
108446: CALL 24802 0 2
// repeat wait ( 0 0$1 ) ;
108450: LD_INT 35
108452: PPUSH
108453: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108457: LD_EXP 89
108461: PUSH
108462: LD_VAR 0 1
108466: ARRAY
108467: NOT
108468: PUSH
108469: LD_EXP 89
108473: PUSH
108474: LD_VAR 0 1
108478: ARRAY
108479: PUSH
108480: EMPTY
108481: EQUAL
108482: OR
108483: IFFALSE 108520
// begin for i in defenders do
108485: LD_ADDR_VAR 0 5
108489: PUSH
108490: LD_VAR 0 2
108494: PUSH
108495: FOR_IN
108496: IFFALSE 108509
// ComStop ( i ) ;
108498: LD_VAR 0 5
108502: PPUSH
108503: CALL_OW 141
108507: GO 108495
108509: POP
108510: POP
// defenders := [ ] ;
108511: LD_ADDR_VAR 0 2
108515: PUSH
108516: EMPTY
108517: ST_TO_ADDR
// exit ;
108518: GO 108706
// end ; for i in defenders do
108520: LD_ADDR_VAR 0 5
108524: PUSH
108525: LD_VAR 0 2
108529: PUSH
108530: FOR_IN
108531: IFFALSE 108620
// begin if not IsInArea ( i , mc_parking [ base ] ) then
108533: LD_VAR 0 5
108537: PPUSH
108538: LD_EXP 113
108542: PUSH
108543: LD_VAR 0 1
108547: ARRAY
108548: PPUSH
108549: CALL_OW 308
108553: NOT
108554: IFFALSE 108578
// ComMoveToArea ( i , mc_parking [ base ] ) else
108556: LD_VAR 0 5
108560: PPUSH
108561: LD_EXP 113
108565: PUSH
108566: LD_VAR 0 1
108570: ARRAY
108571: PPUSH
108572: CALL_OW 113
108576: GO 108618
// if GetControl ( i ) = control_manual then
108578: LD_VAR 0 5
108582: PPUSH
108583: CALL_OW 263
108587: PUSH
108588: LD_INT 1
108590: EQUAL
108591: IFFALSE 108618
// if IsDrivenBy ( i ) then
108593: LD_VAR 0 5
108597: PPUSH
108598: CALL_OW 311
108602: IFFALSE 108618
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
108604: LD_VAR 0 5
108608: PPUSH
108609: CALL_OW 311
108613: PPUSH
108614: CALL_OW 121
// end ;
108618: GO 108530
108620: POP
108621: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
108622: LD_VAR 0 2
108626: PPUSH
108627: LD_INT 95
108629: PUSH
108630: LD_EXP 113
108634: PUSH
108635: LD_VAR 0 1
108639: ARRAY
108640: PUSH
108641: EMPTY
108642: LIST
108643: LIST
108644: PPUSH
108645: CALL_OW 72
108649: PUSH
108650: LD_VAR 0 2
108654: EQUAL
108655: PUSH
108656: LD_EXP 112
108660: PUSH
108661: LD_VAR 0 1
108665: ARRAY
108666: OR
108667: PUSH
108668: LD_EXP 89
108672: PUSH
108673: LD_VAR 0 1
108677: ARRAY
108678: NOT
108679: OR
108680: IFFALSE 108450
// end ; MC_Reset ( base , 19 ) ;
108682: LD_VAR 0 1
108686: PPUSH
108687: LD_INT 19
108689: PPUSH
108690: CALL 24802 0 2
// MC_Reset ( base , 20 ) ;
108694: LD_VAR 0 1
108698: PPUSH
108699: LD_INT 20
108701: PPUSH
108702: CALL 24802 0 2
// end ;
108706: LD_VAR 0 4
108710: RET
