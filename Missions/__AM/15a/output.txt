// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 22154 0 0
// InitNature ;
  19: CALL 18820 0 0
// InitArtifact ;
  23: CALL 19437 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5102 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 6941 0 0
// PrepareRussian ;
  52: CALL 9061 0 0
// PrepareLegion ;
  56: CALL 7438 0 0
// Action ;
  60: CALL 11885 0 0
// MC_Start ( ) ;
  64: CALL 24334 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 102
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 103
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 46051 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 47130 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 47223 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 107
 353: PUSH
 354: LD_EXP 107
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 46388 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 46573 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 47130 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 47223 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 46388 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 46573 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 47003 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 46051 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 47130 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 47223 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 107
 843: PUSH
 844: LD_EXP 107
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 46388 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 46573 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 47130 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 47223 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 47541 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 47335 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 46388 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 46573 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 46954 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// uc_side := 7 ;
1443: LD_ADDR_OWVAR 20
1447: PUSH
1448: LD_INT 7
1450: ST_TO_ADDR
// tmp := [ ] ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: EMPTY
1457: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1458: LD_ADDR_EXP 19
1462: PUSH
1463: LD_STRING JMM
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: LD_STRING 14a_
1474: PPUSH
1475: CALL 52862 0 3
1479: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1480: LD_ADDR_EXP 52
1484: PUSH
1485: LD_STRING Burlak
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: LD_STRING 14a_
1496: PPUSH
1497: CALL 52862 0 3
1501: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1502: LD_ADDR_EXP 34
1506: PUSH
1507: LD_STRING Joan
1509: PPUSH
1510: LD_EXP 1
1514: NOT
1515: PPUSH
1516: LD_STRING 13a_
1518: PPUSH
1519: CALL 52862 0 3
1523: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1524: LD_ADDR_EXP 20
1528: PUSH
1529: LD_STRING Roth
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_STRING 13a_
1540: PPUSH
1541: CALL 52862 0 3
1545: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1546: LD_ADDR_EXP 38
1550: PUSH
1551: LD_STRING Gossudarov
1553: PPUSH
1554: LD_EXP 1
1558: NOT
1559: PPUSH
1560: LD_STRING 13a_
1562: PPUSH
1563: CALL 52862 0 3
1567: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1568: LD_ADDR_EXP 25
1572: PUSH
1573: LD_STRING Denis
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 13a_
1584: PPUSH
1585: CALL 52862 0 3
1589: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING DeltaDoctor
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 13a_
1606: PPUSH
1607: CALL 52862 0 3
1611: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1612: LD_ADDR_EXP 37
1616: PUSH
1617: LD_STRING Mike
1619: PPUSH
1620: LD_EXP 1
1624: NOT
1625: PPUSH
1626: LD_STRING 13a_
1628: PPUSH
1629: CALL 52862 0 3
1633: ST_TO_ADDR
// if DeltaDoctor then
1634: LD_EXP 35
1638: IFFALSE 1656
// tmp := tmp ^ DeltaDoctor ;
1640: LD_ADDR_VAR 0 5
1644: PUSH
1645: LD_VAR 0 5
1649: PUSH
1650: LD_EXP 35
1654: ADD
1655: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1656: LD_ADDR_EXP 33
1660: PUSH
1661: LD_STRING Simms
1663: PPUSH
1664: LD_EXP 1
1668: NOT
1669: PPUSH
1670: LD_STRING 13a_
1672: PPUSH
1673: CALL 52862 0 3
1677: ST_TO_ADDR
// if Simms then
1678: LD_EXP 33
1682: IFFALSE 1700
// tmp := tmp ^ Simms ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_VAR 0 5
1693: PUSH
1694: LD_EXP 33
1698: ADD
1699: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1700: LD_ADDR_EXP 31
1704: PUSH
1705: LD_STRING Frank
1707: PPUSH
1708: LD_EXP 1
1712: NOT
1713: PPUSH
1714: LD_STRING 13a_
1716: PPUSH
1717: CALL 52862 0 3
1721: ST_TO_ADDR
// if Frank then
1722: LD_EXP 31
1726: IFFALSE 1744
// tmp := tmp ^ Frank ;
1728: LD_ADDR_VAR 0 5
1732: PUSH
1733: LD_VAR 0 5
1737: PUSH
1738: LD_EXP 31
1742: ADD
1743: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1744: LD_ADDR_EXP 39
1748: PUSH
1749: LD_STRING Kirilenkova
1751: PPUSH
1752: LD_EXP 1
1756: NOT
1757: PPUSH
1758: LD_STRING 13a_
1760: PPUSH
1761: CALL 52862 0 3
1765: ST_TO_ADDR
// if Kirilenkova then
1766: LD_EXP 39
1770: IFFALSE 1788
// tmp := tmp ^ Kirilenkova ;
1772: LD_ADDR_VAR 0 5
1776: PUSH
1777: LD_VAR 0 5
1781: PUSH
1782: LD_EXP 39
1786: ADD
1787: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1788: LD_ADDR_EXP 40
1792: PUSH
1793: LD_STRING Titov
1795: PPUSH
1796: LD_EXP 1
1800: NOT
1801: PPUSH
1802: LD_STRING 13a_
1804: PPUSH
1805: CALL 52862 0 3
1809: ST_TO_ADDR
// if Titov then
1810: LD_EXP 40
1814: IFFALSE 1832
// tmp := tmp ^ Titov ;
1816: LD_ADDR_VAR 0 5
1820: PUSH
1821: LD_VAR 0 5
1825: PUSH
1826: LD_EXP 40
1830: ADD
1831: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1832: LD_ADDR_EXP 41
1836: PUSH
1837: LD_STRING Fadeev
1839: PPUSH
1840: LD_EXP 1
1844: NOT
1845: PPUSH
1846: LD_STRING 13a_
1848: PPUSH
1849: CALL 52862 0 3
1853: ST_TO_ADDR
// if Fadeev then
1854: LD_EXP 41
1858: IFFALSE 1876
// tmp := tmp ^ Fadeev ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_EXP 41
1874: ADD
1875: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1876: LD_ADDR_EXP 42
1880: PUSH
1881: LD_STRING Dolgov
1883: PPUSH
1884: LD_EXP 1
1888: NOT
1889: PPUSH
1890: LD_STRING 13a_
1892: PPUSH
1893: CALL 52862 0 3
1897: ST_TO_ADDR
// if Dolgov then
1898: LD_EXP 42
1902: IFFALSE 1920
// tmp := tmp ^ Dolgov ;
1904: LD_ADDR_VAR 0 5
1908: PUSH
1909: LD_VAR 0 5
1913: PUSH
1914: LD_EXP 42
1918: ADD
1919: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1920: LD_ADDR_EXP 43
1924: PUSH
1925: LD_STRING Petrosyan
1927: PPUSH
1928: LD_EXP 1
1932: NOT
1933: PPUSH
1934: LD_STRING 13a_
1936: PPUSH
1937: CALL 52862 0 3
1941: ST_TO_ADDR
// if Petrosyan then
1942: LD_EXP 43
1946: IFFALSE 1964
// tmp := tmp ^ Petrosyan ;
1948: LD_ADDR_VAR 0 5
1952: PUSH
1953: LD_VAR 0 5
1957: PUSH
1958: LD_EXP 43
1962: ADD
1963: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1964: LD_ADDR_EXP 44
1968: PUSH
1969: LD_STRING Scholtze
1971: PPUSH
1972: LD_EXP 1
1976: NOT
1977: PPUSH
1978: LD_STRING 13a_
1980: PPUSH
1981: CALL 52862 0 3
1985: ST_TO_ADDR
// if Scholtze then
1986: LD_EXP 44
1990: IFFALSE 2008
// tmp := tmp ^ Scholtze ;
1992: LD_ADDR_VAR 0 5
1996: PUSH
1997: LD_VAR 0 5
2001: PUSH
2002: LD_EXP 44
2006: ADD
2007: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2008: LD_ADDR_EXP 45
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: LD_EXP 1
2020: NOT
2021: PPUSH
2022: LD_STRING 13a_
2024: PPUSH
2025: CALL 52862 0 3
2029: ST_TO_ADDR
// if Oblukov then
2030: LD_EXP 45
2034: IFFALSE 2052
// tmp := tmp ^ Oblukov ;
2036: LD_ADDR_VAR 0 5
2040: PUSH
2041: LD_VAR 0 5
2045: PUSH
2046: LD_EXP 45
2050: ADD
2051: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2052: LD_ADDR_EXP 46
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: LD_EXP 1
2064: NOT
2065: PPUSH
2066: LD_STRING 13a_
2068: PPUSH
2069: CALL 52862 0 3
2073: ST_TO_ADDR
// if Kapitsova then
2074: LD_EXP 46
2078: IFFALSE 2096
// tmp := tmp ^ Kapitsova ;
2080: LD_ADDR_VAR 0 5
2084: PUSH
2085: LD_VAR 0 5
2089: PUSH
2090: LD_EXP 46
2094: ADD
2095: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2096: LD_ADDR_EXP 47
2100: PUSH
2101: LD_STRING Lipshchin
2103: PPUSH
2104: LD_EXP 1
2108: NOT
2109: PPUSH
2110: LD_STRING 13a_
2112: PPUSH
2113: CALL 52862 0 3
2117: ST_TO_ADDR
// if Lipshchin then
2118: LD_EXP 47
2122: IFFALSE 2140
// tmp := tmp ^ Lipshchin ;
2124: LD_ADDR_VAR 0 5
2128: PUSH
2129: LD_VAR 0 5
2133: PUSH
2134: LD_EXP 47
2138: ADD
2139: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2140: LD_ADDR_EXP 48
2144: PUSH
2145: LD_STRING Petrovova
2147: PPUSH
2148: LD_EXP 1
2152: NOT
2153: PPUSH
2154: LD_STRING 13a_
2156: PPUSH
2157: CALL 52862 0 3
2161: ST_TO_ADDR
// if Petrovova then
2162: LD_EXP 48
2166: IFFALSE 2184
// tmp := tmp ^ Petrovova ;
2168: LD_ADDR_VAR 0 5
2172: PUSH
2173: LD_VAR 0 5
2177: PUSH
2178: LD_EXP 48
2182: ADD
2183: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2184: LD_ADDR_EXP 49
2188: PUSH
2189: LD_STRING Kovalyuk
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13a_
2200: PPUSH
2201: CALL 52862 0 3
2205: ST_TO_ADDR
// if Kovalyuk then
2206: LD_EXP 49
2210: IFFALSE 2228
// tmp := tmp ^ Kovalyuk ;
2212: LD_ADDR_VAR 0 5
2216: PUSH
2217: LD_VAR 0 5
2221: PUSH
2222: LD_EXP 49
2226: ADD
2227: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2228: LD_ADDR_EXP 50
2232: PUSH
2233: LD_STRING Kuzmov
2235: PPUSH
2236: LD_EXP 1
2240: NOT
2241: PPUSH
2242: LD_STRING 13a_
2244: PPUSH
2245: CALL 52862 0 3
2249: ST_TO_ADDR
// if Kuzmov then
2250: LD_EXP 50
2254: IFFALSE 2272
// tmp := tmp ^ Kuzmov ;
2256: LD_ADDR_VAR 0 5
2260: PUSH
2261: LD_VAR 0 5
2265: PUSH
2266: LD_EXP 50
2270: ADD
2271: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2272: LD_ADDR_EXP 51
2276: PUSH
2277: LD_STRING Karamazov
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: LD_STRING 13a_
2288: PPUSH
2289: CALL 52862 0 3
2293: ST_TO_ADDR
// if Karamazov then
2294: LD_EXP 51
2298: IFFALSE 2316
// tmp := tmp ^ Karamazov ;
2300: LD_ADDR_VAR 0 5
2304: PUSH
2305: LD_VAR 0 5
2309: PUSH
2310: LD_EXP 51
2314: ADD
2315: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2316: LD_ADDR_EXP 53
2320: PUSH
2321: LD_STRING Belkov
2323: PPUSH
2324: LD_EXP 1
2328: NOT
2329: PPUSH
2330: LD_STRING 13a_
2332: PPUSH
2333: CALL 52862 0 3
2337: ST_TO_ADDR
// if Belkov then
2338: LD_EXP 53
2342: IFFALSE 2360
// tmp := tmp ^ Belkov ;
2344: LD_ADDR_VAR 0 5
2348: PUSH
2349: LD_VAR 0 5
2353: PUSH
2354: LD_EXP 53
2358: ADD
2359: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 54
2364: PUSH
2365: LD_STRING Gnyevko
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 52862 0 3
2381: ST_TO_ADDR
// if Gnyevko then
2382: LD_EXP 54
2386: IFFALSE 2404
// tmp := tmp ^ Gnyevko ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 54
2402: ADD
2403: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2404: LD_ADDR_EXP 36
2408: PUSH
2409: LD_STRING Coonie
2411: PPUSH
2412: CALL_OW 25
2416: ST_TO_ADDR
// if not Lisa then
2417: LD_EXP 21
2421: NOT
2422: IFFALSE 2468
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2424: LD_ADDR_EXP 21
2428: PUSH
2429: LD_STRING Lisa
2431: PPUSH
2432: LD_EXP 1
2436: NOT
2437: PPUSH
2438: LD_STRING 13a_
2440: PPUSH
2441: CALL 52862 0 3
2445: ST_TO_ADDR
// if Lisa then
2446: LD_EXP 21
2450: IFFALSE 2468
// tmp := tmp ^ Lisa ;
2452: LD_ADDR_VAR 0 5
2456: PUSH
2457: LD_VAR 0 5
2461: PUSH
2462: LD_EXP 21
2466: ADD
2467: ST_TO_ADDR
// end ; if not Donaldson then
2468: LD_EXP 22
2472: NOT
2473: IFFALSE 2519
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2475: LD_ADDR_EXP 22
2479: PUSH
2480: LD_STRING Donaldson
2482: PPUSH
2483: LD_EXP 1
2487: NOT
2488: PPUSH
2489: LD_STRING 13a_
2491: PPUSH
2492: CALL 52862 0 3
2496: ST_TO_ADDR
// if Donaldson then
2497: LD_EXP 22
2501: IFFALSE 2519
// tmp := tmp ^ Donaldson ;
2503: LD_ADDR_VAR 0 5
2507: PUSH
2508: LD_VAR 0 5
2512: PUSH
2513: LD_EXP 22
2517: ADD
2518: ST_TO_ADDR
// end ; if not Bobby then
2519: LD_EXP 23
2523: NOT
2524: IFFALSE 2570
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2526: LD_ADDR_EXP 23
2530: PUSH
2531: LD_STRING Bobby
2533: PPUSH
2534: LD_EXP 1
2538: NOT
2539: PPUSH
2540: LD_STRING 13a_
2542: PPUSH
2543: CALL 52862 0 3
2547: ST_TO_ADDR
// if Bobby then
2548: LD_EXP 23
2552: IFFALSE 2570
// tmp := tmp ^ Bobby ;
2554: LD_ADDR_VAR 0 5
2558: PUSH
2559: LD_VAR 0 5
2563: PUSH
2564: LD_EXP 23
2568: ADD
2569: ST_TO_ADDR
// end ; if not Cyrus then
2570: LD_EXP 24
2574: NOT
2575: IFFALSE 2621
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2577: LD_ADDR_EXP 24
2581: PUSH
2582: LD_STRING Cyrus
2584: PPUSH
2585: LD_EXP 1
2589: NOT
2590: PPUSH
2591: LD_STRING 13a_
2593: PPUSH
2594: CALL 52862 0 3
2598: ST_TO_ADDR
// if Cyrus then
2599: LD_EXP 24
2603: IFFALSE 2621
// tmp := tmp ^ Cyrus ;
2605: LD_ADDR_VAR 0 5
2609: PUSH
2610: LD_VAR 0 5
2614: PUSH
2615: LD_EXP 24
2619: ADD
2620: ST_TO_ADDR
// end ; if not Brown then
2621: LD_EXP 26
2625: NOT
2626: IFFALSE 2672
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2628: LD_ADDR_EXP 26
2632: PUSH
2633: LD_STRING Brown
2635: PPUSH
2636: LD_EXP 1
2640: NOT
2641: PPUSH
2642: LD_STRING 13a_
2644: PPUSH
2645: CALL 52862 0 3
2649: ST_TO_ADDR
// if Brown then
2650: LD_EXP 26
2654: IFFALSE 2672
// tmp := tmp ^ Brown ;
2656: LD_ADDR_VAR 0 5
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_EXP 26
2670: ADD
2671: ST_TO_ADDR
// end ; if not Gladstone then
2672: LD_EXP 27
2676: NOT
2677: IFFALSE 2723
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2679: LD_ADDR_EXP 27
2683: PUSH
2684: LD_STRING Gladstone
2686: PPUSH
2687: LD_EXP 1
2691: NOT
2692: PPUSH
2693: LD_STRING 13a_
2695: PPUSH
2696: CALL 52862 0 3
2700: ST_TO_ADDR
// if Gladstone then
2701: LD_EXP 27
2705: IFFALSE 2723
// tmp := tmp ^ Gladstone ;
2707: LD_ADDR_VAR 0 5
2711: PUSH
2712: LD_VAR 0 5
2716: PUSH
2717: LD_EXP 27
2721: ADD
2722: ST_TO_ADDR
// end ; if not Cornel then
2723: LD_EXP 29
2727: NOT
2728: IFFALSE 2774
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2730: LD_ADDR_EXP 29
2734: PUSH
2735: LD_STRING Cornel
2737: PPUSH
2738: LD_EXP 1
2742: NOT
2743: PPUSH
2744: LD_STRING 13a_
2746: PPUSH
2747: CALL 52862 0 3
2751: ST_TO_ADDR
// if Cornel then
2752: LD_EXP 29
2756: IFFALSE 2774
// tmp := tmp ^ Cornel ;
2758: LD_ADDR_VAR 0 5
2762: PUSH
2763: LD_VAR 0 5
2767: PUSH
2768: LD_EXP 29
2772: ADD
2773: ST_TO_ADDR
// end ; if not Houten then
2774: LD_EXP 28
2778: NOT
2779: IFFALSE 2825
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2781: LD_ADDR_EXP 28
2785: PUSH
2786: LD_STRING Houten
2788: PPUSH
2789: LD_EXP 1
2793: NOT
2794: PPUSH
2795: LD_STRING 13a_
2797: PPUSH
2798: CALL 52862 0 3
2802: ST_TO_ADDR
// if Houten then
2803: LD_EXP 28
2807: IFFALSE 2825
// tmp := tmp ^ Houten ;
2809: LD_ADDR_VAR 0 5
2813: PUSH
2814: LD_VAR 0 5
2818: PUSH
2819: LD_EXP 28
2823: ADD
2824: ST_TO_ADDR
// end ; if not Gary then
2825: LD_EXP 30
2829: NOT
2830: IFFALSE 2876
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2832: LD_ADDR_EXP 30
2836: PUSH
2837: LD_STRING Gary
2839: PPUSH
2840: LD_EXP 1
2844: NOT
2845: PPUSH
2846: LD_STRING 13a_
2848: PPUSH
2849: CALL 52862 0 3
2853: ST_TO_ADDR
// if Gary then
2854: LD_EXP 30
2858: IFFALSE 2876
// tmp := tmp ^ Gary ;
2860: LD_ADDR_VAR 0 5
2864: PUSH
2865: LD_VAR 0 5
2869: PUSH
2870: LD_EXP 30
2874: ADD
2875: ST_TO_ADDR
// end ; if not Kikuchi then
2876: LD_EXP 32
2880: NOT
2881: IFFALSE 2927
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2883: LD_ADDR_EXP 32
2887: PUSH
2888: LD_STRING Kikuchi
2890: PPUSH
2891: LD_EXP 1
2895: NOT
2896: PPUSH
2897: LD_STRING 13a_
2899: PPUSH
2900: CALL 52862 0 3
2904: ST_TO_ADDR
// if Kikuchi then
2905: LD_EXP 32
2909: IFFALSE 2927
// tmp := tmp ^ Kikuchi ;
2911: LD_ADDR_VAR 0 5
2915: PUSH
2916: LD_VAR 0 5
2920: PUSH
2921: LD_EXP 32
2925: ADD
2926: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2927: LD_ADDR_VAR 0 5
2931: PUSH
2932: LD_VAR 0 5
2936: PUSH
2937: LD_STRING 13a_others
2939: PPUSH
2940: CALL_OW 31
2944: UNION
2945: ST_TO_ADDR
// tmp := tmp diff 0 ;
2946: LD_ADDR_VAR 0 5
2950: PUSH
2951: LD_VAR 0 5
2955: PUSH
2956: LD_INT 0
2958: DIFF
2959: ST_TO_ADDR
// if tmp < 15 then
2960: LD_VAR 0 5
2964: PUSH
2965: LD_INT 15
2967: LESS
2968: IFFALSE 3056
// for i = 15 downto tmp do
2970: LD_ADDR_VAR 0 2
2974: PUSH
2975: DOUBLE
2976: LD_INT 15
2978: INC
2979: ST_TO_ADDR
2980: LD_VAR 0 5
2984: PUSH
2985: FOR_DOWNTO
2986: IFFALSE 3054
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2988: LD_ADDR_OWVAR 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: PUSH
3003: LD_INT 1
3005: PPUSH
3006: LD_INT 2
3008: PPUSH
3009: CALL_OW 12
3013: ARRAY
3014: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3015: LD_INT 0
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: LD_INT 4
3023: PPUSH
3024: CALL_OW 12
3028: PPUSH
3029: LD_INT 8
3031: PPUSH
3032: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3036: LD_ADDR_VAR 0 5
3040: PUSH
3041: LD_VAR 0 5
3045: PUSH
3046: CALL_OW 44
3050: ADD
3051: ST_TO_ADDR
// end ;
3052: GO 2985
3054: POP
3055: POP
// if not debug then
3056: LD_EXP 1
3060: NOT
3061: IFFALSE 3241
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3063: LD_ADDR_VAR 0 4
3067: PUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_INT 14
3073: PUSH
3074: LD_INT 13
3076: PUSH
3077: LD_INT 12
3079: PUSH
3080: LD_INT 11
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: LD_OWVAR 67
3093: ARRAY
3094: PPUSH
3095: LD_INT 14
3097: PUSH
3098: LD_INT 13
3100: PUSH
3101: LD_INT 12
3103: PUSH
3104: LD_INT 11
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: LD_INT -5
3121: PUSH
3122: LD_EXP 19
3126: PUSH
3127: LD_EXP 52
3131: PUSH
3132: LD_EXP 20
3136: PUSH
3137: LD_EXP 34
3141: PUSH
3142: LD_EXP 25
3146: PUSH
3147: LD_EXP 38
3151: PUSH
3152: LD_INT -2
3154: PUSH
3155: LD_INT -3
3157: PUSH
3158: LD_INT -5
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: PUSH
3173: LD_VAR 0 5
3177: ADD
3178: PPUSH
3179: LD_INT 1
3181: PUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 1
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 3
3197: PUSH
3198: LD_INT 5
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 9
3214: PUSH
3215: LD_INT 0
3217: PUSH
3218: LD_INT 3
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: PPUSH
3234: CALL_OW 42
3238: ST_TO_ADDR
3239: GO 3290
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3241: LD_ADDR_VAR 0 4
3245: PUSH
3246: LD_EXP 40
3250: PUSH
3251: LD_EXP 41
3255: PUSH
3256: LD_EXP 42
3260: PUSH
3261: LD_EXP 43
3265: PUSH
3266: LD_EXP 44
3270: PUSH
3271: LD_EXP 45
3275: PUSH
3276: LD_EXP 46
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3290: LD_ADDR_EXP 17
3294: PUSH
3295: LD_VAR 0 5
3299: PUSH
3300: LD_VAR 0 4
3304: DIFF
3305: ST_TO_ADDR
// uc_nation := 1 ;
3306: LD_ADDR_OWVAR 21
3310: PUSH
3311: LD_INT 1
3313: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3314: LD_INT 5
3316: PPUSH
3317: LD_INT 3
3319: PPUSH
3320: LD_INT 1
3322: PPUSH
3323: LD_INT 6
3325: PPUSH
3326: LD_INT 100
3328: PPUSH
3329: CALL 57702 0 5
// veh := CreateVehicle ;
3333: LD_ADDR_VAR 0 3
3337: PUSH
3338: CALL_OW 45
3342: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3343: LD_VAR 0 3
3347: PPUSH
3348: LD_INT 7
3350: NEG
3351: PPUSH
3352: CALL_OW 242
// SetDir ( veh , 3 ) ;
3356: LD_VAR 0 3
3360: PPUSH
3361: LD_INT 3
3363: PPUSH
3364: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3368: LD_VAR 0 3
3372: PPUSH
3373: LD_INT 31
3375: PPUSH
3376: LD_INT 0
3378: PPUSH
3379: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3383: LD_EXP 19
3387: PPUSH
3388: LD_VAR 0 3
3392: PPUSH
3393: CALL_OW 52
// if Joan then
3397: LD_EXP 34
3401: IFFALSE 3473
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3403: LD_INT 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: LD_INT 1
3411: PPUSH
3412: LD_INT 11
3414: PPUSH
3415: LD_INT 100
3417: PPUSH
3418: CALL 57702 0 5
// veh := CreateVehicle ;
3422: LD_ADDR_VAR 0 3
3426: PUSH
3427: CALL_OW 45
3431: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3432: LD_VAR 0 3
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3444: LD_VAR 0 3
3448: PPUSH
3449: LD_INT 30
3451: PPUSH
3452: LD_INT 0
3454: PPUSH
3455: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3459: LD_EXP 34
3463: PPUSH
3464: LD_VAR 0 3
3468: PPUSH
3469: CALL_OW 52
// end ; if Roth then
3473: LD_EXP 20
3477: IFFALSE 3549
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3479: LD_INT 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: LD_INT 11
3490: PPUSH
3491: LD_INT 100
3493: PPUSH
3494: CALL 57702 0 5
// veh := CreateVehicle ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: CALL_OW 45
3507: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3508: LD_VAR 0 3
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3520: LD_VAR 0 3
3524: PPUSH
3525: LD_INT 30
3527: PPUSH
3528: LD_INT 0
3530: PPUSH
3531: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3535: LD_EXP 20
3539: PPUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: CALL_OW 52
// end ; if Denis then
3549: LD_EXP 25
3553: IFFALSE 3625
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3555: LD_INT 5
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: LD_INT 1
3563: PPUSH
3564: LD_INT 9
3566: PPUSH
3567: LD_INT 100
3569: PPUSH
3570: CALL 57702 0 5
// veh := CreateVehicle ;
3574: LD_ADDR_VAR 0 3
3578: PUSH
3579: CALL_OW 45
3583: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3584: LD_VAR 0 3
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3596: LD_VAR 0 3
3600: PPUSH
3601: LD_INT 30
3603: PPUSH
3604: LD_INT 0
3606: PPUSH
3607: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3611: LD_EXP 25
3615: PPUSH
3616: LD_VAR 0 3
3620: PPUSH
3621: CALL_OW 52
// end ; uc_nation := 3 ;
3625: LD_ADDR_OWVAR 21
3629: PUSH
3630: LD_INT 3
3632: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3633: LD_INT 22
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: LD_INT 1
3641: PPUSH
3642: LD_INT 45
3644: PPUSH
3645: LD_INT 100
3647: PPUSH
3648: CALL 57702 0 5
// veh := CreateVehicle ;
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: CALL_OW 45
3661: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3662: LD_VAR 0 3
3666: PPUSH
3667: LD_INT 7
3669: NEG
3670: PPUSH
3671: CALL_OW 242
// SetDir ( veh , 3 ) ;
3675: LD_VAR 0 3
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3687: LD_VAR 0 3
3691: PPUSH
3692: LD_INT 31
3694: PPUSH
3695: LD_INT 0
3697: PPUSH
3698: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3702: LD_EXP 52
3706: PPUSH
3707: LD_VAR 0 3
3711: PPUSH
3712: CALL_OW 52
// if Gossudarov then
3716: LD_EXP 38
3720: IFFALSE 3807
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3722: LD_INT 22
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: LD_INT 51
3733: PPUSH
3734: LD_INT 100
3736: PPUSH
3737: CALL 57702 0 5
// veh := CreateVehicle ;
3741: LD_ADDR_VAR 0 3
3745: PUSH
3746: CALL_OW 45
3750: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3751: LD_VAR 0 3
3755: PPUSH
3756: LD_INT 3
3758: PPUSH
3759: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3763: LD_VAR 0 3
3767: PPUSH
3768: LD_INT 30
3770: PPUSH
3771: LD_INT 0
3773: PPUSH
3774: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3778: LD_EXP 38
3782: PPUSH
3783: LD_VAR 0 3
3787: PPUSH
3788: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3792: LD_VAR 0 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL_OW 290
// end ; if Mike then
3807: LD_EXP 37
3811: IFFALSE 3828
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3813: LD_EXP 37
3817: PPUSH
3818: LD_INT 30
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 49
// for i in selected do
3828: LD_ADDR_VAR 0 2
3832: PUSH
3833: LD_VAR 0 4
3837: PUSH
3838: FOR_IN
3839: IFFALSE 4397
// begin uc_nation := GetNation ( i ) ;
3841: LD_ADDR_OWVAR 21
3845: PUSH
3846: LD_VAR 0 2
3850: PPUSH
3851: CALL_OW 248
3855: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3856: LD_VAR 0 2
3860: PUSH
3861: LD_EXP 21
3865: PUSH
3866: LD_EXP 22
3870: PUSH
3871: LD_EXP 24
3875: PUSH
3876: LD_EXP 23
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: IN
3887: IFFALSE 3910
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3889: LD_INT 5
3891: PPUSH
3892: LD_INT 3
3894: PPUSH
3895: LD_INT 1
3897: PPUSH
3898: LD_INT 6
3900: PPUSH
3901: LD_INT 100
3903: PPUSH
3904: CALL 57702 0 5
3908: GO 4344
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3910: LD_VAR 0 2
3914: PUSH
3915: LD_EXP 45
3919: PUSH
3920: LD_EXP 50
3924: PUSH
3925: LD_EXP 48
3929: PUSH
3930: LD_EXP 40
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: IN
3941: IFFALSE 3972
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3943: LD_INT 24
3945: PPUSH
3946: LD_INT 1
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: LD_INT 46
3954: PPUSH
3955: LD_INT 65
3957: PPUSH
3958: LD_INT 75
3960: PPUSH
3961: CALL_OW 12
3965: PPUSH
3966: CALL 57702 0 5
3970: GO 4344
// if i = Karamazov then
3972: LD_VAR 0 2
3976: PUSH
3977: LD_EXP 51
3981: EQUAL
3982: IFFALSE 4005
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3984: LD_INT 22
3986: PPUSH
3987: LD_INT 3
3989: PPUSH
3990: LD_INT 1
3992: PPUSH
3993: LD_INT 52
3995: PPUSH
3996: LD_INT 100
3998: PPUSH
3999: CALL 57702 0 5
4003: GO 4344
// if i = Brown then
4005: LD_VAR 0 2
4009: PUSH
4010: LD_EXP 26
4014: EQUAL
4015: IFFALSE 4038
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4017: LD_INT 3
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 1
4025: PPUSH
4026: LD_INT 13
4028: PPUSH
4029: LD_INT 100
4031: PPUSH
4032: CALL 57702 0 5
4036: GO 4344
// if uc_nation = nation_american then
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 1
4045: EQUAL
4046: IFFALSE 4197
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4048: LD_INT 3
4050: PUSH
4051: LD_INT 5
4053: PUSH
4054: LD_INT 5
4056: PUSH
4057: EMPTY
4058: LIST
4059: LIST
4060: LIST
4061: PUSH
4062: LD_OWVAR 21
4066: PUSH
4067: LD_INT 3
4069: MOD
4070: PUSH
4071: LD_INT 1
4073: PLUS
4074: ARRAY
4075: PPUSH
4076: LD_INT 1
4078: PUSH
4079: LD_INT 3
4081: PUSH
4082: LD_INT 1
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PUSH
4090: LD_OWVAR 21
4094: PUSH
4095: LD_INT 3
4097: MOD
4098: PUSH
4099: LD_INT 1
4101: PLUS
4102: ARRAY
4103: PPUSH
4104: LD_INT 1
4106: PPUSH
4107: LD_INT 11
4109: PUSH
4110: LD_INT 4
4112: PUSH
4113: LD_INT 5
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: LD_INT 6
4123: PUSH
4124: LD_INT 7
4126: PUSH
4127: LD_INT 9
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: PUSH
4135: LD_INT 6
4137: PUSH
4138: LD_INT 9
4140: PUSH
4141: LD_INT 12
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: LIST
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: LD_OWVAR 21
4158: PUSH
4159: LD_INT 3
4161: MOD
4162: PUSH
4163: LD_INT 1
4165: PLUS
4166: ARRAY
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 3
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 65
4182: PPUSH
4183: LD_INT 75
4185: PPUSH
4186: CALL_OW 12
4190: PPUSH
4191: CALL 57702 0 5
// end else
4195: GO 4344
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4197: LD_INT 22
4199: PUSH
4200: LD_INT 23
4202: PUSH
4203: LD_INT 23
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: PUSH
4211: LD_OWVAR 21
4215: PUSH
4216: LD_INT 3
4218: MOD
4219: PUSH
4220: LD_INT 1
4222: PLUS
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PUSH
4228: LD_INT 3
4230: PUSH
4231: LD_INT 1
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: LIST
4238: PUSH
4239: LD_OWVAR 21
4243: PUSH
4244: LD_INT 3
4246: MOD
4247: PUSH
4248: LD_INT 1
4250: PLUS
4251: ARRAY
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 43
4261: PUSH
4262: LD_INT 44
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 46
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 44
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 46
4286: PUSH
4287: LD_INT 43
4289: PUSH
4290: LD_INT 45
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: LIST
4302: PUSH
4303: LD_OWVAR 21
4307: PUSH
4308: LD_INT 3
4310: MOD
4311: PUSH
4312: LD_INT 1
4314: PLUS
4315: ARRAY
4316: PUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 3
4322: PPUSH
4323: CALL_OW 12
4327: ARRAY
4328: PPUSH
4329: LD_INT 65
4331: PPUSH
4332: LD_INT 75
4334: PPUSH
4335: CALL_OW 12
4339: PPUSH
4340: CALL 57702 0 5
// end ; veh := CreateVehicle ;
4344: LD_ADDR_VAR 0 3
4348: PUSH
4349: CALL_OW 45
4353: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4354: LD_VAR 0 3
4358: PPUSH
4359: LD_INT 3
4361: PPUSH
4362: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4366: LD_VAR 0 3
4370: PPUSH
4371: LD_INT 30
4373: PPUSH
4374: LD_INT 0
4376: PPUSH
4377: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 3
4390: PPUSH
4391: CALL_OW 52
// end ;
4395: GO 3838
4397: POP
4398: POP
// if artifactArCaptured then
4399: LD_EXP 9
4403: IFFALSE 4489
// begin uc_nation := nation_american ;
4405: LD_ADDR_OWVAR 21
4409: PUSH
4410: LD_INT 1
4412: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4413: LD_INT 3
4415: PPUSH
4416: LD_INT 3
4418: PPUSH
4419: LD_INT 3
4421: PPUSH
4422: LD_INT 12
4424: PPUSH
4425: LD_INT 100
4427: PPUSH
4428: CALL 57702 0 5
// veh := CreateVehicle ;
4432: LD_ADDR_VAR 0 3
4436: PUSH
4437: CALL_OW 45
4441: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4442: LD_VAR 0 3
4446: PPUSH
4447: LD_INT 3
4449: PPUSH
4450: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4454: LD_VAR 0 3
4458: PPUSH
4459: LD_INT 198
4461: PPUSH
4462: LD_INT 22
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 4
4479: PPUSH
4480: LD_INT 50
4482: PPUSH
4483: CALL_OW 290
// end else
4487: GO 4508
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4489: LD_INT 4
4491: PPUSH
4492: LD_INT 5
4494: PPUSH
4495: LD_INT 267
4497: PPUSH
4498: LD_INT 226
4500: PPUSH
4501: LD_INT 0
4503: PPUSH
4504: CALL_OW 58
// end ; uc_nation := nation_american ;
4508: LD_ADDR_OWVAR 21
4512: PUSH
4513: LD_INT 1
4515: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4516: LD_INT 3
4518: PPUSH
4519: LD_INT 3
4521: PPUSH
4522: LD_INT 3
4524: PPUSH
4525: LD_INT 12
4527: PPUSH
4528: LD_INT 100
4530: PPUSH
4531: CALL 57702 0 5
// veh := CreateVehicle ;
4535: LD_ADDR_VAR 0 3
4539: PUSH
4540: CALL_OW 45
4544: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4545: LD_VAR 0 3
4549: PPUSH
4550: LD_INT 3
4552: PPUSH
4553: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4557: LD_VAR 0 3
4561: PPUSH
4562: LD_INT 218
4564: PPUSH
4565: LD_INT 23
4567: PPUSH
4568: LD_INT 0
4570: PPUSH
4571: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 4
4582: PPUSH
4583: LD_INT 30
4585: PPUSH
4586: CALL_OW 290
// uc_nation := nation_russian ;
4590: LD_ADDR_OWVAR 21
4594: PUSH
4595: LD_INT 3
4597: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4598: LD_INT 22
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: LD_INT 3
4606: PPUSH
4607: LD_INT 51
4609: PPUSH
4610: LD_INT 100
4612: PPUSH
4613: CALL 57702 0 5
// veh := CreateVehicle ;
4617: LD_ADDR_VAR 0 3
4621: PUSH
4622: CALL_OW 45
4626: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4627: LD_VAR 0 3
4631: PPUSH
4632: LD_INT 3
4634: PPUSH
4635: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4639: LD_VAR 0 3
4643: PPUSH
4644: LD_INT 214
4646: PPUSH
4647: LD_INT 20
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4657: LD_VAR 0 3
4661: PPUSH
4662: LD_INT 4
4664: PPUSH
4665: LD_INT 40
4667: PPUSH
4668: CALL_OW 290
// end ;
4672: LD_VAR 0 1
4676: RET
// export function AllianceSupport ; var i , veh ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if not allianceTeam then
4682: LD_EXP 17
4686: NOT
4687: IFFALSE 4691
// exit ;
4689: GO 5097
// for i := 1 to 6 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 6
4703: PUSH
4704: FOR_TO
4705: IFFALSE 5001
// begin uc_side := 7 ;
4707: LD_ADDR_OWVAR 20
4711: PUSH
4712: LD_INT 7
4714: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4715: LD_ADDR_OWVAR 21
4719: PUSH
4720: LD_INT 1
4722: PUSH
4723: LD_INT 3
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_VAR 0 2
4734: PUSH
4735: LD_INT 2
4737: MOD
4738: PUSH
4739: LD_INT 1
4741: PLUS
4742: ARRAY
4743: ST_TO_ADDR
// if uc_nation = 1 then
4744: LD_OWVAR 21
4748: PUSH
4749: LD_INT 1
4751: EQUAL
4752: IFFALSE 4794
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4754: LD_INT 5
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 1
4762: PPUSH
4763: LD_INT 6
4765: PUSH
4766: LD_INT 7
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 2
4778: PPUSH
4779: CALL_OW 12
4783: ARRAY
4784: PPUSH
4785: LD_INT 100
4787: PPUSH
4788: CALL 57702 0 5
4792: GO 4832
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4794: LD_INT 23
4796: PPUSH
4797: LD_INT 3
4799: PPUSH
4800: LD_INT 1
4802: PPUSH
4803: LD_INT 46
4805: PUSH
4806: LD_INT 47
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: PUSH
4813: LD_INT 1
4815: PPUSH
4816: LD_INT 2
4818: PPUSH
4819: CALL_OW 12
4823: ARRAY
4824: PPUSH
4825: LD_INT 100
4827: PPUSH
4828: CALL 57702 0 5
// if not allianceTeam then
4832: LD_EXP 17
4836: NOT
4837: IFFALSE 4841
// break ;
4839: GO 5001
// veh := CreateVehicle ;
4841: LD_ADDR_VAR 0 3
4845: PUSH
4846: CALL_OW 45
4850: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4851: LD_VAR 0 3
4855: PPUSH
4856: LD_INT 4
4858: PPUSH
4859: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4863: LD_VAR 0 3
4867: PPUSH
4868: LD_INT 38
4870: PPUSH
4871: LD_INT 0
4873: PPUSH
4874: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4878: LD_EXP 17
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: LD_INT 3
4889: PPUSH
4890: CALL_OW 259
4894: PUSH
4895: LD_INT 4
4897: GREATER
4898: IFFALSE 4916
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4900: LD_EXP 17
4904: PUSH
4905: LD_INT 1
4907: ARRAY
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4916: LD_EXP 17
4920: PUSH
4921: LD_INT 1
4923: ARRAY
4924: PPUSH
4925: LD_INT 4
4927: PPUSH
4928: CALL_OW 259
4932: PUSH
4933: LD_INT 8
4935: GREATER
4936: IFFALSE 4954
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4938: LD_EXP 17
4942: PUSH
4943: LD_INT 1
4945: ARRAY
4946: PPUSH
4947: LD_INT 4
4949: PPUSH
4950: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4954: LD_EXP 17
4958: PUSH
4959: LD_INT 1
4961: ARRAY
4962: PPUSH
4963: LD_VAR 0 3
4967: PPUSH
4968: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4972: LD_ADDR_EXP 17
4976: PUSH
4977: LD_EXP 17
4981: PPUSH
4982: LD_INT 1
4984: PPUSH
4985: CALL_OW 3
4989: ST_TO_ADDR
// ComHold ( veh ) ;
4990: LD_VAR 0 3
4994: PPUSH
4995: CALL_OW 140
// end ;
4999: GO 4704
5001: POP
5002: POP
// uc_side := 7 ;
5003: LD_ADDR_OWVAR 20
5007: PUSH
5008: LD_INT 7
5010: ST_TO_ADDR
// uc_nation := 1 ;
5011: LD_ADDR_OWVAR 21
5015: PUSH
5016: LD_INT 1
5018: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5019: LD_INT 5
5021: PPUSH
5022: LD_INT 3
5024: PPUSH
5025: LD_INT 3
5027: PPUSH
5028: LD_INT 11
5030: PPUSH
5031: LD_INT 100
5033: PPUSH
5034: CALL 57702 0 5
// veh := CreateVehicle ;
5038: LD_ADDR_VAR 0 3
5042: PUSH
5043: CALL_OW 45
5047: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5048: LD_VAR 0 3
5052: PPUSH
5053: LD_INT 4
5055: PPUSH
5056: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 305
5067: PPUSH
5068: LD_INT 218
5070: PPUSH
5071: LD_INT 0
5073: PPUSH
5074: CALL_OW 48
// ComHold ( veh ) ;
5078: LD_VAR 0 3
5082: PPUSH
5083: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5087: LD_INT 313
5089: PPUSH
5090: LD_INT 220
5092: PPUSH
5093: CALL_OW 86
// end ; end_of_file
5097: LD_VAR 0 1
5101: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5102: LD_INT 0
5104: PPUSH
5105: PPUSH
5106: PPUSH
5107: PPUSH
5108: PPUSH
5109: PPUSH
5110: PPUSH
5111: PPUSH
5112: PPUSH
5113: PPUSH
5114: PPUSH
// InitHc ;
5115: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5119: LD_INT 387
5121: PPUSH
5122: LD_STRING sigma
5124: PPUSH
5125: CALL_OW 500
// uc_side := 1 ;
5129: LD_ADDR_OWVAR 20
5133: PUSH
5134: LD_INT 1
5136: ST_TO_ADDR
// uc_nation := 1 ;
5137: LD_ADDR_OWVAR 21
5141: PUSH
5142: LD_INT 1
5144: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5145: LD_ADDR_VAR 0 2
5149: PUSH
5150: LD_INT 22
5152: PUSH
5153: LD_INT 1
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 21
5162: PUSH
5163: LD_INT 3
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: PUSH
5179: FOR_IN
5180: IFFALSE 5196
// SetBLevel ( i , 10 ) ;
5182: LD_VAR 0 2
5186: PPUSH
5187: LD_INT 10
5189: PPUSH
5190: CALL_OW 241
5194: GO 5179
5196: POP
5197: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5198: LD_INT 387
5200: PPUSH
5201: CALL_OW 274
5205: PPUSH
5206: LD_INT 1
5208: PPUSH
5209: LD_INT 7500
5211: PPUSH
5212: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5216: LD_INT 387
5218: PPUSH
5219: CALL_OW 274
5223: PPUSH
5224: LD_INT 2
5226: PPUSH
5227: LD_INT 4000
5229: PPUSH
5230: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5234: LD_INT 387
5236: PPUSH
5237: CALL_OW 274
5241: PPUSH
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 50
5247: PPUSH
5248: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5252: LD_INT 476
5254: PPUSH
5255: CALL_OW 274
5259: PPUSH
5260: LD_INT 1
5262: PPUSH
5263: LD_INT 5500
5265: PPUSH
5266: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5270: LD_INT 476
5272: PPUSH
5273: CALL_OW 274
5277: PPUSH
5278: LD_INT 2
5280: PPUSH
5281: LD_INT 4000
5283: PPUSH
5284: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5288: LD_INT 476
5290: PPUSH
5291: CALL_OW 274
5295: PPUSH
5296: LD_INT 3
5298: PPUSH
5299: LD_INT 10
5301: PPUSH
5302: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5306: LD_ADDR_EXP 55
5310: PUSH
5311: LD_STRING Powell
5313: PPUSH
5314: CALL_OW 25
5318: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5319: LD_EXP 55
5323: PPUSH
5324: LD_INT 387
5326: PPUSH
5327: CALL_OW 52
// tmp := [ ] ;
5331: LD_ADDR_VAR 0 7
5335: PUSH
5336: EMPTY
5337: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5338: LD_ADDR_EXP 21
5342: PUSH
5343: LD_STRING Lisa
5345: PPUSH
5346: LD_EXP 1
5350: NOT
5351: PPUSH
5352: LD_STRING 12p_
5354: PPUSH
5355: CALL 52862 0 3
5359: ST_TO_ADDR
// if Lisa then
5360: LD_EXP 21
5364: IFFALSE 5382
// tmp := tmp ^ Lisa ;
5366: LD_ADDR_VAR 0 7
5370: PUSH
5371: LD_VAR 0 7
5375: PUSH
5376: LD_EXP 21
5380: ADD
5381: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5382: LD_ADDR_EXP 22
5386: PUSH
5387: LD_STRING Donaldson
5389: PPUSH
5390: LD_EXP 1
5394: NOT
5395: PPUSH
5396: LD_STRING 12p_
5398: PPUSH
5399: CALL 52862 0 3
5403: ST_TO_ADDR
// if Donaldson then
5404: LD_EXP 22
5408: IFFALSE 5426
// tmp := tmp ^ Donaldson ;
5410: LD_ADDR_VAR 0 7
5414: PUSH
5415: LD_VAR 0 7
5419: PUSH
5420: LD_EXP 22
5424: ADD
5425: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5426: LD_ADDR_EXP 23
5430: PUSH
5431: LD_STRING Bobby
5433: PPUSH
5434: LD_EXP 1
5438: NOT
5439: PPUSH
5440: LD_STRING 12p_
5442: PPUSH
5443: CALL 52862 0 3
5447: ST_TO_ADDR
// if Bobby then
5448: LD_EXP 23
5452: IFFALSE 5470
// tmp := tmp ^ Bobby ;
5454: LD_ADDR_VAR 0 7
5458: PUSH
5459: LD_VAR 0 7
5463: PUSH
5464: LD_EXP 23
5468: ADD
5469: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5470: LD_ADDR_EXP 24
5474: PUSH
5475: LD_STRING Cyrus
5477: PPUSH
5478: LD_EXP 1
5482: NOT
5483: PPUSH
5484: LD_STRING 12p_
5486: PPUSH
5487: CALL 52862 0 3
5491: ST_TO_ADDR
// if Cyrus then
5492: LD_EXP 24
5496: IFFALSE 5514
// tmp := tmp ^ Cyrus ;
5498: LD_ADDR_VAR 0 7
5502: PUSH
5503: LD_VAR 0 7
5507: PUSH
5508: LD_EXP 24
5512: ADD
5513: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5514: LD_ADDR_EXP 26
5518: PUSH
5519: LD_STRING Brown
5521: PPUSH
5522: LD_EXP 1
5526: NOT
5527: PPUSH
5528: LD_STRING 12p_
5530: PPUSH
5531: CALL 52862 0 3
5535: ST_TO_ADDR
// if Brown then
5536: LD_EXP 26
5540: IFFALSE 5558
// tmp := tmp ^ Brown ;
5542: LD_ADDR_VAR 0 7
5546: PUSH
5547: LD_VAR 0 7
5551: PUSH
5552: LD_EXP 26
5556: ADD
5557: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5558: LD_ADDR_EXP 27
5562: PUSH
5563: LD_STRING Gladstone
5565: PPUSH
5566: LD_EXP 1
5570: NOT
5571: PPUSH
5572: LD_STRING 12p_
5574: PPUSH
5575: CALL 52862 0 3
5579: ST_TO_ADDR
// if Gladstone then
5580: LD_EXP 27
5584: IFFALSE 5602
// tmp := tmp ^ Gladstone ;
5586: LD_ADDR_VAR 0 7
5590: PUSH
5591: LD_VAR 0 7
5595: PUSH
5596: LD_EXP 27
5600: ADD
5601: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5602: LD_ADDR_EXP 28
5606: PUSH
5607: LD_STRING Houten
5609: PPUSH
5610: LD_EXP 1
5614: NOT
5615: PPUSH
5616: LD_STRING 12p_
5618: PPUSH
5619: CALL 52862 0 3
5623: ST_TO_ADDR
// if Houten then
5624: LD_EXP 28
5628: IFFALSE 5646
// tmp := tmp ^ Houten ;
5630: LD_ADDR_VAR 0 7
5634: PUSH
5635: LD_VAR 0 7
5639: PUSH
5640: LD_EXP 28
5644: ADD
5645: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5646: LD_ADDR_EXP 29
5650: PUSH
5651: LD_STRING Cornel
5653: PPUSH
5654: LD_EXP 1
5658: NOT
5659: PPUSH
5660: LD_STRING 12p_
5662: PPUSH
5663: CALL 52862 0 3
5667: ST_TO_ADDR
// if Cornel then
5668: LD_EXP 29
5672: IFFALSE 5690
// tmp := tmp ^ Cornel ;
5674: LD_ADDR_VAR 0 7
5678: PUSH
5679: LD_VAR 0 7
5683: PUSH
5684: LD_EXP 29
5688: ADD
5689: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5690: LD_ADDR_EXP 30
5694: PUSH
5695: LD_STRING Gary
5697: PPUSH
5698: LD_EXP 1
5702: NOT
5703: PPUSH
5704: LD_STRING 12p_
5706: PPUSH
5707: CALL 52862 0 3
5711: ST_TO_ADDR
// if Gary then
5712: LD_EXP 30
5716: IFFALSE 5734
// tmp := tmp ^ Gary ;
5718: LD_ADDR_VAR 0 7
5722: PUSH
5723: LD_VAR 0 7
5727: PUSH
5728: LD_EXP 30
5732: ADD
5733: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5734: LD_ADDR_EXP 32
5738: PUSH
5739: LD_STRING Kikuchi
5741: PPUSH
5742: LD_EXP 1
5746: NOT
5747: PPUSH
5748: LD_STRING 12p_
5750: PPUSH
5751: CALL 52862 0 3
5755: ST_TO_ADDR
// if Kikuchi then
5756: LD_EXP 32
5760: IFFALSE 5778
// tmp := tmp ^ Kikuchi ;
5762: LD_ADDR_VAR 0 7
5766: PUSH
5767: LD_VAR 0 7
5771: PUSH
5772: LD_EXP 32
5776: ADD
5777: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5778: LD_ADDR_VAR 0 7
5782: PUSH
5783: LD_VAR 0 7
5787: PUSH
5788: LD_STRING 12p_others
5790: PPUSH
5791: CALL_OW 31
5795: UNION
5796: ST_TO_ADDR
// if tmp < 36 then
5797: LD_VAR 0 7
5801: PUSH
5802: LD_INT 36
5804: LESS
5805: IFFALSE 5872
// for i = 1 to 36 - tmp do
5807: LD_ADDR_VAR 0 2
5811: PUSH
5812: DOUBLE
5813: LD_INT 1
5815: DEC
5816: ST_TO_ADDR
5817: LD_INT 36
5819: PUSH
5820: LD_VAR 0 7
5824: MINUS
5825: PUSH
5826: FOR_TO
5827: IFFALSE 5870
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5829: LD_INT 1
5831: PPUSH
5832: LD_VAR 0 2
5836: PUSH
5837: LD_INT 4
5839: MOD
5840: PUSH
5841: LD_INT 1
5843: PLUS
5844: PPUSH
5845: LD_INT 10
5847: PPUSH
5848: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5852: LD_ADDR_VAR 0 7
5856: PUSH
5857: LD_VAR 0 7
5861: PUSH
5862: CALL_OW 44
5866: ADD
5867: ST_TO_ADDR
// end ;
5868: GO 5826
5870: POP
5871: POP
// p := 0 ;
5872: LD_ADDR_VAR 0 6
5876: PUSH
5877: LD_INT 0
5879: ST_TO_ADDR
// for i in tmp do
5880: LD_ADDR_VAR 0 2
5884: PUSH
5885: LD_VAR 0 7
5889: PUSH
5890: FOR_IN
5891: IFFALSE 5943
// begin p := Inc ( p ) ;
5893: LD_ADDR_VAR 0 6
5897: PUSH
5898: LD_VAR 0 6
5902: PPUSH
5903: CALL 91925 0 1
5907: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5908: LD_VAR 0 2
5912: PPUSH
5913: LD_INT 62
5915: PPUSH
5916: LD_INT 93
5918: PPUSH
5919: LD_INT 9
5921: PPUSH
5922: LD_INT 0
5924: PPUSH
5925: CALL_OW 50
// if p > 36 then
5929: LD_VAR 0 6
5933: PUSH
5934: LD_INT 36
5936: GREATER
5937: IFFALSE 5941
// break ;
5939: GO 5943
// end ;
5941: GO 5890
5943: POP
5944: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5945: LD_ADDR_EXP 78
5949: PUSH
5950: LD_EXP 78
5954: PPUSH
5955: LD_INT 4
5957: PPUSH
5958: LD_INT 22
5960: PUSH
5961: LD_INT 1
5963: PUSH
5964: EMPTY
5965: LIST
5966: LIST
5967: PPUSH
5968: CALL_OW 69
5972: PUSH
5973: LD_EXP 55
5977: DIFF
5978: PPUSH
5979: CALL_OW 1
5983: ST_TO_ADDR
// uc_side := 0 ;
5984: LD_ADDR_OWVAR 20
5988: PUSH
5989: LD_INT 0
5991: ST_TO_ADDR
// uc_nation := 0 ;
5992: LD_ADDR_OWVAR 21
5996: PUSH
5997: LD_INT 0
5999: ST_TO_ADDR
// for i = 1 to 4 do
6000: LD_ADDR_VAR 0 2
6004: PUSH
6005: DOUBLE
6006: LD_INT 1
6008: DEC
6009: ST_TO_ADDR
6010: LD_INT 4
6012: PUSH
6013: FOR_TO
6014: IFFALSE 6045
// begin InitHc ;
6016: CALL_OW 19
// hc_class := class_apeman ;
6020: LD_ADDR_OWVAR 28
6024: PUSH
6025: LD_INT 12
6027: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6028: CALL_OW 44
6032: PPUSH
6033: LD_INT 11
6035: PPUSH
6036: LD_INT 0
6038: PPUSH
6039: CALL_OW 49
// end ;
6043: GO 6013
6045: POP
6046: POP
// end ;
6047: LD_VAR 0 1
6051: RET
// every 9 9$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6052: LD_EXP 4
6056: NOT
6057: IFFALSE 6863
6059: GO 6061
6061: DISABLE
6062: LD_INT 0
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
// begin enable ;
6068: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6069: LD_INT 22
6071: PUSH
6072: LD_INT 1
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PUSH
6079: LD_INT 23
6081: PUSH
6082: LD_INT 1
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: PUSH
6089: LD_INT 30
6091: PUSH
6092: LD_INT 3
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: PPUSH
6104: CALL_OW 69
6108: NOT
6109: IFFALSE 6113
// exit ;
6111: GO 6863
// if Prob ( 40 ) then
6113: LD_INT 40
6115: PPUSH
6116: CALL_OW 13
6120: IFFALSE 6247
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6122: LD_INT 4
6124: PPUSH
6125: LD_INT 5
6127: PUSH
6128: LD_INT 1
6130: PUSH
6131: LD_INT 2
6133: PUSH
6134: LD_INT 7
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: LIST
6141: LIST
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 1
6148: PUSH
6149: LD_INT 2
6151: PUSH
6152: LD_INT 7
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: LIST
6159: LIST
6160: PUSH
6161: LD_INT 5
6163: PUSH
6164: LD_INT 1
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: LD_INT 7
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 5
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: LD_INT 2
6187: PUSH
6188: LD_INT 6
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 5
6199: PUSH
6200: LD_INT 1
6202: PUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 6
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 5
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: LD_INT 2
6223: PUSH
6224: LD_INT 6
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: LIST
6240: PPUSH
6241: CALL 46436 0 2
// end else
6245: GO 6370
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6247: LD_INT 4
6249: PPUSH
6250: LD_INT 5
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: LD_INT 2
6258: PUSH
6259: LD_INT 7
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PUSH
6268: LD_INT 5
6270: PUSH
6271: LD_INT 1
6273: PUSH
6274: LD_INT 2
6276: PUSH
6277: LD_INT 9
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: LIST
6284: LIST
6285: PUSH
6286: LD_INT 5
6288: PUSH
6289: LD_INT 1
6291: PUSH
6292: LD_INT 2
6294: PUSH
6295: LD_INT 9
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 5
6306: PUSH
6307: LD_INT 1
6309: PUSH
6310: LD_INT 2
6312: PUSH
6313: LD_INT 6
6315: PUSH
6316: EMPTY
6317: LIST
6318: LIST
6319: LIST
6320: LIST
6321: PUSH
6322: LD_INT 5
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: LD_INT 2
6330: PUSH
6331: LD_INT 6
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: PUSH
6340: LD_INT 5
6342: PUSH
6343: LD_INT 1
6345: PUSH
6346: LD_INT 2
6348: PUSH
6349: LD_INT 6
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: LIST
6356: LIST
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: PPUSH
6366: CALL 46436 0 2
// end ; p := 0 ;
6370: LD_ADDR_VAR 0 4
6374: PUSH
6375: LD_INT 0
6377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6378: LD_INT 35
6380: PPUSH
6381: CALL_OW 67
// p := Inc ( p ) ;
6385: LD_ADDR_VAR 0 4
6389: PUSH
6390: LD_VAR 0 4
6394: PPUSH
6395: CALL 91925 0 1
6399: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6400: LD_INT 4
6402: PPUSH
6403: LD_INT 1
6405: PPUSH
6406: CALL 47854 0 2
6410: PUSH
6411: LD_INT 6
6413: GREATEREQUAL
6414: PUSH
6415: LD_VAR 0 4
6419: PUSH
6420: LD_INT 100
6422: GREATER
6423: OR
6424: IFFALSE 6378
// wait ( 0 0$30 ) ;
6426: LD_INT 1050
6428: PPUSH
6429: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6433: LD_ADDR_VAR 0 2
6437: PUSH
6438: LD_INT 4
6440: PPUSH
6441: LD_INT 1
6443: PPUSH
6444: CALL 47854 0 2
6448: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6449: LD_ADDR_EXP 97
6453: PUSH
6454: LD_EXP 97
6458: PPUSH
6459: LD_INT 4
6461: PPUSH
6462: LD_EXP 97
6466: PUSH
6467: LD_INT 4
6469: ARRAY
6470: PUSH
6471: LD_VAR 0 2
6475: DIFF
6476: PPUSH
6477: CALL_OW 1
6481: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6482: LD_ADDR_VAR 0 3
6486: PUSH
6487: LD_INT 0
6489: PPUSH
6490: LD_INT 2
6492: PPUSH
6493: CALL_OW 12
6497: ST_TO_ADDR
// if target then
6498: LD_VAR 0 3
6502: IFFALSE 6630
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6504: LD_ADDR_VAR 0 2
6508: PUSH
6509: LD_VAR 0 2
6513: PPUSH
6514: LD_INT 24
6516: PUSH
6517: LD_INT 250
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: PPUSH
6524: CALL_OW 72
6528: ST_TO_ADDR
// for i in tmp do
6529: LD_ADDR_VAR 0 1
6533: PUSH
6534: LD_VAR 0 2
6538: PUSH
6539: FOR_IN
6540: IFFALSE 6580
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6542: LD_VAR 0 1
6546: PPUSH
6547: LD_INT 114
6549: PPUSH
6550: LD_INT 108
6552: PPUSH
6553: CALL_OW 297
6557: PUSH
6558: LD_INT 9
6560: GREATER
6561: IFFALSE 6578
// ComMoveXY ( i , 114 , 108 ) ;
6563: LD_VAR 0 1
6567: PPUSH
6568: LD_INT 114
6570: PPUSH
6571: LD_INT 108
6573: PPUSH
6574: CALL_OW 111
6578: GO 6539
6580: POP
6581: POP
// wait ( 0 0$1 ) ;
6582: LD_INT 35
6584: PPUSH
6585: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6589: LD_VAR 0 2
6593: PPUSH
6594: LD_INT 92
6596: PUSH
6597: LD_INT 114
6599: PUSH
6600: LD_INT 108
6602: PUSH
6603: LD_INT 9
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: LIST
6611: PPUSH
6612: CALL_OW 72
6616: PUSH
6617: LD_VAR 0 2
6621: PUSH
6622: LD_INT 1
6624: MINUS
6625: GREATEREQUAL
6626: IFFALSE 6504
// end else
6628: GO 6754
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6630: LD_ADDR_VAR 0 2
6634: PUSH
6635: LD_VAR 0 2
6639: PPUSH
6640: LD_INT 24
6642: PUSH
6643: LD_INT 250
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: PPUSH
6650: CALL_OW 72
6654: ST_TO_ADDR
// for i in tmp do
6655: LD_ADDR_VAR 0 1
6659: PUSH
6660: LD_VAR 0 2
6664: PUSH
6665: FOR_IN
6666: IFFALSE 6706
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6668: LD_VAR 0 1
6672: PPUSH
6673: LD_INT 129
6675: PPUSH
6676: LD_INT 139
6678: PPUSH
6679: CALL_OW 297
6683: PUSH
6684: LD_INT 9
6686: GREATER
6687: IFFALSE 6704
// ComMoveXY ( i , 129 , 139 ) ;
6689: LD_VAR 0 1
6693: PPUSH
6694: LD_INT 129
6696: PPUSH
6697: LD_INT 139
6699: PPUSH
6700: CALL_OW 111
6704: GO 6665
6706: POP
6707: POP
// wait ( 0 0$1 ) ;
6708: LD_INT 35
6710: PPUSH
6711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6715: LD_VAR 0 2
6719: PPUSH
6720: LD_INT 92
6722: PUSH
6723: LD_INT 129
6725: PUSH
6726: LD_INT 139
6728: PUSH
6729: LD_INT 9
6731: PUSH
6732: EMPTY
6733: LIST
6734: LIST
6735: LIST
6736: LIST
6737: PPUSH
6738: CALL_OW 72
6742: PUSH
6743: LD_VAR 0 2
6747: PUSH
6748: LD_INT 1
6750: MINUS
6751: GREATEREQUAL
6752: IFFALSE 6630
// end ; repeat wait ( 0 0$1 ) ;
6754: LD_INT 35
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 1
6765: PUSH
6766: LD_VAR 0 2
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6854
// begin if GetLives ( i ) > 251 then
6774: LD_VAR 0 1
6778: PPUSH
6779: CALL_OW 256
6783: PUSH
6784: LD_INT 251
6786: GREATER
6787: IFFALSE 6825
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6789: LD_VAR 0 1
6793: PPUSH
6794: LD_INT 81
6796: PUSH
6797: LD_INT 1
6799: PUSH
6800: EMPTY
6801: LIST
6802: LIST
6803: PPUSH
6804: CALL_OW 69
6808: PPUSH
6809: LD_VAR 0 1
6813: PPUSH
6814: CALL_OW 74
6818: PPUSH
6819: CALL_OW 115
6823: GO 6852
// if IsDead ( i ) then
6825: LD_VAR 0 1
6829: PPUSH
6830: CALL_OW 301
6834: IFFALSE 6852
// tmp := tmp diff i ;
6836: LD_ADDR_VAR 0 2
6840: PUSH
6841: LD_VAR 0 2
6845: PUSH
6846: LD_VAR 0 1
6850: DIFF
6851: ST_TO_ADDR
// end ;
6852: GO 6771
6854: POP
6855: POP
// until not tmp ;
6856: LD_VAR 0 2
6860: NOT
6861: IFFALSE 6754
// end ;
6863: PPOPN 4
6865: END
// every 30 30$00 trigger not americanDestroyed do
6866: LD_EXP 4
6870: NOT
6871: IFFALSE 6940
6873: GO 6875
6875: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6876: LD_INT 63000
6878: PUSH
6879: LD_INT 42000
6881: PUSH
6882: LD_INT 31500
6884: PUSH
6885: LD_INT 21000
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: LIST
6892: LIST
6893: PUSH
6894: LD_OWVAR 67
6898: ARRAY
6899: PPUSH
6900: CALL_OW 67
// if americanDestroyed then
6904: LD_EXP 4
6908: IFFALSE 6912
// exit ;
6910: GO 6940
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6912: LD_INT 4
6914: PPUSH
6915: LD_INT 5
6917: PUSH
6918: LD_INT 3
6920: PUSH
6921: LD_INT 1
6923: PUSH
6924: LD_INT 8
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: LIST
6931: LIST
6932: PUSH
6933: EMPTY
6934: LIST
6935: PPUSH
6936: CALL 46436 0 2
// end ; end_of_file
6940: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6941: LD_INT 0
6943: PPUSH
6944: PPUSH
6945: PPUSH
6946: PPUSH
6947: PPUSH
// side := 2 ;
6948: LD_ADDR_VAR 0 5
6952: PUSH
6953: LD_INT 2
6955: ST_TO_ADDR
// InitHc ;
6956: CALL_OW 19
// uc_side := side ;
6960: LD_ADDR_OWVAR 20
6964: PUSH
6965: LD_VAR 0 5
6969: ST_TO_ADDR
// uc_nation := 2 ;
6970: LD_ADDR_OWVAR 21
6974: PUSH
6975: LD_INT 2
6977: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_INT 2
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 21
6995: PUSH
6996: LD_INT 3
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PPUSH
7007: CALL_OW 69
7011: PUSH
7012: FOR_IN
7013: IFFALSE 7029
// SetBLevel ( i , 10 ) ;
7015: LD_VAR 0 2
7019: PPUSH
7020: LD_INT 10
7022: PPUSH
7023: CALL_OW 241
7027: GO 7012
7029: POP
7030: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7031: LD_ADDR_VAR 0 4
7035: PUSH
7036: LD_INT 22
7038: PUSH
7039: LD_VAR 0 5
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: LD_INT 30
7050: PUSH
7051: LD_INT 32
7053: PUSH
7054: EMPTY
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 58
7060: PUSH
7061: EMPTY
7062: LIST
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: LIST
7068: PPUSH
7069: CALL_OW 69
7073: ST_TO_ADDR
// for i = 1 to 10 do
7074: LD_ADDR_VAR 0 2
7078: PUSH
7079: DOUBLE
7080: LD_INT 1
7082: DEC
7083: ST_TO_ADDR
7084: LD_INT 10
7086: PUSH
7087: FOR_TO
7088: IFFALSE 7160
// begin uc_nation := nation_nature ;
7090: LD_ADDR_OWVAR 21
7094: PUSH
7095: LD_INT 0
7097: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7098: LD_ADDR_OWVAR 28
7102: PUSH
7103: LD_INT 15
7105: ST_TO_ADDR
// hc_gallery :=  ;
7106: LD_ADDR_OWVAR 33
7110: PUSH
7111: LD_STRING 
7113: ST_TO_ADDR
// hc_name :=  ;
7114: LD_ADDR_OWVAR 26
7118: PUSH
7119: LD_STRING 
7121: ST_TO_ADDR
// un := CreateHuman ;
7122: LD_ADDR_VAR 0 3
7126: PUSH
7127: CALL_OW 44
7131: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7132: LD_VAR 0 3
7136: PPUSH
7137: LD_VAR 0 4
7141: PUSH
7142: LD_VAR 0 4
7146: PUSH
7147: LD_VAR 0 2
7151: MINUS
7152: ARRAY
7153: PPUSH
7154: CALL_OW 52
// end ;
7158: GO 7087
7160: POP
7161: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7162: LD_INT 503
7164: PPUSH
7165: LD_INT 27
7167: PPUSH
7168: LD_STRING 
7170: PPUSH
7171: LD_INT 8
7173: PUSH
7174: LD_INT 9
7176: PUSH
7177: LD_INT 10
7179: PUSH
7180: LD_INT 10
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: LIST
7187: LIST
7188: PUSH
7189: LD_OWVAR 67
7193: ARRAY
7194: PPUSH
7195: LD_INT 3000
7197: PUSH
7198: LD_INT 500
7200: PUSH
7201: LD_INT 150
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: LIST
7208: PPUSH
7209: LD_INT 16
7211: PUSH
7212: LD_INT 6
7214: PUSH
7215: LD_INT 6
7217: PUSH
7218: LD_INT 6
7220: PUSH
7221: EMPTY
7222: LIST
7223: LIST
7224: LIST
7225: LIST
7226: PPUSH
7227: CALL 61523 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7231: LD_ADDR_EXP 78
7235: PUSH
7236: LD_EXP 78
7240: PPUSH
7241: LD_INT 1
7243: PPUSH
7244: LD_INT 22
7246: PUSH
7247: LD_VAR 0 5
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: PUSH
7256: LD_INT 23
7258: PUSH
7259: LD_INT 2
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 21
7271: PUSH
7272: LD_INT 2
7274: PUSH
7275: EMPTY
7276: LIST
7277: LIST
7278: PUSH
7279: EMPTY
7280: LIST
7281: LIST
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: LIST
7287: PPUSH
7288: CALL_OW 69
7292: PPUSH
7293: CALL_OW 1
7297: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7298: LD_INT 216
7300: PPUSH
7301: LD_INT 228
7303: PPUSH
7304: LD_INT 2
7306: PPUSH
7307: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7311: LD_INT 223
7313: PPUSH
7314: LD_INT 241
7316: PPUSH
7317: LD_INT 2
7319: PPUSH
7320: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7324: LD_INT 216
7326: PPUSH
7327: LD_INT 217
7329: PPUSH
7330: LD_INT 2
7332: PPUSH
7333: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7337: LD_INT 233
7339: PPUSH
7340: LD_INT 257
7342: PPUSH
7343: LD_INT 2
7345: PPUSH
7346: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7350: LD_INT 230
7352: PPUSH
7353: LD_INT 199
7355: PPUSH
7356: LD_INT 2
7358: PPUSH
7359: CALL_OW 244
// end ;
7363: LD_VAR 0 1
7367: RET
// export Omar ; export function PrepareOmarAli ; begin
7368: LD_INT 0
7370: PPUSH
// uc_side := 5 ;
7371: LD_ADDR_OWVAR 20
7375: PUSH
7376: LD_INT 5
7378: ST_TO_ADDR
// uc_nation := 2 ;
7379: LD_ADDR_OWVAR 21
7383: PUSH
7384: LD_INT 2
7386: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7387: LD_ADDR_EXP 56
7391: PUSH
7392: LD_STRING Omar
7394: PPUSH
7395: CALL_OW 25
7399: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7400: LD_EXP 56
7404: PPUSH
7405: LD_INT 330
7407: PPUSH
7408: LD_INT 244
7410: PPUSH
7411: LD_INT 0
7413: PPUSH
7414: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7418: LD_EXP 56
7422: PPUSH
7423: LD_INT 252
7425: PPUSH
7426: LD_INT 220
7428: PPUSH
7429: CALL_OW 111
// end ; end_of_file
7433: LD_VAR 0 1
7437: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7438: LD_INT 0
7440: PPUSH
7441: PPUSH
7442: PPUSH
7443: PPUSH
7444: PPUSH
// side := 8 ;
7445: LD_ADDR_VAR 0 3
7449: PUSH
7450: LD_INT 8
7452: ST_TO_ADDR
// InitHc ;
7453: CALL_OW 19
// uc_side := side ;
7457: LD_ADDR_OWVAR 20
7461: PUSH
7462: LD_VAR 0 3
7466: ST_TO_ADDR
// uc_nation := 2 ;
7467: LD_ADDR_OWVAR 21
7471: PUSH
7472: LD_INT 2
7474: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7475: LD_ADDR_VAR 0 2
7479: PUSH
7480: LD_INT 22
7482: PUSH
7483: LD_VAR 0 3
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PUSH
7492: LD_INT 21
7494: PUSH
7495: LD_INT 3
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PPUSH
7506: CALL_OW 69
7510: PUSH
7511: FOR_IN
7512: IFFALSE 7528
// SetBLevel ( i , 10 ) ;
7514: LD_VAR 0 2
7518: PPUSH
7519: LD_INT 10
7521: PPUSH
7522: CALL_OW 241
7526: GO 7511
7528: POP
7529: POP
// Schulz := NewCharacter ( Schulz ) ;
7530: LD_ADDR_EXP 57
7534: PUSH
7535: LD_STRING Schulz
7537: PPUSH
7538: CALL_OW 25
7542: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7543: LD_ADDR_EXP 59
7547: PUSH
7548: LD_STRING Kaia
7550: PPUSH
7551: CALL_OW 25
7555: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7556: LD_EXP 59
7560: PPUSH
7561: LD_INT 324
7563: PPUSH
7564: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7568: LD_ADDR_EXP 58
7572: PUSH
7573: LD_STRING Kozlov
7575: PPUSH
7576: LD_INT 0
7578: PPUSH
7579: LD_STRING 
7581: PPUSH
7582: CALL 52862 0 3
7586: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7587: LD_EXP 58
7591: PPUSH
7592: LD_INT 22
7594: PUSH
7595: LD_INT 8
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 23
7604: PUSH
7605: LD_INT 3
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 30
7614: PUSH
7615: LD_INT 8
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: LIST
7626: PPUSH
7627: CALL_OW 69
7631: PUSH
7632: LD_INT 1
7634: ARRAY
7635: PPUSH
7636: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7640: LD_EXP 58
7644: PPUSH
7645: LD_INT 3
7647: PPUSH
7648: LD_INT 10
7650: PPUSH
7651: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7655: LD_ADDR_VAR 0 5
7659: PUSH
7660: LD_INT 22
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: LD_INT 30
7674: PUSH
7675: LD_INT 32
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: LD_INT 58
7684: PUSH
7685: EMPTY
7686: LIST
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: PPUSH
7693: CALL_OW 69
7697: ST_TO_ADDR
// for i = 1 to 10 do
7698: LD_ADDR_VAR 0 2
7702: PUSH
7703: DOUBLE
7704: LD_INT 1
7706: DEC
7707: ST_TO_ADDR
7708: LD_INT 10
7710: PUSH
7711: FOR_TO
7712: IFFALSE 7784
// begin uc_nation := nation_nature ;
7714: LD_ADDR_OWVAR 21
7718: PUSH
7719: LD_INT 0
7721: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7722: LD_ADDR_OWVAR 28
7726: PUSH
7727: LD_INT 15
7729: ST_TO_ADDR
// hc_gallery :=  ;
7730: LD_ADDR_OWVAR 33
7734: PUSH
7735: LD_STRING 
7737: ST_TO_ADDR
// hc_name :=  ;
7738: LD_ADDR_OWVAR 26
7742: PUSH
7743: LD_STRING 
7745: ST_TO_ADDR
// un := CreateHuman ;
7746: LD_ADDR_VAR 0 4
7750: PUSH
7751: CALL_OW 44
7755: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7756: LD_VAR 0 4
7760: PPUSH
7761: LD_VAR 0 5
7765: PUSH
7766: LD_VAR 0 5
7770: PUSH
7771: LD_VAR 0 2
7775: MINUS
7776: ARRAY
7777: PPUSH
7778: CALL_OW 52
// end ;
7782: GO 7711
7784: POP
7785: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7786: LD_INT 324
7788: PPUSH
7789: LD_INT 3
7791: PPUSH
7792: LD_STRING 
7794: PPUSH
7795: LD_INT 8
7797: PUSH
7798: LD_INT 9
7800: PUSH
7801: LD_INT 10
7803: PUSH
7804: LD_INT 10
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: PUSH
7813: LD_OWVAR 67
7817: ARRAY
7818: PPUSH
7819: LD_INT 3000
7821: PUSH
7822: LD_INT 500
7824: PUSH
7825: LD_INT 150
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: LIST
7832: PPUSH
7833: LD_INT 16
7835: PUSH
7836: LD_INT 6
7838: PUSH
7839: LD_INT 6
7841: PUSH
7842: LD_INT 8
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: PPUSH
7851: CALL 61523 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7855: LD_ADDR_EXP 78
7859: PUSH
7860: LD_EXP 78
7864: PPUSH
7865: LD_INT 3
7867: PPUSH
7868: LD_INT 22
7870: PUSH
7871: LD_VAR 0 3
7875: PUSH
7876: EMPTY
7877: LIST
7878: LIST
7879: PUSH
7880: LD_INT 23
7882: PUSH
7883: LD_INT 2
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: PUSH
7890: LD_INT 3
7892: PUSH
7893: LD_INT 21
7895: PUSH
7896: LD_INT 2
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: EMPTY
7908: LIST
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 69
7916: PUSH
7917: LD_EXP 57
7921: DIFF
7922: PPUSH
7923: CALL_OW 1
7927: ST_TO_ADDR
// end ;
7928: LD_VAR 0 1
7932: RET
// export function BuildKozlovBomb ; begin
7933: LD_INT 0
7935: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7936: LD_INT 332
7938: PPUSH
7939: CALL_OW 302
7943: NOT
7944: PUSH
7945: LD_INT 336
7947: PPUSH
7948: CALL_OW 302
7952: NOT
7953: OR
7954: IFFALSE 7958
// exit ;
7956: GO 8055
// ComChangeProfession ( Kozlov , 4 ) ;
7958: LD_EXP 58
7962: PPUSH
7963: LD_INT 4
7965: PPUSH
7966: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7970: LD_INT 336
7972: PPUSH
7973: LD_INT 25
7975: PPUSH
7976: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7980: LD_INT 35
7982: PPUSH
7983: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7987: LD_INT 25
7989: PPUSH
7990: LD_INT 8
7992: PPUSH
7993: CALL_OW 321
7997: PUSH
7998: LD_INT 2
8000: EQUAL
8001: IFFALSE 7980
// ComExitBuilding ( Kozlov ) ;
8003: LD_EXP 58
8007: PPUSH
8008: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8012: LD_EXP 58
8016: PPUSH
8017: LD_INT 332
8019: PPUSH
8020: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8024: LD_EXP 58
8028: PPUSH
8029: LD_INT 3
8031: PPUSH
8032: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8036: LD_INT 332
8038: PPUSH
8039: LD_INT 23
8041: PPUSH
8042: LD_INT 3
8044: PPUSH
8045: LD_INT 1
8047: PPUSH
8048: LD_INT 48
8050: PPUSH
8051: CALL_OW 125
// end ;
8055: LD_VAR 0 1
8059: RET
// every 9 9$30 + 7 7$00 trigger not legionDestroyed do var i , tmp , target , p ;
8060: LD_EXP 3
8064: NOT
8065: IFFALSE 8955
8067: GO 8069
8069: DISABLE
8070: LD_INT 0
8072: PPUSH
8073: PPUSH
8074: PPUSH
8075: PPUSH
// begin enable ;
8076: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8077: LD_INT 22
8079: PUSH
8080: LD_INT 8
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: PUSH
8087: LD_INT 23
8089: PUSH
8090: LD_INT 2
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: PUSH
8097: LD_INT 30
8099: PUSH
8100: LD_INT 3
8102: PUSH
8103: EMPTY
8104: LIST
8105: LIST
8106: PUSH
8107: EMPTY
8108: LIST
8109: LIST
8110: LIST
8111: PPUSH
8112: CALL_OW 69
8116: NOT
8117: IFFALSE 8121
// exit ;
8119: GO 8955
// if Prob ( 40 ) then
8121: LD_INT 40
8123: PPUSH
8124: CALL_OW 13
8128: IFFALSE 8255
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8130: LD_INT 3
8132: PPUSH
8133: LD_INT 14
8135: PUSH
8136: LD_INT 1
8138: PUSH
8139: LD_INT 2
8141: PUSH
8142: LD_INT 28
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 14
8153: PUSH
8154: LD_INT 1
8156: PUSH
8157: LD_INT 2
8159: PUSH
8160: LD_INT 28
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: PUSH
8169: LD_INT 14
8171: PUSH
8172: LD_INT 1
8174: PUSH
8175: LD_INT 2
8177: PUSH
8178: LD_INT 28
8180: PUSH
8181: EMPTY
8182: LIST
8183: LIST
8184: LIST
8185: LIST
8186: PUSH
8187: LD_INT 14
8189: PUSH
8190: LD_INT 1
8192: PUSH
8193: LD_INT 2
8195: PUSH
8196: LD_INT 28
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: LIST
8203: LIST
8204: PUSH
8205: LD_INT 14
8207: PUSH
8208: LD_INT 1
8210: PUSH
8211: LD_INT 2
8213: PUSH
8214: LD_INT 28
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_INT 14
8225: PUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 2
8231: PUSH
8232: LD_INT 26
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: LIST
8239: LIST
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: LIST
8247: LIST
8248: PPUSH
8249: CALL 46436 0 2
// end else
8253: GO 8462
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8255: LD_INT 3
8257: PPUSH
8258: LD_INT 14
8260: PUSH
8261: LD_INT 1
8263: PUSH
8264: LD_INT 2
8266: PUSH
8267: LD_INT 27
8269: PUSH
8270: LD_INT 26
8272: PUSH
8273: LD_INT 26
8275: PUSH
8276: LD_INT 28
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: LIST
8283: LIST
8284: PUSH
8285: LD_OWVAR 67
8289: ARRAY
8290: PUSH
8291: EMPTY
8292: LIST
8293: LIST
8294: LIST
8295: LIST
8296: PUSH
8297: LD_INT 14
8299: PUSH
8300: LD_INT 1
8302: PUSH
8303: LD_INT 2
8305: PUSH
8306: LD_INT 27
8308: PUSH
8309: LD_INT 26
8311: PUSH
8312: LD_INT 26
8314: PUSH
8315: LD_INT 26
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: LIST
8322: LIST
8323: PUSH
8324: LD_OWVAR 67
8328: ARRAY
8329: PUSH
8330: EMPTY
8331: LIST
8332: LIST
8333: LIST
8334: LIST
8335: PUSH
8336: LD_INT 14
8338: PUSH
8339: LD_INT 1
8341: PUSH
8342: LD_INT 2
8344: PUSH
8345: LD_INT 26
8347: PUSH
8348: LD_INT 26
8350: PUSH
8351: LD_INT 29
8353: PUSH
8354: LD_INT 29
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: PUSH
8363: LD_OWVAR 67
8367: ARRAY
8368: PUSH
8369: EMPTY
8370: LIST
8371: LIST
8372: LIST
8373: LIST
8374: PUSH
8375: LD_INT 13
8377: PUSH
8378: LD_INT 1
8380: PUSH
8381: LD_INT 2
8383: PUSH
8384: LD_INT 26
8386: PUSH
8387: LD_INT 29
8389: PUSH
8390: LD_INT 29
8392: PUSH
8393: LD_INT 29
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: PUSH
8402: LD_OWVAR 67
8406: ARRAY
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 13
8416: PUSH
8417: LD_INT 1
8419: PUSH
8420: LD_INT 2
8422: PUSH
8423: LD_INT 29
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: LD_INT 14
8434: PUSH
8435: LD_INT 1
8437: PUSH
8438: LD_INT 2
8440: PUSH
8441: LD_INT 26
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: LIST
8448: LIST
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: LIST
8454: LIST
8455: LIST
8456: LIST
8457: PPUSH
8458: CALL 46436 0 2
// end ; p := 0 ;
8462: LD_ADDR_VAR 0 4
8466: PUSH
8467: LD_INT 0
8469: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8470: LD_INT 35
8472: PPUSH
8473: CALL_OW 67
// p := Inc ( p ) ;
8477: LD_ADDR_VAR 0 4
8481: PUSH
8482: LD_VAR 0 4
8486: PPUSH
8487: CALL 91925 0 1
8491: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8492: LD_INT 3
8494: PPUSH
8495: LD_INT 1
8497: PPUSH
8498: CALL 47854 0 2
8502: PUSH
8503: LD_INT 6
8505: GREATEREQUAL
8506: PUSH
8507: LD_VAR 0 4
8511: PUSH
8512: LD_INT 100
8514: GREATER
8515: OR
8516: IFFALSE 8470
// wait ( 0 0$30 ) ;
8518: LD_INT 1050
8520: PPUSH
8521: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8525: LD_ADDR_VAR 0 2
8529: PUSH
8530: LD_INT 3
8532: PPUSH
8533: LD_INT 1
8535: PPUSH
8536: CALL 47854 0 2
8540: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8541: LD_ADDR_EXP 97
8545: PUSH
8546: LD_EXP 97
8550: PPUSH
8551: LD_INT 3
8553: PPUSH
8554: LD_EXP 97
8558: PUSH
8559: LD_INT 3
8561: ARRAY
8562: PUSH
8563: LD_VAR 0 2
8567: DIFF
8568: PPUSH
8569: CALL_OW 1
8573: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8574: LD_ADDR_VAR 0 3
8578: PUSH
8579: LD_INT 0
8581: PPUSH
8582: LD_INT 2
8584: PPUSH
8585: CALL_OW 12
8589: ST_TO_ADDR
// if target then
8590: LD_VAR 0 3
8594: IFFALSE 8722
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8596: LD_ADDR_VAR 0 2
8600: PUSH
8601: LD_VAR 0 2
8605: PPUSH
8606: LD_INT 24
8608: PUSH
8609: LD_INT 250
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PPUSH
8616: CALL_OW 72
8620: ST_TO_ADDR
// for i in tmp do
8621: LD_ADDR_VAR 0 1
8625: PUSH
8626: LD_VAR 0 2
8630: PUSH
8631: FOR_IN
8632: IFFALSE 8672
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8634: LD_VAR 0 1
8638: PPUSH
8639: LD_INT 89
8641: PPUSH
8642: LD_INT 71
8644: PPUSH
8645: CALL_OW 297
8649: PUSH
8650: LD_INT 9
8652: GREATER
8653: IFFALSE 8670
// ComMoveXY ( i , 89 , 71 ) ;
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_INT 89
8662: PPUSH
8663: LD_INT 71
8665: PPUSH
8666: CALL_OW 111
8670: GO 8631
8672: POP
8673: POP
// wait ( 0 0$1 ) ;
8674: LD_INT 35
8676: PPUSH
8677: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8681: LD_VAR 0 2
8685: PPUSH
8686: LD_INT 92
8688: PUSH
8689: LD_INT 89
8691: PUSH
8692: LD_INT 71
8694: PUSH
8695: LD_INT 9
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: LIST
8702: LIST
8703: PPUSH
8704: CALL_OW 72
8708: PUSH
8709: LD_VAR 0 2
8713: PUSH
8714: LD_INT 1
8716: MINUS
8717: GREATEREQUAL
8718: IFFALSE 8596
// end else
8720: GO 8846
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8722: LD_ADDR_VAR 0 2
8726: PUSH
8727: LD_VAR 0 2
8731: PPUSH
8732: LD_INT 24
8734: PUSH
8735: LD_INT 250
8737: PUSH
8738: EMPTY
8739: LIST
8740: LIST
8741: PPUSH
8742: CALL_OW 72
8746: ST_TO_ADDR
// for i in tmp do
8747: LD_ADDR_VAR 0 1
8751: PUSH
8752: LD_VAR 0 2
8756: PUSH
8757: FOR_IN
8758: IFFALSE 8798
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8760: LD_VAR 0 1
8764: PPUSH
8765: LD_INT 147
8767: PPUSH
8768: LD_INT 4
8770: PPUSH
8771: CALL_OW 297
8775: PUSH
8776: LD_INT 9
8778: GREATER
8779: IFFALSE 8796
// ComMoveXY ( i , 147 , 4 ) ;
8781: LD_VAR 0 1
8785: PPUSH
8786: LD_INT 147
8788: PPUSH
8789: LD_INT 4
8791: PPUSH
8792: CALL_OW 111
8796: GO 8757
8798: POP
8799: POP
// wait ( 0 0$1 ) ;
8800: LD_INT 35
8802: PPUSH
8803: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8807: LD_VAR 0 2
8811: PPUSH
8812: LD_INT 92
8814: PUSH
8815: LD_INT 147
8817: PUSH
8818: LD_INT 4
8820: PUSH
8821: LD_INT 9
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: LIST
8828: LIST
8829: PPUSH
8830: CALL_OW 72
8834: PUSH
8835: LD_VAR 0 2
8839: PUSH
8840: LD_INT 1
8842: MINUS
8843: GREATEREQUAL
8844: IFFALSE 8722
// end ; repeat wait ( 0 0$1 ) ;
8846: LD_INT 35
8848: PPUSH
8849: CALL_OW 67
// for i in tmp do
8853: LD_ADDR_VAR 0 1
8857: PUSH
8858: LD_VAR 0 2
8862: PUSH
8863: FOR_IN
8864: IFFALSE 8946
// begin if GetLives ( i ) > 251 then
8866: LD_VAR 0 1
8870: PPUSH
8871: CALL_OW 256
8875: PUSH
8876: LD_INT 251
8878: GREATER
8879: IFFALSE 8917
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8881: LD_VAR 0 1
8885: PPUSH
8886: LD_INT 81
8888: PUSH
8889: LD_INT 8
8891: PUSH
8892: EMPTY
8893: LIST
8894: LIST
8895: PPUSH
8896: CALL_OW 69
8900: PPUSH
8901: LD_VAR 0 1
8905: PPUSH
8906: CALL_OW 74
8910: PPUSH
8911: CALL_OW 115
8915: GO 8944
// if IsDead ( i ) then
8917: LD_VAR 0 1
8921: PPUSH
8922: CALL_OW 301
8926: IFFALSE 8944
// tmp := tmp diff i ;
8928: LD_ADDR_VAR 0 2
8932: PUSH
8933: LD_VAR 0 2
8937: PUSH
8938: LD_VAR 0 1
8942: DIFF
8943: ST_TO_ADDR
// end ;
8944: GO 8863
8946: POP
8947: POP
// until not tmp ;
8948: LD_VAR 0 2
8952: NOT
8953: IFFALSE 8846
// end ;
8955: PPOPN 4
8957: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8958: LD_EXP 58
8962: PPUSH
8963: CALL_OW 302
8967: PUSH
8968: LD_EXP 3
8972: NOT
8973: AND
8974: IFFALSE 8983
8976: GO 8978
8978: DISABLE
// BuildKozlovBomb ;
8979: CALL 7933 0 0
8983: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8984: LD_INT 22
8986: PUSH
8987: LD_INT 8
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: PUSH
8994: LD_INT 34
8996: PUSH
8997: LD_INT 48
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PPUSH
9008: CALL_OW 69
9012: IFFALSE 9060
9014: GO 9016
9016: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9017: LD_INT 22
9019: PUSH
9020: LD_INT 8
9022: PUSH
9023: EMPTY
9024: LIST
9025: LIST
9026: PUSH
9027: LD_INT 34
9029: PUSH
9030: LD_INT 48
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: PPUSH
9041: CALL_OW 69
9045: PUSH
9046: LD_INT 1
9048: ARRAY
9049: PPUSH
9050: LD_INT 173
9052: PPUSH
9053: LD_INT 96
9055: PPUSH
9056: CALL_OW 116
// end ; end_of_file
9060: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9061: LD_INT 0
9063: PPUSH
9064: PPUSH
9065: PPUSH
9066: PPUSH
9067: PPUSH
9068: PPUSH
9069: PPUSH
9070: PPUSH
9071: PPUSH
9072: PPUSH
// side := 3 ;
9073: LD_ADDR_VAR 0 6
9077: PUSH
9078: LD_INT 3
9080: ST_TO_ADDR
// InitHc ;
9081: CALL_OW 19
// uc_side := side ;
9085: LD_ADDR_OWVAR 20
9089: PUSH
9090: LD_VAR 0 6
9094: ST_TO_ADDR
// uc_nation := 3 ;
9095: LD_ADDR_OWVAR 21
9099: PUSH
9100: LD_INT 3
9102: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9103: LD_ADDR_VAR 0 2
9107: PUSH
9108: LD_INT 22
9110: PUSH
9111: LD_VAR 0 6
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 21
9122: PUSH
9123: LD_INT 3
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PPUSH
9134: CALL_OW 69
9138: PUSH
9139: FOR_IN
9140: IFFALSE 9156
// SetBLevel ( i , 10 ) ;
9142: LD_VAR 0 2
9146: PPUSH
9147: LD_INT 10
9149: PPUSH
9150: CALL_OW 241
9154: GO 9139
9156: POP
9157: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9158: LD_ADDR_VAR 0 10
9162: PUSH
9163: LD_INT 22
9165: PUSH
9166: LD_VAR 0 6
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: PUSH
9175: LD_INT 30
9177: PUSH
9178: LD_INT 34
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: PPUSH
9189: CALL_OW 69
9193: ST_TO_ADDR
// if teleport then
9194: LD_VAR 0 10
9198: IFFALSE 9219
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9200: LD_VAR 0 10
9204: PUSH
9205: LD_INT 1
9207: ARRAY
9208: PPUSH
9209: LD_INT 123
9211: PPUSH
9212: LD_INT 122
9214: PPUSH
9215: CALL_OW 243
// hc_importance := 0 ;
9219: LD_ADDR_OWVAR 32
9223: PUSH
9224: LD_INT 0
9226: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9227: LD_ADDR_EXP 60
9231: PUSH
9232: LD_STRING Platonov
9234: PPUSH
9235: CALL_OW 25
9239: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9240: LD_ADDR_EXP 61
9244: PUSH
9245: LD_STRING Yakotich
9247: PPUSH
9248: LD_EXP 1
9252: NOT
9253: PPUSH
9254: LD_STRING 09_
9256: PPUSH
9257: CALL 52862 0 3
9261: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9262: LD_ADDR_EXP 62
9266: PUSH
9267: LD_STRING Gleb
9269: PPUSH
9270: CALL_OW 25
9274: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9275: LD_STRING 03_Cornel
9277: PPUSH
9278: CALL_OW 28
9282: IFFALSE 9330
// begin Bierezov := NewCharacter ( Mikhail ) ;
9284: LD_ADDR_EXP 63
9288: PUSH
9289: LD_STRING Mikhail
9291: PPUSH
9292: CALL_OW 25
9296: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9297: LD_EXP 63
9301: PPUSH
9302: LD_INT 197
9304: PPUSH
9305: LD_INT 111
9307: PPUSH
9308: LD_INT 9
9310: PPUSH
9311: LD_INT 0
9313: PPUSH
9314: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9318: LD_EXP 63
9322: PPUSH
9323: LD_INT 3
9325: PPUSH
9326: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9330: LD_EXP 60
9334: PPUSH
9335: LD_INT 126
9337: PPUSH
9338: CALL_OW 52
// if Yakotich then
9342: LD_EXP 61
9346: IFFALSE 9369
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9348: LD_EXP 61
9352: PPUSH
9353: LD_INT 197
9355: PPUSH
9356: LD_INT 111
9358: PPUSH
9359: LD_INT 9
9361: PPUSH
9362: LD_INT 0
9364: PPUSH
9365: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9369: LD_EXP 62
9373: PPUSH
9374: LD_INT 197
9376: PPUSH
9377: LD_INT 111
9379: PPUSH
9380: LD_INT 9
9382: PPUSH
9383: LD_INT 0
9385: PPUSH
9386: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9390: LD_ADDR_VAR 0 5
9394: PUSH
9395: LD_INT 126
9397: PPUSH
9398: LD_INT 2
9400: PPUSH
9401: LD_STRING zhukov
9403: PPUSH
9404: LD_INT 9
9406: PUSH
9407: LD_INT 10
9409: PUSH
9410: LD_INT 10
9412: PUSH
9413: LD_INT 10
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_OWVAR 67
9426: ARRAY
9427: PPUSH
9428: LD_INT 9000
9430: PUSH
9431: LD_INT 1000
9433: PUSH
9434: LD_INT 300
9436: PUSH
9437: EMPTY
9438: LIST
9439: LIST
9440: LIST
9441: PPUSH
9442: LD_INT 21
9444: PUSH
9445: LD_INT 8
9447: PUSH
9448: LD_INT 13
9450: PUSH
9451: LD_INT 8
9453: PUSH
9454: EMPTY
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: PPUSH
9460: CALL 61523 0 6
9464: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9465: LD_ADDR_EXP 78
9469: PUSH
9470: LD_EXP 78
9474: PPUSH
9475: LD_INT 2
9477: PPUSH
9478: LD_VAR 0 5
9482: PUSH
9483: LD_EXP 61
9487: PUSH
9488: LD_EXP 62
9492: PUSH
9493: LD_EXP 63
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: UNION
9503: PPUSH
9504: CALL_OW 1
9508: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9509: LD_ADDR_VAR 0 4
9513: PUSH
9514: LD_INT 267
9516: PPUSH
9517: CALL_OW 274
9521: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9522: LD_VAR 0 4
9526: PPUSH
9527: LD_INT 1
9529: PPUSH
9530: LD_INT 5000
9532: PPUSH
9533: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9537: LD_VAR 0 4
9541: PPUSH
9542: LD_INT 2
9544: PPUSH
9545: LD_INT 200
9547: PPUSH
9548: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9552: LD_VAR 0 4
9556: PPUSH
9557: LD_INT 3
9559: PPUSH
9560: LD_INT 200
9562: PPUSH
9563: CALL_OW 277
// for i := 1 to 6 do
9567: LD_ADDR_VAR 0 2
9571: PUSH
9572: DOUBLE
9573: LD_INT 1
9575: DEC
9576: ST_TO_ADDR
9577: LD_INT 6
9579: PUSH
9580: FOR_TO
9581: IFFALSE 9664
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
9583: LD_INT 0
9585: PPUSH
9586: LD_INT 8
9588: PUSH
9589: LD_INT 9
9591: PUSH
9592: LD_INT 10
9594: PUSH
9595: LD_INT 10
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: PUSH
9604: LD_OWVAR 67
9608: ARRAY
9609: PPUSH
9610: CALL_OW 381
// un := CreateHuman ;
9614: LD_ADDR_VAR 0 8
9618: PUSH
9619: CALL_OW 44
9623: ST_TO_ADDR
// if i mod 2 = 0 then
9624: LD_VAR 0 2
9628: PUSH
9629: LD_INT 2
9631: MOD
9632: PUSH
9633: LD_INT 0
9635: EQUAL
9636: IFFALSE 9650
// SetClass ( un , class_bazooker ) ;
9638: LD_VAR 0 8
9642: PPUSH
9643: LD_INT 9
9645: PPUSH
9646: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
9650: LD_VAR 0 8
9654: PPUSH
9655: LD_INT 674
9657: PPUSH
9658: CALL_OW 52
// end ;
9662: GO 9580
9664: POP
9665: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
9666: LD_INT 21
9668: PPUSH
9669: LD_INT 3
9671: PPUSH
9672: LD_INT 3
9674: PPUSH
9675: LD_INT 52
9677: PPUSH
9678: LD_INT 100
9680: PPUSH
9681: CALL 57702 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
9685: CALL_OW 45
9689: PPUSH
9690: LD_INT 259
9692: PPUSH
9693: LD_INT 145
9695: PPUSH
9696: LD_INT 3
9698: PPUSH
9699: LD_INT 0
9701: PPUSH
9702: CALL 92704 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
9706: CALL_OW 45
9710: PPUSH
9711: LD_INT 245
9713: PPUSH
9714: LD_INT 139
9716: PPUSH
9717: LD_INT 3
9719: PPUSH
9720: LD_INT 0
9722: PPUSH
9723: CALL 92704 0 5
// behemoths := [ ] ;
9727: LD_ADDR_EXP 64
9731: PUSH
9732: EMPTY
9733: ST_TO_ADDR
// behemothBuilders := [ ] ;
9734: LD_ADDR_EXP 65
9738: PUSH
9739: EMPTY
9740: ST_TO_ADDR
// j := 3 ;
9741: LD_ADDR_VAR 0 3
9745: PUSH
9746: LD_INT 3
9748: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9749: LD_ADDR_VAR 0 2
9753: PUSH
9754: LD_INT 22
9756: PUSH
9757: LD_INT 3
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: PUSH
9764: LD_INT 25
9766: PUSH
9767: LD_INT 3
9769: PUSH
9770: EMPTY
9771: LIST
9772: LIST
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PPUSH
9778: CALL_OW 69
9782: PUSH
9783: FOR_IN
9784: IFFALSE 9834
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9786: LD_ADDR_EXP 65
9790: PUSH
9791: LD_EXP 65
9795: PPUSH
9796: LD_VAR 0 2
9800: PPUSH
9801: CALL 90564 0 2
9805: ST_TO_ADDR
// j := j - 1 ;
9806: LD_ADDR_VAR 0 3
9810: PUSH
9811: LD_VAR 0 3
9815: PUSH
9816: LD_INT 1
9818: MINUS
9819: ST_TO_ADDR
// if j = 0 then
9820: LD_VAR 0 3
9824: PUSH
9825: LD_INT 0
9827: EQUAL
9828: IFFALSE 9832
// break ;
9830: GO 9834
// end ;
9832: GO 9783
9834: POP
9835: POP
// end ;
9836: LD_VAR 0 1
9840: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9841: LD_INT 0
9843: PPUSH
9844: PPUSH
9845: PPUSH
9846: PPUSH
9847: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9848: LD_ADDR_VAR 0 4
9852: PUSH
9853: LD_INT 209
9855: PUSH
9856: LD_INT 149
9858: PUSH
9859: EMPTY
9860: LIST
9861: LIST
9862: PUSH
9863: LD_INT 219
9865: PUSH
9866: LD_INT 154
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: PUSH
9873: LD_INT 223
9875: PUSH
9876: LD_INT 149
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: PUSH
9883: LD_INT 232
9885: PUSH
9886: LD_INT 155
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: LIST
9897: LIST
9898: ST_TO_ADDR
// if not behemothBuilders then
9899: LD_EXP 65
9903: NOT
9904: IFFALSE 9908
// exit ;
9906: GO 10012
// j := 1 ;
9908: LD_ADDR_VAR 0 3
9912: PUSH
9913: LD_INT 1
9915: ST_TO_ADDR
// for i in behemothBuilders do
9916: LD_ADDR_VAR 0 2
9920: PUSH
9921: LD_EXP 65
9925: PUSH
9926: FOR_IN
9927: IFFALSE 10010
// begin if IsInUnit ( i ) then
9929: LD_VAR 0 2
9933: PPUSH
9934: CALL_OW 310
9938: IFFALSE 9949
// ComExitBuilding ( i ) ;
9940: LD_VAR 0 2
9944: PPUSH
9945: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9949: LD_VAR 0 2
9953: PPUSH
9954: LD_INT 37
9956: PPUSH
9957: LD_VAR 0 4
9961: PUSH
9962: LD_VAR 0 3
9966: ARRAY
9967: PUSH
9968: LD_INT 1
9970: ARRAY
9971: PPUSH
9972: LD_VAR 0 4
9976: PUSH
9977: LD_VAR 0 3
9981: ARRAY
9982: PUSH
9983: LD_INT 2
9985: ARRAY
9986: PPUSH
9987: LD_INT 0
9989: PPUSH
9990: CALL_OW 230
// j := j + 1 ;
9994: LD_ADDR_VAR 0 3
9998: PUSH
9999: LD_VAR 0 3
10003: PUSH
10004: LD_INT 1
10006: PLUS
10007: ST_TO_ADDR
// end ;
10008: GO 9926
10010: POP
10011: POP
// end ;
10012: LD_VAR 0 1
10016: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10017: LD_INT 3
10019: PPUSH
10020: CALL 90625 0 1
10024: PUSH
10025: LD_INT 22
10027: PUSH
10028: LD_INT 3
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PUSH
10035: LD_INT 30
10037: PUSH
10038: LD_INT 37
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: PPUSH
10049: CALL_OW 69
10053: NOT
10054: AND
10055: IFFALSE 10241
10057: GO 10059
10059: DISABLE
10060: LD_INT 0
10062: PPUSH
10063: PPUSH
// begin enable ;
10064: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10065: LD_ADDR_VAR 0 2
10069: PUSH
10070: LD_INT 3
10072: PPUSH
10073: CALL 90625 0 1
10077: ST_TO_ADDR
// for i in tmp do
10078: LD_ADDR_VAR 0 1
10082: PUSH
10083: LD_VAR 0 2
10087: PUSH
10088: FOR_IN
10089: IFFALSE 10239
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10091: LD_VAR 0 1
10095: PPUSH
10096: LD_INT 7
10098: PPUSH
10099: CALL_OW 308
10103: PUSH
10104: LD_VAR 0 1
10108: PPUSH
10109: CALL_OW 110
10113: PUSH
10114: LD_INT 2
10116: EQUAL
10117: NOT
10118: AND
10119: IFFALSE 10133
// SetTag ( i , 2 ) ;
10121: LD_VAR 0 1
10125: PPUSH
10126: LD_INT 2
10128: PPUSH
10129: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10133: LD_INT 81
10135: PUSH
10136: LD_INT 3
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: PUSH
10143: LD_INT 91
10145: PUSH
10146: LD_VAR 0 1
10150: PUSH
10151: LD_INT 12
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: LIST
10158: PUSH
10159: EMPTY
10160: LIST
10161: LIST
10162: PPUSH
10163: CALL_OW 69
10167: NOT
10168: PUSH
10169: LD_VAR 0 1
10173: PPUSH
10174: CALL_OW 110
10178: PUSH
10179: LD_INT 2
10181: EQUAL
10182: NOT
10183: AND
10184: IFFALSE 10203
// ComAgressiveMove ( i , 64 , 93 ) else
10186: LD_VAR 0 1
10190: PPUSH
10191: LD_INT 64
10193: PPUSH
10194: LD_INT 93
10196: PPUSH
10197: CALL_OW 114
10201: GO 10237
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10203: LD_VAR 0 1
10207: PPUSH
10208: LD_INT 81
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: EMPTY
10215: LIST
10216: LIST
10217: PPUSH
10218: CALL_OW 69
10222: PPUSH
10223: LD_VAR 0 1
10227: PPUSH
10228: CALL_OW 74
10232: PPUSH
10233: CALL_OW 115
// end ;
10237: GO 10088
10239: POP
10240: POP
// end ;
10241: PPOPN 2
10243: END
// every 9 9$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10244: LD_EXP 2
10248: NOT
10249: IFFALSE 11207
10251: GO 10253
10253: DISABLE
10254: LD_INT 0
10256: PPUSH
10257: PPUSH
10258: PPUSH
10259: PPUSH
10260: PPUSH
// begin enable ;
10261: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10262: LD_INT 22
10264: PUSH
10265: LD_INT 3
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PUSH
10272: LD_INT 30
10274: PUSH
10275: LD_INT 3
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: PPUSH
10286: CALL_OW 69
10290: NOT
10291: IFFALSE 10295
// exit ;
10293: GO 11207
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10295: LD_ADDR_VAR 0 4
10299: PUSH
10300: LD_INT 22
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PUSH
10310: LD_INT 30
10312: PUSH
10313: LD_INT 34
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PPUSH
10324: CALL_OW 69
10328: ST_TO_ADDR
// if Prob ( 40 ) then
10329: LD_INT 40
10331: PPUSH
10332: CALL_OW 13
10336: IFFALSE 10463
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10338: LD_INT 2
10340: PPUSH
10341: LD_INT 22
10343: PUSH
10344: LD_INT 3
10346: PUSH
10347: LD_INT 3
10349: PUSH
10350: LD_INT 49
10352: PUSH
10353: EMPTY
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: PUSH
10359: LD_INT 22
10361: PUSH
10362: LD_INT 3
10364: PUSH
10365: LD_INT 3
10367: PUSH
10368: LD_INT 49
10370: PUSH
10371: EMPTY
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: PUSH
10377: LD_INT 22
10379: PUSH
10380: LD_INT 3
10382: PUSH
10383: LD_INT 3
10385: PUSH
10386: LD_INT 49
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 24
10397: PUSH
10398: LD_INT 3
10400: PUSH
10401: LD_INT 3
10403: PUSH
10404: LD_INT 46
10406: PUSH
10407: EMPTY
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PUSH
10413: LD_INT 24
10415: PUSH
10416: LD_INT 3
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: LD_INT 46
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: LIST
10429: LIST
10430: PUSH
10431: LD_INT 24
10433: PUSH
10434: LD_INT 3
10436: PUSH
10437: LD_INT 3
10439: PUSH
10440: LD_INT 46
10442: PUSH
10443: EMPTY
10444: LIST
10445: LIST
10446: LIST
10447: LIST
10448: PUSH
10449: EMPTY
10450: LIST
10451: LIST
10452: LIST
10453: LIST
10454: LIST
10455: LIST
10456: PPUSH
10457: CALL 46436 0 2
// end else
10461: GO 10586
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10463: LD_INT 2
10465: PPUSH
10466: LD_INT 24
10468: PUSH
10469: LD_INT 3
10471: PUSH
10472: LD_INT 3
10474: PUSH
10475: LD_INT 47
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: PUSH
10484: LD_INT 24
10486: PUSH
10487: LD_INT 3
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 47
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: PUSH
10502: LD_INT 24
10504: PUSH
10505: LD_INT 3
10507: PUSH
10508: LD_INT 3
10510: PUSH
10511: LD_INT 47
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 24
10522: PUSH
10523: LD_INT 3
10525: PUSH
10526: LD_INT 3
10528: PUSH
10529: LD_INT 46
10531: PUSH
10532: EMPTY
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: PUSH
10538: LD_INT 24
10540: PUSH
10541: LD_INT 3
10543: PUSH
10544: LD_INT 3
10546: PUSH
10547: LD_INT 46
10549: PUSH
10550: EMPTY
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: PUSH
10556: LD_INT 24
10558: PUSH
10559: LD_INT 3
10561: PUSH
10562: LD_INT 3
10564: PUSH
10565: LD_INT 46
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: PPUSH
10582: CALL 46436 0 2
// end ; if Difficulty > 1 then
10586: LD_OWVAR 67
10590: PUSH
10591: LD_INT 1
10593: GREATER
10594: IFFALSE 10624
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10596: LD_INT 2
10598: PPUSH
10599: LD_INT 24
10601: PUSH
10602: LD_INT 3
10604: PUSH
10605: LD_INT 3
10607: PUSH
10608: LD_INT 47
10610: PUSH
10611: EMPTY
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: PUSH
10617: EMPTY
10618: LIST
10619: PPUSH
10620: CALL 46436 0 2
// p := 0 ;
10624: LD_ADDR_VAR 0 5
10628: PUSH
10629: LD_INT 0
10631: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10632: LD_INT 35
10634: PPUSH
10635: CALL_OW 67
// p := Inc ( p ) ;
10639: LD_ADDR_VAR 0 5
10643: PUSH
10644: LD_VAR 0 5
10648: PPUSH
10649: CALL 91925 0 1
10653: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 100 ;
10654: LD_INT 2
10656: PPUSH
10657: LD_INT 1
10659: PPUSH
10660: CALL 47854 0 2
10664: PUSH
10665: LD_INT 6
10667: PUSH
10668: LD_INT 7
10670: PUSH
10671: LD_INT 7
10673: PUSH
10674: LD_INT 7
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: LIST
10681: LIST
10682: PUSH
10683: LD_OWVAR 67
10687: ARRAY
10688: GREATEREQUAL
10689: PUSH
10690: LD_VAR 0 5
10694: PUSH
10695: LD_INT 100
10697: GREATER
10698: OR
10699: IFFALSE 10632
// wait ( 0 0$30 ) ;
10701: LD_INT 1050
10703: PPUSH
10704: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10708: LD_ADDR_VAR 0 2
10712: PUSH
10713: LD_INT 2
10715: PPUSH
10716: LD_INT 1
10718: PPUSH
10719: CALL 47854 0 2
10723: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10724: LD_ADDR_EXP 97
10728: PUSH
10729: LD_EXP 97
10733: PPUSH
10734: LD_INT 2
10736: PPUSH
10737: LD_EXP 97
10741: PUSH
10742: LD_INT 2
10744: ARRAY
10745: PUSH
10746: LD_VAR 0 2
10750: DIFF
10751: PPUSH
10752: CALL_OW 1
10756: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10757: LD_ADDR_VAR 0 3
10761: PUSH
10762: LD_INT 0
10764: PPUSH
10765: LD_INT 1
10767: PPUSH
10768: CALL_OW 12
10772: ST_TO_ADDR
// if target then
10773: LD_VAR 0 3
10777: IFFALSE 10905
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10779: LD_ADDR_VAR 0 2
10783: PUSH
10784: LD_VAR 0 2
10788: PPUSH
10789: LD_INT 24
10791: PUSH
10792: LD_INT 250
10794: PUSH
10795: EMPTY
10796: LIST
10797: LIST
10798: PPUSH
10799: CALL_OW 72
10803: ST_TO_ADDR
// for i in tmp do
10804: LD_ADDR_VAR 0 1
10808: PUSH
10809: LD_VAR 0 2
10813: PUSH
10814: FOR_IN
10815: IFFALSE 10855
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10817: LD_VAR 0 1
10821: PPUSH
10822: LD_INT 139
10824: PPUSH
10825: LD_INT 89
10827: PPUSH
10828: CALL_OW 297
10832: PUSH
10833: LD_INT 9
10835: GREATER
10836: IFFALSE 10853
// ComMoveXY ( i , 139 , 89 ) ;
10838: LD_VAR 0 1
10842: PPUSH
10843: LD_INT 139
10845: PPUSH
10846: LD_INT 89
10848: PPUSH
10849: CALL_OW 111
10853: GO 10814
10855: POP
10856: POP
// wait ( 0 0$1 ) ;
10857: LD_INT 35
10859: PPUSH
10860: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10864: LD_VAR 0 2
10868: PPUSH
10869: LD_INT 92
10871: PUSH
10872: LD_INT 139
10874: PUSH
10875: LD_INT 89
10877: PUSH
10878: LD_INT 9
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: LIST
10885: LIST
10886: PPUSH
10887: CALL_OW 72
10891: PUSH
10892: LD_VAR 0 2
10896: PUSH
10897: LD_INT 1
10899: MINUS
10900: GREATEREQUAL
10901: IFFALSE 10779
// end else
10903: GO 11047
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10905: LD_VAR 0 2
10909: PPUSH
10910: LD_VAR 0 4
10914: PUSH
10915: LD_INT 1
10917: ARRAY
10918: PPUSH
10919: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10923: LD_ADDR_VAR 0 2
10927: PUSH
10928: LD_VAR 0 2
10932: PPUSH
10933: LD_INT 24
10935: PUSH
10936: LD_INT 250
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: PPUSH
10943: CALL_OW 72
10947: ST_TO_ADDR
// for i in tmp do
10948: LD_ADDR_VAR 0 1
10952: PUSH
10953: LD_VAR 0 2
10957: PUSH
10958: FOR_IN
10959: IFFALSE 10999
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10961: LD_VAR 0 1
10965: PPUSH
10966: LD_INT 124
10968: PPUSH
10969: LD_INT 139
10971: PPUSH
10972: CALL_OW 297
10976: PUSH
10977: LD_INT 9
10979: GREATER
10980: IFFALSE 10997
// ComMoveXY ( i , 124 , 139 ) ;
10982: LD_VAR 0 1
10986: PPUSH
10987: LD_INT 124
10989: PPUSH
10990: LD_INT 139
10992: PPUSH
10993: CALL_OW 111
10997: GO 10958
10999: POP
11000: POP
// wait ( 0 0$1 ) ;
11001: LD_INT 35
11003: PPUSH
11004: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
11008: LD_VAR 0 2
11012: PPUSH
11013: LD_INT 92
11015: PUSH
11016: LD_INT 124
11018: PUSH
11019: LD_INT 139
11021: PUSH
11022: LD_INT 9
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PPUSH
11031: CALL_OW 72
11035: PUSH
11036: LD_VAR 0 2
11040: PUSH
11041: LD_INT 1
11043: MINUS
11044: GREATEREQUAL
11045: IFFALSE 10923
// end ; repeat wait ( 0 0$1 ) ;
11047: LD_INT 35
11049: PPUSH
11050: CALL_OW 67
// for i in tmp do
11054: LD_ADDR_VAR 0 1
11058: PUSH
11059: LD_VAR 0 2
11063: PUSH
11064: FOR_IN
11065: IFFALSE 11198
// begin if GetLives ( i ) > 251 then
11067: LD_VAR 0 1
11071: PPUSH
11072: CALL_OW 256
11076: PUSH
11077: LD_INT 251
11079: GREATER
11080: IFFALSE 11169
// begin if GetWeapon ( i ) = ru_time_lapser then
11082: LD_VAR 0 1
11086: PPUSH
11087: CALL_OW 264
11091: PUSH
11092: LD_INT 49
11094: EQUAL
11095: IFFALSE 11133
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11097: LD_VAR 0 1
11101: PPUSH
11102: LD_INT 81
11104: PUSH
11105: LD_INT 3
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: PPUSH
11112: CALL_OW 69
11116: PPUSH
11117: LD_VAR 0 1
11121: PPUSH
11122: CALL_OW 74
11126: PPUSH
11127: CALL_OW 112
11131: GO 11167
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11133: LD_VAR 0 1
11137: PPUSH
11138: LD_INT 81
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PPUSH
11148: CALL_OW 69
11152: PPUSH
11153: LD_VAR 0 1
11157: PPUSH
11158: CALL_OW 74
11162: PPUSH
11163: CALL_OW 115
// end else
11167: GO 11196
// if IsDead ( i ) then
11169: LD_VAR 0 1
11173: PPUSH
11174: CALL_OW 301
11178: IFFALSE 11196
// tmp := tmp diff i ;
11180: LD_ADDR_VAR 0 2
11184: PUSH
11185: LD_VAR 0 2
11189: PUSH
11190: LD_VAR 0 1
11194: DIFF
11195: ST_TO_ADDR
// end ;
11196: GO 11064
11198: POP
11199: POP
// until not tmp ;
11200: LD_VAR 0 2
11204: NOT
11205: IFFALSE 11047
// end ;
11207: PPOPN 5
11209: END
// every 30 30$00 trigger not russianDestroyed do
11210: LD_EXP 2
11214: NOT
11215: IFFALSE 11284
11217: GO 11219
11219: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11220: LD_INT 105000
11222: PUSH
11223: LD_INT 84000
11225: PUSH
11226: LD_INT 63000
11228: PUSH
11229: LD_INT 52500
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: PUSH
11238: LD_OWVAR 67
11242: ARRAY
11243: PPUSH
11244: CALL_OW 67
// if russianDestroyed then
11248: LD_EXP 2
11252: IFFALSE 11256
// exit ;
11254: GO 11284
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11256: LD_INT 2
11258: PPUSH
11259: LD_INT 23
11261: PUSH
11262: LD_INT 3
11264: PUSH
11265: LD_INT 1
11267: PUSH
11268: LD_INT 48
11270: PUSH
11271: EMPTY
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: PUSH
11277: EMPTY
11278: LIST
11279: PPUSH
11280: CALL 46436 0 2
// end ; end_of_file
11284: END
// export function CustomEvent ( event ) ; begin
11285: LD_INT 0
11287: PPUSH
// end ;
11288: LD_VAR 0 2
11292: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11293: LD_VAR 0 2
11297: PPUSH
11298: LD_VAR 0 3
11302: PPUSH
11303: LD_INT 15
11305: PPUSH
11306: CALL_OW 309
11310: IFFALSE 11319
// YouLost ( MothContaminate ) ;
11312: LD_STRING MothContaminate
11314: PPUSH
11315: CALL_OW 104
// end ;
11319: PPOPN 3
11321: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11322: LD_VAR 0 2
11326: PPUSH
11327: LD_VAR 0 3
11331: PPUSH
11332: LD_INT 15
11334: PPUSH
11335: CALL_OW 309
11339: IFFALSE 11355
// begin wait ( 0 0$6 ) ;
11341: LD_INT 210
11343: PPUSH
11344: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11348: LD_STRING MothContaminateBomb
11350: PPUSH
11351: CALL_OW 104
// end ; end ;
11355: PPOPN 3
11357: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11358: LD_VAR 0 1
11362: PPUSH
11363: CALL 110588 0 1
// if un = JMM then
11367: LD_VAR 0 1
11371: PUSH
11372: LD_EXP 19
11376: EQUAL
11377: IFFALSE 11388
// begin YouLost ( JMM ) ;
11379: LD_STRING JMM
11381: PPUSH
11382: CALL_OW 104
// exit ;
11386: GO 11517
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11388: LD_VAR 0 1
11392: PPUSH
11393: CALL_OW 255
11397: PUSH
11398: LD_INT 2
11400: EQUAL
11401: PUSH
11402: LD_EXP 18
11406: NOT
11407: AND
11408: IFFALSE 11418
// arabianAttacked := true ;
11410: LD_ADDR_EXP 18
11414: PUSH
11415: LD_INT 1
11417: ST_TO_ADDR
// if un = Powell then
11418: LD_VAR 0 1
11422: PUSH
11423: LD_EXP 55
11427: EQUAL
11428: IFFALSE 11438
// americanDestroyed := true ;
11430: LD_ADDR_EXP 4
11434: PUSH
11435: LD_INT 1
11437: ST_TO_ADDR
// if un = Platonov then
11438: LD_VAR 0 1
11442: PUSH
11443: LD_EXP 60
11447: EQUAL
11448: IFFALSE 11458
// russianDestroyed := true ;
11450: LD_ADDR_EXP 2
11454: PUSH
11455: LD_INT 1
11457: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11458: LD_VAR 0 1
11462: PUSH
11463: LD_INT 22
11465: PUSH
11466: LD_INT 7
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: LD_INT 21
11475: PUSH
11476: LD_INT 2
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: PPUSH
11487: CALL_OW 69
11491: IN
11492: IFFALSE 11508
// vehicleLostCounter := vehicleLostCounter + 1 ;
11494: LD_ADDR_EXP 15
11498: PUSH
11499: LD_EXP 15
11503: PUSH
11504: LD_INT 1
11506: PLUS
11507: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11508: LD_VAR 0 1
11512: PPUSH
11513: CALL 49878 0 1
// end ;
11517: PPOPN 1
11519: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11520: LD_VAR 0 1
11524: PPUSH
11525: LD_VAR 0 2
11529: PPUSH
11530: CALL 52210 0 2
// end ;
11534: PPOPN 2
11536: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11537: LD_VAR 0 1
11541: PPUSH
11542: CALL 51278 0 1
// end ;
11546: PPOPN 1
11548: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11549: LD_VAR 0 1
11553: PUSH
11554: LD_INT 22
11556: PUSH
11557: LD_INT 8
11559: PUSH
11560: EMPTY
11561: LIST
11562: LIST
11563: PUSH
11564: LD_INT 30
11566: PUSH
11567: LD_INT 2
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: LD_INT 23
11576: PUSH
11577: LD_INT 3
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: LIST
11588: PPUSH
11589: CALL_OW 69
11593: IN
11594: IFFALSE 11621
// begin ComUpgrade ( building ) ;
11596: LD_VAR 0 1
11600: PPUSH
11601: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11605: LD_EXP 58
11609: PPUSH
11610: LD_VAR 0 1
11614: PPUSH
11615: CALL 61062 0 2
// exit ;
11619: GO 11630
// end ; MCE_BuildingComplete ( building ) ;
11621: LD_VAR 0 1
11625: PPUSH
11626: CALL 51519 0 1
// end ;
11630: PPOPN 1
11632: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11633: LD_VAR 0 1
11637: PPUSH
11638: LD_VAR 0 2
11642: PPUSH
11643: CALL 49574 0 2
// end ;
11647: PPOPN 2
11649: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11650: LD_VAR 0 1
11654: PPUSH
11655: LD_VAR 0 2
11659: PPUSH
11660: LD_VAR 0 3
11664: PPUSH
11665: LD_VAR 0 4
11669: PPUSH
11670: LD_VAR 0 5
11674: PPUSH
11675: CALL 49194 0 5
// end ;
11679: PPOPN 5
11681: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11682: LD_VAR 0 1
11686: PPUSH
11687: LD_VAR 0 2
11691: PPUSH
11692: CALL 110708 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11696: LD_VAR 0 1
11700: PPUSH
11701: LD_VAR 0 2
11705: PPUSH
11706: CALL 48747 0 2
// end ;
11710: PPOPN 2
11712: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11713: LD_VAR 0 1
11717: PPUSH
11718: LD_VAR 0 2
11722: PPUSH
11723: LD_VAR 0 3
11727: PPUSH
11728: LD_VAR 0 4
11732: PPUSH
11733: CALL 48585 0 4
// end ;
11737: PPOPN 4
11739: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11740: LD_VAR 0 1
11744: PPUSH
11745: LD_VAR 0 2
11749: PPUSH
11750: LD_VAR 0 3
11754: PPUSH
11755: CALL 48360 0 3
// end ;
11759: PPOPN 3
11761: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11762: LD_VAR 0 1
11766: PPUSH
11767: LD_VAR 0 2
11771: PPUSH
11772: CALL 48245 0 2
// end ;
11776: PPOPN 2
11778: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11779: LD_VAR 0 1
11783: PPUSH
11784: LD_VAR 0 2
11788: PPUSH
11789: CALL 52505 0 2
// end ;
11793: PPOPN 2
11795: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
11796: LD_VAR 0 1
11800: PUSH
11801: LD_INT 674
11803: EQUAL
11804: IFFALSE 11826
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
11806: LD_VAR 0 2
11810: PPUSH
11811: LD_INT 227
11813: PPUSH
11814: LD_INT 136
11816: PPUSH
11817: CALL_OW 428
11821: PPUSH
11822: CALL_OW 120
// end ;
11826: PPOPN 2
11828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11829: LD_VAR 0 1
11833: PPUSH
11834: LD_VAR 0 2
11838: PPUSH
11839: LD_VAR 0 3
11843: PPUSH
11844: LD_VAR 0 4
11848: PPUSH
11849: CALL 52721 0 4
// end ;
11853: PPOPN 4
11855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11856: LD_VAR 0 1
11860: PPUSH
11861: LD_VAR 0 2
11865: PPUSH
11866: CALL 48054 0 2
// end ;
11870: PPOPN 2
11872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11873: LD_VAR 0 1
11877: PPUSH
11878: CALL 110692 0 1
// end ; end_of_file
11882: PPOPN 1
11884: END
// export function Action ; begin
11885: LD_INT 0
11887: PPUSH
// InGameOn ;
11888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11892: LD_INT 206
11894: PPUSH
11895: LD_INT 11
11897: PPUSH
11898: CALL_OW 86
// wait ( 0 0$1 ) ;
11902: LD_INT 35
11904: PPUSH
11905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11909: LD_EXP 19
11913: PPUSH
11914: LD_STRING DStart-JMM-JMM-1
11916: PPUSH
11917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11921: LD_EXP 52
11925: PPUSH
11926: LD_STRING DStart-JMM-Bur-1
11928: PPUSH
11929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11933: LD_EXP 19
11937: PPUSH
11938: LD_STRING DStart-JMM-JMM-2
11940: PPUSH
11941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11945: LD_EXP 52
11949: PPUSH
11950: LD_STRING DStart-JMM-Bur-2
11952: PPUSH
11953: CALL_OW 88
// InGameOff ;
11957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11961: LD_STRING MStart
11963: PPUSH
11964: CALL_OW 337
// SaveForQuickRestart ;
11968: CALL_OW 22
// end ;
11972: LD_VAR 0 1
11976: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11977: LD_INT 7
11979: PPUSH
11980: LD_INT 255
11982: PPUSH
11983: LD_INT 219
11985: PPUSH
11986: CALL_OW 293
11990: IFFALSE 12599
11992: GO 11994
11994: DISABLE
11995: LD_INT 0
11997: PPUSH
// begin wait ( 0 0$3 ) ;
11998: LD_INT 105
12000: PPUSH
12001: CALL_OW 67
// alienSpotted := true ;
12005: LD_ADDR_EXP 10
12009: PUSH
12010: LD_INT 1
12012: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12013: LD_ADDR_VAR 0 1
12017: PUSH
12018: LD_INT 22
12020: PUSH
12021: LD_INT 7
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 23
12030: PUSH
12031: LD_INT 3
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 21
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: LD_INT 26
12050: PUSH
12051: LD_INT 1
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: LIST
12062: LIST
12063: PPUSH
12064: CALL_OW 69
12068: PUSH
12069: LD_EXP 52
12073: PUSH
12074: LD_EXP 40
12078: PUSH
12079: LD_EXP 42
12083: PUSH
12084: LD_EXP 43
12088: PUSH
12089: LD_EXP 50
12093: PUSH
12094: LD_EXP 49
12098: PUSH
12099: LD_EXP 44
12103: PUSH
12104: EMPTY
12105: LIST
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: DIFF
12113: ST_TO_ADDR
// DialogueOn ;
12114: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12118: LD_INT 255
12120: PPUSH
12121: LD_INT 219
12123: PPUSH
12124: LD_INT 7
12126: PPUSH
12127: LD_INT 20
12129: NEG
12130: PPUSH
12131: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12135: LD_INT 255
12137: PPUSH
12138: LD_INT 219
12140: PPUSH
12141: CALL_OW 86
// if speaker then
12145: LD_VAR 0 1
12149: IFFALSE 12167
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12151: LD_VAR 0 1
12155: PUSH
12156: LD_INT 1
12158: ARRAY
12159: PPUSH
12160: LD_STRING DAlienBase-RSol1-1
12162: PPUSH
12163: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12167: LD_EXP 19
12171: PPUSH
12172: LD_STRING DAlienBase-JMM-1
12174: PPUSH
12175: CALL_OW 88
// if IsOk ( Burlak ) then
12179: LD_EXP 52
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12209
// begin dwait ( 0 0$1 ) ;
12190: LD_INT 35
12192: PPUSH
12193: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12197: LD_EXP 52
12201: PPUSH
12202: LD_STRING DAlienBase-Bur-1
12204: PPUSH
12205: CALL_OW 88
// end ; if IsOk ( Roth ) then
12209: LD_EXP 20
12213: PPUSH
12214: CALL_OW 302
12218: IFFALSE 12232
// Say ( Roth , DAlienBase-Roth-1 ) ;
12220: LD_EXP 20
12224: PPUSH
12225: LD_STRING DAlienBase-Roth-1
12227: PPUSH
12228: CALL_OW 88
// if IsOk ( Gossudarov ) then
12232: LD_EXP 38
12236: PPUSH
12237: CALL_OW 302
12241: IFFALSE 12257
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12243: LD_EXP 38
12247: PPUSH
12248: LD_STRING DAlienBase-Gos-1
12250: PPUSH
12251: CALL_OW 88
12255: GO 12374
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12257: LD_ADDR_VAR 0 1
12261: PUSH
12262: LD_INT 22
12264: PUSH
12265: LD_INT 7
12267: PUSH
12268: EMPTY
12269: LIST
12270: LIST
12271: PUSH
12272: LD_INT 25
12274: PUSH
12275: LD_INT 4
12277: PUSH
12278: EMPTY
12279: LIST
12280: LIST
12281: PUSH
12282: LD_INT 21
12284: PUSH
12285: LD_INT 1
12287: PUSH
12288: EMPTY
12289: LIST
12290: LIST
12291: PUSH
12292: LD_INT 26
12294: PUSH
12295: LD_INT 1
12297: PUSH
12298: EMPTY
12299: LIST
12300: LIST
12301: PUSH
12302: EMPTY
12303: LIST
12304: LIST
12305: LIST
12306: LIST
12307: PPUSH
12308: CALL_OW 69
12312: PUSH
12313: LD_EXP 20
12317: PUSH
12318: LD_EXP 19
12322: PUSH
12323: LD_EXP 52
12327: PUSH
12328: LD_EXP 40
12332: PUSH
12333: LD_EXP 50
12337: PUSH
12338: LD_EXP 49
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: LIST
12347: LIST
12348: LIST
12349: LIST
12350: DIFF
12351: ST_TO_ADDR
// if speaker then
12352: LD_VAR 0 1
12356: IFFALSE 12374
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12358: LD_VAR 0 1
12362: PUSH
12363: LD_INT 1
12365: ARRAY
12366: PPUSH
12367: LD_STRING DAlienBase-Sci1-1
12369: PPUSH
12370: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12374: LD_INT 255
12376: PPUSH
12377: LD_INT 219
12379: PPUSH
12380: LD_INT 7
12382: PPUSH
12383: CALL_OW 331
// DialogueOff ;
12387: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12391: LD_INT 35
12393: PPUSH
12394: CALL_OW 67
// until IsSelected ( alien ) ;
12398: LD_INT 1
12400: PPUSH
12401: CALL_OW 306
12405: IFFALSE 12391
// if not artifactIResearched or not artifactIIResearched then
12407: LD_EXP 12
12411: NOT
12412: PUSH
12413: LD_EXP 13
12417: NOT
12418: OR
12419: IFFALSE 12599
// begin if IsOk ( Roth ) then
12421: LD_EXP 20
12425: PPUSH
12426: CALL_OW 302
12430: IFFALSE 12446
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12432: LD_EXP 20
12436: PPUSH
12437: LD_STRING DAlieBaseNotReady-Roth-1
12439: PPUSH
12440: CALL_OW 88
12444: GO 12599
// if IsOk ( Gossudarov ) then
12446: LD_EXP 38
12450: PPUSH
12451: CALL_OW 302
12455: IFFALSE 12471
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12457: LD_EXP 38
12461: PPUSH
12462: LD_STRING DAlieBaseNotReady-Gos-1
12464: PPUSH
12465: CALL_OW 88
12469: GO 12599
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12471: LD_ADDR_VAR 0 1
12475: PUSH
12476: LD_INT 22
12478: PUSH
12479: LD_INT 7
12481: PUSH
12482: EMPTY
12483: LIST
12484: LIST
12485: PUSH
12486: LD_INT 23
12488: PUSH
12489: LD_INT 3
12491: PUSH
12492: EMPTY
12493: LIST
12494: LIST
12495: PUSH
12496: LD_INT 25
12498: PUSH
12499: LD_INT 4
12501: PUSH
12502: EMPTY
12503: LIST
12504: LIST
12505: PUSH
12506: LD_INT 21
12508: PUSH
12509: LD_INT 1
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: PUSH
12516: LD_INT 26
12518: PUSH
12519: LD_INT 1
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: LIST
12530: LIST
12531: LIST
12532: PPUSH
12533: CALL_OW 69
12537: PUSH
12538: LD_EXP 20
12542: PUSH
12543: LD_EXP 19
12547: PUSH
12548: LD_EXP 52
12552: PUSH
12553: LD_EXP 40
12557: PUSH
12558: LD_EXP 50
12562: PUSH
12563: LD_EXP 49
12567: PUSH
12568: EMPTY
12569: LIST
12570: LIST
12571: LIST
12572: LIST
12573: LIST
12574: LIST
12575: DIFF
12576: ST_TO_ADDR
// if speaker then
12577: LD_VAR 0 1
12581: IFFALSE 12599
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12583: LD_VAR 0 1
12587: PUSH
12588: LD_INT 1
12590: ARRAY
12591: PPUSH
12592: LD_STRING DAlieBaseNotReady-RSci1-1
12594: PPUSH
12595: CALL_OW 88
// end ; end ; end ;
12599: PPOPN 1
12601: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12602: LD_INT 24
12604: PPUSH
12605: LD_INT 7
12607: PPUSH
12608: CALL_OW 321
12612: PUSH
12613: LD_INT 2
12615: EQUAL
12616: IFFALSE 13307
12618: GO 12620
12620: DISABLE
12621: LD_INT 0
12623: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12624: LD_ADDR_VAR 0 1
12628: PUSH
12629: LD_INT 22
12631: PUSH
12632: LD_INT 7
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: LD_INT 23
12641: PUSH
12642: LD_INT 3
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PUSH
12649: LD_INT 25
12651: PUSH
12652: LD_INT 4
12654: PUSH
12655: EMPTY
12656: LIST
12657: LIST
12658: PUSH
12659: LD_INT 21
12661: PUSH
12662: LD_INT 1
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: PUSH
12669: LD_INT 26
12671: PUSH
12672: LD_INT 1
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: PUSH
12679: EMPTY
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PPUSH
12686: CALL_OW 69
12690: PUSH
12691: LD_EXP 20
12695: PUSH
12696: LD_EXP 19
12700: PUSH
12701: LD_EXP 52
12705: PUSH
12706: LD_EXP 40
12710: PUSH
12711: LD_EXP 50
12715: PUSH
12716: LD_EXP 49
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: DIFF
12729: ST_TO_ADDR
// if not speaker then
12730: LD_VAR 0 1
12734: NOT
12735: IFFALSE 12739
// exit ;
12737: GO 13307
// DialogueOn ;
12739: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12743: LD_VAR 0 1
12747: PUSH
12748: LD_INT 1
12750: ARRAY
12751: PPUSH
12752: LD_STRING DArtefTechnology-RSci1-1
12754: PPUSH
12755: CALL_OW 88
// if IsOk ( Burlak ) then
12759: LD_EXP 52
12763: PPUSH
12764: CALL_OW 302
12768: IFFALSE 12782
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12770: LD_EXP 52
12774: PPUSH
12775: LD_STRING DArtefTechnology-Bur-1
12777: PPUSH
12778: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12782: LD_VAR 0 1
12786: PUSH
12787: LD_INT 1
12789: ARRAY
12790: PPUSH
12791: LD_STRING DArtefTechnology-RSci1-2
12793: PPUSH
12794: CALL_OW 88
// if Denis then
12798: LD_EXP 25
12802: IFFALSE 12819
// speaker := [ Denis ] else
12804: LD_ADDR_VAR 0 1
12808: PUSH
12809: LD_EXP 25
12813: PUSH
12814: EMPTY
12815: LIST
12816: ST_TO_ADDR
12817: GO 12925
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12819: LD_ADDR_VAR 0 1
12823: PUSH
12824: LD_INT 22
12826: PUSH
12827: LD_INT 7
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: PUSH
12834: LD_INT 23
12836: PUSH
12837: LD_INT 1
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: PUSH
12844: LD_INT 25
12846: PUSH
12847: LD_INT 4
12849: PUSH
12850: EMPTY
12851: LIST
12852: LIST
12853: PUSH
12854: LD_INT 21
12856: PUSH
12857: LD_INT 1
12859: PUSH
12860: EMPTY
12861: LIST
12862: LIST
12863: PUSH
12864: LD_INT 26
12866: PUSH
12867: LD_INT 1
12869: PUSH
12870: EMPTY
12871: LIST
12872: LIST
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: PPUSH
12881: CALL_OW 69
12885: PUSH
12886: LD_EXP 20
12890: PUSH
12891: LD_EXP 19
12895: PUSH
12896: LD_EXP 52
12900: PUSH
12901: LD_EXP 40
12905: PUSH
12906: LD_EXP 50
12910: PUSH
12911: LD_EXP 49
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: DIFF
12924: ST_TO_ADDR
// if speaker then
12925: LD_VAR 0 1
12929: IFFALSE 12947
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12931: LD_VAR 0 1
12935: PUSH
12936: LD_INT 1
12938: ARRAY
12939: PPUSH
12940: LD_STRING DArtefTechnology-Sci1-2
12942: PPUSH
12943: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12947: LD_ADDR_VAR 0 1
12951: PUSH
12952: LD_INT 22
12954: PUSH
12955: LD_INT 7
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: PUSH
12962: LD_INT 23
12964: PUSH
12965: LD_INT 3
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 25
12974: PUSH
12975: LD_INT 4
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 21
12984: PUSH
12985: LD_INT 1
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 26
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: LIST
13008: PPUSH
13009: CALL_OW 69
13013: PUSH
13014: LD_EXP 20
13018: PUSH
13019: LD_EXP 19
13023: PUSH
13024: LD_EXP 52
13028: PUSH
13029: LD_EXP 40
13033: PUSH
13034: LD_EXP 50
13038: PUSH
13039: LD_EXP 49
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: LIST
13048: LIST
13049: LIST
13050: LIST
13051: DIFF
13052: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13053: LD_VAR 0 1
13057: PUSH
13058: LD_EXP 9
13062: PUSH
13063: LD_EXP 5
13067: OR
13068: AND
13069: IFFALSE 13303
// begin if arabianDestroyed and IsOk ( Burlak ) then
13071: LD_EXP 5
13075: PUSH
13076: LD_EXP 52
13080: PPUSH
13081: CALL_OW 302
13085: AND
13086: IFFALSE 13102
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13088: LD_EXP 52
13092: PPUSH
13093: LD_STRING DArtefTechnology-Bur-2
13095: PPUSH
13096: CALL_OW 88
13100: GO 13114
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13102: LD_EXP 19
13106: PPUSH
13107: LD_STRING DArtefTechnology-JMM-2
13109: PPUSH
13110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13114: LD_VAR 0 1
13118: PUSH
13119: LD_INT 1
13121: ARRAY
13122: PPUSH
13123: LD_STRING DArtefTechnology-RSci1-3
13125: PPUSH
13126: CALL_OW 88
// if Denis then
13130: LD_EXP 25
13134: IFFALSE 13151
// speaker := [ Denis ] else
13136: LD_ADDR_VAR 0 1
13140: PUSH
13141: LD_EXP 25
13145: PUSH
13146: EMPTY
13147: LIST
13148: ST_TO_ADDR
13149: GO 13257
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13151: LD_ADDR_VAR 0 1
13155: PUSH
13156: LD_INT 22
13158: PUSH
13159: LD_INT 7
13161: PUSH
13162: EMPTY
13163: LIST
13164: LIST
13165: PUSH
13166: LD_INT 23
13168: PUSH
13169: LD_INT 1
13171: PUSH
13172: EMPTY
13173: LIST
13174: LIST
13175: PUSH
13176: LD_INT 25
13178: PUSH
13179: LD_INT 4
13181: PUSH
13182: EMPTY
13183: LIST
13184: LIST
13185: PUSH
13186: LD_INT 21
13188: PUSH
13189: LD_INT 1
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 26
13198: PUSH
13199: LD_INT 1
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: LIST
13210: LIST
13211: LIST
13212: PPUSH
13213: CALL_OW 69
13217: PUSH
13218: LD_EXP 20
13222: PUSH
13223: LD_EXP 19
13227: PUSH
13228: LD_EXP 52
13232: PUSH
13233: LD_EXP 40
13237: PUSH
13238: LD_EXP 50
13242: PUSH
13243: LD_EXP 49
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: DIFF
13256: ST_TO_ADDR
// if speaker then
13257: LD_VAR 0 1
13261: IFFALSE 13303
// if alienSpotted then
13263: LD_EXP 10
13267: IFFALSE 13287
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13269: LD_VAR 0 1
13273: PUSH
13274: LD_INT 1
13276: ARRAY
13277: PPUSH
13278: LD_STRING DArtefTechnology-Sci1-3
13280: PPUSH
13281: CALL_OW 88
13285: GO 13303
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13287: LD_VAR 0 1
13291: PUSH
13292: LD_INT 1
13294: ARRAY
13295: PPUSH
13296: LD_STRING DArtefTechnology-Sci1-3a
13298: PPUSH
13299: CALL_OW 88
// end ; DialogueOff ;
13303: CALL_OW 7
// end ;
13307: PPOPN 1
13309: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13310: LD_EXP 12
13314: IFFALSE 13517
13316: GO 13318
13318: DISABLE
13319: LD_INT 0
13321: PPUSH
// begin if Denis then
13322: LD_EXP 25
13326: IFFALSE 13343
// speaker := [ Denis ] else
13328: LD_ADDR_VAR 0 1
13332: PUSH
13333: LD_EXP 25
13337: PUSH
13338: EMPTY
13339: LIST
13340: ST_TO_ADDR
13341: GO 13449
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13343: LD_ADDR_VAR 0 1
13347: PUSH
13348: LD_INT 22
13350: PUSH
13351: LD_INT 7
13353: PUSH
13354: EMPTY
13355: LIST
13356: LIST
13357: PUSH
13358: LD_INT 23
13360: PUSH
13361: LD_INT 1
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: PUSH
13368: LD_INT 25
13370: PUSH
13371: LD_INT 4
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: PUSH
13378: LD_INT 21
13380: PUSH
13381: LD_INT 1
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: PUSH
13388: LD_INT 26
13390: PUSH
13391: LD_INT 1
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: LIST
13402: LIST
13403: LIST
13404: PPUSH
13405: CALL_OW 69
13409: PUSH
13410: LD_EXP 20
13414: PUSH
13415: LD_EXP 19
13419: PUSH
13420: LD_EXP 52
13424: PUSH
13425: LD_EXP 40
13429: PUSH
13430: LD_EXP 50
13434: PUSH
13435: LD_EXP 49
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: DIFF
13448: ST_TO_ADDR
// if not speaker then
13449: LD_VAR 0 1
13453: NOT
13454: IFFALSE 13458
// exit ;
13456: GO 13517
// DialogueOn ;
13458: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13462: LD_VAR 0 1
13466: PUSH
13467: LD_INT 1
13469: ARRAY
13470: PPUSH
13471: LD_STRING DArtefTechnologyAm-Sci1-1
13473: PPUSH
13474: CALL_OW 88
// if IsOk ( Burlak ) then
13478: LD_EXP 52
13482: PPUSH
13483: CALL_OW 302
13487: IFFALSE 13501
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13489: LD_EXP 52
13493: PPUSH
13494: LD_STRING DArtefTechnologyAm-Bur-1
13496: PPUSH
13497: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13501: LD_EXP 19
13505: PPUSH
13506: LD_STRING DArtefTechnologyAm-JMM-1
13508: PPUSH
13509: CALL_OW 88
// DialogueOff ;
13513: CALL_OW 7
// end ;
13517: PPOPN 1
13519: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13520: LD_EXP 13
13524: IFFALSE 13726
13526: GO 13528
13528: DISABLE
13529: LD_INT 0
13531: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13532: LD_ADDR_VAR 0 1
13536: PUSH
13537: LD_INT 22
13539: PUSH
13540: LD_INT 7
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: LD_INT 23
13549: PUSH
13550: LD_INT 3
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PUSH
13557: LD_INT 25
13559: PUSH
13560: LD_INT 4
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 21
13569: PUSH
13570: LD_INT 1
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PUSH
13577: LD_INT 26
13579: PUSH
13580: LD_INT 1
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: PPUSH
13594: CALL_OW 69
13598: PUSH
13599: LD_EXP 20
13603: PUSH
13604: LD_EXP 19
13608: PUSH
13609: LD_EXP 52
13613: PUSH
13614: LD_EXP 40
13618: PUSH
13619: LD_EXP 50
13623: PUSH
13624: LD_EXP 49
13628: PUSH
13629: EMPTY
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: LIST
13635: LIST
13636: DIFF
13637: ST_TO_ADDR
// if not speaker then
13638: LD_VAR 0 1
13642: NOT
13643: IFFALSE 13647
// exit ;
13645: GO 13726
// DialogueOn ;
13647: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13651: LD_VAR 0 1
13655: PUSH
13656: LD_VAR 0 1
13660: ARRAY
13661: PPUSH
13662: LD_STRING DArtefTechnologyRu-RSci1-1
13664: PPUSH
13665: CALL_OW 88
// if IsOk ( Burlak ) then
13669: LD_EXP 52
13673: PPUSH
13674: CALL_OW 302
13678: IFFALSE 13692
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13680: LD_EXP 52
13684: PPUSH
13685: LD_STRING DArtefTechnologyRu-Bur-1
13687: PPUSH
13688: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13692: LD_VAR 0 1
13696: PUSH
13697: LD_VAR 0 1
13701: ARRAY
13702: PPUSH
13703: LD_STRING DArtefTechnologyRu-RSci1-2
13705: PPUSH
13706: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13710: LD_EXP 19
13714: PPUSH
13715: LD_STRING DArtefTechnologyRu-JMM-1
13717: PPUSH
13718: CALL_OW 88
// DialogueOff ;
13722: CALL_OW 7
// end ;
13726: PPOPN 1
13728: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13729: LD_INT 24
13731: PPUSH
13732: LD_INT 7
13734: PPUSH
13735: CALL_OW 321
13739: PUSH
13740: LD_INT 2
13742: EQUAL
13743: PUSH
13744: LD_INT 1
13746: PPUSH
13747: CALL_OW 255
13751: PUSH
13752: LD_INT 7
13754: EQUAL
13755: AND
13756: IFFALSE 13924
13758: GO 13760
13760: DISABLE
13761: LD_INT 0
13763: PPUSH
// begin if Denis then
13764: LD_EXP 25
13768: IFFALSE 13785
// speaker := [ Denis ] else
13770: LD_ADDR_VAR 0 1
13774: PUSH
13775: LD_EXP 25
13779: PUSH
13780: EMPTY
13781: LIST
13782: ST_TO_ADDR
13783: GO 13891
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13785: LD_ADDR_VAR 0 1
13789: PUSH
13790: LD_INT 22
13792: PUSH
13793: LD_INT 7
13795: PUSH
13796: EMPTY
13797: LIST
13798: LIST
13799: PUSH
13800: LD_INT 23
13802: PUSH
13803: LD_INT 1
13805: PUSH
13806: EMPTY
13807: LIST
13808: LIST
13809: PUSH
13810: LD_INT 25
13812: PUSH
13813: LD_INT 4
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: PUSH
13820: LD_INT 21
13822: PUSH
13823: LD_INT 1
13825: PUSH
13826: EMPTY
13827: LIST
13828: LIST
13829: PUSH
13830: LD_INT 26
13832: PUSH
13833: LD_INT 1
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: PUSH
13840: EMPTY
13841: LIST
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: PPUSH
13847: CALL_OW 69
13851: PUSH
13852: LD_EXP 20
13856: PUSH
13857: LD_EXP 19
13861: PUSH
13862: LD_EXP 52
13866: PUSH
13867: LD_EXP 40
13871: PUSH
13872: LD_EXP 50
13876: PUSH
13877: LD_EXP 49
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: DIFF
13890: ST_TO_ADDR
// if not speaker then
13891: LD_VAR 0 1
13895: NOT
13896: IFFALSE 13900
// exit ;
13898: GO 13924
// DialogueOn ;
13900: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13904: LD_VAR 0 1
13908: PUSH
13909: LD_INT 1
13911: ARRAY
13912: PPUSH
13913: LD_STRING DArtefTechnologyArStart-Sci1-1
13915: PPUSH
13916: CALL_OW 88
// DialogueOff ;
13920: CALL_OW 7
// end ;
13924: PPOPN 1
13926: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13927: LD_EXP 14
13931: IFFALSE 14212
13933: GO 13935
13935: DISABLE
13936: LD_INT 0
13938: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13939: LD_ADDR_VAR 0 1
13943: PUSH
13944: LD_INT 22
13946: PUSH
13947: LD_INT 7
13949: PUSH
13950: EMPTY
13951: LIST
13952: LIST
13953: PUSH
13954: LD_INT 23
13956: PUSH
13957: LD_INT 3
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 25
13966: PUSH
13967: LD_INT 4
13969: PUSH
13970: EMPTY
13971: LIST
13972: LIST
13973: PUSH
13974: LD_INT 21
13976: PUSH
13977: LD_INT 1
13979: PUSH
13980: EMPTY
13981: LIST
13982: LIST
13983: PUSH
13984: LD_INT 26
13986: PUSH
13987: LD_INT 1
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: PPUSH
14001: CALL_OW 69
14005: PUSH
14006: LD_EXP 20
14010: PUSH
14011: LD_EXP 19
14015: PUSH
14016: LD_EXP 52
14020: PUSH
14021: LD_EXP 40
14025: PUSH
14026: LD_EXP 50
14030: PUSH
14031: LD_EXP 49
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: DIFF
14044: ST_TO_ADDR
// if not speaker then
14045: LD_VAR 0 1
14049: NOT
14050: IFFALSE 14054
// exit ;
14052: GO 14212
// DialogueOn ;
14054: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14058: LD_VAR 0 1
14062: PUSH
14063: LD_INT 1
14065: ARRAY
14066: PPUSH
14067: LD_STRING DArtefTechnologyAr-RSci1-1
14069: PPUSH
14070: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14074: LD_EXP 19
14078: PPUSH
14079: LD_STRING DArtefTechnologyAr-JMM-1
14081: PPUSH
14082: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14086: LD_VAR 0 1
14090: PUSH
14091: LD_INT 1
14093: ARRAY
14094: PPUSH
14095: LD_STRING DArtefTechnologyAr-RSci1-2
14097: PPUSH
14098: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14102: LD_EXP 19
14106: PPUSH
14107: LD_STRING DArtefTechnologyAr-JMM-2
14109: PPUSH
14110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14114: LD_VAR 0 1
14118: PUSH
14119: LD_INT 1
14121: ARRAY
14122: PPUSH
14123: LD_STRING DArtefTechnologyAr-RSci1-3
14125: PPUSH
14126: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14130: LD_EXP 19
14134: PPUSH
14135: LD_STRING DArtefTechnologyAr-JMM-3
14137: PPUSH
14138: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14142: LD_VAR 0 1
14146: PUSH
14147: LD_INT 1
14149: ARRAY
14150: PPUSH
14151: LD_STRING DArtefTechnologyAr-RSci1-4
14153: PPUSH
14154: CALL_OW 88
// if IsOk ( Burlak ) then
14158: LD_EXP 52
14162: PPUSH
14163: CALL_OW 302
14167: IFFALSE 14181
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14169: LD_EXP 52
14173: PPUSH
14174: LD_STRING DArtefTechnologyAr-Bur-4
14176: PPUSH
14177: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14181: LD_EXP 19
14185: PPUSH
14186: LD_STRING DArtefTechnologyAr-JMM-4
14188: PPUSH
14189: CALL_OW 88
// DialogueOff ;
14193: CALL_OW 7
// wait ( 0 0$45 ) ;
14197: LD_INT 1575
14199: PPUSH
14200: CALL_OW 67
// spawnOmar := true ;
14204: LD_ADDR_EXP 11
14208: PUSH
14209: LD_INT 1
14211: ST_TO_ADDR
// end ;
14212: PPOPN 1
14214: END
// every 0 0$1 trigger spawnOmar do
14215: LD_EXP 11
14219: IFFALSE 14599
14221: GO 14223
14223: DISABLE
// begin PrepareOmarAli ;
14224: CALL 7368 0 0
// if not HasTask ( Omar ) then
14228: LD_EXP 56
14232: PPUSH
14233: CALL_OW 314
14237: NOT
14238: IFFALSE 14255
// ComMoveXY ( Omar , 252 , 220 ) ;
14240: LD_EXP 56
14244: PPUSH
14245: LD_INT 252
14247: PPUSH
14248: LD_INT 220
14250: PPUSH
14251: CALL_OW 111
// if not Omar then
14255: LD_EXP 56
14259: NOT
14260: IFFALSE 14264
// exit ;
14262: GO 14599
// repeat wait ( 0 0$1 ) ;
14264: LD_INT 35
14266: PPUSH
14267: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14271: LD_EXP 56
14275: PPUSH
14276: CALL_OW 314
14280: NOT
14281: PUSH
14282: LD_EXP 56
14286: PPUSH
14287: LD_INT 252
14289: PPUSH
14290: LD_INT 220
14292: PPUSH
14293: CALL_OW 297
14297: PUSH
14298: LD_INT 6
14300: GREATER
14301: AND
14302: IFFALSE 14319
// ComMoveXY ( Omar , 252 , 220 ) ;
14304: LD_EXP 56
14308: PPUSH
14309: LD_INT 252
14311: PPUSH
14312: LD_INT 220
14314: PPUSH
14315: CALL_OW 111
// until See ( 7 , Omar ) ;
14319: LD_INT 7
14321: PPUSH
14322: LD_EXP 56
14326: PPUSH
14327: CALL_OW 292
14331: IFFALSE 14264
// CenterNowOnUnits ( Omar ) ;
14333: LD_EXP 56
14337: PPUSH
14338: CALL_OW 87
// DialogueOn ;
14342: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14346: LD_EXP 56
14350: PPUSH
14351: LD_STRING DOmar-Omar-1
14353: PPUSH
14354: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14358: LD_EXP 19
14362: PPUSH
14363: LD_STRING DOmar-JMM-1
14365: PPUSH
14366: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14370: LD_EXP 56
14374: PPUSH
14375: LD_STRING DOmar-Omar-2
14377: PPUSH
14378: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14382: LD_EXP 19
14386: PPUSH
14387: LD_STRING DOmar-JMM-2
14389: PPUSH
14390: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14394: LD_EXP 56
14398: PPUSH
14399: LD_STRING DOmar-Omar-3
14401: PPUSH
14402: CALL_OW 88
// if IsOk ( Burlak ) then
14406: LD_EXP 52
14410: PPUSH
14411: CALL_OW 302
14415: IFFALSE 14431
// Say ( Burlak , DOmar-Bur-3 ) else
14417: LD_EXP 52
14421: PPUSH
14422: LD_STRING DOmar-Bur-3
14424: PPUSH
14425: CALL_OW 88
14429: GO 14443
// Say ( JMM , DOmar-JMM-3 ) ;
14431: LD_EXP 19
14435: PPUSH
14436: LD_STRING DOmar-JMM-3
14438: PPUSH
14439: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14443: LD_EXP 56
14447: PPUSH
14448: LD_STRING DOmar-Omar-4
14450: PPUSH
14451: CALL_OW 88
// case Query ( QAccept ) of 1 :
14455: LD_STRING QAccept
14457: PPUSH
14458: CALL_OW 97
14462: PUSH
14463: LD_INT 1
14465: DOUBLE
14466: EQUAL
14467: IFTRUE 14471
14469: GO 14507
14471: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14472: LD_EXP 19
14476: PPUSH
14477: LD_STRING DQrAccept#1-JMM-1
14479: PPUSH
14480: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14484: LD_EXP 56
14488: PPUSH
14489: LD_INT 7
14491: PPUSH
14492: CALL_OW 235
// ComStop ( Omar ) ;
14496: LD_EXP 56
14500: PPUSH
14501: CALL_OW 141
// end ; 2 :
14505: GO 14556
14507: LD_INT 2
14509: DOUBLE
14510: EQUAL
14511: IFTRUE 14515
14513: GO 14555
14515: POP
// begin if IsOk ( Burlak ) then
14516: LD_EXP 52
14520: PPUSH
14521: CALL_OW 302
14525: IFFALSE 14541
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14527: LD_EXP 52
14531: PPUSH
14532: LD_STRING DQrAccept#2-Bur-1
14534: PPUSH
14535: CALL_OW 88
14539: GO 14553
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14541: LD_EXP 19
14545: PPUSH
14546: LD_STRING DQrAccept#2-JMM-1
14548: PPUSH
14549: CALL_OW 88
// end ; end ;
14553: GO 14556
14555: POP
// DialogueOff ;
14556: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14560: LD_EXP 56
14564: PPUSH
14565: CALL_OW 255
14569: PUSH
14570: LD_INT 7
14572: EQUAL
14573: IFFALSE 14584
// begin SetAchievement ( ACH_OMAR ) ;
14575: LD_STRING ACH_OMAR
14577: PPUSH
14578: CALL_OW 543
// exit ;
14582: GO 14599
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14584: LD_EXP 56
14588: PPUSH
14589: LD_INT 202
14591: PPUSH
14592: LD_INT 115
14594: PPUSH
14595: CALL_OW 111
// end ;
14599: END
// every 0 0$1 trigger IsOk ( Omar ) and russianDestroyed do var i ;
14600: LD_EXP 56
14604: PPUSH
14605: CALL_OW 302
14609: PUSH
14610: LD_EXP 2
14614: AND
14615: IFFALSE 15100
14617: GO 14619
14619: DISABLE
14620: LD_INT 0
14622: PPUSH
// begin SetSide ( Omar , 5 ) ;
14623: LD_EXP 56
14627: PPUSH
14628: LD_INT 5
14630: PPUSH
14631: CALL_OW 235
// if IsInUnit ( Omar ) then
14635: LD_EXP 56
14639: PPUSH
14640: CALL_OW 310
14644: IFFALSE 14655
// ComExitVehicle ( Omar ) ;
14646: LD_EXP 56
14650: PPUSH
14651: CALL_OW 121
// if IsInUnit ( Omar ) then
14655: LD_EXP 56
14659: PPUSH
14660: CALL_OW 310
14664: IFFALSE 14675
// ComExitBuilding ( Omar ) ;
14666: LD_EXP 56
14670: PPUSH
14671: CALL_OW 122
// wait ( 0 0$1 ) ;
14675: LD_INT 35
14677: PPUSH
14678: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14682: LD_EXP 56
14686: PPUSH
14687: LD_INT 203
14689: PPUSH
14690: LD_INT 120
14692: PPUSH
14693: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14697: LD_INT 35
14699: PPUSH
14700: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
14704: LD_EXP 56
14708: PPUSH
14709: CALL_OW 306
14713: PUSH
14714: LD_EXP 56
14718: PPUSH
14719: LD_INT 203
14721: PPUSH
14722: LD_INT 120
14724: PPUSH
14725: CALL_OW 297
14729: PUSH
14730: LD_INT 20
14732: LESS
14733: OR
14734: IFFALSE 14697
// DialogueOn ;
14736: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
14740: LD_EXP 56
14744: PPUSH
14745: CALL_OW 250
14749: PPUSH
14750: LD_EXP 56
14754: PPUSH
14755: CALL_OW 251
14759: PPUSH
14760: LD_INT 7
14762: PPUSH
14763: LD_INT 6
14765: NEG
14766: PPUSH
14767: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
14771: LD_EXP 56
14775: PPUSH
14776: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
14780: LD_EXP 19
14784: PPUSH
14785: LD_STRING DOmarContam-JMM-1
14787: PPUSH
14788: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14792: LD_EXP 56
14796: PPUSH
14797: LD_STRING DOmarContam-Omar-1
14799: PPUSH
14800: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14804: LD_EXP 19
14808: PPUSH
14809: LD_STRING DOmarContam-JMM-2
14811: PPUSH
14812: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
14816: LD_EXP 56
14820: PPUSH
14821: CALL_OW 250
14825: PPUSH
14826: LD_EXP 56
14830: PPUSH
14831: CALL_OW 251
14835: PPUSH
14836: LD_INT 7
14838: PPUSH
14839: CALL_OW 331
// DialogueOff ;
14843: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14847: LD_INT 5
14849: PPUSH
14850: LD_INT 7
14852: PPUSH
14853: LD_INT 2
14855: PPUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14863: LD_INT 105
14865: PPUSH
14866: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14870: LD_EXP 56
14874: PPUSH
14875: LD_INT 203
14877: PPUSH
14878: LD_INT 120
14880: PPUSH
14881: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
14885: LD_EXP 56
14889: PPUSH
14890: LD_INT 203
14892: PPUSH
14893: LD_INT 120
14895: PPUSH
14896: CALL_OW 307
14900: IFFALSE 14863
// ComHold ( Omar ) ;
14902: LD_EXP 56
14906: PPUSH
14907: CALL_OW 140
// InGameOn ;
14911: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
14915: LD_INT 203
14917: PPUSH
14918: LD_INT 120
14920: PPUSH
14921: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
14925: LD_INT 203
14927: PPUSH
14928: LD_INT 120
14930: PPUSH
14931: LD_INT 7
14933: PPUSH
14934: LD_INT 30
14936: NEG
14937: PPUSH
14938: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
14942: LD_ADDR_VAR 0 1
14946: PUSH
14947: LD_INT 203
14949: PUSH
14950: LD_INT 120
14952: PUSH
14953: EMPTY
14954: LIST
14955: LIST
14956: PUSH
14957: LD_INT 202
14959: PUSH
14960: LD_INT 125
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PUSH
14967: LD_INT 195
14969: PUSH
14970: LD_INT 117
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: PUSH
14977: LD_INT 216
14979: PUSH
14980: LD_INT 123
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PUSH
14987: LD_INT 224
14989: PUSH
14990: LD_INT 131
14992: PUSH
14993: EMPTY
14994: LIST
14995: LIST
14996: PUSH
14997: LD_INT 212
14999: PUSH
15000: LD_INT 133
15002: PUSH
15003: EMPTY
15004: LIST
15005: LIST
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: PUSH
15015: FOR_IN
15016: IFFALSE 15052
// begin wait ( 0 0$0.5 ) ;
15018: LD_INT 18
15020: PPUSH
15021: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15025: LD_VAR 0 1
15029: PUSH
15030: LD_INT 1
15032: ARRAY
15033: PPUSH
15034: LD_VAR 0 1
15038: PUSH
15039: LD_INT 2
15041: ARRAY
15042: PPUSH
15043: LD_INT 5
15045: PPUSH
15046: CALL_OW 495
// end ;
15050: GO 15015
15052: POP
15053: POP
// KillUnit ( Omar ) ;
15054: LD_EXP 56
15058: PPUSH
15059: CALL_OW 66
// wait ( 0 0$3 ) ;
15063: LD_INT 105
15065: PPUSH
15066: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15070: LD_EXP 19
15074: PPUSH
15075: LD_STRING D16b-JMM-1
15077: PPUSH
15078: CALL_OW 91
// wait ( 0 0$2 ) ;
15082: LD_INT 70
15084: PPUSH
15085: CALL_OW 67
// InGameOff ;
15089: CALL_OW 9
// YouLost ( MothContaminate ) ;
15093: LD_STRING MothContaminate
15095: PPUSH
15096: CALL_OW 104
// end ;
15100: PPOPN 1
15102: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15103: LD_EXP 4
15107: NOT
15108: PUSH
15109: LD_INT 22
15111: PUSH
15112: LD_INT 1
15114: PUSH
15115: EMPTY
15116: LIST
15117: LIST
15118: PUSH
15119: LD_INT 34
15121: PUSH
15122: LD_INT 8
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: PUSH
15129: EMPTY
15130: LIST
15131: LIST
15132: PPUSH
15133: CALL_OW 69
15137: AND
15138: IFFALSE 15257
15140: GO 15142
15142: DISABLE
// begin wait ( 0 0$10 ) ;
15143: LD_INT 350
15145: PPUSH
15146: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15150: LD_EXP 55
15154: PPUSH
15155: CALL_OW 302
15159: NOT
15160: PUSH
15161: LD_INT 22
15163: PUSH
15164: LD_INT 1
15166: PUSH
15167: EMPTY
15168: LIST
15169: LIST
15170: PUSH
15171: LD_INT 34
15173: PUSH
15174: LD_INT 8
15176: PUSH
15177: EMPTY
15178: LIST
15179: LIST
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PPUSH
15185: CALL_OW 69
15189: NOT
15190: OR
15191: IFFALSE 15195
// exit ;
15193: GO 15257
// DialogueOn ;
15195: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15199: LD_EXP 55
15203: PPUSH
15204: LD_STRING DWinAmericans-Pow-1
15206: PPUSH
15207: CALL_OW 94
// if IsOk ( Burlak ) then
15211: LD_EXP 52
15215: PPUSH
15216: CALL_OW 302
15220: IFFALSE 15234
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15222: LD_EXP 52
15226: PPUSH
15227: LD_STRING DWinAmericans-Bur-1
15229: PPUSH
15230: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15234: LD_EXP 19
15238: PPUSH
15239: LD_STRING DWinAmericans-JMM-1
15241: PPUSH
15242: CALL_OW 88
// DialogueOff ;
15246: CALL_OW 7
// YouLost ( AmBomb ) ;
15250: LD_STRING AmBomb
15252: PPUSH
15253: CALL_OW 104
// end ;
15257: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15258: LD_EXP 2
15262: NOT
15263: PUSH
15264: LD_INT 22
15266: PUSH
15267: LD_INT 3
15269: PUSH
15270: EMPTY
15271: LIST
15272: LIST
15273: PUSH
15274: LD_INT 34
15276: PUSH
15277: LD_INT 48
15279: PUSH
15280: EMPTY
15281: LIST
15282: LIST
15283: PUSH
15284: EMPTY
15285: LIST
15286: LIST
15287: PPUSH
15288: CALL_OW 69
15292: AND
15293: IFFALSE 15412
15295: GO 15297
15297: DISABLE
// begin wait ( 0 0$10 ) ;
15298: LD_INT 350
15300: PPUSH
15301: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15305: LD_EXP 60
15309: PPUSH
15310: CALL_OW 302
15314: NOT
15315: PUSH
15316: LD_INT 22
15318: PUSH
15319: LD_INT 3
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: LD_INT 34
15328: PUSH
15329: LD_INT 48
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: PPUSH
15340: CALL_OW 69
15344: NOT
15345: OR
15346: IFFALSE 15350
// exit ;
15348: GO 15412
// DialogueOn ;
15350: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15354: LD_EXP 60
15358: PPUSH
15359: LD_STRING DWinRussians-Pla-1
15361: PPUSH
15362: CALL_OW 94
// if IsOk ( Burlak ) then
15366: LD_EXP 52
15370: PPUSH
15371: CALL_OW 302
15375: IFFALSE 15389
// Say ( Burlak , DWinRussians-Bur-1 ) ;
15377: LD_EXP 52
15381: PPUSH
15382: LD_STRING DWinRussians-Bur-1
15384: PPUSH
15385: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
15389: LD_EXP 19
15393: PPUSH
15394: LD_STRING DWinRussians-JMM-1
15396: PPUSH
15397: CALL_OW 88
// DialogueOff ;
15401: CALL_OW 7
// YouLost ( RuBomb ) ;
15405: LD_STRING RuBomb
15407: PPUSH
15408: CALL_OW 104
// end ;
15412: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
15413: LD_INT 7
15415: PPUSH
15416: LD_INT 22
15418: PUSH
15419: LD_INT 7
15421: PUSH
15422: EMPTY
15423: LIST
15424: LIST
15425: PPUSH
15426: CALL_OW 70
15430: PUSH
15431: LD_EXP 4
15435: NOT
15436: AND
15437: IFFALSE 15466
15439: GO 15441
15441: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
15442: LD_EXP 55
15446: PPUSH
15447: LD_STRING DSurrenderAmericans-Pow-1
15449: PPUSH
15450: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
15454: LD_EXP 19
15458: PPUSH
15459: LD_STRING DSurrenderAmericans-JMM-1
15461: PPUSH
15462: CALL_OW 88
// end ;
15466: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
15467: LD_INT 2
15469: PPUSH
15470: LD_INT 22
15472: PUSH
15473: LD_INT 7
15475: PUSH
15476: EMPTY
15477: LIST
15478: LIST
15479: PPUSH
15480: CALL_OW 70
15484: PUSH
15485: LD_EXP 2
15489: NOT
15490: AND
15491: PUSH
15492: LD_EXP 52
15496: AND
15497: IFFALSE 15526
15499: GO 15501
15501: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
15502: LD_EXP 60
15506: PPUSH
15507: LD_STRING DSurrenderRussians-Pla-1
15509: PPUSH
15510: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15514: LD_EXP 52
15518: PPUSH
15519: LD_STRING DSurrenderRussians-Bur-1
15521: PPUSH
15522: CALL_OW 88
// end ;
15526: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
15527: LD_EXP 4
15531: IFFALSE 15963
15533: GO 15535
15535: DISABLE
15536: LD_INT 0
15538: PPUSH
15539: PPUSH
15540: PPUSH
// begin MC_Kill ( 4 ) ;
15541: LD_INT 4
15543: PPUSH
15544: CALL 22411 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
15548: LD_INT 1
15550: PPUSH
15551: LD_INT 7
15553: PPUSH
15554: LD_INT 1
15556: PPUSH
15557: LD_INT 1
15559: PPUSH
15560: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
15564: LD_ADDR_VAR 0 3
15568: PUSH
15569: LD_INT 22
15571: PUSH
15572: LD_INT 1
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: LD_INT 26
15581: PUSH
15582: LD_INT 1
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: LD_INT 23
15591: PUSH
15592: LD_INT 1
15594: PUSH
15595: EMPTY
15596: LIST
15597: LIST
15598: PUSH
15599: EMPTY
15600: LIST
15601: LIST
15602: LIST
15603: PPUSH
15604: CALL_OW 69
15608: PUSH
15609: LD_EXP 55
15613: PUSH
15614: LD_EXP 27
15618: PUSH
15619: LD_EXP 24
15623: PUSH
15624: LD_EXP 23
15628: PUSH
15629: LD_EXP 30
15633: PUSH
15634: LD_EXP 28
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: LIST
15646: DIFF
15647: ST_TO_ADDR
// if not speaker then
15648: LD_VAR 0 3
15652: NOT
15653: IFFALSE 15693
// begin uc_side := 1 ;
15655: LD_ADDR_OWVAR 20
15659: PUSH
15660: LD_INT 1
15662: ST_TO_ADDR
// uc_nation := 1 ;
15663: LD_ADDR_OWVAR 21
15667: PUSH
15668: LD_INT 1
15670: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
15671: LD_INT 1
15673: PPUSH
15674: LD_INT 0
15676: PPUSH
15677: CALL_OW 381
// speaker := CreateHuman ;
15681: LD_ADDR_VAR 0 3
15685: PUSH
15686: CALL_OW 44
15690: ST_TO_ADDR
// end else
15691: GO 15707
// speaker := speaker [ 1 ] ;
15693: LD_ADDR_VAR 0 3
15697: PUSH
15698: LD_VAR 0 3
15702: PUSH
15703: LD_INT 1
15705: ARRAY
15706: ST_TO_ADDR
// DialogueOn ;
15707: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
15711: LD_VAR 0 3
15715: PPUSH
15716: LD_STRING DSurrenderAmericans-Sol1-1a
15718: PPUSH
15719: CALL_OW 94
// DialogueOff ;
15723: CALL_OW 7
// americanCapitulated := true ;
15727: LD_ADDR_EXP 6
15731: PUSH
15732: LD_INT 1
15734: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15735: LD_ADDR_VAR 0 2
15739: PUSH
15740: LD_INT 22
15742: PUSH
15743: LD_INT 1
15745: PUSH
15746: EMPTY
15747: LIST
15748: LIST
15749: PUSH
15750: LD_INT 21
15752: PUSH
15753: LD_INT 1
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: PUSH
15760: EMPTY
15761: LIST
15762: LIST
15763: PPUSH
15764: CALL_OW 69
15768: PUSH
15769: LD_INT 22
15771: PUSH
15772: LD_INT 1
15774: PUSH
15775: EMPTY
15776: LIST
15777: LIST
15778: PUSH
15779: LD_INT 21
15781: PUSH
15782: LD_INT 2
15784: PUSH
15785: EMPTY
15786: LIST
15787: LIST
15788: PUSH
15789: LD_INT 1
15791: PUSH
15792: EMPTY
15793: LIST
15794: PUSH
15795: EMPTY
15796: LIST
15797: LIST
15798: LIST
15799: PPUSH
15800: CALL_OW 69
15804: ADD
15805: ST_TO_ADDR
// if tmp then
15806: LD_VAR 0 2
15810: IFFALSE 15963
// repeat wait ( 0 0$1 ) ;
15812: LD_INT 35
15814: PPUSH
15815: CALL_OW 67
// for i in tmp do
15819: LD_ADDR_VAR 0 1
15823: PUSH
15824: LD_VAR 0 2
15828: PUSH
15829: FOR_IN
15830: IFFALSE 15912
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15832: LD_VAR 0 1
15836: PPUSH
15837: CALL_OW 310
15841: PUSH
15842: LD_VAR 0 1
15846: PPUSH
15847: CALL_OW 310
15851: PPUSH
15852: CALL_OW 247
15856: PUSH
15857: LD_INT 3
15859: EQUAL
15860: AND
15861: IFFALSE 15872
// ComExitBuilding ( i ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15872: LD_VAR 0 1
15876: PPUSH
15877: LD_INT 122
15879: PPUSH
15880: LD_INT 242
15882: PPUSH
15883: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15887: LD_VAR 0 1
15891: PPUSH
15892: LD_INT 35
15894: PPUSH
15895: CALL_OW 308
15899: IFFALSE 15910
// RemoveUnit ( i ) ;
15901: LD_VAR 0 1
15905: PPUSH
15906: CALL_OW 64
// end ;
15910: GO 15829
15912: POP
15913: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15914: LD_INT 22
15916: PUSH
15917: LD_INT 1
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: PUSH
15924: LD_INT 2
15926: PUSH
15927: LD_INT 21
15929: PUSH
15930: LD_INT 1
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: PUSH
15937: LD_INT 33
15939: PUSH
15940: LD_INT 1
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: LIST
15951: PUSH
15952: EMPTY
15953: LIST
15954: LIST
15955: PPUSH
15956: CALL_OW 69
15960: NOT
15961: IFFALSE 15812
// end ;
15963: PPOPN 3
15965: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15966: LD_EXP 2
15970: IFFALSE 16412
15972: GO 15974
15974: DISABLE
15975: LD_INT 0
15977: PPUSH
15978: PPUSH
15979: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15980: LD_INT 35
15982: PPUSH
15983: CALL_OW 67
// until IsDead ( Yakotich ) ;
15987: LD_EXP 61
15991: PPUSH
15992: CALL_OW 301
15996: IFFALSE 15980
// MC_Kill ( 2 ) ;
15998: LD_INT 2
16000: PPUSH
16001: CALL 22411 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16005: LD_INT 3
16007: PPUSH
16008: LD_INT 7
16010: PPUSH
16011: LD_INT 1
16013: PPUSH
16014: LD_INT 1
16016: PPUSH
16017: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16021: LD_ADDR_VAR 0 3
16025: PUSH
16026: LD_INT 22
16028: PUSH
16029: LD_INT 3
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: PUSH
16036: LD_INT 26
16038: PUSH
16039: LD_INT 1
16041: PUSH
16042: EMPTY
16043: LIST
16044: LIST
16045: PUSH
16046: LD_INT 23
16048: PUSH
16049: LD_INT 3
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: LIST
16060: PPUSH
16061: CALL_OW 69
16065: PUSH
16066: LD_EXP 60
16070: DIFF
16071: ST_TO_ADDR
// if not speaker then
16072: LD_VAR 0 3
16076: NOT
16077: IFFALSE 16117
// begin uc_side := 3 ;
16079: LD_ADDR_OWVAR 20
16083: PUSH
16084: LD_INT 3
16086: ST_TO_ADDR
// uc_nation := 3 ;
16087: LD_ADDR_OWVAR 21
16091: PUSH
16092: LD_INT 3
16094: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16095: LD_INT 1
16097: PPUSH
16098: LD_INT 0
16100: PPUSH
16101: CALL_OW 381
// speaker := CreateHuman ;
16105: LD_ADDR_VAR 0 3
16109: PUSH
16110: CALL_OW 44
16114: ST_TO_ADDR
// end else
16115: GO 16131
// speaker := speaker [ 1 ] ;
16117: LD_ADDR_VAR 0 3
16121: PUSH
16122: LD_VAR 0 3
16126: PUSH
16127: LD_INT 1
16129: ARRAY
16130: ST_TO_ADDR
// DialogueOn ;
16131: CALL_OW 6
// if IsOK ( Burlak ) then
16135: LD_EXP 52
16139: PPUSH
16140: CALL_OW 302
16144: IFFALSE 16160
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16146: LD_VAR 0 3
16150: PPUSH
16151: LD_STRING DSurrenderRussians-RSol1-1
16153: PPUSH
16154: CALL_OW 94
16158: GO 16172
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16160: LD_VAR 0 3
16164: PPUSH
16165: LD_STRING DSurrenderRussians-RSol1-1a
16167: PPUSH
16168: CALL_OW 94
// DialogueOff ;
16172: CALL_OW 7
// russianCapitulated := true ;
16176: LD_ADDR_EXP 7
16180: PUSH
16181: LD_INT 1
16183: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16184: LD_ADDR_VAR 0 2
16188: PUSH
16189: LD_INT 22
16191: PUSH
16192: LD_INT 3
16194: PUSH
16195: EMPTY
16196: LIST
16197: LIST
16198: PUSH
16199: LD_INT 21
16201: PUSH
16202: LD_INT 1
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PPUSH
16213: CALL_OW 69
16217: PUSH
16218: LD_INT 22
16220: PUSH
16221: LD_INT 3
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: PUSH
16228: LD_INT 21
16230: PUSH
16231: LD_INT 2
16233: PUSH
16234: EMPTY
16235: LIST
16236: LIST
16237: PUSH
16238: LD_INT 1
16240: PUSH
16241: EMPTY
16242: LIST
16243: PUSH
16244: EMPTY
16245: LIST
16246: LIST
16247: LIST
16248: PPUSH
16249: CALL_OW 69
16253: ADD
16254: ST_TO_ADDR
// if tmp then
16255: LD_VAR 0 2
16259: IFFALSE 16412
// repeat wait ( 0 0$1 ) ;
16261: LD_INT 35
16263: PPUSH
16264: CALL_OW 67
// for i in tmp do
16268: LD_ADDR_VAR 0 1
16272: PUSH
16273: LD_VAR 0 2
16277: PUSH
16278: FOR_IN
16279: IFFALSE 16361
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16281: LD_VAR 0 1
16285: PPUSH
16286: CALL_OW 310
16290: PUSH
16291: LD_VAR 0 1
16295: PPUSH
16296: CALL_OW 310
16300: PPUSH
16301: CALL_OW 247
16305: PUSH
16306: LD_INT 3
16308: EQUAL
16309: AND
16310: IFFALSE 16321
// ComExitBuilding ( i ) ;
16312: LD_VAR 0 1
16316: PPUSH
16317: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16321: LD_VAR 0 1
16325: PPUSH
16326: LD_INT 154
16328: PPUSH
16329: LD_INT 1
16331: PPUSH
16332: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16336: LD_VAR 0 1
16340: PPUSH
16341: LD_INT 36
16343: PPUSH
16344: CALL_OW 308
16348: IFFALSE 16359
// RemoveUnit ( i ) ;
16350: LD_VAR 0 1
16354: PPUSH
16355: CALL_OW 64
// end ;
16359: GO 16278
16361: POP
16362: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16363: LD_INT 22
16365: PUSH
16366: LD_INT 3
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PUSH
16373: LD_INT 2
16375: PUSH
16376: LD_INT 21
16378: PUSH
16379: LD_INT 1
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 33
16388: PUSH
16389: LD_INT 1
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: LIST
16400: PUSH
16401: EMPTY
16402: LIST
16403: LIST
16404: PPUSH
16405: CALL_OW 69
16409: NOT
16410: IFFALSE 16261
// end ;
16412: PPOPN 3
16414: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
16415: LD_INT 22
16417: PUSH
16418: LD_INT 8
16420: PUSH
16421: EMPTY
16422: LIST
16423: LIST
16424: PUSH
16425: LD_INT 21
16427: PUSH
16428: LD_INT 1
16430: PUSH
16431: EMPTY
16432: LIST
16433: LIST
16434: PUSH
16435: LD_INT 23
16437: PUSH
16438: LD_INT 2
16440: PUSH
16441: EMPTY
16442: LIST
16443: LIST
16444: PUSH
16445: EMPTY
16446: LIST
16447: LIST
16448: LIST
16449: PPUSH
16450: CALL_OW 69
16454: PUSH
16455: LD_INT 18
16457: LESS
16458: PUSH
16459: LD_EXP 58
16463: PPUSH
16464: CALL_OW 301
16468: OR
16469: PUSH
16470: LD_INT 324
16472: PPUSH
16473: CALL_OW 255
16477: PUSH
16478: LD_INT 7
16480: EQUAL
16481: OR
16482: IFFALSE 16495
16484: GO 16486
16486: DISABLE
// legionDestroyed := true ;
16487: LD_ADDR_EXP 3
16491: PUSH
16492: LD_INT 1
16494: ST_TO_ADDR
16495: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
16496: LD_INT 22
16498: PUSH
16499: LD_INT 2
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: LD_INT 21
16508: PUSH
16509: LD_INT 1
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PUSH
16516: LD_INT 23
16518: PUSH
16519: LD_INT 2
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: LIST
16530: PPUSH
16531: CALL_OW 69
16535: PUSH
16536: LD_INT 9
16538: LESS
16539: PUSH
16540: LD_INT 503
16542: PPUSH
16543: CALL_OW 301
16547: OR
16548: PUSH
16549: LD_INT 503
16551: PPUSH
16552: CALL_OW 255
16556: PUSH
16557: LD_INT 7
16559: EQUAL
16560: OR
16561: IFFALSE 16574
16563: GO 16565
16565: DISABLE
// arabianDestroyed := true ;
16566: LD_ADDR_EXP 5
16570: PUSH
16571: LD_INT 1
16573: ST_TO_ADDR
16574: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
16575: LD_EXP 5
16579: IFFALSE 16823
16581: GO 16583
16583: DISABLE
16584: LD_INT 0
16586: PPUSH
16587: PPUSH
// begin MC_Kill ( 1 ) ;
16588: LD_INT 1
16590: PPUSH
16591: CALL 22411 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16595: LD_ADDR_VAR 0 2
16599: PUSH
16600: LD_INT 22
16602: PUSH
16603: LD_INT 2
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PUSH
16610: LD_INT 21
16612: PUSH
16613: LD_INT 1
16615: PUSH
16616: EMPTY
16617: LIST
16618: LIST
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PPUSH
16624: CALL_OW 69
16628: PUSH
16629: LD_INT 22
16631: PUSH
16632: LD_INT 2
16634: PUSH
16635: EMPTY
16636: LIST
16637: LIST
16638: PUSH
16639: LD_INT 21
16641: PUSH
16642: LD_INT 2
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: PUSH
16649: LD_INT 1
16651: PUSH
16652: EMPTY
16653: LIST
16654: PUSH
16655: EMPTY
16656: LIST
16657: LIST
16658: LIST
16659: PPUSH
16660: CALL_OW 69
16664: ADD
16665: ST_TO_ADDR
// if tmp then
16666: LD_VAR 0 2
16670: IFFALSE 16823
// repeat wait ( 0 0$1 ) ;
16672: LD_INT 35
16674: PPUSH
16675: CALL_OW 67
// for i in tmp do
16679: LD_ADDR_VAR 0 1
16683: PUSH
16684: LD_VAR 0 2
16688: PUSH
16689: FOR_IN
16690: IFFALSE 16772
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16692: LD_VAR 0 1
16696: PPUSH
16697: CALL_OW 310
16701: PUSH
16702: LD_VAR 0 1
16706: PPUSH
16707: CALL_OW 310
16711: PPUSH
16712: CALL_OW 247
16716: PUSH
16717: LD_INT 3
16719: EQUAL
16720: AND
16721: IFFALSE 16732
// ComExitBuilding ( i ) ;
16723: LD_VAR 0 1
16727: PPUSH
16728: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
16732: LD_VAR 0 1
16736: PPUSH
16737: LD_INT 254
16739: PPUSH
16740: LD_INT 268
16742: PPUSH
16743: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
16747: LD_VAR 0 1
16751: PPUSH
16752: LD_INT 34
16754: PPUSH
16755: CALL_OW 308
16759: IFFALSE 16770
// RemoveUnit ( i ) ;
16761: LD_VAR 0 1
16765: PPUSH
16766: CALL_OW 64
// end ;
16770: GO 16689
16772: POP
16773: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16774: LD_INT 22
16776: PUSH
16777: LD_INT 2
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: PUSH
16784: LD_INT 2
16786: PUSH
16787: LD_INT 21
16789: PUSH
16790: LD_INT 1
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: LD_INT 33
16799: PUSH
16800: LD_INT 1
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: LIST
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: PPUSH
16816: CALL_OW 69
16820: NOT
16821: IFFALSE 16672
// end ;
16823: PPOPN 2
16825: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16826: LD_EXP 3
16830: IFFALSE 17182
16832: GO 16834
16834: DISABLE
16835: LD_INT 0
16837: PPUSH
16838: PPUSH
// begin MC_Kill ( 3 ) ;
16839: LD_INT 3
16841: PPUSH
16842: CALL 22411 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16846: LD_INT 8
16848: PPUSH
16849: LD_INT 7
16851: PPUSH
16852: LD_INT 1
16854: PPUSH
16855: LD_INT 1
16857: PPUSH
16858: CALL_OW 80
// DialogueOn ;
16862: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16866: LD_EXP 57
16870: PPUSH
16871: LD_STRING D15-Szulc-1
16873: PPUSH
16874: CALL_OW 94
// DialogueOff ;
16878: CALL_OW 7
// legionCapitulated := true ;
16882: LD_ADDR_EXP 8
16886: PUSH
16887: LD_INT 1
16889: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16890: LD_ADDR_VAR 0 1
16894: PUSH
16895: LD_INT 22
16897: PUSH
16898: LD_INT 8
16900: PUSH
16901: EMPTY
16902: LIST
16903: LIST
16904: PUSH
16905: LD_INT 21
16907: PUSH
16908: LD_INT 3
16910: PUSH
16911: EMPTY
16912: LIST
16913: LIST
16914: PUSH
16915: LD_INT 23
16917: PUSH
16918: LD_INT 3
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: PPUSH
16930: CALL_OW 69
16934: PUSH
16935: FOR_IN
16936: IFFALSE 16952
// SetLives ( i , 3 ) ;
16938: LD_VAR 0 1
16942: PPUSH
16943: LD_INT 3
16945: PPUSH
16946: CALL_OW 234
16950: GO 16935
16952: POP
16953: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16954: LD_ADDR_VAR 0 2
16958: PUSH
16959: LD_INT 22
16961: PUSH
16962: LD_INT 8
16964: PUSH
16965: EMPTY
16966: LIST
16967: LIST
16968: PUSH
16969: LD_INT 21
16971: PUSH
16972: LD_INT 1
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PUSH
16979: EMPTY
16980: LIST
16981: LIST
16982: PPUSH
16983: CALL_OW 69
16987: PUSH
16988: LD_INT 22
16990: PUSH
16991: LD_INT 8
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: LD_INT 21
17000: PUSH
17001: LD_INT 2
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PUSH
17008: LD_INT 1
17010: PUSH
17011: EMPTY
17012: LIST
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: LIST
17018: PPUSH
17019: CALL_OW 69
17023: ADD
17024: ST_TO_ADDR
// if tmp then
17025: LD_VAR 0 2
17029: IFFALSE 17182
// repeat wait ( 0 0$1 ) ;
17031: LD_INT 35
17033: PPUSH
17034: CALL_OW 67
// for i in tmp do
17038: LD_ADDR_VAR 0 1
17042: PUSH
17043: LD_VAR 0 2
17047: PUSH
17048: FOR_IN
17049: IFFALSE 17131
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17051: LD_VAR 0 1
17055: PPUSH
17056: CALL_OW 310
17060: PUSH
17061: LD_VAR 0 1
17065: PPUSH
17066: CALL_OW 310
17070: PPUSH
17071: CALL_OW 247
17075: PUSH
17076: LD_INT 3
17078: EQUAL
17079: AND
17080: IFFALSE 17091
// ComExitBuilding ( i ) ;
17082: LD_VAR 0 1
17086: PPUSH
17087: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17091: LD_VAR 0 1
17095: PPUSH
17096: LD_INT 10
17098: PPUSH
17099: LD_INT 1
17101: PPUSH
17102: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17106: LD_VAR 0 1
17110: PPUSH
17111: LD_INT 32
17113: PPUSH
17114: CALL_OW 308
17118: IFFALSE 17129
// RemoveUnit ( i ) ;
17120: LD_VAR 0 1
17124: PPUSH
17125: CALL_OW 64
// end ;
17129: GO 17048
17131: POP
17132: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17133: LD_INT 22
17135: PUSH
17136: LD_INT 8
17138: PUSH
17139: EMPTY
17140: LIST
17141: LIST
17142: PUSH
17143: LD_INT 2
17145: PUSH
17146: LD_INT 21
17148: PUSH
17149: LD_INT 1
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: PUSH
17156: LD_INT 33
17158: PUSH
17159: LD_INT 1
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: LIST
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PPUSH
17175: CALL_OW 69
17179: NOT
17180: IFFALSE 17031
// end ;
17182: PPOPN 2
17184: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17185: LD_EXP 5
17189: NOT
17190: PUSH
17191: LD_OWVAR 1
17195: PUSH
17196: LD_INT 63000
17198: GREATEREQUAL
17199: AND
17200: PUSH
17201: LD_OWVAR 67
17205: PUSH
17206: LD_INT 3
17208: LESS
17209: AND
17210: IFFALSE 17219
17212: GO 17214
17214: DISABLE
// AllianceSupport ;
17215: CALL 4677 0 0
17219: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17220: LD_EXP 4
17224: PUSH
17225: LD_EXP 2
17229: AND
17230: PUSH
17231: LD_EXP 3
17235: AND
17236: PUSH
17237: LD_EXP 5
17241: AND
17242: PUSH
17243: LD_EXP 6
17247: AND
17248: PUSH
17249: LD_EXP 7
17253: AND
17254: PUSH
17255: LD_EXP 8
17259: AND
17260: PUSH
17261: LD_EXP 56
17265: PPUSH
17266: CALL_OW 255
17270: PUSH
17271: LD_INT 5
17273: NONEQUAL
17274: PUSH
17275: LD_EXP 56
17279: PPUSH
17280: CALL_OW 301
17284: OR
17285: PUSH
17286: LD_EXP 56
17290: PPUSH
17291: CALL_OW 305
17295: NOT
17296: OR
17297: AND
17298: IFFALSE 18817
17300: GO 17302
17302: DISABLE
17303: LD_INT 0
17305: PPUSH
17306: PPUSH
// begin wait ( 0 0$5 ) ;
17307: LD_INT 175
17309: PPUSH
17310: CALL_OW 67
// music_class := 5 ;
17314: LD_ADDR_OWVAR 72
17318: PUSH
17319: LD_INT 5
17321: ST_TO_ADDR
// music_nat := 5 ;
17322: LD_ADDR_OWVAR 71
17326: PUSH
17327: LD_INT 5
17329: ST_TO_ADDR
// if vehicleLostCounter < 3 then
17330: LD_EXP 15
17334: PUSH
17335: LD_INT 3
17337: LESS
17338: IFFALSE 17347
// SetAchievement ( ACH_ECONOMY ) ;
17340: LD_STRING ACH_ECONOMY
17342: PPUSH
17343: CALL_OW 543
// if tick < 60 60$00 then
17347: LD_OWVAR 1
17351: PUSH
17352: LD_INT 126000
17354: LESS
17355: IFFALSE 17371
// begin wait ( 3 ) ;
17357: LD_INT 3
17359: PPUSH
17360: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
17364: LD_STRING ACH_ASPEED_19
17366: PPUSH
17367: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
17371: LD_EXP 19
17375: PPUSH
17376: CALL_OW 87
// InGameOn ;
17380: CALL_OW 8
// DialogueOn ;
17384: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
17388: LD_EXP 19
17392: PPUSH
17393: LD_STRING DEnd-JMM-JMM-1
17395: PPUSH
17396: CALL_OW 88
// if Joan then
17400: LD_EXP 34
17404: IFFALSE 17420
// Say ( Joan , DEnd-JMM-Joan-1 ) else
17406: LD_EXP 34
17410: PPUSH
17411: LD_STRING DEnd-JMM-Joan-1
17413: PPUSH
17414: CALL_OW 88
17418: GO 17464
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
17420: LD_EXP 21
17424: PUSH
17425: LD_EXP 21
17429: PPUSH
17430: CALL_OW 255
17434: PUSH
17435: LD_INT 7
17437: EQUAL
17438: AND
17439: PUSH
17440: LD_EXP 21
17444: PPUSH
17445: CALL_OW 305
17449: AND
17450: IFFALSE 17464
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17452: LD_EXP 21
17456: PPUSH
17457: LD_STRING DEnd-JMM-Lisa-1
17459: PPUSH
17460: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
17464: LD_EXP 31
17468: PUSH
17469: LD_EXP 31
17473: PPUSH
17474: CALL_OW 305
17478: AND
17479: IFFALSE 17493
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17481: LD_EXP 31
17485: PPUSH
17486: LD_STRING DEnd-JMM-Frank-1
17488: PPUSH
17489: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
17493: LD_EXP 24
17497: PUSH
17498: LD_EXP 24
17502: PPUSH
17503: CALL_OW 255
17507: PUSH
17508: LD_INT 7
17510: EQUAL
17511: AND
17512: PUSH
17513: LD_EXP 24
17517: PPUSH
17518: CALL_OW 305
17522: AND
17523: IFFALSE 17537
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17525: LD_EXP 24
17529: PPUSH
17530: LD_STRING DEnd-JMM-Cyrus-1
17532: PPUSH
17533: CALL_OW 88
// if Burlak then
17537: LD_EXP 52
17541: IFFALSE 17555
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17543: LD_EXP 52
17547: PPUSH
17548: LD_STRING DEnd-JMM-Bur-1
17550: PPUSH
17551: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
17555: LD_EXP 34
17559: PUSH
17560: LD_EXP 21
17564: AND
17565: PUSH
17566: LD_EXP 21
17570: PPUSH
17571: CALL_OW 255
17575: PUSH
17576: LD_INT 7
17578: EQUAL
17579: AND
17580: PUSH
17581: LD_EXP 21
17585: PPUSH
17586: CALL_OW 305
17590: AND
17591: PUSH
17592: LD_EXP 52
17596: PPUSH
17597: CALL_OW 302
17601: AND
17602: IFFALSE 17616
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
17604: LD_EXP 21
17608: PPUSH
17609: LD_STRING DEnd-Burlak-Lisa-1
17611: PPUSH
17612: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
17616: LD_EXP 53
17620: PUSH
17621: LD_EXP 53
17625: PPUSH
17626: CALL_OW 305
17630: AND
17631: IFFALSE 17645
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
17633: LD_EXP 53
17637: PPUSH
17638: LD_STRING DEnd-JMM-Bel-1
17640: PPUSH
17641: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
17645: LD_EXP 54
17649: PUSH
17650: LD_EXP 54
17654: PPUSH
17655: CALL_OW 305
17659: AND
17660: IFFALSE 17674
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
17662: LD_EXP 54
17666: PPUSH
17667: LD_STRING DEnd-JMM-Gny-1
17669: PPUSH
17670: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
17674: LD_EXP 29
17678: PUSH
17679: LD_EXP 29
17683: PPUSH
17684: CALL_OW 255
17688: PUSH
17689: LD_INT 7
17691: EQUAL
17692: AND
17693: PUSH
17694: LD_EXP 29
17698: PPUSH
17699: CALL_OW 305
17703: AND
17704: IFFALSE 17718
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
17706: LD_EXP 29
17710: PPUSH
17711: LD_STRING DEnd-JMM-Corn-1
17713: PPUSH
17714: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
17718: LD_EXP 22
17722: PUSH
17723: LD_EXP 22
17727: PPUSH
17728: CALL_OW 255
17732: PUSH
17733: LD_INT 7
17735: EQUAL
17736: AND
17737: PUSH
17738: LD_EXP 22
17742: PPUSH
17743: CALL_OW 305
17747: AND
17748: IFFALSE 17762
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17750: LD_EXP 22
17754: PPUSH
17755: LD_STRING DEnd-JMM-Don-1
17757: PPUSH
17758: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
17762: LD_EXP 23
17766: PUSH
17767: LD_EXP 23
17771: PPUSH
17772: CALL_OW 255
17776: PUSH
17777: LD_INT 7
17779: EQUAL
17780: AND
17781: PUSH
17782: LD_EXP 23
17786: PPUSH
17787: CALL_OW 305
17791: AND
17792: IFFALSE 17806
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17794: LD_EXP 23
17798: PPUSH
17799: LD_STRING DEnd-JMM-Bobby-1
17801: PPUSH
17802: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17806: LD_EXP 25
17810: PUSH
17811: LD_EXP 25
17815: PPUSH
17816: CALL_OW 255
17820: PUSH
17821: LD_INT 7
17823: EQUAL
17824: AND
17825: PUSH
17826: LD_EXP 25
17830: PPUSH
17831: CALL_OW 305
17835: AND
17836: IFFALSE 17850
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17838: LD_EXP 25
17842: PPUSH
17843: LD_STRING DEnd-JMM-Den-1
17845: PPUSH
17846: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17850: LD_EXP 27
17854: PUSH
17855: LD_EXP 27
17859: PPUSH
17860: CALL_OW 255
17864: PUSH
17865: LD_INT 7
17867: EQUAL
17868: AND
17869: PUSH
17870: LD_EXP 27
17874: PPUSH
17875: CALL_OW 305
17879: AND
17880: IFFALSE 17894
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17882: LD_EXP 27
17886: PPUSH
17887: LD_STRING DEnd-JMM-Glad-1
17889: PPUSH
17890: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17894: LD_EXP 32
17898: PUSH
17899: LD_EXP 32
17903: PPUSH
17904: CALL_OW 255
17908: PUSH
17909: LD_INT 7
17911: EQUAL
17912: AND
17913: PUSH
17914: LD_EXP 32
17918: PPUSH
17919: CALL_OW 305
17923: AND
17924: IFFALSE 17938
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17926: LD_EXP 32
17930: PPUSH
17931: LD_STRING DEnd-JMM-Yam-1
17933: PPUSH
17934: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17938: LD_EXP 26
17942: PUSH
17943: LD_EXP 26
17947: PPUSH
17948: CALL_OW 255
17952: PUSH
17953: LD_INT 7
17955: EQUAL
17956: AND
17957: PUSH
17958: LD_EXP 26
17962: PPUSH
17963: CALL_OW 305
17967: AND
17968: IFFALSE 17982
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17970: LD_EXP 26
17974: PPUSH
17975: LD_STRING DEnd-JMM-Brown-1
17977: PPUSH
17978: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17982: LD_EXP 36
17986: PUSH
17987: LD_EXP 36
17991: PPUSH
17992: CALL_OW 255
17996: PUSH
17997: LD_INT 7
17999: EQUAL
18000: AND
18001: PUSH
18002: LD_EXP 36
18006: PPUSH
18007: CALL_OW 305
18011: AND
18012: IFFALSE 18026
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18014: LD_EXP 36
18018: PPUSH
18019: LD_STRING DEnd-JMM-Con-1
18021: PPUSH
18022: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
18026: LD_EXP 30
18030: PUSH
18031: LD_EXP 30
18035: PPUSH
18036: CALL_OW 255
18040: PUSH
18041: LD_INT 7
18043: EQUAL
18044: AND
18045: PUSH
18046: LD_EXP 30
18050: PPUSH
18051: CALL_OW 305
18055: AND
18056: IFFALSE 18070
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18058: LD_EXP 30
18062: PPUSH
18063: LD_STRING DEnd-JMM-Gary-1
18065: PPUSH
18066: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18070: LD_EXP 20
18074: PUSH
18075: LD_EXP 20
18079: PPUSH
18080: CALL_OW 305
18084: AND
18085: IFFALSE 18099
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18087: LD_EXP 20
18091: PPUSH
18092: LD_STRING DEnd-JMM-Roth-1
18094: PPUSH
18095: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18099: LD_EXP 33
18103: PUSH
18104: LD_EXP 20
18108: AND
18109: PUSH
18110: LD_EXP 33
18114: PPUSH
18115: CALL_OW 305
18119: AND
18120: IFFALSE 18134
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18122: LD_EXP 33
18126: PPUSH
18127: LD_STRING DEnd-JMM-Sim-1
18129: PPUSH
18130: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18134: LD_EXP 28
18138: PUSH
18139: LD_EXP 28
18143: PPUSH
18144: CALL_OW 255
18148: PUSH
18149: LD_INT 7
18151: EQUAL
18152: AND
18153: PUSH
18154: LD_EXP 28
18158: PPUSH
18159: CALL_OW 305
18163: AND
18164: IFFALSE 18178
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18166: LD_EXP 28
18170: PPUSH
18171: LD_STRING DEnd-JMM-VanH-1
18173: PPUSH
18174: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18178: LD_EXP 42
18182: PUSH
18183: LD_EXP 42
18187: PPUSH
18188: CALL_OW 305
18192: AND
18193: IFFALSE 18207
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18195: LD_EXP 42
18199: PPUSH
18200: LD_STRING DEnd-JMM-Dol-1
18202: PPUSH
18203: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18207: LD_EXP 32
18211: PUSH
18212: LD_EXP 32
18216: PPUSH
18217: CALL_OW 255
18221: PUSH
18222: LD_INT 7
18224: EQUAL
18225: AND
18226: PUSH
18227: LD_EXP 32
18231: PPUSH
18232: CALL_OW 305
18236: AND
18237: IFFALSE 18251
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18239: LD_EXP 32
18243: PPUSH
18244: LD_STRING DEnd-JMM-Yam-1
18246: PPUSH
18247: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18251: LD_EXP 46
18255: PUSH
18256: LD_EXP 46
18260: PPUSH
18261: CALL_OW 305
18265: AND
18266: IFFALSE 18280
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18268: LD_EXP 46
18272: PPUSH
18273: LD_STRING DEnd-JMM-Kap-1
18275: PPUSH
18276: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18280: LD_EXP 49
18284: PUSH
18285: LD_EXP 49
18289: PPUSH
18290: CALL_OW 305
18294: AND
18295: IFFALSE 18309
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18297: LD_EXP 49
18301: PPUSH
18302: LD_STRING DEnd-JMM-Kov-1
18304: PPUSH
18305: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
18309: LD_EXP 44
18313: PUSH
18314: LD_EXP 44
18318: PPUSH
18319: CALL_OW 305
18323: AND
18324: IFFALSE 18338
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18326: LD_EXP 44
18330: PPUSH
18331: LD_STRING DEnd-JMM-Sch-1
18333: PPUSH
18334: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
18338: LD_EXP 40
18342: PUSH
18343: LD_EXP 40
18347: PPUSH
18348: CALL_OW 305
18352: AND
18353: PUSH
18354: LD_EXP 52
18358: PPUSH
18359: CALL_OW 302
18363: AND
18364: IFFALSE 18378
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18366: LD_EXP 40
18370: PPUSH
18371: LD_STRING DEnd-JMM-Tit-1
18373: PPUSH
18374: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
18378: LD_EXP 45
18382: PUSH
18383: LD_EXP 45
18387: PPUSH
18388: CALL_OW 305
18392: AND
18393: IFFALSE 18407
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18395: LD_EXP 45
18399: PPUSH
18400: LD_STRING DEnd-JMM-Obl-1
18402: PPUSH
18403: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
18407: LD_EXP 47
18411: PUSH
18412: LD_EXP 47
18416: PPUSH
18417: CALL_OW 305
18421: AND
18422: IFFALSE 18436
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18424: LD_EXP 47
18428: PPUSH
18429: LD_STRING DEnd-JMM-Lip-1
18431: PPUSH
18432: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
18436: LD_EXP 41
18440: PUSH
18441: LD_EXP 41
18445: PPUSH
18446: CALL_OW 305
18450: AND
18451: PUSH
18452: LD_EXP 52
18456: PPUSH
18457: CALL_OW 302
18461: AND
18462: IFFALSE 18476
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
18464: LD_EXP 41
18468: PPUSH
18469: LD_STRING DEnd-Burlak-Fad-1
18471: PPUSH
18472: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
18476: LD_EXP 48
18480: PUSH
18481: LD_EXP 48
18485: PPUSH
18486: CALL_OW 305
18490: AND
18491: IFFALSE 18505
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
18493: LD_EXP 48
18497: PPUSH
18498: LD_STRING DEnd-Burlak-Ptr-1
18500: PPUSH
18501: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
18505: LD_EXP 50
18509: PUSH
18510: LD_EXP 50
18514: PPUSH
18515: CALL_OW 305
18519: AND
18520: IFFALSE 18534
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
18522: LD_EXP 50
18526: PPUSH
18527: LD_STRING DEnd-Burlak-Kuz-1
18529: PPUSH
18530: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
18534: LD_EXP 39
18538: PUSH
18539: LD_EXP 39
18543: PPUSH
18544: CALL_OW 305
18548: AND
18549: PUSH
18550: LD_EXP 52
18554: PPUSH
18555: CALL_OW 302
18559: AND
18560: IFFALSE 18574
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
18562: LD_EXP 39
18566: PPUSH
18567: LD_STRING DEnd-Burlak-Kir-1
18569: PPUSH
18570: CALL_OW 88
// if Joan then
18574: LD_EXP 34
18578: IFFALSE 18592
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
18580: LD_EXP 34
18584: PPUSH
18585: LD_STRING DEnd-Burlak-Joan-1
18587: PPUSH
18588: CALL_OW 88
// if IsOk ( Burlak ) then
18592: LD_EXP 52
18596: PPUSH
18597: CALL_OW 302
18601: IFFALSE 18615
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
18603: LD_EXP 19
18607: PPUSH
18608: LD_STRING DEnd-Burlak-JMM-1
18610: PPUSH
18611: CALL_OW 88
// dwait ( 0 0$2 ) ;
18615: LD_INT 70
18617: PPUSH
18618: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
18622: LD_EXP 57
18626: PPUSH
18627: LD_STRING DEnd-Szulc
18629: PPUSH
18630: CALL_OW 94
// dwait ( 0 0$1 ) ;
18634: LD_INT 35
18636: PPUSH
18637: CALL_OW 68
// if IsLive ( Burlak ) then
18641: LD_EXP 52
18645: PPUSH
18646: CALL_OW 300
18650: IFFALSE 18662
// med1 := 1 else
18652: LD_ADDR_VAR 0 1
18656: PUSH
18657: LD_INT 1
18659: ST_TO_ADDR
18660: GO 18671
// med1 := - 1 ;
18662: LD_ADDR_VAR 0 1
18666: PUSH
18667: LD_INT 1
18669: NEG
18670: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
18671: LD_EXP 12
18675: PUSH
18676: LD_EXP 13
18680: AND
18681: PUSH
18682: LD_EXP 14
18686: AND
18687: IFFALSE 18699
// med2 := 1 else
18689: LD_ADDR_VAR 0 2
18693: PUSH
18694: LD_INT 1
18696: ST_TO_ADDR
18697: GO 18708
// med2 := - 1 ;
18699: LD_ADDR_VAR 0 2
18703: PUSH
18704: LD_INT 1
18706: NEG
18707: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
18708: LD_STRING Hero
18710: PPUSH
18711: LD_INT 1
18713: PPUSH
18714: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
18718: LD_STRING Artefact
18720: PPUSH
18721: LD_VAR 0 2
18725: PPUSH
18726: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
18730: LD_STRING ReconcileBurlak
18732: PPUSH
18733: LD_VAR 0 1
18737: PPUSH
18738: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
18742: LD_OWVAR 67
18746: PUSH
18747: LD_INT 3
18749: GREATEREQUAL
18750: PUSH
18751: LD_VAR 0 1
18755: PUSH
18756: LD_INT 1
18758: EQUAL
18759: AND
18760: PUSH
18761: LD_VAR 0 2
18765: PUSH
18766: LD_INT 1
18768: EQUAL
18769: AND
18770: IFFALSE 18782
// SetAchievementEX ( ACH_AMER , 19 ) ;
18772: LD_STRING ACH_AMER
18774: PPUSH
18775: LD_INT 19
18777: PPUSH
18778: CALL_OW 564
// GiveMedals ( MAIN ) ;
18782: LD_STRING MAIN
18784: PPUSH
18785: CALL_OW 102
// InGameOff ;
18789: CALL_OW 9
// DialogueOff ;
18793: CALL_OW 7
// music_nat := 1 ;
18797: LD_ADDR_OWVAR 71
18801: PUSH
18802: LD_INT 1
18804: ST_TO_ADDR
// music_class := 4 ;
18805: LD_ADDR_OWVAR 72
18809: PUSH
18810: LD_INT 4
18812: ST_TO_ADDR
// YouWin ;
18813: CALL_OW 103
// end ; end_of_file
18817: PPOPN 2
18819: END
// export function InitNature ; begin
18820: LD_INT 0
18822: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
18823: LD_INT 3
18825: PPUSH
18826: LD_INT 3
18828: PPUSH
18829: LD_INT 2
18831: PPUSH
18832: LD_INT 1
18834: PPUSH
18835: LD_INT 1
18837: PPUSH
18838: LD_INT 0
18840: PPUSH
18841: LD_INT 0
18843: PPUSH
18844: LD_INT 17
18846: PPUSH
18847: LD_INT 0
18849: PPUSH
18850: CALL 87241 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
18854: LD_INT 2
18856: PPUSH
18857: LD_INT 1
18859: PPUSH
18860: LD_INT 1
18862: PPUSH
18863: LD_INT 1
18865: PPUSH
18866: LD_INT 1
18868: PPUSH
18869: LD_INT 0
18871: PPUSH
18872: LD_INT 0
18874: PPUSH
18875: LD_INT 18
18877: PPUSH
18878: LD_INT 0
18880: PPUSH
18881: CALL 87241 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
18885: LD_INT 4
18887: PPUSH
18888: LD_INT 1
18890: PPUSH
18891: LD_INT 2
18893: PPUSH
18894: LD_INT 4
18896: PPUSH
18897: LD_INT 2
18899: PPUSH
18900: LD_INT 1
18902: PPUSH
18903: LD_INT 0
18905: PPUSH
18906: LD_INT 19
18908: PPUSH
18909: LD_INT 0
18911: PPUSH
18912: CALL 87241 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18916: LD_INT 0
18918: PPUSH
18919: LD_INT 0
18921: PPUSH
18922: LD_INT 0
18924: PPUSH
18925: LD_INT 0
18927: PPUSH
18928: LD_INT 0
18930: PPUSH
18931: LD_INT 0
18933: PPUSH
18934: LD_INT 9
18936: PPUSH
18937: LD_INT 0
18939: PPUSH
18940: LD_INT 20
18942: PPUSH
18943: CALL 87241 0 9
// end ; end_of_file
18947: LD_VAR 0 1
18951: RET
// every 0 0$30 do var time ;
18952: GO 18954
18954: DISABLE
18955: LD_INT 0
18957: PPUSH
// begin time := 0 0$30 ;
18958: LD_ADDR_VAR 0 1
18962: PUSH
18963: LD_INT 1050
18965: ST_TO_ADDR
// repeat wait ( time ) ;
18966: LD_VAR 0 1
18970: PPUSH
18971: CALL_OW 67
// if Prob ( 50 ) then
18975: LD_INT 50
18977: PPUSH
18978: CALL_OW 13
18982: IFFALSE 19011
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18984: LD_INT 1
18986: PPUSH
18987: LD_INT 5
18989: PPUSH
18990: CALL_OW 12
18994: PPUSH
18995: LD_INT 106
18997: PPUSH
18998: LD_INT 89
19000: PPUSH
19001: LD_INT 45
19003: PPUSH
19004: LD_INT 1
19006: PPUSH
19007: CALL_OW 56
// time := time + 0 0$3 ;
19011: LD_ADDR_VAR 0 1
19015: PUSH
19016: LD_VAR 0 1
19020: PUSH
19021: LD_INT 105
19023: PLUS
19024: ST_TO_ADDR
// if Prob ( 30 ) then
19025: LD_INT 30
19027: PPUSH
19028: CALL_OW 13
19032: IFFALSE 19078
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
19034: LD_INT 525
19036: PPUSH
19037: LD_INT 735
19039: PPUSH
19040: CALL_OW 12
19044: PPUSH
19045: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19049: LD_INT 1
19051: PPUSH
19052: LD_INT 5
19054: PPUSH
19055: CALL_OW 12
19059: PPUSH
19060: LD_INT 21
19062: PPUSH
19063: LD_INT 26
19065: PPUSH
19066: LD_INT 12
19068: PPUSH
19069: LD_INT 1
19071: PPUSH
19072: CALL_OW 56
// end else
19076: GO 19114
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19078: LD_INT 700
19080: PPUSH
19081: LD_INT 1225
19083: PPUSH
19084: CALL_OW 12
19088: PPUSH
19089: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19093: LD_INT 1
19095: PPUSH
19096: LD_INT 5
19098: PPUSH
19099: CALL_OW 12
19103: PPUSH
19104: LD_INT 14
19106: PPUSH
19107: LD_INT 1
19109: PPUSH
19110: CALL_OW 55
// end ; if Prob ( 50 ) then
19114: LD_INT 50
19116: PPUSH
19117: CALL_OW 13
19121: IFFALSE 19167
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19123: LD_INT 700
19125: PPUSH
19126: LD_INT 1050
19128: PPUSH
19129: CALL_OW 12
19133: PPUSH
19134: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19138: LD_INT 1
19140: PPUSH
19141: LD_INT 5
19143: PPUSH
19144: CALL_OW 12
19148: PPUSH
19149: LD_INT 181
19151: PPUSH
19152: LD_INT 218
19154: PPUSH
19155: LD_INT 16
19157: PPUSH
19158: LD_INT 1
19160: PPUSH
19161: CALL_OW 56
// end else
19165: GO 19239
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19167: LD_INT 350
19169: PPUSH
19170: LD_INT 525
19172: PPUSH
19173: CALL_OW 12
19177: PPUSH
19178: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19182: LD_INT 1
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 13
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19203: LD_INT 350
19205: PPUSH
19206: LD_INT 700
19208: PPUSH
19209: CALL_OW 12
19213: PPUSH
19214: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19218: LD_INT 1
19220: PPUSH
19221: LD_INT 5
19223: PPUSH
19224: CALL_OW 12
19228: PPUSH
19229: LD_INT 33
19231: PPUSH
19232: LD_INT 1
19234: PPUSH
19235: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19239: LD_INT 65
19241: PUSH
19242: LD_INT 62
19244: PUSH
19245: LD_INT 55
19247: PUSH
19248: LD_INT 50
19250: PUSH
19251: EMPTY
19252: LIST
19253: LIST
19254: LIST
19255: LIST
19256: PUSH
19257: LD_OWVAR 67
19261: ARRAY
19262: PPUSH
19263: CALL_OW 13
19267: IFFALSE 19313
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19269: LD_INT 525
19271: PPUSH
19272: LD_INT 875
19274: PPUSH
19275: CALL_OW 12
19279: PPUSH
19280: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19284: LD_INT 1
19286: PPUSH
19287: LD_INT 5
19289: PPUSH
19290: CALL_OW 12
19294: PPUSH
19295: LD_INT 294
19297: PPUSH
19298: LD_INT 211
19300: PPUSH
19301: LD_INT 30
19303: PPUSH
19304: LD_INT 1
19306: PPUSH
19307: CALL_OW 56
// end else
19311: GO 19355
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
19313: LD_INT 420
19315: PPUSH
19316: LD_INT 770
19318: PPUSH
19319: CALL_OW 12
19323: PPUSH
19324: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19328: LD_INT 1
19330: PPUSH
19331: LD_INT 5
19333: PPUSH
19334: CALL_OW 12
19338: PPUSH
19339: LD_INT 294
19341: PPUSH
19342: LD_INT 211
19344: PPUSH
19345: LD_INT 30
19347: PPUSH
19348: LD_INT 1
19350: PPUSH
19351: CALL_OW 56
// end ; if time > 2 2$20 then
19355: LD_VAR 0 1
19359: PUSH
19360: LD_INT 4900
19362: GREATER
19363: IFFALSE 19373
// time := 0 0$50 ;
19365: LD_ADDR_VAR 0 1
19369: PUSH
19370: LD_INT 1750
19372: ST_TO_ADDR
// until false ;
19373: LD_INT 0
19375: IFFALSE 18966
// end ;
19377: PPOPN 1
19379: END
// every 0 0$45 trigger tick < 10 10$00 do
19380: LD_OWVAR 1
19384: PUSH
19385: LD_INT 21000
19387: LESS
19388: IFFALSE 19436
19390: GO 19392
19392: DISABLE
// begin enable ;
19393: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19394: LD_INT 350
19396: PPUSH
19397: LD_INT 700
19399: PPUSH
19400: CALL_OW 12
19404: PPUSH
19405: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
19409: LD_INT 3
19411: PPUSH
19412: LD_INT 5
19414: PPUSH
19415: CALL_OW 12
19419: PPUSH
19420: LD_INT 181
19422: PPUSH
19423: LD_INT 13
19425: PPUSH
19426: LD_INT 20
19428: PPUSH
19429: LD_INT 1
19431: PPUSH
19432: CALL_OW 56
// end ; end_of_file
19436: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
19437: LD_INT 0
19439: PPUSH
// SetArtifactRes ( 7 , true ) ;
19440: LD_INT 7
19442: PPUSH
19443: LD_INT 1
19445: PPUSH
19446: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
19450: LD_ADDR_EXP 66
19454: PUSH
19455: EMPTY
19456: PUSH
19457: EMPTY
19458: PUSH
19459: EMPTY
19460: PUSH
19461: EMPTY
19462: LIST
19463: LIST
19464: LIST
19465: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
19466: LD_ADDR_EXP 67
19470: PUSH
19471: LD_INT 1050
19473: PUSH
19474: LD_OWVAR 67
19478: MUL
19479: PUSH
19480: LD_INT 2800
19482: PUSH
19483: LD_OWVAR 67
19487: MUL
19488: PUSH
19489: LD_INT 1
19491: NEG
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: LIST
19497: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
19498: LD_ADDR_EXP 68
19502: PUSH
19503: LD_INT 10
19505: PUSH
19506: LD_INT 35
19508: PUSH
19509: LD_INT 100
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: LIST
19516: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
19517: LD_ADDR_EXP 69
19521: PUSH
19522: LD_INT 0
19524: PUSH
19525: LD_INT 0
19527: PUSH
19528: LD_INT 0
19530: PUSH
19531: EMPTY
19532: LIST
19533: LIST
19534: LIST
19535: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
19536: LD_ADDR_EXP 71
19540: PUSH
19541: LD_INT 300
19543: PUSH
19544: LD_INT 500
19546: PUSH
19547: LD_INT 800
19549: PUSH
19550: EMPTY
19551: LIST
19552: LIST
19553: LIST
19554: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
19555: LD_ADDR_EXP 72
19559: PUSH
19560: LD_INT 0
19562: PUSH
19563: LD_INT 0
19565: PUSH
19566: LD_INT 0
19568: PUSH
19569: EMPTY
19570: LIST
19571: LIST
19572: LIST
19573: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
19574: LD_ADDR_EXP 73
19578: PUSH
19579: LD_INT 0
19581: PUSH
19582: LD_INT 0
19584: PUSH
19585: LD_INT 0
19587: PUSH
19588: EMPTY
19589: LIST
19590: LIST
19591: LIST
19592: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
19593: LD_ADDR_EXP 70
19597: PUSH
19598: LD_INT 0
19600: PUSH
19601: LD_INT 0
19603: PUSH
19604: LD_INT 0
19606: PUSH
19607: EMPTY
19608: LIST
19609: LIST
19610: LIST
19611: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
19612: LD_ADDR_EXP 74
19616: PUSH
19617: LD_INT 4
19619: PUSH
19620: LD_INT 3
19622: PUSH
19623: LD_INT 1
19625: PUSH
19626: EMPTY
19627: LIST
19628: LIST
19629: LIST
19630: PUSH
19631: LD_INT 5
19633: PUSH
19634: LD_INT 4
19636: PUSH
19637: LD_INT 2
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: LIST
19644: PUSH
19645: LD_INT 6
19647: PUSH
19648: LD_INT 3
19650: PUSH
19651: LD_INT 3
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: LIST
19658: PUSH
19659: EMPTY
19660: LIST
19661: LIST
19662: LIST
19663: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
19664: LD_ADDR_EXP 75
19668: PUSH
19669: LD_INT 0
19671: PUSH
19672: LD_INT 0
19674: PUSH
19675: LD_INT 0
19677: PUSH
19678: EMPTY
19679: LIST
19680: LIST
19681: LIST
19682: ST_TO_ADDR
// end ;
19683: LD_VAR 0 1
19687: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
19688: LD_INT 24
19690: PPUSH
19691: LD_INT 7
19693: PPUSH
19694: CALL_OW 321
19698: PUSH
19699: LD_INT 2
19701: EQUAL
19702: IFFALSE 20628
19704: GO 19706
19706: DISABLE
19707: LD_INT 0
19709: PPUSH
19710: PPUSH
19711: PPUSH
19712: PPUSH
19713: PPUSH
// begin enable ;
19714: ENABLE
// for i = 1 to 3 do
19715: LD_ADDR_VAR 0 1
19719: PUSH
19720: DOUBLE
19721: LD_INT 1
19723: DEC
19724: ST_TO_ADDR
19725: LD_INT 3
19727: PUSH
19728: FOR_TO
19729: IFFALSE 20626
// begin pos := FindArtifact ( i + 2 ) ;
19731: LD_ADDR_VAR 0 2
19735: PUSH
19736: LD_VAR 0 1
19740: PUSH
19741: LD_INT 2
19743: PLUS
19744: PPUSH
19745: CALL_OW 469
19749: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
19750: LD_ADDR_EXP 66
19754: PUSH
19755: LD_EXP 66
19759: PPUSH
19760: LD_VAR 0 1
19764: PPUSH
19765: LD_VAR 0 2
19769: PPUSH
19770: CALL_OW 1
19774: ST_TO_ADDR
// if pos then
19775: LD_VAR 0 2
19779: IFFALSE 20487
// begin case i of 1 :
19781: LD_VAR 0 1
19785: PUSH
19786: LD_INT 1
19788: DOUBLE
19789: EQUAL
19790: IFTRUE 19794
19792: GO 19871
19794: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
19795: LD_ADDR_VAR 0 4
19799: PUSH
19800: LD_INT 22
19802: PUSH
19803: LD_INT 7
19805: PUSH
19806: EMPTY
19807: LIST
19808: LIST
19809: PUSH
19810: LD_INT 23
19812: PUSH
19813: LD_INT 1
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: PUSH
19820: LD_INT 2
19822: PUSH
19823: LD_INT 30
19825: PUSH
19826: LD_INT 8
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: PUSH
19833: LD_INT 30
19835: PUSH
19836: LD_INT 7
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: PUSH
19843: LD_INT 30
19845: PUSH
19846: LD_INT 11
19848: PUSH
19849: EMPTY
19850: LIST
19851: LIST
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: PUSH
19859: EMPTY
19860: LIST
19861: LIST
19862: LIST
19863: PPUSH
19864: CALL_OW 69
19868: ST_TO_ADDR
19869: GO 19979
19871: LD_INT 2
19873: DOUBLE
19874: EQUAL
19875: IFTRUE 19879
19877: GO 19956
19879: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
19880: LD_ADDR_VAR 0 4
19884: PUSH
19885: LD_INT 22
19887: PUSH
19888: LD_INT 7
19890: PUSH
19891: EMPTY
19892: LIST
19893: LIST
19894: PUSH
19895: LD_INT 23
19897: PUSH
19898: LD_INT 3
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PUSH
19905: LD_INT 2
19907: PUSH
19908: LD_INT 30
19910: PUSH
19911: LD_INT 8
19913: PUSH
19914: EMPTY
19915: LIST
19916: LIST
19917: PUSH
19918: LD_INT 30
19920: PUSH
19921: LD_INT 7
19923: PUSH
19924: EMPTY
19925: LIST
19926: LIST
19927: PUSH
19928: LD_INT 30
19930: PUSH
19931: LD_INT 11
19933: PUSH
19934: EMPTY
19935: LIST
19936: LIST
19937: PUSH
19938: EMPTY
19939: LIST
19940: LIST
19941: LIST
19942: LIST
19943: PUSH
19944: EMPTY
19945: LIST
19946: LIST
19947: LIST
19948: PPUSH
19949: CALL_OW 69
19953: ST_TO_ADDR
19954: GO 19979
19956: LD_INT 3
19958: DOUBLE
19959: EQUAL
19960: IFTRUE 19964
19962: GO 19978
19964: POP
// labs := [ alien ] ; end ;
19965: LD_ADDR_VAR 0 4
19969: PUSH
19970: LD_INT 1
19972: PUSH
19973: EMPTY
19974: LIST
19975: ST_TO_ADDR
19976: GO 19979
19978: POP
// if not labs then
19979: LD_VAR 0 4
19983: NOT
19984: IFFALSE 19988
// continue ;
19986: GO 19728
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19988: LD_ADDR_VAR 0 5
19992: PUSH
19993: LD_VAR 0 4
19997: PPUSH
19998: LD_EXP 66
20002: PUSH
20003: LD_VAR 0 1
20007: ARRAY
20008: PUSH
20009: LD_INT 1
20011: ARRAY
20012: PPUSH
20013: LD_EXP 66
20017: PUSH
20018: LD_VAR 0 1
20022: ARRAY
20023: PUSH
20024: LD_INT 2
20026: ARRAY
20027: PPUSH
20028: CALL_OW 73
20032: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
20033: LD_VAR 0 5
20037: NOT
20038: PUSH
20039: LD_VAR 0 5
20043: PUSH
20044: LD_EXP 73
20048: PUSH
20049: LD_VAR 0 1
20053: ARRAY
20054: NONEQUAL
20055: OR
20056: IFFALSE 20161
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20058: LD_INT 7
20060: PPUSH
20061: LD_EXP 74
20065: PUSH
20066: LD_VAR 0 1
20070: ARRAY
20071: PUSH
20072: LD_INT 3
20074: ARRAY
20075: PPUSH
20076: LD_INT 0
20078: PPUSH
20079: LD_EXP 73
20083: PUSH
20084: LD_VAR 0 1
20088: ARRAY
20089: PPUSH
20090: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20094: LD_INT 7
20096: PPUSH
20097: LD_EXP 74
20101: PUSH
20102: LD_VAR 0 1
20106: ARRAY
20107: PUSH
20108: LD_INT 1
20110: ARRAY
20111: PPUSH
20112: LD_INT 0
20114: PPUSH
20115: LD_EXP 73
20119: PUSH
20120: LD_VAR 0 1
20124: ARRAY
20125: PPUSH
20126: CALL_OW 468
// if nearestLab then
20130: LD_VAR 0 5
20134: IFFALSE 20161
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20136: LD_ADDR_EXP 73
20140: PUSH
20141: LD_EXP 73
20145: PPUSH
20146: LD_VAR 0 1
20150: PPUSH
20151: LD_VAR 0 5
20155: PPUSH
20156: CALL_OW 1
20160: ST_TO_ADDR
// end ; if not nearestLab then
20161: LD_VAR 0 5
20165: NOT
20166: IFFALSE 20170
// continue ;
20168: GO 19728
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20170: LD_VAR 0 5
20174: PPUSH
20175: LD_EXP 66
20179: PUSH
20180: LD_VAR 0 1
20184: ARRAY
20185: PUSH
20186: LD_INT 1
20188: ARRAY
20189: PPUSH
20190: LD_EXP 66
20194: PUSH
20195: LD_VAR 0 1
20199: ARRAY
20200: PUSH
20201: LD_INT 2
20203: ARRAY
20204: PPUSH
20205: CALL_OW 297
20209: PUSH
20210: LD_INT 8
20212: LESS
20213: IFFALSE 20410
// begin if not artifactsResearched [ i ] then
20215: LD_EXP 69
20219: PUSH
20220: LD_VAR 0 1
20224: ARRAY
20225: NOT
20226: IFFALSE 20307
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20228: LD_VAR 0 5
20232: PPUSH
20233: CALL_OW 461
20237: PUSH
20238: LD_INT 2
20240: EQUAL
20241: IFFALSE 20275
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20243: LD_INT 7
20245: PPUSH
20246: LD_EXP 74
20250: PUSH
20251: LD_VAR 0 1
20255: ARRAY
20256: PUSH
20257: LD_INT 3
20259: ARRAY
20260: PPUSH
20261: LD_INT 2
20263: PPUSH
20264: LD_VAR 0 5
20268: PPUSH
20269: CALL_OW 468
20273: GO 20305
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20275: LD_INT 7
20277: PPUSH
20278: LD_EXP 74
20282: PUSH
20283: LD_VAR 0 1
20287: ARRAY
20288: PUSH
20289: LD_INT 3
20291: ARRAY
20292: PPUSH
20293: LD_INT 1
20295: PPUSH
20296: LD_VAR 0 5
20300: PPUSH
20301: CALL_OW 468
// end else
20305: GO 20408
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
20307: LD_VAR 0 5
20311: PPUSH
20312: CALL_OW 461
20316: PUSH
20317: LD_INT 2
20319: EQUAL
20320: PUSH
20321: LD_EXP 75
20325: PUSH
20326: LD_VAR 0 1
20330: ARRAY
20331: AND
20332: IFFALSE 20378
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
20334: LD_INT 7
20336: PPUSH
20337: LD_EXP 74
20341: PUSH
20342: LD_VAR 0 1
20346: ARRAY
20347: PUSH
20348: LD_INT 1
20350: ARRAY
20351: PPUSH
20352: LD_EXP 74
20356: PUSH
20357: LD_VAR 0 1
20361: ARRAY
20362: PUSH
20363: LD_INT 2
20365: ARRAY
20366: PPUSH
20367: LD_VAR 0 5
20371: PPUSH
20372: CALL_OW 468
20376: GO 20408
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
20378: LD_INT 7
20380: PPUSH
20381: LD_EXP 74
20385: PUSH
20386: LD_VAR 0 1
20390: ARRAY
20391: PUSH
20392: LD_INT 1
20394: ARRAY
20395: PPUSH
20396: LD_INT 1
20398: PPUSH
20399: LD_VAR 0 5
20403: PPUSH
20404: CALL_OW 468
// end else
20408: GO 20485
// begin if not artifactsResearched [ i ] then
20410: LD_EXP 69
20414: PUSH
20415: LD_VAR 0 1
20419: ARRAY
20420: NOT
20421: IFFALSE 20455
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
20423: LD_INT 7
20425: PPUSH
20426: LD_EXP 74
20430: PUSH
20431: LD_VAR 0 1
20435: ARRAY
20436: PUSH
20437: LD_INT 3
20439: ARRAY
20440: PPUSH
20441: LD_INT 0
20443: PPUSH
20444: LD_VAR 0 5
20448: PPUSH
20449: CALL_OW 468
20453: GO 20485
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
20455: LD_INT 7
20457: PPUSH
20458: LD_EXP 74
20462: PUSH
20463: LD_VAR 0 1
20467: ARRAY
20468: PUSH
20469: LD_INT 1
20471: ARRAY
20472: PPUSH
20473: LD_INT 0
20475: PPUSH
20476: LD_VAR 0 5
20480: PPUSH
20481: CALL_OW 468
// end ; end else
20485: GO 20624
// begin if not artifactsLabs [ i ] then
20487: LD_EXP 73
20491: PUSH
20492: LD_VAR 0 1
20496: ARRAY
20497: NOT
20498: IFFALSE 20502
// continue ;
20500: GO 19728
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20502: LD_INT 7
20504: PPUSH
20505: LD_EXP 74
20509: PUSH
20510: LD_VAR 0 1
20514: ARRAY
20515: PUSH
20516: LD_INT 3
20518: ARRAY
20519: PPUSH
20520: LD_INT 0
20522: PPUSH
20523: LD_EXP 73
20527: PUSH
20528: LD_VAR 0 1
20532: ARRAY
20533: PPUSH
20534: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20538: LD_INT 7
20540: PPUSH
20541: LD_EXP 74
20545: PUSH
20546: LD_VAR 0 1
20550: ARRAY
20551: PUSH
20552: LD_INT 1
20554: ARRAY
20555: PPUSH
20556: LD_INT 0
20558: PPUSH
20559: LD_EXP 73
20563: PUSH
20564: LD_VAR 0 1
20568: ARRAY
20569: PPUSH
20570: CALL_OW 468
// if artifactsLabsWorking [ i ] then
20574: LD_EXP 70
20578: PUSH
20579: LD_VAR 0 1
20583: ARRAY
20584: IFFALSE 20624
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
20586: LD_ADDR_EXP 70
20590: PUSH
20591: LD_EXP 70
20595: PPUSH
20596: LD_VAR 0 1
20600: PPUSH
20601: LD_INT 0
20603: PPUSH
20604: CALL_OW 1
20608: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
20609: LD_EXP 73
20613: PUSH
20614: LD_VAR 0 1
20618: ARRAY
20619: PPUSH
20620: CALL_OW 127
// end ; end ; end ;
20624: GO 19728
20626: POP
20627: POP
// end ;
20628: PPOPN 5
20630: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
20631: LD_INT 0
20633: PPUSH
20634: PPUSH
20635: PPUSH
20636: PPUSH
20637: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
20638: LD_VAR 0 2
20642: PUSH
20643: LD_EXP 74
20647: PUSH
20648: LD_INT 1
20650: ARRAY
20651: PUSH
20652: LD_INT 3
20654: ARRAY
20655: EQUAL
20656: IFFALSE 20779
// begin lab := artifactsLabs [ 1 ] ;
20658: LD_ADDR_VAR 0 6
20662: PUSH
20663: LD_EXP 73
20667: PUSH
20668: LD_INT 1
20670: ARRAY
20671: ST_TO_ADDR
// if not lab then
20672: LD_VAR 0 6
20676: NOT
20677: IFFALSE 20681
// exit ;
20679: GO 21759
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
20681: LD_VAR 0 6
20685: PPUSH
20686: LD_EXP 71
20690: PUSH
20691: LD_INT 1
20693: ARRAY
20694: PPUSH
20695: LD_INT 1
20697: PPUSH
20698: CALL_OW 486
// if artifactsResProgress [ 1 ] then
20702: LD_EXP 72
20706: PUSH
20707: LD_INT 1
20709: ARRAY
20710: IFFALSE 20730
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
20712: LD_VAR 0 6
20716: PPUSH
20717: LD_EXP 72
20721: PUSH
20722: LD_INT 1
20724: ARRAY
20725: PPUSH
20726: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
20730: LD_ADDR_EXP 70
20734: PUSH
20735: LD_EXP 70
20739: PPUSH
20740: LD_INT 1
20742: PPUSH
20743: LD_INT 1
20745: PPUSH
20746: CALL_OW 1
20750: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
20751: LD_INT 7
20753: PPUSH
20754: LD_EXP 74
20758: PUSH
20759: LD_INT 1
20761: ARRAY
20762: PUSH
20763: LD_INT 3
20765: ARRAY
20766: PPUSH
20767: LD_INT 0
20769: PPUSH
20770: LD_VAR 0 6
20774: PPUSH
20775: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
20779: LD_VAR 0 2
20783: PUSH
20784: LD_EXP 74
20788: PUSH
20789: LD_INT 2
20791: ARRAY
20792: PUSH
20793: LD_INT 3
20795: ARRAY
20796: EQUAL
20797: IFFALSE 20920
// begin lab := artifactsLabs [ 2 ] ;
20799: LD_ADDR_VAR 0 6
20803: PUSH
20804: LD_EXP 73
20808: PUSH
20809: LD_INT 2
20811: ARRAY
20812: ST_TO_ADDR
// if not lab then
20813: LD_VAR 0 6
20817: NOT
20818: IFFALSE 20822
// exit ;
20820: GO 21759
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
20822: LD_VAR 0 6
20826: PPUSH
20827: LD_EXP 71
20831: PUSH
20832: LD_INT 2
20834: ARRAY
20835: PPUSH
20836: LD_INT 1
20838: PPUSH
20839: CALL_OW 486
// if artifactsResProgress [ 2 ] then
20843: LD_EXP 72
20847: PUSH
20848: LD_INT 2
20850: ARRAY
20851: IFFALSE 20871
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
20853: LD_VAR 0 6
20857: PPUSH
20858: LD_EXP 72
20862: PUSH
20863: LD_INT 2
20865: ARRAY
20866: PPUSH
20867: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
20871: LD_ADDR_EXP 70
20875: PUSH
20876: LD_EXP 70
20880: PPUSH
20881: LD_INT 2
20883: PPUSH
20884: LD_INT 1
20886: PPUSH
20887: CALL_OW 1
20891: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
20892: LD_INT 7
20894: PPUSH
20895: LD_EXP 74
20899: PUSH
20900: LD_INT 2
20902: ARRAY
20903: PUSH
20904: LD_INT 3
20906: ARRAY
20907: PPUSH
20908: LD_INT 0
20910: PPUSH
20911: LD_VAR 0 6
20915: PPUSH
20916: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20920: LD_VAR 0 2
20924: PUSH
20925: LD_EXP 74
20929: PUSH
20930: LD_INT 3
20932: ARRAY
20933: PUSH
20934: LD_INT 3
20936: ARRAY
20937: EQUAL
20938: IFFALSE 21061
// begin lab := artifactsLabs [ 3 ] ;
20940: LD_ADDR_VAR 0 6
20944: PUSH
20945: LD_EXP 73
20949: PUSH
20950: LD_INT 3
20952: ARRAY
20953: ST_TO_ADDR
// if not lab then
20954: LD_VAR 0 6
20958: NOT
20959: IFFALSE 20963
// exit ;
20961: GO 21759
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20963: LD_VAR 0 6
20967: PPUSH
20968: LD_EXP 71
20972: PUSH
20973: LD_INT 3
20975: ARRAY
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20984: LD_EXP 72
20988: PUSH
20989: LD_INT 3
20991: ARRAY
20992: IFFALSE 21012
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20994: LD_VAR 0 6
20998: PPUSH
20999: LD_EXP 72
21003: PUSH
21004: LD_INT 3
21006: ARRAY
21007: PPUSH
21008: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
21012: LD_ADDR_EXP 70
21016: PUSH
21017: LD_EXP 70
21021: PPUSH
21022: LD_INT 3
21024: PPUSH
21025: LD_INT 1
21027: PPUSH
21028: CALL_OW 1
21032: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
21033: LD_INT 7
21035: PPUSH
21036: LD_EXP 74
21040: PUSH
21041: LD_INT 3
21043: ARRAY
21044: PUSH
21045: LD_INT 3
21047: ARRAY
21048: PPUSH
21049: LD_INT 0
21051: PPUSH
21052: LD_VAR 0 6
21056: PPUSH
21057: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21061: LD_VAR 0 2
21065: PUSH
21066: LD_EXP 74
21070: PUSH
21071: LD_INT 1
21073: ARRAY
21074: PUSH
21075: LD_INT 1
21077: ARRAY
21078: EQUAL
21079: IFFALSE 21237
// begin lab := artifactsLabs [ 1 ] ;
21081: LD_ADDR_VAR 0 6
21085: PUSH
21086: LD_EXP 73
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21095: LD_VAR 0 6
21099: PPUSH
21100: CALL_OW 274
21104: PPUSH
21105: CALL 90794 0 1
21109: PUSH
21110: LD_INT 3
21112: ARRAY
21113: PUSH
21114: LD_EXP 68
21118: PUSH
21119: LD_INT 1
21121: ARRAY
21122: LESS
21123: IFFALSE 21137
// begin HintSpec ( ArtifactCost , 2 ) ;
21125: LD_STRING ArtifactCost
21127: PPUSH
21128: LD_INT 2
21130: PPUSH
21131: CALL_OW 338
// exit ;
21135: GO 21759
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21137: LD_ADDR_EXP 75
21141: PUSH
21142: LD_EXP 75
21146: PPUSH
21147: LD_INT 1
21149: PPUSH
21150: LD_INT 0
21152: PPUSH
21153: CALL_OW 1
21157: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21158: LD_VAR 0 3
21162: PPUSH
21163: LD_VAR 0 4
21167: PPUSH
21168: LD_INT 7
21170: PPUSH
21171: LD_INT 12
21173: NEG
21174: PPUSH
21175: CALL_OW 330
// wait ( 0 0$30 ) ;
21179: LD_INT 1050
21181: PPUSH
21182: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21186: LD_VAR 0 3
21190: PPUSH
21191: LD_VAR 0 4
21195: PPUSH
21196: LD_INT 7
21198: PPUSH
21199: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21203: LD_EXP 67
21207: PUSH
21208: LD_INT 1
21210: ARRAY
21211: PPUSH
21212: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21216: LD_ADDR_EXP 75
21220: PUSH
21221: LD_EXP 75
21225: PPUSH
21226: LD_INT 1
21228: PPUSH
21229: LD_INT 1
21231: PPUSH
21232: CALL_OW 1
21236: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
21237: LD_VAR 0 2
21241: PUSH
21242: LD_EXP 74
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PUSH
21251: LD_INT 1
21253: ARRAY
21254: EQUAL
21255: IFFALSE 21492
// begin lab := artifactsLabs [ 2 ] ;
21257: LD_ADDR_VAR 0 6
21261: PUSH
21262: LD_EXP 73
21266: PUSH
21267: LD_INT 2
21269: ARRAY
21270: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
21271: LD_VAR 0 3
21275: PUSH
21276: LD_INT 81
21278: PUSH
21279: LD_INT 7
21281: PUSH
21282: EMPTY
21283: LIST
21284: LIST
21285: PUSH
21286: LD_INT 2
21288: PUSH
21289: LD_INT 32
21291: PUSH
21292: LD_INT 3
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: PUSH
21299: LD_INT 30
21301: PUSH
21302: LD_INT 28
21304: PUSH
21305: EMPTY
21306: LIST
21307: LIST
21308: PUSH
21309: LD_INT 30
21311: PUSH
21312: LD_INT 30
21314: PUSH
21315: EMPTY
21316: LIST
21317: LIST
21318: PUSH
21319: LD_INT 35
21321: PUSH
21322: LD_INT 49
21324: PUSH
21325: EMPTY
21326: LIST
21327: LIST
21328: PUSH
21329: LD_INT 34
21331: PUSH
21332: LD_INT 49
21334: PUSH
21335: EMPTY
21336: LIST
21337: LIST
21338: PUSH
21339: LD_INT 30
21341: PUSH
21342: LD_INT 21
21344: PUSH
21345: EMPTY
21346: LIST
21347: LIST
21348: PUSH
21349: EMPTY
21350: LIST
21351: LIST
21352: LIST
21353: LIST
21354: LIST
21355: LIST
21356: LIST
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: PPUSH
21362: CALL_OW 69
21366: IN
21367: NOT
21368: IFFALSE 21372
// exit ;
21370: GO 21759
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
21372: LD_VAR 0 6
21376: PPUSH
21377: CALL_OW 274
21381: PPUSH
21382: CALL 90794 0 1
21386: PUSH
21387: LD_INT 3
21389: ARRAY
21390: PUSH
21391: LD_EXP 68
21395: PUSH
21396: LD_INT 2
21398: ARRAY
21399: LESS
21400: IFFALSE 21414
// begin HintSpec ( ArtifactCost , 2 ) ;
21402: LD_STRING ArtifactCost
21404: PPUSH
21405: LD_INT 2
21407: PPUSH
21408: CALL_OW 338
// exit ;
21412: GO 21759
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
21414: LD_ADDR_EXP 75
21418: PUSH
21419: LD_EXP 75
21423: PPUSH
21424: LD_INT 2
21426: PPUSH
21427: LD_INT 0
21429: PPUSH
21430: CALL_OW 1
21434: ST_TO_ADDR
// KillUnit ( x ) ;
21435: LD_VAR 0 3
21439: PPUSH
21440: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
21444: LD_ADDR_EXP 16
21448: PUSH
21449: LD_EXP 16
21453: PUSH
21454: LD_INT 1
21456: PLUS
21457: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
21458: LD_EXP 67
21462: PUSH
21463: LD_INT 2
21465: ARRAY
21466: PPUSH
21467: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
21471: LD_ADDR_EXP 75
21475: PUSH
21476: LD_EXP 75
21480: PPUSH
21481: LD_INT 2
21483: PPUSH
21484: LD_INT 1
21486: PPUSH
21487: CALL_OW 1
21491: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
21492: LD_VAR 0 2
21496: PUSH
21497: LD_EXP 74
21501: PUSH
21502: LD_INT 3
21504: ARRAY
21505: PUSH
21506: LD_INT 1
21508: ARRAY
21509: EQUAL
21510: IFFALSE 21759
// begin lab := artifactsLabs [ 3 ] ;
21512: LD_ADDR_VAR 0 6
21516: PUSH
21517: LD_EXP 73
21521: PUSH
21522: LD_INT 3
21524: ARRAY
21525: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
21526: LD_VAR 0 6
21530: PPUSH
21531: CALL_OW 274
21535: PPUSH
21536: CALL 90794 0 1
21540: PUSH
21541: LD_INT 3
21543: ARRAY
21544: PUSH
21545: LD_EXP 68
21549: PUSH
21550: LD_INT 3
21552: ARRAY
21553: LESS
21554: IFFALSE 21568
// begin HintSpec ( ArtifactCost , 2 ) ;
21556: LD_STRING ArtifactCost
21558: PPUSH
21559: LD_INT 2
21561: PPUSH
21562: CALL_OW 338
// exit ;
21566: GO 21759
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
21568: LD_INT 37
21570: PPUSH
21571: LD_INT 1
21573: PPUSH
21574: CALL_OW 424
// time := 0 0$30 ;
21578: LD_ADDR_VAR 0 7
21582: PUSH
21583: LD_INT 1050
21585: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
21586: LD_ADDR_EXP 75
21590: PUSH
21591: LD_EXP 75
21595: PPUSH
21596: LD_INT 3
21598: PPUSH
21599: LD_INT 0
21601: PPUSH
21602: CALL_OW 1
21606: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
21607: LD_ADDR_OWVAR 47
21611: PUSH
21612: LD_STRING #Am15a-1
21614: PUSH
21615: LD_VAR 0 7
21619: PUSH
21620: EMPTY
21621: LIST
21622: LIST
21623: ST_TO_ADDR
// wait ( 0 0$1 ) ;
21624: LD_INT 35
21626: PPUSH
21627: CALL_OW 67
// time := time - 0 0$1 ;
21631: LD_ADDR_VAR 0 7
21635: PUSH
21636: LD_VAR 0 7
21640: PUSH
21641: LD_INT 35
21643: MINUS
21644: ST_TO_ADDR
// until time = 0 0$00 ;
21645: LD_VAR 0 7
21649: PUSH
21650: LD_INT 0
21652: EQUAL
21653: IFFALSE 21607
// display_strings :=  ;
21655: LD_ADDR_OWVAR 47
21659: PUSH
21660: LD_STRING 
21662: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
21663: LD_INT 37
21665: PPUSH
21666: LD_INT 0
21668: PPUSH
21669: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
21673: LD_ADDR_VAR 0 8
21677: PUSH
21678: LD_INT 37
21680: PPUSH
21681: LD_INT 3
21683: PUSH
21684: LD_INT 21
21686: PUSH
21687: LD_INT 3
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: PPUSH
21698: CALL_OW 70
21702: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
21703: LD_VAR 0 3
21707: PPUSH
21708: LD_VAR 0 4
21712: PPUSH
21713: CALL_OW 84
// for un in list do
21717: LD_ADDR_VAR 0 9
21721: PUSH
21722: LD_VAR 0 8
21726: PUSH
21727: FOR_IN
21728: IFFALSE 21757
// TeleportUnit ( un , x , y , 12 , true ) ;
21730: LD_VAR 0 9
21734: PPUSH
21735: LD_VAR 0 3
21739: PPUSH
21740: LD_VAR 0 4
21744: PPUSH
21745: LD_INT 12
21747: PPUSH
21748: LD_INT 1
21750: PPUSH
21751: CALL_OW 483
21755: GO 21727
21757: POP
21758: POP
// end ; end ;
21759: PPOPN 9
21761: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
21762: LD_INT 0
21764: PPUSH
21765: PPUSH
// begin labNum := 0 ;
21766: LD_ADDR_VAR 0 4
21770: PUSH
21771: LD_INT 0
21773: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21774: LD_ADDR_VAR 0 3
21778: PUSH
21779: DOUBLE
21780: LD_INT 1
21782: DEC
21783: ST_TO_ADDR
21784: LD_EXP 73
21788: PUSH
21789: FOR_TO
21790: IFFALSE 21824
// if artifactsLabs [ i ] = lab then
21792: LD_EXP 73
21796: PUSH
21797: LD_VAR 0 3
21801: ARRAY
21802: PUSH
21803: LD_VAR 0 1
21807: EQUAL
21808: IFFALSE 21822
// begin labNum := i ;
21810: LD_ADDR_VAR 0 4
21814: PUSH
21815: LD_VAR 0 3
21819: ST_TO_ADDR
// break ;
21820: GO 21824
// end ;
21822: GO 21789
21824: POP
21825: POP
// if not labNum then
21826: LD_VAR 0 4
21830: NOT
21831: IFFALSE 21835
// exit ;
21833: GO 21913
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
21835: LD_INT 7
21837: PPUSH
21838: LD_EXP 74
21842: PUSH
21843: LD_VAR 0 4
21847: ARRAY
21848: PUSH
21849: LD_INT 3
21851: ARRAY
21852: PPUSH
21853: LD_INT 2
21855: PPUSH
21856: LD_VAR 0 1
21860: PPUSH
21861: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
21865: LD_ADDR_EXP 72
21869: PUSH
21870: LD_EXP 72
21874: PPUSH
21875: LD_VAR 0 4
21879: PPUSH
21880: LD_VAR 0 2
21884: PPUSH
21885: CALL_OW 1
21889: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
21890: LD_ADDR_EXP 70
21894: PUSH
21895: LD_EXP 70
21899: PPUSH
21900: LD_VAR 0 4
21904: PPUSH
21905: LD_INT 0
21907: PPUSH
21908: CALL_OW 1
21912: ST_TO_ADDR
// end ;
21913: PPOPN 4
21915: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21916: LD_INT 0
21918: PPUSH
21919: PPUSH
// begin labNum := 0 ;
21920: LD_ADDR_VAR 0 3
21924: PUSH
21925: LD_INT 0
21927: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21928: LD_ADDR_VAR 0 2
21932: PUSH
21933: DOUBLE
21934: LD_INT 1
21936: DEC
21937: ST_TO_ADDR
21938: LD_EXP 73
21942: PUSH
21943: FOR_TO
21944: IFFALSE 21978
// if artifactsLabs [ i ] = lab then
21946: LD_EXP 73
21950: PUSH
21951: LD_VAR 0 2
21955: ARRAY
21956: PUSH
21957: LD_VAR 0 1
21961: EQUAL
21962: IFFALSE 21976
// begin labNum := i ;
21964: LD_ADDR_VAR 0 3
21968: PUSH
21969: LD_VAR 0 2
21973: ST_TO_ADDR
// break ;
21974: GO 21978
// end ;
21976: GO 21943
21978: POP
21979: POP
// if not labNum then
21980: LD_VAR 0 3
21984: NOT
21985: IFFALSE 21989
// exit ;
21987: GO 22151
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21989: LD_INT 7
21991: PPUSH
21992: LD_EXP 74
21996: PUSH
21997: LD_VAR 0 3
22001: ARRAY
22002: PUSH
22003: LD_INT 3
22005: ARRAY
22006: PPUSH
22007: LD_INT 0
22009: PPUSH
22010: LD_VAR 0 1
22014: PPUSH
22015: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
22019: LD_ADDR_EXP 69
22023: PUSH
22024: LD_EXP 69
22028: PPUSH
22029: LD_VAR 0 3
22033: PPUSH
22034: LD_INT 1
22036: PPUSH
22037: CALL_OW 1
22041: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22042: LD_ADDR_EXP 75
22046: PUSH
22047: LD_EXP 75
22051: PPUSH
22052: LD_VAR 0 3
22056: PPUSH
22057: LD_INT 1
22059: PPUSH
22060: CALL_OW 1
22064: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22065: LD_ADDR_EXP 70
22069: PUSH
22070: LD_EXP 70
22074: PPUSH
22075: LD_VAR 0 3
22079: PPUSH
22080: LD_INT 0
22082: PPUSH
22083: CALL_OW 1
22087: ST_TO_ADDR
// case labNum of 1 :
22088: LD_VAR 0 3
22092: PUSH
22093: LD_INT 1
22095: DOUBLE
22096: EQUAL
22097: IFTRUE 22101
22099: GO 22112
22101: POP
// artifactIResearched := true ; 2 :
22102: LD_ADDR_EXP 12
22106: PUSH
22107: LD_INT 1
22109: ST_TO_ADDR
22110: GO 22151
22112: LD_INT 2
22114: DOUBLE
22115: EQUAL
22116: IFTRUE 22120
22118: GO 22131
22120: POP
// artifactIIResearched := true ; 3 :
22121: LD_ADDR_EXP 13
22125: PUSH
22126: LD_INT 1
22128: ST_TO_ADDR
22129: GO 22151
22131: LD_INT 3
22133: DOUBLE
22134: EQUAL
22135: IFTRUE 22139
22137: GO 22150
22139: POP
// artifactIIIResearched := true ; end ;
22140: LD_ADDR_EXP 14
22144: PUSH
22145: LD_INT 1
22147: ST_TO_ADDR
22148: GO 22151
22150: POP
// end ; end_of_file
22151: PPOPN 3
22153: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
22154: LD_INT 0
22156: PPUSH
22157: PPUSH
// skirmish := false ;
22158: LD_ADDR_EXP 76
22162: PUSH
22163: LD_INT 0
22165: ST_TO_ADDR
// debug_mc := false ;
22166: LD_ADDR_EXP 77
22170: PUSH
22171: LD_INT 0
22173: ST_TO_ADDR
// mc_bases := [ ] ;
22174: LD_ADDR_EXP 78
22178: PUSH
22179: EMPTY
22180: ST_TO_ADDR
// mc_sides := [ ] ;
22181: LD_ADDR_EXP 104
22185: PUSH
22186: EMPTY
22187: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
22188: LD_ADDR_EXP 79
22192: PUSH
22193: EMPTY
22194: ST_TO_ADDR
// mc_building_repairs := [ ] ;
22195: LD_ADDR_EXP 80
22199: PUSH
22200: EMPTY
22201: ST_TO_ADDR
// mc_need_heal := [ ] ;
22202: LD_ADDR_EXP 81
22206: PUSH
22207: EMPTY
22208: ST_TO_ADDR
// mc_healers := [ ] ;
22209: LD_ADDR_EXP 82
22213: PUSH
22214: EMPTY
22215: ST_TO_ADDR
// mc_build_list := [ ] ;
22216: LD_ADDR_EXP 83
22220: PUSH
22221: EMPTY
22222: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
22223: LD_ADDR_EXP 110
22227: PUSH
22228: EMPTY
22229: ST_TO_ADDR
// mc_builders := [ ] ;
22230: LD_ADDR_EXP 84
22234: PUSH
22235: EMPTY
22236: ST_TO_ADDR
// mc_construct_list := [ ] ;
22237: LD_ADDR_EXP 85
22241: PUSH
22242: EMPTY
22243: ST_TO_ADDR
// mc_turret_list := [ ] ;
22244: LD_ADDR_EXP 86
22248: PUSH
22249: EMPTY
22250: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
22251: LD_ADDR_EXP 87
22255: PUSH
22256: EMPTY
22257: ST_TO_ADDR
// mc_miners := [ ] ;
22258: LD_ADDR_EXP 92
22262: PUSH
22263: EMPTY
22264: ST_TO_ADDR
// mc_mines := [ ] ;
22265: LD_ADDR_EXP 91
22269: PUSH
22270: EMPTY
22271: ST_TO_ADDR
// mc_minefields := [ ] ;
22272: LD_ADDR_EXP 93
22276: PUSH
22277: EMPTY
22278: ST_TO_ADDR
// mc_crates := [ ] ;
22279: LD_ADDR_EXP 94
22283: PUSH
22284: EMPTY
22285: ST_TO_ADDR
// mc_crates_collector := [ ] ;
22286: LD_ADDR_EXP 95
22290: PUSH
22291: EMPTY
22292: ST_TO_ADDR
// mc_crates_area := [ ] ;
22293: LD_ADDR_EXP 96
22297: PUSH
22298: EMPTY
22299: ST_TO_ADDR
// mc_vehicles := [ ] ;
22300: LD_ADDR_EXP 97
22304: PUSH
22305: EMPTY
22306: ST_TO_ADDR
// mc_attack := [ ] ;
22307: LD_ADDR_EXP 98
22311: PUSH
22312: EMPTY
22313: ST_TO_ADDR
// mc_produce := [ ] ;
22314: LD_ADDR_EXP 99
22318: PUSH
22319: EMPTY
22320: ST_TO_ADDR
// mc_defender := [ ] ;
22321: LD_ADDR_EXP 100
22325: PUSH
22326: EMPTY
22327: ST_TO_ADDR
// mc_parking := [ ] ;
22328: LD_ADDR_EXP 102
22332: PUSH
22333: EMPTY
22334: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
22335: LD_ADDR_EXP 88
22339: PUSH
22340: EMPTY
22341: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
22342: LD_ADDR_EXP 90
22346: PUSH
22347: EMPTY
22348: ST_TO_ADDR
// mc_scan := [ ] ;
22349: LD_ADDR_EXP 101
22353: PUSH
22354: EMPTY
22355: ST_TO_ADDR
// mc_scan_area := [ ] ;
22356: LD_ADDR_EXP 103
22360: PUSH
22361: EMPTY
22362: ST_TO_ADDR
// mc_tech := [ ] ;
22363: LD_ADDR_EXP 105
22367: PUSH
22368: EMPTY
22369: ST_TO_ADDR
// mc_class := [ ] ;
22370: LD_ADDR_EXP 119
22374: PUSH
22375: EMPTY
22376: ST_TO_ADDR
// mc_class_case_use := [ ] ;
22377: LD_ADDR_EXP 120
22381: PUSH
22382: EMPTY
22383: ST_TO_ADDR
// mc_is_defending := [ ] ;
22384: LD_ADDR_EXP 121
22388: PUSH
22389: EMPTY
22390: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
22391: LD_ADDR_EXP 112
22395: PUSH
22396: EMPTY
22397: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
22398: LD_ADDR_EXP 122
22402: PUSH
22403: LD_INT 0
22405: ST_TO_ADDR
// end ;
22406: LD_VAR 0 1
22410: RET
// export function MC_Kill ( base ) ; begin
22411: LD_INT 0
22413: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
22414: LD_ADDR_EXP 78
22418: PUSH
22419: LD_EXP 78
22423: PPUSH
22424: LD_VAR 0 1
22428: PPUSH
22429: EMPTY
22430: PPUSH
22431: CALL_OW 1
22435: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22436: LD_ADDR_EXP 79
22440: PUSH
22441: LD_EXP 79
22445: PPUSH
22446: LD_VAR 0 1
22450: PPUSH
22451: EMPTY
22452: PPUSH
22453: CALL_OW 1
22457: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22458: LD_ADDR_EXP 80
22462: PUSH
22463: LD_EXP 80
22467: PPUSH
22468: LD_VAR 0 1
22472: PPUSH
22473: EMPTY
22474: PPUSH
22475: CALL_OW 1
22479: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22480: LD_ADDR_EXP 81
22484: PUSH
22485: LD_EXP 81
22489: PPUSH
22490: LD_VAR 0 1
22494: PPUSH
22495: EMPTY
22496: PPUSH
22497: CALL_OW 1
22501: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22502: LD_ADDR_EXP 82
22506: PUSH
22507: LD_EXP 82
22511: PPUSH
22512: LD_VAR 0 1
22516: PPUSH
22517: EMPTY
22518: PPUSH
22519: CALL_OW 1
22523: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22524: LD_ADDR_EXP 83
22528: PUSH
22529: LD_EXP 83
22533: PPUSH
22534: LD_VAR 0 1
22538: PPUSH
22539: EMPTY
22540: PPUSH
22541: CALL_OW 1
22545: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22546: LD_ADDR_EXP 84
22550: PUSH
22551: LD_EXP 84
22555: PPUSH
22556: LD_VAR 0 1
22560: PPUSH
22561: EMPTY
22562: PPUSH
22563: CALL_OW 1
22567: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22568: LD_ADDR_EXP 85
22572: PUSH
22573: LD_EXP 85
22577: PPUSH
22578: LD_VAR 0 1
22582: PPUSH
22583: EMPTY
22584: PPUSH
22585: CALL_OW 1
22589: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22590: LD_ADDR_EXP 86
22594: PUSH
22595: LD_EXP 86
22599: PPUSH
22600: LD_VAR 0 1
22604: PPUSH
22605: EMPTY
22606: PPUSH
22607: CALL_OW 1
22611: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22612: LD_ADDR_EXP 87
22616: PUSH
22617: LD_EXP 87
22621: PPUSH
22622: LD_VAR 0 1
22626: PPUSH
22627: EMPTY
22628: PPUSH
22629: CALL_OW 1
22633: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22634: LD_ADDR_EXP 88
22638: PUSH
22639: LD_EXP 88
22643: PPUSH
22644: LD_VAR 0 1
22648: PPUSH
22649: EMPTY
22650: PPUSH
22651: CALL_OW 1
22655: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22656: LD_ADDR_EXP 89
22660: PUSH
22661: LD_EXP 89
22665: PPUSH
22666: LD_VAR 0 1
22670: PPUSH
22671: LD_INT 0
22673: PPUSH
22674: CALL_OW 1
22678: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22679: LD_ADDR_EXP 90
22683: PUSH
22684: LD_EXP 90
22688: PPUSH
22689: LD_VAR 0 1
22693: PPUSH
22694: EMPTY
22695: PPUSH
22696: CALL_OW 1
22700: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22701: LD_ADDR_EXP 91
22705: PUSH
22706: LD_EXP 91
22710: PPUSH
22711: LD_VAR 0 1
22715: PPUSH
22716: EMPTY
22717: PPUSH
22718: CALL_OW 1
22722: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22723: LD_ADDR_EXP 92
22727: PUSH
22728: LD_EXP 92
22732: PPUSH
22733: LD_VAR 0 1
22737: PPUSH
22738: EMPTY
22739: PPUSH
22740: CALL_OW 1
22744: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22745: LD_ADDR_EXP 93
22749: PUSH
22750: LD_EXP 93
22754: PPUSH
22755: LD_VAR 0 1
22759: PPUSH
22760: EMPTY
22761: PPUSH
22762: CALL_OW 1
22766: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22767: LD_ADDR_EXP 94
22771: PUSH
22772: LD_EXP 94
22776: PPUSH
22777: LD_VAR 0 1
22781: PPUSH
22782: EMPTY
22783: PPUSH
22784: CALL_OW 1
22788: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22789: LD_ADDR_EXP 95
22793: PUSH
22794: LD_EXP 95
22798: PPUSH
22799: LD_VAR 0 1
22803: PPUSH
22804: EMPTY
22805: PPUSH
22806: CALL_OW 1
22810: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22811: LD_ADDR_EXP 96
22815: PUSH
22816: LD_EXP 96
22820: PPUSH
22821: LD_VAR 0 1
22825: PPUSH
22826: EMPTY
22827: PPUSH
22828: CALL_OW 1
22832: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22833: LD_ADDR_EXP 97
22837: PUSH
22838: LD_EXP 97
22842: PPUSH
22843: LD_VAR 0 1
22847: PPUSH
22848: EMPTY
22849: PPUSH
22850: CALL_OW 1
22854: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22855: LD_ADDR_EXP 98
22859: PUSH
22860: LD_EXP 98
22864: PPUSH
22865: LD_VAR 0 1
22869: PPUSH
22870: EMPTY
22871: PPUSH
22872: CALL_OW 1
22876: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22877: LD_ADDR_EXP 99
22881: PUSH
22882: LD_EXP 99
22886: PPUSH
22887: LD_VAR 0 1
22891: PPUSH
22892: EMPTY
22893: PPUSH
22894: CALL_OW 1
22898: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22899: LD_ADDR_EXP 100
22903: PUSH
22904: LD_EXP 100
22908: PPUSH
22909: LD_VAR 0 1
22913: PPUSH
22914: EMPTY
22915: PPUSH
22916: CALL_OW 1
22920: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22921: LD_ADDR_EXP 101
22925: PUSH
22926: LD_EXP 101
22930: PPUSH
22931: LD_VAR 0 1
22935: PPUSH
22936: EMPTY
22937: PPUSH
22938: CALL_OW 1
22942: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22943: LD_ADDR_EXP 102
22947: PUSH
22948: LD_EXP 102
22952: PPUSH
22953: LD_VAR 0 1
22957: PPUSH
22958: EMPTY
22959: PPUSH
22960: CALL_OW 1
22964: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22965: LD_ADDR_EXP 103
22969: PUSH
22970: LD_EXP 103
22974: PPUSH
22975: LD_VAR 0 1
22979: PPUSH
22980: EMPTY
22981: PPUSH
22982: CALL_OW 1
22986: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22987: LD_ADDR_EXP 105
22991: PUSH
22992: LD_EXP 105
22996: PPUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: EMPTY
23003: PPUSH
23004: CALL_OW 1
23008: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23009: LD_ADDR_EXP 107
23013: PUSH
23014: LD_EXP 107
23018: PPUSH
23019: LD_VAR 0 1
23023: PPUSH
23024: EMPTY
23025: PPUSH
23026: CALL_OW 1
23030: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23031: LD_ADDR_EXP 108
23035: PUSH
23036: LD_EXP 108
23040: PPUSH
23041: LD_VAR 0 1
23045: PPUSH
23046: EMPTY
23047: PPUSH
23048: CALL_OW 1
23052: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23053: LD_ADDR_EXP 109
23057: PUSH
23058: LD_EXP 109
23062: PPUSH
23063: LD_VAR 0 1
23067: PPUSH
23068: EMPTY
23069: PPUSH
23070: CALL_OW 1
23074: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23075: LD_ADDR_EXP 110
23079: PUSH
23080: LD_EXP 110
23084: PPUSH
23085: LD_VAR 0 1
23089: PPUSH
23090: EMPTY
23091: PPUSH
23092: CALL_OW 1
23096: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23097: LD_ADDR_EXP 111
23101: PUSH
23102: LD_EXP 111
23106: PPUSH
23107: LD_VAR 0 1
23111: PPUSH
23112: EMPTY
23113: PPUSH
23114: CALL_OW 1
23118: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23119: LD_ADDR_EXP 112
23123: PUSH
23124: LD_EXP 112
23128: PPUSH
23129: LD_VAR 0 1
23133: PPUSH
23134: EMPTY
23135: PPUSH
23136: CALL_OW 1
23140: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23141: LD_ADDR_EXP 113
23145: PUSH
23146: LD_EXP 113
23150: PPUSH
23151: LD_VAR 0 1
23155: PPUSH
23156: EMPTY
23157: PPUSH
23158: CALL_OW 1
23162: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23163: LD_ADDR_EXP 114
23167: PUSH
23168: LD_EXP 114
23172: PPUSH
23173: LD_VAR 0 1
23177: PPUSH
23178: EMPTY
23179: PPUSH
23180: CALL_OW 1
23184: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23185: LD_ADDR_EXP 115
23189: PUSH
23190: LD_EXP 115
23194: PPUSH
23195: LD_VAR 0 1
23199: PPUSH
23200: EMPTY
23201: PPUSH
23202: CALL_OW 1
23206: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23207: LD_ADDR_EXP 116
23211: PUSH
23212: LD_EXP 116
23216: PPUSH
23217: LD_VAR 0 1
23221: PPUSH
23222: EMPTY
23223: PPUSH
23224: CALL_OW 1
23228: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23229: LD_ADDR_EXP 117
23233: PUSH
23234: LD_EXP 117
23238: PPUSH
23239: LD_VAR 0 1
23243: PPUSH
23244: EMPTY
23245: PPUSH
23246: CALL_OW 1
23250: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23251: LD_ADDR_EXP 118
23255: PUSH
23256: LD_EXP 118
23260: PPUSH
23261: LD_VAR 0 1
23265: PPUSH
23266: EMPTY
23267: PPUSH
23268: CALL_OW 1
23272: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23273: LD_ADDR_EXP 119
23277: PUSH
23278: LD_EXP 119
23282: PPUSH
23283: LD_VAR 0 1
23287: PPUSH
23288: EMPTY
23289: PPUSH
23290: CALL_OW 1
23294: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23295: LD_ADDR_EXP 120
23299: PUSH
23300: LD_EXP 120
23304: PPUSH
23305: LD_VAR 0 1
23309: PPUSH
23310: LD_INT 0
23312: PPUSH
23313: CALL_OW 1
23317: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23318: LD_ADDR_EXP 121
23322: PUSH
23323: LD_EXP 121
23327: PPUSH
23328: LD_VAR 0 1
23332: PPUSH
23333: LD_INT 0
23335: PPUSH
23336: CALL_OW 1
23340: ST_TO_ADDR
// end ;
23341: LD_VAR 0 2
23345: RET
// export function MC_Add ( side , units ) ; var base ; begin
23346: LD_INT 0
23348: PPUSH
23349: PPUSH
// base := mc_bases + 1 ;
23350: LD_ADDR_VAR 0 4
23354: PUSH
23355: LD_EXP 78
23359: PUSH
23360: LD_INT 1
23362: PLUS
23363: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
23364: LD_ADDR_EXP 104
23368: PUSH
23369: LD_EXP 104
23373: PPUSH
23374: LD_VAR 0 4
23378: PPUSH
23379: LD_VAR 0 1
23383: PPUSH
23384: CALL_OW 1
23388: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
23389: LD_ADDR_EXP 78
23393: PUSH
23394: LD_EXP 78
23398: PPUSH
23399: LD_VAR 0 4
23403: PPUSH
23404: LD_VAR 0 2
23408: PPUSH
23409: CALL_OW 1
23413: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23414: LD_ADDR_EXP 79
23418: PUSH
23419: LD_EXP 79
23423: PPUSH
23424: LD_VAR 0 4
23428: PPUSH
23429: EMPTY
23430: PPUSH
23431: CALL_OW 1
23435: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23436: LD_ADDR_EXP 80
23440: PUSH
23441: LD_EXP 80
23445: PPUSH
23446: LD_VAR 0 4
23450: PPUSH
23451: EMPTY
23452: PPUSH
23453: CALL_OW 1
23457: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23458: LD_ADDR_EXP 81
23462: PUSH
23463: LD_EXP 81
23467: PPUSH
23468: LD_VAR 0 4
23472: PPUSH
23473: EMPTY
23474: PPUSH
23475: CALL_OW 1
23479: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23480: LD_ADDR_EXP 82
23484: PUSH
23485: LD_EXP 82
23489: PPUSH
23490: LD_VAR 0 4
23494: PPUSH
23495: EMPTY
23496: PPUSH
23497: CALL_OW 1
23501: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23502: LD_ADDR_EXP 83
23506: PUSH
23507: LD_EXP 83
23511: PPUSH
23512: LD_VAR 0 4
23516: PPUSH
23517: EMPTY
23518: PPUSH
23519: CALL_OW 1
23523: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23524: LD_ADDR_EXP 84
23528: PUSH
23529: LD_EXP 84
23533: PPUSH
23534: LD_VAR 0 4
23538: PPUSH
23539: EMPTY
23540: PPUSH
23541: CALL_OW 1
23545: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23546: LD_ADDR_EXP 85
23550: PUSH
23551: LD_EXP 85
23555: PPUSH
23556: LD_VAR 0 4
23560: PPUSH
23561: EMPTY
23562: PPUSH
23563: CALL_OW 1
23567: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23568: LD_ADDR_EXP 86
23572: PUSH
23573: LD_EXP 86
23577: PPUSH
23578: LD_VAR 0 4
23582: PPUSH
23583: EMPTY
23584: PPUSH
23585: CALL_OW 1
23589: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23590: LD_ADDR_EXP 87
23594: PUSH
23595: LD_EXP 87
23599: PPUSH
23600: LD_VAR 0 4
23604: PPUSH
23605: EMPTY
23606: PPUSH
23607: CALL_OW 1
23611: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23612: LD_ADDR_EXP 88
23616: PUSH
23617: LD_EXP 88
23621: PPUSH
23622: LD_VAR 0 4
23626: PPUSH
23627: EMPTY
23628: PPUSH
23629: CALL_OW 1
23633: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23634: LD_ADDR_EXP 89
23638: PUSH
23639: LD_EXP 89
23643: PPUSH
23644: LD_VAR 0 4
23648: PPUSH
23649: LD_INT 0
23651: PPUSH
23652: CALL_OW 1
23656: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23657: LD_ADDR_EXP 90
23661: PUSH
23662: LD_EXP 90
23666: PPUSH
23667: LD_VAR 0 4
23671: PPUSH
23672: EMPTY
23673: PPUSH
23674: CALL_OW 1
23678: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23679: LD_ADDR_EXP 91
23683: PUSH
23684: LD_EXP 91
23688: PPUSH
23689: LD_VAR 0 4
23693: PPUSH
23694: EMPTY
23695: PPUSH
23696: CALL_OW 1
23700: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23701: LD_ADDR_EXP 92
23705: PUSH
23706: LD_EXP 92
23710: PPUSH
23711: LD_VAR 0 4
23715: PPUSH
23716: EMPTY
23717: PPUSH
23718: CALL_OW 1
23722: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23723: LD_ADDR_EXP 93
23727: PUSH
23728: LD_EXP 93
23732: PPUSH
23733: LD_VAR 0 4
23737: PPUSH
23738: EMPTY
23739: PPUSH
23740: CALL_OW 1
23744: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23745: LD_ADDR_EXP 94
23749: PUSH
23750: LD_EXP 94
23754: PPUSH
23755: LD_VAR 0 4
23759: PPUSH
23760: EMPTY
23761: PPUSH
23762: CALL_OW 1
23766: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23767: LD_ADDR_EXP 95
23771: PUSH
23772: LD_EXP 95
23776: PPUSH
23777: LD_VAR 0 4
23781: PPUSH
23782: EMPTY
23783: PPUSH
23784: CALL_OW 1
23788: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23789: LD_ADDR_EXP 96
23793: PUSH
23794: LD_EXP 96
23798: PPUSH
23799: LD_VAR 0 4
23803: PPUSH
23804: EMPTY
23805: PPUSH
23806: CALL_OW 1
23810: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23811: LD_ADDR_EXP 97
23815: PUSH
23816: LD_EXP 97
23820: PPUSH
23821: LD_VAR 0 4
23825: PPUSH
23826: EMPTY
23827: PPUSH
23828: CALL_OW 1
23832: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23833: LD_ADDR_EXP 98
23837: PUSH
23838: LD_EXP 98
23842: PPUSH
23843: LD_VAR 0 4
23847: PPUSH
23848: EMPTY
23849: PPUSH
23850: CALL_OW 1
23854: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23855: LD_ADDR_EXP 99
23859: PUSH
23860: LD_EXP 99
23864: PPUSH
23865: LD_VAR 0 4
23869: PPUSH
23870: EMPTY
23871: PPUSH
23872: CALL_OW 1
23876: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23877: LD_ADDR_EXP 100
23881: PUSH
23882: LD_EXP 100
23886: PPUSH
23887: LD_VAR 0 4
23891: PPUSH
23892: EMPTY
23893: PPUSH
23894: CALL_OW 1
23898: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23899: LD_ADDR_EXP 101
23903: PUSH
23904: LD_EXP 101
23908: PPUSH
23909: LD_VAR 0 4
23913: PPUSH
23914: EMPTY
23915: PPUSH
23916: CALL_OW 1
23920: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23921: LD_ADDR_EXP 102
23925: PUSH
23926: LD_EXP 102
23930: PPUSH
23931: LD_VAR 0 4
23935: PPUSH
23936: EMPTY
23937: PPUSH
23938: CALL_OW 1
23942: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23943: LD_ADDR_EXP 103
23947: PUSH
23948: LD_EXP 103
23952: PPUSH
23953: LD_VAR 0 4
23957: PPUSH
23958: EMPTY
23959: PPUSH
23960: CALL_OW 1
23964: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23965: LD_ADDR_EXP 105
23969: PUSH
23970: LD_EXP 105
23974: PPUSH
23975: LD_VAR 0 4
23979: PPUSH
23980: EMPTY
23981: PPUSH
23982: CALL_OW 1
23986: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23987: LD_ADDR_EXP 107
23991: PUSH
23992: LD_EXP 107
23996: PPUSH
23997: LD_VAR 0 4
24001: PPUSH
24002: EMPTY
24003: PPUSH
24004: CALL_OW 1
24008: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24009: LD_ADDR_EXP 108
24013: PUSH
24014: LD_EXP 108
24018: PPUSH
24019: LD_VAR 0 4
24023: PPUSH
24024: EMPTY
24025: PPUSH
24026: CALL_OW 1
24030: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24031: LD_ADDR_EXP 109
24035: PUSH
24036: LD_EXP 109
24040: PPUSH
24041: LD_VAR 0 4
24045: PPUSH
24046: EMPTY
24047: PPUSH
24048: CALL_OW 1
24052: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24053: LD_ADDR_EXP 110
24057: PUSH
24058: LD_EXP 110
24062: PPUSH
24063: LD_VAR 0 4
24067: PPUSH
24068: EMPTY
24069: PPUSH
24070: CALL_OW 1
24074: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24075: LD_ADDR_EXP 111
24079: PUSH
24080: LD_EXP 111
24084: PPUSH
24085: LD_VAR 0 4
24089: PPUSH
24090: EMPTY
24091: PPUSH
24092: CALL_OW 1
24096: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24097: LD_ADDR_EXP 112
24101: PUSH
24102: LD_EXP 112
24106: PPUSH
24107: LD_VAR 0 4
24111: PPUSH
24112: EMPTY
24113: PPUSH
24114: CALL_OW 1
24118: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24119: LD_ADDR_EXP 113
24123: PUSH
24124: LD_EXP 113
24128: PPUSH
24129: LD_VAR 0 4
24133: PPUSH
24134: EMPTY
24135: PPUSH
24136: CALL_OW 1
24140: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24141: LD_ADDR_EXP 114
24145: PUSH
24146: LD_EXP 114
24150: PPUSH
24151: LD_VAR 0 4
24155: PPUSH
24156: EMPTY
24157: PPUSH
24158: CALL_OW 1
24162: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24163: LD_ADDR_EXP 115
24167: PUSH
24168: LD_EXP 115
24172: PPUSH
24173: LD_VAR 0 4
24177: PPUSH
24178: EMPTY
24179: PPUSH
24180: CALL_OW 1
24184: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24185: LD_ADDR_EXP 116
24189: PUSH
24190: LD_EXP 116
24194: PPUSH
24195: LD_VAR 0 4
24199: PPUSH
24200: EMPTY
24201: PPUSH
24202: CALL_OW 1
24206: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24207: LD_ADDR_EXP 117
24211: PUSH
24212: LD_EXP 117
24216: PPUSH
24217: LD_VAR 0 4
24221: PPUSH
24222: EMPTY
24223: PPUSH
24224: CALL_OW 1
24228: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24229: LD_ADDR_EXP 118
24233: PUSH
24234: LD_EXP 118
24238: PPUSH
24239: LD_VAR 0 4
24243: PPUSH
24244: EMPTY
24245: PPUSH
24246: CALL_OW 1
24250: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24251: LD_ADDR_EXP 119
24255: PUSH
24256: LD_EXP 119
24260: PPUSH
24261: LD_VAR 0 4
24265: PPUSH
24266: EMPTY
24267: PPUSH
24268: CALL_OW 1
24272: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24273: LD_ADDR_EXP 120
24277: PUSH
24278: LD_EXP 120
24282: PPUSH
24283: LD_VAR 0 4
24287: PPUSH
24288: LD_INT 0
24290: PPUSH
24291: CALL_OW 1
24295: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24296: LD_ADDR_EXP 121
24300: PUSH
24301: LD_EXP 121
24305: PPUSH
24306: LD_VAR 0 4
24310: PPUSH
24311: LD_INT 0
24313: PPUSH
24314: CALL_OW 1
24318: ST_TO_ADDR
// result := base ;
24319: LD_ADDR_VAR 0 3
24323: PUSH
24324: LD_VAR 0 4
24328: ST_TO_ADDR
// end ;
24329: LD_VAR 0 3
24333: RET
// export function MC_Start ( ) ; var i ; begin
24334: LD_INT 0
24336: PPUSH
24337: PPUSH
// for i = 1 to mc_bases do
24338: LD_ADDR_VAR 0 2
24342: PUSH
24343: DOUBLE
24344: LD_INT 1
24346: DEC
24347: ST_TO_ADDR
24348: LD_EXP 78
24352: PUSH
24353: FOR_TO
24354: IFFALSE 25454
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
24356: LD_ADDR_EXP 78
24360: PUSH
24361: LD_EXP 78
24365: PPUSH
24366: LD_VAR 0 2
24370: PPUSH
24371: LD_EXP 78
24375: PUSH
24376: LD_VAR 0 2
24380: ARRAY
24381: PUSH
24382: LD_INT 0
24384: DIFF
24385: PPUSH
24386: CALL_OW 1
24390: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
24391: LD_ADDR_EXP 79
24395: PUSH
24396: LD_EXP 79
24400: PPUSH
24401: LD_VAR 0 2
24405: PPUSH
24406: EMPTY
24407: PPUSH
24408: CALL_OW 1
24412: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
24413: LD_ADDR_EXP 80
24417: PUSH
24418: LD_EXP 80
24422: PPUSH
24423: LD_VAR 0 2
24427: PPUSH
24428: EMPTY
24429: PPUSH
24430: CALL_OW 1
24434: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
24435: LD_ADDR_EXP 81
24439: PUSH
24440: LD_EXP 81
24444: PPUSH
24445: LD_VAR 0 2
24449: PPUSH
24450: EMPTY
24451: PPUSH
24452: CALL_OW 1
24456: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
24457: LD_ADDR_EXP 82
24461: PUSH
24462: LD_EXP 82
24466: PPUSH
24467: LD_VAR 0 2
24471: PPUSH
24472: EMPTY
24473: PUSH
24474: EMPTY
24475: PUSH
24476: EMPTY
24477: LIST
24478: LIST
24479: PPUSH
24480: CALL_OW 1
24484: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
24485: LD_ADDR_EXP 83
24489: PUSH
24490: LD_EXP 83
24494: PPUSH
24495: LD_VAR 0 2
24499: PPUSH
24500: EMPTY
24501: PPUSH
24502: CALL_OW 1
24506: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
24507: LD_ADDR_EXP 110
24511: PUSH
24512: LD_EXP 110
24516: PPUSH
24517: LD_VAR 0 2
24521: PPUSH
24522: EMPTY
24523: PPUSH
24524: CALL_OW 1
24528: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
24529: LD_ADDR_EXP 84
24533: PUSH
24534: LD_EXP 84
24538: PPUSH
24539: LD_VAR 0 2
24543: PPUSH
24544: EMPTY
24545: PPUSH
24546: CALL_OW 1
24550: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
24551: LD_ADDR_EXP 85
24555: PUSH
24556: LD_EXP 85
24560: PPUSH
24561: LD_VAR 0 2
24565: PPUSH
24566: EMPTY
24567: PPUSH
24568: CALL_OW 1
24572: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
24573: LD_ADDR_EXP 86
24577: PUSH
24578: LD_EXP 86
24582: PPUSH
24583: LD_VAR 0 2
24587: PPUSH
24588: LD_EXP 78
24592: PUSH
24593: LD_VAR 0 2
24597: ARRAY
24598: PPUSH
24599: LD_INT 2
24601: PUSH
24602: LD_INT 30
24604: PUSH
24605: LD_INT 32
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: PUSH
24612: LD_INT 30
24614: PUSH
24615: LD_INT 33
24617: PUSH
24618: EMPTY
24619: LIST
24620: LIST
24621: PUSH
24622: EMPTY
24623: LIST
24624: LIST
24625: LIST
24626: PPUSH
24627: CALL_OW 72
24631: PPUSH
24632: CALL_OW 1
24636: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
24637: LD_ADDR_EXP 87
24641: PUSH
24642: LD_EXP 87
24646: PPUSH
24647: LD_VAR 0 2
24651: PPUSH
24652: LD_EXP 78
24656: PUSH
24657: LD_VAR 0 2
24661: ARRAY
24662: PPUSH
24663: LD_INT 2
24665: PUSH
24666: LD_INT 30
24668: PUSH
24669: LD_INT 32
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: PUSH
24676: LD_INT 30
24678: PUSH
24679: LD_INT 31
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: LIST
24690: PUSH
24691: LD_INT 58
24693: PUSH
24694: EMPTY
24695: LIST
24696: PUSH
24697: EMPTY
24698: LIST
24699: LIST
24700: PPUSH
24701: CALL_OW 72
24705: PPUSH
24706: CALL_OW 1
24710: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
24711: LD_ADDR_EXP 88
24715: PUSH
24716: LD_EXP 88
24720: PPUSH
24721: LD_VAR 0 2
24725: PPUSH
24726: EMPTY
24727: PPUSH
24728: CALL_OW 1
24732: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
24733: LD_ADDR_EXP 92
24737: PUSH
24738: LD_EXP 92
24742: PPUSH
24743: LD_VAR 0 2
24747: PPUSH
24748: EMPTY
24749: PPUSH
24750: CALL_OW 1
24754: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
24755: LD_ADDR_EXP 91
24759: PUSH
24760: LD_EXP 91
24764: PPUSH
24765: LD_VAR 0 2
24769: PPUSH
24770: EMPTY
24771: PPUSH
24772: CALL_OW 1
24776: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24777: LD_ADDR_EXP 93
24781: PUSH
24782: LD_EXP 93
24786: PPUSH
24787: LD_VAR 0 2
24791: PPUSH
24792: EMPTY
24793: PPUSH
24794: CALL_OW 1
24798: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24799: LD_ADDR_EXP 94
24803: PUSH
24804: LD_EXP 94
24808: PPUSH
24809: LD_VAR 0 2
24813: PPUSH
24814: EMPTY
24815: PPUSH
24816: CALL_OW 1
24820: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24821: LD_ADDR_EXP 95
24825: PUSH
24826: LD_EXP 95
24830: PPUSH
24831: LD_VAR 0 2
24835: PPUSH
24836: EMPTY
24837: PPUSH
24838: CALL_OW 1
24842: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24843: LD_ADDR_EXP 96
24847: PUSH
24848: LD_EXP 96
24852: PPUSH
24853: LD_VAR 0 2
24857: PPUSH
24858: EMPTY
24859: PPUSH
24860: CALL_OW 1
24864: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24865: LD_ADDR_EXP 97
24869: PUSH
24870: LD_EXP 97
24874: PPUSH
24875: LD_VAR 0 2
24879: PPUSH
24880: EMPTY
24881: PPUSH
24882: CALL_OW 1
24886: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24887: LD_ADDR_EXP 98
24891: PUSH
24892: LD_EXP 98
24896: PPUSH
24897: LD_VAR 0 2
24901: PPUSH
24902: EMPTY
24903: PPUSH
24904: CALL_OW 1
24908: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24909: LD_ADDR_EXP 99
24913: PUSH
24914: LD_EXP 99
24918: PPUSH
24919: LD_VAR 0 2
24923: PPUSH
24924: EMPTY
24925: PPUSH
24926: CALL_OW 1
24930: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24931: LD_ADDR_EXP 100
24935: PUSH
24936: LD_EXP 100
24940: PPUSH
24941: LD_VAR 0 2
24945: PPUSH
24946: EMPTY
24947: PPUSH
24948: CALL_OW 1
24952: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24953: LD_ADDR_EXP 89
24957: PUSH
24958: LD_EXP 89
24962: PPUSH
24963: LD_VAR 0 2
24967: PPUSH
24968: LD_INT 0
24970: PPUSH
24971: CALL_OW 1
24975: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24976: LD_ADDR_EXP 102
24980: PUSH
24981: LD_EXP 102
24985: PPUSH
24986: LD_VAR 0 2
24990: PPUSH
24991: LD_INT 0
24993: PPUSH
24994: CALL_OW 1
24998: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24999: LD_ADDR_EXP 90
25003: PUSH
25004: LD_EXP 90
25008: PPUSH
25009: LD_VAR 0 2
25013: PPUSH
25014: EMPTY
25015: PPUSH
25016: CALL_OW 1
25020: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
25021: LD_ADDR_EXP 101
25025: PUSH
25026: LD_EXP 101
25030: PPUSH
25031: LD_VAR 0 2
25035: PPUSH
25036: LD_INT 0
25038: PPUSH
25039: CALL_OW 1
25043: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25044: LD_ADDR_EXP 103
25048: PUSH
25049: LD_EXP 103
25053: PPUSH
25054: LD_VAR 0 2
25058: PPUSH
25059: EMPTY
25060: PPUSH
25061: CALL_OW 1
25065: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25066: LD_ADDR_EXP 106
25070: PUSH
25071: LD_EXP 106
25075: PPUSH
25076: LD_VAR 0 2
25080: PPUSH
25081: LD_INT 0
25083: PPUSH
25084: CALL_OW 1
25088: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25089: LD_ADDR_EXP 107
25093: PUSH
25094: LD_EXP 107
25098: PPUSH
25099: LD_VAR 0 2
25103: PPUSH
25104: EMPTY
25105: PPUSH
25106: CALL_OW 1
25110: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25111: LD_ADDR_EXP 108
25115: PUSH
25116: LD_EXP 108
25120: PPUSH
25121: LD_VAR 0 2
25125: PPUSH
25126: EMPTY
25127: PPUSH
25128: CALL_OW 1
25132: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25133: LD_ADDR_EXP 109
25137: PUSH
25138: LD_EXP 109
25142: PPUSH
25143: LD_VAR 0 2
25147: PPUSH
25148: EMPTY
25149: PPUSH
25150: CALL_OW 1
25154: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
25155: LD_ADDR_EXP 111
25159: PUSH
25160: LD_EXP 111
25164: PPUSH
25165: LD_VAR 0 2
25169: PPUSH
25170: LD_EXP 78
25174: PUSH
25175: LD_VAR 0 2
25179: ARRAY
25180: PPUSH
25181: LD_INT 2
25183: PUSH
25184: LD_INT 30
25186: PUSH
25187: LD_INT 6
25189: PUSH
25190: EMPTY
25191: LIST
25192: LIST
25193: PUSH
25194: LD_INT 30
25196: PUSH
25197: LD_INT 7
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: PUSH
25204: LD_INT 30
25206: PUSH
25207: LD_INT 8
25209: PUSH
25210: EMPTY
25211: LIST
25212: LIST
25213: PUSH
25214: EMPTY
25215: LIST
25216: LIST
25217: LIST
25218: LIST
25219: PPUSH
25220: CALL_OW 72
25224: PPUSH
25225: CALL_OW 1
25229: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
25230: LD_ADDR_EXP 112
25234: PUSH
25235: LD_EXP 112
25239: PPUSH
25240: LD_VAR 0 2
25244: PPUSH
25245: EMPTY
25246: PPUSH
25247: CALL_OW 1
25251: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
25252: LD_ADDR_EXP 113
25256: PUSH
25257: LD_EXP 113
25261: PPUSH
25262: LD_VAR 0 2
25266: PPUSH
25267: EMPTY
25268: PPUSH
25269: CALL_OW 1
25273: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
25274: LD_ADDR_EXP 114
25278: PUSH
25279: LD_EXP 114
25283: PPUSH
25284: LD_VAR 0 2
25288: PPUSH
25289: EMPTY
25290: PPUSH
25291: CALL_OW 1
25295: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
25296: LD_ADDR_EXP 115
25300: PUSH
25301: LD_EXP 115
25305: PPUSH
25306: LD_VAR 0 2
25310: PPUSH
25311: EMPTY
25312: PPUSH
25313: CALL_OW 1
25317: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
25318: LD_ADDR_EXP 116
25322: PUSH
25323: LD_EXP 116
25327: PPUSH
25328: LD_VAR 0 2
25332: PPUSH
25333: EMPTY
25334: PPUSH
25335: CALL_OW 1
25339: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
25340: LD_ADDR_EXP 117
25344: PUSH
25345: LD_EXP 117
25349: PPUSH
25350: LD_VAR 0 2
25354: PPUSH
25355: EMPTY
25356: PPUSH
25357: CALL_OW 1
25361: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
25362: LD_ADDR_EXP 118
25366: PUSH
25367: LD_EXP 118
25371: PPUSH
25372: LD_VAR 0 2
25376: PPUSH
25377: EMPTY
25378: PPUSH
25379: CALL_OW 1
25383: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
25384: LD_ADDR_EXP 119
25388: PUSH
25389: LD_EXP 119
25393: PPUSH
25394: LD_VAR 0 2
25398: PPUSH
25399: EMPTY
25400: PPUSH
25401: CALL_OW 1
25405: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
25406: LD_ADDR_EXP 120
25410: PUSH
25411: LD_EXP 120
25415: PPUSH
25416: LD_VAR 0 2
25420: PPUSH
25421: LD_INT 0
25423: PPUSH
25424: CALL_OW 1
25428: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
25429: LD_ADDR_EXP 121
25433: PUSH
25434: LD_EXP 121
25438: PPUSH
25439: LD_VAR 0 2
25443: PPUSH
25444: LD_INT 0
25446: PPUSH
25447: CALL_OW 1
25451: ST_TO_ADDR
// end ;
25452: GO 24353
25454: POP
25455: POP
// MC_InitSides ( ) ;
25456: CALL 25742 0 0
// MC_InitResearch ( ) ;
25460: CALL 25481 0 0
// CustomInitMacro ( ) ;
25464: CALL 228 0 0
// skirmish := true ;
25468: LD_ADDR_EXP 76
25472: PUSH
25473: LD_INT 1
25475: ST_TO_ADDR
// end ;
25476: LD_VAR 0 1
25480: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
25481: LD_INT 0
25483: PPUSH
25484: PPUSH
25485: PPUSH
25486: PPUSH
25487: PPUSH
25488: PPUSH
// if not mc_bases then
25489: LD_EXP 78
25493: NOT
25494: IFFALSE 25498
// exit ;
25496: GO 25737
// for i = 1 to 8 do
25498: LD_ADDR_VAR 0 2
25502: PUSH
25503: DOUBLE
25504: LD_INT 1
25506: DEC
25507: ST_TO_ADDR
25508: LD_INT 8
25510: PUSH
25511: FOR_TO
25512: IFFALSE 25538
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
25514: LD_ADDR_EXP 105
25518: PUSH
25519: LD_EXP 105
25523: PPUSH
25524: LD_VAR 0 2
25528: PPUSH
25529: EMPTY
25530: PPUSH
25531: CALL_OW 1
25535: ST_TO_ADDR
25536: GO 25511
25538: POP
25539: POP
// tmp := [ ] ;
25540: LD_ADDR_VAR 0 5
25544: PUSH
25545: EMPTY
25546: ST_TO_ADDR
// for i = 1 to mc_sides do
25547: LD_ADDR_VAR 0 2
25551: PUSH
25552: DOUBLE
25553: LD_INT 1
25555: DEC
25556: ST_TO_ADDR
25557: LD_EXP 104
25561: PUSH
25562: FOR_TO
25563: IFFALSE 25621
// if not mc_sides [ i ] in tmp then
25565: LD_EXP 104
25569: PUSH
25570: LD_VAR 0 2
25574: ARRAY
25575: PUSH
25576: LD_VAR 0 5
25580: IN
25581: NOT
25582: IFFALSE 25619
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
25584: LD_ADDR_VAR 0 5
25588: PUSH
25589: LD_VAR 0 5
25593: PPUSH
25594: LD_VAR 0 5
25598: PUSH
25599: LD_INT 1
25601: PLUS
25602: PPUSH
25603: LD_EXP 104
25607: PUSH
25608: LD_VAR 0 2
25612: ARRAY
25613: PPUSH
25614: CALL_OW 2
25618: ST_TO_ADDR
25619: GO 25562
25621: POP
25622: POP
// if not tmp then
25623: LD_VAR 0 5
25627: NOT
25628: IFFALSE 25632
// exit ;
25630: GO 25737
// for j in tmp do
25632: LD_ADDR_VAR 0 3
25636: PUSH
25637: LD_VAR 0 5
25641: PUSH
25642: FOR_IN
25643: IFFALSE 25735
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
25645: LD_ADDR_VAR 0 6
25649: PUSH
25650: LD_INT 22
25652: PUSH
25653: LD_VAR 0 3
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: ST_TO_ADDR
// if not un then
25667: LD_VAR 0 6
25671: NOT
25672: IFFALSE 25676
// continue ;
25674: GO 25642
// nation := GetNation ( un [ 1 ] ) ;
25676: LD_ADDR_VAR 0 4
25680: PUSH
25681: LD_VAR 0 6
25685: PUSH
25686: LD_INT 1
25688: ARRAY
25689: PPUSH
25690: CALL_OW 248
25694: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
25695: LD_ADDR_EXP 105
25699: PUSH
25700: LD_EXP 105
25704: PPUSH
25705: LD_VAR 0 3
25709: PPUSH
25710: LD_VAR 0 3
25714: PPUSH
25715: LD_VAR 0 4
25719: PPUSH
25720: LD_INT 1
25722: PPUSH
25723: CALL 52925 0 3
25727: PPUSH
25728: CALL_OW 1
25732: ST_TO_ADDR
// end ;
25733: GO 25642
25735: POP
25736: POP
// end ;
25737: LD_VAR 0 1
25741: RET
// export function MC_InitSides ( ) ; var i ; begin
25742: LD_INT 0
25744: PPUSH
25745: PPUSH
// if not mc_bases then
25746: LD_EXP 78
25750: NOT
25751: IFFALSE 25755
// exit ;
25753: GO 25829
// for i = 1 to mc_bases do
25755: LD_ADDR_VAR 0 2
25759: PUSH
25760: DOUBLE
25761: LD_INT 1
25763: DEC
25764: ST_TO_ADDR
25765: LD_EXP 78
25769: PUSH
25770: FOR_TO
25771: IFFALSE 25827
// if mc_bases [ i ] then
25773: LD_EXP 78
25777: PUSH
25778: LD_VAR 0 2
25782: ARRAY
25783: IFFALSE 25825
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25785: LD_ADDR_EXP 104
25789: PUSH
25790: LD_EXP 104
25794: PPUSH
25795: LD_VAR 0 2
25799: PPUSH
25800: LD_EXP 78
25804: PUSH
25805: LD_VAR 0 2
25809: ARRAY
25810: PUSH
25811: LD_INT 1
25813: ARRAY
25814: PPUSH
25815: CALL_OW 255
25819: PPUSH
25820: CALL_OW 1
25824: ST_TO_ADDR
25825: GO 25770
25827: POP
25828: POP
// end ;
25829: LD_VAR 0 1
25833: RET
// every 0 0$03 trigger skirmish do
25834: LD_EXP 76
25838: IFFALSE 25992
25840: GO 25842
25842: DISABLE
// begin enable ;
25843: ENABLE
// MC_CheckBuildings ( ) ;
25844: CALL 30504 0 0
// MC_CheckPeopleLife ( ) ;
25848: CALL 30665 0 0
// RaiseSailEvent ( 100 ) ;
25852: LD_INT 100
25854: PPUSH
25855: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25859: LD_INT 103
25861: PPUSH
25862: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25866: LD_INT 104
25868: PPUSH
25869: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25873: LD_INT 105
25875: PPUSH
25876: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25880: LD_INT 106
25882: PPUSH
25883: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25887: LD_INT 107
25889: PPUSH
25890: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25894: LD_INT 108
25896: PPUSH
25897: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25901: LD_INT 109
25903: PPUSH
25904: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25908: LD_INT 110
25910: PPUSH
25911: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25915: LD_INT 111
25917: PPUSH
25918: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25922: LD_INT 112
25924: PPUSH
25925: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25929: LD_INT 113
25931: PPUSH
25932: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25936: LD_INT 120
25938: PPUSH
25939: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25943: LD_INT 121
25945: PPUSH
25946: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25950: LD_INT 122
25952: PPUSH
25953: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25957: LD_INT 123
25959: PPUSH
25960: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25964: LD_INT 124
25966: PPUSH
25967: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25971: LD_INT 125
25973: PPUSH
25974: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25978: LD_INT 126
25980: PPUSH
25981: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25985: LD_INT 200
25987: PPUSH
25988: CALL_OW 427
// end ;
25992: END
// on SailEvent ( event ) do begin if event < 100 then
25993: LD_VAR 0 1
25997: PUSH
25998: LD_INT 100
26000: LESS
26001: IFFALSE 26012
// CustomEvent ( event ) ;
26003: LD_VAR 0 1
26007: PPUSH
26008: CALL 11285 0 1
// if event = 100 then
26012: LD_VAR 0 1
26016: PUSH
26017: LD_INT 100
26019: EQUAL
26020: IFFALSE 26026
// MC_ClassManager ( ) ;
26022: CALL 26418 0 0
// if event = 101 then
26026: LD_VAR 0 1
26030: PUSH
26031: LD_INT 101
26033: EQUAL
26034: IFFALSE 26040
// MC_RepairBuildings ( ) ;
26036: CALL 31250 0 0
// if event = 102 then
26040: LD_VAR 0 1
26044: PUSH
26045: LD_INT 102
26047: EQUAL
26048: IFFALSE 26054
// MC_Heal ( ) ;
26050: CALL 32185 0 0
// if event = 103 then
26054: LD_VAR 0 1
26058: PUSH
26059: LD_INT 103
26061: EQUAL
26062: IFFALSE 26068
// MC_Build ( ) ;
26064: CALL 32607 0 0
// if event = 104 then
26068: LD_VAR 0 1
26072: PUSH
26073: LD_INT 104
26075: EQUAL
26076: IFFALSE 26082
// MC_TurretWeapon ( ) ;
26078: CALL 34241 0 0
// if event = 105 then
26082: LD_VAR 0 1
26086: PUSH
26087: LD_INT 105
26089: EQUAL
26090: IFFALSE 26096
// MC_BuildUpgrade ( ) ;
26092: CALL 33792 0 0
// if event = 106 then
26096: LD_VAR 0 1
26100: PUSH
26101: LD_INT 106
26103: EQUAL
26104: IFFALSE 26110
// MC_PlantMines ( ) ;
26106: CALL 34671 0 0
// if event = 107 then
26110: LD_VAR 0 1
26114: PUSH
26115: LD_INT 107
26117: EQUAL
26118: IFFALSE 26124
// MC_CollectCrates ( ) ;
26120: CALL 35469 0 0
// if event = 108 then
26124: LD_VAR 0 1
26128: PUSH
26129: LD_INT 108
26131: EQUAL
26132: IFFALSE 26138
// MC_LinkRemoteControl ( ) ;
26134: CALL 37319 0 0
// if event = 109 then
26138: LD_VAR 0 1
26142: PUSH
26143: LD_INT 109
26145: EQUAL
26146: IFFALSE 26152
// MC_ProduceVehicle ( ) ;
26148: CALL 37500 0 0
// if event = 110 then
26152: LD_VAR 0 1
26156: PUSH
26157: LD_INT 110
26159: EQUAL
26160: IFFALSE 26166
// MC_SendAttack ( ) ;
26162: CALL 37966 0 0
// if event = 111 then
26166: LD_VAR 0 1
26170: PUSH
26171: LD_INT 111
26173: EQUAL
26174: IFFALSE 26180
// MC_Defend ( ) ;
26176: CALL 38074 0 0
// if event = 112 then
26180: LD_VAR 0 1
26184: PUSH
26185: LD_INT 112
26187: EQUAL
26188: IFFALSE 26194
// MC_Research ( ) ;
26190: CALL 38954 0 0
// if event = 113 then
26194: LD_VAR 0 1
26198: PUSH
26199: LD_INT 113
26201: EQUAL
26202: IFFALSE 26208
// MC_MinesTrigger ( ) ;
26204: CALL 40068 0 0
// if event = 120 then
26208: LD_VAR 0 1
26212: PUSH
26213: LD_INT 120
26215: EQUAL
26216: IFFALSE 26222
// MC_RepairVehicle ( ) ;
26218: CALL 40167 0 0
// if event = 121 then
26222: LD_VAR 0 1
26226: PUSH
26227: LD_INT 121
26229: EQUAL
26230: IFFALSE 26236
// MC_TameApe ( ) ;
26232: CALL 40936 0 0
// if event = 122 then
26236: LD_VAR 0 1
26240: PUSH
26241: LD_INT 122
26243: EQUAL
26244: IFFALSE 26250
// MC_ChangeApeClass ( ) ;
26246: CALL 41765 0 0
// if event = 123 then
26250: LD_VAR 0 1
26254: PUSH
26255: LD_INT 123
26257: EQUAL
26258: IFFALSE 26264
// MC_Bazooka ( ) ;
26260: CALL 42415 0 0
// if event = 124 then
26264: LD_VAR 0 1
26268: PUSH
26269: LD_INT 124
26271: EQUAL
26272: IFFALSE 26278
// MC_TeleportExit ( ) ;
26274: CALL 42613 0 0
// if event = 125 then
26278: LD_VAR 0 1
26282: PUSH
26283: LD_INT 125
26285: EQUAL
26286: IFFALSE 26292
// MC_Deposits ( ) ;
26288: CALL 43260 0 0
// if event = 126 then
26292: LD_VAR 0 1
26296: PUSH
26297: LD_INT 126
26299: EQUAL
26300: IFFALSE 26306
// MC_RemoteDriver ( ) ;
26302: CALL 43885 0 0
// if event = 200 then
26306: LD_VAR 0 1
26310: PUSH
26311: LD_INT 200
26313: EQUAL
26314: IFFALSE 26320
// MC_Idle ( ) ;
26316: CALL 45792 0 0
// end ;
26320: PPOPN 1
26322: END
// export function MC_Reset ( base , tag ) ; var i ; begin
26323: LD_INT 0
26325: PPUSH
26326: PPUSH
// if not mc_bases [ base ] or not tag then
26327: LD_EXP 78
26331: PUSH
26332: LD_VAR 0 1
26336: ARRAY
26337: NOT
26338: PUSH
26339: LD_VAR 0 2
26343: NOT
26344: OR
26345: IFFALSE 26349
// exit ;
26347: GO 26413
// for i in mc_bases [ base ] union mc_ape [ base ] do
26349: LD_ADDR_VAR 0 4
26353: PUSH
26354: LD_EXP 78
26358: PUSH
26359: LD_VAR 0 1
26363: ARRAY
26364: PUSH
26365: LD_EXP 107
26369: PUSH
26370: LD_VAR 0 1
26374: ARRAY
26375: UNION
26376: PUSH
26377: FOR_IN
26378: IFFALSE 26411
// if GetTag ( i ) = tag then
26380: LD_VAR 0 4
26384: PPUSH
26385: CALL_OW 110
26389: PUSH
26390: LD_VAR 0 2
26394: EQUAL
26395: IFFALSE 26409
// SetTag ( i , 0 ) ;
26397: LD_VAR 0 4
26401: PPUSH
26402: LD_INT 0
26404: PPUSH
26405: CALL_OW 109
26409: GO 26377
26411: POP
26412: POP
// end ;
26413: LD_VAR 0 3
26417: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
26418: LD_INT 0
26420: PPUSH
26421: PPUSH
26422: PPUSH
26423: PPUSH
26424: PPUSH
26425: PPUSH
26426: PPUSH
26427: PPUSH
// if not mc_bases then
26428: LD_EXP 78
26432: NOT
26433: IFFALSE 26437
// exit ;
26435: GO 26886
// for i = 1 to mc_bases do
26437: LD_ADDR_VAR 0 2
26441: PUSH
26442: DOUBLE
26443: LD_INT 1
26445: DEC
26446: ST_TO_ADDR
26447: LD_EXP 78
26451: PUSH
26452: FOR_TO
26453: IFFALSE 26884
// begin tmp := MC_ClassCheckReq ( i ) ;
26455: LD_ADDR_VAR 0 4
26459: PUSH
26460: LD_VAR 0 2
26464: PPUSH
26465: CALL 26891 0 1
26469: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
26470: LD_ADDR_EXP 119
26474: PUSH
26475: LD_EXP 119
26479: PPUSH
26480: LD_VAR 0 2
26484: PPUSH
26485: LD_VAR 0 4
26489: PPUSH
26490: CALL_OW 1
26494: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
26495: LD_ADDR_VAR 0 6
26499: PUSH
26500: LD_EXP 78
26504: PUSH
26505: LD_VAR 0 2
26509: ARRAY
26510: PPUSH
26511: LD_INT 2
26513: PUSH
26514: LD_INT 30
26516: PUSH
26517: LD_INT 4
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: PUSH
26524: LD_INT 30
26526: PUSH
26527: LD_INT 5
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: LIST
26538: PPUSH
26539: CALL_OW 72
26543: PUSH
26544: LD_EXP 78
26548: PUSH
26549: LD_VAR 0 2
26553: ARRAY
26554: PPUSH
26555: LD_INT 2
26557: PUSH
26558: LD_INT 30
26560: PUSH
26561: LD_INT 0
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: PUSH
26568: LD_INT 30
26570: PUSH
26571: LD_INT 1
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: LIST
26582: PPUSH
26583: CALL_OW 72
26587: PUSH
26588: LD_EXP 78
26592: PUSH
26593: LD_VAR 0 2
26597: ARRAY
26598: PPUSH
26599: LD_INT 30
26601: PUSH
26602: LD_INT 3
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PPUSH
26609: CALL_OW 72
26613: PUSH
26614: LD_EXP 78
26618: PUSH
26619: LD_VAR 0 2
26623: ARRAY
26624: PPUSH
26625: LD_INT 2
26627: PUSH
26628: LD_INT 30
26630: PUSH
26631: LD_INT 6
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PUSH
26638: LD_INT 30
26640: PUSH
26641: LD_INT 7
26643: PUSH
26644: EMPTY
26645: LIST
26646: LIST
26647: PUSH
26648: LD_INT 30
26650: PUSH
26651: LD_INT 8
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: LIST
26662: LIST
26663: PPUSH
26664: CALL_OW 72
26668: PUSH
26669: EMPTY
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: ST_TO_ADDR
// for j := 1 to 4 do
26675: LD_ADDR_VAR 0 3
26679: PUSH
26680: DOUBLE
26681: LD_INT 1
26683: DEC
26684: ST_TO_ADDR
26685: LD_INT 4
26687: PUSH
26688: FOR_TO
26689: IFFALSE 26880
// begin if not tmp [ j ] then
26691: LD_VAR 0 4
26695: PUSH
26696: LD_VAR 0 3
26700: ARRAY
26701: NOT
26702: IFFALSE 26706
// continue ;
26704: GO 26688
// for p in tmp [ j ] do
26706: LD_ADDR_VAR 0 5
26710: PUSH
26711: LD_VAR 0 4
26715: PUSH
26716: LD_VAR 0 3
26720: ARRAY
26721: PUSH
26722: FOR_IN
26723: IFFALSE 26876
// begin if not b [ j ] then
26725: LD_VAR 0 6
26729: PUSH
26730: LD_VAR 0 3
26734: ARRAY
26735: NOT
26736: IFFALSE 26740
// break ;
26738: GO 26876
// e := 0 ;
26740: LD_ADDR_VAR 0 7
26744: PUSH
26745: LD_INT 0
26747: ST_TO_ADDR
// for k in b [ j ] do
26748: LD_ADDR_VAR 0 8
26752: PUSH
26753: LD_VAR 0 6
26757: PUSH
26758: LD_VAR 0 3
26762: ARRAY
26763: PUSH
26764: FOR_IN
26765: IFFALSE 26792
// if IsNotFull ( k ) then
26767: LD_VAR 0 8
26771: PPUSH
26772: CALL 55046 0 1
26776: IFFALSE 26790
// begin e := k ;
26778: LD_ADDR_VAR 0 7
26782: PUSH
26783: LD_VAR 0 8
26787: ST_TO_ADDR
// break ;
26788: GO 26792
// end ;
26790: GO 26764
26792: POP
26793: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26794: LD_VAR 0 7
26798: PUSH
26799: LD_VAR 0 5
26803: PPUSH
26804: LD_VAR 0 7
26808: PPUSH
26809: CALL 89196 0 2
26813: NOT
26814: AND
26815: IFFALSE 26874
// begin if IsInUnit ( p ) then
26817: LD_VAR 0 5
26821: PPUSH
26822: CALL_OW 310
26826: IFFALSE 26837
// ComExitBuilding ( p ) ;
26828: LD_VAR 0 5
26832: PPUSH
26833: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26837: LD_VAR 0 5
26841: PPUSH
26842: LD_VAR 0 7
26846: PPUSH
26847: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26851: LD_VAR 0 5
26855: PPUSH
26856: LD_VAR 0 3
26860: PPUSH
26861: CALL_OW 183
// AddComExitBuilding ( p ) ;
26865: LD_VAR 0 5
26869: PPUSH
26870: CALL_OW 182
// end ; end ;
26874: GO 26722
26876: POP
26877: POP
// end ;
26878: GO 26688
26880: POP
26881: POP
// end ;
26882: GO 26452
26884: POP
26885: POP
// end ;
26886: LD_VAR 0 1
26890: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26891: LD_INT 0
26893: PPUSH
26894: PPUSH
26895: PPUSH
26896: PPUSH
26897: PPUSH
26898: PPUSH
26899: PPUSH
26900: PPUSH
26901: PPUSH
26902: PPUSH
26903: PPUSH
26904: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
26905: LD_ADDR_VAR 0 2
26909: PUSH
26910: LD_INT 0
26912: PUSH
26913: LD_INT 0
26915: PUSH
26916: LD_INT 0
26918: PUSH
26919: LD_INT 0
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: LIST
26926: LIST
26927: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26928: LD_VAR 0 1
26932: NOT
26933: PUSH
26934: LD_EXP 78
26938: PUSH
26939: LD_VAR 0 1
26943: ARRAY
26944: NOT
26945: OR
26946: PUSH
26947: LD_EXP 78
26951: PUSH
26952: LD_VAR 0 1
26956: ARRAY
26957: PPUSH
26958: LD_INT 2
26960: PUSH
26961: LD_INT 30
26963: PUSH
26964: LD_INT 0
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: PUSH
26971: LD_INT 30
26973: PUSH
26974: LD_INT 1
26976: PUSH
26977: EMPTY
26978: LIST
26979: LIST
26980: PUSH
26981: EMPTY
26982: LIST
26983: LIST
26984: LIST
26985: PPUSH
26986: CALL_OW 72
26990: NOT
26991: OR
26992: IFFALSE 26996
// exit ;
26994: GO 30499
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26996: LD_ADDR_VAR 0 4
27000: PUSH
27001: LD_EXP 78
27005: PUSH
27006: LD_VAR 0 1
27010: ARRAY
27011: PPUSH
27012: LD_INT 2
27014: PUSH
27015: LD_INT 25
27017: PUSH
27018: LD_INT 1
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PUSH
27025: LD_INT 25
27027: PUSH
27028: LD_INT 2
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: PUSH
27035: LD_INT 25
27037: PUSH
27038: LD_INT 3
27040: PUSH
27041: EMPTY
27042: LIST
27043: LIST
27044: PUSH
27045: LD_INT 25
27047: PUSH
27048: LD_INT 4
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PUSH
27055: LD_INT 25
27057: PUSH
27058: LD_INT 5
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: PUSH
27065: LD_INT 25
27067: PUSH
27068: LD_INT 8
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: LD_INT 25
27077: PUSH
27078: LD_INT 9
27080: PUSH
27081: EMPTY
27082: LIST
27083: LIST
27084: PUSH
27085: EMPTY
27086: LIST
27087: LIST
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: PPUSH
27095: CALL_OW 72
27099: ST_TO_ADDR
// if not tmp then
27100: LD_VAR 0 4
27104: NOT
27105: IFFALSE 27109
// exit ;
27107: GO 30499
// for i in tmp do
27109: LD_ADDR_VAR 0 3
27113: PUSH
27114: LD_VAR 0 4
27118: PUSH
27119: FOR_IN
27120: IFFALSE 27151
// if GetTag ( i ) then
27122: LD_VAR 0 3
27126: PPUSH
27127: CALL_OW 110
27131: IFFALSE 27149
// tmp := tmp diff i ;
27133: LD_ADDR_VAR 0 4
27137: PUSH
27138: LD_VAR 0 4
27142: PUSH
27143: LD_VAR 0 3
27147: DIFF
27148: ST_TO_ADDR
27149: GO 27119
27151: POP
27152: POP
// if not tmp then
27153: LD_VAR 0 4
27157: NOT
27158: IFFALSE 27162
// exit ;
27160: GO 30499
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27162: LD_ADDR_VAR 0 5
27166: PUSH
27167: LD_EXP 78
27171: PUSH
27172: LD_VAR 0 1
27176: ARRAY
27177: PPUSH
27178: LD_INT 2
27180: PUSH
27181: LD_INT 25
27183: PUSH
27184: LD_INT 1
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 25
27193: PUSH
27194: LD_INT 5
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 25
27203: PUSH
27204: LD_INT 8
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: LD_INT 25
27213: PUSH
27214: LD_INT 9
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: LIST
27225: LIST
27226: LIST
27227: PPUSH
27228: CALL_OW 72
27232: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
27233: LD_ADDR_VAR 0 6
27237: PUSH
27238: LD_EXP 78
27242: PUSH
27243: LD_VAR 0 1
27247: ARRAY
27248: PPUSH
27249: LD_INT 25
27251: PUSH
27252: LD_INT 2
27254: PUSH
27255: EMPTY
27256: LIST
27257: LIST
27258: PPUSH
27259: CALL_OW 72
27263: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
27264: LD_ADDR_VAR 0 7
27268: PUSH
27269: LD_EXP 78
27273: PUSH
27274: LD_VAR 0 1
27278: ARRAY
27279: PPUSH
27280: LD_INT 25
27282: PUSH
27283: LD_INT 3
27285: PUSH
27286: EMPTY
27287: LIST
27288: LIST
27289: PPUSH
27290: CALL_OW 72
27294: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
27295: LD_ADDR_VAR 0 8
27299: PUSH
27300: LD_EXP 78
27304: PUSH
27305: LD_VAR 0 1
27309: ARRAY
27310: PPUSH
27311: LD_INT 25
27313: PUSH
27314: LD_INT 4
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: PUSH
27321: LD_INT 24
27323: PUSH
27324: LD_INT 251
27326: PUSH
27327: EMPTY
27328: LIST
27329: LIST
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PPUSH
27335: CALL_OW 72
27339: ST_TO_ADDR
// if mc_is_defending [ base ] then
27340: LD_EXP 121
27344: PUSH
27345: LD_VAR 0 1
27349: ARRAY
27350: IFFALSE 27811
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
27352: LD_ADDR_EXP 120
27356: PUSH
27357: LD_EXP 120
27361: PPUSH
27362: LD_VAR 0 1
27366: PPUSH
27367: LD_INT 4
27369: PPUSH
27370: CALL_OW 1
27374: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
27375: LD_ADDR_VAR 0 12
27379: PUSH
27380: LD_EXP 78
27384: PUSH
27385: LD_VAR 0 1
27389: ARRAY
27390: PPUSH
27391: LD_INT 2
27393: PUSH
27394: LD_INT 30
27396: PUSH
27397: LD_INT 4
27399: PUSH
27400: EMPTY
27401: LIST
27402: LIST
27403: PUSH
27404: LD_INT 30
27406: PUSH
27407: LD_INT 5
27409: PUSH
27410: EMPTY
27411: LIST
27412: LIST
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: LIST
27418: PPUSH
27419: CALL_OW 72
27423: ST_TO_ADDR
// if not b then
27424: LD_VAR 0 12
27428: NOT
27429: IFFALSE 27433
// exit ;
27431: GO 30499
// p := [ ] ;
27433: LD_ADDR_VAR 0 11
27437: PUSH
27438: EMPTY
27439: ST_TO_ADDR
// if sci >= 2 then
27440: LD_VAR 0 8
27444: PUSH
27445: LD_INT 2
27447: GREATEREQUAL
27448: IFFALSE 27479
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
27450: LD_ADDR_VAR 0 8
27454: PUSH
27455: LD_VAR 0 8
27459: PUSH
27460: LD_INT 1
27462: ARRAY
27463: PUSH
27464: LD_VAR 0 8
27468: PUSH
27469: LD_INT 2
27471: ARRAY
27472: PUSH
27473: EMPTY
27474: LIST
27475: LIST
27476: ST_TO_ADDR
27477: GO 27540
// if sci = 1 then
27479: LD_VAR 0 8
27483: PUSH
27484: LD_INT 1
27486: EQUAL
27487: IFFALSE 27508
// sci := [ sci [ 1 ] ] else
27489: LD_ADDR_VAR 0 8
27493: PUSH
27494: LD_VAR 0 8
27498: PUSH
27499: LD_INT 1
27501: ARRAY
27502: PUSH
27503: EMPTY
27504: LIST
27505: ST_TO_ADDR
27506: GO 27540
// if sci = 0 then
27508: LD_VAR 0 8
27512: PUSH
27513: LD_INT 0
27515: EQUAL
27516: IFFALSE 27540
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
27518: LD_ADDR_VAR 0 11
27522: PUSH
27523: LD_VAR 0 4
27527: PPUSH
27528: LD_INT 4
27530: PPUSH
27531: CALL 89068 0 2
27535: PUSH
27536: LD_INT 1
27538: ARRAY
27539: ST_TO_ADDR
// if eng > 4 then
27540: LD_VAR 0 6
27544: PUSH
27545: LD_INT 4
27547: GREATER
27548: IFFALSE 27594
// for i = eng downto 4 do
27550: LD_ADDR_VAR 0 3
27554: PUSH
27555: DOUBLE
27556: LD_VAR 0 6
27560: INC
27561: ST_TO_ADDR
27562: LD_INT 4
27564: PUSH
27565: FOR_DOWNTO
27566: IFFALSE 27592
// eng := eng diff eng [ i ] ;
27568: LD_ADDR_VAR 0 6
27572: PUSH
27573: LD_VAR 0 6
27577: PUSH
27578: LD_VAR 0 6
27582: PUSH
27583: LD_VAR 0 3
27587: ARRAY
27588: DIFF
27589: ST_TO_ADDR
27590: GO 27565
27592: POP
27593: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
27594: LD_ADDR_VAR 0 4
27598: PUSH
27599: LD_VAR 0 4
27603: PUSH
27604: LD_VAR 0 5
27608: PUSH
27609: LD_VAR 0 6
27613: UNION
27614: PUSH
27615: LD_VAR 0 7
27619: UNION
27620: PUSH
27621: LD_VAR 0 8
27625: UNION
27626: DIFF
27627: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
27628: LD_ADDR_VAR 0 13
27632: PUSH
27633: LD_EXP 78
27637: PUSH
27638: LD_VAR 0 1
27642: ARRAY
27643: PPUSH
27644: LD_INT 2
27646: PUSH
27647: LD_INT 30
27649: PUSH
27650: LD_INT 32
27652: PUSH
27653: EMPTY
27654: LIST
27655: LIST
27656: PUSH
27657: LD_INT 30
27659: PUSH
27660: LD_INT 31
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: LIST
27671: PPUSH
27672: CALL_OW 72
27676: PUSH
27677: LD_EXP 78
27681: PUSH
27682: LD_VAR 0 1
27686: ARRAY
27687: PPUSH
27688: LD_INT 2
27690: PUSH
27691: LD_INT 30
27693: PUSH
27694: LD_INT 4
27696: PUSH
27697: EMPTY
27698: LIST
27699: LIST
27700: PUSH
27701: LD_INT 30
27703: PUSH
27704: LD_INT 5
27706: PUSH
27707: EMPTY
27708: LIST
27709: LIST
27710: PUSH
27711: EMPTY
27712: LIST
27713: LIST
27714: LIST
27715: PPUSH
27716: CALL_OW 72
27720: PUSH
27721: LD_INT 6
27723: MUL
27724: PLUS
27725: ST_TO_ADDR
// if bcount < tmp then
27726: LD_VAR 0 13
27730: PUSH
27731: LD_VAR 0 4
27735: LESS
27736: IFFALSE 27782
// for i = tmp downto bcount do
27738: LD_ADDR_VAR 0 3
27742: PUSH
27743: DOUBLE
27744: LD_VAR 0 4
27748: INC
27749: ST_TO_ADDR
27750: LD_VAR 0 13
27754: PUSH
27755: FOR_DOWNTO
27756: IFFALSE 27780
// tmp := Delete ( tmp , tmp ) ;
27758: LD_ADDR_VAR 0 4
27762: PUSH
27763: LD_VAR 0 4
27767: PPUSH
27768: LD_VAR 0 4
27772: PPUSH
27773: CALL_OW 3
27777: ST_TO_ADDR
27778: GO 27755
27780: POP
27781: POP
// result := [ tmp , 0 , 0 , p ] ;
27782: LD_ADDR_VAR 0 2
27786: PUSH
27787: LD_VAR 0 4
27791: PUSH
27792: LD_INT 0
27794: PUSH
27795: LD_INT 0
27797: PUSH
27798: LD_VAR 0 11
27802: PUSH
27803: EMPTY
27804: LIST
27805: LIST
27806: LIST
27807: LIST
27808: ST_TO_ADDR
// exit ;
27809: GO 30499
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27811: LD_EXP 78
27815: PUSH
27816: LD_VAR 0 1
27820: ARRAY
27821: PPUSH
27822: LD_INT 2
27824: PUSH
27825: LD_INT 30
27827: PUSH
27828: LD_INT 6
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: PUSH
27835: LD_INT 30
27837: PUSH
27838: LD_INT 7
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: PUSH
27845: LD_INT 30
27847: PUSH
27848: LD_INT 8
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: LIST
27859: LIST
27860: PPUSH
27861: CALL_OW 72
27865: NOT
27866: PUSH
27867: LD_EXP 78
27871: PUSH
27872: LD_VAR 0 1
27876: ARRAY
27877: PPUSH
27878: LD_INT 30
27880: PUSH
27881: LD_INT 3
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PPUSH
27888: CALL_OW 72
27892: NOT
27893: AND
27894: IFFALSE 27966
// begin if eng = tmp then
27896: LD_VAR 0 6
27900: PUSH
27901: LD_VAR 0 4
27905: EQUAL
27906: IFFALSE 27910
// exit ;
27908: GO 30499
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27910: LD_ADDR_EXP 120
27914: PUSH
27915: LD_EXP 120
27919: PPUSH
27920: LD_VAR 0 1
27924: PPUSH
27925: LD_INT 1
27927: PPUSH
27928: CALL_OW 1
27932: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27933: LD_ADDR_VAR 0 2
27937: PUSH
27938: LD_INT 0
27940: PUSH
27941: LD_VAR 0 4
27945: PUSH
27946: LD_VAR 0 6
27950: DIFF
27951: PUSH
27952: LD_INT 0
27954: PUSH
27955: LD_INT 0
27957: PUSH
27958: EMPTY
27959: LIST
27960: LIST
27961: LIST
27962: LIST
27963: ST_TO_ADDR
// exit ;
27964: GO 30499
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27966: LD_EXP 105
27970: PUSH
27971: LD_EXP 104
27975: PUSH
27976: LD_VAR 0 1
27980: ARRAY
27981: ARRAY
27982: PUSH
27983: LD_EXP 78
27987: PUSH
27988: LD_VAR 0 1
27992: ARRAY
27993: PPUSH
27994: LD_INT 2
27996: PUSH
27997: LD_INT 30
27999: PUSH
28000: LD_INT 6
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 30
28009: PUSH
28010: LD_INT 7
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: PUSH
28017: LD_INT 30
28019: PUSH
28020: LD_INT 8
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: LIST
28031: LIST
28032: PPUSH
28033: CALL_OW 72
28037: AND
28038: PUSH
28039: LD_EXP 78
28043: PUSH
28044: LD_VAR 0 1
28048: ARRAY
28049: PPUSH
28050: LD_INT 30
28052: PUSH
28053: LD_INT 3
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PPUSH
28060: CALL_OW 72
28064: NOT
28065: AND
28066: IFFALSE 28280
// begin if sci >= 6 then
28068: LD_VAR 0 8
28072: PUSH
28073: LD_INT 6
28075: GREATEREQUAL
28076: IFFALSE 28080
// exit ;
28078: GO 30499
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28080: LD_ADDR_EXP 120
28084: PUSH
28085: LD_EXP 120
28089: PPUSH
28090: LD_VAR 0 1
28094: PPUSH
28095: LD_INT 2
28097: PPUSH
28098: CALL_OW 1
28102: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28103: LD_ADDR_VAR 0 9
28107: PUSH
28108: LD_VAR 0 4
28112: PUSH
28113: LD_VAR 0 8
28117: DIFF
28118: PPUSH
28119: LD_INT 4
28121: PPUSH
28122: CALL 89068 0 2
28126: ST_TO_ADDR
// p := [ ] ;
28127: LD_ADDR_VAR 0 11
28131: PUSH
28132: EMPTY
28133: ST_TO_ADDR
// if sci < 6 and sort > 6 then
28134: LD_VAR 0 8
28138: PUSH
28139: LD_INT 6
28141: LESS
28142: PUSH
28143: LD_VAR 0 9
28147: PUSH
28148: LD_INT 6
28150: GREATER
28151: AND
28152: IFFALSE 28233
// begin for i = 1 to 6 - sci do
28154: LD_ADDR_VAR 0 3
28158: PUSH
28159: DOUBLE
28160: LD_INT 1
28162: DEC
28163: ST_TO_ADDR
28164: LD_INT 6
28166: PUSH
28167: LD_VAR 0 8
28171: MINUS
28172: PUSH
28173: FOR_TO
28174: IFFALSE 28229
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
28176: LD_ADDR_VAR 0 11
28180: PUSH
28181: LD_VAR 0 11
28185: PPUSH
28186: LD_VAR 0 11
28190: PUSH
28191: LD_INT 1
28193: PLUS
28194: PPUSH
28195: LD_VAR 0 9
28199: PUSH
28200: LD_INT 1
28202: ARRAY
28203: PPUSH
28204: CALL_OW 2
28208: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
28209: LD_ADDR_VAR 0 9
28213: PUSH
28214: LD_VAR 0 9
28218: PPUSH
28219: LD_INT 1
28221: PPUSH
28222: CALL_OW 3
28226: ST_TO_ADDR
// end ;
28227: GO 28173
28229: POP
28230: POP
// end else
28231: GO 28253
// if sort then
28233: LD_VAR 0 9
28237: IFFALSE 28253
// p := sort [ 1 ] ;
28239: LD_ADDR_VAR 0 11
28243: PUSH
28244: LD_VAR 0 9
28248: PUSH
28249: LD_INT 1
28251: ARRAY
28252: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
28253: LD_ADDR_VAR 0 2
28257: PUSH
28258: LD_INT 0
28260: PUSH
28261: LD_INT 0
28263: PUSH
28264: LD_INT 0
28266: PUSH
28267: LD_VAR 0 11
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: LIST
28276: LIST
28277: ST_TO_ADDR
// exit ;
28278: GO 30499
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28280: LD_EXP 105
28284: PUSH
28285: LD_EXP 104
28289: PUSH
28290: LD_VAR 0 1
28294: ARRAY
28295: ARRAY
28296: PUSH
28297: LD_EXP 78
28301: PUSH
28302: LD_VAR 0 1
28306: ARRAY
28307: PPUSH
28308: LD_INT 2
28310: PUSH
28311: LD_INT 30
28313: PUSH
28314: LD_INT 6
28316: PUSH
28317: EMPTY
28318: LIST
28319: LIST
28320: PUSH
28321: LD_INT 30
28323: PUSH
28324: LD_INT 7
28326: PUSH
28327: EMPTY
28328: LIST
28329: LIST
28330: PUSH
28331: LD_INT 30
28333: PUSH
28334: LD_INT 8
28336: PUSH
28337: EMPTY
28338: LIST
28339: LIST
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: LIST
28345: LIST
28346: PPUSH
28347: CALL_OW 72
28351: AND
28352: PUSH
28353: LD_EXP 78
28357: PUSH
28358: LD_VAR 0 1
28362: ARRAY
28363: PPUSH
28364: LD_INT 30
28366: PUSH
28367: LD_INT 3
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PPUSH
28374: CALL_OW 72
28378: AND
28379: IFFALSE 29113
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
28381: LD_ADDR_EXP 120
28385: PUSH
28386: LD_EXP 120
28390: PPUSH
28391: LD_VAR 0 1
28395: PPUSH
28396: LD_INT 3
28398: PPUSH
28399: CALL_OW 1
28403: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28404: LD_ADDR_VAR 0 2
28408: PUSH
28409: LD_INT 0
28411: PUSH
28412: LD_INT 0
28414: PUSH
28415: LD_INT 0
28417: PUSH
28418: LD_INT 0
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: ST_TO_ADDR
// if not eng then
28427: LD_VAR 0 6
28431: NOT
28432: IFFALSE 28495
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
28434: LD_ADDR_VAR 0 11
28438: PUSH
28439: LD_VAR 0 4
28443: PPUSH
28444: LD_INT 2
28446: PPUSH
28447: CALL 89068 0 2
28451: PUSH
28452: LD_INT 1
28454: ARRAY
28455: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
28456: LD_ADDR_VAR 0 2
28460: PUSH
28461: LD_VAR 0 2
28465: PPUSH
28466: LD_INT 2
28468: PPUSH
28469: LD_VAR 0 11
28473: PPUSH
28474: CALL_OW 1
28478: ST_TO_ADDR
// tmp := tmp diff p ;
28479: LD_ADDR_VAR 0 4
28483: PUSH
28484: LD_VAR 0 4
28488: PUSH
28489: LD_VAR 0 11
28493: DIFF
28494: ST_TO_ADDR
// end ; if tmp and sci < 6 then
28495: LD_VAR 0 4
28499: PUSH
28500: LD_VAR 0 8
28504: PUSH
28505: LD_INT 6
28507: LESS
28508: AND
28509: IFFALSE 28697
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
28511: LD_ADDR_VAR 0 9
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: LD_VAR 0 8
28525: PUSH
28526: LD_VAR 0 7
28530: UNION
28531: DIFF
28532: PPUSH
28533: LD_INT 4
28535: PPUSH
28536: CALL 89068 0 2
28540: ST_TO_ADDR
// p := [ ] ;
28541: LD_ADDR_VAR 0 11
28545: PUSH
28546: EMPTY
28547: ST_TO_ADDR
// if sort then
28548: LD_VAR 0 9
28552: IFFALSE 28668
// for i = 1 to 6 - sci do
28554: LD_ADDR_VAR 0 3
28558: PUSH
28559: DOUBLE
28560: LD_INT 1
28562: DEC
28563: ST_TO_ADDR
28564: LD_INT 6
28566: PUSH
28567: LD_VAR 0 8
28571: MINUS
28572: PUSH
28573: FOR_TO
28574: IFFALSE 28666
// begin if i = sort then
28576: LD_VAR 0 3
28580: PUSH
28581: LD_VAR 0 9
28585: EQUAL
28586: IFFALSE 28590
// break ;
28588: GO 28666
// if GetClass ( i ) = 4 then
28590: LD_VAR 0 3
28594: PPUSH
28595: CALL_OW 257
28599: PUSH
28600: LD_INT 4
28602: EQUAL
28603: IFFALSE 28607
// continue ;
28605: GO 28573
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28607: LD_ADDR_VAR 0 11
28611: PUSH
28612: LD_VAR 0 11
28616: PPUSH
28617: LD_VAR 0 11
28621: PUSH
28622: LD_INT 1
28624: PLUS
28625: PPUSH
28626: LD_VAR 0 9
28630: PUSH
28631: LD_VAR 0 3
28635: ARRAY
28636: PPUSH
28637: CALL_OW 2
28641: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28642: LD_ADDR_VAR 0 4
28646: PUSH
28647: LD_VAR 0 4
28651: PUSH
28652: LD_VAR 0 9
28656: PUSH
28657: LD_VAR 0 3
28661: ARRAY
28662: DIFF
28663: ST_TO_ADDR
// end ;
28664: GO 28573
28666: POP
28667: POP
// if p then
28668: LD_VAR 0 11
28672: IFFALSE 28697
// result := Replace ( result , 4 , p ) ;
28674: LD_ADDR_VAR 0 2
28678: PUSH
28679: LD_VAR 0 2
28683: PPUSH
28684: LD_INT 4
28686: PPUSH
28687: LD_VAR 0 11
28691: PPUSH
28692: CALL_OW 1
28696: ST_TO_ADDR
// end ; if tmp and mech < 6 then
28697: LD_VAR 0 4
28701: PUSH
28702: LD_VAR 0 7
28706: PUSH
28707: LD_INT 6
28709: LESS
28710: AND
28711: IFFALSE 28899
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28713: LD_ADDR_VAR 0 9
28717: PUSH
28718: LD_VAR 0 4
28722: PUSH
28723: LD_VAR 0 8
28727: PUSH
28728: LD_VAR 0 7
28732: UNION
28733: DIFF
28734: PPUSH
28735: LD_INT 3
28737: PPUSH
28738: CALL 89068 0 2
28742: ST_TO_ADDR
// p := [ ] ;
28743: LD_ADDR_VAR 0 11
28747: PUSH
28748: EMPTY
28749: ST_TO_ADDR
// if sort then
28750: LD_VAR 0 9
28754: IFFALSE 28870
// for i = 1 to 6 - mech do
28756: LD_ADDR_VAR 0 3
28760: PUSH
28761: DOUBLE
28762: LD_INT 1
28764: DEC
28765: ST_TO_ADDR
28766: LD_INT 6
28768: PUSH
28769: LD_VAR 0 7
28773: MINUS
28774: PUSH
28775: FOR_TO
28776: IFFALSE 28868
// begin if i = sort then
28778: LD_VAR 0 3
28782: PUSH
28783: LD_VAR 0 9
28787: EQUAL
28788: IFFALSE 28792
// break ;
28790: GO 28868
// if GetClass ( i ) = 3 then
28792: LD_VAR 0 3
28796: PPUSH
28797: CALL_OW 257
28801: PUSH
28802: LD_INT 3
28804: EQUAL
28805: IFFALSE 28809
// continue ;
28807: GO 28775
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28809: LD_ADDR_VAR 0 11
28813: PUSH
28814: LD_VAR 0 11
28818: PPUSH
28819: LD_VAR 0 11
28823: PUSH
28824: LD_INT 1
28826: PLUS
28827: PPUSH
28828: LD_VAR 0 9
28832: PUSH
28833: LD_VAR 0 3
28837: ARRAY
28838: PPUSH
28839: CALL_OW 2
28843: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28844: LD_ADDR_VAR 0 4
28848: PUSH
28849: LD_VAR 0 4
28853: PUSH
28854: LD_VAR 0 9
28858: PUSH
28859: LD_VAR 0 3
28863: ARRAY
28864: DIFF
28865: ST_TO_ADDR
// end ;
28866: GO 28775
28868: POP
28869: POP
// if p then
28870: LD_VAR 0 11
28874: IFFALSE 28899
// result := Replace ( result , 3 , p ) ;
28876: LD_ADDR_VAR 0 2
28880: PUSH
28881: LD_VAR 0 2
28885: PPUSH
28886: LD_INT 3
28888: PPUSH
28889: LD_VAR 0 11
28893: PPUSH
28894: CALL_OW 1
28898: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28899: LD_VAR 0 4
28903: PUSH
28904: LD_INT 6
28906: GREATER
28907: PUSH
28908: LD_VAR 0 6
28912: PUSH
28913: LD_INT 6
28915: LESS
28916: AND
28917: IFFALSE 29111
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28919: LD_ADDR_VAR 0 9
28923: PUSH
28924: LD_VAR 0 4
28928: PUSH
28929: LD_VAR 0 8
28933: PUSH
28934: LD_VAR 0 7
28938: UNION
28939: PUSH
28940: LD_VAR 0 6
28944: UNION
28945: DIFF
28946: PPUSH
28947: LD_INT 2
28949: PPUSH
28950: CALL 89068 0 2
28954: ST_TO_ADDR
// p := [ ] ;
28955: LD_ADDR_VAR 0 11
28959: PUSH
28960: EMPTY
28961: ST_TO_ADDR
// if sort then
28962: LD_VAR 0 9
28966: IFFALSE 29082
// for i = 1 to 6 - eng do
28968: LD_ADDR_VAR 0 3
28972: PUSH
28973: DOUBLE
28974: LD_INT 1
28976: DEC
28977: ST_TO_ADDR
28978: LD_INT 6
28980: PUSH
28981: LD_VAR 0 6
28985: MINUS
28986: PUSH
28987: FOR_TO
28988: IFFALSE 29080
// begin if i = sort then
28990: LD_VAR 0 3
28994: PUSH
28995: LD_VAR 0 9
28999: EQUAL
29000: IFFALSE 29004
// break ;
29002: GO 29080
// if GetClass ( i ) = 2 then
29004: LD_VAR 0 3
29008: PPUSH
29009: CALL_OW 257
29013: PUSH
29014: LD_INT 2
29016: EQUAL
29017: IFFALSE 29021
// continue ;
29019: GO 28987
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29021: LD_ADDR_VAR 0 11
29025: PUSH
29026: LD_VAR 0 11
29030: PPUSH
29031: LD_VAR 0 11
29035: PUSH
29036: LD_INT 1
29038: PLUS
29039: PPUSH
29040: LD_VAR 0 9
29044: PUSH
29045: LD_VAR 0 3
29049: ARRAY
29050: PPUSH
29051: CALL_OW 2
29055: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29056: LD_ADDR_VAR 0 4
29060: PUSH
29061: LD_VAR 0 4
29065: PUSH
29066: LD_VAR 0 9
29070: PUSH
29071: LD_VAR 0 3
29075: ARRAY
29076: DIFF
29077: ST_TO_ADDR
// end ;
29078: GO 28987
29080: POP
29081: POP
// if p then
29082: LD_VAR 0 11
29086: IFFALSE 29111
// result := Replace ( result , 2 , p ) ;
29088: LD_ADDR_VAR 0 2
29092: PUSH
29093: LD_VAR 0 2
29097: PPUSH
29098: LD_INT 2
29100: PPUSH
29101: LD_VAR 0 11
29105: PPUSH
29106: CALL_OW 1
29110: ST_TO_ADDR
// end ; exit ;
29111: GO 30499
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29113: LD_EXP 105
29117: PUSH
29118: LD_EXP 104
29122: PUSH
29123: LD_VAR 0 1
29127: ARRAY
29128: ARRAY
29129: NOT
29130: PUSH
29131: LD_EXP 78
29135: PUSH
29136: LD_VAR 0 1
29140: ARRAY
29141: PPUSH
29142: LD_INT 30
29144: PUSH
29145: LD_INT 3
29147: PUSH
29148: EMPTY
29149: LIST
29150: LIST
29151: PPUSH
29152: CALL_OW 72
29156: AND
29157: PUSH
29158: LD_EXP 83
29162: PUSH
29163: LD_VAR 0 1
29167: ARRAY
29168: AND
29169: IFFALSE 29777
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
29171: LD_ADDR_EXP 120
29175: PUSH
29176: LD_EXP 120
29180: PPUSH
29181: LD_VAR 0 1
29185: PPUSH
29186: LD_INT 5
29188: PPUSH
29189: CALL_OW 1
29193: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29194: LD_ADDR_VAR 0 2
29198: PUSH
29199: LD_INT 0
29201: PUSH
29202: LD_INT 0
29204: PUSH
29205: LD_INT 0
29207: PUSH
29208: LD_INT 0
29210: PUSH
29211: EMPTY
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: ST_TO_ADDR
// if sci > 1 then
29217: LD_VAR 0 8
29221: PUSH
29222: LD_INT 1
29224: GREATER
29225: IFFALSE 29253
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
29227: LD_ADDR_VAR 0 4
29231: PUSH
29232: LD_VAR 0 4
29236: PUSH
29237: LD_VAR 0 8
29241: PUSH
29242: LD_VAR 0 8
29246: PUSH
29247: LD_INT 1
29249: ARRAY
29250: DIFF
29251: DIFF
29252: ST_TO_ADDR
// if tmp and not sci then
29253: LD_VAR 0 4
29257: PUSH
29258: LD_VAR 0 8
29262: NOT
29263: AND
29264: IFFALSE 29333
// begin sort := SortBySkill ( tmp , 4 ) ;
29266: LD_ADDR_VAR 0 9
29270: PUSH
29271: LD_VAR 0 4
29275: PPUSH
29276: LD_INT 4
29278: PPUSH
29279: CALL 89068 0 2
29283: ST_TO_ADDR
// if sort then
29284: LD_VAR 0 9
29288: IFFALSE 29304
// p := sort [ 1 ] ;
29290: LD_ADDR_VAR 0 11
29294: PUSH
29295: LD_VAR 0 9
29299: PUSH
29300: LD_INT 1
29302: ARRAY
29303: ST_TO_ADDR
// if p then
29304: LD_VAR 0 11
29308: IFFALSE 29333
// result := Replace ( result , 4 , p ) ;
29310: LD_ADDR_VAR 0 2
29314: PUSH
29315: LD_VAR 0 2
29319: PPUSH
29320: LD_INT 4
29322: PPUSH
29323: LD_VAR 0 11
29327: PPUSH
29328: CALL_OW 1
29332: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29333: LD_ADDR_VAR 0 4
29337: PUSH
29338: LD_VAR 0 4
29342: PUSH
29343: LD_VAR 0 7
29347: DIFF
29348: ST_TO_ADDR
// if tmp and mech < 6 then
29349: LD_VAR 0 4
29353: PUSH
29354: LD_VAR 0 7
29358: PUSH
29359: LD_INT 6
29361: LESS
29362: AND
29363: IFFALSE 29551
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29365: LD_ADDR_VAR 0 9
29369: PUSH
29370: LD_VAR 0 4
29374: PUSH
29375: LD_VAR 0 8
29379: PUSH
29380: LD_VAR 0 7
29384: UNION
29385: DIFF
29386: PPUSH
29387: LD_INT 3
29389: PPUSH
29390: CALL 89068 0 2
29394: ST_TO_ADDR
// p := [ ] ;
29395: LD_ADDR_VAR 0 11
29399: PUSH
29400: EMPTY
29401: ST_TO_ADDR
// if sort then
29402: LD_VAR 0 9
29406: IFFALSE 29522
// for i = 1 to 6 - mech do
29408: LD_ADDR_VAR 0 3
29412: PUSH
29413: DOUBLE
29414: LD_INT 1
29416: DEC
29417: ST_TO_ADDR
29418: LD_INT 6
29420: PUSH
29421: LD_VAR 0 7
29425: MINUS
29426: PUSH
29427: FOR_TO
29428: IFFALSE 29520
// begin if i = sort then
29430: LD_VAR 0 3
29434: PUSH
29435: LD_VAR 0 9
29439: EQUAL
29440: IFFALSE 29444
// break ;
29442: GO 29520
// if GetClass ( i ) = 3 then
29444: LD_VAR 0 3
29448: PPUSH
29449: CALL_OW 257
29453: PUSH
29454: LD_INT 3
29456: EQUAL
29457: IFFALSE 29461
// continue ;
29459: GO 29427
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29461: LD_ADDR_VAR 0 11
29465: PUSH
29466: LD_VAR 0 11
29470: PPUSH
29471: LD_VAR 0 11
29475: PUSH
29476: LD_INT 1
29478: PLUS
29479: PPUSH
29480: LD_VAR 0 9
29484: PUSH
29485: LD_VAR 0 3
29489: ARRAY
29490: PPUSH
29491: CALL_OW 2
29495: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29496: LD_ADDR_VAR 0 4
29500: PUSH
29501: LD_VAR 0 4
29505: PUSH
29506: LD_VAR 0 9
29510: PUSH
29511: LD_VAR 0 3
29515: ARRAY
29516: DIFF
29517: ST_TO_ADDR
// end ;
29518: GO 29427
29520: POP
29521: POP
// if p then
29522: LD_VAR 0 11
29526: IFFALSE 29551
// result := Replace ( result , 3 , p ) ;
29528: LD_ADDR_VAR 0 2
29532: PUSH
29533: LD_VAR 0 2
29537: PPUSH
29538: LD_INT 3
29540: PPUSH
29541: LD_VAR 0 11
29545: PPUSH
29546: CALL_OW 1
29550: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29551: LD_ADDR_VAR 0 4
29555: PUSH
29556: LD_VAR 0 4
29560: PUSH
29561: LD_VAR 0 6
29565: DIFF
29566: ST_TO_ADDR
// if tmp and eng < 6 then
29567: LD_VAR 0 4
29571: PUSH
29572: LD_VAR 0 6
29576: PUSH
29577: LD_INT 6
29579: LESS
29580: AND
29581: IFFALSE 29775
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29583: LD_ADDR_VAR 0 9
29587: PUSH
29588: LD_VAR 0 4
29592: PUSH
29593: LD_VAR 0 8
29597: PUSH
29598: LD_VAR 0 7
29602: UNION
29603: PUSH
29604: LD_VAR 0 6
29608: UNION
29609: DIFF
29610: PPUSH
29611: LD_INT 2
29613: PPUSH
29614: CALL 89068 0 2
29618: ST_TO_ADDR
// p := [ ] ;
29619: LD_ADDR_VAR 0 11
29623: PUSH
29624: EMPTY
29625: ST_TO_ADDR
// if sort then
29626: LD_VAR 0 9
29630: IFFALSE 29746
// for i = 1 to 6 - eng do
29632: LD_ADDR_VAR 0 3
29636: PUSH
29637: DOUBLE
29638: LD_INT 1
29640: DEC
29641: ST_TO_ADDR
29642: LD_INT 6
29644: PUSH
29645: LD_VAR 0 6
29649: MINUS
29650: PUSH
29651: FOR_TO
29652: IFFALSE 29744
// begin if i = sort then
29654: LD_VAR 0 3
29658: PUSH
29659: LD_VAR 0 9
29663: EQUAL
29664: IFFALSE 29668
// break ;
29666: GO 29744
// if GetClass ( i ) = 2 then
29668: LD_VAR 0 3
29672: PPUSH
29673: CALL_OW 257
29677: PUSH
29678: LD_INT 2
29680: EQUAL
29681: IFFALSE 29685
// continue ;
29683: GO 29651
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29685: LD_ADDR_VAR 0 11
29689: PUSH
29690: LD_VAR 0 11
29694: PPUSH
29695: LD_VAR 0 11
29699: PUSH
29700: LD_INT 1
29702: PLUS
29703: PPUSH
29704: LD_VAR 0 9
29708: PUSH
29709: LD_VAR 0 3
29713: ARRAY
29714: PPUSH
29715: CALL_OW 2
29719: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29720: LD_ADDR_VAR 0 4
29724: PUSH
29725: LD_VAR 0 4
29729: PUSH
29730: LD_VAR 0 9
29734: PUSH
29735: LD_VAR 0 3
29739: ARRAY
29740: DIFF
29741: ST_TO_ADDR
// end ;
29742: GO 29651
29744: POP
29745: POP
// if p then
29746: LD_VAR 0 11
29750: IFFALSE 29775
// result := Replace ( result , 2 , p ) ;
29752: LD_ADDR_VAR 0 2
29756: PUSH
29757: LD_VAR 0 2
29761: PPUSH
29762: LD_INT 2
29764: PPUSH
29765: LD_VAR 0 11
29769: PPUSH
29770: CALL_OW 1
29774: ST_TO_ADDR
// end ; exit ;
29775: GO 30499
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
29777: LD_EXP 105
29781: PUSH
29782: LD_EXP 104
29786: PUSH
29787: LD_VAR 0 1
29791: ARRAY
29792: ARRAY
29793: NOT
29794: PUSH
29795: LD_EXP 78
29799: PUSH
29800: LD_VAR 0 1
29804: ARRAY
29805: PPUSH
29806: LD_INT 30
29808: PUSH
29809: LD_INT 3
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PPUSH
29816: CALL_OW 72
29820: AND
29821: PUSH
29822: LD_EXP 83
29826: PUSH
29827: LD_VAR 0 1
29831: ARRAY
29832: NOT
29833: AND
29834: IFFALSE 30499
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29836: LD_ADDR_EXP 120
29840: PUSH
29841: LD_EXP 120
29845: PPUSH
29846: LD_VAR 0 1
29850: PPUSH
29851: LD_INT 6
29853: PPUSH
29854: CALL_OW 1
29858: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29859: LD_ADDR_VAR 0 2
29863: PUSH
29864: LD_INT 0
29866: PUSH
29867: LD_INT 0
29869: PUSH
29870: LD_INT 0
29872: PUSH
29873: LD_INT 0
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: ST_TO_ADDR
// if sci >= 1 then
29882: LD_VAR 0 8
29886: PUSH
29887: LD_INT 1
29889: GREATEREQUAL
29890: IFFALSE 29912
// tmp := tmp diff sci [ 1 ] ;
29892: LD_ADDR_VAR 0 4
29896: PUSH
29897: LD_VAR 0 4
29901: PUSH
29902: LD_VAR 0 8
29906: PUSH
29907: LD_INT 1
29909: ARRAY
29910: DIFF
29911: ST_TO_ADDR
// if tmp and not sci then
29912: LD_VAR 0 4
29916: PUSH
29917: LD_VAR 0 8
29921: NOT
29922: AND
29923: IFFALSE 29992
// begin sort := SortBySkill ( tmp , 4 ) ;
29925: LD_ADDR_VAR 0 9
29929: PUSH
29930: LD_VAR 0 4
29934: PPUSH
29935: LD_INT 4
29937: PPUSH
29938: CALL 89068 0 2
29942: ST_TO_ADDR
// if sort then
29943: LD_VAR 0 9
29947: IFFALSE 29963
// p := sort [ 1 ] ;
29949: LD_ADDR_VAR 0 11
29953: PUSH
29954: LD_VAR 0 9
29958: PUSH
29959: LD_INT 1
29961: ARRAY
29962: ST_TO_ADDR
// if p then
29963: LD_VAR 0 11
29967: IFFALSE 29992
// result := Replace ( result , 4 , p ) ;
29969: LD_ADDR_VAR 0 2
29973: PUSH
29974: LD_VAR 0 2
29978: PPUSH
29979: LD_INT 4
29981: PPUSH
29982: LD_VAR 0 11
29986: PPUSH
29987: CALL_OW 1
29991: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29992: LD_ADDR_VAR 0 4
29996: PUSH
29997: LD_VAR 0 4
30001: PUSH
30002: LD_VAR 0 7
30006: DIFF
30007: ST_TO_ADDR
// if tmp and mech < 6 then
30008: LD_VAR 0 4
30012: PUSH
30013: LD_VAR 0 7
30017: PUSH
30018: LD_INT 6
30020: LESS
30021: AND
30022: IFFALSE 30204
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
30024: LD_ADDR_VAR 0 9
30028: PUSH
30029: LD_VAR 0 4
30033: PUSH
30034: LD_VAR 0 7
30038: DIFF
30039: PPUSH
30040: LD_INT 3
30042: PPUSH
30043: CALL 89068 0 2
30047: ST_TO_ADDR
// p := [ ] ;
30048: LD_ADDR_VAR 0 11
30052: PUSH
30053: EMPTY
30054: ST_TO_ADDR
// if sort then
30055: LD_VAR 0 9
30059: IFFALSE 30175
// for i = 1 to 6 - mech do
30061: LD_ADDR_VAR 0 3
30065: PUSH
30066: DOUBLE
30067: LD_INT 1
30069: DEC
30070: ST_TO_ADDR
30071: LD_INT 6
30073: PUSH
30074: LD_VAR 0 7
30078: MINUS
30079: PUSH
30080: FOR_TO
30081: IFFALSE 30173
// begin if i = sort then
30083: LD_VAR 0 3
30087: PUSH
30088: LD_VAR 0 9
30092: EQUAL
30093: IFFALSE 30097
// break ;
30095: GO 30173
// if GetClass ( i ) = 3 then
30097: LD_VAR 0 3
30101: PPUSH
30102: CALL_OW 257
30106: PUSH
30107: LD_INT 3
30109: EQUAL
30110: IFFALSE 30114
// continue ;
30112: GO 30080
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30114: LD_ADDR_VAR 0 11
30118: PUSH
30119: LD_VAR 0 11
30123: PPUSH
30124: LD_VAR 0 11
30128: PUSH
30129: LD_INT 1
30131: PLUS
30132: PPUSH
30133: LD_VAR 0 9
30137: PUSH
30138: LD_VAR 0 3
30142: ARRAY
30143: PPUSH
30144: CALL_OW 2
30148: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30149: LD_ADDR_VAR 0 4
30153: PUSH
30154: LD_VAR 0 4
30158: PUSH
30159: LD_VAR 0 9
30163: PUSH
30164: LD_VAR 0 3
30168: ARRAY
30169: DIFF
30170: ST_TO_ADDR
// end ;
30171: GO 30080
30173: POP
30174: POP
// if p then
30175: LD_VAR 0 11
30179: IFFALSE 30204
// result := Replace ( result , 3 , p ) ;
30181: LD_ADDR_VAR 0 2
30185: PUSH
30186: LD_VAR 0 2
30190: PPUSH
30191: LD_INT 3
30193: PPUSH
30194: LD_VAR 0 11
30198: PPUSH
30199: CALL_OW 1
30203: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30204: LD_ADDR_VAR 0 4
30208: PUSH
30209: LD_VAR 0 4
30213: PUSH
30214: LD_VAR 0 6
30218: DIFF
30219: ST_TO_ADDR
// if tmp and eng < 4 then
30220: LD_VAR 0 4
30224: PUSH
30225: LD_VAR 0 6
30229: PUSH
30230: LD_INT 4
30232: LESS
30233: AND
30234: IFFALSE 30424
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
30236: LD_ADDR_VAR 0 9
30240: PUSH
30241: LD_VAR 0 4
30245: PUSH
30246: LD_VAR 0 7
30250: PUSH
30251: LD_VAR 0 6
30255: UNION
30256: DIFF
30257: PPUSH
30258: LD_INT 2
30260: PPUSH
30261: CALL 89068 0 2
30265: ST_TO_ADDR
// p := [ ] ;
30266: LD_ADDR_VAR 0 11
30270: PUSH
30271: EMPTY
30272: ST_TO_ADDR
// if sort then
30273: LD_VAR 0 9
30277: IFFALSE 30393
// for i = 1 to 4 - eng do
30279: LD_ADDR_VAR 0 3
30283: PUSH
30284: DOUBLE
30285: LD_INT 1
30287: DEC
30288: ST_TO_ADDR
30289: LD_INT 4
30291: PUSH
30292: LD_VAR 0 6
30296: MINUS
30297: PUSH
30298: FOR_TO
30299: IFFALSE 30391
// begin if i = sort then
30301: LD_VAR 0 3
30305: PUSH
30306: LD_VAR 0 9
30310: EQUAL
30311: IFFALSE 30315
// break ;
30313: GO 30391
// if GetClass ( i ) = 2 then
30315: LD_VAR 0 3
30319: PPUSH
30320: CALL_OW 257
30324: PUSH
30325: LD_INT 2
30327: EQUAL
30328: IFFALSE 30332
// continue ;
30330: GO 30298
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30332: LD_ADDR_VAR 0 11
30336: PUSH
30337: LD_VAR 0 11
30341: PPUSH
30342: LD_VAR 0 11
30346: PUSH
30347: LD_INT 1
30349: PLUS
30350: PPUSH
30351: LD_VAR 0 9
30355: PUSH
30356: LD_VAR 0 3
30360: ARRAY
30361: PPUSH
30362: CALL_OW 2
30366: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30367: LD_ADDR_VAR 0 4
30371: PUSH
30372: LD_VAR 0 4
30376: PUSH
30377: LD_VAR 0 9
30381: PUSH
30382: LD_VAR 0 3
30386: ARRAY
30387: DIFF
30388: ST_TO_ADDR
// end ;
30389: GO 30298
30391: POP
30392: POP
// if p then
30393: LD_VAR 0 11
30397: IFFALSE 30422
// result := Replace ( result , 2 , p ) ;
30399: LD_ADDR_VAR 0 2
30403: PUSH
30404: LD_VAR 0 2
30408: PPUSH
30409: LD_INT 2
30411: PPUSH
30412: LD_VAR 0 11
30416: PPUSH
30417: CALL_OW 1
30421: ST_TO_ADDR
// end else
30422: GO 30468
// for i = eng downto 5 do
30424: LD_ADDR_VAR 0 3
30428: PUSH
30429: DOUBLE
30430: LD_VAR 0 6
30434: INC
30435: ST_TO_ADDR
30436: LD_INT 5
30438: PUSH
30439: FOR_DOWNTO
30440: IFFALSE 30466
// tmp := tmp union eng [ i ] ;
30442: LD_ADDR_VAR 0 4
30446: PUSH
30447: LD_VAR 0 4
30451: PUSH
30452: LD_VAR 0 6
30456: PUSH
30457: LD_VAR 0 3
30461: ARRAY
30462: UNION
30463: ST_TO_ADDR
30464: GO 30439
30466: POP
30467: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
30468: LD_ADDR_VAR 0 2
30472: PUSH
30473: LD_VAR 0 2
30477: PPUSH
30478: LD_INT 1
30480: PPUSH
30481: LD_VAR 0 4
30485: PUSH
30486: LD_VAR 0 5
30490: DIFF
30491: PPUSH
30492: CALL_OW 1
30496: ST_TO_ADDR
// exit ;
30497: GO 30499
// end ; end ;
30499: LD_VAR 0 2
30503: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
30504: LD_INT 0
30506: PPUSH
30507: PPUSH
30508: PPUSH
// if not mc_bases then
30509: LD_EXP 78
30513: NOT
30514: IFFALSE 30518
// exit ;
30516: GO 30660
// for i = 1 to mc_bases do
30518: LD_ADDR_VAR 0 2
30522: PUSH
30523: DOUBLE
30524: LD_INT 1
30526: DEC
30527: ST_TO_ADDR
30528: LD_EXP 78
30532: PUSH
30533: FOR_TO
30534: IFFALSE 30651
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
30536: LD_ADDR_VAR 0 3
30540: PUSH
30541: LD_EXP 78
30545: PUSH
30546: LD_VAR 0 2
30550: ARRAY
30551: PPUSH
30552: LD_INT 21
30554: PUSH
30555: LD_INT 3
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 3
30564: PUSH
30565: LD_INT 2
30567: PUSH
30568: LD_INT 30
30570: PUSH
30571: LD_INT 29
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 30
30580: PUSH
30581: LD_INT 30
30583: PUSH
30584: EMPTY
30585: LIST
30586: LIST
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: LIST
30592: PUSH
30593: EMPTY
30594: LIST
30595: LIST
30596: PUSH
30597: LD_INT 3
30599: PUSH
30600: LD_INT 24
30602: PUSH
30603: LD_INT 1000
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: LIST
30618: PPUSH
30619: CALL_OW 72
30623: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
30624: LD_ADDR_EXP 79
30628: PUSH
30629: LD_EXP 79
30633: PPUSH
30634: LD_VAR 0 2
30638: PPUSH
30639: LD_VAR 0 3
30643: PPUSH
30644: CALL_OW 1
30648: ST_TO_ADDR
// end ;
30649: GO 30533
30651: POP
30652: POP
// RaiseSailEvent ( 101 ) ;
30653: LD_INT 101
30655: PPUSH
30656: CALL_OW 427
// end ;
30660: LD_VAR 0 1
30664: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
30665: LD_INT 0
30667: PPUSH
30668: PPUSH
30669: PPUSH
30670: PPUSH
30671: PPUSH
30672: PPUSH
30673: PPUSH
// if not mc_bases then
30674: LD_EXP 78
30678: NOT
30679: IFFALSE 30683
// exit ;
30681: GO 31245
// for i = 1 to mc_bases do
30683: LD_ADDR_VAR 0 2
30687: PUSH
30688: DOUBLE
30689: LD_INT 1
30691: DEC
30692: ST_TO_ADDR
30693: LD_EXP 78
30697: PUSH
30698: FOR_TO
30699: IFFALSE 31236
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
30701: LD_ADDR_VAR 0 5
30705: PUSH
30706: LD_EXP 78
30710: PUSH
30711: LD_VAR 0 2
30715: ARRAY
30716: PUSH
30717: LD_EXP 107
30721: PUSH
30722: LD_VAR 0 2
30726: ARRAY
30727: UNION
30728: PPUSH
30729: LD_INT 21
30731: PUSH
30732: LD_INT 1
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 1
30741: PUSH
30742: LD_INT 3
30744: PUSH
30745: LD_INT 54
30747: PUSH
30748: EMPTY
30749: LIST
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 3
30757: PUSH
30758: LD_INT 24
30760: PUSH
30761: LD_INT 1000
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: LIST
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PPUSH
30781: CALL_OW 72
30785: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30786: LD_ADDR_VAR 0 6
30790: PUSH
30791: LD_EXP 78
30795: PUSH
30796: LD_VAR 0 2
30800: ARRAY
30801: PPUSH
30802: LD_INT 21
30804: PUSH
30805: LD_INT 1
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 1
30814: PUSH
30815: LD_INT 3
30817: PUSH
30818: LD_INT 54
30820: PUSH
30821: EMPTY
30822: LIST
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: PUSH
30828: LD_INT 3
30830: PUSH
30831: LD_INT 24
30833: PUSH
30834: LD_INT 250
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: LIST
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PPUSH
30854: CALL_OW 72
30858: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30859: LD_ADDR_VAR 0 7
30863: PUSH
30864: LD_VAR 0 5
30868: PUSH
30869: LD_VAR 0 6
30873: DIFF
30874: ST_TO_ADDR
// if not need_heal_1 then
30875: LD_VAR 0 6
30879: NOT
30880: IFFALSE 30913
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30882: LD_ADDR_EXP 81
30886: PUSH
30887: LD_EXP 81
30891: PPUSH
30892: LD_VAR 0 2
30896: PUSH
30897: LD_INT 1
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PPUSH
30904: EMPTY
30905: PPUSH
30906: CALL 57824 0 3
30910: ST_TO_ADDR
30911: GO 30983
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30913: LD_ADDR_EXP 81
30917: PUSH
30918: LD_EXP 81
30922: PPUSH
30923: LD_VAR 0 2
30927: PUSH
30928: LD_INT 1
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: PPUSH
30935: LD_EXP 81
30939: PUSH
30940: LD_VAR 0 2
30944: ARRAY
30945: PUSH
30946: LD_INT 1
30948: ARRAY
30949: PPUSH
30950: LD_INT 3
30952: PUSH
30953: LD_INT 24
30955: PUSH
30956: LD_INT 1000
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PPUSH
30967: CALL_OW 72
30971: PUSH
30972: LD_VAR 0 6
30976: UNION
30977: PPUSH
30978: CALL 57824 0 3
30982: ST_TO_ADDR
// if not need_heal_2 then
30983: LD_VAR 0 7
30987: NOT
30988: IFFALSE 31021
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30990: LD_ADDR_EXP 81
30994: PUSH
30995: LD_EXP 81
30999: PPUSH
31000: LD_VAR 0 2
31004: PUSH
31005: LD_INT 2
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PPUSH
31012: EMPTY
31013: PPUSH
31014: CALL 57824 0 3
31018: ST_TO_ADDR
31019: GO 31053
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
31021: LD_ADDR_EXP 81
31025: PUSH
31026: LD_EXP 81
31030: PPUSH
31031: LD_VAR 0 2
31035: PUSH
31036: LD_INT 2
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PPUSH
31043: LD_VAR 0 7
31047: PPUSH
31048: CALL 57824 0 3
31052: ST_TO_ADDR
// if need_heal_2 then
31053: LD_VAR 0 7
31057: IFFALSE 31218
// for j in need_heal_2 do
31059: LD_ADDR_VAR 0 3
31063: PUSH
31064: LD_VAR 0 7
31068: PUSH
31069: FOR_IN
31070: IFFALSE 31216
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31072: LD_ADDR_VAR 0 5
31076: PUSH
31077: LD_EXP 78
31081: PUSH
31082: LD_VAR 0 2
31086: ARRAY
31087: PPUSH
31088: LD_INT 2
31090: PUSH
31091: LD_INT 30
31093: PUSH
31094: LD_INT 6
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 30
31103: PUSH
31104: LD_INT 7
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 30
31113: PUSH
31114: LD_INT 8
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 30
31123: PUSH
31124: LD_INT 0
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PUSH
31131: LD_INT 30
31133: PUSH
31134: LD_INT 1
31136: PUSH
31137: EMPTY
31138: LIST
31139: LIST
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: PPUSH
31149: CALL_OW 72
31153: ST_TO_ADDR
// if tmp then
31154: LD_VAR 0 5
31158: IFFALSE 31214
// begin k := NearestUnitToUnit ( tmp , j ) ;
31160: LD_ADDR_VAR 0 4
31164: PUSH
31165: LD_VAR 0 5
31169: PPUSH
31170: LD_VAR 0 3
31174: PPUSH
31175: CALL_OW 74
31179: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
31180: LD_VAR 0 3
31184: PPUSH
31185: LD_VAR 0 4
31189: PPUSH
31190: CALL_OW 296
31194: PUSH
31195: LD_INT 5
31197: GREATER
31198: IFFALSE 31214
// ComMoveToNearbyEntrance ( j , k ) ;
31200: LD_VAR 0 3
31204: PPUSH
31205: LD_VAR 0 4
31209: PPUSH
31210: CALL 91441 0 2
// end ; end ;
31214: GO 31069
31216: POP
31217: POP
// if not need_heal_1 and not need_heal_2 then
31218: LD_VAR 0 6
31222: NOT
31223: PUSH
31224: LD_VAR 0 7
31228: NOT
31229: AND
31230: IFFALSE 31234
// continue ;
31232: GO 30698
// end ;
31234: GO 30698
31236: POP
31237: POP
// RaiseSailEvent ( 102 ) ;
31238: LD_INT 102
31240: PPUSH
31241: CALL_OW 427
// end ;
31245: LD_VAR 0 1
31249: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
31250: LD_INT 0
31252: PPUSH
31253: PPUSH
31254: PPUSH
31255: PPUSH
31256: PPUSH
31257: PPUSH
31258: PPUSH
31259: PPUSH
// if not mc_bases then
31260: LD_EXP 78
31264: NOT
31265: IFFALSE 31269
// exit ;
31267: GO 32180
// for i = 1 to mc_bases do
31269: LD_ADDR_VAR 0 2
31273: PUSH
31274: DOUBLE
31275: LD_INT 1
31277: DEC
31278: ST_TO_ADDR
31279: LD_EXP 78
31283: PUSH
31284: FOR_TO
31285: IFFALSE 32178
// begin if not mc_building_need_repair [ i ] then
31287: LD_EXP 79
31291: PUSH
31292: LD_VAR 0 2
31296: ARRAY
31297: NOT
31298: IFFALSE 31483
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
31300: LD_ADDR_VAR 0 6
31304: PUSH
31305: LD_EXP 97
31309: PUSH
31310: LD_VAR 0 2
31314: ARRAY
31315: PPUSH
31316: LD_INT 3
31318: PUSH
31319: LD_INT 24
31321: PUSH
31322: LD_INT 1000
31324: PUSH
31325: EMPTY
31326: LIST
31327: LIST
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 2
31335: PUSH
31336: LD_INT 34
31338: PUSH
31339: LD_INT 13
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 34
31348: PUSH
31349: LD_INT 52
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 34
31358: PUSH
31359: LD_INT 88
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PPUSH
31376: CALL_OW 72
31380: ST_TO_ADDR
// if cranes then
31381: LD_VAR 0 6
31385: IFFALSE 31447
// for j in cranes do
31387: LD_ADDR_VAR 0 3
31391: PUSH
31392: LD_VAR 0 6
31396: PUSH
31397: FOR_IN
31398: IFFALSE 31445
// if not IsInArea ( j , mc_parking [ i ] ) then
31400: LD_VAR 0 3
31404: PPUSH
31405: LD_EXP 102
31409: PUSH
31410: LD_VAR 0 2
31414: ARRAY
31415: PPUSH
31416: CALL_OW 308
31420: NOT
31421: IFFALSE 31443
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31423: LD_VAR 0 3
31427: PPUSH
31428: LD_EXP 102
31432: PUSH
31433: LD_VAR 0 2
31437: ARRAY
31438: PPUSH
31439: CALL_OW 113
31443: GO 31397
31445: POP
31446: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
31447: LD_ADDR_EXP 80
31451: PUSH
31452: LD_EXP 80
31456: PPUSH
31457: LD_VAR 0 2
31461: PPUSH
31462: EMPTY
31463: PPUSH
31464: CALL_OW 1
31468: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
31469: LD_VAR 0 2
31473: PPUSH
31474: LD_INT 101
31476: PPUSH
31477: CALL 26323 0 2
// continue ;
31481: GO 31284
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
31483: LD_ADDR_EXP 84
31487: PUSH
31488: LD_EXP 84
31492: PPUSH
31493: LD_VAR 0 2
31497: PPUSH
31498: EMPTY
31499: PPUSH
31500: CALL_OW 1
31504: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31505: LD_VAR 0 2
31509: PPUSH
31510: LD_INT 103
31512: PPUSH
31513: CALL 26323 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
31517: LD_ADDR_VAR 0 5
31521: PUSH
31522: LD_EXP 78
31526: PUSH
31527: LD_VAR 0 2
31531: ARRAY
31532: PUSH
31533: LD_EXP 107
31537: PUSH
31538: LD_VAR 0 2
31542: ARRAY
31543: UNION
31544: PPUSH
31545: LD_INT 2
31547: PUSH
31548: LD_INT 25
31550: PUSH
31551: LD_INT 2
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 25
31560: PUSH
31561: LD_INT 16
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: LIST
31572: PUSH
31573: EMPTY
31574: LIST
31575: PPUSH
31576: CALL_OW 72
31580: ST_TO_ADDR
// if mc_need_heal [ i ] then
31581: LD_EXP 81
31585: PUSH
31586: LD_VAR 0 2
31590: ARRAY
31591: IFFALSE 31635
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
31593: LD_ADDR_VAR 0 5
31597: PUSH
31598: LD_VAR 0 5
31602: PUSH
31603: LD_EXP 81
31607: PUSH
31608: LD_VAR 0 2
31612: ARRAY
31613: PUSH
31614: LD_INT 1
31616: ARRAY
31617: PUSH
31618: LD_EXP 81
31622: PUSH
31623: LD_VAR 0 2
31627: ARRAY
31628: PUSH
31629: LD_INT 2
31631: ARRAY
31632: UNION
31633: DIFF
31634: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
31635: LD_ADDR_VAR 0 6
31639: PUSH
31640: LD_EXP 97
31644: PUSH
31645: LD_VAR 0 2
31649: ARRAY
31650: PPUSH
31651: LD_INT 2
31653: PUSH
31654: LD_INT 34
31656: PUSH
31657: LD_INT 13
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 34
31666: PUSH
31667: LD_INT 52
31669: PUSH
31670: EMPTY
31671: LIST
31672: LIST
31673: PUSH
31674: LD_INT 34
31676: PUSH
31677: LD_INT 88
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: PPUSH
31690: CALL_OW 72
31694: ST_TO_ADDR
// if cranes then
31695: LD_VAR 0 6
31699: IFFALSE 31867
// begin for j in cranes do
31701: LD_ADDR_VAR 0 3
31705: PUSH
31706: LD_VAR 0 6
31710: PUSH
31711: FOR_IN
31712: IFFALSE 31865
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
31714: LD_VAR 0 3
31718: PPUSH
31719: CALL_OW 256
31723: PUSH
31724: LD_INT 1000
31726: EQUAL
31727: PUSH
31728: LD_VAR 0 3
31732: PPUSH
31733: CALL_OW 314
31737: NOT
31738: AND
31739: IFFALSE 31805
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
31741: LD_ADDR_VAR 0 8
31745: PUSH
31746: LD_EXP 79
31750: PUSH
31751: LD_VAR 0 2
31755: ARRAY
31756: PPUSH
31757: LD_VAR 0 3
31761: PPUSH
31762: CALL_OW 74
31766: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31767: LD_VAR 0 8
31771: PPUSH
31772: LD_INT 16
31774: PPUSH
31775: CALL 60789 0 2
31779: PUSH
31780: LD_INT 4
31782: ARRAY
31783: PUSH
31784: LD_INT 10
31786: LESS
31787: IFFALSE 31803
// ComRepairBuilding ( j , to_repair ) ;
31789: LD_VAR 0 3
31793: PPUSH
31794: LD_VAR 0 8
31798: PPUSH
31799: CALL_OW 130
// end else
31803: GO 31863
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
31805: LD_VAR 0 3
31809: PPUSH
31810: CALL_OW 256
31814: PUSH
31815: LD_INT 500
31817: LESS
31818: PUSH
31819: LD_VAR 0 3
31823: PPUSH
31824: LD_EXP 102
31828: PUSH
31829: LD_VAR 0 2
31833: ARRAY
31834: PPUSH
31835: CALL_OW 308
31839: NOT
31840: AND
31841: IFFALSE 31863
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31843: LD_VAR 0 3
31847: PPUSH
31848: LD_EXP 102
31852: PUSH
31853: LD_VAR 0 2
31857: ARRAY
31858: PPUSH
31859: CALL_OW 113
// end ;
31863: GO 31711
31865: POP
31866: POP
// end ; if tmp > 3 then
31867: LD_VAR 0 5
31871: PUSH
31872: LD_INT 3
31874: GREATER
31875: IFFALSE 31895
// tmp := ShrinkArray ( tmp , 4 ) ;
31877: LD_ADDR_VAR 0 5
31881: PUSH
31882: LD_VAR 0 5
31886: PPUSH
31887: LD_INT 4
31889: PPUSH
31890: CALL 90879 0 2
31894: ST_TO_ADDR
// if not tmp then
31895: LD_VAR 0 5
31899: NOT
31900: IFFALSE 31904
// continue ;
31902: GO 31284
// for j in tmp do
31904: LD_ADDR_VAR 0 3
31908: PUSH
31909: LD_VAR 0 5
31913: PUSH
31914: FOR_IN
31915: IFFALSE 32174
// begin if IsInUnit ( j ) then
31917: LD_VAR 0 3
31921: PPUSH
31922: CALL_OW 310
31926: IFFALSE 31937
// ComExitBuilding ( j ) ;
31928: LD_VAR 0 3
31932: PPUSH
31933: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31937: LD_VAR 0 3
31941: PUSH
31942: LD_EXP 80
31946: PUSH
31947: LD_VAR 0 2
31951: ARRAY
31952: IN
31953: NOT
31954: IFFALSE 32012
// begin SetTag ( j , 101 ) ;
31956: LD_VAR 0 3
31960: PPUSH
31961: LD_INT 101
31963: PPUSH
31964: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31968: LD_ADDR_EXP 80
31972: PUSH
31973: LD_EXP 80
31977: PPUSH
31978: LD_VAR 0 2
31982: PUSH
31983: LD_EXP 80
31987: PUSH
31988: LD_VAR 0 2
31992: ARRAY
31993: PUSH
31994: LD_INT 1
31996: PLUS
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PPUSH
32002: LD_VAR 0 3
32006: PPUSH
32007: CALL 57824 0 3
32011: ST_TO_ADDR
// end ; wait ( 1 ) ;
32012: LD_INT 1
32014: PPUSH
32015: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
32019: LD_ADDR_VAR 0 7
32023: PUSH
32024: LD_EXP 79
32028: PUSH
32029: LD_VAR 0 2
32033: ARRAY
32034: ST_TO_ADDR
// if mc_scan [ i ] then
32035: LD_EXP 101
32039: PUSH
32040: LD_VAR 0 2
32044: ARRAY
32045: IFFALSE 32107
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
32047: LD_ADDR_VAR 0 7
32051: PUSH
32052: LD_EXP 79
32056: PUSH
32057: LD_VAR 0 2
32061: ARRAY
32062: PPUSH
32063: LD_INT 3
32065: PUSH
32066: LD_INT 30
32068: PUSH
32069: LD_INT 32
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 30
32078: PUSH
32079: LD_INT 33
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 30
32088: PUSH
32089: LD_INT 31
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: EMPTY
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: PPUSH
32102: CALL_OW 72
32106: ST_TO_ADDR
// if not to_repair_tmp then
32107: LD_VAR 0 7
32111: NOT
32112: IFFALSE 32116
// continue ;
32114: GO 31914
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32116: LD_ADDR_VAR 0 8
32120: PUSH
32121: LD_VAR 0 7
32125: PPUSH
32126: LD_VAR 0 3
32130: PPUSH
32131: CALL_OW 74
32135: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
32136: LD_VAR 0 8
32140: PPUSH
32141: LD_INT 16
32143: PPUSH
32144: CALL 60789 0 2
32148: PUSH
32149: LD_INT 4
32151: ARRAY
32152: PUSH
32153: LD_INT 14
32155: LESS
32156: IFFALSE 32172
// ComRepairBuilding ( j , to_repair ) ;
32158: LD_VAR 0 3
32162: PPUSH
32163: LD_VAR 0 8
32167: PPUSH
32168: CALL_OW 130
// end ;
32172: GO 31914
32174: POP
32175: POP
// end ;
32176: GO 31284
32178: POP
32179: POP
// end ;
32180: LD_VAR 0 1
32184: RET
// export function MC_Heal ; var i , j , tmp ; begin
32185: LD_INT 0
32187: PPUSH
32188: PPUSH
32189: PPUSH
32190: PPUSH
// if not mc_bases then
32191: LD_EXP 78
32195: NOT
32196: IFFALSE 32200
// exit ;
32198: GO 32602
// for i = 1 to mc_bases do
32200: LD_ADDR_VAR 0 2
32204: PUSH
32205: DOUBLE
32206: LD_INT 1
32208: DEC
32209: ST_TO_ADDR
32210: LD_EXP 78
32214: PUSH
32215: FOR_TO
32216: IFFALSE 32600
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
32218: LD_EXP 81
32222: PUSH
32223: LD_VAR 0 2
32227: ARRAY
32228: PUSH
32229: LD_INT 1
32231: ARRAY
32232: NOT
32233: PUSH
32234: LD_EXP 81
32238: PUSH
32239: LD_VAR 0 2
32243: ARRAY
32244: PUSH
32245: LD_INT 2
32247: ARRAY
32248: NOT
32249: AND
32250: IFFALSE 32288
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
32252: LD_ADDR_EXP 82
32256: PUSH
32257: LD_EXP 82
32261: PPUSH
32262: LD_VAR 0 2
32266: PPUSH
32267: EMPTY
32268: PPUSH
32269: CALL_OW 1
32273: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
32274: LD_VAR 0 2
32278: PPUSH
32279: LD_INT 102
32281: PPUSH
32282: CALL 26323 0 2
// continue ;
32286: GO 32215
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
32288: LD_ADDR_VAR 0 4
32292: PUSH
32293: LD_EXP 78
32297: PUSH
32298: LD_VAR 0 2
32302: ARRAY
32303: PPUSH
32304: LD_INT 25
32306: PUSH
32307: LD_INT 4
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PPUSH
32314: CALL_OW 72
32318: ST_TO_ADDR
// if not tmp then
32319: LD_VAR 0 4
32323: NOT
32324: IFFALSE 32328
// continue ;
32326: GO 32215
// if mc_taming [ i ] then
32328: LD_EXP 109
32332: PUSH
32333: LD_VAR 0 2
32337: ARRAY
32338: IFFALSE 32362
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
32340: LD_ADDR_EXP 109
32344: PUSH
32345: LD_EXP 109
32349: PPUSH
32350: LD_VAR 0 2
32354: PPUSH
32355: EMPTY
32356: PPUSH
32357: CALL_OW 1
32361: ST_TO_ADDR
// for j in tmp do
32362: LD_ADDR_VAR 0 3
32366: PUSH
32367: LD_VAR 0 4
32371: PUSH
32372: FOR_IN
32373: IFFALSE 32596
// begin if IsInUnit ( j ) then
32375: LD_VAR 0 3
32379: PPUSH
32380: CALL_OW 310
32384: IFFALSE 32395
// ComExitBuilding ( j ) ;
32386: LD_VAR 0 3
32390: PPUSH
32391: CALL_OW 122
// if not j in mc_healers [ i ] then
32395: LD_VAR 0 3
32399: PUSH
32400: LD_EXP 82
32404: PUSH
32405: LD_VAR 0 2
32409: ARRAY
32410: IN
32411: NOT
32412: IFFALSE 32458
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
32414: LD_ADDR_EXP 82
32418: PUSH
32419: LD_EXP 82
32423: PPUSH
32424: LD_VAR 0 2
32428: PUSH
32429: LD_EXP 82
32433: PUSH
32434: LD_VAR 0 2
32438: ARRAY
32439: PUSH
32440: LD_INT 1
32442: PLUS
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PPUSH
32448: LD_VAR 0 3
32452: PPUSH
32453: CALL 57824 0 3
32457: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
32458: LD_VAR 0 3
32462: PPUSH
32463: CALL_OW 110
32467: PUSH
32468: LD_INT 102
32470: NONEQUAL
32471: IFFALSE 32485
// SetTag ( j , 102 ) ;
32473: LD_VAR 0 3
32477: PPUSH
32478: LD_INT 102
32480: PPUSH
32481: CALL_OW 109
// Wait ( 3 ) ;
32485: LD_INT 3
32487: PPUSH
32488: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
32492: LD_EXP 81
32496: PUSH
32497: LD_VAR 0 2
32501: ARRAY
32502: PUSH
32503: LD_INT 1
32505: ARRAY
32506: IFFALSE 32538
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
32508: LD_VAR 0 3
32512: PPUSH
32513: LD_EXP 81
32517: PUSH
32518: LD_VAR 0 2
32522: ARRAY
32523: PUSH
32524: LD_INT 1
32526: ARRAY
32527: PUSH
32528: LD_INT 1
32530: ARRAY
32531: PPUSH
32532: CALL_OW 128
32536: GO 32594
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
32538: LD_VAR 0 3
32542: PPUSH
32543: CALL_OW 314
32547: NOT
32548: PUSH
32549: LD_EXP 81
32553: PUSH
32554: LD_VAR 0 2
32558: ARRAY
32559: PUSH
32560: LD_INT 2
32562: ARRAY
32563: AND
32564: IFFALSE 32594
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
32566: LD_VAR 0 3
32570: PPUSH
32571: LD_EXP 81
32575: PUSH
32576: LD_VAR 0 2
32580: ARRAY
32581: PUSH
32582: LD_INT 2
32584: ARRAY
32585: PUSH
32586: LD_INT 1
32588: ARRAY
32589: PPUSH
32590: CALL_OW 128
// end ;
32594: GO 32372
32596: POP
32597: POP
// end ;
32598: GO 32215
32600: POP
32601: POP
// end ;
32602: LD_VAR 0 1
32606: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
32607: LD_INT 0
32609: PPUSH
32610: PPUSH
32611: PPUSH
32612: PPUSH
32613: PPUSH
32614: PPUSH
// if not mc_bases then
32615: LD_EXP 78
32619: NOT
32620: IFFALSE 32624
// exit ;
32622: GO 33787
// for i = 1 to mc_bases do
32624: LD_ADDR_VAR 0 2
32628: PUSH
32629: DOUBLE
32630: LD_INT 1
32632: DEC
32633: ST_TO_ADDR
32634: LD_EXP 78
32638: PUSH
32639: FOR_TO
32640: IFFALSE 33785
// begin if mc_scan [ i ] then
32642: LD_EXP 101
32646: PUSH
32647: LD_VAR 0 2
32651: ARRAY
32652: IFFALSE 32656
// continue ;
32654: GO 32639
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
32656: LD_EXP 83
32660: PUSH
32661: LD_VAR 0 2
32665: ARRAY
32666: NOT
32667: PUSH
32668: LD_EXP 85
32672: PUSH
32673: LD_VAR 0 2
32677: ARRAY
32678: NOT
32679: AND
32680: PUSH
32681: LD_EXP 84
32685: PUSH
32686: LD_VAR 0 2
32690: ARRAY
32691: AND
32692: IFFALSE 32730
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
32694: LD_ADDR_EXP 84
32698: PUSH
32699: LD_EXP 84
32703: PPUSH
32704: LD_VAR 0 2
32708: PPUSH
32709: EMPTY
32710: PPUSH
32711: CALL_OW 1
32715: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32716: LD_VAR 0 2
32720: PPUSH
32721: LD_INT 103
32723: PPUSH
32724: CALL 26323 0 2
// continue ;
32728: GO 32639
// end ; if mc_construct_list [ i ] then
32730: LD_EXP 85
32734: PUSH
32735: LD_VAR 0 2
32739: ARRAY
32740: IFFALSE 32960
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32742: LD_ADDR_VAR 0 5
32746: PUSH
32747: LD_EXP 78
32751: PUSH
32752: LD_VAR 0 2
32756: ARRAY
32757: PPUSH
32758: LD_INT 25
32760: PUSH
32761: LD_INT 2
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PPUSH
32768: CALL_OW 72
32772: PUSH
32773: LD_EXP 80
32777: PUSH
32778: LD_VAR 0 2
32782: ARRAY
32783: DIFF
32784: ST_TO_ADDR
// if not tmp then
32785: LD_VAR 0 5
32789: NOT
32790: IFFALSE 32794
// continue ;
32792: GO 32639
// for j in tmp do
32794: LD_ADDR_VAR 0 3
32798: PUSH
32799: LD_VAR 0 5
32803: PUSH
32804: FOR_IN
32805: IFFALSE 32956
// begin if not mc_builders [ i ] then
32807: LD_EXP 84
32811: PUSH
32812: LD_VAR 0 2
32816: ARRAY
32817: NOT
32818: IFFALSE 32876
// begin SetTag ( j , 103 ) ;
32820: LD_VAR 0 3
32824: PPUSH
32825: LD_INT 103
32827: PPUSH
32828: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32832: LD_ADDR_EXP 84
32836: PUSH
32837: LD_EXP 84
32841: PPUSH
32842: LD_VAR 0 2
32846: PUSH
32847: LD_EXP 84
32851: PUSH
32852: LD_VAR 0 2
32856: ARRAY
32857: PUSH
32858: LD_INT 1
32860: PLUS
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PPUSH
32866: LD_VAR 0 3
32870: PPUSH
32871: CALL 57824 0 3
32875: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32876: LD_VAR 0 3
32880: PPUSH
32881: CALL_OW 310
32885: IFFALSE 32896
// ComExitBuilding ( j ) ;
32887: LD_VAR 0 3
32891: PPUSH
32892: CALL_OW 122
// wait ( 3 ) ;
32896: LD_INT 3
32898: PPUSH
32899: CALL_OW 67
// if not mc_construct_list [ i ] then
32903: LD_EXP 85
32907: PUSH
32908: LD_VAR 0 2
32912: ARRAY
32913: NOT
32914: IFFALSE 32918
// break ;
32916: GO 32956
// if not HasTask ( j ) then
32918: LD_VAR 0 3
32922: PPUSH
32923: CALL_OW 314
32927: NOT
32928: IFFALSE 32954
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32930: LD_VAR 0 3
32934: PPUSH
32935: LD_EXP 85
32939: PUSH
32940: LD_VAR 0 2
32944: ARRAY
32945: PUSH
32946: LD_INT 1
32948: ARRAY
32949: PPUSH
32950: CALL 61062 0 2
// end ;
32954: GO 32804
32956: POP
32957: POP
// end else
32958: GO 33783
// if mc_build_list [ i ] then
32960: LD_EXP 83
32964: PUSH
32965: LD_VAR 0 2
32969: ARRAY
32970: IFFALSE 33783
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32972: LD_EXP 83
32976: PUSH
32977: LD_VAR 0 2
32981: ARRAY
32982: PUSH
32983: LD_INT 1
32985: ARRAY
32986: PUSH
32987: LD_INT 1
32989: ARRAY
32990: PPUSH
32991: CALL 60886 0 1
32995: PUSH
32996: LD_EXP 78
33000: PUSH
33001: LD_VAR 0 2
33005: ARRAY
33006: PPUSH
33007: LD_INT 2
33009: PUSH
33010: LD_INT 30
33012: PUSH
33013: LD_INT 2
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 30
33022: PUSH
33023: LD_INT 3
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: LIST
33034: PPUSH
33035: CALL_OW 72
33039: NOT
33040: AND
33041: IFFALSE 33146
// begin for j = 1 to mc_build_list [ i ] do
33043: LD_ADDR_VAR 0 3
33047: PUSH
33048: DOUBLE
33049: LD_INT 1
33051: DEC
33052: ST_TO_ADDR
33053: LD_EXP 83
33057: PUSH
33058: LD_VAR 0 2
33062: ARRAY
33063: PUSH
33064: FOR_TO
33065: IFFALSE 33144
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33067: LD_EXP 83
33071: PUSH
33072: LD_VAR 0 2
33076: ARRAY
33077: PUSH
33078: LD_VAR 0 3
33082: ARRAY
33083: PUSH
33084: LD_INT 1
33086: ARRAY
33087: PUSH
33088: LD_INT 2
33090: EQUAL
33091: IFFALSE 33142
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33093: LD_ADDR_EXP 83
33097: PUSH
33098: LD_EXP 83
33102: PPUSH
33103: LD_VAR 0 2
33107: PPUSH
33108: LD_EXP 83
33112: PUSH
33113: LD_VAR 0 2
33117: ARRAY
33118: PPUSH
33119: LD_VAR 0 3
33123: PPUSH
33124: LD_INT 1
33126: PPUSH
33127: LD_INT 0
33129: PPUSH
33130: CALL 57242 0 4
33134: PPUSH
33135: CALL_OW 1
33139: ST_TO_ADDR
// break ;
33140: GO 33144
// end ;
33142: GO 33064
33144: POP
33145: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33146: LD_ADDR_VAR 0 6
33150: PUSH
33151: LD_EXP 78
33155: PUSH
33156: LD_VAR 0 2
33160: ARRAY
33161: PPUSH
33162: LD_INT 2
33164: PUSH
33165: LD_INT 30
33167: PUSH
33168: LD_INT 0
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 30
33177: PUSH
33178: LD_INT 1
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: LIST
33189: PPUSH
33190: CALL_OW 72
33194: ST_TO_ADDR
// for k := 1 to depot do
33195: LD_ADDR_VAR 0 4
33199: PUSH
33200: DOUBLE
33201: LD_INT 1
33203: DEC
33204: ST_TO_ADDR
33205: LD_VAR 0 6
33209: PUSH
33210: FOR_TO
33211: IFFALSE 33781
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
33213: LD_EXP 83
33217: PUSH
33218: LD_VAR 0 2
33222: ARRAY
33223: PUSH
33224: LD_INT 1
33226: ARRAY
33227: PUSH
33228: LD_INT 1
33230: ARRAY
33231: PUSH
33232: LD_INT 0
33234: EQUAL
33235: PUSH
33236: LD_VAR 0 6
33240: PUSH
33241: LD_VAR 0 4
33245: ARRAY
33246: PPUSH
33247: LD_EXP 83
33251: PUSH
33252: LD_VAR 0 2
33256: ARRAY
33257: PUSH
33258: LD_INT 1
33260: ARRAY
33261: PUSH
33262: LD_INT 1
33264: ARRAY
33265: PPUSH
33266: LD_EXP 83
33270: PUSH
33271: LD_VAR 0 2
33275: ARRAY
33276: PUSH
33277: LD_INT 1
33279: ARRAY
33280: PUSH
33281: LD_INT 2
33283: ARRAY
33284: PPUSH
33285: LD_EXP 83
33289: PUSH
33290: LD_VAR 0 2
33294: ARRAY
33295: PUSH
33296: LD_INT 1
33298: ARRAY
33299: PUSH
33300: LD_INT 3
33302: ARRAY
33303: PPUSH
33304: LD_EXP 83
33308: PUSH
33309: LD_VAR 0 2
33313: ARRAY
33314: PUSH
33315: LD_INT 1
33317: ARRAY
33318: PUSH
33319: LD_INT 4
33321: ARRAY
33322: PPUSH
33323: CALL 66298 0 5
33327: OR
33328: IFFALSE 33609
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33330: LD_ADDR_VAR 0 5
33334: PUSH
33335: LD_EXP 78
33339: PUSH
33340: LD_VAR 0 2
33344: ARRAY
33345: PPUSH
33346: LD_INT 25
33348: PUSH
33349: LD_INT 2
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PPUSH
33356: CALL_OW 72
33360: PUSH
33361: LD_EXP 80
33365: PUSH
33366: LD_VAR 0 2
33370: ARRAY
33371: DIFF
33372: ST_TO_ADDR
// if not tmp then
33373: LD_VAR 0 5
33377: NOT
33378: IFFALSE 33382
// continue ;
33380: GO 33210
// for j in tmp do
33382: LD_ADDR_VAR 0 3
33386: PUSH
33387: LD_VAR 0 5
33391: PUSH
33392: FOR_IN
33393: IFFALSE 33605
// begin if not mc_builders [ i ] then
33395: LD_EXP 84
33399: PUSH
33400: LD_VAR 0 2
33404: ARRAY
33405: NOT
33406: IFFALSE 33464
// begin SetTag ( j , 103 ) ;
33408: LD_VAR 0 3
33412: PPUSH
33413: LD_INT 103
33415: PPUSH
33416: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33420: LD_ADDR_EXP 84
33424: PUSH
33425: LD_EXP 84
33429: PPUSH
33430: LD_VAR 0 2
33434: PUSH
33435: LD_EXP 84
33439: PUSH
33440: LD_VAR 0 2
33444: ARRAY
33445: PUSH
33446: LD_INT 1
33448: PLUS
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PPUSH
33454: LD_VAR 0 3
33458: PPUSH
33459: CALL 57824 0 3
33463: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33464: LD_VAR 0 3
33468: PPUSH
33469: CALL_OW 310
33473: IFFALSE 33484
// ComExitBuilding ( j ) ;
33475: LD_VAR 0 3
33479: PPUSH
33480: CALL_OW 122
// wait ( 3 ) ;
33484: LD_INT 3
33486: PPUSH
33487: CALL_OW 67
// if not mc_build_list [ i ] then
33491: LD_EXP 83
33495: PUSH
33496: LD_VAR 0 2
33500: ARRAY
33501: NOT
33502: IFFALSE 33506
// break ;
33504: GO 33605
// if not HasTask ( j ) then
33506: LD_VAR 0 3
33510: PPUSH
33511: CALL_OW 314
33515: NOT
33516: IFFALSE 33603
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
33518: LD_VAR 0 3
33522: PPUSH
33523: LD_EXP 83
33527: PUSH
33528: LD_VAR 0 2
33532: ARRAY
33533: PUSH
33534: LD_INT 1
33536: ARRAY
33537: PUSH
33538: LD_INT 1
33540: ARRAY
33541: PPUSH
33542: LD_EXP 83
33546: PUSH
33547: LD_VAR 0 2
33551: ARRAY
33552: PUSH
33553: LD_INT 1
33555: ARRAY
33556: PUSH
33557: LD_INT 2
33559: ARRAY
33560: PPUSH
33561: LD_EXP 83
33565: PUSH
33566: LD_VAR 0 2
33570: ARRAY
33571: PUSH
33572: LD_INT 1
33574: ARRAY
33575: PUSH
33576: LD_INT 3
33578: ARRAY
33579: PPUSH
33580: LD_EXP 83
33584: PUSH
33585: LD_VAR 0 2
33589: ARRAY
33590: PUSH
33591: LD_INT 1
33593: ARRAY
33594: PUSH
33595: LD_INT 4
33597: ARRAY
33598: PPUSH
33599: CALL_OW 145
// end ;
33603: GO 33392
33605: POP
33606: POP
// end else
33607: GO 33779
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
33609: LD_EXP 78
33613: PUSH
33614: LD_VAR 0 2
33618: ARRAY
33619: PPUSH
33620: LD_EXP 83
33624: PUSH
33625: LD_VAR 0 2
33629: ARRAY
33630: PUSH
33631: LD_INT 1
33633: ARRAY
33634: PUSH
33635: LD_INT 1
33637: ARRAY
33638: PPUSH
33639: LD_EXP 83
33643: PUSH
33644: LD_VAR 0 2
33648: ARRAY
33649: PUSH
33650: LD_INT 1
33652: ARRAY
33653: PUSH
33654: LD_INT 2
33656: ARRAY
33657: PPUSH
33658: LD_EXP 83
33662: PUSH
33663: LD_VAR 0 2
33667: ARRAY
33668: PUSH
33669: LD_INT 1
33671: ARRAY
33672: PUSH
33673: LD_INT 3
33675: ARRAY
33676: PPUSH
33677: LD_EXP 83
33681: PUSH
33682: LD_VAR 0 2
33686: ARRAY
33687: PUSH
33688: LD_INT 1
33690: ARRAY
33691: PUSH
33692: LD_INT 4
33694: ARRAY
33695: PPUSH
33696: LD_EXP 78
33700: PUSH
33701: LD_VAR 0 2
33705: ARRAY
33706: PPUSH
33707: LD_INT 21
33709: PUSH
33710: LD_INT 3
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: PPUSH
33717: CALL_OW 72
33721: PPUSH
33722: EMPTY
33723: PPUSH
33724: CALL 65052 0 7
33728: NOT
33729: IFFALSE 33779
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
33731: LD_ADDR_EXP 83
33735: PUSH
33736: LD_EXP 83
33740: PPUSH
33741: LD_VAR 0 2
33745: PPUSH
33746: LD_EXP 83
33750: PUSH
33751: LD_VAR 0 2
33755: ARRAY
33756: PPUSH
33757: LD_INT 1
33759: PPUSH
33760: LD_INT 1
33762: NEG
33763: PPUSH
33764: LD_INT 0
33766: PPUSH
33767: CALL 57242 0 4
33771: PPUSH
33772: CALL_OW 1
33776: ST_TO_ADDR
// continue ;
33777: GO 33210
// end ; end ;
33779: GO 33210
33781: POP
33782: POP
// end ; end ;
33783: GO 32639
33785: POP
33786: POP
// end ;
33787: LD_VAR 0 1
33791: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
33792: LD_INT 0
33794: PPUSH
33795: PPUSH
33796: PPUSH
33797: PPUSH
33798: PPUSH
33799: PPUSH
// if not mc_bases then
33800: LD_EXP 78
33804: NOT
33805: IFFALSE 33809
// exit ;
33807: GO 34236
// for i = 1 to mc_bases do
33809: LD_ADDR_VAR 0 2
33813: PUSH
33814: DOUBLE
33815: LD_INT 1
33817: DEC
33818: ST_TO_ADDR
33819: LD_EXP 78
33823: PUSH
33824: FOR_TO
33825: IFFALSE 34234
// begin tmp := mc_build_upgrade [ i ] ;
33827: LD_ADDR_VAR 0 4
33831: PUSH
33832: LD_EXP 110
33836: PUSH
33837: LD_VAR 0 2
33841: ARRAY
33842: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33843: LD_ADDR_VAR 0 6
33847: PUSH
33848: LD_EXP 111
33852: PUSH
33853: LD_VAR 0 2
33857: ARRAY
33858: PPUSH
33859: LD_INT 2
33861: PUSH
33862: LD_INT 30
33864: PUSH
33865: LD_INT 6
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 30
33874: PUSH
33875: LD_INT 7
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: LIST
33886: PPUSH
33887: CALL_OW 72
33891: ST_TO_ADDR
// if not tmp and not lab then
33892: LD_VAR 0 4
33896: NOT
33897: PUSH
33898: LD_VAR 0 6
33902: NOT
33903: AND
33904: IFFALSE 33908
// continue ;
33906: GO 33824
// if tmp then
33908: LD_VAR 0 4
33912: IFFALSE 34032
// for j in tmp do
33914: LD_ADDR_VAR 0 3
33918: PUSH
33919: LD_VAR 0 4
33923: PUSH
33924: FOR_IN
33925: IFFALSE 34030
// begin if UpgradeCost ( j ) then
33927: LD_VAR 0 3
33931: PPUSH
33932: CALL 64712 0 1
33936: IFFALSE 34028
// begin ComUpgrade ( j ) ;
33938: LD_VAR 0 3
33942: PPUSH
33943: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33947: LD_ADDR_EXP 110
33951: PUSH
33952: LD_EXP 110
33956: PPUSH
33957: LD_VAR 0 2
33961: PPUSH
33962: LD_EXP 110
33966: PUSH
33967: LD_VAR 0 2
33971: ARRAY
33972: PUSH
33973: LD_VAR 0 3
33977: DIFF
33978: PPUSH
33979: CALL_OW 1
33983: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33984: LD_ADDR_EXP 85
33988: PUSH
33989: LD_EXP 85
33993: PPUSH
33994: LD_VAR 0 2
33998: PUSH
33999: LD_EXP 85
34003: PUSH
34004: LD_VAR 0 2
34008: ARRAY
34009: PUSH
34010: LD_INT 1
34012: PLUS
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PPUSH
34018: LD_VAR 0 3
34022: PPUSH
34023: CALL 57824 0 3
34027: ST_TO_ADDR
// end ; end ;
34028: GO 33924
34030: POP
34031: POP
// if not lab or not mc_lab_upgrade [ i ] then
34032: LD_VAR 0 6
34036: NOT
34037: PUSH
34038: LD_EXP 112
34042: PUSH
34043: LD_VAR 0 2
34047: ARRAY
34048: NOT
34049: OR
34050: IFFALSE 34054
// continue ;
34052: GO 33824
// for j in lab do
34054: LD_ADDR_VAR 0 3
34058: PUSH
34059: LD_VAR 0 6
34063: PUSH
34064: FOR_IN
34065: IFFALSE 34230
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34067: LD_VAR 0 3
34071: PPUSH
34072: CALL_OW 266
34076: PUSH
34077: LD_INT 6
34079: PUSH
34080: LD_INT 7
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: IN
34087: PUSH
34088: LD_VAR 0 3
34092: PPUSH
34093: CALL_OW 461
34097: PUSH
34098: LD_INT 1
34100: NONEQUAL
34101: AND
34102: IFFALSE 34228
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34104: LD_VAR 0 3
34108: PPUSH
34109: LD_EXP 112
34113: PUSH
34114: LD_VAR 0 2
34118: ARRAY
34119: PUSH
34120: LD_INT 1
34122: ARRAY
34123: PPUSH
34124: CALL 64917 0 2
34128: IFFALSE 34228
// begin ComCancel ( j ) ;
34130: LD_VAR 0 3
34134: PPUSH
34135: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
34139: LD_VAR 0 3
34143: PPUSH
34144: LD_EXP 112
34148: PUSH
34149: LD_VAR 0 2
34153: ARRAY
34154: PUSH
34155: LD_INT 1
34157: ARRAY
34158: PPUSH
34159: CALL_OW 207
// if not j in mc_construct_list [ i ] then
34163: LD_VAR 0 3
34167: PUSH
34168: LD_EXP 85
34172: PUSH
34173: LD_VAR 0 2
34177: ARRAY
34178: IN
34179: NOT
34180: IFFALSE 34226
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34182: LD_ADDR_EXP 85
34186: PUSH
34187: LD_EXP 85
34191: PPUSH
34192: LD_VAR 0 2
34196: PUSH
34197: LD_EXP 85
34201: PUSH
34202: LD_VAR 0 2
34206: ARRAY
34207: PUSH
34208: LD_INT 1
34210: PLUS
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PPUSH
34216: LD_VAR 0 3
34220: PPUSH
34221: CALL 57824 0 3
34225: ST_TO_ADDR
// break ;
34226: GO 34230
// end ; end ; end ;
34228: GO 34064
34230: POP
34231: POP
// end ;
34232: GO 33824
34234: POP
34235: POP
// end ;
34236: LD_VAR 0 1
34240: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
34241: LD_INT 0
34243: PPUSH
34244: PPUSH
34245: PPUSH
34246: PPUSH
34247: PPUSH
34248: PPUSH
34249: PPUSH
34250: PPUSH
34251: PPUSH
// if not mc_bases then
34252: LD_EXP 78
34256: NOT
34257: IFFALSE 34261
// exit ;
34259: GO 34666
// for i = 1 to mc_bases do
34261: LD_ADDR_VAR 0 2
34265: PUSH
34266: DOUBLE
34267: LD_INT 1
34269: DEC
34270: ST_TO_ADDR
34271: LD_EXP 78
34275: PUSH
34276: FOR_TO
34277: IFFALSE 34664
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
34279: LD_EXP 86
34283: PUSH
34284: LD_VAR 0 2
34288: ARRAY
34289: NOT
34290: PUSH
34291: LD_EXP 78
34295: PUSH
34296: LD_VAR 0 2
34300: ARRAY
34301: PPUSH
34302: LD_INT 30
34304: PUSH
34305: LD_INT 3
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PPUSH
34312: CALL_OW 72
34316: NOT
34317: OR
34318: IFFALSE 34322
// continue ;
34320: GO 34276
// busy := false ;
34322: LD_ADDR_VAR 0 8
34326: PUSH
34327: LD_INT 0
34329: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34330: LD_ADDR_VAR 0 4
34334: PUSH
34335: LD_EXP 78
34339: PUSH
34340: LD_VAR 0 2
34344: ARRAY
34345: PPUSH
34346: LD_INT 30
34348: PUSH
34349: LD_INT 3
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PPUSH
34356: CALL_OW 72
34360: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
34361: LD_ADDR_VAR 0 6
34365: PUSH
34366: LD_EXP 86
34370: PUSH
34371: LD_VAR 0 2
34375: ARRAY
34376: PPUSH
34377: LD_INT 2
34379: PUSH
34380: LD_INT 30
34382: PUSH
34383: LD_INT 32
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: LD_INT 30
34392: PUSH
34393: LD_INT 33
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: LIST
34404: PPUSH
34405: CALL_OW 72
34409: ST_TO_ADDR
// if not t then
34410: LD_VAR 0 6
34414: NOT
34415: IFFALSE 34419
// continue ;
34417: GO 34276
// for j in tmp do
34419: LD_ADDR_VAR 0 3
34423: PUSH
34424: LD_VAR 0 4
34428: PUSH
34429: FOR_IN
34430: IFFALSE 34460
// if not BuildingStatus ( j ) = bs_idle then
34432: LD_VAR 0 3
34436: PPUSH
34437: CALL_OW 461
34441: PUSH
34442: LD_INT 2
34444: EQUAL
34445: NOT
34446: IFFALSE 34458
// begin busy := true ;
34448: LD_ADDR_VAR 0 8
34452: PUSH
34453: LD_INT 1
34455: ST_TO_ADDR
// break ;
34456: GO 34460
// end ;
34458: GO 34429
34460: POP
34461: POP
// if busy then
34462: LD_VAR 0 8
34466: IFFALSE 34470
// continue ;
34468: GO 34276
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
34470: LD_ADDR_VAR 0 7
34474: PUSH
34475: LD_VAR 0 6
34479: PPUSH
34480: LD_INT 35
34482: PUSH
34483: LD_INT 0
34485: PUSH
34486: EMPTY
34487: LIST
34488: LIST
34489: PPUSH
34490: CALL_OW 72
34494: ST_TO_ADDR
// if tw then
34495: LD_VAR 0 7
34499: IFFALSE 34576
// begin tw := tw [ 1 ] ;
34501: LD_ADDR_VAR 0 7
34505: PUSH
34506: LD_VAR 0 7
34510: PUSH
34511: LD_INT 1
34513: ARRAY
34514: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
34515: LD_ADDR_VAR 0 9
34519: PUSH
34520: LD_VAR 0 7
34524: PPUSH
34525: LD_EXP 103
34529: PUSH
34530: LD_VAR 0 2
34534: ARRAY
34535: PPUSH
34536: CALL 63209 0 2
34540: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
34541: LD_EXP 117
34545: PUSH
34546: LD_VAR 0 2
34550: ARRAY
34551: IFFALSE 34574
// if not weapon in mc_allowed_tower_weapons [ i ] then
34553: LD_VAR 0 9
34557: PUSH
34558: LD_EXP 117
34562: PUSH
34563: LD_VAR 0 2
34567: ARRAY
34568: IN
34569: NOT
34570: IFFALSE 34574
// continue ;
34572: GO 34276
// end else
34574: GO 34639
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
34576: LD_ADDR_VAR 0 5
34580: PUSH
34581: LD_EXP 86
34585: PUSH
34586: LD_VAR 0 2
34590: ARRAY
34591: PPUSH
34592: LD_VAR 0 4
34596: PPUSH
34597: CALL 90112 0 2
34601: ST_TO_ADDR
// if not tmp2 then
34602: LD_VAR 0 5
34606: NOT
34607: IFFALSE 34611
// continue ;
34609: GO 34276
// tw := tmp2 [ 1 ] ;
34611: LD_ADDR_VAR 0 7
34615: PUSH
34616: LD_VAR 0 5
34620: PUSH
34621: LD_INT 1
34623: ARRAY
34624: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
34625: LD_ADDR_VAR 0 9
34629: PUSH
34630: LD_VAR 0 5
34634: PUSH
34635: LD_INT 2
34637: ARRAY
34638: ST_TO_ADDR
// end ; if not weapon then
34639: LD_VAR 0 9
34643: NOT
34644: IFFALSE 34648
// continue ;
34646: GO 34276
// ComPlaceWeapon ( tw , weapon ) ;
34648: LD_VAR 0 7
34652: PPUSH
34653: LD_VAR 0 9
34657: PPUSH
34658: CALL_OW 148
// end ;
34662: GO 34276
34664: POP
34665: POP
// end ;
34666: LD_VAR 0 1
34670: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
34671: LD_INT 0
34673: PPUSH
34674: PPUSH
34675: PPUSH
34676: PPUSH
34677: PPUSH
34678: PPUSH
34679: PPUSH
// if not mc_bases then
34680: LD_EXP 78
34684: NOT
34685: IFFALSE 34689
// exit ;
34687: GO 35464
// for i = 1 to mc_bases do
34689: LD_ADDR_VAR 0 2
34693: PUSH
34694: DOUBLE
34695: LD_INT 1
34697: DEC
34698: ST_TO_ADDR
34699: LD_EXP 78
34703: PUSH
34704: FOR_TO
34705: IFFALSE 35462
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
34707: LD_EXP 91
34711: PUSH
34712: LD_VAR 0 2
34716: ARRAY
34717: NOT
34718: PUSH
34719: LD_EXP 91
34723: PUSH
34724: LD_VAR 0 2
34728: ARRAY
34729: PUSH
34730: LD_EXP 92
34734: PUSH
34735: LD_VAR 0 2
34739: ARRAY
34740: EQUAL
34741: OR
34742: PUSH
34743: LD_EXP 101
34747: PUSH
34748: LD_VAR 0 2
34752: ARRAY
34753: OR
34754: IFFALSE 34758
// continue ;
34756: GO 34704
// if mc_miners [ i ] then
34758: LD_EXP 92
34762: PUSH
34763: LD_VAR 0 2
34767: ARRAY
34768: IFFALSE 35149
// begin for j = mc_miners [ i ] downto 1 do
34770: LD_ADDR_VAR 0 3
34774: PUSH
34775: DOUBLE
34776: LD_EXP 92
34780: PUSH
34781: LD_VAR 0 2
34785: ARRAY
34786: INC
34787: ST_TO_ADDR
34788: LD_INT 1
34790: PUSH
34791: FOR_DOWNTO
34792: IFFALSE 35147
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
34794: LD_EXP 92
34798: PUSH
34799: LD_VAR 0 2
34803: ARRAY
34804: PUSH
34805: LD_VAR 0 3
34809: ARRAY
34810: PPUSH
34811: CALL_OW 301
34815: PUSH
34816: LD_EXP 92
34820: PUSH
34821: LD_VAR 0 2
34825: ARRAY
34826: PUSH
34827: LD_VAR 0 3
34831: ARRAY
34832: PPUSH
34833: CALL_OW 257
34837: PUSH
34838: LD_INT 1
34840: NONEQUAL
34841: OR
34842: IFFALSE 34905
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34844: LD_ADDR_VAR 0 5
34848: PUSH
34849: LD_EXP 92
34853: PUSH
34854: LD_VAR 0 2
34858: ARRAY
34859: PUSH
34860: LD_EXP 92
34864: PUSH
34865: LD_VAR 0 2
34869: ARRAY
34870: PUSH
34871: LD_VAR 0 3
34875: ARRAY
34876: DIFF
34877: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34878: LD_ADDR_EXP 92
34882: PUSH
34883: LD_EXP 92
34887: PPUSH
34888: LD_VAR 0 2
34892: PPUSH
34893: LD_VAR 0 5
34897: PPUSH
34898: CALL_OW 1
34902: ST_TO_ADDR
// continue ;
34903: GO 34791
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34905: LD_EXP 92
34909: PUSH
34910: LD_VAR 0 2
34914: ARRAY
34915: PUSH
34916: LD_VAR 0 3
34920: ARRAY
34921: PPUSH
34922: CALL_OW 257
34926: PUSH
34927: LD_INT 1
34929: EQUAL
34930: PUSH
34931: LD_EXP 92
34935: PUSH
34936: LD_VAR 0 2
34940: ARRAY
34941: PUSH
34942: LD_VAR 0 3
34946: ARRAY
34947: PPUSH
34948: CALL_OW 459
34952: NOT
34953: AND
34954: PUSH
34955: LD_EXP 92
34959: PUSH
34960: LD_VAR 0 2
34964: ARRAY
34965: PUSH
34966: LD_VAR 0 3
34970: ARRAY
34971: PPUSH
34972: CALL_OW 314
34976: NOT
34977: AND
34978: IFFALSE 35145
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34980: LD_EXP 92
34984: PUSH
34985: LD_VAR 0 2
34989: ARRAY
34990: PUSH
34991: LD_VAR 0 3
34995: ARRAY
34996: PPUSH
34997: CALL_OW 310
35001: IFFALSE 35024
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
35003: LD_EXP 92
35007: PUSH
35008: LD_VAR 0 2
35012: ARRAY
35013: PUSH
35014: LD_VAR 0 3
35018: ARRAY
35019: PPUSH
35020: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
35024: LD_EXP 92
35028: PUSH
35029: LD_VAR 0 2
35033: ARRAY
35034: PUSH
35035: LD_VAR 0 3
35039: ARRAY
35040: PPUSH
35041: CALL_OW 314
35045: NOT
35046: IFFALSE 35145
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
35048: LD_ADDR_VAR 0 7
35052: PUSH
35053: LD_VAR 0 3
35057: PUSH
35058: LD_EXP 91
35062: PUSH
35063: LD_VAR 0 2
35067: ARRAY
35068: PPUSH
35069: CALL 54964 0 1
35073: MOD
35074: PUSH
35075: LD_INT 1
35077: PLUS
35078: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35079: LD_EXP 92
35083: PUSH
35084: LD_VAR 0 2
35088: ARRAY
35089: PUSH
35090: LD_VAR 0 3
35094: ARRAY
35095: PPUSH
35096: LD_EXP 91
35100: PUSH
35101: LD_VAR 0 2
35105: ARRAY
35106: PUSH
35107: LD_VAR 0 7
35111: ARRAY
35112: PUSH
35113: LD_INT 1
35115: ARRAY
35116: PPUSH
35117: LD_EXP 91
35121: PUSH
35122: LD_VAR 0 2
35126: ARRAY
35127: PUSH
35128: LD_VAR 0 7
35132: ARRAY
35133: PUSH
35134: LD_INT 2
35136: ARRAY
35137: PPUSH
35138: LD_INT 0
35140: PPUSH
35141: CALL_OW 193
// end ; end ; end ;
35145: GO 34791
35147: POP
35148: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
35149: LD_ADDR_VAR 0 5
35153: PUSH
35154: LD_EXP 78
35158: PUSH
35159: LD_VAR 0 2
35163: ARRAY
35164: PPUSH
35165: LD_INT 2
35167: PUSH
35168: LD_INT 30
35170: PUSH
35171: LD_INT 4
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 30
35180: PUSH
35181: LD_INT 5
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 30
35190: PUSH
35191: LD_INT 32
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: LIST
35202: LIST
35203: PPUSH
35204: CALL_OW 72
35208: ST_TO_ADDR
// if not tmp then
35209: LD_VAR 0 5
35213: NOT
35214: IFFALSE 35218
// continue ;
35216: GO 34704
// list := [ ] ;
35218: LD_ADDR_VAR 0 6
35222: PUSH
35223: EMPTY
35224: ST_TO_ADDR
// for j in tmp do
35225: LD_ADDR_VAR 0 3
35229: PUSH
35230: LD_VAR 0 5
35234: PUSH
35235: FOR_IN
35236: IFFALSE 35305
// begin for k in UnitsInside ( j ) do
35238: LD_ADDR_VAR 0 4
35242: PUSH
35243: LD_VAR 0 3
35247: PPUSH
35248: CALL_OW 313
35252: PUSH
35253: FOR_IN
35254: IFFALSE 35301
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
35256: LD_VAR 0 4
35260: PPUSH
35261: CALL_OW 257
35265: PUSH
35266: LD_INT 1
35268: EQUAL
35269: PUSH
35270: LD_VAR 0 4
35274: PPUSH
35275: CALL_OW 459
35279: NOT
35280: AND
35281: IFFALSE 35299
// list := list ^ k ;
35283: LD_ADDR_VAR 0 6
35287: PUSH
35288: LD_VAR 0 6
35292: PUSH
35293: LD_VAR 0 4
35297: ADD
35298: ST_TO_ADDR
35299: GO 35253
35301: POP
35302: POP
// end ;
35303: GO 35235
35305: POP
35306: POP
// list := list diff mc_miners [ i ] ;
35307: LD_ADDR_VAR 0 6
35311: PUSH
35312: LD_VAR 0 6
35316: PUSH
35317: LD_EXP 92
35321: PUSH
35322: LD_VAR 0 2
35326: ARRAY
35327: DIFF
35328: ST_TO_ADDR
// if not list then
35329: LD_VAR 0 6
35333: NOT
35334: IFFALSE 35338
// continue ;
35336: GO 34704
// k := mc_mines [ i ] - mc_miners [ i ] ;
35338: LD_ADDR_VAR 0 4
35342: PUSH
35343: LD_EXP 91
35347: PUSH
35348: LD_VAR 0 2
35352: ARRAY
35353: PUSH
35354: LD_EXP 92
35358: PUSH
35359: LD_VAR 0 2
35363: ARRAY
35364: MINUS
35365: ST_TO_ADDR
// if k > list then
35366: LD_VAR 0 4
35370: PUSH
35371: LD_VAR 0 6
35375: GREATER
35376: IFFALSE 35388
// k := list ;
35378: LD_ADDR_VAR 0 4
35382: PUSH
35383: LD_VAR 0 6
35387: ST_TO_ADDR
// for j = 1 to k do
35388: LD_ADDR_VAR 0 3
35392: PUSH
35393: DOUBLE
35394: LD_INT 1
35396: DEC
35397: ST_TO_ADDR
35398: LD_VAR 0 4
35402: PUSH
35403: FOR_TO
35404: IFFALSE 35458
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
35406: LD_ADDR_EXP 92
35410: PUSH
35411: LD_EXP 92
35415: PPUSH
35416: LD_VAR 0 2
35420: PUSH
35421: LD_EXP 92
35425: PUSH
35426: LD_VAR 0 2
35430: ARRAY
35431: PUSH
35432: LD_INT 1
35434: PLUS
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PPUSH
35440: LD_VAR 0 6
35444: PUSH
35445: LD_VAR 0 3
35449: ARRAY
35450: PPUSH
35451: CALL 57824 0 3
35455: ST_TO_ADDR
35456: GO 35403
35458: POP
35459: POP
// end ;
35460: GO 34704
35462: POP
35463: POP
// end ;
35464: LD_VAR 0 1
35468: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
35469: LD_INT 0
35471: PPUSH
35472: PPUSH
35473: PPUSH
35474: PPUSH
35475: PPUSH
35476: PPUSH
35477: PPUSH
35478: PPUSH
35479: PPUSH
35480: PPUSH
35481: PPUSH
// if not mc_bases then
35482: LD_EXP 78
35486: NOT
35487: IFFALSE 35491
// exit ;
35489: GO 37314
// for i = 1 to mc_bases do
35491: LD_ADDR_VAR 0 2
35495: PUSH
35496: DOUBLE
35497: LD_INT 1
35499: DEC
35500: ST_TO_ADDR
35501: LD_EXP 78
35505: PUSH
35506: FOR_TO
35507: IFFALSE 37312
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
35509: LD_EXP 78
35513: PUSH
35514: LD_VAR 0 2
35518: ARRAY
35519: NOT
35520: PUSH
35521: LD_EXP 85
35525: PUSH
35526: LD_VAR 0 2
35530: ARRAY
35531: OR
35532: IFFALSE 35536
// continue ;
35534: GO 35506
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
35536: LD_EXP 94
35540: PUSH
35541: LD_VAR 0 2
35545: ARRAY
35546: NOT
35547: PUSH
35548: LD_EXP 95
35552: PUSH
35553: LD_VAR 0 2
35557: ARRAY
35558: AND
35559: IFFALSE 35597
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
35561: LD_ADDR_EXP 95
35565: PUSH
35566: LD_EXP 95
35570: PPUSH
35571: LD_VAR 0 2
35575: PPUSH
35576: EMPTY
35577: PPUSH
35578: CALL_OW 1
35582: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
35583: LD_VAR 0 2
35587: PPUSH
35588: LD_INT 107
35590: PPUSH
35591: CALL 26323 0 2
// continue ;
35595: GO 35506
// end ; target := [ ] ;
35597: LD_ADDR_VAR 0 7
35601: PUSH
35602: EMPTY
35603: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35604: LD_ADDR_VAR 0 6
35608: PUSH
35609: LD_EXP 78
35613: PUSH
35614: LD_VAR 0 2
35618: ARRAY
35619: PUSH
35620: LD_INT 1
35622: ARRAY
35623: PPUSH
35624: CALL_OW 255
35628: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35629: LD_ADDR_VAR 0 9
35633: PUSH
35634: LD_EXP 78
35638: PUSH
35639: LD_VAR 0 2
35643: ARRAY
35644: PPUSH
35645: LD_INT 2
35647: PUSH
35648: LD_INT 30
35650: PUSH
35651: LD_INT 0
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 30
35660: PUSH
35661: LD_INT 1
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: LIST
35672: PPUSH
35673: CALL_OW 72
35677: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
35678: LD_ADDR_VAR 0 3
35682: PUSH
35683: DOUBLE
35684: LD_EXP 94
35688: PUSH
35689: LD_VAR 0 2
35693: ARRAY
35694: INC
35695: ST_TO_ADDR
35696: LD_INT 1
35698: PUSH
35699: FOR_DOWNTO
35700: IFFALSE 35945
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
35702: LD_EXP 94
35706: PUSH
35707: LD_VAR 0 2
35711: ARRAY
35712: PUSH
35713: LD_VAR 0 3
35717: ARRAY
35718: PUSH
35719: LD_INT 2
35721: ARRAY
35722: PPUSH
35723: LD_EXP 94
35727: PUSH
35728: LD_VAR 0 2
35732: ARRAY
35733: PUSH
35734: LD_VAR 0 3
35738: ARRAY
35739: PUSH
35740: LD_INT 3
35742: ARRAY
35743: PPUSH
35744: CALL_OW 488
35748: PUSH
35749: LD_EXP 94
35753: PUSH
35754: LD_VAR 0 2
35758: ARRAY
35759: PUSH
35760: LD_VAR 0 3
35764: ARRAY
35765: PUSH
35766: LD_INT 2
35768: ARRAY
35769: PPUSH
35770: LD_EXP 94
35774: PUSH
35775: LD_VAR 0 2
35779: ARRAY
35780: PUSH
35781: LD_VAR 0 3
35785: ARRAY
35786: PUSH
35787: LD_INT 3
35789: ARRAY
35790: PPUSH
35791: CALL_OW 284
35795: PUSH
35796: LD_INT 0
35798: EQUAL
35799: AND
35800: IFFALSE 35855
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
35802: LD_ADDR_VAR 0 5
35806: PUSH
35807: LD_EXP 94
35811: PUSH
35812: LD_VAR 0 2
35816: ARRAY
35817: PPUSH
35818: LD_VAR 0 3
35822: PPUSH
35823: CALL_OW 3
35827: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35828: LD_ADDR_EXP 94
35832: PUSH
35833: LD_EXP 94
35837: PPUSH
35838: LD_VAR 0 2
35842: PPUSH
35843: LD_VAR 0 5
35847: PPUSH
35848: CALL_OW 1
35852: ST_TO_ADDR
// continue ;
35853: GO 35699
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35855: LD_VAR 0 6
35859: PPUSH
35860: LD_EXP 94
35864: PUSH
35865: LD_VAR 0 2
35869: ARRAY
35870: PUSH
35871: LD_VAR 0 3
35875: ARRAY
35876: PUSH
35877: LD_INT 2
35879: ARRAY
35880: PPUSH
35881: LD_EXP 94
35885: PUSH
35886: LD_VAR 0 2
35890: ARRAY
35891: PUSH
35892: LD_VAR 0 3
35896: ARRAY
35897: PUSH
35898: LD_INT 3
35900: ARRAY
35901: PPUSH
35902: LD_INT 30
35904: PPUSH
35905: CALL 59088 0 4
35909: PUSH
35910: LD_INT 4
35912: ARRAY
35913: PUSH
35914: LD_INT 0
35916: EQUAL
35917: IFFALSE 35943
// begin target := mc_crates [ i ] [ j ] ;
35919: LD_ADDR_VAR 0 7
35923: PUSH
35924: LD_EXP 94
35928: PUSH
35929: LD_VAR 0 2
35933: ARRAY
35934: PUSH
35935: LD_VAR 0 3
35939: ARRAY
35940: ST_TO_ADDR
// break ;
35941: GO 35945
// end ; end ;
35943: GO 35699
35945: POP
35946: POP
// if not target then
35947: LD_VAR 0 7
35951: NOT
35952: IFFALSE 35956
// continue ;
35954: GO 35506
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35956: LD_ADDR_VAR 0 8
35960: PUSH
35961: LD_EXP 97
35965: PUSH
35966: LD_VAR 0 2
35970: ARRAY
35971: PPUSH
35972: LD_INT 2
35974: PUSH
35975: LD_INT 3
35977: PUSH
35978: LD_INT 58
35980: PUSH
35981: EMPTY
35982: LIST
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 61
35990: PUSH
35991: EMPTY
35992: LIST
35993: PUSH
35994: LD_INT 33
35996: PUSH
35997: LD_INT 5
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 33
36006: PUSH
36007: LD_INT 3
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: LIST
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 2
36023: PUSH
36024: LD_INT 34
36026: PUSH
36027: LD_INT 32
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 34
36036: PUSH
36037: LD_INT 51
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 34
36046: PUSH
36047: LD_INT 12
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: LIST
36058: LIST
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PPUSH
36064: CALL_OW 72
36068: ST_TO_ADDR
// if not cargo then
36069: LD_VAR 0 8
36073: NOT
36074: IFFALSE 36780
// begin if mc_crates_collector [ i ] < 5 then
36076: LD_EXP 95
36080: PUSH
36081: LD_VAR 0 2
36085: ARRAY
36086: PUSH
36087: LD_INT 5
36089: LESS
36090: IFFALSE 36456
// begin if mc_ape [ i ] then
36092: LD_EXP 107
36096: PUSH
36097: LD_VAR 0 2
36101: ARRAY
36102: IFFALSE 36149
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36104: LD_ADDR_VAR 0 5
36108: PUSH
36109: LD_EXP 107
36113: PUSH
36114: LD_VAR 0 2
36118: ARRAY
36119: PPUSH
36120: LD_INT 25
36122: PUSH
36123: LD_INT 16
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 24
36132: PUSH
36133: LD_INT 750
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PPUSH
36144: CALL_OW 72
36148: ST_TO_ADDR
// if not tmp then
36149: LD_VAR 0 5
36153: NOT
36154: IFFALSE 36201
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
36156: LD_ADDR_VAR 0 5
36160: PUSH
36161: LD_EXP 78
36165: PUSH
36166: LD_VAR 0 2
36170: ARRAY
36171: PPUSH
36172: LD_INT 25
36174: PUSH
36175: LD_INT 2
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 24
36184: PUSH
36185: LD_INT 750
36187: PUSH
36188: EMPTY
36189: LIST
36190: LIST
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PPUSH
36196: CALL_OW 72
36200: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
36201: LD_EXP 107
36205: PUSH
36206: LD_VAR 0 2
36210: ARRAY
36211: PUSH
36212: LD_EXP 78
36216: PUSH
36217: LD_VAR 0 2
36221: ARRAY
36222: PPUSH
36223: LD_INT 25
36225: PUSH
36226: LD_INT 2
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: LD_INT 24
36235: PUSH
36236: LD_INT 750
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PPUSH
36247: CALL_OW 72
36251: AND
36252: PUSH
36253: LD_VAR 0 5
36257: PUSH
36258: LD_INT 5
36260: LESS
36261: AND
36262: IFFALSE 36344
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
36264: LD_ADDR_VAR 0 3
36268: PUSH
36269: LD_EXP 78
36273: PUSH
36274: LD_VAR 0 2
36278: ARRAY
36279: PPUSH
36280: LD_INT 25
36282: PUSH
36283: LD_INT 2
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 24
36292: PUSH
36293: LD_INT 750
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PPUSH
36304: CALL_OW 72
36308: PUSH
36309: FOR_IN
36310: IFFALSE 36342
// begin tmp := tmp union j ;
36312: LD_ADDR_VAR 0 5
36316: PUSH
36317: LD_VAR 0 5
36321: PUSH
36322: LD_VAR 0 3
36326: UNION
36327: ST_TO_ADDR
// if tmp >= 5 then
36328: LD_VAR 0 5
36332: PUSH
36333: LD_INT 5
36335: GREATEREQUAL
36336: IFFALSE 36340
// break ;
36338: GO 36342
// end ;
36340: GO 36309
36342: POP
36343: POP
// end ; if not tmp then
36344: LD_VAR 0 5
36348: NOT
36349: IFFALSE 36353
// continue ;
36351: GO 35506
// for j in tmp do
36353: LD_ADDR_VAR 0 3
36357: PUSH
36358: LD_VAR 0 5
36362: PUSH
36363: FOR_IN
36364: IFFALSE 36454
// if not GetTag ( j ) then
36366: LD_VAR 0 3
36370: PPUSH
36371: CALL_OW 110
36375: NOT
36376: IFFALSE 36452
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
36378: LD_ADDR_EXP 95
36382: PUSH
36383: LD_EXP 95
36387: PPUSH
36388: LD_VAR 0 2
36392: PUSH
36393: LD_EXP 95
36397: PUSH
36398: LD_VAR 0 2
36402: ARRAY
36403: PUSH
36404: LD_INT 1
36406: PLUS
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PPUSH
36412: LD_VAR 0 3
36416: PPUSH
36417: CALL 57824 0 3
36421: ST_TO_ADDR
// SetTag ( j , 107 ) ;
36422: LD_VAR 0 3
36426: PPUSH
36427: LD_INT 107
36429: PPUSH
36430: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
36434: LD_EXP 95
36438: PUSH
36439: LD_VAR 0 2
36443: ARRAY
36444: PUSH
36445: LD_INT 5
36447: GREATEREQUAL
36448: IFFALSE 36452
// break ;
36450: GO 36454
// end ;
36452: GO 36363
36454: POP
36455: POP
// end ; if mc_crates_collector [ i ] and target then
36456: LD_EXP 95
36460: PUSH
36461: LD_VAR 0 2
36465: ARRAY
36466: PUSH
36467: LD_VAR 0 7
36471: AND
36472: IFFALSE 36778
// begin if mc_crates_collector [ i ] < target [ 1 ] then
36474: LD_EXP 95
36478: PUSH
36479: LD_VAR 0 2
36483: ARRAY
36484: PUSH
36485: LD_VAR 0 7
36489: PUSH
36490: LD_INT 1
36492: ARRAY
36493: LESS
36494: IFFALSE 36514
// tmp := mc_crates_collector [ i ] else
36496: LD_ADDR_VAR 0 5
36500: PUSH
36501: LD_EXP 95
36505: PUSH
36506: LD_VAR 0 2
36510: ARRAY
36511: ST_TO_ADDR
36512: GO 36528
// tmp := target [ 1 ] ;
36514: LD_ADDR_VAR 0 5
36518: PUSH
36519: LD_VAR 0 7
36523: PUSH
36524: LD_INT 1
36526: ARRAY
36527: ST_TO_ADDR
// k := 0 ;
36528: LD_ADDR_VAR 0 4
36532: PUSH
36533: LD_INT 0
36535: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
36536: LD_ADDR_VAR 0 3
36540: PUSH
36541: LD_EXP 95
36545: PUSH
36546: LD_VAR 0 2
36550: ARRAY
36551: PUSH
36552: FOR_IN
36553: IFFALSE 36776
// begin k := k + 1 ;
36555: LD_ADDR_VAR 0 4
36559: PUSH
36560: LD_VAR 0 4
36564: PUSH
36565: LD_INT 1
36567: PLUS
36568: ST_TO_ADDR
// if k > tmp then
36569: LD_VAR 0 4
36573: PUSH
36574: LD_VAR 0 5
36578: GREATER
36579: IFFALSE 36583
// break ;
36581: GO 36776
// if not GetClass ( j ) in [ 2 , 16 ] then
36583: LD_VAR 0 3
36587: PPUSH
36588: CALL_OW 257
36592: PUSH
36593: LD_INT 2
36595: PUSH
36596: LD_INT 16
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: IN
36603: NOT
36604: IFFALSE 36657
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
36606: LD_ADDR_EXP 95
36610: PUSH
36611: LD_EXP 95
36615: PPUSH
36616: LD_VAR 0 2
36620: PPUSH
36621: LD_EXP 95
36625: PUSH
36626: LD_VAR 0 2
36630: ARRAY
36631: PUSH
36632: LD_VAR 0 3
36636: DIFF
36637: PPUSH
36638: CALL_OW 1
36642: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36643: LD_VAR 0 3
36647: PPUSH
36648: LD_INT 0
36650: PPUSH
36651: CALL_OW 109
// continue ;
36655: GO 36552
// end ; if IsInUnit ( j ) then
36657: LD_VAR 0 3
36661: PPUSH
36662: CALL_OW 310
36666: IFFALSE 36677
// ComExitBuilding ( j ) ;
36668: LD_VAR 0 3
36672: PPUSH
36673: CALL_OW 122
// wait ( 3 ) ;
36677: LD_INT 3
36679: PPUSH
36680: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
36684: LD_VAR 0 3
36688: PPUSH
36689: CALL_OW 314
36693: PUSH
36694: LD_VAR 0 6
36698: PPUSH
36699: LD_VAR 0 7
36703: PUSH
36704: LD_INT 2
36706: ARRAY
36707: PPUSH
36708: LD_VAR 0 7
36712: PUSH
36713: LD_INT 3
36715: ARRAY
36716: PPUSH
36717: LD_INT 30
36719: PPUSH
36720: CALL 59088 0 4
36724: PUSH
36725: LD_INT 4
36727: ARRAY
36728: AND
36729: IFFALSE 36747
// ComStandNearbyBuilding ( j , depot ) else
36731: LD_VAR 0 3
36735: PPUSH
36736: LD_VAR 0 9
36740: PPUSH
36741: CALL 54426 0 2
36745: GO 36774
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36747: LD_VAR 0 3
36751: PPUSH
36752: LD_VAR 0 7
36756: PUSH
36757: LD_INT 2
36759: ARRAY
36760: PPUSH
36761: LD_VAR 0 7
36765: PUSH
36766: LD_INT 3
36768: ARRAY
36769: PPUSH
36770: CALL_OW 117
// end ;
36774: GO 36552
36776: POP
36777: POP
// end ; end else
36778: GO 37310
// begin for j in cargo do
36780: LD_ADDR_VAR 0 3
36784: PUSH
36785: LD_VAR 0 8
36789: PUSH
36790: FOR_IN
36791: IFFALSE 37308
// begin if GetTag ( j ) <> 0 then
36793: LD_VAR 0 3
36797: PPUSH
36798: CALL_OW 110
36802: PUSH
36803: LD_INT 0
36805: NONEQUAL
36806: IFFALSE 36810
// continue ;
36808: GO 36790
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
36810: LD_VAR 0 3
36814: PPUSH
36815: CALL_OW 256
36819: PUSH
36820: LD_INT 1000
36822: LESS
36823: PUSH
36824: LD_VAR 0 3
36828: PPUSH
36829: LD_EXP 102
36833: PUSH
36834: LD_VAR 0 2
36838: ARRAY
36839: PPUSH
36840: CALL_OW 308
36844: NOT
36845: AND
36846: IFFALSE 36868
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36848: LD_VAR 0 3
36852: PPUSH
36853: LD_EXP 102
36857: PUSH
36858: LD_VAR 0 2
36862: ARRAY
36863: PPUSH
36864: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36868: LD_VAR 0 3
36872: PPUSH
36873: CALL_OW 256
36877: PUSH
36878: LD_INT 1000
36880: LESS
36881: PUSH
36882: LD_VAR 0 3
36886: PPUSH
36887: LD_EXP 102
36891: PUSH
36892: LD_VAR 0 2
36896: ARRAY
36897: PPUSH
36898: CALL_OW 308
36902: AND
36903: IFFALSE 36907
// continue ;
36905: GO 36790
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36907: LD_VAR 0 3
36911: PPUSH
36912: CALL_OW 262
36916: PUSH
36917: LD_INT 2
36919: EQUAL
36920: PUSH
36921: LD_VAR 0 3
36925: PPUSH
36926: CALL_OW 261
36930: PUSH
36931: LD_INT 15
36933: LESS
36934: AND
36935: IFFALSE 36939
// continue ;
36937: GO 36790
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36939: LD_VAR 0 3
36943: PPUSH
36944: CALL_OW 262
36948: PUSH
36949: LD_INT 1
36951: EQUAL
36952: PUSH
36953: LD_VAR 0 3
36957: PPUSH
36958: CALL_OW 261
36962: PUSH
36963: LD_INT 10
36965: LESS
36966: AND
36967: IFFALSE 37247
// begin if not depot then
36969: LD_VAR 0 9
36973: NOT
36974: IFFALSE 36978
// continue ;
36976: GO 36790
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36978: LD_VAR 0 3
36982: PPUSH
36983: LD_VAR 0 9
36987: PPUSH
36988: LD_VAR 0 3
36992: PPUSH
36993: CALL_OW 74
36997: PPUSH
36998: CALL_OW 296
37002: PUSH
37003: LD_INT 6
37005: LESS
37006: IFFALSE 37022
// SetFuel ( j , 100 ) else
37008: LD_VAR 0 3
37012: PPUSH
37013: LD_INT 100
37015: PPUSH
37016: CALL_OW 240
37020: GO 37247
// if GetFuel ( j ) = 0 then
37022: LD_VAR 0 3
37026: PPUSH
37027: CALL_OW 261
37031: PUSH
37032: LD_INT 0
37034: EQUAL
37035: IFFALSE 37247
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
37037: LD_ADDR_EXP 97
37041: PUSH
37042: LD_EXP 97
37046: PPUSH
37047: LD_VAR 0 2
37051: PPUSH
37052: LD_EXP 97
37056: PUSH
37057: LD_VAR 0 2
37061: ARRAY
37062: PUSH
37063: LD_VAR 0 3
37067: DIFF
37068: PPUSH
37069: CALL_OW 1
37073: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37074: LD_VAR 0 3
37078: PPUSH
37079: CALL_OW 263
37083: PUSH
37084: LD_INT 1
37086: EQUAL
37087: IFFALSE 37103
// ComExitVehicle ( IsInUnit ( j ) ) ;
37089: LD_VAR 0 3
37093: PPUSH
37094: CALL_OW 310
37098: PPUSH
37099: CALL_OW 121
// if GetControl ( j ) = control_remote then
37103: LD_VAR 0 3
37107: PPUSH
37108: CALL_OW 263
37112: PUSH
37113: LD_INT 2
37115: EQUAL
37116: IFFALSE 37127
// ComUnlink ( j ) ;
37118: LD_VAR 0 3
37122: PPUSH
37123: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37127: LD_ADDR_VAR 0 10
37131: PUSH
37132: LD_VAR 0 2
37136: PPUSH
37137: LD_INT 3
37139: PPUSH
37140: CALL 46891 0 2
37144: ST_TO_ADDR
// if fac then
37145: LD_VAR 0 10
37149: IFFALSE 37245
// begin for k in fac do
37151: LD_ADDR_VAR 0 4
37155: PUSH
37156: LD_VAR 0 10
37160: PUSH
37161: FOR_IN
37162: IFFALSE 37243
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
37164: LD_ADDR_VAR 0 11
37168: PUSH
37169: LD_VAR 0 10
37173: PPUSH
37174: LD_VAR 0 3
37178: PPUSH
37179: CALL_OW 265
37183: PPUSH
37184: LD_VAR 0 3
37188: PPUSH
37189: CALL_OW 262
37193: PPUSH
37194: LD_VAR 0 3
37198: PPUSH
37199: CALL_OW 263
37203: PPUSH
37204: LD_VAR 0 3
37208: PPUSH
37209: CALL_OW 264
37213: PPUSH
37214: CALL 55322 0 5
37218: ST_TO_ADDR
// if components then
37219: LD_VAR 0 11
37223: IFFALSE 37241
// begin MC_InsertProduceList ( i , components ) ;
37225: LD_VAR 0 2
37229: PPUSH
37230: LD_VAR 0 11
37234: PPUSH
37235: CALL 46436 0 2
// break ;
37239: GO 37243
// end ; end ;
37241: GO 37161
37243: POP
37244: POP
// end ; continue ;
37245: GO 36790
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
37247: LD_VAR 0 3
37251: PPUSH
37252: LD_INT 1
37254: PPUSH
37255: CALL_OW 289
37259: PUSH
37260: LD_INT 100
37262: LESS
37263: PUSH
37264: LD_VAR 0 3
37268: PPUSH
37269: CALL_OW 314
37273: NOT
37274: AND
37275: IFFALSE 37304
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37277: LD_VAR 0 3
37281: PPUSH
37282: LD_VAR 0 7
37286: PUSH
37287: LD_INT 2
37289: ARRAY
37290: PPUSH
37291: LD_VAR 0 7
37295: PUSH
37296: LD_INT 3
37298: ARRAY
37299: PPUSH
37300: CALL_OW 117
// break ;
37304: GO 37308
// end ;
37306: GO 36790
37308: POP
37309: POP
// end ; end ;
37310: GO 35506
37312: POP
37313: POP
// end ;
37314: LD_VAR 0 1
37318: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
37319: LD_INT 0
37321: PPUSH
37322: PPUSH
37323: PPUSH
37324: PPUSH
// if not mc_bases then
37325: LD_EXP 78
37329: NOT
37330: IFFALSE 37334
// exit ;
37332: GO 37495
// for i = 1 to mc_bases do
37334: LD_ADDR_VAR 0 2
37338: PUSH
37339: DOUBLE
37340: LD_INT 1
37342: DEC
37343: ST_TO_ADDR
37344: LD_EXP 78
37348: PUSH
37349: FOR_TO
37350: IFFALSE 37493
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
37352: LD_ADDR_VAR 0 4
37356: PUSH
37357: LD_EXP 97
37361: PUSH
37362: LD_VAR 0 2
37366: ARRAY
37367: PUSH
37368: LD_EXP 100
37372: PUSH
37373: LD_VAR 0 2
37377: ARRAY
37378: UNION
37379: PPUSH
37380: LD_INT 33
37382: PUSH
37383: LD_INT 2
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PPUSH
37390: CALL_OW 72
37394: ST_TO_ADDR
// if tmp then
37395: LD_VAR 0 4
37399: IFFALSE 37491
// for j in tmp do
37401: LD_ADDR_VAR 0 3
37405: PUSH
37406: LD_VAR 0 4
37410: PUSH
37411: FOR_IN
37412: IFFALSE 37489
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
37414: LD_VAR 0 3
37418: PPUSH
37419: CALL_OW 312
37423: NOT
37424: PUSH
37425: LD_VAR 0 3
37429: PPUSH
37430: CALL_OW 256
37434: PUSH
37435: LD_INT 250
37437: GREATEREQUAL
37438: AND
37439: IFFALSE 37452
// Connect ( j ) else
37441: LD_VAR 0 3
37445: PPUSH
37446: CALL 61170 0 1
37450: GO 37487
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
37452: LD_VAR 0 3
37456: PPUSH
37457: CALL_OW 256
37461: PUSH
37462: LD_INT 250
37464: LESS
37465: PUSH
37466: LD_VAR 0 3
37470: PPUSH
37471: CALL_OW 312
37475: AND
37476: IFFALSE 37487
// ComUnlink ( j ) ;
37478: LD_VAR 0 3
37482: PPUSH
37483: CALL_OW 136
37487: GO 37411
37489: POP
37490: POP
// end ;
37491: GO 37349
37493: POP
37494: POP
// end ;
37495: LD_VAR 0 1
37499: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
37500: LD_INT 0
37502: PPUSH
37503: PPUSH
37504: PPUSH
37505: PPUSH
37506: PPUSH
// if not mc_bases then
37507: LD_EXP 78
37511: NOT
37512: IFFALSE 37516
// exit ;
37514: GO 37961
// for i = 1 to mc_bases do
37516: LD_ADDR_VAR 0 2
37520: PUSH
37521: DOUBLE
37522: LD_INT 1
37524: DEC
37525: ST_TO_ADDR
37526: LD_EXP 78
37530: PUSH
37531: FOR_TO
37532: IFFALSE 37959
// begin if not mc_produce [ i ] then
37534: LD_EXP 99
37538: PUSH
37539: LD_VAR 0 2
37543: ARRAY
37544: NOT
37545: IFFALSE 37549
// continue ;
37547: GO 37531
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37549: LD_ADDR_VAR 0 5
37553: PUSH
37554: LD_EXP 78
37558: PUSH
37559: LD_VAR 0 2
37563: ARRAY
37564: PPUSH
37565: LD_INT 30
37567: PUSH
37568: LD_INT 3
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PPUSH
37575: CALL_OW 72
37579: ST_TO_ADDR
// if not fac then
37580: LD_VAR 0 5
37584: NOT
37585: IFFALSE 37589
// continue ;
37587: GO 37531
// for j in fac do
37589: LD_ADDR_VAR 0 3
37593: PUSH
37594: LD_VAR 0 5
37598: PUSH
37599: FOR_IN
37600: IFFALSE 37955
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
37602: LD_VAR 0 3
37606: PPUSH
37607: CALL_OW 461
37611: PUSH
37612: LD_INT 2
37614: NONEQUAL
37615: PUSH
37616: LD_VAR 0 3
37620: PPUSH
37621: LD_INT 15
37623: PPUSH
37624: CALL 60789 0 2
37628: PUSH
37629: LD_INT 4
37631: ARRAY
37632: OR
37633: IFFALSE 37637
// continue ;
37635: GO 37599
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
37637: LD_VAR 0 3
37641: PPUSH
37642: LD_EXP 99
37646: PUSH
37647: LD_VAR 0 2
37651: ARRAY
37652: PUSH
37653: LD_INT 1
37655: ARRAY
37656: PUSH
37657: LD_INT 1
37659: ARRAY
37660: PPUSH
37661: LD_EXP 99
37665: PUSH
37666: LD_VAR 0 2
37670: ARRAY
37671: PUSH
37672: LD_INT 1
37674: ARRAY
37675: PUSH
37676: LD_INT 2
37678: ARRAY
37679: PPUSH
37680: LD_EXP 99
37684: PUSH
37685: LD_VAR 0 2
37689: ARRAY
37690: PUSH
37691: LD_INT 1
37693: ARRAY
37694: PUSH
37695: LD_INT 3
37697: ARRAY
37698: PPUSH
37699: LD_EXP 99
37703: PUSH
37704: LD_VAR 0 2
37708: ARRAY
37709: PUSH
37710: LD_INT 1
37712: ARRAY
37713: PUSH
37714: LD_INT 4
37716: ARRAY
37717: PPUSH
37718: CALL_OW 448
37722: PUSH
37723: LD_VAR 0 3
37727: PPUSH
37728: LD_EXP 99
37732: PUSH
37733: LD_VAR 0 2
37737: ARRAY
37738: PUSH
37739: LD_INT 1
37741: ARRAY
37742: PUSH
37743: LD_INT 1
37745: ARRAY
37746: PUSH
37747: LD_EXP 99
37751: PUSH
37752: LD_VAR 0 2
37756: ARRAY
37757: PUSH
37758: LD_INT 1
37760: ARRAY
37761: PUSH
37762: LD_INT 2
37764: ARRAY
37765: PUSH
37766: LD_EXP 99
37770: PUSH
37771: LD_VAR 0 2
37775: ARRAY
37776: PUSH
37777: LD_INT 1
37779: ARRAY
37780: PUSH
37781: LD_INT 3
37783: ARRAY
37784: PUSH
37785: LD_EXP 99
37789: PUSH
37790: LD_VAR 0 2
37794: ARRAY
37795: PUSH
37796: LD_INT 1
37798: ARRAY
37799: PUSH
37800: LD_INT 4
37802: ARRAY
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: PPUSH
37810: CALL 64565 0 2
37814: AND
37815: IFFALSE 37953
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37817: LD_VAR 0 3
37821: PPUSH
37822: LD_EXP 99
37826: PUSH
37827: LD_VAR 0 2
37831: ARRAY
37832: PUSH
37833: LD_INT 1
37835: ARRAY
37836: PUSH
37837: LD_INT 1
37839: ARRAY
37840: PPUSH
37841: LD_EXP 99
37845: PUSH
37846: LD_VAR 0 2
37850: ARRAY
37851: PUSH
37852: LD_INT 1
37854: ARRAY
37855: PUSH
37856: LD_INT 2
37858: ARRAY
37859: PPUSH
37860: LD_EXP 99
37864: PUSH
37865: LD_VAR 0 2
37869: ARRAY
37870: PUSH
37871: LD_INT 1
37873: ARRAY
37874: PUSH
37875: LD_INT 3
37877: ARRAY
37878: PPUSH
37879: LD_EXP 99
37883: PUSH
37884: LD_VAR 0 2
37888: ARRAY
37889: PUSH
37890: LD_INT 1
37892: ARRAY
37893: PUSH
37894: LD_INT 4
37896: ARRAY
37897: PPUSH
37898: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37902: LD_ADDR_VAR 0 4
37906: PUSH
37907: LD_EXP 99
37911: PUSH
37912: LD_VAR 0 2
37916: ARRAY
37917: PPUSH
37918: LD_INT 1
37920: PPUSH
37921: CALL_OW 3
37925: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37926: LD_ADDR_EXP 99
37930: PUSH
37931: LD_EXP 99
37935: PPUSH
37936: LD_VAR 0 2
37940: PPUSH
37941: LD_VAR 0 4
37945: PPUSH
37946: CALL_OW 1
37950: ST_TO_ADDR
// break ;
37951: GO 37955
// end ; end ;
37953: GO 37599
37955: POP
37956: POP
// end ;
37957: GO 37531
37959: POP
37960: POP
// end ;
37961: LD_VAR 0 1
37965: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37966: LD_INT 0
37968: PPUSH
37969: PPUSH
37970: PPUSH
// if not mc_bases then
37971: LD_EXP 78
37975: NOT
37976: IFFALSE 37980
// exit ;
37978: GO 38069
// for i = 1 to mc_bases do
37980: LD_ADDR_VAR 0 2
37984: PUSH
37985: DOUBLE
37986: LD_INT 1
37988: DEC
37989: ST_TO_ADDR
37990: LD_EXP 78
37994: PUSH
37995: FOR_TO
37996: IFFALSE 38067
// begin if mc_attack [ i ] then
37998: LD_EXP 98
38002: PUSH
38003: LD_VAR 0 2
38007: ARRAY
38008: IFFALSE 38065
// begin tmp := mc_attack [ i ] [ 1 ] ;
38010: LD_ADDR_VAR 0 3
38014: PUSH
38015: LD_EXP 98
38019: PUSH
38020: LD_VAR 0 2
38024: ARRAY
38025: PUSH
38026: LD_INT 1
38028: ARRAY
38029: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38030: LD_ADDR_EXP 98
38034: PUSH
38035: LD_EXP 98
38039: PPUSH
38040: LD_VAR 0 2
38044: PPUSH
38045: EMPTY
38046: PPUSH
38047: CALL_OW 1
38051: ST_TO_ADDR
// Attack ( tmp ) ;
38052: LD_VAR 0 3
38056: PPUSH
38057: CALL 115316 0 1
// exit ;
38061: POP
38062: POP
38063: GO 38069
// end ; end ;
38065: GO 37995
38067: POP
38068: POP
// end ;
38069: LD_VAR 0 1
38073: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38074: LD_INT 0
38076: PPUSH
38077: PPUSH
38078: PPUSH
38079: PPUSH
38080: PPUSH
38081: PPUSH
38082: PPUSH
// if not mc_bases then
38083: LD_EXP 78
38087: NOT
38088: IFFALSE 38092
// exit ;
38090: GO 38949
// for i = 1 to mc_bases do
38092: LD_ADDR_VAR 0 2
38096: PUSH
38097: DOUBLE
38098: LD_INT 1
38100: DEC
38101: ST_TO_ADDR
38102: LD_EXP 78
38106: PUSH
38107: FOR_TO
38108: IFFALSE 38947
// begin if not mc_bases [ i ] then
38110: LD_EXP 78
38114: PUSH
38115: LD_VAR 0 2
38119: ARRAY
38120: NOT
38121: IFFALSE 38125
// continue ;
38123: GO 38107
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38125: LD_ADDR_VAR 0 7
38129: PUSH
38130: LD_EXP 78
38134: PUSH
38135: LD_VAR 0 2
38139: ARRAY
38140: PUSH
38141: LD_INT 1
38143: ARRAY
38144: PPUSH
38145: CALL 54648 0 1
38149: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
38150: LD_ADDR_EXP 101
38154: PUSH
38155: LD_EXP 101
38159: PPUSH
38160: LD_VAR 0 2
38164: PPUSH
38165: LD_EXP 78
38169: PUSH
38170: LD_VAR 0 2
38174: ARRAY
38175: PUSH
38176: LD_INT 1
38178: ARRAY
38179: PPUSH
38180: CALL_OW 255
38184: PPUSH
38185: LD_EXP 103
38189: PUSH
38190: LD_VAR 0 2
38194: ARRAY
38195: PPUSH
38196: CALL 54613 0 2
38200: PPUSH
38201: CALL_OW 1
38205: ST_TO_ADDR
// if not mc_scan [ i ] then
38206: LD_EXP 101
38210: PUSH
38211: LD_VAR 0 2
38215: ARRAY
38216: NOT
38217: IFFALSE 38395
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38219: LD_ADDR_EXP 121
38223: PUSH
38224: LD_EXP 121
38228: PPUSH
38229: LD_VAR 0 2
38233: PPUSH
38234: LD_INT 0
38236: PPUSH
38237: CALL_OW 1
38241: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38242: LD_ADDR_VAR 0 4
38246: PUSH
38247: LD_EXP 78
38251: PUSH
38252: LD_VAR 0 2
38256: ARRAY
38257: PPUSH
38258: LD_INT 2
38260: PUSH
38261: LD_INT 25
38263: PUSH
38264: LD_INT 5
38266: PUSH
38267: EMPTY
38268: LIST
38269: LIST
38270: PUSH
38271: LD_INT 25
38273: PUSH
38274: LD_INT 8
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PUSH
38281: LD_INT 25
38283: PUSH
38284: LD_INT 9
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: LIST
38295: LIST
38296: PPUSH
38297: CALL_OW 72
38301: ST_TO_ADDR
// if not tmp then
38302: LD_VAR 0 4
38306: NOT
38307: IFFALSE 38311
// continue ;
38309: GO 38107
// for j in tmp do
38311: LD_ADDR_VAR 0 3
38315: PUSH
38316: LD_VAR 0 4
38320: PUSH
38321: FOR_IN
38322: IFFALSE 38393
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
38324: LD_VAR 0 3
38328: PPUSH
38329: CALL_OW 310
38333: PPUSH
38334: CALL_OW 266
38338: PUSH
38339: LD_INT 5
38341: EQUAL
38342: PUSH
38343: LD_VAR 0 3
38347: PPUSH
38348: CALL_OW 257
38352: PUSH
38353: LD_INT 1
38355: EQUAL
38356: AND
38357: PUSH
38358: LD_VAR 0 3
38362: PPUSH
38363: CALL_OW 459
38367: NOT
38368: AND
38369: PUSH
38370: LD_VAR 0 7
38374: AND
38375: IFFALSE 38391
// ComChangeProfession ( j , class ) ;
38377: LD_VAR 0 3
38381: PPUSH
38382: LD_VAR 0 7
38386: PPUSH
38387: CALL_OW 123
38391: GO 38321
38393: POP
38394: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
38395: LD_EXP 101
38399: PUSH
38400: LD_VAR 0 2
38404: ARRAY
38405: PUSH
38406: LD_EXP 121
38410: PUSH
38411: LD_VAR 0 2
38415: ARRAY
38416: NOT
38417: AND
38418: PUSH
38419: LD_EXP 100
38423: PUSH
38424: LD_VAR 0 2
38428: ARRAY
38429: NOT
38430: AND
38431: PUSH
38432: LD_EXP 78
38436: PUSH
38437: LD_VAR 0 2
38441: ARRAY
38442: PPUSH
38443: LD_INT 50
38445: PUSH
38446: EMPTY
38447: LIST
38448: PUSH
38449: LD_INT 2
38451: PUSH
38452: LD_INT 30
38454: PUSH
38455: LD_INT 32
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 30
38464: PUSH
38465: LD_INT 33
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 30
38474: PUSH
38475: LD_INT 4
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 30
38484: PUSH
38485: LD_INT 5
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: LIST
38496: LIST
38497: LIST
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PPUSH
38503: CALL_OW 72
38507: PUSH
38508: LD_INT 4
38510: LESS
38511: PUSH
38512: LD_EXP 78
38516: PUSH
38517: LD_VAR 0 2
38521: ARRAY
38522: PPUSH
38523: LD_INT 3
38525: PUSH
38526: LD_INT 24
38528: PUSH
38529: LD_INT 1000
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 2
38542: PUSH
38543: LD_INT 30
38545: PUSH
38546: LD_INT 0
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 30
38555: PUSH
38556: LD_INT 1
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: LIST
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PPUSH
38572: CALL_OW 72
38576: OR
38577: AND
38578: IFFALSE 38829
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38580: LD_ADDR_EXP 121
38584: PUSH
38585: LD_EXP 121
38589: PPUSH
38590: LD_VAR 0 2
38594: PPUSH
38595: LD_INT 1
38597: PPUSH
38598: CALL_OW 1
38602: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38603: LD_ADDR_VAR 0 4
38607: PUSH
38608: LD_EXP 78
38612: PUSH
38613: LD_VAR 0 2
38617: ARRAY
38618: PPUSH
38619: LD_INT 2
38621: PUSH
38622: LD_INT 25
38624: PUSH
38625: LD_INT 1
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 25
38634: PUSH
38635: LD_INT 5
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: LD_INT 25
38644: PUSH
38645: LD_INT 8
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 25
38654: PUSH
38655: LD_INT 9
38657: PUSH
38658: EMPTY
38659: LIST
38660: LIST
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: LIST
38668: PPUSH
38669: CALL_OW 72
38673: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
38674: LD_ADDR_VAR 0 4
38678: PUSH
38679: LD_VAR 0 4
38683: PUSH
38684: LD_VAR 0 4
38688: PPUSH
38689: LD_INT 18
38691: PPUSH
38692: CALL 88133 0 2
38696: DIFF
38697: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
38698: LD_VAR 0 4
38702: NOT
38703: PUSH
38704: LD_EXP 78
38708: PUSH
38709: LD_VAR 0 2
38713: ARRAY
38714: PPUSH
38715: LD_INT 2
38717: PUSH
38718: LD_INT 30
38720: PUSH
38721: LD_INT 4
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 30
38730: PUSH
38731: LD_INT 5
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: LIST
38742: PPUSH
38743: CALL_OW 72
38747: NOT
38748: AND
38749: IFFALSE 38811
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
38751: LD_ADDR_VAR 0 4
38755: PUSH
38756: LD_EXP 78
38760: PUSH
38761: LD_VAR 0 2
38765: ARRAY
38766: PPUSH
38767: LD_INT 2
38769: PUSH
38770: LD_INT 25
38772: PUSH
38773: LD_INT 2
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: LD_INT 25
38782: PUSH
38783: LD_INT 3
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: LD_INT 25
38792: PUSH
38793: LD_INT 4
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: LIST
38804: LIST
38805: PPUSH
38806: CALL_OW 72
38810: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38811: LD_VAR 0 2
38815: PPUSH
38816: LD_VAR 0 4
38820: PPUSH
38821: CALL 120025 0 2
// exit ;
38825: POP
38826: POP
38827: GO 38949
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38829: LD_EXP 101
38833: PUSH
38834: LD_VAR 0 2
38838: ARRAY
38839: PUSH
38840: LD_EXP 121
38844: PUSH
38845: LD_VAR 0 2
38849: ARRAY
38850: NOT
38851: AND
38852: PUSH
38853: LD_EXP 100
38857: PUSH
38858: LD_VAR 0 2
38862: ARRAY
38863: AND
38864: IFFALSE 38945
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38866: LD_ADDR_EXP 121
38870: PUSH
38871: LD_EXP 121
38875: PPUSH
38876: LD_VAR 0 2
38880: PPUSH
38881: LD_INT 1
38883: PPUSH
38884: CALL_OW 1
38888: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38889: LD_ADDR_VAR 0 4
38893: PUSH
38894: LD_EXP 100
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38905: LD_ADDR_EXP 100
38909: PUSH
38910: LD_EXP 100
38914: PPUSH
38915: LD_VAR 0 2
38919: PPUSH
38920: EMPTY
38921: PPUSH
38922: CALL_OW 1
38926: ST_TO_ADDR
// Defend ( i , tmp ) ;
38927: LD_VAR 0 2
38931: PPUSH
38932: LD_VAR 0 4
38936: PPUSH
38937: CALL 120621 0 2
// exit ;
38941: POP
38942: POP
38943: GO 38949
// end ; end ;
38945: GO 38107
38947: POP
38948: POP
// end ;
38949: LD_VAR 0 1
38953: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38954: LD_INT 0
38956: PPUSH
38957: PPUSH
38958: PPUSH
38959: PPUSH
38960: PPUSH
38961: PPUSH
38962: PPUSH
38963: PPUSH
38964: PPUSH
38965: PPUSH
38966: PPUSH
// if not mc_bases then
38967: LD_EXP 78
38971: NOT
38972: IFFALSE 38976
// exit ;
38974: GO 40063
// for i = 1 to mc_bases do
38976: LD_ADDR_VAR 0 2
38980: PUSH
38981: DOUBLE
38982: LD_INT 1
38984: DEC
38985: ST_TO_ADDR
38986: LD_EXP 78
38990: PUSH
38991: FOR_TO
38992: IFFALSE 40061
// begin tmp := mc_lab [ i ] ;
38994: LD_ADDR_VAR 0 6
38998: PUSH
38999: LD_EXP 111
39003: PUSH
39004: LD_VAR 0 2
39008: ARRAY
39009: ST_TO_ADDR
// if not tmp then
39010: LD_VAR 0 6
39014: NOT
39015: IFFALSE 39019
// continue ;
39017: GO 38991
// idle_lab := 0 ;
39019: LD_ADDR_VAR 0 11
39023: PUSH
39024: LD_INT 0
39026: ST_TO_ADDR
// for j in tmp do
39027: LD_ADDR_VAR 0 3
39031: PUSH
39032: LD_VAR 0 6
39036: PUSH
39037: FOR_IN
39038: IFFALSE 40057
// begin researching := false ;
39040: LD_ADDR_VAR 0 10
39044: PUSH
39045: LD_INT 0
39047: ST_TO_ADDR
// side := GetSide ( j ) ;
39048: LD_ADDR_VAR 0 4
39052: PUSH
39053: LD_VAR 0 3
39057: PPUSH
39058: CALL_OW 255
39062: ST_TO_ADDR
// if not mc_tech [ side ] then
39063: LD_EXP 105
39067: PUSH
39068: LD_VAR 0 4
39072: ARRAY
39073: NOT
39074: IFFALSE 39078
// continue ;
39076: GO 39037
// if BuildingStatus ( j ) = bs_idle then
39078: LD_VAR 0 3
39082: PPUSH
39083: CALL_OW 461
39087: PUSH
39088: LD_INT 2
39090: EQUAL
39091: IFFALSE 39279
// begin if idle_lab and UnitsInside ( j ) < 6 then
39093: LD_VAR 0 11
39097: PUSH
39098: LD_VAR 0 3
39102: PPUSH
39103: CALL_OW 313
39107: PUSH
39108: LD_INT 6
39110: LESS
39111: AND
39112: IFFALSE 39183
// begin tmp2 := UnitsInside ( idle_lab ) ;
39114: LD_ADDR_VAR 0 9
39118: PUSH
39119: LD_VAR 0 11
39123: PPUSH
39124: CALL_OW 313
39128: ST_TO_ADDR
// if tmp2 then
39129: LD_VAR 0 9
39133: IFFALSE 39175
// for x in tmp2 do
39135: LD_ADDR_VAR 0 7
39139: PUSH
39140: LD_VAR 0 9
39144: PUSH
39145: FOR_IN
39146: IFFALSE 39173
// begin ComExitBuilding ( x ) ;
39148: LD_VAR 0 7
39152: PPUSH
39153: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39157: LD_VAR 0 7
39161: PPUSH
39162: LD_VAR 0 3
39166: PPUSH
39167: CALL_OW 180
// end ;
39171: GO 39145
39173: POP
39174: POP
// idle_lab := 0 ;
39175: LD_ADDR_VAR 0 11
39179: PUSH
39180: LD_INT 0
39182: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
39183: LD_ADDR_VAR 0 5
39187: PUSH
39188: LD_EXP 105
39192: PUSH
39193: LD_VAR 0 4
39197: ARRAY
39198: PUSH
39199: FOR_IN
39200: IFFALSE 39260
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
39202: LD_VAR 0 3
39206: PPUSH
39207: LD_VAR 0 5
39211: PPUSH
39212: CALL_OW 430
39216: PUSH
39217: LD_VAR 0 4
39221: PPUSH
39222: LD_VAR 0 5
39226: PPUSH
39227: CALL 53718 0 2
39231: AND
39232: IFFALSE 39258
// begin researching := true ;
39234: LD_ADDR_VAR 0 10
39238: PUSH
39239: LD_INT 1
39241: ST_TO_ADDR
// ComResearch ( j , t ) ;
39242: LD_VAR 0 3
39246: PPUSH
39247: LD_VAR 0 5
39251: PPUSH
39252: CALL_OW 124
// break ;
39256: GO 39260
// end ;
39258: GO 39199
39260: POP
39261: POP
// if not researching then
39262: LD_VAR 0 10
39266: NOT
39267: IFFALSE 39279
// idle_lab := j ;
39269: LD_ADDR_VAR 0 11
39273: PUSH
39274: LD_VAR 0 3
39278: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
39279: LD_VAR 0 3
39283: PPUSH
39284: CALL_OW 461
39288: PUSH
39289: LD_INT 10
39291: EQUAL
39292: IFFALSE 39880
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
39294: LD_EXP 107
39298: PUSH
39299: LD_VAR 0 2
39303: ARRAY
39304: NOT
39305: PUSH
39306: LD_EXP 108
39310: PUSH
39311: LD_VAR 0 2
39315: ARRAY
39316: NOT
39317: AND
39318: PUSH
39319: LD_EXP 105
39323: PUSH
39324: LD_VAR 0 4
39328: ARRAY
39329: PUSH
39330: LD_INT 1
39332: GREATER
39333: AND
39334: IFFALSE 39465
// begin ComCancel ( j ) ;
39336: LD_VAR 0 3
39340: PPUSH
39341: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
39345: LD_ADDR_EXP 105
39349: PUSH
39350: LD_EXP 105
39354: PPUSH
39355: LD_VAR 0 4
39359: PPUSH
39360: LD_EXP 105
39364: PUSH
39365: LD_VAR 0 4
39369: ARRAY
39370: PPUSH
39371: LD_EXP 105
39375: PUSH
39376: LD_VAR 0 4
39380: ARRAY
39381: PUSH
39382: LD_INT 1
39384: MINUS
39385: PPUSH
39386: LD_EXP 105
39390: PUSH
39391: LD_VAR 0 4
39395: ARRAY
39396: PPUSH
39397: LD_INT 0
39399: PPUSH
39400: CALL 57242 0 4
39404: PPUSH
39405: CALL_OW 1
39409: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
39410: LD_ADDR_EXP 105
39414: PUSH
39415: LD_EXP 105
39419: PPUSH
39420: LD_VAR 0 4
39424: PPUSH
39425: LD_EXP 105
39429: PUSH
39430: LD_VAR 0 4
39434: ARRAY
39435: PPUSH
39436: LD_EXP 105
39440: PUSH
39441: LD_VAR 0 4
39445: ARRAY
39446: PPUSH
39447: LD_INT 1
39449: PPUSH
39450: LD_INT 0
39452: PPUSH
39453: CALL 57242 0 4
39457: PPUSH
39458: CALL_OW 1
39462: ST_TO_ADDR
// continue ;
39463: GO 39037
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
39465: LD_EXP 107
39469: PUSH
39470: LD_VAR 0 2
39474: ARRAY
39475: PUSH
39476: LD_EXP 108
39480: PUSH
39481: LD_VAR 0 2
39485: ARRAY
39486: NOT
39487: AND
39488: IFFALSE 39615
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
39490: LD_ADDR_EXP 108
39494: PUSH
39495: LD_EXP 108
39499: PPUSH
39500: LD_VAR 0 2
39504: PUSH
39505: LD_EXP 108
39509: PUSH
39510: LD_VAR 0 2
39514: ARRAY
39515: PUSH
39516: LD_INT 1
39518: PLUS
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PPUSH
39524: LD_EXP 107
39528: PUSH
39529: LD_VAR 0 2
39533: ARRAY
39534: PUSH
39535: LD_INT 1
39537: ARRAY
39538: PPUSH
39539: CALL 57824 0 3
39543: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
39544: LD_EXP 107
39548: PUSH
39549: LD_VAR 0 2
39553: ARRAY
39554: PUSH
39555: LD_INT 1
39557: ARRAY
39558: PPUSH
39559: LD_INT 112
39561: PPUSH
39562: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
39566: LD_ADDR_VAR 0 9
39570: PUSH
39571: LD_EXP 107
39575: PUSH
39576: LD_VAR 0 2
39580: ARRAY
39581: PPUSH
39582: LD_INT 1
39584: PPUSH
39585: CALL_OW 3
39589: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
39590: LD_ADDR_EXP 107
39594: PUSH
39595: LD_EXP 107
39599: PPUSH
39600: LD_VAR 0 2
39604: PPUSH
39605: LD_VAR 0 9
39609: PPUSH
39610: CALL_OW 1
39614: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
39615: LD_EXP 107
39619: PUSH
39620: LD_VAR 0 2
39624: ARRAY
39625: PUSH
39626: LD_EXP 108
39630: PUSH
39631: LD_VAR 0 2
39635: ARRAY
39636: AND
39637: PUSH
39638: LD_EXP 108
39642: PUSH
39643: LD_VAR 0 2
39647: ARRAY
39648: PUSH
39649: LD_INT 1
39651: ARRAY
39652: PPUSH
39653: CALL_OW 310
39657: NOT
39658: AND
39659: PUSH
39660: LD_VAR 0 3
39664: PPUSH
39665: CALL_OW 313
39669: PUSH
39670: LD_INT 6
39672: EQUAL
39673: AND
39674: IFFALSE 39730
// begin tmp2 := UnitsInside ( j ) ;
39676: LD_ADDR_VAR 0 9
39680: PUSH
39681: LD_VAR 0 3
39685: PPUSH
39686: CALL_OW 313
39690: ST_TO_ADDR
// if tmp2 = 6 then
39691: LD_VAR 0 9
39695: PUSH
39696: LD_INT 6
39698: EQUAL
39699: IFFALSE 39730
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
39701: LD_VAR 0 9
39705: PUSH
39706: LD_INT 1
39708: ARRAY
39709: PPUSH
39710: LD_INT 112
39712: PPUSH
39713: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
39717: LD_VAR 0 9
39721: PUSH
39722: LD_INT 1
39724: ARRAY
39725: PPUSH
39726: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
39730: LD_EXP 108
39734: PUSH
39735: LD_VAR 0 2
39739: ARRAY
39740: PUSH
39741: LD_EXP 108
39745: PUSH
39746: LD_VAR 0 2
39750: ARRAY
39751: PUSH
39752: LD_INT 1
39754: ARRAY
39755: PPUSH
39756: CALL_OW 314
39760: NOT
39761: AND
39762: PUSH
39763: LD_EXP 108
39767: PUSH
39768: LD_VAR 0 2
39772: ARRAY
39773: PUSH
39774: LD_INT 1
39776: ARRAY
39777: PPUSH
39778: CALL_OW 310
39782: NOT
39783: AND
39784: IFFALSE 39810
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
39786: LD_EXP 108
39790: PUSH
39791: LD_VAR 0 2
39795: ARRAY
39796: PUSH
39797: LD_INT 1
39799: ARRAY
39800: PPUSH
39801: LD_VAR 0 3
39805: PPUSH
39806: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
39810: LD_EXP 108
39814: PUSH
39815: LD_VAR 0 2
39819: ARRAY
39820: PUSH
39821: LD_INT 1
39823: ARRAY
39824: PPUSH
39825: CALL_OW 310
39829: PUSH
39830: LD_EXP 108
39834: PUSH
39835: LD_VAR 0 2
39839: ARRAY
39840: PUSH
39841: LD_INT 1
39843: ARRAY
39844: PPUSH
39845: CALL_OW 310
39849: PPUSH
39850: CALL_OW 461
39854: PUSH
39855: LD_INT 3
39857: NONEQUAL
39858: AND
39859: IFFALSE 39880
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39861: LD_EXP 108
39865: PUSH
39866: LD_VAR 0 2
39870: ARRAY
39871: PUSH
39872: LD_INT 1
39874: ARRAY
39875: PPUSH
39876: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39880: LD_VAR 0 3
39884: PPUSH
39885: CALL_OW 461
39889: PUSH
39890: LD_INT 6
39892: EQUAL
39893: PUSH
39894: LD_VAR 0 6
39898: PUSH
39899: LD_INT 1
39901: GREATER
39902: AND
39903: IFFALSE 40055
// begin sci := [ ] ;
39905: LD_ADDR_VAR 0 8
39909: PUSH
39910: EMPTY
39911: ST_TO_ADDR
// for x in ( tmp diff j ) do
39912: LD_ADDR_VAR 0 7
39916: PUSH
39917: LD_VAR 0 6
39921: PUSH
39922: LD_VAR 0 3
39926: DIFF
39927: PUSH
39928: FOR_IN
39929: IFFALSE 39981
// begin if sci = 6 then
39931: LD_VAR 0 8
39935: PUSH
39936: LD_INT 6
39938: EQUAL
39939: IFFALSE 39943
// break ;
39941: GO 39981
// if BuildingStatus ( x ) = bs_idle then
39943: LD_VAR 0 7
39947: PPUSH
39948: CALL_OW 461
39952: PUSH
39953: LD_INT 2
39955: EQUAL
39956: IFFALSE 39979
// sci := sci ^ UnitsInside ( x ) ;
39958: LD_ADDR_VAR 0 8
39962: PUSH
39963: LD_VAR 0 8
39967: PUSH
39968: LD_VAR 0 7
39972: PPUSH
39973: CALL_OW 313
39977: ADD
39978: ST_TO_ADDR
// end ;
39979: GO 39928
39981: POP
39982: POP
// if not sci then
39983: LD_VAR 0 8
39987: NOT
39988: IFFALSE 39992
// continue ;
39990: GO 39037
// for x in sci do
39992: LD_ADDR_VAR 0 7
39996: PUSH
39997: LD_VAR 0 8
40001: PUSH
40002: FOR_IN
40003: IFFALSE 40053
// if IsInUnit ( x ) and not HasTask ( x ) then
40005: LD_VAR 0 7
40009: PPUSH
40010: CALL_OW 310
40014: PUSH
40015: LD_VAR 0 7
40019: PPUSH
40020: CALL_OW 314
40024: NOT
40025: AND
40026: IFFALSE 40051
// begin ComExitBuilding ( x ) ;
40028: LD_VAR 0 7
40032: PPUSH
40033: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40037: LD_VAR 0 7
40041: PPUSH
40042: LD_VAR 0 3
40046: PPUSH
40047: CALL_OW 180
// end ;
40051: GO 40002
40053: POP
40054: POP
// end ; end ;
40055: GO 39037
40057: POP
40058: POP
// end ;
40059: GO 38991
40061: POP
40062: POP
// end ;
40063: LD_VAR 0 1
40067: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40068: LD_INT 0
40070: PPUSH
40071: PPUSH
// if not mc_bases then
40072: LD_EXP 78
40076: NOT
40077: IFFALSE 40081
// exit ;
40079: GO 40162
// for i = 1 to mc_bases do
40081: LD_ADDR_VAR 0 2
40085: PUSH
40086: DOUBLE
40087: LD_INT 1
40089: DEC
40090: ST_TO_ADDR
40091: LD_EXP 78
40095: PUSH
40096: FOR_TO
40097: IFFALSE 40160
// if mc_mines [ i ] and mc_miners [ i ] then
40099: LD_EXP 91
40103: PUSH
40104: LD_VAR 0 2
40108: ARRAY
40109: PUSH
40110: LD_EXP 92
40114: PUSH
40115: LD_VAR 0 2
40119: ARRAY
40120: AND
40121: IFFALSE 40158
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40123: LD_EXP 92
40127: PUSH
40128: LD_VAR 0 2
40132: ARRAY
40133: PUSH
40134: LD_INT 1
40136: ARRAY
40137: PPUSH
40138: CALL_OW 255
40142: PPUSH
40143: LD_EXP 91
40147: PUSH
40148: LD_VAR 0 2
40152: ARRAY
40153: PPUSH
40154: CALL 54801 0 2
40158: GO 40096
40160: POP
40161: POP
// end ;
40162: LD_VAR 0 1
40166: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
40167: LD_INT 0
40169: PPUSH
40170: PPUSH
40171: PPUSH
40172: PPUSH
40173: PPUSH
40174: PPUSH
40175: PPUSH
40176: PPUSH
// if not mc_bases or not mc_parking then
40177: LD_EXP 78
40181: NOT
40182: PUSH
40183: LD_EXP 102
40187: NOT
40188: OR
40189: IFFALSE 40193
// exit ;
40191: GO 40931
// for i = 1 to mc_bases do
40193: LD_ADDR_VAR 0 2
40197: PUSH
40198: DOUBLE
40199: LD_INT 1
40201: DEC
40202: ST_TO_ADDR
40203: LD_EXP 78
40207: PUSH
40208: FOR_TO
40209: IFFALSE 40929
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
40211: LD_EXP 78
40215: PUSH
40216: LD_VAR 0 2
40220: ARRAY
40221: NOT
40222: PUSH
40223: LD_EXP 102
40227: PUSH
40228: LD_VAR 0 2
40232: ARRAY
40233: NOT
40234: OR
40235: IFFALSE 40239
// continue ;
40237: GO 40208
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
40239: LD_ADDR_VAR 0 5
40243: PUSH
40244: LD_EXP 78
40248: PUSH
40249: LD_VAR 0 2
40253: ARRAY
40254: PUSH
40255: LD_INT 1
40257: ARRAY
40258: PPUSH
40259: CALL_OW 255
40263: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40264: LD_ADDR_VAR 0 6
40268: PUSH
40269: LD_EXP 78
40273: PUSH
40274: LD_VAR 0 2
40278: ARRAY
40279: PPUSH
40280: LD_INT 30
40282: PUSH
40283: LD_INT 3
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PPUSH
40290: CALL_OW 72
40294: ST_TO_ADDR
// if not fac then
40295: LD_VAR 0 6
40299: NOT
40300: IFFALSE 40351
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40302: LD_ADDR_VAR 0 6
40306: PUSH
40307: LD_EXP 78
40311: PUSH
40312: LD_VAR 0 2
40316: ARRAY
40317: PPUSH
40318: LD_INT 2
40320: PUSH
40321: LD_INT 30
40323: PUSH
40324: LD_INT 0
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: LD_INT 30
40333: PUSH
40334: LD_INT 1
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: LIST
40345: PPUSH
40346: CALL_OW 72
40350: ST_TO_ADDR
// if not fac then
40351: LD_VAR 0 6
40355: NOT
40356: IFFALSE 40360
// continue ;
40358: GO 40208
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40360: LD_ADDR_VAR 0 7
40364: PUSH
40365: LD_EXP 102
40369: PUSH
40370: LD_VAR 0 2
40374: ARRAY
40375: PPUSH
40376: LD_INT 22
40378: PUSH
40379: LD_VAR 0 5
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: PUSH
40388: LD_INT 21
40390: PUSH
40391: LD_INT 2
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 3
40400: PUSH
40401: LD_INT 60
40403: PUSH
40404: EMPTY
40405: LIST
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 3
40413: PUSH
40414: LD_INT 24
40416: PUSH
40417: LD_INT 1000
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: LIST
40432: LIST
40433: PPUSH
40434: CALL_OW 70
40438: ST_TO_ADDR
// for j in fac do
40439: LD_ADDR_VAR 0 3
40443: PUSH
40444: LD_VAR 0 6
40448: PUSH
40449: FOR_IN
40450: IFFALSE 40545
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40452: LD_ADDR_VAR 0 7
40456: PUSH
40457: LD_VAR 0 7
40461: PUSH
40462: LD_INT 22
40464: PUSH
40465: LD_VAR 0 5
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 91
40476: PUSH
40477: LD_VAR 0 3
40481: PUSH
40482: LD_INT 15
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 21
40492: PUSH
40493: LD_INT 2
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 3
40502: PUSH
40503: LD_INT 60
40505: PUSH
40506: EMPTY
40507: LIST
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 3
40515: PUSH
40516: LD_INT 24
40518: PUSH
40519: LD_INT 1000
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: PPUSH
40537: CALL_OW 69
40541: UNION
40542: ST_TO_ADDR
40543: GO 40449
40545: POP
40546: POP
// if not vehs then
40547: LD_VAR 0 7
40551: NOT
40552: IFFALSE 40578
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
40554: LD_ADDR_EXP 90
40558: PUSH
40559: LD_EXP 90
40563: PPUSH
40564: LD_VAR 0 2
40568: PPUSH
40569: EMPTY
40570: PPUSH
40571: CALL_OW 1
40575: ST_TO_ADDR
// continue ;
40576: GO 40208
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40578: LD_ADDR_VAR 0 8
40582: PUSH
40583: LD_EXP 78
40587: PUSH
40588: LD_VAR 0 2
40592: ARRAY
40593: PPUSH
40594: LD_INT 30
40596: PUSH
40597: LD_INT 3
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PPUSH
40604: CALL_OW 72
40608: ST_TO_ADDR
// if tmp then
40609: LD_VAR 0 8
40613: IFFALSE 40716
// begin for j in tmp do
40615: LD_ADDR_VAR 0 3
40619: PUSH
40620: LD_VAR 0 8
40624: PUSH
40625: FOR_IN
40626: IFFALSE 40714
// for k in UnitsInside ( j ) do
40628: LD_ADDR_VAR 0 4
40632: PUSH
40633: LD_VAR 0 3
40637: PPUSH
40638: CALL_OW 313
40642: PUSH
40643: FOR_IN
40644: IFFALSE 40710
// if k then
40646: LD_VAR 0 4
40650: IFFALSE 40708
// if not k in mc_repair_vehicle [ i ] then
40652: LD_VAR 0 4
40656: PUSH
40657: LD_EXP 90
40661: PUSH
40662: LD_VAR 0 2
40666: ARRAY
40667: IN
40668: NOT
40669: IFFALSE 40708
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
40671: LD_ADDR_EXP 90
40675: PUSH
40676: LD_EXP 90
40680: PPUSH
40681: LD_VAR 0 2
40685: PPUSH
40686: LD_EXP 90
40690: PUSH
40691: LD_VAR 0 2
40695: ARRAY
40696: PUSH
40697: LD_VAR 0 4
40701: UNION
40702: PPUSH
40703: CALL_OW 1
40707: ST_TO_ADDR
40708: GO 40643
40710: POP
40711: POP
40712: GO 40625
40714: POP
40715: POP
// end ; if not mc_repair_vehicle [ i ] then
40716: LD_EXP 90
40720: PUSH
40721: LD_VAR 0 2
40725: ARRAY
40726: NOT
40727: IFFALSE 40731
// continue ;
40729: GO 40208
// for j in mc_repair_vehicle [ i ] do
40731: LD_ADDR_VAR 0 3
40735: PUSH
40736: LD_EXP 90
40740: PUSH
40741: LD_VAR 0 2
40745: ARRAY
40746: PUSH
40747: FOR_IN
40748: IFFALSE 40925
// begin if GetClass ( j ) <> 3 then
40750: LD_VAR 0 3
40754: PPUSH
40755: CALL_OW 257
40759: PUSH
40760: LD_INT 3
40762: NONEQUAL
40763: IFFALSE 40804
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
40765: LD_ADDR_EXP 90
40769: PUSH
40770: LD_EXP 90
40774: PPUSH
40775: LD_VAR 0 2
40779: PPUSH
40780: LD_EXP 90
40784: PUSH
40785: LD_VAR 0 2
40789: ARRAY
40790: PUSH
40791: LD_VAR 0 3
40795: DIFF
40796: PPUSH
40797: CALL_OW 1
40801: ST_TO_ADDR
// continue ;
40802: GO 40747
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40804: LD_VAR 0 3
40808: PPUSH
40809: CALL_OW 311
40813: NOT
40814: PUSH
40815: LD_VAR 0 3
40819: PUSH
40820: LD_EXP 81
40824: PUSH
40825: LD_VAR 0 2
40829: ARRAY
40830: PUSH
40831: LD_INT 1
40833: ARRAY
40834: IN
40835: NOT
40836: AND
40837: PUSH
40838: LD_VAR 0 3
40842: PUSH
40843: LD_EXP 81
40847: PUSH
40848: LD_VAR 0 2
40852: ARRAY
40853: PUSH
40854: LD_INT 2
40856: ARRAY
40857: IN
40858: NOT
40859: AND
40860: IFFALSE 40923
// begin if IsInUnit ( j ) then
40862: LD_VAR 0 3
40866: PPUSH
40867: CALL_OW 310
40871: IFFALSE 40884
// ComExitBuilding ( j ) else
40873: LD_VAR 0 3
40877: PPUSH
40878: CALL_OW 122
40882: GO 40923
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40884: LD_VAR 0 3
40888: PPUSH
40889: LD_VAR 0 7
40893: PUSH
40894: LD_INT 1
40896: ARRAY
40897: PPUSH
40898: CALL 92629 0 2
40902: NOT
40903: IFFALSE 40923
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40905: LD_VAR 0 3
40909: PPUSH
40910: LD_VAR 0 7
40914: PUSH
40915: LD_INT 1
40917: ARRAY
40918: PPUSH
40919: CALL_OW 129
// end ; end ;
40923: GO 40747
40925: POP
40926: POP
// end ;
40927: GO 40208
40929: POP
40930: POP
// end ;
40931: LD_VAR 0 1
40935: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40936: LD_INT 0
40938: PPUSH
40939: PPUSH
40940: PPUSH
40941: PPUSH
40942: PPUSH
40943: PPUSH
40944: PPUSH
40945: PPUSH
40946: PPUSH
40947: PPUSH
40948: PPUSH
// if not mc_bases then
40949: LD_EXP 78
40953: NOT
40954: IFFALSE 40958
// exit ;
40956: GO 41760
// for i = 1 to mc_bases do
40958: LD_ADDR_VAR 0 2
40962: PUSH
40963: DOUBLE
40964: LD_INT 1
40966: DEC
40967: ST_TO_ADDR
40968: LD_EXP 78
40972: PUSH
40973: FOR_TO
40974: IFFALSE 41758
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40976: LD_EXP 106
40980: PUSH
40981: LD_VAR 0 2
40985: ARRAY
40986: NOT
40987: PUSH
40988: LD_EXP 81
40992: PUSH
40993: LD_VAR 0 2
40997: ARRAY
40998: PUSH
40999: LD_INT 1
41001: ARRAY
41002: OR
41003: PUSH
41004: LD_EXP 81
41008: PUSH
41009: LD_VAR 0 2
41013: ARRAY
41014: PUSH
41015: LD_INT 2
41017: ARRAY
41018: OR
41019: PUSH
41020: LD_EXP 104
41024: PUSH
41025: LD_VAR 0 2
41029: ARRAY
41030: PPUSH
41031: LD_INT 1
41033: PPUSH
41034: CALL_OW 325
41038: NOT
41039: OR
41040: PUSH
41041: LD_EXP 101
41045: PUSH
41046: LD_VAR 0 2
41050: ARRAY
41051: OR
41052: IFFALSE 41056
// continue ;
41054: GO 40973
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41056: LD_ADDR_VAR 0 8
41060: PUSH
41061: LD_EXP 78
41065: PUSH
41066: LD_VAR 0 2
41070: ARRAY
41071: PPUSH
41072: LD_INT 25
41074: PUSH
41075: LD_INT 4
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 50
41084: PUSH
41085: EMPTY
41086: LIST
41087: PUSH
41088: LD_INT 3
41090: PUSH
41091: LD_INT 60
41093: PUSH
41094: EMPTY
41095: LIST
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: LIST
41105: PPUSH
41106: CALL_OW 72
41110: PUSH
41111: LD_EXP 82
41115: PUSH
41116: LD_VAR 0 2
41120: ARRAY
41121: DIFF
41122: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41123: LD_ADDR_VAR 0 9
41127: PUSH
41128: LD_EXP 78
41132: PUSH
41133: LD_VAR 0 2
41137: ARRAY
41138: PPUSH
41139: LD_INT 2
41141: PUSH
41142: LD_INT 30
41144: PUSH
41145: LD_INT 0
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 30
41154: PUSH
41155: LD_INT 1
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: LIST
41166: PPUSH
41167: CALL_OW 72
41171: ST_TO_ADDR
// if not tmp or not dep then
41172: LD_VAR 0 8
41176: NOT
41177: PUSH
41178: LD_VAR 0 9
41182: NOT
41183: OR
41184: IFFALSE 41188
// continue ;
41186: GO 40973
// side := GetSide ( tmp [ 1 ] ) ;
41188: LD_ADDR_VAR 0 11
41192: PUSH
41193: LD_VAR 0 8
41197: PUSH
41198: LD_INT 1
41200: ARRAY
41201: PPUSH
41202: CALL_OW 255
41206: ST_TO_ADDR
// dep := dep [ 1 ] ;
41207: LD_ADDR_VAR 0 9
41211: PUSH
41212: LD_VAR 0 9
41216: PUSH
41217: LD_INT 1
41219: ARRAY
41220: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
41221: LD_ADDR_VAR 0 7
41225: PUSH
41226: LD_EXP 106
41230: PUSH
41231: LD_VAR 0 2
41235: ARRAY
41236: PPUSH
41237: LD_INT 22
41239: PUSH
41240: LD_INT 0
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 25
41249: PUSH
41250: LD_INT 12
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PPUSH
41261: CALL_OW 70
41265: PUSH
41266: LD_INT 22
41268: PUSH
41269: LD_INT 0
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 25
41278: PUSH
41279: LD_INT 12
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 91
41288: PUSH
41289: LD_VAR 0 9
41293: PUSH
41294: LD_INT 20
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL_OW 69
41311: UNION
41312: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
41313: LD_ADDR_VAR 0 10
41317: PUSH
41318: LD_EXP 106
41322: PUSH
41323: LD_VAR 0 2
41327: ARRAY
41328: PPUSH
41329: LD_INT 81
41331: PUSH
41332: LD_VAR 0 11
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PPUSH
41341: CALL_OW 70
41345: ST_TO_ADDR
// if not apes or danger_at_area then
41346: LD_VAR 0 7
41350: NOT
41351: PUSH
41352: LD_VAR 0 10
41356: OR
41357: IFFALSE 41407
// begin if mc_taming [ i ] then
41359: LD_EXP 109
41363: PUSH
41364: LD_VAR 0 2
41368: ARRAY
41369: IFFALSE 41405
// begin MC_Reset ( i , 121 ) ;
41371: LD_VAR 0 2
41375: PPUSH
41376: LD_INT 121
41378: PPUSH
41379: CALL 26323 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41383: LD_ADDR_EXP 109
41387: PUSH
41388: LD_EXP 109
41392: PPUSH
41393: LD_VAR 0 2
41397: PPUSH
41398: EMPTY
41399: PPUSH
41400: CALL_OW 1
41404: ST_TO_ADDR
// end ; continue ;
41405: GO 40973
// end ; for j in tmp do
41407: LD_ADDR_VAR 0 3
41411: PUSH
41412: LD_VAR 0 8
41416: PUSH
41417: FOR_IN
41418: IFFALSE 41754
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
41420: LD_VAR 0 3
41424: PUSH
41425: LD_EXP 109
41429: PUSH
41430: LD_VAR 0 2
41434: ARRAY
41435: IN
41436: NOT
41437: PUSH
41438: LD_EXP 109
41442: PUSH
41443: LD_VAR 0 2
41447: ARRAY
41448: PUSH
41449: LD_INT 3
41451: LESS
41452: AND
41453: IFFALSE 41511
// begin SetTag ( j , 121 ) ;
41455: LD_VAR 0 3
41459: PPUSH
41460: LD_INT 121
41462: PPUSH
41463: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
41467: LD_ADDR_EXP 109
41471: PUSH
41472: LD_EXP 109
41476: PPUSH
41477: LD_VAR 0 2
41481: PUSH
41482: LD_EXP 109
41486: PUSH
41487: LD_VAR 0 2
41491: ARRAY
41492: PUSH
41493: LD_INT 1
41495: PLUS
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PPUSH
41501: LD_VAR 0 3
41505: PPUSH
41506: CALL 57824 0 3
41510: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
41511: LD_VAR 0 3
41515: PUSH
41516: LD_EXP 109
41520: PUSH
41521: LD_VAR 0 2
41525: ARRAY
41526: IN
41527: IFFALSE 41752
// begin if GetClass ( j ) <> 4 then
41529: LD_VAR 0 3
41533: PPUSH
41534: CALL_OW 257
41538: PUSH
41539: LD_INT 4
41541: NONEQUAL
41542: IFFALSE 41595
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
41544: LD_ADDR_EXP 109
41548: PUSH
41549: LD_EXP 109
41553: PPUSH
41554: LD_VAR 0 2
41558: PPUSH
41559: LD_EXP 109
41563: PUSH
41564: LD_VAR 0 2
41568: ARRAY
41569: PUSH
41570: LD_VAR 0 3
41574: DIFF
41575: PPUSH
41576: CALL_OW 1
41580: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41581: LD_VAR 0 3
41585: PPUSH
41586: LD_INT 0
41588: PPUSH
41589: CALL_OW 109
// continue ;
41593: GO 41417
// end ; if IsInUnit ( j ) then
41595: LD_VAR 0 3
41599: PPUSH
41600: CALL_OW 310
41604: IFFALSE 41615
// ComExitBuilding ( j ) ;
41606: LD_VAR 0 3
41610: PPUSH
41611: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
41615: LD_ADDR_VAR 0 6
41619: PUSH
41620: LD_VAR 0 7
41624: PPUSH
41625: LD_VAR 0 3
41629: PPUSH
41630: CALL_OW 74
41634: ST_TO_ADDR
// if not ape then
41635: LD_VAR 0 6
41639: NOT
41640: IFFALSE 41644
// break ;
41642: GO 41754
// x := GetX ( ape ) ;
41644: LD_ADDR_VAR 0 4
41648: PUSH
41649: LD_VAR 0 6
41653: PPUSH
41654: CALL_OW 250
41658: ST_TO_ADDR
// y := GetY ( ape ) ;
41659: LD_ADDR_VAR 0 5
41663: PUSH
41664: LD_VAR 0 6
41668: PPUSH
41669: CALL_OW 251
41673: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
41674: LD_VAR 0 4
41678: PPUSH
41679: LD_VAR 0 5
41683: PPUSH
41684: CALL_OW 488
41688: NOT
41689: PUSH
41690: LD_VAR 0 11
41694: PPUSH
41695: LD_VAR 0 4
41699: PPUSH
41700: LD_VAR 0 5
41704: PPUSH
41705: LD_INT 20
41707: PPUSH
41708: CALL 59088 0 4
41712: PUSH
41713: LD_INT 4
41715: ARRAY
41716: OR
41717: IFFALSE 41721
// break ;
41719: GO 41754
// if not HasTask ( j ) then
41721: LD_VAR 0 3
41725: PPUSH
41726: CALL_OW 314
41730: NOT
41731: IFFALSE 41752
// ComTameXY ( j , x , y ) ;
41733: LD_VAR 0 3
41737: PPUSH
41738: LD_VAR 0 4
41742: PPUSH
41743: LD_VAR 0 5
41747: PPUSH
41748: CALL_OW 131
// end ; end ;
41752: GO 41417
41754: POP
41755: POP
// end ;
41756: GO 40973
41758: POP
41759: POP
// end ;
41760: LD_VAR 0 1
41764: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
41765: LD_INT 0
41767: PPUSH
41768: PPUSH
41769: PPUSH
41770: PPUSH
41771: PPUSH
41772: PPUSH
41773: PPUSH
41774: PPUSH
// if not mc_bases then
41775: LD_EXP 78
41779: NOT
41780: IFFALSE 41784
// exit ;
41782: GO 42410
// for i = 1 to mc_bases do
41784: LD_ADDR_VAR 0 2
41788: PUSH
41789: DOUBLE
41790: LD_INT 1
41792: DEC
41793: ST_TO_ADDR
41794: LD_EXP 78
41798: PUSH
41799: FOR_TO
41800: IFFALSE 42408
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
41802: LD_EXP 107
41806: PUSH
41807: LD_VAR 0 2
41811: ARRAY
41812: NOT
41813: PUSH
41814: LD_EXP 107
41818: PUSH
41819: LD_VAR 0 2
41823: ARRAY
41824: PPUSH
41825: LD_INT 25
41827: PUSH
41828: LD_INT 12
41830: PUSH
41831: EMPTY
41832: LIST
41833: LIST
41834: PPUSH
41835: CALL_OW 72
41839: NOT
41840: OR
41841: IFFALSE 41845
// continue ;
41843: GO 41799
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41845: LD_ADDR_VAR 0 5
41849: PUSH
41850: LD_EXP 107
41854: PUSH
41855: LD_VAR 0 2
41859: ARRAY
41860: PUSH
41861: LD_INT 1
41863: ARRAY
41864: PPUSH
41865: CALL_OW 255
41869: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41870: LD_VAR 0 5
41874: PPUSH
41875: LD_INT 2
41877: PPUSH
41878: CALL_OW 325
41882: IFFALSE 42135
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41884: LD_ADDR_VAR 0 4
41888: PUSH
41889: LD_EXP 107
41893: PUSH
41894: LD_VAR 0 2
41898: ARRAY
41899: PPUSH
41900: LD_INT 25
41902: PUSH
41903: LD_INT 16
41905: PUSH
41906: EMPTY
41907: LIST
41908: LIST
41909: PPUSH
41910: CALL_OW 72
41914: ST_TO_ADDR
// if tmp < 6 then
41915: LD_VAR 0 4
41919: PUSH
41920: LD_INT 6
41922: LESS
41923: IFFALSE 42135
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41925: LD_ADDR_VAR 0 6
41929: PUSH
41930: LD_EXP 78
41934: PUSH
41935: LD_VAR 0 2
41939: ARRAY
41940: PPUSH
41941: LD_INT 2
41943: PUSH
41944: LD_INT 30
41946: PUSH
41947: LD_INT 0
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 30
41956: PUSH
41957: LD_INT 1
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: LIST
41968: PPUSH
41969: CALL_OW 72
41973: ST_TO_ADDR
// if depot then
41974: LD_VAR 0 6
41978: IFFALSE 42135
// begin selected := 0 ;
41980: LD_ADDR_VAR 0 7
41984: PUSH
41985: LD_INT 0
41987: ST_TO_ADDR
// for j in depot do
41988: LD_ADDR_VAR 0 3
41992: PUSH
41993: LD_VAR 0 6
41997: PUSH
41998: FOR_IN
41999: IFFALSE 42030
// begin if UnitsInside ( j ) < 6 then
42001: LD_VAR 0 3
42005: PPUSH
42006: CALL_OW 313
42010: PUSH
42011: LD_INT 6
42013: LESS
42014: IFFALSE 42028
// begin selected := j ;
42016: LD_ADDR_VAR 0 7
42020: PUSH
42021: LD_VAR 0 3
42025: ST_TO_ADDR
// break ;
42026: GO 42030
// end ; end ;
42028: GO 41998
42030: POP
42031: POP
// if selected then
42032: LD_VAR 0 7
42036: IFFALSE 42135
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42038: LD_ADDR_VAR 0 3
42042: PUSH
42043: LD_EXP 107
42047: PUSH
42048: LD_VAR 0 2
42052: ARRAY
42053: PPUSH
42054: LD_INT 25
42056: PUSH
42057: LD_INT 12
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PPUSH
42064: CALL_OW 72
42068: PUSH
42069: FOR_IN
42070: IFFALSE 42133
// if not HasTask ( j ) then
42072: LD_VAR 0 3
42076: PPUSH
42077: CALL_OW 314
42081: NOT
42082: IFFALSE 42131
// begin if not IsInUnit ( j ) then
42084: LD_VAR 0 3
42088: PPUSH
42089: CALL_OW 310
42093: NOT
42094: IFFALSE 42110
// ComEnterUnit ( j , selected ) ;
42096: LD_VAR 0 3
42100: PPUSH
42101: LD_VAR 0 7
42105: PPUSH
42106: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42110: LD_VAR 0 3
42114: PPUSH
42115: LD_INT 16
42117: PPUSH
42118: CALL_OW 183
// AddComExitBuilding ( j ) ;
42122: LD_VAR 0 3
42126: PPUSH
42127: CALL_OW 182
// end ;
42131: GO 42069
42133: POP
42134: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
42135: LD_VAR 0 5
42139: PPUSH
42140: LD_INT 11
42142: PPUSH
42143: CALL_OW 325
42147: IFFALSE 42406
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42149: LD_ADDR_VAR 0 4
42153: PUSH
42154: LD_EXP 107
42158: PUSH
42159: LD_VAR 0 2
42163: ARRAY
42164: PPUSH
42165: LD_INT 25
42167: PUSH
42168: LD_INT 16
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PPUSH
42175: CALL_OW 72
42179: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
42180: LD_VAR 0 4
42184: PUSH
42185: LD_INT 6
42187: GREATEREQUAL
42188: PUSH
42189: LD_VAR 0 5
42193: PPUSH
42194: LD_INT 2
42196: PPUSH
42197: CALL_OW 325
42201: NOT
42202: OR
42203: IFFALSE 42406
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42205: LD_ADDR_VAR 0 8
42209: PUSH
42210: LD_EXP 78
42214: PUSH
42215: LD_VAR 0 2
42219: ARRAY
42220: PPUSH
42221: LD_INT 2
42223: PUSH
42224: LD_INT 30
42226: PUSH
42227: LD_INT 4
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: PUSH
42234: LD_INT 30
42236: PUSH
42237: LD_INT 5
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: LIST
42248: PPUSH
42249: CALL_OW 72
42253: ST_TO_ADDR
// if barracks then
42254: LD_VAR 0 8
42258: IFFALSE 42406
// begin selected := 0 ;
42260: LD_ADDR_VAR 0 7
42264: PUSH
42265: LD_INT 0
42267: ST_TO_ADDR
// for j in barracks do
42268: LD_ADDR_VAR 0 3
42272: PUSH
42273: LD_VAR 0 8
42277: PUSH
42278: FOR_IN
42279: IFFALSE 42310
// begin if UnitsInside ( j ) < 6 then
42281: LD_VAR 0 3
42285: PPUSH
42286: CALL_OW 313
42290: PUSH
42291: LD_INT 6
42293: LESS
42294: IFFALSE 42308
// begin selected := j ;
42296: LD_ADDR_VAR 0 7
42300: PUSH
42301: LD_VAR 0 3
42305: ST_TO_ADDR
// break ;
42306: GO 42310
// end ; end ;
42308: GO 42278
42310: POP
42311: POP
// if selected then
42312: LD_VAR 0 7
42316: IFFALSE 42406
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42318: LD_ADDR_VAR 0 3
42322: PUSH
42323: LD_EXP 107
42327: PUSH
42328: LD_VAR 0 2
42332: ARRAY
42333: PPUSH
42334: LD_INT 25
42336: PUSH
42337: LD_INT 12
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: PPUSH
42344: CALL_OW 72
42348: PUSH
42349: FOR_IN
42350: IFFALSE 42404
// if not IsInUnit ( j ) and not HasTask ( j ) then
42352: LD_VAR 0 3
42356: PPUSH
42357: CALL_OW 310
42361: NOT
42362: PUSH
42363: LD_VAR 0 3
42367: PPUSH
42368: CALL_OW 314
42372: NOT
42373: AND
42374: IFFALSE 42402
// begin ComEnterUnit ( j , selected ) ;
42376: LD_VAR 0 3
42380: PPUSH
42381: LD_VAR 0 7
42385: PPUSH
42386: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
42390: LD_VAR 0 3
42394: PPUSH
42395: LD_INT 15
42397: PPUSH
42398: CALL_OW 183
// end ;
42402: GO 42349
42404: POP
42405: POP
// end ; end ; end ; end ; end ;
42406: GO 41799
42408: POP
42409: POP
// end ;
42410: LD_VAR 0 1
42414: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
42415: LD_INT 0
42417: PPUSH
42418: PPUSH
42419: PPUSH
42420: PPUSH
// if not mc_bases then
42421: LD_EXP 78
42425: NOT
42426: IFFALSE 42430
// exit ;
42428: GO 42608
// for i = 1 to mc_bases do
42430: LD_ADDR_VAR 0 2
42434: PUSH
42435: DOUBLE
42436: LD_INT 1
42438: DEC
42439: ST_TO_ADDR
42440: LD_EXP 78
42444: PUSH
42445: FOR_TO
42446: IFFALSE 42606
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
42448: LD_ADDR_VAR 0 4
42452: PUSH
42453: LD_EXP 78
42457: PUSH
42458: LD_VAR 0 2
42462: ARRAY
42463: PPUSH
42464: LD_INT 25
42466: PUSH
42467: LD_INT 9
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PPUSH
42474: CALL_OW 72
42478: ST_TO_ADDR
// if not tmp then
42479: LD_VAR 0 4
42483: NOT
42484: IFFALSE 42488
// continue ;
42486: GO 42445
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
42488: LD_EXP 104
42492: PUSH
42493: LD_VAR 0 2
42497: ARRAY
42498: PPUSH
42499: LD_INT 29
42501: PPUSH
42502: CALL_OW 325
42506: NOT
42507: PUSH
42508: LD_EXP 104
42512: PUSH
42513: LD_VAR 0 2
42517: ARRAY
42518: PPUSH
42519: LD_INT 28
42521: PPUSH
42522: CALL_OW 325
42526: NOT
42527: AND
42528: IFFALSE 42532
// continue ;
42530: GO 42445
// for j in tmp do
42532: LD_ADDR_VAR 0 3
42536: PUSH
42537: LD_VAR 0 4
42541: PUSH
42542: FOR_IN
42543: IFFALSE 42602
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
42545: LD_VAR 0 3
42549: PUSH
42550: LD_EXP 81
42554: PUSH
42555: LD_VAR 0 2
42559: ARRAY
42560: PUSH
42561: LD_INT 1
42563: ARRAY
42564: IN
42565: NOT
42566: PUSH
42567: LD_VAR 0 3
42571: PUSH
42572: LD_EXP 81
42576: PUSH
42577: LD_VAR 0 2
42581: ARRAY
42582: PUSH
42583: LD_INT 2
42585: ARRAY
42586: IN
42587: NOT
42588: AND
42589: IFFALSE 42600
// ComSpaceTimeShoot ( j ) ;
42591: LD_VAR 0 3
42595: PPUSH
42596: CALL 53809 0 1
42600: GO 42542
42602: POP
42603: POP
// end ;
42604: GO 42445
42606: POP
42607: POP
// end ;
42608: LD_VAR 0 1
42612: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
42613: LD_INT 0
42615: PPUSH
42616: PPUSH
42617: PPUSH
42618: PPUSH
42619: PPUSH
42620: PPUSH
42621: PPUSH
42622: PPUSH
42623: PPUSH
// if not mc_bases then
42624: LD_EXP 78
42628: NOT
42629: IFFALSE 42633
// exit ;
42631: GO 43255
// for i = 1 to mc_bases do
42633: LD_ADDR_VAR 0 2
42637: PUSH
42638: DOUBLE
42639: LD_INT 1
42641: DEC
42642: ST_TO_ADDR
42643: LD_EXP 78
42647: PUSH
42648: FOR_TO
42649: IFFALSE 43253
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
42651: LD_EXP 113
42655: PUSH
42656: LD_VAR 0 2
42660: ARRAY
42661: NOT
42662: PUSH
42663: LD_INT 38
42665: PPUSH
42666: LD_EXP 104
42670: PUSH
42671: LD_VAR 0 2
42675: ARRAY
42676: PPUSH
42677: CALL_OW 321
42681: PUSH
42682: LD_INT 2
42684: NONEQUAL
42685: OR
42686: IFFALSE 42690
// continue ;
42688: GO 42648
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
42690: LD_ADDR_VAR 0 8
42694: PUSH
42695: LD_EXP 78
42699: PUSH
42700: LD_VAR 0 2
42704: ARRAY
42705: PPUSH
42706: LD_INT 30
42708: PUSH
42709: LD_INT 34
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PPUSH
42716: CALL_OW 72
42720: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
42721: LD_ADDR_VAR 0 9
42725: PUSH
42726: LD_EXP 78
42730: PUSH
42731: LD_VAR 0 2
42735: ARRAY
42736: PPUSH
42737: LD_INT 25
42739: PUSH
42740: LD_INT 4
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PPUSH
42747: CALL_OW 72
42751: PPUSH
42752: LD_INT 0
42754: PPUSH
42755: CALL 88133 0 2
42759: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
42760: LD_VAR 0 9
42764: NOT
42765: PUSH
42766: LD_VAR 0 8
42770: NOT
42771: OR
42772: PUSH
42773: LD_EXP 78
42777: PUSH
42778: LD_VAR 0 2
42782: ARRAY
42783: PPUSH
42784: LD_INT 124
42786: PPUSH
42787: CALL 88133 0 2
42791: OR
42792: IFFALSE 42796
// continue ;
42794: GO 42648
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
42796: LD_EXP 114
42800: PUSH
42801: LD_VAR 0 2
42805: ARRAY
42806: PUSH
42807: LD_EXP 113
42811: PUSH
42812: LD_VAR 0 2
42816: ARRAY
42817: LESS
42818: PUSH
42819: LD_EXP 114
42823: PUSH
42824: LD_VAR 0 2
42828: ARRAY
42829: PUSH
42830: LD_VAR 0 8
42834: LESS
42835: AND
42836: IFFALSE 43251
// begin tmp := sci [ 1 ] ;
42838: LD_ADDR_VAR 0 7
42842: PUSH
42843: LD_VAR 0 9
42847: PUSH
42848: LD_INT 1
42850: ARRAY
42851: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42852: LD_VAR 0 7
42856: PPUSH
42857: LD_INT 124
42859: PPUSH
42860: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42864: LD_ADDR_VAR 0 3
42868: PUSH
42869: DOUBLE
42870: LD_EXP 113
42874: PUSH
42875: LD_VAR 0 2
42879: ARRAY
42880: INC
42881: ST_TO_ADDR
42882: LD_EXP 113
42886: PUSH
42887: LD_VAR 0 2
42891: ARRAY
42892: PUSH
42893: FOR_DOWNTO
42894: IFFALSE 43237
// begin if IsInUnit ( tmp ) then
42896: LD_VAR 0 7
42900: PPUSH
42901: CALL_OW 310
42905: IFFALSE 42916
// ComExitBuilding ( tmp ) ;
42907: LD_VAR 0 7
42911: PPUSH
42912: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42916: LD_INT 35
42918: PPUSH
42919: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42923: LD_VAR 0 7
42927: PPUSH
42928: CALL_OW 310
42932: NOT
42933: PUSH
42934: LD_VAR 0 7
42938: PPUSH
42939: CALL_OW 314
42943: NOT
42944: AND
42945: IFFALSE 42916
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42947: LD_ADDR_VAR 0 6
42951: PUSH
42952: LD_VAR 0 7
42956: PPUSH
42957: CALL_OW 250
42961: PUSH
42962: LD_VAR 0 7
42966: PPUSH
42967: CALL_OW 251
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42976: LD_INT 35
42978: PPUSH
42979: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42983: LD_ADDR_VAR 0 4
42987: PUSH
42988: LD_EXP 113
42992: PUSH
42993: LD_VAR 0 2
42997: ARRAY
42998: PUSH
42999: LD_VAR 0 3
43003: ARRAY
43004: PUSH
43005: LD_INT 1
43007: ARRAY
43008: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
43009: LD_ADDR_VAR 0 5
43013: PUSH
43014: LD_EXP 113
43018: PUSH
43019: LD_VAR 0 2
43023: ARRAY
43024: PUSH
43025: LD_VAR 0 3
43029: ARRAY
43030: PUSH
43031: LD_INT 2
43033: ARRAY
43034: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
43035: LD_VAR 0 7
43039: PPUSH
43040: LD_INT 10
43042: PPUSH
43043: CALL 60789 0 2
43047: PUSH
43048: LD_INT 4
43050: ARRAY
43051: IFFALSE 43089
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43053: LD_VAR 0 7
43057: PPUSH
43058: LD_VAR 0 6
43062: PUSH
43063: LD_INT 1
43065: ARRAY
43066: PPUSH
43067: LD_VAR 0 6
43071: PUSH
43072: LD_INT 2
43074: ARRAY
43075: PPUSH
43076: CALL_OW 111
// wait ( 0 0$10 ) ;
43080: LD_INT 350
43082: PPUSH
43083: CALL_OW 67
// end else
43087: GO 43115
// begin ComMoveXY ( tmp , x , y ) ;
43089: LD_VAR 0 7
43093: PPUSH
43094: LD_VAR 0 4
43098: PPUSH
43099: LD_VAR 0 5
43103: PPUSH
43104: CALL_OW 111
// wait ( 0 0$3 ) ;
43108: LD_INT 105
43110: PPUSH
43111: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43115: LD_VAR 0 7
43119: PPUSH
43120: LD_VAR 0 4
43124: PPUSH
43125: LD_VAR 0 5
43129: PPUSH
43130: CALL_OW 307
43134: IFFALSE 42976
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
43136: LD_VAR 0 7
43140: PPUSH
43141: LD_VAR 0 4
43145: PPUSH
43146: LD_VAR 0 5
43150: PPUSH
43151: LD_VAR 0 8
43155: PUSH
43156: LD_VAR 0 3
43160: ARRAY
43161: PPUSH
43162: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
43166: LD_INT 35
43168: PPUSH
43169: CALL_OW 67
// until not HasTask ( tmp ) ;
43173: LD_VAR 0 7
43177: PPUSH
43178: CALL_OW 314
43182: NOT
43183: IFFALSE 43166
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
43185: LD_ADDR_EXP 114
43189: PUSH
43190: LD_EXP 114
43194: PPUSH
43195: LD_VAR 0 2
43199: PUSH
43200: LD_EXP 114
43204: PUSH
43205: LD_VAR 0 2
43209: ARRAY
43210: PUSH
43211: LD_INT 1
43213: PLUS
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PPUSH
43219: LD_VAR 0 8
43223: PUSH
43224: LD_VAR 0 3
43228: ARRAY
43229: PPUSH
43230: CALL 57824 0 3
43234: ST_TO_ADDR
// end ;
43235: GO 42893
43237: POP
43238: POP
// MC_Reset ( i , 124 ) ;
43239: LD_VAR 0 2
43243: PPUSH
43244: LD_INT 124
43246: PPUSH
43247: CALL 26323 0 2
// end ; end ;
43251: GO 42648
43253: POP
43254: POP
// end ;
43255: LD_VAR 0 1
43259: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
43260: LD_INT 0
43262: PPUSH
43263: PPUSH
43264: PPUSH
// if not mc_bases then
43265: LD_EXP 78
43269: NOT
43270: IFFALSE 43274
// exit ;
43272: GO 43880
// for i = 1 to mc_bases do
43274: LD_ADDR_VAR 0 2
43278: PUSH
43279: DOUBLE
43280: LD_INT 1
43282: DEC
43283: ST_TO_ADDR
43284: LD_EXP 78
43288: PUSH
43289: FOR_TO
43290: IFFALSE 43878
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43292: LD_ADDR_VAR 0 3
43296: PUSH
43297: LD_EXP 78
43301: PUSH
43302: LD_VAR 0 2
43306: ARRAY
43307: PPUSH
43308: LD_INT 25
43310: PUSH
43311: LD_INT 4
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PPUSH
43318: CALL_OW 72
43322: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43323: LD_VAR 0 3
43327: NOT
43328: PUSH
43329: LD_EXP 115
43333: PUSH
43334: LD_VAR 0 2
43338: ARRAY
43339: NOT
43340: OR
43341: PUSH
43342: LD_EXP 78
43346: PUSH
43347: LD_VAR 0 2
43351: ARRAY
43352: PPUSH
43353: LD_INT 2
43355: PUSH
43356: LD_INT 30
43358: PUSH
43359: LD_INT 0
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 30
43368: PUSH
43369: LD_INT 1
43371: PUSH
43372: EMPTY
43373: LIST
43374: LIST
43375: PUSH
43376: EMPTY
43377: LIST
43378: LIST
43379: LIST
43380: PPUSH
43381: CALL_OW 72
43385: NOT
43386: OR
43387: IFFALSE 43437
// begin if mc_deposits_finder [ i ] then
43389: LD_EXP 116
43393: PUSH
43394: LD_VAR 0 2
43398: ARRAY
43399: IFFALSE 43435
// begin MC_Reset ( i , 125 ) ;
43401: LD_VAR 0 2
43405: PPUSH
43406: LD_INT 125
43408: PPUSH
43409: CALL 26323 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43413: LD_ADDR_EXP 116
43417: PUSH
43418: LD_EXP 116
43422: PPUSH
43423: LD_VAR 0 2
43427: PPUSH
43428: EMPTY
43429: PPUSH
43430: CALL_OW 1
43434: ST_TO_ADDR
// end ; continue ;
43435: GO 43289
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
43437: LD_EXP 115
43441: PUSH
43442: LD_VAR 0 2
43446: ARRAY
43447: PUSH
43448: LD_INT 1
43450: ARRAY
43451: PUSH
43452: LD_INT 3
43454: ARRAY
43455: PUSH
43456: LD_INT 1
43458: EQUAL
43459: PUSH
43460: LD_INT 20
43462: PPUSH
43463: LD_EXP 104
43467: PUSH
43468: LD_VAR 0 2
43472: ARRAY
43473: PPUSH
43474: CALL_OW 321
43478: PUSH
43479: LD_INT 2
43481: NONEQUAL
43482: AND
43483: IFFALSE 43533
// begin if mc_deposits_finder [ i ] then
43485: LD_EXP 116
43489: PUSH
43490: LD_VAR 0 2
43494: ARRAY
43495: IFFALSE 43531
// begin MC_Reset ( i , 125 ) ;
43497: LD_VAR 0 2
43501: PPUSH
43502: LD_INT 125
43504: PPUSH
43505: CALL 26323 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43509: LD_ADDR_EXP 116
43513: PUSH
43514: LD_EXP 116
43518: PPUSH
43519: LD_VAR 0 2
43523: PPUSH
43524: EMPTY
43525: PPUSH
43526: CALL_OW 1
43530: ST_TO_ADDR
// end ; continue ;
43531: GO 43289
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
43533: LD_EXP 115
43537: PUSH
43538: LD_VAR 0 2
43542: ARRAY
43543: PUSH
43544: LD_INT 1
43546: ARRAY
43547: PUSH
43548: LD_INT 1
43550: ARRAY
43551: PPUSH
43552: LD_EXP 115
43556: PUSH
43557: LD_VAR 0 2
43561: ARRAY
43562: PUSH
43563: LD_INT 1
43565: ARRAY
43566: PUSH
43567: LD_INT 2
43569: ARRAY
43570: PPUSH
43571: LD_EXP 104
43575: PUSH
43576: LD_VAR 0 2
43580: ARRAY
43581: PPUSH
43582: CALL_OW 440
43586: IFFALSE 43629
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
43588: LD_ADDR_EXP 115
43592: PUSH
43593: LD_EXP 115
43597: PPUSH
43598: LD_VAR 0 2
43602: PPUSH
43603: LD_EXP 115
43607: PUSH
43608: LD_VAR 0 2
43612: ARRAY
43613: PPUSH
43614: LD_INT 1
43616: PPUSH
43617: CALL_OW 3
43621: PPUSH
43622: CALL_OW 1
43626: ST_TO_ADDR
43627: GO 43876
// begin if not mc_deposits_finder [ i ] then
43629: LD_EXP 116
43633: PUSH
43634: LD_VAR 0 2
43638: ARRAY
43639: NOT
43640: IFFALSE 43692
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
43642: LD_ADDR_EXP 116
43646: PUSH
43647: LD_EXP 116
43651: PPUSH
43652: LD_VAR 0 2
43656: PPUSH
43657: LD_VAR 0 3
43661: PUSH
43662: LD_INT 1
43664: ARRAY
43665: PUSH
43666: EMPTY
43667: LIST
43668: PPUSH
43669: CALL_OW 1
43673: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
43674: LD_VAR 0 3
43678: PUSH
43679: LD_INT 1
43681: ARRAY
43682: PPUSH
43683: LD_INT 125
43685: PPUSH
43686: CALL_OW 109
// end else
43690: GO 43876
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
43692: LD_EXP 116
43696: PUSH
43697: LD_VAR 0 2
43701: ARRAY
43702: PUSH
43703: LD_INT 1
43705: ARRAY
43706: PPUSH
43707: CALL_OW 310
43711: IFFALSE 43734
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
43713: LD_EXP 116
43717: PUSH
43718: LD_VAR 0 2
43722: ARRAY
43723: PUSH
43724: LD_INT 1
43726: ARRAY
43727: PPUSH
43728: CALL_OW 122
43732: GO 43876
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
43734: LD_EXP 116
43738: PUSH
43739: LD_VAR 0 2
43743: ARRAY
43744: PUSH
43745: LD_INT 1
43747: ARRAY
43748: PPUSH
43749: CALL_OW 314
43753: NOT
43754: PUSH
43755: LD_EXP 116
43759: PUSH
43760: LD_VAR 0 2
43764: ARRAY
43765: PUSH
43766: LD_INT 1
43768: ARRAY
43769: PPUSH
43770: LD_EXP 115
43774: PUSH
43775: LD_VAR 0 2
43779: ARRAY
43780: PUSH
43781: LD_INT 1
43783: ARRAY
43784: PUSH
43785: LD_INT 1
43787: ARRAY
43788: PPUSH
43789: LD_EXP 115
43793: PUSH
43794: LD_VAR 0 2
43798: ARRAY
43799: PUSH
43800: LD_INT 1
43802: ARRAY
43803: PUSH
43804: LD_INT 2
43806: ARRAY
43807: PPUSH
43808: CALL_OW 297
43812: PUSH
43813: LD_INT 6
43815: GREATER
43816: AND
43817: IFFALSE 43876
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
43819: LD_EXP 116
43823: PUSH
43824: LD_VAR 0 2
43828: ARRAY
43829: PUSH
43830: LD_INT 1
43832: ARRAY
43833: PPUSH
43834: LD_EXP 115
43838: PUSH
43839: LD_VAR 0 2
43843: ARRAY
43844: PUSH
43845: LD_INT 1
43847: ARRAY
43848: PUSH
43849: LD_INT 1
43851: ARRAY
43852: PPUSH
43853: LD_EXP 115
43857: PUSH
43858: LD_VAR 0 2
43862: ARRAY
43863: PUSH
43864: LD_INT 1
43866: ARRAY
43867: PUSH
43868: LD_INT 2
43870: ARRAY
43871: PPUSH
43872: CALL_OW 111
// end ; end ; end ;
43876: GO 43289
43878: POP
43879: POP
// end ;
43880: LD_VAR 0 1
43884: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43885: LD_INT 0
43887: PPUSH
43888: PPUSH
43889: PPUSH
43890: PPUSH
43891: PPUSH
43892: PPUSH
43893: PPUSH
43894: PPUSH
43895: PPUSH
43896: PPUSH
43897: PPUSH
// if not mc_bases then
43898: LD_EXP 78
43902: NOT
43903: IFFALSE 43907
// exit ;
43905: GO 44847
// for i = 1 to mc_bases do
43907: LD_ADDR_VAR 0 2
43911: PUSH
43912: DOUBLE
43913: LD_INT 1
43915: DEC
43916: ST_TO_ADDR
43917: LD_EXP 78
43921: PUSH
43922: FOR_TO
43923: IFFALSE 44845
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43925: LD_EXP 78
43929: PUSH
43930: LD_VAR 0 2
43934: ARRAY
43935: NOT
43936: PUSH
43937: LD_EXP 101
43941: PUSH
43942: LD_VAR 0 2
43946: ARRAY
43947: OR
43948: IFFALSE 43952
// continue ;
43950: GO 43922
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43952: LD_ADDR_VAR 0 7
43956: PUSH
43957: LD_EXP 78
43961: PUSH
43962: LD_VAR 0 2
43966: ARRAY
43967: PUSH
43968: LD_INT 1
43970: ARRAY
43971: PPUSH
43972: CALL_OW 248
43976: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43977: LD_VAR 0 7
43981: PUSH
43982: LD_INT 3
43984: EQUAL
43985: PUSH
43986: LD_EXP 97
43990: PUSH
43991: LD_VAR 0 2
43995: ARRAY
43996: PUSH
43997: LD_EXP 100
44001: PUSH
44002: LD_VAR 0 2
44006: ARRAY
44007: UNION
44008: PPUSH
44009: LD_INT 33
44011: PUSH
44012: LD_INT 2
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PPUSH
44019: CALL_OW 72
44023: NOT
44024: OR
44025: IFFALSE 44029
// continue ;
44027: GO 43922
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
44029: LD_ADDR_VAR 0 9
44033: PUSH
44034: LD_EXP 78
44038: PUSH
44039: LD_VAR 0 2
44043: ARRAY
44044: PPUSH
44045: LD_INT 30
44047: PUSH
44048: LD_INT 36
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: PPUSH
44055: CALL_OW 72
44059: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44060: LD_ADDR_VAR 0 10
44064: PUSH
44065: LD_EXP 97
44069: PUSH
44070: LD_VAR 0 2
44074: ARRAY
44075: PPUSH
44076: LD_INT 34
44078: PUSH
44079: LD_INT 31
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PPUSH
44086: CALL_OW 72
44090: ST_TO_ADDR
// if not cts and not mcts then
44091: LD_VAR 0 9
44095: NOT
44096: PUSH
44097: LD_VAR 0 10
44101: NOT
44102: AND
44103: IFFALSE 44107
// continue ;
44105: GO 43922
// x := cts ;
44107: LD_ADDR_VAR 0 11
44111: PUSH
44112: LD_VAR 0 9
44116: ST_TO_ADDR
// if not x then
44117: LD_VAR 0 11
44121: NOT
44122: IFFALSE 44134
// x := mcts ;
44124: LD_ADDR_VAR 0 11
44128: PUSH
44129: LD_VAR 0 10
44133: ST_TO_ADDR
// if not x then
44134: LD_VAR 0 11
44138: NOT
44139: IFFALSE 44143
// continue ;
44141: GO 43922
// if mc_remote_driver [ i ] then
44143: LD_EXP 118
44147: PUSH
44148: LD_VAR 0 2
44152: ARRAY
44153: IFFALSE 44540
// for j in mc_remote_driver [ i ] do
44155: LD_ADDR_VAR 0 3
44159: PUSH
44160: LD_EXP 118
44164: PUSH
44165: LD_VAR 0 2
44169: ARRAY
44170: PUSH
44171: FOR_IN
44172: IFFALSE 44538
// begin if GetClass ( j ) <> 3 then
44174: LD_VAR 0 3
44178: PPUSH
44179: CALL_OW 257
44183: PUSH
44184: LD_INT 3
44186: NONEQUAL
44187: IFFALSE 44240
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
44189: LD_ADDR_EXP 118
44193: PUSH
44194: LD_EXP 118
44198: PPUSH
44199: LD_VAR 0 2
44203: PPUSH
44204: LD_EXP 118
44208: PUSH
44209: LD_VAR 0 2
44213: ARRAY
44214: PUSH
44215: LD_VAR 0 3
44219: DIFF
44220: PPUSH
44221: CALL_OW 1
44225: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44226: LD_VAR 0 3
44230: PPUSH
44231: LD_INT 0
44233: PPUSH
44234: CALL_OW 109
// continue ;
44238: GO 44171
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
44240: LD_EXP 97
44244: PUSH
44245: LD_VAR 0 2
44249: ARRAY
44250: PPUSH
44251: LD_INT 34
44253: PUSH
44254: LD_INT 31
44256: PUSH
44257: EMPTY
44258: LIST
44259: LIST
44260: PUSH
44261: LD_INT 58
44263: PUSH
44264: EMPTY
44265: LIST
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PPUSH
44271: CALL_OW 72
44275: PUSH
44276: LD_VAR 0 3
44280: PPUSH
44281: CALL 88168 0 1
44285: NOT
44286: AND
44287: IFFALSE 44358
// begin if IsInUnit ( j ) then
44289: LD_VAR 0 3
44293: PPUSH
44294: CALL_OW 310
44298: IFFALSE 44309
// ComExitBuilding ( j ) ;
44300: LD_VAR 0 3
44304: PPUSH
44305: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
44309: LD_VAR 0 3
44313: PPUSH
44314: LD_EXP 97
44318: PUSH
44319: LD_VAR 0 2
44323: ARRAY
44324: PPUSH
44325: LD_INT 34
44327: PUSH
44328: LD_INT 31
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: LD_INT 58
44337: PUSH
44338: EMPTY
44339: LIST
44340: PUSH
44341: EMPTY
44342: LIST
44343: LIST
44344: PPUSH
44345: CALL_OW 72
44349: PUSH
44350: LD_INT 1
44352: ARRAY
44353: PPUSH
44354: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
44358: LD_VAR 0 3
44362: PPUSH
44363: CALL_OW 310
44367: NOT
44368: PUSH
44369: LD_VAR 0 3
44373: PPUSH
44374: CALL_OW 310
44378: PPUSH
44379: CALL_OW 266
44383: PUSH
44384: LD_INT 36
44386: NONEQUAL
44387: PUSH
44388: LD_VAR 0 3
44392: PPUSH
44393: CALL 88168 0 1
44397: NOT
44398: AND
44399: OR
44400: IFFALSE 44536
// begin if IsInUnit ( j ) then
44402: LD_VAR 0 3
44406: PPUSH
44407: CALL_OW 310
44411: IFFALSE 44422
// ComExitBuilding ( j ) ;
44413: LD_VAR 0 3
44417: PPUSH
44418: CALL_OW 122
// ct := 0 ;
44422: LD_ADDR_VAR 0 8
44426: PUSH
44427: LD_INT 0
44429: ST_TO_ADDR
// for k in x do
44430: LD_ADDR_VAR 0 4
44434: PUSH
44435: LD_VAR 0 11
44439: PUSH
44440: FOR_IN
44441: IFFALSE 44514
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
44443: LD_VAR 0 4
44447: PPUSH
44448: CALL_OW 264
44452: PUSH
44453: LD_INT 31
44455: EQUAL
44456: PUSH
44457: LD_VAR 0 4
44461: PPUSH
44462: CALL_OW 311
44466: NOT
44467: AND
44468: PUSH
44469: LD_VAR 0 4
44473: PPUSH
44474: CALL_OW 266
44478: PUSH
44479: LD_INT 36
44481: EQUAL
44482: PUSH
44483: LD_VAR 0 4
44487: PPUSH
44488: CALL_OW 313
44492: PUSH
44493: LD_INT 3
44495: LESS
44496: AND
44497: OR
44498: IFFALSE 44512
// begin ct := k ;
44500: LD_ADDR_VAR 0 8
44504: PUSH
44505: LD_VAR 0 4
44509: ST_TO_ADDR
// break ;
44510: GO 44514
// end ;
44512: GO 44440
44514: POP
44515: POP
// if ct then
44516: LD_VAR 0 8
44520: IFFALSE 44536
// ComEnterUnit ( j , ct ) ;
44522: LD_VAR 0 3
44526: PPUSH
44527: LD_VAR 0 8
44531: PPUSH
44532: CALL_OW 120
// end ; end ;
44536: GO 44171
44538: POP
44539: POP
// places := 0 ;
44540: LD_ADDR_VAR 0 5
44544: PUSH
44545: LD_INT 0
44547: ST_TO_ADDR
// for j = 1 to x do
44548: LD_ADDR_VAR 0 3
44552: PUSH
44553: DOUBLE
44554: LD_INT 1
44556: DEC
44557: ST_TO_ADDR
44558: LD_VAR 0 11
44562: PUSH
44563: FOR_TO
44564: IFFALSE 44640
// if GetWeapon ( x [ j ] ) = ar_control_tower then
44566: LD_VAR 0 11
44570: PUSH
44571: LD_VAR 0 3
44575: ARRAY
44576: PPUSH
44577: CALL_OW 264
44581: PUSH
44582: LD_INT 31
44584: EQUAL
44585: IFFALSE 44603
// places := places + 1 else
44587: LD_ADDR_VAR 0 5
44591: PUSH
44592: LD_VAR 0 5
44596: PUSH
44597: LD_INT 1
44599: PLUS
44600: ST_TO_ADDR
44601: GO 44638
// if GetBType ( x [ j ] ) = b_control_tower then
44603: LD_VAR 0 11
44607: PUSH
44608: LD_VAR 0 3
44612: ARRAY
44613: PPUSH
44614: CALL_OW 266
44618: PUSH
44619: LD_INT 36
44621: EQUAL
44622: IFFALSE 44638
// places := places + 3 ;
44624: LD_ADDR_VAR 0 5
44628: PUSH
44629: LD_VAR 0 5
44633: PUSH
44634: LD_INT 3
44636: PLUS
44637: ST_TO_ADDR
44638: GO 44563
44640: POP
44641: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
44642: LD_VAR 0 5
44646: PUSH
44647: LD_INT 0
44649: EQUAL
44650: PUSH
44651: LD_VAR 0 5
44655: PUSH
44656: LD_EXP 118
44660: PUSH
44661: LD_VAR 0 2
44665: ARRAY
44666: LESSEQUAL
44667: OR
44668: IFFALSE 44672
// continue ;
44670: GO 43922
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
44672: LD_ADDR_VAR 0 6
44676: PUSH
44677: LD_EXP 78
44681: PUSH
44682: LD_VAR 0 2
44686: ARRAY
44687: PPUSH
44688: LD_INT 25
44690: PUSH
44691: LD_INT 3
44693: PUSH
44694: EMPTY
44695: LIST
44696: LIST
44697: PPUSH
44698: CALL_OW 72
44702: PUSH
44703: LD_EXP 118
44707: PUSH
44708: LD_VAR 0 2
44712: ARRAY
44713: DIFF
44714: PPUSH
44715: LD_INT 3
44717: PPUSH
44718: CALL 89068 0 2
44722: ST_TO_ADDR
// for j in tmp do
44723: LD_ADDR_VAR 0 3
44727: PUSH
44728: LD_VAR 0 6
44732: PUSH
44733: FOR_IN
44734: IFFALSE 44769
// if GetTag ( j ) > 0 then
44736: LD_VAR 0 3
44740: PPUSH
44741: CALL_OW 110
44745: PUSH
44746: LD_INT 0
44748: GREATER
44749: IFFALSE 44767
// tmp := tmp diff j ;
44751: LD_ADDR_VAR 0 6
44755: PUSH
44756: LD_VAR 0 6
44760: PUSH
44761: LD_VAR 0 3
44765: DIFF
44766: ST_TO_ADDR
44767: GO 44733
44769: POP
44770: POP
// if not tmp then
44771: LD_VAR 0 6
44775: NOT
44776: IFFALSE 44780
// continue ;
44778: GO 43922
// if places then
44780: LD_VAR 0 5
44784: IFFALSE 44843
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
44786: LD_ADDR_EXP 118
44790: PUSH
44791: LD_EXP 118
44795: PPUSH
44796: LD_VAR 0 2
44800: PPUSH
44801: LD_EXP 118
44805: PUSH
44806: LD_VAR 0 2
44810: ARRAY
44811: PUSH
44812: LD_VAR 0 6
44816: PUSH
44817: LD_INT 1
44819: ARRAY
44820: UNION
44821: PPUSH
44822: CALL_OW 1
44826: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
44827: LD_VAR 0 6
44831: PUSH
44832: LD_INT 1
44834: ARRAY
44835: PPUSH
44836: LD_INT 126
44838: PPUSH
44839: CALL_OW 109
// end ; end ;
44843: GO 43922
44845: POP
44846: POP
// end ;
44847: LD_VAR 0 1
44851: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44852: LD_INT 0
44854: PPUSH
44855: PPUSH
44856: PPUSH
44857: PPUSH
44858: PPUSH
44859: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44860: LD_VAR 0 1
44864: NOT
44865: PUSH
44866: LD_VAR 0 2
44870: NOT
44871: OR
44872: PUSH
44873: LD_VAR 0 3
44877: NOT
44878: OR
44879: PUSH
44880: LD_VAR 0 4
44884: PUSH
44885: LD_INT 1
44887: PUSH
44888: LD_INT 2
44890: PUSH
44891: LD_INT 3
44893: PUSH
44894: LD_INT 4
44896: PUSH
44897: LD_INT 5
44899: PUSH
44900: LD_INT 8
44902: PUSH
44903: LD_INT 9
44905: PUSH
44906: LD_INT 15
44908: PUSH
44909: LD_INT 16
44911: PUSH
44912: EMPTY
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: IN
44923: NOT
44924: OR
44925: IFFALSE 44929
// exit ;
44927: GO 45787
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44929: LD_ADDR_VAR 0 2
44933: PUSH
44934: LD_VAR 0 2
44938: PPUSH
44939: LD_INT 21
44941: PUSH
44942: LD_INT 3
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PUSH
44949: LD_INT 24
44951: PUSH
44952: LD_INT 250
44954: PUSH
44955: EMPTY
44956: LIST
44957: LIST
44958: PUSH
44959: EMPTY
44960: LIST
44961: LIST
44962: PPUSH
44963: CALL_OW 72
44967: ST_TO_ADDR
// case class of 1 , 15 :
44968: LD_VAR 0 4
44972: PUSH
44973: LD_INT 1
44975: DOUBLE
44976: EQUAL
44977: IFTRUE 44987
44979: LD_INT 15
44981: DOUBLE
44982: EQUAL
44983: IFTRUE 44987
44985: GO 45072
44987: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44988: LD_ADDR_VAR 0 8
44992: PUSH
44993: LD_VAR 0 2
44997: PPUSH
44998: LD_INT 2
45000: PUSH
45001: LD_INT 30
45003: PUSH
45004: LD_INT 32
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 30
45013: PUSH
45014: LD_INT 31
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: PUSH
45021: EMPTY
45022: LIST
45023: LIST
45024: LIST
45025: PPUSH
45026: CALL_OW 72
45030: PUSH
45031: LD_VAR 0 2
45035: PPUSH
45036: LD_INT 2
45038: PUSH
45039: LD_INT 30
45041: PUSH
45042: LD_INT 4
45044: PUSH
45045: EMPTY
45046: LIST
45047: LIST
45048: PUSH
45049: LD_INT 30
45051: PUSH
45052: LD_INT 5
45054: PUSH
45055: EMPTY
45056: LIST
45057: LIST
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: LIST
45063: PPUSH
45064: CALL_OW 72
45068: ADD
45069: ST_TO_ADDR
45070: GO 45318
45072: LD_INT 2
45074: DOUBLE
45075: EQUAL
45076: IFTRUE 45086
45078: LD_INT 16
45080: DOUBLE
45081: EQUAL
45082: IFTRUE 45086
45084: GO 45132
45086: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45087: LD_ADDR_VAR 0 8
45091: PUSH
45092: LD_VAR 0 2
45096: PPUSH
45097: LD_INT 2
45099: PUSH
45100: LD_INT 30
45102: PUSH
45103: LD_INT 0
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 30
45112: PUSH
45113: LD_INT 1
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: LIST
45124: PPUSH
45125: CALL_OW 72
45129: ST_TO_ADDR
45130: GO 45318
45132: LD_INT 3
45134: DOUBLE
45135: EQUAL
45136: IFTRUE 45140
45138: GO 45186
45140: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
45141: LD_ADDR_VAR 0 8
45145: PUSH
45146: LD_VAR 0 2
45150: PPUSH
45151: LD_INT 2
45153: PUSH
45154: LD_INT 30
45156: PUSH
45157: LD_INT 2
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 30
45166: PUSH
45167: LD_INT 3
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: LIST
45178: PPUSH
45179: CALL_OW 72
45183: ST_TO_ADDR
45184: GO 45318
45186: LD_INT 4
45188: DOUBLE
45189: EQUAL
45190: IFTRUE 45194
45192: GO 45251
45194: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
45195: LD_ADDR_VAR 0 8
45199: PUSH
45200: LD_VAR 0 2
45204: PPUSH
45205: LD_INT 2
45207: PUSH
45208: LD_INT 30
45210: PUSH
45211: LD_INT 6
45213: PUSH
45214: EMPTY
45215: LIST
45216: LIST
45217: PUSH
45218: LD_INT 30
45220: PUSH
45221: LD_INT 7
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: PUSH
45228: LD_INT 30
45230: PUSH
45231: LD_INT 8
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: LIST
45242: LIST
45243: PPUSH
45244: CALL_OW 72
45248: ST_TO_ADDR
45249: GO 45318
45251: LD_INT 5
45253: DOUBLE
45254: EQUAL
45255: IFTRUE 45271
45257: LD_INT 8
45259: DOUBLE
45260: EQUAL
45261: IFTRUE 45271
45263: LD_INT 9
45265: DOUBLE
45266: EQUAL
45267: IFTRUE 45271
45269: GO 45317
45271: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
45272: LD_ADDR_VAR 0 8
45276: PUSH
45277: LD_VAR 0 2
45281: PPUSH
45282: LD_INT 2
45284: PUSH
45285: LD_INT 30
45287: PUSH
45288: LD_INT 4
45290: PUSH
45291: EMPTY
45292: LIST
45293: LIST
45294: PUSH
45295: LD_INT 30
45297: PUSH
45298: LD_INT 5
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: LIST
45309: PPUSH
45310: CALL_OW 72
45314: ST_TO_ADDR
45315: GO 45318
45317: POP
// if not tmp then
45318: LD_VAR 0 8
45322: NOT
45323: IFFALSE 45327
// exit ;
45325: GO 45787
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
45327: LD_VAR 0 4
45331: PUSH
45332: LD_INT 1
45334: PUSH
45335: LD_INT 15
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: IN
45342: PUSH
45343: LD_EXP 87
45347: PUSH
45348: LD_VAR 0 1
45352: ARRAY
45353: AND
45354: IFFALSE 45510
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
45356: LD_ADDR_VAR 0 9
45360: PUSH
45361: LD_EXP 87
45365: PUSH
45366: LD_VAR 0 1
45370: ARRAY
45371: PUSH
45372: LD_INT 1
45374: ARRAY
45375: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
45376: LD_VAR 0 9
45380: PUSH
45381: LD_EXP 88
45385: PUSH
45386: LD_VAR 0 1
45390: ARRAY
45391: IN
45392: NOT
45393: IFFALSE 45508
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
45395: LD_ADDR_EXP 88
45399: PUSH
45400: LD_EXP 88
45404: PPUSH
45405: LD_VAR 0 1
45409: PUSH
45410: LD_EXP 88
45414: PUSH
45415: LD_VAR 0 1
45419: ARRAY
45420: PUSH
45421: LD_INT 1
45423: PLUS
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PPUSH
45429: LD_VAR 0 9
45433: PPUSH
45434: CALL 57824 0 3
45438: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
45439: LD_ADDR_EXP 87
45443: PUSH
45444: LD_EXP 87
45448: PPUSH
45449: LD_VAR 0 1
45453: PPUSH
45454: LD_EXP 87
45458: PUSH
45459: LD_VAR 0 1
45463: ARRAY
45464: PUSH
45465: LD_VAR 0 9
45469: DIFF
45470: PPUSH
45471: CALL_OW 1
45475: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
45476: LD_VAR 0 3
45480: PPUSH
45481: LD_EXP 88
45485: PUSH
45486: LD_VAR 0 1
45490: ARRAY
45491: PUSH
45492: LD_EXP 88
45496: PUSH
45497: LD_VAR 0 1
45501: ARRAY
45502: ARRAY
45503: PPUSH
45504: CALL_OW 120
// end ; exit ;
45508: GO 45787
// end ; if tmp > 1 then
45510: LD_VAR 0 8
45514: PUSH
45515: LD_INT 1
45517: GREATER
45518: IFFALSE 45622
// for i = 2 to tmp do
45520: LD_ADDR_VAR 0 6
45524: PUSH
45525: DOUBLE
45526: LD_INT 2
45528: DEC
45529: ST_TO_ADDR
45530: LD_VAR 0 8
45534: PUSH
45535: FOR_TO
45536: IFFALSE 45620
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
45538: LD_VAR 0 8
45542: PUSH
45543: LD_VAR 0 6
45547: ARRAY
45548: PPUSH
45549: CALL_OW 461
45553: PUSH
45554: LD_INT 6
45556: EQUAL
45557: IFFALSE 45618
// begin x := tmp [ i ] ;
45559: LD_ADDR_VAR 0 9
45563: PUSH
45564: LD_VAR 0 8
45568: PUSH
45569: LD_VAR 0 6
45573: ARRAY
45574: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
45575: LD_ADDR_VAR 0 8
45579: PUSH
45580: LD_VAR 0 8
45584: PPUSH
45585: LD_VAR 0 6
45589: PPUSH
45590: CALL_OW 3
45594: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
45595: LD_ADDR_VAR 0 8
45599: PUSH
45600: LD_VAR 0 8
45604: PPUSH
45605: LD_INT 1
45607: PPUSH
45608: LD_VAR 0 9
45612: PPUSH
45613: CALL_OW 2
45617: ST_TO_ADDR
// end ;
45618: GO 45535
45620: POP
45621: POP
// for i in tmp do
45622: LD_ADDR_VAR 0 6
45626: PUSH
45627: LD_VAR 0 8
45631: PUSH
45632: FOR_IN
45633: IFFALSE 45660
// begin if IsNotFull ( i ) then
45635: LD_VAR 0 6
45639: PPUSH
45640: CALL 55046 0 1
45644: IFFALSE 45658
// begin j := i ;
45646: LD_ADDR_VAR 0 7
45650: PUSH
45651: LD_VAR 0 6
45655: ST_TO_ADDR
// break ;
45656: GO 45660
// end ; end ;
45658: GO 45632
45660: POP
45661: POP
// if j then
45662: LD_VAR 0 7
45666: IFFALSE 45684
// ComEnterUnit ( unit , j ) else
45668: LD_VAR 0 3
45672: PPUSH
45673: LD_VAR 0 7
45677: PPUSH
45678: CALL_OW 120
45682: GO 45787
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45684: LD_ADDR_VAR 0 10
45688: PUSH
45689: LD_VAR 0 2
45693: PPUSH
45694: LD_INT 2
45696: PUSH
45697: LD_INT 30
45699: PUSH
45700: LD_INT 0
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: LD_INT 30
45709: PUSH
45710: LD_INT 1
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: LIST
45721: PPUSH
45722: CALL_OW 72
45726: ST_TO_ADDR
// if depot then
45727: LD_VAR 0 10
45731: IFFALSE 45787
// begin depot := NearestUnitToUnit ( depot , unit ) ;
45733: LD_ADDR_VAR 0 10
45737: PUSH
45738: LD_VAR 0 10
45742: PPUSH
45743: LD_VAR 0 3
45747: PPUSH
45748: CALL_OW 74
45752: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
45753: LD_VAR 0 3
45757: PPUSH
45758: LD_VAR 0 10
45762: PPUSH
45763: CALL_OW 296
45767: PUSH
45768: LD_INT 10
45770: GREATER
45771: IFFALSE 45787
// ComStandNearbyBuilding ( unit , depot ) ;
45773: LD_VAR 0 3
45777: PPUSH
45778: LD_VAR 0 10
45782: PPUSH
45783: CALL 54426 0 2
// end ; end ; end ;
45787: LD_VAR 0 5
45791: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
45792: LD_INT 0
45794: PPUSH
45795: PPUSH
45796: PPUSH
45797: PPUSH
// if not mc_bases then
45798: LD_EXP 78
45802: NOT
45803: IFFALSE 45807
// exit ;
45805: GO 46046
// for i = 1 to mc_bases do
45807: LD_ADDR_VAR 0 2
45811: PUSH
45812: DOUBLE
45813: LD_INT 1
45815: DEC
45816: ST_TO_ADDR
45817: LD_EXP 78
45821: PUSH
45822: FOR_TO
45823: IFFALSE 46044
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45825: LD_ADDR_VAR 0 4
45829: PUSH
45830: LD_EXP 78
45834: PUSH
45835: LD_VAR 0 2
45839: ARRAY
45840: PPUSH
45841: LD_INT 21
45843: PUSH
45844: LD_INT 1
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PPUSH
45851: CALL_OW 72
45855: PUSH
45856: LD_EXP 107
45860: PUSH
45861: LD_VAR 0 2
45865: ARRAY
45866: UNION
45867: ST_TO_ADDR
// if not tmp then
45868: LD_VAR 0 4
45872: NOT
45873: IFFALSE 45877
// continue ;
45875: GO 45822
// for j in tmp do
45877: LD_ADDR_VAR 0 3
45881: PUSH
45882: LD_VAR 0 4
45886: PUSH
45887: FOR_IN
45888: IFFALSE 46040
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45890: LD_VAR 0 3
45894: PPUSH
45895: CALL_OW 110
45899: NOT
45900: PUSH
45901: LD_VAR 0 3
45905: PPUSH
45906: CALL_OW 314
45910: NOT
45911: AND
45912: PUSH
45913: LD_VAR 0 3
45917: PPUSH
45918: CALL_OW 311
45922: NOT
45923: AND
45924: PUSH
45925: LD_VAR 0 3
45929: PPUSH
45930: CALL_OW 310
45934: NOT
45935: AND
45936: PUSH
45937: LD_VAR 0 3
45941: PUSH
45942: LD_EXP 81
45946: PUSH
45947: LD_VAR 0 2
45951: ARRAY
45952: PUSH
45953: LD_INT 1
45955: ARRAY
45956: IN
45957: NOT
45958: AND
45959: PUSH
45960: LD_VAR 0 3
45964: PUSH
45965: LD_EXP 81
45969: PUSH
45970: LD_VAR 0 2
45974: ARRAY
45975: PUSH
45976: LD_INT 2
45978: ARRAY
45979: IN
45980: NOT
45981: AND
45982: PUSH
45983: LD_VAR 0 3
45987: PUSH
45988: LD_EXP 90
45992: PUSH
45993: LD_VAR 0 2
45997: ARRAY
45998: IN
45999: NOT
46000: AND
46001: IFFALSE 46038
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
46003: LD_VAR 0 2
46007: PPUSH
46008: LD_EXP 78
46012: PUSH
46013: LD_VAR 0 2
46017: ARRAY
46018: PPUSH
46019: LD_VAR 0 3
46023: PPUSH
46024: LD_VAR 0 3
46028: PPUSH
46029: CALL_OW 257
46033: PPUSH
46034: CALL 44852 0 4
// end ;
46038: GO 45887
46040: POP
46041: POP
// end ;
46042: GO 45822
46044: POP
46045: POP
// end ;
46046: LD_VAR 0 1
46050: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46051: LD_INT 0
46053: PPUSH
46054: PPUSH
46055: PPUSH
46056: PPUSH
46057: PPUSH
46058: PPUSH
// if not mc_bases [ base ] then
46059: LD_EXP 78
46063: PUSH
46064: LD_VAR 0 1
46068: ARRAY
46069: NOT
46070: IFFALSE 46074
// exit ;
46072: GO 46275
// tmp := [ ] ;
46074: LD_ADDR_VAR 0 6
46078: PUSH
46079: EMPTY
46080: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46081: LD_ADDR_VAR 0 7
46085: PUSH
46086: LD_VAR 0 3
46090: PPUSH
46091: LD_INT 0
46093: PPUSH
46094: CALL_OW 517
46098: ST_TO_ADDR
// if not list then
46099: LD_VAR 0 7
46103: NOT
46104: IFFALSE 46108
// exit ;
46106: GO 46275
// c := Count ( list [ 1 ] ) ;
46108: LD_ADDR_VAR 0 9
46112: PUSH
46113: LD_VAR 0 7
46117: PUSH
46118: LD_INT 1
46120: ARRAY
46121: PPUSH
46122: CALL 54964 0 1
46126: ST_TO_ADDR
// if amount > c then
46127: LD_VAR 0 2
46131: PUSH
46132: LD_VAR 0 9
46136: GREATER
46137: IFFALSE 46149
// amount := c ;
46139: LD_ADDR_VAR 0 2
46143: PUSH
46144: LD_VAR 0 9
46148: ST_TO_ADDR
// for i := 1 to amount do
46149: LD_ADDR_VAR 0 5
46153: PUSH
46154: DOUBLE
46155: LD_INT 1
46157: DEC
46158: ST_TO_ADDR
46159: LD_VAR 0 2
46163: PUSH
46164: FOR_TO
46165: IFFALSE 46223
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
46167: LD_ADDR_VAR 0 6
46171: PUSH
46172: LD_VAR 0 6
46176: PPUSH
46177: LD_VAR 0 5
46181: PPUSH
46182: LD_VAR 0 7
46186: PUSH
46187: LD_INT 1
46189: ARRAY
46190: PUSH
46191: LD_VAR 0 5
46195: ARRAY
46196: PUSH
46197: LD_VAR 0 7
46201: PUSH
46202: LD_INT 2
46204: ARRAY
46205: PUSH
46206: LD_VAR 0 5
46210: ARRAY
46211: PUSH
46212: EMPTY
46213: LIST
46214: LIST
46215: PPUSH
46216: CALL_OW 1
46220: ST_TO_ADDR
46221: GO 46164
46223: POP
46224: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
46225: LD_ADDR_EXP 91
46229: PUSH
46230: LD_EXP 91
46234: PPUSH
46235: LD_VAR 0 1
46239: PPUSH
46240: LD_VAR 0 6
46244: PPUSH
46245: CALL_OW 1
46249: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
46250: LD_ADDR_EXP 93
46254: PUSH
46255: LD_EXP 93
46259: PPUSH
46260: LD_VAR 0 1
46264: PPUSH
46265: LD_VAR 0 3
46269: PPUSH
46270: CALL_OW 1
46274: ST_TO_ADDR
// end ;
46275: LD_VAR 0 4
46279: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
46280: LD_INT 0
46282: PPUSH
// if not mc_bases [ base ] then
46283: LD_EXP 78
46287: PUSH
46288: LD_VAR 0 1
46292: ARRAY
46293: NOT
46294: IFFALSE 46298
// exit ;
46296: GO 46323
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
46298: LD_ADDR_EXP 83
46302: PUSH
46303: LD_EXP 83
46307: PPUSH
46308: LD_VAR 0 1
46312: PPUSH
46313: LD_VAR 0 2
46317: PPUSH
46318: CALL_OW 1
46322: ST_TO_ADDR
// end ;
46323: LD_VAR 0 3
46327: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
46328: LD_INT 0
46330: PPUSH
// if not mc_bases [ base ] then
46331: LD_EXP 78
46335: PUSH
46336: LD_VAR 0 1
46340: ARRAY
46341: NOT
46342: IFFALSE 46346
// exit ;
46344: GO 46383
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
46346: LD_ADDR_EXP 83
46350: PUSH
46351: LD_EXP 83
46355: PPUSH
46356: LD_VAR 0 1
46360: PPUSH
46361: LD_EXP 83
46365: PUSH
46366: LD_VAR 0 1
46370: ARRAY
46371: PUSH
46372: LD_VAR 0 2
46376: UNION
46377: PPUSH
46378: CALL_OW 1
46382: ST_TO_ADDR
// end ;
46383: LD_VAR 0 3
46387: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
46388: LD_INT 0
46390: PPUSH
// if not mc_bases [ base ] then
46391: LD_EXP 78
46395: PUSH
46396: LD_VAR 0 1
46400: ARRAY
46401: NOT
46402: IFFALSE 46406
// exit ;
46404: GO 46431
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
46406: LD_ADDR_EXP 99
46410: PUSH
46411: LD_EXP 99
46415: PPUSH
46416: LD_VAR 0 1
46420: PPUSH
46421: LD_VAR 0 2
46425: PPUSH
46426: CALL_OW 1
46430: ST_TO_ADDR
// end ;
46431: LD_VAR 0 3
46435: RET
// export function MC_InsertProduceList ( base , components ) ; begin
46436: LD_INT 0
46438: PPUSH
// if not mc_bases [ base ] then
46439: LD_EXP 78
46443: PUSH
46444: LD_VAR 0 1
46448: ARRAY
46449: NOT
46450: IFFALSE 46454
// exit ;
46452: GO 46491
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
46454: LD_ADDR_EXP 99
46458: PUSH
46459: LD_EXP 99
46463: PPUSH
46464: LD_VAR 0 1
46468: PPUSH
46469: LD_EXP 99
46473: PUSH
46474: LD_VAR 0 1
46478: ARRAY
46479: PUSH
46480: LD_VAR 0 2
46484: ADD
46485: PPUSH
46486: CALL_OW 1
46490: ST_TO_ADDR
// end ;
46491: LD_VAR 0 3
46495: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
46496: LD_INT 0
46498: PPUSH
// if not mc_bases [ base ] then
46499: LD_EXP 78
46503: PUSH
46504: LD_VAR 0 1
46508: ARRAY
46509: NOT
46510: IFFALSE 46514
// exit ;
46512: GO 46568
// mc_defender := Replace ( mc_defender , base , deflist ) ;
46514: LD_ADDR_EXP 100
46518: PUSH
46519: LD_EXP 100
46523: PPUSH
46524: LD_VAR 0 1
46528: PPUSH
46529: LD_VAR 0 2
46533: PPUSH
46534: CALL_OW 1
46538: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
46539: LD_ADDR_EXP 89
46543: PUSH
46544: LD_EXP 89
46548: PPUSH
46549: LD_VAR 0 1
46553: PPUSH
46554: LD_VAR 0 2
46558: PUSH
46559: LD_INT 0
46561: PLUS
46562: PPUSH
46563: CALL_OW 1
46567: ST_TO_ADDR
// end ;
46568: LD_VAR 0 3
46572: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
46573: LD_INT 0
46575: PPUSH
// if not mc_bases [ base ] then
46576: LD_EXP 78
46580: PUSH
46581: LD_VAR 0 1
46585: ARRAY
46586: NOT
46587: IFFALSE 46591
// exit ;
46589: GO 46616
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
46591: LD_ADDR_EXP 89
46595: PUSH
46596: LD_EXP 89
46600: PPUSH
46601: LD_VAR 0 1
46605: PPUSH
46606: LD_VAR 0 2
46610: PPUSH
46611: CALL_OW 1
46615: ST_TO_ADDR
// end ;
46616: LD_VAR 0 3
46620: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
46621: LD_INT 0
46623: PPUSH
46624: PPUSH
46625: PPUSH
46626: PPUSH
// if not mc_bases [ base ] then
46627: LD_EXP 78
46631: PUSH
46632: LD_VAR 0 1
46636: ARRAY
46637: NOT
46638: IFFALSE 46642
// exit ;
46640: GO 46707
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
46642: LD_ADDR_EXP 98
46646: PUSH
46647: LD_EXP 98
46651: PPUSH
46652: LD_VAR 0 1
46656: PUSH
46657: LD_EXP 98
46661: PUSH
46662: LD_VAR 0 1
46666: ARRAY
46667: PUSH
46668: LD_INT 1
46670: PLUS
46671: PUSH
46672: EMPTY
46673: LIST
46674: LIST
46675: PPUSH
46676: LD_VAR 0 1
46680: PUSH
46681: LD_VAR 0 2
46685: PUSH
46686: LD_VAR 0 3
46690: PUSH
46691: LD_VAR 0 4
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: LIST
46700: LIST
46701: PPUSH
46702: CALL 57824 0 3
46706: ST_TO_ADDR
// end ;
46707: LD_VAR 0 5
46711: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
46712: LD_INT 0
46714: PPUSH
// if not mc_bases [ base ] then
46715: LD_EXP 78
46719: PUSH
46720: LD_VAR 0 1
46724: ARRAY
46725: NOT
46726: IFFALSE 46730
// exit ;
46728: GO 46755
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
46730: LD_ADDR_EXP 115
46734: PUSH
46735: LD_EXP 115
46739: PPUSH
46740: LD_VAR 0 1
46744: PPUSH
46745: LD_VAR 0 2
46749: PPUSH
46750: CALL_OW 1
46754: ST_TO_ADDR
// end ;
46755: LD_VAR 0 3
46759: RET
// export function MC_GetMinesField ( base ) ; begin
46760: LD_INT 0
46762: PPUSH
// result := mc_mines [ base ] ;
46763: LD_ADDR_VAR 0 2
46767: PUSH
46768: LD_EXP 91
46772: PUSH
46773: LD_VAR 0 1
46777: ARRAY
46778: ST_TO_ADDR
// end ;
46779: LD_VAR 0 2
46783: RET
// export function MC_GetProduceList ( base ) ; begin
46784: LD_INT 0
46786: PPUSH
// result := mc_produce [ base ] ;
46787: LD_ADDR_VAR 0 2
46791: PUSH
46792: LD_EXP 99
46796: PUSH
46797: LD_VAR 0 1
46801: ARRAY
46802: ST_TO_ADDR
// end ;
46803: LD_VAR 0 2
46807: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
46808: LD_INT 0
46810: PPUSH
46811: PPUSH
// if not mc_bases then
46812: LD_EXP 78
46816: NOT
46817: IFFALSE 46821
// exit ;
46819: GO 46886
// if mc_bases [ base ] then
46821: LD_EXP 78
46825: PUSH
46826: LD_VAR 0 1
46830: ARRAY
46831: IFFALSE 46886
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46833: LD_ADDR_VAR 0 3
46837: PUSH
46838: LD_EXP 78
46842: PUSH
46843: LD_VAR 0 1
46847: ARRAY
46848: PPUSH
46849: LD_INT 30
46851: PUSH
46852: LD_VAR 0 2
46856: PUSH
46857: EMPTY
46858: LIST
46859: LIST
46860: PPUSH
46861: CALL_OW 72
46865: ST_TO_ADDR
// if result then
46866: LD_VAR 0 3
46870: IFFALSE 46886
// result := result [ 1 ] ;
46872: LD_ADDR_VAR 0 3
46876: PUSH
46877: LD_VAR 0 3
46881: PUSH
46882: LD_INT 1
46884: ARRAY
46885: ST_TO_ADDR
// end ; end ;
46886: LD_VAR 0 3
46890: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46891: LD_INT 0
46893: PPUSH
46894: PPUSH
// if not mc_bases then
46895: LD_EXP 78
46899: NOT
46900: IFFALSE 46904
// exit ;
46902: GO 46949
// if mc_bases [ base ] then
46904: LD_EXP 78
46908: PUSH
46909: LD_VAR 0 1
46913: ARRAY
46914: IFFALSE 46949
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46916: LD_ADDR_VAR 0 3
46920: PUSH
46921: LD_EXP 78
46925: PUSH
46926: LD_VAR 0 1
46930: ARRAY
46931: PPUSH
46932: LD_INT 30
46934: PUSH
46935: LD_VAR 0 2
46939: PUSH
46940: EMPTY
46941: LIST
46942: LIST
46943: PPUSH
46944: CALL_OW 72
46948: ST_TO_ADDR
// end ;
46949: LD_VAR 0 3
46953: RET
// export function MC_SetTame ( base , area ) ; begin
46954: LD_INT 0
46956: PPUSH
// if not mc_bases or not base then
46957: LD_EXP 78
46961: NOT
46962: PUSH
46963: LD_VAR 0 1
46967: NOT
46968: OR
46969: IFFALSE 46973
// exit ;
46971: GO 46998
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46973: LD_ADDR_EXP 106
46977: PUSH
46978: LD_EXP 106
46982: PPUSH
46983: LD_VAR 0 1
46987: PPUSH
46988: LD_VAR 0 2
46992: PPUSH
46993: CALL_OW 1
46997: ST_TO_ADDR
// end ;
46998: LD_VAR 0 3
47002: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
47003: LD_INT 0
47005: PPUSH
47006: PPUSH
// if not mc_bases or not base then
47007: LD_EXP 78
47011: NOT
47012: PUSH
47013: LD_VAR 0 1
47017: NOT
47018: OR
47019: IFFALSE 47023
// exit ;
47021: GO 47125
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47023: LD_ADDR_VAR 0 4
47027: PUSH
47028: LD_EXP 78
47032: PUSH
47033: LD_VAR 0 1
47037: ARRAY
47038: PPUSH
47039: LD_INT 30
47041: PUSH
47042: LD_VAR 0 2
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PPUSH
47051: CALL_OW 72
47055: ST_TO_ADDR
// if not tmp then
47056: LD_VAR 0 4
47060: NOT
47061: IFFALSE 47065
// exit ;
47063: GO 47125
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47065: LD_ADDR_EXP 110
47069: PUSH
47070: LD_EXP 110
47074: PPUSH
47075: LD_VAR 0 1
47079: PPUSH
47080: LD_EXP 110
47084: PUSH
47085: LD_VAR 0 1
47089: ARRAY
47090: PPUSH
47091: LD_EXP 110
47095: PUSH
47096: LD_VAR 0 1
47100: ARRAY
47101: PUSH
47102: LD_INT 1
47104: PLUS
47105: PPUSH
47106: LD_VAR 0 4
47110: PUSH
47111: LD_INT 1
47113: ARRAY
47114: PPUSH
47115: CALL_OW 2
47119: PPUSH
47120: CALL_OW 1
47124: ST_TO_ADDR
// end ;
47125: LD_VAR 0 3
47129: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47130: LD_INT 0
47132: PPUSH
47133: PPUSH
// if not mc_bases or not base or not kinds then
47134: LD_EXP 78
47138: NOT
47139: PUSH
47140: LD_VAR 0 1
47144: NOT
47145: OR
47146: PUSH
47147: LD_VAR 0 2
47151: NOT
47152: OR
47153: IFFALSE 47157
// exit ;
47155: GO 47218
// for i in kinds do
47157: LD_ADDR_VAR 0 4
47161: PUSH
47162: LD_VAR 0 2
47166: PUSH
47167: FOR_IN
47168: IFFALSE 47216
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
47170: LD_ADDR_EXP 112
47174: PUSH
47175: LD_EXP 112
47179: PPUSH
47180: LD_VAR 0 1
47184: PUSH
47185: LD_EXP 112
47189: PUSH
47190: LD_VAR 0 1
47194: ARRAY
47195: PUSH
47196: LD_INT 1
47198: PLUS
47199: PUSH
47200: EMPTY
47201: LIST
47202: LIST
47203: PPUSH
47204: LD_VAR 0 4
47208: PPUSH
47209: CALL 57824 0 3
47213: ST_TO_ADDR
47214: GO 47167
47216: POP
47217: POP
// end ;
47218: LD_VAR 0 3
47222: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
47223: LD_INT 0
47225: PPUSH
// if not mc_bases or not base or not areas then
47226: LD_EXP 78
47230: NOT
47231: PUSH
47232: LD_VAR 0 1
47236: NOT
47237: OR
47238: PUSH
47239: LD_VAR 0 2
47243: NOT
47244: OR
47245: IFFALSE 47249
// exit ;
47247: GO 47274
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
47249: LD_ADDR_EXP 96
47253: PUSH
47254: LD_EXP 96
47258: PPUSH
47259: LD_VAR 0 1
47263: PPUSH
47264: LD_VAR 0 2
47268: PPUSH
47269: CALL_OW 1
47273: ST_TO_ADDR
// end ;
47274: LD_VAR 0 3
47278: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
47279: LD_INT 0
47281: PPUSH
// if not mc_bases or not base or not teleports_exit then
47282: LD_EXP 78
47286: NOT
47287: PUSH
47288: LD_VAR 0 1
47292: NOT
47293: OR
47294: PUSH
47295: LD_VAR 0 2
47299: NOT
47300: OR
47301: IFFALSE 47305
// exit ;
47303: GO 47330
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
47305: LD_ADDR_EXP 113
47309: PUSH
47310: LD_EXP 113
47314: PPUSH
47315: LD_VAR 0 1
47319: PPUSH
47320: LD_VAR 0 2
47324: PPUSH
47325: CALL_OW 1
47329: ST_TO_ADDR
// end ;
47330: LD_VAR 0 3
47334: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
47335: LD_INT 0
47337: PPUSH
47338: PPUSH
47339: PPUSH
// if not mc_bases or not base or not ext_list then
47340: LD_EXP 78
47344: NOT
47345: PUSH
47346: LD_VAR 0 1
47350: NOT
47351: OR
47352: PUSH
47353: LD_VAR 0 5
47357: NOT
47358: OR
47359: IFFALSE 47363
// exit ;
47361: GO 47536
// tmp := GetFacExtXYD ( x , y , d ) ;
47363: LD_ADDR_VAR 0 8
47367: PUSH
47368: LD_VAR 0 2
47372: PPUSH
47373: LD_VAR 0 3
47377: PPUSH
47378: LD_VAR 0 4
47382: PPUSH
47383: CALL 88198 0 3
47387: ST_TO_ADDR
// if not tmp then
47388: LD_VAR 0 8
47392: NOT
47393: IFFALSE 47397
// exit ;
47395: GO 47536
// for i in tmp do
47397: LD_ADDR_VAR 0 7
47401: PUSH
47402: LD_VAR 0 8
47406: PUSH
47407: FOR_IN
47408: IFFALSE 47534
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
47410: LD_ADDR_EXP 83
47414: PUSH
47415: LD_EXP 83
47419: PPUSH
47420: LD_VAR 0 1
47424: PPUSH
47425: LD_EXP 83
47429: PUSH
47430: LD_VAR 0 1
47434: ARRAY
47435: PPUSH
47436: LD_EXP 83
47440: PUSH
47441: LD_VAR 0 1
47445: ARRAY
47446: PUSH
47447: LD_INT 1
47449: PLUS
47450: PPUSH
47451: LD_VAR 0 5
47455: PUSH
47456: LD_INT 1
47458: ARRAY
47459: PUSH
47460: LD_VAR 0 7
47464: PUSH
47465: LD_INT 1
47467: ARRAY
47468: PUSH
47469: LD_VAR 0 7
47473: PUSH
47474: LD_INT 2
47476: ARRAY
47477: PUSH
47478: LD_VAR 0 7
47482: PUSH
47483: LD_INT 3
47485: ARRAY
47486: PUSH
47487: EMPTY
47488: LIST
47489: LIST
47490: LIST
47491: LIST
47492: PPUSH
47493: CALL_OW 2
47497: PPUSH
47498: CALL_OW 1
47502: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
47503: LD_ADDR_VAR 0 5
47507: PUSH
47508: LD_VAR 0 5
47512: PPUSH
47513: LD_INT 1
47515: PPUSH
47516: CALL_OW 3
47520: ST_TO_ADDR
// if not ext_list then
47521: LD_VAR 0 5
47525: NOT
47526: IFFALSE 47532
// exit ;
47528: POP
47529: POP
47530: GO 47536
// end ;
47532: GO 47407
47534: POP
47535: POP
// end ;
47536: LD_VAR 0 6
47540: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
47541: LD_INT 0
47543: PPUSH
// if not mc_bases or not base or not weapon_list then
47544: LD_EXP 78
47548: NOT
47549: PUSH
47550: LD_VAR 0 1
47554: NOT
47555: OR
47556: PUSH
47557: LD_VAR 0 2
47561: NOT
47562: OR
47563: IFFALSE 47567
// exit ;
47565: GO 47592
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
47567: LD_ADDR_EXP 117
47571: PUSH
47572: LD_EXP 117
47576: PPUSH
47577: LD_VAR 0 1
47581: PPUSH
47582: LD_VAR 0 2
47586: PPUSH
47587: CALL_OW 1
47591: ST_TO_ADDR
// end ;
47592: LD_VAR 0 3
47596: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
47597: LD_INT 0
47599: PPUSH
// if not mc_bases or not base or not tech_list then
47600: LD_EXP 78
47604: NOT
47605: PUSH
47606: LD_VAR 0 1
47610: NOT
47611: OR
47612: PUSH
47613: LD_VAR 0 2
47617: NOT
47618: OR
47619: IFFALSE 47623
// exit ;
47621: GO 47648
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
47623: LD_ADDR_EXP 105
47627: PUSH
47628: LD_EXP 105
47632: PPUSH
47633: LD_VAR 0 1
47637: PPUSH
47638: LD_VAR 0 2
47642: PPUSH
47643: CALL_OW 1
47647: ST_TO_ADDR
// end ;
47648: LD_VAR 0 3
47652: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
47653: LD_INT 0
47655: PPUSH
// if not mc_bases or not parking_area or not base then
47656: LD_EXP 78
47660: NOT
47661: PUSH
47662: LD_VAR 0 2
47666: NOT
47667: OR
47668: PUSH
47669: LD_VAR 0 1
47673: NOT
47674: OR
47675: IFFALSE 47679
// exit ;
47677: GO 47704
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
47679: LD_ADDR_EXP 102
47683: PUSH
47684: LD_EXP 102
47688: PPUSH
47689: LD_VAR 0 1
47693: PPUSH
47694: LD_VAR 0 2
47698: PPUSH
47699: CALL_OW 1
47703: ST_TO_ADDR
// end ;
47704: LD_VAR 0 3
47708: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
47709: LD_INT 0
47711: PPUSH
// if not mc_bases or not base or not scan_area then
47712: LD_EXP 78
47716: NOT
47717: PUSH
47718: LD_VAR 0 1
47722: NOT
47723: OR
47724: PUSH
47725: LD_VAR 0 2
47729: NOT
47730: OR
47731: IFFALSE 47735
// exit ;
47733: GO 47760
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
47735: LD_ADDR_EXP 103
47739: PUSH
47740: LD_EXP 103
47744: PPUSH
47745: LD_VAR 0 1
47749: PPUSH
47750: LD_VAR 0 2
47754: PPUSH
47755: CALL_OW 1
47759: ST_TO_ADDR
// end ;
47760: LD_VAR 0 3
47764: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
47765: LD_INT 0
47767: PPUSH
47768: PPUSH
// if not mc_bases or not base then
47769: LD_EXP 78
47773: NOT
47774: PUSH
47775: LD_VAR 0 1
47779: NOT
47780: OR
47781: IFFALSE 47785
// exit ;
47783: GO 47849
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
47785: LD_ADDR_VAR 0 3
47789: PUSH
47790: LD_INT 1
47792: PUSH
47793: LD_INT 2
47795: PUSH
47796: LD_INT 3
47798: PUSH
47799: LD_INT 4
47801: PUSH
47802: LD_INT 11
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: LIST
47809: LIST
47810: LIST
47811: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
47812: LD_ADDR_EXP 105
47816: PUSH
47817: LD_EXP 105
47821: PPUSH
47822: LD_VAR 0 1
47826: PPUSH
47827: LD_EXP 105
47831: PUSH
47832: LD_VAR 0 1
47836: ARRAY
47837: PUSH
47838: LD_VAR 0 3
47842: DIFF
47843: PPUSH
47844: CALL_OW 1
47848: ST_TO_ADDR
// end ;
47849: LD_VAR 0 2
47853: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47854: LD_INT 0
47856: PPUSH
// result := mc_vehicles [ base ] ;
47857: LD_ADDR_VAR 0 3
47861: PUSH
47862: LD_EXP 97
47866: PUSH
47867: LD_VAR 0 1
47871: ARRAY
47872: ST_TO_ADDR
// if onlyCombat then
47873: LD_VAR 0 2
47877: IFFALSE 48049
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47879: LD_ADDR_VAR 0 3
47883: PUSH
47884: LD_VAR 0 3
47888: PUSH
47889: LD_VAR 0 3
47893: PPUSH
47894: LD_INT 2
47896: PUSH
47897: LD_INT 34
47899: PUSH
47900: LD_INT 12
47902: PUSH
47903: EMPTY
47904: LIST
47905: LIST
47906: PUSH
47907: LD_INT 34
47909: PUSH
47910: LD_INT 51
47912: PUSH
47913: EMPTY
47914: LIST
47915: LIST
47916: PUSH
47917: LD_INT 34
47919: PUSH
47920: LD_INT 89
47922: PUSH
47923: EMPTY
47924: LIST
47925: LIST
47926: PUSH
47927: LD_INT 34
47929: PUSH
47930: LD_INT 32
47932: PUSH
47933: EMPTY
47934: LIST
47935: LIST
47936: PUSH
47937: LD_INT 34
47939: PUSH
47940: LD_INT 13
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 34
47949: PUSH
47950: LD_INT 52
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: LD_INT 34
47959: PUSH
47960: LD_INT 88
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: LD_INT 34
47969: PUSH
47970: LD_INT 14
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 34
47979: PUSH
47980: LD_INT 53
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 34
47989: PUSH
47990: LD_INT 98
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: LD_INT 34
47999: PUSH
48000: LD_INT 31
48002: PUSH
48003: EMPTY
48004: LIST
48005: LIST
48006: PUSH
48007: LD_INT 34
48009: PUSH
48010: LD_INT 48
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 34
48019: PUSH
48020: LD_INT 8
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: LIST
48042: PPUSH
48043: CALL_OW 72
48047: DIFF
48048: ST_TO_ADDR
// end ; end_of_file
48049: LD_VAR 0 3
48053: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48054: LD_INT 0
48056: PPUSH
48057: PPUSH
48058: PPUSH
// if not mc_bases or not skirmish then
48059: LD_EXP 78
48063: NOT
48064: PUSH
48065: LD_EXP 76
48069: NOT
48070: OR
48071: IFFALSE 48075
// exit ;
48073: GO 48240
// for i = 1 to mc_bases do
48075: LD_ADDR_VAR 0 4
48079: PUSH
48080: DOUBLE
48081: LD_INT 1
48083: DEC
48084: ST_TO_ADDR
48085: LD_EXP 78
48089: PUSH
48090: FOR_TO
48091: IFFALSE 48238
// begin if sci in mc_bases [ i ] then
48093: LD_VAR 0 2
48097: PUSH
48098: LD_EXP 78
48102: PUSH
48103: LD_VAR 0 4
48107: ARRAY
48108: IN
48109: IFFALSE 48236
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48111: LD_ADDR_EXP 107
48115: PUSH
48116: LD_EXP 107
48120: PPUSH
48121: LD_VAR 0 4
48125: PUSH
48126: LD_EXP 107
48130: PUSH
48131: LD_VAR 0 4
48135: ARRAY
48136: PUSH
48137: LD_INT 1
48139: PLUS
48140: PUSH
48141: EMPTY
48142: LIST
48143: LIST
48144: PPUSH
48145: LD_VAR 0 1
48149: PPUSH
48150: CALL 57824 0 3
48154: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
48155: LD_ADDR_VAR 0 5
48159: PUSH
48160: LD_EXP 78
48164: PUSH
48165: LD_VAR 0 4
48169: ARRAY
48170: PPUSH
48171: LD_INT 2
48173: PUSH
48174: LD_INT 30
48176: PUSH
48177: LD_INT 0
48179: PUSH
48180: EMPTY
48181: LIST
48182: LIST
48183: PUSH
48184: LD_INT 30
48186: PUSH
48187: LD_INT 1
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: LIST
48198: PPUSH
48199: CALL_OW 72
48203: PPUSH
48204: LD_VAR 0 1
48208: PPUSH
48209: CALL_OW 74
48213: ST_TO_ADDR
// if tmp then
48214: LD_VAR 0 5
48218: IFFALSE 48234
// ComStandNearbyBuilding ( ape , tmp ) ;
48220: LD_VAR 0 1
48224: PPUSH
48225: LD_VAR 0 5
48229: PPUSH
48230: CALL 54426 0 2
// break ;
48234: GO 48238
// end ; end ;
48236: GO 48090
48238: POP
48239: POP
// end ;
48240: LD_VAR 0 3
48244: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
48245: LD_INT 0
48247: PPUSH
48248: PPUSH
48249: PPUSH
// if not mc_bases or not skirmish then
48250: LD_EXP 78
48254: NOT
48255: PUSH
48256: LD_EXP 76
48260: NOT
48261: OR
48262: IFFALSE 48266
// exit ;
48264: GO 48355
// for i = 1 to mc_bases do
48266: LD_ADDR_VAR 0 4
48270: PUSH
48271: DOUBLE
48272: LD_INT 1
48274: DEC
48275: ST_TO_ADDR
48276: LD_EXP 78
48280: PUSH
48281: FOR_TO
48282: IFFALSE 48353
// begin if building in mc_busy_turret_list [ i ] then
48284: LD_VAR 0 1
48288: PUSH
48289: LD_EXP 88
48293: PUSH
48294: LD_VAR 0 4
48298: ARRAY
48299: IN
48300: IFFALSE 48351
// begin tmp := mc_busy_turret_list [ i ] diff building ;
48302: LD_ADDR_VAR 0 5
48306: PUSH
48307: LD_EXP 88
48311: PUSH
48312: LD_VAR 0 4
48316: ARRAY
48317: PUSH
48318: LD_VAR 0 1
48322: DIFF
48323: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
48324: LD_ADDR_EXP 88
48328: PUSH
48329: LD_EXP 88
48333: PPUSH
48334: LD_VAR 0 4
48338: PPUSH
48339: LD_VAR 0 5
48343: PPUSH
48344: CALL_OW 1
48348: ST_TO_ADDR
// break ;
48349: GO 48353
// end ; end ;
48351: GO 48281
48353: POP
48354: POP
// end ;
48355: LD_VAR 0 3
48359: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
48360: LD_INT 0
48362: PPUSH
48363: PPUSH
48364: PPUSH
// if not mc_bases or not skirmish then
48365: LD_EXP 78
48369: NOT
48370: PUSH
48371: LD_EXP 76
48375: NOT
48376: OR
48377: IFFALSE 48381
// exit ;
48379: GO 48580
// for i = 1 to mc_bases do
48381: LD_ADDR_VAR 0 5
48385: PUSH
48386: DOUBLE
48387: LD_INT 1
48389: DEC
48390: ST_TO_ADDR
48391: LD_EXP 78
48395: PUSH
48396: FOR_TO
48397: IFFALSE 48578
// if building in mc_bases [ i ] then
48399: LD_VAR 0 1
48403: PUSH
48404: LD_EXP 78
48408: PUSH
48409: LD_VAR 0 5
48413: ARRAY
48414: IN
48415: IFFALSE 48576
// begin tmp := mc_bases [ i ] diff building ;
48417: LD_ADDR_VAR 0 6
48421: PUSH
48422: LD_EXP 78
48426: PUSH
48427: LD_VAR 0 5
48431: ARRAY
48432: PUSH
48433: LD_VAR 0 1
48437: DIFF
48438: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
48439: LD_ADDR_EXP 78
48443: PUSH
48444: LD_EXP 78
48448: PPUSH
48449: LD_VAR 0 5
48453: PPUSH
48454: LD_VAR 0 6
48458: PPUSH
48459: CALL_OW 1
48463: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
48464: LD_VAR 0 1
48468: PUSH
48469: LD_EXP 86
48473: PUSH
48474: LD_VAR 0 5
48478: ARRAY
48479: IN
48480: IFFALSE 48519
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
48482: LD_ADDR_EXP 86
48486: PUSH
48487: LD_EXP 86
48491: PPUSH
48492: LD_VAR 0 5
48496: PPUSH
48497: LD_EXP 86
48501: PUSH
48502: LD_VAR 0 5
48506: ARRAY
48507: PUSH
48508: LD_VAR 0 1
48512: DIFF
48513: PPUSH
48514: CALL_OW 1
48518: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
48519: LD_VAR 0 1
48523: PUSH
48524: LD_EXP 87
48528: PUSH
48529: LD_VAR 0 5
48533: ARRAY
48534: IN
48535: IFFALSE 48574
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
48537: LD_ADDR_EXP 87
48541: PUSH
48542: LD_EXP 87
48546: PPUSH
48547: LD_VAR 0 5
48551: PPUSH
48552: LD_EXP 87
48556: PUSH
48557: LD_VAR 0 5
48561: ARRAY
48562: PUSH
48563: LD_VAR 0 1
48567: DIFF
48568: PPUSH
48569: CALL_OW 1
48573: ST_TO_ADDR
// break ;
48574: GO 48578
// end ;
48576: GO 48396
48578: POP
48579: POP
// end ;
48580: LD_VAR 0 4
48584: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
48585: LD_INT 0
48587: PPUSH
48588: PPUSH
48589: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
48590: LD_EXP 78
48594: NOT
48595: PUSH
48596: LD_EXP 76
48600: NOT
48601: OR
48602: PUSH
48603: LD_VAR 0 3
48607: PUSH
48608: LD_EXP 104
48612: IN
48613: NOT
48614: OR
48615: IFFALSE 48619
// exit ;
48617: GO 48742
// for i = 1 to mc_vehicles do
48619: LD_ADDR_VAR 0 6
48623: PUSH
48624: DOUBLE
48625: LD_INT 1
48627: DEC
48628: ST_TO_ADDR
48629: LD_EXP 97
48633: PUSH
48634: FOR_TO
48635: IFFALSE 48740
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
48637: LD_VAR 0 2
48641: PUSH
48642: LD_EXP 97
48646: PUSH
48647: LD_VAR 0 6
48651: ARRAY
48652: IN
48653: PUSH
48654: LD_VAR 0 1
48658: PUSH
48659: LD_EXP 97
48663: PUSH
48664: LD_VAR 0 6
48668: ARRAY
48669: IN
48670: OR
48671: IFFALSE 48738
// begin tmp := mc_vehicles [ i ] diff old ;
48673: LD_ADDR_VAR 0 7
48677: PUSH
48678: LD_EXP 97
48682: PUSH
48683: LD_VAR 0 6
48687: ARRAY
48688: PUSH
48689: LD_VAR 0 2
48693: DIFF
48694: ST_TO_ADDR
// tmp := tmp diff new ;
48695: LD_ADDR_VAR 0 7
48699: PUSH
48700: LD_VAR 0 7
48704: PUSH
48705: LD_VAR 0 1
48709: DIFF
48710: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
48711: LD_ADDR_EXP 97
48715: PUSH
48716: LD_EXP 97
48720: PPUSH
48721: LD_VAR 0 6
48725: PPUSH
48726: LD_VAR 0 7
48730: PPUSH
48731: CALL_OW 1
48735: ST_TO_ADDR
// break ;
48736: GO 48740
// end ;
48738: GO 48634
48740: POP
48741: POP
// end ;
48742: LD_VAR 0 5
48746: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
48747: LD_INT 0
48749: PPUSH
48750: PPUSH
48751: PPUSH
48752: PPUSH
// if not mc_bases or not skirmish then
48753: LD_EXP 78
48757: NOT
48758: PUSH
48759: LD_EXP 76
48763: NOT
48764: OR
48765: IFFALSE 48769
// exit ;
48767: GO 49189
// repeat wait ( 0 0$1 ) ;
48769: LD_INT 35
48771: PPUSH
48772: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
48776: LD_EXP 122
48780: NOT
48781: IFFALSE 48769
// mc_block_vehicle_constructed_thread := true ;
48783: LD_ADDR_EXP 122
48787: PUSH
48788: LD_INT 1
48790: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
48791: LD_ADDR_VAR 0 5
48795: PUSH
48796: LD_VAR 0 1
48800: PPUSH
48801: CALL_OW 255
48805: ST_TO_ADDR
// for i = 1 to mc_bases do
48806: LD_ADDR_VAR 0 4
48810: PUSH
48811: DOUBLE
48812: LD_INT 1
48814: DEC
48815: ST_TO_ADDR
48816: LD_EXP 78
48820: PUSH
48821: FOR_TO
48822: IFFALSE 49179
// begin if factory in mc_bases [ i ] then
48824: LD_VAR 0 2
48828: PUSH
48829: LD_EXP 78
48833: PUSH
48834: LD_VAR 0 4
48838: ARRAY
48839: IN
48840: IFFALSE 49177
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48842: LD_EXP 100
48846: PUSH
48847: LD_VAR 0 4
48851: ARRAY
48852: PUSH
48853: LD_EXP 89
48857: PUSH
48858: LD_VAR 0 4
48862: ARRAY
48863: LESS
48864: PUSH
48865: LD_VAR 0 1
48869: PPUSH
48870: CALL_OW 264
48874: PUSH
48875: LD_INT 31
48877: PUSH
48878: LD_INT 32
48880: PUSH
48881: LD_INT 51
48883: PUSH
48884: LD_INT 89
48886: PUSH
48887: LD_INT 12
48889: PUSH
48890: LD_INT 30
48892: PUSH
48893: LD_INT 98
48895: PUSH
48896: LD_INT 11
48898: PUSH
48899: LD_INT 53
48901: PUSH
48902: LD_INT 14
48904: PUSH
48905: LD_INT 91
48907: PUSH
48908: LD_INT 29
48910: PUSH
48911: LD_INT 99
48913: PUSH
48914: LD_INT 13
48916: PUSH
48917: LD_INT 52
48919: PUSH
48920: LD_INT 88
48922: PUSH
48923: LD_INT 48
48925: PUSH
48926: LD_INT 8
48928: PUSH
48929: EMPTY
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: LIST
48947: LIST
48948: IN
48949: NOT
48950: AND
48951: IFFALSE 48999
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48953: LD_ADDR_EXP 100
48957: PUSH
48958: LD_EXP 100
48962: PPUSH
48963: LD_VAR 0 4
48967: PUSH
48968: LD_EXP 100
48972: PUSH
48973: LD_VAR 0 4
48977: ARRAY
48978: PUSH
48979: LD_INT 1
48981: PLUS
48982: PUSH
48983: EMPTY
48984: LIST
48985: LIST
48986: PPUSH
48987: LD_VAR 0 1
48991: PPUSH
48992: CALL 57824 0 3
48996: ST_TO_ADDR
48997: GO 49043
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48999: LD_ADDR_EXP 97
49003: PUSH
49004: LD_EXP 97
49008: PPUSH
49009: LD_VAR 0 4
49013: PUSH
49014: LD_EXP 97
49018: PUSH
49019: LD_VAR 0 4
49023: ARRAY
49024: PUSH
49025: LD_INT 1
49027: PLUS
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PPUSH
49033: LD_VAR 0 1
49037: PPUSH
49038: CALL 57824 0 3
49042: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
49043: LD_ADDR_EXP 122
49047: PUSH
49048: LD_INT 0
49050: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49051: LD_VAR 0 1
49055: PPUSH
49056: CALL_OW 263
49060: PUSH
49061: LD_INT 2
49063: EQUAL
49064: IFFALSE 49093
// begin repeat wait ( 0 0$3 ) ;
49066: LD_INT 105
49068: PPUSH
49069: CALL_OW 67
// Connect ( vehicle ) ;
49073: LD_VAR 0 1
49077: PPUSH
49078: CALL 61170 0 1
// until IsControledBy ( vehicle ) ;
49082: LD_VAR 0 1
49086: PPUSH
49087: CALL_OW 312
49091: IFFALSE 49066
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49093: LD_VAR 0 1
49097: PPUSH
49098: LD_EXP 102
49102: PUSH
49103: LD_VAR 0 4
49107: ARRAY
49108: PPUSH
49109: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49113: LD_VAR 0 1
49117: PPUSH
49118: CALL_OW 263
49122: PUSH
49123: LD_INT 1
49125: NONEQUAL
49126: IFFALSE 49130
// break ;
49128: GO 49179
// repeat wait ( 0 0$1 ) ;
49130: LD_INT 35
49132: PPUSH
49133: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
49137: LD_VAR 0 1
49141: PPUSH
49142: LD_EXP 102
49146: PUSH
49147: LD_VAR 0 4
49151: ARRAY
49152: PPUSH
49153: CALL_OW 308
49157: IFFALSE 49130
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
49159: LD_VAR 0 1
49163: PPUSH
49164: CALL_OW 311
49168: PPUSH
49169: CALL_OW 121
// exit ;
49173: POP
49174: POP
49175: GO 49189
// end ; end ;
49177: GO 48821
49179: POP
49180: POP
// mc_block_vehicle_constructed_thread := false ;
49181: LD_ADDR_EXP 122
49185: PUSH
49186: LD_INT 0
49188: ST_TO_ADDR
// end ;
49189: LD_VAR 0 3
49193: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
49194: LD_INT 0
49196: PPUSH
49197: PPUSH
49198: PPUSH
49199: PPUSH
// if not mc_bases or not skirmish then
49200: LD_EXP 78
49204: NOT
49205: PUSH
49206: LD_EXP 76
49210: NOT
49211: OR
49212: IFFALSE 49216
// exit ;
49214: GO 49569
// repeat wait ( 0 0$1 ) ;
49216: LD_INT 35
49218: PPUSH
49219: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
49223: LD_VAR 0 2
49227: PPUSH
49228: LD_VAR 0 3
49232: PPUSH
49233: CALL_OW 284
49237: IFFALSE 49216
// if GetResourceTypeXY ( x , y ) = mat_artefact then
49239: LD_VAR 0 2
49243: PPUSH
49244: LD_VAR 0 3
49248: PPUSH
49249: CALL_OW 283
49253: PUSH
49254: LD_INT 4
49256: EQUAL
49257: IFFALSE 49261
// exit ;
49259: GO 49569
// for i = 1 to mc_bases do
49261: LD_ADDR_VAR 0 7
49265: PUSH
49266: DOUBLE
49267: LD_INT 1
49269: DEC
49270: ST_TO_ADDR
49271: LD_EXP 78
49275: PUSH
49276: FOR_TO
49277: IFFALSE 49567
// begin if mc_crates_area [ i ] then
49279: LD_EXP 96
49283: PUSH
49284: LD_VAR 0 7
49288: ARRAY
49289: IFFALSE 49400
// for j in mc_crates_area [ i ] do
49291: LD_ADDR_VAR 0 8
49295: PUSH
49296: LD_EXP 96
49300: PUSH
49301: LD_VAR 0 7
49305: ARRAY
49306: PUSH
49307: FOR_IN
49308: IFFALSE 49398
// if InArea ( x , y , j ) then
49310: LD_VAR 0 2
49314: PPUSH
49315: LD_VAR 0 3
49319: PPUSH
49320: LD_VAR 0 8
49324: PPUSH
49325: CALL_OW 309
49329: IFFALSE 49396
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49331: LD_ADDR_EXP 94
49335: PUSH
49336: LD_EXP 94
49340: PPUSH
49341: LD_VAR 0 7
49345: PUSH
49346: LD_EXP 94
49350: PUSH
49351: LD_VAR 0 7
49355: ARRAY
49356: PUSH
49357: LD_INT 1
49359: PLUS
49360: PUSH
49361: EMPTY
49362: LIST
49363: LIST
49364: PPUSH
49365: LD_VAR 0 4
49369: PUSH
49370: LD_VAR 0 2
49374: PUSH
49375: LD_VAR 0 3
49379: PUSH
49380: EMPTY
49381: LIST
49382: LIST
49383: LIST
49384: PPUSH
49385: CALL 57824 0 3
49389: ST_TO_ADDR
// exit ;
49390: POP
49391: POP
49392: POP
49393: POP
49394: GO 49569
// end ;
49396: GO 49307
49398: POP
49399: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49400: LD_ADDR_VAR 0 9
49404: PUSH
49405: LD_EXP 78
49409: PUSH
49410: LD_VAR 0 7
49414: ARRAY
49415: PPUSH
49416: LD_INT 2
49418: PUSH
49419: LD_INT 30
49421: PUSH
49422: LD_INT 0
49424: PUSH
49425: EMPTY
49426: LIST
49427: LIST
49428: PUSH
49429: LD_INT 30
49431: PUSH
49432: LD_INT 1
49434: PUSH
49435: EMPTY
49436: LIST
49437: LIST
49438: PUSH
49439: EMPTY
49440: LIST
49441: LIST
49442: LIST
49443: PPUSH
49444: CALL_OW 72
49448: ST_TO_ADDR
// if not depot then
49449: LD_VAR 0 9
49453: NOT
49454: IFFALSE 49458
// continue ;
49456: GO 49276
// for j in depot do
49458: LD_ADDR_VAR 0 8
49462: PUSH
49463: LD_VAR 0 9
49467: PUSH
49468: FOR_IN
49469: IFFALSE 49563
// if GetDistUnitXY ( j , x , y ) < 30 then
49471: LD_VAR 0 8
49475: PPUSH
49476: LD_VAR 0 2
49480: PPUSH
49481: LD_VAR 0 3
49485: PPUSH
49486: CALL_OW 297
49490: PUSH
49491: LD_INT 30
49493: LESS
49494: IFFALSE 49561
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49496: LD_ADDR_EXP 94
49500: PUSH
49501: LD_EXP 94
49505: PPUSH
49506: LD_VAR 0 7
49510: PUSH
49511: LD_EXP 94
49515: PUSH
49516: LD_VAR 0 7
49520: ARRAY
49521: PUSH
49522: LD_INT 1
49524: PLUS
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PPUSH
49530: LD_VAR 0 4
49534: PUSH
49535: LD_VAR 0 2
49539: PUSH
49540: LD_VAR 0 3
49544: PUSH
49545: EMPTY
49546: LIST
49547: LIST
49548: LIST
49549: PPUSH
49550: CALL 57824 0 3
49554: ST_TO_ADDR
// exit ;
49555: POP
49556: POP
49557: POP
49558: POP
49559: GO 49569
// end ;
49561: GO 49468
49563: POP
49564: POP
// end ;
49565: GO 49276
49567: POP
49568: POP
// end ;
49569: LD_VAR 0 6
49573: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
49574: LD_INT 0
49576: PPUSH
49577: PPUSH
49578: PPUSH
49579: PPUSH
// if not mc_bases or not skirmish then
49580: LD_EXP 78
49584: NOT
49585: PUSH
49586: LD_EXP 76
49590: NOT
49591: OR
49592: IFFALSE 49596
// exit ;
49594: GO 49873
// side := GetSide ( lab ) ;
49596: LD_ADDR_VAR 0 4
49600: PUSH
49601: LD_VAR 0 2
49605: PPUSH
49606: CALL_OW 255
49610: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
49611: LD_VAR 0 4
49615: PUSH
49616: LD_EXP 104
49620: IN
49621: NOT
49622: PUSH
49623: LD_EXP 105
49627: NOT
49628: OR
49629: PUSH
49630: LD_EXP 78
49634: NOT
49635: OR
49636: IFFALSE 49640
// exit ;
49638: GO 49873
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
49640: LD_ADDR_EXP 105
49644: PUSH
49645: LD_EXP 105
49649: PPUSH
49650: LD_VAR 0 4
49654: PPUSH
49655: LD_EXP 105
49659: PUSH
49660: LD_VAR 0 4
49664: ARRAY
49665: PUSH
49666: LD_VAR 0 1
49670: DIFF
49671: PPUSH
49672: CALL_OW 1
49676: ST_TO_ADDR
// for i = 1 to mc_bases do
49677: LD_ADDR_VAR 0 5
49681: PUSH
49682: DOUBLE
49683: LD_INT 1
49685: DEC
49686: ST_TO_ADDR
49687: LD_EXP 78
49691: PUSH
49692: FOR_TO
49693: IFFALSE 49871
// begin if lab in mc_bases [ i ] then
49695: LD_VAR 0 2
49699: PUSH
49700: LD_EXP 78
49704: PUSH
49705: LD_VAR 0 5
49709: ARRAY
49710: IN
49711: IFFALSE 49869
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
49713: LD_VAR 0 1
49717: PUSH
49718: LD_INT 11
49720: PUSH
49721: LD_INT 4
49723: PUSH
49724: LD_INT 3
49726: PUSH
49727: LD_INT 2
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: LIST
49734: LIST
49735: IN
49736: PUSH
49737: LD_EXP 108
49741: PUSH
49742: LD_VAR 0 5
49746: ARRAY
49747: AND
49748: IFFALSE 49869
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
49750: LD_ADDR_VAR 0 6
49754: PUSH
49755: LD_EXP 108
49759: PUSH
49760: LD_VAR 0 5
49764: ARRAY
49765: PUSH
49766: LD_INT 1
49768: ARRAY
49769: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49770: LD_ADDR_EXP 108
49774: PUSH
49775: LD_EXP 108
49779: PPUSH
49780: LD_VAR 0 5
49784: PPUSH
49785: EMPTY
49786: PPUSH
49787: CALL_OW 1
49791: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
49792: LD_VAR 0 6
49796: PPUSH
49797: LD_INT 0
49799: PPUSH
49800: CALL_OW 109
// ComExitBuilding ( tmp ) ;
49804: LD_VAR 0 6
49808: PPUSH
49809: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
49813: LD_ADDR_EXP 107
49817: PUSH
49818: LD_EXP 107
49822: PPUSH
49823: LD_VAR 0 5
49827: PPUSH
49828: LD_EXP 107
49832: PUSH
49833: LD_VAR 0 5
49837: ARRAY
49838: PPUSH
49839: LD_INT 1
49841: PPUSH
49842: LD_VAR 0 6
49846: PPUSH
49847: CALL_OW 2
49851: PPUSH
49852: CALL_OW 1
49856: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49857: LD_VAR 0 5
49861: PPUSH
49862: LD_INT 112
49864: PPUSH
49865: CALL 26323 0 2
// end ; end ; end ;
49869: GO 49692
49871: POP
49872: POP
// end ;
49873: LD_VAR 0 3
49877: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49878: LD_INT 0
49880: PPUSH
49881: PPUSH
49882: PPUSH
49883: PPUSH
49884: PPUSH
49885: PPUSH
49886: PPUSH
49887: PPUSH
// if not mc_bases or not skirmish then
49888: LD_EXP 78
49892: NOT
49893: PUSH
49894: LD_EXP 76
49898: NOT
49899: OR
49900: IFFALSE 49904
// exit ;
49902: GO 51273
// for i = 1 to mc_bases do
49904: LD_ADDR_VAR 0 3
49908: PUSH
49909: DOUBLE
49910: LD_INT 1
49912: DEC
49913: ST_TO_ADDR
49914: LD_EXP 78
49918: PUSH
49919: FOR_TO
49920: IFFALSE 51271
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49922: LD_VAR 0 1
49926: PUSH
49927: LD_EXP 78
49931: PUSH
49932: LD_VAR 0 3
49936: ARRAY
49937: IN
49938: PUSH
49939: LD_VAR 0 1
49943: PUSH
49944: LD_EXP 85
49948: PUSH
49949: LD_VAR 0 3
49953: ARRAY
49954: IN
49955: OR
49956: PUSH
49957: LD_VAR 0 1
49961: PUSH
49962: LD_EXP 100
49966: PUSH
49967: LD_VAR 0 3
49971: ARRAY
49972: IN
49973: OR
49974: PUSH
49975: LD_VAR 0 1
49979: PUSH
49980: LD_EXP 97
49984: PUSH
49985: LD_VAR 0 3
49989: ARRAY
49990: IN
49991: OR
49992: PUSH
49993: LD_VAR 0 1
49997: PUSH
49998: LD_EXP 107
50002: PUSH
50003: LD_VAR 0 3
50007: ARRAY
50008: IN
50009: OR
50010: PUSH
50011: LD_VAR 0 1
50015: PUSH
50016: LD_EXP 108
50020: PUSH
50021: LD_VAR 0 3
50025: ARRAY
50026: IN
50027: OR
50028: IFFALSE 51269
// begin if un in mc_ape [ i ] then
50030: LD_VAR 0 1
50034: PUSH
50035: LD_EXP 107
50039: PUSH
50040: LD_VAR 0 3
50044: ARRAY
50045: IN
50046: IFFALSE 50085
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
50048: LD_ADDR_EXP 107
50052: PUSH
50053: LD_EXP 107
50057: PPUSH
50058: LD_VAR 0 3
50062: PPUSH
50063: LD_EXP 107
50067: PUSH
50068: LD_VAR 0 3
50072: ARRAY
50073: PUSH
50074: LD_VAR 0 1
50078: DIFF
50079: PPUSH
50080: CALL_OW 1
50084: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50085: LD_VAR 0 1
50089: PUSH
50090: LD_EXP 108
50094: PUSH
50095: LD_VAR 0 3
50099: ARRAY
50100: IN
50101: IFFALSE 50125
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50103: LD_ADDR_EXP 108
50107: PUSH
50108: LD_EXP 108
50112: PPUSH
50113: LD_VAR 0 3
50117: PPUSH
50118: EMPTY
50119: PPUSH
50120: CALL_OW 1
50124: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50125: LD_VAR 0 1
50129: PPUSH
50130: CALL_OW 247
50134: PUSH
50135: LD_INT 2
50137: EQUAL
50138: PUSH
50139: LD_VAR 0 1
50143: PPUSH
50144: CALL_OW 110
50148: PUSH
50149: LD_INT 20
50151: EQUAL
50152: PUSH
50153: LD_VAR 0 1
50157: PUSH
50158: LD_EXP 100
50162: PUSH
50163: LD_VAR 0 3
50167: ARRAY
50168: IN
50169: OR
50170: PUSH
50171: LD_VAR 0 1
50175: PPUSH
50176: CALL_OW 264
50180: PUSH
50181: LD_INT 12
50183: PUSH
50184: LD_INT 51
50186: PUSH
50187: LD_INT 89
50189: PUSH
50190: LD_INT 32
50192: PUSH
50193: LD_INT 13
50195: PUSH
50196: LD_INT 52
50198: PUSH
50199: LD_INT 31
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: LIST
50206: LIST
50207: LIST
50208: LIST
50209: LIST
50210: IN
50211: OR
50212: AND
50213: IFFALSE 50521
// begin if un in mc_defender [ i ] then
50215: LD_VAR 0 1
50219: PUSH
50220: LD_EXP 100
50224: PUSH
50225: LD_VAR 0 3
50229: ARRAY
50230: IN
50231: IFFALSE 50270
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50233: LD_ADDR_EXP 100
50237: PUSH
50238: LD_EXP 100
50242: PPUSH
50243: LD_VAR 0 3
50247: PPUSH
50248: LD_EXP 100
50252: PUSH
50253: LD_VAR 0 3
50257: ARRAY
50258: PUSH
50259: LD_VAR 0 1
50263: DIFF
50264: PPUSH
50265: CALL_OW 1
50269: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
50270: LD_ADDR_VAR 0 8
50274: PUSH
50275: LD_VAR 0 3
50279: PPUSH
50280: LD_INT 3
50282: PPUSH
50283: CALL 46891 0 2
50287: ST_TO_ADDR
// if fac then
50288: LD_VAR 0 8
50292: IFFALSE 50521
// begin for j in fac do
50294: LD_ADDR_VAR 0 4
50298: PUSH
50299: LD_VAR 0 8
50303: PUSH
50304: FOR_IN
50305: IFFALSE 50519
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
50307: LD_ADDR_VAR 0 9
50311: PUSH
50312: LD_VAR 0 8
50316: PPUSH
50317: LD_VAR 0 1
50321: PPUSH
50322: CALL_OW 265
50326: PPUSH
50327: LD_VAR 0 1
50331: PPUSH
50332: CALL_OW 262
50336: PPUSH
50337: LD_VAR 0 1
50341: PPUSH
50342: CALL_OW 263
50346: PPUSH
50347: LD_VAR 0 1
50351: PPUSH
50352: CALL_OW 264
50356: PPUSH
50357: CALL 55322 0 5
50361: ST_TO_ADDR
// if components then
50362: LD_VAR 0 9
50366: IFFALSE 50517
// begin if GetWeapon ( un ) = ar_control_tower then
50368: LD_VAR 0 1
50372: PPUSH
50373: CALL_OW 264
50377: PUSH
50378: LD_INT 31
50380: EQUAL
50381: IFFALSE 50498
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
50383: LD_VAR 0 1
50387: PPUSH
50388: CALL_OW 311
50392: PPUSH
50393: LD_INT 0
50395: PPUSH
50396: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
50400: LD_ADDR_EXP 118
50404: PUSH
50405: LD_EXP 118
50409: PPUSH
50410: LD_VAR 0 3
50414: PPUSH
50415: LD_EXP 118
50419: PUSH
50420: LD_VAR 0 3
50424: ARRAY
50425: PUSH
50426: LD_VAR 0 1
50430: PPUSH
50431: CALL_OW 311
50435: DIFF
50436: PPUSH
50437: CALL_OW 1
50441: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
50442: LD_ADDR_VAR 0 7
50446: PUSH
50447: LD_EXP 99
50451: PUSH
50452: LD_VAR 0 3
50456: ARRAY
50457: PPUSH
50458: LD_INT 1
50460: PPUSH
50461: LD_VAR 0 9
50465: PPUSH
50466: CALL_OW 2
50470: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50471: LD_ADDR_EXP 99
50475: PUSH
50476: LD_EXP 99
50480: PPUSH
50481: LD_VAR 0 3
50485: PPUSH
50486: LD_VAR 0 7
50490: PPUSH
50491: CALL_OW 1
50495: ST_TO_ADDR
// end else
50496: GO 50515
// MC_InsertProduceList ( i , [ components ] ) ;
50498: LD_VAR 0 3
50502: PPUSH
50503: LD_VAR 0 9
50507: PUSH
50508: EMPTY
50509: LIST
50510: PPUSH
50511: CALL 46436 0 2
// break ;
50515: GO 50519
// end ; end ;
50517: GO 50304
50519: POP
50520: POP
// end ; end ; if GetType ( un ) = unit_building then
50521: LD_VAR 0 1
50525: PPUSH
50526: CALL_OW 247
50530: PUSH
50531: LD_INT 3
50533: EQUAL
50534: IFFALSE 50937
// begin btype := GetBType ( un ) ;
50536: LD_ADDR_VAR 0 5
50540: PUSH
50541: LD_VAR 0 1
50545: PPUSH
50546: CALL_OW 266
50550: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
50551: LD_VAR 0 5
50555: PUSH
50556: LD_INT 29
50558: PUSH
50559: LD_INT 30
50561: PUSH
50562: EMPTY
50563: LIST
50564: LIST
50565: IN
50566: IFFALSE 50639
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
50568: LD_VAR 0 1
50572: PPUSH
50573: CALL_OW 250
50577: PPUSH
50578: LD_VAR 0 1
50582: PPUSH
50583: CALL_OW 251
50587: PPUSH
50588: LD_VAR 0 1
50592: PPUSH
50593: CALL_OW 255
50597: PPUSH
50598: CALL_OW 440
50602: NOT
50603: IFFALSE 50639
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
50605: LD_VAR 0 1
50609: PPUSH
50610: CALL_OW 250
50614: PPUSH
50615: LD_VAR 0 1
50619: PPUSH
50620: CALL_OW 251
50624: PPUSH
50625: LD_VAR 0 1
50629: PPUSH
50630: CALL_OW 255
50634: PPUSH
50635: CALL_OW 441
// end ; if btype = b_warehouse then
50639: LD_VAR 0 5
50643: PUSH
50644: LD_INT 1
50646: EQUAL
50647: IFFALSE 50665
// begin btype := b_depot ;
50649: LD_ADDR_VAR 0 5
50653: PUSH
50654: LD_INT 0
50656: ST_TO_ADDR
// pos := 1 ;
50657: LD_ADDR_VAR 0 6
50661: PUSH
50662: LD_INT 1
50664: ST_TO_ADDR
// end ; if btype = b_factory then
50665: LD_VAR 0 5
50669: PUSH
50670: LD_INT 3
50672: EQUAL
50673: IFFALSE 50691
// begin btype := b_workshop ;
50675: LD_ADDR_VAR 0 5
50679: PUSH
50680: LD_INT 2
50682: ST_TO_ADDR
// pos := 1 ;
50683: LD_ADDR_VAR 0 6
50687: PUSH
50688: LD_INT 1
50690: ST_TO_ADDR
// end ; if btype = b_barracks then
50691: LD_VAR 0 5
50695: PUSH
50696: LD_INT 5
50698: EQUAL
50699: IFFALSE 50709
// btype := b_armoury ;
50701: LD_ADDR_VAR 0 5
50705: PUSH
50706: LD_INT 4
50708: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
50709: LD_VAR 0 5
50713: PUSH
50714: LD_INT 7
50716: PUSH
50717: LD_INT 8
50719: PUSH
50720: EMPTY
50721: LIST
50722: LIST
50723: IN
50724: IFFALSE 50734
// btype := b_lab ;
50726: LD_ADDR_VAR 0 5
50730: PUSH
50731: LD_INT 6
50733: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
50734: LD_ADDR_EXP 83
50738: PUSH
50739: LD_EXP 83
50743: PPUSH
50744: LD_VAR 0 3
50748: PUSH
50749: LD_EXP 83
50753: PUSH
50754: LD_VAR 0 3
50758: ARRAY
50759: PUSH
50760: LD_INT 1
50762: PLUS
50763: PUSH
50764: EMPTY
50765: LIST
50766: LIST
50767: PPUSH
50768: LD_VAR 0 5
50772: PUSH
50773: LD_VAR 0 1
50777: PPUSH
50778: CALL_OW 250
50782: PUSH
50783: LD_VAR 0 1
50787: PPUSH
50788: CALL_OW 251
50792: PUSH
50793: LD_VAR 0 1
50797: PPUSH
50798: CALL_OW 254
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: LIST
50807: LIST
50808: PPUSH
50809: CALL 57824 0 3
50813: ST_TO_ADDR
// if pos = 1 then
50814: LD_VAR 0 6
50818: PUSH
50819: LD_INT 1
50821: EQUAL
50822: IFFALSE 50937
// begin tmp := mc_build_list [ i ] ;
50824: LD_ADDR_VAR 0 7
50828: PUSH
50829: LD_EXP 83
50833: PUSH
50834: LD_VAR 0 3
50838: ARRAY
50839: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50840: LD_VAR 0 7
50844: PPUSH
50845: LD_INT 2
50847: PUSH
50848: LD_INT 30
50850: PUSH
50851: LD_INT 0
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: PUSH
50858: LD_INT 30
50860: PUSH
50861: LD_INT 1
50863: PUSH
50864: EMPTY
50865: LIST
50866: LIST
50867: PUSH
50868: EMPTY
50869: LIST
50870: LIST
50871: LIST
50872: PPUSH
50873: CALL_OW 72
50877: IFFALSE 50887
// pos := 2 ;
50879: LD_ADDR_VAR 0 6
50883: PUSH
50884: LD_INT 2
50886: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50887: LD_ADDR_VAR 0 7
50891: PUSH
50892: LD_VAR 0 7
50896: PPUSH
50897: LD_VAR 0 6
50901: PPUSH
50902: LD_VAR 0 7
50906: PPUSH
50907: CALL 58150 0 3
50911: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50912: LD_ADDR_EXP 83
50916: PUSH
50917: LD_EXP 83
50921: PPUSH
50922: LD_VAR 0 3
50926: PPUSH
50927: LD_VAR 0 7
50931: PPUSH
50932: CALL_OW 1
50936: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50937: LD_VAR 0 1
50941: PUSH
50942: LD_EXP 78
50946: PUSH
50947: LD_VAR 0 3
50951: ARRAY
50952: IN
50953: IFFALSE 50992
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50955: LD_ADDR_EXP 78
50959: PUSH
50960: LD_EXP 78
50964: PPUSH
50965: LD_VAR 0 3
50969: PPUSH
50970: LD_EXP 78
50974: PUSH
50975: LD_VAR 0 3
50979: ARRAY
50980: PUSH
50981: LD_VAR 0 1
50985: DIFF
50986: PPUSH
50987: CALL_OW 1
50991: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50992: LD_VAR 0 1
50996: PUSH
50997: LD_EXP 85
51001: PUSH
51002: LD_VAR 0 3
51006: ARRAY
51007: IN
51008: IFFALSE 51047
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
51010: LD_ADDR_EXP 85
51014: PUSH
51015: LD_EXP 85
51019: PPUSH
51020: LD_VAR 0 3
51024: PPUSH
51025: LD_EXP 85
51029: PUSH
51030: LD_VAR 0 3
51034: ARRAY
51035: PUSH
51036: LD_VAR 0 1
51040: DIFF
51041: PPUSH
51042: CALL_OW 1
51046: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
51047: LD_VAR 0 1
51051: PUSH
51052: LD_EXP 97
51056: PUSH
51057: LD_VAR 0 3
51061: ARRAY
51062: IN
51063: IFFALSE 51102
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51065: LD_ADDR_EXP 97
51069: PUSH
51070: LD_EXP 97
51074: PPUSH
51075: LD_VAR 0 3
51079: PPUSH
51080: LD_EXP 97
51084: PUSH
51085: LD_VAR 0 3
51089: ARRAY
51090: PUSH
51091: LD_VAR 0 1
51095: DIFF
51096: PPUSH
51097: CALL_OW 1
51101: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51102: LD_VAR 0 1
51106: PUSH
51107: LD_EXP 100
51111: PUSH
51112: LD_VAR 0 3
51116: ARRAY
51117: IN
51118: IFFALSE 51157
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51120: LD_ADDR_EXP 100
51124: PUSH
51125: LD_EXP 100
51129: PPUSH
51130: LD_VAR 0 3
51134: PPUSH
51135: LD_EXP 100
51139: PUSH
51140: LD_VAR 0 3
51144: ARRAY
51145: PUSH
51146: LD_VAR 0 1
51150: DIFF
51151: PPUSH
51152: CALL_OW 1
51156: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
51157: LD_VAR 0 1
51161: PUSH
51162: LD_EXP 87
51166: PUSH
51167: LD_VAR 0 3
51171: ARRAY
51172: IN
51173: IFFALSE 51212
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
51175: LD_ADDR_EXP 87
51179: PUSH
51180: LD_EXP 87
51184: PPUSH
51185: LD_VAR 0 3
51189: PPUSH
51190: LD_EXP 87
51194: PUSH
51195: LD_VAR 0 3
51199: ARRAY
51200: PUSH
51201: LD_VAR 0 1
51205: DIFF
51206: PPUSH
51207: CALL_OW 1
51211: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
51212: LD_VAR 0 1
51216: PUSH
51217: LD_EXP 86
51221: PUSH
51222: LD_VAR 0 3
51226: ARRAY
51227: IN
51228: IFFALSE 51267
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
51230: LD_ADDR_EXP 86
51234: PUSH
51235: LD_EXP 86
51239: PPUSH
51240: LD_VAR 0 3
51244: PPUSH
51245: LD_EXP 86
51249: PUSH
51250: LD_VAR 0 3
51254: ARRAY
51255: PUSH
51256: LD_VAR 0 1
51260: DIFF
51261: PPUSH
51262: CALL_OW 1
51266: ST_TO_ADDR
// end ; break ;
51267: GO 51271
// end ;
51269: GO 49919
51271: POP
51272: POP
// end ;
51273: LD_VAR 0 2
51277: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
51278: LD_INT 0
51280: PPUSH
51281: PPUSH
51282: PPUSH
// if not mc_bases or not skirmish then
51283: LD_EXP 78
51287: NOT
51288: PUSH
51289: LD_EXP 76
51293: NOT
51294: OR
51295: IFFALSE 51299
// exit ;
51297: GO 51514
// for i = 1 to mc_bases do
51299: LD_ADDR_VAR 0 3
51303: PUSH
51304: DOUBLE
51305: LD_INT 1
51307: DEC
51308: ST_TO_ADDR
51309: LD_EXP 78
51313: PUSH
51314: FOR_TO
51315: IFFALSE 51512
// begin if building in mc_construct_list [ i ] then
51317: LD_VAR 0 1
51321: PUSH
51322: LD_EXP 85
51326: PUSH
51327: LD_VAR 0 3
51331: ARRAY
51332: IN
51333: IFFALSE 51510
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51335: LD_ADDR_EXP 85
51339: PUSH
51340: LD_EXP 85
51344: PPUSH
51345: LD_VAR 0 3
51349: PPUSH
51350: LD_EXP 85
51354: PUSH
51355: LD_VAR 0 3
51359: ARRAY
51360: PUSH
51361: LD_VAR 0 1
51365: DIFF
51366: PPUSH
51367: CALL_OW 1
51371: ST_TO_ADDR
// if building in mc_lab [ i ] then
51372: LD_VAR 0 1
51376: PUSH
51377: LD_EXP 111
51381: PUSH
51382: LD_VAR 0 3
51386: ARRAY
51387: IN
51388: IFFALSE 51443
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
51390: LD_ADDR_EXP 112
51394: PUSH
51395: LD_EXP 112
51399: PPUSH
51400: LD_VAR 0 3
51404: PPUSH
51405: LD_EXP 112
51409: PUSH
51410: LD_VAR 0 3
51414: ARRAY
51415: PPUSH
51416: LD_INT 1
51418: PPUSH
51419: LD_EXP 112
51423: PUSH
51424: LD_VAR 0 3
51428: ARRAY
51429: PPUSH
51430: LD_INT 0
51432: PPUSH
51433: CALL 57242 0 4
51437: PPUSH
51438: CALL_OW 1
51442: ST_TO_ADDR
// if not building in mc_bases [ i ] then
51443: LD_VAR 0 1
51447: PUSH
51448: LD_EXP 78
51452: PUSH
51453: LD_VAR 0 3
51457: ARRAY
51458: IN
51459: NOT
51460: IFFALSE 51506
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51462: LD_ADDR_EXP 78
51466: PUSH
51467: LD_EXP 78
51471: PPUSH
51472: LD_VAR 0 3
51476: PUSH
51477: LD_EXP 78
51481: PUSH
51482: LD_VAR 0 3
51486: ARRAY
51487: PUSH
51488: LD_INT 1
51490: PLUS
51491: PUSH
51492: EMPTY
51493: LIST
51494: LIST
51495: PPUSH
51496: LD_VAR 0 1
51500: PPUSH
51501: CALL 57824 0 3
51505: ST_TO_ADDR
// exit ;
51506: POP
51507: POP
51508: GO 51514
// end ; end ;
51510: GO 51314
51512: POP
51513: POP
// end ;
51514: LD_VAR 0 2
51518: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
51519: LD_INT 0
51521: PPUSH
51522: PPUSH
51523: PPUSH
51524: PPUSH
51525: PPUSH
51526: PPUSH
51527: PPUSH
// if not mc_bases or not skirmish then
51528: LD_EXP 78
51532: NOT
51533: PUSH
51534: LD_EXP 76
51538: NOT
51539: OR
51540: IFFALSE 51544
// exit ;
51542: GO 52205
// for i = 1 to mc_bases do
51544: LD_ADDR_VAR 0 3
51548: PUSH
51549: DOUBLE
51550: LD_INT 1
51552: DEC
51553: ST_TO_ADDR
51554: LD_EXP 78
51558: PUSH
51559: FOR_TO
51560: IFFALSE 52203
// begin if building in mc_construct_list [ i ] then
51562: LD_VAR 0 1
51566: PUSH
51567: LD_EXP 85
51571: PUSH
51572: LD_VAR 0 3
51576: ARRAY
51577: IN
51578: IFFALSE 52201
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51580: LD_ADDR_EXP 85
51584: PUSH
51585: LD_EXP 85
51589: PPUSH
51590: LD_VAR 0 3
51594: PPUSH
51595: LD_EXP 85
51599: PUSH
51600: LD_VAR 0 3
51604: ARRAY
51605: PUSH
51606: LD_VAR 0 1
51610: DIFF
51611: PPUSH
51612: CALL_OW 1
51616: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51617: LD_ADDR_EXP 78
51621: PUSH
51622: LD_EXP 78
51626: PPUSH
51627: LD_VAR 0 3
51631: PUSH
51632: LD_EXP 78
51636: PUSH
51637: LD_VAR 0 3
51641: ARRAY
51642: PUSH
51643: LD_INT 1
51645: PLUS
51646: PUSH
51647: EMPTY
51648: LIST
51649: LIST
51650: PPUSH
51651: LD_VAR 0 1
51655: PPUSH
51656: CALL 57824 0 3
51660: ST_TO_ADDR
// btype := GetBType ( building ) ;
51661: LD_ADDR_VAR 0 5
51665: PUSH
51666: LD_VAR 0 1
51670: PPUSH
51671: CALL_OW 266
51675: ST_TO_ADDR
// side := GetSide ( building ) ;
51676: LD_ADDR_VAR 0 8
51680: PUSH
51681: LD_VAR 0 1
51685: PPUSH
51686: CALL_OW 255
51690: ST_TO_ADDR
// if btype = b_lab then
51691: LD_VAR 0 5
51695: PUSH
51696: LD_INT 6
51698: EQUAL
51699: IFFALSE 51749
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
51701: LD_ADDR_EXP 111
51705: PUSH
51706: LD_EXP 111
51710: PPUSH
51711: LD_VAR 0 3
51715: PUSH
51716: LD_EXP 111
51720: PUSH
51721: LD_VAR 0 3
51725: ARRAY
51726: PUSH
51727: LD_INT 1
51729: PLUS
51730: PUSH
51731: EMPTY
51732: LIST
51733: LIST
51734: PPUSH
51735: LD_VAR 0 1
51739: PPUSH
51740: CALL 57824 0 3
51744: ST_TO_ADDR
// exit ;
51745: POP
51746: POP
51747: GO 52205
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
51749: LD_VAR 0 5
51753: PUSH
51754: LD_INT 0
51756: PUSH
51757: LD_INT 2
51759: PUSH
51760: LD_INT 4
51762: PUSH
51763: EMPTY
51764: LIST
51765: LIST
51766: LIST
51767: IN
51768: IFFALSE 51892
// begin if btype = b_armoury then
51770: LD_VAR 0 5
51774: PUSH
51775: LD_INT 4
51777: EQUAL
51778: IFFALSE 51788
// btype := b_barracks ;
51780: LD_ADDR_VAR 0 5
51784: PUSH
51785: LD_INT 5
51787: ST_TO_ADDR
// if btype = b_depot then
51788: LD_VAR 0 5
51792: PUSH
51793: LD_INT 0
51795: EQUAL
51796: IFFALSE 51806
// btype := b_warehouse ;
51798: LD_ADDR_VAR 0 5
51802: PUSH
51803: LD_INT 1
51805: ST_TO_ADDR
// if btype = b_workshop then
51806: LD_VAR 0 5
51810: PUSH
51811: LD_INT 2
51813: EQUAL
51814: IFFALSE 51824
// btype := b_factory ;
51816: LD_ADDR_VAR 0 5
51820: PUSH
51821: LD_INT 3
51823: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
51824: LD_VAR 0 5
51828: PPUSH
51829: LD_VAR 0 8
51833: PPUSH
51834: CALL_OW 323
51838: PUSH
51839: LD_INT 1
51841: EQUAL
51842: IFFALSE 51888
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51844: LD_ADDR_EXP 110
51848: PUSH
51849: LD_EXP 110
51853: PPUSH
51854: LD_VAR 0 3
51858: PUSH
51859: LD_EXP 110
51863: PUSH
51864: LD_VAR 0 3
51868: ARRAY
51869: PUSH
51870: LD_INT 1
51872: PLUS
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: PPUSH
51878: LD_VAR 0 1
51882: PPUSH
51883: CALL 57824 0 3
51887: ST_TO_ADDR
// exit ;
51888: POP
51889: POP
51890: GO 52205
// end ; if btype in [ b_bunker , b_turret ] then
51892: LD_VAR 0 5
51896: PUSH
51897: LD_INT 32
51899: PUSH
51900: LD_INT 33
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: IN
51907: IFFALSE 52197
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51909: LD_ADDR_EXP 86
51913: PUSH
51914: LD_EXP 86
51918: PPUSH
51919: LD_VAR 0 3
51923: PUSH
51924: LD_EXP 86
51928: PUSH
51929: LD_VAR 0 3
51933: ARRAY
51934: PUSH
51935: LD_INT 1
51937: PLUS
51938: PUSH
51939: EMPTY
51940: LIST
51941: LIST
51942: PPUSH
51943: LD_VAR 0 1
51947: PPUSH
51948: CALL 57824 0 3
51952: ST_TO_ADDR
// if btype = b_bunker then
51953: LD_VAR 0 5
51957: PUSH
51958: LD_INT 32
51960: EQUAL
51961: IFFALSE 52197
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51963: LD_ADDR_EXP 87
51967: PUSH
51968: LD_EXP 87
51972: PPUSH
51973: LD_VAR 0 3
51977: PUSH
51978: LD_EXP 87
51982: PUSH
51983: LD_VAR 0 3
51987: ARRAY
51988: PUSH
51989: LD_INT 1
51991: PLUS
51992: PUSH
51993: EMPTY
51994: LIST
51995: LIST
51996: PPUSH
51997: LD_VAR 0 1
52001: PPUSH
52002: CALL 57824 0 3
52006: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
52007: LD_ADDR_VAR 0 6
52011: PUSH
52012: LD_EXP 78
52016: PUSH
52017: LD_VAR 0 3
52021: ARRAY
52022: PPUSH
52023: LD_INT 25
52025: PUSH
52026: LD_INT 1
52028: PUSH
52029: EMPTY
52030: LIST
52031: LIST
52032: PUSH
52033: LD_INT 3
52035: PUSH
52036: LD_INT 54
52038: PUSH
52039: EMPTY
52040: LIST
52041: PUSH
52042: EMPTY
52043: LIST
52044: LIST
52045: PUSH
52046: EMPTY
52047: LIST
52048: LIST
52049: PPUSH
52050: CALL_OW 72
52054: ST_TO_ADDR
// if tmp then
52055: LD_VAR 0 6
52059: IFFALSE 52065
// exit ;
52061: POP
52062: POP
52063: GO 52205
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52065: LD_ADDR_VAR 0 6
52069: PUSH
52070: LD_EXP 78
52074: PUSH
52075: LD_VAR 0 3
52079: ARRAY
52080: PPUSH
52081: LD_INT 2
52083: PUSH
52084: LD_INT 30
52086: PUSH
52087: LD_INT 4
52089: PUSH
52090: EMPTY
52091: LIST
52092: LIST
52093: PUSH
52094: LD_INT 30
52096: PUSH
52097: LD_INT 5
52099: PUSH
52100: EMPTY
52101: LIST
52102: LIST
52103: PUSH
52104: EMPTY
52105: LIST
52106: LIST
52107: LIST
52108: PPUSH
52109: CALL_OW 72
52113: ST_TO_ADDR
// if not tmp then
52114: LD_VAR 0 6
52118: NOT
52119: IFFALSE 52125
// exit ;
52121: POP
52122: POP
52123: GO 52205
// for j in tmp do
52125: LD_ADDR_VAR 0 4
52129: PUSH
52130: LD_VAR 0 6
52134: PUSH
52135: FOR_IN
52136: IFFALSE 52195
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
52138: LD_ADDR_VAR 0 7
52142: PUSH
52143: LD_VAR 0 4
52147: PPUSH
52148: CALL_OW 313
52152: PPUSH
52153: LD_INT 25
52155: PUSH
52156: LD_INT 1
52158: PUSH
52159: EMPTY
52160: LIST
52161: LIST
52162: PPUSH
52163: CALL_OW 72
52167: ST_TO_ADDR
// if units then
52168: LD_VAR 0 7
52172: IFFALSE 52193
// begin ComExitBuilding ( units [ 1 ] ) ;
52174: LD_VAR 0 7
52178: PUSH
52179: LD_INT 1
52181: ARRAY
52182: PPUSH
52183: CALL_OW 122
// exit ;
52187: POP
52188: POP
52189: POP
52190: POP
52191: GO 52205
// end ; end ;
52193: GO 52135
52195: POP
52196: POP
// end ; end ; exit ;
52197: POP
52198: POP
52199: GO 52205
// end ; end ;
52201: GO 51559
52203: POP
52204: POP
// end ;
52205: LD_VAR 0 2
52209: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
52210: LD_INT 0
52212: PPUSH
52213: PPUSH
52214: PPUSH
52215: PPUSH
52216: PPUSH
52217: PPUSH
52218: PPUSH
// if not mc_bases or not skirmish then
52219: LD_EXP 78
52223: NOT
52224: PUSH
52225: LD_EXP 76
52229: NOT
52230: OR
52231: IFFALSE 52235
// exit ;
52233: GO 52500
// btype := GetBType ( building ) ;
52235: LD_ADDR_VAR 0 6
52239: PUSH
52240: LD_VAR 0 1
52244: PPUSH
52245: CALL_OW 266
52249: ST_TO_ADDR
// x := GetX ( building ) ;
52250: LD_ADDR_VAR 0 7
52254: PUSH
52255: LD_VAR 0 1
52259: PPUSH
52260: CALL_OW 250
52264: ST_TO_ADDR
// y := GetY ( building ) ;
52265: LD_ADDR_VAR 0 8
52269: PUSH
52270: LD_VAR 0 1
52274: PPUSH
52275: CALL_OW 251
52279: ST_TO_ADDR
// d := GetDir ( building ) ;
52280: LD_ADDR_VAR 0 9
52284: PUSH
52285: LD_VAR 0 1
52289: PPUSH
52290: CALL_OW 254
52294: ST_TO_ADDR
// for i = 1 to mc_bases do
52295: LD_ADDR_VAR 0 4
52299: PUSH
52300: DOUBLE
52301: LD_INT 1
52303: DEC
52304: ST_TO_ADDR
52305: LD_EXP 78
52309: PUSH
52310: FOR_TO
52311: IFFALSE 52498
// begin if not mc_build_list [ i ] then
52313: LD_EXP 83
52317: PUSH
52318: LD_VAR 0 4
52322: ARRAY
52323: NOT
52324: IFFALSE 52328
// continue ;
52326: GO 52310
// for j := 1 to mc_build_list [ i ] do
52328: LD_ADDR_VAR 0 5
52332: PUSH
52333: DOUBLE
52334: LD_INT 1
52336: DEC
52337: ST_TO_ADDR
52338: LD_EXP 83
52342: PUSH
52343: LD_VAR 0 4
52347: ARRAY
52348: PUSH
52349: FOR_TO
52350: IFFALSE 52494
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
52352: LD_VAR 0 6
52356: PUSH
52357: LD_VAR 0 7
52361: PUSH
52362: LD_VAR 0 8
52366: PUSH
52367: LD_VAR 0 9
52371: PUSH
52372: EMPTY
52373: LIST
52374: LIST
52375: LIST
52376: LIST
52377: PPUSH
52378: LD_EXP 83
52382: PUSH
52383: LD_VAR 0 4
52387: ARRAY
52388: PUSH
52389: LD_VAR 0 5
52393: ARRAY
52394: PPUSH
52395: CALL 64381 0 2
52399: IFFALSE 52492
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
52401: LD_ADDR_EXP 83
52405: PUSH
52406: LD_EXP 83
52410: PPUSH
52411: LD_VAR 0 4
52415: PPUSH
52416: LD_EXP 83
52420: PUSH
52421: LD_VAR 0 4
52425: ARRAY
52426: PPUSH
52427: LD_VAR 0 5
52431: PPUSH
52432: CALL_OW 3
52436: PPUSH
52437: CALL_OW 1
52441: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
52442: LD_ADDR_EXP 85
52446: PUSH
52447: LD_EXP 85
52451: PPUSH
52452: LD_VAR 0 4
52456: PUSH
52457: LD_EXP 85
52461: PUSH
52462: LD_VAR 0 4
52466: ARRAY
52467: PUSH
52468: LD_INT 1
52470: PLUS
52471: PUSH
52472: EMPTY
52473: LIST
52474: LIST
52475: PPUSH
52476: LD_VAR 0 1
52480: PPUSH
52481: CALL 57824 0 3
52485: ST_TO_ADDR
// exit ;
52486: POP
52487: POP
52488: POP
52489: POP
52490: GO 52500
// end ;
52492: GO 52349
52494: POP
52495: POP
// end ;
52496: GO 52310
52498: POP
52499: POP
// end ;
52500: LD_VAR 0 3
52504: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
52505: LD_INT 0
52507: PPUSH
52508: PPUSH
52509: PPUSH
// if not mc_bases or not skirmish then
52510: LD_EXP 78
52514: NOT
52515: PUSH
52516: LD_EXP 76
52520: NOT
52521: OR
52522: IFFALSE 52526
// exit ;
52524: GO 52716
// for i = 1 to mc_bases do
52526: LD_ADDR_VAR 0 4
52530: PUSH
52531: DOUBLE
52532: LD_INT 1
52534: DEC
52535: ST_TO_ADDR
52536: LD_EXP 78
52540: PUSH
52541: FOR_TO
52542: IFFALSE 52629
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
52544: LD_VAR 0 1
52548: PUSH
52549: LD_EXP 86
52553: PUSH
52554: LD_VAR 0 4
52558: ARRAY
52559: IN
52560: PUSH
52561: LD_VAR 0 1
52565: PUSH
52566: LD_EXP 87
52570: PUSH
52571: LD_VAR 0 4
52575: ARRAY
52576: IN
52577: NOT
52578: AND
52579: IFFALSE 52627
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52581: LD_ADDR_EXP 87
52585: PUSH
52586: LD_EXP 87
52590: PPUSH
52591: LD_VAR 0 4
52595: PUSH
52596: LD_EXP 87
52600: PUSH
52601: LD_VAR 0 4
52605: ARRAY
52606: PUSH
52607: LD_INT 1
52609: PLUS
52610: PUSH
52611: EMPTY
52612: LIST
52613: LIST
52614: PPUSH
52615: LD_VAR 0 1
52619: PPUSH
52620: CALL 57824 0 3
52624: ST_TO_ADDR
// break ;
52625: GO 52629
// end ; end ;
52627: GO 52541
52629: POP
52630: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
52631: LD_VAR 0 1
52635: PPUSH
52636: CALL_OW 257
52640: PUSH
52641: LD_EXP 104
52645: IN
52646: PUSH
52647: LD_VAR 0 1
52651: PPUSH
52652: CALL_OW 266
52656: PUSH
52657: LD_INT 5
52659: EQUAL
52660: AND
52661: PUSH
52662: LD_VAR 0 2
52666: PPUSH
52667: CALL_OW 110
52671: PUSH
52672: LD_INT 18
52674: NONEQUAL
52675: AND
52676: IFFALSE 52716
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
52678: LD_VAR 0 2
52682: PPUSH
52683: CALL_OW 257
52687: PUSH
52688: LD_INT 5
52690: PUSH
52691: LD_INT 8
52693: PUSH
52694: LD_INT 9
52696: PUSH
52697: EMPTY
52698: LIST
52699: LIST
52700: LIST
52701: IN
52702: IFFALSE 52716
// SetClass ( unit , 1 ) ;
52704: LD_VAR 0 2
52708: PPUSH
52709: LD_INT 1
52711: PPUSH
52712: CALL_OW 336
// end ;
52716: LD_VAR 0 3
52720: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
52721: LD_INT 0
52723: PPUSH
52724: PPUSH
// if not mc_bases or not skirmish then
52725: LD_EXP 78
52729: NOT
52730: PUSH
52731: LD_EXP 76
52735: NOT
52736: OR
52737: IFFALSE 52741
// exit ;
52739: GO 52857
// if GetLives ( abandoned_vehicle ) > 250 then
52741: LD_VAR 0 2
52745: PPUSH
52746: CALL_OW 256
52750: PUSH
52751: LD_INT 250
52753: GREATER
52754: IFFALSE 52758
// exit ;
52756: GO 52857
// for i = 1 to mc_bases do
52758: LD_ADDR_VAR 0 6
52762: PUSH
52763: DOUBLE
52764: LD_INT 1
52766: DEC
52767: ST_TO_ADDR
52768: LD_EXP 78
52772: PUSH
52773: FOR_TO
52774: IFFALSE 52855
// begin if driver in mc_bases [ i ] then
52776: LD_VAR 0 1
52780: PUSH
52781: LD_EXP 78
52785: PUSH
52786: LD_VAR 0 6
52790: ARRAY
52791: IN
52792: IFFALSE 52853
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
52794: LD_VAR 0 1
52798: PPUSH
52799: LD_EXP 78
52803: PUSH
52804: LD_VAR 0 6
52808: ARRAY
52809: PPUSH
52810: LD_INT 2
52812: PUSH
52813: LD_INT 30
52815: PUSH
52816: LD_INT 0
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: PUSH
52823: LD_INT 30
52825: PUSH
52826: LD_INT 1
52828: PUSH
52829: EMPTY
52830: LIST
52831: LIST
52832: PUSH
52833: EMPTY
52834: LIST
52835: LIST
52836: LIST
52837: PPUSH
52838: CALL_OW 72
52842: PUSH
52843: LD_INT 1
52845: ARRAY
52846: PPUSH
52847: CALL 91441 0 2
// break ;
52851: GO 52855
// end ; end ;
52853: GO 52773
52855: POP
52856: POP
// end ; end_of_file
52857: LD_VAR 0 5
52861: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52862: LD_INT 0
52864: PPUSH
52865: PPUSH
// if exist_mode then
52866: LD_VAR 0 2
52870: IFFALSE 52895
// unit := CreateCharacter ( prefix & ident ) else
52872: LD_ADDR_VAR 0 5
52876: PUSH
52877: LD_VAR 0 3
52881: PUSH
52882: LD_VAR 0 1
52886: STR
52887: PPUSH
52888: CALL_OW 34
52892: ST_TO_ADDR
52893: GO 52910
// unit := NewCharacter ( ident ) ;
52895: LD_ADDR_VAR 0 5
52899: PUSH
52900: LD_VAR 0 1
52904: PPUSH
52905: CALL_OW 25
52909: ST_TO_ADDR
// result := unit ;
52910: LD_ADDR_VAR 0 4
52914: PUSH
52915: LD_VAR 0 5
52919: ST_TO_ADDR
// end ;
52920: LD_VAR 0 4
52924: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52925: LD_INT 0
52927: PPUSH
52928: PPUSH
// if not side or not nation then
52929: LD_VAR 0 1
52933: NOT
52934: PUSH
52935: LD_VAR 0 2
52939: NOT
52940: OR
52941: IFFALSE 52945
// exit ;
52943: GO 53713
// case nation of nation_american :
52945: LD_VAR 0 2
52949: PUSH
52950: LD_INT 1
52952: DOUBLE
52953: EQUAL
52954: IFTRUE 52958
52956: GO 53172
52958: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52959: LD_ADDR_VAR 0 4
52963: PUSH
52964: LD_INT 35
52966: PUSH
52967: LD_INT 45
52969: PUSH
52970: LD_INT 46
52972: PUSH
52973: LD_INT 47
52975: PUSH
52976: LD_INT 82
52978: PUSH
52979: LD_INT 83
52981: PUSH
52982: LD_INT 84
52984: PUSH
52985: LD_INT 85
52987: PUSH
52988: LD_INT 86
52990: PUSH
52991: LD_INT 1
52993: PUSH
52994: LD_INT 2
52996: PUSH
52997: LD_INT 6
52999: PUSH
53000: LD_INT 15
53002: PUSH
53003: LD_INT 16
53005: PUSH
53006: LD_INT 7
53008: PUSH
53009: LD_INT 12
53011: PUSH
53012: LD_INT 13
53014: PUSH
53015: LD_INT 10
53017: PUSH
53018: LD_INT 14
53020: PUSH
53021: LD_INT 20
53023: PUSH
53024: LD_INT 21
53026: PUSH
53027: LD_INT 22
53029: PUSH
53030: LD_INT 25
53032: PUSH
53033: LD_INT 32
53035: PUSH
53036: LD_INT 27
53038: PUSH
53039: LD_INT 36
53041: PUSH
53042: LD_INT 69
53044: PUSH
53045: LD_INT 39
53047: PUSH
53048: LD_INT 34
53050: PUSH
53051: LD_INT 40
53053: PUSH
53054: LD_INT 48
53056: PUSH
53057: LD_INT 49
53059: PUSH
53060: LD_INT 50
53062: PUSH
53063: LD_INT 51
53065: PUSH
53066: LD_INT 52
53068: PUSH
53069: LD_INT 53
53071: PUSH
53072: LD_INT 54
53074: PUSH
53075: LD_INT 55
53077: PUSH
53078: LD_INT 56
53080: PUSH
53081: LD_INT 57
53083: PUSH
53084: LD_INT 58
53086: PUSH
53087: LD_INT 59
53089: PUSH
53090: LD_INT 60
53092: PUSH
53093: LD_INT 61
53095: PUSH
53096: LD_INT 62
53098: PUSH
53099: LD_INT 80
53101: PUSH
53102: LD_INT 82
53104: PUSH
53105: LD_INT 83
53107: PUSH
53108: LD_INT 84
53110: PUSH
53111: LD_INT 85
53113: PUSH
53114: LD_INT 86
53116: PUSH
53117: EMPTY
53118: LIST
53119: LIST
53120: LIST
53121: LIST
53122: LIST
53123: LIST
53124: LIST
53125: LIST
53126: LIST
53127: LIST
53128: LIST
53129: LIST
53130: LIST
53131: LIST
53132: LIST
53133: LIST
53134: LIST
53135: LIST
53136: LIST
53137: LIST
53138: LIST
53139: LIST
53140: LIST
53141: LIST
53142: LIST
53143: LIST
53144: LIST
53145: LIST
53146: LIST
53147: LIST
53148: LIST
53149: LIST
53150: LIST
53151: LIST
53152: LIST
53153: LIST
53154: LIST
53155: LIST
53156: LIST
53157: LIST
53158: LIST
53159: LIST
53160: LIST
53161: LIST
53162: LIST
53163: LIST
53164: LIST
53165: LIST
53166: LIST
53167: LIST
53168: LIST
53169: ST_TO_ADDR
53170: GO 53637
53172: LD_INT 2
53174: DOUBLE
53175: EQUAL
53176: IFTRUE 53180
53178: GO 53406
53180: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
53181: LD_ADDR_VAR 0 4
53185: PUSH
53186: LD_INT 35
53188: PUSH
53189: LD_INT 45
53191: PUSH
53192: LD_INT 46
53194: PUSH
53195: LD_INT 47
53197: PUSH
53198: LD_INT 82
53200: PUSH
53201: LD_INT 83
53203: PUSH
53204: LD_INT 84
53206: PUSH
53207: LD_INT 85
53209: PUSH
53210: LD_INT 87
53212: PUSH
53213: LD_INT 70
53215: PUSH
53216: LD_INT 1
53218: PUSH
53219: LD_INT 11
53221: PUSH
53222: LD_INT 3
53224: PUSH
53225: LD_INT 4
53227: PUSH
53228: LD_INT 5
53230: PUSH
53231: LD_INT 6
53233: PUSH
53234: LD_INT 15
53236: PUSH
53237: LD_INT 18
53239: PUSH
53240: LD_INT 7
53242: PUSH
53243: LD_INT 17
53245: PUSH
53246: LD_INT 8
53248: PUSH
53249: LD_INT 20
53251: PUSH
53252: LD_INT 21
53254: PUSH
53255: LD_INT 22
53257: PUSH
53258: LD_INT 72
53260: PUSH
53261: LD_INT 26
53263: PUSH
53264: LD_INT 69
53266: PUSH
53267: LD_INT 39
53269: PUSH
53270: LD_INT 40
53272: PUSH
53273: LD_INT 41
53275: PUSH
53276: LD_INT 42
53278: PUSH
53279: LD_INT 43
53281: PUSH
53282: LD_INT 48
53284: PUSH
53285: LD_INT 49
53287: PUSH
53288: LD_INT 50
53290: PUSH
53291: LD_INT 51
53293: PUSH
53294: LD_INT 52
53296: PUSH
53297: LD_INT 53
53299: PUSH
53300: LD_INT 54
53302: PUSH
53303: LD_INT 55
53305: PUSH
53306: LD_INT 56
53308: PUSH
53309: LD_INT 60
53311: PUSH
53312: LD_INT 61
53314: PUSH
53315: LD_INT 62
53317: PUSH
53318: LD_INT 66
53320: PUSH
53321: LD_INT 67
53323: PUSH
53324: LD_INT 68
53326: PUSH
53327: LD_INT 81
53329: PUSH
53330: LD_INT 82
53332: PUSH
53333: LD_INT 83
53335: PUSH
53336: LD_INT 84
53338: PUSH
53339: LD_INT 85
53341: PUSH
53342: LD_INT 87
53344: PUSH
53345: LD_INT 88
53347: PUSH
53348: EMPTY
53349: LIST
53350: LIST
53351: LIST
53352: LIST
53353: LIST
53354: LIST
53355: LIST
53356: LIST
53357: LIST
53358: LIST
53359: LIST
53360: LIST
53361: LIST
53362: LIST
53363: LIST
53364: LIST
53365: LIST
53366: LIST
53367: LIST
53368: LIST
53369: LIST
53370: LIST
53371: LIST
53372: LIST
53373: LIST
53374: LIST
53375: LIST
53376: LIST
53377: LIST
53378: LIST
53379: LIST
53380: LIST
53381: LIST
53382: LIST
53383: LIST
53384: LIST
53385: LIST
53386: LIST
53387: LIST
53388: LIST
53389: LIST
53390: LIST
53391: LIST
53392: LIST
53393: LIST
53394: LIST
53395: LIST
53396: LIST
53397: LIST
53398: LIST
53399: LIST
53400: LIST
53401: LIST
53402: LIST
53403: ST_TO_ADDR
53404: GO 53637
53406: LD_INT 3
53408: DOUBLE
53409: EQUAL
53410: IFTRUE 53414
53412: GO 53636
53414: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
53415: LD_ADDR_VAR 0 4
53419: PUSH
53420: LD_INT 46
53422: PUSH
53423: LD_INT 47
53425: PUSH
53426: LD_INT 1
53428: PUSH
53429: LD_INT 2
53431: PUSH
53432: LD_INT 82
53434: PUSH
53435: LD_INT 83
53437: PUSH
53438: LD_INT 84
53440: PUSH
53441: LD_INT 85
53443: PUSH
53444: LD_INT 86
53446: PUSH
53447: LD_INT 11
53449: PUSH
53450: LD_INT 9
53452: PUSH
53453: LD_INT 20
53455: PUSH
53456: LD_INT 19
53458: PUSH
53459: LD_INT 21
53461: PUSH
53462: LD_INT 24
53464: PUSH
53465: LD_INT 22
53467: PUSH
53468: LD_INT 25
53470: PUSH
53471: LD_INT 28
53473: PUSH
53474: LD_INT 29
53476: PUSH
53477: LD_INT 30
53479: PUSH
53480: LD_INT 31
53482: PUSH
53483: LD_INT 37
53485: PUSH
53486: LD_INT 38
53488: PUSH
53489: LD_INT 32
53491: PUSH
53492: LD_INT 27
53494: PUSH
53495: LD_INT 33
53497: PUSH
53498: LD_INT 69
53500: PUSH
53501: LD_INT 39
53503: PUSH
53504: LD_INT 34
53506: PUSH
53507: LD_INT 40
53509: PUSH
53510: LD_INT 71
53512: PUSH
53513: LD_INT 23
53515: PUSH
53516: LD_INT 44
53518: PUSH
53519: LD_INT 48
53521: PUSH
53522: LD_INT 49
53524: PUSH
53525: LD_INT 50
53527: PUSH
53528: LD_INT 51
53530: PUSH
53531: LD_INT 52
53533: PUSH
53534: LD_INT 53
53536: PUSH
53537: LD_INT 54
53539: PUSH
53540: LD_INT 55
53542: PUSH
53543: LD_INT 56
53545: PUSH
53546: LD_INT 57
53548: PUSH
53549: LD_INT 58
53551: PUSH
53552: LD_INT 59
53554: PUSH
53555: LD_INT 63
53557: PUSH
53558: LD_INT 64
53560: PUSH
53561: LD_INT 65
53563: PUSH
53564: LD_INT 82
53566: PUSH
53567: LD_INT 83
53569: PUSH
53570: LD_INT 84
53572: PUSH
53573: LD_INT 85
53575: PUSH
53576: LD_INT 86
53578: PUSH
53579: EMPTY
53580: LIST
53581: LIST
53582: LIST
53583: LIST
53584: LIST
53585: LIST
53586: LIST
53587: LIST
53588: LIST
53589: LIST
53590: LIST
53591: LIST
53592: LIST
53593: LIST
53594: LIST
53595: LIST
53596: LIST
53597: LIST
53598: LIST
53599: LIST
53600: LIST
53601: LIST
53602: LIST
53603: LIST
53604: LIST
53605: LIST
53606: LIST
53607: LIST
53608: LIST
53609: LIST
53610: LIST
53611: LIST
53612: LIST
53613: LIST
53614: LIST
53615: LIST
53616: LIST
53617: LIST
53618: LIST
53619: LIST
53620: LIST
53621: LIST
53622: LIST
53623: LIST
53624: LIST
53625: LIST
53626: LIST
53627: LIST
53628: LIST
53629: LIST
53630: LIST
53631: LIST
53632: LIST
53633: ST_TO_ADDR
53634: GO 53637
53636: POP
// if state > - 1 and state < 3 then
53637: LD_VAR 0 3
53641: PUSH
53642: LD_INT 1
53644: NEG
53645: GREATER
53646: PUSH
53647: LD_VAR 0 3
53651: PUSH
53652: LD_INT 3
53654: LESS
53655: AND
53656: IFFALSE 53713
// for i in result do
53658: LD_ADDR_VAR 0 5
53662: PUSH
53663: LD_VAR 0 4
53667: PUSH
53668: FOR_IN
53669: IFFALSE 53711
// if GetTech ( i , side ) <> state then
53671: LD_VAR 0 5
53675: PPUSH
53676: LD_VAR 0 1
53680: PPUSH
53681: CALL_OW 321
53685: PUSH
53686: LD_VAR 0 3
53690: NONEQUAL
53691: IFFALSE 53709
// result := result diff i ;
53693: LD_ADDR_VAR 0 4
53697: PUSH
53698: LD_VAR 0 4
53702: PUSH
53703: LD_VAR 0 5
53707: DIFF
53708: ST_TO_ADDR
53709: GO 53668
53711: POP
53712: POP
// end ;
53713: LD_VAR 0 4
53717: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
53718: LD_INT 0
53720: PPUSH
53721: PPUSH
53722: PPUSH
// result := true ;
53723: LD_ADDR_VAR 0 3
53727: PUSH
53728: LD_INT 1
53730: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
53731: LD_ADDR_VAR 0 5
53735: PUSH
53736: LD_VAR 0 2
53740: PPUSH
53741: CALL_OW 480
53745: ST_TO_ADDR
// if not tmp then
53746: LD_VAR 0 5
53750: NOT
53751: IFFALSE 53755
// exit ;
53753: GO 53804
// for i in tmp do
53755: LD_ADDR_VAR 0 4
53759: PUSH
53760: LD_VAR 0 5
53764: PUSH
53765: FOR_IN
53766: IFFALSE 53802
// if GetTech ( i , side ) <> state_researched then
53768: LD_VAR 0 4
53772: PPUSH
53773: LD_VAR 0 1
53777: PPUSH
53778: CALL_OW 321
53782: PUSH
53783: LD_INT 2
53785: NONEQUAL
53786: IFFALSE 53800
// begin result := false ;
53788: LD_ADDR_VAR 0 3
53792: PUSH
53793: LD_INT 0
53795: ST_TO_ADDR
// exit ;
53796: POP
53797: POP
53798: GO 53804
// end ;
53800: GO 53765
53802: POP
53803: POP
// end ;
53804: LD_VAR 0 3
53808: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
53809: LD_INT 0
53811: PPUSH
53812: PPUSH
53813: PPUSH
53814: PPUSH
53815: PPUSH
53816: PPUSH
53817: PPUSH
53818: PPUSH
53819: PPUSH
53820: PPUSH
53821: PPUSH
53822: PPUSH
53823: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
53824: LD_VAR 0 1
53828: NOT
53829: PUSH
53830: LD_VAR 0 1
53834: PPUSH
53835: CALL_OW 257
53839: PUSH
53840: LD_INT 9
53842: NONEQUAL
53843: OR
53844: IFFALSE 53848
// exit ;
53846: GO 54421
// side := GetSide ( unit ) ;
53848: LD_ADDR_VAR 0 9
53852: PUSH
53853: LD_VAR 0 1
53857: PPUSH
53858: CALL_OW 255
53862: ST_TO_ADDR
// tech_space := tech_spacanom ;
53863: LD_ADDR_VAR 0 12
53867: PUSH
53868: LD_INT 29
53870: ST_TO_ADDR
// tech_time := tech_taurad ;
53871: LD_ADDR_VAR 0 13
53875: PUSH
53876: LD_INT 28
53878: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53879: LD_ADDR_VAR 0 11
53883: PUSH
53884: LD_VAR 0 1
53888: PPUSH
53889: CALL_OW 310
53893: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53894: LD_VAR 0 11
53898: PPUSH
53899: CALL_OW 247
53903: PUSH
53904: LD_INT 2
53906: EQUAL
53907: IFFALSE 53911
// exit ;
53909: GO 54421
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53911: LD_ADDR_VAR 0 8
53915: PUSH
53916: LD_INT 81
53918: PUSH
53919: LD_VAR 0 9
53923: PUSH
53924: EMPTY
53925: LIST
53926: LIST
53927: PUSH
53928: LD_INT 3
53930: PUSH
53931: LD_INT 21
53933: PUSH
53934: LD_INT 3
53936: PUSH
53937: EMPTY
53938: LIST
53939: LIST
53940: PUSH
53941: EMPTY
53942: LIST
53943: LIST
53944: PUSH
53945: EMPTY
53946: LIST
53947: LIST
53948: PPUSH
53949: CALL_OW 69
53953: ST_TO_ADDR
// if not tmp then
53954: LD_VAR 0 8
53958: NOT
53959: IFFALSE 53963
// exit ;
53961: GO 54421
// if in_unit then
53963: LD_VAR 0 11
53967: IFFALSE 53991
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53969: LD_ADDR_VAR 0 10
53973: PUSH
53974: LD_VAR 0 8
53978: PPUSH
53979: LD_VAR 0 11
53983: PPUSH
53984: CALL_OW 74
53988: ST_TO_ADDR
53989: GO 54011
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53991: LD_ADDR_VAR 0 10
53995: PUSH
53996: LD_VAR 0 8
54000: PPUSH
54001: LD_VAR 0 1
54005: PPUSH
54006: CALL_OW 74
54010: ST_TO_ADDR
// if not enemy then
54011: LD_VAR 0 10
54015: NOT
54016: IFFALSE 54020
// exit ;
54018: GO 54421
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54020: LD_VAR 0 11
54024: PUSH
54025: LD_VAR 0 11
54029: PPUSH
54030: LD_VAR 0 10
54034: PPUSH
54035: CALL_OW 296
54039: PUSH
54040: LD_INT 13
54042: GREATER
54043: AND
54044: PUSH
54045: LD_VAR 0 1
54049: PPUSH
54050: LD_VAR 0 10
54054: PPUSH
54055: CALL_OW 296
54059: PUSH
54060: LD_INT 12
54062: GREATER
54063: OR
54064: IFFALSE 54068
// exit ;
54066: GO 54421
// missile := [ 1 ] ;
54068: LD_ADDR_VAR 0 14
54072: PUSH
54073: LD_INT 1
54075: PUSH
54076: EMPTY
54077: LIST
54078: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54079: LD_VAR 0 9
54083: PPUSH
54084: LD_VAR 0 12
54088: PPUSH
54089: CALL_OW 325
54093: IFFALSE 54122
// missile := Replace ( missile , missile + 1 , 2 ) ;
54095: LD_ADDR_VAR 0 14
54099: PUSH
54100: LD_VAR 0 14
54104: PPUSH
54105: LD_VAR 0 14
54109: PUSH
54110: LD_INT 1
54112: PLUS
54113: PPUSH
54114: LD_INT 2
54116: PPUSH
54117: CALL_OW 1
54121: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54122: LD_VAR 0 9
54126: PPUSH
54127: LD_VAR 0 13
54131: PPUSH
54132: CALL_OW 325
54136: PUSH
54137: LD_VAR 0 10
54141: PPUSH
54142: CALL_OW 255
54146: PPUSH
54147: LD_VAR 0 13
54151: PPUSH
54152: CALL_OW 325
54156: NOT
54157: AND
54158: IFFALSE 54187
// missile := Replace ( missile , missile + 1 , 3 ) ;
54160: LD_ADDR_VAR 0 14
54164: PUSH
54165: LD_VAR 0 14
54169: PPUSH
54170: LD_VAR 0 14
54174: PUSH
54175: LD_INT 1
54177: PLUS
54178: PPUSH
54179: LD_INT 3
54181: PPUSH
54182: CALL_OW 1
54186: ST_TO_ADDR
// if missile < 2 then
54187: LD_VAR 0 14
54191: PUSH
54192: LD_INT 2
54194: LESS
54195: IFFALSE 54199
// exit ;
54197: GO 54421
// x := GetX ( enemy ) ;
54199: LD_ADDR_VAR 0 4
54203: PUSH
54204: LD_VAR 0 10
54208: PPUSH
54209: CALL_OW 250
54213: ST_TO_ADDR
// y := GetY ( enemy ) ;
54214: LD_ADDR_VAR 0 5
54218: PUSH
54219: LD_VAR 0 10
54223: PPUSH
54224: CALL_OW 251
54228: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
54229: LD_ADDR_VAR 0 6
54233: PUSH
54234: LD_VAR 0 4
54238: PUSH
54239: LD_INT 1
54241: NEG
54242: PPUSH
54243: LD_INT 1
54245: PPUSH
54246: CALL_OW 12
54250: PLUS
54251: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
54252: LD_ADDR_VAR 0 7
54256: PUSH
54257: LD_VAR 0 5
54261: PUSH
54262: LD_INT 1
54264: NEG
54265: PPUSH
54266: LD_INT 1
54268: PPUSH
54269: CALL_OW 12
54273: PLUS
54274: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54275: LD_VAR 0 6
54279: PPUSH
54280: LD_VAR 0 7
54284: PPUSH
54285: CALL_OW 488
54289: NOT
54290: IFFALSE 54312
// begin _x := x ;
54292: LD_ADDR_VAR 0 6
54296: PUSH
54297: LD_VAR 0 4
54301: ST_TO_ADDR
// _y := y ;
54302: LD_ADDR_VAR 0 7
54306: PUSH
54307: LD_VAR 0 5
54311: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
54312: LD_ADDR_VAR 0 3
54316: PUSH
54317: LD_INT 1
54319: PPUSH
54320: LD_VAR 0 14
54324: PPUSH
54325: CALL_OW 12
54329: ST_TO_ADDR
// case i of 1 :
54330: LD_VAR 0 3
54334: PUSH
54335: LD_INT 1
54337: DOUBLE
54338: EQUAL
54339: IFTRUE 54343
54341: GO 54360
54343: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
54344: LD_VAR 0 1
54348: PPUSH
54349: LD_VAR 0 10
54353: PPUSH
54354: CALL_OW 115
54358: GO 54421
54360: LD_INT 2
54362: DOUBLE
54363: EQUAL
54364: IFTRUE 54368
54366: GO 54390
54368: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
54369: LD_VAR 0 1
54373: PPUSH
54374: LD_VAR 0 6
54378: PPUSH
54379: LD_VAR 0 7
54383: PPUSH
54384: CALL_OW 153
54388: GO 54421
54390: LD_INT 3
54392: DOUBLE
54393: EQUAL
54394: IFTRUE 54398
54396: GO 54420
54398: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
54399: LD_VAR 0 1
54403: PPUSH
54404: LD_VAR 0 6
54408: PPUSH
54409: LD_VAR 0 7
54413: PPUSH
54414: CALL_OW 154
54418: GO 54421
54420: POP
// end ;
54421: LD_VAR 0 2
54425: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
54426: LD_INT 0
54428: PPUSH
54429: PPUSH
54430: PPUSH
54431: PPUSH
54432: PPUSH
54433: PPUSH
// if not unit or not building then
54434: LD_VAR 0 1
54438: NOT
54439: PUSH
54440: LD_VAR 0 2
54444: NOT
54445: OR
54446: IFFALSE 54450
// exit ;
54448: GO 54608
// x := GetX ( building ) ;
54450: LD_ADDR_VAR 0 5
54454: PUSH
54455: LD_VAR 0 2
54459: PPUSH
54460: CALL_OW 250
54464: ST_TO_ADDR
// y := GetY ( building ) ;
54465: LD_ADDR_VAR 0 6
54469: PUSH
54470: LD_VAR 0 2
54474: PPUSH
54475: CALL_OW 251
54479: ST_TO_ADDR
// for i = 0 to 5 do
54480: LD_ADDR_VAR 0 4
54484: PUSH
54485: DOUBLE
54486: LD_INT 0
54488: DEC
54489: ST_TO_ADDR
54490: LD_INT 5
54492: PUSH
54493: FOR_TO
54494: IFFALSE 54606
// begin _x := ShiftX ( x , i , 3 ) ;
54496: LD_ADDR_VAR 0 7
54500: PUSH
54501: LD_VAR 0 5
54505: PPUSH
54506: LD_VAR 0 4
54510: PPUSH
54511: LD_INT 3
54513: PPUSH
54514: CALL_OW 272
54518: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
54519: LD_ADDR_VAR 0 8
54523: PUSH
54524: LD_VAR 0 6
54528: PPUSH
54529: LD_VAR 0 4
54533: PPUSH
54534: LD_INT 3
54536: PPUSH
54537: CALL_OW 273
54541: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54542: LD_VAR 0 7
54546: PPUSH
54547: LD_VAR 0 8
54551: PPUSH
54552: CALL_OW 488
54556: NOT
54557: IFFALSE 54561
// continue ;
54559: GO 54493
// if HexInfo ( _x , _y ) = 0 then
54561: LD_VAR 0 7
54565: PPUSH
54566: LD_VAR 0 8
54570: PPUSH
54571: CALL_OW 428
54575: PUSH
54576: LD_INT 0
54578: EQUAL
54579: IFFALSE 54604
// begin ComMoveXY ( unit , _x , _y ) ;
54581: LD_VAR 0 1
54585: PPUSH
54586: LD_VAR 0 7
54590: PPUSH
54591: LD_VAR 0 8
54595: PPUSH
54596: CALL_OW 111
// exit ;
54600: POP
54601: POP
54602: GO 54608
// end ; end ;
54604: GO 54493
54606: POP
54607: POP
// end ;
54608: LD_VAR 0 3
54612: RET
// export function ScanBase ( side , base_area ) ; begin
54613: LD_INT 0
54615: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
54616: LD_ADDR_VAR 0 3
54620: PUSH
54621: LD_VAR 0 2
54625: PPUSH
54626: LD_INT 81
54628: PUSH
54629: LD_VAR 0 1
54633: PUSH
54634: EMPTY
54635: LIST
54636: LIST
54637: PPUSH
54638: CALL_OW 70
54642: ST_TO_ADDR
// end ;
54643: LD_VAR 0 3
54647: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54648: LD_INT 0
54650: PPUSH
54651: PPUSH
54652: PPUSH
54653: PPUSH
// result := false ;
54654: LD_ADDR_VAR 0 2
54658: PUSH
54659: LD_INT 0
54661: ST_TO_ADDR
// side := GetSide ( unit ) ;
54662: LD_ADDR_VAR 0 3
54666: PUSH
54667: LD_VAR 0 1
54671: PPUSH
54672: CALL_OW 255
54676: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54677: LD_ADDR_VAR 0 4
54681: PUSH
54682: LD_VAR 0 1
54686: PPUSH
54687: CALL_OW 248
54691: ST_TO_ADDR
// case nat of 1 :
54692: LD_VAR 0 4
54696: PUSH
54697: LD_INT 1
54699: DOUBLE
54700: EQUAL
54701: IFTRUE 54705
54703: GO 54716
54705: POP
// tech := tech_lassight ; 2 :
54706: LD_ADDR_VAR 0 5
54710: PUSH
54711: LD_INT 12
54713: ST_TO_ADDR
54714: GO 54755
54716: LD_INT 2
54718: DOUBLE
54719: EQUAL
54720: IFTRUE 54724
54722: GO 54735
54724: POP
// tech := tech_mortar ; 3 :
54725: LD_ADDR_VAR 0 5
54729: PUSH
54730: LD_INT 41
54732: ST_TO_ADDR
54733: GO 54755
54735: LD_INT 3
54737: DOUBLE
54738: EQUAL
54739: IFTRUE 54743
54741: GO 54754
54743: POP
// tech := tech_bazooka ; end ;
54744: LD_ADDR_VAR 0 5
54748: PUSH
54749: LD_INT 44
54751: ST_TO_ADDR
54752: GO 54755
54754: POP
// if Researched ( side , tech ) then
54755: LD_VAR 0 3
54759: PPUSH
54760: LD_VAR 0 5
54764: PPUSH
54765: CALL_OW 325
54769: IFFALSE 54796
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54771: LD_ADDR_VAR 0 2
54775: PUSH
54776: LD_INT 5
54778: PUSH
54779: LD_INT 8
54781: PUSH
54782: LD_INT 9
54784: PUSH
54785: EMPTY
54786: LIST
54787: LIST
54788: LIST
54789: PUSH
54790: LD_VAR 0 4
54794: ARRAY
54795: ST_TO_ADDR
// end ;
54796: LD_VAR 0 2
54800: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54801: LD_INT 0
54803: PPUSH
54804: PPUSH
54805: PPUSH
// if not mines then
54806: LD_VAR 0 2
54810: NOT
54811: IFFALSE 54815
// exit ;
54813: GO 54959
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54815: LD_ADDR_VAR 0 5
54819: PUSH
54820: LD_INT 81
54822: PUSH
54823: LD_VAR 0 1
54827: PUSH
54828: EMPTY
54829: LIST
54830: LIST
54831: PUSH
54832: LD_INT 3
54834: PUSH
54835: LD_INT 21
54837: PUSH
54838: LD_INT 3
54840: PUSH
54841: EMPTY
54842: LIST
54843: LIST
54844: PUSH
54845: EMPTY
54846: LIST
54847: LIST
54848: PUSH
54849: EMPTY
54850: LIST
54851: LIST
54852: PPUSH
54853: CALL_OW 69
54857: ST_TO_ADDR
// for i in mines do
54858: LD_ADDR_VAR 0 4
54862: PUSH
54863: LD_VAR 0 2
54867: PUSH
54868: FOR_IN
54869: IFFALSE 54957
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54871: LD_VAR 0 4
54875: PUSH
54876: LD_INT 1
54878: ARRAY
54879: PPUSH
54880: LD_VAR 0 4
54884: PUSH
54885: LD_INT 2
54887: ARRAY
54888: PPUSH
54889: CALL_OW 458
54893: NOT
54894: IFFALSE 54898
// continue ;
54896: GO 54868
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54898: LD_VAR 0 4
54902: PUSH
54903: LD_INT 1
54905: ARRAY
54906: PPUSH
54907: LD_VAR 0 4
54911: PUSH
54912: LD_INT 2
54914: ARRAY
54915: PPUSH
54916: CALL_OW 428
54920: PUSH
54921: LD_VAR 0 5
54925: IN
54926: IFFALSE 54955
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54928: LD_VAR 0 4
54932: PUSH
54933: LD_INT 1
54935: ARRAY
54936: PPUSH
54937: LD_VAR 0 4
54941: PUSH
54942: LD_INT 2
54944: ARRAY
54945: PPUSH
54946: LD_VAR 0 1
54950: PPUSH
54951: CALL_OW 456
// end ;
54955: GO 54868
54957: POP
54958: POP
// end ;
54959: LD_VAR 0 3
54963: RET
// export function Count ( array ) ; begin
54964: LD_INT 0
54966: PPUSH
// result := array + 0 ;
54967: LD_ADDR_VAR 0 2
54971: PUSH
54972: LD_VAR 0 1
54976: PUSH
54977: LD_INT 0
54979: PLUS
54980: ST_TO_ADDR
// end ;
54981: LD_VAR 0 2
54985: RET
// export function IsEmpty ( building ) ; begin
54986: LD_INT 0
54988: PPUSH
// if not building then
54989: LD_VAR 0 1
54993: NOT
54994: IFFALSE 54998
// exit ;
54996: GO 55041
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54998: LD_ADDR_VAR 0 2
55002: PUSH
55003: LD_VAR 0 1
55007: PUSH
55008: LD_INT 22
55010: PUSH
55011: LD_VAR 0 1
55015: PPUSH
55016: CALL_OW 255
55020: PUSH
55021: EMPTY
55022: LIST
55023: LIST
55024: PUSH
55025: LD_INT 58
55027: PUSH
55028: EMPTY
55029: LIST
55030: PUSH
55031: EMPTY
55032: LIST
55033: LIST
55034: PPUSH
55035: CALL_OW 69
55039: IN
55040: ST_TO_ADDR
// end ;
55041: LD_VAR 0 2
55045: RET
// export function IsNotFull ( building ) ; var places ; begin
55046: LD_INT 0
55048: PPUSH
55049: PPUSH
// if not building then
55050: LD_VAR 0 1
55054: NOT
55055: IFFALSE 55059
// exit ;
55057: GO 55087
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
55059: LD_ADDR_VAR 0 2
55063: PUSH
55064: LD_VAR 0 1
55068: PPUSH
55069: LD_INT 3
55071: PUSH
55072: LD_INT 62
55074: PUSH
55075: EMPTY
55076: LIST
55077: PUSH
55078: EMPTY
55079: LIST
55080: LIST
55081: PPUSH
55082: CALL_OW 72
55086: ST_TO_ADDR
// end ;
55087: LD_VAR 0 2
55091: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55092: LD_INT 0
55094: PPUSH
55095: PPUSH
55096: PPUSH
55097: PPUSH
// tmp := [ ] ;
55098: LD_ADDR_VAR 0 3
55102: PUSH
55103: EMPTY
55104: ST_TO_ADDR
// list := [ ] ;
55105: LD_ADDR_VAR 0 5
55109: PUSH
55110: EMPTY
55111: ST_TO_ADDR
// for i = 16 to 25 do
55112: LD_ADDR_VAR 0 4
55116: PUSH
55117: DOUBLE
55118: LD_INT 16
55120: DEC
55121: ST_TO_ADDR
55122: LD_INT 25
55124: PUSH
55125: FOR_TO
55126: IFFALSE 55199
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55128: LD_ADDR_VAR 0 3
55132: PUSH
55133: LD_VAR 0 3
55137: PUSH
55138: LD_INT 22
55140: PUSH
55141: LD_VAR 0 1
55145: PPUSH
55146: CALL_OW 255
55150: PUSH
55151: EMPTY
55152: LIST
55153: LIST
55154: PUSH
55155: LD_INT 91
55157: PUSH
55158: LD_VAR 0 1
55162: PUSH
55163: LD_INT 6
55165: PUSH
55166: EMPTY
55167: LIST
55168: LIST
55169: LIST
55170: PUSH
55171: LD_INT 30
55173: PUSH
55174: LD_VAR 0 4
55178: PUSH
55179: EMPTY
55180: LIST
55181: LIST
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: LIST
55187: PUSH
55188: EMPTY
55189: LIST
55190: PPUSH
55191: CALL_OW 69
55195: ADD
55196: ST_TO_ADDR
55197: GO 55125
55199: POP
55200: POP
// for i = 1 to tmp do
55201: LD_ADDR_VAR 0 4
55205: PUSH
55206: DOUBLE
55207: LD_INT 1
55209: DEC
55210: ST_TO_ADDR
55211: LD_VAR 0 3
55215: PUSH
55216: FOR_TO
55217: IFFALSE 55305
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55219: LD_ADDR_VAR 0 5
55223: PUSH
55224: LD_VAR 0 5
55228: PUSH
55229: LD_VAR 0 3
55233: PUSH
55234: LD_VAR 0 4
55238: ARRAY
55239: PPUSH
55240: CALL_OW 266
55244: PUSH
55245: LD_VAR 0 3
55249: PUSH
55250: LD_VAR 0 4
55254: ARRAY
55255: PPUSH
55256: CALL_OW 250
55260: PUSH
55261: LD_VAR 0 3
55265: PUSH
55266: LD_VAR 0 4
55270: ARRAY
55271: PPUSH
55272: CALL_OW 251
55276: PUSH
55277: LD_VAR 0 3
55281: PUSH
55282: LD_VAR 0 4
55286: ARRAY
55287: PPUSH
55288: CALL_OW 254
55292: PUSH
55293: EMPTY
55294: LIST
55295: LIST
55296: LIST
55297: LIST
55298: PUSH
55299: EMPTY
55300: LIST
55301: ADD
55302: ST_TO_ADDR
55303: GO 55216
55305: POP
55306: POP
// result := list ;
55307: LD_ADDR_VAR 0 2
55311: PUSH
55312: LD_VAR 0 5
55316: ST_TO_ADDR
// end ;
55317: LD_VAR 0 2
55321: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55322: LD_INT 0
55324: PPUSH
55325: PPUSH
55326: PPUSH
55327: PPUSH
55328: PPUSH
55329: PPUSH
55330: PPUSH
// if not factory then
55331: LD_VAR 0 1
55335: NOT
55336: IFFALSE 55340
// exit ;
55338: GO 55933
// if control = control_apeman then
55340: LD_VAR 0 4
55344: PUSH
55345: LD_INT 5
55347: EQUAL
55348: IFFALSE 55457
// begin tmp := UnitsInside ( factory ) ;
55350: LD_ADDR_VAR 0 8
55354: PUSH
55355: LD_VAR 0 1
55359: PPUSH
55360: CALL_OW 313
55364: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55365: LD_VAR 0 8
55369: PPUSH
55370: LD_INT 25
55372: PUSH
55373: LD_INT 12
55375: PUSH
55376: EMPTY
55377: LIST
55378: LIST
55379: PPUSH
55380: CALL_OW 72
55384: NOT
55385: IFFALSE 55395
// control := control_manual ;
55387: LD_ADDR_VAR 0 4
55391: PUSH
55392: LD_INT 1
55394: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55395: LD_ADDR_VAR 0 8
55399: PUSH
55400: LD_VAR 0 1
55404: PPUSH
55405: CALL 55092 0 1
55409: ST_TO_ADDR
// if tmp then
55410: LD_VAR 0 8
55414: IFFALSE 55457
// begin for i in tmp do
55416: LD_ADDR_VAR 0 7
55420: PUSH
55421: LD_VAR 0 8
55425: PUSH
55426: FOR_IN
55427: IFFALSE 55455
// if i [ 1 ] = b_ext_radio then
55429: LD_VAR 0 7
55433: PUSH
55434: LD_INT 1
55436: ARRAY
55437: PUSH
55438: LD_INT 22
55440: EQUAL
55441: IFFALSE 55453
// begin control := control_remote ;
55443: LD_ADDR_VAR 0 4
55447: PUSH
55448: LD_INT 2
55450: ST_TO_ADDR
// break ;
55451: GO 55455
// end ;
55453: GO 55426
55455: POP
55456: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55457: LD_VAR 0 1
55461: PPUSH
55462: LD_VAR 0 2
55466: PPUSH
55467: LD_VAR 0 3
55471: PPUSH
55472: LD_VAR 0 4
55476: PPUSH
55477: LD_VAR 0 5
55481: PPUSH
55482: CALL_OW 448
55486: IFFALSE 55521
// begin result := [ chassis , engine , control , weapon ] ;
55488: LD_ADDR_VAR 0 6
55492: PUSH
55493: LD_VAR 0 2
55497: PUSH
55498: LD_VAR 0 3
55502: PUSH
55503: LD_VAR 0 4
55507: PUSH
55508: LD_VAR 0 5
55512: PUSH
55513: EMPTY
55514: LIST
55515: LIST
55516: LIST
55517: LIST
55518: ST_TO_ADDR
// exit ;
55519: GO 55933
// end ; _chassis := AvailableChassisList ( factory ) ;
55521: LD_ADDR_VAR 0 9
55525: PUSH
55526: LD_VAR 0 1
55530: PPUSH
55531: CALL_OW 475
55535: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55536: LD_ADDR_VAR 0 11
55540: PUSH
55541: LD_VAR 0 1
55545: PPUSH
55546: CALL_OW 476
55550: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55551: LD_ADDR_VAR 0 12
55555: PUSH
55556: LD_VAR 0 1
55560: PPUSH
55561: CALL_OW 477
55565: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55566: LD_ADDR_VAR 0 10
55570: PUSH
55571: LD_VAR 0 1
55575: PPUSH
55576: CALL_OW 478
55580: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55581: LD_VAR 0 9
55585: NOT
55586: PUSH
55587: LD_VAR 0 11
55591: NOT
55592: OR
55593: PUSH
55594: LD_VAR 0 12
55598: NOT
55599: OR
55600: PUSH
55601: LD_VAR 0 10
55605: NOT
55606: OR
55607: IFFALSE 55642
// begin result := [ chassis , engine , control , weapon ] ;
55609: LD_ADDR_VAR 0 6
55613: PUSH
55614: LD_VAR 0 2
55618: PUSH
55619: LD_VAR 0 3
55623: PUSH
55624: LD_VAR 0 4
55628: PUSH
55629: LD_VAR 0 5
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: LIST
55638: LIST
55639: ST_TO_ADDR
// exit ;
55640: GO 55933
// end ; if not chassis in _chassis then
55642: LD_VAR 0 2
55646: PUSH
55647: LD_VAR 0 9
55651: IN
55652: NOT
55653: IFFALSE 55679
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55655: LD_ADDR_VAR 0 2
55659: PUSH
55660: LD_VAR 0 9
55664: PUSH
55665: LD_INT 1
55667: PPUSH
55668: LD_VAR 0 9
55672: PPUSH
55673: CALL_OW 12
55677: ARRAY
55678: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55679: LD_VAR 0 2
55683: PPUSH
55684: LD_VAR 0 3
55688: PPUSH
55689: CALL 55938 0 2
55693: NOT
55694: IFFALSE 55753
// repeat engine := _engine [ 1 ] ;
55696: LD_ADDR_VAR 0 3
55700: PUSH
55701: LD_VAR 0 11
55705: PUSH
55706: LD_INT 1
55708: ARRAY
55709: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55710: LD_ADDR_VAR 0 11
55714: PUSH
55715: LD_VAR 0 11
55719: PPUSH
55720: LD_INT 1
55722: PPUSH
55723: CALL_OW 3
55727: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55728: LD_VAR 0 2
55732: PPUSH
55733: LD_VAR 0 3
55737: PPUSH
55738: CALL 55938 0 2
55742: PUSH
55743: LD_VAR 0 11
55747: PUSH
55748: EMPTY
55749: EQUAL
55750: OR
55751: IFFALSE 55696
// if not control in _control then
55753: LD_VAR 0 4
55757: PUSH
55758: LD_VAR 0 12
55762: IN
55763: NOT
55764: IFFALSE 55790
// control := _control [ rand ( 1 , _control ) ] ;
55766: LD_ADDR_VAR 0 4
55770: PUSH
55771: LD_VAR 0 12
55775: PUSH
55776: LD_INT 1
55778: PPUSH
55779: LD_VAR 0 12
55783: PPUSH
55784: CALL_OW 12
55788: ARRAY
55789: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55790: LD_VAR 0 2
55794: PPUSH
55795: LD_VAR 0 5
55799: PPUSH
55800: CALL 56158 0 2
55804: NOT
55805: IFFALSE 55864
// repeat weapon := _weapon [ 1 ] ;
55807: LD_ADDR_VAR 0 5
55811: PUSH
55812: LD_VAR 0 10
55816: PUSH
55817: LD_INT 1
55819: ARRAY
55820: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55821: LD_ADDR_VAR 0 10
55825: PUSH
55826: LD_VAR 0 10
55830: PPUSH
55831: LD_INT 1
55833: PPUSH
55834: CALL_OW 3
55838: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55839: LD_VAR 0 2
55843: PPUSH
55844: LD_VAR 0 5
55848: PPUSH
55849: CALL 56158 0 2
55853: PUSH
55854: LD_VAR 0 10
55858: PUSH
55859: EMPTY
55860: EQUAL
55861: OR
55862: IFFALSE 55807
// result := [ ] ;
55864: LD_ADDR_VAR 0 6
55868: PUSH
55869: EMPTY
55870: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55871: LD_VAR 0 1
55875: PPUSH
55876: LD_VAR 0 2
55880: PPUSH
55881: LD_VAR 0 3
55885: PPUSH
55886: LD_VAR 0 4
55890: PPUSH
55891: LD_VAR 0 5
55895: PPUSH
55896: CALL_OW 448
55900: IFFALSE 55933
// result := [ chassis , engine , control , weapon ] ;
55902: LD_ADDR_VAR 0 6
55906: PUSH
55907: LD_VAR 0 2
55911: PUSH
55912: LD_VAR 0 3
55916: PUSH
55917: LD_VAR 0 4
55921: PUSH
55922: LD_VAR 0 5
55926: PUSH
55927: EMPTY
55928: LIST
55929: LIST
55930: LIST
55931: LIST
55932: ST_TO_ADDR
// end ;
55933: LD_VAR 0 6
55937: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55938: LD_INT 0
55940: PPUSH
// if not chassis or not engine then
55941: LD_VAR 0 1
55945: NOT
55946: PUSH
55947: LD_VAR 0 2
55951: NOT
55952: OR
55953: IFFALSE 55957
// exit ;
55955: GO 56153
// case engine of engine_solar :
55957: LD_VAR 0 2
55961: PUSH
55962: LD_INT 2
55964: DOUBLE
55965: EQUAL
55966: IFTRUE 55970
55968: GO 56008
55970: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55971: LD_ADDR_VAR 0 3
55975: PUSH
55976: LD_INT 11
55978: PUSH
55979: LD_INT 12
55981: PUSH
55982: LD_INT 13
55984: PUSH
55985: LD_INT 14
55987: PUSH
55988: LD_INT 1
55990: PUSH
55991: LD_INT 2
55993: PUSH
55994: LD_INT 3
55996: PUSH
55997: EMPTY
55998: LIST
55999: LIST
56000: LIST
56001: LIST
56002: LIST
56003: LIST
56004: LIST
56005: ST_TO_ADDR
56006: GO 56137
56008: LD_INT 1
56010: DOUBLE
56011: EQUAL
56012: IFTRUE 56016
56014: GO 56078
56016: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56017: LD_ADDR_VAR 0 3
56021: PUSH
56022: LD_INT 11
56024: PUSH
56025: LD_INT 12
56027: PUSH
56028: LD_INT 13
56030: PUSH
56031: LD_INT 14
56033: PUSH
56034: LD_INT 1
56036: PUSH
56037: LD_INT 2
56039: PUSH
56040: LD_INT 3
56042: PUSH
56043: LD_INT 4
56045: PUSH
56046: LD_INT 5
56048: PUSH
56049: LD_INT 21
56051: PUSH
56052: LD_INT 23
56054: PUSH
56055: LD_INT 22
56057: PUSH
56058: LD_INT 24
56060: PUSH
56061: EMPTY
56062: LIST
56063: LIST
56064: LIST
56065: LIST
56066: LIST
56067: LIST
56068: LIST
56069: LIST
56070: LIST
56071: LIST
56072: LIST
56073: LIST
56074: LIST
56075: ST_TO_ADDR
56076: GO 56137
56078: LD_INT 3
56080: DOUBLE
56081: EQUAL
56082: IFTRUE 56086
56084: GO 56136
56086: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56087: LD_ADDR_VAR 0 3
56091: PUSH
56092: LD_INT 13
56094: PUSH
56095: LD_INT 14
56097: PUSH
56098: LD_INT 2
56100: PUSH
56101: LD_INT 3
56103: PUSH
56104: LD_INT 4
56106: PUSH
56107: LD_INT 5
56109: PUSH
56110: LD_INT 21
56112: PUSH
56113: LD_INT 22
56115: PUSH
56116: LD_INT 23
56118: PUSH
56119: LD_INT 24
56121: PUSH
56122: EMPTY
56123: LIST
56124: LIST
56125: LIST
56126: LIST
56127: LIST
56128: LIST
56129: LIST
56130: LIST
56131: LIST
56132: LIST
56133: ST_TO_ADDR
56134: GO 56137
56136: POP
// result := ( chassis in result ) ;
56137: LD_ADDR_VAR 0 3
56141: PUSH
56142: LD_VAR 0 1
56146: PUSH
56147: LD_VAR 0 3
56151: IN
56152: ST_TO_ADDR
// end ;
56153: LD_VAR 0 3
56157: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56158: LD_INT 0
56160: PPUSH
// if not chassis or not weapon then
56161: LD_VAR 0 1
56165: NOT
56166: PUSH
56167: LD_VAR 0 2
56171: NOT
56172: OR
56173: IFFALSE 56177
// exit ;
56175: GO 57237
// case weapon of us_machine_gun :
56177: LD_VAR 0 2
56181: PUSH
56182: LD_INT 2
56184: DOUBLE
56185: EQUAL
56186: IFTRUE 56190
56188: GO 56220
56190: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56191: LD_ADDR_VAR 0 3
56195: PUSH
56196: LD_INT 1
56198: PUSH
56199: LD_INT 2
56201: PUSH
56202: LD_INT 3
56204: PUSH
56205: LD_INT 4
56207: PUSH
56208: LD_INT 5
56210: PUSH
56211: EMPTY
56212: LIST
56213: LIST
56214: LIST
56215: LIST
56216: LIST
56217: ST_TO_ADDR
56218: GO 57221
56220: LD_INT 3
56222: DOUBLE
56223: EQUAL
56224: IFTRUE 56228
56226: GO 56258
56228: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56229: LD_ADDR_VAR 0 3
56233: PUSH
56234: LD_INT 1
56236: PUSH
56237: LD_INT 2
56239: PUSH
56240: LD_INT 3
56242: PUSH
56243: LD_INT 4
56245: PUSH
56246: LD_INT 5
56248: PUSH
56249: EMPTY
56250: LIST
56251: LIST
56252: LIST
56253: LIST
56254: LIST
56255: ST_TO_ADDR
56256: GO 57221
56258: LD_INT 11
56260: DOUBLE
56261: EQUAL
56262: IFTRUE 56266
56264: GO 56296
56266: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56267: LD_ADDR_VAR 0 3
56271: PUSH
56272: LD_INT 1
56274: PUSH
56275: LD_INT 2
56277: PUSH
56278: LD_INT 3
56280: PUSH
56281: LD_INT 4
56283: PUSH
56284: LD_INT 5
56286: PUSH
56287: EMPTY
56288: LIST
56289: LIST
56290: LIST
56291: LIST
56292: LIST
56293: ST_TO_ADDR
56294: GO 57221
56296: LD_INT 4
56298: DOUBLE
56299: EQUAL
56300: IFTRUE 56304
56302: GO 56330
56304: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56305: LD_ADDR_VAR 0 3
56309: PUSH
56310: LD_INT 2
56312: PUSH
56313: LD_INT 3
56315: PUSH
56316: LD_INT 4
56318: PUSH
56319: LD_INT 5
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: LIST
56326: LIST
56327: ST_TO_ADDR
56328: GO 57221
56330: LD_INT 5
56332: DOUBLE
56333: EQUAL
56334: IFTRUE 56338
56336: GO 56364
56338: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56339: LD_ADDR_VAR 0 3
56343: PUSH
56344: LD_INT 2
56346: PUSH
56347: LD_INT 3
56349: PUSH
56350: LD_INT 4
56352: PUSH
56353: LD_INT 5
56355: PUSH
56356: EMPTY
56357: LIST
56358: LIST
56359: LIST
56360: LIST
56361: ST_TO_ADDR
56362: GO 57221
56364: LD_INT 9
56366: DOUBLE
56367: EQUAL
56368: IFTRUE 56372
56370: GO 56398
56372: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56373: LD_ADDR_VAR 0 3
56377: PUSH
56378: LD_INT 2
56380: PUSH
56381: LD_INT 3
56383: PUSH
56384: LD_INT 4
56386: PUSH
56387: LD_INT 5
56389: PUSH
56390: EMPTY
56391: LIST
56392: LIST
56393: LIST
56394: LIST
56395: ST_TO_ADDR
56396: GO 57221
56398: LD_INT 7
56400: DOUBLE
56401: EQUAL
56402: IFTRUE 56406
56404: GO 56432
56406: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56407: LD_ADDR_VAR 0 3
56411: PUSH
56412: LD_INT 2
56414: PUSH
56415: LD_INT 3
56417: PUSH
56418: LD_INT 4
56420: PUSH
56421: LD_INT 5
56423: PUSH
56424: EMPTY
56425: LIST
56426: LIST
56427: LIST
56428: LIST
56429: ST_TO_ADDR
56430: GO 57221
56432: LD_INT 12
56434: DOUBLE
56435: EQUAL
56436: IFTRUE 56440
56438: GO 56466
56440: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56441: LD_ADDR_VAR 0 3
56445: PUSH
56446: LD_INT 2
56448: PUSH
56449: LD_INT 3
56451: PUSH
56452: LD_INT 4
56454: PUSH
56455: LD_INT 5
56457: PUSH
56458: EMPTY
56459: LIST
56460: LIST
56461: LIST
56462: LIST
56463: ST_TO_ADDR
56464: GO 57221
56466: LD_INT 13
56468: DOUBLE
56469: EQUAL
56470: IFTRUE 56474
56472: GO 56500
56474: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56475: LD_ADDR_VAR 0 3
56479: PUSH
56480: LD_INT 2
56482: PUSH
56483: LD_INT 3
56485: PUSH
56486: LD_INT 4
56488: PUSH
56489: LD_INT 5
56491: PUSH
56492: EMPTY
56493: LIST
56494: LIST
56495: LIST
56496: LIST
56497: ST_TO_ADDR
56498: GO 57221
56500: LD_INT 14
56502: DOUBLE
56503: EQUAL
56504: IFTRUE 56508
56506: GO 56526
56508: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56509: LD_ADDR_VAR 0 3
56513: PUSH
56514: LD_INT 4
56516: PUSH
56517: LD_INT 5
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: ST_TO_ADDR
56524: GO 57221
56526: LD_INT 6
56528: DOUBLE
56529: EQUAL
56530: IFTRUE 56534
56532: GO 56552
56534: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56535: LD_ADDR_VAR 0 3
56539: PUSH
56540: LD_INT 4
56542: PUSH
56543: LD_INT 5
56545: PUSH
56546: EMPTY
56547: LIST
56548: LIST
56549: ST_TO_ADDR
56550: GO 57221
56552: LD_INT 10
56554: DOUBLE
56555: EQUAL
56556: IFTRUE 56560
56558: GO 56578
56560: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56561: LD_ADDR_VAR 0 3
56565: PUSH
56566: LD_INT 4
56568: PUSH
56569: LD_INT 5
56571: PUSH
56572: EMPTY
56573: LIST
56574: LIST
56575: ST_TO_ADDR
56576: GO 57221
56578: LD_INT 22
56580: DOUBLE
56581: EQUAL
56582: IFTRUE 56586
56584: GO 56612
56586: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56587: LD_ADDR_VAR 0 3
56591: PUSH
56592: LD_INT 11
56594: PUSH
56595: LD_INT 12
56597: PUSH
56598: LD_INT 13
56600: PUSH
56601: LD_INT 14
56603: PUSH
56604: EMPTY
56605: LIST
56606: LIST
56607: LIST
56608: LIST
56609: ST_TO_ADDR
56610: GO 57221
56612: LD_INT 23
56614: DOUBLE
56615: EQUAL
56616: IFTRUE 56620
56618: GO 56646
56620: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56621: LD_ADDR_VAR 0 3
56625: PUSH
56626: LD_INT 11
56628: PUSH
56629: LD_INT 12
56631: PUSH
56632: LD_INT 13
56634: PUSH
56635: LD_INT 14
56637: PUSH
56638: EMPTY
56639: LIST
56640: LIST
56641: LIST
56642: LIST
56643: ST_TO_ADDR
56644: GO 57221
56646: LD_INT 24
56648: DOUBLE
56649: EQUAL
56650: IFTRUE 56654
56652: GO 56680
56654: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56655: LD_ADDR_VAR 0 3
56659: PUSH
56660: LD_INT 11
56662: PUSH
56663: LD_INT 12
56665: PUSH
56666: LD_INT 13
56668: PUSH
56669: LD_INT 14
56671: PUSH
56672: EMPTY
56673: LIST
56674: LIST
56675: LIST
56676: LIST
56677: ST_TO_ADDR
56678: GO 57221
56680: LD_INT 30
56682: DOUBLE
56683: EQUAL
56684: IFTRUE 56688
56686: GO 56714
56688: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56689: LD_ADDR_VAR 0 3
56693: PUSH
56694: LD_INT 11
56696: PUSH
56697: LD_INT 12
56699: PUSH
56700: LD_INT 13
56702: PUSH
56703: LD_INT 14
56705: PUSH
56706: EMPTY
56707: LIST
56708: LIST
56709: LIST
56710: LIST
56711: ST_TO_ADDR
56712: GO 57221
56714: LD_INT 25
56716: DOUBLE
56717: EQUAL
56718: IFTRUE 56722
56720: GO 56740
56722: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56723: LD_ADDR_VAR 0 3
56727: PUSH
56728: LD_INT 13
56730: PUSH
56731: LD_INT 14
56733: PUSH
56734: EMPTY
56735: LIST
56736: LIST
56737: ST_TO_ADDR
56738: GO 57221
56740: LD_INT 27
56742: DOUBLE
56743: EQUAL
56744: IFTRUE 56748
56746: GO 56766
56748: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
56749: LD_ADDR_VAR 0 3
56753: PUSH
56754: LD_INT 13
56756: PUSH
56757: LD_INT 14
56759: PUSH
56760: EMPTY
56761: LIST
56762: LIST
56763: ST_TO_ADDR
56764: GO 57221
56766: LD_INT 92
56768: DOUBLE
56769: EQUAL
56770: IFTRUE 56774
56772: GO 56800
56774: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56775: LD_ADDR_VAR 0 3
56779: PUSH
56780: LD_INT 11
56782: PUSH
56783: LD_INT 12
56785: PUSH
56786: LD_INT 13
56788: PUSH
56789: LD_INT 14
56791: PUSH
56792: EMPTY
56793: LIST
56794: LIST
56795: LIST
56796: LIST
56797: ST_TO_ADDR
56798: GO 57221
56800: LD_INT 28
56802: DOUBLE
56803: EQUAL
56804: IFTRUE 56808
56806: GO 56826
56808: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56809: LD_ADDR_VAR 0 3
56813: PUSH
56814: LD_INT 13
56816: PUSH
56817: LD_INT 14
56819: PUSH
56820: EMPTY
56821: LIST
56822: LIST
56823: ST_TO_ADDR
56824: GO 57221
56826: LD_INT 29
56828: DOUBLE
56829: EQUAL
56830: IFTRUE 56834
56832: GO 56852
56834: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56835: LD_ADDR_VAR 0 3
56839: PUSH
56840: LD_INT 13
56842: PUSH
56843: LD_INT 14
56845: PUSH
56846: EMPTY
56847: LIST
56848: LIST
56849: ST_TO_ADDR
56850: GO 57221
56852: LD_INT 31
56854: DOUBLE
56855: EQUAL
56856: IFTRUE 56860
56858: GO 56878
56860: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56861: LD_ADDR_VAR 0 3
56865: PUSH
56866: LD_INT 13
56868: PUSH
56869: LD_INT 14
56871: PUSH
56872: EMPTY
56873: LIST
56874: LIST
56875: ST_TO_ADDR
56876: GO 57221
56878: LD_INT 26
56880: DOUBLE
56881: EQUAL
56882: IFTRUE 56886
56884: GO 56904
56886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56887: LD_ADDR_VAR 0 3
56891: PUSH
56892: LD_INT 13
56894: PUSH
56895: LD_INT 14
56897: PUSH
56898: EMPTY
56899: LIST
56900: LIST
56901: ST_TO_ADDR
56902: GO 57221
56904: LD_INT 42
56906: DOUBLE
56907: EQUAL
56908: IFTRUE 56912
56910: GO 56938
56912: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56913: LD_ADDR_VAR 0 3
56917: PUSH
56918: LD_INT 21
56920: PUSH
56921: LD_INT 22
56923: PUSH
56924: LD_INT 23
56926: PUSH
56927: LD_INT 24
56929: PUSH
56930: EMPTY
56931: LIST
56932: LIST
56933: LIST
56934: LIST
56935: ST_TO_ADDR
56936: GO 57221
56938: LD_INT 43
56940: DOUBLE
56941: EQUAL
56942: IFTRUE 56946
56944: GO 56972
56946: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56947: LD_ADDR_VAR 0 3
56951: PUSH
56952: LD_INT 21
56954: PUSH
56955: LD_INT 22
56957: PUSH
56958: LD_INT 23
56960: PUSH
56961: LD_INT 24
56963: PUSH
56964: EMPTY
56965: LIST
56966: LIST
56967: LIST
56968: LIST
56969: ST_TO_ADDR
56970: GO 57221
56972: LD_INT 44
56974: DOUBLE
56975: EQUAL
56976: IFTRUE 56980
56978: GO 57006
56980: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56981: LD_ADDR_VAR 0 3
56985: PUSH
56986: LD_INT 21
56988: PUSH
56989: LD_INT 22
56991: PUSH
56992: LD_INT 23
56994: PUSH
56995: LD_INT 24
56997: PUSH
56998: EMPTY
56999: LIST
57000: LIST
57001: LIST
57002: LIST
57003: ST_TO_ADDR
57004: GO 57221
57006: LD_INT 45
57008: DOUBLE
57009: EQUAL
57010: IFTRUE 57014
57012: GO 57040
57014: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57015: LD_ADDR_VAR 0 3
57019: PUSH
57020: LD_INT 21
57022: PUSH
57023: LD_INT 22
57025: PUSH
57026: LD_INT 23
57028: PUSH
57029: LD_INT 24
57031: PUSH
57032: EMPTY
57033: LIST
57034: LIST
57035: LIST
57036: LIST
57037: ST_TO_ADDR
57038: GO 57221
57040: LD_INT 49
57042: DOUBLE
57043: EQUAL
57044: IFTRUE 57048
57046: GO 57074
57048: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57049: LD_ADDR_VAR 0 3
57053: PUSH
57054: LD_INT 21
57056: PUSH
57057: LD_INT 22
57059: PUSH
57060: LD_INT 23
57062: PUSH
57063: LD_INT 24
57065: PUSH
57066: EMPTY
57067: LIST
57068: LIST
57069: LIST
57070: LIST
57071: ST_TO_ADDR
57072: GO 57221
57074: LD_INT 51
57076: DOUBLE
57077: EQUAL
57078: IFTRUE 57082
57080: GO 57108
57082: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57083: LD_ADDR_VAR 0 3
57087: PUSH
57088: LD_INT 21
57090: PUSH
57091: LD_INT 22
57093: PUSH
57094: LD_INT 23
57096: PUSH
57097: LD_INT 24
57099: PUSH
57100: EMPTY
57101: LIST
57102: LIST
57103: LIST
57104: LIST
57105: ST_TO_ADDR
57106: GO 57221
57108: LD_INT 52
57110: DOUBLE
57111: EQUAL
57112: IFTRUE 57116
57114: GO 57142
57116: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57117: LD_ADDR_VAR 0 3
57121: PUSH
57122: LD_INT 21
57124: PUSH
57125: LD_INT 22
57127: PUSH
57128: LD_INT 23
57130: PUSH
57131: LD_INT 24
57133: PUSH
57134: EMPTY
57135: LIST
57136: LIST
57137: LIST
57138: LIST
57139: ST_TO_ADDR
57140: GO 57221
57142: LD_INT 53
57144: DOUBLE
57145: EQUAL
57146: IFTRUE 57150
57148: GO 57168
57150: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57151: LD_ADDR_VAR 0 3
57155: PUSH
57156: LD_INT 23
57158: PUSH
57159: LD_INT 24
57161: PUSH
57162: EMPTY
57163: LIST
57164: LIST
57165: ST_TO_ADDR
57166: GO 57221
57168: LD_INT 46
57170: DOUBLE
57171: EQUAL
57172: IFTRUE 57176
57174: GO 57194
57176: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57177: LD_ADDR_VAR 0 3
57181: PUSH
57182: LD_INT 23
57184: PUSH
57185: LD_INT 24
57187: PUSH
57188: EMPTY
57189: LIST
57190: LIST
57191: ST_TO_ADDR
57192: GO 57221
57194: LD_INT 47
57196: DOUBLE
57197: EQUAL
57198: IFTRUE 57202
57200: GO 57220
57202: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57203: LD_ADDR_VAR 0 3
57207: PUSH
57208: LD_INT 23
57210: PUSH
57211: LD_INT 24
57213: PUSH
57214: EMPTY
57215: LIST
57216: LIST
57217: ST_TO_ADDR
57218: GO 57221
57220: POP
// result := ( chassis in result ) ;
57221: LD_ADDR_VAR 0 3
57225: PUSH
57226: LD_VAR 0 1
57230: PUSH
57231: LD_VAR 0 3
57235: IN
57236: ST_TO_ADDR
// end ;
57237: LD_VAR 0 3
57241: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57242: LD_INT 0
57244: PPUSH
57245: PPUSH
57246: PPUSH
57247: PPUSH
57248: PPUSH
57249: PPUSH
57250: PPUSH
// result := array ;
57251: LD_ADDR_VAR 0 5
57255: PUSH
57256: LD_VAR 0 1
57260: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57261: LD_VAR 0 1
57265: NOT
57266: PUSH
57267: LD_VAR 0 2
57271: NOT
57272: OR
57273: PUSH
57274: LD_VAR 0 3
57278: NOT
57279: OR
57280: PUSH
57281: LD_VAR 0 2
57285: PUSH
57286: LD_VAR 0 1
57290: GREATER
57291: OR
57292: PUSH
57293: LD_VAR 0 3
57297: PUSH
57298: LD_VAR 0 1
57302: GREATER
57303: OR
57304: IFFALSE 57308
// exit ;
57306: GO 57604
// if direction then
57308: LD_VAR 0 4
57312: IFFALSE 57376
// begin d := 1 ;
57314: LD_ADDR_VAR 0 9
57318: PUSH
57319: LD_INT 1
57321: ST_TO_ADDR
// if i_from > i_to then
57322: LD_VAR 0 2
57326: PUSH
57327: LD_VAR 0 3
57331: GREATER
57332: IFFALSE 57358
// length := ( array - i_from ) + i_to else
57334: LD_ADDR_VAR 0 11
57338: PUSH
57339: LD_VAR 0 1
57343: PUSH
57344: LD_VAR 0 2
57348: MINUS
57349: PUSH
57350: LD_VAR 0 3
57354: PLUS
57355: ST_TO_ADDR
57356: GO 57374
// length := i_to - i_from ;
57358: LD_ADDR_VAR 0 11
57362: PUSH
57363: LD_VAR 0 3
57367: PUSH
57368: LD_VAR 0 2
57372: MINUS
57373: ST_TO_ADDR
// end else
57374: GO 57437
// begin d := - 1 ;
57376: LD_ADDR_VAR 0 9
57380: PUSH
57381: LD_INT 1
57383: NEG
57384: ST_TO_ADDR
// if i_from > i_to then
57385: LD_VAR 0 2
57389: PUSH
57390: LD_VAR 0 3
57394: GREATER
57395: IFFALSE 57415
// length := i_from - i_to else
57397: LD_ADDR_VAR 0 11
57401: PUSH
57402: LD_VAR 0 2
57406: PUSH
57407: LD_VAR 0 3
57411: MINUS
57412: ST_TO_ADDR
57413: GO 57437
// length := ( array - i_to ) + i_from ;
57415: LD_ADDR_VAR 0 11
57419: PUSH
57420: LD_VAR 0 1
57424: PUSH
57425: LD_VAR 0 3
57429: MINUS
57430: PUSH
57431: LD_VAR 0 2
57435: PLUS
57436: ST_TO_ADDR
// end ; if not length then
57437: LD_VAR 0 11
57441: NOT
57442: IFFALSE 57446
// exit ;
57444: GO 57604
// tmp := array ;
57446: LD_ADDR_VAR 0 10
57450: PUSH
57451: LD_VAR 0 1
57455: ST_TO_ADDR
// for i = 1 to length do
57456: LD_ADDR_VAR 0 6
57460: PUSH
57461: DOUBLE
57462: LD_INT 1
57464: DEC
57465: ST_TO_ADDR
57466: LD_VAR 0 11
57470: PUSH
57471: FOR_TO
57472: IFFALSE 57592
// begin for j = 1 to array do
57474: LD_ADDR_VAR 0 7
57478: PUSH
57479: DOUBLE
57480: LD_INT 1
57482: DEC
57483: ST_TO_ADDR
57484: LD_VAR 0 1
57488: PUSH
57489: FOR_TO
57490: IFFALSE 57578
// begin k := j + d ;
57492: LD_ADDR_VAR 0 8
57496: PUSH
57497: LD_VAR 0 7
57501: PUSH
57502: LD_VAR 0 9
57506: PLUS
57507: ST_TO_ADDR
// if k > array then
57508: LD_VAR 0 8
57512: PUSH
57513: LD_VAR 0 1
57517: GREATER
57518: IFFALSE 57528
// k := 1 ;
57520: LD_ADDR_VAR 0 8
57524: PUSH
57525: LD_INT 1
57527: ST_TO_ADDR
// if not k then
57528: LD_VAR 0 8
57532: NOT
57533: IFFALSE 57545
// k := array ;
57535: LD_ADDR_VAR 0 8
57539: PUSH
57540: LD_VAR 0 1
57544: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57545: LD_ADDR_VAR 0 10
57549: PUSH
57550: LD_VAR 0 10
57554: PPUSH
57555: LD_VAR 0 8
57559: PPUSH
57560: LD_VAR 0 1
57564: PUSH
57565: LD_VAR 0 7
57569: ARRAY
57570: PPUSH
57571: CALL_OW 1
57575: ST_TO_ADDR
// end ;
57576: GO 57489
57578: POP
57579: POP
// array := tmp ;
57580: LD_ADDR_VAR 0 1
57584: PUSH
57585: LD_VAR 0 10
57589: ST_TO_ADDR
// end ;
57590: GO 57471
57592: POP
57593: POP
// result := array ;
57594: LD_ADDR_VAR 0 5
57598: PUSH
57599: LD_VAR 0 1
57603: ST_TO_ADDR
// end ;
57604: LD_VAR 0 5
57608: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57609: LD_INT 0
57611: PPUSH
57612: PPUSH
// result := 0 ;
57613: LD_ADDR_VAR 0 3
57617: PUSH
57618: LD_INT 0
57620: ST_TO_ADDR
// if not array or not value in array then
57621: LD_VAR 0 1
57625: NOT
57626: PUSH
57627: LD_VAR 0 2
57631: PUSH
57632: LD_VAR 0 1
57636: IN
57637: NOT
57638: OR
57639: IFFALSE 57643
// exit ;
57641: GO 57697
// for i = 1 to array do
57643: LD_ADDR_VAR 0 4
57647: PUSH
57648: DOUBLE
57649: LD_INT 1
57651: DEC
57652: ST_TO_ADDR
57653: LD_VAR 0 1
57657: PUSH
57658: FOR_TO
57659: IFFALSE 57695
// if value = array [ i ] then
57661: LD_VAR 0 2
57665: PUSH
57666: LD_VAR 0 1
57670: PUSH
57671: LD_VAR 0 4
57675: ARRAY
57676: EQUAL
57677: IFFALSE 57693
// begin result := i ;
57679: LD_ADDR_VAR 0 3
57683: PUSH
57684: LD_VAR 0 4
57688: ST_TO_ADDR
// exit ;
57689: POP
57690: POP
57691: GO 57697
// end ;
57693: GO 57658
57695: POP
57696: POP
// end ;
57697: LD_VAR 0 3
57701: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57702: LD_INT 0
57704: PPUSH
// vc_chassis := chassis ;
57705: LD_ADDR_OWVAR 37
57709: PUSH
57710: LD_VAR 0 1
57714: ST_TO_ADDR
// vc_engine := engine ;
57715: LD_ADDR_OWVAR 39
57719: PUSH
57720: LD_VAR 0 2
57724: ST_TO_ADDR
// vc_control := control ;
57725: LD_ADDR_OWVAR 38
57729: PUSH
57730: LD_VAR 0 3
57734: ST_TO_ADDR
// vc_weapon := weapon ;
57735: LD_ADDR_OWVAR 40
57739: PUSH
57740: LD_VAR 0 4
57744: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57745: LD_ADDR_OWVAR 41
57749: PUSH
57750: LD_VAR 0 5
57754: ST_TO_ADDR
// end ;
57755: LD_VAR 0 6
57759: RET
// export function WantPlant ( unit ) ; var task ; begin
57760: LD_INT 0
57762: PPUSH
57763: PPUSH
// result := false ;
57764: LD_ADDR_VAR 0 2
57768: PUSH
57769: LD_INT 0
57771: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57772: LD_ADDR_VAR 0 3
57776: PUSH
57777: LD_VAR 0 1
57781: PPUSH
57782: CALL_OW 437
57786: ST_TO_ADDR
// if task then
57787: LD_VAR 0 3
57791: IFFALSE 57819
// if task [ 1 ] [ 1 ] = p then
57793: LD_VAR 0 3
57797: PUSH
57798: LD_INT 1
57800: ARRAY
57801: PUSH
57802: LD_INT 1
57804: ARRAY
57805: PUSH
57806: LD_STRING p
57808: EQUAL
57809: IFFALSE 57819
// result := true ;
57811: LD_ADDR_VAR 0 2
57815: PUSH
57816: LD_INT 1
57818: ST_TO_ADDR
// end ;
57819: LD_VAR 0 2
57823: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57824: LD_INT 0
57826: PPUSH
57827: PPUSH
57828: PPUSH
57829: PPUSH
// if pos < 1 then
57830: LD_VAR 0 2
57834: PUSH
57835: LD_INT 1
57837: LESS
57838: IFFALSE 57842
// exit ;
57840: GO 58145
// if pos = 1 then
57842: LD_VAR 0 2
57846: PUSH
57847: LD_INT 1
57849: EQUAL
57850: IFFALSE 57883
// result := Replace ( arr , pos [ 1 ] , value ) else
57852: LD_ADDR_VAR 0 4
57856: PUSH
57857: LD_VAR 0 1
57861: PPUSH
57862: LD_VAR 0 2
57866: PUSH
57867: LD_INT 1
57869: ARRAY
57870: PPUSH
57871: LD_VAR 0 3
57875: PPUSH
57876: CALL_OW 1
57880: ST_TO_ADDR
57881: GO 58145
// begin tmp := arr ;
57883: LD_ADDR_VAR 0 6
57887: PUSH
57888: LD_VAR 0 1
57892: ST_TO_ADDR
// s_arr := [ tmp ] ;
57893: LD_ADDR_VAR 0 7
57897: PUSH
57898: LD_VAR 0 6
57902: PUSH
57903: EMPTY
57904: LIST
57905: ST_TO_ADDR
// for i = 1 to pos - 1 do
57906: LD_ADDR_VAR 0 5
57910: PUSH
57911: DOUBLE
57912: LD_INT 1
57914: DEC
57915: ST_TO_ADDR
57916: LD_VAR 0 2
57920: PUSH
57921: LD_INT 1
57923: MINUS
57924: PUSH
57925: FOR_TO
57926: IFFALSE 57971
// begin tmp := tmp [ pos [ i ] ] ;
57928: LD_ADDR_VAR 0 6
57932: PUSH
57933: LD_VAR 0 6
57937: PUSH
57938: LD_VAR 0 2
57942: PUSH
57943: LD_VAR 0 5
57947: ARRAY
57948: ARRAY
57949: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57950: LD_ADDR_VAR 0 7
57954: PUSH
57955: LD_VAR 0 7
57959: PUSH
57960: LD_VAR 0 6
57964: PUSH
57965: EMPTY
57966: LIST
57967: ADD
57968: ST_TO_ADDR
// end ;
57969: GO 57925
57971: POP
57972: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57973: LD_ADDR_VAR 0 6
57977: PUSH
57978: LD_VAR 0 6
57982: PPUSH
57983: LD_VAR 0 2
57987: PUSH
57988: LD_VAR 0 2
57992: ARRAY
57993: PPUSH
57994: LD_VAR 0 3
57998: PPUSH
57999: CALL_OW 1
58003: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
58004: LD_ADDR_VAR 0 7
58008: PUSH
58009: LD_VAR 0 7
58013: PPUSH
58014: LD_VAR 0 7
58018: PPUSH
58019: LD_VAR 0 6
58023: PPUSH
58024: CALL_OW 1
58028: ST_TO_ADDR
// for i = s_arr downto 2 do
58029: LD_ADDR_VAR 0 5
58033: PUSH
58034: DOUBLE
58035: LD_VAR 0 7
58039: INC
58040: ST_TO_ADDR
58041: LD_INT 2
58043: PUSH
58044: FOR_DOWNTO
58045: IFFALSE 58129
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58047: LD_ADDR_VAR 0 6
58051: PUSH
58052: LD_VAR 0 7
58056: PUSH
58057: LD_VAR 0 5
58061: PUSH
58062: LD_INT 1
58064: MINUS
58065: ARRAY
58066: PPUSH
58067: LD_VAR 0 2
58071: PUSH
58072: LD_VAR 0 5
58076: PUSH
58077: LD_INT 1
58079: MINUS
58080: ARRAY
58081: PPUSH
58082: LD_VAR 0 7
58086: PUSH
58087: LD_VAR 0 5
58091: ARRAY
58092: PPUSH
58093: CALL_OW 1
58097: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58098: LD_ADDR_VAR 0 7
58102: PUSH
58103: LD_VAR 0 7
58107: PPUSH
58108: LD_VAR 0 5
58112: PUSH
58113: LD_INT 1
58115: MINUS
58116: PPUSH
58117: LD_VAR 0 6
58121: PPUSH
58122: CALL_OW 1
58126: ST_TO_ADDR
// end ;
58127: GO 58044
58129: POP
58130: POP
// result := s_arr [ 1 ] ;
58131: LD_ADDR_VAR 0 4
58135: PUSH
58136: LD_VAR 0 7
58140: PUSH
58141: LD_INT 1
58143: ARRAY
58144: ST_TO_ADDR
// end ; end ;
58145: LD_VAR 0 4
58149: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58150: LD_INT 0
58152: PPUSH
58153: PPUSH
// if not list then
58154: LD_VAR 0 1
58158: NOT
58159: IFFALSE 58163
// exit ;
58161: GO 58254
// i := list [ pos1 ] ;
58163: LD_ADDR_VAR 0 5
58167: PUSH
58168: LD_VAR 0 1
58172: PUSH
58173: LD_VAR 0 2
58177: ARRAY
58178: ST_TO_ADDR
// if not i then
58179: LD_VAR 0 5
58183: NOT
58184: IFFALSE 58188
// exit ;
58186: GO 58254
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58188: LD_ADDR_VAR 0 1
58192: PUSH
58193: LD_VAR 0 1
58197: PPUSH
58198: LD_VAR 0 2
58202: PPUSH
58203: LD_VAR 0 1
58207: PUSH
58208: LD_VAR 0 3
58212: ARRAY
58213: PPUSH
58214: CALL_OW 1
58218: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58219: LD_ADDR_VAR 0 1
58223: PUSH
58224: LD_VAR 0 1
58228: PPUSH
58229: LD_VAR 0 3
58233: PPUSH
58234: LD_VAR 0 5
58238: PPUSH
58239: CALL_OW 1
58243: ST_TO_ADDR
// result := list ;
58244: LD_ADDR_VAR 0 4
58248: PUSH
58249: LD_VAR 0 1
58253: ST_TO_ADDR
// end ;
58254: LD_VAR 0 4
58258: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58259: LD_INT 0
58261: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58262: LD_ADDR_VAR 0 5
58266: PUSH
58267: LD_VAR 0 1
58271: PPUSH
58272: CALL_OW 250
58276: PPUSH
58277: LD_VAR 0 1
58281: PPUSH
58282: CALL_OW 251
58286: PPUSH
58287: LD_VAR 0 2
58291: PPUSH
58292: LD_VAR 0 3
58296: PPUSH
58297: LD_VAR 0 4
58301: PPUSH
58302: CALL 58680 0 5
58306: ST_TO_ADDR
// end ;
58307: LD_VAR 0 5
58311: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
58312: LD_INT 0
58314: PPUSH
58315: PPUSH
58316: PPUSH
58317: PPUSH
// if not list or not unit then
58318: LD_VAR 0 2
58322: NOT
58323: PUSH
58324: LD_VAR 0 1
58328: NOT
58329: OR
58330: IFFALSE 58334
// exit ;
58332: GO 58675
// result := [ ] ;
58334: LD_ADDR_VAR 0 5
58338: PUSH
58339: EMPTY
58340: ST_TO_ADDR
// for i in list do
58341: LD_ADDR_VAR 0 6
58345: PUSH
58346: LD_VAR 0 2
58350: PUSH
58351: FOR_IN
58352: IFFALSE 58570
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
58354: LD_ADDR_VAR 0 8
58358: PUSH
58359: LD_VAR 0 1
58363: PPUSH
58364: LD_VAR 0 6
58368: PUSH
58369: LD_INT 1
58371: ARRAY
58372: PPUSH
58373: LD_VAR 0 6
58377: PUSH
58378: LD_INT 2
58380: ARRAY
58381: PPUSH
58382: CALL_OW 297
58386: ST_TO_ADDR
// if not Count ( result ) then
58387: LD_VAR 0 5
58391: PPUSH
58392: CALL 54964 0 1
58396: NOT
58397: IFFALSE 58430
// begin result := Join ( result , [ i , tmp ] ) ;
58399: LD_ADDR_VAR 0 5
58403: PUSH
58404: LD_VAR 0 5
58408: PPUSH
58409: LD_VAR 0 6
58413: PUSH
58414: LD_VAR 0 8
58418: PUSH
58419: EMPTY
58420: LIST
58421: LIST
58422: PPUSH
58423: CALL 90564 0 2
58427: ST_TO_ADDR
// continue ;
58428: GO 58351
// end ; if result [ result ] [ 2 ] <= tmp then
58430: LD_VAR 0 5
58434: PUSH
58435: LD_VAR 0 5
58439: ARRAY
58440: PUSH
58441: LD_INT 2
58443: ARRAY
58444: PUSH
58445: LD_VAR 0 8
58449: LESSEQUAL
58450: IFFALSE 58483
// result := Join ( result , [ i , tmp ] ) else
58452: LD_ADDR_VAR 0 5
58456: PUSH
58457: LD_VAR 0 5
58461: PPUSH
58462: LD_VAR 0 6
58466: PUSH
58467: LD_VAR 0 8
58471: PUSH
58472: EMPTY
58473: LIST
58474: LIST
58475: PPUSH
58476: CALL 90564 0 2
58480: ST_TO_ADDR
58481: GO 58568
// begin for j := 1 to Count ( result ) do
58483: LD_ADDR_VAR 0 7
58487: PUSH
58488: DOUBLE
58489: LD_INT 1
58491: DEC
58492: ST_TO_ADDR
58493: LD_VAR 0 5
58497: PPUSH
58498: CALL 54964 0 1
58502: PUSH
58503: FOR_TO
58504: IFFALSE 58566
// begin if tmp < result [ j ] [ 2 ] then
58506: LD_VAR 0 8
58510: PUSH
58511: LD_VAR 0 5
58515: PUSH
58516: LD_VAR 0 7
58520: ARRAY
58521: PUSH
58522: LD_INT 2
58524: ARRAY
58525: LESS
58526: IFFALSE 58564
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58528: LD_ADDR_VAR 0 5
58532: PUSH
58533: LD_VAR 0 5
58537: PPUSH
58538: LD_VAR 0 7
58542: PPUSH
58543: LD_VAR 0 6
58547: PUSH
58548: LD_VAR 0 8
58552: PUSH
58553: EMPTY
58554: LIST
58555: LIST
58556: PPUSH
58557: CALL_OW 2
58561: ST_TO_ADDR
// break ;
58562: GO 58566
// end ; end ;
58564: GO 58503
58566: POP
58567: POP
// end ; end ;
58568: GO 58351
58570: POP
58571: POP
// if result and not asc then
58572: LD_VAR 0 5
58576: PUSH
58577: LD_VAR 0 3
58581: NOT
58582: AND
58583: IFFALSE 58600
// result := ReverseArray ( result ) ;
58585: LD_ADDR_VAR 0 5
58589: PUSH
58590: LD_VAR 0 5
58594: PPUSH
58595: CALL 85840 0 1
58599: ST_TO_ADDR
// tmp := [ ] ;
58600: LD_ADDR_VAR 0 8
58604: PUSH
58605: EMPTY
58606: ST_TO_ADDR
// if mode then
58607: LD_VAR 0 4
58611: IFFALSE 58675
// begin for i := 1 to result do
58613: LD_ADDR_VAR 0 6
58617: PUSH
58618: DOUBLE
58619: LD_INT 1
58621: DEC
58622: ST_TO_ADDR
58623: LD_VAR 0 5
58627: PUSH
58628: FOR_TO
58629: IFFALSE 58663
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
58631: LD_ADDR_VAR 0 8
58635: PUSH
58636: LD_VAR 0 8
58640: PPUSH
58641: LD_VAR 0 5
58645: PUSH
58646: LD_VAR 0 6
58650: ARRAY
58651: PUSH
58652: LD_INT 1
58654: ARRAY
58655: PPUSH
58656: CALL 90564 0 2
58660: ST_TO_ADDR
58661: GO 58628
58663: POP
58664: POP
// result := tmp ;
58665: LD_ADDR_VAR 0 5
58669: PUSH
58670: LD_VAR 0 8
58674: ST_TO_ADDR
// end ; end ;
58675: LD_VAR 0 5
58679: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58680: LD_INT 0
58682: PPUSH
58683: PPUSH
58684: PPUSH
58685: PPUSH
// if not list then
58686: LD_VAR 0 3
58690: NOT
58691: IFFALSE 58695
// exit ;
58693: GO 59083
// result := [ ] ;
58695: LD_ADDR_VAR 0 6
58699: PUSH
58700: EMPTY
58701: ST_TO_ADDR
// for i in list do
58702: LD_ADDR_VAR 0 7
58706: PUSH
58707: LD_VAR 0 3
58711: PUSH
58712: FOR_IN
58713: IFFALSE 58915
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58715: LD_ADDR_VAR 0 9
58719: PUSH
58720: LD_VAR 0 7
58724: PPUSH
58725: LD_VAR 0 1
58729: PPUSH
58730: LD_VAR 0 2
58734: PPUSH
58735: CALL_OW 297
58739: ST_TO_ADDR
// if not result then
58740: LD_VAR 0 6
58744: NOT
58745: IFFALSE 58771
// result := [ [ i , tmp ] ] else
58747: LD_ADDR_VAR 0 6
58751: PUSH
58752: LD_VAR 0 7
58756: PUSH
58757: LD_VAR 0 9
58761: PUSH
58762: EMPTY
58763: LIST
58764: LIST
58765: PUSH
58766: EMPTY
58767: LIST
58768: ST_TO_ADDR
58769: GO 58913
// begin if result [ result ] [ 2 ] < tmp then
58771: LD_VAR 0 6
58775: PUSH
58776: LD_VAR 0 6
58780: ARRAY
58781: PUSH
58782: LD_INT 2
58784: ARRAY
58785: PUSH
58786: LD_VAR 0 9
58790: LESS
58791: IFFALSE 58833
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58793: LD_ADDR_VAR 0 6
58797: PUSH
58798: LD_VAR 0 6
58802: PPUSH
58803: LD_VAR 0 6
58807: PUSH
58808: LD_INT 1
58810: PLUS
58811: PPUSH
58812: LD_VAR 0 7
58816: PUSH
58817: LD_VAR 0 9
58821: PUSH
58822: EMPTY
58823: LIST
58824: LIST
58825: PPUSH
58826: CALL_OW 2
58830: ST_TO_ADDR
58831: GO 58913
// for j = 1 to result do
58833: LD_ADDR_VAR 0 8
58837: PUSH
58838: DOUBLE
58839: LD_INT 1
58841: DEC
58842: ST_TO_ADDR
58843: LD_VAR 0 6
58847: PUSH
58848: FOR_TO
58849: IFFALSE 58911
// begin if tmp < result [ j ] [ 2 ] then
58851: LD_VAR 0 9
58855: PUSH
58856: LD_VAR 0 6
58860: PUSH
58861: LD_VAR 0 8
58865: ARRAY
58866: PUSH
58867: LD_INT 2
58869: ARRAY
58870: LESS
58871: IFFALSE 58909
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58873: LD_ADDR_VAR 0 6
58877: PUSH
58878: LD_VAR 0 6
58882: PPUSH
58883: LD_VAR 0 8
58887: PPUSH
58888: LD_VAR 0 7
58892: PUSH
58893: LD_VAR 0 9
58897: PUSH
58898: EMPTY
58899: LIST
58900: LIST
58901: PPUSH
58902: CALL_OW 2
58906: ST_TO_ADDR
// break ;
58907: GO 58911
// end ; end ;
58909: GO 58848
58911: POP
58912: POP
// end ; end ;
58913: GO 58712
58915: POP
58916: POP
// if result and not asc then
58917: LD_VAR 0 6
58921: PUSH
58922: LD_VAR 0 4
58926: NOT
58927: AND
58928: IFFALSE 59003
// begin tmp := result ;
58930: LD_ADDR_VAR 0 9
58934: PUSH
58935: LD_VAR 0 6
58939: ST_TO_ADDR
// for i = tmp downto 1 do
58940: LD_ADDR_VAR 0 7
58944: PUSH
58945: DOUBLE
58946: LD_VAR 0 9
58950: INC
58951: ST_TO_ADDR
58952: LD_INT 1
58954: PUSH
58955: FOR_DOWNTO
58956: IFFALSE 59001
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58958: LD_ADDR_VAR 0 6
58962: PUSH
58963: LD_VAR 0 6
58967: PPUSH
58968: LD_VAR 0 9
58972: PUSH
58973: LD_VAR 0 7
58977: MINUS
58978: PUSH
58979: LD_INT 1
58981: PLUS
58982: PPUSH
58983: LD_VAR 0 9
58987: PUSH
58988: LD_VAR 0 7
58992: ARRAY
58993: PPUSH
58994: CALL_OW 1
58998: ST_TO_ADDR
58999: GO 58955
59001: POP
59002: POP
// end ; tmp := [ ] ;
59003: LD_ADDR_VAR 0 9
59007: PUSH
59008: EMPTY
59009: ST_TO_ADDR
// if mode then
59010: LD_VAR 0 5
59014: IFFALSE 59083
// begin for i = 1 to result do
59016: LD_ADDR_VAR 0 7
59020: PUSH
59021: DOUBLE
59022: LD_INT 1
59024: DEC
59025: ST_TO_ADDR
59026: LD_VAR 0 6
59030: PUSH
59031: FOR_TO
59032: IFFALSE 59071
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
59034: LD_ADDR_VAR 0 9
59038: PUSH
59039: LD_VAR 0 9
59043: PPUSH
59044: LD_VAR 0 7
59048: PPUSH
59049: LD_VAR 0 6
59053: PUSH
59054: LD_VAR 0 7
59058: ARRAY
59059: PUSH
59060: LD_INT 1
59062: ARRAY
59063: PPUSH
59064: CALL_OW 1
59068: ST_TO_ADDR
59069: GO 59031
59071: POP
59072: POP
// result := tmp ;
59073: LD_ADDR_VAR 0 6
59077: PUSH
59078: LD_VAR 0 9
59082: ST_TO_ADDR
// end ; end ;
59083: LD_VAR 0 6
59087: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
59088: LD_INT 0
59090: PPUSH
59091: PPUSH
59092: PPUSH
59093: PPUSH
59094: PPUSH
59095: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
59096: LD_ADDR_VAR 0 5
59100: PUSH
59101: LD_INT 0
59103: PUSH
59104: LD_INT 0
59106: PUSH
59107: LD_INT 0
59109: PUSH
59110: EMPTY
59111: PUSH
59112: EMPTY
59113: LIST
59114: LIST
59115: LIST
59116: LIST
59117: ST_TO_ADDR
// if not x or not y then
59118: LD_VAR 0 2
59122: NOT
59123: PUSH
59124: LD_VAR 0 3
59128: NOT
59129: OR
59130: IFFALSE 59134
// exit ;
59132: GO 60784
// if not range then
59134: LD_VAR 0 4
59138: NOT
59139: IFFALSE 59149
// range := 10 ;
59141: LD_ADDR_VAR 0 4
59145: PUSH
59146: LD_INT 10
59148: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
59149: LD_ADDR_VAR 0 8
59153: PUSH
59154: LD_INT 81
59156: PUSH
59157: LD_VAR 0 1
59161: PUSH
59162: EMPTY
59163: LIST
59164: LIST
59165: PUSH
59166: LD_INT 92
59168: PUSH
59169: LD_VAR 0 2
59173: PUSH
59174: LD_VAR 0 3
59178: PUSH
59179: LD_VAR 0 4
59183: PUSH
59184: EMPTY
59185: LIST
59186: LIST
59187: LIST
59188: LIST
59189: PUSH
59190: LD_INT 3
59192: PUSH
59193: LD_INT 21
59195: PUSH
59196: LD_INT 3
59198: PUSH
59199: EMPTY
59200: LIST
59201: LIST
59202: PUSH
59203: EMPTY
59204: LIST
59205: LIST
59206: PUSH
59207: EMPTY
59208: LIST
59209: LIST
59210: LIST
59211: PPUSH
59212: CALL_OW 69
59216: ST_TO_ADDR
// if not tmp then
59217: LD_VAR 0 8
59221: NOT
59222: IFFALSE 59226
// exit ;
59224: GO 60784
// for i in tmp do
59226: LD_ADDR_VAR 0 6
59230: PUSH
59231: LD_VAR 0 8
59235: PUSH
59236: FOR_IN
59237: IFFALSE 60759
// begin points := [ 0 , 0 , 0 ] ;
59239: LD_ADDR_VAR 0 9
59243: PUSH
59244: LD_INT 0
59246: PUSH
59247: LD_INT 0
59249: PUSH
59250: LD_INT 0
59252: PUSH
59253: EMPTY
59254: LIST
59255: LIST
59256: LIST
59257: ST_TO_ADDR
// bpoints := 1 ;
59258: LD_ADDR_VAR 0 10
59262: PUSH
59263: LD_INT 1
59265: ST_TO_ADDR
// case GetType ( i ) of unit_human :
59266: LD_VAR 0 6
59270: PPUSH
59271: CALL_OW 247
59275: PUSH
59276: LD_INT 1
59278: DOUBLE
59279: EQUAL
59280: IFTRUE 59284
59282: GO 59862
59284: POP
// begin if GetClass ( i ) = 1 then
59285: LD_VAR 0 6
59289: PPUSH
59290: CALL_OW 257
59294: PUSH
59295: LD_INT 1
59297: EQUAL
59298: IFFALSE 59319
// points := [ 10 , 5 , 3 ] ;
59300: LD_ADDR_VAR 0 9
59304: PUSH
59305: LD_INT 10
59307: PUSH
59308: LD_INT 5
59310: PUSH
59311: LD_INT 3
59313: PUSH
59314: EMPTY
59315: LIST
59316: LIST
59317: LIST
59318: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
59319: LD_VAR 0 6
59323: PPUSH
59324: CALL_OW 257
59328: PUSH
59329: LD_INT 2
59331: PUSH
59332: LD_INT 3
59334: PUSH
59335: LD_INT 4
59337: PUSH
59338: EMPTY
59339: LIST
59340: LIST
59341: LIST
59342: IN
59343: IFFALSE 59364
// points := [ 3 , 2 , 1 ] ;
59345: LD_ADDR_VAR 0 9
59349: PUSH
59350: LD_INT 3
59352: PUSH
59353: LD_INT 2
59355: PUSH
59356: LD_INT 1
59358: PUSH
59359: EMPTY
59360: LIST
59361: LIST
59362: LIST
59363: ST_TO_ADDR
// if GetClass ( i ) = 5 then
59364: LD_VAR 0 6
59368: PPUSH
59369: CALL_OW 257
59373: PUSH
59374: LD_INT 5
59376: EQUAL
59377: IFFALSE 59398
// points := [ 130 , 5 , 2 ] ;
59379: LD_ADDR_VAR 0 9
59383: PUSH
59384: LD_INT 130
59386: PUSH
59387: LD_INT 5
59389: PUSH
59390: LD_INT 2
59392: PUSH
59393: EMPTY
59394: LIST
59395: LIST
59396: LIST
59397: ST_TO_ADDR
// if GetClass ( i ) = 8 then
59398: LD_VAR 0 6
59402: PPUSH
59403: CALL_OW 257
59407: PUSH
59408: LD_INT 8
59410: EQUAL
59411: IFFALSE 59432
// points := [ 35 , 35 , 30 ] ;
59413: LD_ADDR_VAR 0 9
59417: PUSH
59418: LD_INT 35
59420: PUSH
59421: LD_INT 35
59423: PUSH
59424: LD_INT 30
59426: PUSH
59427: EMPTY
59428: LIST
59429: LIST
59430: LIST
59431: ST_TO_ADDR
// if GetClass ( i ) = 9 then
59432: LD_VAR 0 6
59436: PPUSH
59437: CALL_OW 257
59441: PUSH
59442: LD_INT 9
59444: EQUAL
59445: IFFALSE 59466
// points := [ 20 , 55 , 40 ] ;
59447: LD_ADDR_VAR 0 9
59451: PUSH
59452: LD_INT 20
59454: PUSH
59455: LD_INT 55
59457: PUSH
59458: LD_INT 40
59460: PUSH
59461: EMPTY
59462: LIST
59463: LIST
59464: LIST
59465: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59466: LD_VAR 0 6
59470: PPUSH
59471: CALL_OW 257
59475: PUSH
59476: LD_INT 12
59478: PUSH
59479: LD_INT 16
59481: PUSH
59482: EMPTY
59483: LIST
59484: LIST
59485: IN
59486: IFFALSE 59507
// points := [ 5 , 3 , 2 ] ;
59488: LD_ADDR_VAR 0 9
59492: PUSH
59493: LD_INT 5
59495: PUSH
59496: LD_INT 3
59498: PUSH
59499: LD_INT 2
59501: PUSH
59502: EMPTY
59503: LIST
59504: LIST
59505: LIST
59506: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59507: LD_VAR 0 6
59511: PPUSH
59512: CALL_OW 257
59516: PUSH
59517: LD_INT 17
59519: EQUAL
59520: IFFALSE 59541
// points := [ 100 , 50 , 75 ] ;
59522: LD_ADDR_VAR 0 9
59526: PUSH
59527: LD_INT 100
59529: PUSH
59530: LD_INT 50
59532: PUSH
59533: LD_INT 75
59535: PUSH
59536: EMPTY
59537: LIST
59538: LIST
59539: LIST
59540: ST_TO_ADDR
// if GetClass ( i ) = 15 then
59541: LD_VAR 0 6
59545: PPUSH
59546: CALL_OW 257
59550: PUSH
59551: LD_INT 15
59553: EQUAL
59554: IFFALSE 59575
// points := [ 10 , 5 , 3 ] ;
59556: LD_ADDR_VAR 0 9
59560: PUSH
59561: LD_INT 10
59563: PUSH
59564: LD_INT 5
59566: PUSH
59567: LD_INT 3
59569: PUSH
59570: EMPTY
59571: LIST
59572: LIST
59573: LIST
59574: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59575: LD_VAR 0 6
59579: PPUSH
59580: CALL_OW 257
59584: PUSH
59585: LD_INT 14
59587: EQUAL
59588: IFFALSE 59609
// points := [ 10 , 0 , 0 ] ;
59590: LD_ADDR_VAR 0 9
59594: PUSH
59595: LD_INT 10
59597: PUSH
59598: LD_INT 0
59600: PUSH
59601: LD_INT 0
59603: PUSH
59604: EMPTY
59605: LIST
59606: LIST
59607: LIST
59608: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59609: LD_VAR 0 6
59613: PPUSH
59614: CALL_OW 257
59618: PUSH
59619: LD_INT 11
59621: EQUAL
59622: IFFALSE 59643
// points := [ 30 , 10 , 5 ] ;
59624: LD_ADDR_VAR 0 9
59628: PUSH
59629: LD_INT 30
59631: PUSH
59632: LD_INT 10
59634: PUSH
59635: LD_INT 5
59637: PUSH
59638: EMPTY
59639: LIST
59640: LIST
59641: LIST
59642: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59643: LD_VAR 0 1
59647: PPUSH
59648: LD_INT 5
59650: PPUSH
59651: CALL_OW 321
59655: PUSH
59656: LD_INT 2
59658: EQUAL
59659: IFFALSE 59676
// bpoints := bpoints * 1.8 ;
59661: LD_ADDR_VAR 0 10
59665: PUSH
59666: LD_VAR 0 10
59670: PUSH
59671: LD_REAL  1.80000000000000E+0000
59674: MUL
59675: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59676: LD_VAR 0 6
59680: PPUSH
59681: CALL_OW 257
59685: PUSH
59686: LD_INT 1
59688: PUSH
59689: LD_INT 2
59691: PUSH
59692: LD_INT 3
59694: PUSH
59695: LD_INT 4
59697: PUSH
59698: EMPTY
59699: LIST
59700: LIST
59701: LIST
59702: LIST
59703: IN
59704: PUSH
59705: LD_VAR 0 1
59709: PPUSH
59710: LD_INT 51
59712: PPUSH
59713: CALL_OW 321
59717: PUSH
59718: LD_INT 2
59720: EQUAL
59721: AND
59722: IFFALSE 59739
// bpoints := bpoints * 1.2 ;
59724: LD_ADDR_VAR 0 10
59728: PUSH
59729: LD_VAR 0 10
59733: PUSH
59734: LD_REAL  1.20000000000000E+0000
59737: MUL
59738: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59739: LD_VAR 0 6
59743: PPUSH
59744: CALL_OW 257
59748: PUSH
59749: LD_INT 5
59751: PUSH
59752: LD_INT 7
59754: PUSH
59755: LD_INT 9
59757: PUSH
59758: EMPTY
59759: LIST
59760: LIST
59761: LIST
59762: IN
59763: PUSH
59764: LD_VAR 0 1
59768: PPUSH
59769: LD_INT 52
59771: PPUSH
59772: CALL_OW 321
59776: PUSH
59777: LD_INT 2
59779: EQUAL
59780: AND
59781: IFFALSE 59798
// bpoints := bpoints * 1.5 ;
59783: LD_ADDR_VAR 0 10
59787: PUSH
59788: LD_VAR 0 10
59792: PUSH
59793: LD_REAL  1.50000000000000E+0000
59796: MUL
59797: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59798: LD_VAR 0 1
59802: PPUSH
59803: LD_INT 66
59805: PPUSH
59806: CALL_OW 321
59810: PUSH
59811: LD_INT 2
59813: EQUAL
59814: IFFALSE 59831
// bpoints := bpoints * 1.1 ;
59816: LD_ADDR_VAR 0 10
59820: PUSH
59821: LD_VAR 0 10
59825: PUSH
59826: LD_REAL  1.10000000000000E+0000
59829: MUL
59830: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59831: LD_ADDR_VAR 0 10
59835: PUSH
59836: LD_VAR 0 10
59840: PUSH
59841: LD_VAR 0 6
59845: PPUSH
59846: LD_INT 1
59848: PPUSH
59849: CALL_OW 259
59853: PUSH
59854: LD_REAL  1.15000000000000E+0000
59857: MUL
59858: MUL
59859: ST_TO_ADDR
// end ; unit_vehicle :
59860: GO 60688
59862: LD_INT 2
59864: DOUBLE
59865: EQUAL
59866: IFTRUE 59870
59868: GO 60676
59870: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59871: LD_VAR 0 6
59875: PPUSH
59876: CALL_OW 264
59880: PUSH
59881: LD_INT 2
59883: PUSH
59884: LD_INT 42
59886: PUSH
59887: LD_INT 24
59889: PUSH
59890: EMPTY
59891: LIST
59892: LIST
59893: LIST
59894: IN
59895: IFFALSE 59916
// points := [ 25 , 5 , 3 ] ;
59897: LD_ADDR_VAR 0 9
59901: PUSH
59902: LD_INT 25
59904: PUSH
59905: LD_INT 5
59907: PUSH
59908: LD_INT 3
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: LIST
59915: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59916: LD_VAR 0 6
59920: PPUSH
59921: CALL_OW 264
59925: PUSH
59926: LD_INT 4
59928: PUSH
59929: LD_INT 43
59931: PUSH
59932: LD_INT 25
59934: PUSH
59935: EMPTY
59936: LIST
59937: LIST
59938: LIST
59939: IN
59940: IFFALSE 59961
// points := [ 40 , 15 , 5 ] ;
59942: LD_ADDR_VAR 0 9
59946: PUSH
59947: LD_INT 40
59949: PUSH
59950: LD_INT 15
59952: PUSH
59953: LD_INT 5
59955: PUSH
59956: EMPTY
59957: LIST
59958: LIST
59959: LIST
59960: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59961: LD_VAR 0 6
59965: PPUSH
59966: CALL_OW 264
59970: PUSH
59971: LD_INT 3
59973: PUSH
59974: LD_INT 23
59976: PUSH
59977: EMPTY
59978: LIST
59979: LIST
59980: IN
59981: IFFALSE 60002
// points := [ 7 , 25 , 8 ] ;
59983: LD_ADDR_VAR 0 9
59987: PUSH
59988: LD_INT 7
59990: PUSH
59991: LD_INT 25
59993: PUSH
59994: LD_INT 8
59996: PUSH
59997: EMPTY
59998: LIST
59999: LIST
60000: LIST
60001: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
60002: LD_VAR 0 6
60006: PPUSH
60007: CALL_OW 264
60011: PUSH
60012: LD_INT 5
60014: PUSH
60015: LD_INT 27
60017: PUSH
60018: LD_INT 44
60020: PUSH
60021: EMPTY
60022: LIST
60023: LIST
60024: LIST
60025: IN
60026: IFFALSE 60047
// points := [ 14 , 50 , 16 ] ;
60028: LD_ADDR_VAR 0 9
60032: PUSH
60033: LD_INT 14
60035: PUSH
60036: LD_INT 50
60038: PUSH
60039: LD_INT 16
60041: PUSH
60042: EMPTY
60043: LIST
60044: LIST
60045: LIST
60046: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
60047: LD_VAR 0 6
60051: PPUSH
60052: CALL_OW 264
60056: PUSH
60057: LD_INT 6
60059: PUSH
60060: LD_INT 46
60062: PUSH
60063: EMPTY
60064: LIST
60065: LIST
60066: IN
60067: IFFALSE 60088
// points := [ 32 , 120 , 70 ] ;
60069: LD_ADDR_VAR 0 9
60073: PUSH
60074: LD_INT 32
60076: PUSH
60077: LD_INT 120
60079: PUSH
60080: LD_INT 70
60082: PUSH
60083: EMPTY
60084: LIST
60085: LIST
60086: LIST
60087: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
60088: LD_VAR 0 6
60092: PPUSH
60093: CALL_OW 264
60097: PUSH
60098: LD_INT 7
60100: PUSH
60101: LD_INT 28
60103: PUSH
60104: LD_INT 45
60106: PUSH
60107: LD_INT 92
60109: PUSH
60110: EMPTY
60111: LIST
60112: LIST
60113: LIST
60114: LIST
60115: IN
60116: IFFALSE 60137
// points := [ 35 , 20 , 45 ] ;
60118: LD_ADDR_VAR 0 9
60122: PUSH
60123: LD_INT 35
60125: PUSH
60126: LD_INT 20
60128: PUSH
60129: LD_INT 45
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: LIST
60136: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
60137: LD_VAR 0 6
60141: PPUSH
60142: CALL_OW 264
60146: PUSH
60147: LD_INT 47
60149: PUSH
60150: EMPTY
60151: LIST
60152: IN
60153: IFFALSE 60174
// points := [ 67 , 45 , 75 ] ;
60155: LD_ADDR_VAR 0 9
60159: PUSH
60160: LD_INT 67
60162: PUSH
60163: LD_INT 45
60165: PUSH
60166: LD_INT 75
60168: PUSH
60169: EMPTY
60170: LIST
60171: LIST
60172: LIST
60173: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
60174: LD_VAR 0 6
60178: PPUSH
60179: CALL_OW 264
60183: PUSH
60184: LD_INT 26
60186: PUSH
60187: EMPTY
60188: LIST
60189: IN
60190: IFFALSE 60211
// points := [ 120 , 30 , 80 ] ;
60192: LD_ADDR_VAR 0 9
60196: PUSH
60197: LD_INT 120
60199: PUSH
60200: LD_INT 30
60202: PUSH
60203: LD_INT 80
60205: PUSH
60206: EMPTY
60207: LIST
60208: LIST
60209: LIST
60210: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
60211: LD_VAR 0 6
60215: PPUSH
60216: CALL_OW 264
60220: PUSH
60221: LD_INT 22
60223: PUSH
60224: EMPTY
60225: LIST
60226: IN
60227: IFFALSE 60248
// points := [ 40 , 1 , 1 ] ;
60229: LD_ADDR_VAR 0 9
60233: PUSH
60234: LD_INT 40
60236: PUSH
60237: LD_INT 1
60239: PUSH
60240: LD_INT 1
60242: PUSH
60243: EMPTY
60244: LIST
60245: LIST
60246: LIST
60247: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
60248: LD_VAR 0 6
60252: PPUSH
60253: CALL_OW 264
60257: PUSH
60258: LD_INT 29
60260: PUSH
60261: EMPTY
60262: LIST
60263: IN
60264: IFFALSE 60285
// points := [ 70 , 200 , 400 ] ;
60266: LD_ADDR_VAR 0 9
60270: PUSH
60271: LD_INT 70
60273: PUSH
60274: LD_INT 200
60276: PUSH
60277: LD_INT 400
60279: PUSH
60280: EMPTY
60281: LIST
60282: LIST
60283: LIST
60284: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
60285: LD_VAR 0 6
60289: PPUSH
60290: CALL_OW 264
60294: PUSH
60295: LD_INT 14
60297: PUSH
60298: LD_INT 53
60300: PUSH
60301: EMPTY
60302: LIST
60303: LIST
60304: IN
60305: IFFALSE 60326
// points := [ 40 , 10 , 20 ] ;
60307: LD_ADDR_VAR 0 9
60311: PUSH
60312: LD_INT 40
60314: PUSH
60315: LD_INT 10
60317: PUSH
60318: LD_INT 20
60320: PUSH
60321: EMPTY
60322: LIST
60323: LIST
60324: LIST
60325: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
60326: LD_VAR 0 6
60330: PPUSH
60331: CALL_OW 264
60335: PUSH
60336: LD_INT 9
60338: PUSH
60339: EMPTY
60340: LIST
60341: IN
60342: IFFALSE 60363
// points := [ 5 , 70 , 20 ] ;
60344: LD_ADDR_VAR 0 9
60348: PUSH
60349: LD_INT 5
60351: PUSH
60352: LD_INT 70
60354: PUSH
60355: LD_INT 20
60357: PUSH
60358: EMPTY
60359: LIST
60360: LIST
60361: LIST
60362: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
60363: LD_VAR 0 6
60367: PPUSH
60368: CALL_OW 264
60372: PUSH
60373: LD_INT 10
60375: PUSH
60376: EMPTY
60377: LIST
60378: IN
60379: IFFALSE 60400
// points := [ 35 , 110 , 70 ] ;
60381: LD_ADDR_VAR 0 9
60385: PUSH
60386: LD_INT 35
60388: PUSH
60389: LD_INT 110
60391: PUSH
60392: LD_INT 70
60394: PUSH
60395: EMPTY
60396: LIST
60397: LIST
60398: LIST
60399: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
60400: LD_VAR 0 6
60404: PPUSH
60405: CALL_OW 265
60409: PUSH
60410: LD_INT 25
60412: EQUAL
60413: IFFALSE 60434
// points := [ 80 , 65 , 100 ] ;
60415: LD_ADDR_VAR 0 9
60419: PUSH
60420: LD_INT 80
60422: PUSH
60423: LD_INT 65
60425: PUSH
60426: LD_INT 100
60428: PUSH
60429: EMPTY
60430: LIST
60431: LIST
60432: LIST
60433: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
60434: LD_VAR 0 6
60438: PPUSH
60439: CALL_OW 263
60443: PUSH
60444: LD_INT 1
60446: EQUAL
60447: IFFALSE 60482
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
60449: LD_ADDR_VAR 0 10
60453: PUSH
60454: LD_VAR 0 10
60458: PUSH
60459: LD_VAR 0 6
60463: PPUSH
60464: CALL_OW 311
60468: PPUSH
60469: LD_INT 3
60471: PPUSH
60472: CALL_OW 259
60476: PUSH
60477: LD_INT 4
60479: MUL
60480: MUL
60481: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60482: LD_VAR 0 6
60486: PPUSH
60487: CALL_OW 263
60491: PUSH
60492: LD_INT 2
60494: EQUAL
60495: IFFALSE 60546
// begin j := IsControledBy ( i ) ;
60497: LD_ADDR_VAR 0 7
60501: PUSH
60502: LD_VAR 0 6
60506: PPUSH
60507: CALL_OW 312
60511: ST_TO_ADDR
// if j then
60512: LD_VAR 0 7
60516: IFFALSE 60546
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60518: LD_ADDR_VAR 0 10
60522: PUSH
60523: LD_VAR 0 10
60527: PUSH
60528: LD_VAR 0 7
60532: PPUSH
60533: LD_INT 3
60535: PPUSH
60536: CALL_OW 259
60540: PUSH
60541: LD_INT 3
60543: MUL
60544: MUL
60545: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
60546: LD_VAR 0 6
60550: PPUSH
60551: CALL_OW 264
60555: PUSH
60556: LD_INT 5
60558: PUSH
60559: LD_INT 6
60561: PUSH
60562: LD_INT 46
60564: PUSH
60565: LD_INT 44
60567: PUSH
60568: LD_INT 47
60570: PUSH
60571: LD_INT 45
60573: PUSH
60574: LD_INT 28
60576: PUSH
60577: LD_INT 7
60579: PUSH
60580: LD_INT 27
60582: PUSH
60583: LD_INT 29
60585: PUSH
60586: EMPTY
60587: LIST
60588: LIST
60589: LIST
60590: LIST
60591: LIST
60592: LIST
60593: LIST
60594: LIST
60595: LIST
60596: LIST
60597: IN
60598: PUSH
60599: LD_VAR 0 1
60603: PPUSH
60604: LD_INT 52
60606: PPUSH
60607: CALL_OW 321
60611: PUSH
60612: LD_INT 2
60614: EQUAL
60615: AND
60616: IFFALSE 60633
// bpoints := bpoints * 1.2 ;
60618: LD_ADDR_VAR 0 10
60622: PUSH
60623: LD_VAR 0 10
60627: PUSH
60628: LD_REAL  1.20000000000000E+0000
60631: MUL
60632: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60633: LD_VAR 0 6
60637: PPUSH
60638: CALL_OW 264
60642: PUSH
60643: LD_INT 6
60645: PUSH
60646: LD_INT 46
60648: PUSH
60649: LD_INT 47
60651: PUSH
60652: EMPTY
60653: LIST
60654: LIST
60655: LIST
60656: IN
60657: IFFALSE 60674
// bpoints := bpoints * 1.2 ;
60659: LD_ADDR_VAR 0 10
60663: PUSH
60664: LD_VAR 0 10
60668: PUSH
60669: LD_REAL  1.20000000000000E+0000
60672: MUL
60673: ST_TO_ADDR
// end ; unit_building :
60674: GO 60688
60676: LD_INT 3
60678: DOUBLE
60679: EQUAL
60680: IFTRUE 60684
60682: GO 60687
60684: POP
// ; end ;
60685: GO 60688
60687: POP
// for j = 1 to 3 do
60688: LD_ADDR_VAR 0 7
60692: PUSH
60693: DOUBLE
60694: LD_INT 1
60696: DEC
60697: ST_TO_ADDR
60698: LD_INT 3
60700: PUSH
60701: FOR_TO
60702: IFFALSE 60755
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60704: LD_ADDR_VAR 0 5
60708: PUSH
60709: LD_VAR 0 5
60713: PPUSH
60714: LD_VAR 0 7
60718: PPUSH
60719: LD_VAR 0 5
60723: PUSH
60724: LD_VAR 0 7
60728: ARRAY
60729: PUSH
60730: LD_VAR 0 9
60734: PUSH
60735: LD_VAR 0 7
60739: ARRAY
60740: PUSH
60741: LD_VAR 0 10
60745: MUL
60746: PLUS
60747: PPUSH
60748: CALL_OW 1
60752: ST_TO_ADDR
60753: GO 60701
60755: POP
60756: POP
// end ;
60757: GO 59236
60759: POP
60760: POP
// result := Replace ( result , 4 , tmp ) ;
60761: LD_ADDR_VAR 0 5
60765: PUSH
60766: LD_VAR 0 5
60770: PPUSH
60771: LD_INT 4
60773: PPUSH
60774: LD_VAR 0 8
60778: PPUSH
60779: CALL_OW 1
60783: ST_TO_ADDR
// end ;
60784: LD_VAR 0 5
60788: RET
// export function DangerAtRange ( unit , range ) ; begin
60789: LD_INT 0
60791: PPUSH
// if not unit then
60792: LD_VAR 0 1
60796: NOT
60797: IFFALSE 60801
// exit ;
60799: GO 60846
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60801: LD_ADDR_VAR 0 3
60805: PUSH
60806: LD_VAR 0 1
60810: PPUSH
60811: CALL_OW 255
60815: PPUSH
60816: LD_VAR 0 1
60820: PPUSH
60821: CALL_OW 250
60825: PPUSH
60826: LD_VAR 0 1
60830: PPUSH
60831: CALL_OW 251
60835: PPUSH
60836: LD_VAR 0 2
60840: PPUSH
60841: CALL 59088 0 4
60845: ST_TO_ADDR
// end ;
60846: LD_VAR 0 3
60850: RET
// export function DangerInArea ( side , area ) ; begin
60851: LD_INT 0
60853: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60854: LD_ADDR_VAR 0 3
60858: PUSH
60859: LD_VAR 0 2
60863: PPUSH
60864: LD_INT 81
60866: PUSH
60867: LD_VAR 0 1
60871: PUSH
60872: EMPTY
60873: LIST
60874: LIST
60875: PPUSH
60876: CALL_OW 70
60880: ST_TO_ADDR
// end ;
60881: LD_VAR 0 3
60885: RET
// export function IsExtension ( b ) ; begin
60886: LD_INT 0
60888: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60889: LD_ADDR_VAR 0 2
60893: PUSH
60894: LD_VAR 0 1
60898: PUSH
60899: LD_INT 23
60901: PUSH
60902: LD_INT 20
60904: PUSH
60905: LD_INT 22
60907: PUSH
60908: LD_INT 17
60910: PUSH
60911: LD_INT 24
60913: PUSH
60914: LD_INT 21
60916: PUSH
60917: LD_INT 19
60919: PUSH
60920: LD_INT 16
60922: PUSH
60923: LD_INT 25
60925: PUSH
60926: LD_INT 18
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: LIST
60933: LIST
60934: LIST
60935: LIST
60936: LIST
60937: LIST
60938: LIST
60939: LIST
60940: IN
60941: ST_TO_ADDR
// end ;
60942: LD_VAR 0 2
60946: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
60947: LD_INT 0
60949: PPUSH
60950: PPUSH
60951: PPUSH
// result := [ ] ;
60952: LD_ADDR_VAR 0 4
60956: PUSH
60957: EMPTY
60958: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60959: LD_ADDR_VAR 0 5
60963: PUSH
60964: LD_VAR 0 2
60968: PPUSH
60969: LD_INT 21
60971: PUSH
60972: LD_INT 3
60974: PUSH
60975: EMPTY
60976: LIST
60977: LIST
60978: PPUSH
60979: CALL_OW 70
60983: ST_TO_ADDR
// if not tmp then
60984: LD_VAR 0 5
60988: NOT
60989: IFFALSE 60993
// exit ;
60991: GO 61057
// if checkLink then
60993: LD_VAR 0 3
60997: IFFALSE 61047
// begin for i in tmp do
60999: LD_ADDR_VAR 0 6
61003: PUSH
61004: LD_VAR 0 5
61008: PUSH
61009: FOR_IN
61010: IFFALSE 61045
// if GetBase ( i ) <> base then
61012: LD_VAR 0 6
61016: PPUSH
61017: CALL_OW 274
61021: PUSH
61022: LD_VAR 0 1
61026: NONEQUAL
61027: IFFALSE 61043
// ComLinkToBase ( base , i ) ;
61029: LD_VAR 0 1
61033: PPUSH
61034: LD_VAR 0 6
61038: PPUSH
61039: CALL_OW 169
61043: GO 61009
61045: POP
61046: POP
// end ; result := tmp ;
61047: LD_ADDR_VAR 0 4
61051: PUSH
61052: LD_VAR 0 5
61056: ST_TO_ADDR
// end ;
61057: LD_VAR 0 4
61061: RET
// export function ComComplete ( units , b ) ; var i ; begin
61062: LD_INT 0
61064: PPUSH
61065: PPUSH
// if not units then
61066: LD_VAR 0 1
61070: NOT
61071: IFFALSE 61075
// exit ;
61073: GO 61165
// for i in units do
61075: LD_ADDR_VAR 0 4
61079: PUSH
61080: LD_VAR 0 1
61084: PUSH
61085: FOR_IN
61086: IFFALSE 61163
// if BuildingStatus ( b ) = bs_build then
61088: LD_VAR 0 2
61092: PPUSH
61093: CALL_OW 461
61097: PUSH
61098: LD_INT 1
61100: EQUAL
61101: IFFALSE 61161
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
61103: LD_VAR 0 4
61107: PPUSH
61108: LD_STRING h
61110: PUSH
61111: LD_VAR 0 2
61115: PPUSH
61116: CALL_OW 250
61120: PUSH
61121: LD_VAR 0 2
61125: PPUSH
61126: CALL_OW 251
61130: PUSH
61131: LD_VAR 0 2
61135: PUSH
61136: LD_INT 0
61138: PUSH
61139: LD_INT 0
61141: PUSH
61142: LD_INT 0
61144: PUSH
61145: EMPTY
61146: LIST
61147: LIST
61148: LIST
61149: LIST
61150: LIST
61151: LIST
61152: LIST
61153: PUSH
61154: EMPTY
61155: LIST
61156: PPUSH
61157: CALL_OW 446
61161: GO 61085
61163: POP
61164: POP
// end ;
61165: LD_VAR 0 3
61169: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
61170: LD_INT 0
61172: PPUSH
61173: PPUSH
61174: PPUSH
61175: PPUSH
61176: PPUSH
61177: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
61178: LD_VAR 0 1
61182: NOT
61183: PUSH
61184: LD_VAR 0 1
61188: PPUSH
61189: CALL_OW 263
61193: PUSH
61194: LD_INT 2
61196: NONEQUAL
61197: OR
61198: IFFALSE 61202
// exit ;
61200: GO 61518
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
61202: LD_ADDR_VAR 0 6
61206: PUSH
61207: LD_INT 22
61209: PUSH
61210: LD_VAR 0 1
61214: PPUSH
61215: CALL_OW 255
61219: PUSH
61220: EMPTY
61221: LIST
61222: LIST
61223: PUSH
61224: LD_INT 2
61226: PUSH
61227: LD_INT 30
61229: PUSH
61230: LD_INT 36
61232: PUSH
61233: EMPTY
61234: LIST
61235: LIST
61236: PUSH
61237: LD_INT 34
61239: PUSH
61240: LD_INT 31
61242: PUSH
61243: EMPTY
61244: LIST
61245: LIST
61246: PUSH
61247: EMPTY
61248: LIST
61249: LIST
61250: LIST
61251: PUSH
61252: EMPTY
61253: LIST
61254: LIST
61255: PPUSH
61256: CALL_OW 69
61260: ST_TO_ADDR
// if not tmp then
61261: LD_VAR 0 6
61265: NOT
61266: IFFALSE 61270
// exit ;
61268: GO 61518
// result := [ ] ;
61270: LD_ADDR_VAR 0 2
61274: PUSH
61275: EMPTY
61276: ST_TO_ADDR
// for i in tmp do
61277: LD_ADDR_VAR 0 3
61281: PUSH
61282: LD_VAR 0 6
61286: PUSH
61287: FOR_IN
61288: IFFALSE 61359
// begin t := UnitsInside ( i ) ;
61290: LD_ADDR_VAR 0 4
61294: PUSH
61295: LD_VAR 0 3
61299: PPUSH
61300: CALL_OW 313
61304: ST_TO_ADDR
// if t then
61305: LD_VAR 0 4
61309: IFFALSE 61357
// for j in t do
61311: LD_ADDR_VAR 0 7
61315: PUSH
61316: LD_VAR 0 4
61320: PUSH
61321: FOR_IN
61322: IFFALSE 61355
// result := Replace ( result , result + 1 , j ) ;
61324: LD_ADDR_VAR 0 2
61328: PUSH
61329: LD_VAR 0 2
61333: PPUSH
61334: LD_VAR 0 2
61338: PUSH
61339: LD_INT 1
61341: PLUS
61342: PPUSH
61343: LD_VAR 0 7
61347: PPUSH
61348: CALL_OW 1
61352: ST_TO_ADDR
61353: GO 61321
61355: POP
61356: POP
// end ;
61357: GO 61287
61359: POP
61360: POP
// if not result then
61361: LD_VAR 0 2
61365: NOT
61366: IFFALSE 61370
// exit ;
61368: GO 61518
// mech := result [ 1 ] ;
61370: LD_ADDR_VAR 0 5
61374: PUSH
61375: LD_VAR 0 2
61379: PUSH
61380: LD_INT 1
61382: ARRAY
61383: ST_TO_ADDR
// if result > 1 then
61384: LD_VAR 0 2
61388: PUSH
61389: LD_INT 1
61391: GREATER
61392: IFFALSE 61504
// begin for i = 2 to result do
61394: LD_ADDR_VAR 0 3
61398: PUSH
61399: DOUBLE
61400: LD_INT 2
61402: DEC
61403: ST_TO_ADDR
61404: LD_VAR 0 2
61408: PUSH
61409: FOR_TO
61410: IFFALSE 61502
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
61412: LD_ADDR_VAR 0 4
61416: PUSH
61417: LD_VAR 0 2
61421: PUSH
61422: LD_VAR 0 3
61426: ARRAY
61427: PPUSH
61428: LD_INT 3
61430: PPUSH
61431: CALL_OW 259
61435: PUSH
61436: LD_VAR 0 2
61440: PUSH
61441: LD_VAR 0 3
61445: ARRAY
61446: PPUSH
61447: CALL_OW 432
61451: MINUS
61452: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
61453: LD_VAR 0 4
61457: PUSH
61458: LD_VAR 0 5
61462: PPUSH
61463: LD_INT 3
61465: PPUSH
61466: CALL_OW 259
61470: PUSH
61471: LD_VAR 0 5
61475: PPUSH
61476: CALL_OW 432
61480: MINUS
61481: GREATEREQUAL
61482: IFFALSE 61500
// mech := result [ i ] ;
61484: LD_ADDR_VAR 0 5
61488: PUSH
61489: LD_VAR 0 2
61493: PUSH
61494: LD_VAR 0 3
61498: ARRAY
61499: ST_TO_ADDR
// end ;
61500: GO 61409
61502: POP
61503: POP
// end ; ComLinkTo ( vehicle , mech ) ;
61504: LD_VAR 0 1
61508: PPUSH
61509: LD_VAR 0 5
61513: PPUSH
61514: CALL_OW 135
// end ;
61518: LD_VAR 0 2
61522: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61523: LD_INT 0
61525: PPUSH
61526: PPUSH
61527: PPUSH
61528: PPUSH
61529: PPUSH
61530: PPUSH
61531: PPUSH
61532: PPUSH
61533: PPUSH
61534: PPUSH
61535: PPUSH
61536: PPUSH
61537: PPUSH
// result := [ ] ;
61538: LD_ADDR_VAR 0 7
61542: PUSH
61543: EMPTY
61544: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
61545: LD_VAR 0 1
61549: PPUSH
61550: CALL_OW 266
61554: PUSH
61555: LD_INT 0
61557: PUSH
61558: LD_INT 1
61560: PUSH
61561: EMPTY
61562: LIST
61563: LIST
61564: IN
61565: NOT
61566: IFFALSE 61570
// exit ;
61568: GO 63204
// if name then
61570: LD_VAR 0 3
61574: IFFALSE 61590
// SetBName ( base_dep , name ) ;
61576: LD_VAR 0 1
61580: PPUSH
61581: LD_VAR 0 3
61585: PPUSH
61586: CALL_OW 500
// base := GetBase ( base_dep ) ;
61590: LD_ADDR_VAR 0 15
61594: PUSH
61595: LD_VAR 0 1
61599: PPUSH
61600: CALL_OW 274
61604: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61605: LD_ADDR_VAR 0 16
61609: PUSH
61610: LD_VAR 0 1
61614: PPUSH
61615: CALL_OW 255
61619: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61620: LD_ADDR_VAR 0 17
61624: PUSH
61625: LD_VAR 0 1
61629: PPUSH
61630: CALL_OW 248
61634: ST_TO_ADDR
// if sources then
61635: LD_VAR 0 5
61639: IFFALSE 61686
// for i = 1 to 3 do
61641: LD_ADDR_VAR 0 8
61645: PUSH
61646: DOUBLE
61647: LD_INT 1
61649: DEC
61650: ST_TO_ADDR
61651: LD_INT 3
61653: PUSH
61654: FOR_TO
61655: IFFALSE 61684
// AddResourceType ( base , i , sources [ i ] ) ;
61657: LD_VAR 0 15
61661: PPUSH
61662: LD_VAR 0 8
61666: PPUSH
61667: LD_VAR 0 5
61671: PUSH
61672: LD_VAR 0 8
61676: ARRAY
61677: PPUSH
61678: CALL_OW 276
61682: GO 61654
61684: POP
61685: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
61686: LD_ADDR_VAR 0 18
61690: PUSH
61691: LD_VAR 0 15
61695: PPUSH
61696: LD_VAR 0 2
61700: PPUSH
61701: LD_INT 1
61703: PPUSH
61704: CALL 60947 0 3
61708: ST_TO_ADDR
// InitHc ;
61709: CALL_OW 19
// InitUc ;
61713: CALL_OW 18
// uc_side := side ;
61717: LD_ADDR_OWVAR 20
61721: PUSH
61722: LD_VAR 0 16
61726: ST_TO_ADDR
// uc_nation := nation ;
61727: LD_ADDR_OWVAR 21
61731: PUSH
61732: LD_VAR 0 17
61736: ST_TO_ADDR
// if buildings then
61737: LD_VAR 0 18
61741: IFFALSE 63063
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61743: LD_ADDR_VAR 0 19
61747: PUSH
61748: LD_VAR 0 18
61752: PPUSH
61753: LD_INT 2
61755: PUSH
61756: LD_INT 30
61758: PUSH
61759: LD_INT 29
61761: PUSH
61762: EMPTY
61763: LIST
61764: LIST
61765: PUSH
61766: LD_INT 30
61768: PUSH
61769: LD_INT 30
61771: PUSH
61772: EMPTY
61773: LIST
61774: LIST
61775: PUSH
61776: EMPTY
61777: LIST
61778: LIST
61779: LIST
61780: PPUSH
61781: CALL_OW 72
61785: ST_TO_ADDR
// if tmp then
61786: LD_VAR 0 19
61790: IFFALSE 61838
// for i in tmp do
61792: LD_ADDR_VAR 0 8
61796: PUSH
61797: LD_VAR 0 19
61801: PUSH
61802: FOR_IN
61803: IFFALSE 61836
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61805: LD_VAR 0 8
61809: PPUSH
61810: CALL_OW 250
61814: PPUSH
61815: LD_VAR 0 8
61819: PPUSH
61820: CALL_OW 251
61824: PPUSH
61825: LD_VAR 0 16
61829: PPUSH
61830: CALL_OW 441
61834: GO 61802
61836: POP
61837: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61838: LD_VAR 0 18
61842: PPUSH
61843: LD_INT 2
61845: PUSH
61846: LD_INT 30
61848: PUSH
61849: LD_INT 32
61851: PUSH
61852: EMPTY
61853: LIST
61854: LIST
61855: PUSH
61856: LD_INT 30
61858: PUSH
61859: LD_INT 33
61861: PUSH
61862: EMPTY
61863: LIST
61864: LIST
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: LIST
61870: PPUSH
61871: CALL_OW 72
61875: IFFALSE 61963
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61877: LD_ADDR_VAR 0 8
61881: PUSH
61882: LD_VAR 0 18
61886: PPUSH
61887: LD_INT 2
61889: PUSH
61890: LD_INT 30
61892: PUSH
61893: LD_INT 32
61895: PUSH
61896: EMPTY
61897: LIST
61898: LIST
61899: PUSH
61900: LD_INT 30
61902: PUSH
61903: LD_INT 33
61905: PUSH
61906: EMPTY
61907: LIST
61908: LIST
61909: PUSH
61910: EMPTY
61911: LIST
61912: LIST
61913: LIST
61914: PPUSH
61915: CALL_OW 72
61919: PUSH
61920: FOR_IN
61921: IFFALSE 61961
// begin if not GetBWeapon ( i ) then
61923: LD_VAR 0 8
61927: PPUSH
61928: CALL_OW 269
61932: NOT
61933: IFFALSE 61959
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61935: LD_VAR 0 8
61939: PPUSH
61940: LD_VAR 0 8
61944: PPUSH
61945: LD_VAR 0 2
61949: PPUSH
61950: CALL 63209 0 2
61954: PPUSH
61955: CALL_OW 431
// end ;
61959: GO 61920
61961: POP
61962: POP
// end ; for i = 1 to personel do
61963: LD_ADDR_VAR 0 8
61967: PUSH
61968: DOUBLE
61969: LD_INT 1
61971: DEC
61972: ST_TO_ADDR
61973: LD_VAR 0 6
61977: PUSH
61978: FOR_TO
61979: IFFALSE 63043
// begin if i > 4 then
61981: LD_VAR 0 8
61985: PUSH
61986: LD_INT 4
61988: GREATER
61989: IFFALSE 61993
// break ;
61991: GO 63043
// case i of 1 :
61993: LD_VAR 0 8
61997: PUSH
61998: LD_INT 1
62000: DOUBLE
62001: EQUAL
62002: IFTRUE 62006
62004: GO 62086
62006: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
62007: LD_ADDR_VAR 0 12
62011: PUSH
62012: LD_VAR 0 18
62016: PPUSH
62017: LD_INT 22
62019: PUSH
62020: LD_VAR 0 16
62024: PUSH
62025: EMPTY
62026: LIST
62027: LIST
62028: PUSH
62029: LD_INT 58
62031: PUSH
62032: EMPTY
62033: LIST
62034: PUSH
62035: LD_INT 2
62037: PUSH
62038: LD_INT 30
62040: PUSH
62041: LD_INT 32
62043: PUSH
62044: EMPTY
62045: LIST
62046: LIST
62047: PUSH
62048: LD_INT 30
62050: PUSH
62051: LD_INT 4
62053: PUSH
62054: EMPTY
62055: LIST
62056: LIST
62057: PUSH
62058: LD_INT 30
62060: PUSH
62061: LD_INT 5
62063: PUSH
62064: EMPTY
62065: LIST
62066: LIST
62067: PUSH
62068: EMPTY
62069: LIST
62070: LIST
62071: LIST
62072: LIST
62073: PUSH
62074: EMPTY
62075: LIST
62076: LIST
62077: LIST
62078: PPUSH
62079: CALL_OW 72
62083: ST_TO_ADDR
62084: GO 62308
62086: LD_INT 2
62088: DOUBLE
62089: EQUAL
62090: IFTRUE 62094
62092: GO 62156
62094: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
62095: LD_ADDR_VAR 0 12
62099: PUSH
62100: LD_VAR 0 18
62104: PPUSH
62105: LD_INT 22
62107: PUSH
62108: LD_VAR 0 16
62112: PUSH
62113: EMPTY
62114: LIST
62115: LIST
62116: PUSH
62117: LD_INT 2
62119: PUSH
62120: LD_INT 30
62122: PUSH
62123: LD_INT 0
62125: PUSH
62126: EMPTY
62127: LIST
62128: LIST
62129: PUSH
62130: LD_INT 30
62132: PUSH
62133: LD_INT 1
62135: PUSH
62136: EMPTY
62137: LIST
62138: LIST
62139: PUSH
62140: EMPTY
62141: LIST
62142: LIST
62143: LIST
62144: PUSH
62145: EMPTY
62146: LIST
62147: LIST
62148: PPUSH
62149: CALL_OW 72
62153: ST_TO_ADDR
62154: GO 62308
62156: LD_INT 3
62158: DOUBLE
62159: EQUAL
62160: IFTRUE 62164
62162: GO 62226
62164: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
62165: LD_ADDR_VAR 0 12
62169: PUSH
62170: LD_VAR 0 18
62174: PPUSH
62175: LD_INT 22
62177: PUSH
62178: LD_VAR 0 16
62182: PUSH
62183: EMPTY
62184: LIST
62185: LIST
62186: PUSH
62187: LD_INT 2
62189: PUSH
62190: LD_INT 30
62192: PUSH
62193: LD_INT 2
62195: PUSH
62196: EMPTY
62197: LIST
62198: LIST
62199: PUSH
62200: LD_INT 30
62202: PUSH
62203: LD_INT 3
62205: PUSH
62206: EMPTY
62207: LIST
62208: LIST
62209: PUSH
62210: EMPTY
62211: LIST
62212: LIST
62213: LIST
62214: PUSH
62215: EMPTY
62216: LIST
62217: LIST
62218: PPUSH
62219: CALL_OW 72
62223: ST_TO_ADDR
62224: GO 62308
62226: LD_INT 4
62228: DOUBLE
62229: EQUAL
62230: IFTRUE 62234
62232: GO 62307
62234: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
62235: LD_ADDR_VAR 0 12
62239: PUSH
62240: LD_VAR 0 18
62244: PPUSH
62245: LD_INT 22
62247: PUSH
62248: LD_VAR 0 16
62252: PUSH
62253: EMPTY
62254: LIST
62255: LIST
62256: PUSH
62257: LD_INT 2
62259: PUSH
62260: LD_INT 30
62262: PUSH
62263: LD_INT 6
62265: PUSH
62266: EMPTY
62267: LIST
62268: LIST
62269: PUSH
62270: LD_INT 30
62272: PUSH
62273: LD_INT 7
62275: PUSH
62276: EMPTY
62277: LIST
62278: LIST
62279: PUSH
62280: LD_INT 30
62282: PUSH
62283: LD_INT 8
62285: PUSH
62286: EMPTY
62287: LIST
62288: LIST
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: LIST
62294: LIST
62295: PUSH
62296: EMPTY
62297: LIST
62298: LIST
62299: PPUSH
62300: CALL_OW 72
62304: ST_TO_ADDR
62305: GO 62308
62307: POP
// if i = 1 then
62308: LD_VAR 0 8
62312: PUSH
62313: LD_INT 1
62315: EQUAL
62316: IFFALSE 62427
// begin tmp := [ ] ;
62318: LD_ADDR_VAR 0 19
62322: PUSH
62323: EMPTY
62324: ST_TO_ADDR
// for j in f do
62325: LD_ADDR_VAR 0 9
62329: PUSH
62330: LD_VAR 0 12
62334: PUSH
62335: FOR_IN
62336: IFFALSE 62409
// if GetBType ( j ) = b_bunker then
62338: LD_VAR 0 9
62342: PPUSH
62343: CALL_OW 266
62347: PUSH
62348: LD_INT 32
62350: EQUAL
62351: IFFALSE 62378
// tmp := Insert ( tmp , 1 , j ) else
62353: LD_ADDR_VAR 0 19
62357: PUSH
62358: LD_VAR 0 19
62362: PPUSH
62363: LD_INT 1
62365: PPUSH
62366: LD_VAR 0 9
62370: PPUSH
62371: CALL_OW 2
62375: ST_TO_ADDR
62376: GO 62407
// tmp := Insert ( tmp , tmp + 1 , j ) ;
62378: LD_ADDR_VAR 0 19
62382: PUSH
62383: LD_VAR 0 19
62387: PPUSH
62388: LD_VAR 0 19
62392: PUSH
62393: LD_INT 1
62395: PLUS
62396: PPUSH
62397: LD_VAR 0 9
62401: PPUSH
62402: CALL_OW 2
62406: ST_TO_ADDR
62407: GO 62335
62409: POP
62410: POP
// if tmp then
62411: LD_VAR 0 19
62415: IFFALSE 62427
// f := tmp ;
62417: LD_ADDR_VAR 0 12
62421: PUSH
62422: LD_VAR 0 19
62426: ST_TO_ADDR
// end ; x := personel [ i ] ;
62427: LD_ADDR_VAR 0 13
62431: PUSH
62432: LD_VAR 0 6
62436: PUSH
62437: LD_VAR 0 8
62441: ARRAY
62442: ST_TO_ADDR
// if x = - 1 then
62443: LD_VAR 0 13
62447: PUSH
62448: LD_INT 1
62450: NEG
62451: EQUAL
62452: IFFALSE 62661
// begin for j in f do
62454: LD_ADDR_VAR 0 9
62458: PUSH
62459: LD_VAR 0 12
62463: PUSH
62464: FOR_IN
62465: IFFALSE 62657
// repeat InitHc ;
62467: CALL_OW 19
// if GetBType ( j ) = b_barracks then
62471: LD_VAR 0 9
62475: PPUSH
62476: CALL_OW 266
62480: PUSH
62481: LD_INT 5
62483: EQUAL
62484: IFFALSE 62554
// begin if UnitsInside ( j ) < 3 then
62486: LD_VAR 0 9
62490: PPUSH
62491: CALL_OW 313
62495: PUSH
62496: LD_INT 3
62498: LESS
62499: IFFALSE 62535
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62501: LD_INT 0
62503: PPUSH
62504: LD_INT 5
62506: PUSH
62507: LD_INT 8
62509: PUSH
62510: LD_INT 9
62512: PUSH
62513: EMPTY
62514: LIST
62515: LIST
62516: LIST
62517: PUSH
62518: LD_VAR 0 17
62522: ARRAY
62523: PPUSH
62524: LD_VAR 0 4
62528: PPUSH
62529: CALL_OW 380
62533: GO 62552
// PrepareHuman ( false , i , skill ) ;
62535: LD_INT 0
62537: PPUSH
62538: LD_VAR 0 8
62542: PPUSH
62543: LD_VAR 0 4
62547: PPUSH
62548: CALL_OW 380
// end else
62552: GO 62571
// PrepareHuman ( false , i , skill ) ;
62554: LD_INT 0
62556: PPUSH
62557: LD_VAR 0 8
62561: PPUSH
62562: LD_VAR 0 4
62566: PPUSH
62567: CALL_OW 380
// un := CreateHuman ;
62571: LD_ADDR_VAR 0 14
62575: PUSH
62576: CALL_OW 44
62580: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62581: LD_ADDR_VAR 0 7
62585: PUSH
62586: LD_VAR 0 7
62590: PPUSH
62591: LD_INT 1
62593: PPUSH
62594: LD_VAR 0 14
62598: PPUSH
62599: CALL_OW 2
62603: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62604: LD_VAR 0 14
62608: PPUSH
62609: LD_VAR 0 9
62613: PPUSH
62614: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62618: LD_VAR 0 9
62622: PPUSH
62623: CALL_OW 313
62627: PUSH
62628: LD_INT 6
62630: EQUAL
62631: PUSH
62632: LD_VAR 0 9
62636: PPUSH
62637: CALL_OW 266
62641: PUSH
62642: LD_INT 32
62644: PUSH
62645: LD_INT 31
62647: PUSH
62648: EMPTY
62649: LIST
62650: LIST
62651: IN
62652: OR
62653: IFFALSE 62467
62655: GO 62464
62657: POP
62658: POP
// end else
62659: GO 63041
// for j = 1 to x do
62661: LD_ADDR_VAR 0 9
62665: PUSH
62666: DOUBLE
62667: LD_INT 1
62669: DEC
62670: ST_TO_ADDR
62671: LD_VAR 0 13
62675: PUSH
62676: FOR_TO
62677: IFFALSE 63039
// begin InitHc ;
62679: CALL_OW 19
// if not f then
62683: LD_VAR 0 12
62687: NOT
62688: IFFALSE 62777
// begin PrepareHuman ( false , i , skill ) ;
62690: LD_INT 0
62692: PPUSH
62693: LD_VAR 0 8
62697: PPUSH
62698: LD_VAR 0 4
62702: PPUSH
62703: CALL_OW 380
// un := CreateHuman ;
62707: LD_ADDR_VAR 0 14
62711: PUSH
62712: CALL_OW 44
62716: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62717: LD_ADDR_VAR 0 7
62721: PUSH
62722: LD_VAR 0 7
62726: PPUSH
62727: LD_INT 1
62729: PPUSH
62730: LD_VAR 0 14
62734: PPUSH
62735: CALL_OW 2
62739: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62740: LD_VAR 0 14
62744: PPUSH
62745: LD_VAR 0 1
62749: PPUSH
62750: CALL_OW 250
62754: PPUSH
62755: LD_VAR 0 1
62759: PPUSH
62760: CALL_OW 251
62764: PPUSH
62765: LD_INT 10
62767: PPUSH
62768: LD_INT 0
62770: PPUSH
62771: CALL_OW 50
// continue ;
62775: GO 62676
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62777: LD_VAR 0 12
62781: PUSH
62782: LD_INT 1
62784: ARRAY
62785: PPUSH
62786: CALL_OW 313
62790: PUSH
62791: LD_VAR 0 12
62795: PUSH
62796: LD_INT 1
62798: ARRAY
62799: PPUSH
62800: CALL_OW 266
62804: PUSH
62805: LD_INT 32
62807: PUSH
62808: LD_INT 31
62810: PUSH
62811: EMPTY
62812: LIST
62813: LIST
62814: IN
62815: AND
62816: PUSH
62817: LD_VAR 0 12
62821: PUSH
62822: LD_INT 1
62824: ARRAY
62825: PPUSH
62826: CALL_OW 313
62830: PUSH
62831: LD_INT 6
62833: EQUAL
62834: OR
62835: IFFALSE 62855
// f := Delete ( f , 1 ) ;
62837: LD_ADDR_VAR 0 12
62841: PUSH
62842: LD_VAR 0 12
62846: PPUSH
62847: LD_INT 1
62849: PPUSH
62850: CALL_OW 3
62854: ST_TO_ADDR
// if not f then
62855: LD_VAR 0 12
62859: NOT
62860: IFFALSE 62878
// begin x := x + 2 ;
62862: LD_ADDR_VAR 0 13
62866: PUSH
62867: LD_VAR 0 13
62871: PUSH
62872: LD_INT 2
62874: PLUS
62875: ST_TO_ADDR
// continue ;
62876: GO 62676
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62878: LD_VAR 0 12
62882: PUSH
62883: LD_INT 1
62885: ARRAY
62886: PPUSH
62887: CALL_OW 266
62891: PUSH
62892: LD_INT 5
62894: EQUAL
62895: IFFALSE 62969
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62897: LD_VAR 0 12
62901: PUSH
62902: LD_INT 1
62904: ARRAY
62905: PPUSH
62906: CALL_OW 313
62910: PUSH
62911: LD_INT 3
62913: LESS
62914: IFFALSE 62950
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62916: LD_INT 0
62918: PPUSH
62919: LD_INT 5
62921: PUSH
62922: LD_INT 8
62924: PUSH
62925: LD_INT 9
62927: PUSH
62928: EMPTY
62929: LIST
62930: LIST
62931: LIST
62932: PUSH
62933: LD_VAR 0 17
62937: ARRAY
62938: PPUSH
62939: LD_VAR 0 4
62943: PPUSH
62944: CALL_OW 380
62948: GO 62967
// PrepareHuman ( false , i , skill ) ;
62950: LD_INT 0
62952: PPUSH
62953: LD_VAR 0 8
62957: PPUSH
62958: LD_VAR 0 4
62962: PPUSH
62963: CALL_OW 380
// end else
62967: GO 62986
// PrepareHuman ( false , i , skill ) ;
62969: LD_INT 0
62971: PPUSH
62972: LD_VAR 0 8
62976: PPUSH
62977: LD_VAR 0 4
62981: PPUSH
62982: CALL_OW 380
// un := CreateHuman ;
62986: LD_ADDR_VAR 0 14
62990: PUSH
62991: CALL_OW 44
62995: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62996: LD_ADDR_VAR 0 7
63000: PUSH
63001: LD_VAR 0 7
63005: PPUSH
63006: LD_INT 1
63008: PPUSH
63009: LD_VAR 0 14
63013: PPUSH
63014: CALL_OW 2
63018: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
63019: LD_VAR 0 14
63023: PPUSH
63024: LD_VAR 0 12
63028: PUSH
63029: LD_INT 1
63031: ARRAY
63032: PPUSH
63033: CALL_OW 52
// end ;
63037: GO 62676
63039: POP
63040: POP
// end ;
63041: GO 61978
63043: POP
63044: POP
// result := result ^ buildings ;
63045: LD_ADDR_VAR 0 7
63049: PUSH
63050: LD_VAR 0 7
63054: PUSH
63055: LD_VAR 0 18
63059: ADD
63060: ST_TO_ADDR
// end else
63061: GO 63204
// begin for i = 1 to personel do
63063: LD_ADDR_VAR 0 8
63067: PUSH
63068: DOUBLE
63069: LD_INT 1
63071: DEC
63072: ST_TO_ADDR
63073: LD_VAR 0 6
63077: PUSH
63078: FOR_TO
63079: IFFALSE 63202
// begin if i > 4 then
63081: LD_VAR 0 8
63085: PUSH
63086: LD_INT 4
63088: GREATER
63089: IFFALSE 63093
// break ;
63091: GO 63202
// x := personel [ i ] ;
63093: LD_ADDR_VAR 0 13
63097: PUSH
63098: LD_VAR 0 6
63102: PUSH
63103: LD_VAR 0 8
63107: ARRAY
63108: ST_TO_ADDR
// if x = - 1 then
63109: LD_VAR 0 13
63113: PUSH
63114: LD_INT 1
63116: NEG
63117: EQUAL
63118: IFFALSE 63122
// continue ;
63120: GO 63078
// PrepareHuman ( false , i , skill ) ;
63122: LD_INT 0
63124: PPUSH
63125: LD_VAR 0 8
63129: PPUSH
63130: LD_VAR 0 4
63134: PPUSH
63135: CALL_OW 380
// un := CreateHuman ;
63139: LD_ADDR_VAR 0 14
63143: PUSH
63144: CALL_OW 44
63148: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63149: LD_VAR 0 14
63153: PPUSH
63154: LD_VAR 0 1
63158: PPUSH
63159: CALL_OW 250
63163: PPUSH
63164: LD_VAR 0 1
63168: PPUSH
63169: CALL_OW 251
63173: PPUSH
63174: LD_INT 10
63176: PPUSH
63177: LD_INT 0
63179: PPUSH
63180: CALL_OW 50
// result := result ^ un ;
63184: LD_ADDR_VAR 0 7
63188: PUSH
63189: LD_VAR 0 7
63193: PUSH
63194: LD_VAR 0 14
63198: ADD
63199: ST_TO_ADDR
// end ;
63200: GO 63078
63202: POP
63203: POP
// end ; end ;
63204: LD_VAR 0 7
63208: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
63209: LD_INT 0
63211: PPUSH
63212: PPUSH
63213: PPUSH
63214: PPUSH
63215: PPUSH
63216: PPUSH
63217: PPUSH
63218: PPUSH
63219: PPUSH
63220: PPUSH
63221: PPUSH
63222: PPUSH
63223: PPUSH
63224: PPUSH
63225: PPUSH
63226: PPUSH
// result := false ;
63227: LD_ADDR_VAR 0 3
63231: PUSH
63232: LD_INT 0
63234: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
63235: LD_VAR 0 1
63239: NOT
63240: PUSH
63241: LD_VAR 0 1
63245: PPUSH
63246: CALL_OW 266
63250: PUSH
63251: LD_INT 32
63253: PUSH
63254: LD_INT 33
63256: PUSH
63257: EMPTY
63258: LIST
63259: LIST
63260: IN
63261: NOT
63262: OR
63263: IFFALSE 63267
// exit ;
63265: GO 64376
// nat := GetNation ( tower ) ;
63267: LD_ADDR_VAR 0 12
63271: PUSH
63272: LD_VAR 0 1
63276: PPUSH
63277: CALL_OW 248
63281: ST_TO_ADDR
// side := GetSide ( tower ) ;
63282: LD_ADDR_VAR 0 16
63286: PUSH
63287: LD_VAR 0 1
63291: PPUSH
63292: CALL_OW 255
63296: ST_TO_ADDR
// x := GetX ( tower ) ;
63297: LD_ADDR_VAR 0 10
63301: PUSH
63302: LD_VAR 0 1
63306: PPUSH
63307: CALL_OW 250
63311: ST_TO_ADDR
// y := GetY ( tower ) ;
63312: LD_ADDR_VAR 0 11
63316: PUSH
63317: LD_VAR 0 1
63321: PPUSH
63322: CALL_OW 251
63326: ST_TO_ADDR
// if not x or not y then
63327: LD_VAR 0 10
63331: NOT
63332: PUSH
63333: LD_VAR 0 11
63337: NOT
63338: OR
63339: IFFALSE 63343
// exit ;
63341: GO 64376
// weapon := 0 ;
63343: LD_ADDR_VAR 0 18
63347: PUSH
63348: LD_INT 0
63350: ST_TO_ADDR
// fac_list := [ ] ;
63351: LD_ADDR_VAR 0 17
63355: PUSH
63356: EMPTY
63357: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
63358: LD_ADDR_VAR 0 6
63362: PUSH
63363: LD_VAR 0 1
63367: PPUSH
63368: CALL_OW 274
63372: PPUSH
63373: LD_VAR 0 2
63377: PPUSH
63378: LD_INT 0
63380: PPUSH
63381: CALL 60947 0 3
63385: PPUSH
63386: LD_INT 30
63388: PUSH
63389: LD_INT 3
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: PPUSH
63396: CALL_OW 72
63400: ST_TO_ADDR
// if not factories then
63401: LD_VAR 0 6
63405: NOT
63406: IFFALSE 63410
// exit ;
63408: GO 64376
// for i in factories do
63410: LD_ADDR_VAR 0 8
63414: PUSH
63415: LD_VAR 0 6
63419: PUSH
63420: FOR_IN
63421: IFFALSE 63446
// fac_list := fac_list union AvailableWeaponList ( i ) ;
63423: LD_ADDR_VAR 0 17
63427: PUSH
63428: LD_VAR 0 17
63432: PUSH
63433: LD_VAR 0 8
63437: PPUSH
63438: CALL_OW 478
63442: UNION
63443: ST_TO_ADDR
63444: GO 63420
63446: POP
63447: POP
// if not fac_list then
63448: LD_VAR 0 17
63452: NOT
63453: IFFALSE 63457
// exit ;
63455: GO 64376
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
63457: LD_ADDR_VAR 0 5
63461: PUSH
63462: LD_INT 4
63464: PUSH
63465: LD_INT 5
63467: PUSH
63468: LD_INT 9
63470: PUSH
63471: LD_INT 10
63473: PUSH
63474: LD_INT 6
63476: PUSH
63477: LD_INT 7
63479: PUSH
63480: LD_INT 11
63482: PUSH
63483: EMPTY
63484: LIST
63485: LIST
63486: LIST
63487: LIST
63488: LIST
63489: LIST
63490: LIST
63491: PUSH
63492: LD_INT 27
63494: PUSH
63495: LD_INT 28
63497: PUSH
63498: LD_INT 26
63500: PUSH
63501: LD_INT 30
63503: PUSH
63504: EMPTY
63505: LIST
63506: LIST
63507: LIST
63508: LIST
63509: PUSH
63510: LD_INT 43
63512: PUSH
63513: LD_INT 44
63515: PUSH
63516: LD_INT 46
63518: PUSH
63519: LD_INT 45
63521: PUSH
63522: LD_INT 47
63524: PUSH
63525: LD_INT 49
63527: PUSH
63528: EMPTY
63529: LIST
63530: LIST
63531: LIST
63532: LIST
63533: LIST
63534: LIST
63535: PUSH
63536: EMPTY
63537: LIST
63538: LIST
63539: LIST
63540: PUSH
63541: LD_VAR 0 12
63545: ARRAY
63546: ST_TO_ADDR
// list := list isect fac_list ;
63547: LD_ADDR_VAR 0 5
63551: PUSH
63552: LD_VAR 0 5
63556: PUSH
63557: LD_VAR 0 17
63561: ISECT
63562: ST_TO_ADDR
// if not list then
63563: LD_VAR 0 5
63567: NOT
63568: IFFALSE 63572
// exit ;
63570: GO 64376
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63572: LD_VAR 0 12
63576: PUSH
63577: LD_INT 3
63579: EQUAL
63580: PUSH
63581: LD_INT 49
63583: PUSH
63584: LD_VAR 0 5
63588: IN
63589: AND
63590: PUSH
63591: LD_INT 31
63593: PPUSH
63594: LD_VAR 0 16
63598: PPUSH
63599: CALL_OW 321
63603: PUSH
63604: LD_INT 2
63606: EQUAL
63607: AND
63608: IFFALSE 63668
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63610: LD_INT 22
63612: PUSH
63613: LD_VAR 0 16
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: PUSH
63622: LD_INT 35
63624: PUSH
63625: LD_INT 49
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: PUSH
63632: LD_INT 91
63634: PUSH
63635: LD_VAR 0 1
63639: PUSH
63640: LD_INT 10
63642: PUSH
63643: EMPTY
63644: LIST
63645: LIST
63646: LIST
63647: PUSH
63648: EMPTY
63649: LIST
63650: LIST
63651: LIST
63652: PPUSH
63653: CALL_OW 69
63657: NOT
63658: IFFALSE 63668
// weapon := ru_time_lapser ;
63660: LD_ADDR_VAR 0 18
63664: PUSH
63665: LD_INT 49
63667: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63668: LD_VAR 0 12
63672: PUSH
63673: LD_INT 1
63675: PUSH
63676: LD_INT 2
63678: PUSH
63679: EMPTY
63680: LIST
63681: LIST
63682: IN
63683: PUSH
63684: LD_INT 11
63686: PUSH
63687: LD_VAR 0 5
63691: IN
63692: PUSH
63693: LD_INT 30
63695: PUSH
63696: LD_VAR 0 5
63700: IN
63701: OR
63702: AND
63703: PUSH
63704: LD_INT 6
63706: PPUSH
63707: LD_VAR 0 16
63711: PPUSH
63712: CALL_OW 321
63716: PUSH
63717: LD_INT 2
63719: EQUAL
63720: AND
63721: IFFALSE 63886
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63723: LD_INT 22
63725: PUSH
63726: LD_VAR 0 16
63730: PUSH
63731: EMPTY
63732: LIST
63733: LIST
63734: PUSH
63735: LD_INT 2
63737: PUSH
63738: LD_INT 35
63740: PUSH
63741: LD_INT 11
63743: PUSH
63744: EMPTY
63745: LIST
63746: LIST
63747: PUSH
63748: LD_INT 35
63750: PUSH
63751: LD_INT 30
63753: PUSH
63754: EMPTY
63755: LIST
63756: LIST
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: LIST
63762: PUSH
63763: LD_INT 91
63765: PUSH
63766: LD_VAR 0 1
63770: PUSH
63771: LD_INT 18
63773: PUSH
63774: EMPTY
63775: LIST
63776: LIST
63777: LIST
63778: PUSH
63779: EMPTY
63780: LIST
63781: LIST
63782: LIST
63783: PPUSH
63784: CALL_OW 69
63788: NOT
63789: PUSH
63790: LD_INT 22
63792: PUSH
63793: LD_VAR 0 16
63797: PUSH
63798: EMPTY
63799: LIST
63800: LIST
63801: PUSH
63802: LD_INT 2
63804: PUSH
63805: LD_INT 30
63807: PUSH
63808: LD_INT 32
63810: PUSH
63811: EMPTY
63812: LIST
63813: LIST
63814: PUSH
63815: LD_INT 30
63817: PUSH
63818: LD_INT 33
63820: PUSH
63821: EMPTY
63822: LIST
63823: LIST
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: LIST
63829: PUSH
63830: LD_INT 91
63832: PUSH
63833: LD_VAR 0 1
63837: PUSH
63838: LD_INT 12
63840: PUSH
63841: EMPTY
63842: LIST
63843: LIST
63844: LIST
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: LIST
63850: PUSH
63851: EMPTY
63852: LIST
63853: PPUSH
63854: CALL_OW 69
63858: PUSH
63859: LD_INT 2
63861: GREATER
63862: AND
63863: IFFALSE 63886
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63865: LD_ADDR_VAR 0 18
63869: PUSH
63870: LD_INT 11
63872: PUSH
63873: LD_INT 30
63875: PUSH
63876: EMPTY
63877: LIST
63878: LIST
63879: PUSH
63880: LD_VAR 0 12
63884: ARRAY
63885: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63886: LD_VAR 0 18
63890: NOT
63891: PUSH
63892: LD_INT 40
63894: PPUSH
63895: LD_VAR 0 16
63899: PPUSH
63900: CALL_OW 321
63904: PUSH
63905: LD_INT 2
63907: EQUAL
63908: AND
63909: PUSH
63910: LD_INT 7
63912: PUSH
63913: LD_VAR 0 5
63917: IN
63918: PUSH
63919: LD_INT 28
63921: PUSH
63922: LD_VAR 0 5
63926: IN
63927: OR
63928: PUSH
63929: LD_INT 45
63931: PUSH
63932: LD_VAR 0 5
63936: IN
63937: OR
63938: AND
63939: IFFALSE 64193
// begin hex := GetHexInfo ( x , y ) ;
63941: LD_ADDR_VAR 0 4
63945: PUSH
63946: LD_VAR 0 10
63950: PPUSH
63951: LD_VAR 0 11
63955: PPUSH
63956: CALL_OW 546
63960: ST_TO_ADDR
// if hex [ 1 ] then
63961: LD_VAR 0 4
63965: PUSH
63966: LD_INT 1
63968: ARRAY
63969: IFFALSE 63973
// exit ;
63971: GO 64376
// height := hex [ 2 ] ;
63973: LD_ADDR_VAR 0 15
63977: PUSH
63978: LD_VAR 0 4
63982: PUSH
63983: LD_INT 2
63985: ARRAY
63986: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63987: LD_ADDR_VAR 0 14
63991: PUSH
63992: LD_INT 0
63994: PUSH
63995: LD_INT 2
63997: PUSH
63998: LD_INT 3
64000: PUSH
64001: LD_INT 5
64003: PUSH
64004: EMPTY
64005: LIST
64006: LIST
64007: LIST
64008: LIST
64009: ST_TO_ADDR
// for i in tmp do
64010: LD_ADDR_VAR 0 8
64014: PUSH
64015: LD_VAR 0 14
64019: PUSH
64020: FOR_IN
64021: IFFALSE 64191
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
64023: LD_ADDR_VAR 0 9
64027: PUSH
64028: LD_VAR 0 10
64032: PPUSH
64033: LD_VAR 0 8
64037: PPUSH
64038: LD_INT 5
64040: PPUSH
64041: CALL_OW 272
64045: PUSH
64046: LD_VAR 0 11
64050: PPUSH
64051: LD_VAR 0 8
64055: PPUSH
64056: LD_INT 5
64058: PPUSH
64059: CALL_OW 273
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
64068: LD_VAR 0 9
64072: PUSH
64073: LD_INT 1
64075: ARRAY
64076: PPUSH
64077: LD_VAR 0 9
64081: PUSH
64082: LD_INT 2
64084: ARRAY
64085: PPUSH
64086: CALL_OW 488
64090: IFFALSE 64189
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
64092: LD_ADDR_VAR 0 4
64096: PUSH
64097: LD_VAR 0 9
64101: PUSH
64102: LD_INT 1
64104: ARRAY
64105: PPUSH
64106: LD_VAR 0 9
64110: PUSH
64111: LD_INT 2
64113: ARRAY
64114: PPUSH
64115: CALL_OW 546
64119: ST_TO_ADDR
// if hex [ 1 ] then
64120: LD_VAR 0 4
64124: PUSH
64125: LD_INT 1
64127: ARRAY
64128: IFFALSE 64132
// continue ;
64130: GO 64020
// h := hex [ 2 ] ;
64132: LD_ADDR_VAR 0 13
64136: PUSH
64137: LD_VAR 0 4
64141: PUSH
64142: LD_INT 2
64144: ARRAY
64145: ST_TO_ADDR
// if h + 7 < height then
64146: LD_VAR 0 13
64150: PUSH
64151: LD_INT 7
64153: PLUS
64154: PUSH
64155: LD_VAR 0 15
64159: LESS
64160: IFFALSE 64189
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
64162: LD_ADDR_VAR 0 18
64166: PUSH
64167: LD_INT 7
64169: PUSH
64170: LD_INT 28
64172: PUSH
64173: LD_INT 45
64175: PUSH
64176: EMPTY
64177: LIST
64178: LIST
64179: LIST
64180: PUSH
64181: LD_VAR 0 12
64185: ARRAY
64186: ST_TO_ADDR
// break ;
64187: GO 64191
// end ; end ; end ;
64189: GO 64020
64191: POP
64192: POP
// end ; if not weapon then
64193: LD_VAR 0 18
64197: NOT
64198: IFFALSE 64258
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
64200: LD_ADDR_VAR 0 5
64204: PUSH
64205: LD_VAR 0 5
64209: PUSH
64210: LD_INT 11
64212: PUSH
64213: LD_INT 30
64215: PUSH
64216: LD_INT 49
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: LIST
64223: DIFF
64224: ST_TO_ADDR
// if not list then
64225: LD_VAR 0 5
64229: NOT
64230: IFFALSE 64234
// exit ;
64232: GO 64376
// weapon := list [ rand ( 1 , list ) ] ;
64234: LD_ADDR_VAR 0 18
64238: PUSH
64239: LD_VAR 0 5
64243: PUSH
64244: LD_INT 1
64246: PPUSH
64247: LD_VAR 0 5
64251: PPUSH
64252: CALL_OW 12
64256: ARRAY
64257: ST_TO_ADDR
// end ; if weapon then
64258: LD_VAR 0 18
64262: IFFALSE 64376
// begin tmp := CostOfWeapon ( weapon ) ;
64264: LD_ADDR_VAR 0 14
64268: PUSH
64269: LD_VAR 0 18
64273: PPUSH
64274: CALL_OW 451
64278: ST_TO_ADDR
// j := GetBase ( tower ) ;
64279: LD_ADDR_VAR 0 9
64283: PUSH
64284: LD_VAR 0 1
64288: PPUSH
64289: CALL_OW 274
64293: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
64294: LD_VAR 0 9
64298: PPUSH
64299: LD_INT 1
64301: PPUSH
64302: CALL_OW 275
64306: PUSH
64307: LD_VAR 0 14
64311: PUSH
64312: LD_INT 1
64314: ARRAY
64315: GREATEREQUAL
64316: PUSH
64317: LD_VAR 0 9
64321: PPUSH
64322: LD_INT 2
64324: PPUSH
64325: CALL_OW 275
64329: PUSH
64330: LD_VAR 0 14
64334: PUSH
64335: LD_INT 2
64337: ARRAY
64338: GREATEREQUAL
64339: AND
64340: PUSH
64341: LD_VAR 0 9
64345: PPUSH
64346: LD_INT 3
64348: PPUSH
64349: CALL_OW 275
64353: PUSH
64354: LD_VAR 0 14
64358: PUSH
64359: LD_INT 3
64361: ARRAY
64362: GREATEREQUAL
64363: AND
64364: IFFALSE 64376
// result := weapon ;
64366: LD_ADDR_VAR 0 3
64370: PUSH
64371: LD_VAR 0 18
64375: ST_TO_ADDR
// end ; end ;
64376: LD_VAR 0 3
64380: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
64381: LD_INT 0
64383: PPUSH
64384: PPUSH
// result := true ;
64385: LD_ADDR_VAR 0 3
64389: PUSH
64390: LD_INT 1
64392: ST_TO_ADDR
// if array1 = array2 then
64393: LD_VAR 0 1
64397: PUSH
64398: LD_VAR 0 2
64402: EQUAL
64403: IFFALSE 64463
// begin for i = 1 to array1 do
64405: LD_ADDR_VAR 0 4
64409: PUSH
64410: DOUBLE
64411: LD_INT 1
64413: DEC
64414: ST_TO_ADDR
64415: LD_VAR 0 1
64419: PUSH
64420: FOR_TO
64421: IFFALSE 64459
// if array1 [ i ] <> array2 [ i ] then
64423: LD_VAR 0 1
64427: PUSH
64428: LD_VAR 0 4
64432: ARRAY
64433: PUSH
64434: LD_VAR 0 2
64438: PUSH
64439: LD_VAR 0 4
64443: ARRAY
64444: NONEQUAL
64445: IFFALSE 64457
// begin result := false ;
64447: LD_ADDR_VAR 0 3
64451: PUSH
64452: LD_INT 0
64454: ST_TO_ADDR
// break ;
64455: GO 64459
// end ;
64457: GO 64420
64459: POP
64460: POP
// end else
64461: GO 64471
// result := false ;
64463: LD_ADDR_VAR 0 3
64467: PUSH
64468: LD_INT 0
64470: ST_TO_ADDR
// end ;
64471: LD_VAR 0 3
64475: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
64476: LD_INT 0
64478: PPUSH
64479: PPUSH
// if not array1 or not array2 then
64480: LD_VAR 0 1
64484: NOT
64485: PUSH
64486: LD_VAR 0 2
64490: NOT
64491: OR
64492: IFFALSE 64496
// exit ;
64494: GO 64560
// result := true ;
64496: LD_ADDR_VAR 0 3
64500: PUSH
64501: LD_INT 1
64503: ST_TO_ADDR
// for i = 1 to array1 do
64504: LD_ADDR_VAR 0 4
64508: PUSH
64509: DOUBLE
64510: LD_INT 1
64512: DEC
64513: ST_TO_ADDR
64514: LD_VAR 0 1
64518: PUSH
64519: FOR_TO
64520: IFFALSE 64558
// if array1 [ i ] <> array2 [ i ] then
64522: LD_VAR 0 1
64526: PUSH
64527: LD_VAR 0 4
64531: ARRAY
64532: PUSH
64533: LD_VAR 0 2
64537: PUSH
64538: LD_VAR 0 4
64542: ARRAY
64543: NONEQUAL
64544: IFFALSE 64556
// begin result := false ;
64546: LD_ADDR_VAR 0 3
64550: PUSH
64551: LD_INT 0
64553: ST_TO_ADDR
// break ;
64554: GO 64558
// end ;
64556: GO 64519
64558: POP
64559: POP
// end ;
64560: LD_VAR 0 3
64564: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
64565: LD_INT 0
64567: PPUSH
64568: PPUSH
64569: PPUSH
// pom := GetBase ( fac ) ;
64570: LD_ADDR_VAR 0 5
64574: PUSH
64575: LD_VAR 0 1
64579: PPUSH
64580: CALL_OW 274
64584: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
64585: LD_ADDR_VAR 0 4
64589: PUSH
64590: LD_VAR 0 2
64594: PUSH
64595: LD_INT 1
64597: ARRAY
64598: PPUSH
64599: LD_VAR 0 2
64603: PUSH
64604: LD_INT 2
64606: ARRAY
64607: PPUSH
64608: LD_VAR 0 2
64612: PUSH
64613: LD_INT 3
64615: ARRAY
64616: PPUSH
64617: LD_VAR 0 2
64621: PUSH
64622: LD_INT 4
64624: ARRAY
64625: PPUSH
64626: CALL_OW 449
64630: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64631: LD_ADDR_VAR 0 3
64635: PUSH
64636: LD_VAR 0 5
64640: PPUSH
64641: LD_INT 1
64643: PPUSH
64644: CALL_OW 275
64648: PUSH
64649: LD_VAR 0 4
64653: PUSH
64654: LD_INT 1
64656: ARRAY
64657: GREATEREQUAL
64658: PUSH
64659: LD_VAR 0 5
64663: PPUSH
64664: LD_INT 2
64666: PPUSH
64667: CALL_OW 275
64671: PUSH
64672: LD_VAR 0 4
64676: PUSH
64677: LD_INT 2
64679: ARRAY
64680: GREATEREQUAL
64681: AND
64682: PUSH
64683: LD_VAR 0 5
64687: PPUSH
64688: LD_INT 3
64690: PPUSH
64691: CALL_OW 275
64695: PUSH
64696: LD_VAR 0 4
64700: PUSH
64701: LD_INT 3
64703: ARRAY
64704: GREATEREQUAL
64705: AND
64706: ST_TO_ADDR
// end ;
64707: LD_VAR 0 3
64711: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64712: LD_INT 0
64714: PPUSH
64715: PPUSH
64716: PPUSH
64717: PPUSH
// pom := GetBase ( building ) ;
64718: LD_ADDR_VAR 0 3
64722: PUSH
64723: LD_VAR 0 1
64727: PPUSH
64728: CALL_OW 274
64732: ST_TO_ADDR
// if not pom then
64733: LD_VAR 0 3
64737: NOT
64738: IFFALSE 64742
// exit ;
64740: GO 64912
// btype := GetBType ( building ) ;
64742: LD_ADDR_VAR 0 5
64746: PUSH
64747: LD_VAR 0 1
64751: PPUSH
64752: CALL_OW 266
64756: ST_TO_ADDR
// if btype = b_armoury then
64757: LD_VAR 0 5
64761: PUSH
64762: LD_INT 4
64764: EQUAL
64765: IFFALSE 64775
// btype := b_barracks ;
64767: LD_ADDR_VAR 0 5
64771: PUSH
64772: LD_INT 5
64774: ST_TO_ADDR
// if btype = b_depot then
64775: LD_VAR 0 5
64779: PUSH
64780: LD_INT 0
64782: EQUAL
64783: IFFALSE 64793
// btype := b_warehouse ;
64785: LD_ADDR_VAR 0 5
64789: PUSH
64790: LD_INT 1
64792: ST_TO_ADDR
// if btype = b_workshop then
64793: LD_VAR 0 5
64797: PUSH
64798: LD_INT 2
64800: EQUAL
64801: IFFALSE 64811
// btype := b_factory ;
64803: LD_ADDR_VAR 0 5
64807: PUSH
64808: LD_INT 3
64810: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64811: LD_ADDR_VAR 0 4
64815: PUSH
64816: LD_VAR 0 5
64820: PPUSH
64821: LD_VAR 0 1
64825: PPUSH
64826: CALL_OW 248
64830: PPUSH
64831: CALL_OW 450
64835: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64836: LD_ADDR_VAR 0 2
64840: PUSH
64841: LD_VAR 0 3
64845: PPUSH
64846: LD_INT 1
64848: PPUSH
64849: CALL_OW 275
64853: PUSH
64854: LD_VAR 0 4
64858: PUSH
64859: LD_INT 1
64861: ARRAY
64862: GREATEREQUAL
64863: PUSH
64864: LD_VAR 0 3
64868: PPUSH
64869: LD_INT 2
64871: PPUSH
64872: CALL_OW 275
64876: PUSH
64877: LD_VAR 0 4
64881: PUSH
64882: LD_INT 2
64884: ARRAY
64885: GREATEREQUAL
64886: AND
64887: PUSH
64888: LD_VAR 0 3
64892: PPUSH
64893: LD_INT 3
64895: PPUSH
64896: CALL_OW 275
64900: PUSH
64901: LD_VAR 0 4
64905: PUSH
64906: LD_INT 3
64908: ARRAY
64909: GREATEREQUAL
64910: AND
64911: ST_TO_ADDR
// end ;
64912: LD_VAR 0 2
64916: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64917: LD_INT 0
64919: PPUSH
64920: PPUSH
64921: PPUSH
// pom := GetBase ( building ) ;
64922: LD_ADDR_VAR 0 4
64926: PUSH
64927: LD_VAR 0 1
64931: PPUSH
64932: CALL_OW 274
64936: ST_TO_ADDR
// if not pom then
64937: LD_VAR 0 4
64941: NOT
64942: IFFALSE 64946
// exit ;
64944: GO 65047
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64946: LD_ADDR_VAR 0 5
64950: PUSH
64951: LD_VAR 0 2
64955: PPUSH
64956: LD_VAR 0 1
64960: PPUSH
64961: CALL_OW 248
64965: PPUSH
64966: CALL_OW 450
64970: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64971: LD_ADDR_VAR 0 3
64975: PUSH
64976: LD_VAR 0 4
64980: PPUSH
64981: LD_INT 1
64983: PPUSH
64984: CALL_OW 275
64988: PUSH
64989: LD_VAR 0 5
64993: PUSH
64994: LD_INT 1
64996: ARRAY
64997: GREATEREQUAL
64998: PUSH
64999: LD_VAR 0 4
65003: PPUSH
65004: LD_INT 2
65006: PPUSH
65007: CALL_OW 275
65011: PUSH
65012: LD_VAR 0 5
65016: PUSH
65017: LD_INT 2
65019: ARRAY
65020: GREATEREQUAL
65021: AND
65022: PUSH
65023: LD_VAR 0 4
65027: PPUSH
65028: LD_INT 3
65030: PPUSH
65031: CALL_OW 275
65035: PUSH
65036: LD_VAR 0 5
65040: PUSH
65041: LD_INT 3
65043: ARRAY
65044: GREATEREQUAL
65045: AND
65046: ST_TO_ADDR
// end ;
65047: LD_VAR 0 3
65051: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
65052: LD_INT 0
65054: PPUSH
65055: PPUSH
65056: PPUSH
65057: PPUSH
65058: PPUSH
65059: PPUSH
65060: PPUSH
65061: PPUSH
65062: PPUSH
65063: PPUSH
65064: PPUSH
// result := false ;
65065: LD_ADDR_VAR 0 8
65069: PUSH
65070: LD_INT 0
65072: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
65073: LD_VAR 0 5
65077: NOT
65078: PUSH
65079: LD_VAR 0 1
65083: NOT
65084: OR
65085: PUSH
65086: LD_VAR 0 2
65090: NOT
65091: OR
65092: PUSH
65093: LD_VAR 0 3
65097: NOT
65098: OR
65099: IFFALSE 65103
// exit ;
65101: GO 65917
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
65103: LD_ADDR_VAR 0 14
65107: PUSH
65108: LD_VAR 0 1
65112: PPUSH
65113: LD_VAR 0 2
65117: PPUSH
65118: LD_VAR 0 3
65122: PPUSH
65123: LD_VAR 0 4
65127: PPUSH
65128: LD_VAR 0 5
65132: PUSH
65133: LD_INT 1
65135: ARRAY
65136: PPUSH
65137: CALL_OW 248
65141: PPUSH
65142: LD_INT 0
65144: PPUSH
65145: CALL 67170 0 6
65149: ST_TO_ADDR
// if not hexes then
65150: LD_VAR 0 14
65154: NOT
65155: IFFALSE 65159
// exit ;
65157: GO 65917
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
65159: LD_ADDR_VAR 0 17
65163: PUSH
65164: LD_VAR 0 5
65168: PPUSH
65169: LD_INT 22
65171: PUSH
65172: LD_VAR 0 13
65176: PPUSH
65177: CALL_OW 255
65181: PUSH
65182: EMPTY
65183: LIST
65184: LIST
65185: PUSH
65186: LD_INT 2
65188: PUSH
65189: LD_INT 30
65191: PUSH
65192: LD_INT 0
65194: PUSH
65195: EMPTY
65196: LIST
65197: LIST
65198: PUSH
65199: LD_INT 30
65201: PUSH
65202: LD_INT 1
65204: PUSH
65205: EMPTY
65206: LIST
65207: LIST
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: LIST
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PPUSH
65218: CALL_OW 72
65222: ST_TO_ADDR
// for i = 1 to hexes do
65223: LD_ADDR_VAR 0 9
65227: PUSH
65228: DOUBLE
65229: LD_INT 1
65231: DEC
65232: ST_TO_ADDR
65233: LD_VAR 0 14
65237: PUSH
65238: FOR_TO
65239: IFFALSE 65915
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65241: LD_ADDR_VAR 0 13
65245: PUSH
65246: LD_VAR 0 14
65250: PUSH
65251: LD_VAR 0 9
65255: ARRAY
65256: PUSH
65257: LD_INT 1
65259: ARRAY
65260: PPUSH
65261: LD_VAR 0 14
65265: PUSH
65266: LD_VAR 0 9
65270: ARRAY
65271: PUSH
65272: LD_INT 2
65274: ARRAY
65275: PPUSH
65276: CALL_OW 428
65280: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
65281: LD_VAR 0 14
65285: PUSH
65286: LD_VAR 0 9
65290: ARRAY
65291: PUSH
65292: LD_INT 1
65294: ARRAY
65295: PPUSH
65296: LD_VAR 0 14
65300: PUSH
65301: LD_VAR 0 9
65305: ARRAY
65306: PUSH
65307: LD_INT 2
65309: ARRAY
65310: PPUSH
65311: CALL_OW 351
65315: PUSH
65316: LD_VAR 0 14
65320: PUSH
65321: LD_VAR 0 9
65325: ARRAY
65326: PUSH
65327: LD_INT 1
65329: ARRAY
65330: PPUSH
65331: LD_VAR 0 14
65335: PUSH
65336: LD_VAR 0 9
65340: ARRAY
65341: PUSH
65342: LD_INT 2
65344: ARRAY
65345: PPUSH
65346: CALL_OW 488
65350: NOT
65351: OR
65352: PUSH
65353: LD_VAR 0 13
65357: PPUSH
65358: CALL_OW 247
65362: PUSH
65363: LD_INT 3
65365: EQUAL
65366: OR
65367: IFFALSE 65373
// exit ;
65369: POP
65370: POP
65371: GO 65917
// if not tmp then
65373: LD_VAR 0 13
65377: NOT
65378: IFFALSE 65382
// continue ;
65380: GO 65238
// result := true ;
65382: LD_ADDR_VAR 0 8
65386: PUSH
65387: LD_INT 1
65389: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
65390: LD_VAR 0 6
65394: PUSH
65395: LD_VAR 0 13
65399: PPUSH
65400: CALL_OW 247
65404: PUSH
65405: LD_INT 2
65407: EQUAL
65408: AND
65409: PUSH
65410: LD_VAR 0 13
65414: PPUSH
65415: CALL_OW 263
65419: PUSH
65420: LD_INT 1
65422: EQUAL
65423: AND
65424: IFFALSE 65588
// begin if IsDrivenBy ( tmp ) then
65426: LD_VAR 0 13
65430: PPUSH
65431: CALL_OW 311
65435: IFFALSE 65439
// continue ;
65437: GO 65238
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
65439: LD_VAR 0 6
65443: PPUSH
65444: LD_INT 3
65446: PUSH
65447: LD_INT 60
65449: PUSH
65450: EMPTY
65451: LIST
65452: PUSH
65453: EMPTY
65454: LIST
65455: LIST
65456: PUSH
65457: LD_INT 3
65459: PUSH
65460: LD_INT 55
65462: PUSH
65463: EMPTY
65464: LIST
65465: PUSH
65466: EMPTY
65467: LIST
65468: LIST
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PPUSH
65474: CALL_OW 72
65478: IFFALSE 65586
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
65480: LD_ADDR_VAR 0 18
65484: PUSH
65485: LD_VAR 0 6
65489: PPUSH
65490: LD_INT 3
65492: PUSH
65493: LD_INT 60
65495: PUSH
65496: EMPTY
65497: LIST
65498: PUSH
65499: EMPTY
65500: LIST
65501: LIST
65502: PUSH
65503: LD_INT 3
65505: PUSH
65506: LD_INT 55
65508: PUSH
65509: EMPTY
65510: LIST
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: PUSH
65516: EMPTY
65517: LIST
65518: LIST
65519: PPUSH
65520: CALL_OW 72
65524: PUSH
65525: LD_INT 1
65527: ARRAY
65528: ST_TO_ADDR
// if IsInUnit ( driver ) then
65529: LD_VAR 0 18
65533: PPUSH
65534: CALL_OW 310
65538: IFFALSE 65549
// ComExit ( driver ) ;
65540: LD_VAR 0 18
65544: PPUSH
65545: CALL 90962 0 1
// AddComEnterUnit ( driver , tmp ) ;
65549: LD_VAR 0 18
65553: PPUSH
65554: LD_VAR 0 13
65558: PPUSH
65559: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
65563: LD_VAR 0 18
65567: PPUSH
65568: LD_VAR 0 7
65572: PPUSH
65573: CALL_OW 173
// AddComExitVehicle ( driver ) ;
65577: LD_VAR 0 18
65581: PPUSH
65582: CALL_OW 181
// end ; continue ;
65586: GO 65238
// end ; if not cleaners or not tmp in cleaners then
65588: LD_VAR 0 6
65592: NOT
65593: PUSH
65594: LD_VAR 0 13
65598: PUSH
65599: LD_VAR 0 6
65603: IN
65604: NOT
65605: OR
65606: IFFALSE 65913
// begin if dep then
65608: LD_VAR 0 17
65612: IFFALSE 65748
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
65614: LD_ADDR_VAR 0 16
65618: PUSH
65619: LD_VAR 0 17
65623: PUSH
65624: LD_INT 1
65626: ARRAY
65627: PPUSH
65628: CALL_OW 250
65632: PPUSH
65633: LD_VAR 0 17
65637: PUSH
65638: LD_INT 1
65640: ARRAY
65641: PPUSH
65642: CALL_OW 254
65646: PPUSH
65647: LD_INT 5
65649: PPUSH
65650: CALL_OW 272
65654: PUSH
65655: LD_VAR 0 17
65659: PUSH
65660: LD_INT 1
65662: ARRAY
65663: PPUSH
65664: CALL_OW 251
65668: PPUSH
65669: LD_VAR 0 17
65673: PUSH
65674: LD_INT 1
65676: ARRAY
65677: PPUSH
65678: CALL_OW 254
65682: PPUSH
65683: LD_INT 5
65685: PPUSH
65686: CALL_OW 273
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
65695: LD_VAR 0 16
65699: PUSH
65700: LD_INT 1
65702: ARRAY
65703: PPUSH
65704: LD_VAR 0 16
65708: PUSH
65709: LD_INT 2
65711: ARRAY
65712: PPUSH
65713: CALL_OW 488
65717: IFFALSE 65748
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
65719: LD_VAR 0 13
65723: PPUSH
65724: LD_VAR 0 16
65728: PUSH
65729: LD_INT 1
65731: ARRAY
65732: PPUSH
65733: LD_VAR 0 16
65737: PUSH
65738: LD_INT 2
65740: ARRAY
65741: PPUSH
65742: CALL_OW 111
// continue ;
65746: GO 65238
// end ; end ; r := GetDir ( tmp ) ;
65748: LD_ADDR_VAR 0 15
65752: PUSH
65753: LD_VAR 0 13
65757: PPUSH
65758: CALL_OW 254
65762: ST_TO_ADDR
// if r = 5 then
65763: LD_VAR 0 15
65767: PUSH
65768: LD_INT 5
65770: EQUAL
65771: IFFALSE 65781
// r := 0 ;
65773: LD_ADDR_VAR 0 15
65777: PUSH
65778: LD_INT 0
65780: ST_TO_ADDR
// for j = r to 5 do
65781: LD_ADDR_VAR 0 10
65785: PUSH
65786: DOUBLE
65787: LD_VAR 0 15
65791: DEC
65792: ST_TO_ADDR
65793: LD_INT 5
65795: PUSH
65796: FOR_TO
65797: IFFALSE 65911
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
65799: LD_ADDR_VAR 0 11
65803: PUSH
65804: LD_VAR 0 13
65808: PPUSH
65809: CALL_OW 250
65813: PPUSH
65814: LD_VAR 0 10
65818: PPUSH
65819: LD_INT 2
65821: PPUSH
65822: CALL_OW 272
65826: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
65827: LD_ADDR_VAR 0 12
65831: PUSH
65832: LD_VAR 0 13
65836: PPUSH
65837: CALL_OW 251
65841: PPUSH
65842: LD_VAR 0 10
65846: PPUSH
65847: LD_INT 2
65849: PPUSH
65850: CALL_OW 273
65854: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
65855: LD_VAR 0 11
65859: PPUSH
65860: LD_VAR 0 12
65864: PPUSH
65865: CALL_OW 488
65869: PUSH
65870: LD_VAR 0 11
65874: PPUSH
65875: LD_VAR 0 12
65879: PPUSH
65880: CALL_OW 428
65884: NOT
65885: AND
65886: IFFALSE 65909
// begin ComMoveXY ( tmp , _x , _y ) ;
65888: LD_VAR 0 13
65892: PPUSH
65893: LD_VAR 0 11
65897: PPUSH
65898: LD_VAR 0 12
65902: PPUSH
65903: CALL_OW 111
// break ;
65907: GO 65911
// end ; end ;
65909: GO 65796
65911: POP
65912: POP
// end ; end ;
65913: GO 65238
65915: POP
65916: POP
// end ;
65917: LD_VAR 0 8
65921: RET
// export function BuildingTechInvented ( side , btype ) ; begin
65922: LD_INT 0
65924: PPUSH
// result := true ;
65925: LD_ADDR_VAR 0 3
65929: PUSH
65930: LD_INT 1
65932: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
65933: LD_VAR 0 2
65937: PUSH
65938: LD_INT 24
65940: DOUBLE
65941: EQUAL
65942: IFTRUE 65952
65944: LD_INT 33
65946: DOUBLE
65947: EQUAL
65948: IFTRUE 65952
65950: GO 65977
65952: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
65953: LD_ADDR_VAR 0 3
65957: PUSH
65958: LD_INT 32
65960: PPUSH
65961: LD_VAR 0 1
65965: PPUSH
65966: CALL_OW 321
65970: PUSH
65971: LD_INT 2
65973: EQUAL
65974: ST_TO_ADDR
65975: GO 66293
65977: LD_INT 20
65979: DOUBLE
65980: EQUAL
65981: IFTRUE 65985
65983: GO 66010
65985: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
65986: LD_ADDR_VAR 0 3
65990: PUSH
65991: LD_INT 6
65993: PPUSH
65994: LD_VAR 0 1
65998: PPUSH
65999: CALL_OW 321
66003: PUSH
66004: LD_INT 2
66006: EQUAL
66007: ST_TO_ADDR
66008: GO 66293
66010: LD_INT 22
66012: DOUBLE
66013: EQUAL
66014: IFTRUE 66024
66016: LD_INT 36
66018: DOUBLE
66019: EQUAL
66020: IFTRUE 66024
66022: GO 66049
66024: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
66025: LD_ADDR_VAR 0 3
66029: PUSH
66030: LD_INT 15
66032: PPUSH
66033: LD_VAR 0 1
66037: PPUSH
66038: CALL_OW 321
66042: PUSH
66043: LD_INT 2
66045: EQUAL
66046: ST_TO_ADDR
66047: GO 66293
66049: LD_INT 30
66051: DOUBLE
66052: EQUAL
66053: IFTRUE 66057
66055: GO 66082
66057: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
66058: LD_ADDR_VAR 0 3
66062: PUSH
66063: LD_INT 20
66065: PPUSH
66066: LD_VAR 0 1
66070: PPUSH
66071: CALL_OW 321
66075: PUSH
66076: LD_INT 2
66078: EQUAL
66079: ST_TO_ADDR
66080: GO 66293
66082: LD_INT 28
66084: DOUBLE
66085: EQUAL
66086: IFTRUE 66096
66088: LD_INT 21
66090: DOUBLE
66091: EQUAL
66092: IFTRUE 66096
66094: GO 66121
66096: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
66097: LD_ADDR_VAR 0 3
66101: PUSH
66102: LD_INT 21
66104: PPUSH
66105: LD_VAR 0 1
66109: PPUSH
66110: CALL_OW 321
66114: PUSH
66115: LD_INT 2
66117: EQUAL
66118: ST_TO_ADDR
66119: GO 66293
66121: LD_INT 16
66123: DOUBLE
66124: EQUAL
66125: IFTRUE 66129
66127: GO 66154
66129: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
66130: LD_ADDR_VAR 0 3
66134: PUSH
66135: LD_INT 84
66137: PPUSH
66138: LD_VAR 0 1
66142: PPUSH
66143: CALL_OW 321
66147: PUSH
66148: LD_INT 2
66150: EQUAL
66151: ST_TO_ADDR
66152: GO 66293
66154: LD_INT 19
66156: DOUBLE
66157: EQUAL
66158: IFTRUE 66168
66160: LD_INT 23
66162: DOUBLE
66163: EQUAL
66164: IFTRUE 66168
66166: GO 66193
66168: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
66169: LD_ADDR_VAR 0 3
66173: PUSH
66174: LD_INT 83
66176: PPUSH
66177: LD_VAR 0 1
66181: PPUSH
66182: CALL_OW 321
66186: PUSH
66187: LD_INT 2
66189: EQUAL
66190: ST_TO_ADDR
66191: GO 66293
66193: LD_INT 17
66195: DOUBLE
66196: EQUAL
66197: IFTRUE 66201
66199: GO 66226
66201: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
66202: LD_ADDR_VAR 0 3
66206: PUSH
66207: LD_INT 39
66209: PPUSH
66210: LD_VAR 0 1
66214: PPUSH
66215: CALL_OW 321
66219: PUSH
66220: LD_INT 2
66222: EQUAL
66223: ST_TO_ADDR
66224: GO 66293
66226: LD_INT 18
66228: DOUBLE
66229: EQUAL
66230: IFTRUE 66234
66232: GO 66259
66234: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
66235: LD_ADDR_VAR 0 3
66239: PUSH
66240: LD_INT 40
66242: PPUSH
66243: LD_VAR 0 1
66247: PPUSH
66248: CALL_OW 321
66252: PUSH
66253: LD_INT 2
66255: EQUAL
66256: ST_TO_ADDR
66257: GO 66293
66259: LD_INT 27
66261: DOUBLE
66262: EQUAL
66263: IFTRUE 66267
66265: GO 66292
66267: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
66268: LD_ADDR_VAR 0 3
66272: PUSH
66273: LD_INT 35
66275: PPUSH
66276: LD_VAR 0 1
66280: PPUSH
66281: CALL_OW 321
66285: PUSH
66286: LD_INT 2
66288: EQUAL
66289: ST_TO_ADDR
66290: GO 66293
66292: POP
// end ;
66293: LD_VAR 0 3
66297: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
66298: LD_INT 0
66300: PPUSH
66301: PPUSH
66302: PPUSH
66303: PPUSH
66304: PPUSH
66305: PPUSH
66306: PPUSH
66307: PPUSH
66308: PPUSH
66309: PPUSH
66310: PPUSH
// result := false ;
66311: LD_ADDR_VAR 0 6
66315: PUSH
66316: LD_INT 0
66318: ST_TO_ADDR
// if btype = b_depot then
66319: LD_VAR 0 2
66323: PUSH
66324: LD_INT 0
66326: EQUAL
66327: IFFALSE 66339
// begin result := true ;
66329: LD_ADDR_VAR 0 6
66333: PUSH
66334: LD_INT 1
66336: ST_TO_ADDR
// exit ;
66337: GO 67165
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
66339: LD_VAR 0 1
66343: NOT
66344: PUSH
66345: LD_VAR 0 1
66349: PPUSH
66350: CALL_OW 266
66354: PUSH
66355: LD_INT 0
66357: PUSH
66358: LD_INT 1
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: IN
66365: NOT
66366: OR
66367: PUSH
66368: LD_VAR 0 2
66372: NOT
66373: OR
66374: PUSH
66375: LD_VAR 0 5
66379: PUSH
66380: LD_INT 0
66382: PUSH
66383: LD_INT 1
66385: PUSH
66386: LD_INT 2
66388: PUSH
66389: LD_INT 3
66391: PUSH
66392: LD_INT 4
66394: PUSH
66395: LD_INT 5
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: IN
66406: NOT
66407: OR
66408: PUSH
66409: LD_VAR 0 3
66413: PPUSH
66414: LD_VAR 0 4
66418: PPUSH
66419: CALL_OW 488
66423: NOT
66424: OR
66425: IFFALSE 66429
// exit ;
66427: GO 67165
// side := GetSide ( depot ) ;
66429: LD_ADDR_VAR 0 9
66433: PUSH
66434: LD_VAR 0 1
66438: PPUSH
66439: CALL_OW 255
66443: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
66444: LD_VAR 0 9
66448: PPUSH
66449: LD_VAR 0 2
66453: PPUSH
66454: CALL 65922 0 2
66458: NOT
66459: IFFALSE 66463
// exit ;
66461: GO 67165
// pom := GetBase ( depot ) ;
66463: LD_ADDR_VAR 0 10
66467: PUSH
66468: LD_VAR 0 1
66472: PPUSH
66473: CALL_OW 274
66477: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
66478: LD_ADDR_VAR 0 11
66482: PUSH
66483: LD_VAR 0 2
66487: PPUSH
66488: LD_VAR 0 1
66492: PPUSH
66493: CALL_OW 248
66497: PPUSH
66498: CALL_OW 450
66502: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
66503: LD_VAR 0 10
66507: PPUSH
66508: LD_INT 1
66510: PPUSH
66511: CALL_OW 275
66515: PUSH
66516: LD_VAR 0 11
66520: PUSH
66521: LD_INT 1
66523: ARRAY
66524: GREATEREQUAL
66525: PUSH
66526: LD_VAR 0 10
66530: PPUSH
66531: LD_INT 2
66533: PPUSH
66534: CALL_OW 275
66538: PUSH
66539: LD_VAR 0 11
66543: PUSH
66544: LD_INT 2
66546: ARRAY
66547: GREATEREQUAL
66548: AND
66549: PUSH
66550: LD_VAR 0 10
66554: PPUSH
66555: LD_INT 3
66557: PPUSH
66558: CALL_OW 275
66562: PUSH
66563: LD_VAR 0 11
66567: PUSH
66568: LD_INT 3
66570: ARRAY
66571: GREATEREQUAL
66572: AND
66573: NOT
66574: IFFALSE 66578
// exit ;
66576: GO 67165
// if GetBType ( depot ) = b_depot then
66578: LD_VAR 0 1
66582: PPUSH
66583: CALL_OW 266
66587: PUSH
66588: LD_INT 0
66590: EQUAL
66591: IFFALSE 66603
// dist := 28 else
66593: LD_ADDR_VAR 0 14
66597: PUSH
66598: LD_INT 28
66600: ST_TO_ADDR
66601: GO 66611
// dist := 36 ;
66603: LD_ADDR_VAR 0 14
66607: PUSH
66608: LD_INT 36
66610: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
66611: LD_VAR 0 1
66615: PPUSH
66616: LD_VAR 0 3
66620: PPUSH
66621: LD_VAR 0 4
66625: PPUSH
66626: CALL_OW 297
66630: PUSH
66631: LD_VAR 0 14
66635: GREATER
66636: IFFALSE 66640
// exit ;
66638: GO 67165
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
66640: LD_ADDR_VAR 0 12
66644: PUSH
66645: LD_VAR 0 2
66649: PPUSH
66650: LD_VAR 0 3
66654: PPUSH
66655: LD_VAR 0 4
66659: PPUSH
66660: LD_VAR 0 5
66664: PPUSH
66665: LD_VAR 0 1
66669: PPUSH
66670: CALL_OW 248
66674: PPUSH
66675: LD_INT 0
66677: PPUSH
66678: CALL 67170 0 6
66682: ST_TO_ADDR
// if not hexes then
66683: LD_VAR 0 12
66687: NOT
66688: IFFALSE 66692
// exit ;
66690: GO 67165
// hex := GetHexInfo ( x , y ) ;
66692: LD_ADDR_VAR 0 15
66696: PUSH
66697: LD_VAR 0 3
66701: PPUSH
66702: LD_VAR 0 4
66706: PPUSH
66707: CALL_OW 546
66711: ST_TO_ADDR
// if hex [ 1 ] then
66712: LD_VAR 0 15
66716: PUSH
66717: LD_INT 1
66719: ARRAY
66720: IFFALSE 66724
// exit ;
66722: GO 67165
// height := hex [ 2 ] ;
66724: LD_ADDR_VAR 0 13
66728: PUSH
66729: LD_VAR 0 15
66733: PUSH
66734: LD_INT 2
66736: ARRAY
66737: ST_TO_ADDR
// for i = 1 to hexes do
66738: LD_ADDR_VAR 0 7
66742: PUSH
66743: DOUBLE
66744: LD_INT 1
66746: DEC
66747: ST_TO_ADDR
66748: LD_VAR 0 12
66752: PUSH
66753: FOR_TO
66754: IFFALSE 67084
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
66756: LD_VAR 0 12
66760: PUSH
66761: LD_VAR 0 7
66765: ARRAY
66766: PUSH
66767: LD_INT 1
66769: ARRAY
66770: PPUSH
66771: LD_VAR 0 12
66775: PUSH
66776: LD_VAR 0 7
66780: ARRAY
66781: PUSH
66782: LD_INT 2
66784: ARRAY
66785: PPUSH
66786: CALL_OW 488
66790: NOT
66791: PUSH
66792: LD_VAR 0 12
66796: PUSH
66797: LD_VAR 0 7
66801: ARRAY
66802: PUSH
66803: LD_INT 1
66805: ARRAY
66806: PPUSH
66807: LD_VAR 0 12
66811: PUSH
66812: LD_VAR 0 7
66816: ARRAY
66817: PUSH
66818: LD_INT 2
66820: ARRAY
66821: PPUSH
66822: CALL_OW 428
66826: PUSH
66827: LD_INT 0
66829: GREATER
66830: OR
66831: PUSH
66832: LD_VAR 0 12
66836: PUSH
66837: LD_VAR 0 7
66841: ARRAY
66842: PUSH
66843: LD_INT 1
66845: ARRAY
66846: PPUSH
66847: LD_VAR 0 12
66851: PUSH
66852: LD_VAR 0 7
66856: ARRAY
66857: PUSH
66858: LD_INT 2
66860: ARRAY
66861: PPUSH
66862: CALL_OW 351
66866: OR
66867: IFFALSE 66873
// exit ;
66869: POP
66870: POP
66871: GO 67165
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
66873: LD_ADDR_VAR 0 8
66877: PUSH
66878: LD_VAR 0 12
66882: PUSH
66883: LD_VAR 0 7
66887: ARRAY
66888: PUSH
66889: LD_INT 1
66891: ARRAY
66892: PPUSH
66893: LD_VAR 0 12
66897: PUSH
66898: LD_VAR 0 7
66902: ARRAY
66903: PUSH
66904: LD_INT 2
66906: ARRAY
66907: PPUSH
66908: CALL_OW 546
66912: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
66913: LD_VAR 0 8
66917: PUSH
66918: LD_INT 1
66920: ARRAY
66921: PUSH
66922: LD_VAR 0 8
66926: PUSH
66927: LD_INT 2
66929: ARRAY
66930: PUSH
66931: LD_VAR 0 13
66935: PUSH
66936: LD_INT 2
66938: PLUS
66939: GREATER
66940: OR
66941: PUSH
66942: LD_VAR 0 8
66946: PUSH
66947: LD_INT 2
66949: ARRAY
66950: PUSH
66951: LD_VAR 0 13
66955: PUSH
66956: LD_INT 2
66958: MINUS
66959: LESS
66960: OR
66961: PUSH
66962: LD_VAR 0 8
66966: PUSH
66967: LD_INT 3
66969: ARRAY
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: LD_INT 8
66976: PUSH
66977: LD_INT 9
66979: PUSH
66980: LD_INT 10
66982: PUSH
66983: LD_INT 11
66985: PUSH
66986: LD_INT 12
66988: PUSH
66989: LD_INT 13
66991: PUSH
66992: LD_INT 16
66994: PUSH
66995: LD_INT 17
66997: PUSH
66998: LD_INT 18
67000: PUSH
67001: LD_INT 19
67003: PUSH
67004: LD_INT 20
67006: PUSH
67007: LD_INT 21
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: LIST
67024: IN
67025: NOT
67026: OR
67027: PUSH
67028: LD_VAR 0 8
67032: PUSH
67033: LD_INT 5
67035: ARRAY
67036: NOT
67037: OR
67038: PUSH
67039: LD_VAR 0 8
67043: PUSH
67044: LD_INT 6
67046: ARRAY
67047: PUSH
67048: LD_INT 1
67050: PUSH
67051: LD_INT 2
67053: PUSH
67054: LD_INT 7
67056: PUSH
67057: LD_INT 9
67059: PUSH
67060: LD_INT 10
67062: PUSH
67063: LD_INT 11
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: IN
67074: NOT
67075: OR
67076: IFFALSE 67082
// exit ;
67078: POP
67079: POP
67080: GO 67165
// end ;
67082: GO 66753
67084: POP
67085: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
67086: LD_VAR 0 9
67090: PPUSH
67091: LD_VAR 0 3
67095: PPUSH
67096: LD_VAR 0 4
67100: PPUSH
67101: LD_INT 20
67103: PPUSH
67104: CALL 59088 0 4
67108: PUSH
67109: LD_INT 4
67111: ARRAY
67112: IFFALSE 67116
// exit ;
67114: GO 67165
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
67116: LD_VAR 0 2
67120: PUSH
67121: LD_INT 29
67123: PUSH
67124: LD_INT 30
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: IN
67131: PUSH
67132: LD_VAR 0 3
67136: PPUSH
67137: LD_VAR 0 4
67141: PPUSH
67142: LD_VAR 0 9
67146: PPUSH
67147: CALL_OW 440
67151: NOT
67152: AND
67153: IFFALSE 67157
// exit ;
67155: GO 67165
// result := true ;
67157: LD_ADDR_VAR 0 6
67161: PUSH
67162: LD_INT 1
67164: ST_TO_ADDR
// end ;
67165: LD_VAR 0 6
67169: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
67170: LD_INT 0
67172: PPUSH
67173: PPUSH
67174: PPUSH
67175: PPUSH
67176: PPUSH
67177: PPUSH
67178: PPUSH
67179: PPUSH
67180: PPUSH
67181: PPUSH
67182: PPUSH
67183: PPUSH
67184: PPUSH
67185: PPUSH
67186: PPUSH
67187: PPUSH
67188: PPUSH
67189: PPUSH
67190: PPUSH
67191: PPUSH
67192: PPUSH
67193: PPUSH
67194: PPUSH
67195: PPUSH
67196: PPUSH
67197: PPUSH
67198: PPUSH
67199: PPUSH
67200: PPUSH
67201: PPUSH
67202: PPUSH
67203: PPUSH
67204: PPUSH
67205: PPUSH
67206: PPUSH
67207: PPUSH
67208: PPUSH
67209: PPUSH
67210: PPUSH
67211: PPUSH
67212: PPUSH
67213: PPUSH
67214: PPUSH
67215: PPUSH
67216: PPUSH
67217: PPUSH
67218: PPUSH
67219: PPUSH
67220: PPUSH
67221: PPUSH
67222: PPUSH
67223: PPUSH
67224: PPUSH
67225: PPUSH
67226: PPUSH
67227: PPUSH
67228: PPUSH
67229: PPUSH
// result = [ ] ;
67230: LD_ADDR_VAR 0 7
67234: PUSH
67235: EMPTY
67236: ST_TO_ADDR
// temp_list = [ ] ;
67237: LD_ADDR_VAR 0 9
67241: PUSH
67242: EMPTY
67243: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
67244: LD_VAR 0 4
67248: PUSH
67249: LD_INT 0
67251: PUSH
67252: LD_INT 1
67254: PUSH
67255: LD_INT 2
67257: PUSH
67258: LD_INT 3
67260: PUSH
67261: LD_INT 4
67263: PUSH
67264: LD_INT 5
67266: PUSH
67267: EMPTY
67268: LIST
67269: LIST
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: IN
67275: NOT
67276: PUSH
67277: LD_VAR 0 1
67281: PUSH
67282: LD_INT 0
67284: PUSH
67285: LD_INT 1
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: IN
67292: PUSH
67293: LD_VAR 0 5
67297: PUSH
67298: LD_INT 1
67300: PUSH
67301: LD_INT 2
67303: PUSH
67304: LD_INT 3
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: LIST
67311: IN
67312: NOT
67313: AND
67314: OR
67315: IFFALSE 67319
// exit ;
67317: GO 85710
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
67319: LD_VAR 0 1
67323: PUSH
67324: LD_INT 6
67326: PUSH
67327: LD_INT 7
67329: PUSH
67330: LD_INT 8
67332: PUSH
67333: LD_INT 13
67335: PUSH
67336: LD_INT 12
67338: PUSH
67339: LD_INT 15
67341: PUSH
67342: LD_INT 11
67344: PUSH
67345: LD_INT 14
67347: PUSH
67348: LD_INT 10
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: LIST
67355: LIST
67356: LIST
67357: LIST
67358: LIST
67359: LIST
67360: LIST
67361: IN
67362: IFFALSE 67372
// btype = b_lab ;
67364: LD_ADDR_VAR 0 1
67368: PUSH
67369: LD_INT 6
67371: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
67372: LD_VAR 0 6
67376: PUSH
67377: LD_INT 0
67379: PUSH
67380: LD_INT 1
67382: PUSH
67383: LD_INT 2
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: LIST
67390: IN
67391: NOT
67392: PUSH
67393: LD_VAR 0 1
67397: PUSH
67398: LD_INT 0
67400: PUSH
67401: LD_INT 1
67403: PUSH
67404: LD_INT 2
67406: PUSH
67407: LD_INT 3
67409: PUSH
67410: LD_INT 6
67412: PUSH
67413: LD_INT 36
67415: PUSH
67416: LD_INT 4
67418: PUSH
67419: LD_INT 5
67421: PUSH
67422: LD_INT 31
67424: PUSH
67425: LD_INT 32
67427: PUSH
67428: LD_INT 33
67430: PUSH
67431: EMPTY
67432: LIST
67433: LIST
67434: LIST
67435: LIST
67436: LIST
67437: LIST
67438: LIST
67439: LIST
67440: LIST
67441: LIST
67442: LIST
67443: IN
67444: NOT
67445: PUSH
67446: LD_VAR 0 6
67450: PUSH
67451: LD_INT 1
67453: EQUAL
67454: AND
67455: OR
67456: PUSH
67457: LD_VAR 0 1
67461: PUSH
67462: LD_INT 2
67464: PUSH
67465: LD_INT 3
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: IN
67472: NOT
67473: PUSH
67474: LD_VAR 0 6
67478: PUSH
67479: LD_INT 2
67481: EQUAL
67482: AND
67483: OR
67484: IFFALSE 67494
// mode = 0 ;
67486: LD_ADDR_VAR 0 6
67490: PUSH
67491: LD_INT 0
67493: ST_TO_ADDR
// case mode of 0 :
67494: LD_VAR 0 6
67498: PUSH
67499: LD_INT 0
67501: DOUBLE
67502: EQUAL
67503: IFTRUE 67507
67505: GO 78960
67507: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67508: LD_ADDR_VAR 0 11
67512: PUSH
67513: LD_INT 0
67515: PUSH
67516: LD_INT 0
67518: PUSH
67519: EMPTY
67520: LIST
67521: LIST
67522: PUSH
67523: LD_INT 0
67525: PUSH
67526: LD_INT 1
67528: NEG
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: PUSH
67537: LD_INT 0
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 1
67546: PUSH
67547: LD_INT 1
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 0
67556: PUSH
67557: LD_INT 1
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 1
67566: NEG
67567: PUSH
67568: LD_INT 0
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 1
67577: NEG
67578: PUSH
67579: LD_INT 1
67581: NEG
67582: PUSH
67583: EMPTY
67584: LIST
67585: LIST
67586: PUSH
67587: LD_INT 1
67589: NEG
67590: PUSH
67591: LD_INT 2
67593: NEG
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PUSH
67599: LD_INT 0
67601: PUSH
67602: LD_INT 2
67604: NEG
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 1
67612: PUSH
67613: LD_INT 1
67615: NEG
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: PUSH
67621: LD_INT 1
67623: PUSH
67624: LD_INT 2
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 0
67633: PUSH
67634: LD_INT 2
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 1
67643: NEG
67644: PUSH
67645: LD_INT 1
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 1
67654: PUSH
67655: LD_INT 3
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 0
67664: PUSH
67665: LD_INT 3
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 1
67674: NEG
67675: PUSH
67676: LD_INT 2
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: LIST
67687: LIST
67688: LIST
67689: LIST
67690: LIST
67691: LIST
67692: LIST
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67701: LD_ADDR_VAR 0 12
67705: PUSH
67706: LD_INT 0
67708: PUSH
67709: LD_INT 0
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 0
67718: PUSH
67719: LD_INT 1
67721: NEG
67722: PUSH
67723: EMPTY
67724: LIST
67725: LIST
67726: PUSH
67727: LD_INT 1
67729: PUSH
67730: LD_INT 0
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: LD_INT 1
67739: PUSH
67740: LD_INT 1
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: LD_INT 1
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: PUSH
67757: LD_INT 1
67759: NEG
67760: PUSH
67761: LD_INT 0
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 1
67770: NEG
67771: PUSH
67772: LD_INT 1
67774: NEG
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 1
67782: PUSH
67783: LD_INT 1
67785: NEG
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PUSH
67791: LD_INT 2
67793: PUSH
67794: LD_INT 0
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 2
67803: PUSH
67804: LD_INT 1
67806: PUSH
67807: EMPTY
67808: LIST
67809: LIST
67810: PUSH
67811: LD_INT 1
67813: NEG
67814: PUSH
67815: LD_INT 1
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: LD_INT 2
67824: NEG
67825: PUSH
67826: LD_INT 0
67828: PUSH
67829: EMPTY
67830: LIST
67831: LIST
67832: PUSH
67833: LD_INT 2
67835: NEG
67836: PUSH
67837: LD_INT 1
67839: NEG
67840: PUSH
67841: EMPTY
67842: LIST
67843: LIST
67844: PUSH
67845: LD_INT 2
67847: NEG
67848: PUSH
67849: LD_INT 1
67851: PUSH
67852: EMPTY
67853: LIST
67854: LIST
67855: PUSH
67856: LD_INT 3
67858: NEG
67859: PUSH
67860: LD_INT 0
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: PUSH
67867: LD_INT 3
67869: NEG
67870: PUSH
67871: LD_INT 1
67873: NEG
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: LIST
67886: LIST
67887: LIST
67888: LIST
67889: LIST
67890: LIST
67891: LIST
67892: LIST
67893: LIST
67894: LIST
67895: LIST
67896: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67897: LD_ADDR_VAR 0 13
67901: PUSH
67902: LD_INT 0
67904: PUSH
67905: LD_INT 0
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: PUSH
67912: LD_INT 0
67914: PUSH
67915: LD_INT 1
67917: NEG
67918: PUSH
67919: EMPTY
67920: LIST
67921: LIST
67922: PUSH
67923: LD_INT 1
67925: PUSH
67926: LD_INT 0
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 1
67935: PUSH
67936: LD_INT 1
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PUSH
67943: LD_INT 0
67945: PUSH
67946: LD_INT 1
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 1
67955: NEG
67956: PUSH
67957: LD_INT 0
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 1
67966: NEG
67967: PUSH
67968: LD_INT 1
67970: NEG
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 1
67978: NEG
67979: PUSH
67980: LD_INT 2
67982: NEG
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 2
67990: PUSH
67991: LD_INT 1
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PUSH
67998: LD_INT 2
68000: PUSH
68001: LD_INT 2
68003: PUSH
68004: EMPTY
68005: LIST
68006: LIST
68007: PUSH
68008: LD_INT 1
68010: PUSH
68011: LD_INT 2
68013: PUSH
68014: EMPTY
68015: LIST
68016: LIST
68017: PUSH
68018: LD_INT 2
68020: NEG
68021: PUSH
68022: LD_INT 1
68024: NEG
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: PUSH
68030: LD_INT 2
68032: NEG
68033: PUSH
68034: LD_INT 2
68036: NEG
68037: PUSH
68038: EMPTY
68039: LIST
68040: LIST
68041: PUSH
68042: LD_INT 2
68044: NEG
68045: PUSH
68046: LD_INT 3
68048: NEG
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 3
68056: NEG
68057: PUSH
68058: LD_INT 2
68060: NEG
68061: PUSH
68062: EMPTY
68063: LIST
68064: LIST
68065: PUSH
68066: LD_INT 3
68068: NEG
68069: PUSH
68070: LD_INT 3
68072: NEG
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
68096: LD_ADDR_VAR 0 14
68100: PUSH
68101: LD_INT 0
68103: PUSH
68104: LD_INT 0
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: PUSH
68111: LD_INT 0
68113: PUSH
68114: LD_INT 1
68116: NEG
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 1
68124: PUSH
68125: LD_INT 0
68127: PUSH
68128: EMPTY
68129: LIST
68130: LIST
68131: PUSH
68132: LD_INT 1
68134: PUSH
68135: LD_INT 1
68137: PUSH
68138: EMPTY
68139: LIST
68140: LIST
68141: PUSH
68142: LD_INT 0
68144: PUSH
68145: LD_INT 1
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PUSH
68152: LD_INT 1
68154: NEG
68155: PUSH
68156: LD_INT 0
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: LD_INT 1
68165: NEG
68166: PUSH
68167: LD_INT 1
68169: NEG
68170: PUSH
68171: EMPTY
68172: LIST
68173: LIST
68174: PUSH
68175: LD_INT 1
68177: NEG
68178: PUSH
68179: LD_INT 2
68181: NEG
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PUSH
68187: LD_INT 0
68189: PUSH
68190: LD_INT 2
68192: NEG
68193: PUSH
68194: EMPTY
68195: LIST
68196: LIST
68197: PUSH
68198: LD_INT 1
68200: PUSH
68201: LD_INT 1
68203: NEG
68204: PUSH
68205: EMPTY
68206: LIST
68207: LIST
68208: PUSH
68209: LD_INT 1
68211: PUSH
68212: LD_INT 2
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: PUSH
68219: LD_INT 0
68221: PUSH
68222: LD_INT 2
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 1
68231: NEG
68232: PUSH
68233: LD_INT 1
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 1
68242: NEG
68243: PUSH
68244: LD_INT 3
68246: NEG
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 0
68254: PUSH
68255: LD_INT 3
68257: NEG
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 1
68265: PUSH
68266: LD_INT 2
68268: NEG
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
68292: LD_ADDR_VAR 0 15
68296: PUSH
68297: LD_INT 0
68299: PUSH
68300: LD_INT 0
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 0
68309: PUSH
68310: LD_INT 1
68312: NEG
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 1
68320: PUSH
68321: LD_INT 0
68323: PUSH
68324: EMPTY
68325: LIST
68326: LIST
68327: PUSH
68328: LD_INT 1
68330: PUSH
68331: LD_INT 1
68333: PUSH
68334: EMPTY
68335: LIST
68336: LIST
68337: PUSH
68338: LD_INT 0
68340: PUSH
68341: LD_INT 1
68343: PUSH
68344: EMPTY
68345: LIST
68346: LIST
68347: PUSH
68348: LD_INT 1
68350: NEG
68351: PUSH
68352: LD_INT 0
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PUSH
68359: LD_INT 1
68361: NEG
68362: PUSH
68363: LD_INT 1
68365: NEG
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: LD_INT 1
68376: NEG
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: LD_INT 2
68384: PUSH
68385: LD_INT 0
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PUSH
68392: LD_INT 2
68394: PUSH
68395: LD_INT 1
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: LD_INT 1
68404: NEG
68405: PUSH
68406: LD_INT 1
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 2
68415: NEG
68416: PUSH
68417: LD_INT 0
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: LD_INT 2
68426: NEG
68427: PUSH
68428: LD_INT 1
68430: NEG
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PUSH
68436: LD_INT 2
68438: PUSH
68439: LD_INT 1
68441: NEG
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: PUSH
68447: LD_INT 3
68449: PUSH
68450: LD_INT 0
68452: PUSH
68453: EMPTY
68454: LIST
68455: LIST
68456: PUSH
68457: LD_INT 3
68459: PUSH
68460: LD_INT 1
68462: PUSH
68463: EMPTY
68464: LIST
68465: LIST
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: LIST
68471: LIST
68472: LIST
68473: LIST
68474: LIST
68475: LIST
68476: LIST
68477: LIST
68478: LIST
68479: LIST
68480: LIST
68481: LIST
68482: LIST
68483: LIST
68484: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
68485: LD_ADDR_VAR 0 16
68489: PUSH
68490: LD_INT 0
68492: PUSH
68493: LD_INT 0
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: PUSH
68500: LD_INT 0
68502: PUSH
68503: LD_INT 1
68505: NEG
68506: PUSH
68507: EMPTY
68508: LIST
68509: LIST
68510: PUSH
68511: LD_INT 1
68513: PUSH
68514: LD_INT 0
68516: PUSH
68517: EMPTY
68518: LIST
68519: LIST
68520: PUSH
68521: LD_INT 1
68523: PUSH
68524: LD_INT 1
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 0
68533: PUSH
68534: LD_INT 1
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 1
68543: NEG
68544: PUSH
68545: LD_INT 0
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 1
68554: NEG
68555: PUSH
68556: LD_INT 1
68558: NEG
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 1
68566: NEG
68567: PUSH
68568: LD_INT 2
68570: NEG
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 2
68578: PUSH
68579: LD_INT 1
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 2
68588: PUSH
68589: LD_INT 2
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PUSH
68596: LD_INT 1
68598: PUSH
68599: LD_INT 2
68601: PUSH
68602: EMPTY
68603: LIST
68604: LIST
68605: PUSH
68606: LD_INT 2
68608: NEG
68609: PUSH
68610: LD_INT 1
68612: NEG
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: PUSH
68618: LD_INT 2
68620: NEG
68621: PUSH
68622: LD_INT 2
68624: NEG
68625: PUSH
68626: EMPTY
68627: LIST
68628: LIST
68629: PUSH
68630: LD_INT 3
68632: PUSH
68633: LD_INT 2
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 3
68642: PUSH
68643: LD_INT 3
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: PUSH
68650: LD_INT 2
68652: PUSH
68653: LD_INT 3
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: LIST
68664: LIST
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: LIST
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68678: LD_ADDR_VAR 0 17
68682: PUSH
68683: LD_INT 0
68685: PUSH
68686: LD_INT 0
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: PUSH
68693: LD_INT 0
68695: PUSH
68696: LD_INT 1
68698: NEG
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 1
68706: PUSH
68707: LD_INT 0
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: PUSH
68714: LD_INT 1
68716: PUSH
68717: LD_INT 1
68719: PUSH
68720: EMPTY
68721: LIST
68722: LIST
68723: PUSH
68724: LD_INT 0
68726: PUSH
68727: LD_INT 1
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 1
68736: NEG
68737: PUSH
68738: LD_INT 0
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 1
68747: NEG
68748: PUSH
68749: LD_INT 1
68751: NEG
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: PUSH
68757: LD_INT 1
68759: NEG
68760: PUSH
68761: LD_INT 2
68763: NEG
68764: PUSH
68765: EMPTY
68766: LIST
68767: LIST
68768: PUSH
68769: LD_INT 0
68771: PUSH
68772: LD_INT 2
68774: NEG
68775: PUSH
68776: EMPTY
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 1
68782: PUSH
68783: LD_INT 1
68785: NEG
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: PUSH
68791: LD_INT 2
68793: PUSH
68794: LD_INT 0
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PUSH
68801: LD_INT 2
68803: PUSH
68804: LD_INT 1
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PUSH
68811: LD_INT 2
68813: PUSH
68814: LD_INT 2
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 1
68823: PUSH
68824: LD_INT 2
68826: PUSH
68827: EMPTY
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 0
68833: PUSH
68834: LD_INT 2
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 1
68843: NEG
68844: PUSH
68845: LD_INT 1
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 2
68854: NEG
68855: PUSH
68856: LD_INT 0
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: LD_INT 1
68869: NEG
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: PUSH
68875: LD_INT 2
68877: NEG
68878: PUSH
68879: LD_INT 2
68881: NEG
68882: PUSH
68883: EMPTY
68884: LIST
68885: LIST
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: LIST
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: LIST
68899: LIST
68900: LIST
68901: LIST
68902: LIST
68903: LIST
68904: LIST
68905: LIST
68906: LIST
68907: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68908: LD_ADDR_VAR 0 18
68912: PUSH
68913: LD_INT 0
68915: PUSH
68916: LD_INT 0
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: PUSH
68923: LD_INT 0
68925: PUSH
68926: LD_INT 1
68928: NEG
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 1
68936: PUSH
68937: LD_INT 0
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 1
68946: PUSH
68947: LD_INT 1
68949: PUSH
68950: EMPTY
68951: LIST
68952: LIST
68953: PUSH
68954: LD_INT 0
68956: PUSH
68957: LD_INT 1
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PUSH
68964: LD_INT 1
68966: NEG
68967: PUSH
68968: LD_INT 0
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 1
68977: NEG
68978: PUSH
68979: LD_INT 1
68981: NEG
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 1
68989: NEG
68990: PUSH
68991: LD_INT 2
68993: NEG
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: PUSH
68999: LD_INT 0
69001: PUSH
69002: LD_INT 2
69004: NEG
69005: PUSH
69006: EMPTY
69007: LIST
69008: LIST
69009: PUSH
69010: LD_INT 1
69012: PUSH
69013: LD_INT 1
69015: NEG
69016: PUSH
69017: EMPTY
69018: LIST
69019: LIST
69020: PUSH
69021: LD_INT 2
69023: PUSH
69024: LD_INT 0
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: PUSH
69031: LD_INT 2
69033: PUSH
69034: LD_INT 1
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 2
69043: PUSH
69044: LD_INT 2
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 1
69053: PUSH
69054: LD_INT 2
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 0
69063: PUSH
69064: LD_INT 2
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 1
69073: NEG
69074: PUSH
69075: LD_INT 1
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: LD_INT 2
69084: NEG
69085: PUSH
69086: LD_INT 0
69088: PUSH
69089: EMPTY
69090: LIST
69091: LIST
69092: PUSH
69093: LD_INT 2
69095: NEG
69096: PUSH
69097: LD_INT 1
69099: NEG
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: PUSH
69105: LD_INT 2
69107: NEG
69108: PUSH
69109: LD_INT 2
69111: NEG
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: EMPTY
69118: LIST
69119: LIST
69120: LIST
69121: LIST
69122: LIST
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69138: LD_ADDR_VAR 0 19
69142: PUSH
69143: LD_INT 0
69145: PUSH
69146: LD_INT 0
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 0
69155: PUSH
69156: LD_INT 1
69158: NEG
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: LD_INT 1
69166: PUSH
69167: LD_INT 0
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: LD_INT 1
69176: PUSH
69177: LD_INT 1
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: LD_INT 0
69186: PUSH
69187: LD_INT 1
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 1
69196: NEG
69197: PUSH
69198: LD_INT 0
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 1
69207: NEG
69208: PUSH
69209: LD_INT 1
69211: NEG
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: LD_INT 1
69219: NEG
69220: PUSH
69221: LD_INT 2
69223: NEG
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 0
69231: PUSH
69232: LD_INT 2
69234: NEG
69235: PUSH
69236: EMPTY
69237: LIST
69238: LIST
69239: PUSH
69240: LD_INT 1
69242: PUSH
69243: LD_INT 1
69245: NEG
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: LD_INT 2
69253: PUSH
69254: LD_INT 0
69256: PUSH
69257: EMPTY
69258: LIST
69259: LIST
69260: PUSH
69261: LD_INT 2
69263: PUSH
69264: LD_INT 1
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 2
69273: PUSH
69274: LD_INT 2
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 1
69283: PUSH
69284: LD_INT 2
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 0
69293: PUSH
69294: LD_INT 2
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: PUSH
69301: LD_INT 1
69303: NEG
69304: PUSH
69305: LD_INT 1
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PUSH
69312: LD_INT 2
69314: NEG
69315: PUSH
69316: LD_INT 0
69318: PUSH
69319: EMPTY
69320: LIST
69321: LIST
69322: PUSH
69323: LD_INT 2
69325: NEG
69326: PUSH
69327: LD_INT 1
69329: NEG
69330: PUSH
69331: EMPTY
69332: LIST
69333: LIST
69334: PUSH
69335: LD_INT 2
69337: NEG
69338: PUSH
69339: LD_INT 2
69341: NEG
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: LIST
69367: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69368: LD_ADDR_VAR 0 20
69372: PUSH
69373: LD_INT 0
69375: PUSH
69376: LD_INT 0
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 0
69385: PUSH
69386: LD_INT 1
69388: NEG
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 1
69396: PUSH
69397: LD_INT 0
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 1
69406: PUSH
69407: LD_INT 1
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 0
69416: PUSH
69417: LD_INT 1
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: LD_INT 1
69426: NEG
69427: PUSH
69428: LD_INT 0
69430: PUSH
69431: EMPTY
69432: LIST
69433: LIST
69434: PUSH
69435: LD_INT 1
69437: NEG
69438: PUSH
69439: LD_INT 1
69441: NEG
69442: PUSH
69443: EMPTY
69444: LIST
69445: LIST
69446: PUSH
69447: LD_INT 1
69449: NEG
69450: PUSH
69451: LD_INT 2
69453: NEG
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 0
69461: PUSH
69462: LD_INT 2
69464: NEG
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 1
69472: PUSH
69473: LD_INT 1
69475: NEG
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: PUSH
69481: LD_INT 2
69483: PUSH
69484: LD_INT 0
69486: PUSH
69487: EMPTY
69488: LIST
69489: LIST
69490: PUSH
69491: LD_INT 2
69493: PUSH
69494: LD_INT 1
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 2
69503: PUSH
69504: LD_INT 2
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PUSH
69511: LD_INT 1
69513: PUSH
69514: LD_INT 2
69516: PUSH
69517: EMPTY
69518: LIST
69519: LIST
69520: PUSH
69521: LD_INT 0
69523: PUSH
69524: LD_INT 2
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 1
69533: NEG
69534: PUSH
69535: LD_INT 1
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 2
69544: NEG
69545: PUSH
69546: LD_INT 0
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 2
69555: NEG
69556: PUSH
69557: LD_INT 1
69559: NEG
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 2
69567: NEG
69568: PUSH
69569: LD_INT 2
69571: NEG
69572: PUSH
69573: EMPTY
69574: LIST
69575: LIST
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69598: LD_ADDR_VAR 0 21
69602: PUSH
69603: LD_INT 0
69605: PUSH
69606: LD_INT 0
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 0
69615: PUSH
69616: LD_INT 1
69618: NEG
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 1
69626: PUSH
69627: LD_INT 0
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: PUSH
69634: LD_INT 1
69636: PUSH
69637: LD_INT 1
69639: PUSH
69640: EMPTY
69641: LIST
69642: LIST
69643: PUSH
69644: LD_INT 0
69646: PUSH
69647: LD_INT 1
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 1
69656: NEG
69657: PUSH
69658: LD_INT 0
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 1
69667: NEG
69668: PUSH
69669: LD_INT 1
69671: NEG
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 1
69679: NEG
69680: PUSH
69681: LD_INT 2
69683: NEG
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: LD_INT 0
69691: PUSH
69692: LD_INT 2
69694: NEG
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: PUSH
69700: LD_INT 1
69702: PUSH
69703: LD_INT 1
69705: NEG
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 2
69713: PUSH
69714: LD_INT 0
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: PUSH
69721: LD_INT 2
69723: PUSH
69724: LD_INT 1
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 2
69733: PUSH
69734: LD_INT 2
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 1
69743: PUSH
69744: LD_INT 2
69746: PUSH
69747: EMPTY
69748: LIST
69749: LIST
69750: PUSH
69751: LD_INT 0
69753: PUSH
69754: LD_INT 2
69756: PUSH
69757: EMPTY
69758: LIST
69759: LIST
69760: PUSH
69761: LD_INT 1
69763: NEG
69764: PUSH
69765: LD_INT 1
69767: PUSH
69768: EMPTY
69769: LIST
69770: LIST
69771: PUSH
69772: LD_INT 2
69774: NEG
69775: PUSH
69776: LD_INT 0
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: PUSH
69783: LD_INT 2
69785: NEG
69786: PUSH
69787: LD_INT 1
69789: NEG
69790: PUSH
69791: EMPTY
69792: LIST
69793: LIST
69794: PUSH
69795: LD_INT 2
69797: NEG
69798: PUSH
69799: LD_INT 2
69801: NEG
69802: PUSH
69803: EMPTY
69804: LIST
69805: LIST
69806: PUSH
69807: EMPTY
69808: LIST
69809: LIST
69810: LIST
69811: LIST
69812: LIST
69813: LIST
69814: LIST
69815: LIST
69816: LIST
69817: LIST
69818: LIST
69819: LIST
69820: LIST
69821: LIST
69822: LIST
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69828: LD_ADDR_VAR 0 22
69832: PUSH
69833: LD_INT 0
69835: PUSH
69836: LD_INT 0
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 0
69845: PUSH
69846: LD_INT 1
69848: NEG
69849: PUSH
69850: EMPTY
69851: LIST
69852: LIST
69853: PUSH
69854: LD_INT 1
69856: PUSH
69857: LD_INT 0
69859: PUSH
69860: EMPTY
69861: LIST
69862: LIST
69863: PUSH
69864: LD_INT 1
69866: PUSH
69867: LD_INT 1
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: PUSH
69874: LD_INT 0
69876: PUSH
69877: LD_INT 1
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 1
69886: NEG
69887: PUSH
69888: LD_INT 0
69890: PUSH
69891: EMPTY
69892: LIST
69893: LIST
69894: PUSH
69895: LD_INT 1
69897: NEG
69898: PUSH
69899: LD_INT 1
69901: NEG
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 1
69909: NEG
69910: PUSH
69911: LD_INT 2
69913: NEG
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 0
69921: PUSH
69922: LD_INT 2
69924: NEG
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: PUSH
69930: LD_INT 1
69932: PUSH
69933: LD_INT 1
69935: NEG
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 2
69943: PUSH
69944: LD_INT 0
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: PUSH
69951: LD_INT 2
69953: PUSH
69954: LD_INT 1
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: PUSH
69961: LD_INT 2
69963: PUSH
69964: LD_INT 2
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: LD_INT 2
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 0
69983: PUSH
69984: LD_INT 2
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: LD_INT 1
69993: NEG
69994: PUSH
69995: LD_INT 1
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: LD_INT 2
70004: NEG
70005: PUSH
70006: LD_INT 0
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: PUSH
70013: LD_INT 2
70015: NEG
70016: PUSH
70017: LD_INT 1
70019: NEG
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PUSH
70025: LD_INT 2
70027: NEG
70028: PUSH
70029: LD_INT 2
70031: NEG
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: LIST
70053: LIST
70054: LIST
70055: LIST
70056: LIST
70057: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
70058: LD_ADDR_VAR 0 23
70062: PUSH
70063: LD_INT 0
70065: PUSH
70066: LD_INT 0
70068: PUSH
70069: EMPTY
70070: LIST
70071: LIST
70072: PUSH
70073: LD_INT 0
70075: PUSH
70076: LD_INT 1
70078: NEG
70079: PUSH
70080: EMPTY
70081: LIST
70082: LIST
70083: PUSH
70084: LD_INT 1
70086: PUSH
70087: LD_INT 0
70089: PUSH
70090: EMPTY
70091: LIST
70092: LIST
70093: PUSH
70094: LD_INT 1
70096: PUSH
70097: LD_INT 1
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 0
70106: PUSH
70107: LD_INT 1
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 1
70116: NEG
70117: PUSH
70118: LD_INT 0
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 1
70127: NEG
70128: PUSH
70129: LD_INT 1
70131: NEG
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 1
70139: NEG
70140: PUSH
70141: LD_INT 2
70143: NEG
70144: PUSH
70145: EMPTY
70146: LIST
70147: LIST
70148: PUSH
70149: LD_INT 0
70151: PUSH
70152: LD_INT 2
70154: NEG
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: LD_INT 1
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 2
70173: PUSH
70174: LD_INT 0
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 2
70183: PUSH
70184: LD_INT 1
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 2
70193: PUSH
70194: LD_INT 2
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 1
70203: PUSH
70204: LD_INT 2
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 0
70213: PUSH
70214: LD_INT 2
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 1
70223: NEG
70224: PUSH
70225: LD_INT 1
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 2
70234: NEG
70235: PUSH
70236: LD_INT 0
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 2
70245: NEG
70246: PUSH
70247: LD_INT 1
70249: NEG
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 2
70257: NEG
70258: PUSH
70259: LD_INT 2
70261: NEG
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: LD_INT 2
70269: NEG
70270: PUSH
70271: LD_INT 3
70273: NEG
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 1
70281: NEG
70282: PUSH
70283: LD_INT 3
70285: NEG
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: LD_INT 1
70293: PUSH
70294: LD_INT 2
70296: NEG
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: LD_INT 2
70304: PUSH
70305: LD_INT 1
70307: NEG
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
70338: LD_ADDR_VAR 0 24
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: LD_INT 0
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PUSH
70353: LD_INT 0
70355: PUSH
70356: LD_INT 1
70358: NEG
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 1
70366: PUSH
70367: LD_INT 0
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 1
70376: PUSH
70377: LD_INT 1
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PUSH
70384: LD_INT 0
70386: PUSH
70387: LD_INT 1
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 1
70396: NEG
70397: PUSH
70398: LD_INT 0
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 1
70407: NEG
70408: PUSH
70409: LD_INT 1
70411: NEG
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 1
70419: NEG
70420: PUSH
70421: LD_INT 2
70423: NEG
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 0
70431: PUSH
70432: LD_INT 2
70434: NEG
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 1
70442: PUSH
70443: LD_INT 1
70445: NEG
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 2
70453: PUSH
70454: LD_INT 0
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: PUSH
70461: LD_INT 2
70463: PUSH
70464: LD_INT 1
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: PUSH
70471: LD_INT 2
70473: PUSH
70474: LD_INT 2
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PUSH
70481: LD_INT 1
70483: PUSH
70484: LD_INT 2
70486: PUSH
70487: EMPTY
70488: LIST
70489: LIST
70490: PUSH
70491: LD_INT 0
70493: PUSH
70494: LD_INT 2
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 1
70503: NEG
70504: PUSH
70505: LD_INT 1
70507: PUSH
70508: EMPTY
70509: LIST
70510: LIST
70511: PUSH
70512: LD_INT 2
70514: NEG
70515: PUSH
70516: LD_INT 0
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 2
70525: NEG
70526: PUSH
70527: LD_INT 1
70529: NEG
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 2
70537: NEG
70538: PUSH
70539: LD_INT 2
70541: NEG
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: PUSH
70547: LD_INT 1
70549: PUSH
70550: LD_INT 2
70552: NEG
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 2
70560: PUSH
70561: LD_INT 1
70563: NEG
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 3
70571: PUSH
70572: LD_INT 1
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 3
70581: PUSH
70582: LD_INT 2
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: LIST
70593: LIST
70594: LIST
70595: LIST
70596: LIST
70597: LIST
70598: LIST
70599: LIST
70600: LIST
70601: LIST
70602: LIST
70603: LIST
70604: LIST
70605: LIST
70606: LIST
70607: LIST
70608: LIST
70609: LIST
70610: LIST
70611: LIST
70612: LIST
70613: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
70614: LD_ADDR_VAR 0 25
70618: PUSH
70619: LD_INT 0
70621: PUSH
70622: LD_INT 0
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 0
70631: PUSH
70632: LD_INT 1
70634: NEG
70635: PUSH
70636: EMPTY
70637: LIST
70638: LIST
70639: PUSH
70640: LD_INT 1
70642: PUSH
70643: LD_INT 0
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: PUSH
70650: LD_INT 1
70652: PUSH
70653: LD_INT 1
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 0
70662: PUSH
70663: LD_INT 1
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: LD_INT 0
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 1
70683: NEG
70684: PUSH
70685: LD_INT 1
70687: NEG
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: PUSH
70693: LD_INT 1
70695: NEG
70696: PUSH
70697: LD_INT 2
70699: NEG
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: LD_INT 0
70707: PUSH
70708: LD_INT 2
70710: NEG
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: LD_INT 1
70718: PUSH
70719: LD_INT 1
70721: NEG
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: PUSH
70727: LD_INT 2
70729: PUSH
70730: LD_INT 0
70732: PUSH
70733: EMPTY
70734: LIST
70735: LIST
70736: PUSH
70737: LD_INT 2
70739: PUSH
70740: LD_INT 1
70742: PUSH
70743: EMPTY
70744: LIST
70745: LIST
70746: PUSH
70747: LD_INT 2
70749: PUSH
70750: LD_INT 2
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: PUSH
70757: LD_INT 1
70759: PUSH
70760: LD_INT 2
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PUSH
70767: LD_INT 0
70769: PUSH
70770: LD_INT 2
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: LD_INT 1
70779: NEG
70780: PUSH
70781: LD_INT 1
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 2
70790: NEG
70791: PUSH
70792: LD_INT 0
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: PUSH
70799: LD_INT 2
70801: NEG
70802: PUSH
70803: LD_INT 1
70805: NEG
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 2
70813: NEG
70814: PUSH
70815: LD_INT 2
70817: NEG
70818: PUSH
70819: EMPTY
70820: LIST
70821: LIST
70822: PUSH
70823: LD_INT 3
70825: PUSH
70826: LD_INT 1
70828: PUSH
70829: EMPTY
70830: LIST
70831: LIST
70832: PUSH
70833: LD_INT 3
70835: PUSH
70836: LD_INT 2
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 2
70845: PUSH
70846: LD_INT 3
70848: PUSH
70849: EMPTY
70850: LIST
70851: LIST
70852: PUSH
70853: LD_INT 1
70855: PUSH
70856: LD_INT 3
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: LIST
70867: LIST
70868: LIST
70869: LIST
70870: LIST
70871: LIST
70872: LIST
70873: LIST
70874: LIST
70875: LIST
70876: LIST
70877: LIST
70878: LIST
70879: LIST
70880: LIST
70881: LIST
70882: LIST
70883: LIST
70884: LIST
70885: LIST
70886: LIST
70887: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
70888: LD_ADDR_VAR 0 26
70892: PUSH
70893: LD_INT 0
70895: PUSH
70896: LD_INT 0
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: PUSH
70903: LD_INT 0
70905: PUSH
70906: LD_INT 1
70908: NEG
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 1
70916: PUSH
70917: LD_INT 0
70919: PUSH
70920: EMPTY
70921: LIST
70922: LIST
70923: PUSH
70924: LD_INT 1
70926: PUSH
70927: LD_INT 1
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: LD_INT 0
70936: PUSH
70937: LD_INT 1
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: LD_INT 1
70946: NEG
70947: PUSH
70948: LD_INT 0
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 1
70957: NEG
70958: PUSH
70959: LD_INT 1
70961: NEG
70962: PUSH
70963: EMPTY
70964: LIST
70965: LIST
70966: PUSH
70967: LD_INT 1
70969: NEG
70970: PUSH
70971: LD_INT 2
70973: NEG
70974: PUSH
70975: EMPTY
70976: LIST
70977: LIST
70978: PUSH
70979: LD_INT 0
70981: PUSH
70982: LD_INT 2
70984: NEG
70985: PUSH
70986: EMPTY
70987: LIST
70988: LIST
70989: PUSH
70990: LD_INT 1
70992: PUSH
70993: LD_INT 1
70995: NEG
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 2
71003: PUSH
71004: LD_INT 0
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: LD_INT 2
71013: PUSH
71014: LD_INT 1
71016: PUSH
71017: EMPTY
71018: LIST
71019: LIST
71020: PUSH
71021: LD_INT 2
71023: PUSH
71024: LD_INT 2
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: PUSH
71031: LD_INT 1
71033: PUSH
71034: LD_INT 2
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: LD_INT 0
71043: PUSH
71044: LD_INT 2
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 1
71053: NEG
71054: PUSH
71055: LD_INT 1
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 2
71064: NEG
71065: PUSH
71066: LD_INT 0
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 2
71075: NEG
71076: PUSH
71077: LD_INT 1
71079: NEG
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 2
71087: NEG
71088: PUSH
71089: LD_INT 2
71091: NEG
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: PUSH
71097: LD_INT 2
71099: PUSH
71100: LD_INT 3
71102: PUSH
71103: EMPTY
71104: LIST
71105: LIST
71106: PUSH
71107: LD_INT 1
71109: PUSH
71110: LD_INT 3
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: PUSH
71117: LD_INT 1
71119: NEG
71120: PUSH
71121: LD_INT 2
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: LD_INT 2
71130: NEG
71131: PUSH
71132: LD_INT 1
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: LIST
71161: LIST
71162: LIST
71163: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71164: LD_ADDR_VAR 0 27
71168: PUSH
71169: LD_INT 0
71171: PUSH
71172: LD_INT 0
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 0
71181: PUSH
71182: LD_INT 1
71184: NEG
71185: PUSH
71186: EMPTY
71187: LIST
71188: LIST
71189: PUSH
71190: LD_INT 1
71192: PUSH
71193: LD_INT 0
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 1
71202: PUSH
71203: LD_INT 1
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 0
71212: PUSH
71213: LD_INT 1
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 1
71222: NEG
71223: PUSH
71224: LD_INT 0
71226: PUSH
71227: EMPTY
71228: LIST
71229: LIST
71230: PUSH
71231: LD_INT 1
71233: NEG
71234: PUSH
71235: LD_INT 1
71237: NEG
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PUSH
71243: LD_INT 1
71245: NEG
71246: PUSH
71247: LD_INT 2
71249: NEG
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 0
71257: PUSH
71258: LD_INT 2
71260: NEG
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PUSH
71266: LD_INT 1
71268: PUSH
71269: LD_INT 1
71271: NEG
71272: PUSH
71273: EMPTY
71274: LIST
71275: LIST
71276: PUSH
71277: LD_INT 2
71279: PUSH
71280: LD_INT 0
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PUSH
71287: LD_INT 2
71289: PUSH
71290: LD_INT 1
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 2
71299: PUSH
71300: LD_INT 2
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 1
71309: PUSH
71310: LD_INT 2
71312: PUSH
71313: EMPTY
71314: LIST
71315: LIST
71316: PUSH
71317: LD_INT 0
71319: PUSH
71320: LD_INT 2
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: PUSH
71327: LD_INT 1
71329: NEG
71330: PUSH
71331: LD_INT 1
71333: PUSH
71334: EMPTY
71335: LIST
71336: LIST
71337: PUSH
71338: LD_INT 2
71340: NEG
71341: PUSH
71342: LD_INT 0
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: LD_INT 2
71351: NEG
71352: PUSH
71353: LD_INT 1
71355: NEG
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: PUSH
71361: LD_INT 2
71363: NEG
71364: PUSH
71365: LD_INT 2
71367: NEG
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 1
71375: NEG
71376: PUSH
71377: LD_INT 2
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 2
71386: NEG
71387: PUSH
71388: LD_INT 1
71390: PUSH
71391: EMPTY
71392: LIST
71393: LIST
71394: PUSH
71395: LD_INT 3
71397: NEG
71398: PUSH
71399: LD_INT 1
71401: NEG
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 3
71409: NEG
71410: PUSH
71411: LD_INT 2
71413: NEG
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: LIST
71428: LIST
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71444: LD_ADDR_VAR 0 28
71448: PUSH
71449: LD_INT 0
71451: PUSH
71452: LD_INT 0
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: LD_INT 0
71461: PUSH
71462: LD_INT 1
71464: NEG
71465: PUSH
71466: EMPTY
71467: LIST
71468: LIST
71469: PUSH
71470: LD_INT 1
71472: PUSH
71473: LD_INT 0
71475: PUSH
71476: EMPTY
71477: LIST
71478: LIST
71479: PUSH
71480: LD_INT 1
71482: PUSH
71483: LD_INT 1
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: PUSH
71490: LD_INT 0
71492: PUSH
71493: LD_INT 1
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 1
71502: NEG
71503: PUSH
71504: LD_INT 0
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 1
71513: NEG
71514: PUSH
71515: LD_INT 1
71517: NEG
71518: PUSH
71519: EMPTY
71520: LIST
71521: LIST
71522: PUSH
71523: LD_INT 1
71525: NEG
71526: PUSH
71527: LD_INT 2
71529: NEG
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 0
71537: PUSH
71538: LD_INT 2
71540: NEG
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: LD_INT 1
71548: PUSH
71549: LD_INT 1
71551: NEG
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 2
71559: PUSH
71560: LD_INT 0
71562: PUSH
71563: EMPTY
71564: LIST
71565: LIST
71566: PUSH
71567: LD_INT 2
71569: PUSH
71570: LD_INT 1
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 2
71579: PUSH
71580: LD_INT 2
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 1
71589: PUSH
71590: LD_INT 2
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: LD_INT 0
71599: PUSH
71600: LD_INT 2
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 1
71609: NEG
71610: PUSH
71611: LD_INT 1
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 2
71620: NEG
71621: PUSH
71622: LD_INT 0
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: LD_INT 2
71631: NEG
71632: PUSH
71633: LD_INT 1
71635: NEG
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 2
71643: NEG
71644: PUSH
71645: LD_INT 2
71647: NEG
71648: PUSH
71649: EMPTY
71650: LIST
71651: LIST
71652: PUSH
71653: LD_INT 2
71655: NEG
71656: PUSH
71657: LD_INT 3
71659: NEG
71660: PUSH
71661: EMPTY
71662: LIST
71663: LIST
71664: PUSH
71665: LD_INT 1
71667: NEG
71668: PUSH
71669: LD_INT 3
71671: NEG
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 3
71679: NEG
71680: PUSH
71681: LD_INT 1
71683: NEG
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 3
71691: NEG
71692: PUSH
71693: LD_INT 2
71695: NEG
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71726: LD_ADDR_VAR 0 29
71730: PUSH
71731: LD_INT 0
71733: PUSH
71734: LD_INT 0
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 0
71743: PUSH
71744: LD_INT 1
71746: NEG
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: LD_INT 1
71754: PUSH
71755: LD_INT 0
71757: PUSH
71758: EMPTY
71759: LIST
71760: LIST
71761: PUSH
71762: LD_INT 1
71764: PUSH
71765: LD_INT 1
71767: PUSH
71768: EMPTY
71769: LIST
71770: LIST
71771: PUSH
71772: LD_INT 0
71774: PUSH
71775: LD_INT 1
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 1
71784: NEG
71785: PUSH
71786: LD_INT 0
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: LD_INT 1
71795: NEG
71796: PUSH
71797: LD_INT 1
71799: NEG
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 1
71807: NEG
71808: PUSH
71809: LD_INT 2
71811: NEG
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: PUSH
71817: LD_INT 0
71819: PUSH
71820: LD_INT 2
71822: NEG
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: LD_INT 1
71830: PUSH
71831: LD_INT 1
71833: NEG
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: PUSH
71839: LD_INT 2
71841: PUSH
71842: LD_INT 0
71844: PUSH
71845: EMPTY
71846: LIST
71847: LIST
71848: PUSH
71849: LD_INT 2
71851: PUSH
71852: LD_INT 1
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 1
71861: PUSH
71862: LD_INT 2
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 0
71871: PUSH
71872: LD_INT 2
71874: PUSH
71875: EMPTY
71876: LIST
71877: LIST
71878: PUSH
71879: LD_INT 1
71881: NEG
71882: PUSH
71883: LD_INT 1
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PUSH
71890: LD_INT 2
71892: NEG
71893: PUSH
71894: LD_INT 1
71896: NEG
71897: PUSH
71898: EMPTY
71899: LIST
71900: LIST
71901: PUSH
71902: LD_INT 2
71904: NEG
71905: PUSH
71906: LD_INT 2
71908: NEG
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 2
71916: NEG
71917: PUSH
71918: LD_INT 3
71920: NEG
71921: PUSH
71922: EMPTY
71923: LIST
71924: LIST
71925: PUSH
71926: LD_INT 2
71928: PUSH
71929: LD_INT 1
71931: NEG
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: PUSH
71937: LD_INT 3
71939: PUSH
71940: LD_INT 1
71942: PUSH
71943: EMPTY
71944: LIST
71945: LIST
71946: PUSH
71947: LD_INT 1
71949: PUSH
71950: LD_INT 3
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: LD_INT 1
71959: NEG
71960: PUSH
71961: LD_INT 2
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: LD_INT 3
71970: NEG
71971: PUSH
71972: LD_INT 2
71974: NEG
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: LIST
71989: LIST
71990: LIST
71991: LIST
71992: LIST
71993: LIST
71994: LIST
71995: LIST
71996: LIST
71997: LIST
71998: LIST
71999: LIST
72000: LIST
72001: LIST
72002: LIST
72003: LIST
72004: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72005: LD_ADDR_VAR 0 30
72009: PUSH
72010: LD_INT 0
72012: PUSH
72013: LD_INT 0
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 0
72022: PUSH
72023: LD_INT 1
72025: NEG
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: PUSH
72031: LD_INT 1
72033: PUSH
72034: LD_INT 0
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 1
72043: PUSH
72044: LD_INT 1
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 0
72053: PUSH
72054: LD_INT 1
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 1
72063: NEG
72064: PUSH
72065: LD_INT 0
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: LD_INT 1
72074: NEG
72075: PUSH
72076: LD_INT 1
72078: NEG
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: LD_INT 1
72086: NEG
72087: PUSH
72088: LD_INT 2
72090: NEG
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 0
72098: PUSH
72099: LD_INT 2
72101: NEG
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 1
72109: PUSH
72110: LD_INT 1
72112: NEG
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: LD_INT 2
72120: PUSH
72121: LD_INT 0
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 2
72130: PUSH
72131: LD_INT 1
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 2
72140: PUSH
72141: LD_INT 2
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 1
72150: PUSH
72151: LD_INT 2
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: NEG
72161: PUSH
72162: LD_INT 1
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 2
72171: NEG
72172: PUSH
72173: LD_INT 0
72175: PUSH
72176: EMPTY
72177: LIST
72178: LIST
72179: PUSH
72180: LD_INT 2
72182: NEG
72183: PUSH
72184: LD_INT 1
72186: NEG
72187: PUSH
72188: EMPTY
72189: LIST
72190: LIST
72191: PUSH
72192: LD_INT 1
72194: NEG
72195: PUSH
72196: LD_INT 3
72198: NEG
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 1
72206: PUSH
72207: LD_INT 2
72209: NEG
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 3
72217: PUSH
72218: LD_INT 2
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 2
72227: PUSH
72228: LD_INT 3
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 2
72237: NEG
72238: PUSH
72239: LD_INT 1
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 3
72248: NEG
72249: PUSH
72250: LD_INT 1
72252: NEG
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: LIST
72262: LIST
72263: LIST
72264: LIST
72265: LIST
72266: LIST
72267: LIST
72268: LIST
72269: LIST
72270: LIST
72271: LIST
72272: LIST
72273: LIST
72274: LIST
72275: LIST
72276: LIST
72277: LIST
72278: LIST
72279: LIST
72280: LIST
72281: LIST
72282: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72283: LD_ADDR_VAR 0 31
72287: PUSH
72288: LD_INT 0
72290: PUSH
72291: LD_INT 0
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 0
72300: PUSH
72301: LD_INT 1
72303: NEG
72304: PUSH
72305: EMPTY
72306: LIST
72307: LIST
72308: PUSH
72309: LD_INT 1
72311: PUSH
72312: LD_INT 0
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PUSH
72319: LD_INT 1
72321: PUSH
72322: LD_INT 1
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: PUSH
72329: LD_INT 0
72331: PUSH
72332: LD_INT 1
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 1
72341: NEG
72342: PUSH
72343: LD_INT 0
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 1
72352: NEG
72353: PUSH
72354: LD_INT 1
72356: NEG
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: LD_INT 1
72364: NEG
72365: PUSH
72366: LD_INT 2
72368: NEG
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: PUSH
72374: LD_INT 1
72376: PUSH
72377: LD_INT 1
72379: NEG
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 2
72387: PUSH
72388: LD_INT 0
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 2
72397: PUSH
72398: LD_INT 1
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 2
72407: PUSH
72408: LD_INT 2
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PUSH
72415: LD_INT 1
72417: PUSH
72418: LD_INT 2
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PUSH
72425: LD_INT 0
72427: PUSH
72428: LD_INT 2
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 1
72437: NEG
72438: PUSH
72439: LD_INT 1
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 2
72448: NEG
72449: PUSH
72450: LD_INT 1
72452: NEG
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: PUSH
72458: LD_INT 2
72460: NEG
72461: PUSH
72462: LD_INT 2
72464: NEG
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 2
72472: NEG
72473: PUSH
72474: LD_INT 3
72476: NEG
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 2
72484: PUSH
72485: LD_INT 1
72487: NEG
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: LD_INT 3
72495: PUSH
72496: LD_INT 1
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 1
72505: PUSH
72506: LD_INT 3
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 1
72515: NEG
72516: PUSH
72517: LD_INT 2
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PUSH
72524: LD_INT 3
72526: NEG
72527: PUSH
72528: LD_INT 2
72530: NEG
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: EMPTY
72537: LIST
72538: LIST
72539: LIST
72540: LIST
72541: LIST
72542: LIST
72543: LIST
72544: LIST
72545: LIST
72546: LIST
72547: LIST
72548: LIST
72549: LIST
72550: LIST
72551: LIST
72552: LIST
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: LIST
72558: LIST
72559: LIST
72560: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72561: LD_ADDR_VAR 0 32
72565: PUSH
72566: LD_INT 0
72568: PUSH
72569: LD_INT 0
72571: PUSH
72572: EMPTY
72573: LIST
72574: LIST
72575: PUSH
72576: LD_INT 0
72578: PUSH
72579: LD_INT 1
72581: NEG
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: PUSH
72587: LD_INT 1
72589: PUSH
72590: LD_INT 0
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: PUSH
72597: LD_INT 1
72599: PUSH
72600: LD_INT 1
72602: PUSH
72603: EMPTY
72604: LIST
72605: LIST
72606: PUSH
72607: LD_INT 0
72609: PUSH
72610: LD_INT 1
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PUSH
72617: LD_INT 1
72619: NEG
72620: PUSH
72621: LD_INT 0
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: LD_INT 1
72630: NEG
72631: PUSH
72632: LD_INT 1
72634: NEG
72635: PUSH
72636: EMPTY
72637: LIST
72638: LIST
72639: PUSH
72640: LD_INT 1
72642: NEG
72643: PUSH
72644: LD_INT 2
72646: NEG
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 0
72654: PUSH
72655: LD_INT 2
72657: NEG
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PUSH
72663: LD_INT 1
72665: PUSH
72666: LD_INT 1
72668: NEG
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: LD_INT 2
72676: PUSH
72677: LD_INT 1
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: PUSH
72684: LD_INT 2
72686: PUSH
72687: LD_INT 2
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 1
72696: PUSH
72697: LD_INT 2
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 0
72706: PUSH
72707: LD_INT 2
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: LD_INT 1
72716: NEG
72717: PUSH
72718: LD_INT 1
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 2
72727: NEG
72728: PUSH
72729: LD_INT 0
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 2
72738: NEG
72739: PUSH
72740: LD_INT 1
72742: NEG
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 1
72750: NEG
72751: PUSH
72752: LD_INT 3
72754: NEG
72755: PUSH
72756: EMPTY
72757: LIST
72758: LIST
72759: PUSH
72760: LD_INT 1
72762: PUSH
72763: LD_INT 2
72765: NEG
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: LD_INT 3
72773: PUSH
72774: LD_INT 2
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 2
72783: PUSH
72784: LD_INT 3
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 2
72793: NEG
72794: PUSH
72795: LD_INT 1
72797: PUSH
72798: EMPTY
72799: LIST
72800: LIST
72801: PUSH
72802: LD_INT 3
72804: NEG
72805: PUSH
72806: LD_INT 1
72808: NEG
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: LIST
72824: LIST
72825: LIST
72826: LIST
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72839: LD_ADDR_VAR 0 33
72843: PUSH
72844: LD_INT 0
72846: PUSH
72847: LD_INT 0
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 0
72856: PUSH
72857: LD_INT 1
72859: NEG
72860: PUSH
72861: EMPTY
72862: LIST
72863: LIST
72864: PUSH
72865: LD_INT 1
72867: PUSH
72868: LD_INT 0
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 1
72877: PUSH
72878: LD_INT 1
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 0
72887: PUSH
72888: LD_INT 1
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PUSH
72895: LD_INT 1
72897: NEG
72898: PUSH
72899: LD_INT 0
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 1
72908: NEG
72909: PUSH
72910: LD_INT 1
72912: NEG
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 1
72920: NEG
72921: PUSH
72922: LD_INT 2
72924: NEG
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 1
72932: PUSH
72933: LD_INT 1
72935: NEG
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 2
72943: PUSH
72944: LD_INT 0
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 2
72953: PUSH
72954: LD_INT 1
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: LD_INT 2
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 0
72973: PUSH
72974: LD_INT 2
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 1
72983: NEG
72984: PUSH
72985: LD_INT 1
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 2
72994: NEG
72995: PUSH
72996: LD_INT 0
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 2
73005: NEG
73006: PUSH
73007: LD_INT 1
73009: NEG
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: PUSH
73015: LD_INT 2
73017: NEG
73018: PUSH
73019: LD_INT 2
73021: NEG
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: PUSH
73027: LD_INT 2
73029: NEG
73030: PUSH
73031: LD_INT 3
73033: NEG
73034: PUSH
73035: EMPTY
73036: LIST
73037: LIST
73038: PUSH
73039: LD_INT 2
73041: PUSH
73042: LD_INT 1
73044: NEG
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: LD_INT 3
73052: PUSH
73053: LD_INT 1
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: LD_INT 1
73062: PUSH
73063: LD_INT 3
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: LD_INT 1
73072: NEG
73073: PUSH
73074: LD_INT 2
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: LD_INT 3
73083: NEG
73084: PUSH
73085: LD_INT 2
73087: NEG
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PUSH
73093: EMPTY
73094: LIST
73095: LIST
73096: LIST
73097: LIST
73098: LIST
73099: LIST
73100: LIST
73101: LIST
73102: LIST
73103: LIST
73104: LIST
73105: LIST
73106: LIST
73107: LIST
73108: LIST
73109: LIST
73110: LIST
73111: LIST
73112: LIST
73113: LIST
73114: LIST
73115: LIST
73116: LIST
73117: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73118: LD_ADDR_VAR 0 34
73122: PUSH
73123: LD_INT 0
73125: PUSH
73126: LD_INT 0
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: PUSH
73133: LD_INT 0
73135: PUSH
73136: LD_INT 1
73138: NEG
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 1
73146: PUSH
73147: LD_INT 0
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 1
73156: PUSH
73157: LD_INT 1
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: LD_INT 0
73166: PUSH
73167: LD_INT 1
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: LD_INT 1
73176: NEG
73177: PUSH
73178: LD_INT 0
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 1
73187: NEG
73188: PUSH
73189: LD_INT 1
73191: NEG
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: LD_INT 1
73199: NEG
73200: PUSH
73201: LD_INT 2
73203: NEG
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 0
73211: PUSH
73212: LD_INT 2
73214: NEG
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: LD_INT 1
73222: PUSH
73223: LD_INT 1
73225: NEG
73226: PUSH
73227: EMPTY
73228: LIST
73229: LIST
73230: PUSH
73231: LD_INT 2
73233: PUSH
73234: LD_INT 1
73236: PUSH
73237: EMPTY
73238: LIST
73239: LIST
73240: PUSH
73241: LD_INT 2
73243: PUSH
73244: LD_INT 2
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: LD_INT 1
73253: PUSH
73254: LD_INT 2
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 1
73263: NEG
73264: PUSH
73265: LD_INT 1
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: LD_INT 2
73274: NEG
73275: PUSH
73276: LD_INT 0
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: LD_INT 2
73285: NEG
73286: PUSH
73287: LD_INT 1
73289: NEG
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: LD_INT 2
73297: NEG
73298: PUSH
73299: LD_INT 2
73301: NEG
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: PUSH
73307: LD_INT 1
73309: NEG
73310: PUSH
73311: LD_INT 3
73313: NEG
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: LD_INT 1
73321: PUSH
73322: LD_INT 2
73324: NEG
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 3
73332: PUSH
73333: LD_INT 2
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: PUSH
73340: LD_INT 2
73342: PUSH
73343: LD_INT 3
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PUSH
73350: LD_INT 2
73352: NEG
73353: PUSH
73354: LD_INT 1
73356: PUSH
73357: EMPTY
73358: LIST
73359: LIST
73360: PUSH
73361: LD_INT 3
73363: NEG
73364: PUSH
73365: LD_INT 1
73367: NEG
73368: PUSH
73369: EMPTY
73370: LIST
73371: LIST
73372: PUSH
73373: EMPTY
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: LIST
73380: LIST
73381: LIST
73382: LIST
73383: LIST
73384: LIST
73385: LIST
73386: LIST
73387: LIST
73388: LIST
73389: LIST
73390: LIST
73391: LIST
73392: LIST
73393: LIST
73394: LIST
73395: LIST
73396: LIST
73397: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
73398: LD_ADDR_VAR 0 35
73402: PUSH
73403: LD_INT 0
73405: PUSH
73406: LD_INT 0
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 0
73415: PUSH
73416: LD_INT 1
73418: NEG
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: LD_INT 1
73426: PUSH
73427: LD_INT 0
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 1
73436: PUSH
73437: LD_INT 1
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: LD_INT 0
73446: PUSH
73447: LD_INT 1
73449: PUSH
73450: EMPTY
73451: LIST
73452: LIST
73453: PUSH
73454: LD_INT 1
73456: NEG
73457: PUSH
73458: LD_INT 0
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 1
73467: NEG
73468: PUSH
73469: LD_INT 1
73471: NEG
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: LD_INT 2
73479: PUSH
73480: LD_INT 1
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: LD_INT 2
73489: NEG
73490: PUSH
73491: LD_INT 1
73493: NEG
73494: PUSH
73495: EMPTY
73496: LIST
73497: LIST
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: LIST
73503: LIST
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73510: LD_ADDR_VAR 0 36
73514: PUSH
73515: LD_INT 0
73517: PUSH
73518: LD_INT 0
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: LD_INT 0
73527: PUSH
73528: LD_INT 1
73530: NEG
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: LD_INT 1
73538: PUSH
73539: LD_INT 0
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PUSH
73546: LD_INT 1
73548: PUSH
73549: LD_INT 1
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: LD_INT 0
73558: PUSH
73559: LD_INT 1
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 1
73568: NEG
73569: PUSH
73570: LD_INT 0
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 1
73579: NEG
73580: PUSH
73581: LD_INT 1
73583: NEG
73584: PUSH
73585: EMPTY
73586: LIST
73587: LIST
73588: PUSH
73589: LD_INT 1
73591: NEG
73592: PUSH
73593: LD_INT 2
73595: NEG
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PUSH
73601: LD_INT 1
73603: PUSH
73604: LD_INT 2
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: PUSH
73611: EMPTY
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73622: LD_ADDR_VAR 0 37
73626: PUSH
73627: LD_INT 0
73629: PUSH
73630: LD_INT 0
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: PUSH
73637: LD_INT 0
73639: PUSH
73640: LD_INT 1
73642: NEG
73643: PUSH
73644: EMPTY
73645: LIST
73646: LIST
73647: PUSH
73648: LD_INT 1
73650: PUSH
73651: LD_INT 0
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: LD_INT 1
73660: PUSH
73661: LD_INT 1
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: PUSH
73668: LD_INT 0
73670: PUSH
73671: LD_INT 1
73673: PUSH
73674: EMPTY
73675: LIST
73676: LIST
73677: PUSH
73678: LD_INT 1
73680: NEG
73681: PUSH
73682: LD_INT 0
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 1
73691: NEG
73692: PUSH
73693: LD_INT 1
73695: NEG
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: LD_INT 1
73703: PUSH
73704: LD_INT 1
73706: NEG
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: LD_INT 1
73714: NEG
73715: PUSH
73716: LD_INT 1
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: EMPTY
73724: LIST
73725: LIST
73726: LIST
73727: LIST
73728: LIST
73729: LIST
73730: LIST
73731: LIST
73732: LIST
73733: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
73734: LD_ADDR_VAR 0 38
73738: PUSH
73739: LD_INT 0
73741: PUSH
73742: LD_INT 0
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PUSH
73749: LD_INT 0
73751: PUSH
73752: LD_INT 1
73754: NEG
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PUSH
73760: LD_INT 1
73762: PUSH
73763: LD_INT 0
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: LD_INT 1
73772: PUSH
73773: LD_INT 1
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: PUSH
73780: LD_INT 0
73782: PUSH
73783: LD_INT 1
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 1
73792: NEG
73793: PUSH
73794: LD_INT 0
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: PUSH
73801: LD_INT 1
73803: NEG
73804: PUSH
73805: LD_INT 1
73807: NEG
73808: PUSH
73809: EMPTY
73810: LIST
73811: LIST
73812: PUSH
73813: LD_INT 2
73815: PUSH
73816: LD_INT 1
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 2
73825: NEG
73826: PUSH
73827: LD_INT 1
73829: NEG
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73846: LD_ADDR_VAR 0 39
73850: PUSH
73851: LD_INT 0
73853: PUSH
73854: LD_INT 0
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 0
73863: PUSH
73864: LD_INT 1
73866: NEG
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 1
73874: PUSH
73875: LD_INT 0
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 1
73884: PUSH
73885: LD_INT 1
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: LD_INT 1
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 1
73904: NEG
73905: PUSH
73906: LD_INT 0
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 1
73915: NEG
73916: PUSH
73917: LD_INT 1
73919: NEG
73920: PUSH
73921: EMPTY
73922: LIST
73923: LIST
73924: PUSH
73925: LD_INT 1
73927: NEG
73928: PUSH
73929: LD_INT 2
73931: NEG
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: LD_INT 1
73939: PUSH
73940: LD_INT 2
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: LIST
73951: LIST
73952: LIST
73953: LIST
73954: LIST
73955: LIST
73956: LIST
73957: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73958: LD_ADDR_VAR 0 40
73962: PUSH
73963: LD_INT 0
73965: PUSH
73966: LD_INT 0
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 0
73975: PUSH
73976: LD_INT 1
73978: NEG
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 1
73986: PUSH
73987: LD_INT 0
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 1
73996: PUSH
73997: LD_INT 1
73999: PUSH
74000: EMPTY
74001: LIST
74002: LIST
74003: PUSH
74004: LD_INT 0
74006: PUSH
74007: LD_INT 1
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PUSH
74014: LD_INT 1
74016: NEG
74017: PUSH
74018: LD_INT 0
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: PUSH
74025: LD_INT 1
74027: NEG
74028: PUSH
74029: LD_INT 1
74031: NEG
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PUSH
74037: LD_INT 1
74039: PUSH
74040: LD_INT 1
74042: NEG
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: PUSH
74048: LD_INT 1
74050: NEG
74051: PUSH
74052: LD_INT 1
74054: PUSH
74055: EMPTY
74056: LIST
74057: LIST
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74070: LD_ADDR_VAR 0 41
74074: PUSH
74075: LD_INT 0
74077: PUSH
74078: LD_INT 0
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 0
74087: PUSH
74088: LD_INT 1
74090: NEG
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 1
74098: PUSH
74099: LD_INT 0
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: LD_INT 1
74108: PUSH
74109: LD_INT 1
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 0
74118: PUSH
74119: LD_INT 1
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 1
74128: NEG
74129: PUSH
74130: LD_INT 0
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: PUSH
74137: LD_INT 1
74139: NEG
74140: PUSH
74141: LD_INT 1
74143: NEG
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 1
74151: NEG
74152: PUSH
74153: LD_INT 2
74155: NEG
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: LD_INT 1
74163: PUSH
74164: LD_INT 1
74166: NEG
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: PUSH
74172: LD_INT 2
74174: PUSH
74175: LD_INT 0
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: PUSH
74182: LD_INT 2
74184: PUSH
74185: LD_INT 1
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: PUSH
74192: LD_INT 2
74194: PUSH
74195: LD_INT 2
74197: PUSH
74198: EMPTY
74199: LIST
74200: LIST
74201: PUSH
74202: LD_INT 1
74204: PUSH
74205: LD_INT 2
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: PUSH
74212: LD_INT 1
74214: NEG
74215: PUSH
74216: LD_INT 1
74218: PUSH
74219: EMPTY
74220: LIST
74221: LIST
74222: PUSH
74223: LD_INT 2
74225: NEG
74226: PUSH
74227: LD_INT 0
74229: PUSH
74230: EMPTY
74231: LIST
74232: LIST
74233: PUSH
74234: LD_INT 2
74236: NEG
74237: PUSH
74238: LD_INT 1
74240: NEG
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: PUSH
74246: LD_INT 2
74248: NEG
74249: PUSH
74250: LD_INT 2
74252: NEG
74253: PUSH
74254: EMPTY
74255: LIST
74256: LIST
74257: PUSH
74258: LD_INT 2
74260: NEG
74261: PUSH
74262: LD_INT 3
74264: NEG
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: PUSH
74270: LD_INT 2
74272: PUSH
74273: LD_INT 1
74275: NEG
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: PUSH
74281: LD_INT 3
74283: PUSH
74284: LD_INT 0
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: PUSH
74291: LD_INT 3
74293: PUSH
74294: LD_INT 1
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: PUSH
74301: LD_INT 3
74303: PUSH
74304: LD_INT 2
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 3
74313: PUSH
74314: LD_INT 3
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 2
74323: PUSH
74324: LD_INT 3
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 2
74333: NEG
74334: PUSH
74335: LD_INT 1
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: PUSH
74342: LD_INT 3
74344: NEG
74345: PUSH
74346: LD_INT 0
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: PUSH
74353: LD_INT 3
74355: NEG
74356: PUSH
74357: LD_INT 1
74359: NEG
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 3
74367: NEG
74368: PUSH
74369: LD_INT 2
74371: NEG
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: PUSH
74377: LD_INT 3
74379: NEG
74380: PUSH
74381: LD_INT 3
74383: NEG
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: LIST
74393: LIST
74394: LIST
74395: LIST
74396: LIST
74397: LIST
74398: LIST
74399: LIST
74400: LIST
74401: LIST
74402: LIST
74403: LIST
74404: LIST
74405: LIST
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74420: LD_ADDR_VAR 0 42
74424: PUSH
74425: LD_INT 0
74427: PUSH
74428: LD_INT 0
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PUSH
74435: LD_INT 0
74437: PUSH
74438: LD_INT 1
74440: NEG
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: PUSH
74446: LD_INT 1
74448: PUSH
74449: LD_INT 0
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: LD_INT 1
74458: PUSH
74459: LD_INT 1
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PUSH
74466: LD_INT 0
74468: PUSH
74469: LD_INT 1
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 1
74478: NEG
74479: PUSH
74480: LD_INT 0
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PUSH
74487: LD_INT 1
74489: NEG
74490: PUSH
74491: LD_INT 1
74493: NEG
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 1
74501: NEG
74502: PUSH
74503: LD_INT 2
74505: NEG
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 0
74513: PUSH
74514: LD_INT 2
74516: NEG
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 1
74524: PUSH
74525: LD_INT 1
74527: NEG
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: PUSH
74533: LD_INT 2
74535: PUSH
74536: LD_INT 1
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: PUSH
74543: LD_INT 2
74545: PUSH
74546: LD_INT 2
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: PUSH
74553: LD_INT 1
74555: PUSH
74556: LD_INT 2
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: LD_INT 0
74565: PUSH
74566: LD_INT 2
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: LD_INT 1
74575: NEG
74576: PUSH
74577: LD_INT 1
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 2
74586: NEG
74587: PUSH
74588: LD_INT 1
74590: NEG
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: LD_INT 2
74598: NEG
74599: PUSH
74600: LD_INT 2
74602: NEG
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 2
74610: NEG
74611: PUSH
74612: LD_INT 3
74614: NEG
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PUSH
74620: LD_INT 1
74622: NEG
74623: PUSH
74624: LD_INT 3
74626: NEG
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: PUSH
74632: LD_INT 0
74634: PUSH
74635: LD_INT 3
74637: NEG
74638: PUSH
74639: EMPTY
74640: LIST
74641: LIST
74642: PUSH
74643: LD_INT 1
74645: PUSH
74646: LD_INT 2
74648: NEG
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 3
74656: PUSH
74657: LD_INT 2
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: LD_INT 3
74666: PUSH
74667: LD_INT 3
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 2
74676: PUSH
74677: LD_INT 3
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 1
74686: PUSH
74687: LD_INT 3
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: LD_INT 0
74696: PUSH
74697: LD_INT 3
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: PUSH
74704: LD_INT 1
74706: NEG
74707: PUSH
74708: LD_INT 2
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 3
74717: NEG
74718: PUSH
74719: LD_INT 2
74721: NEG
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 3
74729: NEG
74730: PUSH
74731: LD_INT 3
74733: NEG
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: LIST
74750: LIST
74751: LIST
74752: LIST
74753: LIST
74754: LIST
74755: LIST
74756: LIST
74757: LIST
74758: LIST
74759: LIST
74760: LIST
74761: LIST
74762: LIST
74763: LIST
74764: LIST
74765: LIST
74766: LIST
74767: LIST
74768: LIST
74769: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74770: LD_ADDR_VAR 0 43
74774: PUSH
74775: LD_INT 0
74777: PUSH
74778: LD_INT 0
74780: PUSH
74781: EMPTY
74782: LIST
74783: LIST
74784: PUSH
74785: LD_INT 0
74787: PUSH
74788: LD_INT 1
74790: NEG
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: PUSH
74796: LD_INT 1
74798: PUSH
74799: LD_INT 0
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: LD_INT 1
74808: PUSH
74809: LD_INT 1
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: PUSH
74816: LD_INT 0
74818: PUSH
74819: LD_INT 1
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: PUSH
74826: LD_INT 1
74828: NEG
74829: PUSH
74830: LD_INT 0
74832: PUSH
74833: EMPTY
74834: LIST
74835: LIST
74836: PUSH
74837: LD_INT 1
74839: NEG
74840: PUSH
74841: LD_INT 1
74843: NEG
74844: PUSH
74845: EMPTY
74846: LIST
74847: LIST
74848: PUSH
74849: LD_INT 1
74851: NEG
74852: PUSH
74853: LD_INT 2
74855: NEG
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 0
74863: PUSH
74864: LD_INT 2
74866: NEG
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 1
74874: PUSH
74875: LD_INT 1
74877: NEG
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: LD_INT 2
74885: PUSH
74886: LD_INT 0
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 2
74895: PUSH
74896: LD_INT 1
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 1
74905: PUSH
74906: LD_INT 2
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 0
74915: PUSH
74916: LD_INT 2
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 1
74925: NEG
74926: PUSH
74927: LD_INT 1
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 2
74936: NEG
74937: PUSH
74938: LD_INT 0
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 2
74947: NEG
74948: PUSH
74949: LD_INT 1
74951: NEG
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: LD_INT 1
74959: NEG
74960: PUSH
74961: LD_INT 3
74963: NEG
74964: PUSH
74965: EMPTY
74966: LIST
74967: LIST
74968: PUSH
74969: LD_INT 0
74971: PUSH
74972: LD_INT 3
74974: NEG
74975: PUSH
74976: EMPTY
74977: LIST
74978: LIST
74979: PUSH
74980: LD_INT 1
74982: PUSH
74983: LD_INT 2
74985: NEG
74986: PUSH
74987: EMPTY
74988: LIST
74989: LIST
74990: PUSH
74991: LD_INT 2
74993: PUSH
74994: LD_INT 1
74996: NEG
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: PUSH
75002: LD_INT 3
75004: PUSH
75005: LD_INT 0
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: LD_INT 3
75014: PUSH
75015: LD_INT 1
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: PUSH
75022: LD_INT 1
75024: PUSH
75025: LD_INT 3
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 0
75034: PUSH
75035: LD_INT 3
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: LD_INT 1
75044: NEG
75045: PUSH
75046: LD_INT 2
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 2
75055: NEG
75056: PUSH
75057: LD_INT 1
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: LD_INT 3
75066: NEG
75067: PUSH
75068: LD_INT 0
75070: PUSH
75071: EMPTY
75072: LIST
75073: LIST
75074: PUSH
75075: LD_INT 3
75077: NEG
75078: PUSH
75079: LD_INT 1
75081: NEG
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: LIST
75091: LIST
75092: LIST
75093: LIST
75094: LIST
75095: LIST
75096: LIST
75097: LIST
75098: LIST
75099: LIST
75100: LIST
75101: LIST
75102: LIST
75103: LIST
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: LIST
75114: LIST
75115: LIST
75116: LIST
75117: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75118: LD_ADDR_VAR 0 44
75122: PUSH
75123: LD_INT 0
75125: PUSH
75126: LD_INT 0
75128: PUSH
75129: EMPTY
75130: LIST
75131: LIST
75132: PUSH
75133: LD_INT 0
75135: PUSH
75136: LD_INT 1
75138: NEG
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 1
75146: PUSH
75147: LD_INT 0
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: PUSH
75154: LD_INT 1
75156: PUSH
75157: LD_INT 1
75159: PUSH
75160: EMPTY
75161: LIST
75162: LIST
75163: PUSH
75164: LD_INT 0
75166: PUSH
75167: LD_INT 1
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: PUSH
75174: LD_INT 1
75176: NEG
75177: PUSH
75178: LD_INT 0
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: PUSH
75185: LD_INT 1
75187: NEG
75188: PUSH
75189: LD_INT 1
75191: NEG
75192: PUSH
75193: EMPTY
75194: LIST
75195: LIST
75196: PUSH
75197: LD_INT 1
75199: NEG
75200: PUSH
75201: LD_INT 2
75203: NEG
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: PUSH
75209: LD_INT 1
75211: PUSH
75212: LD_INT 1
75214: NEG
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: LD_INT 2
75222: PUSH
75223: LD_INT 0
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PUSH
75230: LD_INT 2
75232: PUSH
75233: LD_INT 1
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 2
75242: PUSH
75243: LD_INT 2
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 1
75252: PUSH
75253: LD_INT 2
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 1
75262: NEG
75263: PUSH
75264: LD_INT 1
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: PUSH
75271: LD_INT 2
75273: NEG
75274: PUSH
75275: LD_INT 0
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: PUSH
75282: LD_INT 2
75284: NEG
75285: PUSH
75286: LD_INT 1
75288: NEG
75289: PUSH
75290: EMPTY
75291: LIST
75292: LIST
75293: PUSH
75294: LD_INT 2
75296: NEG
75297: PUSH
75298: LD_INT 2
75300: NEG
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 2
75308: NEG
75309: PUSH
75310: LD_INT 3
75312: NEG
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 2
75320: PUSH
75321: LD_INT 1
75323: NEG
75324: PUSH
75325: EMPTY
75326: LIST
75327: LIST
75328: PUSH
75329: LD_INT 3
75331: PUSH
75332: LD_INT 0
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PUSH
75339: LD_INT 3
75341: PUSH
75342: LD_INT 1
75344: PUSH
75345: EMPTY
75346: LIST
75347: LIST
75348: PUSH
75349: LD_INT 3
75351: PUSH
75352: LD_INT 2
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 3
75361: PUSH
75362: LD_INT 3
75364: PUSH
75365: EMPTY
75366: LIST
75367: LIST
75368: PUSH
75369: LD_INT 2
75371: PUSH
75372: LD_INT 3
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: PUSH
75379: LD_INT 2
75381: NEG
75382: PUSH
75383: LD_INT 1
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 3
75392: NEG
75393: PUSH
75394: LD_INT 0
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 3
75403: NEG
75404: PUSH
75405: LD_INT 1
75407: NEG
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PUSH
75413: LD_INT 3
75415: NEG
75416: PUSH
75417: LD_INT 2
75419: NEG
75420: PUSH
75421: EMPTY
75422: LIST
75423: LIST
75424: PUSH
75425: LD_INT 3
75427: NEG
75428: PUSH
75429: LD_INT 3
75431: NEG
75432: PUSH
75433: EMPTY
75434: LIST
75435: LIST
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: LIST
75441: LIST
75442: LIST
75443: LIST
75444: LIST
75445: LIST
75446: LIST
75447: LIST
75448: LIST
75449: LIST
75450: LIST
75451: LIST
75452: LIST
75453: LIST
75454: LIST
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: LIST
75460: LIST
75461: LIST
75462: LIST
75463: LIST
75464: LIST
75465: LIST
75466: LIST
75467: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75468: LD_ADDR_VAR 0 45
75472: PUSH
75473: LD_INT 0
75475: PUSH
75476: LD_INT 0
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 0
75485: PUSH
75486: LD_INT 1
75488: NEG
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 1
75496: PUSH
75497: LD_INT 0
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 1
75506: PUSH
75507: LD_INT 1
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 0
75516: PUSH
75517: LD_INT 1
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: LD_INT 0
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 1
75537: NEG
75538: PUSH
75539: LD_INT 1
75541: NEG
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PUSH
75547: LD_INT 1
75549: NEG
75550: PUSH
75551: LD_INT 2
75553: NEG
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: PUSH
75559: LD_INT 0
75561: PUSH
75562: LD_INT 2
75564: NEG
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 1
75572: PUSH
75573: LD_INT 1
75575: NEG
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 2
75583: PUSH
75584: LD_INT 1
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 2
75593: PUSH
75594: LD_INT 2
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 1
75603: PUSH
75604: LD_INT 2
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 0
75613: PUSH
75614: LD_INT 2
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 1
75623: NEG
75624: PUSH
75625: LD_INT 1
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 2
75634: NEG
75635: PUSH
75636: LD_INT 1
75638: NEG
75639: PUSH
75640: EMPTY
75641: LIST
75642: LIST
75643: PUSH
75644: LD_INT 2
75646: NEG
75647: PUSH
75648: LD_INT 2
75650: NEG
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: PUSH
75656: LD_INT 2
75658: NEG
75659: PUSH
75660: LD_INT 3
75662: NEG
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 1
75670: NEG
75671: PUSH
75672: LD_INT 3
75674: NEG
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 0
75682: PUSH
75683: LD_INT 3
75685: NEG
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 1
75693: PUSH
75694: LD_INT 2
75696: NEG
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 3
75704: PUSH
75705: LD_INT 2
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 3
75714: PUSH
75715: LD_INT 3
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 2
75724: PUSH
75725: LD_INT 3
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 1
75734: PUSH
75735: LD_INT 3
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 0
75744: PUSH
75745: LD_INT 3
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 1
75754: NEG
75755: PUSH
75756: LD_INT 2
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 3
75765: NEG
75766: PUSH
75767: LD_INT 2
75769: NEG
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 3
75777: NEG
75778: PUSH
75779: LD_INT 3
75781: NEG
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: LIST
75791: LIST
75792: LIST
75793: LIST
75794: LIST
75795: LIST
75796: LIST
75797: LIST
75798: LIST
75799: LIST
75800: LIST
75801: LIST
75802: LIST
75803: LIST
75804: LIST
75805: LIST
75806: LIST
75807: LIST
75808: LIST
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: LIST
75814: LIST
75815: LIST
75816: LIST
75817: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75818: LD_ADDR_VAR 0 46
75822: PUSH
75823: LD_INT 0
75825: PUSH
75826: LD_INT 0
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PUSH
75833: LD_INT 0
75835: PUSH
75836: LD_INT 1
75838: NEG
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: LD_INT 1
75846: PUSH
75847: LD_INT 0
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: PUSH
75854: LD_INT 1
75856: PUSH
75857: LD_INT 1
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: PUSH
75864: LD_INT 0
75866: PUSH
75867: LD_INT 1
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 1
75876: NEG
75877: PUSH
75878: LD_INT 0
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PUSH
75885: LD_INT 1
75887: NEG
75888: PUSH
75889: LD_INT 1
75891: NEG
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 1
75899: NEG
75900: PUSH
75901: LD_INT 2
75903: NEG
75904: PUSH
75905: EMPTY
75906: LIST
75907: LIST
75908: PUSH
75909: LD_INT 0
75911: PUSH
75912: LD_INT 2
75914: NEG
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 1
75922: PUSH
75923: LD_INT 1
75925: NEG
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 2
75933: PUSH
75934: LD_INT 0
75936: PUSH
75937: EMPTY
75938: LIST
75939: LIST
75940: PUSH
75941: LD_INT 2
75943: PUSH
75944: LD_INT 1
75946: PUSH
75947: EMPTY
75948: LIST
75949: LIST
75950: PUSH
75951: LD_INT 1
75953: PUSH
75954: LD_INT 2
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: LD_INT 0
75963: PUSH
75964: LD_INT 2
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: PUSH
75971: LD_INT 1
75973: NEG
75974: PUSH
75975: LD_INT 1
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: PUSH
75982: LD_INT 2
75984: NEG
75985: PUSH
75986: LD_INT 0
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: PUSH
75993: LD_INT 2
75995: NEG
75996: PUSH
75997: LD_INT 1
75999: NEG
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PUSH
76005: LD_INT 1
76007: NEG
76008: PUSH
76009: LD_INT 3
76011: NEG
76012: PUSH
76013: EMPTY
76014: LIST
76015: LIST
76016: PUSH
76017: LD_INT 0
76019: PUSH
76020: LD_INT 3
76022: NEG
76023: PUSH
76024: EMPTY
76025: LIST
76026: LIST
76027: PUSH
76028: LD_INT 1
76030: PUSH
76031: LD_INT 2
76033: NEG
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: PUSH
76039: LD_INT 2
76041: PUSH
76042: LD_INT 1
76044: NEG
76045: PUSH
76046: EMPTY
76047: LIST
76048: LIST
76049: PUSH
76050: LD_INT 3
76052: PUSH
76053: LD_INT 0
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: PUSH
76060: LD_INT 3
76062: PUSH
76063: LD_INT 1
76065: PUSH
76066: EMPTY
76067: LIST
76068: LIST
76069: PUSH
76070: LD_INT 1
76072: PUSH
76073: LD_INT 3
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PUSH
76080: LD_INT 0
76082: PUSH
76083: LD_INT 3
76085: PUSH
76086: EMPTY
76087: LIST
76088: LIST
76089: PUSH
76090: LD_INT 1
76092: NEG
76093: PUSH
76094: LD_INT 2
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 2
76103: NEG
76104: PUSH
76105: LD_INT 1
76107: PUSH
76108: EMPTY
76109: LIST
76110: LIST
76111: PUSH
76112: LD_INT 3
76114: NEG
76115: PUSH
76116: LD_INT 0
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 3
76125: NEG
76126: PUSH
76127: LD_INT 1
76129: NEG
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: LIST
76139: LIST
76140: LIST
76141: LIST
76142: LIST
76143: LIST
76144: LIST
76145: LIST
76146: LIST
76147: LIST
76148: LIST
76149: LIST
76150: LIST
76151: LIST
76152: LIST
76153: LIST
76154: LIST
76155: LIST
76156: LIST
76157: LIST
76158: LIST
76159: LIST
76160: LIST
76161: LIST
76162: LIST
76163: LIST
76164: LIST
76165: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76166: LD_ADDR_VAR 0 47
76170: PUSH
76171: LD_INT 0
76173: PUSH
76174: LD_INT 0
76176: PUSH
76177: EMPTY
76178: LIST
76179: LIST
76180: PUSH
76181: LD_INT 0
76183: PUSH
76184: LD_INT 1
76186: NEG
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: LD_INT 1
76194: PUSH
76195: LD_INT 0
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 1
76204: PUSH
76205: LD_INT 1
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: LD_INT 0
76214: PUSH
76215: LD_INT 1
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: PUSH
76222: LD_INT 1
76224: NEG
76225: PUSH
76226: LD_INT 0
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PUSH
76233: LD_INT 1
76235: NEG
76236: PUSH
76237: LD_INT 1
76239: NEG
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: LD_INT 1
76247: NEG
76248: PUSH
76249: LD_INT 2
76251: NEG
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PUSH
76257: LD_INT 0
76259: PUSH
76260: LD_INT 2
76262: NEG
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: PUSH
76268: LD_INT 1
76270: PUSH
76271: LD_INT 1
76273: NEG
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: LD_INT 2
76281: NEG
76282: PUSH
76283: LD_INT 1
76285: NEG
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: PUSH
76291: LD_INT 2
76293: NEG
76294: PUSH
76295: LD_INT 2
76297: NEG
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: LIST
76307: LIST
76308: LIST
76309: LIST
76310: LIST
76311: LIST
76312: LIST
76313: LIST
76314: LIST
76315: LIST
76316: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76317: LD_ADDR_VAR 0 48
76321: PUSH
76322: LD_INT 0
76324: PUSH
76325: LD_INT 0
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: PUSH
76332: LD_INT 0
76334: PUSH
76335: LD_INT 1
76337: NEG
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 1
76345: PUSH
76346: LD_INT 0
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 1
76355: PUSH
76356: LD_INT 1
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: LD_INT 0
76365: PUSH
76366: LD_INT 1
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 1
76375: NEG
76376: PUSH
76377: LD_INT 0
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: LD_INT 1
76386: NEG
76387: PUSH
76388: LD_INT 1
76390: NEG
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: LD_INT 1
76398: NEG
76399: PUSH
76400: LD_INT 2
76402: NEG
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: PUSH
76408: LD_INT 0
76410: PUSH
76411: LD_INT 2
76413: NEG
76414: PUSH
76415: EMPTY
76416: LIST
76417: LIST
76418: PUSH
76419: LD_INT 1
76421: PUSH
76422: LD_INT 1
76424: NEG
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 2
76432: PUSH
76433: LD_INT 0
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: LD_INT 2
76442: PUSH
76443: LD_INT 1
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: LIST
76458: LIST
76459: LIST
76460: LIST
76461: LIST
76462: LIST
76463: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76464: LD_ADDR_VAR 0 49
76468: PUSH
76469: LD_INT 0
76471: PUSH
76472: LD_INT 0
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: LD_INT 0
76481: PUSH
76482: LD_INT 1
76484: NEG
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 1
76492: PUSH
76493: LD_INT 0
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: PUSH
76500: LD_INT 1
76502: PUSH
76503: LD_INT 1
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: PUSH
76510: LD_INT 0
76512: PUSH
76513: LD_INT 1
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 1
76522: NEG
76523: PUSH
76524: LD_INT 0
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PUSH
76531: LD_INT 1
76533: NEG
76534: PUSH
76535: LD_INT 1
76537: NEG
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 1
76545: PUSH
76546: LD_INT 1
76548: NEG
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 2
76556: PUSH
76557: LD_INT 0
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: PUSH
76564: LD_INT 2
76566: PUSH
76567: LD_INT 1
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PUSH
76574: LD_INT 2
76576: PUSH
76577: LD_INT 2
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: PUSH
76584: LD_INT 1
76586: PUSH
76587: LD_INT 2
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: LIST
76600: LIST
76601: LIST
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: LIST
76607: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76608: LD_ADDR_VAR 0 50
76612: PUSH
76613: LD_INT 0
76615: PUSH
76616: LD_INT 0
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: PUSH
76623: LD_INT 0
76625: PUSH
76626: LD_INT 1
76628: NEG
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PUSH
76634: LD_INT 1
76636: PUSH
76637: LD_INT 0
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 1
76646: PUSH
76647: LD_INT 1
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: LD_INT 0
76656: PUSH
76657: LD_INT 1
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PUSH
76664: LD_INT 1
76666: NEG
76667: PUSH
76668: LD_INT 0
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: PUSH
76675: LD_INT 1
76677: NEG
76678: PUSH
76679: LD_INT 1
76681: NEG
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 2
76689: PUSH
76690: LD_INT 1
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 2
76699: PUSH
76700: LD_INT 2
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PUSH
76707: LD_INT 1
76709: PUSH
76710: LD_INT 2
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: LD_INT 0
76719: PUSH
76720: LD_INT 2
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 1
76729: NEG
76730: PUSH
76731: LD_INT 1
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: LIST
76742: LIST
76743: LIST
76744: LIST
76745: LIST
76746: LIST
76747: LIST
76748: LIST
76749: LIST
76750: LIST
76751: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76752: LD_ADDR_VAR 0 51
76756: PUSH
76757: LD_INT 0
76759: PUSH
76760: LD_INT 0
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: PUSH
76767: LD_INT 0
76769: PUSH
76770: LD_INT 1
76772: NEG
76773: PUSH
76774: EMPTY
76775: LIST
76776: LIST
76777: PUSH
76778: LD_INT 1
76780: PUSH
76781: LD_INT 0
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PUSH
76788: LD_INT 1
76790: PUSH
76791: LD_INT 1
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 0
76800: PUSH
76801: LD_INT 1
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 1
76810: NEG
76811: PUSH
76812: LD_INT 0
76814: PUSH
76815: EMPTY
76816: LIST
76817: LIST
76818: PUSH
76819: LD_INT 1
76821: NEG
76822: PUSH
76823: LD_INT 1
76825: NEG
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PUSH
76831: LD_INT 1
76833: PUSH
76834: LD_INT 2
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: PUSH
76841: LD_INT 0
76843: PUSH
76844: LD_INT 2
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: PUSH
76851: LD_INT 1
76853: NEG
76854: PUSH
76855: LD_INT 1
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: PUSH
76862: LD_INT 2
76864: NEG
76865: PUSH
76866: LD_INT 0
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 2
76875: NEG
76876: PUSH
76877: LD_INT 1
76879: NEG
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76899: LD_ADDR_VAR 0 52
76903: PUSH
76904: LD_INT 0
76906: PUSH
76907: LD_INT 0
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 0
76916: PUSH
76917: LD_INT 1
76919: NEG
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: PUSH
76925: LD_INT 1
76927: PUSH
76928: LD_INT 0
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PUSH
76935: LD_INT 1
76937: PUSH
76938: LD_INT 1
76940: PUSH
76941: EMPTY
76942: LIST
76943: LIST
76944: PUSH
76945: LD_INT 0
76947: PUSH
76948: LD_INT 1
76950: PUSH
76951: EMPTY
76952: LIST
76953: LIST
76954: PUSH
76955: LD_INT 1
76957: NEG
76958: PUSH
76959: LD_INT 0
76961: PUSH
76962: EMPTY
76963: LIST
76964: LIST
76965: PUSH
76966: LD_INT 1
76968: NEG
76969: PUSH
76970: LD_INT 1
76972: NEG
76973: PUSH
76974: EMPTY
76975: LIST
76976: LIST
76977: PUSH
76978: LD_INT 1
76980: NEG
76981: PUSH
76982: LD_INT 2
76984: NEG
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 1
76992: NEG
76993: PUSH
76994: LD_INT 1
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: PUSH
77001: LD_INT 2
77003: NEG
77004: PUSH
77005: LD_INT 0
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PUSH
77012: LD_INT 2
77014: NEG
77015: PUSH
77016: LD_INT 1
77018: NEG
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: PUSH
77024: LD_INT 2
77026: NEG
77027: PUSH
77028: LD_INT 2
77030: NEG
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: LIST
77040: LIST
77041: LIST
77042: LIST
77043: LIST
77044: LIST
77045: LIST
77046: LIST
77047: LIST
77048: LIST
77049: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77050: LD_ADDR_VAR 0 53
77054: PUSH
77055: LD_INT 0
77057: PUSH
77058: LD_INT 0
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: LD_INT 0
77067: PUSH
77068: LD_INT 1
77070: NEG
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PUSH
77076: LD_INT 1
77078: PUSH
77079: LD_INT 0
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PUSH
77086: LD_INT 1
77088: PUSH
77089: LD_INT 1
77091: PUSH
77092: EMPTY
77093: LIST
77094: LIST
77095: PUSH
77096: LD_INT 0
77098: PUSH
77099: LD_INT 1
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 1
77108: NEG
77109: PUSH
77110: LD_INT 0
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 1
77119: NEG
77120: PUSH
77121: LD_INT 1
77123: NEG
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: LD_INT 1
77131: NEG
77132: PUSH
77133: LD_INT 2
77135: NEG
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: LD_INT 0
77143: PUSH
77144: LD_INT 2
77146: NEG
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: PUSH
77152: LD_INT 1
77154: PUSH
77155: LD_INT 1
77157: NEG
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: LD_INT 2
77165: PUSH
77166: LD_INT 0
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PUSH
77173: LD_INT 2
77175: PUSH
77176: LD_INT 1
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 2
77185: PUSH
77186: LD_INT 2
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: PUSH
77193: LD_INT 1
77195: PUSH
77196: LD_INT 2
77198: PUSH
77199: EMPTY
77200: LIST
77201: LIST
77202: PUSH
77203: LD_INT 0
77205: PUSH
77206: LD_INT 2
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: PUSH
77213: LD_INT 1
77215: NEG
77216: PUSH
77217: LD_INT 1
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PUSH
77224: LD_INT 2
77226: NEG
77227: PUSH
77228: LD_INT 0
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 2
77237: NEG
77238: PUSH
77239: LD_INT 1
77241: NEG
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 2
77249: NEG
77250: PUSH
77251: LD_INT 2
77253: NEG
77254: PUSH
77255: EMPTY
77256: LIST
77257: LIST
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: LIST
77263: LIST
77264: LIST
77265: LIST
77266: LIST
77267: LIST
77268: LIST
77269: LIST
77270: LIST
77271: LIST
77272: LIST
77273: LIST
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77280: LD_ADDR_VAR 0 54
77284: PUSH
77285: LD_INT 0
77287: PUSH
77288: LD_INT 0
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 0
77297: PUSH
77298: LD_INT 1
77300: NEG
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 1
77308: PUSH
77309: LD_INT 0
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 1
77318: PUSH
77319: LD_INT 1
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 0
77328: PUSH
77329: LD_INT 1
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: LD_INT 1
77338: NEG
77339: PUSH
77340: LD_INT 0
77342: PUSH
77343: EMPTY
77344: LIST
77345: LIST
77346: PUSH
77347: LD_INT 1
77349: NEG
77350: PUSH
77351: LD_INT 1
77353: NEG
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 1
77361: NEG
77362: PUSH
77363: LD_INT 2
77365: NEG
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PUSH
77371: LD_INT 0
77373: PUSH
77374: LD_INT 2
77376: NEG
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: LD_INT 1
77384: PUSH
77385: LD_INT 1
77387: NEG
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 2
77395: PUSH
77396: LD_INT 0
77398: PUSH
77399: EMPTY
77400: LIST
77401: LIST
77402: PUSH
77403: LD_INT 2
77405: PUSH
77406: LD_INT 1
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: PUSH
77413: LD_INT 2
77415: PUSH
77416: LD_INT 2
77418: PUSH
77419: EMPTY
77420: LIST
77421: LIST
77422: PUSH
77423: LD_INT 1
77425: PUSH
77426: LD_INT 2
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: LD_INT 0
77435: PUSH
77436: LD_INT 2
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: PUSH
77443: LD_INT 1
77445: NEG
77446: PUSH
77447: LD_INT 1
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: PUSH
77454: LD_INT 2
77456: NEG
77457: PUSH
77458: LD_INT 0
77460: PUSH
77461: EMPTY
77462: LIST
77463: LIST
77464: PUSH
77465: LD_INT 2
77467: NEG
77468: PUSH
77469: LD_INT 1
77471: NEG
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: PUSH
77477: LD_INT 2
77479: NEG
77480: PUSH
77481: LD_INT 2
77483: NEG
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: EMPTY
77490: LIST
77491: LIST
77492: LIST
77493: LIST
77494: LIST
77495: LIST
77496: LIST
77497: LIST
77498: LIST
77499: LIST
77500: LIST
77501: LIST
77502: LIST
77503: LIST
77504: LIST
77505: LIST
77506: LIST
77507: LIST
77508: LIST
77509: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77510: LD_ADDR_VAR 0 55
77514: PUSH
77515: LD_INT 0
77517: PUSH
77518: LD_INT 0
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 0
77527: PUSH
77528: LD_INT 1
77530: NEG
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 1
77538: PUSH
77539: LD_INT 0
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: PUSH
77546: LD_INT 1
77548: PUSH
77549: LD_INT 1
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: PUSH
77556: LD_INT 0
77558: PUSH
77559: LD_INT 1
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: PUSH
77566: LD_INT 1
77568: NEG
77569: PUSH
77570: LD_INT 0
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: PUSH
77577: LD_INT 1
77579: NEG
77580: PUSH
77581: LD_INT 1
77583: NEG
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: PUSH
77589: LD_INT 1
77591: NEG
77592: PUSH
77593: LD_INT 2
77595: NEG
77596: PUSH
77597: EMPTY
77598: LIST
77599: LIST
77600: PUSH
77601: LD_INT 0
77603: PUSH
77604: LD_INT 2
77606: NEG
77607: PUSH
77608: EMPTY
77609: LIST
77610: LIST
77611: PUSH
77612: LD_INT 1
77614: PUSH
77615: LD_INT 1
77617: NEG
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 2
77625: PUSH
77626: LD_INT 0
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PUSH
77633: LD_INT 2
77635: PUSH
77636: LD_INT 1
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: LD_INT 2
77645: PUSH
77646: LD_INT 2
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: PUSH
77653: LD_INT 1
77655: PUSH
77656: LD_INT 2
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: LD_INT 0
77665: PUSH
77666: LD_INT 2
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 1
77675: NEG
77676: PUSH
77677: LD_INT 1
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PUSH
77684: LD_INT 2
77686: NEG
77687: PUSH
77688: LD_INT 0
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: LD_INT 2
77697: NEG
77698: PUSH
77699: LD_INT 1
77701: NEG
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PUSH
77707: LD_INT 2
77709: NEG
77710: PUSH
77711: LD_INT 2
77713: NEG
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77740: LD_ADDR_VAR 0 56
77744: PUSH
77745: LD_INT 0
77747: PUSH
77748: LD_INT 0
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: LD_INT 0
77757: PUSH
77758: LD_INT 1
77760: NEG
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 1
77768: PUSH
77769: LD_INT 0
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: LD_INT 1
77778: PUSH
77779: LD_INT 1
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 0
77788: PUSH
77789: LD_INT 1
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: PUSH
77796: LD_INT 1
77798: NEG
77799: PUSH
77800: LD_INT 0
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 1
77809: NEG
77810: PUSH
77811: LD_INT 1
77813: NEG
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: LD_INT 1
77821: NEG
77822: PUSH
77823: LD_INT 2
77825: NEG
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 0
77833: PUSH
77834: LD_INT 2
77836: NEG
77837: PUSH
77838: EMPTY
77839: LIST
77840: LIST
77841: PUSH
77842: LD_INT 1
77844: PUSH
77845: LD_INT 1
77847: NEG
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: LD_INT 2
77855: PUSH
77856: LD_INT 0
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 2
77865: PUSH
77866: LD_INT 1
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 2
77875: PUSH
77876: LD_INT 2
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 1
77885: PUSH
77886: LD_INT 2
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 0
77895: PUSH
77896: LD_INT 2
77898: PUSH
77899: EMPTY
77900: LIST
77901: LIST
77902: PUSH
77903: LD_INT 1
77905: NEG
77906: PUSH
77907: LD_INT 1
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: PUSH
77914: LD_INT 2
77916: NEG
77917: PUSH
77918: LD_INT 0
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 2
77927: NEG
77928: PUSH
77929: LD_INT 1
77931: NEG
77932: PUSH
77933: EMPTY
77934: LIST
77935: LIST
77936: PUSH
77937: LD_INT 2
77939: NEG
77940: PUSH
77941: LD_INT 2
77943: NEG
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: LIST
77953: LIST
77954: LIST
77955: LIST
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: LIST
77962: LIST
77963: LIST
77964: LIST
77965: LIST
77966: LIST
77967: LIST
77968: LIST
77969: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77970: LD_ADDR_VAR 0 57
77974: PUSH
77975: LD_INT 0
77977: PUSH
77978: LD_INT 0
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 0
77987: PUSH
77988: LD_INT 1
77990: NEG
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 1
77998: PUSH
77999: LD_INT 0
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: PUSH
78006: LD_INT 1
78008: PUSH
78009: LD_INT 1
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 0
78018: PUSH
78019: LD_INT 1
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 1
78028: NEG
78029: PUSH
78030: LD_INT 0
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: PUSH
78037: LD_INT 1
78039: NEG
78040: PUSH
78041: LD_INT 1
78043: NEG
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 1
78051: NEG
78052: PUSH
78053: LD_INT 2
78055: NEG
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: LD_INT 0
78063: PUSH
78064: LD_INT 2
78066: NEG
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PUSH
78072: LD_INT 1
78074: PUSH
78075: LD_INT 1
78077: NEG
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: LD_INT 2
78085: PUSH
78086: LD_INT 0
78088: PUSH
78089: EMPTY
78090: LIST
78091: LIST
78092: PUSH
78093: LD_INT 2
78095: PUSH
78096: LD_INT 1
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: PUSH
78103: LD_INT 2
78105: PUSH
78106: LD_INT 2
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 1
78115: PUSH
78116: LD_INT 2
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 0
78125: PUSH
78126: LD_INT 2
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: PUSH
78133: LD_INT 1
78135: NEG
78136: PUSH
78137: LD_INT 1
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 2
78146: NEG
78147: PUSH
78148: LD_INT 0
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 2
78157: NEG
78158: PUSH
78159: LD_INT 1
78161: NEG
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 2
78169: NEG
78170: PUSH
78171: LD_INT 2
78173: NEG
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: LIST
78183: LIST
78184: LIST
78185: LIST
78186: LIST
78187: LIST
78188: LIST
78189: LIST
78190: LIST
78191: LIST
78192: LIST
78193: LIST
78194: LIST
78195: LIST
78196: LIST
78197: LIST
78198: LIST
78199: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78200: LD_ADDR_VAR 0 58
78204: PUSH
78205: LD_INT 0
78207: PUSH
78208: LD_INT 0
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 0
78217: PUSH
78218: LD_INT 1
78220: NEG
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PUSH
78226: LD_INT 1
78228: PUSH
78229: LD_INT 0
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 1
78238: PUSH
78239: LD_INT 1
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: PUSH
78246: LD_INT 0
78248: PUSH
78249: LD_INT 1
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 1
78258: NEG
78259: PUSH
78260: LD_INT 0
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: PUSH
78267: LD_INT 1
78269: NEG
78270: PUSH
78271: LD_INT 1
78273: NEG
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: PUSH
78279: LD_INT 1
78281: NEG
78282: PUSH
78283: LD_INT 2
78285: NEG
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: PUSH
78291: LD_INT 0
78293: PUSH
78294: LD_INT 2
78296: NEG
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 1
78304: PUSH
78305: LD_INT 1
78307: NEG
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 2
78315: PUSH
78316: LD_INT 0
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PUSH
78323: LD_INT 2
78325: PUSH
78326: LD_INT 1
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: PUSH
78333: LD_INT 2
78335: PUSH
78336: LD_INT 2
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: LD_INT 1
78345: PUSH
78346: LD_INT 2
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 0
78355: PUSH
78356: LD_INT 2
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 1
78365: NEG
78366: PUSH
78367: LD_INT 1
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 2
78376: NEG
78377: PUSH
78378: LD_INT 0
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 2
78387: NEG
78388: PUSH
78389: LD_INT 1
78391: NEG
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 2
78399: NEG
78400: PUSH
78401: LD_INT 2
78403: NEG
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: EMPTY
78410: LIST
78411: LIST
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: LIST
78426: LIST
78427: LIST
78428: LIST
78429: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78430: LD_ADDR_VAR 0 59
78434: PUSH
78435: LD_INT 0
78437: PUSH
78438: LD_INT 0
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 0
78447: PUSH
78448: LD_INT 1
78450: NEG
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 1
78458: PUSH
78459: LD_INT 0
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 1
78468: PUSH
78469: LD_INT 1
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 0
78478: PUSH
78479: LD_INT 1
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 1
78488: NEG
78489: PUSH
78490: LD_INT 0
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 1
78499: NEG
78500: PUSH
78501: LD_INT 1
78503: NEG
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: LIST
78513: LIST
78514: LIST
78515: LIST
78516: LIST
78517: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78518: LD_ADDR_VAR 0 60
78522: PUSH
78523: LD_INT 0
78525: PUSH
78526: LD_INT 0
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 0
78535: PUSH
78536: LD_INT 1
78538: NEG
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: PUSH
78544: LD_INT 1
78546: PUSH
78547: LD_INT 0
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: LD_INT 1
78556: PUSH
78557: LD_INT 1
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: LD_INT 0
78566: PUSH
78567: LD_INT 1
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 1
78576: NEG
78577: PUSH
78578: LD_INT 0
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 1
78587: NEG
78588: PUSH
78589: LD_INT 1
78591: NEG
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78606: LD_ADDR_VAR 0 61
78610: PUSH
78611: LD_INT 0
78613: PUSH
78614: LD_INT 0
78616: PUSH
78617: EMPTY
78618: LIST
78619: LIST
78620: PUSH
78621: LD_INT 0
78623: PUSH
78624: LD_INT 1
78626: NEG
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PUSH
78632: LD_INT 1
78634: PUSH
78635: LD_INT 0
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PUSH
78642: LD_INT 1
78644: PUSH
78645: LD_INT 1
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 0
78654: PUSH
78655: LD_INT 1
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: PUSH
78662: LD_INT 1
78664: NEG
78665: PUSH
78666: LD_INT 0
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 1
78675: NEG
78676: PUSH
78677: LD_INT 1
78679: NEG
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: LIST
78689: LIST
78690: LIST
78691: LIST
78692: LIST
78693: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78694: LD_ADDR_VAR 0 62
78698: PUSH
78699: LD_INT 0
78701: PUSH
78702: LD_INT 0
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: PUSH
78709: LD_INT 0
78711: PUSH
78712: LD_INT 1
78714: NEG
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: LD_INT 1
78722: PUSH
78723: LD_INT 0
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: LD_INT 1
78732: PUSH
78733: LD_INT 1
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 0
78742: PUSH
78743: LD_INT 1
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 1
78752: NEG
78753: PUSH
78754: LD_INT 0
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 1
78763: NEG
78764: PUSH
78765: LD_INT 1
78767: NEG
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78782: LD_ADDR_VAR 0 63
78786: PUSH
78787: LD_INT 0
78789: PUSH
78790: LD_INT 0
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PUSH
78797: LD_INT 0
78799: PUSH
78800: LD_INT 1
78802: NEG
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 1
78810: PUSH
78811: LD_INT 0
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: LD_INT 1
78820: PUSH
78821: LD_INT 1
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: PUSH
78828: LD_INT 0
78830: PUSH
78831: LD_INT 1
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 1
78840: NEG
78841: PUSH
78842: LD_INT 0
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PUSH
78849: LD_INT 1
78851: NEG
78852: PUSH
78853: LD_INT 1
78855: NEG
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PUSH
78861: EMPTY
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78870: LD_ADDR_VAR 0 64
78874: PUSH
78875: LD_INT 0
78877: PUSH
78878: LD_INT 0
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: PUSH
78885: LD_INT 0
78887: PUSH
78888: LD_INT 1
78890: NEG
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: PUSH
78896: LD_INT 1
78898: PUSH
78899: LD_INT 0
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 1
78908: PUSH
78909: LD_INT 1
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: LD_INT 0
78918: PUSH
78919: LD_INT 1
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 1
78928: NEG
78929: PUSH
78930: LD_INT 0
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 1
78939: NEG
78940: PUSH
78941: LD_INT 1
78943: NEG
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: LIST
78953: LIST
78954: LIST
78955: LIST
78956: LIST
78957: ST_TO_ADDR
// end ; 1 :
78958: GO 84855
78960: LD_INT 1
78962: DOUBLE
78963: EQUAL
78964: IFTRUE 78968
78966: GO 81591
78968: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78969: LD_ADDR_VAR 0 11
78973: PUSH
78974: LD_INT 1
78976: NEG
78977: PUSH
78978: LD_INT 3
78980: NEG
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 0
78988: PUSH
78989: LD_INT 3
78991: NEG
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PUSH
78997: LD_INT 1
78999: PUSH
79000: LD_INT 2
79002: NEG
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: LIST
79012: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79013: LD_ADDR_VAR 0 12
79017: PUSH
79018: LD_INT 2
79020: PUSH
79021: LD_INT 1
79023: NEG
79024: PUSH
79025: EMPTY
79026: LIST
79027: LIST
79028: PUSH
79029: LD_INT 3
79031: PUSH
79032: LD_INT 0
79034: PUSH
79035: EMPTY
79036: LIST
79037: LIST
79038: PUSH
79039: LD_INT 3
79041: PUSH
79042: LD_INT 1
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: LIST
79053: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79054: LD_ADDR_VAR 0 13
79058: PUSH
79059: LD_INT 3
79061: PUSH
79062: LD_INT 2
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 3
79071: PUSH
79072: LD_INT 3
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 2
79081: PUSH
79082: LD_INT 3
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: LIST
79093: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79094: LD_ADDR_VAR 0 14
79098: PUSH
79099: LD_INT 1
79101: PUSH
79102: LD_INT 3
79104: PUSH
79105: EMPTY
79106: LIST
79107: LIST
79108: PUSH
79109: LD_INT 0
79111: PUSH
79112: LD_INT 3
79114: PUSH
79115: EMPTY
79116: LIST
79117: LIST
79118: PUSH
79119: LD_INT 1
79121: NEG
79122: PUSH
79123: LD_INT 2
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: LIST
79134: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79135: LD_ADDR_VAR 0 15
79139: PUSH
79140: LD_INT 2
79142: NEG
79143: PUSH
79144: LD_INT 1
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: PUSH
79151: LD_INT 3
79153: NEG
79154: PUSH
79155: LD_INT 0
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: PUSH
79162: LD_INT 3
79164: NEG
79165: PUSH
79166: LD_INT 1
79168: NEG
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: LIST
79178: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79179: LD_ADDR_VAR 0 16
79183: PUSH
79184: LD_INT 2
79186: NEG
79187: PUSH
79188: LD_INT 3
79190: NEG
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: PUSH
79196: LD_INT 3
79198: NEG
79199: PUSH
79200: LD_INT 2
79202: NEG
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PUSH
79208: LD_INT 3
79210: NEG
79211: PUSH
79212: LD_INT 3
79214: NEG
79215: PUSH
79216: EMPTY
79217: LIST
79218: LIST
79219: PUSH
79220: EMPTY
79221: LIST
79222: LIST
79223: LIST
79224: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79225: LD_ADDR_VAR 0 17
79229: PUSH
79230: LD_INT 1
79232: NEG
79233: PUSH
79234: LD_INT 3
79236: NEG
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 0
79244: PUSH
79245: LD_INT 3
79247: NEG
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 1
79255: PUSH
79256: LD_INT 2
79258: NEG
79259: PUSH
79260: EMPTY
79261: LIST
79262: LIST
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: LIST
79268: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79269: LD_ADDR_VAR 0 18
79273: PUSH
79274: LD_INT 2
79276: PUSH
79277: LD_INT 1
79279: NEG
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 3
79287: PUSH
79288: LD_INT 0
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 3
79297: PUSH
79298: LD_INT 1
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: LIST
79309: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79310: LD_ADDR_VAR 0 19
79314: PUSH
79315: LD_INT 3
79317: PUSH
79318: LD_INT 2
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 3
79327: PUSH
79328: LD_INT 3
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 2
79337: PUSH
79338: LD_INT 3
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: LIST
79349: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79350: LD_ADDR_VAR 0 20
79354: PUSH
79355: LD_INT 1
79357: PUSH
79358: LD_INT 3
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: PUSH
79365: LD_INT 0
79367: PUSH
79368: LD_INT 3
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 1
79377: NEG
79378: PUSH
79379: LD_INT 2
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: LIST
79390: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79391: LD_ADDR_VAR 0 21
79395: PUSH
79396: LD_INT 2
79398: NEG
79399: PUSH
79400: LD_INT 1
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 3
79409: NEG
79410: PUSH
79411: LD_INT 0
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 3
79420: NEG
79421: PUSH
79422: LD_INT 1
79424: NEG
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PUSH
79430: EMPTY
79431: LIST
79432: LIST
79433: LIST
79434: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79435: LD_ADDR_VAR 0 22
79439: PUSH
79440: LD_INT 2
79442: NEG
79443: PUSH
79444: LD_INT 3
79446: NEG
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: LD_INT 3
79454: NEG
79455: PUSH
79456: LD_INT 2
79458: NEG
79459: PUSH
79460: EMPTY
79461: LIST
79462: LIST
79463: PUSH
79464: LD_INT 3
79466: NEG
79467: PUSH
79468: LD_INT 3
79470: NEG
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: LIST
79480: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
79481: LD_ADDR_VAR 0 23
79485: PUSH
79486: LD_INT 0
79488: PUSH
79489: LD_INT 3
79491: NEG
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 1
79499: NEG
79500: PUSH
79501: LD_INT 4
79503: NEG
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: LD_INT 1
79511: PUSH
79512: LD_INT 3
79514: NEG
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: LIST
79524: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
79525: LD_ADDR_VAR 0 24
79529: PUSH
79530: LD_INT 3
79532: PUSH
79533: LD_INT 0
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PUSH
79540: LD_INT 3
79542: PUSH
79543: LD_INT 1
79545: NEG
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: PUSH
79551: LD_INT 4
79553: PUSH
79554: LD_INT 1
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: LIST
79565: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
79566: LD_ADDR_VAR 0 25
79570: PUSH
79571: LD_INT 3
79573: PUSH
79574: LD_INT 3
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: LD_INT 4
79583: PUSH
79584: LD_INT 3
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PUSH
79591: LD_INT 3
79593: PUSH
79594: LD_INT 4
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: LIST
79605: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
79606: LD_ADDR_VAR 0 26
79610: PUSH
79611: LD_INT 0
79613: PUSH
79614: LD_INT 3
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 1
79623: PUSH
79624: LD_INT 4
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: PUSH
79631: LD_INT 1
79633: NEG
79634: PUSH
79635: LD_INT 3
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: LIST
79646: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
79647: LD_ADDR_VAR 0 27
79651: PUSH
79652: LD_INT 3
79654: NEG
79655: PUSH
79656: LD_INT 0
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 3
79665: NEG
79666: PUSH
79667: LD_INT 1
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 4
79676: NEG
79677: PUSH
79678: LD_INT 1
79680: NEG
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: LIST
79690: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
79691: LD_ADDR_VAR 0 28
79695: PUSH
79696: LD_INT 3
79698: NEG
79699: PUSH
79700: LD_INT 3
79702: NEG
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 3
79710: NEG
79711: PUSH
79712: LD_INT 4
79714: NEG
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: PUSH
79720: LD_INT 4
79722: NEG
79723: PUSH
79724: LD_INT 3
79726: NEG
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: LIST
79736: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
79737: LD_ADDR_VAR 0 29
79741: PUSH
79742: LD_INT 1
79744: NEG
79745: PUSH
79746: LD_INT 3
79748: NEG
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 0
79756: PUSH
79757: LD_INT 3
79759: NEG
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 1
79767: PUSH
79768: LD_INT 2
79770: NEG
79771: PUSH
79772: EMPTY
79773: LIST
79774: LIST
79775: PUSH
79776: LD_INT 1
79778: NEG
79779: PUSH
79780: LD_INT 4
79782: NEG
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 0
79790: PUSH
79791: LD_INT 4
79793: NEG
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 1
79801: PUSH
79802: LD_INT 3
79804: NEG
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 1
79812: NEG
79813: PUSH
79814: LD_INT 5
79816: NEG
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 0
79824: PUSH
79825: LD_INT 5
79827: NEG
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 1
79835: PUSH
79836: LD_INT 4
79838: NEG
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: PUSH
79844: LD_INT 1
79846: NEG
79847: PUSH
79848: LD_INT 6
79850: NEG
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 0
79858: PUSH
79859: LD_INT 6
79861: NEG
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 1
79869: PUSH
79870: LD_INT 5
79872: NEG
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: LIST
79882: LIST
79883: LIST
79884: LIST
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: LIST
79890: LIST
79891: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
79892: LD_ADDR_VAR 0 30
79896: PUSH
79897: LD_INT 2
79899: PUSH
79900: LD_INT 1
79902: NEG
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 3
79910: PUSH
79911: LD_INT 0
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 3
79920: PUSH
79921: LD_INT 1
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 3
79930: PUSH
79931: LD_INT 1
79933: NEG
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 4
79941: PUSH
79942: LD_INT 0
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 4
79951: PUSH
79952: LD_INT 1
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 4
79961: PUSH
79962: LD_INT 1
79964: NEG
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 5
79972: PUSH
79973: LD_INT 0
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 5
79982: PUSH
79983: LD_INT 1
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 5
79992: PUSH
79993: LD_INT 1
79995: NEG
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 6
80003: PUSH
80004: LD_INT 0
80006: PUSH
80007: EMPTY
80008: LIST
80009: LIST
80010: PUSH
80011: LD_INT 6
80013: PUSH
80014: LD_INT 1
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: LIST
80025: LIST
80026: LIST
80027: LIST
80028: LIST
80029: LIST
80030: LIST
80031: LIST
80032: LIST
80033: LIST
80034: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
80035: LD_ADDR_VAR 0 31
80039: PUSH
80040: LD_INT 3
80042: PUSH
80043: LD_INT 2
80045: PUSH
80046: EMPTY
80047: LIST
80048: LIST
80049: PUSH
80050: LD_INT 3
80052: PUSH
80053: LD_INT 3
80055: PUSH
80056: EMPTY
80057: LIST
80058: LIST
80059: PUSH
80060: LD_INT 2
80062: PUSH
80063: LD_INT 3
80065: PUSH
80066: EMPTY
80067: LIST
80068: LIST
80069: PUSH
80070: LD_INT 4
80072: PUSH
80073: LD_INT 3
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 4
80082: PUSH
80083: LD_INT 4
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 3
80092: PUSH
80093: LD_INT 4
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: PUSH
80100: LD_INT 5
80102: PUSH
80103: LD_INT 4
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: PUSH
80110: LD_INT 5
80112: PUSH
80113: LD_INT 5
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 4
80122: PUSH
80123: LD_INT 5
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 6
80132: PUSH
80133: LD_INT 5
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 6
80142: PUSH
80143: LD_INT 6
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 5
80152: PUSH
80153: LD_INT 6
80155: PUSH
80156: EMPTY
80157: LIST
80158: LIST
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
80174: LD_ADDR_VAR 0 32
80178: PUSH
80179: LD_INT 1
80181: PUSH
80182: LD_INT 3
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: PUSH
80189: LD_INT 0
80191: PUSH
80192: LD_INT 3
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PUSH
80199: LD_INT 1
80201: NEG
80202: PUSH
80203: LD_INT 2
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 1
80212: PUSH
80213: LD_INT 4
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 0
80222: PUSH
80223: LD_INT 4
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: LD_INT 1
80232: NEG
80233: PUSH
80234: LD_INT 3
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 1
80243: PUSH
80244: LD_INT 5
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: LD_INT 0
80253: PUSH
80254: LD_INT 5
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 1
80263: NEG
80264: PUSH
80265: LD_INT 4
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 1
80274: PUSH
80275: LD_INT 6
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 0
80284: PUSH
80285: LD_INT 6
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PUSH
80292: LD_INT 1
80294: NEG
80295: PUSH
80296: LD_INT 5
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: LIST
80307: LIST
80308: LIST
80309: LIST
80310: LIST
80311: LIST
80312: LIST
80313: LIST
80314: LIST
80315: LIST
80316: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
80317: LD_ADDR_VAR 0 33
80321: PUSH
80322: LD_INT 2
80324: NEG
80325: PUSH
80326: LD_INT 1
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 3
80335: NEG
80336: PUSH
80337: LD_INT 0
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: LD_INT 3
80346: NEG
80347: PUSH
80348: LD_INT 1
80350: NEG
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 3
80358: NEG
80359: PUSH
80360: LD_INT 1
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 4
80369: NEG
80370: PUSH
80371: LD_INT 0
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 4
80380: NEG
80381: PUSH
80382: LD_INT 1
80384: NEG
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 4
80392: NEG
80393: PUSH
80394: LD_INT 1
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 5
80403: NEG
80404: PUSH
80405: LD_INT 0
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 5
80414: NEG
80415: PUSH
80416: LD_INT 1
80418: NEG
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 5
80426: NEG
80427: PUSH
80428: LD_INT 1
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 6
80437: NEG
80438: PUSH
80439: LD_INT 0
80441: PUSH
80442: EMPTY
80443: LIST
80444: LIST
80445: PUSH
80446: LD_INT 6
80448: NEG
80449: PUSH
80450: LD_INT 1
80452: NEG
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
80472: LD_ADDR_VAR 0 34
80476: PUSH
80477: LD_INT 2
80479: NEG
80480: PUSH
80481: LD_INT 3
80483: NEG
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: PUSH
80489: LD_INT 3
80491: NEG
80492: PUSH
80493: LD_INT 2
80495: NEG
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 3
80503: NEG
80504: PUSH
80505: LD_INT 3
80507: NEG
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 3
80515: NEG
80516: PUSH
80517: LD_INT 4
80519: NEG
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 4
80527: NEG
80528: PUSH
80529: LD_INT 3
80531: NEG
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: PUSH
80537: LD_INT 4
80539: NEG
80540: PUSH
80541: LD_INT 4
80543: NEG
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PUSH
80549: LD_INT 4
80551: NEG
80552: PUSH
80553: LD_INT 5
80555: NEG
80556: PUSH
80557: EMPTY
80558: LIST
80559: LIST
80560: PUSH
80561: LD_INT 5
80563: NEG
80564: PUSH
80565: LD_INT 4
80567: NEG
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: PUSH
80573: LD_INT 5
80575: NEG
80576: PUSH
80577: LD_INT 5
80579: NEG
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 5
80587: NEG
80588: PUSH
80589: LD_INT 6
80591: NEG
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: PUSH
80597: LD_INT 6
80599: NEG
80600: PUSH
80601: LD_INT 5
80603: NEG
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 6
80611: NEG
80612: PUSH
80613: LD_INT 6
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
80635: LD_ADDR_VAR 0 41
80639: PUSH
80640: LD_INT 0
80642: PUSH
80643: LD_INT 2
80645: NEG
80646: PUSH
80647: EMPTY
80648: LIST
80649: LIST
80650: PUSH
80651: LD_INT 1
80653: NEG
80654: PUSH
80655: LD_INT 3
80657: NEG
80658: PUSH
80659: EMPTY
80660: LIST
80661: LIST
80662: PUSH
80663: LD_INT 1
80665: PUSH
80666: LD_INT 2
80668: NEG
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: LIST
80678: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
80679: LD_ADDR_VAR 0 42
80683: PUSH
80684: LD_INT 2
80686: PUSH
80687: LD_INT 0
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 2
80696: PUSH
80697: LD_INT 1
80699: NEG
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 3
80707: PUSH
80708: LD_INT 1
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: LIST
80719: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
80720: LD_ADDR_VAR 0 43
80724: PUSH
80725: LD_INT 2
80727: PUSH
80728: LD_INT 2
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 3
80737: PUSH
80738: LD_INT 2
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: LD_INT 2
80747: PUSH
80748: LD_INT 3
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: LIST
80759: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
80760: LD_ADDR_VAR 0 44
80764: PUSH
80765: LD_INT 0
80767: PUSH
80768: LD_INT 2
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 1
80777: PUSH
80778: LD_INT 3
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 1
80787: NEG
80788: PUSH
80789: LD_INT 2
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: LIST
80800: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80801: LD_ADDR_VAR 0 45
80805: PUSH
80806: LD_INT 2
80808: NEG
80809: PUSH
80810: LD_INT 0
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 2
80819: NEG
80820: PUSH
80821: LD_INT 1
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 3
80830: NEG
80831: PUSH
80832: LD_INT 1
80834: NEG
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: EMPTY
80841: LIST
80842: LIST
80843: LIST
80844: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
80845: LD_ADDR_VAR 0 46
80849: PUSH
80850: LD_INT 2
80852: NEG
80853: PUSH
80854: LD_INT 2
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 2
80864: NEG
80865: PUSH
80866: LD_INT 3
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 3
80876: NEG
80877: PUSH
80878: LD_INT 2
80880: NEG
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: LIST
80890: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
80891: LD_ADDR_VAR 0 47
80895: PUSH
80896: LD_INT 2
80898: NEG
80899: PUSH
80900: LD_INT 3
80902: NEG
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 1
80910: NEG
80911: PUSH
80912: LD_INT 3
80914: NEG
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80924: LD_ADDR_VAR 0 48
80928: PUSH
80929: LD_INT 1
80931: PUSH
80932: LD_INT 2
80934: NEG
80935: PUSH
80936: EMPTY
80937: LIST
80938: LIST
80939: PUSH
80940: LD_INT 2
80942: PUSH
80943: LD_INT 1
80945: NEG
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
80955: LD_ADDR_VAR 0 49
80959: PUSH
80960: LD_INT 3
80962: PUSH
80963: LD_INT 1
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: PUSH
80970: LD_INT 3
80972: PUSH
80973: LD_INT 2
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
80984: LD_ADDR_VAR 0 50
80988: PUSH
80989: LD_INT 2
80991: PUSH
80992: LD_INT 3
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 1
81001: PUSH
81002: LD_INT 3
81004: PUSH
81005: EMPTY
81006: LIST
81007: LIST
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81013: LD_ADDR_VAR 0 51
81017: PUSH
81018: LD_INT 1
81020: NEG
81021: PUSH
81022: LD_INT 2
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 2
81031: NEG
81032: PUSH
81033: LD_INT 1
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81044: LD_ADDR_VAR 0 52
81048: PUSH
81049: LD_INT 3
81051: NEG
81052: PUSH
81053: LD_INT 1
81055: NEG
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 3
81063: NEG
81064: PUSH
81065: LD_INT 2
81067: NEG
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: EMPTY
81074: LIST
81075: LIST
81076: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81077: LD_ADDR_VAR 0 53
81081: PUSH
81082: LD_INT 1
81084: NEG
81085: PUSH
81086: LD_INT 3
81088: NEG
81089: PUSH
81090: EMPTY
81091: LIST
81092: LIST
81093: PUSH
81094: LD_INT 0
81096: PUSH
81097: LD_INT 3
81099: NEG
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 1
81107: PUSH
81108: LD_INT 2
81110: NEG
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: EMPTY
81117: LIST
81118: LIST
81119: LIST
81120: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81121: LD_ADDR_VAR 0 54
81125: PUSH
81126: LD_INT 2
81128: PUSH
81129: LD_INT 1
81131: NEG
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PUSH
81137: LD_INT 3
81139: PUSH
81140: LD_INT 0
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PUSH
81147: LD_INT 3
81149: PUSH
81150: LD_INT 1
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: LIST
81161: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81162: LD_ADDR_VAR 0 55
81166: PUSH
81167: LD_INT 3
81169: PUSH
81170: LD_INT 2
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 3
81179: PUSH
81180: LD_INT 3
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 2
81189: PUSH
81190: LD_INT 3
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: LIST
81201: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81202: LD_ADDR_VAR 0 56
81206: PUSH
81207: LD_INT 1
81209: PUSH
81210: LD_INT 3
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 0
81219: PUSH
81220: LD_INT 3
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 1
81229: NEG
81230: PUSH
81231: LD_INT 2
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: LIST
81242: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81243: LD_ADDR_VAR 0 57
81247: PUSH
81248: LD_INT 2
81250: NEG
81251: PUSH
81252: LD_INT 1
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 3
81261: NEG
81262: PUSH
81263: LD_INT 0
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: PUSH
81270: LD_INT 3
81272: NEG
81273: PUSH
81274: LD_INT 1
81276: NEG
81277: PUSH
81278: EMPTY
81279: LIST
81280: LIST
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: LIST
81286: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81287: LD_ADDR_VAR 0 58
81291: PUSH
81292: LD_INT 2
81294: NEG
81295: PUSH
81296: LD_INT 3
81298: NEG
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 3
81306: NEG
81307: PUSH
81308: LD_INT 2
81310: NEG
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 3
81318: NEG
81319: PUSH
81320: LD_INT 3
81322: NEG
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: EMPTY
81329: LIST
81330: LIST
81331: LIST
81332: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
81333: LD_ADDR_VAR 0 59
81337: PUSH
81338: LD_INT 1
81340: NEG
81341: PUSH
81342: LD_INT 2
81344: NEG
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: PUSH
81350: LD_INT 0
81352: PUSH
81353: LD_INT 2
81355: NEG
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: PUSH
81361: LD_INT 1
81363: PUSH
81364: LD_INT 1
81366: NEG
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: LIST
81376: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
81377: LD_ADDR_VAR 0 60
81381: PUSH
81382: LD_INT 1
81384: PUSH
81385: LD_INT 1
81387: NEG
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 2
81395: PUSH
81396: LD_INT 0
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 2
81405: PUSH
81406: LD_INT 1
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: LIST
81417: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
81418: LD_ADDR_VAR 0 61
81422: PUSH
81423: LD_INT 2
81425: PUSH
81426: LD_INT 1
81428: PUSH
81429: EMPTY
81430: LIST
81431: LIST
81432: PUSH
81433: LD_INT 2
81435: PUSH
81436: LD_INT 2
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PUSH
81443: LD_INT 1
81445: PUSH
81446: LD_INT 2
81448: PUSH
81449: EMPTY
81450: LIST
81451: LIST
81452: PUSH
81453: EMPTY
81454: LIST
81455: LIST
81456: LIST
81457: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
81458: LD_ADDR_VAR 0 62
81462: PUSH
81463: LD_INT 1
81465: PUSH
81466: LD_INT 2
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 0
81475: PUSH
81476: LD_INT 2
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 1
81485: NEG
81486: PUSH
81487: LD_INT 1
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: LIST
81498: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
81499: LD_ADDR_VAR 0 63
81503: PUSH
81504: LD_INT 1
81506: NEG
81507: PUSH
81508: LD_INT 1
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 2
81517: NEG
81518: PUSH
81519: LD_INT 0
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 2
81528: NEG
81529: PUSH
81530: LD_INT 1
81532: NEG
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: LIST
81542: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81543: LD_ADDR_VAR 0 64
81547: PUSH
81548: LD_INT 1
81550: NEG
81551: PUSH
81552: LD_INT 2
81554: NEG
81555: PUSH
81556: EMPTY
81557: LIST
81558: LIST
81559: PUSH
81560: LD_INT 2
81562: NEG
81563: PUSH
81564: LD_INT 1
81566: NEG
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PUSH
81572: LD_INT 2
81574: NEG
81575: PUSH
81576: LD_INT 2
81578: NEG
81579: PUSH
81580: EMPTY
81581: LIST
81582: LIST
81583: PUSH
81584: EMPTY
81585: LIST
81586: LIST
81587: LIST
81588: ST_TO_ADDR
// end ; 2 :
81589: GO 84855
81591: LD_INT 2
81593: DOUBLE
81594: EQUAL
81595: IFTRUE 81599
81597: GO 84854
81599: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
81600: LD_ADDR_VAR 0 29
81604: PUSH
81605: LD_INT 4
81607: PUSH
81608: LD_INT 0
81610: PUSH
81611: EMPTY
81612: LIST
81613: LIST
81614: PUSH
81615: LD_INT 4
81617: PUSH
81618: LD_INT 1
81620: NEG
81621: PUSH
81622: EMPTY
81623: LIST
81624: LIST
81625: PUSH
81626: LD_INT 5
81628: PUSH
81629: LD_INT 0
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: LD_INT 5
81638: PUSH
81639: LD_INT 1
81641: PUSH
81642: EMPTY
81643: LIST
81644: LIST
81645: PUSH
81646: LD_INT 4
81648: PUSH
81649: LD_INT 1
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 3
81658: PUSH
81659: LD_INT 0
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 3
81668: PUSH
81669: LD_INT 1
81671: NEG
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: LD_INT 3
81679: PUSH
81680: LD_INT 2
81682: NEG
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: LD_INT 5
81690: PUSH
81691: LD_INT 2
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 3
81700: PUSH
81701: LD_INT 3
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 3
81710: PUSH
81711: LD_INT 2
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 4
81720: PUSH
81721: LD_INT 3
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 4
81730: PUSH
81731: LD_INT 4
81733: PUSH
81734: EMPTY
81735: LIST
81736: LIST
81737: PUSH
81738: LD_INT 3
81740: PUSH
81741: LD_INT 4
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: PUSH
81748: LD_INT 2
81750: PUSH
81751: LD_INT 3
81753: PUSH
81754: EMPTY
81755: LIST
81756: LIST
81757: PUSH
81758: LD_INT 2
81760: PUSH
81761: LD_INT 2
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 4
81770: PUSH
81771: LD_INT 2
81773: PUSH
81774: EMPTY
81775: LIST
81776: LIST
81777: PUSH
81778: LD_INT 2
81780: PUSH
81781: LD_INT 4
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 0
81790: PUSH
81791: LD_INT 4
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: PUSH
81798: LD_INT 0
81800: PUSH
81801: LD_INT 3
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_INT 1
81810: PUSH
81811: LD_INT 4
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: LD_INT 1
81820: PUSH
81821: LD_INT 5
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 0
81830: PUSH
81831: LD_INT 5
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 1
81840: NEG
81841: PUSH
81842: LD_INT 4
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PUSH
81849: LD_INT 1
81851: NEG
81852: PUSH
81853: LD_INT 3
81855: PUSH
81856: EMPTY
81857: LIST
81858: LIST
81859: PUSH
81860: LD_INT 2
81862: PUSH
81863: LD_INT 5
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PUSH
81870: LD_INT 2
81872: NEG
81873: PUSH
81874: LD_INT 3
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PUSH
81881: LD_INT 3
81883: NEG
81884: PUSH
81885: LD_INT 0
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 3
81894: NEG
81895: PUSH
81896: LD_INT 1
81898: NEG
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 2
81906: NEG
81907: PUSH
81908: LD_INT 0
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 2
81917: NEG
81918: PUSH
81919: LD_INT 1
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 3
81928: NEG
81929: PUSH
81930: LD_INT 1
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 4
81939: NEG
81940: PUSH
81941: LD_INT 0
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: PUSH
81948: LD_INT 4
81950: NEG
81951: PUSH
81952: LD_INT 1
81954: NEG
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 4
81962: NEG
81963: PUSH
81964: LD_INT 2
81966: NEG
81967: PUSH
81968: EMPTY
81969: LIST
81970: LIST
81971: PUSH
81972: LD_INT 2
81974: NEG
81975: PUSH
81976: LD_INT 2
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 4
81985: NEG
81986: PUSH
81987: LD_INT 4
81989: NEG
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: LD_INT 4
81997: NEG
81998: PUSH
81999: LD_INT 5
82001: NEG
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: PUSH
82007: LD_INT 3
82009: NEG
82010: PUSH
82011: LD_INT 4
82013: NEG
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: PUSH
82019: LD_INT 3
82021: NEG
82022: PUSH
82023: LD_INT 3
82025: NEG
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 4
82033: NEG
82034: PUSH
82035: LD_INT 3
82037: NEG
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: PUSH
82043: LD_INT 5
82045: NEG
82046: PUSH
82047: LD_INT 4
82049: NEG
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 5
82057: NEG
82058: PUSH
82059: LD_INT 5
82061: NEG
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 3
82069: NEG
82070: PUSH
82071: LD_INT 5
82073: NEG
82074: PUSH
82075: EMPTY
82076: LIST
82077: LIST
82078: PUSH
82079: LD_INT 5
82081: NEG
82082: PUSH
82083: LD_INT 3
82085: NEG
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: LIST
82095: LIST
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: LIST
82101: LIST
82102: LIST
82103: LIST
82104: LIST
82105: LIST
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: LIST
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: LIST
82121: LIST
82122: LIST
82123: LIST
82124: LIST
82125: LIST
82126: LIST
82127: LIST
82128: LIST
82129: LIST
82130: LIST
82131: LIST
82132: LIST
82133: LIST
82134: LIST
82135: LIST
82136: LIST
82137: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
82138: LD_ADDR_VAR 0 30
82142: PUSH
82143: LD_INT 4
82145: PUSH
82146: LD_INT 4
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 4
82155: PUSH
82156: LD_INT 3
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 5
82165: PUSH
82166: LD_INT 4
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: PUSH
82173: LD_INT 5
82175: PUSH
82176: LD_INT 5
82178: PUSH
82179: EMPTY
82180: LIST
82181: LIST
82182: PUSH
82183: LD_INT 4
82185: PUSH
82186: LD_INT 5
82188: PUSH
82189: EMPTY
82190: LIST
82191: LIST
82192: PUSH
82193: LD_INT 3
82195: PUSH
82196: LD_INT 4
82198: PUSH
82199: EMPTY
82200: LIST
82201: LIST
82202: PUSH
82203: LD_INT 3
82205: PUSH
82206: LD_INT 3
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 5
82215: PUSH
82216: LD_INT 3
82218: PUSH
82219: EMPTY
82220: LIST
82221: LIST
82222: PUSH
82223: LD_INT 3
82225: PUSH
82226: LD_INT 5
82228: PUSH
82229: EMPTY
82230: LIST
82231: LIST
82232: PUSH
82233: LD_INT 0
82235: PUSH
82236: LD_INT 3
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: LD_INT 0
82245: PUSH
82246: LD_INT 2
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 1
82255: PUSH
82256: LD_INT 3
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 1
82265: PUSH
82266: LD_INT 4
82268: PUSH
82269: EMPTY
82270: LIST
82271: LIST
82272: PUSH
82273: LD_INT 0
82275: PUSH
82276: LD_INT 4
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: PUSH
82283: LD_INT 1
82285: NEG
82286: PUSH
82287: LD_INT 3
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: PUSH
82294: LD_INT 1
82296: NEG
82297: PUSH
82298: LD_INT 2
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: PUSH
82305: LD_INT 2
82307: PUSH
82308: LD_INT 4
82310: PUSH
82311: EMPTY
82312: LIST
82313: LIST
82314: PUSH
82315: LD_INT 2
82317: NEG
82318: PUSH
82319: LD_INT 2
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 4
82328: NEG
82329: PUSH
82330: LD_INT 0
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 4
82339: NEG
82340: PUSH
82341: LD_INT 1
82343: NEG
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 3
82351: NEG
82352: PUSH
82353: LD_INT 0
82355: PUSH
82356: EMPTY
82357: LIST
82358: LIST
82359: PUSH
82360: LD_INT 3
82362: NEG
82363: PUSH
82364: LD_INT 1
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: PUSH
82371: LD_INT 4
82373: NEG
82374: PUSH
82375: LD_INT 1
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 5
82384: NEG
82385: PUSH
82386: LD_INT 0
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 5
82395: NEG
82396: PUSH
82397: LD_INT 1
82399: NEG
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 5
82407: NEG
82408: PUSH
82409: LD_INT 2
82411: NEG
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 3
82419: NEG
82420: PUSH
82421: LD_INT 2
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 3
82430: NEG
82431: PUSH
82432: LD_INT 3
82434: NEG
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 3
82442: NEG
82443: PUSH
82444: LD_INT 4
82446: NEG
82447: PUSH
82448: EMPTY
82449: LIST
82450: LIST
82451: PUSH
82452: LD_INT 2
82454: NEG
82455: PUSH
82456: LD_INT 3
82458: NEG
82459: PUSH
82460: EMPTY
82461: LIST
82462: LIST
82463: PUSH
82464: LD_INT 2
82466: NEG
82467: PUSH
82468: LD_INT 2
82470: NEG
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 3
82478: NEG
82479: PUSH
82480: LD_INT 2
82482: NEG
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 4
82490: NEG
82491: PUSH
82492: LD_INT 3
82494: NEG
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 4
82502: NEG
82503: PUSH
82504: LD_INT 4
82506: NEG
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 2
82514: NEG
82515: PUSH
82516: LD_INT 4
82518: NEG
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 4
82526: NEG
82527: PUSH
82528: LD_INT 2
82530: NEG
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: PUSH
82536: LD_INT 0
82538: PUSH
82539: LD_INT 4
82541: NEG
82542: PUSH
82543: EMPTY
82544: LIST
82545: LIST
82546: PUSH
82547: LD_INT 0
82549: PUSH
82550: LD_INT 5
82552: NEG
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 1
82560: PUSH
82561: LD_INT 4
82563: NEG
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 1
82571: PUSH
82572: LD_INT 3
82574: NEG
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 0
82582: PUSH
82583: LD_INT 3
82585: NEG
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PUSH
82591: LD_INT 1
82593: NEG
82594: PUSH
82595: LD_INT 4
82597: NEG
82598: PUSH
82599: EMPTY
82600: LIST
82601: LIST
82602: PUSH
82603: LD_INT 1
82605: NEG
82606: PUSH
82607: LD_INT 5
82609: NEG
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 2
82617: PUSH
82618: LD_INT 3
82620: NEG
82621: PUSH
82622: EMPTY
82623: LIST
82624: LIST
82625: PUSH
82626: LD_INT 2
82628: NEG
82629: PUSH
82630: LD_INT 5
82632: NEG
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: LIST
82662: LIST
82663: LIST
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: LIST
82670: LIST
82671: LIST
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: LIST
82679: LIST
82680: LIST
82681: LIST
82682: LIST
82683: LIST
82684: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
82685: LD_ADDR_VAR 0 31
82689: PUSH
82690: LD_INT 0
82692: PUSH
82693: LD_INT 4
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: LD_INT 0
82702: PUSH
82703: LD_INT 3
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 1
82712: PUSH
82713: LD_INT 4
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_INT 1
82722: PUSH
82723: LD_INT 5
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 0
82732: PUSH
82733: LD_INT 5
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 1
82742: NEG
82743: PUSH
82744: LD_INT 4
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 1
82753: NEG
82754: PUSH
82755: LD_INT 3
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 2
82764: PUSH
82765: LD_INT 5
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 2
82774: NEG
82775: PUSH
82776: LD_INT 3
82778: PUSH
82779: EMPTY
82780: LIST
82781: LIST
82782: PUSH
82783: LD_INT 3
82785: NEG
82786: PUSH
82787: LD_INT 0
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 3
82796: NEG
82797: PUSH
82798: LD_INT 1
82800: NEG
82801: PUSH
82802: EMPTY
82803: LIST
82804: LIST
82805: PUSH
82806: LD_INT 2
82808: NEG
82809: PUSH
82810: LD_INT 0
82812: PUSH
82813: EMPTY
82814: LIST
82815: LIST
82816: PUSH
82817: LD_INT 2
82819: NEG
82820: PUSH
82821: LD_INT 1
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: PUSH
82828: LD_INT 3
82830: NEG
82831: PUSH
82832: LD_INT 1
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 4
82841: NEG
82842: PUSH
82843: LD_INT 0
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 4
82852: NEG
82853: PUSH
82854: LD_INT 1
82856: NEG
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 4
82864: NEG
82865: PUSH
82866: LD_INT 2
82868: NEG
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: PUSH
82874: LD_INT 2
82876: NEG
82877: PUSH
82878: LD_INT 2
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 4
82887: NEG
82888: PUSH
82889: LD_INT 4
82891: NEG
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 4
82899: NEG
82900: PUSH
82901: LD_INT 5
82903: NEG
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: LD_INT 3
82911: NEG
82912: PUSH
82913: LD_INT 4
82915: NEG
82916: PUSH
82917: EMPTY
82918: LIST
82919: LIST
82920: PUSH
82921: LD_INT 3
82923: NEG
82924: PUSH
82925: LD_INT 3
82927: NEG
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 4
82935: NEG
82936: PUSH
82937: LD_INT 3
82939: NEG
82940: PUSH
82941: EMPTY
82942: LIST
82943: LIST
82944: PUSH
82945: LD_INT 5
82947: NEG
82948: PUSH
82949: LD_INT 4
82951: NEG
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 5
82959: NEG
82960: PUSH
82961: LD_INT 5
82963: NEG
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 3
82971: NEG
82972: PUSH
82973: LD_INT 5
82975: NEG
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: LD_INT 5
82983: NEG
82984: PUSH
82985: LD_INT 3
82987: NEG
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 0
82995: PUSH
82996: LD_INT 3
82998: NEG
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: LD_INT 4
83009: NEG
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: PUSH
83015: LD_INT 1
83017: PUSH
83018: LD_INT 3
83020: NEG
83021: PUSH
83022: EMPTY
83023: LIST
83024: LIST
83025: PUSH
83026: LD_INT 1
83028: PUSH
83029: LD_INT 2
83031: NEG
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: LD_INT 0
83039: PUSH
83040: LD_INT 2
83042: NEG
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PUSH
83048: LD_INT 1
83050: NEG
83051: PUSH
83052: LD_INT 3
83054: NEG
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 1
83062: NEG
83063: PUSH
83064: LD_INT 4
83066: NEG
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 2
83074: PUSH
83075: LD_INT 2
83077: NEG
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: PUSH
83083: LD_INT 2
83085: NEG
83086: PUSH
83087: LD_INT 4
83089: NEG
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: PUSH
83095: LD_INT 4
83097: PUSH
83098: LD_INT 0
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: PUSH
83105: LD_INT 4
83107: PUSH
83108: LD_INT 1
83110: NEG
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: PUSH
83116: LD_INT 5
83118: PUSH
83119: LD_INT 0
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: PUSH
83126: LD_INT 5
83128: PUSH
83129: LD_INT 1
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 4
83138: PUSH
83139: LD_INT 1
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 3
83148: PUSH
83149: LD_INT 0
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PUSH
83156: LD_INT 3
83158: PUSH
83159: LD_INT 1
83161: NEG
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PUSH
83167: LD_INT 3
83169: PUSH
83170: LD_INT 2
83172: NEG
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 5
83180: PUSH
83181: LD_INT 2
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: LIST
83195: LIST
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: LIST
83201: LIST
83202: LIST
83203: LIST
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: LIST
83213: LIST
83214: LIST
83215: LIST
83216: LIST
83217: LIST
83218: LIST
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
83235: LD_ADDR_VAR 0 32
83239: PUSH
83240: LD_INT 4
83242: NEG
83243: PUSH
83244: LD_INT 0
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 4
83253: NEG
83254: PUSH
83255: LD_INT 1
83257: NEG
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 3
83265: NEG
83266: PUSH
83267: LD_INT 0
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 3
83276: NEG
83277: PUSH
83278: LD_INT 1
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 4
83287: NEG
83288: PUSH
83289: LD_INT 1
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 5
83298: NEG
83299: PUSH
83300: LD_INT 0
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 5
83309: NEG
83310: PUSH
83311: LD_INT 1
83313: NEG
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 5
83321: NEG
83322: PUSH
83323: LD_INT 2
83325: NEG
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: PUSH
83331: LD_INT 3
83333: NEG
83334: PUSH
83335: LD_INT 2
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 3
83344: NEG
83345: PUSH
83346: LD_INT 3
83348: NEG
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 3
83356: NEG
83357: PUSH
83358: LD_INT 4
83360: NEG
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 2
83368: NEG
83369: PUSH
83370: LD_INT 3
83372: NEG
83373: PUSH
83374: EMPTY
83375: LIST
83376: LIST
83377: PUSH
83378: LD_INT 2
83380: NEG
83381: PUSH
83382: LD_INT 2
83384: NEG
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 3
83392: NEG
83393: PUSH
83394: LD_INT 2
83396: NEG
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 4
83404: NEG
83405: PUSH
83406: LD_INT 3
83408: NEG
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: LD_INT 4
83416: NEG
83417: PUSH
83418: LD_INT 4
83420: NEG
83421: PUSH
83422: EMPTY
83423: LIST
83424: LIST
83425: PUSH
83426: LD_INT 2
83428: NEG
83429: PUSH
83430: LD_INT 4
83432: NEG
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: PUSH
83438: LD_INT 4
83440: NEG
83441: PUSH
83442: LD_INT 2
83444: NEG
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 0
83452: PUSH
83453: LD_INT 4
83455: NEG
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PUSH
83461: LD_INT 0
83463: PUSH
83464: LD_INT 5
83466: NEG
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PUSH
83472: LD_INT 1
83474: PUSH
83475: LD_INT 4
83477: NEG
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: PUSH
83483: LD_INT 1
83485: PUSH
83486: LD_INT 3
83488: NEG
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 0
83496: PUSH
83497: LD_INT 3
83499: NEG
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: PUSH
83505: LD_INT 1
83507: NEG
83508: PUSH
83509: LD_INT 4
83511: NEG
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PUSH
83517: LD_INT 1
83519: NEG
83520: PUSH
83521: LD_INT 5
83523: NEG
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: PUSH
83529: LD_INT 2
83531: PUSH
83532: LD_INT 3
83534: NEG
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: PUSH
83540: LD_INT 2
83542: NEG
83543: PUSH
83544: LD_INT 5
83546: NEG
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 3
83554: PUSH
83555: LD_INT 0
83557: PUSH
83558: EMPTY
83559: LIST
83560: LIST
83561: PUSH
83562: LD_INT 3
83564: PUSH
83565: LD_INT 1
83567: NEG
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 4
83575: PUSH
83576: LD_INT 0
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PUSH
83583: LD_INT 4
83585: PUSH
83586: LD_INT 1
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 3
83595: PUSH
83596: LD_INT 1
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 2
83605: PUSH
83606: LD_INT 0
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: PUSH
83613: LD_INT 2
83615: PUSH
83616: LD_INT 1
83618: NEG
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 2
83626: PUSH
83627: LD_INT 2
83629: NEG
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: PUSH
83635: LD_INT 4
83637: PUSH
83638: LD_INT 2
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: PUSH
83645: LD_INT 4
83647: PUSH
83648: LD_INT 4
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: LD_INT 4
83657: PUSH
83658: LD_INT 3
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 5
83667: PUSH
83668: LD_INT 4
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: LD_INT 5
83677: PUSH
83678: LD_INT 5
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 4
83687: PUSH
83688: LD_INT 5
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: PUSH
83695: LD_INT 3
83697: PUSH
83698: LD_INT 4
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: PUSH
83705: LD_INT 3
83707: PUSH
83708: LD_INT 3
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 5
83717: PUSH
83718: LD_INT 3
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: PUSH
83725: LD_INT 3
83727: PUSH
83728: LD_INT 5
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: LIST
83739: LIST
83740: LIST
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
83782: LD_ADDR_VAR 0 33
83786: PUSH
83787: LD_INT 4
83789: NEG
83790: PUSH
83791: LD_INT 4
83793: NEG
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: LD_INT 4
83801: NEG
83802: PUSH
83803: LD_INT 5
83805: NEG
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: PUSH
83811: LD_INT 3
83813: NEG
83814: PUSH
83815: LD_INT 4
83817: NEG
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: PUSH
83823: LD_INT 3
83825: NEG
83826: PUSH
83827: LD_INT 3
83829: NEG
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 4
83837: NEG
83838: PUSH
83839: LD_INT 3
83841: NEG
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: PUSH
83847: LD_INT 5
83849: NEG
83850: PUSH
83851: LD_INT 4
83853: NEG
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 5
83861: NEG
83862: PUSH
83863: LD_INT 5
83865: NEG
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: LD_INT 3
83873: NEG
83874: PUSH
83875: LD_INT 5
83877: NEG
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 5
83885: NEG
83886: PUSH
83887: LD_INT 3
83889: NEG
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 0
83897: PUSH
83898: LD_INT 3
83900: NEG
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: LD_INT 0
83908: PUSH
83909: LD_INT 4
83911: NEG
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: PUSH
83917: LD_INT 1
83919: PUSH
83920: LD_INT 3
83922: NEG
83923: PUSH
83924: EMPTY
83925: LIST
83926: LIST
83927: PUSH
83928: LD_INT 1
83930: PUSH
83931: LD_INT 2
83933: NEG
83934: PUSH
83935: EMPTY
83936: LIST
83937: LIST
83938: PUSH
83939: LD_INT 0
83941: PUSH
83942: LD_INT 2
83944: NEG
83945: PUSH
83946: EMPTY
83947: LIST
83948: LIST
83949: PUSH
83950: LD_INT 1
83952: NEG
83953: PUSH
83954: LD_INT 3
83956: NEG
83957: PUSH
83958: EMPTY
83959: LIST
83960: LIST
83961: PUSH
83962: LD_INT 1
83964: NEG
83965: PUSH
83966: LD_INT 4
83968: NEG
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 2
83976: PUSH
83977: LD_INT 2
83979: NEG
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: PUSH
83985: LD_INT 2
83987: NEG
83988: PUSH
83989: LD_INT 4
83991: NEG
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PUSH
83997: LD_INT 4
83999: PUSH
84000: LD_INT 0
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: PUSH
84007: LD_INT 4
84009: PUSH
84010: LD_INT 1
84012: NEG
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 5
84020: PUSH
84021: LD_INT 0
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: PUSH
84028: LD_INT 5
84030: PUSH
84031: LD_INT 1
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: PUSH
84038: LD_INT 4
84040: PUSH
84041: LD_INT 1
84043: PUSH
84044: EMPTY
84045: LIST
84046: LIST
84047: PUSH
84048: LD_INT 3
84050: PUSH
84051: LD_INT 0
84053: PUSH
84054: EMPTY
84055: LIST
84056: LIST
84057: PUSH
84058: LD_INT 3
84060: PUSH
84061: LD_INT 1
84063: NEG
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: PUSH
84069: LD_INT 3
84071: PUSH
84072: LD_INT 2
84074: NEG
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 5
84082: PUSH
84083: LD_INT 2
84085: PUSH
84086: EMPTY
84087: LIST
84088: LIST
84089: PUSH
84090: LD_INT 3
84092: PUSH
84093: LD_INT 3
84095: PUSH
84096: EMPTY
84097: LIST
84098: LIST
84099: PUSH
84100: LD_INT 3
84102: PUSH
84103: LD_INT 2
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 4
84112: PUSH
84113: LD_INT 3
84115: PUSH
84116: EMPTY
84117: LIST
84118: LIST
84119: PUSH
84120: LD_INT 4
84122: PUSH
84123: LD_INT 4
84125: PUSH
84126: EMPTY
84127: LIST
84128: LIST
84129: PUSH
84130: LD_INT 3
84132: PUSH
84133: LD_INT 4
84135: PUSH
84136: EMPTY
84137: LIST
84138: LIST
84139: PUSH
84140: LD_INT 2
84142: PUSH
84143: LD_INT 3
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 2
84152: PUSH
84153: LD_INT 2
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PUSH
84160: LD_INT 4
84162: PUSH
84163: LD_INT 2
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: PUSH
84170: LD_INT 2
84172: PUSH
84173: LD_INT 4
84175: PUSH
84176: EMPTY
84177: LIST
84178: LIST
84179: PUSH
84180: LD_INT 0
84182: PUSH
84183: LD_INT 4
84185: PUSH
84186: EMPTY
84187: LIST
84188: LIST
84189: PUSH
84190: LD_INT 0
84192: PUSH
84193: LD_INT 3
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: PUSH
84200: LD_INT 1
84202: PUSH
84203: LD_INT 4
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: PUSH
84210: LD_INT 1
84212: PUSH
84213: LD_INT 5
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: PUSH
84220: LD_INT 0
84222: PUSH
84223: LD_INT 5
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: PUSH
84230: LD_INT 1
84232: NEG
84233: PUSH
84234: LD_INT 4
84236: PUSH
84237: EMPTY
84238: LIST
84239: LIST
84240: PUSH
84241: LD_INT 1
84243: NEG
84244: PUSH
84245: LD_INT 3
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 2
84254: PUSH
84255: LD_INT 5
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 2
84264: NEG
84265: PUSH
84266: LD_INT 3
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
84320: LD_ADDR_VAR 0 34
84324: PUSH
84325: LD_INT 0
84327: PUSH
84328: LD_INT 4
84330: NEG
84331: PUSH
84332: EMPTY
84333: LIST
84334: LIST
84335: PUSH
84336: LD_INT 0
84338: PUSH
84339: LD_INT 5
84341: NEG
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 1
84349: PUSH
84350: LD_INT 4
84352: NEG
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 1
84360: PUSH
84361: LD_INT 3
84363: NEG
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 0
84371: PUSH
84372: LD_INT 3
84374: NEG
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 1
84382: NEG
84383: PUSH
84384: LD_INT 4
84386: NEG
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: PUSH
84392: LD_INT 1
84394: NEG
84395: PUSH
84396: LD_INT 5
84398: NEG
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 2
84406: PUSH
84407: LD_INT 3
84409: NEG
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 2
84417: NEG
84418: PUSH
84419: LD_INT 5
84421: NEG
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: PUSH
84427: LD_INT 3
84429: PUSH
84430: LD_INT 0
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: PUSH
84437: LD_INT 3
84439: PUSH
84440: LD_INT 1
84442: NEG
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: PUSH
84448: LD_INT 4
84450: PUSH
84451: LD_INT 0
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: PUSH
84458: LD_INT 4
84460: PUSH
84461: LD_INT 1
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 3
84470: PUSH
84471: LD_INT 1
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: PUSH
84478: LD_INT 2
84480: PUSH
84481: LD_INT 0
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 2
84490: PUSH
84491: LD_INT 1
84493: NEG
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 2
84501: PUSH
84502: LD_INT 2
84504: NEG
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: PUSH
84510: LD_INT 4
84512: PUSH
84513: LD_INT 2
84515: PUSH
84516: EMPTY
84517: LIST
84518: LIST
84519: PUSH
84520: LD_INT 4
84522: PUSH
84523: LD_INT 4
84525: PUSH
84526: EMPTY
84527: LIST
84528: LIST
84529: PUSH
84530: LD_INT 4
84532: PUSH
84533: LD_INT 3
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 5
84542: PUSH
84543: LD_INT 4
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 5
84552: PUSH
84553: LD_INT 5
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: PUSH
84560: LD_INT 4
84562: PUSH
84563: LD_INT 5
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: PUSH
84570: LD_INT 3
84572: PUSH
84573: LD_INT 4
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PUSH
84580: LD_INT 3
84582: PUSH
84583: LD_INT 3
84585: PUSH
84586: EMPTY
84587: LIST
84588: LIST
84589: PUSH
84590: LD_INT 5
84592: PUSH
84593: LD_INT 3
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: PUSH
84600: LD_INT 3
84602: PUSH
84603: LD_INT 5
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: PUSH
84610: LD_INT 0
84612: PUSH
84613: LD_INT 3
84615: PUSH
84616: EMPTY
84617: LIST
84618: LIST
84619: PUSH
84620: LD_INT 0
84622: PUSH
84623: LD_INT 2
84625: PUSH
84626: EMPTY
84627: LIST
84628: LIST
84629: PUSH
84630: LD_INT 1
84632: PUSH
84633: LD_INT 3
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: PUSH
84640: LD_INT 1
84642: PUSH
84643: LD_INT 4
84645: PUSH
84646: EMPTY
84647: LIST
84648: LIST
84649: PUSH
84650: LD_INT 0
84652: PUSH
84653: LD_INT 4
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: PUSH
84660: LD_INT 1
84662: NEG
84663: PUSH
84664: LD_INT 3
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 1
84673: NEG
84674: PUSH
84675: LD_INT 2
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: PUSH
84682: LD_INT 2
84684: PUSH
84685: LD_INT 4
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 2
84694: NEG
84695: PUSH
84696: LD_INT 2
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 4
84705: NEG
84706: PUSH
84707: LD_INT 0
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 4
84716: NEG
84717: PUSH
84718: LD_INT 1
84720: NEG
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: LD_INT 3
84728: NEG
84729: PUSH
84730: LD_INT 0
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: PUSH
84737: LD_INT 3
84739: NEG
84740: PUSH
84741: LD_INT 1
84743: PUSH
84744: EMPTY
84745: LIST
84746: LIST
84747: PUSH
84748: LD_INT 4
84750: NEG
84751: PUSH
84752: LD_INT 1
84754: PUSH
84755: EMPTY
84756: LIST
84757: LIST
84758: PUSH
84759: LD_INT 5
84761: NEG
84762: PUSH
84763: LD_INT 0
84765: PUSH
84766: EMPTY
84767: LIST
84768: LIST
84769: PUSH
84770: LD_INT 5
84772: NEG
84773: PUSH
84774: LD_INT 1
84776: NEG
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: LD_INT 5
84784: NEG
84785: PUSH
84786: LD_INT 2
84788: NEG
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PUSH
84794: LD_INT 3
84796: NEG
84797: PUSH
84798: LD_INT 2
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: LIST
84809: LIST
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: LIST
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: ST_TO_ADDR
// end ; end ;
84852: GO 84855
84854: POP
// case btype of b_depot , b_warehouse :
84855: LD_VAR 0 1
84859: PUSH
84860: LD_INT 0
84862: DOUBLE
84863: EQUAL
84864: IFTRUE 84874
84866: LD_INT 1
84868: DOUBLE
84869: EQUAL
84870: IFTRUE 84874
84872: GO 85075
84874: POP
// case nation of nation_american :
84875: LD_VAR 0 5
84879: PUSH
84880: LD_INT 1
84882: DOUBLE
84883: EQUAL
84884: IFTRUE 84888
84886: GO 84944
84888: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
84889: LD_ADDR_VAR 0 9
84893: PUSH
84894: LD_VAR 0 11
84898: PUSH
84899: LD_VAR 0 12
84903: PUSH
84904: LD_VAR 0 13
84908: PUSH
84909: LD_VAR 0 14
84913: PUSH
84914: LD_VAR 0 15
84918: PUSH
84919: LD_VAR 0 16
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: PUSH
84932: LD_VAR 0 4
84936: PUSH
84937: LD_INT 1
84939: PLUS
84940: ARRAY
84941: ST_TO_ADDR
84942: GO 85073
84944: LD_INT 2
84946: DOUBLE
84947: EQUAL
84948: IFTRUE 84952
84950: GO 85008
84952: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
84953: LD_ADDR_VAR 0 9
84957: PUSH
84958: LD_VAR 0 17
84962: PUSH
84963: LD_VAR 0 18
84967: PUSH
84968: LD_VAR 0 19
84972: PUSH
84973: LD_VAR 0 20
84977: PUSH
84978: LD_VAR 0 21
84982: PUSH
84983: LD_VAR 0 22
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: LIST
84994: LIST
84995: PUSH
84996: LD_VAR 0 4
85000: PUSH
85001: LD_INT 1
85003: PLUS
85004: ARRAY
85005: ST_TO_ADDR
85006: GO 85073
85008: LD_INT 3
85010: DOUBLE
85011: EQUAL
85012: IFTRUE 85016
85014: GO 85072
85016: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
85017: LD_ADDR_VAR 0 9
85021: PUSH
85022: LD_VAR 0 23
85026: PUSH
85027: LD_VAR 0 24
85031: PUSH
85032: LD_VAR 0 25
85036: PUSH
85037: LD_VAR 0 26
85041: PUSH
85042: LD_VAR 0 27
85046: PUSH
85047: LD_VAR 0 28
85051: PUSH
85052: EMPTY
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: PUSH
85060: LD_VAR 0 4
85064: PUSH
85065: LD_INT 1
85067: PLUS
85068: ARRAY
85069: ST_TO_ADDR
85070: GO 85073
85072: POP
85073: GO 85628
85075: LD_INT 2
85077: DOUBLE
85078: EQUAL
85079: IFTRUE 85089
85081: LD_INT 3
85083: DOUBLE
85084: EQUAL
85085: IFTRUE 85089
85087: GO 85145
85089: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
85090: LD_ADDR_VAR 0 9
85094: PUSH
85095: LD_VAR 0 29
85099: PUSH
85100: LD_VAR 0 30
85104: PUSH
85105: LD_VAR 0 31
85109: PUSH
85110: LD_VAR 0 32
85114: PUSH
85115: LD_VAR 0 33
85119: PUSH
85120: LD_VAR 0 34
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: PUSH
85133: LD_VAR 0 4
85137: PUSH
85138: LD_INT 1
85140: PLUS
85141: ARRAY
85142: ST_TO_ADDR
85143: GO 85628
85145: LD_INT 16
85147: DOUBLE
85148: EQUAL
85149: IFTRUE 85207
85151: LD_INT 17
85153: DOUBLE
85154: EQUAL
85155: IFTRUE 85207
85157: LD_INT 18
85159: DOUBLE
85160: EQUAL
85161: IFTRUE 85207
85163: LD_INT 19
85165: DOUBLE
85166: EQUAL
85167: IFTRUE 85207
85169: LD_INT 22
85171: DOUBLE
85172: EQUAL
85173: IFTRUE 85207
85175: LD_INT 20
85177: DOUBLE
85178: EQUAL
85179: IFTRUE 85207
85181: LD_INT 21
85183: DOUBLE
85184: EQUAL
85185: IFTRUE 85207
85187: LD_INT 23
85189: DOUBLE
85190: EQUAL
85191: IFTRUE 85207
85193: LD_INT 24
85195: DOUBLE
85196: EQUAL
85197: IFTRUE 85207
85199: LD_INT 25
85201: DOUBLE
85202: EQUAL
85203: IFTRUE 85207
85205: GO 85263
85207: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
85208: LD_ADDR_VAR 0 9
85212: PUSH
85213: LD_VAR 0 35
85217: PUSH
85218: LD_VAR 0 36
85222: PUSH
85223: LD_VAR 0 37
85227: PUSH
85228: LD_VAR 0 38
85232: PUSH
85233: LD_VAR 0 39
85237: PUSH
85238: LD_VAR 0 40
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: LIST
85247: LIST
85248: LIST
85249: LIST
85250: PUSH
85251: LD_VAR 0 4
85255: PUSH
85256: LD_INT 1
85258: PLUS
85259: ARRAY
85260: ST_TO_ADDR
85261: GO 85628
85263: LD_INT 6
85265: DOUBLE
85266: EQUAL
85267: IFTRUE 85319
85269: LD_INT 7
85271: DOUBLE
85272: EQUAL
85273: IFTRUE 85319
85275: LD_INT 8
85277: DOUBLE
85278: EQUAL
85279: IFTRUE 85319
85281: LD_INT 13
85283: DOUBLE
85284: EQUAL
85285: IFTRUE 85319
85287: LD_INT 12
85289: DOUBLE
85290: EQUAL
85291: IFTRUE 85319
85293: LD_INT 15
85295: DOUBLE
85296: EQUAL
85297: IFTRUE 85319
85299: LD_INT 11
85301: DOUBLE
85302: EQUAL
85303: IFTRUE 85319
85305: LD_INT 14
85307: DOUBLE
85308: EQUAL
85309: IFTRUE 85319
85311: LD_INT 10
85313: DOUBLE
85314: EQUAL
85315: IFTRUE 85319
85317: GO 85375
85319: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
85320: LD_ADDR_VAR 0 9
85324: PUSH
85325: LD_VAR 0 41
85329: PUSH
85330: LD_VAR 0 42
85334: PUSH
85335: LD_VAR 0 43
85339: PUSH
85340: LD_VAR 0 44
85344: PUSH
85345: LD_VAR 0 45
85349: PUSH
85350: LD_VAR 0 46
85354: PUSH
85355: EMPTY
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: LIST
85362: PUSH
85363: LD_VAR 0 4
85367: PUSH
85368: LD_INT 1
85370: PLUS
85371: ARRAY
85372: ST_TO_ADDR
85373: GO 85628
85375: LD_INT 36
85377: DOUBLE
85378: EQUAL
85379: IFTRUE 85383
85381: GO 85439
85383: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
85384: LD_ADDR_VAR 0 9
85388: PUSH
85389: LD_VAR 0 47
85393: PUSH
85394: LD_VAR 0 48
85398: PUSH
85399: LD_VAR 0 49
85403: PUSH
85404: LD_VAR 0 50
85408: PUSH
85409: LD_VAR 0 51
85413: PUSH
85414: LD_VAR 0 52
85418: PUSH
85419: EMPTY
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: PUSH
85427: LD_VAR 0 4
85431: PUSH
85432: LD_INT 1
85434: PLUS
85435: ARRAY
85436: ST_TO_ADDR
85437: GO 85628
85439: LD_INT 4
85441: DOUBLE
85442: EQUAL
85443: IFTRUE 85465
85445: LD_INT 5
85447: DOUBLE
85448: EQUAL
85449: IFTRUE 85465
85451: LD_INT 34
85453: DOUBLE
85454: EQUAL
85455: IFTRUE 85465
85457: LD_INT 37
85459: DOUBLE
85460: EQUAL
85461: IFTRUE 85465
85463: GO 85521
85465: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
85466: LD_ADDR_VAR 0 9
85470: PUSH
85471: LD_VAR 0 53
85475: PUSH
85476: LD_VAR 0 54
85480: PUSH
85481: LD_VAR 0 55
85485: PUSH
85486: LD_VAR 0 56
85490: PUSH
85491: LD_VAR 0 57
85495: PUSH
85496: LD_VAR 0 58
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: PUSH
85509: LD_VAR 0 4
85513: PUSH
85514: LD_INT 1
85516: PLUS
85517: ARRAY
85518: ST_TO_ADDR
85519: GO 85628
85521: LD_INT 31
85523: DOUBLE
85524: EQUAL
85525: IFTRUE 85571
85527: LD_INT 32
85529: DOUBLE
85530: EQUAL
85531: IFTRUE 85571
85533: LD_INT 33
85535: DOUBLE
85536: EQUAL
85537: IFTRUE 85571
85539: LD_INT 27
85541: DOUBLE
85542: EQUAL
85543: IFTRUE 85571
85545: LD_INT 26
85547: DOUBLE
85548: EQUAL
85549: IFTRUE 85571
85551: LD_INT 28
85553: DOUBLE
85554: EQUAL
85555: IFTRUE 85571
85557: LD_INT 29
85559: DOUBLE
85560: EQUAL
85561: IFTRUE 85571
85563: LD_INT 30
85565: DOUBLE
85566: EQUAL
85567: IFTRUE 85571
85569: GO 85627
85571: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
85572: LD_ADDR_VAR 0 9
85576: PUSH
85577: LD_VAR 0 59
85581: PUSH
85582: LD_VAR 0 60
85586: PUSH
85587: LD_VAR 0 61
85591: PUSH
85592: LD_VAR 0 62
85596: PUSH
85597: LD_VAR 0 63
85601: PUSH
85602: LD_VAR 0 64
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: PUSH
85615: LD_VAR 0 4
85619: PUSH
85620: LD_INT 1
85622: PLUS
85623: ARRAY
85624: ST_TO_ADDR
85625: GO 85628
85627: POP
// temp_list2 = [ ] ;
85628: LD_ADDR_VAR 0 10
85632: PUSH
85633: EMPTY
85634: ST_TO_ADDR
// for i in temp_list do
85635: LD_ADDR_VAR 0 8
85639: PUSH
85640: LD_VAR 0 9
85644: PUSH
85645: FOR_IN
85646: IFFALSE 85698
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
85648: LD_ADDR_VAR 0 10
85652: PUSH
85653: LD_VAR 0 10
85657: PUSH
85658: LD_VAR 0 8
85662: PUSH
85663: LD_INT 1
85665: ARRAY
85666: PUSH
85667: LD_VAR 0 2
85671: PLUS
85672: PUSH
85673: LD_VAR 0 8
85677: PUSH
85678: LD_INT 2
85680: ARRAY
85681: PUSH
85682: LD_VAR 0 3
85686: PLUS
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: PUSH
85692: EMPTY
85693: LIST
85694: ADD
85695: ST_TO_ADDR
85696: GO 85645
85698: POP
85699: POP
// result = temp_list2 ;
85700: LD_ADDR_VAR 0 7
85704: PUSH
85705: LD_VAR 0 10
85709: ST_TO_ADDR
// end ;
85710: LD_VAR 0 7
85714: RET
// export function EnemyInRange ( unit , dist ) ; begin
85715: LD_INT 0
85717: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
85718: LD_ADDR_VAR 0 3
85722: PUSH
85723: LD_VAR 0 1
85727: PPUSH
85728: CALL_OW 255
85732: PPUSH
85733: LD_VAR 0 1
85737: PPUSH
85738: CALL_OW 250
85742: PPUSH
85743: LD_VAR 0 1
85747: PPUSH
85748: CALL_OW 251
85752: PPUSH
85753: LD_VAR 0 2
85757: PPUSH
85758: CALL 59088 0 4
85762: PUSH
85763: LD_INT 4
85765: ARRAY
85766: ST_TO_ADDR
// end ;
85767: LD_VAR 0 3
85771: RET
// export function PlayerSeeMe ( unit ) ; begin
85772: LD_INT 0
85774: PPUSH
// result := See ( your_side , unit ) ;
85775: LD_ADDR_VAR 0 2
85779: PUSH
85780: LD_OWVAR 2
85784: PPUSH
85785: LD_VAR 0 1
85789: PPUSH
85790: CALL_OW 292
85794: ST_TO_ADDR
// end ;
85795: LD_VAR 0 2
85799: RET
// export function ReverseDir ( unit ) ; begin
85800: LD_INT 0
85802: PPUSH
// if not unit then
85803: LD_VAR 0 1
85807: NOT
85808: IFFALSE 85812
// exit ;
85810: GO 85835
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
85812: LD_ADDR_VAR 0 2
85816: PUSH
85817: LD_VAR 0 1
85821: PPUSH
85822: CALL_OW 254
85826: PUSH
85827: LD_INT 3
85829: PLUS
85830: PUSH
85831: LD_INT 6
85833: MOD
85834: ST_TO_ADDR
// end ;
85835: LD_VAR 0 2
85839: RET
// export function ReverseArray ( array ) ; var i ; begin
85840: LD_INT 0
85842: PPUSH
85843: PPUSH
// if not array then
85844: LD_VAR 0 1
85848: NOT
85849: IFFALSE 85853
// exit ;
85851: GO 85908
// result := [ ] ;
85853: LD_ADDR_VAR 0 2
85857: PUSH
85858: EMPTY
85859: ST_TO_ADDR
// for i := array downto 1 do
85860: LD_ADDR_VAR 0 3
85864: PUSH
85865: DOUBLE
85866: LD_VAR 0 1
85870: INC
85871: ST_TO_ADDR
85872: LD_INT 1
85874: PUSH
85875: FOR_DOWNTO
85876: IFFALSE 85906
// result := Join ( result , array [ i ] ) ;
85878: LD_ADDR_VAR 0 2
85882: PUSH
85883: LD_VAR 0 2
85887: PPUSH
85888: LD_VAR 0 1
85892: PUSH
85893: LD_VAR 0 3
85897: ARRAY
85898: PPUSH
85899: CALL 90564 0 2
85903: ST_TO_ADDR
85904: GO 85875
85906: POP
85907: POP
// end ;
85908: LD_VAR 0 2
85912: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
85913: LD_INT 0
85915: PPUSH
85916: PPUSH
85917: PPUSH
85918: PPUSH
85919: PPUSH
85920: PPUSH
// if not unit or not hexes then
85921: LD_VAR 0 1
85925: NOT
85926: PUSH
85927: LD_VAR 0 2
85931: NOT
85932: OR
85933: IFFALSE 85937
// exit ;
85935: GO 86060
// dist := 9999 ;
85937: LD_ADDR_VAR 0 5
85941: PUSH
85942: LD_INT 9999
85944: ST_TO_ADDR
// for i = 1 to hexes do
85945: LD_ADDR_VAR 0 4
85949: PUSH
85950: DOUBLE
85951: LD_INT 1
85953: DEC
85954: ST_TO_ADDR
85955: LD_VAR 0 2
85959: PUSH
85960: FOR_TO
85961: IFFALSE 86048
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
85963: LD_ADDR_VAR 0 6
85967: PUSH
85968: LD_VAR 0 1
85972: PPUSH
85973: LD_VAR 0 2
85977: PUSH
85978: LD_VAR 0 4
85982: ARRAY
85983: PUSH
85984: LD_INT 1
85986: ARRAY
85987: PPUSH
85988: LD_VAR 0 2
85992: PUSH
85993: LD_VAR 0 4
85997: ARRAY
85998: PUSH
85999: LD_INT 2
86001: ARRAY
86002: PPUSH
86003: CALL_OW 297
86007: ST_TO_ADDR
// if tdist < dist then
86008: LD_VAR 0 6
86012: PUSH
86013: LD_VAR 0 5
86017: LESS
86018: IFFALSE 86046
// begin hex := hexes [ i ] ;
86020: LD_ADDR_VAR 0 8
86024: PUSH
86025: LD_VAR 0 2
86029: PUSH
86030: LD_VAR 0 4
86034: ARRAY
86035: ST_TO_ADDR
// dist := tdist ;
86036: LD_ADDR_VAR 0 5
86040: PUSH
86041: LD_VAR 0 6
86045: ST_TO_ADDR
// end ; end ;
86046: GO 85960
86048: POP
86049: POP
// result := hex ;
86050: LD_ADDR_VAR 0 3
86054: PUSH
86055: LD_VAR 0 8
86059: ST_TO_ADDR
// end ;
86060: LD_VAR 0 3
86064: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
86065: LD_INT 0
86067: PPUSH
86068: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86069: LD_VAR 0 1
86073: NOT
86074: PUSH
86075: LD_VAR 0 1
86079: PUSH
86080: LD_INT 21
86082: PUSH
86083: LD_INT 2
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: PUSH
86090: LD_INT 23
86092: PUSH
86093: LD_INT 2
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: EMPTY
86101: LIST
86102: LIST
86103: PPUSH
86104: CALL_OW 69
86108: IN
86109: NOT
86110: OR
86111: IFFALSE 86115
// exit ;
86113: GO 86162
// for i = 1 to 3 do
86115: LD_ADDR_VAR 0 3
86119: PUSH
86120: DOUBLE
86121: LD_INT 1
86123: DEC
86124: ST_TO_ADDR
86125: LD_INT 3
86127: PUSH
86128: FOR_TO
86129: IFFALSE 86160
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
86131: LD_VAR 0 1
86135: PPUSH
86136: CALL_OW 250
86140: PPUSH
86141: LD_VAR 0 1
86145: PPUSH
86146: CALL_OW 251
86150: PPUSH
86151: LD_INT 1
86153: PPUSH
86154: CALL_OW 453
86158: GO 86128
86160: POP
86161: POP
// end ;
86162: LD_VAR 0 2
86166: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
86167: LD_INT 0
86169: PPUSH
86170: PPUSH
86171: PPUSH
86172: PPUSH
86173: PPUSH
86174: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
86175: LD_VAR 0 1
86179: NOT
86180: PUSH
86181: LD_VAR 0 2
86185: NOT
86186: OR
86187: PUSH
86188: LD_VAR 0 1
86192: PPUSH
86193: CALL_OW 314
86197: OR
86198: IFFALSE 86202
// exit ;
86200: GO 86669
// if GetLives ( i ) < 250 then
86202: LD_VAR 0 4
86206: PPUSH
86207: CALL_OW 256
86211: PUSH
86212: LD_INT 250
86214: LESS
86215: IFFALSE 86228
// begin ComAutodestruct ( i ) ;
86217: LD_VAR 0 4
86221: PPUSH
86222: CALL 86065 0 1
// exit ;
86226: GO 86669
// end ; x := GetX ( enemy_unit ) ;
86228: LD_ADDR_VAR 0 7
86232: PUSH
86233: LD_VAR 0 2
86237: PPUSH
86238: CALL_OW 250
86242: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
86243: LD_ADDR_VAR 0 8
86247: PUSH
86248: LD_VAR 0 2
86252: PPUSH
86253: CALL_OW 251
86257: ST_TO_ADDR
// if not x or not y then
86258: LD_VAR 0 7
86262: NOT
86263: PUSH
86264: LD_VAR 0 8
86268: NOT
86269: OR
86270: IFFALSE 86274
// exit ;
86272: GO 86669
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
86274: LD_ADDR_VAR 0 6
86278: PUSH
86279: LD_VAR 0 7
86283: PPUSH
86284: LD_INT 0
86286: PPUSH
86287: LD_INT 4
86289: PPUSH
86290: CALL_OW 272
86294: PUSH
86295: LD_VAR 0 8
86299: PPUSH
86300: LD_INT 0
86302: PPUSH
86303: LD_INT 4
86305: PPUSH
86306: CALL_OW 273
86310: PUSH
86311: EMPTY
86312: LIST
86313: LIST
86314: PUSH
86315: LD_VAR 0 7
86319: PPUSH
86320: LD_INT 1
86322: PPUSH
86323: LD_INT 4
86325: PPUSH
86326: CALL_OW 272
86330: PUSH
86331: LD_VAR 0 8
86335: PPUSH
86336: LD_INT 1
86338: PPUSH
86339: LD_INT 4
86341: PPUSH
86342: CALL_OW 273
86346: PUSH
86347: EMPTY
86348: LIST
86349: LIST
86350: PUSH
86351: LD_VAR 0 7
86355: PPUSH
86356: LD_INT 2
86358: PPUSH
86359: LD_INT 4
86361: PPUSH
86362: CALL_OW 272
86366: PUSH
86367: LD_VAR 0 8
86371: PPUSH
86372: LD_INT 2
86374: PPUSH
86375: LD_INT 4
86377: PPUSH
86378: CALL_OW 273
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_VAR 0 7
86391: PPUSH
86392: LD_INT 3
86394: PPUSH
86395: LD_INT 4
86397: PPUSH
86398: CALL_OW 272
86402: PUSH
86403: LD_VAR 0 8
86407: PPUSH
86408: LD_INT 3
86410: PPUSH
86411: LD_INT 4
86413: PPUSH
86414: CALL_OW 273
86418: PUSH
86419: EMPTY
86420: LIST
86421: LIST
86422: PUSH
86423: LD_VAR 0 7
86427: PPUSH
86428: LD_INT 4
86430: PPUSH
86431: LD_INT 4
86433: PPUSH
86434: CALL_OW 272
86438: PUSH
86439: LD_VAR 0 8
86443: PPUSH
86444: LD_INT 4
86446: PPUSH
86447: LD_INT 4
86449: PPUSH
86450: CALL_OW 273
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PUSH
86459: LD_VAR 0 7
86463: PPUSH
86464: LD_INT 5
86466: PPUSH
86467: LD_INT 4
86469: PPUSH
86470: CALL_OW 272
86474: PUSH
86475: LD_VAR 0 8
86479: PPUSH
86480: LD_INT 5
86482: PPUSH
86483: LD_INT 4
86485: PPUSH
86486: CALL_OW 273
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: LIST
86501: LIST
86502: ST_TO_ADDR
// for i = tmp downto 1 do
86503: LD_ADDR_VAR 0 4
86507: PUSH
86508: DOUBLE
86509: LD_VAR 0 6
86513: INC
86514: ST_TO_ADDR
86515: LD_INT 1
86517: PUSH
86518: FOR_DOWNTO
86519: IFFALSE 86620
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
86521: LD_VAR 0 6
86525: PUSH
86526: LD_VAR 0 4
86530: ARRAY
86531: PUSH
86532: LD_INT 1
86534: ARRAY
86535: PPUSH
86536: LD_VAR 0 6
86540: PUSH
86541: LD_VAR 0 4
86545: ARRAY
86546: PUSH
86547: LD_INT 2
86549: ARRAY
86550: PPUSH
86551: CALL_OW 488
86555: NOT
86556: PUSH
86557: LD_VAR 0 6
86561: PUSH
86562: LD_VAR 0 4
86566: ARRAY
86567: PUSH
86568: LD_INT 1
86570: ARRAY
86571: PPUSH
86572: LD_VAR 0 6
86576: PUSH
86577: LD_VAR 0 4
86581: ARRAY
86582: PUSH
86583: LD_INT 2
86585: ARRAY
86586: PPUSH
86587: CALL_OW 428
86591: PUSH
86592: LD_INT 0
86594: NONEQUAL
86595: OR
86596: IFFALSE 86618
// tmp := Delete ( tmp , i ) ;
86598: LD_ADDR_VAR 0 6
86602: PUSH
86603: LD_VAR 0 6
86607: PPUSH
86608: LD_VAR 0 4
86612: PPUSH
86613: CALL_OW 3
86617: ST_TO_ADDR
86618: GO 86518
86620: POP
86621: POP
// j := GetClosestHex ( unit , tmp ) ;
86622: LD_ADDR_VAR 0 5
86626: PUSH
86627: LD_VAR 0 1
86631: PPUSH
86632: LD_VAR 0 6
86636: PPUSH
86637: CALL 85913 0 2
86641: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
86642: LD_VAR 0 1
86646: PPUSH
86647: LD_VAR 0 5
86651: PUSH
86652: LD_INT 1
86654: ARRAY
86655: PPUSH
86656: LD_VAR 0 5
86660: PUSH
86661: LD_INT 2
86663: ARRAY
86664: PPUSH
86665: CALL_OW 111
// end ;
86669: LD_VAR 0 3
86673: RET
// export function PrepareApemanSoldier ( ) ; begin
86674: LD_INT 0
86676: PPUSH
// uc_nation := 0 ;
86677: LD_ADDR_OWVAR 21
86681: PUSH
86682: LD_INT 0
86684: ST_TO_ADDR
// hc_sex := sex_male ;
86685: LD_ADDR_OWVAR 27
86689: PUSH
86690: LD_INT 1
86692: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
86693: LD_ADDR_OWVAR 28
86697: PUSH
86698: LD_INT 15
86700: ST_TO_ADDR
// hc_gallery :=  ;
86701: LD_ADDR_OWVAR 33
86705: PUSH
86706: LD_STRING 
86708: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86709: LD_ADDR_OWVAR 31
86713: PUSH
86714: LD_INT 0
86716: PPUSH
86717: LD_INT 3
86719: PPUSH
86720: CALL_OW 12
86724: PUSH
86725: LD_INT 0
86727: PPUSH
86728: LD_INT 3
86730: PPUSH
86731: CALL_OW 12
86735: PUSH
86736: LD_INT 0
86738: PUSH
86739: LD_INT 0
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: LIST
86746: LIST
86747: ST_TO_ADDR
// end ;
86748: LD_VAR 0 1
86752: RET
// export function PrepareApemanEngineer ( ) ; begin
86753: LD_INT 0
86755: PPUSH
// uc_nation := 0 ;
86756: LD_ADDR_OWVAR 21
86760: PUSH
86761: LD_INT 0
86763: ST_TO_ADDR
// hc_sex := sex_male ;
86764: LD_ADDR_OWVAR 27
86768: PUSH
86769: LD_INT 1
86771: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
86772: LD_ADDR_OWVAR 28
86776: PUSH
86777: LD_INT 16
86779: ST_TO_ADDR
// hc_gallery :=  ;
86780: LD_ADDR_OWVAR 33
86784: PUSH
86785: LD_STRING 
86787: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86788: LD_ADDR_OWVAR 31
86792: PUSH
86793: LD_INT 0
86795: PPUSH
86796: LD_INT 3
86798: PPUSH
86799: CALL_OW 12
86803: PUSH
86804: LD_INT 0
86806: PPUSH
86807: LD_INT 3
86809: PPUSH
86810: CALL_OW 12
86814: PUSH
86815: LD_INT 0
86817: PUSH
86818: LD_INT 0
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: LIST
86825: LIST
86826: ST_TO_ADDR
// end ;
86827: LD_VAR 0 1
86831: RET
// export function PrepareApeman ( agressivity ) ; begin
86832: LD_INT 0
86834: PPUSH
// uc_side := 0 ;
86835: LD_ADDR_OWVAR 20
86839: PUSH
86840: LD_INT 0
86842: ST_TO_ADDR
// uc_nation := 0 ;
86843: LD_ADDR_OWVAR 21
86847: PUSH
86848: LD_INT 0
86850: ST_TO_ADDR
// hc_sex := sex_male ;
86851: LD_ADDR_OWVAR 27
86855: PUSH
86856: LD_INT 1
86858: ST_TO_ADDR
// hc_class := class_apeman ;
86859: LD_ADDR_OWVAR 28
86863: PUSH
86864: LD_INT 12
86866: ST_TO_ADDR
// hc_gallery :=  ;
86867: LD_ADDR_OWVAR 33
86871: PUSH
86872: LD_STRING 
86874: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
86875: LD_ADDR_OWVAR 35
86879: PUSH
86880: LD_VAR 0 1
86884: NEG
86885: PPUSH
86886: LD_VAR 0 1
86890: PPUSH
86891: CALL_OW 12
86895: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86896: LD_ADDR_OWVAR 31
86900: PUSH
86901: LD_INT 0
86903: PPUSH
86904: LD_INT 3
86906: PPUSH
86907: CALL_OW 12
86911: PUSH
86912: LD_INT 0
86914: PPUSH
86915: LD_INT 3
86917: PPUSH
86918: CALL_OW 12
86922: PUSH
86923: LD_INT 0
86925: PUSH
86926: LD_INT 0
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: ST_TO_ADDR
// end ;
86935: LD_VAR 0 2
86939: RET
// export function PrepareTiger ( agressivity ) ; begin
86940: LD_INT 0
86942: PPUSH
// uc_side := 0 ;
86943: LD_ADDR_OWVAR 20
86947: PUSH
86948: LD_INT 0
86950: ST_TO_ADDR
// uc_nation := 0 ;
86951: LD_ADDR_OWVAR 21
86955: PUSH
86956: LD_INT 0
86958: ST_TO_ADDR
// hc_class := class_tiger ;
86959: LD_ADDR_OWVAR 28
86963: PUSH
86964: LD_INT 14
86966: ST_TO_ADDR
// hc_gallery :=  ;
86967: LD_ADDR_OWVAR 33
86971: PUSH
86972: LD_STRING 
86974: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
86975: LD_ADDR_OWVAR 35
86979: PUSH
86980: LD_VAR 0 1
86984: NEG
86985: PPUSH
86986: LD_VAR 0 1
86990: PPUSH
86991: CALL_OW 12
86995: ST_TO_ADDR
// end ;
86996: LD_VAR 0 2
87000: RET
// export function PrepareEnchidna ( ) ; begin
87001: LD_INT 0
87003: PPUSH
// uc_side := 0 ;
87004: LD_ADDR_OWVAR 20
87008: PUSH
87009: LD_INT 0
87011: ST_TO_ADDR
// uc_nation := 0 ;
87012: LD_ADDR_OWVAR 21
87016: PUSH
87017: LD_INT 0
87019: ST_TO_ADDR
// hc_class := class_baggie ;
87020: LD_ADDR_OWVAR 28
87024: PUSH
87025: LD_INT 13
87027: ST_TO_ADDR
// hc_gallery :=  ;
87028: LD_ADDR_OWVAR 33
87032: PUSH
87033: LD_STRING 
87035: ST_TO_ADDR
// end ;
87036: LD_VAR 0 1
87040: RET
// export function PrepareFrog ( ) ; begin
87041: LD_INT 0
87043: PPUSH
// uc_side := 0 ;
87044: LD_ADDR_OWVAR 20
87048: PUSH
87049: LD_INT 0
87051: ST_TO_ADDR
// uc_nation := 0 ;
87052: LD_ADDR_OWVAR 21
87056: PUSH
87057: LD_INT 0
87059: ST_TO_ADDR
// hc_class := class_frog ;
87060: LD_ADDR_OWVAR 28
87064: PUSH
87065: LD_INT 19
87067: ST_TO_ADDR
// hc_gallery :=  ;
87068: LD_ADDR_OWVAR 33
87072: PUSH
87073: LD_STRING 
87075: ST_TO_ADDR
// end ;
87076: LD_VAR 0 1
87080: RET
// export function PrepareFish ( ) ; begin
87081: LD_INT 0
87083: PPUSH
// uc_side := 0 ;
87084: LD_ADDR_OWVAR 20
87088: PUSH
87089: LD_INT 0
87091: ST_TO_ADDR
// uc_nation := 0 ;
87092: LD_ADDR_OWVAR 21
87096: PUSH
87097: LD_INT 0
87099: ST_TO_ADDR
// hc_class := class_fish ;
87100: LD_ADDR_OWVAR 28
87104: PUSH
87105: LD_INT 20
87107: ST_TO_ADDR
// hc_gallery :=  ;
87108: LD_ADDR_OWVAR 33
87112: PUSH
87113: LD_STRING 
87115: ST_TO_ADDR
// end ;
87116: LD_VAR 0 1
87120: RET
// export function PrepareBird ( ) ; begin
87121: LD_INT 0
87123: PPUSH
// uc_side := 0 ;
87124: LD_ADDR_OWVAR 20
87128: PUSH
87129: LD_INT 0
87131: ST_TO_ADDR
// uc_nation := 0 ;
87132: LD_ADDR_OWVAR 21
87136: PUSH
87137: LD_INT 0
87139: ST_TO_ADDR
// hc_class := class_phororhacos ;
87140: LD_ADDR_OWVAR 28
87144: PUSH
87145: LD_INT 18
87147: ST_TO_ADDR
// hc_gallery :=  ;
87148: LD_ADDR_OWVAR 33
87152: PUSH
87153: LD_STRING 
87155: ST_TO_ADDR
// end ;
87156: LD_VAR 0 1
87160: RET
// export function PrepareHorse ( ) ; begin
87161: LD_INT 0
87163: PPUSH
// uc_side := 0 ;
87164: LD_ADDR_OWVAR 20
87168: PUSH
87169: LD_INT 0
87171: ST_TO_ADDR
// uc_nation := 0 ;
87172: LD_ADDR_OWVAR 21
87176: PUSH
87177: LD_INT 0
87179: ST_TO_ADDR
// hc_class := class_horse ;
87180: LD_ADDR_OWVAR 28
87184: PUSH
87185: LD_INT 21
87187: ST_TO_ADDR
// hc_gallery :=  ;
87188: LD_ADDR_OWVAR 33
87192: PUSH
87193: LD_STRING 
87195: ST_TO_ADDR
// end ;
87196: LD_VAR 0 1
87200: RET
// export function PrepareMastodont ( ) ; begin
87201: LD_INT 0
87203: PPUSH
// uc_side := 0 ;
87204: LD_ADDR_OWVAR 20
87208: PUSH
87209: LD_INT 0
87211: ST_TO_ADDR
// uc_nation := 0 ;
87212: LD_ADDR_OWVAR 21
87216: PUSH
87217: LD_INT 0
87219: ST_TO_ADDR
// vc_chassis := class_mastodont ;
87220: LD_ADDR_OWVAR 37
87224: PUSH
87225: LD_INT 31
87227: ST_TO_ADDR
// vc_control := control_rider ;
87228: LD_ADDR_OWVAR 38
87232: PUSH
87233: LD_INT 4
87235: ST_TO_ADDR
// end ;
87236: LD_VAR 0 1
87240: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
87241: LD_INT 0
87243: PPUSH
87244: PPUSH
87245: PPUSH
// uc_side = 0 ;
87246: LD_ADDR_OWVAR 20
87250: PUSH
87251: LD_INT 0
87253: ST_TO_ADDR
// uc_nation = 0 ;
87254: LD_ADDR_OWVAR 21
87258: PUSH
87259: LD_INT 0
87261: ST_TO_ADDR
// InitHc_All ( ) ;
87262: CALL_OW 584
// InitVc ;
87266: CALL_OW 20
// if mastodonts then
87270: LD_VAR 0 6
87274: IFFALSE 87341
// for i = 1 to mastodonts do
87276: LD_ADDR_VAR 0 11
87280: PUSH
87281: DOUBLE
87282: LD_INT 1
87284: DEC
87285: ST_TO_ADDR
87286: LD_VAR 0 6
87290: PUSH
87291: FOR_TO
87292: IFFALSE 87339
// begin vc_chassis := 31 ;
87294: LD_ADDR_OWVAR 37
87298: PUSH
87299: LD_INT 31
87301: ST_TO_ADDR
// vc_control := control_rider ;
87302: LD_ADDR_OWVAR 38
87306: PUSH
87307: LD_INT 4
87309: ST_TO_ADDR
// animal := CreateVehicle ;
87310: LD_ADDR_VAR 0 12
87314: PUSH
87315: CALL_OW 45
87319: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87320: LD_VAR 0 12
87324: PPUSH
87325: LD_VAR 0 8
87329: PPUSH
87330: LD_INT 0
87332: PPUSH
87333: CALL 89469 0 3
// end ;
87337: GO 87291
87339: POP
87340: POP
// if horses then
87341: LD_VAR 0 5
87345: IFFALSE 87412
// for i = 1 to horses do
87347: LD_ADDR_VAR 0 11
87351: PUSH
87352: DOUBLE
87353: LD_INT 1
87355: DEC
87356: ST_TO_ADDR
87357: LD_VAR 0 5
87361: PUSH
87362: FOR_TO
87363: IFFALSE 87410
// begin hc_class := 21 ;
87365: LD_ADDR_OWVAR 28
87369: PUSH
87370: LD_INT 21
87372: ST_TO_ADDR
// hc_gallery :=  ;
87373: LD_ADDR_OWVAR 33
87377: PUSH
87378: LD_STRING 
87380: ST_TO_ADDR
// animal := CreateHuman ;
87381: LD_ADDR_VAR 0 12
87385: PUSH
87386: CALL_OW 44
87390: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87391: LD_VAR 0 12
87395: PPUSH
87396: LD_VAR 0 8
87400: PPUSH
87401: LD_INT 0
87403: PPUSH
87404: CALL 89469 0 3
// end ;
87408: GO 87362
87410: POP
87411: POP
// if birds then
87412: LD_VAR 0 1
87416: IFFALSE 87483
// for i = 1 to birds do
87418: LD_ADDR_VAR 0 11
87422: PUSH
87423: DOUBLE
87424: LD_INT 1
87426: DEC
87427: ST_TO_ADDR
87428: LD_VAR 0 1
87432: PUSH
87433: FOR_TO
87434: IFFALSE 87481
// begin hc_class := 18 ;
87436: LD_ADDR_OWVAR 28
87440: PUSH
87441: LD_INT 18
87443: ST_TO_ADDR
// hc_gallery =  ;
87444: LD_ADDR_OWVAR 33
87448: PUSH
87449: LD_STRING 
87451: ST_TO_ADDR
// animal := CreateHuman ;
87452: LD_ADDR_VAR 0 12
87456: PUSH
87457: CALL_OW 44
87461: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87462: LD_VAR 0 12
87466: PPUSH
87467: LD_VAR 0 8
87471: PPUSH
87472: LD_INT 0
87474: PPUSH
87475: CALL 89469 0 3
// end ;
87479: GO 87433
87481: POP
87482: POP
// if tigers then
87483: LD_VAR 0 2
87487: IFFALSE 87571
// for i = 1 to tigers do
87489: LD_ADDR_VAR 0 11
87493: PUSH
87494: DOUBLE
87495: LD_INT 1
87497: DEC
87498: ST_TO_ADDR
87499: LD_VAR 0 2
87503: PUSH
87504: FOR_TO
87505: IFFALSE 87569
// begin hc_class = class_tiger ;
87507: LD_ADDR_OWVAR 28
87511: PUSH
87512: LD_INT 14
87514: ST_TO_ADDR
// hc_gallery =  ;
87515: LD_ADDR_OWVAR 33
87519: PUSH
87520: LD_STRING 
87522: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
87523: LD_ADDR_OWVAR 35
87527: PUSH
87528: LD_INT 7
87530: NEG
87531: PPUSH
87532: LD_INT 7
87534: PPUSH
87535: CALL_OW 12
87539: ST_TO_ADDR
// animal := CreateHuman ;
87540: LD_ADDR_VAR 0 12
87544: PUSH
87545: CALL_OW 44
87549: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87550: LD_VAR 0 12
87554: PPUSH
87555: LD_VAR 0 8
87559: PPUSH
87560: LD_INT 0
87562: PPUSH
87563: CALL 89469 0 3
// end ;
87567: GO 87504
87569: POP
87570: POP
// if apemans then
87571: LD_VAR 0 3
87575: IFFALSE 87698
// for i = 1 to apemans do
87577: LD_ADDR_VAR 0 11
87581: PUSH
87582: DOUBLE
87583: LD_INT 1
87585: DEC
87586: ST_TO_ADDR
87587: LD_VAR 0 3
87591: PUSH
87592: FOR_TO
87593: IFFALSE 87696
// begin hc_class = class_apeman ;
87595: LD_ADDR_OWVAR 28
87599: PUSH
87600: LD_INT 12
87602: ST_TO_ADDR
// hc_gallery =  ;
87603: LD_ADDR_OWVAR 33
87607: PUSH
87608: LD_STRING 
87610: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
87611: LD_ADDR_OWVAR 35
87615: PUSH
87616: LD_INT 2
87618: NEG
87619: PPUSH
87620: LD_INT 2
87622: PPUSH
87623: CALL_OW 12
87627: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
87628: LD_ADDR_OWVAR 31
87632: PUSH
87633: LD_INT 1
87635: PPUSH
87636: LD_INT 3
87638: PPUSH
87639: CALL_OW 12
87643: PUSH
87644: LD_INT 1
87646: PPUSH
87647: LD_INT 3
87649: PPUSH
87650: CALL_OW 12
87654: PUSH
87655: LD_INT 0
87657: PUSH
87658: LD_INT 0
87660: PUSH
87661: EMPTY
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: ST_TO_ADDR
// animal := CreateHuman ;
87667: LD_ADDR_VAR 0 12
87671: PUSH
87672: CALL_OW 44
87676: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87677: LD_VAR 0 12
87681: PPUSH
87682: LD_VAR 0 8
87686: PPUSH
87687: LD_INT 0
87689: PPUSH
87690: CALL 89469 0 3
// end ;
87694: GO 87592
87696: POP
87697: POP
// if enchidnas then
87698: LD_VAR 0 4
87702: IFFALSE 87769
// for i = 1 to enchidnas do
87704: LD_ADDR_VAR 0 11
87708: PUSH
87709: DOUBLE
87710: LD_INT 1
87712: DEC
87713: ST_TO_ADDR
87714: LD_VAR 0 4
87718: PUSH
87719: FOR_TO
87720: IFFALSE 87767
// begin hc_class = 13 ;
87722: LD_ADDR_OWVAR 28
87726: PUSH
87727: LD_INT 13
87729: ST_TO_ADDR
// hc_gallery =  ;
87730: LD_ADDR_OWVAR 33
87734: PUSH
87735: LD_STRING 
87737: ST_TO_ADDR
// animal := CreateHuman ;
87738: LD_ADDR_VAR 0 12
87742: PUSH
87743: CALL_OW 44
87747: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87748: LD_VAR 0 12
87752: PPUSH
87753: LD_VAR 0 8
87757: PPUSH
87758: LD_INT 0
87760: PPUSH
87761: CALL 89469 0 3
// end ;
87765: GO 87719
87767: POP
87768: POP
// if fishes then
87769: LD_VAR 0 7
87773: IFFALSE 87840
// for i = 1 to fishes do
87775: LD_ADDR_VAR 0 11
87779: PUSH
87780: DOUBLE
87781: LD_INT 1
87783: DEC
87784: ST_TO_ADDR
87785: LD_VAR 0 7
87789: PUSH
87790: FOR_TO
87791: IFFALSE 87838
// begin hc_class = 20 ;
87793: LD_ADDR_OWVAR 28
87797: PUSH
87798: LD_INT 20
87800: ST_TO_ADDR
// hc_gallery =  ;
87801: LD_ADDR_OWVAR 33
87805: PUSH
87806: LD_STRING 
87808: ST_TO_ADDR
// animal := CreateHuman ;
87809: LD_ADDR_VAR 0 12
87813: PUSH
87814: CALL_OW 44
87818: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
87819: LD_VAR 0 12
87823: PPUSH
87824: LD_VAR 0 9
87828: PPUSH
87829: LD_INT 0
87831: PPUSH
87832: CALL 89469 0 3
// end ;
87836: GO 87790
87838: POP
87839: POP
// end ;
87840: LD_VAR 0 10
87844: RET
// export function WantHeal ( sci , unit ) ; begin
87845: LD_INT 0
87847: PPUSH
// if GetTaskList ( sci ) > 0 then
87848: LD_VAR 0 1
87852: PPUSH
87853: CALL_OW 437
87857: PUSH
87858: LD_INT 0
87860: GREATER
87861: IFFALSE 87931
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
87863: LD_VAR 0 1
87867: PPUSH
87868: CALL_OW 437
87872: PUSH
87873: LD_INT 1
87875: ARRAY
87876: PUSH
87877: LD_INT 1
87879: ARRAY
87880: PUSH
87881: LD_STRING l
87883: EQUAL
87884: PUSH
87885: LD_VAR 0 1
87889: PPUSH
87890: CALL_OW 437
87894: PUSH
87895: LD_INT 1
87897: ARRAY
87898: PUSH
87899: LD_INT 4
87901: ARRAY
87902: PUSH
87903: LD_VAR 0 2
87907: EQUAL
87908: AND
87909: IFFALSE 87921
// result := true else
87911: LD_ADDR_VAR 0 3
87915: PUSH
87916: LD_INT 1
87918: ST_TO_ADDR
87919: GO 87929
// result := false ;
87921: LD_ADDR_VAR 0 3
87925: PUSH
87926: LD_INT 0
87928: ST_TO_ADDR
// end else
87929: GO 87939
// result := false ;
87931: LD_ADDR_VAR 0 3
87935: PUSH
87936: LD_INT 0
87938: ST_TO_ADDR
// end ;
87939: LD_VAR 0 3
87943: RET
// export function HealTarget ( sci ) ; begin
87944: LD_INT 0
87946: PPUSH
// if not sci then
87947: LD_VAR 0 1
87951: NOT
87952: IFFALSE 87956
// exit ;
87954: GO 88021
// result := 0 ;
87956: LD_ADDR_VAR 0 2
87960: PUSH
87961: LD_INT 0
87963: ST_TO_ADDR
// if GetTaskList ( sci ) then
87964: LD_VAR 0 1
87968: PPUSH
87969: CALL_OW 437
87973: IFFALSE 88021
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
87975: LD_VAR 0 1
87979: PPUSH
87980: CALL_OW 437
87984: PUSH
87985: LD_INT 1
87987: ARRAY
87988: PUSH
87989: LD_INT 1
87991: ARRAY
87992: PUSH
87993: LD_STRING l
87995: EQUAL
87996: IFFALSE 88021
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
87998: LD_ADDR_VAR 0 2
88002: PUSH
88003: LD_VAR 0 1
88007: PPUSH
88008: CALL_OW 437
88012: PUSH
88013: LD_INT 1
88015: ARRAY
88016: PUSH
88017: LD_INT 4
88019: ARRAY
88020: ST_TO_ADDR
// end ;
88021: LD_VAR 0 2
88025: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
88026: LD_INT 0
88028: PPUSH
88029: PPUSH
88030: PPUSH
88031: PPUSH
// if not base_units then
88032: LD_VAR 0 1
88036: NOT
88037: IFFALSE 88041
// exit ;
88039: GO 88128
// result := false ;
88041: LD_ADDR_VAR 0 2
88045: PUSH
88046: LD_INT 0
88048: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
88049: LD_ADDR_VAR 0 5
88053: PUSH
88054: LD_VAR 0 1
88058: PPUSH
88059: LD_INT 21
88061: PUSH
88062: LD_INT 3
88064: PUSH
88065: EMPTY
88066: LIST
88067: LIST
88068: PPUSH
88069: CALL_OW 72
88073: ST_TO_ADDR
// if not tmp then
88074: LD_VAR 0 5
88078: NOT
88079: IFFALSE 88083
// exit ;
88081: GO 88128
// for i in tmp do
88083: LD_ADDR_VAR 0 3
88087: PUSH
88088: LD_VAR 0 5
88092: PUSH
88093: FOR_IN
88094: IFFALSE 88126
// begin result := EnemyInRange ( i , 22 ) ;
88096: LD_ADDR_VAR 0 2
88100: PUSH
88101: LD_VAR 0 3
88105: PPUSH
88106: LD_INT 22
88108: PPUSH
88109: CALL 85715 0 2
88113: ST_TO_ADDR
// if result then
88114: LD_VAR 0 2
88118: IFFALSE 88124
// exit ;
88120: POP
88121: POP
88122: GO 88128
// end ;
88124: GO 88093
88126: POP
88127: POP
// end ;
88128: LD_VAR 0 2
88132: RET
// export function FilterByTag ( units , tag ) ; begin
88133: LD_INT 0
88135: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
88136: LD_ADDR_VAR 0 3
88140: PUSH
88141: LD_VAR 0 1
88145: PPUSH
88146: LD_INT 120
88148: PUSH
88149: LD_VAR 0 2
88153: PUSH
88154: EMPTY
88155: LIST
88156: LIST
88157: PPUSH
88158: CALL_OW 72
88162: ST_TO_ADDR
// end ;
88163: LD_VAR 0 3
88167: RET
// export function IsDriver ( un ) ; begin
88168: LD_INT 0
88170: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
88171: LD_ADDR_VAR 0 2
88175: PUSH
88176: LD_VAR 0 1
88180: PUSH
88181: LD_INT 55
88183: PUSH
88184: EMPTY
88185: LIST
88186: PPUSH
88187: CALL_OW 69
88191: IN
88192: ST_TO_ADDR
// end ;
88193: LD_VAR 0 2
88197: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
88198: LD_INT 0
88200: PPUSH
88201: PPUSH
// list := [ ] ;
88202: LD_ADDR_VAR 0 5
88206: PUSH
88207: EMPTY
88208: ST_TO_ADDR
// case d of 0 :
88209: LD_VAR 0 3
88213: PUSH
88214: LD_INT 0
88216: DOUBLE
88217: EQUAL
88218: IFTRUE 88222
88220: GO 88355
88222: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
88223: LD_ADDR_VAR 0 5
88227: PUSH
88228: LD_VAR 0 1
88232: PUSH
88233: LD_INT 4
88235: MINUS
88236: PUSH
88237: LD_VAR 0 2
88241: PUSH
88242: LD_INT 4
88244: MINUS
88245: PUSH
88246: LD_INT 2
88248: PUSH
88249: EMPTY
88250: LIST
88251: LIST
88252: LIST
88253: PUSH
88254: LD_VAR 0 1
88258: PUSH
88259: LD_INT 3
88261: MINUS
88262: PUSH
88263: LD_VAR 0 2
88267: PUSH
88268: LD_INT 1
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: LIST
88275: PUSH
88276: LD_VAR 0 1
88280: PUSH
88281: LD_INT 4
88283: PLUS
88284: PUSH
88285: LD_VAR 0 2
88289: PUSH
88290: LD_INT 4
88292: PUSH
88293: EMPTY
88294: LIST
88295: LIST
88296: LIST
88297: PUSH
88298: LD_VAR 0 1
88302: PUSH
88303: LD_INT 3
88305: PLUS
88306: PUSH
88307: LD_VAR 0 2
88311: PUSH
88312: LD_INT 3
88314: PLUS
88315: PUSH
88316: LD_INT 5
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: LIST
88323: PUSH
88324: LD_VAR 0 1
88328: PUSH
88329: LD_VAR 0 2
88333: PUSH
88334: LD_INT 4
88336: PLUS
88337: PUSH
88338: LD_INT 0
88340: PUSH
88341: EMPTY
88342: LIST
88343: LIST
88344: LIST
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: LIST
88350: LIST
88351: LIST
88352: ST_TO_ADDR
// end ; 1 :
88353: GO 89053
88355: LD_INT 1
88357: DOUBLE
88358: EQUAL
88359: IFTRUE 88363
88361: GO 88496
88363: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
88364: LD_ADDR_VAR 0 5
88368: PUSH
88369: LD_VAR 0 1
88373: PUSH
88374: LD_VAR 0 2
88378: PUSH
88379: LD_INT 4
88381: MINUS
88382: PUSH
88383: LD_INT 3
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: LIST
88390: PUSH
88391: LD_VAR 0 1
88395: PUSH
88396: LD_INT 3
88398: MINUS
88399: PUSH
88400: LD_VAR 0 2
88404: PUSH
88405: LD_INT 3
88407: MINUS
88408: PUSH
88409: LD_INT 2
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: LIST
88416: PUSH
88417: LD_VAR 0 1
88421: PUSH
88422: LD_INT 4
88424: MINUS
88425: PUSH
88426: LD_VAR 0 2
88430: PUSH
88431: LD_INT 1
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: LIST
88438: PUSH
88439: LD_VAR 0 1
88443: PUSH
88444: LD_VAR 0 2
88448: PUSH
88449: LD_INT 3
88451: PLUS
88452: PUSH
88453: LD_INT 0
88455: PUSH
88456: EMPTY
88457: LIST
88458: LIST
88459: LIST
88460: PUSH
88461: LD_VAR 0 1
88465: PUSH
88466: LD_INT 4
88468: PLUS
88469: PUSH
88470: LD_VAR 0 2
88474: PUSH
88475: LD_INT 4
88477: PLUS
88478: PUSH
88479: LD_INT 5
88481: PUSH
88482: EMPTY
88483: LIST
88484: LIST
88485: LIST
88486: PUSH
88487: EMPTY
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: ST_TO_ADDR
// end ; 2 :
88494: GO 89053
88496: LD_INT 2
88498: DOUBLE
88499: EQUAL
88500: IFTRUE 88504
88502: GO 88633
88504: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88505: LD_ADDR_VAR 0 5
88509: PUSH
88510: LD_VAR 0 1
88514: PUSH
88515: LD_VAR 0 2
88519: PUSH
88520: LD_INT 3
88522: MINUS
88523: PUSH
88524: LD_INT 3
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: LIST
88531: PUSH
88532: LD_VAR 0 1
88536: PUSH
88537: LD_INT 4
88539: PLUS
88540: PUSH
88541: LD_VAR 0 2
88545: PUSH
88546: LD_INT 4
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: LIST
88553: PUSH
88554: LD_VAR 0 1
88558: PUSH
88559: LD_VAR 0 2
88563: PUSH
88564: LD_INT 4
88566: PLUS
88567: PUSH
88568: LD_INT 0
88570: PUSH
88571: EMPTY
88572: LIST
88573: LIST
88574: LIST
88575: PUSH
88576: LD_VAR 0 1
88580: PUSH
88581: LD_INT 3
88583: MINUS
88584: PUSH
88585: LD_VAR 0 2
88589: PUSH
88590: LD_INT 1
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: LIST
88597: PUSH
88598: LD_VAR 0 1
88602: PUSH
88603: LD_INT 4
88605: MINUS
88606: PUSH
88607: LD_VAR 0 2
88611: PUSH
88612: LD_INT 4
88614: MINUS
88615: PUSH
88616: LD_INT 2
88618: PUSH
88619: EMPTY
88620: LIST
88621: LIST
88622: LIST
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: LIST
88628: LIST
88629: LIST
88630: ST_TO_ADDR
// end ; 3 :
88631: GO 89053
88633: LD_INT 3
88635: DOUBLE
88636: EQUAL
88637: IFTRUE 88641
88639: GO 88774
88641: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
88642: LD_ADDR_VAR 0 5
88646: PUSH
88647: LD_VAR 0 1
88651: PUSH
88652: LD_INT 3
88654: PLUS
88655: PUSH
88656: LD_VAR 0 2
88660: PUSH
88661: LD_INT 4
88663: PUSH
88664: EMPTY
88665: LIST
88666: LIST
88667: LIST
88668: PUSH
88669: LD_VAR 0 1
88673: PUSH
88674: LD_INT 4
88676: PLUS
88677: PUSH
88678: LD_VAR 0 2
88682: PUSH
88683: LD_INT 4
88685: PLUS
88686: PUSH
88687: LD_INT 5
88689: PUSH
88690: EMPTY
88691: LIST
88692: LIST
88693: LIST
88694: PUSH
88695: LD_VAR 0 1
88699: PUSH
88700: LD_INT 4
88702: MINUS
88703: PUSH
88704: LD_VAR 0 2
88708: PUSH
88709: LD_INT 1
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: LIST
88716: PUSH
88717: LD_VAR 0 1
88721: PUSH
88722: LD_VAR 0 2
88726: PUSH
88727: LD_INT 4
88729: MINUS
88730: PUSH
88731: LD_INT 3
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: LIST
88738: PUSH
88739: LD_VAR 0 1
88743: PUSH
88744: LD_INT 3
88746: MINUS
88747: PUSH
88748: LD_VAR 0 2
88752: PUSH
88753: LD_INT 3
88755: MINUS
88756: PUSH
88757: LD_INT 2
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: LIST
88764: PUSH
88765: EMPTY
88766: LIST
88767: LIST
88768: LIST
88769: LIST
88770: LIST
88771: ST_TO_ADDR
// end ; 4 :
88772: GO 89053
88774: LD_INT 4
88776: DOUBLE
88777: EQUAL
88778: IFTRUE 88782
88780: GO 88915
88782: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88783: LD_ADDR_VAR 0 5
88787: PUSH
88788: LD_VAR 0 1
88792: PUSH
88793: LD_VAR 0 2
88797: PUSH
88798: LD_INT 4
88800: PLUS
88801: PUSH
88802: LD_INT 0
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: LIST
88809: PUSH
88810: LD_VAR 0 1
88814: PUSH
88815: LD_INT 3
88817: PLUS
88818: PUSH
88819: LD_VAR 0 2
88823: PUSH
88824: LD_INT 3
88826: PLUS
88827: PUSH
88828: LD_INT 5
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: LIST
88835: PUSH
88836: LD_VAR 0 1
88840: PUSH
88841: LD_INT 4
88843: PLUS
88844: PUSH
88845: LD_VAR 0 2
88849: PUSH
88850: LD_INT 4
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: LIST
88857: PUSH
88858: LD_VAR 0 1
88862: PUSH
88863: LD_VAR 0 2
88867: PUSH
88868: LD_INT 3
88870: MINUS
88871: PUSH
88872: LD_INT 3
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: LIST
88879: PUSH
88880: LD_VAR 0 1
88884: PUSH
88885: LD_INT 4
88887: MINUS
88888: PUSH
88889: LD_VAR 0 2
88893: PUSH
88894: LD_INT 4
88896: MINUS
88897: PUSH
88898: LD_INT 2
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: LIST
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: ST_TO_ADDR
// end ; 5 :
88913: GO 89053
88915: LD_INT 5
88917: DOUBLE
88918: EQUAL
88919: IFTRUE 88923
88921: GO 89052
88923: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88924: LD_ADDR_VAR 0 5
88928: PUSH
88929: LD_VAR 0 1
88933: PUSH
88934: LD_INT 4
88936: MINUS
88937: PUSH
88938: LD_VAR 0 2
88942: PUSH
88943: LD_INT 1
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: LIST
88950: PUSH
88951: LD_VAR 0 1
88955: PUSH
88956: LD_VAR 0 2
88960: PUSH
88961: LD_INT 4
88963: MINUS
88964: PUSH
88965: LD_INT 3
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: LIST
88972: PUSH
88973: LD_VAR 0 1
88977: PUSH
88978: LD_INT 4
88980: PLUS
88981: PUSH
88982: LD_VAR 0 2
88986: PUSH
88987: LD_INT 4
88989: PLUS
88990: PUSH
88991: LD_INT 5
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: LIST
88998: PUSH
88999: LD_VAR 0 1
89003: PUSH
89004: LD_INT 3
89006: PLUS
89007: PUSH
89008: LD_VAR 0 2
89012: PUSH
89013: LD_INT 4
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: LIST
89020: PUSH
89021: LD_VAR 0 1
89025: PUSH
89026: LD_VAR 0 2
89030: PUSH
89031: LD_INT 3
89033: PLUS
89034: PUSH
89035: LD_INT 0
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: LIST
89042: PUSH
89043: EMPTY
89044: LIST
89045: LIST
89046: LIST
89047: LIST
89048: LIST
89049: ST_TO_ADDR
// end ; end ;
89050: GO 89053
89052: POP
// result := list ;
89053: LD_ADDR_VAR 0 4
89057: PUSH
89058: LD_VAR 0 5
89062: ST_TO_ADDR
// end ;
89063: LD_VAR 0 4
89067: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
89068: LD_INT 0
89070: PPUSH
89071: PPUSH
89072: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
89073: LD_VAR 0 1
89077: NOT
89078: PUSH
89079: LD_VAR 0 2
89083: PUSH
89084: LD_INT 1
89086: PUSH
89087: LD_INT 2
89089: PUSH
89090: LD_INT 3
89092: PUSH
89093: LD_INT 4
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: LIST
89100: LIST
89101: IN
89102: NOT
89103: OR
89104: IFFALSE 89108
// exit ;
89106: GO 89191
// tmp := [ ] ;
89108: LD_ADDR_VAR 0 5
89112: PUSH
89113: EMPTY
89114: ST_TO_ADDR
// for i in units do
89115: LD_ADDR_VAR 0 4
89119: PUSH
89120: LD_VAR 0 1
89124: PUSH
89125: FOR_IN
89126: IFFALSE 89160
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
89128: LD_ADDR_VAR 0 5
89132: PUSH
89133: LD_VAR 0 5
89137: PPUSH
89138: LD_VAR 0 4
89142: PPUSH
89143: LD_VAR 0 2
89147: PPUSH
89148: CALL_OW 259
89152: PPUSH
89153: CALL 90564 0 2
89157: ST_TO_ADDR
89158: GO 89125
89160: POP
89161: POP
// if not tmp then
89162: LD_VAR 0 5
89166: NOT
89167: IFFALSE 89171
// exit ;
89169: GO 89191
// result := SortListByListDesc ( units , tmp ) ;
89171: LD_ADDR_VAR 0 3
89175: PUSH
89176: LD_VAR 0 1
89180: PPUSH
89181: LD_VAR 0 5
89185: PPUSH
89186: CALL_OW 77
89190: ST_TO_ADDR
// end ;
89191: LD_VAR 0 3
89195: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
89196: LD_INT 0
89198: PPUSH
89199: PPUSH
89200: PPUSH
// result := false ;
89201: LD_ADDR_VAR 0 3
89205: PUSH
89206: LD_INT 0
89208: ST_TO_ADDR
// if not building then
89209: LD_VAR 0 2
89213: NOT
89214: IFFALSE 89218
// exit ;
89216: GO 89356
// x := GetX ( building ) ;
89218: LD_ADDR_VAR 0 4
89222: PUSH
89223: LD_VAR 0 2
89227: PPUSH
89228: CALL_OW 250
89232: ST_TO_ADDR
// y := GetY ( building ) ;
89233: LD_ADDR_VAR 0 5
89237: PUSH
89238: LD_VAR 0 2
89242: PPUSH
89243: CALL_OW 251
89247: ST_TO_ADDR
// if not x or not y then
89248: LD_VAR 0 4
89252: NOT
89253: PUSH
89254: LD_VAR 0 5
89258: NOT
89259: OR
89260: IFFALSE 89264
// exit ;
89262: GO 89356
// if GetTaskList ( unit ) then
89264: LD_VAR 0 1
89268: PPUSH
89269: CALL_OW 437
89273: IFFALSE 89356
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89275: LD_STRING e
89277: PUSH
89278: LD_VAR 0 1
89282: PPUSH
89283: CALL_OW 437
89287: PUSH
89288: LD_INT 1
89290: ARRAY
89291: PUSH
89292: LD_INT 1
89294: ARRAY
89295: EQUAL
89296: PUSH
89297: LD_VAR 0 4
89301: PUSH
89302: LD_VAR 0 1
89306: PPUSH
89307: CALL_OW 437
89311: PUSH
89312: LD_INT 1
89314: ARRAY
89315: PUSH
89316: LD_INT 2
89318: ARRAY
89319: EQUAL
89320: AND
89321: PUSH
89322: LD_VAR 0 5
89326: PUSH
89327: LD_VAR 0 1
89331: PPUSH
89332: CALL_OW 437
89336: PUSH
89337: LD_INT 1
89339: ARRAY
89340: PUSH
89341: LD_INT 3
89343: ARRAY
89344: EQUAL
89345: AND
89346: IFFALSE 89356
// result := true end ;
89348: LD_ADDR_VAR 0 3
89352: PUSH
89353: LD_INT 1
89355: ST_TO_ADDR
// end ;
89356: LD_VAR 0 3
89360: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
89361: LD_INT 0
89363: PPUSH
// result := false ;
89364: LD_ADDR_VAR 0 4
89368: PUSH
89369: LD_INT 0
89371: ST_TO_ADDR
// if GetTaskList ( unit ) then
89372: LD_VAR 0 1
89376: PPUSH
89377: CALL_OW 437
89381: IFFALSE 89464
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89383: LD_STRING M
89385: PUSH
89386: LD_VAR 0 1
89390: PPUSH
89391: CALL_OW 437
89395: PUSH
89396: LD_INT 1
89398: ARRAY
89399: PUSH
89400: LD_INT 1
89402: ARRAY
89403: EQUAL
89404: PUSH
89405: LD_VAR 0 2
89409: PUSH
89410: LD_VAR 0 1
89414: PPUSH
89415: CALL_OW 437
89419: PUSH
89420: LD_INT 1
89422: ARRAY
89423: PUSH
89424: LD_INT 2
89426: ARRAY
89427: EQUAL
89428: AND
89429: PUSH
89430: LD_VAR 0 3
89434: PUSH
89435: LD_VAR 0 1
89439: PPUSH
89440: CALL_OW 437
89444: PUSH
89445: LD_INT 1
89447: ARRAY
89448: PUSH
89449: LD_INT 3
89451: ARRAY
89452: EQUAL
89453: AND
89454: IFFALSE 89464
// result := true ;
89456: LD_ADDR_VAR 0 4
89460: PUSH
89461: LD_INT 1
89463: ST_TO_ADDR
// end ; end ;
89464: LD_VAR 0 4
89468: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89469: LD_INT 0
89471: PPUSH
89472: PPUSH
89473: PPUSH
89474: PPUSH
// if not unit or not area then
89475: LD_VAR 0 1
89479: NOT
89480: PUSH
89481: LD_VAR 0 2
89485: NOT
89486: OR
89487: IFFALSE 89491
// exit ;
89489: GO 89667
// tmp := AreaToList ( area , i ) ;
89491: LD_ADDR_VAR 0 6
89495: PUSH
89496: LD_VAR 0 2
89500: PPUSH
89501: LD_VAR 0 5
89505: PPUSH
89506: CALL_OW 517
89510: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89511: LD_ADDR_VAR 0 5
89515: PUSH
89516: DOUBLE
89517: LD_INT 1
89519: DEC
89520: ST_TO_ADDR
89521: LD_VAR 0 6
89525: PUSH
89526: LD_INT 1
89528: ARRAY
89529: PUSH
89530: FOR_TO
89531: IFFALSE 89665
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89533: LD_ADDR_VAR 0 7
89537: PUSH
89538: LD_VAR 0 6
89542: PUSH
89543: LD_INT 1
89545: ARRAY
89546: PUSH
89547: LD_VAR 0 5
89551: ARRAY
89552: PUSH
89553: LD_VAR 0 6
89557: PUSH
89558: LD_INT 2
89560: ARRAY
89561: PUSH
89562: LD_VAR 0 5
89566: ARRAY
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
89572: LD_INT 92
89574: PUSH
89575: LD_VAR 0 7
89579: PUSH
89580: LD_INT 1
89582: ARRAY
89583: PUSH
89584: LD_VAR 0 7
89588: PUSH
89589: LD_INT 2
89591: ARRAY
89592: PUSH
89593: LD_INT 2
89595: PUSH
89596: EMPTY
89597: LIST
89598: LIST
89599: LIST
89600: LIST
89601: PPUSH
89602: CALL_OW 69
89606: PUSH
89607: LD_INT 0
89609: EQUAL
89610: IFFALSE 89663
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
89612: LD_VAR 0 1
89616: PPUSH
89617: LD_VAR 0 7
89621: PUSH
89622: LD_INT 1
89624: ARRAY
89625: PPUSH
89626: LD_VAR 0 7
89630: PUSH
89631: LD_INT 2
89633: ARRAY
89634: PPUSH
89635: LD_VAR 0 3
89639: PPUSH
89640: CALL_OW 48
// result := IsPlaced ( unit ) ;
89644: LD_ADDR_VAR 0 4
89648: PUSH
89649: LD_VAR 0 1
89653: PPUSH
89654: CALL_OW 305
89658: ST_TO_ADDR
// exit ;
89659: POP
89660: POP
89661: GO 89667
// end ; end ;
89663: GO 89530
89665: POP
89666: POP
// end ;
89667: LD_VAR 0 4
89671: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
89672: LD_INT 0
89674: PPUSH
89675: PPUSH
89676: PPUSH
// if not side or side > 8 then
89677: LD_VAR 0 1
89681: NOT
89682: PUSH
89683: LD_VAR 0 1
89687: PUSH
89688: LD_INT 8
89690: GREATER
89691: OR
89692: IFFALSE 89696
// exit ;
89694: GO 89883
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
89696: LD_ADDR_VAR 0 4
89700: PUSH
89701: LD_INT 22
89703: PUSH
89704: LD_VAR 0 1
89708: PUSH
89709: EMPTY
89710: LIST
89711: LIST
89712: PUSH
89713: LD_INT 21
89715: PUSH
89716: LD_INT 3
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PUSH
89723: EMPTY
89724: LIST
89725: LIST
89726: PPUSH
89727: CALL_OW 69
89731: ST_TO_ADDR
// if not tmp then
89732: LD_VAR 0 4
89736: NOT
89737: IFFALSE 89741
// exit ;
89739: GO 89883
// enable_addtolog := true ;
89741: LD_ADDR_OWVAR 81
89745: PUSH
89746: LD_INT 1
89748: ST_TO_ADDR
// AddToLog ( [ ) ;
89749: LD_STRING [
89751: PPUSH
89752: CALL_OW 561
// for i in tmp do
89756: LD_ADDR_VAR 0 3
89760: PUSH
89761: LD_VAR 0 4
89765: PUSH
89766: FOR_IN
89767: IFFALSE 89874
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
89769: LD_STRING [
89771: PUSH
89772: LD_VAR 0 3
89776: PPUSH
89777: CALL_OW 266
89781: STR
89782: PUSH
89783: LD_STRING , 
89785: STR
89786: PUSH
89787: LD_VAR 0 3
89791: PPUSH
89792: CALL_OW 250
89796: STR
89797: PUSH
89798: LD_STRING , 
89800: STR
89801: PUSH
89802: LD_VAR 0 3
89806: PPUSH
89807: CALL_OW 251
89811: STR
89812: PUSH
89813: LD_STRING , 
89815: STR
89816: PUSH
89817: LD_VAR 0 3
89821: PPUSH
89822: CALL_OW 254
89826: STR
89827: PUSH
89828: LD_STRING , 
89830: STR
89831: PUSH
89832: LD_VAR 0 3
89836: PPUSH
89837: LD_INT 1
89839: PPUSH
89840: CALL_OW 268
89844: STR
89845: PUSH
89846: LD_STRING , 
89848: STR
89849: PUSH
89850: LD_VAR 0 3
89854: PPUSH
89855: LD_INT 2
89857: PPUSH
89858: CALL_OW 268
89862: STR
89863: PUSH
89864: LD_STRING ],
89866: STR
89867: PPUSH
89868: CALL_OW 561
// end ;
89872: GO 89766
89874: POP
89875: POP
// AddToLog ( ]; ) ;
89876: LD_STRING ];
89878: PPUSH
89879: CALL_OW 561
// end ;
89883: LD_VAR 0 2
89887: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89888: LD_INT 0
89890: PPUSH
89891: PPUSH
89892: PPUSH
89893: PPUSH
89894: PPUSH
// if not area or not rate or not max then
89895: LD_VAR 0 1
89899: NOT
89900: PUSH
89901: LD_VAR 0 2
89905: NOT
89906: OR
89907: PUSH
89908: LD_VAR 0 4
89912: NOT
89913: OR
89914: IFFALSE 89918
// exit ;
89916: GO 90107
// while 1 do
89918: LD_INT 1
89920: IFFALSE 90107
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89922: LD_ADDR_VAR 0 9
89926: PUSH
89927: LD_VAR 0 1
89931: PPUSH
89932: LD_INT 1
89934: PPUSH
89935: CALL_OW 287
89939: PUSH
89940: LD_INT 10
89942: MUL
89943: ST_TO_ADDR
// r := rate / 10 ;
89944: LD_ADDR_VAR 0 7
89948: PUSH
89949: LD_VAR 0 2
89953: PUSH
89954: LD_INT 10
89956: DIVREAL
89957: ST_TO_ADDR
// time := 1 1$00 ;
89958: LD_ADDR_VAR 0 8
89962: PUSH
89963: LD_INT 2100
89965: ST_TO_ADDR
// if amount < min then
89966: LD_VAR 0 9
89970: PUSH
89971: LD_VAR 0 3
89975: LESS
89976: IFFALSE 89994
// r := r * 2 else
89978: LD_ADDR_VAR 0 7
89982: PUSH
89983: LD_VAR 0 7
89987: PUSH
89988: LD_INT 2
89990: MUL
89991: ST_TO_ADDR
89992: GO 90020
// if amount > max then
89994: LD_VAR 0 9
89998: PUSH
89999: LD_VAR 0 4
90003: GREATER
90004: IFFALSE 90020
// r := r / 2 ;
90006: LD_ADDR_VAR 0 7
90010: PUSH
90011: LD_VAR 0 7
90015: PUSH
90016: LD_INT 2
90018: DIVREAL
90019: ST_TO_ADDR
// time := time / r ;
90020: LD_ADDR_VAR 0 8
90024: PUSH
90025: LD_VAR 0 8
90029: PUSH
90030: LD_VAR 0 7
90034: DIVREAL
90035: ST_TO_ADDR
// if time < 0 then
90036: LD_VAR 0 8
90040: PUSH
90041: LD_INT 0
90043: LESS
90044: IFFALSE 90061
// time := time * - 1 ;
90046: LD_ADDR_VAR 0 8
90050: PUSH
90051: LD_VAR 0 8
90055: PUSH
90056: LD_INT 1
90058: NEG
90059: MUL
90060: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
90061: LD_VAR 0 8
90065: PUSH
90066: LD_INT 35
90068: PPUSH
90069: LD_INT 875
90071: PPUSH
90072: CALL_OW 12
90076: PLUS
90077: PPUSH
90078: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
90082: LD_INT 1
90084: PPUSH
90085: LD_INT 5
90087: PPUSH
90088: CALL_OW 12
90092: PPUSH
90093: LD_VAR 0 1
90097: PPUSH
90098: LD_INT 1
90100: PPUSH
90101: CALL_OW 55
// end ;
90105: GO 89918
// end ;
90107: LD_VAR 0 5
90111: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
90112: LD_INT 0
90114: PPUSH
90115: PPUSH
90116: PPUSH
90117: PPUSH
90118: PPUSH
90119: PPUSH
90120: PPUSH
90121: PPUSH
// if not turrets or not factories then
90122: LD_VAR 0 1
90126: NOT
90127: PUSH
90128: LD_VAR 0 2
90132: NOT
90133: OR
90134: IFFALSE 90138
// exit ;
90136: GO 90445
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
90138: LD_ADDR_VAR 0 10
90142: PUSH
90143: LD_INT 5
90145: PUSH
90146: LD_INT 6
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: LD_INT 2
90155: PUSH
90156: LD_INT 4
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: LD_INT 3
90165: PUSH
90166: LD_INT 5
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 24
90180: PUSH
90181: LD_INT 25
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: LD_INT 23
90190: PUSH
90191: LD_INT 27
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 42
90204: PUSH
90205: LD_INT 43
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 44
90214: PUSH
90215: LD_INT 46
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 45
90224: PUSH
90225: LD_INT 47
90227: PUSH
90228: EMPTY
90229: LIST
90230: LIST
90231: PUSH
90232: EMPTY
90233: LIST
90234: LIST
90235: LIST
90236: PUSH
90237: EMPTY
90238: LIST
90239: LIST
90240: LIST
90241: ST_TO_ADDR
// result := [ ] ;
90242: LD_ADDR_VAR 0 3
90246: PUSH
90247: EMPTY
90248: ST_TO_ADDR
// for i in turrets do
90249: LD_ADDR_VAR 0 4
90253: PUSH
90254: LD_VAR 0 1
90258: PUSH
90259: FOR_IN
90260: IFFALSE 90443
// begin nat := GetNation ( i ) ;
90262: LD_ADDR_VAR 0 7
90266: PUSH
90267: LD_VAR 0 4
90271: PPUSH
90272: CALL_OW 248
90276: ST_TO_ADDR
// weapon := 0 ;
90277: LD_ADDR_VAR 0 8
90281: PUSH
90282: LD_INT 0
90284: ST_TO_ADDR
// if not nat then
90285: LD_VAR 0 7
90289: NOT
90290: IFFALSE 90294
// continue ;
90292: GO 90259
// for j in list [ nat ] do
90294: LD_ADDR_VAR 0 5
90298: PUSH
90299: LD_VAR 0 10
90303: PUSH
90304: LD_VAR 0 7
90308: ARRAY
90309: PUSH
90310: FOR_IN
90311: IFFALSE 90352
// if GetBWeapon ( i ) = j [ 1 ] then
90313: LD_VAR 0 4
90317: PPUSH
90318: CALL_OW 269
90322: PUSH
90323: LD_VAR 0 5
90327: PUSH
90328: LD_INT 1
90330: ARRAY
90331: EQUAL
90332: IFFALSE 90350
// begin weapon := j [ 2 ] ;
90334: LD_ADDR_VAR 0 8
90338: PUSH
90339: LD_VAR 0 5
90343: PUSH
90344: LD_INT 2
90346: ARRAY
90347: ST_TO_ADDR
// break ;
90348: GO 90352
// end ;
90350: GO 90310
90352: POP
90353: POP
// if not weapon then
90354: LD_VAR 0 8
90358: NOT
90359: IFFALSE 90363
// continue ;
90361: GO 90259
// for k in factories do
90363: LD_ADDR_VAR 0 6
90367: PUSH
90368: LD_VAR 0 2
90372: PUSH
90373: FOR_IN
90374: IFFALSE 90439
// begin weapons := AvailableWeaponList ( k ) ;
90376: LD_ADDR_VAR 0 9
90380: PUSH
90381: LD_VAR 0 6
90385: PPUSH
90386: CALL_OW 478
90390: ST_TO_ADDR
// if not weapons then
90391: LD_VAR 0 9
90395: NOT
90396: IFFALSE 90400
// continue ;
90398: GO 90373
// if weapon in weapons then
90400: LD_VAR 0 8
90404: PUSH
90405: LD_VAR 0 9
90409: IN
90410: IFFALSE 90437
// begin result := [ i , weapon ] ;
90412: LD_ADDR_VAR 0 3
90416: PUSH
90417: LD_VAR 0 4
90421: PUSH
90422: LD_VAR 0 8
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: ST_TO_ADDR
// exit ;
90431: POP
90432: POP
90433: POP
90434: POP
90435: GO 90445
// end ; end ;
90437: GO 90373
90439: POP
90440: POP
// end ;
90441: GO 90259
90443: POP
90444: POP
// end ;
90445: LD_VAR 0 3
90449: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
90450: LD_INT 0
90452: PPUSH
// if not side or side > 8 then
90453: LD_VAR 0 3
90457: NOT
90458: PUSH
90459: LD_VAR 0 3
90463: PUSH
90464: LD_INT 8
90466: GREATER
90467: OR
90468: IFFALSE 90472
// exit ;
90470: GO 90531
// if not range then
90472: LD_VAR 0 4
90476: NOT
90477: IFFALSE 90488
// range := - 12 ;
90479: LD_ADDR_VAR 0 4
90483: PUSH
90484: LD_INT 12
90486: NEG
90487: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90488: LD_VAR 0 1
90492: PPUSH
90493: LD_VAR 0 2
90497: PPUSH
90498: LD_VAR 0 3
90502: PPUSH
90503: LD_VAR 0 4
90507: PPUSH
90508: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90512: LD_VAR 0 1
90516: PPUSH
90517: LD_VAR 0 2
90521: PPUSH
90522: LD_VAR 0 3
90526: PPUSH
90527: CALL_OW 331
// end ;
90531: LD_VAR 0 5
90535: RET
// export function Video ( mode ) ; begin
90536: LD_INT 0
90538: PPUSH
// ingame_video = mode ;
90539: LD_ADDR_OWVAR 52
90543: PUSH
90544: LD_VAR 0 1
90548: ST_TO_ADDR
// interface_hidden = mode ;
90549: LD_ADDR_OWVAR 54
90553: PUSH
90554: LD_VAR 0 1
90558: ST_TO_ADDR
// end ;
90559: LD_VAR 0 2
90563: RET
// export function Join ( array , element ) ; begin
90564: LD_INT 0
90566: PPUSH
// result := Replace ( array , array + 1 , element ) ;
90567: LD_ADDR_VAR 0 3
90571: PUSH
90572: LD_VAR 0 1
90576: PPUSH
90577: LD_VAR 0 1
90581: PUSH
90582: LD_INT 1
90584: PLUS
90585: PPUSH
90586: LD_VAR 0 2
90590: PPUSH
90591: CALL_OW 1
90595: ST_TO_ADDR
// end ;
90596: LD_VAR 0 3
90600: RET
// export function JoinUnion ( array , element ) ; begin
90601: LD_INT 0
90603: PPUSH
// result := array union element ;
90604: LD_ADDR_VAR 0 3
90608: PUSH
90609: LD_VAR 0 1
90613: PUSH
90614: LD_VAR 0 2
90618: UNION
90619: ST_TO_ADDR
// end ;
90620: LD_VAR 0 3
90624: RET
// export function GetBehemoths ( side ) ; begin
90625: LD_INT 0
90627: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
90628: LD_ADDR_VAR 0 2
90632: PUSH
90633: LD_INT 22
90635: PUSH
90636: LD_VAR 0 1
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: PUSH
90645: LD_INT 31
90647: PUSH
90648: LD_INT 25
90650: PUSH
90651: EMPTY
90652: LIST
90653: LIST
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: PPUSH
90659: CALL_OW 69
90663: ST_TO_ADDR
// end ;
90664: LD_VAR 0 2
90668: RET
// export function Shuffle ( array ) ; var i , index ; begin
90669: LD_INT 0
90671: PPUSH
90672: PPUSH
90673: PPUSH
// result := [ ] ;
90674: LD_ADDR_VAR 0 2
90678: PUSH
90679: EMPTY
90680: ST_TO_ADDR
// if not array then
90681: LD_VAR 0 1
90685: NOT
90686: IFFALSE 90690
// exit ;
90688: GO 90789
// Randomize ;
90690: CALL_OW 10
// for i = array downto 1 do
90694: LD_ADDR_VAR 0 3
90698: PUSH
90699: DOUBLE
90700: LD_VAR 0 1
90704: INC
90705: ST_TO_ADDR
90706: LD_INT 1
90708: PUSH
90709: FOR_DOWNTO
90710: IFFALSE 90787
// begin index := rand ( 1 , array ) ;
90712: LD_ADDR_VAR 0 4
90716: PUSH
90717: LD_INT 1
90719: PPUSH
90720: LD_VAR 0 1
90724: PPUSH
90725: CALL_OW 12
90729: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
90730: LD_ADDR_VAR 0 2
90734: PUSH
90735: LD_VAR 0 2
90739: PPUSH
90740: LD_VAR 0 2
90744: PUSH
90745: LD_INT 1
90747: PLUS
90748: PPUSH
90749: LD_VAR 0 1
90753: PUSH
90754: LD_VAR 0 4
90758: ARRAY
90759: PPUSH
90760: CALL_OW 2
90764: ST_TO_ADDR
// array := Delete ( array , index ) ;
90765: LD_ADDR_VAR 0 1
90769: PUSH
90770: LD_VAR 0 1
90774: PPUSH
90775: LD_VAR 0 4
90779: PPUSH
90780: CALL_OW 3
90784: ST_TO_ADDR
// end ;
90785: GO 90709
90787: POP
90788: POP
// end ;
90789: LD_VAR 0 2
90793: RET
// export function GetBaseMaterials ( base ) ; begin
90794: LD_INT 0
90796: PPUSH
// result := [ 0 , 0 , 0 ] ;
90797: LD_ADDR_VAR 0 2
90801: PUSH
90802: LD_INT 0
90804: PUSH
90805: LD_INT 0
90807: PUSH
90808: LD_INT 0
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: LIST
90815: ST_TO_ADDR
// if not base then
90816: LD_VAR 0 1
90820: NOT
90821: IFFALSE 90825
// exit ;
90823: GO 90874
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
90825: LD_ADDR_VAR 0 2
90829: PUSH
90830: LD_VAR 0 1
90834: PPUSH
90835: LD_INT 1
90837: PPUSH
90838: CALL_OW 275
90842: PUSH
90843: LD_VAR 0 1
90847: PPUSH
90848: LD_INT 2
90850: PPUSH
90851: CALL_OW 275
90855: PUSH
90856: LD_VAR 0 1
90860: PPUSH
90861: LD_INT 3
90863: PPUSH
90864: CALL_OW 275
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: LIST
90873: ST_TO_ADDR
// end ;
90874: LD_VAR 0 2
90878: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
90879: LD_INT 0
90881: PPUSH
90882: PPUSH
// result := array ;
90883: LD_ADDR_VAR 0 3
90887: PUSH
90888: LD_VAR 0 1
90892: ST_TO_ADDR
// if size >= result then
90893: LD_VAR 0 2
90897: PUSH
90898: LD_VAR 0 3
90902: GREATEREQUAL
90903: IFFALSE 90907
// exit ;
90905: GO 90957
// if size then
90907: LD_VAR 0 2
90911: IFFALSE 90957
// for i := array downto size do
90913: LD_ADDR_VAR 0 4
90917: PUSH
90918: DOUBLE
90919: LD_VAR 0 1
90923: INC
90924: ST_TO_ADDR
90925: LD_VAR 0 2
90929: PUSH
90930: FOR_DOWNTO
90931: IFFALSE 90955
// result := Delete ( result , result ) ;
90933: LD_ADDR_VAR 0 3
90937: PUSH
90938: LD_VAR 0 3
90942: PPUSH
90943: LD_VAR 0 3
90947: PPUSH
90948: CALL_OW 3
90952: ST_TO_ADDR
90953: GO 90930
90955: POP
90956: POP
// end ;
90957: LD_VAR 0 3
90961: RET
// export function ComExit ( unit ) ; var tmp ; begin
90962: LD_INT 0
90964: PPUSH
90965: PPUSH
// if not IsInUnit ( unit ) then
90966: LD_VAR 0 1
90970: PPUSH
90971: CALL_OW 310
90975: NOT
90976: IFFALSE 90980
// exit ;
90978: GO 91040
// tmp := IsInUnit ( unit ) ;
90980: LD_ADDR_VAR 0 3
90984: PUSH
90985: LD_VAR 0 1
90989: PPUSH
90990: CALL_OW 310
90994: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
90995: LD_VAR 0 3
90999: PPUSH
91000: CALL_OW 247
91004: PUSH
91005: LD_INT 2
91007: EQUAL
91008: IFFALSE 91021
// ComExitVehicle ( unit ) else
91010: LD_VAR 0 1
91014: PPUSH
91015: CALL_OW 121
91019: GO 91030
// ComExitBuilding ( unit ) ;
91021: LD_VAR 0 1
91025: PPUSH
91026: CALL_OW 122
// result := tmp ;
91030: LD_ADDR_VAR 0 2
91034: PUSH
91035: LD_VAR 0 3
91039: ST_TO_ADDR
// end ;
91040: LD_VAR 0 2
91044: RET
// export function ComExitAll ( units ) ; var i ; begin
91045: LD_INT 0
91047: PPUSH
91048: PPUSH
// if not units then
91049: LD_VAR 0 1
91053: NOT
91054: IFFALSE 91058
// exit ;
91056: GO 91084
// for i in units do
91058: LD_ADDR_VAR 0 3
91062: PUSH
91063: LD_VAR 0 1
91067: PUSH
91068: FOR_IN
91069: IFFALSE 91082
// ComExit ( i ) ;
91071: LD_VAR 0 3
91075: PPUSH
91076: CALL 90962 0 1
91080: GO 91068
91082: POP
91083: POP
// end ;
91084: LD_VAR 0 2
91088: RET
// export function ResetHc ; begin
91089: LD_INT 0
91091: PPUSH
// InitHc ;
91092: CALL_OW 19
// hc_importance := 0 ;
91096: LD_ADDR_OWVAR 32
91100: PUSH
91101: LD_INT 0
91103: ST_TO_ADDR
// end ;
91104: LD_VAR 0 1
91108: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
91109: LD_INT 0
91111: PPUSH
91112: PPUSH
91113: PPUSH
// _x := ( x1 + x2 ) div 2 ;
91114: LD_ADDR_VAR 0 6
91118: PUSH
91119: LD_VAR 0 1
91123: PUSH
91124: LD_VAR 0 3
91128: PLUS
91129: PUSH
91130: LD_INT 2
91132: DIV
91133: ST_TO_ADDR
// if _x < 0 then
91134: LD_VAR 0 6
91138: PUSH
91139: LD_INT 0
91141: LESS
91142: IFFALSE 91159
// _x := _x * - 1 ;
91144: LD_ADDR_VAR 0 6
91148: PUSH
91149: LD_VAR 0 6
91153: PUSH
91154: LD_INT 1
91156: NEG
91157: MUL
91158: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
91159: LD_ADDR_VAR 0 7
91163: PUSH
91164: LD_VAR 0 2
91168: PUSH
91169: LD_VAR 0 4
91173: PLUS
91174: PUSH
91175: LD_INT 2
91177: DIV
91178: ST_TO_ADDR
// if _y < 0 then
91179: LD_VAR 0 7
91183: PUSH
91184: LD_INT 0
91186: LESS
91187: IFFALSE 91204
// _y := _y * - 1 ;
91189: LD_ADDR_VAR 0 7
91193: PUSH
91194: LD_VAR 0 7
91198: PUSH
91199: LD_INT 1
91201: NEG
91202: MUL
91203: ST_TO_ADDR
// result := [ _x , _y ] ;
91204: LD_ADDR_VAR 0 5
91208: PUSH
91209: LD_VAR 0 6
91213: PUSH
91214: LD_VAR 0 7
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: ST_TO_ADDR
// end ;
91223: LD_VAR 0 5
91227: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
91228: LD_INT 0
91230: PPUSH
91231: PPUSH
91232: PPUSH
91233: PPUSH
// task := GetTaskList ( unit ) ;
91234: LD_ADDR_VAR 0 7
91238: PUSH
91239: LD_VAR 0 1
91243: PPUSH
91244: CALL_OW 437
91248: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
91249: LD_VAR 0 7
91253: NOT
91254: PUSH
91255: LD_VAR 0 1
91259: PPUSH
91260: LD_VAR 0 2
91264: PPUSH
91265: CALL_OW 308
91269: NOT
91270: AND
91271: IFFALSE 91275
// exit ;
91273: GO 91393
// if IsInArea ( unit , area ) then
91275: LD_VAR 0 1
91279: PPUSH
91280: LD_VAR 0 2
91284: PPUSH
91285: CALL_OW 308
91289: IFFALSE 91307
// begin ComMoveToArea ( unit , goAway ) ;
91291: LD_VAR 0 1
91295: PPUSH
91296: LD_VAR 0 3
91300: PPUSH
91301: CALL_OW 113
// exit ;
91305: GO 91393
// end ; if task [ 1 ] [ 1 ] <> M then
91307: LD_VAR 0 7
91311: PUSH
91312: LD_INT 1
91314: ARRAY
91315: PUSH
91316: LD_INT 1
91318: ARRAY
91319: PUSH
91320: LD_STRING M
91322: NONEQUAL
91323: IFFALSE 91327
// exit ;
91325: GO 91393
// x := task [ 1 ] [ 2 ] ;
91327: LD_ADDR_VAR 0 5
91331: PUSH
91332: LD_VAR 0 7
91336: PUSH
91337: LD_INT 1
91339: ARRAY
91340: PUSH
91341: LD_INT 2
91343: ARRAY
91344: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
91345: LD_ADDR_VAR 0 6
91349: PUSH
91350: LD_VAR 0 7
91354: PUSH
91355: LD_INT 1
91357: ARRAY
91358: PUSH
91359: LD_INT 3
91361: ARRAY
91362: ST_TO_ADDR
// if InArea ( x , y , area ) then
91363: LD_VAR 0 5
91367: PPUSH
91368: LD_VAR 0 6
91372: PPUSH
91373: LD_VAR 0 2
91377: PPUSH
91378: CALL_OW 309
91382: IFFALSE 91393
// ComStop ( unit ) ;
91384: LD_VAR 0 1
91388: PPUSH
91389: CALL_OW 141
// end ;
91393: LD_VAR 0 4
91397: RET
// export function Abs ( value ) ; begin
91398: LD_INT 0
91400: PPUSH
// result := value ;
91401: LD_ADDR_VAR 0 2
91405: PUSH
91406: LD_VAR 0 1
91410: ST_TO_ADDR
// if value < 0 then
91411: LD_VAR 0 1
91415: PUSH
91416: LD_INT 0
91418: LESS
91419: IFFALSE 91436
// result := value * - 1 ;
91421: LD_ADDR_VAR 0 2
91425: PUSH
91426: LD_VAR 0 1
91430: PUSH
91431: LD_INT 1
91433: NEG
91434: MUL
91435: ST_TO_ADDR
// end ;
91436: LD_VAR 0 2
91440: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
91441: LD_INT 0
91443: PPUSH
91444: PPUSH
91445: PPUSH
91446: PPUSH
91447: PPUSH
91448: PPUSH
91449: PPUSH
91450: PPUSH
// if not unit or not building then
91451: LD_VAR 0 1
91455: NOT
91456: PUSH
91457: LD_VAR 0 2
91461: NOT
91462: OR
91463: IFFALSE 91467
// exit ;
91465: GO 91693
// x := GetX ( building ) ;
91467: LD_ADDR_VAR 0 4
91471: PUSH
91472: LD_VAR 0 2
91476: PPUSH
91477: CALL_OW 250
91481: ST_TO_ADDR
// y := GetY ( building ) ;
91482: LD_ADDR_VAR 0 6
91486: PUSH
91487: LD_VAR 0 2
91491: PPUSH
91492: CALL_OW 251
91496: ST_TO_ADDR
// d := GetDir ( building ) ;
91497: LD_ADDR_VAR 0 8
91501: PUSH
91502: LD_VAR 0 2
91506: PPUSH
91507: CALL_OW 254
91511: ST_TO_ADDR
// r := 4 ;
91512: LD_ADDR_VAR 0 9
91516: PUSH
91517: LD_INT 4
91519: ST_TO_ADDR
// for i := 1 to 5 do
91520: LD_ADDR_VAR 0 10
91524: PUSH
91525: DOUBLE
91526: LD_INT 1
91528: DEC
91529: ST_TO_ADDR
91530: LD_INT 5
91532: PUSH
91533: FOR_TO
91534: IFFALSE 91691
// begin _x := ShiftX ( x , d , r + i ) ;
91536: LD_ADDR_VAR 0 5
91540: PUSH
91541: LD_VAR 0 4
91545: PPUSH
91546: LD_VAR 0 8
91550: PPUSH
91551: LD_VAR 0 9
91555: PUSH
91556: LD_VAR 0 10
91560: PLUS
91561: PPUSH
91562: CALL_OW 272
91566: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
91567: LD_ADDR_VAR 0 7
91571: PUSH
91572: LD_VAR 0 6
91576: PPUSH
91577: LD_VAR 0 8
91581: PPUSH
91582: LD_VAR 0 9
91586: PUSH
91587: LD_VAR 0 10
91591: PLUS
91592: PPUSH
91593: CALL_OW 273
91597: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
91598: LD_VAR 0 5
91602: PPUSH
91603: LD_VAR 0 7
91607: PPUSH
91608: CALL_OW 488
91612: PUSH
91613: LD_VAR 0 5
91617: PPUSH
91618: LD_VAR 0 7
91622: PPUSH
91623: CALL_OW 428
91627: PPUSH
91628: CALL_OW 247
91632: PUSH
91633: LD_INT 3
91635: PUSH
91636: LD_INT 2
91638: PUSH
91639: EMPTY
91640: LIST
91641: LIST
91642: IN
91643: NOT
91644: AND
91645: IFFALSE 91689
// begin ComMoveXY ( unit , _x , _y ) ;
91647: LD_VAR 0 1
91651: PPUSH
91652: LD_VAR 0 5
91656: PPUSH
91657: LD_VAR 0 7
91661: PPUSH
91662: CALL_OW 111
// result := [ _x , _y ] ;
91666: LD_ADDR_VAR 0 3
91670: PUSH
91671: LD_VAR 0 5
91675: PUSH
91676: LD_VAR 0 7
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: ST_TO_ADDR
// exit ;
91685: POP
91686: POP
91687: GO 91693
// end ; end ;
91689: GO 91533
91691: POP
91692: POP
// end ;
91693: LD_VAR 0 3
91697: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
91698: LD_INT 0
91700: PPUSH
91701: PPUSH
91702: PPUSH
// result := 0 ;
91703: LD_ADDR_VAR 0 3
91707: PUSH
91708: LD_INT 0
91710: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
91711: LD_VAR 0 1
91715: PUSH
91716: LD_INT 0
91718: LESS
91719: PUSH
91720: LD_VAR 0 1
91724: PUSH
91725: LD_INT 8
91727: GREATER
91728: OR
91729: PUSH
91730: LD_VAR 0 2
91734: PUSH
91735: LD_INT 0
91737: LESS
91738: OR
91739: PUSH
91740: LD_VAR 0 2
91744: PUSH
91745: LD_INT 8
91747: GREATER
91748: OR
91749: IFFALSE 91753
// exit ;
91751: GO 91828
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
91753: LD_ADDR_VAR 0 4
91757: PUSH
91758: LD_INT 22
91760: PUSH
91761: LD_VAR 0 2
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: PPUSH
91770: CALL_OW 69
91774: PUSH
91775: FOR_IN
91776: IFFALSE 91826
// begin un := UnitShoot ( i ) ;
91778: LD_ADDR_VAR 0 5
91782: PUSH
91783: LD_VAR 0 4
91787: PPUSH
91788: CALL_OW 504
91792: ST_TO_ADDR
// if GetSide ( un ) = side1 then
91793: LD_VAR 0 5
91797: PPUSH
91798: CALL_OW 255
91802: PUSH
91803: LD_VAR 0 1
91807: EQUAL
91808: IFFALSE 91824
// begin result := un ;
91810: LD_ADDR_VAR 0 3
91814: PUSH
91815: LD_VAR 0 5
91819: ST_TO_ADDR
// exit ;
91820: POP
91821: POP
91822: GO 91828
// end ; end ;
91824: GO 91775
91826: POP
91827: POP
// end ;
91828: LD_VAR 0 3
91832: RET
// export function GetCargoBay ( units ) ; begin
91833: LD_INT 0
91835: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
91836: LD_ADDR_VAR 0 2
91840: PUSH
91841: LD_VAR 0 1
91845: PPUSH
91846: LD_INT 2
91848: PUSH
91849: LD_INT 34
91851: PUSH
91852: LD_INT 12
91854: PUSH
91855: EMPTY
91856: LIST
91857: LIST
91858: PUSH
91859: LD_INT 34
91861: PUSH
91862: LD_INT 51
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: PUSH
91869: LD_INT 34
91871: PUSH
91872: LD_INT 32
91874: PUSH
91875: EMPTY
91876: LIST
91877: LIST
91878: PUSH
91879: LD_INT 34
91881: PUSH
91882: LD_INT 89
91884: PUSH
91885: EMPTY
91886: LIST
91887: LIST
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: PPUSH
91896: CALL_OW 72
91900: ST_TO_ADDR
// end ;
91901: LD_VAR 0 2
91905: RET
// export function Negate ( value ) ; begin
91906: LD_INT 0
91908: PPUSH
// result := not value ;
91909: LD_ADDR_VAR 0 2
91913: PUSH
91914: LD_VAR 0 1
91918: NOT
91919: ST_TO_ADDR
// end ;
91920: LD_VAR 0 2
91924: RET
// export function Inc ( value ) ; begin
91925: LD_INT 0
91927: PPUSH
// result := value + 1 ;
91928: LD_ADDR_VAR 0 2
91932: PUSH
91933: LD_VAR 0 1
91937: PUSH
91938: LD_INT 1
91940: PLUS
91941: ST_TO_ADDR
// end ;
91942: LD_VAR 0 2
91946: RET
// export function Dec ( value ) ; begin
91947: LD_INT 0
91949: PPUSH
// result := value - 1 ;
91950: LD_ADDR_VAR 0 2
91954: PUSH
91955: LD_VAR 0 1
91959: PUSH
91960: LD_INT 1
91962: MINUS
91963: ST_TO_ADDR
// end ;
91964: LD_VAR 0 2
91968: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
91969: LD_INT 0
91971: PPUSH
91972: PPUSH
91973: PPUSH
91974: PPUSH
91975: PPUSH
91976: PPUSH
91977: PPUSH
91978: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
91979: LD_VAR 0 1
91983: PPUSH
91984: LD_VAR 0 2
91988: PPUSH
91989: CALL_OW 488
91993: NOT
91994: PUSH
91995: LD_VAR 0 3
91999: PPUSH
92000: LD_VAR 0 4
92004: PPUSH
92005: CALL_OW 488
92009: NOT
92010: OR
92011: IFFALSE 92024
// begin result := - 1 ;
92013: LD_ADDR_VAR 0 5
92017: PUSH
92018: LD_INT 1
92020: NEG
92021: ST_TO_ADDR
// exit ;
92022: GO 92259
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
92024: LD_ADDR_VAR 0 12
92028: PUSH
92029: LD_VAR 0 1
92033: PPUSH
92034: LD_VAR 0 2
92038: PPUSH
92039: LD_VAR 0 3
92043: PPUSH
92044: LD_VAR 0 4
92048: PPUSH
92049: CALL 91109 0 4
92053: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
92054: LD_ADDR_VAR 0 11
92058: PUSH
92059: LD_VAR 0 1
92063: PPUSH
92064: LD_VAR 0 2
92068: PPUSH
92069: LD_VAR 0 12
92073: PUSH
92074: LD_INT 1
92076: ARRAY
92077: PPUSH
92078: LD_VAR 0 12
92082: PUSH
92083: LD_INT 2
92085: ARRAY
92086: PPUSH
92087: CALL_OW 298
92091: ST_TO_ADDR
// distance := 9999 ;
92092: LD_ADDR_VAR 0 10
92096: PUSH
92097: LD_INT 9999
92099: ST_TO_ADDR
// for i := 0 to 5 do
92100: LD_ADDR_VAR 0 6
92104: PUSH
92105: DOUBLE
92106: LD_INT 0
92108: DEC
92109: ST_TO_ADDR
92110: LD_INT 5
92112: PUSH
92113: FOR_TO
92114: IFFALSE 92257
// begin _x := ShiftX ( x1 , i , centerDist ) ;
92116: LD_ADDR_VAR 0 7
92120: PUSH
92121: LD_VAR 0 1
92125: PPUSH
92126: LD_VAR 0 6
92130: PPUSH
92131: LD_VAR 0 11
92135: PPUSH
92136: CALL_OW 272
92140: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
92141: LD_ADDR_VAR 0 8
92145: PUSH
92146: LD_VAR 0 2
92150: PPUSH
92151: LD_VAR 0 6
92155: PPUSH
92156: LD_VAR 0 11
92160: PPUSH
92161: CALL_OW 273
92165: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
92166: LD_VAR 0 7
92170: PPUSH
92171: LD_VAR 0 8
92175: PPUSH
92176: CALL_OW 488
92180: NOT
92181: IFFALSE 92185
// continue ;
92183: GO 92113
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
92185: LD_ADDR_VAR 0 9
92189: PUSH
92190: LD_VAR 0 12
92194: PUSH
92195: LD_INT 1
92197: ARRAY
92198: PPUSH
92199: LD_VAR 0 12
92203: PUSH
92204: LD_INT 2
92206: ARRAY
92207: PPUSH
92208: LD_VAR 0 7
92212: PPUSH
92213: LD_VAR 0 8
92217: PPUSH
92218: CALL_OW 298
92222: ST_TO_ADDR
// if tmp < distance then
92223: LD_VAR 0 9
92227: PUSH
92228: LD_VAR 0 10
92232: LESS
92233: IFFALSE 92255
// begin result := i ;
92235: LD_ADDR_VAR 0 5
92239: PUSH
92240: LD_VAR 0 6
92244: ST_TO_ADDR
// distance := tmp ;
92245: LD_ADDR_VAR 0 10
92249: PUSH
92250: LD_VAR 0 9
92254: ST_TO_ADDR
// end ; end ;
92255: GO 92113
92257: POP
92258: POP
// end ;
92259: LD_VAR 0 5
92263: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92264: LD_INT 0
92266: PPUSH
92267: PPUSH
// if not driver or not IsInUnit ( driver ) then
92268: LD_VAR 0 1
92272: NOT
92273: PUSH
92274: LD_VAR 0 1
92278: PPUSH
92279: CALL_OW 310
92283: NOT
92284: OR
92285: IFFALSE 92289
// exit ;
92287: GO 92379
// vehicle := IsInUnit ( driver ) ;
92289: LD_ADDR_VAR 0 3
92293: PUSH
92294: LD_VAR 0 1
92298: PPUSH
92299: CALL_OW 310
92303: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92304: LD_VAR 0 1
92308: PPUSH
92309: LD_STRING \
92311: PUSH
92312: LD_INT 0
92314: PUSH
92315: LD_INT 0
92317: PUSH
92318: LD_INT 0
92320: PUSH
92321: LD_INT 0
92323: PUSH
92324: LD_INT 0
92326: PUSH
92327: LD_INT 0
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: PUSH
92339: LD_STRING E
92341: PUSH
92342: LD_INT 0
92344: PUSH
92345: LD_INT 0
92347: PUSH
92348: LD_VAR 0 3
92352: PUSH
92353: LD_INT 0
92355: PUSH
92356: LD_INT 0
92358: PUSH
92359: LD_INT 0
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PPUSH
92375: CALL_OW 446
// end ;
92379: LD_VAR 0 2
92383: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92384: LD_INT 0
92386: PPUSH
92387: PPUSH
// if not driver or not IsInUnit ( driver ) then
92388: LD_VAR 0 1
92392: NOT
92393: PUSH
92394: LD_VAR 0 1
92398: PPUSH
92399: CALL_OW 310
92403: NOT
92404: OR
92405: IFFALSE 92409
// exit ;
92407: GO 92499
// vehicle := IsInUnit ( driver ) ;
92409: LD_ADDR_VAR 0 3
92413: PUSH
92414: LD_VAR 0 1
92418: PPUSH
92419: CALL_OW 310
92423: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92424: LD_VAR 0 1
92428: PPUSH
92429: LD_STRING \
92431: PUSH
92432: LD_INT 0
92434: PUSH
92435: LD_INT 0
92437: PUSH
92438: LD_INT 0
92440: PUSH
92441: LD_INT 0
92443: PUSH
92444: LD_INT 0
92446: PUSH
92447: LD_INT 0
92449: PUSH
92450: EMPTY
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: LIST
92458: PUSH
92459: LD_STRING E
92461: PUSH
92462: LD_INT 0
92464: PUSH
92465: LD_INT 0
92467: PUSH
92468: LD_VAR 0 3
92472: PUSH
92473: LD_INT 0
92475: PUSH
92476: LD_INT 0
92478: PUSH
92479: LD_INT 0
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: PPUSH
92495: CALL_OW 447
// end ;
92499: LD_VAR 0 2
92503: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
92504: LD_INT 0
92506: PPUSH
92507: PPUSH
92508: PPUSH
// tmp := [ ] ;
92509: LD_ADDR_VAR 0 5
92513: PUSH
92514: EMPTY
92515: ST_TO_ADDR
// for i in units do
92516: LD_ADDR_VAR 0 4
92520: PUSH
92521: LD_VAR 0 1
92525: PUSH
92526: FOR_IN
92527: IFFALSE 92565
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
92529: LD_ADDR_VAR 0 5
92533: PUSH
92534: LD_VAR 0 5
92538: PPUSH
92539: LD_VAR 0 5
92543: PUSH
92544: LD_INT 1
92546: PLUS
92547: PPUSH
92548: LD_VAR 0 4
92552: PPUSH
92553: CALL_OW 256
92557: PPUSH
92558: CALL_OW 2
92562: ST_TO_ADDR
92563: GO 92526
92565: POP
92566: POP
// if not tmp then
92567: LD_VAR 0 5
92571: NOT
92572: IFFALSE 92576
// exit ;
92574: GO 92624
// if asc then
92576: LD_VAR 0 2
92580: IFFALSE 92604
// result := SortListByListAsc ( units , tmp ) else
92582: LD_ADDR_VAR 0 3
92586: PUSH
92587: LD_VAR 0 1
92591: PPUSH
92592: LD_VAR 0 5
92596: PPUSH
92597: CALL_OW 76
92601: ST_TO_ADDR
92602: GO 92624
// result := SortListByListDesc ( units , tmp ) ;
92604: LD_ADDR_VAR 0 3
92608: PUSH
92609: LD_VAR 0 1
92613: PPUSH
92614: LD_VAR 0 5
92618: PPUSH
92619: CALL_OW 77
92623: ST_TO_ADDR
// end ;
92624: LD_VAR 0 3
92628: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
92629: LD_INT 0
92631: PPUSH
92632: PPUSH
// task := GetTaskList ( mech ) ;
92633: LD_ADDR_VAR 0 4
92637: PUSH
92638: LD_VAR 0 1
92642: PPUSH
92643: CALL_OW 437
92647: ST_TO_ADDR
// if not task then
92648: LD_VAR 0 4
92652: NOT
92653: IFFALSE 92657
// exit ;
92655: GO 92699
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
92657: LD_ADDR_VAR 0 3
92661: PUSH
92662: LD_VAR 0 4
92666: PUSH
92667: LD_INT 1
92669: ARRAY
92670: PUSH
92671: LD_INT 1
92673: ARRAY
92674: PUSH
92675: LD_STRING r
92677: EQUAL
92678: PUSH
92679: LD_VAR 0 4
92683: PUSH
92684: LD_INT 1
92686: ARRAY
92687: PUSH
92688: LD_INT 4
92690: ARRAY
92691: PUSH
92692: LD_VAR 0 2
92696: EQUAL
92697: AND
92698: ST_TO_ADDR
// end ;
92699: LD_VAR 0 3
92703: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
92704: LD_INT 0
92706: PPUSH
// SetDir ( unit , d ) ;
92707: LD_VAR 0 1
92711: PPUSH
92712: LD_VAR 0 4
92716: PPUSH
92717: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
92721: LD_VAR 0 1
92725: PPUSH
92726: LD_VAR 0 2
92730: PPUSH
92731: LD_VAR 0 3
92735: PPUSH
92736: LD_VAR 0 5
92740: PPUSH
92741: CALL_OW 48
// end ;
92745: LD_VAR 0 6
92749: RET
// export function ToNaturalNumber ( number ) ; begin
92750: LD_INT 0
92752: PPUSH
// result := number div 1 ;
92753: LD_ADDR_VAR 0 2
92757: PUSH
92758: LD_VAR 0 1
92762: PUSH
92763: LD_INT 1
92765: DIV
92766: ST_TO_ADDR
// if number < 0 then
92767: LD_VAR 0 1
92771: PUSH
92772: LD_INT 0
92774: LESS
92775: IFFALSE 92785
// result := 0 ;
92777: LD_ADDR_VAR 0 2
92781: PUSH
92782: LD_INT 0
92784: ST_TO_ADDR
// end ;
92785: LD_VAR 0 2
92789: RET
// export function SortByClass ( units , class ) ; var un ; begin
92790: LD_INT 0
92792: PPUSH
92793: PPUSH
// if not units or not class then
92794: LD_VAR 0 1
92798: NOT
92799: PUSH
92800: LD_VAR 0 2
92804: NOT
92805: OR
92806: IFFALSE 92810
// exit ;
92808: GO 92905
// result := [ ] ;
92810: LD_ADDR_VAR 0 3
92814: PUSH
92815: EMPTY
92816: ST_TO_ADDR
// for un in units do
92817: LD_ADDR_VAR 0 4
92821: PUSH
92822: LD_VAR 0 1
92826: PUSH
92827: FOR_IN
92828: IFFALSE 92903
// if GetClass ( un ) = class then
92830: LD_VAR 0 4
92834: PPUSH
92835: CALL_OW 257
92839: PUSH
92840: LD_VAR 0 2
92844: EQUAL
92845: IFFALSE 92872
// result := Insert ( result , 1 , un ) else
92847: LD_ADDR_VAR 0 3
92851: PUSH
92852: LD_VAR 0 3
92856: PPUSH
92857: LD_INT 1
92859: PPUSH
92860: LD_VAR 0 4
92864: PPUSH
92865: CALL_OW 2
92869: ST_TO_ADDR
92870: GO 92901
// result := Replace ( result , result + 1 , un ) ;
92872: LD_ADDR_VAR 0 3
92876: PUSH
92877: LD_VAR 0 3
92881: PPUSH
92882: LD_VAR 0 3
92886: PUSH
92887: LD_INT 1
92889: PLUS
92890: PPUSH
92891: LD_VAR 0 4
92895: PPUSH
92896: CALL_OW 1
92900: ST_TO_ADDR
92901: GO 92827
92903: POP
92904: POP
// end ;
92905: LD_VAR 0 3
92909: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
92910: LD_INT 0
92912: PPUSH
92913: PPUSH
92914: PPUSH
92915: PPUSH
92916: PPUSH
92917: PPUSH
92918: PPUSH
// result := [ ] ;
92919: LD_ADDR_VAR 0 4
92923: PUSH
92924: EMPTY
92925: ST_TO_ADDR
// if x - r < 0 then
92926: LD_VAR 0 1
92930: PUSH
92931: LD_VAR 0 3
92935: MINUS
92936: PUSH
92937: LD_INT 0
92939: LESS
92940: IFFALSE 92952
// min_x := 0 else
92942: LD_ADDR_VAR 0 8
92946: PUSH
92947: LD_INT 0
92949: ST_TO_ADDR
92950: GO 92968
// min_x := x - r ;
92952: LD_ADDR_VAR 0 8
92956: PUSH
92957: LD_VAR 0 1
92961: PUSH
92962: LD_VAR 0 3
92966: MINUS
92967: ST_TO_ADDR
// if y - r < 0 then
92968: LD_VAR 0 2
92972: PUSH
92973: LD_VAR 0 3
92977: MINUS
92978: PUSH
92979: LD_INT 0
92981: LESS
92982: IFFALSE 92994
// min_y := 0 else
92984: LD_ADDR_VAR 0 7
92988: PUSH
92989: LD_INT 0
92991: ST_TO_ADDR
92992: GO 93010
// min_y := y - r ;
92994: LD_ADDR_VAR 0 7
92998: PUSH
92999: LD_VAR 0 2
93003: PUSH
93004: LD_VAR 0 3
93008: MINUS
93009: ST_TO_ADDR
// max_x := x + r ;
93010: LD_ADDR_VAR 0 9
93014: PUSH
93015: LD_VAR 0 1
93019: PUSH
93020: LD_VAR 0 3
93024: PLUS
93025: ST_TO_ADDR
// max_y := y + r ;
93026: LD_ADDR_VAR 0 10
93030: PUSH
93031: LD_VAR 0 2
93035: PUSH
93036: LD_VAR 0 3
93040: PLUS
93041: ST_TO_ADDR
// for _x = min_x to max_x do
93042: LD_ADDR_VAR 0 5
93046: PUSH
93047: DOUBLE
93048: LD_VAR 0 8
93052: DEC
93053: ST_TO_ADDR
93054: LD_VAR 0 9
93058: PUSH
93059: FOR_TO
93060: IFFALSE 93161
// for _y = min_y to max_y do
93062: LD_ADDR_VAR 0 6
93066: PUSH
93067: DOUBLE
93068: LD_VAR 0 7
93072: DEC
93073: ST_TO_ADDR
93074: LD_VAR 0 10
93078: PUSH
93079: FOR_TO
93080: IFFALSE 93157
// begin if not ValidHex ( _x , _y ) then
93082: LD_VAR 0 5
93086: PPUSH
93087: LD_VAR 0 6
93091: PPUSH
93092: CALL_OW 488
93096: NOT
93097: IFFALSE 93101
// continue ;
93099: GO 93079
// if GetResourceTypeXY ( _x , _y ) then
93101: LD_VAR 0 5
93105: PPUSH
93106: LD_VAR 0 6
93110: PPUSH
93111: CALL_OW 283
93115: IFFALSE 93155
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
93117: LD_ADDR_VAR 0 4
93121: PUSH
93122: LD_VAR 0 4
93126: PPUSH
93127: LD_VAR 0 4
93131: PUSH
93132: LD_INT 1
93134: PLUS
93135: PPUSH
93136: LD_VAR 0 5
93140: PUSH
93141: LD_VAR 0 6
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: PPUSH
93150: CALL_OW 1
93154: ST_TO_ADDR
// end ;
93155: GO 93079
93157: POP
93158: POP
93159: GO 93059
93161: POP
93162: POP
// end ;
93163: LD_VAR 0 4
93167: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
93168: LD_INT 0
93170: PPUSH
93171: PPUSH
93172: PPUSH
93173: PPUSH
93174: PPUSH
93175: PPUSH
93176: PPUSH
93177: PPUSH
// if not units then
93178: LD_VAR 0 1
93182: NOT
93183: IFFALSE 93187
// exit ;
93185: GO 93711
// result := UnitFilter ( units , [ f_ok ] ) ;
93187: LD_ADDR_VAR 0 3
93191: PUSH
93192: LD_VAR 0 1
93196: PPUSH
93197: LD_INT 50
93199: PUSH
93200: EMPTY
93201: LIST
93202: PPUSH
93203: CALL_OW 72
93207: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
93208: LD_ADDR_VAR 0 8
93212: PUSH
93213: LD_VAR 0 1
93217: PUSH
93218: LD_INT 1
93220: ARRAY
93221: PPUSH
93222: CALL_OW 255
93226: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
93227: LD_ADDR_VAR 0 10
93231: PUSH
93232: LD_INT 29
93234: PUSH
93235: LD_INT 91
93237: PUSH
93238: LD_INT 49
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: LIST
93245: ST_TO_ADDR
// if not result then
93246: LD_VAR 0 3
93250: NOT
93251: IFFALSE 93255
// exit ;
93253: GO 93711
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
93255: LD_ADDR_VAR 0 5
93259: PUSH
93260: LD_INT 81
93262: PUSH
93263: LD_VAR 0 8
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PPUSH
93272: CALL_OW 69
93276: ST_TO_ADDR
// for i in result do
93277: LD_ADDR_VAR 0 4
93281: PUSH
93282: LD_VAR 0 3
93286: PUSH
93287: FOR_IN
93288: IFFALSE 93709
// begin tag := GetTag ( i ) + 1 ;
93290: LD_ADDR_VAR 0 9
93294: PUSH
93295: LD_VAR 0 4
93299: PPUSH
93300: CALL_OW 110
93304: PUSH
93305: LD_INT 1
93307: PLUS
93308: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
93309: LD_ADDR_VAR 0 7
93313: PUSH
93314: LD_VAR 0 4
93318: PPUSH
93319: CALL_OW 250
93323: PPUSH
93324: LD_VAR 0 4
93328: PPUSH
93329: CALL_OW 251
93333: PPUSH
93334: LD_INT 6
93336: PPUSH
93337: CALL 92910 0 3
93341: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
93342: LD_VAR 0 4
93346: PPUSH
93347: CALL_OW 247
93351: PUSH
93352: LD_INT 2
93354: EQUAL
93355: PUSH
93356: LD_VAR 0 7
93360: AND
93361: PUSH
93362: LD_VAR 0 4
93366: PPUSH
93367: CALL_OW 264
93371: PUSH
93372: LD_VAR 0 10
93376: IN
93377: NOT
93378: AND
93379: IFFALSE 93418
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
93381: LD_VAR 0 4
93385: PPUSH
93386: LD_VAR 0 7
93390: PUSH
93391: LD_INT 1
93393: ARRAY
93394: PUSH
93395: LD_INT 1
93397: ARRAY
93398: PPUSH
93399: LD_VAR 0 7
93403: PUSH
93404: LD_INT 1
93406: ARRAY
93407: PUSH
93408: LD_INT 2
93410: ARRAY
93411: PPUSH
93412: CALL_OW 116
93416: GO 93707
// if path > tag then
93418: LD_VAR 0 2
93422: PUSH
93423: LD_VAR 0 9
93427: GREATER
93428: IFFALSE 93636
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
93430: LD_ADDR_VAR 0 6
93434: PUSH
93435: LD_VAR 0 5
93439: PPUSH
93440: LD_INT 91
93442: PUSH
93443: LD_VAR 0 4
93447: PUSH
93448: LD_INT 8
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: LIST
93455: PPUSH
93456: CALL_OW 72
93460: ST_TO_ADDR
// if nearEnemy then
93461: LD_VAR 0 6
93465: IFFALSE 93534
// begin if GetWeapon ( i ) = ru_time_lapser then
93467: LD_VAR 0 4
93471: PPUSH
93472: CALL_OW 264
93476: PUSH
93477: LD_INT 49
93479: EQUAL
93480: IFFALSE 93508
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
93482: LD_VAR 0 4
93486: PPUSH
93487: LD_VAR 0 6
93491: PPUSH
93492: LD_VAR 0 4
93496: PPUSH
93497: CALL_OW 74
93501: PPUSH
93502: CALL_OW 112
93506: GO 93532
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
93508: LD_VAR 0 4
93512: PPUSH
93513: LD_VAR 0 6
93517: PPUSH
93518: LD_VAR 0 4
93522: PPUSH
93523: CALL_OW 74
93527: PPUSH
93528: CALL 94636 0 2
// end else
93532: GO 93634
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
93534: LD_VAR 0 4
93538: PPUSH
93539: LD_VAR 0 2
93543: PUSH
93544: LD_VAR 0 9
93548: ARRAY
93549: PUSH
93550: LD_INT 1
93552: ARRAY
93553: PPUSH
93554: LD_VAR 0 2
93558: PUSH
93559: LD_VAR 0 9
93563: ARRAY
93564: PUSH
93565: LD_INT 2
93567: ARRAY
93568: PPUSH
93569: CALL_OW 297
93573: PUSH
93574: LD_INT 6
93576: GREATER
93577: IFFALSE 93620
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
93579: LD_VAR 0 4
93583: PPUSH
93584: LD_VAR 0 2
93588: PUSH
93589: LD_VAR 0 9
93593: ARRAY
93594: PUSH
93595: LD_INT 1
93597: ARRAY
93598: PPUSH
93599: LD_VAR 0 2
93603: PUSH
93604: LD_VAR 0 9
93608: ARRAY
93609: PUSH
93610: LD_INT 2
93612: ARRAY
93613: PPUSH
93614: CALL_OW 114
93618: GO 93634
// SetTag ( i , tag ) ;
93620: LD_VAR 0 4
93624: PPUSH
93625: LD_VAR 0 9
93629: PPUSH
93630: CALL_OW 109
// end else
93634: GO 93707
// if enemy then
93636: LD_VAR 0 5
93640: IFFALSE 93707
// begin if GetWeapon ( i ) = ru_time_lapser then
93642: LD_VAR 0 4
93646: PPUSH
93647: CALL_OW 264
93651: PUSH
93652: LD_INT 49
93654: EQUAL
93655: IFFALSE 93683
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
93657: LD_VAR 0 4
93661: PPUSH
93662: LD_VAR 0 5
93666: PPUSH
93667: LD_VAR 0 4
93671: PPUSH
93672: CALL_OW 74
93676: PPUSH
93677: CALL_OW 112
93681: GO 93707
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
93683: LD_VAR 0 4
93687: PPUSH
93688: LD_VAR 0 5
93692: PPUSH
93693: LD_VAR 0 4
93697: PPUSH
93698: CALL_OW 74
93702: PPUSH
93703: CALL 94636 0 2
// end ; end ;
93707: GO 93287
93709: POP
93710: POP
// end ;
93711: LD_VAR 0 3
93715: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
93716: LD_INT 0
93718: PPUSH
93719: PPUSH
93720: PPUSH
// if not unit or IsInUnit ( unit ) then
93721: LD_VAR 0 1
93725: NOT
93726: PUSH
93727: LD_VAR 0 1
93731: PPUSH
93732: CALL_OW 310
93736: OR
93737: IFFALSE 93741
// exit ;
93739: GO 93832
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
93741: LD_ADDR_VAR 0 4
93745: PUSH
93746: LD_VAR 0 1
93750: PPUSH
93751: CALL_OW 250
93755: PPUSH
93756: LD_VAR 0 2
93760: PPUSH
93761: LD_INT 1
93763: PPUSH
93764: CALL_OW 272
93768: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
93769: LD_ADDR_VAR 0 5
93773: PUSH
93774: LD_VAR 0 1
93778: PPUSH
93779: CALL_OW 251
93783: PPUSH
93784: LD_VAR 0 2
93788: PPUSH
93789: LD_INT 1
93791: PPUSH
93792: CALL_OW 273
93796: ST_TO_ADDR
// if ValidHex ( x , y ) then
93797: LD_VAR 0 4
93801: PPUSH
93802: LD_VAR 0 5
93806: PPUSH
93807: CALL_OW 488
93811: IFFALSE 93832
// ComTurnXY ( unit , x , y ) ;
93813: LD_VAR 0 1
93817: PPUSH
93818: LD_VAR 0 4
93822: PPUSH
93823: LD_VAR 0 5
93827: PPUSH
93828: CALL_OW 118
// end ;
93832: LD_VAR 0 3
93836: RET
// export function SeeUnits ( side , units ) ; var i ; begin
93837: LD_INT 0
93839: PPUSH
93840: PPUSH
// result := false ;
93841: LD_ADDR_VAR 0 3
93845: PUSH
93846: LD_INT 0
93848: ST_TO_ADDR
// if not units then
93849: LD_VAR 0 2
93853: NOT
93854: IFFALSE 93858
// exit ;
93856: GO 93903
// for i in units do
93858: LD_ADDR_VAR 0 4
93862: PUSH
93863: LD_VAR 0 2
93867: PUSH
93868: FOR_IN
93869: IFFALSE 93901
// if See ( side , i ) then
93871: LD_VAR 0 1
93875: PPUSH
93876: LD_VAR 0 4
93880: PPUSH
93881: CALL_OW 292
93885: IFFALSE 93899
// begin result := true ;
93887: LD_ADDR_VAR 0 3
93891: PUSH
93892: LD_INT 1
93894: ST_TO_ADDR
// exit ;
93895: POP
93896: POP
93897: GO 93903
// end ;
93899: GO 93868
93901: POP
93902: POP
// end ;
93903: LD_VAR 0 3
93907: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
93908: LD_INT 0
93910: PPUSH
93911: PPUSH
93912: PPUSH
93913: PPUSH
// if not unit or not points then
93914: LD_VAR 0 1
93918: NOT
93919: PUSH
93920: LD_VAR 0 2
93924: NOT
93925: OR
93926: IFFALSE 93930
// exit ;
93928: GO 94020
// dist := 99999 ;
93930: LD_ADDR_VAR 0 5
93934: PUSH
93935: LD_INT 99999
93937: ST_TO_ADDR
// for i in points do
93938: LD_ADDR_VAR 0 4
93942: PUSH
93943: LD_VAR 0 2
93947: PUSH
93948: FOR_IN
93949: IFFALSE 94018
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
93951: LD_ADDR_VAR 0 6
93955: PUSH
93956: LD_VAR 0 1
93960: PPUSH
93961: LD_VAR 0 4
93965: PUSH
93966: LD_INT 1
93968: ARRAY
93969: PPUSH
93970: LD_VAR 0 4
93974: PUSH
93975: LD_INT 2
93977: ARRAY
93978: PPUSH
93979: CALL_OW 297
93983: ST_TO_ADDR
// if tmpDist < dist then
93984: LD_VAR 0 6
93988: PUSH
93989: LD_VAR 0 5
93993: LESS
93994: IFFALSE 94016
// begin result := i ;
93996: LD_ADDR_VAR 0 3
94000: PUSH
94001: LD_VAR 0 4
94005: ST_TO_ADDR
// dist := tmpDist ;
94006: LD_ADDR_VAR 0 5
94010: PUSH
94011: LD_VAR 0 6
94015: ST_TO_ADDR
// end ; end ;
94016: GO 93948
94018: POP
94019: POP
// end ;
94020: LD_VAR 0 3
94024: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
94025: LD_INT 0
94027: PPUSH
// uc_side := side ;
94028: LD_ADDR_OWVAR 20
94032: PUSH
94033: LD_VAR 0 1
94037: ST_TO_ADDR
// uc_nation := 3 ;
94038: LD_ADDR_OWVAR 21
94042: PUSH
94043: LD_INT 3
94045: ST_TO_ADDR
// vc_chassis := 25 ;
94046: LD_ADDR_OWVAR 37
94050: PUSH
94051: LD_INT 25
94053: ST_TO_ADDR
// vc_engine := engine_siberite ;
94054: LD_ADDR_OWVAR 39
94058: PUSH
94059: LD_INT 3
94061: ST_TO_ADDR
// vc_control := control_computer ;
94062: LD_ADDR_OWVAR 38
94066: PUSH
94067: LD_INT 3
94069: ST_TO_ADDR
// vc_weapon := 59 ;
94070: LD_ADDR_OWVAR 40
94074: PUSH
94075: LD_INT 59
94077: ST_TO_ADDR
// result := CreateVehicle ;
94078: LD_ADDR_VAR 0 5
94082: PUSH
94083: CALL_OW 45
94087: ST_TO_ADDR
// SetDir ( result , d ) ;
94088: LD_VAR 0 5
94092: PPUSH
94093: LD_VAR 0 4
94097: PPUSH
94098: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
94102: LD_VAR 0 5
94106: PPUSH
94107: LD_VAR 0 2
94111: PPUSH
94112: LD_VAR 0 3
94116: PPUSH
94117: LD_INT 0
94119: PPUSH
94120: CALL_OW 48
// end ;
94124: LD_VAR 0 5
94128: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
94129: LD_INT 0
94131: PPUSH
94132: PPUSH
94133: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
94134: LD_ADDR_VAR 0 2
94138: PUSH
94139: LD_INT 0
94141: PUSH
94142: LD_INT 0
94144: PUSH
94145: LD_INT 0
94147: PUSH
94148: LD_INT 0
94150: PUSH
94151: EMPTY
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
94157: LD_VAR 0 1
94161: NOT
94162: PUSH
94163: LD_VAR 0 1
94167: PPUSH
94168: CALL_OW 264
94172: PUSH
94173: LD_INT 12
94175: PUSH
94176: LD_INT 51
94178: PUSH
94179: LD_INT 32
94181: PUSH
94182: LD_INT 89
94184: PUSH
94185: EMPTY
94186: LIST
94187: LIST
94188: LIST
94189: LIST
94190: IN
94191: NOT
94192: OR
94193: IFFALSE 94197
// exit ;
94195: GO 94295
// for i := 1 to 3 do
94197: LD_ADDR_VAR 0 3
94201: PUSH
94202: DOUBLE
94203: LD_INT 1
94205: DEC
94206: ST_TO_ADDR
94207: LD_INT 3
94209: PUSH
94210: FOR_TO
94211: IFFALSE 94293
// begin tmp := GetCargo ( cargo , i ) ;
94213: LD_ADDR_VAR 0 4
94217: PUSH
94218: LD_VAR 0 1
94222: PPUSH
94223: LD_VAR 0 3
94227: PPUSH
94228: CALL_OW 289
94232: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
94233: LD_ADDR_VAR 0 2
94237: PUSH
94238: LD_VAR 0 2
94242: PPUSH
94243: LD_VAR 0 3
94247: PPUSH
94248: LD_VAR 0 4
94252: PPUSH
94253: CALL_OW 1
94257: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
94258: LD_ADDR_VAR 0 2
94262: PUSH
94263: LD_VAR 0 2
94267: PPUSH
94268: LD_INT 4
94270: PPUSH
94271: LD_VAR 0 2
94275: PUSH
94276: LD_INT 4
94278: ARRAY
94279: PUSH
94280: LD_VAR 0 4
94284: PLUS
94285: PPUSH
94286: CALL_OW 1
94290: ST_TO_ADDR
// end ;
94291: GO 94210
94293: POP
94294: POP
// end ;
94295: LD_VAR 0 2
94299: RET
// export function Length ( array ) ; begin
94300: LD_INT 0
94302: PPUSH
// result := array + 0 ;
94303: LD_ADDR_VAR 0 2
94307: PUSH
94308: LD_VAR 0 1
94312: PUSH
94313: LD_INT 0
94315: PLUS
94316: ST_TO_ADDR
// end ;
94317: LD_VAR 0 2
94321: RET
// export function PrepareArray ( array ) ; begin
94322: LD_INT 0
94324: PPUSH
// result := array diff 0 ;
94325: LD_ADDR_VAR 0 2
94329: PUSH
94330: LD_VAR 0 1
94334: PUSH
94335: LD_INT 0
94337: DIFF
94338: ST_TO_ADDR
// if not result [ 1 ] then
94339: LD_VAR 0 2
94343: PUSH
94344: LD_INT 1
94346: ARRAY
94347: NOT
94348: IFFALSE 94368
// result := Delete ( result , 1 ) ;
94350: LD_ADDR_VAR 0 2
94354: PUSH
94355: LD_VAR 0 2
94359: PPUSH
94360: LD_INT 1
94362: PPUSH
94363: CALL_OW 3
94367: ST_TO_ADDR
// end ;
94368: LD_VAR 0 2
94372: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
94373: LD_INT 0
94375: PPUSH
94376: PPUSH
94377: PPUSH
94378: PPUSH
// sibRocketRange := 25 ;
94379: LD_ADDR_VAR 0 6
94383: PUSH
94384: LD_INT 25
94386: ST_TO_ADDR
// result := false ;
94387: LD_ADDR_VAR 0 4
94391: PUSH
94392: LD_INT 0
94394: ST_TO_ADDR
// for i := 0 to 5 do
94395: LD_ADDR_VAR 0 5
94399: PUSH
94400: DOUBLE
94401: LD_INT 0
94403: DEC
94404: ST_TO_ADDR
94405: LD_INT 5
94407: PUSH
94408: FOR_TO
94409: IFFALSE 94476
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
94411: LD_VAR 0 1
94415: PPUSH
94416: LD_VAR 0 5
94420: PPUSH
94421: LD_VAR 0 6
94425: PPUSH
94426: CALL_OW 272
94430: PPUSH
94431: LD_VAR 0 2
94435: PPUSH
94436: LD_VAR 0 5
94440: PPUSH
94441: LD_VAR 0 6
94445: PPUSH
94446: CALL_OW 273
94450: PPUSH
94451: LD_VAR 0 3
94455: PPUSH
94456: CALL_OW 309
94460: IFFALSE 94474
// begin result := true ;
94462: LD_ADDR_VAR 0 4
94466: PUSH
94467: LD_INT 1
94469: ST_TO_ADDR
// exit ;
94470: POP
94471: POP
94472: GO 94478
// end ;
94474: GO 94408
94476: POP
94477: POP
// end ;
94478: LD_VAR 0 4
94482: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
94483: LD_INT 0
94485: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
94486: LD_VAR 0 1
94490: PPUSH
94491: LD_VAR 0 2
94495: PPUSH
94496: LD_INT 0
94498: PPUSH
94499: LD_INT 0
94501: PPUSH
94502: LD_INT 1
94504: PPUSH
94505: LD_INT 0
94507: PPUSH
94508: CALL_OW 587
// end ;
94512: LD_VAR 0 3
94516: RET
// export function CenterOnNow ( unit ) ; begin
94517: LD_INT 0
94519: PPUSH
// result := IsInUnit ( unit ) ;
94520: LD_ADDR_VAR 0 2
94524: PUSH
94525: LD_VAR 0 1
94529: PPUSH
94530: CALL_OW 310
94534: ST_TO_ADDR
// if not result then
94535: LD_VAR 0 2
94539: NOT
94540: IFFALSE 94552
// result := unit ;
94542: LD_ADDR_VAR 0 2
94546: PUSH
94547: LD_VAR 0 1
94551: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
94552: LD_VAR 0 1
94556: PPUSH
94557: CALL_OW 87
// end ;
94561: LD_VAR 0 2
94565: RET
// export function ComMoveHex ( unit , hex ) ; begin
94566: LD_INT 0
94568: PPUSH
// if not hex then
94569: LD_VAR 0 2
94573: NOT
94574: IFFALSE 94578
// exit ;
94576: GO 94631
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
94578: LD_VAR 0 2
94582: PUSH
94583: LD_INT 1
94585: ARRAY
94586: PPUSH
94587: LD_VAR 0 2
94591: PUSH
94592: LD_INT 2
94594: ARRAY
94595: PPUSH
94596: CALL_OW 428
94600: IFFALSE 94604
// exit ;
94602: GO 94631
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
94604: LD_VAR 0 1
94608: PPUSH
94609: LD_VAR 0 2
94613: PUSH
94614: LD_INT 1
94616: ARRAY
94617: PPUSH
94618: LD_VAR 0 2
94622: PUSH
94623: LD_INT 2
94625: ARRAY
94626: PPUSH
94627: CALL_OW 111
// end ;
94631: LD_VAR 0 3
94635: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
94636: LD_INT 0
94638: PPUSH
94639: PPUSH
94640: PPUSH
// if not unit or not enemy then
94641: LD_VAR 0 1
94645: NOT
94646: PUSH
94647: LD_VAR 0 2
94651: NOT
94652: OR
94653: IFFALSE 94657
// exit ;
94655: GO 94781
// x := GetX ( enemy ) ;
94657: LD_ADDR_VAR 0 4
94661: PUSH
94662: LD_VAR 0 2
94666: PPUSH
94667: CALL_OW 250
94671: ST_TO_ADDR
// y := GetY ( enemy ) ;
94672: LD_ADDR_VAR 0 5
94676: PUSH
94677: LD_VAR 0 2
94681: PPUSH
94682: CALL_OW 251
94686: ST_TO_ADDR
// if ValidHex ( x , y ) then
94687: LD_VAR 0 4
94691: PPUSH
94692: LD_VAR 0 5
94696: PPUSH
94697: CALL_OW 488
94701: IFFALSE 94781
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
94703: LD_VAR 0 2
94707: PPUSH
94708: CALL_OW 247
94712: PUSH
94713: LD_INT 3
94715: PUSH
94716: LD_INT 2
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: IN
94723: PUSH
94724: LD_VAR 0 1
94728: PPUSH
94729: CALL_OW 255
94733: PPUSH
94734: LD_VAR 0 2
94738: PPUSH
94739: CALL_OW 292
94743: AND
94744: IFFALSE 94762
// ComAttackUnit ( unit , enemy ) else
94746: LD_VAR 0 1
94750: PPUSH
94751: LD_VAR 0 2
94755: PPUSH
94756: CALL_OW 115
94760: GO 94781
// ComAgressiveMove ( unit , x , y ) ;
94762: LD_VAR 0 1
94766: PPUSH
94767: LD_VAR 0 4
94771: PPUSH
94772: LD_VAR 0 5
94776: PPUSH
94777: CALL_OW 114
// end ; end_of_file end_of_file
94781: LD_VAR 0 3
94785: RET
// export globalGameSaveCounter ; every 0 0$1 do
94786: GO 94788
94788: DISABLE
// begin enable ;
94789: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94790: LD_STRING updateTimer(
94792: PUSH
94793: LD_OWVAR 1
94797: STR
94798: PUSH
94799: LD_STRING );
94801: STR
94802: PPUSH
94803: CALL_OW 559
// end ;
94807: END
// every 0 0$1 do
94808: GO 94810
94810: DISABLE
// begin globalGameSaveCounter := 0 ;
94811: LD_ADDR_EXP 123
94815: PUSH
94816: LD_INT 0
94818: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
94819: LD_STRING setGameSaveCounter(0)
94821: PPUSH
94822: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
94826: LD_STRING initStreamRollete();
94828: PPUSH
94829: CALL_OW 559
// InitStreamMode ;
94833: CALL 96159 0 0
// DefineStreamItems ( false ) ;
94837: LD_INT 0
94839: PPUSH
94840: CALL 96623 0 1
// end ;
94844: END
// export function SOS_MapStart ( ) ; begin
94845: LD_INT 0
94847: PPUSH
// if streamModeActive then
94848: LD_EXP 124
94852: IFFALSE 94861
// DefineStreamItems ( true ) ;
94854: LD_INT 1
94856: PPUSH
94857: CALL 96623 0 1
// UpdateLuaVariables ( ) ;
94861: CALL 94878 0 0
// UpdateFactoryWaypoints ( ) ;
94865: CALL 109492 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94869: CALL 109749 0 0
// end ;
94873: LD_VAR 0 1
94877: RET
// function UpdateLuaVariables ( ) ; begin
94878: LD_INT 0
94880: PPUSH
// if globalGameSaveCounter then
94881: LD_EXP 123
94885: IFFALSE 94919
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
94887: LD_ADDR_EXP 123
94891: PUSH
94892: LD_EXP 123
94896: PPUSH
94897: CALL 91925 0 1
94901: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94902: LD_STRING setGameSaveCounter(
94904: PUSH
94905: LD_EXP 123
94909: STR
94910: PUSH
94911: LD_STRING )
94913: STR
94914: PPUSH
94915: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
94919: LD_STRING setGameDifficulty(
94921: PUSH
94922: LD_OWVAR 67
94926: STR
94927: PUSH
94928: LD_STRING )
94930: STR
94931: PPUSH
94932: CALL_OW 559
// end ;
94936: LD_VAR 0 1
94940: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94941: LD_INT 0
94943: PPUSH
// if p2 = stream_mode then
94944: LD_VAR 0 2
94948: PUSH
94949: LD_INT 100
94951: EQUAL
94952: IFFALSE 95955
// begin if not StreamModeActive then
94954: LD_EXP 124
94958: NOT
94959: IFFALSE 94969
// StreamModeActive := true ;
94961: LD_ADDR_EXP 124
94965: PUSH
94966: LD_INT 1
94968: ST_TO_ADDR
// if p3 = 0 then
94969: LD_VAR 0 3
94973: PUSH
94974: LD_INT 0
94976: EQUAL
94977: IFFALSE 94983
// InitStreamMode ;
94979: CALL 96159 0 0
// if p3 = 1 then
94983: LD_VAR 0 3
94987: PUSH
94988: LD_INT 1
94990: EQUAL
94991: IFFALSE 95001
// sRocket := true ;
94993: LD_ADDR_EXP 129
94997: PUSH
94998: LD_INT 1
95000: ST_TO_ADDR
// if p3 = 2 then
95001: LD_VAR 0 3
95005: PUSH
95006: LD_INT 2
95008: EQUAL
95009: IFFALSE 95019
// sSpeed := true ;
95011: LD_ADDR_EXP 128
95015: PUSH
95016: LD_INT 1
95018: ST_TO_ADDR
// if p3 = 3 then
95019: LD_VAR 0 3
95023: PUSH
95024: LD_INT 3
95026: EQUAL
95027: IFFALSE 95037
// sEngine := true ;
95029: LD_ADDR_EXP 130
95033: PUSH
95034: LD_INT 1
95036: ST_TO_ADDR
// if p3 = 4 then
95037: LD_VAR 0 3
95041: PUSH
95042: LD_INT 4
95044: EQUAL
95045: IFFALSE 95055
// sSpec := true ;
95047: LD_ADDR_EXP 127
95051: PUSH
95052: LD_INT 1
95054: ST_TO_ADDR
// if p3 = 5 then
95055: LD_VAR 0 3
95059: PUSH
95060: LD_INT 5
95062: EQUAL
95063: IFFALSE 95073
// sLevel := true ;
95065: LD_ADDR_EXP 131
95069: PUSH
95070: LD_INT 1
95072: ST_TO_ADDR
// if p3 = 6 then
95073: LD_VAR 0 3
95077: PUSH
95078: LD_INT 6
95080: EQUAL
95081: IFFALSE 95091
// sArmoury := true ;
95083: LD_ADDR_EXP 132
95087: PUSH
95088: LD_INT 1
95090: ST_TO_ADDR
// if p3 = 7 then
95091: LD_VAR 0 3
95095: PUSH
95096: LD_INT 7
95098: EQUAL
95099: IFFALSE 95109
// sRadar := true ;
95101: LD_ADDR_EXP 133
95105: PUSH
95106: LD_INT 1
95108: ST_TO_ADDR
// if p3 = 8 then
95109: LD_VAR 0 3
95113: PUSH
95114: LD_INT 8
95116: EQUAL
95117: IFFALSE 95127
// sBunker := true ;
95119: LD_ADDR_EXP 134
95123: PUSH
95124: LD_INT 1
95126: ST_TO_ADDR
// if p3 = 9 then
95127: LD_VAR 0 3
95131: PUSH
95132: LD_INT 9
95134: EQUAL
95135: IFFALSE 95145
// sHack := true ;
95137: LD_ADDR_EXP 135
95141: PUSH
95142: LD_INT 1
95144: ST_TO_ADDR
// if p3 = 10 then
95145: LD_VAR 0 3
95149: PUSH
95150: LD_INT 10
95152: EQUAL
95153: IFFALSE 95163
// sFire := true ;
95155: LD_ADDR_EXP 136
95159: PUSH
95160: LD_INT 1
95162: ST_TO_ADDR
// if p3 = 11 then
95163: LD_VAR 0 3
95167: PUSH
95168: LD_INT 11
95170: EQUAL
95171: IFFALSE 95181
// sRefresh := true ;
95173: LD_ADDR_EXP 137
95177: PUSH
95178: LD_INT 1
95180: ST_TO_ADDR
// if p3 = 12 then
95181: LD_VAR 0 3
95185: PUSH
95186: LD_INT 12
95188: EQUAL
95189: IFFALSE 95199
// sExp := true ;
95191: LD_ADDR_EXP 138
95195: PUSH
95196: LD_INT 1
95198: ST_TO_ADDR
// if p3 = 13 then
95199: LD_VAR 0 3
95203: PUSH
95204: LD_INT 13
95206: EQUAL
95207: IFFALSE 95217
// sDepot := true ;
95209: LD_ADDR_EXP 139
95213: PUSH
95214: LD_INT 1
95216: ST_TO_ADDR
// if p3 = 14 then
95217: LD_VAR 0 3
95221: PUSH
95222: LD_INT 14
95224: EQUAL
95225: IFFALSE 95235
// sFlag := true ;
95227: LD_ADDR_EXP 140
95231: PUSH
95232: LD_INT 1
95234: ST_TO_ADDR
// if p3 = 15 then
95235: LD_VAR 0 3
95239: PUSH
95240: LD_INT 15
95242: EQUAL
95243: IFFALSE 95253
// sKamikadze := true ;
95245: LD_ADDR_EXP 148
95249: PUSH
95250: LD_INT 1
95252: ST_TO_ADDR
// if p3 = 16 then
95253: LD_VAR 0 3
95257: PUSH
95258: LD_INT 16
95260: EQUAL
95261: IFFALSE 95271
// sTroll := true ;
95263: LD_ADDR_EXP 149
95267: PUSH
95268: LD_INT 1
95270: ST_TO_ADDR
// if p3 = 17 then
95271: LD_VAR 0 3
95275: PUSH
95276: LD_INT 17
95278: EQUAL
95279: IFFALSE 95289
// sSlow := true ;
95281: LD_ADDR_EXP 150
95285: PUSH
95286: LD_INT 1
95288: ST_TO_ADDR
// if p3 = 18 then
95289: LD_VAR 0 3
95293: PUSH
95294: LD_INT 18
95296: EQUAL
95297: IFFALSE 95307
// sLack := true ;
95299: LD_ADDR_EXP 151
95303: PUSH
95304: LD_INT 1
95306: ST_TO_ADDR
// if p3 = 19 then
95307: LD_VAR 0 3
95311: PUSH
95312: LD_INT 19
95314: EQUAL
95315: IFFALSE 95325
// sTank := true ;
95317: LD_ADDR_EXP 153
95321: PUSH
95322: LD_INT 1
95324: ST_TO_ADDR
// if p3 = 20 then
95325: LD_VAR 0 3
95329: PUSH
95330: LD_INT 20
95332: EQUAL
95333: IFFALSE 95343
// sRemote := true ;
95335: LD_ADDR_EXP 154
95339: PUSH
95340: LD_INT 1
95342: ST_TO_ADDR
// if p3 = 21 then
95343: LD_VAR 0 3
95347: PUSH
95348: LD_INT 21
95350: EQUAL
95351: IFFALSE 95361
// sPowell := true ;
95353: LD_ADDR_EXP 155
95357: PUSH
95358: LD_INT 1
95360: ST_TO_ADDR
// if p3 = 22 then
95361: LD_VAR 0 3
95365: PUSH
95366: LD_INT 22
95368: EQUAL
95369: IFFALSE 95379
// sTeleport := true ;
95371: LD_ADDR_EXP 158
95375: PUSH
95376: LD_INT 1
95378: ST_TO_ADDR
// if p3 = 23 then
95379: LD_VAR 0 3
95383: PUSH
95384: LD_INT 23
95386: EQUAL
95387: IFFALSE 95397
// sOilTower := true ;
95389: LD_ADDR_EXP 160
95393: PUSH
95394: LD_INT 1
95396: ST_TO_ADDR
// if p3 = 24 then
95397: LD_VAR 0 3
95401: PUSH
95402: LD_INT 24
95404: EQUAL
95405: IFFALSE 95415
// sShovel := true ;
95407: LD_ADDR_EXP 161
95411: PUSH
95412: LD_INT 1
95414: ST_TO_ADDR
// if p3 = 25 then
95415: LD_VAR 0 3
95419: PUSH
95420: LD_INT 25
95422: EQUAL
95423: IFFALSE 95433
// sSheik := true ;
95425: LD_ADDR_EXP 162
95429: PUSH
95430: LD_INT 1
95432: ST_TO_ADDR
// if p3 = 26 then
95433: LD_VAR 0 3
95437: PUSH
95438: LD_INT 26
95440: EQUAL
95441: IFFALSE 95451
// sEarthquake := true ;
95443: LD_ADDR_EXP 164
95447: PUSH
95448: LD_INT 1
95450: ST_TO_ADDR
// if p3 = 27 then
95451: LD_VAR 0 3
95455: PUSH
95456: LD_INT 27
95458: EQUAL
95459: IFFALSE 95469
// sAI := true ;
95461: LD_ADDR_EXP 165
95465: PUSH
95466: LD_INT 1
95468: ST_TO_ADDR
// if p3 = 28 then
95469: LD_VAR 0 3
95473: PUSH
95474: LD_INT 28
95476: EQUAL
95477: IFFALSE 95487
// sCargo := true ;
95479: LD_ADDR_EXP 168
95483: PUSH
95484: LD_INT 1
95486: ST_TO_ADDR
// if p3 = 29 then
95487: LD_VAR 0 3
95491: PUSH
95492: LD_INT 29
95494: EQUAL
95495: IFFALSE 95505
// sDLaser := true ;
95497: LD_ADDR_EXP 169
95501: PUSH
95502: LD_INT 1
95504: ST_TO_ADDR
// if p3 = 30 then
95505: LD_VAR 0 3
95509: PUSH
95510: LD_INT 30
95512: EQUAL
95513: IFFALSE 95523
// sExchange := true ;
95515: LD_ADDR_EXP 170
95519: PUSH
95520: LD_INT 1
95522: ST_TO_ADDR
// if p3 = 31 then
95523: LD_VAR 0 3
95527: PUSH
95528: LD_INT 31
95530: EQUAL
95531: IFFALSE 95541
// sFac := true ;
95533: LD_ADDR_EXP 171
95537: PUSH
95538: LD_INT 1
95540: ST_TO_ADDR
// if p3 = 32 then
95541: LD_VAR 0 3
95545: PUSH
95546: LD_INT 32
95548: EQUAL
95549: IFFALSE 95559
// sPower := true ;
95551: LD_ADDR_EXP 172
95555: PUSH
95556: LD_INT 1
95558: ST_TO_ADDR
// if p3 = 33 then
95559: LD_VAR 0 3
95563: PUSH
95564: LD_INT 33
95566: EQUAL
95567: IFFALSE 95577
// sRandom := true ;
95569: LD_ADDR_EXP 173
95573: PUSH
95574: LD_INT 1
95576: ST_TO_ADDR
// if p3 = 34 then
95577: LD_VAR 0 3
95581: PUSH
95582: LD_INT 34
95584: EQUAL
95585: IFFALSE 95595
// sShield := true ;
95587: LD_ADDR_EXP 174
95591: PUSH
95592: LD_INT 1
95594: ST_TO_ADDR
// if p3 = 35 then
95595: LD_VAR 0 3
95599: PUSH
95600: LD_INT 35
95602: EQUAL
95603: IFFALSE 95613
// sTime := true ;
95605: LD_ADDR_EXP 175
95609: PUSH
95610: LD_INT 1
95612: ST_TO_ADDR
// if p3 = 36 then
95613: LD_VAR 0 3
95617: PUSH
95618: LD_INT 36
95620: EQUAL
95621: IFFALSE 95631
// sTools := true ;
95623: LD_ADDR_EXP 176
95627: PUSH
95628: LD_INT 1
95630: ST_TO_ADDR
// if p3 = 101 then
95631: LD_VAR 0 3
95635: PUSH
95636: LD_INT 101
95638: EQUAL
95639: IFFALSE 95649
// sSold := true ;
95641: LD_ADDR_EXP 141
95645: PUSH
95646: LD_INT 1
95648: ST_TO_ADDR
// if p3 = 102 then
95649: LD_VAR 0 3
95653: PUSH
95654: LD_INT 102
95656: EQUAL
95657: IFFALSE 95667
// sDiff := true ;
95659: LD_ADDR_EXP 142
95663: PUSH
95664: LD_INT 1
95666: ST_TO_ADDR
// if p3 = 103 then
95667: LD_VAR 0 3
95671: PUSH
95672: LD_INT 103
95674: EQUAL
95675: IFFALSE 95685
// sFog := true ;
95677: LD_ADDR_EXP 145
95681: PUSH
95682: LD_INT 1
95684: ST_TO_ADDR
// if p3 = 104 then
95685: LD_VAR 0 3
95689: PUSH
95690: LD_INT 104
95692: EQUAL
95693: IFFALSE 95703
// sReset := true ;
95695: LD_ADDR_EXP 146
95699: PUSH
95700: LD_INT 1
95702: ST_TO_ADDR
// if p3 = 105 then
95703: LD_VAR 0 3
95707: PUSH
95708: LD_INT 105
95710: EQUAL
95711: IFFALSE 95721
// sSun := true ;
95713: LD_ADDR_EXP 147
95717: PUSH
95718: LD_INT 1
95720: ST_TO_ADDR
// if p3 = 106 then
95721: LD_VAR 0 3
95725: PUSH
95726: LD_INT 106
95728: EQUAL
95729: IFFALSE 95739
// sTiger := true ;
95731: LD_ADDR_EXP 143
95735: PUSH
95736: LD_INT 1
95738: ST_TO_ADDR
// if p3 = 107 then
95739: LD_VAR 0 3
95743: PUSH
95744: LD_INT 107
95746: EQUAL
95747: IFFALSE 95757
// sBomb := true ;
95749: LD_ADDR_EXP 144
95753: PUSH
95754: LD_INT 1
95756: ST_TO_ADDR
// if p3 = 108 then
95757: LD_VAR 0 3
95761: PUSH
95762: LD_INT 108
95764: EQUAL
95765: IFFALSE 95775
// sWound := true ;
95767: LD_ADDR_EXP 152
95771: PUSH
95772: LD_INT 1
95774: ST_TO_ADDR
// if p3 = 109 then
95775: LD_VAR 0 3
95779: PUSH
95780: LD_INT 109
95782: EQUAL
95783: IFFALSE 95793
// sBetray := true ;
95785: LD_ADDR_EXP 156
95789: PUSH
95790: LD_INT 1
95792: ST_TO_ADDR
// if p3 = 110 then
95793: LD_VAR 0 3
95797: PUSH
95798: LD_INT 110
95800: EQUAL
95801: IFFALSE 95811
// sContamin := true ;
95803: LD_ADDR_EXP 157
95807: PUSH
95808: LD_INT 1
95810: ST_TO_ADDR
// if p3 = 111 then
95811: LD_VAR 0 3
95815: PUSH
95816: LD_INT 111
95818: EQUAL
95819: IFFALSE 95829
// sOil := true ;
95821: LD_ADDR_EXP 159
95825: PUSH
95826: LD_INT 1
95828: ST_TO_ADDR
// if p3 = 112 then
95829: LD_VAR 0 3
95833: PUSH
95834: LD_INT 112
95836: EQUAL
95837: IFFALSE 95847
// sStu := true ;
95839: LD_ADDR_EXP 163
95843: PUSH
95844: LD_INT 1
95846: ST_TO_ADDR
// if p3 = 113 then
95847: LD_VAR 0 3
95851: PUSH
95852: LD_INT 113
95854: EQUAL
95855: IFFALSE 95865
// sBazooka := true ;
95857: LD_ADDR_EXP 166
95861: PUSH
95862: LD_INT 1
95864: ST_TO_ADDR
// if p3 = 114 then
95865: LD_VAR 0 3
95869: PUSH
95870: LD_INT 114
95872: EQUAL
95873: IFFALSE 95883
// sMortar := true ;
95875: LD_ADDR_EXP 167
95879: PUSH
95880: LD_INT 1
95882: ST_TO_ADDR
// if p3 = 115 then
95883: LD_VAR 0 3
95887: PUSH
95888: LD_INT 115
95890: EQUAL
95891: IFFALSE 95901
// sRanger := true ;
95893: LD_ADDR_EXP 177
95897: PUSH
95898: LD_INT 1
95900: ST_TO_ADDR
// if p3 = 116 then
95901: LD_VAR 0 3
95905: PUSH
95906: LD_INT 116
95908: EQUAL
95909: IFFALSE 95919
// sComputer := true ;
95911: LD_ADDR_EXP 178
95915: PUSH
95916: LD_INT 1
95918: ST_TO_ADDR
// if p3 = 117 then
95919: LD_VAR 0 3
95923: PUSH
95924: LD_INT 117
95926: EQUAL
95927: IFFALSE 95937
// s30 := true ;
95929: LD_ADDR_EXP 179
95933: PUSH
95934: LD_INT 1
95936: ST_TO_ADDR
// if p3 = 118 then
95937: LD_VAR 0 3
95941: PUSH
95942: LD_INT 118
95944: EQUAL
95945: IFFALSE 95955
// s60 := true ;
95947: LD_ADDR_EXP 180
95951: PUSH
95952: LD_INT 1
95954: ST_TO_ADDR
// end ; if p2 = hack_mode then
95955: LD_VAR 0 2
95959: PUSH
95960: LD_INT 101
95962: EQUAL
95963: IFFALSE 96091
// begin case p3 of 1 :
95965: LD_VAR 0 3
95969: PUSH
95970: LD_INT 1
95972: DOUBLE
95973: EQUAL
95974: IFTRUE 95978
95976: GO 95985
95978: POP
// hHackUnlimitedResources ; 2 :
95979: CALL 108238 0 0
95983: GO 96091
95985: LD_INT 2
95987: DOUBLE
95988: EQUAL
95989: IFTRUE 95993
95991: GO 96000
95993: POP
// hHackSetLevel10 ; 3 :
95994: CALL 108371 0 0
95998: GO 96091
96000: LD_INT 3
96002: DOUBLE
96003: EQUAL
96004: IFTRUE 96008
96006: GO 96015
96008: POP
// hHackSetLevel10YourUnits ; 4 :
96009: CALL 108456 0 0
96013: GO 96091
96015: LD_INT 4
96017: DOUBLE
96018: EQUAL
96019: IFTRUE 96023
96021: GO 96030
96023: POP
// hHackInvincible ; 5 :
96024: CALL 108904 0 0
96028: GO 96091
96030: LD_INT 5
96032: DOUBLE
96033: EQUAL
96034: IFTRUE 96038
96036: GO 96045
96038: POP
// hHackInvisible ; 6 :
96039: CALL 109015 0 0
96043: GO 96091
96045: LD_INT 6
96047: DOUBLE
96048: EQUAL
96049: IFTRUE 96053
96051: GO 96060
96053: POP
// hHackChangeYourSide ; 7 :
96054: CALL 109072 0 0
96058: GO 96091
96060: LD_INT 7
96062: DOUBLE
96063: EQUAL
96064: IFTRUE 96068
96066: GO 96075
96068: POP
// hHackChangeUnitSide ; 8 :
96069: CALL 109114 0 0
96073: GO 96091
96075: LD_INT 8
96077: DOUBLE
96078: EQUAL
96079: IFTRUE 96083
96081: GO 96090
96083: POP
// hHackFog ; end ;
96084: CALL 109215 0 0
96088: GO 96091
96090: POP
// end ; if p2 = game_save_mode then
96091: LD_VAR 0 2
96095: PUSH
96096: LD_INT 102
96098: EQUAL
96099: IFFALSE 96154
// begin if p3 = 1 then
96101: LD_VAR 0 3
96105: PUSH
96106: LD_INT 1
96108: EQUAL
96109: IFFALSE 96121
// globalGameSaveCounter := p4 ;
96111: LD_ADDR_EXP 123
96115: PUSH
96116: LD_VAR 0 4
96120: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
96121: LD_VAR 0 3
96125: PUSH
96126: LD_INT 2
96128: EQUAL
96129: PUSH
96130: LD_EXP 123
96134: AND
96135: IFFALSE 96154
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96137: LD_STRING setGameSaveCounter(
96139: PUSH
96140: LD_EXP 123
96144: STR
96145: PUSH
96146: LD_STRING )
96148: STR
96149: PPUSH
96150: CALL_OW 559
// end ; end ;
96154: LD_VAR 0 7
96158: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
96159: LD_INT 0
96161: PPUSH
// streamModeActive := false ;
96162: LD_ADDR_EXP 124
96166: PUSH
96167: LD_INT 0
96169: ST_TO_ADDR
// normalCounter := 36 ;
96170: LD_ADDR_EXP 125
96174: PUSH
96175: LD_INT 36
96177: ST_TO_ADDR
// hardcoreCounter := 18 ;
96178: LD_ADDR_EXP 126
96182: PUSH
96183: LD_INT 18
96185: ST_TO_ADDR
// sRocket := false ;
96186: LD_ADDR_EXP 129
96190: PUSH
96191: LD_INT 0
96193: ST_TO_ADDR
// sSpeed := false ;
96194: LD_ADDR_EXP 128
96198: PUSH
96199: LD_INT 0
96201: ST_TO_ADDR
// sEngine := false ;
96202: LD_ADDR_EXP 130
96206: PUSH
96207: LD_INT 0
96209: ST_TO_ADDR
// sSpec := false ;
96210: LD_ADDR_EXP 127
96214: PUSH
96215: LD_INT 0
96217: ST_TO_ADDR
// sLevel := false ;
96218: LD_ADDR_EXP 131
96222: PUSH
96223: LD_INT 0
96225: ST_TO_ADDR
// sArmoury := false ;
96226: LD_ADDR_EXP 132
96230: PUSH
96231: LD_INT 0
96233: ST_TO_ADDR
// sRadar := false ;
96234: LD_ADDR_EXP 133
96238: PUSH
96239: LD_INT 0
96241: ST_TO_ADDR
// sBunker := false ;
96242: LD_ADDR_EXP 134
96246: PUSH
96247: LD_INT 0
96249: ST_TO_ADDR
// sHack := false ;
96250: LD_ADDR_EXP 135
96254: PUSH
96255: LD_INT 0
96257: ST_TO_ADDR
// sFire := false ;
96258: LD_ADDR_EXP 136
96262: PUSH
96263: LD_INT 0
96265: ST_TO_ADDR
// sRefresh := false ;
96266: LD_ADDR_EXP 137
96270: PUSH
96271: LD_INT 0
96273: ST_TO_ADDR
// sExp := false ;
96274: LD_ADDR_EXP 138
96278: PUSH
96279: LD_INT 0
96281: ST_TO_ADDR
// sDepot := false ;
96282: LD_ADDR_EXP 139
96286: PUSH
96287: LD_INT 0
96289: ST_TO_ADDR
// sFlag := false ;
96290: LD_ADDR_EXP 140
96294: PUSH
96295: LD_INT 0
96297: ST_TO_ADDR
// sKamikadze := false ;
96298: LD_ADDR_EXP 148
96302: PUSH
96303: LD_INT 0
96305: ST_TO_ADDR
// sTroll := false ;
96306: LD_ADDR_EXP 149
96310: PUSH
96311: LD_INT 0
96313: ST_TO_ADDR
// sSlow := false ;
96314: LD_ADDR_EXP 150
96318: PUSH
96319: LD_INT 0
96321: ST_TO_ADDR
// sLack := false ;
96322: LD_ADDR_EXP 151
96326: PUSH
96327: LD_INT 0
96329: ST_TO_ADDR
// sTank := false ;
96330: LD_ADDR_EXP 153
96334: PUSH
96335: LD_INT 0
96337: ST_TO_ADDR
// sRemote := false ;
96338: LD_ADDR_EXP 154
96342: PUSH
96343: LD_INT 0
96345: ST_TO_ADDR
// sPowell := false ;
96346: LD_ADDR_EXP 155
96350: PUSH
96351: LD_INT 0
96353: ST_TO_ADDR
// sTeleport := false ;
96354: LD_ADDR_EXP 158
96358: PUSH
96359: LD_INT 0
96361: ST_TO_ADDR
// sOilTower := false ;
96362: LD_ADDR_EXP 160
96366: PUSH
96367: LD_INT 0
96369: ST_TO_ADDR
// sShovel := false ;
96370: LD_ADDR_EXP 161
96374: PUSH
96375: LD_INT 0
96377: ST_TO_ADDR
// sSheik := false ;
96378: LD_ADDR_EXP 162
96382: PUSH
96383: LD_INT 0
96385: ST_TO_ADDR
// sEarthquake := false ;
96386: LD_ADDR_EXP 164
96390: PUSH
96391: LD_INT 0
96393: ST_TO_ADDR
// sAI := false ;
96394: LD_ADDR_EXP 165
96398: PUSH
96399: LD_INT 0
96401: ST_TO_ADDR
// sCargo := false ;
96402: LD_ADDR_EXP 168
96406: PUSH
96407: LD_INT 0
96409: ST_TO_ADDR
// sDLaser := false ;
96410: LD_ADDR_EXP 169
96414: PUSH
96415: LD_INT 0
96417: ST_TO_ADDR
// sExchange := false ;
96418: LD_ADDR_EXP 170
96422: PUSH
96423: LD_INT 0
96425: ST_TO_ADDR
// sFac := false ;
96426: LD_ADDR_EXP 171
96430: PUSH
96431: LD_INT 0
96433: ST_TO_ADDR
// sPower := false ;
96434: LD_ADDR_EXP 172
96438: PUSH
96439: LD_INT 0
96441: ST_TO_ADDR
// sRandom := false ;
96442: LD_ADDR_EXP 173
96446: PUSH
96447: LD_INT 0
96449: ST_TO_ADDR
// sShield := false ;
96450: LD_ADDR_EXP 174
96454: PUSH
96455: LD_INT 0
96457: ST_TO_ADDR
// sTime := false ;
96458: LD_ADDR_EXP 175
96462: PUSH
96463: LD_INT 0
96465: ST_TO_ADDR
// sTools := false ;
96466: LD_ADDR_EXP 176
96470: PUSH
96471: LD_INT 0
96473: ST_TO_ADDR
// sSold := false ;
96474: LD_ADDR_EXP 141
96478: PUSH
96479: LD_INT 0
96481: ST_TO_ADDR
// sDiff := false ;
96482: LD_ADDR_EXP 142
96486: PUSH
96487: LD_INT 0
96489: ST_TO_ADDR
// sFog := false ;
96490: LD_ADDR_EXP 145
96494: PUSH
96495: LD_INT 0
96497: ST_TO_ADDR
// sReset := false ;
96498: LD_ADDR_EXP 146
96502: PUSH
96503: LD_INT 0
96505: ST_TO_ADDR
// sSun := false ;
96506: LD_ADDR_EXP 147
96510: PUSH
96511: LD_INT 0
96513: ST_TO_ADDR
// sTiger := false ;
96514: LD_ADDR_EXP 143
96518: PUSH
96519: LD_INT 0
96521: ST_TO_ADDR
// sBomb := false ;
96522: LD_ADDR_EXP 144
96526: PUSH
96527: LD_INT 0
96529: ST_TO_ADDR
// sWound := false ;
96530: LD_ADDR_EXP 152
96534: PUSH
96535: LD_INT 0
96537: ST_TO_ADDR
// sBetray := false ;
96538: LD_ADDR_EXP 156
96542: PUSH
96543: LD_INT 0
96545: ST_TO_ADDR
// sContamin := false ;
96546: LD_ADDR_EXP 157
96550: PUSH
96551: LD_INT 0
96553: ST_TO_ADDR
// sOil := false ;
96554: LD_ADDR_EXP 159
96558: PUSH
96559: LD_INT 0
96561: ST_TO_ADDR
// sStu := false ;
96562: LD_ADDR_EXP 163
96566: PUSH
96567: LD_INT 0
96569: ST_TO_ADDR
// sBazooka := false ;
96570: LD_ADDR_EXP 166
96574: PUSH
96575: LD_INT 0
96577: ST_TO_ADDR
// sMortar := false ;
96578: LD_ADDR_EXP 167
96582: PUSH
96583: LD_INT 0
96585: ST_TO_ADDR
// sRanger := false ;
96586: LD_ADDR_EXP 177
96590: PUSH
96591: LD_INT 0
96593: ST_TO_ADDR
// sComputer := false ;
96594: LD_ADDR_EXP 178
96598: PUSH
96599: LD_INT 0
96601: ST_TO_ADDR
// s30 := false ;
96602: LD_ADDR_EXP 179
96606: PUSH
96607: LD_INT 0
96609: ST_TO_ADDR
// s60 := false ;
96610: LD_ADDR_EXP 180
96614: PUSH
96615: LD_INT 0
96617: ST_TO_ADDR
// end ;
96618: LD_VAR 0 1
96622: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96623: LD_INT 0
96625: PPUSH
96626: PPUSH
96627: PPUSH
96628: PPUSH
96629: PPUSH
96630: PPUSH
96631: PPUSH
// result := [ ] ;
96632: LD_ADDR_VAR 0 2
96636: PUSH
96637: EMPTY
96638: ST_TO_ADDR
// if campaign_id = 1 then
96639: LD_OWVAR 69
96643: PUSH
96644: LD_INT 1
96646: EQUAL
96647: IFFALSE 99813
// begin case mission_number of 1 :
96649: LD_OWVAR 70
96653: PUSH
96654: LD_INT 1
96656: DOUBLE
96657: EQUAL
96658: IFTRUE 96662
96660: GO 96738
96662: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96663: LD_ADDR_VAR 0 2
96667: PUSH
96668: LD_INT 2
96670: PUSH
96671: LD_INT 4
96673: PUSH
96674: LD_INT 11
96676: PUSH
96677: LD_INT 12
96679: PUSH
96680: LD_INT 15
96682: PUSH
96683: LD_INT 16
96685: PUSH
96686: LD_INT 22
96688: PUSH
96689: LD_INT 23
96691: PUSH
96692: LD_INT 26
96694: PUSH
96695: EMPTY
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: PUSH
96706: LD_INT 101
96708: PUSH
96709: LD_INT 102
96711: PUSH
96712: LD_INT 106
96714: PUSH
96715: LD_INT 116
96717: PUSH
96718: LD_INT 117
96720: PUSH
96721: LD_INT 118
96723: PUSH
96724: EMPTY
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: PUSH
96732: EMPTY
96733: LIST
96734: LIST
96735: ST_TO_ADDR
96736: GO 99811
96738: LD_INT 2
96740: DOUBLE
96741: EQUAL
96742: IFTRUE 96746
96744: GO 96830
96746: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96747: LD_ADDR_VAR 0 2
96751: PUSH
96752: LD_INT 2
96754: PUSH
96755: LD_INT 4
96757: PUSH
96758: LD_INT 11
96760: PUSH
96761: LD_INT 12
96763: PUSH
96764: LD_INT 15
96766: PUSH
96767: LD_INT 16
96769: PUSH
96770: LD_INT 22
96772: PUSH
96773: LD_INT 23
96775: PUSH
96776: LD_INT 26
96778: PUSH
96779: EMPTY
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: PUSH
96790: LD_INT 101
96792: PUSH
96793: LD_INT 102
96795: PUSH
96796: LD_INT 105
96798: PUSH
96799: LD_INT 106
96801: PUSH
96802: LD_INT 108
96804: PUSH
96805: LD_INT 116
96807: PUSH
96808: LD_INT 117
96810: PUSH
96811: LD_INT 118
96813: PUSH
96814: EMPTY
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: PUSH
96824: EMPTY
96825: LIST
96826: LIST
96827: ST_TO_ADDR
96828: GO 99811
96830: LD_INT 3
96832: DOUBLE
96833: EQUAL
96834: IFTRUE 96838
96836: GO 96926
96838: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96839: LD_ADDR_VAR 0 2
96843: PUSH
96844: LD_INT 2
96846: PUSH
96847: LD_INT 4
96849: PUSH
96850: LD_INT 5
96852: PUSH
96853: LD_INT 11
96855: PUSH
96856: LD_INT 12
96858: PUSH
96859: LD_INT 15
96861: PUSH
96862: LD_INT 16
96864: PUSH
96865: LD_INT 22
96867: PUSH
96868: LD_INT 26
96870: PUSH
96871: LD_INT 36
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 101
96888: PUSH
96889: LD_INT 102
96891: PUSH
96892: LD_INT 105
96894: PUSH
96895: LD_INT 106
96897: PUSH
96898: LD_INT 108
96900: PUSH
96901: LD_INT 116
96903: PUSH
96904: LD_INT 117
96906: PUSH
96907: LD_INT 118
96909: PUSH
96910: EMPTY
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: LIST
96919: PUSH
96920: EMPTY
96921: LIST
96922: LIST
96923: ST_TO_ADDR
96924: GO 99811
96926: LD_INT 4
96928: DOUBLE
96929: EQUAL
96930: IFTRUE 96934
96932: GO 97030
96934: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96935: LD_ADDR_VAR 0 2
96939: PUSH
96940: LD_INT 2
96942: PUSH
96943: LD_INT 4
96945: PUSH
96946: LD_INT 5
96948: PUSH
96949: LD_INT 8
96951: PUSH
96952: LD_INT 11
96954: PUSH
96955: LD_INT 12
96957: PUSH
96958: LD_INT 15
96960: PUSH
96961: LD_INT 16
96963: PUSH
96964: LD_INT 22
96966: PUSH
96967: LD_INT 23
96969: PUSH
96970: LD_INT 26
96972: PUSH
96973: LD_INT 36
96975: PUSH
96976: EMPTY
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: PUSH
96990: LD_INT 101
96992: PUSH
96993: LD_INT 102
96995: PUSH
96996: LD_INT 105
96998: PUSH
96999: LD_INT 106
97001: PUSH
97002: LD_INT 108
97004: PUSH
97005: LD_INT 116
97007: PUSH
97008: LD_INT 117
97010: PUSH
97011: LD_INT 118
97013: PUSH
97014: EMPTY
97015: LIST
97016: LIST
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: ST_TO_ADDR
97028: GO 99811
97030: LD_INT 5
97032: DOUBLE
97033: EQUAL
97034: IFTRUE 97038
97036: GO 97150
97038: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
97039: LD_ADDR_VAR 0 2
97043: PUSH
97044: LD_INT 2
97046: PUSH
97047: LD_INT 4
97049: PUSH
97050: LD_INT 5
97052: PUSH
97053: LD_INT 6
97055: PUSH
97056: LD_INT 8
97058: PUSH
97059: LD_INT 11
97061: PUSH
97062: LD_INT 12
97064: PUSH
97065: LD_INT 15
97067: PUSH
97068: LD_INT 16
97070: PUSH
97071: LD_INT 22
97073: PUSH
97074: LD_INT 23
97076: PUSH
97077: LD_INT 25
97079: PUSH
97080: LD_INT 26
97082: PUSH
97083: LD_INT 36
97085: PUSH
97086: EMPTY
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: PUSH
97102: LD_INT 101
97104: PUSH
97105: LD_INT 102
97107: PUSH
97108: LD_INT 105
97110: PUSH
97111: LD_INT 106
97113: PUSH
97114: LD_INT 108
97116: PUSH
97117: LD_INT 109
97119: PUSH
97120: LD_INT 112
97122: PUSH
97123: LD_INT 116
97125: PUSH
97126: LD_INT 117
97128: PUSH
97129: LD_INT 118
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: PUSH
97144: EMPTY
97145: LIST
97146: LIST
97147: ST_TO_ADDR
97148: GO 99811
97150: LD_INT 6
97152: DOUBLE
97153: EQUAL
97154: IFTRUE 97158
97156: GO 97290
97158: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
97159: LD_ADDR_VAR 0 2
97163: PUSH
97164: LD_INT 2
97166: PUSH
97167: LD_INT 4
97169: PUSH
97170: LD_INT 5
97172: PUSH
97173: LD_INT 6
97175: PUSH
97176: LD_INT 8
97178: PUSH
97179: LD_INT 11
97181: PUSH
97182: LD_INT 12
97184: PUSH
97185: LD_INT 15
97187: PUSH
97188: LD_INT 16
97190: PUSH
97191: LD_INT 20
97193: PUSH
97194: LD_INT 21
97196: PUSH
97197: LD_INT 22
97199: PUSH
97200: LD_INT 23
97202: PUSH
97203: LD_INT 25
97205: PUSH
97206: LD_INT 26
97208: PUSH
97209: LD_INT 30
97211: PUSH
97212: LD_INT 31
97214: PUSH
97215: LD_INT 32
97217: PUSH
97218: LD_INT 36
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: LIST
97233: LIST
97234: LIST
97235: LIST
97236: LIST
97237: LIST
97238: LIST
97239: LIST
97240: LIST
97241: PUSH
97242: LD_INT 101
97244: PUSH
97245: LD_INT 102
97247: PUSH
97248: LD_INT 105
97250: PUSH
97251: LD_INT 106
97253: PUSH
97254: LD_INT 108
97256: PUSH
97257: LD_INT 109
97259: PUSH
97260: LD_INT 112
97262: PUSH
97263: LD_INT 116
97265: PUSH
97266: LD_INT 117
97268: PUSH
97269: LD_INT 118
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: LIST
97279: LIST
97280: LIST
97281: LIST
97282: LIST
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: ST_TO_ADDR
97288: GO 99811
97290: LD_INT 7
97292: DOUBLE
97293: EQUAL
97294: IFTRUE 97298
97296: GO 97410
97298: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97299: LD_ADDR_VAR 0 2
97303: PUSH
97304: LD_INT 2
97306: PUSH
97307: LD_INT 4
97309: PUSH
97310: LD_INT 5
97312: PUSH
97313: LD_INT 7
97315: PUSH
97316: LD_INT 11
97318: PUSH
97319: LD_INT 12
97321: PUSH
97322: LD_INT 15
97324: PUSH
97325: LD_INT 16
97327: PUSH
97328: LD_INT 20
97330: PUSH
97331: LD_INT 21
97333: PUSH
97334: LD_INT 22
97336: PUSH
97337: LD_INT 23
97339: PUSH
97340: LD_INT 25
97342: PUSH
97343: LD_INT 26
97345: PUSH
97346: EMPTY
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: PUSH
97362: LD_INT 101
97364: PUSH
97365: LD_INT 102
97367: PUSH
97368: LD_INT 103
97370: PUSH
97371: LD_INT 105
97373: PUSH
97374: LD_INT 106
97376: PUSH
97377: LD_INT 108
97379: PUSH
97380: LD_INT 112
97382: PUSH
97383: LD_INT 116
97385: PUSH
97386: LD_INT 117
97388: PUSH
97389: LD_INT 118
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: PUSH
97404: EMPTY
97405: LIST
97406: LIST
97407: ST_TO_ADDR
97408: GO 99811
97410: LD_INT 8
97412: DOUBLE
97413: EQUAL
97414: IFTRUE 97418
97416: GO 97558
97418: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97419: LD_ADDR_VAR 0 2
97423: PUSH
97424: LD_INT 2
97426: PUSH
97427: LD_INT 4
97429: PUSH
97430: LD_INT 5
97432: PUSH
97433: LD_INT 6
97435: PUSH
97436: LD_INT 7
97438: PUSH
97439: LD_INT 8
97441: PUSH
97442: LD_INT 11
97444: PUSH
97445: LD_INT 12
97447: PUSH
97448: LD_INT 15
97450: PUSH
97451: LD_INT 16
97453: PUSH
97454: LD_INT 20
97456: PUSH
97457: LD_INT 21
97459: PUSH
97460: LD_INT 22
97462: PUSH
97463: LD_INT 23
97465: PUSH
97466: LD_INT 25
97468: PUSH
97469: LD_INT 26
97471: PUSH
97472: LD_INT 30
97474: PUSH
97475: LD_INT 31
97477: PUSH
97478: LD_INT 32
97480: PUSH
97481: LD_INT 36
97483: PUSH
97484: EMPTY
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: PUSH
97506: LD_INT 101
97508: PUSH
97509: LD_INT 102
97511: PUSH
97512: LD_INT 103
97514: PUSH
97515: LD_INT 105
97517: PUSH
97518: LD_INT 106
97520: PUSH
97521: LD_INT 108
97523: PUSH
97524: LD_INT 109
97526: PUSH
97527: LD_INT 112
97529: PUSH
97530: LD_INT 116
97532: PUSH
97533: LD_INT 117
97535: PUSH
97536: LD_INT 118
97538: PUSH
97539: EMPTY
97540: LIST
97541: LIST
97542: LIST
97543: LIST
97544: LIST
97545: LIST
97546: LIST
97547: LIST
97548: LIST
97549: LIST
97550: LIST
97551: PUSH
97552: EMPTY
97553: LIST
97554: LIST
97555: ST_TO_ADDR
97556: GO 99811
97558: LD_INT 9
97560: DOUBLE
97561: EQUAL
97562: IFTRUE 97566
97564: GO 97714
97566: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97567: LD_ADDR_VAR 0 2
97571: PUSH
97572: LD_INT 2
97574: PUSH
97575: LD_INT 4
97577: PUSH
97578: LD_INT 5
97580: PUSH
97581: LD_INT 6
97583: PUSH
97584: LD_INT 7
97586: PUSH
97587: LD_INT 8
97589: PUSH
97590: LD_INT 11
97592: PUSH
97593: LD_INT 12
97595: PUSH
97596: LD_INT 15
97598: PUSH
97599: LD_INT 16
97601: PUSH
97602: LD_INT 20
97604: PUSH
97605: LD_INT 21
97607: PUSH
97608: LD_INT 22
97610: PUSH
97611: LD_INT 23
97613: PUSH
97614: LD_INT 25
97616: PUSH
97617: LD_INT 26
97619: PUSH
97620: LD_INT 28
97622: PUSH
97623: LD_INT 30
97625: PUSH
97626: LD_INT 31
97628: PUSH
97629: LD_INT 32
97631: PUSH
97632: LD_INT 36
97634: PUSH
97635: EMPTY
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: PUSH
97658: LD_INT 101
97660: PUSH
97661: LD_INT 102
97663: PUSH
97664: LD_INT 103
97666: PUSH
97667: LD_INT 105
97669: PUSH
97670: LD_INT 106
97672: PUSH
97673: LD_INT 108
97675: PUSH
97676: LD_INT 109
97678: PUSH
97679: LD_INT 112
97681: PUSH
97682: LD_INT 114
97684: PUSH
97685: LD_INT 116
97687: PUSH
97688: LD_INT 117
97690: PUSH
97691: LD_INT 118
97693: PUSH
97694: EMPTY
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: PUSH
97708: EMPTY
97709: LIST
97710: LIST
97711: ST_TO_ADDR
97712: GO 99811
97714: LD_INT 10
97716: DOUBLE
97717: EQUAL
97718: IFTRUE 97722
97720: GO 97918
97722: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97723: LD_ADDR_VAR 0 2
97727: PUSH
97728: LD_INT 2
97730: PUSH
97731: LD_INT 4
97733: PUSH
97734: LD_INT 5
97736: PUSH
97737: LD_INT 6
97739: PUSH
97740: LD_INT 7
97742: PUSH
97743: LD_INT 8
97745: PUSH
97746: LD_INT 9
97748: PUSH
97749: LD_INT 10
97751: PUSH
97752: LD_INT 11
97754: PUSH
97755: LD_INT 12
97757: PUSH
97758: LD_INT 13
97760: PUSH
97761: LD_INT 14
97763: PUSH
97764: LD_INT 15
97766: PUSH
97767: LD_INT 16
97769: PUSH
97770: LD_INT 17
97772: PUSH
97773: LD_INT 18
97775: PUSH
97776: LD_INT 19
97778: PUSH
97779: LD_INT 20
97781: PUSH
97782: LD_INT 21
97784: PUSH
97785: LD_INT 22
97787: PUSH
97788: LD_INT 23
97790: PUSH
97791: LD_INT 24
97793: PUSH
97794: LD_INT 25
97796: PUSH
97797: LD_INT 26
97799: PUSH
97800: LD_INT 28
97802: PUSH
97803: LD_INT 30
97805: PUSH
97806: LD_INT 31
97808: PUSH
97809: LD_INT 32
97811: PUSH
97812: LD_INT 36
97814: PUSH
97815: EMPTY
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: LIST
97838: LIST
97839: LIST
97840: LIST
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: PUSH
97846: LD_INT 101
97848: PUSH
97849: LD_INT 102
97851: PUSH
97852: LD_INT 103
97854: PUSH
97855: LD_INT 104
97857: PUSH
97858: LD_INT 105
97860: PUSH
97861: LD_INT 106
97863: PUSH
97864: LD_INT 107
97866: PUSH
97867: LD_INT 108
97869: PUSH
97870: LD_INT 109
97872: PUSH
97873: LD_INT 110
97875: PUSH
97876: LD_INT 111
97878: PUSH
97879: LD_INT 112
97881: PUSH
97882: LD_INT 114
97884: PUSH
97885: LD_INT 116
97887: PUSH
97888: LD_INT 117
97890: PUSH
97891: LD_INT 118
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: PUSH
97912: EMPTY
97913: LIST
97914: LIST
97915: ST_TO_ADDR
97916: GO 99811
97918: LD_INT 11
97920: DOUBLE
97921: EQUAL
97922: IFTRUE 97926
97924: GO 98130
97926: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97927: LD_ADDR_VAR 0 2
97931: PUSH
97932: LD_INT 2
97934: PUSH
97935: LD_INT 3
97937: PUSH
97938: LD_INT 4
97940: PUSH
97941: LD_INT 5
97943: PUSH
97944: LD_INT 6
97946: PUSH
97947: LD_INT 7
97949: PUSH
97950: LD_INT 8
97952: PUSH
97953: LD_INT 9
97955: PUSH
97956: LD_INT 10
97958: PUSH
97959: LD_INT 11
97961: PUSH
97962: LD_INT 12
97964: PUSH
97965: LD_INT 13
97967: PUSH
97968: LD_INT 14
97970: PUSH
97971: LD_INT 15
97973: PUSH
97974: LD_INT 16
97976: PUSH
97977: LD_INT 17
97979: PUSH
97980: LD_INT 18
97982: PUSH
97983: LD_INT 19
97985: PUSH
97986: LD_INT 20
97988: PUSH
97989: LD_INT 21
97991: PUSH
97992: LD_INT 22
97994: PUSH
97995: LD_INT 23
97997: PUSH
97998: LD_INT 24
98000: PUSH
98001: LD_INT 25
98003: PUSH
98004: LD_INT 26
98006: PUSH
98007: LD_INT 28
98009: PUSH
98010: LD_INT 30
98012: PUSH
98013: LD_INT 31
98015: PUSH
98016: LD_INT 32
98018: PUSH
98019: LD_INT 34
98021: PUSH
98022: LD_INT 36
98024: PUSH
98025: EMPTY
98026: LIST
98027: LIST
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: LIST
98041: LIST
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: LIST
98056: LIST
98057: PUSH
98058: LD_INT 101
98060: PUSH
98061: LD_INT 102
98063: PUSH
98064: LD_INT 103
98066: PUSH
98067: LD_INT 104
98069: PUSH
98070: LD_INT 105
98072: PUSH
98073: LD_INT 106
98075: PUSH
98076: LD_INT 107
98078: PUSH
98079: LD_INT 108
98081: PUSH
98082: LD_INT 109
98084: PUSH
98085: LD_INT 110
98087: PUSH
98088: LD_INT 111
98090: PUSH
98091: LD_INT 112
98093: PUSH
98094: LD_INT 114
98096: PUSH
98097: LD_INT 116
98099: PUSH
98100: LD_INT 117
98102: PUSH
98103: LD_INT 118
98105: PUSH
98106: EMPTY
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: PUSH
98124: EMPTY
98125: LIST
98126: LIST
98127: ST_TO_ADDR
98128: GO 99811
98130: LD_INT 12
98132: DOUBLE
98133: EQUAL
98134: IFTRUE 98138
98136: GO 98358
98138: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
98139: LD_ADDR_VAR 0 2
98143: PUSH
98144: LD_INT 1
98146: PUSH
98147: LD_INT 2
98149: PUSH
98150: LD_INT 3
98152: PUSH
98153: LD_INT 4
98155: PUSH
98156: LD_INT 5
98158: PUSH
98159: LD_INT 6
98161: PUSH
98162: LD_INT 7
98164: PUSH
98165: LD_INT 8
98167: PUSH
98168: LD_INT 9
98170: PUSH
98171: LD_INT 10
98173: PUSH
98174: LD_INT 11
98176: PUSH
98177: LD_INT 12
98179: PUSH
98180: LD_INT 13
98182: PUSH
98183: LD_INT 14
98185: PUSH
98186: LD_INT 15
98188: PUSH
98189: LD_INT 16
98191: PUSH
98192: LD_INT 17
98194: PUSH
98195: LD_INT 18
98197: PUSH
98198: LD_INT 19
98200: PUSH
98201: LD_INT 20
98203: PUSH
98204: LD_INT 21
98206: PUSH
98207: LD_INT 22
98209: PUSH
98210: LD_INT 23
98212: PUSH
98213: LD_INT 24
98215: PUSH
98216: LD_INT 25
98218: PUSH
98219: LD_INT 26
98221: PUSH
98222: LD_INT 27
98224: PUSH
98225: LD_INT 28
98227: PUSH
98228: LD_INT 30
98230: PUSH
98231: LD_INT 31
98233: PUSH
98234: LD_INT 32
98236: PUSH
98237: LD_INT 33
98239: PUSH
98240: LD_INT 34
98242: PUSH
98243: LD_INT 36
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: LIST
98271: LIST
98272: LIST
98273: LIST
98274: LIST
98275: LIST
98276: LIST
98277: LIST
98278: LIST
98279: LIST
98280: LIST
98281: PUSH
98282: LD_INT 101
98284: PUSH
98285: LD_INT 102
98287: PUSH
98288: LD_INT 103
98290: PUSH
98291: LD_INT 104
98293: PUSH
98294: LD_INT 105
98296: PUSH
98297: LD_INT 106
98299: PUSH
98300: LD_INT 107
98302: PUSH
98303: LD_INT 108
98305: PUSH
98306: LD_INT 109
98308: PUSH
98309: LD_INT 110
98311: PUSH
98312: LD_INT 111
98314: PUSH
98315: LD_INT 112
98317: PUSH
98318: LD_INT 113
98320: PUSH
98321: LD_INT 114
98323: PUSH
98324: LD_INT 116
98326: PUSH
98327: LD_INT 117
98329: PUSH
98330: LD_INT 118
98332: PUSH
98333: EMPTY
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: PUSH
98352: EMPTY
98353: LIST
98354: LIST
98355: ST_TO_ADDR
98356: GO 99811
98358: LD_INT 13
98360: DOUBLE
98361: EQUAL
98362: IFTRUE 98366
98364: GO 98574
98366: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98367: LD_ADDR_VAR 0 2
98371: PUSH
98372: LD_INT 1
98374: PUSH
98375: LD_INT 2
98377: PUSH
98378: LD_INT 3
98380: PUSH
98381: LD_INT 4
98383: PUSH
98384: LD_INT 5
98386: PUSH
98387: LD_INT 8
98389: PUSH
98390: LD_INT 9
98392: PUSH
98393: LD_INT 10
98395: PUSH
98396: LD_INT 11
98398: PUSH
98399: LD_INT 12
98401: PUSH
98402: LD_INT 14
98404: PUSH
98405: LD_INT 15
98407: PUSH
98408: LD_INT 16
98410: PUSH
98411: LD_INT 17
98413: PUSH
98414: LD_INT 18
98416: PUSH
98417: LD_INT 19
98419: PUSH
98420: LD_INT 20
98422: PUSH
98423: LD_INT 21
98425: PUSH
98426: LD_INT 22
98428: PUSH
98429: LD_INT 23
98431: PUSH
98432: LD_INT 24
98434: PUSH
98435: LD_INT 25
98437: PUSH
98438: LD_INT 26
98440: PUSH
98441: LD_INT 27
98443: PUSH
98444: LD_INT 28
98446: PUSH
98447: LD_INT 30
98449: PUSH
98450: LD_INT 31
98452: PUSH
98453: LD_INT 32
98455: PUSH
98456: LD_INT 33
98458: PUSH
98459: LD_INT 34
98461: PUSH
98462: LD_INT 36
98464: PUSH
98465: EMPTY
98466: LIST
98467: LIST
98468: LIST
98469: LIST
98470: LIST
98471: LIST
98472: LIST
98473: LIST
98474: LIST
98475: LIST
98476: LIST
98477: LIST
98478: LIST
98479: LIST
98480: LIST
98481: LIST
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: LIST
98489: LIST
98490: LIST
98491: LIST
98492: LIST
98493: LIST
98494: LIST
98495: LIST
98496: LIST
98497: PUSH
98498: LD_INT 101
98500: PUSH
98501: LD_INT 102
98503: PUSH
98504: LD_INT 103
98506: PUSH
98507: LD_INT 104
98509: PUSH
98510: LD_INT 105
98512: PUSH
98513: LD_INT 106
98515: PUSH
98516: LD_INT 107
98518: PUSH
98519: LD_INT 108
98521: PUSH
98522: LD_INT 109
98524: PUSH
98525: LD_INT 110
98527: PUSH
98528: LD_INT 111
98530: PUSH
98531: LD_INT 112
98533: PUSH
98534: LD_INT 113
98536: PUSH
98537: LD_INT 114
98539: PUSH
98540: LD_INT 116
98542: PUSH
98543: LD_INT 117
98545: PUSH
98546: LD_INT 118
98548: PUSH
98549: EMPTY
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: PUSH
98568: EMPTY
98569: LIST
98570: LIST
98571: ST_TO_ADDR
98572: GO 99811
98574: LD_INT 14
98576: DOUBLE
98577: EQUAL
98578: IFTRUE 98582
98580: GO 98806
98582: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98583: LD_ADDR_VAR 0 2
98587: PUSH
98588: LD_INT 1
98590: PUSH
98591: LD_INT 2
98593: PUSH
98594: LD_INT 3
98596: PUSH
98597: LD_INT 4
98599: PUSH
98600: LD_INT 5
98602: PUSH
98603: LD_INT 6
98605: PUSH
98606: LD_INT 7
98608: PUSH
98609: LD_INT 8
98611: PUSH
98612: LD_INT 9
98614: PUSH
98615: LD_INT 10
98617: PUSH
98618: LD_INT 11
98620: PUSH
98621: LD_INT 12
98623: PUSH
98624: LD_INT 13
98626: PUSH
98627: LD_INT 14
98629: PUSH
98630: LD_INT 15
98632: PUSH
98633: LD_INT 16
98635: PUSH
98636: LD_INT 17
98638: PUSH
98639: LD_INT 18
98641: PUSH
98642: LD_INT 19
98644: PUSH
98645: LD_INT 20
98647: PUSH
98648: LD_INT 21
98650: PUSH
98651: LD_INT 22
98653: PUSH
98654: LD_INT 23
98656: PUSH
98657: LD_INT 24
98659: PUSH
98660: LD_INT 25
98662: PUSH
98663: LD_INT 26
98665: PUSH
98666: LD_INT 27
98668: PUSH
98669: LD_INT 28
98671: PUSH
98672: LD_INT 29
98674: PUSH
98675: LD_INT 30
98677: PUSH
98678: LD_INT 31
98680: PUSH
98681: LD_INT 32
98683: PUSH
98684: LD_INT 33
98686: PUSH
98687: LD_INT 34
98689: PUSH
98690: LD_INT 36
98692: PUSH
98693: EMPTY
98694: LIST
98695: LIST
98696: LIST
98697: LIST
98698: LIST
98699: LIST
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: PUSH
98730: LD_INT 101
98732: PUSH
98733: LD_INT 102
98735: PUSH
98736: LD_INT 103
98738: PUSH
98739: LD_INT 104
98741: PUSH
98742: LD_INT 105
98744: PUSH
98745: LD_INT 106
98747: PUSH
98748: LD_INT 107
98750: PUSH
98751: LD_INT 108
98753: PUSH
98754: LD_INT 109
98756: PUSH
98757: LD_INT 110
98759: PUSH
98760: LD_INT 111
98762: PUSH
98763: LD_INT 112
98765: PUSH
98766: LD_INT 113
98768: PUSH
98769: LD_INT 114
98771: PUSH
98772: LD_INT 116
98774: PUSH
98775: LD_INT 117
98777: PUSH
98778: LD_INT 118
98780: PUSH
98781: EMPTY
98782: LIST
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: LIST
98795: LIST
98796: LIST
98797: LIST
98798: LIST
98799: PUSH
98800: EMPTY
98801: LIST
98802: LIST
98803: ST_TO_ADDR
98804: GO 99811
98806: LD_INT 15
98808: DOUBLE
98809: EQUAL
98810: IFTRUE 98814
98812: GO 99038
98814: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98815: LD_ADDR_VAR 0 2
98819: PUSH
98820: LD_INT 1
98822: PUSH
98823: LD_INT 2
98825: PUSH
98826: LD_INT 3
98828: PUSH
98829: LD_INT 4
98831: PUSH
98832: LD_INT 5
98834: PUSH
98835: LD_INT 6
98837: PUSH
98838: LD_INT 7
98840: PUSH
98841: LD_INT 8
98843: PUSH
98844: LD_INT 9
98846: PUSH
98847: LD_INT 10
98849: PUSH
98850: LD_INT 11
98852: PUSH
98853: LD_INT 12
98855: PUSH
98856: LD_INT 13
98858: PUSH
98859: LD_INT 14
98861: PUSH
98862: LD_INT 15
98864: PUSH
98865: LD_INT 16
98867: PUSH
98868: LD_INT 17
98870: PUSH
98871: LD_INT 18
98873: PUSH
98874: LD_INT 19
98876: PUSH
98877: LD_INT 20
98879: PUSH
98880: LD_INT 21
98882: PUSH
98883: LD_INT 22
98885: PUSH
98886: LD_INT 23
98888: PUSH
98889: LD_INT 24
98891: PUSH
98892: LD_INT 25
98894: PUSH
98895: LD_INT 26
98897: PUSH
98898: LD_INT 27
98900: PUSH
98901: LD_INT 28
98903: PUSH
98904: LD_INT 29
98906: PUSH
98907: LD_INT 30
98909: PUSH
98910: LD_INT 31
98912: PUSH
98913: LD_INT 32
98915: PUSH
98916: LD_INT 33
98918: PUSH
98919: LD_INT 34
98921: PUSH
98922: LD_INT 36
98924: PUSH
98925: EMPTY
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: LIST
98946: LIST
98947: LIST
98948: LIST
98949: LIST
98950: LIST
98951: LIST
98952: LIST
98953: LIST
98954: LIST
98955: LIST
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: PUSH
98962: LD_INT 101
98964: PUSH
98965: LD_INT 102
98967: PUSH
98968: LD_INT 103
98970: PUSH
98971: LD_INT 104
98973: PUSH
98974: LD_INT 105
98976: PUSH
98977: LD_INT 106
98979: PUSH
98980: LD_INT 107
98982: PUSH
98983: LD_INT 108
98985: PUSH
98986: LD_INT 109
98988: PUSH
98989: LD_INT 110
98991: PUSH
98992: LD_INT 111
98994: PUSH
98995: LD_INT 112
98997: PUSH
98998: LD_INT 113
99000: PUSH
99001: LD_INT 114
99003: PUSH
99004: LD_INT 116
99006: PUSH
99007: LD_INT 117
99009: PUSH
99010: LD_INT 118
99012: PUSH
99013: EMPTY
99014: LIST
99015: LIST
99016: LIST
99017: LIST
99018: LIST
99019: LIST
99020: LIST
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: LIST
99026: LIST
99027: LIST
99028: LIST
99029: LIST
99030: LIST
99031: PUSH
99032: EMPTY
99033: LIST
99034: LIST
99035: ST_TO_ADDR
99036: GO 99811
99038: LD_INT 16
99040: DOUBLE
99041: EQUAL
99042: IFTRUE 99046
99044: GO 99182
99046: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
99047: LD_ADDR_VAR 0 2
99051: PUSH
99052: LD_INT 2
99054: PUSH
99055: LD_INT 4
99057: PUSH
99058: LD_INT 5
99060: PUSH
99061: LD_INT 7
99063: PUSH
99064: LD_INT 11
99066: PUSH
99067: LD_INT 12
99069: PUSH
99070: LD_INT 15
99072: PUSH
99073: LD_INT 16
99075: PUSH
99076: LD_INT 20
99078: PUSH
99079: LD_INT 21
99081: PUSH
99082: LD_INT 22
99084: PUSH
99085: LD_INT 23
99087: PUSH
99088: LD_INT 25
99090: PUSH
99091: LD_INT 26
99093: PUSH
99094: LD_INT 30
99096: PUSH
99097: LD_INT 31
99099: PUSH
99100: LD_INT 32
99102: PUSH
99103: LD_INT 33
99105: PUSH
99106: LD_INT 34
99108: PUSH
99109: EMPTY
99110: LIST
99111: LIST
99112: LIST
99113: LIST
99114: LIST
99115: LIST
99116: LIST
99117: LIST
99118: LIST
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: PUSH
99130: LD_INT 101
99132: PUSH
99133: LD_INT 102
99135: PUSH
99136: LD_INT 103
99138: PUSH
99139: LD_INT 106
99141: PUSH
99142: LD_INT 108
99144: PUSH
99145: LD_INT 112
99147: PUSH
99148: LD_INT 113
99150: PUSH
99151: LD_INT 114
99153: PUSH
99154: LD_INT 116
99156: PUSH
99157: LD_INT 117
99159: PUSH
99160: LD_INT 118
99162: PUSH
99163: EMPTY
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: PUSH
99176: EMPTY
99177: LIST
99178: LIST
99179: ST_TO_ADDR
99180: GO 99811
99182: LD_INT 17
99184: DOUBLE
99185: EQUAL
99186: IFTRUE 99190
99188: GO 99414
99190: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99191: LD_ADDR_VAR 0 2
99195: PUSH
99196: LD_INT 1
99198: PUSH
99199: LD_INT 2
99201: PUSH
99202: LD_INT 3
99204: PUSH
99205: LD_INT 4
99207: PUSH
99208: LD_INT 5
99210: PUSH
99211: LD_INT 6
99213: PUSH
99214: LD_INT 7
99216: PUSH
99217: LD_INT 8
99219: PUSH
99220: LD_INT 9
99222: PUSH
99223: LD_INT 10
99225: PUSH
99226: LD_INT 11
99228: PUSH
99229: LD_INT 12
99231: PUSH
99232: LD_INT 13
99234: PUSH
99235: LD_INT 14
99237: PUSH
99238: LD_INT 15
99240: PUSH
99241: LD_INT 16
99243: PUSH
99244: LD_INT 17
99246: PUSH
99247: LD_INT 18
99249: PUSH
99250: LD_INT 19
99252: PUSH
99253: LD_INT 20
99255: PUSH
99256: LD_INT 21
99258: PUSH
99259: LD_INT 22
99261: PUSH
99262: LD_INT 23
99264: PUSH
99265: LD_INT 24
99267: PUSH
99268: LD_INT 25
99270: PUSH
99271: LD_INT 26
99273: PUSH
99274: LD_INT 27
99276: PUSH
99277: LD_INT 28
99279: PUSH
99280: LD_INT 29
99282: PUSH
99283: LD_INT 30
99285: PUSH
99286: LD_INT 31
99288: PUSH
99289: LD_INT 32
99291: PUSH
99292: LD_INT 33
99294: PUSH
99295: LD_INT 34
99297: PUSH
99298: LD_INT 36
99300: PUSH
99301: EMPTY
99302: LIST
99303: LIST
99304: LIST
99305: LIST
99306: LIST
99307: LIST
99308: LIST
99309: LIST
99310: LIST
99311: LIST
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: LIST
99317: LIST
99318: LIST
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: LIST
99324: LIST
99325: LIST
99326: LIST
99327: LIST
99328: LIST
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: PUSH
99338: LD_INT 101
99340: PUSH
99341: LD_INT 102
99343: PUSH
99344: LD_INT 103
99346: PUSH
99347: LD_INT 104
99349: PUSH
99350: LD_INT 105
99352: PUSH
99353: LD_INT 106
99355: PUSH
99356: LD_INT 107
99358: PUSH
99359: LD_INT 108
99361: PUSH
99362: LD_INT 109
99364: PUSH
99365: LD_INT 110
99367: PUSH
99368: LD_INT 111
99370: PUSH
99371: LD_INT 112
99373: PUSH
99374: LD_INT 113
99376: PUSH
99377: LD_INT 114
99379: PUSH
99380: LD_INT 116
99382: PUSH
99383: LD_INT 117
99385: PUSH
99386: LD_INT 118
99388: PUSH
99389: EMPTY
99390: LIST
99391: LIST
99392: LIST
99393: LIST
99394: LIST
99395: LIST
99396: LIST
99397: LIST
99398: LIST
99399: LIST
99400: LIST
99401: LIST
99402: LIST
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: PUSH
99408: EMPTY
99409: LIST
99410: LIST
99411: ST_TO_ADDR
99412: GO 99811
99414: LD_INT 18
99416: DOUBLE
99417: EQUAL
99418: IFTRUE 99422
99420: GO 99570
99422: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99423: LD_ADDR_VAR 0 2
99427: PUSH
99428: LD_INT 2
99430: PUSH
99431: LD_INT 4
99433: PUSH
99434: LD_INT 5
99436: PUSH
99437: LD_INT 7
99439: PUSH
99440: LD_INT 11
99442: PUSH
99443: LD_INT 12
99445: PUSH
99446: LD_INT 15
99448: PUSH
99449: LD_INT 16
99451: PUSH
99452: LD_INT 20
99454: PUSH
99455: LD_INT 21
99457: PUSH
99458: LD_INT 22
99460: PUSH
99461: LD_INT 23
99463: PUSH
99464: LD_INT 25
99466: PUSH
99467: LD_INT 26
99469: PUSH
99470: LD_INT 30
99472: PUSH
99473: LD_INT 31
99475: PUSH
99476: LD_INT 32
99478: PUSH
99479: LD_INT 33
99481: PUSH
99482: LD_INT 34
99484: PUSH
99485: LD_INT 35
99487: PUSH
99488: LD_INT 36
99490: PUSH
99491: EMPTY
99492: LIST
99493: LIST
99494: LIST
99495: LIST
99496: LIST
99497: LIST
99498: LIST
99499: LIST
99500: LIST
99501: LIST
99502: LIST
99503: LIST
99504: LIST
99505: LIST
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: LIST
99512: LIST
99513: PUSH
99514: LD_INT 101
99516: PUSH
99517: LD_INT 102
99519: PUSH
99520: LD_INT 103
99522: PUSH
99523: LD_INT 106
99525: PUSH
99526: LD_INT 108
99528: PUSH
99529: LD_INT 112
99531: PUSH
99532: LD_INT 113
99534: PUSH
99535: LD_INT 114
99537: PUSH
99538: LD_INT 115
99540: PUSH
99541: LD_INT 116
99543: PUSH
99544: LD_INT 117
99546: PUSH
99547: LD_INT 118
99549: PUSH
99550: EMPTY
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: LIST
99563: PUSH
99564: EMPTY
99565: LIST
99566: LIST
99567: ST_TO_ADDR
99568: GO 99811
99570: LD_INT 19
99572: DOUBLE
99573: EQUAL
99574: IFTRUE 99578
99576: GO 99810
99578: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99579: LD_ADDR_VAR 0 2
99583: PUSH
99584: LD_INT 1
99586: PUSH
99587: LD_INT 2
99589: PUSH
99590: LD_INT 3
99592: PUSH
99593: LD_INT 4
99595: PUSH
99596: LD_INT 5
99598: PUSH
99599: LD_INT 6
99601: PUSH
99602: LD_INT 7
99604: PUSH
99605: LD_INT 8
99607: PUSH
99608: LD_INT 9
99610: PUSH
99611: LD_INT 10
99613: PUSH
99614: LD_INT 11
99616: PUSH
99617: LD_INT 12
99619: PUSH
99620: LD_INT 13
99622: PUSH
99623: LD_INT 14
99625: PUSH
99626: LD_INT 15
99628: PUSH
99629: LD_INT 16
99631: PUSH
99632: LD_INT 17
99634: PUSH
99635: LD_INT 18
99637: PUSH
99638: LD_INT 19
99640: PUSH
99641: LD_INT 20
99643: PUSH
99644: LD_INT 21
99646: PUSH
99647: LD_INT 22
99649: PUSH
99650: LD_INT 23
99652: PUSH
99653: LD_INT 24
99655: PUSH
99656: LD_INT 25
99658: PUSH
99659: LD_INT 26
99661: PUSH
99662: LD_INT 27
99664: PUSH
99665: LD_INT 28
99667: PUSH
99668: LD_INT 29
99670: PUSH
99671: LD_INT 30
99673: PUSH
99674: LD_INT 31
99676: PUSH
99677: LD_INT 32
99679: PUSH
99680: LD_INT 33
99682: PUSH
99683: LD_INT 34
99685: PUSH
99686: LD_INT 35
99688: PUSH
99689: LD_INT 36
99691: PUSH
99692: EMPTY
99693: LIST
99694: LIST
99695: LIST
99696: LIST
99697: LIST
99698: LIST
99699: LIST
99700: LIST
99701: LIST
99702: LIST
99703: LIST
99704: LIST
99705: LIST
99706: LIST
99707: LIST
99708: LIST
99709: LIST
99710: LIST
99711: LIST
99712: LIST
99713: LIST
99714: LIST
99715: LIST
99716: LIST
99717: LIST
99718: LIST
99719: LIST
99720: LIST
99721: LIST
99722: LIST
99723: LIST
99724: LIST
99725: LIST
99726: LIST
99727: LIST
99728: LIST
99729: PUSH
99730: LD_INT 101
99732: PUSH
99733: LD_INT 102
99735: PUSH
99736: LD_INT 103
99738: PUSH
99739: LD_INT 104
99741: PUSH
99742: LD_INT 105
99744: PUSH
99745: LD_INT 106
99747: PUSH
99748: LD_INT 107
99750: PUSH
99751: LD_INT 108
99753: PUSH
99754: LD_INT 109
99756: PUSH
99757: LD_INT 110
99759: PUSH
99760: LD_INT 111
99762: PUSH
99763: LD_INT 112
99765: PUSH
99766: LD_INT 113
99768: PUSH
99769: LD_INT 114
99771: PUSH
99772: LD_INT 115
99774: PUSH
99775: LD_INT 116
99777: PUSH
99778: LD_INT 117
99780: PUSH
99781: LD_INT 118
99783: PUSH
99784: EMPTY
99785: LIST
99786: LIST
99787: LIST
99788: LIST
99789: LIST
99790: LIST
99791: LIST
99792: LIST
99793: LIST
99794: LIST
99795: LIST
99796: LIST
99797: LIST
99798: LIST
99799: LIST
99800: LIST
99801: LIST
99802: LIST
99803: PUSH
99804: EMPTY
99805: LIST
99806: LIST
99807: ST_TO_ADDR
99808: GO 99811
99810: POP
// end else
99811: GO 100042
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99813: LD_ADDR_VAR 0 2
99817: PUSH
99818: LD_INT 1
99820: PUSH
99821: LD_INT 2
99823: PUSH
99824: LD_INT 3
99826: PUSH
99827: LD_INT 4
99829: PUSH
99830: LD_INT 5
99832: PUSH
99833: LD_INT 6
99835: PUSH
99836: LD_INT 7
99838: PUSH
99839: LD_INT 8
99841: PUSH
99842: LD_INT 9
99844: PUSH
99845: LD_INT 10
99847: PUSH
99848: LD_INT 11
99850: PUSH
99851: LD_INT 12
99853: PUSH
99854: LD_INT 13
99856: PUSH
99857: LD_INT 14
99859: PUSH
99860: LD_INT 15
99862: PUSH
99863: LD_INT 16
99865: PUSH
99866: LD_INT 17
99868: PUSH
99869: LD_INT 18
99871: PUSH
99872: LD_INT 19
99874: PUSH
99875: LD_INT 20
99877: PUSH
99878: LD_INT 21
99880: PUSH
99881: LD_INT 22
99883: PUSH
99884: LD_INT 23
99886: PUSH
99887: LD_INT 24
99889: PUSH
99890: LD_INT 25
99892: PUSH
99893: LD_INT 26
99895: PUSH
99896: LD_INT 27
99898: PUSH
99899: LD_INT 28
99901: PUSH
99902: LD_INT 29
99904: PUSH
99905: LD_INT 30
99907: PUSH
99908: LD_INT 31
99910: PUSH
99911: LD_INT 32
99913: PUSH
99914: LD_INT 33
99916: PUSH
99917: LD_INT 34
99919: PUSH
99920: LD_INT 35
99922: PUSH
99923: LD_INT 36
99925: PUSH
99926: EMPTY
99927: LIST
99928: LIST
99929: LIST
99930: LIST
99931: LIST
99932: LIST
99933: LIST
99934: LIST
99935: LIST
99936: LIST
99937: LIST
99938: LIST
99939: LIST
99940: LIST
99941: LIST
99942: LIST
99943: LIST
99944: LIST
99945: LIST
99946: LIST
99947: LIST
99948: LIST
99949: LIST
99950: LIST
99951: LIST
99952: LIST
99953: LIST
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: LIST
99959: LIST
99960: LIST
99961: LIST
99962: LIST
99963: PUSH
99964: LD_INT 101
99966: PUSH
99967: LD_INT 102
99969: PUSH
99970: LD_INT 103
99972: PUSH
99973: LD_INT 104
99975: PUSH
99976: LD_INT 105
99978: PUSH
99979: LD_INT 106
99981: PUSH
99982: LD_INT 107
99984: PUSH
99985: LD_INT 108
99987: PUSH
99988: LD_INT 109
99990: PUSH
99991: LD_INT 110
99993: PUSH
99994: LD_INT 111
99996: PUSH
99997: LD_INT 112
99999: PUSH
100000: LD_INT 113
100002: PUSH
100003: LD_INT 114
100005: PUSH
100006: LD_INT 115
100008: PUSH
100009: LD_INT 116
100011: PUSH
100012: LD_INT 117
100014: PUSH
100015: LD_INT 118
100017: PUSH
100018: EMPTY
100019: LIST
100020: LIST
100021: LIST
100022: LIST
100023: LIST
100024: LIST
100025: LIST
100026: LIST
100027: LIST
100028: LIST
100029: LIST
100030: LIST
100031: LIST
100032: LIST
100033: LIST
100034: LIST
100035: LIST
100036: LIST
100037: PUSH
100038: EMPTY
100039: LIST
100040: LIST
100041: ST_TO_ADDR
// if result then
100042: LD_VAR 0 2
100046: IFFALSE 100832
// begin normal :=  ;
100048: LD_ADDR_VAR 0 5
100052: PUSH
100053: LD_STRING 
100055: ST_TO_ADDR
// hardcore :=  ;
100056: LD_ADDR_VAR 0 6
100060: PUSH
100061: LD_STRING 
100063: ST_TO_ADDR
// active :=  ;
100064: LD_ADDR_VAR 0 7
100068: PUSH
100069: LD_STRING 
100071: ST_TO_ADDR
// for i = 1 to normalCounter do
100072: LD_ADDR_VAR 0 8
100076: PUSH
100077: DOUBLE
100078: LD_INT 1
100080: DEC
100081: ST_TO_ADDR
100082: LD_EXP 125
100086: PUSH
100087: FOR_TO
100088: IFFALSE 100189
// begin tmp := 0 ;
100090: LD_ADDR_VAR 0 3
100094: PUSH
100095: LD_STRING 0
100097: ST_TO_ADDR
// if result [ 1 ] then
100098: LD_VAR 0 2
100102: PUSH
100103: LD_INT 1
100105: ARRAY
100106: IFFALSE 100171
// if result [ 1 ] [ 1 ] = i then
100108: LD_VAR 0 2
100112: PUSH
100113: LD_INT 1
100115: ARRAY
100116: PUSH
100117: LD_INT 1
100119: ARRAY
100120: PUSH
100121: LD_VAR 0 8
100125: EQUAL
100126: IFFALSE 100171
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
100128: LD_ADDR_VAR 0 2
100132: PUSH
100133: LD_VAR 0 2
100137: PPUSH
100138: LD_INT 1
100140: PPUSH
100141: LD_VAR 0 2
100145: PUSH
100146: LD_INT 1
100148: ARRAY
100149: PPUSH
100150: LD_INT 1
100152: PPUSH
100153: CALL_OW 3
100157: PPUSH
100158: CALL_OW 1
100162: ST_TO_ADDR
// tmp := 1 ;
100163: LD_ADDR_VAR 0 3
100167: PUSH
100168: LD_STRING 1
100170: ST_TO_ADDR
// end ; normal := normal & tmp ;
100171: LD_ADDR_VAR 0 5
100175: PUSH
100176: LD_VAR 0 5
100180: PUSH
100181: LD_VAR 0 3
100185: STR
100186: ST_TO_ADDR
// end ;
100187: GO 100087
100189: POP
100190: POP
// for i = 1 to hardcoreCounter do
100191: LD_ADDR_VAR 0 8
100195: PUSH
100196: DOUBLE
100197: LD_INT 1
100199: DEC
100200: ST_TO_ADDR
100201: LD_EXP 126
100205: PUSH
100206: FOR_TO
100207: IFFALSE 100312
// begin tmp := 0 ;
100209: LD_ADDR_VAR 0 3
100213: PUSH
100214: LD_STRING 0
100216: ST_TO_ADDR
// if result [ 2 ] then
100217: LD_VAR 0 2
100221: PUSH
100222: LD_INT 2
100224: ARRAY
100225: IFFALSE 100294
// if result [ 2 ] [ 1 ] = 100 + i then
100227: LD_VAR 0 2
100231: PUSH
100232: LD_INT 2
100234: ARRAY
100235: PUSH
100236: LD_INT 1
100238: ARRAY
100239: PUSH
100240: LD_INT 100
100242: PUSH
100243: LD_VAR 0 8
100247: PLUS
100248: EQUAL
100249: IFFALSE 100294
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100251: LD_ADDR_VAR 0 2
100255: PUSH
100256: LD_VAR 0 2
100260: PPUSH
100261: LD_INT 2
100263: PPUSH
100264: LD_VAR 0 2
100268: PUSH
100269: LD_INT 2
100271: ARRAY
100272: PPUSH
100273: LD_INT 1
100275: PPUSH
100276: CALL_OW 3
100280: PPUSH
100281: CALL_OW 1
100285: ST_TO_ADDR
// tmp := 1 ;
100286: LD_ADDR_VAR 0 3
100290: PUSH
100291: LD_STRING 1
100293: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100294: LD_ADDR_VAR 0 6
100298: PUSH
100299: LD_VAR 0 6
100303: PUSH
100304: LD_VAR 0 3
100308: STR
100309: ST_TO_ADDR
// end ;
100310: GO 100206
100312: POP
100313: POP
// if isGameLoad then
100314: LD_VAR 0 1
100318: IFFALSE 100793
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100320: LD_ADDR_VAR 0 4
100324: PUSH
100325: LD_EXP 129
100329: PUSH
100330: LD_EXP 128
100334: PUSH
100335: LD_EXP 130
100339: PUSH
100340: LD_EXP 127
100344: PUSH
100345: LD_EXP 131
100349: PUSH
100350: LD_EXP 132
100354: PUSH
100355: LD_EXP 133
100359: PUSH
100360: LD_EXP 134
100364: PUSH
100365: LD_EXP 135
100369: PUSH
100370: LD_EXP 136
100374: PUSH
100375: LD_EXP 137
100379: PUSH
100380: LD_EXP 138
100384: PUSH
100385: LD_EXP 139
100389: PUSH
100390: LD_EXP 140
100394: PUSH
100395: LD_EXP 148
100399: PUSH
100400: LD_EXP 149
100404: PUSH
100405: LD_EXP 150
100409: PUSH
100410: LD_EXP 151
100414: PUSH
100415: LD_EXP 153
100419: PUSH
100420: LD_EXP 154
100424: PUSH
100425: LD_EXP 155
100429: PUSH
100430: LD_EXP 158
100434: PUSH
100435: LD_EXP 160
100439: PUSH
100440: LD_EXP 161
100444: PUSH
100445: LD_EXP 162
100449: PUSH
100450: LD_EXP 164
100454: PUSH
100455: LD_EXP 165
100459: PUSH
100460: LD_EXP 168
100464: PUSH
100465: LD_EXP 169
100469: PUSH
100470: LD_EXP 170
100474: PUSH
100475: LD_EXP 171
100479: PUSH
100480: LD_EXP 172
100484: PUSH
100485: LD_EXP 173
100489: PUSH
100490: LD_EXP 174
100494: PUSH
100495: LD_EXP 175
100499: PUSH
100500: LD_EXP 176
100504: PUSH
100505: LD_EXP 141
100509: PUSH
100510: LD_EXP 142
100514: PUSH
100515: LD_EXP 145
100519: PUSH
100520: LD_EXP 146
100524: PUSH
100525: LD_EXP 147
100529: PUSH
100530: LD_EXP 143
100534: PUSH
100535: LD_EXP 144
100539: PUSH
100540: LD_EXP 152
100544: PUSH
100545: LD_EXP 156
100549: PUSH
100550: LD_EXP 157
100554: PUSH
100555: LD_EXP 159
100559: PUSH
100560: LD_EXP 163
100564: PUSH
100565: LD_EXP 166
100569: PUSH
100570: LD_EXP 167
100574: PUSH
100575: LD_EXP 177
100579: PUSH
100580: LD_EXP 178
100584: PUSH
100585: LD_EXP 179
100589: PUSH
100590: LD_EXP 180
100594: PUSH
100595: EMPTY
100596: LIST
100597: LIST
100598: LIST
100599: LIST
100600: LIST
100601: LIST
100602: LIST
100603: LIST
100604: LIST
100605: LIST
100606: LIST
100607: LIST
100608: LIST
100609: LIST
100610: LIST
100611: LIST
100612: LIST
100613: LIST
100614: LIST
100615: LIST
100616: LIST
100617: LIST
100618: LIST
100619: LIST
100620: LIST
100621: LIST
100622: LIST
100623: LIST
100624: LIST
100625: LIST
100626: LIST
100627: LIST
100628: LIST
100629: LIST
100630: LIST
100631: LIST
100632: LIST
100633: LIST
100634: LIST
100635: LIST
100636: LIST
100637: LIST
100638: LIST
100639: LIST
100640: LIST
100641: LIST
100642: LIST
100643: LIST
100644: LIST
100645: LIST
100646: LIST
100647: LIST
100648: LIST
100649: LIST
100650: ST_TO_ADDR
// tmp :=  ;
100651: LD_ADDR_VAR 0 3
100655: PUSH
100656: LD_STRING 
100658: ST_TO_ADDR
// for i = 1 to normalCounter do
100659: LD_ADDR_VAR 0 8
100663: PUSH
100664: DOUBLE
100665: LD_INT 1
100667: DEC
100668: ST_TO_ADDR
100669: LD_EXP 125
100673: PUSH
100674: FOR_TO
100675: IFFALSE 100711
// begin if flags [ i ] then
100677: LD_VAR 0 4
100681: PUSH
100682: LD_VAR 0 8
100686: ARRAY
100687: IFFALSE 100709
// tmp := tmp & i & ; ;
100689: LD_ADDR_VAR 0 3
100693: PUSH
100694: LD_VAR 0 3
100698: PUSH
100699: LD_VAR 0 8
100703: STR
100704: PUSH
100705: LD_STRING ;
100707: STR
100708: ST_TO_ADDR
// end ;
100709: GO 100674
100711: POP
100712: POP
// for i = 1 to hardcoreCounter do
100713: LD_ADDR_VAR 0 8
100717: PUSH
100718: DOUBLE
100719: LD_INT 1
100721: DEC
100722: ST_TO_ADDR
100723: LD_EXP 126
100727: PUSH
100728: FOR_TO
100729: IFFALSE 100775
// begin if flags [ normalCounter + i ] then
100731: LD_VAR 0 4
100735: PUSH
100736: LD_EXP 125
100740: PUSH
100741: LD_VAR 0 8
100745: PLUS
100746: ARRAY
100747: IFFALSE 100773
// tmp := tmp & ( 100 + i ) & ; ;
100749: LD_ADDR_VAR 0 3
100753: PUSH
100754: LD_VAR 0 3
100758: PUSH
100759: LD_INT 100
100761: PUSH
100762: LD_VAR 0 8
100766: PLUS
100767: STR
100768: PUSH
100769: LD_STRING ;
100771: STR
100772: ST_TO_ADDR
// end ;
100773: GO 100728
100775: POP
100776: POP
// if tmp then
100777: LD_VAR 0 3
100781: IFFALSE 100793
// active := tmp ;
100783: LD_ADDR_VAR 0 7
100787: PUSH
100788: LD_VAR 0 3
100792: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100793: LD_STRING getStreamItemsFromMission("
100795: PUSH
100796: LD_VAR 0 5
100800: STR
100801: PUSH
100802: LD_STRING ","
100804: STR
100805: PUSH
100806: LD_VAR 0 6
100810: STR
100811: PUSH
100812: LD_STRING ","
100814: STR
100815: PUSH
100816: LD_VAR 0 7
100820: STR
100821: PUSH
100822: LD_STRING ")
100824: STR
100825: PPUSH
100826: CALL_OW 559
// end else
100830: GO 100839
// ToLua ( getStreamItemsFromMission("","","") ) ;
100832: LD_STRING getStreamItemsFromMission("","","")
100834: PPUSH
100835: CALL_OW 559
// end ;
100839: LD_VAR 0 2
100843: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100844: LD_EXP 124
100848: PUSH
100849: LD_EXP 129
100853: AND
100854: IFFALSE 100978
100856: GO 100858
100858: DISABLE
100859: LD_INT 0
100861: PPUSH
100862: PPUSH
// begin enable ;
100863: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100864: LD_ADDR_VAR 0 2
100868: PUSH
100869: LD_INT 22
100871: PUSH
100872: LD_OWVAR 2
100876: PUSH
100877: EMPTY
100878: LIST
100879: LIST
100880: PUSH
100881: LD_INT 2
100883: PUSH
100884: LD_INT 34
100886: PUSH
100887: LD_INT 7
100889: PUSH
100890: EMPTY
100891: LIST
100892: LIST
100893: PUSH
100894: LD_INT 34
100896: PUSH
100897: LD_INT 45
100899: PUSH
100900: EMPTY
100901: LIST
100902: LIST
100903: PUSH
100904: LD_INT 34
100906: PUSH
100907: LD_INT 28
100909: PUSH
100910: EMPTY
100911: LIST
100912: LIST
100913: PUSH
100914: LD_INT 34
100916: PUSH
100917: LD_INT 47
100919: PUSH
100920: EMPTY
100921: LIST
100922: LIST
100923: PUSH
100924: EMPTY
100925: LIST
100926: LIST
100927: LIST
100928: LIST
100929: LIST
100930: PUSH
100931: EMPTY
100932: LIST
100933: LIST
100934: PPUSH
100935: CALL_OW 69
100939: ST_TO_ADDR
// if not tmp then
100940: LD_VAR 0 2
100944: NOT
100945: IFFALSE 100949
// exit ;
100947: GO 100978
// for i in tmp do
100949: LD_ADDR_VAR 0 1
100953: PUSH
100954: LD_VAR 0 2
100958: PUSH
100959: FOR_IN
100960: IFFALSE 100976
// begin SetLives ( i , 0 ) ;
100962: LD_VAR 0 1
100966: PPUSH
100967: LD_INT 0
100969: PPUSH
100970: CALL_OW 234
// end ;
100974: GO 100959
100976: POP
100977: POP
// end ;
100978: PPOPN 2
100980: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100981: LD_EXP 124
100985: PUSH
100986: LD_EXP 130
100990: AND
100991: IFFALSE 101075
100993: GO 100995
100995: DISABLE
100996: LD_INT 0
100998: PPUSH
100999: PPUSH
// begin enable ;
101000: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
101001: LD_ADDR_VAR 0 2
101005: PUSH
101006: LD_INT 22
101008: PUSH
101009: LD_OWVAR 2
101013: PUSH
101014: EMPTY
101015: LIST
101016: LIST
101017: PUSH
101018: LD_INT 32
101020: PUSH
101021: LD_INT 3
101023: PUSH
101024: EMPTY
101025: LIST
101026: LIST
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: PPUSH
101032: CALL_OW 69
101036: ST_TO_ADDR
// if not tmp then
101037: LD_VAR 0 2
101041: NOT
101042: IFFALSE 101046
// exit ;
101044: GO 101075
// for i in tmp do
101046: LD_ADDR_VAR 0 1
101050: PUSH
101051: LD_VAR 0 2
101055: PUSH
101056: FOR_IN
101057: IFFALSE 101073
// begin SetLives ( i , 0 ) ;
101059: LD_VAR 0 1
101063: PPUSH
101064: LD_INT 0
101066: PPUSH
101067: CALL_OW 234
// end ;
101071: GO 101056
101073: POP
101074: POP
// end ;
101075: PPOPN 2
101077: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
101078: LD_EXP 124
101082: PUSH
101083: LD_EXP 127
101087: AND
101088: IFFALSE 101181
101090: GO 101092
101092: DISABLE
101093: LD_INT 0
101095: PPUSH
// begin enable ;
101096: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
101097: LD_ADDR_VAR 0 1
101101: PUSH
101102: LD_INT 22
101104: PUSH
101105: LD_OWVAR 2
101109: PUSH
101110: EMPTY
101111: LIST
101112: LIST
101113: PUSH
101114: LD_INT 2
101116: PUSH
101117: LD_INT 25
101119: PUSH
101120: LD_INT 5
101122: PUSH
101123: EMPTY
101124: LIST
101125: LIST
101126: PUSH
101127: LD_INT 25
101129: PUSH
101130: LD_INT 9
101132: PUSH
101133: EMPTY
101134: LIST
101135: LIST
101136: PUSH
101137: LD_INT 25
101139: PUSH
101140: LD_INT 8
101142: PUSH
101143: EMPTY
101144: LIST
101145: LIST
101146: PUSH
101147: EMPTY
101148: LIST
101149: LIST
101150: LIST
101151: LIST
101152: PUSH
101153: EMPTY
101154: LIST
101155: LIST
101156: PPUSH
101157: CALL_OW 69
101161: PUSH
101162: FOR_IN
101163: IFFALSE 101179
// begin SetClass ( i , 1 ) ;
101165: LD_VAR 0 1
101169: PPUSH
101170: LD_INT 1
101172: PPUSH
101173: CALL_OW 336
// end ;
101177: GO 101162
101179: POP
101180: POP
// end ;
101181: PPOPN 1
101183: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101184: LD_EXP 124
101188: PUSH
101189: LD_EXP 128
101193: AND
101194: PUSH
101195: LD_OWVAR 65
101199: PUSH
101200: LD_INT 7
101202: LESS
101203: AND
101204: IFFALSE 101218
101206: GO 101208
101208: DISABLE
// begin enable ;
101209: ENABLE
// game_speed := 7 ;
101210: LD_ADDR_OWVAR 65
101214: PUSH
101215: LD_INT 7
101217: ST_TO_ADDR
// end ;
101218: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101219: LD_EXP 124
101223: PUSH
101224: LD_EXP 131
101228: AND
101229: IFFALSE 101431
101231: GO 101233
101233: DISABLE
101234: LD_INT 0
101236: PPUSH
101237: PPUSH
101238: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101239: LD_ADDR_VAR 0 3
101243: PUSH
101244: LD_INT 81
101246: PUSH
101247: LD_OWVAR 2
101251: PUSH
101252: EMPTY
101253: LIST
101254: LIST
101255: PUSH
101256: LD_INT 21
101258: PUSH
101259: LD_INT 1
101261: PUSH
101262: EMPTY
101263: LIST
101264: LIST
101265: PUSH
101266: EMPTY
101267: LIST
101268: LIST
101269: PPUSH
101270: CALL_OW 69
101274: ST_TO_ADDR
// if not tmp then
101275: LD_VAR 0 3
101279: NOT
101280: IFFALSE 101284
// exit ;
101282: GO 101431
// if tmp > 5 then
101284: LD_VAR 0 3
101288: PUSH
101289: LD_INT 5
101291: GREATER
101292: IFFALSE 101304
// k := 5 else
101294: LD_ADDR_VAR 0 2
101298: PUSH
101299: LD_INT 5
101301: ST_TO_ADDR
101302: GO 101314
// k := tmp ;
101304: LD_ADDR_VAR 0 2
101308: PUSH
101309: LD_VAR 0 3
101313: ST_TO_ADDR
// for i := 1 to k do
101314: LD_ADDR_VAR 0 1
101318: PUSH
101319: DOUBLE
101320: LD_INT 1
101322: DEC
101323: ST_TO_ADDR
101324: LD_VAR 0 2
101328: PUSH
101329: FOR_TO
101330: IFFALSE 101429
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101332: LD_VAR 0 3
101336: PUSH
101337: LD_VAR 0 1
101341: ARRAY
101342: PPUSH
101343: LD_VAR 0 1
101347: PUSH
101348: LD_INT 4
101350: MOD
101351: PUSH
101352: LD_INT 1
101354: PLUS
101355: PPUSH
101356: CALL_OW 259
101360: PUSH
101361: LD_INT 10
101363: LESS
101364: IFFALSE 101427
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101366: LD_VAR 0 3
101370: PUSH
101371: LD_VAR 0 1
101375: ARRAY
101376: PPUSH
101377: LD_VAR 0 1
101381: PUSH
101382: LD_INT 4
101384: MOD
101385: PUSH
101386: LD_INT 1
101388: PLUS
101389: PPUSH
101390: LD_VAR 0 3
101394: PUSH
101395: LD_VAR 0 1
101399: ARRAY
101400: PPUSH
101401: LD_VAR 0 1
101405: PUSH
101406: LD_INT 4
101408: MOD
101409: PUSH
101410: LD_INT 1
101412: PLUS
101413: PPUSH
101414: CALL_OW 259
101418: PUSH
101419: LD_INT 1
101421: PLUS
101422: PPUSH
101423: CALL_OW 237
101427: GO 101329
101429: POP
101430: POP
// end ;
101431: PPOPN 3
101433: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101434: LD_EXP 124
101438: PUSH
101439: LD_EXP 132
101443: AND
101444: IFFALSE 101464
101446: GO 101448
101448: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101449: LD_INT 4
101451: PPUSH
101452: LD_OWVAR 2
101456: PPUSH
101457: LD_INT 0
101459: PPUSH
101460: CALL_OW 324
101464: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101465: LD_EXP 124
101469: PUSH
101470: LD_EXP 161
101474: AND
101475: IFFALSE 101495
101477: GO 101479
101479: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101480: LD_INT 19
101482: PPUSH
101483: LD_OWVAR 2
101487: PPUSH
101488: LD_INT 0
101490: PPUSH
101491: CALL_OW 324
101495: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101496: LD_EXP 124
101500: PUSH
101501: LD_EXP 133
101505: AND
101506: IFFALSE 101608
101508: GO 101510
101510: DISABLE
101511: LD_INT 0
101513: PPUSH
101514: PPUSH
// begin enable ;
101515: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101516: LD_ADDR_VAR 0 2
101520: PUSH
101521: LD_INT 22
101523: PUSH
101524: LD_OWVAR 2
101528: PUSH
101529: EMPTY
101530: LIST
101531: LIST
101532: PUSH
101533: LD_INT 2
101535: PUSH
101536: LD_INT 34
101538: PUSH
101539: LD_INT 11
101541: PUSH
101542: EMPTY
101543: LIST
101544: LIST
101545: PUSH
101546: LD_INT 34
101548: PUSH
101549: LD_INT 30
101551: PUSH
101552: EMPTY
101553: LIST
101554: LIST
101555: PUSH
101556: EMPTY
101557: LIST
101558: LIST
101559: LIST
101560: PUSH
101561: EMPTY
101562: LIST
101563: LIST
101564: PPUSH
101565: CALL_OW 69
101569: ST_TO_ADDR
// if not tmp then
101570: LD_VAR 0 2
101574: NOT
101575: IFFALSE 101579
// exit ;
101577: GO 101608
// for i in tmp do
101579: LD_ADDR_VAR 0 1
101583: PUSH
101584: LD_VAR 0 2
101588: PUSH
101589: FOR_IN
101590: IFFALSE 101606
// begin SetLives ( i , 0 ) ;
101592: LD_VAR 0 1
101596: PPUSH
101597: LD_INT 0
101599: PPUSH
101600: CALL_OW 234
// end ;
101604: GO 101589
101606: POP
101607: POP
// end ;
101608: PPOPN 2
101610: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101611: LD_EXP 124
101615: PUSH
101616: LD_EXP 134
101620: AND
101621: IFFALSE 101641
101623: GO 101625
101625: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101626: LD_INT 32
101628: PPUSH
101629: LD_OWVAR 2
101633: PPUSH
101634: LD_INT 0
101636: PPUSH
101637: CALL_OW 324
101641: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101642: LD_EXP 124
101646: PUSH
101647: LD_EXP 135
101651: AND
101652: IFFALSE 101833
101654: GO 101656
101656: DISABLE
101657: LD_INT 0
101659: PPUSH
101660: PPUSH
101661: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101662: LD_ADDR_VAR 0 2
101666: PUSH
101667: LD_INT 22
101669: PUSH
101670: LD_OWVAR 2
101674: PUSH
101675: EMPTY
101676: LIST
101677: LIST
101678: PUSH
101679: LD_INT 33
101681: PUSH
101682: LD_INT 3
101684: PUSH
101685: EMPTY
101686: LIST
101687: LIST
101688: PUSH
101689: EMPTY
101690: LIST
101691: LIST
101692: PPUSH
101693: CALL_OW 69
101697: ST_TO_ADDR
// if not tmp then
101698: LD_VAR 0 2
101702: NOT
101703: IFFALSE 101707
// exit ;
101705: GO 101833
// side := 0 ;
101707: LD_ADDR_VAR 0 3
101711: PUSH
101712: LD_INT 0
101714: ST_TO_ADDR
// for i := 1 to 8 do
101715: LD_ADDR_VAR 0 1
101719: PUSH
101720: DOUBLE
101721: LD_INT 1
101723: DEC
101724: ST_TO_ADDR
101725: LD_INT 8
101727: PUSH
101728: FOR_TO
101729: IFFALSE 101777
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101731: LD_OWVAR 2
101735: PUSH
101736: LD_VAR 0 1
101740: NONEQUAL
101741: PUSH
101742: LD_OWVAR 2
101746: PPUSH
101747: LD_VAR 0 1
101751: PPUSH
101752: CALL_OW 81
101756: PUSH
101757: LD_INT 2
101759: EQUAL
101760: AND
101761: IFFALSE 101775
// begin side := i ;
101763: LD_ADDR_VAR 0 3
101767: PUSH
101768: LD_VAR 0 1
101772: ST_TO_ADDR
// break ;
101773: GO 101777
// end ;
101775: GO 101728
101777: POP
101778: POP
// if not side then
101779: LD_VAR 0 3
101783: NOT
101784: IFFALSE 101788
// exit ;
101786: GO 101833
// for i := 1 to tmp do
101788: LD_ADDR_VAR 0 1
101792: PUSH
101793: DOUBLE
101794: LD_INT 1
101796: DEC
101797: ST_TO_ADDR
101798: LD_VAR 0 2
101802: PUSH
101803: FOR_TO
101804: IFFALSE 101831
// if Prob ( 60 ) then
101806: LD_INT 60
101808: PPUSH
101809: CALL_OW 13
101813: IFFALSE 101829
// SetSide ( i , side ) ;
101815: LD_VAR 0 1
101819: PPUSH
101820: LD_VAR 0 3
101824: PPUSH
101825: CALL_OW 235
101829: GO 101803
101831: POP
101832: POP
// end ;
101833: PPOPN 3
101835: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101836: LD_EXP 124
101840: PUSH
101841: LD_EXP 137
101845: AND
101846: IFFALSE 101965
101848: GO 101850
101850: DISABLE
101851: LD_INT 0
101853: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101854: LD_ADDR_VAR 0 1
101858: PUSH
101859: LD_INT 22
101861: PUSH
101862: LD_OWVAR 2
101866: PUSH
101867: EMPTY
101868: LIST
101869: LIST
101870: PUSH
101871: LD_INT 21
101873: PUSH
101874: LD_INT 1
101876: PUSH
101877: EMPTY
101878: LIST
101879: LIST
101880: PUSH
101881: LD_INT 3
101883: PUSH
101884: LD_INT 23
101886: PUSH
101887: LD_INT 0
101889: PUSH
101890: EMPTY
101891: LIST
101892: LIST
101893: PUSH
101894: EMPTY
101895: LIST
101896: LIST
101897: PUSH
101898: EMPTY
101899: LIST
101900: LIST
101901: LIST
101902: PPUSH
101903: CALL_OW 69
101907: PUSH
101908: FOR_IN
101909: IFFALSE 101963
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101911: LD_VAR 0 1
101915: PPUSH
101916: CALL_OW 257
101920: PUSH
101921: LD_INT 1
101923: PUSH
101924: LD_INT 2
101926: PUSH
101927: LD_INT 3
101929: PUSH
101930: LD_INT 4
101932: PUSH
101933: EMPTY
101934: LIST
101935: LIST
101936: LIST
101937: LIST
101938: IN
101939: IFFALSE 101961
// SetClass ( un , rand ( 1 , 4 ) ) ;
101941: LD_VAR 0 1
101945: PPUSH
101946: LD_INT 1
101948: PPUSH
101949: LD_INT 4
101951: PPUSH
101952: CALL_OW 12
101956: PPUSH
101957: CALL_OW 336
101961: GO 101908
101963: POP
101964: POP
// end ;
101965: PPOPN 1
101967: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101968: LD_EXP 124
101972: PUSH
101973: LD_EXP 136
101977: AND
101978: IFFALSE 102057
101980: GO 101982
101982: DISABLE
101983: LD_INT 0
101985: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101986: LD_ADDR_VAR 0 1
101990: PUSH
101991: LD_INT 22
101993: PUSH
101994: LD_OWVAR 2
101998: PUSH
101999: EMPTY
102000: LIST
102001: LIST
102002: PUSH
102003: LD_INT 21
102005: PUSH
102006: LD_INT 3
102008: PUSH
102009: EMPTY
102010: LIST
102011: LIST
102012: PUSH
102013: EMPTY
102014: LIST
102015: LIST
102016: PPUSH
102017: CALL_OW 69
102021: ST_TO_ADDR
// if not tmp then
102022: LD_VAR 0 1
102026: NOT
102027: IFFALSE 102031
// exit ;
102029: GO 102057
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
102031: LD_VAR 0 1
102035: PUSH
102036: LD_INT 1
102038: PPUSH
102039: LD_VAR 0 1
102043: PPUSH
102044: CALL_OW 12
102048: ARRAY
102049: PPUSH
102050: LD_INT 100
102052: PPUSH
102053: CALL_OW 234
// end ;
102057: PPOPN 1
102059: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
102060: LD_EXP 124
102064: PUSH
102065: LD_EXP 138
102069: AND
102070: IFFALSE 102168
102072: GO 102074
102074: DISABLE
102075: LD_INT 0
102077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102078: LD_ADDR_VAR 0 1
102082: PUSH
102083: LD_INT 22
102085: PUSH
102086: LD_OWVAR 2
102090: PUSH
102091: EMPTY
102092: LIST
102093: LIST
102094: PUSH
102095: LD_INT 21
102097: PUSH
102098: LD_INT 1
102100: PUSH
102101: EMPTY
102102: LIST
102103: LIST
102104: PUSH
102105: EMPTY
102106: LIST
102107: LIST
102108: PPUSH
102109: CALL_OW 69
102113: ST_TO_ADDR
// if not tmp then
102114: LD_VAR 0 1
102118: NOT
102119: IFFALSE 102123
// exit ;
102121: GO 102168
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
102123: LD_VAR 0 1
102127: PUSH
102128: LD_INT 1
102130: PPUSH
102131: LD_VAR 0 1
102135: PPUSH
102136: CALL_OW 12
102140: ARRAY
102141: PPUSH
102142: LD_INT 1
102144: PPUSH
102145: LD_INT 4
102147: PPUSH
102148: CALL_OW 12
102152: PPUSH
102153: LD_INT 3000
102155: PPUSH
102156: LD_INT 9000
102158: PPUSH
102159: CALL_OW 12
102163: PPUSH
102164: CALL_OW 492
// end ;
102168: PPOPN 1
102170: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102171: LD_EXP 124
102175: PUSH
102176: LD_EXP 139
102180: AND
102181: IFFALSE 102201
102183: GO 102185
102185: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102186: LD_INT 1
102188: PPUSH
102189: LD_OWVAR 2
102193: PPUSH
102194: LD_INT 0
102196: PPUSH
102197: CALL_OW 324
102201: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102202: LD_EXP 124
102206: PUSH
102207: LD_EXP 140
102211: AND
102212: IFFALSE 102295
102214: GO 102216
102216: DISABLE
102217: LD_INT 0
102219: PPUSH
102220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102221: LD_ADDR_VAR 0 2
102225: PUSH
102226: LD_INT 22
102228: PUSH
102229: LD_OWVAR 2
102233: PUSH
102234: EMPTY
102235: LIST
102236: LIST
102237: PUSH
102238: LD_INT 21
102240: PUSH
102241: LD_INT 3
102243: PUSH
102244: EMPTY
102245: LIST
102246: LIST
102247: PUSH
102248: EMPTY
102249: LIST
102250: LIST
102251: PPUSH
102252: CALL_OW 69
102256: ST_TO_ADDR
// if not tmp then
102257: LD_VAR 0 2
102261: NOT
102262: IFFALSE 102266
// exit ;
102264: GO 102295
// for i in tmp do
102266: LD_ADDR_VAR 0 1
102270: PUSH
102271: LD_VAR 0 2
102275: PUSH
102276: FOR_IN
102277: IFFALSE 102293
// SetBLevel ( i , 10 ) ;
102279: LD_VAR 0 1
102283: PPUSH
102284: LD_INT 10
102286: PPUSH
102287: CALL_OW 241
102291: GO 102276
102293: POP
102294: POP
// end ;
102295: PPOPN 2
102297: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102298: LD_EXP 124
102302: PUSH
102303: LD_EXP 141
102307: AND
102308: IFFALSE 102419
102310: GO 102312
102312: DISABLE
102313: LD_INT 0
102315: PPUSH
102316: PPUSH
102317: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102318: LD_ADDR_VAR 0 3
102322: PUSH
102323: LD_INT 22
102325: PUSH
102326: LD_OWVAR 2
102330: PUSH
102331: EMPTY
102332: LIST
102333: LIST
102334: PUSH
102335: LD_INT 25
102337: PUSH
102338: LD_INT 1
102340: PUSH
102341: EMPTY
102342: LIST
102343: LIST
102344: PUSH
102345: EMPTY
102346: LIST
102347: LIST
102348: PPUSH
102349: CALL_OW 69
102353: ST_TO_ADDR
// if not tmp then
102354: LD_VAR 0 3
102358: NOT
102359: IFFALSE 102363
// exit ;
102361: GO 102419
// un := tmp [ rand ( 1 , tmp ) ] ;
102363: LD_ADDR_VAR 0 2
102367: PUSH
102368: LD_VAR 0 3
102372: PUSH
102373: LD_INT 1
102375: PPUSH
102376: LD_VAR 0 3
102380: PPUSH
102381: CALL_OW 12
102385: ARRAY
102386: ST_TO_ADDR
// if Crawls ( un ) then
102387: LD_VAR 0 2
102391: PPUSH
102392: CALL_OW 318
102396: IFFALSE 102407
// ComWalk ( un ) ;
102398: LD_VAR 0 2
102402: PPUSH
102403: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102407: LD_VAR 0 2
102411: PPUSH
102412: LD_INT 5
102414: PPUSH
102415: CALL_OW 336
// end ;
102419: PPOPN 3
102421: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102422: LD_EXP 124
102426: PUSH
102427: LD_EXP 142
102431: AND
102432: PUSH
102433: LD_OWVAR 67
102437: PUSH
102438: LD_INT 4
102440: LESS
102441: AND
102442: IFFALSE 102461
102444: GO 102446
102446: DISABLE
// begin Difficulty := Difficulty + 1 ;
102447: LD_ADDR_OWVAR 67
102451: PUSH
102452: LD_OWVAR 67
102456: PUSH
102457: LD_INT 1
102459: PLUS
102460: ST_TO_ADDR
// end ;
102461: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102462: LD_EXP 124
102466: PUSH
102467: LD_EXP 143
102471: AND
102472: IFFALSE 102575
102474: GO 102476
102476: DISABLE
102477: LD_INT 0
102479: PPUSH
// begin for i := 1 to 5 do
102480: LD_ADDR_VAR 0 1
102484: PUSH
102485: DOUBLE
102486: LD_INT 1
102488: DEC
102489: ST_TO_ADDR
102490: LD_INT 5
102492: PUSH
102493: FOR_TO
102494: IFFALSE 102573
// begin uc_nation := nation_nature ;
102496: LD_ADDR_OWVAR 21
102500: PUSH
102501: LD_INT 0
102503: ST_TO_ADDR
// uc_side := 0 ;
102504: LD_ADDR_OWVAR 20
102508: PUSH
102509: LD_INT 0
102511: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102512: LD_ADDR_OWVAR 29
102516: PUSH
102517: LD_INT 12
102519: PUSH
102520: LD_INT 12
102522: PUSH
102523: EMPTY
102524: LIST
102525: LIST
102526: ST_TO_ADDR
// hc_agressivity := 20 ;
102527: LD_ADDR_OWVAR 35
102531: PUSH
102532: LD_INT 20
102534: ST_TO_ADDR
// hc_class := class_tiger ;
102535: LD_ADDR_OWVAR 28
102539: PUSH
102540: LD_INT 14
102542: ST_TO_ADDR
// hc_gallery :=  ;
102543: LD_ADDR_OWVAR 33
102547: PUSH
102548: LD_STRING 
102550: ST_TO_ADDR
// hc_name :=  ;
102551: LD_ADDR_OWVAR 26
102555: PUSH
102556: LD_STRING 
102558: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102559: CALL_OW 44
102563: PPUSH
102564: LD_INT 0
102566: PPUSH
102567: CALL_OW 51
// end ;
102571: GO 102493
102573: POP
102574: POP
// end ;
102575: PPOPN 1
102577: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102578: LD_EXP 124
102582: PUSH
102583: LD_EXP 144
102587: AND
102588: IFFALSE 102597
102590: GO 102592
102592: DISABLE
// StreamSibBomb ;
102593: CALL 102598 0 0
102597: END
// export function StreamSibBomb ; var i , x , y ; begin
102598: LD_INT 0
102600: PPUSH
102601: PPUSH
102602: PPUSH
102603: PPUSH
// result := false ;
102604: LD_ADDR_VAR 0 1
102608: PUSH
102609: LD_INT 0
102611: ST_TO_ADDR
// for i := 1 to 16 do
102612: LD_ADDR_VAR 0 2
102616: PUSH
102617: DOUBLE
102618: LD_INT 1
102620: DEC
102621: ST_TO_ADDR
102622: LD_INT 16
102624: PUSH
102625: FOR_TO
102626: IFFALSE 102825
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102628: LD_ADDR_VAR 0 3
102632: PUSH
102633: LD_INT 10
102635: PUSH
102636: LD_INT 20
102638: PUSH
102639: LD_INT 30
102641: PUSH
102642: LD_INT 40
102644: PUSH
102645: LD_INT 50
102647: PUSH
102648: LD_INT 60
102650: PUSH
102651: LD_INT 70
102653: PUSH
102654: LD_INT 80
102656: PUSH
102657: LD_INT 90
102659: PUSH
102660: LD_INT 100
102662: PUSH
102663: LD_INT 110
102665: PUSH
102666: LD_INT 120
102668: PUSH
102669: LD_INT 130
102671: PUSH
102672: LD_INT 140
102674: PUSH
102675: LD_INT 150
102677: PUSH
102678: EMPTY
102679: LIST
102680: LIST
102681: LIST
102682: LIST
102683: LIST
102684: LIST
102685: LIST
102686: LIST
102687: LIST
102688: LIST
102689: LIST
102690: LIST
102691: LIST
102692: LIST
102693: LIST
102694: PUSH
102695: LD_INT 1
102697: PPUSH
102698: LD_INT 15
102700: PPUSH
102701: CALL_OW 12
102705: ARRAY
102706: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102707: LD_ADDR_VAR 0 4
102711: PUSH
102712: LD_INT 10
102714: PUSH
102715: LD_INT 20
102717: PUSH
102718: LD_INT 30
102720: PUSH
102721: LD_INT 40
102723: PUSH
102724: LD_INT 50
102726: PUSH
102727: LD_INT 60
102729: PUSH
102730: LD_INT 70
102732: PUSH
102733: LD_INT 80
102735: PUSH
102736: LD_INT 90
102738: PUSH
102739: LD_INT 100
102741: PUSH
102742: LD_INT 110
102744: PUSH
102745: LD_INT 120
102747: PUSH
102748: LD_INT 130
102750: PUSH
102751: LD_INT 140
102753: PUSH
102754: LD_INT 150
102756: PUSH
102757: EMPTY
102758: LIST
102759: LIST
102760: LIST
102761: LIST
102762: LIST
102763: LIST
102764: LIST
102765: LIST
102766: LIST
102767: LIST
102768: LIST
102769: LIST
102770: LIST
102771: LIST
102772: LIST
102773: PUSH
102774: LD_INT 1
102776: PPUSH
102777: LD_INT 15
102779: PPUSH
102780: CALL_OW 12
102784: ARRAY
102785: ST_TO_ADDR
// if ValidHex ( x , y ) then
102786: LD_VAR 0 3
102790: PPUSH
102791: LD_VAR 0 4
102795: PPUSH
102796: CALL_OW 488
102800: IFFALSE 102823
// begin result := [ x , y ] ;
102802: LD_ADDR_VAR 0 1
102806: PUSH
102807: LD_VAR 0 3
102811: PUSH
102812: LD_VAR 0 4
102816: PUSH
102817: EMPTY
102818: LIST
102819: LIST
102820: ST_TO_ADDR
// break ;
102821: GO 102825
// end ; end ;
102823: GO 102625
102825: POP
102826: POP
// if result then
102827: LD_VAR 0 1
102831: IFFALSE 102891
// begin ToLua ( playSibBomb() ) ;
102833: LD_STRING playSibBomb()
102835: PPUSH
102836: CALL_OW 559
// wait ( 0 0$14 ) ;
102840: LD_INT 490
102842: PPUSH
102843: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102847: LD_VAR 0 1
102851: PUSH
102852: LD_INT 1
102854: ARRAY
102855: PPUSH
102856: LD_VAR 0 1
102860: PUSH
102861: LD_INT 2
102863: ARRAY
102864: PPUSH
102865: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102869: LD_VAR 0 1
102873: PUSH
102874: LD_INT 1
102876: ARRAY
102877: PPUSH
102878: LD_VAR 0 1
102882: PUSH
102883: LD_INT 2
102885: ARRAY
102886: PPUSH
102887: CALL_OW 429
// end ; end ;
102891: LD_VAR 0 1
102895: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102896: LD_EXP 124
102900: PUSH
102901: LD_EXP 146
102905: AND
102906: IFFALSE 102918
102908: GO 102910
102910: DISABLE
// YouLost (  ) ;
102911: LD_STRING 
102913: PPUSH
102914: CALL_OW 104
102918: END
// every 0 0$1 trigger StreamModeActive and sFog do
102919: LD_EXP 124
102923: PUSH
102924: LD_EXP 145
102928: AND
102929: IFFALSE 102943
102931: GO 102933
102933: DISABLE
// FogOff ( your_side ) ;
102934: LD_OWVAR 2
102938: PPUSH
102939: CALL_OW 344
102943: END
// every 0 0$1 trigger StreamModeActive and sSun do
102944: LD_EXP 124
102948: PUSH
102949: LD_EXP 147
102953: AND
102954: IFFALSE 102982
102956: GO 102958
102958: DISABLE
// begin solar_recharge_percent := 0 ;
102959: LD_ADDR_OWVAR 79
102963: PUSH
102964: LD_INT 0
102966: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102967: LD_INT 10500
102969: PPUSH
102970: CALL_OW 67
// solar_recharge_percent := 100 ;
102974: LD_ADDR_OWVAR 79
102978: PUSH
102979: LD_INT 100
102981: ST_TO_ADDR
// end ;
102982: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102983: LD_EXP 124
102987: PUSH
102988: LD_EXP 148
102992: AND
102993: IFFALSE 103232
102995: GO 102997
102997: DISABLE
102998: LD_INT 0
103000: PPUSH
103001: PPUSH
103002: PPUSH
// begin tmp := [ ] ;
103003: LD_ADDR_VAR 0 3
103007: PUSH
103008: EMPTY
103009: ST_TO_ADDR
// for i := 1 to 6 do
103010: LD_ADDR_VAR 0 1
103014: PUSH
103015: DOUBLE
103016: LD_INT 1
103018: DEC
103019: ST_TO_ADDR
103020: LD_INT 6
103022: PUSH
103023: FOR_TO
103024: IFFALSE 103129
// begin uc_nation := nation_nature ;
103026: LD_ADDR_OWVAR 21
103030: PUSH
103031: LD_INT 0
103033: ST_TO_ADDR
// uc_side := 0 ;
103034: LD_ADDR_OWVAR 20
103038: PUSH
103039: LD_INT 0
103041: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
103042: LD_ADDR_OWVAR 29
103046: PUSH
103047: LD_INT 12
103049: PUSH
103050: LD_INT 12
103052: PUSH
103053: EMPTY
103054: LIST
103055: LIST
103056: ST_TO_ADDR
// hc_agressivity := 20 ;
103057: LD_ADDR_OWVAR 35
103061: PUSH
103062: LD_INT 20
103064: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
103065: LD_ADDR_OWVAR 28
103069: PUSH
103070: LD_INT 17
103072: ST_TO_ADDR
// hc_gallery :=  ;
103073: LD_ADDR_OWVAR 33
103077: PUSH
103078: LD_STRING 
103080: ST_TO_ADDR
// hc_name :=  ;
103081: LD_ADDR_OWVAR 26
103085: PUSH
103086: LD_STRING 
103088: ST_TO_ADDR
// un := CreateHuman ;
103089: LD_ADDR_VAR 0 2
103093: PUSH
103094: CALL_OW 44
103098: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
103099: LD_VAR 0 2
103103: PPUSH
103104: LD_INT 1
103106: PPUSH
103107: CALL_OW 51
// tmp := tmp ^ un ;
103111: LD_ADDR_VAR 0 3
103115: PUSH
103116: LD_VAR 0 3
103120: PUSH
103121: LD_VAR 0 2
103125: ADD
103126: ST_TO_ADDR
// end ;
103127: GO 103023
103129: POP
103130: POP
// repeat wait ( 0 0$1 ) ;
103131: LD_INT 35
103133: PPUSH
103134: CALL_OW 67
// for un in tmp do
103138: LD_ADDR_VAR 0 2
103142: PUSH
103143: LD_VAR 0 3
103147: PUSH
103148: FOR_IN
103149: IFFALSE 103223
// begin if IsDead ( un ) then
103151: LD_VAR 0 2
103155: PPUSH
103156: CALL_OW 301
103160: IFFALSE 103180
// begin tmp := tmp diff un ;
103162: LD_ADDR_VAR 0 3
103166: PUSH
103167: LD_VAR 0 3
103171: PUSH
103172: LD_VAR 0 2
103176: DIFF
103177: ST_TO_ADDR
// continue ;
103178: GO 103148
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103180: LD_VAR 0 2
103184: PPUSH
103185: LD_INT 3
103187: PUSH
103188: LD_INT 22
103190: PUSH
103191: LD_INT 0
103193: PUSH
103194: EMPTY
103195: LIST
103196: LIST
103197: PUSH
103198: EMPTY
103199: LIST
103200: LIST
103201: PPUSH
103202: CALL_OW 69
103206: PPUSH
103207: LD_VAR 0 2
103211: PPUSH
103212: CALL_OW 74
103216: PPUSH
103217: CALL_OW 115
// end ;
103221: GO 103148
103223: POP
103224: POP
// until not tmp ;
103225: LD_VAR 0 3
103229: NOT
103230: IFFALSE 103131
// end ;
103232: PPOPN 3
103234: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103235: LD_EXP 124
103239: PUSH
103240: LD_EXP 149
103244: AND
103245: IFFALSE 103299
103247: GO 103249
103249: DISABLE
// begin ToLua ( displayTroll(); ) ;
103250: LD_STRING displayTroll();
103252: PPUSH
103253: CALL_OW 559
// wait ( 3 3$00 ) ;
103257: LD_INT 6300
103259: PPUSH
103260: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103264: LD_STRING hideTroll();
103266: PPUSH
103267: CALL_OW 559
// wait ( 1 1$00 ) ;
103271: LD_INT 2100
103273: PPUSH
103274: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103278: LD_STRING displayTroll();
103280: PPUSH
103281: CALL_OW 559
// wait ( 1 1$00 ) ;
103285: LD_INT 2100
103287: PPUSH
103288: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103292: LD_STRING hideTroll();
103294: PPUSH
103295: CALL_OW 559
// end ;
103299: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103300: LD_EXP 124
103304: PUSH
103305: LD_EXP 150
103309: AND
103310: IFFALSE 103373
103312: GO 103314
103314: DISABLE
103315: LD_INT 0
103317: PPUSH
// begin p := 0 ;
103318: LD_ADDR_VAR 0 1
103322: PUSH
103323: LD_INT 0
103325: ST_TO_ADDR
// repeat game_speed := 1 ;
103326: LD_ADDR_OWVAR 65
103330: PUSH
103331: LD_INT 1
103333: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103334: LD_INT 35
103336: PPUSH
103337: CALL_OW 67
// p := p + 1 ;
103341: LD_ADDR_VAR 0 1
103345: PUSH
103346: LD_VAR 0 1
103350: PUSH
103351: LD_INT 1
103353: PLUS
103354: ST_TO_ADDR
// until p >= 60 ;
103355: LD_VAR 0 1
103359: PUSH
103360: LD_INT 60
103362: GREATEREQUAL
103363: IFFALSE 103326
// game_speed := 4 ;
103365: LD_ADDR_OWVAR 65
103369: PUSH
103370: LD_INT 4
103372: ST_TO_ADDR
// end ;
103373: PPOPN 1
103375: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103376: LD_EXP 124
103380: PUSH
103381: LD_EXP 151
103385: AND
103386: IFFALSE 103532
103388: GO 103390
103390: DISABLE
103391: LD_INT 0
103393: PPUSH
103394: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103395: LD_ADDR_VAR 0 1
103399: PUSH
103400: LD_INT 22
103402: PUSH
103403: LD_OWVAR 2
103407: PUSH
103408: EMPTY
103409: LIST
103410: LIST
103411: PUSH
103412: LD_INT 2
103414: PUSH
103415: LD_INT 30
103417: PUSH
103418: LD_INT 0
103420: PUSH
103421: EMPTY
103422: LIST
103423: LIST
103424: PUSH
103425: LD_INT 30
103427: PUSH
103428: LD_INT 1
103430: PUSH
103431: EMPTY
103432: LIST
103433: LIST
103434: PUSH
103435: EMPTY
103436: LIST
103437: LIST
103438: LIST
103439: PUSH
103440: EMPTY
103441: LIST
103442: LIST
103443: PPUSH
103444: CALL_OW 69
103448: ST_TO_ADDR
// if not depot then
103449: LD_VAR 0 1
103453: NOT
103454: IFFALSE 103458
// exit ;
103456: GO 103532
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103458: LD_ADDR_VAR 0 2
103462: PUSH
103463: LD_VAR 0 1
103467: PUSH
103468: LD_INT 1
103470: PPUSH
103471: LD_VAR 0 1
103475: PPUSH
103476: CALL_OW 12
103480: ARRAY
103481: PPUSH
103482: CALL_OW 274
103486: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103487: LD_VAR 0 2
103491: PPUSH
103492: LD_INT 1
103494: PPUSH
103495: LD_INT 0
103497: PPUSH
103498: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103502: LD_VAR 0 2
103506: PPUSH
103507: LD_INT 2
103509: PPUSH
103510: LD_INT 0
103512: PPUSH
103513: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103517: LD_VAR 0 2
103521: PPUSH
103522: LD_INT 3
103524: PPUSH
103525: LD_INT 0
103527: PPUSH
103528: CALL_OW 277
// end ;
103532: PPOPN 2
103534: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103535: LD_EXP 124
103539: PUSH
103540: LD_EXP 152
103544: AND
103545: IFFALSE 103642
103547: GO 103549
103549: DISABLE
103550: LD_INT 0
103552: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103553: LD_ADDR_VAR 0 1
103557: PUSH
103558: LD_INT 22
103560: PUSH
103561: LD_OWVAR 2
103565: PUSH
103566: EMPTY
103567: LIST
103568: LIST
103569: PUSH
103570: LD_INT 21
103572: PUSH
103573: LD_INT 1
103575: PUSH
103576: EMPTY
103577: LIST
103578: LIST
103579: PUSH
103580: LD_INT 3
103582: PUSH
103583: LD_INT 23
103585: PUSH
103586: LD_INT 0
103588: PUSH
103589: EMPTY
103590: LIST
103591: LIST
103592: PUSH
103593: EMPTY
103594: LIST
103595: LIST
103596: PUSH
103597: EMPTY
103598: LIST
103599: LIST
103600: LIST
103601: PPUSH
103602: CALL_OW 69
103606: ST_TO_ADDR
// if not tmp then
103607: LD_VAR 0 1
103611: NOT
103612: IFFALSE 103616
// exit ;
103614: GO 103642
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103616: LD_VAR 0 1
103620: PUSH
103621: LD_INT 1
103623: PPUSH
103624: LD_VAR 0 1
103628: PPUSH
103629: CALL_OW 12
103633: ARRAY
103634: PPUSH
103635: LD_INT 200
103637: PPUSH
103638: CALL_OW 234
// end ;
103642: PPOPN 1
103644: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103645: LD_EXP 124
103649: PUSH
103650: LD_EXP 153
103654: AND
103655: IFFALSE 103734
103657: GO 103659
103659: DISABLE
103660: LD_INT 0
103662: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103663: LD_ADDR_VAR 0 1
103667: PUSH
103668: LD_INT 22
103670: PUSH
103671: LD_OWVAR 2
103675: PUSH
103676: EMPTY
103677: LIST
103678: LIST
103679: PUSH
103680: LD_INT 21
103682: PUSH
103683: LD_INT 2
103685: PUSH
103686: EMPTY
103687: LIST
103688: LIST
103689: PUSH
103690: EMPTY
103691: LIST
103692: LIST
103693: PPUSH
103694: CALL_OW 69
103698: ST_TO_ADDR
// if not tmp then
103699: LD_VAR 0 1
103703: NOT
103704: IFFALSE 103708
// exit ;
103706: GO 103734
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103708: LD_VAR 0 1
103712: PUSH
103713: LD_INT 1
103715: PPUSH
103716: LD_VAR 0 1
103720: PPUSH
103721: CALL_OW 12
103725: ARRAY
103726: PPUSH
103727: LD_INT 60
103729: PPUSH
103730: CALL_OW 234
// end ;
103734: PPOPN 1
103736: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103737: LD_EXP 124
103741: PUSH
103742: LD_EXP 154
103746: AND
103747: IFFALSE 103846
103749: GO 103751
103751: DISABLE
103752: LD_INT 0
103754: PPUSH
103755: PPUSH
// begin enable ;
103756: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103757: LD_ADDR_VAR 0 1
103761: PUSH
103762: LD_INT 22
103764: PUSH
103765: LD_OWVAR 2
103769: PUSH
103770: EMPTY
103771: LIST
103772: LIST
103773: PUSH
103774: LD_INT 61
103776: PUSH
103777: EMPTY
103778: LIST
103779: PUSH
103780: LD_INT 33
103782: PUSH
103783: LD_INT 2
103785: PUSH
103786: EMPTY
103787: LIST
103788: LIST
103789: PUSH
103790: EMPTY
103791: LIST
103792: LIST
103793: LIST
103794: PPUSH
103795: CALL_OW 69
103799: ST_TO_ADDR
// if not tmp then
103800: LD_VAR 0 1
103804: NOT
103805: IFFALSE 103809
// exit ;
103807: GO 103846
// for i in tmp do
103809: LD_ADDR_VAR 0 2
103813: PUSH
103814: LD_VAR 0 1
103818: PUSH
103819: FOR_IN
103820: IFFALSE 103844
// if IsControledBy ( i ) then
103822: LD_VAR 0 2
103826: PPUSH
103827: CALL_OW 312
103831: IFFALSE 103842
// ComUnlink ( i ) ;
103833: LD_VAR 0 2
103837: PPUSH
103838: CALL_OW 136
103842: GO 103819
103844: POP
103845: POP
// end ;
103846: PPOPN 2
103848: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103849: LD_EXP 124
103853: PUSH
103854: LD_EXP 155
103858: AND
103859: IFFALSE 103999
103861: GO 103863
103863: DISABLE
103864: LD_INT 0
103866: PPUSH
103867: PPUSH
// begin ToLua ( displayPowell(); ) ;
103868: LD_STRING displayPowell();
103870: PPUSH
103871: CALL_OW 559
// uc_side := 0 ;
103875: LD_ADDR_OWVAR 20
103879: PUSH
103880: LD_INT 0
103882: ST_TO_ADDR
// uc_nation := 2 ;
103883: LD_ADDR_OWVAR 21
103887: PUSH
103888: LD_INT 2
103890: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103891: LD_ADDR_OWVAR 37
103895: PUSH
103896: LD_INT 14
103898: ST_TO_ADDR
// vc_engine := engine_siberite ;
103899: LD_ADDR_OWVAR 39
103903: PUSH
103904: LD_INT 3
103906: ST_TO_ADDR
// vc_control := control_apeman ;
103907: LD_ADDR_OWVAR 38
103911: PUSH
103912: LD_INT 5
103914: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103915: LD_ADDR_OWVAR 40
103919: PUSH
103920: LD_INT 29
103922: ST_TO_ADDR
// un := CreateVehicle ;
103923: LD_ADDR_VAR 0 2
103927: PUSH
103928: CALL_OW 45
103932: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103933: LD_VAR 0 2
103937: PPUSH
103938: LD_INT 1
103940: PPUSH
103941: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103945: LD_INT 35
103947: PPUSH
103948: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103952: LD_VAR 0 2
103956: PPUSH
103957: LD_INT 22
103959: PUSH
103960: LD_OWVAR 2
103964: PUSH
103965: EMPTY
103966: LIST
103967: LIST
103968: PPUSH
103969: CALL_OW 69
103973: PPUSH
103974: LD_VAR 0 2
103978: PPUSH
103979: CALL_OW 74
103983: PPUSH
103984: CALL_OW 115
// until IsDead ( un ) ;
103988: LD_VAR 0 2
103992: PPUSH
103993: CALL_OW 301
103997: IFFALSE 103945
// end ;
103999: PPOPN 2
104001: END
// every 0 0$1 trigger StreamModeActive and sStu do
104002: LD_EXP 124
104006: PUSH
104007: LD_EXP 163
104011: AND
104012: IFFALSE 104028
104014: GO 104016
104016: DISABLE
// begin ToLua ( displayStucuk(); ) ;
104017: LD_STRING displayStucuk();
104019: PPUSH
104020: CALL_OW 559
// ResetFog ;
104024: CALL_OW 335
// end ;
104028: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
104029: LD_EXP 124
104033: PUSH
104034: LD_EXP 156
104038: AND
104039: IFFALSE 104180
104041: GO 104043
104043: DISABLE
104044: LD_INT 0
104046: PPUSH
104047: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104048: LD_ADDR_VAR 0 2
104052: PUSH
104053: LD_INT 22
104055: PUSH
104056: LD_OWVAR 2
104060: PUSH
104061: EMPTY
104062: LIST
104063: LIST
104064: PUSH
104065: LD_INT 21
104067: PUSH
104068: LD_INT 1
104070: PUSH
104071: EMPTY
104072: LIST
104073: LIST
104074: PUSH
104075: EMPTY
104076: LIST
104077: LIST
104078: PPUSH
104079: CALL_OW 69
104083: ST_TO_ADDR
// if not tmp then
104084: LD_VAR 0 2
104088: NOT
104089: IFFALSE 104093
// exit ;
104091: GO 104180
// un := tmp [ rand ( 1 , tmp ) ] ;
104093: LD_ADDR_VAR 0 1
104097: PUSH
104098: LD_VAR 0 2
104102: PUSH
104103: LD_INT 1
104105: PPUSH
104106: LD_VAR 0 2
104110: PPUSH
104111: CALL_OW 12
104115: ARRAY
104116: ST_TO_ADDR
// SetSide ( un , 0 ) ;
104117: LD_VAR 0 1
104121: PPUSH
104122: LD_INT 0
104124: PPUSH
104125: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
104129: LD_VAR 0 1
104133: PPUSH
104134: LD_OWVAR 3
104138: PUSH
104139: LD_VAR 0 1
104143: DIFF
104144: PPUSH
104145: LD_VAR 0 1
104149: PPUSH
104150: CALL_OW 74
104154: PPUSH
104155: CALL_OW 115
// wait ( 0 0$20 ) ;
104159: LD_INT 700
104161: PPUSH
104162: CALL_OW 67
// SetSide ( un , your_side ) ;
104166: LD_VAR 0 1
104170: PPUSH
104171: LD_OWVAR 2
104175: PPUSH
104176: CALL_OW 235
// end ;
104180: PPOPN 2
104182: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104183: LD_EXP 124
104187: PUSH
104188: LD_EXP 157
104192: AND
104193: IFFALSE 104299
104195: GO 104197
104197: DISABLE
104198: LD_INT 0
104200: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104201: LD_ADDR_VAR 0 1
104205: PUSH
104206: LD_INT 22
104208: PUSH
104209: LD_OWVAR 2
104213: PUSH
104214: EMPTY
104215: LIST
104216: LIST
104217: PUSH
104218: LD_INT 2
104220: PUSH
104221: LD_INT 30
104223: PUSH
104224: LD_INT 0
104226: PUSH
104227: EMPTY
104228: LIST
104229: LIST
104230: PUSH
104231: LD_INT 30
104233: PUSH
104234: LD_INT 1
104236: PUSH
104237: EMPTY
104238: LIST
104239: LIST
104240: PUSH
104241: EMPTY
104242: LIST
104243: LIST
104244: LIST
104245: PUSH
104246: EMPTY
104247: LIST
104248: LIST
104249: PPUSH
104250: CALL_OW 69
104254: ST_TO_ADDR
// if not depot then
104255: LD_VAR 0 1
104259: NOT
104260: IFFALSE 104264
// exit ;
104262: GO 104299
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104264: LD_VAR 0 1
104268: PUSH
104269: LD_INT 1
104271: ARRAY
104272: PPUSH
104273: CALL_OW 250
104277: PPUSH
104278: LD_VAR 0 1
104282: PUSH
104283: LD_INT 1
104285: ARRAY
104286: PPUSH
104287: CALL_OW 251
104291: PPUSH
104292: LD_INT 70
104294: PPUSH
104295: CALL_OW 495
// end ;
104299: PPOPN 1
104301: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104302: LD_EXP 124
104306: PUSH
104307: LD_EXP 158
104311: AND
104312: IFFALSE 104523
104314: GO 104316
104316: DISABLE
104317: LD_INT 0
104319: PPUSH
104320: PPUSH
104321: PPUSH
104322: PPUSH
104323: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104324: LD_ADDR_VAR 0 5
104328: PUSH
104329: LD_INT 22
104331: PUSH
104332: LD_OWVAR 2
104336: PUSH
104337: EMPTY
104338: LIST
104339: LIST
104340: PUSH
104341: LD_INT 21
104343: PUSH
104344: LD_INT 1
104346: PUSH
104347: EMPTY
104348: LIST
104349: LIST
104350: PUSH
104351: EMPTY
104352: LIST
104353: LIST
104354: PPUSH
104355: CALL_OW 69
104359: ST_TO_ADDR
// if not tmp then
104360: LD_VAR 0 5
104364: NOT
104365: IFFALSE 104369
// exit ;
104367: GO 104523
// for i in tmp do
104369: LD_ADDR_VAR 0 1
104373: PUSH
104374: LD_VAR 0 5
104378: PUSH
104379: FOR_IN
104380: IFFALSE 104521
// begin d := rand ( 0 , 5 ) ;
104382: LD_ADDR_VAR 0 4
104386: PUSH
104387: LD_INT 0
104389: PPUSH
104390: LD_INT 5
104392: PPUSH
104393: CALL_OW 12
104397: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104398: LD_ADDR_VAR 0 2
104402: PUSH
104403: LD_VAR 0 1
104407: PPUSH
104408: CALL_OW 250
104412: PPUSH
104413: LD_VAR 0 4
104417: PPUSH
104418: LD_INT 3
104420: PPUSH
104421: LD_INT 12
104423: PPUSH
104424: CALL_OW 12
104428: PPUSH
104429: CALL_OW 272
104433: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104434: LD_ADDR_VAR 0 3
104438: PUSH
104439: LD_VAR 0 1
104443: PPUSH
104444: CALL_OW 251
104448: PPUSH
104449: LD_VAR 0 4
104453: PPUSH
104454: LD_INT 3
104456: PPUSH
104457: LD_INT 12
104459: PPUSH
104460: CALL_OW 12
104464: PPUSH
104465: CALL_OW 273
104469: ST_TO_ADDR
// if ValidHex ( x , y ) then
104470: LD_VAR 0 2
104474: PPUSH
104475: LD_VAR 0 3
104479: PPUSH
104480: CALL_OW 488
104484: IFFALSE 104519
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104486: LD_VAR 0 1
104490: PPUSH
104491: LD_VAR 0 2
104495: PPUSH
104496: LD_VAR 0 3
104500: PPUSH
104501: LD_INT 3
104503: PPUSH
104504: LD_INT 6
104506: PPUSH
104507: CALL_OW 12
104511: PPUSH
104512: LD_INT 1
104514: PPUSH
104515: CALL_OW 483
// end ;
104519: GO 104379
104521: POP
104522: POP
// end ;
104523: PPOPN 5
104525: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104526: LD_EXP 124
104530: PUSH
104531: LD_EXP 159
104535: AND
104536: IFFALSE 104630
104538: GO 104540
104540: DISABLE
104541: LD_INT 0
104543: PPUSH
104544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104545: LD_ADDR_VAR 0 2
104549: PUSH
104550: LD_INT 22
104552: PUSH
104553: LD_OWVAR 2
104557: PUSH
104558: EMPTY
104559: LIST
104560: LIST
104561: PUSH
104562: LD_INT 32
104564: PUSH
104565: LD_INT 1
104567: PUSH
104568: EMPTY
104569: LIST
104570: LIST
104571: PUSH
104572: LD_INT 21
104574: PUSH
104575: LD_INT 2
104577: PUSH
104578: EMPTY
104579: LIST
104580: LIST
104581: PUSH
104582: EMPTY
104583: LIST
104584: LIST
104585: LIST
104586: PPUSH
104587: CALL_OW 69
104591: ST_TO_ADDR
// if not tmp then
104592: LD_VAR 0 2
104596: NOT
104597: IFFALSE 104601
// exit ;
104599: GO 104630
// for i in tmp do
104601: LD_ADDR_VAR 0 1
104605: PUSH
104606: LD_VAR 0 2
104610: PUSH
104611: FOR_IN
104612: IFFALSE 104628
// SetFuel ( i , 0 ) ;
104614: LD_VAR 0 1
104618: PPUSH
104619: LD_INT 0
104621: PPUSH
104622: CALL_OW 240
104626: GO 104611
104628: POP
104629: POP
// end ;
104630: PPOPN 2
104632: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104633: LD_EXP 124
104637: PUSH
104638: LD_EXP 160
104642: AND
104643: IFFALSE 104709
104645: GO 104647
104647: DISABLE
104648: LD_INT 0
104650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104651: LD_ADDR_VAR 0 1
104655: PUSH
104656: LD_INT 22
104658: PUSH
104659: LD_OWVAR 2
104663: PUSH
104664: EMPTY
104665: LIST
104666: LIST
104667: PUSH
104668: LD_INT 30
104670: PUSH
104671: LD_INT 29
104673: PUSH
104674: EMPTY
104675: LIST
104676: LIST
104677: PUSH
104678: EMPTY
104679: LIST
104680: LIST
104681: PPUSH
104682: CALL_OW 69
104686: ST_TO_ADDR
// if not tmp then
104687: LD_VAR 0 1
104691: NOT
104692: IFFALSE 104696
// exit ;
104694: GO 104709
// DestroyUnit ( tmp [ 1 ] ) ;
104696: LD_VAR 0 1
104700: PUSH
104701: LD_INT 1
104703: ARRAY
104704: PPUSH
104705: CALL_OW 65
// end ;
104709: PPOPN 1
104711: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104712: LD_EXP 124
104716: PUSH
104717: LD_EXP 162
104721: AND
104722: IFFALSE 104851
104724: GO 104726
104726: DISABLE
104727: LD_INT 0
104729: PPUSH
// begin uc_side := 0 ;
104730: LD_ADDR_OWVAR 20
104734: PUSH
104735: LD_INT 0
104737: ST_TO_ADDR
// uc_nation := nation_arabian ;
104738: LD_ADDR_OWVAR 21
104742: PUSH
104743: LD_INT 2
104745: ST_TO_ADDR
// hc_gallery :=  ;
104746: LD_ADDR_OWVAR 33
104750: PUSH
104751: LD_STRING 
104753: ST_TO_ADDR
// hc_name :=  ;
104754: LD_ADDR_OWVAR 26
104758: PUSH
104759: LD_STRING 
104761: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104762: LD_INT 1
104764: PPUSH
104765: LD_INT 11
104767: PPUSH
104768: LD_INT 10
104770: PPUSH
104771: CALL_OW 380
// un := CreateHuman ;
104775: LD_ADDR_VAR 0 1
104779: PUSH
104780: CALL_OW 44
104784: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104785: LD_VAR 0 1
104789: PPUSH
104790: LD_INT 1
104792: PPUSH
104793: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104797: LD_INT 35
104799: PPUSH
104800: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104804: LD_VAR 0 1
104808: PPUSH
104809: LD_INT 22
104811: PUSH
104812: LD_OWVAR 2
104816: PUSH
104817: EMPTY
104818: LIST
104819: LIST
104820: PPUSH
104821: CALL_OW 69
104825: PPUSH
104826: LD_VAR 0 1
104830: PPUSH
104831: CALL_OW 74
104835: PPUSH
104836: CALL_OW 115
// until IsDead ( un ) ;
104840: LD_VAR 0 1
104844: PPUSH
104845: CALL_OW 301
104849: IFFALSE 104797
// end ;
104851: PPOPN 1
104853: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104854: LD_EXP 124
104858: PUSH
104859: LD_EXP 164
104863: AND
104864: IFFALSE 104876
104866: GO 104868
104868: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104869: LD_STRING earthquake(getX(game), 0, 32)
104871: PPUSH
104872: CALL_OW 559
104876: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104877: LD_EXP 124
104881: PUSH
104882: LD_EXP 165
104886: AND
104887: IFFALSE 104978
104889: GO 104891
104891: DISABLE
104892: LD_INT 0
104894: PPUSH
// begin enable ;
104895: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104896: LD_ADDR_VAR 0 1
104900: PUSH
104901: LD_INT 22
104903: PUSH
104904: LD_OWVAR 2
104908: PUSH
104909: EMPTY
104910: LIST
104911: LIST
104912: PUSH
104913: LD_INT 21
104915: PUSH
104916: LD_INT 2
104918: PUSH
104919: EMPTY
104920: LIST
104921: LIST
104922: PUSH
104923: LD_INT 33
104925: PUSH
104926: LD_INT 3
104928: PUSH
104929: EMPTY
104930: LIST
104931: LIST
104932: PUSH
104933: EMPTY
104934: LIST
104935: LIST
104936: LIST
104937: PPUSH
104938: CALL_OW 69
104942: ST_TO_ADDR
// if not tmp then
104943: LD_VAR 0 1
104947: NOT
104948: IFFALSE 104952
// exit ;
104950: GO 104978
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104952: LD_VAR 0 1
104956: PUSH
104957: LD_INT 1
104959: PPUSH
104960: LD_VAR 0 1
104964: PPUSH
104965: CALL_OW 12
104969: ARRAY
104970: PPUSH
104971: LD_INT 1
104973: PPUSH
104974: CALL_OW 234
// end ;
104978: PPOPN 1
104980: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104981: LD_EXP 124
104985: PUSH
104986: LD_EXP 166
104990: AND
104991: IFFALSE 105132
104993: GO 104995
104995: DISABLE
104996: LD_INT 0
104998: PPUSH
104999: PPUSH
105000: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105001: LD_ADDR_VAR 0 3
105005: PUSH
105006: LD_INT 22
105008: PUSH
105009: LD_OWVAR 2
105013: PUSH
105014: EMPTY
105015: LIST
105016: LIST
105017: PUSH
105018: LD_INT 25
105020: PUSH
105021: LD_INT 1
105023: PUSH
105024: EMPTY
105025: LIST
105026: LIST
105027: PUSH
105028: EMPTY
105029: LIST
105030: LIST
105031: PPUSH
105032: CALL_OW 69
105036: ST_TO_ADDR
// if not tmp then
105037: LD_VAR 0 3
105041: NOT
105042: IFFALSE 105046
// exit ;
105044: GO 105132
// un := tmp [ rand ( 1 , tmp ) ] ;
105046: LD_ADDR_VAR 0 2
105050: PUSH
105051: LD_VAR 0 3
105055: PUSH
105056: LD_INT 1
105058: PPUSH
105059: LD_VAR 0 3
105063: PPUSH
105064: CALL_OW 12
105068: ARRAY
105069: ST_TO_ADDR
// if Crawls ( un ) then
105070: LD_VAR 0 2
105074: PPUSH
105075: CALL_OW 318
105079: IFFALSE 105090
// ComWalk ( un ) ;
105081: LD_VAR 0 2
105085: PPUSH
105086: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
105090: LD_VAR 0 2
105094: PPUSH
105095: LD_INT 9
105097: PPUSH
105098: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
105102: LD_INT 28
105104: PPUSH
105105: LD_OWVAR 2
105109: PPUSH
105110: LD_INT 2
105112: PPUSH
105113: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
105117: LD_INT 29
105119: PPUSH
105120: LD_OWVAR 2
105124: PPUSH
105125: LD_INT 2
105127: PPUSH
105128: CALL_OW 322
// end ;
105132: PPOPN 3
105134: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
105135: LD_EXP 124
105139: PUSH
105140: LD_EXP 167
105144: AND
105145: IFFALSE 105256
105147: GO 105149
105149: DISABLE
105150: LD_INT 0
105152: PPUSH
105153: PPUSH
105154: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105155: LD_ADDR_VAR 0 3
105159: PUSH
105160: LD_INT 22
105162: PUSH
105163: LD_OWVAR 2
105167: PUSH
105168: EMPTY
105169: LIST
105170: LIST
105171: PUSH
105172: LD_INT 25
105174: PUSH
105175: LD_INT 1
105177: PUSH
105178: EMPTY
105179: LIST
105180: LIST
105181: PUSH
105182: EMPTY
105183: LIST
105184: LIST
105185: PPUSH
105186: CALL_OW 69
105190: ST_TO_ADDR
// if not tmp then
105191: LD_VAR 0 3
105195: NOT
105196: IFFALSE 105200
// exit ;
105198: GO 105256
// un := tmp [ rand ( 1 , tmp ) ] ;
105200: LD_ADDR_VAR 0 2
105204: PUSH
105205: LD_VAR 0 3
105209: PUSH
105210: LD_INT 1
105212: PPUSH
105213: LD_VAR 0 3
105217: PPUSH
105218: CALL_OW 12
105222: ARRAY
105223: ST_TO_ADDR
// if Crawls ( un ) then
105224: LD_VAR 0 2
105228: PPUSH
105229: CALL_OW 318
105233: IFFALSE 105244
// ComWalk ( un ) ;
105235: LD_VAR 0 2
105239: PPUSH
105240: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105244: LD_VAR 0 2
105248: PPUSH
105249: LD_INT 8
105251: PPUSH
105252: CALL_OW 336
// end ;
105256: PPOPN 3
105258: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105259: LD_EXP 124
105263: PUSH
105264: LD_EXP 168
105268: AND
105269: IFFALSE 105413
105271: GO 105273
105273: DISABLE
105274: LD_INT 0
105276: PPUSH
105277: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105278: LD_ADDR_VAR 0 2
105282: PUSH
105283: LD_INT 22
105285: PUSH
105286: LD_OWVAR 2
105290: PUSH
105291: EMPTY
105292: LIST
105293: LIST
105294: PUSH
105295: LD_INT 21
105297: PUSH
105298: LD_INT 2
105300: PUSH
105301: EMPTY
105302: LIST
105303: LIST
105304: PUSH
105305: LD_INT 2
105307: PUSH
105308: LD_INT 34
105310: PUSH
105311: LD_INT 12
105313: PUSH
105314: EMPTY
105315: LIST
105316: LIST
105317: PUSH
105318: LD_INT 34
105320: PUSH
105321: LD_INT 51
105323: PUSH
105324: EMPTY
105325: LIST
105326: LIST
105327: PUSH
105328: LD_INT 34
105330: PUSH
105331: LD_INT 32
105333: PUSH
105334: EMPTY
105335: LIST
105336: LIST
105337: PUSH
105338: EMPTY
105339: LIST
105340: LIST
105341: LIST
105342: LIST
105343: PUSH
105344: EMPTY
105345: LIST
105346: LIST
105347: LIST
105348: PPUSH
105349: CALL_OW 69
105353: ST_TO_ADDR
// if not tmp then
105354: LD_VAR 0 2
105358: NOT
105359: IFFALSE 105363
// exit ;
105361: GO 105413
// for i in tmp do
105363: LD_ADDR_VAR 0 1
105367: PUSH
105368: LD_VAR 0 2
105372: PUSH
105373: FOR_IN
105374: IFFALSE 105411
// if GetCargo ( i , mat_artifact ) = 0 then
105376: LD_VAR 0 1
105380: PPUSH
105381: LD_INT 4
105383: PPUSH
105384: CALL_OW 289
105388: PUSH
105389: LD_INT 0
105391: EQUAL
105392: IFFALSE 105409
// SetCargo ( i , mat_siberit , 100 ) ;
105394: LD_VAR 0 1
105398: PPUSH
105399: LD_INT 3
105401: PPUSH
105402: LD_INT 100
105404: PPUSH
105405: CALL_OW 290
105409: GO 105373
105411: POP
105412: POP
// end ;
105413: PPOPN 2
105415: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105416: LD_EXP 124
105420: PUSH
105421: LD_EXP 169
105425: AND
105426: IFFALSE 105609
105428: GO 105430
105430: DISABLE
105431: LD_INT 0
105433: PPUSH
105434: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105435: LD_ADDR_VAR 0 2
105439: PUSH
105440: LD_INT 22
105442: PUSH
105443: LD_OWVAR 2
105447: PUSH
105448: EMPTY
105449: LIST
105450: LIST
105451: PPUSH
105452: CALL_OW 69
105456: ST_TO_ADDR
// if not tmp then
105457: LD_VAR 0 2
105461: NOT
105462: IFFALSE 105466
// exit ;
105464: GO 105609
// for i := 1 to 2 do
105466: LD_ADDR_VAR 0 1
105470: PUSH
105471: DOUBLE
105472: LD_INT 1
105474: DEC
105475: ST_TO_ADDR
105476: LD_INT 2
105478: PUSH
105479: FOR_TO
105480: IFFALSE 105607
// begin uc_side := your_side ;
105482: LD_ADDR_OWVAR 20
105486: PUSH
105487: LD_OWVAR 2
105491: ST_TO_ADDR
// uc_nation := nation_american ;
105492: LD_ADDR_OWVAR 21
105496: PUSH
105497: LD_INT 1
105499: ST_TO_ADDR
// vc_chassis := us_morphling ;
105500: LD_ADDR_OWVAR 37
105504: PUSH
105505: LD_INT 5
105507: ST_TO_ADDR
// vc_engine := engine_siberite ;
105508: LD_ADDR_OWVAR 39
105512: PUSH
105513: LD_INT 3
105515: ST_TO_ADDR
// vc_control := control_computer ;
105516: LD_ADDR_OWVAR 38
105520: PUSH
105521: LD_INT 3
105523: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105524: LD_ADDR_OWVAR 40
105528: PUSH
105529: LD_INT 10
105531: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105532: LD_VAR 0 2
105536: PUSH
105537: LD_INT 1
105539: ARRAY
105540: PPUSH
105541: CALL_OW 310
105545: NOT
105546: IFFALSE 105593
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105548: CALL_OW 45
105552: PPUSH
105553: LD_VAR 0 2
105557: PUSH
105558: LD_INT 1
105560: ARRAY
105561: PPUSH
105562: CALL_OW 250
105566: PPUSH
105567: LD_VAR 0 2
105571: PUSH
105572: LD_INT 1
105574: ARRAY
105575: PPUSH
105576: CALL_OW 251
105580: PPUSH
105581: LD_INT 12
105583: PPUSH
105584: LD_INT 1
105586: PPUSH
105587: CALL_OW 50
105591: GO 105605
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105593: CALL_OW 45
105597: PPUSH
105598: LD_INT 1
105600: PPUSH
105601: CALL_OW 51
// end ;
105605: GO 105479
105607: POP
105608: POP
// end ;
105609: PPOPN 2
105611: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105612: LD_EXP 124
105616: PUSH
105617: LD_EXP 170
105621: AND
105622: IFFALSE 105844
105624: GO 105626
105626: DISABLE
105627: LD_INT 0
105629: PPUSH
105630: PPUSH
105631: PPUSH
105632: PPUSH
105633: PPUSH
105634: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105635: LD_ADDR_VAR 0 6
105639: PUSH
105640: LD_INT 22
105642: PUSH
105643: LD_OWVAR 2
105647: PUSH
105648: EMPTY
105649: LIST
105650: LIST
105651: PUSH
105652: LD_INT 21
105654: PUSH
105655: LD_INT 1
105657: PUSH
105658: EMPTY
105659: LIST
105660: LIST
105661: PUSH
105662: LD_INT 3
105664: PUSH
105665: LD_INT 23
105667: PUSH
105668: LD_INT 0
105670: PUSH
105671: EMPTY
105672: LIST
105673: LIST
105674: PUSH
105675: EMPTY
105676: LIST
105677: LIST
105678: PUSH
105679: EMPTY
105680: LIST
105681: LIST
105682: LIST
105683: PPUSH
105684: CALL_OW 69
105688: ST_TO_ADDR
// if not tmp then
105689: LD_VAR 0 6
105693: NOT
105694: IFFALSE 105698
// exit ;
105696: GO 105844
// s1 := rand ( 1 , 4 ) ;
105698: LD_ADDR_VAR 0 2
105702: PUSH
105703: LD_INT 1
105705: PPUSH
105706: LD_INT 4
105708: PPUSH
105709: CALL_OW 12
105713: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105714: LD_ADDR_VAR 0 4
105718: PUSH
105719: LD_VAR 0 6
105723: PUSH
105724: LD_INT 1
105726: ARRAY
105727: PPUSH
105728: LD_VAR 0 2
105732: PPUSH
105733: CALL_OW 259
105737: ST_TO_ADDR
// if s1 = 1 then
105738: LD_VAR 0 2
105742: PUSH
105743: LD_INT 1
105745: EQUAL
105746: IFFALSE 105766
// s2 := rand ( 2 , 4 ) else
105748: LD_ADDR_VAR 0 3
105752: PUSH
105753: LD_INT 2
105755: PPUSH
105756: LD_INT 4
105758: PPUSH
105759: CALL_OW 12
105763: ST_TO_ADDR
105764: GO 105774
// s2 := 1 ;
105766: LD_ADDR_VAR 0 3
105770: PUSH
105771: LD_INT 1
105773: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105774: LD_ADDR_VAR 0 5
105778: PUSH
105779: LD_VAR 0 6
105783: PUSH
105784: LD_INT 1
105786: ARRAY
105787: PPUSH
105788: LD_VAR 0 3
105792: PPUSH
105793: CALL_OW 259
105797: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105798: LD_VAR 0 6
105802: PUSH
105803: LD_INT 1
105805: ARRAY
105806: PPUSH
105807: LD_VAR 0 2
105811: PPUSH
105812: LD_VAR 0 5
105816: PPUSH
105817: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105821: LD_VAR 0 6
105825: PUSH
105826: LD_INT 1
105828: ARRAY
105829: PPUSH
105830: LD_VAR 0 3
105834: PPUSH
105835: LD_VAR 0 4
105839: PPUSH
105840: CALL_OW 237
// end ;
105844: PPOPN 6
105846: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105847: LD_EXP 124
105851: PUSH
105852: LD_EXP 171
105856: AND
105857: IFFALSE 105936
105859: GO 105861
105861: DISABLE
105862: LD_INT 0
105864: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105865: LD_ADDR_VAR 0 1
105869: PUSH
105870: LD_INT 22
105872: PUSH
105873: LD_OWVAR 2
105877: PUSH
105878: EMPTY
105879: LIST
105880: LIST
105881: PUSH
105882: LD_INT 30
105884: PUSH
105885: LD_INT 3
105887: PUSH
105888: EMPTY
105889: LIST
105890: LIST
105891: PUSH
105892: EMPTY
105893: LIST
105894: LIST
105895: PPUSH
105896: CALL_OW 69
105900: ST_TO_ADDR
// if not tmp then
105901: LD_VAR 0 1
105905: NOT
105906: IFFALSE 105910
// exit ;
105908: GO 105936
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105910: LD_VAR 0 1
105914: PUSH
105915: LD_INT 1
105917: PPUSH
105918: LD_VAR 0 1
105922: PPUSH
105923: CALL_OW 12
105927: ARRAY
105928: PPUSH
105929: LD_INT 1
105931: PPUSH
105932: CALL_OW 234
// end ;
105936: PPOPN 1
105938: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105939: LD_EXP 124
105943: PUSH
105944: LD_EXP 172
105948: AND
105949: IFFALSE 106061
105951: GO 105953
105953: DISABLE
105954: LD_INT 0
105956: PPUSH
105957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105958: LD_ADDR_VAR 0 2
105962: PUSH
105963: LD_INT 22
105965: PUSH
105966: LD_OWVAR 2
105970: PUSH
105971: EMPTY
105972: LIST
105973: LIST
105974: PUSH
105975: LD_INT 2
105977: PUSH
105978: LD_INT 30
105980: PUSH
105981: LD_INT 27
105983: PUSH
105984: EMPTY
105985: LIST
105986: LIST
105987: PUSH
105988: LD_INT 30
105990: PUSH
105991: LD_INT 26
105993: PUSH
105994: EMPTY
105995: LIST
105996: LIST
105997: PUSH
105998: LD_INT 30
106000: PUSH
106001: LD_INT 28
106003: PUSH
106004: EMPTY
106005: LIST
106006: LIST
106007: PUSH
106008: EMPTY
106009: LIST
106010: LIST
106011: LIST
106012: LIST
106013: PUSH
106014: EMPTY
106015: LIST
106016: LIST
106017: PPUSH
106018: CALL_OW 69
106022: ST_TO_ADDR
// if not tmp then
106023: LD_VAR 0 2
106027: NOT
106028: IFFALSE 106032
// exit ;
106030: GO 106061
// for i in tmp do
106032: LD_ADDR_VAR 0 1
106036: PUSH
106037: LD_VAR 0 2
106041: PUSH
106042: FOR_IN
106043: IFFALSE 106059
// SetLives ( i , 1 ) ;
106045: LD_VAR 0 1
106049: PPUSH
106050: LD_INT 1
106052: PPUSH
106053: CALL_OW 234
106057: GO 106042
106059: POP
106060: POP
// end ;
106061: PPOPN 2
106063: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
106064: LD_EXP 124
106068: PUSH
106069: LD_EXP 173
106073: AND
106074: IFFALSE 106361
106076: GO 106078
106078: DISABLE
106079: LD_INT 0
106081: PPUSH
106082: PPUSH
106083: PPUSH
// begin i := rand ( 1 , 7 ) ;
106084: LD_ADDR_VAR 0 1
106088: PUSH
106089: LD_INT 1
106091: PPUSH
106092: LD_INT 7
106094: PPUSH
106095: CALL_OW 12
106099: ST_TO_ADDR
// case i of 1 :
106100: LD_VAR 0 1
106104: PUSH
106105: LD_INT 1
106107: DOUBLE
106108: EQUAL
106109: IFTRUE 106113
106111: GO 106123
106113: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
106114: LD_STRING earthquake(getX(game), 0, 32)
106116: PPUSH
106117: CALL_OW 559
106121: GO 106361
106123: LD_INT 2
106125: DOUBLE
106126: EQUAL
106127: IFTRUE 106131
106129: GO 106145
106131: POP
// begin ToLua ( displayStucuk(); ) ;
106132: LD_STRING displayStucuk();
106134: PPUSH
106135: CALL_OW 559
// ResetFog ;
106139: CALL_OW 335
// end ; 3 :
106143: GO 106361
106145: LD_INT 3
106147: DOUBLE
106148: EQUAL
106149: IFTRUE 106153
106151: GO 106257
106153: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106154: LD_ADDR_VAR 0 2
106158: PUSH
106159: LD_INT 22
106161: PUSH
106162: LD_OWVAR 2
106166: PUSH
106167: EMPTY
106168: LIST
106169: LIST
106170: PUSH
106171: LD_INT 25
106173: PUSH
106174: LD_INT 1
106176: PUSH
106177: EMPTY
106178: LIST
106179: LIST
106180: PUSH
106181: EMPTY
106182: LIST
106183: LIST
106184: PPUSH
106185: CALL_OW 69
106189: ST_TO_ADDR
// if not tmp then
106190: LD_VAR 0 2
106194: NOT
106195: IFFALSE 106199
// exit ;
106197: GO 106361
// un := tmp [ rand ( 1 , tmp ) ] ;
106199: LD_ADDR_VAR 0 3
106203: PUSH
106204: LD_VAR 0 2
106208: PUSH
106209: LD_INT 1
106211: PPUSH
106212: LD_VAR 0 2
106216: PPUSH
106217: CALL_OW 12
106221: ARRAY
106222: ST_TO_ADDR
// if Crawls ( un ) then
106223: LD_VAR 0 3
106227: PPUSH
106228: CALL_OW 318
106232: IFFALSE 106243
// ComWalk ( un ) ;
106234: LD_VAR 0 3
106238: PPUSH
106239: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106243: LD_VAR 0 3
106247: PPUSH
106248: LD_INT 8
106250: PPUSH
106251: CALL_OW 336
// end ; 4 :
106255: GO 106361
106257: LD_INT 4
106259: DOUBLE
106260: EQUAL
106261: IFTRUE 106265
106263: GO 106339
106265: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106266: LD_ADDR_VAR 0 2
106270: PUSH
106271: LD_INT 22
106273: PUSH
106274: LD_OWVAR 2
106278: PUSH
106279: EMPTY
106280: LIST
106281: LIST
106282: PUSH
106283: LD_INT 30
106285: PUSH
106286: LD_INT 29
106288: PUSH
106289: EMPTY
106290: LIST
106291: LIST
106292: PUSH
106293: EMPTY
106294: LIST
106295: LIST
106296: PPUSH
106297: CALL_OW 69
106301: ST_TO_ADDR
// if not tmp then
106302: LD_VAR 0 2
106306: NOT
106307: IFFALSE 106311
// exit ;
106309: GO 106361
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106311: LD_VAR 0 2
106315: PUSH
106316: LD_INT 1
106318: ARRAY
106319: PPUSH
106320: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106324: LD_VAR 0 2
106328: PUSH
106329: LD_INT 1
106331: ARRAY
106332: PPUSH
106333: CALL_OW 65
// end ; 5 .. 7 :
106337: GO 106361
106339: LD_INT 5
106341: DOUBLE
106342: GREATEREQUAL
106343: IFFALSE 106351
106345: LD_INT 7
106347: DOUBLE
106348: LESSEQUAL
106349: IFTRUE 106353
106351: GO 106360
106353: POP
// StreamSibBomb ; end ;
106354: CALL 102598 0 0
106358: GO 106361
106360: POP
// end ;
106361: PPOPN 3
106363: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106364: LD_EXP 124
106368: PUSH
106369: LD_EXP 174
106373: AND
106374: IFFALSE 106530
106376: GO 106378
106378: DISABLE
106379: LD_INT 0
106381: PPUSH
106382: PPUSH
106383: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106384: LD_ADDR_VAR 0 2
106388: PUSH
106389: LD_INT 81
106391: PUSH
106392: LD_OWVAR 2
106396: PUSH
106397: EMPTY
106398: LIST
106399: LIST
106400: PUSH
106401: LD_INT 2
106403: PUSH
106404: LD_INT 21
106406: PUSH
106407: LD_INT 1
106409: PUSH
106410: EMPTY
106411: LIST
106412: LIST
106413: PUSH
106414: LD_INT 21
106416: PUSH
106417: LD_INT 2
106419: PUSH
106420: EMPTY
106421: LIST
106422: LIST
106423: PUSH
106424: EMPTY
106425: LIST
106426: LIST
106427: LIST
106428: PUSH
106429: EMPTY
106430: LIST
106431: LIST
106432: PPUSH
106433: CALL_OW 69
106437: ST_TO_ADDR
// if not tmp then
106438: LD_VAR 0 2
106442: NOT
106443: IFFALSE 106447
// exit ;
106445: GO 106530
// p := 0 ;
106447: LD_ADDR_VAR 0 3
106451: PUSH
106452: LD_INT 0
106454: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106455: LD_INT 35
106457: PPUSH
106458: CALL_OW 67
// p := p + 1 ;
106462: LD_ADDR_VAR 0 3
106466: PUSH
106467: LD_VAR 0 3
106471: PUSH
106472: LD_INT 1
106474: PLUS
106475: ST_TO_ADDR
// for i in tmp do
106476: LD_ADDR_VAR 0 1
106480: PUSH
106481: LD_VAR 0 2
106485: PUSH
106486: FOR_IN
106487: IFFALSE 106518
// if GetLives ( i ) < 1000 then
106489: LD_VAR 0 1
106493: PPUSH
106494: CALL_OW 256
106498: PUSH
106499: LD_INT 1000
106501: LESS
106502: IFFALSE 106516
// SetLives ( i , 1000 ) ;
106504: LD_VAR 0 1
106508: PPUSH
106509: LD_INT 1000
106511: PPUSH
106512: CALL_OW 234
106516: GO 106486
106518: POP
106519: POP
// until p > 20 ;
106520: LD_VAR 0 3
106524: PUSH
106525: LD_INT 20
106527: GREATER
106528: IFFALSE 106455
// end ;
106530: PPOPN 3
106532: END
// every 0 0$1 trigger StreamModeActive and sTime do
106533: LD_EXP 124
106537: PUSH
106538: LD_EXP 175
106542: AND
106543: IFFALSE 106578
106545: GO 106547
106547: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106548: LD_INT 28
106550: PPUSH
106551: LD_OWVAR 2
106555: PPUSH
106556: LD_INT 2
106558: PPUSH
106559: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106563: LD_INT 30
106565: PPUSH
106566: LD_OWVAR 2
106570: PPUSH
106571: LD_INT 2
106573: PPUSH
106574: CALL_OW 322
// end ;
106578: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106579: LD_EXP 124
106583: PUSH
106584: LD_EXP 176
106588: AND
106589: IFFALSE 106710
106591: GO 106593
106593: DISABLE
106594: LD_INT 0
106596: PPUSH
106597: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106598: LD_ADDR_VAR 0 2
106602: PUSH
106603: LD_INT 22
106605: PUSH
106606: LD_OWVAR 2
106610: PUSH
106611: EMPTY
106612: LIST
106613: LIST
106614: PUSH
106615: LD_INT 21
106617: PUSH
106618: LD_INT 1
106620: PUSH
106621: EMPTY
106622: LIST
106623: LIST
106624: PUSH
106625: LD_INT 3
106627: PUSH
106628: LD_INT 23
106630: PUSH
106631: LD_INT 0
106633: PUSH
106634: EMPTY
106635: LIST
106636: LIST
106637: PUSH
106638: EMPTY
106639: LIST
106640: LIST
106641: PUSH
106642: EMPTY
106643: LIST
106644: LIST
106645: LIST
106646: PPUSH
106647: CALL_OW 69
106651: ST_TO_ADDR
// if not tmp then
106652: LD_VAR 0 2
106656: NOT
106657: IFFALSE 106661
// exit ;
106659: GO 106710
// for i in tmp do
106661: LD_ADDR_VAR 0 1
106665: PUSH
106666: LD_VAR 0 2
106670: PUSH
106671: FOR_IN
106672: IFFALSE 106708
// begin if Crawls ( i ) then
106674: LD_VAR 0 1
106678: PPUSH
106679: CALL_OW 318
106683: IFFALSE 106694
// ComWalk ( i ) ;
106685: LD_VAR 0 1
106689: PPUSH
106690: CALL_OW 138
// SetClass ( i , 2 ) ;
106694: LD_VAR 0 1
106698: PPUSH
106699: LD_INT 2
106701: PPUSH
106702: CALL_OW 336
// end ;
106706: GO 106671
106708: POP
106709: POP
// end ;
106710: PPOPN 2
106712: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106713: LD_EXP 124
106717: PUSH
106718: LD_EXP 177
106722: AND
106723: IFFALSE 107011
106725: GO 106727
106727: DISABLE
106728: LD_INT 0
106730: PPUSH
106731: PPUSH
106732: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106733: LD_OWVAR 2
106737: PPUSH
106738: LD_INT 9
106740: PPUSH
106741: LD_INT 1
106743: PPUSH
106744: LD_INT 1
106746: PPUSH
106747: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106751: LD_INT 9
106753: PPUSH
106754: LD_OWVAR 2
106758: PPUSH
106759: CALL_OW 343
// uc_side := 9 ;
106763: LD_ADDR_OWVAR 20
106767: PUSH
106768: LD_INT 9
106770: ST_TO_ADDR
// uc_nation := 2 ;
106771: LD_ADDR_OWVAR 21
106775: PUSH
106776: LD_INT 2
106778: ST_TO_ADDR
// hc_name := Dark Warrior ;
106779: LD_ADDR_OWVAR 26
106783: PUSH
106784: LD_STRING Dark Warrior
106786: ST_TO_ADDR
// hc_gallery :=  ;
106787: LD_ADDR_OWVAR 33
106791: PUSH
106792: LD_STRING 
106794: ST_TO_ADDR
// hc_noskilllimit := true ;
106795: LD_ADDR_OWVAR 76
106799: PUSH
106800: LD_INT 1
106802: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106803: LD_ADDR_OWVAR 31
106807: PUSH
106808: LD_INT 30
106810: PUSH
106811: LD_INT 30
106813: PUSH
106814: LD_INT 30
106816: PUSH
106817: LD_INT 30
106819: PUSH
106820: EMPTY
106821: LIST
106822: LIST
106823: LIST
106824: LIST
106825: ST_TO_ADDR
// un := CreateHuman ;
106826: LD_ADDR_VAR 0 3
106830: PUSH
106831: CALL_OW 44
106835: ST_TO_ADDR
// hc_noskilllimit := false ;
106836: LD_ADDR_OWVAR 76
106840: PUSH
106841: LD_INT 0
106843: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106844: LD_VAR 0 3
106848: PPUSH
106849: LD_INT 1
106851: PPUSH
106852: CALL_OW 51
// ToLua ( playRanger() ) ;
106856: LD_STRING playRanger()
106858: PPUSH
106859: CALL_OW 559
// p := 0 ;
106863: LD_ADDR_VAR 0 2
106867: PUSH
106868: LD_INT 0
106870: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106871: LD_INT 35
106873: PPUSH
106874: CALL_OW 67
// p := p + 1 ;
106878: LD_ADDR_VAR 0 2
106882: PUSH
106883: LD_VAR 0 2
106887: PUSH
106888: LD_INT 1
106890: PLUS
106891: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106892: LD_VAR 0 3
106896: PPUSH
106897: CALL_OW 256
106901: PUSH
106902: LD_INT 1000
106904: LESS
106905: IFFALSE 106919
// SetLives ( un , 1000 ) ;
106907: LD_VAR 0 3
106911: PPUSH
106912: LD_INT 1000
106914: PPUSH
106915: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106919: LD_VAR 0 3
106923: PPUSH
106924: LD_INT 81
106926: PUSH
106927: LD_OWVAR 2
106931: PUSH
106932: EMPTY
106933: LIST
106934: LIST
106935: PUSH
106936: LD_INT 91
106938: PUSH
106939: LD_VAR 0 3
106943: PUSH
106944: LD_INT 30
106946: PUSH
106947: EMPTY
106948: LIST
106949: LIST
106950: LIST
106951: PUSH
106952: EMPTY
106953: LIST
106954: LIST
106955: PPUSH
106956: CALL_OW 69
106960: PPUSH
106961: LD_VAR 0 3
106965: PPUSH
106966: CALL_OW 74
106970: PPUSH
106971: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106975: LD_VAR 0 2
106979: PUSH
106980: LD_INT 80
106982: GREATER
106983: PUSH
106984: LD_VAR 0 3
106988: PPUSH
106989: CALL_OW 301
106993: OR
106994: IFFALSE 106871
// if un then
106996: LD_VAR 0 3
107000: IFFALSE 107011
// RemoveUnit ( un ) ;
107002: LD_VAR 0 3
107006: PPUSH
107007: CALL_OW 64
// end ;
107011: PPOPN 3
107013: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
107014: LD_EXP 178
107018: IFFALSE 107134
107020: GO 107022
107022: DISABLE
107023: LD_INT 0
107025: PPUSH
107026: PPUSH
107027: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107028: LD_ADDR_VAR 0 2
107032: PUSH
107033: LD_INT 81
107035: PUSH
107036: LD_OWVAR 2
107040: PUSH
107041: EMPTY
107042: LIST
107043: LIST
107044: PUSH
107045: LD_INT 21
107047: PUSH
107048: LD_INT 1
107050: PUSH
107051: EMPTY
107052: LIST
107053: LIST
107054: PUSH
107055: EMPTY
107056: LIST
107057: LIST
107058: PPUSH
107059: CALL_OW 69
107063: ST_TO_ADDR
// ToLua ( playComputer() ) ;
107064: LD_STRING playComputer()
107066: PPUSH
107067: CALL_OW 559
// if not tmp then
107071: LD_VAR 0 2
107075: NOT
107076: IFFALSE 107080
// exit ;
107078: GO 107134
// for i in tmp do
107080: LD_ADDR_VAR 0 1
107084: PUSH
107085: LD_VAR 0 2
107089: PUSH
107090: FOR_IN
107091: IFFALSE 107132
// for j := 1 to 4 do
107093: LD_ADDR_VAR 0 3
107097: PUSH
107098: DOUBLE
107099: LD_INT 1
107101: DEC
107102: ST_TO_ADDR
107103: LD_INT 4
107105: PUSH
107106: FOR_TO
107107: IFFALSE 107128
// SetSkill ( i , j , 10 ) ;
107109: LD_VAR 0 1
107113: PPUSH
107114: LD_VAR 0 3
107118: PPUSH
107119: LD_INT 10
107121: PPUSH
107122: CALL_OW 237
107126: GO 107106
107128: POP
107129: POP
107130: GO 107090
107132: POP
107133: POP
// end ;
107134: PPOPN 3
107136: END
// every 0 0$1 trigger s30 do var i , tmp ;
107137: LD_EXP 179
107141: IFFALSE 107210
107143: GO 107145
107145: DISABLE
107146: LD_INT 0
107148: PPUSH
107149: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107150: LD_ADDR_VAR 0 2
107154: PUSH
107155: LD_INT 22
107157: PUSH
107158: LD_OWVAR 2
107162: PUSH
107163: EMPTY
107164: LIST
107165: LIST
107166: PPUSH
107167: CALL_OW 69
107171: ST_TO_ADDR
// if not tmp then
107172: LD_VAR 0 2
107176: NOT
107177: IFFALSE 107181
// exit ;
107179: GO 107210
// for i in tmp do
107181: LD_ADDR_VAR 0 1
107185: PUSH
107186: LD_VAR 0 2
107190: PUSH
107191: FOR_IN
107192: IFFALSE 107208
// SetLives ( i , 300 ) ;
107194: LD_VAR 0 1
107198: PPUSH
107199: LD_INT 300
107201: PPUSH
107202: CALL_OW 234
107206: GO 107191
107208: POP
107209: POP
// end ;
107210: PPOPN 2
107212: END
// every 0 0$1 trigger s60 do var i , tmp ;
107213: LD_EXP 180
107217: IFFALSE 107286
107219: GO 107221
107221: DISABLE
107222: LD_INT 0
107224: PPUSH
107225: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107226: LD_ADDR_VAR 0 2
107230: PUSH
107231: LD_INT 22
107233: PUSH
107234: LD_OWVAR 2
107238: PUSH
107239: EMPTY
107240: LIST
107241: LIST
107242: PPUSH
107243: CALL_OW 69
107247: ST_TO_ADDR
// if not tmp then
107248: LD_VAR 0 2
107252: NOT
107253: IFFALSE 107257
// exit ;
107255: GO 107286
// for i in tmp do
107257: LD_ADDR_VAR 0 1
107261: PUSH
107262: LD_VAR 0 2
107266: PUSH
107267: FOR_IN
107268: IFFALSE 107284
// SetLives ( i , 600 ) ;
107270: LD_VAR 0 1
107274: PPUSH
107275: LD_INT 600
107277: PPUSH
107278: CALL_OW 234
107282: GO 107267
107284: POP
107285: POP
// end ;
107286: PPOPN 2
107288: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107289: LD_INT 0
107291: PPUSH
// case cmd of 301 :
107292: LD_VAR 0 1
107296: PUSH
107297: LD_INT 301
107299: DOUBLE
107300: EQUAL
107301: IFTRUE 107305
107303: GO 107337
107305: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107306: LD_VAR 0 6
107310: PPUSH
107311: LD_VAR 0 7
107315: PPUSH
107316: LD_VAR 0 8
107320: PPUSH
107321: LD_VAR 0 4
107325: PPUSH
107326: LD_VAR 0 5
107330: PPUSH
107331: CALL 108546 0 5
107335: GO 107458
107337: LD_INT 302
107339: DOUBLE
107340: EQUAL
107341: IFTRUE 107345
107343: GO 107382
107345: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107346: LD_VAR 0 6
107350: PPUSH
107351: LD_VAR 0 7
107355: PPUSH
107356: LD_VAR 0 8
107360: PPUSH
107361: LD_VAR 0 9
107365: PPUSH
107366: LD_VAR 0 4
107370: PPUSH
107371: LD_VAR 0 5
107375: PPUSH
107376: CALL 108637 0 6
107380: GO 107458
107382: LD_INT 303
107384: DOUBLE
107385: EQUAL
107386: IFTRUE 107390
107388: GO 107427
107390: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107391: LD_VAR 0 6
107395: PPUSH
107396: LD_VAR 0 7
107400: PPUSH
107401: LD_VAR 0 8
107405: PPUSH
107406: LD_VAR 0 9
107410: PPUSH
107411: LD_VAR 0 4
107415: PPUSH
107416: LD_VAR 0 5
107420: PPUSH
107421: CALL 107463 0 6
107425: GO 107458
107427: LD_INT 304
107429: DOUBLE
107430: EQUAL
107431: IFTRUE 107435
107433: GO 107457
107435: POP
// hHackTeleport ( unit , x , y ) ; end ;
107436: LD_VAR 0 2
107440: PPUSH
107441: LD_VAR 0 4
107445: PPUSH
107446: LD_VAR 0 5
107450: PPUSH
107451: CALL 109230 0 3
107455: GO 107458
107457: POP
// end ;
107458: LD_VAR 0 12
107462: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107463: LD_INT 0
107465: PPUSH
107466: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107467: LD_VAR 0 1
107471: PUSH
107472: LD_INT 1
107474: LESS
107475: PUSH
107476: LD_VAR 0 1
107480: PUSH
107481: LD_INT 3
107483: GREATER
107484: OR
107485: PUSH
107486: LD_VAR 0 5
107490: PPUSH
107491: LD_VAR 0 6
107495: PPUSH
107496: CALL_OW 428
107500: OR
107501: IFFALSE 107505
// exit ;
107503: GO 108233
// uc_side := your_side ;
107505: LD_ADDR_OWVAR 20
107509: PUSH
107510: LD_OWVAR 2
107514: ST_TO_ADDR
// uc_nation := nation ;
107515: LD_ADDR_OWVAR 21
107519: PUSH
107520: LD_VAR 0 1
107524: ST_TO_ADDR
// bc_level = 1 ;
107525: LD_ADDR_OWVAR 43
107529: PUSH
107530: LD_INT 1
107532: ST_TO_ADDR
// case btype of 1 :
107533: LD_VAR 0 2
107537: PUSH
107538: LD_INT 1
107540: DOUBLE
107541: EQUAL
107542: IFTRUE 107546
107544: GO 107557
107546: POP
// bc_type := b_depot ; 2 :
107547: LD_ADDR_OWVAR 42
107551: PUSH
107552: LD_INT 0
107554: ST_TO_ADDR
107555: GO 108177
107557: LD_INT 2
107559: DOUBLE
107560: EQUAL
107561: IFTRUE 107565
107563: GO 107576
107565: POP
// bc_type := b_warehouse ; 3 :
107566: LD_ADDR_OWVAR 42
107570: PUSH
107571: LD_INT 1
107573: ST_TO_ADDR
107574: GO 108177
107576: LD_INT 3
107578: DOUBLE
107579: EQUAL
107580: IFTRUE 107584
107582: GO 107595
107584: POP
// bc_type := b_lab ; 4 .. 9 :
107585: LD_ADDR_OWVAR 42
107589: PUSH
107590: LD_INT 6
107592: ST_TO_ADDR
107593: GO 108177
107595: LD_INT 4
107597: DOUBLE
107598: GREATEREQUAL
107599: IFFALSE 107607
107601: LD_INT 9
107603: DOUBLE
107604: LESSEQUAL
107605: IFTRUE 107609
107607: GO 107669
107609: POP
// begin bc_type := b_lab_half ;
107610: LD_ADDR_OWVAR 42
107614: PUSH
107615: LD_INT 7
107617: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107618: LD_ADDR_OWVAR 44
107622: PUSH
107623: LD_INT 10
107625: PUSH
107626: LD_INT 11
107628: PUSH
107629: LD_INT 12
107631: PUSH
107632: LD_INT 15
107634: PUSH
107635: LD_INT 14
107637: PUSH
107638: LD_INT 13
107640: PUSH
107641: EMPTY
107642: LIST
107643: LIST
107644: LIST
107645: LIST
107646: LIST
107647: LIST
107648: PUSH
107649: LD_VAR 0 2
107653: PUSH
107654: LD_INT 3
107656: MINUS
107657: ARRAY
107658: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
107659: LD_ADDR_OWVAR 45
107663: PUSH
107664: LD_INT 9
107666: ST_TO_ADDR
// end ; 10 .. 13 :
107667: GO 108177
107669: LD_INT 10
107671: DOUBLE
107672: GREATEREQUAL
107673: IFFALSE 107681
107675: LD_INT 13
107677: DOUBLE
107678: LESSEQUAL
107679: IFTRUE 107683
107681: GO 107760
107683: POP
// begin bc_type := b_lab_full ;
107684: LD_ADDR_OWVAR 42
107688: PUSH
107689: LD_INT 8
107691: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107692: LD_ADDR_OWVAR 44
107696: PUSH
107697: LD_INT 10
107699: PUSH
107700: LD_INT 12
107702: PUSH
107703: LD_INT 14
107705: PUSH
107706: LD_INT 13
107708: PUSH
107709: EMPTY
107710: LIST
107711: LIST
107712: LIST
107713: LIST
107714: PUSH
107715: LD_VAR 0 2
107719: PUSH
107720: LD_INT 9
107722: MINUS
107723: ARRAY
107724: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107725: LD_ADDR_OWVAR 45
107729: PUSH
107730: LD_INT 11
107732: PUSH
107733: LD_INT 15
107735: PUSH
107736: LD_INT 12
107738: PUSH
107739: LD_INT 15
107741: PUSH
107742: EMPTY
107743: LIST
107744: LIST
107745: LIST
107746: LIST
107747: PUSH
107748: LD_VAR 0 2
107752: PUSH
107753: LD_INT 9
107755: MINUS
107756: ARRAY
107757: ST_TO_ADDR
// end ; 14 :
107758: GO 108177
107760: LD_INT 14
107762: DOUBLE
107763: EQUAL
107764: IFTRUE 107768
107766: GO 107779
107768: POP
// bc_type := b_workshop ; 15 :
107769: LD_ADDR_OWVAR 42
107773: PUSH
107774: LD_INT 2
107776: ST_TO_ADDR
107777: GO 108177
107779: LD_INT 15
107781: DOUBLE
107782: EQUAL
107783: IFTRUE 107787
107785: GO 107798
107787: POP
// bc_type := b_factory ; 16 :
107788: LD_ADDR_OWVAR 42
107792: PUSH
107793: LD_INT 3
107795: ST_TO_ADDR
107796: GO 108177
107798: LD_INT 16
107800: DOUBLE
107801: EQUAL
107802: IFTRUE 107806
107804: GO 107817
107806: POP
// bc_type := b_ext_gun ; 17 :
107807: LD_ADDR_OWVAR 42
107811: PUSH
107812: LD_INT 17
107814: ST_TO_ADDR
107815: GO 108177
107817: LD_INT 17
107819: DOUBLE
107820: EQUAL
107821: IFTRUE 107825
107823: GO 107853
107825: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107826: LD_ADDR_OWVAR 42
107830: PUSH
107831: LD_INT 19
107833: PUSH
107834: LD_INT 23
107836: PUSH
107837: LD_INT 19
107839: PUSH
107840: EMPTY
107841: LIST
107842: LIST
107843: LIST
107844: PUSH
107845: LD_VAR 0 1
107849: ARRAY
107850: ST_TO_ADDR
107851: GO 108177
107853: LD_INT 18
107855: DOUBLE
107856: EQUAL
107857: IFTRUE 107861
107859: GO 107872
107861: POP
// bc_type := b_ext_radar ; 19 :
107862: LD_ADDR_OWVAR 42
107866: PUSH
107867: LD_INT 20
107869: ST_TO_ADDR
107870: GO 108177
107872: LD_INT 19
107874: DOUBLE
107875: EQUAL
107876: IFTRUE 107880
107878: GO 107891
107880: POP
// bc_type := b_ext_radio ; 20 :
107881: LD_ADDR_OWVAR 42
107885: PUSH
107886: LD_INT 22
107888: ST_TO_ADDR
107889: GO 108177
107891: LD_INT 20
107893: DOUBLE
107894: EQUAL
107895: IFTRUE 107899
107897: GO 107910
107899: POP
// bc_type := b_ext_siberium ; 21 :
107900: LD_ADDR_OWVAR 42
107904: PUSH
107905: LD_INT 21
107907: ST_TO_ADDR
107908: GO 108177
107910: LD_INT 21
107912: DOUBLE
107913: EQUAL
107914: IFTRUE 107918
107916: GO 107929
107918: POP
// bc_type := b_ext_computer ; 22 :
107919: LD_ADDR_OWVAR 42
107923: PUSH
107924: LD_INT 24
107926: ST_TO_ADDR
107927: GO 108177
107929: LD_INT 22
107931: DOUBLE
107932: EQUAL
107933: IFTRUE 107937
107935: GO 107948
107937: POP
// bc_type := b_ext_track ; 23 :
107938: LD_ADDR_OWVAR 42
107942: PUSH
107943: LD_INT 16
107945: ST_TO_ADDR
107946: GO 108177
107948: LD_INT 23
107950: DOUBLE
107951: EQUAL
107952: IFTRUE 107956
107954: GO 107967
107956: POP
// bc_type := b_ext_laser ; 24 :
107957: LD_ADDR_OWVAR 42
107961: PUSH
107962: LD_INT 25
107964: ST_TO_ADDR
107965: GO 108177
107967: LD_INT 24
107969: DOUBLE
107970: EQUAL
107971: IFTRUE 107975
107973: GO 107986
107975: POP
// bc_type := b_control_tower ; 25 :
107976: LD_ADDR_OWVAR 42
107980: PUSH
107981: LD_INT 36
107983: ST_TO_ADDR
107984: GO 108177
107986: LD_INT 25
107988: DOUBLE
107989: EQUAL
107990: IFTRUE 107994
107992: GO 108005
107994: POP
// bc_type := b_breastwork ; 26 :
107995: LD_ADDR_OWVAR 42
107999: PUSH
108000: LD_INT 31
108002: ST_TO_ADDR
108003: GO 108177
108005: LD_INT 26
108007: DOUBLE
108008: EQUAL
108009: IFTRUE 108013
108011: GO 108024
108013: POP
// bc_type := b_bunker ; 27 :
108014: LD_ADDR_OWVAR 42
108018: PUSH
108019: LD_INT 32
108021: ST_TO_ADDR
108022: GO 108177
108024: LD_INT 27
108026: DOUBLE
108027: EQUAL
108028: IFTRUE 108032
108030: GO 108043
108032: POP
// bc_type := b_turret ; 28 :
108033: LD_ADDR_OWVAR 42
108037: PUSH
108038: LD_INT 33
108040: ST_TO_ADDR
108041: GO 108177
108043: LD_INT 28
108045: DOUBLE
108046: EQUAL
108047: IFTRUE 108051
108049: GO 108062
108051: POP
// bc_type := b_armoury ; 29 :
108052: LD_ADDR_OWVAR 42
108056: PUSH
108057: LD_INT 4
108059: ST_TO_ADDR
108060: GO 108177
108062: LD_INT 29
108064: DOUBLE
108065: EQUAL
108066: IFTRUE 108070
108068: GO 108081
108070: POP
// bc_type := b_barracks ; 30 :
108071: LD_ADDR_OWVAR 42
108075: PUSH
108076: LD_INT 5
108078: ST_TO_ADDR
108079: GO 108177
108081: LD_INT 30
108083: DOUBLE
108084: EQUAL
108085: IFTRUE 108089
108087: GO 108100
108089: POP
// bc_type := b_solar_power ; 31 :
108090: LD_ADDR_OWVAR 42
108094: PUSH
108095: LD_INT 27
108097: ST_TO_ADDR
108098: GO 108177
108100: LD_INT 31
108102: DOUBLE
108103: EQUAL
108104: IFTRUE 108108
108106: GO 108119
108108: POP
// bc_type := b_oil_power ; 32 :
108109: LD_ADDR_OWVAR 42
108113: PUSH
108114: LD_INT 26
108116: ST_TO_ADDR
108117: GO 108177
108119: LD_INT 32
108121: DOUBLE
108122: EQUAL
108123: IFTRUE 108127
108125: GO 108138
108127: POP
// bc_type := b_siberite_power ; 33 :
108128: LD_ADDR_OWVAR 42
108132: PUSH
108133: LD_INT 28
108135: ST_TO_ADDR
108136: GO 108177
108138: LD_INT 33
108140: DOUBLE
108141: EQUAL
108142: IFTRUE 108146
108144: GO 108157
108146: POP
// bc_type := b_oil_mine ; 34 :
108147: LD_ADDR_OWVAR 42
108151: PUSH
108152: LD_INT 29
108154: ST_TO_ADDR
108155: GO 108177
108157: LD_INT 34
108159: DOUBLE
108160: EQUAL
108161: IFTRUE 108165
108163: GO 108176
108165: POP
// bc_type := b_siberite_mine ; end ;
108166: LD_ADDR_OWVAR 42
108170: PUSH
108171: LD_INT 30
108173: ST_TO_ADDR
108174: GO 108177
108176: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108177: LD_ADDR_VAR 0 8
108181: PUSH
108182: LD_VAR 0 5
108186: PPUSH
108187: LD_VAR 0 6
108191: PPUSH
108192: LD_VAR 0 3
108196: PPUSH
108197: CALL_OW 47
108201: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108202: LD_OWVAR 42
108206: PUSH
108207: LD_INT 32
108209: PUSH
108210: LD_INT 33
108212: PUSH
108213: EMPTY
108214: LIST
108215: LIST
108216: IN
108217: IFFALSE 108233
// PlaceWeaponTurret ( b , weapon ) ;
108219: LD_VAR 0 8
108223: PPUSH
108224: LD_VAR 0 4
108228: PPUSH
108229: CALL_OW 431
// end ;
108233: LD_VAR 0 7
108237: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108238: LD_INT 0
108240: PPUSH
108241: PPUSH
108242: PPUSH
108243: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108244: LD_ADDR_VAR 0 4
108248: PUSH
108249: LD_INT 22
108251: PUSH
108252: LD_OWVAR 2
108256: PUSH
108257: EMPTY
108258: LIST
108259: LIST
108260: PUSH
108261: LD_INT 2
108263: PUSH
108264: LD_INT 30
108266: PUSH
108267: LD_INT 0
108269: PUSH
108270: EMPTY
108271: LIST
108272: LIST
108273: PUSH
108274: LD_INT 30
108276: PUSH
108277: LD_INT 1
108279: PUSH
108280: EMPTY
108281: LIST
108282: LIST
108283: PUSH
108284: EMPTY
108285: LIST
108286: LIST
108287: LIST
108288: PUSH
108289: EMPTY
108290: LIST
108291: LIST
108292: PPUSH
108293: CALL_OW 69
108297: ST_TO_ADDR
// if not tmp then
108298: LD_VAR 0 4
108302: NOT
108303: IFFALSE 108307
// exit ;
108305: GO 108366
// for i in tmp do
108307: LD_ADDR_VAR 0 2
108311: PUSH
108312: LD_VAR 0 4
108316: PUSH
108317: FOR_IN
108318: IFFALSE 108364
// for j = 1 to 3 do
108320: LD_ADDR_VAR 0 3
108324: PUSH
108325: DOUBLE
108326: LD_INT 1
108328: DEC
108329: ST_TO_ADDR
108330: LD_INT 3
108332: PUSH
108333: FOR_TO
108334: IFFALSE 108360
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108336: LD_VAR 0 2
108340: PPUSH
108341: CALL_OW 274
108345: PPUSH
108346: LD_VAR 0 3
108350: PPUSH
108351: LD_INT 99999
108353: PPUSH
108354: CALL_OW 277
108358: GO 108333
108360: POP
108361: POP
108362: GO 108317
108364: POP
108365: POP
// end ;
108366: LD_VAR 0 1
108370: RET
// export function hHackSetLevel10 ; var i , j ; begin
108371: LD_INT 0
108373: PPUSH
108374: PPUSH
108375: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108376: LD_ADDR_VAR 0 2
108380: PUSH
108381: LD_INT 21
108383: PUSH
108384: LD_INT 1
108386: PUSH
108387: EMPTY
108388: LIST
108389: LIST
108390: PPUSH
108391: CALL_OW 69
108395: PUSH
108396: FOR_IN
108397: IFFALSE 108449
// if IsSelected ( i ) then
108399: LD_VAR 0 2
108403: PPUSH
108404: CALL_OW 306
108408: IFFALSE 108447
// begin for j := 1 to 4 do
108410: LD_ADDR_VAR 0 3
108414: PUSH
108415: DOUBLE
108416: LD_INT 1
108418: DEC
108419: ST_TO_ADDR
108420: LD_INT 4
108422: PUSH
108423: FOR_TO
108424: IFFALSE 108445
// SetSkill ( i , j , 10 ) ;
108426: LD_VAR 0 2
108430: PPUSH
108431: LD_VAR 0 3
108435: PPUSH
108436: LD_INT 10
108438: PPUSH
108439: CALL_OW 237
108443: GO 108423
108445: POP
108446: POP
// end ;
108447: GO 108396
108449: POP
108450: POP
// end ;
108451: LD_VAR 0 1
108455: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108456: LD_INT 0
108458: PPUSH
108459: PPUSH
108460: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108461: LD_ADDR_VAR 0 2
108465: PUSH
108466: LD_INT 22
108468: PUSH
108469: LD_OWVAR 2
108473: PUSH
108474: EMPTY
108475: LIST
108476: LIST
108477: PUSH
108478: LD_INT 21
108480: PUSH
108481: LD_INT 1
108483: PUSH
108484: EMPTY
108485: LIST
108486: LIST
108487: PUSH
108488: EMPTY
108489: LIST
108490: LIST
108491: PPUSH
108492: CALL_OW 69
108496: PUSH
108497: FOR_IN
108498: IFFALSE 108539
// begin for j := 1 to 4 do
108500: LD_ADDR_VAR 0 3
108504: PUSH
108505: DOUBLE
108506: LD_INT 1
108508: DEC
108509: ST_TO_ADDR
108510: LD_INT 4
108512: PUSH
108513: FOR_TO
108514: IFFALSE 108535
// SetSkill ( i , j , 10 ) ;
108516: LD_VAR 0 2
108520: PPUSH
108521: LD_VAR 0 3
108525: PPUSH
108526: LD_INT 10
108528: PPUSH
108529: CALL_OW 237
108533: GO 108513
108535: POP
108536: POP
// end ;
108537: GO 108497
108539: POP
108540: POP
// end ;
108541: LD_VAR 0 1
108545: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108546: LD_INT 0
108548: PPUSH
// uc_side := your_side ;
108549: LD_ADDR_OWVAR 20
108553: PUSH
108554: LD_OWVAR 2
108558: ST_TO_ADDR
// uc_nation := nation ;
108559: LD_ADDR_OWVAR 21
108563: PUSH
108564: LD_VAR 0 1
108568: ST_TO_ADDR
// InitHc ;
108569: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108573: LD_INT 0
108575: PPUSH
108576: LD_VAR 0 2
108580: PPUSH
108581: LD_VAR 0 3
108585: PPUSH
108586: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108590: LD_VAR 0 4
108594: PPUSH
108595: LD_VAR 0 5
108599: PPUSH
108600: CALL_OW 428
108604: PUSH
108605: LD_INT 0
108607: EQUAL
108608: IFFALSE 108632
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108610: CALL_OW 44
108614: PPUSH
108615: LD_VAR 0 4
108619: PPUSH
108620: LD_VAR 0 5
108624: PPUSH
108625: LD_INT 1
108627: PPUSH
108628: CALL_OW 48
// end ;
108632: LD_VAR 0 6
108636: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108637: LD_INT 0
108639: PPUSH
108640: PPUSH
// uc_side := your_side ;
108641: LD_ADDR_OWVAR 20
108645: PUSH
108646: LD_OWVAR 2
108650: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108651: LD_VAR 0 1
108655: PUSH
108656: LD_INT 1
108658: PUSH
108659: LD_INT 2
108661: PUSH
108662: LD_INT 3
108664: PUSH
108665: LD_INT 4
108667: PUSH
108668: LD_INT 5
108670: PUSH
108671: EMPTY
108672: LIST
108673: LIST
108674: LIST
108675: LIST
108676: LIST
108677: IN
108678: IFFALSE 108690
// uc_nation := nation_american else
108680: LD_ADDR_OWVAR 21
108684: PUSH
108685: LD_INT 1
108687: ST_TO_ADDR
108688: GO 108733
// if chassis in [ 11 , 12 , 13 , 14 ] then
108690: LD_VAR 0 1
108694: PUSH
108695: LD_INT 11
108697: PUSH
108698: LD_INT 12
108700: PUSH
108701: LD_INT 13
108703: PUSH
108704: LD_INT 14
108706: PUSH
108707: EMPTY
108708: LIST
108709: LIST
108710: LIST
108711: LIST
108712: IN
108713: IFFALSE 108725
// uc_nation := nation_arabian else
108715: LD_ADDR_OWVAR 21
108719: PUSH
108720: LD_INT 2
108722: ST_TO_ADDR
108723: GO 108733
// uc_nation := nation_russian ;
108725: LD_ADDR_OWVAR 21
108729: PUSH
108730: LD_INT 3
108732: ST_TO_ADDR
// vc_chassis := chassis ;
108733: LD_ADDR_OWVAR 37
108737: PUSH
108738: LD_VAR 0 1
108742: ST_TO_ADDR
// vc_engine := engine ;
108743: LD_ADDR_OWVAR 39
108747: PUSH
108748: LD_VAR 0 2
108752: ST_TO_ADDR
// vc_control := control ;
108753: LD_ADDR_OWVAR 38
108757: PUSH
108758: LD_VAR 0 3
108762: ST_TO_ADDR
// vc_weapon := weapon ;
108763: LD_ADDR_OWVAR 40
108767: PUSH
108768: LD_VAR 0 4
108772: ST_TO_ADDR
// un := CreateVehicle ;
108773: LD_ADDR_VAR 0 8
108777: PUSH
108778: CALL_OW 45
108782: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108783: LD_VAR 0 8
108787: PPUSH
108788: LD_INT 0
108790: PPUSH
108791: LD_INT 5
108793: PPUSH
108794: CALL_OW 12
108798: PPUSH
108799: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108803: LD_VAR 0 8
108807: PPUSH
108808: LD_VAR 0 5
108812: PPUSH
108813: LD_VAR 0 6
108817: PPUSH
108818: LD_INT 1
108820: PPUSH
108821: CALL_OW 48
// end ;
108825: LD_VAR 0 7
108829: RET
// export hInvincible ; every 1 do
108830: GO 108832
108832: DISABLE
// hInvincible := [ ] ;
108833: LD_ADDR_EXP 181
108837: PUSH
108838: EMPTY
108839: ST_TO_ADDR
108840: END
// every 10 do var i ;
108841: GO 108843
108843: DISABLE
108844: LD_INT 0
108846: PPUSH
// begin enable ;
108847: ENABLE
// if not hInvincible then
108848: LD_EXP 181
108852: NOT
108853: IFFALSE 108857
// exit ;
108855: GO 108901
// for i in hInvincible do
108857: LD_ADDR_VAR 0 1
108861: PUSH
108862: LD_EXP 181
108866: PUSH
108867: FOR_IN
108868: IFFALSE 108899
// if GetLives ( i ) < 1000 then
108870: LD_VAR 0 1
108874: PPUSH
108875: CALL_OW 256
108879: PUSH
108880: LD_INT 1000
108882: LESS
108883: IFFALSE 108897
// SetLives ( i , 1000 ) ;
108885: LD_VAR 0 1
108889: PPUSH
108890: LD_INT 1000
108892: PPUSH
108893: CALL_OW 234
108897: GO 108867
108899: POP
108900: POP
// end ;
108901: PPOPN 1
108903: END
// export function hHackInvincible ; var i ; begin
108904: LD_INT 0
108906: PPUSH
108907: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108908: LD_ADDR_VAR 0 2
108912: PUSH
108913: LD_INT 2
108915: PUSH
108916: LD_INT 21
108918: PUSH
108919: LD_INT 1
108921: PUSH
108922: EMPTY
108923: LIST
108924: LIST
108925: PUSH
108926: LD_INT 21
108928: PUSH
108929: LD_INT 2
108931: PUSH
108932: EMPTY
108933: LIST
108934: LIST
108935: PUSH
108936: EMPTY
108937: LIST
108938: LIST
108939: LIST
108940: PPUSH
108941: CALL_OW 69
108945: PUSH
108946: FOR_IN
108947: IFFALSE 109008
// if IsSelected ( i ) then
108949: LD_VAR 0 2
108953: PPUSH
108954: CALL_OW 306
108958: IFFALSE 109006
// begin if i in hInvincible then
108960: LD_VAR 0 2
108964: PUSH
108965: LD_EXP 181
108969: IN
108970: IFFALSE 108990
// hInvincible := hInvincible diff i else
108972: LD_ADDR_EXP 181
108976: PUSH
108977: LD_EXP 181
108981: PUSH
108982: LD_VAR 0 2
108986: DIFF
108987: ST_TO_ADDR
108988: GO 109006
// hInvincible := hInvincible union i ;
108990: LD_ADDR_EXP 181
108994: PUSH
108995: LD_EXP 181
108999: PUSH
109000: LD_VAR 0 2
109004: UNION
109005: ST_TO_ADDR
// end ;
109006: GO 108946
109008: POP
109009: POP
// end ;
109010: LD_VAR 0 1
109014: RET
// export function hHackInvisible ; var i , j ; begin
109015: LD_INT 0
109017: PPUSH
109018: PPUSH
109019: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109020: LD_ADDR_VAR 0 2
109024: PUSH
109025: LD_INT 21
109027: PUSH
109028: LD_INT 1
109030: PUSH
109031: EMPTY
109032: LIST
109033: LIST
109034: PPUSH
109035: CALL_OW 69
109039: PUSH
109040: FOR_IN
109041: IFFALSE 109065
// if IsSelected ( i ) then
109043: LD_VAR 0 2
109047: PPUSH
109048: CALL_OW 306
109052: IFFALSE 109063
// ComForceInvisible ( i ) ;
109054: LD_VAR 0 2
109058: PPUSH
109059: CALL_OW 496
109063: GO 109040
109065: POP
109066: POP
// end ;
109067: LD_VAR 0 1
109071: RET
// export function hHackChangeYourSide ; begin
109072: LD_INT 0
109074: PPUSH
// if your_side = 8 then
109075: LD_OWVAR 2
109079: PUSH
109080: LD_INT 8
109082: EQUAL
109083: IFFALSE 109095
// your_side := 0 else
109085: LD_ADDR_OWVAR 2
109089: PUSH
109090: LD_INT 0
109092: ST_TO_ADDR
109093: GO 109109
// your_side := your_side + 1 ;
109095: LD_ADDR_OWVAR 2
109099: PUSH
109100: LD_OWVAR 2
109104: PUSH
109105: LD_INT 1
109107: PLUS
109108: ST_TO_ADDR
// end ;
109109: LD_VAR 0 1
109113: RET
// export function hHackChangeUnitSide ; var i , j ; begin
109114: LD_INT 0
109116: PPUSH
109117: PPUSH
109118: PPUSH
// for i in all_units do
109119: LD_ADDR_VAR 0 2
109123: PUSH
109124: LD_OWVAR 3
109128: PUSH
109129: FOR_IN
109130: IFFALSE 109208
// if IsSelected ( i ) then
109132: LD_VAR 0 2
109136: PPUSH
109137: CALL_OW 306
109141: IFFALSE 109206
// begin j := GetSide ( i ) ;
109143: LD_ADDR_VAR 0 3
109147: PUSH
109148: LD_VAR 0 2
109152: PPUSH
109153: CALL_OW 255
109157: ST_TO_ADDR
// if j = 8 then
109158: LD_VAR 0 3
109162: PUSH
109163: LD_INT 8
109165: EQUAL
109166: IFFALSE 109178
// j := 0 else
109168: LD_ADDR_VAR 0 3
109172: PUSH
109173: LD_INT 0
109175: ST_TO_ADDR
109176: GO 109192
// j := j + 1 ;
109178: LD_ADDR_VAR 0 3
109182: PUSH
109183: LD_VAR 0 3
109187: PUSH
109188: LD_INT 1
109190: PLUS
109191: ST_TO_ADDR
// SetSide ( i , j ) ;
109192: LD_VAR 0 2
109196: PPUSH
109197: LD_VAR 0 3
109201: PPUSH
109202: CALL_OW 235
// end ;
109206: GO 109129
109208: POP
109209: POP
// end ;
109210: LD_VAR 0 1
109214: RET
// export function hHackFog ; begin
109215: LD_INT 0
109217: PPUSH
// FogOff ( true ) ;
109218: LD_INT 1
109220: PPUSH
109221: CALL_OW 344
// end ;
109225: LD_VAR 0 1
109229: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109230: LD_INT 0
109232: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109233: LD_VAR 0 1
109237: PPUSH
109238: LD_VAR 0 2
109242: PPUSH
109243: LD_VAR 0 3
109247: PPUSH
109248: LD_INT 1
109250: PPUSH
109251: LD_INT 1
109253: PPUSH
109254: CALL_OW 483
// CenterOnXY ( x , y ) ;
109258: LD_VAR 0 2
109262: PPUSH
109263: LD_VAR 0 3
109267: PPUSH
109268: CALL_OW 84
// end ;
109272: LD_VAR 0 4
109276: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109277: LD_INT 0
109279: PPUSH
109280: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109281: LD_VAR 0 1
109285: NOT
109286: PUSH
109287: LD_VAR 0 2
109291: PPUSH
109292: LD_VAR 0 3
109296: PPUSH
109297: CALL_OW 488
109301: NOT
109302: OR
109303: PUSH
109304: LD_VAR 0 1
109308: PPUSH
109309: CALL_OW 266
109313: PUSH
109314: LD_INT 3
109316: NONEQUAL
109317: PUSH
109318: LD_VAR 0 1
109322: PPUSH
109323: CALL_OW 247
109327: PUSH
109328: LD_INT 1
109330: EQUAL
109331: NOT
109332: AND
109333: OR
109334: IFFALSE 109338
// exit ;
109336: GO 109487
// if GetType ( factory ) = unit_human then
109338: LD_VAR 0 1
109342: PPUSH
109343: CALL_OW 247
109347: PUSH
109348: LD_INT 1
109350: EQUAL
109351: IFFALSE 109368
// factory := IsInUnit ( factory ) ;
109353: LD_ADDR_VAR 0 1
109357: PUSH
109358: LD_VAR 0 1
109362: PPUSH
109363: CALL_OW 310
109367: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109368: LD_VAR 0 1
109372: PPUSH
109373: CALL_OW 266
109377: PUSH
109378: LD_INT 3
109380: NONEQUAL
109381: IFFALSE 109385
// exit ;
109383: GO 109487
// if HexInfo ( x , y ) = factory then
109385: LD_VAR 0 2
109389: PPUSH
109390: LD_VAR 0 3
109394: PPUSH
109395: CALL_OW 428
109399: PUSH
109400: LD_VAR 0 1
109404: EQUAL
109405: IFFALSE 109432
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109407: LD_ADDR_EXP 182
109411: PUSH
109412: LD_EXP 182
109416: PPUSH
109417: LD_VAR 0 1
109421: PPUSH
109422: LD_INT 0
109424: PPUSH
109425: CALL_OW 1
109429: ST_TO_ADDR
109430: GO 109483
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109432: LD_ADDR_EXP 182
109436: PUSH
109437: LD_EXP 182
109441: PPUSH
109442: LD_VAR 0 1
109446: PPUSH
109447: LD_VAR 0 1
109451: PPUSH
109452: CALL_OW 255
109456: PUSH
109457: LD_VAR 0 1
109461: PUSH
109462: LD_VAR 0 2
109466: PUSH
109467: LD_VAR 0 3
109471: PUSH
109472: EMPTY
109473: LIST
109474: LIST
109475: LIST
109476: LIST
109477: PPUSH
109478: CALL_OW 1
109482: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109483: CALL 109492 0 0
// end ;
109487: LD_VAR 0 4
109491: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109492: LD_INT 0
109494: PPUSH
109495: PPUSH
109496: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109497: LD_STRING resetFactoryWaypoint();
109499: PPUSH
109500: CALL_OW 559
// if factoryWaypoints then
109504: LD_EXP 182
109508: IFFALSE 109634
// begin list := PrepareArray ( factoryWaypoints ) ;
109510: LD_ADDR_VAR 0 3
109514: PUSH
109515: LD_EXP 182
109519: PPUSH
109520: CALL 94322 0 1
109524: ST_TO_ADDR
// for i := 1 to list do
109525: LD_ADDR_VAR 0 2
109529: PUSH
109530: DOUBLE
109531: LD_INT 1
109533: DEC
109534: ST_TO_ADDR
109535: LD_VAR 0 3
109539: PUSH
109540: FOR_TO
109541: IFFALSE 109632
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109543: LD_STRING setFactoryWaypointXY(
109545: PUSH
109546: LD_VAR 0 3
109550: PUSH
109551: LD_VAR 0 2
109555: ARRAY
109556: PUSH
109557: LD_INT 1
109559: ARRAY
109560: STR
109561: PUSH
109562: LD_STRING ,
109564: STR
109565: PUSH
109566: LD_VAR 0 3
109570: PUSH
109571: LD_VAR 0 2
109575: ARRAY
109576: PUSH
109577: LD_INT 2
109579: ARRAY
109580: STR
109581: PUSH
109582: LD_STRING ,
109584: STR
109585: PUSH
109586: LD_VAR 0 3
109590: PUSH
109591: LD_VAR 0 2
109595: ARRAY
109596: PUSH
109597: LD_INT 3
109599: ARRAY
109600: STR
109601: PUSH
109602: LD_STRING ,
109604: STR
109605: PUSH
109606: LD_VAR 0 3
109610: PUSH
109611: LD_VAR 0 2
109615: ARRAY
109616: PUSH
109617: LD_INT 4
109619: ARRAY
109620: STR
109621: PUSH
109622: LD_STRING )
109624: STR
109625: PPUSH
109626: CALL_OW 559
109630: GO 109540
109632: POP
109633: POP
// end ; end ;
109634: LD_VAR 0 1
109638: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109639: LD_INT 0
109641: PPUSH
// if HexInfo ( x , y ) = warehouse then
109642: LD_VAR 0 2
109646: PPUSH
109647: LD_VAR 0 3
109651: PPUSH
109652: CALL_OW 428
109656: PUSH
109657: LD_VAR 0 1
109661: EQUAL
109662: IFFALSE 109689
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109664: LD_ADDR_EXP 183
109668: PUSH
109669: LD_EXP 183
109673: PPUSH
109674: LD_VAR 0 1
109678: PPUSH
109679: LD_INT 0
109681: PPUSH
109682: CALL_OW 1
109686: ST_TO_ADDR
109687: GO 109740
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109689: LD_ADDR_EXP 183
109693: PUSH
109694: LD_EXP 183
109698: PPUSH
109699: LD_VAR 0 1
109703: PPUSH
109704: LD_VAR 0 1
109708: PPUSH
109709: CALL_OW 255
109713: PUSH
109714: LD_VAR 0 1
109718: PUSH
109719: LD_VAR 0 2
109723: PUSH
109724: LD_VAR 0 3
109728: PUSH
109729: EMPTY
109730: LIST
109731: LIST
109732: LIST
109733: LIST
109734: PPUSH
109735: CALL_OW 1
109739: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109740: CALL 109749 0 0
// end ;
109744: LD_VAR 0 4
109748: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109749: LD_INT 0
109751: PPUSH
109752: PPUSH
109753: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109754: LD_STRING resetWarehouseGatheringPoints();
109756: PPUSH
109757: CALL_OW 559
// if warehouseGatheringPoints then
109761: LD_EXP 183
109765: IFFALSE 109891
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109767: LD_ADDR_VAR 0 3
109771: PUSH
109772: LD_EXP 183
109776: PPUSH
109777: CALL 94322 0 1
109781: ST_TO_ADDR
// for i := 1 to list do
109782: LD_ADDR_VAR 0 2
109786: PUSH
109787: DOUBLE
109788: LD_INT 1
109790: DEC
109791: ST_TO_ADDR
109792: LD_VAR 0 3
109796: PUSH
109797: FOR_TO
109798: IFFALSE 109889
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109800: LD_STRING setWarehouseGatheringPointXY(
109802: PUSH
109803: LD_VAR 0 3
109807: PUSH
109808: LD_VAR 0 2
109812: ARRAY
109813: PUSH
109814: LD_INT 1
109816: ARRAY
109817: STR
109818: PUSH
109819: LD_STRING ,
109821: STR
109822: PUSH
109823: LD_VAR 0 3
109827: PUSH
109828: LD_VAR 0 2
109832: ARRAY
109833: PUSH
109834: LD_INT 2
109836: ARRAY
109837: STR
109838: PUSH
109839: LD_STRING ,
109841: STR
109842: PUSH
109843: LD_VAR 0 3
109847: PUSH
109848: LD_VAR 0 2
109852: ARRAY
109853: PUSH
109854: LD_INT 3
109856: ARRAY
109857: STR
109858: PUSH
109859: LD_STRING ,
109861: STR
109862: PUSH
109863: LD_VAR 0 3
109867: PUSH
109868: LD_VAR 0 2
109872: ARRAY
109873: PUSH
109874: LD_INT 4
109876: ARRAY
109877: STR
109878: PUSH
109879: LD_STRING )
109881: STR
109882: PPUSH
109883: CALL_OW 559
109887: GO 109797
109889: POP
109890: POP
// end ; end ;
109891: LD_VAR 0 1
109895: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109896: LD_EXP 183
109900: IFFALSE 110585
109902: GO 109904
109904: DISABLE
109905: LD_INT 0
109907: PPUSH
109908: PPUSH
109909: PPUSH
109910: PPUSH
109911: PPUSH
109912: PPUSH
109913: PPUSH
109914: PPUSH
109915: PPUSH
// begin enable ;
109916: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109917: LD_ADDR_VAR 0 3
109921: PUSH
109922: LD_EXP 183
109926: PPUSH
109927: CALL 94322 0 1
109931: ST_TO_ADDR
// if not list then
109932: LD_VAR 0 3
109936: NOT
109937: IFFALSE 109941
// exit ;
109939: GO 110585
// for i := 1 to list do
109941: LD_ADDR_VAR 0 1
109945: PUSH
109946: DOUBLE
109947: LD_INT 1
109949: DEC
109950: ST_TO_ADDR
109951: LD_VAR 0 3
109955: PUSH
109956: FOR_TO
109957: IFFALSE 110583
// begin depot := list [ i ] [ 2 ] ;
109959: LD_ADDR_VAR 0 8
109963: PUSH
109964: LD_VAR 0 3
109968: PUSH
109969: LD_VAR 0 1
109973: ARRAY
109974: PUSH
109975: LD_INT 2
109977: ARRAY
109978: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109979: LD_ADDR_VAR 0 5
109983: PUSH
109984: LD_VAR 0 3
109988: PUSH
109989: LD_VAR 0 1
109993: ARRAY
109994: PUSH
109995: LD_INT 1
109997: ARRAY
109998: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109999: LD_VAR 0 8
110003: PPUSH
110004: CALL_OW 301
110008: PUSH
110009: LD_VAR 0 5
110013: PUSH
110014: LD_VAR 0 8
110018: PPUSH
110019: CALL_OW 255
110023: NONEQUAL
110024: OR
110025: IFFALSE 110054
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
110027: LD_ADDR_EXP 183
110031: PUSH
110032: LD_EXP 183
110036: PPUSH
110037: LD_VAR 0 8
110041: PPUSH
110042: LD_INT 0
110044: PPUSH
110045: CALL_OW 1
110049: ST_TO_ADDR
// exit ;
110050: POP
110051: POP
110052: GO 110585
// end ; x := list [ i ] [ 3 ] ;
110054: LD_ADDR_VAR 0 6
110058: PUSH
110059: LD_VAR 0 3
110063: PUSH
110064: LD_VAR 0 1
110068: ARRAY
110069: PUSH
110070: LD_INT 3
110072: ARRAY
110073: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
110074: LD_ADDR_VAR 0 7
110078: PUSH
110079: LD_VAR 0 3
110083: PUSH
110084: LD_VAR 0 1
110088: ARRAY
110089: PUSH
110090: LD_INT 4
110092: ARRAY
110093: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
110094: LD_ADDR_VAR 0 9
110098: PUSH
110099: LD_VAR 0 6
110103: PPUSH
110104: LD_VAR 0 7
110108: PPUSH
110109: LD_INT 16
110111: PPUSH
110112: CALL 92910 0 3
110116: ST_TO_ADDR
// if not cratesNearbyPoint then
110117: LD_VAR 0 9
110121: NOT
110122: IFFALSE 110128
// exit ;
110124: POP
110125: POP
110126: GO 110585
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
110128: LD_ADDR_VAR 0 4
110132: PUSH
110133: LD_INT 22
110135: PUSH
110136: LD_VAR 0 5
110140: PUSH
110141: EMPTY
110142: LIST
110143: LIST
110144: PUSH
110145: LD_INT 3
110147: PUSH
110148: LD_INT 60
110150: PUSH
110151: EMPTY
110152: LIST
110153: PUSH
110154: EMPTY
110155: LIST
110156: LIST
110157: PUSH
110158: LD_INT 91
110160: PUSH
110161: LD_VAR 0 8
110165: PUSH
110166: LD_INT 6
110168: PUSH
110169: EMPTY
110170: LIST
110171: LIST
110172: LIST
110173: PUSH
110174: LD_INT 2
110176: PUSH
110177: LD_INT 25
110179: PUSH
110180: LD_INT 2
110182: PUSH
110183: EMPTY
110184: LIST
110185: LIST
110186: PUSH
110187: LD_INT 25
110189: PUSH
110190: LD_INT 16
110192: PUSH
110193: EMPTY
110194: LIST
110195: LIST
110196: PUSH
110197: EMPTY
110198: LIST
110199: LIST
110200: LIST
110201: PUSH
110202: EMPTY
110203: LIST
110204: LIST
110205: LIST
110206: LIST
110207: PPUSH
110208: CALL_OW 69
110212: PUSH
110213: LD_VAR 0 8
110217: PPUSH
110218: CALL_OW 313
110222: PPUSH
110223: LD_INT 3
110225: PUSH
110226: LD_INT 60
110228: PUSH
110229: EMPTY
110230: LIST
110231: PUSH
110232: EMPTY
110233: LIST
110234: LIST
110235: PUSH
110236: LD_INT 2
110238: PUSH
110239: LD_INT 25
110241: PUSH
110242: LD_INT 2
110244: PUSH
110245: EMPTY
110246: LIST
110247: LIST
110248: PUSH
110249: LD_INT 25
110251: PUSH
110252: LD_INT 16
110254: PUSH
110255: EMPTY
110256: LIST
110257: LIST
110258: PUSH
110259: EMPTY
110260: LIST
110261: LIST
110262: LIST
110263: PUSH
110264: EMPTY
110265: LIST
110266: LIST
110267: PPUSH
110268: CALL_OW 72
110272: UNION
110273: ST_TO_ADDR
// if tmp then
110274: LD_VAR 0 4
110278: IFFALSE 110358
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110280: LD_ADDR_VAR 0 4
110284: PUSH
110285: LD_VAR 0 4
110289: PPUSH
110290: LD_INT 3
110292: PPUSH
110293: CALL 90879 0 2
110297: ST_TO_ADDR
// for j in tmp do
110298: LD_ADDR_VAR 0 2
110302: PUSH
110303: LD_VAR 0 4
110307: PUSH
110308: FOR_IN
110309: IFFALSE 110352
// begin if IsInUnit ( j ) then
110311: LD_VAR 0 2
110315: PPUSH
110316: CALL_OW 310
110320: IFFALSE 110331
// ComExit ( j ) ;
110322: LD_VAR 0 2
110326: PPUSH
110327: CALL 90962 0 1
// AddComCollect ( j , x , y ) ;
110331: LD_VAR 0 2
110335: PPUSH
110336: LD_VAR 0 6
110340: PPUSH
110341: LD_VAR 0 7
110345: PPUSH
110346: CALL_OW 177
// end ;
110350: GO 110308
110352: POP
110353: POP
// exit ;
110354: POP
110355: POP
110356: GO 110585
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110358: LD_ADDR_VAR 0 4
110362: PUSH
110363: LD_INT 22
110365: PUSH
110366: LD_VAR 0 5
110370: PUSH
110371: EMPTY
110372: LIST
110373: LIST
110374: PUSH
110375: LD_INT 91
110377: PUSH
110378: LD_VAR 0 8
110382: PUSH
110383: LD_INT 8
110385: PUSH
110386: EMPTY
110387: LIST
110388: LIST
110389: LIST
110390: PUSH
110391: LD_INT 2
110393: PUSH
110394: LD_INT 34
110396: PUSH
110397: LD_INT 12
110399: PUSH
110400: EMPTY
110401: LIST
110402: LIST
110403: PUSH
110404: LD_INT 34
110406: PUSH
110407: LD_INT 51
110409: PUSH
110410: EMPTY
110411: LIST
110412: LIST
110413: PUSH
110414: LD_INT 34
110416: PUSH
110417: LD_INT 32
110419: PUSH
110420: EMPTY
110421: LIST
110422: LIST
110423: PUSH
110424: LD_INT 34
110426: PUSH
110427: LD_INT 89
110429: PUSH
110430: EMPTY
110431: LIST
110432: LIST
110433: PUSH
110434: EMPTY
110435: LIST
110436: LIST
110437: LIST
110438: LIST
110439: LIST
110440: PUSH
110441: EMPTY
110442: LIST
110443: LIST
110444: LIST
110445: PPUSH
110446: CALL_OW 69
110450: ST_TO_ADDR
// if tmp then
110451: LD_VAR 0 4
110455: IFFALSE 110581
// begin for j in tmp do
110457: LD_ADDR_VAR 0 2
110461: PUSH
110462: LD_VAR 0 4
110466: PUSH
110467: FOR_IN
110468: IFFALSE 110579
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110470: LD_VAR 0 2
110474: PPUSH
110475: CALL_OW 262
110479: PUSH
110480: LD_INT 3
110482: EQUAL
110483: PUSH
110484: LD_VAR 0 2
110488: PPUSH
110489: CALL_OW 261
110493: PUSH
110494: LD_INT 20
110496: GREATER
110497: OR
110498: PUSH
110499: LD_VAR 0 2
110503: PPUSH
110504: CALL_OW 314
110508: NOT
110509: AND
110510: PUSH
110511: LD_VAR 0 2
110515: PPUSH
110516: CALL_OW 263
110520: PUSH
110521: LD_INT 1
110523: NONEQUAL
110524: PUSH
110525: LD_VAR 0 2
110529: PPUSH
110530: CALL_OW 311
110534: OR
110535: AND
110536: IFFALSE 110577
// begin ComCollect ( j , x , y ) ;
110538: LD_VAR 0 2
110542: PPUSH
110543: LD_VAR 0 6
110547: PPUSH
110548: LD_VAR 0 7
110552: PPUSH
110553: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110557: LD_VAR 0 2
110561: PPUSH
110562: LD_VAR 0 8
110566: PPUSH
110567: CALL_OW 172
// exit ;
110571: POP
110572: POP
110573: POP
110574: POP
110575: GO 110585
// end ;
110577: GO 110467
110579: POP
110580: POP
// end ; end ;
110581: GO 109956
110583: POP
110584: POP
// end ; end_of_file
110585: PPOPN 9
110587: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
110588: LD_INT 0
110590: PPUSH
110591: PPUSH
110592: PPUSH
110593: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
110594: LD_VAR 0 1
110598: PPUSH
110599: CALL_OW 264
110603: PUSH
110604: LD_INT 91
110606: EQUAL
110607: IFFALSE 110679
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
110609: LD_INT 68
110611: PPUSH
110612: LD_VAR 0 1
110616: PPUSH
110617: CALL_OW 255
110621: PPUSH
110622: CALL_OW 321
110626: PUSH
110627: LD_INT 2
110629: EQUAL
110630: IFFALSE 110642
// eff := 70 else
110632: LD_ADDR_VAR 0 4
110636: PUSH
110637: LD_INT 70
110639: ST_TO_ADDR
110640: GO 110650
// eff := 30 ;
110642: LD_ADDR_VAR 0 4
110646: PUSH
110647: LD_INT 30
110649: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
110650: LD_VAR 0 1
110654: PPUSH
110655: CALL_OW 250
110659: PPUSH
110660: LD_VAR 0 1
110664: PPUSH
110665: CALL_OW 251
110669: PPUSH
110670: LD_VAR 0 4
110674: PPUSH
110675: CALL_OW 495
// end ; end ;
110679: LD_VAR 0 2
110683: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
110684: LD_INT 0
110686: PPUSH
// end ;
110687: LD_VAR 0 4
110691: RET
// export function SOS_Command ( cmd ) ; begin
110692: LD_INT 0
110694: PPUSH
// end ;
110695: LD_VAR 0 2
110699: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
110700: LD_INT 0
110702: PPUSH
// end ;
110703: LD_VAR 0 6
110707: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
110708: LD_INT 0
110710: PPUSH
110711: PPUSH
// if not vehicle or not factory then
110712: LD_VAR 0 1
110716: NOT
110717: PUSH
110718: LD_VAR 0 2
110722: NOT
110723: OR
110724: IFFALSE 110728
// exit ;
110726: GO 110959
// if factoryWaypoints >= factory then
110728: LD_EXP 182
110732: PUSH
110733: LD_VAR 0 2
110737: GREATEREQUAL
110738: IFFALSE 110959
// if factoryWaypoints [ factory ] then
110740: LD_EXP 182
110744: PUSH
110745: LD_VAR 0 2
110749: ARRAY
110750: IFFALSE 110959
// begin if GetControl ( vehicle ) = control_manual then
110752: LD_VAR 0 1
110756: PPUSH
110757: CALL_OW 263
110761: PUSH
110762: LD_INT 1
110764: EQUAL
110765: IFFALSE 110846
// begin driver := IsDrivenBy ( vehicle ) ;
110767: LD_ADDR_VAR 0 4
110771: PUSH
110772: LD_VAR 0 1
110776: PPUSH
110777: CALL_OW 311
110781: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110782: LD_VAR 0 4
110786: PPUSH
110787: LD_EXP 182
110791: PUSH
110792: LD_VAR 0 2
110796: ARRAY
110797: PUSH
110798: LD_INT 3
110800: ARRAY
110801: PPUSH
110802: LD_EXP 182
110806: PUSH
110807: LD_VAR 0 2
110811: ARRAY
110812: PUSH
110813: LD_INT 4
110815: ARRAY
110816: PPUSH
110817: CALL_OW 171
// AddComExitVehicle ( driver ) ;
110821: LD_VAR 0 4
110825: PPUSH
110826: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
110830: LD_VAR 0 4
110834: PPUSH
110835: LD_VAR 0 2
110839: PPUSH
110840: CALL_OW 180
// end else
110844: GO 110959
// if GetControl ( vehicle ) = control_remote then
110846: LD_VAR 0 1
110850: PPUSH
110851: CALL_OW 263
110855: PUSH
110856: LD_INT 2
110858: EQUAL
110859: IFFALSE 110920
// begin wait ( 0 0$2 ) ;
110861: LD_INT 70
110863: PPUSH
110864: CALL_OW 67
// if Connect ( vehicle ) then
110868: LD_VAR 0 1
110872: PPUSH
110873: CALL 61170 0 1
110877: IFFALSE 110918
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110879: LD_VAR 0 1
110883: PPUSH
110884: LD_EXP 182
110888: PUSH
110889: LD_VAR 0 2
110893: ARRAY
110894: PUSH
110895: LD_INT 3
110897: ARRAY
110898: PPUSH
110899: LD_EXP 182
110903: PUSH
110904: LD_VAR 0 2
110908: ARRAY
110909: PUSH
110910: LD_INT 4
110912: ARRAY
110913: PPUSH
110914: CALL_OW 171
// end else
110918: GO 110959
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110920: LD_VAR 0 1
110924: PPUSH
110925: LD_EXP 182
110929: PUSH
110930: LD_VAR 0 2
110934: ARRAY
110935: PUSH
110936: LD_INT 3
110938: ARRAY
110939: PPUSH
110940: LD_EXP 182
110944: PUSH
110945: LD_VAR 0 2
110949: ARRAY
110950: PUSH
110951: LD_INT 4
110953: ARRAY
110954: PPUSH
110955: CALL_OW 171
// end ; end ;
110959: LD_VAR 0 3
110963: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
110964: LD_INT 0
110966: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
110967: LD_VAR 0 1
110971: PUSH
110972: LD_INT 250
110974: EQUAL
110975: PUSH
110976: LD_VAR 0 2
110980: PPUSH
110981: CALL_OW 264
110985: PUSH
110986: LD_INT 81
110988: EQUAL
110989: AND
110990: IFFALSE 111011
// MinerPlaceMine ( unit , x , y ) ;
110992: LD_VAR 0 2
110996: PPUSH
110997: LD_VAR 0 4
111001: PPUSH
111002: LD_VAR 0 5
111006: PPUSH
111007: CALL 113835 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
111011: LD_VAR 0 1
111015: PUSH
111016: LD_INT 251
111018: EQUAL
111019: PUSH
111020: LD_VAR 0 2
111024: PPUSH
111025: CALL_OW 264
111029: PUSH
111030: LD_INT 81
111032: EQUAL
111033: AND
111034: IFFALSE 111055
// MinerDetonateMine ( unit , x , y ) ;
111036: LD_VAR 0 2
111040: PPUSH
111041: LD_VAR 0 4
111045: PPUSH
111046: LD_VAR 0 5
111050: PPUSH
111051: CALL 114110 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
111055: LD_VAR 0 1
111059: PUSH
111060: LD_INT 252
111062: EQUAL
111063: PUSH
111064: LD_VAR 0 2
111068: PPUSH
111069: CALL_OW 264
111073: PUSH
111074: LD_INT 81
111076: EQUAL
111077: AND
111078: IFFALSE 111099
// MinerCreateMinefield ( unit , x , y ) ;
111080: LD_VAR 0 2
111084: PPUSH
111085: LD_VAR 0 4
111089: PPUSH
111090: LD_VAR 0 5
111094: PPUSH
111095: CALL 114527 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
111099: LD_VAR 0 1
111103: PUSH
111104: LD_INT 253
111106: EQUAL
111107: PUSH
111108: LD_VAR 0 2
111112: PPUSH
111113: CALL_OW 257
111117: PUSH
111118: LD_INT 5
111120: EQUAL
111121: AND
111122: IFFALSE 111143
// ComBinocular ( unit , x , y ) ;
111124: LD_VAR 0 2
111128: PPUSH
111129: LD_VAR 0 4
111133: PPUSH
111134: LD_VAR 0 5
111138: PPUSH
111139: CALL 114896 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
111143: LD_VAR 0 1
111147: PUSH
111148: LD_INT 254
111150: EQUAL
111151: PUSH
111152: LD_VAR 0 2
111156: PPUSH
111157: CALL_OW 264
111161: PUSH
111162: LD_INT 99
111164: EQUAL
111165: AND
111166: PUSH
111167: LD_VAR 0 3
111171: PPUSH
111172: CALL_OW 263
111176: PUSH
111177: LD_INT 3
111179: EQUAL
111180: AND
111181: IFFALSE 111197
// HackDestroyVehicle ( unit , selectedUnit ) ;
111183: LD_VAR 0 2
111187: PPUSH
111188: LD_VAR 0 3
111192: PPUSH
111193: CALL 113199 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
111197: LD_VAR 0 1
111201: PUSH
111202: LD_INT 255
111204: EQUAL
111205: PUSH
111206: LD_VAR 0 2
111210: PPUSH
111211: CALL_OW 264
111215: PUSH
111216: LD_INT 14
111218: PUSH
111219: LD_INT 53
111221: PUSH
111222: EMPTY
111223: LIST
111224: LIST
111225: IN
111226: AND
111227: PUSH
111228: LD_VAR 0 4
111232: PPUSH
111233: LD_VAR 0 5
111237: PPUSH
111238: CALL_OW 488
111242: AND
111243: IFFALSE 111267
// CutTreeXYR ( unit , x , y , 12 ) ;
111245: LD_VAR 0 2
111249: PPUSH
111250: LD_VAR 0 4
111254: PPUSH
111255: LD_VAR 0 5
111259: PPUSH
111260: LD_INT 12
111262: PPUSH
111263: CALL 111362 0 4
// if cmd = 256 then
111267: LD_VAR 0 1
111271: PUSH
111272: LD_INT 256
111274: EQUAL
111275: IFFALSE 111296
// SetFactoryWaypoint ( unit , x , y ) ;
111277: LD_VAR 0 2
111281: PPUSH
111282: LD_VAR 0 4
111286: PPUSH
111287: LD_VAR 0 5
111291: PPUSH
111292: CALL 109277 0 3
// if cmd = 257 then
111296: LD_VAR 0 1
111300: PUSH
111301: LD_INT 257
111303: EQUAL
111304: IFFALSE 111325
// SetWarehouseGatheringPoint ( unit , x , y ) ;
111306: LD_VAR 0 2
111310: PPUSH
111311: LD_VAR 0 4
111315: PPUSH
111316: LD_VAR 0 5
111320: PPUSH
111321: CALL 109639 0 3
// if cmd = 258 then
111325: LD_VAR 0 1
111329: PUSH
111330: LD_INT 258
111332: EQUAL
111333: IFFALSE 111357
// BurnTreeXYR ( unit , x , y , 8 ) ;
111335: LD_VAR 0 2
111339: PPUSH
111340: LD_VAR 0 4
111344: PPUSH
111345: LD_VAR 0 5
111349: PPUSH
111350: LD_INT 8
111352: PPUSH
111353: CALL 111756 0 4
// end ;
111357: LD_VAR 0 6
111361: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
111362: LD_INT 0
111364: PPUSH
111365: PPUSH
111366: PPUSH
111367: PPUSH
111368: PPUSH
111369: PPUSH
111370: PPUSH
111371: PPUSH
111372: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
111373: LD_VAR 0 1
111377: PPUSH
111378: CALL_OW 302
111382: NOT
111383: PUSH
111384: LD_VAR 0 2
111388: PPUSH
111389: LD_VAR 0 3
111393: PPUSH
111394: CALL_OW 488
111398: NOT
111399: OR
111400: PUSH
111401: LD_VAR 0 4
111405: NOT
111406: OR
111407: IFFALSE 111411
// exit ;
111409: GO 111751
// list := [ ] ;
111411: LD_ADDR_VAR 0 13
111415: PUSH
111416: EMPTY
111417: ST_TO_ADDR
// if x - r < 0 then
111418: LD_VAR 0 2
111422: PUSH
111423: LD_VAR 0 4
111427: MINUS
111428: PUSH
111429: LD_INT 0
111431: LESS
111432: IFFALSE 111444
// min_x := 0 else
111434: LD_ADDR_VAR 0 7
111438: PUSH
111439: LD_INT 0
111441: ST_TO_ADDR
111442: GO 111460
// min_x := x - r ;
111444: LD_ADDR_VAR 0 7
111448: PUSH
111449: LD_VAR 0 2
111453: PUSH
111454: LD_VAR 0 4
111458: MINUS
111459: ST_TO_ADDR
// if y - r < 0 then
111460: LD_VAR 0 3
111464: PUSH
111465: LD_VAR 0 4
111469: MINUS
111470: PUSH
111471: LD_INT 0
111473: LESS
111474: IFFALSE 111486
// min_y := 0 else
111476: LD_ADDR_VAR 0 8
111480: PUSH
111481: LD_INT 0
111483: ST_TO_ADDR
111484: GO 111502
// min_y := y - r ;
111486: LD_ADDR_VAR 0 8
111490: PUSH
111491: LD_VAR 0 3
111495: PUSH
111496: LD_VAR 0 4
111500: MINUS
111501: ST_TO_ADDR
// max_x := x + r ;
111502: LD_ADDR_VAR 0 9
111506: PUSH
111507: LD_VAR 0 2
111511: PUSH
111512: LD_VAR 0 4
111516: PLUS
111517: ST_TO_ADDR
// max_y := y + r ;
111518: LD_ADDR_VAR 0 10
111522: PUSH
111523: LD_VAR 0 3
111527: PUSH
111528: LD_VAR 0 4
111532: PLUS
111533: ST_TO_ADDR
// for _x = min_x to max_x do
111534: LD_ADDR_VAR 0 11
111538: PUSH
111539: DOUBLE
111540: LD_VAR 0 7
111544: DEC
111545: ST_TO_ADDR
111546: LD_VAR 0 9
111550: PUSH
111551: FOR_TO
111552: IFFALSE 111669
// for _y = min_y to max_y do
111554: LD_ADDR_VAR 0 12
111558: PUSH
111559: DOUBLE
111560: LD_VAR 0 8
111564: DEC
111565: ST_TO_ADDR
111566: LD_VAR 0 10
111570: PUSH
111571: FOR_TO
111572: IFFALSE 111665
// begin if not ValidHex ( _x , _y ) then
111574: LD_VAR 0 11
111578: PPUSH
111579: LD_VAR 0 12
111583: PPUSH
111584: CALL_OW 488
111588: NOT
111589: IFFALSE 111593
// continue ;
111591: GO 111571
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
111593: LD_VAR 0 11
111597: PPUSH
111598: LD_VAR 0 12
111602: PPUSH
111603: CALL_OW 351
111607: PUSH
111608: LD_VAR 0 11
111612: PPUSH
111613: LD_VAR 0 12
111617: PPUSH
111618: CALL_OW 554
111622: AND
111623: IFFALSE 111663
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
111625: LD_ADDR_VAR 0 13
111629: PUSH
111630: LD_VAR 0 13
111634: PPUSH
111635: LD_VAR 0 13
111639: PUSH
111640: LD_INT 1
111642: PLUS
111643: PPUSH
111644: LD_VAR 0 11
111648: PUSH
111649: LD_VAR 0 12
111653: PUSH
111654: EMPTY
111655: LIST
111656: LIST
111657: PPUSH
111658: CALL_OW 2
111662: ST_TO_ADDR
// end ;
111663: GO 111571
111665: POP
111666: POP
111667: GO 111551
111669: POP
111670: POP
// if not list then
111671: LD_VAR 0 13
111675: NOT
111676: IFFALSE 111680
// exit ;
111678: GO 111751
// for i in list do
111680: LD_ADDR_VAR 0 6
111684: PUSH
111685: LD_VAR 0 13
111689: PUSH
111690: FOR_IN
111691: IFFALSE 111749
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
111693: LD_VAR 0 1
111697: PPUSH
111698: LD_STRING M
111700: PUSH
111701: LD_VAR 0 6
111705: PUSH
111706: LD_INT 1
111708: ARRAY
111709: PUSH
111710: LD_VAR 0 6
111714: PUSH
111715: LD_INT 2
111717: ARRAY
111718: PUSH
111719: LD_INT 0
111721: PUSH
111722: LD_INT 0
111724: PUSH
111725: LD_INT 0
111727: PUSH
111728: LD_INT 0
111730: PUSH
111731: EMPTY
111732: LIST
111733: LIST
111734: LIST
111735: LIST
111736: LIST
111737: LIST
111738: LIST
111739: PUSH
111740: EMPTY
111741: LIST
111742: PPUSH
111743: CALL_OW 447
111747: GO 111690
111749: POP
111750: POP
// end ;
111751: LD_VAR 0 5
111755: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
111756: LD_INT 0
111758: PPUSH
111759: PPUSH
111760: PPUSH
111761: PPUSH
111762: PPUSH
111763: PPUSH
111764: PPUSH
111765: PPUSH
111766: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
111767: LD_VAR 0 1
111771: PPUSH
111772: CALL_OW 302
111776: NOT
111777: PUSH
111778: LD_VAR 0 2
111782: PPUSH
111783: LD_VAR 0 3
111787: PPUSH
111788: CALL_OW 488
111792: NOT
111793: OR
111794: PUSH
111795: LD_VAR 0 4
111799: NOT
111800: OR
111801: IFFALSE 111805
// exit ;
111803: GO 112153
// list := [ ] ;
111805: LD_ADDR_VAR 0 13
111809: PUSH
111810: EMPTY
111811: ST_TO_ADDR
// if x - r < 0 then
111812: LD_VAR 0 2
111816: PUSH
111817: LD_VAR 0 4
111821: MINUS
111822: PUSH
111823: LD_INT 0
111825: LESS
111826: IFFALSE 111838
// min_x := 0 else
111828: LD_ADDR_VAR 0 7
111832: PUSH
111833: LD_INT 0
111835: ST_TO_ADDR
111836: GO 111854
// min_x := x - r ;
111838: LD_ADDR_VAR 0 7
111842: PUSH
111843: LD_VAR 0 2
111847: PUSH
111848: LD_VAR 0 4
111852: MINUS
111853: ST_TO_ADDR
// if y - r < 0 then
111854: LD_VAR 0 3
111858: PUSH
111859: LD_VAR 0 4
111863: MINUS
111864: PUSH
111865: LD_INT 0
111867: LESS
111868: IFFALSE 111880
// min_y := 0 else
111870: LD_ADDR_VAR 0 8
111874: PUSH
111875: LD_INT 0
111877: ST_TO_ADDR
111878: GO 111896
// min_y := y - r ;
111880: LD_ADDR_VAR 0 8
111884: PUSH
111885: LD_VAR 0 3
111889: PUSH
111890: LD_VAR 0 4
111894: MINUS
111895: ST_TO_ADDR
// max_x := x + r ;
111896: LD_ADDR_VAR 0 9
111900: PUSH
111901: LD_VAR 0 2
111905: PUSH
111906: LD_VAR 0 4
111910: PLUS
111911: ST_TO_ADDR
// max_y := y + r ;
111912: LD_ADDR_VAR 0 10
111916: PUSH
111917: LD_VAR 0 3
111921: PUSH
111922: LD_VAR 0 4
111926: PLUS
111927: ST_TO_ADDR
// for _x = min_x to max_x do
111928: LD_ADDR_VAR 0 11
111932: PUSH
111933: DOUBLE
111934: LD_VAR 0 7
111938: DEC
111939: ST_TO_ADDR
111940: LD_VAR 0 9
111944: PUSH
111945: FOR_TO
111946: IFFALSE 112063
// for _y = min_y to max_y do
111948: LD_ADDR_VAR 0 12
111952: PUSH
111953: DOUBLE
111954: LD_VAR 0 8
111958: DEC
111959: ST_TO_ADDR
111960: LD_VAR 0 10
111964: PUSH
111965: FOR_TO
111966: IFFALSE 112059
// begin if not ValidHex ( _x , _y ) then
111968: LD_VAR 0 11
111972: PPUSH
111973: LD_VAR 0 12
111977: PPUSH
111978: CALL_OW 488
111982: NOT
111983: IFFALSE 111987
// continue ;
111985: GO 111965
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
111987: LD_VAR 0 11
111991: PPUSH
111992: LD_VAR 0 12
111996: PPUSH
111997: CALL_OW 351
112001: PUSH
112002: LD_VAR 0 11
112006: PPUSH
112007: LD_VAR 0 12
112011: PPUSH
112012: CALL_OW 554
112016: AND
112017: IFFALSE 112057
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112019: LD_ADDR_VAR 0 13
112023: PUSH
112024: LD_VAR 0 13
112028: PPUSH
112029: LD_VAR 0 13
112033: PUSH
112034: LD_INT 1
112036: PLUS
112037: PPUSH
112038: LD_VAR 0 11
112042: PUSH
112043: LD_VAR 0 12
112047: PUSH
112048: EMPTY
112049: LIST
112050: LIST
112051: PPUSH
112052: CALL_OW 2
112056: ST_TO_ADDR
// end ;
112057: GO 111965
112059: POP
112060: POP
112061: GO 111945
112063: POP
112064: POP
// if not list then
112065: LD_VAR 0 13
112069: NOT
112070: IFFALSE 112074
// exit ;
112072: GO 112153
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
112074: LD_ADDR_VAR 0 13
112078: PUSH
112079: LD_VAR 0 1
112083: PPUSH
112084: LD_VAR 0 13
112088: PPUSH
112089: LD_INT 1
112091: PPUSH
112092: LD_INT 1
112094: PPUSH
112095: CALL 58312 0 4
112099: ST_TO_ADDR
// ComStop ( flame ) ;
112100: LD_VAR 0 1
112104: PPUSH
112105: CALL_OW 141
// for i in list do
112109: LD_ADDR_VAR 0 6
112113: PUSH
112114: LD_VAR 0 13
112118: PUSH
112119: FOR_IN
112120: IFFALSE 112151
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
112122: LD_VAR 0 1
112126: PPUSH
112127: LD_VAR 0 6
112131: PUSH
112132: LD_INT 1
112134: ARRAY
112135: PPUSH
112136: LD_VAR 0 6
112140: PUSH
112141: LD_INT 2
112143: ARRAY
112144: PPUSH
112145: CALL_OW 176
112149: GO 112119
112151: POP
112152: POP
// end ;
112153: LD_VAR 0 5
112157: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
112158: LD_EXP 185
112162: NOT
112163: IFFALSE 112213
112165: GO 112167
112167: DISABLE
// begin initHack := true ;
112168: LD_ADDR_EXP 185
112172: PUSH
112173: LD_INT 1
112175: ST_TO_ADDR
// hackTanks := [ ] ;
112176: LD_ADDR_EXP 186
112180: PUSH
112181: EMPTY
112182: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
112183: LD_ADDR_EXP 187
112187: PUSH
112188: EMPTY
112189: ST_TO_ADDR
// hackLimit := 3 ;
112190: LD_ADDR_EXP 188
112194: PUSH
112195: LD_INT 3
112197: ST_TO_ADDR
// hackDist := 12 ;
112198: LD_ADDR_EXP 189
112202: PUSH
112203: LD_INT 12
112205: ST_TO_ADDR
// hackCounter := [ ] ;
112206: LD_ADDR_EXP 190
112210: PUSH
112211: EMPTY
112212: ST_TO_ADDR
// end ;
112213: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
112214: LD_EXP 185
112218: PUSH
112219: LD_INT 34
112221: PUSH
112222: LD_INT 99
112224: PUSH
112225: EMPTY
112226: LIST
112227: LIST
112228: PPUSH
112229: CALL_OW 69
112233: AND
112234: IFFALSE 112487
112236: GO 112238
112238: DISABLE
112239: LD_INT 0
112241: PPUSH
112242: PPUSH
// begin enable ;
112243: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
112244: LD_ADDR_VAR 0 1
112248: PUSH
112249: LD_INT 34
112251: PUSH
112252: LD_INT 99
112254: PUSH
112255: EMPTY
112256: LIST
112257: LIST
112258: PPUSH
112259: CALL_OW 69
112263: PUSH
112264: FOR_IN
112265: IFFALSE 112485
// begin if not i in hackTanks then
112267: LD_VAR 0 1
112271: PUSH
112272: LD_EXP 186
112276: IN
112277: NOT
112278: IFFALSE 112361
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
112280: LD_ADDR_EXP 186
112284: PUSH
112285: LD_EXP 186
112289: PPUSH
112290: LD_EXP 186
112294: PUSH
112295: LD_INT 1
112297: PLUS
112298: PPUSH
112299: LD_VAR 0 1
112303: PPUSH
112304: CALL_OW 1
112308: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
112309: LD_ADDR_EXP 187
112313: PUSH
112314: LD_EXP 187
112318: PPUSH
112319: LD_EXP 187
112323: PUSH
112324: LD_INT 1
112326: PLUS
112327: PPUSH
112328: EMPTY
112329: PPUSH
112330: CALL_OW 1
112334: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
112335: LD_ADDR_EXP 190
112339: PUSH
112340: LD_EXP 190
112344: PPUSH
112345: LD_EXP 190
112349: PUSH
112350: LD_INT 1
112352: PLUS
112353: PPUSH
112354: EMPTY
112355: PPUSH
112356: CALL_OW 1
112360: ST_TO_ADDR
// end ; if not IsOk ( i ) then
112361: LD_VAR 0 1
112365: PPUSH
112366: CALL_OW 302
112370: NOT
112371: IFFALSE 112384
// begin HackUnlinkAll ( i ) ;
112373: LD_VAR 0 1
112377: PPUSH
112378: CALL 112490 0 1
// continue ;
112382: GO 112264
// end ; HackCheckCapturedStatus ( i ) ;
112384: LD_VAR 0 1
112388: PPUSH
112389: CALL 112933 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
112393: LD_ADDR_VAR 0 2
112397: PUSH
112398: LD_INT 81
112400: PUSH
112401: LD_VAR 0 1
112405: PPUSH
112406: CALL_OW 255
112410: PUSH
112411: EMPTY
112412: LIST
112413: LIST
112414: PUSH
112415: LD_INT 33
112417: PUSH
112418: LD_INT 3
112420: PUSH
112421: EMPTY
112422: LIST
112423: LIST
112424: PUSH
112425: LD_INT 91
112427: PUSH
112428: LD_VAR 0 1
112432: PUSH
112433: LD_EXP 189
112437: PUSH
112438: EMPTY
112439: LIST
112440: LIST
112441: LIST
112442: PUSH
112443: LD_INT 50
112445: PUSH
112446: EMPTY
112447: LIST
112448: PUSH
112449: EMPTY
112450: LIST
112451: LIST
112452: LIST
112453: LIST
112454: PPUSH
112455: CALL_OW 69
112459: ST_TO_ADDR
// if not tmp then
112460: LD_VAR 0 2
112464: NOT
112465: IFFALSE 112469
// continue ;
112467: GO 112264
// HackLink ( i , tmp ) ;
112469: LD_VAR 0 1
112473: PPUSH
112474: LD_VAR 0 2
112478: PPUSH
112479: CALL 112626 0 2
// end ;
112483: GO 112264
112485: POP
112486: POP
// end ;
112487: PPOPN 2
112489: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
112490: LD_INT 0
112492: PPUSH
112493: PPUSH
112494: PPUSH
// if not hack in hackTanks then
112495: LD_VAR 0 1
112499: PUSH
112500: LD_EXP 186
112504: IN
112505: NOT
112506: IFFALSE 112510
// exit ;
112508: GO 112621
// index := GetElementIndex ( hackTanks , hack ) ;
112510: LD_ADDR_VAR 0 4
112514: PUSH
112515: LD_EXP 186
112519: PPUSH
112520: LD_VAR 0 1
112524: PPUSH
112525: CALL 57609 0 2
112529: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
112530: LD_EXP 187
112534: PUSH
112535: LD_VAR 0 4
112539: ARRAY
112540: IFFALSE 112621
// begin for i in hackTanksCaptured [ index ] do
112542: LD_ADDR_VAR 0 3
112546: PUSH
112547: LD_EXP 187
112551: PUSH
112552: LD_VAR 0 4
112556: ARRAY
112557: PUSH
112558: FOR_IN
112559: IFFALSE 112585
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
112561: LD_VAR 0 3
112565: PUSH
112566: LD_INT 1
112568: ARRAY
112569: PPUSH
112570: LD_VAR 0 3
112574: PUSH
112575: LD_INT 2
112577: ARRAY
112578: PPUSH
112579: CALL_OW 235
112583: GO 112558
112585: POP
112586: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
112587: LD_ADDR_EXP 187
112591: PUSH
112592: LD_EXP 187
112596: PPUSH
112597: LD_VAR 0 4
112601: PPUSH
112602: EMPTY
112603: PPUSH
112604: CALL_OW 1
112608: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
112609: LD_VAR 0 1
112613: PPUSH
112614: LD_INT 0
112616: PPUSH
112617: CALL_OW 505
// end ; end ;
112621: LD_VAR 0 2
112625: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
112626: LD_INT 0
112628: PPUSH
112629: PPUSH
112630: PPUSH
// if not hack in hackTanks or not vehicles then
112631: LD_VAR 0 1
112635: PUSH
112636: LD_EXP 186
112640: IN
112641: NOT
112642: PUSH
112643: LD_VAR 0 2
112647: NOT
112648: OR
112649: IFFALSE 112653
// exit ;
112651: GO 112928
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
112653: LD_ADDR_VAR 0 2
112657: PUSH
112658: LD_VAR 0 1
112662: PPUSH
112663: LD_VAR 0 2
112667: PPUSH
112668: LD_INT 1
112670: PPUSH
112671: LD_INT 1
112673: PPUSH
112674: CALL 58259 0 4
112678: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
112679: LD_ADDR_VAR 0 5
112683: PUSH
112684: LD_EXP 186
112688: PPUSH
112689: LD_VAR 0 1
112693: PPUSH
112694: CALL 57609 0 2
112698: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
112699: LD_EXP 187
112703: PUSH
112704: LD_VAR 0 5
112708: ARRAY
112709: PUSH
112710: LD_EXP 188
112714: LESS
112715: IFFALSE 112904
// begin for i := 1 to vehicles do
112717: LD_ADDR_VAR 0 4
112721: PUSH
112722: DOUBLE
112723: LD_INT 1
112725: DEC
112726: ST_TO_ADDR
112727: LD_VAR 0 2
112731: PUSH
112732: FOR_TO
112733: IFFALSE 112902
// begin if hackTanksCaptured [ index ] = hackLimit then
112735: LD_EXP 187
112739: PUSH
112740: LD_VAR 0 5
112744: ARRAY
112745: PUSH
112746: LD_EXP 188
112750: EQUAL
112751: IFFALSE 112755
// break ;
112753: GO 112902
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
112755: LD_ADDR_EXP 190
112759: PUSH
112760: LD_EXP 190
112764: PPUSH
112765: LD_VAR 0 5
112769: PPUSH
112770: LD_EXP 190
112774: PUSH
112775: LD_VAR 0 5
112779: ARRAY
112780: PUSH
112781: LD_INT 1
112783: PLUS
112784: PPUSH
112785: CALL_OW 1
112789: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
112790: LD_ADDR_EXP 187
112794: PUSH
112795: LD_EXP 187
112799: PPUSH
112800: LD_VAR 0 5
112804: PUSH
112805: LD_EXP 187
112809: PUSH
112810: LD_VAR 0 5
112814: ARRAY
112815: PUSH
112816: LD_INT 1
112818: PLUS
112819: PUSH
112820: EMPTY
112821: LIST
112822: LIST
112823: PPUSH
112824: LD_VAR 0 2
112828: PUSH
112829: LD_VAR 0 4
112833: ARRAY
112834: PUSH
112835: LD_VAR 0 2
112839: PUSH
112840: LD_VAR 0 4
112844: ARRAY
112845: PPUSH
112846: CALL_OW 255
112850: PUSH
112851: EMPTY
112852: LIST
112853: LIST
112854: PPUSH
112855: CALL 57824 0 3
112859: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
112860: LD_VAR 0 2
112864: PUSH
112865: LD_VAR 0 4
112869: ARRAY
112870: PPUSH
112871: LD_VAR 0 1
112875: PPUSH
112876: CALL_OW 255
112880: PPUSH
112881: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
112885: LD_VAR 0 2
112889: PUSH
112890: LD_VAR 0 4
112894: ARRAY
112895: PPUSH
112896: CALL_OW 141
// end ;
112900: GO 112732
112902: POP
112903: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
112904: LD_VAR 0 1
112908: PPUSH
112909: LD_EXP 187
112913: PUSH
112914: LD_VAR 0 5
112918: ARRAY
112919: PUSH
112920: LD_INT 0
112922: PLUS
112923: PPUSH
112924: CALL_OW 505
// end ;
112928: LD_VAR 0 3
112932: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
112933: LD_INT 0
112935: PPUSH
112936: PPUSH
112937: PPUSH
112938: PPUSH
// if not hack in hackTanks then
112939: LD_VAR 0 1
112943: PUSH
112944: LD_EXP 186
112948: IN
112949: NOT
112950: IFFALSE 112954
// exit ;
112952: GO 113194
// index := GetElementIndex ( hackTanks , hack ) ;
112954: LD_ADDR_VAR 0 4
112958: PUSH
112959: LD_EXP 186
112963: PPUSH
112964: LD_VAR 0 1
112968: PPUSH
112969: CALL 57609 0 2
112973: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
112974: LD_ADDR_VAR 0 3
112978: PUSH
112979: DOUBLE
112980: LD_EXP 187
112984: PUSH
112985: LD_VAR 0 4
112989: ARRAY
112990: INC
112991: ST_TO_ADDR
112992: LD_INT 1
112994: PUSH
112995: FOR_DOWNTO
112996: IFFALSE 113168
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
112998: LD_ADDR_VAR 0 5
113002: PUSH
113003: LD_EXP 187
113007: PUSH
113008: LD_VAR 0 4
113012: ARRAY
113013: PUSH
113014: LD_VAR 0 3
113018: ARRAY
113019: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
113020: LD_VAR 0 5
113024: PUSH
113025: LD_INT 1
113027: ARRAY
113028: PPUSH
113029: CALL_OW 302
113033: NOT
113034: PUSH
113035: LD_VAR 0 5
113039: PUSH
113040: LD_INT 1
113042: ARRAY
113043: PPUSH
113044: CALL_OW 255
113048: PUSH
113049: LD_VAR 0 1
113053: PPUSH
113054: CALL_OW 255
113058: NONEQUAL
113059: OR
113060: IFFALSE 113166
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
113062: LD_VAR 0 5
113066: PUSH
113067: LD_INT 1
113069: ARRAY
113070: PPUSH
113071: CALL_OW 305
113075: PUSH
113076: LD_VAR 0 5
113080: PUSH
113081: LD_INT 1
113083: ARRAY
113084: PPUSH
113085: CALL_OW 255
113089: PUSH
113090: LD_VAR 0 1
113094: PPUSH
113095: CALL_OW 255
113099: EQUAL
113100: AND
113101: IFFALSE 113125
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
113103: LD_VAR 0 5
113107: PUSH
113108: LD_INT 1
113110: ARRAY
113111: PPUSH
113112: LD_VAR 0 5
113116: PUSH
113117: LD_INT 2
113119: ARRAY
113120: PPUSH
113121: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
113125: LD_ADDR_EXP 187
113129: PUSH
113130: LD_EXP 187
113134: PPUSH
113135: LD_VAR 0 4
113139: PPUSH
113140: LD_EXP 187
113144: PUSH
113145: LD_VAR 0 4
113149: ARRAY
113150: PPUSH
113151: LD_VAR 0 3
113155: PPUSH
113156: CALL_OW 3
113160: PPUSH
113161: CALL_OW 1
113165: ST_TO_ADDR
// end ; end ;
113166: GO 112995
113168: POP
113169: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
113170: LD_VAR 0 1
113174: PPUSH
113175: LD_EXP 187
113179: PUSH
113180: LD_VAR 0 4
113184: ARRAY
113185: PUSH
113186: LD_INT 0
113188: PLUS
113189: PPUSH
113190: CALL_OW 505
// end ;
113194: LD_VAR 0 2
113198: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
113199: LD_INT 0
113201: PPUSH
113202: PPUSH
113203: PPUSH
113204: PPUSH
// if not hack in hackTanks then
113205: LD_VAR 0 1
113209: PUSH
113210: LD_EXP 186
113214: IN
113215: NOT
113216: IFFALSE 113220
// exit ;
113218: GO 113305
// index := GetElementIndex ( hackTanks , hack ) ;
113220: LD_ADDR_VAR 0 5
113224: PUSH
113225: LD_EXP 186
113229: PPUSH
113230: LD_VAR 0 1
113234: PPUSH
113235: CALL 57609 0 2
113239: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
113240: LD_ADDR_VAR 0 4
113244: PUSH
113245: DOUBLE
113246: LD_INT 1
113248: DEC
113249: ST_TO_ADDR
113250: LD_EXP 187
113254: PUSH
113255: LD_VAR 0 5
113259: ARRAY
113260: PUSH
113261: FOR_TO
113262: IFFALSE 113303
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
113264: LD_EXP 187
113268: PUSH
113269: LD_VAR 0 5
113273: ARRAY
113274: PUSH
113275: LD_VAR 0 4
113279: ARRAY
113280: PUSH
113281: LD_INT 1
113283: ARRAY
113284: PUSH
113285: LD_VAR 0 2
113289: EQUAL
113290: IFFALSE 113301
// KillUnit ( vehicle ) ;
113292: LD_VAR 0 2
113296: PPUSH
113297: CALL_OW 66
113301: GO 113261
113303: POP
113304: POP
// end ;
113305: LD_VAR 0 3
113309: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
113310: LD_EXP 191
113314: NOT
113315: IFFALSE 113350
113317: GO 113319
113319: DISABLE
// begin initMiner := true ;
113320: LD_ADDR_EXP 191
113324: PUSH
113325: LD_INT 1
113327: ST_TO_ADDR
// minersList := [ ] ;
113328: LD_ADDR_EXP 192
113332: PUSH
113333: EMPTY
113334: ST_TO_ADDR
// minerMinesList := [ ] ;
113335: LD_ADDR_EXP 193
113339: PUSH
113340: EMPTY
113341: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
113342: LD_ADDR_EXP 194
113346: PUSH
113347: LD_INT 5
113349: ST_TO_ADDR
// end ;
113350: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
113351: LD_EXP 191
113355: PUSH
113356: LD_INT 34
113358: PUSH
113359: LD_INT 81
113361: PUSH
113362: EMPTY
113363: LIST
113364: LIST
113365: PPUSH
113366: CALL_OW 69
113370: AND
113371: IFFALSE 113832
113373: GO 113375
113375: DISABLE
113376: LD_INT 0
113378: PPUSH
113379: PPUSH
113380: PPUSH
113381: PPUSH
// begin enable ;
113382: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
113383: LD_ADDR_VAR 0 1
113387: PUSH
113388: LD_INT 34
113390: PUSH
113391: LD_INT 81
113393: PUSH
113394: EMPTY
113395: LIST
113396: LIST
113397: PPUSH
113398: CALL_OW 69
113402: PUSH
113403: FOR_IN
113404: IFFALSE 113476
// begin if not i in minersList then
113406: LD_VAR 0 1
113410: PUSH
113411: LD_EXP 192
113415: IN
113416: NOT
113417: IFFALSE 113474
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
113419: LD_ADDR_EXP 192
113423: PUSH
113424: LD_EXP 192
113428: PPUSH
113429: LD_EXP 192
113433: PUSH
113434: LD_INT 1
113436: PLUS
113437: PPUSH
113438: LD_VAR 0 1
113442: PPUSH
113443: CALL_OW 1
113447: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
113448: LD_ADDR_EXP 193
113452: PUSH
113453: LD_EXP 193
113457: PPUSH
113458: LD_EXP 193
113462: PUSH
113463: LD_INT 1
113465: PLUS
113466: PPUSH
113467: EMPTY
113468: PPUSH
113469: CALL_OW 1
113473: ST_TO_ADDR
// end end ;
113474: GO 113403
113476: POP
113477: POP
// for i := minerMinesList downto 1 do
113478: LD_ADDR_VAR 0 1
113482: PUSH
113483: DOUBLE
113484: LD_EXP 193
113488: INC
113489: ST_TO_ADDR
113490: LD_INT 1
113492: PUSH
113493: FOR_DOWNTO
113494: IFFALSE 113830
// begin if IsLive ( minersList [ i ] ) then
113496: LD_EXP 192
113500: PUSH
113501: LD_VAR 0 1
113505: ARRAY
113506: PPUSH
113507: CALL_OW 300
113511: IFFALSE 113539
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
113513: LD_EXP 192
113517: PUSH
113518: LD_VAR 0 1
113522: ARRAY
113523: PPUSH
113524: LD_EXP 193
113528: PUSH
113529: LD_VAR 0 1
113533: ARRAY
113534: PPUSH
113535: CALL_OW 505
// if not minerMinesList [ i ] then
113539: LD_EXP 193
113543: PUSH
113544: LD_VAR 0 1
113548: ARRAY
113549: NOT
113550: IFFALSE 113554
// continue ;
113552: GO 113493
// for j := minerMinesList [ i ] downto 1 do
113554: LD_ADDR_VAR 0 2
113558: PUSH
113559: DOUBLE
113560: LD_EXP 193
113564: PUSH
113565: LD_VAR 0 1
113569: ARRAY
113570: INC
113571: ST_TO_ADDR
113572: LD_INT 1
113574: PUSH
113575: FOR_DOWNTO
113576: IFFALSE 113826
// begin side := GetSide ( minersList [ i ] ) ;
113578: LD_ADDR_VAR 0 3
113582: PUSH
113583: LD_EXP 192
113587: PUSH
113588: LD_VAR 0 1
113592: ARRAY
113593: PPUSH
113594: CALL_OW 255
113598: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
113599: LD_ADDR_VAR 0 4
113603: PUSH
113604: LD_EXP 193
113608: PUSH
113609: LD_VAR 0 1
113613: ARRAY
113614: PUSH
113615: LD_VAR 0 2
113619: ARRAY
113620: PUSH
113621: LD_INT 1
113623: ARRAY
113624: PPUSH
113625: LD_EXP 193
113629: PUSH
113630: LD_VAR 0 1
113634: ARRAY
113635: PUSH
113636: LD_VAR 0 2
113640: ARRAY
113641: PUSH
113642: LD_INT 2
113644: ARRAY
113645: PPUSH
113646: CALL_OW 428
113650: ST_TO_ADDR
// if not tmp then
113651: LD_VAR 0 4
113655: NOT
113656: IFFALSE 113660
// continue ;
113658: GO 113575
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
113660: LD_VAR 0 4
113664: PUSH
113665: LD_INT 81
113667: PUSH
113668: LD_VAR 0 3
113672: PUSH
113673: EMPTY
113674: LIST
113675: LIST
113676: PPUSH
113677: CALL_OW 69
113681: IN
113682: PUSH
113683: LD_EXP 193
113687: PUSH
113688: LD_VAR 0 1
113692: ARRAY
113693: PUSH
113694: LD_VAR 0 2
113698: ARRAY
113699: PUSH
113700: LD_INT 1
113702: ARRAY
113703: PPUSH
113704: LD_EXP 193
113708: PUSH
113709: LD_VAR 0 1
113713: ARRAY
113714: PUSH
113715: LD_VAR 0 2
113719: ARRAY
113720: PUSH
113721: LD_INT 2
113723: ARRAY
113724: PPUSH
113725: CALL_OW 458
113729: AND
113730: IFFALSE 113824
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
113732: LD_EXP 193
113736: PUSH
113737: LD_VAR 0 1
113741: ARRAY
113742: PUSH
113743: LD_VAR 0 2
113747: ARRAY
113748: PUSH
113749: LD_INT 1
113751: ARRAY
113752: PPUSH
113753: LD_EXP 193
113757: PUSH
113758: LD_VAR 0 1
113762: ARRAY
113763: PUSH
113764: LD_VAR 0 2
113768: ARRAY
113769: PUSH
113770: LD_INT 2
113772: ARRAY
113773: PPUSH
113774: LD_VAR 0 3
113778: PPUSH
113779: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
113783: LD_ADDR_EXP 193
113787: PUSH
113788: LD_EXP 193
113792: PPUSH
113793: LD_VAR 0 1
113797: PPUSH
113798: LD_EXP 193
113802: PUSH
113803: LD_VAR 0 1
113807: ARRAY
113808: PPUSH
113809: LD_VAR 0 2
113813: PPUSH
113814: CALL_OW 3
113818: PPUSH
113819: CALL_OW 1
113823: ST_TO_ADDR
// end ; end ;
113824: GO 113575
113826: POP
113827: POP
// end ;
113828: GO 113493
113830: POP
113831: POP
// end ;
113832: PPOPN 4
113834: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
113835: LD_INT 0
113837: PPUSH
113838: PPUSH
// result := false ;
113839: LD_ADDR_VAR 0 4
113843: PUSH
113844: LD_INT 0
113846: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
113847: LD_VAR 0 1
113851: PPUSH
113852: CALL_OW 264
113856: PUSH
113857: LD_INT 81
113859: EQUAL
113860: NOT
113861: IFFALSE 113865
// exit ;
113863: GO 114105
// index := GetElementIndex ( minersList , unit ) ;
113865: LD_ADDR_VAR 0 5
113869: PUSH
113870: LD_EXP 192
113874: PPUSH
113875: LD_VAR 0 1
113879: PPUSH
113880: CALL 57609 0 2
113884: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
113885: LD_EXP 193
113889: PUSH
113890: LD_VAR 0 5
113894: ARRAY
113895: PUSH
113896: LD_EXP 194
113900: GREATEREQUAL
113901: IFFALSE 113905
// exit ;
113903: GO 114105
// ComMoveXY ( unit , x , y ) ;
113905: LD_VAR 0 1
113909: PPUSH
113910: LD_VAR 0 2
113914: PPUSH
113915: LD_VAR 0 3
113919: PPUSH
113920: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113924: LD_INT 35
113926: PPUSH
113927: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
113931: LD_VAR 0 1
113935: PPUSH
113936: LD_VAR 0 2
113940: PPUSH
113941: LD_VAR 0 3
113945: PPUSH
113946: CALL 89361 0 3
113950: NOT
113951: PUSH
113952: LD_VAR 0 1
113956: PPUSH
113957: CALL_OW 314
113961: AND
113962: IFFALSE 113966
// exit ;
113964: GO 114105
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
113966: LD_VAR 0 2
113970: PPUSH
113971: LD_VAR 0 3
113975: PPUSH
113976: CALL_OW 428
113980: PUSH
113981: LD_VAR 0 1
113985: EQUAL
113986: PUSH
113987: LD_VAR 0 1
113991: PPUSH
113992: CALL_OW 314
113996: NOT
113997: AND
113998: IFFALSE 113924
// PlaySoundXY ( x , y , PlantMine ) ;
114000: LD_VAR 0 2
114004: PPUSH
114005: LD_VAR 0 3
114009: PPUSH
114010: LD_STRING PlantMine
114012: PPUSH
114013: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
114017: LD_VAR 0 2
114021: PPUSH
114022: LD_VAR 0 3
114026: PPUSH
114027: LD_VAR 0 1
114031: PPUSH
114032: CALL_OW 255
114036: PPUSH
114037: LD_INT 0
114039: PPUSH
114040: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
114044: LD_ADDR_EXP 193
114048: PUSH
114049: LD_EXP 193
114053: PPUSH
114054: LD_VAR 0 5
114058: PUSH
114059: LD_EXP 193
114063: PUSH
114064: LD_VAR 0 5
114068: ARRAY
114069: PUSH
114070: LD_INT 1
114072: PLUS
114073: PUSH
114074: EMPTY
114075: LIST
114076: LIST
114077: PPUSH
114078: LD_VAR 0 2
114082: PUSH
114083: LD_VAR 0 3
114087: PUSH
114088: EMPTY
114089: LIST
114090: LIST
114091: PPUSH
114092: CALL 57824 0 3
114096: ST_TO_ADDR
// result := true ;
114097: LD_ADDR_VAR 0 4
114101: PUSH
114102: LD_INT 1
114104: ST_TO_ADDR
// end ;
114105: LD_VAR 0 4
114109: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
114110: LD_INT 0
114112: PPUSH
114113: PPUSH
114114: PPUSH
// if not unit in minersList then
114115: LD_VAR 0 1
114119: PUSH
114120: LD_EXP 192
114124: IN
114125: NOT
114126: IFFALSE 114130
// exit ;
114128: GO 114522
// index := GetElementIndex ( minersList , unit ) ;
114130: LD_ADDR_VAR 0 6
114134: PUSH
114135: LD_EXP 192
114139: PPUSH
114140: LD_VAR 0 1
114144: PPUSH
114145: CALL 57609 0 2
114149: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
114150: LD_ADDR_VAR 0 5
114154: PUSH
114155: DOUBLE
114156: LD_EXP 193
114160: PUSH
114161: LD_VAR 0 6
114165: ARRAY
114166: INC
114167: ST_TO_ADDR
114168: LD_INT 1
114170: PUSH
114171: FOR_DOWNTO
114172: IFFALSE 114333
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
114174: LD_EXP 193
114178: PUSH
114179: LD_VAR 0 6
114183: ARRAY
114184: PUSH
114185: LD_VAR 0 5
114189: ARRAY
114190: PUSH
114191: LD_INT 1
114193: ARRAY
114194: PUSH
114195: LD_VAR 0 2
114199: EQUAL
114200: PUSH
114201: LD_EXP 193
114205: PUSH
114206: LD_VAR 0 6
114210: ARRAY
114211: PUSH
114212: LD_VAR 0 5
114216: ARRAY
114217: PUSH
114218: LD_INT 2
114220: ARRAY
114221: PUSH
114222: LD_VAR 0 3
114226: EQUAL
114227: AND
114228: IFFALSE 114331
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
114230: LD_EXP 193
114234: PUSH
114235: LD_VAR 0 6
114239: ARRAY
114240: PUSH
114241: LD_VAR 0 5
114245: ARRAY
114246: PUSH
114247: LD_INT 1
114249: ARRAY
114250: PPUSH
114251: LD_EXP 193
114255: PUSH
114256: LD_VAR 0 6
114260: ARRAY
114261: PUSH
114262: LD_VAR 0 5
114266: ARRAY
114267: PUSH
114268: LD_INT 2
114270: ARRAY
114271: PPUSH
114272: LD_VAR 0 1
114276: PPUSH
114277: CALL_OW 255
114281: PPUSH
114282: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
114286: LD_ADDR_EXP 193
114290: PUSH
114291: LD_EXP 193
114295: PPUSH
114296: LD_VAR 0 6
114300: PPUSH
114301: LD_EXP 193
114305: PUSH
114306: LD_VAR 0 6
114310: ARRAY
114311: PPUSH
114312: LD_VAR 0 5
114316: PPUSH
114317: CALL_OW 3
114321: PPUSH
114322: CALL_OW 1
114326: ST_TO_ADDR
// exit ;
114327: POP
114328: POP
114329: GO 114522
// end ; end ;
114331: GO 114171
114333: POP
114334: POP
// for i := minerMinesList [ index ] downto 1 do
114335: LD_ADDR_VAR 0 5
114339: PUSH
114340: DOUBLE
114341: LD_EXP 193
114345: PUSH
114346: LD_VAR 0 6
114350: ARRAY
114351: INC
114352: ST_TO_ADDR
114353: LD_INT 1
114355: PUSH
114356: FOR_DOWNTO
114357: IFFALSE 114520
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
114359: LD_EXP 193
114363: PUSH
114364: LD_VAR 0 6
114368: ARRAY
114369: PUSH
114370: LD_VAR 0 5
114374: ARRAY
114375: PUSH
114376: LD_INT 1
114378: ARRAY
114379: PPUSH
114380: LD_EXP 193
114384: PUSH
114385: LD_VAR 0 6
114389: ARRAY
114390: PUSH
114391: LD_VAR 0 5
114395: ARRAY
114396: PUSH
114397: LD_INT 2
114399: ARRAY
114400: PPUSH
114401: LD_VAR 0 2
114405: PPUSH
114406: LD_VAR 0 3
114410: PPUSH
114411: CALL_OW 298
114415: PUSH
114416: LD_INT 6
114418: LESS
114419: IFFALSE 114518
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
114421: LD_EXP 193
114425: PUSH
114426: LD_VAR 0 6
114430: ARRAY
114431: PUSH
114432: LD_VAR 0 5
114436: ARRAY
114437: PUSH
114438: LD_INT 1
114440: ARRAY
114441: PPUSH
114442: LD_EXP 193
114446: PUSH
114447: LD_VAR 0 6
114451: ARRAY
114452: PUSH
114453: LD_VAR 0 5
114457: ARRAY
114458: PUSH
114459: LD_INT 2
114461: ARRAY
114462: PPUSH
114463: LD_VAR 0 1
114467: PPUSH
114468: CALL_OW 255
114472: PPUSH
114473: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
114477: LD_ADDR_EXP 193
114481: PUSH
114482: LD_EXP 193
114486: PPUSH
114487: LD_VAR 0 6
114491: PPUSH
114492: LD_EXP 193
114496: PUSH
114497: LD_VAR 0 6
114501: ARRAY
114502: PPUSH
114503: LD_VAR 0 5
114507: PPUSH
114508: CALL_OW 3
114512: PPUSH
114513: CALL_OW 1
114517: ST_TO_ADDR
// end ; end ;
114518: GO 114356
114520: POP
114521: POP
// end ;
114522: LD_VAR 0 4
114526: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
114527: LD_INT 0
114529: PPUSH
114530: PPUSH
114531: PPUSH
114532: PPUSH
114533: PPUSH
114534: PPUSH
114535: PPUSH
114536: PPUSH
114537: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
114538: LD_VAR 0 1
114542: PPUSH
114543: CALL_OW 264
114547: PUSH
114548: LD_INT 81
114550: EQUAL
114551: NOT
114552: PUSH
114553: LD_VAR 0 1
114557: PUSH
114558: LD_EXP 192
114562: IN
114563: NOT
114564: OR
114565: IFFALSE 114569
// exit ;
114567: GO 114891
// index := GetElementIndex ( minersList , unit ) ;
114569: LD_ADDR_VAR 0 6
114573: PUSH
114574: LD_EXP 192
114578: PPUSH
114579: LD_VAR 0 1
114583: PPUSH
114584: CALL 57609 0 2
114588: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
114589: LD_ADDR_VAR 0 8
114593: PUSH
114594: LD_EXP 194
114598: PUSH
114599: LD_EXP 193
114603: PUSH
114604: LD_VAR 0 6
114608: ARRAY
114609: MINUS
114610: ST_TO_ADDR
// if not minesFreeAmount then
114611: LD_VAR 0 8
114615: NOT
114616: IFFALSE 114620
// exit ;
114618: GO 114891
// tmp := [ ] ;
114620: LD_ADDR_VAR 0 7
114624: PUSH
114625: EMPTY
114626: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
114627: LD_ADDR_VAR 0 5
114631: PUSH
114632: DOUBLE
114633: LD_INT 1
114635: DEC
114636: ST_TO_ADDR
114637: LD_VAR 0 8
114641: PUSH
114642: FOR_TO
114643: IFFALSE 114838
// begin _d := rand ( 0 , 5 ) ;
114645: LD_ADDR_VAR 0 11
114649: PUSH
114650: LD_INT 0
114652: PPUSH
114653: LD_INT 5
114655: PPUSH
114656: CALL_OW 12
114660: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
114661: LD_ADDR_VAR 0 12
114665: PUSH
114666: LD_INT 2
114668: PPUSH
114669: LD_INT 6
114671: PPUSH
114672: CALL_OW 12
114676: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
114677: LD_ADDR_VAR 0 9
114681: PUSH
114682: LD_VAR 0 2
114686: PPUSH
114687: LD_VAR 0 11
114691: PPUSH
114692: LD_VAR 0 12
114696: PPUSH
114697: CALL_OW 272
114701: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
114702: LD_ADDR_VAR 0 10
114706: PUSH
114707: LD_VAR 0 3
114711: PPUSH
114712: LD_VAR 0 11
114716: PPUSH
114717: LD_VAR 0 12
114721: PPUSH
114722: CALL_OW 273
114726: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
114727: LD_VAR 0 9
114731: PPUSH
114732: LD_VAR 0 10
114736: PPUSH
114737: CALL_OW 488
114741: PUSH
114742: LD_VAR 0 9
114746: PUSH
114747: LD_VAR 0 10
114751: PUSH
114752: EMPTY
114753: LIST
114754: LIST
114755: PUSH
114756: LD_VAR 0 7
114760: IN
114761: NOT
114762: AND
114763: PUSH
114764: LD_VAR 0 9
114768: PPUSH
114769: LD_VAR 0 10
114773: PPUSH
114774: CALL_OW 458
114778: NOT
114779: AND
114780: IFFALSE 114822
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
114782: LD_ADDR_VAR 0 7
114786: PUSH
114787: LD_VAR 0 7
114791: PPUSH
114792: LD_VAR 0 7
114796: PUSH
114797: LD_INT 1
114799: PLUS
114800: PPUSH
114801: LD_VAR 0 9
114805: PUSH
114806: LD_VAR 0 10
114810: PUSH
114811: EMPTY
114812: LIST
114813: LIST
114814: PPUSH
114815: CALL_OW 1
114819: ST_TO_ADDR
114820: GO 114836
// i := i - 1 ;
114822: LD_ADDR_VAR 0 5
114826: PUSH
114827: LD_VAR 0 5
114831: PUSH
114832: LD_INT 1
114834: MINUS
114835: ST_TO_ADDR
// end ;
114836: GO 114642
114838: POP
114839: POP
// for i in tmp do
114840: LD_ADDR_VAR 0 5
114844: PUSH
114845: LD_VAR 0 7
114849: PUSH
114850: FOR_IN
114851: IFFALSE 114889
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
114853: LD_VAR 0 1
114857: PPUSH
114858: LD_VAR 0 5
114862: PUSH
114863: LD_INT 1
114865: ARRAY
114866: PPUSH
114867: LD_VAR 0 5
114871: PUSH
114872: LD_INT 2
114874: ARRAY
114875: PPUSH
114876: CALL 113835 0 3
114880: NOT
114881: IFFALSE 114887
// exit ;
114883: POP
114884: POP
114885: GO 114891
114887: GO 114850
114889: POP
114890: POP
// end ;
114891: LD_VAR 0 4
114895: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
114896: LD_INT 0
114898: PPUSH
114899: PPUSH
114900: PPUSH
114901: PPUSH
114902: PPUSH
114903: PPUSH
114904: PPUSH
// if not GetClass ( unit ) = class_sniper then
114905: LD_VAR 0 1
114909: PPUSH
114910: CALL_OW 257
114914: PUSH
114915: LD_INT 5
114917: EQUAL
114918: NOT
114919: IFFALSE 114923
// exit ;
114921: GO 115311
// dist := 8 ;
114923: LD_ADDR_VAR 0 5
114927: PUSH
114928: LD_INT 8
114930: ST_TO_ADDR
// viewRange := 12 ;
114931: LD_ADDR_VAR 0 7
114935: PUSH
114936: LD_INT 12
114938: ST_TO_ADDR
// side := GetSide ( unit ) ;
114939: LD_ADDR_VAR 0 6
114943: PUSH
114944: LD_VAR 0 1
114948: PPUSH
114949: CALL_OW 255
114953: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
114954: LD_INT 61
114956: PPUSH
114957: LD_VAR 0 6
114961: PPUSH
114962: CALL_OW 321
114966: PUSH
114967: LD_INT 2
114969: EQUAL
114970: IFFALSE 114980
// viewRange := 16 ;
114972: LD_ADDR_VAR 0 7
114976: PUSH
114977: LD_INT 16
114979: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
114980: LD_VAR 0 1
114984: PPUSH
114985: LD_VAR 0 2
114989: PPUSH
114990: LD_VAR 0 3
114994: PPUSH
114995: CALL_OW 297
114999: PUSH
115000: LD_VAR 0 5
115004: GREATER
115005: IFFALSE 115084
// begin ComMoveXY ( unit , x , y ) ;
115007: LD_VAR 0 1
115011: PPUSH
115012: LD_VAR 0 2
115016: PPUSH
115017: LD_VAR 0 3
115021: PPUSH
115022: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
115026: LD_INT 35
115028: PPUSH
115029: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
115033: LD_VAR 0 1
115037: PPUSH
115038: LD_VAR 0 2
115042: PPUSH
115043: LD_VAR 0 3
115047: PPUSH
115048: CALL 89361 0 3
115052: NOT
115053: IFFALSE 115057
// exit ;
115055: GO 115311
// until GetDistUnitXY ( unit , x , y ) < dist ;
115057: LD_VAR 0 1
115061: PPUSH
115062: LD_VAR 0 2
115066: PPUSH
115067: LD_VAR 0 3
115071: PPUSH
115072: CALL_OW 297
115076: PUSH
115077: LD_VAR 0 5
115081: LESS
115082: IFFALSE 115026
// end ; ComTurnXY ( unit , x , y ) ;
115084: LD_VAR 0 1
115088: PPUSH
115089: LD_VAR 0 2
115093: PPUSH
115094: LD_VAR 0 3
115098: PPUSH
115099: CALL_OW 118
// wait ( 5 ) ;
115103: LD_INT 5
115105: PPUSH
115106: CALL_OW 67
// _d := GetDir ( unit ) ;
115110: LD_ADDR_VAR 0 10
115114: PUSH
115115: LD_VAR 0 1
115119: PPUSH
115120: CALL_OW 254
115124: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
115125: LD_ADDR_VAR 0 8
115129: PUSH
115130: LD_VAR 0 1
115134: PPUSH
115135: CALL_OW 250
115139: PPUSH
115140: LD_VAR 0 10
115144: PPUSH
115145: LD_VAR 0 5
115149: PPUSH
115150: CALL_OW 272
115154: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
115155: LD_ADDR_VAR 0 9
115159: PUSH
115160: LD_VAR 0 1
115164: PPUSH
115165: CALL_OW 251
115169: PPUSH
115170: LD_VAR 0 10
115174: PPUSH
115175: LD_VAR 0 5
115179: PPUSH
115180: CALL_OW 273
115184: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
115185: LD_VAR 0 8
115189: PPUSH
115190: LD_VAR 0 9
115194: PPUSH
115195: CALL_OW 488
115199: NOT
115200: IFFALSE 115204
// exit ;
115202: GO 115311
// ComAnimCustom ( unit , 1 ) ;
115204: LD_VAR 0 1
115208: PPUSH
115209: LD_INT 1
115211: PPUSH
115212: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
115216: LD_VAR 0 8
115220: PPUSH
115221: LD_VAR 0 9
115225: PPUSH
115226: LD_VAR 0 6
115230: PPUSH
115231: LD_VAR 0 7
115235: PPUSH
115236: CALL_OW 330
// repeat wait ( 1 ) ;
115240: LD_INT 1
115242: PPUSH
115243: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
115247: LD_VAR 0 1
115251: PPUSH
115252: CALL_OW 316
115256: PUSH
115257: LD_VAR 0 1
115261: PPUSH
115262: CALL_OW 314
115266: OR
115267: PUSH
115268: LD_VAR 0 1
115272: PPUSH
115273: CALL_OW 302
115277: NOT
115278: OR
115279: PUSH
115280: LD_VAR 0 1
115284: PPUSH
115285: CALL_OW 301
115289: OR
115290: IFFALSE 115240
// RemoveSeeing ( _x , _y , side ) ;
115292: LD_VAR 0 8
115296: PPUSH
115297: LD_VAR 0 9
115301: PPUSH
115302: LD_VAR 0 6
115306: PPUSH
115307: CALL_OW 331
// end ; end_of_file
115311: LD_VAR 0 4
115315: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
115316: LD_INT 0
115318: PPUSH
115319: PPUSH
115320: PPUSH
115321: PPUSH
115322: PPUSH
115323: PPUSH
115324: PPUSH
115325: PPUSH
115326: PPUSH
115327: PPUSH
115328: PPUSH
115329: PPUSH
115330: PPUSH
115331: PPUSH
115332: PPUSH
115333: PPUSH
115334: PPUSH
115335: PPUSH
115336: PPUSH
115337: PPUSH
115338: PPUSH
115339: PPUSH
115340: PPUSH
115341: PPUSH
115342: PPUSH
115343: PPUSH
115344: PPUSH
115345: PPUSH
115346: PPUSH
115347: PPUSH
115348: PPUSH
115349: PPUSH
115350: PPUSH
115351: PPUSH
// if not list then
115352: LD_VAR 0 1
115356: NOT
115357: IFFALSE 115361
// exit ;
115359: GO 120020
// base := list [ 1 ] ;
115361: LD_ADDR_VAR 0 3
115365: PUSH
115366: LD_VAR 0 1
115370: PUSH
115371: LD_INT 1
115373: ARRAY
115374: ST_TO_ADDR
// group := list [ 2 ] ;
115375: LD_ADDR_VAR 0 4
115379: PUSH
115380: LD_VAR 0 1
115384: PUSH
115385: LD_INT 2
115387: ARRAY
115388: ST_TO_ADDR
// path := list [ 3 ] ;
115389: LD_ADDR_VAR 0 5
115393: PUSH
115394: LD_VAR 0 1
115398: PUSH
115399: LD_INT 3
115401: ARRAY
115402: ST_TO_ADDR
// flags := list [ 4 ] ;
115403: LD_ADDR_VAR 0 6
115407: PUSH
115408: LD_VAR 0 1
115412: PUSH
115413: LD_INT 4
115415: ARRAY
115416: ST_TO_ADDR
// mined := [ ] ;
115417: LD_ADDR_VAR 0 27
115421: PUSH
115422: EMPTY
115423: ST_TO_ADDR
// bombed := [ ] ;
115424: LD_ADDR_VAR 0 28
115428: PUSH
115429: EMPTY
115430: ST_TO_ADDR
// healers := [ ] ;
115431: LD_ADDR_VAR 0 31
115435: PUSH
115436: EMPTY
115437: ST_TO_ADDR
// to_heal := [ ] ;
115438: LD_ADDR_VAR 0 30
115442: PUSH
115443: EMPTY
115444: ST_TO_ADDR
// repairs := [ ] ;
115445: LD_ADDR_VAR 0 33
115449: PUSH
115450: EMPTY
115451: ST_TO_ADDR
// to_repair := [ ] ;
115452: LD_ADDR_VAR 0 32
115456: PUSH
115457: EMPTY
115458: ST_TO_ADDR
// if not group or not path then
115459: LD_VAR 0 4
115463: NOT
115464: PUSH
115465: LD_VAR 0 5
115469: NOT
115470: OR
115471: IFFALSE 115475
// exit ;
115473: GO 120020
// side := GetSide ( group [ 1 ] ) ;
115475: LD_ADDR_VAR 0 35
115479: PUSH
115480: LD_VAR 0 4
115484: PUSH
115485: LD_INT 1
115487: ARRAY
115488: PPUSH
115489: CALL_OW 255
115493: ST_TO_ADDR
// if flags then
115494: LD_VAR 0 6
115498: IFFALSE 115642
// begin f_ignore_area := flags [ 1 ] ;
115500: LD_ADDR_VAR 0 17
115504: PUSH
115505: LD_VAR 0 6
115509: PUSH
115510: LD_INT 1
115512: ARRAY
115513: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
115514: LD_ADDR_VAR 0 18
115518: PUSH
115519: LD_VAR 0 6
115523: PUSH
115524: LD_INT 2
115526: ARRAY
115527: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
115528: LD_ADDR_VAR 0 19
115532: PUSH
115533: LD_VAR 0 6
115537: PUSH
115538: LD_INT 3
115540: ARRAY
115541: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
115542: LD_ADDR_VAR 0 20
115546: PUSH
115547: LD_VAR 0 6
115551: PUSH
115552: LD_INT 4
115554: ARRAY
115555: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
115556: LD_ADDR_VAR 0 21
115560: PUSH
115561: LD_VAR 0 6
115565: PUSH
115566: LD_INT 5
115568: ARRAY
115569: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
115570: LD_ADDR_VAR 0 22
115574: PUSH
115575: LD_VAR 0 6
115579: PUSH
115580: LD_INT 6
115582: ARRAY
115583: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
115584: LD_ADDR_VAR 0 23
115588: PUSH
115589: LD_VAR 0 6
115593: PUSH
115594: LD_INT 7
115596: ARRAY
115597: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
115598: LD_ADDR_VAR 0 24
115602: PUSH
115603: LD_VAR 0 6
115607: PUSH
115608: LD_INT 8
115610: ARRAY
115611: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
115612: LD_ADDR_VAR 0 25
115616: PUSH
115617: LD_VAR 0 6
115621: PUSH
115622: LD_INT 9
115624: ARRAY
115625: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
115626: LD_ADDR_VAR 0 26
115630: PUSH
115631: LD_VAR 0 6
115635: PUSH
115636: LD_INT 10
115638: ARRAY
115639: ST_TO_ADDR
// end else
115640: GO 115722
// begin f_ignore_area := false ;
115642: LD_ADDR_VAR 0 17
115646: PUSH
115647: LD_INT 0
115649: ST_TO_ADDR
// f_capture := false ;
115650: LD_ADDR_VAR 0 18
115654: PUSH
115655: LD_INT 0
115657: ST_TO_ADDR
// f_ignore_civ := false ;
115658: LD_ADDR_VAR 0 19
115662: PUSH
115663: LD_INT 0
115665: ST_TO_ADDR
// f_murder := false ;
115666: LD_ADDR_VAR 0 20
115670: PUSH
115671: LD_INT 0
115673: ST_TO_ADDR
// f_mines := false ;
115674: LD_ADDR_VAR 0 21
115678: PUSH
115679: LD_INT 0
115681: ST_TO_ADDR
// f_repair := false ;
115682: LD_ADDR_VAR 0 22
115686: PUSH
115687: LD_INT 0
115689: ST_TO_ADDR
// f_heal := false ;
115690: LD_ADDR_VAR 0 23
115694: PUSH
115695: LD_INT 0
115697: ST_TO_ADDR
// f_spacetime := false ;
115698: LD_ADDR_VAR 0 24
115702: PUSH
115703: LD_INT 0
115705: ST_TO_ADDR
// f_attack_depot := false ;
115706: LD_ADDR_VAR 0 25
115710: PUSH
115711: LD_INT 0
115713: ST_TO_ADDR
// f_crawl := false ;
115714: LD_ADDR_VAR 0 26
115718: PUSH
115719: LD_INT 0
115721: ST_TO_ADDR
// end ; if f_heal then
115722: LD_VAR 0 23
115726: IFFALSE 115753
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
115728: LD_ADDR_VAR 0 31
115732: PUSH
115733: LD_VAR 0 4
115737: PPUSH
115738: LD_INT 25
115740: PUSH
115741: LD_INT 4
115743: PUSH
115744: EMPTY
115745: LIST
115746: LIST
115747: PPUSH
115748: CALL_OW 72
115752: ST_TO_ADDR
// if f_repair then
115753: LD_VAR 0 22
115757: IFFALSE 115784
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
115759: LD_ADDR_VAR 0 33
115763: PUSH
115764: LD_VAR 0 4
115768: PPUSH
115769: LD_INT 25
115771: PUSH
115772: LD_INT 3
115774: PUSH
115775: EMPTY
115776: LIST
115777: LIST
115778: PPUSH
115779: CALL_OW 72
115783: ST_TO_ADDR
// units_path := [ ] ;
115784: LD_ADDR_VAR 0 16
115788: PUSH
115789: EMPTY
115790: ST_TO_ADDR
// for i = 1 to group do
115791: LD_ADDR_VAR 0 7
115795: PUSH
115796: DOUBLE
115797: LD_INT 1
115799: DEC
115800: ST_TO_ADDR
115801: LD_VAR 0 4
115805: PUSH
115806: FOR_TO
115807: IFFALSE 115836
// units_path := Replace ( units_path , i , path ) ;
115809: LD_ADDR_VAR 0 16
115813: PUSH
115814: LD_VAR 0 16
115818: PPUSH
115819: LD_VAR 0 7
115823: PPUSH
115824: LD_VAR 0 5
115828: PPUSH
115829: CALL_OW 1
115833: ST_TO_ADDR
115834: GO 115806
115836: POP
115837: POP
// repeat for i = group downto 1 do
115838: LD_ADDR_VAR 0 7
115842: PUSH
115843: DOUBLE
115844: LD_VAR 0 4
115848: INC
115849: ST_TO_ADDR
115850: LD_INT 1
115852: PUSH
115853: FOR_DOWNTO
115854: IFFALSE 119976
// begin wait ( 5 ) ;
115856: LD_INT 5
115858: PPUSH
115859: CALL_OW 67
// tmp := [ ] ;
115863: LD_ADDR_VAR 0 14
115867: PUSH
115868: EMPTY
115869: ST_TO_ADDR
// attacking := false ;
115870: LD_ADDR_VAR 0 29
115874: PUSH
115875: LD_INT 0
115877: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
115878: LD_VAR 0 4
115882: PUSH
115883: LD_VAR 0 7
115887: ARRAY
115888: PPUSH
115889: CALL_OW 301
115893: PUSH
115894: LD_VAR 0 4
115898: PUSH
115899: LD_VAR 0 7
115903: ARRAY
115904: NOT
115905: OR
115906: IFFALSE 116015
// begin if GetType ( group [ i ] ) = unit_human then
115908: LD_VAR 0 4
115912: PUSH
115913: LD_VAR 0 7
115917: ARRAY
115918: PPUSH
115919: CALL_OW 247
115923: PUSH
115924: LD_INT 1
115926: EQUAL
115927: IFFALSE 115973
// begin to_heal := to_heal diff group [ i ] ;
115929: LD_ADDR_VAR 0 30
115933: PUSH
115934: LD_VAR 0 30
115938: PUSH
115939: LD_VAR 0 4
115943: PUSH
115944: LD_VAR 0 7
115948: ARRAY
115949: DIFF
115950: ST_TO_ADDR
// healers := healers diff group [ i ] ;
115951: LD_ADDR_VAR 0 31
115955: PUSH
115956: LD_VAR 0 31
115960: PUSH
115961: LD_VAR 0 4
115965: PUSH
115966: LD_VAR 0 7
115970: ARRAY
115971: DIFF
115972: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
115973: LD_ADDR_VAR 0 4
115977: PUSH
115978: LD_VAR 0 4
115982: PPUSH
115983: LD_VAR 0 7
115987: PPUSH
115988: CALL_OW 3
115992: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
115993: LD_ADDR_VAR 0 16
115997: PUSH
115998: LD_VAR 0 16
116002: PPUSH
116003: LD_VAR 0 7
116007: PPUSH
116008: CALL_OW 3
116012: ST_TO_ADDR
// continue ;
116013: GO 115853
// end ; if f_repair then
116015: LD_VAR 0 22
116019: IFFALSE 116508
// begin if GetType ( group [ i ] ) = unit_vehicle then
116021: LD_VAR 0 4
116025: PUSH
116026: LD_VAR 0 7
116030: ARRAY
116031: PPUSH
116032: CALL_OW 247
116036: PUSH
116037: LD_INT 2
116039: EQUAL
116040: IFFALSE 116230
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
116042: LD_VAR 0 4
116046: PUSH
116047: LD_VAR 0 7
116051: ARRAY
116052: PPUSH
116053: CALL_OW 256
116057: PUSH
116058: LD_INT 700
116060: LESS
116061: PUSH
116062: LD_VAR 0 4
116066: PUSH
116067: LD_VAR 0 7
116071: ARRAY
116072: PUSH
116073: LD_VAR 0 32
116077: IN
116078: NOT
116079: AND
116080: IFFALSE 116104
// to_repair := to_repair union group [ i ] ;
116082: LD_ADDR_VAR 0 32
116086: PUSH
116087: LD_VAR 0 32
116091: PUSH
116092: LD_VAR 0 4
116096: PUSH
116097: LD_VAR 0 7
116101: ARRAY
116102: UNION
116103: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
116104: LD_VAR 0 4
116108: PUSH
116109: LD_VAR 0 7
116113: ARRAY
116114: PPUSH
116115: CALL_OW 256
116119: PUSH
116120: LD_INT 1000
116122: EQUAL
116123: PUSH
116124: LD_VAR 0 4
116128: PUSH
116129: LD_VAR 0 7
116133: ARRAY
116134: PUSH
116135: LD_VAR 0 32
116139: IN
116140: AND
116141: IFFALSE 116165
// to_repair := to_repair diff group [ i ] ;
116143: LD_ADDR_VAR 0 32
116147: PUSH
116148: LD_VAR 0 32
116152: PUSH
116153: LD_VAR 0 4
116157: PUSH
116158: LD_VAR 0 7
116162: ARRAY
116163: DIFF
116164: ST_TO_ADDR
// if group [ i ] in to_repair then
116165: LD_VAR 0 4
116169: PUSH
116170: LD_VAR 0 7
116174: ARRAY
116175: PUSH
116176: LD_VAR 0 32
116180: IN
116181: IFFALSE 116228
// begin if not IsInArea ( group [ i ] , f_repair ) then
116183: LD_VAR 0 4
116187: PUSH
116188: LD_VAR 0 7
116192: ARRAY
116193: PPUSH
116194: LD_VAR 0 22
116198: PPUSH
116199: CALL_OW 308
116203: NOT
116204: IFFALSE 116226
// ComMoveToArea ( group [ i ] , f_repair ) ;
116206: LD_VAR 0 4
116210: PUSH
116211: LD_VAR 0 7
116215: ARRAY
116216: PPUSH
116217: LD_VAR 0 22
116221: PPUSH
116222: CALL_OW 113
// continue ;
116226: GO 115853
// end ; end else
116228: GO 116508
// if group [ i ] in repairs then
116230: LD_VAR 0 4
116234: PUSH
116235: LD_VAR 0 7
116239: ARRAY
116240: PUSH
116241: LD_VAR 0 33
116245: IN
116246: IFFALSE 116508
// begin if IsInUnit ( group [ i ] ) then
116248: LD_VAR 0 4
116252: PUSH
116253: LD_VAR 0 7
116257: ARRAY
116258: PPUSH
116259: CALL_OW 310
116263: IFFALSE 116331
// begin z := IsInUnit ( group [ i ] ) ;
116265: LD_ADDR_VAR 0 13
116269: PUSH
116270: LD_VAR 0 4
116274: PUSH
116275: LD_VAR 0 7
116279: ARRAY
116280: PPUSH
116281: CALL_OW 310
116285: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
116286: LD_VAR 0 13
116290: PUSH
116291: LD_VAR 0 32
116295: IN
116296: PUSH
116297: LD_VAR 0 13
116301: PPUSH
116302: LD_VAR 0 22
116306: PPUSH
116307: CALL_OW 308
116311: AND
116312: IFFALSE 116329
// ComExitVehicle ( group [ i ] ) ;
116314: LD_VAR 0 4
116318: PUSH
116319: LD_VAR 0 7
116323: ARRAY
116324: PPUSH
116325: CALL_OW 121
// end else
116329: GO 116508
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
116331: LD_ADDR_VAR 0 13
116335: PUSH
116336: LD_VAR 0 4
116340: PPUSH
116341: LD_INT 95
116343: PUSH
116344: LD_VAR 0 22
116348: PUSH
116349: EMPTY
116350: LIST
116351: LIST
116352: PUSH
116353: LD_INT 58
116355: PUSH
116356: EMPTY
116357: LIST
116358: PUSH
116359: EMPTY
116360: LIST
116361: LIST
116362: PPUSH
116363: CALL_OW 72
116367: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
116368: LD_VAR 0 4
116372: PUSH
116373: LD_VAR 0 7
116377: ARRAY
116378: PPUSH
116379: CALL_OW 314
116383: NOT
116384: IFFALSE 116506
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
116386: LD_ADDR_VAR 0 10
116390: PUSH
116391: LD_VAR 0 13
116395: PPUSH
116396: LD_VAR 0 4
116400: PUSH
116401: LD_VAR 0 7
116405: ARRAY
116406: PPUSH
116407: CALL_OW 74
116411: ST_TO_ADDR
// if not x then
116412: LD_VAR 0 10
116416: NOT
116417: IFFALSE 116421
// continue ;
116419: GO 115853
// if GetLives ( x ) < 1000 then
116421: LD_VAR 0 10
116425: PPUSH
116426: CALL_OW 256
116430: PUSH
116431: LD_INT 1000
116433: LESS
116434: IFFALSE 116458
// ComRepairVehicle ( group [ i ] , x ) else
116436: LD_VAR 0 4
116440: PUSH
116441: LD_VAR 0 7
116445: ARRAY
116446: PPUSH
116447: LD_VAR 0 10
116451: PPUSH
116452: CALL_OW 129
116456: GO 116506
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
116458: LD_VAR 0 23
116462: PUSH
116463: LD_VAR 0 4
116467: PUSH
116468: LD_VAR 0 7
116472: ARRAY
116473: PPUSH
116474: CALL_OW 256
116478: PUSH
116479: LD_INT 1000
116481: LESS
116482: AND
116483: NOT
116484: IFFALSE 116506
// ComEnterUnit ( group [ i ] , x ) ;
116486: LD_VAR 0 4
116490: PUSH
116491: LD_VAR 0 7
116495: ARRAY
116496: PPUSH
116497: LD_VAR 0 10
116501: PPUSH
116502: CALL_OW 120
// end ; continue ;
116506: GO 115853
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
116508: LD_VAR 0 23
116512: PUSH
116513: LD_VAR 0 4
116517: PUSH
116518: LD_VAR 0 7
116522: ARRAY
116523: PPUSH
116524: CALL_OW 247
116528: PUSH
116529: LD_INT 1
116531: EQUAL
116532: AND
116533: IFFALSE 117011
// begin if group [ i ] in healers then
116535: LD_VAR 0 4
116539: PUSH
116540: LD_VAR 0 7
116544: ARRAY
116545: PUSH
116546: LD_VAR 0 31
116550: IN
116551: IFFALSE 116824
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
116553: LD_VAR 0 4
116557: PUSH
116558: LD_VAR 0 7
116562: ARRAY
116563: PPUSH
116564: LD_VAR 0 23
116568: PPUSH
116569: CALL_OW 308
116573: NOT
116574: PUSH
116575: LD_VAR 0 4
116579: PUSH
116580: LD_VAR 0 7
116584: ARRAY
116585: PPUSH
116586: CALL_OW 314
116590: NOT
116591: AND
116592: IFFALSE 116616
// ComMoveToArea ( group [ i ] , f_heal ) else
116594: LD_VAR 0 4
116598: PUSH
116599: LD_VAR 0 7
116603: ARRAY
116604: PPUSH
116605: LD_VAR 0 23
116609: PPUSH
116610: CALL_OW 113
116614: GO 116822
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
116616: LD_VAR 0 4
116620: PUSH
116621: LD_VAR 0 7
116625: ARRAY
116626: PPUSH
116627: CALL 87944 0 1
116631: PPUSH
116632: CALL_OW 256
116636: PUSH
116637: LD_INT 1000
116639: EQUAL
116640: IFFALSE 116659
// ComStop ( group [ i ] ) else
116642: LD_VAR 0 4
116646: PUSH
116647: LD_VAR 0 7
116651: ARRAY
116652: PPUSH
116653: CALL_OW 141
116657: GO 116822
// if not HasTask ( group [ i ] ) and to_heal then
116659: LD_VAR 0 4
116663: PUSH
116664: LD_VAR 0 7
116668: ARRAY
116669: PPUSH
116670: CALL_OW 314
116674: NOT
116675: PUSH
116676: LD_VAR 0 30
116680: AND
116681: IFFALSE 116822
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
116683: LD_ADDR_VAR 0 13
116687: PUSH
116688: LD_VAR 0 30
116692: PPUSH
116693: LD_INT 3
116695: PUSH
116696: LD_INT 54
116698: PUSH
116699: EMPTY
116700: LIST
116701: PUSH
116702: EMPTY
116703: LIST
116704: LIST
116705: PPUSH
116706: CALL_OW 72
116710: PPUSH
116711: LD_VAR 0 4
116715: PUSH
116716: LD_VAR 0 7
116720: ARRAY
116721: PPUSH
116722: CALL_OW 74
116726: ST_TO_ADDR
// if z then
116727: LD_VAR 0 13
116731: IFFALSE 116822
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
116733: LD_INT 91
116735: PUSH
116736: LD_VAR 0 13
116740: PUSH
116741: LD_INT 10
116743: PUSH
116744: EMPTY
116745: LIST
116746: LIST
116747: LIST
116748: PUSH
116749: LD_INT 81
116751: PUSH
116752: LD_VAR 0 13
116756: PPUSH
116757: CALL_OW 255
116761: PUSH
116762: EMPTY
116763: LIST
116764: LIST
116765: PUSH
116766: EMPTY
116767: LIST
116768: LIST
116769: PPUSH
116770: CALL_OW 69
116774: PUSH
116775: LD_INT 0
116777: EQUAL
116778: IFFALSE 116802
// ComHeal ( group [ i ] , z ) else
116780: LD_VAR 0 4
116784: PUSH
116785: LD_VAR 0 7
116789: ARRAY
116790: PPUSH
116791: LD_VAR 0 13
116795: PPUSH
116796: CALL_OW 128
116800: GO 116822
// ComMoveToArea ( group [ i ] , f_heal ) ;
116802: LD_VAR 0 4
116806: PUSH
116807: LD_VAR 0 7
116811: ARRAY
116812: PPUSH
116813: LD_VAR 0 23
116817: PPUSH
116818: CALL_OW 113
// end ; continue ;
116822: GO 115853
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
116824: LD_VAR 0 4
116828: PUSH
116829: LD_VAR 0 7
116833: ARRAY
116834: PPUSH
116835: CALL_OW 256
116839: PUSH
116840: LD_INT 700
116842: LESS
116843: PUSH
116844: LD_VAR 0 4
116848: PUSH
116849: LD_VAR 0 7
116853: ARRAY
116854: PUSH
116855: LD_VAR 0 30
116859: IN
116860: NOT
116861: AND
116862: IFFALSE 116886
// to_heal := to_heal union group [ i ] ;
116864: LD_ADDR_VAR 0 30
116868: PUSH
116869: LD_VAR 0 30
116873: PUSH
116874: LD_VAR 0 4
116878: PUSH
116879: LD_VAR 0 7
116883: ARRAY
116884: UNION
116885: ST_TO_ADDR
// if group [ i ] in to_heal then
116886: LD_VAR 0 4
116890: PUSH
116891: LD_VAR 0 7
116895: ARRAY
116896: PUSH
116897: LD_VAR 0 30
116901: IN
116902: IFFALSE 117011
// begin if GetLives ( group [ i ] ) = 1000 then
116904: LD_VAR 0 4
116908: PUSH
116909: LD_VAR 0 7
116913: ARRAY
116914: PPUSH
116915: CALL_OW 256
116919: PUSH
116920: LD_INT 1000
116922: EQUAL
116923: IFFALSE 116949
// to_heal := to_heal diff group [ i ] else
116925: LD_ADDR_VAR 0 30
116929: PUSH
116930: LD_VAR 0 30
116934: PUSH
116935: LD_VAR 0 4
116939: PUSH
116940: LD_VAR 0 7
116944: ARRAY
116945: DIFF
116946: ST_TO_ADDR
116947: GO 117011
// begin if not IsInArea ( group [ i ] , to_heal ) then
116949: LD_VAR 0 4
116953: PUSH
116954: LD_VAR 0 7
116958: ARRAY
116959: PPUSH
116960: LD_VAR 0 30
116964: PPUSH
116965: CALL_OW 308
116969: NOT
116970: IFFALSE 116994
// ComMoveToArea ( group [ i ] , f_heal ) else
116972: LD_VAR 0 4
116976: PUSH
116977: LD_VAR 0 7
116981: ARRAY
116982: PPUSH
116983: LD_VAR 0 23
116987: PPUSH
116988: CALL_OW 113
116992: GO 117009
// ComHold ( group [ i ] ) ;
116994: LD_VAR 0 4
116998: PUSH
116999: LD_VAR 0 7
117003: ARRAY
117004: PPUSH
117005: CALL_OW 140
// continue ;
117009: GO 115853
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
117011: LD_VAR 0 4
117015: PUSH
117016: LD_VAR 0 7
117020: ARRAY
117021: PPUSH
117022: LD_INT 10
117024: PPUSH
117025: CALL 85715 0 2
117029: NOT
117030: PUSH
117031: LD_VAR 0 16
117035: PUSH
117036: LD_VAR 0 7
117040: ARRAY
117041: PUSH
117042: EMPTY
117043: EQUAL
117044: NOT
117045: AND
117046: IFFALSE 117312
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
117048: LD_VAR 0 4
117052: PUSH
117053: LD_VAR 0 7
117057: ARRAY
117058: PPUSH
117059: CALL_OW 262
117063: PUSH
117064: LD_INT 1
117066: PUSH
117067: LD_INT 2
117069: PUSH
117070: EMPTY
117071: LIST
117072: LIST
117073: IN
117074: IFFALSE 117115
// if GetFuel ( group [ i ] ) < 10 then
117076: LD_VAR 0 4
117080: PUSH
117081: LD_VAR 0 7
117085: ARRAY
117086: PPUSH
117087: CALL_OW 261
117091: PUSH
117092: LD_INT 10
117094: LESS
117095: IFFALSE 117115
// SetFuel ( group [ i ] , 12 ) ;
117097: LD_VAR 0 4
117101: PUSH
117102: LD_VAR 0 7
117106: ARRAY
117107: PPUSH
117108: LD_INT 12
117110: PPUSH
117111: CALL_OW 240
// if units_path [ i ] then
117115: LD_VAR 0 16
117119: PUSH
117120: LD_VAR 0 7
117124: ARRAY
117125: IFFALSE 117310
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
117127: LD_VAR 0 4
117131: PUSH
117132: LD_VAR 0 7
117136: ARRAY
117137: PPUSH
117138: LD_VAR 0 16
117142: PUSH
117143: LD_VAR 0 7
117147: ARRAY
117148: PUSH
117149: LD_INT 1
117151: ARRAY
117152: PUSH
117153: LD_INT 1
117155: ARRAY
117156: PPUSH
117157: LD_VAR 0 16
117161: PUSH
117162: LD_VAR 0 7
117166: ARRAY
117167: PUSH
117168: LD_INT 1
117170: ARRAY
117171: PUSH
117172: LD_INT 2
117174: ARRAY
117175: PPUSH
117176: CALL_OW 297
117180: PUSH
117181: LD_INT 6
117183: GREATER
117184: IFFALSE 117259
// begin if not HasTask ( group [ i ] ) then
117186: LD_VAR 0 4
117190: PUSH
117191: LD_VAR 0 7
117195: ARRAY
117196: PPUSH
117197: CALL_OW 314
117201: NOT
117202: IFFALSE 117257
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
117204: LD_VAR 0 4
117208: PUSH
117209: LD_VAR 0 7
117213: ARRAY
117214: PPUSH
117215: LD_VAR 0 16
117219: PUSH
117220: LD_VAR 0 7
117224: ARRAY
117225: PUSH
117226: LD_INT 1
117228: ARRAY
117229: PUSH
117230: LD_INT 1
117232: ARRAY
117233: PPUSH
117234: LD_VAR 0 16
117238: PUSH
117239: LD_VAR 0 7
117243: ARRAY
117244: PUSH
117245: LD_INT 1
117247: ARRAY
117248: PUSH
117249: LD_INT 2
117251: ARRAY
117252: PPUSH
117253: CALL_OW 114
// end else
117257: GO 117310
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
117259: LD_ADDR_VAR 0 15
117263: PUSH
117264: LD_VAR 0 16
117268: PUSH
117269: LD_VAR 0 7
117273: ARRAY
117274: PPUSH
117275: LD_INT 1
117277: PPUSH
117278: CALL_OW 3
117282: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
117283: LD_ADDR_VAR 0 16
117287: PUSH
117288: LD_VAR 0 16
117292: PPUSH
117293: LD_VAR 0 7
117297: PPUSH
117298: LD_VAR 0 15
117302: PPUSH
117303: CALL_OW 1
117307: ST_TO_ADDR
// continue ;
117308: GO 115853
// end ; end ; end else
117310: GO 119974
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
117312: LD_ADDR_VAR 0 14
117316: PUSH
117317: LD_INT 81
117319: PUSH
117320: LD_VAR 0 4
117324: PUSH
117325: LD_VAR 0 7
117329: ARRAY
117330: PPUSH
117331: CALL_OW 255
117335: PUSH
117336: EMPTY
117337: LIST
117338: LIST
117339: PPUSH
117340: CALL_OW 69
117344: ST_TO_ADDR
// if not tmp then
117345: LD_VAR 0 14
117349: NOT
117350: IFFALSE 117354
// continue ;
117352: GO 115853
// if f_ignore_area then
117354: LD_VAR 0 17
117358: IFFALSE 117446
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
117360: LD_ADDR_VAR 0 15
117364: PUSH
117365: LD_VAR 0 14
117369: PPUSH
117370: LD_INT 3
117372: PUSH
117373: LD_INT 92
117375: PUSH
117376: LD_VAR 0 17
117380: PUSH
117381: LD_INT 1
117383: ARRAY
117384: PUSH
117385: LD_VAR 0 17
117389: PUSH
117390: LD_INT 2
117392: ARRAY
117393: PUSH
117394: LD_VAR 0 17
117398: PUSH
117399: LD_INT 3
117401: ARRAY
117402: PUSH
117403: EMPTY
117404: LIST
117405: LIST
117406: LIST
117407: LIST
117408: PUSH
117409: EMPTY
117410: LIST
117411: LIST
117412: PPUSH
117413: CALL_OW 72
117417: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
117418: LD_VAR 0 14
117422: PUSH
117423: LD_VAR 0 15
117427: DIFF
117428: IFFALSE 117446
// tmp := tmp diff tmp2 ;
117430: LD_ADDR_VAR 0 14
117434: PUSH
117435: LD_VAR 0 14
117439: PUSH
117440: LD_VAR 0 15
117444: DIFF
117445: ST_TO_ADDR
// end ; if not f_murder then
117446: LD_VAR 0 20
117450: NOT
117451: IFFALSE 117509
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
117453: LD_ADDR_VAR 0 15
117457: PUSH
117458: LD_VAR 0 14
117462: PPUSH
117463: LD_INT 3
117465: PUSH
117466: LD_INT 50
117468: PUSH
117469: EMPTY
117470: LIST
117471: PUSH
117472: EMPTY
117473: LIST
117474: LIST
117475: PPUSH
117476: CALL_OW 72
117480: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
117481: LD_VAR 0 14
117485: PUSH
117486: LD_VAR 0 15
117490: DIFF
117491: IFFALSE 117509
// tmp := tmp diff tmp2 ;
117493: LD_ADDR_VAR 0 14
117497: PUSH
117498: LD_VAR 0 14
117502: PUSH
117503: LD_VAR 0 15
117507: DIFF
117508: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
117509: LD_ADDR_VAR 0 14
117513: PUSH
117514: LD_VAR 0 4
117518: PUSH
117519: LD_VAR 0 7
117523: ARRAY
117524: PPUSH
117525: LD_VAR 0 14
117529: PPUSH
117530: LD_INT 1
117532: PPUSH
117533: LD_INT 1
117535: PPUSH
117536: CALL 58259 0 4
117540: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
117541: LD_VAR 0 4
117545: PUSH
117546: LD_VAR 0 7
117550: ARRAY
117551: PPUSH
117552: CALL_OW 257
117556: PUSH
117557: LD_INT 1
117559: EQUAL
117560: IFFALSE 118008
// begin if WantPlant ( group [ i ] ) then
117562: LD_VAR 0 4
117566: PUSH
117567: LD_VAR 0 7
117571: ARRAY
117572: PPUSH
117573: CALL 57760 0 1
117577: IFFALSE 117581
// continue ;
117579: GO 115853
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
117581: LD_VAR 0 18
117585: PUSH
117586: LD_VAR 0 4
117590: PUSH
117591: LD_VAR 0 7
117595: ARRAY
117596: PPUSH
117597: CALL_OW 310
117601: NOT
117602: AND
117603: PUSH
117604: LD_VAR 0 14
117608: PUSH
117609: LD_INT 1
117611: ARRAY
117612: PUSH
117613: LD_VAR 0 14
117617: PPUSH
117618: LD_INT 21
117620: PUSH
117621: LD_INT 2
117623: PUSH
117624: EMPTY
117625: LIST
117626: LIST
117627: PUSH
117628: LD_INT 58
117630: PUSH
117631: EMPTY
117632: LIST
117633: PUSH
117634: EMPTY
117635: LIST
117636: LIST
117637: PPUSH
117638: CALL_OW 72
117642: IN
117643: AND
117644: IFFALSE 117680
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
117646: LD_VAR 0 4
117650: PUSH
117651: LD_VAR 0 7
117655: ARRAY
117656: PPUSH
117657: LD_VAR 0 14
117661: PUSH
117662: LD_INT 1
117664: ARRAY
117665: PPUSH
117666: CALL_OW 120
// attacking := true ;
117670: LD_ADDR_VAR 0 29
117674: PUSH
117675: LD_INT 1
117677: ST_TO_ADDR
// continue ;
117678: GO 115853
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
117680: LD_VAR 0 26
117684: PUSH
117685: LD_VAR 0 4
117689: PUSH
117690: LD_VAR 0 7
117694: ARRAY
117695: PPUSH
117696: CALL_OW 257
117700: PUSH
117701: LD_INT 1
117703: EQUAL
117704: AND
117705: PUSH
117706: LD_VAR 0 4
117710: PUSH
117711: LD_VAR 0 7
117715: ARRAY
117716: PPUSH
117717: CALL_OW 256
117721: PUSH
117722: LD_INT 800
117724: LESS
117725: AND
117726: PUSH
117727: LD_VAR 0 4
117731: PUSH
117732: LD_VAR 0 7
117736: ARRAY
117737: PPUSH
117738: CALL_OW 318
117742: NOT
117743: AND
117744: IFFALSE 117761
// ComCrawl ( group [ i ] ) ;
117746: LD_VAR 0 4
117750: PUSH
117751: LD_VAR 0 7
117755: ARRAY
117756: PPUSH
117757: CALL_OW 137
// if f_mines then
117761: LD_VAR 0 21
117765: IFFALSE 118008
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
117767: LD_VAR 0 14
117771: PUSH
117772: LD_INT 1
117774: ARRAY
117775: PPUSH
117776: CALL_OW 247
117780: PUSH
117781: LD_INT 3
117783: EQUAL
117784: PUSH
117785: LD_VAR 0 14
117789: PUSH
117790: LD_INT 1
117792: ARRAY
117793: PUSH
117794: LD_VAR 0 27
117798: IN
117799: NOT
117800: AND
117801: IFFALSE 118008
// begin x := GetX ( tmp [ 1 ] ) ;
117803: LD_ADDR_VAR 0 10
117807: PUSH
117808: LD_VAR 0 14
117812: PUSH
117813: LD_INT 1
117815: ARRAY
117816: PPUSH
117817: CALL_OW 250
117821: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
117822: LD_ADDR_VAR 0 11
117826: PUSH
117827: LD_VAR 0 14
117831: PUSH
117832: LD_INT 1
117834: ARRAY
117835: PPUSH
117836: CALL_OW 251
117840: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
117841: LD_ADDR_VAR 0 12
117845: PUSH
117846: LD_VAR 0 4
117850: PUSH
117851: LD_VAR 0 7
117855: ARRAY
117856: PPUSH
117857: CALL 85800 0 1
117861: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
117862: LD_VAR 0 4
117866: PUSH
117867: LD_VAR 0 7
117871: ARRAY
117872: PPUSH
117873: LD_VAR 0 10
117877: PPUSH
117878: LD_VAR 0 11
117882: PPUSH
117883: LD_VAR 0 14
117887: PUSH
117888: LD_INT 1
117890: ARRAY
117891: PPUSH
117892: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
117896: LD_VAR 0 4
117900: PUSH
117901: LD_VAR 0 7
117905: ARRAY
117906: PPUSH
117907: LD_VAR 0 10
117911: PPUSH
117912: LD_VAR 0 12
117916: PPUSH
117917: LD_INT 7
117919: PPUSH
117920: CALL_OW 272
117924: PPUSH
117925: LD_VAR 0 11
117929: PPUSH
117930: LD_VAR 0 12
117934: PPUSH
117935: LD_INT 7
117937: PPUSH
117938: CALL_OW 273
117942: PPUSH
117943: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
117947: LD_VAR 0 4
117951: PUSH
117952: LD_VAR 0 7
117956: ARRAY
117957: PPUSH
117958: LD_INT 71
117960: PPUSH
117961: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
117965: LD_ADDR_VAR 0 27
117969: PUSH
117970: LD_VAR 0 27
117974: PPUSH
117975: LD_VAR 0 27
117979: PUSH
117980: LD_INT 1
117982: PLUS
117983: PPUSH
117984: LD_VAR 0 14
117988: PUSH
117989: LD_INT 1
117991: ARRAY
117992: PPUSH
117993: CALL_OW 1
117997: ST_TO_ADDR
// attacking := true ;
117998: LD_ADDR_VAR 0 29
118002: PUSH
118003: LD_INT 1
118005: ST_TO_ADDR
// continue ;
118006: GO 115853
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
118008: LD_VAR 0 4
118012: PUSH
118013: LD_VAR 0 7
118017: ARRAY
118018: PPUSH
118019: CALL_OW 257
118023: PUSH
118024: LD_INT 17
118026: EQUAL
118027: PUSH
118028: LD_VAR 0 4
118032: PUSH
118033: LD_VAR 0 7
118037: ARRAY
118038: PPUSH
118039: CALL_OW 110
118043: PUSH
118044: LD_INT 71
118046: EQUAL
118047: NOT
118048: AND
118049: IFFALSE 118195
// begin attacking := false ;
118051: LD_ADDR_VAR 0 29
118055: PUSH
118056: LD_INT 0
118058: ST_TO_ADDR
// k := 5 ;
118059: LD_ADDR_VAR 0 9
118063: PUSH
118064: LD_INT 5
118066: ST_TO_ADDR
// if tmp < k then
118067: LD_VAR 0 14
118071: PUSH
118072: LD_VAR 0 9
118076: LESS
118077: IFFALSE 118089
// k := tmp ;
118079: LD_ADDR_VAR 0 9
118083: PUSH
118084: LD_VAR 0 14
118088: ST_TO_ADDR
// for j = 1 to k do
118089: LD_ADDR_VAR 0 8
118093: PUSH
118094: DOUBLE
118095: LD_INT 1
118097: DEC
118098: ST_TO_ADDR
118099: LD_VAR 0 9
118103: PUSH
118104: FOR_TO
118105: IFFALSE 118193
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
118107: LD_VAR 0 14
118111: PUSH
118112: LD_VAR 0 8
118116: ARRAY
118117: PUSH
118118: LD_VAR 0 14
118122: PPUSH
118123: LD_INT 58
118125: PUSH
118126: EMPTY
118127: LIST
118128: PPUSH
118129: CALL_OW 72
118133: IN
118134: NOT
118135: IFFALSE 118191
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118137: LD_VAR 0 4
118141: PUSH
118142: LD_VAR 0 7
118146: ARRAY
118147: PPUSH
118148: LD_VAR 0 14
118152: PUSH
118153: LD_VAR 0 8
118157: ARRAY
118158: PPUSH
118159: CALL_OW 115
// attacking := true ;
118163: LD_ADDR_VAR 0 29
118167: PUSH
118168: LD_INT 1
118170: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
118171: LD_VAR 0 4
118175: PUSH
118176: LD_VAR 0 7
118180: ARRAY
118181: PPUSH
118182: LD_INT 71
118184: PPUSH
118185: CALL_OW 109
// continue ;
118189: GO 118104
// end ; end ;
118191: GO 118104
118193: POP
118194: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
118195: LD_VAR 0 4
118199: PUSH
118200: LD_VAR 0 7
118204: ARRAY
118205: PPUSH
118206: CALL_OW 257
118210: PUSH
118211: LD_INT 8
118213: EQUAL
118214: PUSH
118215: LD_VAR 0 4
118219: PUSH
118220: LD_VAR 0 7
118224: ARRAY
118225: PPUSH
118226: CALL_OW 264
118230: PUSH
118231: LD_INT 28
118233: PUSH
118234: LD_INT 45
118236: PUSH
118237: LD_INT 7
118239: PUSH
118240: LD_INT 47
118242: PUSH
118243: EMPTY
118244: LIST
118245: LIST
118246: LIST
118247: LIST
118248: IN
118249: OR
118250: IFFALSE 118506
// begin attacking := false ;
118252: LD_ADDR_VAR 0 29
118256: PUSH
118257: LD_INT 0
118259: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
118260: LD_VAR 0 14
118264: PUSH
118265: LD_INT 1
118267: ARRAY
118268: PPUSH
118269: CALL_OW 266
118273: PUSH
118274: LD_INT 32
118276: PUSH
118277: LD_INT 31
118279: PUSH
118280: LD_INT 33
118282: PUSH
118283: LD_INT 4
118285: PUSH
118286: LD_INT 5
118288: PUSH
118289: EMPTY
118290: LIST
118291: LIST
118292: LIST
118293: LIST
118294: LIST
118295: IN
118296: IFFALSE 118482
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
118298: LD_ADDR_VAR 0 9
118302: PUSH
118303: LD_VAR 0 14
118307: PUSH
118308: LD_INT 1
118310: ARRAY
118311: PPUSH
118312: CALL_OW 266
118316: PPUSH
118317: LD_VAR 0 14
118321: PUSH
118322: LD_INT 1
118324: ARRAY
118325: PPUSH
118326: CALL_OW 250
118330: PPUSH
118331: LD_VAR 0 14
118335: PUSH
118336: LD_INT 1
118338: ARRAY
118339: PPUSH
118340: CALL_OW 251
118344: PPUSH
118345: LD_VAR 0 14
118349: PUSH
118350: LD_INT 1
118352: ARRAY
118353: PPUSH
118354: CALL_OW 254
118358: PPUSH
118359: LD_VAR 0 14
118363: PUSH
118364: LD_INT 1
118366: ARRAY
118367: PPUSH
118368: CALL_OW 248
118372: PPUSH
118373: LD_INT 0
118375: PPUSH
118376: CALL 67170 0 6
118380: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
118381: LD_ADDR_VAR 0 8
118385: PUSH
118386: LD_VAR 0 4
118390: PUSH
118391: LD_VAR 0 7
118395: ARRAY
118396: PPUSH
118397: LD_VAR 0 9
118401: PPUSH
118402: CALL 85913 0 2
118406: ST_TO_ADDR
// if j then
118407: LD_VAR 0 8
118411: IFFALSE 118480
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
118413: LD_VAR 0 8
118417: PUSH
118418: LD_INT 1
118420: ARRAY
118421: PPUSH
118422: LD_VAR 0 8
118426: PUSH
118427: LD_INT 2
118429: ARRAY
118430: PPUSH
118431: CALL_OW 488
118435: IFFALSE 118480
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
118437: LD_VAR 0 4
118441: PUSH
118442: LD_VAR 0 7
118446: ARRAY
118447: PPUSH
118448: LD_VAR 0 8
118452: PUSH
118453: LD_INT 1
118455: ARRAY
118456: PPUSH
118457: LD_VAR 0 8
118461: PUSH
118462: LD_INT 2
118464: ARRAY
118465: PPUSH
118466: CALL_OW 116
// attacking := true ;
118470: LD_ADDR_VAR 0 29
118474: PUSH
118475: LD_INT 1
118477: ST_TO_ADDR
// continue ;
118478: GO 115853
// end ; end else
118480: GO 118506
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118482: LD_VAR 0 4
118486: PUSH
118487: LD_VAR 0 7
118491: ARRAY
118492: PPUSH
118493: LD_VAR 0 14
118497: PUSH
118498: LD_INT 1
118500: ARRAY
118501: PPUSH
118502: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
118506: LD_VAR 0 4
118510: PUSH
118511: LD_VAR 0 7
118515: ARRAY
118516: PPUSH
118517: CALL_OW 265
118521: PUSH
118522: LD_INT 11
118524: EQUAL
118525: IFFALSE 118803
// begin k := 10 ;
118527: LD_ADDR_VAR 0 9
118531: PUSH
118532: LD_INT 10
118534: ST_TO_ADDR
// x := 0 ;
118535: LD_ADDR_VAR 0 10
118539: PUSH
118540: LD_INT 0
118542: ST_TO_ADDR
// if tmp < k then
118543: LD_VAR 0 14
118547: PUSH
118548: LD_VAR 0 9
118552: LESS
118553: IFFALSE 118565
// k := tmp ;
118555: LD_ADDR_VAR 0 9
118559: PUSH
118560: LD_VAR 0 14
118564: ST_TO_ADDR
// for j = k downto 1 do
118565: LD_ADDR_VAR 0 8
118569: PUSH
118570: DOUBLE
118571: LD_VAR 0 9
118575: INC
118576: ST_TO_ADDR
118577: LD_INT 1
118579: PUSH
118580: FOR_DOWNTO
118581: IFFALSE 118656
// begin if GetType ( tmp [ j ] ) = unit_human then
118583: LD_VAR 0 14
118587: PUSH
118588: LD_VAR 0 8
118592: ARRAY
118593: PPUSH
118594: CALL_OW 247
118598: PUSH
118599: LD_INT 1
118601: EQUAL
118602: IFFALSE 118654
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
118604: LD_VAR 0 4
118608: PUSH
118609: LD_VAR 0 7
118613: ARRAY
118614: PPUSH
118615: LD_VAR 0 14
118619: PUSH
118620: LD_VAR 0 8
118624: ARRAY
118625: PPUSH
118626: CALL 86167 0 2
// x := tmp [ j ] ;
118630: LD_ADDR_VAR 0 10
118634: PUSH
118635: LD_VAR 0 14
118639: PUSH
118640: LD_VAR 0 8
118644: ARRAY
118645: ST_TO_ADDR
// attacking := true ;
118646: LD_ADDR_VAR 0 29
118650: PUSH
118651: LD_INT 1
118653: ST_TO_ADDR
// end ; end ;
118654: GO 118580
118656: POP
118657: POP
// if not x then
118658: LD_VAR 0 10
118662: NOT
118663: IFFALSE 118803
// begin attacking := true ;
118665: LD_ADDR_VAR 0 29
118669: PUSH
118670: LD_INT 1
118672: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
118673: LD_VAR 0 4
118677: PUSH
118678: LD_VAR 0 7
118682: ARRAY
118683: PPUSH
118684: CALL_OW 250
118688: PPUSH
118689: LD_VAR 0 4
118693: PUSH
118694: LD_VAR 0 7
118698: ARRAY
118699: PPUSH
118700: CALL_OW 251
118704: PPUSH
118705: CALL_OW 546
118709: PUSH
118710: LD_INT 2
118712: ARRAY
118713: PUSH
118714: LD_VAR 0 14
118718: PUSH
118719: LD_INT 1
118721: ARRAY
118722: PPUSH
118723: CALL_OW 250
118727: PPUSH
118728: LD_VAR 0 14
118732: PUSH
118733: LD_INT 1
118735: ARRAY
118736: PPUSH
118737: CALL_OW 251
118741: PPUSH
118742: CALL_OW 546
118746: PUSH
118747: LD_INT 2
118749: ARRAY
118750: EQUAL
118751: IFFALSE 118779
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
118753: LD_VAR 0 4
118757: PUSH
118758: LD_VAR 0 7
118762: ARRAY
118763: PPUSH
118764: LD_VAR 0 14
118768: PUSH
118769: LD_INT 1
118771: ARRAY
118772: PPUSH
118773: CALL 86167 0 2
118777: GO 118803
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118779: LD_VAR 0 4
118783: PUSH
118784: LD_VAR 0 7
118788: ARRAY
118789: PPUSH
118790: LD_VAR 0 14
118794: PUSH
118795: LD_INT 1
118797: ARRAY
118798: PPUSH
118799: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
118803: LD_VAR 0 4
118807: PUSH
118808: LD_VAR 0 7
118812: ARRAY
118813: PPUSH
118814: CALL_OW 264
118818: PUSH
118819: LD_INT 29
118821: EQUAL
118822: IFFALSE 119188
// begin if WantsToAttack ( group [ i ] ) in bombed then
118824: LD_VAR 0 4
118828: PUSH
118829: LD_VAR 0 7
118833: ARRAY
118834: PPUSH
118835: CALL_OW 319
118839: PUSH
118840: LD_VAR 0 28
118844: IN
118845: IFFALSE 118849
// continue ;
118847: GO 115853
// k := 8 ;
118849: LD_ADDR_VAR 0 9
118853: PUSH
118854: LD_INT 8
118856: ST_TO_ADDR
// x := 0 ;
118857: LD_ADDR_VAR 0 10
118861: PUSH
118862: LD_INT 0
118864: ST_TO_ADDR
// if tmp < k then
118865: LD_VAR 0 14
118869: PUSH
118870: LD_VAR 0 9
118874: LESS
118875: IFFALSE 118887
// k := tmp ;
118877: LD_ADDR_VAR 0 9
118881: PUSH
118882: LD_VAR 0 14
118886: ST_TO_ADDR
// for j = 1 to k do
118887: LD_ADDR_VAR 0 8
118891: PUSH
118892: DOUBLE
118893: LD_INT 1
118895: DEC
118896: ST_TO_ADDR
118897: LD_VAR 0 9
118901: PUSH
118902: FOR_TO
118903: IFFALSE 119035
// begin if GetType ( tmp [ j ] ) = unit_building then
118905: LD_VAR 0 14
118909: PUSH
118910: LD_VAR 0 8
118914: ARRAY
118915: PPUSH
118916: CALL_OW 247
118920: PUSH
118921: LD_INT 3
118923: EQUAL
118924: IFFALSE 119033
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
118926: LD_VAR 0 14
118930: PUSH
118931: LD_VAR 0 8
118935: ARRAY
118936: PUSH
118937: LD_VAR 0 28
118941: IN
118942: NOT
118943: PUSH
118944: LD_VAR 0 14
118948: PUSH
118949: LD_VAR 0 8
118953: ARRAY
118954: PPUSH
118955: CALL_OW 313
118959: AND
118960: IFFALSE 119033
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118962: LD_VAR 0 4
118966: PUSH
118967: LD_VAR 0 7
118971: ARRAY
118972: PPUSH
118973: LD_VAR 0 14
118977: PUSH
118978: LD_VAR 0 8
118982: ARRAY
118983: PPUSH
118984: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
118988: LD_ADDR_VAR 0 28
118992: PUSH
118993: LD_VAR 0 28
118997: PPUSH
118998: LD_VAR 0 28
119002: PUSH
119003: LD_INT 1
119005: PLUS
119006: PPUSH
119007: LD_VAR 0 14
119011: PUSH
119012: LD_VAR 0 8
119016: ARRAY
119017: PPUSH
119018: CALL_OW 1
119022: ST_TO_ADDR
// attacking := true ;
119023: LD_ADDR_VAR 0 29
119027: PUSH
119028: LD_INT 1
119030: ST_TO_ADDR
// break ;
119031: GO 119035
// end ; end ;
119033: GO 118902
119035: POP
119036: POP
// if not attacking and f_attack_depot then
119037: LD_VAR 0 29
119041: NOT
119042: PUSH
119043: LD_VAR 0 25
119047: AND
119048: IFFALSE 119143
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119050: LD_ADDR_VAR 0 13
119054: PUSH
119055: LD_VAR 0 14
119059: PPUSH
119060: LD_INT 2
119062: PUSH
119063: LD_INT 30
119065: PUSH
119066: LD_INT 0
119068: PUSH
119069: EMPTY
119070: LIST
119071: LIST
119072: PUSH
119073: LD_INT 30
119075: PUSH
119076: LD_INT 1
119078: PUSH
119079: EMPTY
119080: LIST
119081: LIST
119082: PUSH
119083: EMPTY
119084: LIST
119085: LIST
119086: LIST
119087: PPUSH
119088: CALL_OW 72
119092: ST_TO_ADDR
// if z then
119093: LD_VAR 0 13
119097: IFFALSE 119143
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
119099: LD_VAR 0 4
119103: PUSH
119104: LD_VAR 0 7
119108: ARRAY
119109: PPUSH
119110: LD_VAR 0 13
119114: PPUSH
119115: LD_VAR 0 4
119119: PUSH
119120: LD_VAR 0 7
119124: ARRAY
119125: PPUSH
119126: CALL_OW 74
119130: PPUSH
119131: CALL_OW 115
// attacking := true ;
119135: LD_ADDR_VAR 0 29
119139: PUSH
119140: LD_INT 1
119142: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
119143: LD_VAR 0 4
119147: PUSH
119148: LD_VAR 0 7
119152: ARRAY
119153: PPUSH
119154: CALL_OW 256
119158: PUSH
119159: LD_INT 500
119161: LESS
119162: IFFALSE 119188
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119164: LD_VAR 0 4
119168: PUSH
119169: LD_VAR 0 7
119173: ARRAY
119174: PPUSH
119175: LD_VAR 0 14
119179: PUSH
119180: LD_INT 1
119182: ARRAY
119183: PPUSH
119184: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
119188: LD_VAR 0 4
119192: PUSH
119193: LD_VAR 0 7
119197: ARRAY
119198: PPUSH
119199: CALL_OW 264
119203: PUSH
119204: LD_INT 49
119206: EQUAL
119207: IFFALSE 119328
// begin if not HasTask ( group [ i ] ) then
119209: LD_VAR 0 4
119213: PUSH
119214: LD_VAR 0 7
119218: ARRAY
119219: PPUSH
119220: CALL_OW 314
119224: NOT
119225: IFFALSE 119328
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
119227: LD_ADDR_VAR 0 9
119231: PUSH
119232: LD_INT 81
119234: PUSH
119235: LD_VAR 0 4
119239: PUSH
119240: LD_VAR 0 7
119244: ARRAY
119245: PPUSH
119246: CALL_OW 255
119250: PUSH
119251: EMPTY
119252: LIST
119253: LIST
119254: PPUSH
119255: CALL_OW 69
119259: PPUSH
119260: LD_VAR 0 4
119264: PUSH
119265: LD_VAR 0 7
119269: ARRAY
119270: PPUSH
119271: CALL_OW 74
119275: ST_TO_ADDR
// if k then
119276: LD_VAR 0 9
119280: IFFALSE 119328
// if GetDistUnits ( group [ i ] , k ) > 10 then
119282: LD_VAR 0 4
119286: PUSH
119287: LD_VAR 0 7
119291: ARRAY
119292: PPUSH
119293: LD_VAR 0 9
119297: PPUSH
119298: CALL_OW 296
119302: PUSH
119303: LD_INT 10
119305: GREATER
119306: IFFALSE 119328
// ComMoveUnit ( group [ i ] , k ) ;
119308: LD_VAR 0 4
119312: PUSH
119313: LD_VAR 0 7
119317: ARRAY
119318: PPUSH
119319: LD_VAR 0 9
119323: PPUSH
119324: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
119328: LD_VAR 0 4
119332: PUSH
119333: LD_VAR 0 7
119337: ARRAY
119338: PPUSH
119339: CALL_OW 256
119343: PUSH
119344: LD_INT 250
119346: LESS
119347: PUSH
119348: LD_VAR 0 4
119352: PUSH
119353: LD_VAR 0 7
119357: ARRAY
119358: PUSH
119359: LD_INT 21
119361: PUSH
119362: LD_INT 2
119364: PUSH
119365: EMPTY
119366: LIST
119367: LIST
119368: PUSH
119369: LD_INT 23
119371: PUSH
119372: LD_INT 2
119374: PUSH
119375: EMPTY
119376: LIST
119377: LIST
119378: PUSH
119379: EMPTY
119380: LIST
119381: LIST
119382: PPUSH
119383: CALL_OW 69
119387: IN
119388: AND
119389: IFFALSE 119514
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
119391: LD_ADDR_VAR 0 9
119395: PUSH
119396: LD_OWVAR 3
119400: PUSH
119401: LD_VAR 0 4
119405: PUSH
119406: LD_VAR 0 7
119410: ARRAY
119411: DIFF
119412: PPUSH
119413: LD_VAR 0 4
119417: PUSH
119418: LD_VAR 0 7
119422: ARRAY
119423: PPUSH
119424: CALL_OW 74
119428: ST_TO_ADDR
// if not k then
119429: LD_VAR 0 9
119433: NOT
119434: IFFALSE 119438
// continue ;
119436: GO 115853
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
119438: LD_VAR 0 9
119442: PUSH
119443: LD_INT 81
119445: PUSH
119446: LD_VAR 0 4
119450: PUSH
119451: LD_VAR 0 7
119455: ARRAY
119456: PPUSH
119457: CALL_OW 255
119461: PUSH
119462: EMPTY
119463: LIST
119464: LIST
119465: PPUSH
119466: CALL_OW 69
119470: IN
119471: PUSH
119472: LD_VAR 0 9
119476: PPUSH
119477: LD_VAR 0 4
119481: PUSH
119482: LD_VAR 0 7
119486: ARRAY
119487: PPUSH
119488: CALL_OW 296
119492: PUSH
119493: LD_INT 5
119495: LESS
119496: AND
119497: IFFALSE 119514
// ComAutodestruct ( group [ i ] ) ;
119499: LD_VAR 0 4
119503: PUSH
119504: LD_VAR 0 7
119508: ARRAY
119509: PPUSH
119510: CALL 86065 0 1
// end ; if f_attack_depot then
119514: LD_VAR 0 25
119518: IFFALSE 119630
// begin k := 6 ;
119520: LD_ADDR_VAR 0 9
119524: PUSH
119525: LD_INT 6
119527: ST_TO_ADDR
// if tmp < k then
119528: LD_VAR 0 14
119532: PUSH
119533: LD_VAR 0 9
119537: LESS
119538: IFFALSE 119550
// k := tmp ;
119540: LD_ADDR_VAR 0 9
119544: PUSH
119545: LD_VAR 0 14
119549: ST_TO_ADDR
// for j = 1 to k do
119550: LD_ADDR_VAR 0 8
119554: PUSH
119555: DOUBLE
119556: LD_INT 1
119558: DEC
119559: ST_TO_ADDR
119560: LD_VAR 0 9
119564: PUSH
119565: FOR_TO
119566: IFFALSE 119628
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
119568: LD_VAR 0 8
119572: PPUSH
119573: CALL_OW 266
119577: PUSH
119578: LD_INT 0
119580: PUSH
119581: LD_INT 1
119583: PUSH
119584: EMPTY
119585: LIST
119586: LIST
119587: IN
119588: IFFALSE 119626
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119590: LD_VAR 0 4
119594: PUSH
119595: LD_VAR 0 7
119599: ARRAY
119600: PPUSH
119601: LD_VAR 0 14
119605: PUSH
119606: LD_VAR 0 8
119610: ARRAY
119611: PPUSH
119612: CALL_OW 115
// attacking := true ;
119616: LD_ADDR_VAR 0 29
119620: PUSH
119621: LD_INT 1
119623: ST_TO_ADDR
// break ;
119624: GO 119628
// end ;
119626: GO 119565
119628: POP
119629: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
119630: LD_VAR 0 4
119634: PUSH
119635: LD_VAR 0 7
119639: ARRAY
119640: PPUSH
119641: CALL_OW 302
119645: PUSH
119646: LD_VAR 0 29
119650: NOT
119651: AND
119652: IFFALSE 119974
// begin if GetTag ( group [ i ] ) = 71 then
119654: LD_VAR 0 4
119658: PUSH
119659: LD_VAR 0 7
119663: ARRAY
119664: PPUSH
119665: CALL_OW 110
119669: PUSH
119670: LD_INT 71
119672: EQUAL
119673: IFFALSE 119714
// begin if HasTask ( group [ i ] ) then
119675: LD_VAR 0 4
119679: PUSH
119680: LD_VAR 0 7
119684: ARRAY
119685: PPUSH
119686: CALL_OW 314
119690: IFFALSE 119696
// continue else
119692: GO 115853
119694: GO 119714
// SetTag ( group [ i ] , 0 ) ;
119696: LD_VAR 0 4
119700: PUSH
119701: LD_VAR 0 7
119705: ARRAY
119706: PPUSH
119707: LD_INT 0
119709: PPUSH
119710: CALL_OW 109
// end ; k := 8 ;
119714: LD_ADDR_VAR 0 9
119718: PUSH
119719: LD_INT 8
119721: ST_TO_ADDR
// x := 0 ;
119722: LD_ADDR_VAR 0 10
119726: PUSH
119727: LD_INT 0
119729: ST_TO_ADDR
// if tmp < k then
119730: LD_VAR 0 14
119734: PUSH
119735: LD_VAR 0 9
119739: LESS
119740: IFFALSE 119752
// k := tmp ;
119742: LD_ADDR_VAR 0 9
119746: PUSH
119747: LD_VAR 0 14
119751: ST_TO_ADDR
// for j = 1 to k do
119752: LD_ADDR_VAR 0 8
119756: PUSH
119757: DOUBLE
119758: LD_INT 1
119760: DEC
119761: ST_TO_ADDR
119762: LD_VAR 0 9
119766: PUSH
119767: FOR_TO
119768: IFFALSE 119866
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
119770: LD_VAR 0 14
119774: PUSH
119775: LD_VAR 0 8
119779: ARRAY
119780: PPUSH
119781: CALL_OW 247
119785: PUSH
119786: LD_INT 1
119788: EQUAL
119789: PUSH
119790: LD_VAR 0 14
119794: PUSH
119795: LD_VAR 0 8
119799: ARRAY
119800: PPUSH
119801: CALL_OW 256
119805: PUSH
119806: LD_INT 250
119808: LESS
119809: PUSH
119810: LD_VAR 0 20
119814: AND
119815: PUSH
119816: LD_VAR 0 20
119820: NOT
119821: PUSH
119822: LD_VAR 0 14
119826: PUSH
119827: LD_VAR 0 8
119831: ARRAY
119832: PPUSH
119833: CALL_OW 256
119837: PUSH
119838: LD_INT 250
119840: GREATEREQUAL
119841: AND
119842: OR
119843: AND
119844: IFFALSE 119864
// begin x := tmp [ j ] ;
119846: LD_ADDR_VAR 0 10
119850: PUSH
119851: LD_VAR 0 14
119855: PUSH
119856: LD_VAR 0 8
119860: ARRAY
119861: ST_TO_ADDR
// break ;
119862: GO 119866
// end ;
119864: GO 119767
119866: POP
119867: POP
// if x then
119868: LD_VAR 0 10
119872: IFFALSE 119896
// ComAttackUnit ( group [ i ] , x ) else
119874: LD_VAR 0 4
119878: PUSH
119879: LD_VAR 0 7
119883: ARRAY
119884: PPUSH
119885: LD_VAR 0 10
119889: PPUSH
119890: CALL_OW 115
119894: GO 119920
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119896: LD_VAR 0 4
119900: PUSH
119901: LD_VAR 0 7
119905: ARRAY
119906: PPUSH
119907: LD_VAR 0 14
119911: PUSH
119912: LD_INT 1
119914: ARRAY
119915: PPUSH
119916: CALL_OW 115
// if not HasTask ( group [ i ] ) then
119920: LD_VAR 0 4
119924: PUSH
119925: LD_VAR 0 7
119929: ARRAY
119930: PPUSH
119931: CALL_OW 314
119935: NOT
119936: IFFALSE 119974
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
119938: LD_VAR 0 4
119942: PUSH
119943: LD_VAR 0 7
119947: ARRAY
119948: PPUSH
119949: LD_VAR 0 14
119953: PPUSH
119954: LD_VAR 0 4
119958: PUSH
119959: LD_VAR 0 7
119963: ARRAY
119964: PPUSH
119965: CALL_OW 74
119969: PPUSH
119970: CALL_OW 115
// end ; end ; end ;
119974: GO 115853
119976: POP
119977: POP
// wait ( 0 0$2 ) ;
119978: LD_INT 70
119980: PPUSH
119981: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
119985: LD_VAR 0 4
119989: NOT
119990: PUSH
119991: LD_VAR 0 4
119995: PUSH
119996: EMPTY
119997: EQUAL
119998: OR
119999: PUSH
120000: LD_INT 81
120002: PUSH
120003: LD_VAR 0 35
120007: PUSH
120008: EMPTY
120009: LIST
120010: LIST
120011: PPUSH
120012: CALL_OW 69
120016: NOT
120017: OR
120018: IFFALSE 115838
// end ;
120020: LD_VAR 0 2
120024: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
120025: LD_INT 0
120027: PPUSH
120028: PPUSH
120029: PPUSH
120030: PPUSH
120031: PPUSH
120032: PPUSH
// if not base or not mc_bases [ base ] or not solds then
120033: LD_VAR 0 1
120037: NOT
120038: PUSH
120039: LD_EXP 78
120043: PUSH
120044: LD_VAR 0 1
120048: ARRAY
120049: NOT
120050: OR
120051: PUSH
120052: LD_VAR 0 2
120056: NOT
120057: OR
120058: IFFALSE 120062
// exit ;
120060: GO 120616
// side := mc_sides [ base ] ;
120062: LD_ADDR_VAR 0 6
120066: PUSH
120067: LD_EXP 104
120071: PUSH
120072: LD_VAR 0 1
120076: ARRAY
120077: ST_TO_ADDR
// if not side then
120078: LD_VAR 0 6
120082: NOT
120083: IFFALSE 120087
// exit ;
120085: GO 120616
// for i in solds do
120087: LD_ADDR_VAR 0 7
120091: PUSH
120092: LD_VAR 0 2
120096: PUSH
120097: FOR_IN
120098: IFFALSE 120159
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
120100: LD_VAR 0 7
120104: PPUSH
120105: CALL_OW 310
120109: PPUSH
120110: CALL_OW 266
120114: PUSH
120115: LD_INT 32
120117: PUSH
120118: LD_INT 31
120120: PUSH
120121: EMPTY
120122: LIST
120123: LIST
120124: IN
120125: IFFALSE 120145
// solds := solds diff i else
120127: LD_ADDR_VAR 0 2
120131: PUSH
120132: LD_VAR 0 2
120136: PUSH
120137: LD_VAR 0 7
120141: DIFF
120142: ST_TO_ADDR
120143: GO 120157
// SetTag ( i , 18 ) ;
120145: LD_VAR 0 7
120149: PPUSH
120150: LD_INT 18
120152: PPUSH
120153: CALL_OW 109
120157: GO 120097
120159: POP
120160: POP
// if not solds then
120161: LD_VAR 0 2
120165: NOT
120166: IFFALSE 120170
// exit ;
120168: GO 120616
// repeat wait ( 0 0$2 ) ;
120170: LD_INT 70
120172: PPUSH
120173: CALL_OW 67
// enemy := mc_scan [ base ] ;
120177: LD_ADDR_VAR 0 4
120181: PUSH
120182: LD_EXP 101
120186: PUSH
120187: LD_VAR 0 1
120191: ARRAY
120192: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120193: LD_EXP 78
120197: PUSH
120198: LD_VAR 0 1
120202: ARRAY
120203: NOT
120204: PUSH
120205: LD_EXP 78
120209: PUSH
120210: LD_VAR 0 1
120214: ARRAY
120215: PUSH
120216: EMPTY
120217: EQUAL
120218: OR
120219: IFFALSE 120256
// begin for i in solds do
120221: LD_ADDR_VAR 0 7
120225: PUSH
120226: LD_VAR 0 2
120230: PUSH
120231: FOR_IN
120232: IFFALSE 120245
// ComStop ( i ) ;
120234: LD_VAR 0 7
120238: PPUSH
120239: CALL_OW 141
120243: GO 120231
120245: POP
120246: POP
// solds := [ ] ;
120247: LD_ADDR_VAR 0 2
120251: PUSH
120252: EMPTY
120253: ST_TO_ADDR
// exit ;
120254: GO 120616
// end ; for i in solds do
120256: LD_ADDR_VAR 0 7
120260: PUSH
120261: LD_VAR 0 2
120265: PUSH
120266: FOR_IN
120267: IFFALSE 120588
// begin if IsInUnit ( i ) then
120269: LD_VAR 0 7
120273: PPUSH
120274: CALL_OW 310
120278: IFFALSE 120289
// ComExitBuilding ( i ) ;
120280: LD_VAR 0 7
120284: PPUSH
120285: CALL_OW 122
// if GetLives ( i ) > 500 then
120289: LD_VAR 0 7
120293: PPUSH
120294: CALL_OW 256
120298: PUSH
120299: LD_INT 500
120301: GREATER
120302: IFFALSE 120355
// begin e := NearestUnitToUnit ( enemy , i ) ;
120304: LD_ADDR_VAR 0 5
120308: PUSH
120309: LD_VAR 0 4
120313: PPUSH
120314: LD_VAR 0 7
120318: PPUSH
120319: CALL_OW 74
120323: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
120324: LD_VAR 0 7
120328: PPUSH
120329: LD_VAR 0 5
120333: PPUSH
120334: CALL_OW 250
120338: PPUSH
120339: LD_VAR 0 5
120343: PPUSH
120344: CALL_OW 251
120348: PPUSH
120349: CALL_OW 114
// end else
120353: GO 120586
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
120355: LD_VAR 0 7
120359: PPUSH
120360: LD_EXP 78
120364: PUSH
120365: LD_VAR 0 1
120369: ARRAY
120370: PPUSH
120371: LD_INT 2
120373: PUSH
120374: LD_INT 30
120376: PUSH
120377: LD_INT 0
120379: PUSH
120380: EMPTY
120381: LIST
120382: LIST
120383: PUSH
120384: LD_INT 30
120386: PUSH
120387: LD_INT 1
120389: PUSH
120390: EMPTY
120391: LIST
120392: LIST
120393: PUSH
120394: LD_INT 30
120396: PUSH
120397: LD_INT 6
120399: PUSH
120400: EMPTY
120401: LIST
120402: LIST
120403: PUSH
120404: EMPTY
120405: LIST
120406: LIST
120407: LIST
120408: LIST
120409: PPUSH
120410: CALL_OW 72
120414: PPUSH
120415: LD_VAR 0 7
120419: PPUSH
120420: CALL_OW 74
120424: PPUSH
120425: CALL_OW 296
120429: PUSH
120430: LD_INT 10
120432: GREATER
120433: IFFALSE 120586
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
120435: LD_ADDR_VAR 0 8
120439: PUSH
120440: LD_EXP 78
120444: PUSH
120445: LD_VAR 0 1
120449: ARRAY
120450: PPUSH
120451: LD_INT 2
120453: PUSH
120454: LD_INT 30
120456: PUSH
120457: LD_INT 0
120459: PUSH
120460: EMPTY
120461: LIST
120462: LIST
120463: PUSH
120464: LD_INT 30
120466: PUSH
120467: LD_INT 1
120469: PUSH
120470: EMPTY
120471: LIST
120472: LIST
120473: PUSH
120474: LD_INT 30
120476: PUSH
120477: LD_INT 6
120479: PUSH
120480: EMPTY
120481: LIST
120482: LIST
120483: PUSH
120484: EMPTY
120485: LIST
120486: LIST
120487: LIST
120488: LIST
120489: PPUSH
120490: CALL_OW 72
120494: PPUSH
120495: LD_VAR 0 7
120499: PPUSH
120500: CALL_OW 74
120504: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
120505: LD_VAR 0 7
120509: PPUSH
120510: LD_VAR 0 8
120514: PPUSH
120515: CALL_OW 250
120519: PPUSH
120520: LD_INT 3
120522: PPUSH
120523: LD_INT 5
120525: PPUSH
120526: CALL_OW 272
120530: PPUSH
120531: LD_VAR 0 8
120535: PPUSH
120536: CALL_OW 251
120540: PPUSH
120541: LD_INT 3
120543: PPUSH
120544: LD_INT 5
120546: PPUSH
120547: CALL_OW 273
120551: PPUSH
120552: CALL_OW 111
// SetTag ( i , 0 ) ;
120556: LD_VAR 0 7
120560: PPUSH
120561: LD_INT 0
120563: PPUSH
120564: CALL_OW 109
// solds := solds diff i ;
120568: LD_ADDR_VAR 0 2
120572: PUSH
120573: LD_VAR 0 2
120577: PUSH
120578: LD_VAR 0 7
120582: DIFF
120583: ST_TO_ADDR
// continue ;
120584: GO 120266
// end ; end ;
120586: GO 120266
120588: POP
120589: POP
// until not solds or not enemy ;
120590: LD_VAR 0 2
120594: NOT
120595: PUSH
120596: LD_VAR 0 4
120600: NOT
120601: OR
120602: IFFALSE 120170
// MC_Reset ( base , 18 ) ;
120604: LD_VAR 0 1
120608: PPUSH
120609: LD_INT 18
120611: PPUSH
120612: CALL 26323 0 2
// end ;
120616: LD_VAR 0 3
120620: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
120621: LD_INT 0
120623: PPUSH
120624: PPUSH
120625: PPUSH
120626: PPUSH
120627: PPUSH
120628: PPUSH
120629: PPUSH
120630: PPUSH
120631: PPUSH
120632: PPUSH
120633: PPUSH
120634: PPUSH
120635: PPUSH
120636: PPUSH
120637: PPUSH
120638: PPUSH
120639: PPUSH
120640: PPUSH
120641: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
120642: LD_ADDR_VAR 0 12
120646: PUSH
120647: LD_EXP 78
120651: PUSH
120652: LD_VAR 0 1
120656: ARRAY
120657: PPUSH
120658: LD_INT 25
120660: PUSH
120661: LD_INT 3
120663: PUSH
120664: EMPTY
120665: LIST
120666: LIST
120667: PPUSH
120668: CALL_OW 72
120672: ST_TO_ADDR
// if mc_remote_driver [ base ] then
120673: LD_EXP 118
120677: PUSH
120678: LD_VAR 0 1
120682: ARRAY
120683: IFFALSE 120707
// mechs := mechs diff mc_remote_driver [ base ] ;
120685: LD_ADDR_VAR 0 12
120689: PUSH
120690: LD_VAR 0 12
120694: PUSH
120695: LD_EXP 118
120699: PUSH
120700: LD_VAR 0 1
120704: ARRAY
120705: DIFF
120706: ST_TO_ADDR
// for i in mechs do
120707: LD_ADDR_VAR 0 4
120711: PUSH
120712: LD_VAR 0 12
120716: PUSH
120717: FOR_IN
120718: IFFALSE 120753
// if GetTag ( i ) > 0 then
120720: LD_VAR 0 4
120724: PPUSH
120725: CALL_OW 110
120729: PUSH
120730: LD_INT 0
120732: GREATER
120733: IFFALSE 120751
// mechs := mechs diff i ;
120735: LD_ADDR_VAR 0 12
120739: PUSH
120740: LD_VAR 0 12
120744: PUSH
120745: LD_VAR 0 4
120749: DIFF
120750: ST_TO_ADDR
120751: GO 120717
120753: POP
120754: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
120755: LD_ADDR_VAR 0 8
120759: PUSH
120760: LD_EXP 78
120764: PUSH
120765: LD_VAR 0 1
120769: ARRAY
120770: PPUSH
120771: LD_INT 2
120773: PUSH
120774: LD_INT 25
120776: PUSH
120777: LD_INT 1
120779: PUSH
120780: EMPTY
120781: LIST
120782: LIST
120783: PUSH
120784: LD_INT 25
120786: PUSH
120787: LD_INT 5
120789: PUSH
120790: EMPTY
120791: LIST
120792: LIST
120793: PUSH
120794: LD_INT 25
120796: PUSH
120797: LD_INT 8
120799: PUSH
120800: EMPTY
120801: LIST
120802: LIST
120803: PUSH
120804: LD_INT 25
120806: PUSH
120807: LD_INT 9
120809: PUSH
120810: EMPTY
120811: LIST
120812: LIST
120813: PUSH
120814: EMPTY
120815: LIST
120816: LIST
120817: LIST
120818: LIST
120819: LIST
120820: PPUSH
120821: CALL_OW 72
120825: ST_TO_ADDR
// if not defenders and not solds then
120826: LD_VAR 0 2
120830: NOT
120831: PUSH
120832: LD_VAR 0 8
120836: NOT
120837: AND
120838: IFFALSE 120842
// exit ;
120840: GO 122612
// depot_under_attack := false ;
120842: LD_ADDR_VAR 0 16
120846: PUSH
120847: LD_INT 0
120849: ST_TO_ADDR
// sold_defenders := [ ] ;
120850: LD_ADDR_VAR 0 17
120854: PUSH
120855: EMPTY
120856: ST_TO_ADDR
// if mechs then
120857: LD_VAR 0 12
120861: IFFALSE 121014
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
120863: LD_ADDR_VAR 0 4
120867: PUSH
120868: LD_VAR 0 2
120872: PPUSH
120873: LD_INT 21
120875: PUSH
120876: LD_INT 2
120878: PUSH
120879: EMPTY
120880: LIST
120881: LIST
120882: PPUSH
120883: CALL_OW 72
120887: PUSH
120888: FOR_IN
120889: IFFALSE 121012
// begin if GetTag ( i ) <> 20 then
120891: LD_VAR 0 4
120895: PPUSH
120896: CALL_OW 110
120900: PUSH
120901: LD_INT 20
120903: NONEQUAL
120904: IFFALSE 120918
// SetTag ( i , 20 ) ;
120906: LD_VAR 0 4
120910: PPUSH
120911: LD_INT 20
120913: PPUSH
120914: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
120918: LD_VAR 0 4
120922: PPUSH
120923: CALL_OW 263
120927: PUSH
120928: LD_INT 1
120930: EQUAL
120931: PUSH
120932: LD_VAR 0 4
120936: PPUSH
120937: CALL_OW 311
120941: NOT
120942: AND
120943: IFFALSE 121010
// begin un := mechs [ 1 ] ;
120945: LD_ADDR_VAR 0 10
120949: PUSH
120950: LD_VAR 0 12
120954: PUSH
120955: LD_INT 1
120957: ARRAY
120958: ST_TO_ADDR
// ComExit ( un ) ;
120959: LD_VAR 0 10
120963: PPUSH
120964: CALL 90962 0 1
// AddComEnterUnit ( un , i ) ;
120968: LD_VAR 0 10
120972: PPUSH
120973: LD_VAR 0 4
120977: PPUSH
120978: CALL_OW 180
// SetTag ( un , 19 ) ;
120982: LD_VAR 0 10
120986: PPUSH
120987: LD_INT 19
120989: PPUSH
120990: CALL_OW 109
// mechs := mechs diff un ;
120994: LD_ADDR_VAR 0 12
120998: PUSH
120999: LD_VAR 0 12
121003: PUSH
121004: LD_VAR 0 10
121008: DIFF
121009: ST_TO_ADDR
// end ; end ;
121010: GO 120888
121012: POP
121013: POP
// if solds then
121014: LD_VAR 0 8
121018: IFFALSE 121077
// for i in solds do
121020: LD_ADDR_VAR 0 4
121024: PUSH
121025: LD_VAR 0 8
121029: PUSH
121030: FOR_IN
121031: IFFALSE 121075
// if not GetTag ( i ) then
121033: LD_VAR 0 4
121037: PPUSH
121038: CALL_OW 110
121042: NOT
121043: IFFALSE 121073
// begin defenders := defenders union i ;
121045: LD_ADDR_VAR 0 2
121049: PUSH
121050: LD_VAR 0 2
121054: PUSH
121055: LD_VAR 0 4
121059: UNION
121060: ST_TO_ADDR
// SetTag ( i , 18 ) ;
121061: LD_VAR 0 4
121065: PPUSH
121066: LD_INT 18
121068: PPUSH
121069: CALL_OW 109
// end ;
121073: GO 121030
121075: POP
121076: POP
// repeat wait ( 0 0$2 ) ;
121077: LD_INT 70
121079: PPUSH
121080: CALL_OW 67
// enemy := mc_scan [ base ] ;
121084: LD_ADDR_VAR 0 21
121088: PUSH
121089: LD_EXP 101
121093: PUSH
121094: LD_VAR 0 1
121098: ARRAY
121099: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121100: LD_EXP 78
121104: PUSH
121105: LD_VAR 0 1
121109: ARRAY
121110: NOT
121111: PUSH
121112: LD_EXP 78
121116: PUSH
121117: LD_VAR 0 1
121121: ARRAY
121122: PUSH
121123: EMPTY
121124: EQUAL
121125: OR
121126: IFFALSE 121163
// begin for i in defenders do
121128: LD_ADDR_VAR 0 4
121132: PUSH
121133: LD_VAR 0 2
121137: PUSH
121138: FOR_IN
121139: IFFALSE 121152
// ComStop ( i ) ;
121141: LD_VAR 0 4
121145: PPUSH
121146: CALL_OW 141
121150: GO 121138
121152: POP
121153: POP
// defenders := [ ] ;
121154: LD_ADDR_VAR 0 2
121158: PUSH
121159: EMPTY
121160: ST_TO_ADDR
// exit ;
121161: GO 122612
// end ; for i in defenders do
121163: LD_ADDR_VAR 0 4
121167: PUSH
121168: LD_VAR 0 2
121172: PUSH
121173: FOR_IN
121174: IFFALSE 122072
// begin e := NearestUnitToUnit ( enemy , i ) ;
121176: LD_ADDR_VAR 0 13
121180: PUSH
121181: LD_VAR 0 21
121185: PPUSH
121186: LD_VAR 0 4
121190: PPUSH
121191: CALL_OW 74
121195: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
121196: LD_ADDR_VAR 0 7
121200: PUSH
121201: LD_EXP 78
121205: PUSH
121206: LD_VAR 0 1
121210: ARRAY
121211: PPUSH
121212: LD_INT 2
121214: PUSH
121215: LD_INT 30
121217: PUSH
121218: LD_INT 0
121220: PUSH
121221: EMPTY
121222: LIST
121223: LIST
121224: PUSH
121225: LD_INT 30
121227: PUSH
121228: LD_INT 1
121230: PUSH
121231: EMPTY
121232: LIST
121233: LIST
121234: PUSH
121235: EMPTY
121236: LIST
121237: LIST
121238: LIST
121239: PPUSH
121240: CALL_OW 72
121244: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
121245: LD_ADDR_VAR 0 16
121249: PUSH
121250: LD_VAR 0 7
121254: NOT
121255: PUSH
121256: LD_VAR 0 7
121260: PPUSH
121261: LD_INT 3
121263: PUSH
121264: LD_INT 24
121266: PUSH
121267: LD_INT 600
121269: PUSH
121270: EMPTY
121271: LIST
121272: LIST
121273: PUSH
121274: EMPTY
121275: LIST
121276: LIST
121277: PPUSH
121278: CALL_OW 72
121282: OR
121283: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
121284: LD_VAR 0 4
121288: PPUSH
121289: CALL_OW 247
121293: PUSH
121294: LD_INT 2
121296: DOUBLE
121297: EQUAL
121298: IFTRUE 121302
121300: GO 121698
121302: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
121303: LD_VAR 0 4
121307: PPUSH
121308: CALL_OW 256
121312: PUSH
121313: LD_INT 1000
121315: EQUAL
121316: PUSH
121317: LD_VAR 0 4
121321: PPUSH
121322: LD_VAR 0 13
121326: PPUSH
121327: CALL_OW 296
121331: PUSH
121332: LD_INT 40
121334: LESS
121335: PUSH
121336: LD_VAR 0 13
121340: PPUSH
121341: LD_EXP 103
121345: PUSH
121346: LD_VAR 0 1
121350: ARRAY
121351: PPUSH
121352: CALL_OW 308
121356: OR
121357: AND
121358: IFFALSE 121480
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
121360: LD_VAR 0 4
121364: PPUSH
121365: CALL_OW 262
121369: PUSH
121370: LD_INT 1
121372: EQUAL
121373: PUSH
121374: LD_VAR 0 4
121378: PPUSH
121379: CALL_OW 261
121383: PUSH
121384: LD_INT 30
121386: LESS
121387: AND
121388: PUSH
121389: LD_VAR 0 7
121393: AND
121394: IFFALSE 121464
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
121396: LD_VAR 0 4
121400: PPUSH
121401: LD_VAR 0 7
121405: PPUSH
121406: LD_VAR 0 4
121410: PPUSH
121411: CALL_OW 74
121415: PPUSH
121416: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
121420: LD_VAR 0 4
121424: PPUSH
121425: LD_VAR 0 7
121429: PPUSH
121430: LD_VAR 0 4
121434: PPUSH
121435: CALL_OW 74
121439: PPUSH
121440: CALL_OW 296
121444: PUSH
121445: LD_INT 6
121447: LESS
121448: IFFALSE 121462
// SetFuel ( i , 100 ) ;
121450: LD_VAR 0 4
121454: PPUSH
121455: LD_INT 100
121457: PPUSH
121458: CALL_OW 240
// end else
121462: GO 121478
// ComAttackUnit ( i , e ) ;
121464: LD_VAR 0 4
121468: PPUSH
121469: LD_VAR 0 13
121473: PPUSH
121474: CALL_OW 115
// end else
121478: GO 121581
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
121480: LD_VAR 0 13
121484: PPUSH
121485: LD_EXP 103
121489: PUSH
121490: LD_VAR 0 1
121494: ARRAY
121495: PPUSH
121496: CALL_OW 308
121500: NOT
121501: PUSH
121502: LD_VAR 0 4
121506: PPUSH
121507: LD_VAR 0 13
121511: PPUSH
121512: CALL_OW 296
121516: PUSH
121517: LD_INT 40
121519: GREATEREQUAL
121520: AND
121521: PUSH
121522: LD_VAR 0 4
121526: PPUSH
121527: CALL_OW 256
121531: PUSH
121532: LD_INT 650
121534: LESSEQUAL
121535: OR
121536: PUSH
121537: LD_VAR 0 4
121541: PPUSH
121542: LD_EXP 102
121546: PUSH
121547: LD_VAR 0 1
121551: ARRAY
121552: PPUSH
121553: CALL_OW 308
121557: NOT
121558: AND
121559: IFFALSE 121581
// ComMoveToArea ( i , mc_parking [ base ] ) ;
121561: LD_VAR 0 4
121565: PPUSH
121566: LD_EXP 102
121570: PUSH
121571: LD_VAR 0 1
121575: ARRAY
121576: PPUSH
121577: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
121581: LD_VAR 0 4
121585: PPUSH
121586: CALL_OW 256
121590: PUSH
121591: LD_INT 1000
121593: LESS
121594: PUSH
121595: LD_VAR 0 4
121599: PPUSH
121600: CALL_OW 263
121604: PUSH
121605: LD_INT 1
121607: EQUAL
121608: AND
121609: PUSH
121610: LD_VAR 0 4
121614: PPUSH
121615: CALL_OW 311
121619: AND
121620: PUSH
121621: LD_VAR 0 4
121625: PPUSH
121626: LD_EXP 102
121630: PUSH
121631: LD_VAR 0 1
121635: ARRAY
121636: PPUSH
121637: CALL_OW 308
121641: AND
121642: IFFALSE 121696
// begin mech := IsDrivenBy ( i ) ;
121644: LD_ADDR_VAR 0 9
121648: PUSH
121649: LD_VAR 0 4
121653: PPUSH
121654: CALL_OW 311
121658: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
121659: LD_VAR 0 9
121663: PPUSH
121664: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
121668: LD_VAR 0 9
121672: PPUSH
121673: LD_VAR 0 4
121677: PPUSH
121678: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
121682: LD_VAR 0 9
121686: PPUSH
121687: LD_VAR 0 4
121691: PPUSH
121692: CALL_OW 180
// end ; end ; unit_human :
121696: GO 122043
121698: LD_INT 1
121700: DOUBLE
121701: EQUAL
121702: IFTRUE 121706
121704: GO 122042
121706: POP
// begin b := IsInUnit ( i ) ;
121707: LD_ADDR_VAR 0 18
121711: PUSH
121712: LD_VAR 0 4
121716: PPUSH
121717: CALL_OW 310
121721: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
121722: LD_ADDR_VAR 0 19
121726: PUSH
121727: LD_VAR 0 18
121731: NOT
121732: PUSH
121733: LD_VAR 0 18
121737: PPUSH
121738: CALL_OW 266
121742: PUSH
121743: LD_INT 32
121745: PUSH
121746: LD_INT 31
121748: PUSH
121749: EMPTY
121750: LIST
121751: LIST
121752: IN
121753: OR
121754: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
121755: LD_VAR 0 18
121759: PPUSH
121760: CALL_OW 266
121764: PUSH
121765: LD_INT 5
121767: EQUAL
121768: PUSH
121769: LD_VAR 0 4
121773: PPUSH
121774: CALL_OW 257
121778: PUSH
121779: LD_INT 1
121781: PUSH
121782: LD_INT 2
121784: PUSH
121785: LD_INT 3
121787: PUSH
121788: LD_INT 4
121790: PUSH
121791: EMPTY
121792: LIST
121793: LIST
121794: LIST
121795: LIST
121796: IN
121797: AND
121798: IFFALSE 121835
// begin class := AllowSpecClass ( i ) ;
121800: LD_ADDR_VAR 0 20
121804: PUSH
121805: LD_VAR 0 4
121809: PPUSH
121810: CALL 54648 0 1
121814: ST_TO_ADDR
// if class then
121815: LD_VAR 0 20
121819: IFFALSE 121835
// ComChangeProfession ( i , class ) ;
121821: LD_VAR 0 4
121825: PPUSH
121826: LD_VAR 0 20
121830: PPUSH
121831: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
121835: LD_VAR 0 16
121839: PUSH
121840: LD_VAR 0 2
121844: PPUSH
121845: LD_INT 21
121847: PUSH
121848: LD_INT 2
121850: PUSH
121851: EMPTY
121852: LIST
121853: LIST
121854: PPUSH
121855: CALL_OW 72
121859: PUSH
121860: LD_INT 1
121862: LESSEQUAL
121863: OR
121864: PUSH
121865: LD_VAR 0 19
121869: AND
121870: PUSH
121871: LD_VAR 0 4
121875: PUSH
121876: LD_VAR 0 17
121880: IN
121881: NOT
121882: AND
121883: IFFALSE 121976
// begin if b then
121885: LD_VAR 0 18
121889: IFFALSE 121938
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
121891: LD_VAR 0 18
121895: PPUSH
121896: LD_VAR 0 21
121900: PPUSH
121901: LD_VAR 0 18
121905: PPUSH
121906: CALL_OW 74
121910: PPUSH
121911: CALL_OW 296
121915: PUSH
121916: LD_INT 10
121918: LESS
121919: PUSH
121920: LD_VAR 0 18
121924: PPUSH
121925: CALL_OW 461
121929: PUSH
121930: LD_INT 7
121932: NONEQUAL
121933: AND
121934: IFFALSE 121938
// continue ;
121936: GO 121173
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
121938: LD_ADDR_VAR 0 17
121942: PUSH
121943: LD_VAR 0 17
121947: PPUSH
121948: LD_VAR 0 17
121952: PUSH
121953: LD_INT 1
121955: PLUS
121956: PPUSH
121957: LD_VAR 0 4
121961: PPUSH
121962: CALL_OW 1
121966: ST_TO_ADDR
// ComExitBuilding ( i ) ;
121967: LD_VAR 0 4
121971: PPUSH
121972: CALL_OW 122
// end ; if sold_defenders then
121976: LD_VAR 0 17
121980: IFFALSE 122040
// if i in sold_defenders then
121982: LD_VAR 0 4
121986: PUSH
121987: LD_VAR 0 17
121991: IN
121992: IFFALSE 122040
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
121994: LD_VAR 0 4
121998: PPUSH
121999: CALL_OW 314
122003: NOT
122004: PUSH
122005: LD_VAR 0 4
122009: PPUSH
122010: LD_VAR 0 13
122014: PPUSH
122015: CALL_OW 296
122019: PUSH
122020: LD_INT 30
122022: LESS
122023: AND
122024: IFFALSE 122040
// ComAttackUnit ( i , e ) ;
122026: LD_VAR 0 4
122030: PPUSH
122031: LD_VAR 0 13
122035: PPUSH
122036: CALL_OW 115
// end ; end ; end ;
122040: GO 122043
122042: POP
// if IsDead ( i ) then
122043: LD_VAR 0 4
122047: PPUSH
122048: CALL_OW 301
122052: IFFALSE 122070
// defenders := defenders diff i ;
122054: LD_ADDR_VAR 0 2
122058: PUSH
122059: LD_VAR 0 2
122063: PUSH
122064: LD_VAR 0 4
122068: DIFF
122069: ST_TO_ADDR
// end ;
122070: GO 121173
122072: POP
122073: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
122074: LD_VAR 0 21
122078: NOT
122079: PUSH
122080: LD_VAR 0 2
122084: NOT
122085: OR
122086: PUSH
122087: LD_EXP 78
122091: PUSH
122092: LD_VAR 0 1
122096: ARRAY
122097: NOT
122098: OR
122099: IFFALSE 121077
// MC_Reset ( base , 18 ) ;
122101: LD_VAR 0 1
122105: PPUSH
122106: LD_INT 18
122108: PPUSH
122109: CALL 26323 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
122113: LD_ADDR_VAR 0 2
122117: PUSH
122118: LD_VAR 0 2
122122: PUSH
122123: LD_VAR 0 2
122127: PPUSH
122128: LD_INT 2
122130: PUSH
122131: LD_INT 25
122133: PUSH
122134: LD_INT 1
122136: PUSH
122137: EMPTY
122138: LIST
122139: LIST
122140: PUSH
122141: LD_INT 25
122143: PUSH
122144: LD_INT 5
122146: PUSH
122147: EMPTY
122148: LIST
122149: LIST
122150: PUSH
122151: LD_INT 25
122153: PUSH
122154: LD_INT 8
122156: PUSH
122157: EMPTY
122158: LIST
122159: LIST
122160: PUSH
122161: LD_INT 25
122163: PUSH
122164: LD_INT 9
122166: PUSH
122167: EMPTY
122168: LIST
122169: LIST
122170: PUSH
122171: EMPTY
122172: LIST
122173: LIST
122174: LIST
122175: LIST
122176: LIST
122177: PPUSH
122178: CALL_OW 72
122182: DIFF
122183: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
122184: LD_VAR 0 21
122188: NOT
122189: PUSH
122190: LD_VAR 0 2
122194: PPUSH
122195: LD_INT 21
122197: PUSH
122198: LD_INT 2
122200: PUSH
122201: EMPTY
122202: LIST
122203: LIST
122204: PPUSH
122205: CALL_OW 72
122209: AND
122210: IFFALSE 122548
// begin tmp := FilterByTag ( defenders , 19 ) ;
122212: LD_ADDR_VAR 0 11
122216: PUSH
122217: LD_VAR 0 2
122221: PPUSH
122222: LD_INT 19
122224: PPUSH
122225: CALL 88133 0 2
122229: ST_TO_ADDR
// if tmp then
122230: LD_VAR 0 11
122234: IFFALSE 122304
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
122236: LD_ADDR_VAR 0 11
122240: PUSH
122241: LD_VAR 0 11
122245: PPUSH
122246: LD_INT 25
122248: PUSH
122249: LD_INT 3
122251: PUSH
122252: EMPTY
122253: LIST
122254: LIST
122255: PPUSH
122256: CALL_OW 72
122260: ST_TO_ADDR
// if tmp then
122261: LD_VAR 0 11
122265: IFFALSE 122304
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
122267: LD_ADDR_EXP 90
122271: PUSH
122272: LD_EXP 90
122276: PPUSH
122277: LD_VAR 0 1
122281: PPUSH
122282: LD_EXP 90
122286: PUSH
122287: LD_VAR 0 1
122291: ARRAY
122292: PUSH
122293: LD_VAR 0 11
122297: UNION
122298: PPUSH
122299: CALL_OW 1
122303: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
122304: LD_VAR 0 1
122308: PPUSH
122309: LD_INT 19
122311: PPUSH
122312: CALL 26323 0 2
// repeat wait ( 0 0$1 ) ;
122316: LD_INT 35
122318: PPUSH
122319: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122323: LD_EXP 78
122327: PUSH
122328: LD_VAR 0 1
122332: ARRAY
122333: NOT
122334: PUSH
122335: LD_EXP 78
122339: PUSH
122340: LD_VAR 0 1
122344: ARRAY
122345: PUSH
122346: EMPTY
122347: EQUAL
122348: OR
122349: IFFALSE 122386
// begin for i in defenders do
122351: LD_ADDR_VAR 0 4
122355: PUSH
122356: LD_VAR 0 2
122360: PUSH
122361: FOR_IN
122362: IFFALSE 122375
// ComStop ( i ) ;
122364: LD_VAR 0 4
122368: PPUSH
122369: CALL_OW 141
122373: GO 122361
122375: POP
122376: POP
// defenders := [ ] ;
122377: LD_ADDR_VAR 0 2
122381: PUSH
122382: EMPTY
122383: ST_TO_ADDR
// exit ;
122384: GO 122612
// end ; for i in defenders do
122386: LD_ADDR_VAR 0 4
122390: PUSH
122391: LD_VAR 0 2
122395: PUSH
122396: FOR_IN
122397: IFFALSE 122486
// begin if not IsInArea ( i , mc_parking [ base ] ) then
122399: LD_VAR 0 4
122403: PPUSH
122404: LD_EXP 102
122408: PUSH
122409: LD_VAR 0 1
122413: ARRAY
122414: PPUSH
122415: CALL_OW 308
122419: NOT
122420: IFFALSE 122444
// ComMoveToArea ( i , mc_parking [ base ] ) else
122422: LD_VAR 0 4
122426: PPUSH
122427: LD_EXP 102
122431: PUSH
122432: LD_VAR 0 1
122436: ARRAY
122437: PPUSH
122438: CALL_OW 113
122442: GO 122484
// if GetControl ( i ) = control_manual then
122444: LD_VAR 0 4
122448: PPUSH
122449: CALL_OW 263
122453: PUSH
122454: LD_INT 1
122456: EQUAL
122457: IFFALSE 122484
// if IsDrivenBy ( i ) then
122459: LD_VAR 0 4
122463: PPUSH
122464: CALL_OW 311
122468: IFFALSE 122484
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
122470: LD_VAR 0 4
122474: PPUSH
122475: CALL_OW 311
122479: PPUSH
122480: CALL_OW 121
// end ;
122484: GO 122396
122486: POP
122487: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
122488: LD_VAR 0 2
122492: PPUSH
122493: LD_INT 95
122495: PUSH
122496: LD_EXP 102
122500: PUSH
122501: LD_VAR 0 1
122505: ARRAY
122506: PUSH
122507: EMPTY
122508: LIST
122509: LIST
122510: PPUSH
122511: CALL_OW 72
122515: PUSH
122516: LD_VAR 0 2
122520: EQUAL
122521: PUSH
122522: LD_EXP 101
122526: PUSH
122527: LD_VAR 0 1
122531: ARRAY
122532: OR
122533: PUSH
122534: LD_EXP 78
122538: PUSH
122539: LD_VAR 0 1
122543: ARRAY
122544: NOT
122545: OR
122546: IFFALSE 122316
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
122548: LD_ADDR_EXP 100
122552: PUSH
122553: LD_EXP 100
122557: PPUSH
122558: LD_VAR 0 1
122562: PPUSH
122563: LD_VAR 0 2
122567: PPUSH
122568: LD_INT 21
122570: PUSH
122571: LD_INT 2
122573: PUSH
122574: EMPTY
122575: LIST
122576: LIST
122577: PPUSH
122578: CALL_OW 72
122582: PPUSH
122583: CALL_OW 1
122587: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
122588: LD_VAR 0 1
122592: PPUSH
122593: LD_INT 19
122595: PPUSH
122596: CALL 26323 0 2
// MC_Reset ( base , 20 ) ;
122600: LD_VAR 0 1
122604: PPUSH
122605: LD_INT 20
122607: PPUSH
122608: CALL 26323 0 2
// end ; end_of_file
122612: LD_VAR 0 3
122616: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
122617: LD_VAR 0 1
122621: PUSH
122622: LD_INT 200
122624: DOUBLE
122625: GREATEREQUAL
122626: IFFALSE 122634
122628: LD_INT 299
122630: DOUBLE
122631: LESSEQUAL
122632: IFTRUE 122636
122634: GO 122668
122636: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
122637: LD_VAR 0 1
122641: PPUSH
122642: LD_VAR 0 2
122646: PPUSH
122647: LD_VAR 0 3
122651: PPUSH
122652: LD_VAR 0 4
122656: PPUSH
122657: LD_VAR 0 5
122661: PPUSH
122662: CALL 110964 0 5
122666: GO 122745
122668: LD_INT 300
122670: DOUBLE
122671: GREATEREQUAL
122672: IFFALSE 122680
122674: LD_INT 399
122676: DOUBLE
122677: LESSEQUAL
122678: IFTRUE 122682
122680: GO 122744
122682: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
122683: LD_VAR 0 1
122687: PPUSH
122688: LD_VAR 0 2
122692: PPUSH
122693: LD_VAR 0 3
122697: PPUSH
122698: LD_VAR 0 4
122702: PPUSH
122703: LD_VAR 0 5
122707: PPUSH
122708: LD_VAR 0 6
122712: PPUSH
122713: LD_VAR 0 7
122717: PPUSH
122718: LD_VAR 0 8
122722: PPUSH
122723: LD_VAR 0 9
122727: PPUSH
122728: LD_VAR 0 10
122732: PPUSH
122733: LD_VAR 0 11
122737: PPUSH
122738: CALL 107289 0 11
122742: GO 122745
122744: POP
// end ;
122745: PPOPN 11
122747: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
122748: LD_VAR 0 1
122752: PPUSH
122753: LD_VAR 0 2
122757: PPUSH
122758: LD_VAR 0 3
122762: PPUSH
122763: LD_VAR 0 4
122767: PPUSH
122768: LD_VAR 0 5
122772: PPUSH
122773: CALL 110700 0 5
// end ; end_of_file
122777: PPOPN 5
122779: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
122780: LD_VAR 0 1
122784: PPUSH
122785: LD_VAR 0 2
122789: PPUSH
122790: LD_VAR 0 3
122794: PPUSH
122795: LD_VAR 0 4
122799: PPUSH
122800: LD_VAR 0 5
122804: PPUSH
122805: LD_VAR 0 6
122809: PPUSH
122810: CALL 94941 0 6
// end ;
122814: PPOPN 6
122816: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
122817: LD_INT 0
122819: PPUSH
// begin if not units then
122820: LD_VAR 0 1
122824: NOT
122825: IFFALSE 122829
// exit ;
122827: GO 122829
// end ;
122829: PPOPN 7
122831: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
122832: CALL 94845 0 0
// end ;
122836: PPOPN 1
122838: END
