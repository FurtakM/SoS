// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 22154 0 0
// InitNature ;
  19: CALL 18820 0 0
// InitArtifact ;
  23: CALL 19437 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5102 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 6941 0 0
// PrepareRussian ;
  52: CALL 9061 0 0
// PrepareLegion ;
  56: CALL 7438 0 0
// Action ;
  60: CALL 11885 0 0
// MC_Start ( ) ;
  64: CALL 24334 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 102
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 103
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 46037 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 47116 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 47209 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 107
 353: PUSH
 354: LD_EXP 107
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 46374 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 46559 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 47116 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 47209 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 46374 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 46559 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 46989 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 46037 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 47116 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 47209 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 107
 843: PUSH
 844: LD_EXP 107
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 46374 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 46559 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 47116 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 47209 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 47527 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 47321 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 46374 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 46559 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 46940 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// uc_side := 7 ;
1443: LD_ADDR_OWVAR 20
1447: PUSH
1448: LD_INT 7
1450: ST_TO_ADDR
// tmp := [ ] ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: EMPTY
1457: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1458: LD_ADDR_EXP 19
1462: PUSH
1463: LD_STRING JMM
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: LD_STRING 14a_
1474: PPUSH
1475: CALL 52848 0 3
1479: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1480: LD_ADDR_EXP 52
1484: PUSH
1485: LD_STRING Burlak
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: LD_STRING 14a_
1496: PPUSH
1497: CALL 52848 0 3
1501: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1502: LD_ADDR_EXP 34
1506: PUSH
1507: LD_STRING Joan
1509: PPUSH
1510: LD_EXP 1
1514: NOT
1515: PPUSH
1516: LD_STRING 13a_
1518: PPUSH
1519: CALL 52848 0 3
1523: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1524: LD_ADDR_EXP 20
1528: PUSH
1529: LD_STRING Roth
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_STRING 13a_
1540: PPUSH
1541: CALL 52848 0 3
1545: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1546: LD_ADDR_EXP 38
1550: PUSH
1551: LD_STRING Gossudarov
1553: PPUSH
1554: LD_EXP 1
1558: NOT
1559: PPUSH
1560: LD_STRING 13a_
1562: PPUSH
1563: CALL 52848 0 3
1567: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1568: LD_ADDR_EXP 25
1572: PUSH
1573: LD_STRING Denis
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 13a_
1584: PPUSH
1585: CALL 52848 0 3
1589: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING DeltaDoctor
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 13a_
1606: PPUSH
1607: CALL 52848 0 3
1611: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1612: LD_ADDR_EXP 37
1616: PUSH
1617: LD_STRING Mike
1619: PPUSH
1620: LD_EXP 1
1624: NOT
1625: PPUSH
1626: LD_STRING 13a_
1628: PPUSH
1629: CALL 52848 0 3
1633: ST_TO_ADDR
// if DeltaDoctor then
1634: LD_EXP 35
1638: IFFALSE 1656
// tmp := tmp ^ DeltaDoctor ;
1640: LD_ADDR_VAR 0 5
1644: PUSH
1645: LD_VAR 0 5
1649: PUSH
1650: LD_EXP 35
1654: ADD
1655: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1656: LD_ADDR_EXP 33
1660: PUSH
1661: LD_STRING Simms
1663: PPUSH
1664: LD_EXP 1
1668: NOT
1669: PPUSH
1670: LD_STRING 13a_
1672: PPUSH
1673: CALL 52848 0 3
1677: ST_TO_ADDR
// if Simms then
1678: LD_EXP 33
1682: IFFALSE 1700
// tmp := tmp ^ Simms ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_VAR 0 5
1693: PUSH
1694: LD_EXP 33
1698: ADD
1699: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1700: LD_ADDR_EXP 31
1704: PUSH
1705: LD_STRING Frank
1707: PPUSH
1708: LD_EXP 1
1712: NOT
1713: PPUSH
1714: LD_STRING 13a_
1716: PPUSH
1717: CALL 52848 0 3
1721: ST_TO_ADDR
// if Frank then
1722: LD_EXP 31
1726: IFFALSE 1744
// tmp := tmp ^ Frank ;
1728: LD_ADDR_VAR 0 5
1732: PUSH
1733: LD_VAR 0 5
1737: PUSH
1738: LD_EXP 31
1742: ADD
1743: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1744: LD_ADDR_EXP 39
1748: PUSH
1749: LD_STRING Kirilenkova
1751: PPUSH
1752: LD_EXP 1
1756: NOT
1757: PPUSH
1758: LD_STRING 13a_
1760: PPUSH
1761: CALL 52848 0 3
1765: ST_TO_ADDR
// if Kirilenkova then
1766: LD_EXP 39
1770: IFFALSE 1788
// tmp := tmp ^ Kirilenkova ;
1772: LD_ADDR_VAR 0 5
1776: PUSH
1777: LD_VAR 0 5
1781: PUSH
1782: LD_EXP 39
1786: ADD
1787: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1788: LD_ADDR_EXP 40
1792: PUSH
1793: LD_STRING Titov
1795: PPUSH
1796: LD_EXP 1
1800: NOT
1801: PPUSH
1802: LD_STRING 13a_
1804: PPUSH
1805: CALL 52848 0 3
1809: ST_TO_ADDR
// if Titov then
1810: LD_EXP 40
1814: IFFALSE 1832
// tmp := tmp ^ Titov ;
1816: LD_ADDR_VAR 0 5
1820: PUSH
1821: LD_VAR 0 5
1825: PUSH
1826: LD_EXP 40
1830: ADD
1831: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1832: LD_ADDR_EXP 41
1836: PUSH
1837: LD_STRING Fadeev
1839: PPUSH
1840: LD_EXP 1
1844: NOT
1845: PPUSH
1846: LD_STRING 13a_
1848: PPUSH
1849: CALL 52848 0 3
1853: ST_TO_ADDR
// if Fadeev then
1854: LD_EXP 41
1858: IFFALSE 1876
// tmp := tmp ^ Fadeev ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_EXP 41
1874: ADD
1875: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1876: LD_ADDR_EXP 42
1880: PUSH
1881: LD_STRING Dolgov
1883: PPUSH
1884: LD_EXP 1
1888: NOT
1889: PPUSH
1890: LD_STRING 13a_
1892: PPUSH
1893: CALL 52848 0 3
1897: ST_TO_ADDR
// if Dolgov then
1898: LD_EXP 42
1902: IFFALSE 1920
// tmp := tmp ^ Dolgov ;
1904: LD_ADDR_VAR 0 5
1908: PUSH
1909: LD_VAR 0 5
1913: PUSH
1914: LD_EXP 42
1918: ADD
1919: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1920: LD_ADDR_EXP 43
1924: PUSH
1925: LD_STRING Petrosyan
1927: PPUSH
1928: LD_EXP 1
1932: NOT
1933: PPUSH
1934: LD_STRING 13a_
1936: PPUSH
1937: CALL 52848 0 3
1941: ST_TO_ADDR
// if Petrosyan then
1942: LD_EXP 43
1946: IFFALSE 1964
// tmp := tmp ^ Petrosyan ;
1948: LD_ADDR_VAR 0 5
1952: PUSH
1953: LD_VAR 0 5
1957: PUSH
1958: LD_EXP 43
1962: ADD
1963: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1964: LD_ADDR_EXP 44
1968: PUSH
1969: LD_STRING Scholtze
1971: PPUSH
1972: LD_EXP 1
1976: NOT
1977: PPUSH
1978: LD_STRING 13a_
1980: PPUSH
1981: CALL 52848 0 3
1985: ST_TO_ADDR
// if Scholtze then
1986: LD_EXP 44
1990: IFFALSE 2008
// tmp := tmp ^ Scholtze ;
1992: LD_ADDR_VAR 0 5
1996: PUSH
1997: LD_VAR 0 5
2001: PUSH
2002: LD_EXP 44
2006: ADD
2007: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2008: LD_ADDR_EXP 45
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: LD_EXP 1
2020: NOT
2021: PPUSH
2022: LD_STRING 13a_
2024: PPUSH
2025: CALL 52848 0 3
2029: ST_TO_ADDR
// if Oblukov then
2030: LD_EXP 45
2034: IFFALSE 2052
// tmp := tmp ^ Oblukov ;
2036: LD_ADDR_VAR 0 5
2040: PUSH
2041: LD_VAR 0 5
2045: PUSH
2046: LD_EXP 45
2050: ADD
2051: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2052: LD_ADDR_EXP 46
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: LD_EXP 1
2064: NOT
2065: PPUSH
2066: LD_STRING 13a_
2068: PPUSH
2069: CALL 52848 0 3
2073: ST_TO_ADDR
// if Kapitsova then
2074: LD_EXP 46
2078: IFFALSE 2096
// tmp := tmp ^ Kapitsova ;
2080: LD_ADDR_VAR 0 5
2084: PUSH
2085: LD_VAR 0 5
2089: PUSH
2090: LD_EXP 46
2094: ADD
2095: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2096: LD_ADDR_EXP 47
2100: PUSH
2101: LD_STRING Lipshchin
2103: PPUSH
2104: LD_EXP 1
2108: NOT
2109: PPUSH
2110: LD_STRING 13a_
2112: PPUSH
2113: CALL 52848 0 3
2117: ST_TO_ADDR
// if Lipshchin then
2118: LD_EXP 47
2122: IFFALSE 2140
// tmp := tmp ^ Lipshchin ;
2124: LD_ADDR_VAR 0 5
2128: PUSH
2129: LD_VAR 0 5
2133: PUSH
2134: LD_EXP 47
2138: ADD
2139: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2140: LD_ADDR_EXP 48
2144: PUSH
2145: LD_STRING Petrovova
2147: PPUSH
2148: LD_EXP 1
2152: NOT
2153: PPUSH
2154: LD_STRING 13a_
2156: PPUSH
2157: CALL 52848 0 3
2161: ST_TO_ADDR
// if Petrovova then
2162: LD_EXP 48
2166: IFFALSE 2184
// tmp := tmp ^ Petrovova ;
2168: LD_ADDR_VAR 0 5
2172: PUSH
2173: LD_VAR 0 5
2177: PUSH
2178: LD_EXP 48
2182: ADD
2183: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2184: LD_ADDR_EXP 49
2188: PUSH
2189: LD_STRING Kovalyuk
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13a_
2200: PPUSH
2201: CALL 52848 0 3
2205: ST_TO_ADDR
// if Kovalyuk then
2206: LD_EXP 49
2210: IFFALSE 2228
// tmp := tmp ^ Kovalyuk ;
2212: LD_ADDR_VAR 0 5
2216: PUSH
2217: LD_VAR 0 5
2221: PUSH
2222: LD_EXP 49
2226: ADD
2227: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2228: LD_ADDR_EXP 50
2232: PUSH
2233: LD_STRING Kuzmov
2235: PPUSH
2236: LD_EXP 1
2240: NOT
2241: PPUSH
2242: LD_STRING 13a_
2244: PPUSH
2245: CALL 52848 0 3
2249: ST_TO_ADDR
// if Kuzmov then
2250: LD_EXP 50
2254: IFFALSE 2272
// tmp := tmp ^ Kuzmov ;
2256: LD_ADDR_VAR 0 5
2260: PUSH
2261: LD_VAR 0 5
2265: PUSH
2266: LD_EXP 50
2270: ADD
2271: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2272: LD_ADDR_EXP 51
2276: PUSH
2277: LD_STRING Karamazov
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: LD_STRING 13a_
2288: PPUSH
2289: CALL 52848 0 3
2293: ST_TO_ADDR
// if Karamazov then
2294: LD_EXP 51
2298: IFFALSE 2316
// tmp := tmp ^ Karamazov ;
2300: LD_ADDR_VAR 0 5
2304: PUSH
2305: LD_VAR 0 5
2309: PUSH
2310: LD_EXP 51
2314: ADD
2315: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2316: LD_ADDR_EXP 53
2320: PUSH
2321: LD_STRING Belkov
2323: PPUSH
2324: LD_EXP 1
2328: NOT
2329: PPUSH
2330: LD_STRING 13a_
2332: PPUSH
2333: CALL 52848 0 3
2337: ST_TO_ADDR
// if Belkov then
2338: LD_EXP 53
2342: IFFALSE 2360
// tmp := tmp ^ Belkov ;
2344: LD_ADDR_VAR 0 5
2348: PUSH
2349: LD_VAR 0 5
2353: PUSH
2354: LD_EXP 53
2358: ADD
2359: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 54
2364: PUSH
2365: LD_STRING Gnyevko
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 52848 0 3
2381: ST_TO_ADDR
// if Gnyevko then
2382: LD_EXP 54
2386: IFFALSE 2404
// tmp := tmp ^ Gnyevko ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 54
2402: ADD
2403: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2404: LD_ADDR_EXP 36
2408: PUSH
2409: LD_STRING Coonie
2411: PPUSH
2412: CALL_OW 25
2416: ST_TO_ADDR
// if not Lisa then
2417: LD_EXP 21
2421: NOT
2422: IFFALSE 2468
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2424: LD_ADDR_EXP 21
2428: PUSH
2429: LD_STRING Lisa
2431: PPUSH
2432: LD_EXP 1
2436: NOT
2437: PPUSH
2438: LD_STRING 13a_
2440: PPUSH
2441: CALL 52848 0 3
2445: ST_TO_ADDR
// if Lisa then
2446: LD_EXP 21
2450: IFFALSE 2468
// tmp := tmp ^ Lisa ;
2452: LD_ADDR_VAR 0 5
2456: PUSH
2457: LD_VAR 0 5
2461: PUSH
2462: LD_EXP 21
2466: ADD
2467: ST_TO_ADDR
// end ; if not Donaldson then
2468: LD_EXP 22
2472: NOT
2473: IFFALSE 2519
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2475: LD_ADDR_EXP 22
2479: PUSH
2480: LD_STRING Donaldson
2482: PPUSH
2483: LD_EXP 1
2487: NOT
2488: PPUSH
2489: LD_STRING 13a_
2491: PPUSH
2492: CALL 52848 0 3
2496: ST_TO_ADDR
// if Donaldson then
2497: LD_EXP 22
2501: IFFALSE 2519
// tmp := tmp ^ Donaldson ;
2503: LD_ADDR_VAR 0 5
2507: PUSH
2508: LD_VAR 0 5
2512: PUSH
2513: LD_EXP 22
2517: ADD
2518: ST_TO_ADDR
// end ; if not Bobby then
2519: LD_EXP 23
2523: NOT
2524: IFFALSE 2570
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2526: LD_ADDR_EXP 23
2530: PUSH
2531: LD_STRING Bobby
2533: PPUSH
2534: LD_EXP 1
2538: NOT
2539: PPUSH
2540: LD_STRING 13a_
2542: PPUSH
2543: CALL 52848 0 3
2547: ST_TO_ADDR
// if Bobby then
2548: LD_EXP 23
2552: IFFALSE 2570
// tmp := tmp ^ Bobby ;
2554: LD_ADDR_VAR 0 5
2558: PUSH
2559: LD_VAR 0 5
2563: PUSH
2564: LD_EXP 23
2568: ADD
2569: ST_TO_ADDR
// end ; if not Cyrus then
2570: LD_EXP 24
2574: NOT
2575: IFFALSE 2621
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2577: LD_ADDR_EXP 24
2581: PUSH
2582: LD_STRING Cyrus
2584: PPUSH
2585: LD_EXP 1
2589: NOT
2590: PPUSH
2591: LD_STRING 13a_
2593: PPUSH
2594: CALL 52848 0 3
2598: ST_TO_ADDR
// if Cyrus then
2599: LD_EXP 24
2603: IFFALSE 2621
// tmp := tmp ^ Cyrus ;
2605: LD_ADDR_VAR 0 5
2609: PUSH
2610: LD_VAR 0 5
2614: PUSH
2615: LD_EXP 24
2619: ADD
2620: ST_TO_ADDR
// end ; if not Brown then
2621: LD_EXP 26
2625: NOT
2626: IFFALSE 2672
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2628: LD_ADDR_EXP 26
2632: PUSH
2633: LD_STRING Brown
2635: PPUSH
2636: LD_EXP 1
2640: NOT
2641: PPUSH
2642: LD_STRING 13a_
2644: PPUSH
2645: CALL 52848 0 3
2649: ST_TO_ADDR
// if Brown then
2650: LD_EXP 26
2654: IFFALSE 2672
// tmp := tmp ^ Brown ;
2656: LD_ADDR_VAR 0 5
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_EXP 26
2670: ADD
2671: ST_TO_ADDR
// end ; if not Gladstone then
2672: LD_EXP 27
2676: NOT
2677: IFFALSE 2723
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2679: LD_ADDR_EXP 27
2683: PUSH
2684: LD_STRING Gladstone
2686: PPUSH
2687: LD_EXP 1
2691: NOT
2692: PPUSH
2693: LD_STRING 13a_
2695: PPUSH
2696: CALL 52848 0 3
2700: ST_TO_ADDR
// if Gladstone then
2701: LD_EXP 27
2705: IFFALSE 2723
// tmp := tmp ^ Gladstone ;
2707: LD_ADDR_VAR 0 5
2711: PUSH
2712: LD_VAR 0 5
2716: PUSH
2717: LD_EXP 27
2721: ADD
2722: ST_TO_ADDR
// end ; if not Cornel then
2723: LD_EXP 29
2727: NOT
2728: IFFALSE 2774
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2730: LD_ADDR_EXP 29
2734: PUSH
2735: LD_STRING Cornel
2737: PPUSH
2738: LD_EXP 1
2742: NOT
2743: PPUSH
2744: LD_STRING 13a_
2746: PPUSH
2747: CALL 52848 0 3
2751: ST_TO_ADDR
// if Cornel then
2752: LD_EXP 29
2756: IFFALSE 2774
// tmp := tmp ^ Cornel ;
2758: LD_ADDR_VAR 0 5
2762: PUSH
2763: LD_VAR 0 5
2767: PUSH
2768: LD_EXP 29
2772: ADD
2773: ST_TO_ADDR
// end ; if not Houten then
2774: LD_EXP 28
2778: NOT
2779: IFFALSE 2825
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2781: LD_ADDR_EXP 28
2785: PUSH
2786: LD_STRING Houten
2788: PPUSH
2789: LD_EXP 1
2793: NOT
2794: PPUSH
2795: LD_STRING 13a_
2797: PPUSH
2798: CALL 52848 0 3
2802: ST_TO_ADDR
// if Houten then
2803: LD_EXP 28
2807: IFFALSE 2825
// tmp := tmp ^ Houten ;
2809: LD_ADDR_VAR 0 5
2813: PUSH
2814: LD_VAR 0 5
2818: PUSH
2819: LD_EXP 28
2823: ADD
2824: ST_TO_ADDR
// end ; if not Gary then
2825: LD_EXP 30
2829: NOT
2830: IFFALSE 2876
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2832: LD_ADDR_EXP 30
2836: PUSH
2837: LD_STRING Gary
2839: PPUSH
2840: LD_EXP 1
2844: NOT
2845: PPUSH
2846: LD_STRING 13a_
2848: PPUSH
2849: CALL 52848 0 3
2853: ST_TO_ADDR
// if Gary then
2854: LD_EXP 30
2858: IFFALSE 2876
// tmp := tmp ^ Gary ;
2860: LD_ADDR_VAR 0 5
2864: PUSH
2865: LD_VAR 0 5
2869: PUSH
2870: LD_EXP 30
2874: ADD
2875: ST_TO_ADDR
// end ; if not Kikuchi then
2876: LD_EXP 32
2880: NOT
2881: IFFALSE 2927
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2883: LD_ADDR_EXP 32
2887: PUSH
2888: LD_STRING Kikuchi
2890: PPUSH
2891: LD_EXP 1
2895: NOT
2896: PPUSH
2897: LD_STRING 13a_
2899: PPUSH
2900: CALL 52848 0 3
2904: ST_TO_ADDR
// if Kikuchi then
2905: LD_EXP 32
2909: IFFALSE 2927
// tmp := tmp ^ Kikuchi ;
2911: LD_ADDR_VAR 0 5
2915: PUSH
2916: LD_VAR 0 5
2920: PUSH
2921: LD_EXP 32
2925: ADD
2926: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2927: LD_ADDR_VAR 0 5
2931: PUSH
2932: LD_VAR 0 5
2936: PUSH
2937: LD_STRING 13a_others
2939: PPUSH
2940: CALL_OW 31
2944: UNION
2945: ST_TO_ADDR
// tmp := tmp diff 0 ;
2946: LD_ADDR_VAR 0 5
2950: PUSH
2951: LD_VAR 0 5
2955: PUSH
2956: LD_INT 0
2958: DIFF
2959: ST_TO_ADDR
// if tmp < 15 then
2960: LD_VAR 0 5
2964: PUSH
2965: LD_INT 15
2967: LESS
2968: IFFALSE 3056
// for i = 15 downto tmp do
2970: LD_ADDR_VAR 0 2
2974: PUSH
2975: DOUBLE
2976: LD_INT 15
2978: INC
2979: ST_TO_ADDR
2980: LD_VAR 0 5
2984: PUSH
2985: FOR_DOWNTO
2986: IFFALSE 3054
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2988: LD_ADDR_OWVAR 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: PUSH
3003: LD_INT 1
3005: PPUSH
3006: LD_INT 2
3008: PPUSH
3009: CALL_OW 12
3013: ARRAY
3014: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3015: LD_INT 0
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: LD_INT 4
3023: PPUSH
3024: CALL_OW 12
3028: PPUSH
3029: LD_INT 8
3031: PPUSH
3032: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3036: LD_ADDR_VAR 0 5
3040: PUSH
3041: LD_VAR 0 5
3045: PUSH
3046: CALL_OW 44
3050: ADD
3051: ST_TO_ADDR
// end ;
3052: GO 2985
3054: POP
3055: POP
// if not debug then
3056: LD_EXP 1
3060: NOT
3061: IFFALSE 3241
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3063: LD_ADDR_VAR 0 4
3067: PUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_INT 14
3073: PUSH
3074: LD_INT 13
3076: PUSH
3077: LD_INT 12
3079: PUSH
3080: LD_INT 11
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: LD_OWVAR 67
3093: ARRAY
3094: PPUSH
3095: LD_INT 14
3097: PUSH
3098: LD_INT 13
3100: PUSH
3101: LD_INT 12
3103: PUSH
3104: LD_INT 11
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: LD_INT -5
3121: PUSH
3122: LD_EXP 19
3126: PUSH
3127: LD_EXP 52
3131: PUSH
3132: LD_EXP 20
3136: PUSH
3137: LD_EXP 34
3141: PUSH
3142: LD_EXP 25
3146: PUSH
3147: LD_EXP 38
3151: PUSH
3152: LD_INT -2
3154: PUSH
3155: LD_INT -3
3157: PUSH
3158: LD_INT -5
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: PUSH
3173: LD_VAR 0 5
3177: ADD
3178: PPUSH
3179: LD_INT 1
3181: PUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 1
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 3
3197: PUSH
3198: LD_INT 5
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 9
3214: PUSH
3215: LD_INT 0
3217: PUSH
3218: LD_INT 3
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: PPUSH
3234: CALL_OW 42
3238: ST_TO_ADDR
3239: GO 3290
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3241: LD_ADDR_VAR 0 4
3245: PUSH
3246: LD_EXP 40
3250: PUSH
3251: LD_EXP 41
3255: PUSH
3256: LD_EXP 42
3260: PUSH
3261: LD_EXP 43
3265: PUSH
3266: LD_EXP 44
3270: PUSH
3271: LD_EXP 45
3275: PUSH
3276: LD_EXP 46
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3290: LD_ADDR_EXP 17
3294: PUSH
3295: LD_VAR 0 5
3299: PUSH
3300: LD_VAR 0 4
3304: DIFF
3305: ST_TO_ADDR
// uc_nation := 1 ;
3306: LD_ADDR_OWVAR 21
3310: PUSH
3311: LD_INT 1
3313: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3314: LD_INT 5
3316: PPUSH
3317: LD_INT 3
3319: PPUSH
3320: LD_INT 1
3322: PPUSH
3323: LD_INT 6
3325: PPUSH
3326: LD_INT 100
3328: PPUSH
3329: CALL 57688 0 5
// veh := CreateVehicle ;
3333: LD_ADDR_VAR 0 3
3337: PUSH
3338: CALL_OW 45
3342: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3343: LD_VAR 0 3
3347: PPUSH
3348: LD_INT 7
3350: NEG
3351: PPUSH
3352: CALL_OW 242
// SetDir ( veh , 3 ) ;
3356: LD_VAR 0 3
3360: PPUSH
3361: LD_INT 3
3363: PPUSH
3364: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3368: LD_VAR 0 3
3372: PPUSH
3373: LD_INT 31
3375: PPUSH
3376: LD_INT 0
3378: PPUSH
3379: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3383: LD_EXP 19
3387: PPUSH
3388: LD_VAR 0 3
3392: PPUSH
3393: CALL_OW 52
// if Joan then
3397: LD_EXP 34
3401: IFFALSE 3473
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3403: LD_INT 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: LD_INT 1
3411: PPUSH
3412: LD_INT 11
3414: PPUSH
3415: LD_INT 100
3417: PPUSH
3418: CALL 57688 0 5
// veh := CreateVehicle ;
3422: LD_ADDR_VAR 0 3
3426: PUSH
3427: CALL_OW 45
3431: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3432: LD_VAR 0 3
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3444: LD_VAR 0 3
3448: PPUSH
3449: LD_INT 30
3451: PPUSH
3452: LD_INT 0
3454: PPUSH
3455: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3459: LD_EXP 34
3463: PPUSH
3464: LD_VAR 0 3
3468: PPUSH
3469: CALL_OW 52
// end ; if Roth then
3473: LD_EXP 20
3477: IFFALSE 3549
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3479: LD_INT 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: LD_INT 11
3490: PPUSH
3491: LD_INT 100
3493: PPUSH
3494: CALL 57688 0 5
// veh := CreateVehicle ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: CALL_OW 45
3507: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3508: LD_VAR 0 3
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3520: LD_VAR 0 3
3524: PPUSH
3525: LD_INT 30
3527: PPUSH
3528: LD_INT 0
3530: PPUSH
3531: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3535: LD_EXP 20
3539: PPUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: CALL_OW 52
// end ; if Denis then
3549: LD_EXP 25
3553: IFFALSE 3625
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3555: LD_INT 5
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: LD_INT 1
3563: PPUSH
3564: LD_INT 9
3566: PPUSH
3567: LD_INT 100
3569: PPUSH
3570: CALL 57688 0 5
// veh := CreateVehicle ;
3574: LD_ADDR_VAR 0 3
3578: PUSH
3579: CALL_OW 45
3583: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3584: LD_VAR 0 3
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3596: LD_VAR 0 3
3600: PPUSH
3601: LD_INT 30
3603: PPUSH
3604: LD_INT 0
3606: PPUSH
3607: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3611: LD_EXP 25
3615: PPUSH
3616: LD_VAR 0 3
3620: PPUSH
3621: CALL_OW 52
// end ; uc_nation := 3 ;
3625: LD_ADDR_OWVAR 21
3629: PUSH
3630: LD_INT 3
3632: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3633: LD_INT 22
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: LD_INT 1
3641: PPUSH
3642: LD_INT 45
3644: PPUSH
3645: LD_INT 100
3647: PPUSH
3648: CALL 57688 0 5
// veh := CreateVehicle ;
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: CALL_OW 45
3661: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3662: LD_VAR 0 3
3666: PPUSH
3667: LD_INT 7
3669: NEG
3670: PPUSH
3671: CALL_OW 242
// SetDir ( veh , 3 ) ;
3675: LD_VAR 0 3
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3687: LD_VAR 0 3
3691: PPUSH
3692: LD_INT 31
3694: PPUSH
3695: LD_INT 0
3697: PPUSH
3698: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3702: LD_EXP 52
3706: PPUSH
3707: LD_VAR 0 3
3711: PPUSH
3712: CALL_OW 52
// if Gossudarov then
3716: LD_EXP 38
3720: IFFALSE 3807
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3722: LD_INT 22
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: LD_INT 51
3733: PPUSH
3734: LD_INT 100
3736: PPUSH
3737: CALL 57688 0 5
// veh := CreateVehicle ;
3741: LD_ADDR_VAR 0 3
3745: PUSH
3746: CALL_OW 45
3750: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3751: LD_VAR 0 3
3755: PPUSH
3756: LD_INT 3
3758: PPUSH
3759: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3763: LD_VAR 0 3
3767: PPUSH
3768: LD_INT 30
3770: PPUSH
3771: LD_INT 0
3773: PPUSH
3774: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3778: LD_EXP 38
3782: PPUSH
3783: LD_VAR 0 3
3787: PPUSH
3788: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3792: LD_VAR 0 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL_OW 290
// end ; if Mike then
3807: LD_EXP 37
3811: IFFALSE 3828
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3813: LD_EXP 37
3817: PPUSH
3818: LD_INT 30
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 49
// for i in selected do
3828: LD_ADDR_VAR 0 2
3832: PUSH
3833: LD_VAR 0 4
3837: PUSH
3838: FOR_IN
3839: IFFALSE 4397
// begin uc_nation := GetNation ( i ) ;
3841: LD_ADDR_OWVAR 21
3845: PUSH
3846: LD_VAR 0 2
3850: PPUSH
3851: CALL_OW 248
3855: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3856: LD_VAR 0 2
3860: PUSH
3861: LD_EXP 21
3865: PUSH
3866: LD_EXP 22
3870: PUSH
3871: LD_EXP 24
3875: PUSH
3876: LD_EXP 23
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: IN
3887: IFFALSE 3910
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3889: LD_INT 5
3891: PPUSH
3892: LD_INT 3
3894: PPUSH
3895: LD_INT 1
3897: PPUSH
3898: LD_INT 6
3900: PPUSH
3901: LD_INT 100
3903: PPUSH
3904: CALL 57688 0 5
3908: GO 4344
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3910: LD_VAR 0 2
3914: PUSH
3915: LD_EXP 45
3919: PUSH
3920: LD_EXP 50
3924: PUSH
3925: LD_EXP 48
3929: PUSH
3930: LD_EXP 40
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: IN
3941: IFFALSE 3972
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3943: LD_INT 24
3945: PPUSH
3946: LD_INT 1
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: LD_INT 46
3954: PPUSH
3955: LD_INT 65
3957: PPUSH
3958: LD_INT 75
3960: PPUSH
3961: CALL_OW 12
3965: PPUSH
3966: CALL 57688 0 5
3970: GO 4344
// if i = Karamazov then
3972: LD_VAR 0 2
3976: PUSH
3977: LD_EXP 51
3981: EQUAL
3982: IFFALSE 4005
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3984: LD_INT 22
3986: PPUSH
3987: LD_INT 3
3989: PPUSH
3990: LD_INT 1
3992: PPUSH
3993: LD_INT 52
3995: PPUSH
3996: LD_INT 100
3998: PPUSH
3999: CALL 57688 0 5
4003: GO 4344
// if i = Brown then
4005: LD_VAR 0 2
4009: PUSH
4010: LD_EXP 26
4014: EQUAL
4015: IFFALSE 4038
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4017: LD_INT 3
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 1
4025: PPUSH
4026: LD_INT 13
4028: PPUSH
4029: LD_INT 100
4031: PPUSH
4032: CALL 57688 0 5
4036: GO 4344
// if uc_nation = nation_american then
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 1
4045: EQUAL
4046: IFFALSE 4197
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4048: LD_INT 3
4050: PUSH
4051: LD_INT 5
4053: PUSH
4054: LD_INT 5
4056: PUSH
4057: EMPTY
4058: LIST
4059: LIST
4060: LIST
4061: PUSH
4062: LD_OWVAR 21
4066: PUSH
4067: LD_INT 3
4069: MOD
4070: PUSH
4071: LD_INT 1
4073: PLUS
4074: ARRAY
4075: PPUSH
4076: LD_INT 1
4078: PUSH
4079: LD_INT 3
4081: PUSH
4082: LD_INT 1
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PUSH
4090: LD_OWVAR 21
4094: PUSH
4095: LD_INT 3
4097: MOD
4098: PUSH
4099: LD_INT 1
4101: PLUS
4102: ARRAY
4103: PPUSH
4104: LD_INT 1
4106: PPUSH
4107: LD_INT 11
4109: PUSH
4110: LD_INT 4
4112: PUSH
4113: LD_INT 5
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: LD_INT 6
4123: PUSH
4124: LD_INT 7
4126: PUSH
4127: LD_INT 9
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: PUSH
4135: LD_INT 6
4137: PUSH
4138: LD_INT 9
4140: PUSH
4141: LD_INT 12
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: LIST
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: LD_OWVAR 21
4158: PUSH
4159: LD_INT 3
4161: MOD
4162: PUSH
4163: LD_INT 1
4165: PLUS
4166: ARRAY
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 3
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 65
4182: PPUSH
4183: LD_INT 75
4185: PPUSH
4186: CALL_OW 12
4190: PPUSH
4191: CALL 57688 0 5
// end else
4195: GO 4344
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4197: LD_INT 22
4199: PUSH
4200: LD_INT 23
4202: PUSH
4203: LD_INT 23
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: PUSH
4211: LD_OWVAR 21
4215: PUSH
4216: LD_INT 3
4218: MOD
4219: PUSH
4220: LD_INT 1
4222: PLUS
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PUSH
4228: LD_INT 3
4230: PUSH
4231: LD_INT 1
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: LIST
4238: PUSH
4239: LD_OWVAR 21
4243: PUSH
4244: LD_INT 3
4246: MOD
4247: PUSH
4248: LD_INT 1
4250: PLUS
4251: ARRAY
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 43
4261: PUSH
4262: LD_INT 44
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 46
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 44
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 46
4286: PUSH
4287: LD_INT 43
4289: PUSH
4290: LD_INT 45
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: LIST
4302: PUSH
4303: LD_OWVAR 21
4307: PUSH
4308: LD_INT 3
4310: MOD
4311: PUSH
4312: LD_INT 1
4314: PLUS
4315: ARRAY
4316: PUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 3
4322: PPUSH
4323: CALL_OW 12
4327: ARRAY
4328: PPUSH
4329: LD_INT 65
4331: PPUSH
4332: LD_INT 75
4334: PPUSH
4335: CALL_OW 12
4339: PPUSH
4340: CALL 57688 0 5
// end ; veh := CreateVehicle ;
4344: LD_ADDR_VAR 0 3
4348: PUSH
4349: CALL_OW 45
4353: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4354: LD_VAR 0 3
4358: PPUSH
4359: LD_INT 3
4361: PPUSH
4362: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4366: LD_VAR 0 3
4370: PPUSH
4371: LD_INT 30
4373: PPUSH
4374: LD_INT 0
4376: PPUSH
4377: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 3
4390: PPUSH
4391: CALL_OW 52
// end ;
4395: GO 3838
4397: POP
4398: POP
// if artifactArCaptured then
4399: LD_EXP 9
4403: IFFALSE 4489
// begin uc_nation := nation_american ;
4405: LD_ADDR_OWVAR 21
4409: PUSH
4410: LD_INT 1
4412: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4413: LD_INT 3
4415: PPUSH
4416: LD_INT 3
4418: PPUSH
4419: LD_INT 3
4421: PPUSH
4422: LD_INT 12
4424: PPUSH
4425: LD_INT 100
4427: PPUSH
4428: CALL 57688 0 5
// veh := CreateVehicle ;
4432: LD_ADDR_VAR 0 3
4436: PUSH
4437: CALL_OW 45
4441: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4442: LD_VAR 0 3
4446: PPUSH
4447: LD_INT 3
4449: PPUSH
4450: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4454: LD_VAR 0 3
4458: PPUSH
4459: LD_INT 198
4461: PPUSH
4462: LD_INT 22
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 4
4479: PPUSH
4480: LD_INT 50
4482: PPUSH
4483: CALL_OW 290
// end else
4487: GO 4508
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4489: LD_INT 4
4491: PPUSH
4492: LD_INT 5
4494: PPUSH
4495: LD_INT 267
4497: PPUSH
4498: LD_INT 226
4500: PPUSH
4501: LD_INT 0
4503: PPUSH
4504: CALL_OW 58
// end ; uc_nation := nation_american ;
4508: LD_ADDR_OWVAR 21
4512: PUSH
4513: LD_INT 1
4515: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4516: LD_INT 3
4518: PPUSH
4519: LD_INT 3
4521: PPUSH
4522: LD_INT 3
4524: PPUSH
4525: LD_INT 12
4527: PPUSH
4528: LD_INT 100
4530: PPUSH
4531: CALL 57688 0 5
// veh := CreateVehicle ;
4535: LD_ADDR_VAR 0 3
4539: PUSH
4540: CALL_OW 45
4544: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4545: LD_VAR 0 3
4549: PPUSH
4550: LD_INT 3
4552: PPUSH
4553: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4557: LD_VAR 0 3
4561: PPUSH
4562: LD_INT 218
4564: PPUSH
4565: LD_INT 23
4567: PPUSH
4568: LD_INT 0
4570: PPUSH
4571: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 4
4582: PPUSH
4583: LD_INT 30
4585: PPUSH
4586: CALL_OW 290
// uc_nation := nation_russian ;
4590: LD_ADDR_OWVAR 21
4594: PUSH
4595: LD_INT 3
4597: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4598: LD_INT 22
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: LD_INT 3
4606: PPUSH
4607: LD_INT 51
4609: PPUSH
4610: LD_INT 100
4612: PPUSH
4613: CALL 57688 0 5
// veh := CreateVehicle ;
4617: LD_ADDR_VAR 0 3
4621: PUSH
4622: CALL_OW 45
4626: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4627: LD_VAR 0 3
4631: PPUSH
4632: LD_INT 3
4634: PPUSH
4635: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4639: LD_VAR 0 3
4643: PPUSH
4644: LD_INT 214
4646: PPUSH
4647: LD_INT 20
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4657: LD_VAR 0 3
4661: PPUSH
4662: LD_INT 4
4664: PPUSH
4665: LD_INT 40
4667: PPUSH
4668: CALL_OW 290
// end ;
4672: LD_VAR 0 1
4676: RET
// export function AllianceSupport ; var i , veh ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if not allianceTeam then
4682: LD_EXP 17
4686: NOT
4687: IFFALSE 4691
// exit ;
4689: GO 5097
// for i := 1 to 6 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 6
4703: PUSH
4704: FOR_TO
4705: IFFALSE 5001
// begin uc_side := 7 ;
4707: LD_ADDR_OWVAR 20
4711: PUSH
4712: LD_INT 7
4714: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4715: LD_ADDR_OWVAR 21
4719: PUSH
4720: LD_INT 1
4722: PUSH
4723: LD_INT 3
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_VAR 0 2
4734: PUSH
4735: LD_INT 2
4737: MOD
4738: PUSH
4739: LD_INT 1
4741: PLUS
4742: ARRAY
4743: ST_TO_ADDR
// if uc_nation = 1 then
4744: LD_OWVAR 21
4748: PUSH
4749: LD_INT 1
4751: EQUAL
4752: IFFALSE 4794
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4754: LD_INT 5
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 1
4762: PPUSH
4763: LD_INT 6
4765: PUSH
4766: LD_INT 7
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 2
4778: PPUSH
4779: CALL_OW 12
4783: ARRAY
4784: PPUSH
4785: LD_INT 100
4787: PPUSH
4788: CALL 57688 0 5
4792: GO 4832
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4794: LD_INT 23
4796: PPUSH
4797: LD_INT 3
4799: PPUSH
4800: LD_INT 1
4802: PPUSH
4803: LD_INT 46
4805: PUSH
4806: LD_INT 47
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: PUSH
4813: LD_INT 1
4815: PPUSH
4816: LD_INT 2
4818: PPUSH
4819: CALL_OW 12
4823: ARRAY
4824: PPUSH
4825: LD_INT 100
4827: PPUSH
4828: CALL 57688 0 5
// if not allianceTeam then
4832: LD_EXP 17
4836: NOT
4837: IFFALSE 4841
// break ;
4839: GO 5001
// veh := CreateVehicle ;
4841: LD_ADDR_VAR 0 3
4845: PUSH
4846: CALL_OW 45
4850: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4851: LD_VAR 0 3
4855: PPUSH
4856: LD_INT 4
4858: PPUSH
4859: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4863: LD_VAR 0 3
4867: PPUSH
4868: LD_INT 38
4870: PPUSH
4871: LD_INT 0
4873: PPUSH
4874: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4878: LD_EXP 17
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: LD_INT 3
4889: PPUSH
4890: CALL_OW 259
4894: PUSH
4895: LD_INT 4
4897: GREATER
4898: IFFALSE 4916
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4900: LD_EXP 17
4904: PUSH
4905: LD_INT 1
4907: ARRAY
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4916: LD_EXP 17
4920: PUSH
4921: LD_INT 1
4923: ARRAY
4924: PPUSH
4925: LD_INT 4
4927: PPUSH
4928: CALL_OW 259
4932: PUSH
4933: LD_INT 8
4935: GREATER
4936: IFFALSE 4954
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4938: LD_EXP 17
4942: PUSH
4943: LD_INT 1
4945: ARRAY
4946: PPUSH
4947: LD_INT 4
4949: PPUSH
4950: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4954: LD_EXP 17
4958: PUSH
4959: LD_INT 1
4961: ARRAY
4962: PPUSH
4963: LD_VAR 0 3
4967: PPUSH
4968: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4972: LD_ADDR_EXP 17
4976: PUSH
4977: LD_EXP 17
4981: PPUSH
4982: LD_INT 1
4984: PPUSH
4985: CALL_OW 3
4989: ST_TO_ADDR
// ComHold ( veh ) ;
4990: LD_VAR 0 3
4994: PPUSH
4995: CALL_OW 140
// end ;
4999: GO 4704
5001: POP
5002: POP
// uc_side := 7 ;
5003: LD_ADDR_OWVAR 20
5007: PUSH
5008: LD_INT 7
5010: ST_TO_ADDR
// uc_nation := 1 ;
5011: LD_ADDR_OWVAR 21
5015: PUSH
5016: LD_INT 1
5018: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5019: LD_INT 5
5021: PPUSH
5022: LD_INT 3
5024: PPUSH
5025: LD_INT 3
5027: PPUSH
5028: LD_INT 11
5030: PPUSH
5031: LD_INT 100
5033: PPUSH
5034: CALL 57688 0 5
// veh := CreateVehicle ;
5038: LD_ADDR_VAR 0 3
5042: PUSH
5043: CALL_OW 45
5047: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5048: LD_VAR 0 3
5052: PPUSH
5053: LD_INT 4
5055: PPUSH
5056: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 305
5067: PPUSH
5068: LD_INT 218
5070: PPUSH
5071: LD_INT 0
5073: PPUSH
5074: CALL_OW 48
// ComHold ( veh ) ;
5078: LD_VAR 0 3
5082: PPUSH
5083: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5087: LD_INT 313
5089: PPUSH
5090: LD_INT 220
5092: PPUSH
5093: CALL_OW 86
// end ; end_of_file
5097: LD_VAR 0 1
5101: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5102: LD_INT 0
5104: PPUSH
5105: PPUSH
5106: PPUSH
5107: PPUSH
5108: PPUSH
5109: PPUSH
5110: PPUSH
5111: PPUSH
5112: PPUSH
5113: PPUSH
5114: PPUSH
// InitHc ;
5115: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5119: LD_INT 387
5121: PPUSH
5122: LD_STRING sigma
5124: PPUSH
5125: CALL_OW 500
// uc_side := 1 ;
5129: LD_ADDR_OWVAR 20
5133: PUSH
5134: LD_INT 1
5136: ST_TO_ADDR
// uc_nation := 1 ;
5137: LD_ADDR_OWVAR 21
5141: PUSH
5142: LD_INT 1
5144: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5145: LD_ADDR_VAR 0 2
5149: PUSH
5150: LD_INT 22
5152: PUSH
5153: LD_INT 1
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 21
5162: PUSH
5163: LD_INT 3
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: PUSH
5179: FOR_IN
5180: IFFALSE 5196
// SetBLevel ( i , 10 ) ;
5182: LD_VAR 0 2
5186: PPUSH
5187: LD_INT 10
5189: PPUSH
5190: CALL_OW 241
5194: GO 5179
5196: POP
5197: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5198: LD_INT 387
5200: PPUSH
5201: CALL_OW 274
5205: PPUSH
5206: LD_INT 1
5208: PPUSH
5209: LD_INT 7500
5211: PPUSH
5212: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5216: LD_INT 387
5218: PPUSH
5219: CALL_OW 274
5223: PPUSH
5224: LD_INT 2
5226: PPUSH
5227: LD_INT 4000
5229: PPUSH
5230: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5234: LD_INT 387
5236: PPUSH
5237: CALL_OW 274
5241: PPUSH
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 50
5247: PPUSH
5248: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5252: LD_INT 476
5254: PPUSH
5255: CALL_OW 274
5259: PPUSH
5260: LD_INT 1
5262: PPUSH
5263: LD_INT 5500
5265: PPUSH
5266: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5270: LD_INT 476
5272: PPUSH
5273: CALL_OW 274
5277: PPUSH
5278: LD_INT 2
5280: PPUSH
5281: LD_INT 4000
5283: PPUSH
5284: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5288: LD_INT 476
5290: PPUSH
5291: CALL_OW 274
5295: PPUSH
5296: LD_INT 3
5298: PPUSH
5299: LD_INT 10
5301: PPUSH
5302: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5306: LD_ADDR_EXP 55
5310: PUSH
5311: LD_STRING Powell
5313: PPUSH
5314: CALL_OW 25
5318: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5319: LD_EXP 55
5323: PPUSH
5324: LD_INT 387
5326: PPUSH
5327: CALL_OW 52
// tmp := [ ] ;
5331: LD_ADDR_VAR 0 7
5335: PUSH
5336: EMPTY
5337: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5338: LD_ADDR_EXP 21
5342: PUSH
5343: LD_STRING Lisa
5345: PPUSH
5346: LD_EXP 1
5350: NOT
5351: PPUSH
5352: LD_STRING 12p_
5354: PPUSH
5355: CALL 52848 0 3
5359: ST_TO_ADDR
// if Lisa then
5360: LD_EXP 21
5364: IFFALSE 5382
// tmp := tmp ^ Lisa ;
5366: LD_ADDR_VAR 0 7
5370: PUSH
5371: LD_VAR 0 7
5375: PUSH
5376: LD_EXP 21
5380: ADD
5381: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5382: LD_ADDR_EXP 22
5386: PUSH
5387: LD_STRING Donaldson
5389: PPUSH
5390: LD_EXP 1
5394: NOT
5395: PPUSH
5396: LD_STRING 12p_
5398: PPUSH
5399: CALL 52848 0 3
5403: ST_TO_ADDR
// if Donaldson then
5404: LD_EXP 22
5408: IFFALSE 5426
// tmp := tmp ^ Donaldson ;
5410: LD_ADDR_VAR 0 7
5414: PUSH
5415: LD_VAR 0 7
5419: PUSH
5420: LD_EXP 22
5424: ADD
5425: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5426: LD_ADDR_EXP 23
5430: PUSH
5431: LD_STRING Bobby
5433: PPUSH
5434: LD_EXP 1
5438: NOT
5439: PPUSH
5440: LD_STRING 12p_
5442: PPUSH
5443: CALL 52848 0 3
5447: ST_TO_ADDR
// if Bobby then
5448: LD_EXP 23
5452: IFFALSE 5470
// tmp := tmp ^ Bobby ;
5454: LD_ADDR_VAR 0 7
5458: PUSH
5459: LD_VAR 0 7
5463: PUSH
5464: LD_EXP 23
5468: ADD
5469: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5470: LD_ADDR_EXP 24
5474: PUSH
5475: LD_STRING Cyrus
5477: PPUSH
5478: LD_EXP 1
5482: NOT
5483: PPUSH
5484: LD_STRING 12p_
5486: PPUSH
5487: CALL 52848 0 3
5491: ST_TO_ADDR
// if Cyrus then
5492: LD_EXP 24
5496: IFFALSE 5514
// tmp := tmp ^ Cyrus ;
5498: LD_ADDR_VAR 0 7
5502: PUSH
5503: LD_VAR 0 7
5507: PUSH
5508: LD_EXP 24
5512: ADD
5513: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5514: LD_ADDR_EXP 26
5518: PUSH
5519: LD_STRING Brown
5521: PPUSH
5522: LD_EXP 1
5526: NOT
5527: PPUSH
5528: LD_STRING 12p_
5530: PPUSH
5531: CALL 52848 0 3
5535: ST_TO_ADDR
// if Brown then
5536: LD_EXP 26
5540: IFFALSE 5558
// tmp := tmp ^ Brown ;
5542: LD_ADDR_VAR 0 7
5546: PUSH
5547: LD_VAR 0 7
5551: PUSH
5552: LD_EXP 26
5556: ADD
5557: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5558: LD_ADDR_EXP 27
5562: PUSH
5563: LD_STRING Gladstone
5565: PPUSH
5566: LD_EXP 1
5570: NOT
5571: PPUSH
5572: LD_STRING 12p_
5574: PPUSH
5575: CALL 52848 0 3
5579: ST_TO_ADDR
// if Gladstone then
5580: LD_EXP 27
5584: IFFALSE 5602
// tmp := tmp ^ Gladstone ;
5586: LD_ADDR_VAR 0 7
5590: PUSH
5591: LD_VAR 0 7
5595: PUSH
5596: LD_EXP 27
5600: ADD
5601: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5602: LD_ADDR_EXP 28
5606: PUSH
5607: LD_STRING Houten
5609: PPUSH
5610: LD_EXP 1
5614: NOT
5615: PPUSH
5616: LD_STRING 12p_
5618: PPUSH
5619: CALL 52848 0 3
5623: ST_TO_ADDR
// if Houten then
5624: LD_EXP 28
5628: IFFALSE 5646
// tmp := tmp ^ Houten ;
5630: LD_ADDR_VAR 0 7
5634: PUSH
5635: LD_VAR 0 7
5639: PUSH
5640: LD_EXP 28
5644: ADD
5645: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5646: LD_ADDR_EXP 29
5650: PUSH
5651: LD_STRING Cornel
5653: PPUSH
5654: LD_EXP 1
5658: NOT
5659: PPUSH
5660: LD_STRING 12p_
5662: PPUSH
5663: CALL 52848 0 3
5667: ST_TO_ADDR
// if Cornel then
5668: LD_EXP 29
5672: IFFALSE 5690
// tmp := tmp ^ Cornel ;
5674: LD_ADDR_VAR 0 7
5678: PUSH
5679: LD_VAR 0 7
5683: PUSH
5684: LD_EXP 29
5688: ADD
5689: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5690: LD_ADDR_EXP 30
5694: PUSH
5695: LD_STRING Gary
5697: PPUSH
5698: LD_EXP 1
5702: NOT
5703: PPUSH
5704: LD_STRING 12p_
5706: PPUSH
5707: CALL 52848 0 3
5711: ST_TO_ADDR
// if Gary then
5712: LD_EXP 30
5716: IFFALSE 5734
// tmp := tmp ^ Gary ;
5718: LD_ADDR_VAR 0 7
5722: PUSH
5723: LD_VAR 0 7
5727: PUSH
5728: LD_EXP 30
5732: ADD
5733: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5734: LD_ADDR_EXP 32
5738: PUSH
5739: LD_STRING Kikuchi
5741: PPUSH
5742: LD_EXP 1
5746: NOT
5747: PPUSH
5748: LD_STRING 12p_
5750: PPUSH
5751: CALL 52848 0 3
5755: ST_TO_ADDR
// if Kikuchi then
5756: LD_EXP 32
5760: IFFALSE 5778
// tmp := tmp ^ Kikuchi ;
5762: LD_ADDR_VAR 0 7
5766: PUSH
5767: LD_VAR 0 7
5771: PUSH
5772: LD_EXP 32
5776: ADD
5777: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5778: LD_ADDR_VAR 0 7
5782: PUSH
5783: LD_VAR 0 7
5787: PUSH
5788: LD_STRING 12p_others
5790: PPUSH
5791: CALL_OW 31
5795: UNION
5796: ST_TO_ADDR
// if tmp < 36 then
5797: LD_VAR 0 7
5801: PUSH
5802: LD_INT 36
5804: LESS
5805: IFFALSE 5872
// for i = 1 to 36 - tmp do
5807: LD_ADDR_VAR 0 2
5811: PUSH
5812: DOUBLE
5813: LD_INT 1
5815: DEC
5816: ST_TO_ADDR
5817: LD_INT 36
5819: PUSH
5820: LD_VAR 0 7
5824: MINUS
5825: PUSH
5826: FOR_TO
5827: IFFALSE 5870
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5829: LD_INT 1
5831: PPUSH
5832: LD_VAR 0 2
5836: PUSH
5837: LD_INT 4
5839: MOD
5840: PUSH
5841: LD_INT 1
5843: PLUS
5844: PPUSH
5845: LD_INT 10
5847: PPUSH
5848: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5852: LD_ADDR_VAR 0 7
5856: PUSH
5857: LD_VAR 0 7
5861: PUSH
5862: CALL_OW 44
5866: ADD
5867: ST_TO_ADDR
// end ;
5868: GO 5826
5870: POP
5871: POP
// p := 0 ;
5872: LD_ADDR_VAR 0 6
5876: PUSH
5877: LD_INT 0
5879: ST_TO_ADDR
// for i in tmp do
5880: LD_ADDR_VAR 0 2
5884: PUSH
5885: LD_VAR 0 7
5889: PUSH
5890: FOR_IN
5891: IFFALSE 5943
// begin p := Inc ( p ) ;
5893: LD_ADDR_VAR 0 6
5897: PUSH
5898: LD_VAR 0 6
5902: PPUSH
5903: CALL 91501 0 1
5907: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5908: LD_VAR 0 2
5912: PPUSH
5913: LD_INT 62
5915: PPUSH
5916: LD_INT 93
5918: PPUSH
5919: LD_INT 9
5921: PPUSH
5922: LD_INT 0
5924: PPUSH
5925: CALL_OW 50
// if p > 36 then
5929: LD_VAR 0 6
5933: PUSH
5934: LD_INT 36
5936: GREATER
5937: IFFALSE 5941
// break ;
5939: GO 5943
// end ;
5941: GO 5890
5943: POP
5944: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5945: LD_ADDR_EXP 78
5949: PUSH
5950: LD_EXP 78
5954: PPUSH
5955: LD_INT 4
5957: PPUSH
5958: LD_INT 22
5960: PUSH
5961: LD_INT 1
5963: PUSH
5964: EMPTY
5965: LIST
5966: LIST
5967: PPUSH
5968: CALL_OW 69
5972: PUSH
5973: LD_EXP 55
5977: DIFF
5978: PPUSH
5979: CALL_OW 1
5983: ST_TO_ADDR
// uc_side := 0 ;
5984: LD_ADDR_OWVAR 20
5988: PUSH
5989: LD_INT 0
5991: ST_TO_ADDR
// uc_nation := 0 ;
5992: LD_ADDR_OWVAR 21
5996: PUSH
5997: LD_INT 0
5999: ST_TO_ADDR
// for i = 1 to 4 do
6000: LD_ADDR_VAR 0 2
6004: PUSH
6005: DOUBLE
6006: LD_INT 1
6008: DEC
6009: ST_TO_ADDR
6010: LD_INT 4
6012: PUSH
6013: FOR_TO
6014: IFFALSE 6045
// begin InitHc ;
6016: CALL_OW 19
// hc_class := class_apeman ;
6020: LD_ADDR_OWVAR 28
6024: PUSH
6025: LD_INT 12
6027: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6028: CALL_OW 44
6032: PPUSH
6033: LD_INT 11
6035: PPUSH
6036: LD_INT 0
6038: PPUSH
6039: CALL_OW 49
// end ;
6043: GO 6013
6045: POP
6046: POP
// end ;
6047: LD_VAR 0 1
6051: RET
// every 9 9$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6052: LD_EXP 4
6056: NOT
6057: IFFALSE 6863
6059: GO 6061
6061: DISABLE
6062: LD_INT 0
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
// begin enable ;
6068: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6069: LD_INT 22
6071: PUSH
6072: LD_INT 1
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PUSH
6079: LD_INT 23
6081: PUSH
6082: LD_INT 1
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: PUSH
6089: LD_INT 30
6091: PUSH
6092: LD_INT 3
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: PPUSH
6104: CALL_OW 69
6108: NOT
6109: IFFALSE 6113
// exit ;
6111: GO 6863
// if Prob ( 40 ) then
6113: LD_INT 40
6115: PPUSH
6116: CALL_OW 13
6120: IFFALSE 6247
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6122: LD_INT 4
6124: PPUSH
6125: LD_INT 5
6127: PUSH
6128: LD_INT 1
6130: PUSH
6131: LD_INT 2
6133: PUSH
6134: LD_INT 7
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: LIST
6141: LIST
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 1
6148: PUSH
6149: LD_INT 2
6151: PUSH
6152: LD_INT 7
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: LIST
6159: LIST
6160: PUSH
6161: LD_INT 5
6163: PUSH
6164: LD_INT 1
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: LD_INT 7
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 5
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: LD_INT 2
6187: PUSH
6188: LD_INT 6
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 5
6199: PUSH
6200: LD_INT 1
6202: PUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 6
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 5
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: LD_INT 2
6223: PUSH
6224: LD_INT 6
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: LIST
6240: PPUSH
6241: CALL 46422 0 2
// end else
6245: GO 6370
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6247: LD_INT 4
6249: PPUSH
6250: LD_INT 5
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: LD_INT 2
6258: PUSH
6259: LD_INT 7
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PUSH
6268: LD_INT 5
6270: PUSH
6271: LD_INT 1
6273: PUSH
6274: LD_INT 2
6276: PUSH
6277: LD_INT 9
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: LIST
6284: LIST
6285: PUSH
6286: LD_INT 5
6288: PUSH
6289: LD_INT 1
6291: PUSH
6292: LD_INT 2
6294: PUSH
6295: LD_INT 9
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 5
6306: PUSH
6307: LD_INT 1
6309: PUSH
6310: LD_INT 2
6312: PUSH
6313: LD_INT 6
6315: PUSH
6316: EMPTY
6317: LIST
6318: LIST
6319: LIST
6320: LIST
6321: PUSH
6322: LD_INT 5
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: LD_INT 2
6330: PUSH
6331: LD_INT 6
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: PUSH
6340: LD_INT 5
6342: PUSH
6343: LD_INT 1
6345: PUSH
6346: LD_INT 2
6348: PUSH
6349: LD_INT 6
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: LIST
6356: LIST
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: PPUSH
6366: CALL 46422 0 2
// end ; p := 0 ;
6370: LD_ADDR_VAR 0 4
6374: PUSH
6375: LD_INT 0
6377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6378: LD_INT 35
6380: PPUSH
6381: CALL_OW 67
// p := Inc ( p ) ;
6385: LD_ADDR_VAR 0 4
6389: PUSH
6390: LD_VAR 0 4
6394: PPUSH
6395: CALL 91501 0 1
6399: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6400: LD_INT 4
6402: PPUSH
6403: LD_INT 1
6405: PPUSH
6406: CALL 47840 0 2
6410: PUSH
6411: LD_INT 6
6413: GREATEREQUAL
6414: PUSH
6415: LD_VAR 0 4
6419: PUSH
6420: LD_INT 100
6422: GREATER
6423: OR
6424: IFFALSE 6378
// wait ( 0 0$30 ) ;
6426: LD_INT 1050
6428: PPUSH
6429: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6433: LD_ADDR_VAR 0 2
6437: PUSH
6438: LD_INT 4
6440: PPUSH
6441: LD_INT 1
6443: PPUSH
6444: CALL 47840 0 2
6448: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6449: LD_ADDR_EXP 97
6453: PUSH
6454: LD_EXP 97
6458: PPUSH
6459: LD_INT 4
6461: PPUSH
6462: LD_EXP 97
6466: PUSH
6467: LD_INT 4
6469: ARRAY
6470: PUSH
6471: LD_VAR 0 2
6475: DIFF
6476: PPUSH
6477: CALL_OW 1
6481: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6482: LD_ADDR_VAR 0 3
6486: PUSH
6487: LD_INT 0
6489: PPUSH
6490: LD_INT 2
6492: PPUSH
6493: CALL_OW 12
6497: ST_TO_ADDR
// if target then
6498: LD_VAR 0 3
6502: IFFALSE 6630
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6504: LD_ADDR_VAR 0 2
6508: PUSH
6509: LD_VAR 0 2
6513: PPUSH
6514: LD_INT 24
6516: PUSH
6517: LD_INT 250
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: PPUSH
6524: CALL_OW 72
6528: ST_TO_ADDR
// for i in tmp do
6529: LD_ADDR_VAR 0 1
6533: PUSH
6534: LD_VAR 0 2
6538: PUSH
6539: FOR_IN
6540: IFFALSE 6580
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6542: LD_VAR 0 1
6546: PPUSH
6547: LD_INT 114
6549: PPUSH
6550: LD_INT 108
6552: PPUSH
6553: CALL_OW 297
6557: PUSH
6558: LD_INT 9
6560: GREATER
6561: IFFALSE 6578
// ComMoveXY ( i , 114 , 108 ) ;
6563: LD_VAR 0 1
6567: PPUSH
6568: LD_INT 114
6570: PPUSH
6571: LD_INT 108
6573: PPUSH
6574: CALL_OW 111
6578: GO 6539
6580: POP
6581: POP
// wait ( 0 0$1 ) ;
6582: LD_INT 35
6584: PPUSH
6585: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6589: LD_VAR 0 2
6593: PPUSH
6594: LD_INT 92
6596: PUSH
6597: LD_INT 114
6599: PUSH
6600: LD_INT 108
6602: PUSH
6603: LD_INT 9
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: LIST
6611: PPUSH
6612: CALL_OW 72
6616: PUSH
6617: LD_VAR 0 2
6621: PUSH
6622: LD_INT 1
6624: MINUS
6625: GREATEREQUAL
6626: IFFALSE 6504
// end else
6628: GO 6754
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6630: LD_ADDR_VAR 0 2
6634: PUSH
6635: LD_VAR 0 2
6639: PPUSH
6640: LD_INT 24
6642: PUSH
6643: LD_INT 250
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: PPUSH
6650: CALL_OW 72
6654: ST_TO_ADDR
// for i in tmp do
6655: LD_ADDR_VAR 0 1
6659: PUSH
6660: LD_VAR 0 2
6664: PUSH
6665: FOR_IN
6666: IFFALSE 6706
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6668: LD_VAR 0 1
6672: PPUSH
6673: LD_INT 129
6675: PPUSH
6676: LD_INT 139
6678: PPUSH
6679: CALL_OW 297
6683: PUSH
6684: LD_INT 9
6686: GREATER
6687: IFFALSE 6704
// ComMoveXY ( i , 129 , 139 ) ;
6689: LD_VAR 0 1
6693: PPUSH
6694: LD_INT 129
6696: PPUSH
6697: LD_INT 139
6699: PPUSH
6700: CALL_OW 111
6704: GO 6665
6706: POP
6707: POP
// wait ( 0 0$1 ) ;
6708: LD_INT 35
6710: PPUSH
6711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6715: LD_VAR 0 2
6719: PPUSH
6720: LD_INT 92
6722: PUSH
6723: LD_INT 129
6725: PUSH
6726: LD_INT 139
6728: PUSH
6729: LD_INT 9
6731: PUSH
6732: EMPTY
6733: LIST
6734: LIST
6735: LIST
6736: LIST
6737: PPUSH
6738: CALL_OW 72
6742: PUSH
6743: LD_VAR 0 2
6747: PUSH
6748: LD_INT 1
6750: MINUS
6751: GREATEREQUAL
6752: IFFALSE 6630
// end ; repeat wait ( 0 0$1 ) ;
6754: LD_INT 35
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 1
6765: PUSH
6766: LD_VAR 0 2
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6854
// begin if GetLives ( i ) > 251 then
6774: LD_VAR 0 1
6778: PPUSH
6779: CALL_OW 256
6783: PUSH
6784: LD_INT 251
6786: GREATER
6787: IFFALSE 6825
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6789: LD_VAR 0 1
6793: PPUSH
6794: LD_INT 81
6796: PUSH
6797: LD_INT 1
6799: PUSH
6800: EMPTY
6801: LIST
6802: LIST
6803: PPUSH
6804: CALL_OW 69
6808: PPUSH
6809: LD_VAR 0 1
6813: PPUSH
6814: CALL_OW 74
6818: PPUSH
6819: CALL_OW 115
6823: GO 6852
// if IsDead ( i ) then
6825: LD_VAR 0 1
6829: PPUSH
6830: CALL_OW 301
6834: IFFALSE 6852
// tmp := tmp diff i ;
6836: LD_ADDR_VAR 0 2
6840: PUSH
6841: LD_VAR 0 2
6845: PUSH
6846: LD_VAR 0 1
6850: DIFF
6851: ST_TO_ADDR
// end ;
6852: GO 6771
6854: POP
6855: POP
// until not tmp ;
6856: LD_VAR 0 2
6860: NOT
6861: IFFALSE 6754
// end ;
6863: PPOPN 4
6865: END
// every 30 30$00 trigger not americanDestroyed do
6866: LD_EXP 4
6870: NOT
6871: IFFALSE 6940
6873: GO 6875
6875: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6876: LD_INT 63000
6878: PUSH
6879: LD_INT 42000
6881: PUSH
6882: LD_INT 31500
6884: PUSH
6885: LD_INT 21000
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: LIST
6892: LIST
6893: PUSH
6894: LD_OWVAR 67
6898: ARRAY
6899: PPUSH
6900: CALL_OW 67
// if americanDestroyed then
6904: LD_EXP 4
6908: IFFALSE 6912
// exit ;
6910: GO 6940
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6912: LD_INT 4
6914: PPUSH
6915: LD_INT 5
6917: PUSH
6918: LD_INT 3
6920: PUSH
6921: LD_INT 1
6923: PUSH
6924: LD_INT 8
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: LIST
6931: LIST
6932: PUSH
6933: EMPTY
6934: LIST
6935: PPUSH
6936: CALL 46422 0 2
// end ; end_of_file
6940: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6941: LD_INT 0
6943: PPUSH
6944: PPUSH
6945: PPUSH
6946: PPUSH
6947: PPUSH
// side := 2 ;
6948: LD_ADDR_VAR 0 5
6952: PUSH
6953: LD_INT 2
6955: ST_TO_ADDR
// InitHc ;
6956: CALL_OW 19
// uc_side := side ;
6960: LD_ADDR_OWVAR 20
6964: PUSH
6965: LD_VAR 0 5
6969: ST_TO_ADDR
// uc_nation := 2 ;
6970: LD_ADDR_OWVAR 21
6974: PUSH
6975: LD_INT 2
6977: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_INT 2
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 21
6995: PUSH
6996: LD_INT 3
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PPUSH
7007: CALL_OW 69
7011: PUSH
7012: FOR_IN
7013: IFFALSE 7029
// SetBLevel ( i , 10 ) ;
7015: LD_VAR 0 2
7019: PPUSH
7020: LD_INT 10
7022: PPUSH
7023: CALL_OW 241
7027: GO 7012
7029: POP
7030: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7031: LD_ADDR_VAR 0 4
7035: PUSH
7036: LD_INT 22
7038: PUSH
7039: LD_VAR 0 5
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: LD_INT 30
7050: PUSH
7051: LD_INT 32
7053: PUSH
7054: EMPTY
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 58
7060: PUSH
7061: EMPTY
7062: LIST
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: LIST
7068: PPUSH
7069: CALL_OW 69
7073: ST_TO_ADDR
// for i = 1 to 10 do
7074: LD_ADDR_VAR 0 2
7078: PUSH
7079: DOUBLE
7080: LD_INT 1
7082: DEC
7083: ST_TO_ADDR
7084: LD_INT 10
7086: PUSH
7087: FOR_TO
7088: IFFALSE 7160
// begin uc_nation := nation_nature ;
7090: LD_ADDR_OWVAR 21
7094: PUSH
7095: LD_INT 0
7097: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7098: LD_ADDR_OWVAR 28
7102: PUSH
7103: LD_INT 15
7105: ST_TO_ADDR
// hc_gallery :=  ;
7106: LD_ADDR_OWVAR 33
7110: PUSH
7111: LD_STRING 
7113: ST_TO_ADDR
// hc_name :=  ;
7114: LD_ADDR_OWVAR 26
7118: PUSH
7119: LD_STRING 
7121: ST_TO_ADDR
// un := CreateHuman ;
7122: LD_ADDR_VAR 0 3
7126: PUSH
7127: CALL_OW 44
7131: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7132: LD_VAR 0 3
7136: PPUSH
7137: LD_VAR 0 4
7141: PUSH
7142: LD_VAR 0 4
7146: PUSH
7147: LD_VAR 0 2
7151: MINUS
7152: ARRAY
7153: PPUSH
7154: CALL_OW 52
// end ;
7158: GO 7087
7160: POP
7161: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7162: LD_INT 503
7164: PPUSH
7165: LD_INT 27
7167: PPUSH
7168: LD_STRING 
7170: PPUSH
7171: LD_INT 8
7173: PUSH
7174: LD_INT 9
7176: PUSH
7177: LD_INT 10
7179: PUSH
7180: LD_INT 10
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: LIST
7187: LIST
7188: PUSH
7189: LD_OWVAR 67
7193: ARRAY
7194: PPUSH
7195: LD_INT 3000
7197: PUSH
7198: LD_INT 500
7200: PUSH
7201: LD_INT 150
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: LIST
7208: PPUSH
7209: LD_INT 16
7211: PUSH
7212: LD_INT 6
7214: PUSH
7215: LD_INT 6
7217: PUSH
7218: LD_INT 6
7220: PUSH
7221: EMPTY
7222: LIST
7223: LIST
7224: LIST
7225: LIST
7226: PPUSH
7227: CALL 61132 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7231: LD_ADDR_EXP 78
7235: PUSH
7236: LD_EXP 78
7240: PPUSH
7241: LD_INT 1
7243: PPUSH
7244: LD_INT 22
7246: PUSH
7247: LD_VAR 0 5
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: PUSH
7256: LD_INT 23
7258: PUSH
7259: LD_INT 2
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 21
7271: PUSH
7272: LD_INT 2
7274: PUSH
7275: EMPTY
7276: LIST
7277: LIST
7278: PUSH
7279: EMPTY
7280: LIST
7281: LIST
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: LIST
7287: PPUSH
7288: CALL_OW 69
7292: PPUSH
7293: CALL_OW 1
7297: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7298: LD_INT 216
7300: PPUSH
7301: LD_INT 228
7303: PPUSH
7304: LD_INT 2
7306: PPUSH
7307: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7311: LD_INT 223
7313: PPUSH
7314: LD_INT 241
7316: PPUSH
7317: LD_INT 2
7319: PPUSH
7320: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7324: LD_INT 216
7326: PPUSH
7327: LD_INT 217
7329: PPUSH
7330: LD_INT 2
7332: PPUSH
7333: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7337: LD_INT 233
7339: PPUSH
7340: LD_INT 257
7342: PPUSH
7343: LD_INT 2
7345: PPUSH
7346: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7350: LD_INT 230
7352: PPUSH
7353: LD_INT 199
7355: PPUSH
7356: LD_INT 2
7358: PPUSH
7359: CALL_OW 244
// end ;
7363: LD_VAR 0 1
7367: RET
// export Omar ; export function PrepareOmarAli ; begin
7368: LD_INT 0
7370: PPUSH
// uc_side := 5 ;
7371: LD_ADDR_OWVAR 20
7375: PUSH
7376: LD_INT 5
7378: ST_TO_ADDR
// uc_nation := 2 ;
7379: LD_ADDR_OWVAR 21
7383: PUSH
7384: LD_INT 2
7386: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7387: LD_ADDR_EXP 56
7391: PUSH
7392: LD_STRING Omar
7394: PPUSH
7395: CALL_OW 25
7399: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7400: LD_EXP 56
7404: PPUSH
7405: LD_INT 330
7407: PPUSH
7408: LD_INT 244
7410: PPUSH
7411: LD_INT 0
7413: PPUSH
7414: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7418: LD_EXP 56
7422: PPUSH
7423: LD_INT 252
7425: PPUSH
7426: LD_INT 220
7428: PPUSH
7429: CALL_OW 111
// end ; end_of_file
7433: LD_VAR 0 1
7437: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7438: LD_INT 0
7440: PPUSH
7441: PPUSH
7442: PPUSH
7443: PPUSH
7444: PPUSH
// side := 8 ;
7445: LD_ADDR_VAR 0 3
7449: PUSH
7450: LD_INT 8
7452: ST_TO_ADDR
// InitHc ;
7453: CALL_OW 19
// uc_side := side ;
7457: LD_ADDR_OWVAR 20
7461: PUSH
7462: LD_VAR 0 3
7466: ST_TO_ADDR
// uc_nation := 2 ;
7467: LD_ADDR_OWVAR 21
7471: PUSH
7472: LD_INT 2
7474: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7475: LD_ADDR_VAR 0 2
7479: PUSH
7480: LD_INT 22
7482: PUSH
7483: LD_VAR 0 3
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PUSH
7492: LD_INT 21
7494: PUSH
7495: LD_INT 3
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PPUSH
7506: CALL_OW 69
7510: PUSH
7511: FOR_IN
7512: IFFALSE 7528
// SetBLevel ( i , 10 ) ;
7514: LD_VAR 0 2
7518: PPUSH
7519: LD_INT 10
7521: PPUSH
7522: CALL_OW 241
7526: GO 7511
7528: POP
7529: POP
// Schulz := NewCharacter ( Schulz ) ;
7530: LD_ADDR_EXP 57
7534: PUSH
7535: LD_STRING Schulz
7537: PPUSH
7538: CALL_OW 25
7542: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7543: LD_ADDR_EXP 59
7547: PUSH
7548: LD_STRING Kaia
7550: PPUSH
7551: CALL_OW 25
7555: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7556: LD_EXP 59
7560: PPUSH
7561: LD_INT 324
7563: PPUSH
7564: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7568: LD_ADDR_EXP 58
7572: PUSH
7573: LD_STRING Kozlov
7575: PPUSH
7576: LD_INT 0
7578: PPUSH
7579: LD_STRING 
7581: PPUSH
7582: CALL 52848 0 3
7586: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7587: LD_EXP 58
7591: PPUSH
7592: LD_INT 22
7594: PUSH
7595: LD_INT 8
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 23
7604: PUSH
7605: LD_INT 3
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 30
7614: PUSH
7615: LD_INT 8
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: LIST
7626: PPUSH
7627: CALL_OW 69
7631: PUSH
7632: LD_INT 1
7634: ARRAY
7635: PPUSH
7636: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7640: LD_EXP 58
7644: PPUSH
7645: LD_INT 3
7647: PPUSH
7648: LD_INT 10
7650: PPUSH
7651: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7655: LD_ADDR_VAR 0 5
7659: PUSH
7660: LD_INT 22
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: LD_INT 30
7674: PUSH
7675: LD_INT 32
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: LD_INT 58
7684: PUSH
7685: EMPTY
7686: LIST
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: PPUSH
7693: CALL_OW 69
7697: ST_TO_ADDR
// for i = 1 to 10 do
7698: LD_ADDR_VAR 0 2
7702: PUSH
7703: DOUBLE
7704: LD_INT 1
7706: DEC
7707: ST_TO_ADDR
7708: LD_INT 10
7710: PUSH
7711: FOR_TO
7712: IFFALSE 7784
// begin uc_nation := nation_nature ;
7714: LD_ADDR_OWVAR 21
7718: PUSH
7719: LD_INT 0
7721: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7722: LD_ADDR_OWVAR 28
7726: PUSH
7727: LD_INT 15
7729: ST_TO_ADDR
// hc_gallery :=  ;
7730: LD_ADDR_OWVAR 33
7734: PUSH
7735: LD_STRING 
7737: ST_TO_ADDR
// hc_name :=  ;
7738: LD_ADDR_OWVAR 26
7742: PUSH
7743: LD_STRING 
7745: ST_TO_ADDR
// un := CreateHuman ;
7746: LD_ADDR_VAR 0 4
7750: PUSH
7751: CALL_OW 44
7755: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7756: LD_VAR 0 4
7760: PPUSH
7761: LD_VAR 0 5
7765: PUSH
7766: LD_VAR 0 5
7770: PUSH
7771: LD_VAR 0 2
7775: MINUS
7776: ARRAY
7777: PPUSH
7778: CALL_OW 52
// end ;
7782: GO 7711
7784: POP
7785: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7786: LD_INT 324
7788: PPUSH
7789: LD_INT 3
7791: PPUSH
7792: LD_STRING 
7794: PPUSH
7795: LD_INT 8
7797: PUSH
7798: LD_INT 9
7800: PUSH
7801: LD_INT 10
7803: PUSH
7804: LD_INT 10
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: PUSH
7813: LD_OWVAR 67
7817: ARRAY
7818: PPUSH
7819: LD_INT 3000
7821: PUSH
7822: LD_INT 500
7824: PUSH
7825: LD_INT 150
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: LIST
7832: PPUSH
7833: LD_INT 16
7835: PUSH
7836: LD_INT 6
7838: PUSH
7839: LD_INT 6
7841: PUSH
7842: LD_INT 8
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: PPUSH
7851: CALL 61132 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7855: LD_ADDR_EXP 78
7859: PUSH
7860: LD_EXP 78
7864: PPUSH
7865: LD_INT 3
7867: PPUSH
7868: LD_INT 22
7870: PUSH
7871: LD_VAR 0 3
7875: PUSH
7876: EMPTY
7877: LIST
7878: LIST
7879: PUSH
7880: LD_INT 23
7882: PUSH
7883: LD_INT 2
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: PUSH
7890: LD_INT 3
7892: PUSH
7893: LD_INT 21
7895: PUSH
7896: LD_INT 2
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: EMPTY
7908: LIST
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 69
7916: PUSH
7917: LD_EXP 57
7921: DIFF
7922: PPUSH
7923: CALL_OW 1
7927: ST_TO_ADDR
// end ;
7928: LD_VAR 0 1
7932: RET
// export function BuildKozlovBomb ; begin
7933: LD_INT 0
7935: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7936: LD_INT 332
7938: PPUSH
7939: CALL_OW 302
7943: NOT
7944: PUSH
7945: LD_INT 336
7947: PPUSH
7948: CALL_OW 302
7952: NOT
7953: OR
7954: IFFALSE 7958
// exit ;
7956: GO 8055
// ComChangeProfession ( Kozlov , 4 ) ;
7958: LD_EXP 58
7962: PPUSH
7963: LD_INT 4
7965: PPUSH
7966: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7970: LD_INT 336
7972: PPUSH
7973: LD_INT 25
7975: PPUSH
7976: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7980: LD_INT 35
7982: PPUSH
7983: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7987: LD_INT 25
7989: PPUSH
7990: LD_INT 8
7992: PPUSH
7993: CALL_OW 321
7997: PUSH
7998: LD_INT 2
8000: EQUAL
8001: IFFALSE 7980
// ComExitBuilding ( Kozlov ) ;
8003: LD_EXP 58
8007: PPUSH
8008: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8012: LD_EXP 58
8016: PPUSH
8017: LD_INT 332
8019: PPUSH
8020: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8024: LD_EXP 58
8028: PPUSH
8029: LD_INT 3
8031: PPUSH
8032: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8036: LD_INT 332
8038: PPUSH
8039: LD_INT 23
8041: PPUSH
8042: LD_INT 3
8044: PPUSH
8045: LD_INT 1
8047: PPUSH
8048: LD_INT 48
8050: PPUSH
8051: CALL_OW 125
// end ;
8055: LD_VAR 0 1
8059: RET
// every 9 9$30 + 7 7$00 trigger not legionDestroyed do var i , tmp , target , p ;
8060: LD_EXP 3
8064: NOT
8065: IFFALSE 8955
8067: GO 8069
8069: DISABLE
8070: LD_INT 0
8072: PPUSH
8073: PPUSH
8074: PPUSH
8075: PPUSH
// begin enable ;
8076: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8077: LD_INT 22
8079: PUSH
8080: LD_INT 8
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: PUSH
8087: LD_INT 23
8089: PUSH
8090: LD_INT 2
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: PUSH
8097: LD_INT 30
8099: PUSH
8100: LD_INT 3
8102: PUSH
8103: EMPTY
8104: LIST
8105: LIST
8106: PUSH
8107: EMPTY
8108: LIST
8109: LIST
8110: LIST
8111: PPUSH
8112: CALL_OW 69
8116: NOT
8117: IFFALSE 8121
// exit ;
8119: GO 8955
// if Prob ( 40 ) then
8121: LD_INT 40
8123: PPUSH
8124: CALL_OW 13
8128: IFFALSE 8255
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8130: LD_INT 3
8132: PPUSH
8133: LD_INT 14
8135: PUSH
8136: LD_INT 1
8138: PUSH
8139: LD_INT 2
8141: PUSH
8142: LD_INT 28
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 14
8153: PUSH
8154: LD_INT 1
8156: PUSH
8157: LD_INT 2
8159: PUSH
8160: LD_INT 28
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: PUSH
8169: LD_INT 14
8171: PUSH
8172: LD_INT 1
8174: PUSH
8175: LD_INT 2
8177: PUSH
8178: LD_INT 28
8180: PUSH
8181: EMPTY
8182: LIST
8183: LIST
8184: LIST
8185: LIST
8186: PUSH
8187: LD_INT 14
8189: PUSH
8190: LD_INT 1
8192: PUSH
8193: LD_INT 2
8195: PUSH
8196: LD_INT 28
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: LIST
8203: LIST
8204: PUSH
8205: LD_INT 14
8207: PUSH
8208: LD_INT 1
8210: PUSH
8211: LD_INT 2
8213: PUSH
8214: LD_INT 28
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_INT 14
8225: PUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 2
8231: PUSH
8232: LD_INT 26
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: LIST
8239: LIST
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: LIST
8247: LIST
8248: PPUSH
8249: CALL 46422 0 2
// end else
8253: GO 8462
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8255: LD_INT 3
8257: PPUSH
8258: LD_INT 14
8260: PUSH
8261: LD_INT 1
8263: PUSH
8264: LD_INT 2
8266: PUSH
8267: LD_INT 27
8269: PUSH
8270: LD_INT 26
8272: PUSH
8273: LD_INT 26
8275: PUSH
8276: LD_INT 28
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: LIST
8283: LIST
8284: PUSH
8285: LD_OWVAR 67
8289: ARRAY
8290: PUSH
8291: EMPTY
8292: LIST
8293: LIST
8294: LIST
8295: LIST
8296: PUSH
8297: LD_INT 14
8299: PUSH
8300: LD_INT 1
8302: PUSH
8303: LD_INT 2
8305: PUSH
8306: LD_INT 27
8308: PUSH
8309: LD_INT 26
8311: PUSH
8312: LD_INT 26
8314: PUSH
8315: LD_INT 26
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: LIST
8322: LIST
8323: PUSH
8324: LD_OWVAR 67
8328: ARRAY
8329: PUSH
8330: EMPTY
8331: LIST
8332: LIST
8333: LIST
8334: LIST
8335: PUSH
8336: LD_INT 14
8338: PUSH
8339: LD_INT 1
8341: PUSH
8342: LD_INT 2
8344: PUSH
8345: LD_INT 26
8347: PUSH
8348: LD_INT 26
8350: PUSH
8351: LD_INT 29
8353: PUSH
8354: LD_INT 29
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: PUSH
8363: LD_OWVAR 67
8367: ARRAY
8368: PUSH
8369: EMPTY
8370: LIST
8371: LIST
8372: LIST
8373: LIST
8374: PUSH
8375: LD_INT 13
8377: PUSH
8378: LD_INT 1
8380: PUSH
8381: LD_INT 2
8383: PUSH
8384: LD_INT 26
8386: PUSH
8387: LD_INT 29
8389: PUSH
8390: LD_INT 29
8392: PUSH
8393: LD_INT 29
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: PUSH
8402: LD_OWVAR 67
8406: ARRAY
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 13
8416: PUSH
8417: LD_INT 1
8419: PUSH
8420: LD_INT 2
8422: PUSH
8423: LD_INT 29
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: LD_INT 14
8434: PUSH
8435: LD_INT 1
8437: PUSH
8438: LD_INT 2
8440: PUSH
8441: LD_INT 26
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: LIST
8448: LIST
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: LIST
8454: LIST
8455: LIST
8456: LIST
8457: PPUSH
8458: CALL 46422 0 2
// end ; p := 0 ;
8462: LD_ADDR_VAR 0 4
8466: PUSH
8467: LD_INT 0
8469: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8470: LD_INT 35
8472: PPUSH
8473: CALL_OW 67
// p := Inc ( p ) ;
8477: LD_ADDR_VAR 0 4
8481: PUSH
8482: LD_VAR 0 4
8486: PPUSH
8487: CALL 91501 0 1
8491: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8492: LD_INT 3
8494: PPUSH
8495: LD_INT 1
8497: PPUSH
8498: CALL 47840 0 2
8502: PUSH
8503: LD_INT 6
8505: GREATEREQUAL
8506: PUSH
8507: LD_VAR 0 4
8511: PUSH
8512: LD_INT 100
8514: GREATER
8515: OR
8516: IFFALSE 8470
// wait ( 0 0$30 ) ;
8518: LD_INT 1050
8520: PPUSH
8521: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8525: LD_ADDR_VAR 0 2
8529: PUSH
8530: LD_INT 3
8532: PPUSH
8533: LD_INT 1
8535: PPUSH
8536: CALL 47840 0 2
8540: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8541: LD_ADDR_EXP 97
8545: PUSH
8546: LD_EXP 97
8550: PPUSH
8551: LD_INT 3
8553: PPUSH
8554: LD_EXP 97
8558: PUSH
8559: LD_INT 3
8561: ARRAY
8562: PUSH
8563: LD_VAR 0 2
8567: DIFF
8568: PPUSH
8569: CALL_OW 1
8573: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8574: LD_ADDR_VAR 0 3
8578: PUSH
8579: LD_INT 0
8581: PPUSH
8582: LD_INT 2
8584: PPUSH
8585: CALL_OW 12
8589: ST_TO_ADDR
// if target then
8590: LD_VAR 0 3
8594: IFFALSE 8722
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8596: LD_ADDR_VAR 0 2
8600: PUSH
8601: LD_VAR 0 2
8605: PPUSH
8606: LD_INT 24
8608: PUSH
8609: LD_INT 250
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PPUSH
8616: CALL_OW 72
8620: ST_TO_ADDR
// for i in tmp do
8621: LD_ADDR_VAR 0 1
8625: PUSH
8626: LD_VAR 0 2
8630: PUSH
8631: FOR_IN
8632: IFFALSE 8672
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8634: LD_VAR 0 1
8638: PPUSH
8639: LD_INT 89
8641: PPUSH
8642: LD_INT 71
8644: PPUSH
8645: CALL_OW 297
8649: PUSH
8650: LD_INT 9
8652: GREATER
8653: IFFALSE 8670
// ComMoveXY ( i , 89 , 71 ) ;
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_INT 89
8662: PPUSH
8663: LD_INT 71
8665: PPUSH
8666: CALL_OW 111
8670: GO 8631
8672: POP
8673: POP
// wait ( 0 0$1 ) ;
8674: LD_INT 35
8676: PPUSH
8677: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8681: LD_VAR 0 2
8685: PPUSH
8686: LD_INT 92
8688: PUSH
8689: LD_INT 89
8691: PUSH
8692: LD_INT 71
8694: PUSH
8695: LD_INT 9
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: LIST
8702: LIST
8703: PPUSH
8704: CALL_OW 72
8708: PUSH
8709: LD_VAR 0 2
8713: PUSH
8714: LD_INT 1
8716: MINUS
8717: GREATEREQUAL
8718: IFFALSE 8596
// end else
8720: GO 8846
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8722: LD_ADDR_VAR 0 2
8726: PUSH
8727: LD_VAR 0 2
8731: PPUSH
8732: LD_INT 24
8734: PUSH
8735: LD_INT 250
8737: PUSH
8738: EMPTY
8739: LIST
8740: LIST
8741: PPUSH
8742: CALL_OW 72
8746: ST_TO_ADDR
// for i in tmp do
8747: LD_ADDR_VAR 0 1
8751: PUSH
8752: LD_VAR 0 2
8756: PUSH
8757: FOR_IN
8758: IFFALSE 8798
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8760: LD_VAR 0 1
8764: PPUSH
8765: LD_INT 147
8767: PPUSH
8768: LD_INT 4
8770: PPUSH
8771: CALL_OW 297
8775: PUSH
8776: LD_INT 9
8778: GREATER
8779: IFFALSE 8796
// ComMoveXY ( i , 147 , 4 ) ;
8781: LD_VAR 0 1
8785: PPUSH
8786: LD_INT 147
8788: PPUSH
8789: LD_INT 4
8791: PPUSH
8792: CALL_OW 111
8796: GO 8757
8798: POP
8799: POP
// wait ( 0 0$1 ) ;
8800: LD_INT 35
8802: PPUSH
8803: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8807: LD_VAR 0 2
8811: PPUSH
8812: LD_INT 92
8814: PUSH
8815: LD_INT 147
8817: PUSH
8818: LD_INT 4
8820: PUSH
8821: LD_INT 9
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: LIST
8828: LIST
8829: PPUSH
8830: CALL_OW 72
8834: PUSH
8835: LD_VAR 0 2
8839: PUSH
8840: LD_INT 1
8842: MINUS
8843: GREATEREQUAL
8844: IFFALSE 8722
// end ; repeat wait ( 0 0$1 ) ;
8846: LD_INT 35
8848: PPUSH
8849: CALL_OW 67
// for i in tmp do
8853: LD_ADDR_VAR 0 1
8857: PUSH
8858: LD_VAR 0 2
8862: PUSH
8863: FOR_IN
8864: IFFALSE 8946
// begin if GetLives ( i ) > 251 then
8866: LD_VAR 0 1
8870: PPUSH
8871: CALL_OW 256
8875: PUSH
8876: LD_INT 251
8878: GREATER
8879: IFFALSE 8917
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8881: LD_VAR 0 1
8885: PPUSH
8886: LD_INT 81
8888: PUSH
8889: LD_INT 8
8891: PUSH
8892: EMPTY
8893: LIST
8894: LIST
8895: PPUSH
8896: CALL_OW 69
8900: PPUSH
8901: LD_VAR 0 1
8905: PPUSH
8906: CALL_OW 74
8910: PPUSH
8911: CALL_OW 115
8915: GO 8944
// if IsDead ( i ) then
8917: LD_VAR 0 1
8921: PPUSH
8922: CALL_OW 301
8926: IFFALSE 8944
// tmp := tmp diff i ;
8928: LD_ADDR_VAR 0 2
8932: PUSH
8933: LD_VAR 0 2
8937: PUSH
8938: LD_VAR 0 1
8942: DIFF
8943: ST_TO_ADDR
// end ;
8944: GO 8863
8946: POP
8947: POP
// until not tmp ;
8948: LD_VAR 0 2
8952: NOT
8953: IFFALSE 8846
// end ;
8955: PPOPN 4
8957: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8958: LD_EXP 58
8962: PPUSH
8963: CALL_OW 302
8967: PUSH
8968: LD_EXP 3
8972: NOT
8973: AND
8974: IFFALSE 8983
8976: GO 8978
8978: DISABLE
// BuildKozlovBomb ;
8979: CALL 7933 0 0
8983: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8984: LD_INT 22
8986: PUSH
8987: LD_INT 8
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: PUSH
8994: LD_INT 34
8996: PUSH
8997: LD_INT 48
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PPUSH
9008: CALL_OW 69
9012: IFFALSE 9060
9014: GO 9016
9016: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9017: LD_INT 22
9019: PUSH
9020: LD_INT 8
9022: PUSH
9023: EMPTY
9024: LIST
9025: LIST
9026: PUSH
9027: LD_INT 34
9029: PUSH
9030: LD_INT 48
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: PPUSH
9041: CALL_OW 69
9045: PUSH
9046: LD_INT 1
9048: ARRAY
9049: PPUSH
9050: LD_INT 173
9052: PPUSH
9053: LD_INT 96
9055: PPUSH
9056: CALL_OW 116
// end ; end_of_file
9060: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9061: LD_INT 0
9063: PPUSH
9064: PPUSH
9065: PPUSH
9066: PPUSH
9067: PPUSH
9068: PPUSH
9069: PPUSH
9070: PPUSH
9071: PPUSH
9072: PPUSH
// side := 3 ;
9073: LD_ADDR_VAR 0 6
9077: PUSH
9078: LD_INT 3
9080: ST_TO_ADDR
// InitHc ;
9081: CALL_OW 19
// uc_side := side ;
9085: LD_ADDR_OWVAR 20
9089: PUSH
9090: LD_VAR 0 6
9094: ST_TO_ADDR
// uc_nation := 3 ;
9095: LD_ADDR_OWVAR 21
9099: PUSH
9100: LD_INT 3
9102: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9103: LD_ADDR_VAR 0 2
9107: PUSH
9108: LD_INT 22
9110: PUSH
9111: LD_VAR 0 6
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 21
9122: PUSH
9123: LD_INT 3
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PPUSH
9134: CALL_OW 69
9138: PUSH
9139: FOR_IN
9140: IFFALSE 9156
// SetBLevel ( i , 10 ) ;
9142: LD_VAR 0 2
9146: PPUSH
9147: LD_INT 10
9149: PPUSH
9150: CALL_OW 241
9154: GO 9139
9156: POP
9157: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9158: LD_ADDR_VAR 0 10
9162: PUSH
9163: LD_INT 22
9165: PUSH
9166: LD_VAR 0 6
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: PUSH
9175: LD_INT 30
9177: PUSH
9178: LD_INT 34
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: PPUSH
9189: CALL_OW 69
9193: ST_TO_ADDR
// if teleport then
9194: LD_VAR 0 10
9198: IFFALSE 9219
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9200: LD_VAR 0 10
9204: PUSH
9205: LD_INT 1
9207: ARRAY
9208: PPUSH
9209: LD_INT 123
9211: PPUSH
9212: LD_INT 122
9214: PPUSH
9215: CALL_OW 243
// hc_importance := 0 ;
9219: LD_ADDR_OWVAR 32
9223: PUSH
9224: LD_INT 0
9226: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9227: LD_ADDR_EXP 60
9231: PUSH
9232: LD_STRING Platonov
9234: PPUSH
9235: CALL_OW 25
9239: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9240: LD_ADDR_EXP 61
9244: PUSH
9245: LD_STRING Yakotich
9247: PPUSH
9248: LD_EXP 1
9252: NOT
9253: PPUSH
9254: LD_STRING 09_
9256: PPUSH
9257: CALL 52848 0 3
9261: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9262: LD_ADDR_EXP 62
9266: PUSH
9267: LD_STRING Gleb
9269: PPUSH
9270: CALL_OW 25
9274: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9275: LD_STRING 03_Cornel
9277: PPUSH
9278: CALL_OW 28
9282: IFFALSE 9330
// begin Bierezov := NewCharacter ( Mikhail ) ;
9284: LD_ADDR_EXP 63
9288: PUSH
9289: LD_STRING Mikhail
9291: PPUSH
9292: CALL_OW 25
9296: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9297: LD_EXP 63
9301: PPUSH
9302: LD_INT 197
9304: PPUSH
9305: LD_INT 111
9307: PPUSH
9308: LD_INT 9
9310: PPUSH
9311: LD_INT 0
9313: PPUSH
9314: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9318: LD_EXP 63
9322: PPUSH
9323: LD_INT 3
9325: PPUSH
9326: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9330: LD_EXP 60
9334: PPUSH
9335: LD_INT 126
9337: PPUSH
9338: CALL_OW 52
// if Yakotich then
9342: LD_EXP 61
9346: IFFALSE 9369
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9348: LD_EXP 61
9352: PPUSH
9353: LD_INT 197
9355: PPUSH
9356: LD_INT 111
9358: PPUSH
9359: LD_INT 9
9361: PPUSH
9362: LD_INT 0
9364: PPUSH
9365: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9369: LD_EXP 62
9373: PPUSH
9374: LD_INT 197
9376: PPUSH
9377: LD_INT 111
9379: PPUSH
9380: LD_INT 9
9382: PPUSH
9383: LD_INT 0
9385: PPUSH
9386: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9390: LD_ADDR_VAR 0 5
9394: PUSH
9395: LD_INT 126
9397: PPUSH
9398: LD_INT 2
9400: PPUSH
9401: LD_STRING zhukov
9403: PPUSH
9404: LD_INT 9
9406: PUSH
9407: LD_INT 10
9409: PUSH
9410: LD_INT 10
9412: PUSH
9413: LD_INT 10
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_OWVAR 67
9426: ARRAY
9427: PPUSH
9428: LD_INT 9000
9430: PUSH
9431: LD_INT 1000
9433: PUSH
9434: LD_INT 300
9436: PUSH
9437: EMPTY
9438: LIST
9439: LIST
9440: LIST
9441: PPUSH
9442: LD_INT 21
9444: PUSH
9445: LD_INT 8
9447: PUSH
9448: LD_INT 13
9450: PUSH
9451: LD_INT 8
9453: PUSH
9454: EMPTY
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: PPUSH
9460: CALL 61132 0 6
9464: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9465: LD_ADDR_EXP 78
9469: PUSH
9470: LD_EXP 78
9474: PPUSH
9475: LD_INT 2
9477: PPUSH
9478: LD_VAR 0 5
9482: PUSH
9483: LD_EXP 61
9487: PUSH
9488: LD_EXP 62
9492: PUSH
9493: LD_EXP 63
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: UNION
9503: PPUSH
9504: CALL_OW 1
9508: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9509: LD_ADDR_VAR 0 4
9513: PUSH
9514: LD_INT 267
9516: PPUSH
9517: CALL_OW 274
9521: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9522: LD_VAR 0 4
9526: PPUSH
9527: LD_INT 1
9529: PPUSH
9530: LD_INT 5000
9532: PPUSH
9533: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9537: LD_VAR 0 4
9541: PPUSH
9542: LD_INT 2
9544: PPUSH
9545: LD_INT 200
9547: PPUSH
9548: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9552: LD_VAR 0 4
9556: PPUSH
9557: LD_INT 3
9559: PPUSH
9560: LD_INT 200
9562: PPUSH
9563: CALL_OW 277
// for i := 1 to 6 do
9567: LD_ADDR_VAR 0 2
9571: PUSH
9572: DOUBLE
9573: LD_INT 1
9575: DEC
9576: ST_TO_ADDR
9577: LD_INT 6
9579: PUSH
9580: FOR_TO
9581: IFFALSE 9664
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
9583: LD_INT 0
9585: PPUSH
9586: LD_INT 8
9588: PUSH
9589: LD_INT 9
9591: PUSH
9592: LD_INT 10
9594: PUSH
9595: LD_INT 10
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: PUSH
9604: LD_OWVAR 67
9608: ARRAY
9609: PPUSH
9610: CALL_OW 381
// un := CreateHuman ;
9614: LD_ADDR_VAR 0 8
9618: PUSH
9619: CALL_OW 44
9623: ST_TO_ADDR
// if i mod 2 = 0 then
9624: LD_VAR 0 2
9628: PUSH
9629: LD_INT 2
9631: MOD
9632: PUSH
9633: LD_INT 0
9635: EQUAL
9636: IFFALSE 9650
// SetClass ( un , class_bazooker ) ;
9638: LD_VAR 0 8
9642: PPUSH
9643: LD_INT 9
9645: PPUSH
9646: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
9650: LD_VAR 0 8
9654: PPUSH
9655: LD_INT 674
9657: PPUSH
9658: CALL_OW 52
// end ;
9662: GO 9580
9664: POP
9665: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
9666: LD_INT 21
9668: PPUSH
9669: LD_INT 3
9671: PPUSH
9672: LD_INT 3
9674: PPUSH
9675: LD_INT 52
9677: PPUSH
9678: LD_INT 100
9680: PPUSH
9681: CALL 57688 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
9685: CALL_OW 45
9689: PPUSH
9690: LD_INT 259
9692: PPUSH
9693: LD_INT 145
9695: PPUSH
9696: LD_INT 3
9698: PPUSH
9699: LD_INT 0
9701: PPUSH
9702: CALL 92280 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
9706: CALL_OW 45
9710: PPUSH
9711: LD_INT 245
9713: PPUSH
9714: LD_INT 139
9716: PPUSH
9717: LD_INT 3
9719: PPUSH
9720: LD_INT 0
9722: PPUSH
9723: CALL 92280 0 5
// behemoths := [ ] ;
9727: LD_ADDR_EXP 64
9731: PUSH
9732: EMPTY
9733: ST_TO_ADDR
// behemothBuilders := [ ] ;
9734: LD_ADDR_EXP 65
9738: PUSH
9739: EMPTY
9740: ST_TO_ADDR
// j := 3 ;
9741: LD_ADDR_VAR 0 3
9745: PUSH
9746: LD_INT 3
9748: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9749: LD_ADDR_VAR 0 2
9753: PUSH
9754: LD_INT 22
9756: PUSH
9757: LD_INT 3
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: PUSH
9764: LD_INT 25
9766: PUSH
9767: LD_INT 3
9769: PUSH
9770: EMPTY
9771: LIST
9772: LIST
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PPUSH
9778: CALL_OW 69
9782: PUSH
9783: FOR_IN
9784: IFFALSE 9834
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9786: LD_ADDR_EXP 65
9790: PUSH
9791: LD_EXP 65
9795: PPUSH
9796: LD_VAR 0 2
9800: PPUSH
9801: CALL 90140 0 2
9805: ST_TO_ADDR
// j := j - 1 ;
9806: LD_ADDR_VAR 0 3
9810: PUSH
9811: LD_VAR 0 3
9815: PUSH
9816: LD_INT 1
9818: MINUS
9819: ST_TO_ADDR
// if j = 0 then
9820: LD_VAR 0 3
9824: PUSH
9825: LD_INT 0
9827: EQUAL
9828: IFFALSE 9832
// break ;
9830: GO 9834
// end ;
9832: GO 9783
9834: POP
9835: POP
// end ;
9836: LD_VAR 0 1
9840: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9841: LD_INT 0
9843: PPUSH
9844: PPUSH
9845: PPUSH
9846: PPUSH
9847: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9848: LD_ADDR_VAR 0 4
9852: PUSH
9853: LD_INT 209
9855: PUSH
9856: LD_INT 149
9858: PUSH
9859: EMPTY
9860: LIST
9861: LIST
9862: PUSH
9863: LD_INT 219
9865: PUSH
9866: LD_INT 154
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: PUSH
9873: LD_INT 223
9875: PUSH
9876: LD_INT 149
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: PUSH
9883: LD_INT 232
9885: PUSH
9886: LD_INT 155
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: LIST
9897: LIST
9898: ST_TO_ADDR
// if not behemothBuilders then
9899: LD_EXP 65
9903: NOT
9904: IFFALSE 9908
// exit ;
9906: GO 10012
// j := 1 ;
9908: LD_ADDR_VAR 0 3
9912: PUSH
9913: LD_INT 1
9915: ST_TO_ADDR
// for i in behemothBuilders do
9916: LD_ADDR_VAR 0 2
9920: PUSH
9921: LD_EXP 65
9925: PUSH
9926: FOR_IN
9927: IFFALSE 10010
// begin if IsInUnit ( i ) then
9929: LD_VAR 0 2
9933: PPUSH
9934: CALL_OW 310
9938: IFFALSE 9949
// ComExitBuilding ( i ) ;
9940: LD_VAR 0 2
9944: PPUSH
9945: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9949: LD_VAR 0 2
9953: PPUSH
9954: LD_INT 37
9956: PPUSH
9957: LD_VAR 0 4
9961: PUSH
9962: LD_VAR 0 3
9966: ARRAY
9967: PUSH
9968: LD_INT 1
9970: ARRAY
9971: PPUSH
9972: LD_VAR 0 4
9976: PUSH
9977: LD_VAR 0 3
9981: ARRAY
9982: PUSH
9983: LD_INT 2
9985: ARRAY
9986: PPUSH
9987: LD_INT 0
9989: PPUSH
9990: CALL_OW 230
// j := j + 1 ;
9994: LD_ADDR_VAR 0 3
9998: PUSH
9999: LD_VAR 0 3
10003: PUSH
10004: LD_INT 1
10006: PLUS
10007: ST_TO_ADDR
// end ;
10008: GO 9926
10010: POP
10011: POP
// end ;
10012: LD_VAR 0 1
10016: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10017: LD_INT 3
10019: PPUSH
10020: CALL 90201 0 1
10024: PUSH
10025: LD_INT 22
10027: PUSH
10028: LD_INT 3
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PUSH
10035: LD_INT 30
10037: PUSH
10038: LD_INT 37
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: PPUSH
10049: CALL_OW 69
10053: NOT
10054: AND
10055: IFFALSE 10241
10057: GO 10059
10059: DISABLE
10060: LD_INT 0
10062: PPUSH
10063: PPUSH
// begin enable ;
10064: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10065: LD_ADDR_VAR 0 2
10069: PUSH
10070: LD_INT 3
10072: PPUSH
10073: CALL 90201 0 1
10077: ST_TO_ADDR
// for i in tmp do
10078: LD_ADDR_VAR 0 1
10082: PUSH
10083: LD_VAR 0 2
10087: PUSH
10088: FOR_IN
10089: IFFALSE 10239
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10091: LD_VAR 0 1
10095: PPUSH
10096: LD_INT 7
10098: PPUSH
10099: CALL_OW 308
10103: PUSH
10104: LD_VAR 0 1
10108: PPUSH
10109: CALL_OW 110
10113: PUSH
10114: LD_INT 2
10116: EQUAL
10117: NOT
10118: AND
10119: IFFALSE 10133
// SetTag ( i , 2 ) ;
10121: LD_VAR 0 1
10125: PPUSH
10126: LD_INT 2
10128: PPUSH
10129: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10133: LD_INT 81
10135: PUSH
10136: LD_INT 3
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: PUSH
10143: LD_INT 91
10145: PUSH
10146: LD_VAR 0 1
10150: PUSH
10151: LD_INT 12
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: LIST
10158: PUSH
10159: EMPTY
10160: LIST
10161: LIST
10162: PPUSH
10163: CALL_OW 69
10167: NOT
10168: PUSH
10169: LD_VAR 0 1
10173: PPUSH
10174: CALL_OW 110
10178: PUSH
10179: LD_INT 2
10181: EQUAL
10182: NOT
10183: AND
10184: IFFALSE 10203
// ComAgressiveMove ( i , 64 , 93 ) else
10186: LD_VAR 0 1
10190: PPUSH
10191: LD_INT 64
10193: PPUSH
10194: LD_INT 93
10196: PPUSH
10197: CALL_OW 114
10201: GO 10237
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10203: LD_VAR 0 1
10207: PPUSH
10208: LD_INT 81
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: EMPTY
10215: LIST
10216: LIST
10217: PPUSH
10218: CALL_OW 69
10222: PPUSH
10223: LD_VAR 0 1
10227: PPUSH
10228: CALL_OW 74
10232: PPUSH
10233: CALL_OW 115
// end ;
10237: GO 10088
10239: POP
10240: POP
// end ;
10241: PPOPN 2
10243: END
// every 9 9$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10244: LD_EXP 2
10248: NOT
10249: IFFALSE 11207
10251: GO 10253
10253: DISABLE
10254: LD_INT 0
10256: PPUSH
10257: PPUSH
10258: PPUSH
10259: PPUSH
10260: PPUSH
// begin enable ;
10261: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10262: LD_INT 22
10264: PUSH
10265: LD_INT 3
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PUSH
10272: LD_INT 30
10274: PUSH
10275: LD_INT 3
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: PPUSH
10286: CALL_OW 69
10290: NOT
10291: IFFALSE 10295
// exit ;
10293: GO 11207
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10295: LD_ADDR_VAR 0 4
10299: PUSH
10300: LD_INT 22
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PUSH
10310: LD_INT 30
10312: PUSH
10313: LD_INT 34
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PPUSH
10324: CALL_OW 69
10328: ST_TO_ADDR
// if Prob ( 40 ) then
10329: LD_INT 40
10331: PPUSH
10332: CALL_OW 13
10336: IFFALSE 10463
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10338: LD_INT 2
10340: PPUSH
10341: LD_INT 22
10343: PUSH
10344: LD_INT 3
10346: PUSH
10347: LD_INT 3
10349: PUSH
10350: LD_INT 49
10352: PUSH
10353: EMPTY
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: PUSH
10359: LD_INT 22
10361: PUSH
10362: LD_INT 3
10364: PUSH
10365: LD_INT 3
10367: PUSH
10368: LD_INT 49
10370: PUSH
10371: EMPTY
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: PUSH
10377: LD_INT 22
10379: PUSH
10380: LD_INT 3
10382: PUSH
10383: LD_INT 3
10385: PUSH
10386: LD_INT 49
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 24
10397: PUSH
10398: LD_INT 3
10400: PUSH
10401: LD_INT 3
10403: PUSH
10404: LD_INT 46
10406: PUSH
10407: EMPTY
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PUSH
10413: LD_INT 24
10415: PUSH
10416: LD_INT 3
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: LD_INT 46
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: LIST
10429: LIST
10430: PUSH
10431: LD_INT 24
10433: PUSH
10434: LD_INT 3
10436: PUSH
10437: LD_INT 3
10439: PUSH
10440: LD_INT 46
10442: PUSH
10443: EMPTY
10444: LIST
10445: LIST
10446: LIST
10447: LIST
10448: PUSH
10449: EMPTY
10450: LIST
10451: LIST
10452: LIST
10453: LIST
10454: LIST
10455: LIST
10456: PPUSH
10457: CALL 46422 0 2
// end else
10461: GO 10586
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10463: LD_INT 2
10465: PPUSH
10466: LD_INT 24
10468: PUSH
10469: LD_INT 3
10471: PUSH
10472: LD_INT 3
10474: PUSH
10475: LD_INT 47
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: PUSH
10484: LD_INT 24
10486: PUSH
10487: LD_INT 3
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 47
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: PUSH
10502: LD_INT 24
10504: PUSH
10505: LD_INT 3
10507: PUSH
10508: LD_INT 3
10510: PUSH
10511: LD_INT 47
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 24
10522: PUSH
10523: LD_INT 3
10525: PUSH
10526: LD_INT 3
10528: PUSH
10529: LD_INT 46
10531: PUSH
10532: EMPTY
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: PUSH
10538: LD_INT 24
10540: PUSH
10541: LD_INT 3
10543: PUSH
10544: LD_INT 3
10546: PUSH
10547: LD_INT 46
10549: PUSH
10550: EMPTY
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: PUSH
10556: LD_INT 24
10558: PUSH
10559: LD_INT 3
10561: PUSH
10562: LD_INT 3
10564: PUSH
10565: LD_INT 46
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: PPUSH
10582: CALL 46422 0 2
// end ; if Difficulty > 1 then
10586: LD_OWVAR 67
10590: PUSH
10591: LD_INT 1
10593: GREATER
10594: IFFALSE 10624
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10596: LD_INT 2
10598: PPUSH
10599: LD_INT 24
10601: PUSH
10602: LD_INT 3
10604: PUSH
10605: LD_INT 3
10607: PUSH
10608: LD_INT 47
10610: PUSH
10611: EMPTY
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: PUSH
10617: EMPTY
10618: LIST
10619: PPUSH
10620: CALL 46422 0 2
// p := 0 ;
10624: LD_ADDR_VAR 0 5
10628: PUSH
10629: LD_INT 0
10631: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10632: LD_INT 35
10634: PPUSH
10635: CALL_OW 67
// p := Inc ( p ) ;
10639: LD_ADDR_VAR 0 5
10643: PUSH
10644: LD_VAR 0 5
10648: PPUSH
10649: CALL 91501 0 1
10653: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 100 ;
10654: LD_INT 2
10656: PPUSH
10657: LD_INT 1
10659: PPUSH
10660: CALL 47840 0 2
10664: PUSH
10665: LD_INT 6
10667: PUSH
10668: LD_INT 7
10670: PUSH
10671: LD_INT 7
10673: PUSH
10674: LD_INT 7
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: LIST
10681: LIST
10682: PUSH
10683: LD_OWVAR 67
10687: ARRAY
10688: GREATEREQUAL
10689: PUSH
10690: LD_VAR 0 5
10694: PUSH
10695: LD_INT 100
10697: GREATER
10698: OR
10699: IFFALSE 10632
// wait ( 0 0$30 ) ;
10701: LD_INT 1050
10703: PPUSH
10704: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10708: LD_ADDR_VAR 0 2
10712: PUSH
10713: LD_INT 2
10715: PPUSH
10716: LD_INT 1
10718: PPUSH
10719: CALL 47840 0 2
10723: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10724: LD_ADDR_EXP 97
10728: PUSH
10729: LD_EXP 97
10733: PPUSH
10734: LD_INT 2
10736: PPUSH
10737: LD_EXP 97
10741: PUSH
10742: LD_INT 2
10744: ARRAY
10745: PUSH
10746: LD_VAR 0 2
10750: DIFF
10751: PPUSH
10752: CALL_OW 1
10756: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10757: LD_ADDR_VAR 0 3
10761: PUSH
10762: LD_INT 0
10764: PPUSH
10765: LD_INT 1
10767: PPUSH
10768: CALL_OW 12
10772: ST_TO_ADDR
// if target then
10773: LD_VAR 0 3
10777: IFFALSE 10905
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10779: LD_ADDR_VAR 0 2
10783: PUSH
10784: LD_VAR 0 2
10788: PPUSH
10789: LD_INT 24
10791: PUSH
10792: LD_INT 250
10794: PUSH
10795: EMPTY
10796: LIST
10797: LIST
10798: PPUSH
10799: CALL_OW 72
10803: ST_TO_ADDR
// for i in tmp do
10804: LD_ADDR_VAR 0 1
10808: PUSH
10809: LD_VAR 0 2
10813: PUSH
10814: FOR_IN
10815: IFFALSE 10855
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10817: LD_VAR 0 1
10821: PPUSH
10822: LD_INT 139
10824: PPUSH
10825: LD_INT 89
10827: PPUSH
10828: CALL_OW 297
10832: PUSH
10833: LD_INT 9
10835: GREATER
10836: IFFALSE 10853
// ComMoveXY ( i , 139 , 89 ) ;
10838: LD_VAR 0 1
10842: PPUSH
10843: LD_INT 139
10845: PPUSH
10846: LD_INT 89
10848: PPUSH
10849: CALL_OW 111
10853: GO 10814
10855: POP
10856: POP
// wait ( 0 0$1 ) ;
10857: LD_INT 35
10859: PPUSH
10860: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10864: LD_VAR 0 2
10868: PPUSH
10869: LD_INT 92
10871: PUSH
10872: LD_INT 139
10874: PUSH
10875: LD_INT 89
10877: PUSH
10878: LD_INT 9
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: LIST
10885: LIST
10886: PPUSH
10887: CALL_OW 72
10891: PUSH
10892: LD_VAR 0 2
10896: PUSH
10897: LD_INT 1
10899: MINUS
10900: GREATEREQUAL
10901: IFFALSE 10779
// end else
10903: GO 11047
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10905: LD_VAR 0 2
10909: PPUSH
10910: LD_VAR 0 4
10914: PUSH
10915: LD_INT 1
10917: ARRAY
10918: PPUSH
10919: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10923: LD_ADDR_VAR 0 2
10927: PUSH
10928: LD_VAR 0 2
10932: PPUSH
10933: LD_INT 24
10935: PUSH
10936: LD_INT 250
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: PPUSH
10943: CALL_OW 72
10947: ST_TO_ADDR
// for i in tmp do
10948: LD_ADDR_VAR 0 1
10952: PUSH
10953: LD_VAR 0 2
10957: PUSH
10958: FOR_IN
10959: IFFALSE 10999
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10961: LD_VAR 0 1
10965: PPUSH
10966: LD_INT 124
10968: PPUSH
10969: LD_INT 139
10971: PPUSH
10972: CALL_OW 297
10976: PUSH
10977: LD_INT 9
10979: GREATER
10980: IFFALSE 10997
// ComMoveXY ( i , 124 , 139 ) ;
10982: LD_VAR 0 1
10986: PPUSH
10987: LD_INT 124
10989: PPUSH
10990: LD_INT 139
10992: PPUSH
10993: CALL_OW 111
10997: GO 10958
10999: POP
11000: POP
// wait ( 0 0$1 ) ;
11001: LD_INT 35
11003: PPUSH
11004: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
11008: LD_VAR 0 2
11012: PPUSH
11013: LD_INT 92
11015: PUSH
11016: LD_INT 124
11018: PUSH
11019: LD_INT 139
11021: PUSH
11022: LD_INT 9
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PPUSH
11031: CALL_OW 72
11035: PUSH
11036: LD_VAR 0 2
11040: PUSH
11041: LD_INT 1
11043: MINUS
11044: GREATEREQUAL
11045: IFFALSE 10923
// end ; repeat wait ( 0 0$1 ) ;
11047: LD_INT 35
11049: PPUSH
11050: CALL_OW 67
// for i in tmp do
11054: LD_ADDR_VAR 0 1
11058: PUSH
11059: LD_VAR 0 2
11063: PUSH
11064: FOR_IN
11065: IFFALSE 11198
// begin if GetLives ( i ) > 251 then
11067: LD_VAR 0 1
11071: PPUSH
11072: CALL_OW 256
11076: PUSH
11077: LD_INT 251
11079: GREATER
11080: IFFALSE 11169
// begin if GetWeapon ( i ) = ru_time_lapser then
11082: LD_VAR 0 1
11086: PPUSH
11087: CALL_OW 264
11091: PUSH
11092: LD_INT 49
11094: EQUAL
11095: IFFALSE 11133
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11097: LD_VAR 0 1
11101: PPUSH
11102: LD_INT 81
11104: PUSH
11105: LD_INT 3
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: PPUSH
11112: CALL_OW 69
11116: PPUSH
11117: LD_VAR 0 1
11121: PPUSH
11122: CALL_OW 74
11126: PPUSH
11127: CALL_OW 112
11131: GO 11167
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11133: LD_VAR 0 1
11137: PPUSH
11138: LD_INT 81
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PPUSH
11148: CALL_OW 69
11152: PPUSH
11153: LD_VAR 0 1
11157: PPUSH
11158: CALL_OW 74
11162: PPUSH
11163: CALL_OW 115
// end else
11167: GO 11196
// if IsDead ( i ) then
11169: LD_VAR 0 1
11173: PPUSH
11174: CALL_OW 301
11178: IFFALSE 11196
// tmp := tmp diff i ;
11180: LD_ADDR_VAR 0 2
11184: PUSH
11185: LD_VAR 0 2
11189: PUSH
11190: LD_VAR 0 1
11194: DIFF
11195: ST_TO_ADDR
// end ;
11196: GO 11064
11198: POP
11199: POP
// until not tmp ;
11200: LD_VAR 0 2
11204: NOT
11205: IFFALSE 11047
// end ;
11207: PPOPN 5
11209: END
// every 30 30$00 trigger not russianDestroyed do
11210: LD_EXP 2
11214: NOT
11215: IFFALSE 11284
11217: GO 11219
11219: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11220: LD_INT 105000
11222: PUSH
11223: LD_INT 84000
11225: PUSH
11226: LD_INT 63000
11228: PUSH
11229: LD_INT 52500
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: PUSH
11238: LD_OWVAR 67
11242: ARRAY
11243: PPUSH
11244: CALL_OW 67
// if russianDestroyed then
11248: LD_EXP 2
11252: IFFALSE 11256
// exit ;
11254: GO 11284
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11256: LD_INT 2
11258: PPUSH
11259: LD_INT 23
11261: PUSH
11262: LD_INT 3
11264: PUSH
11265: LD_INT 1
11267: PUSH
11268: LD_INT 48
11270: PUSH
11271: EMPTY
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: PUSH
11277: EMPTY
11278: LIST
11279: PPUSH
11280: CALL 46422 0 2
// end ; end_of_file
11284: END
// export function CustomEvent ( event ) ; begin
11285: LD_INT 0
11287: PPUSH
// end ;
11288: LD_VAR 0 2
11292: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11293: LD_VAR 0 2
11297: PPUSH
11298: LD_VAR 0 3
11302: PPUSH
11303: LD_INT 15
11305: PPUSH
11306: CALL_OW 309
11310: IFFALSE 11319
// YouLost ( MothContaminate ) ;
11312: LD_STRING MothContaminate
11314: PPUSH
11315: CALL_OW 104
// end ;
11319: PPOPN 3
11321: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11322: LD_VAR 0 2
11326: PPUSH
11327: LD_VAR 0 3
11331: PPUSH
11332: LD_INT 15
11334: PPUSH
11335: CALL_OW 309
11339: IFFALSE 11355
// begin wait ( 0 0$6 ) ;
11341: LD_INT 210
11343: PPUSH
11344: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11348: LD_STRING MothContaminateBomb
11350: PPUSH
11351: CALL_OW 104
// end ; end ;
11355: PPOPN 3
11357: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11358: LD_VAR 0 1
11362: PPUSH
11363: CALL 110014 0 1
// if un = JMM then
11367: LD_VAR 0 1
11371: PUSH
11372: LD_EXP 19
11376: EQUAL
11377: IFFALSE 11388
// begin YouLost ( JMM ) ;
11379: LD_STRING JMM
11381: PPUSH
11382: CALL_OW 104
// exit ;
11386: GO 11517
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11388: LD_VAR 0 1
11392: PPUSH
11393: CALL_OW 255
11397: PUSH
11398: LD_INT 2
11400: EQUAL
11401: PUSH
11402: LD_EXP 18
11406: NOT
11407: AND
11408: IFFALSE 11418
// arabianAttacked := true ;
11410: LD_ADDR_EXP 18
11414: PUSH
11415: LD_INT 1
11417: ST_TO_ADDR
// if un = Powell then
11418: LD_VAR 0 1
11422: PUSH
11423: LD_EXP 55
11427: EQUAL
11428: IFFALSE 11438
// americanDestroyed := true ;
11430: LD_ADDR_EXP 4
11434: PUSH
11435: LD_INT 1
11437: ST_TO_ADDR
// if un = Platonov then
11438: LD_VAR 0 1
11442: PUSH
11443: LD_EXP 60
11447: EQUAL
11448: IFFALSE 11458
// russianDestroyed := true ;
11450: LD_ADDR_EXP 2
11454: PUSH
11455: LD_INT 1
11457: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11458: LD_VAR 0 1
11462: PUSH
11463: LD_INT 22
11465: PUSH
11466: LD_INT 7
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: LD_INT 21
11475: PUSH
11476: LD_INT 2
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: PPUSH
11487: CALL_OW 69
11491: IN
11492: IFFALSE 11508
// vehicleLostCounter := vehicleLostCounter + 1 ;
11494: LD_ADDR_EXP 15
11498: PUSH
11499: LD_EXP 15
11503: PUSH
11504: LD_INT 1
11506: PLUS
11507: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11508: LD_VAR 0 1
11512: PPUSH
11513: CALL 49864 0 1
// end ;
11517: PPOPN 1
11519: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11520: LD_VAR 0 1
11524: PPUSH
11525: LD_VAR 0 2
11529: PPUSH
11530: CALL 52196 0 2
// end ;
11534: PPOPN 2
11536: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11537: LD_VAR 0 1
11541: PPUSH
11542: CALL 51264 0 1
// end ;
11546: PPOPN 1
11548: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11549: LD_VAR 0 1
11553: PUSH
11554: LD_INT 22
11556: PUSH
11557: LD_INT 8
11559: PUSH
11560: EMPTY
11561: LIST
11562: LIST
11563: PUSH
11564: LD_INT 30
11566: PUSH
11567: LD_INT 2
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: LD_INT 23
11576: PUSH
11577: LD_INT 3
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: LIST
11588: PPUSH
11589: CALL_OW 69
11593: IN
11594: IFFALSE 11621
// begin ComUpgrade ( building ) ;
11596: LD_VAR 0 1
11600: PPUSH
11601: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11605: LD_EXP 58
11609: PPUSH
11610: LD_VAR 0 1
11614: PPUSH
11615: CALL 60671 0 2
// exit ;
11619: GO 11630
// end ; MCE_BuildingComplete ( building ) ;
11621: LD_VAR 0 1
11625: PPUSH
11626: CALL 51505 0 1
// end ;
11630: PPOPN 1
11632: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11633: LD_VAR 0 1
11637: PPUSH
11638: LD_VAR 0 2
11642: PPUSH
11643: CALL 49560 0 2
// end ;
11647: PPOPN 2
11649: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11650: LD_VAR 0 1
11654: PPUSH
11655: LD_VAR 0 2
11659: PPUSH
11660: LD_VAR 0 3
11664: PPUSH
11665: LD_VAR 0 4
11669: PPUSH
11670: LD_VAR 0 5
11674: PPUSH
11675: CALL 49180 0 5
// end ;
11679: PPOPN 5
11681: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11682: LD_VAR 0 1
11686: PPUSH
11687: LD_VAR 0 2
11691: PPUSH
11692: CALL 110134 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11696: LD_VAR 0 1
11700: PPUSH
11701: LD_VAR 0 2
11705: PPUSH
11706: CALL 48733 0 2
// end ;
11710: PPOPN 2
11712: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11713: LD_VAR 0 1
11717: PPUSH
11718: LD_VAR 0 2
11722: PPUSH
11723: LD_VAR 0 3
11727: PPUSH
11728: LD_VAR 0 4
11732: PPUSH
11733: CALL 48571 0 4
// end ;
11737: PPOPN 4
11739: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11740: LD_VAR 0 1
11744: PPUSH
11745: LD_VAR 0 2
11749: PPUSH
11750: LD_VAR 0 3
11754: PPUSH
11755: CALL 48346 0 3
// end ;
11759: PPOPN 3
11761: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11762: LD_VAR 0 1
11766: PPUSH
11767: LD_VAR 0 2
11771: PPUSH
11772: CALL 48231 0 2
// end ;
11776: PPOPN 2
11778: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11779: LD_VAR 0 1
11783: PPUSH
11784: LD_VAR 0 2
11788: PPUSH
11789: CALL 52491 0 2
// end ;
11793: PPOPN 2
11795: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
11796: LD_VAR 0 1
11800: PUSH
11801: LD_INT 674
11803: EQUAL
11804: IFFALSE 11826
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
11806: LD_VAR 0 2
11810: PPUSH
11811: LD_INT 227
11813: PPUSH
11814: LD_INT 136
11816: PPUSH
11817: CALL_OW 428
11821: PPUSH
11822: CALL_OW 120
// end ;
11826: PPOPN 2
11828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11829: LD_VAR 0 1
11833: PPUSH
11834: LD_VAR 0 2
11838: PPUSH
11839: LD_VAR 0 3
11843: PPUSH
11844: LD_VAR 0 4
11848: PPUSH
11849: CALL 52707 0 4
// end ;
11853: PPOPN 4
11855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11856: LD_VAR 0 1
11860: PPUSH
11861: LD_VAR 0 2
11865: PPUSH
11866: CALL 48040 0 2
// end ;
11870: PPOPN 2
11872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11873: LD_VAR 0 1
11877: PPUSH
11878: CALL 110118 0 1
// end ; end_of_file
11882: PPOPN 1
11884: END
// export function Action ; begin
11885: LD_INT 0
11887: PPUSH
// InGameOn ;
11888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11892: LD_INT 206
11894: PPUSH
11895: LD_INT 11
11897: PPUSH
11898: CALL_OW 86
// wait ( 0 0$1 ) ;
11902: LD_INT 35
11904: PPUSH
11905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11909: LD_EXP 19
11913: PPUSH
11914: LD_STRING DStart-JMM-JMM-1
11916: PPUSH
11917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11921: LD_EXP 52
11925: PPUSH
11926: LD_STRING DStart-JMM-Bur-1
11928: PPUSH
11929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11933: LD_EXP 19
11937: PPUSH
11938: LD_STRING DStart-JMM-JMM-2
11940: PPUSH
11941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11945: LD_EXP 52
11949: PPUSH
11950: LD_STRING DStart-JMM-Bur-2
11952: PPUSH
11953: CALL_OW 88
// InGameOff ;
11957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11961: LD_STRING MStart
11963: PPUSH
11964: CALL_OW 337
// SaveForQuickRestart ;
11968: CALL_OW 22
// end ;
11972: LD_VAR 0 1
11976: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11977: LD_INT 7
11979: PPUSH
11980: LD_INT 255
11982: PPUSH
11983: LD_INT 219
11985: PPUSH
11986: CALL_OW 293
11990: IFFALSE 12599
11992: GO 11994
11994: DISABLE
11995: LD_INT 0
11997: PPUSH
// begin wait ( 0 0$3 ) ;
11998: LD_INT 105
12000: PPUSH
12001: CALL_OW 67
// alienSpotted := true ;
12005: LD_ADDR_EXP 10
12009: PUSH
12010: LD_INT 1
12012: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12013: LD_ADDR_VAR 0 1
12017: PUSH
12018: LD_INT 22
12020: PUSH
12021: LD_INT 7
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 23
12030: PUSH
12031: LD_INT 3
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 21
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: LD_INT 26
12050: PUSH
12051: LD_INT 1
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: LIST
12062: LIST
12063: PPUSH
12064: CALL_OW 69
12068: PUSH
12069: LD_EXP 52
12073: PUSH
12074: LD_EXP 40
12078: PUSH
12079: LD_EXP 42
12083: PUSH
12084: LD_EXP 43
12088: PUSH
12089: LD_EXP 50
12093: PUSH
12094: LD_EXP 49
12098: PUSH
12099: LD_EXP 44
12103: PUSH
12104: EMPTY
12105: LIST
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: DIFF
12113: ST_TO_ADDR
// DialogueOn ;
12114: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12118: LD_INT 255
12120: PPUSH
12121: LD_INT 219
12123: PPUSH
12124: LD_INT 7
12126: PPUSH
12127: LD_INT 20
12129: NEG
12130: PPUSH
12131: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12135: LD_INT 255
12137: PPUSH
12138: LD_INT 219
12140: PPUSH
12141: CALL_OW 86
// if speaker then
12145: LD_VAR 0 1
12149: IFFALSE 12167
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12151: LD_VAR 0 1
12155: PUSH
12156: LD_INT 1
12158: ARRAY
12159: PPUSH
12160: LD_STRING DAlienBase-RSol1-1
12162: PPUSH
12163: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12167: LD_EXP 19
12171: PPUSH
12172: LD_STRING DAlienBase-JMM-1
12174: PPUSH
12175: CALL_OW 88
// if IsOk ( Burlak ) then
12179: LD_EXP 52
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12209
// begin dwait ( 0 0$1 ) ;
12190: LD_INT 35
12192: PPUSH
12193: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12197: LD_EXP 52
12201: PPUSH
12202: LD_STRING DAlienBase-Bur-1
12204: PPUSH
12205: CALL_OW 88
// end ; if IsOk ( Roth ) then
12209: LD_EXP 20
12213: PPUSH
12214: CALL_OW 302
12218: IFFALSE 12232
// Say ( Roth , DAlienBase-Roth-1 ) ;
12220: LD_EXP 20
12224: PPUSH
12225: LD_STRING DAlienBase-Roth-1
12227: PPUSH
12228: CALL_OW 88
// if IsOk ( Gossudarov ) then
12232: LD_EXP 38
12236: PPUSH
12237: CALL_OW 302
12241: IFFALSE 12257
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12243: LD_EXP 38
12247: PPUSH
12248: LD_STRING DAlienBase-Gos-1
12250: PPUSH
12251: CALL_OW 88
12255: GO 12374
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12257: LD_ADDR_VAR 0 1
12261: PUSH
12262: LD_INT 22
12264: PUSH
12265: LD_INT 7
12267: PUSH
12268: EMPTY
12269: LIST
12270: LIST
12271: PUSH
12272: LD_INT 25
12274: PUSH
12275: LD_INT 4
12277: PUSH
12278: EMPTY
12279: LIST
12280: LIST
12281: PUSH
12282: LD_INT 21
12284: PUSH
12285: LD_INT 1
12287: PUSH
12288: EMPTY
12289: LIST
12290: LIST
12291: PUSH
12292: LD_INT 26
12294: PUSH
12295: LD_INT 1
12297: PUSH
12298: EMPTY
12299: LIST
12300: LIST
12301: PUSH
12302: EMPTY
12303: LIST
12304: LIST
12305: LIST
12306: LIST
12307: PPUSH
12308: CALL_OW 69
12312: PUSH
12313: LD_EXP 20
12317: PUSH
12318: LD_EXP 19
12322: PUSH
12323: LD_EXP 52
12327: PUSH
12328: LD_EXP 40
12332: PUSH
12333: LD_EXP 50
12337: PUSH
12338: LD_EXP 49
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: LIST
12347: LIST
12348: LIST
12349: LIST
12350: DIFF
12351: ST_TO_ADDR
// if speaker then
12352: LD_VAR 0 1
12356: IFFALSE 12374
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12358: LD_VAR 0 1
12362: PUSH
12363: LD_INT 1
12365: ARRAY
12366: PPUSH
12367: LD_STRING DAlienBase-Sci1-1
12369: PPUSH
12370: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12374: LD_INT 255
12376: PPUSH
12377: LD_INT 219
12379: PPUSH
12380: LD_INT 7
12382: PPUSH
12383: CALL_OW 331
// DialogueOff ;
12387: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12391: LD_INT 35
12393: PPUSH
12394: CALL_OW 67
// until IsSelected ( alien ) ;
12398: LD_INT 1
12400: PPUSH
12401: CALL_OW 306
12405: IFFALSE 12391
// if not artifactIResearched or not artifactIIResearched then
12407: LD_EXP 12
12411: NOT
12412: PUSH
12413: LD_EXP 13
12417: NOT
12418: OR
12419: IFFALSE 12599
// begin if IsOk ( Roth ) then
12421: LD_EXP 20
12425: PPUSH
12426: CALL_OW 302
12430: IFFALSE 12446
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12432: LD_EXP 20
12436: PPUSH
12437: LD_STRING DAlieBaseNotReady-Roth-1
12439: PPUSH
12440: CALL_OW 88
12444: GO 12599
// if IsOk ( Gossudarov ) then
12446: LD_EXP 38
12450: PPUSH
12451: CALL_OW 302
12455: IFFALSE 12471
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12457: LD_EXP 38
12461: PPUSH
12462: LD_STRING DAlieBaseNotReady-Gos-1
12464: PPUSH
12465: CALL_OW 88
12469: GO 12599
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12471: LD_ADDR_VAR 0 1
12475: PUSH
12476: LD_INT 22
12478: PUSH
12479: LD_INT 7
12481: PUSH
12482: EMPTY
12483: LIST
12484: LIST
12485: PUSH
12486: LD_INT 23
12488: PUSH
12489: LD_INT 3
12491: PUSH
12492: EMPTY
12493: LIST
12494: LIST
12495: PUSH
12496: LD_INT 25
12498: PUSH
12499: LD_INT 4
12501: PUSH
12502: EMPTY
12503: LIST
12504: LIST
12505: PUSH
12506: LD_INT 21
12508: PUSH
12509: LD_INT 1
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: PUSH
12516: LD_INT 26
12518: PUSH
12519: LD_INT 1
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: LIST
12530: LIST
12531: LIST
12532: PPUSH
12533: CALL_OW 69
12537: PUSH
12538: LD_EXP 20
12542: PUSH
12543: LD_EXP 19
12547: PUSH
12548: LD_EXP 52
12552: PUSH
12553: LD_EXP 40
12557: PUSH
12558: LD_EXP 50
12562: PUSH
12563: LD_EXP 49
12567: PUSH
12568: EMPTY
12569: LIST
12570: LIST
12571: LIST
12572: LIST
12573: LIST
12574: LIST
12575: DIFF
12576: ST_TO_ADDR
// if speaker then
12577: LD_VAR 0 1
12581: IFFALSE 12599
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12583: LD_VAR 0 1
12587: PUSH
12588: LD_INT 1
12590: ARRAY
12591: PPUSH
12592: LD_STRING DAlieBaseNotReady-RSci1-1
12594: PPUSH
12595: CALL_OW 88
// end ; end ; end ;
12599: PPOPN 1
12601: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12602: LD_INT 24
12604: PPUSH
12605: LD_INT 7
12607: PPUSH
12608: CALL_OW 321
12612: PUSH
12613: LD_INT 2
12615: EQUAL
12616: IFFALSE 13307
12618: GO 12620
12620: DISABLE
12621: LD_INT 0
12623: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12624: LD_ADDR_VAR 0 1
12628: PUSH
12629: LD_INT 22
12631: PUSH
12632: LD_INT 7
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: LD_INT 23
12641: PUSH
12642: LD_INT 3
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PUSH
12649: LD_INT 25
12651: PUSH
12652: LD_INT 4
12654: PUSH
12655: EMPTY
12656: LIST
12657: LIST
12658: PUSH
12659: LD_INT 21
12661: PUSH
12662: LD_INT 1
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: PUSH
12669: LD_INT 26
12671: PUSH
12672: LD_INT 1
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: PUSH
12679: EMPTY
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PPUSH
12686: CALL_OW 69
12690: PUSH
12691: LD_EXP 20
12695: PUSH
12696: LD_EXP 19
12700: PUSH
12701: LD_EXP 52
12705: PUSH
12706: LD_EXP 40
12710: PUSH
12711: LD_EXP 50
12715: PUSH
12716: LD_EXP 49
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: DIFF
12729: ST_TO_ADDR
// if not speaker then
12730: LD_VAR 0 1
12734: NOT
12735: IFFALSE 12739
// exit ;
12737: GO 13307
// DialogueOn ;
12739: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12743: LD_VAR 0 1
12747: PUSH
12748: LD_INT 1
12750: ARRAY
12751: PPUSH
12752: LD_STRING DArtefTechnology-RSci1-1
12754: PPUSH
12755: CALL_OW 88
// if IsOk ( Burlak ) then
12759: LD_EXP 52
12763: PPUSH
12764: CALL_OW 302
12768: IFFALSE 12782
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12770: LD_EXP 52
12774: PPUSH
12775: LD_STRING DArtefTechnology-Bur-1
12777: PPUSH
12778: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12782: LD_VAR 0 1
12786: PUSH
12787: LD_INT 1
12789: ARRAY
12790: PPUSH
12791: LD_STRING DArtefTechnology-RSci1-2
12793: PPUSH
12794: CALL_OW 88
// if Denis then
12798: LD_EXP 25
12802: IFFALSE 12819
// speaker := [ Denis ] else
12804: LD_ADDR_VAR 0 1
12808: PUSH
12809: LD_EXP 25
12813: PUSH
12814: EMPTY
12815: LIST
12816: ST_TO_ADDR
12817: GO 12925
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12819: LD_ADDR_VAR 0 1
12823: PUSH
12824: LD_INT 22
12826: PUSH
12827: LD_INT 7
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: PUSH
12834: LD_INT 23
12836: PUSH
12837: LD_INT 1
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: PUSH
12844: LD_INT 25
12846: PUSH
12847: LD_INT 4
12849: PUSH
12850: EMPTY
12851: LIST
12852: LIST
12853: PUSH
12854: LD_INT 21
12856: PUSH
12857: LD_INT 1
12859: PUSH
12860: EMPTY
12861: LIST
12862: LIST
12863: PUSH
12864: LD_INT 26
12866: PUSH
12867: LD_INT 1
12869: PUSH
12870: EMPTY
12871: LIST
12872: LIST
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: PPUSH
12881: CALL_OW 69
12885: PUSH
12886: LD_EXP 20
12890: PUSH
12891: LD_EXP 19
12895: PUSH
12896: LD_EXP 52
12900: PUSH
12901: LD_EXP 40
12905: PUSH
12906: LD_EXP 50
12910: PUSH
12911: LD_EXP 49
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: DIFF
12924: ST_TO_ADDR
// if speaker then
12925: LD_VAR 0 1
12929: IFFALSE 12947
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12931: LD_VAR 0 1
12935: PUSH
12936: LD_INT 1
12938: ARRAY
12939: PPUSH
12940: LD_STRING DArtefTechnology-Sci1-2
12942: PPUSH
12943: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12947: LD_ADDR_VAR 0 1
12951: PUSH
12952: LD_INT 22
12954: PUSH
12955: LD_INT 7
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: PUSH
12962: LD_INT 23
12964: PUSH
12965: LD_INT 3
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 25
12974: PUSH
12975: LD_INT 4
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 21
12984: PUSH
12985: LD_INT 1
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 26
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: LIST
13008: PPUSH
13009: CALL_OW 69
13013: PUSH
13014: LD_EXP 20
13018: PUSH
13019: LD_EXP 19
13023: PUSH
13024: LD_EXP 52
13028: PUSH
13029: LD_EXP 40
13033: PUSH
13034: LD_EXP 50
13038: PUSH
13039: LD_EXP 49
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: LIST
13048: LIST
13049: LIST
13050: LIST
13051: DIFF
13052: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13053: LD_VAR 0 1
13057: PUSH
13058: LD_EXP 9
13062: PUSH
13063: LD_EXP 5
13067: OR
13068: AND
13069: IFFALSE 13303
// begin if arabianDestroyed and IsOk ( Burlak ) then
13071: LD_EXP 5
13075: PUSH
13076: LD_EXP 52
13080: PPUSH
13081: CALL_OW 302
13085: AND
13086: IFFALSE 13102
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13088: LD_EXP 52
13092: PPUSH
13093: LD_STRING DArtefTechnology-Bur-2
13095: PPUSH
13096: CALL_OW 88
13100: GO 13114
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13102: LD_EXP 19
13106: PPUSH
13107: LD_STRING DArtefTechnology-JMM-2
13109: PPUSH
13110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13114: LD_VAR 0 1
13118: PUSH
13119: LD_INT 1
13121: ARRAY
13122: PPUSH
13123: LD_STRING DArtefTechnology-RSci1-3
13125: PPUSH
13126: CALL_OW 88
// if Denis then
13130: LD_EXP 25
13134: IFFALSE 13151
// speaker := [ Denis ] else
13136: LD_ADDR_VAR 0 1
13140: PUSH
13141: LD_EXP 25
13145: PUSH
13146: EMPTY
13147: LIST
13148: ST_TO_ADDR
13149: GO 13257
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13151: LD_ADDR_VAR 0 1
13155: PUSH
13156: LD_INT 22
13158: PUSH
13159: LD_INT 7
13161: PUSH
13162: EMPTY
13163: LIST
13164: LIST
13165: PUSH
13166: LD_INT 23
13168: PUSH
13169: LD_INT 1
13171: PUSH
13172: EMPTY
13173: LIST
13174: LIST
13175: PUSH
13176: LD_INT 25
13178: PUSH
13179: LD_INT 4
13181: PUSH
13182: EMPTY
13183: LIST
13184: LIST
13185: PUSH
13186: LD_INT 21
13188: PUSH
13189: LD_INT 1
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 26
13198: PUSH
13199: LD_INT 1
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: LIST
13210: LIST
13211: LIST
13212: PPUSH
13213: CALL_OW 69
13217: PUSH
13218: LD_EXP 20
13222: PUSH
13223: LD_EXP 19
13227: PUSH
13228: LD_EXP 52
13232: PUSH
13233: LD_EXP 40
13237: PUSH
13238: LD_EXP 50
13242: PUSH
13243: LD_EXP 49
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: DIFF
13256: ST_TO_ADDR
// if speaker then
13257: LD_VAR 0 1
13261: IFFALSE 13303
// if alienSpotted then
13263: LD_EXP 10
13267: IFFALSE 13287
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13269: LD_VAR 0 1
13273: PUSH
13274: LD_INT 1
13276: ARRAY
13277: PPUSH
13278: LD_STRING DArtefTechnology-Sci1-3
13280: PPUSH
13281: CALL_OW 88
13285: GO 13303
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13287: LD_VAR 0 1
13291: PUSH
13292: LD_INT 1
13294: ARRAY
13295: PPUSH
13296: LD_STRING DArtefTechnology-Sci1-3a
13298: PPUSH
13299: CALL_OW 88
// end ; DialogueOff ;
13303: CALL_OW 7
// end ;
13307: PPOPN 1
13309: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13310: LD_EXP 12
13314: IFFALSE 13517
13316: GO 13318
13318: DISABLE
13319: LD_INT 0
13321: PPUSH
// begin if Denis then
13322: LD_EXP 25
13326: IFFALSE 13343
// speaker := [ Denis ] else
13328: LD_ADDR_VAR 0 1
13332: PUSH
13333: LD_EXP 25
13337: PUSH
13338: EMPTY
13339: LIST
13340: ST_TO_ADDR
13341: GO 13449
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13343: LD_ADDR_VAR 0 1
13347: PUSH
13348: LD_INT 22
13350: PUSH
13351: LD_INT 7
13353: PUSH
13354: EMPTY
13355: LIST
13356: LIST
13357: PUSH
13358: LD_INT 23
13360: PUSH
13361: LD_INT 1
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: PUSH
13368: LD_INT 25
13370: PUSH
13371: LD_INT 4
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: PUSH
13378: LD_INT 21
13380: PUSH
13381: LD_INT 1
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: PUSH
13388: LD_INT 26
13390: PUSH
13391: LD_INT 1
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: LIST
13402: LIST
13403: LIST
13404: PPUSH
13405: CALL_OW 69
13409: PUSH
13410: LD_EXP 20
13414: PUSH
13415: LD_EXP 19
13419: PUSH
13420: LD_EXP 52
13424: PUSH
13425: LD_EXP 40
13429: PUSH
13430: LD_EXP 50
13434: PUSH
13435: LD_EXP 49
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: DIFF
13448: ST_TO_ADDR
// if not speaker then
13449: LD_VAR 0 1
13453: NOT
13454: IFFALSE 13458
// exit ;
13456: GO 13517
// DialogueOn ;
13458: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13462: LD_VAR 0 1
13466: PUSH
13467: LD_INT 1
13469: ARRAY
13470: PPUSH
13471: LD_STRING DArtefTechnologyAm-Sci1-1
13473: PPUSH
13474: CALL_OW 88
// if IsOk ( Burlak ) then
13478: LD_EXP 52
13482: PPUSH
13483: CALL_OW 302
13487: IFFALSE 13501
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13489: LD_EXP 52
13493: PPUSH
13494: LD_STRING DArtefTechnologyAm-Bur-1
13496: PPUSH
13497: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13501: LD_EXP 19
13505: PPUSH
13506: LD_STRING DArtefTechnologyAm-JMM-1
13508: PPUSH
13509: CALL_OW 88
// DialogueOff ;
13513: CALL_OW 7
// end ;
13517: PPOPN 1
13519: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13520: LD_EXP 13
13524: IFFALSE 13726
13526: GO 13528
13528: DISABLE
13529: LD_INT 0
13531: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13532: LD_ADDR_VAR 0 1
13536: PUSH
13537: LD_INT 22
13539: PUSH
13540: LD_INT 7
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: LD_INT 23
13549: PUSH
13550: LD_INT 3
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PUSH
13557: LD_INT 25
13559: PUSH
13560: LD_INT 4
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 21
13569: PUSH
13570: LD_INT 1
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PUSH
13577: LD_INT 26
13579: PUSH
13580: LD_INT 1
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: PPUSH
13594: CALL_OW 69
13598: PUSH
13599: LD_EXP 20
13603: PUSH
13604: LD_EXP 19
13608: PUSH
13609: LD_EXP 52
13613: PUSH
13614: LD_EXP 40
13618: PUSH
13619: LD_EXP 50
13623: PUSH
13624: LD_EXP 49
13628: PUSH
13629: EMPTY
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: LIST
13635: LIST
13636: DIFF
13637: ST_TO_ADDR
// if not speaker then
13638: LD_VAR 0 1
13642: NOT
13643: IFFALSE 13647
// exit ;
13645: GO 13726
// DialogueOn ;
13647: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13651: LD_VAR 0 1
13655: PUSH
13656: LD_VAR 0 1
13660: ARRAY
13661: PPUSH
13662: LD_STRING DArtefTechnologyRu-RSci1-1
13664: PPUSH
13665: CALL_OW 88
// if IsOk ( Burlak ) then
13669: LD_EXP 52
13673: PPUSH
13674: CALL_OW 302
13678: IFFALSE 13692
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13680: LD_EXP 52
13684: PPUSH
13685: LD_STRING DArtefTechnologyRu-Bur-1
13687: PPUSH
13688: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13692: LD_VAR 0 1
13696: PUSH
13697: LD_VAR 0 1
13701: ARRAY
13702: PPUSH
13703: LD_STRING DArtefTechnologyRu-RSci1-2
13705: PPUSH
13706: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13710: LD_EXP 19
13714: PPUSH
13715: LD_STRING DArtefTechnologyRu-JMM-1
13717: PPUSH
13718: CALL_OW 88
// DialogueOff ;
13722: CALL_OW 7
// end ;
13726: PPOPN 1
13728: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13729: LD_INT 24
13731: PPUSH
13732: LD_INT 7
13734: PPUSH
13735: CALL_OW 321
13739: PUSH
13740: LD_INT 2
13742: EQUAL
13743: PUSH
13744: LD_INT 1
13746: PPUSH
13747: CALL_OW 255
13751: PUSH
13752: LD_INT 7
13754: EQUAL
13755: AND
13756: IFFALSE 13924
13758: GO 13760
13760: DISABLE
13761: LD_INT 0
13763: PPUSH
// begin if Denis then
13764: LD_EXP 25
13768: IFFALSE 13785
// speaker := [ Denis ] else
13770: LD_ADDR_VAR 0 1
13774: PUSH
13775: LD_EXP 25
13779: PUSH
13780: EMPTY
13781: LIST
13782: ST_TO_ADDR
13783: GO 13891
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13785: LD_ADDR_VAR 0 1
13789: PUSH
13790: LD_INT 22
13792: PUSH
13793: LD_INT 7
13795: PUSH
13796: EMPTY
13797: LIST
13798: LIST
13799: PUSH
13800: LD_INT 23
13802: PUSH
13803: LD_INT 1
13805: PUSH
13806: EMPTY
13807: LIST
13808: LIST
13809: PUSH
13810: LD_INT 25
13812: PUSH
13813: LD_INT 4
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: PUSH
13820: LD_INT 21
13822: PUSH
13823: LD_INT 1
13825: PUSH
13826: EMPTY
13827: LIST
13828: LIST
13829: PUSH
13830: LD_INT 26
13832: PUSH
13833: LD_INT 1
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: PUSH
13840: EMPTY
13841: LIST
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: PPUSH
13847: CALL_OW 69
13851: PUSH
13852: LD_EXP 20
13856: PUSH
13857: LD_EXP 19
13861: PUSH
13862: LD_EXP 52
13866: PUSH
13867: LD_EXP 40
13871: PUSH
13872: LD_EXP 50
13876: PUSH
13877: LD_EXP 49
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: DIFF
13890: ST_TO_ADDR
// if not speaker then
13891: LD_VAR 0 1
13895: NOT
13896: IFFALSE 13900
// exit ;
13898: GO 13924
// DialogueOn ;
13900: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13904: LD_VAR 0 1
13908: PUSH
13909: LD_INT 1
13911: ARRAY
13912: PPUSH
13913: LD_STRING DArtefTechnologyArStart-Sci1-1
13915: PPUSH
13916: CALL_OW 88
// DialogueOff ;
13920: CALL_OW 7
// end ;
13924: PPOPN 1
13926: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13927: LD_EXP 14
13931: IFFALSE 14212
13933: GO 13935
13935: DISABLE
13936: LD_INT 0
13938: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13939: LD_ADDR_VAR 0 1
13943: PUSH
13944: LD_INT 22
13946: PUSH
13947: LD_INT 7
13949: PUSH
13950: EMPTY
13951: LIST
13952: LIST
13953: PUSH
13954: LD_INT 23
13956: PUSH
13957: LD_INT 3
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 25
13966: PUSH
13967: LD_INT 4
13969: PUSH
13970: EMPTY
13971: LIST
13972: LIST
13973: PUSH
13974: LD_INT 21
13976: PUSH
13977: LD_INT 1
13979: PUSH
13980: EMPTY
13981: LIST
13982: LIST
13983: PUSH
13984: LD_INT 26
13986: PUSH
13987: LD_INT 1
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: PPUSH
14001: CALL_OW 69
14005: PUSH
14006: LD_EXP 20
14010: PUSH
14011: LD_EXP 19
14015: PUSH
14016: LD_EXP 52
14020: PUSH
14021: LD_EXP 40
14025: PUSH
14026: LD_EXP 50
14030: PUSH
14031: LD_EXP 49
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: DIFF
14044: ST_TO_ADDR
// if not speaker then
14045: LD_VAR 0 1
14049: NOT
14050: IFFALSE 14054
// exit ;
14052: GO 14212
// DialogueOn ;
14054: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14058: LD_VAR 0 1
14062: PUSH
14063: LD_INT 1
14065: ARRAY
14066: PPUSH
14067: LD_STRING DArtefTechnologyAr-RSci1-1
14069: PPUSH
14070: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14074: LD_EXP 19
14078: PPUSH
14079: LD_STRING DArtefTechnologyAr-JMM-1
14081: PPUSH
14082: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14086: LD_VAR 0 1
14090: PUSH
14091: LD_INT 1
14093: ARRAY
14094: PPUSH
14095: LD_STRING DArtefTechnologyAr-RSci1-2
14097: PPUSH
14098: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14102: LD_EXP 19
14106: PPUSH
14107: LD_STRING DArtefTechnologyAr-JMM-2
14109: PPUSH
14110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14114: LD_VAR 0 1
14118: PUSH
14119: LD_INT 1
14121: ARRAY
14122: PPUSH
14123: LD_STRING DArtefTechnologyAr-RSci1-3
14125: PPUSH
14126: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14130: LD_EXP 19
14134: PPUSH
14135: LD_STRING DArtefTechnologyAr-JMM-3
14137: PPUSH
14138: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14142: LD_VAR 0 1
14146: PUSH
14147: LD_INT 1
14149: ARRAY
14150: PPUSH
14151: LD_STRING DArtefTechnologyAr-RSci1-4
14153: PPUSH
14154: CALL_OW 88
// if IsOk ( Burlak ) then
14158: LD_EXP 52
14162: PPUSH
14163: CALL_OW 302
14167: IFFALSE 14181
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14169: LD_EXP 52
14173: PPUSH
14174: LD_STRING DArtefTechnologyAr-Bur-4
14176: PPUSH
14177: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14181: LD_EXP 19
14185: PPUSH
14186: LD_STRING DArtefTechnologyAr-JMM-4
14188: PPUSH
14189: CALL_OW 88
// DialogueOff ;
14193: CALL_OW 7
// wait ( 0 0$45 ) ;
14197: LD_INT 1575
14199: PPUSH
14200: CALL_OW 67
// spawnOmar := true ;
14204: LD_ADDR_EXP 11
14208: PUSH
14209: LD_INT 1
14211: ST_TO_ADDR
// end ;
14212: PPOPN 1
14214: END
// every 0 0$1 trigger spawnOmar do
14215: LD_EXP 11
14219: IFFALSE 14599
14221: GO 14223
14223: DISABLE
// begin PrepareOmarAli ;
14224: CALL 7368 0 0
// if not HasTask ( Omar ) then
14228: LD_EXP 56
14232: PPUSH
14233: CALL_OW 314
14237: NOT
14238: IFFALSE 14255
// ComMoveXY ( Omar , 252 , 220 ) ;
14240: LD_EXP 56
14244: PPUSH
14245: LD_INT 252
14247: PPUSH
14248: LD_INT 220
14250: PPUSH
14251: CALL_OW 111
// if not Omar then
14255: LD_EXP 56
14259: NOT
14260: IFFALSE 14264
// exit ;
14262: GO 14599
// repeat wait ( 0 0$1 ) ;
14264: LD_INT 35
14266: PPUSH
14267: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14271: LD_EXP 56
14275: PPUSH
14276: CALL_OW 314
14280: NOT
14281: PUSH
14282: LD_EXP 56
14286: PPUSH
14287: LD_INT 252
14289: PPUSH
14290: LD_INT 220
14292: PPUSH
14293: CALL_OW 297
14297: PUSH
14298: LD_INT 6
14300: GREATER
14301: AND
14302: IFFALSE 14319
// ComMoveXY ( Omar , 252 , 220 ) ;
14304: LD_EXP 56
14308: PPUSH
14309: LD_INT 252
14311: PPUSH
14312: LD_INT 220
14314: PPUSH
14315: CALL_OW 111
// until See ( 7 , Omar ) ;
14319: LD_INT 7
14321: PPUSH
14322: LD_EXP 56
14326: PPUSH
14327: CALL_OW 292
14331: IFFALSE 14264
// CenterNowOnUnits ( Omar ) ;
14333: LD_EXP 56
14337: PPUSH
14338: CALL_OW 87
// DialogueOn ;
14342: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14346: LD_EXP 56
14350: PPUSH
14351: LD_STRING DOmar-Omar-1
14353: PPUSH
14354: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14358: LD_EXP 19
14362: PPUSH
14363: LD_STRING DOmar-JMM-1
14365: PPUSH
14366: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14370: LD_EXP 56
14374: PPUSH
14375: LD_STRING DOmar-Omar-2
14377: PPUSH
14378: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14382: LD_EXP 19
14386: PPUSH
14387: LD_STRING DOmar-JMM-2
14389: PPUSH
14390: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14394: LD_EXP 56
14398: PPUSH
14399: LD_STRING DOmar-Omar-3
14401: PPUSH
14402: CALL_OW 88
// if IsOk ( Burlak ) then
14406: LD_EXP 52
14410: PPUSH
14411: CALL_OW 302
14415: IFFALSE 14431
// Say ( Burlak , DOmar-Bur-3 ) else
14417: LD_EXP 52
14421: PPUSH
14422: LD_STRING DOmar-Bur-3
14424: PPUSH
14425: CALL_OW 88
14429: GO 14443
// Say ( JMM , DOmar-JMM-3 ) ;
14431: LD_EXP 19
14435: PPUSH
14436: LD_STRING DOmar-JMM-3
14438: PPUSH
14439: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14443: LD_EXP 56
14447: PPUSH
14448: LD_STRING DOmar-Omar-4
14450: PPUSH
14451: CALL_OW 88
// case Query ( QAccept ) of 1 :
14455: LD_STRING QAccept
14457: PPUSH
14458: CALL_OW 97
14462: PUSH
14463: LD_INT 1
14465: DOUBLE
14466: EQUAL
14467: IFTRUE 14471
14469: GO 14507
14471: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14472: LD_EXP 19
14476: PPUSH
14477: LD_STRING DQrAccept#1-JMM-1
14479: PPUSH
14480: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14484: LD_EXP 56
14488: PPUSH
14489: LD_INT 7
14491: PPUSH
14492: CALL_OW 235
// ComStop ( Omar ) ;
14496: LD_EXP 56
14500: PPUSH
14501: CALL_OW 141
// end ; 2 :
14505: GO 14556
14507: LD_INT 2
14509: DOUBLE
14510: EQUAL
14511: IFTRUE 14515
14513: GO 14555
14515: POP
// begin if IsOk ( Burlak ) then
14516: LD_EXP 52
14520: PPUSH
14521: CALL_OW 302
14525: IFFALSE 14541
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14527: LD_EXP 52
14531: PPUSH
14532: LD_STRING DQrAccept#2-Bur-1
14534: PPUSH
14535: CALL_OW 88
14539: GO 14553
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14541: LD_EXP 19
14545: PPUSH
14546: LD_STRING DQrAccept#2-JMM-1
14548: PPUSH
14549: CALL_OW 88
// end ; end ;
14553: GO 14556
14555: POP
// DialogueOff ;
14556: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14560: LD_EXP 56
14564: PPUSH
14565: CALL_OW 255
14569: PUSH
14570: LD_INT 7
14572: EQUAL
14573: IFFALSE 14584
// begin SetAchievement ( ACH_OMAR ) ;
14575: LD_STRING ACH_OMAR
14577: PPUSH
14578: CALL_OW 543
// exit ;
14582: GO 14599
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14584: LD_EXP 56
14588: PPUSH
14589: LD_INT 202
14591: PPUSH
14592: LD_INT 115
14594: PPUSH
14595: CALL_OW 111
// end ;
14599: END
// every 0 0$1 trigger IsOk ( Omar ) and russianDestroyed do var i ;
14600: LD_EXP 56
14604: PPUSH
14605: CALL_OW 302
14609: PUSH
14610: LD_EXP 2
14614: AND
14615: IFFALSE 15100
14617: GO 14619
14619: DISABLE
14620: LD_INT 0
14622: PPUSH
// begin SetSide ( Omar , 5 ) ;
14623: LD_EXP 56
14627: PPUSH
14628: LD_INT 5
14630: PPUSH
14631: CALL_OW 235
// if IsInUnit ( Omar ) then
14635: LD_EXP 56
14639: PPUSH
14640: CALL_OW 310
14644: IFFALSE 14655
// ComExitVehicle ( Omar ) ;
14646: LD_EXP 56
14650: PPUSH
14651: CALL_OW 121
// if IsInUnit ( Omar ) then
14655: LD_EXP 56
14659: PPUSH
14660: CALL_OW 310
14664: IFFALSE 14675
// ComExitBuilding ( Omar ) ;
14666: LD_EXP 56
14670: PPUSH
14671: CALL_OW 122
// wait ( 0 0$1 ) ;
14675: LD_INT 35
14677: PPUSH
14678: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14682: LD_EXP 56
14686: PPUSH
14687: LD_INT 203
14689: PPUSH
14690: LD_INT 120
14692: PPUSH
14693: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14697: LD_INT 35
14699: PPUSH
14700: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
14704: LD_EXP 56
14708: PPUSH
14709: CALL_OW 306
14713: PUSH
14714: LD_EXP 56
14718: PPUSH
14719: LD_INT 203
14721: PPUSH
14722: LD_INT 120
14724: PPUSH
14725: CALL_OW 297
14729: PUSH
14730: LD_INT 20
14732: LESS
14733: OR
14734: IFFALSE 14697
// DialogueOn ;
14736: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
14740: LD_EXP 56
14744: PPUSH
14745: CALL_OW 250
14749: PPUSH
14750: LD_EXP 56
14754: PPUSH
14755: CALL_OW 251
14759: PPUSH
14760: LD_INT 7
14762: PPUSH
14763: LD_INT 6
14765: NEG
14766: PPUSH
14767: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
14771: LD_EXP 56
14775: PPUSH
14776: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
14780: LD_EXP 19
14784: PPUSH
14785: LD_STRING DOmarContam-JMM-1
14787: PPUSH
14788: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14792: LD_EXP 56
14796: PPUSH
14797: LD_STRING DOmarContam-Omar-1
14799: PPUSH
14800: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14804: LD_EXP 19
14808: PPUSH
14809: LD_STRING DOmarContam-JMM-2
14811: PPUSH
14812: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
14816: LD_EXP 56
14820: PPUSH
14821: CALL_OW 250
14825: PPUSH
14826: LD_EXP 56
14830: PPUSH
14831: CALL_OW 251
14835: PPUSH
14836: LD_INT 7
14838: PPUSH
14839: CALL_OW 331
// DialogueOff ;
14843: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14847: LD_INT 5
14849: PPUSH
14850: LD_INT 7
14852: PPUSH
14853: LD_INT 2
14855: PPUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14863: LD_INT 105
14865: PPUSH
14866: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14870: LD_EXP 56
14874: PPUSH
14875: LD_INT 203
14877: PPUSH
14878: LD_INT 120
14880: PPUSH
14881: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
14885: LD_EXP 56
14889: PPUSH
14890: LD_INT 203
14892: PPUSH
14893: LD_INT 120
14895: PPUSH
14896: CALL_OW 307
14900: IFFALSE 14863
// ComHold ( Omar ) ;
14902: LD_EXP 56
14906: PPUSH
14907: CALL_OW 140
// InGameOn ;
14911: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
14915: LD_INT 203
14917: PPUSH
14918: LD_INT 120
14920: PPUSH
14921: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
14925: LD_INT 203
14927: PPUSH
14928: LD_INT 120
14930: PPUSH
14931: LD_INT 7
14933: PPUSH
14934: LD_INT 30
14936: NEG
14937: PPUSH
14938: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
14942: LD_ADDR_VAR 0 1
14946: PUSH
14947: LD_INT 203
14949: PUSH
14950: LD_INT 120
14952: PUSH
14953: EMPTY
14954: LIST
14955: LIST
14956: PUSH
14957: LD_INT 202
14959: PUSH
14960: LD_INT 125
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PUSH
14967: LD_INT 195
14969: PUSH
14970: LD_INT 117
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: PUSH
14977: LD_INT 216
14979: PUSH
14980: LD_INT 123
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PUSH
14987: LD_INT 224
14989: PUSH
14990: LD_INT 131
14992: PUSH
14993: EMPTY
14994: LIST
14995: LIST
14996: PUSH
14997: LD_INT 212
14999: PUSH
15000: LD_INT 133
15002: PUSH
15003: EMPTY
15004: LIST
15005: LIST
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: PUSH
15015: FOR_IN
15016: IFFALSE 15052
// begin wait ( 0 0$0.5 ) ;
15018: LD_INT 18
15020: PPUSH
15021: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15025: LD_VAR 0 1
15029: PUSH
15030: LD_INT 1
15032: ARRAY
15033: PPUSH
15034: LD_VAR 0 1
15038: PUSH
15039: LD_INT 2
15041: ARRAY
15042: PPUSH
15043: LD_INT 5
15045: PPUSH
15046: CALL_OW 495
// end ;
15050: GO 15015
15052: POP
15053: POP
// KillUnit ( Omar ) ;
15054: LD_EXP 56
15058: PPUSH
15059: CALL_OW 66
// wait ( 0 0$3 ) ;
15063: LD_INT 105
15065: PPUSH
15066: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15070: LD_EXP 19
15074: PPUSH
15075: LD_STRING D16b-JMM-1
15077: PPUSH
15078: CALL_OW 91
// wait ( 0 0$2 ) ;
15082: LD_INT 70
15084: PPUSH
15085: CALL_OW 67
// InGameOff ;
15089: CALL_OW 9
// YouLost ( MothContaminate ) ;
15093: LD_STRING MothContaminate
15095: PPUSH
15096: CALL_OW 104
// end ;
15100: PPOPN 1
15102: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15103: LD_EXP 4
15107: NOT
15108: PUSH
15109: LD_INT 22
15111: PUSH
15112: LD_INT 1
15114: PUSH
15115: EMPTY
15116: LIST
15117: LIST
15118: PUSH
15119: LD_INT 34
15121: PUSH
15122: LD_INT 8
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: PUSH
15129: EMPTY
15130: LIST
15131: LIST
15132: PPUSH
15133: CALL_OW 69
15137: AND
15138: IFFALSE 15257
15140: GO 15142
15142: DISABLE
// begin wait ( 0 0$10 ) ;
15143: LD_INT 350
15145: PPUSH
15146: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15150: LD_EXP 55
15154: PPUSH
15155: CALL_OW 302
15159: NOT
15160: PUSH
15161: LD_INT 22
15163: PUSH
15164: LD_INT 1
15166: PUSH
15167: EMPTY
15168: LIST
15169: LIST
15170: PUSH
15171: LD_INT 34
15173: PUSH
15174: LD_INT 8
15176: PUSH
15177: EMPTY
15178: LIST
15179: LIST
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PPUSH
15185: CALL_OW 69
15189: NOT
15190: OR
15191: IFFALSE 15195
// exit ;
15193: GO 15257
// DialogueOn ;
15195: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15199: LD_EXP 55
15203: PPUSH
15204: LD_STRING DWinAmericans-Pow-1
15206: PPUSH
15207: CALL_OW 94
// if IsOk ( Burlak ) then
15211: LD_EXP 52
15215: PPUSH
15216: CALL_OW 302
15220: IFFALSE 15234
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15222: LD_EXP 52
15226: PPUSH
15227: LD_STRING DWinAmericans-Bur-1
15229: PPUSH
15230: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15234: LD_EXP 19
15238: PPUSH
15239: LD_STRING DWinAmericans-JMM-1
15241: PPUSH
15242: CALL_OW 88
// DialogueOff ;
15246: CALL_OW 7
// YouLost ( AmBomb ) ;
15250: LD_STRING AmBomb
15252: PPUSH
15253: CALL_OW 104
// end ;
15257: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15258: LD_EXP 2
15262: NOT
15263: PUSH
15264: LD_INT 22
15266: PUSH
15267: LD_INT 3
15269: PUSH
15270: EMPTY
15271: LIST
15272: LIST
15273: PUSH
15274: LD_INT 34
15276: PUSH
15277: LD_INT 48
15279: PUSH
15280: EMPTY
15281: LIST
15282: LIST
15283: PUSH
15284: EMPTY
15285: LIST
15286: LIST
15287: PPUSH
15288: CALL_OW 69
15292: AND
15293: IFFALSE 15412
15295: GO 15297
15297: DISABLE
// begin wait ( 0 0$10 ) ;
15298: LD_INT 350
15300: PPUSH
15301: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15305: LD_EXP 60
15309: PPUSH
15310: CALL_OW 302
15314: NOT
15315: PUSH
15316: LD_INT 22
15318: PUSH
15319: LD_INT 3
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: LD_INT 34
15328: PUSH
15329: LD_INT 48
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: PPUSH
15340: CALL_OW 69
15344: NOT
15345: OR
15346: IFFALSE 15350
// exit ;
15348: GO 15412
// DialogueOn ;
15350: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15354: LD_EXP 60
15358: PPUSH
15359: LD_STRING DWinRussians-Pla-1
15361: PPUSH
15362: CALL_OW 94
// if IsOk ( Burlak ) then
15366: LD_EXP 52
15370: PPUSH
15371: CALL_OW 302
15375: IFFALSE 15389
// Say ( Burlak , DWinRussians-Bur-1 ) ;
15377: LD_EXP 52
15381: PPUSH
15382: LD_STRING DWinRussians-Bur-1
15384: PPUSH
15385: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
15389: LD_EXP 19
15393: PPUSH
15394: LD_STRING DWinRussians-JMM-1
15396: PPUSH
15397: CALL_OW 88
// DialogueOff ;
15401: CALL_OW 7
// YouLost ( RuBomb ) ;
15405: LD_STRING RuBomb
15407: PPUSH
15408: CALL_OW 104
// end ;
15412: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
15413: LD_INT 7
15415: PPUSH
15416: LD_INT 22
15418: PUSH
15419: LD_INT 7
15421: PUSH
15422: EMPTY
15423: LIST
15424: LIST
15425: PPUSH
15426: CALL_OW 70
15430: PUSH
15431: LD_EXP 4
15435: NOT
15436: AND
15437: IFFALSE 15466
15439: GO 15441
15441: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
15442: LD_EXP 55
15446: PPUSH
15447: LD_STRING DSurrenderAmericans-Pow-1
15449: PPUSH
15450: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
15454: LD_EXP 19
15458: PPUSH
15459: LD_STRING DSurrenderAmericans-JMM-1
15461: PPUSH
15462: CALL_OW 88
// end ;
15466: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
15467: LD_INT 2
15469: PPUSH
15470: LD_INT 22
15472: PUSH
15473: LD_INT 7
15475: PUSH
15476: EMPTY
15477: LIST
15478: LIST
15479: PPUSH
15480: CALL_OW 70
15484: PUSH
15485: LD_EXP 2
15489: NOT
15490: AND
15491: PUSH
15492: LD_EXP 52
15496: AND
15497: IFFALSE 15526
15499: GO 15501
15501: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
15502: LD_EXP 60
15506: PPUSH
15507: LD_STRING DSurrenderRussians-Pla-1
15509: PPUSH
15510: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15514: LD_EXP 52
15518: PPUSH
15519: LD_STRING DSurrenderRussians-Bur-1
15521: PPUSH
15522: CALL_OW 88
// end ;
15526: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
15527: LD_EXP 4
15531: IFFALSE 15963
15533: GO 15535
15535: DISABLE
15536: LD_INT 0
15538: PPUSH
15539: PPUSH
15540: PPUSH
// begin MC_Kill ( 4 ) ;
15541: LD_INT 4
15543: PPUSH
15544: CALL 22411 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
15548: LD_INT 1
15550: PPUSH
15551: LD_INT 7
15553: PPUSH
15554: LD_INT 1
15556: PPUSH
15557: LD_INT 1
15559: PPUSH
15560: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
15564: LD_ADDR_VAR 0 3
15568: PUSH
15569: LD_INT 22
15571: PUSH
15572: LD_INT 1
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: LD_INT 26
15581: PUSH
15582: LD_INT 1
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: LD_INT 23
15591: PUSH
15592: LD_INT 1
15594: PUSH
15595: EMPTY
15596: LIST
15597: LIST
15598: PUSH
15599: EMPTY
15600: LIST
15601: LIST
15602: LIST
15603: PPUSH
15604: CALL_OW 69
15608: PUSH
15609: LD_EXP 55
15613: PUSH
15614: LD_EXP 27
15618: PUSH
15619: LD_EXP 24
15623: PUSH
15624: LD_EXP 23
15628: PUSH
15629: LD_EXP 30
15633: PUSH
15634: LD_EXP 28
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: LIST
15646: DIFF
15647: ST_TO_ADDR
// if not speaker then
15648: LD_VAR 0 3
15652: NOT
15653: IFFALSE 15693
// begin uc_side := 1 ;
15655: LD_ADDR_OWVAR 20
15659: PUSH
15660: LD_INT 1
15662: ST_TO_ADDR
// uc_nation := 1 ;
15663: LD_ADDR_OWVAR 21
15667: PUSH
15668: LD_INT 1
15670: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
15671: LD_INT 1
15673: PPUSH
15674: LD_INT 0
15676: PPUSH
15677: CALL_OW 381
// speaker := CreateHuman ;
15681: LD_ADDR_VAR 0 3
15685: PUSH
15686: CALL_OW 44
15690: ST_TO_ADDR
// end else
15691: GO 15707
// speaker := speaker [ 1 ] ;
15693: LD_ADDR_VAR 0 3
15697: PUSH
15698: LD_VAR 0 3
15702: PUSH
15703: LD_INT 1
15705: ARRAY
15706: ST_TO_ADDR
// DialogueOn ;
15707: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
15711: LD_VAR 0 3
15715: PPUSH
15716: LD_STRING DSurrenderAmericans-Sol1-1a
15718: PPUSH
15719: CALL_OW 94
// DialogueOff ;
15723: CALL_OW 7
// americanCapitulated := true ;
15727: LD_ADDR_EXP 6
15731: PUSH
15732: LD_INT 1
15734: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15735: LD_ADDR_VAR 0 2
15739: PUSH
15740: LD_INT 22
15742: PUSH
15743: LD_INT 1
15745: PUSH
15746: EMPTY
15747: LIST
15748: LIST
15749: PUSH
15750: LD_INT 21
15752: PUSH
15753: LD_INT 1
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: PUSH
15760: EMPTY
15761: LIST
15762: LIST
15763: PPUSH
15764: CALL_OW 69
15768: PUSH
15769: LD_INT 22
15771: PUSH
15772: LD_INT 1
15774: PUSH
15775: EMPTY
15776: LIST
15777: LIST
15778: PUSH
15779: LD_INT 21
15781: PUSH
15782: LD_INT 2
15784: PUSH
15785: EMPTY
15786: LIST
15787: LIST
15788: PUSH
15789: LD_INT 1
15791: PUSH
15792: EMPTY
15793: LIST
15794: PUSH
15795: EMPTY
15796: LIST
15797: LIST
15798: LIST
15799: PPUSH
15800: CALL_OW 69
15804: ADD
15805: ST_TO_ADDR
// if tmp then
15806: LD_VAR 0 2
15810: IFFALSE 15963
// repeat wait ( 0 0$1 ) ;
15812: LD_INT 35
15814: PPUSH
15815: CALL_OW 67
// for i in tmp do
15819: LD_ADDR_VAR 0 1
15823: PUSH
15824: LD_VAR 0 2
15828: PUSH
15829: FOR_IN
15830: IFFALSE 15912
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15832: LD_VAR 0 1
15836: PPUSH
15837: CALL_OW 310
15841: PUSH
15842: LD_VAR 0 1
15846: PPUSH
15847: CALL_OW 310
15851: PPUSH
15852: CALL_OW 247
15856: PUSH
15857: LD_INT 3
15859: EQUAL
15860: AND
15861: IFFALSE 15872
// ComExitBuilding ( i ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15872: LD_VAR 0 1
15876: PPUSH
15877: LD_INT 122
15879: PPUSH
15880: LD_INT 242
15882: PPUSH
15883: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15887: LD_VAR 0 1
15891: PPUSH
15892: LD_INT 35
15894: PPUSH
15895: CALL_OW 308
15899: IFFALSE 15910
// RemoveUnit ( i ) ;
15901: LD_VAR 0 1
15905: PPUSH
15906: CALL_OW 64
// end ;
15910: GO 15829
15912: POP
15913: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15914: LD_INT 22
15916: PUSH
15917: LD_INT 1
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: PUSH
15924: LD_INT 2
15926: PUSH
15927: LD_INT 21
15929: PUSH
15930: LD_INT 1
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: PUSH
15937: LD_INT 33
15939: PUSH
15940: LD_INT 1
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: LIST
15951: PUSH
15952: EMPTY
15953: LIST
15954: LIST
15955: PPUSH
15956: CALL_OW 69
15960: NOT
15961: IFFALSE 15812
// end ;
15963: PPOPN 3
15965: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15966: LD_EXP 2
15970: IFFALSE 16412
15972: GO 15974
15974: DISABLE
15975: LD_INT 0
15977: PPUSH
15978: PPUSH
15979: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15980: LD_INT 35
15982: PPUSH
15983: CALL_OW 67
// until IsDead ( Yakotich ) ;
15987: LD_EXP 61
15991: PPUSH
15992: CALL_OW 301
15996: IFFALSE 15980
// MC_Kill ( 2 ) ;
15998: LD_INT 2
16000: PPUSH
16001: CALL 22411 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16005: LD_INT 3
16007: PPUSH
16008: LD_INT 7
16010: PPUSH
16011: LD_INT 1
16013: PPUSH
16014: LD_INT 1
16016: PPUSH
16017: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16021: LD_ADDR_VAR 0 3
16025: PUSH
16026: LD_INT 22
16028: PUSH
16029: LD_INT 3
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: PUSH
16036: LD_INT 26
16038: PUSH
16039: LD_INT 1
16041: PUSH
16042: EMPTY
16043: LIST
16044: LIST
16045: PUSH
16046: LD_INT 23
16048: PUSH
16049: LD_INT 3
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: LIST
16060: PPUSH
16061: CALL_OW 69
16065: PUSH
16066: LD_EXP 60
16070: DIFF
16071: ST_TO_ADDR
// if not speaker then
16072: LD_VAR 0 3
16076: NOT
16077: IFFALSE 16117
// begin uc_side := 3 ;
16079: LD_ADDR_OWVAR 20
16083: PUSH
16084: LD_INT 3
16086: ST_TO_ADDR
// uc_nation := 3 ;
16087: LD_ADDR_OWVAR 21
16091: PUSH
16092: LD_INT 3
16094: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16095: LD_INT 1
16097: PPUSH
16098: LD_INT 0
16100: PPUSH
16101: CALL_OW 381
// speaker := CreateHuman ;
16105: LD_ADDR_VAR 0 3
16109: PUSH
16110: CALL_OW 44
16114: ST_TO_ADDR
// end else
16115: GO 16131
// speaker := speaker [ 1 ] ;
16117: LD_ADDR_VAR 0 3
16121: PUSH
16122: LD_VAR 0 3
16126: PUSH
16127: LD_INT 1
16129: ARRAY
16130: ST_TO_ADDR
// DialogueOn ;
16131: CALL_OW 6
// if IsOK ( Burlak ) then
16135: LD_EXP 52
16139: PPUSH
16140: CALL_OW 302
16144: IFFALSE 16160
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16146: LD_VAR 0 3
16150: PPUSH
16151: LD_STRING DSurrenderRussians-RSol1-1
16153: PPUSH
16154: CALL_OW 94
16158: GO 16172
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16160: LD_VAR 0 3
16164: PPUSH
16165: LD_STRING DSurrenderRussians-RSol1-1a
16167: PPUSH
16168: CALL_OW 94
// DialogueOff ;
16172: CALL_OW 7
// russianCapitulated := true ;
16176: LD_ADDR_EXP 7
16180: PUSH
16181: LD_INT 1
16183: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16184: LD_ADDR_VAR 0 2
16188: PUSH
16189: LD_INT 22
16191: PUSH
16192: LD_INT 3
16194: PUSH
16195: EMPTY
16196: LIST
16197: LIST
16198: PUSH
16199: LD_INT 21
16201: PUSH
16202: LD_INT 1
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PPUSH
16213: CALL_OW 69
16217: PUSH
16218: LD_INT 22
16220: PUSH
16221: LD_INT 3
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: PUSH
16228: LD_INT 21
16230: PUSH
16231: LD_INT 2
16233: PUSH
16234: EMPTY
16235: LIST
16236: LIST
16237: PUSH
16238: LD_INT 1
16240: PUSH
16241: EMPTY
16242: LIST
16243: PUSH
16244: EMPTY
16245: LIST
16246: LIST
16247: LIST
16248: PPUSH
16249: CALL_OW 69
16253: ADD
16254: ST_TO_ADDR
// if tmp then
16255: LD_VAR 0 2
16259: IFFALSE 16412
// repeat wait ( 0 0$1 ) ;
16261: LD_INT 35
16263: PPUSH
16264: CALL_OW 67
// for i in tmp do
16268: LD_ADDR_VAR 0 1
16272: PUSH
16273: LD_VAR 0 2
16277: PUSH
16278: FOR_IN
16279: IFFALSE 16361
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16281: LD_VAR 0 1
16285: PPUSH
16286: CALL_OW 310
16290: PUSH
16291: LD_VAR 0 1
16295: PPUSH
16296: CALL_OW 310
16300: PPUSH
16301: CALL_OW 247
16305: PUSH
16306: LD_INT 3
16308: EQUAL
16309: AND
16310: IFFALSE 16321
// ComExitBuilding ( i ) ;
16312: LD_VAR 0 1
16316: PPUSH
16317: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16321: LD_VAR 0 1
16325: PPUSH
16326: LD_INT 154
16328: PPUSH
16329: LD_INT 1
16331: PPUSH
16332: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16336: LD_VAR 0 1
16340: PPUSH
16341: LD_INT 36
16343: PPUSH
16344: CALL_OW 308
16348: IFFALSE 16359
// RemoveUnit ( i ) ;
16350: LD_VAR 0 1
16354: PPUSH
16355: CALL_OW 64
// end ;
16359: GO 16278
16361: POP
16362: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16363: LD_INT 22
16365: PUSH
16366: LD_INT 3
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PUSH
16373: LD_INT 2
16375: PUSH
16376: LD_INT 21
16378: PUSH
16379: LD_INT 1
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 33
16388: PUSH
16389: LD_INT 1
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: LIST
16400: PUSH
16401: EMPTY
16402: LIST
16403: LIST
16404: PPUSH
16405: CALL_OW 69
16409: NOT
16410: IFFALSE 16261
// end ;
16412: PPOPN 3
16414: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
16415: LD_INT 22
16417: PUSH
16418: LD_INT 8
16420: PUSH
16421: EMPTY
16422: LIST
16423: LIST
16424: PUSH
16425: LD_INT 21
16427: PUSH
16428: LD_INT 1
16430: PUSH
16431: EMPTY
16432: LIST
16433: LIST
16434: PUSH
16435: LD_INT 23
16437: PUSH
16438: LD_INT 2
16440: PUSH
16441: EMPTY
16442: LIST
16443: LIST
16444: PUSH
16445: EMPTY
16446: LIST
16447: LIST
16448: LIST
16449: PPUSH
16450: CALL_OW 69
16454: PUSH
16455: LD_INT 18
16457: LESS
16458: PUSH
16459: LD_EXP 58
16463: PPUSH
16464: CALL_OW 301
16468: OR
16469: PUSH
16470: LD_INT 324
16472: PPUSH
16473: CALL_OW 255
16477: PUSH
16478: LD_INT 7
16480: EQUAL
16481: OR
16482: IFFALSE 16495
16484: GO 16486
16486: DISABLE
// legionDestroyed := true ;
16487: LD_ADDR_EXP 3
16491: PUSH
16492: LD_INT 1
16494: ST_TO_ADDR
16495: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
16496: LD_INT 22
16498: PUSH
16499: LD_INT 2
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: LD_INT 21
16508: PUSH
16509: LD_INT 1
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PUSH
16516: LD_INT 23
16518: PUSH
16519: LD_INT 2
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: LIST
16530: PPUSH
16531: CALL_OW 69
16535: PUSH
16536: LD_INT 9
16538: LESS
16539: PUSH
16540: LD_INT 503
16542: PPUSH
16543: CALL_OW 301
16547: OR
16548: PUSH
16549: LD_INT 503
16551: PPUSH
16552: CALL_OW 255
16556: PUSH
16557: LD_INT 7
16559: EQUAL
16560: OR
16561: IFFALSE 16574
16563: GO 16565
16565: DISABLE
// arabianDestroyed := true ;
16566: LD_ADDR_EXP 5
16570: PUSH
16571: LD_INT 1
16573: ST_TO_ADDR
16574: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
16575: LD_EXP 5
16579: IFFALSE 16823
16581: GO 16583
16583: DISABLE
16584: LD_INT 0
16586: PPUSH
16587: PPUSH
// begin MC_Kill ( 1 ) ;
16588: LD_INT 1
16590: PPUSH
16591: CALL 22411 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16595: LD_ADDR_VAR 0 2
16599: PUSH
16600: LD_INT 22
16602: PUSH
16603: LD_INT 2
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PUSH
16610: LD_INT 21
16612: PUSH
16613: LD_INT 1
16615: PUSH
16616: EMPTY
16617: LIST
16618: LIST
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PPUSH
16624: CALL_OW 69
16628: PUSH
16629: LD_INT 22
16631: PUSH
16632: LD_INT 2
16634: PUSH
16635: EMPTY
16636: LIST
16637: LIST
16638: PUSH
16639: LD_INT 21
16641: PUSH
16642: LD_INT 2
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: PUSH
16649: LD_INT 1
16651: PUSH
16652: EMPTY
16653: LIST
16654: PUSH
16655: EMPTY
16656: LIST
16657: LIST
16658: LIST
16659: PPUSH
16660: CALL_OW 69
16664: ADD
16665: ST_TO_ADDR
// if tmp then
16666: LD_VAR 0 2
16670: IFFALSE 16823
// repeat wait ( 0 0$1 ) ;
16672: LD_INT 35
16674: PPUSH
16675: CALL_OW 67
// for i in tmp do
16679: LD_ADDR_VAR 0 1
16683: PUSH
16684: LD_VAR 0 2
16688: PUSH
16689: FOR_IN
16690: IFFALSE 16772
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16692: LD_VAR 0 1
16696: PPUSH
16697: CALL_OW 310
16701: PUSH
16702: LD_VAR 0 1
16706: PPUSH
16707: CALL_OW 310
16711: PPUSH
16712: CALL_OW 247
16716: PUSH
16717: LD_INT 3
16719: EQUAL
16720: AND
16721: IFFALSE 16732
// ComExitBuilding ( i ) ;
16723: LD_VAR 0 1
16727: PPUSH
16728: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
16732: LD_VAR 0 1
16736: PPUSH
16737: LD_INT 254
16739: PPUSH
16740: LD_INT 268
16742: PPUSH
16743: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
16747: LD_VAR 0 1
16751: PPUSH
16752: LD_INT 34
16754: PPUSH
16755: CALL_OW 308
16759: IFFALSE 16770
// RemoveUnit ( i ) ;
16761: LD_VAR 0 1
16765: PPUSH
16766: CALL_OW 64
// end ;
16770: GO 16689
16772: POP
16773: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16774: LD_INT 22
16776: PUSH
16777: LD_INT 2
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: PUSH
16784: LD_INT 2
16786: PUSH
16787: LD_INT 21
16789: PUSH
16790: LD_INT 1
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: LD_INT 33
16799: PUSH
16800: LD_INT 1
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: LIST
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: PPUSH
16816: CALL_OW 69
16820: NOT
16821: IFFALSE 16672
// end ;
16823: PPOPN 2
16825: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16826: LD_EXP 3
16830: IFFALSE 17182
16832: GO 16834
16834: DISABLE
16835: LD_INT 0
16837: PPUSH
16838: PPUSH
// begin MC_Kill ( 3 ) ;
16839: LD_INT 3
16841: PPUSH
16842: CALL 22411 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16846: LD_INT 8
16848: PPUSH
16849: LD_INT 7
16851: PPUSH
16852: LD_INT 1
16854: PPUSH
16855: LD_INT 1
16857: PPUSH
16858: CALL_OW 80
// DialogueOn ;
16862: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16866: LD_EXP 57
16870: PPUSH
16871: LD_STRING D15-Szulc-1
16873: PPUSH
16874: CALL_OW 94
// DialogueOff ;
16878: CALL_OW 7
// legionCapitulated := true ;
16882: LD_ADDR_EXP 8
16886: PUSH
16887: LD_INT 1
16889: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16890: LD_ADDR_VAR 0 1
16894: PUSH
16895: LD_INT 22
16897: PUSH
16898: LD_INT 8
16900: PUSH
16901: EMPTY
16902: LIST
16903: LIST
16904: PUSH
16905: LD_INT 21
16907: PUSH
16908: LD_INT 3
16910: PUSH
16911: EMPTY
16912: LIST
16913: LIST
16914: PUSH
16915: LD_INT 23
16917: PUSH
16918: LD_INT 3
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: PPUSH
16930: CALL_OW 69
16934: PUSH
16935: FOR_IN
16936: IFFALSE 16952
// SetLives ( i , 3 ) ;
16938: LD_VAR 0 1
16942: PPUSH
16943: LD_INT 3
16945: PPUSH
16946: CALL_OW 234
16950: GO 16935
16952: POP
16953: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16954: LD_ADDR_VAR 0 2
16958: PUSH
16959: LD_INT 22
16961: PUSH
16962: LD_INT 8
16964: PUSH
16965: EMPTY
16966: LIST
16967: LIST
16968: PUSH
16969: LD_INT 21
16971: PUSH
16972: LD_INT 1
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PUSH
16979: EMPTY
16980: LIST
16981: LIST
16982: PPUSH
16983: CALL_OW 69
16987: PUSH
16988: LD_INT 22
16990: PUSH
16991: LD_INT 8
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: LD_INT 21
17000: PUSH
17001: LD_INT 2
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PUSH
17008: LD_INT 1
17010: PUSH
17011: EMPTY
17012: LIST
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: LIST
17018: PPUSH
17019: CALL_OW 69
17023: ADD
17024: ST_TO_ADDR
// if tmp then
17025: LD_VAR 0 2
17029: IFFALSE 17182
// repeat wait ( 0 0$1 ) ;
17031: LD_INT 35
17033: PPUSH
17034: CALL_OW 67
// for i in tmp do
17038: LD_ADDR_VAR 0 1
17042: PUSH
17043: LD_VAR 0 2
17047: PUSH
17048: FOR_IN
17049: IFFALSE 17131
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17051: LD_VAR 0 1
17055: PPUSH
17056: CALL_OW 310
17060: PUSH
17061: LD_VAR 0 1
17065: PPUSH
17066: CALL_OW 310
17070: PPUSH
17071: CALL_OW 247
17075: PUSH
17076: LD_INT 3
17078: EQUAL
17079: AND
17080: IFFALSE 17091
// ComExitBuilding ( i ) ;
17082: LD_VAR 0 1
17086: PPUSH
17087: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17091: LD_VAR 0 1
17095: PPUSH
17096: LD_INT 10
17098: PPUSH
17099: LD_INT 1
17101: PPUSH
17102: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17106: LD_VAR 0 1
17110: PPUSH
17111: LD_INT 32
17113: PPUSH
17114: CALL_OW 308
17118: IFFALSE 17129
// RemoveUnit ( i ) ;
17120: LD_VAR 0 1
17124: PPUSH
17125: CALL_OW 64
// end ;
17129: GO 17048
17131: POP
17132: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17133: LD_INT 22
17135: PUSH
17136: LD_INT 8
17138: PUSH
17139: EMPTY
17140: LIST
17141: LIST
17142: PUSH
17143: LD_INT 2
17145: PUSH
17146: LD_INT 21
17148: PUSH
17149: LD_INT 1
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: PUSH
17156: LD_INT 33
17158: PUSH
17159: LD_INT 1
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: LIST
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PPUSH
17175: CALL_OW 69
17179: NOT
17180: IFFALSE 17031
// end ;
17182: PPOPN 2
17184: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17185: LD_EXP 5
17189: NOT
17190: PUSH
17191: LD_OWVAR 1
17195: PUSH
17196: LD_INT 63000
17198: GREATEREQUAL
17199: AND
17200: PUSH
17201: LD_OWVAR 67
17205: PUSH
17206: LD_INT 3
17208: LESS
17209: AND
17210: IFFALSE 17219
17212: GO 17214
17214: DISABLE
// AllianceSupport ;
17215: CALL 4677 0 0
17219: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17220: LD_EXP 4
17224: PUSH
17225: LD_EXP 2
17229: AND
17230: PUSH
17231: LD_EXP 3
17235: AND
17236: PUSH
17237: LD_EXP 5
17241: AND
17242: PUSH
17243: LD_EXP 6
17247: AND
17248: PUSH
17249: LD_EXP 7
17253: AND
17254: PUSH
17255: LD_EXP 8
17259: AND
17260: PUSH
17261: LD_EXP 56
17265: PPUSH
17266: CALL_OW 255
17270: PUSH
17271: LD_INT 5
17273: NONEQUAL
17274: PUSH
17275: LD_EXP 56
17279: PPUSH
17280: CALL_OW 301
17284: OR
17285: PUSH
17286: LD_EXP 56
17290: PPUSH
17291: CALL_OW 305
17295: NOT
17296: OR
17297: AND
17298: IFFALSE 18817
17300: GO 17302
17302: DISABLE
17303: LD_INT 0
17305: PPUSH
17306: PPUSH
// begin wait ( 0 0$5 ) ;
17307: LD_INT 175
17309: PPUSH
17310: CALL_OW 67
// music_class := 5 ;
17314: LD_ADDR_OWVAR 72
17318: PUSH
17319: LD_INT 5
17321: ST_TO_ADDR
// music_nat := 5 ;
17322: LD_ADDR_OWVAR 71
17326: PUSH
17327: LD_INT 5
17329: ST_TO_ADDR
// if vehicleLostCounter < 3 then
17330: LD_EXP 15
17334: PUSH
17335: LD_INT 3
17337: LESS
17338: IFFALSE 17347
// SetAchievement ( ACH_ECONOMY ) ;
17340: LD_STRING ACH_ECONOMY
17342: PPUSH
17343: CALL_OW 543
// if tick < 60 60$00 then
17347: LD_OWVAR 1
17351: PUSH
17352: LD_INT 126000
17354: LESS
17355: IFFALSE 17371
// begin wait ( 3 ) ;
17357: LD_INT 3
17359: PPUSH
17360: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
17364: LD_STRING ACH_ASPEED_19
17366: PPUSH
17367: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
17371: LD_EXP 19
17375: PPUSH
17376: CALL_OW 87
// InGameOn ;
17380: CALL_OW 8
// DialogueOn ;
17384: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
17388: LD_EXP 19
17392: PPUSH
17393: LD_STRING DEnd-JMM-JMM-1
17395: PPUSH
17396: CALL_OW 88
// if Joan then
17400: LD_EXP 34
17404: IFFALSE 17420
// Say ( Joan , DEnd-JMM-Joan-1 ) else
17406: LD_EXP 34
17410: PPUSH
17411: LD_STRING DEnd-JMM-Joan-1
17413: PPUSH
17414: CALL_OW 88
17418: GO 17464
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
17420: LD_EXP 21
17424: PUSH
17425: LD_EXP 21
17429: PPUSH
17430: CALL_OW 255
17434: PUSH
17435: LD_INT 7
17437: EQUAL
17438: AND
17439: PUSH
17440: LD_EXP 21
17444: PPUSH
17445: CALL_OW 305
17449: AND
17450: IFFALSE 17464
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17452: LD_EXP 21
17456: PPUSH
17457: LD_STRING DEnd-JMM-Lisa-1
17459: PPUSH
17460: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
17464: LD_EXP 31
17468: PUSH
17469: LD_EXP 31
17473: PPUSH
17474: CALL_OW 305
17478: AND
17479: IFFALSE 17493
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17481: LD_EXP 31
17485: PPUSH
17486: LD_STRING DEnd-JMM-Frank-1
17488: PPUSH
17489: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
17493: LD_EXP 24
17497: PUSH
17498: LD_EXP 24
17502: PPUSH
17503: CALL_OW 255
17507: PUSH
17508: LD_INT 7
17510: EQUAL
17511: AND
17512: PUSH
17513: LD_EXP 24
17517: PPUSH
17518: CALL_OW 305
17522: AND
17523: IFFALSE 17537
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17525: LD_EXP 24
17529: PPUSH
17530: LD_STRING DEnd-JMM-Cyrus-1
17532: PPUSH
17533: CALL_OW 88
// if Burlak then
17537: LD_EXP 52
17541: IFFALSE 17555
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17543: LD_EXP 52
17547: PPUSH
17548: LD_STRING DEnd-JMM-Bur-1
17550: PPUSH
17551: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
17555: LD_EXP 34
17559: PUSH
17560: LD_EXP 21
17564: AND
17565: PUSH
17566: LD_EXP 21
17570: PPUSH
17571: CALL_OW 255
17575: PUSH
17576: LD_INT 7
17578: EQUAL
17579: AND
17580: PUSH
17581: LD_EXP 21
17585: PPUSH
17586: CALL_OW 305
17590: AND
17591: PUSH
17592: LD_EXP 52
17596: PPUSH
17597: CALL_OW 302
17601: AND
17602: IFFALSE 17616
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
17604: LD_EXP 21
17608: PPUSH
17609: LD_STRING DEnd-Burlak-Lisa-1
17611: PPUSH
17612: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
17616: LD_EXP 53
17620: PUSH
17621: LD_EXP 53
17625: PPUSH
17626: CALL_OW 305
17630: AND
17631: IFFALSE 17645
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
17633: LD_EXP 53
17637: PPUSH
17638: LD_STRING DEnd-JMM-Bel-1
17640: PPUSH
17641: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
17645: LD_EXP 54
17649: PUSH
17650: LD_EXP 54
17654: PPUSH
17655: CALL_OW 305
17659: AND
17660: IFFALSE 17674
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
17662: LD_EXP 54
17666: PPUSH
17667: LD_STRING DEnd-JMM-Gny-1
17669: PPUSH
17670: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
17674: LD_EXP 29
17678: PUSH
17679: LD_EXP 29
17683: PPUSH
17684: CALL_OW 255
17688: PUSH
17689: LD_INT 7
17691: EQUAL
17692: AND
17693: PUSH
17694: LD_EXP 29
17698: PPUSH
17699: CALL_OW 305
17703: AND
17704: IFFALSE 17718
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
17706: LD_EXP 29
17710: PPUSH
17711: LD_STRING DEnd-JMM-Corn-1
17713: PPUSH
17714: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
17718: LD_EXP 22
17722: PUSH
17723: LD_EXP 22
17727: PPUSH
17728: CALL_OW 255
17732: PUSH
17733: LD_INT 7
17735: EQUAL
17736: AND
17737: PUSH
17738: LD_EXP 22
17742: PPUSH
17743: CALL_OW 305
17747: AND
17748: IFFALSE 17762
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17750: LD_EXP 22
17754: PPUSH
17755: LD_STRING DEnd-JMM-Don-1
17757: PPUSH
17758: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
17762: LD_EXP 23
17766: PUSH
17767: LD_EXP 23
17771: PPUSH
17772: CALL_OW 255
17776: PUSH
17777: LD_INT 7
17779: EQUAL
17780: AND
17781: PUSH
17782: LD_EXP 23
17786: PPUSH
17787: CALL_OW 305
17791: AND
17792: IFFALSE 17806
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17794: LD_EXP 23
17798: PPUSH
17799: LD_STRING DEnd-JMM-Bobby-1
17801: PPUSH
17802: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17806: LD_EXP 25
17810: PUSH
17811: LD_EXP 25
17815: PPUSH
17816: CALL_OW 255
17820: PUSH
17821: LD_INT 7
17823: EQUAL
17824: AND
17825: PUSH
17826: LD_EXP 25
17830: PPUSH
17831: CALL_OW 305
17835: AND
17836: IFFALSE 17850
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17838: LD_EXP 25
17842: PPUSH
17843: LD_STRING DEnd-JMM-Den-1
17845: PPUSH
17846: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17850: LD_EXP 27
17854: PUSH
17855: LD_EXP 27
17859: PPUSH
17860: CALL_OW 255
17864: PUSH
17865: LD_INT 7
17867: EQUAL
17868: AND
17869: PUSH
17870: LD_EXP 27
17874: PPUSH
17875: CALL_OW 305
17879: AND
17880: IFFALSE 17894
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17882: LD_EXP 27
17886: PPUSH
17887: LD_STRING DEnd-JMM-Glad-1
17889: PPUSH
17890: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17894: LD_EXP 32
17898: PUSH
17899: LD_EXP 32
17903: PPUSH
17904: CALL_OW 255
17908: PUSH
17909: LD_INT 7
17911: EQUAL
17912: AND
17913: PUSH
17914: LD_EXP 32
17918: PPUSH
17919: CALL_OW 305
17923: AND
17924: IFFALSE 17938
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17926: LD_EXP 32
17930: PPUSH
17931: LD_STRING DEnd-JMM-Yam-1
17933: PPUSH
17934: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17938: LD_EXP 26
17942: PUSH
17943: LD_EXP 26
17947: PPUSH
17948: CALL_OW 255
17952: PUSH
17953: LD_INT 7
17955: EQUAL
17956: AND
17957: PUSH
17958: LD_EXP 26
17962: PPUSH
17963: CALL_OW 305
17967: AND
17968: IFFALSE 17982
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17970: LD_EXP 26
17974: PPUSH
17975: LD_STRING DEnd-JMM-Brown-1
17977: PPUSH
17978: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17982: LD_EXP 36
17986: PUSH
17987: LD_EXP 36
17991: PPUSH
17992: CALL_OW 255
17996: PUSH
17997: LD_INT 7
17999: EQUAL
18000: AND
18001: PUSH
18002: LD_EXP 36
18006: PPUSH
18007: CALL_OW 305
18011: AND
18012: IFFALSE 18026
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18014: LD_EXP 36
18018: PPUSH
18019: LD_STRING DEnd-JMM-Con-1
18021: PPUSH
18022: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
18026: LD_EXP 30
18030: PUSH
18031: LD_EXP 30
18035: PPUSH
18036: CALL_OW 255
18040: PUSH
18041: LD_INT 7
18043: EQUAL
18044: AND
18045: PUSH
18046: LD_EXP 30
18050: PPUSH
18051: CALL_OW 305
18055: AND
18056: IFFALSE 18070
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18058: LD_EXP 30
18062: PPUSH
18063: LD_STRING DEnd-JMM-Gary-1
18065: PPUSH
18066: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18070: LD_EXP 20
18074: PUSH
18075: LD_EXP 20
18079: PPUSH
18080: CALL_OW 305
18084: AND
18085: IFFALSE 18099
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18087: LD_EXP 20
18091: PPUSH
18092: LD_STRING DEnd-JMM-Roth-1
18094: PPUSH
18095: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18099: LD_EXP 33
18103: PUSH
18104: LD_EXP 20
18108: AND
18109: PUSH
18110: LD_EXP 33
18114: PPUSH
18115: CALL_OW 305
18119: AND
18120: IFFALSE 18134
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18122: LD_EXP 33
18126: PPUSH
18127: LD_STRING DEnd-JMM-Sim-1
18129: PPUSH
18130: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18134: LD_EXP 28
18138: PUSH
18139: LD_EXP 28
18143: PPUSH
18144: CALL_OW 255
18148: PUSH
18149: LD_INT 7
18151: EQUAL
18152: AND
18153: PUSH
18154: LD_EXP 28
18158: PPUSH
18159: CALL_OW 305
18163: AND
18164: IFFALSE 18178
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18166: LD_EXP 28
18170: PPUSH
18171: LD_STRING DEnd-JMM-VanH-1
18173: PPUSH
18174: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18178: LD_EXP 42
18182: PUSH
18183: LD_EXP 42
18187: PPUSH
18188: CALL_OW 305
18192: AND
18193: IFFALSE 18207
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18195: LD_EXP 42
18199: PPUSH
18200: LD_STRING DEnd-JMM-Dol-1
18202: PPUSH
18203: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18207: LD_EXP 32
18211: PUSH
18212: LD_EXP 32
18216: PPUSH
18217: CALL_OW 255
18221: PUSH
18222: LD_INT 7
18224: EQUAL
18225: AND
18226: PUSH
18227: LD_EXP 32
18231: PPUSH
18232: CALL_OW 305
18236: AND
18237: IFFALSE 18251
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18239: LD_EXP 32
18243: PPUSH
18244: LD_STRING DEnd-JMM-Yam-1
18246: PPUSH
18247: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18251: LD_EXP 46
18255: PUSH
18256: LD_EXP 46
18260: PPUSH
18261: CALL_OW 305
18265: AND
18266: IFFALSE 18280
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18268: LD_EXP 46
18272: PPUSH
18273: LD_STRING DEnd-JMM-Kap-1
18275: PPUSH
18276: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18280: LD_EXP 49
18284: PUSH
18285: LD_EXP 49
18289: PPUSH
18290: CALL_OW 305
18294: AND
18295: IFFALSE 18309
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18297: LD_EXP 49
18301: PPUSH
18302: LD_STRING DEnd-JMM-Kov-1
18304: PPUSH
18305: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
18309: LD_EXP 44
18313: PUSH
18314: LD_EXP 44
18318: PPUSH
18319: CALL_OW 305
18323: AND
18324: IFFALSE 18338
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18326: LD_EXP 44
18330: PPUSH
18331: LD_STRING DEnd-JMM-Sch-1
18333: PPUSH
18334: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
18338: LD_EXP 40
18342: PUSH
18343: LD_EXP 40
18347: PPUSH
18348: CALL_OW 305
18352: AND
18353: PUSH
18354: LD_EXP 52
18358: PPUSH
18359: CALL_OW 302
18363: AND
18364: IFFALSE 18378
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18366: LD_EXP 40
18370: PPUSH
18371: LD_STRING DEnd-JMM-Tit-1
18373: PPUSH
18374: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
18378: LD_EXP 45
18382: PUSH
18383: LD_EXP 45
18387: PPUSH
18388: CALL_OW 305
18392: AND
18393: IFFALSE 18407
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18395: LD_EXP 45
18399: PPUSH
18400: LD_STRING DEnd-JMM-Obl-1
18402: PPUSH
18403: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
18407: LD_EXP 47
18411: PUSH
18412: LD_EXP 47
18416: PPUSH
18417: CALL_OW 305
18421: AND
18422: IFFALSE 18436
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18424: LD_EXP 47
18428: PPUSH
18429: LD_STRING DEnd-JMM-Lip-1
18431: PPUSH
18432: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
18436: LD_EXP 41
18440: PUSH
18441: LD_EXP 41
18445: PPUSH
18446: CALL_OW 305
18450: AND
18451: PUSH
18452: LD_EXP 52
18456: PPUSH
18457: CALL_OW 302
18461: AND
18462: IFFALSE 18476
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
18464: LD_EXP 41
18468: PPUSH
18469: LD_STRING DEnd-Burlak-Fad-1
18471: PPUSH
18472: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
18476: LD_EXP 48
18480: PUSH
18481: LD_EXP 48
18485: PPUSH
18486: CALL_OW 305
18490: AND
18491: IFFALSE 18505
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
18493: LD_EXP 48
18497: PPUSH
18498: LD_STRING DEnd-Burlak-Ptr-1
18500: PPUSH
18501: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
18505: LD_EXP 50
18509: PUSH
18510: LD_EXP 50
18514: PPUSH
18515: CALL_OW 305
18519: AND
18520: IFFALSE 18534
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
18522: LD_EXP 50
18526: PPUSH
18527: LD_STRING DEnd-Burlak-Kuz-1
18529: PPUSH
18530: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
18534: LD_EXP 39
18538: PUSH
18539: LD_EXP 39
18543: PPUSH
18544: CALL_OW 305
18548: AND
18549: PUSH
18550: LD_EXP 52
18554: PPUSH
18555: CALL_OW 302
18559: AND
18560: IFFALSE 18574
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
18562: LD_EXP 39
18566: PPUSH
18567: LD_STRING DEnd-Burlak-Kir-1
18569: PPUSH
18570: CALL_OW 88
// if Joan then
18574: LD_EXP 34
18578: IFFALSE 18592
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
18580: LD_EXP 34
18584: PPUSH
18585: LD_STRING DEnd-Burlak-Joan-1
18587: PPUSH
18588: CALL_OW 88
// if IsOk ( Burlak ) then
18592: LD_EXP 52
18596: PPUSH
18597: CALL_OW 302
18601: IFFALSE 18615
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
18603: LD_EXP 19
18607: PPUSH
18608: LD_STRING DEnd-Burlak-JMM-1
18610: PPUSH
18611: CALL_OW 88
// dwait ( 0 0$2 ) ;
18615: LD_INT 70
18617: PPUSH
18618: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
18622: LD_EXP 57
18626: PPUSH
18627: LD_STRING DEnd-Szulc
18629: PPUSH
18630: CALL_OW 94
// dwait ( 0 0$1 ) ;
18634: LD_INT 35
18636: PPUSH
18637: CALL_OW 68
// if IsLive ( Burlak ) then
18641: LD_EXP 52
18645: PPUSH
18646: CALL_OW 300
18650: IFFALSE 18662
// med1 := 1 else
18652: LD_ADDR_VAR 0 1
18656: PUSH
18657: LD_INT 1
18659: ST_TO_ADDR
18660: GO 18671
// med1 := - 1 ;
18662: LD_ADDR_VAR 0 1
18666: PUSH
18667: LD_INT 1
18669: NEG
18670: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
18671: LD_EXP 12
18675: PUSH
18676: LD_EXP 13
18680: AND
18681: PUSH
18682: LD_EXP 14
18686: AND
18687: IFFALSE 18699
// med2 := 1 else
18689: LD_ADDR_VAR 0 2
18693: PUSH
18694: LD_INT 1
18696: ST_TO_ADDR
18697: GO 18708
// med2 := - 1 ;
18699: LD_ADDR_VAR 0 2
18703: PUSH
18704: LD_INT 1
18706: NEG
18707: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
18708: LD_STRING Hero
18710: PPUSH
18711: LD_INT 1
18713: PPUSH
18714: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
18718: LD_STRING Artefact
18720: PPUSH
18721: LD_VAR 0 2
18725: PPUSH
18726: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
18730: LD_STRING ReconcileBurlak
18732: PPUSH
18733: LD_VAR 0 1
18737: PPUSH
18738: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
18742: LD_OWVAR 67
18746: PUSH
18747: LD_INT 3
18749: GREATEREQUAL
18750: PUSH
18751: LD_VAR 0 1
18755: PUSH
18756: LD_INT 1
18758: EQUAL
18759: AND
18760: PUSH
18761: LD_VAR 0 2
18765: PUSH
18766: LD_INT 1
18768: EQUAL
18769: AND
18770: IFFALSE 18782
// SetAchievementEX ( ACH_AMER , 19 ) ;
18772: LD_STRING ACH_AMER
18774: PPUSH
18775: LD_INT 19
18777: PPUSH
18778: CALL_OW 564
// GiveMedals ( MAIN ) ;
18782: LD_STRING MAIN
18784: PPUSH
18785: CALL_OW 102
// InGameOff ;
18789: CALL_OW 9
// DialogueOff ;
18793: CALL_OW 7
// music_nat := 1 ;
18797: LD_ADDR_OWVAR 71
18801: PUSH
18802: LD_INT 1
18804: ST_TO_ADDR
// music_class := 4 ;
18805: LD_ADDR_OWVAR 72
18809: PUSH
18810: LD_INT 4
18812: ST_TO_ADDR
// YouWin ;
18813: CALL_OW 103
// end ; end_of_file
18817: PPOPN 2
18819: END
// export function InitNature ; begin
18820: LD_INT 0
18822: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
18823: LD_INT 3
18825: PPUSH
18826: LD_INT 3
18828: PPUSH
18829: LD_INT 2
18831: PPUSH
18832: LD_INT 1
18834: PPUSH
18835: LD_INT 1
18837: PPUSH
18838: LD_INT 0
18840: PPUSH
18841: LD_INT 0
18843: PPUSH
18844: LD_INT 17
18846: PPUSH
18847: LD_INT 0
18849: PPUSH
18850: CALL 86830 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
18854: LD_INT 2
18856: PPUSH
18857: LD_INT 1
18859: PPUSH
18860: LD_INT 1
18862: PPUSH
18863: LD_INT 1
18865: PPUSH
18866: LD_INT 1
18868: PPUSH
18869: LD_INT 0
18871: PPUSH
18872: LD_INT 0
18874: PPUSH
18875: LD_INT 18
18877: PPUSH
18878: LD_INT 0
18880: PPUSH
18881: CALL 86830 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
18885: LD_INT 4
18887: PPUSH
18888: LD_INT 1
18890: PPUSH
18891: LD_INT 2
18893: PPUSH
18894: LD_INT 4
18896: PPUSH
18897: LD_INT 2
18899: PPUSH
18900: LD_INT 1
18902: PPUSH
18903: LD_INT 0
18905: PPUSH
18906: LD_INT 19
18908: PPUSH
18909: LD_INT 0
18911: PPUSH
18912: CALL 86830 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18916: LD_INT 0
18918: PPUSH
18919: LD_INT 0
18921: PPUSH
18922: LD_INT 0
18924: PPUSH
18925: LD_INT 0
18927: PPUSH
18928: LD_INT 0
18930: PPUSH
18931: LD_INT 0
18933: PPUSH
18934: LD_INT 9
18936: PPUSH
18937: LD_INT 0
18939: PPUSH
18940: LD_INT 20
18942: PPUSH
18943: CALL 86830 0 9
// end ; end_of_file
18947: LD_VAR 0 1
18951: RET
// every 0 0$30 do var time ;
18952: GO 18954
18954: DISABLE
18955: LD_INT 0
18957: PPUSH
// begin time := 0 0$30 ;
18958: LD_ADDR_VAR 0 1
18962: PUSH
18963: LD_INT 1050
18965: ST_TO_ADDR
// repeat wait ( time ) ;
18966: LD_VAR 0 1
18970: PPUSH
18971: CALL_OW 67
// if Prob ( 50 ) then
18975: LD_INT 50
18977: PPUSH
18978: CALL_OW 13
18982: IFFALSE 19011
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18984: LD_INT 1
18986: PPUSH
18987: LD_INT 5
18989: PPUSH
18990: CALL_OW 12
18994: PPUSH
18995: LD_INT 106
18997: PPUSH
18998: LD_INT 89
19000: PPUSH
19001: LD_INT 45
19003: PPUSH
19004: LD_INT 1
19006: PPUSH
19007: CALL_OW 56
// time := time + 0 0$3 ;
19011: LD_ADDR_VAR 0 1
19015: PUSH
19016: LD_VAR 0 1
19020: PUSH
19021: LD_INT 105
19023: PLUS
19024: ST_TO_ADDR
// if Prob ( 30 ) then
19025: LD_INT 30
19027: PPUSH
19028: CALL_OW 13
19032: IFFALSE 19078
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
19034: LD_INT 525
19036: PPUSH
19037: LD_INT 735
19039: PPUSH
19040: CALL_OW 12
19044: PPUSH
19045: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19049: LD_INT 1
19051: PPUSH
19052: LD_INT 5
19054: PPUSH
19055: CALL_OW 12
19059: PPUSH
19060: LD_INT 21
19062: PPUSH
19063: LD_INT 26
19065: PPUSH
19066: LD_INT 12
19068: PPUSH
19069: LD_INT 1
19071: PPUSH
19072: CALL_OW 56
// end else
19076: GO 19114
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19078: LD_INT 700
19080: PPUSH
19081: LD_INT 1225
19083: PPUSH
19084: CALL_OW 12
19088: PPUSH
19089: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19093: LD_INT 1
19095: PPUSH
19096: LD_INT 5
19098: PPUSH
19099: CALL_OW 12
19103: PPUSH
19104: LD_INT 14
19106: PPUSH
19107: LD_INT 1
19109: PPUSH
19110: CALL_OW 55
// end ; if Prob ( 50 ) then
19114: LD_INT 50
19116: PPUSH
19117: CALL_OW 13
19121: IFFALSE 19167
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19123: LD_INT 700
19125: PPUSH
19126: LD_INT 1050
19128: PPUSH
19129: CALL_OW 12
19133: PPUSH
19134: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19138: LD_INT 1
19140: PPUSH
19141: LD_INT 5
19143: PPUSH
19144: CALL_OW 12
19148: PPUSH
19149: LD_INT 181
19151: PPUSH
19152: LD_INT 218
19154: PPUSH
19155: LD_INT 16
19157: PPUSH
19158: LD_INT 1
19160: PPUSH
19161: CALL_OW 56
// end else
19165: GO 19239
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19167: LD_INT 350
19169: PPUSH
19170: LD_INT 525
19172: PPUSH
19173: CALL_OW 12
19177: PPUSH
19178: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19182: LD_INT 1
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 13
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19203: LD_INT 350
19205: PPUSH
19206: LD_INT 700
19208: PPUSH
19209: CALL_OW 12
19213: PPUSH
19214: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19218: LD_INT 1
19220: PPUSH
19221: LD_INT 5
19223: PPUSH
19224: CALL_OW 12
19228: PPUSH
19229: LD_INT 33
19231: PPUSH
19232: LD_INT 1
19234: PPUSH
19235: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19239: LD_INT 65
19241: PUSH
19242: LD_INT 62
19244: PUSH
19245: LD_INT 55
19247: PUSH
19248: LD_INT 50
19250: PUSH
19251: EMPTY
19252: LIST
19253: LIST
19254: LIST
19255: LIST
19256: PUSH
19257: LD_OWVAR 67
19261: ARRAY
19262: PPUSH
19263: CALL_OW 13
19267: IFFALSE 19313
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19269: LD_INT 525
19271: PPUSH
19272: LD_INT 875
19274: PPUSH
19275: CALL_OW 12
19279: PPUSH
19280: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19284: LD_INT 1
19286: PPUSH
19287: LD_INT 5
19289: PPUSH
19290: CALL_OW 12
19294: PPUSH
19295: LD_INT 294
19297: PPUSH
19298: LD_INT 211
19300: PPUSH
19301: LD_INT 30
19303: PPUSH
19304: LD_INT 1
19306: PPUSH
19307: CALL_OW 56
// end else
19311: GO 19355
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
19313: LD_INT 420
19315: PPUSH
19316: LD_INT 770
19318: PPUSH
19319: CALL_OW 12
19323: PPUSH
19324: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19328: LD_INT 1
19330: PPUSH
19331: LD_INT 5
19333: PPUSH
19334: CALL_OW 12
19338: PPUSH
19339: LD_INT 294
19341: PPUSH
19342: LD_INT 211
19344: PPUSH
19345: LD_INT 30
19347: PPUSH
19348: LD_INT 1
19350: PPUSH
19351: CALL_OW 56
// end ; if time > 2 2$20 then
19355: LD_VAR 0 1
19359: PUSH
19360: LD_INT 4900
19362: GREATER
19363: IFFALSE 19373
// time := 0 0$50 ;
19365: LD_ADDR_VAR 0 1
19369: PUSH
19370: LD_INT 1750
19372: ST_TO_ADDR
// until false ;
19373: LD_INT 0
19375: IFFALSE 18966
// end ;
19377: PPOPN 1
19379: END
// every 0 0$45 trigger tick < 10 10$00 do
19380: LD_OWVAR 1
19384: PUSH
19385: LD_INT 21000
19387: LESS
19388: IFFALSE 19436
19390: GO 19392
19392: DISABLE
// begin enable ;
19393: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19394: LD_INT 350
19396: PPUSH
19397: LD_INT 700
19399: PPUSH
19400: CALL_OW 12
19404: PPUSH
19405: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
19409: LD_INT 3
19411: PPUSH
19412: LD_INT 5
19414: PPUSH
19415: CALL_OW 12
19419: PPUSH
19420: LD_INT 181
19422: PPUSH
19423: LD_INT 13
19425: PPUSH
19426: LD_INT 20
19428: PPUSH
19429: LD_INT 1
19431: PPUSH
19432: CALL_OW 56
// end ; end_of_file
19436: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
19437: LD_INT 0
19439: PPUSH
// SetArtifactRes ( 7 , true ) ;
19440: LD_INT 7
19442: PPUSH
19443: LD_INT 1
19445: PPUSH
19446: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
19450: LD_ADDR_EXP 66
19454: PUSH
19455: EMPTY
19456: PUSH
19457: EMPTY
19458: PUSH
19459: EMPTY
19460: PUSH
19461: EMPTY
19462: LIST
19463: LIST
19464: LIST
19465: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
19466: LD_ADDR_EXP 67
19470: PUSH
19471: LD_INT 1050
19473: PUSH
19474: LD_OWVAR 67
19478: MUL
19479: PUSH
19480: LD_INT 2800
19482: PUSH
19483: LD_OWVAR 67
19487: MUL
19488: PUSH
19489: LD_INT 1
19491: NEG
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: LIST
19497: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
19498: LD_ADDR_EXP 68
19502: PUSH
19503: LD_INT 10
19505: PUSH
19506: LD_INT 35
19508: PUSH
19509: LD_INT 100
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: LIST
19516: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
19517: LD_ADDR_EXP 69
19521: PUSH
19522: LD_INT 0
19524: PUSH
19525: LD_INT 0
19527: PUSH
19528: LD_INT 0
19530: PUSH
19531: EMPTY
19532: LIST
19533: LIST
19534: LIST
19535: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
19536: LD_ADDR_EXP 71
19540: PUSH
19541: LD_INT 300
19543: PUSH
19544: LD_INT 500
19546: PUSH
19547: LD_INT 800
19549: PUSH
19550: EMPTY
19551: LIST
19552: LIST
19553: LIST
19554: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
19555: LD_ADDR_EXP 72
19559: PUSH
19560: LD_INT 0
19562: PUSH
19563: LD_INT 0
19565: PUSH
19566: LD_INT 0
19568: PUSH
19569: EMPTY
19570: LIST
19571: LIST
19572: LIST
19573: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
19574: LD_ADDR_EXP 73
19578: PUSH
19579: LD_INT 0
19581: PUSH
19582: LD_INT 0
19584: PUSH
19585: LD_INT 0
19587: PUSH
19588: EMPTY
19589: LIST
19590: LIST
19591: LIST
19592: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
19593: LD_ADDR_EXP 70
19597: PUSH
19598: LD_INT 0
19600: PUSH
19601: LD_INT 0
19603: PUSH
19604: LD_INT 0
19606: PUSH
19607: EMPTY
19608: LIST
19609: LIST
19610: LIST
19611: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
19612: LD_ADDR_EXP 74
19616: PUSH
19617: LD_INT 4
19619: PUSH
19620: LD_INT 3
19622: PUSH
19623: LD_INT 1
19625: PUSH
19626: EMPTY
19627: LIST
19628: LIST
19629: LIST
19630: PUSH
19631: LD_INT 5
19633: PUSH
19634: LD_INT 4
19636: PUSH
19637: LD_INT 2
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: LIST
19644: PUSH
19645: LD_INT 6
19647: PUSH
19648: LD_INT 3
19650: PUSH
19651: LD_INT 3
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: LIST
19658: PUSH
19659: EMPTY
19660: LIST
19661: LIST
19662: LIST
19663: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
19664: LD_ADDR_EXP 75
19668: PUSH
19669: LD_INT 0
19671: PUSH
19672: LD_INT 0
19674: PUSH
19675: LD_INT 0
19677: PUSH
19678: EMPTY
19679: LIST
19680: LIST
19681: LIST
19682: ST_TO_ADDR
// end ;
19683: LD_VAR 0 1
19687: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
19688: LD_INT 24
19690: PPUSH
19691: LD_INT 7
19693: PPUSH
19694: CALL_OW 321
19698: PUSH
19699: LD_INT 2
19701: EQUAL
19702: IFFALSE 20628
19704: GO 19706
19706: DISABLE
19707: LD_INT 0
19709: PPUSH
19710: PPUSH
19711: PPUSH
19712: PPUSH
19713: PPUSH
// begin enable ;
19714: ENABLE
// for i = 1 to 3 do
19715: LD_ADDR_VAR 0 1
19719: PUSH
19720: DOUBLE
19721: LD_INT 1
19723: DEC
19724: ST_TO_ADDR
19725: LD_INT 3
19727: PUSH
19728: FOR_TO
19729: IFFALSE 20626
// begin pos := FindArtifact ( i + 2 ) ;
19731: LD_ADDR_VAR 0 2
19735: PUSH
19736: LD_VAR 0 1
19740: PUSH
19741: LD_INT 2
19743: PLUS
19744: PPUSH
19745: CALL_OW 469
19749: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
19750: LD_ADDR_EXP 66
19754: PUSH
19755: LD_EXP 66
19759: PPUSH
19760: LD_VAR 0 1
19764: PPUSH
19765: LD_VAR 0 2
19769: PPUSH
19770: CALL_OW 1
19774: ST_TO_ADDR
// if pos then
19775: LD_VAR 0 2
19779: IFFALSE 20487
// begin case i of 1 :
19781: LD_VAR 0 1
19785: PUSH
19786: LD_INT 1
19788: DOUBLE
19789: EQUAL
19790: IFTRUE 19794
19792: GO 19871
19794: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
19795: LD_ADDR_VAR 0 4
19799: PUSH
19800: LD_INT 22
19802: PUSH
19803: LD_INT 7
19805: PUSH
19806: EMPTY
19807: LIST
19808: LIST
19809: PUSH
19810: LD_INT 23
19812: PUSH
19813: LD_INT 1
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: PUSH
19820: LD_INT 2
19822: PUSH
19823: LD_INT 30
19825: PUSH
19826: LD_INT 8
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: PUSH
19833: LD_INT 30
19835: PUSH
19836: LD_INT 7
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: PUSH
19843: LD_INT 30
19845: PUSH
19846: LD_INT 11
19848: PUSH
19849: EMPTY
19850: LIST
19851: LIST
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: PUSH
19859: EMPTY
19860: LIST
19861: LIST
19862: LIST
19863: PPUSH
19864: CALL_OW 69
19868: ST_TO_ADDR
19869: GO 19979
19871: LD_INT 2
19873: DOUBLE
19874: EQUAL
19875: IFTRUE 19879
19877: GO 19956
19879: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
19880: LD_ADDR_VAR 0 4
19884: PUSH
19885: LD_INT 22
19887: PUSH
19888: LD_INT 7
19890: PUSH
19891: EMPTY
19892: LIST
19893: LIST
19894: PUSH
19895: LD_INT 23
19897: PUSH
19898: LD_INT 3
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PUSH
19905: LD_INT 2
19907: PUSH
19908: LD_INT 30
19910: PUSH
19911: LD_INT 8
19913: PUSH
19914: EMPTY
19915: LIST
19916: LIST
19917: PUSH
19918: LD_INT 30
19920: PUSH
19921: LD_INT 7
19923: PUSH
19924: EMPTY
19925: LIST
19926: LIST
19927: PUSH
19928: LD_INT 30
19930: PUSH
19931: LD_INT 11
19933: PUSH
19934: EMPTY
19935: LIST
19936: LIST
19937: PUSH
19938: EMPTY
19939: LIST
19940: LIST
19941: LIST
19942: LIST
19943: PUSH
19944: EMPTY
19945: LIST
19946: LIST
19947: LIST
19948: PPUSH
19949: CALL_OW 69
19953: ST_TO_ADDR
19954: GO 19979
19956: LD_INT 3
19958: DOUBLE
19959: EQUAL
19960: IFTRUE 19964
19962: GO 19978
19964: POP
// labs := [ alien ] ; end ;
19965: LD_ADDR_VAR 0 4
19969: PUSH
19970: LD_INT 1
19972: PUSH
19973: EMPTY
19974: LIST
19975: ST_TO_ADDR
19976: GO 19979
19978: POP
// if not labs then
19979: LD_VAR 0 4
19983: NOT
19984: IFFALSE 19988
// continue ;
19986: GO 19728
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19988: LD_ADDR_VAR 0 5
19992: PUSH
19993: LD_VAR 0 4
19997: PPUSH
19998: LD_EXP 66
20002: PUSH
20003: LD_VAR 0 1
20007: ARRAY
20008: PUSH
20009: LD_INT 1
20011: ARRAY
20012: PPUSH
20013: LD_EXP 66
20017: PUSH
20018: LD_VAR 0 1
20022: ARRAY
20023: PUSH
20024: LD_INT 2
20026: ARRAY
20027: PPUSH
20028: CALL_OW 73
20032: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
20033: LD_VAR 0 5
20037: NOT
20038: PUSH
20039: LD_VAR 0 5
20043: PUSH
20044: LD_EXP 73
20048: PUSH
20049: LD_VAR 0 1
20053: ARRAY
20054: NONEQUAL
20055: OR
20056: IFFALSE 20161
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20058: LD_INT 7
20060: PPUSH
20061: LD_EXP 74
20065: PUSH
20066: LD_VAR 0 1
20070: ARRAY
20071: PUSH
20072: LD_INT 3
20074: ARRAY
20075: PPUSH
20076: LD_INT 0
20078: PPUSH
20079: LD_EXP 73
20083: PUSH
20084: LD_VAR 0 1
20088: ARRAY
20089: PPUSH
20090: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20094: LD_INT 7
20096: PPUSH
20097: LD_EXP 74
20101: PUSH
20102: LD_VAR 0 1
20106: ARRAY
20107: PUSH
20108: LD_INT 1
20110: ARRAY
20111: PPUSH
20112: LD_INT 0
20114: PPUSH
20115: LD_EXP 73
20119: PUSH
20120: LD_VAR 0 1
20124: ARRAY
20125: PPUSH
20126: CALL_OW 468
// if nearestLab then
20130: LD_VAR 0 5
20134: IFFALSE 20161
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20136: LD_ADDR_EXP 73
20140: PUSH
20141: LD_EXP 73
20145: PPUSH
20146: LD_VAR 0 1
20150: PPUSH
20151: LD_VAR 0 5
20155: PPUSH
20156: CALL_OW 1
20160: ST_TO_ADDR
// end ; if not nearestLab then
20161: LD_VAR 0 5
20165: NOT
20166: IFFALSE 20170
// continue ;
20168: GO 19728
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20170: LD_VAR 0 5
20174: PPUSH
20175: LD_EXP 66
20179: PUSH
20180: LD_VAR 0 1
20184: ARRAY
20185: PUSH
20186: LD_INT 1
20188: ARRAY
20189: PPUSH
20190: LD_EXP 66
20194: PUSH
20195: LD_VAR 0 1
20199: ARRAY
20200: PUSH
20201: LD_INT 2
20203: ARRAY
20204: PPUSH
20205: CALL_OW 297
20209: PUSH
20210: LD_INT 8
20212: LESS
20213: IFFALSE 20410
// begin if not artifactsResearched [ i ] then
20215: LD_EXP 69
20219: PUSH
20220: LD_VAR 0 1
20224: ARRAY
20225: NOT
20226: IFFALSE 20307
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20228: LD_VAR 0 5
20232: PPUSH
20233: CALL_OW 461
20237: PUSH
20238: LD_INT 2
20240: EQUAL
20241: IFFALSE 20275
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20243: LD_INT 7
20245: PPUSH
20246: LD_EXP 74
20250: PUSH
20251: LD_VAR 0 1
20255: ARRAY
20256: PUSH
20257: LD_INT 3
20259: ARRAY
20260: PPUSH
20261: LD_INT 2
20263: PPUSH
20264: LD_VAR 0 5
20268: PPUSH
20269: CALL_OW 468
20273: GO 20305
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20275: LD_INT 7
20277: PPUSH
20278: LD_EXP 74
20282: PUSH
20283: LD_VAR 0 1
20287: ARRAY
20288: PUSH
20289: LD_INT 3
20291: ARRAY
20292: PPUSH
20293: LD_INT 1
20295: PPUSH
20296: LD_VAR 0 5
20300: PPUSH
20301: CALL_OW 468
// end else
20305: GO 20408
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
20307: LD_VAR 0 5
20311: PPUSH
20312: CALL_OW 461
20316: PUSH
20317: LD_INT 2
20319: EQUAL
20320: PUSH
20321: LD_EXP 75
20325: PUSH
20326: LD_VAR 0 1
20330: ARRAY
20331: AND
20332: IFFALSE 20378
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
20334: LD_INT 7
20336: PPUSH
20337: LD_EXP 74
20341: PUSH
20342: LD_VAR 0 1
20346: ARRAY
20347: PUSH
20348: LD_INT 1
20350: ARRAY
20351: PPUSH
20352: LD_EXP 74
20356: PUSH
20357: LD_VAR 0 1
20361: ARRAY
20362: PUSH
20363: LD_INT 2
20365: ARRAY
20366: PPUSH
20367: LD_VAR 0 5
20371: PPUSH
20372: CALL_OW 468
20376: GO 20408
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
20378: LD_INT 7
20380: PPUSH
20381: LD_EXP 74
20385: PUSH
20386: LD_VAR 0 1
20390: ARRAY
20391: PUSH
20392: LD_INT 1
20394: ARRAY
20395: PPUSH
20396: LD_INT 1
20398: PPUSH
20399: LD_VAR 0 5
20403: PPUSH
20404: CALL_OW 468
// end else
20408: GO 20485
// begin if not artifactsResearched [ i ] then
20410: LD_EXP 69
20414: PUSH
20415: LD_VAR 0 1
20419: ARRAY
20420: NOT
20421: IFFALSE 20455
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
20423: LD_INT 7
20425: PPUSH
20426: LD_EXP 74
20430: PUSH
20431: LD_VAR 0 1
20435: ARRAY
20436: PUSH
20437: LD_INT 3
20439: ARRAY
20440: PPUSH
20441: LD_INT 0
20443: PPUSH
20444: LD_VAR 0 5
20448: PPUSH
20449: CALL_OW 468
20453: GO 20485
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
20455: LD_INT 7
20457: PPUSH
20458: LD_EXP 74
20462: PUSH
20463: LD_VAR 0 1
20467: ARRAY
20468: PUSH
20469: LD_INT 1
20471: ARRAY
20472: PPUSH
20473: LD_INT 0
20475: PPUSH
20476: LD_VAR 0 5
20480: PPUSH
20481: CALL_OW 468
// end ; end else
20485: GO 20624
// begin if not artifactsLabs [ i ] then
20487: LD_EXP 73
20491: PUSH
20492: LD_VAR 0 1
20496: ARRAY
20497: NOT
20498: IFFALSE 20502
// continue ;
20500: GO 19728
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20502: LD_INT 7
20504: PPUSH
20505: LD_EXP 74
20509: PUSH
20510: LD_VAR 0 1
20514: ARRAY
20515: PUSH
20516: LD_INT 3
20518: ARRAY
20519: PPUSH
20520: LD_INT 0
20522: PPUSH
20523: LD_EXP 73
20527: PUSH
20528: LD_VAR 0 1
20532: ARRAY
20533: PPUSH
20534: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20538: LD_INT 7
20540: PPUSH
20541: LD_EXP 74
20545: PUSH
20546: LD_VAR 0 1
20550: ARRAY
20551: PUSH
20552: LD_INT 1
20554: ARRAY
20555: PPUSH
20556: LD_INT 0
20558: PPUSH
20559: LD_EXP 73
20563: PUSH
20564: LD_VAR 0 1
20568: ARRAY
20569: PPUSH
20570: CALL_OW 468
// if artifactsLabsWorking [ i ] then
20574: LD_EXP 70
20578: PUSH
20579: LD_VAR 0 1
20583: ARRAY
20584: IFFALSE 20624
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
20586: LD_ADDR_EXP 70
20590: PUSH
20591: LD_EXP 70
20595: PPUSH
20596: LD_VAR 0 1
20600: PPUSH
20601: LD_INT 0
20603: PPUSH
20604: CALL_OW 1
20608: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
20609: LD_EXP 73
20613: PUSH
20614: LD_VAR 0 1
20618: ARRAY
20619: PPUSH
20620: CALL_OW 127
// end ; end ; end ;
20624: GO 19728
20626: POP
20627: POP
// end ;
20628: PPOPN 5
20630: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
20631: LD_INT 0
20633: PPUSH
20634: PPUSH
20635: PPUSH
20636: PPUSH
20637: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
20638: LD_VAR 0 2
20642: PUSH
20643: LD_EXP 74
20647: PUSH
20648: LD_INT 1
20650: ARRAY
20651: PUSH
20652: LD_INT 3
20654: ARRAY
20655: EQUAL
20656: IFFALSE 20779
// begin lab := artifactsLabs [ 1 ] ;
20658: LD_ADDR_VAR 0 6
20662: PUSH
20663: LD_EXP 73
20667: PUSH
20668: LD_INT 1
20670: ARRAY
20671: ST_TO_ADDR
// if not lab then
20672: LD_VAR 0 6
20676: NOT
20677: IFFALSE 20681
// exit ;
20679: GO 21759
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
20681: LD_VAR 0 6
20685: PPUSH
20686: LD_EXP 71
20690: PUSH
20691: LD_INT 1
20693: ARRAY
20694: PPUSH
20695: LD_INT 1
20697: PPUSH
20698: CALL_OW 486
// if artifactsResProgress [ 1 ] then
20702: LD_EXP 72
20706: PUSH
20707: LD_INT 1
20709: ARRAY
20710: IFFALSE 20730
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
20712: LD_VAR 0 6
20716: PPUSH
20717: LD_EXP 72
20721: PUSH
20722: LD_INT 1
20724: ARRAY
20725: PPUSH
20726: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
20730: LD_ADDR_EXP 70
20734: PUSH
20735: LD_EXP 70
20739: PPUSH
20740: LD_INT 1
20742: PPUSH
20743: LD_INT 1
20745: PPUSH
20746: CALL_OW 1
20750: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
20751: LD_INT 7
20753: PPUSH
20754: LD_EXP 74
20758: PUSH
20759: LD_INT 1
20761: ARRAY
20762: PUSH
20763: LD_INT 3
20765: ARRAY
20766: PPUSH
20767: LD_INT 0
20769: PPUSH
20770: LD_VAR 0 6
20774: PPUSH
20775: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
20779: LD_VAR 0 2
20783: PUSH
20784: LD_EXP 74
20788: PUSH
20789: LD_INT 2
20791: ARRAY
20792: PUSH
20793: LD_INT 3
20795: ARRAY
20796: EQUAL
20797: IFFALSE 20920
// begin lab := artifactsLabs [ 2 ] ;
20799: LD_ADDR_VAR 0 6
20803: PUSH
20804: LD_EXP 73
20808: PUSH
20809: LD_INT 2
20811: ARRAY
20812: ST_TO_ADDR
// if not lab then
20813: LD_VAR 0 6
20817: NOT
20818: IFFALSE 20822
// exit ;
20820: GO 21759
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
20822: LD_VAR 0 6
20826: PPUSH
20827: LD_EXP 71
20831: PUSH
20832: LD_INT 2
20834: ARRAY
20835: PPUSH
20836: LD_INT 1
20838: PPUSH
20839: CALL_OW 486
// if artifactsResProgress [ 2 ] then
20843: LD_EXP 72
20847: PUSH
20848: LD_INT 2
20850: ARRAY
20851: IFFALSE 20871
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
20853: LD_VAR 0 6
20857: PPUSH
20858: LD_EXP 72
20862: PUSH
20863: LD_INT 2
20865: ARRAY
20866: PPUSH
20867: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
20871: LD_ADDR_EXP 70
20875: PUSH
20876: LD_EXP 70
20880: PPUSH
20881: LD_INT 2
20883: PPUSH
20884: LD_INT 1
20886: PPUSH
20887: CALL_OW 1
20891: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
20892: LD_INT 7
20894: PPUSH
20895: LD_EXP 74
20899: PUSH
20900: LD_INT 2
20902: ARRAY
20903: PUSH
20904: LD_INT 3
20906: ARRAY
20907: PPUSH
20908: LD_INT 0
20910: PPUSH
20911: LD_VAR 0 6
20915: PPUSH
20916: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20920: LD_VAR 0 2
20924: PUSH
20925: LD_EXP 74
20929: PUSH
20930: LD_INT 3
20932: ARRAY
20933: PUSH
20934: LD_INT 3
20936: ARRAY
20937: EQUAL
20938: IFFALSE 21061
// begin lab := artifactsLabs [ 3 ] ;
20940: LD_ADDR_VAR 0 6
20944: PUSH
20945: LD_EXP 73
20949: PUSH
20950: LD_INT 3
20952: ARRAY
20953: ST_TO_ADDR
// if not lab then
20954: LD_VAR 0 6
20958: NOT
20959: IFFALSE 20963
// exit ;
20961: GO 21759
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20963: LD_VAR 0 6
20967: PPUSH
20968: LD_EXP 71
20972: PUSH
20973: LD_INT 3
20975: ARRAY
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20984: LD_EXP 72
20988: PUSH
20989: LD_INT 3
20991: ARRAY
20992: IFFALSE 21012
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20994: LD_VAR 0 6
20998: PPUSH
20999: LD_EXP 72
21003: PUSH
21004: LD_INT 3
21006: ARRAY
21007: PPUSH
21008: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
21012: LD_ADDR_EXP 70
21016: PUSH
21017: LD_EXP 70
21021: PPUSH
21022: LD_INT 3
21024: PPUSH
21025: LD_INT 1
21027: PPUSH
21028: CALL_OW 1
21032: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
21033: LD_INT 7
21035: PPUSH
21036: LD_EXP 74
21040: PUSH
21041: LD_INT 3
21043: ARRAY
21044: PUSH
21045: LD_INT 3
21047: ARRAY
21048: PPUSH
21049: LD_INT 0
21051: PPUSH
21052: LD_VAR 0 6
21056: PPUSH
21057: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21061: LD_VAR 0 2
21065: PUSH
21066: LD_EXP 74
21070: PUSH
21071: LD_INT 1
21073: ARRAY
21074: PUSH
21075: LD_INT 1
21077: ARRAY
21078: EQUAL
21079: IFFALSE 21237
// begin lab := artifactsLabs [ 1 ] ;
21081: LD_ADDR_VAR 0 6
21085: PUSH
21086: LD_EXP 73
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21095: LD_VAR 0 6
21099: PPUSH
21100: CALL_OW 274
21104: PPUSH
21105: CALL 90370 0 1
21109: PUSH
21110: LD_INT 3
21112: ARRAY
21113: PUSH
21114: LD_EXP 68
21118: PUSH
21119: LD_INT 1
21121: ARRAY
21122: LESS
21123: IFFALSE 21137
// begin HintSpec ( ArtifactCost , 2 ) ;
21125: LD_STRING ArtifactCost
21127: PPUSH
21128: LD_INT 2
21130: PPUSH
21131: CALL_OW 338
// exit ;
21135: GO 21759
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21137: LD_ADDR_EXP 75
21141: PUSH
21142: LD_EXP 75
21146: PPUSH
21147: LD_INT 1
21149: PPUSH
21150: LD_INT 0
21152: PPUSH
21153: CALL_OW 1
21157: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21158: LD_VAR 0 3
21162: PPUSH
21163: LD_VAR 0 4
21167: PPUSH
21168: LD_INT 7
21170: PPUSH
21171: LD_INT 12
21173: NEG
21174: PPUSH
21175: CALL_OW 330
// wait ( 0 0$30 ) ;
21179: LD_INT 1050
21181: PPUSH
21182: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21186: LD_VAR 0 3
21190: PPUSH
21191: LD_VAR 0 4
21195: PPUSH
21196: LD_INT 7
21198: PPUSH
21199: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21203: LD_EXP 67
21207: PUSH
21208: LD_INT 1
21210: ARRAY
21211: PPUSH
21212: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21216: LD_ADDR_EXP 75
21220: PUSH
21221: LD_EXP 75
21225: PPUSH
21226: LD_INT 1
21228: PPUSH
21229: LD_INT 1
21231: PPUSH
21232: CALL_OW 1
21236: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
21237: LD_VAR 0 2
21241: PUSH
21242: LD_EXP 74
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PUSH
21251: LD_INT 1
21253: ARRAY
21254: EQUAL
21255: IFFALSE 21492
// begin lab := artifactsLabs [ 2 ] ;
21257: LD_ADDR_VAR 0 6
21261: PUSH
21262: LD_EXP 73
21266: PUSH
21267: LD_INT 2
21269: ARRAY
21270: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
21271: LD_VAR 0 3
21275: PUSH
21276: LD_INT 81
21278: PUSH
21279: LD_INT 7
21281: PUSH
21282: EMPTY
21283: LIST
21284: LIST
21285: PUSH
21286: LD_INT 2
21288: PUSH
21289: LD_INT 32
21291: PUSH
21292: LD_INT 3
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: PUSH
21299: LD_INT 30
21301: PUSH
21302: LD_INT 28
21304: PUSH
21305: EMPTY
21306: LIST
21307: LIST
21308: PUSH
21309: LD_INT 30
21311: PUSH
21312: LD_INT 30
21314: PUSH
21315: EMPTY
21316: LIST
21317: LIST
21318: PUSH
21319: LD_INT 35
21321: PUSH
21322: LD_INT 49
21324: PUSH
21325: EMPTY
21326: LIST
21327: LIST
21328: PUSH
21329: LD_INT 34
21331: PUSH
21332: LD_INT 49
21334: PUSH
21335: EMPTY
21336: LIST
21337: LIST
21338: PUSH
21339: LD_INT 30
21341: PUSH
21342: LD_INT 21
21344: PUSH
21345: EMPTY
21346: LIST
21347: LIST
21348: PUSH
21349: EMPTY
21350: LIST
21351: LIST
21352: LIST
21353: LIST
21354: LIST
21355: LIST
21356: LIST
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: PPUSH
21362: CALL_OW 69
21366: IN
21367: NOT
21368: IFFALSE 21372
// exit ;
21370: GO 21759
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
21372: LD_VAR 0 6
21376: PPUSH
21377: CALL_OW 274
21381: PPUSH
21382: CALL 90370 0 1
21386: PUSH
21387: LD_INT 3
21389: ARRAY
21390: PUSH
21391: LD_EXP 68
21395: PUSH
21396: LD_INT 2
21398: ARRAY
21399: LESS
21400: IFFALSE 21414
// begin HintSpec ( ArtifactCost , 2 ) ;
21402: LD_STRING ArtifactCost
21404: PPUSH
21405: LD_INT 2
21407: PPUSH
21408: CALL_OW 338
// exit ;
21412: GO 21759
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
21414: LD_ADDR_EXP 75
21418: PUSH
21419: LD_EXP 75
21423: PPUSH
21424: LD_INT 2
21426: PPUSH
21427: LD_INT 0
21429: PPUSH
21430: CALL_OW 1
21434: ST_TO_ADDR
// KillUnit ( x ) ;
21435: LD_VAR 0 3
21439: PPUSH
21440: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
21444: LD_ADDR_EXP 16
21448: PUSH
21449: LD_EXP 16
21453: PUSH
21454: LD_INT 1
21456: PLUS
21457: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
21458: LD_EXP 67
21462: PUSH
21463: LD_INT 2
21465: ARRAY
21466: PPUSH
21467: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
21471: LD_ADDR_EXP 75
21475: PUSH
21476: LD_EXP 75
21480: PPUSH
21481: LD_INT 2
21483: PPUSH
21484: LD_INT 1
21486: PPUSH
21487: CALL_OW 1
21491: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
21492: LD_VAR 0 2
21496: PUSH
21497: LD_EXP 74
21501: PUSH
21502: LD_INT 3
21504: ARRAY
21505: PUSH
21506: LD_INT 1
21508: ARRAY
21509: EQUAL
21510: IFFALSE 21759
// begin lab := artifactsLabs [ 3 ] ;
21512: LD_ADDR_VAR 0 6
21516: PUSH
21517: LD_EXP 73
21521: PUSH
21522: LD_INT 3
21524: ARRAY
21525: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
21526: LD_VAR 0 6
21530: PPUSH
21531: CALL_OW 274
21535: PPUSH
21536: CALL 90370 0 1
21540: PUSH
21541: LD_INT 3
21543: ARRAY
21544: PUSH
21545: LD_EXP 68
21549: PUSH
21550: LD_INT 3
21552: ARRAY
21553: LESS
21554: IFFALSE 21568
// begin HintSpec ( ArtifactCost , 2 ) ;
21556: LD_STRING ArtifactCost
21558: PPUSH
21559: LD_INT 2
21561: PPUSH
21562: CALL_OW 338
// exit ;
21566: GO 21759
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
21568: LD_INT 37
21570: PPUSH
21571: LD_INT 1
21573: PPUSH
21574: CALL_OW 424
// time := 0 0$30 ;
21578: LD_ADDR_VAR 0 7
21582: PUSH
21583: LD_INT 1050
21585: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
21586: LD_ADDR_EXP 75
21590: PUSH
21591: LD_EXP 75
21595: PPUSH
21596: LD_INT 3
21598: PPUSH
21599: LD_INT 0
21601: PPUSH
21602: CALL_OW 1
21606: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
21607: LD_ADDR_OWVAR 47
21611: PUSH
21612: LD_STRING #Am15a-1
21614: PUSH
21615: LD_VAR 0 7
21619: PUSH
21620: EMPTY
21621: LIST
21622: LIST
21623: ST_TO_ADDR
// wait ( 0 0$1 ) ;
21624: LD_INT 35
21626: PPUSH
21627: CALL_OW 67
// time := time - 0 0$1 ;
21631: LD_ADDR_VAR 0 7
21635: PUSH
21636: LD_VAR 0 7
21640: PUSH
21641: LD_INT 35
21643: MINUS
21644: ST_TO_ADDR
// until time = 0 0$00 ;
21645: LD_VAR 0 7
21649: PUSH
21650: LD_INT 0
21652: EQUAL
21653: IFFALSE 21607
// display_strings :=  ;
21655: LD_ADDR_OWVAR 47
21659: PUSH
21660: LD_STRING 
21662: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
21663: LD_INT 37
21665: PPUSH
21666: LD_INT 0
21668: PPUSH
21669: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
21673: LD_ADDR_VAR 0 8
21677: PUSH
21678: LD_INT 37
21680: PPUSH
21681: LD_INT 3
21683: PUSH
21684: LD_INT 21
21686: PUSH
21687: LD_INT 3
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: PPUSH
21698: CALL_OW 70
21702: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
21703: LD_VAR 0 3
21707: PPUSH
21708: LD_VAR 0 4
21712: PPUSH
21713: CALL_OW 84
// for un in list do
21717: LD_ADDR_VAR 0 9
21721: PUSH
21722: LD_VAR 0 8
21726: PUSH
21727: FOR_IN
21728: IFFALSE 21757
// TeleportUnit ( un , x , y , 12 , true ) ;
21730: LD_VAR 0 9
21734: PPUSH
21735: LD_VAR 0 3
21739: PPUSH
21740: LD_VAR 0 4
21744: PPUSH
21745: LD_INT 12
21747: PPUSH
21748: LD_INT 1
21750: PPUSH
21751: CALL_OW 483
21755: GO 21727
21757: POP
21758: POP
// end ; end ;
21759: PPOPN 9
21761: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
21762: LD_INT 0
21764: PPUSH
21765: PPUSH
// begin labNum := 0 ;
21766: LD_ADDR_VAR 0 4
21770: PUSH
21771: LD_INT 0
21773: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21774: LD_ADDR_VAR 0 3
21778: PUSH
21779: DOUBLE
21780: LD_INT 1
21782: DEC
21783: ST_TO_ADDR
21784: LD_EXP 73
21788: PUSH
21789: FOR_TO
21790: IFFALSE 21824
// if artifactsLabs [ i ] = lab then
21792: LD_EXP 73
21796: PUSH
21797: LD_VAR 0 3
21801: ARRAY
21802: PUSH
21803: LD_VAR 0 1
21807: EQUAL
21808: IFFALSE 21822
// begin labNum := i ;
21810: LD_ADDR_VAR 0 4
21814: PUSH
21815: LD_VAR 0 3
21819: ST_TO_ADDR
// break ;
21820: GO 21824
// end ;
21822: GO 21789
21824: POP
21825: POP
// if not labNum then
21826: LD_VAR 0 4
21830: NOT
21831: IFFALSE 21835
// exit ;
21833: GO 21913
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
21835: LD_INT 7
21837: PPUSH
21838: LD_EXP 74
21842: PUSH
21843: LD_VAR 0 4
21847: ARRAY
21848: PUSH
21849: LD_INT 3
21851: ARRAY
21852: PPUSH
21853: LD_INT 2
21855: PPUSH
21856: LD_VAR 0 1
21860: PPUSH
21861: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
21865: LD_ADDR_EXP 72
21869: PUSH
21870: LD_EXP 72
21874: PPUSH
21875: LD_VAR 0 4
21879: PPUSH
21880: LD_VAR 0 2
21884: PPUSH
21885: CALL_OW 1
21889: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
21890: LD_ADDR_EXP 70
21894: PUSH
21895: LD_EXP 70
21899: PPUSH
21900: LD_VAR 0 4
21904: PPUSH
21905: LD_INT 0
21907: PPUSH
21908: CALL_OW 1
21912: ST_TO_ADDR
// end ;
21913: PPOPN 4
21915: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21916: LD_INT 0
21918: PPUSH
21919: PPUSH
// begin labNum := 0 ;
21920: LD_ADDR_VAR 0 3
21924: PUSH
21925: LD_INT 0
21927: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21928: LD_ADDR_VAR 0 2
21932: PUSH
21933: DOUBLE
21934: LD_INT 1
21936: DEC
21937: ST_TO_ADDR
21938: LD_EXP 73
21942: PUSH
21943: FOR_TO
21944: IFFALSE 21978
// if artifactsLabs [ i ] = lab then
21946: LD_EXP 73
21950: PUSH
21951: LD_VAR 0 2
21955: ARRAY
21956: PUSH
21957: LD_VAR 0 1
21961: EQUAL
21962: IFFALSE 21976
// begin labNum := i ;
21964: LD_ADDR_VAR 0 3
21968: PUSH
21969: LD_VAR 0 2
21973: ST_TO_ADDR
// break ;
21974: GO 21978
// end ;
21976: GO 21943
21978: POP
21979: POP
// if not labNum then
21980: LD_VAR 0 3
21984: NOT
21985: IFFALSE 21989
// exit ;
21987: GO 22151
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21989: LD_INT 7
21991: PPUSH
21992: LD_EXP 74
21996: PUSH
21997: LD_VAR 0 3
22001: ARRAY
22002: PUSH
22003: LD_INT 3
22005: ARRAY
22006: PPUSH
22007: LD_INT 0
22009: PPUSH
22010: LD_VAR 0 1
22014: PPUSH
22015: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
22019: LD_ADDR_EXP 69
22023: PUSH
22024: LD_EXP 69
22028: PPUSH
22029: LD_VAR 0 3
22033: PPUSH
22034: LD_INT 1
22036: PPUSH
22037: CALL_OW 1
22041: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22042: LD_ADDR_EXP 75
22046: PUSH
22047: LD_EXP 75
22051: PPUSH
22052: LD_VAR 0 3
22056: PPUSH
22057: LD_INT 1
22059: PPUSH
22060: CALL_OW 1
22064: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22065: LD_ADDR_EXP 70
22069: PUSH
22070: LD_EXP 70
22074: PPUSH
22075: LD_VAR 0 3
22079: PPUSH
22080: LD_INT 0
22082: PPUSH
22083: CALL_OW 1
22087: ST_TO_ADDR
// case labNum of 1 :
22088: LD_VAR 0 3
22092: PUSH
22093: LD_INT 1
22095: DOUBLE
22096: EQUAL
22097: IFTRUE 22101
22099: GO 22112
22101: POP
// artifactIResearched := true ; 2 :
22102: LD_ADDR_EXP 12
22106: PUSH
22107: LD_INT 1
22109: ST_TO_ADDR
22110: GO 22151
22112: LD_INT 2
22114: DOUBLE
22115: EQUAL
22116: IFTRUE 22120
22118: GO 22131
22120: POP
// artifactIIResearched := true ; 3 :
22121: LD_ADDR_EXP 13
22125: PUSH
22126: LD_INT 1
22128: ST_TO_ADDR
22129: GO 22151
22131: LD_INT 3
22133: DOUBLE
22134: EQUAL
22135: IFTRUE 22139
22137: GO 22150
22139: POP
// artifactIIIResearched := true ; end ;
22140: LD_ADDR_EXP 14
22144: PUSH
22145: LD_INT 1
22147: ST_TO_ADDR
22148: GO 22151
22150: POP
// end ; end_of_file
22151: PPOPN 3
22153: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
22154: LD_INT 0
22156: PPUSH
22157: PPUSH
// skirmish := false ;
22158: LD_ADDR_EXP 76
22162: PUSH
22163: LD_INT 0
22165: ST_TO_ADDR
// debug_mc := false ;
22166: LD_ADDR_EXP 77
22170: PUSH
22171: LD_INT 0
22173: ST_TO_ADDR
// mc_bases := [ ] ;
22174: LD_ADDR_EXP 78
22178: PUSH
22179: EMPTY
22180: ST_TO_ADDR
// mc_sides := [ ] ;
22181: LD_ADDR_EXP 104
22185: PUSH
22186: EMPTY
22187: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
22188: LD_ADDR_EXP 79
22192: PUSH
22193: EMPTY
22194: ST_TO_ADDR
// mc_building_repairs := [ ] ;
22195: LD_ADDR_EXP 80
22199: PUSH
22200: EMPTY
22201: ST_TO_ADDR
// mc_need_heal := [ ] ;
22202: LD_ADDR_EXP 81
22206: PUSH
22207: EMPTY
22208: ST_TO_ADDR
// mc_healers := [ ] ;
22209: LD_ADDR_EXP 82
22213: PUSH
22214: EMPTY
22215: ST_TO_ADDR
// mc_build_list := [ ] ;
22216: LD_ADDR_EXP 83
22220: PUSH
22221: EMPTY
22222: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
22223: LD_ADDR_EXP 110
22227: PUSH
22228: EMPTY
22229: ST_TO_ADDR
// mc_builders := [ ] ;
22230: LD_ADDR_EXP 84
22234: PUSH
22235: EMPTY
22236: ST_TO_ADDR
// mc_construct_list := [ ] ;
22237: LD_ADDR_EXP 85
22241: PUSH
22242: EMPTY
22243: ST_TO_ADDR
// mc_turret_list := [ ] ;
22244: LD_ADDR_EXP 86
22248: PUSH
22249: EMPTY
22250: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
22251: LD_ADDR_EXP 87
22255: PUSH
22256: EMPTY
22257: ST_TO_ADDR
// mc_miners := [ ] ;
22258: LD_ADDR_EXP 92
22262: PUSH
22263: EMPTY
22264: ST_TO_ADDR
// mc_mines := [ ] ;
22265: LD_ADDR_EXP 91
22269: PUSH
22270: EMPTY
22271: ST_TO_ADDR
// mc_minefields := [ ] ;
22272: LD_ADDR_EXP 93
22276: PUSH
22277: EMPTY
22278: ST_TO_ADDR
// mc_crates := [ ] ;
22279: LD_ADDR_EXP 94
22283: PUSH
22284: EMPTY
22285: ST_TO_ADDR
// mc_crates_collector := [ ] ;
22286: LD_ADDR_EXP 95
22290: PUSH
22291: EMPTY
22292: ST_TO_ADDR
// mc_crates_area := [ ] ;
22293: LD_ADDR_EXP 96
22297: PUSH
22298: EMPTY
22299: ST_TO_ADDR
// mc_vehicles := [ ] ;
22300: LD_ADDR_EXP 97
22304: PUSH
22305: EMPTY
22306: ST_TO_ADDR
// mc_attack := [ ] ;
22307: LD_ADDR_EXP 98
22311: PUSH
22312: EMPTY
22313: ST_TO_ADDR
// mc_produce := [ ] ;
22314: LD_ADDR_EXP 99
22318: PUSH
22319: EMPTY
22320: ST_TO_ADDR
// mc_defender := [ ] ;
22321: LD_ADDR_EXP 100
22325: PUSH
22326: EMPTY
22327: ST_TO_ADDR
// mc_parking := [ ] ;
22328: LD_ADDR_EXP 102
22332: PUSH
22333: EMPTY
22334: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
22335: LD_ADDR_EXP 88
22339: PUSH
22340: EMPTY
22341: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
22342: LD_ADDR_EXP 90
22346: PUSH
22347: EMPTY
22348: ST_TO_ADDR
// mc_scan := [ ] ;
22349: LD_ADDR_EXP 101
22353: PUSH
22354: EMPTY
22355: ST_TO_ADDR
// mc_scan_area := [ ] ;
22356: LD_ADDR_EXP 103
22360: PUSH
22361: EMPTY
22362: ST_TO_ADDR
// mc_tech := [ ] ;
22363: LD_ADDR_EXP 105
22367: PUSH
22368: EMPTY
22369: ST_TO_ADDR
// mc_class := [ ] ;
22370: LD_ADDR_EXP 119
22374: PUSH
22375: EMPTY
22376: ST_TO_ADDR
// mc_class_case_use := [ ] ;
22377: LD_ADDR_EXP 120
22381: PUSH
22382: EMPTY
22383: ST_TO_ADDR
// mc_is_defending := [ ] ;
22384: LD_ADDR_EXP 121
22388: PUSH
22389: EMPTY
22390: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
22391: LD_ADDR_EXP 112
22395: PUSH
22396: EMPTY
22397: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
22398: LD_ADDR_EXP 122
22402: PUSH
22403: LD_INT 0
22405: ST_TO_ADDR
// end ;
22406: LD_VAR 0 1
22410: RET
// export function MC_Kill ( base ) ; begin
22411: LD_INT 0
22413: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
22414: LD_ADDR_EXP 78
22418: PUSH
22419: LD_EXP 78
22423: PPUSH
22424: LD_VAR 0 1
22428: PPUSH
22429: EMPTY
22430: PPUSH
22431: CALL_OW 1
22435: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22436: LD_ADDR_EXP 79
22440: PUSH
22441: LD_EXP 79
22445: PPUSH
22446: LD_VAR 0 1
22450: PPUSH
22451: EMPTY
22452: PPUSH
22453: CALL_OW 1
22457: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22458: LD_ADDR_EXP 80
22462: PUSH
22463: LD_EXP 80
22467: PPUSH
22468: LD_VAR 0 1
22472: PPUSH
22473: EMPTY
22474: PPUSH
22475: CALL_OW 1
22479: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22480: LD_ADDR_EXP 81
22484: PUSH
22485: LD_EXP 81
22489: PPUSH
22490: LD_VAR 0 1
22494: PPUSH
22495: EMPTY
22496: PPUSH
22497: CALL_OW 1
22501: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22502: LD_ADDR_EXP 82
22506: PUSH
22507: LD_EXP 82
22511: PPUSH
22512: LD_VAR 0 1
22516: PPUSH
22517: EMPTY
22518: PPUSH
22519: CALL_OW 1
22523: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22524: LD_ADDR_EXP 83
22528: PUSH
22529: LD_EXP 83
22533: PPUSH
22534: LD_VAR 0 1
22538: PPUSH
22539: EMPTY
22540: PPUSH
22541: CALL_OW 1
22545: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22546: LD_ADDR_EXP 84
22550: PUSH
22551: LD_EXP 84
22555: PPUSH
22556: LD_VAR 0 1
22560: PPUSH
22561: EMPTY
22562: PPUSH
22563: CALL_OW 1
22567: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22568: LD_ADDR_EXP 85
22572: PUSH
22573: LD_EXP 85
22577: PPUSH
22578: LD_VAR 0 1
22582: PPUSH
22583: EMPTY
22584: PPUSH
22585: CALL_OW 1
22589: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22590: LD_ADDR_EXP 86
22594: PUSH
22595: LD_EXP 86
22599: PPUSH
22600: LD_VAR 0 1
22604: PPUSH
22605: EMPTY
22606: PPUSH
22607: CALL_OW 1
22611: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22612: LD_ADDR_EXP 87
22616: PUSH
22617: LD_EXP 87
22621: PPUSH
22622: LD_VAR 0 1
22626: PPUSH
22627: EMPTY
22628: PPUSH
22629: CALL_OW 1
22633: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22634: LD_ADDR_EXP 88
22638: PUSH
22639: LD_EXP 88
22643: PPUSH
22644: LD_VAR 0 1
22648: PPUSH
22649: EMPTY
22650: PPUSH
22651: CALL_OW 1
22655: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22656: LD_ADDR_EXP 89
22660: PUSH
22661: LD_EXP 89
22665: PPUSH
22666: LD_VAR 0 1
22670: PPUSH
22671: LD_INT 0
22673: PPUSH
22674: CALL_OW 1
22678: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22679: LD_ADDR_EXP 90
22683: PUSH
22684: LD_EXP 90
22688: PPUSH
22689: LD_VAR 0 1
22693: PPUSH
22694: EMPTY
22695: PPUSH
22696: CALL_OW 1
22700: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22701: LD_ADDR_EXP 91
22705: PUSH
22706: LD_EXP 91
22710: PPUSH
22711: LD_VAR 0 1
22715: PPUSH
22716: EMPTY
22717: PPUSH
22718: CALL_OW 1
22722: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22723: LD_ADDR_EXP 92
22727: PUSH
22728: LD_EXP 92
22732: PPUSH
22733: LD_VAR 0 1
22737: PPUSH
22738: EMPTY
22739: PPUSH
22740: CALL_OW 1
22744: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22745: LD_ADDR_EXP 93
22749: PUSH
22750: LD_EXP 93
22754: PPUSH
22755: LD_VAR 0 1
22759: PPUSH
22760: EMPTY
22761: PPUSH
22762: CALL_OW 1
22766: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22767: LD_ADDR_EXP 94
22771: PUSH
22772: LD_EXP 94
22776: PPUSH
22777: LD_VAR 0 1
22781: PPUSH
22782: EMPTY
22783: PPUSH
22784: CALL_OW 1
22788: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22789: LD_ADDR_EXP 95
22793: PUSH
22794: LD_EXP 95
22798: PPUSH
22799: LD_VAR 0 1
22803: PPUSH
22804: EMPTY
22805: PPUSH
22806: CALL_OW 1
22810: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22811: LD_ADDR_EXP 96
22815: PUSH
22816: LD_EXP 96
22820: PPUSH
22821: LD_VAR 0 1
22825: PPUSH
22826: EMPTY
22827: PPUSH
22828: CALL_OW 1
22832: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22833: LD_ADDR_EXP 97
22837: PUSH
22838: LD_EXP 97
22842: PPUSH
22843: LD_VAR 0 1
22847: PPUSH
22848: EMPTY
22849: PPUSH
22850: CALL_OW 1
22854: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22855: LD_ADDR_EXP 98
22859: PUSH
22860: LD_EXP 98
22864: PPUSH
22865: LD_VAR 0 1
22869: PPUSH
22870: EMPTY
22871: PPUSH
22872: CALL_OW 1
22876: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22877: LD_ADDR_EXP 99
22881: PUSH
22882: LD_EXP 99
22886: PPUSH
22887: LD_VAR 0 1
22891: PPUSH
22892: EMPTY
22893: PPUSH
22894: CALL_OW 1
22898: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22899: LD_ADDR_EXP 100
22903: PUSH
22904: LD_EXP 100
22908: PPUSH
22909: LD_VAR 0 1
22913: PPUSH
22914: EMPTY
22915: PPUSH
22916: CALL_OW 1
22920: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22921: LD_ADDR_EXP 101
22925: PUSH
22926: LD_EXP 101
22930: PPUSH
22931: LD_VAR 0 1
22935: PPUSH
22936: EMPTY
22937: PPUSH
22938: CALL_OW 1
22942: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22943: LD_ADDR_EXP 102
22947: PUSH
22948: LD_EXP 102
22952: PPUSH
22953: LD_VAR 0 1
22957: PPUSH
22958: EMPTY
22959: PPUSH
22960: CALL_OW 1
22964: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22965: LD_ADDR_EXP 103
22969: PUSH
22970: LD_EXP 103
22974: PPUSH
22975: LD_VAR 0 1
22979: PPUSH
22980: EMPTY
22981: PPUSH
22982: CALL_OW 1
22986: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22987: LD_ADDR_EXP 105
22991: PUSH
22992: LD_EXP 105
22996: PPUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: EMPTY
23003: PPUSH
23004: CALL_OW 1
23008: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23009: LD_ADDR_EXP 107
23013: PUSH
23014: LD_EXP 107
23018: PPUSH
23019: LD_VAR 0 1
23023: PPUSH
23024: EMPTY
23025: PPUSH
23026: CALL_OW 1
23030: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23031: LD_ADDR_EXP 108
23035: PUSH
23036: LD_EXP 108
23040: PPUSH
23041: LD_VAR 0 1
23045: PPUSH
23046: EMPTY
23047: PPUSH
23048: CALL_OW 1
23052: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23053: LD_ADDR_EXP 109
23057: PUSH
23058: LD_EXP 109
23062: PPUSH
23063: LD_VAR 0 1
23067: PPUSH
23068: EMPTY
23069: PPUSH
23070: CALL_OW 1
23074: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23075: LD_ADDR_EXP 110
23079: PUSH
23080: LD_EXP 110
23084: PPUSH
23085: LD_VAR 0 1
23089: PPUSH
23090: EMPTY
23091: PPUSH
23092: CALL_OW 1
23096: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23097: LD_ADDR_EXP 111
23101: PUSH
23102: LD_EXP 111
23106: PPUSH
23107: LD_VAR 0 1
23111: PPUSH
23112: EMPTY
23113: PPUSH
23114: CALL_OW 1
23118: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23119: LD_ADDR_EXP 112
23123: PUSH
23124: LD_EXP 112
23128: PPUSH
23129: LD_VAR 0 1
23133: PPUSH
23134: EMPTY
23135: PPUSH
23136: CALL_OW 1
23140: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23141: LD_ADDR_EXP 113
23145: PUSH
23146: LD_EXP 113
23150: PPUSH
23151: LD_VAR 0 1
23155: PPUSH
23156: EMPTY
23157: PPUSH
23158: CALL_OW 1
23162: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23163: LD_ADDR_EXP 114
23167: PUSH
23168: LD_EXP 114
23172: PPUSH
23173: LD_VAR 0 1
23177: PPUSH
23178: EMPTY
23179: PPUSH
23180: CALL_OW 1
23184: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23185: LD_ADDR_EXP 115
23189: PUSH
23190: LD_EXP 115
23194: PPUSH
23195: LD_VAR 0 1
23199: PPUSH
23200: EMPTY
23201: PPUSH
23202: CALL_OW 1
23206: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23207: LD_ADDR_EXP 116
23211: PUSH
23212: LD_EXP 116
23216: PPUSH
23217: LD_VAR 0 1
23221: PPUSH
23222: EMPTY
23223: PPUSH
23224: CALL_OW 1
23228: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23229: LD_ADDR_EXP 117
23233: PUSH
23234: LD_EXP 117
23238: PPUSH
23239: LD_VAR 0 1
23243: PPUSH
23244: EMPTY
23245: PPUSH
23246: CALL_OW 1
23250: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23251: LD_ADDR_EXP 118
23255: PUSH
23256: LD_EXP 118
23260: PPUSH
23261: LD_VAR 0 1
23265: PPUSH
23266: EMPTY
23267: PPUSH
23268: CALL_OW 1
23272: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23273: LD_ADDR_EXP 119
23277: PUSH
23278: LD_EXP 119
23282: PPUSH
23283: LD_VAR 0 1
23287: PPUSH
23288: EMPTY
23289: PPUSH
23290: CALL_OW 1
23294: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23295: LD_ADDR_EXP 120
23299: PUSH
23300: LD_EXP 120
23304: PPUSH
23305: LD_VAR 0 1
23309: PPUSH
23310: LD_INT 0
23312: PPUSH
23313: CALL_OW 1
23317: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23318: LD_ADDR_EXP 121
23322: PUSH
23323: LD_EXP 121
23327: PPUSH
23328: LD_VAR 0 1
23332: PPUSH
23333: LD_INT 0
23335: PPUSH
23336: CALL_OW 1
23340: ST_TO_ADDR
// end ;
23341: LD_VAR 0 2
23345: RET
// export function MC_Add ( side , units ) ; var base ; begin
23346: LD_INT 0
23348: PPUSH
23349: PPUSH
// base := mc_bases + 1 ;
23350: LD_ADDR_VAR 0 4
23354: PUSH
23355: LD_EXP 78
23359: PUSH
23360: LD_INT 1
23362: PLUS
23363: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
23364: LD_ADDR_EXP 104
23368: PUSH
23369: LD_EXP 104
23373: PPUSH
23374: LD_VAR 0 4
23378: PPUSH
23379: LD_VAR 0 1
23383: PPUSH
23384: CALL_OW 1
23388: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
23389: LD_ADDR_EXP 78
23393: PUSH
23394: LD_EXP 78
23398: PPUSH
23399: LD_VAR 0 4
23403: PPUSH
23404: LD_VAR 0 2
23408: PPUSH
23409: CALL_OW 1
23413: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23414: LD_ADDR_EXP 79
23418: PUSH
23419: LD_EXP 79
23423: PPUSH
23424: LD_VAR 0 4
23428: PPUSH
23429: EMPTY
23430: PPUSH
23431: CALL_OW 1
23435: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23436: LD_ADDR_EXP 80
23440: PUSH
23441: LD_EXP 80
23445: PPUSH
23446: LD_VAR 0 4
23450: PPUSH
23451: EMPTY
23452: PPUSH
23453: CALL_OW 1
23457: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23458: LD_ADDR_EXP 81
23462: PUSH
23463: LD_EXP 81
23467: PPUSH
23468: LD_VAR 0 4
23472: PPUSH
23473: EMPTY
23474: PPUSH
23475: CALL_OW 1
23479: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23480: LD_ADDR_EXP 82
23484: PUSH
23485: LD_EXP 82
23489: PPUSH
23490: LD_VAR 0 4
23494: PPUSH
23495: EMPTY
23496: PPUSH
23497: CALL_OW 1
23501: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23502: LD_ADDR_EXP 83
23506: PUSH
23507: LD_EXP 83
23511: PPUSH
23512: LD_VAR 0 4
23516: PPUSH
23517: EMPTY
23518: PPUSH
23519: CALL_OW 1
23523: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23524: LD_ADDR_EXP 84
23528: PUSH
23529: LD_EXP 84
23533: PPUSH
23534: LD_VAR 0 4
23538: PPUSH
23539: EMPTY
23540: PPUSH
23541: CALL_OW 1
23545: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23546: LD_ADDR_EXP 85
23550: PUSH
23551: LD_EXP 85
23555: PPUSH
23556: LD_VAR 0 4
23560: PPUSH
23561: EMPTY
23562: PPUSH
23563: CALL_OW 1
23567: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23568: LD_ADDR_EXP 86
23572: PUSH
23573: LD_EXP 86
23577: PPUSH
23578: LD_VAR 0 4
23582: PPUSH
23583: EMPTY
23584: PPUSH
23585: CALL_OW 1
23589: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23590: LD_ADDR_EXP 87
23594: PUSH
23595: LD_EXP 87
23599: PPUSH
23600: LD_VAR 0 4
23604: PPUSH
23605: EMPTY
23606: PPUSH
23607: CALL_OW 1
23611: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23612: LD_ADDR_EXP 88
23616: PUSH
23617: LD_EXP 88
23621: PPUSH
23622: LD_VAR 0 4
23626: PPUSH
23627: EMPTY
23628: PPUSH
23629: CALL_OW 1
23633: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23634: LD_ADDR_EXP 89
23638: PUSH
23639: LD_EXP 89
23643: PPUSH
23644: LD_VAR 0 4
23648: PPUSH
23649: LD_INT 0
23651: PPUSH
23652: CALL_OW 1
23656: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23657: LD_ADDR_EXP 90
23661: PUSH
23662: LD_EXP 90
23666: PPUSH
23667: LD_VAR 0 4
23671: PPUSH
23672: EMPTY
23673: PPUSH
23674: CALL_OW 1
23678: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23679: LD_ADDR_EXP 91
23683: PUSH
23684: LD_EXP 91
23688: PPUSH
23689: LD_VAR 0 4
23693: PPUSH
23694: EMPTY
23695: PPUSH
23696: CALL_OW 1
23700: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23701: LD_ADDR_EXP 92
23705: PUSH
23706: LD_EXP 92
23710: PPUSH
23711: LD_VAR 0 4
23715: PPUSH
23716: EMPTY
23717: PPUSH
23718: CALL_OW 1
23722: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23723: LD_ADDR_EXP 93
23727: PUSH
23728: LD_EXP 93
23732: PPUSH
23733: LD_VAR 0 4
23737: PPUSH
23738: EMPTY
23739: PPUSH
23740: CALL_OW 1
23744: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23745: LD_ADDR_EXP 94
23749: PUSH
23750: LD_EXP 94
23754: PPUSH
23755: LD_VAR 0 4
23759: PPUSH
23760: EMPTY
23761: PPUSH
23762: CALL_OW 1
23766: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23767: LD_ADDR_EXP 95
23771: PUSH
23772: LD_EXP 95
23776: PPUSH
23777: LD_VAR 0 4
23781: PPUSH
23782: EMPTY
23783: PPUSH
23784: CALL_OW 1
23788: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23789: LD_ADDR_EXP 96
23793: PUSH
23794: LD_EXP 96
23798: PPUSH
23799: LD_VAR 0 4
23803: PPUSH
23804: EMPTY
23805: PPUSH
23806: CALL_OW 1
23810: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23811: LD_ADDR_EXP 97
23815: PUSH
23816: LD_EXP 97
23820: PPUSH
23821: LD_VAR 0 4
23825: PPUSH
23826: EMPTY
23827: PPUSH
23828: CALL_OW 1
23832: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23833: LD_ADDR_EXP 98
23837: PUSH
23838: LD_EXP 98
23842: PPUSH
23843: LD_VAR 0 4
23847: PPUSH
23848: EMPTY
23849: PPUSH
23850: CALL_OW 1
23854: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23855: LD_ADDR_EXP 99
23859: PUSH
23860: LD_EXP 99
23864: PPUSH
23865: LD_VAR 0 4
23869: PPUSH
23870: EMPTY
23871: PPUSH
23872: CALL_OW 1
23876: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23877: LD_ADDR_EXP 100
23881: PUSH
23882: LD_EXP 100
23886: PPUSH
23887: LD_VAR 0 4
23891: PPUSH
23892: EMPTY
23893: PPUSH
23894: CALL_OW 1
23898: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23899: LD_ADDR_EXP 101
23903: PUSH
23904: LD_EXP 101
23908: PPUSH
23909: LD_VAR 0 4
23913: PPUSH
23914: EMPTY
23915: PPUSH
23916: CALL_OW 1
23920: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23921: LD_ADDR_EXP 102
23925: PUSH
23926: LD_EXP 102
23930: PPUSH
23931: LD_VAR 0 4
23935: PPUSH
23936: EMPTY
23937: PPUSH
23938: CALL_OW 1
23942: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23943: LD_ADDR_EXP 103
23947: PUSH
23948: LD_EXP 103
23952: PPUSH
23953: LD_VAR 0 4
23957: PPUSH
23958: EMPTY
23959: PPUSH
23960: CALL_OW 1
23964: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23965: LD_ADDR_EXP 105
23969: PUSH
23970: LD_EXP 105
23974: PPUSH
23975: LD_VAR 0 4
23979: PPUSH
23980: EMPTY
23981: PPUSH
23982: CALL_OW 1
23986: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23987: LD_ADDR_EXP 107
23991: PUSH
23992: LD_EXP 107
23996: PPUSH
23997: LD_VAR 0 4
24001: PPUSH
24002: EMPTY
24003: PPUSH
24004: CALL_OW 1
24008: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24009: LD_ADDR_EXP 108
24013: PUSH
24014: LD_EXP 108
24018: PPUSH
24019: LD_VAR 0 4
24023: PPUSH
24024: EMPTY
24025: PPUSH
24026: CALL_OW 1
24030: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24031: LD_ADDR_EXP 109
24035: PUSH
24036: LD_EXP 109
24040: PPUSH
24041: LD_VAR 0 4
24045: PPUSH
24046: EMPTY
24047: PPUSH
24048: CALL_OW 1
24052: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24053: LD_ADDR_EXP 110
24057: PUSH
24058: LD_EXP 110
24062: PPUSH
24063: LD_VAR 0 4
24067: PPUSH
24068: EMPTY
24069: PPUSH
24070: CALL_OW 1
24074: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24075: LD_ADDR_EXP 111
24079: PUSH
24080: LD_EXP 111
24084: PPUSH
24085: LD_VAR 0 4
24089: PPUSH
24090: EMPTY
24091: PPUSH
24092: CALL_OW 1
24096: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24097: LD_ADDR_EXP 112
24101: PUSH
24102: LD_EXP 112
24106: PPUSH
24107: LD_VAR 0 4
24111: PPUSH
24112: EMPTY
24113: PPUSH
24114: CALL_OW 1
24118: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24119: LD_ADDR_EXP 113
24123: PUSH
24124: LD_EXP 113
24128: PPUSH
24129: LD_VAR 0 4
24133: PPUSH
24134: EMPTY
24135: PPUSH
24136: CALL_OW 1
24140: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24141: LD_ADDR_EXP 114
24145: PUSH
24146: LD_EXP 114
24150: PPUSH
24151: LD_VAR 0 4
24155: PPUSH
24156: EMPTY
24157: PPUSH
24158: CALL_OW 1
24162: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24163: LD_ADDR_EXP 115
24167: PUSH
24168: LD_EXP 115
24172: PPUSH
24173: LD_VAR 0 4
24177: PPUSH
24178: EMPTY
24179: PPUSH
24180: CALL_OW 1
24184: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24185: LD_ADDR_EXP 116
24189: PUSH
24190: LD_EXP 116
24194: PPUSH
24195: LD_VAR 0 4
24199: PPUSH
24200: EMPTY
24201: PPUSH
24202: CALL_OW 1
24206: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24207: LD_ADDR_EXP 117
24211: PUSH
24212: LD_EXP 117
24216: PPUSH
24217: LD_VAR 0 4
24221: PPUSH
24222: EMPTY
24223: PPUSH
24224: CALL_OW 1
24228: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24229: LD_ADDR_EXP 118
24233: PUSH
24234: LD_EXP 118
24238: PPUSH
24239: LD_VAR 0 4
24243: PPUSH
24244: EMPTY
24245: PPUSH
24246: CALL_OW 1
24250: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24251: LD_ADDR_EXP 119
24255: PUSH
24256: LD_EXP 119
24260: PPUSH
24261: LD_VAR 0 4
24265: PPUSH
24266: EMPTY
24267: PPUSH
24268: CALL_OW 1
24272: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24273: LD_ADDR_EXP 120
24277: PUSH
24278: LD_EXP 120
24282: PPUSH
24283: LD_VAR 0 4
24287: PPUSH
24288: LD_INT 0
24290: PPUSH
24291: CALL_OW 1
24295: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24296: LD_ADDR_EXP 121
24300: PUSH
24301: LD_EXP 121
24305: PPUSH
24306: LD_VAR 0 4
24310: PPUSH
24311: LD_INT 0
24313: PPUSH
24314: CALL_OW 1
24318: ST_TO_ADDR
// result := base ;
24319: LD_ADDR_VAR 0 3
24323: PUSH
24324: LD_VAR 0 4
24328: ST_TO_ADDR
// end ;
24329: LD_VAR 0 3
24333: RET
// export function MC_Start ( ) ; var i ; begin
24334: LD_INT 0
24336: PPUSH
24337: PPUSH
// for i = 1 to mc_bases do
24338: LD_ADDR_VAR 0 2
24342: PUSH
24343: DOUBLE
24344: LD_INT 1
24346: DEC
24347: ST_TO_ADDR
24348: LD_EXP 78
24352: PUSH
24353: FOR_TO
24354: IFFALSE 25454
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
24356: LD_ADDR_EXP 78
24360: PUSH
24361: LD_EXP 78
24365: PPUSH
24366: LD_VAR 0 2
24370: PPUSH
24371: LD_EXP 78
24375: PUSH
24376: LD_VAR 0 2
24380: ARRAY
24381: PUSH
24382: LD_INT 0
24384: DIFF
24385: PPUSH
24386: CALL_OW 1
24390: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
24391: LD_ADDR_EXP 79
24395: PUSH
24396: LD_EXP 79
24400: PPUSH
24401: LD_VAR 0 2
24405: PPUSH
24406: EMPTY
24407: PPUSH
24408: CALL_OW 1
24412: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
24413: LD_ADDR_EXP 80
24417: PUSH
24418: LD_EXP 80
24422: PPUSH
24423: LD_VAR 0 2
24427: PPUSH
24428: EMPTY
24429: PPUSH
24430: CALL_OW 1
24434: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
24435: LD_ADDR_EXP 81
24439: PUSH
24440: LD_EXP 81
24444: PPUSH
24445: LD_VAR 0 2
24449: PPUSH
24450: EMPTY
24451: PPUSH
24452: CALL_OW 1
24456: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
24457: LD_ADDR_EXP 82
24461: PUSH
24462: LD_EXP 82
24466: PPUSH
24467: LD_VAR 0 2
24471: PPUSH
24472: EMPTY
24473: PUSH
24474: EMPTY
24475: PUSH
24476: EMPTY
24477: LIST
24478: LIST
24479: PPUSH
24480: CALL_OW 1
24484: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
24485: LD_ADDR_EXP 83
24489: PUSH
24490: LD_EXP 83
24494: PPUSH
24495: LD_VAR 0 2
24499: PPUSH
24500: EMPTY
24501: PPUSH
24502: CALL_OW 1
24506: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
24507: LD_ADDR_EXP 110
24511: PUSH
24512: LD_EXP 110
24516: PPUSH
24517: LD_VAR 0 2
24521: PPUSH
24522: EMPTY
24523: PPUSH
24524: CALL_OW 1
24528: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
24529: LD_ADDR_EXP 84
24533: PUSH
24534: LD_EXP 84
24538: PPUSH
24539: LD_VAR 0 2
24543: PPUSH
24544: EMPTY
24545: PPUSH
24546: CALL_OW 1
24550: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
24551: LD_ADDR_EXP 85
24555: PUSH
24556: LD_EXP 85
24560: PPUSH
24561: LD_VAR 0 2
24565: PPUSH
24566: EMPTY
24567: PPUSH
24568: CALL_OW 1
24572: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
24573: LD_ADDR_EXP 86
24577: PUSH
24578: LD_EXP 86
24582: PPUSH
24583: LD_VAR 0 2
24587: PPUSH
24588: LD_EXP 78
24592: PUSH
24593: LD_VAR 0 2
24597: ARRAY
24598: PPUSH
24599: LD_INT 2
24601: PUSH
24602: LD_INT 30
24604: PUSH
24605: LD_INT 32
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: PUSH
24612: LD_INT 30
24614: PUSH
24615: LD_INT 33
24617: PUSH
24618: EMPTY
24619: LIST
24620: LIST
24621: PUSH
24622: EMPTY
24623: LIST
24624: LIST
24625: LIST
24626: PPUSH
24627: CALL_OW 72
24631: PPUSH
24632: CALL_OW 1
24636: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
24637: LD_ADDR_EXP 87
24641: PUSH
24642: LD_EXP 87
24646: PPUSH
24647: LD_VAR 0 2
24651: PPUSH
24652: LD_EXP 78
24656: PUSH
24657: LD_VAR 0 2
24661: ARRAY
24662: PPUSH
24663: LD_INT 2
24665: PUSH
24666: LD_INT 30
24668: PUSH
24669: LD_INT 32
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: PUSH
24676: LD_INT 30
24678: PUSH
24679: LD_INT 31
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: LIST
24690: PUSH
24691: LD_INT 58
24693: PUSH
24694: EMPTY
24695: LIST
24696: PUSH
24697: EMPTY
24698: LIST
24699: LIST
24700: PPUSH
24701: CALL_OW 72
24705: PPUSH
24706: CALL_OW 1
24710: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
24711: LD_ADDR_EXP 88
24715: PUSH
24716: LD_EXP 88
24720: PPUSH
24721: LD_VAR 0 2
24725: PPUSH
24726: EMPTY
24727: PPUSH
24728: CALL_OW 1
24732: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
24733: LD_ADDR_EXP 92
24737: PUSH
24738: LD_EXP 92
24742: PPUSH
24743: LD_VAR 0 2
24747: PPUSH
24748: EMPTY
24749: PPUSH
24750: CALL_OW 1
24754: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
24755: LD_ADDR_EXP 91
24759: PUSH
24760: LD_EXP 91
24764: PPUSH
24765: LD_VAR 0 2
24769: PPUSH
24770: EMPTY
24771: PPUSH
24772: CALL_OW 1
24776: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24777: LD_ADDR_EXP 93
24781: PUSH
24782: LD_EXP 93
24786: PPUSH
24787: LD_VAR 0 2
24791: PPUSH
24792: EMPTY
24793: PPUSH
24794: CALL_OW 1
24798: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24799: LD_ADDR_EXP 94
24803: PUSH
24804: LD_EXP 94
24808: PPUSH
24809: LD_VAR 0 2
24813: PPUSH
24814: EMPTY
24815: PPUSH
24816: CALL_OW 1
24820: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24821: LD_ADDR_EXP 95
24825: PUSH
24826: LD_EXP 95
24830: PPUSH
24831: LD_VAR 0 2
24835: PPUSH
24836: EMPTY
24837: PPUSH
24838: CALL_OW 1
24842: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24843: LD_ADDR_EXP 96
24847: PUSH
24848: LD_EXP 96
24852: PPUSH
24853: LD_VAR 0 2
24857: PPUSH
24858: EMPTY
24859: PPUSH
24860: CALL_OW 1
24864: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24865: LD_ADDR_EXP 97
24869: PUSH
24870: LD_EXP 97
24874: PPUSH
24875: LD_VAR 0 2
24879: PPUSH
24880: EMPTY
24881: PPUSH
24882: CALL_OW 1
24886: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24887: LD_ADDR_EXP 98
24891: PUSH
24892: LD_EXP 98
24896: PPUSH
24897: LD_VAR 0 2
24901: PPUSH
24902: EMPTY
24903: PPUSH
24904: CALL_OW 1
24908: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24909: LD_ADDR_EXP 99
24913: PUSH
24914: LD_EXP 99
24918: PPUSH
24919: LD_VAR 0 2
24923: PPUSH
24924: EMPTY
24925: PPUSH
24926: CALL_OW 1
24930: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24931: LD_ADDR_EXP 100
24935: PUSH
24936: LD_EXP 100
24940: PPUSH
24941: LD_VAR 0 2
24945: PPUSH
24946: EMPTY
24947: PPUSH
24948: CALL_OW 1
24952: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24953: LD_ADDR_EXP 89
24957: PUSH
24958: LD_EXP 89
24962: PPUSH
24963: LD_VAR 0 2
24967: PPUSH
24968: LD_INT 0
24970: PPUSH
24971: CALL_OW 1
24975: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24976: LD_ADDR_EXP 102
24980: PUSH
24981: LD_EXP 102
24985: PPUSH
24986: LD_VAR 0 2
24990: PPUSH
24991: LD_INT 0
24993: PPUSH
24994: CALL_OW 1
24998: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24999: LD_ADDR_EXP 90
25003: PUSH
25004: LD_EXP 90
25008: PPUSH
25009: LD_VAR 0 2
25013: PPUSH
25014: EMPTY
25015: PPUSH
25016: CALL_OW 1
25020: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
25021: LD_ADDR_EXP 101
25025: PUSH
25026: LD_EXP 101
25030: PPUSH
25031: LD_VAR 0 2
25035: PPUSH
25036: LD_INT 0
25038: PPUSH
25039: CALL_OW 1
25043: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25044: LD_ADDR_EXP 103
25048: PUSH
25049: LD_EXP 103
25053: PPUSH
25054: LD_VAR 0 2
25058: PPUSH
25059: EMPTY
25060: PPUSH
25061: CALL_OW 1
25065: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25066: LD_ADDR_EXP 106
25070: PUSH
25071: LD_EXP 106
25075: PPUSH
25076: LD_VAR 0 2
25080: PPUSH
25081: LD_INT 0
25083: PPUSH
25084: CALL_OW 1
25088: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25089: LD_ADDR_EXP 107
25093: PUSH
25094: LD_EXP 107
25098: PPUSH
25099: LD_VAR 0 2
25103: PPUSH
25104: EMPTY
25105: PPUSH
25106: CALL_OW 1
25110: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25111: LD_ADDR_EXP 108
25115: PUSH
25116: LD_EXP 108
25120: PPUSH
25121: LD_VAR 0 2
25125: PPUSH
25126: EMPTY
25127: PPUSH
25128: CALL_OW 1
25132: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25133: LD_ADDR_EXP 109
25137: PUSH
25138: LD_EXP 109
25142: PPUSH
25143: LD_VAR 0 2
25147: PPUSH
25148: EMPTY
25149: PPUSH
25150: CALL_OW 1
25154: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
25155: LD_ADDR_EXP 111
25159: PUSH
25160: LD_EXP 111
25164: PPUSH
25165: LD_VAR 0 2
25169: PPUSH
25170: LD_EXP 78
25174: PUSH
25175: LD_VAR 0 2
25179: ARRAY
25180: PPUSH
25181: LD_INT 2
25183: PUSH
25184: LD_INT 30
25186: PUSH
25187: LD_INT 6
25189: PUSH
25190: EMPTY
25191: LIST
25192: LIST
25193: PUSH
25194: LD_INT 30
25196: PUSH
25197: LD_INT 7
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: PUSH
25204: LD_INT 30
25206: PUSH
25207: LD_INT 8
25209: PUSH
25210: EMPTY
25211: LIST
25212: LIST
25213: PUSH
25214: EMPTY
25215: LIST
25216: LIST
25217: LIST
25218: LIST
25219: PPUSH
25220: CALL_OW 72
25224: PPUSH
25225: CALL_OW 1
25229: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
25230: LD_ADDR_EXP 112
25234: PUSH
25235: LD_EXP 112
25239: PPUSH
25240: LD_VAR 0 2
25244: PPUSH
25245: EMPTY
25246: PPUSH
25247: CALL_OW 1
25251: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
25252: LD_ADDR_EXP 113
25256: PUSH
25257: LD_EXP 113
25261: PPUSH
25262: LD_VAR 0 2
25266: PPUSH
25267: EMPTY
25268: PPUSH
25269: CALL_OW 1
25273: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
25274: LD_ADDR_EXP 114
25278: PUSH
25279: LD_EXP 114
25283: PPUSH
25284: LD_VAR 0 2
25288: PPUSH
25289: EMPTY
25290: PPUSH
25291: CALL_OW 1
25295: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
25296: LD_ADDR_EXP 115
25300: PUSH
25301: LD_EXP 115
25305: PPUSH
25306: LD_VAR 0 2
25310: PPUSH
25311: EMPTY
25312: PPUSH
25313: CALL_OW 1
25317: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
25318: LD_ADDR_EXP 116
25322: PUSH
25323: LD_EXP 116
25327: PPUSH
25328: LD_VAR 0 2
25332: PPUSH
25333: EMPTY
25334: PPUSH
25335: CALL_OW 1
25339: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
25340: LD_ADDR_EXP 117
25344: PUSH
25345: LD_EXP 117
25349: PPUSH
25350: LD_VAR 0 2
25354: PPUSH
25355: EMPTY
25356: PPUSH
25357: CALL_OW 1
25361: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
25362: LD_ADDR_EXP 118
25366: PUSH
25367: LD_EXP 118
25371: PPUSH
25372: LD_VAR 0 2
25376: PPUSH
25377: EMPTY
25378: PPUSH
25379: CALL_OW 1
25383: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
25384: LD_ADDR_EXP 119
25388: PUSH
25389: LD_EXP 119
25393: PPUSH
25394: LD_VAR 0 2
25398: PPUSH
25399: EMPTY
25400: PPUSH
25401: CALL_OW 1
25405: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
25406: LD_ADDR_EXP 120
25410: PUSH
25411: LD_EXP 120
25415: PPUSH
25416: LD_VAR 0 2
25420: PPUSH
25421: LD_INT 0
25423: PPUSH
25424: CALL_OW 1
25428: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
25429: LD_ADDR_EXP 121
25433: PUSH
25434: LD_EXP 121
25438: PPUSH
25439: LD_VAR 0 2
25443: PPUSH
25444: LD_INT 0
25446: PPUSH
25447: CALL_OW 1
25451: ST_TO_ADDR
// end ;
25452: GO 24353
25454: POP
25455: POP
// MC_InitSides ( ) ;
25456: CALL 25742 0 0
// MC_InitResearch ( ) ;
25460: CALL 25481 0 0
// CustomInitMacro ( ) ;
25464: CALL 228 0 0
// skirmish := true ;
25468: LD_ADDR_EXP 76
25472: PUSH
25473: LD_INT 1
25475: ST_TO_ADDR
// end ;
25476: LD_VAR 0 1
25480: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
25481: LD_INT 0
25483: PPUSH
25484: PPUSH
25485: PPUSH
25486: PPUSH
25487: PPUSH
25488: PPUSH
// if not mc_bases then
25489: LD_EXP 78
25493: NOT
25494: IFFALSE 25498
// exit ;
25496: GO 25737
// for i = 1 to 8 do
25498: LD_ADDR_VAR 0 2
25502: PUSH
25503: DOUBLE
25504: LD_INT 1
25506: DEC
25507: ST_TO_ADDR
25508: LD_INT 8
25510: PUSH
25511: FOR_TO
25512: IFFALSE 25538
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
25514: LD_ADDR_EXP 105
25518: PUSH
25519: LD_EXP 105
25523: PPUSH
25524: LD_VAR 0 2
25528: PPUSH
25529: EMPTY
25530: PPUSH
25531: CALL_OW 1
25535: ST_TO_ADDR
25536: GO 25511
25538: POP
25539: POP
// tmp := [ ] ;
25540: LD_ADDR_VAR 0 5
25544: PUSH
25545: EMPTY
25546: ST_TO_ADDR
// for i = 1 to mc_sides do
25547: LD_ADDR_VAR 0 2
25551: PUSH
25552: DOUBLE
25553: LD_INT 1
25555: DEC
25556: ST_TO_ADDR
25557: LD_EXP 104
25561: PUSH
25562: FOR_TO
25563: IFFALSE 25621
// if not mc_sides [ i ] in tmp then
25565: LD_EXP 104
25569: PUSH
25570: LD_VAR 0 2
25574: ARRAY
25575: PUSH
25576: LD_VAR 0 5
25580: IN
25581: NOT
25582: IFFALSE 25619
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
25584: LD_ADDR_VAR 0 5
25588: PUSH
25589: LD_VAR 0 5
25593: PPUSH
25594: LD_VAR 0 5
25598: PUSH
25599: LD_INT 1
25601: PLUS
25602: PPUSH
25603: LD_EXP 104
25607: PUSH
25608: LD_VAR 0 2
25612: ARRAY
25613: PPUSH
25614: CALL_OW 2
25618: ST_TO_ADDR
25619: GO 25562
25621: POP
25622: POP
// if not tmp then
25623: LD_VAR 0 5
25627: NOT
25628: IFFALSE 25632
// exit ;
25630: GO 25737
// for j in tmp do
25632: LD_ADDR_VAR 0 3
25636: PUSH
25637: LD_VAR 0 5
25641: PUSH
25642: FOR_IN
25643: IFFALSE 25735
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
25645: LD_ADDR_VAR 0 6
25649: PUSH
25650: LD_INT 22
25652: PUSH
25653: LD_VAR 0 3
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: ST_TO_ADDR
// if not un then
25667: LD_VAR 0 6
25671: NOT
25672: IFFALSE 25676
// continue ;
25674: GO 25642
// nation := GetNation ( un [ 1 ] ) ;
25676: LD_ADDR_VAR 0 4
25680: PUSH
25681: LD_VAR 0 6
25685: PUSH
25686: LD_INT 1
25688: ARRAY
25689: PPUSH
25690: CALL_OW 248
25694: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
25695: LD_ADDR_EXP 105
25699: PUSH
25700: LD_EXP 105
25704: PPUSH
25705: LD_VAR 0 3
25709: PPUSH
25710: LD_VAR 0 3
25714: PPUSH
25715: LD_VAR 0 4
25719: PPUSH
25720: LD_INT 1
25722: PPUSH
25723: CALL 52911 0 3
25727: PPUSH
25728: CALL_OW 1
25732: ST_TO_ADDR
// end ;
25733: GO 25642
25735: POP
25736: POP
// end ;
25737: LD_VAR 0 1
25741: RET
// export function MC_InitSides ( ) ; var i ; begin
25742: LD_INT 0
25744: PPUSH
25745: PPUSH
// if not mc_bases then
25746: LD_EXP 78
25750: NOT
25751: IFFALSE 25755
// exit ;
25753: GO 25829
// for i = 1 to mc_bases do
25755: LD_ADDR_VAR 0 2
25759: PUSH
25760: DOUBLE
25761: LD_INT 1
25763: DEC
25764: ST_TO_ADDR
25765: LD_EXP 78
25769: PUSH
25770: FOR_TO
25771: IFFALSE 25827
// if mc_bases [ i ] then
25773: LD_EXP 78
25777: PUSH
25778: LD_VAR 0 2
25782: ARRAY
25783: IFFALSE 25825
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25785: LD_ADDR_EXP 104
25789: PUSH
25790: LD_EXP 104
25794: PPUSH
25795: LD_VAR 0 2
25799: PPUSH
25800: LD_EXP 78
25804: PUSH
25805: LD_VAR 0 2
25809: ARRAY
25810: PUSH
25811: LD_INT 1
25813: ARRAY
25814: PPUSH
25815: CALL_OW 255
25819: PPUSH
25820: CALL_OW 1
25824: ST_TO_ADDR
25825: GO 25770
25827: POP
25828: POP
// end ;
25829: LD_VAR 0 1
25833: RET
// every 0 0$03 trigger skirmish do
25834: LD_EXP 76
25838: IFFALSE 25992
25840: GO 25842
25842: DISABLE
// begin enable ;
25843: ENABLE
// MC_CheckBuildings ( ) ;
25844: CALL 30490 0 0
// MC_CheckPeopleLife ( ) ;
25848: CALL 30651 0 0
// RaiseSailEvent ( 100 ) ;
25852: LD_INT 100
25854: PPUSH
25855: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25859: LD_INT 103
25861: PPUSH
25862: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25866: LD_INT 104
25868: PPUSH
25869: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25873: LD_INT 105
25875: PPUSH
25876: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25880: LD_INT 106
25882: PPUSH
25883: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25887: LD_INT 107
25889: PPUSH
25890: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25894: LD_INT 108
25896: PPUSH
25897: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25901: LD_INT 109
25903: PPUSH
25904: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25908: LD_INT 110
25910: PPUSH
25911: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25915: LD_INT 111
25917: PPUSH
25918: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25922: LD_INT 112
25924: PPUSH
25925: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25929: LD_INT 113
25931: PPUSH
25932: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25936: LD_INT 120
25938: PPUSH
25939: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25943: LD_INT 121
25945: PPUSH
25946: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25950: LD_INT 122
25952: PPUSH
25953: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25957: LD_INT 123
25959: PPUSH
25960: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25964: LD_INT 124
25966: PPUSH
25967: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25971: LD_INT 125
25973: PPUSH
25974: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25978: LD_INT 126
25980: PPUSH
25981: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25985: LD_INT 200
25987: PPUSH
25988: CALL_OW 427
// end ;
25992: END
// on SailEvent ( event ) do begin if event < 100 then
25993: LD_VAR 0 1
25997: PUSH
25998: LD_INT 100
26000: LESS
26001: IFFALSE 26012
// CustomEvent ( event ) ;
26003: LD_VAR 0 1
26007: PPUSH
26008: CALL 11285 0 1
// if event = 100 then
26012: LD_VAR 0 1
26016: PUSH
26017: LD_INT 100
26019: EQUAL
26020: IFFALSE 26026
// MC_ClassManager ( ) ;
26022: CALL 26418 0 0
// if event = 101 then
26026: LD_VAR 0 1
26030: PUSH
26031: LD_INT 101
26033: EQUAL
26034: IFFALSE 26040
// MC_RepairBuildings ( ) ;
26036: CALL 31236 0 0
// if event = 102 then
26040: LD_VAR 0 1
26044: PUSH
26045: LD_INT 102
26047: EQUAL
26048: IFFALSE 26054
// MC_Heal ( ) ;
26050: CALL 32171 0 0
// if event = 103 then
26054: LD_VAR 0 1
26058: PUSH
26059: LD_INT 103
26061: EQUAL
26062: IFFALSE 26068
// MC_Build ( ) ;
26064: CALL 32593 0 0
// if event = 104 then
26068: LD_VAR 0 1
26072: PUSH
26073: LD_INT 104
26075: EQUAL
26076: IFFALSE 26082
// MC_TurretWeapon ( ) ;
26078: CALL 34227 0 0
// if event = 105 then
26082: LD_VAR 0 1
26086: PUSH
26087: LD_INT 105
26089: EQUAL
26090: IFFALSE 26096
// MC_BuildUpgrade ( ) ;
26092: CALL 33778 0 0
// if event = 106 then
26096: LD_VAR 0 1
26100: PUSH
26101: LD_INT 106
26103: EQUAL
26104: IFFALSE 26110
// MC_PlantMines ( ) ;
26106: CALL 34657 0 0
// if event = 107 then
26110: LD_VAR 0 1
26114: PUSH
26115: LD_INT 107
26117: EQUAL
26118: IFFALSE 26124
// MC_CollectCrates ( ) ;
26120: CALL 35455 0 0
// if event = 108 then
26124: LD_VAR 0 1
26128: PUSH
26129: LD_INT 108
26131: EQUAL
26132: IFFALSE 26138
// MC_LinkRemoteControl ( ) ;
26134: CALL 37305 0 0
// if event = 109 then
26138: LD_VAR 0 1
26142: PUSH
26143: LD_INT 109
26145: EQUAL
26146: IFFALSE 26152
// MC_ProduceVehicle ( ) ;
26148: CALL 37486 0 0
// if event = 110 then
26152: LD_VAR 0 1
26156: PUSH
26157: LD_INT 110
26159: EQUAL
26160: IFFALSE 26166
// MC_SendAttack ( ) ;
26162: CALL 37952 0 0
// if event = 111 then
26166: LD_VAR 0 1
26170: PUSH
26171: LD_INT 111
26173: EQUAL
26174: IFFALSE 26180
// MC_Defend ( ) ;
26176: CALL 38060 0 0
// if event = 112 then
26180: LD_VAR 0 1
26184: PUSH
26185: LD_INT 112
26187: EQUAL
26188: IFFALSE 26194
// MC_Research ( ) ;
26190: CALL 38940 0 0
// if event = 113 then
26194: LD_VAR 0 1
26198: PUSH
26199: LD_INT 113
26201: EQUAL
26202: IFFALSE 26208
// MC_MinesTrigger ( ) ;
26204: CALL 40054 0 0
// if event = 120 then
26208: LD_VAR 0 1
26212: PUSH
26213: LD_INT 120
26215: EQUAL
26216: IFFALSE 26222
// MC_RepairVehicle ( ) ;
26218: CALL 40153 0 0
// if event = 121 then
26222: LD_VAR 0 1
26226: PUSH
26227: LD_INT 121
26229: EQUAL
26230: IFFALSE 26236
// MC_TameApe ( ) ;
26232: CALL 40922 0 0
// if event = 122 then
26236: LD_VAR 0 1
26240: PUSH
26241: LD_INT 122
26243: EQUAL
26244: IFFALSE 26250
// MC_ChangeApeClass ( ) ;
26246: CALL 41751 0 0
// if event = 123 then
26250: LD_VAR 0 1
26254: PUSH
26255: LD_INT 123
26257: EQUAL
26258: IFFALSE 26264
// MC_Bazooka ( ) ;
26260: CALL 42401 0 0
// if event = 124 then
26264: LD_VAR 0 1
26268: PUSH
26269: LD_INT 124
26271: EQUAL
26272: IFFALSE 26278
// MC_TeleportExit ( ) ;
26274: CALL 42599 0 0
// if event = 125 then
26278: LD_VAR 0 1
26282: PUSH
26283: LD_INT 125
26285: EQUAL
26286: IFFALSE 26292
// MC_Deposits ( ) ;
26288: CALL 43246 0 0
// if event = 126 then
26292: LD_VAR 0 1
26296: PUSH
26297: LD_INT 126
26299: EQUAL
26300: IFFALSE 26306
// MC_RemoteDriver ( ) ;
26302: CALL 43871 0 0
// if event = 200 then
26306: LD_VAR 0 1
26310: PUSH
26311: LD_INT 200
26313: EQUAL
26314: IFFALSE 26320
// MC_Idle ( ) ;
26316: CALL 45778 0 0
// end ;
26320: PPOPN 1
26322: END
// export function MC_Reset ( base , tag ) ; var i ; begin
26323: LD_INT 0
26325: PPUSH
26326: PPUSH
// if not mc_bases [ base ] or not tag then
26327: LD_EXP 78
26331: PUSH
26332: LD_VAR 0 1
26336: ARRAY
26337: NOT
26338: PUSH
26339: LD_VAR 0 2
26343: NOT
26344: OR
26345: IFFALSE 26349
// exit ;
26347: GO 26413
// for i in mc_bases [ base ] union mc_ape [ base ] do
26349: LD_ADDR_VAR 0 4
26353: PUSH
26354: LD_EXP 78
26358: PUSH
26359: LD_VAR 0 1
26363: ARRAY
26364: PUSH
26365: LD_EXP 107
26369: PUSH
26370: LD_VAR 0 1
26374: ARRAY
26375: UNION
26376: PUSH
26377: FOR_IN
26378: IFFALSE 26411
// if GetTag ( i ) = tag then
26380: LD_VAR 0 4
26384: PPUSH
26385: CALL_OW 110
26389: PUSH
26390: LD_VAR 0 2
26394: EQUAL
26395: IFFALSE 26409
// SetTag ( i , 0 ) ;
26397: LD_VAR 0 4
26401: PPUSH
26402: LD_INT 0
26404: PPUSH
26405: CALL_OW 109
26409: GO 26377
26411: POP
26412: POP
// end ;
26413: LD_VAR 0 3
26417: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
26418: LD_INT 0
26420: PPUSH
26421: PPUSH
26422: PPUSH
26423: PPUSH
26424: PPUSH
26425: PPUSH
26426: PPUSH
26427: PPUSH
// if not mc_bases then
26428: LD_EXP 78
26432: NOT
26433: IFFALSE 26437
// exit ;
26435: GO 26895
// for i = 1 to mc_bases do
26437: LD_ADDR_VAR 0 2
26441: PUSH
26442: DOUBLE
26443: LD_INT 1
26445: DEC
26446: ST_TO_ADDR
26447: LD_EXP 78
26451: PUSH
26452: FOR_TO
26453: IFFALSE 26893
// begin tmp := MC_ClassCheckReq ( i ) ;
26455: LD_ADDR_VAR 0 4
26459: PUSH
26460: LD_VAR 0 2
26464: PPUSH
26465: CALL 26900 0 1
26469: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
26470: LD_ADDR_EXP 119
26474: PUSH
26475: LD_EXP 119
26479: PPUSH
26480: LD_VAR 0 2
26484: PPUSH
26485: LD_VAR 0 4
26489: PPUSH
26490: CALL_OW 1
26494: ST_TO_ADDR
// if not tmp then
26495: LD_VAR 0 4
26499: NOT
26500: IFFALSE 26504
// continue ;
26502: GO 26452
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
26504: LD_ADDR_VAR 0 6
26508: PUSH
26509: LD_EXP 78
26513: PUSH
26514: LD_VAR 0 2
26518: ARRAY
26519: PPUSH
26520: LD_INT 2
26522: PUSH
26523: LD_INT 30
26525: PUSH
26526: LD_INT 4
26528: PUSH
26529: EMPTY
26530: LIST
26531: LIST
26532: PUSH
26533: LD_INT 30
26535: PUSH
26536: LD_INT 5
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: EMPTY
26544: LIST
26545: LIST
26546: LIST
26547: PPUSH
26548: CALL_OW 72
26552: PUSH
26553: LD_EXP 78
26557: PUSH
26558: LD_VAR 0 2
26562: ARRAY
26563: PPUSH
26564: LD_INT 2
26566: PUSH
26567: LD_INT 30
26569: PUSH
26570: LD_INT 0
26572: PUSH
26573: EMPTY
26574: LIST
26575: LIST
26576: PUSH
26577: LD_INT 30
26579: PUSH
26580: LD_INT 1
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: LIST
26591: PPUSH
26592: CALL_OW 72
26596: PUSH
26597: LD_EXP 78
26601: PUSH
26602: LD_VAR 0 2
26606: ARRAY
26607: PPUSH
26608: LD_INT 30
26610: PUSH
26611: LD_INT 3
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PPUSH
26618: CALL_OW 72
26622: PUSH
26623: LD_EXP 78
26627: PUSH
26628: LD_VAR 0 2
26632: ARRAY
26633: PPUSH
26634: LD_INT 2
26636: PUSH
26637: LD_INT 30
26639: PUSH
26640: LD_INT 6
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PUSH
26647: LD_INT 30
26649: PUSH
26650: LD_INT 7
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: PUSH
26657: LD_INT 30
26659: PUSH
26660: LD_INT 8
26662: PUSH
26663: EMPTY
26664: LIST
26665: LIST
26666: PUSH
26667: EMPTY
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: PPUSH
26673: CALL_OW 72
26677: PUSH
26678: EMPTY
26679: LIST
26680: LIST
26681: LIST
26682: LIST
26683: ST_TO_ADDR
// for j = 1 to 4 do
26684: LD_ADDR_VAR 0 3
26688: PUSH
26689: DOUBLE
26690: LD_INT 1
26692: DEC
26693: ST_TO_ADDR
26694: LD_INT 4
26696: PUSH
26697: FOR_TO
26698: IFFALSE 26889
// begin if not tmp [ j ] then
26700: LD_VAR 0 4
26704: PUSH
26705: LD_VAR 0 3
26709: ARRAY
26710: NOT
26711: IFFALSE 26715
// continue ;
26713: GO 26697
// for p in tmp [ j ] do
26715: LD_ADDR_VAR 0 5
26719: PUSH
26720: LD_VAR 0 4
26724: PUSH
26725: LD_VAR 0 3
26729: ARRAY
26730: PUSH
26731: FOR_IN
26732: IFFALSE 26885
// begin if not b [ j ] then
26734: LD_VAR 0 6
26738: PUSH
26739: LD_VAR 0 3
26743: ARRAY
26744: NOT
26745: IFFALSE 26749
// break ;
26747: GO 26885
// e := 0 ;
26749: LD_ADDR_VAR 0 7
26753: PUSH
26754: LD_INT 0
26756: ST_TO_ADDR
// for k in b [ j ] do
26757: LD_ADDR_VAR 0 8
26761: PUSH
26762: LD_VAR 0 6
26766: PUSH
26767: LD_VAR 0 3
26771: ARRAY
26772: PUSH
26773: FOR_IN
26774: IFFALSE 26801
// if IsNotFull ( k ) then
26776: LD_VAR 0 8
26780: PPUSH
26781: CALL 55032 0 1
26785: IFFALSE 26799
// begin e := k ;
26787: LD_ADDR_VAR 0 7
26791: PUSH
26792: LD_VAR 0 8
26796: ST_TO_ADDR
// break ;
26797: GO 26801
// end ;
26799: GO 26773
26801: POP
26802: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26803: LD_VAR 0 7
26807: PUSH
26808: LD_VAR 0 5
26812: PPUSH
26813: LD_VAR 0 7
26817: PPUSH
26818: CALL 88785 0 2
26822: NOT
26823: AND
26824: IFFALSE 26883
// begin if IsInUnit ( p ) then
26826: LD_VAR 0 5
26830: PPUSH
26831: CALL_OW 310
26835: IFFALSE 26846
// ComExitBuilding ( p ) ;
26837: LD_VAR 0 5
26841: PPUSH
26842: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26846: LD_VAR 0 5
26850: PPUSH
26851: LD_VAR 0 7
26855: PPUSH
26856: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26860: LD_VAR 0 5
26864: PPUSH
26865: LD_VAR 0 3
26869: PPUSH
26870: CALL_OW 183
// AddComExitBuilding ( p ) ;
26874: LD_VAR 0 5
26878: PPUSH
26879: CALL_OW 182
// end ; end ;
26883: GO 26731
26885: POP
26886: POP
// end ;
26887: GO 26697
26889: POP
26890: POP
// end ;
26891: GO 26452
26893: POP
26894: POP
// end ;
26895: LD_VAR 0 1
26899: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26900: LD_INT 0
26902: PPUSH
26903: PPUSH
26904: PPUSH
26905: PPUSH
26906: PPUSH
26907: PPUSH
26908: PPUSH
26909: PPUSH
26910: PPUSH
26911: PPUSH
26912: PPUSH
26913: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26914: LD_VAR 0 1
26918: NOT
26919: PUSH
26920: LD_EXP 78
26924: PUSH
26925: LD_VAR 0 1
26929: ARRAY
26930: NOT
26931: OR
26932: PUSH
26933: LD_EXP 78
26937: PUSH
26938: LD_VAR 0 1
26942: ARRAY
26943: PPUSH
26944: LD_INT 2
26946: PUSH
26947: LD_INT 30
26949: PUSH
26950: LD_INT 0
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: PUSH
26957: LD_INT 30
26959: PUSH
26960: LD_INT 1
26962: PUSH
26963: EMPTY
26964: LIST
26965: LIST
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: LIST
26971: PPUSH
26972: CALL_OW 72
26976: NOT
26977: OR
26978: IFFALSE 26982
// exit ;
26980: GO 30485
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26982: LD_ADDR_VAR 0 4
26986: PUSH
26987: LD_EXP 78
26991: PUSH
26992: LD_VAR 0 1
26996: ARRAY
26997: PPUSH
26998: LD_INT 2
27000: PUSH
27001: LD_INT 25
27003: PUSH
27004: LD_INT 1
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: PUSH
27011: LD_INT 25
27013: PUSH
27014: LD_INT 2
27016: PUSH
27017: EMPTY
27018: LIST
27019: LIST
27020: PUSH
27021: LD_INT 25
27023: PUSH
27024: LD_INT 3
27026: PUSH
27027: EMPTY
27028: LIST
27029: LIST
27030: PUSH
27031: LD_INT 25
27033: PUSH
27034: LD_INT 4
27036: PUSH
27037: EMPTY
27038: LIST
27039: LIST
27040: PUSH
27041: LD_INT 25
27043: PUSH
27044: LD_INT 5
27046: PUSH
27047: EMPTY
27048: LIST
27049: LIST
27050: PUSH
27051: LD_INT 25
27053: PUSH
27054: LD_INT 8
27056: PUSH
27057: EMPTY
27058: LIST
27059: LIST
27060: PUSH
27061: LD_INT 25
27063: PUSH
27064: LD_INT 9
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: LIST
27075: LIST
27076: LIST
27077: LIST
27078: LIST
27079: LIST
27080: PPUSH
27081: CALL_OW 72
27085: ST_TO_ADDR
// if not tmp then
27086: LD_VAR 0 4
27090: NOT
27091: IFFALSE 27095
// exit ;
27093: GO 30485
// for i in tmp do
27095: LD_ADDR_VAR 0 3
27099: PUSH
27100: LD_VAR 0 4
27104: PUSH
27105: FOR_IN
27106: IFFALSE 27137
// if GetTag ( i ) then
27108: LD_VAR 0 3
27112: PPUSH
27113: CALL_OW 110
27117: IFFALSE 27135
// tmp := tmp diff i ;
27119: LD_ADDR_VAR 0 4
27123: PUSH
27124: LD_VAR 0 4
27128: PUSH
27129: LD_VAR 0 3
27133: DIFF
27134: ST_TO_ADDR
27135: GO 27105
27137: POP
27138: POP
// if not tmp then
27139: LD_VAR 0 4
27143: NOT
27144: IFFALSE 27148
// exit ;
27146: GO 30485
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27148: LD_ADDR_VAR 0 5
27152: PUSH
27153: LD_EXP 78
27157: PUSH
27158: LD_VAR 0 1
27162: ARRAY
27163: PPUSH
27164: LD_INT 2
27166: PUSH
27167: LD_INT 25
27169: PUSH
27170: LD_INT 1
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: PUSH
27177: LD_INT 25
27179: PUSH
27180: LD_INT 5
27182: PUSH
27183: EMPTY
27184: LIST
27185: LIST
27186: PUSH
27187: LD_INT 25
27189: PUSH
27190: LD_INT 8
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: LD_INT 25
27199: PUSH
27200: LD_INT 9
27202: PUSH
27203: EMPTY
27204: LIST
27205: LIST
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: LIST
27211: LIST
27212: LIST
27213: PPUSH
27214: CALL_OW 72
27218: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
27219: LD_ADDR_VAR 0 6
27223: PUSH
27224: LD_EXP 78
27228: PUSH
27229: LD_VAR 0 1
27233: ARRAY
27234: PPUSH
27235: LD_INT 25
27237: PUSH
27238: LD_INT 2
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: PPUSH
27245: CALL_OW 72
27249: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
27250: LD_ADDR_VAR 0 7
27254: PUSH
27255: LD_EXP 78
27259: PUSH
27260: LD_VAR 0 1
27264: ARRAY
27265: PPUSH
27266: LD_INT 25
27268: PUSH
27269: LD_INT 3
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PPUSH
27276: CALL_OW 72
27280: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
27281: LD_ADDR_VAR 0 8
27285: PUSH
27286: LD_EXP 78
27290: PUSH
27291: LD_VAR 0 1
27295: ARRAY
27296: PPUSH
27297: LD_INT 25
27299: PUSH
27300: LD_INT 4
27302: PUSH
27303: EMPTY
27304: LIST
27305: LIST
27306: PUSH
27307: LD_INT 24
27309: PUSH
27310: LD_INT 251
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: PPUSH
27321: CALL_OW 72
27325: ST_TO_ADDR
// if mc_is_defending [ base ] then
27326: LD_EXP 121
27330: PUSH
27331: LD_VAR 0 1
27335: ARRAY
27336: IFFALSE 27797
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
27338: LD_ADDR_EXP 120
27342: PUSH
27343: LD_EXP 120
27347: PPUSH
27348: LD_VAR 0 1
27352: PPUSH
27353: LD_INT 4
27355: PPUSH
27356: CALL_OW 1
27360: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
27361: LD_ADDR_VAR 0 12
27365: PUSH
27366: LD_EXP 78
27370: PUSH
27371: LD_VAR 0 1
27375: ARRAY
27376: PPUSH
27377: LD_INT 2
27379: PUSH
27380: LD_INT 30
27382: PUSH
27383: LD_INT 4
27385: PUSH
27386: EMPTY
27387: LIST
27388: LIST
27389: PUSH
27390: LD_INT 30
27392: PUSH
27393: LD_INT 5
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: PUSH
27400: EMPTY
27401: LIST
27402: LIST
27403: LIST
27404: PPUSH
27405: CALL_OW 72
27409: ST_TO_ADDR
// if not b then
27410: LD_VAR 0 12
27414: NOT
27415: IFFALSE 27419
// exit ;
27417: GO 30485
// p := [ ] ;
27419: LD_ADDR_VAR 0 11
27423: PUSH
27424: EMPTY
27425: ST_TO_ADDR
// if sci >= 2 then
27426: LD_VAR 0 8
27430: PUSH
27431: LD_INT 2
27433: GREATEREQUAL
27434: IFFALSE 27465
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
27436: LD_ADDR_VAR 0 8
27440: PUSH
27441: LD_VAR 0 8
27445: PUSH
27446: LD_INT 1
27448: ARRAY
27449: PUSH
27450: LD_VAR 0 8
27454: PUSH
27455: LD_INT 2
27457: ARRAY
27458: PUSH
27459: EMPTY
27460: LIST
27461: LIST
27462: ST_TO_ADDR
27463: GO 27526
// if sci = 1 then
27465: LD_VAR 0 8
27469: PUSH
27470: LD_INT 1
27472: EQUAL
27473: IFFALSE 27494
// sci := [ sci [ 1 ] ] else
27475: LD_ADDR_VAR 0 8
27479: PUSH
27480: LD_VAR 0 8
27484: PUSH
27485: LD_INT 1
27487: ARRAY
27488: PUSH
27489: EMPTY
27490: LIST
27491: ST_TO_ADDR
27492: GO 27526
// if sci = 0 then
27494: LD_VAR 0 8
27498: PUSH
27499: LD_INT 0
27501: EQUAL
27502: IFFALSE 27526
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
27504: LD_ADDR_VAR 0 11
27508: PUSH
27509: LD_VAR 0 4
27513: PPUSH
27514: LD_INT 4
27516: PPUSH
27517: CALL 88657 0 2
27521: PUSH
27522: LD_INT 1
27524: ARRAY
27525: ST_TO_ADDR
// if eng > 4 then
27526: LD_VAR 0 6
27530: PUSH
27531: LD_INT 4
27533: GREATER
27534: IFFALSE 27580
// for i = eng downto 4 do
27536: LD_ADDR_VAR 0 3
27540: PUSH
27541: DOUBLE
27542: LD_VAR 0 6
27546: INC
27547: ST_TO_ADDR
27548: LD_INT 4
27550: PUSH
27551: FOR_DOWNTO
27552: IFFALSE 27578
// eng := eng diff eng [ i ] ;
27554: LD_ADDR_VAR 0 6
27558: PUSH
27559: LD_VAR 0 6
27563: PUSH
27564: LD_VAR 0 6
27568: PUSH
27569: LD_VAR 0 3
27573: ARRAY
27574: DIFF
27575: ST_TO_ADDR
27576: GO 27551
27578: POP
27579: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
27580: LD_ADDR_VAR 0 4
27584: PUSH
27585: LD_VAR 0 4
27589: PUSH
27590: LD_VAR 0 5
27594: PUSH
27595: LD_VAR 0 6
27599: UNION
27600: PUSH
27601: LD_VAR 0 7
27605: UNION
27606: PUSH
27607: LD_VAR 0 8
27611: UNION
27612: DIFF
27613: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
27614: LD_ADDR_VAR 0 13
27618: PUSH
27619: LD_EXP 78
27623: PUSH
27624: LD_VAR 0 1
27628: ARRAY
27629: PPUSH
27630: LD_INT 2
27632: PUSH
27633: LD_INT 30
27635: PUSH
27636: LD_INT 32
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PUSH
27643: LD_INT 30
27645: PUSH
27646: LD_INT 31
27648: PUSH
27649: EMPTY
27650: LIST
27651: LIST
27652: PUSH
27653: EMPTY
27654: LIST
27655: LIST
27656: LIST
27657: PPUSH
27658: CALL_OW 72
27662: PUSH
27663: LD_EXP 78
27667: PUSH
27668: LD_VAR 0 1
27672: ARRAY
27673: PPUSH
27674: LD_INT 2
27676: PUSH
27677: LD_INT 30
27679: PUSH
27680: LD_INT 4
27682: PUSH
27683: EMPTY
27684: LIST
27685: LIST
27686: PUSH
27687: LD_INT 30
27689: PUSH
27690: LD_INT 5
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PUSH
27697: EMPTY
27698: LIST
27699: LIST
27700: LIST
27701: PPUSH
27702: CALL_OW 72
27706: PUSH
27707: LD_INT 6
27709: MUL
27710: PLUS
27711: ST_TO_ADDR
// if bcount < tmp then
27712: LD_VAR 0 13
27716: PUSH
27717: LD_VAR 0 4
27721: LESS
27722: IFFALSE 27768
// for i = tmp downto bcount do
27724: LD_ADDR_VAR 0 3
27728: PUSH
27729: DOUBLE
27730: LD_VAR 0 4
27734: INC
27735: ST_TO_ADDR
27736: LD_VAR 0 13
27740: PUSH
27741: FOR_DOWNTO
27742: IFFALSE 27766
// tmp := Delete ( tmp , tmp ) ;
27744: LD_ADDR_VAR 0 4
27748: PUSH
27749: LD_VAR 0 4
27753: PPUSH
27754: LD_VAR 0 4
27758: PPUSH
27759: CALL_OW 3
27763: ST_TO_ADDR
27764: GO 27741
27766: POP
27767: POP
// result := [ tmp , 0 , 0 , p ] ;
27768: LD_ADDR_VAR 0 2
27772: PUSH
27773: LD_VAR 0 4
27777: PUSH
27778: LD_INT 0
27780: PUSH
27781: LD_INT 0
27783: PUSH
27784: LD_VAR 0 11
27788: PUSH
27789: EMPTY
27790: LIST
27791: LIST
27792: LIST
27793: LIST
27794: ST_TO_ADDR
// exit ;
27795: GO 30485
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27797: LD_EXP 78
27801: PUSH
27802: LD_VAR 0 1
27806: ARRAY
27807: PPUSH
27808: LD_INT 2
27810: PUSH
27811: LD_INT 30
27813: PUSH
27814: LD_INT 6
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PUSH
27821: LD_INT 30
27823: PUSH
27824: LD_INT 7
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PUSH
27831: LD_INT 30
27833: PUSH
27834: LD_INT 8
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: PPUSH
27847: CALL_OW 72
27851: NOT
27852: PUSH
27853: LD_EXP 78
27857: PUSH
27858: LD_VAR 0 1
27862: ARRAY
27863: PPUSH
27864: LD_INT 30
27866: PUSH
27867: LD_INT 3
27869: PUSH
27870: EMPTY
27871: LIST
27872: LIST
27873: PPUSH
27874: CALL_OW 72
27878: NOT
27879: AND
27880: IFFALSE 27952
// begin if eng = tmp then
27882: LD_VAR 0 6
27886: PUSH
27887: LD_VAR 0 4
27891: EQUAL
27892: IFFALSE 27896
// exit ;
27894: GO 30485
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27896: LD_ADDR_EXP 120
27900: PUSH
27901: LD_EXP 120
27905: PPUSH
27906: LD_VAR 0 1
27910: PPUSH
27911: LD_INT 1
27913: PPUSH
27914: CALL_OW 1
27918: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27919: LD_ADDR_VAR 0 2
27923: PUSH
27924: LD_INT 0
27926: PUSH
27927: LD_VAR 0 4
27931: PUSH
27932: LD_VAR 0 6
27936: DIFF
27937: PUSH
27938: LD_INT 0
27940: PUSH
27941: LD_INT 0
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: LIST
27948: LIST
27949: ST_TO_ADDR
// exit ;
27950: GO 30485
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27952: LD_EXP 105
27956: PUSH
27957: LD_EXP 104
27961: PUSH
27962: LD_VAR 0 1
27966: ARRAY
27967: ARRAY
27968: PUSH
27969: LD_EXP 78
27973: PUSH
27974: LD_VAR 0 1
27978: ARRAY
27979: PPUSH
27980: LD_INT 2
27982: PUSH
27983: LD_INT 30
27985: PUSH
27986: LD_INT 6
27988: PUSH
27989: EMPTY
27990: LIST
27991: LIST
27992: PUSH
27993: LD_INT 30
27995: PUSH
27996: LD_INT 7
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PUSH
28003: LD_INT 30
28005: PUSH
28006: LD_INT 8
28008: PUSH
28009: EMPTY
28010: LIST
28011: LIST
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: LIST
28017: LIST
28018: PPUSH
28019: CALL_OW 72
28023: AND
28024: PUSH
28025: LD_EXP 78
28029: PUSH
28030: LD_VAR 0 1
28034: ARRAY
28035: PPUSH
28036: LD_INT 30
28038: PUSH
28039: LD_INT 3
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PPUSH
28046: CALL_OW 72
28050: NOT
28051: AND
28052: IFFALSE 28266
// begin if sci >= 6 then
28054: LD_VAR 0 8
28058: PUSH
28059: LD_INT 6
28061: GREATEREQUAL
28062: IFFALSE 28066
// exit ;
28064: GO 30485
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28066: LD_ADDR_EXP 120
28070: PUSH
28071: LD_EXP 120
28075: PPUSH
28076: LD_VAR 0 1
28080: PPUSH
28081: LD_INT 2
28083: PPUSH
28084: CALL_OW 1
28088: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28089: LD_ADDR_VAR 0 9
28093: PUSH
28094: LD_VAR 0 4
28098: PUSH
28099: LD_VAR 0 8
28103: DIFF
28104: PPUSH
28105: LD_INT 4
28107: PPUSH
28108: CALL 88657 0 2
28112: ST_TO_ADDR
// p := [ ] ;
28113: LD_ADDR_VAR 0 11
28117: PUSH
28118: EMPTY
28119: ST_TO_ADDR
// if sci < 6 and sort > 6 then
28120: LD_VAR 0 8
28124: PUSH
28125: LD_INT 6
28127: LESS
28128: PUSH
28129: LD_VAR 0 9
28133: PUSH
28134: LD_INT 6
28136: GREATER
28137: AND
28138: IFFALSE 28219
// begin for i = 1 to 6 - sci do
28140: LD_ADDR_VAR 0 3
28144: PUSH
28145: DOUBLE
28146: LD_INT 1
28148: DEC
28149: ST_TO_ADDR
28150: LD_INT 6
28152: PUSH
28153: LD_VAR 0 8
28157: MINUS
28158: PUSH
28159: FOR_TO
28160: IFFALSE 28215
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
28162: LD_ADDR_VAR 0 11
28166: PUSH
28167: LD_VAR 0 11
28171: PPUSH
28172: LD_VAR 0 11
28176: PUSH
28177: LD_INT 1
28179: PLUS
28180: PPUSH
28181: LD_VAR 0 9
28185: PUSH
28186: LD_INT 1
28188: ARRAY
28189: PPUSH
28190: CALL_OW 2
28194: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
28195: LD_ADDR_VAR 0 9
28199: PUSH
28200: LD_VAR 0 9
28204: PPUSH
28205: LD_INT 1
28207: PPUSH
28208: CALL_OW 3
28212: ST_TO_ADDR
// end ;
28213: GO 28159
28215: POP
28216: POP
// end else
28217: GO 28239
// if sort then
28219: LD_VAR 0 9
28223: IFFALSE 28239
// p := sort [ 1 ] ;
28225: LD_ADDR_VAR 0 11
28229: PUSH
28230: LD_VAR 0 9
28234: PUSH
28235: LD_INT 1
28237: ARRAY
28238: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
28239: LD_ADDR_VAR 0 2
28243: PUSH
28244: LD_INT 0
28246: PUSH
28247: LD_INT 0
28249: PUSH
28250: LD_INT 0
28252: PUSH
28253: LD_VAR 0 11
28257: PUSH
28258: EMPTY
28259: LIST
28260: LIST
28261: LIST
28262: LIST
28263: ST_TO_ADDR
// exit ;
28264: GO 30485
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28266: LD_EXP 105
28270: PUSH
28271: LD_EXP 104
28275: PUSH
28276: LD_VAR 0 1
28280: ARRAY
28281: ARRAY
28282: PUSH
28283: LD_EXP 78
28287: PUSH
28288: LD_VAR 0 1
28292: ARRAY
28293: PPUSH
28294: LD_INT 2
28296: PUSH
28297: LD_INT 30
28299: PUSH
28300: LD_INT 6
28302: PUSH
28303: EMPTY
28304: LIST
28305: LIST
28306: PUSH
28307: LD_INT 30
28309: PUSH
28310: LD_INT 7
28312: PUSH
28313: EMPTY
28314: LIST
28315: LIST
28316: PUSH
28317: LD_INT 30
28319: PUSH
28320: LD_INT 8
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PUSH
28327: EMPTY
28328: LIST
28329: LIST
28330: LIST
28331: LIST
28332: PPUSH
28333: CALL_OW 72
28337: AND
28338: PUSH
28339: LD_EXP 78
28343: PUSH
28344: LD_VAR 0 1
28348: ARRAY
28349: PPUSH
28350: LD_INT 30
28352: PUSH
28353: LD_INT 3
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PPUSH
28360: CALL_OW 72
28364: AND
28365: IFFALSE 29099
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
28367: LD_ADDR_EXP 120
28371: PUSH
28372: LD_EXP 120
28376: PPUSH
28377: LD_VAR 0 1
28381: PPUSH
28382: LD_INT 3
28384: PPUSH
28385: CALL_OW 1
28389: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28390: LD_ADDR_VAR 0 2
28394: PUSH
28395: LD_INT 0
28397: PUSH
28398: LD_INT 0
28400: PUSH
28401: LD_INT 0
28403: PUSH
28404: LD_INT 0
28406: PUSH
28407: EMPTY
28408: LIST
28409: LIST
28410: LIST
28411: LIST
28412: ST_TO_ADDR
// if not eng then
28413: LD_VAR 0 6
28417: NOT
28418: IFFALSE 28481
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
28420: LD_ADDR_VAR 0 11
28424: PUSH
28425: LD_VAR 0 4
28429: PPUSH
28430: LD_INT 2
28432: PPUSH
28433: CALL 88657 0 2
28437: PUSH
28438: LD_INT 1
28440: ARRAY
28441: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
28442: LD_ADDR_VAR 0 2
28446: PUSH
28447: LD_VAR 0 2
28451: PPUSH
28452: LD_INT 2
28454: PPUSH
28455: LD_VAR 0 11
28459: PPUSH
28460: CALL_OW 1
28464: ST_TO_ADDR
// tmp := tmp diff p ;
28465: LD_ADDR_VAR 0 4
28469: PUSH
28470: LD_VAR 0 4
28474: PUSH
28475: LD_VAR 0 11
28479: DIFF
28480: ST_TO_ADDR
// end ; if tmp and sci < 6 then
28481: LD_VAR 0 4
28485: PUSH
28486: LD_VAR 0 8
28490: PUSH
28491: LD_INT 6
28493: LESS
28494: AND
28495: IFFALSE 28683
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
28497: LD_ADDR_VAR 0 9
28501: PUSH
28502: LD_VAR 0 4
28506: PUSH
28507: LD_VAR 0 8
28511: PUSH
28512: LD_VAR 0 7
28516: UNION
28517: DIFF
28518: PPUSH
28519: LD_INT 4
28521: PPUSH
28522: CALL 88657 0 2
28526: ST_TO_ADDR
// p := [ ] ;
28527: LD_ADDR_VAR 0 11
28531: PUSH
28532: EMPTY
28533: ST_TO_ADDR
// if sort then
28534: LD_VAR 0 9
28538: IFFALSE 28654
// for i = 1 to 6 - sci do
28540: LD_ADDR_VAR 0 3
28544: PUSH
28545: DOUBLE
28546: LD_INT 1
28548: DEC
28549: ST_TO_ADDR
28550: LD_INT 6
28552: PUSH
28553: LD_VAR 0 8
28557: MINUS
28558: PUSH
28559: FOR_TO
28560: IFFALSE 28652
// begin if i = sort then
28562: LD_VAR 0 3
28566: PUSH
28567: LD_VAR 0 9
28571: EQUAL
28572: IFFALSE 28576
// break ;
28574: GO 28652
// if GetClass ( i ) = 4 then
28576: LD_VAR 0 3
28580: PPUSH
28581: CALL_OW 257
28585: PUSH
28586: LD_INT 4
28588: EQUAL
28589: IFFALSE 28593
// continue ;
28591: GO 28559
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28593: LD_ADDR_VAR 0 11
28597: PUSH
28598: LD_VAR 0 11
28602: PPUSH
28603: LD_VAR 0 11
28607: PUSH
28608: LD_INT 1
28610: PLUS
28611: PPUSH
28612: LD_VAR 0 9
28616: PUSH
28617: LD_VAR 0 3
28621: ARRAY
28622: PPUSH
28623: CALL_OW 2
28627: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28628: LD_ADDR_VAR 0 4
28632: PUSH
28633: LD_VAR 0 4
28637: PUSH
28638: LD_VAR 0 9
28642: PUSH
28643: LD_VAR 0 3
28647: ARRAY
28648: DIFF
28649: ST_TO_ADDR
// end ;
28650: GO 28559
28652: POP
28653: POP
// if p then
28654: LD_VAR 0 11
28658: IFFALSE 28683
// result := Replace ( result , 4 , p ) ;
28660: LD_ADDR_VAR 0 2
28664: PUSH
28665: LD_VAR 0 2
28669: PPUSH
28670: LD_INT 4
28672: PPUSH
28673: LD_VAR 0 11
28677: PPUSH
28678: CALL_OW 1
28682: ST_TO_ADDR
// end ; if tmp and mech < 6 then
28683: LD_VAR 0 4
28687: PUSH
28688: LD_VAR 0 7
28692: PUSH
28693: LD_INT 6
28695: LESS
28696: AND
28697: IFFALSE 28885
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28699: LD_ADDR_VAR 0 9
28703: PUSH
28704: LD_VAR 0 4
28708: PUSH
28709: LD_VAR 0 8
28713: PUSH
28714: LD_VAR 0 7
28718: UNION
28719: DIFF
28720: PPUSH
28721: LD_INT 3
28723: PPUSH
28724: CALL 88657 0 2
28728: ST_TO_ADDR
// p := [ ] ;
28729: LD_ADDR_VAR 0 11
28733: PUSH
28734: EMPTY
28735: ST_TO_ADDR
// if sort then
28736: LD_VAR 0 9
28740: IFFALSE 28856
// for i = 1 to 6 - mech do
28742: LD_ADDR_VAR 0 3
28746: PUSH
28747: DOUBLE
28748: LD_INT 1
28750: DEC
28751: ST_TO_ADDR
28752: LD_INT 6
28754: PUSH
28755: LD_VAR 0 7
28759: MINUS
28760: PUSH
28761: FOR_TO
28762: IFFALSE 28854
// begin if i = sort then
28764: LD_VAR 0 3
28768: PUSH
28769: LD_VAR 0 9
28773: EQUAL
28774: IFFALSE 28778
// break ;
28776: GO 28854
// if GetClass ( i ) = 3 then
28778: LD_VAR 0 3
28782: PPUSH
28783: CALL_OW 257
28787: PUSH
28788: LD_INT 3
28790: EQUAL
28791: IFFALSE 28795
// continue ;
28793: GO 28761
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28795: LD_ADDR_VAR 0 11
28799: PUSH
28800: LD_VAR 0 11
28804: PPUSH
28805: LD_VAR 0 11
28809: PUSH
28810: LD_INT 1
28812: PLUS
28813: PPUSH
28814: LD_VAR 0 9
28818: PUSH
28819: LD_VAR 0 3
28823: ARRAY
28824: PPUSH
28825: CALL_OW 2
28829: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28830: LD_ADDR_VAR 0 4
28834: PUSH
28835: LD_VAR 0 4
28839: PUSH
28840: LD_VAR 0 9
28844: PUSH
28845: LD_VAR 0 3
28849: ARRAY
28850: DIFF
28851: ST_TO_ADDR
// end ;
28852: GO 28761
28854: POP
28855: POP
// if p then
28856: LD_VAR 0 11
28860: IFFALSE 28885
// result := Replace ( result , 3 , p ) ;
28862: LD_ADDR_VAR 0 2
28866: PUSH
28867: LD_VAR 0 2
28871: PPUSH
28872: LD_INT 3
28874: PPUSH
28875: LD_VAR 0 11
28879: PPUSH
28880: CALL_OW 1
28884: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28885: LD_VAR 0 4
28889: PUSH
28890: LD_INT 6
28892: GREATER
28893: PUSH
28894: LD_VAR 0 6
28898: PUSH
28899: LD_INT 6
28901: LESS
28902: AND
28903: IFFALSE 29097
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28905: LD_ADDR_VAR 0 9
28909: PUSH
28910: LD_VAR 0 4
28914: PUSH
28915: LD_VAR 0 8
28919: PUSH
28920: LD_VAR 0 7
28924: UNION
28925: PUSH
28926: LD_VAR 0 6
28930: UNION
28931: DIFF
28932: PPUSH
28933: LD_INT 2
28935: PPUSH
28936: CALL 88657 0 2
28940: ST_TO_ADDR
// p := [ ] ;
28941: LD_ADDR_VAR 0 11
28945: PUSH
28946: EMPTY
28947: ST_TO_ADDR
// if sort then
28948: LD_VAR 0 9
28952: IFFALSE 29068
// for i = 1 to 6 - eng do
28954: LD_ADDR_VAR 0 3
28958: PUSH
28959: DOUBLE
28960: LD_INT 1
28962: DEC
28963: ST_TO_ADDR
28964: LD_INT 6
28966: PUSH
28967: LD_VAR 0 6
28971: MINUS
28972: PUSH
28973: FOR_TO
28974: IFFALSE 29066
// begin if i = sort then
28976: LD_VAR 0 3
28980: PUSH
28981: LD_VAR 0 9
28985: EQUAL
28986: IFFALSE 28990
// break ;
28988: GO 29066
// if GetClass ( i ) = 2 then
28990: LD_VAR 0 3
28994: PPUSH
28995: CALL_OW 257
28999: PUSH
29000: LD_INT 2
29002: EQUAL
29003: IFFALSE 29007
// continue ;
29005: GO 28973
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29007: LD_ADDR_VAR 0 11
29011: PUSH
29012: LD_VAR 0 11
29016: PPUSH
29017: LD_VAR 0 11
29021: PUSH
29022: LD_INT 1
29024: PLUS
29025: PPUSH
29026: LD_VAR 0 9
29030: PUSH
29031: LD_VAR 0 3
29035: ARRAY
29036: PPUSH
29037: CALL_OW 2
29041: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29042: LD_ADDR_VAR 0 4
29046: PUSH
29047: LD_VAR 0 4
29051: PUSH
29052: LD_VAR 0 9
29056: PUSH
29057: LD_VAR 0 3
29061: ARRAY
29062: DIFF
29063: ST_TO_ADDR
// end ;
29064: GO 28973
29066: POP
29067: POP
// if p then
29068: LD_VAR 0 11
29072: IFFALSE 29097
// result := Replace ( result , 2 , p ) ;
29074: LD_ADDR_VAR 0 2
29078: PUSH
29079: LD_VAR 0 2
29083: PPUSH
29084: LD_INT 2
29086: PPUSH
29087: LD_VAR 0 11
29091: PPUSH
29092: CALL_OW 1
29096: ST_TO_ADDR
// end ; exit ;
29097: GO 30485
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29099: LD_EXP 105
29103: PUSH
29104: LD_EXP 104
29108: PUSH
29109: LD_VAR 0 1
29113: ARRAY
29114: ARRAY
29115: NOT
29116: PUSH
29117: LD_EXP 78
29121: PUSH
29122: LD_VAR 0 1
29126: ARRAY
29127: PPUSH
29128: LD_INT 30
29130: PUSH
29131: LD_INT 3
29133: PUSH
29134: EMPTY
29135: LIST
29136: LIST
29137: PPUSH
29138: CALL_OW 72
29142: AND
29143: PUSH
29144: LD_EXP 83
29148: PUSH
29149: LD_VAR 0 1
29153: ARRAY
29154: AND
29155: IFFALSE 29763
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
29157: LD_ADDR_EXP 120
29161: PUSH
29162: LD_EXP 120
29166: PPUSH
29167: LD_VAR 0 1
29171: PPUSH
29172: LD_INT 5
29174: PPUSH
29175: CALL_OW 1
29179: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29180: LD_ADDR_VAR 0 2
29184: PUSH
29185: LD_INT 0
29187: PUSH
29188: LD_INT 0
29190: PUSH
29191: LD_INT 0
29193: PUSH
29194: LD_INT 0
29196: PUSH
29197: EMPTY
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: ST_TO_ADDR
// if sci > 1 then
29203: LD_VAR 0 8
29207: PUSH
29208: LD_INT 1
29210: GREATER
29211: IFFALSE 29239
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
29213: LD_ADDR_VAR 0 4
29217: PUSH
29218: LD_VAR 0 4
29222: PUSH
29223: LD_VAR 0 8
29227: PUSH
29228: LD_VAR 0 8
29232: PUSH
29233: LD_INT 1
29235: ARRAY
29236: DIFF
29237: DIFF
29238: ST_TO_ADDR
// if tmp and not sci then
29239: LD_VAR 0 4
29243: PUSH
29244: LD_VAR 0 8
29248: NOT
29249: AND
29250: IFFALSE 29319
// begin sort := SortBySkill ( tmp , 4 ) ;
29252: LD_ADDR_VAR 0 9
29256: PUSH
29257: LD_VAR 0 4
29261: PPUSH
29262: LD_INT 4
29264: PPUSH
29265: CALL 88657 0 2
29269: ST_TO_ADDR
// if sort then
29270: LD_VAR 0 9
29274: IFFALSE 29290
// p := sort [ 1 ] ;
29276: LD_ADDR_VAR 0 11
29280: PUSH
29281: LD_VAR 0 9
29285: PUSH
29286: LD_INT 1
29288: ARRAY
29289: ST_TO_ADDR
// if p then
29290: LD_VAR 0 11
29294: IFFALSE 29319
// result := Replace ( result , 4 , p ) ;
29296: LD_ADDR_VAR 0 2
29300: PUSH
29301: LD_VAR 0 2
29305: PPUSH
29306: LD_INT 4
29308: PPUSH
29309: LD_VAR 0 11
29313: PPUSH
29314: CALL_OW 1
29318: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29319: LD_ADDR_VAR 0 4
29323: PUSH
29324: LD_VAR 0 4
29328: PUSH
29329: LD_VAR 0 7
29333: DIFF
29334: ST_TO_ADDR
// if tmp and mech < 6 then
29335: LD_VAR 0 4
29339: PUSH
29340: LD_VAR 0 7
29344: PUSH
29345: LD_INT 6
29347: LESS
29348: AND
29349: IFFALSE 29537
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29351: LD_ADDR_VAR 0 9
29355: PUSH
29356: LD_VAR 0 4
29360: PUSH
29361: LD_VAR 0 8
29365: PUSH
29366: LD_VAR 0 7
29370: UNION
29371: DIFF
29372: PPUSH
29373: LD_INT 3
29375: PPUSH
29376: CALL 88657 0 2
29380: ST_TO_ADDR
// p := [ ] ;
29381: LD_ADDR_VAR 0 11
29385: PUSH
29386: EMPTY
29387: ST_TO_ADDR
// if sort then
29388: LD_VAR 0 9
29392: IFFALSE 29508
// for i = 1 to 6 - mech do
29394: LD_ADDR_VAR 0 3
29398: PUSH
29399: DOUBLE
29400: LD_INT 1
29402: DEC
29403: ST_TO_ADDR
29404: LD_INT 6
29406: PUSH
29407: LD_VAR 0 7
29411: MINUS
29412: PUSH
29413: FOR_TO
29414: IFFALSE 29506
// begin if i = sort then
29416: LD_VAR 0 3
29420: PUSH
29421: LD_VAR 0 9
29425: EQUAL
29426: IFFALSE 29430
// break ;
29428: GO 29506
// if GetClass ( i ) = 3 then
29430: LD_VAR 0 3
29434: PPUSH
29435: CALL_OW 257
29439: PUSH
29440: LD_INT 3
29442: EQUAL
29443: IFFALSE 29447
// continue ;
29445: GO 29413
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29447: LD_ADDR_VAR 0 11
29451: PUSH
29452: LD_VAR 0 11
29456: PPUSH
29457: LD_VAR 0 11
29461: PUSH
29462: LD_INT 1
29464: PLUS
29465: PPUSH
29466: LD_VAR 0 9
29470: PUSH
29471: LD_VAR 0 3
29475: ARRAY
29476: PPUSH
29477: CALL_OW 2
29481: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29482: LD_ADDR_VAR 0 4
29486: PUSH
29487: LD_VAR 0 4
29491: PUSH
29492: LD_VAR 0 9
29496: PUSH
29497: LD_VAR 0 3
29501: ARRAY
29502: DIFF
29503: ST_TO_ADDR
// end ;
29504: GO 29413
29506: POP
29507: POP
// if p then
29508: LD_VAR 0 11
29512: IFFALSE 29537
// result := Replace ( result , 3 , p ) ;
29514: LD_ADDR_VAR 0 2
29518: PUSH
29519: LD_VAR 0 2
29523: PPUSH
29524: LD_INT 3
29526: PPUSH
29527: LD_VAR 0 11
29531: PPUSH
29532: CALL_OW 1
29536: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29537: LD_ADDR_VAR 0 4
29541: PUSH
29542: LD_VAR 0 4
29546: PUSH
29547: LD_VAR 0 6
29551: DIFF
29552: ST_TO_ADDR
// if tmp and eng < 6 then
29553: LD_VAR 0 4
29557: PUSH
29558: LD_VAR 0 6
29562: PUSH
29563: LD_INT 6
29565: LESS
29566: AND
29567: IFFALSE 29761
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29569: LD_ADDR_VAR 0 9
29573: PUSH
29574: LD_VAR 0 4
29578: PUSH
29579: LD_VAR 0 8
29583: PUSH
29584: LD_VAR 0 7
29588: UNION
29589: PUSH
29590: LD_VAR 0 6
29594: UNION
29595: DIFF
29596: PPUSH
29597: LD_INT 2
29599: PPUSH
29600: CALL 88657 0 2
29604: ST_TO_ADDR
// p := [ ] ;
29605: LD_ADDR_VAR 0 11
29609: PUSH
29610: EMPTY
29611: ST_TO_ADDR
// if sort then
29612: LD_VAR 0 9
29616: IFFALSE 29732
// for i = 1 to 6 - eng do
29618: LD_ADDR_VAR 0 3
29622: PUSH
29623: DOUBLE
29624: LD_INT 1
29626: DEC
29627: ST_TO_ADDR
29628: LD_INT 6
29630: PUSH
29631: LD_VAR 0 6
29635: MINUS
29636: PUSH
29637: FOR_TO
29638: IFFALSE 29730
// begin if i = sort then
29640: LD_VAR 0 3
29644: PUSH
29645: LD_VAR 0 9
29649: EQUAL
29650: IFFALSE 29654
// break ;
29652: GO 29730
// if GetClass ( i ) = 2 then
29654: LD_VAR 0 3
29658: PPUSH
29659: CALL_OW 257
29663: PUSH
29664: LD_INT 2
29666: EQUAL
29667: IFFALSE 29671
// continue ;
29669: GO 29637
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29671: LD_ADDR_VAR 0 11
29675: PUSH
29676: LD_VAR 0 11
29680: PPUSH
29681: LD_VAR 0 11
29685: PUSH
29686: LD_INT 1
29688: PLUS
29689: PPUSH
29690: LD_VAR 0 9
29694: PUSH
29695: LD_VAR 0 3
29699: ARRAY
29700: PPUSH
29701: CALL_OW 2
29705: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29706: LD_ADDR_VAR 0 4
29710: PUSH
29711: LD_VAR 0 4
29715: PUSH
29716: LD_VAR 0 9
29720: PUSH
29721: LD_VAR 0 3
29725: ARRAY
29726: DIFF
29727: ST_TO_ADDR
// end ;
29728: GO 29637
29730: POP
29731: POP
// if p then
29732: LD_VAR 0 11
29736: IFFALSE 29761
// result := Replace ( result , 2 , p ) ;
29738: LD_ADDR_VAR 0 2
29742: PUSH
29743: LD_VAR 0 2
29747: PPUSH
29748: LD_INT 2
29750: PPUSH
29751: LD_VAR 0 11
29755: PPUSH
29756: CALL_OW 1
29760: ST_TO_ADDR
// end ; exit ;
29761: GO 30485
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
29763: LD_EXP 105
29767: PUSH
29768: LD_EXP 104
29772: PUSH
29773: LD_VAR 0 1
29777: ARRAY
29778: ARRAY
29779: NOT
29780: PUSH
29781: LD_EXP 78
29785: PUSH
29786: LD_VAR 0 1
29790: ARRAY
29791: PPUSH
29792: LD_INT 30
29794: PUSH
29795: LD_INT 3
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PPUSH
29802: CALL_OW 72
29806: AND
29807: PUSH
29808: LD_EXP 83
29812: PUSH
29813: LD_VAR 0 1
29817: ARRAY
29818: NOT
29819: AND
29820: IFFALSE 30485
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29822: LD_ADDR_EXP 120
29826: PUSH
29827: LD_EXP 120
29831: PPUSH
29832: LD_VAR 0 1
29836: PPUSH
29837: LD_INT 6
29839: PPUSH
29840: CALL_OW 1
29844: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29845: LD_ADDR_VAR 0 2
29849: PUSH
29850: LD_INT 0
29852: PUSH
29853: LD_INT 0
29855: PUSH
29856: LD_INT 0
29858: PUSH
29859: LD_INT 0
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: LIST
29866: LIST
29867: ST_TO_ADDR
// if sci >= 1 then
29868: LD_VAR 0 8
29872: PUSH
29873: LD_INT 1
29875: GREATEREQUAL
29876: IFFALSE 29898
// tmp := tmp diff sci [ 1 ] ;
29878: LD_ADDR_VAR 0 4
29882: PUSH
29883: LD_VAR 0 4
29887: PUSH
29888: LD_VAR 0 8
29892: PUSH
29893: LD_INT 1
29895: ARRAY
29896: DIFF
29897: ST_TO_ADDR
// if tmp and not sci then
29898: LD_VAR 0 4
29902: PUSH
29903: LD_VAR 0 8
29907: NOT
29908: AND
29909: IFFALSE 29978
// begin sort := SortBySkill ( tmp , 4 ) ;
29911: LD_ADDR_VAR 0 9
29915: PUSH
29916: LD_VAR 0 4
29920: PPUSH
29921: LD_INT 4
29923: PPUSH
29924: CALL 88657 0 2
29928: ST_TO_ADDR
// if sort then
29929: LD_VAR 0 9
29933: IFFALSE 29949
// p := sort [ 1 ] ;
29935: LD_ADDR_VAR 0 11
29939: PUSH
29940: LD_VAR 0 9
29944: PUSH
29945: LD_INT 1
29947: ARRAY
29948: ST_TO_ADDR
// if p then
29949: LD_VAR 0 11
29953: IFFALSE 29978
// result := Replace ( result , 4 , p ) ;
29955: LD_ADDR_VAR 0 2
29959: PUSH
29960: LD_VAR 0 2
29964: PPUSH
29965: LD_INT 4
29967: PPUSH
29968: LD_VAR 0 11
29972: PPUSH
29973: CALL_OW 1
29977: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29978: LD_ADDR_VAR 0 4
29982: PUSH
29983: LD_VAR 0 4
29987: PUSH
29988: LD_VAR 0 7
29992: DIFF
29993: ST_TO_ADDR
// if tmp and mech < 6 then
29994: LD_VAR 0 4
29998: PUSH
29999: LD_VAR 0 7
30003: PUSH
30004: LD_INT 6
30006: LESS
30007: AND
30008: IFFALSE 30190
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
30010: LD_ADDR_VAR 0 9
30014: PUSH
30015: LD_VAR 0 4
30019: PUSH
30020: LD_VAR 0 7
30024: DIFF
30025: PPUSH
30026: LD_INT 3
30028: PPUSH
30029: CALL 88657 0 2
30033: ST_TO_ADDR
// p := [ ] ;
30034: LD_ADDR_VAR 0 11
30038: PUSH
30039: EMPTY
30040: ST_TO_ADDR
// if sort then
30041: LD_VAR 0 9
30045: IFFALSE 30161
// for i = 1 to 6 - mech do
30047: LD_ADDR_VAR 0 3
30051: PUSH
30052: DOUBLE
30053: LD_INT 1
30055: DEC
30056: ST_TO_ADDR
30057: LD_INT 6
30059: PUSH
30060: LD_VAR 0 7
30064: MINUS
30065: PUSH
30066: FOR_TO
30067: IFFALSE 30159
// begin if i = sort then
30069: LD_VAR 0 3
30073: PUSH
30074: LD_VAR 0 9
30078: EQUAL
30079: IFFALSE 30083
// break ;
30081: GO 30159
// if GetClass ( i ) = 3 then
30083: LD_VAR 0 3
30087: PPUSH
30088: CALL_OW 257
30092: PUSH
30093: LD_INT 3
30095: EQUAL
30096: IFFALSE 30100
// continue ;
30098: GO 30066
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30100: LD_ADDR_VAR 0 11
30104: PUSH
30105: LD_VAR 0 11
30109: PPUSH
30110: LD_VAR 0 11
30114: PUSH
30115: LD_INT 1
30117: PLUS
30118: PPUSH
30119: LD_VAR 0 9
30123: PUSH
30124: LD_VAR 0 3
30128: ARRAY
30129: PPUSH
30130: CALL_OW 2
30134: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30135: LD_ADDR_VAR 0 4
30139: PUSH
30140: LD_VAR 0 4
30144: PUSH
30145: LD_VAR 0 9
30149: PUSH
30150: LD_VAR 0 3
30154: ARRAY
30155: DIFF
30156: ST_TO_ADDR
// end ;
30157: GO 30066
30159: POP
30160: POP
// if p then
30161: LD_VAR 0 11
30165: IFFALSE 30190
// result := Replace ( result , 3 , p ) ;
30167: LD_ADDR_VAR 0 2
30171: PUSH
30172: LD_VAR 0 2
30176: PPUSH
30177: LD_INT 3
30179: PPUSH
30180: LD_VAR 0 11
30184: PPUSH
30185: CALL_OW 1
30189: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30190: LD_ADDR_VAR 0 4
30194: PUSH
30195: LD_VAR 0 4
30199: PUSH
30200: LD_VAR 0 6
30204: DIFF
30205: ST_TO_ADDR
// if tmp and eng < 4 then
30206: LD_VAR 0 4
30210: PUSH
30211: LD_VAR 0 6
30215: PUSH
30216: LD_INT 4
30218: LESS
30219: AND
30220: IFFALSE 30410
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
30222: LD_ADDR_VAR 0 9
30226: PUSH
30227: LD_VAR 0 4
30231: PUSH
30232: LD_VAR 0 7
30236: PUSH
30237: LD_VAR 0 6
30241: UNION
30242: DIFF
30243: PPUSH
30244: LD_INT 2
30246: PPUSH
30247: CALL 88657 0 2
30251: ST_TO_ADDR
// p := [ ] ;
30252: LD_ADDR_VAR 0 11
30256: PUSH
30257: EMPTY
30258: ST_TO_ADDR
// if sort then
30259: LD_VAR 0 9
30263: IFFALSE 30379
// for i = 1 to 4 - eng do
30265: LD_ADDR_VAR 0 3
30269: PUSH
30270: DOUBLE
30271: LD_INT 1
30273: DEC
30274: ST_TO_ADDR
30275: LD_INT 4
30277: PUSH
30278: LD_VAR 0 6
30282: MINUS
30283: PUSH
30284: FOR_TO
30285: IFFALSE 30377
// begin if i = sort then
30287: LD_VAR 0 3
30291: PUSH
30292: LD_VAR 0 9
30296: EQUAL
30297: IFFALSE 30301
// break ;
30299: GO 30377
// if GetClass ( i ) = 2 then
30301: LD_VAR 0 3
30305: PPUSH
30306: CALL_OW 257
30310: PUSH
30311: LD_INT 2
30313: EQUAL
30314: IFFALSE 30318
// continue ;
30316: GO 30284
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30318: LD_ADDR_VAR 0 11
30322: PUSH
30323: LD_VAR 0 11
30327: PPUSH
30328: LD_VAR 0 11
30332: PUSH
30333: LD_INT 1
30335: PLUS
30336: PPUSH
30337: LD_VAR 0 9
30341: PUSH
30342: LD_VAR 0 3
30346: ARRAY
30347: PPUSH
30348: CALL_OW 2
30352: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30353: LD_ADDR_VAR 0 4
30357: PUSH
30358: LD_VAR 0 4
30362: PUSH
30363: LD_VAR 0 9
30367: PUSH
30368: LD_VAR 0 3
30372: ARRAY
30373: DIFF
30374: ST_TO_ADDR
// end ;
30375: GO 30284
30377: POP
30378: POP
// if p then
30379: LD_VAR 0 11
30383: IFFALSE 30408
// result := Replace ( result , 2 , p ) ;
30385: LD_ADDR_VAR 0 2
30389: PUSH
30390: LD_VAR 0 2
30394: PPUSH
30395: LD_INT 2
30397: PPUSH
30398: LD_VAR 0 11
30402: PPUSH
30403: CALL_OW 1
30407: ST_TO_ADDR
// end else
30408: GO 30454
// for i = eng downto 5 do
30410: LD_ADDR_VAR 0 3
30414: PUSH
30415: DOUBLE
30416: LD_VAR 0 6
30420: INC
30421: ST_TO_ADDR
30422: LD_INT 5
30424: PUSH
30425: FOR_DOWNTO
30426: IFFALSE 30452
// tmp := tmp union eng [ i ] ;
30428: LD_ADDR_VAR 0 4
30432: PUSH
30433: LD_VAR 0 4
30437: PUSH
30438: LD_VAR 0 6
30442: PUSH
30443: LD_VAR 0 3
30447: ARRAY
30448: UNION
30449: ST_TO_ADDR
30450: GO 30425
30452: POP
30453: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
30454: LD_ADDR_VAR 0 2
30458: PUSH
30459: LD_VAR 0 2
30463: PPUSH
30464: LD_INT 1
30466: PPUSH
30467: LD_VAR 0 4
30471: PUSH
30472: LD_VAR 0 5
30476: DIFF
30477: PPUSH
30478: CALL_OW 1
30482: ST_TO_ADDR
// exit ;
30483: GO 30485
// end ; end ;
30485: LD_VAR 0 2
30489: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
30490: LD_INT 0
30492: PPUSH
30493: PPUSH
30494: PPUSH
// if not mc_bases then
30495: LD_EXP 78
30499: NOT
30500: IFFALSE 30504
// exit ;
30502: GO 30646
// for i = 1 to mc_bases do
30504: LD_ADDR_VAR 0 2
30508: PUSH
30509: DOUBLE
30510: LD_INT 1
30512: DEC
30513: ST_TO_ADDR
30514: LD_EXP 78
30518: PUSH
30519: FOR_TO
30520: IFFALSE 30637
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
30522: LD_ADDR_VAR 0 3
30526: PUSH
30527: LD_EXP 78
30531: PUSH
30532: LD_VAR 0 2
30536: ARRAY
30537: PPUSH
30538: LD_INT 21
30540: PUSH
30541: LD_INT 3
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 3
30550: PUSH
30551: LD_INT 2
30553: PUSH
30554: LD_INT 30
30556: PUSH
30557: LD_INT 29
30559: PUSH
30560: EMPTY
30561: LIST
30562: LIST
30563: PUSH
30564: LD_INT 30
30566: PUSH
30567: LD_INT 30
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: LIST
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 3
30585: PUSH
30586: LD_INT 24
30588: PUSH
30589: LD_INT 1000
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: LIST
30604: PPUSH
30605: CALL_OW 72
30609: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
30610: LD_ADDR_EXP 79
30614: PUSH
30615: LD_EXP 79
30619: PPUSH
30620: LD_VAR 0 2
30624: PPUSH
30625: LD_VAR 0 3
30629: PPUSH
30630: CALL_OW 1
30634: ST_TO_ADDR
// end ;
30635: GO 30519
30637: POP
30638: POP
// RaiseSailEvent ( 101 ) ;
30639: LD_INT 101
30641: PPUSH
30642: CALL_OW 427
// end ;
30646: LD_VAR 0 1
30650: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
30651: LD_INT 0
30653: PPUSH
30654: PPUSH
30655: PPUSH
30656: PPUSH
30657: PPUSH
30658: PPUSH
30659: PPUSH
// if not mc_bases then
30660: LD_EXP 78
30664: NOT
30665: IFFALSE 30669
// exit ;
30667: GO 31231
// for i = 1 to mc_bases do
30669: LD_ADDR_VAR 0 2
30673: PUSH
30674: DOUBLE
30675: LD_INT 1
30677: DEC
30678: ST_TO_ADDR
30679: LD_EXP 78
30683: PUSH
30684: FOR_TO
30685: IFFALSE 31222
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
30687: LD_ADDR_VAR 0 5
30691: PUSH
30692: LD_EXP 78
30696: PUSH
30697: LD_VAR 0 2
30701: ARRAY
30702: PUSH
30703: LD_EXP 107
30707: PUSH
30708: LD_VAR 0 2
30712: ARRAY
30713: UNION
30714: PPUSH
30715: LD_INT 21
30717: PUSH
30718: LD_INT 1
30720: PUSH
30721: EMPTY
30722: LIST
30723: LIST
30724: PUSH
30725: LD_INT 1
30727: PUSH
30728: LD_INT 3
30730: PUSH
30731: LD_INT 54
30733: PUSH
30734: EMPTY
30735: LIST
30736: PUSH
30737: EMPTY
30738: LIST
30739: LIST
30740: PUSH
30741: LD_INT 3
30743: PUSH
30744: LD_INT 24
30746: PUSH
30747: LD_INT 1000
30749: PUSH
30750: EMPTY
30751: LIST
30752: LIST
30753: PUSH
30754: EMPTY
30755: LIST
30756: LIST
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: LIST
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PPUSH
30767: CALL_OW 72
30771: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30772: LD_ADDR_VAR 0 6
30776: PUSH
30777: LD_EXP 78
30781: PUSH
30782: LD_VAR 0 2
30786: ARRAY
30787: PPUSH
30788: LD_INT 21
30790: PUSH
30791: LD_INT 1
30793: PUSH
30794: EMPTY
30795: LIST
30796: LIST
30797: PUSH
30798: LD_INT 1
30800: PUSH
30801: LD_INT 3
30803: PUSH
30804: LD_INT 54
30806: PUSH
30807: EMPTY
30808: LIST
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 3
30816: PUSH
30817: LD_INT 24
30819: PUSH
30820: LD_INT 250
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: LIST
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PPUSH
30840: CALL_OW 72
30844: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30845: LD_ADDR_VAR 0 7
30849: PUSH
30850: LD_VAR 0 5
30854: PUSH
30855: LD_VAR 0 6
30859: DIFF
30860: ST_TO_ADDR
// if not need_heal_1 then
30861: LD_VAR 0 6
30865: NOT
30866: IFFALSE 30899
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30868: LD_ADDR_EXP 81
30872: PUSH
30873: LD_EXP 81
30877: PPUSH
30878: LD_VAR 0 2
30882: PUSH
30883: LD_INT 1
30885: PUSH
30886: EMPTY
30887: LIST
30888: LIST
30889: PPUSH
30890: EMPTY
30891: PPUSH
30892: CALL 57810 0 3
30896: ST_TO_ADDR
30897: GO 30969
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30899: LD_ADDR_EXP 81
30903: PUSH
30904: LD_EXP 81
30908: PPUSH
30909: LD_VAR 0 2
30913: PUSH
30914: LD_INT 1
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: PPUSH
30921: LD_EXP 81
30925: PUSH
30926: LD_VAR 0 2
30930: ARRAY
30931: PUSH
30932: LD_INT 1
30934: ARRAY
30935: PPUSH
30936: LD_INT 3
30938: PUSH
30939: LD_INT 24
30941: PUSH
30942: LD_INT 1000
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PPUSH
30953: CALL_OW 72
30957: PUSH
30958: LD_VAR 0 6
30962: UNION
30963: PPUSH
30964: CALL 57810 0 3
30968: ST_TO_ADDR
// if not need_heal_2 then
30969: LD_VAR 0 7
30973: NOT
30974: IFFALSE 31007
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30976: LD_ADDR_EXP 81
30980: PUSH
30981: LD_EXP 81
30985: PPUSH
30986: LD_VAR 0 2
30990: PUSH
30991: LD_INT 2
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PPUSH
30998: EMPTY
30999: PPUSH
31000: CALL 57810 0 3
31004: ST_TO_ADDR
31005: GO 31039
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
31007: LD_ADDR_EXP 81
31011: PUSH
31012: LD_EXP 81
31016: PPUSH
31017: LD_VAR 0 2
31021: PUSH
31022: LD_INT 2
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PPUSH
31029: LD_VAR 0 7
31033: PPUSH
31034: CALL 57810 0 3
31038: ST_TO_ADDR
// if need_heal_2 then
31039: LD_VAR 0 7
31043: IFFALSE 31204
// for j in need_heal_2 do
31045: LD_ADDR_VAR 0 3
31049: PUSH
31050: LD_VAR 0 7
31054: PUSH
31055: FOR_IN
31056: IFFALSE 31202
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31058: LD_ADDR_VAR 0 5
31062: PUSH
31063: LD_EXP 78
31067: PUSH
31068: LD_VAR 0 2
31072: ARRAY
31073: PPUSH
31074: LD_INT 2
31076: PUSH
31077: LD_INT 30
31079: PUSH
31080: LD_INT 6
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: LD_INT 30
31089: PUSH
31090: LD_INT 7
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: LD_INT 30
31099: PUSH
31100: LD_INT 8
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 30
31109: PUSH
31110: LD_INT 0
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 30
31119: PUSH
31120: LD_INT 1
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: PPUSH
31135: CALL_OW 72
31139: ST_TO_ADDR
// if tmp then
31140: LD_VAR 0 5
31144: IFFALSE 31200
// begin k := NearestUnitToUnit ( tmp , j ) ;
31146: LD_ADDR_VAR 0 4
31150: PUSH
31151: LD_VAR 0 5
31155: PPUSH
31156: LD_VAR 0 3
31160: PPUSH
31161: CALL_OW 74
31165: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
31166: LD_VAR 0 3
31170: PPUSH
31171: LD_VAR 0 4
31175: PPUSH
31176: CALL_OW 296
31180: PUSH
31181: LD_INT 5
31183: GREATER
31184: IFFALSE 31200
// ComMoveToNearbyEntrance ( j , k ) ;
31186: LD_VAR 0 3
31190: PPUSH
31191: LD_VAR 0 4
31195: PPUSH
31196: CALL 91017 0 2
// end ; end ;
31200: GO 31055
31202: POP
31203: POP
// if not need_heal_1 and not need_heal_2 then
31204: LD_VAR 0 6
31208: NOT
31209: PUSH
31210: LD_VAR 0 7
31214: NOT
31215: AND
31216: IFFALSE 31220
// continue ;
31218: GO 30684
// end ;
31220: GO 30684
31222: POP
31223: POP
// RaiseSailEvent ( 102 ) ;
31224: LD_INT 102
31226: PPUSH
31227: CALL_OW 427
// end ;
31231: LD_VAR 0 1
31235: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
31236: LD_INT 0
31238: PPUSH
31239: PPUSH
31240: PPUSH
31241: PPUSH
31242: PPUSH
31243: PPUSH
31244: PPUSH
31245: PPUSH
// if not mc_bases then
31246: LD_EXP 78
31250: NOT
31251: IFFALSE 31255
// exit ;
31253: GO 32166
// for i = 1 to mc_bases do
31255: LD_ADDR_VAR 0 2
31259: PUSH
31260: DOUBLE
31261: LD_INT 1
31263: DEC
31264: ST_TO_ADDR
31265: LD_EXP 78
31269: PUSH
31270: FOR_TO
31271: IFFALSE 32164
// begin if not mc_building_need_repair [ i ] then
31273: LD_EXP 79
31277: PUSH
31278: LD_VAR 0 2
31282: ARRAY
31283: NOT
31284: IFFALSE 31469
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
31286: LD_ADDR_VAR 0 6
31290: PUSH
31291: LD_EXP 97
31295: PUSH
31296: LD_VAR 0 2
31300: ARRAY
31301: PPUSH
31302: LD_INT 3
31304: PUSH
31305: LD_INT 24
31307: PUSH
31308: LD_INT 1000
31310: PUSH
31311: EMPTY
31312: LIST
31313: LIST
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 2
31321: PUSH
31322: LD_INT 34
31324: PUSH
31325: LD_INT 13
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 34
31334: PUSH
31335: LD_INT 52
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: PUSH
31342: LD_INT 34
31344: PUSH
31345: LD_INT 88
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: LIST
31356: LIST
31357: PUSH
31358: EMPTY
31359: LIST
31360: LIST
31361: PPUSH
31362: CALL_OW 72
31366: ST_TO_ADDR
// if cranes then
31367: LD_VAR 0 6
31371: IFFALSE 31433
// for j in cranes do
31373: LD_ADDR_VAR 0 3
31377: PUSH
31378: LD_VAR 0 6
31382: PUSH
31383: FOR_IN
31384: IFFALSE 31431
// if not IsInArea ( j , mc_parking [ i ] ) then
31386: LD_VAR 0 3
31390: PPUSH
31391: LD_EXP 102
31395: PUSH
31396: LD_VAR 0 2
31400: ARRAY
31401: PPUSH
31402: CALL_OW 308
31406: NOT
31407: IFFALSE 31429
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31409: LD_VAR 0 3
31413: PPUSH
31414: LD_EXP 102
31418: PUSH
31419: LD_VAR 0 2
31423: ARRAY
31424: PPUSH
31425: CALL_OW 113
31429: GO 31383
31431: POP
31432: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
31433: LD_ADDR_EXP 80
31437: PUSH
31438: LD_EXP 80
31442: PPUSH
31443: LD_VAR 0 2
31447: PPUSH
31448: EMPTY
31449: PPUSH
31450: CALL_OW 1
31454: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
31455: LD_VAR 0 2
31459: PPUSH
31460: LD_INT 101
31462: PPUSH
31463: CALL 26323 0 2
// continue ;
31467: GO 31270
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
31469: LD_ADDR_EXP 84
31473: PUSH
31474: LD_EXP 84
31478: PPUSH
31479: LD_VAR 0 2
31483: PPUSH
31484: EMPTY
31485: PPUSH
31486: CALL_OW 1
31490: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31491: LD_VAR 0 2
31495: PPUSH
31496: LD_INT 103
31498: PPUSH
31499: CALL 26323 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
31503: LD_ADDR_VAR 0 5
31507: PUSH
31508: LD_EXP 78
31512: PUSH
31513: LD_VAR 0 2
31517: ARRAY
31518: PUSH
31519: LD_EXP 107
31523: PUSH
31524: LD_VAR 0 2
31528: ARRAY
31529: UNION
31530: PPUSH
31531: LD_INT 2
31533: PUSH
31534: LD_INT 25
31536: PUSH
31537: LD_INT 2
31539: PUSH
31540: EMPTY
31541: LIST
31542: LIST
31543: PUSH
31544: LD_INT 25
31546: PUSH
31547: LD_INT 16
31549: PUSH
31550: EMPTY
31551: LIST
31552: LIST
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: LIST
31558: PUSH
31559: EMPTY
31560: LIST
31561: PPUSH
31562: CALL_OW 72
31566: ST_TO_ADDR
// if mc_need_heal [ i ] then
31567: LD_EXP 81
31571: PUSH
31572: LD_VAR 0 2
31576: ARRAY
31577: IFFALSE 31621
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
31579: LD_ADDR_VAR 0 5
31583: PUSH
31584: LD_VAR 0 5
31588: PUSH
31589: LD_EXP 81
31593: PUSH
31594: LD_VAR 0 2
31598: ARRAY
31599: PUSH
31600: LD_INT 1
31602: ARRAY
31603: PUSH
31604: LD_EXP 81
31608: PUSH
31609: LD_VAR 0 2
31613: ARRAY
31614: PUSH
31615: LD_INT 2
31617: ARRAY
31618: UNION
31619: DIFF
31620: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
31621: LD_ADDR_VAR 0 6
31625: PUSH
31626: LD_EXP 97
31630: PUSH
31631: LD_VAR 0 2
31635: ARRAY
31636: PPUSH
31637: LD_INT 2
31639: PUSH
31640: LD_INT 34
31642: PUSH
31643: LD_INT 13
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 34
31652: PUSH
31653: LD_INT 52
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 34
31662: PUSH
31663: LD_INT 88
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: EMPTY
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: PPUSH
31676: CALL_OW 72
31680: ST_TO_ADDR
// if cranes then
31681: LD_VAR 0 6
31685: IFFALSE 31853
// begin for j in cranes do
31687: LD_ADDR_VAR 0 3
31691: PUSH
31692: LD_VAR 0 6
31696: PUSH
31697: FOR_IN
31698: IFFALSE 31851
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
31700: LD_VAR 0 3
31704: PPUSH
31705: CALL_OW 256
31709: PUSH
31710: LD_INT 1000
31712: EQUAL
31713: PUSH
31714: LD_VAR 0 3
31718: PPUSH
31719: CALL_OW 314
31723: NOT
31724: AND
31725: IFFALSE 31791
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
31727: LD_ADDR_VAR 0 8
31731: PUSH
31732: LD_EXP 79
31736: PUSH
31737: LD_VAR 0 2
31741: ARRAY
31742: PPUSH
31743: LD_VAR 0 3
31747: PPUSH
31748: CALL_OW 74
31752: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31753: LD_VAR 0 8
31757: PPUSH
31758: LD_INT 16
31760: PPUSH
31761: CALL 60407 0 2
31765: PUSH
31766: LD_INT 4
31768: ARRAY
31769: PUSH
31770: LD_INT 10
31772: LESS
31773: IFFALSE 31789
// ComRepairBuilding ( j , to_repair ) ;
31775: LD_VAR 0 3
31779: PPUSH
31780: LD_VAR 0 8
31784: PPUSH
31785: CALL_OW 130
// end else
31789: GO 31849
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
31791: LD_VAR 0 3
31795: PPUSH
31796: CALL_OW 256
31800: PUSH
31801: LD_INT 500
31803: LESS
31804: PUSH
31805: LD_VAR 0 3
31809: PPUSH
31810: LD_EXP 102
31814: PUSH
31815: LD_VAR 0 2
31819: ARRAY
31820: PPUSH
31821: CALL_OW 308
31825: NOT
31826: AND
31827: IFFALSE 31849
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31829: LD_VAR 0 3
31833: PPUSH
31834: LD_EXP 102
31838: PUSH
31839: LD_VAR 0 2
31843: ARRAY
31844: PPUSH
31845: CALL_OW 113
// end ;
31849: GO 31697
31851: POP
31852: POP
// end ; if tmp > 3 then
31853: LD_VAR 0 5
31857: PUSH
31858: LD_INT 3
31860: GREATER
31861: IFFALSE 31881
// tmp := ShrinkArray ( tmp , 4 ) ;
31863: LD_ADDR_VAR 0 5
31867: PUSH
31868: LD_VAR 0 5
31872: PPUSH
31873: LD_INT 4
31875: PPUSH
31876: CALL 90455 0 2
31880: ST_TO_ADDR
// if not tmp then
31881: LD_VAR 0 5
31885: NOT
31886: IFFALSE 31890
// continue ;
31888: GO 31270
// for j in tmp do
31890: LD_ADDR_VAR 0 3
31894: PUSH
31895: LD_VAR 0 5
31899: PUSH
31900: FOR_IN
31901: IFFALSE 32160
// begin if IsInUnit ( j ) then
31903: LD_VAR 0 3
31907: PPUSH
31908: CALL_OW 310
31912: IFFALSE 31923
// ComExitBuilding ( j ) ;
31914: LD_VAR 0 3
31918: PPUSH
31919: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31923: LD_VAR 0 3
31927: PUSH
31928: LD_EXP 80
31932: PUSH
31933: LD_VAR 0 2
31937: ARRAY
31938: IN
31939: NOT
31940: IFFALSE 31998
// begin SetTag ( j , 101 ) ;
31942: LD_VAR 0 3
31946: PPUSH
31947: LD_INT 101
31949: PPUSH
31950: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31954: LD_ADDR_EXP 80
31958: PUSH
31959: LD_EXP 80
31963: PPUSH
31964: LD_VAR 0 2
31968: PUSH
31969: LD_EXP 80
31973: PUSH
31974: LD_VAR 0 2
31978: ARRAY
31979: PUSH
31980: LD_INT 1
31982: PLUS
31983: PUSH
31984: EMPTY
31985: LIST
31986: LIST
31987: PPUSH
31988: LD_VAR 0 3
31992: PPUSH
31993: CALL 57810 0 3
31997: ST_TO_ADDR
// end ; wait ( 1 ) ;
31998: LD_INT 1
32000: PPUSH
32001: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
32005: LD_ADDR_VAR 0 7
32009: PUSH
32010: LD_EXP 79
32014: PUSH
32015: LD_VAR 0 2
32019: ARRAY
32020: ST_TO_ADDR
// if mc_scan [ i ] then
32021: LD_EXP 101
32025: PUSH
32026: LD_VAR 0 2
32030: ARRAY
32031: IFFALSE 32093
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
32033: LD_ADDR_VAR 0 7
32037: PUSH
32038: LD_EXP 79
32042: PUSH
32043: LD_VAR 0 2
32047: ARRAY
32048: PPUSH
32049: LD_INT 3
32051: PUSH
32052: LD_INT 30
32054: PUSH
32055: LD_INT 32
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: PUSH
32062: LD_INT 30
32064: PUSH
32065: LD_INT 33
32067: PUSH
32068: EMPTY
32069: LIST
32070: LIST
32071: PUSH
32072: LD_INT 30
32074: PUSH
32075: LD_INT 31
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: PPUSH
32088: CALL_OW 72
32092: ST_TO_ADDR
// if not to_repair_tmp then
32093: LD_VAR 0 7
32097: NOT
32098: IFFALSE 32102
// continue ;
32100: GO 31900
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32102: LD_ADDR_VAR 0 8
32106: PUSH
32107: LD_VAR 0 7
32111: PPUSH
32112: LD_VAR 0 3
32116: PPUSH
32117: CALL_OW 74
32121: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
32122: LD_VAR 0 8
32126: PPUSH
32127: LD_INT 16
32129: PPUSH
32130: CALL 60407 0 2
32134: PUSH
32135: LD_INT 4
32137: ARRAY
32138: PUSH
32139: LD_INT 14
32141: LESS
32142: IFFALSE 32158
// ComRepairBuilding ( j , to_repair ) ;
32144: LD_VAR 0 3
32148: PPUSH
32149: LD_VAR 0 8
32153: PPUSH
32154: CALL_OW 130
// end ;
32158: GO 31900
32160: POP
32161: POP
// end ;
32162: GO 31270
32164: POP
32165: POP
// end ;
32166: LD_VAR 0 1
32170: RET
// export function MC_Heal ; var i , j , tmp ; begin
32171: LD_INT 0
32173: PPUSH
32174: PPUSH
32175: PPUSH
32176: PPUSH
// if not mc_bases then
32177: LD_EXP 78
32181: NOT
32182: IFFALSE 32186
// exit ;
32184: GO 32588
// for i = 1 to mc_bases do
32186: LD_ADDR_VAR 0 2
32190: PUSH
32191: DOUBLE
32192: LD_INT 1
32194: DEC
32195: ST_TO_ADDR
32196: LD_EXP 78
32200: PUSH
32201: FOR_TO
32202: IFFALSE 32586
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
32204: LD_EXP 81
32208: PUSH
32209: LD_VAR 0 2
32213: ARRAY
32214: PUSH
32215: LD_INT 1
32217: ARRAY
32218: NOT
32219: PUSH
32220: LD_EXP 81
32224: PUSH
32225: LD_VAR 0 2
32229: ARRAY
32230: PUSH
32231: LD_INT 2
32233: ARRAY
32234: NOT
32235: AND
32236: IFFALSE 32274
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
32238: LD_ADDR_EXP 82
32242: PUSH
32243: LD_EXP 82
32247: PPUSH
32248: LD_VAR 0 2
32252: PPUSH
32253: EMPTY
32254: PPUSH
32255: CALL_OW 1
32259: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
32260: LD_VAR 0 2
32264: PPUSH
32265: LD_INT 102
32267: PPUSH
32268: CALL 26323 0 2
// continue ;
32272: GO 32201
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
32274: LD_ADDR_VAR 0 4
32278: PUSH
32279: LD_EXP 78
32283: PUSH
32284: LD_VAR 0 2
32288: ARRAY
32289: PPUSH
32290: LD_INT 25
32292: PUSH
32293: LD_INT 4
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PPUSH
32300: CALL_OW 72
32304: ST_TO_ADDR
// if not tmp then
32305: LD_VAR 0 4
32309: NOT
32310: IFFALSE 32314
// continue ;
32312: GO 32201
// if mc_taming [ i ] then
32314: LD_EXP 109
32318: PUSH
32319: LD_VAR 0 2
32323: ARRAY
32324: IFFALSE 32348
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
32326: LD_ADDR_EXP 109
32330: PUSH
32331: LD_EXP 109
32335: PPUSH
32336: LD_VAR 0 2
32340: PPUSH
32341: EMPTY
32342: PPUSH
32343: CALL_OW 1
32347: ST_TO_ADDR
// for j in tmp do
32348: LD_ADDR_VAR 0 3
32352: PUSH
32353: LD_VAR 0 4
32357: PUSH
32358: FOR_IN
32359: IFFALSE 32582
// begin if IsInUnit ( j ) then
32361: LD_VAR 0 3
32365: PPUSH
32366: CALL_OW 310
32370: IFFALSE 32381
// ComExitBuilding ( j ) ;
32372: LD_VAR 0 3
32376: PPUSH
32377: CALL_OW 122
// if not j in mc_healers [ i ] then
32381: LD_VAR 0 3
32385: PUSH
32386: LD_EXP 82
32390: PUSH
32391: LD_VAR 0 2
32395: ARRAY
32396: IN
32397: NOT
32398: IFFALSE 32444
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
32400: LD_ADDR_EXP 82
32404: PUSH
32405: LD_EXP 82
32409: PPUSH
32410: LD_VAR 0 2
32414: PUSH
32415: LD_EXP 82
32419: PUSH
32420: LD_VAR 0 2
32424: ARRAY
32425: PUSH
32426: LD_INT 1
32428: PLUS
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PPUSH
32434: LD_VAR 0 3
32438: PPUSH
32439: CALL 57810 0 3
32443: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
32444: LD_VAR 0 3
32448: PPUSH
32449: CALL_OW 110
32453: PUSH
32454: LD_INT 102
32456: NONEQUAL
32457: IFFALSE 32471
// SetTag ( j , 102 ) ;
32459: LD_VAR 0 3
32463: PPUSH
32464: LD_INT 102
32466: PPUSH
32467: CALL_OW 109
// Wait ( 3 ) ;
32471: LD_INT 3
32473: PPUSH
32474: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
32478: LD_EXP 81
32482: PUSH
32483: LD_VAR 0 2
32487: ARRAY
32488: PUSH
32489: LD_INT 1
32491: ARRAY
32492: IFFALSE 32524
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
32494: LD_VAR 0 3
32498: PPUSH
32499: LD_EXP 81
32503: PUSH
32504: LD_VAR 0 2
32508: ARRAY
32509: PUSH
32510: LD_INT 1
32512: ARRAY
32513: PUSH
32514: LD_INT 1
32516: ARRAY
32517: PPUSH
32518: CALL_OW 128
32522: GO 32580
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
32524: LD_VAR 0 3
32528: PPUSH
32529: CALL_OW 314
32533: NOT
32534: PUSH
32535: LD_EXP 81
32539: PUSH
32540: LD_VAR 0 2
32544: ARRAY
32545: PUSH
32546: LD_INT 2
32548: ARRAY
32549: AND
32550: IFFALSE 32580
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
32552: LD_VAR 0 3
32556: PPUSH
32557: LD_EXP 81
32561: PUSH
32562: LD_VAR 0 2
32566: ARRAY
32567: PUSH
32568: LD_INT 2
32570: ARRAY
32571: PUSH
32572: LD_INT 1
32574: ARRAY
32575: PPUSH
32576: CALL_OW 128
// end ;
32580: GO 32358
32582: POP
32583: POP
// end ;
32584: GO 32201
32586: POP
32587: POP
// end ;
32588: LD_VAR 0 1
32592: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
32593: LD_INT 0
32595: PPUSH
32596: PPUSH
32597: PPUSH
32598: PPUSH
32599: PPUSH
32600: PPUSH
// if not mc_bases then
32601: LD_EXP 78
32605: NOT
32606: IFFALSE 32610
// exit ;
32608: GO 33773
// for i = 1 to mc_bases do
32610: LD_ADDR_VAR 0 2
32614: PUSH
32615: DOUBLE
32616: LD_INT 1
32618: DEC
32619: ST_TO_ADDR
32620: LD_EXP 78
32624: PUSH
32625: FOR_TO
32626: IFFALSE 33771
// begin if mc_scan [ i ] then
32628: LD_EXP 101
32632: PUSH
32633: LD_VAR 0 2
32637: ARRAY
32638: IFFALSE 32642
// continue ;
32640: GO 32625
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
32642: LD_EXP 83
32646: PUSH
32647: LD_VAR 0 2
32651: ARRAY
32652: NOT
32653: PUSH
32654: LD_EXP 85
32658: PUSH
32659: LD_VAR 0 2
32663: ARRAY
32664: NOT
32665: AND
32666: PUSH
32667: LD_EXP 84
32671: PUSH
32672: LD_VAR 0 2
32676: ARRAY
32677: AND
32678: IFFALSE 32716
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
32680: LD_ADDR_EXP 84
32684: PUSH
32685: LD_EXP 84
32689: PPUSH
32690: LD_VAR 0 2
32694: PPUSH
32695: EMPTY
32696: PPUSH
32697: CALL_OW 1
32701: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32702: LD_VAR 0 2
32706: PPUSH
32707: LD_INT 103
32709: PPUSH
32710: CALL 26323 0 2
// continue ;
32714: GO 32625
// end ; if mc_construct_list [ i ] then
32716: LD_EXP 85
32720: PUSH
32721: LD_VAR 0 2
32725: ARRAY
32726: IFFALSE 32946
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32728: LD_ADDR_VAR 0 5
32732: PUSH
32733: LD_EXP 78
32737: PUSH
32738: LD_VAR 0 2
32742: ARRAY
32743: PPUSH
32744: LD_INT 25
32746: PUSH
32747: LD_INT 2
32749: PUSH
32750: EMPTY
32751: LIST
32752: LIST
32753: PPUSH
32754: CALL_OW 72
32758: PUSH
32759: LD_EXP 80
32763: PUSH
32764: LD_VAR 0 2
32768: ARRAY
32769: DIFF
32770: ST_TO_ADDR
// if not tmp then
32771: LD_VAR 0 5
32775: NOT
32776: IFFALSE 32780
// continue ;
32778: GO 32625
// for j in tmp do
32780: LD_ADDR_VAR 0 3
32784: PUSH
32785: LD_VAR 0 5
32789: PUSH
32790: FOR_IN
32791: IFFALSE 32942
// begin if not mc_builders [ i ] then
32793: LD_EXP 84
32797: PUSH
32798: LD_VAR 0 2
32802: ARRAY
32803: NOT
32804: IFFALSE 32862
// begin SetTag ( j , 103 ) ;
32806: LD_VAR 0 3
32810: PPUSH
32811: LD_INT 103
32813: PPUSH
32814: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32818: LD_ADDR_EXP 84
32822: PUSH
32823: LD_EXP 84
32827: PPUSH
32828: LD_VAR 0 2
32832: PUSH
32833: LD_EXP 84
32837: PUSH
32838: LD_VAR 0 2
32842: ARRAY
32843: PUSH
32844: LD_INT 1
32846: PLUS
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PPUSH
32852: LD_VAR 0 3
32856: PPUSH
32857: CALL 57810 0 3
32861: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32862: LD_VAR 0 3
32866: PPUSH
32867: CALL_OW 310
32871: IFFALSE 32882
// ComExitBuilding ( j ) ;
32873: LD_VAR 0 3
32877: PPUSH
32878: CALL_OW 122
// wait ( 3 ) ;
32882: LD_INT 3
32884: PPUSH
32885: CALL_OW 67
// if not mc_construct_list [ i ] then
32889: LD_EXP 85
32893: PUSH
32894: LD_VAR 0 2
32898: ARRAY
32899: NOT
32900: IFFALSE 32904
// break ;
32902: GO 32942
// if not HasTask ( j ) then
32904: LD_VAR 0 3
32908: PPUSH
32909: CALL_OW 314
32913: NOT
32914: IFFALSE 32940
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32916: LD_VAR 0 3
32920: PPUSH
32921: LD_EXP 85
32925: PUSH
32926: LD_VAR 0 2
32930: ARRAY
32931: PUSH
32932: LD_INT 1
32934: ARRAY
32935: PPUSH
32936: CALL 60671 0 2
// end ;
32940: GO 32790
32942: POP
32943: POP
// end else
32944: GO 33769
// if mc_build_list [ i ] then
32946: LD_EXP 83
32950: PUSH
32951: LD_VAR 0 2
32955: ARRAY
32956: IFFALSE 33769
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32958: LD_EXP 83
32962: PUSH
32963: LD_VAR 0 2
32967: ARRAY
32968: PUSH
32969: LD_INT 1
32971: ARRAY
32972: PUSH
32973: LD_INT 1
32975: ARRAY
32976: PPUSH
32977: CALL 60495 0 1
32981: PUSH
32982: LD_EXP 78
32986: PUSH
32987: LD_VAR 0 2
32991: ARRAY
32992: PPUSH
32993: LD_INT 2
32995: PUSH
32996: LD_INT 30
32998: PUSH
32999: LD_INT 2
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 30
33008: PUSH
33009: LD_INT 3
33011: PUSH
33012: EMPTY
33013: LIST
33014: LIST
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: LIST
33020: PPUSH
33021: CALL_OW 72
33025: NOT
33026: AND
33027: IFFALSE 33132
// begin for j = 1 to mc_build_list [ i ] do
33029: LD_ADDR_VAR 0 3
33033: PUSH
33034: DOUBLE
33035: LD_INT 1
33037: DEC
33038: ST_TO_ADDR
33039: LD_EXP 83
33043: PUSH
33044: LD_VAR 0 2
33048: ARRAY
33049: PUSH
33050: FOR_TO
33051: IFFALSE 33130
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33053: LD_EXP 83
33057: PUSH
33058: LD_VAR 0 2
33062: ARRAY
33063: PUSH
33064: LD_VAR 0 3
33068: ARRAY
33069: PUSH
33070: LD_INT 1
33072: ARRAY
33073: PUSH
33074: LD_INT 2
33076: EQUAL
33077: IFFALSE 33128
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33079: LD_ADDR_EXP 83
33083: PUSH
33084: LD_EXP 83
33088: PPUSH
33089: LD_VAR 0 2
33093: PPUSH
33094: LD_EXP 83
33098: PUSH
33099: LD_VAR 0 2
33103: ARRAY
33104: PPUSH
33105: LD_VAR 0 3
33109: PPUSH
33110: LD_INT 1
33112: PPUSH
33113: LD_INT 0
33115: PPUSH
33116: CALL 57228 0 4
33120: PPUSH
33121: CALL_OW 1
33125: ST_TO_ADDR
// break ;
33126: GO 33130
// end ;
33128: GO 33050
33130: POP
33131: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33132: LD_ADDR_VAR 0 6
33136: PUSH
33137: LD_EXP 78
33141: PUSH
33142: LD_VAR 0 2
33146: ARRAY
33147: PPUSH
33148: LD_INT 2
33150: PUSH
33151: LD_INT 30
33153: PUSH
33154: LD_INT 0
33156: PUSH
33157: EMPTY
33158: LIST
33159: LIST
33160: PUSH
33161: LD_INT 30
33163: PUSH
33164: LD_INT 1
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: LIST
33175: PPUSH
33176: CALL_OW 72
33180: ST_TO_ADDR
// for k := 1 to depot do
33181: LD_ADDR_VAR 0 4
33185: PUSH
33186: DOUBLE
33187: LD_INT 1
33189: DEC
33190: ST_TO_ADDR
33191: LD_VAR 0 6
33195: PUSH
33196: FOR_TO
33197: IFFALSE 33767
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
33199: LD_EXP 83
33203: PUSH
33204: LD_VAR 0 2
33208: ARRAY
33209: PUSH
33210: LD_INT 1
33212: ARRAY
33213: PUSH
33214: LD_INT 1
33216: ARRAY
33217: PUSH
33218: LD_INT 0
33220: EQUAL
33221: PUSH
33222: LD_VAR 0 6
33226: PUSH
33227: LD_VAR 0 4
33231: ARRAY
33232: PPUSH
33233: LD_EXP 83
33237: PUSH
33238: LD_VAR 0 2
33242: ARRAY
33243: PUSH
33244: LD_INT 1
33246: ARRAY
33247: PUSH
33248: LD_INT 1
33250: ARRAY
33251: PPUSH
33252: LD_EXP 83
33256: PUSH
33257: LD_VAR 0 2
33261: ARRAY
33262: PUSH
33263: LD_INT 1
33265: ARRAY
33266: PUSH
33267: LD_INT 2
33269: ARRAY
33270: PPUSH
33271: LD_EXP 83
33275: PUSH
33276: LD_VAR 0 2
33280: ARRAY
33281: PUSH
33282: LD_INT 1
33284: ARRAY
33285: PUSH
33286: LD_INT 3
33288: ARRAY
33289: PPUSH
33290: LD_EXP 83
33294: PUSH
33295: LD_VAR 0 2
33299: ARRAY
33300: PUSH
33301: LD_INT 1
33303: ARRAY
33304: PUSH
33305: LD_INT 4
33307: ARRAY
33308: PPUSH
33309: CALL 65907 0 5
33313: OR
33314: IFFALSE 33595
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33316: LD_ADDR_VAR 0 5
33320: PUSH
33321: LD_EXP 78
33325: PUSH
33326: LD_VAR 0 2
33330: ARRAY
33331: PPUSH
33332: LD_INT 25
33334: PUSH
33335: LD_INT 2
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PPUSH
33342: CALL_OW 72
33346: PUSH
33347: LD_EXP 80
33351: PUSH
33352: LD_VAR 0 2
33356: ARRAY
33357: DIFF
33358: ST_TO_ADDR
// if not tmp then
33359: LD_VAR 0 5
33363: NOT
33364: IFFALSE 33368
// continue ;
33366: GO 33196
// for j in tmp do
33368: LD_ADDR_VAR 0 3
33372: PUSH
33373: LD_VAR 0 5
33377: PUSH
33378: FOR_IN
33379: IFFALSE 33591
// begin if not mc_builders [ i ] then
33381: LD_EXP 84
33385: PUSH
33386: LD_VAR 0 2
33390: ARRAY
33391: NOT
33392: IFFALSE 33450
// begin SetTag ( j , 103 ) ;
33394: LD_VAR 0 3
33398: PPUSH
33399: LD_INT 103
33401: PPUSH
33402: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33406: LD_ADDR_EXP 84
33410: PUSH
33411: LD_EXP 84
33415: PPUSH
33416: LD_VAR 0 2
33420: PUSH
33421: LD_EXP 84
33425: PUSH
33426: LD_VAR 0 2
33430: ARRAY
33431: PUSH
33432: LD_INT 1
33434: PLUS
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PPUSH
33440: LD_VAR 0 3
33444: PPUSH
33445: CALL 57810 0 3
33449: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33450: LD_VAR 0 3
33454: PPUSH
33455: CALL_OW 310
33459: IFFALSE 33470
// ComExitBuilding ( j ) ;
33461: LD_VAR 0 3
33465: PPUSH
33466: CALL_OW 122
// wait ( 3 ) ;
33470: LD_INT 3
33472: PPUSH
33473: CALL_OW 67
// if not mc_build_list [ i ] then
33477: LD_EXP 83
33481: PUSH
33482: LD_VAR 0 2
33486: ARRAY
33487: NOT
33488: IFFALSE 33492
// break ;
33490: GO 33591
// if not HasTask ( j ) then
33492: LD_VAR 0 3
33496: PPUSH
33497: CALL_OW 314
33501: NOT
33502: IFFALSE 33589
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
33504: LD_VAR 0 3
33508: PPUSH
33509: LD_EXP 83
33513: PUSH
33514: LD_VAR 0 2
33518: ARRAY
33519: PUSH
33520: LD_INT 1
33522: ARRAY
33523: PUSH
33524: LD_INT 1
33526: ARRAY
33527: PPUSH
33528: LD_EXP 83
33532: PUSH
33533: LD_VAR 0 2
33537: ARRAY
33538: PUSH
33539: LD_INT 1
33541: ARRAY
33542: PUSH
33543: LD_INT 2
33545: ARRAY
33546: PPUSH
33547: LD_EXP 83
33551: PUSH
33552: LD_VAR 0 2
33556: ARRAY
33557: PUSH
33558: LD_INT 1
33560: ARRAY
33561: PUSH
33562: LD_INT 3
33564: ARRAY
33565: PPUSH
33566: LD_EXP 83
33570: PUSH
33571: LD_VAR 0 2
33575: ARRAY
33576: PUSH
33577: LD_INT 1
33579: ARRAY
33580: PUSH
33581: LD_INT 4
33583: ARRAY
33584: PPUSH
33585: CALL_OW 145
// end ;
33589: GO 33378
33591: POP
33592: POP
// end else
33593: GO 33765
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
33595: LD_EXP 78
33599: PUSH
33600: LD_VAR 0 2
33604: ARRAY
33605: PPUSH
33606: LD_EXP 83
33610: PUSH
33611: LD_VAR 0 2
33615: ARRAY
33616: PUSH
33617: LD_INT 1
33619: ARRAY
33620: PUSH
33621: LD_INT 1
33623: ARRAY
33624: PPUSH
33625: LD_EXP 83
33629: PUSH
33630: LD_VAR 0 2
33634: ARRAY
33635: PUSH
33636: LD_INT 1
33638: ARRAY
33639: PUSH
33640: LD_INT 2
33642: ARRAY
33643: PPUSH
33644: LD_EXP 83
33648: PUSH
33649: LD_VAR 0 2
33653: ARRAY
33654: PUSH
33655: LD_INT 1
33657: ARRAY
33658: PUSH
33659: LD_INT 3
33661: ARRAY
33662: PPUSH
33663: LD_EXP 83
33667: PUSH
33668: LD_VAR 0 2
33672: ARRAY
33673: PUSH
33674: LD_INT 1
33676: ARRAY
33677: PUSH
33678: LD_INT 4
33680: ARRAY
33681: PPUSH
33682: LD_EXP 78
33686: PUSH
33687: LD_VAR 0 2
33691: ARRAY
33692: PPUSH
33693: LD_INT 21
33695: PUSH
33696: LD_INT 3
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PPUSH
33703: CALL_OW 72
33707: PPUSH
33708: EMPTY
33709: PPUSH
33710: CALL 64661 0 7
33714: NOT
33715: IFFALSE 33765
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
33717: LD_ADDR_EXP 83
33721: PUSH
33722: LD_EXP 83
33726: PPUSH
33727: LD_VAR 0 2
33731: PPUSH
33732: LD_EXP 83
33736: PUSH
33737: LD_VAR 0 2
33741: ARRAY
33742: PPUSH
33743: LD_INT 1
33745: PPUSH
33746: LD_INT 1
33748: NEG
33749: PPUSH
33750: LD_INT 0
33752: PPUSH
33753: CALL 57228 0 4
33757: PPUSH
33758: CALL_OW 1
33762: ST_TO_ADDR
// continue ;
33763: GO 33196
// end ; end ;
33765: GO 33196
33767: POP
33768: POP
// end ; end ;
33769: GO 32625
33771: POP
33772: POP
// end ;
33773: LD_VAR 0 1
33777: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
33778: LD_INT 0
33780: PPUSH
33781: PPUSH
33782: PPUSH
33783: PPUSH
33784: PPUSH
33785: PPUSH
// if not mc_bases then
33786: LD_EXP 78
33790: NOT
33791: IFFALSE 33795
// exit ;
33793: GO 34222
// for i = 1 to mc_bases do
33795: LD_ADDR_VAR 0 2
33799: PUSH
33800: DOUBLE
33801: LD_INT 1
33803: DEC
33804: ST_TO_ADDR
33805: LD_EXP 78
33809: PUSH
33810: FOR_TO
33811: IFFALSE 34220
// begin tmp := mc_build_upgrade [ i ] ;
33813: LD_ADDR_VAR 0 4
33817: PUSH
33818: LD_EXP 110
33822: PUSH
33823: LD_VAR 0 2
33827: ARRAY
33828: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33829: LD_ADDR_VAR 0 6
33833: PUSH
33834: LD_EXP 111
33838: PUSH
33839: LD_VAR 0 2
33843: ARRAY
33844: PPUSH
33845: LD_INT 2
33847: PUSH
33848: LD_INT 30
33850: PUSH
33851: LD_INT 6
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 30
33860: PUSH
33861: LD_INT 7
33863: PUSH
33864: EMPTY
33865: LIST
33866: LIST
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: LIST
33872: PPUSH
33873: CALL_OW 72
33877: ST_TO_ADDR
// if not tmp and not lab then
33878: LD_VAR 0 4
33882: NOT
33883: PUSH
33884: LD_VAR 0 6
33888: NOT
33889: AND
33890: IFFALSE 33894
// continue ;
33892: GO 33810
// if tmp then
33894: LD_VAR 0 4
33898: IFFALSE 34018
// for j in tmp do
33900: LD_ADDR_VAR 0 3
33904: PUSH
33905: LD_VAR 0 4
33909: PUSH
33910: FOR_IN
33911: IFFALSE 34016
// begin if UpgradeCost ( j ) then
33913: LD_VAR 0 3
33917: PPUSH
33918: CALL 64321 0 1
33922: IFFALSE 34014
// begin ComUpgrade ( j ) ;
33924: LD_VAR 0 3
33928: PPUSH
33929: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33933: LD_ADDR_EXP 110
33937: PUSH
33938: LD_EXP 110
33942: PPUSH
33943: LD_VAR 0 2
33947: PPUSH
33948: LD_EXP 110
33952: PUSH
33953: LD_VAR 0 2
33957: ARRAY
33958: PUSH
33959: LD_VAR 0 3
33963: DIFF
33964: PPUSH
33965: CALL_OW 1
33969: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33970: LD_ADDR_EXP 85
33974: PUSH
33975: LD_EXP 85
33979: PPUSH
33980: LD_VAR 0 2
33984: PUSH
33985: LD_EXP 85
33989: PUSH
33990: LD_VAR 0 2
33994: ARRAY
33995: PUSH
33996: LD_INT 1
33998: PLUS
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PPUSH
34004: LD_VAR 0 3
34008: PPUSH
34009: CALL 57810 0 3
34013: ST_TO_ADDR
// end ; end ;
34014: GO 33910
34016: POP
34017: POP
// if not lab or not mc_lab_upgrade [ i ] then
34018: LD_VAR 0 6
34022: NOT
34023: PUSH
34024: LD_EXP 112
34028: PUSH
34029: LD_VAR 0 2
34033: ARRAY
34034: NOT
34035: OR
34036: IFFALSE 34040
// continue ;
34038: GO 33810
// for j in lab do
34040: LD_ADDR_VAR 0 3
34044: PUSH
34045: LD_VAR 0 6
34049: PUSH
34050: FOR_IN
34051: IFFALSE 34216
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34053: LD_VAR 0 3
34057: PPUSH
34058: CALL_OW 266
34062: PUSH
34063: LD_INT 6
34065: PUSH
34066: LD_INT 7
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: IN
34073: PUSH
34074: LD_VAR 0 3
34078: PPUSH
34079: CALL_OW 461
34083: PUSH
34084: LD_INT 1
34086: NONEQUAL
34087: AND
34088: IFFALSE 34214
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34090: LD_VAR 0 3
34094: PPUSH
34095: LD_EXP 112
34099: PUSH
34100: LD_VAR 0 2
34104: ARRAY
34105: PUSH
34106: LD_INT 1
34108: ARRAY
34109: PPUSH
34110: CALL 64526 0 2
34114: IFFALSE 34214
// begin ComCancel ( j ) ;
34116: LD_VAR 0 3
34120: PPUSH
34121: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
34125: LD_VAR 0 3
34129: PPUSH
34130: LD_EXP 112
34134: PUSH
34135: LD_VAR 0 2
34139: ARRAY
34140: PUSH
34141: LD_INT 1
34143: ARRAY
34144: PPUSH
34145: CALL_OW 207
// if not j in mc_construct_list [ i ] then
34149: LD_VAR 0 3
34153: PUSH
34154: LD_EXP 85
34158: PUSH
34159: LD_VAR 0 2
34163: ARRAY
34164: IN
34165: NOT
34166: IFFALSE 34212
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34168: LD_ADDR_EXP 85
34172: PUSH
34173: LD_EXP 85
34177: PPUSH
34178: LD_VAR 0 2
34182: PUSH
34183: LD_EXP 85
34187: PUSH
34188: LD_VAR 0 2
34192: ARRAY
34193: PUSH
34194: LD_INT 1
34196: PLUS
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PPUSH
34202: LD_VAR 0 3
34206: PPUSH
34207: CALL 57810 0 3
34211: ST_TO_ADDR
// break ;
34212: GO 34216
// end ; end ; end ;
34214: GO 34050
34216: POP
34217: POP
// end ;
34218: GO 33810
34220: POP
34221: POP
// end ;
34222: LD_VAR 0 1
34226: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
34227: LD_INT 0
34229: PPUSH
34230: PPUSH
34231: PPUSH
34232: PPUSH
34233: PPUSH
34234: PPUSH
34235: PPUSH
34236: PPUSH
34237: PPUSH
// if not mc_bases then
34238: LD_EXP 78
34242: NOT
34243: IFFALSE 34247
// exit ;
34245: GO 34652
// for i = 1 to mc_bases do
34247: LD_ADDR_VAR 0 2
34251: PUSH
34252: DOUBLE
34253: LD_INT 1
34255: DEC
34256: ST_TO_ADDR
34257: LD_EXP 78
34261: PUSH
34262: FOR_TO
34263: IFFALSE 34650
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
34265: LD_EXP 86
34269: PUSH
34270: LD_VAR 0 2
34274: ARRAY
34275: NOT
34276: PUSH
34277: LD_EXP 78
34281: PUSH
34282: LD_VAR 0 2
34286: ARRAY
34287: PPUSH
34288: LD_INT 30
34290: PUSH
34291: LD_INT 3
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PPUSH
34298: CALL_OW 72
34302: NOT
34303: OR
34304: IFFALSE 34308
// continue ;
34306: GO 34262
// busy := false ;
34308: LD_ADDR_VAR 0 8
34312: PUSH
34313: LD_INT 0
34315: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34316: LD_ADDR_VAR 0 4
34320: PUSH
34321: LD_EXP 78
34325: PUSH
34326: LD_VAR 0 2
34330: ARRAY
34331: PPUSH
34332: LD_INT 30
34334: PUSH
34335: LD_INT 3
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PPUSH
34342: CALL_OW 72
34346: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
34347: LD_ADDR_VAR 0 6
34351: PUSH
34352: LD_EXP 86
34356: PUSH
34357: LD_VAR 0 2
34361: ARRAY
34362: PPUSH
34363: LD_INT 2
34365: PUSH
34366: LD_INT 30
34368: PUSH
34369: LD_INT 32
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 30
34378: PUSH
34379: LD_INT 33
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: LIST
34390: PPUSH
34391: CALL_OW 72
34395: ST_TO_ADDR
// if not t then
34396: LD_VAR 0 6
34400: NOT
34401: IFFALSE 34405
// continue ;
34403: GO 34262
// for j in tmp do
34405: LD_ADDR_VAR 0 3
34409: PUSH
34410: LD_VAR 0 4
34414: PUSH
34415: FOR_IN
34416: IFFALSE 34446
// if not BuildingStatus ( j ) = bs_idle then
34418: LD_VAR 0 3
34422: PPUSH
34423: CALL_OW 461
34427: PUSH
34428: LD_INT 2
34430: EQUAL
34431: NOT
34432: IFFALSE 34444
// begin busy := true ;
34434: LD_ADDR_VAR 0 8
34438: PUSH
34439: LD_INT 1
34441: ST_TO_ADDR
// break ;
34442: GO 34446
// end ;
34444: GO 34415
34446: POP
34447: POP
// if busy then
34448: LD_VAR 0 8
34452: IFFALSE 34456
// continue ;
34454: GO 34262
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
34456: LD_ADDR_VAR 0 7
34460: PUSH
34461: LD_VAR 0 6
34465: PPUSH
34466: LD_INT 35
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PPUSH
34476: CALL_OW 72
34480: ST_TO_ADDR
// if tw then
34481: LD_VAR 0 7
34485: IFFALSE 34562
// begin tw := tw [ 1 ] ;
34487: LD_ADDR_VAR 0 7
34491: PUSH
34492: LD_VAR 0 7
34496: PUSH
34497: LD_INT 1
34499: ARRAY
34500: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
34501: LD_ADDR_VAR 0 9
34505: PUSH
34506: LD_VAR 0 7
34510: PPUSH
34511: LD_EXP 103
34515: PUSH
34516: LD_VAR 0 2
34520: ARRAY
34521: PPUSH
34522: CALL 62818 0 2
34526: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
34527: LD_EXP 117
34531: PUSH
34532: LD_VAR 0 2
34536: ARRAY
34537: IFFALSE 34560
// if not weapon in mc_allowed_tower_weapons [ i ] then
34539: LD_VAR 0 9
34543: PUSH
34544: LD_EXP 117
34548: PUSH
34549: LD_VAR 0 2
34553: ARRAY
34554: IN
34555: NOT
34556: IFFALSE 34560
// continue ;
34558: GO 34262
// end else
34560: GO 34625
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
34562: LD_ADDR_VAR 0 5
34566: PUSH
34567: LD_EXP 86
34571: PUSH
34572: LD_VAR 0 2
34576: ARRAY
34577: PPUSH
34578: LD_VAR 0 4
34582: PPUSH
34583: CALL 89688 0 2
34587: ST_TO_ADDR
// if not tmp2 then
34588: LD_VAR 0 5
34592: NOT
34593: IFFALSE 34597
// continue ;
34595: GO 34262
// tw := tmp2 [ 1 ] ;
34597: LD_ADDR_VAR 0 7
34601: PUSH
34602: LD_VAR 0 5
34606: PUSH
34607: LD_INT 1
34609: ARRAY
34610: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
34611: LD_ADDR_VAR 0 9
34615: PUSH
34616: LD_VAR 0 5
34620: PUSH
34621: LD_INT 2
34623: ARRAY
34624: ST_TO_ADDR
// end ; if not weapon then
34625: LD_VAR 0 9
34629: NOT
34630: IFFALSE 34634
// continue ;
34632: GO 34262
// ComPlaceWeapon ( tw , weapon ) ;
34634: LD_VAR 0 7
34638: PPUSH
34639: LD_VAR 0 9
34643: PPUSH
34644: CALL_OW 148
// end ;
34648: GO 34262
34650: POP
34651: POP
// end ;
34652: LD_VAR 0 1
34656: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
34657: LD_INT 0
34659: PPUSH
34660: PPUSH
34661: PPUSH
34662: PPUSH
34663: PPUSH
34664: PPUSH
34665: PPUSH
// if not mc_bases then
34666: LD_EXP 78
34670: NOT
34671: IFFALSE 34675
// exit ;
34673: GO 35450
// for i = 1 to mc_bases do
34675: LD_ADDR_VAR 0 2
34679: PUSH
34680: DOUBLE
34681: LD_INT 1
34683: DEC
34684: ST_TO_ADDR
34685: LD_EXP 78
34689: PUSH
34690: FOR_TO
34691: IFFALSE 35448
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
34693: LD_EXP 91
34697: PUSH
34698: LD_VAR 0 2
34702: ARRAY
34703: NOT
34704: PUSH
34705: LD_EXP 91
34709: PUSH
34710: LD_VAR 0 2
34714: ARRAY
34715: PUSH
34716: LD_EXP 92
34720: PUSH
34721: LD_VAR 0 2
34725: ARRAY
34726: EQUAL
34727: OR
34728: PUSH
34729: LD_EXP 101
34733: PUSH
34734: LD_VAR 0 2
34738: ARRAY
34739: OR
34740: IFFALSE 34744
// continue ;
34742: GO 34690
// if mc_miners [ i ] then
34744: LD_EXP 92
34748: PUSH
34749: LD_VAR 0 2
34753: ARRAY
34754: IFFALSE 35135
// begin for j = mc_miners [ i ] downto 1 do
34756: LD_ADDR_VAR 0 3
34760: PUSH
34761: DOUBLE
34762: LD_EXP 92
34766: PUSH
34767: LD_VAR 0 2
34771: ARRAY
34772: INC
34773: ST_TO_ADDR
34774: LD_INT 1
34776: PUSH
34777: FOR_DOWNTO
34778: IFFALSE 35133
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
34780: LD_EXP 92
34784: PUSH
34785: LD_VAR 0 2
34789: ARRAY
34790: PUSH
34791: LD_VAR 0 3
34795: ARRAY
34796: PPUSH
34797: CALL_OW 301
34801: PUSH
34802: LD_EXP 92
34806: PUSH
34807: LD_VAR 0 2
34811: ARRAY
34812: PUSH
34813: LD_VAR 0 3
34817: ARRAY
34818: PPUSH
34819: CALL_OW 257
34823: PUSH
34824: LD_INT 1
34826: NONEQUAL
34827: OR
34828: IFFALSE 34891
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34830: LD_ADDR_VAR 0 5
34834: PUSH
34835: LD_EXP 92
34839: PUSH
34840: LD_VAR 0 2
34844: ARRAY
34845: PUSH
34846: LD_EXP 92
34850: PUSH
34851: LD_VAR 0 2
34855: ARRAY
34856: PUSH
34857: LD_VAR 0 3
34861: ARRAY
34862: DIFF
34863: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34864: LD_ADDR_EXP 92
34868: PUSH
34869: LD_EXP 92
34873: PPUSH
34874: LD_VAR 0 2
34878: PPUSH
34879: LD_VAR 0 5
34883: PPUSH
34884: CALL_OW 1
34888: ST_TO_ADDR
// continue ;
34889: GO 34777
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34891: LD_EXP 92
34895: PUSH
34896: LD_VAR 0 2
34900: ARRAY
34901: PUSH
34902: LD_VAR 0 3
34906: ARRAY
34907: PPUSH
34908: CALL_OW 257
34912: PUSH
34913: LD_INT 1
34915: EQUAL
34916: PUSH
34917: LD_EXP 92
34921: PUSH
34922: LD_VAR 0 2
34926: ARRAY
34927: PUSH
34928: LD_VAR 0 3
34932: ARRAY
34933: PPUSH
34934: CALL_OW 459
34938: NOT
34939: AND
34940: PUSH
34941: LD_EXP 92
34945: PUSH
34946: LD_VAR 0 2
34950: ARRAY
34951: PUSH
34952: LD_VAR 0 3
34956: ARRAY
34957: PPUSH
34958: CALL_OW 314
34962: NOT
34963: AND
34964: IFFALSE 35131
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34966: LD_EXP 92
34970: PUSH
34971: LD_VAR 0 2
34975: ARRAY
34976: PUSH
34977: LD_VAR 0 3
34981: ARRAY
34982: PPUSH
34983: CALL_OW 310
34987: IFFALSE 35010
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34989: LD_EXP 92
34993: PUSH
34994: LD_VAR 0 2
34998: ARRAY
34999: PUSH
35000: LD_VAR 0 3
35004: ARRAY
35005: PPUSH
35006: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
35010: LD_EXP 92
35014: PUSH
35015: LD_VAR 0 2
35019: ARRAY
35020: PUSH
35021: LD_VAR 0 3
35025: ARRAY
35026: PPUSH
35027: CALL_OW 314
35031: NOT
35032: IFFALSE 35131
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
35034: LD_ADDR_VAR 0 7
35038: PUSH
35039: LD_VAR 0 3
35043: PUSH
35044: LD_EXP 91
35048: PUSH
35049: LD_VAR 0 2
35053: ARRAY
35054: PPUSH
35055: CALL 54950 0 1
35059: MOD
35060: PUSH
35061: LD_INT 1
35063: PLUS
35064: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35065: LD_EXP 92
35069: PUSH
35070: LD_VAR 0 2
35074: ARRAY
35075: PUSH
35076: LD_VAR 0 3
35080: ARRAY
35081: PPUSH
35082: LD_EXP 91
35086: PUSH
35087: LD_VAR 0 2
35091: ARRAY
35092: PUSH
35093: LD_VAR 0 7
35097: ARRAY
35098: PUSH
35099: LD_INT 1
35101: ARRAY
35102: PPUSH
35103: LD_EXP 91
35107: PUSH
35108: LD_VAR 0 2
35112: ARRAY
35113: PUSH
35114: LD_VAR 0 7
35118: ARRAY
35119: PUSH
35120: LD_INT 2
35122: ARRAY
35123: PPUSH
35124: LD_INT 0
35126: PPUSH
35127: CALL_OW 193
// end ; end ; end ;
35131: GO 34777
35133: POP
35134: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
35135: LD_ADDR_VAR 0 5
35139: PUSH
35140: LD_EXP 78
35144: PUSH
35145: LD_VAR 0 2
35149: ARRAY
35150: PPUSH
35151: LD_INT 2
35153: PUSH
35154: LD_INT 30
35156: PUSH
35157: LD_INT 4
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 30
35166: PUSH
35167: LD_INT 5
35169: PUSH
35170: EMPTY
35171: LIST
35172: LIST
35173: PUSH
35174: LD_INT 30
35176: PUSH
35177: LD_INT 32
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: LIST
35188: LIST
35189: PPUSH
35190: CALL_OW 72
35194: ST_TO_ADDR
// if not tmp then
35195: LD_VAR 0 5
35199: NOT
35200: IFFALSE 35204
// continue ;
35202: GO 34690
// list := [ ] ;
35204: LD_ADDR_VAR 0 6
35208: PUSH
35209: EMPTY
35210: ST_TO_ADDR
// for j in tmp do
35211: LD_ADDR_VAR 0 3
35215: PUSH
35216: LD_VAR 0 5
35220: PUSH
35221: FOR_IN
35222: IFFALSE 35291
// begin for k in UnitsInside ( j ) do
35224: LD_ADDR_VAR 0 4
35228: PUSH
35229: LD_VAR 0 3
35233: PPUSH
35234: CALL_OW 313
35238: PUSH
35239: FOR_IN
35240: IFFALSE 35287
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
35242: LD_VAR 0 4
35246: PPUSH
35247: CALL_OW 257
35251: PUSH
35252: LD_INT 1
35254: EQUAL
35255: PUSH
35256: LD_VAR 0 4
35260: PPUSH
35261: CALL_OW 459
35265: NOT
35266: AND
35267: IFFALSE 35285
// list := list ^ k ;
35269: LD_ADDR_VAR 0 6
35273: PUSH
35274: LD_VAR 0 6
35278: PUSH
35279: LD_VAR 0 4
35283: ADD
35284: ST_TO_ADDR
35285: GO 35239
35287: POP
35288: POP
// end ;
35289: GO 35221
35291: POP
35292: POP
// list := list diff mc_miners [ i ] ;
35293: LD_ADDR_VAR 0 6
35297: PUSH
35298: LD_VAR 0 6
35302: PUSH
35303: LD_EXP 92
35307: PUSH
35308: LD_VAR 0 2
35312: ARRAY
35313: DIFF
35314: ST_TO_ADDR
// if not list then
35315: LD_VAR 0 6
35319: NOT
35320: IFFALSE 35324
// continue ;
35322: GO 34690
// k := mc_mines [ i ] - mc_miners [ i ] ;
35324: LD_ADDR_VAR 0 4
35328: PUSH
35329: LD_EXP 91
35333: PUSH
35334: LD_VAR 0 2
35338: ARRAY
35339: PUSH
35340: LD_EXP 92
35344: PUSH
35345: LD_VAR 0 2
35349: ARRAY
35350: MINUS
35351: ST_TO_ADDR
// if k > list then
35352: LD_VAR 0 4
35356: PUSH
35357: LD_VAR 0 6
35361: GREATER
35362: IFFALSE 35374
// k := list ;
35364: LD_ADDR_VAR 0 4
35368: PUSH
35369: LD_VAR 0 6
35373: ST_TO_ADDR
// for j = 1 to k do
35374: LD_ADDR_VAR 0 3
35378: PUSH
35379: DOUBLE
35380: LD_INT 1
35382: DEC
35383: ST_TO_ADDR
35384: LD_VAR 0 4
35388: PUSH
35389: FOR_TO
35390: IFFALSE 35444
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
35392: LD_ADDR_EXP 92
35396: PUSH
35397: LD_EXP 92
35401: PPUSH
35402: LD_VAR 0 2
35406: PUSH
35407: LD_EXP 92
35411: PUSH
35412: LD_VAR 0 2
35416: ARRAY
35417: PUSH
35418: LD_INT 1
35420: PLUS
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PPUSH
35426: LD_VAR 0 6
35430: PUSH
35431: LD_VAR 0 3
35435: ARRAY
35436: PPUSH
35437: CALL 57810 0 3
35441: ST_TO_ADDR
35442: GO 35389
35444: POP
35445: POP
// end ;
35446: GO 34690
35448: POP
35449: POP
// end ;
35450: LD_VAR 0 1
35454: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
35455: LD_INT 0
35457: PPUSH
35458: PPUSH
35459: PPUSH
35460: PPUSH
35461: PPUSH
35462: PPUSH
35463: PPUSH
35464: PPUSH
35465: PPUSH
35466: PPUSH
35467: PPUSH
// if not mc_bases then
35468: LD_EXP 78
35472: NOT
35473: IFFALSE 35477
// exit ;
35475: GO 37300
// for i = 1 to mc_bases do
35477: LD_ADDR_VAR 0 2
35481: PUSH
35482: DOUBLE
35483: LD_INT 1
35485: DEC
35486: ST_TO_ADDR
35487: LD_EXP 78
35491: PUSH
35492: FOR_TO
35493: IFFALSE 37298
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
35495: LD_EXP 78
35499: PUSH
35500: LD_VAR 0 2
35504: ARRAY
35505: NOT
35506: PUSH
35507: LD_EXP 85
35511: PUSH
35512: LD_VAR 0 2
35516: ARRAY
35517: OR
35518: IFFALSE 35522
// continue ;
35520: GO 35492
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
35522: LD_EXP 94
35526: PUSH
35527: LD_VAR 0 2
35531: ARRAY
35532: NOT
35533: PUSH
35534: LD_EXP 95
35538: PUSH
35539: LD_VAR 0 2
35543: ARRAY
35544: AND
35545: IFFALSE 35583
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
35547: LD_ADDR_EXP 95
35551: PUSH
35552: LD_EXP 95
35556: PPUSH
35557: LD_VAR 0 2
35561: PPUSH
35562: EMPTY
35563: PPUSH
35564: CALL_OW 1
35568: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
35569: LD_VAR 0 2
35573: PPUSH
35574: LD_INT 107
35576: PPUSH
35577: CALL 26323 0 2
// continue ;
35581: GO 35492
// end ; target := [ ] ;
35583: LD_ADDR_VAR 0 7
35587: PUSH
35588: EMPTY
35589: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35590: LD_ADDR_VAR 0 6
35594: PUSH
35595: LD_EXP 78
35599: PUSH
35600: LD_VAR 0 2
35604: ARRAY
35605: PUSH
35606: LD_INT 1
35608: ARRAY
35609: PPUSH
35610: CALL_OW 255
35614: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35615: LD_ADDR_VAR 0 9
35619: PUSH
35620: LD_EXP 78
35624: PUSH
35625: LD_VAR 0 2
35629: ARRAY
35630: PPUSH
35631: LD_INT 2
35633: PUSH
35634: LD_INT 30
35636: PUSH
35637: LD_INT 0
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 30
35646: PUSH
35647: LD_INT 1
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: LIST
35658: PPUSH
35659: CALL_OW 72
35663: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
35664: LD_ADDR_VAR 0 3
35668: PUSH
35669: DOUBLE
35670: LD_EXP 94
35674: PUSH
35675: LD_VAR 0 2
35679: ARRAY
35680: INC
35681: ST_TO_ADDR
35682: LD_INT 1
35684: PUSH
35685: FOR_DOWNTO
35686: IFFALSE 35931
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
35688: LD_EXP 94
35692: PUSH
35693: LD_VAR 0 2
35697: ARRAY
35698: PUSH
35699: LD_VAR 0 3
35703: ARRAY
35704: PUSH
35705: LD_INT 2
35707: ARRAY
35708: PPUSH
35709: LD_EXP 94
35713: PUSH
35714: LD_VAR 0 2
35718: ARRAY
35719: PUSH
35720: LD_VAR 0 3
35724: ARRAY
35725: PUSH
35726: LD_INT 3
35728: ARRAY
35729: PPUSH
35730: CALL_OW 488
35734: PUSH
35735: LD_EXP 94
35739: PUSH
35740: LD_VAR 0 2
35744: ARRAY
35745: PUSH
35746: LD_VAR 0 3
35750: ARRAY
35751: PUSH
35752: LD_INT 2
35754: ARRAY
35755: PPUSH
35756: LD_EXP 94
35760: PUSH
35761: LD_VAR 0 2
35765: ARRAY
35766: PUSH
35767: LD_VAR 0 3
35771: ARRAY
35772: PUSH
35773: LD_INT 3
35775: ARRAY
35776: PPUSH
35777: CALL_OW 284
35781: PUSH
35782: LD_INT 0
35784: EQUAL
35785: AND
35786: IFFALSE 35841
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
35788: LD_ADDR_VAR 0 5
35792: PUSH
35793: LD_EXP 94
35797: PUSH
35798: LD_VAR 0 2
35802: ARRAY
35803: PPUSH
35804: LD_VAR 0 3
35808: PPUSH
35809: CALL_OW 3
35813: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35814: LD_ADDR_EXP 94
35818: PUSH
35819: LD_EXP 94
35823: PPUSH
35824: LD_VAR 0 2
35828: PPUSH
35829: LD_VAR 0 5
35833: PPUSH
35834: CALL_OW 1
35838: ST_TO_ADDR
// continue ;
35839: GO 35685
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35841: LD_VAR 0 6
35845: PPUSH
35846: LD_EXP 94
35850: PUSH
35851: LD_VAR 0 2
35855: ARRAY
35856: PUSH
35857: LD_VAR 0 3
35861: ARRAY
35862: PUSH
35863: LD_INT 2
35865: ARRAY
35866: PPUSH
35867: LD_EXP 94
35871: PUSH
35872: LD_VAR 0 2
35876: ARRAY
35877: PUSH
35878: LD_VAR 0 3
35882: ARRAY
35883: PUSH
35884: LD_INT 3
35886: ARRAY
35887: PPUSH
35888: LD_INT 30
35890: PPUSH
35891: CALL 58706 0 4
35895: PUSH
35896: LD_INT 4
35898: ARRAY
35899: PUSH
35900: LD_INT 0
35902: EQUAL
35903: IFFALSE 35929
// begin target := mc_crates [ i ] [ j ] ;
35905: LD_ADDR_VAR 0 7
35909: PUSH
35910: LD_EXP 94
35914: PUSH
35915: LD_VAR 0 2
35919: ARRAY
35920: PUSH
35921: LD_VAR 0 3
35925: ARRAY
35926: ST_TO_ADDR
// break ;
35927: GO 35931
// end ; end ;
35929: GO 35685
35931: POP
35932: POP
// if not target then
35933: LD_VAR 0 7
35937: NOT
35938: IFFALSE 35942
// continue ;
35940: GO 35492
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35942: LD_ADDR_VAR 0 8
35946: PUSH
35947: LD_EXP 97
35951: PUSH
35952: LD_VAR 0 2
35956: ARRAY
35957: PPUSH
35958: LD_INT 2
35960: PUSH
35961: LD_INT 3
35963: PUSH
35964: LD_INT 58
35966: PUSH
35967: EMPTY
35968: LIST
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 61
35976: PUSH
35977: EMPTY
35978: LIST
35979: PUSH
35980: LD_INT 33
35982: PUSH
35983: LD_INT 5
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 33
35992: PUSH
35993: LD_INT 3
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: LIST
36004: LIST
36005: LIST
36006: PUSH
36007: LD_INT 2
36009: PUSH
36010: LD_INT 34
36012: PUSH
36013: LD_INT 32
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 34
36022: PUSH
36023: LD_INT 51
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: PUSH
36030: LD_INT 34
36032: PUSH
36033: LD_INT 12
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: LIST
36044: LIST
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: PPUSH
36050: CALL_OW 72
36054: ST_TO_ADDR
// if not cargo then
36055: LD_VAR 0 8
36059: NOT
36060: IFFALSE 36766
// begin if mc_crates_collector [ i ] < 5 then
36062: LD_EXP 95
36066: PUSH
36067: LD_VAR 0 2
36071: ARRAY
36072: PUSH
36073: LD_INT 5
36075: LESS
36076: IFFALSE 36442
// begin if mc_ape [ i ] then
36078: LD_EXP 107
36082: PUSH
36083: LD_VAR 0 2
36087: ARRAY
36088: IFFALSE 36135
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36090: LD_ADDR_VAR 0 5
36094: PUSH
36095: LD_EXP 107
36099: PUSH
36100: LD_VAR 0 2
36104: ARRAY
36105: PPUSH
36106: LD_INT 25
36108: PUSH
36109: LD_INT 16
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 24
36118: PUSH
36119: LD_INT 750
36121: PUSH
36122: EMPTY
36123: LIST
36124: LIST
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PPUSH
36130: CALL_OW 72
36134: ST_TO_ADDR
// if not tmp then
36135: LD_VAR 0 5
36139: NOT
36140: IFFALSE 36187
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
36142: LD_ADDR_VAR 0 5
36146: PUSH
36147: LD_EXP 78
36151: PUSH
36152: LD_VAR 0 2
36156: ARRAY
36157: PPUSH
36158: LD_INT 25
36160: PUSH
36161: LD_INT 2
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 24
36170: PUSH
36171: LD_INT 750
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PPUSH
36182: CALL_OW 72
36186: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
36187: LD_EXP 107
36191: PUSH
36192: LD_VAR 0 2
36196: ARRAY
36197: PUSH
36198: LD_EXP 78
36202: PUSH
36203: LD_VAR 0 2
36207: ARRAY
36208: PPUSH
36209: LD_INT 25
36211: PUSH
36212: LD_INT 2
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 24
36221: PUSH
36222: LD_INT 750
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PPUSH
36233: CALL_OW 72
36237: AND
36238: PUSH
36239: LD_VAR 0 5
36243: PUSH
36244: LD_INT 5
36246: LESS
36247: AND
36248: IFFALSE 36330
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
36250: LD_ADDR_VAR 0 3
36254: PUSH
36255: LD_EXP 78
36259: PUSH
36260: LD_VAR 0 2
36264: ARRAY
36265: PPUSH
36266: LD_INT 25
36268: PUSH
36269: LD_INT 2
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 24
36278: PUSH
36279: LD_INT 750
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PPUSH
36290: CALL_OW 72
36294: PUSH
36295: FOR_IN
36296: IFFALSE 36328
// begin tmp := tmp union j ;
36298: LD_ADDR_VAR 0 5
36302: PUSH
36303: LD_VAR 0 5
36307: PUSH
36308: LD_VAR 0 3
36312: UNION
36313: ST_TO_ADDR
// if tmp >= 5 then
36314: LD_VAR 0 5
36318: PUSH
36319: LD_INT 5
36321: GREATEREQUAL
36322: IFFALSE 36326
// break ;
36324: GO 36328
// end ;
36326: GO 36295
36328: POP
36329: POP
// end ; if not tmp then
36330: LD_VAR 0 5
36334: NOT
36335: IFFALSE 36339
// continue ;
36337: GO 35492
// for j in tmp do
36339: LD_ADDR_VAR 0 3
36343: PUSH
36344: LD_VAR 0 5
36348: PUSH
36349: FOR_IN
36350: IFFALSE 36440
// if not GetTag ( j ) then
36352: LD_VAR 0 3
36356: PPUSH
36357: CALL_OW 110
36361: NOT
36362: IFFALSE 36438
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
36364: LD_ADDR_EXP 95
36368: PUSH
36369: LD_EXP 95
36373: PPUSH
36374: LD_VAR 0 2
36378: PUSH
36379: LD_EXP 95
36383: PUSH
36384: LD_VAR 0 2
36388: ARRAY
36389: PUSH
36390: LD_INT 1
36392: PLUS
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PPUSH
36398: LD_VAR 0 3
36402: PPUSH
36403: CALL 57810 0 3
36407: ST_TO_ADDR
// SetTag ( j , 107 ) ;
36408: LD_VAR 0 3
36412: PPUSH
36413: LD_INT 107
36415: PPUSH
36416: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
36420: LD_EXP 95
36424: PUSH
36425: LD_VAR 0 2
36429: ARRAY
36430: PUSH
36431: LD_INT 5
36433: GREATEREQUAL
36434: IFFALSE 36438
// break ;
36436: GO 36440
// end ;
36438: GO 36349
36440: POP
36441: POP
// end ; if mc_crates_collector [ i ] and target then
36442: LD_EXP 95
36446: PUSH
36447: LD_VAR 0 2
36451: ARRAY
36452: PUSH
36453: LD_VAR 0 7
36457: AND
36458: IFFALSE 36764
// begin if mc_crates_collector [ i ] < target [ 1 ] then
36460: LD_EXP 95
36464: PUSH
36465: LD_VAR 0 2
36469: ARRAY
36470: PUSH
36471: LD_VAR 0 7
36475: PUSH
36476: LD_INT 1
36478: ARRAY
36479: LESS
36480: IFFALSE 36500
// tmp := mc_crates_collector [ i ] else
36482: LD_ADDR_VAR 0 5
36486: PUSH
36487: LD_EXP 95
36491: PUSH
36492: LD_VAR 0 2
36496: ARRAY
36497: ST_TO_ADDR
36498: GO 36514
// tmp := target [ 1 ] ;
36500: LD_ADDR_VAR 0 5
36504: PUSH
36505: LD_VAR 0 7
36509: PUSH
36510: LD_INT 1
36512: ARRAY
36513: ST_TO_ADDR
// k := 0 ;
36514: LD_ADDR_VAR 0 4
36518: PUSH
36519: LD_INT 0
36521: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
36522: LD_ADDR_VAR 0 3
36526: PUSH
36527: LD_EXP 95
36531: PUSH
36532: LD_VAR 0 2
36536: ARRAY
36537: PUSH
36538: FOR_IN
36539: IFFALSE 36762
// begin k := k + 1 ;
36541: LD_ADDR_VAR 0 4
36545: PUSH
36546: LD_VAR 0 4
36550: PUSH
36551: LD_INT 1
36553: PLUS
36554: ST_TO_ADDR
// if k > tmp then
36555: LD_VAR 0 4
36559: PUSH
36560: LD_VAR 0 5
36564: GREATER
36565: IFFALSE 36569
// break ;
36567: GO 36762
// if not GetClass ( j ) in [ 2 , 16 ] then
36569: LD_VAR 0 3
36573: PPUSH
36574: CALL_OW 257
36578: PUSH
36579: LD_INT 2
36581: PUSH
36582: LD_INT 16
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: IN
36589: NOT
36590: IFFALSE 36643
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
36592: LD_ADDR_EXP 95
36596: PUSH
36597: LD_EXP 95
36601: PPUSH
36602: LD_VAR 0 2
36606: PPUSH
36607: LD_EXP 95
36611: PUSH
36612: LD_VAR 0 2
36616: ARRAY
36617: PUSH
36618: LD_VAR 0 3
36622: DIFF
36623: PPUSH
36624: CALL_OW 1
36628: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36629: LD_VAR 0 3
36633: PPUSH
36634: LD_INT 0
36636: PPUSH
36637: CALL_OW 109
// continue ;
36641: GO 36538
// end ; if IsInUnit ( j ) then
36643: LD_VAR 0 3
36647: PPUSH
36648: CALL_OW 310
36652: IFFALSE 36663
// ComExitBuilding ( j ) ;
36654: LD_VAR 0 3
36658: PPUSH
36659: CALL_OW 122
// wait ( 3 ) ;
36663: LD_INT 3
36665: PPUSH
36666: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
36670: LD_VAR 0 3
36674: PPUSH
36675: CALL_OW 314
36679: PUSH
36680: LD_VAR 0 6
36684: PPUSH
36685: LD_VAR 0 7
36689: PUSH
36690: LD_INT 2
36692: ARRAY
36693: PPUSH
36694: LD_VAR 0 7
36698: PUSH
36699: LD_INT 3
36701: ARRAY
36702: PPUSH
36703: LD_INT 30
36705: PPUSH
36706: CALL 58706 0 4
36710: PUSH
36711: LD_INT 4
36713: ARRAY
36714: AND
36715: IFFALSE 36733
// ComStandNearbyBuilding ( j , depot ) else
36717: LD_VAR 0 3
36721: PPUSH
36722: LD_VAR 0 9
36726: PPUSH
36727: CALL 54412 0 2
36731: GO 36760
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36733: LD_VAR 0 3
36737: PPUSH
36738: LD_VAR 0 7
36742: PUSH
36743: LD_INT 2
36745: ARRAY
36746: PPUSH
36747: LD_VAR 0 7
36751: PUSH
36752: LD_INT 3
36754: ARRAY
36755: PPUSH
36756: CALL_OW 117
// end ;
36760: GO 36538
36762: POP
36763: POP
// end ; end else
36764: GO 37296
// begin for j in cargo do
36766: LD_ADDR_VAR 0 3
36770: PUSH
36771: LD_VAR 0 8
36775: PUSH
36776: FOR_IN
36777: IFFALSE 37294
// begin if GetTag ( j ) <> 0 then
36779: LD_VAR 0 3
36783: PPUSH
36784: CALL_OW 110
36788: PUSH
36789: LD_INT 0
36791: NONEQUAL
36792: IFFALSE 36796
// continue ;
36794: GO 36776
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
36796: LD_VAR 0 3
36800: PPUSH
36801: CALL_OW 256
36805: PUSH
36806: LD_INT 1000
36808: LESS
36809: PUSH
36810: LD_VAR 0 3
36814: PPUSH
36815: LD_EXP 102
36819: PUSH
36820: LD_VAR 0 2
36824: ARRAY
36825: PPUSH
36826: CALL_OW 308
36830: NOT
36831: AND
36832: IFFALSE 36854
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36834: LD_VAR 0 3
36838: PPUSH
36839: LD_EXP 102
36843: PUSH
36844: LD_VAR 0 2
36848: ARRAY
36849: PPUSH
36850: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36854: LD_VAR 0 3
36858: PPUSH
36859: CALL_OW 256
36863: PUSH
36864: LD_INT 1000
36866: LESS
36867: PUSH
36868: LD_VAR 0 3
36872: PPUSH
36873: LD_EXP 102
36877: PUSH
36878: LD_VAR 0 2
36882: ARRAY
36883: PPUSH
36884: CALL_OW 308
36888: AND
36889: IFFALSE 36893
// continue ;
36891: GO 36776
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36893: LD_VAR 0 3
36897: PPUSH
36898: CALL_OW 262
36902: PUSH
36903: LD_INT 2
36905: EQUAL
36906: PUSH
36907: LD_VAR 0 3
36911: PPUSH
36912: CALL_OW 261
36916: PUSH
36917: LD_INT 15
36919: LESS
36920: AND
36921: IFFALSE 36925
// continue ;
36923: GO 36776
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36925: LD_VAR 0 3
36929: PPUSH
36930: CALL_OW 262
36934: PUSH
36935: LD_INT 1
36937: EQUAL
36938: PUSH
36939: LD_VAR 0 3
36943: PPUSH
36944: CALL_OW 261
36948: PUSH
36949: LD_INT 10
36951: LESS
36952: AND
36953: IFFALSE 37233
// begin if not depot then
36955: LD_VAR 0 9
36959: NOT
36960: IFFALSE 36964
// continue ;
36962: GO 36776
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36964: LD_VAR 0 3
36968: PPUSH
36969: LD_VAR 0 9
36973: PPUSH
36974: LD_VAR 0 3
36978: PPUSH
36979: CALL_OW 74
36983: PPUSH
36984: CALL_OW 296
36988: PUSH
36989: LD_INT 6
36991: LESS
36992: IFFALSE 37008
// SetFuel ( j , 100 ) else
36994: LD_VAR 0 3
36998: PPUSH
36999: LD_INT 100
37001: PPUSH
37002: CALL_OW 240
37006: GO 37233
// if GetFuel ( j ) = 0 then
37008: LD_VAR 0 3
37012: PPUSH
37013: CALL_OW 261
37017: PUSH
37018: LD_INT 0
37020: EQUAL
37021: IFFALSE 37233
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
37023: LD_ADDR_EXP 97
37027: PUSH
37028: LD_EXP 97
37032: PPUSH
37033: LD_VAR 0 2
37037: PPUSH
37038: LD_EXP 97
37042: PUSH
37043: LD_VAR 0 2
37047: ARRAY
37048: PUSH
37049: LD_VAR 0 3
37053: DIFF
37054: PPUSH
37055: CALL_OW 1
37059: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37060: LD_VAR 0 3
37064: PPUSH
37065: CALL_OW 263
37069: PUSH
37070: LD_INT 1
37072: EQUAL
37073: IFFALSE 37089
// ComExitVehicle ( IsInUnit ( j ) ) ;
37075: LD_VAR 0 3
37079: PPUSH
37080: CALL_OW 310
37084: PPUSH
37085: CALL_OW 121
// if GetControl ( j ) = control_remote then
37089: LD_VAR 0 3
37093: PPUSH
37094: CALL_OW 263
37098: PUSH
37099: LD_INT 2
37101: EQUAL
37102: IFFALSE 37113
// ComUnlink ( j ) ;
37104: LD_VAR 0 3
37108: PPUSH
37109: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37113: LD_ADDR_VAR 0 10
37117: PUSH
37118: LD_VAR 0 2
37122: PPUSH
37123: LD_INT 3
37125: PPUSH
37126: CALL 46877 0 2
37130: ST_TO_ADDR
// if fac then
37131: LD_VAR 0 10
37135: IFFALSE 37231
// begin for k in fac do
37137: LD_ADDR_VAR 0 4
37141: PUSH
37142: LD_VAR 0 10
37146: PUSH
37147: FOR_IN
37148: IFFALSE 37229
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
37150: LD_ADDR_VAR 0 11
37154: PUSH
37155: LD_VAR 0 10
37159: PPUSH
37160: LD_VAR 0 3
37164: PPUSH
37165: CALL_OW 265
37169: PPUSH
37170: LD_VAR 0 3
37174: PPUSH
37175: CALL_OW 262
37179: PPUSH
37180: LD_VAR 0 3
37184: PPUSH
37185: CALL_OW 263
37189: PPUSH
37190: LD_VAR 0 3
37194: PPUSH
37195: CALL_OW 264
37199: PPUSH
37200: CALL 55308 0 5
37204: ST_TO_ADDR
// if components then
37205: LD_VAR 0 11
37209: IFFALSE 37227
// begin MC_InsertProduceList ( i , components ) ;
37211: LD_VAR 0 2
37215: PPUSH
37216: LD_VAR 0 11
37220: PPUSH
37221: CALL 46422 0 2
// break ;
37225: GO 37229
// end ; end ;
37227: GO 37147
37229: POP
37230: POP
// end ; continue ;
37231: GO 36776
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
37233: LD_VAR 0 3
37237: PPUSH
37238: LD_INT 1
37240: PPUSH
37241: CALL_OW 289
37245: PUSH
37246: LD_INT 100
37248: LESS
37249: PUSH
37250: LD_VAR 0 3
37254: PPUSH
37255: CALL_OW 314
37259: NOT
37260: AND
37261: IFFALSE 37290
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37263: LD_VAR 0 3
37267: PPUSH
37268: LD_VAR 0 7
37272: PUSH
37273: LD_INT 2
37275: ARRAY
37276: PPUSH
37277: LD_VAR 0 7
37281: PUSH
37282: LD_INT 3
37284: ARRAY
37285: PPUSH
37286: CALL_OW 117
// break ;
37290: GO 37294
// end ;
37292: GO 36776
37294: POP
37295: POP
// end ; end ;
37296: GO 35492
37298: POP
37299: POP
// end ;
37300: LD_VAR 0 1
37304: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
37305: LD_INT 0
37307: PPUSH
37308: PPUSH
37309: PPUSH
37310: PPUSH
// if not mc_bases then
37311: LD_EXP 78
37315: NOT
37316: IFFALSE 37320
// exit ;
37318: GO 37481
// for i = 1 to mc_bases do
37320: LD_ADDR_VAR 0 2
37324: PUSH
37325: DOUBLE
37326: LD_INT 1
37328: DEC
37329: ST_TO_ADDR
37330: LD_EXP 78
37334: PUSH
37335: FOR_TO
37336: IFFALSE 37479
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
37338: LD_ADDR_VAR 0 4
37342: PUSH
37343: LD_EXP 97
37347: PUSH
37348: LD_VAR 0 2
37352: ARRAY
37353: PUSH
37354: LD_EXP 100
37358: PUSH
37359: LD_VAR 0 2
37363: ARRAY
37364: UNION
37365: PPUSH
37366: LD_INT 33
37368: PUSH
37369: LD_INT 2
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PPUSH
37376: CALL_OW 72
37380: ST_TO_ADDR
// if tmp then
37381: LD_VAR 0 4
37385: IFFALSE 37477
// for j in tmp do
37387: LD_ADDR_VAR 0 3
37391: PUSH
37392: LD_VAR 0 4
37396: PUSH
37397: FOR_IN
37398: IFFALSE 37475
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
37400: LD_VAR 0 3
37404: PPUSH
37405: CALL_OW 312
37409: NOT
37410: PUSH
37411: LD_VAR 0 3
37415: PPUSH
37416: CALL_OW 256
37420: PUSH
37421: LD_INT 250
37423: GREATEREQUAL
37424: AND
37425: IFFALSE 37438
// Connect ( j ) else
37427: LD_VAR 0 3
37431: PPUSH
37432: CALL 60779 0 1
37436: GO 37473
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
37438: LD_VAR 0 3
37442: PPUSH
37443: CALL_OW 256
37447: PUSH
37448: LD_INT 250
37450: LESS
37451: PUSH
37452: LD_VAR 0 3
37456: PPUSH
37457: CALL_OW 312
37461: AND
37462: IFFALSE 37473
// ComUnlink ( j ) ;
37464: LD_VAR 0 3
37468: PPUSH
37469: CALL_OW 136
37473: GO 37397
37475: POP
37476: POP
// end ;
37477: GO 37335
37479: POP
37480: POP
// end ;
37481: LD_VAR 0 1
37485: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
37486: LD_INT 0
37488: PPUSH
37489: PPUSH
37490: PPUSH
37491: PPUSH
37492: PPUSH
// if not mc_bases then
37493: LD_EXP 78
37497: NOT
37498: IFFALSE 37502
// exit ;
37500: GO 37947
// for i = 1 to mc_bases do
37502: LD_ADDR_VAR 0 2
37506: PUSH
37507: DOUBLE
37508: LD_INT 1
37510: DEC
37511: ST_TO_ADDR
37512: LD_EXP 78
37516: PUSH
37517: FOR_TO
37518: IFFALSE 37945
// begin if not mc_produce [ i ] then
37520: LD_EXP 99
37524: PUSH
37525: LD_VAR 0 2
37529: ARRAY
37530: NOT
37531: IFFALSE 37535
// continue ;
37533: GO 37517
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37535: LD_ADDR_VAR 0 5
37539: PUSH
37540: LD_EXP 78
37544: PUSH
37545: LD_VAR 0 2
37549: ARRAY
37550: PPUSH
37551: LD_INT 30
37553: PUSH
37554: LD_INT 3
37556: PUSH
37557: EMPTY
37558: LIST
37559: LIST
37560: PPUSH
37561: CALL_OW 72
37565: ST_TO_ADDR
// if not fac then
37566: LD_VAR 0 5
37570: NOT
37571: IFFALSE 37575
// continue ;
37573: GO 37517
// for j in fac do
37575: LD_ADDR_VAR 0 3
37579: PUSH
37580: LD_VAR 0 5
37584: PUSH
37585: FOR_IN
37586: IFFALSE 37941
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
37588: LD_VAR 0 3
37592: PPUSH
37593: CALL_OW 461
37597: PUSH
37598: LD_INT 2
37600: NONEQUAL
37601: PUSH
37602: LD_VAR 0 3
37606: PPUSH
37607: LD_INT 15
37609: PPUSH
37610: CALL 60407 0 2
37614: PUSH
37615: LD_INT 4
37617: ARRAY
37618: OR
37619: IFFALSE 37623
// continue ;
37621: GO 37585
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
37623: LD_VAR 0 3
37627: PPUSH
37628: LD_EXP 99
37632: PUSH
37633: LD_VAR 0 2
37637: ARRAY
37638: PUSH
37639: LD_INT 1
37641: ARRAY
37642: PUSH
37643: LD_INT 1
37645: ARRAY
37646: PPUSH
37647: LD_EXP 99
37651: PUSH
37652: LD_VAR 0 2
37656: ARRAY
37657: PUSH
37658: LD_INT 1
37660: ARRAY
37661: PUSH
37662: LD_INT 2
37664: ARRAY
37665: PPUSH
37666: LD_EXP 99
37670: PUSH
37671: LD_VAR 0 2
37675: ARRAY
37676: PUSH
37677: LD_INT 1
37679: ARRAY
37680: PUSH
37681: LD_INT 3
37683: ARRAY
37684: PPUSH
37685: LD_EXP 99
37689: PUSH
37690: LD_VAR 0 2
37694: ARRAY
37695: PUSH
37696: LD_INT 1
37698: ARRAY
37699: PUSH
37700: LD_INT 4
37702: ARRAY
37703: PPUSH
37704: CALL_OW 448
37708: PUSH
37709: LD_VAR 0 3
37713: PPUSH
37714: LD_EXP 99
37718: PUSH
37719: LD_VAR 0 2
37723: ARRAY
37724: PUSH
37725: LD_INT 1
37727: ARRAY
37728: PUSH
37729: LD_INT 1
37731: ARRAY
37732: PUSH
37733: LD_EXP 99
37737: PUSH
37738: LD_VAR 0 2
37742: ARRAY
37743: PUSH
37744: LD_INT 1
37746: ARRAY
37747: PUSH
37748: LD_INT 2
37750: ARRAY
37751: PUSH
37752: LD_EXP 99
37756: PUSH
37757: LD_VAR 0 2
37761: ARRAY
37762: PUSH
37763: LD_INT 1
37765: ARRAY
37766: PUSH
37767: LD_INT 3
37769: ARRAY
37770: PUSH
37771: LD_EXP 99
37775: PUSH
37776: LD_VAR 0 2
37780: ARRAY
37781: PUSH
37782: LD_INT 1
37784: ARRAY
37785: PUSH
37786: LD_INT 4
37788: ARRAY
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: LIST
37794: LIST
37795: PPUSH
37796: CALL 64174 0 2
37800: AND
37801: IFFALSE 37939
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37803: LD_VAR 0 3
37807: PPUSH
37808: LD_EXP 99
37812: PUSH
37813: LD_VAR 0 2
37817: ARRAY
37818: PUSH
37819: LD_INT 1
37821: ARRAY
37822: PUSH
37823: LD_INT 1
37825: ARRAY
37826: PPUSH
37827: LD_EXP 99
37831: PUSH
37832: LD_VAR 0 2
37836: ARRAY
37837: PUSH
37838: LD_INT 1
37840: ARRAY
37841: PUSH
37842: LD_INT 2
37844: ARRAY
37845: PPUSH
37846: LD_EXP 99
37850: PUSH
37851: LD_VAR 0 2
37855: ARRAY
37856: PUSH
37857: LD_INT 1
37859: ARRAY
37860: PUSH
37861: LD_INT 3
37863: ARRAY
37864: PPUSH
37865: LD_EXP 99
37869: PUSH
37870: LD_VAR 0 2
37874: ARRAY
37875: PUSH
37876: LD_INT 1
37878: ARRAY
37879: PUSH
37880: LD_INT 4
37882: ARRAY
37883: PPUSH
37884: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37888: LD_ADDR_VAR 0 4
37892: PUSH
37893: LD_EXP 99
37897: PUSH
37898: LD_VAR 0 2
37902: ARRAY
37903: PPUSH
37904: LD_INT 1
37906: PPUSH
37907: CALL_OW 3
37911: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37912: LD_ADDR_EXP 99
37916: PUSH
37917: LD_EXP 99
37921: PPUSH
37922: LD_VAR 0 2
37926: PPUSH
37927: LD_VAR 0 4
37931: PPUSH
37932: CALL_OW 1
37936: ST_TO_ADDR
// break ;
37937: GO 37941
// end ; end ;
37939: GO 37585
37941: POP
37942: POP
// end ;
37943: GO 37517
37945: POP
37946: POP
// end ;
37947: LD_VAR 0 1
37951: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37952: LD_INT 0
37954: PPUSH
37955: PPUSH
37956: PPUSH
// if not mc_bases then
37957: LD_EXP 78
37961: NOT
37962: IFFALSE 37966
// exit ;
37964: GO 38055
// for i = 1 to mc_bases do
37966: LD_ADDR_VAR 0 2
37970: PUSH
37971: DOUBLE
37972: LD_INT 1
37974: DEC
37975: ST_TO_ADDR
37976: LD_EXP 78
37980: PUSH
37981: FOR_TO
37982: IFFALSE 38053
// begin if mc_attack [ i ] then
37984: LD_EXP 98
37988: PUSH
37989: LD_VAR 0 2
37993: ARRAY
37994: IFFALSE 38051
// begin tmp := mc_attack [ i ] [ 1 ] ;
37996: LD_ADDR_VAR 0 3
38000: PUSH
38001: LD_EXP 98
38005: PUSH
38006: LD_VAR 0 2
38010: ARRAY
38011: PUSH
38012: LD_INT 1
38014: ARRAY
38015: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38016: LD_ADDR_EXP 98
38020: PUSH
38021: LD_EXP 98
38025: PPUSH
38026: LD_VAR 0 2
38030: PPUSH
38031: EMPTY
38032: PPUSH
38033: CALL_OW 1
38037: ST_TO_ADDR
// Attack ( tmp ) ;
38038: LD_VAR 0 3
38042: PPUSH
38043: CALL 114303 0 1
// exit ;
38047: POP
38048: POP
38049: GO 38055
// end ; end ;
38051: GO 37981
38053: POP
38054: POP
// end ;
38055: LD_VAR 0 1
38059: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38060: LD_INT 0
38062: PPUSH
38063: PPUSH
38064: PPUSH
38065: PPUSH
38066: PPUSH
38067: PPUSH
38068: PPUSH
// if not mc_bases then
38069: LD_EXP 78
38073: NOT
38074: IFFALSE 38078
// exit ;
38076: GO 38935
// for i = 1 to mc_bases do
38078: LD_ADDR_VAR 0 2
38082: PUSH
38083: DOUBLE
38084: LD_INT 1
38086: DEC
38087: ST_TO_ADDR
38088: LD_EXP 78
38092: PUSH
38093: FOR_TO
38094: IFFALSE 38933
// begin if not mc_bases [ i ] then
38096: LD_EXP 78
38100: PUSH
38101: LD_VAR 0 2
38105: ARRAY
38106: NOT
38107: IFFALSE 38111
// continue ;
38109: GO 38093
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38111: LD_ADDR_VAR 0 7
38115: PUSH
38116: LD_EXP 78
38120: PUSH
38121: LD_VAR 0 2
38125: ARRAY
38126: PUSH
38127: LD_INT 1
38129: ARRAY
38130: PPUSH
38131: CALL 54634 0 1
38135: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
38136: LD_ADDR_EXP 101
38140: PUSH
38141: LD_EXP 101
38145: PPUSH
38146: LD_VAR 0 2
38150: PPUSH
38151: LD_EXP 78
38155: PUSH
38156: LD_VAR 0 2
38160: ARRAY
38161: PUSH
38162: LD_INT 1
38164: ARRAY
38165: PPUSH
38166: CALL_OW 255
38170: PPUSH
38171: LD_EXP 103
38175: PUSH
38176: LD_VAR 0 2
38180: ARRAY
38181: PPUSH
38182: CALL 54599 0 2
38186: PPUSH
38187: CALL_OW 1
38191: ST_TO_ADDR
// if not mc_scan [ i ] then
38192: LD_EXP 101
38196: PUSH
38197: LD_VAR 0 2
38201: ARRAY
38202: NOT
38203: IFFALSE 38381
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38205: LD_ADDR_EXP 121
38209: PUSH
38210: LD_EXP 121
38214: PPUSH
38215: LD_VAR 0 2
38219: PPUSH
38220: LD_INT 0
38222: PPUSH
38223: CALL_OW 1
38227: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38228: LD_ADDR_VAR 0 4
38232: PUSH
38233: LD_EXP 78
38237: PUSH
38238: LD_VAR 0 2
38242: ARRAY
38243: PPUSH
38244: LD_INT 2
38246: PUSH
38247: LD_INT 25
38249: PUSH
38250: LD_INT 5
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 25
38259: PUSH
38260: LD_INT 8
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 25
38269: PUSH
38270: LD_INT 9
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: PPUSH
38283: CALL_OW 72
38287: ST_TO_ADDR
// if not tmp then
38288: LD_VAR 0 4
38292: NOT
38293: IFFALSE 38297
// continue ;
38295: GO 38093
// for j in tmp do
38297: LD_ADDR_VAR 0 3
38301: PUSH
38302: LD_VAR 0 4
38306: PUSH
38307: FOR_IN
38308: IFFALSE 38379
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
38310: LD_VAR 0 3
38314: PPUSH
38315: CALL_OW 310
38319: PPUSH
38320: CALL_OW 266
38324: PUSH
38325: LD_INT 5
38327: EQUAL
38328: PUSH
38329: LD_VAR 0 3
38333: PPUSH
38334: CALL_OW 257
38338: PUSH
38339: LD_INT 1
38341: EQUAL
38342: AND
38343: PUSH
38344: LD_VAR 0 3
38348: PPUSH
38349: CALL_OW 459
38353: NOT
38354: AND
38355: PUSH
38356: LD_VAR 0 7
38360: AND
38361: IFFALSE 38377
// ComChangeProfession ( j , class ) ;
38363: LD_VAR 0 3
38367: PPUSH
38368: LD_VAR 0 7
38372: PPUSH
38373: CALL_OW 123
38377: GO 38307
38379: POP
38380: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
38381: LD_EXP 101
38385: PUSH
38386: LD_VAR 0 2
38390: ARRAY
38391: PUSH
38392: LD_EXP 121
38396: PUSH
38397: LD_VAR 0 2
38401: ARRAY
38402: NOT
38403: AND
38404: PUSH
38405: LD_EXP 100
38409: PUSH
38410: LD_VAR 0 2
38414: ARRAY
38415: NOT
38416: AND
38417: PUSH
38418: LD_EXP 78
38422: PUSH
38423: LD_VAR 0 2
38427: ARRAY
38428: PPUSH
38429: LD_INT 50
38431: PUSH
38432: EMPTY
38433: LIST
38434: PUSH
38435: LD_INT 2
38437: PUSH
38438: LD_INT 30
38440: PUSH
38441: LD_INT 32
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 30
38450: PUSH
38451: LD_INT 33
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 30
38460: PUSH
38461: LD_INT 4
38463: PUSH
38464: EMPTY
38465: LIST
38466: LIST
38467: PUSH
38468: LD_INT 30
38470: PUSH
38471: LD_INT 5
38473: PUSH
38474: EMPTY
38475: LIST
38476: LIST
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: LIST
38482: LIST
38483: LIST
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PPUSH
38489: CALL_OW 72
38493: PUSH
38494: LD_INT 4
38496: LESS
38497: PUSH
38498: LD_EXP 78
38502: PUSH
38503: LD_VAR 0 2
38507: ARRAY
38508: PPUSH
38509: LD_INT 3
38511: PUSH
38512: LD_INT 24
38514: PUSH
38515: LD_INT 1000
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 2
38528: PUSH
38529: LD_INT 30
38531: PUSH
38532: LD_INT 0
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 30
38541: PUSH
38542: LD_INT 1
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: LIST
38553: PUSH
38554: EMPTY
38555: LIST
38556: LIST
38557: PPUSH
38558: CALL_OW 72
38562: OR
38563: AND
38564: IFFALSE 38815
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38566: LD_ADDR_EXP 121
38570: PUSH
38571: LD_EXP 121
38575: PPUSH
38576: LD_VAR 0 2
38580: PPUSH
38581: LD_INT 1
38583: PPUSH
38584: CALL_OW 1
38588: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38589: LD_ADDR_VAR 0 4
38593: PUSH
38594: LD_EXP 78
38598: PUSH
38599: LD_VAR 0 2
38603: ARRAY
38604: PPUSH
38605: LD_INT 2
38607: PUSH
38608: LD_INT 25
38610: PUSH
38611: LD_INT 1
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 25
38620: PUSH
38621: LD_INT 5
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 25
38630: PUSH
38631: LD_INT 8
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 25
38640: PUSH
38641: LD_INT 9
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: LIST
38652: LIST
38653: LIST
38654: PPUSH
38655: CALL_OW 72
38659: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
38660: LD_ADDR_VAR 0 4
38664: PUSH
38665: LD_VAR 0 4
38669: PUSH
38670: LD_VAR 0 4
38674: PPUSH
38675: LD_INT 18
38677: PPUSH
38678: CALL 87722 0 2
38682: DIFF
38683: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
38684: LD_VAR 0 4
38688: NOT
38689: PUSH
38690: LD_EXP 78
38694: PUSH
38695: LD_VAR 0 2
38699: ARRAY
38700: PPUSH
38701: LD_INT 2
38703: PUSH
38704: LD_INT 30
38706: PUSH
38707: LD_INT 4
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 30
38716: PUSH
38717: LD_INT 5
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: LIST
38728: PPUSH
38729: CALL_OW 72
38733: NOT
38734: AND
38735: IFFALSE 38797
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
38737: LD_ADDR_VAR 0 4
38741: PUSH
38742: LD_EXP 78
38746: PUSH
38747: LD_VAR 0 2
38751: ARRAY
38752: PPUSH
38753: LD_INT 2
38755: PUSH
38756: LD_INT 25
38758: PUSH
38759: LD_INT 2
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 25
38768: PUSH
38769: LD_INT 3
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 25
38778: PUSH
38779: LD_INT 4
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: PPUSH
38792: CALL_OW 72
38796: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38797: LD_VAR 0 2
38801: PPUSH
38802: LD_VAR 0 4
38806: PPUSH
38807: CALL 119012 0 2
// exit ;
38811: POP
38812: POP
38813: GO 38935
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38815: LD_EXP 101
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_EXP 121
38830: PUSH
38831: LD_VAR 0 2
38835: ARRAY
38836: NOT
38837: AND
38838: PUSH
38839: LD_EXP 100
38843: PUSH
38844: LD_VAR 0 2
38848: ARRAY
38849: AND
38850: IFFALSE 38931
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38852: LD_ADDR_EXP 121
38856: PUSH
38857: LD_EXP 121
38861: PPUSH
38862: LD_VAR 0 2
38866: PPUSH
38867: LD_INT 1
38869: PPUSH
38870: CALL_OW 1
38874: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38875: LD_ADDR_VAR 0 4
38879: PUSH
38880: LD_EXP 100
38884: PUSH
38885: LD_VAR 0 2
38889: ARRAY
38890: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38891: LD_ADDR_EXP 100
38895: PUSH
38896: LD_EXP 100
38900: PPUSH
38901: LD_VAR 0 2
38905: PPUSH
38906: EMPTY
38907: PPUSH
38908: CALL_OW 1
38912: ST_TO_ADDR
// Defend ( i , tmp ) ;
38913: LD_VAR 0 2
38917: PPUSH
38918: LD_VAR 0 4
38922: PPUSH
38923: CALL 119608 0 2
// exit ;
38927: POP
38928: POP
38929: GO 38935
// end ; end ;
38931: GO 38093
38933: POP
38934: POP
// end ;
38935: LD_VAR 0 1
38939: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38940: LD_INT 0
38942: PPUSH
38943: PPUSH
38944: PPUSH
38945: PPUSH
38946: PPUSH
38947: PPUSH
38948: PPUSH
38949: PPUSH
38950: PPUSH
38951: PPUSH
38952: PPUSH
// if not mc_bases then
38953: LD_EXP 78
38957: NOT
38958: IFFALSE 38962
// exit ;
38960: GO 40049
// for i = 1 to mc_bases do
38962: LD_ADDR_VAR 0 2
38966: PUSH
38967: DOUBLE
38968: LD_INT 1
38970: DEC
38971: ST_TO_ADDR
38972: LD_EXP 78
38976: PUSH
38977: FOR_TO
38978: IFFALSE 40047
// begin tmp := mc_lab [ i ] ;
38980: LD_ADDR_VAR 0 6
38984: PUSH
38985: LD_EXP 111
38989: PUSH
38990: LD_VAR 0 2
38994: ARRAY
38995: ST_TO_ADDR
// if not tmp then
38996: LD_VAR 0 6
39000: NOT
39001: IFFALSE 39005
// continue ;
39003: GO 38977
// idle_lab := 0 ;
39005: LD_ADDR_VAR 0 11
39009: PUSH
39010: LD_INT 0
39012: ST_TO_ADDR
// for j in tmp do
39013: LD_ADDR_VAR 0 3
39017: PUSH
39018: LD_VAR 0 6
39022: PUSH
39023: FOR_IN
39024: IFFALSE 40043
// begin researching := false ;
39026: LD_ADDR_VAR 0 10
39030: PUSH
39031: LD_INT 0
39033: ST_TO_ADDR
// side := GetSide ( j ) ;
39034: LD_ADDR_VAR 0 4
39038: PUSH
39039: LD_VAR 0 3
39043: PPUSH
39044: CALL_OW 255
39048: ST_TO_ADDR
// if not mc_tech [ side ] then
39049: LD_EXP 105
39053: PUSH
39054: LD_VAR 0 4
39058: ARRAY
39059: NOT
39060: IFFALSE 39064
// continue ;
39062: GO 39023
// if BuildingStatus ( j ) = bs_idle then
39064: LD_VAR 0 3
39068: PPUSH
39069: CALL_OW 461
39073: PUSH
39074: LD_INT 2
39076: EQUAL
39077: IFFALSE 39265
// begin if idle_lab and UnitsInside ( j ) < 6 then
39079: LD_VAR 0 11
39083: PUSH
39084: LD_VAR 0 3
39088: PPUSH
39089: CALL_OW 313
39093: PUSH
39094: LD_INT 6
39096: LESS
39097: AND
39098: IFFALSE 39169
// begin tmp2 := UnitsInside ( idle_lab ) ;
39100: LD_ADDR_VAR 0 9
39104: PUSH
39105: LD_VAR 0 11
39109: PPUSH
39110: CALL_OW 313
39114: ST_TO_ADDR
// if tmp2 then
39115: LD_VAR 0 9
39119: IFFALSE 39161
// for x in tmp2 do
39121: LD_ADDR_VAR 0 7
39125: PUSH
39126: LD_VAR 0 9
39130: PUSH
39131: FOR_IN
39132: IFFALSE 39159
// begin ComExitBuilding ( x ) ;
39134: LD_VAR 0 7
39138: PPUSH
39139: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39143: LD_VAR 0 7
39147: PPUSH
39148: LD_VAR 0 3
39152: PPUSH
39153: CALL_OW 180
// end ;
39157: GO 39131
39159: POP
39160: POP
// idle_lab := 0 ;
39161: LD_ADDR_VAR 0 11
39165: PUSH
39166: LD_INT 0
39168: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
39169: LD_ADDR_VAR 0 5
39173: PUSH
39174: LD_EXP 105
39178: PUSH
39179: LD_VAR 0 4
39183: ARRAY
39184: PUSH
39185: FOR_IN
39186: IFFALSE 39246
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
39188: LD_VAR 0 3
39192: PPUSH
39193: LD_VAR 0 5
39197: PPUSH
39198: CALL_OW 430
39202: PUSH
39203: LD_VAR 0 4
39207: PPUSH
39208: LD_VAR 0 5
39212: PPUSH
39213: CALL 53704 0 2
39217: AND
39218: IFFALSE 39244
// begin researching := true ;
39220: LD_ADDR_VAR 0 10
39224: PUSH
39225: LD_INT 1
39227: ST_TO_ADDR
// ComResearch ( j , t ) ;
39228: LD_VAR 0 3
39232: PPUSH
39233: LD_VAR 0 5
39237: PPUSH
39238: CALL_OW 124
// break ;
39242: GO 39246
// end ;
39244: GO 39185
39246: POP
39247: POP
// if not researching then
39248: LD_VAR 0 10
39252: NOT
39253: IFFALSE 39265
// idle_lab := j ;
39255: LD_ADDR_VAR 0 11
39259: PUSH
39260: LD_VAR 0 3
39264: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
39265: LD_VAR 0 3
39269: PPUSH
39270: CALL_OW 461
39274: PUSH
39275: LD_INT 10
39277: EQUAL
39278: IFFALSE 39866
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
39280: LD_EXP 107
39284: PUSH
39285: LD_VAR 0 2
39289: ARRAY
39290: NOT
39291: PUSH
39292: LD_EXP 108
39296: PUSH
39297: LD_VAR 0 2
39301: ARRAY
39302: NOT
39303: AND
39304: PUSH
39305: LD_EXP 105
39309: PUSH
39310: LD_VAR 0 4
39314: ARRAY
39315: PUSH
39316: LD_INT 1
39318: GREATER
39319: AND
39320: IFFALSE 39451
// begin ComCancel ( j ) ;
39322: LD_VAR 0 3
39326: PPUSH
39327: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
39331: LD_ADDR_EXP 105
39335: PUSH
39336: LD_EXP 105
39340: PPUSH
39341: LD_VAR 0 4
39345: PPUSH
39346: LD_EXP 105
39350: PUSH
39351: LD_VAR 0 4
39355: ARRAY
39356: PPUSH
39357: LD_EXP 105
39361: PUSH
39362: LD_VAR 0 4
39366: ARRAY
39367: PUSH
39368: LD_INT 1
39370: MINUS
39371: PPUSH
39372: LD_EXP 105
39376: PUSH
39377: LD_VAR 0 4
39381: ARRAY
39382: PPUSH
39383: LD_INT 0
39385: PPUSH
39386: CALL 57228 0 4
39390: PPUSH
39391: CALL_OW 1
39395: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
39396: LD_ADDR_EXP 105
39400: PUSH
39401: LD_EXP 105
39405: PPUSH
39406: LD_VAR 0 4
39410: PPUSH
39411: LD_EXP 105
39415: PUSH
39416: LD_VAR 0 4
39420: ARRAY
39421: PPUSH
39422: LD_EXP 105
39426: PUSH
39427: LD_VAR 0 4
39431: ARRAY
39432: PPUSH
39433: LD_INT 1
39435: PPUSH
39436: LD_INT 0
39438: PPUSH
39439: CALL 57228 0 4
39443: PPUSH
39444: CALL_OW 1
39448: ST_TO_ADDR
// continue ;
39449: GO 39023
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
39451: LD_EXP 107
39455: PUSH
39456: LD_VAR 0 2
39460: ARRAY
39461: PUSH
39462: LD_EXP 108
39466: PUSH
39467: LD_VAR 0 2
39471: ARRAY
39472: NOT
39473: AND
39474: IFFALSE 39601
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
39476: LD_ADDR_EXP 108
39480: PUSH
39481: LD_EXP 108
39485: PPUSH
39486: LD_VAR 0 2
39490: PUSH
39491: LD_EXP 108
39495: PUSH
39496: LD_VAR 0 2
39500: ARRAY
39501: PUSH
39502: LD_INT 1
39504: PLUS
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PPUSH
39510: LD_EXP 107
39514: PUSH
39515: LD_VAR 0 2
39519: ARRAY
39520: PUSH
39521: LD_INT 1
39523: ARRAY
39524: PPUSH
39525: CALL 57810 0 3
39529: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
39530: LD_EXP 107
39534: PUSH
39535: LD_VAR 0 2
39539: ARRAY
39540: PUSH
39541: LD_INT 1
39543: ARRAY
39544: PPUSH
39545: LD_INT 112
39547: PPUSH
39548: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
39552: LD_ADDR_VAR 0 9
39556: PUSH
39557: LD_EXP 107
39561: PUSH
39562: LD_VAR 0 2
39566: ARRAY
39567: PPUSH
39568: LD_INT 1
39570: PPUSH
39571: CALL_OW 3
39575: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
39576: LD_ADDR_EXP 107
39580: PUSH
39581: LD_EXP 107
39585: PPUSH
39586: LD_VAR 0 2
39590: PPUSH
39591: LD_VAR 0 9
39595: PPUSH
39596: CALL_OW 1
39600: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
39601: LD_EXP 107
39605: PUSH
39606: LD_VAR 0 2
39610: ARRAY
39611: PUSH
39612: LD_EXP 108
39616: PUSH
39617: LD_VAR 0 2
39621: ARRAY
39622: AND
39623: PUSH
39624: LD_EXP 108
39628: PUSH
39629: LD_VAR 0 2
39633: ARRAY
39634: PUSH
39635: LD_INT 1
39637: ARRAY
39638: PPUSH
39639: CALL_OW 310
39643: NOT
39644: AND
39645: PUSH
39646: LD_VAR 0 3
39650: PPUSH
39651: CALL_OW 313
39655: PUSH
39656: LD_INT 6
39658: EQUAL
39659: AND
39660: IFFALSE 39716
// begin tmp2 := UnitsInside ( j ) ;
39662: LD_ADDR_VAR 0 9
39666: PUSH
39667: LD_VAR 0 3
39671: PPUSH
39672: CALL_OW 313
39676: ST_TO_ADDR
// if tmp2 = 6 then
39677: LD_VAR 0 9
39681: PUSH
39682: LD_INT 6
39684: EQUAL
39685: IFFALSE 39716
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
39687: LD_VAR 0 9
39691: PUSH
39692: LD_INT 1
39694: ARRAY
39695: PPUSH
39696: LD_INT 112
39698: PPUSH
39699: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
39703: LD_VAR 0 9
39707: PUSH
39708: LD_INT 1
39710: ARRAY
39711: PPUSH
39712: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
39716: LD_EXP 108
39720: PUSH
39721: LD_VAR 0 2
39725: ARRAY
39726: PUSH
39727: LD_EXP 108
39731: PUSH
39732: LD_VAR 0 2
39736: ARRAY
39737: PUSH
39738: LD_INT 1
39740: ARRAY
39741: PPUSH
39742: CALL_OW 314
39746: NOT
39747: AND
39748: PUSH
39749: LD_EXP 108
39753: PUSH
39754: LD_VAR 0 2
39758: ARRAY
39759: PUSH
39760: LD_INT 1
39762: ARRAY
39763: PPUSH
39764: CALL_OW 310
39768: NOT
39769: AND
39770: IFFALSE 39796
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
39772: LD_EXP 108
39776: PUSH
39777: LD_VAR 0 2
39781: ARRAY
39782: PUSH
39783: LD_INT 1
39785: ARRAY
39786: PPUSH
39787: LD_VAR 0 3
39791: PPUSH
39792: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
39796: LD_EXP 108
39800: PUSH
39801: LD_VAR 0 2
39805: ARRAY
39806: PUSH
39807: LD_INT 1
39809: ARRAY
39810: PPUSH
39811: CALL_OW 310
39815: PUSH
39816: LD_EXP 108
39820: PUSH
39821: LD_VAR 0 2
39825: ARRAY
39826: PUSH
39827: LD_INT 1
39829: ARRAY
39830: PPUSH
39831: CALL_OW 310
39835: PPUSH
39836: CALL_OW 461
39840: PUSH
39841: LD_INT 3
39843: NONEQUAL
39844: AND
39845: IFFALSE 39866
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39847: LD_EXP 108
39851: PUSH
39852: LD_VAR 0 2
39856: ARRAY
39857: PUSH
39858: LD_INT 1
39860: ARRAY
39861: PPUSH
39862: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39866: LD_VAR 0 3
39870: PPUSH
39871: CALL_OW 461
39875: PUSH
39876: LD_INT 6
39878: EQUAL
39879: PUSH
39880: LD_VAR 0 6
39884: PUSH
39885: LD_INT 1
39887: GREATER
39888: AND
39889: IFFALSE 40041
// begin sci := [ ] ;
39891: LD_ADDR_VAR 0 8
39895: PUSH
39896: EMPTY
39897: ST_TO_ADDR
// for x in ( tmp diff j ) do
39898: LD_ADDR_VAR 0 7
39902: PUSH
39903: LD_VAR 0 6
39907: PUSH
39908: LD_VAR 0 3
39912: DIFF
39913: PUSH
39914: FOR_IN
39915: IFFALSE 39967
// begin if sci = 6 then
39917: LD_VAR 0 8
39921: PUSH
39922: LD_INT 6
39924: EQUAL
39925: IFFALSE 39929
// break ;
39927: GO 39967
// if BuildingStatus ( x ) = bs_idle then
39929: LD_VAR 0 7
39933: PPUSH
39934: CALL_OW 461
39938: PUSH
39939: LD_INT 2
39941: EQUAL
39942: IFFALSE 39965
// sci := sci ^ UnitsInside ( x ) ;
39944: LD_ADDR_VAR 0 8
39948: PUSH
39949: LD_VAR 0 8
39953: PUSH
39954: LD_VAR 0 7
39958: PPUSH
39959: CALL_OW 313
39963: ADD
39964: ST_TO_ADDR
// end ;
39965: GO 39914
39967: POP
39968: POP
// if not sci then
39969: LD_VAR 0 8
39973: NOT
39974: IFFALSE 39978
// continue ;
39976: GO 39023
// for x in sci do
39978: LD_ADDR_VAR 0 7
39982: PUSH
39983: LD_VAR 0 8
39987: PUSH
39988: FOR_IN
39989: IFFALSE 40039
// if IsInUnit ( x ) and not HasTask ( x ) then
39991: LD_VAR 0 7
39995: PPUSH
39996: CALL_OW 310
40000: PUSH
40001: LD_VAR 0 7
40005: PPUSH
40006: CALL_OW 314
40010: NOT
40011: AND
40012: IFFALSE 40037
// begin ComExitBuilding ( x ) ;
40014: LD_VAR 0 7
40018: PPUSH
40019: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40023: LD_VAR 0 7
40027: PPUSH
40028: LD_VAR 0 3
40032: PPUSH
40033: CALL_OW 180
// end ;
40037: GO 39988
40039: POP
40040: POP
// end ; end ;
40041: GO 39023
40043: POP
40044: POP
// end ;
40045: GO 38977
40047: POP
40048: POP
// end ;
40049: LD_VAR 0 1
40053: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40054: LD_INT 0
40056: PPUSH
40057: PPUSH
// if not mc_bases then
40058: LD_EXP 78
40062: NOT
40063: IFFALSE 40067
// exit ;
40065: GO 40148
// for i = 1 to mc_bases do
40067: LD_ADDR_VAR 0 2
40071: PUSH
40072: DOUBLE
40073: LD_INT 1
40075: DEC
40076: ST_TO_ADDR
40077: LD_EXP 78
40081: PUSH
40082: FOR_TO
40083: IFFALSE 40146
// if mc_mines [ i ] and mc_miners [ i ] then
40085: LD_EXP 91
40089: PUSH
40090: LD_VAR 0 2
40094: ARRAY
40095: PUSH
40096: LD_EXP 92
40100: PUSH
40101: LD_VAR 0 2
40105: ARRAY
40106: AND
40107: IFFALSE 40144
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40109: LD_EXP 92
40113: PUSH
40114: LD_VAR 0 2
40118: ARRAY
40119: PUSH
40120: LD_INT 1
40122: ARRAY
40123: PPUSH
40124: CALL_OW 255
40128: PPUSH
40129: LD_EXP 91
40133: PUSH
40134: LD_VAR 0 2
40138: ARRAY
40139: PPUSH
40140: CALL 54787 0 2
40144: GO 40082
40146: POP
40147: POP
// end ;
40148: LD_VAR 0 1
40152: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
40153: LD_INT 0
40155: PPUSH
40156: PPUSH
40157: PPUSH
40158: PPUSH
40159: PPUSH
40160: PPUSH
40161: PPUSH
40162: PPUSH
// if not mc_bases or not mc_parking then
40163: LD_EXP 78
40167: NOT
40168: PUSH
40169: LD_EXP 102
40173: NOT
40174: OR
40175: IFFALSE 40179
// exit ;
40177: GO 40917
// for i = 1 to mc_bases do
40179: LD_ADDR_VAR 0 2
40183: PUSH
40184: DOUBLE
40185: LD_INT 1
40187: DEC
40188: ST_TO_ADDR
40189: LD_EXP 78
40193: PUSH
40194: FOR_TO
40195: IFFALSE 40915
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
40197: LD_EXP 78
40201: PUSH
40202: LD_VAR 0 2
40206: ARRAY
40207: NOT
40208: PUSH
40209: LD_EXP 102
40213: PUSH
40214: LD_VAR 0 2
40218: ARRAY
40219: NOT
40220: OR
40221: IFFALSE 40225
// continue ;
40223: GO 40194
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
40225: LD_ADDR_VAR 0 5
40229: PUSH
40230: LD_EXP 78
40234: PUSH
40235: LD_VAR 0 2
40239: ARRAY
40240: PUSH
40241: LD_INT 1
40243: ARRAY
40244: PPUSH
40245: CALL_OW 255
40249: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40250: LD_ADDR_VAR 0 6
40254: PUSH
40255: LD_EXP 78
40259: PUSH
40260: LD_VAR 0 2
40264: ARRAY
40265: PPUSH
40266: LD_INT 30
40268: PUSH
40269: LD_INT 3
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PPUSH
40276: CALL_OW 72
40280: ST_TO_ADDR
// if not fac then
40281: LD_VAR 0 6
40285: NOT
40286: IFFALSE 40337
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40288: LD_ADDR_VAR 0 6
40292: PUSH
40293: LD_EXP 78
40297: PUSH
40298: LD_VAR 0 2
40302: ARRAY
40303: PPUSH
40304: LD_INT 2
40306: PUSH
40307: LD_INT 30
40309: PUSH
40310: LD_INT 0
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 30
40319: PUSH
40320: LD_INT 1
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: LIST
40331: PPUSH
40332: CALL_OW 72
40336: ST_TO_ADDR
// if not fac then
40337: LD_VAR 0 6
40341: NOT
40342: IFFALSE 40346
// continue ;
40344: GO 40194
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40346: LD_ADDR_VAR 0 7
40350: PUSH
40351: LD_EXP 102
40355: PUSH
40356: LD_VAR 0 2
40360: ARRAY
40361: PPUSH
40362: LD_INT 22
40364: PUSH
40365: LD_VAR 0 5
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 21
40376: PUSH
40377: LD_INT 2
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 3
40386: PUSH
40387: LD_INT 60
40389: PUSH
40390: EMPTY
40391: LIST
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 3
40399: PUSH
40400: LD_INT 24
40402: PUSH
40403: LD_INT 1000
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: PPUSH
40420: CALL_OW 70
40424: ST_TO_ADDR
// for j in fac do
40425: LD_ADDR_VAR 0 3
40429: PUSH
40430: LD_VAR 0 6
40434: PUSH
40435: FOR_IN
40436: IFFALSE 40531
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40438: LD_ADDR_VAR 0 7
40442: PUSH
40443: LD_VAR 0 7
40447: PUSH
40448: LD_INT 22
40450: PUSH
40451: LD_VAR 0 5
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 91
40462: PUSH
40463: LD_VAR 0 3
40467: PUSH
40468: LD_INT 15
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: LIST
40475: PUSH
40476: LD_INT 21
40478: PUSH
40479: LD_INT 2
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: PUSH
40486: LD_INT 3
40488: PUSH
40489: LD_INT 60
40491: PUSH
40492: EMPTY
40493: LIST
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 3
40501: PUSH
40502: LD_INT 24
40504: PUSH
40505: LD_INT 1000
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: EMPTY
40517: LIST
40518: LIST
40519: LIST
40520: LIST
40521: LIST
40522: PPUSH
40523: CALL_OW 69
40527: UNION
40528: ST_TO_ADDR
40529: GO 40435
40531: POP
40532: POP
// if not vehs then
40533: LD_VAR 0 7
40537: NOT
40538: IFFALSE 40564
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
40540: LD_ADDR_EXP 90
40544: PUSH
40545: LD_EXP 90
40549: PPUSH
40550: LD_VAR 0 2
40554: PPUSH
40555: EMPTY
40556: PPUSH
40557: CALL_OW 1
40561: ST_TO_ADDR
// continue ;
40562: GO 40194
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40564: LD_ADDR_VAR 0 8
40568: PUSH
40569: LD_EXP 78
40573: PUSH
40574: LD_VAR 0 2
40578: ARRAY
40579: PPUSH
40580: LD_INT 30
40582: PUSH
40583: LD_INT 3
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PPUSH
40590: CALL_OW 72
40594: ST_TO_ADDR
// if tmp then
40595: LD_VAR 0 8
40599: IFFALSE 40702
// begin for j in tmp do
40601: LD_ADDR_VAR 0 3
40605: PUSH
40606: LD_VAR 0 8
40610: PUSH
40611: FOR_IN
40612: IFFALSE 40700
// for k in UnitsInside ( j ) do
40614: LD_ADDR_VAR 0 4
40618: PUSH
40619: LD_VAR 0 3
40623: PPUSH
40624: CALL_OW 313
40628: PUSH
40629: FOR_IN
40630: IFFALSE 40696
// if k then
40632: LD_VAR 0 4
40636: IFFALSE 40694
// if not k in mc_repair_vehicle [ i ] then
40638: LD_VAR 0 4
40642: PUSH
40643: LD_EXP 90
40647: PUSH
40648: LD_VAR 0 2
40652: ARRAY
40653: IN
40654: NOT
40655: IFFALSE 40694
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
40657: LD_ADDR_EXP 90
40661: PUSH
40662: LD_EXP 90
40666: PPUSH
40667: LD_VAR 0 2
40671: PPUSH
40672: LD_EXP 90
40676: PUSH
40677: LD_VAR 0 2
40681: ARRAY
40682: PUSH
40683: LD_VAR 0 4
40687: UNION
40688: PPUSH
40689: CALL_OW 1
40693: ST_TO_ADDR
40694: GO 40629
40696: POP
40697: POP
40698: GO 40611
40700: POP
40701: POP
// end ; if not mc_repair_vehicle [ i ] then
40702: LD_EXP 90
40706: PUSH
40707: LD_VAR 0 2
40711: ARRAY
40712: NOT
40713: IFFALSE 40717
// continue ;
40715: GO 40194
// for j in mc_repair_vehicle [ i ] do
40717: LD_ADDR_VAR 0 3
40721: PUSH
40722: LD_EXP 90
40726: PUSH
40727: LD_VAR 0 2
40731: ARRAY
40732: PUSH
40733: FOR_IN
40734: IFFALSE 40911
// begin if GetClass ( j ) <> 3 then
40736: LD_VAR 0 3
40740: PPUSH
40741: CALL_OW 257
40745: PUSH
40746: LD_INT 3
40748: NONEQUAL
40749: IFFALSE 40790
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
40751: LD_ADDR_EXP 90
40755: PUSH
40756: LD_EXP 90
40760: PPUSH
40761: LD_VAR 0 2
40765: PPUSH
40766: LD_EXP 90
40770: PUSH
40771: LD_VAR 0 2
40775: ARRAY
40776: PUSH
40777: LD_VAR 0 3
40781: DIFF
40782: PPUSH
40783: CALL_OW 1
40787: ST_TO_ADDR
// continue ;
40788: GO 40733
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40790: LD_VAR 0 3
40794: PPUSH
40795: CALL_OW 311
40799: NOT
40800: PUSH
40801: LD_VAR 0 3
40805: PUSH
40806: LD_EXP 81
40810: PUSH
40811: LD_VAR 0 2
40815: ARRAY
40816: PUSH
40817: LD_INT 1
40819: ARRAY
40820: IN
40821: NOT
40822: AND
40823: PUSH
40824: LD_VAR 0 3
40828: PUSH
40829: LD_EXP 81
40833: PUSH
40834: LD_VAR 0 2
40838: ARRAY
40839: PUSH
40840: LD_INT 2
40842: ARRAY
40843: IN
40844: NOT
40845: AND
40846: IFFALSE 40909
// begin if IsInUnit ( j ) then
40848: LD_VAR 0 3
40852: PPUSH
40853: CALL_OW 310
40857: IFFALSE 40870
// ComExitBuilding ( j ) else
40859: LD_VAR 0 3
40863: PPUSH
40864: CALL_OW 122
40868: GO 40909
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40870: LD_VAR 0 3
40874: PPUSH
40875: LD_VAR 0 7
40879: PUSH
40880: LD_INT 1
40882: ARRAY
40883: PPUSH
40884: CALL 92205 0 2
40888: NOT
40889: IFFALSE 40909
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40891: LD_VAR 0 3
40895: PPUSH
40896: LD_VAR 0 7
40900: PUSH
40901: LD_INT 1
40903: ARRAY
40904: PPUSH
40905: CALL_OW 129
// end ; end ;
40909: GO 40733
40911: POP
40912: POP
// end ;
40913: GO 40194
40915: POP
40916: POP
// end ;
40917: LD_VAR 0 1
40921: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40922: LD_INT 0
40924: PPUSH
40925: PPUSH
40926: PPUSH
40927: PPUSH
40928: PPUSH
40929: PPUSH
40930: PPUSH
40931: PPUSH
40932: PPUSH
40933: PPUSH
40934: PPUSH
// if not mc_bases then
40935: LD_EXP 78
40939: NOT
40940: IFFALSE 40944
// exit ;
40942: GO 41746
// for i = 1 to mc_bases do
40944: LD_ADDR_VAR 0 2
40948: PUSH
40949: DOUBLE
40950: LD_INT 1
40952: DEC
40953: ST_TO_ADDR
40954: LD_EXP 78
40958: PUSH
40959: FOR_TO
40960: IFFALSE 41744
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40962: LD_EXP 106
40966: PUSH
40967: LD_VAR 0 2
40971: ARRAY
40972: NOT
40973: PUSH
40974: LD_EXP 81
40978: PUSH
40979: LD_VAR 0 2
40983: ARRAY
40984: PUSH
40985: LD_INT 1
40987: ARRAY
40988: OR
40989: PUSH
40990: LD_EXP 81
40994: PUSH
40995: LD_VAR 0 2
40999: ARRAY
41000: PUSH
41001: LD_INT 2
41003: ARRAY
41004: OR
41005: PUSH
41006: LD_EXP 104
41010: PUSH
41011: LD_VAR 0 2
41015: ARRAY
41016: PPUSH
41017: LD_INT 1
41019: PPUSH
41020: CALL_OW 325
41024: NOT
41025: OR
41026: PUSH
41027: LD_EXP 101
41031: PUSH
41032: LD_VAR 0 2
41036: ARRAY
41037: OR
41038: IFFALSE 41042
// continue ;
41040: GO 40959
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41042: LD_ADDR_VAR 0 8
41046: PUSH
41047: LD_EXP 78
41051: PUSH
41052: LD_VAR 0 2
41056: ARRAY
41057: PPUSH
41058: LD_INT 25
41060: PUSH
41061: LD_INT 4
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: LD_INT 50
41070: PUSH
41071: EMPTY
41072: LIST
41073: PUSH
41074: LD_INT 3
41076: PUSH
41077: LD_INT 60
41079: PUSH
41080: EMPTY
41081: LIST
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: LIST
41091: PPUSH
41092: CALL_OW 72
41096: PUSH
41097: LD_EXP 82
41101: PUSH
41102: LD_VAR 0 2
41106: ARRAY
41107: DIFF
41108: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41109: LD_ADDR_VAR 0 9
41113: PUSH
41114: LD_EXP 78
41118: PUSH
41119: LD_VAR 0 2
41123: ARRAY
41124: PPUSH
41125: LD_INT 2
41127: PUSH
41128: LD_INT 30
41130: PUSH
41131: LD_INT 0
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 30
41140: PUSH
41141: LD_INT 1
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: LIST
41152: PPUSH
41153: CALL_OW 72
41157: ST_TO_ADDR
// if not tmp or not dep then
41158: LD_VAR 0 8
41162: NOT
41163: PUSH
41164: LD_VAR 0 9
41168: NOT
41169: OR
41170: IFFALSE 41174
// continue ;
41172: GO 40959
// side := GetSide ( tmp [ 1 ] ) ;
41174: LD_ADDR_VAR 0 11
41178: PUSH
41179: LD_VAR 0 8
41183: PUSH
41184: LD_INT 1
41186: ARRAY
41187: PPUSH
41188: CALL_OW 255
41192: ST_TO_ADDR
// dep := dep [ 1 ] ;
41193: LD_ADDR_VAR 0 9
41197: PUSH
41198: LD_VAR 0 9
41202: PUSH
41203: LD_INT 1
41205: ARRAY
41206: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
41207: LD_ADDR_VAR 0 7
41211: PUSH
41212: LD_EXP 106
41216: PUSH
41217: LD_VAR 0 2
41221: ARRAY
41222: PPUSH
41223: LD_INT 22
41225: PUSH
41226: LD_INT 0
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 25
41235: PUSH
41236: LD_INT 12
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PPUSH
41247: CALL_OW 70
41251: PUSH
41252: LD_INT 22
41254: PUSH
41255: LD_INT 0
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PUSH
41262: LD_INT 25
41264: PUSH
41265: LD_INT 12
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: LD_INT 91
41274: PUSH
41275: LD_VAR 0 9
41279: PUSH
41280: LD_INT 20
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: LIST
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: LIST
41292: PPUSH
41293: CALL_OW 69
41297: UNION
41298: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
41299: LD_ADDR_VAR 0 10
41303: PUSH
41304: LD_EXP 106
41308: PUSH
41309: LD_VAR 0 2
41313: ARRAY
41314: PPUSH
41315: LD_INT 81
41317: PUSH
41318: LD_VAR 0 11
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PPUSH
41327: CALL_OW 70
41331: ST_TO_ADDR
// if not apes or danger_at_area then
41332: LD_VAR 0 7
41336: NOT
41337: PUSH
41338: LD_VAR 0 10
41342: OR
41343: IFFALSE 41393
// begin if mc_taming [ i ] then
41345: LD_EXP 109
41349: PUSH
41350: LD_VAR 0 2
41354: ARRAY
41355: IFFALSE 41391
// begin MC_Reset ( i , 121 ) ;
41357: LD_VAR 0 2
41361: PPUSH
41362: LD_INT 121
41364: PPUSH
41365: CALL 26323 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41369: LD_ADDR_EXP 109
41373: PUSH
41374: LD_EXP 109
41378: PPUSH
41379: LD_VAR 0 2
41383: PPUSH
41384: EMPTY
41385: PPUSH
41386: CALL_OW 1
41390: ST_TO_ADDR
// end ; continue ;
41391: GO 40959
// end ; for j in tmp do
41393: LD_ADDR_VAR 0 3
41397: PUSH
41398: LD_VAR 0 8
41402: PUSH
41403: FOR_IN
41404: IFFALSE 41740
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
41406: LD_VAR 0 3
41410: PUSH
41411: LD_EXP 109
41415: PUSH
41416: LD_VAR 0 2
41420: ARRAY
41421: IN
41422: NOT
41423: PUSH
41424: LD_EXP 109
41428: PUSH
41429: LD_VAR 0 2
41433: ARRAY
41434: PUSH
41435: LD_INT 3
41437: LESS
41438: AND
41439: IFFALSE 41497
// begin SetTag ( j , 121 ) ;
41441: LD_VAR 0 3
41445: PPUSH
41446: LD_INT 121
41448: PPUSH
41449: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
41453: LD_ADDR_EXP 109
41457: PUSH
41458: LD_EXP 109
41462: PPUSH
41463: LD_VAR 0 2
41467: PUSH
41468: LD_EXP 109
41472: PUSH
41473: LD_VAR 0 2
41477: ARRAY
41478: PUSH
41479: LD_INT 1
41481: PLUS
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PPUSH
41487: LD_VAR 0 3
41491: PPUSH
41492: CALL 57810 0 3
41496: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
41497: LD_VAR 0 3
41501: PUSH
41502: LD_EXP 109
41506: PUSH
41507: LD_VAR 0 2
41511: ARRAY
41512: IN
41513: IFFALSE 41738
// begin if GetClass ( j ) <> 4 then
41515: LD_VAR 0 3
41519: PPUSH
41520: CALL_OW 257
41524: PUSH
41525: LD_INT 4
41527: NONEQUAL
41528: IFFALSE 41581
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
41530: LD_ADDR_EXP 109
41534: PUSH
41535: LD_EXP 109
41539: PPUSH
41540: LD_VAR 0 2
41544: PPUSH
41545: LD_EXP 109
41549: PUSH
41550: LD_VAR 0 2
41554: ARRAY
41555: PUSH
41556: LD_VAR 0 3
41560: DIFF
41561: PPUSH
41562: CALL_OW 1
41566: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41567: LD_VAR 0 3
41571: PPUSH
41572: LD_INT 0
41574: PPUSH
41575: CALL_OW 109
// continue ;
41579: GO 41403
// end ; if IsInUnit ( j ) then
41581: LD_VAR 0 3
41585: PPUSH
41586: CALL_OW 310
41590: IFFALSE 41601
// ComExitBuilding ( j ) ;
41592: LD_VAR 0 3
41596: PPUSH
41597: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
41601: LD_ADDR_VAR 0 6
41605: PUSH
41606: LD_VAR 0 7
41610: PPUSH
41611: LD_VAR 0 3
41615: PPUSH
41616: CALL_OW 74
41620: ST_TO_ADDR
// if not ape then
41621: LD_VAR 0 6
41625: NOT
41626: IFFALSE 41630
// break ;
41628: GO 41740
// x := GetX ( ape ) ;
41630: LD_ADDR_VAR 0 4
41634: PUSH
41635: LD_VAR 0 6
41639: PPUSH
41640: CALL_OW 250
41644: ST_TO_ADDR
// y := GetY ( ape ) ;
41645: LD_ADDR_VAR 0 5
41649: PUSH
41650: LD_VAR 0 6
41654: PPUSH
41655: CALL_OW 251
41659: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
41660: LD_VAR 0 4
41664: PPUSH
41665: LD_VAR 0 5
41669: PPUSH
41670: CALL_OW 488
41674: NOT
41675: PUSH
41676: LD_VAR 0 11
41680: PPUSH
41681: LD_VAR 0 4
41685: PPUSH
41686: LD_VAR 0 5
41690: PPUSH
41691: LD_INT 20
41693: PPUSH
41694: CALL 58706 0 4
41698: PUSH
41699: LD_INT 4
41701: ARRAY
41702: OR
41703: IFFALSE 41707
// break ;
41705: GO 41740
// if not HasTask ( j ) then
41707: LD_VAR 0 3
41711: PPUSH
41712: CALL_OW 314
41716: NOT
41717: IFFALSE 41738
// ComTameXY ( j , x , y ) ;
41719: LD_VAR 0 3
41723: PPUSH
41724: LD_VAR 0 4
41728: PPUSH
41729: LD_VAR 0 5
41733: PPUSH
41734: CALL_OW 131
// end ; end ;
41738: GO 41403
41740: POP
41741: POP
// end ;
41742: GO 40959
41744: POP
41745: POP
// end ;
41746: LD_VAR 0 1
41750: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
41751: LD_INT 0
41753: PPUSH
41754: PPUSH
41755: PPUSH
41756: PPUSH
41757: PPUSH
41758: PPUSH
41759: PPUSH
41760: PPUSH
// if not mc_bases then
41761: LD_EXP 78
41765: NOT
41766: IFFALSE 41770
// exit ;
41768: GO 42396
// for i = 1 to mc_bases do
41770: LD_ADDR_VAR 0 2
41774: PUSH
41775: DOUBLE
41776: LD_INT 1
41778: DEC
41779: ST_TO_ADDR
41780: LD_EXP 78
41784: PUSH
41785: FOR_TO
41786: IFFALSE 42394
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
41788: LD_EXP 107
41792: PUSH
41793: LD_VAR 0 2
41797: ARRAY
41798: NOT
41799: PUSH
41800: LD_EXP 107
41804: PUSH
41805: LD_VAR 0 2
41809: ARRAY
41810: PPUSH
41811: LD_INT 25
41813: PUSH
41814: LD_INT 12
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: PPUSH
41821: CALL_OW 72
41825: NOT
41826: OR
41827: IFFALSE 41831
// continue ;
41829: GO 41785
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41831: LD_ADDR_VAR 0 5
41835: PUSH
41836: LD_EXP 107
41840: PUSH
41841: LD_VAR 0 2
41845: ARRAY
41846: PUSH
41847: LD_INT 1
41849: ARRAY
41850: PPUSH
41851: CALL_OW 255
41855: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41856: LD_VAR 0 5
41860: PPUSH
41861: LD_INT 2
41863: PPUSH
41864: CALL_OW 325
41868: IFFALSE 42121
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41870: LD_ADDR_VAR 0 4
41874: PUSH
41875: LD_EXP 107
41879: PUSH
41880: LD_VAR 0 2
41884: ARRAY
41885: PPUSH
41886: LD_INT 25
41888: PUSH
41889: LD_INT 16
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PPUSH
41896: CALL_OW 72
41900: ST_TO_ADDR
// if tmp < 6 then
41901: LD_VAR 0 4
41905: PUSH
41906: LD_INT 6
41908: LESS
41909: IFFALSE 42121
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41911: LD_ADDR_VAR 0 6
41915: PUSH
41916: LD_EXP 78
41920: PUSH
41921: LD_VAR 0 2
41925: ARRAY
41926: PPUSH
41927: LD_INT 2
41929: PUSH
41930: LD_INT 30
41932: PUSH
41933: LD_INT 0
41935: PUSH
41936: EMPTY
41937: LIST
41938: LIST
41939: PUSH
41940: LD_INT 30
41942: PUSH
41943: LD_INT 1
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: PPUSH
41955: CALL_OW 72
41959: ST_TO_ADDR
// if depot then
41960: LD_VAR 0 6
41964: IFFALSE 42121
// begin selected := 0 ;
41966: LD_ADDR_VAR 0 7
41970: PUSH
41971: LD_INT 0
41973: ST_TO_ADDR
// for j in depot do
41974: LD_ADDR_VAR 0 3
41978: PUSH
41979: LD_VAR 0 6
41983: PUSH
41984: FOR_IN
41985: IFFALSE 42016
// begin if UnitsInside ( j ) < 6 then
41987: LD_VAR 0 3
41991: PPUSH
41992: CALL_OW 313
41996: PUSH
41997: LD_INT 6
41999: LESS
42000: IFFALSE 42014
// begin selected := j ;
42002: LD_ADDR_VAR 0 7
42006: PUSH
42007: LD_VAR 0 3
42011: ST_TO_ADDR
// break ;
42012: GO 42016
// end ; end ;
42014: GO 41984
42016: POP
42017: POP
// if selected then
42018: LD_VAR 0 7
42022: IFFALSE 42121
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42024: LD_ADDR_VAR 0 3
42028: PUSH
42029: LD_EXP 107
42033: PUSH
42034: LD_VAR 0 2
42038: ARRAY
42039: PPUSH
42040: LD_INT 25
42042: PUSH
42043: LD_INT 12
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PPUSH
42050: CALL_OW 72
42054: PUSH
42055: FOR_IN
42056: IFFALSE 42119
// if not HasTask ( j ) then
42058: LD_VAR 0 3
42062: PPUSH
42063: CALL_OW 314
42067: NOT
42068: IFFALSE 42117
// begin if not IsInUnit ( j ) then
42070: LD_VAR 0 3
42074: PPUSH
42075: CALL_OW 310
42079: NOT
42080: IFFALSE 42096
// ComEnterUnit ( j , selected ) ;
42082: LD_VAR 0 3
42086: PPUSH
42087: LD_VAR 0 7
42091: PPUSH
42092: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42096: LD_VAR 0 3
42100: PPUSH
42101: LD_INT 16
42103: PPUSH
42104: CALL_OW 183
// AddComExitBuilding ( j ) ;
42108: LD_VAR 0 3
42112: PPUSH
42113: CALL_OW 182
// end ;
42117: GO 42055
42119: POP
42120: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
42121: LD_VAR 0 5
42125: PPUSH
42126: LD_INT 11
42128: PPUSH
42129: CALL_OW 325
42133: IFFALSE 42392
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42135: LD_ADDR_VAR 0 4
42139: PUSH
42140: LD_EXP 107
42144: PUSH
42145: LD_VAR 0 2
42149: ARRAY
42150: PPUSH
42151: LD_INT 25
42153: PUSH
42154: LD_INT 16
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PPUSH
42161: CALL_OW 72
42165: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
42166: LD_VAR 0 4
42170: PUSH
42171: LD_INT 6
42173: GREATEREQUAL
42174: PUSH
42175: LD_VAR 0 5
42179: PPUSH
42180: LD_INT 2
42182: PPUSH
42183: CALL_OW 325
42187: NOT
42188: OR
42189: IFFALSE 42392
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42191: LD_ADDR_VAR 0 8
42195: PUSH
42196: LD_EXP 78
42200: PUSH
42201: LD_VAR 0 2
42205: ARRAY
42206: PPUSH
42207: LD_INT 2
42209: PUSH
42210: LD_INT 30
42212: PUSH
42213: LD_INT 4
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PUSH
42220: LD_INT 30
42222: PUSH
42223: LD_INT 5
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: LIST
42234: PPUSH
42235: CALL_OW 72
42239: ST_TO_ADDR
// if barracks then
42240: LD_VAR 0 8
42244: IFFALSE 42392
// begin selected := 0 ;
42246: LD_ADDR_VAR 0 7
42250: PUSH
42251: LD_INT 0
42253: ST_TO_ADDR
// for j in barracks do
42254: LD_ADDR_VAR 0 3
42258: PUSH
42259: LD_VAR 0 8
42263: PUSH
42264: FOR_IN
42265: IFFALSE 42296
// begin if UnitsInside ( j ) < 6 then
42267: LD_VAR 0 3
42271: PPUSH
42272: CALL_OW 313
42276: PUSH
42277: LD_INT 6
42279: LESS
42280: IFFALSE 42294
// begin selected := j ;
42282: LD_ADDR_VAR 0 7
42286: PUSH
42287: LD_VAR 0 3
42291: ST_TO_ADDR
// break ;
42292: GO 42296
// end ; end ;
42294: GO 42264
42296: POP
42297: POP
// if selected then
42298: LD_VAR 0 7
42302: IFFALSE 42392
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42304: LD_ADDR_VAR 0 3
42308: PUSH
42309: LD_EXP 107
42313: PUSH
42314: LD_VAR 0 2
42318: ARRAY
42319: PPUSH
42320: LD_INT 25
42322: PUSH
42323: LD_INT 12
42325: PUSH
42326: EMPTY
42327: LIST
42328: LIST
42329: PPUSH
42330: CALL_OW 72
42334: PUSH
42335: FOR_IN
42336: IFFALSE 42390
// if not IsInUnit ( j ) and not HasTask ( j ) then
42338: LD_VAR 0 3
42342: PPUSH
42343: CALL_OW 310
42347: NOT
42348: PUSH
42349: LD_VAR 0 3
42353: PPUSH
42354: CALL_OW 314
42358: NOT
42359: AND
42360: IFFALSE 42388
// begin ComEnterUnit ( j , selected ) ;
42362: LD_VAR 0 3
42366: PPUSH
42367: LD_VAR 0 7
42371: PPUSH
42372: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
42376: LD_VAR 0 3
42380: PPUSH
42381: LD_INT 15
42383: PPUSH
42384: CALL_OW 183
// end ;
42388: GO 42335
42390: POP
42391: POP
// end ; end ; end ; end ; end ;
42392: GO 41785
42394: POP
42395: POP
// end ;
42396: LD_VAR 0 1
42400: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
42401: LD_INT 0
42403: PPUSH
42404: PPUSH
42405: PPUSH
42406: PPUSH
// if not mc_bases then
42407: LD_EXP 78
42411: NOT
42412: IFFALSE 42416
// exit ;
42414: GO 42594
// for i = 1 to mc_bases do
42416: LD_ADDR_VAR 0 2
42420: PUSH
42421: DOUBLE
42422: LD_INT 1
42424: DEC
42425: ST_TO_ADDR
42426: LD_EXP 78
42430: PUSH
42431: FOR_TO
42432: IFFALSE 42592
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
42434: LD_ADDR_VAR 0 4
42438: PUSH
42439: LD_EXP 78
42443: PUSH
42444: LD_VAR 0 2
42448: ARRAY
42449: PPUSH
42450: LD_INT 25
42452: PUSH
42453: LD_INT 9
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PPUSH
42460: CALL_OW 72
42464: ST_TO_ADDR
// if not tmp then
42465: LD_VAR 0 4
42469: NOT
42470: IFFALSE 42474
// continue ;
42472: GO 42431
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
42474: LD_EXP 104
42478: PUSH
42479: LD_VAR 0 2
42483: ARRAY
42484: PPUSH
42485: LD_INT 29
42487: PPUSH
42488: CALL_OW 325
42492: NOT
42493: PUSH
42494: LD_EXP 104
42498: PUSH
42499: LD_VAR 0 2
42503: ARRAY
42504: PPUSH
42505: LD_INT 28
42507: PPUSH
42508: CALL_OW 325
42512: NOT
42513: AND
42514: IFFALSE 42518
// continue ;
42516: GO 42431
// for j in tmp do
42518: LD_ADDR_VAR 0 3
42522: PUSH
42523: LD_VAR 0 4
42527: PUSH
42528: FOR_IN
42529: IFFALSE 42588
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
42531: LD_VAR 0 3
42535: PUSH
42536: LD_EXP 81
42540: PUSH
42541: LD_VAR 0 2
42545: ARRAY
42546: PUSH
42547: LD_INT 1
42549: ARRAY
42550: IN
42551: NOT
42552: PUSH
42553: LD_VAR 0 3
42557: PUSH
42558: LD_EXP 81
42562: PUSH
42563: LD_VAR 0 2
42567: ARRAY
42568: PUSH
42569: LD_INT 2
42571: ARRAY
42572: IN
42573: NOT
42574: AND
42575: IFFALSE 42586
// ComSpaceTimeShoot ( j ) ;
42577: LD_VAR 0 3
42581: PPUSH
42582: CALL 53795 0 1
42586: GO 42528
42588: POP
42589: POP
// end ;
42590: GO 42431
42592: POP
42593: POP
// end ;
42594: LD_VAR 0 1
42598: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
42599: LD_INT 0
42601: PPUSH
42602: PPUSH
42603: PPUSH
42604: PPUSH
42605: PPUSH
42606: PPUSH
42607: PPUSH
42608: PPUSH
42609: PPUSH
// if not mc_bases then
42610: LD_EXP 78
42614: NOT
42615: IFFALSE 42619
// exit ;
42617: GO 43241
// for i = 1 to mc_bases do
42619: LD_ADDR_VAR 0 2
42623: PUSH
42624: DOUBLE
42625: LD_INT 1
42627: DEC
42628: ST_TO_ADDR
42629: LD_EXP 78
42633: PUSH
42634: FOR_TO
42635: IFFALSE 43239
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
42637: LD_EXP 113
42641: PUSH
42642: LD_VAR 0 2
42646: ARRAY
42647: NOT
42648: PUSH
42649: LD_INT 38
42651: PPUSH
42652: LD_EXP 104
42656: PUSH
42657: LD_VAR 0 2
42661: ARRAY
42662: PPUSH
42663: CALL_OW 321
42667: PUSH
42668: LD_INT 2
42670: NONEQUAL
42671: OR
42672: IFFALSE 42676
// continue ;
42674: GO 42634
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
42676: LD_ADDR_VAR 0 8
42680: PUSH
42681: LD_EXP 78
42685: PUSH
42686: LD_VAR 0 2
42690: ARRAY
42691: PPUSH
42692: LD_INT 30
42694: PUSH
42695: LD_INT 34
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PPUSH
42702: CALL_OW 72
42706: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
42707: LD_ADDR_VAR 0 9
42711: PUSH
42712: LD_EXP 78
42716: PUSH
42717: LD_VAR 0 2
42721: ARRAY
42722: PPUSH
42723: LD_INT 25
42725: PUSH
42726: LD_INT 4
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PPUSH
42733: CALL_OW 72
42737: PPUSH
42738: LD_INT 0
42740: PPUSH
42741: CALL 87722 0 2
42745: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
42746: LD_VAR 0 9
42750: NOT
42751: PUSH
42752: LD_VAR 0 8
42756: NOT
42757: OR
42758: PUSH
42759: LD_EXP 78
42763: PUSH
42764: LD_VAR 0 2
42768: ARRAY
42769: PPUSH
42770: LD_INT 124
42772: PPUSH
42773: CALL 87722 0 2
42777: OR
42778: IFFALSE 42782
// continue ;
42780: GO 42634
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
42782: LD_EXP 114
42786: PUSH
42787: LD_VAR 0 2
42791: ARRAY
42792: PUSH
42793: LD_EXP 113
42797: PUSH
42798: LD_VAR 0 2
42802: ARRAY
42803: LESS
42804: PUSH
42805: LD_EXP 114
42809: PUSH
42810: LD_VAR 0 2
42814: ARRAY
42815: PUSH
42816: LD_VAR 0 8
42820: LESS
42821: AND
42822: IFFALSE 43237
// begin tmp := sci [ 1 ] ;
42824: LD_ADDR_VAR 0 7
42828: PUSH
42829: LD_VAR 0 9
42833: PUSH
42834: LD_INT 1
42836: ARRAY
42837: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42838: LD_VAR 0 7
42842: PPUSH
42843: LD_INT 124
42845: PPUSH
42846: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42850: LD_ADDR_VAR 0 3
42854: PUSH
42855: DOUBLE
42856: LD_EXP 113
42860: PUSH
42861: LD_VAR 0 2
42865: ARRAY
42866: INC
42867: ST_TO_ADDR
42868: LD_EXP 113
42872: PUSH
42873: LD_VAR 0 2
42877: ARRAY
42878: PUSH
42879: FOR_DOWNTO
42880: IFFALSE 43223
// begin if IsInUnit ( tmp ) then
42882: LD_VAR 0 7
42886: PPUSH
42887: CALL_OW 310
42891: IFFALSE 42902
// ComExitBuilding ( tmp ) ;
42893: LD_VAR 0 7
42897: PPUSH
42898: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42902: LD_INT 35
42904: PPUSH
42905: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42909: LD_VAR 0 7
42913: PPUSH
42914: CALL_OW 310
42918: NOT
42919: PUSH
42920: LD_VAR 0 7
42924: PPUSH
42925: CALL_OW 314
42929: NOT
42930: AND
42931: IFFALSE 42902
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42933: LD_ADDR_VAR 0 6
42937: PUSH
42938: LD_VAR 0 7
42942: PPUSH
42943: CALL_OW 250
42947: PUSH
42948: LD_VAR 0 7
42952: PPUSH
42953: CALL_OW 251
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42962: LD_INT 35
42964: PPUSH
42965: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42969: LD_ADDR_VAR 0 4
42973: PUSH
42974: LD_EXP 113
42978: PUSH
42979: LD_VAR 0 2
42983: ARRAY
42984: PUSH
42985: LD_VAR 0 3
42989: ARRAY
42990: PUSH
42991: LD_INT 1
42993: ARRAY
42994: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42995: LD_ADDR_VAR 0 5
42999: PUSH
43000: LD_EXP 113
43004: PUSH
43005: LD_VAR 0 2
43009: ARRAY
43010: PUSH
43011: LD_VAR 0 3
43015: ARRAY
43016: PUSH
43017: LD_INT 2
43019: ARRAY
43020: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
43021: LD_VAR 0 7
43025: PPUSH
43026: LD_INT 10
43028: PPUSH
43029: CALL 60407 0 2
43033: PUSH
43034: LD_INT 4
43036: ARRAY
43037: IFFALSE 43075
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43039: LD_VAR 0 7
43043: PPUSH
43044: LD_VAR 0 6
43048: PUSH
43049: LD_INT 1
43051: ARRAY
43052: PPUSH
43053: LD_VAR 0 6
43057: PUSH
43058: LD_INT 2
43060: ARRAY
43061: PPUSH
43062: CALL_OW 111
// wait ( 0 0$10 ) ;
43066: LD_INT 350
43068: PPUSH
43069: CALL_OW 67
// end else
43073: GO 43101
// begin ComMoveXY ( tmp , x , y ) ;
43075: LD_VAR 0 7
43079: PPUSH
43080: LD_VAR 0 4
43084: PPUSH
43085: LD_VAR 0 5
43089: PPUSH
43090: CALL_OW 111
// wait ( 0 0$3 ) ;
43094: LD_INT 105
43096: PPUSH
43097: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43101: LD_VAR 0 7
43105: PPUSH
43106: LD_VAR 0 4
43110: PPUSH
43111: LD_VAR 0 5
43115: PPUSH
43116: CALL_OW 307
43120: IFFALSE 42962
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
43122: LD_VAR 0 7
43126: PPUSH
43127: LD_VAR 0 4
43131: PPUSH
43132: LD_VAR 0 5
43136: PPUSH
43137: LD_VAR 0 8
43141: PUSH
43142: LD_VAR 0 3
43146: ARRAY
43147: PPUSH
43148: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
43152: LD_INT 35
43154: PPUSH
43155: CALL_OW 67
// until not HasTask ( tmp ) ;
43159: LD_VAR 0 7
43163: PPUSH
43164: CALL_OW 314
43168: NOT
43169: IFFALSE 43152
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
43171: LD_ADDR_EXP 114
43175: PUSH
43176: LD_EXP 114
43180: PPUSH
43181: LD_VAR 0 2
43185: PUSH
43186: LD_EXP 114
43190: PUSH
43191: LD_VAR 0 2
43195: ARRAY
43196: PUSH
43197: LD_INT 1
43199: PLUS
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: PPUSH
43205: LD_VAR 0 8
43209: PUSH
43210: LD_VAR 0 3
43214: ARRAY
43215: PPUSH
43216: CALL 57810 0 3
43220: ST_TO_ADDR
// end ;
43221: GO 42879
43223: POP
43224: POP
// MC_Reset ( i , 124 ) ;
43225: LD_VAR 0 2
43229: PPUSH
43230: LD_INT 124
43232: PPUSH
43233: CALL 26323 0 2
// end ; end ;
43237: GO 42634
43239: POP
43240: POP
// end ;
43241: LD_VAR 0 1
43245: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
43246: LD_INT 0
43248: PPUSH
43249: PPUSH
43250: PPUSH
// if not mc_bases then
43251: LD_EXP 78
43255: NOT
43256: IFFALSE 43260
// exit ;
43258: GO 43866
// for i = 1 to mc_bases do
43260: LD_ADDR_VAR 0 2
43264: PUSH
43265: DOUBLE
43266: LD_INT 1
43268: DEC
43269: ST_TO_ADDR
43270: LD_EXP 78
43274: PUSH
43275: FOR_TO
43276: IFFALSE 43864
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43278: LD_ADDR_VAR 0 3
43282: PUSH
43283: LD_EXP 78
43287: PUSH
43288: LD_VAR 0 2
43292: ARRAY
43293: PPUSH
43294: LD_INT 25
43296: PUSH
43297: LD_INT 4
43299: PUSH
43300: EMPTY
43301: LIST
43302: LIST
43303: PPUSH
43304: CALL_OW 72
43308: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43309: LD_VAR 0 3
43313: NOT
43314: PUSH
43315: LD_EXP 115
43319: PUSH
43320: LD_VAR 0 2
43324: ARRAY
43325: NOT
43326: OR
43327: PUSH
43328: LD_EXP 78
43332: PUSH
43333: LD_VAR 0 2
43337: ARRAY
43338: PPUSH
43339: LD_INT 2
43341: PUSH
43342: LD_INT 30
43344: PUSH
43345: LD_INT 0
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: LD_INT 30
43354: PUSH
43355: LD_INT 1
43357: PUSH
43358: EMPTY
43359: LIST
43360: LIST
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: LIST
43366: PPUSH
43367: CALL_OW 72
43371: NOT
43372: OR
43373: IFFALSE 43423
// begin if mc_deposits_finder [ i ] then
43375: LD_EXP 116
43379: PUSH
43380: LD_VAR 0 2
43384: ARRAY
43385: IFFALSE 43421
// begin MC_Reset ( i , 125 ) ;
43387: LD_VAR 0 2
43391: PPUSH
43392: LD_INT 125
43394: PPUSH
43395: CALL 26323 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43399: LD_ADDR_EXP 116
43403: PUSH
43404: LD_EXP 116
43408: PPUSH
43409: LD_VAR 0 2
43413: PPUSH
43414: EMPTY
43415: PPUSH
43416: CALL_OW 1
43420: ST_TO_ADDR
// end ; continue ;
43421: GO 43275
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
43423: LD_EXP 115
43427: PUSH
43428: LD_VAR 0 2
43432: ARRAY
43433: PUSH
43434: LD_INT 1
43436: ARRAY
43437: PUSH
43438: LD_INT 3
43440: ARRAY
43441: PUSH
43442: LD_INT 1
43444: EQUAL
43445: PUSH
43446: LD_INT 20
43448: PPUSH
43449: LD_EXP 104
43453: PUSH
43454: LD_VAR 0 2
43458: ARRAY
43459: PPUSH
43460: CALL_OW 321
43464: PUSH
43465: LD_INT 2
43467: NONEQUAL
43468: AND
43469: IFFALSE 43519
// begin if mc_deposits_finder [ i ] then
43471: LD_EXP 116
43475: PUSH
43476: LD_VAR 0 2
43480: ARRAY
43481: IFFALSE 43517
// begin MC_Reset ( i , 125 ) ;
43483: LD_VAR 0 2
43487: PPUSH
43488: LD_INT 125
43490: PPUSH
43491: CALL 26323 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43495: LD_ADDR_EXP 116
43499: PUSH
43500: LD_EXP 116
43504: PPUSH
43505: LD_VAR 0 2
43509: PPUSH
43510: EMPTY
43511: PPUSH
43512: CALL_OW 1
43516: ST_TO_ADDR
// end ; continue ;
43517: GO 43275
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
43519: LD_EXP 115
43523: PUSH
43524: LD_VAR 0 2
43528: ARRAY
43529: PUSH
43530: LD_INT 1
43532: ARRAY
43533: PUSH
43534: LD_INT 1
43536: ARRAY
43537: PPUSH
43538: LD_EXP 115
43542: PUSH
43543: LD_VAR 0 2
43547: ARRAY
43548: PUSH
43549: LD_INT 1
43551: ARRAY
43552: PUSH
43553: LD_INT 2
43555: ARRAY
43556: PPUSH
43557: LD_EXP 104
43561: PUSH
43562: LD_VAR 0 2
43566: ARRAY
43567: PPUSH
43568: CALL_OW 440
43572: IFFALSE 43615
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
43574: LD_ADDR_EXP 115
43578: PUSH
43579: LD_EXP 115
43583: PPUSH
43584: LD_VAR 0 2
43588: PPUSH
43589: LD_EXP 115
43593: PUSH
43594: LD_VAR 0 2
43598: ARRAY
43599: PPUSH
43600: LD_INT 1
43602: PPUSH
43603: CALL_OW 3
43607: PPUSH
43608: CALL_OW 1
43612: ST_TO_ADDR
43613: GO 43862
// begin if not mc_deposits_finder [ i ] then
43615: LD_EXP 116
43619: PUSH
43620: LD_VAR 0 2
43624: ARRAY
43625: NOT
43626: IFFALSE 43678
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
43628: LD_ADDR_EXP 116
43632: PUSH
43633: LD_EXP 116
43637: PPUSH
43638: LD_VAR 0 2
43642: PPUSH
43643: LD_VAR 0 3
43647: PUSH
43648: LD_INT 1
43650: ARRAY
43651: PUSH
43652: EMPTY
43653: LIST
43654: PPUSH
43655: CALL_OW 1
43659: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
43660: LD_VAR 0 3
43664: PUSH
43665: LD_INT 1
43667: ARRAY
43668: PPUSH
43669: LD_INT 125
43671: PPUSH
43672: CALL_OW 109
// end else
43676: GO 43862
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
43678: LD_EXP 116
43682: PUSH
43683: LD_VAR 0 2
43687: ARRAY
43688: PUSH
43689: LD_INT 1
43691: ARRAY
43692: PPUSH
43693: CALL_OW 310
43697: IFFALSE 43720
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
43699: LD_EXP 116
43703: PUSH
43704: LD_VAR 0 2
43708: ARRAY
43709: PUSH
43710: LD_INT 1
43712: ARRAY
43713: PPUSH
43714: CALL_OW 122
43718: GO 43862
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
43720: LD_EXP 116
43724: PUSH
43725: LD_VAR 0 2
43729: ARRAY
43730: PUSH
43731: LD_INT 1
43733: ARRAY
43734: PPUSH
43735: CALL_OW 314
43739: NOT
43740: PUSH
43741: LD_EXP 116
43745: PUSH
43746: LD_VAR 0 2
43750: ARRAY
43751: PUSH
43752: LD_INT 1
43754: ARRAY
43755: PPUSH
43756: LD_EXP 115
43760: PUSH
43761: LD_VAR 0 2
43765: ARRAY
43766: PUSH
43767: LD_INT 1
43769: ARRAY
43770: PUSH
43771: LD_INT 1
43773: ARRAY
43774: PPUSH
43775: LD_EXP 115
43779: PUSH
43780: LD_VAR 0 2
43784: ARRAY
43785: PUSH
43786: LD_INT 1
43788: ARRAY
43789: PUSH
43790: LD_INT 2
43792: ARRAY
43793: PPUSH
43794: CALL_OW 297
43798: PUSH
43799: LD_INT 6
43801: GREATER
43802: AND
43803: IFFALSE 43862
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
43805: LD_EXP 116
43809: PUSH
43810: LD_VAR 0 2
43814: ARRAY
43815: PUSH
43816: LD_INT 1
43818: ARRAY
43819: PPUSH
43820: LD_EXP 115
43824: PUSH
43825: LD_VAR 0 2
43829: ARRAY
43830: PUSH
43831: LD_INT 1
43833: ARRAY
43834: PUSH
43835: LD_INT 1
43837: ARRAY
43838: PPUSH
43839: LD_EXP 115
43843: PUSH
43844: LD_VAR 0 2
43848: ARRAY
43849: PUSH
43850: LD_INT 1
43852: ARRAY
43853: PUSH
43854: LD_INT 2
43856: ARRAY
43857: PPUSH
43858: CALL_OW 111
// end ; end ; end ;
43862: GO 43275
43864: POP
43865: POP
// end ;
43866: LD_VAR 0 1
43870: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43871: LD_INT 0
43873: PPUSH
43874: PPUSH
43875: PPUSH
43876: PPUSH
43877: PPUSH
43878: PPUSH
43879: PPUSH
43880: PPUSH
43881: PPUSH
43882: PPUSH
43883: PPUSH
// if not mc_bases then
43884: LD_EXP 78
43888: NOT
43889: IFFALSE 43893
// exit ;
43891: GO 44833
// for i = 1 to mc_bases do
43893: LD_ADDR_VAR 0 2
43897: PUSH
43898: DOUBLE
43899: LD_INT 1
43901: DEC
43902: ST_TO_ADDR
43903: LD_EXP 78
43907: PUSH
43908: FOR_TO
43909: IFFALSE 44831
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43911: LD_EXP 78
43915: PUSH
43916: LD_VAR 0 2
43920: ARRAY
43921: NOT
43922: PUSH
43923: LD_EXP 101
43927: PUSH
43928: LD_VAR 0 2
43932: ARRAY
43933: OR
43934: IFFALSE 43938
// continue ;
43936: GO 43908
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43938: LD_ADDR_VAR 0 7
43942: PUSH
43943: LD_EXP 78
43947: PUSH
43948: LD_VAR 0 2
43952: ARRAY
43953: PUSH
43954: LD_INT 1
43956: ARRAY
43957: PPUSH
43958: CALL_OW 248
43962: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43963: LD_VAR 0 7
43967: PUSH
43968: LD_INT 3
43970: EQUAL
43971: PUSH
43972: LD_EXP 97
43976: PUSH
43977: LD_VAR 0 2
43981: ARRAY
43982: PUSH
43983: LD_EXP 100
43987: PUSH
43988: LD_VAR 0 2
43992: ARRAY
43993: UNION
43994: PPUSH
43995: LD_INT 33
43997: PUSH
43998: LD_INT 2
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PPUSH
44005: CALL_OW 72
44009: NOT
44010: OR
44011: IFFALSE 44015
// continue ;
44013: GO 43908
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
44015: LD_ADDR_VAR 0 9
44019: PUSH
44020: LD_EXP 78
44024: PUSH
44025: LD_VAR 0 2
44029: ARRAY
44030: PPUSH
44031: LD_INT 30
44033: PUSH
44034: LD_INT 36
44036: PUSH
44037: EMPTY
44038: LIST
44039: LIST
44040: PPUSH
44041: CALL_OW 72
44045: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44046: LD_ADDR_VAR 0 10
44050: PUSH
44051: LD_EXP 97
44055: PUSH
44056: LD_VAR 0 2
44060: ARRAY
44061: PPUSH
44062: LD_INT 34
44064: PUSH
44065: LD_INT 31
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PPUSH
44072: CALL_OW 72
44076: ST_TO_ADDR
// if not cts and not mcts then
44077: LD_VAR 0 9
44081: NOT
44082: PUSH
44083: LD_VAR 0 10
44087: NOT
44088: AND
44089: IFFALSE 44093
// continue ;
44091: GO 43908
// x := cts ;
44093: LD_ADDR_VAR 0 11
44097: PUSH
44098: LD_VAR 0 9
44102: ST_TO_ADDR
// if not x then
44103: LD_VAR 0 11
44107: NOT
44108: IFFALSE 44120
// x := mcts ;
44110: LD_ADDR_VAR 0 11
44114: PUSH
44115: LD_VAR 0 10
44119: ST_TO_ADDR
// if not x then
44120: LD_VAR 0 11
44124: NOT
44125: IFFALSE 44129
// continue ;
44127: GO 43908
// if mc_remote_driver [ i ] then
44129: LD_EXP 118
44133: PUSH
44134: LD_VAR 0 2
44138: ARRAY
44139: IFFALSE 44526
// for j in mc_remote_driver [ i ] do
44141: LD_ADDR_VAR 0 3
44145: PUSH
44146: LD_EXP 118
44150: PUSH
44151: LD_VAR 0 2
44155: ARRAY
44156: PUSH
44157: FOR_IN
44158: IFFALSE 44524
// begin if GetClass ( j ) <> 3 then
44160: LD_VAR 0 3
44164: PPUSH
44165: CALL_OW 257
44169: PUSH
44170: LD_INT 3
44172: NONEQUAL
44173: IFFALSE 44226
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
44175: LD_ADDR_EXP 118
44179: PUSH
44180: LD_EXP 118
44184: PPUSH
44185: LD_VAR 0 2
44189: PPUSH
44190: LD_EXP 118
44194: PUSH
44195: LD_VAR 0 2
44199: ARRAY
44200: PUSH
44201: LD_VAR 0 3
44205: DIFF
44206: PPUSH
44207: CALL_OW 1
44211: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44212: LD_VAR 0 3
44216: PPUSH
44217: LD_INT 0
44219: PPUSH
44220: CALL_OW 109
// continue ;
44224: GO 44157
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
44226: LD_EXP 97
44230: PUSH
44231: LD_VAR 0 2
44235: ARRAY
44236: PPUSH
44237: LD_INT 34
44239: PUSH
44240: LD_INT 31
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: PUSH
44247: LD_INT 58
44249: PUSH
44250: EMPTY
44251: LIST
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: PPUSH
44257: CALL_OW 72
44261: PUSH
44262: LD_VAR 0 3
44266: PPUSH
44267: CALL 87757 0 1
44271: NOT
44272: AND
44273: IFFALSE 44344
// begin if IsInUnit ( j ) then
44275: LD_VAR 0 3
44279: PPUSH
44280: CALL_OW 310
44284: IFFALSE 44295
// ComExitBuilding ( j ) ;
44286: LD_VAR 0 3
44290: PPUSH
44291: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
44295: LD_VAR 0 3
44299: PPUSH
44300: LD_EXP 97
44304: PUSH
44305: LD_VAR 0 2
44309: ARRAY
44310: PPUSH
44311: LD_INT 34
44313: PUSH
44314: LD_INT 31
44316: PUSH
44317: EMPTY
44318: LIST
44319: LIST
44320: PUSH
44321: LD_INT 58
44323: PUSH
44324: EMPTY
44325: LIST
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: PPUSH
44331: CALL_OW 72
44335: PUSH
44336: LD_INT 1
44338: ARRAY
44339: PPUSH
44340: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
44344: LD_VAR 0 3
44348: PPUSH
44349: CALL_OW 310
44353: NOT
44354: PUSH
44355: LD_VAR 0 3
44359: PPUSH
44360: CALL_OW 310
44364: PPUSH
44365: CALL_OW 266
44369: PUSH
44370: LD_INT 36
44372: NONEQUAL
44373: PUSH
44374: LD_VAR 0 3
44378: PPUSH
44379: CALL 87757 0 1
44383: NOT
44384: AND
44385: OR
44386: IFFALSE 44522
// begin if IsInUnit ( j ) then
44388: LD_VAR 0 3
44392: PPUSH
44393: CALL_OW 310
44397: IFFALSE 44408
// ComExitBuilding ( j ) ;
44399: LD_VAR 0 3
44403: PPUSH
44404: CALL_OW 122
// ct := 0 ;
44408: LD_ADDR_VAR 0 8
44412: PUSH
44413: LD_INT 0
44415: ST_TO_ADDR
// for k in x do
44416: LD_ADDR_VAR 0 4
44420: PUSH
44421: LD_VAR 0 11
44425: PUSH
44426: FOR_IN
44427: IFFALSE 44500
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
44429: LD_VAR 0 4
44433: PPUSH
44434: CALL_OW 264
44438: PUSH
44439: LD_INT 31
44441: EQUAL
44442: PUSH
44443: LD_VAR 0 4
44447: PPUSH
44448: CALL_OW 311
44452: NOT
44453: AND
44454: PUSH
44455: LD_VAR 0 4
44459: PPUSH
44460: CALL_OW 266
44464: PUSH
44465: LD_INT 36
44467: EQUAL
44468: PUSH
44469: LD_VAR 0 4
44473: PPUSH
44474: CALL_OW 313
44478: PUSH
44479: LD_INT 3
44481: LESS
44482: AND
44483: OR
44484: IFFALSE 44498
// begin ct := k ;
44486: LD_ADDR_VAR 0 8
44490: PUSH
44491: LD_VAR 0 4
44495: ST_TO_ADDR
// break ;
44496: GO 44500
// end ;
44498: GO 44426
44500: POP
44501: POP
// if ct then
44502: LD_VAR 0 8
44506: IFFALSE 44522
// ComEnterUnit ( j , ct ) ;
44508: LD_VAR 0 3
44512: PPUSH
44513: LD_VAR 0 8
44517: PPUSH
44518: CALL_OW 120
// end ; end ;
44522: GO 44157
44524: POP
44525: POP
// places := 0 ;
44526: LD_ADDR_VAR 0 5
44530: PUSH
44531: LD_INT 0
44533: ST_TO_ADDR
// for j = 1 to x do
44534: LD_ADDR_VAR 0 3
44538: PUSH
44539: DOUBLE
44540: LD_INT 1
44542: DEC
44543: ST_TO_ADDR
44544: LD_VAR 0 11
44548: PUSH
44549: FOR_TO
44550: IFFALSE 44626
// if GetWeapon ( x [ j ] ) = ar_control_tower then
44552: LD_VAR 0 11
44556: PUSH
44557: LD_VAR 0 3
44561: ARRAY
44562: PPUSH
44563: CALL_OW 264
44567: PUSH
44568: LD_INT 31
44570: EQUAL
44571: IFFALSE 44589
// places := places + 1 else
44573: LD_ADDR_VAR 0 5
44577: PUSH
44578: LD_VAR 0 5
44582: PUSH
44583: LD_INT 1
44585: PLUS
44586: ST_TO_ADDR
44587: GO 44624
// if GetBType ( x [ j ] ) = b_control_tower then
44589: LD_VAR 0 11
44593: PUSH
44594: LD_VAR 0 3
44598: ARRAY
44599: PPUSH
44600: CALL_OW 266
44604: PUSH
44605: LD_INT 36
44607: EQUAL
44608: IFFALSE 44624
// places := places + 3 ;
44610: LD_ADDR_VAR 0 5
44614: PUSH
44615: LD_VAR 0 5
44619: PUSH
44620: LD_INT 3
44622: PLUS
44623: ST_TO_ADDR
44624: GO 44549
44626: POP
44627: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
44628: LD_VAR 0 5
44632: PUSH
44633: LD_INT 0
44635: EQUAL
44636: PUSH
44637: LD_VAR 0 5
44641: PUSH
44642: LD_EXP 118
44646: PUSH
44647: LD_VAR 0 2
44651: ARRAY
44652: LESSEQUAL
44653: OR
44654: IFFALSE 44658
// continue ;
44656: GO 43908
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
44658: LD_ADDR_VAR 0 6
44662: PUSH
44663: LD_EXP 78
44667: PUSH
44668: LD_VAR 0 2
44672: ARRAY
44673: PPUSH
44674: LD_INT 25
44676: PUSH
44677: LD_INT 3
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PPUSH
44684: CALL_OW 72
44688: PUSH
44689: LD_EXP 118
44693: PUSH
44694: LD_VAR 0 2
44698: ARRAY
44699: DIFF
44700: PPUSH
44701: LD_INT 3
44703: PPUSH
44704: CALL 88657 0 2
44708: ST_TO_ADDR
// for j in tmp do
44709: LD_ADDR_VAR 0 3
44713: PUSH
44714: LD_VAR 0 6
44718: PUSH
44719: FOR_IN
44720: IFFALSE 44755
// if GetTag ( j ) > 0 then
44722: LD_VAR 0 3
44726: PPUSH
44727: CALL_OW 110
44731: PUSH
44732: LD_INT 0
44734: GREATER
44735: IFFALSE 44753
// tmp := tmp diff j ;
44737: LD_ADDR_VAR 0 6
44741: PUSH
44742: LD_VAR 0 6
44746: PUSH
44747: LD_VAR 0 3
44751: DIFF
44752: ST_TO_ADDR
44753: GO 44719
44755: POP
44756: POP
// if not tmp then
44757: LD_VAR 0 6
44761: NOT
44762: IFFALSE 44766
// continue ;
44764: GO 43908
// if places then
44766: LD_VAR 0 5
44770: IFFALSE 44829
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
44772: LD_ADDR_EXP 118
44776: PUSH
44777: LD_EXP 118
44781: PPUSH
44782: LD_VAR 0 2
44786: PPUSH
44787: LD_EXP 118
44791: PUSH
44792: LD_VAR 0 2
44796: ARRAY
44797: PUSH
44798: LD_VAR 0 6
44802: PUSH
44803: LD_INT 1
44805: ARRAY
44806: UNION
44807: PPUSH
44808: CALL_OW 1
44812: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
44813: LD_VAR 0 6
44817: PUSH
44818: LD_INT 1
44820: ARRAY
44821: PPUSH
44822: LD_INT 126
44824: PPUSH
44825: CALL_OW 109
// end ; end ;
44829: GO 43908
44831: POP
44832: POP
// end ;
44833: LD_VAR 0 1
44837: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44838: LD_INT 0
44840: PPUSH
44841: PPUSH
44842: PPUSH
44843: PPUSH
44844: PPUSH
44845: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44846: LD_VAR 0 1
44850: NOT
44851: PUSH
44852: LD_VAR 0 2
44856: NOT
44857: OR
44858: PUSH
44859: LD_VAR 0 3
44863: NOT
44864: OR
44865: PUSH
44866: LD_VAR 0 4
44870: PUSH
44871: LD_INT 1
44873: PUSH
44874: LD_INT 2
44876: PUSH
44877: LD_INT 3
44879: PUSH
44880: LD_INT 4
44882: PUSH
44883: LD_INT 5
44885: PUSH
44886: LD_INT 8
44888: PUSH
44889: LD_INT 9
44891: PUSH
44892: LD_INT 15
44894: PUSH
44895: LD_INT 16
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: LIST
44905: LIST
44906: LIST
44907: LIST
44908: IN
44909: NOT
44910: OR
44911: IFFALSE 44915
// exit ;
44913: GO 45773
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44915: LD_ADDR_VAR 0 2
44919: PUSH
44920: LD_VAR 0 2
44924: PPUSH
44925: LD_INT 21
44927: PUSH
44928: LD_INT 3
44930: PUSH
44931: EMPTY
44932: LIST
44933: LIST
44934: PUSH
44935: LD_INT 24
44937: PUSH
44938: LD_INT 250
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PPUSH
44949: CALL_OW 72
44953: ST_TO_ADDR
// case class of 1 , 15 :
44954: LD_VAR 0 4
44958: PUSH
44959: LD_INT 1
44961: DOUBLE
44962: EQUAL
44963: IFTRUE 44973
44965: LD_INT 15
44967: DOUBLE
44968: EQUAL
44969: IFTRUE 44973
44971: GO 45058
44973: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44974: LD_ADDR_VAR 0 8
44978: PUSH
44979: LD_VAR 0 2
44983: PPUSH
44984: LD_INT 2
44986: PUSH
44987: LD_INT 30
44989: PUSH
44990: LD_INT 32
44992: PUSH
44993: EMPTY
44994: LIST
44995: LIST
44996: PUSH
44997: LD_INT 30
44999: PUSH
45000: LD_INT 31
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: LIST
45011: PPUSH
45012: CALL_OW 72
45016: PUSH
45017: LD_VAR 0 2
45021: PPUSH
45022: LD_INT 2
45024: PUSH
45025: LD_INT 30
45027: PUSH
45028: LD_INT 4
45030: PUSH
45031: EMPTY
45032: LIST
45033: LIST
45034: PUSH
45035: LD_INT 30
45037: PUSH
45038: LD_INT 5
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: PUSH
45045: EMPTY
45046: LIST
45047: LIST
45048: LIST
45049: PPUSH
45050: CALL_OW 72
45054: ADD
45055: ST_TO_ADDR
45056: GO 45304
45058: LD_INT 2
45060: DOUBLE
45061: EQUAL
45062: IFTRUE 45072
45064: LD_INT 16
45066: DOUBLE
45067: EQUAL
45068: IFTRUE 45072
45070: GO 45118
45072: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45073: LD_ADDR_VAR 0 8
45077: PUSH
45078: LD_VAR 0 2
45082: PPUSH
45083: LD_INT 2
45085: PUSH
45086: LD_INT 30
45088: PUSH
45089: LD_INT 0
45091: PUSH
45092: EMPTY
45093: LIST
45094: LIST
45095: PUSH
45096: LD_INT 30
45098: PUSH
45099: LD_INT 1
45101: PUSH
45102: EMPTY
45103: LIST
45104: LIST
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: LIST
45110: PPUSH
45111: CALL_OW 72
45115: ST_TO_ADDR
45116: GO 45304
45118: LD_INT 3
45120: DOUBLE
45121: EQUAL
45122: IFTRUE 45126
45124: GO 45172
45126: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
45127: LD_ADDR_VAR 0 8
45131: PUSH
45132: LD_VAR 0 2
45136: PPUSH
45137: LD_INT 2
45139: PUSH
45140: LD_INT 30
45142: PUSH
45143: LD_INT 2
45145: PUSH
45146: EMPTY
45147: LIST
45148: LIST
45149: PUSH
45150: LD_INT 30
45152: PUSH
45153: LD_INT 3
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: LIST
45164: PPUSH
45165: CALL_OW 72
45169: ST_TO_ADDR
45170: GO 45304
45172: LD_INT 4
45174: DOUBLE
45175: EQUAL
45176: IFTRUE 45180
45178: GO 45237
45180: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
45181: LD_ADDR_VAR 0 8
45185: PUSH
45186: LD_VAR 0 2
45190: PPUSH
45191: LD_INT 2
45193: PUSH
45194: LD_INT 30
45196: PUSH
45197: LD_INT 6
45199: PUSH
45200: EMPTY
45201: LIST
45202: LIST
45203: PUSH
45204: LD_INT 30
45206: PUSH
45207: LD_INT 7
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 30
45216: PUSH
45217: LD_INT 8
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: PPUSH
45230: CALL_OW 72
45234: ST_TO_ADDR
45235: GO 45304
45237: LD_INT 5
45239: DOUBLE
45240: EQUAL
45241: IFTRUE 45257
45243: LD_INT 8
45245: DOUBLE
45246: EQUAL
45247: IFTRUE 45257
45249: LD_INT 9
45251: DOUBLE
45252: EQUAL
45253: IFTRUE 45257
45255: GO 45303
45257: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
45258: LD_ADDR_VAR 0 8
45262: PUSH
45263: LD_VAR 0 2
45267: PPUSH
45268: LD_INT 2
45270: PUSH
45271: LD_INT 30
45273: PUSH
45274: LD_INT 4
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 30
45283: PUSH
45284: LD_INT 5
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: EMPTY
45292: LIST
45293: LIST
45294: LIST
45295: PPUSH
45296: CALL_OW 72
45300: ST_TO_ADDR
45301: GO 45304
45303: POP
// if not tmp then
45304: LD_VAR 0 8
45308: NOT
45309: IFFALSE 45313
// exit ;
45311: GO 45773
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
45313: LD_VAR 0 4
45317: PUSH
45318: LD_INT 1
45320: PUSH
45321: LD_INT 15
45323: PUSH
45324: EMPTY
45325: LIST
45326: LIST
45327: IN
45328: PUSH
45329: LD_EXP 87
45333: PUSH
45334: LD_VAR 0 1
45338: ARRAY
45339: AND
45340: IFFALSE 45496
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
45342: LD_ADDR_VAR 0 9
45346: PUSH
45347: LD_EXP 87
45351: PUSH
45352: LD_VAR 0 1
45356: ARRAY
45357: PUSH
45358: LD_INT 1
45360: ARRAY
45361: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
45362: LD_VAR 0 9
45366: PUSH
45367: LD_EXP 88
45371: PUSH
45372: LD_VAR 0 1
45376: ARRAY
45377: IN
45378: NOT
45379: IFFALSE 45494
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
45381: LD_ADDR_EXP 88
45385: PUSH
45386: LD_EXP 88
45390: PPUSH
45391: LD_VAR 0 1
45395: PUSH
45396: LD_EXP 88
45400: PUSH
45401: LD_VAR 0 1
45405: ARRAY
45406: PUSH
45407: LD_INT 1
45409: PLUS
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: PPUSH
45415: LD_VAR 0 9
45419: PPUSH
45420: CALL 57810 0 3
45424: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
45425: LD_ADDR_EXP 87
45429: PUSH
45430: LD_EXP 87
45434: PPUSH
45435: LD_VAR 0 1
45439: PPUSH
45440: LD_EXP 87
45444: PUSH
45445: LD_VAR 0 1
45449: ARRAY
45450: PUSH
45451: LD_VAR 0 9
45455: DIFF
45456: PPUSH
45457: CALL_OW 1
45461: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
45462: LD_VAR 0 3
45466: PPUSH
45467: LD_EXP 88
45471: PUSH
45472: LD_VAR 0 1
45476: ARRAY
45477: PUSH
45478: LD_EXP 88
45482: PUSH
45483: LD_VAR 0 1
45487: ARRAY
45488: ARRAY
45489: PPUSH
45490: CALL_OW 120
// end ; exit ;
45494: GO 45773
// end ; if tmp > 1 then
45496: LD_VAR 0 8
45500: PUSH
45501: LD_INT 1
45503: GREATER
45504: IFFALSE 45608
// for i = 2 to tmp do
45506: LD_ADDR_VAR 0 6
45510: PUSH
45511: DOUBLE
45512: LD_INT 2
45514: DEC
45515: ST_TO_ADDR
45516: LD_VAR 0 8
45520: PUSH
45521: FOR_TO
45522: IFFALSE 45606
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
45524: LD_VAR 0 8
45528: PUSH
45529: LD_VAR 0 6
45533: ARRAY
45534: PPUSH
45535: CALL_OW 461
45539: PUSH
45540: LD_INT 6
45542: EQUAL
45543: IFFALSE 45604
// begin x := tmp [ i ] ;
45545: LD_ADDR_VAR 0 9
45549: PUSH
45550: LD_VAR 0 8
45554: PUSH
45555: LD_VAR 0 6
45559: ARRAY
45560: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
45561: LD_ADDR_VAR 0 8
45565: PUSH
45566: LD_VAR 0 8
45570: PPUSH
45571: LD_VAR 0 6
45575: PPUSH
45576: CALL_OW 3
45580: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
45581: LD_ADDR_VAR 0 8
45585: PUSH
45586: LD_VAR 0 8
45590: PPUSH
45591: LD_INT 1
45593: PPUSH
45594: LD_VAR 0 9
45598: PPUSH
45599: CALL_OW 2
45603: ST_TO_ADDR
// end ;
45604: GO 45521
45606: POP
45607: POP
// for i in tmp do
45608: LD_ADDR_VAR 0 6
45612: PUSH
45613: LD_VAR 0 8
45617: PUSH
45618: FOR_IN
45619: IFFALSE 45646
// begin if IsNotFull ( i ) then
45621: LD_VAR 0 6
45625: PPUSH
45626: CALL 55032 0 1
45630: IFFALSE 45644
// begin j := i ;
45632: LD_ADDR_VAR 0 7
45636: PUSH
45637: LD_VAR 0 6
45641: ST_TO_ADDR
// break ;
45642: GO 45646
// end ; end ;
45644: GO 45618
45646: POP
45647: POP
// if j then
45648: LD_VAR 0 7
45652: IFFALSE 45670
// ComEnterUnit ( unit , j ) else
45654: LD_VAR 0 3
45658: PPUSH
45659: LD_VAR 0 7
45663: PPUSH
45664: CALL_OW 120
45668: GO 45773
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45670: LD_ADDR_VAR 0 10
45674: PUSH
45675: LD_VAR 0 2
45679: PPUSH
45680: LD_INT 2
45682: PUSH
45683: LD_INT 30
45685: PUSH
45686: LD_INT 0
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 30
45695: PUSH
45696: LD_INT 1
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: LIST
45707: PPUSH
45708: CALL_OW 72
45712: ST_TO_ADDR
// if depot then
45713: LD_VAR 0 10
45717: IFFALSE 45773
// begin depot := NearestUnitToUnit ( depot , unit ) ;
45719: LD_ADDR_VAR 0 10
45723: PUSH
45724: LD_VAR 0 10
45728: PPUSH
45729: LD_VAR 0 3
45733: PPUSH
45734: CALL_OW 74
45738: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
45739: LD_VAR 0 3
45743: PPUSH
45744: LD_VAR 0 10
45748: PPUSH
45749: CALL_OW 296
45753: PUSH
45754: LD_INT 10
45756: GREATER
45757: IFFALSE 45773
// ComStandNearbyBuilding ( unit , depot ) ;
45759: LD_VAR 0 3
45763: PPUSH
45764: LD_VAR 0 10
45768: PPUSH
45769: CALL 54412 0 2
// end ; end ; end ;
45773: LD_VAR 0 5
45777: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
45778: LD_INT 0
45780: PPUSH
45781: PPUSH
45782: PPUSH
45783: PPUSH
// if not mc_bases then
45784: LD_EXP 78
45788: NOT
45789: IFFALSE 45793
// exit ;
45791: GO 46032
// for i = 1 to mc_bases do
45793: LD_ADDR_VAR 0 2
45797: PUSH
45798: DOUBLE
45799: LD_INT 1
45801: DEC
45802: ST_TO_ADDR
45803: LD_EXP 78
45807: PUSH
45808: FOR_TO
45809: IFFALSE 46030
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45811: LD_ADDR_VAR 0 4
45815: PUSH
45816: LD_EXP 78
45820: PUSH
45821: LD_VAR 0 2
45825: ARRAY
45826: PPUSH
45827: LD_INT 21
45829: PUSH
45830: LD_INT 1
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: PPUSH
45837: CALL_OW 72
45841: PUSH
45842: LD_EXP 107
45846: PUSH
45847: LD_VAR 0 2
45851: ARRAY
45852: UNION
45853: ST_TO_ADDR
// if not tmp then
45854: LD_VAR 0 4
45858: NOT
45859: IFFALSE 45863
// continue ;
45861: GO 45808
// for j in tmp do
45863: LD_ADDR_VAR 0 3
45867: PUSH
45868: LD_VAR 0 4
45872: PUSH
45873: FOR_IN
45874: IFFALSE 46026
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45876: LD_VAR 0 3
45880: PPUSH
45881: CALL_OW 110
45885: NOT
45886: PUSH
45887: LD_VAR 0 3
45891: PPUSH
45892: CALL_OW 314
45896: NOT
45897: AND
45898: PUSH
45899: LD_VAR 0 3
45903: PPUSH
45904: CALL_OW 311
45908: NOT
45909: AND
45910: PUSH
45911: LD_VAR 0 3
45915: PPUSH
45916: CALL_OW 310
45920: NOT
45921: AND
45922: PUSH
45923: LD_VAR 0 3
45927: PUSH
45928: LD_EXP 81
45932: PUSH
45933: LD_VAR 0 2
45937: ARRAY
45938: PUSH
45939: LD_INT 1
45941: ARRAY
45942: IN
45943: NOT
45944: AND
45945: PUSH
45946: LD_VAR 0 3
45950: PUSH
45951: LD_EXP 81
45955: PUSH
45956: LD_VAR 0 2
45960: ARRAY
45961: PUSH
45962: LD_INT 2
45964: ARRAY
45965: IN
45966: NOT
45967: AND
45968: PUSH
45969: LD_VAR 0 3
45973: PUSH
45974: LD_EXP 90
45978: PUSH
45979: LD_VAR 0 2
45983: ARRAY
45984: IN
45985: NOT
45986: AND
45987: IFFALSE 46024
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45989: LD_VAR 0 2
45993: PPUSH
45994: LD_EXP 78
45998: PUSH
45999: LD_VAR 0 2
46003: ARRAY
46004: PPUSH
46005: LD_VAR 0 3
46009: PPUSH
46010: LD_VAR 0 3
46014: PPUSH
46015: CALL_OW 257
46019: PPUSH
46020: CALL 44838 0 4
// end ;
46024: GO 45873
46026: POP
46027: POP
// end ;
46028: GO 45808
46030: POP
46031: POP
// end ;
46032: LD_VAR 0 1
46036: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46037: LD_INT 0
46039: PPUSH
46040: PPUSH
46041: PPUSH
46042: PPUSH
46043: PPUSH
46044: PPUSH
// if not mc_bases [ base ] then
46045: LD_EXP 78
46049: PUSH
46050: LD_VAR 0 1
46054: ARRAY
46055: NOT
46056: IFFALSE 46060
// exit ;
46058: GO 46261
// tmp := [ ] ;
46060: LD_ADDR_VAR 0 6
46064: PUSH
46065: EMPTY
46066: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46067: LD_ADDR_VAR 0 7
46071: PUSH
46072: LD_VAR 0 3
46076: PPUSH
46077: LD_INT 0
46079: PPUSH
46080: CALL_OW 517
46084: ST_TO_ADDR
// if not list then
46085: LD_VAR 0 7
46089: NOT
46090: IFFALSE 46094
// exit ;
46092: GO 46261
// c := Count ( list [ 1 ] ) ;
46094: LD_ADDR_VAR 0 9
46098: PUSH
46099: LD_VAR 0 7
46103: PUSH
46104: LD_INT 1
46106: ARRAY
46107: PPUSH
46108: CALL 54950 0 1
46112: ST_TO_ADDR
// if amount > c then
46113: LD_VAR 0 2
46117: PUSH
46118: LD_VAR 0 9
46122: GREATER
46123: IFFALSE 46135
// amount := c ;
46125: LD_ADDR_VAR 0 2
46129: PUSH
46130: LD_VAR 0 9
46134: ST_TO_ADDR
// for i := 1 to amount do
46135: LD_ADDR_VAR 0 5
46139: PUSH
46140: DOUBLE
46141: LD_INT 1
46143: DEC
46144: ST_TO_ADDR
46145: LD_VAR 0 2
46149: PUSH
46150: FOR_TO
46151: IFFALSE 46209
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
46153: LD_ADDR_VAR 0 6
46157: PUSH
46158: LD_VAR 0 6
46162: PPUSH
46163: LD_VAR 0 5
46167: PPUSH
46168: LD_VAR 0 7
46172: PUSH
46173: LD_INT 1
46175: ARRAY
46176: PUSH
46177: LD_VAR 0 5
46181: ARRAY
46182: PUSH
46183: LD_VAR 0 7
46187: PUSH
46188: LD_INT 2
46190: ARRAY
46191: PUSH
46192: LD_VAR 0 5
46196: ARRAY
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PPUSH
46202: CALL_OW 1
46206: ST_TO_ADDR
46207: GO 46150
46209: POP
46210: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
46211: LD_ADDR_EXP 91
46215: PUSH
46216: LD_EXP 91
46220: PPUSH
46221: LD_VAR 0 1
46225: PPUSH
46226: LD_VAR 0 6
46230: PPUSH
46231: CALL_OW 1
46235: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
46236: LD_ADDR_EXP 93
46240: PUSH
46241: LD_EXP 93
46245: PPUSH
46246: LD_VAR 0 1
46250: PPUSH
46251: LD_VAR 0 3
46255: PPUSH
46256: CALL_OW 1
46260: ST_TO_ADDR
// end ;
46261: LD_VAR 0 4
46265: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
46266: LD_INT 0
46268: PPUSH
// if not mc_bases [ base ] then
46269: LD_EXP 78
46273: PUSH
46274: LD_VAR 0 1
46278: ARRAY
46279: NOT
46280: IFFALSE 46284
// exit ;
46282: GO 46309
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
46284: LD_ADDR_EXP 83
46288: PUSH
46289: LD_EXP 83
46293: PPUSH
46294: LD_VAR 0 1
46298: PPUSH
46299: LD_VAR 0 2
46303: PPUSH
46304: CALL_OW 1
46308: ST_TO_ADDR
// end ;
46309: LD_VAR 0 3
46313: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
46314: LD_INT 0
46316: PPUSH
// if not mc_bases [ base ] then
46317: LD_EXP 78
46321: PUSH
46322: LD_VAR 0 1
46326: ARRAY
46327: NOT
46328: IFFALSE 46332
// exit ;
46330: GO 46369
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
46332: LD_ADDR_EXP 83
46336: PUSH
46337: LD_EXP 83
46341: PPUSH
46342: LD_VAR 0 1
46346: PPUSH
46347: LD_EXP 83
46351: PUSH
46352: LD_VAR 0 1
46356: ARRAY
46357: PUSH
46358: LD_VAR 0 2
46362: UNION
46363: PPUSH
46364: CALL_OW 1
46368: ST_TO_ADDR
// end ;
46369: LD_VAR 0 3
46373: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
46374: LD_INT 0
46376: PPUSH
// if not mc_bases [ base ] then
46377: LD_EXP 78
46381: PUSH
46382: LD_VAR 0 1
46386: ARRAY
46387: NOT
46388: IFFALSE 46392
// exit ;
46390: GO 46417
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
46392: LD_ADDR_EXP 99
46396: PUSH
46397: LD_EXP 99
46401: PPUSH
46402: LD_VAR 0 1
46406: PPUSH
46407: LD_VAR 0 2
46411: PPUSH
46412: CALL_OW 1
46416: ST_TO_ADDR
// end ;
46417: LD_VAR 0 3
46421: RET
// export function MC_InsertProduceList ( base , components ) ; begin
46422: LD_INT 0
46424: PPUSH
// if not mc_bases [ base ] then
46425: LD_EXP 78
46429: PUSH
46430: LD_VAR 0 1
46434: ARRAY
46435: NOT
46436: IFFALSE 46440
// exit ;
46438: GO 46477
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
46440: LD_ADDR_EXP 99
46444: PUSH
46445: LD_EXP 99
46449: PPUSH
46450: LD_VAR 0 1
46454: PPUSH
46455: LD_EXP 99
46459: PUSH
46460: LD_VAR 0 1
46464: ARRAY
46465: PUSH
46466: LD_VAR 0 2
46470: ADD
46471: PPUSH
46472: CALL_OW 1
46476: ST_TO_ADDR
// end ;
46477: LD_VAR 0 3
46481: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
46482: LD_INT 0
46484: PPUSH
// if not mc_bases [ base ] then
46485: LD_EXP 78
46489: PUSH
46490: LD_VAR 0 1
46494: ARRAY
46495: NOT
46496: IFFALSE 46500
// exit ;
46498: GO 46554
// mc_defender := Replace ( mc_defender , base , deflist ) ;
46500: LD_ADDR_EXP 100
46504: PUSH
46505: LD_EXP 100
46509: PPUSH
46510: LD_VAR 0 1
46514: PPUSH
46515: LD_VAR 0 2
46519: PPUSH
46520: CALL_OW 1
46524: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
46525: LD_ADDR_EXP 89
46529: PUSH
46530: LD_EXP 89
46534: PPUSH
46535: LD_VAR 0 1
46539: PPUSH
46540: LD_VAR 0 2
46544: PUSH
46545: LD_INT 0
46547: PLUS
46548: PPUSH
46549: CALL_OW 1
46553: ST_TO_ADDR
// end ;
46554: LD_VAR 0 3
46558: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
46559: LD_INT 0
46561: PPUSH
// if not mc_bases [ base ] then
46562: LD_EXP 78
46566: PUSH
46567: LD_VAR 0 1
46571: ARRAY
46572: NOT
46573: IFFALSE 46577
// exit ;
46575: GO 46602
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
46577: LD_ADDR_EXP 89
46581: PUSH
46582: LD_EXP 89
46586: PPUSH
46587: LD_VAR 0 1
46591: PPUSH
46592: LD_VAR 0 2
46596: PPUSH
46597: CALL_OW 1
46601: ST_TO_ADDR
// end ;
46602: LD_VAR 0 3
46606: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
46607: LD_INT 0
46609: PPUSH
46610: PPUSH
46611: PPUSH
46612: PPUSH
// if not mc_bases [ base ] then
46613: LD_EXP 78
46617: PUSH
46618: LD_VAR 0 1
46622: ARRAY
46623: NOT
46624: IFFALSE 46628
// exit ;
46626: GO 46693
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
46628: LD_ADDR_EXP 98
46632: PUSH
46633: LD_EXP 98
46637: PPUSH
46638: LD_VAR 0 1
46642: PUSH
46643: LD_EXP 98
46647: PUSH
46648: LD_VAR 0 1
46652: ARRAY
46653: PUSH
46654: LD_INT 1
46656: PLUS
46657: PUSH
46658: EMPTY
46659: LIST
46660: LIST
46661: PPUSH
46662: LD_VAR 0 1
46666: PUSH
46667: LD_VAR 0 2
46671: PUSH
46672: LD_VAR 0 3
46676: PUSH
46677: LD_VAR 0 4
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: PPUSH
46688: CALL 57810 0 3
46692: ST_TO_ADDR
// end ;
46693: LD_VAR 0 5
46697: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
46698: LD_INT 0
46700: PPUSH
// if not mc_bases [ base ] then
46701: LD_EXP 78
46705: PUSH
46706: LD_VAR 0 1
46710: ARRAY
46711: NOT
46712: IFFALSE 46716
// exit ;
46714: GO 46741
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
46716: LD_ADDR_EXP 115
46720: PUSH
46721: LD_EXP 115
46725: PPUSH
46726: LD_VAR 0 1
46730: PPUSH
46731: LD_VAR 0 2
46735: PPUSH
46736: CALL_OW 1
46740: ST_TO_ADDR
// end ;
46741: LD_VAR 0 3
46745: RET
// export function MC_GetMinesField ( base ) ; begin
46746: LD_INT 0
46748: PPUSH
// result := mc_mines [ base ] ;
46749: LD_ADDR_VAR 0 2
46753: PUSH
46754: LD_EXP 91
46758: PUSH
46759: LD_VAR 0 1
46763: ARRAY
46764: ST_TO_ADDR
// end ;
46765: LD_VAR 0 2
46769: RET
// export function MC_GetProduceList ( base ) ; begin
46770: LD_INT 0
46772: PPUSH
// result := mc_produce [ base ] ;
46773: LD_ADDR_VAR 0 2
46777: PUSH
46778: LD_EXP 99
46782: PUSH
46783: LD_VAR 0 1
46787: ARRAY
46788: ST_TO_ADDR
// end ;
46789: LD_VAR 0 2
46793: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
46794: LD_INT 0
46796: PPUSH
46797: PPUSH
// if not mc_bases then
46798: LD_EXP 78
46802: NOT
46803: IFFALSE 46807
// exit ;
46805: GO 46872
// if mc_bases [ base ] then
46807: LD_EXP 78
46811: PUSH
46812: LD_VAR 0 1
46816: ARRAY
46817: IFFALSE 46872
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46819: LD_ADDR_VAR 0 3
46823: PUSH
46824: LD_EXP 78
46828: PUSH
46829: LD_VAR 0 1
46833: ARRAY
46834: PPUSH
46835: LD_INT 30
46837: PUSH
46838: LD_VAR 0 2
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PPUSH
46847: CALL_OW 72
46851: ST_TO_ADDR
// if result then
46852: LD_VAR 0 3
46856: IFFALSE 46872
// result := result [ 1 ] ;
46858: LD_ADDR_VAR 0 3
46862: PUSH
46863: LD_VAR 0 3
46867: PUSH
46868: LD_INT 1
46870: ARRAY
46871: ST_TO_ADDR
// end ; end ;
46872: LD_VAR 0 3
46876: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46877: LD_INT 0
46879: PPUSH
46880: PPUSH
// if not mc_bases then
46881: LD_EXP 78
46885: NOT
46886: IFFALSE 46890
// exit ;
46888: GO 46935
// if mc_bases [ base ] then
46890: LD_EXP 78
46894: PUSH
46895: LD_VAR 0 1
46899: ARRAY
46900: IFFALSE 46935
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46902: LD_ADDR_VAR 0 3
46906: PUSH
46907: LD_EXP 78
46911: PUSH
46912: LD_VAR 0 1
46916: ARRAY
46917: PPUSH
46918: LD_INT 30
46920: PUSH
46921: LD_VAR 0 2
46925: PUSH
46926: EMPTY
46927: LIST
46928: LIST
46929: PPUSH
46930: CALL_OW 72
46934: ST_TO_ADDR
// end ;
46935: LD_VAR 0 3
46939: RET
// export function MC_SetTame ( base , area ) ; begin
46940: LD_INT 0
46942: PPUSH
// if not mc_bases or not base then
46943: LD_EXP 78
46947: NOT
46948: PUSH
46949: LD_VAR 0 1
46953: NOT
46954: OR
46955: IFFALSE 46959
// exit ;
46957: GO 46984
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46959: LD_ADDR_EXP 106
46963: PUSH
46964: LD_EXP 106
46968: PPUSH
46969: LD_VAR 0 1
46973: PPUSH
46974: LD_VAR 0 2
46978: PPUSH
46979: CALL_OW 1
46983: ST_TO_ADDR
// end ;
46984: LD_VAR 0 3
46988: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46989: LD_INT 0
46991: PPUSH
46992: PPUSH
// if not mc_bases or not base then
46993: LD_EXP 78
46997: NOT
46998: PUSH
46999: LD_VAR 0 1
47003: NOT
47004: OR
47005: IFFALSE 47009
// exit ;
47007: GO 47111
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47009: LD_ADDR_VAR 0 4
47013: PUSH
47014: LD_EXP 78
47018: PUSH
47019: LD_VAR 0 1
47023: ARRAY
47024: PPUSH
47025: LD_INT 30
47027: PUSH
47028: LD_VAR 0 2
47032: PUSH
47033: EMPTY
47034: LIST
47035: LIST
47036: PPUSH
47037: CALL_OW 72
47041: ST_TO_ADDR
// if not tmp then
47042: LD_VAR 0 4
47046: NOT
47047: IFFALSE 47051
// exit ;
47049: GO 47111
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47051: LD_ADDR_EXP 110
47055: PUSH
47056: LD_EXP 110
47060: PPUSH
47061: LD_VAR 0 1
47065: PPUSH
47066: LD_EXP 110
47070: PUSH
47071: LD_VAR 0 1
47075: ARRAY
47076: PPUSH
47077: LD_EXP 110
47081: PUSH
47082: LD_VAR 0 1
47086: ARRAY
47087: PUSH
47088: LD_INT 1
47090: PLUS
47091: PPUSH
47092: LD_VAR 0 4
47096: PUSH
47097: LD_INT 1
47099: ARRAY
47100: PPUSH
47101: CALL_OW 2
47105: PPUSH
47106: CALL_OW 1
47110: ST_TO_ADDR
// end ;
47111: LD_VAR 0 3
47115: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47116: LD_INT 0
47118: PPUSH
47119: PPUSH
// if not mc_bases or not base or not kinds then
47120: LD_EXP 78
47124: NOT
47125: PUSH
47126: LD_VAR 0 1
47130: NOT
47131: OR
47132: PUSH
47133: LD_VAR 0 2
47137: NOT
47138: OR
47139: IFFALSE 47143
// exit ;
47141: GO 47204
// for i in kinds do
47143: LD_ADDR_VAR 0 4
47147: PUSH
47148: LD_VAR 0 2
47152: PUSH
47153: FOR_IN
47154: IFFALSE 47202
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
47156: LD_ADDR_EXP 112
47160: PUSH
47161: LD_EXP 112
47165: PPUSH
47166: LD_VAR 0 1
47170: PUSH
47171: LD_EXP 112
47175: PUSH
47176: LD_VAR 0 1
47180: ARRAY
47181: PUSH
47182: LD_INT 1
47184: PLUS
47185: PUSH
47186: EMPTY
47187: LIST
47188: LIST
47189: PPUSH
47190: LD_VAR 0 4
47194: PPUSH
47195: CALL 57810 0 3
47199: ST_TO_ADDR
47200: GO 47153
47202: POP
47203: POP
// end ;
47204: LD_VAR 0 3
47208: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
47209: LD_INT 0
47211: PPUSH
// if not mc_bases or not base or not areas then
47212: LD_EXP 78
47216: NOT
47217: PUSH
47218: LD_VAR 0 1
47222: NOT
47223: OR
47224: PUSH
47225: LD_VAR 0 2
47229: NOT
47230: OR
47231: IFFALSE 47235
// exit ;
47233: GO 47260
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
47235: LD_ADDR_EXP 96
47239: PUSH
47240: LD_EXP 96
47244: PPUSH
47245: LD_VAR 0 1
47249: PPUSH
47250: LD_VAR 0 2
47254: PPUSH
47255: CALL_OW 1
47259: ST_TO_ADDR
// end ;
47260: LD_VAR 0 3
47264: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
47265: LD_INT 0
47267: PPUSH
// if not mc_bases or not base or not teleports_exit then
47268: LD_EXP 78
47272: NOT
47273: PUSH
47274: LD_VAR 0 1
47278: NOT
47279: OR
47280: PUSH
47281: LD_VAR 0 2
47285: NOT
47286: OR
47287: IFFALSE 47291
// exit ;
47289: GO 47316
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
47291: LD_ADDR_EXP 113
47295: PUSH
47296: LD_EXP 113
47300: PPUSH
47301: LD_VAR 0 1
47305: PPUSH
47306: LD_VAR 0 2
47310: PPUSH
47311: CALL_OW 1
47315: ST_TO_ADDR
// end ;
47316: LD_VAR 0 3
47320: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
47321: LD_INT 0
47323: PPUSH
47324: PPUSH
47325: PPUSH
// if not mc_bases or not base or not ext_list then
47326: LD_EXP 78
47330: NOT
47331: PUSH
47332: LD_VAR 0 1
47336: NOT
47337: OR
47338: PUSH
47339: LD_VAR 0 5
47343: NOT
47344: OR
47345: IFFALSE 47349
// exit ;
47347: GO 47522
// tmp := GetFacExtXYD ( x , y , d ) ;
47349: LD_ADDR_VAR 0 8
47353: PUSH
47354: LD_VAR 0 2
47358: PPUSH
47359: LD_VAR 0 3
47363: PPUSH
47364: LD_VAR 0 4
47368: PPUSH
47369: CALL 87787 0 3
47373: ST_TO_ADDR
// if not tmp then
47374: LD_VAR 0 8
47378: NOT
47379: IFFALSE 47383
// exit ;
47381: GO 47522
// for i in tmp do
47383: LD_ADDR_VAR 0 7
47387: PUSH
47388: LD_VAR 0 8
47392: PUSH
47393: FOR_IN
47394: IFFALSE 47520
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
47396: LD_ADDR_EXP 83
47400: PUSH
47401: LD_EXP 83
47405: PPUSH
47406: LD_VAR 0 1
47410: PPUSH
47411: LD_EXP 83
47415: PUSH
47416: LD_VAR 0 1
47420: ARRAY
47421: PPUSH
47422: LD_EXP 83
47426: PUSH
47427: LD_VAR 0 1
47431: ARRAY
47432: PUSH
47433: LD_INT 1
47435: PLUS
47436: PPUSH
47437: LD_VAR 0 5
47441: PUSH
47442: LD_INT 1
47444: ARRAY
47445: PUSH
47446: LD_VAR 0 7
47450: PUSH
47451: LD_INT 1
47453: ARRAY
47454: PUSH
47455: LD_VAR 0 7
47459: PUSH
47460: LD_INT 2
47462: ARRAY
47463: PUSH
47464: LD_VAR 0 7
47468: PUSH
47469: LD_INT 3
47471: ARRAY
47472: PUSH
47473: EMPTY
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: PPUSH
47479: CALL_OW 2
47483: PPUSH
47484: CALL_OW 1
47488: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
47489: LD_ADDR_VAR 0 5
47493: PUSH
47494: LD_VAR 0 5
47498: PPUSH
47499: LD_INT 1
47501: PPUSH
47502: CALL_OW 3
47506: ST_TO_ADDR
// if not ext_list then
47507: LD_VAR 0 5
47511: NOT
47512: IFFALSE 47518
// exit ;
47514: POP
47515: POP
47516: GO 47522
// end ;
47518: GO 47393
47520: POP
47521: POP
// end ;
47522: LD_VAR 0 6
47526: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
47527: LD_INT 0
47529: PPUSH
// if not mc_bases or not base or not weapon_list then
47530: LD_EXP 78
47534: NOT
47535: PUSH
47536: LD_VAR 0 1
47540: NOT
47541: OR
47542: PUSH
47543: LD_VAR 0 2
47547: NOT
47548: OR
47549: IFFALSE 47553
// exit ;
47551: GO 47578
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
47553: LD_ADDR_EXP 117
47557: PUSH
47558: LD_EXP 117
47562: PPUSH
47563: LD_VAR 0 1
47567: PPUSH
47568: LD_VAR 0 2
47572: PPUSH
47573: CALL_OW 1
47577: ST_TO_ADDR
// end ;
47578: LD_VAR 0 3
47582: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
47583: LD_INT 0
47585: PPUSH
// if not mc_bases or not base or not tech_list then
47586: LD_EXP 78
47590: NOT
47591: PUSH
47592: LD_VAR 0 1
47596: NOT
47597: OR
47598: PUSH
47599: LD_VAR 0 2
47603: NOT
47604: OR
47605: IFFALSE 47609
// exit ;
47607: GO 47634
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
47609: LD_ADDR_EXP 105
47613: PUSH
47614: LD_EXP 105
47618: PPUSH
47619: LD_VAR 0 1
47623: PPUSH
47624: LD_VAR 0 2
47628: PPUSH
47629: CALL_OW 1
47633: ST_TO_ADDR
// end ;
47634: LD_VAR 0 3
47638: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
47639: LD_INT 0
47641: PPUSH
// if not mc_bases or not parking_area or not base then
47642: LD_EXP 78
47646: NOT
47647: PUSH
47648: LD_VAR 0 2
47652: NOT
47653: OR
47654: PUSH
47655: LD_VAR 0 1
47659: NOT
47660: OR
47661: IFFALSE 47665
// exit ;
47663: GO 47690
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
47665: LD_ADDR_EXP 102
47669: PUSH
47670: LD_EXP 102
47674: PPUSH
47675: LD_VAR 0 1
47679: PPUSH
47680: LD_VAR 0 2
47684: PPUSH
47685: CALL_OW 1
47689: ST_TO_ADDR
// end ;
47690: LD_VAR 0 3
47694: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
47695: LD_INT 0
47697: PPUSH
// if not mc_bases or not base or not scan_area then
47698: LD_EXP 78
47702: NOT
47703: PUSH
47704: LD_VAR 0 1
47708: NOT
47709: OR
47710: PUSH
47711: LD_VAR 0 2
47715: NOT
47716: OR
47717: IFFALSE 47721
// exit ;
47719: GO 47746
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
47721: LD_ADDR_EXP 103
47725: PUSH
47726: LD_EXP 103
47730: PPUSH
47731: LD_VAR 0 1
47735: PPUSH
47736: LD_VAR 0 2
47740: PPUSH
47741: CALL_OW 1
47745: ST_TO_ADDR
// end ;
47746: LD_VAR 0 3
47750: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
47751: LD_INT 0
47753: PPUSH
47754: PPUSH
// if not mc_bases or not base then
47755: LD_EXP 78
47759: NOT
47760: PUSH
47761: LD_VAR 0 1
47765: NOT
47766: OR
47767: IFFALSE 47771
// exit ;
47769: GO 47835
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
47771: LD_ADDR_VAR 0 3
47775: PUSH
47776: LD_INT 1
47778: PUSH
47779: LD_INT 2
47781: PUSH
47782: LD_INT 3
47784: PUSH
47785: LD_INT 4
47787: PUSH
47788: LD_INT 11
47790: PUSH
47791: EMPTY
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: LIST
47797: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
47798: LD_ADDR_EXP 105
47802: PUSH
47803: LD_EXP 105
47807: PPUSH
47808: LD_VAR 0 1
47812: PPUSH
47813: LD_EXP 105
47817: PUSH
47818: LD_VAR 0 1
47822: ARRAY
47823: PUSH
47824: LD_VAR 0 3
47828: DIFF
47829: PPUSH
47830: CALL_OW 1
47834: ST_TO_ADDR
// end ;
47835: LD_VAR 0 2
47839: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47840: LD_INT 0
47842: PPUSH
// result := mc_vehicles [ base ] ;
47843: LD_ADDR_VAR 0 3
47847: PUSH
47848: LD_EXP 97
47852: PUSH
47853: LD_VAR 0 1
47857: ARRAY
47858: ST_TO_ADDR
// if onlyCombat then
47859: LD_VAR 0 2
47863: IFFALSE 48035
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47865: LD_ADDR_VAR 0 3
47869: PUSH
47870: LD_VAR 0 3
47874: PUSH
47875: LD_VAR 0 3
47879: PPUSH
47880: LD_INT 2
47882: PUSH
47883: LD_INT 34
47885: PUSH
47886: LD_INT 12
47888: PUSH
47889: EMPTY
47890: LIST
47891: LIST
47892: PUSH
47893: LD_INT 34
47895: PUSH
47896: LD_INT 51
47898: PUSH
47899: EMPTY
47900: LIST
47901: LIST
47902: PUSH
47903: LD_INT 34
47905: PUSH
47906: LD_INT 89
47908: PUSH
47909: EMPTY
47910: LIST
47911: LIST
47912: PUSH
47913: LD_INT 34
47915: PUSH
47916: LD_INT 32
47918: PUSH
47919: EMPTY
47920: LIST
47921: LIST
47922: PUSH
47923: LD_INT 34
47925: PUSH
47926: LD_INT 13
47928: PUSH
47929: EMPTY
47930: LIST
47931: LIST
47932: PUSH
47933: LD_INT 34
47935: PUSH
47936: LD_INT 52
47938: PUSH
47939: EMPTY
47940: LIST
47941: LIST
47942: PUSH
47943: LD_INT 34
47945: PUSH
47946: LD_INT 88
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PUSH
47953: LD_INT 34
47955: PUSH
47956: LD_INT 14
47958: PUSH
47959: EMPTY
47960: LIST
47961: LIST
47962: PUSH
47963: LD_INT 34
47965: PUSH
47966: LD_INT 53
47968: PUSH
47969: EMPTY
47970: LIST
47971: LIST
47972: PUSH
47973: LD_INT 34
47975: PUSH
47976: LD_INT 98
47978: PUSH
47979: EMPTY
47980: LIST
47981: LIST
47982: PUSH
47983: LD_INT 34
47985: PUSH
47986: LD_INT 31
47988: PUSH
47989: EMPTY
47990: LIST
47991: LIST
47992: PUSH
47993: LD_INT 34
47995: PUSH
47996: LD_INT 48
47998: PUSH
47999: EMPTY
48000: LIST
48001: LIST
48002: PUSH
48003: LD_INT 34
48005: PUSH
48006: LD_INT 8
48008: PUSH
48009: EMPTY
48010: LIST
48011: LIST
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: LIST
48017: LIST
48018: LIST
48019: LIST
48020: LIST
48021: LIST
48022: LIST
48023: LIST
48024: LIST
48025: LIST
48026: LIST
48027: LIST
48028: PPUSH
48029: CALL_OW 72
48033: DIFF
48034: ST_TO_ADDR
// end ; end_of_file
48035: LD_VAR 0 3
48039: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48040: LD_INT 0
48042: PPUSH
48043: PPUSH
48044: PPUSH
// if not mc_bases or not skirmish then
48045: LD_EXP 78
48049: NOT
48050: PUSH
48051: LD_EXP 76
48055: NOT
48056: OR
48057: IFFALSE 48061
// exit ;
48059: GO 48226
// for i = 1 to mc_bases do
48061: LD_ADDR_VAR 0 4
48065: PUSH
48066: DOUBLE
48067: LD_INT 1
48069: DEC
48070: ST_TO_ADDR
48071: LD_EXP 78
48075: PUSH
48076: FOR_TO
48077: IFFALSE 48224
// begin if sci in mc_bases [ i ] then
48079: LD_VAR 0 2
48083: PUSH
48084: LD_EXP 78
48088: PUSH
48089: LD_VAR 0 4
48093: ARRAY
48094: IN
48095: IFFALSE 48222
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48097: LD_ADDR_EXP 107
48101: PUSH
48102: LD_EXP 107
48106: PPUSH
48107: LD_VAR 0 4
48111: PUSH
48112: LD_EXP 107
48116: PUSH
48117: LD_VAR 0 4
48121: ARRAY
48122: PUSH
48123: LD_INT 1
48125: PLUS
48126: PUSH
48127: EMPTY
48128: LIST
48129: LIST
48130: PPUSH
48131: LD_VAR 0 1
48135: PPUSH
48136: CALL 57810 0 3
48140: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
48141: LD_ADDR_VAR 0 5
48145: PUSH
48146: LD_EXP 78
48150: PUSH
48151: LD_VAR 0 4
48155: ARRAY
48156: PPUSH
48157: LD_INT 2
48159: PUSH
48160: LD_INT 30
48162: PUSH
48163: LD_INT 0
48165: PUSH
48166: EMPTY
48167: LIST
48168: LIST
48169: PUSH
48170: LD_INT 30
48172: PUSH
48173: LD_INT 1
48175: PUSH
48176: EMPTY
48177: LIST
48178: LIST
48179: PUSH
48180: EMPTY
48181: LIST
48182: LIST
48183: LIST
48184: PPUSH
48185: CALL_OW 72
48189: PPUSH
48190: LD_VAR 0 1
48194: PPUSH
48195: CALL_OW 74
48199: ST_TO_ADDR
// if tmp then
48200: LD_VAR 0 5
48204: IFFALSE 48220
// ComStandNearbyBuilding ( ape , tmp ) ;
48206: LD_VAR 0 1
48210: PPUSH
48211: LD_VAR 0 5
48215: PPUSH
48216: CALL 54412 0 2
// break ;
48220: GO 48224
// end ; end ;
48222: GO 48076
48224: POP
48225: POP
// end ;
48226: LD_VAR 0 3
48230: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
48231: LD_INT 0
48233: PPUSH
48234: PPUSH
48235: PPUSH
// if not mc_bases or not skirmish then
48236: LD_EXP 78
48240: NOT
48241: PUSH
48242: LD_EXP 76
48246: NOT
48247: OR
48248: IFFALSE 48252
// exit ;
48250: GO 48341
// for i = 1 to mc_bases do
48252: LD_ADDR_VAR 0 4
48256: PUSH
48257: DOUBLE
48258: LD_INT 1
48260: DEC
48261: ST_TO_ADDR
48262: LD_EXP 78
48266: PUSH
48267: FOR_TO
48268: IFFALSE 48339
// begin if building in mc_busy_turret_list [ i ] then
48270: LD_VAR 0 1
48274: PUSH
48275: LD_EXP 88
48279: PUSH
48280: LD_VAR 0 4
48284: ARRAY
48285: IN
48286: IFFALSE 48337
// begin tmp := mc_busy_turret_list [ i ] diff building ;
48288: LD_ADDR_VAR 0 5
48292: PUSH
48293: LD_EXP 88
48297: PUSH
48298: LD_VAR 0 4
48302: ARRAY
48303: PUSH
48304: LD_VAR 0 1
48308: DIFF
48309: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
48310: LD_ADDR_EXP 88
48314: PUSH
48315: LD_EXP 88
48319: PPUSH
48320: LD_VAR 0 4
48324: PPUSH
48325: LD_VAR 0 5
48329: PPUSH
48330: CALL_OW 1
48334: ST_TO_ADDR
// break ;
48335: GO 48339
// end ; end ;
48337: GO 48267
48339: POP
48340: POP
// end ;
48341: LD_VAR 0 3
48345: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
48346: LD_INT 0
48348: PPUSH
48349: PPUSH
48350: PPUSH
// if not mc_bases or not skirmish then
48351: LD_EXP 78
48355: NOT
48356: PUSH
48357: LD_EXP 76
48361: NOT
48362: OR
48363: IFFALSE 48367
// exit ;
48365: GO 48566
// for i = 1 to mc_bases do
48367: LD_ADDR_VAR 0 5
48371: PUSH
48372: DOUBLE
48373: LD_INT 1
48375: DEC
48376: ST_TO_ADDR
48377: LD_EXP 78
48381: PUSH
48382: FOR_TO
48383: IFFALSE 48564
// if building in mc_bases [ i ] then
48385: LD_VAR 0 1
48389: PUSH
48390: LD_EXP 78
48394: PUSH
48395: LD_VAR 0 5
48399: ARRAY
48400: IN
48401: IFFALSE 48562
// begin tmp := mc_bases [ i ] diff building ;
48403: LD_ADDR_VAR 0 6
48407: PUSH
48408: LD_EXP 78
48412: PUSH
48413: LD_VAR 0 5
48417: ARRAY
48418: PUSH
48419: LD_VAR 0 1
48423: DIFF
48424: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
48425: LD_ADDR_EXP 78
48429: PUSH
48430: LD_EXP 78
48434: PPUSH
48435: LD_VAR 0 5
48439: PPUSH
48440: LD_VAR 0 6
48444: PPUSH
48445: CALL_OW 1
48449: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
48450: LD_VAR 0 1
48454: PUSH
48455: LD_EXP 86
48459: PUSH
48460: LD_VAR 0 5
48464: ARRAY
48465: IN
48466: IFFALSE 48505
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
48468: LD_ADDR_EXP 86
48472: PUSH
48473: LD_EXP 86
48477: PPUSH
48478: LD_VAR 0 5
48482: PPUSH
48483: LD_EXP 86
48487: PUSH
48488: LD_VAR 0 5
48492: ARRAY
48493: PUSH
48494: LD_VAR 0 1
48498: DIFF
48499: PPUSH
48500: CALL_OW 1
48504: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
48505: LD_VAR 0 1
48509: PUSH
48510: LD_EXP 87
48514: PUSH
48515: LD_VAR 0 5
48519: ARRAY
48520: IN
48521: IFFALSE 48560
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
48523: LD_ADDR_EXP 87
48527: PUSH
48528: LD_EXP 87
48532: PPUSH
48533: LD_VAR 0 5
48537: PPUSH
48538: LD_EXP 87
48542: PUSH
48543: LD_VAR 0 5
48547: ARRAY
48548: PUSH
48549: LD_VAR 0 1
48553: DIFF
48554: PPUSH
48555: CALL_OW 1
48559: ST_TO_ADDR
// break ;
48560: GO 48564
// end ;
48562: GO 48382
48564: POP
48565: POP
// end ;
48566: LD_VAR 0 4
48570: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
48571: LD_INT 0
48573: PPUSH
48574: PPUSH
48575: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
48576: LD_EXP 78
48580: NOT
48581: PUSH
48582: LD_EXP 76
48586: NOT
48587: OR
48588: PUSH
48589: LD_VAR 0 3
48593: PUSH
48594: LD_EXP 104
48598: IN
48599: NOT
48600: OR
48601: IFFALSE 48605
// exit ;
48603: GO 48728
// for i = 1 to mc_vehicles do
48605: LD_ADDR_VAR 0 6
48609: PUSH
48610: DOUBLE
48611: LD_INT 1
48613: DEC
48614: ST_TO_ADDR
48615: LD_EXP 97
48619: PUSH
48620: FOR_TO
48621: IFFALSE 48726
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
48623: LD_VAR 0 2
48627: PUSH
48628: LD_EXP 97
48632: PUSH
48633: LD_VAR 0 6
48637: ARRAY
48638: IN
48639: PUSH
48640: LD_VAR 0 1
48644: PUSH
48645: LD_EXP 97
48649: PUSH
48650: LD_VAR 0 6
48654: ARRAY
48655: IN
48656: OR
48657: IFFALSE 48724
// begin tmp := mc_vehicles [ i ] diff old ;
48659: LD_ADDR_VAR 0 7
48663: PUSH
48664: LD_EXP 97
48668: PUSH
48669: LD_VAR 0 6
48673: ARRAY
48674: PUSH
48675: LD_VAR 0 2
48679: DIFF
48680: ST_TO_ADDR
// tmp := tmp diff new ;
48681: LD_ADDR_VAR 0 7
48685: PUSH
48686: LD_VAR 0 7
48690: PUSH
48691: LD_VAR 0 1
48695: DIFF
48696: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
48697: LD_ADDR_EXP 97
48701: PUSH
48702: LD_EXP 97
48706: PPUSH
48707: LD_VAR 0 6
48711: PPUSH
48712: LD_VAR 0 7
48716: PPUSH
48717: CALL_OW 1
48721: ST_TO_ADDR
// break ;
48722: GO 48726
// end ;
48724: GO 48620
48726: POP
48727: POP
// end ;
48728: LD_VAR 0 5
48732: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
48733: LD_INT 0
48735: PPUSH
48736: PPUSH
48737: PPUSH
48738: PPUSH
// if not mc_bases or not skirmish then
48739: LD_EXP 78
48743: NOT
48744: PUSH
48745: LD_EXP 76
48749: NOT
48750: OR
48751: IFFALSE 48755
// exit ;
48753: GO 49175
// repeat wait ( 0 0$1 ) ;
48755: LD_INT 35
48757: PPUSH
48758: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
48762: LD_EXP 122
48766: NOT
48767: IFFALSE 48755
// mc_block_vehicle_constructed_thread := true ;
48769: LD_ADDR_EXP 122
48773: PUSH
48774: LD_INT 1
48776: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
48777: LD_ADDR_VAR 0 5
48781: PUSH
48782: LD_VAR 0 1
48786: PPUSH
48787: CALL_OW 255
48791: ST_TO_ADDR
// for i = 1 to mc_bases do
48792: LD_ADDR_VAR 0 4
48796: PUSH
48797: DOUBLE
48798: LD_INT 1
48800: DEC
48801: ST_TO_ADDR
48802: LD_EXP 78
48806: PUSH
48807: FOR_TO
48808: IFFALSE 49165
// begin if factory in mc_bases [ i ] then
48810: LD_VAR 0 2
48814: PUSH
48815: LD_EXP 78
48819: PUSH
48820: LD_VAR 0 4
48824: ARRAY
48825: IN
48826: IFFALSE 49163
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48828: LD_EXP 100
48832: PUSH
48833: LD_VAR 0 4
48837: ARRAY
48838: PUSH
48839: LD_EXP 89
48843: PUSH
48844: LD_VAR 0 4
48848: ARRAY
48849: LESS
48850: PUSH
48851: LD_VAR 0 1
48855: PPUSH
48856: CALL_OW 264
48860: PUSH
48861: LD_INT 31
48863: PUSH
48864: LD_INT 32
48866: PUSH
48867: LD_INT 51
48869: PUSH
48870: LD_INT 89
48872: PUSH
48873: LD_INT 12
48875: PUSH
48876: LD_INT 30
48878: PUSH
48879: LD_INT 98
48881: PUSH
48882: LD_INT 11
48884: PUSH
48885: LD_INT 53
48887: PUSH
48888: LD_INT 14
48890: PUSH
48891: LD_INT 91
48893: PUSH
48894: LD_INT 29
48896: PUSH
48897: LD_INT 99
48899: PUSH
48900: LD_INT 13
48902: PUSH
48903: LD_INT 52
48905: PUSH
48906: LD_INT 88
48908: PUSH
48909: LD_INT 48
48911: PUSH
48912: LD_INT 8
48914: PUSH
48915: EMPTY
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: IN
48935: NOT
48936: AND
48937: IFFALSE 48985
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48939: LD_ADDR_EXP 100
48943: PUSH
48944: LD_EXP 100
48948: PPUSH
48949: LD_VAR 0 4
48953: PUSH
48954: LD_EXP 100
48958: PUSH
48959: LD_VAR 0 4
48963: ARRAY
48964: PUSH
48965: LD_INT 1
48967: PLUS
48968: PUSH
48969: EMPTY
48970: LIST
48971: LIST
48972: PPUSH
48973: LD_VAR 0 1
48977: PPUSH
48978: CALL 57810 0 3
48982: ST_TO_ADDR
48983: GO 49029
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48985: LD_ADDR_EXP 97
48989: PUSH
48990: LD_EXP 97
48994: PPUSH
48995: LD_VAR 0 4
48999: PUSH
49000: LD_EXP 97
49004: PUSH
49005: LD_VAR 0 4
49009: ARRAY
49010: PUSH
49011: LD_INT 1
49013: PLUS
49014: PUSH
49015: EMPTY
49016: LIST
49017: LIST
49018: PPUSH
49019: LD_VAR 0 1
49023: PPUSH
49024: CALL 57810 0 3
49028: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
49029: LD_ADDR_EXP 122
49033: PUSH
49034: LD_INT 0
49036: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49037: LD_VAR 0 1
49041: PPUSH
49042: CALL_OW 263
49046: PUSH
49047: LD_INT 2
49049: EQUAL
49050: IFFALSE 49079
// begin repeat wait ( 0 0$3 ) ;
49052: LD_INT 105
49054: PPUSH
49055: CALL_OW 67
// Connect ( vehicle ) ;
49059: LD_VAR 0 1
49063: PPUSH
49064: CALL 60779 0 1
// until IsControledBy ( vehicle ) ;
49068: LD_VAR 0 1
49072: PPUSH
49073: CALL_OW 312
49077: IFFALSE 49052
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49079: LD_VAR 0 1
49083: PPUSH
49084: LD_EXP 102
49088: PUSH
49089: LD_VAR 0 4
49093: ARRAY
49094: PPUSH
49095: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49099: LD_VAR 0 1
49103: PPUSH
49104: CALL_OW 263
49108: PUSH
49109: LD_INT 1
49111: NONEQUAL
49112: IFFALSE 49116
// break ;
49114: GO 49165
// repeat wait ( 0 0$1 ) ;
49116: LD_INT 35
49118: PPUSH
49119: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
49123: LD_VAR 0 1
49127: PPUSH
49128: LD_EXP 102
49132: PUSH
49133: LD_VAR 0 4
49137: ARRAY
49138: PPUSH
49139: CALL_OW 308
49143: IFFALSE 49116
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
49145: LD_VAR 0 1
49149: PPUSH
49150: CALL_OW 311
49154: PPUSH
49155: CALL_OW 121
// exit ;
49159: POP
49160: POP
49161: GO 49175
// end ; end ;
49163: GO 48807
49165: POP
49166: POP
// mc_block_vehicle_constructed_thread := false ;
49167: LD_ADDR_EXP 122
49171: PUSH
49172: LD_INT 0
49174: ST_TO_ADDR
// end ;
49175: LD_VAR 0 3
49179: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
49180: LD_INT 0
49182: PPUSH
49183: PPUSH
49184: PPUSH
49185: PPUSH
// if not mc_bases or not skirmish then
49186: LD_EXP 78
49190: NOT
49191: PUSH
49192: LD_EXP 76
49196: NOT
49197: OR
49198: IFFALSE 49202
// exit ;
49200: GO 49555
// repeat wait ( 0 0$1 ) ;
49202: LD_INT 35
49204: PPUSH
49205: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
49209: LD_VAR 0 2
49213: PPUSH
49214: LD_VAR 0 3
49218: PPUSH
49219: CALL_OW 284
49223: IFFALSE 49202
// if GetResourceTypeXY ( x , y ) = mat_artefact then
49225: LD_VAR 0 2
49229: PPUSH
49230: LD_VAR 0 3
49234: PPUSH
49235: CALL_OW 283
49239: PUSH
49240: LD_INT 4
49242: EQUAL
49243: IFFALSE 49247
// exit ;
49245: GO 49555
// for i = 1 to mc_bases do
49247: LD_ADDR_VAR 0 7
49251: PUSH
49252: DOUBLE
49253: LD_INT 1
49255: DEC
49256: ST_TO_ADDR
49257: LD_EXP 78
49261: PUSH
49262: FOR_TO
49263: IFFALSE 49553
// begin if mc_crates_area [ i ] then
49265: LD_EXP 96
49269: PUSH
49270: LD_VAR 0 7
49274: ARRAY
49275: IFFALSE 49386
// for j in mc_crates_area [ i ] do
49277: LD_ADDR_VAR 0 8
49281: PUSH
49282: LD_EXP 96
49286: PUSH
49287: LD_VAR 0 7
49291: ARRAY
49292: PUSH
49293: FOR_IN
49294: IFFALSE 49384
// if InArea ( x , y , j ) then
49296: LD_VAR 0 2
49300: PPUSH
49301: LD_VAR 0 3
49305: PPUSH
49306: LD_VAR 0 8
49310: PPUSH
49311: CALL_OW 309
49315: IFFALSE 49382
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49317: LD_ADDR_EXP 94
49321: PUSH
49322: LD_EXP 94
49326: PPUSH
49327: LD_VAR 0 7
49331: PUSH
49332: LD_EXP 94
49336: PUSH
49337: LD_VAR 0 7
49341: ARRAY
49342: PUSH
49343: LD_INT 1
49345: PLUS
49346: PUSH
49347: EMPTY
49348: LIST
49349: LIST
49350: PPUSH
49351: LD_VAR 0 4
49355: PUSH
49356: LD_VAR 0 2
49360: PUSH
49361: LD_VAR 0 3
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: LIST
49370: PPUSH
49371: CALL 57810 0 3
49375: ST_TO_ADDR
// exit ;
49376: POP
49377: POP
49378: POP
49379: POP
49380: GO 49555
// end ;
49382: GO 49293
49384: POP
49385: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49386: LD_ADDR_VAR 0 9
49390: PUSH
49391: LD_EXP 78
49395: PUSH
49396: LD_VAR 0 7
49400: ARRAY
49401: PPUSH
49402: LD_INT 2
49404: PUSH
49405: LD_INT 30
49407: PUSH
49408: LD_INT 0
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: PUSH
49415: LD_INT 30
49417: PUSH
49418: LD_INT 1
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: PUSH
49425: EMPTY
49426: LIST
49427: LIST
49428: LIST
49429: PPUSH
49430: CALL_OW 72
49434: ST_TO_ADDR
// if not depot then
49435: LD_VAR 0 9
49439: NOT
49440: IFFALSE 49444
// continue ;
49442: GO 49262
// for j in depot do
49444: LD_ADDR_VAR 0 8
49448: PUSH
49449: LD_VAR 0 9
49453: PUSH
49454: FOR_IN
49455: IFFALSE 49549
// if GetDistUnitXY ( j , x , y ) < 30 then
49457: LD_VAR 0 8
49461: PPUSH
49462: LD_VAR 0 2
49466: PPUSH
49467: LD_VAR 0 3
49471: PPUSH
49472: CALL_OW 297
49476: PUSH
49477: LD_INT 30
49479: LESS
49480: IFFALSE 49547
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49482: LD_ADDR_EXP 94
49486: PUSH
49487: LD_EXP 94
49491: PPUSH
49492: LD_VAR 0 7
49496: PUSH
49497: LD_EXP 94
49501: PUSH
49502: LD_VAR 0 7
49506: ARRAY
49507: PUSH
49508: LD_INT 1
49510: PLUS
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: PPUSH
49516: LD_VAR 0 4
49520: PUSH
49521: LD_VAR 0 2
49525: PUSH
49526: LD_VAR 0 3
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: LIST
49535: PPUSH
49536: CALL 57810 0 3
49540: ST_TO_ADDR
// exit ;
49541: POP
49542: POP
49543: POP
49544: POP
49545: GO 49555
// end ;
49547: GO 49454
49549: POP
49550: POP
// end ;
49551: GO 49262
49553: POP
49554: POP
// end ;
49555: LD_VAR 0 6
49559: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
49560: LD_INT 0
49562: PPUSH
49563: PPUSH
49564: PPUSH
49565: PPUSH
// if not mc_bases or not skirmish then
49566: LD_EXP 78
49570: NOT
49571: PUSH
49572: LD_EXP 76
49576: NOT
49577: OR
49578: IFFALSE 49582
// exit ;
49580: GO 49859
// side := GetSide ( lab ) ;
49582: LD_ADDR_VAR 0 4
49586: PUSH
49587: LD_VAR 0 2
49591: PPUSH
49592: CALL_OW 255
49596: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
49597: LD_VAR 0 4
49601: PUSH
49602: LD_EXP 104
49606: IN
49607: NOT
49608: PUSH
49609: LD_EXP 105
49613: NOT
49614: OR
49615: PUSH
49616: LD_EXP 78
49620: NOT
49621: OR
49622: IFFALSE 49626
// exit ;
49624: GO 49859
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
49626: LD_ADDR_EXP 105
49630: PUSH
49631: LD_EXP 105
49635: PPUSH
49636: LD_VAR 0 4
49640: PPUSH
49641: LD_EXP 105
49645: PUSH
49646: LD_VAR 0 4
49650: ARRAY
49651: PUSH
49652: LD_VAR 0 1
49656: DIFF
49657: PPUSH
49658: CALL_OW 1
49662: ST_TO_ADDR
// for i = 1 to mc_bases do
49663: LD_ADDR_VAR 0 5
49667: PUSH
49668: DOUBLE
49669: LD_INT 1
49671: DEC
49672: ST_TO_ADDR
49673: LD_EXP 78
49677: PUSH
49678: FOR_TO
49679: IFFALSE 49857
// begin if lab in mc_bases [ i ] then
49681: LD_VAR 0 2
49685: PUSH
49686: LD_EXP 78
49690: PUSH
49691: LD_VAR 0 5
49695: ARRAY
49696: IN
49697: IFFALSE 49855
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
49699: LD_VAR 0 1
49703: PUSH
49704: LD_INT 11
49706: PUSH
49707: LD_INT 4
49709: PUSH
49710: LD_INT 3
49712: PUSH
49713: LD_INT 2
49715: PUSH
49716: EMPTY
49717: LIST
49718: LIST
49719: LIST
49720: LIST
49721: IN
49722: PUSH
49723: LD_EXP 108
49727: PUSH
49728: LD_VAR 0 5
49732: ARRAY
49733: AND
49734: IFFALSE 49855
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
49736: LD_ADDR_VAR 0 6
49740: PUSH
49741: LD_EXP 108
49745: PUSH
49746: LD_VAR 0 5
49750: ARRAY
49751: PUSH
49752: LD_INT 1
49754: ARRAY
49755: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49756: LD_ADDR_EXP 108
49760: PUSH
49761: LD_EXP 108
49765: PPUSH
49766: LD_VAR 0 5
49770: PPUSH
49771: EMPTY
49772: PPUSH
49773: CALL_OW 1
49777: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
49778: LD_VAR 0 6
49782: PPUSH
49783: LD_INT 0
49785: PPUSH
49786: CALL_OW 109
// ComExitBuilding ( tmp ) ;
49790: LD_VAR 0 6
49794: PPUSH
49795: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
49799: LD_ADDR_EXP 107
49803: PUSH
49804: LD_EXP 107
49808: PPUSH
49809: LD_VAR 0 5
49813: PPUSH
49814: LD_EXP 107
49818: PUSH
49819: LD_VAR 0 5
49823: ARRAY
49824: PPUSH
49825: LD_INT 1
49827: PPUSH
49828: LD_VAR 0 6
49832: PPUSH
49833: CALL_OW 2
49837: PPUSH
49838: CALL_OW 1
49842: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49843: LD_VAR 0 5
49847: PPUSH
49848: LD_INT 112
49850: PPUSH
49851: CALL 26323 0 2
// end ; end ; end ;
49855: GO 49678
49857: POP
49858: POP
// end ;
49859: LD_VAR 0 3
49863: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49864: LD_INT 0
49866: PPUSH
49867: PPUSH
49868: PPUSH
49869: PPUSH
49870: PPUSH
49871: PPUSH
49872: PPUSH
49873: PPUSH
// if not mc_bases or not skirmish then
49874: LD_EXP 78
49878: NOT
49879: PUSH
49880: LD_EXP 76
49884: NOT
49885: OR
49886: IFFALSE 49890
// exit ;
49888: GO 51259
// for i = 1 to mc_bases do
49890: LD_ADDR_VAR 0 3
49894: PUSH
49895: DOUBLE
49896: LD_INT 1
49898: DEC
49899: ST_TO_ADDR
49900: LD_EXP 78
49904: PUSH
49905: FOR_TO
49906: IFFALSE 51257
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49908: LD_VAR 0 1
49912: PUSH
49913: LD_EXP 78
49917: PUSH
49918: LD_VAR 0 3
49922: ARRAY
49923: IN
49924: PUSH
49925: LD_VAR 0 1
49929: PUSH
49930: LD_EXP 85
49934: PUSH
49935: LD_VAR 0 3
49939: ARRAY
49940: IN
49941: OR
49942: PUSH
49943: LD_VAR 0 1
49947: PUSH
49948: LD_EXP 100
49952: PUSH
49953: LD_VAR 0 3
49957: ARRAY
49958: IN
49959: OR
49960: PUSH
49961: LD_VAR 0 1
49965: PUSH
49966: LD_EXP 97
49970: PUSH
49971: LD_VAR 0 3
49975: ARRAY
49976: IN
49977: OR
49978: PUSH
49979: LD_VAR 0 1
49983: PUSH
49984: LD_EXP 107
49988: PUSH
49989: LD_VAR 0 3
49993: ARRAY
49994: IN
49995: OR
49996: PUSH
49997: LD_VAR 0 1
50001: PUSH
50002: LD_EXP 108
50006: PUSH
50007: LD_VAR 0 3
50011: ARRAY
50012: IN
50013: OR
50014: IFFALSE 51255
// begin if un in mc_ape [ i ] then
50016: LD_VAR 0 1
50020: PUSH
50021: LD_EXP 107
50025: PUSH
50026: LD_VAR 0 3
50030: ARRAY
50031: IN
50032: IFFALSE 50071
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
50034: LD_ADDR_EXP 107
50038: PUSH
50039: LD_EXP 107
50043: PPUSH
50044: LD_VAR 0 3
50048: PPUSH
50049: LD_EXP 107
50053: PUSH
50054: LD_VAR 0 3
50058: ARRAY
50059: PUSH
50060: LD_VAR 0 1
50064: DIFF
50065: PPUSH
50066: CALL_OW 1
50070: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50071: LD_VAR 0 1
50075: PUSH
50076: LD_EXP 108
50080: PUSH
50081: LD_VAR 0 3
50085: ARRAY
50086: IN
50087: IFFALSE 50111
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50089: LD_ADDR_EXP 108
50093: PUSH
50094: LD_EXP 108
50098: PPUSH
50099: LD_VAR 0 3
50103: PPUSH
50104: EMPTY
50105: PPUSH
50106: CALL_OW 1
50110: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50111: LD_VAR 0 1
50115: PPUSH
50116: CALL_OW 247
50120: PUSH
50121: LD_INT 2
50123: EQUAL
50124: PUSH
50125: LD_VAR 0 1
50129: PPUSH
50130: CALL_OW 110
50134: PUSH
50135: LD_INT 20
50137: EQUAL
50138: PUSH
50139: LD_VAR 0 1
50143: PUSH
50144: LD_EXP 100
50148: PUSH
50149: LD_VAR 0 3
50153: ARRAY
50154: IN
50155: OR
50156: PUSH
50157: LD_VAR 0 1
50161: PPUSH
50162: CALL_OW 264
50166: PUSH
50167: LD_INT 12
50169: PUSH
50170: LD_INT 51
50172: PUSH
50173: LD_INT 89
50175: PUSH
50176: LD_INT 32
50178: PUSH
50179: LD_INT 13
50181: PUSH
50182: LD_INT 52
50184: PUSH
50185: LD_INT 31
50187: PUSH
50188: EMPTY
50189: LIST
50190: LIST
50191: LIST
50192: LIST
50193: LIST
50194: LIST
50195: LIST
50196: IN
50197: OR
50198: AND
50199: IFFALSE 50507
// begin if un in mc_defender [ i ] then
50201: LD_VAR 0 1
50205: PUSH
50206: LD_EXP 100
50210: PUSH
50211: LD_VAR 0 3
50215: ARRAY
50216: IN
50217: IFFALSE 50256
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50219: LD_ADDR_EXP 100
50223: PUSH
50224: LD_EXP 100
50228: PPUSH
50229: LD_VAR 0 3
50233: PPUSH
50234: LD_EXP 100
50238: PUSH
50239: LD_VAR 0 3
50243: ARRAY
50244: PUSH
50245: LD_VAR 0 1
50249: DIFF
50250: PPUSH
50251: CALL_OW 1
50255: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
50256: LD_ADDR_VAR 0 8
50260: PUSH
50261: LD_VAR 0 3
50265: PPUSH
50266: LD_INT 3
50268: PPUSH
50269: CALL 46877 0 2
50273: ST_TO_ADDR
// if fac then
50274: LD_VAR 0 8
50278: IFFALSE 50507
// begin for j in fac do
50280: LD_ADDR_VAR 0 4
50284: PUSH
50285: LD_VAR 0 8
50289: PUSH
50290: FOR_IN
50291: IFFALSE 50505
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
50293: LD_ADDR_VAR 0 9
50297: PUSH
50298: LD_VAR 0 8
50302: PPUSH
50303: LD_VAR 0 1
50307: PPUSH
50308: CALL_OW 265
50312: PPUSH
50313: LD_VAR 0 1
50317: PPUSH
50318: CALL_OW 262
50322: PPUSH
50323: LD_VAR 0 1
50327: PPUSH
50328: CALL_OW 263
50332: PPUSH
50333: LD_VAR 0 1
50337: PPUSH
50338: CALL_OW 264
50342: PPUSH
50343: CALL 55308 0 5
50347: ST_TO_ADDR
// if components then
50348: LD_VAR 0 9
50352: IFFALSE 50503
// begin if GetWeapon ( un ) = ar_control_tower then
50354: LD_VAR 0 1
50358: PPUSH
50359: CALL_OW 264
50363: PUSH
50364: LD_INT 31
50366: EQUAL
50367: IFFALSE 50484
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
50369: LD_VAR 0 1
50373: PPUSH
50374: CALL_OW 311
50378: PPUSH
50379: LD_INT 0
50381: PPUSH
50382: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
50386: LD_ADDR_EXP 118
50390: PUSH
50391: LD_EXP 118
50395: PPUSH
50396: LD_VAR 0 3
50400: PPUSH
50401: LD_EXP 118
50405: PUSH
50406: LD_VAR 0 3
50410: ARRAY
50411: PUSH
50412: LD_VAR 0 1
50416: PPUSH
50417: CALL_OW 311
50421: DIFF
50422: PPUSH
50423: CALL_OW 1
50427: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
50428: LD_ADDR_VAR 0 7
50432: PUSH
50433: LD_EXP 99
50437: PUSH
50438: LD_VAR 0 3
50442: ARRAY
50443: PPUSH
50444: LD_INT 1
50446: PPUSH
50447: LD_VAR 0 9
50451: PPUSH
50452: CALL_OW 2
50456: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50457: LD_ADDR_EXP 99
50461: PUSH
50462: LD_EXP 99
50466: PPUSH
50467: LD_VAR 0 3
50471: PPUSH
50472: LD_VAR 0 7
50476: PPUSH
50477: CALL_OW 1
50481: ST_TO_ADDR
// end else
50482: GO 50501
// MC_InsertProduceList ( i , [ components ] ) ;
50484: LD_VAR 0 3
50488: PPUSH
50489: LD_VAR 0 9
50493: PUSH
50494: EMPTY
50495: LIST
50496: PPUSH
50497: CALL 46422 0 2
// break ;
50501: GO 50505
// end ; end ;
50503: GO 50290
50505: POP
50506: POP
// end ; end ; if GetType ( un ) = unit_building then
50507: LD_VAR 0 1
50511: PPUSH
50512: CALL_OW 247
50516: PUSH
50517: LD_INT 3
50519: EQUAL
50520: IFFALSE 50923
// begin btype := GetBType ( un ) ;
50522: LD_ADDR_VAR 0 5
50526: PUSH
50527: LD_VAR 0 1
50531: PPUSH
50532: CALL_OW 266
50536: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
50537: LD_VAR 0 5
50541: PUSH
50542: LD_INT 29
50544: PUSH
50545: LD_INT 30
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: IN
50552: IFFALSE 50625
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
50554: LD_VAR 0 1
50558: PPUSH
50559: CALL_OW 250
50563: PPUSH
50564: LD_VAR 0 1
50568: PPUSH
50569: CALL_OW 251
50573: PPUSH
50574: LD_VAR 0 1
50578: PPUSH
50579: CALL_OW 255
50583: PPUSH
50584: CALL_OW 440
50588: NOT
50589: IFFALSE 50625
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
50591: LD_VAR 0 1
50595: PPUSH
50596: CALL_OW 250
50600: PPUSH
50601: LD_VAR 0 1
50605: PPUSH
50606: CALL_OW 251
50610: PPUSH
50611: LD_VAR 0 1
50615: PPUSH
50616: CALL_OW 255
50620: PPUSH
50621: CALL_OW 441
// end ; if btype = b_warehouse then
50625: LD_VAR 0 5
50629: PUSH
50630: LD_INT 1
50632: EQUAL
50633: IFFALSE 50651
// begin btype := b_depot ;
50635: LD_ADDR_VAR 0 5
50639: PUSH
50640: LD_INT 0
50642: ST_TO_ADDR
// pos := 1 ;
50643: LD_ADDR_VAR 0 6
50647: PUSH
50648: LD_INT 1
50650: ST_TO_ADDR
// end ; if btype = b_factory then
50651: LD_VAR 0 5
50655: PUSH
50656: LD_INT 3
50658: EQUAL
50659: IFFALSE 50677
// begin btype := b_workshop ;
50661: LD_ADDR_VAR 0 5
50665: PUSH
50666: LD_INT 2
50668: ST_TO_ADDR
// pos := 1 ;
50669: LD_ADDR_VAR 0 6
50673: PUSH
50674: LD_INT 1
50676: ST_TO_ADDR
// end ; if btype = b_barracks then
50677: LD_VAR 0 5
50681: PUSH
50682: LD_INT 5
50684: EQUAL
50685: IFFALSE 50695
// btype := b_armoury ;
50687: LD_ADDR_VAR 0 5
50691: PUSH
50692: LD_INT 4
50694: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
50695: LD_VAR 0 5
50699: PUSH
50700: LD_INT 7
50702: PUSH
50703: LD_INT 8
50705: PUSH
50706: EMPTY
50707: LIST
50708: LIST
50709: IN
50710: IFFALSE 50720
// btype := b_lab ;
50712: LD_ADDR_VAR 0 5
50716: PUSH
50717: LD_INT 6
50719: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
50720: LD_ADDR_EXP 83
50724: PUSH
50725: LD_EXP 83
50729: PPUSH
50730: LD_VAR 0 3
50734: PUSH
50735: LD_EXP 83
50739: PUSH
50740: LD_VAR 0 3
50744: ARRAY
50745: PUSH
50746: LD_INT 1
50748: PLUS
50749: PUSH
50750: EMPTY
50751: LIST
50752: LIST
50753: PPUSH
50754: LD_VAR 0 5
50758: PUSH
50759: LD_VAR 0 1
50763: PPUSH
50764: CALL_OW 250
50768: PUSH
50769: LD_VAR 0 1
50773: PPUSH
50774: CALL_OW 251
50778: PUSH
50779: LD_VAR 0 1
50783: PPUSH
50784: CALL_OW 254
50788: PUSH
50789: EMPTY
50790: LIST
50791: LIST
50792: LIST
50793: LIST
50794: PPUSH
50795: CALL 57810 0 3
50799: ST_TO_ADDR
// if pos = 1 then
50800: LD_VAR 0 6
50804: PUSH
50805: LD_INT 1
50807: EQUAL
50808: IFFALSE 50923
// begin tmp := mc_build_list [ i ] ;
50810: LD_ADDR_VAR 0 7
50814: PUSH
50815: LD_EXP 83
50819: PUSH
50820: LD_VAR 0 3
50824: ARRAY
50825: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50826: LD_VAR 0 7
50830: PPUSH
50831: LD_INT 2
50833: PUSH
50834: LD_INT 30
50836: PUSH
50837: LD_INT 0
50839: PUSH
50840: EMPTY
50841: LIST
50842: LIST
50843: PUSH
50844: LD_INT 30
50846: PUSH
50847: LD_INT 1
50849: PUSH
50850: EMPTY
50851: LIST
50852: LIST
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: LIST
50858: PPUSH
50859: CALL_OW 72
50863: IFFALSE 50873
// pos := 2 ;
50865: LD_ADDR_VAR 0 6
50869: PUSH
50870: LD_INT 2
50872: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50873: LD_ADDR_VAR 0 7
50877: PUSH
50878: LD_VAR 0 7
50882: PPUSH
50883: LD_VAR 0 6
50887: PPUSH
50888: LD_VAR 0 7
50892: PPUSH
50893: CALL 58136 0 3
50897: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50898: LD_ADDR_EXP 83
50902: PUSH
50903: LD_EXP 83
50907: PPUSH
50908: LD_VAR 0 3
50912: PPUSH
50913: LD_VAR 0 7
50917: PPUSH
50918: CALL_OW 1
50922: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50923: LD_VAR 0 1
50927: PUSH
50928: LD_EXP 78
50932: PUSH
50933: LD_VAR 0 3
50937: ARRAY
50938: IN
50939: IFFALSE 50978
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50941: LD_ADDR_EXP 78
50945: PUSH
50946: LD_EXP 78
50950: PPUSH
50951: LD_VAR 0 3
50955: PPUSH
50956: LD_EXP 78
50960: PUSH
50961: LD_VAR 0 3
50965: ARRAY
50966: PUSH
50967: LD_VAR 0 1
50971: DIFF
50972: PPUSH
50973: CALL_OW 1
50977: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50978: LD_VAR 0 1
50982: PUSH
50983: LD_EXP 85
50987: PUSH
50988: LD_VAR 0 3
50992: ARRAY
50993: IN
50994: IFFALSE 51033
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50996: LD_ADDR_EXP 85
51000: PUSH
51001: LD_EXP 85
51005: PPUSH
51006: LD_VAR 0 3
51010: PPUSH
51011: LD_EXP 85
51015: PUSH
51016: LD_VAR 0 3
51020: ARRAY
51021: PUSH
51022: LD_VAR 0 1
51026: DIFF
51027: PPUSH
51028: CALL_OW 1
51032: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
51033: LD_VAR 0 1
51037: PUSH
51038: LD_EXP 97
51042: PUSH
51043: LD_VAR 0 3
51047: ARRAY
51048: IN
51049: IFFALSE 51088
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51051: LD_ADDR_EXP 97
51055: PUSH
51056: LD_EXP 97
51060: PPUSH
51061: LD_VAR 0 3
51065: PPUSH
51066: LD_EXP 97
51070: PUSH
51071: LD_VAR 0 3
51075: ARRAY
51076: PUSH
51077: LD_VAR 0 1
51081: DIFF
51082: PPUSH
51083: CALL_OW 1
51087: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51088: LD_VAR 0 1
51092: PUSH
51093: LD_EXP 100
51097: PUSH
51098: LD_VAR 0 3
51102: ARRAY
51103: IN
51104: IFFALSE 51143
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51106: LD_ADDR_EXP 100
51110: PUSH
51111: LD_EXP 100
51115: PPUSH
51116: LD_VAR 0 3
51120: PPUSH
51121: LD_EXP 100
51125: PUSH
51126: LD_VAR 0 3
51130: ARRAY
51131: PUSH
51132: LD_VAR 0 1
51136: DIFF
51137: PPUSH
51138: CALL_OW 1
51142: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
51143: LD_VAR 0 1
51147: PUSH
51148: LD_EXP 87
51152: PUSH
51153: LD_VAR 0 3
51157: ARRAY
51158: IN
51159: IFFALSE 51198
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
51161: LD_ADDR_EXP 87
51165: PUSH
51166: LD_EXP 87
51170: PPUSH
51171: LD_VAR 0 3
51175: PPUSH
51176: LD_EXP 87
51180: PUSH
51181: LD_VAR 0 3
51185: ARRAY
51186: PUSH
51187: LD_VAR 0 1
51191: DIFF
51192: PPUSH
51193: CALL_OW 1
51197: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
51198: LD_VAR 0 1
51202: PUSH
51203: LD_EXP 86
51207: PUSH
51208: LD_VAR 0 3
51212: ARRAY
51213: IN
51214: IFFALSE 51253
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
51216: LD_ADDR_EXP 86
51220: PUSH
51221: LD_EXP 86
51225: PPUSH
51226: LD_VAR 0 3
51230: PPUSH
51231: LD_EXP 86
51235: PUSH
51236: LD_VAR 0 3
51240: ARRAY
51241: PUSH
51242: LD_VAR 0 1
51246: DIFF
51247: PPUSH
51248: CALL_OW 1
51252: ST_TO_ADDR
// end ; break ;
51253: GO 51257
// end ;
51255: GO 49905
51257: POP
51258: POP
// end ;
51259: LD_VAR 0 2
51263: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
51264: LD_INT 0
51266: PPUSH
51267: PPUSH
51268: PPUSH
// if not mc_bases or not skirmish then
51269: LD_EXP 78
51273: NOT
51274: PUSH
51275: LD_EXP 76
51279: NOT
51280: OR
51281: IFFALSE 51285
// exit ;
51283: GO 51500
// for i = 1 to mc_bases do
51285: LD_ADDR_VAR 0 3
51289: PUSH
51290: DOUBLE
51291: LD_INT 1
51293: DEC
51294: ST_TO_ADDR
51295: LD_EXP 78
51299: PUSH
51300: FOR_TO
51301: IFFALSE 51498
// begin if building in mc_construct_list [ i ] then
51303: LD_VAR 0 1
51307: PUSH
51308: LD_EXP 85
51312: PUSH
51313: LD_VAR 0 3
51317: ARRAY
51318: IN
51319: IFFALSE 51496
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51321: LD_ADDR_EXP 85
51325: PUSH
51326: LD_EXP 85
51330: PPUSH
51331: LD_VAR 0 3
51335: PPUSH
51336: LD_EXP 85
51340: PUSH
51341: LD_VAR 0 3
51345: ARRAY
51346: PUSH
51347: LD_VAR 0 1
51351: DIFF
51352: PPUSH
51353: CALL_OW 1
51357: ST_TO_ADDR
// if building in mc_lab [ i ] then
51358: LD_VAR 0 1
51362: PUSH
51363: LD_EXP 111
51367: PUSH
51368: LD_VAR 0 3
51372: ARRAY
51373: IN
51374: IFFALSE 51429
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
51376: LD_ADDR_EXP 112
51380: PUSH
51381: LD_EXP 112
51385: PPUSH
51386: LD_VAR 0 3
51390: PPUSH
51391: LD_EXP 112
51395: PUSH
51396: LD_VAR 0 3
51400: ARRAY
51401: PPUSH
51402: LD_INT 1
51404: PPUSH
51405: LD_EXP 112
51409: PUSH
51410: LD_VAR 0 3
51414: ARRAY
51415: PPUSH
51416: LD_INT 0
51418: PPUSH
51419: CALL 57228 0 4
51423: PPUSH
51424: CALL_OW 1
51428: ST_TO_ADDR
// if not building in mc_bases [ i ] then
51429: LD_VAR 0 1
51433: PUSH
51434: LD_EXP 78
51438: PUSH
51439: LD_VAR 0 3
51443: ARRAY
51444: IN
51445: NOT
51446: IFFALSE 51492
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51448: LD_ADDR_EXP 78
51452: PUSH
51453: LD_EXP 78
51457: PPUSH
51458: LD_VAR 0 3
51462: PUSH
51463: LD_EXP 78
51467: PUSH
51468: LD_VAR 0 3
51472: ARRAY
51473: PUSH
51474: LD_INT 1
51476: PLUS
51477: PUSH
51478: EMPTY
51479: LIST
51480: LIST
51481: PPUSH
51482: LD_VAR 0 1
51486: PPUSH
51487: CALL 57810 0 3
51491: ST_TO_ADDR
// exit ;
51492: POP
51493: POP
51494: GO 51500
// end ; end ;
51496: GO 51300
51498: POP
51499: POP
// end ;
51500: LD_VAR 0 2
51504: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
51505: LD_INT 0
51507: PPUSH
51508: PPUSH
51509: PPUSH
51510: PPUSH
51511: PPUSH
51512: PPUSH
51513: PPUSH
// if not mc_bases or not skirmish then
51514: LD_EXP 78
51518: NOT
51519: PUSH
51520: LD_EXP 76
51524: NOT
51525: OR
51526: IFFALSE 51530
// exit ;
51528: GO 52191
// for i = 1 to mc_bases do
51530: LD_ADDR_VAR 0 3
51534: PUSH
51535: DOUBLE
51536: LD_INT 1
51538: DEC
51539: ST_TO_ADDR
51540: LD_EXP 78
51544: PUSH
51545: FOR_TO
51546: IFFALSE 52189
// begin if building in mc_construct_list [ i ] then
51548: LD_VAR 0 1
51552: PUSH
51553: LD_EXP 85
51557: PUSH
51558: LD_VAR 0 3
51562: ARRAY
51563: IN
51564: IFFALSE 52187
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51566: LD_ADDR_EXP 85
51570: PUSH
51571: LD_EXP 85
51575: PPUSH
51576: LD_VAR 0 3
51580: PPUSH
51581: LD_EXP 85
51585: PUSH
51586: LD_VAR 0 3
51590: ARRAY
51591: PUSH
51592: LD_VAR 0 1
51596: DIFF
51597: PPUSH
51598: CALL_OW 1
51602: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51603: LD_ADDR_EXP 78
51607: PUSH
51608: LD_EXP 78
51612: PPUSH
51613: LD_VAR 0 3
51617: PUSH
51618: LD_EXP 78
51622: PUSH
51623: LD_VAR 0 3
51627: ARRAY
51628: PUSH
51629: LD_INT 1
51631: PLUS
51632: PUSH
51633: EMPTY
51634: LIST
51635: LIST
51636: PPUSH
51637: LD_VAR 0 1
51641: PPUSH
51642: CALL 57810 0 3
51646: ST_TO_ADDR
// btype := GetBType ( building ) ;
51647: LD_ADDR_VAR 0 5
51651: PUSH
51652: LD_VAR 0 1
51656: PPUSH
51657: CALL_OW 266
51661: ST_TO_ADDR
// side := GetSide ( building ) ;
51662: LD_ADDR_VAR 0 8
51666: PUSH
51667: LD_VAR 0 1
51671: PPUSH
51672: CALL_OW 255
51676: ST_TO_ADDR
// if btype = b_lab then
51677: LD_VAR 0 5
51681: PUSH
51682: LD_INT 6
51684: EQUAL
51685: IFFALSE 51735
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
51687: LD_ADDR_EXP 111
51691: PUSH
51692: LD_EXP 111
51696: PPUSH
51697: LD_VAR 0 3
51701: PUSH
51702: LD_EXP 111
51706: PUSH
51707: LD_VAR 0 3
51711: ARRAY
51712: PUSH
51713: LD_INT 1
51715: PLUS
51716: PUSH
51717: EMPTY
51718: LIST
51719: LIST
51720: PPUSH
51721: LD_VAR 0 1
51725: PPUSH
51726: CALL 57810 0 3
51730: ST_TO_ADDR
// exit ;
51731: POP
51732: POP
51733: GO 52191
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
51735: LD_VAR 0 5
51739: PUSH
51740: LD_INT 0
51742: PUSH
51743: LD_INT 2
51745: PUSH
51746: LD_INT 4
51748: PUSH
51749: EMPTY
51750: LIST
51751: LIST
51752: LIST
51753: IN
51754: IFFALSE 51878
// begin if btype = b_armoury then
51756: LD_VAR 0 5
51760: PUSH
51761: LD_INT 4
51763: EQUAL
51764: IFFALSE 51774
// btype := b_barracks ;
51766: LD_ADDR_VAR 0 5
51770: PUSH
51771: LD_INT 5
51773: ST_TO_ADDR
// if btype = b_depot then
51774: LD_VAR 0 5
51778: PUSH
51779: LD_INT 0
51781: EQUAL
51782: IFFALSE 51792
// btype := b_warehouse ;
51784: LD_ADDR_VAR 0 5
51788: PUSH
51789: LD_INT 1
51791: ST_TO_ADDR
// if btype = b_workshop then
51792: LD_VAR 0 5
51796: PUSH
51797: LD_INT 2
51799: EQUAL
51800: IFFALSE 51810
// btype := b_factory ;
51802: LD_ADDR_VAR 0 5
51806: PUSH
51807: LD_INT 3
51809: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
51810: LD_VAR 0 5
51814: PPUSH
51815: LD_VAR 0 8
51819: PPUSH
51820: CALL_OW 323
51824: PUSH
51825: LD_INT 1
51827: EQUAL
51828: IFFALSE 51874
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51830: LD_ADDR_EXP 110
51834: PUSH
51835: LD_EXP 110
51839: PPUSH
51840: LD_VAR 0 3
51844: PUSH
51845: LD_EXP 110
51849: PUSH
51850: LD_VAR 0 3
51854: ARRAY
51855: PUSH
51856: LD_INT 1
51858: PLUS
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: PPUSH
51864: LD_VAR 0 1
51868: PPUSH
51869: CALL 57810 0 3
51873: ST_TO_ADDR
// exit ;
51874: POP
51875: POP
51876: GO 52191
// end ; if btype in [ b_bunker , b_turret ] then
51878: LD_VAR 0 5
51882: PUSH
51883: LD_INT 32
51885: PUSH
51886: LD_INT 33
51888: PUSH
51889: EMPTY
51890: LIST
51891: LIST
51892: IN
51893: IFFALSE 52183
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51895: LD_ADDR_EXP 86
51899: PUSH
51900: LD_EXP 86
51904: PPUSH
51905: LD_VAR 0 3
51909: PUSH
51910: LD_EXP 86
51914: PUSH
51915: LD_VAR 0 3
51919: ARRAY
51920: PUSH
51921: LD_INT 1
51923: PLUS
51924: PUSH
51925: EMPTY
51926: LIST
51927: LIST
51928: PPUSH
51929: LD_VAR 0 1
51933: PPUSH
51934: CALL 57810 0 3
51938: ST_TO_ADDR
// if btype = b_bunker then
51939: LD_VAR 0 5
51943: PUSH
51944: LD_INT 32
51946: EQUAL
51947: IFFALSE 52183
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51949: LD_ADDR_EXP 87
51953: PUSH
51954: LD_EXP 87
51958: PPUSH
51959: LD_VAR 0 3
51963: PUSH
51964: LD_EXP 87
51968: PUSH
51969: LD_VAR 0 3
51973: ARRAY
51974: PUSH
51975: LD_INT 1
51977: PLUS
51978: PUSH
51979: EMPTY
51980: LIST
51981: LIST
51982: PPUSH
51983: LD_VAR 0 1
51987: PPUSH
51988: CALL 57810 0 3
51992: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51993: LD_ADDR_VAR 0 6
51997: PUSH
51998: LD_EXP 78
52002: PUSH
52003: LD_VAR 0 3
52007: ARRAY
52008: PPUSH
52009: LD_INT 25
52011: PUSH
52012: LD_INT 1
52014: PUSH
52015: EMPTY
52016: LIST
52017: LIST
52018: PUSH
52019: LD_INT 3
52021: PUSH
52022: LD_INT 54
52024: PUSH
52025: EMPTY
52026: LIST
52027: PUSH
52028: EMPTY
52029: LIST
52030: LIST
52031: PUSH
52032: EMPTY
52033: LIST
52034: LIST
52035: PPUSH
52036: CALL_OW 72
52040: ST_TO_ADDR
// if tmp then
52041: LD_VAR 0 6
52045: IFFALSE 52051
// exit ;
52047: POP
52048: POP
52049: GO 52191
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52051: LD_ADDR_VAR 0 6
52055: PUSH
52056: LD_EXP 78
52060: PUSH
52061: LD_VAR 0 3
52065: ARRAY
52066: PPUSH
52067: LD_INT 2
52069: PUSH
52070: LD_INT 30
52072: PUSH
52073: LD_INT 4
52075: PUSH
52076: EMPTY
52077: LIST
52078: LIST
52079: PUSH
52080: LD_INT 30
52082: PUSH
52083: LD_INT 5
52085: PUSH
52086: EMPTY
52087: LIST
52088: LIST
52089: PUSH
52090: EMPTY
52091: LIST
52092: LIST
52093: LIST
52094: PPUSH
52095: CALL_OW 72
52099: ST_TO_ADDR
// if not tmp then
52100: LD_VAR 0 6
52104: NOT
52105: IFFALSE 52111
// exit ;
52107: POP
52108: POP
52109: GO 52191
// for j in tmp do
52111: LD_ADDR_VAR 0 4
52115: PUSH
52116: LD_VAR 0 6
52120: PUSH
52121: FOR_IN
52122: IFFALSE 52181
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
52124: LD_ADDR_VAR 0 7
52128: PUSH
52129: LD_VAR 0 4
52133: PPUSH
52134: CALL_OW 313
52138: PPUSH
52139: LD_INT 25
52141: PUSH
52142: LD_INT 1
52144: PUSH
52145: EMPTY
52146: LIST
52147: LIST
52148: PPUSH
52149: CALL_OW 72
52153: ST_TO_ADDR
// if units then
52154: LD_VAR 0 7
52158: IFFALSE 52179
// begin ComExitBuilding ( units [ 1 ] ) ;
52160: LD_VAR 0 7
52164: PUSH
52165: LD_INT 1
52167: ARRAY
52168: PPUSH
52169: CALL_OW 122
// exit ;
52173: POP
52174: POP
52175: POP
52176: POP
52177: GO 52191
// end ; end ;
52179: GO 52121
52181: POP
52182: POP
// end ; end ; exit ;
52183: POP
52184: POP
52185: GO 52191
// end ; end ;
52187: GO 51545
52189: POP
52190: POP
// end ;
52191: LD_VAR 0 2
52195: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
52196: LD_INT 0
52198: PPUSH
52199: PPUSH
52200: PPUSH
52201: PPUSH
52202: PPUSH
52203: PPUSH
52204: PPUSH
// if not mc_bases or not skirmish then
52205: LD_EXP 78
52209: NOT
52210: PUSH
52211: LD_EXP 76
52215: NOT
52216: OR
52217: IFFALSE 52221
// exit ;
52219: GO 52486
// btype := GetBType ( building ) ;
52221: LD_ADDR_VAR 0 6
52225: PUSH
52226: LD_VAR 0 1
52230: PPUSH
52231: CALL_OW 266
52235: ST_TO_ADDR
// x := GetX ( building ) ;
52236: LD_ADDR_VAR 0 7
52240: PUSH
52241: LD_VAR 0 1
52245: PPUSH
52246: CALL_OW 250
52250: ST_TO_ADDR
// y := GetY ( building ) ;
52251: LD_ADDR_VAR 0 8
52255: PUSH
52256: LD_VAR 0 1
52260: PPUSH
52261: CALL_OW 251
52265: ST_TO_ADDR
// d := GetDir ( building ) ;
52266: LD_ADDR_VAR 0 9
52270: PUSH
52271: LD_VAR 0 1
52275: PPUSH
52276: CALL_OW 254
52280: ST_TO_ADDR
// for i = 1 to mc_bases do
52281: LD_ADDR_VAR 0 4
52285: PUSH
52286: DOUBLE
52287: LD_INT 1
52289: DEC
52290: ST_TO_ADDR
52291: LD_EXP 78
52295: PUSH
52296: FOR_TO
52297: IFFALSE 52484
// begin if not mc_build_list [ i ] then
52299: LD_EXP 83
52303: PUSH
52304: LD_VAR 0 4
52308: ARRAY
52309: NOT
52310: IFFALSE 52314
// continue ;
52312: GO 52296
// for j := 1 to mc_build_list [ i ] do
52314: LD_ADDR_VAR 0 5
52318: PUSH
52319: DOUBLE
52320: LD_INT 1
52322: DEC
52323: ST_TO_ADDR
52324: LD_EXP 83
52328: PUSH
52329: LD_VAR 0 4
52333: ARRAY
52334: PUSH
52335: FOR_TO
52336: IFFALSE 52480
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
52338: LD_VAR 0 6
52342: PUSH
52343: LD_VAR 0 7
52347: PUSH
52348: LD_VAR 0 8
52352: PUSH
52353: LD_VAR 0 9
52357: PUSH
52358: EMPTY
52359: LIST
52360: LIST
52361: LIST
52362: LIST
52363: PPUSH
52364: LD_EXP 83
52368: PUSH
52369: LD_VAR 0 4
52373: ARRAY
52374: PUSH
52375: LD_VAR 0 5
52379: ARRAY
52380: PPUSH
52381: CALL 63990 0 2
52385: IFFALSE 52478
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
52387: LD_ADDR_EXP 83
52391: PUSH
52392: LD_EXP 83
52396: PPUSH
52397: LD_VAR 0 4
52401: PPUSH
52402: LD_EXP 83
52406: PUSH
52407: LD_VAR 0 4
52411: ARRAY
52412: PPUSH
52413: LD_VAR 0 5
52417: PPUSH
52418: CALL_OW 3
52422: PPUSH
52423: CALL_OW 1
52427: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
52428: LD_ADDR_EXP 85
52432: PUSH
52433: LD_EXP 85
52437: PPUSH
52438: LD_VAR 0 4
52442: PUSH
52443: LD_EXP 85
52447: PUSH
52448: LD_VAR 0 4
52452: ARRAY
52453: PUSH
52454: LD_INT 1
52456: PLUS
52457: PUSH
52458: EMPTY
52459: LIST
52460: LIST
52461: PPUSH
52462: LD_VAR 0 1
52466: PPUSH
52467: CALL 57810 0 3
52471: ST_TO_ADDR
// exit ;
52472: POP
52473: POP
52474: POP
52475: POP
52476: GO 52486
// end ;
52478: GO 52335
52480: POP
52481: POP
// end ;
52482: GO 52296
52484: POP
52485: POP
// end ;
52486: LD_VAR 0 3
52490: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
52491: LD_INT 0
52493: PPUSH
52494: PPUSH
52495: PPUSH
// if not mc_bases or not skirmish then
52496: LD_EXP 78
52500: NOT
52501: PUSH
52502: LD_EXP 76
52506: NOT
52507: OR
52508: IFFALSE 52512
// exit ;
52510: GO 52702
// for i = 1 to mc_bases do
52512: LD_ADDR_VAR 0 4
52516: PUSH
52517: DOUBLE
52518: LD_INT 1
52520: DEC
52521: ST_TO_ADDR
52522: LD_EXP 78
52526: PUSH
52527: FOR_TO
52528: IFFALSE 52615
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
52530: LD_VAR 0 1
52534: PUSH
52535: LD_EXP 86
52539: PUSH
52540: LD_VAR 0 4
52544: ARRAY
52545: IN
52546: PUSH
52547: LD_VAR 0 1
52551: PUSH
52552: LD_EXP 87
52556: PUSH
52557: LD_VAR 0 4
52561: ARRAY
52562: IN
52563: NOT
52564: AND
52565: IFFALSE 52613
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52567: LD_ADDR_EXP 87
52571: PUSH
52572: LD_EXP 87
52576: PPUSH
52577: LD_VAR 0 4
52581: PUSH
52582: LD_EXP 87
52586: PUSH
52587: LD_VAR 0 4
52591: ARRAY
52592: PUSH
52593: LD_INT 1
52595: PLUS
52596: PUSH
52597: EMPTY
52598: LIST
52599: LIST
52600: PPUSH
52601: LD_VAR 0 1
52605: PPUSH
52606: CALL 57810 0 3
52610: ST_TO_ADDR
// break ;
52611: GO 52615
// end ; end ;
52613: GO 52527
52615: POP
52616: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
52617: LD_VAR 0 1
52621: PPUSH
52622: CALL_OW 257
52626: PUSH
52627: LD_EXP 104
52631: IN
52632: PUSH
52633: LD_VAR 0 1
52637: PPUSH
52638: CALL_OW 266
52642: PUSH
52643: LD_INT 5
52645: EQUAL
52646: AND
52647: PUSH
52648: LD_VAR 0 2
52652: PPUSH
52653: CALL_OW 110
52657: PUSH
52658: LD_INT 18
52660: NONEQUAL
52661: AND
52662: IFFALSE 52702
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
52664: LD_VAR 0 2
52668: PPUSH
52669: CALL_OW 257
52673: PUSH
52674: LD_INT 5
52676: PUSH
52677: LD_INT 8
52679: PUSH
52680: LD_INT 9
52682: PUSH
52683: EMPTY
52684: LIST
52685: LIST
52686: LIST
52687: IN
52688: IFFALSE 52702
// SetClass ( unit , 1 ) ;
52690: LD_VAR 0 2
52694: PPUSH
52695: LD_INT 1
52697: PPUSH
52698: CALL_OW 336
// end ;
52702: LD_VAR 0 3
52706: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
52707: LD_INT 0
52709: PPUSH
52710: PPUSH
// if not mc_bases or not skirmish then
52711: LD_EXP 78
52715: NOT
52716: PUSH
52717: LD_EXP 76
52721: NOT
52722: OR
52723: IFFALSE 52727
// exit ;
52725: GO 52843
// if GetLives ( abandoned_vehicle ) > 250 then
52727: LD_VAR 0 2
52731: PPUSH
52732: CALL_OW 256
52736: PUSH
52737: LD_INT 250
52739: GREATER
52740: IFFALSE 52744
// exit ;
52742: GO 52843
// for i = 1 to mc_bases do
52744: LD_ADDR_VAR 0 6
52748: PUSH
52749: DOUBLE
52750: LD_INT 1
52752: DEC
52753: ST_TO_ADDR
52754: LD_EXP 78
52758: PUSH
52759: FOR_TO
52760: IFFALSE 52841
// begin if driver in mc_bases [ i ] then
52762: LD_VAR 0 1
52766: PUSH
52767: LD_EXP 78
52771: PUSH
52772: LD_VAR 0 6
52776: ARRAY
52777: IN
52778: IFFALSE 52839
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
52780: LD_VAR 0 1
52784: PPUSH
52785: LD_EXP 78
52789: PUSH
52790: LD_VAR 0 6
52794: ARRAY
52795: PPUSH
52796: LD_INT 2
52798: PUSH
52799: LD_INT 30
52801: PUSH
52802: LD_INT 0
52804: PUSH
52805: EMPTY
52806: LIST
52807: LIST
52808: PUSH
52809: LD_INT 30
52811: PUSH
52812: LD_INT 1
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: LIST
52823: PPUSH
52824: CALL_OW 72
52828: PUSH
52829: LD_INT 1
52831: ARRAY
52832: PPUSH
52833: CALL 91017 0 2
// break ;
52837: GO 52841
// end ; end ;
52839: GO 52759
52841: POP
52842: POP
// end ; end_of_file
52843: LD_VAR 0 5
52847: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52848: LD_INT 0
52850: PPUSH
52851: PPUSH
// if exist_mode then
52852: LD_VAR 0 2
52856: IFFALSE 52881
// unit := CreateCharacter ( prefix & ident ) else
52858: LD_ADDR_VAR 0 5
52862: PUSH
52863: LD_VAR 0 3
52867: PUSH
52868: LD_VAR 0 1
52872: STR
52873: PPUSH
52874: CALL_OW 34
52878: ST_TO_ADDR
52879: GO 52896
// unit := NewCharacter ( ident ) ;
52881: LD_ADDR_VAR 0 5
52885: PUSH
52886: LD_VAR 0 1
52890: PPUSH
52891: CALL_OW 25
52895: ST_TO_ADDR
// result := unit ;
52896: LD_ADDR_VAR 0 4
52900: PUSH
52901: LD_VAR 0 5
52905: ST_TO_ADDR
// end ;
52906: LD_VAR 0 4
52910: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52911: LD_INT 0
52913: PPUSH
52914: PPUSH
// if not side or not nation then
52915: LD_VAR 0 1
52919: NOT
52920: PUSH
52921: LD_VAR 0 2
52925: NOT
52926: OR
52927: IFFALSE 52931
// exit ;
52929: GO 53699
// case nation of nation_american :
52931: LD_VAR 0 2
52935: PUSH
52936: LD_INT 1
52938: DOUBLE
52939: EQUAL
52940: IFTRUE 52944
52942: GO 53158
52944: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52945: LD_ADDR_VAR 0 4
52949: PUSH
52950: LD_INT 35
52952: PUSH
52953: LD_INT 45
52955: PUSH
52956: LD_INT 46
52958: PUSH
52959: LD_INT 47
52961: PUSH
52962: LD_INT 82
52964: PUSH
52965: LD_INT 83
52967: PUSH
52968: LD_INT 84
52970: PUSH
52971: LD_INT 85
52973: PUSH
52974: LD_INT 86
52976: PUSH
52977: LD_INT 1
52979: PUSH
52980: LD_INT 2
52982: PUSH
52983: LD_INT 6
52985: PUSH
52986: LD_INT 15
52988: PUSH
52989: LD_INT 16
52991: PUSH
52992: LD_INT 7
52994: PUSH
52995: LD_INT 12
52997: PUSH
52998: LD_INT 13
53000: PUSH
53001: LD_INT 10
53003: PUSH
53004: LD_INT 14
53006: PUSH
53007: LD_INT 20
53009: PUSH
53010: LD_INT 21
53012: PUSH
53013: LD_INT 22
53015: PUSH
53016: LD_INT 25
53018: PUSH
53019: LD_INT 32
53021: PUSH
53022: LD_INT 27
53024: PUSH
53025: LD_INT 36
53027: PUSH
53028: LD_INT 69
53030: PUSH
53031: LD_INT 39
53033: PUSH
53034: LD_INT 34
53036: PUSH
53037: LD_INT 40
53039: PUSH
53040: LD_INT 48
53042: PUSH
53043: LD_INT 49
53045: PUSH
53046: LD_INT 50
53048: PUSH
53049: LD_INT 51
53051: PUSH
53052: LD_INT 52
53054: PUSH
53055: LD_INT 53
53057: PUSH
53058: LD_INT 54
53060: PUSH
53061: LD_INT 55
53063: PUSH
53064: LD_INT 56
53066: PUSH
53067: LD_INT 57
53069: PUSH
53070: LD_INT 58
53072: PUSH
53073: LD_INT 59
53075: PUSH
53076: LD_INT 60
53078: PUSH
53079: LD_INT 61
53081: PUSH
53082: LD_INT 62
53084: PUSH
53085: LD_INT 80
53087: PUSH
53088: LD_INT 82
53090: PUSH
53091: LD_INT 83
53093: PUSH
53094: LD_INT 84
53096: PUSH
53097: LD_INT 85
53099: PUSH
53100: LD_INT 86
53102: PUSH
53103: EMPTY
53104: LIST
53105: LIST
53106: LIST
53107: LIST
53108: LIST
53109: LIST
53110: LIST
53111: LIST
53112: LIST
53113: LIST
53114: LIST
53115: LIST
53116: LIST
53117: LIST
53118: LIST
53119: LIST
53120: LIST
53121: LIST
53122: LIST
53123: LIST
53124: LIST
53125: LIST
53126: LIST
53127: LIST
53128: LIST
53129: LIST
53130: LIST
53131: LIST
53132: LIST
53133: LIST
53134: LIST
53135: LIST
53136: LIST
53137: LIST
53138: LIST
53139: LIST
53140: LIST
53141: LIST
53142: LIST
53143: LIST
53144: LIST
53145: LIST
53146: LIST
53147: LIST
53148: LIST
53149: LIST
53150: LIST
53151: LIST
53152: LIST
53153: LIST
53154: LIST
53155: ST_TO_ADDR
53156: GO 53623
53158: LD_INT 2
53160: DOUBLE
53161: EQUAL
53162: IFTRUE 53166
53164: GO 53392
53166: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
53167: LD_ADDR_VAR 0 4
53171: PUSH
53172: LD_INT 35
53174: PUSH
53175: LD_INT 45
53177: PUSH
53178: LD_INT 46
53180: PUSH
53181: LD_INT 47
53183: PUSH
53184: LD_INT 82
53186: PUSH
53187: LD_INT 83
53189: PUSH
53190: LD_INT 84
53192: PUSH
53193: LD_INT 85
53195: PUSH
53196: LD_INT 87
53198: PUSH
53199: LD_INT 70
53201: PUSH
53202: LD_INT 1
53204: PUSH
53205: LD_INT 11
53207: PUSH
53208: LD_INT 3
53210: PUSH
53211: LD_INT 4
53213: PUSH
53214: LD_INT 5
53216: PUSH
53217: LD_INT 6
53219: PUSH
53220: LD_INT 15
53222: PUSH
53223: LD_INT 18
53225: PUSH
53226: LD_INT 7
53228: PUSH
53229: LD_INT 17
53231: PUSH
53232: LD_INT 8
53234: PUSH
53235: LD_INT 20
53237: PUSH
53238: LD_INT 21
53240: PUSH
53241: LD_INT 22
53243: PUSH
53244: LD_INT 72
53246: PUSH
53247: LD_INT 26
53249: PUSH
53250: LD_INT 69
53252: PUSH
53253: LD_INT 39
53255: PUSH
53256: LD_INT 40
53258: PUSH
53259: LD_INT 41
53261: PUSH
53262: LD_INT 42
53264: PUSH
53265: LD_INT 43
53267: PUSH
53268: LD_INT 48
53270: PUSH
53271: LD_INT 49
53273: PUSH
53274: LD_INT 50
53276: PUSH
53277: LD_INT 51
53279: PUSH
53280: LD_INT 52
53282: PUSH
53283: LD_INT 53
53285: PUSH
53286: LD_INT 54
53288: PUSH
53289: LD_INT 55
53291: PUSH
53292: LD_INT 56
53294: PUSH
53295: LD_INT 60
53297: PUSH
53298: LD_INT 61
53300: PUSH
53301: LD_INT 62
53303: PUSH
53304: LD_INT 66
53306: PUSH
53307: LD_INT 67
53309: PUSH
53310: LD_INT 68
53312: PUSH
53313: LD_INT 81
53315: PUSH
53316: LD_INT 82
53318: PUSH
53319: LD_INT 83
53321: PUSH
53322: LD_INT 84
53324: PUSH
53325: LD_INT 85
53327: PUSH
53328: LD_INT 87
53330: PUSH
53331: LD_INT 88
53333: PUSH
53334: EMPTY
53335: LIST
53336: LIST
53337: LIST
53338: LIST
53339: LIST
53340: LIST
53341: LIST
53342: LIST
53343: LIST
53344: LIST
53345: LIST
53346: LIST
53347: LIST
53348: LIST
53349: LIST
53350: LIST
53351: LIST
53352: LIST
53353: LIST
53354: LIST
53355: LIST
53356: LIST
53357: LIST
53358: LIST
53359: LIST
53360: LIST
53361: LIST
53362: LIST
53363: LIST
53364: LIST
53365: LIST
53366: LIST
53367: LIST
53368: LIST
53369: LIST
53370: LIST
53371: LIST
53372: LIST
53373: LIST
53374: LIST
53375: LIST
53376: LIST
53377: LIST
53378: LIST
53379: LIST
53380: LIST
53381: LIST
53382: LIST
53383: LIST
53384: LIST
53385: LIST
53386: LIST
53387: LIST
53388: LIST
53389: ST_TO_ADDR
53390: GO 53623
53392: LD_INT 3
53394: DOUBLE
53395: EQUAL
53396: IFTRUE 53400
53398: GO 53622
53400: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
53401: LD_ADDR_VAR 0 4
53405: PUSH
53406: LD_INT 46
53408: PUSH
53409: LD_INT 47
53411: PUSH
53412: LD_INT 1
53414: PUSH
53415: LD_INT 2
53417: PUSH
53418: LD_INT 82
53420: PUSH
53421: LD_INT 83
53423: PUSH
53424: LD_INT 84
53426: PUSH
53427: LD_INT 85
53429: PUSH
53430: LD_INT 86
53432: PUSH
53433: LD_INT 11
53435: PUSH
53436: LD_INT 9
53438: PUSH
53439: LD_INT 20
53441: PUSH
53442: LD_INT 19
53444: PUSH
53445: LD_INT 21
53447: PUSH
53448: LD_INT 24
53450: PUSH
53451: LD_INT 22
53453: PUSH
53454: LD_INT 25
53456: PUSH
53457: LD_INT 28
53459: PUSH
53460: LD_INT 29
53462: PUSH
53463: LD_INT 30
53465: PUSH
53466: LD_INT 31
53468: PUSH
53469: LD_INT 37
53471: PUSH
53472: LD_INT 38
53474: PUSH
53475: LD_INT 32
53477: PUSH
53478: LD_INT 27
53480: PUSH
53481: LD_INT 33
53483: PUSH
53484: LD_INT 69
53486: PUSH
53487: LD_INT 39
53489: PUSH
53490: LD_INT 34
53492: PUSH
53493: LD_INT 40
53495: PUSH
53496: LD_INT 71
53498: PUSH
53499: LD_INT 23
53501: PUSH
53502: LD_INT 44
53504: PUSH
53505: LD_INT 48
53507: PUSH
53508: LD_INT 49
53510: PUSH
53511: LD_INT 50
53513: PUSH
53514: LD_INT 51
53516: PUSH
53517: LD_INT 52
53519: PUSH
53520: LD_INT 53
53522: PUSH
53523: LD_INT 54
53525: PUSH
53526: LD_INT 55
53528: PUSH
53529: LD_INT 56
53531: PUSH
53532: LD_INT 57
53534: PUSH
53535: LD_INT 58
53537: PUSH
53538: LD_INT 59
53540: PUSH
53541: LD_INT 63
53543: PUSH
53544: LD_INT 64
53546: PUSH
53547: LD_INT 65
53549: PUSH
53550: LD_INT 82
53552: PUSH
53553: LD_INT 83
53555: PUSH
53556: LD_INT 84
53558: PUSH
53559: LD_INT 85
53561: PUSH
53562: LD_INT 86
53564: PUSH
53565: EMPTY
53566: LIST
53567: LIST
53568: LIST
53569: LIST
53570: LIST
53571: LIST
53572: LIST
53573: LIST
53574: LIST
53575: LIST
53576: LIST
53577: LIST
53578: LIST
53579: LIST
53580: LIST
53581: LIST
53582: LIST
53583: LIST
53584: LIST
53585: LIST
53586: LIST
53587: LIST
53588: LIST
53589: LIST
53590: LIST
53591: LIST
53592: LIST
53593: LIST
53594: LIST
53595: LIST
53596: LIST
53597: LIST
53598: LIST
53599: LIST
53600: LIST
53601: LIST
53602: LIST
53603: LIST
53604: LIST
53605: LIST
53606: LIST
53607: LIST
53608: LIST
53609: LIST
53610: LIST
53611: LIST
53612: LIST
53613: LIST
53614: LIST
53615: LIST
53616: LIST
53617: LIST
53618: LIST
53619: ST_TO_ADDR
53620: GO 53623
53622: POP
// if state > - 1 and state < 3 then
53623: LD_VAR 0 3
53627: PUSH
53628: LD_INT 1
53630: NEG
53631: GREATER
53632: PUSH
53633: LD_VAR 0 3
53637: PUSH
53638: LD_INT 3
53640: LESS
53641: AND
53642: IFFALSE 53699
// for i in result do
53644: LD_ADDR_VAR 0 5
53648: PUSH
53649: LD_VAR 0 4
53653: PUSH
53654: FOR_IN
53655: IFFALSE 53697
// if GetTech ( i , side ) <> state then
53657: LD_VAR 0 5
53661: PPUSH
53662: LD_VAR 0 1
53666: PPUSH
53667: CALL_OW 321
53671: PUSH
53672: LD_VAR 0 3
53676: NONEQUAL
53677: IFFALSE 53695
// result := result diff i ;
53679: LD_ADDR_VAR 0 4
53683: PUSH
53684: LD_VAR 0 4
53688: PUSH
53689: LD_VAR 0 5
53693: DIFF
53694: ST_TO_ADDR
53695: GO 53654
53697: POP
53698: POP
// end ;
53699: LD_VAR 0 4
53703: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
53704: LD_INT 0
53706: PPUSH
53707: PPUSH
53708: PPUSH
// result := true ;
53709: LD_ADDR_VAR 0 3
53713: PUSH
53714: LD_INT 1
53716: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
53717: LD_ADDR_VAR 0 5
53721: PUSH
53722: LD_VAR 0 2
53726: PPUSH
53727: CALL_OW 480
53731: ST_TO_ADDR
// if not tmp then
53732: LD_VAR 0 5
53736: NOT
53737: IFFALSE 53741
// exit ;
53739: GO 53790
// for i in tmp do
53741: LD_ADDR_VAR 0 4
53745: PUSH
53746: LD_VAR 0 5
53750: PUSH
53751: FOR_IN
53752: IFFALSE 53788
// if GetTech ( i , side ) <> state_researched then
53754: LD_VAR 0 4
53758: PPUSH
53759: LD_VAR 0 1
53763: PPUSH
53764: CALL_OW 321
53768: PUSH
53769: LD_INT 2
53771: NONEQUAL
53772: IFFALSE 53786
// begin result := false ;
53774: LD_ADDR_VAR 0 3
53778: PUSH
53779: LD_INT 0
53781: ST_TO_ADDR
// exit ;
53782: POP
53783: POP
53784: GO 53790
// end ;
53786: GO 53751
53788: POP
53789: POP
// end ;
53790: LD_VAR 0 3
53794: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
53795: LD_INT 0
53797: PPUSH
53798: PPUSH
53799: PPUSH
53800: PPUSH
53801: PPUSH
53802: PPUSH
53803: PPUSH
53804: PPUSH
53805: PPUSH
53806: PPUSH
53807: PPUSH
53808: PPUSH
53809: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
53810: LD_VAR 0 1
53814: NOT
53815: PUSH
53816: LD_VAR 0 1
53820: PPUSH
53821: CALL_OW 257
53825: PUSH
53826: LD_INT 9
53828: NONEQUAL
53829: OR
53830: IFFALSE 53834
// exit ;
53832: GO 54407
// side := GetSide ( unit ) ;
53834: LD_ADDR_VAR 0 9
53838: PUSH
53839: LD_VAR 0 1
53843: PPUSH
53844: CALL_OW 255
53848: ST_TO_ADDR
// tech_space := tech_spacanom ;
53849: LD_ADDR_VAR 0 12
53853: PUSH
53854: LD_INT 29
53856: ST_TO_ADDR
// tech_time := tech_taurad ;
53857: LD_ADDR_VAR 0 13
53861: PUSH
53862: LD_INT 28
53864: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53865: LD_ADDR_VAR 0 11
53869: PUSH
53870: LD_VAR 0 1
53874: PPUSH
53875: CALL_OW 310
53879: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53880: LD_VAR 0 11
53884: PPUSH
53885: CALL_OW 247
53889: PUSH
53890: LD_INT 2
53892: EQUAL
53893: IFFALSE 53897
// exit ;
53895: GO 54407
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53897: LD_ADDR_VAR 0 8
53901: PUSH
53902: LD_INT 81
53904: PUSH
53905: LD_VAR 0 9
53909: PUSH
53910: EMPTY
53911: LIST
53912: LIST
53913: PUSH
53914: LD_INT 3
53916: PUSH
53917: LD_INT 21
53919: PUSH
53920: LD_INT 3
53922: PUSH
53923: EMPTY
53924: LIST
53925: LIST
53926: PUSH
53927: EMPTY
53928: LIST
53929: LIST
53930: PUSH
53931: EMPTY
53932: LIST
53933: LIST
53934: PPUSH
53935: CALL_OW 69
53939: ST_TO_ADDR
// if not tmp then
53940: LD_VAR 0 8
53944: NOT
53945: IFFALSE 53949
// exit ;
53947: GO 54407
// if in_unit then
53949: LD_VAR 0 11
53953: IFFALSE 53977
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53955: LD_ADDR_VAR 0 10
53959: PUSH
53960: LD_VAR 0 8
53964: PPUSH
53965: LD_VAR 0 11
53969: PPUSH
53970: CALL_OW 74
53974: ST_TO_ADDR
53975: GO 53997
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53977: LD_ADDR_VAR 0 10
53981: PUSH
53982: LD_VAR 0 8
53986: PPUSH
53987: LD_VAR 0 1
53991: PPUSH
53992: CALL_OW 74
53996: ST_TO_ADDR
// if not enemy then
53997: LD_VAR 0 10
54001: NOT
54002: IFFALSE 54006
// exit ;
54004: GO 54407
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54006: LD_VAR 0 11
54010: PUSH
54011: LD_VAR 0 11
54015: PPUSH
54016: LD_VAR 0 10
54020: PPUSH
54021: CALL_OW 296
54025: PUSH
54026: LD_INT 13
54028: GREATER
54029: AND
54030: PUSH
54031: LD_VAR 0 1
54035: PPUSH
54036: LD_VAR 0 10
54040: PPUSH
54041: CALL_OW 296
54045: PUSH
54046: LD_INT 12
54048: GREATER
54049: OR
54050: IFFALSE 54054
// exit ;
54052: GO 54407
// missile := [ 1 ] ;
54054: LD_ADDR_VAR 0 14
54058: PUSH
54059: LD_INT 1
54061: PUSH
54062: EMPTY
54063: LIST
54064: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54065: LD_VAR 0 9
54069: PPUSH
54070: LD_VAR 0 12
54074: PPUSH
54075: CALL_OW 325
54079: IFFALSE 54108
// missile := Replace ( missile , missile + 1 , 2 ) ;
54081: LD_ADDR_VAR 0 14
54085: PUSH
54086: LD_VAR 0 14
54090: PPUSH
54091: LD_VAR 0 14
54095: PUSH
54096: LD_INT 1
54098: PLUS
54099: PPUSH
54100: LD_INT 2
54102: PPUSH
54103: CALL_OW 1
54107: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54108: LD_VAR 0 9
54112: PPUSH
54113: LD_VAR 0 13
54117: PPUSH
54118: CALL_OW 325
54122: PUSH
54123: LD_VAR 0 10
54127: PPUSH
54128: CALL_OW 255
54132: PPUSH
54133: LD_VAR 0 13
54137: PPUSH
54138: CALL_OW 325
54142: NOT
54143: AND
54144: IFFALSE 54173
// missile := Replace ( missile , missile + 1 , 3 ) ;
54146: LD_ADDR_VAR 0 14
54150: PUSH
54151: LD_VAR 0 14
54155: PPUSH
54156: LD_VAR 0 14
54160: PUSH
54161: LD_INT 1
54163: PLUS
54164: PPUSH
54165: LD_INT 3
54167: PPUSH
54168: CALL_OW 1
54172: ST_TO_ADDR
// if missile < 2 then
54173: LD_VAR 0 14
54177: PUSH
54178: LD_INT 2
54180: LESS
54181: IFFALSE 54185
// exit ;
54183: GO 54407
// x := GetX ( enemy ) ;
54185: LD_ADDR_VAR 0 4
54189: PUSH
54190: LD_VAR 0 10
54194: PPUSH
54195: CALL_OW 250
54199: ST_TO_ADDR
// y := GetY ( enemy ) ;
54200: LD_ADDR_VAR 0 5
54204: PUSH
54205: LD_VAR 0 10
54209: PPUSH
54210: CALL_OW 251
54214: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
54215: LD_ADDR_VAR 0 6
54219: PUSH
54220: LD_VAR 0 4
54224: PUSH
54225: LD_INT 1
54227: NEG
54228: PPUSH
54229: LD_INT 1
54231: PPUSH
54232: CALL_OW 12
54236: PLUS
54237: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
54238: LD_ADDR_VAR 0 7
54242: PUSH
54243: LD_VAR 0 5
54247: PUSH
54248: LD_INT 1
54250: NEG
54251: PPUSH
54252: LD_INT 1
54254: PPUSH
54255: CALL_OW 12
54259: PLUS
54260: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54261: LD_VAR 0 6
54265: PPUSH
54266: LD_VAR 0 7
54270: PPUSH
54271: CALL_OW 488
54275: NOT
54276: IFFALSE 54298
// begin _x := x ;
54278: LD_ADDR_VAR 0 6
54282: PUSH
54283: LD_VAR 0 4
54287: ST_TO_ADDR
// _y := y ;
54288: LD_ADDR_VAR 0 7
54292: PUSH
54293: LD_VAR 0 5
54297: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
54298: LD_ADDR_VAR 0 3
54302: PUSH
54303: LD_INT 1
54305: PPUSH
54306: LD_VAR 0 14
54310: PPUSH
54311: CALL_OW 12
54315: ST_TO_ADDR
// case i of 1 :
54316: LD_VAR 0 3
54320: PUSH
54321: LD_INT 1
54323: DOUBLE
54324: EQUAL
54325: IFTRUE 54329
54327: GO 54346
54329: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
54330: LD_VAR 0 1
54334: PPUSH
54335: LD_VAR 0 10
54339: PPUSH
54340: CALL_OW 115
54344: GO 54407
54346: LD_INT 2
54348: DOUBLE
54349: EQUAL
54350: IFTRUE 54354
54352: GO 54376
54354: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
54355: LD_VAR 0 1
54359: PPUSH
54360: LD_VAR 0 6
54364: PPUSH
54365: LD_VAR 0 7
54369: PPUSH
54370: CALL_OW 153
54374: GO 54407
54376: LD_INT 3
54378: DOUBLE
54379: EQUAL
54380: IFTRUE 54384
54382: GO 54406
54384: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
54385: LD_VAR 0 1
54389: PPUSH
54390: LD_VAR 0 6
54394: PPUSH
54395: LD_VAR 0 7
54399: PPUSH
54400: CALL_OW 154
54404: GO 54407
54406: POP
// end ;
54407: LD_VAR 0 2
54411: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
54412: LD_INT 0
54414: PPUSH
54415: PPUSH
54416: PPUSH
54417: PPUSH
54418: PPUSH
54419: PPUSH
// if not unit or not building then
54420: LD_VAR 0 1
54424: NOT
54425: PUSH
54426: LD_VAR 0 2
54430: NOT
54431: OR
54432: IFFALSE 54436
// exit ;
54434: GO 54594
// x := GetX ( building ) ;
54436: LD_ADDR_VAR 0 5
54440: PUSH
54441: LD_VAR 0 2
54445: PPUSH
54446: CALL_OW 250
54450: ST_TO_ADDR
// y := GetY ( building ) ;
54451: LD_ADDR_VAR 0 6
54455: PUSH
54456: LD_VAR 0 2
54460: PPUSH
54461: CALL_OW 251
54465: ST_TO_ADDR
// for i = 0 to 5 do
54466: LD_ADDR_VAR 0 4
54470: PUSH
54471: DOUBLE
54472: LD_INT 0
54474: DEC
54475: ST_TO_ADDR
54476: LD_INT 5
54478: PUSH
54479: FOR_TO
54480: IFFALSE 54592
// begin _x := ShiftX ( x , i , 3 ) ;
54482: LD_ADDR_VAR 0 7
54486: PUSH
54487: LD_VAR 0 5
54491: PPUSH
54492: LD_VAR 0 4
54496: PPUSH
54497: LD_INT 3
54499: PPUSH
54500: CALL_OW 272
54504: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
54505: LD_ADDR_VAR 0 8
54509: PUSH
54510: LD_VAR 0 6
54514: PPUSH
54515: LD_VAR 0 4
54519: PPUSH
54520: LD_INT 3
54522: PPUSH
54523: CALL_OW 273
54527: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54528: LD_VAR 0 7
54532: PPUSH
54533: LD_VAR 0 8
54537: PPUSH
54538: CALL_OW 488
54542: NOT
54543: IFFALSE 54547
// continue ;
54545: GO 54479
// if HexInfo ( _x , _y ) = 0 then
54547: LD_VAR 0 7
54551: PPUSH
54552: LD_VAR 0 8
54556: PPUSH
54557: CALL_OW 428
54561: PUSH
54562: LD_INT 0
54564: EQUAL
54565: IFFALSE 54590
// begin ComMoveXY ( unit , _x , _y ) ;
54567: LD_VAR 0 1
54571: PPUSH
54572: LD_VAR 0 7
54576: PPUSH
54577: LD_VAR 0 8
54581: PPUSH
54582: CALL_OW 111
// exit ;
54586: POP
54587: POP
54588: GO 54594
// end ; end ;
54590: GO 54479
54592: POP
54593: POP
// end ;
54594: LD_VAR 0 3
54598: RET
// export function ScanBase ( side , base_area ) ; begin
54599: LD_INT 0
54601: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
54602: LD_ADDR_VAR 0 3
54606: PUSH
54607: LD_VAR 0 2
54611: PPUSH
54612: LD_INT 81
54614: PUSH
54615: LD_VAR 0 1
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: PPUSH
54624: CALL_OW 70
54628: ST_TO_ADDR
// end ;
54629: LD_VAR 0 3
54633: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54634: LD_INT 0
54636: PPUSH
54637: PPUSH
54638: PPUSH
54639: PPUSH
// result := false ;
54640: LD_ADDR_VAR 0 2
54644: PUSH
54645: LD_INT 0
54647: ST_TO_ADDR
// side := GetSide ( unit ) ;
54648: LD_ADDR_VAR 0 3
54652: PUSH
54653: LD_VAR 0 1
54657: PPUSH
54658: CALL_OW 255
54662: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54663: LD_ADDR_VAR 0 4
54667: PUSH
54668: LD_VAR 0 1
54672: PPUSH
54673: CALL_OW 248
54677: ST_TO_ADDR
// case nat of 1 :
54678: LD_VAR 0 4
54682: PUSH
54683: LD_INT 1
54685: DOUBLE
54686: EQUAL
54687: IFTRUE 54691
54689: GO 54702
54691: POP
// tech := tech_lassight ; 2 :
54692: LD_ADDR_VAR 0 5
54696: PUSH
54697: LD_INT 12
54699: ST_TO_ADDR
54700: GO 54741
54702: LD_INT 2
54704: DOUBLE
54705: EQUAL
54706: IFTRUE 54710
54708: GO 54721
54710: POP
// tech := tech_mortar ; 3 :
54711: LD_ADDR_VAR 0 5
54715: PUSH
54716: LD_INT 41
54718: ST_TO_ADDR
54719: GO 54741
54721: LD_INT 3
54723: DOUBLE
54724: EQUAL
54725: IFTRUE 54729
54727: GO 54740
54729: POP
// tech := tech_bazooka ; end ;
54730: LD_ADDR_VAR 0 5
54734: PUSH
54735: LD_INT 44
54737: ST_TO_ADDR
54738: GO 54741
54740: POP
// if Researched ( side , tech ) then
54741: LD_VAR 0 3
54745: PPUSH
54746: LD_VAR 0 5
54750: PPUSH
54751: CALL_OW 325
54755: IFFALSE 54782
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54757: LD_ADDR_VAR 0 2
54761: PUSH
54762: LD_INT 5
54764: PUSH
54765: LD_INT 8
54767: PUSH
54768: LD_INT 9
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: LIST
54775: PUSH
54776: LD_VAR 0 4
54780: ARRAY
54781: ST_TO_ADDR
// end ;
54782: LD_VAR 0 2
54786: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54787: LD_INT 0
54789: PPUSH
54790: PPUSH
54791: PPUSH
// if not mines then
54792: LD_VAR 0 2
54796: NOT
54797: IFFALSE 54801
// exit ;
54799: GO 54945
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54801: LD_ADDR_VAR 0 5
54805: PUSH
54806: LD_INT 81
54808: PUSH
54809: LD_VAR 0 1
54813: PUSH
54814: EMPTY
54815: LIST
54816: LIST
54817: PUSH
54818: LD_INT 3
54820: PUSH
54821: LD_INT 21
54823: PUSH
54824: LD_INT 3
54826: PUSH
54827: EMPTY
54828: LIST
54829: LIST
54830: PUSH
54831: EMPTY
54832: LIST
54833: LIST
54834: PUSH
54835: EMPTY
54836: LIST
54837: LIST
54838: PPUSH
54839: CALL_OW 69
54843: ST_TO_ADDR
// for i in mines do
54844: LD_ADDR_VAR 0 4
54848: PUSH
54849: LD_VAR 0 2
54853: PUSH
54854: FOR_IN
54855: IFFALSE 54943
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54857: LD_VAR 0 4
54861: PUSH
54862: LD_INT 1
54864: ARRAY
54865: PPUSH
54866: LD_VAR 0 4
54870: PUSH
54871: LD_INT 2
54873: ARRAY
54874: PPUSH
54875: CALL_OW 458
54879: NOT
54880: IFFALSE 54884
// continue ;
54882: GO 54854
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54884: LD_VAR 0 4
54888: PUSH
54889: LD_INT 1
54891: ARRAY
54892: PPUSH
54893: LD_VAR 0 4
54897: PUSH
54898: LD_INT 2
54900: ARRAY
54901: PPUSH
54902: CALL_OW 428
54906: PUSH
54907: LD_VAR 0 5
54911: IN
54912: IFFALSE 54941
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54914: LD_VAR 0 4
54918: PUSH
54919: LD_INT 1
54921: ARRAY
54922: PPUSH
54923: LD_VAR 0 4
54927: PUSH
54928: LD_INT 2
54930: ARRAY
54931: PPUSH
54932: LD_VAR 0 1
54936: PPUSH
54937: CALL_OW 456
// end ;
54941: GO 54854
54943: POP
54944: POP
// end ;
54945: LD_VAR 0 3
54949: RET
// export function Count ( array ) ; begin
54950: LD_INT 0
54952: PPUSH
// result := array + 0 ;
54953: LD_ADDR_VAR 0 2
54957: PUSH
54958: LD_VAR 0 1
54962: PUSH
54963: LD_INT 0
54965: PLUS
54966: ST_TO_ADDR
// end ;
54967: LD_VAR 0 2
54971: RET
// export function IsEmpty ( building ) ; begin
54972: LD_INT 0
54974: PPUSH
// if not building then
54975: LD_VAR 0 1
54979: NOT
54980: IFFALSE 54984
// exit ;
54982: GO 55027
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54984: LD_ADDR_VAR 0 2
54988: PUSH
54989: LD_VAR 0 1
54993: PUSH
54994: LD_INT 22
54996: PUSH
54997: LD_VAR 0 1
55001: PPUSH
55002: CALL_OW 255
55006: PUSH
55007: EMPTY
55008: LIST
55009: LIST
55010: PUSH
55011: LD_INT 58
55013: PUSH
55014: EMPTY
55015: LIST
55016: PUSH
55017: EMPTY
55018: LIST
55019: LIST
55020: PPUSH
55021: CALL_OW 69
55025: IN
55026: ST_TO_ADDR
// end ;
55027: LD_VAR 0 2
55031: RET
// export function IsNotFull ( building ) ; var places ; begin
55032: LD_INT 0
55034: PPUSH
55035: PPUSH
// if not building then
55036: LD_VAR 0 1
55040: NOT
55041: IFFALSE 55045
// exit ;
55043: GO 55073
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
55045: LD_ADDR_VAR 0 2
55049: PUSH
55050: LD_VAR 0 1
55054: PPUSH
55055: LD_INT 3
55057: PUSH
55058: LD_INT 62
55060: PUSH
55061: EMPTY
55062: LIST
55063: PUSH
55064: EMPTY
55065: LIST
55066: LIST
55067: PPUSH
55068: CALL_OW 72
55072: ST_TO_ADDR
// end ;
55073: LD_VAR 0 2
55077: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55078: LD_INT 0
55080: PPUSH
55081: PPUSH
55082: PPUSH
55083: PPUSH
// tmp := [ ] ;
55084: LD_ADDR_VAR 0 3
55088: PUSH
55089: EMPTY
55090: ST_TO_ADDR
// list := [ ] ;
55091: LD_ADDR_VAR 0 5
55095: PUSH
55096: EMPTY
55097: ST_TO_ADDR
// for i = 16 to 25 do
55098: LD_ADDR_VAR 0 4
55102: PUSH
55103: DOUBLE
55104: LD_INT 16
55106: DEC
55107: ST_TO_ADDR
55108: LD_INT 25
55110: PUSH
55111: FOR_TO
55112: IFFALSE 55185
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55114: LD_ADDR_VAR 0 3
55118: PUSH
55119: LD_VAR 0 3
55123: PUSH
55124: LD_INT 22
55126: PUSH
55127: LD_VAR 0 1
55131: PPUSH
55132: CALL_OW 255
55136: PUSH
55137: EMPTY
55138: LIST
55139: LIST
55140: PUSH
55141: LD_INT 91
55143: PUSH
55144: LD_VAR 0 1
55148: PUSH
55149: LD_INT 6
55151: PUSH
55152: EMPTY
55153: LIST
55154: LIST
55155: LIST
55156: PUSH
55157: LD_INT 30
55159: PUSH
55160: LD_VAR 0 4
55164: PUSH
55165: EMPTY
55166: LIST
55167: LIST
55168: PUSH
55169: EMPTY
55170: LIST
55171: LIST
55172: LIST
55173: PUSH
55174: EMPTY
55175: LIST
55176: PPUSH
55177: CALL_OW 69
55181: ADD
55182: ST_TO_ADDR
55183: GO 55111
55185: POP
55186: POP
// for i = 1 to tmp do
55187: LD_ADDR_VAR 0 4
55191: PUSH
55192: DOUBLE
55193: LD_INT 1
55195: DEC
55196: ST_TO_ADDR
55197: LD_VAR 0 3
55201: PUSH
55202: FOR_TO
55203: IFFALSE 55291
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55205: LD_ADDR_VAR 0 5
55209: PUSH
55210: LD_VAR 0 5
55214: PUSH
55215: LD_VAR 0 3
55219: PUSH
55220: LD_VAR 0 4
55224: ARRAY
55225: PPUSH
55226: CALL_OW 266
55230: PUSH
55231: LD_VAR 0 3
55235: PUSH
55236: LD_VAR 0 4
55240: ARRAY
55241: PPUSH
55242: CALL_OW 250
55246: PUSH
55247: LD_VAR 0 3
55251: PUSH
55252: LD_VAR 0 4
55256: ARRAY
55257: PPUSH
55258: CALL_OW 251
55262: PUSH
55263: LD_VAR 0 3
55267: PUSH
55268: LD_VAR 0 4
55272: ARRAY
55273: PPUSH
55274: CALL_OW 254
55278: PUSH
55279: EMPTY
55280: LIST
55281: LIST
55282: LIST
55283: LIST
55284: PUSH
55285: EMPTY
55286: LIST
55287: ADD
55288: ST_TO_ADDR
55289: GO 55202
55291: POP
55292: POP
// result := list ;
55293: LD_ADDR_VAR 0 2
55297: PUSH
55298: LD_VAR 0 5
55302: ST_TO_ADDR
// end ;
55303: LD_VAR 0 2
55307: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55308: LD_INT 0
55310: PPUSH
55311: PPUSH
55312: PPUSH
55313: PPUSH
55314: PPUSH
55315: PPUSH
55316: PPUSH
// if not factory then
55317: LD_VAR 0 1
55321: NOT
55322: IFFALSE 55326
// exit ;
55324: GO 55919
// if control = control_apeman then
55326: LD_VAR 0 4
55330: PUSH
55331: LD_INT 5
55333: EQUAL
55334: IFFALSE 55443
// begin tmp := UnitsInside ( factory ) ;
55336: LD_ADDR_VAR 0 8
55340: PUSH
55341: LD_VAR 0 1
55345: PPUSH
55346: CALL_OW 313
55350: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55351: LD_VAR 0 8
55355: PPUSH
55356: LD_INT 25
55358: PUSH
55359: LD_INT 12
55361: PUSH
55362: EMPTY
55363: LIST
55364: LIST
55365: PPUSH
55366: CALL_OW 72
55370: NOT
55371: IFFALSE 55381
// control := control_manual ;
55373: LD_ADDR_VAR 0 4
55377: PUSH
55378: LD_INT 1
55380: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55381: LD_ADDR_VAR 0 8
55385: PUSH
55386: LD_VAR 0 1
55390: PPUSH
55391: CALL 55078 0 1
55395: ST_TO_ADDR
// if tmp then
55396: LD_VAR 0 8
55400: IFFALSE 55443
// begin for i in tmp do
55402: LD_ADDR_VAR 0 7
55406: PUSH
55407: LD_VAR 0 8
55411: PUSH
55412: FOR_IN
55413: IFFALSE 55441
// if i [ 1 ] = b_ext_radio then
55415: LD_VAR 0 7
55419: PUSH
55420: LD_INT 1
55422: ARRAY
55423: PUSH
55424: LD_INT 22
55426: EQUAL
55427: IFFALSE 55439
// begin control := control_remote ;
55429: LD_ADDR_VAR 0 4
55433: PUSH
55434: LD_INT 2
55436: ST_TO_ADDR
// break ;
55437: GO 55441
// end ;
55439: GO 55412
55441: POP
55442: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55443: LD_VAR 0 1
55447: PPUSH
55448: LD_VAR 0 2
55452: PPUSH
55453: LD_VAR 0 3
55457: PPUSH
55458: LD_VAR 0 4
55462: PPUSH
55463: LD_VAR 0 5
55467: PPUSH
55468: CALL_OW 448
55472: IFFALSE 55507
// begin result := [ chassis , engine , control , weapon ] ;
55474: LD_ADDR_VAR 0 6
55478: PUSH
55479: LD_VAR 0 2
55483: PUSH
55484: LD_VAR 0 3
55488: PUSH
55489: LD_VAR 0 4
55493: PUSH
55494: LD_VAR 0 5
55498: PUSH
55499: EMPTY
55500: LIST
55501: LIST
55502: LIST
55503: LIST
55504: ST_TO_ADDR
// exit ;
55505: GO 55919
// end ; _chassis := AvailableChassisList ( factory ) ;
55507: LD_ADDR_VAR 0 9
55511: PUSH
55512: LD_VAR 0 1
55516: PPUSH
55517: CALL_OW 475
55521: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55522: LD_ADDR_VAR 0 11
55526: PUSH
55527: LD_VAR 0 1
55531: PPUSH
55532: CALL_OW 476
55536: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55537: LD_ADDR_VAR 0 12
55541: PUSH
55542: LD_VAR 0 1
55546: PPUSH
55547: CALL_OW 477
55551: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55552: LD_ADDR_VAR 0 10
55556: PUSH
55557: LD_VAR 0 1
55561: PPUSH
55562: CALL_OW 478
55566: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55567: LD_VAR 0 9
55571: NOT
55572: PUSH
55573: LD_VAR 0 11
55577: NOT
55578: OR
55579: PUSH
55580: LD_VAR 0 12
55584: NOT
55585: OR
55586: PUSH
55587: LD_VAR 0 10
55591: NOT
55592: OR
55593: IFFALSE 55628
// begin result := [ chassis , engine , control , weapon ] ;
55595: LD_ADDR_VAR 0 6
55599: PUSH
55600: LD_VAR 0 2
55604: PUSH
55605: LD_VAR 0 3
55609: PUSH
55610: LD_VAR 0 4
55614: PUSH
55615: LD_VAR 0 5
55619: PUSH
55620: EMPTY
55621: LIST
55622: LIST
55623: LIST
55624: LIST
55625: ST_TO_ADDR
// exit ;
55626: GO 55919
// end ; if not chassis in _chassis then
55628: LD_VAR 0 2
55632: PUSH
55633: LD_VAR 0 9
55637: IN
55638: NOT
55639: IFFALSE 55665
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55641: LD_ADDR_VAR 0 2
55645: PUSH
55646: LD_VAR 0 9
55650: PUSH
55651: LD_INT 1
55653: PPUSH
55654: LD_VAR 0 9
55658: PPUSH
55659: CALL_OW 12
55663: ARRAY
55664: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55665: LD_VAR 0 2
55669: PPUSH
55670: LD_VAR 0 3
55674: PPUSH
55675: CALL 55924 0 2
55679: NOT
55680: IFFALSE 55739
// repeat engine := _engine [ 1 ] ;
55682: LD_ADDR_VAR 0 3
55686: PUSH
55687: LD_VAR 0 11
55691: PUSH
55692: LD_INT 1
55694: ARRAY
55695: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55696: LD_ADDR_VAR 0 11
55700: PUSH
55701: LD_VAR 0 11
55705: PPUSH
55706: LD_INT 1
55708: PPUSH
55709: CALL_OW 3
55713: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55714: LD_VAR 0 2
55718: PPUSH
55719: LD_VAR 0 3
55723: PPUSH
55724: CALL 55924 0 2
55728: PUSH
55729: LD_VAR 0 11
55733: PUSH
55734: EMPTY
55735: EQUAL
55736: OR
55737: IFFALSE 55682
// if not control in _control then
55739: LD_VAR 0 4
55743: PUSH
55744: LD_VAR 0 12
55748: IN
55749: NOT
55750: IFFALSE 55776
// control := _control [ rand ( 1 , _control ) ] ;
55752: LD_ADDR_VAR 0 4
55756: PUSH
55757: LD_VAR 0 12
55761: PUSH
55762: LD_INT 1
55764: PPUSH
55765: LD_VAR 0 12
55769: PPUSH
55770: CALL_OW 12
55774: ARRAY
55775: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55776: LD_VAR 0 2
55780: PPUSH
55781: LD_VAR 0 5
55785: PPUSH
55786: CALL 56144 0 2
55790: NOT
55791: IFFALSE 55850
// repeat weapon := _weapon [ 1 ] ;
55793: LD_ADDR_VAR 0 5
55797: PUSH
55798: LD_VAR 0 10
55802: PUSH
55803: LD_INT 1
55805: ARRAY
55806: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55807: LD_ADDR_VAR 0 10
55811: PUSH
55812: LD_VAR 0 10
55816: PPUSH
55817: LD_INT 1
55819: PPUSH
55820: CALL_OW 3
55824: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55825: LD_VAR 0 2
55829: PPUSH
55830: LD_VAR 0 5
55834: PPUSH
55835: CALL 56144 0 2
55839: PUSH
55840: LD_VAR 0 10
55844: PUSH
55845: EMPTY
55846: EQUAL
55847: OR
55848: IFFALSE 55793
// result := [ ] ;
55850: LD_ADDR_VAR 0 6
55854: PUSH
55855: EMPTY
55856: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55857: LD_VAR 0 1
55861: PPUSH
55862: LD_VAR 0 2
55866: PPUSH
55867: LD_VAR 0 3
55871: PPUSH
55872: LD_VAR 0 4
55876: PPUSH
55877: LD_VAR 0 5
55881: PPUSH
55882: CALL_OW 448
55886: IFFALSE 55919
// result := [ chassis , engine , control , weapon ] ;
55888: LD_ADDR_VAR 0 6
55892: PUSH
55893: LD_VAR 0 2
55897: PUSH
55898: LD_VAR 0 3
55902: PUSH
55903: LD_VAR 0 4
55907: PUSH
55908: LD_VAR 0 5
55912: PUSH
55913: EMPTY
55914: LIST
55915: LIST
55916: LIST
55917: LIST
55918: ST_TO_ADDR
// end ;
55919: LD_VAR 0 6
55923: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55924: LD_INT 0
55926: PPUSH
// if not chassis or not engine then
55927: LD_VAR 0 1
55931: NOT
55932: PUSH
55933: LD_VAR 0 2
55937: NOT
55938: OR
55939: IFFALSE 55943
// exit ;
55941: GO 56139
// case engine of engine_solar :
55943: LD_VAR 0 2
55947: PUSH
55948: LD_INT 2
55950: DOUBLE
55951: EQUAL
55952: IFTRUE 55956
55954: GO 55994
55956: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55957: LD_ADDR_VAR 0 3
55961: PUSH
55962: LD_INT 11
55964: PUSH
55965: LD_INT 12
55967: PUSH
55968: LD_INT 13
55970: PUSH
55971: LD_INT 14
55973: PUSH
55974: LD_INT 1
55976: PUSH
55977: LD_INT 2
55979: PUSH
55980: LD_INT 3
55982: PUSH
55983: EMPTY
55984: LIST
55985: LIST
55986: LIST
55987: LIST
55988: LIST
55989: LIST
55990: LIST
55991: ST_TO_ADDR
55992: GO 56123
55994: LD_INT 1
55996: DOUBLE
55997: EQUAL
55998: IFTRUE 56002
56000: GO 56064
56002: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56003: LD_ADDR_VAR 0 3
56007: PUSH
56008: LD_INT 11
56010: PUSH
56011: LD_INT 12
56013: PUSH
56014: LD_INT 13
56016: PUSH
56017: LD_INT 14
56019: PUSH
56020: LD_INT 1
56022: PUSH
56023: LD_INT 2
56025: PUSH
56026: LD_INT 3
56028: PUSH
56029: LD_INT 4
56031: PUSH
56032: LD_INT 5
56034: PUSH
56035: LD_INT 21
56037: PUSH
56038: LD_INT 23
56040: PUSH
56041: LD_INT 22
56043: PUSH
56044: LD_INT 24
56046: PUSH
56047: EMPTY
56048: LIST
56049: LIST
56050: LIST
56051: LIST
56052: LIST
56053: LIST
56054: LIST
56055: LIST
56056: LIST
56057: LIST
56058: LIST
56059: LIST
56060: LIST
56061: ST_TO_ADDR
56062: GO 56123
56064: LD_INT 3
56066: DOUBLE
56067: EQUAL
56068: IFTRUE 56072
56070: GO 56122
56072: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56073: LD_ADDR_VAR 0 3
56077: PUSH
56078: LD_INT 13
56080: PUSH
56081: LD_INT 14
56083: PUSH
56084: LD_INT 2
56086: PUSH
56087: LD_INT 3
56089: PUSH
56090: LD_INT 4
56092: PUSH
56093: LD_INT 5
56095: PUSH
56096: LD_INT 21
56098: PUSH
56099: LD_INT 22
56101: PUSH
56102: LD_INT 23
56104: PUSH
56105: LD_INT 24
56107: PUSH
56108: EMPTY
56109: LIST
56110: LIST
56111: LIST
56112: LIST
56113: LIST
56114: LIST
56115: LIST
56116: LIST
56117: LIST
56118: LIST
56119: ST_TO_ADDR
56120: GO 56123
56122: POP
// result := ( chassis in result ) ;
56123: LD_ADDR_VAR 0 3
56127: PUSH
56128: LD_VAR 0 1
56132: PUSH
56133: LD_VAR 0 3
56137: IN
56138: ST_TO_ADDR
// end ;
56139: LD_VAR 0 3
56143: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56144: LD_INT 0
56146: PPUSH
// if not chassis or not weapon then
56147: LD_VAR 0 1
56151: NOT
56152: PUSH
56153: LD_VAR 0 2
56157: NOT
56158: OR
56159: IFFALSE 56163
// exit ;
56161: GO 57223
// case weapon of us_machine_gun :
56163: LD_VAR 0 2
56167: PUSH
56168: LD_INT 2
56170: DOUBLE
56171: EQUAL
56172: IFTRUE 56176
56174: GO 56206
56176: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56177: LD_ADDR_VAR 0 3
56181: PUSH
56182: LD_INT 1
56184: PUSH
56185: LD_INT 2
56187: PUSH
56188: LD_INT 3
56190: PUSH
56191: LD_INT 4
56193: PUSH
56194: LD_INT 5
56196: PUSH
56197: EMPTY
56198: LIST
56199: LIST
56200: LIST
56201: LIST
56202: LIST
56203: ST_TO_ADDR
56204: GO 57207
56206: LD_INT 3
56208: DOUBLE
56209: EQUAL
56210: IFTRUE 56214
56212: GO 56244
56214: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56215: LD_ADDR_VAR 0 3
56219: PUSH
56220: LD_INT 1
56222: PUSH
56223: LD_INT 2
56225: PUSH
56226: LD_INT 3
56228: PUSH
56229: LD_INT 4
56231: PUSH
56232: LD_INT 5
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: LIST
56239: LIST
56240: LIST
56241: ST_TO_ADDR
56242: GO 57207
56244: LD_INT 11
56246: DOUBLE
56247: EQUAL
56248: IFTRUE 56252
56250: GO 56282
56252: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56253: LD_ADDR_VAR 0 3
56257: PUSH
56258: LD_INT 1
56260: PUSH
56261: LD_INT 2
56263: PUSH
56264: LD_INT 3
56266: PUSH
56267: LD_INT 4
56269: PUSH
56270: LD_INT 5
56272: PUSH
56273: EMPTY
56274: LIST
56275: LIST
56276: LIST
56277: LIST
56278: LIST
56279: ST_TO_ADDR
56280: GO 57207
56282: LD_INT 4
56284: DOUBLE
56285: EQUAL
56286: IFTRUE 56290
56288: GO 56316
56290: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56291: LD_ADDR_VAR 0 3
56295: PUSH
56296: LD_INT 2
56298: PUSH
56299: LD_INT 3
56301: PUSH
56302: LD_INT 4
56304: PUSH
56305: LD_INT 5
56307: PUSH
56308: EMPTY
56309: LIST
56310: LIST
56311: LIST
56312: LIST
56313: ST_TO_ADDR
56314: GO 57207
56316: LD_INT 5
56318: DOUBLE
56319: EQUAL
56320: IFTRUE 56324
56322: GO 56350
56324: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56325: LD_ADDR_VAR 0 3
56329: PUSH
56330: LD_INT 2
56332: PUSH
56333: LD_INT 3
56335: PUSH
56336: LD_INT 4
56338: PUSH
56339: LD_INT 5
56341: PUSH
56342: EMPTY
56343: LIST
56344: LIST
56345: LIST
56346: LIST
56347: ST_TO_ADDR
56348: GO 57207
56350: LD_INT 9
56352: DOUBLE
56353: EQUAL
56354: IFTRUE 56358
56356: GO 56384
56358: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56359: LD_ADDR_VAR 0 3
56363: PUSH
56364: LD_INT 2
56366: PUSH
56367: LD_INT 3
56369: PUSH
56370: LD_INT 4
56372: PUSH
56373: LD_INT 5
56375: PUSH
56376: EMPTY
56377: LIST
56378: LIST
56379: LIST
56380: LIST
56381: ST_TO_ADDR
56382: GO 57207
56384: LD_INT 7
56386: DOUBLE
56387: EQUAL
56388: IFTRUE 56392
56390: GO 56418
56392: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56393: LD_ADDR_VAR 0 3
56397: PUSH
56398: LD_INT 2
56400: PUSH
56401: LD_INT 3
56403: PUSH
56404: LD_INT 4
56406: PUSH
56407: LD_INT 5
56409: PUSH
56410: EMPTY
56411: LIST
56412: LIST
56413: LIST
56414: LIST
56415: ST_TO_ADDR
56416: GO 57207
56418: LD_INT 12
56420: DOUBLE
56421: EQUAL
56422: IFTRUE 56426
56424: GO 56452
56426: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56427: LD_ADDR_VAR 0 3
56431: PUSH
56432: LD_INT 2
56434: PUSH
56435: LD_INT 3
56437: PUSH
56438: LD_INT 4
56440: PUSH
56441: LD_INT 5
56443: PUSH
56444: EMPTY
56445: LIST
56446: LIST
56447: LIST
56448: LIST
56449: ST_TO_ADDR
56450: GO 57207
56452: LD_INT 13
56454: DOUBLE
56455: EQUAL
56456: IFTRUE 56460
56458: GO 56486
56460: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56461: LD_ADDR_VAR 0 3
56465: PUSH
56466: LD_INT 2
56468: PUSH
56469: LD_INT 3
56471: PUSH
56472: LD_INT 4
56474: PUSH
56475: LD_INT 5
56477: PUSH
56478: EMPTY
56479: LIST
56480: LIST
56481: LIST
56482: LIST
56483: ST_TO_ADDR
56484: GO 57207
56486: LD_INT 14
56488: DOUBLE
56489: EQUAL
56490: IFTRUE 56494
56492: GO 56512
56494: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56495: LD_ADDR_VAR 0 3
56499: PUSH
56500: LD_INT 4
56502: PUSH
56503: LD_INT 5
56505: PUSH
56506: EMPTY
56507: LIST
56508: LIST
56509: ST_TO_ADDR
56510: GO 57207
56512: LD_INT 6
56514: DOUBLE
56515: EQUAL
56516: IFTRUE 56520
56518: GO 56538
56520: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56521: LD_ADDR_VAR 0 3
56525: PUSH
56526: LD_INT 4
56528: PUSH
56529: LD_INT 5
56531: PUSH
56532: EMPTY
56533: LIST
56534: LIST
56535: ST_TO_ADDR
56536: GO 57207
56538: LD_INT 10
56540: DOUBLE
56541: EQUAL
56542: IFTRUE 56546
56544: GO 56564
56546: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56547: LD_ADDR_VAR 0 3
56551: PUSH
56552: LD_INT 4
56554: PUSH
56555: LD_INT 5
56557: PUSH
56558: EMPTY
56559: LIST
56560: LIST
56561: ST_TO_ADDR
56562: GO 57207
56564: LD_INT 22
56566: DOUBLE
56567: EQUAL
56568: IFTRUE 56572
56570: GO 56598
56572: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56573: LD_ADDR_VAR 0 3
56577: PUSH
56578: LD_INT 11
56580: PUSH
56581: LD_INT 12
56583: PUSH
56584: LD_INT 13
56586: PUSH
56587: LD_INT 14
56589: PUSH
56590: EMPTY
56591: LIST
56592: LIST
56593: LIST
56594: LIST
56595: ST_TO_ADDR
56596: GO 57207
56598: LD_INT 23
56600: DOUBLE
56601: EQUAL
56602: IFTRUE 56606
56604: GO 56632
56606: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56607: LD_ADDR_VAR 0 3
56611: PUSH
56612: LD_INT 11
56614: PUSH
56615: LD_INT 12
56617: PUSH
56618: LD_INT 13
56620: PUSH
56621: LD_INT 14
56623: PUSH
56624: EMPTY
56625: LIST
56626: LIST
56627: LIST
56628: LIST
56629: ST_TO_ADDR
56630: GO 57207
56632: LD_INT 24
56634: DOUBLE
56635: EQUAL
56636: IFTRUE 56640
56638: GO 56666
56640: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56641: LD_ADDR_VAR 0 3
56645: PUSH
56646: LD_INT 11
56648: PUSH
56649: LD_INT 12
56651: PUSH
56652: LD_INT 13
56654: PUSH
56655: LD_INT 14
56657: PUSH
56658: EMPTY
56659: LIST
56660: LIST
56661: LIST
56662: LIST
56663: ST_TO_ADDR
56664: GO 57207
56666: LD_INT 30
56668: DOUBLE
56669: EQUAL
56670: IFTRUE 56674
56672: GO 56700
56674: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56675: LD_ADDR_VAR 0 3
56679: PUSH
56680: LD_INT 11
56682: PUSH
56683: LD_INT 12
56685: PUSH
56686: LD_INT 13
56688: PUSH
56689: LD_INT 14
56691: PUSH
56692: EMPTY
56693: LIST
56694: LIST
56695: LIST
56696: LIST
56697: ST_TO_ADDR
56698: GO 57207
56700: LD_INT 25
56702: DOUBLE
56703: EQUAL
56704: IFTRUE 56708
56706: GO 56726
56708: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56709: LD_ADDR_VAR 0 3
56713: PUSH
56714: LD_INT 13
56716: PUSH
56717: LD_INT 14
56719: PUSH
56720: EMPTY
56721: LIST
56722: LIST
56723: ST_TO_ADDR
56724: GO 57207
56726: LD_INT 27
56728: DOUBLE
56729: EQUAL
56730: IFTRUE 56734
56732: GO 56752
56734: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
56735: LD_ADDR_VAR 0 3
56739: PUSH
56740: LD_INT 13
56742: PUSH
56743: LD_INT 14
56745: PUSH
56746: EMPTY
56747: LIST
56748: LIST
56749: ST_TO_ADDR
56750: GO 57207
56752: LD_INT 92
56754: DOUBLE
56755: EQUAL
56756: IFTRUE 56760
56758: GO 56786
56760: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56761: LD_ADDR_VAR 0 3
56765: PUSH
56766: LD_INT 11
56768: PUSH
56769: LD_INT 12
56771: PUSH
56772: LD_INT 13
56774: PUSH
56775: LD_INT 14
56777: PUSH
56778: EMPTY
56779: LIST
56780: LIST
56781: LIST
56782: LIST
56783: ST_TO_ADDR
56784: GO 57207
56786: LD_INT 28
56788: DOUBLE
56789: EQUAL
56790: IFTRUE 56794
56792: GO 56812
56794: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56795: LD_ADDR_VAR 0 3
56799: PUSH
56800: LD_INT 13
56802: PUSH
56803: LD_INT 14
56805: PUSH
56806: EMPTY
56807: LIST
56808: LIST
56809: ST_TO_ADDR
56810: GO 57207
56812: LD_INT 29
56814: DOUBLE
56815: EQUAL
56816: IFTRUE 56820
56818: GO 56838
56820: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56821: LD_ADDR_VAR 0 3
56825: PUSH
56826: LD_INT 13
56828: PUSH
56829: LD_INT 14
56831: PUSH
56832: EMPTY
56833: LIST
56834: LIST
56835: ST_TO_ADDR
56836: GO 57207
56838: LD_INT 31
56840: DOUBLE
56841: EQUAL
56842: IFTRUE 56846
56844: GO 56864
56846: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56847: LD_ADDR_VAR 0 3
56851: PUSH
56852: LD_INT 13
56854: PUSH
56855: LD_INT 14
56857: PUSH
56858: EMPTY
56859: LIST
56860: LIST
56861: ST_TO_ADDR
56862: GO 57207
56864: LD_INT 26
56866: DOUBLE
56867: EQUAL
56868: IFTRUE 56872
56870: GO 56890
56872: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56873: LD_ADDR_VAR 0 3
56877: PUSH
56878: LD_INT 13
56880: PUSH
56881: LD_INT 14
56883: PUSH
56884: EMPTY
56885: LIST
56886: LIST
56887: ST_TO_ADDR
56888: GO 57207
56890: LD_INT 42
56892: DOUBLE
56893: EQUAL
56894: IFTRUE 56898
56896: GO 56924
56898: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56899: LD_ADDR_VAR 0 3
56903: PUSH
56904: LD_INT 21
56906: PUSH
56907: LD_INT 22
56909: PUSH
56910: LD_INT 23
56912: PUSH
56913: LD_INT 24
56915: PUSH
56916: EMPTY
56917: LIST
56918: LIST
56919: LIST
56920: LIST
56921: ST_TO_ADDR
56922: GO 57207
56924: LD_INT 43
56926: DOUBLE
56927: EQUAL
56928: IFTRUE 56932
56930: GO 56958
56932: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56933: LD_ADDR_VAR 0 3
56937: PUSH
56938: LD_INT 21
56940: PUSH
56941: LD_INT 22
56943: PUSH
56944: LD_INT 23
56946: PUSH
56947: LD_INT 24
56949: PUSH
56950: EMPTY
56951: LIST
56952: LIST
56953: LIST
56954: LIST
56955: ST_TO_ADDR
56956: GO 57207
56958: LD_INT 44
56960: DOUBLE
56961: EQUAL
56962: IFTRUE 56966
56964: GO 56992
56966: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56967: LD_ADDR_VAR 0 3
56971: PUSH
56972: LD_INT 21
56974: PUSH
56975: LD_INT 22
56977: PUSH
56978: LD_INT 23
56980: PUSH
56981: LD_INT 24
56983: PUSH
56984: EMPTY
56985: LIST
56986: LIST
56987: LIST
56988: LIST
56989: ST_TO_ADDR
56990: GO 57207
56992: LD_INT 45
56994: DOUBLE
56995: EQUAL
56996: IFTRUE 57000
56998: GO 57026
57000: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57001: LD_ADDR_VAR 0 3
57005: PUSH
57006: LD_INT 21
57008: PUSH
57009: LD_INT 22
57011: PUSH
57012: LD_INT 23
57014: PUSH
57015: LD_INT 24
57017: PUSH
57018: EMPTY
57019: LIST
57020: LIST
57021: LIST
57022: LIST
57023: ST_TO_ADDR
57024: GO 57207
57026: LD_INT 49
57028: DOUBLE
57029: EQUAL
57030: IFTRUE 57034
57032: GO 57060
57034: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57035: LD_ADDR_VAR 0 3
57039: PUSH
57040: LD_INT 21
57042: PUSH
57043: LD_INT 22
57045: PUSH
57046: LD_INT 23
57048: PUSH
57049: LD_INT 24
57051: PUSH
57052: EMPTY
57053: LIST
57054: LIST
57055: LIST
57056: LIST
57057: ST_TO_ADDR
57058: GO 57207
57060: LD_INT 51
57062: DOUBLE
57063: EQUAL
57064: IFTRUE 57068
57066: GO 57094
57068: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57069: LD_ADDR_VAR 0 3
57073: PUSH
57074: LD_INT 21
57076: PUSH
57077: LD_INT 22
57079: PUSH
57080: LD_INT 23
57082: PUSH
57083: LD_INT 24
57085: PUSH
57086: EMPTY
57087: LIST
57088: LIST
57089: LIST
57090: LIST
57091: ST_TO_ADDR
57092: GO 57207
57094: LD_INT 52
57096: DOUBLE
57097: EQUAL
57098: IFTRUE 57102
57100: GO 57128
57102: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57103: LD_ADDR_VAR 0 3
57107: PUSH
57108: LD_INT 21
57110: PUSH
57111: LD_INT 22
57113: PUSH
57114: LD_INT 23
57116: PUSH
57117: LD_INT 24
57119: PUSH
57120: EMPTY
57121: LIST
57122: LIST
57123: LIST
57124: LIST
57125: ST_TO_ADDR
57126: GO 57207
57128: LD_INT 53
57130: DOUBLE
57131: EQUAL
57132: IFTRUE 57136
57134: GO 57154
57136: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57137: LD_ADDR_VAR 0 3
57141: PUSH
57142: LD_INT 23
57144: PUSH
57145: LD_INT 24
57147: PUSH
57148: EMPTY
57149: LIST
57150: LIST
57151: ST_TO_ADDR
57152: GO 57207
57154: LD_INT 46
57156: DOUBLE
57157: EQUAL
57158: IFTRUE 57162
57160: GO 57180
57162: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57163: LD_ADDR_VAR 0 3
57167: PUSH
57168: LD_INT 23
57170: PUSH
57171: LD_INT 24
57173: PUSH
57174: EMPTY
57175: LIST
57176: LIST
57177: ST_TO_ADDR
57178: GO 57207
57180: LD_INT 47
57182: DOUBLE
57183: EQUAL
57184: IFTRUE 57188
57186: GO 57206
57188: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57189: LD_ADDR_VAR 0 3
57193: PUSH
57194: LD_INT 23
57196: PUSH
57197: LD_INT 24
57199: PUSH
57200: EMPTY
57201: LIST
57202: LIST
57203: ST_TO_ADDR
57204: GO 57207
57206: POP
// result := ( chassis in result ) ;
57207: LD_ADDR_VAR 0 3
57211: PUSH
57212: LD_VAR 0 1
57216: PUSH
57217: LD_VAR 0 3
57221: IN
57222: ST_TO_ADDR
// end ;
57223: LD_VAR 0 3
57227: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57228: LD_INT 0
57230: PPUSH
57231: PPUSH
57232: PPUSH
57233: PPUSH
57234: PPUSH
57235: PPUSH
57236: PPUSH
// result := array ;
57237: LD_ADDR_VAR 0 5
57241: PUSH
57242: LD_VAR 0 1
57246: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57247: LD_VAR 0 1
57251: NOT
57252: PUSH
57253: LD_VAR 0 2
57257: NOT
57258: OR
57259: PUSH
57260: LD_VAR 0 3
57264: NOT
57265: OR
57266: PUSH
57267: LD_VAR 0 2
57271: PUSH
57272: LD_VAR 0 1
57276: GREATER
57277: OR
57278: PUSH
57279: LD_VAR 0 3
57283: PUSH
57284: LD_VAR 0 1
57288: GREATER
57289: OR
57290: IFFALSE 57294
// exit ;
57292: GO 57590
// if direction then
57294: LD_VAR 0 4
57298: IFFALSE 57362
// begin d := 1 ;
57300: LD_ADDR_VAR 0 9
57304: PUSH
57305: LD_INT 1
57307: ST_TO_ADDR
// if i_from > i_to then
57308: LD_VAR 0 2
57312: PUSH
57313: LD_VAR 0 3
57317: GREATER
57318: IFFALSE 57344
// length := ( array - i_from ) + i_to else
57320: LD_ADDR_VAR 0 11
57324: PUSH
57325: LD_VAR 0 1
57329: PUSH
57330: LD_VAR 0 2
57334: MINUS
57335: PUSH
57336: LD_VAR 0 3
57340: PLUS
57341: ST_TO_ADDR
57342: GO 57360
// length := i_to - i_from ;
57344: LD_ADDR_VAR 0 11
57348: PUSH
57349: LD_VAR 0 3
57353: PUSH
57354: LD_VAR 0 2
57358: MINUS
57359: ST_TO_ADDR
// end else
57360: GO 57423
// begin d := - 1 ;
57362: LD_ADDR_VAR 0 9
57366: PUSH
57367: LD_INT 1
57369: NEG
57370: ST_TO_ADDR
// if i_from > i_to then
57371: LD_VAR 0 2
57375: PUSH
57376: LD_VAR 0 3
57380: GREATER
57381: IFFALSE 57401
// length := i_from - i_to else
57383: LD_ADDR_VAR 0 11
57387: PUSH
57388: LD_VAR 0 2
57392: PUSH
57393: LD_VAR 0 3
57397: MINUS
57398: ST_TO_ADDR
57399: GO 57423
// length := ( array - i_to ) + i_from ;
57401: LD_ADDR_VAR 0 11
57405: PUSH
57406: LD_VAR 0 1
57410: PUSH
57411: LD_VAR 0 3
57415: MINUS
57416: PUSH
57417: LD_VAR 0 2
57421: PLUS
57422: ST_TO_ADDR
// end ; if not length then
57423: LD_VAR 0 11
57427: NOT
57428: IFFALSE 57432
// exit ;
57430: GO 57590
// tmp := array ;
57432: LD_ADDR_VAR 0 10
57436: PUSH
57437: LD_VAR 0 1
57441: ST_TO_ADDR
// for i = 1 to length do
57442: LD_ADDR_VAR 0 6
57446: PUSH
57447: DOUBLE
57448: LD_INT 1
57450: DEC
57451: ST_TO_ADDR
57452: LD_VAR 0 11
57456: PUSH
57457: FOR_TO
57458: IFFALSE 57578
// begin for j = 1 to array do
57460: LD_ADDR_VAR 0 7
57464: PUSH
57465: DOUBLE
57466: LD_INT 1
57468: DEC
57469: ST_TO_ADDR
57470: LD_VAR 0 1
57474: PUSH
57475: FOR_TO
57476: IFFALSE 57564
// begin k := j + d ;
57478: LD_ADDR_VAR 0 8
57482: PUSH
57483: LD_VAR 0 7
57487: PUSH
57488: LD_VAR 0 9
57492: PLUS
57493: ST_TO_ADDR
// if k > array then
57494: LD_VAR 0 8
57498: PUSH
57499: LD_VAR 0 1
57503: GREATER
57504: IFFALSE 57514
// k := 1 ;
57506: LD_ADDR_VAR 0 8
57510: PUSH
57511: LD_INT 1
57513: ST_TO_ADDR
// if not k then
57514: LD_VAR 0 8
57518: NOT
57519: IFFALSE 57531
// k := array ;
57521: LD_ADDR_VAR 0 8
57525: PUSH
57526: LD_VAR 0 1
57530: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57531: LD_ADDR_VAR 0 10
57535: PUSH
57536: LD_VAR 0 10
57540: PPUSH
57541: LD_VAR 0 8
57545: PPUSH
57546: LD_VAR 0 1
57550: PUSH
57551: LD_VAR 0 7
57555: ARRAY
57556: PPUSH
57557: CALL_OW 1
57561: ST_TO_ADDR
// end ;
57562: GO 57475
57564: POP
57565: POP
// array := tmp ;
57566: LD_ADDR_VAR 0 1
57570: PUSH
57571: LD_VAR 0 10
57575: ST_TO_ADDR
// end ;
57576: GO 57457
57578: POP
57579: POP
// result := array ;
57580: LD_ADDR_VAR 0 5
57584: PUSH
57585: LD_VAR 0 1
57589: ST_TO_ADDR
// end ;
57590: LD_VAR 0 5
57594: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57595: LD_INT 0
57597: PPUSH
57598: PPUSH
// result := 0 ;
57599: LD_ADDR_VAR 0 3
57603: PUSH
57604: LD_INT 0
57606: ST_TO_ADDR
// if not array or not value in array then
57607: LD_VAR 0 1
57611: NOT
57612: PUSH
57613: LD_VAR 0 2
57617: PUSH
57618: LD_VAR 0 1
57622: IN
57623: NOT
57624: OR
57625: IFFALSE 57629
// exit ;
57627: GO 57683
// for i = 1 to array do
57629: LD_ADDR_VAR 0 4
57633: PUSH
57634: DOUBLE
57635: LD_INT 1
57637: DEC
57638: ST_TO_ADDR
57639: LD_VAR 0 1
57643: PUSH
57644: FOR_TO
57645: IFFALSE 57681
// if value = array [ i ] then
57647: LD_VAR 0 2
57651: PUSH
57652: LD_VAR 0 1
57656: PUSH
57657: LD_VAR 0 4
57661: ARRAY
57662: EQUAL
57663: IFFALSE 57679
// begin result := i ;
57665: LD_ADDR_VAR 0 3
57669: PUSH
57670: LD_VAR 0 4
57674: ST_TO_ADDR
// exit ;
57675: POP
57676: POP
57677: GO 57683
// end ;
57679: GO 57644
57681: POP
57682: POP
// end ;
57683: LD_VAR 0 3
57687: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57688: LD_INT 0
57690: PPUSH
// vc_chassis := chassis ;
57691: LD_ADDR_OWVAR 37
57695: PUSH
57696: LD_VAR 0 1
57700: ST_TO_ADDR
// vc_engine := engine ;
57701: LD_ADDR_OWVAR 39
57705: PUSH
57706: LD_VAR 0 2
57710: ST_TO_ADDR
// vc_control := control ;
57711: LD_ADDR_OWVAR 38
57715: PUSH
57716: LD_VAR 0 3
57720: ST_TO_ADDR
// vc_weapon := weapon ;
57721: LD_ADDR_OWVAR 40
57725: PUSH
57726: LD_VAR 0 4
57730: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57731: LD_ADDR_OWVAR 41
57735: PUSH
57736: LD_VAR 0 5
57740: ST_TO_ADDR
// end ;
57741: LD_VAR 0 6
57745: RET
// export function WantPlant ( unit ) ; var task ; begin
57746: LD_INT 0
57748: PPUSH
57749: PPUSH
// result := false ;
57750: LD_ADDR_VAR 0 2
57754: PUSH
57755: LD_INT 0
57757: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57758: LD_ADDR_VAR 0 3
57762: PUSH
57763: LD_VAR 0 1
57767: PPUSH
57768: CALL_OW 437
57772: ST_TO_ADDR
// if task then
57773: LD_VAR 0 3
57777: IFFALSE 57805
// if task [ 1 ] [ 1 ] = p then
57779: LD_VAR 0 3
57783: PUSH
57784: LD_INT 1
57786: ARRAY
57787: PUSH
57788: LD_INT 1
57790: ARRAY
57791: PUSH
57792: LD_STRING p
57794: EQUAL
57795: IFFALSE 57805
// result := true ;
57797: LD_ADDR_VAR 0 2
57801: PUSH
57802: LD_INT 1
57804: ST_TO_ADDR
// end ;
57805: LD_VAR 0 2
57809: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57810: LD_INT 0
57812: PPUSH
57813: PPUSH
57814: PPUSH
57815: PPUSH
// if pos < 1 then
57816: LD_VAR 0 2
57820: PUSH
57821: LD_INT 1
57823: LESS
57824: IFFALSE 57828
// exit ;
57826: GO 58131
// if pos = 1 then
57828: LD_VAR 0 2
57832: PUSH
57833: LD_INT 1
57835: EQUAL
57836: IFFALSE 57869
// result := Replace ( arr , pos [ 1 ] , value ) else
57838: LD_ADDR_VAR 0 4
57842: PUSH
57843: LD_VAR 0 1
57847: PPUSH
57848: LD_VAR 0 2
57852: PUSH
57853: LD_INT 1
57855: ARRAY
57856: PPUSH
57857: LD_VAR 0 3
57861: PPUSH
57862: CALL_OW 1
57866: ST_TO_ADDR
57867: GO 58131
// begin tmp := arr ;
57869: LD_ADDR_VAR 0 6
57873: PUSH
57874: LD_VAR 0 1
57878: ST_TO_ADDR
// s_arr := [ tmp ] ;
57879: LD_ADDR_VAR 0 7
57883: PUSH
57884: LD_VAR 0 6
57888: PUSH
57889: EMPTY
57890: LIST
57891: ST_TO_ADDR
// for i = 1 to pos - 1 do
57892: LD_ADDR_VAR 0 5
57896: PUSH
57897: DOUBLE
57898: LD_INT 1
57900: DEC
57901: ST_TO_ADDR
57902: LD_VAR 0 2
57906: PUSH
57907: LD_INT 1
57909: MINUS
57910: PUSH
57911: FOR_TO
57912: IFFALSE 57957
// begin tmp := tmp [ pos [ i ] ] ;
57914: LD_ADDR_VAR 0 6
57918: PUSH
57919: LD_VAR 0 6
57923: PUSH
57924: LD_VAR 0 2
57928: PUSH
57929: LD_VAR 0 5
57933: ARRAY
57934: ARRAY
57935: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57936: LD_ADDR_VAR 0 7
57940: PUSH
57941: LD_VAR 0 7
57945: PUSH
57946: LD_VAR 0 6
57950: PUSH
57951: EMPTY
57952: LIST
57953: ADD
57954: ST_TO_ADDR
// end ;
57955: GO 57911
57957: POP
57958: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57959: LD_ADDR_VAR 0 6
57963: PUSH
57964: LD_VAR 0 6
57968: PPUSH
57969: LD_VAR 0 2
57973: PUSH
57974: LD_VAR 0 2
57978: ARRAY
57979: PPUSH
57980: LD_VAR 0 3
57984: PPUSH
57985: CALL_OW 1
57989: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57990: LD_ADDR_VAR 0 7
57994: PUSH
57995: LD_VAR 0 7
57999: PPUSH
58000: LD_VAR 0 7
58004: PPUSH
58005: LD_VAR 0 6
58009: PPUSH
58010: CALL_OW 1
58014: ST_TO_ADDR
// for i = s_arr downto 2 do
58015: LD_ADDR_VAR 0 5
58019: PUSH
58020: DOUBLE
58021: LD_VAR 0 7
58025: INC
58026: ST_TO_ADDR
58027: LD_INT 2
58029: PUSH
58030: FOR_DOWNTO
58031: IFFALSE 58115
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58033: LD_ADDR_VAR 0 6
58037: PUSH
58038: LD_VAR 0 7
58042: PUSH
58043: LD_VAR 0 5
58047: PUSH
58048: LD_INT 1
58050: MINUS
58051: ARRAY
58052: PPUSH
58053: LD_VAR 0 2
58057: PUSH
58058: LD_VAR 0 5
58062: PUSH
58063: LD_INT 1
58065: MINUS
58066: ARRAY
58067: PPUSH
58068: LD_VAR 0 7
58072: PUSH
58073: LD_VAR 0 5
58077: ARRAY
58078: PPUSH
58079: CALL_OW 1
58083: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58084: LD_ADDR_VAR 0 7
58088: PUSH
58089: LD_VAR 0 7
58093: PPUSH
58094: LD_VAR 0 5
58098: PUSH
58099: LD_INT 1
58101: MINUS
58102: PPUSH
58103: LD_VAR 0 6
58107: PPUSH
58108: CALL_OW 1
58112: ST_TO_ADDR
// end ;
58113: GO 58030
58115: POP
58116: POP
// result := s_arr [ 1 ] ;
58117: LD_ADDR_VAR 0 4
58121: PUSH
58122: LD_VAR 0 7
58126: PUSH
58127: LD_INT 1
58129: ARRAY
58130: ST_TO_ADDR
// end ; end ;
58131: LD_VAR 0 4
58135: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58136: LD_INT 0
58138: PPUSH
58139: PPUSH
// if not list then
58140: LD_VAR 0 1
58144: NOT
58145: IFFALSE 58149
// exit ;
58147: GO 58240
// i := list [ pos1 ] ;
58149: LD_ADDR_VAR 0 5
58153: PUSH
58154: LD_VAR 0 1
58158: PUSH
58159: LD_VAR 0 2
58163: ARRAY
58164: ST_TO_ADDR
// if not i then
58165: LD_VAR 0 5
58169: NOT
58170: IFFALSE 58174
// exit ;
58172: GO 58240
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58174: LD_ADDR_VAR 0 1
58178: PUSH
58179: LD_VAR 0 1
58183: PPUSH
58184: LD_VAR 0 2
58188: PPUSH
58189: LD_VAR 0 1
58193: PUSH
58194: LD_VAR 0 3
58198: ARRAY
58199: PPUSH
58200: CALL_OW 1
58204: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58205: LD_ADDR_VAR 0 1
58209: PUSH
58210: LD_VAR 0 1
58214: PPUSH
58215: LD_VAR 0 3
58219: PPUSH
58220: LD_VAR 0 5
58224: PPUSH
58225: CALL_OW 1
58229: ST_TO_ADDR
// result := list ;
58230: LD_ADDR_VAR 0 4
58234: PUSH
58235: LD_VAR 0 1
58239: ST_TO_ADDR
// end ;
58240: LD_VAR 0 4
58244: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58245: LD_INT 0
58247: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58248: LD_ADDR_VAR 0 5
58252: PUSH
58253: LD_VAR 0 1
58257: PPUSH
58258: CALL_OW 250
58262: PPUSH
58263: LD_VAR 0 1
58267: PPUSH
58268: CALL_OW 251
58272: PPUSH
58273: LD_VAR 0 2
58277: PPUSH
58278: LD_VAR 0 3
58282: PPUSH
58283: LD_VAR 0 4
58287: PPUSH
58288: CALL 58298 0 5
58292: ST_TO_ADDR
// end ;
58293: LD_VAR 0 5
58297: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58298: LD_INT 0
58300: PPUSH
58301: PPUSH
58302: PPUSH
58303: PPUSH
// if not list then
58304: LD_VAR 0 3
58308: NOT
58309: IFFALSE 58313
// exit ;
58311: GO 58701
// result := [ ] ;
58313: LD_ADDR_VAR 0 6
58317: PUSH
58318: EMPTY
58319: ST_TO_ADDR
// for i in list do
58320: LD_ADDR_VAR 0 7
58324: PUSH
58325: LD_VAR 0 3
58329: PUSH
58330: FOR_IN
58331: IFFALSE 58533
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58333: LD_ADDR_VAR 0 9
58337: PUSH
58338: LD_VAR 0 7
58342: PPUSH
58343: LD_VAR 0 1
58347: PPUSH
58348: LD_VAR 0 2
58352: PPUSH
58353: CALL_OW 297
58357: ST_TO_ADDR
// if not result then
58358: LD_VAR 0 6
58362: NOT
58363: IFFALSE 58389
// result := [ [ i , tmp ] ] else
58365: LD_ADDR_VAR 0 6
58369: PUSH
58370: LD_VAR 0 7
58374: PUSH
58375: LD_VAR 0 9
58379: PUSH
58380: EMPTY
58381: LIST
58382: LIST
58383: PUSH
58384: EMPTY
58385: LIST
58386: ST_TO_ADDR
58387: GO 58531
// begin if result [ result ] [ 2 ] < tmp then
58389: LD_VAR 0 6
58393: PUSH
58394: LD_VAR 0 6
58398: ARRAY
58399: PUSH
58400: LD_INT 2
58402: ARRAY
58403: PUSH
58404: LD_VAR 0 9
58408: LESS
58409: IFFALSE 58451
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58411: LD_ADDR_VAR 0 6
58415: PUSH
58416: LD_VAR 0 6
58420: PPUSH
58421: LD_VAR 0 6
58425: PUSH
58426: LD_INT 1
58428: PLUS
58429: PPUSH
58430: LD_VAR 0 7
58434: PUSH
58435: LD_VAR 0 9
58439: PUSH
58440: EMPTY
58441: LIST
58442: LIST
58443: PPUSH
58444: CALL_OW 2
58448: ST_TO_ADDR
58449: GO 58531
// for j = 1 to result do
58451: LD_ADDR_VAR 0 8
58455: PUSH
58456: DOUBLE
58457: LD_INT 1
58459: DEC
58460: ST_TO_ADDR
58461: LD_VAR 0 6
58465: PUSH
58466: FOR_TO
58467: IFFALSE 58529
// begin if tmp < result [ j ] [ 2 ] then
58469: LD_VAR 0 9
58473: PUSH
58474: LD_VAR 0 6
58478: PUSH
58479: LD_VAR 0 8
58483: ARRAY
58484: PUSH
58485: LD_INT 2
58487: ARRAY
58488: LESS
58489: IFFALSE 58527
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58491: LD_ADDR_VAR 0 6
58495: PUSH
58496: LD_VAR 0 6
58500: PPUSH
58501: LD_VAR 0 8
58505: PPUSH
58506: LD_VAR 0 7
58510: PUSH
58511: LD_VAR 0 9
58515: PUSH
58516: EMPTY
58517: LIST
58518: LIST
58519: PPUSH
58520: CALL_OW 2
58524: ST_TO_ADDR
// break ;
58525: GO 58529
// end ; end ;
58527: GO 58466
58529: POP
58530: POP
// end ; end ;
58531: GO 58330
58533: POP
58534: POP
// if result and not asc then
58535: LD_VAR 0 6
58539: PUSH
58540: LD_VAR 0 4
58544: NOT
58545: AND
58546: IFFALSE 58621
// begin tmp := result ;
58548: LD_ADDR_VAR 0 9
58552: PUSH
58553: LD_VAR 0 6
58557: ST_TO_ADDR
// for i = tmp downto 1 do
58558: LD_ADDR_VAR 0 7
58562: PUSH
58563: DOUBLE
58564: LD_VAR 0 9
58568: INC
58569: ST_TO_ADDR
58570: LD_INT 1
58572: PUSH
58573: FOR_DOWNTO
58574: IFFALSE 58619
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58576: LD_ADDR_VAR 0 6
58580: PUSH
58581: LD_VAR 0 6
58585: PPUSH
58586: LD_VAR 0 9
58590: PUSH
58591: LD_VAR 0 7
58595: MINUS
58596: PUSH
58597: LD_INT 1
58599: PLUS
58600: PPUSH
58601: LD_VAR 0 9
58605: PUSH
58606: LD_VAR 0 7
58610: ARRAY
58611: PPUSH
58612: CALL_OW 1
58616: ST_TO_ADDR
58617: GO 58573
58619: POP
58620: POP
// end ; tmp := [ ] ;
58621: LD_ADDR_VAR 0 9
58625: PUSH
58626: EMPTY
58627: ST_TO_ADDR
// if mode then
58628: LD_VAR 0 5
58632: IFFALSE 58701
// begin for i = 1 to result do
58634: LD_ADDR_VAR 0 7
58638: PUSH
58639: DOUBLE
58640: LD_INT 1
58642: DEC
58643: ST_TO_ADDR
58644: LD_VAR 0 6
58648: PUSH
58649: FOR_TO
58650: IFFALSE 58689
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58652: LD_ADDR_VAR 0 9
58656: PUSH
58657: LD_VAR 0 9
58661: PPUSH
58662: LD_VAR 0 7
58666: PPUSH
58667: LD_VAR 0 6
58671: PUSH
58672: LD_VAR 0 7
58676: ARRAY
58677: PUSH
58678: LD_INT 1
58680: ARRAY
58681: PPUSH
58682: CALL_OW 1
58686: ST_TO_ADDR
58687: GO 58649
58689: POP
58690: POP
// result := tmp ;
58691: LD_ADDR_VAR 0 6
58695: PUSH
58696: LD_VAR 0 9
58700: ST_TO_ADDR
// end ; end ;
58701: LD_VAR 0 6
58705: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58706: LD_INT 0
58708: PPUSH
58709: PPUSH
58710: PPUSH
58711: PPUSH
58712: PPUSH
58713: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58714: LD_ADDR_VAR 0 5
58718: PUSH
58719: LD_INT 0
58721: PUSH
58722: LD_INT 0
58724: PUSH
58725: LD_INT 0
58727: PUSH
58728: EMPTY
58729: PUSH
58730: EMPTY
58731: LIST
58732: LIST
58733: LIST
58734: LIST
58735: ST_TO_ADDR
// if not x or not y then
58736: LD_VAR 0 2
58740: NOT
58741: PUSH
58742: LD_VAR 0 3
58746: NOT
58747: OR
58748: IFFALSE 58752
// exit ;
58750: GO 60402
// if not range then
58752: LD_VAR 0 4
58756: NOT
58757: IFFALSE 58767
// range := 10 ;
58759: LD_ADDR_VAR 0 4
58763: PUSH
58764: LD_INT 10
58766: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58767: LD_ADDR_VAR 0 8
58771: PUSH
58772: LD_INT 81
58774: PUSH
58775: LD_VAR 0 1
58779: PUSH
58780: EMPTY
58781: LIST
58782: LIST
58783: PUSH
58784: LD_INT 92
58786: PUSH
58787: LD_VAR 0 2
58791: PUSH
58792: LD_VAR 0 3
58796: PUSH
58797: LD_VAR 0 4
58801: PUSH
58802: EMPTY
58803: LIST
58804: LIST
58805: LIST
58806: LIST
58807: PUSH
58808: LD_INT 3
58810: PUSH
58811: LD_INT 21
58813: PUSH
58814: LD_INT 3
58816: PUSH
58817: EMPTY
58818: LIST
58819: LIST
58820: PUSH
58821: EMPTY
58822: LIST
58823: LIST
58824: PUSH
58825: EMPTY
58826: LIST
58827: LIST
58828: LIST
58829: PPUSH
58830: CALL_OW 69
58834: ST_TO_ADDR
// if not tmp then
58835: LD_VAR 0 8
58839: NOT
58840: IFFALSE 58844
// exit ;
58842: GO 60402
// for i in tmp do
58844: LD_ADDR_VAR 0 6
58848: PUSH
58849: LD_VAR 0 8
58853: PUSH
58854: FOR_IN
58855: IFFALSE 60377
// begin points := [ 0 , 0 , 0 ] ;
58857: LD_ADDR_VAR 0 9
58861: PUSH
58862: LD_INT 0
58864: PUSH
58865: LD_INT 0
58867: PUSH
58868: LD_INT 0
58870: PUSH
58871: EMPTY
58872: LIST
58873: LIST
58874: LIST
58875: ST_TO_ADDR
// bpoints := 1 ;
58876: LD_ADDR_VAR 0 10
58880: PUSH
58881: LD_INT 1
58883: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58884: LD_VAR 0 6
58888: PPUSH
58889: CALL_OW 247
58893: PUSH
58894: LD_INT 1
58896: DOUBLE
58897: EQUAL
58898: IFTRUE 58902
58900: GO 59480
58902: POP
// begin if GetClass ( i ) = 1 then
58903: LD_VAR 0 6
58907: PPUSH
58908: CALL_OW 257
58912: PUSH
58913: LD_INT 1
58915: EQUAL
58916: IFFALSE 58937
// points := [ 10 , 5 , 3 ] ;
58918: LD_ADDR_VAR 0 9
58922: PUSH
58923: LD_INT 10
58925: PUSH
58926: LD_INT 5
58928: PUSH
58929: LD_INT 3
58931: PUSH
58932: EMPTY
58933: LIST
58934: LIST
58935: LIST
58936: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58937: LD_VAR 0 6
58941: PPUSH
58942: CALL_OW 257
58946: PUSH
58947: LD_INT 2
58949: PUSH
58950: LD_INT 3
58952: PUSH
58953: LD_INT 4
58955: PUSH
58956: EMPTY
58957: LIST
58958: LIST
58959: LIST
58960: IN
58961: IFFALSE 58982
// points := [ 3 , 2 , 1 ] ;
58963: LD_ADDR_VAR 0 9
58967: PUSH
58968: LD_INT 3
58970: PUSH
58971: LD_INT 2
58973: PUSH
58974: LD_INT 1
58976: PUSH
58977: EMPTY
58978: LIST
58979: LIST
58980: LIST
58981: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58982: LD_VAR 0 6
58986: PPUSH
58987: CALL_OW 257
58991: PUSH
58992: LD_INT 5
58994: EQUAL
58995: IFFALSE 59016
// points := [ 130 , 5 , 2 ] ;
58997: LD_ADDR_VAR 0 9
59001: PUSH
59002: LD_INT 130
59004: PUSH
59005: LD_INT 5
59007: PUSH
59008: LD_INT 2
59010: PUSH
59011: EMPTY
59012: LIST
59013: LIST
59014: LIST
59015: ST_TO_ADDR
// if GetClass ( i ) = 8 then
59016: LD_VAR 0 6
59020: PPUSH
59021: CALL_OW 257
59025: PUSH
59026: LD_INT 8
59028: EQUAL
59029: IFFALSE 59050
// points := [ 35 , 35 , 30 ] ;
59031: LD_ADDR_VAR 0 9
59035: PUSH
59036: LD_INT 35
59038: PUSH
59039: LD_INT 35
59041: PUSH
59042: LD_INT 30
59044: PUSH
59045: EMPTY
59046: LIST
59047: LIST
59048: LIST
59049: ST_TO_ADDR
// if GetClass ( i ) = 9 then
59050: LD_VAR 0 6
59054: PPUSH
59055: CALL_OW 257
59059: PUSH
59060: LD_INT 9
59062: EQUAL
59063: IFFALSE 59084
// points := [ 20 , 55 , 40 ] ;
59065: LD_ADDR_VAR 0 9
59069: PUSH
59070: LD_INT 20
59072: PUSH
59073: LD_INT 55
59075: PUSH
59076: LD_INT 40
59078: PUSH
59079: EMPTY
59080: LIST
59081: LIST
59082: LIST
59083: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59084: LD_VAR 0 6
59088: PPUSH
59089: CALL_OW 257
59093: PUSH
59094: LD_INT 12
59096: PUSH
59097: LD_INT 16
59099: PUSH
59100: EMPTY
59101: LIST
59102: LIST
59103: IN
59104: IFFALSE 59125
// points := [ 5 , 3 , 2 ] ;
59106: LD_ADDR_VAR 0 9
59110: PUSH
59111: LD_INT 5
59113: PUSH
59114: LD_INT 3
59116: PUSH
59117: LD_INT 2
59119: PUSH
59120: EMPTY
59121: LIST
59122: LIST
59123: LIST
59124: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59125: LD_VAR 0 6
59129: PPUSH
59130: CALL_OW 257
59134: PUSH
59135: LD_INT 17
59137: EQUAL
59138: IFFALSE 59159
// points := [ 100 , 50 , 75 ] ;
59140: LD_ADDR_VAR 0 9
59144: PUSH
59145: LD_INT 100
59147: PUSH
59148: LD_INT 50
59150: PUSH
59151: LD_INT 75
59153: PUSH
59154: EMPTY
59155: LIST
59156: LIST
59157: LIST
59158: ST_TO_ADDR
// if GetClass ( i ) = 15 then
59159: LD_VAR 0 6
59163: PPUSH
59164: CALL_OW 257
59168: PUSH
59169: LD_INT 15
59171: EQUAL
59172: IFFALSE 59193
// points := [ 10 , 5 , 3 ] ;
59174: LD_ADDR_VAR 0 9
59178: PUSH
59179: LD_INT 10
59181: PUSH
59182: LD_INT 5
59184: PUSH
59185: LD_INT 3
59187: PUSH
59188: EMPTY
59189: LIST
59190: LIST
59191: LIST
59192: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59193: LD_VAR 0 6
59197: PPUSH
59198: CALL_OW 257
59202: PUSH
59203: LD_INT 14
59205: EQUAL
59206: IFFALSE 59227
// points := [ 10 , 0 , 0 ] ;
59208: LD_ADDR_VAR 0 9
59212: PUSH
59213: LD_INT 10
59215: PUSH
59216: LD_INT 0
59218: PUSH
59219: LD_INT 0
59221: PUSH
59222: EMPTY
59223: LIST
59224: LIST
59225: LIST
59226: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59227: LD_VAR 0 6
59231: PPUSH
59232: CALL_OW 257
59236: PUSH
59237: LD_INT 11
59239: EQUAL
59240: IFFALSE 59261
// points := [ 30 , 10 , 5 ] ;
59242: LD_ADDR_VAR 0 9
59246: PUSH
59247: LD_INT 30
59249: PUSH
59250: LD_INT 10
59252: PUSH
59253: LD_INT 5
59255: PUSH
59256: EMPTY
59257: LIST
59258: LIST
59259: LIST
59260: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59261: LD_VAR 0 1
59265: PPUSH
59266: LD_INT 5
59268: PPUSH
59269: CALL_OW 321
59273: PUSH
59274: LD_INT 2
59276: EQUAL
59277: IFFALSE 59294
// bpoints := bpoints * 1.8 ;
59279: LD_ADDR_VAR 0 10
59283: PUSH
59284: LD_VAR 0 10
59288: PUSH
59289: LD_REAL  1.80000000000000E+0000
59292: MUL
59293: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59294: LD_VAR 0 6
59298: PPUSH
59299: CALL_OW 257
59303: PUSH
59304: LD_INT 1
59306: PUSH
59307: LD_INT 2
59309: PUSH
59310: LD_INT 3
59312: PUSH
59313: LD_INT 4
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: LIST
59320: LIST
59321: IN
59322: PUSH
59323: LD_VAR 0 1
59327: PPUSH
59328: LD_INT 51
59330: PPUSH
59331: CALL_OW 321
59335: PUSH
59336: LD_INT 2
59338: EQUAL
59339: AND
59340: IFFALSE 59357
// bpoints := bpoints * 1.2 ;
59342: LD_ADDR_VAR 0 10
59346: PUSH
59347: LD_VAR 0 10
59351: PUSH
59352: LD_REAL  1.20000000000000E+0000
59355: MUL
59356: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59357: LD_VAR 0 6
59361: PPUSH
59362: CALL_OW 257
59366: PUSH
59367: LD_INT 5
59369: PUSH
59370: LD_INT 7
59372: PUSH
59373: LD_INT 9
59375: PUSH
59376: EMPTY
59377: LIST
59378: LIST
59379: LIST
59380: IN
59381: PUSH
59382: LD_VAR 0 1
59386: PPUSH
59387: LD_INT 52
59389: PPUSH
59390: CALL_OW 321
59394: PUSH
59395: LD_INT 2
59397: EQUAL
59398: AND
59399: IFFALSE 59416
// bpoints := bpoints * 1.5 ;
59401: LD_ADDR_VAR 0 10
59405: PUSH
59406: LD_VAR 0 10
59410: PUSH
59411: LD_REAL  1.50000000000000E+0000
59414: MUL
59415: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59416: LD_VAR 0 1
59420: PPUSH
59421: LD_INT 66
59423: PPUSH
59424: CALL_OW 321
59428: PUSH
59429: LD_INT 2
59431: EQUAL
59432: IFFALSE 59449
// bpoints := bpoints * 1.1 ;
59434: LD_ADDR_VAR 0 10
59438: PUSH
59439: LD_VAR 0 10
59443: PUSH
59444: LD_REAL  1.10000000000000E+0000
59447: MUL
59448: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59449: LD_ADDR_VAR 0 10
59453: PUSH
59454: LD_VAR 0 10
59458: PUSH
59459: LD_VAR 0 6
59463: PPUSH
59464: LD_INT 1
59466: PPUSH
59467: CALL_OW 259
59471: PUSH
59472: LD_REAL  1.15000000000000E+0000
59475: MUL
59476: MUL
59477: ST_TO_ADDR
// end ; unit_vehicle :
59478: GO 60306
59480: LD_INT 2
59482: DOUBLE
59483: EQUAL
59484: IFTRUE 59488
59486: GO 60294
59488: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59489: LD_VAR 0 6
59493: PPUSH
59494: CALL_OW 264
59498: PUSH
59499: LD_INT 2
59501: PUSH
59502: LD_INT 42
59504: PUSH
59505: LD_INT 24
59507: PUSH
59508: EMPTY
59509: LIST
59510: LIST
59511: LIST
59512: IN
59513: IFFALSE 59534
// points := [ 25 , 5 , 3 ] ;
59515: LD_ADDR_VAR 0 9
59519: PUSH
59520: LD_INT 25
59522: PUSH
59523: LD_INT 5
59525: PUSH
59526: LD_INT 3
59528: PUSH
59529: EMPTY
59530: LIST
59531: LIST
59532: LIST
59533: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59534: LD_VAR 0 6
59538: PPUSH
59539: CALL_OW 264
59543: PUSH
59544: LD_INT 4
59546: PUSH
59547: LD_INT 43
59549: PUSH
59550: LD_INT 25
59552: PUSH
59553: EMPTY
59554: LIST
59555: LIST
59556: LIST
59557: IN
59558: IFFALSE 59579
// points := [ 40 , 15 , 5 ] ;
59560: LD_ADDR_VAR 0 9
59564: PUSH
59565: LD_INT 40
59567: PUSH
59568: LD_INT 15
59570: PUSH
59571: LD_INT 5
59573: PUSH
59574: EMPTY
59575: LIST
59576: LIST
59577: LIST
59578: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59579: LD_VAR 0 6
59583: PPUSH
59584: CALL_OW 264
59588: PUSH
59589: LD_INT 3
59591: PUSH
59592: LD_INT 23
59594: PUSH
59595: EMPTY
59596: LIST
59597: LIST
59598: IN
59599: IFFALSE 59620
// points := [ 7 , 25 , 8 ] ;
59601: LD_ADDR_VAR 0 9
59605: PUSH
59606: LD_INT 7
59608: PUSH
59609: LD_INT 25
59611: PUSH
59612: LD_INT 8
59614: PUSH
59615: EMPTY
59616: LIST
59617: LIST
59618: LIST
59619: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59620: LD_VAR 0 6
59624: PPUSH
59625: CALL_OW 264
59629: PUSH
59630: LD_INT 5
59632: PUSH
59633: LD_INT 27
59635: PUSH
59636: LD_INT 44
59638: PUSH
59639: EMPTY
59640: LIST
59641: LIST
59642: LIST
59643: IN
59644: IFFALSE 59665
// points := [ 14 , 50 , 16 ] ;
59646: LD_ADDR_VAR 0 9
59650: PUSH
59651: LD_INT 14
59653: PUSH
59654: LD_INT 50
59656: PUSH
59657: LD_INT 16
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: LIST
59664: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59665: LD_VAR 0 6
59669: PPUSH
59670: CALL_OW 264
59674: PUSH
59675: LD_INT 6
59677: PUSH
59678: LD_INT 46
59680: PUSH
59681: EMPTY
59682: LIST
59683: LIST
59684: IN
59685: IFFALSE 59706
// points := [ 32 , 120 , 70 ] ;
59687: LD_ADDR_VAR 0 9
59691: PUSH
59692: LD_INT 32
59694: PUSH
59695: LD_INT 120
59697: PUSH
59698: LD_INT 70
59700: PUSH
59701: EMPTY
59702: LIST
59703: LIST
59704: LIST
59705: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
59706: LD_VAR 0 6
59710: PPUSH
59711: CALL_OW 264
59715: PUSH
59716: LD_INT 7
59718: PUSH
59719: LD_INT 28
59721: PUSH
59722: LD_INT 45
59724: PUSH
59725: LD_INT 92
59727: PUSH
59728: EMPTY
59729: LIST
59730: LIST
59731: LIST
59732: LIST
59733: IN
59734: IFFALSE 59755
// points := [ 35 , 20 , 45 ] ;
59736: LD_ADDR_VAR 0 9
59740: PUSH
59741: LD_INT 35
59743: PUSH
59744: LD_INT 20
59746: PUSH
59747: LD_INT 45
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: LIST
59754: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59755: LD_VAR 0 6
59759: PPUSH
59760: CALL_OW 264
59764: PUSH
59765: LD_INT 47
59767: PUSH
59768: EMPTY
59769: LIST
59770: IN
59771: IFFALSE 59792
// points := [ 67 , 45 , 75 ] ;
59773: LD_ADDR_VAR 0 9
59777: PUSH
59778: LD_INT 67
59780: PUSH
59781: LD_INT 45
59783: PUSH
59784: LD_INT 75
59786: PUSH
59787: EMPTY
59788: LIST
59789: LIST
59790: LIST
59791: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59792: LD_VAR 0 6
59796: PPUSH
59797: CALL_OW 264
59801: PUSH
59802: LD_INT 26
59804: PUSH
59805: EMPTY
59806: LIST
59807: IN
59808: IFFALSE 59829
// points := [ 120 , 30 , 80 ] ;
59810: LD_ADDR_VAR 0 9
59814: PUSH
59815: LD_INT 120
59817: PUSH
59818: LD_INT 30
59820: PUSH
59821: LD_INT 80
59823: PUSH
59824: EMPTY
59825: LIST
59826: LIST
59827: LIST
59828: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59829: LD_VAR 0 6
59833: PPUSH
59834: CALL_OW 264
59838: PUSH
59839: LD_INT 22
59841: PUSH
59842: EMPTY
59843: LIST
59844: IN
59845: IFFALSE 59866
// points := [ 40 , 1 , 1 ] ;
59847: LD_ADDR_VAR 0 9
59851: PUSH
59852: LD_INT 40
59854: PUSH
59855: LD_INT 1
59857: PUSH
59858: LD_INT 1
59860: PUSH
59861: EMPTY
59862: LIST
59863: LIST
59864: LIST
59865: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59866: LD_VAR 0 6
59870: PPUSH
59871: CALL_OW 264
59875: PUSH
59876: LD_INT 29
59878: PUSH
59879: EMPTY
59880: LIST
59881: IN
59882: IFFALSE 59903
// points := [ 70 , 200 , 400 ] ;
59884: LD_ADDR_VAR 0 9
59888: PUSH
59889: LD_INT 70
59891: PUSH
59892: LD_INT 200
59894: PUSH
59895: LD_INT 400
59897: PUSH
59898: EMPTY
59899: LIST
59900: LIST
59901: LIST
59902: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59903: LD_VAR 0 6
59907: PPUSH
59908: CALL_OW 264
59912: PUSH
59913: LD_INT 14
59915: PUSH
59916: LD_INT 53
59918: PUSH
59919: EMPTY
59920: LIST
59921: LIST
59922: IN
59923: IFFALSE 59944
// points := [ 40 , 10 , 20 ] ;
59925: LD_ADDR_VAR 0 9
59929: PUSH
59930: LD_INT 40
59932: PUSH
59933: LD_INT 10
59935: PUSH
59936: LD_INT 20
59938: PUSH
59939: EMPTY
59940: LIST
59941: LIST
59942: LIST
59943: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59944: LD_VAR 0 6
59948: PPUSH
59949: CALL_OW 264
59953: PUSH
59954: LD_INT 9
59956: PUSH
59957: EMPTY
59958: LIST
59959: IN
59960: IFFALSE 59981
// points := [ 5 , 70 , 20 ] ;
59962: LD_ADDR_VAR 0 9
59966: PUSH
59967: LD_INT 5
59969: PUSH
59970: LD_INT 70
59972: PUSH
59973: LD_INT 20
59975: PUSH
59976: EMPTY
59977: LIST
59978: LIST
59979: LIST
59980: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59981: LD_VAR 0 6
59985: PPUSH
59986: CALL_OW 264
59990: PUSH
59991: LD_INT 10
59993: PUSH
59994: EMPTY
59995: LIST
59996: IN
59997: IFFALSE 60018
// points := [ 35 , 110 , 70 ] ;
59999: LD_ADDR_VAR 0 9
60003: PUSH
60004: LD_INT 35
60006: PUSH
60007: LD_INT 110
60009: PUSH
60010: LD_INT 70
60012: PUSH
60013: EMPTY
60014: LIST
60015: LIST
60016: LIST
60017: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
60018: LD_VAR 0 6
60022: PPUSH
60023: CALL_OW 265
60027: PUSH
60028: LD_INT 25
60030: EQUAL
60031: IFFALSE 60052
// points := [ 80 , 65 , 100 ] ;
60033: LD_ADDR_VAR 0 9
60037: PUSH
60038: LD_INT 80
60040: PUSH
60041: LD_INT 65
60043: PUSH
60044: LD_INT 100
60046: PUSH
60047: EMPTY
60048: LIST
60049: LIST
60050: LIST
60051: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
60052: LD_VAR 0 6
60056: PPUSH
60057: CALL_OW 263
60061: PUSH
60062: LD_INT 1
60064: EQUAL
60065: IFFALSE 60100
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
60067: LD_ADDR_VAR 0 10
60071: PUSH
60072: LD_VAR 0 10
60076: PUSH
60077: LD_VAR 0 6
60081: PPUSH
60082: CALL_OW 311
60086: PPUSH
60087: LD_INT 3
60089: PPUSH
60090: CALL_OW 259
60094: PUSH
60095: LD_INT 4
60097: MUL
60098: MUL
60099: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60100: LD_VAR 0 6
60104: PPUSH
60105: CALL_OW 263
60109: PUSH
60110: LD_INT 2
60112: EQUAL
60113: IFFALSE 60164
// begin j := IsControledBy ( i ) ;
60115: LD_ADDR_VAR 0 7
60119: PUSH
60120: LD_VAR 0 6
60124: PPUSH
60125: CALL_OW 312
60129: ST_TO_ADDR
// if j then
60130: LD_VAR 0 7
60134: IFFALSE 60164
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60136: LD_ADDR_VAR 0 10
60140: PUSH
60141: LD_VAR 0 10
60145: PUSH
60146: LD_VAR 0 7
60150: PPUSH
60151: LD_INT 3
60153: PPUSH
60154: CALL_OW 259
60158: PUSH
60159: LD_INT 3
60161: MUL
60162: MUL
60163: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
60164: LD_VAR 0 6
60168: PPUSH
60169: CALL_OW 264
60173: PUSH
60174: LD_INT 5
60176: PUSH
60177: LD_INT 6
60179: PUSH
60180: LD_INT 46
60182: PUSH
60183: LD_INT 44
60185: PUSH
60186: LD_INT 47
60188: PUSH
60189: LD_INT 45
60191: PUSH
60192: LD_INT 28
60194: PUSH
60195: LD_INT 7
60197: PUSH
60198: LD_INT 27
60200: PUSH
60201: LD_INT 29
60203: PUSH
60204: EMPTY
60205: LIST
60206: LIST
60207: LIST
60208: LIST
60209: LIST
60210: LIST
60211: LIST
60212: LIST
60213: LIST
60214: LIST
60215: IN
60216: PUSH
60217: LD_VAR 0 1
60221: PPUSH
60222: LD_INT 52
60224: PPUSH
60225: CALL_OW 321
60229: PUSH
60230: LD_INT 2
60232: EQUAL
60233: AND
60234: IFFALSE 60251
// bpoints := bpoints * 1.2 ;
60236: LD_ADDR_VAR 0 10
60240: PUSH
60241: LD_VAR 0 10
60245: PUSH
60246: LD_REAL  1.20000000000000E+0000
60249: MUL
60250: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60251: LD_VAR 0 6
60255: PPUSH
60256: CALL_OW 264
60260: PUSH
60261: LD_INT 6
60263: PUSH
60264: LD_INT 46
60266: PUSH
60267: LD_INT 47
60269: PUSH
60270: EMPTY
60271: LIST
60272: LIST
60273: LIST
60274: IN
60275: IFFALSE 60292
// bpoints := bpoints * 1.2 ;
60277: LD_ADDR_VAR 0 10
60281: PUSH
60282: LD_VAR 0 10
60286: PUSH
60287: LD_REAL  1.20000000000000E+0000
60290: MUL
60291: ST_TO_ADDR
// end ; unit_building :
60292: GO 60306
60294: LD_INT 3
60296: DOUBLE
60297: EQUAL
60298: IFTRUE 60302
60300: GO 60305
60302: POP
// ; end ;
60303: GO 60306
60305: POP
// for j = 1 to 3 do
60306: LD_ADDR_VAR 0 7
60310: PUSH
60311: DOUBLE
60312: LD_INT 1
60314: DEC
60315: ST_TO_ADDR
60316: LD_INT 3
60318: PUSH
60319: FOR_TO
60320: IFFALSE 60373
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60322: LD_ADDR_VAR 0 5
60326: PUSH
60327: LD_VAR 0 5
60331: PPUSH
60332: LD_VAR 0 7
60336: PPUSH
60337: LD_VAR 0 5
60341: PUSH
60342: LD_VAR 0 7
60346: ARRAY
60347: PUSH
60348: LD_VAR 0 9
60352: PUSH
60353: LD_VAR 0 7
60357: ARRAY
60358: PUSH
60359: LD_VAR 0 10
60363: MUL
60364: PLUS
60365: PPUSH
60366: CALL_OW 1
60370: ST_TO_ADDR
60371: GO 60319
60373: POP
60374: POP
// end ;
60375: GO 58854
60377: POP
60378: POP
// result := Replace ( result , 4 , tmp ) ;
60379: LD_ADDR_VAR 0 5
60383: PUSH
60384: LD_VAR 0 5
60388: PPUSH
60389: LD_INT 4
60391: PPUSH
60392: LD_VAR 0 8
60396: PPUSH
60397: CALL_OW 1
60401: ST_TO_ADDR
// end ;
60402: LD_VAR 0 5
60406: RET
// export function DangerAtRange ( unit , range ) ; begin
60407: LD_INT 0
60409: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60410: LD_ADDR_VAR 0 3
60414: PUSH
60415: LD_VAR 0 1
60419: PPUSH
60420: CALL_OW 255
60424: PPUSH
60425: LD_VAR 0 1
60429: PPUSH
60430: CALL_OW 250
60434: PPUSH
60435: LD_VAR 0 1
60439: PPUSH
60440: CALL_OW 251
60444: PPUSH
60445: LD_VAR 0 2
60449: PPUSH
60450: CALL 58706 0 4
60454: ST_TO_ADDR
// end ;
60455: LD_VAR 0 3
60459: RET
// export function DangerInArea ( side , area ) ; begin
60460: LD_INT 0
60462: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60463: LD_ADDR_VAR 0 3
60467: PUSH
60468: LD_VAR 0 2
60472: PPUSH
60473: LD_INT 81
60475: PUSH
60476: LD_VAR 0 1
60480: PUSH
60481: EMPTY
60482: LIST
60483: LIST
60484: PPUSH
60485: CALL_OW 70
60489: ST_TO_ADDR
// end ;
60490: LD_VAR 0 3
60494: RET
// export function IsExtension ( b ) ; begin
60495: LD_INT 0
60497: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60498: LD_ADDR_VAR 0 2
60502: PUSH
60503: LD_VAR 0 1
60507: PUSH
60508: LD_INT 23
60510: PUSH
60511: LD_INT 20
60513: PUSH
60514: LD_INT 22
60516: PUSH
60517: LD_INT 17
60519: PUSH
60520: LD_INT 24
60522: PUSH
60523: LD_INT 21
60525: PUSH
60526: LD_INT 19
60528: PUSH
60529: LD_INT 16
60531: PUSH
60532: LD_INT 25
60534: PUSH
60535: LD_INT 18
60537: PUSH
60538: EMPTY
60539: LIST
60540: LIST
60541: LIST
60542: LIST
60543: LIST
60544: LIST
60545: LIST
60546: LIST
60547: LIST
60548: LIST
60549: IN
60550: ST_TO_ADDR
// end ;
60551: LD_VAR 0 2
60555: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
60556: LD_INT 0
60558: PPUSH
60559: PPUSH
60560: PPUSH
// result := [ ] ;
60561: LD_ADDR_VAR 0 4
60565: PUSH
60566: EMPTY
60567: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60568: LD_ADDR_VAR 0 5
60572: PUSH
60573: LD_VAR 0 2
60577: PPUSH
60578: LD_INT 21
60580: PUSH
60581: LD_INT 3
60583: PUSH
60584: EMPTY
60585: LIST
60586: LIST
60587: PPUSH
60588: CALL_OW 70
60592: ST_TO_ADDR
// if not tmp then
60593: LD_VAR 0 5
60597: NOT
60598: IFFALSE 60602
// exit ;
60600: GO 60666
// if checkLink then
60602: LD_VAR 0 3
60606: IFFALSE 60656
// begin for i in tmp do
60608: LD_ADDR_VAR 0 6
60612: PUSH
60613: LD_VAR 0 5
60617: PUSH
60618: FOR_IN
60619: IFFALSE 60654
// if GetBase ( i ) <> base then
60621: LD_VAR 0 6
60625: PPUSH
60626: CALL_OW 274
60630: PUSH
60631: LD_VAR 0 1
60635: NONEQUAL
60636: IFFALSE 60652
// ComLinkToBase ( base , i ) ;
60638: LD_VAR 0 1
60642: PPUSH
60643: LD_VAR 0 6
60647: PPUSH
60648: CALL_OW 169
60652: GO 60618
60654: POP
60655: POP
// end ; result := tmp ;
60656: LD_ADDR_VAR 0 4
60660: PUSH
60661: LD_VAR 0 5
60665: ST_TO_ADDR
// end ;
60666: LD_VAR 0 4
60670: RET
// export function ComComplete ( units , b ) ; var i ; begin
60671: LD_INT 0
60673: PPUSH
60674: PPUSH
// if not units then
60675: LD_VAR 0 1
60679: NOT
60680: IFFALSE 60684
// exit ;
60682: GO 60774
// for i in units do
60684: LD_ADDR_VAR 0 4
60688: PUSH
60689: LD_VAR 0 1
60693: PUSH
60694: FOR_IN
60695: IFFALSE 60772
// if BuildingStatus ( b ) = bs_build then
60697: LD_VAR 0 2
60701: PPUSH
60702: CALL_OW 461
60706: PUSH
60707: LD_INT 1
60709: EQUAL
60710: IFFALSE 60770
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60712: LD_VAR 0 4
60716: PPUSH
60717: LD_STRING h
60719: PUSH
60720: LD_VAR 0 2
60724: PPUSH
60725: CALL_OW 250
60729: PUSH
60730: LD_VAR 0 2
60734: PPUSH
60735: CALL_OW 251
60739: PUSH
60740: LD_VAR 0 2
60744: PUSH
60745: LD_INT 0
60747: PUSH
60748: LD_INT 0
60750: PUSH
60751: LD_INT 0
60753: PUSH
60754: EMPTY
60755: LIST
60756: LIST
60757: LIST
60758: LIST
60759: LIST
60760: LIST
60761: LIST
60762: PUSH
60763: EMPTY
60764: LIST
60765: PPUSH
60766: CALL_OW 446
60770: GO 60694
60772: POP
60773: POP
// end ;
60774: LD_VAR 0 3
60778: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60779: LD_INT 0
60781: PPUSH
60782: PPUSH
60783: PPUSH
60784: PPUSH
60785: PPUSH
60786: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
60787: LD_VAR 0 1
60791: NOT
60792: PUSH
60793: LD_VAR 0 1
60797: PPUSH
60798: CALL_OW 263
60802: PUSH
60803: LD_INT 2
60805: NONEQUAL
60806: OR
60807: IFFALSE 60811
// exit ;
60809: GO 61127
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60811: LD_ADDR_VAR 0 6
60815: PUSH
60816: LD_INT 22
60818: PUSH
60819: LD_VAR 0 1
60823: PPUSH
60824: CALL_OW 255
60828: PUSH
60829: EMPTY
60830: LIST
60831: LIST
60832: PUSH
60833: LD_INT 2
60835: PUSH
60836: LD_INT 30
60838: PUSH
60839: LD_INT 36
60841: PUSH
60842: EMPTY
60843: LIST
60844: LIST
60845: PUSH
60846: LD_INT 34
60848: PUSH
60849: LD_INT 31
60851: PUSH
60852: EMPTY
60853: LIST
60854: LIST
60855: PUSH
60856: EMPTY
60857: LIST
60858: LIST
60859: LIST
60860: PUSH
60861: EMPTY
60862: LIST
60863: LIST
60864: PPUSH
60865: CALL_OW 69
60869: ST_TO_ADDR
// if not tmp then
60870: LD_VAR 0 6
60874: NOT
60875: IFFALSE 60879
// exit ;
60877: GO 61127
// result := [ ] ;
60879: LD_ADDR_VAR 0 2
60883: PUSH
60884: EMPTY
60885: ST_TO_ADDR
// for i in tmp do
60886: LD_ADDR_VAR 0 3
60890: PUSH
60891: LD_VAR 0 6
60895: PUSH
60896: FOR_IN
60897: IFFALSE 60968
// begin t := UnitsInside ( i ) ;
60899: LD_ADDR_VAR 0 4
60903: PUSH
60904: LD_VAR 0 3
60908: PPUSH
60909: CALL_OW 313
60913: ST_TO_ADDR
// if t then
60914: LD_VAR 0 4
60918: IFFALSE 60966
// for j in t do
60920: LD_ADDR_VAR 0 7
60924: PUSH
60925: LD_VAR 0 4
60929: PUSH
60930: FOR_IN
60931: IFFALSE 60964
// result := Replace ( result , result + 1 , j ) ;
60933: LD_ADDR_VAR 0 2
60937: PUSH
60938: LD_VAR 0 2
60942: PPUSH
60943: LD_VAR 0 2
60947: PUSH
60948: LD_INT 1
60950: PLUS
60951: PPUSH
60952: LD_VAR 0 7
60956: PPUSH
60957: CALL_OW 1
60961: ST_TO_ADDR
60962: GO 60930
60964: POP
60965: POP
// end ;
60966: GO 60896
60968: POP
60969: POP
// if not result then
60970: LD_VAR 0 2
60974: NOT
60975: IFFALSE 60979
// exit ;
60977: GO 61127
// mech := result [ 1 ] ;
60979: LD_ADDR_VAR 0 5
60983: PUSH
60984: LD_VAR 0 2
60988: PUSH
60989: LD_INT 1
60991: ARRAY
60992: ST_TO_ADDR
// if result > 1 then
60993: LD_VAR 0 2
60997: PUSH
60998: LD_INT 1
61000: GREATER
61001: IFFALSE 61113
// begin for i = 2 to result do
61003: LD_ADDR_VAR 0 3
61007: PUSH
61008: DOUBLE
61009: LD_INT 2
61011: DEC
61012: ST_TO_ADDR
61013: LD_VAR 0 2
61017: PUSH
61018: FOR_TO
61019: IFFALSE 61111
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
61021: LD_ADDR_VAR 0 4
61025: PUSH
61026: LD_VAR 0 2
61030: PUSH
61031: LD_VAR 0 3
61035: ARRAY
61036: PPUSH
61037: LD_INT 3
61039: PPUSH
61040: CALL_OW 259
61044: PUSH
61045: LD_VAR 0 2
61049: PUSH
61050: LD_VAR 0 3
61054: ARRAY
61055: PPUSH
61056: CALL_OW 432
61060: MINUS
61061: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
61062: LD_VAR 0 4
61066: PUSH
61067: LD_VAR 0 5
61071: PPUSH
61072: LD_INT 3
61074: PPUSH
61075: CALL_OW 259
61079: PUSH
61080: LD_VAR 0 5
61084: PPUSH
61085: CALL_OW 432
61089: MINUS
61090: GREATEREQUAL
61091: IFFALSE 61109
// mech := result [ i ] ;
61093: LD_ADDR_VAR 0 5
61097: PUSH
61098: LD_VAR 0 2
61102: PUSH
61103: LD_VAR 0 3
61107: ARRAY
61108: ST_TO_ADDR
// end ;
61109: GO 61018
61111: POP
61112: POP
// end ; ComLinkTo ( vehicle , mech ) ;
61113: LD_VAR 0 1
61117: PPUSH
61118: LD_VAR 0 5
61122: PPUSH
61123: CALL_OW 135
// end ;
61127: LD_VAR 0 2
61131: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61132: LD_INT 0
61134: PPUSH
61135: PPUSH
61136: PPUSH
61137: PPUSH
61138: PPUSH
61139: PPUSH
61140: PPUSH
61141: PPUSH
61142: PPUSH
61143: PPUSH
61144: PPUSH
61145: PPUSH
61146: PPUSH
// result := [ ] ;
61147: LD_ADDR_VAR 0 7
61151: PUSH
61152: EMPTY
61153: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
61154: LD_VAR 0 1
61158: PPUSH
61159: CALL_OW 266
61163: PUSH
61164: LD_INT 0
61166: PUSH
61167: LD_INT 1
61169: PUSH
61170: EMPTY
61171: LIST
61172: LIST
61173: IN
61174: NOT
61175: IFFALSE 61179
// exit ;
61177: GO 62813
// if name then
61179: LD_VAR 0 3
61183: IFFALSE 61199
// SetBName ( base_dep , name ) ;
61185: LD_VAR 0 1
61189: PPUSH
61190: LD_VAR 0 3
61194: PPUSH
61195: CALL_OW 500
// base := GetBase ( base_dep ) ;
61199: LD_ADDR_VAR 0 15
61203: PUSH
61204: LD_VAR 0 1
61208: PPUSH
61209: CALL_OW 274
61213: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61214: LD_ADDR_VAR 0 16
61218: PUSH
61219: LD_VAR 0 1
61223: PPUSH
61224: CALL_OW 255
61228: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61229: LD_ADDR_VAR 0 17
61233: PUSH
61234: LD_VAR 0 1
61238: PPUSH
61239: CALL_OW 248
61243: ST_TO_ADDR
// if sources then
61244: LD_VAR 0 5
61248: IFFALSE 61295
// for i = 1 to 3 do
61250: LD_ADDR_VAR 0 8
61254: PUSH
61255: DOUBLE
61256: LD_INT 1
61258: DEC
61259: ST_TO_ADDR
61260: LD_INT 3
61262: PUSH
61263: FOR_TO
61264: IFFALSE 61293
// AddResourceType ( base , i , sources [ i ] ) ;
61266: LD_VAR 0 15
61270: PPUSH
61271: LD_VAR 0 8
61275: PPUSH
61276: LD_VAR 0 5
61280: PUSH
61281: LD_VAR 0 8
61285: ARRAY
61286: PPUSH
61287: CALL_OW 276
61291: GO 61263
61293: POP
61294: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
61295: LD_ADDR_VAR 0 18
61299: PUSH
61300: LD_VAR 0 15
61304: PPUSH
61305: LD_VAR 0 2
61309: PPUSH
61310: LD_INT 1
61312: PPUSH
61313: CALL 60556 0 3
61317: ST_TO_ADDR
// InitHc ;
61318: CALL_OW 19
// InitUc ;
61322: CALL_OW 18
// uc_side := side ;
61326: LD_ADDR_OWVAR 20
61330: PUSH
61331: LD_VAR 0 16
61335: ST_TO_ADDR
// uc_nation := nation ;
61336: LD_ADDR_OWVAR 21
61340: PUSH
61341: LD_VAR 0 17
61345: ST_TO_ADDR
// if buildings then
61346: LD_VAR 0 18
61350: IFFALSE 62672
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61352: LD_ADDR_VAR 0 19
61356: PUSH
61357: LD_VAR 0 18
61361: PPUSH
61362: LD_INT 2
61364: PUSH
61365: LD_INT 30
61367: PUSH
61368: LD_INT 29
61370: PUSH
61371: EMPTY
61372: LIST
61373: LIST
61374: PUSH
61375: LD_INT 30
61377: PUSH
61378: LD_INT 30
61380: PUSH
61381: EMPTY
61382: LIST
61383: LIST
61384: PUSH
61385: EMPTY
61386: LIST
61387: LIST
61388: LIST
61389: PPUSH
61390: CALL_OW 72
61394: ST_TO_ADDR
// if tmp then
61395: LD_VAR 0 19
61399: IFFALSE 61447
// for i in tmp do
61401: LD_ADDR_VAR 0 8
61405: PUSH
61406: LD_VAR 0 19
61410: PUSH
61411: FOR_IN
61412: IFFALSE 61445
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61414: LD_VAR 0 8
61418: PPUSH
61419: CALL_OW 250
61423: PPUSH
61424: LD_VAR 0 8
61428: PPUSH
61429: CALL_OW 251
61433: PPUSH
61434: LD_VAR 0 16
61438: PPUSH
61439: CALL_OW 441
61443: GO 61411
61445: POP
61446: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61447: LD_VAR 0 18
61451: PPUSH
61452: LD_INT 2
61454: PUSH
61455: LD_INT 30
61457: PUSH
61458: LD_INT 32
61460: PUSH
61461: EMPTY
61462: LIST
61463: LIST
61464: PUSH
61465: LD_INT 30
61467: PUSH
61468: LD_INT 33
61470: PUSH
61471: EMPTY
61472: LIST
61473: LIST
61474: PUSH
61475: EMPTY
61476: LIST
61477: LIST
61478: LIST
61479: PPUSH
61480: CALL_OW 72
61484: IFFALSE 61572
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61486: LD_ADDR_VAR 0 8
61490: PUSH
61491: LD_VAR 0 18
61495: PPUSH
61496: LD_INT 2
61498: PUSH
61499: LD_INT 30
61501: PUSH
61502: LD_INT 32
61504: PUSH
61505: EMPTY
61506: LIST
61507: LIST
61508: PUSH
61509: LD_INT 30
61511: PUSH
61512: LD_INT 33
61514: PUSH
61515: EMPTY
61516: LIST
61517: LIST
61518: PUSH
61519: EMPTY
61520: LIST
61521: LIST
61522: LIST
61523: PPUSH
61524: CALL_OW 72
61528: PUSH
61529: FOR_IN
61530: IFFALSE 61570
// begin if not GetBWeapon ( i ) then
61532: LD_VAR 0 8
61536: PPUSH
61537: CALL_OW 269
61541: NOT
61542: IFFALSE 61568
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61544: LD_VAR 0 8
61548: PPUSH
61549: LD_VAR 0 8
61553: PPUSH
61554: LD_VAR 0 2
61558: PPUSH
61559: CALL 62818 0 2
61563: PPUSH
61564: CALL_OW 431
// end ;
61568: GO 61529
61570: POP
61571: POP
// end ; for i = 1 to personel do
61572: LD_ADDR_VAR 0 8
61576: PUSH
61577: DOUBLE
61578: LD_INT 1
61580: DEC
61581: ST_TO_ADDR
61582: LD_VAR 0 6
61586: PUSH
61587: FOR_TO
61588: IFFALSE 62652
// begin if i > 4 then
61590: LD_VAR 0 8
61594: PUSH
61595: LD_INT 4
61597: GREATER
61598: IFFALSE 61602
// break ;
61600: GO 62652
// case i of 1 :
61602: LD_VAR 0 8
61606: PUSH
61607: LD_INT 1
61609: DOUBLE
61610: EQUAL
61611: IFTRUE 61615
61613: GO 61695
61615: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61616: LD_ADDR_VAR 0 12
61620: PUSH
61621: LD_VAR 0 18
61625: PPUSH
61626: LD_INT 22
61628: PUSH
61629: LD_VAR 0 16
61633: PUSH
61634: EMPTY
61635: LIST
61636: LIST
61637: PUSH
61638: LD_INT 58
61640: PUSH
61641: EMPTY
61642: LIST
61643: PUSH
61644: LD_INT 2
61646: PUSH
61647: LD_INT 30
61649: PUSH
61650: LD_INT 32
61652: PUSH
61653: EMPTY
61654: LIST
61655: LIST
61656: PUSH
61657: LD_INT 30
61659: PUSH
61660: LD_INT 4
61662: PUSH
61663: EMPTY
61664: LIST
61665: LIST
61666: PUSH
61667: LD_INT 30
61669: PUSH
61670: LD_INT 5
61672: PUSH
61673: EMPTY
61674: LIST
61675: LIST
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: LIST
61681: LIST
61682: PUSH
61683: EMPTY
61684: LIST
61685: LIST
61686: LIST
61687: PPUSH
61688: CALL_OW 72
61692: ST_TO_ADDR
61693: GO 61917
61695: LD_INT 2
61697: DOUBLE
61698: EQUAL
61699: IFTRUE 61703
61701: GO 61765
61703: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61704: LD_ADDR_VAR 0 12
61708: PUSH
61709: LD_VAR 0 18
61713: PPUSH
61714: LD_INT 22
61716: PUSH
61717: LD_VAR 0 16
61721: PUSH
61722: EMPTY
61723: LIST
61724: LIST
61725: PUSH
61726: LD_INT 2
61728: PUSH
61729: LD_INT 30
61731: PUSH
61732: LD_INT 0
61734: PUSH
61735: EMPTY
61736: LIST
61737: LIST
61738: PUSH
61739: LD_INT 30
61741: PUSH
61742: LD_INT 1
61744: PUSH
61745: EMPTY
61746: LIST
61747: LIST
61748: PUSH
61749: EMPTY
61750: LIST
61751: LIST
61752: LIST
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: PPUSH
61758: CALL_OW 72
61762: ST_TO_ADDR
61763: GO 61917
61765: LD_INT 3
61767: DOUBLE
61768: EQUAL
61769: IFTRUE 61773
61771: GO 61835
61773: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61774: LD_ADDR_VAR 0 12
61778: PUSH
61779: LD_VAR 0 18
61783: PPUSH
61784: LD_INT 22
61786: PUSH
61787: LD_VAR 0 16
61791: PUSH
61792: EMPTY
61793: LIST
61794: LIST
61795: PUSH
61796: LD_INT 2
61798: PUSH
61799: LD_INT 30
61801: PUSH
61802: LD_INT 2
61804: PUSH
61805: EMPTY
61806: LIST
61807: LIST
61808: PUSH
61809: LD_INT 30
61811: PUSH
61812: LD_INT 3
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: PUSH
61819: EMPTY
61820: LIST
61821: LIST
61822: LIST
61823: PUSH
61824: EMPTY
61825: LIST
61826: LIST
61827: PPUSH
61828: CALL_OW 72
61832: ST_TO_ADDR
61833: GO 61917
61835: LD_INT 4
61837: DOUBLE
61838: EQUAL
61839: IFTRUE 61843
61841: GO 61916
61843: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61844: LD_ADDR_VAR 0 12
61848: PUSH
61849: LD_VAR 0 18
61853: PPUSH
61854: LD_INT 22
61856: PUSH
61857: LD_VAR 0 16
61861: PUSH
61862: EMPTY
61863: LIST
61864: LIST
61865: PUSH
61866: LD_INT 2
61868: PUSH
61869: LD_INT 30
61871: PUSH
61872: LD_INT 6
61874: PUSH
61875: EMPTY
61876: LIST
61877: LIST
61878: PUSH
61879: LD_INT 30
61881: PUSH
61882: LD_INT 7
61884: PUSH
61885: EMPTY
61886: LIST
61887: LIST
61888: PUSH
61889: LD_INT 30
61891: PUSH
61892: LD_INT 8
61894: PUSH
61895: EMPTY
61896: LIST
61897: LIST
61898: PUSH
61899: EMPTY
61900: LIST
61901: LIST
61902: LIST
61903: LIST
61904: PUSH
61905: EMPTY
61906: LIST
61907: LIST
61908: PPUSH
61909: CALL_OW 72
61913: ST_TO_ADDR
61914: GO 61917
61916: POP
// if i = 1 then
61917: LD_VAR 0 8
61921: PUSH
61922: LD_INT 1
61924: EQUAL
61925: IFFALSE 62036
// begin tmp := [ ] ;
61927: LD_ADDR_VAR 0 19
61931: PUSH
61932: EMPTY
61933: ST_TO_ADDR
// for j in f do
61934: LD_ADDR_VAR 0 9
61938: PUSH
61939: LD_VAR 0 12
61943: PUSH
61944: FOR_IN
61945: IFFALSE 62018
// if GetBType ( j ) = b_bunker then
61947: LD_VAR 0 9
61951: PPUSH
61952: CALL_OW 266
61956: PUSH
61957: LD_INT 32
61959: EQUAL
61960: IFFALSE 61987
// tmp := Insert ( tmp , 1 , j ) else
61962: LD_ADDR_VAR 0 19
61966: PUSH
61967: LD_VAR 0 19
61971: PPUSH
61972: LD_INT 1
61974: PPUSH
61975: LD_VAR 0 9
61979: PPUSH
61980: CALL_OW 2
61984: ST_TO_ADDR
61985: GO 62016
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61987: LD_ADDR_VAR 0 19
61991: PUSH
61992: LD_VAR 0 19
61996: PPUSH
61997: LD_VAR 0 19
62001: PUSH
62002: LD_INT 1
62004: PLUS
62005: PPUSH
62006: LD_VAR 0 9
62010: PPUSH
62011: CALL_OW 2
62015: ST_TO_ADDR
62016: GO 61944
62018: POP
62019: POP
// if tmp then
62020: LD_VAR 0 19
62024: IFFALSE 62036
// f := tmp ;
62026: LD_ADDR_VAR 0 12
62030: PUSH
62031: LD_VAR 0 19
62035: ST_TO_ADDR
// end ; x := personel [ i ] ;
62036: LD_ADDR_VAR 0 13
62040: PUSH
62041: LD_VAR 0 6
62045: PUSH
62046: LD_VAR 0 8
62050: ARRAY
62051: ST_TO_ADDR
// if x = - 1 then
62052: LD_VAR 0 13
62056: PUSH
62057: LD_INT 1
62059: NEG
62060: EQUAL
62061: IFFALSE 62270
// begin for j in f do
62063: LD_ADDR_VAR 0 9
62067: PUSH
62068: LD_VAR 0 12
62072: PUSH
62073: FOR_IN
62074: IFFALSE 62266
// repeat InitHc ;
62076: CALL_OW 19
// if GetBType ( j ) = b_barracks then
62080: LD_VAR 0 9
62084: PPUSH
62085: CALL_OW 266
62089: PUSH
62090: LD_INT 5
62092: EQUAL
62093: IFFALSE 62163
// begin if UnitsInside ( j ) < 3 then
62095: LD_VAR 0 9
62099: PPUSH
62100: CALL_OW 313
62104: PUSH
62105: LD_INT 3
62107: LESS
62108: IFFALSE 62144
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62110: LD_INT 0
62112: PPUSH
62113: LD_INT 5
62115: PUSH
62116: LD_INT 8
62118: PUSH
62119: LD_INT 9
62121: PUSH
62122: EMPTY
62123: LIST
62124: LIST
62125: LIST
62126: PUSH
62127: LD_VAR 0 17
62131: ARRAY
62132: PPUSH
62133: LD_VAR 0 4
62137: PPUSH
62138: CALL_OW 380
62142: GO 62161
// PrepareHuman ( false , i , skill ) ;
62144: LD_INT 0
62146: PPUSH
62147: LD_VAR 0 8
62151: PPUSH
62152: LD_VAR 0 4
62156: PPUSH
62157: CALL_OW 380
// end else
62161: GO 62180
// PrepareHuman ( false , i , skill ) ;
62163: LD_INT 0
62165: PPUSH
62166: LD_VAR 0 8
62170: PPUSH
62171: LD_VAR 0 4
62175: PPUSH
62176: CALL_OW 380
// un := CreateHuman ;
62180: LD_ADDR_VAR 0 14
62184: PUSH
62185: CALL_OW 44
62189: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62190: LD_ADDR_VAR 0 7
62194: PUSH
62195: LD_VAR 0 7
62199: PPUSH
62200: LD_INT 1
62202: PPUSH
62203: LD_VAR 0 14
62207: PPUSH
62208: CALL_OW 2
62212: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62213: LD_VAR 0 14
62217: PPUSH
62218: LD_VAR 0 9
62222: PPUSH
62223: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62227: LD_VAR 0 9
62231: PPUSH
62232: CALL_OW 313
62236: PUSH
62237: LD_INT 6
62239: EQUAL
62240: PUSH
62241: LD_VAR 0 9
62245: PPUSH
62246: CALL_OW 266
62250: PUSH
62251: LD_INT 32
62253: PUSH
62254: LD_INT 31
62256: PUSH
62257: EMPTY
62258: LIST
62259: LIST
62260: IN
62261: OR
62262: IFFALSE 62076
62264: GO 62073
62266: POP
62267: POP
// end else
62268: GO 62650
// for j = 1 to x do
62270: LD_ADDR_VAR 0 9
62274: PUSH
62275: DOUBLE
62276: LD_INT 1
62278: DEC
62279: ST_TO_ADDR
62280: LD_VAR 0 13
62284: PUSH
62285: FOR_TO
62286: IFFALSE 62648
// begin InitHc ;
62288: CALL_OW 19
// if not f then
62292: LD_VAR 0 12
62296: NOT
62297: IFFALSE 62386
// begin PrepareHuman ( false , i , skill ) ;
62299: LD_INT 0
62301: PPUSH
62302: LD_VAR 0 8
62306: PPUSH
62307: LD_VAR 0 4
62311: PPUSH
62312: CALL_OW 380
// un := CreateHuman ;
62316: LD_ADDR_VAR 0 14
62320: PUSH
62321: CALL_OW 44
62325: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62326: LD_ADDR_VAR 0 7
62330: PUSH
62331: LD_VAR 0 7
62335: PPUSH
62336: LD_INT 1
62338: PPUSH
62339: LD_VAR 0 14
62343: PPUSH
62344: CALL_OW 2
62348: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62349: LD_VAR 0 14
62353: PPUSH
62354: LD_VAR 0 1
62358: PPUSH
62359: CALL_OW 250
62363: PPUSH
62364: LD_VAR 0 1
62368: PPUSH
62369: CALL_OW 251
62373: PPUSH
62374: LD_INT 10
62376: PPUSH
62377: LD_INT 0
62379: PPUSH
62380: CALL_OW 50
// continue ;
62384: GO 62285
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62386: LD_VAR 0 12
62390: PUSH
62391: LD_INT 1
62393: ARRAY
62394: PPUSH
62395: CALL_OW 313
62399: PUSH
62400: LD_VAR 0 12
62404: PUSH
62405: LD_INT 1
62407: ARRAY
62408: PPUSH
62409: CALL_OW 266
62413: PUSH
62414: LD_INT 32
62416: PUSH
62417: LD_INT 31
62419: PUSH
62420: EMPTY
62421: LIST
62422: LIST
62423: IN
62424: AND
62425: PUSH
62426: LD_VAR 0 12
62430: PUSH
62431: LD_INT 1
62433: ARRAY
62434: PPUSH
62435: CALL_OW 313
62439: PUSH
62440: LD_INT 6
62442: EQUAL
62443: OR
62444: IFFALSE 62464
// f := Delete ( f , 1 ) ;
62446: LD_ADDR_VAR 0 12
62450: PUSH
62451: LD_VAR 0 12
62455: PPUSH
62456: LD_INT 1
62458: PPUSH
62459: CALL_OW 3
62463: ST_TO_ADDR
// if not f then
62464: LD_VAR 0 12
62468: NOT
62469: IFFALSE 62487
// begin x := x + 2 ;
62471: LD_ADDR_VAR 0 13
62475: PUSH
62476: LD_VAR 0 13
62480: PUSH
62481: LD_INT 2
62483: PLUS
62484: ST_TO_ADDR
// continue ;
62485: GO 62285
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62487: LD_VAR 0 12
62491: PUSH
62492: LD_INT 1
62494: ARRAY
62495: PPUSH
62496: CALL_OW 266
62500: PUSH
62501: LD_INT 5
62503: EQUAL
62504: IFFALSE 62578
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62506: LD_VAR 0 12
62510: PUSH
62511: LD_INT 1
62513: ARRAY
62514: PPUSH
62515: CALL_OW 313
62519: PUSH
62520: LD_INT 3
62522: LESS
62523: IFFALSE 62559
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62525: LD_INT 0
62527: PPUSH
62528: LD_INT 5
62530: PUSH
62531: LD_INT 8
62533: PUSH
62534: LD_INT 9
62536: PUSH
62537: EMPTY
62538: LIST
62539: LIST
62540: LIST
62541: PUSH
62542: LD_VAR 0 17
62546: ARRAY
62547: PPUSH
62548: LD_VAR 0 4
62552: PPUSH
62553: CALL_OW 380
62557: GO 62576
// PrepareHuman ( false , i , skill ) ;
62559: LD_INT 0
62561: PPUSH
62562: LD_VAR 0 8
62566: PPUSH
62567: LD_VAR 0 4
62571: PPUSH
62572: CALL_OW 380
// end else
62576: GO 62595
// PrepareHuman ( false , i , skill ) ;
62578: LD_INT 0
62580: PPUSH
62581: LD_VAR 0 8
62585: PPUSH
62586: LD_VAR 0 4
62590: PPUSH
62591: CALL_OW 380
// un := CreateHuman ;
62595: LD_ADDR_VAR 0 14
62599: PUSH
62600: CALL_OW 44
62604: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62605: LD_ADDR_VAR 0 7
62609: PUSH
62610: LD_VAR 0 7
62614: PPUSH
62615: LD_INT 1
62617: PPUSH
62618: LD_VAR 0 14
62622: PPUSH
62623: CALL_OW 2
62627: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62628: LD_VAR 0 14
62632: PPUSH
62633: LD_VAR 0 12
62637: PUSH
62638: LD_INT 1
62640: ARRAY
62641: PPUSH
62642: CALL_OW 52
// end ;
62646: GO 62285
62648: POP
62649: POP
// end ;
62650: GO 61587
62652: POP
62653: POP
// result := result ^ buildings ;
62654: LD_ADDR_VAR 0 7
62658: PUSH
62659: LD_VAR 0 7
62663: PUSH
62664: LD_VAR 0 18
62668: ADD
62669: ST_TO_ADDR
// end else
62670: GO 62813
// begin for i = 1 to personel do
62672: LD_ADDR_VAR 0 8
62676: PUSH
62677: DOUBLE
62678: LD_INT 1
62680: DEC
62681: ST_TO_ADDR
62682: LD_VAR 0 6
62686: PUSH
62687: FOR_TO
62688: IFFALSE 62811
// begin if i > 4 then
62690: LD_VAR 0 8
62694: PUSH
62695: LD_INT 4
62697: GREATER
62698: IFFALSE 62702
// break ;
62700: GO 62811
// x := personel [ i ] ;
62702: LD_ADDR_VAR 0 13
62706: PUSH
62707: LD_VAR 0 6
62711: PUSH
62712: LD_VAR 0 8
62716: ARRAY
62717: ST_TO_ADDR
// if x = - 1 then
62718: LD_VAR 0 13
62722: PUSH
62723: LD_INT 1
62725: NEG
62726: EQUAL
62727: IFFALSE 62731
// continue ;
62729: GO 62687
// PrepareHuman ( false , i , skill ) ;
62731: LD_INT 0
62733: PPUSH
62734: LD_VAR 0 8
62738: PPUSH
62739: LD_VAR 0 4
62743: PPUSH
62744: CALL_OW 380
// un := CreateHuman ;
62748: LD_ADDR_VAR 0 14
62752: PUSH
62753: CALL_OW 44
62757: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62758: LD_VAR 0 14
62762: PPUSH
62763: LD_VAR 0 1
62767: PPUSH
62768: CALL_OW 250
62772: PPUSH
62773: LD_VAR 0 1
62777: PPUSH
62778: CALL_OW 251
62782: PPUSH
62783: LD_INT 10
62785: PPUSH
62786: LD_INT 0
62788: PPUSH
62789: CALL_OW 50
// result := result ^ un ;
62793: LD_ADDR_VAR 0 7
62797: PUSH
62798: LD_VAR 0 7
62802: PUSH
62803: LD_VAR 0 14
62807: ADD
62808: ST_TO_ADDR
// end ;
62809: GO 62687
62811: POP
62812: POP
// end ; end ;
62813: LD_VAR 0 7
62817: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62818: LD_INT 0
62820: PPUSH
62821: PPUSH
62822: PPUSH
62823: PPUSH
62824: PPUSH
62825: PPUSH
62826: PPUSH
62827: PPUSH
62828: PPUSH
62829: PPUSH
62830: PPUSH
62831: PPUSH
62832: PPUSH
62833: PPUSH
62834: PPUSH
62835: PPUSH
// result := false ;
62836: LD_ADDR_VAR 0 3
62840: PUSH
62841: LD_INT 0
62843: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62844: LD_VAR 0 1
62848: NOT
62849: PUSH
62850: LD_VAR 0 1
62854: PPUSH
62855: CALL_OW 266
62859: PUSH
62860: LD_INT 32
62862: PUSH
62863: LD_INT 33
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: IN
62870: NOT
62871: OR
62872: IFFALSE 62876
// exit ;
62874: GO 63985
// nat := GetNation ( tower ) ;
62876: LD_ADDR_VAR 0 12
62880: PUSH
62881: LD_VAR 0 1
62885: PPUSH
62886: CALL_OW 248
62890: ST_TO_ADDR
// side := GetSide ( tower ) ;
62891: LD_ADDR_VAR 0 16
62895: PUSH
62896: LD_VAR 0 1
62900: PPUSH
62901: CALL_OW 255
62905: ST_TO_ADDR
// x := GetX ( tower ) ;
62906: LD_ADDR_VAR 0 10
62910: PUSH
62911: LD_VAR 0 1
62915: PPUSH
62916: CALL_OW 250
62920: ST_TO_ADDR
// y := GetY ( tower ) ;
62921: LD_ADDR_VAR 0 11
62925: PUSH
62926: LD_VAR 0 1
62930: PPUSH
62931: CALL_OW 251
62935: ST_TO_ADDR
// if not x or not y then
62936: LD_VAR 0 10
62940: NOT
62941: PUSH
62942: LD_VAR 0 11
62946: NOT
62947: OR
62948: IFFALSE 62952
// exit ;
62950: GO 63985
// weapon := 0 ;
62952: LD_ADDR_VAR 0 18
62956: PUSH
62957: LD_INT 0
62959: ST_TO_ADDR
// fac_list := [ ] ;
62960: LD_ADDR_VAR 0 17
62964: PUSH
62965: EMPTY
62966: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62967: LD_ADDR_VAR 0 6
62971: PUSH
62972: LD_VAR 0 1
62976: PPUSH
62977: CALL_OW 274
62981: PPUSH
62982: LD_VAR 0 2
62986: PPUSH
62987: LD_INT 0
62989: PPUSH
62990: CALL 60556 0 3
62994: PPUSH
62995: LD_INT 30
62997: PUSH
62998: LD_INT 3
63000: PUSH
63001: EMPTY
63002: LIST
63003: LIST
63004: PPUSH
63005: CALL_OW 72
63009: ST_TO_ADDR
// if not factories then
63010: LD_VAR 0 6
63014: NOT
63015: IFFALSE 63019
// exit ;
63017: GO 63985
// for i in factories do
63019: LD_ADDR_VAR 0 8
63023: PUSH
63024: LD_VAR 0 6
63028: PUSH
63029: FOR_IN
63030: IFFALSE 63055
// fac_list := fac_list union AvailableWeaponList ( i ) ;
63032: LD_ADDR_VAR 0 17
63036: PUSH
63037: LD_VAR 0 17
63041: PUSH
63042: LD_VAR 0 8
63046: PPUSH
63047: CALL_OW 478
63051: UNION
63052: ST_TO_ADDR
63053: GO 63029
63055: POP
63056: POP
// if not fac_list then
63057: LD_VAR 0 17
63061: NOT
63062: IFFALSE 63066
// exit ;
63064: GO 63985
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
63066: LD_ADDR_VAR 0 5
63070: PUSH
63071: LD_INT 4
63073: PUSH
63074: LD_INT 5
63076: PUSH
63077: LD_INT 9
63079: PUSH
63080: LD_INT 10
63082: PUSH
63083: LD_INT 6
63085: PUSH
63086: LD_INT 7
63088: PUSH
63089: LD_INT 11
63091: PUSH
63092: EMPTY
63093: LIST
63094: LIST
63095: LIST
63096: LIST
63097: LIST
63098: LIST
63099: LIST
63100: PUSH
63101: LD_INT 27
63103: PUSH
63104: LD_INT 28
63106: PUSH
63107: LD_INT 26
63109: PUSH
63110: LD_INT 30
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: LIST
63117: LIST
63118: PUSH
63119: LD_INT 43
63121: PUSH
63122: LD_INT 44
63124: PUSH
63125: LD_INT 46
63127: PUSH
63128: LD_INT 45
63130: PUSH
63131: LD_INT 47
63133: PUSH
63134: LD_INT 49
63136: PUSH
63137: EMPTY
63138: LIST
63139: LIST
63140: LIST
63141: LIST
63142: LIST
63143: LIST
63144: PUSH
63145: EMPTY
63146: LIST
63147: LIST
63148: LIST
63149: PUSH
63150: LD_VAR 0 12
63154: ARRAY
63155: ST_TO_ADDR
// list := list isect fac_list ;
63156: LD_ADDR_VAR 0 5
63160: PUSH
63161: LD_VAR 0 5
63165: PUSH
63166: LD_VAR 0 17
63170: ISECT
63171: ST_TO_ADDR
// if not list then
63172: LD_VAR 0 5
63176: NOT
63177: IFFALSE 63181
// exit ;
63179: GO 63985
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63181: LD_VAR 0 12
63185: PUSH
63186: LD_INT 3
63188: EQUAL
63189: PUSH
63190: LD_INT 49
63192: PUSH
63193: LD_VAR 0 5
63197: IN
63198: AND
63199: PUSH
63200: LD_INT 31
63202: PPUSH
63203: LD_VAR 0 16
63207: PPUSH
63208: CALL_OW 321
63212: PUSH
63213: LD_INT 2
63215: EQUAL
63216: AND
63217: IFFALSE 63277
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63219: LD_INT 22
63221: PUSH
63222: LD_VAR 0 16
63226: PUSH
63227: EMPTY
63228: LIST
63229: LIST
63230: PUSH
63231: LD_INT 35
63233: PUSH
63234: LD_INT 49
63236: PUSH
63237: EMPTY
63238: LIST
63239: LIST
63240: PUSH
63241: LD_INT 91
63243: PUSH
63244: LD_VAR 0 1
63248: PUSH
63249: LD_INT 10
63251: PUSH
63252: EMPTY
63253: LIST
63254: LIST
63255: LIST
63256: PUSH
63257: EMPTY
63258: LIST
63259: LIST
63260: LIST
63261: PPUSH
63262: CALL_OW 69
63266: NOT
63267: IFFALSE 63277
// weapon := ru_time_lapser ;
63269: LD_ADDR_VAR 0 18
63273: PUSH
63274: LD_INT 49
63276: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63277: LD_VAR 0 12
63281: PUSH
63282: LD_INT 1
63284: PUSH
63285: LD_INT 2
63287: PUSH
63288: EMPTY
63289: LIST
63290: LIST
63291: IN
63292: PUSH
63293: LD_INT 11
63295: PUSH
63296: LD_VAR 0 5
63300: IN
63301: PUSH
63302: LD_INT 30
63304: PUSH
63305: LD_VAR 0 5
63309: IN
63310: OR
63311: AND
63312: PUSH
63313: LD_INT 6
63315: PPUSH
63316: LD_VAR 0 16
63320: PPUSH
63321: CALL_OW 321
63325: PUSH
63326: LD_INT 2
63328: EQUAL
63329: AND
63330: IFFALSE 63495
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63332: LD_INT 22
63334: PUSH
63335: LD_VAR 0 16
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 2
63346: PUSH
63347: LD_INT 35
63349: PUSH
63350: LD_INT 11
63352: PUSH
63353: EMPTY
63354: LIST
63355: LIST
63356: PUSH
63357: LD_INT 35
63359: PUSH
63360: LD_INT 30
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: PUSH
63367: EMPTY
63368: LIST
63369: LIST
63370: LIST
63371: PUSH
63372: LD_INT 91
63374: PUSH
63375: LD_VAR 0 1
63379: PUSH
63380: LD_INT 18
63382: PUSH
63383: EMPTY
63384: LIST
63385: LIST
63386: LIST
63387: PUSH
63388: EMPTY
63389: LIST
63390: LIST
63391: LIST
63392: PPUSH
63393: CALL_OW 69
63397: NOT
63398: PUSH
63399: LD_INT 22
63401: PUSH
63402: LD_VAR 0 16
63406: PUSH
63407: EMPTY
63408: LIST
63409: LIST
63410: PUSH
63411: LD_INT 2
63413: PUSH
63414: LD_INT 30
63416: PUSH
63417: LD_INT 32
63419: PUSH
63420: EMPTY
63421: LIST
63422: LIST
63423: PUSH
63424: LD_INT 30
63426: PUSH
63427: LD_INT 33
63429: PUSH
63430: EMPTY
63431: LIST
63432: LIST
63433: PUSH
63434: EMPTY
63435: LIST
63436: LIST
63437: LIST
63438: PUSH
63439: LD_INT 91
63441: PUSH
63442: LD_VAR 0 1
63446: PUSH
63447: LD_INT 12
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: LIST
63454: PUSH
63455: EMPTY
63456: LIST
63457: LIST
63458: LIST
63459: PUSH
63460: EMPTY
63461: LIST
63462: PPUSH
63463: CALL_OW 69
63467: PUSH
63468: LD_INT 2
63470: GREATER
63471: AND
63472: IFFALSE 63495
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63474: LD_ADDR_VAR 0 18
63478: PUSH
63479: LD_INT 11
63481: PUSH
63482: LD_INT 30
63484: PUSH
63485: EMPTY
63486: LIST
63487: LIST
63488: PUSH
63489: LD_VAR 0 12
63493: ARRAY
63494: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63495: LD_VAR 0 18
63499: NOT
63500: PUSH
63501: LD_INT 40
63503: PPUSH
63504: LD_VAR 0 16
63508: PPUSH
63509: CALL_OW 321
63513: PUSH
63514: LD_INT 2
63516: EQUAL
63517: AND
63518: PUSH
63519: LD_INT 7
63521: PUSH
63522: LD_VAR 0 5
63526: IN
63527: PUSH
63528: LD_INT 28
63530: PUSH
63531: LD_VAR 0 5
63535: IN
63536: OR
63537: PUSH
63538: LD_INT 45
63540: PUSH
63541: LD_VAR 0 5
63545: IN
63546: OR
63547: AND
63548: IFFALSE 63802
// begin hex := GetHexInfo ( x , y ) ;
63550: LD_ADDR_VAR 0 4
63554: PUSH
63555: LD_VAR 0 10
63559: PPUSH
63560: LD_VAR 0 11
63564: PPUSH
63565: CALL_OW 546
63569: ST_TO_ADDR
// if hex [ 1 ] then
63570: LD_VAR 0 4
63574: PUSH
63575: LD_INT 1
63577: ARRAY
63578: IFFALSE 63582
// exit ;
63580: GO 63985
// height := hex [ 2 ] ;
63582: LD_ADDR_VAR 0 15
63586: PUSH
63587: LD_VAR 0 4
63591: PUSH
63592: LD_INT 2
63594: ARRAY
63595: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63596: LD_ADDR_VAR 0 14
63600: PUSH
63601: LD_INT 0
63603: PUSH
63604: LD_INT 2
63606: PUSH
63607: LD_INT 3
63609: PUSH
63610: LD_INT 5
63612: PUSH
63613: EMPTY
63614: LIST
63615: LIST
63616: LIST
63617: LIST
63618: ST_TO_ADDR
// for i in tmp do
63619: LD_ADDR_VAR 0 8
63623: PUSH
63624: LD_VAR 0 14
63628: PUSH
63629: FOR_IN
63630: IFFALSE 63800
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63632: LD_ADDR_VAR 0 9
63636: PUSH
63637: LD_VAR 0 10
63641: PPUSH
63642: LD_VAR 0 8
63646: PPUSH
63647: LD_INT 5
63649: PPUSH
63650: CALL_OW 272
63654: PUSH
63655: LD_VAR 0 11
63659: PPUSH
63660: LD_VAR 0 8
63664: PPUSH
63665: LD_INT 5
63667: PPUSH
63668: CALL_OW 273
63672: PUSH
63673: EMPTY
63674: LIST
63675: LIST
63676: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63677: LD_VAR 0 9
63681: PUSH
63682: LD_INT 1
63684: ARRAY
63685: PPUSH
63686: LD_VAR 0 9
63690: PUSH
63691: LD_INT 2
63693: ARRAY
63694: PPUSH
63695: CALL_OW 488
63699: IFFALSE 63798
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63701: LD_ADDR_VAR 0 4
63705: PUSH
63706: LD_VAR 0 9
63710: PUSH
63711: LD_INT 1
63713: ARRAY
63714: PPUSH
63715: LD_VAR 0 9
63719: PUSH
63720: LD_INT 2
63722: ARRAY
63723: PPUSH
63724: CALL_OW 546
63728: ST_TO_ADDR
// if hex [ 1 ] then
63729: LD_VAR 0 4
63733: PUSH
63734: LD_INT 1
63736: ARRAY
63737: IFFALSE 63741
// continue ;
63739: GO 63629
// h := hex [ 2 ] ;
63741: LD_ADDR_VAR 0 13
63745: PUSH
63746: LD_VAR 0 4
63750: PUSH
63751: LD_INT 2
63753: ARRAY
63754: ST_TO_ADDR
// if h + 7 < height then
63755: LD_VAR 0 13
63759: PUSH
63760: LD_INT 7
63762: PLUS
63763: PUSH
63764: LD_VAR 0 15
63768: LESS
63769: IFFALSE 63798
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63771: LD_ADDR_VAR 0 18
63775: PUSH
63776: LD_INT 7
63778: PUSH
63779: LD_INT 28
63781: PUSH
63782: LD_INT 45
63784: PUSH
63785: EMPTY
63786: LIST
63787: LIST
63788: LIST
63789: PUSH
63790: LD_VAR 0 12
63794: ARRAY
63795: ST_TO_ADDR
// break ;
63796: GO 63800
// end ; end ; end ;
63798: GO 63629
63800: POP
63801: POP
// end ; if not weapon then
63802: LD_VAR 0 18
63806: NOT
63807: IFFALSE 63867
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63809: LD_ADDR_VAR 0 5
63813: PUSH
63814: LD_VAR 0 5
63818: PUSH
63819: LD_INT 11
63821: PUSH
63822: LD_INT 30
63824: PUSH
63825: LD_INT 49
63827: PUSH
63828: EMPTY
63829: LIST
63830: LIST
63831: LIST
63832: DIFF
63833: ST_TO_ADDR
// if not list then
63834: LD_VAR 0 5
63838: NOT
63839: IFFALSE 63843
// exit ;
63841: GO 63985
// weapon := list [ rand ( 1 , list ) ] ;
63843: LD_ADDR_VAR 0 18
63847: PUSH
63848: LD_VAR 0 5
63852: PUSH
63853: LD_INT 1
63855: PPUSH
63856: LD_VAR 0 5
63860: PPUSH
63861: CALL_OW 12
63865: ARRAY
63866: ST_TO_ADDR
// end ; if weapon then
63867: LD_VAR 0 18
63871: IFFALSE 63985
// begin tmp := CostOfWeapon ( weapon ) ;
63873: LD_ADDR_VAR 0 14
63877: PUSH
63878: LD_VAR 0 18
63882: PPUSH
63883: CALL_OW 451
63887: ST_TO_ADDR
// j := GetBase ( tower ) ;
63888: LD_ADDR_VAR 0 9
63892: PUSH
63893: LD_VAR 0 1
63897: PPUSH
63898: CALL_OW 274
63902: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63903: LD_VAR 0 9
63907: PPUSH
63908: LD_INT 1
63910: PPUSH
63911: CALL_OW 275
63915: PUSH
63916: LD_VAR 0 14
63920: PUSH
63921: LD_INT 1
63923: ARRAY
63924: GREATEREQUAL
63925: PUSH
63926: LD_VAR 0 9
63930: PPUSH
63931: LD_INT 2
63933: PPUSH
63934: CALL_OW 275
63938: PUSH
63939: LD_VAR 0 14
63943: PUSH
63944: LD_INT 2
63946: ARRAY
63947: GREATEREQUAL
63948: AND
63949: PUSH
63950: LD_VAR 0 9
63954: PPUSH
63955: LD_INT 3
63957: PPUSH
63958: CALL_OW 275
63962: PUSH
63963: LD_VAR 0 14
63967: PUSH
63968: LD_INT 3
63970: ARRAY
63971: GREATEREQUAL
63972: AND
63973: IFFALSE 63985
// result := weapon ;
63975: LD_ADDR_VAR 0 3
63979: PUSH
63980: LD_VAR 0 18
63984: ST_TO_ADDR
// end ; end ;
63985: LD_VAR 0 3
63989: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63990: LD_INT 0
63992: PPUSH
63993: PPUSH
// result := true ;
63994: LD_ADDR_VAR 0 3
63998: PUSH
63999: LD_INT 1
64001: ST_TO_ADDR
// if array1 = array2 then
64002: LD_VAR 0 1
64006: PUSH
64007: LD_VAR 0 2
64011: EQUAL
64012: IFFALSE 64072
// begin for i = 1 to array1 do
64014: LD_ADDR_VAR 0 4
64018: PUSH
64019: DOUBLE
64020: LD_INT 1
64022: DEC
64023: ST_TO_ADDR
64024: LD_VAR 0 1
64028: PUSH
64029: FOR_TO
64030: IFFALSE 64068
// if array1 [ i ] <> array2 [ i ] then
64032: LD_VAR 0 1
64036: PUSH
64037: LD_VAR 0 4
64041: ARRAY
64042: PUSH
64043: LD_VAR 0 2
64047: PUSH
64048: LD_VAR 0 4
64052: ARRAY
64053: NONEQUAL
64054: IFFALSE 64066
// begin result := false ;
64056: LD_ADDR_VAR 0 3
64060: PUSH
64061: LD_INT 0
64063: ST_TO_ADDR
// break ;
64064: GO 64068
// end ;
64066: GO 64029
64068: POP
64069: POP
// end else
64070: GO 64080
// result := false ;
64072: LD_ADDR_VAR 0 3
64076: PUSH
64077: LD_INT 0
64079: ST_TO_ADDR
// end ;
64080: LD_VAR 0 3
64084: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
64085: LD_INT 0
64087: PPUSH
64088: PPUSH
// if not array1 or not array2 then
64089: LD_VAR 0 1
64093: NOT
64094: PUSH
64095: LD_VAR 0 2
64099: NOT
64100: OR
64101: IFFALSE 64105
// exit ;
64103: GO 64169
// result := true ;
64105: LD_ADDR_VAR 0 3
64109: PUSH
64110: LD_INT 1
64112: ST_TO_ADDR
// for i = 1 to array1 do
64113: LD_ADDR_VAR 0 4
64117: PUSH
64118: DOUBLE
64119: LD_INT 1
64121: DEC
64122: ST_TO_ADDR
64123: LD_VAR 0 1
64127: PUSH
64128: FOR_TO
64129: IFFALSE 64167
// if array1 [ i ] <> array2 [ i ] then
64131: LD_VAR 0 1
64135: PUSH
64136: LD_VAR 0 4
64140: ARRAY
64141: PUSH
64142: LD_VAR 0 2
64146: PUSH
64147: LD_VAR 0 4
64151: ARRAY
64152: NONEQUAL
64153: IFFALSE 64165
// begin result := false ;
64155: LD_ADDR_VAR 0 3
64159: PUSH
64160: LD_INT 0
64162: ST_TO_ADDR
// break ;
64163: GO 64167
// end ;
64165: GO 64128
64167: POP
64168: POP
// end ;
64169: LD_VAR 0 3
64173: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
64174: LD_INT 0
64176: PPUSH
64177: PPUSH
64178: PPUSH
// pom := GetBase ( fac ) ;
64179: LD_ADDR_VAR 0 5
64183: PUSH
64184: LD_VAR 0 1
64188: PPUSH
64189: CALL_OW 274
64193: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
64194: LD_ADDR_VAR 0 4
64198: PUSH
64199: LD_VAR 0 2
64203: PUSH
64204: LD_INT 1
64206: ARRAY
64207: PPUSH
64208: LD_VAR 0 2
64212: PUSH
64213: LD_INT 2
64215: ARRAY
64216: PPUSH
64217: LD_VAR 0 2
64221: PUSH
64222: LD_INT 3
64224: ARRAY
64225: PPUSH
64226: LD_VAR 0 2
64230: PUSH
64231: LD_INT 4
64233: ARRAY
64234: PPUSH
64235: CALL_OW 449
64239: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64240: LD_ADDR_VAR 0 3
64244: PUSH
64245: LD_VAR 0 5
64249: PPUSH
64250: LD_INT 1
64252: PPUSH
64253: CALL_OW 275
64257: PUSH
64258: LD_VAR 0 4
64262: PUSH
64263: LD_INT 1
64265: ARRAY
64266: GREATEREQUAL
64267: PUSH
64268: LD_VAR 0 5
64272: PPUSH
64273: LD_INT 2
64275: PPUSH
64276: CALL_OW 275
64280: PUSH
64281: LD_VAR 0 4
64285: PUSH
64286: LD_INT 2
64288: ARRAY
64289: GREATEREQUAL
64290: AND
64291: PUSH
64292: LD_VAR 0 5
64296: PPUSH
64297: LD_INT 3
64299: PPUSH
64300: CALL_OW 275
64304: PUSH
64305: LD_VAR 0 4
64309: PUSH
64310: LD_INT 3
64312: ARRAY
64313: GREATEREQUAL
64314: AND
64315: ST_TO_ADDR
// end ;
64316: LD_VAR 0 3
64320: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64321: LD_INT 0
64323: PPUSH
64324: PPUSH
64325: PPUSH
64326: PPUSH
// pom := GetBase ( building ) ;
64327: LD_ADDR_VAR 0 3
64331: PUSH
64332: LD_VAR 0 1
64336: PPUSH
64337: CALL_OW 274
64341: ST_TO_ADDR
// if not pom then
64342: LD_VAR 0 3
64346: NOT
64347: IFFALSE 64351
// exit ;
64349: GO 64521
// btype := GetBType ( building ) ;
64351: LD_ADDR_VAR 0 5
64355: PUSH
64356: LD_VAR 0 1
64360: PPUSH
64361: CALL_OW 266
64365: ST_TO_ADDR
// if btype = b_armoury then
64366: LD_VAR 0 5
64370: PUSH
64371: LD_INT 4
64373: EQUAL
64374: IFFALSE 64384
// btype := b_barracks ;
64376: LD_ADDR_VAR 0 5
64380: PUSH
64381: LD_INT 5
64383: ST_TO_ADDR
// if btype = b_depot then
64384: LD_VAR 0 5
64388: PUSH
64389: LD_INT 0
64391: EQUAL
64392: IFFALSE 64402
// btype := b_warehouse ;
64394: LD_ADDR_VAR 0 5
64398: PUSH
64399: LD_INT 1
64401: ST_TO_ADDR
// if btype = b_workshop then
64402: LD_VAR 0 5
64406: PUSH
64407: LD_INT 2
64409: EQUAL
64410: IFFALSE 64420
// btype := b_factory ;
64412: LD_ADDR_VAR 0 5
64416: PUSH
64417: LD_INT 3
64419: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64420: LD_ADDR_VAR 0 4
64424: PUSH
64425: LD_VAR 0 5
64429: PPUSH
64430: LD_VAR 0 1
64434: PPUSH
64435: CALL_OW 248
64439: PPUSH
64440: CALL_OW 450
64444: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64445: LD_ADDR_VAR 0 2
64449: PUSH
64450: LD_VAR 0 3
64454: PPUSH
64455: LD_INT 1
64457: PPUSH
64458: CALL_OW 275
64462: PUSH
64463: LD_VAR 0 4
64467: PUSH
64468: LD_INT 1
64470: ARRAY
64471: GREATEREQUAL
64472: PUSH
64473: LD_VAR 0 3
64477: PPUSH
64478: LD_INT 2
64480: PPUSH
64481: CALL_OW 275
64485: PUSH
64486: LD_VAR 0 4
64490: PUSH
64491: LD_INT 2
64493: ARRAY
64494: GREATEREQUAL
64495: AND
64496: PUSH
64497: LD_VAR 0 3
64501: PPUSH
64502: LD_INT 3
64504: PPUSH
64505: CALL_OW 275
64509: PUSH
64510: LD_VAR 0 4
64514: PUSH
64515: LD_INT 3
64517: ARRAY
64518: GREATEREQUAL
64519: AND
64520: ST_TO_ADDR
// end ;
64521: LD_VAR 0 2
64525: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64526: LD_INT 0
64528: PPUSH
64529: PPUSH
64530: PPUSH
// pom := GetBase ( building ) ;
64531: LD_ADDR_VAR 0 4
64535: PUSH
64536: LD_VAR 0 1
64540: PPUSH
64541: CALL_OW 274
64545: ST_TO_ADDR
// if not pom then
64546: LD_VAR 0 4
64550: NOT
64551: IFFALSE 64555
// exit ;
64553: GO 64656
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64555: LD_ADDR_VAR 0 5
64559: PUSH
64560: LD_VAR 0 2
64564: PPUSH
64565: LD_VAR 0 1
64569: PPUSH
64570: CALL_OW 248
64574: PPUSH
64575: CALL_OW 450
64579: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64580: LD_ADDR_VAR 0 3
64584: PUSH
64585: LD_VAR 0 4
64589: PPUSH
64590: LD_INT 1
64592: PPUSH
64593: CALL_OW 275
64597: PUSH
64598: LD_VAR 0 5
64602: PUSH
64603: LD_INT 1
64605: ARRAY
64606: GREATEREQUAL
64607: PUSH
64608: LD_VAR 0 4
64612: PPUSH
64613: LD_INT 2
64615: PPUSH
64616: CALL_OW 275
64620: PUSH
64621: LD_VAR 0 5
64625: PUSH
64626: LD_INT 2
64628: ARRAY
64629: GREATEREQUAL
64630: AND
64631: PUSH
64632: LD_VAR 0 4
64636: PPUSH
64637: LD_INT 3
64639: PPUSH
64640: CALL_OW 275
64644: PUSH
64645: LD_VAR 0 5
64649: PUSH
64650: LD_INT 3
64652: ARRAY
64653: GREATEREQUAL
64654: AND
64655: ST_TO_ADDR
// end ;
64656: LD_VAR 0 3
64660: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
64661: LD_INT 0
64663: PPUSH
64664: PPUSH
64665: PPUSH
64666: PPUSH
64667: PPUSH
64668: PPUSH
64669: PPUSH
64670: PPUSH
64671: PPUSH
64672: PPUSH
64673: PPUSH
// result := false ;
64674: LD_ADDR_VAR 0 8
64678: PUSH
64679: LD_INT 0
64681: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
64682: LD_VAR 0 5
64686: NOT
64687: PUSH
64688: LD_VAR 0 1
64692: NOT
64693: OR
64694: PUSH
64695: LD_VAR 0 2
64699: NOT
64700: OR
64701: PUSH
64702: LD_VAR 0 3
64706: NOT
64707: OR
64708: IFFALSE 64712
// exit ;
64710: GO 65526
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
64712: LD_ADDR_VAR 0 14
64716: PUSH
64717: LD_VAR 0 1
64721: PPUSH
64722: LD_VAR 0 2
64726: PPUSH
64727: LD_VAR 0 3
64731: PPUSH
64732: LD_VAR 0 4
64736: PPUSH
64737: LD_VAR 0 5
64741: PUSH
64742: LD_INT 1
64744: ARRAY
64745: PPUSH
64746: CALL_OW 248
64750: PPUSH
64751: LD_INT 0
64753: PPUSH
64754: CALL 66759 0 6
64758: ST_TO_ADDR
// if not hexes then
64759: LD_VAR 0 14
64763: NOT
64764: IFFALSE 64768
// exit ;
64766: GO 65526
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64768: LD_ADDR_VAR 0 17
64772: PUSH
64773: LD_VAR 0 5
64777: PPUSH
64778: LD_INT 22
64780: PUSH
64781: LD_VAR 0 13
64785: PPUSH
64786: CALL_OW 255
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: PUSH
64795: LD_INT 2
64797: PUSH
64798: LD_INT 30
64800: PUSH
64801: LD_INT 0
64803: PUSH
64804: EMPTY
64805: LIST
64806: LIST
64807: PUSH
64808: LD_INT 30
64810: PUSH
64811: LD_INT 1
64813: PUSH
64814: EMPTY
64815: LIST
64816: LIST
64817: PUSH
64818: EMPTY
64819: LIST
64820: LIST
64821: LIST
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: PPUSH
64827: CALL_OW 72
64831: ST_TO_ADDR
// for i = 1 to hexes do
64832: LD_ADDR_VAR 0 9
64836: PUSH
64837: DOUBLE
64838: LD_INT 1
64840: DEC
64841: ST_TO_ADDR
64842: LD_VAR 0 14
64846: PUSH
64847: FOR_TO
64848: IFFALSE 65524
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64850: LD_ADDR_VAR 0 13
64854: PUSH
64855: LD_VAR 0 14
64859: PUSH
64860: LD_VAR 0 9
64864: ARRAY
64865: PUSH
64866: LD_INT 1
64868: ARRAY
64869: PPUSH
64870: LD_VAR 0 14
64874: PUSH
64875: LD_VAR 0 9
64879: ARRAY
64880: PUSH
64881: LD_INT 2
64883: ARRAY
64884: PPUSH
64885: CALL_OW 428
64889: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64890: LD_VAR 0 14
64894: PUSH
64895: LD_VAR 0 9
64899: ARRAY
64900: PUSH
64901: LD_INT 1
64903: ARRAY
64904: PPUSH
64905: LD_VAR 0 14
64909: PUSH
64910: LD_VAR 0 9
64914: ARRAY
64915: PUSH
64916: LD_INT 2
64918: ARRAY
64919: PPUSH
64920: CALL_OW 351
64924: PUSH
64925: LD_VAR 0 14
64929: PUSH
64930: LD_VAR 0 9
64934: ARRAY
64935: PUSH
64936: LD_INT 1
64938: ARRAY
64939: PPUSH
64940: LD_VAR 0 14
64944: PUSH
64945: LD_VAR 0 9
64949: ARRAY
64950: PUSH
64951: LD_INT 2
64953: ARRAY
64954: PPUSH
64955: CALL_OW 488
64959: NOT
64960: OR
64961: PUSH
64962: LD_VAR 0 13
64966: PPUSH
64967: CALL_OW 247
64971: PUSH
64972: LD_INT 3
64974: EQUAL
64975: OR
64976: IFFALSE 64982
// exit ;
64978: POP
64979: POP
64980: GO 65526
// if not tmp then
64982: LD_VAR 0 13
64986: NOT
64987: IFFALSE 64991
// continue ;
64989: GO 64847
// result := true ;
64991: LD_ADDR_VAR 0 8
64995: PUSH
64996: LD_INT 1
64998: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64999: LD_VAR 0 6
65003: PUSH
65004: LD_VAR 0 13
65008: PPUSH
65009: CALL_OW 247
65013: PUSH
65014: LD_INT 2
65016: EQUAL
65017: AND
65018: PUSH
65019: LD_VAR 0 13
65023: PPUSH
65024: CALL_OW 263
65028: PUSH
65029: LD_INT 1
65031: EQUAL
65032: AND
65033: IFFALSE 65197
// begin if IsDrivenBy ( tmp ) then
65035: LD_VAR 0 13
65039: PPUSH
65040: CALL_OW 311
65044: IFFALSE 65048
// continue ;
65046: GO 64847
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
65048: LD_VAR 0 6
65052: PPUSH
65053: LD_INT 3
65055: PUSH
65056: LD_INT 60
65058: PUSH
65059: EMPTY
65060: LIST
65061: PUSH
65062: EMPTY
65063: LIST
65064: LIST
65065: PUSH
65066: LD_INT 3
65068: PUSH
65069: LD_INT 55
65071: PUSH
65072: EMPTY
65073: LIST
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: PUSH
65079: EMPTY
65080: LIST
65081: LIST
65082: PPUSH
65083: CALL_OW 72
65087: IFFALSE 65195
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
65089: LD_ADDR_VAR 0 18
65093: PUSH
65094: LD_VAR 0 6
65098: PPUSH
65099: LD_INT 3
65101: PUSH
65102: LD_INT 60
65104: PUSH
65105: EMPTY
65106: LIST
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PUSH
65112: LD_INT 3
65114: PUSH
65115: LD_INT 55
65117: PUSH
65118: EMPTY
65119: LIST
65120: PUSH
65121: EMPTY
65122: LIST
65123: LIST
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: PPUSH
65129: CALL_OW 72
65133: PUSH
65134: LD_INT 1
65136: ARRAY
65137: ST_TO_ADDR
// if IsInUnit ( driver ) then
65138: LD_VAR 0 18
65142: PPUSH
65143: CALL_OW 310
65147: IFFALSE 65158
// ComExit ( driver ) ;
65149: LD_VAR 0 18
65153: PPUSH
65154: CALL 90538 0 1
// AddComEnterUnit ( driver , tmp ) ;
65158: LD_VAR 0 18
65162: PPUSH
65163: LD_VAR 0 13
65167: PPUSH
65168: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
65172: LD_VAR 0 18
65176: PPUSH
65177: LD_VAR 0 7
65181: PPUSH
65182: CALL_OW 173
// AddComExitVehicle ( driver ) ;
65186: LD_VAR 0 18
65190: PPUSH
65191: CALL_OW 181
// end ; continue ;
65195: GO 64847
// end ; if not cleaners or not tmp in cleaners then
65197: LD_VAR 0 6
65201: NOT
65202: PUSH
65203: LD_VAR 0 13
65207: PUSH
65208: LD_VAR 0 6
65212: IN
65213: NOT
65214: OR
65215: IFFALSE 65522
// begin if dep then
65217: LD_VAR 0 17
65221: IFFALSE 65357
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
65223: LD_ADDR_VAR 0 16
65227: PUSH
65228: LD_VAR 0 17
65232: PUSH
65233: LD_INT 1
65235: ARRAY
65236: PPUSH
65237: CALL_OW 250
65241: PPUSH
65242: LD_VAR 0 17
65246: PUSH
65247: LD_INT 1
65249: ARRAY
65250: PPUSH
65251: CALL_OW 254
65255: PPUSH
65256: LD_INT 5
65258: PPUSH
65259: CALL_OW 272
65263: PUSH
65264: LD_VAR 0 17
65268: PUSH
65269: LD_INT 1
65271: ARRAY
65272: PPUSH
65273: CALL_OW 251
65277: PPUSH
65278: LD_VAR 0 17
65282: PUSH
65283: LD_INT 1
65285: ARRAY
65286: PPUSH
65287: CALL_OW 254
65291: PPUSH
65292: LD_INT 5
65294: PPUSH
65295: CALL_OW 273
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
65304: LD_VAR 0 16
65308: PUSH
65309: LD_INT 1
65311: ARRAY
65312: PPUSH
65313: LD_VAR 0 16
65317: PUSH
65318: LD_INT 2
65320: ARRAY
65321: PPUSH
65322: CALL_OW 488
65326: IFFALSE 65357
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
65328: LD_VAR 0 13
65332: PPUSH
65333: LD_VAR 0 16
65337: PUSH
65338: LD_INT 1
65340: ARRAY
65341: PPUSH
65342: LD_VAR 0 16
65346: PUSH
65347: LD_INT 2
65349: ARRAY
65350: PPUSH
65351: CALL_OW 111
// continue ;
65355: GO 64847
// end ; end ; r := GetDir ( tmp ) ;
65357: LD_ADDR_VAR 0 15
65361: PUSH
65362: LD_VAR 0 13
65366: PPUSH
65367: CALL_OW 254
65371: ST_TO_ADDR
// if r = 5 then
65372: LD_VAR 0 15
65376: PUSH
65377: LD_INT 5
65379: EQUAL
65380: IFFALSE 65390
// r := 0 ;
65382: LD_ADDR_VAR 0 15
65386: PUSH
65387: LD_INT 0
65389: ST_TO_ADDR
// for j = r to 5 do
65390: LD_ADDR_VAR 0 10
65394: PUSH
65395: DOUBLE
65396: LD_VAR 0 15
65400: DEC
65401: ST_TO_ADDR
65402: LD_INT 5
65404: PUSH
65405: FOR_TO
65406: IFFALSE 65520
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
65408: LD_ADDR_VAR 0 11
65412: PUSH
65413: LD_VAR 0 13
65417: PPUSH
65418: CALL_OW 250
65422: PPUSH
65423: LD_VAR 0 10
65427: PPUSH
65428: LD_INT 2
65430: PPUSH
65431: CALL_OW 272
65435: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
65436: LD_ADDR_VAR 0 12
65440: PUSH
65441: LD_VAR 0 13
65445: PPUSH
65446: CALL_OW 251
65450: PPUSH
65451: LD_VAR 0 10
65455: PPUSH
65456: LD_INT 2
65458: PPUSH
65459: CALL_OW 273
65463: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
65464: LD_VAR 0 11
65468: PPUSH
65469: LD_VAR 0 12
65473: PPUSH
65474: CALL_OW 488
65478: PUSH
65479: LD_VAR 0 11
65483: PPUSH
65484: LD_VAR 0 12
65488: PPUSH
65489: CALL_OW 428
65493: NOT
65494: AND
65495: IFFALSE 65518
// begin ComMoveXY ( tmp , _x , _y ) ;
65497: LD_VAR 0 13
65501: PPUSH
65502: LD_VAR 0 11
65506: PPUSH
65507: LD_VAR 0 12
65511: PPUSH
65512: CALL_OW 111
// break ;
65516: GO 65520
// end ; end ;
65518: GO 65405
65520: POP
65521: POP
// end ; end ;
65522: GO 64847
65524: POP
65525: POP
// end ;
65526: LD_VAR 0 8
65530: RET
// export function BuildingTechInvented ( side , btype ) ; begin
65531: LD_INT 0
65533: PPUSH
// result := true ;
65534: LD_ADDR_VAR 0 3
65538: PUSH
65539: LD_INT 1
65541: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
65542: LD_VAR 0 2
65546: PUSH
65547: LD_INT 24
65549: DOUBLE
65550: EQUAL
65551: IFTRUE 65561
65553: LD_INT 33
65555: DOUBLE
65556: EQUAL
65557: IFTRUE 65561
65559: GO 65586
65561: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
65562: LD_ADDR_VAR 0 3
65566: PUSH
65567: LD_INT 32
65569: PPUSH
65570: LD_VAR 0 1
65574: PPUSH
65575: CALL_OW 321
65579: PUSH
65580: LD_INT 2
65582: EQUAL
65583: ST_TO_ADDR
65584: GO 65902
65586: LD_INT 20
65588: DOUBLE
65589: EQUAL
65590: IFTRUE 65594
65592: GO 65619
65594: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
65595: LD_ADDR_VAR 0 3
65599: PUSH
65600: LD_INT 6
65602: PPUSH
65603: LD_VAR 0 1
65607: PPUSH
65608: CALL_OW 321
65612: PUSH
65613: LD_INT 2
65615: EQUAL
65616: ST_TO_ADDR
65617: GO 65902
65619: LD_INT 22
65621: DOUBLE
65622: EQUAL
65623: IFTRUE 65633
65625: LD_INT 36
65627: DOUBLE
65628: EQUAL
65629: IFTRUE 65633
65631: GO 65658
65633: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
65634: LD_ADDR_VAR 0 3
65638: PUSH
65639: LD_INT 15
65641: PPUSH
65642: LD_VAR 0 1
65646: PPUSH
65647: CALL_OW 321
65651: PUSH
65652: LD_INT 2
65654: EQUAL
65655: ST_TO_ADDR
65656: GO 65902
65658: LD_INT 30
65660: DOUBLE
65661: EQUAL
65662: IFTRUE 65666
65664: GO 65691
65666: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
65667: LD_ADDR_VAR 0 3
65671: PUSH
65672: LD_INT 20
65674: PPUSH
65675: LD_VAR 0 1
65679: PPUSH
65680: CALL_OW 321
65684: PUSH
65685: LD_INT 2
65687: EQUAL
65688: ST_TO_ADDR
65689: GO 65902
65691: LD_INT 28
65693: DOUBLE
65694: EQUAL
65695: IFTRUE 65705
65697: LD_INT 21
65699: DOUBLE
65700: EQUAL
65701: IFTRUE 65705
65703: GO 65730
65705: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
65706: LD_ADDR_VAR 0 3
65710: PUSH
65711: LD_INT 21
65713: PPUSH
65714: LD_VAR 0 1
65718: PPUSH
65719: CALL_OW 321
65723: PUSH
65724: LD_INT 2
65726: EQUAL
65727: ST_TO_ADDR
65728: GO 65902
65730: LD_INT 16
65732: DOUBLE
65733: EQUAL
65734: IFTRUE 65738
65736: GO 65763
65738: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
65739: LD_ADDR_VAR 0 3
65743: PUSH
65744: LD_INT 84
65746: PPUSH
65747: LD_VAR 0 1
65751: PPUSH
65752: CALL_OW 321
65756: PUSH
65757: LD_INT 2
65759: EQUAL
65760: ST_TO_ADDR
65761: GO 65902
65763: LD_INT 19
65765: DOUBLE
65766: EQUAL
65767: IFTRUE 65777
65769: LD_INT 23
65771: DOUBLE
65772: EQUAL
65773: IFTRUE 65777
65775: GO 65802
65777: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
65778: LD_ADDR_VAR 0 3
65782: PUSH
65783: LD_INT 83
65785: PPUSH
65786: LD_VAR 0 1
65790: PPUSH
65791: CALL_OW 321
65795: PUSH
65796: LD_INT 2
65798: EQUAL
65799: ST_TO_ADDR
65800: GO 65902
65802: LD_INT 17
65804: DOUBLE
65805: EQUAL
65806: IFTRUE 65810
65808: GO 65835
65810: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65811: LD_ADDR_VAR 0 3
65815: PUSH
65816: LD_INT 39
65818: PPUSH
65819: LD_VAR 0 1
65823: PPUSH
65824: CALL_OW 321
65828: PUSH
65829: LD_INT 2
65831: EQUAL
65832: ST_TO_ADDR
65833: GO 65902
65835: LD_INT 18
65837: DOUBLE
65838: EQUAL
65839: IFTRUE 65843
65841: GO 65868
65843: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65844: LD_ADDR_VAR 0 3
65848: PUSH
65849: LD_INT 40
65851: PPUSH
65852: LD_VAR 0 1
65856: PPUSH
65857: CALL_OW 321
65861: PUSH
65862: LD_INT 2
65864: EQUAL
65865: ST_TO_ADDR
65866: GO 65902
65868: LD_INT 27
65870: DOUBLE
65871: EQUAL
65872: IFTRUE 65876
65874: GO 65901
65876: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65877: LD_ADDR_VAR 0 3
65881: PUSH
65882: LD_INT 35
65884: PPUSH
65885: LD_VAR 0 1
65889: PPUSH
65890: CALL_OW 321
65894: PUSH
65895: LD_INT 2
65897: EQUAL
65898: ST_TO_ADDR
65899: GO 65902
65901: POP
// end ;
65902: LD_VAR 0 3
65906: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65907: LD_INT 0
65909: PPUSH
65910: PPUSH
65911: PPUSH
65912: PPUSH
65913: PPUSH
65914: PPUSH
65915: PPUSH
65916: PPUSH
65917: PPUSH
65918: PPUSH
65919: PPUSH
// result := false ;
65920: LD_ADDR_VAR 0 6
65924: PUSH
65925: LD_INT 0
65927: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65928: LD_VAR 0 1
65932: NOT
65933: PUSH
65934: LD_VAR 0 1
65938: PPUSH
65939: CALL_OW 266
65943: PUSH
65944: LD_INT 0
65946: PUSH
65947: LD_INT 1
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: IN
65954: NOT
65955: OR
65956: PUSH
65957: LD_VAR 0 2
65961: NOT
65962: OR
65963: PUSH
65964: LD_VAR 0 5
65968: PUSH
65969: LD_INT 0
65971: PUSH
65972: LD_INT 1
65974: PUSH
65975: LD_INT 2
65977: PUSH
65978: LD_INT 3
65980: PUSH
65981: LD_INT 4
65983: PUSH
65984: LD_INT 5
65986: PUSH
65987: EMPTY
65988: LIST
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: IN
65995: NOT
65996: OR
65997: PUSH
65998: LD_VAR 0 3
66002: PPUSH
66003: LD_VAR 0 4
66007: PPUSH
66008: CALL_OW 488
66012: NOT
66013: OR
66014: IFFALSE 66018
// exit ;
66016: GO 66754
// side := GetSide ( depot ) ;
66018: LD_ADDR_VAR 0 9
66022: PUSH
66023: LD_VAR 0 1
66027: PPUSH
66028: CALL_OW 255
66032: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
66033: LD_VAR 0 9
66037: PPUSH
66038: LD_VAR 0 2
66042: PPUSH
66043: CALL 65531 0 2
66047: NOT
66048: IFFALSE 66052
// exit ;
66050: GO 66754
// pom := GetBase ( depot ) ;
66052: LD_ADDR_VAR 0 10
66056: PUSH
66057: LD_VAR 0 1
66061: PPUSH
66062: CALL_OW 274
66066: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
66067: LD_ADDR_VAR 0 11
66071: PUSH
66072: LD_VAR 0 2
66076: PPUSH
66077: LD_VAR 0 1
66081: PPUSH
66082: CALL_OW 248
66086: PPUSH
66087: CALL_OW 450
66091: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
66092: LD_VAR 0 10
66096: PPUSH
66097: LD_INT 1
66099: PPUSH
66100: CALL_OW 275
66104: PUSH
66105: LD_VAR 0 11
66109: PUSH
66110: LD_INT 1
66112: ARRAY
66113: GREATEREQUAL
66114: PUSH
66115: LD_VAR 0 10
66119: PPUSH
66120: LD_INT 2
66122: PPUSH
66123: CALL_OW 275
66127: PUSH
66128: LD_VAR 0 11
66132: PUSH
66133: LD_INT 2
66135: ARRAY
66136: GREATEREQUAL
66137: AND
66138: PUSH
66139: LD_VAR 0 10
66143: PPUSH
66144: LD_INT 3
66146: PPUSH
66147: CALL_OW 275
66151: PUSH
66152: LD_VAR 0 11
66156: PUSH
66157: LD_INT 3
66159: ARRAY
66160: GREATEREQUAL
66161: AND
66162: NOT
66163: IFFALSE 66167
// exit ;
66165: GO 66754
// if GetBType ( depot ) = b_depot then
66167: LD_VAR 0 1
66171: PPUSH
66172: CALL_OW 266
66176: PUSH
66177: LD_INT 0
66179: EQUAL
66180: IFFALSE 66192
// dist := 28 else
66182: LD_ADDR_VAR 0 14
66186: PUSH
66187: LD_INT 28
66189: ST_TO_ADDR
66190: GO 66200
// dist := 36 ;
66192: LD_ADDR_VAR 0 14
66196: PUSH
66197: LD_INT 36
66199: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
66200: LD_VAR 0 1
66204: PPUSH
66205: LD_VAR 0 3
66209: PPUSH
66210: LD_VAR 0 4
66214: PPUSH
66215: CALL_OW 297
66219: PUSH
66220: LD_VAR 0 14
66224: GREATER
66225: IFFALSE 66229
// exit ;
66227: GO 66754
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
66229: LD_ADDR_VAR 0 12
66233: PUSH
66234: LD_VAR 0 2
66238: PPUSH
66239: LD_VAR 0 3
66243: PPUSH
66244: LD_VAR 0 4
66248: PPUSH
66249: LD_VAR 0 5
66253: PPUSH
66254: LD_VAR 0 1
66258: PPUSH
66259: CALL_OW 248
66263: PPUSH
66264: LD_INT 0
66266: PPUSH
66267: CALL 66759 0 6
66271: ST_TO_ADDR
// if not hexes then
66272: LD_VAR 0 12
66276: NOT
66277: IFFALSE 66281
// exit ;
66279: GO 66754
// hex := GetHexInfo ( x , y ) ;
66281: LD_ADDR_VAR 0 15
66285: PUSH
66286: LD_VAR 0 3
66290: PPUSH
66291: LD_VAR 0 4
66295: PPUSH
66296: CALL_OW 546
66300: ST_TO_ADDR
// if hex [ 1 ] then
66301: LD_VAR 0 15
66305: PUSH
66306: LD_INT 1
66308: ARRAY
66309: IFFALSE 66313
// exit ;
66311: GO 66754
// height := hex [ 2 ] ;
66313: LD_ADDR_VAR 0 13
66317: PUSH
66318: LD_VAR 0 15
66322: PUSH
66323: LD_INT 2
66325: ARRAY
66326: ST_TO_ADDR
// for i = 1 to hexes do
66327: LD_ADDR_VAR 0 7
66331: PUSH
66332: DOUBLE
66333: LD_INT 1
66335: DEC
66336: ST_TO_ADDR
66337: LD_VAR 0 12
66341: PUSH
66342: FOR_TO
66343: IFFALSE 66673
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
66345: LD_VAR 0 12
66349: PUSH
66350: LD_VAR 0 7
66354: ARRAY
66355: PUSH
66356: LD_INT 1
66358: ARRAY
66359: PPUSH
66360: LD_VAR 0 12
66364: PUSH
66365: LD_VAR 0 7
66369: ARRAY
66370: PUSH
66371: LD_INT 2
66373: ARRAY
66374: PPUSH
66375: CALL_OW 488
66379: NOT
66380: PUSH
66381: LD_VAR 0 12
66385: PUSH
66386: LD_VAR 0 7
66390: ARRAY
66391: PUSH
66392: LD_INT 1
66394: ARRAY
66395: PPUSH
66396: LD_VAR 0 12
66400: PUSH
66401: LD_VAR 0 7
66405: ARRAY
66406: PUSH
66407: LD_INT 2
66409: ARRAY
66410: PPUSH
66411: CALL_OW 428
66415: PUSH
66416: LD_INT 0
66418: GREATER
66419: OR
66420: PUSH
66421: LD_VAR 0 12
66425: PUSH
66426: LD_VAR 0 7
66430: ARRAY
66431: PUSH
66432: LD_INT 1
66434: ARRAY
66435: PPUSH
66436: LD_VAR 0 12
66440: PUSH
66441: LD_VAR 0 7
66445: ARRAY
66446: PUSH
66447: LD_INT 2
66449: ARRAY
66450: PPUSH
66451: CALL_OW 351
66455: OR
66456: IFFALSE 66462
// exit ;
66458: POP
66459: POP
66460: GO 66754
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
66462: LD_ADDR_VAR 0 8
66466: PUSH
66467: LD_VAR 0 12
66471: PUSH
66472: LD_VAR 0 7
66476: ARRAY
66477: PUSH
66478: LD_INT 1
66480: ARRAY
66481: PPUSH
66482: LD_VAR 0 12
66486: PUSH
66487: LD_VAR 0 7
66491: ARRAY
66492: PUSH
66493: LD_INT 2
66495: ARRAY
66496: PPUSH
66497: CALL_OW 546
66501: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
66502: LD_VAR 0 8
66506: PUSH
66507: LD_INT 1
66509: ARRAY
66510: PUSH
66511: LD_VAR 0 8
66515: PUSH
66516: LD_INT 2
66518: ARRAY
66519: PUSH
66520: LD_VAR 0 13
66524: PUSH
66525: LD_INT 2
66527: PLUS
66528: GREATER
66529: OR
66530: PUSH
66531: LD_VAR 0 8
66535: PUSH
66536: LD_INT 2
66538: ARRAY
66539: PUSH
66540: LD_VAR 0 13
66544: PUSH
66545: LD_INT 2
66547: MINUS
66548: LESS
66549: OR
66550: PUSH
66551: LD_VAR 0 8
66555: PUSH
66556: LD_INT 3
66558: ARRAY
66559: PUSH
66560: LD_INT 0
66562: PUSH
66563: LD_INT 8
66565: PUSH
66566: LD_INT 9
66568: PUSH
66569: LD_INT 10
66571: PUSH
66572: LD_INT 11
66574: PUSH
66575: LD_INT 12
66577: PUSH
66578: LD_INT 13
66580: PUSH
66581: LD_INT 16
66583: PUSH
66584: LD_INT 17
66586: PUSH
66587: LD_INT 18
66589: PUSH
66590: LD_INT 19
66592: PUSH
66593: LD_INT 20
66595: PUSH
66596: LD_INT 21
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: IN
66614: NOT
66615: OR
66616: PUSH
66617: LD_VAR 0 8
66621: PUSH
66622: LD_INT 5
66624: ARRAY
66625: NOT
66626: OR
66627: PUSH
66628: LD_VAR 0 8
66632: PUSH
66633: LD_INT 6
66635: ARRAY
66636: PUSH
66637: LD_INT 1
66639: PUSH
66640: LD_INT 2
66642: PUSH
66643: LD_INT 7
66645: PUSH
66646: LD_INT 9
66648: PUSH
66649: LD_INT 10
66651: PUSH
66652: LD_INT 11
66654: PUSH
66655: EMPTY
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: IN
66663: NOT
66664: OR
66665: IFFALSE 66671
// exit ;
66667: POP
66668: POP
66669: GO 66754
// end ;
66671: GO 66342
66673: POP
66674: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66675: LD_VAR 0 9
66679: PPUSH
66680: LD_VAR 0 3
66684: PPUSH
66685: LD_VAR 0 4
66689: PPUSH
66690: LD_INT 20
66692: PPUSH
66693: CALL 58706 0 4
66697: PUSH
66698: LD_INT 4
66700: ARRAY
66701: IFFALSE 66705
// exit ;
66703: GO 66754
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
66705: LD_VAR 0 2
66709: PUSH
66710: LD_INT 29
66712: PUSH
66713: LD_INT 30
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: IN
66720: PUSH
66721: LD_VAR 0 3
66725: PPUSH
66726: LD_VAR 0 4
66730: PPUSH
66731: LD_VAR 0 9
66735: PPUSH
66736: CALL_OW 440
66740: NOT
66741: AND
66742: IFFALSE 66746
// exit ;
66744: GO 66754
// result := true ;
66746: LD_ADDR_VAR 0 6
66750: PUSH
66751: LD_INT 1
66753: ST_TO_ADDR
// end ;
66754: LD_VAR 0 6
66758: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
66759: LD_INT 0
66761: PPUSH
66762: PPUSH
66763: PPUSH
66764: PPUSH
66765: PPUSH
66766: PPUSH
66767: PPUSH
66768: PPUSH
66769: PPUSH
66770: PPUSH
66771: PPUSH
66772: PPUSH
66773: PPUSH
66774: PPUSH
66775: PPUSH
66776: PPUSH
66777: PPUSH
66778: PPUSH
66779: PPUSH
66780: PPUSH
66781: PPUSH
66782: PPUSH
66783: PPUSH
66784: PPUSH
66785: PPUSH
66786: PPUSH
66787: PPUSH
66788: PPUSH
66789: PPUSH
66790: PPUSH
66791: PPUSH
66792: PPUSH
66793: PPUSH
66794: PPUSH
66795: PPUSH
66796: PPUSH
66797: PPUSH
66798: PPUSH
66799: PPUSH
66800: PPUSH
66801: PPUSH
66802: PPUSH
66803: PPUSH
66804: PPUSH
66805: PPUSH
66806: PPUSH
66807: PPUSH
66808: PPUSH
66809: PPUSH
66810: PPUSH
66811: PPUSH
66812: PPUSH
66813: PPUSH
66814: PPUSH
66815: PPUSH
66816: PPUSH
66817: PPUSH
66818: PPUSH
// result = [ ] ;
66819: LD_ADDR_VAR 0 7
66823: PUSH
66824: EMPTY
66825: ST_TO_ADDR
// temp_list = [ ] ;
66826: LD_ADDR_VAR 0 9
66830: PUSH
66831: EMPTY
66832: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66833: LD_VAR 0 4
66837: PUSH
66838: LD_INT 0
66840: PUSH
66841: LD_INT 1
66843: PUSH
66844: LD_INT 2
66846: PUSH
66847: LD_INT 3
66849: PUSH
66850: LD_INT 4
66852: PUSH
66853: LD_INT 5
66855: PUSH
66856: EMPTY
66857: LIST
66858: LIST
66859: LIST
66860: LIST
66861: LIST
66862: LIST
66863: IN
66864: NOT
66865: PUSH
66866: LD_VAR 0 1
66870: PUSH
66871: LD_INT 0
66873: PUSH
66874: LD_INT 1
66876: PUSH
66877: EMPTY
66878: LIST
66879: LIST
66880: IN
66881: PUSH
66882: LD_VAR 0 5
66886: PUSH
66887: LD_INT 1
66889: PUSH
66890: LD_INT 2
66892: PUSH
66893: LD_INT 3
66895: PUSH
66896: EMPTY
66897: LIST
66898: LIST
66899: LIST
66900: IN
66901: NOT
66902: AND
66903: OR
66904: IFFALSE 66908
// exit ;
66906: GO 85299
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66908: LD_VAR 0 1
66912: PUSH
66913: LD_INT 6
66915: PUSH
66916: LD_INT 7
66918: PUSH
66919: LD_INT 8
66921: PUSH
66922: LD_INT 13
66924: PUSH
66925: LD_INT 12
66927: PUSH
66928: LD_INT 15
66930: PUSH
66931: LD_INT 11
66933: PUSH
66934: LD_INT 14
66936: PUSH
66937: LD_INT 10
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: LIST
66944: LIST
66945: LIST
66946: LIST
66947: LIST
66948: LIST
66949: LIST
66950: IN
66951: IFFALSE 66961
// btype = b_lab ;
66953: LD_ADDR_VAR 0 1
66957: PUSH
66958: LD_INT 6
66960: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66961: LD_VAR 0 6
66965: PUSH
66966: LD_INT 0
66968: PUSH
66969: LD_INT 1
66971: PUSH
66972: LD_INT 2
66974: PUSH
66975: EMPTY
66976: LIST
66977: LIST
66978: LIST
66979: IN
66980: NOT
66981: PUSH
66982: LD_VAR 0 1
66986: PUSH
66987: LD_INT 0
66989: PUSH
66990: LD_INT 1
66992: PUSH
66993: LD_INT 2
66995: PUSH
66996: LD_INT 3
66998: PUSH
66999: LD_INT 6
67001: PUSH
67002: LD_INT 36
67004: PUSH
67005: LD_INT 4
67007: PUSH
67008: LD_INT 5
67010: PUSH
67011: LD_INT 31
67013: PUSH
67014: LD_INT 32
67016: PUSH
67017: LD_INT 33
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: LIST
67024: LIST
67025: LIST
67026: LIST
67027: LIST
67028: LIST
67029: LIST
67030: LIST
67031: LIST
67032: IN
67033: NOT
67034: PUSH
67035: LD_VAR 0 6
67039: PUSH
67040: LD_INT 1
67042: EQUAL
67043: AND
67044: OR
67045: PUSH
67046: LD_VAR 0 1
67050: PUSH
67051: LD_INT 2
67053: PUSH
67054: LD_INT 3
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: IN
67061: NOT
67062: PUSH
67063: LD_VAR 0 6
67067: PUSH
67068: LD_INT 2
67070: EQUAL
67071: AND
67072: OR
67073: IFFALSE 67083
// mode = 0 ;
67075: LD_ADDR_VAR 0 6
67079: PUSH
67080: LD_INT 0
67082: ST_TO_ADDR
// case mode of 0 :
67083: LD_VAR 0 6
67087: PUSH
67088: LD_INT 0
67090: DOUBLE
67091: EQUAL
67092: IFTRUE 67096
67094: GO 78549
67096: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67097: LD_ADDR_VAR 0 11
67101: PUSH
67102: LD_INT 0
67104: PUSH
67105: LD_INT 0
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PUSH
67112: LD_INT 0
67114: PUSH
67115: LD_INT 1
67117: NEG
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: LD_INT 1
67125: PUSH
67126: LD_INT 0
67128: PUSH
67129: EMPTY
67130: LIST
67131: LIST
67132: PUSH
67133: LD_INT 1
67135: PUSH
67136: LD_INT 1
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 0
67145: PUSH
67146: LD_INT 1
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: PUSH
67153: LD_INT 1
67155: NEG
67156: PUSH
67157: LD_INT 0
67159: PUSH
67160: EMPTY
67161: LIST
67162: LIST
67163: PUSH
67164: LD_INT 1
67166: NEG
67167: PUSH
67168: LD_INT 1
67170: NEG
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: LD_INT 1
67178: NEG
67179: PUSH
67180: LD_INT 2
67182: NEG
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: LD_INT 0
67190: PUSH
67191: LD_INT 2
67193: NEG
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 1
67201: PUSH
67202: LD_INT 1
67204: NEG
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 1
67212: PUSH
67213: LD_INT 2
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: PUSH
67220: LD_INT 0
67222: PUSH
67223: LD_INT 2
67225: PUSH
67226: EMPTY
67227: LIST
67228: LIST
67229: PUSH
67230: LD_INT 1
67232: NEG
67233: PUSH
67234: LD_INT 1
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 1
67243: PUSH
67244: LD_INT 3
67246: PUSH
67247: EMPTY
67248: LIST
67249: LIST
67250: PUSH
67251: LD_INT 0
67253: PUSH
67254: LD_INT 3
67256: PUSH
67257: EMPTY
67258: LIST
67259: LIST
67260: PUSH
67261: LD_INT 1
67263: NEG
67264: PUSH
67265: LD_INT 2
67267: PUSH
67268: EMPTY
67269: LIST
67270: LIST
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67290: LD_ADDR_VAR 0 12
67294: PUSH
67295: LD_INT 0
67297: PUSH
67298: LD_INT 0
67300: PUSH
67301: EMPTY
67302: LIST
67303: LIST
67304: PUSH
67305: LD_INT 0
67307: PUSH
67308: LD_INT 1
67310: NEG
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 1
67318: PUSH
67319: LD_INT 0
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 1
67328: PUSH
67329: LD_INT 1
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 0
67338: PUSH
67339: LD_INT 1
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PUSH
67346: LD_INT 1
67348: NEG
67349: PUSH
67350: LD_INT 0
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: LD_INT 1
67359: NEG
67360: PUSH
67361: LD_INT 1
67363: NEG
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: PUSH
67369: LD_INT 1
67371: PUSH
67372: LD_INT 1
67374: NEG
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: LD_INT 2
67382: PUSH
67383: LD_INT 0
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: LD_INT 2
67392: PUSH
67393: LD_INT 1
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 1
67402: NEG
67403: PUSH
67404: LD_INT 1
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 2
67413: NEG
67414: PUSH
67415: LD_INT 0
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 2
67424: NEG
67425: PUSH
67426: LD_INT 1
67428: NEG
67429: PUSH
67430: EMPTY
67431: LIST
67432: LIST
67433: PUSH
67434: LD_INT 2
67436: NEG
67437: PUSH
67438: LD_INT 1
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: PUSH
67445: LD_INT 3
67447: NEG
67448: PUSH
67449: LD_INT 0
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 3
67458: NEG
67459: PUSH
67460: LD_INT 1
67462: NEG
67463: PUSH
67464: EMPTY
67465: LIST
67466: LIST
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: LIST
67483: LIST
67484: LIST
67485: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67486: LD_ADDR_VAR 0 13
67490: PUSH
67491: LD_INT 0
67493: PUSH
67494: LD_INT 0
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 0
67503: PUSH
67504: LD_INT 1
67506: NEG
67507: PUSH
67508: EMPTY
67509: LIST
67510: LIST
67511: PUSH
67512: LD_INT 1
67514: PUSH
67515: LD_INT 0
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: PUSH
67522: LD_INT 1
67524: PUSH
67525: LD_INT 1
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: PUSH
67532: LD_INT 0
67534: PUSH
67535: LD_INT 1
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PUSH
67542: LD_INT 1
67544: NEG
67545: PUSH
67546: LD_INT 0
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: PUSH
67553: LD_INT 1
67555: NEG
67556: PUSH
67557: LD_INT 1
67559: NEG
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 1
67567: NEG
67568: PUSH
67569: LD_INT 2
67571: NEG
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: LD_INT 2
67579: PUSH
67580: LD_INT 1
67582: PUSH
67583: EMPTY
67584: LIST
67585: LIST
67586: PUSH
67587: LD_INT 2
67589: PUSH
67590: LD_INT 2
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: PUSH
67597: LD_INT 1
67599: PUSH
67600: LD_INT 2
67602: PUSH
67603: EMPTY
67604: LIST
67605: LIST
67606: PUSH
67607: LD_INT 2
67609: NEG
67610: PUSH
67611: LD_INT 1
67613: NEG
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: PUSH
67619: LD_INT 2
67621: NEG
67622: PUSH
67623: LD_INT 2
67625: NEG
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 2
67633: NEG
67634: PUSH
67635: LD_INT 3
67637: NEG
67638: PUSH
67639: EMPTY
67640: LIST
67641: LIST
67642: PUSH
67643: LD_INT 3
67645: NEG
67646: PUSH
67647: LD_INT 2
67649: NEG
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: LD_INT 3
67657: NEG
67658: PUSH
67659: LD_INT 3
67661: NEG
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: LIST
67671: LIST
67672: LIST
67673: LIST
67674: LIST
67675: LIST
67676: LIST
67677: LIST
67678: LIST
67679: LIST
67680: LIST
67681: LIST
67682: LIST
67683: LIST
67684: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67685: LD_ADDR_VAR 0 14
67689: PUSH
67690: LD_INT 0
67692: PUSH
67693: LD_INT 0
67695: PUSH
67696: EMPTY
67697: LIST
67698: LIST
67699: PUSH
67700: LD_INT 0
67702: PUSH
67703: LD_INT 1
67705: NEG
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: PUSH
67711: LD_INT 1
67713: PUSH
67714: LD_INT 0
67716: PUSH
67717: EMPTY
67718: LIST
67719: LIST
67720: PUSH
67721: LD_INT 1
67723: PUSH
67724: LD_INT 1
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: LD_INT 0
67733: PUSH
67734: LD_INT 1
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 1
67743: NEG
67744: PUSH
67745: LD_INT 0
67747: PUSH
67748: EMPTY
67749: LIST
67750: LIST
67751: PUSH
67752: LD_INT 1
67754: NEG
67755: PUSH
67756: LD_INT 1
67758: NEG
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PUSH
67764: LD_INT 1
67766: NEG
67767: PUSH
67768: LD_INT 2
67770: NEG
67771: PUSH
67772: EMPTY
67773: LIST
67774: LIST
67775: PUSH
67776: LD_INT 0
67778: PUSH
67779: LD_INT 2
67781: NEG
67782: PUSH
67783: EMPTY
67784: LIST
67785: LIST
67786: PUSH
67787: LD_INT 1
67789: PUSH
67790: LD_INT 1
67792: NEG
67793: PUSH
67794: EMPTY
67795: LIST
67796: LIST
67797: PUSH
67798: LD_INT 1
67800: PUSH
67801: LD_INT 2
67803: PUSH
67804: EMPTY
67805: LIST
67806: LIST
67807: PUSH
67808: LD_INT 0
67810: PUSH
67811: LD_INT 2
67813: PUSH
67814: EMPTY
67815: LIST
67816: LIST
67817: PUSH
67818: LD_INT 1
67820: NEG
67821: PUSH
67822: LD_INT 1
67824: PUSH
67825: EMPTY
67826: LIST
67827: LIST
67828: PUSH
67829: LD_INT 1
67831: NEG
67832: PUSH
67833: LD_INT 3
67835: NEG
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: PUSH
67841: LD_INT 0
67843: PUSH
67844: LD_INT 3
67846: NEG
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: PUSH
67852: LD_INT 1
67854: PUSH
67855: LD_INT 2
67857: NEG
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: LIST
67880: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67881: LD_ADDR_VAR 0 15
67885: PUSH
67886: LD_INT 0
67888: PUSH
67889: LD_INT 0
67891: PUSH
67892: EMPTY
67893: LIST
67894: LIST
67895: PUSH
67896: LD_INT 0
67898: PUSH
67899: LD_INT 1
67901: NEG
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: LD_INT 1
67909: PUSH
67910: LD_INT 0
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: PUSH
67917: LD_INT 1
67919: PUSH
67920: LD_INT 1
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PUSH
67927: LD_INT 0
67929: PUSH
67930: LD_INT 1
67932: PUSH
67933: EMPTY
67934: LIST
67935: LIST
67936: PUSH
67937: LD_INT 1
67939: NEG
67940: PUSH
67941: LD_INT 0
67943: PUSH
67944: EMPTY
67945: LIST
67946: LIST
67947: PUSH
67948: LD_INT 1
67950: NEG
67951: PUSH
67952: LD_INT 1
67954: NEG
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 1
67962: PUSH
67963: LD_INT 1
67965: NEG
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 2
67973: PUSH
67974: LD_INT 0
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 2
67983: PUSH
67984: LD_INT 1
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PUSH
67991: LD_INT 1
67993: NEG
67994: PUSH
67995: LD_INT 1
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: PUSH
68002: LD_INT 2
68004: NEG
68005: PUSH
68006: LD_INT 0
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 2
68015: NEG
68016: PUSH
68017: LD_INT 1
68019: NEG
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: LD_INT 2
68027: PUSH
68028: LD_INT 1
68030: NEG
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: PUSH
68036: LD_INT 3
68038: PUSH
68039: LD_INT 0
68041: PUSH
68042: EMPTY
68043: LIST
68044: LIST
68045: PUSH
68046: LD_INT 3
68048: PUSH
68049: LD_INT 1
68051: PUSH
68052: EMPTY
68053: LIST
68054: LIST
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
68074: LD_ADDR_VAR 0 16
68078: PUSH
68079: LD_INT 0
68081: PUSH
68082: LD_INT 0
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: PUSH
68089: LD_INT 0
68091: PUSH
68092: LD_INT 1
68094: NEG
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: PUSH
68100: LD_INT 1
68102: PUSH
68103: LD_INT 0
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 1
68112: PUSH
68113: LD_INT 1
68115: PUSH
68116: EMPTY
68117: LIST
68118: LIST
68119: PUSH
68120: LD_INT 0
68122: PUSH
68123: LD_INT 1
68125: PUSH
68126: EMPTY
68127: LIST
68128: LIST
68129: PUSH
68130: LD_INT 1
68132: NEG
68133: PUSH
68134: LD_INT 0
68136: PUSH
68137: EMPTY
68138: LIST
68139: LIST
68140: PUSH
68141: LD_INT 1
68143: NEG
68144: PUSH
68145: LD_INT 1
68147: NEG
68148: PUSH
68149: EMPTY
68150: LIST
68151: LIST
68152: PUSH
68153: LD_INT 1
68155: NEG
68156: PUSH
68157: LD_INT 2
68159: NEG
68160: PUSH
68161: EMPTY
68162: LIST
68163: LIST
68164: PUSH
68165: LD_INT 2
68167: PUSH
68168: LD_INT 1
68170: PUSH
68171: EMPTY
68172: LIST
68173: LIST
68174: PUSH
68175: LD_INT 2
68177: PUSH
68178: LD_INT 2
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: PUSH
68185: LD_INT 1
68187: PUSH
68188: LD_INT 2
68190: PUSH
68191: EMPTY
68192: LIST
68193: LIST
68194: PUSH
68195: LD_INT 2
68197: NEG
68198: PUSH
68199: LD_INT 1
68201: NEG
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 2
68209: NEG
68210: PUSH
68211: LD_INT 2
68213: NEG
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: PUSH
68219: LD_INT 3
68221: PUSH
68222: LD_INT 2
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 3
68231: PUSH
68232: LD_INT 3
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 2
68241: PUSH
68242: LD_INT 3
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: LIST
68253: LIST
68254: LIST
68255: LIST
68256: LIST
68257: LIST
68258: LIST
68259: LIST
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: LIST
68266: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68267: LD_ADDR_VAR 0 17
68271: PUSH
68272: LD_INT 0
68274: PUSH
68275: LD_INT 0
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: PUSH
68282: LD_INT 0
68284: PUSH
68285: LD_INT 1
68287: NEG
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 1
68295: PUSH
68296: LD_INT 0
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PUSH
68303: LD_INT 1
68305: PUSH
68306: LD_INT 1
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: LD_INT 0
68315: PUSH
68316: LD_INT 1
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: LD_INT 1
68325: NEG
68326: PUSH
68327: LD_INT 0
68329: PUSH
68330: EMPTY
68331: LIST
68332: LIST
68333: PUSH
68334: LD_INT 1
68336: NEG
68337: PUSH
68338: LD_INT 1
68340: NEG
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 1
68348: NEG
68349: PUSH
68350: LD_INT 2
68352: NEG
68353: PUSH
68354: EMPTY
68355: LIST
68356: LIST
68357: PUSH
68358: LD_INT 0
68360: PUSH
68361: LD_INT 2
68363: NEG
68364: PUSH
68365: EMPTY
68366: LIST
68367: LIST
68368: PUSH
68369: LD_INT 1
68371: PUSH
68372: LD_INT 1
68374: NEG
68375: PUSH
68376: EMPTY
68377: LIST
68378: LIST
68379: PUSH
68380: LD_INT 2
68382: PUSH
68383: LD_INT 0
68385: PUSH
68386: EMPTY
68387: LIST
68388: LIST
68389: PUSH
68390: LD_INT 2
68392: PUSH
68393: LD_INT 1
68395: PUSH
68396: EMPTY
68397: LIST
68398: LIST
68399: PUSH
68400: LD_INT 2
68402: PUSH
68403: LD_INT 2
68405: PUSH
68406: EMPTY
68407: LIST
68408: LIST
68409: PUSH
68410: LD_INT 1
68412: PUSH
68413: LD_INT 2
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: PUSH
68420: LD_INT 0
68422: PUSH
68423: LD_INT 2
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 1
68432: NEG
68433: PUSH
68434: LD_INT 1
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: PUSH
68441: LD_INT 2
68443: NEG
68444: PUSH
68445: LD_INT 0
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: PUSH
68452: LD_INT 2
68454: NEG
68455: PUSH
68456: LD_INT 1
68458: NEG
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 2
68466: NEG
68467: PUSH
68468: LD_INT 2
68470: NEG
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: EMPTY
68477: LIST
68478: LIST
68479: LIST
68480: LIST
68481: LIST
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: LIST
68496: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68497: LD_ADDR_VAR 0 18
68501: PUSH
68502: LD_INT 0
68504: PUSH
68505: LD_INT 0
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PUSH
68512: LD_INT 0
68514: PUSH
68515: LD_INT 1
68517: NEG
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PUSH
68523: LD_INT 1
68525: PUSH
68526: LD_INT 0
68528: PUSH
68529: EMPTY
68530: LIST
68531: LIST
68532: PUSH
68533: LD_INT 1
68535: PUSH
68536: LD_INT 1
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: LD_INT 0
68545: PUSH
68546: LD_INT 1
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: LD_INT 1
68555: NEG
68556: PUSH
68557: LD_INT 0
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 1
68566: NEG
68567: PUSH
68568: LD_INT 1
68570: NEG
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 1
68578: NEG
68579: PUSH
68580: LD_INT 2
68582: NEG
68583: PUSH
68584: EMPTY
68585: LIST
68586: LIST
68587: PUSH
68588: LD_INT 0
68590: PUSH
68591: LD_INT 2
68593: NEG
68594: PUSH
68595: EMPTY
68596: LIST
68597: LIST
68598: PUSH
68599: LD_INT 1
68601: PUSH
68602: LD_INT 1
68604: NEG
68605: PUSH
68606: EMPTY
68607: LIST
68608: LIST
68609: PUSH
68610: LD_INT 2
68612: PUSH
68613: LD_INT 0
68615: PUSH
68616: EMPTY
68617: LIST
68618: LIST
68619: PUSH
68620: LD_INT 2
68622: PUSH
68623: LD_INT 1
68625: PUSH
68626: EMPTY
68627: LIST
68628: LIST
68629: PUSH
68630: LD_INT 2
68632: PUSH
68633: LD_INT 2
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 1
68642: PUSH
68643: LD_INT 2
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: PUSH
68650: LD_INT 0
68652: PUSH
68653: LD_INT 2
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: PUSH
68660: LD_INT 1
68662: NEG
68663: PUSH
68664: LD_INT 1
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 2
68673: NEG
68674: PUSH
68675: LD_INT 0
68677: PUSH
68678: EMPTY
68679: LIST
68680: LIST
68681: PUSH
68682: LD_INT 2
68684: NEG
68685: PUSH
68686: LD_INT 1
68688: NEG
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: LD_INT 2
68696: NEG
68697: PUSH
68698: LD_INT 2
68700: NEG
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: LIST
68724: LIST
68725: LIST
68726: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68727: LD_ADDR_VAR 0 19
68731: PUSH
68732: LD_INT 0
68734: PUSH
68735: LD_INT 0
68737: PUSH
68738: EMPTY
68739: LIST
68740: LIST
68741: PUSH
68742: LD_INT 0
68744: PUSH
68745: LD_INT 1
68747: NEG
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PUSH
68753: LD_INT 1
68755: PUSH
68756: LD_INT 0
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PUSH
68763: LD_INT 1
68765: PUSH
68766: LD_INT 1
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 0
68775: PUSH
68776: LD_INT 1
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 1
68785: NEG
68786: PUSH
68787: LD_INT 0
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: PUSH
68794: LD_INT 1
68796: NEG
68797: PUSH
68798: LD_INT 1
68800: NEG
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 1
68808: NEG
68809: PUSH
68810: LD_INT 2
68812: NEG
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: PUSH
68818: LD_INT 0
68820: PUSH
68821: LD_INT 2
68823: NEG
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 1
68831: PUSH
68832: LD_INT 1
68834: NEG
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: PUSH
68840: LD_INT 2
68842: PUSH
68843: LD_INT 0
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: PUSH
68850: LD_INT 2
68852: PUSH
68853: LD_INT 1
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: LD_INT 2
68862: PUSH
68863: LD_INT 2
68865: PUSH
68866: EMPTY
68867: LIST
68868: LIST
68869: PUSH
68870: LD_INT 1
68872: PUSH
68873: LD_INT 2
68875: PUSH
68876: EMPTY
68877: LIST
68878: LIST
68879: PUSH
68880: LD_INT 0
68882: PUSH
68883: LD_INT 2
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PUSH
68890: LD_INT 1
68892: NEG
68893: PUSH
68894: LD_INT 1
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 2
68903: NEG
68904: PUSH
68905: LD_INT 0
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 2
68914: NEG
68915: PUSH
68916: LD_INT 1
68918: NEG
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 2
68926: NEG
68927: PUSH
68928: LD_INT 2
68930: NEG
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68957: LD_ADDR_VAR 0 20
68961: PUSH
68962: LD_INT 0
68964: PUSH
68965: LD_INT 0
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: PUSH
68972: LD_INT 0
68974: PUSH
68975: LD_INT 1
68977: NEG
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: LD_INT 1
68985: PUSH
68986: LD_INT 0
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 1
68995: PUSH
68996: LD_INT 1
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 0
69005: PUSH
69006: LD_INT 1
69008: PUSH
69009: EMPTY
69010: LIST
69011: LIST
69012: PUSH
69013: LD_INT 1
69015: NEG
69016: PUSH
69017: LD_INT 0
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PUSH
69024: LD_INT 1
69026: NEG
69027: PUSH
69028: LD_INT 1
69030: NEG
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: LD_INT 1
69038: NEG
69039: PUSH
69040: LD_INT 2
69042: NEG
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: LD_INT 0
69050: PUSH
69051: LD_INT 2
69053: NEG
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 1
69061: PUSH
69062: LD_INT 1
69064: NEG
69065: PUSH
69066: EMPTY
69067: LIST
69068: LIST
69069: PUSH
69070: LD_INT 2
69072: PUSH
69073: LD_INT 0
69075: PUSH
69076: EMPTY
69077: LIST
69078: LIST
69079: PUSH
69080: LD_INT 2
69082: PUSH
69083: LD_INT 1
69085: PUSH
69086: EMPTY
69087: LIST
69088: LIST
69089: PUSH
69090: LD_INT 2
69092: PUSH
69093: LD_INT 2
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: PUSH
69100: LD_INT 1
69102: PUSH
69103: LD_INT 2
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 0
69112: PUSH
69113: LD_INT 2
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 1
69122: NEG
69123: PUSH
69124: LD_INT 1
69126: PUSH
69127: EMPTY
69128: LIST
69129: LIST
69130: PUSH
69131: LD_INT 2
69133: NEG
69134: PUSH
69135: LD_INT 0
69137: PUSH
69138: EMPTY
69139: LIST
69140: LIST
69141: PUSH
69142: LD_INT 2
69144: NEG
69145: PUSH
69146: LD_INT 1
69148: NEG
69149: PUSH
69150: EMPTY
69151: LIST
69152: LIST
69153: PUSH
69154: LD_INT 2
69156: NEG
69157: PUSH
69158: LD_INT 2
69160: NEG
69161: PUSH
69162: EMPTY
69163: LIST
69164: LIST
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69187: LD_ADDR_VAR 0 21
69191: PUSH
69192: LD_INT 0
69194: PUSH
69195: LD_INT 0
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 0
69204: PUSH
69205: LD_INT 1
69207: NEG
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: PUSH
69213: LD_INT 1
69215: PUSH
69216: LD_INT 0
69218: PUSH
69219: EMPTY
69220: LIST
69221: LIST
69222: PUSH
69223: LD_INT 1
69225: PUSH
69226: LD_INT 1
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: LD_INT 0
69235: PUSH
69236: LD_INT 1
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: PUSH
69243: LD_INT 1
69245: NEG
69246: PUSH
69247: LD_INT 0
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PUSH
69254: LD_INT 1
69256: NEG
69257: PUSH
69258: LD_INT 1
69260: NEG
69261: PUSH
69262: EMPTY
69263: LIST
69264: LIST
69265: PUSH
69266: LD_INT 1
69268: NEG
69269: PUSH
69270: LD_INT 2
69272: NEG
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: PUSH
69278: LD_INT 0
69280: PUSH
69281: LD_INT 2
69283: NEG
69284: PUSH
69285: EMPTY
69286: LIST
69287: LIST
69288: PUSH
69289: LD_INT 1
69291: PUSH
69292: LD_INT 1
69294: NEG
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: LD_INT 2
69302: PUSH
69303: LD_INT 0
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: LD_INT 2
69312: PUSH
69313: LD_INT 1
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: PUSH
69320: LD_INT 2
69322: PUSH
69323: LD_INT 2
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: PUSH
69330: LD_INT 1
69332: PUSH
69333: LD_INT 2
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 0
69342: PUSH
69343: LD_INT 2
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: LD_INT 1
69352: NEG
69353: PUSH
69354: LD_INT 1
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: PUSH
69361: LD_INT 2
69363: NEG
69364: PUSH
69365: LD_INT 0
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: PUSH
69372: LD_INT 2
69374: NEG
69375: PUSH
69376: LD_INT 1
69378: NEG
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 2
69386: NEG
69387: PUSH
69388: LD_INT 2
69390: NEG
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69417: LD_ADDR_VAR 0 22
69421: PUSH
69422: LD_INT 0
69424: PUSH
69425: LD_INT 0
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: PUSH
69432: LD_INT 0
69434: PUSH
69435: LD_INT 1
69437: NEG
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: PUSH
69443: LD_INT 1
69445: PUSH
69446: LD_INT 0
69448: PUSH
69449: EMPTY
69450: LIST
69451: LIST
69452: PUSH
69453: LD_INT 1
69455: PUSH
69456: LD_INT 1
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 0
69465: PUSH
69466: LD_INT 1
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PUSH
69473: LD_INT 1
69475: NEG
69476: PUSH
69477: LD_INT 0
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: LD_INT 1
69486: NEG
69487: PUSH
69488: LD_INT 1
69490: NEG
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 1
69498: NEG
69499: PUSH
69500: LD_INT 2
69502: NEG
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 0
69510: PUSH
69511: LD_INT 2
69513: NEG
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: LD_INT 1
69521: PUSH
69522: LD_INT 1
69524: NEG
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 2
69532: PUSH
69533: LD_INT 0
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: PUSH
69540: LD_INT 2
69542: PUSH
69543: LD_INT 1
69545: PUSH
69546: EMPTY
69547: LIST
69548: LIST
69549: PUSH
69550: LD_INT 2
69552: PUSH
69553: LD_INT 2
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 1
69562: PUSH
69563: LD_INT 2
69565: PUSH
69566: EMPTY
69567: LIST
69568: LIST
69569: PUSH
69570: LD_INT 0
69572: PUSH
69573: LD_INT 2
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 1
69582: NEG
69583: PUSH
69584: LD_INT 1
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: PUSH
69591: LD_INT 2
69593: NEG
69594: PUSH
69595: LD_INT 0
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: PUSH
69602: LD_INT 2
69604: NEG
69605: PUSH
69606: LD_INT 1
69608: NEG
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PUSH
69614: LD_INT 2
69616: NEG
69617: PUSH
69618: LD_INT 2
69620: NEG
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69647: LD_ADDR_VAR 0 23
69651: PUSH
69652: LD_INT 0
69654: PUSH
69655: LD_INT 0
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: PUSH
69662: LD_INT 0
69664: PUSH
69665: LD_INT 1
69667: NEG
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 1
69675: PUSH
69676: LD_INT 0
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: LD_INT 1
69685: PUSH
69686: LD_INT 1
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: PUSH
69693: LD_INT 0
69695: PUSH
69696: LD_INT 1
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 1
69705: NEG
69706: PUSH
69707: LD_INT 0
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 1
69716: NEG
69717: PUSH
69718: LD_INT 1
69720: NEG
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 1
69728: NEG
69729: PUSH
69730: LD_INT 2
69732: NEG
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: LD_INT 0
69740: PUSH
69741: LD_INT 2
69743: NEG
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PUSH
69749: LD_INT 1
69751: PUSH
69752: LD_INT 1
69754: NEG
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: PUSH
69760: LD_INT 2
69762: PUSH
69763: LD_INT 0
69765: PUSH
69766: EMPTY
69767: LIST
69768: LIST
69769: PUSH
69770: LD_INT 2
69772: PUSH
69773: LD_INT 1
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: PUSH
69780: LD_INT 2
69782: PUSH
69783: LD_INT 2
69785: PUSH
69786: EMPTY
69787: LIST
69788: LIST
69789: PUSH
69790: LD_INT 1
69792: PUSH
69793: LD_INT 2
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PUSH
69800: LD_INT 0
69802: PUSH
69803: LD_INT 2
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 1
69812: NEG
69813: PUSH
69814: LD_INT 1
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 2
69823: NEG
69824: PUSH
69825: LD_INT 0
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 2
69834: NEG
69835: PUSH
69836: LD_INT 1
69838: NEG
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 2
69846: NEG
69847: PUSH
69848: LD_INT 2
69850: NEG
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: PUSH
69856: LD_INT 2
69858: NEG
69859: PUSH
69860: LD_INT 3
69862: NEG
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: LD_INT 1
69870: NEG
69871: PUSH
69872: LD_INT 3
69874: NEG
69875: PUSH
69876: EMPTY
69877: LIST
69878: LIST
69879: PUSH
69880: LD_INT 1
69882: PUSH
69883: LD_INT 2
69885: NEG
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 2
69893: PUSH
69894: LD_INT 1
69896: NEG
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: LIST
69906: LIST
69907: LIST
69908: LIST
69909: LIST
69910: LIST
69911: LIST
69912: LIST
69913: LIST
69914: LIST
69915: LIST
69916: LIST
69917: LIST
69918: LIST
69919: LIST
69920: LIST
69921: LIST
69922: LIST
69923: LIST
69924: LIST
69925: LIST
69926: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69927: LD_ADDR_VAR 0 24
69931: PUSH
69932: LD_INT 0
69934: PUSH
69935: LD_INT 0
69937: PUSH
69938: EMPTY
69939: LIST
69940: LIST
69941: PUSH
69942: LD_INT 0
69944: PUSH
69945: LD_INT 1
69947: NEG
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PUSH
69953: LD_INT 1
69955: PUSH
69956: LD_INT 0
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: LD_INT 1
69965: PUSH
69966: LD_INT 1
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: PUSH
69973: LD_INT 0
69975: PUSH
69976: LD_INT 1
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PUSH
69983: LD_INT 1
69985: NEG
69986: PUSH
69987: LD_INT 0
69989: PUSH
69990: EMPTY
69991: LIST
69992: LIST
69993: PUSH
69994: LD_INT 1
69996: NEG
69997: PUSH
69998: LD_INT 1
70000: NEG
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: LD_INT 1
70008: NEG
70009: PUSH
70010: LD_INT 2
70012: NEG
70013: PUSH
70014: EMPTY
70015: LIST
70016: LIST
70017: PUSH
70018: LD_INT 0
70020: PUSH
70021: LD_INT 2
70023: NEG
70024: PUSH
70025: EMPTY
70026: LIST
70027: LIST
70028: PUSH
70029: LD_INT 1
70031: PUSH
70032: LD_INT 1
70034: NEG
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 2
70042: PUSH
70043: LD_INT 0
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: LD_INT 2
70052: PUSH
70053: LD_INT 1
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: PUSH
70060: LD_INT 2
70062: PUSH
70063: LD_INT 2
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 1
70072: PUSH
70073: LD_INT 2
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 0
70082: PUSH
70083: LD_INT 2
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: PUSH
70090: LD_INT 1
70092: NEG
70093: PUSH
70094: LD_INT 1
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 2
70103: NEG
70104: PUSH
70105: LD_INT 0
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: PUSH
70112: LD_INT 2
70114: NEG
70115: PUSH
70116: LD_INT 1
70118: NEG
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 2
70126: NEG
70127: PUSH
70128: LD_INT 2
70130: NEG
70131: PUSH
70132: EMPTY
70133: LIST
70134: LIST
70135: PUSH
70136: LD_INT 1
70138: PUSH
70139: LD_INT 2
70141: NEG
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PUSH
70147: LD_INT 2
70149: PUSH
70150: LD_INT 1
70152: NEG
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: LD_INT 3
70160: PUSH
70161: LD_INT 1
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PUSH
70168: LD_INT 3
70170: PUSH
70171: LD_INT 2
70173: PUSH
70174: EMPTY
70175: LIST
70176: LIST
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: LIST
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
70203: LD_ADDR_VAR 0 25
70207: PUSH
70208: LD_INT 0
70210: PUSH
70211: LD_INT 0
70213: PUSH
70214: EMPTY
70215: LIST
70216: LIST
70217: PUSH
70218: LD_INT 0
70220: PUSH
70221: LD_INT 1
70223: NEG
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: PUSH
70229: LD_INT 1
70231: PUSH
70232: LD_INT 0
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: LD_INT 1
70241: PUSH
70242: LD_INT 1
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: LD_INT 0
70251: PUSH
70252: LD_INT 1
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: PUSH
70259: LD_INT 1
70261: NEG
70262: PUSH
70263: LD_INT 0
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 1
70272: NEG
70273: PUSH
70274: LD_INT 1
70276: NEG
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 1
70284: NEG
70285: PUSH
70286: LD_INT 2
70288: NEG
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: LD_INT 0
70296: PUSH
70297: LD_INT 2
70299: NEG
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 1
70307: PUSH
70308: LD_INT 1
70310: NEG
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 2
70318: PUSH
70319: LD_INT 0
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 2
70328: PUSH
70329: LD_INT 1
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 2
70338: PUSH
70339: LD_INT 2
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: LD_INT 1
70348: PUSH
70349: LD_INT 2
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 0
70358: PUSH
70359: LD_INT 2
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 1
70368: NEG
70369: PUSH
70370: LD_INT 1
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 2
70379: NEG
70380: PUSH
70381: LD_INT 0
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: PUSH
70388: LD_INT 2
70390: NEG
70391: PUSH
70392: LD_INT 1
70394: NEG
70395: PUSH
70396: EMPTY
70397: LIST
70398: LIST
70399: PUSH
70400: LD_INT 2
70402: NEG
70403: PUSH
70404: LD_INT 2
70406: NEG
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: PUSH
70412: LD_INT 3
70414: PUSH
70415: LD_INT 1
70417: PUSH
70418: EMPTY
70419: LIST
70420: LIST
70421: PUSH
70422: LD_INT 3
70424: PUSH
70425: LD_INT 2
70427: PUSH
70428: EMPTY
70429: LIST
70430: LIST
70431: PUSH
70432: LD_INT 2
70434: PUSH
70435: LD_INT 3
70437: PUSH
70438: EMPTY
70439: LIST
70440: LIST
70441: PUSH
70442: LD_INT 1
70444: PUSH
70445: LD_INT 3
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: LIST
70456: LIST
70457: LIST
70458: LIST
70459: LIST
70460: LIST
70461: LIST
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
70477: LD_ADDR_VAR 0 26
70481: PUSH
70482: LD_INT 0
70484: PUSH
70485: LD_INT 0
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PUSH
70492: LD_INT 0
70494: PUSH
70495: LD_INT 1
70497: NEG
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 1
70505: PUSH
70506: LD_INT 0
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 1
70515: PUSH
70516: LD_INT 1
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 0
70525: PUSH
70526: LD_INT 1
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: PUSH
70533: LD_INT 1
70535: NEG
70536: PUSH
70537: LD_INT 0
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 1
70546: NEG
70547: PUSH
70548: LD_INT 1
70550: NEG
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 1
70558: NEG
70559: PUSH
70560: LD_INT 2
70562: NEG
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: LD_INT 0
70570: PUSH
70571: LD_INT 2
70573: NEG
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 1
70581: PUSH
70582: LD_INT 1
70584: NEG
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 2
70592: PUSH
70593: LD_INT 0
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: PUSH
70600: LD_INT 2
70602: PUSH
70603: LD_INT 1
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 2
70612: PUSH
70613: LD_INT 2
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 1
70622: PUSH
70623: LD_INT 2
70625: PUSH
70626: EMPTY
70627: LIST
70628: LIST
70629: PUSH
70630: LD_INT 0
70632: PUSH
70633: LD_INT 2
70635: PUSH
70636: EMPTY
70637: LIST
70638: LIST
70639: PUSH
70640: LD_INT 1
70642: NEG
70643: PUSH
70644: LD_INT 1
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: LD_INT 2
70653: NEG
70654: PUSH
70655: LD_INT 0
70657: PUSH
70658: EMPTY
70659: LIST
70660: LIST
70661: PUSH
70662: LD_INT 2
70664: NEG
70665: PUSH
70666: LD_INT 1
70668: NEG
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 2
70676: NEG
70677: PUSH
70678: LD_INT 2
70680: NEG
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: PUSH
70686: LD_INT 2
70688: PUSH
70689: LD_INT 3
70691: PUSH
70692: EMPTY
70693: LIST
70694: LIST
70695: PUSH
70696: LD_INT 1
70698: PUSH
70699: LD_INT 3
70701: PUSH
70702: EMPTY
70703: LIST
70704: LIST
70705: PUSH
70706: LD_INT 1
70708: NEG
70709: PUSH
70710: LD_INT 2
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: LD_INT 2
70719: NEG
70720: PUSH
70721: LD_INT 1
70723: PUSH
70724: EMPTY
70725: LIST
70726: LIST
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: LIST
70735: LIST
70736: LIST
70737: LIST
70738: LIST
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70753: LD_ADDR_VAR 0 27
70757: PUSH
70758: LD_INT 0
70760: PUSH
70761: LD_INT 0
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: PUSH
70768: LD_INT 0
70770: PUSH
70771: LD_INT 1
70773: NEG
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 1
70781: PUSH
70782: LD_INT 0
70784: PUSH
70785: EMPTY
70786: LIST
70787: LIST
70788: PUSH
70789: LD_INT 1
70791: PUSH
70792: LD_INT 1
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: PUSH
70799: LD_INT 0
70801: PUSH
70802: LD_INT 1
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 1
70811: NEG
70812: PUSH
70813: LD_INT 0
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 1
70822: NEG
70823: PUSH
70824: LD_INT 1
70826: NEG
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 1
70834: NEG
70835: PUSH
70836: LD_INT 2
70838: NEG
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PUSH
70844: LD_INT 0
70846: PUSH
70847: LD_INT 2
70849: NEG
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 1
70857: PUSH
70858: LD_INT 1
70860: NEG
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 2
70868: PUSH
70869: LD_INT 0
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: LD_INT 2
70878: PUSH
70879: LD_INT 1
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: LD_INT 2
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: LD_INT 2
70901: PUSH
70902: EMPTY
70903: LIST
70904: LIST
70905: PUSH
70906: LD_INT 0
70908: PUSH
70909: LD_INT 2
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PUSH
70916: LD_INT 1
70918: NEG
70919: PUSH
70920: LD_INT 1
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 2
70929: NEG
70930: PUSH
70931: LD_INT 0
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: LD_INT 2
70940: NEG
70941: PUSH
70942: LD_INT 1
70944: NEG
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 2
70952: NEG
70953: PUSH
70954: LD_INT 2
70956: NEG
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: PUSH
70962: LD_INT 1
70964: NEG
70965: PUSH
70966: LD_INT 2
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: LD_INT 2
70975: NEG
70976: PUSH
70977: LD_INT 1
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 3
70986: NEG
70987: PUSH
70988: LD_INT 1
70990: NEG
70991: PUSH
70992: EMPTY
70993: LIST
70994: LIST
70995: PUSH
70996: LD_INT 3
70998: NEG
70999: PUSH
71000: LD_INT 2
71002: NEG
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: LIST
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71033: LD_ADDR_VAR 0 28
71037: PUSH
71038: LD_INT 0
71040: PUSH
71041: LD_INT 0
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 0
71050: PUSH
71051: LD_INT 1
71053: NEG
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 1
71061: PUSH
71062: LD_INT 0
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: LD_INT 1
71071: PUSH
71072: LD_INT 1
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: PUSH
71079: LD_INT 0
71081: PUSH
71082: LD_INT 1
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 1
71091: NEG
71092: PUSH
71093: LD_INT 0
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: LD_INT 1
71102: NEG
71103: PUSH
71104: LD_INT 1
71106: NEG
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 1
71114: NEG
71115: PUSH
71116: LD_INT 2
71118: NEG
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: LD_INT 0
71126: PUSH
71127: LD_INT 2
71129: NEG
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 1
71137: PUSH
71138: LD_INT 1
71140: NEG
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 2
71148: PUSH
71149: LD_INT 0
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 2
71158: PUSH
71159: LD_INT 1
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 2
71168: PUSH
71169: LD_INT 2
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: LD_INT 1
71178: PUSH
71179: LD_INT 2
71181: PUSH
71182: EMPTY
71183: LIST
71184: LIST
71185: PUSH
71186: LD_INT 0
71188: PUSH
71189: LD_INT 2
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: LD_INT 1
71198: NEG
71199: PUSH
71200: LD_INT 1
71202: PUSH
71203: EMPTY
71204: LIST
71205: LIST
71206: PUSH
71207: LD_INT 2
71209: NEG
71210: PUSH
71211: LD_INT 0
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PUSH
71218: LD_INT 2
71220: NEG
71221: PUSH
71222: LD_INT 1
71224: NEG
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: PUSH
71230: LD_INT 2
71232: NEG
71233: PUSH
71234: LD_INT 2
71236: NEG
71237: PUSH
71238: EMPTY
71239: LIST
71240: LIST
71241: PUSH
71242: LD_INT 2
71244: NEG
71245: PUSH
71246: LD_INT 3
71248: NEG
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: LD_INT 1
71256: NEG
71257: PUSH
71258: LD_INT 3
71260: NEG
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PUSH
71266: LD_INT 3
71268: NEG
71269: PUSH
71270: LD_INT 1
71272: NEG
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 3
71280: NEG
71281: PUSH
71282: LD_INT 2
71284: NEG
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71315: LD_ADDR_VAR 0 29
71319: PUSH
71320: LD_INT 0
71322: PUSH
71323: LD_INT 0
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PUSH
71330: LD_INT 0
71332: PUSH
71333: LD_INT 1
71335: NEG
71336: PUSH
71337: EMPTY
71338: LIST
71339: LIST
71340: PUSH
71341: LD_INT 1
71343: PUSH
71344: LD_INT 0
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 1
71353: PUSH
71354: LD_INT 1
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: PUSH
71361: LD_INT 0
71363: PUSH
71364: LD_INT 1
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: PUSH
71371: LD_INT 1
71373: NEG
71374: PUSH
71375: LD_INT 0
71377: PUSH
71378: EMPTY
71379: LIST
71380: LIST
71381: PUSH
71382: LD_INT 1
71384: NEG
71385: PUSH
71386: LD_INT 1
71388: NEG
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PUSH
71394: LD_INT 1
71396: NEG
71397: PUSH
71398: LD_INT 2
71400: NEG
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: PUSH
71406: LD_INT 0
71408: PUSH
71409: LD_INT 2
71411: NEG
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 1
71419: PUSH
71420: LD_INT 1
71422: NEG
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: LD_INT 2
71430: PUSH
71431: LD_INT 0
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 2
71440: PUSH
71441: LD_INT 1
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: PUSH
71448: LD_INT 1
71450: PUSH
71451: LD_INT 2
71453: PUSH
71454: EMPTY
71455: LIST
71456: LIST
71457: PUSH
71458: LD_INT 0
71460: PUSH
71461: LD_INT 2
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: LD_INT 1
71470: NEG
71471: PUSH
71472: LD_INT 1
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 2
71481: NEG
71482: PUSH
71483: LD_INT 1
71485: NEG
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 2
71493: NEG
71494: PUSH
71495: LD_INT 2
71497: NEG
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 2
71505: NEG
71506: PUSH
71507: LD_INT 3
71509: NEG
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: LD_INT 2
71517: PUSH
71518: LD_INT 1
71520: NEG
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: PUSH
71526: LD_INT 3
71528: PUSH
71529: LD_INT 1
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PUSH
71536: LD_INT 1
71538: PUSH
71539: LD_INT 3
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: LD_INT 1
71548: NEG
71549: PUSH
71550: LD_INT 2
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 3
71559: NEG
71560: PUSH
71561: LD_INT 2
71563: NEG
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: LIST
71573: LIST
71574: LIST
71575: LIST
71576: LIST
71577: LIST
71578: LIST
71579: LIST
71580: LIST
71581: LIST
71582: LIST
71583: LIST
71584: LIST
71585: LIST
71586: LIST
71587: LIST
71588: LIST
71589: LIST
71590: LIST
71591: LIST
71592: LIST
71593: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71594: LD_ADDR_VAR 0 30
71598: PUSH
71599: LD_INT 0
71601: PUSH
71602: LD_INT 0
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: PUSH
71609: LD_INT 0
71611: PUSH
71612: LD_INT 1
71614: NEG
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: PUSH
71620: LD_INT 1
71622: PUSH
71623: LD_INT 0
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: PUSH
71630: LD_INT 1
71632: PUSH
71633: LD_INT 1
71635: PUSH
71636: EMPTY
71637: LIST
71638: LIST
71639: PUSH
71640: LD_INT 0
71642: PUSH
71643: LD_INT 1
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 1
71652: NEG
71653: PUSH
71654: LD_INT 0
71656: PUSH
71657: EMPTY
71658: LIST
71659: LIST
71660: PUSH
71661: LD_INT 1
71663: NEG
71664: PUSH
71665: LD_INT 1
71667: NEG
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: PUSH
71673: LD_INT 1
71675: NEG
71676: PUSH
71677: LD_INT 2
71679: NEG
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: PUSH
71685: LD_INT 0
71687: PUSH
71688: LD_INT 2
71690: NEG
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PUSH
71696: LD_INT 1
71698: PUSH
71699: LD_INT 1
71701: NEG
71702: PUSH
71703: EMPTY
71704: LIST
71705: LIST
71706: PUSH
71707: LD_INT 2
71709: PUSH
71710: LD_INT 0
71712: PUSH
71713: EMPTY
71714: LIST
71715: LIST
71716: PUSH
71717: LD_INT 2
71719: PUSH
71720: LD_INT 1
71722: PUSH
71723: EMPTY
71724: LIST
71725: LIST
71726: PUSH
71727: LD_INT 2
71729: PUSH
71730: LD_INT 2
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: PUSH
71737: LD_INT 1
71739: PUSH
71740: LD_INT 2
71742: PUSH
71743: EMPTY
71744: LIST
71745: LIST
71746: PUSH
71747: LD_INT 1
71749: NEG
71750: PUSH
71751: LD_INT 1
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 2
71760: NEG
71761: PUSH
71762: LD_INT 0
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 2
71771: NEG
71772: PUSH
71773: LD_INT 1
71775: NEG
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 1
71783: NEG
71784: PUSH
71785: LD_INT 3
71787: NEG
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: LD_INT 1
71795: PUSH
71796: LD_INT 2
71798: NEG
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: PUSH
71804: LD_INT 3
71806: PUSH
71807: LD_INT 2
71809: PUSH
71810: EMPTY
71811: LIST
71812: LIST
71813: PUSH
71814: LD_INT 2
71816: PUSH
71817: LD_INT 3
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 2
71826: NEG
71827: PUSH
71828: LD_INT 1
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PUSH
71835: LD_INT 3
71837: NEG
71838: PUSH
71839: LD_INT 1
71841: NEG
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: LIST
71851: LIST
71852: LIST
71853: LIST
71854: LIST
71855: LIST
71856: LIST
71857: LIST
71858: LIST
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71872: LD_ADDR_VAR 0 31
71876: PUSH
71877: LD_INT 0
71879: PUSH
71880: LD_INT 0
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: LD_INT 0
71889: PUSH
71890: LD_INT 1
71892: NEG
71893: PUSH
71894: EMPTY
71895: LIST
71896: LIST
71897: PUSH
71898: LD_INT 1
71900: PUSH
71901: LD_INT 0
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: PUSH
71908: LD_INT 1
71910: PUSH
71911: LD_INT 1
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: PUSH
71918: LD_INT 0
71920: PUSH
71921: LD_INT 1
71923: PUSH
71924: EMPTY
71925: LIST
71926: LIST
71927: PUSH
71928: LD_INT 1
71930: NEG
71931: PUSH
71932: LD_INT 0
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PUSH
71939: LD_INT 1
71941: NEG
71942: PUSH
71943: LD_INT 1
71945: NEG
71946: PUSH
71947: EMPTY
71948: LIST
71949: LIST
71950: PUSH
71951: LD_INT 1
71953: NEG
71954: PUSH
71955: LD_INT 2
71957: NEG
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 1
71965: PUSH
71966: LD_INT 1
71968: NEG
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: PUSH
71974: LD_INT 2
71976: PUSH
71977: LD_INT 0
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: PUSH
71984: LD_INT 2
71986: PUSH
71987: LD_INT 1
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 2
71996: PUSH
71997: LD_INT 2
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: LD_INT 1
72006: PUSH
72007: LD_INT 2
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 0
72016: PUSH
72017: LD_INT 2
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 1
72026: NEG
72027: PUSH
72028: LD_INT 1
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 2
72037: NEG
72038: PUSH
72039: LD_INT 1
72041: NEG
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: LD_INT 2
72049: NEG
72050: PUSH
72051: LD_INT 2
72053: NEG
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: LD_INT 2
72061: NEG
72062: PUSH
72063: LD_INT 3
72065: NEG
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 2
72073: PUSH
72074: LD_INT 1
72076: NEG
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: LD_INT 3
72084: PUSH
72085: LD_INT 1
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: PUSH
72092: LD_INT 1
72094: PUSH
72095: LD_INT 3
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: PUSH
72102: LD_INT 1
72104: NEG
72105: PUSH
72106: LD_INT 2
72108: PUSH
72109: EMPTY
72110: LIST
72111: LIST
72112: PUSH
72113: LD_INT 3
72115: NEG
72116: PUSH
72117: LD_INT 2
72119: NEG
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: LIST
72129: LIST
72130: LIST
72131: LIST
72132: LIST
72133: LIST
72134: LIST
72135: LIST
72136: LIST
72137: LIST
72138: LIST
72139: LIST
72140: LIST
72141: LIST
72142: LIST
72143: LIST
72144: LIST
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72150: LD_ADDR_VAR 0 32
72154: PUSH
72155: LD_INT 0
72157: PUSH
72158: LD_INT 0
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: LD_INT 0
72167: PUSH
72168: LD_INT 1
72170: NEG
72171: PUSH
72172: EMPTY
72173: LIST
72174: LIST
72175: PUSH
72176: LD_INT 1
72178: PUSH
72179: LD_INT 0
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 1
72188: PUSH
72189: LD_INT 1
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: LD_INT 0
72198: PUSH
72199: LD_INT 1
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: LD_INT 1
72208: NEG
72209: PUSH
72210: LD_INT 0
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: PUSH
72217: LD_INT 1
72219: NEG
72220: PUSH
72221: LD_INT 1
72223: NEG
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 1
72231: NEG
72232: PUSH
72233: LD_INT 2
72235: NEG
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 0
72243: PUSH
72244: LD_INT 2
72246: NEG
72247: PUSH
72248: EMPTY
72249: LIST
72250: LIST
72251: PUSH
72252: LD_INT 1
72254: PUSH
72255: LD_INT 1
72257: NEG
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: LD_INT 2
72265: PUSH
72266: LD_INT 1
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 2
72275: PUSH
72276: LD_INT 2
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PUSH
72283: LD_INT 1
72285: PUSH
72286: LD_INT 2
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 0
72295: PUSH
72296: LD_INT 2
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 1
72305: NEG
72306: PUSH
72307: LD_INT 1
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 2
72316: NEG
72317: PUSH
72318: LD_INT 0
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 2
72327: NEG
72328: PUSH
72329: LD_INT 1
72331: NEG
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 1
72339: NEG
72340: PUSH
72341: LD_INT 3
72343: NEG
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 1
72351: PUSH
72352: LD_INT 2
72354: NEG
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: LD_INT 3
72362: PUSH
72363: LD_INT 2
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: LD_INT 2
72372: PUSH
72373: LD_INT 3
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: LD_INT 2
72382: NEG
72383: PUSH
72384: LD_INT 1
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 3
72393: NEG
72394: PUSH
72395: LD_INT 1
72397: NEG
72398: PUSH
72399: EMPTY
72400: LIST
72401: LIST
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: LIST
72407: LIST
72408: LIST
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: LIST
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: LIST
72419: LIST
72420: LIST
72421: LIST
72422: LIST
72423: LIST
72424: LIST
72425: LIST
72426: LIST
72427: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72428: LD_ADDR_VAR 0 33
72432: PUSH
72433: LD_INT 0
72435: PUSH
72436: LD_INT 0
72438: PUSH
72439: EMPTY
72440: LIST
72441: LIST
72442: PUSH
72443: LD_INT 0
72445: PUSH
72446: LD_INT 1
72448: NEG
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: PUSH
72454: LD_INT 1
72456: PUSH
72457: LD_INT 0
72459: PUSH
72460: EMPTY
72461: LIST
72462: LIST
72463: PUSH
72464: LD_INT 1
72466: PUSH
72467: LD_INT 1
72469: PUSH
72470: EMPTY
72471: LIST
72472: LIST
72473: PUSH
72474: LD_INT 0
72476: PUSH
72477: LD_INT 1
72479: PUSH
72480: EMPTY
72481: LIST
72482: LIST
72483: PUSH
72484: LD_INT 1
72486: NEG
72487: PUSH
72488: LD_INT 0
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PUSH
72495: LD_INT 1
72497: NEG
72498: PUSH
72499: LD_INT 1
72501: NEG
72502: PUSH
72503: EMPTY
72504: LIST
72505: LIST
72506: PUSH
72507: LD_INT 1
72509: NEG
72510: PUSH
72511: LD_INT 2
72513: NEG
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 1
72521: PUSH
72522: LD_INT 1
72524: NEG
72525: PUSH
72526: EMPTY
72527: LIST
72528: LIST
72529: PUSH
72530: LD_INT 2
72532: PUSH
72533: LD_INT 0
72535: PUSH
72536: EMPTY
72537: LIST
72538: LIST
72539: PUSH
72540: LD_INT 2
72542: PUSH
72543: LD_INT 1
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 1
72552: PUSH
72553: LD_INT 2
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 0
72562: PUSH
72563: LD_INT 2
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: LD_INT 1
72572: NEG
72573: PUSH
72574: LD_INT 1
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: PUSH
72581: LD_INT 2
72583: NEG
72584: PUSH
72585: LD_INT 0
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 2
72594: NEG
72595: PUSH
72596: LD_INT 1
72598: NEG
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: PUSH
72604: LD_INT 2
72606: NEG
72607: PUSH
72608: LD_INT 2
72610: NEG
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 2
72618: NEG
72619: PUSH
72620: LD_INT 3
72622: NEG
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: LD_INT 2
72630: PUSH
72631: LD_INT 1
72633: NEG
72634: PUSH
72635: EMPTY
72636: LIST
72637: LIST
72638: PUSH
72639: LD_INT 3
72641: PUSH
72642: LD_INT 1
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PUSH
72649: LD_INT 1
72651: PUSH
72652: LD_INT 3
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: PUSH
72659: LD_INT 1
72661: NEG
72662: PUSH
72663: LD_INT 2
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: PUSH
72670: LD_INT 3
72672: NEG
72673: PUSH
72674: LD_INT 2
72676: NEG
72677: PUSH
72678: EMPTY
72679: LIST
72680: LIST
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: LIST
72686: LIST
72687: LIST
72688: LIST
72689: LIST
72690: LIST
72691: LIST
72692: LIST
72693: LIST
72694: LIST
72695: LIST
72696: LIST
72697: LIST
72698: LIST
72699: LIST
72700: LIST
72701: LIST
72702: LIST
72703: LIST
72704: LIST
72705: LIST
72706: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72707: LD_ADDR_VAR 0 34
72711: PUSH
72712: LD_INT 0
72714: PUSH
72715: LD_INT 0
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: LD_INT 1
72727: NEG
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 1
72735: PUSH
72736: LD_INT 0
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 1
72745: PUSH
72746: LD_INT 1
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 0
72755: PUSH
72756: LD_INT 1
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 1
72765: NEG
72766: PUSH
72767: LD_INT 0
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 1
72776: NEG
72777: PUSH
72778: LD_INT 1
72780: NEG
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 1
72788: NEG
72789: PUSH
72790: LD_INT 2
72792: NEG
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: LD_INT 0
72800: PUSH
72801: LD_INT 2
72803: NEG
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: PUSH
72809: LD_INT 1
72811: PUSH
72812: LD_INT 1
72814: NEG
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: LD_INT 2
72822: PUSH
72823: LD_INT 1
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: LD_INT 2
72832: PUSH
72833: LD_INT 2
72835: PUSH
72836: EMPTY
72837: LIST
72838: LIST
72839: PUSH
72840: LD_INT 1
72842: PUSH
72843: LD_INT 2
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: PUSH
72850: LD_INT 1
72852: NEG
72853: PUSH
72854: LD_INT 1
72856: PUSH
72857: EMPTY
72858: LIST
72859: LIST
72860: PUSH
72861: LD_INT 2
72863: NEG
72864: PUSH
72865: LD_INT 0
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: PUSH
72872: LD_INT 2
72874: NEG
72875: PUSH
72876: LD_INT 1
72878: NEG
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 2
72886: NEG
72887: PUSH
72888: LD_INT 2
72890: NEG
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 1
72898: NEG
72899: PUSH
72900: LD_INT 3
72902: NEG
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 1
72910: PUSH
72911: LD_INT 2
72913: NEG
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: LD_INT 3
72921: PUSH
72922: LD_INT 2
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: PUSH
72929: LD_INT 2
72931: PUSH
72932: LD_INT 3
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: PUSH
72939: LD_INT 2
72941: NEG
72942: PUSH
72943: LD_INT 1
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: PUSH
72950: LD_INT 3
72952: NEG
72953: PUSH
72954: LD_INT 1
72956: NEG
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: LIST
72966: LIST
72967: LIST
72968: LIST
72969: LIST
72970: LIST
72971: LIST
72972: LIST
72973: LIST
72974: LIST
72975: LIST
72976: LIST
72977: LIST
72978: LIST
72979: LIST
72980: LIST
72981: LIST
72982: LIST
72983: LIST
72984: LIST
72985: LIST
72986: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72987: LD_ADDR_VAR 0 35
72991: PUSH
72992: LD_INT 0
72994: PUSH
72995: LD_INT 0
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: PUSH
73002: LD_INT 0
73004: PUSH
73005: LD_INT 1
73007: NEG
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 1
73015: PUSH
73016: LD_INT 0
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: PUSH
73023: LD_INT 1
73025: PUSH
73026: LD_INT 1
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 0
73035: PUSH
73036: LD_INT 1
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: LD_INT 1
73045: NEG
73046: PUSH
73047: LD_INT 0
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: PUSH
73054: LD_INT 1
73056: NEG
73057: PUSH
73058: LD_INT 1
73060: NEG
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: PUSH
73066: LD_INT 2
73068: PUSH
73069: LD_INT 1
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: PUSH
73076: LD_INT 2
73078: NEG
73079: PUSH
73080: LD_INT 1
73082: NEG
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: EMPTY
73089: LIST
73090: LIST
73091: LIST
73092: LIST
73093: LIST
73094: LIST
73095: LIST
73096: LIST
73097: LIST
73098: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73099: LD_ADDR_VAR 0 36
73103: PUSH
73104: LD_INT 0
73106: PUSH
73107: LD_INT 0
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: LD_INT 0
73116: PUSH
73117: LD_INT 1
73119: NEG
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: PUSH
73125: LD_INT 1
73127: PUSH
73128: LD_INT 0
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: PUSH
73135: LD_INT 1
73137: PUSH
73138: LD_INT 1
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 0
73147: PUSH
73148: LD_INT 1
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PUSH
73155: LD_INT 1
73157: NEG
73158: PUSH
73159: LD_INT 0
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: PUSH
73166: LD_INT 1
73168: NEG
73169: PUSH
73170: LD_INT 1
73172: NEG
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 1
73180: NEG
73181: PUSH
73182: LD_INT 2
73184: NEG
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: PUSH
73190: LD_INT 1
73192: PUSH
73193: LD_INT 2
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73211: LD_ADDR_VAR 0 37
73215: PUSH
73216: LD_INT 0
73218: PUSH
73219: LD_INT 0
73221: PUSH
73222: EMPTY
73223: LIST
73224: LIST
73225: PUSH
73226: LD_INT 0
73228: PUSH
73229: LD_INT 1
73231: NEG
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: LD_INT 1
73239: PUSH
73240: LD_INT 0
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: LD_INT 1
73249: PUSH
73250: LD_INT 1
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: LD_INT 0
73259: PUSH
73260: LD_INT 1
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: LD_INT 1
73269: NEG
73270: PUSH
73271: LD_INT 0
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 1
73280: NEG
73281: PUSH
73282: LD_INT 1
73284: NEG
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 1
73292: PUSH
73293: LD_INT 1
73295: NEG
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PUSH
73301: LD_INT 1
73303: NEG
73304: PUSH
73305: LD_INT 1
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: LIST
73316: LIST
73317: LIST
73318: LIST
73319: LIST
73320: LIST
73321: LIST
73322: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
73323: LD_ADDR_VAR 0 38
73327: PUSH
73328: LD_INT 0
73330: PUSH
73331: LD_INT 0
73333: PUSH
73334: EMPTY
73335: LIST
73336: LIST
73337: PUSH
73338: LD_INT 0
73340: PUSH
73341: LD_INT 1
73343: NEG
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: PUSH
73349: LD_INT 1
73351: PUSH
73352: LD_INT 0
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: PUSH
73359: LD_INT 1
73361: PUSH
73362: LD_INT 1
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: PUSH
73369: LD_INT 0
73371: PUSH
73372: LD_INT 1
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: PUSH
73379: LD_INT 1
73381: NEG
73382: PUSH
73383: LD_INT 0
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: PUSH
73390: LD_INT 1
73392: NEG
73393: PUSH
73394: LD_INT 1
73396: NEG
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: LD_INT 2
73404: PUSH
73405: LD_INT 1
73407: PUSH
73408: EMPTY
73409: LIST
73410: LIST
73411: PUSH
73412: LD_INT 2
73414: NEG
73415: PUSH
73416: LD_INT 1
73418: NEG
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: LIST
73428: LIST
73429: LIST
73430: LIST
73431: LIST
73432: LIST
73433: LIST
73434: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73435: LD_ADDR_VAR 0 39
73439: PUSH
73440: LD_INT 0
73442: PUSH
73443: LD_INT 0
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: PUSH
73450: LD_INT 0
73452: PUSH
73453: LD_INT 1
73455: NEG
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 1
73463: PUSH
73464: LD_INT 0
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 1
73473: PUSH
73474: LD_INT 1
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 0
73483: PUSH
73484: LD_INT 1
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: PUSH
73491: LD_INT 1
73493: NEG
73494: PUSH
73495: LD_INT 0
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: LD_INT 1
73504: NEG
73505: PUSH
73506: LD_INT 1
73508: NEG
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PUSH
73514: LD_INT 1
73516: NEG
73517: PUSH
73518: LD_INT 2
73520: NEG
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: LD_INT 1
73528: PUSH
73529: LD_INT 2
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73547: LD_ADDR_VAR 0 40
73551: PUSH
73552: LD_INT 0
73554: PUSH
73555: LD_INT 0
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: LD_INT 0
73564: PUSH
73565: LD_INT 1
73567: NEG
73568: PUSH
73569: EMPTY
73570: LIST
73571: LIST
73572: PUSH
73573: LD_INT 1
73575: PUSH
73576: LD_INT 0
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: PUSH
73583: LD_INT 1
73585: PUSH
73586: LD_INT 1
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 0
73595: PUSH
73596: LD_INT 1
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PUSH
73603: LD_INT 1
73605: NEG
73606: PUSH
73607: LD_INT 0
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: LD_INT 1
73616: NEG
73617: PUSH
73618: LD_INT 1
73620: NEG
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: LD_INT 1
73628: PUSH
73629: LD_INT 1
73631: NEG
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: PUSH
73637: LD_INT 1
73639: NEG
73640: PUSH
73641: LD_INT 1
73643: PUSH
73644: EMPTY
73645: LIST
73646: LIST
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: LIST
73652: LIST
73653: LIST
73654: LIST
73655: LIST
73656: LIST
73657: LIST
73658: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73659: LD_ADDR_VAR 0 41
73663: PUSH
73664: LD_INT 0
73666: PUSH
73667: LD_INT 0
73669: PUSH
73670: EMPTY
73671: LIST
73672: LIST
73673: PUSH
73674: LD_INT 0
73676: PUSH
73677: LD_INT 1
73679: NEG
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: PUSH
73685: LD_INT 1
73687: PUSH
73688: LD_INT 0
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: LD_INT 1
73697: PUSH
73698: LD_INT 1
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: LD_INT 0
73707: PUSH
73708: LD_INT 1
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 1
73717: NEG
73718: PUSH
73719: LD_INT 0
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 1
73728: NEG
73729: PUSH
73730: LD_INT 1
73732: NEG
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 1
73740: NEG
73741: PUSH
73742: LD_INT 2
73744: NEG
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: LD_INT 1
73752: PUSH
73753: LD_INT 1
73755: NEG
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: LD_INT 2
73763: PUSH
73764: LD_INT 0
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: PUSH
73771: LD_INT 2
73773: PUSH
73774: LD_INT 1
73776: PUSH
73777: EMPTY
73778: LIST
73779: LIST
73780: PUSH
73781: LD_INT 2
73783: PUSH
73784: LD_INT 2
73786: PUSH
73787: EMPTY
73788: LIST
73789: LIST
73790: PUSH
73791: LD_INT 1
73793: PUSH
73794: LD_INT 2
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: PUSH
73801: LD_INT 1
73803: NEG
73804: PUSH
73805: LD_INT 1
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 2
73814: NEG
73815: PUSH
73816: LD_INT 0
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 2
73825: NEG
73826: PUSH
73827: LD_INT 1
73829: NEG
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 2
73837: NEG
73838: PUSH
73839: LD_INT 2
73841: NEG
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 2
73849: NEG
73850: PUSH
73851: LD_INT 3
73853: NEG
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 2
73861: PUSH
73862: LD_INT 1
73864: NEG
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 3
73872: PUSH
73873: LD_INT 0
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 3
73882: PUSH
73883: LD_INT 1
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: LD_INT 3
73892: PUSH
73893: LD_INT 2
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 3
73902: PUSH
73903: LD_INT 3
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 2
73912: PUSH
73913: LD_INT 3
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: PUSH
73920: LD_INT 2
73922: NEG
73923: PUSH
73924: LD_INT 1
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: LD_INT 3
73933: NEG
73934: PUSH
73935: LD_INT 0
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 3
73944: NEG
73945: PUSH
73946: LD_INT 1
73948: NEG
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: PUSH
73954: LD_INT 3
73956: NEG
73957: PUSH
73958: LD_INT 2
73960: NEG
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 3
73968: NEG
73969: PUSH
73970: LD_INT 3
73972: NEG
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: LIST
73982: LIST
73983: LIST
73984: LIST
73985: LIST
73986: LIST
73987: LIST
73988: LIST
73989: LIST
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: LIST
73998: LIST
73999: LIST
74000: LIST
74001: LIST
74002: LIST
74003: LIST
74004: LIST
74005: LIST
74006: LIST
74007: LIST
74008: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74009: LD_ADDR_VAR 0 42
74013: PUSH
74014: LD_INT 0
74016: PUSH
74017: LD_INT 0
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 0
74026: PUSH
74027: LD_INT 1
74029: NEG
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: PUSH
74035: LD_INT 1
74037: PUSH
74038: LD_INT 0
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: PUSH
74045: LD_INT 1
74047: PUSH
74048: LD_INT 1
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: PUSH
74055: LD_INT 0
74057: PUSH
74058: LD_INT 1
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: LD_INT 1
74067: NEG
74068: PUSH
74069: LD_INT 0
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 1
74078: NEG
74079: PUSH
74080: LD_INT 1
74082: NEG
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 1
74090: NEG
74091: PUSH
74092: LD_INT 2
74094: NEG
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: LD_INT 0
74102: PUSH
74103: LD_INT 2
74105: NEG
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 1
74113: PUSH
74114: LD_INT 1
74116: NEG
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 2
74124: PUSH
74125: LD_INT 1
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: PUSH
74132: LD_INT 2
74134: PUSH
74135: LD_INT 2
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 1
74144: PUSH
74145: LD_INT 2
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: PUSH
74152: LD_INT 0
74154: PUSH
74155: LD_INT 2
74157: PUSH
74158: EMPTY
74159: LIST
74160: LIST
74161: PUSH
74162: LD_INT 1
74164: NEG
74165: PUSH
74166: LD_INT 1
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: LD_INT 2
74175: NEG
74176: PUSH
74177: LD_INT 1
74179: NEG
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: LD_INT 2
74187: NEG
74188: PUSH
74189: LD_INT 2
74191: NEG
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 2
74199: NEG
74200: PUSH
74201: LD_INT 3
74203: NEG
74204: PUSH
74205: EMPTY
74206: LIST
74207: LIST
74208: PUSH
74209: LD_INT 1
74211: NEG
74212: PUSH
74213: LD_INT 3
74215: NEG
74216: PUSH
74217: EMPTY
74218: LIST
74219: LIST
74220: PUSH
74221: LD_INT 0
74223: PUSH
74224: LD_INT 3
74226: NEG
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 1
74234: PUSH
74235: LD_INT 2
74237: NEG
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: PUSH
74243: LD_INT 3
74245: PUSH
74246: LD_INT 2
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 3
74255: PUSH
74256: LD_INT 3
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 2
74265: PUSH
74266: LD_INT 3
74268: PUSH
74269: EMPTY
74270: LIST
74271: LIST
74272: PUSH
74273: LD_INT 1
74275: PUSH
74276: LD_INT 3
74278: PUSH
74279: EMPTY
74280: LIST
74281: LIST
74282: PUSH
74283: LD_INT 0
74285: PUSH
74286: LD_INT 3
74288: PUSH
74289: EMPTY
74290: LIST
74291: LIST
74292: PUSH
74293: LD_INT 1
74295: NEG
74296: PUSH
74297: LD_INT 2
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 3
74306: NEG
74307: PUSH
74308: LD_INT 2
74310: NEG
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 3
74318: NEG
74319: PUSH
74320: LD_INT 3
74322: NEG
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: LIST
74332: LIST
74333: LIST
74334: LIST
74335: LIST
74336: LIST
74337: LIST
74338: LIST
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: LIST
74350: LIST
74351: LIST
74352: LIST
74353: LIST
74354: LIST
74355: LIST
74356: LIST
74357: LIST
74358: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74359: LD_ADDR_VAR 0 43
74363: PUSH
74364: LD_INT 0
74366: PUSH
74367: LD_INT 0
74369: PUSH
74370: EMPTY
74371: LIST
74372: LIST
74373: PUSH
74374: LD_INT 0
74376: PUSH
74377: LD_INT 1
74379: NEG
74380: PUSH
74381: EMPTY
74382: LIST
74383: LIST
74384: PUSH
74385: LD_INT 1
74387: PUSH
74388: LD_INT 0
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: PUSH
74395: LD_INT 1
74397: PUSH
74398: LD_INT 1
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: LD_INT 0
74407: PUSH
74408: LD_INT 1
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: LD_INT 1
74417: NEG
74418: PUSH
74419: LD_INT 0
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: PUSH
74426: LD_INT 1
74428: NEG
74429: PUSH
74430: LD_INT 1
74432: NEG
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 1
74440: NEG
74441: PUSH
74442: LD_INT 2
74444: NEG
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PUSH
74450: LD_INT 0
74452: PUSH
74453: LD_INT 2
74455: NEG
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 1
74463: PUSH
74464: LD_INT 1
74466: NEG
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: LD_INT 2
74474: PUSH
74475: LD_INT 0
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PUSH
74482: LD_INT 2
74484: PUSH
74485: LD_INT 1
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 1
74494: PUSH
74495: LD_INT 2
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 0
74504: PUSH
74505: LD_INT 2
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: PUSH
74512: LD_INT 1
74514: NEG
74515: PUSH
74516: LD_INT 1
74518: PUSH
74519: EMPTY
74520: LIST
74521: LIST
74522: PUSH
74523: LD_INT 2
74525: NEG
74526: PUSH
74527: LD_INT 0
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 2
74536: NEG
74537: PUSH
74538: LD_INT 1
74540: NEG
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: LD_INT 1
74548: NEG
74549: PUSH
74550: LD_INT 3
74552: NEG
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: LD_INT 0
74560: PUSH
74561: LD_INT 3
74563: NEG
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: LD_INT 1
74571: PUSH
74572: LD_INT 2
74574: NEG
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: PUSH
74580: LD_INT 2
74582: PUSH
74583: LD_INT 1
74585: NEG
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: PUSH
74591: LD_INT 3
74593: PUSH
74594: LD_INT 0
74596: PUSH
74597: EMPTY
74598: LIST
74599: LIST
74600: PUSH
74601: LD_INT 3
74603: PUSH
74604: LD_INT 1
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: LD_INT 1
74613: PUSH
74614: LD_INT 3
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: LD_INT 0
74623: PUSH
74624: LD_INT 3
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 1
74633: NEG
74634: PUSH
74635: LD_INT 2
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: PUSH
74642: LD_INT 2
74644: NEG
74645: PUSH
74646: LD_INT 1
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 3
74655: NEG
74656: PUSH
74657: LD_INT 0
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: LD_INT 3
74666: NEG
74667: PUSH
74668: LD_INT 1
74670: NEG
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: EMPTY
74677: LIST
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: LIST
74683: LIST
74684: LIST
74685: LIST
74686: LIST
74687: LIST
74688: LIST
74689: LIST
74690: LIST
74691: LIST
74692: LIST
74693: LIST
74694: LIST
74695: LIST
74696: LIST
74697: LIST
74698: LIST
74699: LIST
74700: LIST
74701: LIST
74702: LIST
74703: LIST
74704: LIST
74705: LIST
74706: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74707: LD_ADDR_VAR 0 44
74711: PUSH
74712: LD_INT 0
74714: PUSH
74715: LD_INT 0
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: LD_INT 0
74724: PUSH
74725: LD_INT 1
74727: NEG
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: PUSH
74733: LD_INT 1
74735: PUSH
74736: LD_INT 0
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: PUSH
74743: LD_INT 1
74745: PUSH
74746: LD_INT 1
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: PUSH
74753: LD_INT 0
74755: PUSH
74756: LD_INT 1
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: PUSH
74763: LD_INT 1
74765: NEG
74766: PUSH
74767: LD_INT 0
74769: PUSH
74770: EMPTY
74771: LIST
74772: LIST
74773: PUSH
74774: LD_INT 1
74776: NEG
74777: PUSH
74778: LD_INT 1
74780: NEG
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: PUSH
74786: LD_INT 1
74788: NEG
74789: PUSH
74790: LD_INT 2
74792: NEG
74793: PUSH
74794: EMPTY
74795: LIST
74796: LIST
74797: PUSH
74798: LD_INT 1
74800: PUSH
74801: LD_INT 1
74803: NEG
74804: PUSH
74805: EMPTY
74806: LIST
74807: LIST
74808: PUSH
74809: LD_INT 2
74811: PUSH
74812: LD_INT 0
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 2
74821: PUSH
74822: LD_INT 1
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: PUSH
74829: LD_INT 2
74831: PUSH
74832: LD_INT 2
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 1
74841: PUSH
74842: LD_INT 2
74844: PUSH
74845: EMPTY
74846: LIST
74847: LIST
74848: PUSH
74849: LD_INT 1
74851: NEG
74852: PUSH
74853: LD_INT 1
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: PUSH
74860: LD_INT 2
74862: NEG
74863: PUSH
74864: LD_INT 0
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 2
74873: NEG
74874: PUSH
74875: LD_INT 1
74877: NEG
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: LD_INT 2
74885: NEG
74886: PUSH
74887: LD_INT 2
74889: NEG
74890: PUSH
74891: EMPTY
74892: LIST
74893: LIST
74894: PUSH
74895: LD_INT 2
74897: NEG
74898: PUSH
74899: LD_INT 3
74901: NEG
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 2
74909: PUSH
74910: LD_INT 1
74912: NEG
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 3
74920: PUSH
74921: LD_INT 0
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: PUSH
74928: LD_INT 3
74930: PUSH
74931: LD_INT 1
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: LD_INT 3
74940: PUSH
74941: LD_INT 2
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: PUSH
74948: LD_INT 3
74950: PUSH
74951: LD_INT 3
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: PUSH
74958: LD_INT 2
74960: PUSH
74961: LD_INT 3
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: PUSH
74968: LD_INT 2
74970: NEG
74971: PUSH
74972: LD_INT 1
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: PUSH
74979: LD_INT 3
74981: NEG
74982: PUSH
74983: LD_INT 0
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: LD_INT 3
74992: NEG
74993: PUSH
74994: LD_INT 1
74996: NEG
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: PUSH
75002: LD_INT 3
75004: NEG
75005: PUSH
75006: LD_INT 2
75008: NEG
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: LD_INT 3
75016: NEG
75017: PUSH
75018: LD_INT 3
75020: NEG
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: LIST
75030: LIST
75031: LIST
75032: LIST
75033: LIST
75034: LIST
75035: LIST
75036: LIST
75037: LIST
75038: LIST
75039: LIST
75040: LIST
75041: LIST
75042: LIST
75043: LIST
75044: LIST
75045: LIST
75046: LIST
75047: LIST
75048: LIST
75049: LIST
75050: LIST
75051: LIST
75052: LIST
75053: LIST
75054: LIST
75055: LIST
75056: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75057: LD_ADDR_VAR 0 45
75061: PUSH
75062: LD_INT 0
75064: PUSH
75065: LD_INT 0
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 0
75074: PUSH
75075: LD_INT 1
75077: NEG
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 1
75085: PUSH
75086: LD_INT 0
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 1
75095: PUSH
75096: LD_INT 1
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 0
75105: PUSH
75106: LD_INT 1
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 1
75115: NEG
75116: PUSH
75117: LD_INT 0
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: LD_INT 1
75126: NEG
75127: PUSH
75128: LD_INT 1
75130: NEG
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 1
75138: NEG
75139: PUSH
75140: LD_INT 2
75142: NEG
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 0
75150: PUSH
75151: LD_INT 2
75153: NEG
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 1
75161: PUSH
75162: LD_INT 1
75164: NEG
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 2
75172: PUSH
75173: LD_INT 1
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: LD_INT 2
75182: PUSH
75183: LD_INT 2
75185: PUSH
75186: EMPTY
75187: LIST
75188: LIST
75189: PUSH
75190: LD_INT 1
75192: PUSH
75193: LD_INT 2
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 0
75202: PUSH
75203: LD_INT 2
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 1
75212: NEG
75213: PUSH
75214: LD_INT 1
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: PUSH
75221: LD_INT 2
75223: NEG
75224: PUSH
75225: LD_INT 1
75227: NEG
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 2
75235: NEG
75236: PUSH
75237: LD_INT 2
75239: NEG
75240: PUSH
75241: EMPTY
75242: LIST
75243: LIST
75244: PUSH
75245: LD_INT 2
75247: NEG
75248: PUSH
75249: LD_INT 3
75251: NEG
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: LD_INT 1
75259: NEG
75260: PUSH
75261: LD_INT 3
75263: NEG
75264: PUSH
75265: EMPTY
75266: LIST
75267: LIST
75268: PUSH
75269: LD_INT 0
75271: PUSH
75272: LD_INT 3
75274: NEG
75275: PUSH
75276: EMPTY
75277: LIST
75278: LIST
75279: PUSH
75280: LD_INT 1
75282: PUSH
75283: LD_INT 2
75285: NEG
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 3
75293: PUSH
75294: LD_INT 2
75296: PUSH
75297: EMPTY
75298: LIST
75299: LIST
75300: PUSH
75301: LD_INT 3
75303: PUSH
75304: LD_INT 3
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PUSH
75311: LD_INT 2
75313: PUSH
75314: LD_INT 3
75316: PUSH
75317: EMPTY
75318: LIST
75319: LIST
75320: PUSH
75321: LD_INT 1
75323: PUSH
75324: LD_INT 3
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: LD_INT 0
75333: PUSH
75334: LD_INT 3
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: PUSH
75341: LD_INT 1
75343: NEG
75344: PUSH
75345: LD_INT 2
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 3
75354: NEG
75355: PUSH
75356: LD_INT 2
75358: NEG
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: LD_INT 3
75366: NEG
75367: PUSH
75368: LD_INT 3
75370: NEG
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: EMPTY
75377: LIST
75378: LIST
75379: LIST
75380: LIST
75381: LIST
75382: LIST
75383: LIST
75384: LIST
75385: LIST
75386: LIST
75387: LIST
75388: LIST
75389: LIST
75390: LIST
75391: LIST
75392: LIST
75393: LIST
75394: LIST
75395: LIST
75396: LIST
75397: LIST
75398: LIST
75399: LIST
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: LIST
75405: LIST
75406: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75407: LD_ADDR_VAR 0 46
75411: PUSH
75412: LD_INT 0
75414: PUSH
75415: LD_INT 0
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: PUSH
75422: LD_INT 0
75424: PUSH
75425: LD_INT 1
75427: NEG
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PUSH
75433: LD_INT 1
75435: PUSH
75436: LD_INT 0
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 1
75445: PUSH
75446: LD_INT 1
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 0
75455: PUSH
75456: LD_INT 1
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 1
75465: NEG
75466: PUSH
75467: LD_INT 0
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 1
75476: NEG
75477: PUSH
75478: LD_INT 1
75480: NEG
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: LD_INT 1
75488: NEG
75489: PUSH
75490: LD_INT 2
75492: NEG
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PUSH
75498: LD_INT 0
75500: PUSH
75501: LD_INT 2
75503: NEG
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 1
75511: PUSH
75512: LD_INT 1
75514: NEG
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PUSH
75520: LD_INT 2
75522: PUSH
75523: LD_INT 0
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: LD_INT 2
75532: PUSH
75533: LD_INT 1
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 1
75542: PUSH
75543: LD_INT 2
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 0
75552: PUSH
75553: LD_INT 2
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 1
75562: NEG
75563: PUSH
75564: LD_INT 1
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 2
75573: NEG
75574: PUSH
75575: LD_INT 0
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 2
75584: NEG
75585: PUSH
75586: LD_INT 1
75588: NEG
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 1
75596: NEG
75597: PUSH
75598: LD_INT 3
75600: NEG
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: LD_INT 0
75608: PUSH
75609: LD_INT 3
75611: NEG
75612: PUSH
75613: EMPTY
75614: LIST
75615: LIST
75616: PUSH
75617: LD_INT 1
75619: PUSH
75620: LD_INT 2
75622: NEG
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 2
75630: PUSH
75631: LD_INT 1
75633: NEG
75634: PUSH
75635: EMPTY
75636: LIST
75637: LIST
75638: PUSH
75639: LD_INT 3
75641: PUSH
75642: LD_INT 0
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: LD_INT 3
75651: PUSH
75652: LD_INT 1
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 1
75661: PUSH
75662: LD_INT 3
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: PUSH
75669: LD_INT 0
75671: PUSH
75672: LD_INT 3
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PUSH
75679: LD_INT 1
75681: NEG
75682: PUSH
75683: LD_INT 2
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: LD_INT 2
75692: NEG
75693: PUSH
75694: LD_INT 1
75696: PUSH
75697: EMPTY
75698: LIST
75699: LIST
75700: PUSH
75701: LD_INT 3
75703: NEG
75704: PUSH
75705: LD_INT 0
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 3
75714: NEG
75715: PUSH
75716: LD_INT 1
75718: NEG
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: LIST
75730: LIST
75731: LIST
75732: LIST
75733: LIST
75734: LIST
75735: LIST
75736: LIST
75737: LIST
75738: LIST
75739: LIST
75740: LIST
75741: LIST
75742: LIST
75743: LIST
75744: LIST
75745: LIST
75746: LIST
75747: LIST
75748: LIST
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75755: LD_ADDR_VAR 0 47
75759: PUSH
75760: LD_INT 0
75762: PUSH
75763: LD_INT 0
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 0
75772: PUSH
75773: LD_INT 1
75775: NEG
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: PUSH
75781: LD_INT 1
75783: PUSH
75784: LD_INT 0
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: PUSH
75791: LD_INT 1
75793: PUSH
75794: LD_INT 1
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 0
75803: PUSH
75804: LD_INT 1
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: PUSH
75811: LD_INT 1
75813: NEG
75814: PUSH
75815: LD_INT 0
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PUSH
75822: LD_INT 1
75824: NEG
75825: PUSH
75826: LD_INT 1
75828: NEG
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 1
75836: NEG
75837: PUSH
75838: LD_INT 2
75840: NEG
75841: PUSH
75842: EMPTY
75843: LIST
75844: LIST
75845: PUSH
75846: LD_INT 0
75848: PUSH
75849: LD_INT 2
75851: NEG
75852: PUSH
75853: EMPTY
75854: LIST
75855: LIST
75856: PUSH
75857: LD_INT 1
75859: PUSH
75860: LD_INT 1
75862: NEG
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PUSH
75868: LD_INT 2
75870: NEG
75871: PUSH
75872: LD_INT 1
75874: NEG
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: LD_INT 2
75882: NEG
75883: PUSH
75884: LD_INT 2
75886: NEG
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: LIST
75896: LIST
75897: LIST
75898: LIST
75899: LIST
75900: LIST
75901: LIST
75902: LIST
75903: LIST
75904: LIST
75905: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75906: LD_ADDR_VAR 0 48
75910: PUSH
75911: LD_INT 0
75913: PUSH
75914: LD_INT 0
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PUSH
75921: LD_INT 0
75923: PUSH
75924: LD_INT 1
75926: NEG
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 1
75934: PUSH
75935: LD_INT 0
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: LD_INT 1
75944: PUSH
75945: LD_INT 1
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 0
75954: PUSH
75955: LD_INT 1
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: PUSH
75962: LD_INT 1
75964: NEG
75965: PUSH
75966: LD_INT 0
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: PUSH
75973: LD_INT 1
75975: NEG
75976: PUSH
75977: LD_INT 1
75979: NEG
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PUSH
75985: LD_INT 1
75987: NEG
75988: PUSH
75989: LD_INT 2
75991: NEG
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 0
75999: PUSH
76000: LD_INT 2
76002: NEG
76003: PUSH
76004: EMPTY
76005: LIST
76006: LIST
76007: PUSH
76008: LD_INT 1
76010: PUSH
76011: LD_INT 1
76013: NEG
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 2
76021: PUSH
76022: LD_INT 0
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 2
76031: PUSH
76032: LD_INT 1
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: LIST
76043: LIST
76044: LIST
76045: LIST
76046: LIST
76047: LIST
76048: LIST
76049: LIST
76050: LIST
76051: LIST
76052: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76053: LD_ADDR_VAR 0 49
76057: PUSH
76058: LD_INT 0
76060: PUSH
76061: LD_INT 0
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PUSH
76068: LD_INT 0
76070: PUSH
76071: LD_INT 1
76073: NEG
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: PUSH
76079: LD_INT 1
76081: PUSH
76082: LD_INT 0
76084: PUSH
76085: EMPTY
76086: LIST
76087: LIST
76088: PUSH
76089: LD_INT 1
76091: PUSH
76092: LD_INT 1
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: PUSH
76099: LD_INT 0
76101: PUSH
76102: LD_INT 1
76104: PUSH
76105: EMPTY
76106: LIST
76107: LIST
76108: PUSH
76109: LD_INT 1
76111: NEG
76112: PUSH
76113: LD_INT 0
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: LD_INT 1
76122: NEG
76123: PUSH
76124: LD_INT 1
76126: NEG
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PUSH
76132: LD_INT 1
76134: PUSH
76135: LD_INT 1
76137: NEG
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 2
76145: PUSH
76146: LD_INT 0
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 2
76155: PUSH
76156: LD_INT 1
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: PUSH
76163: LD_INT 2
76165: PUSH
76166: LD_INT 2
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 1
76175: PUSH
76176: LD_INT 2
76178: PUSH
76179: EMPTY
76180: LIST
76181: LIST
76182: PUSH
76183: EMPTY
76184: LIST
76185: LIST
76186: LIST
76187: LIST
76188: LIST
76189: LIST
76190: LIST
76191: LIST
76192: LIST
76193: LIST
76194: LIST
76195: LIST
76196: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76197: LD_ADDR_VAR 0 50
76201: PUSH
76202: LD_INT 0
76204: PUSH
76205: LD_INT 0
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: LD_INT 0
76214: PUSH
76215: LD_INT 1
76217: NEG
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: PUSH
76223: LD_INT 1
76225: PUSH
76226: LD_INT 0
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PUSH
76233: LD_INT 1
76235: PUSH
76236: LD_INT 1
76238: PUSH
76239: EMPTY
76240: LIST
76241: LIST
76242: PUSH
76243: LD_INT 0
76245: PUSH
76246: LD_INT 1
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: LD_INT 1
76255: NEG
76256: PUSH
76257: LD_INT 0
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PUSH
76264: LD_INT 1
76266: NEG
76267: PUSH
76268: LD_INT 1
76270: NEG
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 2
76278: PUSH
76279: LD_INT 1
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: LD_INT 2
76288: PUSH
76289: LD_INT 2
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 1
76298: PUSH
76299: LD_INT 2
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: LD_INT 0
76308: PUSH
76309: LD_INT 2
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 1
76318: NEG
76319: PUSH
76320: LD_INT 1
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: LIST
76331: LIST
76332: LIST
76333: LIST
76334: LIST
76335: LIST
76336: LIST
76337: LIST
76338: LIST
76339: LIST
76340: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76341: LD_ADDR_VAR 0 51
76345: PUSH
76346: LD_INT 0
76348: PUSH
76349: LD_INT 0
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 0
76358: PUSH
76359: LD_INT 1
76361: NEG
76362: PUSH
76363: EMPTY
76364: LIST
76365: LIST
76366: PUSH
76367: LD_INT 1
76369: PUSH
76370: LD_INT 0
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: LD_INT 1
76379: PUSH
76380: LD_INT 1
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: LD_INT 0
76389: PUSH
76390: LD_INT 1
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: LD_INT 1
76399: NEG
76400: PUSH
76401: LD_INT 0
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: PUSH
76408: LD_INT 1
76410: NEG
76411: PUSH
76412: LD_INT 1
76414: NEG
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 1
76422: PUSH
76423: LD_INT 2
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 0
76432: PUSH
76433: LD_INT 2
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: LD_INT 1
76442: NEG
76443: PUSH
76444: LD_INT 1
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: PUSH
76451: LD_INT 2
76453: NEG
76454: PUSH
76455: LD_INT 0
76457: PUSH
76458: EMPTY
76459: LIST
76460: LIST
76461: PUSH
76462: LD_INT 2
76464: NEG
76465: PUSH
76466: LD_INT 1
76468: NEG
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: LIST
76478: LIST
76479: LIST
76480: LIST
76481: LIST
76482: LIST
76483: LIST
76484: LIST
76485: LIST
76486: LIST
76487: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76488: LD_ADDR_VAR 0 52
76492: PUSH
76493: LD_INT 0
76495: PUSH
76496: LD_INT 0
76498: PUSH
76499: EMPTY
76500: LIST
76501: LIST
76502: PUSH
76503: LD_INT 0
76505: PUSH
76506: LD_INT 1
76508: NEG
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: PUSH
76514: LD_INT 1
76516: PUSH
76517: LD_INT 0
76519: PUSH
76520: EMPTY
76521: LIST
76522: LIST
76523: PUSH
76524: LD_INT 1
76526: PUSH
76527: LD_INT 1
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: PUSH
76534: LD_INT 0
76536: PUSH
76537: LD_INT 1
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: PUSH
76544: LD_INT 1
76546: NEG
76547: PUSH
76548: LD_INT 0
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: LD_INT 1
76561: NEG
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 1
76569: NEG
76570: PUSH
76571: LD_INT 2
76573: NEG
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: LD_INT 1
76581: NEG
76582: PUSH
76583: LD_INT 1
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 2
76592: NEG
76593: PUSH
76594: LD_INT 0
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: LD_INT 2
76603: NEG
76604: PUSH
76605: LD_INT 1
76607: NEG
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: LD_INT 2
76615: NEG
76616: PUSH
76617: LD_INT 2
76619: NEG
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: LIST
76629: LIST
76630: LIST
76631: LIST
76632: LIST
76633: LIST
76634: LIST
76635: LIST
76636: LIST
76637: LIST
76638: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76639: LD_ADDR_VAR 0 53
76643: PUSH
76644: LD_INT 0
76646: PUSH
76647: LD_INT 0
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: LD_INT 0
76656: PUSH
76657: LD_INT 1
76659: NEG
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: PUSH
76665: LD_INT 1
76667: PUSH
76668: LD_INT 0
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: PUSH
76675: LD_INT 1
76677: PUSH
76678: LD_INT 1
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PUSH
76685: LD_INT 0
76687: PUSH
76688: LD_INT 1
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PUSH
76695: LD_INT 1
76697: NEG
76698: PUSH
76699: LD_INT 0
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: PUSH
76706: LD_INT 1
76708: NEG
76709: PUSH
76710: LD_INT 1
76712: NEG
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 1
76720: NEG
76721: PUSH
76722: LD_INT 2
76724: NEG
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: PUSH
76730: LD_INT 0
76732: PUSH
76733: LD_INT 2
76735: NEG
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: PUSH
76741: LD_INT 1
76743: PUSH
76744: LD_INT 1
76746: NEG
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: PUSH
76752: LD_INT 2
76754: PUSH
76755: LD_INT 0
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: LD_INT 2
76764: PUSH
76765: LD_INT 1
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PUSH
76772: LD_INT 2
76774: PUSH
76775: LD_INT 2
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 1
76784: PUSH
76785: LD_INT 2
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 0
76794: PUSH
76795: LD_INT 2
76797: PUSH
76798: EMPTY
76799: LIST
76800: LIST
76801: PUSH
76802: LD_INT 1
76804: NEG
76805: PUSH
76806: LD_INT 1
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 2
76815: NEG
76816: PUSH
76817: LD_INT 0
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 2
76826: NEG
76827: PUSH
76828: LD_INT 1
76830: NEG
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 2
76838: NEG
76839: PUSH
76840: LD_INT 2
76842: NEG
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: LIST
76852: LIST
76853: LIST
76854: LIST
76855: LIST
76856: LIST
76857: LIST
76858: LIST
76859: LIST
76860: LIST
76861: LIST
76862: LIST
76863: LIST
76864: LIST
76865: LIST
76866: LIST
76867: LIST
76868: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76869: LD_ADDR_VAR 0 54
76873: PUSH
76874: LD_INT 0
76876: PUSH
76877: LD_INT 0
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: LD_INT 0
76886: PUSH
76887: LD_INT 1
76889: NEG
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: PUSH
76895: LD_INT 1
76897: PUSH
76898: LD_INT 0
76900: PUSH
76901: EMPTY
76902: LIST
76903: LIST
76904: PUSH
76905: LD_INT 1
76907: PUSH
76908: LD_INT 1
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 0
76917: PUSH
76918: LD_INT 1
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: PUSH
76925: LD_INT 1
76927: NEG
76928: PUSH
76929: LD_INT 0
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: LD_INT 1
76938: NEG
76939: PUSH
76940: LD_INT 1
76942: NEG
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 1
76950: NEG
76951: PUSH
76952: LD_INT 2
76954: NEG
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 0
76962: PUSH
76963: LD_INT 2
76965: NEG
76966: PUSH
76967: EMPTY
76968: LIST
76969: LIST
76970: PUSH
76971: LD_INT 1
76973: PUSH
76974: LD_INT 1
76976: NEG
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: PUSH
76982: LD_INT 2
76984: PUSH
76985: LD_INT 0
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: LD_INT 2
76994: PUSH
76995: LD_INT 1
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: PUSH
77002: LD_INT 2
77004: PUSH
77005: LD_INT 2
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PUSH
77012: LD_INT 1
77014: PUSH
77015: LD_INT 2
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: PUSH
77022: LD_INT 0
77024: PUSH
77025: LD_INT 2
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: PUSH
77032: LD_INT 1
77034: NEG
77035: PUSH
77036: LD_INT 1
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: PUSH
77043: LD_INT 2
77045: NEG
77046: PUSH
77047: LD_INT 0
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 2
77056: NEG
77057: PUSH
77058: LD_INT 1
77060: NEG
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 2
77068: NEG
77069: PUSH
77070: LD_INT 2
77072: NEG
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: LIST
77082: LIST
77083: LIST
77084: LIST
77085: LIST
77086: LIST
77087: LIST
77088: LIST
77089: LIST
77090: LIST
77091: LIST
77092: LIST
77093: LIST
77094: LIST
77095: LIST
77096: LIST
77097: LIST
77098: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77099: LD_ADDR_VAR 0 55
77103: PUSH
77104: LD_INT 0
77106: PUSH
77107: LD_INT 0
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PUSH
77114: LD_INT 0
77116: PUSH
77117: LD_INT 1
77119: NEG
77120: PUSH
77121: EMPTY
77122: LIST
77123: LIST
77124: PUSH
77125: LD_INT 1
77127: PUSH
77128: LD_INT 0
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: PUSH
77135: LD_INT 1
77137: PUSH
77138: LD_INT 1
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 0
77147: PUSH
77148: LD_INT 1
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: PUSH
77155: LD_INT 1
77157: NEG
77158: PUSH
77159: LD_INT 0
77161: PUSH
77162: EMPTY
77163: LIST
77164: LIST
77165: PUSH
77166: LD_INT 1
77168: NEG
77169: PUSH
77170: LD_INT 1
77172: NEG
77173: PUSH
77174: EMPTY
77175: LIST
77176: LIST
77177: PUSH
77178: LD_INT 1
77180: NEG
77181: PUSH
77182: LD_INT 2
77184: NEG
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: LD_INT 0
77192: PUSH
77193: LD_INT 2
77195: NEG
77196: PUSH
77197: EMPTY
77198: LIST
77199: LIST
77200: PUSH
77201: LD_INT 1
77203: PUSH
77204: LD_INT 1
77206: NEG
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: PUSH
77212: LD_INT 2
77214: PUSH
77215: LD_INT 0
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: LD_INT 2
77224: PUSH
77225: LD_INT 1
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: PUSH
77232: LD_INT 2
77234: PUSH
77235: LD_INT 2
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 1
77244: PUSH
77245: LD_INT 2
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 0
77254: PUSH
77255: LD_INT 2
77257: PUSH
77258: EMPTY
77259: LIST
77260: LIST
77261: PUSH
77262: LD_INT 1
77264: NEG
77265: PUSH
77266: LD_INT 1
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: PUSH
77273: LD_INT 2
77275: NEG
77276: PUSH
77277: LD_INT 0
77279: PUSH
77280: EMPTY
77281: LIST
77282: LIST
77283: PUSH
77284: LD_INT 2
77286: NEG
77287: PUSH
77288: LD_INT 1
77290: NEG
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 2
77298: NEG
77299: PUSH
77300: LD_INT 2
77302: NEG
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: EMPTY
77309: LIST
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: LIST
77319: LIST
77320: LIST
77321: LIST
77322: LIST
77323: LIST
77324: LIST
77325: LIST
77326: LIST
77327: LIST
77328: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77329: LD_ADDR_VAR 0 56
77333: PUSH
77334: LD_INT 0
77336: PUSH
77337: LD_INT 0
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: LD_INT 0
77346: PUSH
77347: LD_INT 1
77349: NEG
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PUSH
77355: LD_INT 1
77357: PUSH
77358: LD_INT 0
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 1
77367: PUSH
77368: LD_INT 1
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: LD_INT 0
77377: PUSH
77378: LD_INT 1
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PUSH
77385: LD_INT 1
77387: NEG
77388: PUSH
77389: LD_INT 0
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: LD_INT 1
77398: NEG
77399: PUSH
77400: LD_INT 1
77402: NEG
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: PUSH
77408: LD_INT 1
77410: NEG
77411: PUSH
77412: LD_INT 2
77414: NEG
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 0
77422: PUSH
77423: LD_INT 2
77425: NEG
77426: PUSH
77427: EMPTY
77428: LIST
77429: LIST
77430: PUSH
77431: LD_INT 1
77433: PUSH
77434: LD_INT 1
77436: NEG
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: PUSH
77442: LD_INT 2
77444: PUSH
77445: LD_INT 0
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 2
77454: PUSH
77455: LD_INT 1
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: PUSH
77462: LD_INT 2
77464: PUSH
77465: LD_INT 2
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 1
77474: PUSH
77475: LD_INT 2
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: LD_INT 0
77484: PUSH
77485: LD_INT 2
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 1
77494: NEG
77495: PUSH
77496: LD_INT 1
77498: PUSH
77499: EMPTY
77500: LIST
77501: LIST
77502: PUSH
77503: LD_INT 2
77505: NEG
77506: PUSH
77507: LD_INT 0
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 2
77516: NEG
77517: PUSH
77518: LD_INT 1
77520: NEG
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: LD_INT 2
77528: NEG
77529: PUSH
77530: LD_INT 2
77532: NEG
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: LIST
77542: LIST
77543: LIST
77544: LIST
77545: LIST
77546: LIST
77547: LIST
77548: LIST
77549: LIST
77550: LIST
77551: LIST
77552: LIST
77553: LIST
77554: LIST
77555: LIST
77556: LIST
77557: LIST
77558: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77559: LD_ADDR_VAR 0 57
77563: PUSH
77564: LD_INT 0
77566: PUSH
77567: LD_INT 0
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PUSH
77574: LD_INT 0
77576: PUSH
77577: LD_INT 1
77579: NEG
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_INT 1
77587: PUSH
77588: LD_INT 0
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 1
77597: PUSH
77598: LD_INT 1
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 0
77607: PUSH
77608: LD_INT 1
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: LD_INT 1
77617: NEG
77618: PUSH
77619: LD_INT 0
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: LD_INT 1
77628: NEG
77629: PUSH
77630: LD_INT 1
77632: NEG
77633: PUSH
77634: EMPTY
77635: LIST
77636: LIST
77637: PUSH
77638: LD_INT 1
77640: NEG
77641: PUSH
77642: LD_INT 2
77644: NEG
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 0
77652: PUSH
77653: LD_INT 2
77655: NEG
77656: PUSH
77657: EMPTY
77658: LIST
77659: LIST
77660: PUSH
77661: LD_INT 1
77663: PUSH
77664: LD_INT 1
77666: NEG
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: PUSH
77672: LD_INT 2
77674: PUSH
77675: LD_INT 0
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 2
77684: PUSH
77685: LD_INT 1
77687: PUSH
77688: EMPTY
77689: LIST
77690: LIST
77691: PUSH
77692: LD_INT 2
77694: PUSH
77695: LD_INT 2
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: PUSH
77702: LD_INT 1
77704: PUSH
77705: LD_INT 2
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: LD_INT 0
77714: PUSH
77715: LD_INT 2
77717: PUSH
77718: EMPTY
77719: LIST
77720: LIST
77721: PUSH
77722: LD_INT 1
77724: NEG
77725: PUSH
77726: LD_INT 1
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: PUSH
77733: LD_INT 2
77735: NEG
77736: PUSH
77737: LD_INT 0
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: LD_INT 2
77746: NEG
77747: PUSH
77748: LD_INT 1
77750: NEG
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 2
77758: NEG
77759: PUSH
77760: LD_INT 2
77762: NEG
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: LIST
77772: LIST
77773: LIST
77774: LIST
77775: LIST
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: LIST
77781: LIST
77782: LIST
77783: LIST
77784: LIST
77785: LIST
77786: LIST
77787: LIST
77788: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77789: LD_ADDR_VAR 0 58
77793: PUSH
77794: LD_INT 0
77796: PUSH
77797: LD_INT 0
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: LD_INT 0
77806: PUSH
77807: LD_INT 1
77809: NEG
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PUSH
77815: LD_INT 1
77817: PUSH
77818: LD_INT 0
77820: PUSH
77821: EMPTY
77822: LIST
77823: LIST
77824: PUSH
77825: LD_INT 1
77827: PUSH
77828: LD_INT 1
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 0
77837: PUSH
77838: LD_INT 1
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PUSH
77845: LD_INT 1
77847: NEG
77848: PUSH
77849: LD_INT 0
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 1
77858: NEG
77859: PUSH
77860: LD_INT 1
77862: NEG
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: LD_INT 1
77870: NEG
77871: PUSH
77872: LD_INT 2
77874: NEG
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PUSH
77880: LD_INT 0
77882: PUSH
77883: LD_INT 2
77885: NEG
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: PUSH
77891: LD_INT 1
77893: PUSH
77894: LD_INT 1
77896: NEG
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: LD_INT 2
77904: PUSH
77905: LD_INT 0
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PUSH
77912: LD_INT 2
77914: PUSH
77915: LD_INT 1
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PUSH
77922: LD_INT 2
77924: PUSH
77925: LD_INT 2
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: PUSH
77932: LD_INT 1
77934: PUSH
77935: LD_INT 2
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: LD_INT 0
77944: PUSH
77945: LD_INT 2
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 1
77954: NEG
77955: PUSH
77956: LD_INT 1
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: LD_INT 2
77965: NEG
77966: PUSH
77967: LD_INT 0
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 2
77976: NEG
77977: PUSH
77978: LD_INT 1
77980: NEG
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: LD_INT 2
77988: NEG
77989: PUSH
77990: LD_INT 2
77992: NEG
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: EMPTY
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: LIST
78018: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78019: LD_ADDR_VAR 0 59
78023: PUSH
78024: LD_INT 0
78026: PUSH
78027: LD_INT 0
78029: PUSH
78030: EMPTY
78031: LIST
78032: LIST
78033: PUSH
78034: LD_INT 0
78036: PUSH
78037: LD_INT 1
78039: NEG
78040: PUSH
78041: EMPTY
78042: LIST
78043: LIST
78044: PUSH
78045: LD_INT 1
78047: PUSH
78048: LD_INT 0
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: PUSH
78055: LD_INT 1
78057: PUSH
78058: LD_INT 1
78060: PUSH
78061: EMPTY
78062: LIST
78063: LIST
78064: PUSH
78065: LD_INT 0
78067: PUSH
78068: LD_INT 1
78070: PUSH
78071: EMPTY
78072: LIST
78073: LIST
78074: PUSH
78075: LD_INT 1
78077: NEG
78078: PUSH
78079: LD_INT 0
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 1
78088: NEG
78089: PUSH
78090: LD_INT 1
78092: NEG
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: LIST
78102: LIST
78103: LIST
78104: LIST
78105: LIST
78106: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78107: LD_ADDR_VAR 0 60
78111: PUSH
78112: LD_INT 0
78114: PUSH
78115: LD_INT 0
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 0
78124: PUSH
78125: LD_INT 1
78127: NEG
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: PUSH
78133: LD_INT 1
78135: PUSH
78136: LD_INT 0
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: LD_INT 1
78145: PUSH
78146: LD_INT 1
78148: PUSH
78149: EMPTY
78150: LIST
78151: LIST
78152: PUSH
78153: LD_INT 0
78155: PUSH
78156: LD_INT 1
78158: PUSH
78159: EMPTY
78160: LIST
78161: LIST
78162: PUSH
78163: LD_INT 1
78165: NEG
78166: PUSH
78167: LD_INT 0
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: LD_INT 1
78176: NEG
78177: PUSH
78178: LD_INT 1
78180: NEG
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: LIST
78190: LIST
78191: LIST
78192: LIST
78193: LIST
78194: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78195: LD_ADDR_VAR 0 61
78199: PUSH
78200: LD_INT 0
78202: PUSH
78203: LD_INT 0
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: PUSH
78210: LD_INT 0
78212: PUSH
78213: LD_INT 1
78215: NEG
78216: PUSH
78217: EMPTY
78218: LIST
78219: LIST
78220: PUSH
78221: LD_INT 1
78223: PUSH
78224: LD_INT 0
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: PUSH
78231: LD_INT 1
78233: PUSH
78234: LD_INT 1
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: LD_INT 0
78243: PUSH
78244: LD_INT 1
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 1
78253: NEG
78254: PUSH
78255: LD_INT 0
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 1
78264: NEG
78265: PUSH
78266: LD_INT 1
78268: NEG
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: LIST
78278: LIST
78279: LIST
78280: LIST
78281: LIST
78282: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78283: LD_ADDR_VAR 0 62
78287: PUSH
78288: LD_INT 0
78290: PUSH
78291: LD_INT 0
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: PUSH
78298: LD_INT 0
78300: PUSH
78301: LD_INT 1
78303: NEG
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: LD_INT 1
78311: PUSH
78312: LD_INT 0
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 1
78321: PUSH
78322: LD_INT 1
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 0
78331: PUSH
78332: LD_INT 1
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 1
78341: NEG
78342: PUSH
78343: LD_INT 0
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 1
78352: NEG
78353: PUSH
78354: LD_INT 1
78356: NEG
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78371: LD_ADDR_VAR 0 63
78375: PUSH
78376: LD_INT 0
78378: PUSH
78379: LD_INT 0
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PUSH
78386: LD_INT 0
78388: PUSH
78389: LD_INT 1
78391: NEG
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 1
78399: PUSH
78400: LD_INT 0
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: PUSH
78407: LD_INT 1
78409: PUSH
78410: LD_INT 1
78412: PUSH
78413: EMPTY
78414: LIST
78415: LIST
78416: PUSH
78417: LD_INT 0
78419: PUSH
78420: LD_INT 1
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: PUSH
78427: LD_INT 1
78429: NEG
78430: PUSH
78431: LD_INT 0
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 1
78440: NEG
78441: PUSH
78442: LD_INT 1
78444: NEG
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: LIST
78458: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78459: LD_ADDR_VAR 0 64
78463: PUSH
78464: LD_INT 0
78466: PUSH
78467: LD_INT 0
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: PUSH
78474: LD_INT 0
78476: PUSH
78477: LD_INT 1
78479: NEG
78480: PUSH
78481: EMPTY
78482: LIST
78483: LIST
78484: PUSH
78485: LD_INT 1
78487: PUSH
78488: LD_INT 0
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: PUSH
78495: LD_INT 1
78497: PUSH
78498: LD_INT 1
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 0
78507: PUSH
78508: LD_INT 1
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: PUSH
78515: LD_INT 1
78517: NEG
78518: PUSH
78519: LD_INT 0
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 1
78528: NEG
78529: PUSH
78530: LD_INT 1
78532: NEG
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: ST_TO_ADDR
// end ; 1 :
78547: GO 84444
78549: LD_INT 1
78551: DOUBLE
78552: EQUAL
78553: IFTRUE 78557
78555: GO 81180
78557: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78558: LD_ADDR_VAR 0 11
78562: PUSH
78563: LD_INT 1
78565: NEG
78566: PUSH
78567: LD_INT 3
78569: NEG
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 0
78577: PUSH
78578: LD_INT 3
78580: NEG
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 1
78588: PUSH
78589: LD_INT 2
78591: NEG
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: LIST
78601: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78602: LD_ADDR_VAR 0 12
78606: PUSH
78607: LD_INT 2
78609: PUSH
78610: LD_INT 1
78612: NEG
78613: PUSH
78614: EMPTY
78615: LIST
78616: LIST
78617: PUSH
78618: LD_INT 3
78620: PUSH
78621: LD_INT 0
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 3
78630: PUSH
78631: LD_INT 1
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: LIST
78642: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78643: LD_ADDR_VAR 0 13
78647: PUSH
78648: LD_INT 3
78650: PUSH
78651: LD_INT 2
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 3
78660: PUSH
78661: LD_INT 3
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 2
78670: PUSH
78671: LD_INT 3
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: LIST
78682: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78683: LD_ADDR_VAR 0 14
78687: PUSH
78688: LD_INT 1
78690: PUSH
78691: LD_INT 3
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 0
78700: PUSH
78701: LD_INT 3
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 1
78710: NEG
78711: PUSH
78712: LD_INT 2
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: EMPTY
78720: LIST
78721: LIST
78722: LIST
78723: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78724: LD_ADDR_VAR 0 15
78728: PUSH
78729: LD_INT 2
78731: NEG
78732: PUSH
78733: LD_INT 1
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 3
78742: NEG
78743: PUSH
78744: LD_INT 0
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: LD_INT 3
78753: NEG
78754: PUSH
78755: LD_INT 1
78757: NEG
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: LIST
78767: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78768: LD_ADDR_VAR 0 16
78772: PUSH
78773: LD_INT 2
78775: NEG
78776: PUSH
78777: LD_INT 3
78779: NEG
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: LD_INT 3
78787: NEG
78788: PUSH
78789: LD_INT 2
78791: NEG
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PUSH
78797: LD_INT 3
78799: NEG
78800: PUSH
78801: LD_INT 3
78803: NEG
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: LIST
78813: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78814: LD_ADDR_VAR 0 17
78818: PUSH
78819: LD_INT 1
78821: NEG
78822: PUSH
78823: LD_INT 3
78825: NEG
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 0
78833: PUSH
78834: LD_INT 3
78836: NEG
78837: PUSH
78838: EMPTY
78839: LIST
78840: LIST
78841: PUSH
78842: LD_INT 1
78844: PUSH
78845: LD_INT 2
78847: NEG
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: LIST
78857: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78858: LD_ADDR_VAR 0 18
78862: PUSH
78863: LD_INT 2
78865: PUSH
78866: LD_INT 1
78868: NEG
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: PUSH
78874: LD_INT 3
78876: PUSH
78877: LD_INT 0
78879: PUSH
78880: EMPTY
78881: LIST
78882: LIST
78883: PUSH
78884: LD_INT 3
78886: PUSH
78887: LD_INT 1
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: LIST
78898: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78899: LD_ADDR_VAR 0 19
78903: PUSH
78904: LD_INT 3
78906: PUSH
78907: LD_INT 2
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 3
78916: PUSH
78917: LD_INT 3
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: LD_INT 2
78926: PUSH
78927: LD_INT 3
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: LIST
78938: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78939: LD_ADDR_VAR 0 20
78943: PUSH
78944: LD_INT 1
78946: PUSH
78947: LD_INT 3
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 0
78956: PUSH
78957: LD_INT 3
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 1
78966: NEG
78967: PUSH
78968: LD_INT 2
78970: PUSH
78971: EMPTY
78972: LIST
78973: LIST
78974: PUSH
78975: EMPTY
78976: LIST
78977: LIST
78978: LIST
78979: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78980: LD_ADDR_VAR 0 21
78984: PUSH
78985: LD_INT 2
78987: NEG
78988: PUSH
78989: LD_INT 1
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 3
78998: NEG
78999: PUSH
79000: LD_INT 0
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: PUSH
79007: LD_INT 3
79009: NEG
79010: PUSH
79011: LD_INT 1
79013: NEG
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: LIST
79023: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79024: LD_ADDR_VAR 0 22
79028: PUSH
79029: LD_INT 2
79031: NEG
79032: PUSH
79033: LD_INT 3
79035: NEG
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 3
79043: NEG
79044: PUSH
79045: LD_INT 2
79047: NEG
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 3
79055: NEG
79056: PUSH
79057: LD_INT 3
79059: NEG
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: LIST
79069: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
79070: LD_ADDR_VAR 0 23
79074: PUSH
79075: LD_INT 0
79077: PUSH
79078: LD_INT 3
79080: NEG
79081: PUSH
79082: EMPTY
79083: LIST
79084: LIST
79085: PUSH
79086: LD_INT 1
79088: NEG
79089: PUSH
79090: LD_INT 4
79092: NEG
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: LD_INT 1
79100: PUSH
79101: LD_INT 3
79103: NEG
79104: PUSH
79105: EMPTY
79106: LIST
79107: LIST
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: LIST
79113: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
79114: LD_ADDR_VAR 0 24
79118: PUSH
79119: LD_INT 3
79121: PUSH
79122: LD_INT 0
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: PUSH
79129: LD_INT 3
79131: PUSH
79132: LD_INT 1
79134: NEG
79135: PUSH
79136: EMPTY
79137: LIST
79138: LIST
79139: PUSH
79140: LD_INT 4
79142: PUSH
79143: LD_INT 1
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: LIST
79154: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
79155: LD_ADDR_VAR 0 25
79159: PUSH
79160: LD_INT 3
79162: PUSH
79163: LD_INT 3
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: PUSH
79170: LD_INT 4
79172: PUSH
79173: LD_INT 3
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PUSH
79180: LD_INT 3
79182: PUSH
79183: LD_INT 4
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: LIST
79194: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
79195: LD_ADDR_VAR 0 26
79199: PUSH
79200: LD_INT 0
79202: PUSH
79203: LD_INT 3
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 1
79212: PUSH
79213: LD_INT 4
79215: PUSH
79216: EMPTY
79217: LIST
79218: LIST
79219: PUSH
79220: LD_INT 1
79222: NEG
79223: PUSH
79224: LD_INT 3
79226: PUSH
79227: EMPTY
79228: LIST
79229: LIST
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: LIST
79235: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
79236: LD_ADDR_VAR 0 27
79240: PUSH
79241: LD_INT 3
79243: NEG
79244: PUSH
79245: LD_INT 0
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: LD_INT 3
79254: NEG
79255: PUSH
79256: LD_INT 1
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 4
79265: NEG
79266: PUSH
79267: LD_INT 1
79269: NEG
79270: PUSH
79271: EMPTY
79272: LIST
79273: LIST
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: LIST
79279: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
79280: LD_ADDR_VAR 0 28
79284: PUSH
79285: LD_INT 3
79287: NEG
79288: PUSH
79289: LD_INT 3
79291: NEG
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 3
79299: NEG
79300: PUSH
79301: LD_INT 4
79303: NEG
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 4
79311: NEG
79312: PUSH
79313: LD_INT 3
79315: NEG
79316: PUSH
79317: EMPTY
79318: LIST
79319: LIST
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: LIST
79325: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
79326: LD_ADDR_VAR 0 29
79330: PUSH
79331: LD_INT 1
79333: NEG
79334: PUSH
79335: LD_INT 3
79337: NEG
79338: PUSH
79339: EMPTY
79340: LIST
79341: LIST
79342: PUSH
79343: LD_INT 0
79345: PUSH
79346: LD_INT 3
79348: NEG
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 1
79356: PUSH
79357: LD_INT 2
79359: NEG
79360: PUSH
79361: EMPTY
79362: LIST
79363: LIST
79364: PUSH
79365: LD_INT 1
79367: NEG
79368: PUSH
79369: LD_INT 4
79371: NEG
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: PUSH
79377: LD_INT 0
79379: PUSH
79380: LD_INT 4
79382: NEG
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 1
79390: PUSH
79391: LD_INT 3
79393: NEG
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 1
79401: NEG
79402: PUSH
79403: LD_INT 5
79405: NEG
79406: PUSH
79407: EMPTY
79408: LIST
79409: LIST
79410: PUSH
79411: LD_INT 0
79413: PUSH
79414: LD_INT 5
79416: NEG
79417: PUSH
79418: EMPTY
79419: LIST
79420: LIST
79421: PUSH
79422: LD_INT 1
79424: PUSH
79425: LD_INT 4
79427: NEG
79428: PUSH
79429: EMPTY
79430: LIST
79431: LIST
79432: PUSH
79433: LD_INT 1
79435: NEG
79436: PUSH
79437: LD_INT 6
79439: NEG
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 0
79447: PUSH
79448: LD_INT 6
79450: NEG
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: LD_INT 1
79458: PUSH
79459: LD_INT 5
79461: NEG
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: LIST
79471: LIST
79472: LIST
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: LIST
79478: LIST
79479: LIST
79480: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
79481: LD_ADDR_VAR 0 30
79485: PUSH
79486: LD_INT 2
79488: PUSH
79489: LD_INT 1
79491: NEG
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 3
79499: PUSH
79500: LD_INT 0
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: LD_INT 3
79509: PUSH
79510: LD_INT 1
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 3
79519: PUSH
79520: LD_INT 1
79522: NEG
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 4
79530: PUSH
79531: LD_INT 0
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 4
79540: PUSH
79541: LD_INT 1
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: LD_INT 4
79550: PUSH
79551: LD_INT 1
79553: NEG
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 5
79561: PUSH
79562: LD_INT 0
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 5
79571: PUSH
79572: LD_INT 1
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 5
79581: PUSH
79582: LD_INT 1
79584: NEG
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: LD_INT 6
79592: PUSH
79593: LD_INT 0
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: PUSH
79600: LD_INT 6
79602: PUSH
79603: LD_INT 1
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
79624: LD_ADDR_VAR 0 31
79628: PUSH
79629: LD_INT 3
79631: PUSH
79632: LD_INT 2
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 3
79641: PUSH
79642: LD_INT 3
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 2
79651: PUSH
79652: LD_INT 3
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 4
79661: PUSH
79662: LD_INT 3
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: PUSH
79669: LD_INT 4
79671: PUSH
79672: LD_INT 4
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: PUSH
79679: LD_INT 3
79681: PUSH
79682: LD_INT 4
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 5
79691: PUSH
79692: LD_INT 4
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 5
79701: PUSH
79702: LD_INT 5
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 4
79711: PUSH
79712: LD_INT 5
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 6
79721: PUSH
79722: LD_INT 5
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 6
79731: PUSH
79732: LD_INT 6
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 5
79741: PUSH
79742: LD_INT 6
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: LIST
79753: LIST
79754: LIST
79755: LIST
79756: LIST
79757: LIST
79758: LIST
79759: LIST
79760: LIST
79761: LIST
79762: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79763: LD_ADDR_VAR 0 32
79767: PUSH
79768: LD_INT 1
79770: PUSH
79771: LD_INT 3
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 0
79780: PUSH
79781: LD_INT 3
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 1
79790: NEG
79791: PUSH
79792: LD_INT 2
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 1
79801: PUSH
79802: LD_INT 4
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 0
79811: PUSH
79812: LD_INT 4
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 1
79821: NEG
79822: PUSH
79823: LD_INT 3
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 1
79832: PUSH
79833: LD_INT 5
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 0
79842: PUSH
79843: LD_INT 5
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 1
79852: NEG
79853: PUSH
79854: LD_INT 4
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 1
79863: PUSH
79864: LD_INT 6
79866: PUSH
79867: EMPTY
79868: LIST
79869: LIST
79870: PUSH
79871: LD_INT 0
79873: PUSH
79874: LD_INT 6
79876: PUSH
79877: EMPTY
79878: LIST
79879: LIST
79880: PUSH
79881: LD_INT 1
79883: NEG
79884: PUSH
79885: LD_INT 5
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79906: LD_ADDR_VAR 0 33
79910: PUSH
79911: LD_INT 2
79913: NEG
79914: PUSH
79915: LD_INT 1
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: LD_INT 3
79924: NEG
79925: PUSH
79926: LD_INT 0
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 3
79935: NEG
79936: PUSH
79937: LD_INT 1
79939: NEG
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 3
79947: NEG
79948: PUSH
79949: LD_INT 1
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 4
79958: NEG
79959: PUSH
79960: LD_INT 0
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 4
79969: NEG
79970: PUSH
79971: LD_INT 1
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 4
79981: NEG
79982: PUSH
79983: LD_INT 1
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 5
79992: NEG
79993: PUSH
79994: LD_INT 0
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 5
80003: NEG
80004: PUSH
80005: LD_INT 1
80007: NEG
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 5
80015: NEG
80016: PUSH
80017: LD_INT 1
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 6
80026: NEG
80027: PUSH
80028: LD_INT 0
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 6
80037: NEG
80038: PUSH
80039: LD_INT 1
80041: NEG
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: LIST
80051: LIST
80052: LIST
80053: LIST
80054: LIST
80055: LIST
80056: LIST
80057: LIST
80058: LIST
80059: LIST
80060: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
80061: LD_ADDR_VAR 0 34
80065: PUSH
80066: LD_INT 2
80068: NEG
80069: PUSH
80070: LD_INT 3
80072: NEG
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 3
80080: NEG
80081: PUSH
80082: LD_INT 2
80084: NEG
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 3
80092: NEG
80093: PUSH
80094: LD_INT 3
80096: NEG
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 3
80104: NEG
80105: PUSH
80106: LD_INT 4
80108: NEG
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 4
80116: NEG
80117: PUSH
80118: LD_INT 3
80120: NEG
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 4
80128: NEG
80129: PUSH
80130: LD_INT 4
80132: NEG
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 4
80140: NEG
80141: PUSH
80142: LD_INT 5
80144: NEG
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 5
80152: NEG
80153: PUSH
80154: LD_INT 4
80156: NEG
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: LD_INT 5
80164: NEG
80165: PUSH
80166: LD_INT 5
80168: NEG
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 5
80176: NEG
80177: PUSH
80178: LD_INT 6
80180: NEG
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 6
80188: NEG
80189: PUSH
80190: LD_INT 5
80192: NEG
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 6
80200: NEG
80201: PUSH
80202: LD_INT 6
80204: NEG
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: LIST
80218: LIST
80219: LIST
80220: LIST
80221: LIST
80222: LIST
80223: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
80224: LD_ADDR_VAR 0 41
80228: PUSH
80229: LD_INT 0
80231: PUSH
80232: LD_INT 2
80234: NEG
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: LD_INT 3
80246: NEG
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 1
80254: PUSH
80255: LD_INT 2
80257: NEG
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: LIST
80267: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
80268: LD_ADDR_VAR 0 42
80272: PUSH
80273: LD_INT 2
80275: PUSH
80276: LD_INT 0
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 2
80285: PUSH
80286: LD_INT 1
80288: NEG
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 3
80296: PUSH
80297: LD_INT 1
80299: PUSH
80300: EMPTY
80301: LIST
80302: LIST
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: LIST
80308: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
80309: LD_ADDR_VAR 0 43
80313: PUSH
80314: LD_INT 2
80316: PUSH
80317: LD_INT 2
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 3
80326: PUSH
80327: LD_INT 2
80329: PUSH
80330: EMPTY
80331: LIST
80332: LIST
80333: PUSH
80334: LD_INT 2
80336: PUSH
80337: LD_INT 3
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: LIST
80348: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
80349: LD_ADDR_VAR 0 44
80353: PUSH
80354: LD_INT 0
80356: PUSH
80357: LD_INT 2
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: LD_INT 1
80366: PUSH
80367: LD_INT 3
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 1
80376: NEG
80377: PUSH
80378: LD_INT 2
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: LIST
80389: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80390: LD_ADDR_VAR 0 45
80394: PUSH
80395: LD_INT 2
80397: NEG
80398: PUSH
80399: LD_INT 0
80401: PUSH
80402: EMPTY
80403: LIST
80404: LIST
80405: PUSH
80406: LD_INT 2
80408: NEG
80409: PUSH
80410: LD_INT 1
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 3
80419: NEG
80420: PUSH
80421: LD_INT 1
80423: NEG
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: LIST
80433: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
80434: LD_ADDR_VAR 0 46
80438: PUSH
80439: LD_INT 2
80441: NEG
80442: PUSH
80443: LD_INT 2
80445: NEG
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 2
80453: NEG
80454: PUSH
80455: LD_INT 3
80457: NEG
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 3
80465: NEG
80466: PUSH
80467: LD_INT 2
80469: NEG
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: LIST
80479: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
80480: LD_ADDR_VAR 0 47
80484: PUSH
80485: LD_INT 2
80487: NEG
80488: PUSH
80489: LD_INT 3
80491: NEG
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 1
80499: NEG
80500: PUSH
80501: LD_INT 3
80503: NEG
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80513: LD_ADDR_VAR 0 48
80517: PUSH
80518: LD_INT 1
80520: PUSH
80521: LD_INT 2
80523: NEG
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: LD_INT 2
80531: PUSH
80532: LD_INT 1
80534: NEG
80535: PUSH
80536: EMPTY
80537: LIST
80538: LIST
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
80544: LD_ADDR_VAR 0 49
80548: PUSH
80549: LD_INT 3
80551: PUSH
80552: LD_INT 1
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 3
80561: PUSH
80562: LD_INT 2
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
80573: LD_ADDR_VAR 0 50
80577: PUSH
80578: LD_INT 2
80580: PUSH
80581: LD_INT 3
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 1
80590: PUSH
80591: LD_INT 3
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
80602: LD_ADDR_VAR 0 51
80606: PUSH
80607: LD_INT 1
80609: NEG
80610: PUSH
80611: LD_INT 2
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: LD_INT 2
80620: NEG
80621: PUSH
80622: LD_INT 1
80624: PUSH
80625: EMPTY
80626: LIST
80627: LIST
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80633: LD_ADDR_VAR 0 52
80637: PUSH
80638: LD_INT 3
80640: NEG
80641: PUSH
80642: LD_INT 1
80644: NEG
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: PUSH
80650: LD_INT 3
80652: NEG
80653: PUSH
80654: LD_INT 2
80656: NEG
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80666: LD_ADDR_VAR 0 53
80670: PUSH
80671: LD_INT 1
80673: NEG
80674: PUSH
80675: LD_INT 3
80677: NEG
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 0
80685: PUSH
80686: LD_INT 3
80688: NEG
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 1
80696: PUSH
80697: LD_INT 2
80699: NEG
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: LIST
80709: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80710: LD_ADDR_VAR 0 54
80714: PUSH
80715: LD_INT 2
80717: PUSH
80718: LD_INT 1
80720: NEG
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 3
80728: PUSH
80729: LD_INT 0
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 3
80738: PUSH
80739: LD_INT 1
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: LIST
80750: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80751: LD_ADDR_VAR 0 55
80755: PUSH
80756: LD_INT 3
80758: PUSH
80759: LD_INT 2
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 3
80768: PUSH
80769: LD_INT 3
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 2
80778: PUSH
80779: LD_INT 3
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: LIST
80790: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80791: LD_ADDR_VAR 0 56
80795: PUSH
80796: LD_INT 1
80798: PUSH
80799: LD_INT 3
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 3
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 1
80818: NEG
80819: PUSH
80820: LD_INT 2
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: LIST
80831: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80832: LD_ADDR_VAR 0 57
80836: PUSH
80837: LD_INT 2
80839: NEG
80840: PUSH
80841: LD_INT 1
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 3
80850: NEG
80851: PUSH
80852: LD_INT 0
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 3
80861: NEG
80862: PUSH
80863: LD_INT 1
80865: NEG
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: LIST
80875: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80876: LD_ADDR_VAR 0 58
80880: PUSH
80881: LD_INT 2
80883: NEG
80884: PUSH
80885: LD_INT 3
80887: NEG
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 3
80895: NEG
80896: PUSH
80897: LD_INT 2
80899: NEG
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 3
80907: NEG
80908: PUSH
80909: LD_INT 3
80911: NEG
80912: PUSH
80913: EMPTY
80914: LIST
80915: LIST
80916: PUSH
80917: EMPTY
80918: LIST
80919: LIST
80920: LIST
80921: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80922: LD_ADDR_VAR 0 59
80926: PUSH
80927: LD_INT 1
80929: NEG
80930: PUSH
80931: LD_INT 2
80933: NEG
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 0
80941: PUSH
80942: LD_INT 2
80944: NEG
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 1
80952: PUSH
80953: LD_INT 1
80955: NEG
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: LIST
80965: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80966: LD_ADDR_VAR 0 60
80970: PUSH
80971: LD_INT 1
80973: PUSH
80974: LD_INT 1
80976: NEG
80977: PUSH
80978: EMPTY
80979: LIST
80980: LIST
80981: PUSH
80982: LD_INT 2
80984: PUSH
80985: LD_INT 0
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 2
80994: PUSH
80995: LD_INT 1
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: LIST
81006: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
81007: LD_ADDR_VAR 0 61
81011: PUSH
81012: LD_INT 2
81014: PUSH
81015: LD_INT 1
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 2
81024: PUSH
81025: LD_INT 2
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 1
81034: PUSH
81035: LD_INT 2
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: EMPTY
81043: LIST
81044: LIST
81045: LIST
81046: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
81047: LD_ADDR_VAR 0 62
81051: PUSH
81052: LD_INT 1
81054: PUSH
81055: LD_INT 2
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: LD_INT 0
81064: PUSH
81065: LD_INT 2
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: PUSH
81072: LD_INT 1
81074: NEG
81075: PUSH
81076: LD_INT 1
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: LIST
81087: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
81088: LD_ADDR_VAR 0 63
81092: PUSH
81093: LD_INT 1
81095: NEG
81096: PUSH
81097: LD_INT 1
81099: PUSH
81100: EMPTY
81101: LIST
81102: LIST
81103: PUSH
81104: LD_INT 2
81106: NEG
81107: PUSH
81108: LD_INT 0
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 2
81117: NEG
81118: PUSH
81119: LD_INT 1
81121: NEG
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: LIST
81131: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81132: LD_ADDR_VAR 0 64
81136: PUSH
81137: LD_INT 1
81139: NEG
81140: PUSH
81141: LD_INT 2
81143: NEG
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 2
81151: NEG
81152: PUSH
81153: LD_INT 1
81155: NEG
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 2
81163: NEG
81164: PUSH
81165: LD_INT 2
81167: NEG
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: LIST
81177: ST_TO_ADDR
// end ; 2 :
81178: GO 84444
81180: LD_INT 2
81182: DOUBLE
81183: EQUAL
81184: IFTRUE 81188
81186: GO 84443
81188: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
81189: LD_ADDR_VAR 0 29
81193: PUSH
81194: LD_INT 4
81196: PUSH
81197: LD_INT 0
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 4
81206: PUSH
81207: LD_INT 1
81209: NEG
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 5
81217: PUSH
81218: LD_INT 0
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 5
81227: PUSH
81228: LD_INT 1
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 4
81237: PUSH
81238: LD_INT 1
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PUSH
81245: LD_INT 3
81247: PUSH
81248: LD_INT 0
81250: PUSH
81251: EMPTY
81252: LIST
81253: LIST
81254: PUSH
81255: LD_INT 3
81257: PUSH
81258: LD_INT 1
81260: NEG
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 3
81268: PUSH
81269: LD_INT 2
81271: NEG
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: PUSH
81277: LD_INT 5
81279: PUSH
81280: LD_INT 2
81282: PUSH
81283: EMPTY
81284: LIST
81285: LIST
81286: PUSH
81287: LD_INT 3
81289: PUSH
81290: LD_INT 3
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 3
81299: PUSH
81300: LD_INT 2
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 4
81309: PUSH
81310: LD_INT 3
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: PUSH
81317: LD_INT 4
81319: PUSH
81320: LD_INT 4
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 3
81329: PUSH
81330: LD_INT 4
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 2
81339: PUSH
81340: LD_INT 3
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 2
81349: PUSH
81350: LD_INT 2
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 4
81359: PUSH
81360: LD_INT 2
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 2
81369: PUSH
81370: LD_INT 4
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 0
81379: PUSH
81380: LD_INT 4
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PUSH
81387: LD_INT 0
81389: PUSH
81390: LD_INT 3
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 1
81399: PUSH
81400: LD_INT 4
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 1
81409: PUSH
81410: LD_INT 5
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: PUSH
81417: LD_INT 0
81419: PUSH
81420: LD_INT 5
81422: PUSH
81423: EMPTY
81424: LIST
81425: LIST
81426: PUSH
81427: LD_INT 1
81429: NEG
81430: PUSH
81431: LD_INT 4
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 1
81440: NEG
81441: PUSH
81442: LD_INT 3
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 2
81451: PUSH
81452: LD_INT 5
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 2
81461: NEG
81462: PUSH
81463: LD_INT 3
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: LD_INT 3
81472: NEG
81473: PUSH
81474: LD_INT 0
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 3
81483: NEG
81484: PUSH
81485: LD_INT 1
81487: NEG
81488: PUSH
81489: EMPTY
81490: LIST
81491: LIST
81492: PUSH
81493: LD_INT 2
81495: NEG
81496: PUSH
81497: LD_INT 0
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 2
81506: NEG
81507: PUSH
81508: LD_INT 1
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 3
81517: NEG
81518: PUSH
81519: LD_INT 1
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 4
81528: NEG
81529: PUSH
81530: LD_INT 0
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 4
81539: NEG
81540: PUSH
81541: LD_INT 1
81543: NEG
81544: PUSH
81545: EMPTY
81546: LIST
81547: LIST
81548: PUSH
81549: LD_INT 4
81551: NEG
81552: PUSH
81553: LD_INT 2
81555: NEG
81556: PUSH
81557: EMPTY
81558: LIST
81559: LIST
81560: PUSH
81561: LD_INT 2
81563: NEG
81564: PUSH
81565: LD_INT 2
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PUSH
81572: LD_INT 4
81574: NEG
81575: PUSH
81576: LD_INT 4
81578: NEG
81579: PUSH
81580: EMPTY
81581: LIST
81582: LIST
81583: PUSH
81584: LD_INT 4
81586: NEG
81587: PUSH
81588: LD_INT 5
81590: NEG
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 3
81598: NEG
81599: PUSH
81600: LD_INT 4
81602: NEG
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 3
81610: NEG
81611: PUSH
81612: LD_INT 3
81614: NEG
81615: PUSH
81616: EMPTY
81617: LIST
81618: LIST
81619: PUSH
81620: LD_INT 4
81622: NEG
81623: PUSH
81624: LD_INT 3
81626: NEG
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 5
81634: NEG
81635: PUSH
81636: LD_INT 4
81638: NEG
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 5
81646: NEG
81647: PUSH
81648: LD_INT 5
81650: NEG
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 3
81658: NEG
81659: PUSH
81660: LD_INT 5
81662: NEG
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: LD_INT 5
81670: NEG
81671: PUSH
81672: LD_INT 3
81674: NEG
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
81727: LD_ADDR_VAR 0 30
81731: PUSH
81732: LD_INT 4
81734: PUSH
81735: LD_INT 4
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 4
81744: PUSH
81745: LD_INT 3
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: LD_INT 5
81754: PUSH
81755: LD_INT 4
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: PUSH
81762: LD_INT 5
81764: PUSH
81765: LD_INT 5
81767: PUSH
81768: EMPTY
81769: LIST
81770: LIST
81771: PUSH
81772: LD_INT 4
81774: PUSH
81775: LD_INT 5
81777: PUSH
81778: EMPTY
81779: LIST
81780: LIST
81781: PUSH
81782: LD_INT 3
81784: PUSH
81785: LD_INT 4
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: PUSH
81792: LD_INT 3
81794: PUSH
81795: LD_INT 3
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: PUSH
81802: LD_INT 5
81804: PUSH
81805: LD_INT 3
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 3
81814: PUSH
81815: LD_INT 5
81817: PUSH
81818: EMPTY
81819: LIST
81820: LIST
81821: PUSH
81822: LD_INT 0
81824: PUSH
81825: LD_INT 3
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: LD_INT 0
81834: PUSH
81835: LD_INT 2
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 1
81844: PUSH
81845: LD_INT 3
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 1
81854: PUSH
81855: LD_INT 4
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 0
81864: PUSH
81865: LD_INT 4
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 1
81874: NEG
81875: PUSH
81876: LD_INT 3
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 1
81885: NEG
81886: PUSH
81887: LD_INT 2
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 2
81896: PUSH
81897: LD_INT 4
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 2
81906: NEG
81907: PUSH
81908: LD_INT 2
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 4
81917: NEG
81918: PUSH
81919: LD_INT 0
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 4
81928: NEG
81929: PUSH
81930: LD_INT 1
81932: NEG
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PUSH
81938: LD_INT 3
81940: NEG
81941: PUSH
81942: LD_INT 0
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 3
81951: NEG
81952: PUSH
81953: LD_INT 1
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 4
81962: NEG
81963: PUSH
81964: LD_INT 1
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: PUSH
81971: LD_INT 5
81973: NEG
81974: PUSH
81975: LD_INT 0
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: PUSH
81982: LD_INT 5
81984: NEG
81985: PUSH
81986: LD_INT 1
81988: NEG
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 5
81996: NEG
81997: PUSH
81998: LD_INT 2
82000: NEG
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 3
82008: NEG
82009: PUSH
82010: LD_INT 2
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: LD_INT 3
82019: NEG
82020: PUSH
82021: LD_INT 3
82023: NEG
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: LD_INT 3
82031: NEG
82032: PUSH
82033: LD_INT 4
82035: NEG
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: PUSH
82041: LD_INT 2
82043: NEG
82044: PUSH
82045: LD_INT 3
82047: NEG
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: LD_INT 2
82055: NEG
82056: PUSH
82057: LD_INT 2
82059: NEG
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 3
82067: NEG
82068: PUSH
82069: LD_INT 2
82071: NEG
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: PUSH
82077: LD_INT 4
82079: NEG
82080: PUSH
82081: LD_INT 3
82083: NEG
82084: PUSH
82085: EMPTY
82086: LIST
82087: LIST
82088: PUSH
82089: LD_INT 4
82091: NEG
82092: PUSH
82093: LD_INT 4
82095: NEG
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 2
82103: NEG
82104: PUSH
82105: LD_INT 4
82107: NEG
82108: PUSH
82109: EMPTY
82110: LIST
82111: LIST
82112: PUSH
82113: LD_INT 4
82115: NEG
82116: PUSH
82117: LD_INT 2
82119: NEG
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: PUSH
82125: LD_INT 0
82127: PUSH
82128: LD_INT 4
82130: NEG
82131: PUSH
82132: EMPTY
82133: LIST
82134: LIST
82135: PUSH
82136: LD_INT 0
82138: PUSH
82139: LD_INT 5
82141: NEG
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: LD_INT 1
82149: PUSH
82150: LD_INT 4
82152: NEG
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 1
82160: PUSH
82161: LD_INT 3
82163: NEG
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 0
82171: PUSH
82172: LD_INT 3
82174: NEG
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 1
82182: NEG
82183: PUSH
82184: LD_INT 4
82186: NEG
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 1
82194: NEG
82195: PUSH
82196: LD_INT 5
82198: NEG
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 2
82206: PUSH
82207: LD_INT 3
82209: NEG
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PUSH
82215: LD_INT 2
82217: NEG
82218: PUSH
82219: LD_INT 5
82221: NEG
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: LIST
82262: LIST
82263: LIST
82264: LIST
82265: LIST
82266: LIST
82267: LIST
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
82274: LD_ADDR_VAR 0 31
82278: PUSH
82279: LD_INT 0
82281: PUSH
82282: LD_INT 4
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 0
82291: PUSH
82292: LD_INT 3
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: LD_INT 1
82301: PUSH
82302: LD_INT 4
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: PUSH
82309: LD_INT 1
82311: PUSH
82312: LD_INT 5
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 0
82321: PUSH
82322: LD_INT 5
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PUSH
82329: LD_INT 1
82331: NEG
82332: PUSH
82333: LD_INT 4
82335: PUSH
82336: EMPTY
82337: LIST
82338: LIST
82339: PUSH
82340: LD_INT 1
82342: NEG
82343: PUSH
82344: LD_INT 3
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 2
82353: PUSH
82354: LD_INT 5
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PUSH
82361: LD_INT 2
82363: NEG
82364: PUSH
82365: LD_INT 3
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 3
82374: NEG
82375: PUSH
82376: LD_INT 0
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 3
82385: NEG
82386: PUSH
82387: LD_INT 1
82389: NEG
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 2
82397: NEG
82398: PUSH
82399: LD_INT 0
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 2
82408: NEG
82409: PUSH
82410: LD_INT 1
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 3
82419: NEG
82420: PUSH
82421: LD_INT 1
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 4
82430: NEG
82431: PUSH
82432: LD_INT 0
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 4
82441: NEG
82442: PUSH
82443: LD_INT 1
82445: NEG
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: PUSH
82451: LD_INT 4
82453: NEG
82454: PUSH
82455: LD_INT 2
82457: NEG
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: PUSH
82463: LD_INT 2
82465: NEG
82466: PUSH
82467: LD_INT 2
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 4
82476: NEG
82477: PUSH
82478: LD_INT 4
82480: NEG
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: LD_INT 4
82488: NEG
82489: PUSH
82490: LD_INT 5
82492: NEG
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 3
82500: NEG
82501: PUSH
82502: LD_INT 4
82504: NEG
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 3
82512: NEG
82513: PUSH
82514: LD_INT 3
82516: NEG
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 4
82524: NEG
82525: PUSH
82526: LD_INT 3
82528: NEG
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: LD_INT 5
82536: NEG
82537: PUSH
82538: LD_INT 4
82540: NEG
82541: PUSH
82542: EMPTY
82543: LIST
82544: LIST
82545: PUSH
82546: LD_INT 5
82548: NEG
82549: PUSH
82550: LD_INT 5
82552: NEG
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 3
82560: NEG
82561: PUSH
82562: LD_INT 5
82564: NEG
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: PUSH
82570: LD_INT 5
82572: NEG
82573: PUSH
82574: LD_INT 3
82576: NEG
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 0
82584: PUSH
82585: LD_INT 3
82587: NEG
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: LD_INT 0
82595: PUSH
82596: LD_INT 4
82598: NEG
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 1
82606: PUSH
82607: LD_INT 3
82609: NEG
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 1
82617: PUSH
82618: LD_INT 2
82620: NEG
82621: PUSH
82622: EMPTY
82623: LIST
82624: LIST
82625: PUSH
82626: LD_INT 0
82628: PUSH
82629: LD_INT 2
82631: NEG
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 1
82639: NEG
82640: PUSH
82641: LD_INT 3
82643: NEG
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 1
82651: NEG
82652: PUSH
82653: LD_INT 4
82655: NEG
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 2
82663: PUSH
82664: LD_INT 2
82666: NEG
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 2
82674: NEG
82675: PUSH
82676: LD_INT 4
82678: NEG
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 4
82686: PUSH
82687: LD_INT 0
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 4
82696: PUSH
82697: LD_INT 1
82699: NEG
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 5
82707: PUSH
82708: LD_INT 0
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 5
82717: PUSH
82718: LD_INT 1
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 4
82727: PUSH
82728: LD_INT 1
82730: PUSH
82731: EMPTY
82732: LIST
82733: LIST
82734: PUSH
82735: LD_INT 3
82737: PUSH
82738: LD_INT 0
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 3
82747: PUSH
82748: LD_INT 1
82750: NEG
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 3
82758: PUSH
82759: LD_INT 2
82761: NEG
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: PUSH
82767: LD_INT 5
82769: PUSH
82770: LD_INT 2
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: LIST
82799: LIST
82800: LIST
82801: LIST
82802: LIST
82803: LIST
82804: LIST
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82824: LD_ADDR_VAR 0 32
82828: PUSH
82829: LD_INT 4
82831: NEG
82832: PUSH
82833: LD_INT 0
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: PUSH
82840: LD_INT 4
82842: NEG
82843: PUSH
82844: LD_INT 1
82846: NEG
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 3
82854: NEG
82855: PUSH
82856: LD_INT 0
82858: PUSH
82859: EMPTY
82860: LIST
82861: LIST
82862: PUSH
82863: LD_INT 3
82865: NEG
82866: PUSH
82867: LD_INT 1
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: PUSH
82874: LD_INT 4
82876: NEG
82877: PUSH
82878: LD_INT 1
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 5
82887: NEG
82888: PUSH
82889: LD_INT 0
82891: PUSH
82892: EMPTY
82893: LIST
82894: LIST
82895: PUSH
82896: LD_INT 5
82898: NEG
82899: PUSH
82900: LD_INT 1
82902: NEG
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 5
82910: NEG
82911: PUSH
82912: LD_INT 2
82914: NEG
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: PUSH
82920: LD_INT 3
82922: NEG
82923: PUSH
82924: LD_INT 2
82926: PUSH
82927: EMPTY
82928: LIST
82929: LIST
82930: PUSH
82931: LD_INT 3
82933: NEG
82934: PUSH
82935: LD_INT 3
82937: NEG
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: PUSH
82943: LD_INT 3
82945: NEG
82946: PUSH
82947: LD_INT 4
82949: NEG
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: PUSH
82955: LD_INT 2
82957: NEG
82958: PUSH
82959: LD_INT 3
82961: NEG
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 2
82969: NEG
82970: PUSH
82971: LD_INT 2
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 3
82981: NEG
82982: PUSH
82983: LD_INT 2
82985: NEG
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 4
82993: NEG
82994: PUSH
82995: LD_INT 3
82997: NEG
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: LD_INT 4
83005: NEG
83006: PUSH
83007: LD_INT 4
83009: NEG
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: PUSH
83015: LD_INT 2
83017: NEG
83018: PUSH
83019: LD_INT 4
83021: NEG
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: PUSH
83027: LD_INT 4
83029: NEG
83030: PUSH
83031: LD_INT 2
83033: NEG
83034: PUSH
83035: EMPTY
83036: LIST
83037: LIST
83038: PUSH
83039: LD_INT 0
83041: PUSH
83042: LD_INT 4
83044: NEG
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 0
83052: PUSH
83053: LD_INT 5
83055: NEG
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: PUSH
83061: LD_INT 1
83063: PUSH
83064: LD_INT 4
83066: NEG
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 1
83074: PUSH
83075: LD_INT 3
83077: NEG
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: PUSH
83083: LD_INT 0
83085: PUSH
83086: LD_INT 3
83088: NEG
83089: PUSH
83090: EMPTY
83091: LIST
83092: LIST
83093: PUSH
83094: LD_INT 1
83096: NEG
83097: PUSH
83098: LD_INT 4
83100: NEG
83101: PUSH
83102: EMPTY
83103: LIST
83104: LIST
83105: PUSH
83106: LD_INT 1
83108: NEG
83109: PUSH
83110: LD_INT 5
83112: NEG
83113: PUSH
83114: EMPTY
83115: LIST
83116: LIST
83117: PUSH
83118: LD_INT 2
83120: PUSH
83121: LD_INT 3
83123: NEG
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 2
83131: NEG
83132: PUSH
83133: LD_INT 5
83135: NEG
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PUSH
83141: LD_INT 3
83143: PUSH
83144: LD_INT 0
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: LD_INT 3
83153: PUSH
83154: LD_INT 1
83156: NEG
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: PUSH
83162: LD_INT 4
83164: PUSH
83165: LD_INT 0
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 4
83174: PUSH
83175: LD_INT 1
83177: PUSH
83178: EMPTY
83179: LIST
83180: LIST
83181: PUSH
83182: LD_INT 3
83184: PUSH
83185: LD_INT 1
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: LD_INT 2
83194: PUSH
83195: LD_INT 0
83197: PUSH
83198: EMPTY
83199: LIST
83200: LIST
83201: PUSH
83202: LD_INT 2
83204: PUSH
83205: LD_INT 1
83207: NEG
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PUSH
83213: LD_INT 2
83215: PUSH
83216: LD_INT 2
83218: NEG
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 4
83226: PUSH
83227: LD_INT 2
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 4
83236: PUSH
83237: LD_INT 4
83239: PUSH
83240: EMPTY
83241: LIST
83242: LIST
83243: PUSH
83244: LD_INT 4
83246: PUSH
83247: LD_INT 3
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: PUSH
83254: LD_INT 5
83256: PUSH
83257: LD_INT 4
83259: PUSH
83260: EMPTY
83261: LIST
83262: LIST
83263: PUSH
83264: LD_INT 5
83266: PUSH
83267: LD_INT 5
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 4
83276: PUSH
83277: LD_INT 5
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 3
83286: PUSH
83287: LD_INT 4
83289: PUSH
83290: EMPTY
83291: LIST
83292: LIST
83293: PUSH
83294: LD_INT 3
83296: PUSH
83297: LD_INT 3
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: LD_INT 5
83306: PUSH
83307: LD_INT 3
83309: PUSH
83310: EMPTY
83311: LIST
83312: LIST
83313: PUSH
83314: LD_INT 3
83316: PUSH
83317: LD_INT 5
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: LIST
83332: LIST
83333: LIST
83334: LIST
83335: LIST
83336: LIST
83337: LIST
83338: LIST
83339: LIST
83340: LIST
83341: LIST
83342: LIST
83343: LIST
83344: LIST
83345: LIST
83346: LIST
83347: LIST
83348: LIST
83349: LIST
83350: LIST
83351: LIST
83352: LIST
83353: LIST
83354: LIST
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: LIST
83363: LIST
83364: LIST
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
83371: LD_ADDR_VAR 0 33
83375: PUSH
83376: LD_INT 4
83378: NEG
83379: PUSH
83380: LD_INT 4
83382: NEG
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: PUSH
83388: LD_INT 4
83390: NEG
83391: PUSH
83392: LD_INT 5
83394: NEG
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PUSH
83400: LD_INT 3
83402: NEG
83403: PUSH
83404: LD_INT 4
83406: NEG
83407: PUSH
83408: EMPTY
83409: LIST
83410: LIST
83411: PUSH
83412: LD_INT 3
83414: NEG
83415: PUSH
83416: LD_INT 3
83418: NEG
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 4
83426: NEG
83427: PUSH
83428: LD_INT 3
83430: NEG
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 5
83438: NEG
83439: PUSH
83440: LD_INT 4
83442: NEG
83443: PUSH
83444: EMPTY
83445: LIST
83446: LIST
83447: PUSH
83448: LD_INT 5
83450: NEG
83451: PUSH
83452: LD_INT 5
83454: NEG
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: PUSH
83460: LD_INT 3
83462: NEG
83463: PUSH
83464: LD_INT 5
83466: NEG
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PUSH
83472: LD_INT 5
83474: NEG
83475: PUSH
83476: LD_INT 3
83478: NEG
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 0
83486: PUSH
83487: LD_INT 3
83489: NEG
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 0
83497: PUSH
83498: LD_INT 4
83500: NEG
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 1
83508: PUSH
83509: LD_INT 3
83511: NEG
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PUSH
83517: LD_INT 1
83519: PUSH
83520: LD_INT 2
83522: NEG
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: LD_INT 0
83530: PUSH
83531: LD_INT 2
83533: NEG
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: LD_INT 1
83541: NEG
83542: PUSH
83543: LD_INT 3
83545: NEG
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: PUSH
83551: LD_INT 1
83553: NEG
83554: PUSH
83555: LD_INT 4
83557: NEG
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 2
83565: PUSH
83566: LD_INT 2
83568: NEG
83569: PUSH
83570: EMPTY
83571: LIST
83572: LIST
83573: PUSH
83574: LD_INT 2
83576: NEG
83577: PUSH
83578: LD_INT 4
83580: NEG
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: PUSH
83586: LD_INT 4
83588: PUSH
83589: LD_INT 0
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: PUSH
83596: LD_INT 4
83598: PUSH
83599: LD_INT 1
83601: NEG
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: PUSH
83607: LD_INT 5
83609: PUSH
83610: LD_INT 0
83612: PUSH
83613: EMPTY
83614: LIST
83615: LIST
83616: PUSH
83617: LD_INT 5
83619: PUSH
83620: LD_INT 1
83622: PUSH
83623: EMPTY
83624: LIST
83625: LIST
83626: PUSH
83627: LD_INT 4
83629: PUSH
83630: LD_INT 1
83632: PUSH
83633: EMPTY
83634: LIST
83635: LIST
83636: PUSH
83637: LD_INT 3
83639: PUSH
83640: LD_INT 0
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: PUSH
83647: LD_INT 3
83649: PUSH
83650: LD_INT 1
83652: NEG
83653: PUSH
83654: EMPTY
83655: LIST
83656: LIST
83657: PUSH
83658: LD_INT 3
83660: PUSH
83661: LD_INT 2
83663: NEG
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 5
83671: PUSH
83672: LD_INT 2
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PUSH
83679: LD_INT 3
83681: PUSH
83682: LD_INT 3
83684: PUSH
83685: EMPTY
83686: LIST
83687: LIST
83688: PUSH
83689: LD_INT 3
83691: PUSH
83692: LD_INT 2
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: LD_INT 4
83701: PUSH
83702: LD_INT 3
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: PUSH
83709: LD_INT 4
83711: PUSH
83712: LD_INT 4
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 3
83721: PUSH
83722: LD_INT 4
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 2
83731: PUSH
83732: LD_INT 3
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PUSH
83739: LD_INT 2
83741: PUSH
83742: LD_INT 2
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: PUSH
83749: LD_INT 4
83751: PUSH
83752: LD_INT 2
83754: PUSH
83755: EMPTY
83756: LIST
83757: LIST
83758: PUSH
83759: LD_INT 2
83761: PUSH
83762: LD_INT 4
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: PUSH
83769: LD_INT 0
83771: PUSH
83772: LD_INT 4
83774: PUSH
83775: EMPTY
83776: LIST
83777: LIST
83778: PUSH
83779: LD_INT 0
83781: PUSH
83782: LD_INT 3
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PUSH
83789: LD_INT 1
83791: PUSH
83792: LD_INT 4
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: LD_INT 1
83801: PUSH
83802: LD_INT 5
83804: PUSH
83805: EMPTY
83806: LIST
83807: LIST
83808: PUSH
83809: LD_INT 0
83811: PUSH
83812: LD_INT 5
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: LD_INT 1
83821: NEG
83822: PUSH
83823: LD_INT 4
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: PUSH
83830: LD_INT 1
83832: NEG
83833: PUSH
83834: LD_INT 3
83836: PUSH
83837: EMPTY
83838: LIST
83839: LIST
83840: PUSH
83841: LD_INT 2
83843: PUSH
83844: LD_INT 5
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PUSH
83851: LD_INT 2
83853: NEG
83854: PUSH
83855: LD_INT 3
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: LIST
83866: LIST
83867: LIST
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: LIST
83873: LIST
83874: LIST
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: LIST
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: LIST
83896: LIST
83897: LIST
83898: LIST
83899: LIST
83900: LIST
83901: LIST
83902: LIST
83903: LIST
83904: LIST
83905: LIST
83906: LIST
83907: LIST
83908: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83909: LD_ADDR_VAR 0 34
83913: PUSH
83914: LD_INT 0
83916: PUSH
83917: LD_INT 4
83919: NEG
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: PUSH
83925: LD_INT 0
83927: PUSH
83928: LD_INT 5
83930: NEG
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 1
83938: PUSH
83939: LD_INT 4
83941: NEG
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: PUSH
83947: LD_INT 1
83949: PUSH
83950: LD_INT 3
83952: NEG
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: PUSH
83958: LD_INT 0
83960: PUSH
83961: LD_INT 3
83963: NEG
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PUSH
83969: LD_INT 1
83971: NEG
83972: PUSH
83973: LD_INT 4
83975: NEG
83976: PUSH
83977: EMPTY
83978: LIST
83979: LIST
83980: PUSH
83981: LD_INT 1
83983: NEG
83984: PUSH
83985: LD_INT 5
83987: NEG
83988: PUSH
83989: EMPTY
83990: LIST
83991: LIST
83992: PUSH
83993: LD_INT 2
83995: PUSH
83996: LD_INT 3
83998: NEG
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: PUSH
84004: LD_INT 2
84006: NEG
84007: PUSH
84008: LD_INT 5
84010: NEG
84011: PUSH
84012: EMPTY
84013: LIST
84014: LIST
84015: PUSH
84016: LD_INT 3
84018: PUSH
84019: LD_INT 0
84021: PUSH
84022: EMPTY
84023: LIST
84024: LIST
84025: PUSH
84026: LD_INT 3
84028: PUSH
84029: LD_INT 1
84031: NEG
84032: PUSH
84033: EMPTY
84034: LIST
84035: LIST
84036: PUSH
84037: LD_INT 4
84039: PUSH
84040: LD_INT 0
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: PUSH
84047: LD_INT 4
84049: PUSH
84050: LD_INT 1
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: LD_INT 3
84059: PUSH
84060: LD_INT 1
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 2
84069: PUSH
84070: LD_INT 0
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 2
84079: PUSH
84080: LD_INT 1
84082: NEG
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: PUSH
84088: LD_INT 2
84090: PUSH
84091: LD_INT 2
84093: NEG
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PUSH
84099: LD_INT 4
84101: PUSH
84102: LD_INT 2
84104: PUSH
84105: EMPTY
84106: LIST
84107: LIST
84108: PUSH
84109: LD_INT 4
84111: PUSH
84112: LD_INT 4
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 4
84121: PUSH
84122: LD_INT 3
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 5
84131: PUSH
84132: LD_INT 4
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 5
84141: PUSH
84142: LD_INT 5
84144: PUSH
84145: EMPTY
84146: LIST
84147: LIST
84148: PUSH
84149: LD_INT 4
84151: PUSH
84152: LD_INT 5
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: PUSH
84159: LD_INT 3
84161: PUSH
84162: LD_INT 4
84164: PUSH
84165: EMPTY
84166: LIST
84167: LIST
84168: PUSH
84169: LD_INT 3
84171: PUSH
84172: LD_INT 3
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PUSH
84179: LD_INT 5
84181: PUSH
84182: LD_INT 3
84184: PUSH
84185: EMPTY
84186: LIST
84187: LIST
84188: PUSH
84189: LD_INT 3
84191: PUSH
84192: LD_INT 5
84194: PUSH
84195: EMPTY
84196: LIST
84197: LIST
84198: PUSH
84199: LD_INT 0
84201: PUSH
84202: LD_INT 3
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 0
84211: PUSH
84212: LD_INT 2
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 1
84221: PUSH
84222: LD_INT 3
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: PUSH
84229: LD_INT 1
84231: PUSH
84232: LD_INT 4
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 0
84241: PUSH
84242: LD_INT 4
84244: PUSH
84245: EMPTY
84246: LIST
84247: LIST
84248: PUSH
84249: LD_INT 1
84251: NEG
84252: PUSH
84253: LD_INT 3
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 1
84262: NEG
84263: PUSH
84264: LD_INT 2
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 2
84273: PUSH
84274: LD_INT 4
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 2
84283: NEG
84284: PUSH
84285: LD_INT 2
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 4
84294: NEG
84295: PUSH
84296: LD_INT 0
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 4
84305: NEG
84306: PUSH
84307: LD_INT 1
84309: NEG
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 3
84317: NEG
84318: PUSH
84319: LD_INT 0
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PUSH
84326: LD_INT 3
84328: NEG
84329: PUSH
84330: LD_INT 1
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 4
84339: NEG
84340: PUSH
84341: LD_INT 1
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 5
84350: NEG
84351: PUSH
84352: LD_INT 0
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 5
84361: NEG
84362: PUSH
84363: LD_INT 1
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 5
84373: NEG
84374: PUSH
84375: LD_INT 2
84377: NEG
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 3
84385: NEG
84386: PUSH
84387: LD_INT 2
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: LIST
84407: LIST
84408: LIST
84409: LIST
84410: LIST
84411: LIST
84412: LIST
84413: LIST
84414: LIST
84415: LIST
84416: LIST
84417: LIST
84418: LIST
84419: LIST
84420: LIST
84421: LIST
84422: LIST
84423: LIST
84424: LIST
84425: LIST
84426: LIST
84427: LIST
84428: LIST
84429: LIST
84430: LIST
84431: LIST
84432: LIST
84433: LIST
84434: LIST
84435: LIST
84436: LIST
84437: LIST
84438: LIST
84439: LIST
84440: ST_TO_ADDR
// end ; end ;
84441: GO 84444
84443: POP
// case btype of b_depot , b_warehouse :
84444: LD_VAR 0 1
84448: PUSH
84449: LD_INT 0
84451: DOUBLE
84452: EQUAL
84453: IFTRUE 84463
84455: LD_INT 1
84457: DOUBLE
84458: EQUAL
84459: IFTRUE 84463
84461: GO 84664
84463: POP
// case nation of nation_american :
84464: LD_VAR 0 5
84468: PUSH
84469: LD_INT 1
84471: DOUBLE
84472: EQUAL
84473: IFTRUE 84477
84475: GO 84533
84477: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
84478: LD_ADDR_VAR 0 9
84482: PUSH
84483: LD_VAR 0 11
84487: PUSH
84488: LD_VAR 0 12
84492: PUSH
84493: LD_VAR 0 13
84497: PUSH
84498: LD_VAR 0 14
84502: PUSH
84503: LD_VAR 0 15
84507: PUSH
84508: LD_VAR 0 16
84512: PUSH
84513: EMPTY
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: PUSH
84521: LD_VAR 0 4
84525: PUSH
84526: LD_INT 1
84528: PLUS
84529: ARRAY
84530: ST_TO_ADDR
84531: GO 84662
84533: LD_INT 2
84535: DOUBLE
84536: EQUAL
84537: IFTRUE 84541
84539: GO 84597
84541: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
84542: LD_ADDR_VAR 0 9
84546: PUSH
84547: LD_VAR 0 17
84551: PUSH
84552: LD_VAR 0 18
84556: PUSH
84557: LD_VAR 0 19
84561: PUSH
84562: LD_VAR 0 20
84566: PUSH
84567: LD_VAR 0 21
84571: PUSH
84572: LD_VAR 0 22
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: PUSH
84585: LD_VAR 0 4
84589: PUSH
84590: LD_INT 1
84592: PLUS
84593: ARRAY
84594: ST_TO_ADDR
84595: GO 84662
84597: LD_INT 3
84599: DOUBLE
84600: EQUAL
84601: IFTRUE 84605
84603: GO 84661
84605: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
84606: LD_ADDR_VAR 0 9
84610: PUSH
84611: LD_VAR 0 23
84615: PUSH
84616: LD_VAR 0 24
84620: PUSH
84621: LD_VAR 0 25
84625: PUSH
84626: LD_VAR 0 26
84630: PUSH
84631: LD_VAR 0 27
84635: PUSH
84636: LD_VAR 0 28
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: PUSH
84649: LD_VAR 0 4
84653: PUSH
84654: LD_INT 1
84656: PLUS
84657: ARRAY
84658: ST_TO_ADDR
84659: GO 84662
84661: POP
84662: GO 85217
84664: LD_INT 2
84666: DOUBLE
84667: EQUAL
84668: IFTRUE 84678
84670: LD_INT 3
84672: DOUBLE
84673: EQUAL
84674: IFTRUE 84678
84676: GO 84734
84678: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
84679: LD_ADDR_VAR 0 9
84683: PUSH
84684: LD_VAR 0 29
84688: PUSH
84689: LD_VAR 0 30
84693: PUSH
84694: LD_VAR 0 31
84698: PUSH
84699: LD_VAR 0 32
84703: PUSH
84704: LD_VAR 0 33
84708: PUSH
84709: LD_VAR 0 34
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: LIST
84721: PUSH
84722: LD_VAR 0 4
84726: PUSH
84727: LD_INT 1
84729: PLUS
84730: ARRAY
84731: ST_TO_ADDR
84732: GO 85217
84734: LD_INT 16
84736: DOUBLE
84737: EQUAL
84738: IFTRUE 84796
84740: LD_INT 17
84742: DOUBLE
84743: EQUAL
84744: IFTRUE 84796
84746: LD_INT 18
84748: DOUBLE
84749: EQUAL
84750: IFTRUE 84796
84752: LD_INT 19
84754: DOUBLE
84755: EQUAL
84756: IFTRUE 84796
84758: LD_INT 22
84760: DOUBLE
84761: EQUAL
84762: IFTRUE 84796
84764: LD_INT 20
84766: DOUBLE
84767: EQUAL
84768: IFTRUE 84796
84770: LD_INT 21
84772: DOUBLE
84773: EQUAL
84774: IFTRUE 84796
84776: LD_INT 23
84778: DOUBLE
84779: EQUAL
84780: IFTRUE 84796
84782: LD_INT 24
84784: DOUBLE
84785: EQUAL
84786: IFTRUE 84796
84788: LD_INT 25
84790: DOUBLE
84791: EQUAL
84792: IFTRUE 84796
84794: GO 84852
84796: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84797: LD_ADDR_VAR 0 9
84801: PUSH
84802: LD_VAR 0 35
84806: PUSH
84807: LD_VAR 0 36
84811: PUSH
84812: LD_VAR 0 37
84816: PUSH
84817: LD_VAR 0 38
84821: PUSH
84822: LD_VAR 0 39
84826: PUSH
84827: LD_VAR 0 40
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: PUSH
84840: LD_VAR 0 4
84844: PUSH
84845: LD_INT 1
84847: PLUS
84848: ARRAY
84849: ST_TO_ADDR
84850: GO 85217
84852: LD_INT 6
84854: DOUBLE
84855: EQUAL
84856: IFTRUE 84908
84858: LD_INT 7
84860: DOUBLE
84861: EQUAL
84862: IFTRUE 84908
84864: LD_INT 8
84866: DOUBLE
84867: EQUAL
84868: IFTRUE 84908
84870: LD_INT 13
84872: DOUBLE
84873: EQUAL
84874: IFTRUE 84908
84876: LD_INT 12
84878: DOUBLE
84879: EQUAL
84880: IFTRUE 84908
84882: LD_INT 15
84884: DOUBLE
84885: EQUAL
84886: IFTRUE 84908
84888: LD_INT 11
84890: DOUBLE
84891: EQUAL
84892: IFTRUE 84908
84894: LD_INT 14
84896: DOUBLE
84897: EQUAL
84898: IFTRUE 84908
84900: LD_INT 10
84902: DOUBLE
84903: EQUAL
84904: IFTRUE 84908
84906: GO 84964
84908: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84909: LD_ADDR_VAR 0 9
84913: PUSH
84914: LD_VAR 0 41
84918: PUSH
84919: LD_VAR 0 42
84923: PUSH
84924: LD_VAR 0 43
84928: PUSH
84929: LD_VAR 0 44
84933: PUSH
84934: LD_VAR 0 45
84938: PUSH
84939: LD_VAR 0 46
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: PUSH
84952: LD_VAR 0 4
84956: PUSH
84957: LD_INT 1
84959: PLUS
84960: ARRAY
84961: ST_TO_ADDR
84962: GO 85217
84964: LD_INT 36
84966: DOUBLE
84967: EQUAL
84968: IFTRUE 84972
84970: GO 85028
84972: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84973: LD_ADDR_VAR 0 9
84977: PUSH
84978: LD_VAR 0 47
84982: PUSH
84983: LD_VAR 0 48
84987: PUSH
84988: LD_VAR 0 49
84992: PUSH
84993: LD_VAR 0 50
84997: PUSH
84998: LD_VAR 0 51
85002: PUSH
85003: LD_VAR 0 52
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: PUSH
85016: LD_VAR 0 4
85020: PUSH
85021: LD_INT 1
85023: PLUS
85024: ARRAY
85025: ST_TO_ADDR
85026: GO 85217
85028: LD_INT 4
85030: DOUBLE
85031: EQUAL
85032: IFTRUE 85054
85034: LD_INT 5
85036: DOUBLE
85037: EQUAL
85038: IFTRUE 85054
85040: LD_INT 34
85042: DOUBLE
85043: EQUAL
85044: IFTRUE 85054
85046: LD_INT 37
85048: DOUBLE
85049: EQUAL
85050: IFTRUE 85054
85052: GO 85110
85054: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
85055: LD_ADDR_VAR 0 9
85059: PUSH
85060: LD_VAR 0 53
85064: PUSH
85065: LD_VAR 0 54
85069: PUSH
85070: LD_VAR 0 55
85074: PUSH
85075: LD_VAR 0 56
85079: PUSH
85080: LD_VAR 0 57
85084: PUSH
85085: LD_VAR 0 58
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: PUSH
85098: LD_VAR 0 4
85102: PUSH
85103: LD_INT 1
85105: PLUS
85106: ARRAY
85107: ST_TO_ADDR
85108: GO 85217
85110: LD_INT 31
85112: DOUBLE
85113: EQUAL
85114: IFTRUE 85160
85116: LD_INT 32
85118: DOUBLE
85119: EQUAL
85120: IFTRUE 85160
85122: LD_INT 33
85124: DOUBLE
85125: EQUAL
85126: IFTRUE 85160
85128: LD_INT 27
85130: DOUBLE
85131: EQUAL
85132: IFTRUE 85160
85134: LD_INT 26
85136: DOUBLE
85137: EQUAL
85138: IFTRUE 85160
85140: LD_INT 28
85142: DOUBLE
85143: EQUAL
85144: IFTRUE 85160
85146: LD_INT 29
85148: DOUBLE
85149: EQUAL
85150: IFTRUE 85160
85152: LD_INT 30
85154: DOUBLE
85155: EQUAL
85156: IFTRUE 85160
85158: GO 85216
85160: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
85161: LD_ADDR_VAR 0 9
85165: PUSH
85166: LD_VAR 0 59
85170: PUSH
85171: LD_VAR 0 60
85175: PUSH
85176: LD_VAR 0 61
85180: PUSH
85181: LD_VAR 0 62
85185: PUSH
85186: LD_VAR 0 63
85190: PUSH
85191: LD_VAR 0 64
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: PUSH
85204: LD_VAR 0 4
85208: PUSH
85209: LD_INT 1
85211: PLUS
85212: ARRAY
85213: ST_TO_ADDR
85214: GO 85217
85216: POP
// temp_list2 = [ ] ;
85217: LD_ADDR_VAR 0 10
85221: PUSH
85222: EMPTY
85223: ST_TO_ADDR
// for i in temp_list do
85224: LD_ADDR_VAR 0 8
85228: PUSH
85229: LD_VAR 0 9
85233: PUSH
85234: FOR_IN
85235: IFFALSE 85287
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
85237: LD_ADDR_VAR 0 10
85241: PUSH
85242: LD_VAR 0 10
85246: PUSH
85247: LD_VAR 0 8
85251: PUSH
85252: LD_INT 1
85254: ARRAY
85255: PUSH
85256: LD_VAR 0 2
85260: PLUS
85261: PUSH
85262: LD_VAR 0 8
85266: PUSH
85267: LD_INT 2
85269: ARRAY
85270: PUSH
85271: LD_VAR 0 3
85275: PLUS
85276: PUSH
85277: EMPTY
85278: LIST
85279: LIST
85280: PUSH
85281: EMPTY
85282: LIST
85283: ADD
85284: ST_TO_ADDR
85285: GO 85234
85287: POP
85288: POP
// result = temp_list2 ;
85289: LD_ADDR_VAR 0 7
85293: PUSH
85294: LD_VAR 0 10
85298: ST_TO_ADDR
// end ;
85299: LD_VAR 0 7
85303: RET
// export function EnemyInRange ( unit , dist ) ; begin
85304: LD_INT 0
85306: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
85307: LD_ADDR_VAR 0 3
85311: PUSH
85312: LD_VAR 0 1
85316: PPUSH
85317: CALL_OW 255
85321: PPUSH
85322: LD_VAR 0 1
85326: PPUSH
85327: CALL_OW 250
85331: PPUSH
85332: LD_VAR 0 1
85336: PPUSH
85337: CALL_OW 251
85341: PPUSH
85342: LD_VAR 0 2
85346: PPUSH
85347: CALL 58706 0 4
85351: PUSH
85352: LD_INT 4
85354: ARRAY
85355: ST_TO_ADDR
// end ;
85356: LD_VAR 0 3
85360: RET
// export function PlayerSeeMe ( unit ) ; begin
85361: LD_INT 0
85363: PPUSH
// result := See ( your_side , unit ) ;
85364: LD_ADDR_VAR 0 2
85368: PUSH
85369: LD_OWVAR 2
85373: PPUSH
85374: LD_VAR 0 1
85378: PPUSH
85379: CALL_OW 292
85383: ST_TO_ADDR
// end ;
85384: LD_VAR 0 2
85388: RET
// export function ReverseDir ( unit ) ; begin
85389: LD_INT 0
85391: PPUSH
// if not unit then
85392: LD_VAR 0 1
85396: NOT
85397: IFFALSE 85401
// exit ;
85399: GO 85424
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
85401: LD_ADDR_VAR 0 2
85405: PUSH
85406: LD_VAR 0 1
85410: PPUSH
85411: CALL_OW 254
85415: PUSH
85416: LD_INT 3
85418: PLUS
85419: PUSH
85420: LD_INT 6
85422: MOD
85423: ST_TO_ADDR
// end ;
85424: LD_VAR 0 2
85428: RET
// export function ReverseArray ( array ) ; var i ; begin
85429: LD_INT 0
85431: PPUSH
85432: PPUSH
// if not array then
85433: LD_VAR 0 1
85437: NOT
85438: IFFALSE 85442
// exit ;
85440: GO 85497
// result := [ ] ;
85442: LD_ADDR_VAR 0 2
85446: PUSH
85447: EMPTY
85448: ST_TO_ADDR
// for i := array downto 1 do
85449: LD_ADDR_VAR 0 3
85453: PUSH
85454: DOUBLE
85455: LD_VAR 0 1
85459: INC
85460: ST_TO_ADDR
85461: LD_INT 1
85463: PUSH
85464: FOR_DOWNTO
85465: IFFALSE 85495
// result := Join ( result , array [ i ] ) ;
85467: LD_ADDR_VAR 0 2
85471: PUSH
85472: LD_VAR 0 2
85476: PPUSH
85477: LD_VAR 0 1
85481: PUSH
85482: LD_VAR 0 3
85486: ARRAY
85487: PPUSH
85488: CALL 90140 0 2
85492: ST_TO_ADDR
85493: GO 85464
85495: POP
85496: POP
// end ;
85497: LD_VAR 0 2
85501: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
85502: LD_INT 0
85504: PPUSH
85505: PPUSH
85506: PPUSH
85507: PPUSH
85508: PPUSH
85509: PPUSH
// if not unit or not hexes then
85510: LD_VAR 0 1
85514: NOT
85515: PUSH
85516: LD_VAR 0 2
85520: NOT
85521: OR
85522: IFFALSE 85526
// exit ;
85524: GO 85649
// dist := 9999 ;
85526: LD_ADDR_VAR 0 5
85530: PUSH
85531: LD_INT 9999
85533: ST_TO_ADDR
// for i = 1 to hexes do
85534: LD_ADDR_VAR 0 4
85538: PUSH
85539: DOUBLE
85540: LD_INT 1
85542: DEC
85543: ST_TO_ADDR
85544: LD_VAR 0 2
85548: PUSH
85549: FOR_TO
85550: IFFALSE 85637
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
85552: LD_ADDR_VAR 0 6
85556: PUSH
85557: LD_VAR 0 1
85561: PPUSH
85562: LD_VAR 0 2
85566: PUSH
85567: LD_VAR 0 4
85571: ARRAY
85572: PUSH
85573: LD_INT 1
85575: ARRAY
85576: PPUSH
85577: LD_VAR 0 2
85581: PUSH
85582: LD_VAR 0 4
85586: ARRAY
85587: PUSH
85588: LD_INT 2
85590: ARRAY
85591: PPUSH
85592: CALL_OW 297
85596: ST_TO_ADDR
// if tdist < dist then
85597: LD_VAR 0 6
85601: PUSH
85602: LD_VAR 0 5
85606: LESS
85607: IFFALSE 85635
// begin hex := hexes [ i ] ;
85609: LD_ADDR_VAR 0 8
85613: PUSH
85614: LD_VAR 0 2
85618: PUSH
85619: LD_VAR 0 4
85623: ARRAY
85624: ST_TO_ADDR
// dist := tdist ;
85625: LD_ADDR_VAR 0 5
85629: PUSH
85630: LD_VAR 0 6
85634: ST_TO_ADDR
// end ; end ;
85635: GO 85549
85637: POP
85638: POP
// result := hex ;
85639: LD_ADDR_VAR 0 3
85643: PUSH
85644: LD_VAR 0 8
85648: ST_TO_ADDR
// end ;
85649: LD_VAR 0 3
85653: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
85654: LD_INT 0
85656: PPUSH
85657: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85658: LD_VAR 0 1
85662: NOT
85663: PUSH
85664: LD_VAR 0 1
85668: PUSH
85669: LD_INT 21
85671: PUSH
85672: LD_INT 2
85674: PUSH
85675: EMPTY
85676: LIST
85677: LIST
85678: PUSH
85679: LD_INT 23
85681: PUSH
85682: LD_INT 2
85684: PUSH
85685: EMPTY
85686: LIST
85687: LIST
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PPUSH
85693: CALL_OW 69
85697: IN
85698: NOT
85699: OR
85700: IFFALSE 85704
// exit ;
85702: GO 85751
// for i = 1 to 3 do
85704: LD_ADDR_VAR 0 3
85708: PUSH
85709: DOUBLE
85710: LD_INT 1
85712: DEC
85713: ST_TO_ADDR
85714: LD_INT 3
85716: PUSH
85717: FOR_TO
85718: IFFALSE 85749
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
85720: LD_VAR 0 1
85724: PPUSH
85725: CALL_OW 250
85729: PPUSH
85730: LD_VAR 0 1
85734: PPUSH
85735: CALL_OW 251
85739: PPUSH
85740: LD_INT 1
85742: PPUSH
85743: CALL_OW 453
85747: GO 85717
85749: POP
85750: POP
// end ;
85751: LD_VAR 0 2
85755: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
85756: LD_INT 0
85758: PPUSH
85759: PPUSH
85760: PPUSH
85761: PPUSH
85762: PPUSH
85763: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
85764: LD_VAR 0 1
85768: NOT
85769: PUSH
85770: LD_VAR 0 2
85774: NOT
85775: OR
85776: PUSH
85777: LD_VAR 0 1
85781: PPUSH
85782: CALL_OW 314
85786: OR
85787: IFFALSE 85791
// exit ;
85789: GO 86258
// if GetLives ( i ) < 250 then
85791: LD_VAR 0 4
85795: PPUSH
85796: CALL_OW 256
85800: PUSH
85801: LD_INT 250
85803: LESS
85804: IFFALSE 85817
// begin ComAutodestruct ( i ) ;
85806: LD_VAR 0 4
85810: PPUSH
85811: CALL 85654 0 1
// exit ;
85815: GO 86258
// end ; x := GetX ( enemy_unit ) ;
85817: LD_ADDR_VAR 0 7
85821: PUSH
85822: LD_VAR 0 2
85826: PPUSH
85827: CALL_OW 250
85831: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85832: LD_ADDR_VAR 0 8
85836: PUSH
85837: LD_VAR 0 2
85841: PPUSH
85842: CALL_OW 251
85846: ST_TO_ADDR
// if not x or not y then
85847: LD_VAR 0 7
85851: NOT
85852: PUSH
85853: LD_VAR 0 8
85857: NOT
85858: OR
85859: IFFALSE 85863
// exit ;
85861: GO 86258
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85863: LD_ADDR_VAR 0 6
85867: PUSH
85868: LD_VAR 0 7
85872: PPUSH
85873: LD_INT 0
85875: PPUSH
85876: LD_INT 4
85878: PPUSH
85879: CALL_OW 272
85883: PUSH
85884: LD_VAR 0 8
85888: PPUSH
85889: LD_INT 0
85891: PPUSH
85892: LD_INT 4
85894: PPUSH
85895: CALL_OW 273
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: LD_VAR 0 7
85908: PPUSH
85909: LD_INT 1
85911: PPUSH
85912: LD_INT 4
85914: PPUSH
85915: CALL_OW 272
85919: PUSH
85920: LD_VAR 0 8
85924: PPUSH
85925: LD_INT 1
85927: PPUSH
85928: LD_INT 4
85930: PPUSH
85931: CALL_OW 273
85935: PUSH
85936: EMPTY
85937: LIST
85938: LIST
85939: PUSH
85940: LD_VAR 0 7
85944: PPUSH
85945: LD_INT 2
85947: PPUSH
85948: LD_INT 4
85950: PPUSH
85951: CALL_OW 272
85955: PUSH
85956: LD_VAR 0 8
85960: PPUSH
85961: LD_INT 2
85963: PPUSH
85964: LD_INT 4
85966: PPUSH
85967: CALL_OW 273
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: PUSH
85976: LD_VAR 0 7
85980: PPUSH
85981: LD_INT 3
85983: PPUSH
85984: LD_INT 4
85986: PPUSH
85987: CALL_OW 272
85991: PUSH
85992: LD_VAR 0 8
85996: PPUSH
85997: LD_INT 3
85999: PPUSH
86000: LD_INT 4
86002: PPUSH
86003: CALL_OW 273
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PUSH
86012: LD_VAR 0 7
86016: PPUSH
86017: LD_INT 4
86019: PPUSH
86020: LD_INT 4
86022: PPUSH
86023: CALL_OW 272
86027: PUSH
86028: LD_VAR 0 8
86032: PPUSH
86033: LD_INT 4
86035: PPUSH
86036: LD_INT 4
86038: PPUSH
86039: CALL_OW 273
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: LD_VAR 0 7
86052: PPUSH
86053: LD_INT 5
86055: PPUSH
86056: LD_INT 4
86058: PPUSH
86059: CALL_OW 272
86063: PUSH
86064: LD_VAR 0 8
86068: PPUSH
86069: LD_INT 5
86071: PPUSH
86072: LD_INT 4
86074: PPUSH
86075: CALL_OW 273
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: ST_TO_ADDR
// for i = tmp downto 1 do
86092: LD_ADDR_VAR 0 4
86096: PUSH
86097: DOUBLE
86098: LD_VAR 0 6
86102: INC
86103: ST_TO_ADDR
86104: LD_INT 1
86106: PUSH
86107: FOR_DOWNTO
86108: IFFALSE 86209
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
86110: LD_VAR 0 6
86114: PUSH
86115: LD_VAR 0 4
86119: ARRAY
86120: PUSH
86121: LD_INT 1
86123: ARRAY
86124: PPUSH
86125: LD_VAR 0 6
86129: PUSH
86130: LD_VAR 0 4
86134: ARRAY
86135: PUSH
86136: LD_INT 2
86138: ARRAY
86139: PPUSH
86140: CALL_OW 488
86144: NOT
86145: PUSH
86146: LD_VAR 0 6
86150: PUSH
86151: LD_VAR 0 4
86155: ARRAY
86156: PUSH
86157: LD_INT 1
86159: ARRAY
86160: PPUSH
86161: LD_VAR 0 6
86165: PUSH
86166: LD_VAR 0 4
86170: ARRAY
86171: PUSH
86172: LD_INT 2
86174: ARRAY
86175: PPUSH
86176: CALL_OW 428
86180: PUSH
86181: LD_INT 0
86183: NONEQUAL
86184: OR
86185: IFFALSE 86207
// tmp := Delete ( tmp , i ) ;
86187: LD_ADDR_VAR 0 6
86191: PUSH
86192: LD_VAR 0 6
86196: PPUSH
86197: LD_VAR 0 4
86201: PPUSH
86202: CALL_OW 3
86206: ST_TO_ADDR
86207: GO 86107
86209: POP
86210: POP
// j := GetClosestHex ( unit , tmp ) ;
86211: LD_ADDR_VAR 0 5
86215: PUSH
86216: LD_VAR 0 1
86220: PPUSH
86221: LD_VAR 0 6
86225: PPUSH
86226: CALL 85502 0 2
86230: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
86231: LD_VAR 0 1
86235: PPUSH
86236: LD_VAR 0 5
86240: PUSH
86241: LD_INT 1
86243: ARRAY
86244: PPUSH
86245: LD_VAR 0 5
86249: PUSH
86250: LD_INT 2
86252: ARRAY
86253: PPUSH
86254: CALL_OW 111
// end ;
86258: LD_VAR 0 3
86262: RET
// export function PrepareApemanSoldier ( ) ; begin
86263: LD_INT 0
86265: PPUSH
// uc_nation := 0 ;
86266: LD_ADDR_OWVAR 21
86270: PUSH
86271: LD_INT 0
86273: ST_TO_ADDR
// hc_sex := sex_male ;
86274: LD_ADDR_OWVAR 27
86278: PUSH
86279: LD_INT 1
86281: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
86282: LD_ADDR_OWVAR 28
86286: PUSH
86287: LD_INT 15
86289: ST_TO_ADDR
// hc_gallery :=  ;
86290: LD_ADDR_OWVAR 33
86294: PUSH
86295: LD_STRING 
86297: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86298: LD_ADDR_OWVAR 31
86302: PUSH
86303: LD_INT 0
86305: PPUSH
86306: LD_INT 3
86308: PPUSH
86309: CALL_OW 12
86313: PUSH
86314: LD_INT 0
86316: PPUSH
86317: LD_INT 3
86319: PPUSH
86320: CALL_OW 12
86324: PUSH
86325: LD_INT 0
86327: PUSH
86328: LD_INT 0
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: ST_TO_ADDR
// end ;
86337: LD_VAR 0 1
86341: RET
// export function PrepareApemanEngineer ( ) ; begin
86342: LD_INT 0
86344: PPUSH
// uc_nation := 0 ;
86345: LD_ADDR_OWVAR 21
86349: PUSH
86350: LD_INT 0
86352: ST_TO_ADDR
// hc_sex := sex_male ;
86353: LD_ADDR_OWVAR 27
86357: PUSH
86358: LD_INT 1
86360: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
86361: LD_ADDR_OWVAR 28
86365: PUSH
86366: LD_INT 16
86368: ST_TO_ADDR
// hc_gallery :=  ;
86369: LD_ADDR_OWVAR 33
86373: PUSH
86374: LD_STRING 
86376: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86377: LD_ADDR_OWVAR 31
86381: PUSH
86382: LD_INT 0
86384: PPUSH
86385: LD_INT 3
86387: PPUSH
86388: CALL_OW 12
86392: PUSH
86393: LD_INT 0
86395: PPUSH
86396: LD_INT 3
86398: PPUSH
86399: CALL_OW 12
86403: PUSH
86404: LD_INT 0
86406: PUSH
86407: LD_INT 0
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: ST_TO_ADDR
// end ;
86416: LD_VAR 0 1
86420: RET
// export function PrepareApeman ( agressivity ) ; begin
86421: LD_INT 0
86423: PPUSH
// uc_side := 0 ;
86424: LD_ADDR_OWVAR 20
86428: PUSH
86429: LD_INT 0
86431: ST_TO_ADDR
// uc_nation := 0 ;
86432: LD_ADDR_OWVAR 21
86436: PUSH
86437: LD_INT 0
86439: ST_TO_ADDR
// hc_sex := sex_male ;
86440: LD_ADDR_OWVAR 27
86444: PUSH
86445: LD_INT 1
86447: ST_TO_ADDR
// hc_class := class_apeman ;
86448: LD_ADDR_OWVAR 28
86452: PUSH
86453: LD_INT 12
86455: ST_TO_ADDR
// hc_gallery :=  ;
86456: LD_ADDR_OWVAR 33
86460: PUSH
86461: LD_STRING 
86463: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
86464: LD_ADDR_OWVAR 35
86468: PUSH
86469: LD_VAR 0 1
86473: NEG
86474: PPUSH
86475: LD_VAR 0 1
86479: PPUSH
86480: CALL_OW 12
86484: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86485: LD_ADDR_OWVAR 31
86489: PUSH
86490: LD_INT 0
86492: PPUSH
86493: LD_INT 3
86495: PPUSH
86496: CALL_OW 12
86500: PUSH
86501: LD_INT 0
86503: PPUSH
86504: LD_INT 3
86506: PPUSH
86507: CALL_OW 12
86511: PUSH
86512: LD_INT 0
86514: PUSH
86515: LD_INT 0
86517: PUSH
86518: EMPTY
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: ST_TO_ADDR
// end ;
86524: LD_VAR 0 2
86528: RET
// export function PrepareTiger ( agressivity ) ; begin
86529: LD_INT 0
86531: PPUSH
// uc_side := 0 ;
86532: LD_ADDR_OWVAR 20
86536: PUSH
86537: LD_INT 0
86539: ST_TO_ADDR
// uc_nation := 0 ;
86540: LD_ADDR_OWVAR 21
86544: PUSH
86545: LD_INT 0
86547: ST_TO_ADDR
// hc_class := class_tiger ;
86548: LD_ADDR_OWVAR 28
86552: PUSH
86553: LD_INT 14
86555: ST_TO_ADDR
// hc_gallery :=  ;
86556: LD_ADDR_OWVAR 33
86560: PUSH
86561: LD_STRING 
86563: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
86564: LD_ADDR_OWVAR 35
86568: PUSH
86569: LD_VAR 0 1
86573: NEG
86574: PPUSH
86575: LD_VAR 0 1
86579: PPUSH
86580: CALL_OW 12
86584: ST_TO_ADDR
// end ;
86585: LD_VAR 0 2
86589: RET
// export function PrepareEnchidna ( ) ; begin
86590: LD_INT 0
86592: PPUSH
// uc_side := 0 ;
86593: LD_ADDR_OWVAR 20
86597: PUSH
86598: LD_INT 0
86600: ST_TO_ADDR
// uc_nation := 0 ;
86601: LD_ADDR_OWVAR 21
86605: PUSH
86606: LD_INT 0
86608: ST_TO_ADDR
// hc_class := class_baggie ;
86609: LD_ADDR_OWVAR 28
86613: PUSH
86614: LD_INT 13
86616: ST_TO_ADDR
// hc_gallery :=  ;
86617: LD_ADDR_OWVAR 33
86621: PUSH
86622: LD_STRING 
86624: ST_TO_ADDR
// end ;
86625: LD_VAR 0 1
86629: RET
// export function PrepareFrog ( ) ; begin
86630: LD_INT 0
86632: PPUSH
// uc_side := 0 ;
86633: LD_ADDR_OWVAR 20
86637: PUSH
86638: LD_INT 0
86640: ST_TO_ADDR
// uc_nation := 0 ;
86641: LD_ADDR_OWVAR 21
86645: PUSH
86646: LD_INT 0
86648: ST_TO_ADDR
// hc_class := class_frog ;
86649: LD_ADDR_OWVAR 28
86653: PUSH
86654: LD_INT 19
86656: ST_TO_ADDR
// hc_gallery :=  ;
86657: LD_ADDR_OWVAR 33
86661: PUSH
86662: LD_STRING 
86664: ST_TO_ADDR
// end ;
86665: LD_VAR 0 1
86669: RET
// export function PrepareFish ( ) ; begin
86670: LD_INT 0
86672: PPUSH
// uc_side := 0 ;
86673: LD_ADDR_OWVAR 20
86677: PUSH
86678: LD_INT 0
86680: ST_TO_ADDR
// uc_nation := 0 ;
86681: LD_ADDR_OWVAR 21
86685: PUSH
86686: LD_INT 0
86688: ST_TO_ADDR
// hc_class := class_fish ;
86689: LD_ADDR_OWVAR 28
86693: PUSH
86694: LD_INT 20
86696: ST_TO_ADDR
// hc_gallery :=  ;
86697: LD_ADDR_OWVAR 33
86701: PUSH
86702: LD_STRING 
86704: ST_TO_ADDR
// end ;
86705: LD_VAR 0 1
86709: RET
// export function PrepareBird ( ) ; begin
86710: LD_INT 0
86712: PPUSH
// uc_side := 0 ;
86713: LD_ADDR_OWVAR 20
86717: PUSH
86718: LD_INT 0
86720: ST_TO_ADDR
// uc_nation := 0 ;
86721: LD_ADDR_OWVAR 21
86725: PUSH
86726: LD_INT 0
86728: ST_TO_ADDR
// hc_class := class_phororhacos ;
86729: LD_ADDR_OWVAR 28
86733: PUSH
86734: LD_INT 18
86736: ST_TO_ADDR
// hc_gallery :=  ;
86737: LD_ADDR_OWVAR 33
86741: PUSH
86742: LD_STRING 
86744: ST_TO_ADDR
// end ;
86745: LD_VAR 0 1
86749: RET
// export function PrepareHorse ( ) ; begin
86750: LD_INT 0
86752: PPUSH
// uc_side := 0 ;
86753: LD_ADDR_OWVAR 20
86757: PUSH
86758: LD_INT 0
86760: ST_TO_ADDR
// uc_nation := 0 ;
86761: LD_ADDR_OWVAR 21
86765: PUSH
86766: LD_INT 0
86768: ST_TO_ADDR
// hc_class := class_horse ;
86769: LD_ADDR_OWVAR 28
86773: PUSH
86774: LD_INT 21
86776: ST_TO_ADDR
// hc_gallery :=  ;
86777: LD_ADDR_OWVAR 33
86781: PUSH
86782: LD_STRING 
86784: ST_TO_ADDR
// end ;
86785: LD_VAR 0 1
86789: RET
// export function PrepareMastodont ( ) ; begin
86790: LD_INT 0
86792: PPUSH
// uc_side := 0 ;
86793: LD_ADDR_OWVAR 20
86797: PUSH
86798: LD_INT 0
86800: ST_TO_ADDR
// uc_nation := 0 ;
86801: LD_ADDR_OWVAR 21
86805: PUSH
86806: LD_INT 0
86808: ST_TO_ADDR
// vc_chassis := class_mastodont ;
86809: LD_ADDR_OWVAR 37
86813: PUSH
86814: LD_INT 31
86816: ST_TO_ADDR
// vc_control := control_rider ;
86817: LD_ADDR_OWVAR 38
86821: PUSH
86822: LD_INT 4
86824: ST_TO_ADDR
// end ;
86825: LD_VAR 0 1
86829: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
86830: LD_INT 0
86832: PPUSH
86833: PPUSH
86834: PPUSH
// uc_side = 0 ;
86835: LD_ADDR_OWVAR 20
86839: PUSH
86840: LD_INT 0
86842: ST_TO_ADDR
// uc_nation = 0 ;
86843: LD_ADDR_OWVAR 21
86847: PUSH
86848: LD_INT 0
86850: ST_TO_ADDR
// InitHc_All ( ) ;
86851: CALL_OW 584
// InitVc ;
86855: CALL_OW 20
// if mastodonts then
86859: LD_VAR 0 6
86863: IFFALSE 86930
// for i = 1 to mastodonts do
86865: LD_ADDR_VAR 0 11
86869: PUSH
86870: DOUBLE
86871: LD_INT 1
86873: DEC
86874: ST_TO_ADDR
86875: LD_VAR 0 6
86879: PUSH
86880: FOR_TO
86881: IFFALSE 86928
// begin vc_chassis := 31 ;
86883: LD_ADDR_OWVAR 37
86887: PUSH
86888: LD_INT 31
86890: ST_TO_ADDR
// vc_control := control_rider ;
86891: LD_ADDR_OWVAR 38
86895: PUSH
86896: LD_INT 4
86898: ST_TO_ADDR
// animal := CreateVehicle ;
86899: LD_ADDR_VAR 0 12
86903: PUSH
86904: CALL_OW 45
86908: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86909: LD_VAR 0 12
86913: PPUSH
86914: LD_VAR 0 8
86918: PPUSH
86919: LD_INT 0
86921: PPUSH
86922: CALL 89058 0 3
// end ;
86926: GO 86880
86928: POP
86929: POP
// if horses then
86930: LD_VAR 0 5
86934: IFFALSE 87001
// for i = 1 to horses do
86936: LD_ADDR_VAR 0 11
86940: PUSH
86941: DOUBLE
86942: LD_INT 1
86944: DEC
86945: ST_TO_ADDR
86946: LD_VAR 0 5
86950: PUSH
86951: FOR_TO
86952: IFFALSE 86999
// begin hc_class := 21 ;
86954: LD_ADDR_OWVAR 28
86958: PUSH
86959: LD_INT 21
86961: ST_TO_ADDR
// hc_gallery :=  ;
86962: LD_ADDR_OWVAR 33
86966: PUSH
86967: LD_STRING 
86969: ST_TO_ADDR
// animal := CreateHuman ;
86970: LD_ADDR_VAR 0 12
86974: PUSH
86975: CALL_OW 44
86979: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86980: LD_VAR 0 12
86984: PPUSH
86985: LD_VAR 0 8
86989: PPUSH
86990: LD_INT 0
86992: PPUSH
86993: CALL 89058 0 3
// end ;
86997: GO 86951
86999: POP
87000: POP
// if birds then
87001: LD_VAR 0 1
87005: IFFALSE 87072
// for i = 1 to birds do
87007: LD_ADDR_VAR 0 11
87011: PUSH
87012: DOUBLE
87013: LD_INT 1
87015: DEC
87016: ST_TO_ADDR
87017: LD_VAR 0 1
87021: PUSH
87022: FOR_TO
87023: IFFALSE 87070
// begin hc_class = 18 ;
87025: LD_ADDR_OWVAR 28
87029: PUSH
87030: LD_INT 18
87032: ST_TO_ADDR
// hc_gallery =  ;
87033: LD_ADDR_OWVAR 33
87037: PUSH
87038: LD_STRING 
87040: ST_TO_ADDR
// animal := CreateHuman ;
87041: LD_ADDR_VAR 0 12
87045: PUSH
87046: CALL_OW 44
87050: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87051: LD_VAR 0 12
87055: PPUSH
87056: LD_VAR 0 8
87060: PPUSH
87061: LD_INT 0
87063: PPUSH
87064: CALL 89058 0 3
// end ;
87068: GO 87022
87070: POP
87071: POP
// if tigers then
87072: LD_VAR 0 2
87076: IFFALSE 87160
// for i = 1 to tigers do
87078: LD_ADDR_VAR 0 11
87082: PUSH
87083: DOUBLE
87084: LD_INT 1
87086: DEC
87087: ST_TO_ADDR
87088: LD_VAR 0 2
87092: PUSH
87093: FOR_TO
87094: IFFALSE 87158
// begin hc_class = class_tiger ;
87096: LD_ADDR_OWVAR 28
87100: PUSH
87101: LD_INT 14
87103: ST_TO_ADDR
// hc_gallery =  ;
87104: LD_ADDR_OWVAR 33
87108: PUSH
87109: LD_STRING 
87111: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
87112: LD_ADDR_OWVAR 35
87116: PUSH
87117: LD_INT 7
87119: NEG
87120: PPUSH
87121: LD_INT 7
87123: PPUSH
87124: CALL_OW 12
87128: ST_TO_ADDR
// animal := CreateHuman ;
87129: LD_ADDR_VAR 0 12
87133: PUSH
87134: CALL_OW 44
87138: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87139: LD_VAR 0 12
87143: PPUSH
87144: LD_VAR 0 8
87148: PPUSH
87149: LD_INT 0
87151: PPUSH
87152: CALL 89058 0 3
// end ;
87156: GO 87093
87158: POP
87159: POP
// if apemans then
87160: LD_VAR 0 3
87164: IFFALSE 87287
// for i = 1 to apemans do
87166: LD_ADDR_VAR 0 11
87170: PUSH
87171: DOUBLE
87172: LD_INT 1
87174: DEC
87175: ST_TO_ADDR
87176: LD_VAR 0 3
87180: PUSH
87181: FOR_TO
87182: IFFALSE 87285
// begin hc_class = class_apeman ;
87184: LD_ADDR_OWVAR 28
87188: PUSH
87189: LD_INT 12
87191: ST_TO_ADDR
// hc_gallery =  ;
87192: LD_ADDR_OWVAR 33
87196: PUSH
87197: LD_STRING 
87199: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
87200: LD_ADDR_OWVAR 35
87204: PUSH
87205: LD_INT 2
87207: NEG
87208: PPUSH
87209: LD_INT 2
87211: PPUSH
87212: CALL_OW 12
87216: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
87217: LD_ADDR_OWVAR 31
87221: PUSH
87222: LD_INT 1
87224: PPUSH
87225: LD_INT 3
87227: PPUSH
87228: CALL_OW 12
87232: PUSH
87233: LD_INT 1
87235: PPUSH
87236: LD_INT 3
87238: PPUSH
87239: CALL_OW 12
87243: PUSH
87244: LD_INT 0
87246: PUSH
87247: LD_INT 0
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: ST_TO_ADDR
// animal := CreateHuman ;
87256: LD_ADDR_VAR 0 12
87260: PUSH
87261: CALL_OW 44
87265: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87266: LD_VAR 0 12
87270: PPUSH
87271: LD_VAR 0 8
87275: PPUSH
87276: LD_INT 0
87278: PPUSH
87279: CALL 89058 0 3
// end ;
87283: GO 87181
87285: POP
87286: POP
// if enchidnas then
87287: LD_VAR 0 4
87291: IFFALSE 87358
// for i = 1 to enchidnas do
87293: LD_ADDR_VAR 0 11
87297: PUSH
87298: DOUBLE
87299: LD_INT 1
87301: DEC
87302: ST_TO_ADDR
87303: LD_VAR 0 4
87307: PUSH
87308: FOR_TO
87309: IFFALSE 87356
// begin hc_class = 13 ;
87311: LD_ADDR_OWVAR 28
87315: PUSH
87316: LD_INT 13
87318: ST_TO_ADDR
// hc_gallery =  ;
87319: LD_ADDR_OWVAR 33
87323: PUSH
87324: LD_STRING 
87326: ST_TO_ADDR
// animal := CreateHuman ;
87327: LD_ADDR_VAR 0 12
87331: PUSH
87332: CALL_OW 44
87336: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87337: LD_VAR 0 12
87341: PPUSH
87342: LD_VAR 0 8
87346: PPUSH
87347: LD_INT 0
87349: PPUSH
87350: CALL 89058 0 3
// end ;
87354: GO 87308
87356: POP
87357: POP
// if fishes then
87358: LD_VAR 0 7
87362: IFFALSE 87429
// for i = 1 to fishes do
87364: LD_ADDR_VAR 0 11
87368: PUSH
87369: DOUBLE
87370: LD_INT 1
87372: DEC
87373: ST_TO_ADDR
87374: LD_VAR 0 7
87378: PUSH
87379: FOR_TO
87380: IFFALSE 87427
// begin hc_class = 20 ;
87382: LD_ADDR_OWVAR 28
87386: PUSH
87387: LD_INT 20
87389: ST_TO_ADDR
// hc_gallery =  ;
87390: LD_ADDR_OWVAR 33
87394: PUSH
87395: LD_STRING 
87397: ST_TO_ADDR
// animal := CreateHuman ;
87398: LD_ADDR_VAR 0 12
87402: PUSH
87403: CALL_OW 44
87407: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
87408: LD_VAR 0 12
87412: PPUSH
87413: LD_VAR 0 9
87417: PPUSH
87418: LD_INT 0
87420: PPUSH
87421: CALL 89058 0 3
// end ;
87425: GO 87379
87427: POP
87428: POP
// end ;
87429: LD_VAR 0 10
87433: RET
// export function WantHeal ( sci , unit ) ; begin
87434: LD_INT 0
87436: PPUSH
// if GetTaskList ( sci ) > 0 then
87437: LD_VAR 0 1
87441: PPUSH
87442: CALL_OW 437
87446: PUSH
87447: LD_INT 0
87449: GREATER
87450: IFFALSE 87520
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
87452: LD_VAR 0 1
87456: PPUSH
87457: CALL_OW 437
87461: PUSH
87462: LD_INT 1
87464: ARRAY
87465: PUSH
87466: LD_INT 1
87468: ARRAY
87469: PUSH
87470: LD_STRING l
87472: EQUAL
87473: PUSH
87474: LD_VAR 0 1
87478: PPUSH
87479: CALL_OW 437
87483: PUSH
87484: LD_INT 1
87486: ARRAY
87487: PUSH
87488: LD_INT 4
87490: ARRAY
87491: PUSH
87492: LD_VAR 0 2
87496: EQUAL
87497: AND
87498: IFFALSE 87510
// result := true else
87500: LD_ADDR_VAR 0 3
87504: PUSH
87505: LD_INT 1
87507: ST_TO_ADDR
87508: GO 87518
// result := false ;
87510: LD_ADDR_VAR 0 3
87514: PUSH
87515: LD_INT 0
87517: ST_TO_ADDR
// end else
87518: GO 87528
// result := false ;
87520: LD_ADDR_VAR 0 3
87524: PUSH
87525: LD_INT 0
87527: ST_TO_ADDR
// end ;
87528: LD_VAR 0 3
87532: RET
// export function HealTarget ( sci ) ; begin
87533: LD_INT 0
87535: PPUSH
// if not sci then
87536: LD_VAR 0 1
87540: NOT
87541: IFFALSE 87545
// exit ;
87543: GO 87610
// result := 0 ;
87545: LD_ADDR_VAR 0 2
87549: PUSH
87550: LD_INT 0
87552: ST_TO_ADDR
// if GetTaskList ( sci ) then
87553: LD_VAR 0 1
87557: PPUSH
87558: CALL_OW 437
87562: IFFALSE 87610
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
87564: LD_VAR 0 1
87568: PPUSH
87569: CALL_OW 437
87573: PUSH
87574: LD_INT 1
87576: ARRAY
87577: PUSH
87578: LD_INT 1
87580: ARRAY
87581: PUSH
87582: LD_STRING l
87584: EQUAL
87585: IFFALSE 87610
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
87587: LD_ADDR_VAR 0 2
87591: PUSH
87592: LD_VAR 0 1
87596: PPUSH
87597: CALL_OW 437
87601: PUSH
87602: LD_INT 1
87604: ARRAY
87605: PUSH
87606: LD_INT 4
87608: ARRAY
87609: ST_TO_ADDR
// end ;
87610: LD_VAR 0 2
87614: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
87615: LD_INT 0
87617: PPUSH
87618: PPUSH
87619: PPUSH
87620: PPUSH
// if not base_units then
87621: LD_VAR 0 1
87625: NOT
87626: IFFALSE 87630
// exit ;
87628: GO 87717
// result := false ;
87630: LD_ADDR_VAR 0 2
87634: PUSH
87635: LD_INT 0
87637: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87638: LD_ADDR_VAR 0 5
87642: PUSH
87643: LD_VAR 0 1
87647: PPUSH
87648: LD_INT 21
87650: PUSH
87651: LD_INT 3
87653: PUSH
87654: EMPTY
87655: LIST
87656: LIST
87657: PPUSH
87658: CALL_OW 72
87662: ST_TO_ADDR
// if not tmp then
87663: LD_VAR 0 5
87667: NOT
87668: IFFALSE 87672
// exit ;
87670: GO 87717
// for i in tmp do
87672: LD_ADDR_VAR 0 3
87676: PUSH
87677: LD_VAR 0 5
87681: PUSH
87682: FOR_IN
87683: IFFALSE 87715
// begin result := EnemyInRange ( i , 22 ) ;
87685: LD_ADDR_VAR 0 2
87689: PUSH
87690: LD_VAR 0 3
87694: PPUSH
87695: LD_INT 22
87697: PPUSH
87698: CALL 85304 0 2
87702: ST_TO_ADDR
// if result then
87703: LD_VAR 0 2
87707: IFFALSE 87713
// exit ;
87709: POP
87710: POP
87711: GO 87717
// end ;
87713: GO 87682
87715: POP
87716: POP
// end ;
87717: LD_VAR 0 2
87721: RET
// export function FilterByTag ( units , tag ) ; begin
87722: LD_INT 0
87724: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
87725: LD_ADDR_VAR 0 3
87729: PUSH
87730: LD_VAR 0 1
87734: PPUSH
87735: LD_INT 120
87737: PUSH
87738: LD_VAR 0 2
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PPUSH
87747: CALL_OW 72
87751: ST_TO_ADDR
// end ;
87752: LD_VAR 0 3
87756: RET
// export function IsDriver ( un ) ; begin
87757: LD_INT 0
87759: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87760: LD_ADDR_VAR 0 2
87764: PUSH
87765: LD_VAR 0 1
87769: PUSH
87770: LD_INT 55
87772: PUSH
87773: EMPTY
87774: LIST
87775: PPUSH
87776: CALL_OW 69
87780: IN
87781: ST_TO_ADDR
// end ;
87782: LD_VAR 0 2
87786: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87787: LD_INT 0
87789: PPUSH
87790: PPUSH
// list := [ ] ;
87791: LD_ADDR_VAR 0 5
87795: PUSH
87796: EMPTY
87797: ST_TO_ADDR
// case d of 0 :
87798: LD_VAR 0 3
87802: PUSH
87803: LD_INT 0
87805: DOUBLE
87806: EQUAL
87807: IFTRUE 87811
87809: GO 87944
87811: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87812: LD_ADDR_VAR 0 5
87816: PUSH
87817: LD_VAR 0 1
87821: PUSH
87822: LD_INT 4
87824: MINUS
87825: PUSH
87826: LD_VAR 0 2
87830: PUSH
87831: LD_INT 4
87833: MINUS
87834: PUSH
87835: LD_INT 2
87837: PUSH
87838: EMPTY
87839: LIST
87840: LIST
87841: LIST
87842: PUSH
87843: LD_VAR 0 1
87847: PUSH
87848: LD_INT 3
87850: MINUS
87851: PUSH
87852: LD_VAR 0 2
87856: PUSH
87857: LD_INT 1
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: LIST
87864: PUSH
87865: LD_VAR 0 1
87869: PUSH
87870: LD_INT 4
87872: PLUS
87873: PUSH
87874: LD_VAR 0 2
87878: PUSH
87879: LD_INT 4
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: LIST
87886: PUSH
87887: LD_VAR 0 1
87891: PUSH
87892: LD_INT 3
87894: PLUS
87895: PUSH
87896: LD_VAR 0 2
87900: PUSH
87901: LD_INT 3
87903: PLUS
87904: PUSH
87905: LD_INT 5
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: LIST
87912: PUSH
87913: LD_VAR 0 1
87917: PUSH
87918: LD_VAR 0 2
87922: PUSH
87923: LD_INT 4
87925: PLUS
87926: PUSH
87927: LD_INT 0
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: LIST
87934: PUSH
87935: EMPTY
87936: LIST
87937: LIST
87938: LIST
87939: LIST
87940: LIST
87941: ST_TO_ADDR
// end ; 1 :
87942: GO 88642
87944: LD_INT 1
87946: DOUBLE
87947: EQUAL
87948: IFTRUE 87952
87950: GO 88085
87952: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87953: LD_ADDR_VAR 0 5
87957: PUSH
87958: LD_VAR 0 1
87962: PUSH
87963: LD_VAR 0 2
87967: PUSH
87968: LD_INT 4
87970: MINUS
87971: PUSH
87972: LD_INT 3
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: LIST
87979: PUSH
87980: LD_VAR 0 1
87984: PUSH
87985: LD_INT 3
87987: MINUS
87988: PUSH
87989: LD_VAR 0 2
87993: PUSH
87994: LD_INT 3
87996: MINUS
87997: PUSH
87998: LD_INT 2
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: LIST
88005: PUSH
88006: LD_VAR 0 1
88010: PUSH
88011: LD_INT 4
88013: MINUS
88014: PUSH
88015: LD_VAR 0 2
88019: PUSH
88020: LD_INT 1
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: LIST
88027: PUSH
88028: LD_VAR 0 1
88032: PUSH
88033: LD_VAR 0 2
88037: PUSH
88038: LD_INT 3
88040: PLUS
88041: PUSH
88042: LD_INT 0
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: LIST
88049: PUSH
88050: LD_VAR 0 1
88054: PUSH
88055: LD_INT 4
88057: PLUS
88058: PUSH
88059: LD_VAR 0 2
88063: PUSH
88064: LD_INT 4
88066: PLUS
88067: PUSH
88068: LD_INT 5
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: LIST
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: ST_TO_ADDR
// end ; 2 :
88083: GO 88642
88085: LD_INT 2
88087: DOUBLE
88088: EQUAL
88089: IFTRUE 88093
88091: GO 88222
88093: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88094: LD_ADDR_VAR 0 5
88098: PUSH
88099: LD_VAR 0 1
88103: PUSH
88104: LD_VAR 0 2
88108: PUSH
88109: LD_INT 3
88111: MINUS
88112: PUSH
88113: LD_INT 3
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: LIST
88120: PUSH
88121: LD_VAR 0 1
88125: PUSH
88126: LD_INT 4
88128: PLUS
88129: PUSH
88130: LD_VAR 0 2
88134: PUSH
88135: LD_INT 4
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: LIST
88142: PUSH
88143: LD_VAR 0 1
88147: PUSH
88148: LD_VAR 0 2
88152: PUSH
88153: LD_INT 4
88155: PLUS
88156: PUSH
88157: LD_INT 0
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: LIST
88164: PUSH
88165: LD_VAR 0 1
88169: PUSH
88170: LD_INT 3
88172: MINUS
88173: PUSH
88174: LD_VAR 0 2
88178: PUSH
88179: LD_INT 1
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: LIST
88186: PUSH
88187: LD_VAR 0 1
88191: PUSH
88192: LD_INT 4
88194: MINUS
88195: PUSH
88196: LD_VAR 0 2
88200: PUSH
88201: LD_INT 4
88203: MINUS
88204: PUSH
88205: LD_INT 2
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: LIST
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: ST_TO_ADDR
// end ; 3 :
88220: GO 88642
88222: LD_INT 3
88224: DOUBLE
88225: EQUAL
88226: IFTRUE 88230
88228: GO 88363
88230: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
88231: LD_ADDR_VAR 0 5
88235: PUSH
88236: LD_VAR 0 1
88240: PUSH
88241: LD_INT 3
88243: PLUS
88244: PUSH
88245: LD_VAR 0 2
88249: PUSH
88250: LD_INT 4
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: LIST
88257: PUSH
88258: LD_VAR 0 1
88262: PUSH
88263: LD_INT 4
88265: PLUS
88266: PUSH
88267: LD_VAR 0 2
88271: PUSH
88272: LD_INT 4
88274: PLUS
88275: PUSH
88276: LD_INT 5
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: LIST
88283: PUSH
88284: LD_VAR 0 1
88288: PUSH
88289: LD_INT 4
88291: MINUS
88292: PUSH
88293: LD_VAR 0 2
88297: PUSH
88298: LD_INT 1
88300: PUSH
88301: EMPTY
88302: LIST
88303: LIST
88304: LIST
88305: PUSH
88306: LD_VAR 0 1
88310: PUSH
88311: LD_VAR 0 2
88315: PUSH
88316: LD_INT 4
88318: MINUS
88319: PUSH
88320: LD_INT 3
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: LIST
88327: PUSH
88328: LD_VAR 0 1
88332: PUSH
88333: LD_INT 3
88335: MINUS
88336: PUSH
88337: LD_VAR 0 2
88341: PUSH
88342: LD_INT 3
88344: MINUS
88345: PUSH
88346: LD_INT 2
88348: PUSH
88349: EMPTY
88350: LIST
88351: LIST
88352: LIST
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: LIST
88358: LIST
88359: LIST
88360: ST_TO_ADDR
// end ; 4 :
88361: GO 88642
88363: LD_INT 4
88365: DOUBLE
88366: EQUAL
88367: IFTRUE 88371
88369: GO 88504
88371: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88372: LD_ADDR_VAR 0 5
88376: PUSH
88377: LD_VAR 0 1
88381: PUSH
88382: LD_VAR 0 2
88386: PUSH
88387: LD_INT 4
88389: PLUS
88390: PUSH
88391: LD_INT 0
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: LIST
88398: PUSH
88399: LD_VAR 0 1
88403: PUSH
88404: LD_INT 3
88406: PLUS
88407: PUSH
88408: LD_VAR 0 2
88412: PUSH
88413: LD_INT 3
88415: PLUS
88416: PUSH
88417: LD_INT 5
88419: PUSH
88420: EMPTY
88421: LIST
88422: LIST
88423: LIST
88424: PUSH
88425: LD_VAR 0 1
88429: PUSH
88430: LD_INT 4
88432: PLUS
88433: PUSH
88434: LD_VAR 0 2
88438: PUSH
88439: LD_INT 4
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: LIST
88446: PUSH
88447: LD_VAR 0 1
88451: PUSH
88452: LD_VAR 0 2
88456: PUSH
88457: LD_INT 3
88459: MINUS
88460: PUSH
88461: LD_INT 3
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: LIST
88468: PUSH
88469: LD_VAR 0 1
88473: PUSH
88474: LD_INT 4
88476: MINUS
88477: PUSH
88478: LD_VAR 0 2
88482: PUSH
88483: LD_INT 4
88485: MINUS
88486: PUSH
88487: LD_INT 2
88489: PUSH
88490: EMPTY
88491: LIST
88492: LIST
88493: LIST
88494: PUSH
88495: EMPTY
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: ST_TO_ADDR
// end ; 5 :
88502: GO 88642
88504: LD_INT 5
88506: DOUBLE
88507: EQUAL
88508: IFTRUE 88512
88510: GO 88641
88512: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88513: LD_ADDR_VAR 0 5
88517: PUSH
88518: LD_VAR 0 1
88522: PUSH
88523: LD_INT 4
88525: MINUS
88526: PUSH
88527: LD_VAR 0 2
88531: PUSH
88532: LD_INT 1
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: LIST
88539: PUSH
88540: LD_VAR 0 1
88544: PUSH
88545: LD_VAR 0 2
88549: PUSH
88550: LD_INT 4
88552: MINUS
88553: PUSH
88554: LD_INT 3
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: LIST
88561: PUSH
88562: LD_VAR 0 1
88566: PUSH
88567: LD_INT 4
88569: PLUS
88570: PUSH
88571: LD_VAR 0 2
88575: PUSH
88576: LD_INT 4
88578: PLUS
88579: PUSH
88580: LD_INT 5
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: LIST
88587: PUSH
88588: LD_VAR 0 1
88592: PUSH
88593: LD_INT 3
88595: PLUS
88596: PUSH
88597: LD_VAR 0 2
88601: PUSH
88602: LD_INT 4
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: LIST
88609: PUSH
88610: LD_VAR 0 1
88614: PUSH
88615: LD_VAR 0 2
88619: PUSH
88620: LD_INT 3
88622: PLUS
88623: PUSH
88624: LD_INT 0
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: LIST
88631: PUSH
88632: EMPTY
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: ST_TO_ADDR
// end ; end ;
88639: GO 88642
88641: POP
// result := list ;
88642: LD_ADDR_VAR 0 4
88646: PUSH
88647: LD_VAR 0 5
88651: ST_TO_ADDR
// end ;
88652: LD_VAR 0 4
88656: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88657: LD_INT 0
88659: PPUSH
88660: PPUSH
88661: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88662: LD_VAR 0 1
88666: NOT
88667: PUSH
88668: LD_VAR 0 2
88672: PUSH
88673: LD_INT 1
88675: PUSH
88676: LD_INT 2
88678: PUSH
88679: LD_INT 3
88681: PUSH
88682: LD_INT 4
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: IN
88691: NOT
88692: OR
88693: IFFALSE 88697
// exit ;
88695: GO 88780
// tmp := [ ] ;
88697: LD_ADDR_VAR 0 5
88701: PUSH
88702: EMPTY
88703: ST_TO_ADDR
// for i in units do
88704: LD_ADDR_VAR 0 4
88708: PUSH
88709: LD_VAR 0 1
88713: PUSH
88714: FOR_IN
88715: IFFALSE 88749
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
88717: LD_ADDR_VAR 0 5
88721: PUSH
88722: LD_VAR 0 5
88726: PPUSH
88727: LD_VAR 0 4
88731: PPUSH
88732: LD_VAR 0 2
88736: PPUSH
88737: CALL_OW 259
88741: PPUSH
88742: CALL 90140 0 2
88746: ST_TO_ADDR
88747: GO 88714
88749: POP
88750: POP
// if not tmp then
88751: LD_VAR 0 5
88755: NOT
88756: IFFALSE 88760
// exit ;
88758: GO 88780
// result := SortListByListDesc ( units , tmp ) ;
88760: LD_ADDR_VAR 0 3
88764: PUSH
88765: LD_VAR 0 1
88769: PPUSH
88770: LD_VAR 0 5
88774: PPUSH
88775: CALL_OW 77
88779: ST_TO_ADDR
// end ;
88780: LD_VAR 0 3
88784: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88785: LD_INT 0
88787: PPUSH
88788: PPUSH
88789: PPUSH
// result := false ;
88790: LD_ADDR_VAR 0 3
88794: PUSH
88795: LD_INT 0
88797: ST_TO_ADDR
// if not building then
88798: LD_VAR 0 2
88802: NOT
88803: IFFALSE 88807
// exit ;
88805: GO 88945
// x := GetX ( building ) ;
88807: LD_ADDR_VAR 0 4
88811: PUSH
88812: LD_VAR 0 2
88816: PPUSH
88817: CALL_OW 250
88821: ST_TO_ADDR
// y := GetY ( building ) ;
88822: LD_ADDR_VAR 0 5
88826: PUSH
88827: LD_VAR 0 2
88831: PPUSH
88832: CALL_OW 251
88836: ST_TO_ADDR
// if not x or not y then
88837: LD_VAR 0 4
88841: NOT
88842: PUSH
88843: LD_VAR 0 5
88847: NOT
88848: OR
88849: IFFALSE 88853
// exit ;
88851: GO 88945
// if GetTaskList ( unit ) then
88853: LD_VAR 0 1
88857: PPUSH
88858: CALL_OW 437
88862: IFFALSE 88945
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88864: LD_STRING e
88866: PUSH
88867: LD_VAR 0 1
88871: PPUSH
88872: CALL_OW 437
88876: PUSH
88877: LD_INT 1
88879: ARRAY
88880: PUSH
88881: LD_INT 1
88883: ARRAY
88884: EQUAL
88885: PUSH
88886: LD_VAR 0 4
88890: PUSH
88891: LD_VAR 0 1
88895: PPUSH
88896: CALL_OW 437
88900: PUSH
88901: LD_INT 1
88903: ARRAY
88904: PUSH
88905: LD_INT 2
88907: ARRAY
88908: EQUAL
88909: AND
88910: PUSH
88911: LD_VAR 0 5
88915: PUSH
88916: LD_VAR 0 1
88920: PPUSH
88921: CALL_OW 437
88925: PUSH
88926: LD_INT 1
88928: ARRAY
88929: PUSH
88930: LD_INT 3
88932: ARRAY
88933: EQUAL
88934: AND
88935: IFFALSE 88945
// result := true end ;
88937: LD_ADDR_VAR 0 3
88941: PUSH
88942: LD_INT 1
88944: ST_TO_ADDR
// end ;
88945: LD_VAR 0 3
88949: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
88950: LD_INT 0
88952: PPUSH
// result := false ;
88953: LD_ADDR_VAR 0 4
88957: PUSH
88958: LD_INT 0
88960: ST_TO_ADDR
// if GetTaskList ( unit ) then
88961: LD_VAR 0 1
88965: PPUSH
88966: CALL_OW 437
88970: IFFALSE 89053
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88972: LD_STRING M
88974: PUSH
88975: LD_VAR 0 1
88979: PPUSH
88980: CALL_OW 437
88984: PUSH
88985: LD_INT 1
88987: ARRAY
88988: PUSH
88989: LD_INT 1
88991: ARRAY
88992: EQUAL
88993: PUSH
88994: LD_VAR 0 2
88998: PUSH
88999: LD_VAR 0 1
89003: PPUSH
89004: CALL_OW 437
89008: PUSH
89009: LD_INT 1
89011: ARRAY
89012: PUSH
89013: LD_INT 2
89015: ARRAY
89016: EQUAL
89017: AND
89018: PUSH
89019: LD_VAR 0 3
89023: PUSH
89024: LD_VAR 0 1
89028: PPUSH
89029: CALL_OW 437
89033: PUSH
89034: LD_INT 1
89036: ARRAY
89037: PUSH
89038: LD_INT 3
89040: ARRAY
89041: EQUAL
89042: AND
89043: IFFALSE 89053
// result := true ;
89045: LD_ADDR_VAR 0 4
89049: PUSH
89050: LD_INT 1
89052: ST_TO_ADDR
// end ; end ;
89053: LD_VAR 0 4
89057: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89058: LD_INT 0
89060: PPUSH
89061: PPUSH
89062: PPUSH
89063: PPUSH
// if not unit or not area then
89064: LD_VAR 0 1
89068: NOT
89069: PUSH
89070: LD_VAR 0 2
89074: NOT
89075: OR
89076: IFFALSE 89080
// exit ;
89078: GO 89243
// tmp := AreaToList ( area , i ) ;
89080: LD_ADDR_VAR 0 6
89084: PUSH
89085: LD_VAR 0 2
89089: PPUSH
89090: LD_VAR 0 5
89094: PPUSH
89095: CALL_OW 517
89099: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89100: LD_ADDR_VAR 0 5
89104: PUSH
89105: DOUBLE
89106: LD_INT 1
89108: DEC
89109: ST_TO_ADDR
89110: LD_VAR 0 6
89114: PUSH
89115: LD_INT 1
89117: ARRAY
89118: PUSH
89119: FOR_TO
89120: IFFALSE 89241
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89122: LD_ADDR_VAR 0 7
89126: PUSH
89127: LD_VAR 0 6
89131: PUSH
89132: LD_INT 1
89134: ARRAY
89135: PUSH
89136: LD_VAR 0 5
89140: ARRAY
89141: PUSH
89142: LD_VAR 0 6
89146: PUSH
89147: LD_INT 2
89149: ARRAY
89150: PUSH
89151: LD_VAR 0 5
89155: ARRAY
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
89161: LD_INT 92
89163: PUSH
89164: LD_VAR 0 7
89168: PUSH
89169: LD_INT 1
89171: ARRAY
89172: PUSH
89173: LD_VAR 0 7
89177: PUSH
89178: LD_INT 2
89180: ARRAY
89181: PUSH
89182: LD_INT 3
89184: PUSH
89185: EMPTY
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: PPUSH
89191: CALL_OW 69
89195: PUSH
89196: LD_INT 0
89198: EQUAL
89199: IFFALSE 89239
// begin PlaceUnitArea ( unit , area , mode ) ;
89201: LD_VAR 0 1
89205: PPUSH
89206: LD_VAR 0 2
89210: PPUSH
89211: LD_VAR 0 3
89215: PPUSH
89216: CALL_OW 49
// result := IsPlaced ( unit ) ;
89220: LD_ADDR_VAR 0 4
89224: PUSH
89225: LD_VAR 0 1
89229: PPUSH
89230: CALL_OW 305
89234: ST_TO_ADDR
// exit ;
89235: POP
89236: POP
89237: GO 89243
// end ; end ;
89239: GO 89119
89241: POP
89242: POP
// end ;
89243: LD_VAR 0 4
89247: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
89248: LD_INT 0
89250: PPUSH
89251: PPUSH
89252: PPUSH
// if not side or side > 8 then
89253: LD_VAR 0 1
89257: NOT
89258: PUSH
89259: LD_VAR 0 1
89263: PUSH
89264: LD_INT 8
89266: GREATER
89267: OR
89268: IFFALSE 89272
// exit ;
89270: GO 89459
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
89272: LD_ADDR_VAR 0 4
89276: PUSH
89277: LD_INT 22
89279: PUSH
89280: LD_VAR 0 1
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 21
89291: PUSH
89292: LD_INT 3
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PPUSH
89303: CALL_OW 69
89307: ST_TO_ADDR
// if not tmp then
89308: LD_VAR 0 4
89312: NOT
89313: IFFALSE 89317
// exit ;
89315: GO 89459
// enable_addtolog := true ;
89317: LD_ADDR_OWVAR 81
89321: PUSH
89322: LD_INT 1
89324: ST_TO_ADDR
// AddToLog ( [ ) ;
89325: LD_STRING [
89327: PPUSH
89328: CALL_OW 561
// for i in tmp do
89332: LD_ADDR_VAR 0 3
89336: PUSH
89337: LD_VAR 0 4
89341: PUSH
89342: FOR_IN
89343: IFFALSE 89450
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
89345: LD_STRING [
89347: PUSH
89348: LD_VAR 0 3
89352: PPUSH
89353: CALL_OW 266
89357: STR
89358: PUSH
89359: LD_STRING , 
89361: STR
89362: PUSH
89363: LD_VAR 0 3
89367: PPUSH
89368: CALL_OW 250
89372: STR
89373: PUSH
89374: LD_STRING , 
89376: STR
89377: PUSH
89378: LD_VAR 0 3
89382: PPUSH
89383: CALL_OW 251
89387: STR
89388: PUSH
89389: LD_STRING , 
89391: STR
89392: PUSH
89393: LD_VAR 0 3
89397: PPUSH
89398: CALL_OW 254
89402: STR
89403: PUSH
89404: LD_STRING , 
89406: STR
89407: PUSH
89408: LD_VAR 0 3
89412: PPUSH
89413: LD_INT 1
89415: PPUSH
89416: CALL_OW 268
89420: STR
89421: PUSH
89422: LD_STRING , 
89424: STR
89425: PUSH
89426: LD_VAR 0 3
89430: PPUSH
89431: LD_INT 2
89433: PPUSH
89434: CALL_OW 268
89438: STR
89439: PUSH
89440: LD_STRING ],
89442: STR
89443: PPUSH
89444: CALL_OW 561
// end ;
89448: GO 89342
89450: POP
89451: POP
// AddToLog ( ]; ) ;
89452: LD_STRING ];
89454: PPUSH
89455: CALL_OW 561
// end ;
89459: LD_VAR 0 2
89463: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89464: LD_INT 0
89466: PPUSH
89467: PPUSH
89468: PPUSH
89469: PPUSH
89470: PPUSH
// if not area or not rate or not max then
89471: LD_VAR 0 1
89475: NOT
89476: PUSH
89477: LD_VAR 0 2
89481: NOT
89482: OR
89483: PUSH
89484: LD_VAR 0 4
89488: NOT
89489: OR
89490: IFFALSE 89494
// exit ;
89492: GO 89683
// while 1 do
89494: LD_INT 1
89496: IFFALSE 89683
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89498: LD_ADDR_VAR 0 9
89502: PUSH
89503: LD_VAR 0 1
89507: PPUSH
89508: LD_INT 1
89510: PPUSH
89511: CALL_OW 287
89515: PUSH
89516: LD_INT 10
89518: MUL
89519: ST_TO_ADDR
// r := rate / 10 ;
89520: LD_ADDR_VAR 0 7
89524: PUSH
89525: LD_VAR 0 2
89529: PUSH
89530: LD_INT 10
89532: DIVREAL
89533: ST_TO_ADDR
// time := 1 1$00 ;
89534: LD_ADDR_VAR 0 8
89538: PUSH
89539: LD_INT 2100
89541: ST_TO_ADDR
// if amount < min then
89542: LD_VAR 0 9
89546: PUSH
89547: LD_VAR 0 3
89551: LESS
89552: IFFALSE 89570
// r := r * 2 else
89554: LD_ADDR_VAR 0 7
89558: PUSH
89559: LD_VAR 0 7
89563: PUSH
89564: LD_INT 2
89566: MUL
89567: ST_TO_ADDR
89568: GO 89596
// if amount > max then
89570: LD_VAR 0 9
89574: PUSH
89575: LD_VAR 0 4
89579: GREATER
89580: IFFALSE 89596
// r := r / 2 ;
89582: LD_ADDR_VAR 0 7
89586: PUSH
89587: LD_VAR 0 7
89591: PUSH
89592: LD_INT 2
89594: DIVREAL
89595: ST_TO_ADDR
// time := time / r ;
89596: LD_ADDR_VAR 0 8
89600: PUSH
89601: LD_VAR 0 8
89605: PUSH
89606: LD_VAR 0 7
89610: DIVREAL
89611: ST_TO_ADDR
// if time < 0 then
89612: LD_VAR 0 8
89616: PUSH
89617: LD_INT 0
89619: LESS
89620: IFFALSE 89637
// time := time * - 1 ;
89622: LD_ADDR_VAR 0 8
89626: PUSH
89627: LD_VAR 0 8
89631: PUSH
89632: LD_INT 1
89634: NEG
89635: MUL
89636: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
89637: LD_VAR 0 8
89641: PUSH
89642: LD_INT 35
89644: PPUSH
89645: LD_INT 875
89647: PPUSH
89648: CALL_OW 12
89652: PLUS
89653: PPUSH
89654: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89658: LD_INT 1
89660: PPUSH
89661: LD_INT 5
89663: PPUSH
89664: CALL_OW 12
89668: PPUSH
89669: LD_VAR 0 1
89673: PPUSH
89674: LD_INT 1
89676: PPUSH
89677: CALL_OW 55
// end ;
89681: GO 89494
// end ;
89683: LD_VAR 0 5
89687: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89688: LD_INT 0
89690: PPUSH
89691: PPUSH
89692: PPUSH
89693: PPUSH
89694: PPUSH
89695: PPUSH
89696: PPUSH
89697: PPUSH
// if not turrets or not factories then
89698: LD_VAR 0 1
89702: NOT
89703: PUSH
89704: LD_VAR 0 2
89708: NOT
89709: OR
89710: IFFALSE 89714
// exit ;
89712: GO 90021
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89714: LD_ADDR_VAR 0 10
89718: PUSH
89719: LD_INT 5
89721: PUSH
89722: LD_INT 6
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 2
89731: PUSH
89732: LD_INT 4
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 3
89741: PUSH
89742: LD_INT 5
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: LIST
89753: PUSH
89754: LD_INT 24
89756: PUSH
89757: LD_INT 25
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: LD_INT 23
89766: PUSH
89767: LD_INT 27
89769: PUSH
89770: EMPTY
89771: LIST
89772: LIST
89773: PUSH
89774: EMPTY
89775: LIST
89776: LIST
89777: PUSH
89778: LD_INT 42
89780: PUSH
89781: LD_INT 43
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: PUSH
89788: LD_INT 44
89790: PUSH
89791: LD_INT 46
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: PUSH
89798: LD_INT 45
89800: PUSH
89801: LD_INT 47
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: LIST
89812: PUSH
89813: EMPTY
89814: LIST
89815: LIST
89816: LIST
89817: ST_TO_ADDR
// result := [ ] ;
89818: LD_ADDR_VAR 0 3
89822: PUSH
89823: EMPTY
89824: ST_TO_ADDR
// for i in turrets do
89825: LD_ADDR_VAR 0 4
89829: PUSH
89830: LD_VAR 0 1
89834: PUSH
89835: FOR_IN
89836: IFFALSE 90019
// begin nat := GetNation ( i ) ;
89838: LD_ADDR_VAR 0 7
89842: PUSH
89843: LD_VAR 0 4
89847: PPUSH
89848: CALL_OW 248
89852: ST_TO_ADDR
// weapon := 0 ;
89853: LD_ADDR_VAR 0 8
89857: PUSH
89858: LD_INT 0
89860: ST_TO_ADDR
// if not nat then
89861: LD_VAR 0 7
89865: NOT
89866: IFFALSE 89870
// continue ;
89868: GO 89835
// for j in list [ nat ] do
89870: LD_ADDR_VAR 0 5
89874: PUSH
89875: LD_VAR 0 10
89879: PUSH
89880: LD_VAR 0 7
89884: ARRAY
89885: PUSH
89886: FOR_IN
89887: IFFALSE 89928
// if GetBWeapon ( i ) = j [ 1 ] then
89889: LD_VAR 0 4
89893: PPUSH
89894: CALL_OW 269
89898: PUSH
89899: LD_VAR 0 5
89903: PUSH
89904: LD_INT 1
89906: ARRAY
89907: EQUAL
89908: IFFALSE 89926
// begin weapon := j [ 2 ] ;
89910: LD_ADDR_VAR 0 8
89914: PUSH
89915: LD_VAR 0 5
89919: PUSH
89920: LD_INT 2
89922: ARRAY
89923: ST_TO_ADDR
// break ;
89924: GO 89928
// end ;
89926: GO 89886
89928: POP
89929: POP
// if not weapon then
89930: LD_VAR 0 8
89934: NOT
89935: IFFALSE 89939
// continue ;
89937: GO 89835
// for k in factories do
89939: LD_ADDR_VAR 0 6
89943: PUSH
89944: LD_VAR 0 2
89948: PUSH
89949: FOR_IN
89950: IFFALSE 90015
// begin weapons := AvailableWeaponList ( k ) ;
89952: LD_ADDR_VAR 0 9
89956: PUSH
89957: LD_VAR 0 6
89961: PPUSH
89962: CALL_OW 478
89966: ST_TO_ADDR
// if not weapons then
89967: LD_VAR 0 9
89971: NOT
89972: IFFALSE 89976
// continue ;
89974: GO 89949
// if weapon in weapons then
89976: LD_VAR 0 8
89980: PUSH
89981: LD_VAR 0 9
89985: IN
89986: IFFALSE 90013
// begin result := [ i , weapon ] ;
89988: LD_ADDR_VAR 0 3
89992: PUSH
89993: LD_VAR 0 4
89997: PUSH
89998: LD_VAR 0 8
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: ST_TO_ADDR
// exit ;
90007: POP
90008: POP
90009: POP
90010: POP
90011: GO 90021
// end ; end ;
90013: GO 89949
90015: POP
90016: POP
// end ;
90017: GO 89835
90019: POP
90020: POP
// end ;
90021: LD_VAR 0 3
90025: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
90026: LD_INT 0
90028: PPUSH
// if not side or side > 8 then
90029: LD_VAR 0 3
90033: NOT
90034: PUSH
90035: LD_VAR 0 3
90039: PUSH
90040: LD_INT 8
90042: GREATER
90043: OR
90044: IFFALSE 90048
// exit ;
90046: GO 90107
// if not range then
90048: LD_VAR 0 4
90052: NOT
90053: IFFALSE 90064
// range := - 12 ;
90055: LD_ADDR_VAR 0 4
90059: PUSH
90060: LD_INT 12
90062: NEG
90063: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90064: LD_VAR 0 1
90068: PPUSH
90069: LD_VAR 0 2
90073: PPUSH
90074: LD_VAR 0 3
90078: PPUSH
90079: LD_VAR 0 4
90083: PPUSH
90084: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90088: LD_VAR 0 1
90092: PPUSH
90093: LD_VAR 0 2
90097: PPUSH
90098: LD_VAR 0 3
90102: PPUSH
90103: CALL_OW 331
// end ;
90107: LD_VAR 0 5
90111: RET
// export function Video ( mode ) ; begin
90112: LD_INT 0
90114: PPUSH
// ingame_video = mode ;
90115: LD_ADDR_OWVAR 52
90119: PUSH
90120: LD_VAR 0 1
90124: ST_TO_ADDR
// interface_hidden = mode ;
90125: LD_ADDR_OWVAR 54
90129: PUSH
90130: LD_VAR 0 1
90134: ST_TO_ADDR
// end ;
90135: LD_VAR 0 2
90139: RET
// export function Join ( array , element ) ; begin
90140: LD_INT 0
90142: PPUSH
// result := Replace ( array , array + 1 , element ) ;
90143: LD_ADDR_VAR 0 3
90147: PUSH
90148: LD_VAR 0 1
90152: PPUSH
90153: LD_VAR 0 1
90157: PUSH
90158: LD_INT 1
90160: PLUS
90161: PPUSH
90162: LD_VAR 0 2
90166: PPUSH
90167: CALL_OW 1
90171: ST_TO_ADDR
// end ;
90172: LD_VAR 0 3
90176: RET
// export function JoinUnion ( array , element ) ; begin
90177: LD_INT 0
90179: PPUSH
// result := array union element ;
90180: LD_ADDR_VAR 0 3
90184: PUSH
90185: LD_VAR 0 1
90189: PUSH
90190: LD_VAR 0 2
90194: UNION
90195: ST_TO_ADDR
// end ;
90196: LD_VAR 0 3
90200: RET
// export function GetBehemoths ( side ) ; begin
90201: LD_INT 0
90203: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
90204: LD_ADDR_VAR 0 2
90208: PUSH
90209: LD_INT 22
90211: PUSH
90212: LD_VAR 0 1
90216: PUSH
90217: EMPTY
90218: LIST
90219: LIST
90220: PUSH
90221: LD_INT 31
90223: PUSH
90224: LD_INT 25
90226: PUSH
90227: EMPTY
90228: LIST
90229: LIST
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PPUSH
90235: CALL_OW 69
90239: ST_TO_ADDR
// end ;
90240: LD_VAR 0 2
90244: RET
// export function Shuffle ( array ) ; var i , index ; begin
90245: LD_INT 0
90247: PPUSH
90248: PPUSH
90249: PPUSH
// result := [ ] ;
90250: LD_ADDR_VAR 0 2
90254: PUSH
90255: EMPTY
90256: ST_TO_ADDR
// if not array then
90257: LD_VAR 0 1
90261: NOT
90262: IFFALSE 90266
// exit ;
90264: GO 90365
// Randomize ;
90266: CALL_OW 10
// for i = array downto 1 do
90270: LD_ADDR_VAR 0 3
90274: PUSH
90275: DOUBLE
90276: LD_VAR 0 1
90280: INC
90281: ST_TO_ADDR
90282: LD_INT 1
90284: PUSH
90285: FOR_DOWNTO
90286: IFFALSE 90363
// begin index := rand ( 1 , array ) ;
90288: LD_ADDR_VAR 0 4
90292: PUSH
90293: LD_INT 1
90295: PPUSH
90296: LD_VAR 0 1
90300: PPUSH
90301: CALL_OW 12
90305: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
90306: LD_ADDR_VAR 0 2
90310: PUSH
90311: LD_VAR 0 2
90315: PPUSH
90316: LD_VAR 0 2
90320: PUSH
90321: LD_INT 1
90323: PLUS
90324: PPUSH
90325: LD_VAR 0 1
90329: PUSH
90330: LD_VAR 0 4
90334: ARRAY
90335: PPUSH
90336: CALL_OW 2
90340: ST_TO_ADDR
// array := Delete ( array , index ) ;
90341: LD_ADDR_VAR 0 1
90345: PUSH
90346: LD_VAR 0 1
90350: PPUSH
90351: LD_VAR 0 4
90355: PPUSH
90356: CALL_OW 3
90360: ST_TO_ADDR
// end ;
90361: GO 90285
90363: POP
90364: POP
// end ;
90365: LD_VAR 0 2
90369: RET
// export function GetBaseMaterials ( base ) ; begin
90370: LD_INT 0
90372: PPUSH
// result := [ 0 , 0 , 0 ] ;
90373: LD_ADDR_VAR 0 2
90377: PUSH
90378: LD_INT 0
90380: PUSH
90381: LD_INT 0
90383: PUSH
90384: LD_INT 0
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: LIST
90391: ST_TO_ADDR
// if not base then
90392: LD_VAR 0 1
90396: NOT
90397: IFFALSE 90401
// exit ;
90399: GO 90450
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
90401: LD_ADDR_VAR 0 2
90405: PUSH
90406: LD_VAR 0 1
90410: PPUSH
90411: LD_INT 1
90413: PPUSH
90414: CALL_OW 275
90418: PUSH
90419: LD_VAR 0 1
90423: PPUSH
90424: LD_INT 2
90426: PPUSH
90427: CALL_OW 275
90431: PUSH
90432: LD_VAR 0 1
90436: PPUSH
90437: LD_INT 3
90439: PPUSH
90440: CALL_OW 275
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: LIST
90449: ST_TO_ADDR
// end ;
90450: LD_VAR 0 2
90454: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
90455: LD_INT 0
90457: PPUSH
90458: PPUSH
// result := array ;
90459: LD_ADDR_VAR 0 3
90463: PUSH
90464: LD_VAR 0 1
90468: ST_TO_ADDR
// if size >= result then
90469: LD_VAR 0 2
90473: PUSH
90474: LD_VAR 0 3
90478: GREATEREQUAL
90479: IFFALSE 90483
// exit ;
90481: GO 90533
// if size then
90483: LD_VAR 0 2
90487: IFFALSE 90533
// for i := array downto size do
90489: LD_ADDR_VAR 0 4
90493: PUSH
90494: DOUBLE
90495: LD_VAR 0 1
90499: INC
90500: ST_TO_ADDR
90501: LD_VAR 0 2
90505: PUSH
90506: FOR_DOWNTO
90507: IFFALSE 90531
// result := Delete ( result , result ) ;
90509: LD_ADDR_VAR 0 3
90513: PUSH
90514: LD_VAR 0 3
90518: PPUSH
90519: LD_VAR 0 3
90523: PPUSH
90524: CALL_OW 3
90528: ST_TO_ADDR
90529: GO 90506
90531: POP
90532: POP
// end ;
90533: LD_VAR 0 3
90537: RET
// export function ComExit ( unit ) ; var tmp ; begin
90538: LD_INT 0
90540: PPUSH
90541: PPUSH
// if not IsInUnit ( unit ) then
90542: LD_VAR 0 1
90546: PPUSH
90547: CALL_OW 310
90551: NOT
90552: IFFALSE 90556
// exit ;
90554: GO 90616
// tmp := IsInUnit ( unit ) ;
90556: LD_ADDR_VAR 0 3
90560: PUSH
90561: LD_VAR 0 1
90565: PPUSH
90566: CALL_OW 310
90570: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
90571: LD_VAR 0 3
90575: PPUSH
90576: CALL_OW 247
90580: PUSH
90581: LD_INT 2
90583: EQUAL
90584: IFFALSE 90597
// ComExitVehicle ( unit ) else
90586: LD_VAR 0 1
90590: PPUSH
90591: CALL_OW 121
90595: GO 90606
// ComExitBuilding ( unit ) ;
90597: LD_VAR 0 1
90601: PPUSH
90602: CALL_OW 122
// result := tmp ;
90606: LD_ADDR_VAR 0 2
90610: PUSH
90611: LD_VAR 0 3
90615: ST_TO_ADDR
// end ;
90616: LD_VAR 0 2
90620: RET
// export function ComExitAll ( units ) ; var i ; begin
90621: LD_INT 0
90623: PPUSH
90624: PPUSH
// if not units then
90625: LD_VAR 0 1
90629: NOT
90630: IFFALSE 90634
// exit ;
90632: GO 90660
// for i in units do
90634: LD_ADDR_VAR 0 3
90638: PUSH
90639: LD_VAR 0 1
90643: PUSH
90644: FOR_IN
90645: IFFALSE 90658
// ComExit ( i ) ;
90647: LD_VAR 0 3
90651: PPUSH
90652: CALL 90538 0 1
90656: GO 90644
90658: POP
90659: POP
// end ;
90660: LD_VAR 0 2
90664: RET
// export function ResetHc ; begin
90665: LD_INT 0
90667: PPUSH
// InitHc ;
90668: CALL_OW 19
// hc_importance := 0 ;
90672: LD_ADDR_OWVAR 32
90676: PUSH
90677: LD_INT 0
90679: ST_TO_ADDR
// end ;
90680: LD_VAR 0 1
90684: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
90685: LD_INT 0
90687: PPUSH
90688: PPUSH
90689: PPUSH
// _x := ( x1 + x2 ) div 2 ;
90690: LD_ADDR_VAR 0 6
90694: PUSH
90695: LD_VAR 0 1
90699: PUSH
90700: LD_VAR 0 3
90704: PLUS
90705: PUSH
90706: LD_INT 2
90708: DIV
90709: ST_TO_ADDR
// if _x < 0 then
90710: LD_VAR 0 6
90714: PUSH
90715: LD_INT 0
90717: LESS
90718: IFFALSE 90735
// _x := _x * - 1 ;
90720: LD_ADDR_VAR 0 6
90724: PUSH
90725: LD_VAR 0 6
90729: PUSH
90730: LD_INT 1
90732: NEG
90733: MUL
90734: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
90735: LD_ADDR_VAR 0 7
90739: PUSH
90740: LD_VAR 0 2
90744: PUSH
90745: LD_VAR 0 4
90749: PLUS
90750: PUSH
90751: LD_INT 2
90753: DIV
90754: ST_TO_ADDR
// if _y < 0 then
90755: LD_VAR 0 7
90759: PUSH
90760: LD_INT 0
90762: LESS
90763: IFFALSE 90780
// _y := _y * - 1 ;
90765: LD_ADDR_VAR 0 7
90769: PUSH
90770: LD_VAR 0 7
90774: PUSH
90775: LD_INT 1
90777: NEG
90778: MUL
90779: ST_TO_ADDR
// result := [ _x , _y ] ;
90780: LD_ADDR_VAR 0 5
90784: PUSH
90785: LD_VAR 0 6
90789: PUSH
90790: LD_VAR 0 7
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: ST_TO_ADDR
// end ;
90799: LD_VAR 0 5
90803: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
90804: LD_INT 0
90806: PPUSH
90807: PPUSH
90808: PPUSH
90809: PPUSH
// task := GetTaskList ( unit ) ;
90810: LD_ADDR_VAR 0 7
90814: PUSH
90815: LD_VAR 0 1
90819: PPUSH
90820: CALL_OW 437
90824: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
90825: LD_VAR 0 7
90829: NOT
90830: PUSH
90831: LD_VAR 0 1
90835: PPUSH
90836: LD_VAR 0 2
90840: PPUSH
90841: CALL_OW 308
90845: NOT
90846: AND
90847: IFFALSE 90851
// exit ;
90849: GO 90969
// if IsInArea ( unit , area ) then
90851: LD_VAR 0 1
90855: PPUSH
90856: LD_VAR 0 2
90860: PPUSH
90861: CALL_OW 308
90865: IFFALSE 90883
// begin ComMoveToArea ( unit , goAway ) ;
90867: LD_VAR 0 1
90871: PPUSH
90872: LD_VAR 0 3
90876: PPUSH
90877: CALL_OW 113
// exit ;
90881: GO 90969
// end ; if task [ 1 ] [ 1 ] <> M then
90883: LD_VAR 0 7
90887: PUSH
90888: LD_INT 1
90890: ARRAY
90891: PUSH
90892: LD_INT 1
90894: ARRAY
90895: PUSH
90896: LD_STRING M
90898: NONEQUAL
90899: IFFALSE 90903
// exit ;
90901: GO 90969
// x := task [ 1 ] [ 2 ] ;
90903: LD_ADDR_VAR 0 5
90907: PUSH
90908: LD_VAR 0 7
90912: PUSH
90913: LD_INT 1
90915: ARRAY
90916: PUSH
90917: LD_INT 2
90919: ARRAY
90920: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
90921: LD_ADDR_VAR 0 6
90925: PUSH
90926: LD_VAR 0 7
90930: PUSH
90931: LD_INT 1
90933: ARRAY
90934: PUSH
90935: LD_INT 3
90937: ARRAY
90938: ST_TO_ADDR
// if InArea ( x , y , area ) then
90939: LD_VAR 0 5
90943: PPUSH
90944: LD_VAR 0 6
90948: PPUSH
90949: LD_VAR 0 2
90953: PPUSH
90954: CALL_OW 309
90958: IFFALSE 90969
// ComStop ( unit ) ;
90960: LD_VAR 0 1
90964: PPUSH
90965: CALL_OW 141
// end ;
90969: LD_VAR 0 4
90973: RET
// export function Abs ( value ) ; begin
90974: LD_INT 0
90976: PPUSH
// result := value ;
90977: LD_ADDR_VAR 0 2
90981: PUSH
90982: LD_VAR 0 1
90986: ST_TO_ADDR
// if value < 0 then
90987: LD_VAR 0 1
90991: PUSH
90992: LD_INT 0
90994: LESS
90995: IFFALSE 91012
// result := value * - 1 ;
90997: LD_ADDR_VAR 0 2
91001: PUSH
91002: LD_VAR 0 1
91006: PUSH
91007: LD_INT 1
91009: NEG
91010: MUL
91011: ST_TO_ADDR
// end ;
91012: LD_VAR 0 2
91016: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
91017: LD_INT 0
91019: PPUSH
91020: PPUSH
91021: PPUSH
91022: PPUSH
91023: PPUSH
91024: PPUSH
91025: PPUSH
91026: PPUSH
// if not unit or not building then
91027: LD_VAR 0 1
91031: NOT
91032: PUSH
91033: LD_VAR 0 2
91037: NOT
91038: OR
91039: IFFALSE 91043
// exit ;
91041: GO 91269
// x := GetX ( building ) ;
91043: LD_ADDR_VAR 0 4
91047: PUSH
91048: LD_VAR 0 2
91052: PPUSH
91053: CALL_OW 250
91057: ST_TO_ADDR
// y := GetY ( building ) ;
91058: LD_ADDR_VAR 0 6
91062: PUSH
91063: LD_VAR 0 2
91067: PPUSH
91068: CALL_OW 251
91072: ST_TO_ADDR
// d := GetDir ( building ) ;
91073: LD_ADDR_VAR 0 8
91077: PUSH
91078: LD_VAR 0 2
91082: PPUSH
91083: CALL_OW 254
91087: ST_TO_ADDR
// r := 4 ;
91088: LD_ADDR_VAR 0 9
91092: PUSH
91093: LD_INT 4
91095: ST_TO_ADDR
// for i := 1 to 5 do
91096: LD_ADDR_VAR 0 10
91100: PUSH
91101: DOUBLE
91102: LD_INT 1
91104: DEC
91105: ST_TO_ADDR
91106: LD_INT 5
91108: PUSH
91109: FOR_TO
91110: IFFALSE 91267
// begin _x := ShiftX ( x , d , r + i ) ;
91112: LD_ADDR_VAR 0 5
91116: PUSH
91117: LD_VAR 0 4
91121: PPUSH
91122: LD_VAR 0 8
91126: PPUSH
91127: LD_VAR 0 9
91131: PUSH
91132: LD_VAR 0 10
91136: PLUS
91137: PPUSH
91138: CALL_OW 272
91142: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
91143: LD_ADDR_VAR 0 7
91147: PUSH
91148: LD_VAR 0 6
91152: PPUSH
91153: LD_VAR 0 8
91157: PPUSH
91158: LD_VAR 0 9
91162: PUSH
91163: LD_VAR 0 10
91167: PLUS
91168: PPUSH
91169: CALL_OW 273
91173: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
91174: LD_VAR 0 5
91178: PPUSH
91179: LD_VAR 0 7
91183: PPUSH
91184: CALL_OW 488
91188: PUSH
91189: LD_VAR 0 5
91193: PPUSH
91194: LD_VAR 0 7
91198: PPUSH
91199: CALL_OW 428
91203: PPUSH
91204: CALL_OW 247
91208: PUSH
91209: LD_INT 3
91211: PUSH
91212: LD_INT 2
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: IN
91219: NOT
91220: AND
91221: IFFALSE 91265
// begin ComMoveXY ( unit , _x , _y ) ;
91223: LD_VAR 0 1
91227: PPUSH
91228: LD_VAR 0 5
91232: PPUSH
91233: LD_VAR 0 7
91237: PPUSH
91238: CALL_OW 111
// result := [ _x , _y ] ;
91242: LD_ADDR_VAR 0 3
91246: PUSH
91247: LD_VAR 0 5
91251: PUSH
91252: LD_VAR 0 7
91256: PUSH
91257: EMPTY
91258: LIST
91259: LIST
91260: ST_TO_ADDR
// exit ;
91261: POP
91262: POP
91263: GO 91269
// end ; end ;
91265: GO 91109
91267: POP
91268: POP
// end ;
91269: LD_VAR 0 3
91273: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
91274: LD_INT 0
91276: PPUSH
91277: PPUSH
91278: PPUSH
// result := 0 ;
91279: LD_ADDR_VAR 0 3
91283: PUSH
91284: LD_INT 0
91286: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
91287: LD_VAR 0 1
91291: PUSH
91292: LD_INT 0
91294: LESS
91295: PUSH
91296: LD_VAR 0 1
91300: PUSH
91301: LD_INT 8
91303: GREATER
91304: OR
91305: PUSH
91306: LD_VAR 0 2
91310: PUSH
91311: LD_INT 0
91313: LESS
91314: OR
91315: PUSH
91316: LD_VAR 0 2
91320: PUSH
91321: LD_INT 8
91323: GREATER
91324: OR
91325: IFFALSE 91329
// exit ;
91327: GO 91404
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
91329: LD_ADDR_VAR 0 4
91333: PUSH
91334: LD_INT 22
91336: PUSH
91337: LD_VAR 0 2
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PPUSH
91346: CALL_OW 69
91350: PUSH
91351: FOR_IN
91352: IFFALSE 91402
// begin un := UnitShoot ( i ) ;
91354: LD_ADDR_VAR 0 5
91358: PUSH
91359: LD_VAR 0 4
91363: PPUSH
91364: CALL_OW 504
91368: ST_TO_ADDR
// if GetSide ( un ) = side1 then
91369: LD_VAR 0 5
91373: PPUSH
91374: CALL_OW 255
91378: PUSH
91379: LD_VAR 0 1
91383: EQUAL
91384: IFFALSE 91400
// begin result := un ;
91386: LD_ADDR_VAR 0 3
91390: PUSH
91391: LD_VAR 0 5
91395: ST_TO_ADDR
// exit ;
91396: POP
91397: POP
91398: GO 91404
// end ; end ;
91400: GO 91351
91402: POP
91403: POP
// end ;
91404: LD_VAR 0 3
91408: RET
// export function GetCargoBay ( units ) ; begin
91409: LD_INT 0
91411: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
91412: LD_ADDR_VAR 0 2
91416: PUSH
91417: LD_VAR 0 1
91421: PPUSH
91422: LD_INT 2
91424: PUSH
91425: LD_INT 34
91427: PUSH
91428: LD_INT 12
91430: PUSH
91431: EMPTY
91432: LIST
91433: LIST
91434: PUSH
91435: LD_INT 34
91437: PUSH
91438: LD_INT 51
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 34
91447: PUSH
91448: LD_INT 32
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: PUSH
91455: LD_INT 34
91457: PUSH
91458: LD_INT 89
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: PPUSH
91472: CALL_OW 72
91476: ST_TO_ADDR
// end ;
91477: LD_VAR 0 2
91481: RET
// export function Negate ( value ) ; begin
91482: LD_INT 0
91484: PPUSH
// result := not value ;
91485: LD_ADDR_VAR 0 2
91489: PUSH
91490: LD_VAR 0 1
91494: NOT
91495: ST_TO_ADDR
// end ;
91496: LD_VAR 0 2
91500: RET
// export function Inc ( value ) ; begin
91501: LD_INT 0
91503: PPUSH
// result := value + 1 ;
91504: LD_ADDR_VAR 0 2
91508: PUSH
91509: LD_VAR 0 1
91513: PUSH
91514: LD_INT 1
91516: PLUS
91517: ST_TO_ADDR
// end ;
91518: LD_VAR 0 2
91522: RET
// export function Dec ( value ) ; begin
91523: LD_INT 0
91525: PPUSH
// result := value - 1 ;
91526: LD_ADDR_VAR 0 2
91530: PUSH
91531: LD_VAR 0 1
91535: PUSH
91536: LD_INT 1
91538: MINUS
91539: ST_TO_ADDR
// end ;
91540: LD_VAR 0 2
91544: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
91545: LD_INT 0
91547: PPUSH
91548: PPUSH
91549: PPUSH
91550: PPUSH
91551: PPUSH
91552: PPUSH
91553: PPUSH
91554: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
91555: LD_VAR 0 1
91559: PPUSH
91560: LD_VAR 0 2
91564: PPUSH
91565: CALL_OW 488
91569: NOT
91570: PUSH
91571: LD_VAR 0 3
91575: PPUSH
91576: LD_VAR 0 4
91580: PPUSH
91581: CALL_OW 488
91585: NOT
91586: OR
91587: IFFALSE 91600
// begin result := - 1 ;
91589: LD_ADDR_VAR 0 5
91593: PUSH
91594: LD_INT 1
91596: NEG
91597: ST_TO_ADDR
// exit ;
91598: GO 91835
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
91600: LD_ADDR_VAR 0 12
91604: PUSH
91605: LD_VAR 0 1
91609: PPUSH
91610: LD_VAR 0 2
91614: PPUSH
91615: LD_VAR 0 3
91619: PPUSH
91620: LD_VAR 0 4
91624: PPUSH
91625: CALL 90685 0 4
91629: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
91630: LD_ADDR_VAR 0 11
91634: PUSH
91635: LD_VAR 0 1
91639: PPUSH
91640: LD_VAR 0 2
91644: PPUSH
91645: LD_VAR 0 12
91649: PUSH
91650: LD_INT 1
91652: ARRAY
91653: PPUSH
91654: LD_VAR 0 12
91658: PUSH
91659: LD_INT 2
91661: ARRAY
91662: PPUSH
91663: CALL_OW 298
91667: ST_TO_ADDR
// distance := 9999 ;
91668: LD_ADDR_VAR 0 10
91672: PUSH
91673: LD_INT 9999
91675: ST_TO_ADDR
// for i := 0 to 5 do
91676: LD_ADDR_VAR 0 6
91680: PUSH
91681: DOUBLE
91682: LD_INT 0
91684: DEC
91685: ST_TO_ADDR
91686: LD_INT 5
91688: PUSH
91689: FOR_TO
91690: IFFALSE 91833
// begin _x := ShiftX ( x1 , i , centerDist ) ;
91692: LD_ADDR_VAR 0 7
91696: PUSH
91697: LD_VAR 0 1
91701: PPUSH
91702: LD_VAR 0 6
91706: PPUSH
91707: LD_VAR 0 11
91711: PPUSH
91712: CALL_OW 272
91716: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
91717: LD_ADDR_VAR 0 8
91721: PUSH
91722: LD_VAR 0 2
91726: PPUSH
91727: LD_VAR 0 6
91731: PPUSH
91732: LD_VAR 0 11
91736: PPUSH
91737: CALL_OW 273
91741: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91742: LD_VAR 0 7
91746: PPUSH
91747: LD_VAR 0 8
91751: PPUSH
91752: CALL_OW 488
91756: NOT
91757: IFFALSE 91761
// continue ;
91759: GO 91689
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
91761: LD_ADDR_VAR 0 9
91765: PUSH
91766: LD_VAR 0 12
91770: PUSH
91771: LD_INT 1
91773: ARRAY
91774: PPUSH
91775: LD_VAR 0 12
91779: PUSH
91780: LD_INT 2
91782: ARRAY
91783: PPUSH
91784: LD_VAR 0 7
91788: PPUSH
91789: LD_VAR 0 8
91793: PPUSH
91794: CALL_OW 298
91798: ST_TO_ADDR
// if tmp < distance then
91799: LD_VAR 0 9
91803: PUSH
91804: LD_VAR 0 10
91808: LESS
91809: IFFALSE 91831
// begin result := i ;
91811: LD_ADDR_VAR 0 5
91815: PUSH
91816: LD_VAR 0 6
91820: ST_TO_ADDR
// distance := tmp ;
91821: LD_ADDR_VAR 0 10
91825: PUSH
91826: LD_VAR 0 9
91830: ST_TO_ADDR
// end ; end ;
91831: GO 91689
91833: POP
91834: POP
// end ;
91835: LD_VAR 0 5
91839: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91840: LD_INT 0
91842: PPUSH
91843: PPUSH
// if not driver or not IsInUnit ( driver ) then
91844: LD_VAR 0 1
91848: NOT
91849: PUSH
91850: LD_VAR 0 1
91854: PPUSH
91855: CALL_OW 310
91859: NOT
91860: OR
91861: IFFALSE 91865
// exit ;
91863: GO 91955
// vehicle := IsInUnit ( driver ) ;
91865: LD_ADDR_VAR 0 3
91869: PUSH
91870: LD_VAR 0 1
91874: PPUSH
91875: CALL_OW 310
91879: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91880: LD_VAR 0 1
91884: PPUSH
91885: LD_STRING \
91887: PUSH
91888: LD_INT 0
91890: PUSH
91891: LD_INT 0
91893: PUSH
91894: LD_INT 0
91896: PUSH
91897: LD_INT 0
91899: PUSH
91900: LD_INT 0
91902: PUSH
91903: LD_INT 0
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: PUSH
91915: LD_STRING E
91917: PUSH
91918: LD_INT 0
91920: PUSH
91921: LD_INT 0
91923: PUSH
91924: LD_VAR 0 3
91928: PUSH
91929: LD_INT 0
91931: PUSH
91932: LD_INT 0
91934: PUSH
91935: LD_INT 0
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PPUSH
91951: CALL_OW 446
// end ;
91955: LD_VAR 0 2
91959: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91960: LD_INT 0
91962: PPUSH
91963: PPUSH
// if not driver or not IsInUnit ( driver ) then
91964: LD_VAR 0 1
91968: NOT
91969: PUSH
91970: LD_VAR 0 1
91974: PPUSH
91975: CALL_OW 310
91979: NOT
91980: OR
91981: IFFALSE 91985
// exit ;
91983: GO 92075
// vehicle := IsInUnit ( driver ) ;
91985: LD_ADDR_VAR 0 3
91989: PUSH
91990: LD_VAR 0 1
91994: PPUSH
91995: CALL_OW 310
91999: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92000: LD_VAR 0 1
92004: PPUSH
92005: LD_STRING \
92007: PUSH
92008: LD_INT 0
92010: PUSH
92011: LD_INT 0
92013: PUSH
92014: LD_INT 0
92016: PUSH
92017: LD_INT 0
92019: PUSH
92020: LD_INT 0
92022: PUSH
92023: LD_INT 0
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: PUSH
92035: LD_STRING E
92037: PUSH
92038: LD_INT 0
92040: PUSH
92041: LD_INT 0
92043: PUSH
92044: LD_VAR 0 3
92048: PUSH
92049: LD_INT 0
92051: PUSH
92052: LD_INT 0
92054: PUSH
92055: LD_INT 0
92057: PUSH
92058: EMPTY
92059: LIST
92060: LIST
92061: LIST
92062: LIST
92063: LIST
92064: LIST
92065: LIST
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: PPUSH
92071: CALL_OW 447
// end ;
92075: LD_VAR 0 2
92079: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
92080: LD_INT 0
92082: PPUSH
92083: PPUSH
92084: PPUSH
// tmp := [ ] ;
92085: LD_ADDR_VAR 0 5
92089: PUSH
92090: EMPTY
92091: ST_TO_ADDR
// for i in units do
92092: LD_ADDR_VAR 0 4
92096: PUSH
92097: LD_VAR 0 1
92101: PUSH
92102: FOR_IN
92103: IFFALSE 92141
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
92105: LD_ADDR_VAR 0 5
92109: PUSH
92110: LD_VAR 0 5
92114: PPUSH
92115: LD_VAR 0 5
92119: PUSH
92120: LD_INT 1
92122: PLUS
92123: PPUSH
92124: LD_VAR 0 4
92128: PPUSH
92129: CALL_OW 256
92133: PPUSH
92134: CALL_OW 2
92138: ST_TO_ADDR
92139: GO 92102
92141: POP
92142: POP
// if not tmp then
92143: LD_VAR 0 5
92147: NOT
92148: IFFALSE 92152
// exit ;
92150: GO 92200
// if asc then
92152: LD_VAR 0 2
92156: IFFALSE 92180
// result := SortListByListAsc ( units , tmp ) else
92158: LD_ADDR_VAR 0 3
92162: PUSH
92163: LD_VAR 0 1
92167: PPUSH
92168: LD_VAR 0 5
92172: PPUSH
92173: CALL_OW 76
92177: ST_TO_ADDR
92178: GO 92200
// result := SortListByListDesc ( units , tmp ) ;
92180: LD_ADDR_VAR 0 3
92184: PUSH
92185: LD_VAR 0 1
92189: PPUSH
92190: LD_VAR 0 5
92194: PPUSH
92195: CALL_OW 77
92199: ST_TO_ADDR
// end ;
92200: LD_VAR 0 3
92204: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
92205: LD_INT 0
92207: PPUSH
92208: PPUSH
// task := GetTaskList ( mech ) ;
92209: LD_ADDR_VAR 0 4
92213: PUSH
92214: LD_VAR 0 1
92218: PPUSH
92219: CALL_OW 437
92223: ST_TO_ADDR
// if not task then
92224: LD_VAR 0 4
92228: NOT
92229: IFFALSE 92233
// exit ;
92231: GO 92275
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
92233: LD_ADDR_VAR 0 3
92237: PUSH
92238: LD_VAR 0 4
92242: PUSH
92243: LD_INT 1
92245: ARRAY
92246: PUSH
92247: LD_INT 1
92249: ARRAY
92250: PUSH
92251: LD_STRING r
92253: EQUAL
92254: PUSH
92255: LD_VAR 0 4
92259: PUSH
92260: LD_INT 1
92262: ARRAY
92263: PUSH
92264: LD_INT 4
92266: ARRAY
92267: PUSH
92268: LD_VAR 0 2
92272: EQUAL
92273: AND
92274: ST_TO_ADDR
// end ;
92275: LD_VAR 0 3
92279: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
92280: LD_INT 0
92282: PPUSH
// SetDir ( unit , d ) ;
92283: LD_VAR 0 1
92287: PPUSH
92288: LD_VAR 0 4
92292: PPUSH
92293: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
92297: LD_VAR 0 1
92301: PPUSH
92302: LD_VAR 0 2
92306: PPUSH
92307: LD_VAR 0 3
92311: PPUSH
92312: LD_VAR 0 5
92316: PPUSH
92317: CALL_OW 48
// end ;
92321: LD_VAR 0 6
92325: RET
// export function ToNaturalNumber ( number ) ; begin
92326: LD_INT 0
92328: PPUSH
// result := number div 1 ;
92329: LD_ADDR_VAR 0 2
92333: PUSH
92334: LD_VAR 0 1
92338: PUSH
92339: LD_INT 1
92341: DIV
92342: ST_TO_ADDR
// if number < 0 then
92343: LD_VAR 0 1
92347: PUSH
92348: LD_INT 0
92350: LESS
92351: IFFALSE 92361
// result := 0 ;
92353: LD_ADDR_VAR 0 2
92357: PUSH
92358: LD_INT 0
92360: ST_TO_ADDR
// end ;
92361: LD_VAR 0 2
92365: RET
// export function SortByClass ( units , class ) ; var un ; begin
92366: LD_INT 0
92368: PPUSH
92369: PPUSH
// if not units or not class then
92370: LD_VAR 0 1
92374: NOT
92375: PUSH
92376: LD_VAR 0 2
92380: NOT
92381: OR
92382: IFFALSE 92386
// exit ;
92384: GO 92481
// result := [ ] ;
92386: LD_ADDR_VAR 0 3
92390: PUSH
92391: EMPTY
92392: ST_TO_ADDR
// for un in units do
92393: LD_ADDR_VAR 0 4
92397: PUSH
92398: LD_VAR 0 1
92402: PUSH
92403: FOR_IN
92404: IFFALSE 92479
// if GetClass ( un ) = class then
92406: LD_VAR 0 4
92410: PPUSH
92411: CALL_OW 257
92415: PUSH
92416: LD_VAR 0 2
92420: EQUAL
92421: IFFALSE 92448
// result := Insert ( result , 1 , un ) else
92423: LD_ADDR_VAR 0 3
92427: PUSH
92428: LD_VAR 0 3
92432: PPUSH
92433: LD_INT 1
92435: PPUSH
92436: LD_VAR 0 4
92440: PPUSH
92441: CALL_OW 2
92445: ST_TO_ADDR
92446: GO 92477
// result := Replace ( result , result + 1 , un ) ;
92448: LD_ADDR_VAR 0 3
92452: PUSH
92453: LD_VAR 0 3
92457: PPUSH
92458: LD_VAR 0 3
92462: PUSH
92463: LD_INT 1
92465: PLUS
92466: PPUSH
92467: LD_VAR 0 4
92471: PPUSH
92472: CALL_OW 1
92476: ST_TO_ADDR
92477: GO 92403
92479: POP
92480: POP
// end ;
92481: LD_VAR 0 3
92485: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
92486: LD_INT 0
92488: PPUSH
92489: PPUSH
92490: PPUSH
92491: PPUSH
92492: PPUSH
92493: PPUSH
92494: PPUSH
// result := [ ] ;
92495: LD_ADDR_VAR 0 4
92499: PUSH
92500: EMPTY
92501: ST_TO_ADDR
// if x - r < 0 then
92502: LD_VAR 0 1
92506: PUSH
92507: LD_VAR 0 3
92511: MINUS
92512: PUSH
92513: LD_INT 0
92515: LESS
92516: IFFALSE 92528
// min_x := 0 else
92518: LD_ADDR_VAR 0 8
92522: PUSH
92523: LD_INT 0
92525: ST_TO_ADDR
92526: GO 92544
// min_x := x - r ;
92528: LD_ADDR_VAR 0 8
92532: PUSH
92533: LD_VAR 0 1
92537: PUSH
92538: LD_VAR 0 3
92542: MINUS
92543: ST_TO_ADDR
// if y - r < 0 then
92544: LD_VAR 0 2
92548: PUSH
92549: LD_VAR 0 3
92553: MINUS
92554: PUSH
92555: LD_INT 0
92557: LESS
92558: IFFALSE 92570
// min_y := 0 else
92560: LD_ADDR_VAR 0 7
92564: PUSH
92565: LD_INT 0
92567: ST_TO_ADDR
92568: GO 92586
// min_y := y - r ;
92570: LD_ADDR_VAR 0 7
92574: PUSH
92575: LD_VAR 0 2
92579: PUSH
92580: LD_VAR 0 3
92584: MINUS
92585: ST_TO_ADDR
// max_x := x + r ;
92586: LD_ADDR_VAR 0 9
92590: PUSH
92591: LD_VAR 0 1
92595: PUSH
92596: LD_VAR 0 3
92600: PLUS
92601: ST_TO_ADDR
// max_y := y + r ;
92602: LD_ADDR_VAR 0 10
92606: PUSH
92607: LD_VAR 0 2
92611: PUSH
92612: LD_VAR 0 3
92616: PLUS
92617: ST_TO_ADDR
// for _x = min_x to max_x do
92618: LD_ADDR_VAR 0 5
92622: PUSH
92623: DOUBLE
92624: LD_VAR 0 8
92628: DEC
92629: ST_TO_ADDR
92630: LD_VAR 0 9
92634: PUSH
92635: FOR_TO
92636: IFFALSE 92737
// for _y = min_y to max_y do
92638: LD_ADDR_VAR 0 6
92642: PUSH
92643: DOUBLE
92644: LD_VAR 0 7
92648: DEC
92649: ST_TO_ADDR
92650: LD_VAR 0 10
92654: PUSH
92655: FOR_TO
92656: IFFALSE 92733
// begin if not ValidHex ( _x , _y ) then
92658: LD_VAR 0 5
92662: PPUSH
92663: LD_VAR 0 6
92667: PPUSH
92668: CALL_OW 488
92672: NOT
92673: IFFALSE 92677
// continue ;
92675: GO 92655
// if GetResourceTypeXY ( _x , _y ) then
92677: LD_VAR 0 5
92681: PPUSH
92682: LD_VAR 0 6
92686: PPUSH
92687: CALL_OW 283
92691: IFFALSE 92731
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
92693: LD_ADDR_VAR 0 4
92697: PUSH
92698: LD_VAR 0 4
92702: PPUSH
92703: LD_VAR 0 4
92707: PUSH
92708: LD_INT 1
92710: PLUS
92711: PPUSH
92712: LD_VAR 0 5
92716: PUSH
92717: LD_VAR 0 6
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: PPUSH
92726: CALL_OW 1
92730: ST_TO_ADDR
// end ;
92731: GO 92655
92733: POP
92734: POP
92735: GO 92635
92737: POP
92738: POP
// end ;
92739: LD_VAR 0 4
92743: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
92744: LD_INT 0
92746: PPUSH
92747: PPUSH
92748: PPUSH
92749: PPUSH
92750: PPUSH
92751: PPUSH
92752: PPUSH
92753: PPUSH
// if not units then
92754: LD_VAR 0 1
92758: NOT
92759: IFFALSE 92763
// exit ;
92761: GO 93287
// result := UnitFilter ( units , [ f_ok ] ) ;
92763: LD_ADDR_VAR 0 3
92767: PUSH
92768: LD_VAR 0 1
92772: PPUSH
92773: LD_INT 50
92775: PUSH
92776: EMPTY
92777: LIST
92778: PPUSH
92779: CALL_OW 72
92783: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
92784: LD_ADDR_VAR 0 8
92788: PUSH
92789: LD_VAR 0 1
92793: PUSH
92794: LD_INT 1
92796: ARRAY
92797: PPUSH
92798: CALL_OW 255
92802: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
92803: LD_ADDR_VAR 0 10
92807: PUSH
92808: LD_INT 29
92810: PUSH
92811: LD_INT 91
92813: PUSH
92814: LD_INT 49
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: LIST
92821: ST_TO_ADDR
// if not result then
92822: LD_VAR 0 3
92826: NOT
92827: IFFALSE 92831
// exit ;
92829: GO 93287
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
92831: LD_ADDR_VAR 0 5
92835: PUSH
92836: LD_INT 81
92838: PUSH
92839: LD_VAR 0 8
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PPUSH
92848: CALL_OW 69
92852: ST_TO_ADDR
// for i in result do
92853: LD_ADDR_VAR 0 4
92857: PUSH
92858: LD_VAR 0 3
92862: PUSH
92863: FOR_IN
92864: IFFALSE 93285
// begin tag := GetTag ( i ) + 1 ;
92866: LD_ADDR_VAR 0 9
92870: PUSH
92871: LD_VAR 0 4
92875: PPUSH
92876: CALL_OW 110
92880: PUSH
92881: LD_INT 1
92883: PLUS
92884: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
92885: LD_ADDR_VAR 0 7
92889: PUSH
92890: LD_VAR 0 4
92894: PPUSH
92895: CALL_OW 250
92899: PPUSH
92900: LD_VAR 0 4
92904: PPUSH
92905: CALL_OW 251
92909: PPUSH
92910: LD_INT 6
92912: PPUSH
92913: CALL 92486 0 3
92917: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
92918: LD_VAR 0 4
92922: PPUSH
92923: CALL_OW 247
92927: PUSH
92928: LD_INT 2
92930: EQUAL
92931: PUSH
92932: LD_VAR 0 7
92936: AND
92937: PUSH
92938: LD_VAR 0 4
92942: PPUSH
92943: CALL_OW 264
92947: PUSH
92948: LD_VAR 0 10
92952: IN
92953: NOT
92954: AND
92955: IFFALSE 92994
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
92957: LD_VAR 0 4
92961: PPUSH
92962: LD_VAR 0 7
92966: PUSH
92967: LD_INT 1
92969: ARRAY
92970: PUSH
92971: LD_INT 1
92973: ARRAY
92974: PPUSH
92975: LD_VAR 0 7
92979: PUSH
92980: LD_INT 1
92982: ARRAY
92983: PUSH
92984: LD_INT 2
92986: ARRAY
92987: PPUSH
92988: CALL_OW 116
92992: GO 93283
// if path > tag then
92994: LD_VAR 0 2
92998: PUSH
92999: LD_VAR 0 9
93003: GREATER
93004: IFFALSE 93212
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
93006: LD_ADDR_VAR 0 6
93010: PUSH
93011: LD_VAR 0 5
93015: PPUSH
93016: LD_INT 91
93018: PUSH
93019: LD_VAR 0 4
93023: PUSH
93024: LD_INT 8
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: LIST
93031: PPUSH
93032: CALL_OW 72
93036: ST_TO_ADDR
// if nearEnemy then
93037: LD_VAR 0 6
93041: IFFALSE 93110
// begin if GetWeapon ( i ) = ru_time_lapser then
93043: LD_VAR 0 4
93047: PPUSH
93048: CALL_OW 264
93052: PUSH
93053: LD_INT 49
93055: EQUAL
93056: IFFALSE 93084
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
93058: LD_VAR 0 4
93062: PPUSH
93063: LD_VAR 0 6
93067: PPUSH
93068: LD_VAR 0 4
93072: PPUSH
93073: CALL_OW 74
93077: PPUSH
93078: CALL_OW 112
93082: GO 93108
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
93084: LD_VAR 0 4
93088: PPUSH
93089: LD_VAR 0 6
93093: PPUSH
93094: LD_VAR 0 4
93098: PPUSH
93099: CALL_OW 74
93103: PPUSH
93104: CALL_OW 115
// end else
93108: GO 93210
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
93110: LD_VAR 0 4
93114: PPUSH
93115: LD_VAR 0 2
93119: PUSH
93120: LD_VAR 0 9
93124: ARRAY
93125: PUSH
93126: LD_INT 1
93128: ARRAY
93129: PPUSH
93130: LD_VAR 0 2
93134: PUSH
93135: LD_VAR 0 9
93139: ARRAY
93140: PUSH
93141: LD_INT 2
93143: ARRAY
93144: PPUSH
93145: CALL_OW 297
93149: PUSH
93150: LD_INT 6
93152: GREATER
93153: IFFALSE 93196
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
93155: LD_VAR 0 4
93159: PPUSH
93160: LD_VAR 0 2
93164: PUSH
93165: LD_VAR 0 9
93169: ARRAY
93170: PUSH
93171: LD_INT 1
93173: ARRAY
93174: PPUSH
93175: LD_VAR 0 2
93179: PUSH
93180: LD_VAR 0 9
93184: ARRAY
93185: PUSH
93186: LD_INT 2
93188: ARRAY
93189: PPUSH
93190: CALL_OW 114
93194: GO 93210
// SetTag ( i , tag ) ;
93196: LD_VAR 0 4
93200: PPUSH
93201: LD_VAR 0 9
93205: PPUSH
93206: CALL_OW 109
// end else
93210: GO 93283
// if enemy then
93212: LD_VAR 0 5
93216: IFFALSE 93283
// begin if GetWeapon ( i ) = ru_time_lapser then
93218: LD_VAR 0 4
93222: PPUSH
93223: CALL_OW 264
93227: PUSH
93228: LD_INT 49
93230: EQUAL
93231: IFFALSE 93259
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
93233: LD_VAR 0 4
93237: PPUSH
93238: LD_VAR 0 5
93242: PPUSH
93243: LD_VAR 0 4
93247: PPUSH
93248: CALL_OW 74
93252: PPUSH
93253: CALL_OW 112
93257: GO 93283
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
93259: LD_VAR 0 4
93263: PPUSH
93264: LD_VAR 0 5
93268: PPUSH
93269: LD_VAR 0 4
93273: PPUSH
93274: CALL_OW 74
93278: PPUSH
93279: CALL_OW 115
// end ; end ;
93283: GO 92863
93285: POP
93286: POP
// end ;
93287: LD_VAR 0 3
93291: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
93292: LD_INT 0
93294: PPUSH
93295: PPUSH
93296: PPUSH
// if not unit or IsInUnit ( unit ) then
93297: LD_VAR 0 1
93301: NOT
93302: PUSH
93303: LD_VAR 0 1
93307: PPUSH
93308: CALL_OW 310
93312: OR
93313: IFFALSE 93317
// exit ;
93315: GO 93408
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
93317: LD_ADDR_VAR 0 4
93321: PUSH
93322: LD_VAR 0 1
93326: PPUSH
93327: CALL_OW 250
93331: PPUSH
93332: LD_VAR 0 2
93336: PPUSH
93337: LD_INT 1
93339: PPUSH
93340: CALL_OW 272
93344: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
93345: LD_ADDR_VAR 0 5
93349: PUSH
93350: LD_VAR 0 1
93354: PPUSH
93355: CALL_OW 251
93359: PPUSH
93360: LD_VAR 0 2
93364: PPUSH
93365: LD_INT 1
93367: PPUSH
93368: CALL_OW 273
93372: ST_TO_ADDR
// if ValidHex ( x , y ) then
93373: LD_VAR 0 4
93377: PPUSH
93378: LD_VAR 0 5
93382: PPUSH
93383: CALL_OW 488
93387: IFFALSE 93408
// ComTurnXY ( unit , x , y ) ;
93389: LD_VAR 0 1
93393: PPUSH
93394: LD_VAR 0 4
93398: PPUSH
93399: LD_VAR 0 5
93403: PPUSH
93404: CALL_OW 118
// end ;
93408: LD_VAR 0 3
93412: RET
// export function SeeUnits ( side , units ) ; var i ; begin
93413: LD_INT 0
93415: PPUSH
93416: PPUSH
// result := false ;
93417: LD_ADDR_VAR 0 3
93421: PUSH
93422: LD_INT 0
93424: ST_TO_ADDR
// if not units then
93425: LD_VAR 0 2
93429: NOT
93430: IFFALSE 93434
// exit ;
93432: GO 93479
// for i in units do
93434: LD_ADDR_VAR 0 4
93438: PUSH
93439: LD_VAR 0 2
93443: PUSH
93444: FOR_IN
93445: IFFALSE 93477
// if See ( side , i ) then
93447: LD_VAR 0 1
93451: PPUSH
93452: LD_VAR 0 4
93456: PPUSH
93457: CALL_OW 292
93461: IFFALSE 93475
// begin result := true ;
93463: LD_ADDR_VAR 0 3
93467: PUSH
93468: LD_INT 1
93470: ST_TO_ADDR
// exit ;
93471: POP
93472: POP
93473: GO 93479
// end ;
93475: GO 93444
93477: POP
93478: POP
// end ;
93479: LD_VAR 0 3
93483: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
93484: LD_INT 0
93486: PPUSH
93487: PPUSH
93488: PPUSH
93489: PPUSH
// if not unit or not points then
93490: LD_VAR 0 1
93494: NOT
93495: PUSH
93496: LD_VAR 0 2
93500: NOT
93501: OR
93502: IFFALSE 93506
// exit ;
93504: GO 93596
// dist := 99999 ;
93506: LD_ADDR_VAR 0 5
93510: PUSH
93511: LD_INT 99999
93513: ST_TO_ADDR
// for i in points do
93514: LD_ADDR_VAR 0 4
93518: PUSH
93519: LD_VAR 0 2
93523: PUSH
93524: FOR_IN
93525: IFFALSE 93594
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
93527: LD_ADDR_VAR 0 6
93531: PUSH
93532: LD_VAR 0 1
93536: PPUSH
93537: LD_VAR 0 4
93541: PUSH
93542: LD_INT 1
93544: ARRAY
93545: PPUSH
93546: LD_VAR 0 4
93550: PUSH
93551: LD_INT 2
93553: ARRAY
93554: PPUSH
93555: CALL_OW 297
93559: ST_TO_ADDR
// if tmpDist < dist then
93560: LD_VAR 0 6
93564: PUSH
93565: LD_VAR 0 5
93569: LESS
93570: IFFALSE 93592
// begin result := i ;
93572: LD_ADDR_VAR 0 3
93576: PUSH
93577: LD_VAR 0 4
93581: ST_TO_ADDR
// dist := tmpDist ;
93582: LD_ADDR_VAR 0 5
93586: PUSH
93587: LD_VAR 0 6
93591: ST_TO_ADDR
// end ; end ;
93592: GO 93524
93594: POP
93595: POP
// end ;
93596: LD_VAR 0 3
93600: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
93601: LD_INT 0
93603: PPUSH
// uc_side := side ;
93604: LD_ADDR_OWVAR 20
93608: PUSH
93609: LD_VAR 0 1
93613: ST_TO_ADDR
// uc_nation := 3 ;
93614: LD_ADDR_OWVAR 21
93618: PUSH
93619: LD_INT 3
93621: ST_TO_ADDR
// vc_chassis := 25 ;
93622: LD_ADDR_OWVAR 37
93626: PUSH
93627: LD_INT 25
93629: ST_TO_ADDR
// vc_engine := engine_siberite ;
93630: LD_ADDR_OWVAR 39
93634: PUSH
93635: LD_INT 3
93637: ST_TO_ADDR
// vc_control := control_computer ;
93638: LD_ADDR_OWVAR 38
93642: PUSH
93643: LD_INT 3
93645: ST_TO_ADDR
// vc_weapon := 59 ;
93646: LD_ADDR_OWVAR 40
93650: PUSH
93651: LD_INT 59
93653: ST_TO_ADDR
// result := CreateVehicle ;
93654: LD_ADDR_VAR 0 5
93658: PUSH
93659: CALL_OW 45
93663: ST_TO_ADDR
// SetDir ( result , d ) ;
93664: LD_VAR 0 5
93668: PPUSH
93669: LD_VAR 0 4
93673: PPUSH
93674: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
93678: LD_VAR 0 5
93682: PPUSH
93683: LD_VAR 0 2
93687: PPUSH
93688: LD_VAR 0 3
93692: PPUSH
93693: LD_INT 0
93695: PPUSH
93696: CALL_OW 48
// end ;
93700: LD_VAR 0 5
93704: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
93705: LD_INT 0
93707: PPUSH
93708: PPUSH
93709: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
93710: LD_ADDR_VAR 0 2
93714: PUSH
93715: LD_INT 0
93717: PUSH
93718: LD_INT 0
93720: PUSH
93721: LD_INT 0
93723: PUSH
93724: LD_INT 0
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: LIST
93731: LIST
93732: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
93733: LD_VAR 0 1
93737: NOT
93738: PUSH
93739: LD_VAR 0 1
93743: PPUSH
93744: CALL_OW 264
93748: PUSH
93749: LD_INT 12
93751: PUSH
93752: LD_INT 51
93754: PUSH
93755: LD_INT 32
93757: PUSH
93758: LD_INT 89
93760: PUSH
93761: EMPTY
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: IN
93767: NOT
93768: OR
93769: IFFALSE 93773
// exit ;
93771: GO 93871
// for i := 1 to 3 do
93773: LD_ADDR_VAR 0 3
93777: PUSH
93778: DOUBLE
93779: LD_INT 1
93781: DEC
93782: ST_TO_ADDR
93783: LD_INT 3
93785: PUSH
93786: FOR_TO
93787: IFFALSE 93869
// begin tmp := GetCargo ( cargo , i ) ;
93789: LD_ADDR_VAR 0 4
93793: PUSH
93794: LD_VAR 0 1
93798: PPUSH
93799: LD_VAR 0 3
93803: PPUSH
93804: CALL_OW 289
93808: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
93809: LD_ADDR_VAR 0 2
93813: PUSH
93814: LD_VAR 0 2
93818: PPUSH
93819: LD_VAR 0 3
93823: PPUSH
93824: LD_VAR 0 4
93828: PPUSH
93829: CALL_OW 1
93833: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
93834: LD_ADDR_VAR 0 2
93838: PUSH
93839: LD_VAR 0 2
93843: PPUSH
93844: LD_INT 4
93846: PPUSH
93847: LD_VAR 0 2
93851: PUSH
93852: LD_INT 4
93854: ARRAY
93855: PUSH
93856: LD_VAR 0 4
93860: PLUS
93861: PPUSH
93862: CALL_OW 1
93866: ST_TO_ADDR
// end ;
93867: GO 93786
93869: POP
93870: POP
// end ;
93871: LD_VAR 0 2
93875: RET
// export function Length ( array ) ; begin
93876: LD_INT 0
93878: PPUSH
// result := array + 0 ;
93879: LD_ADDR_VAR 0 2
93883: PUSH
93884: LD_VAR 0 1
93888: PUSH
93889: LD_INT 0
93891: PLUS
93892: ST_TO_ADDR
// end ;
93893: LD_VAR 0 2
93897: RET
// export function PrepareArray ( array ) ; begin
93898: LD_INT 0
93900: PPUSH
// result := array diff 0 ;
93901: LD_ADDR_VAR 0 2
93905: PUSH
93906: LD_VAR 0 1
93910: PUSH
93911: LD_INT 0
93913: DIFF
93914: ST_TO_ADDR
// if not result [ 1 ] then
93915: LD_VAR 0 2
93919: PUSH
93920: LD_INT 1
93922: ARRAY
93923: NOT
93924: IFFALSE 93944
// result := Delete ( result , 1 ) ;
93926: LD_ADDR_VAR 0 2
93930: PUSH
93931: LD_VAR 0 2
93935: PPUSH
93936: LD_INT 1
93938: PPUSH
93939: CALL_OW 3
93943: ST_TO_ADDR
// end ;
93944: LD_VAR 0 2
93948: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
93949: LD_INT 0
93951: PPUSH
93952: PPUSH
93953: PPUSH
93954: PPUSH
// sibRocketRange := 25 ;
93955: LD_ADDR_VAR 0 6
93959: PUSH
93960: LD_INT 25
93962: ST_TO_ADDR
// result := false ;
93963: LD_ADDR_VAR 0 4
93967: PUSH
93968: LD_INT 0
93970: ST_TO_ADDR
// for i := 0 to 5 do
93971: LD_ADDR_VAR 0 5
93975: PUSH
93976: DOUBLE
93977: LD_INT 0
93979: DEC
93980: ST_TO_ADDR
93981: LD_INT 5
93983: PUSH
93984: FOR_TO
93985: IFFALSE 94052
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
93987: LD_VAR 0 1
93991: PPUSH
93992: LD_VAR 0 5
93996: PPUSH
93997: LD_VAR 0 6
94001: PPUSH
94002: CALL_OW 272
94006: PPUSH
94007: LD_VAR 0 2
94011: PPUSH
94012: LD_VAR 0 5
94016: PPUSH
94017: LD_VAR 0 6
94021: PPUSH
94022: CALL_OW 273
94026: PPUSH
94027: LD_VAR 0 3
94031: PPUSH
94032: CALL_OW 309
94036: IFFALSE 94050
// begin result := true ;
94038: LD_ADDR_VAR 0 4
94042: PUSH
94043: LD_INT 1
94045: ST_TO_ADDR
// exit ;
94046: POP
94047: POP
94048: GO 94054
// end ;
94050: GO 93984
94052: POP
94053: POP
// end ;
94054: LD_VAR 0 4
94058: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
94059: LD_INT 0
94061: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
94062: LD_VAR 0 1
94066: PPUSH
94067: LD_VAR 0 2
94071: PPUSH
94072: LD_INT 0
94074: PPUSH
94075: LD_INT 0
94077: PPUSH
94078: LD_INT 1
94080: PPUSH
94081: LD_INT 0
94083: PPUSH
94084: CALL_OW 587
// end ;
94088: LD_VAR 0 3
94092: RET
// export function CenterOnNow ( unit ) ; begin
94093: LD_INT 0
94095: PPUSH
// result := IsInUnit ( unit ) ;
94096: LD_ADDR_VAR 0 2
94100: PUSH
94101: LD_VAR 0 1
94105: PPUSH
94106: CALL_OW 310
94110: ST_TO_ADDR
// if not result then
94111: LD_VAR 0 2
94115: NOT
94116: IFFALSE 94128
// result := unit ;
94118: LD_ADDR_VAR 0 2
94122: PUSH
94123: LD_VAR 0 1
94127: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
94128: LD_VAR 0 1
94132: PPUSH
94133: CALL_OW 87
// end ;
94137: LD_VAR 0 2
94141: RET
// export function ComMoveHex ( unit , hex ) ; begin
94142: LD_INT 0
94144: PPUSH
// if not hex then
94145: LD_VAR 0 2
94149: NOT
94150: IFFALSE 94154
// exit ;
94152: GO 94207
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
94154: LD_VAR 0 2
94158: PUSH
94159: LD_INT 1
94161: ARRAY
94162: PPUSH
94163: LD_VAR 0 2
94167: PUSH
94168: LD_INT 2
94170: ARRAY
94171: PPUSH
94172: CALL_OW 428
94176: IFFALSE 94180
// exit ;
94178: GO 94207
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
94180: LD_VAR 0 1
94184: PPUSH
94185: LD_VAR 0 2
94189: PUSH
94190: LD_INT 1
94192: ARRAY
94193: PPUSH
94194: LD_VAR 0 2
94198: PUSH
94199: LD_INT 2
94201: ARRAY
94202: PPUSH
94203: CALL_OW 111
// end ; end_of_file end_of_file
94207: LD_VAR 0 3
94211: RET
// export globalGameSaveCounter ; every 0 0$1 do
94212: GO 94214
94214: DISABLE
// begin enable ;
94215: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94216: LD_STRING updateTimer(
94218: PUSH
94219: LD_OWVAR 1
94223: STR
94224: PUSH
94225: LD_STRING );
94227: STR
94228: PPUSH
94229: CALL_OW 559
// end ;
94233: END
// every 0 0$1 do
94234: GO 94236
94236: DISABLE
// begin globalGameSaveCounter := 0 ;
94237: LD_ADDR_EXP 123
94241: PUSH
94242: LD_INT 0
94244: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
94245: LD_STRING setGameSaveCounter(0)
94247: PPUSH
94248: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
94252: LD_STRING initStreamRollete();
94254: PPUSH
94255: CALL_OW 559
// InitStreamMode ;
94259: CALL 95585 0 0
// DefineStreamItems ( false ) ;
94263: LD_INT 0
94265: PPUSH
94266: CALL 96049 0 1
// end ;
94270: END
// export function SOS_MapStart ( ) ; begin
94271: LD_INT 0
94273: PPUSH
// if streamModeActive then
94274: LD_EXP 124
94278: IFFALSE 94287
// DefineStreamItems ( true ) ;
94280: LD_INT 1
94282: PPUSH
94283: CALL 96049 0 1
// UpdateLuaVariables ( ) ;
94287: CALL 94304 0 0
// UpdateFactoryWaypoints ( ) ;
94291: CALL 108918 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94295: CALL 109175 0 0
// end ;
94299: LD_VAR 0 1
94303: RET
// function UpdateLuaVariables ( ) ; begin
94304: LD_INT 0
94306: PPUSH
// if globalGameSaveCounter then
94307: LD_EXP 123
94311: IFFALSE 94345
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
94313: LD_ADDR_EXP 123
94317: PUSH
94318: LD_EXP 123
94322: PPUSH
94323: CALL 91501 0 1
94327: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94328: LD_STRING setGameSaveCounter(
94330: PUSH
94331: LD_EXP 123
94335: STR
94336: PUSH
94337: LD_STRING )
94339: STR
94340: PPUSH
94341: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
94345: LD_STRING setGameDifficulty(
94347: PUSH
94348: LD_OWVAR 67
94352: STR
94353: PUSH
94354: LD_STRING )
94356: STR
94357: PPUSH
94358: CALL_OW 559
// end ;
94362: LD_VAR 0 1
94366: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94367: LD_INT 0
94369: PPUSH
// if p2 = stream_mode then
94370: LD_VAR 0 2
94374: PUSH
94375: LD_INT 100
94377: EQUAL
94378: IFFALSE 95381
// begin if not StreamModeActive then
94380: LD_EXP 124
94384: NOT
94385: IFFALSE 94395
// StreamModeActive := true ;
94387: LD_ADDR_EXP 124
94391: PUSH
94392: LD_INT 1
94394: ST_TO_ADDR
// if p3 = 0 then
94395: LD_VAR 0 3
94399: PUSH
94400: LD_INT 0
94402: EQUAL
94403: IFFALSE 94409
// InitStreamMode ;
94405: CALL 95585 0 0
// if p3 = 1 then
94409: LD_VAR 0 3
94413: PUSH
94414: LD_INT 1
94416: EQUAL
94417: IFFALSE 94427
// sRocket := true ;
94419: LD_ADDR_EXP 129
94423: PUSH
94424: LD_INT 1
94426: ST_TO_ADDR
// if p3 = 2 then
94427: LD_VAR 0 3
94431: PUSH
94432: LD_INT 2
94434: EQUAL
94435: IFFALSE 94445
// sSpeed := true ;
94437: LD_ADDR_EXP 128
94441: PUSH
94442: LD_INT 1
94444: ST_TO_ADDR
// if p3 = 3 then
94445: LD_VAR 0 3
94449: PUSH
94450: LD_INT 3
94452: EQUAL
94453: IFFALSE 94463
// sEngine := true ;
94455: LD_ADDR_EXP 130
94459: PUSH
94460: LD_INT 1
94462: ST_TO_ADDR
// if p3 = 4 then
94463: LD_VAR 0 3
94467: PUSH
94468: LD_INT 4
94470: EQUAL
94471: IFFALSE 94481
// sSpec := true ;
94473: LD_ADDR_EXP 127
94477: PUSH
94478: LD_INT 1
94480: ST_TO_ADDR
// if p3 = 5 then
94481: LD_VAR 0 3
94485: PUSH
94486: LD_INT 5
94488: EQUAL
94489: IFFALSE 94499
// sLevel := true ;
94491: LD_ADDR_EXP 131
94495: PUSH
94496: LD_INT 1
94498: ST_TO_ADDR
// if p3 = 6 then
94499: LD_VAR 0 3
94503: PUSH
94504: LD_INT 6
94506: EQUAL
94507: IFFALSE 94517
// sArmoury := true ;
94509: LD_ADDR_EXP 132
94513: PUSH
94514: LD_INT 1
94516: ST_TO_ADDR
// if p3 = 7 then
94517: LD_VAR 0 3
94521: PUSH
94522: LD_INT 7
94524: EQUAL
94525: IFFALSE 94535
// sRadar := true ;
94527: LD_ADDR_EXP 133
94531: PUSH
94532: LD_INT 1
94534: ST_TO_ADDR
// if p3 = 8 then
94535: LD_VAR 0 3
94539: PUSH
94540: LD_INT 8
94542: EQUAL
94543: IFFALSE 94553
// sBunker := true ;
94545: LD_ADDR_EXP 134
94549: PUSH
94550: LD_INT 1
94552: ST_TO_ADDR
// if p3 = 9 then
94553: LD_VAR 0 3
94557: PUSH
94558: LD_INT 9
94560: EQUAL
94561: IFFALSE 94571
// sHack := true ;
94563: LD_ADDR_EXP 135
94567: PUSH
94568: LD_INT 1
94570: ST_TO_ADDR
// if p3 = 10 then
94571: LD_VAR 0 3
94575: PUSH
94576: LD_INT 10
94578: EQUAL
94579: IFFALSE 94589
// sFire := true ;
94581: LD_ADDR_EXP 136
94585: PUSH
94586: LD_INT 1
94588: ST_TO_ADDR
// if p3 = 11 then
94589: LD_VAR 0 3
94593: PUSH
94594: LD_INT 11
94596: EQUAL
94597: IFFALSE 94607
// sRefresh := true ;
94599: LD_ADDR_EXP 137
94603: PUSH
94604: LD_INT 1
94606: ST_TO_ADDR
// if p3 = 12 then
94607: LD_VAR 0 3
94611: PUSH
94612: LD_INT 12
94614: EQUAL
94615: IFFALSE 94625
// sExp := true ;
94617: LD_ADDR_EXP 138
94621: PUSH
94622: LD_INT 1
94624: ST_TO_ADDR
// if p3 = 13 then
94625: LD_VAR 0 3
94629: PUSH
94630: LD_INT 13
94632: EQUAL
94633: IFFALSE 94643
// sDepot := true ;
94635: LD_ADDR_EXP 139
94639: PUSH
94640: LD_INT 1
94642: ST_TO_ADDR
// if p3 = 14 then
94643: LD_VAR 0 3
94647: PUSH
94648: LD_INT 14
94650: EQUAL
94651: IFFALSE 94661
// sFlag := true ;
94653: LD_ADDR_EXP 140
94657: PUSH
94658: LD_INT 1
94660: ST_TO_ADDR
// if p3 = 15 then
94661: LD_VAR 0 3
94665: PUSH
94666: LD_INT 15
94668: EQUAL
94669: IFFALSE 94679
// sKamikadze := true ;
94671: LD_ADDR_EXP 148
94675: PUSH
94676: LD_INT 1
94678: ST_TO_ADDR
// if p3 = 16 then
94679: LD_VAR 0 3
94683: PUSH
94684: LD_INT 16
94686: EQUAL
94687: IFFALSE 94697
// sTroll := true ;
94689: LD_ADDR_EXP 149
94693: PUSH
94694: LD_INT 1
94696: ST_TO_ADDR
// if p3 = 17 then
94697: LD_VAR 0 3
94701: PUSH
94702: LD_INT 17
94704: EQUAL
94705: IFFALSE 94715
// sSlow := true ;
94707: LD_ADDR_EXP 150
94711: PUSH
94712: LD_INT 1
94714: ST_TO_ADDR
// if p3 = 18 then
94715: LD_VAR 0 3
94719: PUSH
94720: LD_INT 18
94722: EQUAL
94723: IFFALSE 94733
// sLack := true ;
94725: LD_ADDR_EXP 151
94729: PUSH
94730: LD_INT 1
94732: ST_TO_ADDR
// if p3 = 19 then
94733: LD_VAR 0 3
94737: PUSH
94738: LD_INT 19
94740: EQUAL
94741: IFFALSE 94751
// sTank := true ;
94743: LD_ADDR_EXP 153
94747: PUSH
94748: LD_INT 1
94750: ST_TO_ADDR
// if p3 = 20 then
94751: LD_VAR 0 3
94755: PUSH
94756: LD_INT 20
94758: EQUAL
94759: IFFALSE 94769
// sRemote := true ;
94761: LD_ADDR_EXP 154
94765: PUSH
94766: LD_INT 1
94768: ST_TO_ADDR
// if p3 = 21 then
94769: LD_VAR 0 3
94773: PUSH
94774: LD_INT 21
94776: EQUAL
94777: IFFALSE 94787
// sPowell := true ;
94779: LD_ADDR_EXP 155
94783: PUSH
94784: LD_INT 1
94786: ST_TO_ADDR
// if p3 = 22 then
94787: LD_VAR 0 3
94791: PUSH
94792: LD_INT 22
94794: EQUAL
94795: IFFALSE 94805
// sTeleport := true ;
94797: LD_ADDR_EXP 158
94801: PUSH
94802: LD_INT 1
94804: ST_TO_ADDR
// if p3 = 23 then
94805: LD_VAR 0 3
94809: PUSH
94810: LD_INT 23
94812: EQUAL
94813: IFFALSE 94823
// sOilTower := true ;
94815: LD_ADDR_EXP 160
94819: PUSH
94820: LD_INT 1
94822: ST_TO_ADDR
// if p3 = 24 then
94823: LD_VAR 0 3
94827: PUSH
94828: LD_INT 24
94830: EQUAL
94831: IFFALSE 94841
// sShovel := true ;
94833: LD_ADDR_EXP 161
94837: PUSH
94838: LD_INT 1
94840: ST_TO_ADDR
// if p3 = 25 then
94841: LD_VAR 0 3
94845: PUSH
94846: LD_INT 25
94848: EQUAL
94849: IFFALSE 94859
// sSheik := true ;
94851: LD_ADDR_EXP 162
94855: PUSH
94856: LD_INT 1
94858: ST_TO_ADDR
// if p3 = 26 then
94859: LD_VAR 0 3
94863: PUSH
94864: LD_INT 26
94866: EQUAL
94867: IFFALSE 94877
// sEarthquake := true ;
94869: LD_ADDR_EXP 164
94873: PUSH
94874: LD_INT 1
94876: ST_TO_ADDR
// if p3 = 27 then
94877: LD_VAR 0 3
94881: PUSH
94882: LD_INT 27
94884: EQUAL
94885: IFFALSE 94895
// sAI := true ;
94887: LD_ADDR_EXP 165
94891: PUSH
94892: LD_INT 1
94894: ST_TO_ADDR
// if p3 = 28 then
94895: LD_VAR 0 3
94899: PUSH
94900: LD_INT 28
94902: EQUAL
94903: IFFALSE 94913
// sCargo := true ;
94905: LD_ADDR_EXP 168
94909: PUSH
94910: LD_INT 1
94912: ST_TO_ADDR
// if p3 = 29 then
94913: LD_VAR 0 3
94917: PUSH
94918: LD_INT 29
94920: EQUAL
94921: IFFALSE 94931
// sDLaser := true ;
94923: LD_ADDR_EXP 169
94927: PUSH
94928: LD_INT 1
94930: ST_TO_ADDR
// if p3 = 30 then
94931: LD_VAR 0 3
94935: PUSH
94936: LD_INT 30
94938: EQUAL
94939: IFFALSE 94949
// sExchange := true ;
94941: LD_ADDR_EXP 170
94945: PUSH
94946: LD_INT 1
94948: ST_TO_ADDR
// if p3 = 31 then
94949: LD_VAR 0 3
94953: PUSH
94954: LD_INT 31
94956: EQUAL
94957: IFFALSE 94967
// sFac := true ;
94959: LD_ADDR_EXP 171
94963: PUSH
94964: LD_INT 1
94966: ST_TO_ADDR
// if p3 = 32 then
94967: LD_VAR 0 3
94971: PUSH
94972: LD_INT 32
94974: EQUAL
94975: IFFALSE 94985
// sPower := true ;
94977: LD_ADDR_EXP 172
94981: PUSH
94982: LD_INT 1
94984: ST_TO_ADDR
// if p3 = 33 then
94985: LD_VAR 0 3
94989: PUSH
94990: LD_INT 33
94992: EQUAL
94993: IFFALSE 95003
// sRandom := true ;
94995: LD_ADDR_EXP 173
94999: PUSH
95000: LD_INT 1
95002: ST_TO_ADDR
// if p3 = 34 then
95003: LD_VAR 0 3
95007: PUSH
95008: LD_INT 34
95010: EQUAL
95011: IFFALSE 95021
// sShield := true ;
95013: LD_ADDR_EXP 174
95017: PUSH
95018: LD_INT 1
95020: ST_TO_ADDR
// if p3 = 35 then
95021: LD_VAR 0 3
95025: PUSH
95026: LD_INT 35
95028: EQUAL
95029: IFFALSE 95039
// sTime := true ;
95031: LD_ADDR_EXP 175
95035: PUSH
95036: LD_INT 1
95038: ST_TO_ADDR
// if p3 = 36 then
95039: LD_VAR 0 3
95043: PUSH
95044: LD_INT 36
95046: EQUAL
95047: IFFALSE 95057
// sTools := true ;
95049: LD_ADDR_EXP 176
95053: PUSH
95054: LD_INT 1
95056: ST_TO_ADDR
// if p3 = 101 then
95057: LD_VAR 0 3
95061: PUSH
95062: LD_INT 101
95064: EQUAL
95065: IFFALSE 95075
// sSold := true ;
95067: LD_ADDR_EXP 141
95071: PUSH
95072: LD_INT 1
95074: ST_TO_ADDR
// if p3 = 102 then
95075: LD_VAR 0 3
95079: PUSH
95080: LD_INT 102
95082: EQUAL
95083: IFFALSE 95093
// sDiff := true ;
95085: LD_ADDR_EXP 142
95089: PUSH
95090: LD_INT 1
95092: ST_TO_ADDR
// if p3 = 103 then
95093: LD_VAR 0 3
95097: PUSH
95098: LD_INT 103
95100: EQUAL
95101: IFFALSE 95111
// sFog := true ;
95103: LD_ADDR_EXP 145
95107: PUSH
95108: LD_INT 1
95110: ST_TO_ADDR
// if p3 = 104 then
95111: LD_VAR 0 3
95115: PUSH
95116: LD_INT 104
95118: EQUAL
95119: IFFALSE 95129
// sReset := true ;
95121: LD_ADDR_EXP 146
95125: PUSH
95126: LD_INT 1
95128: ST_TO_ADDR
// if p3 = 105 then
95129: LD_VAR 0 3
95133: PUSH
95134: LD_INT 105
95136: EQUAL
95137: IFFALSE 95147
// sSun := true ;
95139: LD_ADDR_EXP 147
95143: PUSH
95144: LD_INT 1
95146: ST_TO_ADDR
// if p3 = 106 then
95147: LD_VAR 0 3
95151: PUSH
95152: LD_INT 106
95154: EQUAL
95155: IFFALSE 95165
// sTiger := true ;
95157: LD_ADDR_EXP 143
95161: PUSH
95162: LD_INT 1
95164: ST_TO_ADDR
// if p3 = 107 then
95165: LD_VAR 0 3
95169: PUSH
95170: LD_INT 107
95172: EQUAL
95173: IFFALSE 95183
// sBomb := true ;
95175: LD_ADDR_EXP 144
95179: PUSH
95180: LD_INT 1
95182: ST_TO_ADDR
// if p3 = 108 then
95183: LD_VAR 0 3
95187: PUSH
95188: LD_INT 108
95190: EQUAL
95191: IFFALSE 95201
// sWound := true ;
95193: LD_ADDR_EXP 152
95197: PUSH
95198: LD_INT 1
95200: ST_TO_ADDR
// if p3 = 109 then
95201: LD_VAR 0 3
95205: PUSH
95206: LD_INT 109
95208: EQUAL
95209: IFFALSE 95219
// sBetray := true ;
95211: LD_ADDR_EXP 156
95215: PUSH
95216: LD_INT 1
95218: ST_TO_ADDR
// if p3 = 110 then
95219: LD_VAR 0 3
95223: PUSH
95224: LD_INT 110
95226: EQUAL
95227: IFFALSE 95237
// sContamin := true ;
95229: LD_ADDR_EXP 157
95233: PUSH
95234: LD_INT 1
95236: ST_TO_ADDR
// if p3 = 111 then
95237: LD_VAR 0 3
95241: PUSH
95242: LD_INT 111
95244: EQUAL
95245: IFFALSE 95255
// sOil := true ;
95247: LD_ADDR_EXP 159
95251: PUSH
95252: LD_INT 1
95254: ST_TO_ADDR
// if p3 = 112 then
95255: LD_VAR 0 3
95259: PUSH
95260: LD_INT 112
95262: EQUAL
95263: IFFALSE 95273
// sStu := true ;
95265: LD_ADDR_EXP 163
95269: PUSH
95270: LD_INT 1
95272: ST_TO_ADDR
// if p3 = 113 then
95273: LD_VAR 0 3
95277: PUSH
95278: LD_INT 113
95280: EQUAL
95281: IFFALSE 95291
// sBazooka := true ;
95283: LD_ADDR_EXP 166
95287: PUSH
95288: LD_INT 1
95290: ST_TO_ADDR
// if p3 = 114 then
95291: LD_VAR 0 3
95295: PUSH
95296: LD_INT 114
95298: EQUAL
95299: IFFALSE 95309
// sMortar := true ;
95301: LD_ADDR_EXP 167
95305: PUSH
95306: LD_INT 1
95308: ST_TO_ADDR
// if p3 = 115 then
95309: LD_VAR 0 3
95313: PUSH
95314: LD_INT 115
95316: EQUAL
95317: IFFALSE 95327
// sRanger := true ;
95319: LD_ADDR_EXP 177
95323: PUSH
95324: LD_INT 1
95326: ST_TO_ADDR
// if p3 = 116 then
95327: LD_VAR 0 3
95331: PUSH
95332: LD_INT 116
95334: EQUAL
95335: IFFALSE 95345
// sComputer := true ;
95337: LD_ADDR_EXP 178
95341: PUSH
95342: LD_INT 1
95344: ST_TO_ADDR
// if p3 = 117 then
95345: LD_VAR 0 3
95349: PUSH
95350: LD_INT 117
95352: EQUAL
95353: IFFALSE 95363
// s30 := true ;
95355: LD_ADDR_EXP 179
95359: PUSH
95360: LD_INT 1
95362: ST_TO_ADDR
// if p3 = 118 then
95363: LD_VAR 0 3
95367: PUSH
95368: LD_INT 118
95370: EQUAL
95371: IFFALSE 95381
// s60 := true ;
95373: LD_ADDR_EXP 180
95377: PUSH
95378: LD_INT 1
95380: ST_TO_ADDR
// end ; if p2 = hack_mode then
95381: LD_VAR 0 2
95385: PUSH
95386: LD_INT 101
95388: EQUAL
95389: IFFALSE 95517
// begin case p3 of 1 :
95391: LD_VAR 0 3
95395: PUSH
95396: LD_INT 1
95398: DOUBLE
95399: EQUAL
95400: IFTRUE 95404
95402: GO 95411
95404: POP
// hHackUnlimitedResources ; 2 :
95405: CALL 107664 0 0
95409: GO 95517
95411: LD_INT 2
95413: DOUBLE
95414: EQUAL
95415: IFTRUE 95419
95417: GO 95426
95419: POP
// hHackSetLevel10 ; 3 :
95420: CALL 107797 0 0
95424: GO 95517
95426: LD_INT 3
95428: DOUBLE
95429: EQUAL
95430: IFTRUE 95434
95432: GO 95441
95434: POP
// hHackSetLevel10YourUnits ; 4 :
95435: CALL 107882 0 0
95439: GO 95517
95441: LD_INT 4
95443: DOUBLE
95444: EQUAL
95445: IFTRUE 95449
95447: GO 95456
95449: POP
// hHackInvincible ; 5 :
95450: CALL 108330 0 0
95454: GO 95517
95456: LD_INT 5
95458: DOUBLE
95459: EQUAL
95460: IFTRUE 95464
95462: GO 95471
95464: POP
// hHackInvisible ; 6 :
95465: CALL 108441 0 0
95469: GO 95517
95471: LD_INT 6
95473: DOUBLE
95474: EQUAL
95475: IFTRUE 95479
95477: GO 95486
95479: POP
// hHackChangeYourSide ; 7 :
95480: CALL 108498 0 0
95484: GO 95517
95486: LD_INT 7
95488: DOUBLE
95489: EQUAL
95490: IFTRUE 95494
95492: GO 95501
95494: POP
// hHackChangeUnitSide ; 8 :
95495: CALL 108540 0 0
95499: GO 95517
95501: LD_INT 8
95503: DOUBLE
95504: EQUAL
95505: IFTRUE 95509
95507: GO 95516
95509: POP
// hHackFog ; end ;
95510: CALL 108641 0 0
95514: GO 95517
95516: POP
// end ; if p2 = game_save_mode then
95517: LD_VAR 0 2
95521: PUSH
95522: LD_INT 102
95524: EQUAL
95525: IFFALSE 95580
// begin if p3 = 1 then
95527: LD_VAR 0 3
95531: PUSH
95532: LD_INT 1
95534: EQUAL
95535: IFFALSE 95547
// globalGameSaveCounter := p4 ;
95537: LD_ADDR_EXP 123
95541: PUSH
95542: LD_VAR 0 4
95546: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
95547: LD_VAR 0 3
95551: PUSH
95552: LD_INT 2
95554: EQUAL
95555: PUSH
95556: LD_EXP 123
95560: AND
95561: IFFALSE 95580
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95563: LD_STRING setGameSaveCounter(
95565: PUSH
95566: LD_EXP 123
95570: STR
95571: PUSH
95572: LD_STRING )
95574: STR
95575: PPUSH
95576: CALL_OW 559
// end ; end ;
95580: LD_VAR 0 7
95584: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
95585: LD_INT 0
95587: PPUSH
// streamModeActive := false ;
95588: LD_ADDR_EXP 124
95592: PUSH
95593: LD_INT 0
95595: ST_TO_ADDR
// normalCounter := 36 ;
95596: LD_ADDR_EXP 125
95600: PUSH
95601: LD_INT 36
95603: ST_TO_ADDR
// hardcoreCounter := 18 ;
95604: LD_ADDR_EXP 126
95608: PUSH
95609: LD_INT 18
95611: ST_TO_ADDR
// sRocket := false ;
95612: LD_ADDR_EXP 129
95616: PUSH
95617: LD_INT 0
95619: ST_TO_ADDR
// sSpeed := false ;
95620: LD_ADDR_EXP 128
95624: PUSH
95625: LD_INT 0
95627: ST_TO_ADDR
// sEngine := false ;
95628: LD_ADDR_EXP 130
95632: PUSH
95633: LD_INT 0
95635: ST_TO_ADDR
// sSpec := false ;
95636: LD_ADDR_EXP 127
95640: PUSH
95641: LD_INT 0
95643: ST_TO_ADDR
// sLevel := false ;
95644: LD_ADDR_EXP 131
95648: PUSH
95649: LD_INT 0
95651: ST_TO_ADDR
// sArmoury := false ;
95652: LD_ADDR_EXP 132
95656: PUSH
95657: LD_INT 0
95659: ST_TO_ADDR
// sRadar := false ;
95660: LD_ADDR_EXP 133
95664: PUSH
95665: LD_INT 0
95667: ST_TO_ADDR
// sBunker := false ;
95668: LD_ADDR_EXP 134
95672: PUSH
95673: LD_INT 0
95675: ST_TO_ADDR
// sHack := false ;
95676: LD_ADDR_EXP 135
95680: PUSH
95681: LD_INT 0
95683: ST_TO_ADDR
// sFire := false ;
95684: LD_ADDR_EXP 136
95688: PUSH
95689: LD_INT 0
95691: ST_TO_ADDR
// sRefresh := false ;
95692: LD_ADDR_EXP 137
95696: PUSH
95697: LD_INT 0
95699: ST_TO_ADDR
// sExp := false ;
95700: LD_ADDR_EXP 138
95704: PUSH
95705: LD_INT 0
95707: ST_TO_ADDR
// sDepot := false ;
95708: LD_ADDR_EXP 139
95712: PUSH
95713: LD_INT 0
95715: ST_TO_ADDR
// sFlag := false ;
95716: LD_ADDR_EXP 140
95720: PUSH
95721: LD_INT 0
95723: ST_TO_ADDR
// sKamikadze := false ;
95724: LD_ADDR_EXP 148
95728: PUSH
95729: LD_INT 0
95731: ST_TO_ADDR
// sTroll := false ;
95732: LD_ADDR_EXP 149
95736: PUSH
95737: LD_INT 0
95739: ST_TO_ADDR
// sSlow := false ;
95740: LD_ADDR_EXP 150
95744: PUSH
95745: LD_INT 0
95747: ST_TO_ADDR
// sLack := false ;
95748: LD_ADDR_EXP 151
95752: PUSH
95753: LD_INT 0
95755: ST_TO_ADDR
// sTank := false ;
95756: LD_ADDR_EXP 153
95760: PUSH
95761: LD_INT 0
95763: ST_TO_ADDR
// sRemote := false ;
95764: LD_ADDR_EXP 154
95768: PUSH
95769: LD_INT 0
95771: ST_TO_ADDR
// sPowell := false ;
95772: LD_ADDR_EXP 155
95776: PUSH
95777: LD_INT 0
95779: ST_TO_ADDR
// sTeleport := false ;
95780: LD_ADDR_EXP 158
95784: PUSH
95785: LD_INT 0
95787: ST_TO_ADDR
// sOilTower := false ;
95788: LD_ADDR_EXP 160
95792: PUSH
95793: LD_INT 0
95795: ST_TO_ADDR
// sShovel := false ;
95796: LD_ADDR_EXP 161
95800: PUSH
95801: LD_INT 0
95803: ST_TO_ADDR
// sSheik := false ;
95804: LD_ADDR_EXP 162
95808: PUSH
95809: LD_INT 0
95811: ST_TO_ADDR
// sEarthquake := false ;
95812: LD_ADDR_EXP 164
95816: PUSH
95817: LD_INT 0
95819: ST_TO_ADDR
// sAI := false ;
95820: LD_ADDR_EXP 165
95824: PUSH
95825: LD_INT 0
95827: ST_TO_ADDR
// sCargo := false ;
95828: LD_ADDR_EXP 168
95832: PUSH
95833: LD_INT 0
95835: ST_TO_ADDR
// sDLaser := false ;
95836: LD_ADDR_EXP 169
95840: PUSH
95841: LD_INT 0
95843: ST_TO_ADDR
// sExchange := false ;
95844: LD_ADDR_EXP 170
95848: PUSH
95849: LD_INT 0
95851: ST_TO_ADDR
// sFac := false ;
95852: LD_ADDR_EXP 171
95856: PUSH
95857: LD_INT 0
95859: ST_TO_ADDR
// sPower := false ;
95860: LD_ADDR_EXP 172
95864: PUSH
95865: LD_INT 0
95867: ST_TO_ADDR
// sRandom := false ;
95868: LD_ADDR_EXP 173
95872: PUSH
95873: LD_INT 0
95875: ST_TO_ADDR
// sShield := false ;
95876: LD_ADDR_EXP 174
95880: PUSH
95881: LD_INT 0
95883: ST_TO_ADDR
// sTime := false ;
95884: LD_ADDR_EXP 175
95888: PUSH
95889: LD_INT 0
95891: ST_TO_ADDR
// sTools := false ;
95892: LD_ADDR_EXP 176
95896: PUSH
95897: LD_INT 0
95899: ST_TO_ADDR
// sSold := false ;
95900: LD_ADDR_EXP 141
95904: PUSH
95905: LD_INT 0
95907: ST_TO_ADDR
// sDiff := false ;
95908: LD_ADDR_EXP 142
95912: PUSH
95913: LD_INT 0
95915: ST_TO_ADDR
// sFog := false ;
95916: LD_ADDR_EXP 145
95920: PUSH
95921: LD_INT 0
95923: ST_TO_ADDR
// sReset := false ;
95924: LD_ADDR_EXP 146
95928: PUSH
95929: LD_INT 0
95931: ST_TO_ADDR
// sSun := false ;
95932: LD_ADDR_EXP 147
95936: PUSH
95937: LD_INT 0
95939: ST_TO_ADDR
// sTiger := false ;
95940: LD_ADDR_EXP 143
95944: PUSH
95945: LD_INT 0
95947: ST_TO_ADDR
// sBomb := false ;
95948: LD_ADDR_EXP 144
95952: PUSH
95953: LD_INT 0
95955: ST_TO_ADDR
// sWound := false ;
95956: LD_ADDR_EXP 152
95960: PUSH
95961: LD_INT 0
95963: ST_TO_ADDR
// sBetray := false ;
95964: LD_ADDR_EXP 156
95968: PUSH
95969: LD_INT 0
95971: ST_TO_ADDR
// sContamin := false ;
95972: LD_ADDR_EXP 157
95976: PUSH
95977: LD_INT 0
95979: ST_TO_ADDR
// sOil := false ;
95980: LD_ADDR_EXP 159
95984: PUSH
95985: LD_INT 0
95987: ST_TO_ADDR
// sStu := false ;
95988: LD_ADDR_EXP 163
95992: PUSH
95993: LD_INT 0
95995: ST_TO_ADDR
// sBazooka := false ;
95996: LD_ADDR_EXP 166
96000: PUSH
96001: LD_INT 0
96003: ST_TO_ADDR
// sMortar := false ;
96004: LD_ADDR_EXP 167
96008: PUSH
96009: LD_INT 0
96011: ST_TO_ADDR
// sRanger := false ;
96012: LD_ADDR_EXP 177
96016: PUSH
96017: LD_INT 0
96019: ST_TO_ADDR
// sComputer := false ;
96020: LD_ADDR_EXP 178
96024: PUSH
96025: LD_INT 0
96027: ST_TO_ADDR
// s30 := false ;
96028: LD_ADDR_EXP 179
96032: PUSH
96033: LD_INT 0
96035: ST_TO_ADDR
// s60 := false ;
96036: LD_ADDR_EXP 180
96040: PUSH
96041: LD_INT 0
96043: ST_TO_ADDR
// end ;
96044: LD_VAR 0 1
96048: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96049: LD_INT 0
96051: PPUSH
96052: PPUSH
96053: PPUSH
96054: PPUSH
96055: PPUSH
96056: PPUSH
96057: PPUSH
// result := [ ] ;
96058: LD_ADDR_VAR 0 2
96062: PUSH
96063: EMPTY
96064: ST_TO_ADDR
// if campaign_id = 1 then
96065: LD_OWVAR 69
96069: PUSH
96070: LD_INT 1
96072: EQUAL
96073: IFFALSE 99239
// begin case mission_number of 1 :
96075: LD_OWVAR 70
96079: PUSH
96080: LD_INT 1
96082: DOUBLE
96083: EQUAL
96084: IFTRUE 96088
96086: GO 96164
96088: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96089: LD_ADDR_VAR 0 2
96093: PUSH
96094: LD_INT 2
96096: PUSH
96097: LD_INT 4
96099: PUSH
96100: LD_INT 11
96102: PUSH
96103: LD_INT 12
96105: PUSH
96106: LD_INT 15
96108: PUSH
96109: LD_INT 16
96111: PUSH
96112: LD_INT 22
96114: PUSH
96115: LD_INT 23
96117: PUSH
96118: LD_INT 26
96120: PUSH
96121: EMPTY
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: PUSH
96132: LD_INT 101
96134: PUSH
96135: LD_INT 102
96137: PUSH
96138: LD_INT 106
96140: PUSH
96141: LD_INT 116
96143: PUSH
96144: LD_INT 117
96146: PUSH
96147: LD_INT 118
96149: PUSH
96150: EMPTY
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: PUSH
96158: EMPTY
96159: LIST
96160: LIST
96161: ST_TO_ADDR
96162: GO 99237
96164: LD_INT 2
96166: DOUBLE
96167: EQUAL
96168: IFTRUE 96172
96170: GO 96256
96172: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96173: LD_ADDR_VAR 0 2
96177: PUSH
96178: LD_INT 2
96180: PUSH
96181: LD_INT 4
96183: PUSH
96184: LD_INT 11
96186: PUSH
96187: LD_INT 12
96189: PUSH
96190: LD_INT 15
96192: PUSH
96193: LD_INT 16
96195: PUSH
96196: LD_INT 22
96198: PUSH
96199: LD_INT 23
96201: PUSH
96202: LD_INT 26
96204: PUSH
96205: EMPTY
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: PUSH
96216: LD_INT 101
96218: PUSH
96219: LD_INT 102
96221: PUSH
96222: LD_INT 105
96224: PUSH
96225: LD_INT 106
96227: PUSH
96228: LD_INT 108
96230: PUSH
96231: LD_INT 116
96233: PUSH
96234: LD_INT 117
96236: PUSH
96237: LD_INT 118
96239: PUSH
96240: EMPTY
96241: LIST
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: PUSH
96250: EMPTY
96251: LIST
96252: LIST
96253: ST_TO_ADDR
96254: GO 99237
96256: LD_INT 3
96258: DOUBLE
96259: EQUAL
96260: IFTRUE 96264
96262: GO 96352
96264: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96265: LD_ADDR_VAR 0 2
96269: PUSH
96270: LD_INT 2
96272: PUSH
96273: LD_INT 4
96275: PUSH
96276: LD_INT 5
96278: PUSH
96279: LD_INT 11
96281: PUSH
96282: LD_INT 12
96284: PUSH
96285: LD_INT 15
96287: PUSH
96288: LD_INT 16
96290: PUSH
96291: LD_INT 22
96293: PUSH
96294: LD_INT 26
96296: PUSH
96297: LD_INT 36
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: PUSH
96312: LD_INT 101
96314: PUSH
96315: LD_INT 102
96317: PUSH
96318: LD_INT 105
96320: PUSH
96321: LD_INT 106
96323: PUSH
96324: LD_INT 108
96326: PUSH
96327: LD_INT 116
96329: PUSH
96330: LD_INT 117
96332: PUSH
96333: LD_INT 118
96335: PUSH
96336: EMPTY
96337: LIST
96338: LIST
96339: LIST
96340: LIST
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: PUSH
96346: EMPTY
96347: LIST
96348: LIST
96349: ST_TO_ADDR
96350: GO 99237
96352: LD_INT 4
96354: DOUBLE
96355: EQUAL
96356: IFTRUE 96360
96358: GO 96456
96360: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96361: LD_ADDR_VAR 0 2
96365: PUSH
96366: LD_INT 2
96368: PUSH
96369: LD_INT 4
96371: PUSH
96372: LD_INT 5
96374: PUSH
96375: LD_INT 8
96377: PUSH
96378: LD_INT 11
96380: PUSH
96381: LD_INT 12
96383: PUSH
96384: LD_INT 15
96386: PUSH
96387: LD_INT 16
96389: PUSH
96390: LD_INT 22
96392: PUSH
96393: LD_INT 23
96395: PUSH
96396: LD_INT 26
96398: PUSH
96399: LD_INT 36
96401: PUSH
96402: EMPTY
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: PUSH
96416: LD_INT 101
96418: PUSH
96419: LD_INT 102
96421: PUSH
96422: LD_INT 105
96424: PUSH
96425: LD_INT 106
96427: PUSH
96428: LD_INT 108
96430: PUSH
96431: LD_INT 116
96433: PUSH
96434: LD_INT 117
96436: PUSH
96437: LD_INT 118
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: PUSH
96450: EMPTY
96451: LIST
96452: LIST
96453: ST_TO_ADDR
96454: GO 99237
96456: LD_INT 5
96458: DOUBLE
96459: EQUAL
96460: IFTRUE 96464
96462: GO 96576
96464: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96465: LD_ADDR_VAR 0 2
96469: PUSH
96470: LD_INT 2
96472: PUSH
96473: LD_INT 4
96475: PUSH
96476: LD_INT 5
96478: PUSH
96479: LD_INT 6
96481: PUSH
96482: LD_INT 8
96484: PUSH
96485: LD_INT 11
96487: PUSH
96488: LD_INT 12
96490: PUSH
96491: LD_INT 15
96493: PUSH
96494: LD_INT 16
96496: PUSH
96497: LD_INT 22
96499: PUSH
96500: LD_INT 23
96502: PUSH
96503: LD_INT 25
96505: PUSH
96506: LD_INT 26
96508: PUSH
96509: LD_INT 36
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: PUSH
96528: LD_INT 101
96530: PUSH
96531: LD_INT 102
96533: PUSH
96534: LD_INT 105
96536: PUSH
96537: LD_INT 106
96539: PUSH
96540: LD_INT 108
96542: PUSH
96543: LD_INT 109
96545: PUSH
96546: LD_INT 112
96548: PUSH
96549: LD_INT 116
96551: PUSH
96552: LD_INT 117
96554: PUSH
96555: LD_INT 118
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: PUSH
96570: EMPTY
96571: LIST
96572: LIST
96573: ST_TO_ADDR
96574: GO 99237
96576: LD_INT 6
96578: DOUBLE
96579: EQUAL
96580: IFTRUE 96584
96582: GO 96716
96584: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96585: LD_ADDR_VAR 0 2
96589: PUSH
96590: LD_INT 2
96592: PUSH
96593: LD_INT 4
96595: PUSH
96596: LD_INT 5
96598: PUSH
96599: LD_INT 6
96601: PUSH
96602: LD_INT 8
96604: PUSH
96605: LD_INT 11
96607: PUSH
96608: LD_INT 12
96610: PUSH
96611: LD_INT 15
96613: PUSH
96614: LD_INT 16
96616: PUSH
96617: LD_INT 20
96619: PUSH
96620: LD_INT 21
96622: PUSH
96623: LD_INT 22
96625: PUSH
96626: LD_INT 23
96628: PUSH
96629: LD_INT 25
96631: PUSH
96632: LD_INT 26
96634: PUSH
96635: LD_INT 30
96637: PUSH
96638: LD_INT 31
96640: PUSH
96641: LD_INT 32
96643: PUSH
96644: LD_INT 36
96646: PUSH
96647: EMPTY
96648: LIST
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: PUSH
96668: LD_INT 101
96670: PUSH
96671: LD_INT 102
96673: PUSH
96674: LD_INT 105
96676: PUSH
96677: LD_INT 106
96679: PUSH
96680: LD_INT 108
96682: PUSH
96683: LD_INT 109
96685: PUSH
96686: LD_INT 112
96688: PUSH
96689: LD_INT 116
96691: PUSH
96692: LD_INT 117
96694: PUSH
96695: LD_INT 118
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: PUSH
96710: EMPTY
96711: LIST
96712: LIST
96713: ST_TO_ADDR
96714: GO 99237
96716: LD_INT 7
96718: DOUBLE
96719: EQUAL
96720: IFTRUE 96724
96722: GO 96836
96724: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
96725: LD_ADDR_VAR 0 2
96729: PUSH
96730: LD_INT 2
96732: PUSH
96733: LD_INT 4
96735: PUSH
96736: LD_INT 5
96738: PUSH
96739: LD_INT 7
96741: PUSH
96742: LD_INT 11
96744: PUSH
96745: LD_INT 12
96747: PUSH
96748: LD_INT 15
96750: PUSH
96751: LD_INT 16
96753: PUSH
96754: LD_INT 20
96756: PUSH
96757: LD_INT 21
96759: PUSH
96760: LD_INT 22
96762: PUSH
96763: LD_INT 23
96765: PUSH
96766: LD_INT 25
96768: PUSH
96769: LD_INT 26
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: LIST
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: PUSH
96788: LD_INT 101
96790: PUSH
96791: LD_INT 102
96793: PUSH
96794: LD_INT 103
96796: PUSH
96797: LD_INT 105
96799: PUSH
96800: LD_INT 106
96802: PUSH
96803: LD_INT 108
96805: PUSH
96806: LD_INT 112
96808: PUSH
96809: LD_INT 116
96811: PUSH
96812: LD_INT 117
96814: PUSH
96815: LD_INT 118
96817: PUSH
96818: EMPTY
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: ST_TO_ADDR
96834: GO 99237
96836: LD_INT 8
96838: DOUBLE
96839: EQUAL
96840: IFTRUE 96844
96842: GO 96984
96844: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
96845: LD_ADDR_VAR 0 2
96849: PUSH
96850: LD_INT 2
96852: PUSH
96853: LD_INT 4
96855: PUSH
96856: LD_INT 5
96858: PUSH
96859: LD_INT 6
96861: PUSH
96862: LD_INT 7
96864: PUSH
96865: LD_INT 8
96867: PUSH
96868: LD_INT 11
96870: PUSH
96871: LD_INT 12
96873: PUSH
96874: LD_INT 15
96876: PUSH
96877: LD_INT 16
96879: PUSH
96880: LD_INT 20
96882: PUSH
96883: LD_INT 21
96885: PUSH
96886: LD_INT 22
96888: PUSH
96889: LD_INT 23
96891: PUSH
96892: LD_INT 25
96894: PUSH
96895: LD_INT 26
96897: PUSH
96898: LD_INT 30
96900: PUSH
96901: LD_INT 31
96903: PUSH
96904: LD_INT 32
96906: PUSH
96907: LD_INT 36
96909: PUSH
96910: EMPTY
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: LIST
96919: LIST
96920: LIST
96921: LIST
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: PUSH
96932: LD_INT 101
96934: PUSH
96935: LD_INT 102
96937: PUSH
96938: LD_INT 103
96940: PUSH
96941: LD_INT 105
96943: PUSH
96944: LD_INT 106
96946: PUSH
96947: LD_INT 108
96949: PUSH
96950: LD_INT 109
96952: PUSH
96953: LD_INT 112
96955: PUSH
96956: LD_INT 116
96958: PUSH
96959: LD_INT 117
96961: PUSH
96962: LD_INT 118
96964: PUSH
96965: EMPTY
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: PUSH
96978: EMPTY
96979: LIST
96980: LIST
96981: ST_TO_ADDR
96982: GO 99237
96984: LD_INT 9
96986: DOUBLE
96987: EQUAL
96988: IFTRUE 96992
96990: GO 97140
96992: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96993: LD_ADDR_VAR 0 2
96997: PUSH
96998: LD_INT 2
97000: PUSH
97001: LD_INT 4
97003: PUSH
97004: LD_INT 5
97006: PUSH
97007: LD_INT 6
97009: PUSH
97010: LD_INT 7
97012: PUSH
97013: LD_INT 8
97015: PUSH
97016: LD_INT 11
97018: PUSH
97019: LD_INT 12
97021: PUSH
97022: LD_INT 15
97024: PUSH
97025: LD_INT 16
97027: PUSH
97028: LD_INT 20
97030: PUSH
97031: LD_INT 21
97033: PUSH
97034: LD_INT 22
97036: PUSH
97037: LD_INT 23
97039: PUSH
97040: LD_INT 25
97042: PUSH
97043: LD_INT 26
97045: PUSH
97046: LD_INT 28
97048: PUSH
97049: LD_INT 30
97051: PUSH
97052: LD_INT 31
97054: PUSH
97055: LD_INT 32
97057: PUSH
97058: LD_INT 36
97060: PUSH
97061: EMPTY
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: LIST
97072: LIST
97073: LIST
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: LIST
97079: LIST
97080: LIST
97081: LIST
97082: LIST
97083: PUSH
97084: LD_INT 101
97086: PUSH
97087: LD_INT 102
97089: PUSH
97090: LD_INT 103
97092: PUSH
97093: LD_INT 105
97095: PUSH
97096: LD_INT 106
97098: PUSH
97099: LD_INT 108
97101: PUSH
97102: LD_INT 109
97104: PUSH
97105: LD_INT 112
97107: PUSH
97108: LD_INT 114
97110: PUSH
97111: LD_INT 116
97113: PUSH
97114: LD_INT 117
97116: PUSH
97117: LD_INT 118
97119: PUSH
97120: EMPTY
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: PUSH
97134: EMPTY
97135: LIST
97136: LIST
97137: ST_TO_ADDR
97138: GO 99237
97140: LD_INT 10
97142: DOUBLE
97143: EQUAL
97144: IFTRUE 97148
97146: GO 97344
97148: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97149: LD_ADDR_VAR 0 2
97153: PUSH
97154: LD_INT 2
97156: PUSH
97157: LD_INT 4
97159: PUSH
97160: LD_INT 5
97162: PUSH
97163: LD_INT 6
97165: PUSH
97166: LD_INT 7
97168: PUSH
97169: LD_INT 8
97171: PUSH
97172: LD_INT 9
97174: PUSH
97175: LD_INT 10
97177: PUSH
97178: LD_INT 11
97180: PUSH
97181: LD_INT 12
97183: PUSH
97184: LD_INT 13
97186: PUSH
97187: LD_INT 14
97189: PUSH
97190: LD_INT 15
97192: PUSH
97193: LD_INT 16
97195: PUSH
97196: LD_INT 17
97198: PUSH
97199: LD_INT 18
97201: PUSH
97202: LD_INT 19
97204: PUSH
97205: LD_INT 20
97207: PUSH
97208: LD_INT 21
97210: PUSH
97211: LD_INT 22
97213: PUSH
97214: LD_INT 23
97216: PUSH
97217: LD_INT 24
97219: PUSH
97220: LD_INT 25
97222: PUSH
97223: LD_INT 26
97225: PUSH
97226: LD_INT 28
97228: PUSH
97229: LD_INT 30
97231: PUSH
97232: LD_INT 31
97234: PUSH
97235: LD_INT 32
97237: PUSH
97238: LD_INT 36
97240: PUSH
97241: EMPTY
97242: LIST
97243: LIST
97244: LIST
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: PUSH
97272: LD_INT 101
97274: PUSH
97275: LD_INT 102
97277: PUSH
97278: LD_INT 103
97280: PUSH
97281: LD_INT 104
97283: PUSH
97284: LD_INT 105
97286: PUSH
97287: LD_INT 106
97289: PUSH
97290: LD_INT 107
97292: PUSH
97293: LD_INT 108
97295: PUSH
97296: LD_INT 109
97298: PUSH
97299: LD_INT 110
97301: PUSH
97302: LD_INT 111
97304: PUSH
97305: LD_INT 112
97307: PUSH
97308: LD_INT 114
97310: PUSH
97311: LD_INT 116
97313: PUSH
97314: LD_INT 117
97316: PUSH
97317: LD_INT 118
97319: PUSH
97320: EMPTY
97321: LIST
97322: LIST
97323: LIST
97324: LIST
97325: LIST
97326: LIST
97327: LIST
97328: LIST
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: LIST
97337: PUSH
97338: EMPTY
97339: LIST
97340: LIST
97341: ST_TO_ADDR
97342: GO 99237
97344: LD_INT 11
97346: DOUBLE
97347: EQUAL
97348: IFTRUE 97352
97350: GO 97556
97352: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97353: LD_ADDR_VAR 0 2
97357: PUSH
97358: LD_INT 2
97360: PUSH
97361: LD_INT 3
97363: PUSH
97364: LD_INT 4
97366: PUSH
97367: LD_INT 5
97369: PUSH
97370: LD_INT 6
97372: PUSH
97373: LD_INT 7
97375: PUSH
97376: LD_INT 8
97378: PUSH
97379: LD_INT 9
97381: PUSH
97382: LD_INT 10
97384: PUSH
97385: LD_INT 11
97387: PUSH
97388: LD_INT 12
97390: PUSH
97391: LD_INT 13
97393: PUSH
97394: LD_INT 14
97396: PUSH
97397: LD_INT 15
97399: PUSH
97400: LD_INT 16
97402: PUSH
97403: LD_INT 17
97405: PUSH
97406: LD_INT 18
97408: PUSH
97409: LD_INT 19
97411: PUSH
97412: LD_INT 20
97414: PUSH
97415: LD_INT 21
97417: PUSH
97418: LD_INT 22
97420: PUSH
97421: LD_INT 23
97423: PUSH
97424: LD_INT 24
97426: PUSH
97427: LD_INT 25
97429: PUSH
97430: LD_INT 26
97432: PUSH
97433: LD_INT 28
97435: PUSH
97436: LD_INT 30
97438: PUSH
97439: LD_INT 31
97441: PUSH
97442: LD_INT 32
97444: PUSH
97445: LD_INT 34
97447: PUSH
97448: LD_INT 36
97450: PUSH
97451: EMPTY
97452: LIST
97453: LIST
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: PUSH
97484: LD_INT 101
97486: PUSH
97487: LD_INT 102
97489: PUSH
97490: LD_INT 103
97492: PUSH
97493: LD_INT 104
97495: PUSH
97496: LD_INT 105
97498: PUSH
97499: LD_INT 106
97501: PUSH
97502: LD_INT 107
97504: PUSH
97505: LD_INT 108
97507: PUSH
97508: LD_INT 109
97510: PUSH
97511: LD_INT 110
97513: PUSH
97514: LD_INT 111
97516: PUSH
97517: LD_INT 112
97519: PUSH
97520: LD_INT 114
97522: PUSH
97523: LD_INT 116
97525: PUSH
97526: LD_INT 117
97528: PUSH
97529: LD_INT 118
97531: PUSH
97532: EMPTY
97533: LIST
97534: LIST
97535: LIST
97536: LIST
97537: LIST
97538: LIST
97539: LIST
97540: LIST
97541: LIST
97542: LIST
97543: LIST
97544: LIST
97545: LIST
97546: LIST
97547: LIST
97548: LIST
97549: PUSH
97550: EMPTY
97551: LIST
97552: LIST
97553: ST_TO_ADDR
97554: GO 99237
97556: LD_INT 12
97558: DOUBLE
97559: EQUAL
97560: IFTRUE 97564
97562: GO 97784
97564: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97565: LD_ADDR_VAR 0 2
97569: PUSH
97570: LD_INT 1
97572: PUSH
97573: LD_INT 2
97575: PUSH
97576: LD_INT 3
97578: PUSH
97579: LD_INT 4
97581: PUSH
97582: LD_INT 5
97584: PUSH
97585: LD_INT 6
97587: PUSH
97588: LD_INT 7
97590: PUSH
97591: LD_INT 8
97593: PUSH
97594: LD_INT 9
97596: PUSH
97597: LD_INT 10
97599: PUSH
97600: LD_INT 11
97602: PUSH
97603: LD_INT 12
97605: PUSH
97606: LD_INT 13
97608: PUSH
97609: LD_INT 14
97611: PUSH
97612: LD_INT 15
97614: PUSH
97615: LD_INT 16
97617: PUSH
97618: LD_INT 17
97620: PUSH
97621: LD_INT 18
97623: PUSH
97624: LD_INT 19
97626: PUSH
97627: LD_INT 20
97629: PUSH
97630: LD_INT 21
97632: PUSH
97633: LD_INT 22
97635: PUSH
97636: LD_INT 23
97638: PUSH
97639: LD_INT 24
97641: PUSH
97642: LD_INT 25
97644: PUSH
97645: LD_INT 26
97647: PUSH
97648: LD_INT 27
97650: PUSH
97651: LD_INT 28
97653: PUSH
97654: LD_INT 30
97656: PUSH
97657: LD_INT 31
97659: PUSH
97660: LD_INT 32
97662: PUSH
97663: LD_INT 33
97665: PUSH
97666: LD_INT 34
97668: PUSH
97669: LD_INT 36
97671: PUSH
97672: EMPTY
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: PUSH
97708: LD_INT 101
97710: PUSH
97711: LD_INT 102
97713: PUSH
97714: LD_INT 103
97716: PUSH
97717: LD_INT 104
97719: PUSH
97720: LD_INT 105
97722: PUSH
97723: LD_INT 106
97725: PUSH
97726: LD_INT 107
97728: PUSH
97729: LD_INT 108
97731: PUSH
97732: LD_INT 109
97734: PUSH
97735: LD_INT 110
97737: PUSH
97738: LD_INT 111
97740: PUSH
97741: LD_INT 112
97743: PUSH
97744: LD_INT 113
97746: PUSH
97747: LD_INT 114
97749: PUSH
97750: LD_INT 116
97752: PUSH
97753: LD_INT 117
97755: PUSH
97756: LD_INT 118
97758: PUSH
97759: EMPTY
97760: LIST
97761: LIST
97762: LIST
97763: LIST
97764: LIST
97765: LIST
97766: LIST
97767: LIST
97768: LIST
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: PUSH
97778: EMPTY
97779: LIST
97780: LIST
97781: ST_TO_ADDR
97782: GO 99237
97784: LD_INT 13
97786: DOUBLE
97787: EQUAL
97788: IFTRUE 97792
97790: GO 98000
97792: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97793: LD_ADDR_VAR 0 2
97797: PUSH
97798: LD_INT 1
97800: PUSH
97801: LD_INT 2
97803: PUSH
97804: LD_INT 3
97806: PUSH
97807: LD_INT 4
97809: PUSH
97810: LD_INT 5
97812: PUSH
97813: LD_INT 8
97815: PUSH
97816: LD_INT 9
97818: PUSH
97819: LD_INT 10
97821: PUSH
97822: LD_INT 11
97824: PUSH
97825: LD_INT 12
97827: PUSH
97828: LD_INT 14
97830: PUSH
97831: LD_INT 15
97833: PUSH
97834: LD_INT 16
97836: PUSH
97837: LD_INT 17
97839: PUSH
97840: LD_INT 18
97842: PUSH
97843: LD_INT 19
97845: PUSH
97846: LD_INT 20
97848: PUSH
97849: LD_INT 21
97851: PUSH
97852: LD_INT 22
97854: PUSH
97855: LD_INT 23
97857: PUSH
97858: LD_INT 24
97860: PUSH
97861: LD_INT 25
97863: PUSH
97864: LD_INT 26
97866: PUSH
97867: LD_INT 27
97869: PUSH
97870: LD_INT 28
97872: PUSH
97873: LD_INT 30
97875: PUSH
97876: LD_INT 31
97878: PUSH
97879: LD_INT 32
97881: PUSH
97882: LD_INT 33
97884: PUSH
97885: LD_INT 34
97887: PUSH
97888: LD_INT 36
97890: PUSH
97891: EMPTY
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: PUSH
97924: LD_INT 101
97926: PUSH
97927: LD_INT 102
97929: PUSH
97930: LD_INT 103
97932: PUSH
97933: LD_INT 104
97935: PUSH
97936: LD_INT 105
97938: PUSH
97939: LD_INT 106
97941: PUSH
97942: LD_INT 107
97944: PUSH
97945: LD_INT 108
97947: PUSH
97948: LD_INT 109
97950: PUSH
97951: LD_INT 110
97953: PUSH
97954: LD_INT 111
97956: PUSH
97957: LD_INT 112
97959: PUSH
97960: LD_INT 113
97962: PUSH
97963: LD_INT 114
97965: PUSH
97966: LD_INT 116
97968: PUSH
97969: LD_INT 117
97971: PUSH
97972: LD_INT 118
97974: PUSH
97975: EMPTY
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: LIST
97988: LIST
97989: LIST
97990: LIST
97991: LIST
97992: LIST
97993: PUSH
97994: EMPTY
97995: LIST
97996: LIST
97997: ST_TO_ADDR
97998: GO 99237
98000: LD_INT 14
98002: DOUBLE
98003: EQUAL
98004: IFTRUE 98008
98006: GO 98232
98008: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98009: LD_ADDR_VAR 0 2
98013: PUSH
98014: LD_INT 1
98016: PUSH
98017: LD_INT 2
98019: PUSH
98020: LD_INT 3
98022: PUSH
98023: LD_INT 4
98025: PUSH
98026: LD_INT 5
98028: PUSH
98029: LD_INT 6
98031: PUSH
98032: LD_INT 7
98034: PUSH
98035: LD_INT 8
98037: PUSH
98038: LD_INT 9
98040: PUSH
98041: LD_INT 10
98043: PUSH
98044: LD_INT 11
98046: PUSH
98047: LD_INT 12
98049: PUSH
98050: LD_INT 13
98052: PUSH
98053: LD_INT 14
98055: PUSH
98056: LD_INT 15
98058: PUSH
98059: LD_INT 16
98061: PUSH
98062: LD_INT 17
98064: PUSH
98065: LD_INT 18
98067: PUSH
98068: LD_INT 19
98070: PUSH
98071: LD_INT 20
98073: PUSH
98074: LD_INT 21
98076: PUSH
98077: LD_INT 22
98079: PUSH
98080: LD_INT 23
98082: PUSH
98083: LD_INT 24
98085: PUSH
98086: LD_INT 25
98088: PUSH
98089: LD_INT 26
98091: PUSH
98092: LD_INT 27
98094: PUSH
98095: LD_INT 28
98097: PUSH
98098: LD_INT 29
98100: PUSH
98101: LD_INT 30
98103: PUSH
98104: LD_INT 31
98106: PUSH
98107: LD_INT 32
98109: PUSH
98110: LD_INT 33
98112: PUSH
98113: LD_INT 34
98115: PUSH
98116: LD_INT 36
98118: PUSH
98119: EMPTY
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: LIST
98128: LIST
98129: LIST
98130: LIST
98131: LIST
98132: LIST
98133: LIST
98134: LIST
98135: LIST
98136: LIST
98137: LIST
98138: LIST
98139: LIST
98140: LIST
98141: LIST
98142: LIST
98143: LIST
98144: LIST
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: LIST
98150: LIST
98151: LIST
98152: LIST
98153: LIST
98154: LIST
98155: PUSH
98156: LD_INT 101
98158: PUSH
98159: LD_INT 102
98161: PUSH
98162: LD_INT 103
98164: PUSH
98165: LD_INT 104
98167: PUSH
98168: LD_INT 105
98170: PUSH
98171: LD_INT 106
98173: PUSH
98174: LD_INT 107
98176: PUSH
98177: LD_INT 108
98179: PUSH
98180: LD_INT 109
98182: PUSH
98183: LD_INT 110
98185: PUSH
98186: LD_INT 111
98188: PUSH
98189: LD_INT 112
98191: PUSH
98192: LD_INT 113
98194: PUSH
98195: LD_INT 114
98197: PUSH
98198: LD_INT 116
98200: PUSH
98201: LD_INT 117
98203: PUSH
98204: LD_INT 118
98206: PUSH
98207: EMPTY
98208: LIST
98209: LIST
98210: LIST
98211: LIST
98212: LIST
98213: LIST
98214: LIST
98215: LIST
98216: LIST
98217: LIST
98218: LIST
98219: LIST
98220: LIST
98221: LIST
98222: LIST
98223: LIST
98224: LIST
98225: PUSH
98226: EMPTY
98227: LIST
98228: LIST
98229: ST_TO_ADDR
98230: GO 99237
98232: LD_INT 15
98234: DOUBLE
98235: EQUAL
98236: IFTRUE 98240
98238: GO 98464
98240: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98241: LD_ADDR_VAR 0 2
98245: PUSH
98246: LD_INT 1
98248: PUSH
98249: LD_INT 2
98251: PUSH
98252: LD_INT 3
98254: PUSH
98255: LD_INT 4
98257: PUSH
98258: LD_INT 5
98260: PUSH
98261: LD_INT 6
98263: PUSH
98264: LD_INT 7
98266: PUSH
98267: LD_INT 8
98269: PUSH
98270: LD_INT 9
98272: PUSH
98273: LD_INT 10
98275: PUSH
98276: LD_INT 11
98278: PUSH
98279: LD_INT 12
98281: PUSH
98282: LD_INT 13
98284: PUSH
98285: LD_INT 14
98287: PUSH
98288: LD_INT 15
98290: PUSH
98291: LD_INT 16
98293: PUSH
98294: LD_INT 17
98296: PUSH
98297: LD_INT 18
98299: PUSH
98300: LD_INT 19
98302: PUSH
98303: LD_INT 20
98305: PUSH
98306: LD_INT 21
98308: PUSH
98309: LD_INT 22
98311: PUSH
98312: LD_INT 23
98314: PUSH
98315: LD_INT 24
98317: PUSH
98318: LD_INT 25
98320: PUSH
98321: LD_INT 26
98323: PUSH
98324: LD_INT 27
98326: PUSH
98327: LD_INT 28
98329: PUSH
98330: LD_INT 29
98332: PUSH
98333: LD_INT 30
98335: PUSH
98336: LD_INT 31
98338: PUSH
98339: LD_INT 32
98341: PUSH
98342: LD_INT 33
98344: PUSH
98345: LD_INT 34
98347: PUSH
98348: LD_INT 36
98350: PUSH
98351: EMPTY
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: LIST
98360: LIST
98361: LIST
98362: LIST
98363: LIST
98364: LIST
98365: LIST
98366: LIST
98367: LIST
98368: LIST
98369: LIST
98370: LIST
98371: LIST
98372: LIST
98373: LIST
98374: LIST
98375: LIST
98376: LIST
98377: LIST
98378: LIST
98379: LIST
98380: LIST
98381: LIST
98382: LIST
98383: LIST
98384: LIST
98385: LIST
98386: LIST
98387: PUSH
98388: LD_INT 101
98390: PUSH
98391: LD_INT 102
98393: PUSH
98394: LD_INT 103
98396: PUSH
98397: LD_INT 104
98399: PUSH
98400: LD_INT 105
98402: PUSH
98403: LD_INT 106
98405: PUSH
98406: LD_INT 107
98408: PUSH
98409: LD_INT 108
98411: PUSH
98412: LD_INT 109
98414: PUSH
98415: LD_INT 110
98417: PUSH
98418: LD_INT 111
98420: PUSH
98421: LD_INT 112
98423: PUSH
98424: LD_INT 113
98426: PUSH
98427: LD_INT 114
98429: PUSH
98430: LD_INT 116
98432: PUSH
98433: LD_INT 117
98435: PUSH
98436: LD_INT 118
98438: PUSH
98439: EMPTY
98440: LIST
98441: LIST
98442: LIST
98443: LIST
98444: LIST
98445: LIST
98446: LIST
98447: LIST
98448: LIST
98449: LIST
98450: LIST
98451: LIST
98452: LIST
98453: LIST
98454: LIST
98455: LIST
98456: LIST
98457: PUSH
98458: EMPTY
98459: LIST
98460: LIST
98461: ST_TO_ADDR
98462: GO 99237
98464: LD_INT 16
98466: DOUBLE
98467: EQUAL
98468: IFTRUE 98472
98470: GO 98608
98472: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98473: LD_ADDR_VAR 0 2
98477: PUSH
98478: LD_INT 2
98480: PUSH
98481: LD_INT 4
98483: PUSH
98484: LD_INT 5
98486: PUSH
98487: LD_INT 7
98489: PUSH
98490: LD_INT 11
98492: PUSH
98493: LD_INT 12
98495: PUSH
98496: LD_INT 15
98498: PUSH
98499: LD_INT 16
98501: PUSH
98502: LD_INT 20
98504: PUSH
98505: LD_INT 21
98507: PUSH
98508: LD_INT 22
98510: PUSH
98511: LD_INT 23
98513: PUSH
98514: LD_INT 25
98516: PUSH
98517: LD_INT 26
98519: PUSH
98520: LD_INT 30
98522: PUSH
98523: LD_INT 31
98525: PUSH
98526: LD_INT 32
98528: PUSH
98529: LD_INT 33
98531: PUSH
98532: LD_INT 34
98534: PUSH
98535: EMPTY
98536: LIST
98537: LIST
98538: LIST
98539: LIST
98540: LIST
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: PUSH
98556: LD_INT 101
98558: PUSH
98559: LD_INT 102
98561: PUSH
98562: LD_INT 103
98564: PUSH
98565: LD_INT 106
98567: PUSH
98568: LD_INT 108
98570: PUSH
98571: LD_INT 112
98573: PUSH
98574: LD_INT 113
98576: PUSH
98577: LD_INT 114
98579: PUSH
98580: LD_INT 116
98582: PUSH
98583: LD_INT 117
98585: PUSH
98586: LD_INT 118
98588: PUSH
98589: EMPTY
98590: LIST
98591: LIST
98592: LIST
98593: LIST
98594: LIST
98595: LIST
98596: LIST
98597: LIST
98598: LIST
98599: LIST
98600: LIST
98601: PUSH
98602: EMPTY
98603: LIST
98604: LIST
98605: ST_TO_ADDR
98606: GO 99237
98608: LD_INT 17
98610: DOUBLE
98611: EQUAL
98612: IFTRUE 98616
98614: GO 98840
98616: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98617: LD_ADDR_VAR 0 2
98621: PUSH
98622: LD_INT 1
98624: PUSH
98625: LD_INT 2
98627: PUSH
98628: LD_INT 3
98630: PUSH
98631: LD_INT 4
98633: PUSH
98634: LD_INT 5
98636: PUSH
98637: LD_INT 6
98639: PUSH
98640: LD_INT 7
98642: PUSH
98643: LD_INT 8
98645: PUSH
98646: LD_INT 9
98648: PUSH
98649: LD_INT 10
98651: PUSH
98652: LD_INT 11
98654: PUSH
98655: LD_INT 12
98657: PUSH
98658: LD_INT 13
98660: PUSH
98661: LD_INT 14
98663: PUSH
98664: LD_INT 15
98666: PUSH
98667: LD_INT 16
98669: PUSH
98670: LD_INT 17
98672: PUSH
98673: LD_INT 18
98675: PUSH
98676: LD_INT 19
98678: PUSH
98679: LD_INT 20
98681: PUSH
98682: LD_INT 21
98684: PUSH
98685: LD_INT 22
98687: PUSH
98688: LD_INT 23
98690: PUSH
98691: LD_INT 24
98693: PUSH
98694: LD_INT 25
98696: PUSH
98697: LD_INT 26
98699: PUSH
98700: LD_INT 27
98702: PUSH
98703: LD_INT 28
98705: PUSH
98706: LD_INT 29
98708: PUSH
98709: LD_INT 30
98711: PUSH
98712: LD_INT 31
98714: PUSH
98715: LD_INT 32
98717: PUSH
98718: LD_INT 33
98720: PUSH
98721: LD_INT 34
98723: PUSH
98724: LD_INT 36
98726: PUSH
98727: EMPTY
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: LIST
98762: LIST
98763: PUSH
98764: LD_INT 101
98766: PUSH
98767: LD_INT 102
98769: PUSH
98770: LD_INT 103
98772: PUSH
98773: LD_INT 104
98775: PUSH
98776: LD_INT 105
98778: PUSH
98779: LD_INT 106
98781: PUSH
98782: LD_INT 107
98784: PUSH
98785: LD_INT 108
98787: PUSH
98788: LD_INT 109
98790: PUSH
98791: LD_INT 110
98793: PUSH
98794: LD_INT 111
98796: PUSH
98797: LD_INT 112
98799: PUSH
98800: LD_INT 113
98802: PUSH
98803: LD_INT 114
98805: PUSH
98806: LD_INT 116
98808: PUSH
98809: LD_INT 117
98811: PUSH
98812: LD_INT 118
98814: PUSH
98815: EMPTY
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: LIST
98830: LIST
98831: LIST
98832: LIST
98833: PUSH
98834: EMPTY
98835: LIST
98836: LIST
98837: ST_TO_ADDR
98838: GO 99237
98840: LD_INT 18
98842: DOUBLE
98843: EQUAL
98844: IFTRUE 98848
98846: GO 98996
98848: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
98849: LD_ADDR_VAR 0 2
98853: PUSH
98854: LD_INT 2
98856: PUSH
98857: LD_INT 4
98859: PUSH
98860: LD_INT 5
98862: PUSH
98863: LD_INT 7
98865: PUSH
98866: LD_INT 11
98868: PUSH
98869: LD_INT 12
98871: PUSH
98872: LD_INT 15
98874: PUSH
98875: LD_INT 16
98877: PUSH
98878: LD_INT 20
98880: PUSH
98881: LD_INT 21
98883: PUSH
98884: LD_INT 22
98886: PUSH
98887: LD_INT 23
98889: PUSH
98890: LD_INT 25
98892: PUSH
98893: LD_INT 26
98895: PUSH
98896: LD_INT 30
98898: PUSH
98899: LD_INT 31
98901: PUSH
98902: LD_INT 32
98904: PUSH
98905: LD_INT 33
98907: PUSH
98908: LD_INT 34
98910: PUSH
98911: LD_INT 35
98913: PUSH
98914: LD_INT 36
98916: PUSH
98917: EMPTY
98918: LIST
98919: LIST
98920: LIST
98921: LIST
98922: LIST
98923: LIST
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: PUSH
98940: LD_INT 101
98942: PUSH
98943: LD_INT 102
98945: PUSH
98946: LD_INT 103
98948: PUSH
98949: LD_INT 106
98951: PUSH
98952: LD_INT 108
98954: PUSH
98955: LD_INT 112
98957: PUSH
98958: LD_INT 113
98960: PUSH
98961: LD_INT 114
98963: PUSH
98964: LD_INT 115
98966: PUSH
98967: LD_INT 116
98969: PUSH
98970: LD_INT 117
98972: PUSH
98973: LD_INT 118
98975: PUSH
98976: EMPTY
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: PUSH
98990: EMPTY
98991: LIST
98992: LIST
98993: ST_TO_ADDR
98994: GO 99237
98996: LD_INT 19
98998: DOUBLE
98999: EQUAL
99000: IFTRUE 99004
99002: GO 99236
99004: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99005: LD_ADDR_VAR 0 2
99009: PUSH
99010: LD_INT 1
99012: PUSH
99013: LD_INT 2
99015: PUSH
99016: LD_INT 3
99018: PUSH
99019: LD_INT 4
99021: PUSH
99022: LD_INT 5
99024: PUSH
99025: LD_INT 6
99027: PUSH
99028: LD_INT 7
99030: PUSH
99031: LD_INT 8
99033: PUSH
99034: LD_INT 9
99036: PUSH
99037: LD_INT 10
99039: PUSH
99040: LD_INT 11
99042: PUSH
99043: LD_INT 12
99045: PUSH
99046: LD_INT 13
99048: PUSH
99049: LD_INT 14
99051: PUSH
99052: LD_INT 15
99054: PUSH
99055: LD_INT 16
99057: PUSH
99058: LD_INT 17
99060: PUSH
99061: LD_INT 18
99063: PUSH
99064: LD_INT 19
99066: PUSH
99067: LD_INT 20
99069: PUSH
99070: LD_INT 21
99072: PUSH
99073: LD_INT 22
99075: PUSH
99076: LD_INT 23
99078: PUSH
99079: LD_INT 24
99081: PUSH
99082: LD_INT 25
99084: PUSH
99085: LD_INT 26
99087: PUSH
99088: LD_INT 27
99090: PUSH
99091: LD_INT 28
99093: PUSH
99094: LD_INT 29
99096: PUSH
99097: LD_INT 30
99099: PUSH
99100: LD_INT 31
99102: PUSH
99103: LD_INT 32
99105: PUSH
99106: LD_INT 33
99108: PUSH
99109: LD_INT 34
99111: PUSH
99112: LD_INT 35
99114: PUSH
99115: LD_INT 36
99117: PUSH
99118: EMPTY
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: LIST
99130: LIST
99131: LIST
99132: LIST
99133: LIST
99134: LIST
99135: LIST
99136: LIST
99137: LIST
99138: LIST
99139: LIST
99140: LIST
99141: LIST
99142: LIST
99143: LIST
99144: LIST
99145: LIST
99146: LIST
99147: LIST
99148: LIST
99149: LIST
99150: LIST
99151: LIST
99152: LIST
99153: LIST
99154: LIST
99155: PUSH
99156: LD_INT 101
99158: PUSH
99159: LD_INT 102
99161: PUSH
99162: LD_INT 103
99164: PUSH
99165: LD_INT 104
99167: PUSH
99168: LD_INT 105
99170: PUSH
99171: LD_INT 106
99173: PUSH
99174: LD_INT 107
99176: PUSH
99177: LD_INT 108
99179: PUSH
99180: LD_INT 109
99182: PUSH
99183: LD_INT 110
99185: PUSH
99186: LD_INT 111
99188: PUSH
99189: LD_INT 112
99191: PUSH
99192: LD_INT 113
99194: PUSH
99195: LD_INT 114
99197: PUSH
99198: LD_INT 115
99200: PUSH
99201: LD_INT 116
99203: PUSH
99204: LD_INT 117
99206: PUSH
99207: LD_INT 118
99209: PUSH
99210: EMPTY
99211: LIST
99212: LIST
99213: LIST
99214: LIST
99215: LIST
99216: LIST
99217: LIST
99218: LIST
99219: LIST
99220: LIST
99221: LIST
99222: LIST
99223: LIST
99224: LIST
99225: LIST
99226: LIST
99227: LIST
99228: LIST
99229: PUSH
99230: EMPTY
99231: LIST
99232: LIST
99233: ST_TO_ADDR
99234: GO 99237
99236: POP
// end else
99237: GO 99468
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99239: LD_ADDR_VAR 0 2
99243: PUSH
99244: LD_INT 1
99246: PUSH
99247: LD_INT 2
99249: PUSH
99250: LD_INT 3
99252: PUSH
99253: LD_INT 4
99255: PUSH
99256: LD_INT 5
99258: PUSH
99259: LD_INT 6
99261: PUSH
99262: LD_INT 7
99264: PUSH
99265: LD_INT 8
99267: PUSH
99268: LD_INT 9
99270: PUSH
99271: LD_INT 10
99273: PUSH
99274: LD_INT 11
99276: PUSH
99277: LD_INT 12
99279: PUSH
99280: LD_INT 13
99282: PUSH
99283: LD_INT 14
99285: PUSH
99286: LD_INT 15
99288: PUSH
99289: LD_INT 16
99291: PUSH
99292: LD_INT 17
99294: PUSH
99295: LD_INT 18
99297: PUSH
99298: LD_INT 19
99300: PUSH
99301: LD_INT 20
99303: PUSH
99304: LD_INT 21
99306: PUSH
99307: LD_INT 22
99309: PUSH
99310: LD_INT 23
99312: PUSH
99313: LD_INT 24
99315: PUSH
99316: LD_INT 25
99318: PUSH
99319: LD_INT 26
99321: PUSH
99322: LD_INT 27
99324: PUSH
99325: LD_INT 28
99327: PUSH
99328: LD_INT 29
99330: PUSH
99331: LD_INT 30
99333: PUSH
99334: LD_INT 31
99336: PUSH
99337: LD_INT 32
99339: PUSH
99340: LD_INT 33
99342: PUSH
99343: LD_INT 34
99345: PUSH
99346: LD_INT 35
99348: PUSH
99349: LD_INT 36
99351: PUSH
99352: EMPTY
99353: LIST
99354: LIST
99355: LIST
99356: LIST
99357: LIST
99358: LIST
99359: LIST
99360: LIST
99361: LIST
99362: LIST
99363: LIST
99364: LIST
99365: LIST
99366: LIST
99367: LIST
99368: LIST
99369: LIST
99370: LIST
99371: LIST
99372: LIST
99373: LIST
99374: LIST
99375: LIST
99376: LIST
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: LIST
99383: LIST
99384: LIST
99385: LIST
99386: LIST
99387: LIST
99388: LIST
99389: PUSH
99390: LD_INT 101
99392: PUSH
99393: LD_INT 102
99395: PUSH
99396: LD_INT 103
99398: PUSH
99399: LD_INT 104
99401: PUSH
99402: LD_INT 105
99404: PUSH
99405: LD_INT 106
99407: PUSH
99408: LD_INT 107
99410: PUSH
99411: LD_INT 108
99413: PUSH
99414: LD_INT 109
99416: PUSH
99417: LD_INT 110
99419: PUSH
99420: LD_INT 111
99422: PUSH
99423: LD_INT 112
99425: PUSH
99426: LD_INT 113
99428: PUSH
99429: LD_INT 114
99431: PUSH
99432: LD_INT 115
99434: PUSH
99435: LD_INT 116
99437: PUSH
99438: LD_INT 117
99440: PUSH
99441: LD_INT 118
99443: PUSH
99444: EMPTY
99445: LIST
99446: LIST
99447: LIST
99448: LIST
99449: LIST
99450: LIST
99451: LIST
99452: LIST
99453: LIST
99454: LIST
99455: LIST
99456: LIST
99457: LIST
99458: LIST
99459: LIST
99460: LIST
99461: LIST
99462: LIST
99463: PUSH
99464: EMPTY
99465: LIST
99466: LIST
99467: ST_TO_ADDR
// if result then
99468: LD_VAR 0 2
99472: IFFALSE 100258
// begin normal :=  ;
99474: LD_ADDR_VAR 0 5
99478: PUSH
99479: LD_STRING 
99481: ST_TO_ADDR
// hardcore :=  ;
99482: LD_ADDR_VAR 0 6
99486: PUSH
99487: LD_STRING 
99489: ST_TO_ADDR
// active :=  ;
99490: LD_ADDR_VAR 0 7
99494: PUSH
99495: LD_STRING 
99497: ST_TO_ADDR
// for i = 1 to normalCounter do
99498: LD_ADDR_VAR 0 8
99502: PUSH
99503: DOUBLE
99504: LD_INT 1
99506: DEC
99507: ST_TO_ADDR
99508: LD_EXP 125
99512: PUSH
99513: FOR_TO
99514: IFFALSE 99615
// begin tmp := 0 ;
99516: LD_ADDR_VAR 0 3
99520: PUSH
99521: LD_STRING 0
99523: ST_TO_ADDR
// if result [ 1 ] then
99524: LD_VAR 0 2
99528: PUSH
99529: LD_INT 1
99531: ARRAY
99532: IFFALSE 99597
// if result [ 1 ] [ 1 ] = i then
99534: LD_VAR 0 2
99538: PUSH
99539: LD_INT 1
99541: ARRAY
99542: PUSH
99543: LD_INT 1
99545: ARRAY
99546: PUSH
99547: LD_VAR 0 8
99551: EQUAL
99552: IFFALSE 99597
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99554: LD_ADDR_VAR 0 2
99558: PUSH
99559: LD_VAR 0 2
99563: PPUSH
99564: LD_INT 1
99566: PPUSH
99567: LD_VAR 0 2
99571: PUSH
99572: LD_INT 1
99574: ARRAY
99575: PPUSH
99576: LD_INT 1
99578: PPUSH
99579: CALL_OW 3
99583: PPUSH
99584: CALL_OW 1
99588: ST_TO_ADDR
// tmp := 1 ;
99589: LD_ADDR_VAR 0 3
99593: PUSH
99594: LD_STRING 1
99596: ST_TO_ADDR
// end ; normal := normal & tmp ;
99597: LD_ADDR_VAR 0 5
99601: PUSH
99602: LD_VAR 0 5
99606: PUSH
99607: LD_VAR 0 3
99611: STR
99612: ST_TO_ADDR
// end ;
99613: GO 99513
99615: POP
99616: POP
// for i = 1 to hardcoreCounter do
99617: LD_ADDR_VAR 0 8
99621: PUSH
99622: DOUBLE
99623: LD_INT 1
99625: DEC
99626: ST_TO_ADDR
99627: LD_EXP 126
99631: PUSH
99632: FOR_TO
99633: IFFALSE 99738
// begin tmp := 0 ;
99635: LD_ADDR_VAR 0 3
99639: PUSH
99640: LD_STRING 0
99642: ST_TO_ADDR
// if result [ 2 ] then
99643: LD_VAR 0 2
99647: PUSH
99648: LD_INT 2
99650: ARRAY
99651: IFFALSE 99720
// if result [ 2 ] [ 1 ] = 100 + i then
99653: LD_VAR 0 2
99657: PUSH
99658: LD_INT 2
99660: ARRAY
99661: PUSH
99662: LD_INT 1
99664: ARRAY
99665: PUSH
99666: LD_INT 100
99668: PUSH
99669: LD_VAR 0 8
99673: PLUS
99674: EQUAL
99675: IFFALSE 99720
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
99677: LD_ADDR_VAR 0 2
99681: PUSH
99682: LD_VAR 0 2
99686: PPUSH
99687: LD_INT 2
99689: PPUSH
99690: LD_VAR 0 2
99694: PUSH
99695: LD_INT 2
99697: ARRAY
99698: PPUSH
99699: LD_INT 1
99701: PPUSH
99702: CALL_OW 3
99706: PPUSH
99707: CALL_OW 1
99711: ST_TO_ADDR
// tmp := 1 ;
99712: LD_ADDR_VAR 0 3
99716: PUSH
99717: LD_STRING 1
99719: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
99720: LD_ADDR_VAR 0 6
99724: PUSH
99725: LD_VAR 0 6
99729: PUSH
99730: LD_VAR 0 3
99734: STR
99735: ST_TO_ADDR
// end ;
99736: GO 99632
99738: POP
99739: POP
// if isGameLoad then
99740: LD_VAR 0 1
99744: IFFALSE 100219
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99746: LD_ADDR_VAR 0 4
99750: PUSH
99751: LD_EXP 129
99755: PUSH
99756: LD_EXP 128
99760: PUSH
99761: LD_EXP 130
99765: PUSH
99766: LD_EXP 127
99770: PUSH
99771: LD_EXP 131
99775: PUSH
99776: LD_EXP 132
99780: PUSH
99781: LD_EXP 133
99785: PUSH
99786: LD_EXP 134
99790: PUSH
99791: LD_EXP 135
99795: PUSH
99796: LD_EXP 136
99800: PUSH
99801: LD_EXP 137
99805: PUSH
99806: LD_EXP 138
99810: PUSH
99811: LD_EXP 139
99815: PUSH
99816: LD_EXP 140
99820: PUSH
99821: LD_EXP 148
99825: PUSH
99826: LD_EXP 149
99830: PUSH
99831: LD_EXP 150
99835: PUSH
99836: LD_EXP 151
99840: PUSH
99841: LD_EXP 153
99845: PUSH
99846: LD_EXP 154
99850: PUSH
99851: LD_EXP 155
99855: PUSH
99856: LD_EXP 158
99860: PUSH
99861: LD_EXP 160
99865: PUSH
99866: LD_EXP 161
99870: PUSH
99871: LD_EXP 162
99875: PUSH
99876: LD_EXP 164
99880: PUSH
99881: LD_EXP 165
99885: PUSH
99886: LD_EXP 168
99890: PUSH
99891: LD_EXP 169
99895: PUSH
99896: LD_EXP 170
99900: PUSH
99901: LD_EXP 171
99905: PUSH
99906: LD_EXP 172
99910: PUSH
99911: LD_EXP 173
99915: PUSH
99916: LD_EXP 174
99920: PUSH
99921: LD_EXP 175
99925: PUSH
99926: LD_EXP 176
99930: PUSH
99931: LD_EXP 141
99935: PUSH
99936: LD_EXP 142
99940: PUSH
99941: LD_EXP 145
99945: PUSH
99946: LD_EXP 146
99950: PUSH
99951: LD_EXP 147
99955: PUSH
99956: LD_EXP 143
99960: PUSH
99961: LD_EXP 144
99965: PUSH
99966: LD_EXP 152
99970: PUSH
99971: LD_EXP 156
99975: PUSH
99976: LD_EXP 157
99980: PUSH
99981: LD_EXP 159
99985: PUSH
99986: LD_EXP 163
99990: PUSH
99991: LD_EXP 166
99995: PUSH
99996: LD_EXP 167
100000: PUSH
100001: LD_EXP 177
100005: PUSH
100006: LD_EXP 178
100010: PUSH
100011: LD_EXP 179
100015: PUSH
100016: LD_EXP 180
100020: PUSH
100021: EMPTY
100022: LIST
100023: LIST
100024: LIST
100025: LIST
100026: LIST
100027: LIST
100028: LIST
100029: LIST
100030: LIST
100031: LIST
100032: LIST
100033: LIST
100034: LIST
100035: LIST
100036: LIST
100037: LIST
100038: LIST
100039: LIST
100040: LIST
100041: LIST
100042: LIST
100043: LIST
100044: LIST
100045: LIST
100046: LIST
100047: LIST
100048: LIST
100049: LIST
100050: LIST
100051: LIST
100052: LIST
100053: LIST
100054: LIST
100055: LIST
100056: LIST
100057: LIST
100058: LIST
100059: LIST
100060: LIST
100061: LIST
100062: LIST
100063: LIST
100064: LIST
100065: LIST
100066: LIST
100067: LIST
100068: LIST
100069: LIST
100070: LIST
100071: LIST
100072: LIST
100073: LIST
100074: LIST
100075: LIST
100076: ST_TO_ADDR
// tmp :=  ;
100077: LD_ADDR_VAR 0 3
100081: PUSH
100082: LD_STRING 
100084: ST_TO_ADDR
// for i = 1 to normalCounter do
100085: LD_ADDR_VAR 0 8
100089: PUSH
100090: DOUBLE
100091: LD_INT 1
100093: DEC
100094: ST_TO_ADDR
100095: LD_EXP 125
100099: PUSH
100100: FOR_TO
100101: IFFALSE 100137
// begin if flags [ i ] then
100103: LD_VAR 0 4
100107: PUSH
100108: LD_VAR 0 8
100112: ARRAY
100113: IFFALSE 100135
// tmp := tmp & i & ; ;
100115: LD_ADDR_VAR 0 3
100119: PUSH
100120: LD_VAR 0 3
100124: PUSH
100125: LD_VAR 0 8
100129: STR
100130: PUSH
100131: LD_STRING ;
100133: STR
100134: ST_TO_ADDR
// end ;
100135: GO 100100
100137: POP
100138: POP
// for i = 1 to hardcoreCounter do
100139: LD_ADDR_VAR 0 8
100143: PUSH
100144: DOUBLE
100145: LD_INT 1
100147: DEC
100148: ST_TO_ADDR
100149: LD_EXP 126
100153: PUSH
100154: FOR_TO
100155: IFFALSE 100201
// begin if flags [ normalCounter + i ] then
100157: LD_VAR 0 4
100161: PUSH
100162: LD_EXP 125
100166: PUSH
100167: LD_VAR 0 8
100171: PLUS
100172: ARRAY
100173: IFFALSE 100199
// tmp := tmp & ( 100 + i ) & ; ;
100175: LD_ADDR_VAR 0 3
100179: PUSH
100180: LD_VAR 0 3
100184: PUSH
100185: LD_INT 100
100187: PUSH
100188: LD_VAR 0 8
100192: PLUS
100193: STR
100194: PUSH
100195: LD_STRING ;
100197: STR
100198: ST_TO_ADDR
// end ;
100199: GO 100154
100201: POP
100202: POP
// if tmp then
100203: LD_VAR 0 3
100207: IFFALSE 100219
// active := tmp ;
100209: LD_ADDR_VAR 0 7
100213: PUSH
100214: LD_VAR 0 3
100218: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100219: LD_STRING getStreamItemsFromMission("
100221: PUSH
100222: LD_VAR 0 5
100226: STR
100227: PUSH
100228: LD_STRING ","
100230: STR
100231: PUSH
100232: LD_VAR 0 6
100236: STR
100237: PUSH
100238: LD_STRING ","
100240: STR
100241: PUSH
100242: LD_VAR 0 7
100246: STR
100247: PUSH
100248: LD_STRING ")
100250: STR
100251: PPUSH
100252: CALL_OW 559
// end else
100256: GO 100265
// ToLua ( getStreamItemsFromMission("","","") ) ;
100258: LD_STRING getStreamItemsFromMission("","","")
100260: PPUSH
100261: CALL_OW 559
// end ;
100265: LD_VAR 0 2
100269: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100270: LD_EXP 124
100274: PUSH
100275: LD_EXP 129
100279: AND
100280: IFFALSE 100404
100282: GO 100284
100284: DISABLE
100285: LD_INT 0
100287: PPUSH
100288: PPUSH
// begin enable ;
100289: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100290: LD_ADDR_VAR 0 2
100294: PUSH
100295: LD_INT 22
100297: PUSH
100298: LD_OWVAR 2
100302: PUSH
100303: EMPTY
100304: LIST
100305: LIST
100306: PUSH
100307: LD_INT 2
100309: PUSH
100310: LD_INT 34
100312: PUSH
100313: LD_INT 7
100315: PUSH
100316: EMPTY
100317: LIST
100318: LIST
100319: PUSH
100320: LD_INT 34
100322: PUSH
100323: LD_INT 45
100325: PUSH
100326: EMPTY
100327: LIST
100328: LIST
100329: PUSH
100330: LD_INT 34
100332: PUSH
100333: LD_INT 28
100335: PUSH
100336: EMPTY
100337: LIST
100338: LIST
100339: PUSH
100340: LD_INT 34
100342: PUSH
100343: LD_INT 47
100345: PUSH
100346: EMPTY
100347: LIST
100348: LIST
100349: PUSH
100350: EMPTY
100351: LIST
100352: LIST
100353: LIST
100354: LIST
100355: LIST
100356: PUSH
100357: EMPTY
100358: LIST
100359: LIST
100360: PPUSH
100361: CALL_OW 69
100365: ST_TO_ADDR
// if not tmp then
100366: LD_VAR 0 2
100370: NOT
100371: IFFALSE 100375
// exit ;
100373: GO 100404
// for i in tmp do
100375: LD_ADDR_VAR 0 1
100379: PUSH
100380: LD_VAR 0 2
100384: PUSH
100385: FOR_IN
100386: IFFALSE 100402
// begin SetLives ( i , 0 ) ;
100388: LD_VAR 0 1
100392: PPUSH
100393: LD_INT 0
100395: PPUSH
100396: CALL_OW 234
// end ;
100400: GO 100385
100402: POP
100403: POP
// end ;
100404: PPOPN 2
100406: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100407: LD_EXP 124
100411: PUSH
100412: LD_EXP 130
100416: AND
100417: IFFALSE 100501
100419: GO 100421
100421: DISABLE
100422: LD_INT 0
100424: PPUSH
100425: PPUSH
// begin enable ;
100426: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100427: LD_ADDR_VAR 0 2
100431: PUSH
100432: LD_INT 22
100434: PUSH
100435: LD_OWVAR 2
100439: PUSH
100440: EMPTY
100441: LIST
100442: LIST
100443: PUSH
100444: LD_INT 32
100446: PUSH
100447: LD_INT 3
100449: PUSH
100450: EMPTY
100451: LIST
100452: LIST
100453: PUSH
100454: EMPTY
100455: LIST
100456: LIST
100457: PPUSH
100458: CALL_OW 69
100462: ST_TO_ADDR
// if not tmp then
100463: LD_VAR 0 2
100467: NOT
100468: IFFALSE 100472
// exit ;
100470: GO 100501
// for i in tmp do
100472: LD_ADDR_VAR 0 1
100476: PUSH
100477: LD_VAR 0 2
100481: PUSH
100482: FOR_IN
100483: IFFALSE 100499
// begin SetLives ( i , 0 ) ;
100485: LD_VAR 0 1
100489: PPUSH
100490: LD_INT 0
100492: PPUSH
100493: CALL_OW 234
// end ;
100497: GO 100482
100499: POP
100500: POP
// end ;
100501: PPOPN 2
100503: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100504: LD_EXP 124
100508: PUSH
100509: LD_EXP 127
100513: AND
100514: IFFALSE 100607
100516: GO 100518
100518: DISABLE
100519: LD_INT 0
100521: PPUSH
// begin enable ;
100522: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100523: LD_ADDR_VAR 0 1
100527: PUSH
100528: LD_INT 22
100530: PUSH
100531: LD_OWVAR 2
100535: PUSH
100536: EMPTY
100537: LIST
100538: LIST
100539: PUSH
100540: LD_INT 2
100542: PUSH
100543: LD_INT 25
100545: PUSH
100546: LD_INT 5
100548: PUSH
100549: EMPTY
100550: LIST
100551: LIST
100552: PUSH
100553: LD_INT 25
100555: PUSH
100556: LD_INT 9
100558: PUSH
100559: EMPTY
100560: LIST
100561: LIST
100562: PUSH
100563: LD_INT 25
100565: PUSH
100566: LD_INT 8
100568: PUSH
100569: EMPTY
100570: LIST
100571: LIST
100572: PUSH
100573: EMPTY
100574: LIST
100575: LIST
100576: LIST
100577: LIST
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: PPUSH
100583: CALL_OW 69
100587: PUSH
100588: FOR_IN
100589: IFFALSE 100605
// begin SetClass ( i , 1 ) ;
100591: LD_VAR 0 1
100595: PPUSH
100596: LD_INT 1
100598: PPUSH
100599: CALL_OW 336
// end ;
100603: GO 100588
100605: POP
100606: POP
// end ;
100607: PPOPN 1
100609: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100610: LD_EXP 124
100614: PUSH
100615: LD_EXP 128
100619: AND
100620: PUSH
100621: LD_OWVAR 65
100625: PUSH
100626: LD_INT 7
100628: LESS
100629: AND
100630: IFFALSE 100644
100632: GO 100634
100634: DISABLE
// begin enable ;
100635: ENABLE
// game_speed := 7 ;
100636: LD_ADDR_OWVAR 65
100640: PUSH
100641: LD_INT 7
100643: ST_TO_ADDR
// end ;
100644: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100645: LD_EXP 124
100649: PUSH
100650: LD_EXP 131
100654: AND
100655: IFFALSE 100857
100657: GO 100659
100659: DISABLE
100660: LD_INT 0
100662: PPUSH
100663: PPUSH
100664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100665: LD_ADDR_VAR 0 3
100669: PUSH
100670: LD_INT 81
100672: PUSH
100673: LD_OWVAR 2
100677: PUSH
100678: EMPTY
100679: LIST
100680: LIST
100681: PUSH
100682: LD_INT 21
100684: PUSH
100685: LD_INT 1
100687: PUSH
100688: EMPTY
100689: LIST
100690: LIST
100691: PUSH
100692: EMPTY
100693: LIST
100694: LIST
100695: PPUSH
100696: CALL_OW 69
100700: ST_TO_ADDR
// if not tmp then
100701: LD_VAR 0 3
100705: NOT
100706: IFFALSE 100710
// exit ;
100708: GO 100857
// if tmp > 5 then
100710: LD_VAR 0 3
100714: PUSH
100715: LD_INT 5
100717: GREATER
100718: IFFALSE 100730
// k := 5 else
100720: LD_ADDR_VAR 0 2
100724: PUSH
100725: LD_INT 5
100727: ST_TO_ADDR
100728: GO 100740
// k := tmp ;
100730: LD_ADDR_VAR 0 2
100734: PUSH
100735: LD_VAR 0 3
100739: ST_TO_ADDR
// for i := 1 to k do
100740: LD_ADDR_VAR 0 1
100744: PUSH
100745: DOUBLE
100746: LD_INT 1
100748: DEC
100749: ST_TO_ADDR
100750: LD_VAR 0 2
100754: PUSH
100755: FOR_TO
100756: IFFALSE 100855
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100758: LD_VAR 0 3
100762: PUSH
100763: LD_VAR 0 1
100767: ARRAY
100768: PPUSH
100769: LD_VAR 0 1
100773: PUSH
100774: LD_INT 4
100776: MOD
100777: PUSH
100778: LD_INT 1
100780: PLUS
100781: PPUSH
100782: CALL_OW 259
100786: PUSH
100787: LD_INT 10
100789: LESS
100790: IFFALSE 100853
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100792: LD_VAR 0 3
100796: PUSH
100797: LD_VAR 0 1
100801: ARRAY
100802: PPUSH
100803: LD_VAR 0 1
100807: PUSH
100808: LD_INT 4
100810: MOD
100811: PUSH
100812: LD_INT 1
100814: PLUS
100815: PPUSH
100816: LD_VAR 0 3
100820: PUSH
100821: LD_VAR 0 1
100825: ARRAY
100826: PPUSH
100827: LD_VAR 0 1
100831: PUSH
100832: LD_INT 4
100834: MOD
100835: PUSH
100836: LD_INT 1
100838: PLUS
100839: PPUSH
100840: CALL_OW 259
100844: PUSH
100845: LD_INT 1
100847: PLUS
100848: PPUSH
100849: CALL_OW 237
100853: GO 100755
100855: POP
100856: POP
// end ;
100857: PPOPN 3
100859: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
100860: LD_EXP 124
100864: PUSH
100865: LD_EXP 132
100869: AND
100870: IFFALSE 100890
100872: GO 100874
100874: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
100875: LD_INT 4
100877: PPUSH
100878: LD_OWVAR 2
100882: PPUSH
100883: LD_INT 0
100885: PPUSH
100886: CALL_OW 324
100890: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100891: LD_EXP 124
100895: PUSH
100896: LD_EXP 161
100900: AND
100901: IFFALSE 100921
100903: GO 100905
100905: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100906: LD_INT 19
100908: PPUSH
100909: LD_OWVAR 2
100913: PPUSH
100914: LD_INT 0
100916: PPUSH
100917: CALL_OW 324
100921: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100922: LD_EXP 124
100926: PUSH
100927: LD_EXP 133
100931: AND
100932: IFFALSE 101034
100934: GO 100936
100936: DISABLE
100937: LD_INT 0
100939: PPUSH
100940: PPUSH
// begin enable ;
100941: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100942: LD_ADDR_VAR 0 2
100946: PUSH
100947: LD_INT 22
100949: PUSH
100950: LD_OWVAR 2
100954: PUSH
100955: EMPTY
100956: LIST
100957: LIST
100958: PUSH
100959: LD_INT 2
100961: PUSH
100962: LD_INT 34
100964: PUSH
100965: LD_INT 11
100967: PUSH
100968: EMPTY
100969: LIST
100970: LIST
100971: PUSH
100972: LD_INT 34
100974: PUSH
100975: LD_INT 30
100977: PUSH
100978: EMPTY
100979: LIST
100980: LIST
100981: PUSH
100982: EMPTY
100983: LIST
100984: LIST
100985: LIST
100986: PUSH
100987: EMPTY
100988: LIST
100989: LIST
100990: PPUSH
100991: CALL_OW 69
100995: ST_TO_ADDR
// if not tmp then
100996: LD_VAR 0 2
101000: NOT
101001: IFFALSE 101005
// exit ;
101003: GO 101034
// for i in tmp do
101005: LD_ADDR_VAR 0 1
101009: PUSH
101010: LD_VAR 0 2
101014: PUSH
101015: FOR_IN
101016: IFFALSE 101032
// begin SetLives ( i , 0 ) ;
101018: LD_VAR 0 1
101022: PPUSH
101023: LD_INT 0
101025: PPUSH
101026: CALL_OW 234
// end ;
101030: GO 101015
101032: POP
101033: POP
// end ;
101034: PPOPN 2
101036: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101037: LD_EXP 124
101041: PUSH
101042: LD_EXP 134
101046: AND
101047: IFFALSE 101067
101049: GO 101051
101051: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101052: LD_INT 32
101054: PPUSH
101055: LD_OWVAR 2
101059: PPUSH
101060: LD_INT 0
101062: PPUSH
101063: CALL_OW 324
101067: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101068: LD_EXP 124
101072: PUSH
101073: LD_EXP 135
101077: AND
101078: IFFALSE 101259
101080: GO 101082
101082: DISABLE
101083: LD_INT 0
101085: PPUSH
101086: PPUSH
101087: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101088: LD_ADDR_VAR 0 2
101092: PUSH
101093: LD_INT 22
101095: PUSH
101096: LD_OWVAR 2
101100: PUSH
101101: EMPTY
101102: LIST
101103: LIST
101104: PUSH
101105: LD_INT 33
101107: PUSH
101108: LD_INT 3
101110: PUSH
101111: EMPTY
101112: LIST
101113: LIST
101114: PUSH
101115: EMPTY
101116: LIST
101117: LIST
101118: PPUSH
101119: CALL_OW 69
101123: ST_TO_ADDR
// if not tmp then
101124: LD_VAR 0 2
101128: NOT
101129: IFFALSE 101133
// exit ;
101131: GO 101259
// side := 0 ;
101133: LD_ADDR_VAR 0 3
101137: PUSH
101138: LD_INT 0
101140: ST_TO_ADDR
// for i := 1 to 8 do
101141: LD_ADDR_VAR 0 1
101145: PUSH
101146: DOUBLE
101147: LD_INT 1
101149: DEC
101150: ST_TO_ADDR
101151: LD_INT 8
101153: PUSH
101154: FOR_TO
101155: IFFALSE 101203
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101157: LD_OWVAR 2
101161: PUSH
101162: LD_VAR 0 1
101166: NONEQUAL
101167: PUSH
101168: LD_OWVAR 2
101172: PPUSH
101173: LD_VAR 0 1
101177: PPUSH
101178: CALL_OW 81
101182: PUSH
101183: LD_INT 2
101185: EQUAL
101186: AND
101187: IFFALSE 101201
// begin side := i ;
101189: LD_ADDR_VAR 0 3
101193: PUSH
101194: LD_VAR 0 1
101198: ST_TO_ADDR
// break ;
101199: GO 101203
// end ;
101201: GO 101154
101203: POP
101204: POP
// if not side then
101205: LD_VAR 0 3
101209: NOT
101210: IFFALSE 101214
// exit ;
101212: GO 101259
// for i := 1 to tmp do
101214: LD_ADDR_VAR 0 1
101218: PUSH
101219: DOUBLE
101220: LD_INT 1
101222: DEC
101223: ST_TO_ADDR
101224: LD_VAR 0 2
101228: PUSH
101229: FOR_TO
101230: IFFALSE 101257
// if Prob ( 60 ) then
101232: LD_INT 60
101234: PPUSH
101235: CALL_OW 13
101239: IFFALSE 101255
// SetSide ( i , side ) ;
101241: LD_VAR 0 1
101245: PPUSH
101246: LD_VAR 0 3
101250: PPUSH
101251: CALL_OW 235
101255: GO 101229
101257: POP
101258: POP
// end ;
101259: PPOPN 3
101261: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101262: LD_EXP 124
101266: PUSH
101267: LD_EXP 137
101271: AND
101272: IFFALSE 101391
101274: GO 101276
101276: DISABLE
101277: LD_INT 0
101279: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101280: LD_ADDR_VAR 0 1
101284: PUSH
101285: LD_INT 22
101287: PUSH
101288: LD_OWVAR 2
101292: PUSH
101293: EMPTY
101294: LIST
101295: LIST
101296: PUSH
101297: LD_INT 21
101299: PUSH
101300: LD_INT 1
101302: PUSH
101303: EMPTY
101304: LIST
101305: LIST
101306: PUSH
101307: LD_INT 3
101309: PUSH
101310: LD_INT 23
101312: PUSH
101313: LD_INT 0
101315: PUSH
101316: EMPTY
101317: LIST
101318: LIST
101319: PUSH
101320: EMPTY
101321: LIST
101322: LIST
101323: PUSH
101324: EMPTY
101325: LIST
101326: LIST
101327: LIST
101328: PPUSH
101329: CALL_OW 69
101333: PUSH
101334: FOR_IN
101335: IFFALSE 101389
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101337: LD_VAR 0 1
101341: PPUSH
101342: CALL_OW 257
101346: PUSH
101347: LD_INT 1
101349: PUSH
101350: LD_INT 2
101352: PUSH
101353: LD_INT 3
101355: PUSH
101356: LD_INT 4
101358: PUSH
101359: EMPTY
101360: LIST
101361: LIST
101362: LIST
101363: LIST
101364: IN
101365: IFFALSE 101387
// SetClass ( un , rand ( 1 , 4 ) ) ;
101367: LD_VAR 0 1
101371: PPUSH
101372: LD_INT 1
101374: PPUSH
101375: LD_INT 4
101377: PPUSH
101378: CALL_OW 12
101382: PPUSH
101383: CALL_OW 336
101387: GO 101334
101389: POP
101390: POP
// end ;
101391: PPOPN 1
101393: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101394: LD_EXP 124
101398: PUSH
101399: LD_EXP 136
101403: AND
101404: IFFALSE 101483
101406: GO 101408
101408: DISABLE
101409: LD_INT 0
101411: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101412: LD_ADDR_VAR 0 1
101416: PUSH
101417: LD_INT 22
101419: PUSH
101420: LD_OWVAR 2
101424: PUSH
101425: EMPTY
101426: LIST
101427: LIST
101428: PUSH
101429: LD_INT 21
101431: PUSH
101432: LD_INT 3
101434: PUSH
101435: EMPTY
101436: LIST
101437: LIST
101438: PUSH
101439: EMPTY
101440: LIST
101441: LIST
101442: PPUSH
101443: CALL_OW 69
101447: ST_TO_ADDR
// if not tmp then
101448: LD_VAR 0 1
101452: NOT
101453: IFFALSE 101457
// exit ;
101455: GO 101483
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101457: LD_VAR 0 1
101461: PUSH
101462: LD_INT 1
101464: PPUSH
101465: LD_VAR 0 1
101469: PPUSH
101470: CALL_OW 12
101474: ARRAY
101475: PPUSH
101476: LD_INT 100
101478: PPUSH
101479: CALL_OW 234
// end ;
101483: PPOPN 1
101485: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101486: LD_EXP 124
101490: PUSH
101491: LD_EXP 138
101495: AND
101496: IFFALSE 101594
101498: GO 101500
101500: DISABLE
101501: LD_INT 0
101503: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101504: LD_ADDR_VAR 0 1
101508: PUSH
101509: LD_INT 22
101511: PUSH
101512: LD_OWVAR 2
101516: PUSH
101517: EMPTY
101518: LIST
101519: LIST
101520: PUSH
101521: LD_INT 21
101523: PUSH
101524: LD_INT 1
101526: PUSH
101527: EMPTY
101528: LIST
101529: LIST
101530: PUSH
101531: EMPTY
101532: LIST
101533: LIST
101534: PPUSH
101535: CALL_OW 69
101539: ST_TO_ADDR
// if not tmp then
101540: LD_VAR 0 1
101544: NOT
101545: IFFALSE 101549
// exit ;
101547: GO 101594
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101549: LD_VAR 0 1
101553: PUSH
101554: LD_INT 1
101556: PPUSH
101557: LD_VAR 0 1
101561: PPUSH
101562: CALL_OW 12
101566: ARRAY
101567: PPUSH
101568: LD_INT 1
101570: PPUSH
101571: LD_INT 4
101573: PPUSH
101574: CALL_OW 12
101578: PPUSH
101579: LD_INT 3000
101581: PPUSH
101582: LD_INT 9000
101584: PPUSH
101585: CALL_OW 12
101589: PPUSH
101590: CALL_OW 492
// end ;
101594: PPOPN 1
101596: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101597: LD_EXP 124
101601: PUSH
101602: LD_EXP 139
101606: AND
101607: IFFALSE 101627
101609: GO 101611
101611: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101612: LD_INT 1
101614: PPUSH
101615: LD_OWVAR 2
101619: PPUSH
101620: LD_INT 0
101622: PPUSH
101623: CALL_OW 324
101627: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101628: LD_EXP 124
101632: PUSH
101633: LD_EXP 140
101637: AND
101638: IFFALSE 101721
101640: GO 101642
101642: DISABLE
101643: LD_INT 0
101645: PPUSH
101646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101647: LD_ADDR_VAR 0 2
101651: PUSH
101652: LD_INT 22
101654: PUSH
101655: LD_OWVAR 2
101659: PUSH
101660: EMPTY
101661: LIST
101662: LIST
101663: PUSH
101664: LD_INT 21
101666: PUSH
101667: LD_INT 3
101669: PUSH
101670: EMPTY
101671: LIST
101672: LIST
101673: PUSH
101674: EMPTY
101675: LIST
101676: LIST
101677: PPUSH
101678: CALL_OW 69
101682: ST_TO_ADDR
// if not tmp then
101683: LD_VAR 0 2
101687: NOT
101688: IFFALSE 101692
// exit ;
101690: GO 101721
// for i in tmp do
101692: LD_ADDR_VAR 0 1
101696: PUSH
101697: LD_VAR 0 2
101701: PUSH
101702: FOR_IN
101703: IFFALSE 101719
// SetBLevel ( i , 10 ) ;
101705: LD_VAR 0 1
101709: PPUSH
101710: LD_INT 10
101712: PPUSH
101713: CALL_OW 241
101717: GO 101702
101719: POP
101720: POP
// end ;
101721: PPOPN 2
101723: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
101724: LD_EXP 124
101728: PUSH
101729: LD_EXP 141
101733: AND
101734: IFFALSE 101845
101736: GO 101738
101738: DISABLE
101739: LD_INT 0
101741: PPUSH
101742: PPUSH
101743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101744: LD_ADDR_VAR 0 3
101748: PUSH
101749: LD_INT 22
101751: PUSH
101752: LD_OWVAR 2
101756: PUSH
101757: EMPTY
101758: LIST
101759: LIST
101760: PUSH
101761: LD_INT 25
101763: PUSH
101764: LD_INT 1
101766: PUSH
101767: EMPTY
101768: LIST
101769: LIST
101770: PUSH
101771: EMPTY
101772: LIST
101773: LIST
101774: PPUSH
101775: CALL_OW 69
101779: ST_TO_ADDR
// if not tmp then
101780: LD_VAR 0 3
101784: NOT
101785: IFFALSE 101789
// exit ;
101787: GO 101845
// un := tmp [ rand ( 1 , tmp ) ] ;
101789: LD_ADDR_VAR 0 2
101793: PUSH
101794: LD_VAR 0 3
101798: PUSH
101799: LD_INT 1
101801: PPUSH
101802: LD_VAR 0 3
101806: PPUSH
101807: CALL_OW 12
101811: ARRAY
101812: ST_TO_ADDR
// if Crawls ( un ) then
101813: LD_VAR 0 2
101817: PPUSH
101818: CALL_OW 318
101822: IFFALSE 101833
// ComWalk ( un ) ;
101824: LD_VAR 0 2
101828: PPUSH
101829: CALL_OW 138
// SetClass ( un , class_sniper ) ;
101833: LD_VAR 0 2
101837: PPUSH
101838: LD_INT 5
101840: PPUSH
101841: CALL_OW 336
// end ;
101845: PPOPN 3
101847: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
101848: LD_EXP 124
101852: PUSH
101853: LD_EXP 142
101857: AND
101858: PUSH
101859: LD_OWVAR 67
101863: PUSH
101864: LD_INT 4
101866: LESS
101867: AND
101868: IFFALSE 101887
101870: GO 101872
101872: DISABLE
// begin Difficulty := Difficulty + 1 ;
101873: LD_ADDR_OWVAR 67
101877: PUSH
101878: LD_OWVAR 67
101882: PUSH
101883: LD_INT 1
101885: PLUS
101886: ST_TO_ADDR
// end ;
101887: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101888: LD_EXP 124
101892: PUSH
101893: LD_EXP 143
101897: AND
101898: IFFALSE 102001
101900: GO 101902
101902: DISABLE
101903: LD_INT 0
101905: PPUSH
// begin for i := 1 to 5 do
101906: LD_ADDR_VAR 0 1
101910: PUSH
101911: DOUBLE
101912: LD_INT 1
101914: DEC
101915: ST_TO_ADDR
101916: LD_INT 5
101918: PUSH
101919: FOR_TO
101920: IFFALSE 101999
// begin uc_nation := nation_nature ;
101922: LD_ADDR_OWVAR 21
101926: PUSH
101927: LD_INT 0
101929: ST_TO_ADDR
// uc_side := 0 ;
101930: LD_ADDR_OWVAR 20
101934: PUSH
101935: LD_INT 0
101937: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101938: LD_ADDR_OWVAR 29
101942: PUSH
101943: LD_INT 12
101945: PUSH
101946: LD_INT 12
101948: PUSH
101949: EMPTY
101950: LIST
101951: LIST
101952: ST_TO_ADDR
// hc_agressivity := 20 ;
101953: LD_ADDR_OWVAR 35
101957: PUSH
101958: LD_INT 20
101960: ST_TO_ADDR
// hc_class := class_tiger ;
101961: LD_ADDR_OWVAR 28
101965: PUSH
101966: LD_INT 14
101968: ST_TO_ADDR
// hc_gallery :=  ;
101969: LD_ADDR_OWVAR 33
101973: PUSH
101974: LD_STRING 
101976: ST_TO_ADDR
// hc_name :=  ;
101977: LD_ADDR_OWVAR 26
101981: PUSH
101982: LD_STRING 
101984: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101985: CALL_OW 44
101989: PPUSH
101990: LD_INT 0
101992: PPUSH
101993: CALL_OW 51
// end ;
101997: GO 101919
101999: POP
102000: POP
// end ;
102001: PPOPN 1
102003: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102004: LD_EXP 124
102008: PUSH
102009: LD_EXP 144
102013: AND
102014: IFFALSE 102023
102016: GO 102018
102018: DISABLE
// StreamSibBomb ;
102019: CALL 102024 0 0
102023: END
// export function StreamSibBomb ; var i , x , y ; begin
102024: LD_INT 0
102026: PPUSH
102027: PPUSH
102028: PPUSH
102029: PPUSH
// result := false ;
102030: LD_ADDR_VAR 0 1
102034: PUSH
102035: LD_INT 0
102037: ST_TO_ADDR
// for i := 1 to 16 do
102038: LD_ADDR_VAR 0 2
102042: PUSH
102043: DOUBLE
102044: LD_INT 1
102046: DEC
102047: ST_TO_ADDR
102048: LD_INT 16
102050: PUSH
102051: FOR_TO
102052: IFFALSE 102251
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102054: LD_ADDR_VAR 0 3
102058: PUSH
102059: LD_INT 10
102061: PUSH
102062: LD_INT 20
102064: PUSH
102065: LD_INT 30
102067: PUSH
102068: LD_INT 40
102070: PUSH
102071: LD_INT 50
102073: PUSH
102074: LD_INT 60
102076: PUSH
102077: LD_INT 70
102079: PUSH
102080: LD_INT 80
102082: PUSH
102083: LD_INT 90
102085: PUSH
102086: LD_INT 100
102088: PUSH
102089: LD_INT 110
102091: PUSH
102092: LD_INT 120
102094: PUSH
102095: LD_INT 130
102097: PUSH
102098: LD_INT 140
102100: PUSH
102101: LD_INT 150
102103: PUSH
102104: EMPTY
102105: LIST
102106: LIST
102107: LIST
102108: LIST
102109: LIST
102110: LIST
102111: LIST
102112: LIST
102113: LIST
102114: LIST
102115: LIST
102116: LIST
102117: LIST
102118: LIST
102119: LIST
102120: PUSH
102121: LD_INT 1
102123: PPUSH
102124: LD_INT 15
102126: PPUSH
102127: CALL_OW 12
102131: ARRAY
102132: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102133: LD_ADDR_VAR 0 4
102137: PUSH
102138: LD_INT 10
102140: PUSH
102141: LD_INT 20
102143: PUSH
102144: LD_INT 30
102146: PUSH
102147: LD_INT 40
102149: PUSH
102150: LD_INT 50
102152: PUSH
102153: LD_INT 60
102155: PUSH
102156: LD_INT 70
102158: PUSH
102159: LD_INT 80
102161: PUSH
102162: LD_INT 90
102164: PUSH
102165: LD_INT 100
102167: PUSH
102168: LD_INT 110
102170: PUSH
102171: LD_INT 120
102173: PUSH
102174: LD_INT 130
102176: PUSH
102177: LD_INT 140
102179: PUSH
102180: LD_INT 150
102182: PUSH
102183: EMPTY
102184: LIST
102185: LIST
102186: LIST
102187: LIST
102188: LIST
102189: LIST
102190: LIST
102191: LIST
102192: LIST
102193: LIST
102194: LIST
102195: LIST
102196: LIST
102197: LIST
102198: LIST
102199: PUSH
102200: LD_INT 1
102202: PPUSH
102203: LD_INT 15
102205: PPUSH
102206: CALL_OW 12
102210: ARRAY
102211: ST_TO_ADDR
// if ValidHex ( x , y ) then
102212: LD_VAR 0 3
102216: PPUSH
102217: LD_VAR 0 4
102221: PPUSH
102222: CALL_OW 488
102226: IFFALSE 102249
// begin result := [ x , y ] ;
102228: LD_ADDR_VAR 0 1
102232: PUSH
102233: LD_VAR 0 3
102237: PUSH
102238: LD_VAR 0 4
102242: PUSH
102243: EMPTY
102244: LIST
102245: LIST
102246: ST_TO_ADDR
// break ;
102247: GO 102251
// end ; end ;
102249: GO 102051
102251: POP
102252: POP
// if result then
102253: LD_VAR 0 1
102257: IFFALSE 102317
// begin ToLua ( playSibBomb() ) ;
102259: LD_STRING playSibBomb()
102261: PPUSH
102262: CALL_OW 559
// wait ( 0 0$14 ) ;
102266: LD_INT 490
102268: PPUSH
102269: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102273: LD_VAR 0 1
102277: PUSH
102278: LD_INT 1
102280: ARRAY
102281: PPUSH
102282: LD_VAR 0 1
102286: PUSH
102287: LD_INT 2
102289: ARRAY
102290: PPUSH
102291: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102295: LD_VAR 0 1
102299: PUSH
102300: LD_INT 1
102302: ARRAY
102303: PPUSH
102304: LD_VAR 0 1
102308: PUSH
102309: LD_INT 2
102311: ARRAY
102312: PPUSH
102313: CALL_OW 429
// end ; end ;
102317: LD_VAR 0 1
102321: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102322: LD_EXP 124
102326: PUSH
102327: LD_EXP 146
102331: AND
102332: IFFALSE 102344
102334: GO 102336
102336: DISABLE
// YouLost (  ) ;
102337: LD_STRING 
102339: PPUSH
102340: CALL_OW 104
102344: END
// every 0 0$1 trigger StreamModeActive and sFog do
102345: LD_EXP 124
102349: PUSH
102350: LD_EXP 145
102354: AND
102355: IFFALSE 102369
102357: GO 102359
102359: DISABLE
// FogOff ( your_side ) ;
102360: LD_OWVAR 2
102364: PPUSH
102365: CALL_OW 344
102369: END
// every 0 0$1 trigger StreamModeActive and sSun do
102370: LD_EXP 124
102374: PUSH
102375: LD_EXP 147
102379: AND
102380: IFFALSE 102408
102382: GO 102384
102384: DISABLE
// begin solar_recharge_percent := 0 ;
102385: LD_ADDR_OWVAR 79
102389: PUSH
102390: LD_INT 0
102392: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102393: LD_INT 10500
102395: PPUSH
102396: CALL_OW 67
// solar_recharge_percent := 100 ;
102400: LD_ADDR_OWVAR 79
102404: PUSH
102405: LD_INT 100
102407: ST_TO_ADDR
// end ;
102408: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102409: LD_EXP 124
102413: PUSH
102414: LD_EXP 148
102418: AND
102419: IFFALSE 102658
102421: GO 102423
102423: DISABLE
102424: LD_INT 0
102426: PPUSH
102427: PPUSH
102428: PPUSH
// begin tmp := [ ] ;
102429: LD_ADDR_VAR 0 3
102433: PUSH
102434: EMPTY
102435: ST_TO_ADDR
// for i := 1 to 6 do
102436: LD_ADDR_VAR 0 1
102440: PUSH
102441: DOUBLE
102442: LD_INT 1
102444: DEC
102445: ST_TO_ADDR
102446: LD_INT 6
102448: PUSH
102449: FOR_TO
102450: IFFALSE 102555
// begin uc_nation := nation_nature ;
102452: LD_ADDR_OWVAR 21
102456: PUSH
102457: LD_INT 0
102459: ST_TO_ADDR
// uc_side := 0 ;
102460: LD_ADDR_OWVAR 20
102464: PUSH
102465: LD_INT 0
102467: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102468: LD_ADDR_OWVAR 29
102472: PUSH
102473: LD_INT 12
102475: PUSH
102476: LD_INT 12
102478: PUSH
102479: EMPTY
102480: LIST
102481: LIST
102482: ST_TO_ADDR
// hc_agressivity := 20 ;
102483: LD_ADDR_OWVAR 35
102487: PUSH
102488: LD_INT 20
102490: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102491: LD_ADDR_OWVAR 28
102495: PUSH
102496: LD_INT 17
102498: ST_TO_ADDR
// hc_gallery :=  ;
102499: LD_ADDR_OWVAR 33
102503: PUSH
102504: LD_STRING 
102506: ST_TO_ADDR
// hc_name :=  ;
102507: LD_ADDR_OWVAR 26
102511: PUSH
102512: LD_STRING 
102514: ST_TO_ADDR
// un := CreateHuman ;
102515: LD_ADDR_VAR 0 2
102519: PUSH
102520: CALL_OW 44
102524: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102525: LD_VAR 0 2
102529: PPUSH
102530: LD_INT 1
102532: PPUSH
102533: CALL_OW 51
// tmp := tmp ^ un ;
102537: LD_ADDR_VAR 0 3
102541: PUSH
102542: LD_VAR 0 3
102546: PUSH
102547: LD_VAR 0 2
102551: ADD
102552: ST_TO_ADDR
// end ;
102553: GO 102449
102555: POP
102556: POP
// repeat wait ( 0 0$1 ) ;
102557: LD_INT 35
102559: PPUSH
102560: CALL_OW 67
// for un in tmp do
102564: LD_ADDR_VAR 0 2
102568: PUSH
102569: LD_VAR 0 3
102573: PUSH
102574: FOR_IN
102575: IFFALSE 102649
// begin if IsDead ( un ) then
102577: LD_VAR 0 2
102581: PPUSH
102582: CALL_OW 301
102586: IFFALSE 102606
// begin tmp := tmp diff un ;
102588: LD_ADDR_VAR 0 3
102592: PUSH
102593: LD_VAR 0 3
102597: PUSH
102598: LD_VAR 0 2
102602: DIFF
102603: ST_TO_ADDR
// continue ;
102604: GO 102574
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102606: LD_VAR 0 2
102610: PPUSH
102611: LD_INT 3
102613: PUSH
102614: LD_INT 22
102616: PUSH
102617: LD_INT 0
102619: PUSH
102620: EMPTY
102621: LIST
102622: LIST
102623: PUSH
102624: EMPTY
102625: LIST
102626: LIST
102627: PPUSH
102628: CALL_OW 69
102632: PPUSH
102633: LD_VAR 0 2
102637: PPUSH
102638: CALL_OW 74
102642: PPUSH
102643: CALL_OW 115
// end ;
102647: GO 102574
102649: POP
102650: POP
// until not tmp ;
102651: LD_VAR 0 3
102655: NOT
102656: IFFALSE 102557
// end ;
102658: PPOPN 3
102660: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102661: LD_EXP 124
102665: PUSH
102666: LD_EXP 149
102670: AND
102671: IFFALSE 102725
102673: GO 102675
102675: DISABLE
// begin ToLua ( displayTroll(); ) ;
102676: LD_STRING displayTroll();
102678: PPUSH
102679: CALL_OW 559
// wait ( 3 3$00 ) ;
102683: LD_INT 6300
102685: PPUSH
102686: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102690: LD_STRING hideTroll();
102692: PPUSH
102693: CALL_OW 559
// wait ( 1 1$00 ) ;
102697: LD_INT 2100
102699: PPUSH
102700: CALL_OW 67
// ToLua ( displayTroll(); ) ;
102704: LD_STRING displayTroll();
102706: PPUSH
102707: CALL_OW 559
// wait ( 1 1$00 ) ;
102711: LD_INT 2100
102713: PPUSH
102714: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102718: LD_STRING hideTroll();
102720: PPUSH
102721: CALL_OW 559
// end ;
102725: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
102726: LD_EXP 124
102730: PUSH
102731: LD_EXP 150
102735: AND
102736: IFFALSE 102799
102738: GO 102740
102740: DISABLE
102741: LD_INT 0
102743: PPUSH
// begin p := 0 ;
102744: LD_ADDR_VAR 0 1
102748: PUSH
102749: LD_INT 0
102751: ST_TO_ADDR
// repeat game_speed := 1 ;
102752: LD_ADDR_OWVAR 65
102756: PUSH
102757: LD_INT 1
102759: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102760: LD_INT 35
102762: PPUSH
102763: CALL_OW 67
// p := p + 1 ;
102767: LD_ADDR_VAR 0 1
102771: PUSH
102772: LD_VAR 0 1
102776: PUSH
102777: LD_INT 1
102779: PLUS
102780: ST_TO_ADDR
// until p >= 60 ;
102781: LD_VAR 0 1
102785: PUSH
102786: LD_INT 60
102788: GREATEREQUAL
102789: IFFALSE 102752
// game_speed := 4 ;
102791: LD_ADDR_OWVAR 65
102795: PUSH
102796: LD_INT 4
102798: ST_TO_ADDR
// end ;
102799: PPOPN 1
102801: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
102802: LD_EXP 124
102806: PUSH
102807: LD_EXP 151
102811: AND
102812: IFFALSE 102958
102814: GO 102816
102816: DISABLE
102817: LD_INT 0
102819: PPUSH
102820: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102821: LD_ADDR_VAR 0 1
102825: PUSH
102826: LD_INT 22
102828: PUSH
102829: LD_OWVAR 2
102833: PUSH
102834: EMPTY
102835: LIST
102836: LIST
102837: PUSH
102838: LD_INT 2
102840: PUSH
102841: LD_INT 30
102843: PUSH
102844: LD_INT 0
102846: PUSH
102847: EMPTY
102848: LIST
102849: LIST
102850: PUSH
102851: LD_INT 30
102853: PUSH
102854: LD_INT 1
102856: PUSH
102857: EMPTY
102858: LIST
102859: LIST
102860: PUSH
102861: EMPTY
102862: LIST
102863: LIST
102864: LIST
102865: PUSH
102866: EMPTY
102867: LIST
102868: LIST
102869: PPUSH
102870: CALL_OW 69
102874: ST_TO_ADDR
// if not depot then
102875: LD_VAR 0 1
102879: NOT
102880: IFFALSE 102884
// exit ;
102882: GO 102958
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102884: LD_ADDR_VAR 0 2
102888: PUSH
102889: LD_VAR 0 1
102893: PUSH
102894: LD_INT 1
102896: PPUSH
102897: LD_VAR 0 1
102901: PPUSH
102902: CALL_OW 12
102906: ARRAY
102907: PPUSH
102908: CALL_OW 274
102912: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102913: LD_VAR 0 2
102917: PPUSH
102918: LD_INT 1
102920: PPUSH
102921: LD_INT 0
102923: PPUSH
102924: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102928: LD_VAR 0 2
102932: PPUSH
102933: LD_INT 2
102935: PPUSH
102936: LD_INT 0
102938: PPUSH
102939: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102943: LD_VAR 0 2
102947: PPUSH
102948: LD_INT 3
102950: PPUSH
102951: LD_INT 0
102953: PPUSH
102954: CALL_OW 277
// end ;
102958: PPOPN 2
102960: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102961: LD_EXP 124
102965: PUSH
102966: LD_EXP 152
102970: AND
102971: IFFALSE 103068
102973: GO 102975
102975: DISABLE
102976: LD_INT 0
102978: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102979: LD_ADDR_VAR 0 1
102983: PUSH
102984: LD_INT 22
102986: PUSH
102987: LD_OWVAR 2
102991: PUSH
102992: EMPTY
102993: LIST
102994: LIST
102995: PUSH
102996: LD_INT 21
102998: PUSH
102999: LD_INT 1
103001: PUSH
103002: EMPTY
103003: LIST
103004: LIST
103005: PUSH
103006: LD_INT 3
103008: PUSH
103009: LD_INT 23
103011: PUSH
103012: LD_INT 0
103014: PUSH
103015: EMPTY
103016: LIST
103017: LIST
103018: PUSH
103019: EMPTY
103020: LIST
103021: LIST
103022: PUSH
103023: EMPTY
103024: LIST
103025: LIST
103026: LIST
103027: PPUSH
103028: CALL_OW 69
103032: ST_TO_ADDR
// if not tmp then
103033: LD_VAR 0 1
103037: NOT
103038: IFFALSE 103042
// exit ;
103040: GO 103068
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103042: LD_VAR 0 1
103046: PUSH
103047: LD_INT 1
103049: PPUSH
103050: LD_VAR 0 1
103054: PPUSH
103055: CALL_OW 12
103059: ARRAY
103060: PPUSH
103061: LD_INT 200
103063: PPUSH
103064: CALL_OW 234
// end ;
103068: PPOPN 1
103070: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103071: LD_EXP 124
103075: PUSH
103076: LD_EXP 153
103080: AND
103081: IFFALSE 103160
103083: GO 103085
103085: DISABLE
103086: LD_INT 0
103088: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103089: LD_ADDR_VAR 0 1
103093: PUSH
103094: LD_INT 22
103096: PUSH
103097: LD_OWVAR 2
103101: PUSH
103102: EMPTY
103103: LIST
103104: LIST
103105: PUSH
103106: LD_INT 21
103108: PUSH
103109: LD_INT 2
103111: PUSH
103112: EMPTY
103113: LIST
103114: LIST
103115: PUSH
103116: EMPTY
103117: LIST
103118: LIST
103119: PPUSH
103120: CALL_OW 69
103124: ST_TO_ADDR
// if not tmp then
103125: LD_VAR 0 1
103129: NOT
103130: IFFALSE 103134
// exit ;
103132: GO 103160
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103134: LD_VAR 0 1
103138: PUSH
103139: LD_INT 1
103141: PPUSH
103142: LD_VAR 0 1
103146: PPUSH
103147: CALL_OW 12
103151: ARRAY
103152: PPUSH
103153: LD_INT 60
103155: PPUSH
103156: CALL_OW 234
// end ;
103160: PPOPN 1
103162: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103163: LD_EXP 124
103167: PUSH
103168: LD_EXP 154
103172: AND
103173: IFFALSE 103272
103175: GO 103177
103177: DISABLE
103178: LD_INT 0
103180: PPUSH
103181: PPUSH
// begin enable ;
103182: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103183: LD_ADDR_VAR 0 1
103187: PUSH
103188: LD_INT 22
103190: PUSH
103191: LD_OWVAR 2
103195: PUSH
103196: EMPTY
103197: LIST
103198: LIST
103199: PUSH
103200: LD_INT 61
103202: PUSH
103203: EMPTY
103204: LIST
103205: PUSH
103206: LD_INT 33
103208: PUSH
103209: LD_INT 2
103211: PUSH
103212: EMPTY
103213: LIST
103214: LIST
103215: PUSH
103216: EMPTY
103217: LIST
103218: LIST
103219: LIST
103220: PPUSH
103221: CALL_OW 69
103225: ST_TO_ADDR
// if not tmp then
103226: LD_VAR 0 1
103230: NOT
103231: IFFALSE 103235
// exit ;
103233: GO 103272
// for i in tmp do
103235: LD_ADDR_VAR 0 2
103239: PUSH
103240: LD_VAR 0 1
103244: PUSH
103245: FOR_IN
103246: IFFALSE 103270
// if IsControledBy ( i ) then
103248: LD_VAR 0 2
103252: PPUSH
103253: CALL_OW 312
103257: IFFALSE 103268
// ComUnlink ( i ) ;
103259: LD_VAR 0 2
103263: PPUSH
103264: CALL_OW 136
103268: GO 103245
103270: POP
103271: POP
// end ;
103272: PPOPN 2
103274: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103275: LD_EXP 124
103279: PUSH
103280: LD_EXP 155
103284: AND
103285: IFFALSE 103425
103287: GO 103289
103289: DISABLE
103290: LD_INT 0
103292: PPUSH
103293: PPUSH
// begin ToLua ( displayPowell(); ) ;
103294: LD_STRING displayPowell();
103296: PPUSH
103297: CALL_OW 559
// uc_side := 0 ;
103301: LD_ADDR_OWVAR 20
103305: PUSH
103306: LD_INT 0
103308: ST_TO_ADDR
// uc_nation := 2 ;
103309: LD_ADDR_OWVAR 21
103313: PUSH
103314: LD_INT 2
103316: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103317: LD_ADDR_OWVAR 37
103321: PUSH
103322: LD_INT 14
103324: ST_TO_ADDR
// vc_engine := engine_siberite ;
103325: LD_ADDR_OWVAR 39
103329: PUSH
103330: LD_INT 3
103332: ST_TO_ADDR
// vc_control := control_apeman ;
103333: LD_ADDR_OWVAR 38
103337: PUSH
103338: LD_INT 5
103340: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103341: LD_ADDR_OWVAR 40
103345: PUSH
103346: LD_INT 29
103348: ST_TO_ADDR
// un := CreateVehicle ;
103349: LD_ADDR_VAR 0 2
103353: PUSH
103354: CALL_OW 45
103358: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103359: LD_VAR 0 2
103363: PPUSH
103364: LD_INT 1
103366: PPUSH
103367: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103371: LD_INT 35
103373: PPUSH
103374: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103378: LD_VAR 0 2
103382: PPUSH
103383: LD_INT 22
103385: PUSH
103386: LD_OWVAR 2
103390: PUSH
103391: EMPTY
103392: LIST
103393: LIST
103394: PPUSH
103395: CALL_OW 69
103399: PPUSH
103400: LD_VAR 0 2
103404: PPUSH
103405: CALL_OW 74
103409: PPUSH
103410: CALL_OW 115
// until IsDead ( un ) ;
103414: LD_VAR 0 2
103418: PPUSH
103419: CALL_OW 301
103423: IFFALSE 103371
// end ;
103425: PPOPN 2
103427: END
// every 0 0$1 trigger StreamModeActive and sStu do
103428: LD_EXP 124
103432: PUSH
103433: LD_EXP 163
103437: AND
103438: IFFALSE 103454
103440: GO 103442
103442: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103443: LD_STRING displayStucuk();
103445: PPUSH
103446: CALL_OW 559
// ResetFog ;
103450: CALL_OW 335
// end ;
103454: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103455: LD_EXP 124
103459: PUSH
103460: LD_EXP 156
103464: AND
103465: IFFALSE 103606
103467: GO 103469
103469: DISABLE
103470: LD_INT 0
103472: PPUSH
103473: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103474: LD_ADDR_VAR 0 2
103478: PUSH
103479: LD_INT 22
103481: PUSH
103482: LD_OWVAR 2
103486: PUSH
103487: EMPTY
103488: LIST
103489: LIST
103490: PUSH
103491: LD_INT 21
103493: PUSH
103494: LD_INT 1
103496: PUSH
103497: EMPTY
103498: LIST
103499: LIST
103500: PUSH
103501: EMPTY
103502: LIST
103503: LIST
103504: PPUSH
103505: CALL_OW 69
103509: ST_TO_ADDR
// if not tmp then
103510: LD_VAR 0 2
103514: NOT
103515: IFFALSE 103519
// exit ;
103517: GO 103606
// un := tmp [ rand ( 1 , tmp ) ] ;
103519: LD_ADDR_VAR 0 1
103523: PUSH
103524: LD_VAR 0 2
103528: PUSH
103529: LD_INT 1
103531: PPUSH
103532: LD_VAR 0 2
103536: PPUSH
103537: CALL_OW 12
103541: ARRAY
103542: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103543: LD_VAR 0 1
103547: PPUSH
103548: LD_INT 0
103550: PPUSH
103551: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103555: LD_VAR 0 1
103559: PPUSH
103560: LD_OWVAR 3
103564: PUSH
103565: LD_VAR 0 1
103569: DIFF
103570: PPUSH
103571: LD_VAR 0 1
103575: PPUSH
103576: CALL_OW 74
103580: PPUSH
103581: CALL_OW 115
// wait ( 0 0$20 ) ;
103585: LD_INT 700
103587: PPUSH
103588: CALL_OW 67
// SetSide ( un , your_side ) ;
103592: LD_VAR 0 1
103596: PPUSH
103597: LD_OWVAR 2
103601: PPUSH
103602: CALL_OW 235
// end ;
103606: PPOPN 2
103608: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
103609: LD_EXP 124
103613: PUSH
103614: LD_EXP 157
103618: AND
103619: IFFALSE 103725
103621: GO 103623
103623: DISABLE
103624: LD_INT 0
103626: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103627: LD_ADDR_VAR 0 1
103631: PUSH
103632: LD_INT 22
103634: PUSH
103635: LD_OWVAR 2
103639: PUSH
103640: EMPTY
103641: LIST
103642: LIST
103643: PUSH
103644: LD_INT 2
103646: PUSH
103647: LD_INT 30
103649: PUSH
103650: LD_INT 0
103652: PUSH
103653: EMPTY
103654: LIST
103655: LIST
103656: PUSH
103657: LD_INT 30
103659: PUSH
103660: LD_INT 1
103662: PUSH
103663: EMPTY
103664: LIST
103665: LIST
103666: PUSH
103667: EMPTY
103668: LIST
103669: LIST
103670: LIST
103671: PUSH
103672: EMPTY
103673: LIST
103674: LIST
103675: PPUSH
103676: CALL_OW 69
103680: ST_TO_ADDR
// if not depot then
103681: LD_VAR 0 1
103685: NOT
103686: IFFALSE 103690
// exit ;
103688: GO 103725
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
103690: LD_VAR 0 1
103694: PUSH
103695: LD_INT 1
103697: ARRAY
103698: PPUSH
103699: CALL_OW 250
103703: PPUSH
103704: LD_VAR 0 1
103708: PUSH
103709: LD_INT 1
103711: ARRAY
103712: PPUSH
103713: CALL_OW 251
103717: PPUSH
103718: LD_INT 70
103720: PPUSH
103721: CALL_OW 495
// end ;
103725: PPOPN 1
103727: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
103728: LD_EXP 124
103732: PUSH
103733: LD_EXP 158
103737: AND
103738: IFFALSE 103949
103740: GO 103742
103742: DISABLE
103743: LD_INT 0
103745: PPUSH
103746: PPUSH
103747: PPUSH
103748: PPUSH
103749: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103750: LD_ADDR_VAR 0 5
103754: PUSH
103755: LD_INT 22
103757: PUSH
103758: LD_OWVAR 2
103762: PUSH
103763: EMPTY
103764: LIST
103765: LIST
103766: PUSH
103767: LD_INT 21
103769: PUSH
103770: LD_INT 1
103772: PUSH
103773: EMPTY
103774: LIST
103775: LIST
103776: PUSH
103777: EMPTY
103778: LIST
103779: LIST
103780: PPUSH
103781: CALL_OW 69
103785: ST_TO_ADDR
// if not tmp then
103786: LD_VAR 0 5
103790: NOT
103791: IFFALSE 103795
// exit ;
103793: GO 103949
// for i in tmp do
103795: LD_ADDR_VAR 0 1
103799: PUSH
103800: LD_VAR 0 5
103804: PUSH
103805: FOR_IN
103806: IFFALSE 103947
// begin d := rand ( 0 , 5 ) ;
103808: LD_ADDR_VAR 0 4
103812: PUSH
103813: LD_INT 0
103815: PPUSH
103816: LD_INT 5
103818: PPUSH
103819: CALL_OW 12
103823: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
103824: LD_ADDR_VAR 0 2
103828: PUSH
103829: LD_VAR 0 1
103833: PPUSH
103834: CALL_OW 250
103838: PPUSH
103839: LD_VAR 0 4
103843: PPUSH
103844: LD_INT 3
103846: PPUSH
103847: LD_INT 12
103849: PPUSH
103850: CALL_OW 12
103854: PPUSH
103855: CALL_OW 272
103859: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
103860: LD_ADDR_VAR 0 3
103864: PUSH
103865: LD_VAR 0 1
103869: PPUSH
103870: CALL_OW 251
103874: PPUSH
103875: LD_VAR 0 4
103879: PPUSH
103880: LD_INT 3
103882: PPUSH
103883: LD_INT 12
103885: PPUSH
103886: CALL_OW 12
103890: PPUSH
103891: CALL_OW 273
103895: ST_TO_ADDR
// if ValidHex ( x , y ) then
103896: LD_VAR 0 2
103900: PPUSH
103901: LD_VAR 0 3
103905: PPUSH
103906: CALL_OW 488
103910: IFFALSE 103945
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103912: LD_VAR 0 1
103916: PPUSH
103917: LD_VAR 0 2
103921: PPUSH
103922: LD_VAR 0 3
103926: PPUSH
103927: LD_INT 3
103929: PPUSH
103930: LD_INT 6
103932: PPUSH
103933: CALL_OW 12
103937: PPUSH
103938: LD_INT 1
103940: PPUSH
103941: CALL_OW 483
// end ;
103945: GO 103805
103947: POP
103948: POP
// end ;
103949: PPOPN 5
103951: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103952: LD_EXP 124
103956: PUSH
103957: LD_EXP 159
103961: AND
103962: IFFALSE 104056
103964: GO 103966
103966: DISABLE
103967: LD_INT 0
103969: PPUSH
103970: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103971: LD_ADDR_VAR 0 2
103975: PUSH
103976: LD_INT 22
103978: PUSH
103979: LD_OWVAR 2
103983: PUSH
103984: EMPTY
103985: LIST
103986: LIST
103987: PUSH
103988: LD_INT 32
103990: PUSH
103991: LD_INT 1
103993: PUSH
103994: EMPTY
103995: LIST
103996: LIST
103997: PUSH
103998: LD_INT 21
104000: PUSH
104001: LD_INT 2
104003: PUSH
104004: EMPTY
104005: LIST
104006: LIST
104007: PUSH
104008: EMPTY
104009: LIST
104010: LIST
104011: LIST
104012: PPUSH
104013: CALL_OW 69
104017: ST_TO_ADDR
// if not tmp then
104018: LD_VAR 0 2
104022: NOT
104023: IFFALSE 104027
// exit ;
104025: GO 104056
// for i in tmp do
104027: LD_ADDR_VAR 0 1
104031: PUSH
104032: LD_VAR 0 2
104036: PUSH
104037: FOR_IN
104038: IFFALSE 104054
// SetFuel ( i , 0 ) ;
104040: LD_VAR 0 1
104044: PPUSH
104045: LD_INT 0
104047: PPUSH
104048: CALL_OW 240
104052: GO 104037
104054: POP
104055: POP
// end ;
104056: PPOPN 2
104058: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104059: LD_EXP 124
104063: PUSH
104064: LD_EXP 160
104068: AND
104069: IFFALSE 104135
104071: GO 104073
104073: DISABLE
104074: LD_INT 0
104076: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104077: LD_ADDR_VAR 0 1
104081: PUSH
104082: LD_INT 22
104084: PUSH
104085: LD_OWVAR 2
104089: PUSH
104090: EMPTY
104091: LIST
104092: LIST
104093: PUSH
104094: LD_INT 30
104096: PUSH
104097: LD_INT 29
104099: PUSH
104100: EMPTY
104101: LIST
104102: LIST
104103: PUSH
104104: EMPTY
104105: LIST
104106: LIST
104107: PPUSH
104108: CALL_OW 69
104112: ST_TO_ADDR
// if not tmp then
104113: LD_VAR 0 1
104117: NOT
104118: IFFALSE 104122
// exit ;
104120: GO 104135
// DestroyUnit ( tmp [ 1 ] ) ;
104122: LD_VAR 0 1
104126: PUSH
104127: LD_INT 1
104129: ARRAY
104130: PPUSH
104131: CALL_OW 65
// end ;
104135: PPOPN 1
104137: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104138: LD_EXP 124
104142: PUSH
104143: LD_EXP 162
104147: AND
104148: IFFALSE 104277
104150: GO 104152
104152: DISABLE
104153: LD_INT 0
104155: PPUSH
// begin uc_side := 0 ;
104156: LD_ADDR_OWVAR 20
104160: PUSH
104161: LD_INT 0
104163: ST_TO_ADDR
// uc_nation := nation_arabian ;
104164: LD_ADDR_OWVAR 21
104168: PUSH
104169: LD_INT 2
104171: ST_TO_ADDR
// hc_gallery :=  ;
104172: LD_ADDR_OWVAR 33
104176: PUSH
104177: LD_STRING 
104179: ST_TO_ADDR
// hc_name :=  ;
104180: LD_ADDR_OWVAR 26
104184: PUSH
104185: LD_STRING 
104187: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104188: LD_INT 1
104190: PPUSH
104191: LD_INT 11
104193: PPUSH
104194: LD_INT 10
104196: PPUSH
104197: CALL_OW 380
// un := CreateHuman ;
104201: LD_ADDR_VAR 0 1
104205: PUSH
104206: CALL_OW 44
104210: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104211: LD_VAR 0 1
104215: PPUSH
104216: LD_INT 1
104218: PPUSH
104219: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104223: LD_INT 35
104225: PPUSH
104226: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104230: LD_VAR 0 1
104234: PPUSH
104235: LD_INT 22
104237: PUSH
104238: LD_OWVAR 2
104242: PUSH
104243: EMPTY
104244: LIST
104245: LIST
104246: PPUSH
104247: CALL_OW 69
104251: PPUSH
104252: LD_VAR 0 1
104256: PPUSH
104257: CALL_OW 74
104261: PPUSH
104262: CALL_OW 115
// until IsDead ( un ) ;
104266: LD_VAR 0 1
104270: PPUSH
104271: CALL_OW 301
104275: IFFALSE 104223
// end ;
104277: PPOPN 1
104279: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104280: LD_EXP 124
104284: PUSH
104285: LD_EXP 164
104289: AND
104290: IFFALSE 104302
104292: GO 104294
104294: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104295: LD_STRING earthquake(getX(game), 0, 32)
104297: PPUSH
104298: CALL_OW 559
104302: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104303: LD_EXP 124
104307: PUSH
104308: LD_EXP 165
104312: AND
104313: IFFALSE 104404
104315: GO 104317
104317: DISABLE
104318: LD_INT 0
104320: PPUSH
// begin enable ;
104321: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104322: LD_ADDR_VAR 0 1
104326: PUSH
104327: LD_INT 22
104329: PUSH
104330: LD_OWVAR 2
104334: PUSH
104335: EMPTY
104336: LIST
104337: LIST
104338: PUSH
104339: LD_INT 21
104341: PUSH
104342: LD_INT 2
104344: PUSH
104345: EMPTY
104346: LIST
104347: LIST
104348: PUSH
104349: LD_INT 33
104351: PUSH
104352: LD_INT 3
104354: PUSH
104355: EMPTY
104356: LIST
104357: LIST
104358: PUSH
104359: EMPTY
104360: LIST
104361: LIST
104362: LIST
104363: PPUSH
104364: CALL_OW 69
104368: ST_TO_ADDR
// if not tmp then
104369: LD_VAR 0 1
104373: NOT
104374: IFFALSE 104378
// exit ;
104376: GO 104404
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104378: LD_VAR 0 1
104382: PUSH
104383: LD_INT 1
104385: PPUSH
104386: LD_VAR 0 1
104390: PPUSH
104391: CALL_OW 12
104395: ARRAY
104396: PPUSH
104397: LD_INT 1
104399: PPUSH
104400: CALL_OW 234
// end ;
104404: PPOPN 1
104406: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104407: LD_EXP 124
104411: PUSH
104412: LD_EXP 166
104416: AND
104417: IFFALSE 104558
104419: GO 104421
104421: DISABLE
104422: LD_INT 0
104424: PPUSH
104425: PPUSH
104426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104427: LD_ADDR_VAR 0 3
104431: PUSH
104432: LD_INT 22
104434: PUSH
104435: LD_OWVAR 2
104439: PUSH
104440: EMPTY
104441: LIST
104442: LIST
104443: PUSH
104444: LD_INT 25
104446: PUSH
104447: LD_INT 1
104449: PUSH
104450: EMPTY
104451: LIST
104452: LIST
104453: PUSH
104454: EMPTY
104455: LIST
104456: LIST
104457: PPUSH
104458: CALL_OW 69
104462: ST_TO_ADDR
// if not tmp then
104463: LD_VAR 0 3
104467: NOT
104468: IFFALSE 104472
// exit ;
104470: GO 104558
// un := tmp [ rand ( 1 , tmp ) ] ;
104472: LD_ADDR_VAR 0 2
104476: PUSH
104477: LD_VAR 0 3
104481: PUSH
104482: LD_INT 1
104484: PPUSH
104485: LD_VAR 0 3
104489: PPUSH
104490: CALL_OW 12
104494: ARRAY
104495: ST_TO_ADDR
// if Crawls ( un ) then
104496: LD_VAR 0 2
104500: PPUSH
104501: CALL_OW 318
104505: IFFALSE 104516
// ComWalk ( un ) ;
104507: LD_VAR 0 2
104511: PPUSH
104512: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104516: LD_VAR 0 2
104520: PPUSH
104521: LD_INT 9
104523: PPUSH
104524: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104528: LD_INT 28
104530: PPUSH
104531: LD_OWVAR 2
104535: PPUSH
104536: LD_INT 2
104538: PPUSH
104539: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104543: LD_INT 29
104545: PPUSH
104546: LD_OWVAR 2
104550: PPUSH
104551: LD_INT 2
104553: PPUSH
104554: CALL_OW 322
// end ;
104558: PPOPN 3
104560: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104561: LD_EXP 124
104565: PUSH
104566: LD_EXP 167
104570: AND
104571: IFFALSE 104682
104573: GO 104575
104575: DISABLE
104576: LD_INT 0
104578: PPUSH
104579: PPUSH
104580: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104581: LD_ADDR_VAR 0 3
104585: PUSH
104586: LD_INT 22
104588: PUSH
104589: LD_OWVAR 2
104593: PUSH
104594: EMPTY
104595: LIST
104596: LIST
104597: PUSH
104598: LD_INT 25
104600: PUSH
104601: LD_INT 1
104603: PUSH
104604: EMPTY
104605: LIST
104606: LIST
104607: PUSH
104608: EMPTY
104609: LIST
104610: LIST
104611: PPUSH
104612: CALL_OW 69
104616: ST_TO_ADDR
// if not tmp then
104617: LD_VAR 0 3
104621: NOT
104622: IFFALSE 104626
// exit ;
104624: GO 104682
// un := tmp [ rand ( 1 , tmp ) ] ;
104626: LD_ADDR_VAR 0 2
104630: PUSH
104631: LD_VAR 0 3
104635: PUSH
104636: LD_INT 1
104638: PPUSH
104639: LD_VAR 0 3
104643: PPUSH
104644: CALL_OW 12
104648: ARRAY
104649: ST_TO_ADDR
// if Crawls ( un ) then
104650: LD_VAR 0 2
104654: PPUSH
104655: CALL_OW 318
104659: IFFALSE 104670
// ComWalk ( un ) ;
104661: LD_VAR 0 2
104665: PPUSH
104666: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104670: LD_VAR 0 2
104674: PPUSH
104675: LD_INT 8
104677: PPUSH
104678: CALL_OW 336
// end ;
104682: PPOPN 3
104684: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
104685: LD_EXP 124
104689: PUSH
104690: LD_EXP 168
104694: AND
104695: IFFALSE 104839
104697: GO 104699
104699: DISABLE
104700: LD_INT 0
104702: PPUSH
104703: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
104704: LD_ADDR_VAR 0 2
104708: PUSH
104709: LD_INT 22
104711: PUSH
104712: LD_OWVAR 2
104716: PUSH
104717: EMPTY
104718: LIST
104719: LIST
104720: PUSH
104721: LD_INT 21
104723: PUSH
104724: LD_INT 2
104726: PUSH
104727: EMPTY
104728: LIST
104729: LIST
104730: PUSH
104731: LD_INT 2
104733: PUSH
104734: LD_INT 34
104736: PUSH
104737: LD_INT 12
104739: PUSH
104740: EMPTY
104741: LIST
104742: LIST
104743: PUSH
104744: LD_INT 34
104746: PUSH
104747: LD_INT 51
104749: PUSH
104750: EMPTY
104751: LIST
104752: LIST
104753: PUSH
104754: LD_INT 34
104756: PUSH
104757: LD_INT 32
104759: PUSH
104760: EMPTY
104761: LIST
104762: LIST
104763: PUSH
104764: EMPTY
104765: LIST
104766: LIST
104767: LIST
104768: LIST
104769: PUSH
104770: EMPTY
104771: LIST
104772: LIST
104773: LIST
104774: PPUSH
104775: CALL_OW 69
104779: ST_TO_ADDR
// if not tmp then
104780: LD_VAR 0 2
104784: NOT
104785: IFFALSE 104789
// exit ;
104787: GO 104839
// for i in tmp do
104789: LD_ADDR_VAR 0 1
104793: PUSH
104794: LD_VAR 0 2
104798: PUSH
104799: FOR_IN
104800: IFFALSE 104837
// if GetCargo ( i , mat_artifact ) = 0 then
104802: LD_VAR 0 1
104806: PPUSH
104807: LD_INT 4
104809: PPUSH
104810: CALL_OW 289
104814: PUSH
104815: LD_INT 0
104817: EQUAL
104818: IFFALSE 104835
// SetCargo ( i , mat_siberit , 100 ) ;
104820: LD_VAR 0 1
104824: PPUSH
104825: LD_INT 3
104827: PPUSH
104828: LD_INT 100
104830: PPUSH
104831: CALL_OW 290
104835: GO 104799
104837: POP
104838: POP
// end ;
104839: PPOPN 2
104841: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
104842: LD_EXP 124
104846: PUSH
104847: LD_EXP 169
104851: AND
104852: IFFALSE 105035
104854: GO 104856
104856: DISABLE
104857: LD_INT 0
104859: PPUSH
104860: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104861: LD_ADDR_VAR 0 2
104865: PUSH
104866: LD_INT 22
104868: PUSH
104869: LD_OWVAR 2
104873: PUSH
104874: EMPTY
104875: LIST
104876: LIST
104877: PPUSH
104878: CALL_OW 69
104882: ST_TO_ADDR
// if not tmp then
104883: LD_VAR 0 2
104887: NOT
104888: IFFALSE 104892
// exit ;
104890: GO 105035
// for i := 1 to 2 do
104892: LD_ADDR_VAR 0 1
104896: PUSH
104897: DOUBLE
104898: LD_INT 1
104900: DEC
104901: ST_TO_ADDR
104902: LD_INT 2
104904: PUSH
104905: FOR_TO
104906: IFFALSE 105033
// begin uc_side := your_side ;
104908: LD_ADDR_OWVAR 20
104912: PUSH
104913: LD_OWVAR 2
104917: ST_TO_ADDR
// uc_nation := nation_american ;
104918: LD_ADDR_OWVAR 21
104922: PUSH
104923: LD_INT 1
104925: ST_TO_ADDR
// vc_chassis := us_morphling ;
104926: LD_ADDR_OWVAR 37
104930: PUSH
104931: LD_INT 5
104933: ST_TO_ADDR
// vc_engine := engine_siberite ;
104934: LD_ADDR_OWVAR 39
104938: PUSH
104939: LD_INT 3
104941: ST_TO_ADDR
// vc_control := control_computer ;
104942: LD_ADDR_OWVAR 38
104946: PUSH
104947: LD_INT 3
104949: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104950: LD_ADDR_OWVAR 40
104954: PUSH
104955: LD_INT 10
104957: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104958: LD_VAR 0 2
104962: PUSH
104963: LD_INT 1
104965: ARRAY
104966: PPUSH
104967: CALL_OW 310
104971: NOT
104972: IFFALSE 105019
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104974: CALL_OW 45
104978: PPUSH
104979: LD_VAR 0 2
104983: PUSH
104984: LD_INT 1
104986: ARRAY
104987: PPUSH
104988: CALL_OW 250
104992: PPUSH
104993: LD_VAR 0 2
104997: PUSH
104998: LD_INT 1
105000: ARRAY
105001: PPUSH
105002: CALL_OW 251
105006: PPUSH
105007: LD_INT 12
105009: PPUSH
105010: LD_INT 1
105012: PPUSH
105013: CALL_OW 50
105017: GO 105031
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105019: CALL_OW 45
105023: PPUSH
105024: LD_INT 1
105026: PPUSH
105027: CALL_OW 51
// end ;
105031: GO 104905
105033: POP
105034: POP
// end ;
105035: PPOPN 2
105037: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105038: LD_EXP 124
105042: PUSH
105043: LD_EXP 170
105047: AND
105048: IFFALSE 105270
105050: GO 105052
105052: DISABLE
105053: LD_INT 0
105055: PPUSH
105056: PPUSH
105057: PPUSH
105058: PPUSH
105059: PPUSH
105060: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105061: LD_ADDR_VAR 0 6
105065: PUSH
105066: LD_INT 22
105068: PUSH
105069: LD_OWVAR 2
105073: PUSH
105074: EMPTY
105075: LIST
105076: LIST
105077: PUSH
105078: LD_INT 21
105080: PUSH
105081: LD_INT 1
105083: PUSH
105084: EMPTY
105085: LIST
105086: LIST
105087: PUSH
105088: LD_INT 3
105090: PUSH
105091: LD_INT 23
105093: PUSH
105094: LD_INT 0
105096: PUSH
105097: EMPTY
105098: LIST
105099: LIST
105100: PUSH
105101: EMPTY
105102: LIST
105103: LIST
105104: PUSH
105105: EMPTY
105106: LIST
105107: LIST
105108: LIST
105109: PPUSH
105110: CALL_OW 69
105114: ST_TO_ADDR
// if not tmp then
105115: LD_VAR 0 6
105119: NOT
105120: IFFALSE 105124
// exit ;
105122: GO 105270
// s1 := rand ( 1 , 4 ) ;
105124: LD_ADDR_VAR 0 2
105128: PUSH
105129: LD_INT 1
105131: PPUSH
105132: LD_INT 4
105134: PPUSH
105135: CALL_OW 12
105139: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105140: LD_ADDR_VAR 0 4
105144: PUSH
105145: LD_VAR 0 6
105149: PUSH
105150: LD_INT 1
105152: ARRAY
105153: PPUSH
105154: LD_VAR 0 2
105158: PPUSH
105159: CALL_OW 259
105163: ST_TO_ADDR
// if s1 = 1 then
105164: LD_VAR 0 2
105168: PUSH
105169: LD_INT 1
105171: EQUAL
105172: IFFALSE 105192
// s2 := rand ( 2 , 4 ) else
105174: LD_ADDR_VAR 0 3
105178: PUSH
105179: LD_INT 2
105181: PPUSH
105182: LD_INT 4
105184: PPUSH
105185: CALL_OW 12
105189: ST_TO_ADDR
105190: GO 105200
// s2 := 1 ;
105192: LD_ADDR_VAR 0 3
105196: PUSH
105197: LD_INT 1
105199: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105200: LD_ADDR_VAR 0 5
105204: PUSH
105205: LD_VAR 0 6
105209: PUSH
105210: LD_INT 1
105212: ARRAY
105213: PPUSH
105214: LD_VAR 0 3
105218: PPUSH
105219: CALL_OW 259
105223: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105224: LD_VAR 0 6
105228: PUSH
105229: LD_INT 1
105231: ARRAY
105232: PPUSH
105233: LD_VAR 0 2
105237: PPUSH
105238: LD_VAR 0 5
105242: PPUSH
105243: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105247: LD_VAR 0 6
105251: PUSH
105252: LD_INT 1
105254: ARRAY
105255: PPUSH
105256: LD_VAR 0 3
105260: PPUSH
105261: LD_VAR 0 4
105265: PPUSH
105266: CALL_OW 237
// end ;
105270: PPOPN 6
105272: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105273: LD_EXP 124
105277: PUSH
105278: LD_EXP 171
105282: AND
105283: IFFALSE 105362
105285: GO 105287
105287: DISABLE
105288: LD_INT 0
105290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105291: LD_ADDR_VAR 0 1
105295: PUSH
105296: LD_INT 22
105298: PUSH
105299: LD_OWVAR 2
105303: PUSH
105304: EMPTY
105305: LIST
105306: LIST
105307: PUSH
105308: LD_INT 30
105310: PUSH
105311: LD_INT 3
105313: PUSH
105314: EMPTY
105315: LIST
105316: LIST
105317: PUSH
105318: EMPTY
105319: LIST
105320: LIST
105321: PPUSH
105322: CALL_OW 69
105326: ST_TO_ADDR
// if not tmp then
105327: LD_VAR 0 1
105331: NOT
105332: IFFALSE 105336
// exit ;
105334: GO 105362
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105336: LD_VAR 0 1
105340: PUSH
105341: LD_INT 1
105343: PPUSH
105344: LD_VAR 0 1
105348: PPUSH
105349: CALL_OW 12
105353: ARRAY
105354: PPUSH
105355: LD_INT 1
105357: PPUSH
105358: CALL_OW 234
// end ;
105362: PPOPN 1
105364: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105365: LD_EXP 124
105369: PUSH
105370: LD_EXP 172
105374: AND
105375: IFFALSE 105487
105377: GO 105379
105379: DISABLE
105380: LD_INT 0
105382: PPUSH
105383: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105384: LD_ADDR_VAR 0 2
105388: PUSH
105389: LD_INT 22
105391: PUSH
105392: LD_OWVAR 2
105396: PUSH
105397: EMPTY
105398: LIST
105399: LIST
105400: PUSH
105401: LD_INT 2
105403: PUSH
105404: LD_INT 30
105406: PUSH
105407: LD_INT 27
105409: PUSH
105410: EMPTY
105411: LIST
105412: LIST
105413: PUSH
105414: LD_INT 30
105416: PUSH
105417: LD_INT 26
105419: PUSH
105420: EMPTY
105421: LIST
105422: LIST
105423: PUSH
105424: LD_INT 30
105426: PUSH
105427: LD_INT 28
105429: PUSH
105430: EMPTY
105431: LIST
105432: LIST
105433: PUSH
105434: EMPTY
105435: LIST
105436: LIST
105437: LIST
105438: LIST
105439: PUSH
105440: EMPTY
105441: LIST
105442: LIST
105443: PPUSH
105444: CALL_OW 69
105448: ST_TO_ADDR
// if not tmp then
105449: LD_VAR 0 2
105453: NOT
105454: IFFALSE 105458
// exit ;
105456: GO 105487
// for i in tmp do
105458: LD_ADDR_VAR 0 1
105462: PUSH
105463: LD_VAR 0 2
105467: PUSH
105468: FOR_IN
105469: IFFALSE 105485
// SetLives ( i , 1 ) ;
105471: LD_VAR 0 1
105475: PPUSH
105476: LD_INT 1
105478: PPUSH
105479: CALL_OW 234
105483: GO 105468
105485: POP
105486: POP
// end ;
105487: PPOPN 2
105489: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105490: LD_EXP 124
105494: PUSH
105495: LD_EXP 173
105499: AND
105500: IFFALSE 105787
105502: GO 105504
105504: DISABLE
105505: LD_INT 0
105507: PPUSH
105508: PPUSH
105509: PPUSH
// begin i := rand ( 1 , 7 ) ;
105510: LD_ADDR_VAR 0 1
105514: PUSH
105515: LD_INT 1
105517: PPUSH
105518: LD_INT 7
105520: PPUSH
105521: CALL_OW 12
105525: ST_TO_ADDR
// case i of 1 :
105526: LD_VAR 0 1
105530: PUSH
105531: LD_INT 1
105533: DOUBLE
105534: EQUAL
105535: IFTRUE 105539
105537: GO 105549
105539: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105540: LD_STRING earthquake(getX(game), 0, 32)
105542: PPUSH
105543: CALL_OW 559
105547: GO 105787
105549: LD_INT 2
105551: DOUBLE
105552: EQUAL
105553: IFTRUE 105557
105555: GO 105571
105557: POP
// begin ToLua ( displayStucuk(); ) ;
105558: LD_STRING displayStucuk();
105560: PPUSH
105561: CALL_OW 559
// ResetFog ;
105565: CALL_OW 335
// end ; 3 :
105569: GO 105787
105571: LD_INT 3
105573: DOUBLE
105574: EQUAL
105575: IFTRUE 105579
105577: GO 105683
105579: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105580: LD_ADDR_VAR 0 2
105584: PUSH
105585: LD_INT 22
105587: PUSH
105588: LD_OWVAR 2
105592: PUSH
105593: EMPTY
105594: LIST
105595: LIST
105596: PUSH
105597: LD_INT 25
105599: PUSH
105600: LD_INT 1
105602: PUSH
105603: EMPTY
105604: LIST
105605: LIST
105606: PUSH
105607: EMPTY
105608: LIST
105609: LIST
105610: PPUSH
105611: CALL_OW 69
105615: ST_TO_ADDR
// if not tmp then
105616: LD_VAR 0 2
105620: NOT
105621: IFFALSE 105625
// exit ;
105623: GO 105787
// un := tmp [ rand ( 1 , tmp ) ] ;
105625: LD_ADDR_VAR 0 3
105629: PUSH
105630: LD_VAR 0 2
105634: PUSH
105635: LD_INT 1
105637: PPUSH
105638: LD_VAR 0 2
105642: PPUSH
105643: CALL_OW 12
105647: ARRAY
105648: ST_TO_ADDR
// if Crawls ( un ) then
105649: LD_VAR 0 3
105653: PPUSH
105654: CALL_OW 318
105658: IFFALSE 105669
// ComWalk ( un ) ;
105660: LD_VAR 0 3
105664: PPUSH
105665: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105669: LD_VAR 0 3
105673: PPUSH
105674: LD_INT 8
105676: PPUSH
105677: CALL_OW 336
// end ; 4 :
105681: GO 105787
105683: LD_INT 4
105685: DOUBLE
105686: EQUAL
105687: IFTRUE 105691
105689: GO 105765
105691: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105692: LD_ADDR_VAR 0 2
105696: PUSH
105697: LD_INT 22
105699: PUSH
105700: LD_OWVAR 2
105704: PUSH
105705: EMPTY
105706: LIST
105707: LIST
105708: PUSH
105709: LD_INT 30
105711: PUSH
105712: LD_INT 29
105714: PUSH
105715: EMPTY
105716: LIST
105717: LIST
105718: PUSH
105719: EMPTY
105720: LIST
105721: LIST
105722: PPUSH
105723: CALL_OW 69
105727: ST_TO_ADDR
// if not tmp then
105728: LD_VAR 0 2
105732: NOT
105733: IFFALSE 105737
// exit ;
105735: GO 105787
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105737: LD_VAR 0 2
105741: PUSH
105742: LD_INT 1
105744: ARRAY
105745: PPUSH
105746: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105750: LD_VAR 0 2
105754: PUSH
105755: LD_INT 1
105757: ARRAY
105758: PPUSH
105759: CALL_OW 65
// end ; 5 .. 7 :
105763: GO 105787
105765: LD_INT 5
105767: DOUBLE
105768: GREATEREQUAL
105769: IFFALSE 105777
105771: LD_INT 7
105773: DOUBLE
105774: LESSEQUAL
105775: IFTRUE 105779
105777: GO 105786
105779: POP
// StreamSibBomb ; end ;
105780: CALL 102024 0 0
105784: GO 105787
105786: POP
// end ;
105787: PPOPN 3
105789: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105790: LD_EXP 124
105794: PUSH
105795: LD_EXP 174
105799: AND
105800: IFFALSE 105956
105802: GO 105804
105804: DISABLE
105805: LD_INT 0
105807: PPUSH
105808: PPUSH
105809: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
105810: LD_ADDR_VAR 0 2
105814: PUSH
105815: LD_INT 81
105817: PUSH
105818: LD_OWVAR 2
105822: PUSH
105823: EMPTY
105824: LIST
105825: LIST
105826: PUSH
105827: LD_INT 2
105829: PUSH
105830: LD_INT 21
105832: PUSH
105833: LD_INT 1
105835: PUSH
105836: EMPTY
105837: LIST
105838: LIST
105839: PUSH
105840: LD_INT 21
105842: PUSH
105843: LD_INT 2
105845: PUSH
105846: EMPTY
105847: LIST
105848: LIST
105849: PUSH
105850: EMPTY
105851: LIST
105852: LIST
105853: LIST
105854: PUSH
105855: EMPTY
105856: LIST
105857: LIST
105858: PPUSH
105859: CALL_OW 69
105863: ST_TO_ADDR
// if not tmp then
105864: LD_VAR 0 2
105868: NOT
105869: IFFALSE 105873
// exit ;
105871: GO 105956
// p := 0 ;
105873: LD_ADDR_VAR 0 3
105877: PUSH
105878: LD_INT 0
105880: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105881: LD_INT 35
105883: PPUSH
105884: CALL_OW 67
// p := p + 1 ;
105888: LD_ADDR_VAR 0 3
105892: PUSH
105893: LD_VAR 0 3
105897: PUSH
105898: LD_INT 1
105900: PLUS
105901: ST_TO_ADDR
// for i in tmp do
105902: LD_ADDR_VAR 0 1
105906: PUSH
105907: LD_VAR 0 2
105911: PUSH
105912: FOR_IN
105913: IFFALSE 105944
// if GetLives ( i ) < 1000 then
105915: LD_VAR 0 1
105919: PPUSH
105920: CALL_OW 256
105924: PUSH
105925: LD_INT 1000
105927: LESS
105928: IFFALSE 105942
// SetLives ( i , 1000 ) ;
105930: LD_VAR 0 1
105934: PPUSH
105935: LD_INT 1000
105937: PPUSH
105938: CALL_OW 234
105942: GO 105912
105944: POP
105945: POP
// until p > 20 ;
105946: LD_VAR 0 3
105950: PUSH
105951: LD_INT 20
105953: GREATER
105954: IFFALSE 105881
// end ;
105956: PPOPN 3
105958: END
// every 0 0$1 trigger StreamModeActive and sTime do
105959: LD_EXP 124
105963: PUSH
105964: LD_EXP 175
105968: AND
105969: IFFALSE 106004
105971: GO 105973
105973: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105974: LD_INT 28
105976: PPUSH
105977: LD_OWVAR 2
105981: PPUSH
105982: LD_INT 2
105984: PPUSH
105985: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105989: LD_INT 30
105991: PPUSH
105992: LD_OWVAR 2
105996: PPUSH
105997: LD_INT 2
105999: PPUSH
106000: CALL_OW 322
// end ;
106004: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106005: LD_EXP 124
106009: PUSH
106010: LD_EXP 176
106014: AND
106015: IFFALSE 106136
106017: GO 106019
106019: DISABLE
106020: LD_INT 0
106022: PPUSH
106023: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106024: LD_ADDR_VAR 0 2
106028: PUSH
106029: LD_INT 22
106031: PUSH
106032: LD_OWVAR 2
106036: PUSH
106037: EMPTY
106038: LIST
106039: LIST
106040: PUSH
106041: LD_INT 21
106043: PUSH
106044: LD_INT 1
106046: PUSH
106047: EMPTY
106048: LIST
106049: LIST
106050: PUSH
106051: LD_INT 3
106053: PUSH
106054: LD_INT 23
106056: PUSH
106057: LD_INT 0
106059: PUSH
106060: EMPTY
106061: LIST
106062: LIST
106063: PUSH
106064: EMPTY
106065: LIST
106066: LIST
106067: PUSH
106068: EMPTY
106069: LIST
106070: LIST
106071: LIST
106072: PPUSH
106073: CALL_OW 69
106077: ST_TO_ADDR
// if not tmp then
106078: LD_VAR 0 2
106082: NOT
106083: IFFALSE 106087
// exit ;
106085: GO 106136
// for i in tmp do
106087: LD_ADDR_VAR 0 1
106091: PUSH
106092: LD_VAR 0 2
106096: PUSH
106097: FOR_IN
106098: IFFALSE 106134
// begin if Crawls ( i ) then
106100: LD_VAR 0 1
106104: PPUSH
106105: CALL_OW 318
106109: IFFALSE 106120
// ComWalk ( i ) ;
106111: LD_VAR 0 1
106115: PPUSH
106116: CALL_OW 138
// SetClass ( i , 2 ) ;
106120: LD_VAR 0 1
106124: PPUSH
106125: LD_INT 2
106127: PPUSH
106128: CALL_OW 336
// end ;
106132: GO 106097
106134: POP
106135: POP
// end ;
106136: PPOPN 2
106138: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106139: LD_EXP 124
106143: PUSH
106144: LD_EXP 177
106148: AND
106149: IFFALSE 106437
106151: GO 106153
106153: DISABLE
106154: LD_INT 0
106156: PPUSH
106157: PPUSH
106158: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106159: LD_OWVAR 2
106163: PPUSH
106164: LD_INT 9
106166: PPUSH
106167: LD_INT 1
106169: PPUSH
106170: LD_INT 1
106172: PPUSH
106173: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106177: LD_INT 9
106179: PPUSH
106180: LD_OWVAR 2
106184: PPUSH
106185: CALL_OW 343
// uc_side := 9 ;
106189: LD_ADDR_OWVAR 20
106193: PUSH
106194: LD_INT 9
106196: ST_TO_ADDR
// uc_nation := 2 ;
106197: LD_ADDR_OWVAR 21
106201: PUSH
106202: LD_INT 2
106204: ST_TO_ADDR
// hc_name := Dark Warrior ;
106205: LD_ADDR_OWVAR 26
106209: PUSH
106210: LD_STRING Dark Warrior
106212: ST_TO_ADDR
// hc_gallery :=  ;
106213: LD_ADDR_OWVAR 33
106217: PUSH
106218: LD_STRING 
106220: ST_TO_ADDR
// hc_noskilllimit := true ;
106221: LD_ADDR_OWVAR 76
106225: PUSH
106226: LD_INT 1
106228: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106229: LD_ADDR_OWVAR 31
106233: PUSH
106234: LD_INT 30
106236: PUSH
106237: LD_INT 30
106239: PUSH
106240: LD_INT 30
106242: PUSH
106243: LD_INT 30
106245: PUSH
106246: EMPTY
106247: LIST
106248: LIST
106249: LIST
106250: LIST
106251: ST_TO_ADDR
// un := CreateHuman ;
106252: LD_ADDR_VAR 0 3
106256: PUSH
106257: CALL_OW 44
106261: ST_TO_ADDR
// hc_noskilllimit := false ;
106262: LD_ADDR_OWVAR 76
106266: PUSH
106267: LD_INT 0
106269: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106270: LD_VAR 0 3
106274: PPUSH
106275: LD_INT 1
106277: PPUSH
106278: CALL_OW 51
// ToLua ( playRanger() ) ;
106282: LD_STRING playRanger()
106284: PPUSH
106285: CALL_OW 559
// p := 0 ;
106289: LD_ADDR_VAR 0 2
106293: PUSH
106294: LD_INT 0
106296: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106297: LD_INT 35
106299: PPUSH
106300: CALL_OW 67
// p := p + 1 ;
106304: LD_ADDR_VAR 0 2
106308: PUSH
106309: LD_VAR 0 2
106313: PUSH
106314: LD_INT 1
106316: PLUS
106317: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106318: LD_VAR 0 3
106322: PPUSH
106323: CALL_OW 256
106327: PUSH
106328: LD_INT 1000
106330: LESS
106331: IFFALSE 106345
// SetLives ( un , 1000 ) ;
106333: LD_VAR 0 3
106337: PPUSH
106338: LD_INT 1000
106340: PPUSH
106341: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106345: LD_VAR 0 3
106349: PPUSH
106350: LD_INT 81
106352: PUSH
106353: LD_OWVAR 2
106357: PUSH
106358: EMPTY
106359: LIST
106360: LIST
106361: PUSH
106362: LD_INT 91
106364: PUSH
106365: LD_VAR 0 3
106369: PUSH
106370: LD_INT 30
106372: PUSH
106373: EMPTY
106374: LIST
106375: LIST
106376: LIST
106377: PUSH
106378: EMPTY
106379: LIST
106380: LIST
106381: PPUSH
106382: CALL_OW 69
106386: PPUSH
106387: LD_VAR 0 3
106391: PPUSH
106392: CALL_OW 74
106396: PPUSH
106397: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106401: LD_VAR 0 2
106405: PUSH
106406: LD_INT 80
106408: GREATER
106409: PUSH
106410: LD_VAR 0 3
106414: PPUSH
106415: CALL_OW 301
106419: OR
106420: IFFALSE 106297
// if un then
106422: LD_VAR 0 3
106426: IFFALSE 106437
// RemoveUnit ( un ) ;
106428: LD_VAR 0 3
106432: PPUSH
106433: CALL_OW 64
// end ;
106437: PPOPN 3
106439: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106440: LD_EXP 178
106444: IFFALSE 106560
106446: GO 106448
106448: DISABLE
106449: LD_INT 0
106451: PPUSH
106452: PPUSH
106453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106454: LD_ADDR_VAR 0 2
106458: PUSH
106459: LD_INT 81
106461: PUSH
106462: LD_OWVAR 2
106466: PUSH
106467: EMPTY
106468: LIST
106469: LIST
106470: PUSH
106471: LD_INT 21
106473: PUSH
106474: LD_INT 1
106476: PUSH
106477: EMPTY
106478: LIST
106479: LIST
106480: PUSH
106481: EMPTY
106482: LIST
106483: LIST
106484: PPUSH
106485: CALL_OW 69
106489: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106490: LD_STRING playComputer()
106492: PPUSH
106493: CALL_OW 559
// if not tmp then
106497: LD_VAR 0 2
106501: NOT
106502: IFFALSE 106506
// exit ;
106504: GO 106560
// for i in tmp do
106506: LD_ADDR_VAR 0 1
106510: PUSH
106511: LD_VAR 0 2
106515: PUSH
106516: FOR_IN
106517: IFFALSE 106558
// for j := 1 to 4 do
106519: LD_ADDR_VAR 0 3
106523: PUSH
106524: DOUBLE
106525: LD_INT 1
106527: DEC
106528: ST_TO_ADDR
106529: LD_INT 4
106531: PUSH
106532: FOR_TO
106533: IFFALSE 106554
// SetSkill ( i , j , 10 ) ;
106535: LD_VAR 0 1
106539: PPUSH
106540: LD_VAR 0 3
106544: PPUSH
106545: LD_INT 10
106547: PPUSH
106548: CALL_OW 237
106552: GO 106532
106554: POP
106555: POP
106556: GO 106516
106558: POP
106559: POP
// end ;
106560: PPOPN 3
106562: END
// every 0 0$1 trigger s30 do var i , tmp ;
106563: LD_EXP 179
106567: IFFALSE 106636
106569: GO 106571
106571: DISABLE
106572: LD_INT 0
106574: PPUSH
106575: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106576: LD_ADDR_VAR 0 2
106580: PUSH
106581: LD_INT 22
106583: PUSH
106584: LD_OWVAR 2
106588: PUSH
106589: EMPTY
106590: LIST
106591: LIST
106592: PPUSH
106593: CALL_OW 69
106597: ST_TO_ADDR
// if not tmp then
106598: LD_VAR 0 2
106602: NOT
106603: IFFALSE 106607
// exit ;
106605: GO 106636
// for i in tmp do
106607: LD_ADDR_VAR 0 1
106611: PUSH
106612: LD_VAR 0 2
106616: PUSH
106617: FOR_IN
106618: IFFALSE 106634
// SetLives ( i , 300 ) ;
106620: LD_VAR 0 1
106624: PPUSH
106625: LD_INT 300
106627: PPUSH
106628: CALL_OW 234
106632: GO 106617
106634: POP
106635: POP
// end ;
106636: PPOPN 2
106638: END
// every 0 0$1 trigger s60 do var i , tmp ;
106639: LD_EXP 180
106643: IFFALSE 106712
106645: GO 106647
106647: DISABLE
106648: LD_INT 0
106650: PPUSH
106651: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106652: LD_ADDR_VAR 0 2
106656: PUSH
106657: LD_INT 22
106659: PUSH
106660: LD_OWVAR 2
106664: PUSH
106665: EMPTY
106666: LIST
106667: LIST
106668: PPUSH
106669: CALL_OW 69
106673: ST_TO_ADDR
// if not tmp then
106674: LD_VAR 0 2
106678: NOT
106679: IFFALSE 106683
// exit ;
106681: GO 106712
// for i in tmp do
106683: LD_ADDR_VAR 0 1
106687: PUSH
106688: LD_VAR 0 2
106692: PUSH
106693: FOR_IN
106694: IFFALSE 106710
// SetLives ( i , 600 ) ;
106696: LD_VAR 0 1
106700: PPUSH
106701: LD_INT 600
106703: PPUSH
106704: CALL_OW 234
106708: GO 106693
106710: POP
106711: POP
// end ;
106712: PPOPN 2
106714: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106715: LD_INT 0
106717: PPUSH
// case cmd of 301 :
106718: LD_VAR 0 1
106722: PUSH
106723: LD_INT 301
106725: DOUBLE
106726: EQUAL
106727: IFTRUE 106731
106729: GO 106763
106731: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106732: LD_VAR 0 6
106736: PPUSH
106737: LD_VAR 0 7
106741: PPUSH
106742: LD_VAR 0 8
106746: PPUSH
106747: LD_VAR 0 4
106751: PPUSH
106752: LD_VAR 0 5
106756: PPUSH
106757: CALL 107972 0 5
106761: GO 106884
106763: LD_INT 302
106765: DOUBLE
106766: EQUAL
106767: IFTRUE 106771
106769: GO 106808
106771: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106772: LD_VAR 0 6
106776: PPUSH
106777: LD_VAR 0 7
106781: PPUSH
106782: LD_VAR 0 8
106786: PPUSH
106787: LD_VAR 0 9
106791: PPUSH
106792: LD_VAR 0 4
106796: PPUSH
106797: LD_VAR 0 5
106801: PPUSH
106802: CALL 108063 0 6
106806: GO 106884
106808: LD_INT 303
106810: DOUBLE
106811: EQUAL
106812: IFTRUE 106816
106814: GO 106853
106816: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
106817: LD_VAR 0 6
106821: PPUSH
106822: LD_VAR 0 7
106826: PPUSH
106827: LD_VAR 0 8
106831: PPUSH
106832: LD_VAR 0 9
106836: PPUSH
106837: LD_VAR 0 4
106841: PPUSH
106842: LD_VAR 0 5
106846: PPUSH
106847: CALL 106889 0 6
106851: GO 106884
106853: LD_INT 304
106855: DOUBLE
106856: EQUAL
106857: IFTRUE 106861
106859: GO 106883
106861: POP
// hHackTeleport ( unit , x , y ) ; end ;
106862: LD_VAR 0 2
106866: PPUSH
106867: LD_VAR 0 4
106871: PPUSH
106872: LD_VAR 0 5
106876: PPUSH
106877: CALL 108656 0 3
106881: GO 106884
106883: POP
// end ;
106884: LD_VAR 0 12
106888: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106889: LD_INT 0
106891: PPUSH
106892: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106893: LD_VAR 0 1
106897: PUSH
106898: LD_INT 1
106900: LESS
106901: PUSH
106902: LD_VAR 0 1
106906: PUSH
106907: LD_INT 3
106909: GREATER
106910: OR
106911: PUSH
106912: LD_VAR 0 5
106916: PPUSH
106917: LD_VAR 0 6
106921: PPUSH
106922: CALL_OW 428
106926: OR
106927: IFFALSE 106931
// exit ;
106929: GO 107659
// uc_side := your_side ;
106931: LD_ADDR_OWVAR 20
106935: PUSH
106936: LD_OWVAR 2
106940: ST_TO_ADDR
// uc_nation := nation ;
106941: LD_ADDR_OWVAR 21
106945: PUSH
106946: LD_VAR 0 1
106950: ST_TO_ADDR
// bc_level = 1 ;
106951: LD_ADDR_OWVAR 43
106955: PUSH
106956: LD_INT 1
106958: ST_TO_ADDR
// case btype of 1 :
106959: LD_VAR 0 2
106963: PUSH
106964: LD_INT 1
106966: DOUBLE
106967: EQUAL
106968: IFTRUE 106972
106970: GO 106983
106972: POP
// bc_type := b_depot ; 2 :
106973: LD_ADDR_OWVAR 42
106977: PUSH
106978: LD_INT 0
106980: ST_TO_ADDR
106981: GO 107603
106983: LD_INT 2
106985: DOUBLE
106986: EQUAL
106987: IFTRUE 106991
106989: GO 107002
106991: POP
// bc_type := b_warehouse ; 3 :
106992: LD_ADDR_OWVAR 42
106996: PUSH
106997: LD_INT 1
106999: ST_TO_ADDR
107000: GO 107603
107002: LD_INT 3
107004: DOUBLE
107005: EQUAL
107006: IFTRUE 107010
107008: GO 107021
107010: POP
// bc_type := b_lab ; 4 .. 9 :
107011: LD_ADDR_OWVAR 42
107015: PUSH
107016: LD_INT 6
107018: ST_TO_ADDR
107019: GO 107603
107021: LD_INT 4
107023: DOUBLE
107024: GREATEREQUAL
107025: IFFALSE 107033
107027: LD_INT 9
107029: DOUBLE
107030: LESSEQUAL
107031: IFTRUE 107035
107033: GO 107095
107035: POP
// begin bc_type := b_lab_half ;
107036: LD_ADDR_OWVAR 42
107040: PUSH
107041: LD_INT 7
107043: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107044: LD_ADDR_OWVAR 44
107048: PUSH
107049: LD_INT 10
107051: PUSH
107052: LD_INT 11
107054: PUSH
107055: LD_INT 12
107057: PUSH
107058: LD_INT 15
107060: PUSH
107061: LD_INT 14
107063: PUSH
107064: LD_INT 13
107066: PUSH
107067: EMPTY
107068: LIST
107069: LIST
107070: LIST
107071: LIST
107072: LIST
107073: LIST
107074: PUSH
107075: LD_VAR 0 2
107079: PUSH
107080: LD_INT 3
107082: MINUS
107083: ARRAY
107084: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
107085: LD_ADDR_OWVAR 45
107089: PUSH
107090: LD_INT 9
107092: ST_TO_ADDR
// end ; 10 .. 13 :
107093: GO 107603
107095: LD_INT 10
107097: DOUBLE
107098: GREATEREQUAL
107099: IFFALSE 107107
107101: LD_INT 13
107103: DOUBLE
107104: LESSEQUAL
107105: IFTRUE 107109
107107: GO 107186
107109: POP
// begin bc_type := b_lab_full ;
107110: LD_ADDR_OWVAR 42
107114: PUSH
107115: LD_INT 8
107117: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107118: LD_ADDR_OWVAR 44
107122: PUSH
107123: LD_INT 10
107125: PUSH
107126: LD_INT 12
107128: PUSH
107129: LD_INT 14
107131: PUSH
107132: LD_INT 13
107134: PUSH
107135: EMPTY
107136: LIST
107137: LIST
107138: LIST
107139: LIST
107140: PUSH
107141: LD_VAR 0 2
107145: PUSH
107146: LD_INT 9
107148: MINUS
107149: ARRAY
107150: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107151: LD_ADDR_OWVAR 45
107155: PUSH
107156: LD_INT 11
107158: PUSH
107159: LD_INT 15
107161: PUSH
107162: LD_INT 12
107164: PUSH
107165: LD_INT 15
107167: PUSH
107168: EMPTY
107169: LIST
107170: LIST
107171: LIST
107172: LIST
107173: PUSH
107174: LD_VAR 0 2
107178: PUSH
107179: LD_INT 9
107181: MINUS
107182: ARRAY
107183: ST_TO_ADDR
// end ; 14 :
107184: GO 107603
107186: LD_INT 14
107188: DOUBLE
107189: EQUAL
107190: IFTRUE 107194
107192: GO 107205
107194: POP
// bc_type := b_workshop ; 15 :
107195: LD_ADDR_OWVAR 42
107199: PUSH
107200: LD_INT 2
107202: ST_TO_ADDR
107203: GO 107603
107205: LD_INT 15
107207: DOUBLE
107208: EQUAL
107209: IFTRUE 107213
107211: GO 107224
107213: POP
// bc_type := b_factory ; 16 :
107214: LD_ADDR_OWVAR 42
107218: PUSH
107219: LD_INT 3
107221: ST_TO_ADDR
107222: GO 107603
107224: LD_INT 16
107226: DOUBLE
107227: EQUAL
107228: IFTRUE 107232
107230: GO 107243
107232: POP
// bc_type := b_ext_gun ; 17 :
107233: LD_ADDR_OWVAR 42
107237: PUSH
107238: LD_INT 17
107240: ST_TO_ADDR
107241: GO 107603
107243: LD_INT 17
107245: DOUBLE
107246: EQUAL
107247: IFTRUE 107251
107249: GO 107279
107251: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107252: LD_ADDR_OWVAR 42
107256: PUSH
107257: LD_INT 19
107259: PUSH
107260: LD_INT 23
107262: PUSH
107263: LD_INT 19
107265: PUSH
107266: EMPTY
107267: LIST
107268: LIST
107269: LIST
107270: PUSH
107271: LD_VAR 0 1
107275: ARRAY
107276: ST_TO_ADDR
107277: GO 107603
107279: LD_INT 18
107281: DOUBLE
107282: EQUAL
107283: IFTRUE 107287
107285: GO 107298
107287: POP
// bc_type := b_ext_radar ; 19 :
107288: LD_ADDR_OWVAR 42
107292: PUSH
107293: LD_INT 20
107295: ST_TO_ADDR
107296: GO 107603
107298: LD_INT 19
107300: DOUBLE
107301: EQUAL
107302: IFTRUE 107306
107304: GO 107317
107306: POP
// bc_type := b_ext_radio ; 20 :
107307: LD_ADDR_OWVAR 42
107311: PUSH
107312: LD_INT 22
107314: ST_TO_ADDR
107315: GO 107603
107317: LD_INT 20
107319: DOUBLE
107320: EQUAL
107321: IFTRUE 107325
107323: GO 107336
107325: POP
// bc_type := b_ext_siberium ; 21 :
107326: LD_ADDR_OWVAR 42
107330: PUSH
107331: LD_INT 21
107333: ST_TO_ADDR
107334: GO 107603
107336: LD_INT 21
107338: DOUBLE
107339: EQUAL
107340: IFTRUE 107344
107342: GO 107355
107344: POP
// bc_type := b_ext_computer ; 22 :
107345: LD_ADDR_OWVAR 42
107349: PUSH
107350: LD_INT 24
107352: ST_TO_ADDR
107353: GO 107603
107355: LD_INT 22
107357: DOUBLE
107358: EQUAL
107359: IFTRUE 107363
107361: GO 107374
107363: POP
// bc_type := b_ext_track ; 23 :
107364: LD_ADDR_OWVAR 42
107368: PUSH
107369: LD_INT 16
107371: ST_TO_ADDR
107372: GO 107603
107374: LD_INT 23
107376: DOUBLE
107377: EQUAL
107378: IFTRUE 107382
107380: GO 107393
107382: POP
// bc_type := b_ext_laser ; 24 :
107383: LD_ADDR_OWVAR 42
107387: PUSH
107388: LD_INT 25
107390: ST_TO_ADDR
107391: GO 107603
107393: LD_INT 24
107395: DOUBLE
107396: EQUAL
107397: IFTRUE 107401
107399: GO 107412
107401: POP
// bc_type := b_control_tower ; 25 :
107402: LD_ADDR_OWVAR 42
107406: PUSH
107407: LD_INT 36
107409: ST_TO_ADDR
107410: GO 107603
107412: LD_INT 25
107414: DOUBLE
107415: EQUAL
107416: IFTRUE 107420
107418: GO 107431
107420: POP
// bc_type := b_breastwork ; 26 :
107421: LD_ADDR_OWVAR 42
107425: PUSH
107426: LD_INT 31
107428: ST_TO_ADDR
107429: GO 107603
107431: LD_INT 26
107433: DOUBLE
107434: EQUAL
107435: IFTRUE 107439
107437: GO 107450
107439: POP
// bc_type := b_bunker ; 27 :
107440: LD_ADDR_OWVAR 42
107444: PUSH
107445: LD_INT 32
107447: ST_TO_ADDR
107448: GO 107603
107450: LD_INT 27
107452: DOUBLE
107453: EQUAL
107454: IFTRUE 107458
107456: GO 107469
107458: POP
// bc_type := b_turret ; 28 :
107459: LD_ADDR_OWVAR 42
107463: PUSH
107464: LD_INT 33
107466: ST_TO_ADDR
107467: GO 107603
107469: LD_INT 28
107471: DOUBLE
107472: EQUAL
107473: IFTRUE 107477
107475: GO 107488
107477: POP
// bc_type := b_armoury ; 29 :
107478: LD_ADDR_OWVAR 42
107482: PUSH
107483: LD_INT 4
107485: ST_TO_ADDR
107486: GO 107603
107488: LD_INT 29
107490: DOUBLE
107491: EQUAL
107492: IFTRUE 107496
107494: GO 107507
107496: POP
// bc_type := b_barracks ; 30 :
107497: LD_ADDR_OWVAR 42
107501: PUSH
107502: LD_INT 5
107504: ST_TO_ADDR
107505: GO 107603
107507: LD_INT 30
107509: DOUBLE
107510: EQUAL
107511: IFTRUE 107515
107513: GO 107526
107515: POP
// bc_type := b_solar_power ; 31 :
107516: LD_ADDR_OWVAR 42
107520: PUSH
107521: LD_INT 27
107523: ST_TO_ADDR
107524: GO 107603
107526: LD_INT 31
107528: DOUBLE
107529: EQUAL
107530: IFTRUE 107534
107532: GO 107545
107534: POP
// bc_type := b_oil_power ; 32 :
107535: LD_ADDR_OWVAR 42
107539: PUSH
107540: LD_INT 26
107542: ST_TO_ADDR
107543: GO 107603
107545: LD_INT 32
107547: DOUBLE
107548: EQUAL
107549: IFTRUE 107553
107551: GO 107564
107553: POP
// bc_type := b_siberite_power ; 33 :
107554: LD_ADDR_OWVAR 42
107558: PUSH
107559: LD_INT 28
107561: ST_TO_ADDR
107562: GO 107603
107564: LD_INT 33
107566: DOUBLE
107567: EQUAL
107568: IFTRUE 107572
107570: GO 107583
107572: POP
// bc_type := b_oil_mine ; 34 :
107573: LD_ADDR_OWVAR 42
107577: PUSH
107578: LD_INT 29
107580: ST_TO_ADDR
107581: GO 107603
107583: LD_INT 34
107585: DOUBLE
107586: EQUAL
107587: IFTRUE 107591
107589: GO 107602
107591: POP
// bc_type := b_siberite_mine ; end ;
107592: LD_ADDR_OWVAR 42
107596: PUSH
107597: LD_INT 30
107599: ST_TO_ADDR
107600: GO 107603
107602: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
107603: LD_ADDR_VAR 0 8
107607: PUSH
107608: LD_VAR 0 5
107612: PPUSH
107613: LD_VAR 0 6
107617: PPUSH
107618: LD_VAR 0 3
107622: PPUSH
107623: CALL_OW 47
107627: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
107628: LD_OWVAR 42
107632: PUSH
107633: LD_INT 32
107635: PUSH
107636: LD_INT 33
107638: PUSH
107639: EMPTY
107640: LIST
107641: LIST
107642: IN
107643: IFFALSE 107659
// PlaceWeaponTurret ( b , weapon ) ;
107645: LD_VAR 0 8
107649: PPUSH
107650: LD_VAR 0 4
107654: PPUSH
107655: CALL_OW 431
// end ;
107659: LD_VAR 0 7
107663: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107664: LD_INT 0
107666: PPUSH
107667: PPUSH
107668: PPUSH
107669: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107670: LD_ADDR_VAR 0 4
107674: PUSH
107675: LD_INT 22
107677: PUSH
107678: LD_OWVAR 2
107682: PUSH
107683: EMPTY
107684: LIST
107685: LIST
107686: PUSH
107687: LD_INT 2
107689: PUSH
107690: LD_INT 30
107692: PUSH
107693: LD_INT 0
107695: PUSH
107696: EMPTY
107697: LIST
107698: LIST
107699: PUSH
107700: LD_INT 30
107702: PUSH
107703: LD_INT 1
107705: PUSH
107706: EMPTY
107707: LIST
107708: LIST
107709: PUSH
107710: EMPTY
107711: LIST
107712: LIST
107713: LIST
107714: PUSH
107715: EMPTY
107716: LIST
107717: LIST
107718: PPUSH
107719: CALL_OW 69
107723: ST_TO_ADDR
// if not tmp then
107724: LD_VAR 0 4
107728: NOT
107729: IFFALSE 107733
// exit ;
107731: GO 107792
// for i in tmp do
107733: LD_ADDR_VAR 0 2
107737: PUSH
107738: LD_VAR 0 4
107742: PUSH
107743: FOR_IN
107744: IFFALSE 107790
// for j = 1 to 3 do
107746: LD_ADDR_VAR 0 3
107750: PUSH
107751: DOUBLE
107752: LD_INT 1
107754: DEC
107755: ST_TO_ADDR
107756: LD_INT 3
107758: PUSH
107759: FOR_TO
107760: IFFALSE 107786
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107762: LD_VAR 0 2
107766: PPUSH
107767: CALL_OW 274
107771: PPUSH
107772: LD_VAR 0 3
107776: PPUSH
107777: LD_INT 99999
107779: PPUSH
107780: CALL_OW 277
107784: GO 107759
107786: POP
107787: POP
107788: GO 107743
107790: POP
107791: POP
// end ;
107792: LD_VAR 0 1
107796: RET
// export function hHackSetLevel10 ; var i , j ; begin
107797: LD_INT 0
107799: PPUSH
107800: PPUSH
107801: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107802: LD_ADDR_VAR 0 2
107806: PUSH
107807: LD_INT 21
107809: PUSH
107810: LD_INT 1
107812: PUSH
107813: EMPTY
107814: LIST
107815: LIST
107816: PPUSH
107817: CALL_OW 69
107821: PUSH
107822: FOR_IN
107823: IFFALSE 107875
// if IsSelected ( i ) then
107825: LD_VAR 0 2
107829: PPUSH
107830: CALL_OW 306
107834: IFFALSE 107873
// begin for j := 1 to 4 do
107836: LD_ADDR_VAR 0 3
107840: PUSH
107841: DOUBLE
107842: LD_INT 1
107844: DEC
107845: ST_TO_ADDR
107846: LD_INT 4
107848: PUSH
107849: FOR_TO
107850: IFFALSE 107871
// SetSkill ( i , j , 10 ) ;
107852: LD_VAR 0 2
107856: PPUSH
107857: LD_VAR 0 3
107861: PPUSH
107862: LD_INT 10
107864: PPUSH
107865: CALL_OW 237
107869: GO 107849
107871: POP
107872: POP
// end ;
107873: GO 107822
107875: POP
107876: POP
// end ;
107877: LD_VAR 0 1
107881: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107882: LD_INT 0
107884: PPUSH
107885: PPUSH
107886: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107887: LD_ADDR_VAR 0 2
107891: PUSH
107892: LD_INT 22
107894: PUSH
107895: LD_OWVAR 2
107899: PUSH
107900: EMPTY
107901: LIST
107902: LIST
107903: PUSH
107904: LD_INT 21
107906: PUSH
107907: LD_INT 1
107909: PUSH
107910: EMPTY
107911: LIST
107912: LIST
107913: PUSH
107914: EMPTY
107915: LIST
107916: LIST
107917: PPUSH
107918: CALL_OW 69
107922: PUSH
107923: FOR_IN
107924: IFFALSE 107965
// begin for j := 1 to 4 do
107926: LD_ADDR_VAR 0 3
107930: PUSH
107931: DOUBLE
107932: LD_INT 1
107934: DEC
107935: ST_TO_ADDR
107936: LD_INT 4
107938: PUSH
107939: FOR_TO
107940: IFFALSE 107961
// SetSkill ( i , j , 10 ) ;
107942: LD_VAR 0 2
107946: PPUSH
107947: LD_VAR 0 3
107951: PPUSH
107952: LD_INT 10
107954: PPUSH
107955: CALL_OW 237
107959: GO 107939
107961: POP
107962: POP
// end ;
107963: GO 107923
107965: POP
107966: POP
// end ;
107967: LD_VAR 0 1
107971: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107972: LD_INT 0
107974: PPUSH
// uc_side := your_side ;
107975: LD_ADDR_OWVAR 20
107979: PUSH
107980: LD_OWVAR 2
107984: ST_TO_ADDR
// uc_nation := nation ;
107985: LD_ADDR_OWVAR 21
107989: PUSH
107990: LD_VAR 0 1
107994: ST_TO_ADDR
// InitHc ;
107995: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107999: LD_INT 0
108001: PPUSH
108002: LD_VAR 0 2
108006: PPUSH
108007: LD_VAR 0 3
108011: PPUSH
108012: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108016: LD_VAR 0 4
108020: PPUSH
108021: LD_VAR 0 5
108025: PPUSH
108026: CALL_OW 428
108030: PUSH
108031: LD_INT 0
108033: EQUAL
108034: IFFALSE 108058
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108036: CALL_OW 44
108040: PPUSH
108041: LD_VAR 0 4
108045: PPUSH
108046: LD_VAR 0 5
108050: PPUSH
108051: LD_INT 1
108053: PPUSH
108054: CALL_OW 48
// end ;
108058: LD_VAR 0 6
108062: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108063: LD_INT 0
108065: PPUSH
108066: PPUSH
// uc_side := your_side ;
108067: LD_ADDR_OWVAR 20
108071: PUSH
108072: LD_OWVAR 2
108076: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108077: LD_VAR 0 1
108081: PUSH
108082: LD_INT 1
108084: PUSH
108085: LD_INT 2
108087: PUSH
108088: LD_INT 3
108090: PUSH
108091: LD_INT 4
108093: PUSH
108094: LD_INT 5
108096: PUSH
108097: EMPTY
108098: LIST
108099: LIST
108100: LIST
108101: LIST
108102: LIST
108103: IN
108104: IFFALSE 108116
// uc_nation := nation_american else
108106: LD_ADDR_OWVAR 21
108110: PUSH
108111: LD_INT 1
108113: ST_TO_ADDR
108114: GO 108159
// if chassis in [ 11 , 12 , 13 , 14 ] then
108116: LD_VAR 0 1
108120: PUSH
108121: LD_INT 11
108123: PUSH
108124: LD_INT 12
108126: PUSH
108127: LD_INT 13
108129: PUSH
108130: LD_INT 14
108132: PUSH
108133: EMPTY
108134: LIST
108135: LIST
108136: LIST
108137: LIST
108138: IN
108139: IFFALSE 108151
// uc_nation := nation_arabian else
108141: LD_ADDR_OWVAR 21
108145: PUSH
108146: LD_INT 2
108148: ST_TO_ADDR
108149: GO 108159
// uc_nation := nation_russian ;
108151: LD_ADDR_OWVAR 21
108155: PUSH
108156: LD_INT 3
108158: ST_TO_ADDR
// vc_chassis := chassis ;
108159: LD_ADDR_OWVAR 37
108163: PUSH
108164: LD_VAR 0 1
108168: ST_TO_ADDR
// vc_engine := engine ;
108169: LD_ADDR_OWVAR 39
108173: PUSH
108174: LD_VAR 0 2
108178: ST_TO_ADDR
// vc_control := control ;
108179: LD_ADDR_OWVAR 38
108183: PUSH
108184: LD_VAR 0 3
108188: ST_TO_ADDR
// vc_weapon := weapon ;
108189: LD_ADDR_OWVAR 40
108193: PUSH
108194: LD_VAR 0 4
108198: ST_TO_ADDR
// un := CreateVehicle ;
108199: LD_ADDR_VAR 0 8
108203: PUSH
108204: CALL_OW 45
108208: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108209: LD_VAR 0 8
108213: PPUSH
108214: LD_INT 0
108216: PPUSH
108217: LD_INT 5
108219: PPUSH
108220: CALL_OW 12
108224: PPUSH
108225: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108229: LD_VAR 0 8
108233: PPUSH
108234: LD_VAR 0 5
108238: PPUSH
108239: LD_VAR 0 6
108243: PPUSH
108244: LD_INT 1
108246: PPUSH
108247: CALL_OW 48
// end ;
108251: LD_VAR 0 7
108255: RET
// export hInvincible ; every 1 do
108256: GO 108258
108258: DISABLE
// hInvincible := [ ] ;
108259: LD_ADDR_EXP 181
108263: PUSH
108264: EMPTY
108265: ST_TO_ADDR
108266: END
// every 10 do var i ;
108267: GO 108269
108269: DISABLE
108270: LD_INT 0
108272: PPUSH
// begin enable ;
108273: ENABLE
// if not hInvincible then
108274: LD_EXP 181
108278: NOT
108279: IFFALSE 108283
// exit ;
108281: GO 108327
// for i in hInvincible do
108283: LD_ADDR_VAR 0 1
108287: PUSH
108288: LD_EXP 181
108292: PUSH
108293: FOR_IN
108294: IFFALSE 108325
// if GetLives ( i ) < 1000 then
108296: LD_VAR 0 1
108300: PPUSH
108301: CALL_OW 256
108305: PUSH
108306: LD_INT 1000
108308: LESS
108309: IFFALSE 108323
// SetLives ( i , 1000 ) ;
108311: LD_VAR 0 1
108315: PPUSH
108316: LD_INT 1000
108318: PPUSH
108319: CALL_OW 234
108323: GO 108293
108325: POP
108326: POP
// end ;
108327: PPOPN 1
108329: END
// export function hHackInvincible ; var i ; begin
108330: LD_INT 0
108332: PPUSH
108333: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108334: LD_ADDR_VAR 0 2
108338: PUSH
108339: LD_INT 2
108341: PUSH
108342: LD_INT 21
108344: PUSH
108345: LD_INT 1
108347: PUSH
108348: EMPTY
108349: LIST
108350: LIST
108351: PUSH
108352: LD_INT 21
108354: PUSH
108355: LD_INT 2
108357: PUSH
108358: EMPTY
108359: LIST
108360: LIST
108361: PUSH
108362: EMPTY
108363: LIST
108364: LIST
108365: LIST
108366: PPUSH
108367: CALL_OW 69
108371: PUSH
108372: FOR_IN
108373: IFFALSE 108434
// if IsSelected ( i ) then
108375: LD_VAR 0 2
108379: PPUSH
108380: CALL_OW 306
108384: IFFALSE 108432
// begin if i in hInvincible then
108386: LD_VAR 0 2
108390: PUSH
108391: LD_EXP 181
108395: IN
108396: IFFALSE 108416
// hInvincible := hInvincible diff i else
108398: LD_ADDR_EXP 181
108402: PUSH
108403: LD_EXP 181
108407: PUSH
108408: LD_VAR 0 2
108412: DIFF
108413: ST_TO_ADDR
108414: GO 108432
// hInvincible := hInvincible union i ;
108416: LD_ADDR_EXP 181
108420: PUSH
108421: LD_EXP 181
108425: PUSH
108426: LD_VAR 0 2
108430: UNION
108431: ST_TO_ADDR
// end ;
108432: GO 108372
108434: POP
108435: POP
// end ;
108436: LD_VAR 0 1
108440: RET
// export function hHackInvisible ; var i , j ; begin
108441: LD_INT 0
108443: PPUSH
108444: PPUSH
108445: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108446: LD_ADDR_VAR 0 2
108450: PUSH
108451: LD_INT 21
108453: PUSH
108454: LD_INT 1
108456: PUSH
108457: EMPTY
108458: LIST
108459: LIST
108460: PPUSH
108461: CALL_OW 69
108465: PUSH
108466: FOR_IN
108467: IFFALSE 108491
// if IsSelected ( i ) then
108469: LD_VAR 0 2
108473: PPUSH
108474: CALL_OW 306
108478: IFFALSE 108489
// ComForceInvisible ( i ) ;
108480: LD_VAR 0 2
108484: PPUSH
108485: CALL_OW 496
108489: GO 108466
108491: POP
108492: POP
// end ;
108493: LD_VAR 0 1
108497: RET
// export function hHackChangeYourSide ; begin
108498: LD_INT 0
108500: PPUSH
// if your_side = 8 then
108501: LD_OWVAR 2
108505: PUSH
108506: LD_INT 8
108508: EQUAL
108509: IFFALSE 108521
// your_side := 0 else
108511: LD_ADDR_OWVAR 2
108515: PUSH
108516: LD_INT 0
108518: ST_TO_ADDR
108519: GO 108535
// your_side := your_side + 1 ;
108521: LD_ADDR_OWVAR 2
108525: PUSH
108526: LD_OWVAR 2
108530: PUSH
108531: LD_INT 1
108533: PLUS
108534: ST_TO_ADDR
// end ;
108535: LD_VAR 0 1
108539: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108540: LD_INT 0
108542: PPUSH
108543: PPUSH
108544: PPUSH
// for i in all_units do
108545: LD_ADDR_VAR 0 2
108549: PUSH
108550: LD_OWVAR 3
108554: PUSH
108555: FOR_IN
108556: IFFALSE 108634
// if IsSelected ( i ) then
108558: LD_VAR 0 2
108562: PPUSH
108563: CALL_OW 306
108567: IFFALSE 108632
// begin j := GetSide ( i ) ;
108569: LD_ADDR_VAR 0 3
108573: PUSH
108574: LD_VAR 0 2
108578: PPUSH
108579: CALL_OW 255
108583: ST_TO_ADDR
// if j = 8 then
108584: LD_VAR 0 3
108588: PUSH
108589: LD_INT 8
108591: EQUAL
108592: IFFALSE 108604
// j := 0 else
108594: LD_ADDR_VAR 0 3
108598: PUSH
108599: LD_INT 0
108601: ST_TO_ADDR
108602: GO 108618
// j := j + 1 ;
108604: LD_ADDR_VAR 0 3
108608: PUSH
108609: LD_VAR 0 3
108613: PUSH
108614: LD_INT 1
108616: PLUS
108617: ST_TO_ADDR
// SetSide ( i , j ) ;
108618: LD_VAR 0 2
108622: PPUSH
108623: LD_VAR 0 3
108627: PPUSH
108628: CALL_OW 235
// end ;
108632: GO 108555
108634: POP
108635: POP
// end ;
108636: LD_VAR 0 1
108640: RET
// export function hHackFog ; begin
108641: LD_INT 0
108643: PPUSH
// FogOff ( true ) ;
108644: LD_INT 1
108646: PPUSH
108647: CALL_OW 344
// end ;
108651: LD_VAR 0 1
108655: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108656: LD_INT 0
108658: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108659: LD_VAR 0 1
108663: PPUSH
108664: LD_VAR 0 2
108668: PPUSH
108669: LD_VAR 0 3
108673: PPUSH
108674: LD_INT 1
108676: PPUSH
108677: LD_INT 1
108679: PPUSH
108680: CALL_OW 483
// CenterOnXY ( x , y ) ;
108684: LD_VAR 0 2
108688: PPUSH
108689: LD_VAR 0 3
108693: PPUSH
108694: CALL_OW 84
// end ;
108698: LD_VAR 0 4
108702: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
108703: LD_INT 0
108705: PPUSH
108706: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
108707: LD_VAR 0 1
108711: NOT
108712: PUSH
108713: LD_VAR 0 2
108717: PPUSH
108718: LD_VAR 0 3
108722: PPUSH
108723: CALL_OW 488
108727: NOT
108728: OR
108729: PUSH
108730: LD_VAR 0 1
108734: PPUSH
108735: CALL_OW 266
108739: PUSH
108740: LD_INT 3
108742: NONEQUAL
108743: PUSH
108744: LD_VAR 0 1
108748: PPUSH
108749: CALL_OW 247
108753: PUSH
108754: LD_INT 1
108756: EQUAL
108757: NOT
108758: AND
108759: OR
108760: IFFALSE 108764
// exit ;
108762: GO 108913
// if GetType ( factory ) = unit_human then
108764: LD_VAR 0 1
108768: PPUSH
108769: CALL_OW 247
108773: PUSH
108774: LD_INT 1
108776: EQUAL
108777: IFFALSE 108794
// factory := IsInUnit ( factory ) ;
108779: LD_ADDR_VAR 0 1
108783: PUSH
108784: LD_VAR 0 1
108788: PPUSH
108789: CALL_OW 310
108793: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108794: LD_VAR 0 1
108798: PPUSH
108799: CALL_OW 266
108803: PUSH
108804: LD_INT 3
108806: NONEQUAL
108807: IFFALSE 108811
// exit ;
108809: GO 108913
// if HexInfo ( x , y ) = factory then
108811: LD_VAR 0 2
108815: PPUSH
108816: LD_VAR 0 3
108820: PPUSH
108821: CALL_OW 428
108825: PUSH
108826: LD_VAR 0 1
108830: EQUAL
108831: IFFALSE 108858
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
108833: LD_ADDR_EXP 182
108837: PUSH
108838: LD_EXP 182
108842: PPUSH
108843: LD_VAR 0 1
108847: PPUSH
108848: LD_INT 0
108850: PPUSH
108851: CALL_OW 1
108855: ST_TO_ADDR
108856: GO 108909
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
108858: LD_ADDR_EXP 182
108862: PUSH
108863: LD_EXP 182
108867: PPUSH
108868: LD_VAR 0 1
108872: PPUSH
108873: LD_VAR 0 1
108877: PPUSH
108878: CALL_OW 255
108882: PUSH
108883: LD_VAR 0 1
108887: PUSH
108888: LD_VAR 0 2
108892: PUSH
108893: LD_VAR 0 3
108897: PUSH
108898: EMPTY
108899: LIST
108900: LIST
108901: LIST
108902: LIST
108903: PPUSH
108904: CALL_OW 1
108908: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108909: CALL 108918 0 0
// end ;
108913: LD_VAR 0 4
108917: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
108918: LD_INT 0
108920: PPUSH
108921: PPUSH
108922: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
108923: LD_STRING resetFactoryWaypoint();
108925: PPUSH
108926: CALL_OW 559
// if factoryWaypoints then
108930: LD_EXP 182
108934: IFFALSE 109060
// begin list := PrepareArray ( factoryWaypoints ) ;
108936: LD_ADDR_VAR 0 3
108940: PUSH
108941: LD_EXP 182
108945: PPUSH
108946: CALL 93898 0 1
108950: ST_TO_ADDR
// for i := 1 to list do
108951: LD_ADDR_VAR 0 2
108955: PUSH
108956: DOUBLE
108957: LD_INT 1
108959: DEC
108960: ST_TO_ADDR
108961: LD_VAR 0 3
108965: PUSH
108966: FOR_TO
108967: IFFALSE 109058
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108969: LD_STRING setFactoryWaypointXY(
108971: PUSH
108972: LD_VAR 0 3
108976: PUSH
108977: LD_VAR 0 2
108981: ARRAY
108982: PUSH
108983: LD_INT 1
108985: ARRAY
108986: STR
108987: PUSH
108988: LD_STRING ,
108990: STR
108991: PUSH
108992: LD_VAR 0 3
108996: PUSH
108997: LD_VAR 0 2
109001: ARRAY
109002: PUSH
109003: LD_INT 2
109005: ARRAY
109006: STR
109007: PUSH
109008: LD_STRING ,
109010: STR
109011: PUSH
109012: LD_VAR 0 3
109016: PUSH
109017: LD_VAR 0 2
109021: ARRAY
109022: PUSH
109023: LD_INT 3
109025: ARRAY
109026: STR
109027: PUSH
109028: LD_STRING ,
109030: STR
109031: PUSH
109032: LD_VAR 0 3
109036: PUSH
109037: LD_VAR 0 2
109041: ARRAY
109042: PUSH
109043: LD_INT 4
109045: ARRAY
109046: STR
109047: PUSH
109048: LD_STRING )
109050: STR
109051: PPUSH
109052: CALL_OW 559
109056: GO 108966
109058: POP
109059: POP
// end ; end ;
109060: LD_VAR 0 1
109064: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109065: LD_INT 0
109067: PPUSH
// if HexInfo ( x , y ) = warehouse then
109068: LD_VAR 0 2
109072: PPUSH
109073: LD_VAR 0 3
109077: PPUSH
109078: CALL_OW 428
109082: PUSH
109083: LD_VAR 0 1
109087: EQUAL
109088: IFFALSE 109115
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109090: LD_ADDR_EXP 183
109094: PUSH
109095: LD_EXP 183
109099: PPUSH
109100: LD_VAR 0 1
109104: PPUSH
109105: LD_INT 0
109107: PPUSH
109108: CALL_OW 1
109112: ST_TO_ADDR
109113: GO 109166
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109115: LD_ADDR_EXP 183
109119: PUSH
109120: LD_EXP 183
109124: PPUSH
109125: LD_VAR 0 1
109129: PPUSH
109130: LD_VAR 0 1
109134: PPUSH
109135: CALL_OW 255
109139: PUSH
109140: LD_VAR 0 1
109144: PUSH
109145: LD_VAR 0 2
109149: PUSH
109150: LD_VAR 0 3
109154: PUSH
109155: EMPTY
109156: LIST
109157: LIST
109158: LIST
109159: LIST
109160: PPUSH
109161: CALL_OW 1
109165: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109166: CALL 109175 0 0
// end ;
109170: LD_VAR 0 4
109174: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109175: LD_INT 0
109177: PPUSH
109178: PPUSH
109179: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109180: LD_STRING resetWarehouseGatheringPoints();
109182: PPUSH
109183: CALL_OW 559
// if warehouseGatheringPoints then
109187: LD_EXP 183
109191: IFFALSE 109317
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109193: LD_ADDR_VAR 0 3
109197: PUSH
109198: LD_EXP 183
109202: PPUSH
109203: CALL 93898 0 1
109207: ST_TO_ADDR
// for i := 1 to list do
109208: LD_ADDR_VAR 0 2
109212: PUSH
109213: DOUBLE
109214: LD_INT 1
109216: DEC
109217: ST_TO_ADDR
109218: LD_VAR 0 3
109222: PUSH
109223: FOR_TO
109224: IFFALSE 109315
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109226: LD_STRING setWarehouseGatheringPointXY(
109228: PUSH
109229: LD_VAR 0 3
109233: PUSH
109234: LD_VAR 0 2
109238: ARRAY
109239: PUSH
109240: LD_INT 1
109242: ARRAY
109243: STR
109244: PUSH
109245: LD_STRING ,
109247: STR
109248: PUSH
109249: LD_VAR 0 3
109253: PUSH
109254: LD_VAR 0 2
109258: ARRAY
109259: PUSH
109260: LD_INT 2
109262: ARRAY
109263: STR
109264: PUSH
109265: LD_STRING ,
109267: STR
109268: PUSH
109269: LD_VAR 0 3
109273: PUSH
109274: LD_VAR 0 2
109278: ARRAY
109279: PUSH
109280: LD_INT 3
109282: ARRAY
109283: STR
109284: PUSH
109285: LD_STRING ,
109287: STR
109288: PUSH
109289: LD_VAR 0 3
109293: PUSH
109294: LD_VAR 0 2
109298: ARRAY
109299: PUSH
109300: LD_INT 4
109302: ARRAY
109303: STR
109304: PUSH
109305: LD_STRING )
109307: STR
109308: PPUSH
109309: CALL_OW 559
109313: GO 109223
109315: POP
109316: POP
// end ; end ;
109317: LD_VAR 0 1
109321: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109322: LD_EXP 183
109326: IFFALSE 110011
109328: GO 109330
109330: DISABLE
109331: LD_INT 0
109333: PPUSH
109334: PPUSH
109335: PPUSH
109336: PPUSH
109337: PPUSH
109338: PPUSH
109339: PPUSH
109340: PPUSH
109341: PPUSH
// begin enable ;
109342: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109343: LD_ADDR_VAR 0 3
109347: PUSH
109348: LD_EXP 183
109352: PPUSH
109353: CALL 93898 0 1
109357: ST_TO_ADDR
// if not list then
109358: LD_VAR 0 3
109362: NOT
109363: IFFALSE 109367
// exit ;
109365: GO 110011
// for i := 1 to list do
109367: LD_ADDR_VAR 0 1
109371: PUSH
109372: DOUBLE
109373: LD_INT 1
109375: DEC
109376: ST_TO_ADDR
109377: LD_VAR 0 3
109381: PUSH
109382: FOR_TO
109383: IFFALSE 110009
// begin depot := list [ i ] [ 2 ] ;
109385: LD_ADDR_VAR 0 8
109389: PUSH
109390: LD_VAR 0 3
109394: PUSH
109395: LD_VAR 0 1
109399: ARRAY
109400: PUSH
109401: LD_INT 2
109403: ARRAY
109404: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109405: LD_ADDR_VAR 0 5
109409: PUSH
109410: LD_VAR 0 3
109414: PUSH
109415: LD_VAR 0 1
109419: ARRAY
109420: PUSH
109421: LD_INT 1
109423: ARRAY
109424: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109425: LD_VAR 0 8
109429: PPUSH
109430: CALL_OW 301
109434: PUSH
109435: LD_VAR 0 5
109439: PUSH
109440: LD_VAR 0 8
109444: PPUSH
109445: CALL_OW 255
109449: NONEQUAL
109450: OR
109451: IFFALSE 109480
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
109453: LD_ADDR_EXP 183
109457: PUSH
109458: LD_EXP 183
109462: PPUSH
109463: LD_VAR 0 8
109467: PPUSH
109468: LD_INT 0
109470: PPUSH
109471: CALL_OW 1
109475: ST_TO_ADDR
// exit ;
109476: POP
109477: POP
109478: GO 110011
// end ; x := list [ i ] [ 3 ] ;
109480: LD_ADDR_VAR 0 6
109484: PUSH
109485: LD_VAR 0 3
109489: PUSH
109490: LD_VAR 0 1
109494: ARRAY
109495: PUSH
109496: LD_INT 3
109498: ARRAY
109499: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109500: LD_ADDR_VAR 0 7
109504: PUSH
109505: LD_VAR 0 3
109509: PUSH
109510: LD_VAR 0 1
109514: ARRAY
109515: PUSH
109516: LD_INT 4
109518: ARRAY
109519: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109520: LD_ADDR_VAR 0 9
109524: PUSH
109525: LD_VAR 0 6
109529: PPUSH
109530: LD_VAR 0 7
109534: PPUSH
109535: LD_INT 16
109537: PPUSH
109538: CALL 92486 0 3
109542: ST_TO_ADDR
// if not cratesNearbyPoint then
109543: LD_VAR 0 9
109547: NOT
109548: IFFALSE 109554
// exit ;
109550: POP
109551: POP
109552: GO 110011
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109554: LD_ADDR_VAR 0 4
109558: PUSH
109559: LD_INT 22
109561: PUSH
109562: LD_VAR 0 5
109566: PUSH
109567: EMPTY
109568: LIST
109569: LIST
109570: PUSH
109571: LD_INT 3
109573: PUSH
109574: LD_INT 60
109576: PUSH
109577: EMPTY
109578: LIST
109579: PUSH
109580: EMPTY
109581: LIST
109582: LIST
109583: PUSH
109584: LD_INT 91
109586: PUSH
109587: LD_VAR 0 8
109591: PUSH
109592: LD_INT 6
109594: PUSH
109595: EMPTY
109596: LIST
109597: LIST
109598: LIST
109599: PUSH
109600: LD_INT 2
109602: PUSH
109603: LD_INT 25
109605: PUSH
109606: LD_INT 2
109608: PUSH
109609: EMPTY
109610: LIST
109611: LIST
109612: PUSH
109613: LD_INT 25
109615: PUSH
109616: LD_INT 16
109618: PUSH
109619: EMPTY
109620: LIST
109621: LIST
109622: PUSH
109623: EMPTY
109624: LIST
109625: LIST
109626: LIST
109627: PUSH
109628: EMPTY
109629: LIST
109630: LIST
109631: LIST
109632: LIST
109633: PPUSH
109634: CALL_OW 69
109638: PUSH
109639: LD_VAR 0 8
109643: PPUSH
109644: CALL_OW 313
109648: PPUSH
109649: LD_INT 3
109651: PUSH
109652: LD_INT 60
109654: PUSH
109655: EMPTY
109656: LIST
109657: PUSH
109658: EMPTY
109659: LIST
109660: LIST
109661: PUSH
109662: LD_INT 2
109664: PUSH
109665: LD_INT 25
109667: PUSH
109668: LD_INT 2
109670: PUSH
109671: EMPTY
109672: LIST
109673: LIST
109674: PUSH
109675: LD_INT 25
109677: PUSH
109678: LD_INT 16
109680: PUSH
109681: EMPTY
109682: LIST
109683: LIST
109684: PUSH
109685: EMPTY
109686: LIST
109687: LIST
109688: LIST
109689: PUSH
109690: EMPTY
109691: LIST
109692: LIST
109693: PPUSH
109694: CALL_OW 72
109698: UNION
109699: ST_TO_ADDR
// if tmp then
109700: LD_VAR 0 4
109704: IFFALSE 109784
// begin tmp := ShrinkArray ( tmp , 3 ) ;
109706: LD_ADDR_VAR 0 4
109710: PUSH
109711: LD_VAR 0 4
109715: PPUSH
109716: LD_INT 3
109718: PPUSH
109719: CALL 90455 0 2
109723: ST_TO_ADDR
// for j in tmp do
109724: LD_ADDR_VAR 0 2
109728: PUSH
109729: LD_VAR 0 4
109733: PUSH
109734: FOR_IN
109735: IFFALSE 109778
// begin if IsInUnit ( j ) then
109737: LD_VAR 0 2
109741: PPUSH
109742: CALL_OW 310
109746: IFFALSE 109757
// ComExit ( j ) ;
109748: LD_VAR 0 2
109752: PPUSH
109753: CALL 90538 0 1
// AddComCollect ( j , x , y ) ;
109757: LD_VAR 0 2
109761: PPUSH
109762: LD_VAR 0 6
109766: PPUSH
109767: LD_VAR 0 7
109771: PPUSH
109772: CALL_OW 177
// end ;
109776: GO 109734
109778: POP
109779: POP
// exit ;
109780: POP
109781: POP
109782: GO 110011
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109784: LD_ADDR_VAR 0 4
109788: PUSH
109789: LD_INT 22
109791: PUSH
109792: LD_VAR 0 5
109796: PUSH
109797: EMPTY
109798: LIST
109799: LIST
109800: PUSH
109801: LD_INT 91
109803: PUSH
109804: LD_VAR 0 8
109808: PUSH
109809: LD_INT 8
109811: PUSH
109812: EMPTY
109813: LIST
109814: LIST
109815: LIST
109816: PUSH
109817: LD_INT 2
109819: PUSH
109820: LD_INT 34
109822: PUSH
109823: LD_INT 12
109825: PUSH
109826: EMPTY
109827: LIST
109828: LIST
109829: PUSH
109830: LD_INT 34
109832: PUSH
109833: LD_INT 51
109835: PUSH
109836: EMPTY
109837: LIST
109838: LIST
109839: PUSH
109840: LD_INT 34
109842: PUSH
109843: LD_INT 32
109845: PUSH
109846: EMPTY
109847: LIST
109848: LIST
109849: PUSH
109850: LD_INT 34
109852: PUSH
109853: LD_INT 89
109855: PUSH
109856: EMPTY
109857: LIST
109858: LIST
109859: PUSH
109860: EMPTY
109861: LIST
109862: LIST
109863: LIST
109864: LIST
109865: LIST
109866: PUSH
109867: EMPTY
109868: LIST
109869: LIST
109870: LIST
109871: PPUSH
109872: CALL_OW 69
109876: ST_TO_ADDR
// if tmp then
109877: LD_VAR 0 4
109881: IFFALSE 110007
// begin for j in tmp do
109883: LD_ADDR_VAR 0 2
109887: PUSH
109888: LD_VAR 0 4
109892: PUSH
109893: FOR_IN
109894: IFFALSE 110005
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
109896: LD_VAR 0 2
109900: PPUSH
109901: CALL_OW 262
109905: PUSH
109906: LD_INT 3
109908: EQUAL
109909: PUSH
109910: LD_VAR 0 2
109914: PPUSH
109915: CALL_OW 261
109919: PUSH
109920: LD_INT 20
109922: GREATER
109923: OR
109924: PUSH
109925: LD_VAR 0 2
109929: PPUSH
109930: CALL_OW 314
109934: NOT
109935: AND
109936: PUSH
109937: LD_VAR 0 2
109941: PPUSH
109942: CALL_OW 263
109946: PUSH
109947: LD_INT 1
109949: NONEQUAL
109950: PUSH
109951: LD_VAR 0 2
109955: PPUSH
109956: CALL_OW 311
109960: OR
109961: AND
109962: IFFALSE 110003
// begin ComCollect ( j , x , y ) ;
109964: LD_VAR 0 2
109968: PPUSH
109969: LD_VAR 0 6
109973: PPUSH
109974: LD_VAR 0 7
109978: PPUSH
109979: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
109983: LD_VAR 0 2
109987: PPUSH
109988: LD_VAR 0 8
109992: PPUSH
109993: CALL_OW 172
// exit ;
109997: POP
109998: POP
109999: POP
110000: POP
110001: GO 110011
// end ;
110003: GO 109893
110005: POP
110006: POP
// end ; end ;
110007: GO 109382
110009: POP
110010: POP
// end ; end_of_file
110011: PPOPN 9
110013: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
110014: LD_INT 0
110016: PPUSH
110017: PPUSH
110018: PPUSH
110019: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
110020: LD_VAR 0 1
110024: PPUSH
110025: CALL_OW 264
110029: PUSH
110030: LD_INT 91
110032: EQUAL
110033: IFFALSE 110105
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
110035: LD_INT 68
110037: PPUSH
110038: LD_VAR 0 1
110042: PPUSH
110043: CALL_OW 255
110047: PPUSH
110048: CALL_OW 321
110052: PUSH
110053: LD_INT 2
110055: EQUAL
110056: IFFALSE 110068
// eff := 70 else
110058: LD_ADDR_VAR 0 4
110062: PUSH
110063: LD_INT 70
110065: ST_TO_ADDR
110066: GO 110076
// eff := 30 ;
110068: LD_ADDR_VAR 0 4
110072: PUSH
110073: LD_INT 30
110075: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
110076: LD_VAR 0 1
110080: PPUSH
110081: CALL_OW 250
110085: PPUSH
110086: LD_VAR 0 1
110090: PPUSH
110091: CALL_OW 251
110095: PPUSH
110096: LD_VAR 0 4
110100: PPUSH
110101: CALL_OW 495
// end ; end ;
110105: LD_VAR 0 2
110109: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
110110: LD_INT 0
110112: PPUSH
// end ;
110113: LD_VAR 0 4
110117: RET
// export function SOS_Command ( cmd ) ; begin
110118: LD_INT 0
110120: PPUSH
// end ;
110121: LD_VAR 0 2
110125: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
110126: LD_INT 0
110128: PPUSH
// end ;
110129: LD_VAR 0 6
110133: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
110134: LD_INT 0
110136: PPUSH
110137: PPUSH
// if not vehicle or not factory then
110138: LD_VAR 0 1
110142: NOT
110143: PUSH
110144: LD_VAR 0 2
110148: NOT
110149: OR
110150: IFFALSE 110154
// exit ;
110152: GO 110385
// if factoryWaypoints >= factory then
110154: LD_EXP 182
110158: PUSH
110159: LD_VAR 0 2
110163: GREATEREQUAL
110164: IFFALSE 110385
// if factoryWaypoints [ factory ] then
110166: LD_EXP 182
110170: PUSH
110171: LD_VAR 0 2
110175: ARRAY
110176: IFFALSE 110385
// begin if GetControl ( vehicle ) = control_manual then
110178: LD_VAR 0 1
110182: PPUSH
110183: CALL_OW 263
110187: PUSH
110188: LD_INT 1
110190: EQUAL
110191: IFFALSE 110272
// begin driver := IsDrivenBy ( vehicle ) ;
110193: LD_ADDR_VAR 0 4
110197: PUSH
110198: LD_VAR 0 1
110202: PPUSH
110203: CALL_OW 311
110207: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110208: LD_VAR 0 4
110212: PPUSH
110213: LD_EXP 182
110217: PUSH
110218: LD_VAR 0 2
110222: ARRAY
110223: PUSH
110224: LD_INT 3
110226: ARRAY
110227: PPUSH
110228: LD_EXP 182
110232: PUSH
110233: LD_VAR 0 2
110237: ARRAY
110238: PUSH
110239: LD_INT 4
110241: ARRAY
110242: PPUSH
110243: CALL_OW 171
// AddComExitVehicle ( driver ) ;
110247: LD_VAR 0 4
110251: PPUSH
110252: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
110256: LD_VAR 0 4
110260: PPUSH
110261: LD_VAR 0 2
110265: PPUSH
110266: CALL_OW 180
// end else
110270: GO 110385
// if GetControl ( vehicle ) = control_remote then
110272: LD_VAR 0 1
110276: PPUSH
110277: CALL_OW 263
110281: PUSH
110282: LD_INT 2
110284: EQUAL
110285: IFFALSE 110346
// begin wait ( 0 0$2 ) ;
110287: LD_INT 70
110289: PPUSH
110290: CALL_OW 67
// if Connect ( vehicle ) then
110294: LD_VAR 0 1
110298: PPUSH
110299: CALL 60779 0 1
110303: IFFALSE 110344
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110305: LD_VAR 0 1
110309: PPUSH
110310: LD_EXP 182
110314: PUSH
110315: LD_VAR 0 2
110319: ARRAY
110320: PUSH
110321: LD_INT 3
110323: ARRAY
110324: PPUSH
110325: LD_EXP 182
110329: PUSH
110330: LD_VAR 0 2
110334: ARRAY
110335: PUSH
110336: LD_INT 4
110338: ARRAY
110339: PPUSH
110340: CALL_OW 171
// end else
110344: GO 110385
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110346: LD_VAR 0 1
110350: PPUSH
110351: LD_EXP 182
110355: PUSH
110356: LD_VAR 0 2
110360: ARRAY
110361: PUSH
110362: LD_INT 3
110364: ARRAY
110365: PPUSH
110366: LD_EXP 182
110370: PUSH
110371: LD_VAR 0 2
110375: ARRAY
110376: PUSH
110377: LD_INT 4
110379: ARRAY
110380: PPUSH
110381: CALL_OW 171
// end ; end ;
110385: LD_VAR 0 3
110389: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
110390: LD_INT 0
110392: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
110393: LD_VAR 0 1
110397: PUSH
110398: LD_INT 250
110400: EQUAL
110401: PUSH
110402: LD_VAR 0 2
110406: PPUSH
110407: CALL_OW 264
110411: PUSH
110412: LD_INT 81
110414: EQUAL
110415: AND
110416: IFFALSE 110437
// MinerPlaceMine ( unit , x , y ) ;
110418: LD_VAR 0 2
110422: PPUSH
110423: LD_VAR 0 4
110427: PPUSH
110428: LD_VAR 0 5
110432: PPUSH
110433: CALL 112822 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
110437: LD_VAR 0 1
110441: PUSH
110442: LD_INT 251
110444: EQUAL
110445: PUSH
110446: LD_VAR 0 2
110450: PPUSH
110451: CALL_OW 264
110455: PUSH
110456: LD_INT 81
110458: EQUAL
110459: AND
110460: IFFALSE 110481
// MinerDetonateMine ( unit , x , y ) ;
110462: LD_VAR 0 2
110466: PPUSH
110467: LD_VAR 0 4
110471: PPUSH
110472: LD_VAR 0 5
110476: PPUSH
110477: CALL 113097 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
110481: LD_VAR 0 1
110485: PUSH
110486: LD_INT 252
110488: EQUAL
110489: PUSH
110490: LD_VAR 0 2
110494: PPUSH
110495: CALL_OW 264
110499: PUSH
110500: LD_INT 81
110502: EQUAL
110503: AND
110504: IFFALSE 110525
// MinerCreateMinefield ( unit , x , y ) ;
110506: LD_VAR 0 2
110510: PPUSH
110511: LD_VAR 0 4
110515: PPUSH
110516: LD_VAR 0 5
110520: PPUSH
110521: CALL 113514 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
110525: LD_VAR 0 1
110529: PUSH
110530: LD_INT 253
110532: EQUAL
110533: PUSH
110534: LD_VAR 0 2
110538: PPUSH
110539: CALL_OW 257
110543: PUSH
110544: LD_INT 5
110546: EQUAL
110547: AND
110548: IFFALSE 110569
// ComBinocular ( unit , x , y ) ;
110550: LD_VAR 0 2
110554: PPUSH
110555: LD_VAR 0 4
110559: PPUSH
110560: LD_VAR 0 5
110564: PPUSH
110565: CALL 113883 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
110569: LD_VAR 0 1
110573: PUSH
110574: LD_INT 254
110576: EQUAL
110577: PUSH
110578: LD_VAR 0 2
110582: PPUSH
110583: CALL_OW 264
110587: PUSH
110588: LD_INT 99
110590: EQUAL
110591: AND
110592: PUSH
110593: LD_VAR 0 3
110597: PPUSH
110598: CALL_OW 263
110602: PUSH
110603: LD_INT 3
110605: EQUAL
110606: AND
110607: IFFALSE 110623
// HackDestroyVehicle ( unit , selectedUnit ) ;
110609: LD_VAR 0 2
110613: PPUSH
110614: LD_VAR 0 3
110618: PPUSH
110619: CALL 112186 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
110623: LD_VAR 0 1
110627: PUSH
110628: LD_INT 255
110630: EQUAL
110631: PUSH
110632: LD_VAR 0 2
110636: PPUSH
110637: CALL_OW 264
110641: PUSH
110642: LD_INT 14
110644: PUSH
110645: LD_INT 53
110647: PUSH
110648: EMPTY
110649: LIST
110650: LIST
110651: IN
110652: AND
110653: PUSH
110654: LD_VAR 0 4
110658: PPUSH
110659: LD_VAR 0 5
110663: PPUSH
110664: CALL_OW 488
110668: AND
110669: IFFALSE 110693
// CutTreeXYR ( unit , x , y , 12 ) ;
110671: LD_VAR 0 2
110675: PPUSH
110676: LD_VAR 0 4
110680: PPUSH
110681: LD_VAR 0 5
110685: PPUSH
110686: LD_INT 12
110688: PPUSH
110689: CALL 110756 0 4
// if cmd = 256 then
110693: LD_VAR 0 1
110697: PUSH
110698: LD_INT 256
110700: EQUAL
110701: IFFALSE 110722
// SetFactoryWaypoint ( unit , x , y ) ;
110703: LD_VAR 0 2
110707: PPUSH
110708: LD_VAR 0 4
110712: PPUSH
110713: LD_VAR 0 5
110717: PPUSH
110718: CALL 108703 0 3
// if cmd = 257 then
110722: LD_VAR 0 1
110726: PUSH
110727: LD_INT 257
110729: EQUAL
110730: IFFALSE 110751
// SetWarehouseGatheringPoint ( unit , x , y ) ;
110732: LD_VAR 0 2
110736: PPUSH
110737: LD_VAR 0 4
110741: PPUSH
110742: LD_VAR 0 5
110746: PPUSH
110747: CALL 109065 0 3
// end ;
110751: LD_VAR 0 6
110755: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
110756: LD_INT 0
110758: PPUSH
110759: PPUSH
110760: PPUSH
110761: PPUSH
110762: PPUSH
110763: PPUSH
110764: PPUSH
110765: PPUSH
110766: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
110767: LD_VAR 0 1
110771: NOT
110772: PUSH
110773: LD_VAR 0 2
110777: PPUSH
110778: LD_VAR 0 3
110782: PPUSH
110783: CALL_OW 488
110787: NOT
110788: OR
110789: PUSH
110790: LD_VAR 0 4
110794: NOT
110795: OR
110796: IFFALSE 110800
// exit ;
110798: GO 111140
// list := [ ] ;
110800: LD_ADDR_VAR 0 13
110804: PUSH
110805: EMPTY
110806: ST_TO_ADDR
// if x - r < 0 then
110807: LD_VAR 0 2
110811: PUSH
110812: LD_VAR 0 4
110816: MINUS
110817: PUSH
110818: LD_INT 0
110820: LESS
110821: IFFALSE 110833
// min_x := 0 else
110823: LD_ADDR_VAR 0 7
110827: PUSH
110828: LD_INT 0
110830: ST_TO_ADDR
110831: GO 110849
// min_x := x - r ;
110833: LD_ADDR_VAR 0 7
110837: PUSH
110838: LD_VAR 0 2
110842: PUSH
110843: LD_VAR 0 4
110847: MINUS
110848: ST_TO_ADDR
// if y - r < 0 then
110849: LD_VAR 0 3
110853: PUSH
110854: LD_VAR 0 4
110858: MINUS
110859: PUSH
110860: LD_INT 0
110862: LESS
110863: IFFALSE 110875
// min_y := 0 else
110865: LD_ADDR_VAR 0 8
110869: PUSH
110870: LD_INT 0
110872: ST_TO_ADDR
110873: GO 110891
// min_y := y - r ;
110875: LD_ADDR_VAR 0 8
110879: PUSH
110880: LD_VAR 0 3
110884: PUSH
110885: LD_VAR 0 4
110889: MINUS
110890: ST_TO_ADDR
// max_x := x + r ;
110891: LD_ADDR_VAR 0 9
110895: PUSH
110896: LD_VAR 0 2
110900: PUSH
110901: LD_VAR 0 4
110905: PLUS
110906: ST_TO_ADDR
// max_y := y + r ;
110907: LD_ADDR_VAR 0 10
110911: PUSH
110912: LD_VAR 0 3
110916: PUSH
110917: LD_VAR 0 4
110921: PLUS
110922: ST_TO_ADDR
// for _x = min_x to max_x do
110923: LD_ADDR_VAR 0 11
110927: PUSH
110928: DOUBLE
110929: LD_VAR 0 7
110933: DEC
110934: ST_TO_ADDR
110935: LD_VAR 0 9
110939: PUSH
110940: FOR_TO
110941: IFFALSE 111058
// for _y = min_y to max_y do
110943: LD_ADDR_VAR 0 12
110947: PUSH
110948: DOUBLE
110949: LD_VAR 0 8
110953: DEC
110954: ST_TO_ADDR
110955: LD_VAR 0 10
110959: PUSH
110960: FOR_TO
110961: IFFALSE 111054
// begin if not ValidHex ( _x , _y ) then
110963: LD_VAR 0 11
110967: PPUSH
110968: LD_VAR 0 12
110972: PPUSH
110973: CALL_OW 488
110977: NOT
110978: IFFALSE 110982
// continue ;
110980: GO 110960
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
110982: LD_VAR 0 11
110986: PPUSH
110987: LD_VAR 0 12
110991: PPUSH
110992: CALL_OW 351
110996: PUSH
110997: LD_VAR 0 11
111001: PPUSH
111002: LD_VAR 0 12
111006: PPUSH
111007: CALL_OW 554
111011: AND
111012: IFFALSE 111052
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
111014: LD_ADDR_VAR 0 13
111018: PUSH
111019: LD_VAR 0 13
111023: PPUSH
111024: LD_VAR 0 13
111028: PUSH
111029: LD_INT 1
111031: PLUS
111032: PPUSH
111033: LD_VAR 0 11
111037: PUSH
111038: LD_VAR 0 12
111042: PUSH
111043: EMPTY
111044: LIST
111045: LIST
111046: PPUSH
111047: CALL_OW 2
111051: ST_TO_ADDR
// end ;
111052: GO 110960
111054: POP
111055: POP
111056: GO 110940
111058: POP
111059: POP
// if not list then
111060: LD_VAR 0 13
111064: NOT
111065: IFFALSE 111069
// exit ;
111067: GO 111140
// for i in list do
111069: LD_ADDR_VAR 0 6
111073: PUSH
111074: LD_VAR 0 13
111078: PUSH
111079: FOR_IN
111080: IFFALSE 111138
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
111082: LD_VAR 0 1
111086: PPUSH
111087: LD_STRING M
111089: PUSH
111090: LD_VAR 0 6
111094: PUSH
111095: LD_INT 1
111097: ARRAY
111098: PUSH
111099: LD_VAR 0 6
111103: PUSH
111104: LD_INT 2
111106: ARRAY
111107: PUSH
111108: LD_INT 0
111110: PUSH
111111: LD_INT 0
111113: PUSH
111114: LD_INT 0
111116: PUSH
111117: LD_INT 0
111119: PUSH
111120: EMPTY
111121: LIST
111122: LIST
111123: LIST
111124: LIST
111125: LIST
111126: LIST
111127: LIST
111128: PUSH
111129: EMPTY
111130: LIST
111131: PPUSH
111132: CALL_OW 447
111136: GO 111079
111138: POP
111139: POP
// end ;
111140: LD_VAR 0 5
111144: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
111145: LD_EXP 185
111149: NOT
111150: IFFALSE 111200
111152: GO 111154
111154: DISABLE
// begin initHack := true ;
111155: LD_ADDR_EXP 185
111159: PUSH
111160: LD_INT 1
111162: ST_TO_ADDR
// hackTanks := [ ] ;
111163: LD_ADDR_EXP 186
111167: PUSH
111168: EMPTY
111169: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
111170: LD_ADDR_EXP 187
111174: PUSH
111175: EMPTY
111176: ST_TO_ADDR
// hackLimit := 3 ;
111177: LD_ADDR_EXP 188
111181: PUSH
111182: LD_INT 3
111184: ST_TO_ADDR
// hackDist := 12 ;
111185: LD_ADDR_EXP 189
111189: PUSH
111190: LD_INT 12
111192: ST_TO_ADDR
// hackCounter := [ ] ;
111193: LD_ADDR_EXP 190
111197: PUSH
111198: EMPTY
111199: ST_TO_ADDR
// end ;
111200: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
111201: LD_EXP 185
111205: PUSH
111206: LD_INT 34
111208: PUSH
111209: LD_INT 99
111211: PUSH
111212: EMPTY
111213: LIST
111214: LIST
111215: PPUSH
111216: CALL_OW 69
111220: AND
111221: IFFALSE 111474
111223: GO 111225
111225: DISABLE
111226: LD_INT 0
111228: PPUSH
111229: PPUSH
// begin enable ;
111230: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
111231: LD_ADDR_VAR 0 1
111235: PUSH
111236: LD_INT 34
111238: PUSH
111239: LD_INT 99
111241: PUSH
111242: EMPTY
111243: LIST
111244: LIST
111245: PPUSH
111246: CALL_OW 69
111250: PUSH
111251: FOR_IN
111252: IFFALSE 111472
// begin if not i in hackTanks then
111254: LD_VAR 0 1
111258: PUSH
111259: LD_EXP 186
111263: IN
111264: NOT
111265: IFFALSE 111348
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
111267: LD_ADDR_EXP 186
111271: PUSH
111272: LD_EXP 186
111276: PPUSH
111277: LD_EXP 186
111281: PUSH
111282: LD_INT 1
111284: PLUS
111285: PPUSH
111286: LD_VAR 0 1
111290: PPUSH
111291: CALL_OW 1
111295: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
111296: LD_ADDR_EXP 187
111300: PUSH
111301: LD_EXP 187
111305: PPUSH
111306: LD_EXP 187
111310: PUSH
111311: LD_INT 1
111313: PLUS
111314: PPUSH
111315: EMPTY
111316: PPUSH
111317: CALL_OW 1
111321: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
111322: LD_ADDR_EXP 190
111326: PUSH
111327: LD_EXP 190
111331: PPUSH
111332: LD_EXP 190
111336: PUSH
111337: LD_INT 1
111339: PLUS
111340: PPUSH
111341: EMPTY
111342: PPUSH
111343: CALL_OW 1
111347: ST_TO_ADDR
// end ; if not IsOk ( i ) then
111348: LD_VAR 0 1
111352: PPUSH
111353: CALL_OW 302
111357: NOT
111358: IFFALSE 111371
// begin HackUnlinkAll ( i ) ;
111360: LD_VAR 0 1
111364: PPUSH
111365: CALL 111477 0 1
// continue ;
111369: GO 111251
// end ; HackCheckCapturedStatus ( i ) ;
111371: LD_VAR 0 1
111375: PPUSH
111376: CALL 111920 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
111380: LD_ADDR_VAR 0 2
111384: PUSH
111385: LD_INT 81
111387: PUSH
111388: LD_VAR 0 1
111392: PPUSH
111393: CALL_OW 255
111397: PUSH
111398: EMPTY
111399: LIST
111400: LIST
111401: PUSH
111402: LD_INT 33
111404: PUSH
111405: LD_INT 3
111407: PUSH
111408: EMPTY
111409: LIST
111410: LIST
111411: PUSH
111412: LD_INT 91
111414: PUSH
111415: LD_VAR 0 1
111419: PUSH
111420: LD_EXP 189
111424: PUSH
111425: EMPTY
111426: LIST
111427: LIST
111428: LIST
111429: PUSH
111430: LD_INT 50
111432: PUSH
111433: EMPTY
111434: LIST
111435: PUSH
111436: EMPTY
111437: LIST
111438: LIST
111439: LIST
111440: LIST
111441: PPUSH
111442: CALL_OW 69
111446: ST_TO_ADDR
// if not tmp then
111447: LD_VAR 0 2
111451: NOT
111452: IFFALSE 111456
// continue ;
111454: GO 111251
// HackLink ( i , tmp ) ;
111456: LD_VAR 0 1
111460: PPUSH
111461: LD_VAR 0 2
111465: PPUSH
111466: CALL 111613 0 2
// end ;
111470: GO 111251
111472: POP
111473: POP
// end ;
111474: PPOPN 2
111476: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
111477: LD_INT 0
111479: PPUSH
111480: PPUSH
111481: PPUSH
// if not hack in hackTanks then
111482: LD_VAR 0 1
111486: PUSH
111487: LD_EXP 186
111491: IN
111492: NOT
111493: IFFALSE 111497
// exit ;
111495: GO 111608
// index := GetElementIndex ( hackTanks , hack ) ;
111497: LD_ADDR_VAR 0 4
111501: PUSH
111502: LD_EXP 186
111506: PPUSH
111507: LD_VAR 0 1
111511: PPUSH
111512: CALL 57595 0 2
111516: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
111517: LD_EXP 187
111521: PUSH
111522: LD_VAR 0 4
111526: ARRAY
111527: IFFALSE 111608
// begin for i in hackTanksCaptured [ index ] do
111529: LD_ADDR_VAR 0 3
111533: PUSH
111534: LD_EXP 187
111538: PUSH
111539: LD_VAR 0 4
111543: ARRAY
111544: PUSH
111545: FOR_IN
111546: IFFALSE 111572
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
111548: LD_VAR 0 3
111552: PUSH
111553: LD_INT 1
111555: ARRAY
111556: PPUSH
111557: LD_VAR 0 3
111561: PUSH
111562: LD_INT 2
111564: ARRAY
111565: PPUSH
111566: CALL_OW 235
111570: GO 111545
111572: POP
111573: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
111574: LD_ADDR_EXP 187
111578: PUSH
111579: LD_EXP 187
111583: PPUSH
111584: LD_VAR 0 4
111588: PPUSH
111589: EMPTY
111590: PPUSH
111591: CALL_OW 1
111595: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
111596: LD_VAR 0 1
111600: PPUSH
111601: LD_INT 0
111603: PPUSH
111604: CALL_OW 505
// end ; end ;
111608: LD_VAR 0 2
111612: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
111613: LD_INT 0
111615: PPUSH
111616: PPUSH
111617: PPUSH
// if not hack in hackTanks or not vehicles then
111618: LD_VAR 0 1
111622: PUSH
111623: LD_EXP 186
111627: IN
111628: NOT
111629: PUSH
111630: LD_VAR 0 2
111634: NOT
111635: OR
111636: IFFALSE 111640
// exit ;
111638: GO 111915
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
111640: LD_ADDR_VAR 0 2
111644: PUSH
111645: LD_VAR 0 1
111649: PPUSH
111650: LD_VAR 0 2
111654: PPUSH
111655: LD_INT 1
111657: PPUSH
111658: LD_INT 1
111660: PPUSH
111661: CALL 58245 0 4
111665: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
111666: LD_ADDR_VAR 0 5
111670: PUSH
111671: LD_EXP 186
111675: PPUSH
111676: LD_VAR 0 1
111680: PPUSH
111681: CALL 57595 0 2
111685: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
111686: LD_EXP 187
111690: PUSH
111691: LD_VAR 0 5
111695: ARRAY
111696: PUSH
111697: LD_EXP 188
111701: LESS
111702: IFFALSE 111891
// begin for i := 1 to vehicles do
111704: LD_ADDR_VAR 0 4
111708: PUSH
111709: DOUBLE
111710: LD_INT 1
111712: DEC
111713: ST_TO_ADDR
111714: LD_VAR 0 2
111718: PUSH
111719: FOR_TO
111720: IFFALSE 111889
// begin if hackTanksCaptured [ index ] = hackLimit then
111722: LD_EXP 187
111726: PUSH
111727: LD_VAR 0 5
111731: ARRAY
111732: PUSH
111733: LD_EXP 188
111737: EQUAL
111738: IFFALSE 111742
// break ;
111740: GO 111889
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
111742: LD_ADDR_EXP 190
111746: PUSH
111747: LD_EXP 190
111751: PPUSH
111752: LD_VAR 0 5
111756: PPUSH
111757: LD_EXP 190
111761: PUSH
111762: LD_VAR 0 5
111766: ARRAY
111767: PUSH
111768: LD_INT 1
111770: PLUS
111771: PPUSH
111772: CALL_OW 1
111776: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
111777: LD_ADDR_EXP 187
111781: PUSH
111782: LD_EXP 187
111786: PPUSH
111787: LD_VAR 0 5
111791: PUSH
111792: LD_EXP 187
111796: PUSH
111797: LD_VAR 0 5
111801: ARRAY
111802: PUSH
111803: LD_INT 1
111805: PLUS
111806: PUSH
111807: EMPTY
111808: LIST
111809: LIST
111810: PPUSH
111811: LD_VAR 0 2
111815: PUSH
111816: LD_VAR 0 4
111820: ARRAY
111821: PUSH
111822: LD_VAR 0 2
111826: PUSH
111827: LD_VAR 0 4
111831: ARRAY
111832: PPUSH
111833: CALL_OW 255
111837: PUSH
111838: EMPTY
111839: LIST
111840: LIST
111841: PPUSH
111842: CALL 57810 0 3
111846: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
111847: LD_VAR 0 2
111851: PUSH
111852: LD_VAR 0 4
111856: ARRAY
111857: PPUSH
111858: LD_VAR 0 1
111862: PPUSH
111863: CALL_OW 255
111867: PPUSH
111868: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
111872: LD_VAR 0 2
111876: PUSH
111877: LD_VAR 0 4
111881: ARRAY
111882: PPUSH
111883: CALL_OW 141
// end ;
111887: GO 111719
111889: POP
111890: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111891: LD_VAR 0 1
111895: PPUSH
111896: LD_EXP 187
111900: PUSH
111901: LD_VAR 0 5
111905: ARRAY
111906: PUSH
111907: LD_INT 0
111909: PLUS
111910: PPUSH
111911: CALL_OW 505
// end ;
111915: LD_VAR 0 3
111919: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
111920: LD_INT 0
111922: PPUSH
111923: PPUSH
111924: PPUSH
111925: PPUSH
// if not hack in hackTanks then
111926: LD_VAR 0 1
111930: PUSH
111931: LD_EXP 186
111935: IN
111936: NOT
111937: IFFALSE 111941
// exit ;
111939: GO 112181
// index := GetElementIndex ( hackTanks , hack ) ;
111941: LD_ADDR_VAR 0 4
111945: PUSH
111946: LD_EXP 186
111950: PPUSH
111951: LD_VAR 0 1
111955: PPUSH
111956: CALL 57595 0 2
111960: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
111961: LD_ADDR_VAR 0 3
111965: PUSH
111966: DOUBLE
111967: LD_EXP 187
111971: PUSH
111972: LD_VAR 0 4
111976: ARRAY
111977: INC
111978: ST_TO_ADDR
111979: LD_INT 1
111981: PUSH
111982: FOR_DOWNTO
111983: IFFALSE 112155
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
111985: LD_ADDR_VAR 0 5
111989: PUSH
111990: LD_EXP 187
111994: PUSH
111995: LD_VAR 0 4
111999: ARRAY
112000: PUSH
112001: LD_VAR 0 3
112005: ARRAY
112006: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
112007: LD_VAR 0 5
112011: PUSH
112012: LD_INT 1
112014: ARRAY
112015: PPUSH
112016: CALL_OW 302
112020: NOT
112021: PUSH
112022: LD_VAR 0 5
112026: PUSH
112027: LD_INT 1
112029: ARRAY
112030: PPUSH
112031: CALL_OW 255
112035: PUSH
112036: LD_VAR 0 1
112040: PPUSH
112041: CALL_OW 255
112045: NONEQUAL
112046: OR
112047: IFFALSE 112153
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
112049: LD_VAR 0 5
112053: PUSH
112054: LD_INT 1
112056: ARRAY
112057: PPUSH
112058: CALL_OW 305
112062: PUSH
112063: LD_VAR 0 5
112067: PUSH
112068: LD_INT 1
112070: ARRAY
112071: PPUSH
112072: CALL_OW 255
112076: PUSH
112077: LD_VAR 0 1
112081: PPUSH
112082: CALL_OW 255
112086: EQUAL
112087: AND
112088: IFFALSE 112112
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
112090: LD_VAR 0 5
112094: PUSH
112095: LD_INT 1
112097: ARRAY
112098: PPUSH
112099: LD_VAR 0 5
112103: PUSH
112104: LD_INT 2
112106: ARRAY
112107: PPUSH
112108: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
112112: LD_ADDR_EXP 187
112116: PUSH
112117: LD_EXP 187
112121: PPUSH
112122: LD_VAR 0 4
112126: PPUSH
112127: LD_EXP 187
112131: PUSH
112132: LD_VAR 0 4
112136: ARRAY
112137: PPUSH
112138: LD_VAR 0 3
112142: PPUSH
112143: CALL_OW 3
112147: PPUSH
112148: CALL_OW 1
112152: ST_TO_ADDR
// end ; end ;
112153: GO 111982
112155: POP
112156: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
112157: LD_VAR 0 1
112161: PPUSH
112162: LD_EXP 187
112166: PUSH
112167: LD_VAR 0 4
112171: ARRAY
112172: PUSH
112173: LD_INT 0
112175: PLUS
112176: PPUSH
112177: CALL_OW 505
// end ;
112181: LD_VAR 0 2
112185: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
112186: LD_INT 0
112188: PPUSH
112189: PPUSH
112190: PPUSH
112191: PPUSH
// if not hack in hackTanks then
112192: LD_VAR 0 1
112196: PUSH
112197: LD_EXP 186
112201: IN
112202: NOT
112203: IFFALSE 112207
// exit ;
112205: GO 112292
// index := GetElementIndex ( hackTanks , hack ) ;
112207: LD_ADDR_VAR 0 5
112211: PUSH
112212: LD_EXP 186
112216: PPUSH
112217: LD_VAR 0 1
112221: PPUSH
112222: CALL 57595 0 2
112226: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
112227: LD_ADDR_VAR 0 4
112231: PUSH
112232: DOUBLE
112233: LD_INT 1
112235: DEC
112236: ST_TO_ADDR
112237: LD_EXP 187
112241: PUSH
112242: LD_VAR 0 5
112246: ARRAY
112247: PUSH
112248: FOR_TO
112249: IFFALSE 112290
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
112251: LD_EXP 187
112255: PUSH
112256: LD_VAR 0 5
112260: ARRAY
112261: PUSH
112262: LD_VAR 0 4
112266: ARRAY
112267: PUSH
112268: LD_INT 1
112270: ARRAY
112271: PUSH
112272: LD_VAR 0 2
112276: EQUAL
112277: IFFALSE 112288
// KillUnit ( vehicle ) ;
112279: LD_VAR 0 2
112283: PPUSH
112284: CALL_OW 66
112288: GO 112248
112290: POP
112291: POP
// end ;
112292: LD_VAR 0 3
112296: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
112297: LD_EXP 191
112301: NOT
112302: IFFALSE 112337
112304: GO 112306
112306: DISABLE
// begin initMiner := true ;
112307: LD_ADDR_EXP 191
112311: PUSH
112312: LD_INT 1
112314: ST_TO_ADDR
// minersList := [ ] ;
112315: LD_ADDR_EXP 192
112319: PUSH
112320: EMPTY
112321: ST_TO_ADDR
// minerMinesList := [ ] ;
112322: LD_ADDR_EXP 193
112326: PUSH
112327: EMPTY
112328: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
112329: LD_ADDR_EXP 194
112333: PUSH
112334: LD_INT 5
112336: ST_TO_ADDR
// end ;
112337: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
112338: LD_EXP 191
112342: PUSH
112343: LD_INT 34
112345: PUSH
112346: LD_INT 81
112348: PUSH
112349: EMPTY
112350: LIST
112351: LIST
112352: PPUSH
112353: CALL_OW 69
112357: AND
112358: IFFALSE 112819
112360: GO 112362
112362: DISABLE
112363: LD_INT 0
112365: PPUSH
112366: PPUSH
112367: PPUSH
112368: PPUSH
// begin enable ;
112369: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
112370: LD_ADDR_VAR 0 1
112374: PUSH
112375: LD_INT 34
112377: PUSH
112378: LD_INT 81
112380: PUSH
112381: EMPTY
112382: LIST
112383: LIST
112384: PPUSH
112385: CALL_OW 69
112389: PUSH
112390: FOR_IN
112391: IFFALSE 112463
// begin if not i in minersList then
112393: LD_VAR 0 1
112397: PUSH
112398: LD_EXP 192
112402: IN
112403: NOT
112404: IFFALSE 112461
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
112406: LD_ADDR_EXP 192
112410: PUSH
112411: LD_EXP 192
112415: PPUSH
112416: LD_EXP 192
112420: PUSH
112421: LD_INT 1
112423: PLUS
112424: PPUSH
112425: LD_VAR 0 1
112429: PPUSH
112430: CALL_OW 1
112434: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
112435: LD_ADDR_EXP 193
112439: PUSH
112440: LD_EXP 193
112444: PPUSH
112445: LD_EXP 193
112449: PUSH
112450: LD_INT 1
112452: PLUS
112453: PPUSH
112454: EMPTY
112455: PPUSH
112456: CALL_OW 1
112460: ST_TO_ADDR
// end end ;
112461: GO 112390
112463: POP
112464: POP
// for i := minerMinesList downto 1 do
112465: LD_ADDR_VAR 0 1
112469: PUSH
112470: DOUBLE
112471: LD_EXP 193
112475: INC
112476: ST_TO_ADDR
112477: LD_INT 1
112479: PUSH
112480: FOR_DOWNTO
112481: IFFALSE 112817
// begin if IsLive ( minersList [ i ] ) then
112483: LD_EXP 192
112487: PUSH
112488: LD_VAR 0 1
112492: ARRAY
112493: PPUSH
112494: CALL_OW 300
112498: IFFALSE 112526
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
112500: LD_EXP 192
112504: PUSH
112505: LD_VAR 0 1
112509: ARRAY
112510: PPUSH
112511: LD_EXP 193
112515: PUSH
112516: LD_VAR 0 1
112520: ARRAY
112521: PPUSH
112522: CALL_OW 505
// if not minerMinesList [ i ] then
112526: LD_EXP 193
112530: PUSH
112531: LD_VAR 0 1
112535: ARRAY
112536: NOT
112537: IFFALSE 112541
// continue ;
112539: GO 112480
// for j := minerMinesList [ i ] downto 1 do
112541: LD_ADDR_VAR 0 2
112545: PUSH
112546: DOUBLE
112547: LD_EXP 193
112551: PUSH
112552: LD_VAR 0 1
112556: ARRAY
112557: INC
112558: ST_TO_ADDR
112559: LD_INT 1
112561: PUSH
112562: FOR_DOWNTO
112563: IFFALSE 112813
// begin side := GetSide ( minersList [ i ] ) ;
112565: LD_ADDR_VAR 0 3
112569: PUSH
112570: LD_EXP 192
112574: PUSH
112575: LD_VAR 0 1
112579: ARRAY
112580: PPUSH
112581: CALL_OW 255
112585: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
112586: LD_ADDR_VAR 0 4
112590: PUSH
112591: LD_EXP 193
112595: PUSH
112596: LD_VAR 0 1
112600: ARRAY
112601: PUSH
112602: LD_VAR 0 2
112606: ARRAY
112607: PUSH
112608: LD_INT 1
112610: ARRAY
112611: PPUSH
112612: LD_EXP 193
112616: PUSH
112617: LD_VAR 0 1
112621: ARRAY
112622: PUSH
112623: LD_VAR 0 2
112627: ARRAY
112628: PUSH
112629: LD_INT 2
112631: ARRAY
112632: PPUSH
112633: CALL_OW 428
112637: ST_TO_ADDR
// if not tmp then
112638: LD_VAR 0 4
112642: NOT
112643: IFFALSE 112647
// continue ;
112645: GO 112562
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
112647: LD_VAR 0 4
112651: PUSH
112652: LD_INT 81
112654: PUSH
112655: LD_VAR 0 3
112659: PUSH
112660: EMPTY
112661: LIST
112662: LIST
112663: PPUSH
112664: CALL_OW 69
112668: IN
112669: PUSH
112670: LD_EXP 193
112674: PUSH
112675: LD_VAR 0 1
112679: ARRAY
112680: PUSH
112681: LD_VAR 0 2
112685: ARRAY
112686: PUSH
112687: LD_INT 1
112689: ARRAY
112690: PPUSH
112691: LD_EXP 193
112695: PUSH
112696: LD_VAR 0 1
112700: ARRAY
112701: PUSH
112702: LD_VAR 0 2
112706: ARRAY
112707: PUSH
112708: LD_INT 2
112710: ARRAY
112711: PPUSH
112712: CALL_OW 458
112716: AND
112717: IFFALSE 112811
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
112719: LD_EXP 193
112723: PUSH
112724: LD_VAR 0 1
112728: ARRAY
112729: PUSH
112730: LD_VAR 0 2
112734: ARRAY
112735: PUSH
112736: LD_INT 1
112738: ARRAY
112739: PPUSH
112740: LD_EXP 193
112744: PUSH
112745: LD_VAR 0 1
112749: ARRAY
112750: PUSH
112751: LD_VAR 0 2
112755: ARRAY
112756: PUSH
112757: LD_INT 2
112759: ARRAY
112760: PPUSH
112761: LD_VAR 0 3
112765: PPUSH
112766: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
112770: LD_ADDR_EXP 193
112774: PUSH
112775: LD_EXP 193
112779: PPUSH
112780: LD_VAR 0 1
112784: PPUSH
112785: LD_EXP 193
112789: PUSH
112790: LD_VAR 0 1
112794: ARRAY
112795: PPUSH
112796: LD_VAR 0 2
112800: PPUSH
112801: CALL_OW 3
112805: PPUSH
112806: CALL_OW 1
112810: ST_TO_ADDR
// end ; end ;
112811: GO 112562
112813: POP
112814: POP
// end ;
112815: GO 112480
112817: POP
112818: POP
// end ;
112819: PPOPN 4
112821: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
112822: LD_INT 0
112824: PPUSH
112825: PPUSH
// result := false ;
112826: LD_ADDR_VAR 0 4
112830: PUSH
112831: LD_INT 0
112833: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
112834: LD_VAR 0 1
112838: PPUSH
112839: CALL_OW 264
112843: PUSH
112844: LD_INT 81
112846: EQUAL
112847: NOT
112848: IFFALSE 112852
// exit ;
112850: GO 113092
// index := GetElementIndex ( minersList , unit ) ;
112852: LD_ADDR_VAR 0 5
112856: PUSH
112857: LD_EXP 192
112861: PPUSH
112862: LD_VAR 0 1
112866: PPUSH
112867: CALL 57595 0 2
112871: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
112872: LD_EXP 193
112876: PUSH
112877: LD_VAR 0 5
112881: ARRAY
112882: PUSH
112883: LD_EXP 194
112887: GREATEREQUAL
112888: IFFALSE 112892
// exit ;
112890: GO 113092
// ComMoveXY ( unit , x , y ) ;
112892: LD_VAR 0 1
112896: PPUSH
112897: LD_VAR 0 2
112901: PPUSH
112902: LD_VAR 0 3
112906: PPUSH
112907: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112911: LD_INT 35
112913: PPUSH
112914: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
112918: LD_VAR 0 1
112922: PPUSH
112923: LD_VAR 0 2
112927: PPUSH
112928: LD_VAR 0 3
112932: PPUSH
112933: CALL 88950 0 3
112937: NOT
112938: PUSH
112939: LD_VAR 0 1
112943: PPUSH
112944: CALL_OW 314
112948: AND
112949: IFFALSE 112953
// exit ;
112951: GO 113092
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
112953: LD_VAR 0 2
112957: PPUSH
112958: LD_VAR 0 3
112962: PPUSH
112963: CALL_OW 428
112967: PUSH
112968: LD_VAR 0 1
112972: EQUAL
112973: PUSH
112974: LD_VAR 0 1
112978: PPUSH
112979: CALL_OW 314
112983: NOT
112984: AND
112985: IFFALSE 112911
// PlaySoundXY ( x , y , PlantMine ) ;
112987: LD_VAR 0 2
112991: PPUSH
112992: LD_VAR 0 3
112996: PPUSH
112997: LD_STRING PlantMine
112999: PPUSH
113000: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
113004: LD_VAR 0 2
113008: PPUSH
113009: LD_VAR 0 3
113013: PPUSH
113014: LD_VAR 0 1
113018: PPUSH
113019: CALL_OW 255
113023: PPUSH
113024: LD_INT 0
113026: PPUSH
113027: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
113031: LD_ADDR_EXP 193
113035: PUSH
113036: LD_EXP 193
113040: PPUSH
113041: LD_VAR 0 5
113045: PUSH
113046: LD_EXP 193
113050: PUSH
113051: LD_VAR 0 5
113055: ARRAY
113056: PUSH
113057: LD_INT 1
113059: PLUS
113060: PUSH
113061: EMPTY
113062: LIST
113063: LIST
113064: PPUSH
113065: LD_VAR 0 2
113069: PUSH
113070: LD_VAR 0 3
113074: PUSH
113075: EMPTY
113076: LIST
113077: LIST
113078: PPUSH
113079: CALL 57810 0 3
113083: ST_TO_ADDR
// result := true ;
113084: LD_ADDR_VAR 0 4
113088: PUSH
113089: LD_INT 1
113091: ST_TO_ADDR
// end ;
113092: LD_VAR 0 4
113096: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
113097: LD_INT 0
113099: PPUSH
113100: PPUSH
113101: PPUSH
// if not unit in minersList then
113102: LD_VAR 0 1
113106: PUSH
113107: LD_EXP 192
113111: IN
113112: NOT
113113: IFFALSE 113117
// exit ;
113115: GO 113509
// index := GetElementIndex ( minersList , unit ) ;
113117: LD_ADDR_VAR 0 6
113121: PUSH
113122: LD_EXP 192
113126: PPUSH
113127: LD_VAR 0 1
113131: PPUSH
113132: CALL 57595 0 2
113136: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
113137: LD_ADDR_VAR 0 5
113141: PUSH
113142: DOUBLE
113143: LD_EXP 193
113147: PUSH
113148: LD_VAR 0 6
113152: ARRAY
113153: INC
113154: ST_TO_ADDR
113155: LD_INT 1
113157: PUSH
113158: FOR_DOWNTO
113159: IFFALSE 113320
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
113161: LD_EXP 193
113165: PUSH
113166: LD_VAR 0 6
113170: ARRAY
113171: PUSH
113172: LD_VAR 0 5
113176: ARRAY
113177: PUSH
113178: LD_INT 1
113180: ARRAY
113181: PUSH
113182: LD_VAR 0 2
113186: EQUAL
113187: PUSH
113188: LD_EXP 193
113192: PUSH
113193: LD_VAR 0 6
113197: ARRAY
113198: PUSH
113199: LD_VAR 0 5
113203: ARRAY
113204: PUSH
113205: LD_INT 2
113207: ARRAY
113208: PUSH
113209: LD_VAR 0 3
113213: EQUAL
113214: AND
113215: IFFALSE 113318
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
113217: LD_EXP 193
113221: PUSH
113222: LD_VAR 0 6
113226: ARRAY
113227: PUSH
113228: LD_VAR 0 5
113232: ARRAY
113233: PUSH
113234: LD_INT 1
113236: ARRAY
113237: PPUSH
113238: LD_EXP 193
113242: PUSH
113243: LD_VAR 0 6
113247: ARRAY
113248: PUSH
113249: LD_VAR 0 5
113253: ARRAY
113254: PUSH
113255: LD_INT 2
113257: ARRAY
113258: PPUSH
113259: LD_VAR 0 1
113263: PPUSH
113264: CALL_OW 255
113268: PPUSH
113269: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
113273: LD_ADDR_EXP 193
113277: PUSH
113278: LD_EXP 193
113282: PPUSH
113283: LD_VAR 0 6
113287: PPUSH
113288: LD_EXP 193
113292: PUSH
113293: LD_VAR 0 6
113297: ARRAY
113298: PPUSH
113299: LD_VAR 0 5
113303: PPUSH
113304: CALL_OW 3
113308: PPUSH
113309: CALL_OW 1
113313: ST_TO_ADDR
// exit ;
113314: POP
113315: POP
113316: GO 113509
// end ; end ;
113318: GO 113158
113320: POP
113321: POP
// for i := minerMinesList [ index ] downto 1 do
113322: LD_ADDR_VAR 0 5
113326: PUSH
113327: DOUBLE
113328: LD_EXP 193
113332: PUSH
113333: LD_VAR 0 6
113337: ARRAY
113338: INC
113339: ST_TO_ADDR
113340: LD_INT 1
113342: PUSH
113343: FOR_DOWNTO
113344: IFFALSE 113507
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
113346: LD_EXP 193
113350: PUSH
113351: LD_VAR 0 6
113355: ARRAY
113356: PUSH
113357: LD_VAR 0 5
113361: ARRAY
113362: PUSH
113363: LD_INT 1
113365: ARRAY
113366: PPUSH
113367: LD_EXP 193
113371: PUSH
113372: LD_VAR 0 6
113376: ARRAY
113377: PUSH
113378: LD_VAR 0 5
113382: ARRAY
113383: PUSH
113384: LD_INT 2
113386: ARRAY
113387: PPUSH
113388: LD_VAR 0 2
113392: PPUSH
113393: LD_VAR 0 3
113397: PPUSH
113398: CALL_OW 298
113402: PUSH
113403: LD_INT 6
113405: LESS
113406: IFFALSE 113505
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
113408: LD_EXP 193
113412: PUSH
113413: LD_VAR 0 6
113417: ARRAY
113418: PUSH
113419: LD_VAR 0 5
113423: ARRAY
113424: PUSH
113425: LD_INT 1
113427: ARRAY
113428: PPUSH
113429: LD_EXP 193
113433: PUSH
113434: LD_VAR 0 6
113438: ARRAY
113439: PUSH
113440: LD_VAR 0 5
113444: ARRAY
113445: PUSH
113446: LD_INT 2
113448: ARRAY
113449: PPUSH
113450: LD_VAR 0 1
113454: PPUSH
113455: CALL_OW 255
113459: PPUSH
113460: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
113464: LD_ADDR_EXP 193
113468: PUSH
113469: LD_EXP 193
113473: PPUSH
113474: LD_VAR 0 6
113478: PPUSH
113479: LD_EXP 193
113483: PUSH
113484: LD_VAR 0 6
113488: ARRAY
113489: PPUSH
113490: LD_VAR 0 5
113494: PPUSH
113495: CALL_OW 3
113499: PPUSH
113500: CALL_OW 1
113504: ST_TO_ADDR
// end ; end ;
113505: GO 113343
113507: POP
113508: POP
// end ;
113509: LD_VAR 0 4
113513: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
113514: LD_INT 0
113516: PPUSH
113517: PPUSH
113518: PPUSH
113519: PPUSH
113520: PPUSH
113521: PPUSH
113522: PPUSH
113523: PPUSH
113524: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
113525: LD_VAR 0 1
113529: PPUSH
113530: CALL_OW 264
113534: PUSH
113535: LD_INT 81
113537: EQUAL
113538: NOT
113539: PUSH
113540: LD_VAR 0 1
113544: PUSH
113545: LD_EXP 192
113549: IN
113550: NOT
113551: OR
113552: IFFALSE 113556
// exit ;
113554: GO 113878
// index := GetElementIndex ( minersList , unit ) ;
113556: LD_ADDR_VAR 0 6
113560: PUSH
113561: LD_EXP 192
113565: PPUSH
113566: LD_VAR 0 1
113570: PPUSH
113571: CALL 57595 0 2
113575: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
113576: LD_ADDR_VAR 0 8
113580: PUSH
113581: LD_EXP 194
113585: PUSH
113586: LD_EXP 193
113590: PUSH
113591: LD_VAR 0 6
113595: ARRAY
113596: MINUS
113597: ST_TO_ADDR
// if not minesFreeAmount then
113598: LD_VAR 0 8
113602: NOT
113603: IFFALSE 113607
// exit ;
113605: GO 113878
// tmp := [ ] ;
113607: LD_ADDR_VAR 0 7
113611: PUSH
113612: EMPTY
113613: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
113614: LD_ADDR_VAR 0 5
113618: PUSH
113619: DOUBLE
113620: LD_INT 1
113622: DEC
113623: ST_TO_ADDR
113624: LD_VAR 0 8
113628: PUSH
113629: FOR_TO
113630: IFFALSE 113825
// begin _d := rand ( 0 , 5 ) ;
113632: LD_ADDR_VAR 0 11
113636: PUSH
113637: LD_INT 0
113639: PPUSH
113640: LD_INT 5
113642: PPUSH
113643: CALL_OW 12
113647: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
113648: LD_ADDR_VAR 0 12
113652: PUSH
113653: LD_INT 2
113655: PPUSH
113656: LD_INT 6
113658: PPUSH
113659: CALL_OW 12
113663: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
113664: LD_ADDR_VAR 0 9
113668: PUSH
113669: LD_VAR 0 2
113673: PPUSH
113674: LD_VAR 0 11
113678: PPUSH
113679: LD_VAR 0 12
113683: PPUSH
113684: CALL_OW 272
113688: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
113689: LD_ADDR_VAR 0 10
113693: PUSH
113694: LD_VAR 0 3
113698: PPUSH
113699: LD_VAR 0 11
113703: PPUSH
113704: LD_VAR 0 12
113708: PPUSH
113709: CALL_OW 273
113713: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
113714: LD_VAR 0 9
113718: PPUSH
113719: LD_VAR 0 10
113723: PPUSH
113724: CALL_OW 488
113728: PUSH
113729: LD_VAR 0 9
113733: PUSH
113734: LD_VAR 0 10
113738: PUSH
113739: EMPTY
113740: LIST
113741: LIST
113742: PUSH
113743: LD_VAR 0 7
113747: IN
113748: NOT
113749: AND
113750: PUSH
113751: LD_VAR 0 9
113755: PPUSH
113756: LD_VAR 0 10
113760: PPUSH
113761: CALL_OW 458
113765: NOT
113766: AND
113767: IFFALSE 113809
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
113769: LD_ADDR_VAR 0 7
113773: PUSH
113774: LD_VAR 0 7
113778: PPUSH
113779: LD_VAR 0 7
113783: PUSH
113784: LD_INT 1
113786: PLUS
113787: PPUSH
113788: LD_VAR 0 9
113792: PUSH
113793: LD_VAR 0 10
113797: PUSH
113798: EMPTY
113799: LIST
113800: LIST
113801: PPUSH
113802: CALL_OW 1
113806: ST_TO_ADDR
113807: GO 113823
// i := i - 1 ;
113809: LD_ADDR_VAR 0 5
113813: PUSH
113814: LD_VAR 0 5
113818: PUSH
113819: LD_INT 1
113821: MINUS
113822: ST_TO_ADDR
// end ;
113823: GO 113629
113825: POP
113826: POP
// for i in tmp do
113827: LD_ADDR_VAR 0 5
113831: PUSH
113832: LD_VAR 0 7
113836: PUSH
113837: FOR_IN
113838: IFFALSE 113876
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
113840: LD_VAR 0 1
113844: PPUSH
113845: LD_VAR 0 5
113849: PUSH
113850: LD_INT 1
113852: ARRAY
113853: PPUSH
113854: LD_VAR 0 5
113858: PUSH
113859: LD_INT 2
113861: ARRAY
113862: PPUSH
113863: CALL 112822 0 3
113867: NOT
113868: IFFALSE 113874
// exit ;
113870: POP
113871: POP
113872: GO 113878
113874: GO 113837
113876: POP
113877: POP
// end ;
113878: LD_VAR 0 4
113882: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
113883: LD_INT 0
113885: PPUSH
113886: PPUSH
113887: PPUSH
113888: PPUSH
113889: PPUSH
113890: PPUSH
113891: PPUSH
// if not GetClass ( unit ) = class_sniper then
113892: LD_VAR 0 1
113896: PPUSH
113897: CALL_OW 257
113901: PUSH
113902: LD_INT 5
113904: EQUAL
113905: NOT
113906: IFFALSE 113910
// exit ;
113908: GO 114298
// dist := 8 ;
113910: LD_ADDR_VAR 0 5
113914: PUSH
113915: LD_INT 8
113917: ST_TO_ADDR
// viewRange := 12 ;
113918: LD_ADDR_VAR 0 7
113922: PUSH
113923: LD_INT 12
113925: ST_TO_ADDR
// side := GetSide ( unit ) ;
113926: LD_ADDR_VAR 0 6
113930: PUSH
113931: LD_VAR 0 1
113935: PPUSH
113936: CALL_OW 255
113940: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
113941: LD_INT 61
113943: PPUSH
113944: LD_VAR 0 6
113948: PPUSH
113949: CALL_OW 321
113953: PUSH
113954: LD_INT 2
113956: EQUAL
113957: IFFALSE 113967
// viewRange := 16 ;
113959: LD_ADDR_VAR 0 7
113963: PUSH
113964: LD_INT 16
113966: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
113967: LD_VAR 0 1
113971: PPUSH
113972: LD_VAR 0 2
113976: PPUSH
113977: LD_VAR 0 3
113981: PPUSH
113982: CALL_OW 297
113986: PUSH
113987: LD_VAR 0 5
113991: GREATER
113992: IFFALSE 114071
// begin ComMoveXY ( unit , x , y ) ;
113994: LD_VAR 0 1
113998: PPUSH
113999: LD_VAR 0 2
114003: PPUSH
114004: LD_VAR 0 3
114008: PPUSH
114009: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
114013: LD_INT 35
114015: PPUSH
114016: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
114020: LD_VAR 0 1
114024: PPUSH
114025: LD_VAR 0 2
114029: PPUSH
114030: LD_VAR 0 3
114034: PPUSH
114035: CALL 88950 0 3
114039: NOT
114040: IFFALSE 114044
// exit ;
114042: GO 114298
// until GetDistUnitXY ( unit , x , y ) < dist ;
114044: LD_VAR 0 1
114048: PPUSH
114049: LD_VAR 0 2
114053: PPUSH
114054: LD_VAR 0 3
114058: PPUSH
114059: CALL_OW 297
114063: PUSH
114064: LD_VAR 0 5
114068: LESS
114069: IFFALSE 114013
// end ; ComTurnXY ( unit , x , y ) ;
114071: LD_VAR 0 1
114075: PPUSH
114076: LD_VAR 0 2
114080: PPUSH
114081: LD_VAR 0 3
114085: PPUSH
114086: CALL_OW 118
// wait ( 5 ) ;
114090: LD_INT 5
114092: PPUSH
114093: CALL_OW 67
// _d := GetDir ( unit ) ;
114097: LD_ADDR_VAR 0 10
114101: PUSH
114102: LD_VAR 0 1
114106: PPUSH
114107: CALL_OW 254
114111: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
114112: LD_ADDR_VAR 0 8
114116: PUSH
114117: LD_VAR 0 1
114121: PPUSH
114122: CALL_OW 250
114126: PPUSH
114127: LD_VAR 0 10
114131: PPUSH
114132: LD_VAR 0 5
114136: PPUSH
114137: CALL_OW 272
114141: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
114142: LD_ADDR_VAR 0 9
114146: PUSH
114147: LD_VAR 0 1
114151: PPUSH
114152: CALL_OW 251
114156: PPUSH
114157: LD_VAR 0 10
114161: PPUSH
114162: LD_VAR 0 5
114166: PPUSH
114167: CALL_OW 273
114171: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
114172: LD_VAR 0 8
114176: PPUSH
114177: LD_VAR 0 9
114181: PPUSH
114182: CALL_OW 488
114186: NOT
114187: IFFALSE 114191
// exit ;
114189: GO 114298
// ComAnimCustom ( unit , 1 ) ;
114191: LD_VAR 0 1
114195: PPUSH
114196: LD_INT 1
114198: PPUSH
114199: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
114203: LD_VAR 0 8
114207: PPUSH
114208: LD_VAR 0 9
114212: PPUSH
114213: LD_VAR 0 6
114217: PPUSH
114218: LD_VAR 0 7
114222: PPUSH
114223: CALL_OW 330
// repeat wait ( 1 ) ;
114227: LD_INT 1
114229: PPUSH
114230: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
114234: LD_VAR 0 1
114238: PPUSH
114239: CALL_OW 316
114243: PUSH
114244: LD_VAR 0 1
114248: PPUSH
114249: CALL_OW 314
114253: OR
114254: PUSH
114255: LD_VAR 0 1
114259: PPUSH
114260: CALL_OW 302
114264: NOT
114265: OR
114266: PUSH
114267: LD_VAR 0 1
114271: PPUSH
114272: CALL_OW 301
114276: OR
114277: IFFALSE 114227
// RemoveSeeing ( _x , _y , side ) ;
114279: LD_VAR 0 8
114283: PPUSH
114284: LD_VAR 0 9
114288: PPUSH
114289: LD_VAR 0 6
114293: PPUSH
114294: CALL_OW 331
// end ; end_of_file
114298: LD_VAR 0 4
114302: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
114303: LD_INT 0
114305: PPUSH
114306: PPUSH
114307: PPUSH
114308: PPUSH
114309: PPUSH
114310: PPUSH
114311: PPUSH
114312: PPUSH
114313: PPUSH
114314: PPUSH
114315: PPUSH
114316: PPUSH
114317: PPUSH
114318: PPUSH
114319: PPUSH
114320: PPUSH
114321: PPUSH
114322: PPUSH
114323: PPUSH
114324: PPUSH
114325: PPUSH
114326: PPUSH
114327: PPUSH
114328: PPUSH
114329: PPUSH
114330: PPUSH
114331: PPUSH
114332: PPUSH
114333: PPUSH
114334: PPUSH
114335: PPUSH
114336: PPUSH
114337: PPUSH
114338: PPUSH
// if not list then
114339: LD_VAR 0 1
114343: NOT
114344: IFFALSE 114348
// exit ;
114346: GO 119007
// base := list [ 1 ] ;
114348: LD_ADDR_VAR 0 3
114352: PUSH
114353: LD_VAR 0 1
114357: PUSH
114358: LD_INT 1
114360: ARRAY
114361: ST_TO_ADDR
// group := list [ 2 ] ;
114362: LD_ADDR_VAR 0 4
114366: PUSH
114367: LD_VAR 0 1
114371: PUSH
114372: LD_INT 2
114374: ARRAY
114375: ST_TO_ADDR
// path := list [ 3 ] ;
114376: LD_ADDR_VAR 0 5
114380: PUSH
114381: LD_VAR 0 1
114385: PUSH
114386: LD_INT 3
114388: ARRAY
114389: ST_TO_ADDR
// flags := list [ 4 ] ;
114390: LD_ADDR_VAR 0 6
114394: PUSH
114395: LD_VAR 0 1
114399: PUSH
114400: LD_INT 4
114402: ARRAY
114403: ST_TO_ADDR
// mined := [ ] ;
114404: LD_ADDR_VAR 0 27
114408: PUSH
114409: EMPTY
114410: ST_TO_ADDR
// bombed := [ ] ;
114411: LD_ADDR_VAR 0 28
114415: PUSH
114416: EMPTY
114417: ST_TO_ADDR
// healers := [ ] ;
114418: LD_ADDR_VAR 0 31
114422: PUSH
114423: EMPTY
114424: ST_TO_ADDR
// to_heal := [ ] ;
114425: LD_ADDR_VAR 0 30
114429: PUSH
114430: EMPTY
114431: ST_TO_ADDR
// repairs := [ ] ;
114432: LD_ADDR_VAR 0 33
114436: PUSH
114437: EMPTY
114438: ST_TO_ADDR
// to_repair := [ ] ;
114439: LD_ADDR_VAR 0 32
114443: PUSH
114444: EMPTY
114445: ST_TO_ADDR
// if not group or not path then
114446: LD_VAR 0 4
114450: NOT
114451: PUSH
114452: LD_VAR 0 5
114456: NOT
114457: OR
114458: IFFALSE 114462
// exit ;
114460: GO 119007
// side := GetSide ( group [ 1 ] ) ;
114462: LD_ADDR_VAR 0 35
114466: PUSH
114467: LD_VAR 0 4
114471: PUSH
114472: LD_INT 1
114474: ARRAY
114475: PPUSH
114476: CALL_OW 255
114480: ST_TO_ADDR
// if flags then
114481: LD_VAR 0 6
114485: IFFALSE 114629
// begin f_ignore_area := flags [ 1 ] ;
114487: LD_ADDR_VAR 0 17
114491: PUSH
114492: LD_VAR 0 6
114496: PUSH
114497: LD_INT 1
114499: ARRAY
114500: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
114501: LD_ADDR_VAR 0 18
114505: PUSH
114506: LD_VAR 0 6
114510: PUSH
114511: LD_INT 2
114513: ARRAY
114514: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
114515: LD_ADDR_VAR 0 19
114519: PUSH
114520: LD_VAR 0 6
114524: PUSH
114525: LD_INT 3
114527: ARRAY
114528: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
114529: LD_ADDR_VAR 0 20
114533: PUSH
114534: LD_VAR 0 6
114538: PUSH
114539: LD_INT 4
114541: ARRAY
114542: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
114543: LD_ADDR_VAR 0 21
114547: PUSH
114548: LD_VAR 0 6
114552: PUSH
114553: LD_INT 5
114555: ARRAY
114556: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
114557: LD_ADDR_VAR 0 22
114561: PUSH
114562: LD_VAR 0 6
114566: PUSH
114567: LD_INT 6
114569: ARRAY
114570: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
114571: LD_ADDR_VAR 0 23
114575: PUSH
114576: LD_VAR 0 6
114580: PUSH
114581: LD_INT 7
114583: ARRAY
114584: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
114585: LD_ADDR_VAR 0 24
114589: PUSH
114590: LD_VAR 0 6
114594: PUSH
114595: LD_INT 8
114597: ARRAY
114598: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
114599: LD_ADDR_VAR 0 25
114603: PUSH
114604: LD_VAR 0 6
114608: PUSH
114609: LD_INT 9
114611: ARRAY
114612: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
114613: LD_ADDR_VAR 0 26
114617: PUSH
114618: LD_VAR 0 6
114622: PUSH
114623: LD_INT 10
114625: ARRAY
114626: ST_TO_ADDR
// end else
114627: GO 114709
// begin f_ignore_area := false ;
114629: LD_ADDR_VAR 0 17
114633: PUSH
114634: LD_INT 0
114636: ST_TO_ADDR
// f_capture := false ;
114637: LD_ADDR_VAR 0 18
114641: PUSH
114642: LD_INT 0
114644: ST_TO_ADDR
// f_ignore_civ := false ;
114645: LD_ADDR_VAR 0 19
114649: PUSH
114650: LD_INT 0
114652: ST_TO_ADDR
// f_murder := false ;
114653: LD_ADDR_VAR 0 20
114657: PUSH
114658: LD_INT 0
114660: ST_TO_ADDR
// f_mines := false ;
114661: LD_ADDR_VAR 0 21
114665: PUSH
114666: LD_INT 0
114668: ST_TO_ADDR
// f_repair := false ;
114669: LD_ADDR_VAR 0 22
114673: PUSH
114674: LD_INT 0
114676: ST_TO_ADDR
// f_heal := false ;
114677: LD_ADDR_VAR 0 23
114681: PUSH
114682: LD_INT 0
114684: ST_TO_ADDR
// f_spacetime := false ;
114685: LD_ADDR_VAR 0 24
114689: PUSH
114690: LD_INT 0
114692: ST_TO_ADDR
// f_attack_depot := false ;
114693: LD_ADDR_VAR 0 25
114697: PUSH
114698: LD_INT 0
114700: ST_TO_ADDR
// f_crawl := false ;
114701: LD_ADDR_VAR 0 26
114705: PUSH
114706: LD_INT 0
114708: ST_TO_ADDR
// end ; if f_heal then
114709: LD_VAR 0 23
114713: IFFALSE 114740
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
114715: LD_ADDR_VAR 0 31
114719: PUSH
114720: LD_VAR 0 4
114724: PPUSH
114725: LD_INT 25
114727: PUSH
114728: LD_INT 4
114730: PUSH
114731: EMPTY
114732: LIST
114733: LIST
114734: PPUSH
114735: CALL_OW 72
114739: ST_TO_ADDR
// if f_repair then
114740: LD_VAR 0 22
114744: IFFALSE 114771
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
114746: LD_ADDR_VAR 0 33
114750: PUSH
114751: LD_VAR 0 4
114755: PPUSH
114756: LD_INT 25
114758: PUSH
114759: LD_INT 3
114761: PUSH
114762: EMPTY
114763: LIST
114764: LIST
114765: PPUSH
114766: CALL_OW 72
114770: ST_TO_ADDR
// units_path := [ ] ;
114771: LD_ADDR_VAR 0 16
114775: PUSH
114776: EMPTY
114777: ST_TO_ADDR
// for i = 1 to group do
114778: LD_ADDR_VAR 0 7
114782: PUSH
114783: DOUBLE
114784: LD_INT 1
114786: DEC
114787: ST_TO_ADDR
114788: LD_VAR 0 4
114792: PUSH
114793: FOR_TO
114794: IFFALSE 114823
// units_path := Replace ( units_path , i , path ) ;
114796: LD_ADDR_VAR 0 16
114800: PUSH
114801: LD_VAR 0 16
114805: PPUSH
114806: LD_VAR 0 7
114810: PPUSH
114811: LD_VAR 0 5
114815: PPUSH
114816: CALL_OW 1
114820: ST_TO_ADDR
114821: GO 114793
114823: POP
114824: POP
// repeat for i = group downto 1 do
114825: LD_ADDR_VAR 0 7
114829: PUSH
114830: DOUBLE
114831: LD_VAR 0 4
114835: INC
114836: ST_TO_ADDR
114837: LD_INT 1
114839: PUSH
114840: FOR_DOWNTO
114841: IFFALSE 118963
// begin wait ( 5 ) ;
114843: LD_INT 5
114845: PPUSH
114846: CALL_OW 67
// tmp := [ ] ;
114850: LD_ADDR_VAR 0 14
114854: PUSH
114855: EMPTY
114856: ST_TO_ADDR
// attacking := false ;
114857: LD_ADDR_VAR 0 29
114861: PUSH
114862: LD_INT 0
114864: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
114865: LD_VAR 0 4
114869: PUSH
114870: LD_VAR 0 7
114874: ARRAY
114875: PPUSH
114876: CALL_OW 301
114880: PUSH
114881: LD_VAR 0 4
114885: PUSH
114886: LD_VAR 0 7
114890: ARRAY
114891: NOT
114892: OR
114893: IFFALSE 115002
// begin if GetType ( group [ i ] ) = unit_human then
114895: LD_VAR 0 4
114899: PUSH
114900: LD_VAR 0 7
114904: ARRAY
114905: PPUSH
114906: CALL_OW 247
114910: PUSH
114911: LD_INT 1
114913: EQUAL
114914: IFFALSE 114960
// begin to_heal := to_heal diff group [ i ] ;
114916: LD_ADDR_VAR 0 30
114920: PUSH
114921: LD_VAR 0 30
114925: PUSH
114926: LD_VAR 0 4
114930: PUSH
114931: LD_VAR 0 7
114935: ARRAY
114936: DIFF
114937: ST_TO_ADDR
// healers := healers diff group [ i ] ;
114938: LD_ADDR_VAR 0 31
114942: PUSH
114943: LD_VAR 0 31
114947: PUSH
114948: LD_VAR 0 4
114952: PUSH
114953: LD_VAR 0 7
114957: ARRAY
114958: DIFF
114959: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
114960: LD_ADDR_VAR 0 4
114964: PUSH
114965: LD_VAR 0 4
114969: PPUSH
114970: LD_VAR 0 7
114974: PPUSH
114975: CALL_OW 3
114979: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
114980: LD_ADDR_VAR 0 16
114984: PUSH
114985: LD_VAR 0 16
114989: PPUSH
114990: LD_VAR 0 7
114994: PPUSH
114995: CALL_OW 3
114999: ST_TO_ADDR
// continue ;
115000: GO 114840
// end ; if f_repair then
115002: LD_VAR 0 22
115006: IFFALSE 115495
// begin if GetType ( group [ i ] ) = unit_vehicle then
115008: LD_VAR 0 4
115012: PUSH
115013: LD_VAR 0 7
115017: ARRAY
115018: PPUSH
115019: CALL_OW 247
115023: PUSH
115024: LD_INT 2
115026: EQUAL
115027: IFFALSE 115217
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
115029: LD_VAR 0 4
115033: PUSH
115034: LD_VAR 0 7
115038: ARRAY
115039: PPUSH
115040: CALL_OW 256
115044: PUSH
115045: LD_INT 700
115047: LESS
115048: PUSH
115049: LD_VAR 0 4
115053: PUSH
115054: LD_VAR 0 7
115058: ARRAY
115059: PUSH
115060: LD_VAR 0 32
115064: IN
115065: NOT
115066: AND
115067: IFFALSE 115091
// to_repair := to_repair union group [ i ] ;
115069: LD_ADDR_VAR 0 32
115073: PUSH
115074: LD_VAR 0 32
115078: PUSH
115079: LD_VAR 0 4
115083: PUSH
115084: LD_VAR 0 7
115088: ARRAY
115089: UNION
115090: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
115091: LD_VAR 0 4
115095: PUSH
115096: LD_VAR 0 7
115100: ARRAY
115101: PPUSH
115102: CALL_OW 256
115106: PUSH
115107: LD_INT 1000
115109: EQUAL
115110: PUSH
115111: LD_VAR 0 4
115115: PUSH
115116: LD_VAR 0 7
115120: ARRAY
115121: PUSH
115122: LD_VAR 0 32
115126: IN
115127: AND
115128: IFFALSE 115152
// to_repair := to_repair diff group [ i ] ;
115130: LD_ADDR_VAR 0 32
115134: PUSH
115135: LD_VAR 0 32
115139: PUSH
115140: LD_VAR 0 4
115144: PUSH
115145: LD_VAR 0 7
115149: ARRAY
115150: DIFF
115151: ST_TO_ADDR
// if group [ i ] in to_repair then
115152: LD_VAR 0 4
115156: PUSH
115157: LD_VAR 0 7
115161: ARRAY
115162: PUSH
115163: LD_VAR 0 32
115167: IN
115168: IFFALSE 115215
// begin if not IsInArea ( group [ i ] , f_repair ) then
115170: LD_VAR 0 4
115174: PUSH
115175: LD_VAR 0 7
115179: ARRAY
115180: PPUSH
115181: LD_VAR 0 22
115185: PPUSH
115186: CALL_OW 308
115190: NOT
115191: IFFALSE 115213
// ComMoveToArea ( group [ i ] , f_repair ) ;
115193: LD_VAR 0 4
115197: PUSH
115198: LD_VAR 0 7
115202: ARRAY
115203: PPUSH
115204: LD_VAR 0 22
115208: PPUSH
115209: CALL_OW 113
// continue ;
115213: GO 114840
// end ; end else
115215: GO 115495
// if group [ i ] in repairs then
115217: LD_VAR 0 4
115221: PUSH
115222: LD_VAR 0 7
115226: ARRAY
115227: PUSH
115228: LD_VAR 0 33
115232: IN
115233: IFFALSE 115495
// begin if IsInUnit ( group [ i ] ) then
115235: LD_VAR 0 4
115239: PUSH
115240: LD_VAR 0 7
115244: ARRAY
115245: PPUSH
115246: CALL_OW 310
115250: IFFALSE 115318
// begin z := IsInUnit ( group [ i ] ) ;
115252: LD_ADDR_VAR 0 13
115256: PUSH
115257: LD_VAR 0 4
115261: PUSH
115262: LD_VAR 0 7
115266: ARRAY
115267: PPUSH
115268: CALL_OW 310
115272: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
115273: LD_VAR 0 13
115277: PUSH
115278: LD_VAR 0 32
115282: IN
115283: PUSH
115284: LD_VAR 0 13
115288: PPUSH
115289: LD_VAR 0 22
115293: PPUSH
115294: CALL_OW 308
115298: AND
115299: IFFALSE 115316
// ComExitVehicle ( group [ i ] ) ;
115301: LD_VAR 0 4
115305: PUSH
115306: LD_VAR 0 7
115310: ARRAY
115311: PPUSH
115312: CALL_OW 121
// end else
115316: GO 115495
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
115318: LD_ADDR_VAR 0 13
115322: PUSH
115323: LD_VAR 0 4
115327: PPUSH
115328: LD_INT 95
115330: PUSH
115331: LD_VAR 0 22
115335: PUSH
115336: EMPTY
115337: LIST
115338: LIST
115339: PUSH
115340: LD_INT 58
115342: PUSH
115343: EMPTY
115344: LIST
115345: PUSH
115346: EMPTY
115347: LIST
115348: LIST
115349: PPUSH
115350: CALL_OW 72
115354: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
115355: LD_VAR 0 4
115359: PUSH
115360: LD_VAR 0 7
115364: ARRAY
115365: PPUSH
115366: CALL_OW 314
115370: NOT
115371: IFFALSE 115493
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
115373: LD_ADDR_VAR 0 10
115377: PUSH
115378: LD_VAR 0 13
115382: PPUSH
115383: LD_VAR 0 4
115387: PUSH
115388: LD_VAR 0 7
115392: ARRAY
115393: PPUSH
115394: CALL_OW 74
115398: ST_TO_ADDR
// if not x then
115399: LD_VAR 0 10
115403: NOT
115404: IFFALSE 115408
// continue ;
115406: GO 114840
// if GetLives ( x ) < 1000 then
115408: LD_VAR 0 10
115412: PPUSH
115413: CALL_OW 256
115417: PUSH
115418: LD_INT 1000
115420: LESS
115421: IFFALSE 115445
// ComRepairVehicle ( group [ i ] , x ) else
115423: LD_VAR 0 4
115427: PUSH
115428: LD_VAR 0 7
115432: ARRAY
115433: PPUSH
115434: LD_VAR 0 10
115438: PPUSH
115439: CALL_OW 129
115443: GO 115493
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
115445: LD_VAR 0 23
115449: PUSH
115450: LD_VAR 0 4
115454: PUSH
115455: LD_VAR 0 7
115459: ARRAY
115460: PPUSH
115461: CALL_OW 256
115465: PUSH
115466: LD_INT 1000
115468: LESS
115469: AND
115470: NOT
115471: IFFALSE 115493
// ComEnterUnit ( group [ i ] , x ) ;
115473: LD_VAR 0 4
115477: PUSH
115478: LD_VAR 0 7
115482: ARRAY
115483: PPUSH
115484: LD_VAR 0 10
115488: PPUSH
115489: CALL_OW 120
// end ; continue ;
115493: GO 114840
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
115495: LD_VAR 0 23
115499: PUSH
115500: LD_VAR 0 4
115504: PUSH
115505: LD_VAR 0 7
115509: ARRAY
115510: PPUSH
115511: CALL_OW 247
115515: PUSH
115516: LD_INT 1
115518: EQUAL
115519: AND
115520: IFFALSE 115998
// begin if group [ i ] in healers then
115522: LD_VAR 0 4
115526: PUSH
115527: LD_VAR 0 7
115531: ARRAY
115532: PUSH
115533: LD_VAR 0 31
115537: IN
115538: IFFALSE 115811
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
115540: LD_VAR 0 4
115544: PUSH
115545: LD_VAR 0 7
115549: ARRAY
115550: PPUSH
115551: LD_VAR 0 23
115555: PPUSH
115556: CALL_OW 308
115560: NOT
115561: PUSH
115562: LD_VAR 0 4
115566: PUSH
115567: LD_VAR 0 7
115571: ARRAY
115572: PPUSH
115573: CALL_OW 314
115577: NOT
115578: AND
115579: IFFALSE 115603
// ComMoveToArea ( group [ i ] , f_heal ) else
115581: LD_VAR 0 4
115585: PUSH
115586: LD_VAR 0 7
115590: ARRAY
115591: PPUSH
115592: LD_VAR 0 23
115596: PPUSH
115597: CALL_OW 113
115601: GO 115809
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
115603: LD_VAR 0 4
115607: PUSH
115608: LD_VAR 0 7
115612: ARRAY
115613: PPUSH
115614: CALL 87533 0 1
115618: PPUSH
115619: CALL_OW 256
115623: PUSH
115624: LD_INT 1000
115626: EQUAL
115627: IFFALSE 115646
// ComStop ( group [ i ] ) else
115629: LD_VAR 0 4
115633: PUSH
115634: LD_VAR 0 7
115638: ARRAY
115639: PPUSH
115640: CALL_OW 141
115644: GO 115809
// if not HasTask ( group [ i ] ) and to_heal then
115646: LD_VAR 0 4
115650: PUSH
115651: LD_VAR 0 7
115655: ARRAY
115656: PPUSH
115657: CALL_OW 314
115661: NOT
115662: PUSH
115663: LD_VAR 0 30
115667: AND
115668: IFFALSE 115809
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
115670: LD_ADDR_VAR 0 13
115674: PUSH
115675: LD_VAR 0 30
115679: PPUSH
115680: LD_INT 3
115682: PUSH
115683: LD_INT 54
115685: PUSH
115686: EMPTY
115687: LIST
115688: PUSH
115689: EMPTY
115690: LIST
115691: LIST
115692: PPUSH
115693: CALL_OW 72
115697: PPUSH
115698: LD_VAR 0 4
115702: PUSH
115703: LD_VAR 0 7
115707: ARRAY
115708: PPUSH
115709: CALL_OW 74
115713: ST_TO_ADDR
// if z then
115714: LD_VAR 0 13
115718: IFFALSE 115809
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
115720: LD_INT 91
115722: PUSH
115723: LD_VAR 0 13
115727: PUSH
115728: LD_INT 10
115730: PUSH
115731: EMPTY
115732: LIST
115733: LIST
115734: LIST
115735: PUSH
115736: LD_INT 81
115738: PUSH
115739: LD_VAR 0 13
115743: PPUSH
115744: CALL_OW 255
115748: PUSH
115749: EMPTY
115750: LIST
115751: LIST
115752: PUSH
115753: EMPTY
115754: LIST
115755: LIST
115756: PPUSH
115757: CALL_OW 69
115761: PUSH
115762: LD_INT 0
115764: EQUAL
115765: IFFALSE 115789
// ComHeal ( group [ i ] , z ) else
115767: LD_VAR 0 4
115771: PUSH
115772: LD_VAR 0 7
115776: ARRAY
115777: PPUSH
115778: LD_VAR 0 13
115782: PPUSH
115783: CALL_OW 128
115787: GO 115809
// ComMoveToArea ( group [ i ] , f_heal ) ;
115789: LD_VAR 0 4
115793: PUSH
115794: LD_VAR 0 7
115798: ARRAY
115799: PPUSH
115800: LD_VAR 0 23
115804: PPUSH
115805: CALL_OW 113
// end ; continue ;
115809: GO 114840
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
115811: LD_VAR 0 4
115815: PUSH
115816: LD_VAR 0 7
115820: ARRAY
115821: PPUSH
115822: CALL_OW 256
115826: PUSH
115827: LD_INT 700
115829: LESS
115830: PUSH
115831: LD_VAR 0 4
115835: PUSH
115836: LD_VAR 0 7
115840: ARRAY
115841: PUSH
115842: LD_VAR 0 30
115846: IN
115847: NOT
115848: AND
115849: IFFALSE 115873
// to_heal := to_heal union group [ i ] ;
115851: LD_ADDR_VAR 0 30
115855: PUSH
115856: LD_VAR 0 30
115860: PUSH
115861: LD_VAR 0 4
115865: PUSH
115866: LD_VAR 0 7
115870: ARRAY
115871: UNION
115872: ST_TO_ADDR
// if group [ i ] in to_heal then
115873: LD_VAR 0 4
115877: PUSH
115878: LD_VAR 0 7
115882: ARRAY
115883: PUSH
115884: LD_VAR 0 30
115888: IN
115889: IFFALSE 115998
// begin if GetLives ( group [ i ] ) = 1000 then
115891: LD_VAR 0 4
115895: PUSH
115896: LD_VAR 0 7
115900: ARRAY
115901: PPUSH
115902: CALL_OW 256
115906: PUSH
115907: LD_INT 1000
115909: EQUAL
115910: IFFALSE 115936
// to_heal := to_heal diff group [ i ] else
115912: LD_ADDR_VAR 0 30
115916: PUSH
115917: LD_VAR 0 30
115921: PUSH
115922: LD_VAR 0 4
115926: PUSH
115927: LD_VAR 0 7
115931: ARRAY
115932: DIFF
115933: ST_TO_ADDR
115934: GO 115998
// begin if not IsInArea ( group [ i ] , to_heal ) then
115936: LD_VAR 0 4
115940: PUSH
115941: LD_VAR 0 7
115945: ARRAY
115946: PPUSH
115947: LD_VAR 0 30
115951: PPUSH
115952: CALL_OW 308
115956: NOT
115957: IFFALSE 115981
// ComMoveToArea ( group [ i ] , f_heal ) else
115959: LD_VAR 0 4
115963: PUSH
115964: LD_VAR 0 7
115968: ARRAY
115969: PPUSH
115970: LD_VAR 0 23
115974: PPUSH
115975: CALL_OW 113
115979: GO 115996
// ComHold ( group [ i ] ) ;
115981: LD_VAR 0 4
115985: PUSH
115986: LD_VAR 0 7
115990: ARRAY
115991: PPUSH
115992: CALL_OW 140
// continue ;
115996: GO 114840
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
115998: LD_VAR 0 4
116002: PUSH
116003: LD_VAR 0 7
116007: ARRAY
116008: PPUSH
116009: LD_INT 10
116011: PPUSH
116012: CALL 85304 0 2
116016: NOT
116017: PUSH
116018: LD_VAR 0 16
116022: PUSH
116023: LD_VAR 0 7
116027: ARRAY
116028: PUSH
116029: EMPTY
116030: EQUAL
116031: NOT
116032: AND
116033: IFFALSE 116299
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
116035: LD_VAR 0 4
116039: PUSH
116040: LD_VAR 0 7
116044: ARRAY
116045: PPUSH
116046: CALL_OW 262
116050: PUSH
116051: LD_INT 1
116053: PUSH
116054: LD_INT 2
116056: PUSH
116057: EMPTY
116058: LIST
116059: LIST
116060: IN
116061: IFFALSE 116102
// if GetFuel ( group [ i ] ) < 10 then
116063: LD_VAR 0 4
116067: PUSH
116068: LD_VAR 0 7
116072: ARRAY
116073: PPUSH
116074: CALL_OW 261
116078: PUSH
116079: LD_INT 10
116081: LESS
116082: IFFALSE 116102
// SetFuel ( group [ i ] , 12 ) ;
116084: LD_VAR 0 4
116088: PUSH
116089: LD_VAR 0 7
116093: ARRAY
116094: PPUSH
116095: LD_INT 12
116097: PPUSH
116098: CALL_OW 240
// if units_path [ i ] then
116102: LD_VAR 0 16
116106: PUSH
116107: LD_VAR 0 7
116111: ARRAY
116112: IFFALSE 116297
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
116114: LD_VAR 0 4
116118: PUSH
116119: LD_VAR 0 7
116123: ARRAY
116124: PPUSH
116125: LD_VAR 0 16
116129: PUSH
116130: LD_VAR 0 7
116134: ARRAY
116135: PUSH
116136: LD_INT 1
116138: ARRAY
116139: PUSH
116140: LD_INT 1
116142: ARRAY
116143: PPUSH
116144: LD_VAR 0 16
116148: PUSH
116149: LD_VAR 0 7
116153: ARRAY
116154: PUSH
116155: LD_INT 1
116157: ARRAY
116158: PUSH
116159: LD_INT 2
116161: ARRAY
116162: PPUSH
116163: CALL_OW 297
116167: PUSH
116168: LD_INT 6
116170: GREATER
116171: IFFALSE 116246
// begin if not HasTask ( group [ i ] ) then
116173: LD_VAR 0 4
116177: PUSH
116178: LD_VAR 0 7
116182: ARRAY
116183: PPUSH
116184: CALL_OW 314
116188: NOT
116189: IFFALSE 116244
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
116191: LD_VAR 0 4
116195: PUSH
116196: LD_VAR 0 7
116200: ARRAY
116201: PPUSH
116202: LD_VAR 0 16
116206: PUSH
116207: LD_VAR 0 7
116211: ARRAY
116212: PUSH
116213: LD_INT 1
116215: ARRAY
116216: PUSH
116217: LD_INT 1
116219: ARRAY
116220: PPUSH
116221: LD_VAR 0 16
116225: PUSH
116226: LD_VAR 0 7
116230: ARRAY
116231: PUSH
116232: LD_INT 1
116234: ARRAY
116235: PUSH
116236: LD_INT 2
116238: ARRAY
116239: PPUSH
116240: CALL_OW 114
// end else
116244: GO 116297
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
116246: LD_ADDR_VAR 0 15
116250: PUSH
116251: LD_VAR 0 16
116255: PUSH
116256: LD_VAR 0 7
116260: ARRAY
116261: PPUSH
116262: LD_INT 1
116264: PPUSH
116265: CALL_OW 3
116269: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
116270: LD_ADDR_VAR 0 16
116274: PUSH
116275: LD_VAR 0 16
116279: PPUSH
116280: LD_VAR 0 7
116284: PPUSH
116285: LD_VAR 0 15
116289: PPUSH
116290: CALL_OW 1
116294: ST_TO_ADDR
// continue ;
116295: GO 114840
// end ; end ; end else
116297: GO 118961
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
116299: LD_ADDR_VAR 0 14
116303: PUSH
116304: LD_INT 81
116306: PUSH
116307: LD_VAR 0 4
116311: PUSH
116312: LD_VAR 0 7
116316: ARRAY
116317: PPUSH
116318: CALL_OW 255
116322: PUSH
116323: EMPTY
116324: LIST
116325: LIST
116326: PPUSH
116327: CALL_OW 69
116331: ST_TO_ADDR
// if not tmp then
116332: LD_VAR 0 14
116336: NOT
116337: IFFALSE 116341
// continue ;
116339: GO 114840
// if f_ignore_area then
116341: LD_VAR 0 17
116345: IFFALSE 116433
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
116347: LD_ADDR_VAR 0 15
116351: PUSH
116352: LD_VAR 0 14
116356: PPUSH
116357: LD_INT 3
116359: PUSH
116360: LD_INT 92
116362: PUSH
116363: LD_VAR 0 17
116367: PUSH
116368: LD_INT 1
116370: ARRAY
116371: PUSH
116372: LD_VAR 0 17
116376: PUSH
116377: LD_INT 2
116379: ARRAY
116380: PUSH
116381: LD_VAR 0 17
116385: PUSH
116386: LD_INT 3
116388: ARRAY
116389: PUSH
116390: EMPTY
116391: LIST
116392: LIST
116393: LIST
116394: LIST
116395: PUSH
116396: EMPTY
116397: LIST
116398: LIST
116399: PPUSH
116400: CALL_OW 72
116404: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116405: LD_VAR 0 14
116409: PUSH
116410: LD_VAR 0 15
116414: DIFF
116415: IFFALSE 116433
// tmp := tmp diff tmp2 ;
116417: LD_ADDR_VAR 0 14
116421: PUSH
116422: LD_VAR 0 14
116426: PUSH
116427: LD_VAR 0 15
116431: DIFF
116432: ST_TO_ADDR
// end ; if not f_murder then
116433: LD_VAR 0 20
116437: NOT
116438: IFFALSE 116496
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
116440: LD_ADDR_VAR 0 15
116444: PUSH
116445: LD_VAR 0 14
116449: PPUSH
116450: LD_INT 3
116452: PUSH
116453: LD_INT 50
116455: PUSH
116456: EMPTY
116457: LIST
116458: PUSH
116459: EMPTY
116460: LIST
116461: LIST
116462: PPUSH
116463: CALL_OW 72
116467: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116468: LD_VAR 0 14
116472: PUSH
116473: LD_VAR 0 15
116477: DIFF
116478: IFFALSE 116496
// tmp := tmp diff tmp2 ;
116480: LD_ADDR_VAR 0 14
116484: PUSH
116485: LD_VAR 0 14
116489: PUSH
116490: LD_VAR 0 15
116494: DIFF
116495: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
116496: LD_ADDR_VAR 0 14
116500: PUSH
116501: LD_VAR 0 4
116505: PUSH
116506: LD_VAR 0 7
116510: ARRAY
116511: PPUSH
116512: LD_VAR 0 14
116516: PPUSH
116517: LD_INT 1
116519: PPUSH
116520: LD_INT 1
116522: PPUSH
116523: CALL 58245 0 4
116527: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
116528: LD_VAR 0 4
116532: PUSH
116533: LD_VAR 0 7
116537: ARRAY
116538: PPUSH
116539: CALL_OW 257
116543: PUSH
116544: LD_INT 1
116546: EQUAL
116547: IFFALSE 116995
// begin if WantPlant ( group [ i ] ) then
116549: LD_VAR 0 4
116553: PUSH
116554: LD_VAR 0 7
116558: ARRAY
116559: PPUSH
116560: CALL 57746 0 1
116564: IFFALSE 116568
// continue ;
116566: GO 114840
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
116568: LD_VAR 0 18
116572: PUSH
116573: LD_VAR 0 4
116577: PUSH
116578: LD_VAR 0 7
116582: ARRAY
116583: PPUSH
116584: CALL_OW 310
116588: NOT
116589: AND
116590: PUSH
116591: LD_VAR 0 14
116595: PUSH
116596: LD_INT 1
116598: ARRAY
116599: PUSH
116600: LD_VAR 0 14
116604: PPUSH
116605: LD_INT 21
116607: PUSH
116608: LD_INT 2
116610: PUSH
116611: EMPTY
116612: LIST
116613: LIST
116614: PUSH
116615: LD_INT 58
116617: PUSH
116618: EMPTY
116619: LIST
116620: PUSH
116621: EMPTY
116622: LIST
116623: LIST
116624: PPUSH
116625: CALL_OW 72
116629: IN
116630: AND
116631: IFFALSE 116667
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
116633: LD_VAR 0 4
116637: PUSH
116638: LD_VAR 0 7
116642: ARRAY
116643: PPUSH
116644: LD_VAR 0 14
116648: PUSH
116649: LD_INT 1
116651: ARRAY
116652: PPUSH
116653: CALL_OW 120
// attacking := true ;
116657: LD_ADDR_VAR 0 29
116661: PUSH
116662: LD_INT 1
116664: ST_TO_ADDR
// continue ;
116665: GO 114840
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
116667: LD_VAR 0 26
116671: PUSH
116672: LD_VAR 0 4
116676: PUSH
116677: LD_VAR 0 7
116681: ARRAY
116682: PPUSH
116683: CALL_OW 257
116687: PUSH
116688: LD_INT 1
116690: EQUAL
116691: AND
116692: PUSH
116693: LD_VAR 0 4
116697: PUSH
116698: LD_VAR 0 7
116702: ARRAY
116703: PPUSH
116704: CALL_OW 256
116708: PUSH
116709: LD_INT 800
116711: LESS
116712: AND
116713: PUSH
116714: LD_VAR 0 4
116718: PUSH
116719: LD_VAR 0 7
116723: ARRAY
116724: PPUSH
116725: CALL_OW 318
116729: NOT
116730: AND
116731: IFFALSE 116748
// ComCrawl ( group [ i ] ) ;
116733: LD_VAR 0 4
116737: PUSH
116738: LD_VAR 0 7
116742: ARRAY
116743: PPUSH
116744: CALL_OW 137
// if f_mines then
116748: LD_VAR 0 21
116752: IFFALSE 116995
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
116754: LD_VAR 0 14
116758: PUSH
116759: LD_INT 1
116761: ARRAY
116762: PPUSH
116763: CALL_OW 247
116767: PUSH
116768: LD_INT 3
116770: EQUAL
116771: PUSH
116772: LD_VAR 0 14
116776: PUSH
116777: LD_INT 1
116779: ARRAY
116780: PUSH
116781: LD_VAR 0 27
116785: IN
116786: NOT
116787: AND
116788: IFFALSE 116995
// begin x := GetX ( tmp [ 1 ] ) ;
116790: LD_ADDR_VAR 0 10
116794: PUSH
116795: LD_VAR 0 14
116799: PUSH
116800: LD_INT 1
116802: ARRAY
116803: PPUSH
116804: CALL_OW 250
116808: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
116809: LD_ADDR_VAR 0 11
116813: PUSH
116814: LD_VAR 0 14
116818: PUSH
116819: LD_INT 1
116821: ARRAY
116822: PPUSH
116823: CALL_OW 251
116827: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
116828: LD_ADDR_VAR 0 12
116832: PUSH
116833: LD_VAR 0 4
116837: PUSH
116838: LD_VAR 0 7
116842: ARRAY
116843: PPUSH
116844: CALL 85389 0 1
116848: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
116849: LD_VAR 0 4
116853: PUSH
116854: LD_VAR 0 7
116858: ARRAY
116859: PPUSH
116860: LD_VAR 0 10
116864: PPUSH
116865: LD_VAR 0 11
116869: PPUSH
116870: LD_VAR 0 14
116874: PUSH
116875: LD_INT 1
116877: ARRAY
116878: PPUSH
116879: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
116883: LD_VAR 0 4
116887: PUSH
116888: LD_VAR 0 7
116892: ARRAY
116893: PPUSH
116894: LD_VAR 0 10
116898: PPUSH
116899: LD_VAR 0 12
116903: PPUSH
116904: LD_INT 7
116906: PPUSH
116907: CALL_OW 272
116911: PPUSH
116912: LD_VAR 0 11
116916: PPUSH
116917: LD_VAR 0 12
116921: PPUSH
116922: LD_INT 7
116924: PPUSH
116925: CALL_OW 273
116929: PPUSH
116930: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
116934: LD_VAR 0 4
116938: PUSH
116939: LD_VAR 0 7
116943: ARRAY
116944: PPUSH
116945: LD_INT 71
116947: PPUSH
116948: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
116952: LD_ADDR_VAR 0 27
116956: PUSH
116957: LD_VAR 0 27
116961: PPUSH
116962: LD_VAR 0 27
116966: PUSH
116967: LD_INT 1
116969: PLUS
116970: PPUSH
116971: LD_VAR 0 14
116975: PUSH
116976: LD_INT 1
116978: ARRAY
116979: PPUSH
116980: CALL_OW 1
116984: ST_TO_ADDR
// attacking := true ;
116985: LD_ADDR_VAR 0 29
116989: PUSH
116990: LD_INT 1
116992: ST_TO_ADDR
// continue ;
116993: GO 114840
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
116995: LD_VAR 0 4
116999: PUSH
117000: LD_VAR 0 7
117004: ARRAY
117005: PPUSH
117006: CALL_OW 257
117010: PUSH
117011: LD_INT 17
117013: EQUAL
117014: PUSH
117015: LD_VAR 0 4
117019: PUSH
117020: LD_VAR 0 7
117024: ARRAY
117025: PPUSH
117026: CALL_OW 110
117030: PUSH
117031: LD_INT 71
117033: EQUAL
117034: NOT
117035: AND
117036: IFFALSE 117182
// begin attacking := false ;
117038: LD_ADDR_VAR 0 29
117042: PUSH
117043: LD_INT 0
117045: ST_TO_ADDR
// k := 5 ;
117046: LD_ADDR_VAR 0 9
117050: PUSH
117051: LD_INT 5
117053: ST_TO_ADDR
// if tmp < k then
117054: LD_VAR 0 14
117058: PUSH
117059: LD_VAR 0 9
117063: LESS
117064: IFFALSE 117076
// k := tmp ;
117066: LD_ADDR_VAR 0 9
117070: PUSH
117071: LD_VAR 0 14
117075: ST_TO_ADDR
// for j = 1 to k do
117076: LD_ADDR_VAR 0 8
117080: PUSH
117081: DOUBLE
117082: LD_INT 1
117084: DEC
117085: ST_TO_ADDR
117086: LD_VAR 0 9
117090: PUSH
117091: FOR_TO
117092: IFFALSE 117180
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
117094: LD_VAR 0 14
117098: PUSH
117099: LD_VAR 0 8
117103: ARRAY
117104: PUSH
117105: LD_VAR 0 14
117109: PPUSH
117110: LD_INT 58
117112: PUSH
117113: EMPTY
117114: LIST
117115: PPUSH
117116: CALL_OW 72
117120: IN
117121: NOT
117122: IFFALSE 117178
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117124: LD_VAR 0 4
117128: PUSH
117129: LD_VAR 0 7
117133: ARRAY
117134: PPUSH
117135: LD_VAR 0 14
117139: PUSH
117140: LD_VAR 0 8
117144: ARRAY
117145: PPUSH
117146: CALL_OW 115
// attacking := true ;
117150: LD_ADDR_VAR 0 29
117154: PUSH
117155: LD_INT 1
117157: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
117158: LD_VAR 0 4
117162: PUSH
117163: LD_VAR 0 7
117167: ARRAY
117168: PPUSH
117169: LD_INT 71
117171: PPUSH
117172: CALL_OW 109
// continue ;
117176: GO 117091
// end ; end ;
117178: GO 117091
117180: POP
117181: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
117182: LD_VAR 0 4
117186: PUSH
117187: LD_VAR 0 7
117191: ARRAY
117192: PPUSH
117193: CALL_OW 257
117197: PUSH
117198: LD_INT 8
117200: EQUAL
117201: PUSH
117202: LD_VAR 0 4
117206: PUSH
117207: LD_VAR 0 7
117211: ARRAY
117212: PPUSH
117213: CALL_OW 264
117217: PUSH
117218: LD_INT 28
117220: PUSH
117221: LD_INT 45
117223: PUSH
117224: LD_INT 7
117226: PUSH
117227: LD_INT 47
117229: PUSH
117230: EMPTY
117231: LIST
117232: LIST
117233: LIST
117234: LIST
117235: IN
117236: OR
117237: IFFALSE 117493
// begin attacking := false ;
117239: LD_ADDR_VAR 0 29
117243: PUSH
117244: LD_INT 0
117246: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
117247: LD_VAR 0 14
117251: PUSH
117252: LD_INT 1
117254: ARRAY
117255: PPUSH
117256: CALL_OW 266
117260: PUSH
117261: LD_INT 32
117263: PUSH
117264: LD_INT 31
117266: PUSH
117267: LD_INT 33
117269: PUSH
117270: LD_INT 4
117272: PUSH
117273: LD_INT 5
117275: PUSH
117276: EMPTY
117277: LIST
117278: LIST
117279: LIST
117280: LIST
117281: LIST
117282: IN
117283: IFFALSE 117469
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
117285: LD_ADDR_VAR 0 9
117289: PUSH
117290: LD_VAR 0 14
117294: PUSH
117295: LD_INT 1
117297: ARRAY
117298: PPUSH
117299: CALL_OW 266
117303: PPUSH
117304: LD_VAR 0 14
117308: PUSH
117309: LD_INT 1
117311: ARRAY
117312: PPUSH
117313: CALL_OW 250
117317: PPUSH
117318: LD_VAR 0 14
117322: PUSH
117323: LD_INT 1
117325: ARRAY
117326: PPUSH
117327: CALL_OW 251
117331: PPUSH
117332: LD_VAR 0 14
117336: PUSH
117337: LD_INT 1
117339: ARRAY
117340: PPUSH
117341: CALL_OW 254
117345: PPUSH
117346: LD_VAR 0 14
117350: PUSH
117351: LD_INT 1
117353: ARRAY
117354: PPUSH
117355: CALL_OW 248
117359: PPUSH
117360: LD_INT 0
117362: PPUSH
117363: CALL 66759 0 6
117367: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
117368: LD_ADDR_VAR 0 8
117372: PUSH
117373: LD_VAR 0 4
117377: PUSH
117378: LD_VAR 0 7
117382: ARRAY
117383: PPUSH
117384: LD_VAR 0 9
117388: PPUSH
117389: CALL 85502 0 2
117393: ST_TO_ADDR
// if j then
117394: LD_VAR 0 8
117398: IFFALSE 117467
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
117400: LD_VAR 0 8
117404: PUSH
117405: LD_INT 1
117407: ARRAY
117408: PPUSH
117409: LD_VAR 0 8
117413: PUSH
117414: LD_INT 2
117416: ARRAY
117417: PPUSH
117418: CALL_OW 488
117422: IFFALSE 117467
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
117424: LD_VAR 0 4
117428: PUSH
117429: LD_VAR 0 7
117433: ARRAY
117434: PPUSH
117435: LD_VAR 0 8
117439: PUSH
117440: LD_INT 1
117442: ARRAY
117443: PPUSH
117444: LD_VAR 0 8
117448: PUSH
117449: LD_INT 2
117451: ARRAY
117452: PPUSH
117453: CALL_OW 116
// attacking := true ;
117457: LD_ADDR_VAR 0 29
117461: PUSH
117462: LD_INT 1
117464: ST_TO_ADDR
// continue ;
117465: GO 114840
// end ; end else
117467: GO 117493
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117469: LD_VAR 0 4
117473: PUSH
117474: LD_VAR 0 7
117478: ARRAY
117479: PPUSH
117480: LD_VAR 0 14
117484: PUSH
117485: LD_INT 1
117487: ARRAY
117488: PPUSH
117489: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
117493: LD_VAR 0 4
117497: PUSH
117498: LD_VAR 0 7
117502: ARRAY
117503: PPUSH
117504: CALL_OW 265
117508: PUSH
117509: LD_INT 11
117511: EQUAL
117512: IFFALSE 117790
// begin k := 10 ;
117514: LD_ADDR_VAR 0 9
117518: PUSH
117519: LD_INT 10
117521: ST_TO_ADDR
// x := 0 ;
117522: LD_ADDR_VAR 0 10
117526: PUSH
117527: LD_INT 0
117529: ST_TO_ADDR
// if tmp < k then
117530: LD_VAR 0 14
117534: PUSH
117535: LD_VAR 0 9
117539: LESS
117540: IFFALSE 117552
// k := tmp ;
117542: LD_ADDR_VAR 0 9
117546: PUSH
117547: LD_VAR 0 14
117551: ST_TO_ADDR
// for j = k downto 1 do
117552: LD_ADDR_VAR 0 8
117556: PUSH
117557: DOUBLE
117558: LD_VAR 0 9
117562: INC
117563: ST_TO_ADDR
117564: LD_INT 1
117566: PUSH
117567: FOR_DOWNTO
117568: IFFALSE 117643
// begin if GetType ( tmp [ j ] ) = unit_human then
117570: LD_VAR 0 14
117574: PUSH
117575: LD_VAR 0 8
117579: ARRAY
117580: PPUSH
117581: CALL_OW 247
117585: PUSH
117586: LD_INT 1
117588: EQUAL
117589: IFFALSE 117641
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
117591: LD_VAR 0 4
117595: PUSH
117596: LD_VAR 0 7
117600: ARRAY
117601: PPUSH
117602: LD_VAR 0 14
117606: PUSH
117607: LD_VAR 0 8
117611: ARRAY
117612: PPUSH
117613: CALL 85756 0 2
// x := tmp [ j ] ;
117617: LD_ADDR_VAR 0 10
117621: PUSH
117622: LD_VAR 0 14
117626: PUSH
117627: LD_VAR 0 8
117631: ARRAY
117632: ST_TO_ADDR
// attacking := true ;
117633: LD_ADDR_VAR 0 29
117637: PUSH
117638: LD_INT 1
117640: ST_TO_ADDR
// end ; end ;
117641: GO 117567
117643: POP
117644: POP
// if not x then
117645: LD_VAR 0 10
117649: NOT
117650: IFFALSE 117790
// begin attacking := true ;
117652: LD_ADDR_VAR 0 29
117656: PUSH
117657: LD_INT 1
117659: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
117660: LD_VAR 0 4
117664: PUSH
117665: LD_VAR 0 7
117669: ARRAY
117670: PPUSH
117671: CALL_OW 250
117675: PPUSH
117676: LD_VAR 0 4
117680: PUSH
117681: LD_VAR 0 7
117685: ARRAY
117686: PPUSH
117687: CALL_OW 251
117691: PPUSH
117692: CALL_OW 546
117696: PUSH
117697: LD_INT 2
117699: ARRAY
117700: PUSH
117701: LD_VAR 0 14
117705: PUSH
117706: LD_INT 1
117708: ARRAY
117709: PPUSH
117710: CALL_OW 250
117714: PPUSH
117715: LD_VAR 0 14
117719: PUSH
117720: LD_INT 1
117722: ARRAY
117723: PPUSH
117724: CALL_OW 251
117728: PPUSH
117729: CALL_OW 546
117733: PUSH
117734: LD_INT 2
117736: ARRAY
117737: EQUAL
117738: IFFALSE 117766
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
117740: LD_VAR 0 4
117744: PUSH
117745: LD_VAR 0 7
117749: ARRAY
117750: PPUSH
117751: LD_VAR 0 14
117755: PUSH
117756: LD_INT 1
117758: ARRAY
117759: PPUSH
117760: CALL 85756 0 2
117764: GO 117790
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117766: LD_VAR 0 4
117770: PUSH
117771: LD_VAR 0 7
117775: ARRAY
117776: PPUSH
117777: LD_VAR 0 14
117781: PUSH
117782: LD_INT 1
117784: ARRAY
117785: PPUSH
117786: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
117790: LD_VAR 0 4
117794: PUSH
117795: LD_VAR 0 7
117799: ARRAY
117800: PPUSH
117801: CALL_OW 264
117805: PUSH
117806: LD_INT 29
117808: EQUAL
117809: IFFALSE 118175
// begin if WantsToAttack ( group [ i ] ) in bombed then
117811: LD_VAR 0 4
117815: PUSH
117816: LD_VAR 0 7
117820: ARRAY
117821: PPUSH
117822: CALL_OW 319
117826: PUSH
117827: LD_VAR 0 28
117831: IN
117832: IFFALSE 117836
// continue ;
117834: GO 114840
// k := 8 ;
117836: LD_ADDR_VAR 0 9
117840: PUSH
117841: LD_INT 8
117843: ST_TO_ADDR
// x := 0 ;
117844: LD_ADDR_VAR 0 10
117848: PUSH
117849: LD_INT 0
117851: ST_TO_ADDR
// if tmp < k then
117852: LD_VAR 0 14
117856: PUSH
117857: LD_VAR 0 9
117861: LESS
117862: IFFALSE 117874
// k := tmp ;
117864: LD_ADDR_VAR 0 9
117868: PUSH
117869: LD_VAR 0 14
117873: ST_TO_ADDR
// for j = 1 to k do
117874: LD_ADDR_VAR 0 8
117878: PUSH
117879: DOUBLE
117880: LD_INT 1
117882: DEC
117883: ST_TO_ADDR
117884: LD_VAR 0 9
117888: PUSH
117889: FOR_TO
117890: IFFALSE 118022
// begin if GetType ( tmp [ j ] ) = unit_building then
117892: LD_VAR 0 14
117896: PUSH
117897: LD_VAR 0 8
117901: ARRAY
117902: PPUSH
117903: CALL_OW 247
117907: PUSH
117908: LD_INT 3
117910: EQUAL
117911: IFFALSE 118020
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
117913: LD_VAR 0 14
117917: PUSH
117918: LD_VAR 0 8
117922: ARRAY
117923: PUSH
117924: LD_VAR 0 28
117928: IN
117929: NOT
117930: PUSH
117931: LD_VAR 0 14
117935: PUSH
117936: LD_VAR 0 8
117940: ARRAY
117941: PPUSH
117942: CALL_OW 313
117946: AND
117947: IFFALSE 118020
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117949: LD_VAR 0 4
117953: PUSH
117954: LD_VAR 0 7
117958: ARRAY
117959: PPUSH
117960: LD_VAR 0 14
117964: PUSH
117965: LD_VAR 0 8
117969: ARRAY
117970: PPUSH
117971: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
117975: LD_ADDR_VAR 0 28
117979: PUSH
117980: LD_VAR 0 28
117984: PPUSH
117985: LD_VAR 0 28
117989: PUSH
117990: LD_INT 1
117992: PLUS
117993: PPUSH
117994: LD_VAR 0 14
117998: PUSH
117999: LD_VAR 0 8
118003: ARRAY
118004: PPUSH
118005: CALL_OW 1
118009: ST_TO_ADDR
// attacking := true ;
118010: LD_ADDR_VAR 0 29
118014: PUSH
118015: LD_INT 1
118017: ST_TO_ADDR
// break ;
118018: GO 118022
// end ; end ;
118020: GO 117889
118022: POP
118023: POP
// if not attacking and f_attack_depot then
118024: LD_VAR 0 29
118028: NOT
118029: PUSH
118030: LD_VAR 0 25
118034: AND
118035: IFFALSE 118130
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118037: LD_ADDR_VAR 0 13
118041: PUSH
118042: LD_VAR 0 14
118046: PPUSH
118047: LD_INT 2
118049: PUSH
118050: LD_INT 30
118052: PUSH
118053: LD_INT 0
118055: PUSH
118056: EMPTY
118057: LIST
118058: LIST
118059: PUSH
118060: LD_INT 30
118062: PUSH
118063: LD_INT 1
118065: PUSH
118066: EMPTY
118067: LIST
118068: LIST
118069: PUSH
118070: EMPTY
118071: LIST
118072: LIST
118073: LIST
118074: PPUSH
118075: CALL_OW 72
118079: ST_TO_ADDR
// if z then
118080: LD_VAR 0 13
118084: IFFALSE 118130
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
118086: LD_VAR 0 4
118090: PUSH
118091: LD_VAR 0 7
118095: ARRAY
118096: PPUSH
118097: LD_VAR 0 13
118101: PPUSH
118102: LD_VAR 0 4
118106: PUSH
118107: LD_VAR 0 7
118111: ARRAY
118112: PPUSH
118113: CALL_OW 74
118117: PPUSH
118118: CALL_OW 115
// attacking := true ;
118122: LD_ADDR_VAR 0 29
118126: PUSH
118127: LD_INT 1
118129: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
118130: LD_VAR 0 4
118134: PUSH
118135: LD_VAR 0 7
118139: ARRAY
118140: PPUSH
118141: CALL_OW 256
118145: PUSH
118146: LD_INT 500
118148: LESS
118149: IFFALSE 118175
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118151: LD_VAR 0 4
118155: PUSH
118156: LD_VAR 0 7
118160: ARRAY
118161: PPUSH
118162: LD_VAR 0 14
118166: PUSH
118167: LD_INT 1
118169: ARRAY
118170: PPUSH
118171: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
118175: LD_VAR 0 4
118179: PUSH
118180: LD_VAR 0 7
118184: ARRAY
118185: PPUSH
118186: CALL_OW 264
118190: PUSH
118191: LD_INT 49
118193: EQUAL
118194: IFFALSE 118315
// begin if not HasTask ( group [ i ] ) then
118196: LD_VAR 0 4
118200: PUSH
118201: LD_VAR 0 7
118205: ARRAY
118206: PPUSH
118207: CALL_OW 314
118211: NOT
118212: IFFALSE 118315
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
118214: LD_ADDR_VAR 0 9
118218: PUSH
118219: LD_INT 81
118221: PUSH
118222: LD_VAR 0 4
118226: PUSH
118227: LD_VAR 0 7
118231: ARRAY
118232: PPUSH
118233: CALL_OW 255
118237: PUSH
118238: EMPTY
118239: LIST
118240: LIST
118241: PPUSH
118242: CALL_OW 69
118246: PPUSH
118247: LD_VAR 0 4
118251: PUSH
118252: LD_VAR 0 7
118256: ARRAY
118257: PPUSH
118258: CALL_OW 74
118262: ST_TO_ADDR
// if k then
118263: LD_VAR 0 9
118267: IFFALSE 118315
// if GetDistUnits ( group [ i ] , k ) > 10 then
118269: LD_VAR 0 4
118273: PUSH
118274: LD_VAR 0 7
118278: ARRAY
118279: PPUSH
118280: LD_VAR 0 9
118284: PPUSH
118285: CALL_OW 296
118289: PUSH
118290: LD_INT 10
118292: GREATER
118293: IFFALSE 118315
// ComMoveUnit ( group [ i ] , k ) ;
118295: LD_VAR 0 4
118299: PUSH
118300: LD_VAR 0 7
118304: ARRAY
118305: PPUSH
118306: LD_VAR 0 9
118310: PPUSH
118311: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
118315: LD_VAR 0 4
118319: PUSH
118320: LD_VAR 0 7
118324: ARRAY
118325: PPUSH
118326: CALL_OW 256
118330: PUSH
118331: LD_INT 250
118333: LESS
118334: PUSH
118335: LD_VAR 0 4
118339: PUSH
118340: LD_VAR 0 7
118344: ARRAY
118345: PUSH
118346: LD_INT 21
118348: PUSH
118349: LD_INT 2
118351: PUSH
118352: EMPTY
118353: LIST
118354: LIST
118355: PUSH
118356: LD_INT 23
118358: PUSH
118359: LD_INT 2
118361: PUSH
118362: EMPTY
118363: LIST
118364: LIST
118365: PUSH
118366: EMPTY
118367: LIST
118368: LIST
118369: PPUSH
118370: CALL_OW 69
118374: IN
118375: AND
118376: IFFALSE 118501
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
118378: LD_ADDR_VAR 0 9
118382: PUSH
118383: LD_OWVAR 3
118387: PUSH
118388: LD_VAR 0 4
118392: PUSH
118393: LD_VAR 0 7
118397: ARRAY
118398: DIFF
118399: PPUSH
118400: LD_VAR 0 4
118404: PUSH
118405: LD_VAR 0 7
118409: ARRAY
118410: PPUSH
118411: CALL_OW 74
118415: ST_TO_ADDR
// if not k then
118416: LD_VAR 0 9
118420: NOT
118421: IFFALSE 118425
// continue ;
118423: GO 114840
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
118425: LD_VAR 0 9
118429: PUSH
118430: LD_INT 81
118432: PUSH
118433: LD_VAR 0 4
118437: PUSH
118438: LD_VAR 0 7
118442: ARRAY
118443: PPUSH
118444: CALL_OW 255
118448: PUSH
118449: EMPTY
118450: LIST
118451: LIST
118452: PPUSH
118453: CALL_OW 69
118457: IN
118458: PUSH
118459: LD_VAR 0 9
118463: PPUSH
118464: LD_VAR 0 4
118468: PUSH
118469: LD_VAR 0 7
118473: ARRAY
118474: PPUSH
118475: CALL_OW 296
118479: PUSH
118480: LD_INT 5
118482: LESS
118483: AND
118484: IFFALSE 118501
// ComAutodestruct ( group [ i ] ) ;
118486: LD_VAR 0 4
118490: PUSH
118491: LD_VAR 0 7
118495: ARRAY
118496: PPUSH
118497: CALL 85654 0 1
// end ; if f_attack_depot then
118501: LD_VAR 0 25
118505: IFFALSE 118617
// begin k := 6 ;
118507: LD_ADDR_VAR 0 9
118511: PUSH
118512: LD_INT 6
118514: ST_TO_ADDR
// if tmp < k then
118515: LD_VAR 0 14
118519: PUSH
118520: LD_VAR 0 9
118524: LESS
118525: IFFALSE 118537
// k := tmp ;
118527: LD_ADDR_VAR 0 9
118531: PUSH
118532: LD_VAR 0 14
118536: ST_TO_ADDR
// for j = 1 to k do
118537: LD_ADDR_VAR 0 8
118541: PUSH
118542: DOUBLE
118543: LD_INT 1
118545: DEC
118546: ST_TO_ADDR
118547: LD_VAR 0 9
118551: PUSH
118552: FOR_TO
118553: IFFALSE 118615
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
118555: LD_VAR 0 8
118559: PPUSH
118560: CALL_OW 266
118564: PUSH
118565: LD_INT 0
118567: PUSH
118568: LD_INT 1
118570: PUSH
118571: EMPTY
118572: LIST
118573: LIST
118574: IN
118575: IFFALSE 118613
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118577: LD_VAR 0 4
118581: PUSH
118582: LD_VAR 0 7
118586: ARRAY
118587: PPUSH
118588: LD_VAR 0 14
118592: PUSH
118593: LD_VAR 0 8
118597: ARRAY
118598: PPUSH
118599: CALL_OW 115
// attacking := true ;
118603: LD_ADDR_VAR 0 29
118607: PUSH
118608: LD_INT 1
118610: ST_TO_ADDR
// break ;
118611: GO 118615
// end ;
118613: GO 118552
118615: POP
118616: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
118617: LD_VAR 0 4
118621: PUSH
118622: LD_VAR 0 7
118626: ARRAY
118627: PPUSH
118628: CALL_OW 302
118632: PUSH
118633: LD_VAR 0 29
118637: NOT
118638: AND
118639: IFFALSE 118961
// begin if GetTag ( group [ i ] ) = 71 then
118641: LD_VAR 0 4
118645: PUSH
118646: LD_VAR 0 7
118650: ARRAY
118651: PPUSH
118652: CALL_OW 110
118656: PUSH
118657: LD_INT 71
118659: EQUAL
118660: IFFALSE 118701
// begin if HasTask ( group [ i ] ) then
118662: LD_VAR 0 4
118666: PUSH
118667: LD_VAR 0 7
118671: ARRAY
118672: PPUSH
118673: CALL_OW 314
118677: IFFALSE 118683
// continue else
118679: GO 114840
118681: GO 118701
// SetTag ( group [ i ] , 0 ) ;
118683: LD_VAR 0 4
118687: PUSH
118688: LD_VAR 0 7
118692: ARRAY
118693: PPUSH
118694: LD_INT 0
118696: PPUSH
118697: CALL_OW 109
// end ; k := 8 ;
118701: LD_ADDR_VAR 0 9
118705: PUSH
118706: LD_INT 8
118708: ST_TO_ADDR
// x := 0 ;
118709: LD_ADDR_VAR 0 10
118713: PUSH
118714: LD_INT 0
118716: ST_TO_ADDR
// if tmp < k then
118717: LD_VAR 0 14
118721: PUSH
118722: LD_VAR 0 9
118726: LESS
118727: IFFALSE 118739
// k := tmp ;
118729: LD_ADDR_VAR 0 9
118733: PUSH
118734: LD_VAR 0 14
118738: ST_TO_ADDR
// for j = 1 to k do
118739: LD_ADDR_VAR 0 8
118743: PUSH
118744: DOUBLE
118745: LD_INT 1
118747: DEC
118748: ST_TO_ADDR
118749: LD_VAR 0 9
118753: PUSH
118754: FOR_TO
118755: IFFALSE 118853
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
118757: LD_VAR 0 14
118761: PUSH
118762: LD_VAR 0 8
118766: ARRAY
118767: PPUSH
118768: CALL_OW 247
118772: PUSH
118773: LD_INT 1
118775: EQUAL
118776: PUSH
118777: LD_VAR 0 14
118781: PUSH
118782: LD_VAR 0 8
118786: ARRAY
118787: PPUSH
118788: CALL_OW 256
118792: PUSH
118793: LD_INT 250
118795: LESS
118796: PUSH
118797: LD_VAR 0 20
118801: AND
118802: PUSH
118803: LD_VAR 0 20
118807: NOT
118808: PUSH
118809: LD_VAR 0 14
118813: PUSH
118814: LD_VAR 0 8
118818: ARRAY
118819: PPUSH
118820: CALL_OW 256
118824: PUSH
118825: LD_INT 250
118827: GREATEREQUAL
118828: AND
118829: OR
118830: AND
118831: IFFALSE 118851
// begin x := tmp [ j ] ;
118833: LD_ADDR_VAR 0 10
118837: PUSH
118838: LD_VAR 0 14
118842: PUSH
118843: LD_VAR 0 8
118847: ARRAY
118848: ST_TO_ADDR
// break ;
118849: GO 118853
// end ;
118851: GO 118754
118853: POP
118854: POP
// if x then
118855: LD_VAR 0 10
118859: IFFALSE 118883
// ComAttackUnit ( group [ i ] , x ) else
118861: LD_VAR 0 4
118865: PUSH
118866: LD_VAR 0 7
118870: ARRAY
118871: PPUSH
118872: LD_VAR 0 10
118876: PPUSH
118877: CALL_OW 115
118881: GO 118907
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118883: LD_VAR 0 4
118887: PUSH
118888: LD_VAR 0 7
118892: ARRAY
118893: PPUSH
118894: LD_VAR 0 14
118898: PUSH
118899: LD_INT 1
118901: ARRAY
118902: PPUSH
118903: CALL_OW 115
// if not HasTask ( group [ i ] ) then
118907: LD_VAR 0 4
118911: PUSH
118912: LD_VAR 0 7
118916: ARRAY
118917: PPUSH
118918: CALL_OW 314
118922: NOT
118923: IFFALSE 118961
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
118925: LD_VAR 0 4
118929: PUSH
118930: LD_VAR 0 7
118934: ARRAY
118935: PPUSH
118936: LD_VAR 0 14
118940: PPUSH
118941: LD_VAR 0 4
118945: PUSH
118946: LD_VAR 0 7
118950: ARRAY
118951: PPUSH
118952: CALL_OW 74
118956: PPUSH
118957: CALL_OW 115
// end ; end ; end ;
118961: GO 114840
118963: POP
118964: POP
// wait ( 0 0$2 ) ;
118965: LD_INT 70
118967: PPUSH
118968: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
118972: LD_VAR 0 4
118976: NOT
118977: PUSH
118978: LD_VAR 0 4
118982: PUSH
118983: EMPTY
118984: EQUAL
118985: OR
118986: PUSH
118987: LD_INT 81
118989: PUSH
118990: LD_VAR 0 35
118994: PUSH
118995: EMPTY
118996: LIST
118997: LIST
118998: PPUSH
118999: CALL_OW 69
119003: NOT
119004: OR
119005: IFFALSE 114825
// end ;
119007: LD_VAR 0 2
119011: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
119012: LD_INT 0
119014: PPUSH
119015: PPUSH
119016: PPUSH
119017: PPUSH
119018: PPUSH
119019: PPUSH
// if not base or not mc_bases [ base ] or not solds then
119020: LD_VAR 0 1
119024: NOT
119025: PUSH
119026: LD_EXP 78
119030: PUSH
119031: LD_VAR 0 1
119035: ARRAY
119036: NOT
119037: OR
119038: PUSH
119039: LD_VAR 0 2
119043: NOT
119044: OR
119045: IFFALSE 119049
// exit ;
119047: GO 119603
// side := mc_sides [ base ] ;
119049: LD_ADDR_VAR 0 6
119053: PUSH
119054: LD_EXP 104
119058: PUSH
119059: LD_VAR 0 1
119063: ARRAY
119064: ST_TO_ADDR
// if not side then
119065: LD_VAR 0 6
119069: NOT
119070: IFFALSE 119074
// exit ;
119072: GO 119603
// for i in solds do
119074: LD_ADDR_VAR 0 7
119078: PUSH
119079: LD_VAR 0 2
119083: PUSH
119084: FOR_IN
119085: IFFALSE 119146
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
119087: LD_VAR 0 7
119091: PPUSH
119092: CALL_OW 310
119096: PPUSH
119097: CALL_OW 266
119101: PUSH
119102: LD_INT 32
119104: PUSH
119105: LD_INT 31
119107: PUSH
119108: EMPTY
119109: LIST
119110: LIST
119111: IN
119112: IFFALSE 119132
// solds := solds diff i else
119114: LD_ADDR_VAR 0 2
119118: PUSH
119119: LD_VAR 0 2
119123: PUSH
119124: LD_VAR 0 7
119128: DIFF
119129: ST_TO_ADDR
119130: GO 119144
// SetTag ( i , 18 ) ;
119132: LD_VAR 0 7
119136: PPUSH
119137: LD_INT 18
119139: PPUSH
119140: CALL_OW 109
119144: GO 119084
119146: POP
119147: POP
// if not solds then
119148: LD_VAR 0 2
119152: NOT
119153: IFFALSE 119157
// exit ;
119155: GO 119603
// repeat wait ( 0 0$2 ) ;
119157: LD_INT 70
119159: PPUSH
119160: CALL_OW 67
// enemy := mc_scan [ base ] ;
119164: LD_ADDR_VAR 0 4
119168: PUSH
119169: LD_EXP 101
119173: PUSH
119174: LD_VAR 0 1
119178: ARRAY
119179: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119180: LD_EXP 78
119184: PUSH
119185: LD_VAR 0 1
119189: ARRAY
119190: NOT
119191: PUSH
119192: LD_EXP 78
119196: PUSH
119197: LD_VAR 0 1
119201: ARRAY
119202: PUSH
119203: EMPTY
119204: EQUAL
119205: OR
119206: IFFALSE 119243
// begin for i in solds do
119208: LD_ADDR_VAR 0 7
119212: PUSH
119213: LD_VAR 0 2
119217: PUSH
119218: FOR_IN
119219: IFFALSE 119232
// ComStop ( i ) ;
119221: LD_VAR 0 7
119225: PPUSH
119226: CALL_OW 141
119230: GO 119218
119232: POP
119233: POP
// solds := [ ] ;
119234: LD_ADDR_VAR 0 2
119238: PUSH
119239: EMPTY
119240: ST_TO_ADDR
// exit ;
119241: GO 119603
// end ; for i in solds do
119243: LD_ADDR_VAR 0 7
119247: PUSH
119248: LD_VAR 0 2
119252: PUSH
119253: FOR_IN
119254: IFFALSE 119575
// begin if IsInUnit ( i ) then
119256: LD_VAR 0 7
119260: PPUSH
119261: CALL_OW 310
119265: IFFALSE 119276
// ComExitBuilding ( i ) ;
119267: LD_VAR 0 7
119271: PPUSH
119272: CALL_OW 122
// if GetLives ( i ) > 500 then
119276: LD_VAR 0 7
119280: PPUSH
119281: CALL_OW 256
119285: PUSH
119286: LD_INT 500
119288: GREATER
119289: IFFALSE 119342
// begin e := NearestUnitToUnit ( enemy , i ) ;
119291: LD_ADDR_VAR 0 5
119295: PUSH
119296: LD_VAR 0 4
119300: PPUSH
119301: LD_VAR 0 7
119305: PPUSH
119306: CALL_OW 74
119310: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
119311: LD_VAR 0 7
119315: PPUSH
119316: LD_VAR 0 5
119320: PPUSH
119321: CALL_OW 250
119325: PPUSH
119326: LD_VAR 0 5
119330: PPUSH
119331: CALL_OW 251
119335: PPUSH
119336: CALL_OW 114
// end else
119340: GO 119573
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
119342: LD_VAR 0 7
119346: PPUSH
119347: LD_EXP 78
119351: PUSH
119352: LD_VAR 0 1
119356: ARRAY
119357: PPUSH
119358: LD_INT 2
119360: PUSH
119361: LD_INT 30
119363: PUSH
119364: LD_INT 0
119366: PUSH
119367: EMPTY
119368: LIST
119369: LIST
119370: PUSH
119371: LD_INT 30
119373: PUSH
119374: LD_INT 1
119376: PUSH
119377: EMPTY
119378: LIST
119379: LIST
119380: PUSH
119381: LD_INT 30
119383: PUSH
119384: LD_INT 6
119386: PUSH
119387: EMPTY
119388: LIST
119389: LIST
119390: PUSH
119391: EMPTY
119392: LIST
119393: LIST
119394: LIST
119395: LIST
119396: PPUSH
119397: CALL_OW 72
119401: PPUSH
119402: LD_VAR 0 7
119406: PPUSH
119407: CALL_OW 74
119411: PPUSH
119412: CALL_OW 296
119416: PUSH
119417: LD_INT 10
119419: GREATER
119420: IFFALSE 119573
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
119422: LD_ADDR_VAR 0 8
119426: PUSH
119427: LD_EXP 78
119431: PUSH
119432: LD_VAR 0 1
119436: ARRAY
119437: PPUSH
119438: LD_INT 2
119440: PUSH
119441: LD_INT 30
119443: PUSH
119444: LD_INT 0
119446: PUSH
119447: EMPTY
119448: LIST
119449: LIST
119450: PUSH
119451: LD_INT 30
119453: PUSH
119454: LD_INT 1
119456: PUSH
119457: EMPTY
119458: LIST
119459: LIST
119460: PUSH
119461: LD_INT 30
119463: PUSH
119464: LD_INT 6
119466: PUSH
119467: EMPTY
119468: LIST
119469: LIST
119470: PUSH
119471: EMPTY
119472: LIST
119473: LIST
119474: LIST
119475: LIST
119476: PPUSH
119477: CALL_OW 72
119481: PPUSH
119482: LD_VAR 0 7
119486: PPUSH
119487: CALL_OW 74
119491: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
119492: LD_VAR 0 7
119496: PPUSH
119497: LD_VAR 0 8
119501: PPUSH
119502: CALL_OW 250
119506: PPUSH
119507: LD_INT 3
119509: PPUSH
119510: LD_INT 5
119512: PPUSH
119513: CALL_OW 272
119517: PPUSH
119518: LD_VAR 0 8
119522: PPUSH
119523: CALL_OW 251
119527: PPUSH
119528: LD_INT 3
119530: PPUSH
119531: LD_INT 5
119533: PPUSH
119534: CALL_OW 273
119538: PPUSH
119539: CALL_OW 111
// SetTag ( i , 0 ) ;
119543: LD_VAR 0 7
119547: PPUSH
119548: LD_INT 0
119550: PPUSH
119551: CALL_OW 109
// solds := solds diff i ;
119555: LD_ADDR_VAR 0 2
119559: PUSH
119560: LD_VAR 0 2
119564: PUSH
119565: LD_VAR 0 7
119569: DIFF
119570: ST_TO_ADDR
// continue ;
119571: GO 119253
// end ; end ;
119573: GO 119253
119575: POP
119576: POP
// until not solds or not enemy ;
119577: LD_VAR 0 2
119581: NOT
119582: PUSH
119583: LD_VAR 0 4
119587: NOT
119588: OR
119589: IFFALSE 119157
// MC_Reset ( base , 18 ) ;
119591: LD_VAR 0 1
119595: PPUSH
119596: LD_INT 18
119598: PPUSH
119599: CALL 26323 0 2
// end ;
119603: LD_VAR 0 3
119607: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
119608: LD_INT 0
119610: PPUSH
119611: PPUSH
119612: PPUSH
119613: PPUSH
119614: PPUSH
119615: PPUSH
119616: PPUSH
119617: PPUSH
119618: PPUSH
119619: PPUSH
119620: PPUSH
119621: PPUSH
119622: PPUSH
119623: PPUSH
119624: PPUSH
119625: PPUSH
119626: PPUSH
119627: PPUSH
119628: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
119629: LD_ADDR_VAR 0 12
119633: PUSH
119634: LD_EXP 78
119638: PUSH
119639: LD_VAR 0 1
119643: ARRAY
119644: PPUSH
119645: LD_INT 25
119647: PUSH
119648: LD_INT 3
119650: PUSH
119651: EMPTY
119652: LIST
119653: LIST
119654: PPUSH
119655: CALL_OW 72
119659: ST_TO_ADDR
// if mc_remote_driver [ base ] then
119660: LD_EXP 118
119664: PUSH
119665: LD_VAR 0 1
119669: ARRAY
119670: IFFALSE 119694
// mechs := mechs diff mc_remote_driver [ base ] ;
119672: LD_ADDR_VAR 0 12
119676: PUSH
119677: LD_VAR 0 12
119681: PUSH
119682: LD_EXP 118
119686: PUSH
119687: LD_VAR 0 1
119691: ARRAY
119692: DIFF
119693: ST_TO_ADDR
// for i in mechs do
119694: LD_ADDR_VAR 0 4
119698: PUSH
119699: LD_VAR 0 12
119703: PUSH
119704: FOR_IN
119705: IFFALSE 119740
// if GetTag ( i ) > 0 then
119707: LD_VAR 0 4
119711: PPUSH
119712: CALL_OW 110
119716: PUSH
119717: LD_INT 0
119719: GREATER
119720: IFFALSE 119738
// mechs := mechs diff i ;
119722: LD_ADDR_VAR 0 12
119726: PUSH
119727: LD_VAR 0 12
119731: PUSH
119732: LD_VAR 0 4
119736: DIFF
119737: ST_TO_ADDR
119738: GO 119704
119740: POP
119741: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119742: LD_ADDR_VAR 0 8
119746: PUSH
119747: LD_EXP 78
119751: PUSH
119752: LD_VAR 0 1
119756: ARRAY
119757: PPUSH
119758: LD_INT 2
119760: PUSH
119761: LD_INT 25
119763: PUSH
119764: LD_INT 1
119766: PUSH
119767: EMPTY
119768: LIST
119769: LIST
119770: PUSH
119771: LD_INT 25
119773: PUSH
119774: LD_INT 5
119776: PUSH
119777: EMPTY
119778: LIST
119779: LIST
119780: PUSH
119781: LD_INT 25
119783: PUSH
119784: LD_INT 8
119786: PUSH
119787: EMPTY
119788: LIST
119789: LIST
119790: PUSH
119791: LD_INT 25
119793: PUSH
119794: LD_INT 9
119796: PUSH
119797: EMPTY
119798: LIST
119799: LIST
119800: PUSH
119801: EMPTY
119802: LIST
119803: LIST
119804: LIST
119805: LIST
119806: LIST
119807: PPUSH
119808: CALL_OW 72
119812: ST_TO_ADDR
// if not defenders and not solds then
119813: LD_VAR 0 2
119817: NOT
119818: PUSH
119819: LD_VAR 0 8
119823: NOT
119824: AND
119825: IFFALSE 119829
// exit ;
119827: GO 121599
// depot_under_attack := false ;
119829: LD_ADDR_VAR 0 16
119833: PUSH
119834: LD_INT 0
119836: ST_TO_ADDR
// sold_defenders := [ ] ;
119837: LD_ADDR_VAR 0 17
119841: PUSH
119842: EMPTY
119843: ST_TO_ADDR
// if mechs then
119844: LD_VAR 0 12
119848: IFFALSE 120001
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
119850: LD_ADDR_VAR 0 4
119854: PUSH
119855: LD_VAR 0 2
119859: PPUSH
119860: LD_INT 21
119862: PUSH
119863: LD_INT 2
119865: PUSH
119866: EMPTY
119867: LIST
119868: LIST
119869: PPUSH
119870: CALL_OW 72
119874: PUSH
119875: FOR_IN
119876: IFFALSE 119999
// begin if GetTag ( i ) <> 20 then
119878: LD_VAR 0 4
119882: PPUSH
119883: CALL_OW 110
119887: PUSH
119888: LD_INT 20
119890: NONEQUAL
119891: IFFALSE 119905
// SetTag ( i , 20 ) ;
119893: LD_VAR 0 4
119897: PPUSH
119898: LD_INT 20
119900: PPUSH
119901: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
119905: LD_VAR 0 4
119909: PPUSH
119910: CALL_OW 263
119914: PUSH
119915: LD_INT 1
119917: EQUAL
119918: PUSH
119919: LD_VAR 0 4
119923: PPUSH
119924: CALL_OW 311
119928: NOT
119929: AND
119930: IFFALSE 119997
// begin un := mechs [ 1 ] ;
119932: LD_ADDR_VAR 0 10
119936: PUSH
119937: LD_VAR 0 12
119941: PUSH
119942: LD_INT 1
119944: ARRAY
119945: ST_TO_ADDR
// ComExit ( un ) ;
119946: LD_VAR 0 10
119950: PPUSH
119951: CALL 90538 0 1
// AddComEnterUnit ( un , i ) ;
119955: LD_VAR 0 10
119959: PPUSH
119960: LD_VAR 0 4
119964: PPUSH
119965: CALL_OW 180
// SetTag ( un , 19 ) ;
119969: LD_VAR 0 10
119973: PPUSH
119974: LD_INT 19
119976: PPUSH
119977: CALL_OW 109
// mechs := mechs diff un ;
119981: LD_ADDR_VAR 0 12
119985: PUSH
119986: LD_VAR 0 12
119990: PUSH
119991: LD_VAR 0 10
119995: DIFF
119996: ST_TO_ADDR
// end ; end ;
119997: GO 119875
119999: POP
120000: POP
// if solds then
120001: LD_VAR 0 8
120005: IFFALSE 120064
// for i in solds do
120007: LD_ADDR_VAR 0 4
120011: PUSH
120012: LD_VAR 0 8
120016: PUSH
120017: FOR_IN
120018: IFFALSE 120062
// if not GetTag ( i ) then
120020: LD_VAR 0 4
120024: PPUSH
120025: CALL_OW 110
120029: NOT
120030: IFFALSE 120060
// begin defenders := defenders union i ;
120032: LD_ADDR_VAR 0 2
120036: PUSH
120037: LD_VAR 0 2
120041: PUSH
120042: LD_VAR 0 4
120046: UNION
120047: ST_TO_ADDR
// SetTag ( i , 18 ) ;
120048: LD_VAR 0 4
120052: PPUSH
120053: LD_INT 18
120055: PPUSH
120056: CALL_OW 109
// end ;
120060: GO 120017
120062: POP
120063: POP
// repeat wait ( 0 0$2 ) ;
120064: LD_INT 70
120066: PPUSH
120067: CALL_OW 67
// enemy := mc_scan [ base ] ;
120071: LD_ADDR_VAR 0 21
120075: PUSH
120076: LD_EXP 101
120080: PUSH
120081: LD_VAR 0 1
120085: ARRAY
120086: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120087: LD_EXP 78
120091: PUSH
120092: LD_VAR 0 1
120096: ARRAY
120097: NOT
120098: PUSH
120099: LD_EXP 78
120103: PUSH
120104: LD_VAR 0 1
120108: ARRAY
120109: PUSH
120110: EMPTY
120111: EQUAL
120112: OR
120113: IFFALSE 120150
// begin for i in defenders do
120115: LD_ADDR_VAR 0 4
120119: PUSH
120120: LD_VAR 0 2
120124: PUSH
120125: FOR_IN
120126: IFFALSE 120139
// ComStop ( i ) ;
120128: LD_VAR 0 4
120132: PPUSH
120133: CALL_OW 141
120137: GO 120125
120139: POP
120140: POP
// defenders := [ ] ;
120141: LD_ADDR_VAR 0 2
120145: PUSH
120146: EMPTY
120147: ST_TO_ADDR
// exit ;
120148: GO 121599
// end ; for i in defenders do
120150: LD_ADDR_VAR 0 4
120154: PUSH
120155: LD_VAR 0 2
120159: PUSH
120160: FOR_IN
120161: IFFALSE 121059
// begin e := NearestUnitToUnit ( enemy , i ) ;
120163: LD_ADDR_VAR 0 13
120167: PUSH
120168: LD_VAR 0 21
120172: PPUSH
120173: LD_VAR 0 4
120177: PPUSH
120178: CALL_OW 74
120182: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120183: LD_ADDR_VAR 0 7
120187: PUSH
120188: LD_EXP 78
120192: PUSH
120193: LD_VAR 0 1
120197: ARRAY
120198: PPUSH
120199: LD_INT 2
120201: PUSH
120202: LD_INT 30
120204: PUSH
120205: LD_INT 0
120207: PUSH
120208: EMPTY
120209: LIST
120210: LIST
120211: PUSH
120212: LD_INT 30
120214: PUSH
120215: LD_INT 1
120217: PUSH
120218: EMPTY
120219: LIST
120220: LIST
120221: PUSH
120222: EMPTY
120223: LIST
120224: LIST
120225: LIST
120226: PPUSH
120227: CALL_OW 72
120231: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
120232: LD_ADDR_VAR 0 16
120236: PUSH
120237: LD_VAR 0 7
120241: NOT
120242: PUSH
120243: LD_VAR 0 7
120247: PPUSH
120248: LD_INT 3
120250: PUSH
120251: LD_INT 24
120253: PUSH
120254: LD_INT 600
120256: PUSH
120257: EMPTY
120258: LIST
120259: LIST
120260: PUSH
120261: EMPTY
120262: LIST
120263: LIST
120264: PPUSH
120265: CALL_OW 72
120269: OR
120270: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
120271: LD_VAR 0 4
120275: PPUSH
120276: CALL_OW 247
120280: PUSH
120281: LD_INT 2
120283: DOUBLE
120284: EQUAL
120285: IFTRUE 120289
120287: GO 120685
120289: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
120290: LD_VAR 0 4
120294: PPUSH
120295: CALL_OW 256
120299: PUSH
120300: LD_INT 1000
120302: EQUAL
120303: PUSH
120304: LD_VAR 0 4
120308: PPUSH
120309: LD_VAR 0 13
120313: PPUSH
120314: CALL_OW 296
120318: PUSH
120319: LD_INT 40
120321: LESS
120322: PUSH
120323: LD_VAR 0 13
120327: PPUSH
120328: LD_EXP 103
120332: PUSH
120333: LD_VAR 0 1
120337: ARRAY
120338: PPUSH
120339: CALL_OW 308
120343: OR
120344: AND
120345: IFFALSE 120467
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
120347: LD_VAR 0 4
120351: PPUSH
120352: CALL_OW 262
120356: PUSH
120357: LD_INT 1
120359: EQUAL
120360: PUSH
120361: LD_VAR 0 4
120365: PPUSH
120366: CALL_OW 261
120370: PUSH
120371: LD_INT 30
120373: LESS
120374: AND
120375: PUSH
120376: LD_VAR 0 7
120380: AND
120381: IFFALSE 120451
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
120383: LD_VAR 0 4
120387: PPUSH
120388: LD_VAR 0 7
120392: PPUSH
120393: LD_VAR 0 4
120397: PPUSH
120398: CALL_OW 74
120402: PPUSH
120403: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
120407: LD_VAR 0 4
120411: PPUSH
120412: LD_VAR 0 7
120416: PPUSH
120417: LD_VAR 0 4
120421: PPUSH
120422: CALL_OW 74
120426: PPUSH
120427: CALL_OW 296
120431: PUSH
120432: LD_INT 6
120434: LESS
120435: IFFALSE 120449
// SetFuel ( i , 100 ) ;
120437: LD_VAR 0 4
120441: PPUSH
120442: LD_INT 100
120444: PPUSH
120445: CALL_OW 240
// end else
120449: GO 120465
// ComAttackUnit ( i , e ) ;
120451: LD_VAR 0 4
120455: PPUSH
120456: LD_VAR 0 13
120460: PPUSH
120461: CALL_OW 115
// end else
120465: GO 120568
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
120467: LD_VAR 0 13
120471: PPUSH
120472: LD_EXP 103
120476: PUSH
120477: LD_VAR 0 1
120481: ARRAY
120482: PPUSH
120483: CALL_OW 308
120487: NOT
120488: PUSH
120489: LD_VAR 0 4
120493: PPUSH
120494: LD_VAR 0 13
120498: PPUSH
120499: CALL_OW 296
120503: PUSH
120504: LD_INT 40
120506: GREATEREQUAL
120507: AND
120508: PUSH
120509: LD_VAR 0 4
120513: PPUSH
120514: CALL_OW 256
120518: PUSH
120519: LD_INT 650
120521: LESSEQUAL
120522: OR
120523: PUSH
120524: LD_VAR 0 4
120528: PPUSH
120529: LD_EXP 102
120533: PUSH
120534: LD_VAR 0 1
120538: ARRAY
120539: PPUSH
120540: CALL_OW 308
120544: NOT
120545: AND
120546: IFFALSE 120568
// ComMoveToArea ( i , mc_parking [ base ] ) ;
120548: LD_VAR 0 4
120552: PPUSH
120553: LD_EXP 102
120557: PUSH
120558: LD_VAR 0 1
120562: ARRAY
120563: PPUSH
120564: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
120568: LD_VAR 0 4
120572: PPUSH
120573: CALL_OW 256
120577: PUSH
120578: LD_INT 1000
120580: LESS
120581: PUSH
120582: LD_VAR 0 4
120586: PPUSH
120587: CALL_OW 263
120591: PUSH
120592: LD_INT 1
120594: EQUAL
120595: AND
120596: PUSH
120597: LD_VAR 0 4
120601: PPUSH
120602: CALL_OW 311
120606: AND
120607: PUSH
120608: LD_VAR 0 4
120612: PPUSH
120613: LD_EXP 102
120617: PUSH
120618: LD_VAR 0 1
120622: ARRAY
120623: PPUSH
120624: CALL_OW 308
120628: AND
120629: IFFALSE 120683
// begin mech := IsDrivenBy ( i ) ;
120631: LD_ADDR_VAR 0 9
120635: PUSH
120636: LD_VAR 0 4
120640: PPUSH
120641: CALL_OW 311
120645: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
120646: LD_VAR 0 9
120650: PPUSH
120651: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
120655: LD_VAR 0 9
120659: PPUSH
120660: LD_VAR 0 4
120664: PPUSH
120665: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
120669: LD_VAR 0 9
120673: PPUSH
120674: LD_VAR 0 4
120678: PPUSH
120679: CALL_OW 180
// end ; end ; unit_human :
120683: GO 121030
120685: LD_INT 1
120687: DOUBLE
120688: EQUAL
120689: IFTRUE 120693
120691: GO 121029
120693: POP
// begin b := IsInUnit ( i ) ;
120694: LD_ADDR_VAR 0 18
120698: PUSH
120699: LD_VAR 0 4
120703: PPUSH
120704: CALL_OW 310
120708: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
120709: LD_ADDR_VAR 0 19
120713: PUSH
120714: LD_VAR 0 18
120718: NOT
120719: PUSH
120720: LD_VAR 0 18
120724: PPUSH
120725: CALL_OW 266
120729: PUSH
120730: LD_INT 32
120732: PUSH
120733: LD_INT 31
120735: PUSH
120736: EMPTY
120737: LIST
120738: LIST
120739: IN
120740: OR
120741: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
120742: LD_VAR 0 18
120746: PPUSH
120747: CALL_OW 266
120751: PUSH
120752: LD_INT 5
120754: EQUAL
120755: PUSH
120756: LD_VAR 0 4
120760: PPUSH
120761: CALL_OW 257
120765: PUSH
120766: LD_INT 1
120768: PUSH
120769: LD_INT 2
120771: PUSH
120772: LD_INT 3
120774: PUSH
120775: LD_INT 4
120777: PUSH
120778: EMPTY
120779: LIST
120780: LIST
120781: LIST
120782: LIST
120783: IN
120784: AND
120785: IFFALSE 120822
// begin class := AllowSpecClass ( i ) ;
120787: LD_ADDR_VAR 0 20
120791: PUSH
120792: LD_VAR 0 4
120796: PPUSH
120797: CALL 54634 0 1
120801: ST_TO_ADDR
// if class then
120802: LD_VAR 0 20
120806: IFFALSE 120822
// ComChangeProfession ( i , class ) ;
120808: LD_VAR 0 4
120812: PPUSH
120813: LD_VAR 0 20
120817: PPUSH
120818: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
120822: LD_VAR 0 16
120826: PUSH
120827: LD_VAR 0 2
120831: PPUSH
120832: LD_INT 21
120834: PUSH
120835: LD_INT 2
120837: PUSH
120838: EMPTY
120839: LIST
120840: LIST
120841: PPUSH
120842: CALL_OW 72
120846: PUSH
120847: LD_INT 1
120849: LESSEQUAL
120850: OR
120851: PUSH
120852: LD_VAR 0 19
120856: AND
120857: PUSH
120858: LD_VAR 0 4
120862: PUSH
120863: LD_VAR 0 17
120867: IN
120868: NOT
120869: AND
120870: IFFALSE 120963
// begin if b then
120872: LD_VAR 0 18
120876: IFFALSE 120925
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
120878: LD_VAR 0 18
120882: PPUSH
120883: LD_VAR 0 21
120887: PPUSH
120888: LD_VAR 0 18
120892: PPUSH
120893: CALL_OW 74
120897: PPUSH
120898: CALL_OW 296
120902: PUSH
120903: LD_INT 10
120905: LESS
120906: PUSH
120907: LD_VAR 0 18
120911: PPUSH
120912: CALL_OW 461
120916: PUSH
120917: LD_INT 7
120919: NONEQUAL
120920: AND
120921: IFFALSE 120925
// continue ;
120923: GO 120160
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
120925: LD_ADDR_VAR 0 17
120929: PUSH
120930: LD_VAR 0 17
120934: PPUSH
120935: LD_VAR 0 17
120939: PUSH
120940: LD_INT 1
120942: PLUS
120943: PPUSH
120944: LD_VAR 0 4
120948: PPUSH
120949: CALL_OW 1
120953: ST_TO_ADDR
// ComExitBuilding ( i ) ;
120954: LD_VAR 0 4
120958: PPUSH
120959: CALL_OW 122
// end ; if sold_defenders then
120963: LD_VAR 0 17
120967: IFFALSE 121027
// if i in sold_defenders then
120969: LD_VAR 0 4
120973: PUSH
120974: LD_VAR 0 17
120978: IN
120979: IFFALSE 121027
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
120981: LD_VAR 0 4
120985: PPUSH
120986: CALL_OW 314
120990: NOT
120991: PUSH
120992: LD_VAR 0 4
120996: PPUSH
120997: LD_VAR 0 13
121001: PPUSH
121002: CALL_OW 296
121006: PUSH
121007: LD_INT 30
121009: LESS
121010: AND
121011: IFFALSE 121027
// ComAttackUnit ( i , e ) ;
121013: LD_VAR 0 4
121017: PPUSH
121018: LD_VAR 0 13
121022: PPUSH
121023: CALL_OW 115
// end ; end ; end ;
121027: GO 121030
121029: POP
// if IsDead ( i ) then
121030: LD_VAR 0 4
121034: PPUSH
121035: CALL_OW 301
121039: IFFALSE 121057
// defenders := defenders diff i ;
121041: LD_ADDR_VAR 0 2
121045: PUSH
121046: LD_VAR 0 2
121050: PUSH
121051: LD_VAR 0 4
121055: DIFF
121056: ST_TO_ADDR
// end ;
121057: GO 120160
121059: POP
121060: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
121061: LD_VAR 0 21
121065: NOT
121066: PUSH
121067: LD_VAR 0 2
121071: NOT
121072: OR
121073: PUSH
121074: LD_EXP 78
121078: PUSH
121079: LD_VAR 0 1
121083: ARRAY
121084: NOT
121085: OR
121086: IFFALSE 120064
// MC_Reset ( base , 18 ) ;
121088: LD_VAR 0 1
121092: PPUSH
121093: LD_INT 18
121095: PPUSH
121096: CALL 26323 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
121100: LD_ADDR_VAR 0 2
121104: PUSH
121105: LD_VAR 0 2
121109: PUSH
121110: LD_VAR 0 2
121114: PPUSH
121115: LD_INT 2
121117: PUSH
121118: LD_INT 25
121120: PUSH
121121: LD_INT 1
121123: PUSH
121124: EMPTY
121125: LIST
121126: LIST
121127: PUSH
121128: LD_INT 25
121130: PUSH
121131: LD_INT 5
121133: PUSH
121134: EMPTY
121135: LIST
121136: LIST
121137: PUSH
121138: LD_INT 25
121140: PUSH
121141: LD_INT 8
121143: PUSH
121144: EMPTY
121145: LIST
121146: LIST
121147: PUSH
121148: LD_INT 25
121150: PUSH
121151: LD_INT 9
121153: PUSH
121154: EMPTY
121155: LIST
121156: LIST
121157: PUSH
121158: EMPTY
121159: LIST
121160: LIST
121161: LIST
121162: LIST
121163: LIST
121164: PPUSH
121165: CALL_OW 72
121169: DIFF
121170: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
121171: LD_VAR 0 21
121175: NOT
121176: PUSH
121177: LD_VAR 0 2
121181: PPUSH
121182: LD_INT 21
121184: PUSH
121185: LD_INT 2
121187: PUSH
121188: EMPTY
121189: LIST
121190: LIST
121191: PPUSH
121192: CALL_OW 72
121196: AND
121197: IFFALSE 121535
// begin tmp := FilterByTag ( defenders , 19 ) ;
121199: LD_ADDR_VAR 0 11
121203: PUSH
121204: LD_VAR 0 2
121208: PPUSH
121209: LD_INT 19
121211: PPUSH
121212: CALL 87722 0 2
121216: ST_TO_ADDR
// if tmp then
121217: LD_VAR 0 11
121221: IFFALSE 121291
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
121223: LD_ADDR_VAR 0 11
121227: PUSH
121228: LD_VAR 0 11
121232: PPUSH
121233: LD_INT 25
121235: PUSH
121236: LD_INT 3
121238: PUSH
121239: EMPTY
121240: LIST
121241: LIST
121242: PPUSH
121243: CALL_OW 72
121247: ST_TO_ADDR
// if tmp then
121248: LD_VAR 0 11
121252: IFFALSE 121291
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
121254: LD_ADDR_EXP 90
121258: PUSH
121259: LD_EXP 90
121263: PPUSH
121264: LD_VAR 0 1
121268: PPUSH
121269: LD_EXP 90
121273: PUSH
121274: LD_VAR 0 1
121278: ARRAY
121279: PUSH
121280: LD_VAR 0 11
121284: UNION
121285: PPUSH
121286: CALL_OW 1
121290: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
121291: LD_VAR 0 1
121295: PPUSH
121296: LD_INT 19
121298: PPUSH
121299: CALL 26323 0 2
// repeat wait ( 0 0$1 ) ;
121303: LD_INT 35
121305: PPUSH
121306: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121310: LD_EXP 78
121314: PUSH
121315: LD_VAR 0 1
121319: ARRAY
121320: NOT
121321: PUSH
121322: LD_EXP 78
121326: PUSH
121327: LD_VAR 0 1
121331: ARRAY
121332: PUSH
121333: EMPTY
121334: EQUAL
121335: OR
121336: IFFALSE 121373
// begin for i in defenders do
121338: LD_ADDR_VAR 0 4
121342: PUSH
121343: LD_VAR 0 2
121347: PUSH
121348: FOR_IN
121349: IFFALSE 121362
// ComStop ( i ) ;
121351: LD_VAR 0 4
121355: PPUSH
121356: CALL_OW 141
121360: GO 121348
121362: POP
121363: POP
// defenders := [ ] ;
121364: LD_ADDR_VAR 0 2
121368: PUSH
121369: EMPTY
121370: ST_TO_ADDR
// exit ;
121371: GO 121599
// end ; for i in defenders do
121373: LD_ADDR_VAR 0 4
121377: PUSH
121378: LD_VAR 0 2
121382: PUSH
121383: FOR_IN
121384: IFFALSE 121473
// begin if not IsInArea ( i , mc_parking [ base ] ) then
121386: LD_VAR 0 4
121390: PPUSH
121391: LD_EXP 102
121395: PUSH
121396: LD_VAR 0 1
121400: ARRAY
121401: PPUSH
121402: CALL_OW 308
121406: NOT
121407: IFFALSE 121431
// ComMoveToArea ( i , mc_parking [ base ] ) else
121409: LD_VAR 0 4
121413: PPUSH
121414: LD_EXP 102
121418: PUSH
121419: LD_VAR 0 1
121423: ARRAY
121424: PPUSH
121425: CALL_OW 113
121429: GO 121471
// if GetControl ( i ) = control_manual then
121431: LD_VAR 0 4
121435: PPUSH
121436: CALL_OW 263
121440: PUSH
121441: LD_INT 1
121443: EQUAL
121444: IFFALSE 121471
// if IsDrivenBy ( i ) then
121446: LD_VAR 0 4
121450: PPUSH
121451: CALL_OW 311
121455: IFFALSE 121471
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
121457: LD_VAR 0 4
121461: PPUSH
121462: CALL_OW 311
121466: PPUSH
121467: CALL_OW 121
// end ;
121471: GO 121383
121473: POP
121474: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
121475: LD_VAR 0 2
121479: PPUSH
121480: LD_INT 95
121482: PUSH
121483: LD_EXP 102
121487: PUSH
121488: LD_VAR 0 1
121492: ARRAY
121493: PUSH
121494: EMPTY
121495: LIST
121496: LIST
121497: PPUSH
121498: CALL_OW 72
121502: PUSH
121503: LD_VAR 0 2
121507: EQUAL
121508: PUSH
121509: LD_EXP 101
121513: PUSH
121514: LD_VAR 0 1
121518: ARRAY
121519: OR
121520: PUSH
121521: LD_EXP 78
121525: PUSH
121526: LD_VAR 0 1
121530: ARRAY
121531: NOT
121532: OR
121533: IFFALSE 121303
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
121535: LD_ADDR_EXP 100
121539: PUSH
121540: LD_EXP 100
121544: PPUSH
121545: LD_VAR 0 1
121549: PPUSH
121550: LD_VAR 0 2
121554: PPUSH
121555: LD_INT 21
121557: PUSH
121558: LD_INT 2
121560: PUSH
121561: EMPTY
121562: LIST
121563: LIST
121564: PPUSH
121565: CALL_OW 72
121569: PPUSH
121570: CALL_OW 1
121574: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
121575: LD_VAR 0 1
121579: PPUSH
121580: LD_INT 19
121582: PPUSH
121583: CALL 26323 0 2
// MC_Reset ( base , 20 ) ;
121587: LD_VAR 0 1
121591: PPUSH
121592: LD_INT 20
121594: PPUSH
121595: CALL 26323 0 2
// end ; end_of_file
121599: LD_VAR 0 3
121603: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
121604: LD_VAR 0 1
121608: PUSH
121609: LD_INT 200
121611: DOUBLE
121612: GREATEREQUAL
121613: IFFALSE 121621
121615: LD_INT 299
121617: DOUBLE
121618: LESSEQUAL
121619: IFTRUE 121623
121621: GO 121655
121623: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
121624: LD_VAR 0 1
121628: PPUSH
121629: LD_VAR 0 2
121633: PPUSH
121634: LD_VAR 0 3
121638: PPUSH
121639: LD_VAR 0 4
121643: PPUSH
121644: LD_VAR 0 5
121648: PPUSH
121649: CALL 110390 0 5
121653: GO 121732
121655: LD_INT 300
121657: DOUBLE
121658: GREATEREQUAL
121659: IFFALSE 121667
121661: LD_INT 399
121663: DOUBLE
121664: LESSEQUAL
121665: IFTRUE 121669
121667: GO 121731
121669: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
121670: LD_VAR 0 1
121674: PPUSH
121675: LD_VAR 0 2
121679: PPUSH
121680: LD_VAR 0 3
121684: PPUSH
121685: LD_VAR 0 4
121689: PPUSH
121690: LD_VAR 0 5
121694: PPUSH
121695: LD_VAR 0 6
121699: PPUSH
121700: LD_VAR 0 7
121704: PPUSH
121705: LD_VAR 0 8
121709: PPUSH
121710: LD_VAR 0 9
121714: PPUSH
121715: LD_VAR 0 10
121719: PPUSH
121720: LD_VAR 0 11
121724: PPUSH
121725: CALL 106715 0 11
121729: GO 121732
121731: POP
// end ;
121732: PPOPN 11
121734: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
121735: LD_VAR 0 1
121739: PPUSH
121740: LD_VAR 0 2
121744: PPUSH
121745: LD_VAR 0 3
121749: PPUSH
121750: LD_VAR 0 4
121754: PPUSH
121755: LD_VAR 0 5
121759: PPUSH
121760: CALL 110126 0 5
// end ; end_of_file
121764: PPOPN 5
121766: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
121767: LD_VAR 0 1
121771: PPUSH
121772: LD_VAR 0 2
121776: PPUSH
121777: LD_VAR 0 3
121781: PPUSH
121782: LD_VAR 0 4
121786: PPUSH
121787: LD_VAR 0 5
121791: PPUSH
121792: LD_VAR 0 6
121796: PPUSH
121797: CALL 94367 0 6
// end ;
121801: PPOPN 6
121803: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
121804: LD_INT 0
121806: PPUSH
// begin if not units then
121807: LD_VAR 0 1
121811: NOT
121812: IFFALSE 121816
// exit ;
121814: GO 121816
// end ;
121816: PPOPN 7
121818: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
121819: CALL 94271 0 0
// end ;
121823: PPOPN 1
121825: END
