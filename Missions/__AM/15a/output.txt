// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20112 0 0
// InitNature ;
  19: CALL 16784 0 0
// InitArtifact ;
  23: CALL 17397 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4496 0 0
// PrepareAlliance ;
  44: CALL 1314 0 0
// PrepareArabian ;
  48: CALL 6226 0 0
// PrepareRussian ;
  52: CALL 8177 0 0
// PrepareLegion ;
  56: CALL 6620 0 0
// Action ;
  60: CALL 10680 0 0
// MC_Start ( ) ;
  64: CALL 22224 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// end ;
 168: LD_VAR 0 1
 172: RET
// export function CustomInitMacro ( ) ; begin
 173: LD_INT 0
 175: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 176: LD_ADDR_EXP 98
 180: PUSH
 181: LD_INT 26
 183: PUSH
 184: LD_INT 1
 186: PUSH
 187: LD_INT 4
 189: PUSH
 190: LD_INT 8
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 199: LD_ADDR_EXP 99
 203: PUSH
 204: LD_INT 27
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 7
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: LIST
 221: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 222: LD_INT 1
 224: PPUSH
 225: LD_INT 6
 227: PUSH
 228: LD_INT 7
 230: PUSH
 231: LD_INT 9
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: PPUSH
 245: LD_INT 28
 247: PPUSH
 248: CALL 43329 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 252: LD_INT 1
 254: PPUSH
 255: LD_INT 10
 257: PUSH
 258: LD_INT 11
 260: PUSH
 261: LD_INT 13
 263: PUSH
 264: LD_INT 15
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: PPUSH
 273: CALL 44389 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 29
 282: PUSH
 283: EMPTY
 284: LIST
 285: PPUSH
 286: CALL 44482 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 290: LD_ADDR_EXP 103
 294: PUSH
 295: LD_EXP 103
 299: PPUSH
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 22
 305: PUSH
 306: LD_INT 2
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: PUSH
 313: LD_INT 25
 315: PUSH
 316: LD_INT 15
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: PPUSH
 327: CALL_OW 69
 331: PPUSH
 332: CALL_OW 1
 336: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 337: LD_INT 1
 339: PPUSH
 340: LD_INT 13
 342: PUSH
 343: LD_INT 2
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 31
 351: PUSH
 352: EMPTY
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: PUSH
 358: LD_INT 13
 360: PUSH
 361: LD_INT 2
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: LD_INT 31
 369: PUSH
 370: EMPTY
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 13
 378: PUSH
 379: LD_INT 1
 381: PUSH
 382: LD_INT 1
 384: PUSH
 385: LD_INT 28
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: PUSH
 394: LD_INT 13
 396: PUSH
 397: LD_INT 1
 399: PUSH
 400: LD_INT 1
 402: PUSH
 403: LD_INT 28
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: PUSH
 412: LD_INT 13
 414: PUSH
 415: LD_INT 1
 417: PUSH
 418: LD_INT 1
 420: PUSH
 421: LD_INT 28
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 13
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: LD_INT 28
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PPUSH
 456: CALL 43647 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 460: LD_INT 1
 462: PPUSH
 463: LD_INT 4
 465: PPUSH
 466: CALL 43832 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 470: LD_INT 2
 472: PPUSH
 473: LD_INT 10
 475: PUSH
 476: LD_INT 11
 478: PUSH
 479: LD_INT 12
 481: PUSH
 482: LD_INT 14
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL 44389 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 495: LD_INT 2
 497: PPUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: PPUSH
 504: CALL 44482 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 508: LD_INT 2
 510: PPUSH
 511: LD_INT 21
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 51
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 22
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: LD_INT 3
 537: PUSH
 538: LD_INT 52
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 22
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: LD_INT 3
 555: PUSH
 556: LD_INT 52
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 24
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: LD_INT 3
 573: PUSH
 574: LD_INT 47
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 24
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 3
 591: PUSH
 592: LD_INT 47
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: LD_INT 24
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: LD_INT 47
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: PUSH
 619: LD_INT 24
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 3
 627: PUSH
 628: LD_INT 47
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 24
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 47
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PPUSH
 665: CALL 43647 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 669: LD_INT 2
 671: PPUSH
 672: LD_INT 5
 674: PPUSH
 675: CALL 43832 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 0
 684: PPUSH
 685: CALL 44262 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 689: LD_INT 3
 691: PPUSH
 692: LD_INT 10
 694: PUSH
 695: LD_INT 12
 697: PUSH
 698: LD_INT 15
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_OWVAR 67
 710: ARRAY
 711: PPUSH
 712: LD_INT 24
 714: PPUSH
 715: CALL 43329 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 719: LD_INT 3
 721: PPUSH
 722: LD_INT 10
 724: PUSH
 725: LD_INT 11
 727: PUSH
 728: LD_INT 13
 730: PUSH
 731: LD_INT 15
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: PPUSH
 740: CALL 44389 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 744: LD_INT 3
 746: PPUSH
 747: LD_INT 13
 749: PUSH
 750: EMPTY
 751: LIST
 752: PPUSH
 753: CALL 44482 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 757: LD_ADDR_EXP 103
 761: PUSH
 762: LD_EXP 103
 766: PPUSH
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 22
 772: PUSH
 773: LD_INT 8
 775: PUSH
 776: EMPTY
 777: LIST
 778: LIST
 779: PUSH
 780: LD_INT 25
 782: PUSH
 783: LD_INT 15
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: PPUSH
 794: CALL_OW 69
 798: PPUSH
 799: CALL_OW 1
 803: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 804: LD_INT 3
 806: PPUSH
 807: LD_INT 13
 809: PUSH
 810: LD_INT 2
 812: PUSH
 813: LD_INT 1
 815: PUSH
 816: LD_INT 31
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 13
 827: PUSH
 828: LD_INT 2
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 31
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 13
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 2
 851: PUSH
 852: LD_INT 32
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: LD_INT 14
 863: PUSH
 864: LD_INT 1
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 28
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 14
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 28
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: PUSH
 897: LD_INT 14
 899: PUSH
 900: LD_INT 1
 902: PUSH
 903: LD_INT 1
 905: PUSH
 906: LD_INT 28
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 14
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: LD_INT 1
 923: PUSH
 924: LD_INT 28
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 43647 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 4
 951: PPUSH
 952: CALL 43832 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 956: LD_INT 4
 958: PPUSH
 959: LD_INT 10
 961: PUSH
 962: LD_INT 12
 964: PUSH
 965: LD_INT 11
 967: PUSH
 968: LD_INT 15
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL 44389 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 981: LD_INT 4
 983: PPUSH
 984: LD_INT 33
 986: PUSH
 987: EMPTY
 988: LIST
 989: PPUSH
 990: CALL 44482 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 994: LD_INT 4
 996: PPUSH
 997: LD_INT 5
 999: PUSH
1000: LD_INT 6
1002: PUSH
1003: LD_INT 7
1005: PUSH
1006: LD_INT 9
1008: PUSH
1009: LD_INT 10
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PPUSH
1019: CALL 44800 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1023: LD_INT 4
1025: PPUSH
1026: LD_INT 54
1028: PPUSH
1029: LD_INT 85
1031: PPUSH
1032: LD_INT 2
1034: PPUSH
1035: LD_INT 25
1037: PUSH
1038: LD_INT 16
1040: PUSH
1041: LD_INT 17
1043: PUSH
1044: LD_INT 18
1046: PUSH
1047: LD_INT 22
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL 44594 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1061: LD_INT 4
1063: PPUSH
1064: LD_INT 5
1066: PUSH
1067: LD_INT 1
1069: PUSH
1070: LD_INT 1
1072: PUSH
1073: LD_INT 7
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 5
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: LD_INT 1
1090: PUSH
1091: LD_INT 6
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 5
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 1
1108: PUSH
1109: LD_INT 7
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_INT 5
1120: PUSH
1121: LD_INT 1
1123: PUSH
1124: LD_INT 1
1126: PUSH
1127: LD_INT 6
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 5
1138: PUSH
1139: LD_INT 1
1141: PUSH
1142: LD_INT 3
1144: PUSH
1145: LD_INT 12
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PUSH
1154: LD_INT 3
1156: PUSH
1157: LD_INT 1
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: LD_INT 13
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PPUSH
1180: CALL 43647 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1184: LD_INT 4
1186: PPUSH
1187: LD_INT 4
1189: PPUSH
1190: CALL 43832 0 2
// MC_SetTame ( 4 , powellApe ) ;
1194: LD_INT 4
1196: PPUSH
1197: LD_INT 11
1199: PPUSH
1200: CALL 44213 0 2
// end ;
1204: LD_VAR 0 1
1208: RET
// every 0 0$1 trigger debug do var i ;
1209: LD_EXP 1
1213: IFFALSE 1311
1215: GO 1217
1217: DISABLE
1218: LD_INT 0
1220: PPUSH
// begin enable ;
1221: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1222: LD_ADDR_VAR 0 1
1226: PUSH
1227: LD_INT 22
1229: PUSH
1230: LD_INT 7
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 2
1239: PUSH
1240: LD_INT 21
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: PUSH
1250: LD_INT 21
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: PUSH
1265: LD_INT 3
1267: PUSH
1268: LD_INT 24
1270: PUSH
1271: LD_INT 1000
1273: PUSH
1274: EMPTY
1275: LIST
1276: LIST
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: PPUSH
1287: CALL_OW 69
1291: PUSH
1292: FOR_IN
1293: IFFALSE 1309
// SetLives ( i , 1000 ) ;
1295: LD_VAR 0 1
1299: PPUSH
1300: LD_INT 1000
1302: PPUSH
1303: CALL_OW 234
1307: GO 1292
1309: POP
1310: POP
// end ; end_of_file
1311: PPOPN 1
1313: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1314: LD_INT 0
1316: PPUSH
1317: PPUSH
1318: PPUSH
1319: PPUSH
1320: PPUSH
// uc_side := 7 ;
1321: LD_ADDR_OWVAR 20
1325: PUSH
1326: LD_INT 7
1328: ST_TO_ADDR
// tmp := [ ] ;
1329: LD_ADDR_VAR 0 5
1333: PUSH
1334: EMPTY
1335: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1336: LD_ADDR_EXP 12
1340: PUSH
1341: LD_STRING JMM
1343: PPUSH
1344: LD_EXP 1
1348: NOT
1349: PPUSH
1350: LD_STRING 14a_
1352: PPUSH
1353: CALL 49905 0 3
1357: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1358: LD_ADDR_EXP 44
1362: PUSH
1363: LD_STRING Burlak
1365: PPUSH
1366: LD_EXP 1
1370: NOT
1371: PPUSH
1372: LD_STRING 14a_
1374: PPUSH
1375: CALL 49905 0 3
1379: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1380: LD_ADDR_EXP 27
1384: PUSH
1385: LD_STRING Joan
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: LD_STRING 13a_
1396: PPUSH
1397: CALL 49905 0 3
1401: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1402: LD_ADDR_EXP 13
1406: PUSH
1407: LD_STRING Roth
1409: PPUSH
1410: LD_EXP 1
1414: NOT
1415: PPUSH
1416: LD_STRING 13a_
1418: PPUSH
1419: CALL 49905 0 3
1423: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1424: LD_ADDR_EXP 30
1428: PUSH
1429: LD_STRING Gossudarov
1431: PPUSH
1432: LD_EXP 1
1436: NOT
1437: PPUSH
1438: LD_STRING 13a_
1440: PPUSH
1441: CALL 49905 0 3
1445: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1446: LD_ADDR_EXP 28
1450: PUSH
1451: LD_STRING DeltaDoctor
1453: PPUSH
1454: LD_EXP 1
1458: NOT
1459: PPUSH
1460: LD_STRING 13a_
1462: PPUSH
1463: CALL 49905 0 3
1467: ST_TO_ADDR
// if DeltaDoctor then
1468: LD_EXP 28
1472: IFFALSE 1490
// tmp := tmp ^ DeltaDoctor ;
1474: LD_ADDR_VAR 0 5
1478: PUSH
1479: LD_VAR 0 5
1483: PUSH
1484: LD_EXP 28
1488: ADD
1489: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1490: LD_ADDR_EXP 26
1494: PUSH
1495: LD_STRING Simms
1497: PPUSH
1498: LD_EXP 1
1502: NOT
1503: PPUSH
1504: LD_STRING 13a_
1506: PPUSH
1507: CALL 49905 0 3
1511: ST_TO_ADDR
// if Simms then
1512: LD_EXP 26
1516: IFFALSE 1534
// tmp := tmp ^ Simms ;
1518: LD_ADDR_VAR 0 5
1522: PUSH
1523: LD_VAR 0 5
1527: PUSH
1528: LD_EXP 26
1532: ADD
1533: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1534: LD_ADDR_EXP 24
1538: PUSH
1539: LD_STRING Frank
1541: PPUSH
1542: LD_EXP 1
1546: NOT
1547: PPUSH
1548: LD_STRING 13a_
1550: PPUSH
1551: CALL 49905 0 3
1555: ST_TO_ADDR
// if Frank then
1556: LD_EXP 24
1560: IFFALSE 1578
// tmp := tmp ^ Frank ;
1562: LD_ADDR_VAR 0 5
1566: PUSH
1567: LD_VAR 0 5
1571: PUSH
1572: LD_EXP 24
1576: ADD
1577: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1578: LD_ADDR_EXP 31
1582: PUSH
1583: LD_STRING Kirilenkova
1585: PPUSH
1586: LD_EXP 1
1590: NOT
1591: PPUSH
1592: LD_STRING 13a_
1594: PPUSH
1595: CALL 49905 0 3
1599: ST_TO_ADDR
// if Kirilenkova then
1600: LD_EXP 31
1604: IFFALSE 1622
// tmp := tmp ^ Kirilenkova ;
1606: LD_ADDR_VAR 0 5
1610: PUSH
1611: LD_VAR 0 5
1615: PUSH
1616: LD_EXP 31
1620: ADD
1621: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING Titov
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 13a_
1638: PPUSH
1639: CALL 49905 0 3
1643: ST_TO_ADDR
// if Titov then
1644: LD_EXP 32
1648: IFFALSE 1666
// tmp := tmp ^ Titov ;
1650: LD_ADDR_VAR 0 5
1654: PUSH
1655: LD_VAR 0 5
1659: PUSH
1660: LD_EXP 32
1664: ADD
1665: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1666: LD_ADDR_EXP 33
1670: PUSH
1671: LD_STRING Fadeev
1673: PPUSH
1674: LD_EXP 1
1678: NOT
1679: PPUSH
1680: LD_STRING 13a_
1682: PPUSH
1683: CALL 49905 0 3
1687: ST_TO_ADDR
// if Fadeev then
1688: LD_EXP 33
1692: IFFALSE 1710
// tmp := tmp ^ Fadeev ;
1694: LD_ADDR_VAR 0 5
1698: PUSH
1699: LD_VAR 0 5
1703: PUSH
1704: LD_EXP 33
1708: ADD
1709: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1710: LD_ADDR_EXP 34
1714: PUSH
1715: LD_STRING Dolgov
1717: PPUSH
1718: LD_EXP 1
1722: NOT
1723: PPUSH
1724: LD_STRING 13a_
1726: PPUSH
1727: CALL 49905 0 3
1731: ST_TO_ADDR
// if Dolgov then
1732: LD_EXP 34
1736: IFFALSE 1754
// tmp := tmp ^ Dolgov ;
1738: LD_ADDR_VAR 0 5
1742: PUSH
1743: LD_VAR 0 5
1747: PUSH
1748: LD_EXP 34
1752: ADD
1753: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1754: LD_ADDR_EXP 35
1758: PUSH
1759: LD_STRING Petrosyan
1761: PPUSH
1762: LD_EXP 1
1766: NOT
1767: PPUSH
1768: LD_STRING 13a_
1770: PPUSH
1771: CALL 49905 0 3
1775: ST_TO_ADDR
// if Petrosyan then
1776: LD_EXP 35
1780: IFFALSE 1798
// tmp := tmp ^ Petrosyan ;
1782: LD_ADDR_VAR 0 5
1786: PUSH
1787: LD_VAR 0 5
1791: PUSH
1792: LD_EXP 35
1796: ADD
1797: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1798: LD_ADDR_EXP 36
1802: PUSH
1803: LD_STRING Scholtze
1805: PPUSH
1806: LD_EXP 1
1810: NOT
1811: PPUSH
1812: LD_STRING 13a_
1814: PPUSH
1815: CALL 49905 0 3
1819: ST_TO_ADDR
// if Scholtze then
1820: LD_EXP 36
1824: IFFALSE 1842
// tmp := tmp ^ Scholtze ;
1826: LD_ADDR_VAR 0 5
1830: PUSH
1831: LD_VAR 0 5
1835: PUSH
1836: LD_EXP 36
1840: ADD
1841: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1842: LD_ADDR_EXP 37
1846: PUSH
1847: LD_STRING Oblukov
1849: PPUSH
1850: LD_EXP 1
1854: NOT
1855: PPUSH
1856: LD_STRING 13a_
1858: PPUSH
1859: CALL 49905 0 3
1863: ST_TO_ADDR
// if Oblukov then
1864: LD_EXP 37
1868: IFFALSE 1886
// tmp := tmp ^ Oblukov ;
1870: LD_ADDR_VAR 0 5
1874: PUSH
1875: LD_VAR 0 5
1879: PUSH
1880: LD_EXP 37
1884: ADD
1885: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1886: LD_ADDR_EXP 38
1890: PUSH
1891: LD_STRING Kapitsova
1893: PPUSH
1894: LD_EXP 1
1898: NOT
1899: PPUSH
1900: LD_STRING 13a_
1902: PPUSH
1903: CALL 49905 0 3
1907: ST_TO_ADDR
// if Kapitsova then
1908: LD_EXP 38
1912: IFFALSE 1930
// tmp := tmp ^ Kapitsova ;
1914: LD_ADDR_VAR 0 5
1918: PUSH
1919: LD_VAR 0 5
1923: PUSH
1924: LD_EXP 38
1928: ADD
1929: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1930: LD_ADDR_EXP 39
1934: PUSH
1935: LD_STRING Lipshchin
1937: PPUSH
1938: LD_EXP 1
1942: NOT
1943: PPUSH
1944: LD_STRING 13a_
1946: PPUSH
1947: CALL 49905 0 3
1951: ST_TO_ADDR
// if Lipshchin then
1952: LD_EXP 39
1956: IFFALSE 1974
// tmp := tmp ^ Lipshchin ;
1958: LD_ADDR_VAR 0 5
1962: PUSH
1963: LD_VAR 0 5
1967: PUSH
1968: LD_EXP 39
1972: ADD
1973: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
1974: LD_ADDR_EXP 40
1978: PUSH
1979: LD_STRING Petrovova
1981: PPUSH
1982: LD_EXP 1
1986: NOT
1987: PPUSH
1988: LD_STRING 13a_
1990: PPUSH
1991: CALL 49905 0 3
1995: ST_TO_ADDR
// if Petrovova then
1996: LD_EXP 40
2000: IFFALSE 2018
// tmp := tmp ^ Petrovova ;
2002: LD_ADDR_VAR 0 5
2006: PUSH
2007: LD_VAR 0 5
2011: PUSH
2012: LD_EXP 40
2016: ADD
2017: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2018: LD_ADDR_EXP 41
2022: PUSH
2023: LD_STRING Kovalyuk
2025: PPUSH
2026: LD_EXP 1
2030: NOT
2031: PPUSH
2032: LD_STRING 13a_
2034: PPUSH
2035: CALL 49905 0 3
2039: ST_TO_ADDR
// if Kovalyuk then
2040: LD_EXP 41
2044: IFFALSE 2062
// tmp := tmp ^ Kovalyuk ;
2046: LD_ADDR_VAR 0 5
2050: PUSH
2051: LD_VAR 0 5
2055: PUSH
2056: LD_EXP 41
2060: ADD
2061: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2062: LD_ADDR_EXP 42
2066: PUSH
2067: LD_STRING Kuzmov
2069: PPUSH
2070: LD_EXP 1
2074: NOT
2075: PPUSH
2076: LD_STRING 13a_
2078: PPUSH
2079: CALL 49905 0 3
2083: ST_TO_ADDR
// if Kuzmov then
2084: LD_EXP 42
2088: IFFALSE 2106
// tmp := tmp ^ Kuzmov ;
2090: LD_ADDR_VAR 0 5
2094: PUSH
2095: LD_VAR 0 5
2099: PUSH
2100: LD_EXP 42
2104: ADD
2105: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2106: LD_ADDR_EXP 43
2110: PUSH
2111: LD_STRING Karamazov
2113: PPUSH
2114: LD_EXP 1
2118: NOT
2119: PPUSH
2120: LD_STRING 13a_
2122: PPUSH
2123: CALL 49905 0 3
2127: ST_TO_ADDR
// if Karamazov then
2128: LD_EXP 43
2132: IFFALSE 2150
// tmp := tmp ^ Karamazov ;
2134: LD_ADDR_VAR 0 5
2138: PUSH
2139: LD_VAR 0 5
2143: PUSH
2144: LD_EXP 43
2148: ADD
2149: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2150: LD_ADDR_EXP 45
2154: PUSH
2155: LD_STRING Belkov
2157: PPUSH
2158: LD_EXP 1
2162: NOT
2163: PPUSH
2164: LD_STRING 13a_
2166: PPUSH
2167: CALL 49905 0 3
2171: ST_TO_ADDR
// if Belkov then
2172: LD_EXP 45
2176: IFFALSE 2194
// tmp := tmp ^ Belkov ;
2178: LD_ADDR_VAR 0 5
2182: PUSH
2183: LD_VAR 0 5
2187: PUSH
2188: LD_EXP 45
2192: ADD
2193: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2194: LD_ADDR_EXP 46
2198: PUSH
2199: LD_STRING Gnyevko
2201: PPUSH
2202: LD_EXP 1
2206: NOT
2207: PPUSH
2208: LD_STRING 13a_
2210: PPUSH
2211: CALL 49905 0 3
2215: ST_TO_ADDR
// if Gnyevko then
2216: LD_EXP 46
2220: IFFALSE 2238
// tmp := tmp ^ Gnyevko ;
2222: LD_ADDR_VAR 0 5
2226: PUSH
2227: LD_VAR 0 5
2231: PUSH
2232: LD_EXP 46
2236: ADD
2237: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2238: LD_ADDR_EXP 29
2242: PUSH
2243: LD_STRING Coonie
2245: PPUSH
2246: CALL_OW 25
2250: ST_TO_ADDR
// if not Lisa then
2251: LD_EXP 14
2255: NOT
2256: IFFALSE 2302
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 14
2262: PUSH
2263: LD_STRING Lisa
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 49905 0 3
2279: ST_TO_ADDR
// if Lisa then
2280: LD_EXP 14
2284: IFFALSE 2302
// tmp := tmp ^ Lisa ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 14
2300: ADD
2301: ST_TO_ADDR
// end ; if not Donaldson then
2302: LD_EXP 15
2306: NOT
2307: IFFALSE 2353
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2309: LD_ADDR_EXP 15
2313: PUSH
2314: LD_STRING Donaldson
2316: PPUSH
2317: LD_EXP 1
2321: NOT
2322: PPUSH
2323: LD_STRING 13a_
2325: PPUSH
2326: CALL 49905 0 3
2330: ST_TO_ADDR
// if Donaldson then
2331: LD_EXP 15
2335: IFFALSE 2353
// tmp := tmp ^ Donaldson ;
2337: LD_ADDR_VAR 0 5
2341: PUSH
2342: LD_VAR 0 5
2346: PUSH
2347: LD_EXP 15
2351: ADD
2352: ST_TO_ADDR
// end ; if not Bobby then
2353: LD_EXP 16
2357: NOT
2358: IFFALSE 2404
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 16
2364: PUSH
2365: LD_STRING Bobby
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 49905 0 3
2381: ST_TO_ADDR
// if Bobby then
2382: LD_EXP 16
2386: IFFALSE 2404
// tmp := tmp ^ Bobby ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 16
2402: ADD
2403: ST_TO_ADDR
// end ; if not Cyrus then
2404: LD_EXP 17
2408: NOT
2409: IFFALSE 2455
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2411: LD_ADDR_EXP 17
2415: PUSH
2416: LD_STRING Cyrus
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_STRING 13a_
2427: PPUSH
2428: CALL 49905 0 3
2432: ST_TO_ADDR
// if Cyrus then
2433: LD_EXP 17
2437: IFFALSE 2455
// tmp := tmp ^ Cyrus ;
2439: LD_ADDR_VAR 0 5
2443: PUSH
2444: LD_VAR 0 5
2448: PUSH
2449: LD_EXP 17
2453: ADD
2454: ST_TO_ADDR
// end ; if not Brown then
2455: LD_EXP 19
2459: NOT
2460: IFFALSE 2506
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2462: LD_ADDR_EXP 19
2466: PUSH
2467: LD_STRING Brown
2469: PPUSH
2470: LD_EXP 1
2474: NOT
2475: PPUSH
2476: LD_STRING 13a_
2478: PPUSH
2479: CALL 49905 0 3
2483: ST_TO_ADDR
// if Brown then
2484: LD_EXP 19
2488: IFFALSE 2506
// tmp := tmp ^ Brown ;
2490: LD_ADDR_VAR 0 5
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: LD_EXP 19
2504: ADD
2505: ST_TO_ADDR
// end ; if not Gladstone then
2506: LD_EXP 20
2510: NOT
2511: IFFALSE 2557
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2513: LD_ADDR_EXP 20
2517: PUSH
2518: LD_STRING Gladstone
2520: PPUSH
2521: LD_EXP 1
2525: NOT
2526: PPUSH
2527: LD_STRING 13a_
2529: PPUSH
2530: CALL 49905 0 3
2534: ST_TO_ADDR
// if Gladstone then
2535: LD_EXP 20
2539: IFFALSE 2557
// tmp := tmp ^ Gladstone ;
2541: LD_ADDR_VAR 0 5
2545: PUSH
2546: LD_VAR 0 5
2550: PUSH
2551: LD_EXP 20
2555: ADD
2556: ST_TO_ADDR
// end ; if not Cornel then
2557: LD_EXP 22
2561: NOT
2562: IFFALSE 2608
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2564: LD_ADDR_EXP 22
2568: PUSH
2569: LD_STRING Cornel
2571: PPUSH
2572: LD_EXP 1
2576: NOT
2577: PPUSH
2578: LD_STRING 13a_
2580: PPUSH
2581: CALL 49905 0 3
2585: ST_TO_ADDR
// if Cornel then
2586: LD_EXP 22
2590: IFFALSE 2608
// tmp := tmp ^ Cornel ;
2592: LD_ADDR_VAR 0 5
2596: PUSH
2597: LD_VAR 0 5
2601: PUSH
2602: LD_EXP 22
2606: ADD
2607: ST_TO_ADDR
// end ; if not Houten then
2608: LD_EXP 21
2612: NOT
2613: IFFALSE 2659
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2615: LD_ADDR_EXP 21
2619: PUSH
2620: LD_STRING Houten
2622: PPUSH
2623: LD_EXP 1
2627: NOT
2628: PPUSH
2629: LD_STRING 13a_
2631: PPUSH
2632: CALL 49905 0 3
2636: ST_TO_ADDR
// if Houten then
2637: LD_EXP 21
2641: IFFALSE 2659
// tmp := tmp ^ Houten ;
2643: LD_ADDR_VAR 0 5
2647: PUSH
2648: LD_VAR 0 5
2652: PUSH
2653: LD_EXP 21
2657: ADD
2658: ST_TO_ADDR
// end ; if not Gary then
2659: LD_EXP 23
2663: NOT
2664: IFFALSE 2710
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2666: LD_ADDR_EXP 23
2670: PUSH
2671: LD_STRING Gary
2673: PPUSH
2674: LD_EXP 1
2678: NOT
2679: PPUSH
2680: LD_STRING 13a_
2682: PPUSH
2683: CALL 49905 0 3
2687: ST_TO_ADDR
// if Gary then
2688: LD_EXP 23
2692: IFFALSE 2710
// tmp := tmp ^ Gary ;
2694: LD_ADDR_VAR 0 5
2698: PUSH
2699: LD_VAR 0 5
2703: PUSH
2704: LD_EXP 23
2708: ADD
2709: ST_TO_ADDR
// end ; if not Kikuchi then
2710: LD_EXP 25
2714: NOT
2715: IFFALSE 2761
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2717: LD_ADDR_EXP 25
2721: PUSH
2722: LD_STRING Kikuchi
2724: PPUSH
2725: LD_EXP 1
2729: NOT
2730: PPUSH
2731: LD_STRING 13a_
2733: PPUSH
2734: CALL 49905 0 3
2738: ST_TO_ADDR
// if Kikuchi then
2739: LD_EXP 25
2743: IFFALSE 2761
// tmp := tmp ^ Kikuchi ;
2745: LD_ADDR_VAR 0 5
2749: PUSH
2750: LD_VAR 0 5
2754: PUSH
2755: LD_EXP 25
2759: ADD
2760: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2761: LD_ADDR_VAR 0 5
2765: PUSH
2766: LD_VAR 0 5
2770: PUSH
2771: LD_STRING 13a_others
2773: PPUSH
2774: CALL_OW 31
2778: UNION
2779: ST_TO_ADDR
// tmp := tmp diff 0 ;
2780: LD_ADDR_VAR 0 5
2784: PUSH
2785: LD_VAR 0 5
2789: PUSH
2790: LD_INT 0
2792: DIFF
2793: ST_TO_ADDR
// if tmp < 15 then
2794: LD_VAR 0 5
2798: PUSH
2799: LD_INT 15
2801: LESS
2802: IFFALSE 2890
// for i = 15 downto tmp do
2804: LD_ADDR_VAR 0 2
2808: PUSH
2809: DOUBLE
2810: LD_INT 15
2812: INC
2813: ST_TO_ADDR
2814: LD_VAR 0 5
2818: PUSH
2819: FOR_DOWNTO
2820: IFFALSE 2888
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2822: LD_ADDR_OWVAR 21
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 3
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 1
2839: PPUSH
2840: LD_INT 2
2842: PPUSH
2843: CALL_OW 12
2847: ARRAY
2848: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2849: LD_INT 0
2851: PPUSH
2852: LD_INT 1
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: CALL_OW 12
2862: PPUSH
2863: LD_INT 8
2865: PPUSH
2866: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2870: LD_ADDR_VAR 0 5
2874: PUSH
2875: LD_VAR 0 5
2879: PUSH
2880: CALL_OW 44
2884: ADD
2885: ST_TO_ADDR
// end ;
2886: GO 2819
2888: POP
2889: POP
// if not debug then
2890: LD_EXP 1
2894: NOT
2895: IFFALSE 3067
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2897: LD_ADDR_VAR 0 4
2901: PUSH
2902: LD_STRING 
2904: PPUSH
2905: LD_INT 15
2907: PUSH
2908: LD_INT 14
2910: PUSH
2911: LD_INT 13
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: LIST
2918: PUSH
2919: LD_OWVAR 67
2923: ARRAY
2924: PPUSH
2925: LD_INT 15
2927: PUSH
2928: LD_INT 14
2930: PUSH
2931: LD_INT 13
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: LIST
2938: PUSH
2939: LD_OWVAR 67
2943: ARRAY
2944: PPUSH
2945: LD_INT -6
2947: PUSH
2948: LD_EXP 12
2952: PUSH
2953: LD_EXP 44
2957: PUSH
2958: LD_EXP 13
2962: PUSH
2963: LD_EXP 27
2967: PUSH
2968: LD_EXP 18
2972: PUSH
2973: LD_EXP 30
2977: PUSH
2978: LD_INT -2
2980: PUSH
2981: LD_INT -3
2983: PUSH
2984: LD_INT -5
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: LIST
2997: LIST
2998: PUSH
2999: LD_VAR 0 5
3003: ADD
3004: PPUSH
3005: LD_INT 1
3007: PUSH
3008: LD_INT 4
3010: PUSH
3011: LD_INT 2
3013: PUSH
3014: LD_INT 1
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 5
3026: PUSH
3027: LD_INT 0
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: LIST
3037: PUSH
3038: LD_INT 9
3040: PUSH
3041: LD_INT 0
3043: PUSH
3044: LD_INT 3
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PPUSH
3060: CALL_OW 42
3064: ST_TO_ADDR
3065: GO 3146
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3067: LD_ADDR_VAR 0 4
3071: PUSH
3072: LD_EXP 32
3076: PUSH
3077: LD_EXP 33
3081: PUSH
3082: LD_EXP 34
3086: PUSH
3087: LD_EXP 35
3091: PUSH
3092: LD_EXP 36
3096: PUSH
3097: LD_EXP 37
3101: PUSH
3102: LD_EXP 38
3106: PUSH
3107: LD_EXP 39
3111: PUSH
3112: LD_EXP 40
3116: PUSH
3117: LD_EXP 41
3121: PUSH
3122: LD_EXP 42
3126: PUSH
3127: LD_EXP 43
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: ST_TO_ADDR
// uc_nation := 1 ;
3146: LD_ADDR_OWVAR 21
3150: PUSH
3151: LD_INT 1
3153: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3154: LD_INT 5
3156: PPUSH
3157: LD_INT 3
3159: PPUSH
3160: LD_INT 1
3162: PPUSH
3163: LD_INT 6
3165: PPUSH
3166: LD_INT 100
3168: PPUSH
3169: CALL 56871 0 5
// veh := CreateVehicle ;
3173: LD_ADDR_VAR 0 3
3177: PUSH
3178: CALL_OW 45
3182: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3183: LD_VAR 0 3
3187: PPUSH
3188: LD_INT 7
3190: NEG
3191: PPUSH
3192: CALL_OW 242
// SetDir ( veh , 3 ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: LD_INT 3
3203: PPUSH
3204: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3208: LD_VAR 0 3
3212: PPUSH
3213: LD_INT 31
3215: PPUSH
3216: LD_INT 0
3218: PPUSH
3219: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3223: LD_EXP 12
3227: PPUSH
3228: LD_VAR 0 3
3232: PPUSH
3233: CALL_OW 52
// if Joan then
3237: LD_EXP 27
3241: IFFALSE 3313
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3243: LD_INT 3
3245: PPUSH
3246: LD_INT 3
3248: PPUSH
3249: LD_INT 1
3251: PPUSH
3252: LD_INT 11
3254: PPUSH
3255: LD_INT 100
3257: PPUSH
3258: CALL 56871 0 5
// veh := CreateVehicle ;
3262: LD_ADDR_VAR 0 3
3266: PUSH
3267: CALL_OW 45
3271: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3272: LD_VAR 0 3
3276: PPUSH
3277: LD_INT 3
3279: PPUSH
3280: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3284: LD_VAR 0 3
3288: PPUSH
3289: LD_INT 30
3291: PPUSH
3292: LD_INT 0
3294: PPUSH
3295: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3299: LD_EXP 27
3303: PPUSH
3304: LD_VAR 0 3
3308: PPUSH
3309: CALL_OW 52
// end ; if Roth then
3313: LD_EXP 13
3317: IFFALSE 3389
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3319: LD_INT 3
3321: PPUSH
3322: LD_INT 3
3324: PPUSH
3325: LD_INT 1
3327: PPUSH
3328: LD_INT 11
3330: PPUSH
3331: LD_INT 100
3333: PPUSH
3334: CALL 56871 0 5
// veh := CreateVehicle ;
3338: LD_ADDR_VAR 0 3
3342: PUSH
3343: CALL_OW 45
3347: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3348: LD_VAR 0 3
3352: PPUSH
3353: LD_INT 3
3355: PPUSH
3356: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3360: LD_VAR 0 3
3364: PPUSH
3365: LD_INT 30
3367: PPUSH
3368: LD_INT 0
3370: PPUSH
3371: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3375: LD_EXP 13
3379: PPUSH
3380: LD_VAR 0 3
3384: PPUSH
3385: CALL_OW 52
// end ; if Denis then
3389: LD_EXP 18
3393: IFFALSE 3465
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3395: LD_INT 5
3397: PPUSH
3398: LD_INT 3
3400: PPUSH
3401: LD_INT 1
3403: PPUSH
3404: LD_INT 9
3406: PPUSH
3407: LD_INT 100
3409: PPUSH
3410: CALL 56871 0 5
// veh := CreateVehicle ;
3414: LD_ADDR_VAR 0 3
3418: PUSH
3419: CALL_OW 45
3423: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3424: LD_VAR 0 3
3428: PPUSH
3429: LD_INT 3
3431: PPUSH
3432: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3436: LD_VAR 0 3
3440: PPUSH
3441: LD_INT 30
3443: PPUSH
3444: LD_INT 0
3446: PPUSH
3447: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3451: LD_EXP 18
3455: PPUSH
3456: LD_VAR 0 3
3460: PPUSH
3461: CALL_OW 52
// end ; uc_nation := 3 ;
3465: LD_ADDR_OWVAR 21
3469: PUSH
3470: LD_INT 3
3472: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3473: LD_INT 22
3475: PPUSH
3476: LD_INT 3
3478: PPUSH
3479: LD_INT 1
3481: PPUSH
3482: LD_INT 45
3484: PPUSH
3485: LD_INT 100
3487: PPUSH
3488: CALL 56871 0 5
// veh := CreateVehicle ;
3492: LD_ADDR_VAR 0 3
3496: PUSH
3497: CALL_OW 45
3501: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3502: LD_VAR 0 3
3506: PPUSH
3507: LD_INT 7
3509: NEG
3510: PPUSH
3511: CALL_OW 242
// SetDir ( veh , 3 ) ;
3515: LD_VAR 0 3
3519: PPUSH
3520: LD_INT 3
3522: PPUSH
3523: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3527: LD_VAR 0 3
3531: PPUSH
3532: LD_INT 31
3534: PPUSH
3535: LD_INT 0
3537: PPUSH
3538: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3542: LD_EXP 44
3546: PPUSH
3547: LD_VAR 0 3
3551: PPUSH
3552: CALL_OW 52
// if Gossudarov then
3556: LD_EXP 30
3560: IFFALSE 3647
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3562: LD_INT 22
3564: PPUSH
3565: LD_INT 3
3567: PPUSH
3568: LD_INT 1
3570: PPUSH
3571: LD_INT 51
3573: PPUSH
3574: LD_INT 100
3576: PPUSH
3577: CALL 56871 0 5
// veh := CreateVehicle ;
3581: LD_ADDR_VAR 0 3
3585: PUSH
3586: CALL_OW 45
3590: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3591: LD_VAR 0 3
3595: PPUSH
3596: LD_INT 3
3598: PPUSH
3599: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3603: LD_VAR 0 3
3607: PPUSH
3608: LD_INT 30
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3618: LD_EXP 30
3622: PPUSH
3623: LD_VAR 0 3
3627: PPUSH
3628: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3632: LD_VAR 0 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: LD_INT 100
3642: PPUSH
3643: CALL_OW 290
// end ; for i in selected do
3647: LD_ADDR_VAR 0 2
3651: PUSH
3652: LD_VAR 0 4
3656: PUSH
3657: FOR_IN
3658: IFFALSE 4216
// begin uc_nation := GetNation ( i ) ;
3660: LD_ADDR_OWVAR 21
3664: PUSH
3665: LD_VAR 0 2
3669: PPUSH
3670: CALL_OW 248
3674: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3675: LD_VAR 0 2
3679: PUSH
3680: LD_EXP 14
3684: PUSH
3685: LD_EXP 15
3689: PUSH
3690: LD_EXP 17
3694: PUSH
3695: LD_EXP 16
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: LIST
3704: LIST
3705: IN
3706: IFFALSE 3729
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3708: LD_INT 5
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 6
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 56871 0 5
3727: GO 4163
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3729: LD_VAR 0 2
3733: PUSH
3734: LD_EXP 37
3738: PUSH
3739: LD_EXP 42
3743: PUSH
3744: LD_EXP 40
3748: PUSH
3749: LD_EXP 32
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: LIST
3758: LIST
3759: IN
3760: IFFALSE 3791
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3762: LD_INT 24
3764: PPUSH
3765: LD_INT 1
3767: PPUSH
3768: LD_INT 1
3770: PPUSH
3771: LD_INT 46
3773: PPUSH
3774: LD_INT 65
3776: PPUSH
3777: LD_INT 75
3779: PPUSH
3780: CALL_OW 12
3784: PPUSH
3785: CALL 56871 0 5
3789: GO 4163
// if i = Karamazov then
3791: LD_VAR 0 2
3795: PUSH
3796: LD_EXP 43
3800: EQUAL
3801: IFFALSE 3824
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3803: LD_INT 22
3805: PPUSH
3806: LD_INT 3
3808: PPUSH
3809: LD_INT 1
3811: PPUSH
3812: LD_INT 52
3814: PPUSH
3815: LD_INT 100
3817: PPUSH
3818: CALL 56871 0 5
3822: GO 4163
// if i = Brown then
3824: LD_VAR 0 2
3828: PUSH
3829: LD_EXP 19
3833: EQUAL
3834: IFFALSE 3857
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3836: LD_INT 3
3838: PPUSH
3839: LD_INT 3
3841: PPUSH
3842: LD_INT 1
3844: PPUSH
3845: LD_INT 13
3847: PPUSH
3848: LD_INT 100
3850: PPUSH
3851: CALL 56871 0 5
3855: GO 4163
// if uc_nation = nation_american then
3857: LD_OWVAR 21
3861: PUSH
3862: LD_INT 1
3864: EQUAL
3865: IFFALSE 4016
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3867: LD_INT 3
3869: PUSH
3870: LD_INT 5
3872: PUSH
3873: LD_INT 5
3875: PUSH
3876: EMPTY
3877: LIST
3878: LIST
3879: LIST
3880: PUSH
3881: LD_OWVAR 21
3885: PUSH
3886: LD_INT 3
3888: MOD
3889: PUSH
3890: LD_INT 1
3892: PLUS
3893: ARRAY
3894: PPUSH
3895: LD_INT 1
3897: PUSH
3898: LD_INT 3
3900: PUSH
3901: LD_INT 1
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: PUSH
3909: LD_OWVAR 21
3913: PUSH
3914: LD_INT 3
3916: MOD
3917: PUSH
3918: LD_INT 1
3920: PLUS
3921: ARRAY
3922: PPUSH
3923: LD_INT 1
3925: PPUSH
3926: LD_INT 11
3928: PUSH
3929: LD_INT 4
3931: PUSH
3932: LD_INT 5
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 6
3942: PUSH
3943: LD_INT 7
3945: PUSH
3946: LD_INT 9
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: LIST
3953: PUSH
3954: LD_INT 6
3956: PUSH
3957: LD_INT 9
3959: PUSH
3960: LD_INT 12
3962: PUSH
3963: EMPTY
3964: LIST
3965: LIST
3966: LIST
3967: PUSH
3968: EMPTY
3969: LIST
3970: LIST
3971: LIST
3972: PUSH
3973: LD_OWVAR 21
3977: PUSH
3978: LD_INT 3
3980: MOD
3981: PUSH
3982: LD_INT 1
3984: PLUS
3985: ARRAY
3986: PUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 3
3992: PPUSH
3993: CALL_OW 12
3997: ARRAY
3998: PPUSH
3999: LD_INT 65
4001: PPUSH
4002: LD_INT 75
4004: PPUSH
4005: CALL_OW 12
4009: PPUSH
4010: CALL 56871 0 5
// end else
4014: GO 4163
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4016: LD_INT 22
4018: PUSH
4019: LD_INT 23
4021: PUSH
4022: LD_INT 23
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: PUSH
4030: LD_OWVAR 21
4034: PUSH
4035: LD_INT 3
4037: MOD
4038: PUSH
4039: LD_INT 1
4041: PLUS
4042: ARRAY
4043: PPUSH
4044: LD_INT 1
4046: PUSH
4047: LD_INT 3
4049: PUSH
4050: LD_INT 1
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: PUSH
4058: LD_OWVAR 21
4062: PUSH
4063: LD_INT 3
4065: MOD
4066: PUSH
4067: LD_INT 1
4069: PLUS
4070: ARRAY
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: LD_INT 45
4077: PUSH
4078: LD_INT 43
4080: PUSH
4081: LD_INT 44
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: LIST
4088: PUSH
4089: LD_INT 46
4091: PUSH
4092: LD_INT 45
4094: PUSH
4095: LD_INT 44
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: LIST
4102: PUSH
4103: LD_INT 46
4105: PUSH
4106: LD_INT 43
4108: PUSH
4109: LD_INT 45
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: LIST
4116: PUSH
4117: EMPTY
4118: LIST
4119: LIST
4120: LIST
4121: PUSH
4122: LD_OWVAR 21
4126: PUSH
4127: LD_INT 3
4129: MOD
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: ARRAY
4135: PUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 3
4141: PPUSH
4142: CALL_OW 12
4146: ARRAY
4147: PPUSH
4148: LD_INT 65
4150: PPUSH
4151: LD_INT 75
4153: PPUSH
4154: CALL_OW 12
4158: PPUSH
4159: CALL 56871 0 5
// end ; veh := CreateVehicle ;
4163: LD_ADDR_VAR 0 3
4167: PUSH
4168: CALL_OW 45
4172: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4173: LD_VAR 0 3
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4185: LD_VAR 0 3
4189: PPUSH
4190: LD_INT 30
4192: PPUSH
4193: LD_INT 0
4195: PPUSH
4196: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4200: LD_VAR 0 2
4204: PPUSH
4205: LD_VAR 0 3
4209: PPUSH
4210: CALL_OW 52
// end ;
4214: GO 3657
4216: POP
4217: POP
// if artifactArCaptured then
4218: LD_EXP 6
4222: IFFALSE 4308
// begin uc_nation := nation_american ;
4224: LD_ADDR_OWVAR 21
4228: PUSH
4229: LD_INT 1
4231: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4232: LD_INT 3
4234: PPUSH
4235: LD_INT 3
4237: PPUSH
4238: LD_INT 3
4240: PPUSH
4241: LD_INT 12
4243: PPUSH
4244: LD_INT 100
4246: PPUSH
4247: CALL 56871 0 5
// veh := CreateVehicle ;
4251: LD_ADDR_VAR 0 3
4255: PUSH
4256: CALL_OW 45
4260: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4261: LD_VAR 0 3
4265: PPUSH
4266: LD_INT 3
4268: PPUSH
4269: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4273: LD_VAR 0 3
4277: PPUSH
4278: LD_INT 198
4280: PPUSH
4281: LD_INT 22
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4291: LD_VAR 0 3
4295: PPUSH
4296: LD_INT 4
4298: PPUSH
4299: LD_INT 50
4301: PPUSH
4302: CALL_OW 290
// end else
4306: GO 4327
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4308: LD_INT 4
4310: PPUSH
4311: LD_INT 267
4313: PPUSH
4314: LD_INT 226
4316: PPUSH
4317: LD_INT 5
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 58
// end ; uc_nation := nation_american ;
4327: LD_ADDR_OWVAR 21
4331: PUSH
4332: LD_INT 1
4334: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4335: LD_INT 3
4337: PPUSH
4338: LD_INT 3
4340: PPUSH
4341: LD_INT 3
4343: PPUSH
4344: LD_INT 12
4346: PPUSH
4347: LD_INT 100
4349: PPUSH
4350: CALL 56871 0 5
// veh := CreateVehicle ;
4354: LD_ADDR_VAR 0 3
4358: PUSH
4359: CALL_OW 45
4363: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4364: LD_VAR 0 3
4368: PPUSH
4369: LD_INT 3
4371: PPUSH
4372: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4376: LD_VAR 0 3
4380: PPUSH
4381: LD_INT 218
4383: PPUSH
4384: LD_INT 23
4386: PPUSH
4387: LD_INT 0
4389: PPUSH
4390: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4394: LD_VAR 0 3
4398: PPUSH
4399: LD_INT 4
4401: PPUSH
4402: LD_INT 30
4404: PPUSH
4405: CALL_OW 290
// uc_nation := nation_russian ;
4409: LD_ADDR_OWVAR 21
4413: PUSH
4414: LD_INT 3
4416: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4417: LD_INT 22
4419: PPUSH
4420: LD_INT 3
4422: PPUSH
4423: LD_INT 3
4425: PPUSH
4426: LD_INT 51
4428: PPUSH
4429: LD_INT 100
4431: PPUSH
4432: CALL 56871 0 5
// veh := CreateVehicle ;
4436: LD_ADDR_VAR 0 3
4440: PUSH
4441: CALL_OW 45
4445: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4446: LD_VAR 0 3
4450: PPUSH
4451: LD_INT 3
4453: PPUSH
4454: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4458: LD_VAR 0 3
4462: PPUSH
4463: LD_INT 214
4465: PPUSH
4466: LD_INT 20
4468: PPUSH
4469: LD_INT 0
4471: PPUSH
4472: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 4
4483: PPUSH
4484: LD_INT 40
4486: PPUSH
4487: CALL_OW 290
// end ; end_of_file
4491: LD_VAR 0 1
4495: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4496: LD_INT 0
4498: PPUSH
4499: PPUSH
4500: PPUSH
4501: PPUSH
4502: PPUSH
4503: PPUSH
4504: PPUSH
4505: PPUSH
4506: PPUSH
4507: PPUSH
// InitHc ;
4508: CALL_OW 19
// uc_side := 1 ;
4512: LD_ADDR_OWVAR 20
4516: PUSH
4517: LD_INT 1
4519: ST_TO_ADDR
// uc_nation := 1 ;
4520: LD_ADDR_OWVAR 21
4524: PUSH
4525: LD_INT 1
4527: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4528: LD_INT 387
4530: PPUSH
4531: CALL_OW 274
4535: PPUSH
4536: LD_INT 1
4538: PPUSH
4539: LD_INT 25500
4541: PPUSH
4542: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4546: LD_INT 387
4548: PPUSH
4549: CALL_OW 274
4553: PPUSH
4554: LD_INT 2
4556: PPUSH
4557: LD_INT 4000
4559: PPUSH
4560: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4564: LD_INT 387
4566: PPUSH
4567: CALL_OW 274
4571: PPUSH
4572: LD_INT 3
4574: PPUSH
4575: LD_INT 50
4577: PPUSH
4578: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4582: LD_INT 476
4584: PPUSH
4585: CALL_OW 274
4589: PPUSH
4590: LD_INT 1
4592: PPUSH
4593: LD_INT 7500
4595: PPUSH
4596: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4600: LD_INT 476
4602: PPUSH
4603: CALL_OW 274
4607: PPUSH
4608: LD_INT 2
4610: PPUSH
4611: LD_INT 4000
4613: PPUSH
4614: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4618: LD_INT 476
4620: PPUSH
4621: CALL_OW 274
4625: PPUSH
4626: LD_INT 3
4628: PPUSH
4629: LD_INT 10
4631: PPUSH
4632: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4636: LD_ADDR_EXP 47
4640: PUSH
4641: LD_STRING Powell
4643: PPUSH
4644: CALL_OW 25
4648: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
4649: LD_EXP 47
4653: PPUSH
4654: LD_INT 57
4656: PPUSH
4657: LD_INT 94
4659: PPUSH
4660: LD_INT 0
4662: PPUSH
4663: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
4667: LD_EXP 47
4671: PPUSH
4672: LD_INT 58
4674: PPUSH
4675: LD_INT 94
4677: PPUSH
4678: CALL_OW 118
// tmp := [ ] ;
4682: LD_ADDR_VAR 0 6
4686: PUSH
4687: EMPTY
4688: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4689: LD_ADDR_EXP 14
4693: PUSH
4694: LD_STRING Lisa
4696: PPUSH
4697: LD_EXP 1
4701: NOT
4702: PPUSH
4703: LD_STRING 12p_
4705: PPUSH
4706: CALL 49905 0 3
4710: ST_TO_ADDR
// if Lisa then
4711: LD_EXP 14
4715: IFFALSE 4733
// tmp := tmp ^ Lisa ;
4717: LD_ADDR_VAR 0 6
4721: PUSH
4722: LD_VAR 0 6
4726: PUSH
4727: LD_EXP 14
4731: ADD
4732: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4733: LD_ADDR_EXP 15
4737: PUSH
4738: LD_STRING Donaldson
4740: PPUSH
4741: LD_EXP 1
4745: NOT
4746: PPUSH
4747: LD_STRING 12p_
4749: PPUSH
4750: CALL 49905 0 3
4754: ST_TO_ADDR
// if Donaldson then
4755: LD_EXP 15
4759: IFFALSE 4777
// tmp := tmp ^ Donaldson ;
4761: LD_ADDR_VAR 0 6
4765: PUSH
4766: LD_VAR 0 6
4770: PUSH
4771: LD_EXP 15
4775: ADD
4776: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4777: LD_ADDR_EXP 16
4781: PUSH
4782: LD_STRING Bobby
4784: PPUSH
4785: LD_EXP 1
4789: NOT
4790: PPUSH
4791: LD_STRING 12p_
4793: PPUSH
4794: CALL 49905 0 3
4798: ST_TO_ADDR
// if Bobby then
4799: LD_EXP 16
4803: IFFALSE 4821
// tmp := tmp ^ Bobby ;
4805: LD_ADDR_VAR 0 6
4809: PUSH
4810: LD_VAR 0 6
4814: PUSH
4815: LD_EXP 16
4819: ADD
4820: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4821: LD_ADDR_EXP 17
4825: PUSH
4826: LD_STRING Cyrus
4828: PPUSH
4829: LD_EXP 1
4833: NOT
4834: PPUSH
4835: LD_STRING 12p_
4837: PPUSH
4838: CALL 49905 0 3
4842: ST_TO_ADDR
// if Cyrus then
4843: LD_EXP 17
4847: IFFALSE 4865
// tmp := tmp ^ Cyrus ;
4849: LD_ADDR_VAR 0 6
4853: PUSH
4854: LD_VAR 0 6
4858: PUSH
4859: LD_EXP 17
4863: ADD
4864: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4865: LD_ADDR_EXP 19
4869: PUSH
4870: LD_STRING Brown
4872: PPUSH
4873: LD_EXP 1
4877: NOT
4878: PPUSH
4879: LD_STRING 12p_
4881: PPUSH
4882: CALL 49905 0 3
4886: ST_TO_ADDR
// if Brown then
4887: LD_EXP 19
4891: IFFALSE 4909
// tmp := tmp ^ Brown ;
4893: LD_ADDR_VAR 0 6
4897: PUSH
4898: LD_VAR 0 6
4902: PUSH
4903: LD_EXP 19
4907: ADD
4908: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4909: LD_ADDR_EXP 20
4913: PUSH
4914: LD_STRING Gladstone
4916: PPUSH
4917: LD_EXP 1
4921: NOT
4922: PPUSH
4923: LD_STRING 12p_
4925: PPUSH
4926: CALL 49905 0 3
4930: ST_TO_ADDR
// if Gladstone then
4931: LD_EXP 20
4935: IFFALSE 4953
// tmp := tmp ^ Gladstone ;
4937: LD_ADDR_VAR 0 6
4941: PUSH
4942: LD_VAR 0 6
4946: PUSH
4947: LD_EXP 20
4951: ADD
4952: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4953: LD_ADDR_EXP 21
4957: PUSH
4958: LD_STRING Houten
4960: PPUSH
4961: LD_EXP 1
4965: NOT
4966: PPUSH
4967: LD_STRING 12p_
4969: PPUSH
4970: CALL 49905 0 3
4974: ST_TO_ADDR
// if Houten then
4975: LD_EXP 21
4979: IFFALSE 4997
// tmp := tmp ^ Houten ;
4981: LD_ADDR_VAR 0 6
4985: PUSH
4986: LD_VAR 0 6
4990: PUSH
4991: LD_EXP 21
4995: ADD
4996: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
4997: LD_ADDR_EXP 22
5001: PUSH
5002: LD_STRING Cornel
5004: PPUSH
5005: LD_EXP 1
5009: NOT
5010: PPUSH
5011: LD_STRING 12p_
5013: PPUSH
5014: CALL 49905 0 3
5018: ST_TO_ADDR
// if Cornel then
5019: LD_EXP 22
5023: IFFALSE 5041
// tmp := tmp ^ Cornel ;
5025: LD_ADDR_VAR 0 6
5029: PUSH
5030: LD_VAR 0 6
5034: PUSH
5035: LD_EXP 22
5039: ADD
5040: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5041: LD_ADDR_EXP 23
5045: PUSH
5046: LD_STRING Gary
5048: PPUSH
5049: LD_EXP 1
5053: NOT
5054: PPUSH
5055: LD_STRING 12p_
5057: PPUSH
5058: CALL 49905 0 3
5062: ST_TO_ADDR
// if Gary then
5063: LD_EXP 23
5067: IFFALSE 5085
// tmp := tmp ^ Gary ;
5069: LD_ADDR_VAR 0 6
5073: PUSH
5074: LD_VAR 0 6
5078: PUSH
5079: LD_EXP 23
5083: ADD
5084: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5085: LD_ADDR_EXP 25
5089: PUSH
5090: LD_STRING Kikuchi
5092: PPUSH
5093: LD_EXP 1
5097: NOT
5098: PPUSH
5099: LD_STRING 12p_
5101: PPUSH
5102: CALL 49905 0 3
5106: ST_TO_ADDR
// if Kikuchi then
5107: LD_EXP 25
5111: IFFALSE 5129
// tmp := tmp ^ Kikuchi ;
5113: LD_ADDR_VAR 0 6
5117: PUSH
5118: LD_VAR 0 6
5122: PUSH
5123: LD_EXP 25
5127: ADD
5128: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5129: LD_ADDR_VAR 0 6
5133: PUSH
5134: LD_VAR 0 6
5138: PUSH
5139: LD_STRING 12p_others
5141: PPUSH
5142: CALL_OW 31
5146: UNION
5147: ST_TO_ADDR
// if tmp < 36 then
5148: LD_VAR 0 6
5152: PUSH
5153: LD_INT 36
5155: LESS
5156: IFFALSE 5223
// for i = 1 to 36 - tmp do
5158: LD_ADDR_VAR 0 2
5162: PUSH
5163: DOUBLE
5164: LD_INT 1
5166: DEC
5167: ST_TO_ADDR
5168: LD_INT 36
5170: PUSH
5171: LD_VAR 0 6
5175: MINUS
5176: PUSH
5177: FOR_TO
5178: IFFALSE 5221
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5180: LD_INT 1
5182: PPUSH
5183: LD_VAR 0 2
5187: PUSH
5188: LD_INT 4
5190: MOD
5191: PUSH
5192: LD_INT 1
5194: PLUS
5195: PPUSH
5196: LD_INT 10
5198: PPUSH
5199: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5203: LD_ADDR_VAR 0 6
5207: PUSH
5208: LD_VAR 0 6
5212: PUSH
5213: CALL_OW 44
5217: ADD
5218: ST_TO_ADDR
// end ;
5219: GO 5177
5221: POP
5222: POP
// for i in tmp do
5223: LD_ADDR_VAR 0 2
5227: PUSH
5228: LD_VAR 0 6
5232: PUSH
5233: FOR_IN
5234: IFFALSE 5259
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5236: LD_VAR 0 2
5240: PPUSH
5241: LD_INT 62
5243: PPUSH
5244: LD_INT 93
5246: PPUSH
5247: LD_INT 9
5249: PPUSH
5250: LD_INT 0
5252: PPUSH
5253: CALL_OW 50
5257: GO 5233
5259: POP
5260: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
5261: LD_ADDR_EXP 74
5265: PUSH
5266: LD_EXP 74
5270: PPUSH
5271: LD_INT 4
5273: PPUSH
5274: LD_INT 22
5276: PUSH
5277: LD_INT 1
5279: PUSH
5280: EMPTY
5281: LIST
5282: LIST
5283: PPUSH
5284: CALL_OW 69
5288: PPUSH
5289: CALL_OW 1
5293: ST_TO_ADDR
// uc_side := 0 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 0
5301: ST_TO_ADDR
// uc_nation := 0 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 0
5309: ST_TO_ADDR
// for i = 1 to 4 do
5310: LD_ADDR_VAR 0 2
5314: PUSH
5315: DOUBLE
5316: LD_INT 1
5318: DEC
5319: ST_TO_ADDR
5320: LD_INT 4
5322: PUSH
5323: FOR_TO
5324: IFFALSE 5355
// begin InitHc ;
5326: CALL_OW 19
// hc_class := class_apeman ;
5330: LD_ADDR_OWVAR 28
5334: PUSH
5335: LD_INT 12
5337: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5338: CALL_OW 44
5342: PPUSH
5343: LD_INT 11
5345: PPUSH
5346: LD_INT 0
5348: PPUSH
5349: CALL_OW 49
// end ;
5353: GO 5323
5355: POP
5356: POP
// end ;
5357: LD_VAR 0 1
5361: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5362: LD_EXP 4
5366: NOT
5367: PUSH
5368: LD_INT 4
5370: PPUSH
5371: LD_INT 1
5373: PPUSH
5374: CALL 45113 0 2
5378: NOT
5379: AND
5380: IFFALSE 6152
5382: GO 5384
5384: DISABLE
5385: LD_INT 0
5387: PPUSH
5388: PPUSH
5389: PPUSH
// begin enable ;
5390: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5391: LD_INT 22
5393: PUSH
5394: LD_INT 1
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: PUSH
5401: LD_INT 23
5403: PUSH
5404: LD_INT 1
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PUSH
5411: LD_INT 30
5413: PUSH
5414: LD_INT 3
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: LIST
5425: PPUSH
5426: CALL_OW 69
5430: NOT
5431: IFFALSE 5435
// exit ;
5433: GO 6152
// if Prob ( 40 ) then
5435: LD_INT 40
5437: PPUSH
5438: CALL_OW 13
5442: IFFALSE 5569
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5444: LD_INT 4
5446: PPUSH
5447: LD_INT 5
5449: PUSH
5450: LD_INT 1
5452: PUSH
5453: LD_INT 2
5455: PUSH
5456: LD_INT 7
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: LIST
5463: LIST
5464: PUSH
5465: LD_INT 5
5467: PUSH
5468: LD_INT 1
5470: PUSH
5471: LD_INT 2
5473: PUSH
5474: LD_INT 7
5476: PUSH
5477: EMPTY
5478: LIST
5479: LIST
5480: LIST
5481: LIST
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: LD_INT 1
5488: PUSH
5489: LD_INT 2
5491: PUSH
5492: LD_INT 7
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 5
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 2
5509: PUSH
5510: LD_INT 6
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 5
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 2
5527: PUSH
5528: LD_INT 6
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 5
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 2
5545: PUSH
5546: LD_INT 6
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: LIST
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL 43695 0 2
// end else
5567: GO 5692
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5569: LD_INT 4
5571: PPUSH
5572: LD_INT 5
5574: PUSH
5575: LD_INT 1
5577: PUSH
5578: LD_INT 2
5580: PUSH
5581: LD_INT 7
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: LD_INT 5
5592: PUSH
5593: LD_INT 1
5595: PUSH
5596: LD_INT 2
5598: PUSH
5599: LD_INT 9
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 5
5610: PUSH
5611: LD_INT 1
5613: PUSH
5614: LD_INT 2
5616: PUSH
5617: LD_INT 9
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 5
5628: PUSH
5629: LD_INT 1
5631: PUSH
5632: LD_INT 2
5634: PUSH
5635: LD_INT 6
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: LIST
5642: LIST
5643: PUSH
5644: LD_INT 5
5646: PUSH
5647: LD_INT 1
5649: PUSH
5650: LD_INT 2
5652: PUSH
5653: LD_INT 6
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: LIST
5660: LIST
5661: PUSH
5662: LD_INT 5
5664: PUSH
5665: LD_INT 1
5667: PUSH
5668: LD_INT 2
5670: PUSH
5671: LD_INT 6
5673: PUSH
5674: EMPTY
5675: LIST
5676: LIST
5677: LIST
5678: LIST
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: LIST
5686: LIST
5687: PPUSH
5688: CALL 43695 0 2
// end ; repeat wait ( 0 0$1 ) ;
5692: LD_INT 35
5694: PPUSH
5695: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5699: LD_INT 4
5701: PPUSH
5702: LD_INT 1
5704: PPUSH
5705: CALL 45113 0 2
5709: PUSH
5710: LD_INT 6
5712: GREATEREQUAL
5713: IFFALSE 5692
// wait ( 0 0$30 ) ;
5715: LD_INT 1050
5717: PPUSH
5718: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5722: LD_ADDR_VAR 0 2
5726: PUSH
5727: LD_INT 4
5729: PPUSH
5730: LD_INT 1
5732: PPUSH
5733: CALL 45113 0 2
5737: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5738: LD_ADDR_EXP 93
5742: PUSH
5743: LD_EXP 93
5747: PPUSH
5748: LD_INT 4
5750: PPUSH
5751: LD_EXP 93
5755: PUSH
5756: LD_INT 4
5758: ARRAY
5759: PUSH
5760: LD_VAR 0 2
5764: DIFF
5765: PPUSH
5766: CALL_OW 1
5770: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5771: LD_ADDR_VAR 0 3
5775: PUSH
5776: LD_INT 0
5778: PPUSH
5779: LD_INT 2
5781: PPUSH
5782: CALL_OW 12
5786: ST_TO_ADDR
// if target then
5787: LD_VAR 0 3
5791: IFFALSE 5919
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5793: LD_ADDR_VAR 0 2
5797: PUSH
5798: LD_VAR 0 2
5802: PPUSH
5803: LD_INT 24
5805: PUSH
5806: LD_INT 250
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: PPUSH
5813: CALL_OW 72
5817: ST_TO_ADDR
// for i in tmp do
5818: LD_ADDR_VAR 0 1
5822: PUSH
5823: LD_VAR 0 2
5827: PUSH
5828: FOR_IN
5829: IFFALSE 5869
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5831: LD_VAR 0 1
5835: PPUSH
5836: LD_INT 114
5838: PPUSH
5839: LD_INT 108
5841: PPUSH
5842: CALL_OW 297
5846: PUSH
5847: LD_INT 9
5849: GREATER
5850: IFFALSE 5867
// ComMoveXY ( i , 114 , 108 ) ;
5852: LD_VAR 0 1
5856: PPUSH
5857: LD_INT 114
5859: PPUSH
5860: LD_INT 108
5862: PPUSH
5863: CALL_OW 111
5867: GO 5828
5869: POP
5870: POP
// wait ( 0 0$1 ) ;
5871: LD_INT 35
5873: PPUSH
5874: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5878: LD_VAR 0 2
5882: PPUSH
5883: LD_INT 92
5885: PUSH
5886: LD_INT 114
5888: PUSH
5889: LD_INT 108
5891: PUSH
5892: LD_INT 9
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: PPUSH
5901: CALL_OW 72
5905: PUSH
5906: LD_VAR 0 2
5910: PUSH
5911: LD_INT 1
5913: MINUS
5914: GREATEREQUAL
5915: IFFALSE 5793
// end else
5917: GO 6043
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5919: LD_ADDR_VAR 0 2
5923: PUSH
5924: LD_VAR 0 2
5928: PPUSH
5929: LD_INT 24
5931: PUSH
5932: LD_INT 250
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: PPUSH
5939: CALL_OW 72
5943: ST_TO_ADDR
// for i in tmp do
5944: LD_ADDR_VAR 0 1
5948: PUSH
5949: LD_VAR 0 2
5953: PUSH
5954: FOR_IN
5955: IFFALSE 5995
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5957: LD_VAR 0 1
5961: PPUSH
5962: LD_INT 129
5964: PPUSH
5965: LD_INT 139
5967: PPUSH
5968: CALL_OW 297
5972: PUSH
5973: LD_INT 9
5975: GREATER
5976: IFFALSE 5993
// ComMoveXY ( i , 129 , 139 ) ;
5978: LD_VAR 0 1
5982: PPUSH
5983: LD_INT 129
5985: PPUSH
5986: LD_INT 139
5988: PPUSH
5989: CALL_OW 111
5993: GO 5954
5995: POP
5996: POP
// wait ( 0 0$1 ) ;
5997: LD_INT 35
5999: PPUSH
6000: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6004: LD_VAR 0 2
6008: PPUSH
6009: LD_INT 92
6011: PUSH
6012: LD_INT 129
6014: PUSH
6015: LD_INT 139
6017: PUSH
6018: LD_INT 9
6020: PUSH
6021: EMPTY
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: PPUSH
6027: CALL_OW 72
6031: PUSH
6032: LD_VAR 0 2
6036: PUSH
6037: LD_INT 1
6039: MINUS
6040: GREATEREQUAL
6041: IFFALSE 5919
// end ; repeat wait ( 0 0$1 ) ;
6043: LD_INT 35
6045: PPUSH
6046: CALL_OW 67
// for i in tmp do
6050: LD_ADDR_VAR 0 1
6054: PUSH
6055: LD_VAR 0 2
6059: PUSH
6060: FOR_IN
6061: IFFALSE 6143
// begin if GetLives ( i ) > 251 then
6063: LD_VAR 0 1
6067: PPUSH
6068: CALL_OW 256
6072: PUSH
6073: LD_INT 251
6075: GREATER
6076: IFFALSE 6114
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 81
6085: PUSH
6086: LD_INT 1
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: PPUSH
6093: CALL_OW 69
6097: PPUSH
6098: LD_VAR 0 1
6102: PPUSH
6103: CALL_OW 74
6107: PPUSH
6108: CALL_OW 115
6112: GO 6141
// if IsDead ( i ) then
6114: LD_VAR 0 1
6118: PPUSH
6119: CALL_OW 301
6123: IFFALSE 6141
// tmp := tmp diff i ;
6125: LD_ADDR_VAR 0 2
6129: PUSH
6130: LD_VAR 0 2
6134: PUSH
6135: LD_VAR 0 1
6139: DIFF
6140: ST_TO_ADDR
// end ;
6141: GO 6060
6143: POP
6144: POP
// until not tmp ;
6145: LD_VAR 0 2
6149: NOT
6150: IFFALSE 6043
// end ;
6152: PPOPN 3
6154: END
// every 30 30$00 trigger not americanDestroyed do
6155: LD_EXP 4
6159: NOT
6160: IFFALSE 6225
6162: GO 6164
6164: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6165: LD_INT 63000
6167: PUSH
6168: LD_INT 42000
6170: PUSH
6171: LD_INT 21000
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_OWVAR 67
6183: ARRAY
6184: PPUSH
6185: CALL_OW 67
// if americanDestroyed then
6189: LD_EXP 4
6193: IFFALSE 6197
// exit ;
6195: GO 6225
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6197: LD_INT 4
6199: PPUSH
6200: LD_INT 5
6202: PUSH
6203: LD_INT 3
6205: PUSH
6206: LD_INT 1
6208: PUSH
6209: LD_INT 8
6211: PUSH
6212: EMPTY
6213: LIST
6214: LIST
6215: LIST
6216: LIST
6217: PUSH
6218: EMPTY
6219: LIST
6220: PPUSH
6221: CALL 43695 0 2
// end ; end_of_file
6225: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6226: LD_INT 0
6228: PPUSH
6229: PPUSH
6230: PPUSH
6231: PPUSH
6232: PPUSH
// side := 2 ;
6233: LD_ADDR_VAR 0 5
6237: PUSH
6238: LD_INT 2
6240: ST_TO_ADDR
// InitHc ;
6241: CALL_OW 19
// uc_side := side ;
6245: LD_ADDR_OWVAR 20
6249: PUSH
6250: LD_VAR 0 5
6254: ST_TO_ADDR
// uc_nation := 2 ;
6255: LD_ADDR_OWVAR 21
6259: PUSH
6260: LD_INT 2
6262: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6263: LD_ADDR_VAR 0 4
6267: PUSH
6268: LD_INT 22
6270: PUSH
6271: LD_VAR 0 5
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: PUSH
6280: LD_INT 30
6282: PUSH
6283: LD_INT 32
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 58
6292: PUSH
6293: EMPTY
6294: LIST
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: LIST
6300: PPUSH
6301: CALL_OW 69
6305: ST_TO_ADDR
// for i = 1 to 10 do
6306: LD_ADDR_VAR 0 2
6310: PUSH
6311: DOUBLE
6312: LD_INT 1
6314: DEC
6315: ST_TO_ADDR
6316: LD_INT 10
6318: PUSH
6319: FOR_TO
6320: IFFALSE 6392
// begin uc_nation := nation_nature ;
6322: LD_ADDR_OWVAR 21
6326: PUSH
6327: LD_INT 0
6329: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6330: LD_ADDR_OWVAR 28
6334: PUSH
6335: LD_INT 15
6337: ST_TO_ADDR
// hc_gallery :=  ;
6338: LD_ADDR_OWVAR 33
6342: PUSH
6343: LD_STRING 
6345: ST_TO_ADDR
// hc_name :=  ;
6346: LD_ADDR_OWVAR 26
6350: PUSH
6351: LD_STRING 
6353: ST_TO_ADDR
// un := CreateHuman ;
6354: LD_ADDR_VAR 0 3
6358: PUSH
6359: CALL_OW 44
6363: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6364: LD_VAR 0 3
6368: PPUSH
6369: LD_VAR 0 4
6373: PUSH
6374: LD_VAR 0 4
6378: PUSH
6379: LD_VAR 0 2
6383: MINUS
6384: ARRAY
6385: PPUSH
6386: CALL_OW 52
// end ;
6390: GO 6319
6392: POP
6393: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6394: LD_INT 503
6396: PPUSH
6397: LD_INT 27
6399: PPUSH
6400: LD_STRING 
6402: PPUSH
6403: LD_INT 8
6405: PUSH
6406: LD_INT 9
6408: PUSH
6409: LD_INT 10
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: PUSH
6417: LD_OWVAR 67
6421: ARRAY
6422: PPUSH
6423: LD_INT 3000
6425: PUSH
6426: LD_INT 500
6428: PUSH
6429: LD_INT 150
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: LIST
6436: PPUSH
6437: LD_INT 16
6439: PUSH
6440: LD_INT 6
6442: PUSH
6443: LD_INT 6
6445: PUSH
6446: LD_INT 6
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: LIST
6453: LIST
6454: PPUSH
6455: CALL 60280 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6459: LD_ADDR_EXP 74
6463: PUSH
6464: LD_EXP 74
6468: PPUSH
6469: LD_INT 1
6471: PPUSH
6472: LD_INT 22
6474: PUSH
6475: LD_VAR 0 5
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: PUSH
6484: LD_INT 23
6486: PUSH
6487: LD_INT 2
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 3
6496: PUSH
6497: LD_INT 21
6499: PUSH
6500: LD_INT 2
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PUSH
6511: EMPTY
6512: LIST
6513: LIST
6514: LIST
6515: PPUSH
6516: CALL_OW 69
6520: PPUSH
6521: CALL_OW 1
6525: ST_TO_ADDR
// end ;
6526: LD_VAR 0 1
6530: RET
// export Omar ; export function PrepareOmarAli ; begin
6531: LD_INT 0
6533: PPUSH
// uc_side := 5 ;
6534: LD_ADDR_OWVAR 20
6538: PUSH
6539: LD_INT 5
6541: ST_TO_ADDR
// uc_nation := 2 ;
6542: LD_ADDR_OWVAR 21
6546: PUSH
6547: LD_INT 2
6549: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6550: LD_ADDR_EXP 48
6554: PUSH
6555: LD_STRING Omar
6557: PPUSH
6558: CALL_OW 25
6562: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6563: LD_EXP 48
6567: PPUSH
6568: LD_INT 330
6570: PPUSH
6571: LD_INT 244
6573: PPUSH
6574: LD_INT 0
6576: PPUSH
6577: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6581: LD_EXP 48
6585: PPUSH
6586: LD_INT 22
6588: PUSH
6589: LD_INT 7
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: PPUSH
6596: CALL_OW 69
6600: PPUSH
6601: LD_EXP 48
6605: PPUSH
6606: CALL_OW 74
6610: PPUSH
6611: CALL_OW 112
// end ; end_of_file
6615: LD_VAR 0 1
6619: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6620: LD_INT 0
6622: PPUSH
6623: PPUSH
6624: PPUSH
6625: PPUSH
6626: PPUSH
// side := 8 ;
6627: LD_ADDR_VAR 0 3
6631: PUSH
6632: LD_INT 8
6634: ST_TO_ADDR
// InitHc ;
6635: CALL_OW 19
// uc_side := side ;
6639: LD_ADDR_OWVAR 20
6643: PUSH
6644: LD_VAR 0 3
6648: ST_TO_ADDR
// uc_nation := 2 ;
6649: LD_ADDR_OWVAR 21
6653: PUSH
6654: LD_INT 2
6656: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6657: LD_ADDR_VAR 0 2
6661: PUSH
6662: LD_INT 22
6664: PUSH
6665: LD_VAR 0 3
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: PUSH
6674: LD_INT 21
6676: PUSH
6677: LD_INT 3
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: PPUSH
6688: CALL_OW 69
6692: PUSH
6693: FOR_IN
6694: IFFALSE 6710
// SetBLevel ( i , 10 ) ;
6696: LD_VAR 0 2
6700: PPUSH
6701: LD_INT 10
6703: PPUSH
6704: CALL_OW 241
6708: GO 6693
6710: POP
6711: POP
// Schulz := NewCharacter ( Schulz ) ;
6712: LD_ADDR_EXP 49
6716: PUSH
6717: LD_STRING Schulz
6719: PPUSH
6720: CALL_OW 25
6724: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6725: LD_ADDR_EXP 50
6729: PUSH
6730: LD_STRING Kozlov
6732: PPUSH
6733: LD_INT 0
6735: PPUSH
6736: LD_STRING 
6738: PPUSH
6739: CALL 49905 0 3
6743: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6744: LD_EXP 50
6748: PPUSH
6749: LD_INT 22
6751: PUSH
6752: LD_INT 8
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 23
6761: PUSH
6762: LD_INT 3
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: PUSH
6769: LD_INT 30
6771: PUSH
6772: LD_INT 8
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: PPUSH
6784: CALL_OW 69
6788: PUSH
6789: LD_INT 1
6791: ARRAY
6792: PPUSH
6793: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6797: LD_EXP 50
6801: PPUSH
6802: LD_INT 3
6804: PPUSH
6805: LD_INT 10
6807: PPUSH
6808: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6812: LD_ADDR_VAR 0 5
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 30
6831: PUSH
6832: LD_INT 32
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 58
6841: PUSH
6842: EMPTY
6843: LIST
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: LIST
6849: PPUSH
6850: CALL_OW 69
6854: ST_TO_ADDR
// for i = 1 to 10 do
6855: LD_ADDR_VAR 0 2
6859: PUSH
6860: DOUBLE
6861: LD_INT 1
6863: DEC
6864: ST_TO_ADDR
6865: LD_INT 10
6867: PUSH
6868: FOR_TO
6869: IFFALSE 6941
// begin uc_nation := nation_nature ;
6871: LD_ADDR_OWVAR 21
6875: PUSH
6876: LD_INT 0
6878: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6879: LD_ADDR_OWVAR 28
6883: PUSH
6884: LD_INT 15
6886: ST_TO_ADDR
// hc_gallery :=  ;
6887: LD_ADDR_OWVAR 33
6891: PUSH
6892: LD_STRING 
6894: ST_TO_ADDR
// hc_name :=  ;
6895: LD_ADDR_OWVAR 26
6899: PUSH
6900: LD_STRING 
6902: ST_TO_ADDR
// un := CreateHuman ;
6903: LD_ADDR_VAR 0 4
6907: PUSH
6908: CALL_OW 44
6912: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6913: LD_VAR 0 4
6917: PPUSH
6918: LD_VAR 0 5
6922: PUSH
6923: LD_VAR 0 5
6927: PUSH
6928: LD_VAR 0 2
6932: MINUS
6933: ARRAY
6934: PPUSH
6935: CALL_OW 52
// end ;
6939: GO 6868
6941: POP
6942: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6943: LD_INT 324
6945: PPUSH
6946: LD_INT 3
6948: PPUSH
6949: LD_STRING 
6951: PPUSH
6952: LD_INT 8
6954: PUSH
6955: LD_INT 9
6957: PUSH
6958: LD_INT 10
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: LD_OWVAR 67
6970: ARRAY
6971: PPUSH
6972: LD_INT 3000
6974: PUSH
6975: LD_INT 500
6977: PUSH
6978: LD_INT 150
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: PPUSH
6986: LD_INT 16
6988: PUSH
6989: LD_INT 6
6991: PUSH
6992: LD_INT 6
6994: PUSH
6995: LD_INT 8
6997: PUSH
6998: EMPTY
6999: LIST
7000: LIST
7001: LIST
7002: LIST
7003: PPUSH
7004: CALL 60280 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7008: LD_ADDR_EXP 74
7012: PUSH
7013: LD_EXP 74
7017: PPUSH
7018: LD_INT 3
7020: PPUSH
7021: LD_INT 22
7023: PUSH
7024: LD_VAR 0 3
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 23
7035: PUSH
7036: LD_INT 2
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 21
7048: PUSH
7049: LD_INT 2
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: LIST
7064: PPUSH
7065: CALL_OW 69
7069: PUSH
7070: LD_EXP 49
7074: DIFF
7075: PPUSH
7076: CALL_OW 1
7080: ST_TO_ADDR
// end ;
7081: LD_VAR 0 1
7085: RET
// export function BuildKozlovBomb ; begin
7086: LD_INT 0
7088: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7089: LD_INT 332
7091: PPUSH
7092: CALL_OW 302
7096: NOT
7097: PUSH
7098: LD_INT 336
7100: PPUSH
7101: CALL_OW 302
7105: NOT
7106: OR
7107: IFFALSE 7111
// exit ;
7109: GO 7208
// ComChangeProfession ( Kozlov , 4 ) ;
7111: LD_EXP 50
7115: PPUSH
7116: LD_INT 4
7118: PPUSH
7119: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7123: LD_INT 336
7125: PPUSH
7126: LD_INT 25
7128: PPUSH
7129: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7133: LD_INT 35
7135: PPUSH
7136: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7140: LD_INT 25
7142: PPUSH
7143: LD_INT 8
7145: PPUSH
7146: CALL_OW 321
7150: PUSH
7151: LD_INT 2
7153: EQUAL
7154: IFFALSE 7133
// ComExitBuilding ( Kozlov ) ;
7156: LD_EXP 50
7160: PPUSH
7161: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7165: LD_EXP 50
7169: PPUSH
7170: LD_INT 332
7172: PPUSH
7173: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7177: LD_EXP 50
7181: PPUSH
7182: LD_INT 3
7184: PPUSH
7185: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7189: LD_INT 332
7191: PPUSH
7192: LD_INT 23
7194: PPUSH
7195: LD_INT 3
7197: PPUSH
7198: LD_INT 1
7200: PPUSH
7201: LD_INT 48
7203: PPUSH
7204: CALL_OW 125
// end ;
7208: LD_VAR 0 1
7212: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7213: LD_EXP 3
7217: NOT
7218: PUSH
7219: LD_INT 3
7221: PPUSH
7222: LD_INT 1
7224: PPUSH
7225: CALL 45113 0 2
7229: NOT
7230: AND
7231: IFFALSE 8071
7233: GO 7235
7235: DISABLE
7236: LD_INT 0
7238: PPUSH
7239: PPUSH
7240: PPUSH
// begin enable ;
7241: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7242: LD_INT 22
7244: PUSH
7245: LD_INT 8
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: PUSH
7252: LD_INT 23
7254: PUSH
7255: LD_INT 2
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: PUSH
7262: LD_INT 30
7264: PUSH
7265: LD_INT 3
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: PPUSH
7277: CALL_OW 69
7281: NOT
7282: IFFALSE 7286
// exit ;
7284: GO 8071
// if Prob ( 40 ) then
7286: LD_INT 40
7288: PPUSH
7289: CALL_OW 13
7293: IFFALSE 7420
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7295: LD_INT 3
7297: PPUSH
7298: LD_INT 14
7300: PUSH
7301: LD_INT 1
7303: PUSH
7304: LD_INT 2
7306: PUSH
7307: LD_INT 28
7309: PUSH
7310: EMPTY
7311: LIST
7312: LIST
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 14
7318: PUSH
7319: LD_INT 1
7321: PUSH
7322: LD_INT 2
7324: PUSH
7325: LD_INT 28
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PUSH
7334: LD_INT 14
7336: PUSH
7337: LD_INT 1
7339: PUSH
7340: LD_INT 2
7342: PUSH
7343: LD_INT 28
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 14
7354: PUSH
7355: LD_INT 1
7357: PUSH
7358: LD_INT 2
7360: PUSH
7361: LD_INT 28
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 14
7372: PUSH
7373: LD_INT 1
7375: PUSH
7376: LD_INT 2
7378: PUSH
7379: LD_INT 28
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 14
7390: PUSH
7391: LD_INT 1
7393: PUSH
7394: LD_INT 2
7396: PUSH
7397: LD_INT 26
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: LIST
7410: LIST
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL 43695 0 2
// end else
7418: GO 7611
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 14
7425: PUSH
7426: LD_INT 1
7428: PUSH
7429: LD_INT 2
7431: PUSH
7432: LD_INT 27
7434: PUSH
7435: LD_INT 26
7437: PUSH
7438: LD_INT 26
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: PUSH
7446: LD_OWVAR 67
7450: ARRAY
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: LIST
7456: LIST
7457: PUSH
7458: LD_INT 14
7460: PUSH
7461: LD_INT 1
7463: PUSH
7464: LD_INT 2
7466: PUSH
7467: LD_INT 27
7469: PUSH
7470: LD_INT 26
7472: PUSH
7473: LD_INT 26
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: LIST
7480: PUSH
7481: LD_OWVAR 67
7485: ARRAY
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: LIST
7491: LIST
7492: PUSH
7493: LD_INT 14
7495: PUSH
7496: LD_INT 1
7498: PUSH
7499: LD_INT 2
7501: PUSH
7502: LD_INT 26
7504: PUSH
7505: LD_INT 26
7507: PUSH
7508: LD_INT 29
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: LIST
7515: PUSH
7516: LD_OWVAR 67
7520: ARRAY
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 13
7530: PUSH
7531: LD_INT 1
7533: PUSH
7534: LD_INT 2
7536: PUSH
7537: LD_INT 26
7539: PUSH
7540: LD_INT 29
7542: PUSH
7543: LD_INT 29
7545: PUSH
7546: EMPTY
7547: LIST
7548: LIST
7549: LIST
7550: PUSH
7551: LD_OWVAR 67
7555: ARRAY
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: LIST
7561: LIST
7562: PUSH
7563: LD_INT 13
7565: PUSH
7566: LD_INT 1
7568: PUSH
7569: LD_INT 2
7571: PUSH
7572: LD_INT 29
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: LIST
7579: LIST
7580: PUSH
7581: LD_INT 14
7583: PUSH
7584: LD_INT 1
7586: PUSH
7587: LD_INT 2
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PPUSH
7607: CALL 43695 0 2
// end ; repeat wait ( 0 0$1 ) ;
7611: LD_INT 35
7613: PPUSH
7614: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7618: LD_INT 3
7620: PPUSH
7621: LD_INT 1
7623: PPUSH
7624: CALL 45113 0 2
7628: PUSH
7629: LD_INT 6
7631: GREATEREQUAL
7632: IFFALSE 7611
// wait ( 0 0$30 ) ;
7634: LD_INT 1050
7636: PPUSH
7637: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7641: LD_ADDR_VAR 0 2
7645: PUSH
7646: LD_INT 3
7648: PPUSH
7649: LD_INT 1
7651: PPUSH
7652: CALL 45113 0 2
7656: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7657: LD_ADDR_EXP 93
7661: PUSH
7662: LD_EXP 93
7666: PPUSH
7667: LD_INT 3
7669: PPUSH
7670: LD_EXP 93
7674: PUSH
7675: LD_INT 3
7677: ARRAY
7678: PUSH
7679: LD_VAR 0 2
7683: DIFF
7684: PPUSH
7685: CALL_OW 1
7689: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7690: LD_ADDR_VAR 0 3
7694: PUSH
7695: LD_INT 0
7697: PPUSH
7698: LD_INT 2
7700: PPUSH
7701: CALL_OW 12
7705: ST_TO_ADDR
// if target then
7706: LD_VAR 0 3
7710: IFFALSE 7838
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7712: LD_ADDR_VAR 0 2
7716: PUSH
7717: LD_VAR 0 2
7721: PPUSH
7722: LD_INT 24
7724: PUSH
7725: LD_INT 250
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PPUSH
7732: CALL_OW 72
7736: ST_TO_ADDR
// for i in tmp do
7737: LD_ADDR_VAR 0 1
7741: PUSH
7742: LD_VAR 0 2
7746: PUSH
7747: FOR_IN
7748: IFFALSE 7788
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7750: LD_VAR 0 1
7754: PPUSH
7755: LD_INT 89
7757: PPUSH
7758: LD_INT 71
7760: PPUSH
7761: CALL_OW 297
7765: PUSH
7766: LD_INT 9
7768: GREATER
7769: IFFALSE 7786
// ComMoveXY ( i , 89 , 71 ) ;
7771: LD_VAR 0 1
7775: PPUSH
7776: LD_INT 89
7778: PPUSH
7779: LD_INT 71
7781: PPUSH
7782: CALL_OW 111
7786: GO 7747
7788: POP
7789: POP
// wait ( 0 0$1 ) ;
7790: LD_INT 35
7792: PPUSH
7793: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7797: LD_VAR 0 2
7801: PPUSH
7802: LD_INT 92
7804: PUSH
7805: LD_INT 89
7807: PUSH
7808: LD_INT 71
7810: PUSH
7811: LD_INT 9
7813: PUSH
7814: EMPTY
7815: LIST
7816: LIST
7817: LIST
7818: LIST
7819: PPUSH
7820: CALL_OW 72
7824: PUSH
7825: LD_VAR 0 2
7829: PUSH
7830: LD_INT 1
7832: MINUS
7833: GREATEREQUAL
7834: IFFALSE 7712
// end else
7836: GO 7962
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7838: LD_ADDR_VAR 0 2
7842: PUSH
7843: LD_VAR 0 2
7847: PPUSH
7848: LD_INT 24
7850: PUSH
7851: LD_INT 250
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PPUSH
7858: CALL_OW 72
7862: ST_TO_ADDR
// for i in tmp do
7863: LD_ADDR_VAR 0 1
7867: PUSH
7868: LD_VAR 0 2
7872: PUSH
7873: FOR_IN
7874: IFFALSE 7914
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7876: LD_VAR 0 1
7880: PPUSH
7881: LD_INT 147
7883: PPUSH
7884: LD_INT 4
7886: PPUSH
7887: CALL_OW 297
7891: PUSH
7892: LD_INT 9
7894: GREATER
7895: IFFALSE 7912
// ComMoveXY ( i , 147 , 4 ) ;
7897: LD_VAR 0 1
7901: PPUSH
7902: LD_INT 147
7904: PPUSH
7905: LD_INT 4
7907: PPUSH
7908: CALL_OW 111
7912: GO 7873
7914: POP
7915: POP
// wait ( 0 0$1 ) ;
7916: LD_INT 35
7918: PPUSH
7919: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7923: LD_VAR 0 2
7927: PPUSH
7928: LD_INT 92
7930: PUSH
7931: LD_INT 147
7933: PUSH
7934: LD_INT 4
7936: PUSH
7937: LD_INT 9
7939: PUSH
7940: EMPTY
7941: LIST
7942: LIST
7943: LIST
7944: LIST
7945: PPUSH
7946: CALL_OW 72
7950: PUSH
7951: LD_VAR 0 2
7955: PUSH
7956: LD_INT 1
7958: MINUS
7959: GREATEREQUAL
7960: IFFALSE 7838
// end ; repeat wait ( 0 0$1 ) ;
7962: LD_INT 35
7964: PPUSH
7965: CALL_OW 67
// for i in tmp do
7969: LD_ADDR_VAR 0 1
7973: PUSH
7974: LD_VAR 0 2
7978: PUSH
7979: FOR_IN
7980: IFFALSE 8062
// begin if GetLives ( i ) > 251 then
7982: LD_VAR 0 1
7986: PPUSH
7987: CALL_OW 256
7991: PUSH
7992: LD_INT 251
7994: GREATER
7995: IFFALSE 8033
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
7997: LD_VAR 0 1
8001: PPUSH
8002: LD_INT 81
8004: PUSH
8005: LD_INT 8
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: PPUSH
8012: CALL_OW 69
8016: PPUSH
8017: LD_VAR 0 1
8021: PPUSH
8022: CALL_OW 74
8026: PPUSH
8027: CALL_OW 115
8031: GO 8060
// if IsDead ( i ) then
8033: LD_VAR 0 1
8037: PPUSH
8038: CALL_OW 301
8042: IFFALSE 8060
// tmp := tmp diff i ;
8044: LD_ADDR_VAR 0 2
8048: PUSH
8049: LD_VAR 0 2
8053: PUSH
8054: LD_VAR 0 1
8058: DIFF
8059: ST_TO_ADDR
// end ;
8060: GO 7979
8062: POP
8063: POP
// until not tmp ;
8064: LD_VAR 0 2
8068: NOT
8069: IFFALSE 7962
// end ;
8071: PPOPN 3
8073: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8074: LD_EXP 50
8078: PPUSH
8079: CALL_OW 302
8083: PUSH
8084: LD_EXP 3
8088: NOT
8089: AND
8090: IFFALSE 8099
8092: GO 8094
8094: DISABLE
// BuildKozlovBomb ;
8095: CALL 7086 0 0
8099: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8100: LD_INT 22
8102: PUSH
8103: LD_INT 8
8105: PUSH
8106: EMPTY
8107: LIST
8108: LIST
8109: PUSH
8110: LD_INT 34
8112: PUSH
8113: LD_INT 48
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PPUSH
8124: CALL_OW 69
8128: IFFALSE 8176
8130: GO 8132
8132: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8133: LD_INT 22
8135: PUSH
8136: LD_INT 8
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: PUSH
8143: LD_INT 34
8145: PUSH
8146: LD_INT 48
8148: PUSH
8149: EMPTY
8150: LIST
8151: LIST
8152: PUSH
8153: EMPTY
8154: LIST
8155: LIST
8156: PPUSH
8157: CALL_OW 69
8161: PUSH
8162: LD_INT 1
8164: ARRAY
8165: PPUSH
8166: LD_INT 173
8168: PPUSH
8169: LD_INT 96
8171: PPUSH
8172: CALL_OW 116
// end ; end_of_file
8176: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8177: LD_INT 0
8179: PPUSH
8180: PPUSH
8181: PPUSH
8182: PPUSH
8183: PPUSH
8184: PPUSH
8185: PPUSH
8186: PPUSH
8187: PPUSH
// side := 3 ;
8188: LD_ADDR_VAR 0 6
8192: PUSH
8193: LD_INT 3
8195: ST_TO_ADDR
// InitHc ;
8196: CALL_OW 19
// uc_side := side ;
8200: LD_ADDR_OWVAR 20
8204: PUSH
8205: LD_VAR 0 6
8209: ST_TO_ADDR
// uc_nation := 3 ;
8210: LD_ADDR_OWVAR 21
8214: PUSH
8215: LD_INT 3
8217: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8218: LD_ADDR_VAR 0 2
8222: PUSH
8223: LD_INT 22
8225: PUSH
8226: LD_VAR 0 6
8230: PUSH
8231: EMPTY
8232: LIST
8233: LIST
8234: PUSH
8235: LD_INT 21
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: PUSH
8245: EMPTY
8246: LIST
8247: LIST
8248: PPUSH
8249: CALL_OW 69
8253: PUSH
8254: FOR_IN
8255: IFFALSE 8271
// SetBLevel ( i , 10 ) ;
8257: LD_VAR 0 2
8261: PPUSH
8262: LD_INT 10
8264: PPUSH
8265: CALL_OW 241
8269: GO 8254
8271: POP
8272: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8273: LD_ADDR_VAR 0 9
8277: PUSH
8278: LD_INT 22
8280: PUSH
8281: LD_VAR 0 6
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: PUSH
8290: LD_INT 30
8292: PUSH
8293: LD_INT 34
8295: PUSH
8296: EMPTY
8297: LIST
8298: LIST
8299: PUSH
8300: EMPTY
8301: LIST
8302: LIST
8303: PPUSH
8304: CALL_OW 69
8308: ST_TO_ADDR
// if teleport then
8309: LD_VAR 0 9
8313: IFFALSE 8334
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8315: LD_VAR 0 9
8319: PUSH
8320: LD_INT 1
8322: ARRAY
8323: PPUSH
8324: LD_INT 123
8326: PPUSH
8327: LD_INT 122
8329: PPUSH
8330: CALL_OW 243
// hc_importance := 0 ;
8334: LD_ADDR_OWVAR 32
8338: PUSH
8339: LD_INT 0
8341: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8342: LD_ADDR_EXP 51
8346: PUSH
8347: LD_STRING Platonov
8349: PPUSH
8350: CALL_OW 25
8354: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8355: LD_ADDR_EXP 52
8359: PUSH
8360: LD_STRING Yakotich
8362: PPUSH
8363: CALL_OW 25
8367: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8368: LD_ADDR_EXP 53
8372: PUSH
8373: LD_STRING Gleb
8375: PPUSH
8376: CALL_OW 25
8380: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8381: LD_STRING 03_Cornel
8383: PPUSH
8384: CALL_OW 28
8388: IFFALSE 8436
// begin Bierezov := NewCharacter ( Mikhail ) ;
8390: LD_ADDR_EXP 54
8394: PUSH
8395: LD_STRING Mikhail
8397: PPUSH
8398: CALL_OW 25
8402: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8403: LD_EXP 54
8407: PPUSH
8408: LD_INT 197
8410: PPUSH
8411: LD_INT 111
8413: PPUSH
8414: LD_INT 9
8416: PPUSH
8417: LD_INT 0
8419: PPUSH
8420: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8424: LD_EXP 54
8428: PPUSH
8429: LD_INT 3
8431: PPUSH
8432: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8436: LD_EXP 51
8440: PPUSH
8441: LD_INT 126
8443: PPUSH
8444: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8448: LD_EXP 52
8452: PPUSH
8453: LD_INT 197
8455: PPUSH
8456: LD_INT 111
8458: PPUSH
8459: LD_INT 9
8461: PPUSH
8462: LD_INT 0
8464: PPUSH
8465: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8469: LD_EXP 53
8473: PPUSH
8474: LD_INT 197
8476: PPUSH
8477: LD_INT 111
8479: PPUSH
8480: LD_INT 9
8482: PPUSH
8483: LD_INT 0
8485: PPUSH
8486: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8490: LD_ADDR_VAR 0 5
8494: PUSH
8495: LD_INT 126
8497: PPUSH
8498: LD_INT 2
8500: PPUSH
8501: LD_STRING zhukov
8503: PPUSH
8504: LD_INT 9
8506: PUSH
8507: LD_INT 10
8509: PUSH
8510: LD_INT 10
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: LIST
8517: PUSH
8518: LD_OWVAR 67
8522: ARRAY
8523: PPUSH
8524: LD_INT 90000
8526: PUSH
8527: LD_INT 1000
8529: PUSH
8530: LD_INT 300
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: LIST
8537: PPUSH
8538: LD_INT 21
8540: PUSH
8541: LD_INT 8
8543: PUSH
8544: LD_INT 13
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL 60280 0 6
8560: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8561: LD_ADDR_VAR 0 4
8565: PUSH
8566: LD_INT 267
8568: PPUSH
8569: CALL_OW 274
8573: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8574: LD_VAR 0 4
8578: PPUSH
8579: LD_INT 1
8581: PPUSH
8582: LD_INT 5000
8584: PPUSH
8585: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8589: LD_VAR 0 4
8593: PPUSH
8594: LD_INT 2
8596: PPUSH
8597: LD_INT 200
8599: PPUSH
8600: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8604: LD_VAR 0 4
8608: PPUSH
8609: LD_INT 3
8611: PPUSH
8612: LD_INT 200
8614: PPUSH
8615: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8619: LD_ADDR_EXP 74
8623: PUSH
8624: LD_EXP 74
8628: PPUSH
8629: LD_INT 2
8631: PPUSH
8632: LD_VAR 0 5
8636: PUSH
8637: LD_INT 22
8639: PUSH
8640: LD_VAR 0 6
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PUSH
8649: LD_INT 3
8651: PUSH
8652: LD_INT 21
8654: PUSH
8655: LD_INT 2
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: PPUSH
8670: CALL_OW 69
8674: UNION
8675: PUSH
8676: LD_EXP 51
8680: DIFF
8681: PPUSH
8682: CALL_OW 1
8686: ST_TO_ADDR
// behemoths := [ ] ;
8687: LD_ADDR_EXP 55
8691: PUSH
8692: EMPTY
8693: ST_TO_ADDR
// behemothBuilders := [ ] ;
8694: LD_ADDR_EXP 56
8698: PUSH
8699: EMPTY
8700: ST_TO_ADDR
// j := 3 ;
8701: LD_ADDR_VAR 0 3
8705: PUSH
8706: LD_INT 3
8708: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8709: LD_ADDR_VAR 0 2
8713: PUSH
8714: LD_INT 22
8716: PUSH
8717: LD_INT 3
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: PUSH
8724: LD_INT 25
8726: PUSH
8727: LD_INT 3
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PPUSH
8738: CALL_OW 69
8742: PUSH
8743: FOR_IN
8744: IFFALSE 8794
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8746: LD_ADDR_EXP 56
8750: PUSH
8751: LD_EXP 56
8755: PPUSH
8756: LD_VAR 0 2
8760: PPUSH
8761: CALL 92616 0 2
8765: ST_TO_ADDR
// j := j - 1 ;
8766: LD_ADDR_VAR 0 3
8770: PUSH
8771: LD_VAR 0 3
8775: PUSH
8776: LD_INT 1
8778: MINUS
8779: ST_TO_ADDR
// if j = 0 then
8780: LD_VAR 0 3
8784: PUSH
8785: LD_INT 0
8787: EQUAL
8788: IFFALSE 8792
// break ;
8790: GO 8794
// end ;
8792: GO 8743
8794: POP
8795: POP
// end ;
8796: LD_VAR 0 1
8800: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8801: LD_INT 0
8803: PPUSH
8804: PPUSH
8805: PPUSH
8806: PPUSH
8807: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8808: LD_ADDR_VAR 0 4
8812: PUSH
8813: LD_INT 209
8815: PUSH
8816: LD_INT 149
8818: PUSH
8819: EMPTY
8820: LIST
8821: LIST
8822: PUSH
8823: LD_INT 219
8825: PUSH
8826: LD_INT 154
8828: PUSH
8829: EMPTY
8830: LIST
8831: LIST
8832: PUSH
8833: LD_INT 223
8835: PUSH
8836: LD_INT 149
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: PUSH
8843: LD_INT 232
8845: PUSH
8846: LD_INT 155
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: ST_TO_ADDR
// if not behemothBuilders then
8859: LD_EXP 56
8863: NOT
8864: IFFALSE 8868
// exit ;
8866: GO 8972
// j := 1 ;
8868: LD_ADDR_VAR 0 3
8872: PUSH
8873: LD_INT 1
8875: ST_TO_ADDR
// for i in behemothBuilders do
8876: LD_ADDR_VAR 0 2
8880: PUSH
8881: LD_EXP 56
8885: PUSH
8886: FOR_IN
8887: IFFALSE 8970
// begin if IsInUnit ( i ) then
8889: LD_VAR 0 2
8893: PPUSH
8894: CALL_OW 310
8898: IFFALSE 8909
// ComExitBuilding ( i ) ;
8900: LD_VAR 0 2
8904: PPUSH
8905: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8909: LD_VAR 0 2
8913: PPUSH
8914: LD_INT 37
8916: PPUSH
8917: LD_VAR 0 4
8921: PUSH
8922: LD_VAR 0 3
8926: ARRAY
8927: PUSH
8928: LD_INT 1
8930: ARRAY
8931: PPUSH
8932: LD_VAR 0 4
8936: PUSH
8937: LD_VAR 0 3
8941: ARRAY
8942: PUSH
8943: LD_INT 2
8945: ARRAY
8946: PPUSH
8947: LD_INT 0
8949: PPUSH
8950: CALL_OW 230
// j := j + 1 ;
8954: LD_ADDR_VAR 0 3
8958: PUSH
8959: LD_VAR 0 3
8963: PUSH
8964: LD_INT 1
8966: PLUS
8967: ST_TO_ADDR
// end ;
8968: GO 8886
8970: POP
8971: POP
// end ;
8972: LD_VAR 0 1
8976: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8977: LD_INT 3
8979: PPUSH
8980: CALL 92664 0 1
8984: PUSH
8985: LD_INT 22
8987: PUSH
8988: LD_INT 3
8990: PUSH
8991: EMPTY
8992: LIST
8993: LIST
8994: PUSH
8995: LD_INT 30
8997: PUSH
8998: LD_INT 37
9000: PUSH
9001: EMPTY
9002: LIST
9003: LIST
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: PPUSH
9009: CALL_OW 69
9013: NOT
9014: AND
9015: IFFALSE 9201
9017: GO 9019
9019: DISABLE
9020: LD_INT 0
9022: PPUSH
9023: PPUSH
// begin enable ;
9024: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9025: LD_ADDR_VAR 0 2
9029: PUSH
9030: LD_INT 3
9032: PPUSH
9033: CALL 92664 0 1
9037: ST_TO_ADDR
// for i in tmp do
9038: LD_ADDR_VAR 0 1
9042: PUSH
9043: LD_VAR 0 2
9047: PUSH
9048: FOR_IN
9049: IFFALSE 9199
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9051: LD_VAR 0 1
9055: PPUSH
9056: LD_INT 7
9058: PPUSH
9059: CALL_OW 308
9063: PUSH
9064: LD_VAR 0 1
9068: PPUSH
9069: CALL_OW 110
9073: PUSH
9074: LD_INT 2
9076: EQUAL
9077: NOT
9078: AND
9079: IFFALSE 9093
// SetTag ( i , 2 ) ;
9081: LD_VAR 0 1
9085: PPUSH
9086: LD_INT 2
9088: PPUSH
9089: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9093: LD_INT 81
9095: PUSH
9096: LD_INT 3
9098: PUSH
9099: EMPTY
9100: LIST
9101: LIST
9102: PUSH
9103: LD_INT 91
9105: PUSH
9106: LD_VAR 0 1
9110: PUSH
9111: LD_INT 12
9113: PUSH
9114: EMPTY
9115: LIST
9116: LIST
9117: LIST
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: PPUSH
9123: CALL_OW 69
9127: NOT
9128: PUSH
9129: LD_VAR 0 1
9133: PPUSH
9134: CALL_OW 110
9138: PUSH
9139: LD_INT 2
9141: EQUAL
9142: NOT
9143: AND
9144: IFFALSE 9163
// ComAgressiveMove ( i , 64 , 93 ) else
9146: LD_VAR 0 1
9150: PPUSH
9151: LD_INT 64
9153: PPUSH
9154: LD_INT 93
9156: PPUSH
9157: CALL_OW 114
9161: GO 9197
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9163: LD_VAR 0 1
9167: PPUSH
9168: LD_INT 81
9170: PUSH
9171: LD_INT 3
9173: PUSH
9174: EMPTY
9175: LIST
9176: LIST
9177: PPUSH
9178: CALL_OW 69
9182: PPUSH
9183: LD_VAR 0 1
9187: PPUSH
9188: CALL_OW 74
9192: PPUSH
9193: CALL_OW 115
// end ;
9197: GO 9048
9199: POP
9200: POP
// end ;
9201: PPOPN 2
9203: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9204: LD_EXP 2
9208: NOT
9209: PUSH
9210: LD_INT 2
9212: PPUSH
9213: LD_INT 1
9215: PPUSH
9216: CALL 45113 0 2
9220: NOT
9221: AND
9222: IFFALSE 10142
9224: GO 9226
9226: DISABLE
9227: LD_INT 0
9229: PPUSH
9230: PPUSH
9231: PPUSH
9232: PPUSH
// begin enable ;
9233: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9234: LD_INT 22
9236: PUSH
9237: LD_INT 3
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: PUSH
9244: LD_INT 30
9246: PUSH
9247: LD_INT 3
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PPUSH
9258: CALL_OW 69
9262: NOT
9263: IFFALSE 9267
// exit ;
9265: GO 10142
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9267: LD_ADDR_VAR 0 4
9271: PUSH
9272: LD_INT 22
9274: PUSH
9275: LD_INT 3
9277: PUSH
9278: EMPTY
9279: LIST
9280: LIST
9281: PUSH
9282: LD_INT 30
9284: PUSH
9285: LD_INT 34
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: PUSH
9292: EMPTY
9293: LIST
9294: LIST
9295: PPUSH
9296: CALL_OW 69
9300: ST_TO_ADDR
// if Prob ( 40 ) then
9301: LD_INT 40
9303: PPUSH
9304: CALL_OW 13
9308: IFFALSE 9435
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9310: LD_INT 2
9312: PPUSH
9313: LD_INT 22
9315: PUSH
9316: LD_INT 3
9318: PUSH
9319: LD_INT 3
9321: PUSH
9322: LD_INT 49
9324: PUSH
9325: EMPTY
9326: LIST
9327: LIST
9328: LIST
9329: LIST
9330: PUSH
9331: LD_INT 22
9333: PUSH
9334: LD_INT 3
9336: PUSH
9337: LD_INT 3
9339: PUSH
9340: LD_INT 49
9342: PUSH
9343: EMPTY
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: PUSH
9349: LD_INT 22
9351: PUSH
9352: LD_INT 3
9354: PUSH
9355: LD_INT 3
9357: PUSH
9358: LD_INT 49
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: LIST
9365: LIST
9366: PUSH
9367: LD_INT 24
9369: PUSH
9370: LD_INT 3
9372: PUSH
9373: LD_INT 3
9375: PUSH
9376: LD_INT 46
9378: PUSH
9379: EMPTY
9380: LIST
9381: LIST
9382: LIST
9383: LIST
9384: PUSH
9385: LD_INT 24
9387: PUSH
9388: LD_INT 3
9390: PUSH
9391: LD_INT 3
9393: PUSH
9394: LD_INT 46
9396: PUSH
9397: EMPTY
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: PUSH
9403: LD_INT 24
9405: PUSH
9406: LD_INT 3
9408: PUSH
9409: LD_INT 3
9411: PUSH
9412: LD_INT 46
9414: PUSH
9415: EMPTY
9416: LIST
9417: LIST
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: LIST
9425: LIST
9426: LIST
9427: LIST
9428: PPUSH
9429: CALL 43695 0 2
// end else
9433: GO 9558
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9435: LD_INT 2
9437: PPUSH
9438: LD_INT 24
9440: PUSH
9441: LD_INT 3
9443: PUSH
9444: LD_INT 3
9446: PUSH
9447: LD_INT 47
9449: PUSH
9450: EMPTY
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: PUSH
9456: LD_INT 24
9458: PUSH
9459: LD_INT 3
9461: PUSH
9462: LD_INT 3
9464: PUSH
9465: LD_INT 47
9467: PUSH
9468: EMPTY
9469: LIST
9470: LIST
9471: LIST
9472: LIST
9473: PUSH
9474: LD_INT 24
9476: PUSH
9477: LD_INT 3
9479: PUSH
9480: LD_INT 3
9482: PUSH
9483: LD_INT 47
9485: PUSH
9486: EMPTY
9487: LIST
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_INT 24
9494: PUSH
9495: LD_INT 3
9497: PUSH
9498: LD_INT 3
9500: PUSH
9501: LD_INT 46
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: PUSH
9510: LD_INT 24
9512: PUSH
9513: LD_INT 3
9515: PUSH
9516: LD_INT 3
9518: PUSH
9519: LD_INT 46
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: LIST
9526: LIST
9527: PUSH
9528: LD_INT 24
9530: PUSH
9531: LD_INT 3
9533: PUSH
9534: LD_INT 3
9536: PUSH
9537: LD_INT 46
9539: PUSH
9540: EMPTY
9541: LIST
9542: LIST
9543: LIST
9544: LIST
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: LIST
9553: PPUSH
9554: CALL 43695 0 2
// end ; if Difficulty > 1 then
9558: LD_OWVAR 67
9562: PUSH
9563: LD_INT 1
9565: GREATER
9566: IFFALSE 9596
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9568: LD_INT 2
9570: PPUSH
9571: LD_INT 24
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 3
9579: PUSH
9580: LD_INT 47
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: LIST
9587: LIST
9588: PUSH
9589: EMPTY
9590: LIST
9591: PPUSH
9592: CALL 43695 0 2
// repeat wait ( 0 0$1 ) ;
9596: LD_INT 35
9598: PPUSH
9599: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9603: LD_INT 2
9605: PPUSH
9606: LD_INT 1
9608: PPUSH
9609: CALL 45113 0 2
9613: PUSH
9614: LD_INT 6
9616: PUSH
9617: LD_INT 7
9619: PUSH
9620: LD_INT 7
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: PUSH
9628: LD_OWVAR 67
9632: ARRAY
9633: GREATEREQUAL
9634: IFFALSE 9596
// wait ( 0 0$30 ) ;
9636: LD_INT 1050
9638: PPUSH
9639: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9643: LD_ADDR_VAR 0 2
9647: PUSH
9648: LD_INT 2
9650: PPUSH
9651: LD_INT 1
9653: PPUSH
9654: CALL 45113 0 2
9658: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9659: LD_ADDR_EXP 93
9663: PUSH
9664: LD_EXP 93
9668: PPUSH
9669: LD_INT 2
9671: PPUSH
9672: LD_EXP 93
9676: PUSH
9677: LD_INT 2
9679: ARRAY
9680: PUSH
9681: LD_VAR 0 2
9685: DIFF
9686: PPUSH
9687: CALL_OW 1
9691: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9692: LD_ADDR_VAR 0 3
9696: PUSH
9697: LD_INT 0
9699: PPUSH
9700: LD_INT 1
9702: PPUSH
9703: CALL_OW 12
9707: ST_TO_ADDR
// if target then
9708: LD_VAR 0 3
9712: IFFALSE 9840
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9714: LD_ADDR_VAR 0 2
9718: PUSH
9719: LD_VAR 0 2
9723: PPUSH
9724: LD_INT 24
9726: PUSH
9727: LD_INT 250
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PPUSH
9734: CALL_OW 72
9738: ST_TO_ADDR
// for i in tmp do
9739: LD_ADDR_VAR 0 1
9743: PUSH
9744: LD_VAR 0 2
9748: PUSH
9749: FOR_IN
9750: IFFALSE 9790
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9752: LD_VAR 0 1
9756: PPUSH
9757: LD_INT 139
9759: PPUSH
9760: LD_INT 89
9762: PPUSH
9763: CALL_OW 297
9767: PUSH
9768: LD_INT 9
9770: GREATER
9771: IFFALSE 9788
// ComMoveXY ( i , 139 , 89 ) ;
9773: LD_VAR 0 1
9777: PPUSH
9778: LD_INT 139
9780: PPUSH
9781: LD_INT 89
9783: PPUSH
9784: CALL_OW 111
9788: GO 9749
9790: POP
9791: POP
// wait ( 0 0$1 ) ;
9792: LD_INT 35
9794: PPUSH
9795: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9799: LD_VAR 0 2
9803: PPUSH
9804: LD_INT 92
9806: PUSH
9807: LD_INT 139
9809: PUSH
9810: LD_INT 89
9812: PUSH
9813: LD_INT 9
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: LIST
9820: LIST
9821: PPUSH
9822: CALL_OW 72
9826: PUSH
9827: LD_VAR 0 2
9831: PUSH
9832: LD_INT 1
9834: MINUS
9835: GREATEREQUAL
9836: IFFALSE 9714
// end else
9838: GO 9982
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9840: LD_VAR 0 2
9844: PPUSH
9845: LD_VAR 0 4
9849: PUSH
9850: LD_INT 1
9852: ARRAY
9853: PPUSH
9854: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9858: LD_ADDR_VAR 0 2
9862: PUSH
9863: LD_VAR 0 2
9867: PPUSH
9868: LD_INT 24
9870: PUSH
9871: LD_INT 250
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: PPUSH
9878: CALL_OW 72
9882: ST_TO_ADDR
// for i in tmp do
9883: LD_ADDR_VAR 0 1
9887: PUSH
9888: LD_VAR 0 2
9892: PUSH
9893: FOR_IN
9894: IFFALSE 9934
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9896: LD_VAR 0 1
9900: PPUSH
9901: LD_INT 124
9903: PPUSH
9904: LD_INT 139
9906: PPUSH
9907: CALL_OW 297
9911: PUSH
9912: LD_INT 9
9914: GREATER
9915: IFFALSE 9932
// ComMoveXY ( i , 124 , 139 ) ;
9917: LD_VAR 0 1
9921: PPUSH
9922: LD_INT 124
9924: PPUSH
9925: LD_INT 139
9927: PPUSH
9928: CALL_OW 111
9932: GO 9893
9934: POP
9935: POP
// wait ( 0 0$1 ) ;
9936: LD_INT 35
9938: PPUSH
9939: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9943: LD_VAR 0 2
9947: PPUSH
9948: LD_INT 92
9950: PUSH
9951: LD_INT 124
9953: PUSH
9954: LD_INT 139
9956: PUSH
9957: LD_INT 9
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: LIST
9964: LIST
9965: PPUSH
9966: CALL_OW 72
9970: PUSH
9971: LD_VAR 0 2
9975: PUSH
9976: LD_INT 1
9978: MINUS
9979: GREATEREQUAL
9980: IFFALSE 9858
// end ; repeat wait ( 0 0$1 ) ;
9982: LD_INT 35
9984: PPUSH
9985: CALL_OW 67
// for i in tmp do
9989: LD_ADDR_VAR 0 1
9993: PUSH
9994: LD_VAR 0 2
9998: PUSH
9999: FOR_IN
10000: IFFALSE 10133
// begin if GetLives ( i ) > 251 then
10002: LD_VAR 0 1
10006: PPUSH
10007: CALL_OW 256
10011: PUSH
10012: LD_INT 251
10014: GREATER
10015: IFFALSE 10104
// begin if GetWeapon ( i ) = ru_time_lapser then
10017: LD_VAR 0 1
10021: PPUSH
10022: CALL_OW 264
10026: PUSH
10027: LD_INT 49
10029: EQUAL
10030: IFFALSE 10068
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10032: LD_VAR 0 1
10036: PPUSH
10037: LD_INT 81
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PPUSH
10047: CALL_OW 69
10051: PPUSH
10052: LD_VAR 0 1
10056: PPUSH
10057: CALL_OW 74
10061: PPUSH
10062: CALL_OW 112
10066: GO 10102
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10068: LD_VAR 0 1
10072: PPUSH
10073: LD_INT 81
10075: PUSH
10076: LD_INT 3
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PPUSH
10083: CALL_OW 69
10087: PPUSH
10088: LD_VAR 0 1
10092: PPUSH
10093: CALL_OW 74
10097: PPUSH
10098: CALL_OW 115
// end else
10102: GO 10131
// if IsDead ( i ) then
10104: LD_VAR 0 1
10108: PPUSH
10109: CALL_OW 301
10113: IFFALSE 10131
// tmp := tmp diff i ;
10115: LD_ADDR_VAR 0 2
10119: PUSH
10120: LD_VAR 0 2
10124: PUSH
10125: LD_VAR 0 1
10129: DIFF
10130: ST_TO_ADDR
// end ;
10131: GO 9999
10133: POP
10134: POP
// until not tmp ;
10135: LD_VAR 0 2
10139: NOT
10140: IFFALSE 9982
// end ;
10142: PPOPN 4
10144: END
// every 30 30$00 trigger not russianDestroyed do
10145: LD_EXP 2
10149: NOT
10150: IFFALSE 10215
10152: GO 10154
10154: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10155: LD_INT 105000
10157: PUSH
10158: LD_INT 84000
10160: PUSH
10161: LD_INT 63000
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: PUSH
10169: LD_OWVAR 67
10173: ARRAY
10174: PPUSH
10175: CALL_OW 67
// if russianDestroyed then
10179: LD_EXP 2
10183: IFFALSE 10187
// exit ;
10185: GO 10215
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10187: LD_INT 2
10189: PPUSH
10190: LD_INT 23
10192: PUSH
10193: LD_INT 3
10195: PUSH
10196: LD_INT 1
10198: PUSH
10199: LD_INT 48
10201: PUSH
10202: EMPTY
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: PPUSH
10211: CALL 43695 0 2
// end ; end_of_file
10215: END
// export function CustomEvent ( event ) ; begin
10216: LD_INT 0
10218: PPUSH
// end ;
10219: LD_VAR 0 2
10223: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10224: LD_VAR 0 2
10228: PPUSH
10229: LD_VAR 0 3
10233: PPUSH
10234: LD_INT 15
10236: PPUSH
10237: CALL_OW 309
10241: IFFALSE 10250
// YouLost ( MothContaminate ) ;
10243: LD_STRING MothContaminate
10245: PPUSH
10246: CALL_OW 104
// end ;
10250: PPOPN 3
10252: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10253: LD_VAR 0 2
10257: PPUSH
10258: LD_VAR 0 3
10262: PPUSH
10263: LD_INT 15
10265: PPUSH
10266: CALL_OW 309
10270: IFFALSE 10286
// begin wait ( 0 0$6 ) ;
10272: LD_INT 210
10274: PPUSH
10275: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10279: LD_STRING MothContaminateBomb
10281: PPUSH
10282: CALL_OW 104
// end ; end ;
10286: PPOPN 3
10288: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10289: LD_VAR 0 1
10293: PUSH
10294: LD_EXP 12
10298: EQUAL
10299: IFFALSE 10310
// begin YouLost ( JMM ) ;
10301: LD_STRING JMM
10303: PPUSH
10304: CALL_OW 104
// exit ;
10308: GO 10359
// end ; if un = Powell then
10310: LD_VAR 0 1
10314: PUSH
10315: LD_EXP 47
10319: EQUAL
10320: IFFALSE 10330
// americanDestroyed := true ;
10322: LD_ADDR_EXP 4
10326: PUSH
10327: LD_INT 1
10329: ST_TO_ADDR
// if un = Platonov then
10330: LD_VAR 0 1
10334: PUSH
10335: LD_EXP 51
10339: EQUAL
10340: IFFALSE 10350
// russianDestroyed := true ;
10342: LD_ADDR_EXP 2
10346: PUSH
10347: LD_INT 1
10349: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10350: LD_VAR 0 1
10354: PPUSH
10355: CALL 47087 0 1
// end ;
10359: PPOPN 1
10361: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10362: LD_VAR 0 1
10366: PPUSH
10367: LD_VAR 0 2
10371: PPUSH
10372: CALL 49287 0 2
// end ;
10376: PPOPN 2
10378: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10379: LD_VAR 0 1
10383: PPUSH
10384: CALL 48355 0 1
// end ;
10388: PPOPN 1
10390: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10391: LD_VAR 0 1
10395: PUSH
10396: LD_INT 22
10398: PUSH
10399: LD_INT 8
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: PUSH
10406: LD_INT 30
10408: PUSH
10409: LD_INT 2
10411: PUSH
10412: EMPTY
10413: LIST
10414: LIST
10415: PUSH
10416: LD_INT 23
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: LIST
10430: PPUSH
10431: CALL_OW 69
10435: IN
10436: IFFALSE 10463
// begin ComUpgrade ( building ) ;
10438: LD_VAR 0 1
10442: PPUSH
10443: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10447: LD_EXP 50
10451: PPUSH
10452: LD_VAR 0 1
10456: PPUSH
10457: CALL 59844 0 2
// exit ;
10461: GO 10472
// end ; MCE_BuildingComplete ( building ) ;
10463: LD_VAR 0 1
10467: PPUSH
10468: CALL 48596 0 1
// end ;
10472: PPOPN 1
10474: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10475: LD_VAR 0 1
10479: PPUSH
10480: LD_VAR 0 2
10484: PPUSH
10485: CALL 46783 0 2
// end ;
10489: PPOPN 2
10491: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10492: LD_VAR 0 1
10496: PPUSH
10497: LD_VAR 0 2
10501: PPUSH
10502: LD_VAR 0 3
10506: PPUSH
10507: LD_VAR 0 4
10511: PPUSH
10512: LD_VAR 0 5
10516: PPUSH
10517: CALL 46403 0 5
// end ;
10521: PPOPN 5
10523: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10524: LD_VAR 0 1
10528: PPUSH
10529: LD_VAR 0 2
10533: PPUSH
10534: CALL 45999 0 2
// end ;
10538: PPOPN 2
10540: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10541: LD_VAR 0 1
10545: PPUSH
10546: LD_VAR 0 2
10550: PPUSH
10551: LD_VAR 0 3
10555: PPUSH
10556: LD_VAR 0 4
10560: PPUSH
10561: CALL 45837 0 4
// end ;
10565: PPOPN 4
10567: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10568: LD_VAR 0 1
10572: PPUSH
10573: LD_VAR 0 2
10577: PPUSH
10578: LD_VAR 0 3
10582: PPUSH
10583: CALL 45612 0 3
// end ;
10587: PPOPN 3
10589: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10590: LD_VAR 0 1
10594: PPUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: CALL 45497 0 2
// end ;
10604: PPOPN 2
10606: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10607: LD_VAR 0 1
10611: PPUSH
10612: LD_VAR 0 2
10616: PPUSH
10617: CALL 49548 0 2
// end ;
10621: PPOPN 2
10623: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10624: LD_VAR 0 1
10628: PPUSH
10629: LD_VAR 0 2
10633: PPUSH
10634: LD_VAR 0 3
10638: PPUSH
10639: LD_VAR 0 4
10643: PPUSH
10644: CALL 49764 0 4
// end ;
10648: PPOPN 4
10650: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10651: LD_VAR 0 1
10655: PPUSH
10656: LD_VAR 0 2
10660: PPUSH
10661: CALL 45306 0 2
// end ;
10665: PPOPN 2
10667: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 93016 0 1
// end ; end_of_file
10677: PPOPN 1
10679: END
// export function Action ; begin
10680: LD_INT 0
10682: PPUSH
// InGameOn ;
10683: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10687: LD_INT 206
10689: PPUSH
10690: LD_INT 11
10692: PPUSH
10693: CALL_OW 86
// wait ( 0 0$1 ) ;
10697: LD_INT 35
10699: PPUSH
10700: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10704: LD_EXP 12
10708: PPUSH
10709: LD_STRING DStart-JMM-JMM-1
10711: PPUSH
10712: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10716: LD_EXP 44
10720: PPUSH
10721: LD_STRING DStart-JMM-Bur-1
10723: PPUSH
10724: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10728: LD_EXP 12
10732: PPUSH
10733: LD_STRING DStart-JMM-JMM-2
10735: PPUSH
10736: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10740: LD_EXP 44
10744: PPUSH
10745: LD_STRING DStart-JMM-Bur-2
10747: PPUSH
10748: CALL_OW 88
// InGameOff ;
10752: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10756: LD_STRING MStart
10758: PPUSH
10759: CALL_OW 337
// end ;
10763: LD_VAR 0 1
10767: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10768: LD_INT 7
10770: PPUSH
10771: LD_INT 255
10773: PPUSH
10774: LD_INT 219
10776: PPUSH
10777: CALL_OW 293
10781: IFFALSE 11390
10783: GO 10785
10785: DISABLE
10786: LD_INT 0
10788: PPUSH
// begin wait ( 0 0$3 ) ;
10789: LD_INT 105
10791: PPUSH
10792: CALL_OW 67
// alienSpotted := true ;
10796: LD_ADDR_EXP 7
10800: PUSH
10801: LD_INT 1
10803: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10804: LD_ADDR_VAR 0 1
10808: PUSH
10809: LD_INT 22
10811: PUSH
10812: LD_INT 7
10814: PUSH
10815: EMPTY
10816: LIST
10817: LIST
10818: PUSH
10819: LD_INT 23
10821: PUSH
10822: LD_INT 3
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: PUSH
10829: LD_INT 21
10831: PUSH
10832: LD_INT 1
10834: PUSH
10835: EMPTY
10836: LIST
10837: LIST
10838: PUSH
10839: LD_INT 26
10841: PUSH
10842: LD_INT 1
10844: PUSH
10845: EMPTY
10846: LIST
10847: LIST
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: PPUSH
10855: CALL_OW 69
10859: PUSH
10860: LD_EXP 44
10864: PUSH
10865: LD_EXP 32
10869: PUSH
10870: LD_EXP 34
10874: PUSH
10875: LD_EXP 35
10879: PUSH
10880: LD_EXP 42
10884: PUSH
10885: LD_EXP 41
10889: PUSH
10890: LD_EXP 36
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: DIFF
10904: ST_TO_ADDR
// DialogueOn ;
10905: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
10909: LD_INT 255
10911: PPUSH
10912: LD_INT 219
10914: PPUSH
10915: LD_INT 7
10917: PPUSH
10918: LD_INT 20
10920: NEG
10921: PPUSH
10922: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
10926: LD_INT 255
10928: PPUSH
10929: LD_INT 219
10931: PPUSH
10932: CALL_OW 86
// if speaker then
10936: LD_VAR 0 1
10940: IFFALSE 10958
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
10942: LD_VAR 0 1
10946: PUSH
10947: LD_INT 1
10949: ARRAY
10950: PPUSH
10951: LD_STRING DAlienBase-RSol1-1
10953: PPUSH
10954: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
10958: LD_EXP 12
10962: PPUSH
10963: LD_STRING DAlienBase-JMM-1
10965: PPUSH
10966: CALL_OW 88
// if IsOk ( Burlak ) then
10970: LD_EXP 44
10974: PPUSH
10975: CALL_OW 302
10979: IFFALSE 11000
// begin dwait ( 0 0$1 ) ;
10981: LD_INT 35
10983: PPUSH
10984: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
10988: LD_EXP 44
10992: PPUSH
10993: LD_STRING DAlienBase-Bur-1
10995: PPUSH
10996: CALL_OW 88
// end ; if IsOk ( Roth ) then
11000: LD_EXP 13
11004: PPUSH
11005: CALL_OW 302
11009: IFFALSE 11023
// Say ( Roth , DAlienBase-Roth-1 ) ;
11011: LD_EXP 13
11015: PPUSH
11016: LD_STRING DAlienBase-Roth-1
11018: PPUSH
11019: CALL_OW 88
// if IsOk ( Gossudarov ) then
11023: LD_EXP 30
11027: PPUSH
11028: CALL_OW 302
11032: IFFALSE 11048
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11034: LD_EXP 30
11038: PPUSH
11039: LD_STRING DAlienBase-Gos-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11165
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11048: LD_ADDR_VAR 0 1
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_INT 7
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 25
11065: PUSH
11066: LD_INT 4
11068: PUSH
11069: EMPTY
11070: LIST
11071: LIST
11072: PUSH
11073: LD_INT 21
11075: PUSH
11076: LD_INT 1
11078: PUSH
11079: EMPTY
11080: LIST
11081: LIST
11082: PUSH
11083: LD_INT 26
11085: PUSH
11086: LD_INT 1
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PPUSH
11099: CALL_OW 69
11103: PUSH
11104: LD_EXP 13
11108: PUSH
11109: LD_EXP 12
11113: PUSH
11114: LD_EXP 44
11118: PUSH
11119: LD_EXP 32
11123: PUSH
11124: LD_EXP 42
11128: PUSH
11129: LD_EXP 41
11133: PUSH
11134: EMPTY
11135: LIST
11136: LIST
11137: LIST
11138: LIST
11139: LIST
11140: LIST
11141: DIFF
11142: ST_TO_ADDR
// if speaker then
11143: LD_VAR 0 1
11147: IFFALSE 11165
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11149: LD_VAR 0 1
11153: PUSH
11154: LD_INT 1
11156: ARRAY
11157: PPUSH
11158: LD_STRING DAlienBase-Sci1-1
11160: PPUSH
11161: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11165: LD_INT 255
11167: PPUSH
11168: LD_INT 219
11170: PPUSH
11171: LD_INT 7
11173: PPUSH
11174: CALL_OW 331
// DialogueOff ;
11178: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11182: LD_INT 35
11184: PPUSH
11185: CALL_OW 67
// until IsSelected ( alien ) ;
11189: LD_INT 1
11191: PPUSH
11192: CALL_OW 306
11196: IFFALSE 11182
// if not artifactIResearched or not artifactIIResearched then
11198: LD_EXP 9
11202: NOT
11203: PUSH
11204: LD_EXP 10
11208: NOT
11209: OR
11210: IFFALSE 11390
// begin if IsOk ( Roth ) then
11212: LD_EXP 13
11216: PPUSH
11217: CALL_OW 302
11221: IFFALSE 11237
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11223: LD_EXP 13
11227: PPUSH
11228: LD_STRING DAlieBaseNotReady-Roth-1
11230: PPUSH
11231: CALL_OW 88
11235: GO 11390
// if IsOk ( Gossudarov ) then
11237: LD_EXP 30
11241: PPUSH
11242: CALL_OW 302
11246: IFFALSE 11262
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11248: LD_EXP 30
11252: PPUSH
11253: LD_STRING DAlieBaseNotReady-Gos-1
11255: PPUSH
11256: CALL_OW 88
11260: GO 11390
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11262: LD_ADDR_VAR 0 1
11266: PUSH
11267: LD_INT 22
11269: PUSH
11270: LD_INT 7
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: PUSH
11277: LD_INT 23
11279: PUSH
11280: LD_INT 3
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: PUSH
11287: LD_INT 25
11289: PUSH
11290: LD_INT 4
11292: PUSH
11293: EMPTY
11294: LIST
11295: LIST
11296: PUSH
11297: LD_INT 21
11299: PUSH
11300: LD_INT 1
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: PUSH
11307: LD_INT 26
11309: PUSH
11310: LD_INT 1
11312: PUSH
11313: EMPTY
11314: LIST
11315: LIST
11316: PUSH
11317: EMPTY
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: LIST
11323: PPUSH
11324: CALL_OW 69
11328: PUSH
11329: LD_EXP 13
11333: PUSH
11334: LD_EXP 12
11338: PUSH
11339: LD_EXP 44
11343: PUSH
11344: LD_EXP 32
11348: PUSH
11349: LD_EXP 42
11353: PUSH
11354: LD_EXP 41
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: LIST
11363: LIST
11364: LIST
11365: LIST
11366: DIFF
11367: ST_TO_ADDR
// if speaker then
11368: LD_VAR 0 1
11372: IFFALSE 11390
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11374: LD_VAR 0 1
11378: PUSH
11379: LD_INT 1
11381: ARRAY
11382: PPUSH
11383: LD_STRING DAlieBaseNotReady-RSci1-1
11385: PPUSH
11386: CALL_OW 88
// end ; end ; end ;
11390: PPOPN 1
11392: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11393: LD_INT 24
11395: PPUSH
11396: LD_INT 7
11398: PPUSH
11399: CALL_OW 321
11403: PUSH
11404: LD_INT 2
11406: EQUAL
11407: IFFALSE 12098
11409: GO 11411
11411: DISABLE
11412: LD_INT 0
11414: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11415: LD_ADDR_VAR 0 1
11419: PUSH
11420: LD_INT 22
11422: PUSH
11423: LD_INT 7
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 23
11432: PUSH
11433: LD_INT 3
11435: PUSH
11436: EMPTY
11437: LIST
11438: LIST
11439: PUSH
11440: LD_INT 25
11442: PUSH
11443: LD_INT 4
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PUSH
11450: LD_INT 21
11452: PUSH
11453: LD_INT 1
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: PUSH
11460: LD_INT 26
11462: PUSH
11463: LD_INT 1
11465: PUSH
11466: EMPTY
11467: LIST
11468: LIST
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: LIST
11474: LIST
11475: LIST
11476: PPUSH
11477: CALL_OW 69
11481: PUSH
11482: LD_EXP 13
11486: PUSH
11487: LD_EXP 12
11491: PUSH
11492: LD_EXP 44
11496: PUSH
11497: LD_EXP 32
11501: PUSH
11502: LD_EXP 42
11506: PUSH
11507: LD_EXP 41
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: DIFF
11520: ST_TO_ADDR
// if not speaker then
11521: LD_VAR 0 1
11525: NOT
11526: IFFALSE 11530
// exit ;
11528: GO 12098
// DialogueOn ;
11530: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11534: LD_VAR 0 1
11538: PUSH
11539: LD_INT 1
11541: ARRAY
11542: PPUSH
11543: LD_STRING DArtefTechnology-RSci1-1
11545: PPUSH
11546: CALL_OW 88
// if IsOk ( Burlak ) then
11550: LD_EXP 44
11554: PPUSH
11555: CALL_OW 302
11559: IFFALSE 11573
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11561: LD_EXP 44
11565: PPUSH
11566: LD_STRING DArtefTechnology-Bur-1
11568: PPUSH
11569: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11573: LD_VAR 0 1
11577: PUSH
11578: LD_INT 1
11580: ARRAY
11581: PPUSH
11582: LD_STRING DArtefTechnology-RSci1-2
11584: PPUSH
11585: CALL_OW 88
// if Denis then
11589: LD_EXP 18
11593: IFFALSE 11610
// speaker := [ Denis ] else
11595: LD_ADDR_VAR 0 1
11599: PUSH
11600: LD_EXP 18
11604: PUSH
11605: EMPTY
11606: LIST
11607: ST_TO_ADDR
11608: GO 11716
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11610: LD_ADDR_VAR 0 1
11614: PUSH
11615: LD_INT 22
11617: PUSH
11618: LD_INT 7
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PUSH
11625: LD_INT 23
11627: PUSH
11628: LD_INT 1
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: PUSH
11635: LD_INT 25
11637: PUSH
11638: LD_INT 4
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: PUSH
11645: LD_INT 21
11647: PUSH
11648: LD_INT 1
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PUSH
11655: LD_INT 26
11657: PUSH
11658: LD_INT 1
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: PPUSH
11672: CALL_OW 69
11676: PUSH
11677: LD_EXP 13
11681: PUSH
11682: LD_EXP 12
11686: PUSH
11687: LD_EXP 44
11691: PUSH
11692: LD_EXP 32
11696: PUSH
11697: LD_EXP 42
11701: PUSH
11702: LD_EXP 41
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: DIFF
11715: ST_TO_ADDR
// if speaker then
11716: LD_VAR 0 1
11720: IFFALSE 11738
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11722: LD_VAR 0 1
11726: PUSH
11727: LD_INT 1
11729: ARRAY
11730: PPUSH
11731: LD_STRING DArtefTechnology-Sci1-2
11733: PPUSH
11734: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11738: LD_ADDR_VAR 0 1
11742: PUSH
11743: LD_INT 22
11745: PUSH
11746: LD_INT 7
11748: PUSH
11749: EMPTY
11750: LIST
11751: LIST
11752: PUSH
11753: LD_INT 23
11755: PUSH
11756: LD_INT 3
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: PUSH
11763: LD_INT 25
11765: PUSH
11766: LD_INT 4
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PUSH
11773: LD_INT 21
11775: PUSH
11776: LD_INT 1
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: LD_INT 26
11785: PUSH
11786: LD_INT 1
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: LIST
11799: PPUSH
11800: CALL_OW 69
11804: PUSH
11805: LD_EXP 13
11809: PUSH
11810: LD_EXP 12
11814: PUSH
11815: LD_EXP 44
11819: PUSH
11820: LD_EXP 32
11824: PUSH
11825: LD_EXP 42
11829: PUSH
11830: LD_EXP 41
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: DIFF
11843: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
11844: LD_VAR 0 1
11848: PUSH
11849: LD_EXP 6
11853: PUSH
11854: LD_EXP 5
11858: OR
11859: AND
11860: IFFALSE 12094
// begin if arabianDestroyed and IsOk ( Burlak ) then
11862: LD_EXP 5
11866: PUSH
11867: LD_EXP 44
11871: PPUSH
11872: CALL_OW 302
11876: AND
11877: IFFALSE 11893
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
11879: LD_EXP 44
11883: PPUSH
11884: LD_STRING DArtefTechnology-Bur-2
11886: PPUSH
11887: CALL_OW 88
11891: GO 11905
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
11893: LD_EXP 12
11897: PPUSH
11898: LD_STRING DArtefTechnology-JMM-2
11900: PPUSH
11901: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
11905: LD_VAR 0 1
11909: PUSH
11910: LD_INT 1
11912: ARRAY
11913: PPUSH
11914: LD_STRING DArtefTechnology-RSci1-3
11916: PPUSH
11917: CALL_OW 88
// if Denis then
11921: LD_EXP 18
11925: IFFALSE 11942
// speaker := [ Denis ] else
11927: LD_ADDR_VAR 0 1
11931: PUSH
11932: LD_EXP 18
11936: PUSH
11937: EMPTY
11938: LIST
11939: ST_TO_ADDR
11940: GO 12048
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11942: LD_ADDR_VAR 0 1
11946: PUSH
11947: LD_INT 22
11949: PUSH
11950: LD_INT 7
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 23
11959: PUSH
11960: LD_INT 1
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 25
11969: PUSH
11970: LD_INT 4
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 21
11979: PUSH
11980: LD_INT 1
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 26
11989: PUSH
11990: LD_INT 1
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PUSH
11997: EMPTY
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: PPUSH
12004: CALL_OW 69
12008: PUSH
12009: LD_EXP 13
12013: PUSH
12014: LD_EXP 12
12018: PUSH
12019: LD_EXP 44
12023: PUSH
12024: LD_EXP 32
12028: PUSH
12029: LD_EXP 42
12033: PUSH
12034: LD_EXP 41
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: LIST
12043: LIST
12044: LIST
12045: LIST
12046: DIFF
12047: ST_TO_ADDR
// if speaker then
12048: LD_VAR 0 1
12052: IFFALSE 12094
// if alienSpotted then
12054: LD_EXP 7
12058: IFFALSE 12078
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12060: LD_VAR 0 1
12064: PUSH
12065: LD_INT 1
12067: ARRAY
12068: PPUSH
12069: LD_STRING DArtefTechnology-Sci1-3
12071: PPUSH
12072: CALL_OW 88
12076: GO 12094
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12078: LD_VAR 0 1
12082: PUSH
12083: LD_INT 1
12085: ARRAY
12086: PPUSH
12087: LD_STRING DArtefTechnology-Sci1-3a
12089: PPUSH
12090: CALL_OW 88
// end ; DialogueOff ;
12094: CALL_OW 7
// end ;
12098: PPOPN 1
12100: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12101: LD_EXP 9
12105: IFFALSE 12300
12107: GO 12109
12109: DISABLE
12110: LD_INT 0
12112: PPUSH
// begin if Denis then
12113: LD_EXP 18
12117: IFFALSE 12134
// speaker := [ Denis ] else
12119: LD_ADDR_VAR 0 1
12123: PUSH
12124: LD_EXP 18
12128: PUSH
12129: EMPTY
12130: LIST
12131: ST_TO_ADDR
12132: GO 12240
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12134: LD_ADDR_VAR 0 1
12138: PUSH
12139: LD_INT 22
12141: PUSH
12142: LD_INT 7
12144: PUSH
12145: EMPTY
12146: LIST
12147: LIST
12148: PUSH
12149: LD_INT 23
12151: PUSH
12152: LD_INT 1
12154: PUSH
12155: EMPTY
12156: LIST
12157: LIST
12158: PUSH
12159: LD_INT 25
12161: PUSH
12162: LD_INT 4
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 21
12171: PUSH
12172: LD_INT 1
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: LD_INT 26
12181: PUSH
12182: LD_INT 1
12184: PUSH
12185: EMPTY
12186: LIST
12187: LIST
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: LIST
12193: LIST
12194: LIST
12195: PPUSH
12196: CALL_OW 69
12200: PUSH
12201: LD_EXP 13
12205: PUSH
12206: LD_EXP 12
12210: PUSH
12211: LD_EXP 44
12215: PUSH
12216: LD_EXP 32
12220: PUSH
12221: LD_EXP 42
12225: PUSH
12226: LD_EXP 41
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: LIST
12235: LIST
12236: LIST
12237: LIST
12238: DIFF
12239: ST_TO_ADDR
// if not speaker then
12240: LD_VAR 0 1
12244: NOT
12245: IFFALSE 12249
// exit ;
12247: GO 12300
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12249: LD_VAR 0 1
12253: PUSH
12254: LD_INT 1
12256: ARRAY
12257: PPUSH
12258: LD_STRING DArtefTechnologyAm-Sci1-1
12260: PPUSH
12261: CALL_OW 88
// if IsOk ( Burlak ) then
12265: LD_EXP 44
12269: PPUSH
12270: CALL_OW 302
12274: IFFALSE 12288
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12276: LD_EXP 44
12280: PPUSH
12281: LD_STRING DArtefTechnologyAm-Bur-1
12283: PPUSH
12284: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12288: LD_EXP 12
12292: PPUSH
12293: LD_STRING DArtefTechnologyAm-JMM-1
12295: PPUSH
12296: CALL_OW 88
// end ;
12300: PPOPN 1
12302: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12303: LD_EXP 10
12307: IFFALSE 12518
12309: GO 12311
12311: DISABLE
12312: LD_INT 0
12314: PPUSH
// begin if Denis then
12315: LD_EXP 18
12319: IFFALSE 12336
// speaker := [ Denis ] else
12321: LD_ADDR_VAR 0 1
12325: PUSH
12326: LD_EXP 18
12330: PUSH
12331: EMPTY
12332: LIST
12333: ST_TO_ADDR
12334: GO 12442
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12336: LD_ADDR_VAR 0 1
12340: PUSH
12341: LD_INT 22
12343: PUSH
12344: LD_INT 7
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: LD_INT 23
12353: PUSH
12354: LD_INT 3
12356: PUSH
12357: EMPTY
12358: LIST
12359: LIST
12360: PUSH
12361: LD_INT 25
12363: PUSH
12364: LD_INT 4
12366: PUSH
12367: EMPTY
12368: LIST
12369: LIST
12370: PUSH
12371: LD_INT 21
12373: PUSH
12374: LD_INT 1
12376: PUSH
12377: EMPTY
12378: LIST
12379: LIST
12380: PUSH
12381: LD_INT 26
12383: PUSH
12384: LD_INT 1
12386: PUSH
12387: EMPTY
12388: LIST
12389: LIST
12390: PUSH
12391: EMPTY
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 69
12402: PUSH
12403: LD_EXP 13
12407: PUSH
12408: LD_EXP 12
12412: PUSH
12413: LD_EXP 44
12417: PUSH
12418: LD_EXP 32
12422: PUSH
12423: LD_EXP 42
12427: PUSH
12428: LD_EXP 41
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: LIST
12437: LIST
12438: LIST
12439: LIST
12440: DIFF
12441: ST_TO_ADDR
// if not speaker then
12442: LD_VAR 0 1
12446: NOT
12447: IFFALSE 12451
// exit ;
12449: GO 12518
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12451: LD_VAR 0 1
12455: PUSH
12456: LD_INT 1
12458: ARRAY
12459: PPUSH
12460: LD_STRING DArtefTechnologyRu-RSci1-1
12462: PPUSH
12463: CALL_OW 88
// if IsOk ( Burlak ) then
12467: LD_EXP 44
12471: PPUSH
12472: CALL_OW 302
12476: IFFALSE 12490
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12478: LD_EXP 44
12482: PPUSH
12483: LD_STRING DArtefTechnologyRu-Bur-1
12485: PPUSH
12486: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12490: LD_VAR 0 1
12494: PUSH
12495: LD_INT 1
12497: ARRAY
12498: PPUSH
12499: LD_STRING DArtefTechnologyRu-RSci1-2
12501: PPUSH
12502: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12506: LD_EXP 12
12510: PPUSH
12511: LD_STRING DArtefTechnologyRu-JMM-1
12513: PPUSH
12514: CALL_OW 88
// end ;
12518: PPOPN 1
12520: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12521: LD_INT 24
12523: PPUSH
12524: LD_INT 7
12526: PPUSH
12527: CALL_OW 321
12531: PUSH
12532: LD_INT 2
12534: EQUAL
12535: PUSH
12536: LD_INT 1
12538: PPUSH
12539: CALL_OW 255
12543: PUSH
12544: LD_INT 7
12546: EQUAL
12547: AND
12548: IFFALSE 12708
12550: GO 12552
12552: DISABLE
12553: LD_INT 0
12555: PPUSH
// begin if Denis then
12556: LD_EXP 18
12560: IFFALSE 12577
// speaker := [ Denis ] else
12562: LD_ADDR_VAR 0 1
12566: PUSH
12567: LD_EXP 18
12571: PUSH
12572: EMPTY
12573: LIST
12574: ST_TO_ADDR
12575: GO 12683
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12577: LD_ADDR_VAR 0 1
12581: PUSH
12582: LD_INT 22
12584: PUSH
12585: LD_INT 7
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: PUSH
12592: LD_INT 23
12594: PUSH
12595: LD_INT 1
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 25
12604: PUSH
12605: LD_INT 4
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PUSH
12612: LD_INT 21
12614: PUSH
12615: LD_INT 1
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 26
12624: PUSH
12625: LD_INT 1
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: LIST
12636: LIST
12637: LIST
12638: PPUSH
12639: CALL_OW 69
12643: PUSH
12644: LD_EXP 13
12648: PUSH
12649: LD_EXP 12
12653: PUSH
12654: LD_EXP 44
12658: PUSH
12659: LD_EXP 32
12663: PUSH
12664: LD_EXP 42
12668: PUSH
12669: LD_EXP 41
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: DIFF
12682: ST_TO_ADDR
// if not speaker then
12683: LD_VAR 0 1
12687: NOT
12688: IFFALSE 12692
// exit ;
12690: GO 12708
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12692: LD_VAR 0 1
12696: PUSH
12697: LD_INT 1
12699: ARRAY
12700: PPUSH
12701: LD_STRING DArtefTechnologyArStart-Sci1-1
12703: PPUSH
12704: CALL_OW 88
// end ;
12708: PPOPN 1
12710: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12711: LD_EXP 11
12715: IFFALSE 12996
12717: GO 12719
12719: DISABLE
12720: LD_INT 0
12722: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12723: LD_ADDR_VAR 0 1
12727: PUSH
12728: LD_INT 22
12730: PUSH
12731: LD_INT 7
12733: PUSH
12734: EMPTY
12735: LIST
12736: LIST
12737: PUSH
12738: LD_INT 23
12740: PUSH
12741: LD_INT 3
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: PUSH
12748: LD_INT 25
12750: PUSH
12751: LD_INT 4
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: PUSH
12758: LD_INT 21
12760: PUSH
12761: LD_INT 1
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 26
12770: PUSH
12771: LD_INT 1
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: LIST
12782: LIST
12783: LIST
12784: PPUSH
12785: CALL_OW 69
12789: PUSH
12790: LD_EXP 13
12794: PUSH
12795: LD_EXP 12
12799: PUSH
12800: LD_EXP 44
12804: PUSH
12805: LD_EXP 32
12809: PUSH
12810: LD_EXP 42
12814: PUSH
12815: LD_EXP 41
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: LIST
12827: DIFF
12828: ST_TO_ADDR
// if not speaker then
12829: LD_VAR 0 1
12833: NOT
12834: IFFALSE 12838
// exit ;
12836: GO 12996
// DialogueOn ;
12838: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
12842: LD_VAR 0 1
12846: PUSH
12847: LD_INT 1
12849: ARRAY
12850: PPUSH
12851: LD_STRING DArtefTechnologyAr-RSci1-1
12853: PPUSH
12854: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
12858: LD_EXP 12
12862: PPUSH
12863: LD_STRING DArtefTechnologyAr-JMM-1
12865: PPUSH
12866: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
12870: LD_VAR 0 1
12874: PUSH
12875: LD_INT 1
12877: ARRAY
12878: PPUSH
12879: LD_STRING DArtefTechnologyAr-RSci1-2
12881: PPUSH
12882: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
12886: LD_EXP 12
12890: PPUSH
12891: LD_STRING DArtefTechnologyAr-JMM-2
12893: PPUSH
12894: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
12898: LD_VAR 0 1
12902: PUSH
12903: LD_INT 1
12905: ARRAY
12906: PPUSH
12907: LD_STRING DArtefTechnologyAr-RSci1-3
12909: PPUSH
12910: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
12914: LD_EXP 12
12918: PPUSH
12919: LD_STRING DArtefTechnologyAr-JMM-3
12921: PPUSH
12922: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
12926: LD_VAR 0 1
12930: PUSH
12931: LD_INT 1
12933: ARRAY
12934: PPUSH
12935: LD_STRING DArtefTechnologyAr-RSci1-4
12937: PPUSH
12938: CALL_OW 88
// if IsOk ( Burlak ) then
12942: LD_EXP 44
12946: PPUSH
12947: CALL_OW 302
12951: IFFALSE 12965
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
12953: LD_EXP 44
12957: PPUSH
12958: LD_STRING DArtefTechnologyAr-Bur-4
12960: PPUSH
12961: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
12965: LD_EXP 12
12969: PPUSH
12970: LD_STRING DArtefTechnologyAr-JMM-4
12972: PPUSH
12973: CALL_OW 88
// DialogueOff ;
12977: CALL_OW 7
// wait ( 0 0$45 ) ;
12981: LD_INT 1575
12983: PPUSH
12984: CALL_OW 67
// spawnOmar := true ;
12988: LD_ADDR_EXP 8
12992: PUSH
12993: LD_INT 1
12995: ST_TO_ADDR
// end ;
12996: PPOPN 1
12998: END
// every 0 0$1 trigger spawnOmar do
12999: LD_EXP 8
13003: IFFALSE 13301
13005: GO 13007
13007: DISABLE
// begin PrepareOmarAli ;
13008: CALL 6531 0 0
// if not Omar then
13012: LD_EXP 48
13016: NOT
13017: IFFALSE 13021
// exit ;
13019: GO 13301
// repeat wait ( 0 0$1 ) ;
13021: LD_INT 35
13023: PPUSH
13024: CALL_OW 67
// until See ( 7 , Omar ) ;
13028: LD_INT 7
13030: PPUSH
13031: LD_EXP 48
13035: PPUSH
13036: CALL_OW 292
13040: IFFALSE 13021
// CenterNowOnUnits ( Omar ) ;
13042: LD_EXP 48
13046: PPUSH
13047: CALL_OW 87
// DialogueOn ;
13051: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13055: LD_EXP 48
13059: PPUSH
13060: LD_STRING DOmar-Omar-1
13062: PPUSH
13063: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13067: LD_EXP 12
13071: PPUSH
13072: LD_STRING DOmar-JMM-1
13074: PPUSH
13075: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13079: LD_EXP 48
13083: PPUSH
13084: LD_STRING DOmar-Omar-2
13086: PPUSH
13087: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13091: LD_EXP 12
13095: PPUSH
13096: LD_STRING DOmar-JMM-2
13098: PPUSH
13099: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13103: LD_EXP 48
13107: PPUSH
13108: LD_STRING DOmar-Omar-3
13110: PPUSH
13111: CALL_OW 88
// if IsOk ( Burlak ) then
13115: LD_EXP 44
13119: PPUSH
13120: CALL_OW 302
13124: IFFALSE 13140
// Say ( Burlak , DOmar-Bur-3 ) else
13126: LD_EXP 44
13130: PPUSH
13131: LD_STRING DOmar-Bur-3
13133: PPUSH
13134: CALL_OW 88
13138: GO 13152
// Say ( JMM , DOmar-JMM-3 ) ;
13140: LD_EXP 12
13144: PPUSH
13145: LD_STRING DOmar-JMM-3
13147: PPUSH
13148: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13152: LD_EXP 48
13156: PPUSH
13157: LD_STRING DOmar-Omar-4
13159: PPUSH
13160: CALL_OW 88
// case Query ( QAccept ) of 1 :
13164: LD_STRING QAccept
13166: PPUSH
13167: CALL_OW 97
13171: PUSH
13172: LD_INT 1
13174: DOUBLE
13175: EQUAL
13176: IFTRUE 13180
13178: GO 13216
13180: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13181: LD_EXP 12
13185: PPUSH
13186: LD_STRING DQrAccept#1-JMM-1
13188: PPUSH
13189: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13193: LD_EXP 48
13197: PPUSH
13198: LD_INT 7
13200: PPUSH
13201: CALL_OW 235
// ComStop ( Omar ) ;
13205: LD_EXP 48
13209: PPUSH
13210: CALL_OW 141
// end ; 2 :
13214: GO 13265
13216: LD_INT 2
13218: DOUBLE
13219: EQUAL
13220: IFTRUE 13224
13222: GO 13264
13224: POP
// begin if IsOk ( Burlak ) then
13225: LD_EXP 44
13229: PPUSH
13230: CALL_OW 302
13234: IFFALSE 13250
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13236: LD_EXP 44
13240: PPUSH
13241: LD_STRING DQrAccept#2-Bur-1
13243: PPUSH
13244: CALL_OW 88
13248: GO 13262
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13250: LD_EXP 12
13254: PPUSH
13255: LD_STRING DQrAccept#2-JMM-1
13257: PPUSH
13258: CALL_OW 88
// end ; end ;
13262: GO 13265
13264: POP
// DialogueOff ;
13265: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13269: LD_EXP 48
13273: PPUSH
13274: CALL_OW 255
13278: PUSH
13279: LD_INT 7
13281: EQUAL
13282: IFFALSE 13286
// exit ;
13284: GO 13301
// ComMoveXY ( Omar , 202 , 115 ) ;
13286: LD_EXP 48
13290: PPUSH
13291: LD_INT 202
13293: PPUSH
13294: LD_INT 115
13296: PPUSH
13297: CALL_OW 111
// end ;
13301: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13302: LD_EXP 48
13306: PPUSH
13307: LD_INT 200
13309: PPUSH
13310: LD_INT 98
13312: PPUSH
13313: CALL_OW 297
13317: PUSH
13318: LD_INT 40
13320: LESS
13321: PUSH
13322: LD_EXP 2
13326: AND
13327: IFFALSE 13545
13329: GO 13331
13331: DISABLE
// begin SetSide ( Omar , 5 ) ;
13332: LD_EXP 48
13336: PPUSH
13337: LD_INT 5
13339: PPUSH
13340: CALL_OW 235
// if IsInUnit ( Omar ) then
13344: LD_EXP 48
13348: PPUSH
13349: CALL_OW 310
13353: IFFALSE 13364
// ComExitVehicle ( Omar ) ;
13355: LD_EXP 48
13359: PPUSH
13360: CALL_OW 121
// if IsInUnit ( Omar ) then
13364: LD_EXP 48
13368: PPUSH
13369: CALL_OW 310
13373: IFFALSE 13384
// ComExitBuilding ( Omar ) ;
13375: LD_EXP 48
13379: PPUSH
13380: CALL_OW 122
// wait ( 0 0$1 ) ;
13384: LD_INT 35
13386: PPUSH
13387: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13391: LD_EXP 48
13395: PPUSH
13396: LD_INT 203
13398: PPUSH
13399: LD_INT 120
13401: PPUSH
13402: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13406: LD_INT 35
13408: PPUSH
13409: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13413: LD_EXP 48
13417: PPUSH
13418: CALL_OW 306
13422: PUSH
13423: LD_EXP 48
13427: PPUSH
13428: LD_INT 203
13430: PPUSH
13431: LD_INT 120
13433: PPUSH
13434: CALL_OW 297
13438: PUSH
13439: LD_INT 6
13441: LESS
13442: OR
13443: IFFALSE 13406
// CenterNowOnUnits ( Omar ) ;
13445: LD_EXP 48
13449: PPUSH
13450: CALL_OW 87
// DialogueOn ;
13454: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13458: LD_EXP 12
13462: PPUSH
13463: LD_STRING DOmarContam-JMM-1
13465: PPUSH
13466: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13470: LD_EXP 48
13474: PPUSH
13475: LD_STRING DOmarContam-Omar-1
13477: PPUSH
13478: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13482: LD_EXP 12
13486: PPUSH
13487: LD_STRING DOmarContam-JMM-2
13489: PPUSH
13490: CALL_OW 88
// DialogueOff ;
13494: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13498: LD_INT 5
13500: PPUSH
13501: LD_INT 7
13503: PPUSH
13504: LD_INT 2
13506: PPUSH
13507: LD_INT 1
13509: PPUSH
13510: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13514: LD_INT 105
13516: PPUSH
13517: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13521: LD_EXP 48
13525: PPUSH
13526: LD_INT 203
13528: PPUSH
13529: LD_INT 120
13531: PPUSH
13532: CALL_OW 307
13536: IFFALSE 13514
// YouLost ( MothContaminate ) ;
13538: LD_STRING MothContaminate
13540: PPUSH
13541: CALL_OW 104
// end ;
13545: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13546: LD_EXP 4
13550: NOT
13551: PUSH
13552: LD_INT 22
13554: PUSH
13555: LD_INT 1
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PUSH
13562: LD_INT 34
13564: PUSH
13565: LD_INT 8
13567: PUSH
13568: EMPTY
13569: LIST
13570: LIST
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PPUSH
13576: CALL_OW 69
13580: AND
13581: IFFALSE 13662
13583: GO 13585
13585: DISABLE
// begin if not IsOk ( Powell ) then
13586: LD_EXP 47
13590: PPUSH
13591: CALL_OW 302
13595: NOT
13596: IFFALSE 13600
// exit ;
13598: GO 13662
// DialogueOn ;
13600: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13604: LD_EXP 47
13608: PPUSH
13609: LD_STRING DWinAmericans-Pow-1
13611: PPUSH
13612: CALL_OW 94
// if IsOk ( Burlak ) then
13616: LD_EXP 44
13620: PPUSH
13621: CALL_OW 302
13625: IFFALSE 13639
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13627: LD_EXP 44
13631: PPUSH
13632: LD_STRING DWinAmericans-Bur-1
13634: PPUSH
13635: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13639: LD_EXP 12
13643: PPUSH
13644: LD_STRING DWinAmericans-JMM-1
13646: PPUSH
13647: CALL_OW 88
// DialogueOff ;
13651: CALL_OW 7
// YouLost ( AmBomb ) ;
13655: LD_STRING AmBomb
13657: PPUSH
13658: CALL_OW 104
// end ;
13662: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13663: LD_EXP 2
13667: NOT
13668: PUSH
13669: LD_INT 22
13671: PUSH
13672: LD_INT 3
13674: PUSH
13675: EMPTY
13676: LIST
13677: LIST
13678: PUSH
13679: LD_INT 34
13681: PUSH
13682: LD_INT 48
13684: PUSH
13685: EMPTY
13686: LIST
13687: LIST
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PPUSH
13693: CALL_OW 69
13697: AND
13698: IFFALSE 13779
13700: GO 13702
13702: DISABLE
// begin if not IsOk ( Platonov ) then
13703: LD_EXP 51
13707: PPUSH
13708: CALL_OW 302
13712: NOT
13713: IFFALSE 13717
// exit ;
13715: GO 13779
// DialogueOn ;
13717: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13721: LD_EXP 51
13725: PPUSH
13726: LD_STRING DWinRussians-Pla-1
13728: PPUSH
13729: CALL_OW 94
// if IsOk ( Burlak ) then
13733: LD_EXP 44
13737: PPUSH
13738: CALL_OW 302
13742: IFFALSE 13756
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13744: LD_EXP 44
13748: PPUSH
13749: LD_STRING DWinRussians-Bur-1
13751: PPUSH
13752: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13756: LD_EXP 12
13760: PPUSH
13761: LD_STRING DWinRussians-JMM-1
13763: PPUSH
13764: CALL_OW 88
// DialogueOff ;
13768: CALL_OW 7
// YouLost ( RuBomb ) ;
13772: LD_STRING RuBomb
13774: PPUSH
13775: CALL_OW 104
// end ;
13779: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13780: LD_INT 7
13782: PPUSH
13783: LD_INT 22
13785: PUSH
13786: LD_INT 7
13788: PUSH
13789: EMPTY
13790: LIST
13791: LIST
13792: PPUSH
13793: CALL_OW 70
13797: PUSH
13798: LD_EXP 4
13802: NOT
13803: AND
13804: IFFALSE 13833
13806: GO 13808
13808: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13809: LD_EXP 47
13813: PPUSH
13814: LD_STRING DSurrenderAmericans-Pow-1
13816: PPUSH
13817: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
13821: LD_EXP 12
13825: PPUSH
13826: LD_STRING DSurrenderAmericans-JMM-1
13828: PPUSH
13829: CALL_OW 88
// end ;
13833: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
13834: LD_INT 2
13836: PPUSH
13837: LD_INT 22
13839: PUSH
13840: LD_INT 7
13842: PUSH
13843: EMPTY
13844: LIST
13845: LIST
13846: PPUSH
13847: CALL_OW 70
13851: PUSH
13852: LD_EXP 2
13856: NOT
13857: AND
13858: PUSH
13859: LD_EXP 44
13863: AND
13864: IFFALSE 13893
13866: GO 13868
13868: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
13869: LD_EXP 51
13873: PPUSH
13874: LD_STRING DSurrenderRussians-Pla-1
13876: PPUSH
13877: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
13881: LD_EXP 44
13885: PPUSH
13886: LD_STRING DSurrenderRussians-Bur-1
13888: PPUSH
13889: CALL_OW 88
// end ;
13893: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
13894: LD_EXP 4
13898: IFFALSE 14273
13900: GO 13902
13902: DISABLE
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
// begin MC_Kill ( 4 ) ;
13908: LD_INT 4
13910: PPUSH
13911: CALL 20347 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
13915: LD_INT 1
13917: PPUSH
13918: LD_INT 7
13920: PPUSH
13921: LD_INT 1
13923: PPUSH
13924: LD_INT 1
13926: PPUSH
13927: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
13931: LD_ADDR_VAR 0 3
13935: PUSH
13936: LD_INT 22
13938: PUSH
13939: LD_INT 1
13941: PUSH
13942: EMPTY
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 26
13948: PUSH
13949: LD_INT 1
13951: PUSH
13952: EMPTY
13953: LIST
13954: LIST
13955: PUSH
13956: LD_INT 23
13958: PUSH
13959: LD_INT 1
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: EMPTY
13967: LIST
13968: LIST
13969: LIST
13970: PPUSH
13971: CALL_OW 69
13975: PUSH
13976: LD_EXP 47
13980: PUSH
13981: LD_EXP 20
13985: PUSH
13986: LD_EXP 17
13990: PUSH
13991: LD_EXP 16
13995: PUSH
13996: LD_EXP 23
14000: PUSH
14001: LD_EXP 21
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: LIST
14010: LIST
14011: LIST
14012: LIST
14013: DIFF
14014: ST_TO_ADDR
// if speaker then
14015: LD_VAR 0 3
14019: IFFALSE 14045
// begin DialogueOn ;
14021: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14025: LD_VAR 0 3
14029: PUSH
14030: LD_INT 1
14032: ARRAY
14033: PPUSH
14034: LD_STRING DSurrenderAmericans-Sol1-1a
14036: PPUSH
14037: CALL_OW 94
// DialogueOff ;
14041: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14045: LD_ADDR_VAR 0 2
14049: PUSH
14050: LD_INT 22
14052: PUSH
14053: LD_INT 1
14055: PUSH
14056: EMPTY
14057: LIST
14058: LIST
14059: PUSH
14060: LD_INT 21
14062: PUSH
14063: LD_INT 1
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: PUSH
14070: EMPTY
14071: LIST
14072: LIST
14073: PPUSH
14074: CALL_OW 69
14078: PUSH
14079: LD_INT 22
14081: PUSH
14082: LD_INT 1
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: LD_INT 21
14091: PUSH
14092: LD_INT 2
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: LD_INT 1
14101: PUSH
14102: EMPTY
14103: LIST
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: LIST
14109: PPUSH
14110: CALL_OW 69
14114: ADD
14115: ST_TO_ADDR
// if tmp then
14116: LD_VAR 0 2
14120: IFFALSE 14273
// repeat wait ( 0 0$1 ) ;
14122: LD_INT 35
14124: PPUSH
14125: CALL_OW 67
// for i in tmp do
14129: LD_ADDR_VAR 0 1
14133: PUSH
14134: LD_VAR 0 2
14138: PUSH
14139: FOR_IN
14140: IFFALSE 14222
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14142: LD_VAR 0 1
14146: PPUSH
14147: CALL_OW 310
14151: PUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: CALL_OW 310
14161: PPUSH
14162: CALL_OW 247
14166: PUSH
14167: LD_INT 3
14169: EQUAL
14170: AND
14171: IFFALSE 14182
// ComExitBuilding ( i ) ;
14173: LD_VAR 0 1
14177: PPUSH
14178: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14182: LD_VAR 0 1
14186: PPUSH
14187: LD_INT 122
14189: PPUSH
14190: LD_INT 242
14192: PPUSH
14193: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14197: LD_VAR 0 1
14201: PPUSH
14202: LD_INT 35
14204: PPUSH
14205: CALL_OW 308
14209: IFFALSE 14220
// RemoveUnit ( i ) ;
14211: LD_VAR 0 1
14215: PPUSH
14216: CALL_OW 64
// end ;
14220: GO 14139
14222: POP
14223: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14224: LD_INT 22
14226: PUSH
14227: LD_INT 1
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: PUSH
14234: LD_INT 2
14236: PUSH
14237: LD_INT 21
14239: PUSH
14240: LD_INT 1
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: LD_INT 33
14249: PUSH
14250: LD_INT 1
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: PUSH
14262: EMPTY
14263: LIST
14264: LIST
14265: PPUSH
14266: CALL_OW 69
14270: NOT
14271: IFFALSE 14122
// end ;
14273: PPOPN 3
14275: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14276: LD_EXP 2
14280: IFFALSE 14673
14282: GO 14284
14284: DISABLE
14285: LD_INT 0
14287: PPUSH
14288: PPUSH
14289: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14290: LD_INT 35
14292: PPUSH
14293: CALL_OW 67
// until IsDead ( Yakotich ) ;
14297: LD_EXP 52
14301: PPUSH
14302: CALL_OW 301
14306: IFFALSE 14290
// MC_Kill ( 2 ) ;
14308: LD_INT 2
14310: PPUSH
14311: CALL 20347 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14315: LD_INT 3
14317: PPUSH
14318: LD_INT 7
14320: PPUSH
14321: LD_INT 1
14323: PPUSH
14324: LD_INT 1
14326: PPUSH
14327: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14331: LD_ADDR_VAR 0 3
14335: PUSH
14336: LD_INT 22
14338: PUSH
14339: LD_INT 3
14341: PUSH
14342: EMPTY
14343: LIST
14344: LIST
14345: PUSH
14346: LD_INT 26
14348: PUSH
14349: LD_INT 1
14351: PUSH
14352: EMPTY
14353: LIST
14354: LIST
14355: PUSH
14356: LD_INT 23
14358: PUSH
14359: LD_INT 3
14361: PUSH
14362: EMPTY
14363: LIST
14364: LIST
14365: PUSH
14366: EMPTY
14367: LIST
14368: LIST
14369: LIST
14370: PPUSH
14371: CALL_OW 69
14375: PUSH
14376: LD_EXP 51
14380: PUSH
14381: LD_EXP 52
14385: PUSH
14386: EMPTY
14387: LIST
14388: LIST
14389: DIFF
14390: ST_TO_ADDR
// if speaker then
14391: LD_VAR 0 3
14395: IFFALSE 14445
// begin DialogueOn ;
14397: CALL_OW 6
// if Burlak then
14401: LD_EXP 44
14405: IFFALSE 14425
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14407: LD_VAR 0 3
14411: PUSH
14412: LD_INT 1
14414: ARRAY
14415: PPUSH
14416: LD_STRING DSurrenderRussians-RSol1-1
14418: PPUSH
14419: CALL_OW 94
14423: GO 14441
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14425: LD_VAR 0 3
14429: PUSH
14430: LD_INT 1
14432: ARRAY
14433: PPUSH
14434: LD_STRING DSurrenderRussians-RSol1-1a
14436: PPUSH
14437: CALL_OW 94
// DialogueOff ;
14441: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 3
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 21
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 3
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ADD
14515: ST_TO_ADDR
// if tmp then
14516: LD_VAR 0 2
14520: IFFALSE 14673
// repeat wait ( 0 0$1 ) ;
14522: LD_INT 35
14524: PPUSH
14525: CALL_OW 67
// for i in tmp do
14529: LD_ADDR_VAR 0 1
14533: PUSH
14534: LD_VAR 0 2
14538: PUSH
14539: FOR_IN
14540: IFFALSE 14622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 310
14551: PUSH
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 310
14561: PPUSH
14562: CALL_OW 247
14566: PUSH
14567: LD_INT 3
14569: EQUAL
14570: AND
14571: IFFALSE 14582
// ComExitBuilding ( i ) ;
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 154
14589: PPUSH
14590: LD_INT 1
14592: PPUSH
14593: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 36
14604: PPUSH
14605: CALL_OW 308
14609: IFFALSE 14620
// RemoveUnit ( i ) ;
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 64
// end ;
14620: GO 14539
14622: POP
14623: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14624: LD_INT 22
14626: PUSH
14627: LD_INT 3
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 33
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14522
// end ;
14673: PPOPN 3
14675: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) do
14676: LD_INT 22
14678: PUSH
14679: LD_INT 8
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: PUSH
14686: LD_INT 21
14688: PUSH
14689: LD_INT 1
14691: PUSH
14692: EMPTY
14693: LIST
14694: LIST
14695: PUSH
14696: LD_INT 23
14698: PUSH
14699: LD_INT 2
14701: PUSH
14702: EMPTY
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: LIST
14710: PPUSH
14711: CALL_OW 69
14715: PUSH
14716: LD_INT 18
14718: LESS
14719: PUSH
14720: LD_EXP 50
14724: PPUSH
14725: CALL_OW 301
14729: OR
14730: IFFALSE 14743
14732: GO 14734
14734: DISABLE
// legionDestroyed := true ;
14735: LD_ADDR_EXP 3
14739: PUSH
14740: LD_INT 1
14742: ST_TO_ADDR
14743: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14744: LD_INT 22
14746: PUSH
14747: LD_INT 2
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: PUSH
14754: LD_INT 21
14756: PUSH
14757: LD_INT 1
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: PUSH
14764: LD_INT 23
14766: PUSH
14767: LD_INT 2
14769: PUSH
14770: EMPTY
14771: LIST
14772: LIST
14773: PUSH
14774: EMPTY
14775: LIST
14776: LIST
14777: LIST
14778: PPUSH
14779: CALL_OW 69
14783: PUSH
14784: LD_INT 9
14786: LESS
14787: IFFALSE 14800
14789: GO 14791
14791: DISABLE
// arabianDestroyed := true ;
14792: LD_ADDR_EXP 5
14796: PUSH
14797: LD_INT 1
14799: ST_TO_ADDR
14800: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14801: LD_EXP 5
14805: IFFALSE 15065
14807: GO 14809
14809: DISABLE
14810: LD_INT 0
14812: PPUSH
14813: PPUSH
// begin MC_Kill ( 1 ) ;
14814: LD_INT 1
14816: PPUSH
14817: CALL 20347 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
14821: LD_INT 2
14823: PPUSH
14824: LD_INT 7
14826: PPUSH
14827: LD_INT 1
14829: PPUSH
14830: LD_INT 1
14832: PPUSH
14833: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14837: LD_ADDR_VAR 0 2
14841: PUSH
14842: LD_INT 22
14844: PUSH
14845: LD_INT 2
14847: PUSH
14848: EMPTY
14849: LIST
14850: LIST
14851: PUSH
14852: LD_INT 21
14854: PUSH
14855: LD_INT 1
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: PUSH
14862: EMPTY
14863: LIST
14864: LIST
14865: PPUSH
14866: CALL_OW 69
14870: PUSH
14871: LD_INT 22
14873: PUSH
14874: LD_INT 8
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 21
14883: PUSH
14884: LD_INT 2
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: PUSH
14891: LD_INT 1
14893: PUSH
14894: EMPTY
14895: LIST
14896: PUSH
14897: EMPTY
14898: LIST
14899: LIST
14900: LIST
14901: PPUSH
14902: CALL_OW 69
14906: ADD
14907: ST_TO_ADDR
// if tmp then
14908: LD_VAR 0 2
14912: IFFALSE 15065
// repeat wait ( 0 0$1 ) ;
14914: LD_INT 35
14916: PPUSH
14917: CALL_OW 67
// for i in tmp do
14921: LD_ADDR_VAR 0 1
14925: PUSH
14926: LD_VAR 0 2
14930: PUSH
14931: FOR_IN
14932: IFFALSE 15014
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14934: LD_VAR 0 1
14938: PPUSH
14939: CALL_OW 310
14943: PUSH
14944: LD_VAR 0 1
14948: PPUSH
14949: CALL_OW 310
14953: PPUSH
14954: CALL_OW 247
14958: PUSH
14959: LD_INT 3
14961: EQUAL
14962: AND
14963: IFFALSE 14974
// ComExitBuilding ( i ) ;
14965: LD_VAR 0 1
14969: PPUSH
14970: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
14974: LD_VAR 0 1
14978: PPUSH
14979: LD_INT 254
14981: PPUSH
14982: LD_INT 268
14984: PPUSH
14985: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
14989: LD_VAR 0 1
14993: PPUSH
14994: LD_INT 34
14996: PPUSH
14997: CALL_OW 308
15001: IFFALSE 15012
// RemoveUnit ( i ) ;
15003: LD_VAR 0 1
15007: PPUSH
15008: CALL_OW 64
// end ;
15012: GO 14931
15014: POP
15015: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15016: LD_INT 22
15018: PUSH
15019: LD_INT 2
15021: PUSH
15022: EMPTY
15023: LIST
15024: LIST
15025: PUSH
15026: LD_INT 2
15028: PUSH
15029: LD_INT 21
15031: PUSH
15032: LD_INT 1
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: PUSH
15039: LD_INT 33
15041: PUSH
15042: LD_INT 1
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: LIST
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: PPUSH
15058: CALL_OW 69
15062: NOT
15063: IFFALSE 14914
// end ;
15065: PPOPN 2
15067: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15068: LD_EXP 3
15072: IFFALSE 15413
15074: GO 15076
15076: DISABLE
15077: LD_INT 0
15079: PPUSH
15080: PPUSH
// begin MC_Kill ( 3 ) ;
15081: LD_INT 3
15083: PPUSH
15084: CALL 20347 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15088: LD_INT 8
15090: PPUSH
15091: LD_INT 7
15093: PPUSH
15094: LD_INT 1
15096: PPUSH
15097: LD_INT 1
15099: PPUSH
15100: CALL_OW 80
// DialogueOn ;
15104: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15108: LD_EXP 49
15112: PPUSH
15113: LD_STRING D15-Szulc-1
15115: PPUSH
15116: CALL_OW 94
// DialogueOff ;
15120: CALL_OW 7
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15124: LD_ADDR_VAR 0 1
15128: PUSH
15129: LD_INT 22
15131: PUSH
15132: LD_INT 8
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: PUSH
15139: LD_INT 21
15141: PUSH
15142: LD_INT 3
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PUSH
15149: LD_INT 23
15151: PUSH
15152: LD_INT 3
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: PUSH
15159: EMPTY
15160: LIST
15161: LIST
15162: LIST
15163: PPUSH
15164: CALL_OW 69
15168: PUSH
15169: FOR_IN
15170: IFFALSE 15183
// DestroyUnit ( i ) ;
15172: LD_VAR 0 1
15176: PPUSH
15177: CALL_OW 65
15181: GO 15169
15183: POP
15184: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15185: LD_ADDR_VAR 0 2
15189: PUSH
15190: LD_INT 22
15192: PUSH
15193: LD_INT 8
15195: PUSH
15196: EMPTY
15197: LIST
15198: LIST
15199: PUSH
15200: LD_INT 21
15202: PUSH
15203: LD_INT 1
15205: PUSH
15206: EMPTY
15207: LIST
15208: LIST
15209: PUSH
15210: EMPTY
15211: LIST
15212: LIST
15213: PPUSH
15214: CALL_OW 69
15218: PUSH
15219: LD_INT 22
15221: PUSH
15222: LD_INT 8
15224: PUSH
15225: EMPTY
15226: LIST
15227: LIST
15228: PUSH
15229: LD_INT 21
15231: PUSH
15232: LD_INT 2
15234: PUSH
15235: EMPTY
15236: LIST
15237: LIST
15238: PUSH
15239: LD_INT 1
15241: PUSH
15242: EMPTY
15243: LIST
15244: PUSH
15245: EMPTY
15246: LIST
15247: LIST
15248: LIST
15249: PPUSH
15250: CALL_OW 69
15254: ADD
15255: ST_TO_ADDR
// if tmp then
15256: LD_VAR 0 2
15260: IFFALSE 15413
// repeat wait ( 0 0$1 ) ;
15262: LD_INT 35
15264: PPUSH
15265: CALL_OW 67
// for i in tmp do
15269: LD_ADDR_VAR 0 1
15273: PUSH
15274: LD_VAR 0 2
15278: PUSH
15279: FOR_IN
15280: IFFALSE 15362
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15282: LD_VAR 0 1
15286: PPUSH
15287: CALL_OW 310
15291: PUSH
15292: LD_VAR 0 1
15296: PPUSH
15297: CALL_OW 310
15301: PPUSH
15302: CALL_OW 247
15306: PUSH
15307: LD_INT 3
15309: EQUAL
15310: AND
15311: IFFALSE 15322
// ComExitBuilding ( i ) ;
15313: LD_VAR 0 1
15317: PPUSH
15318: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15322: LD_VAR 0 1
15326: PPUSH
15327: LD_INT 10
15329: PPUSH
15330: LD_INT 1
15332: PPUSH
15333: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15337: LD_VAR 0 1
15341: PPUSH
15342: LD_INT 32
15344: PPUSH
15345: CALL_OW 308
15349: IFFALSE 15360
// RemoveUnit ( i ) ;
15351: LD_VAR 0 1
15355: PPUSH
15356: CALL_OW 64
// end ;
15360: GO 15279
15362: POP
15363: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15364: LD_INT 22
15366: PUSH
15367: LD_INT 8
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: LD_INT 21
15379: PUSH
15380: LD_INT 1
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PUSH
15387: LD_INT 33
15389: PUSH
15390: LD_INT 1
15392: PUSH
15393: EMPTY
15394: LIST
15395: LIST
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: LIST
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: PPUSH
15406: CALL_OW 69
15410: NOT
15411: IFFALSE 15262
// end ;
15413: PPOPN 2
15415: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do var med1 , med2 ;
15416: LD_EXP 4
15420: PUSH
15421: LD_EXP 2
15425: AND
15426: PUSH
15427: LD_EXP 3
15431: AND
15432: PUSH
15433: LD_EXP 5
15437: AND
15438: IFFALSE 16781
15440: GO 15442
15442: DISABLE
15443: LD_INT 0
15445: PPUSH
15446: PPUSH
// begin music_class := 5 ;
15447: LD_ADDR_OWVAR 72
15451: PUSH
15452: LD_INT 5
15454: ST_TO_ADDR
// music_nat := 5 ;
15455: LD_ADDR_OWVAR 71
15459: PUSH
15460: LD_INT 5
15462: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
15463: LD_EXP 12
15467: PPUSH
15468: CALL_OW 87
// InGameOn ;
15472: CALL_OW 8
// DialogueOn ;
15476: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15480: LD_EXP 12
15484: PPUSH
15485: LD_STRING DEnd-JMM-JMM-1
15487: PPUSH
15488: CALL_OW 88
// if Joan then
15492: LD_EXP 27
15496: IFFALSE 15512
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15498: LD_EXP 27
15502: PPUSH
15503: LD_STRING DEnd-JMM-Joan-1
15505: PPUSH
15506: CALL_OW 88
15510: GO 15556
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15512: LD_EXP 14
15516: PUSH
15517: LD_EXP 14
15521: PPUSH
15522: CALL_OW 255
15526: PUSH
15527: LD_INT 7
15529: EQUAL
15530: AND
15531: PUSH
15532: LD_EXP 14
15536: PPUSH
15537: CALL_OW 305
15541: AND
15542: IFFALSE 15556
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15544: LD_EXP 14
15548: PPUSH
15549: LD_STRING DEnd-JMM-Lisa-1
15551: PPUSH
15552: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15556: LD_EXP 24
15560: PUSH
15561: LD_EXP 24
15565: PPUSH
15566: CALL_OW 305
15570: AND
15571: IFFALSE 15585
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15573: LD_EXP 24
15577: PPUSH
15578: LD_STRING DEnd-JMM-Frank-1
15580: PPUSH
15581: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15585: LD_EXP 17
15589: PUSH
15590: LD_EXP 17
15594: PPUSH
15595: CALL_OW 255
15599: PUSH
15600: LD_INT 7
15602: EQUAL
15603: AND
15604: PUSH
15605: LD_EXP 17
15609: PPUSH
15610: CALL_OW 305
15614: AND
15615: IFFALSE 15629
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15617: LD_EXP 17
15621: PPUSH
15622: LD_STRING DEnd-JMM-Cyrus-1
15624: PPUSH
15625: CALL_OW 88
// if Burlak then
15629: LD_EXP 44
15633: IFFALSE 15647
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15635: LD_EXP 44
15639: PPUSH
15640: LD_STRING DEnd-JMM-Bur-1
15642: PPUSH
15643: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15647: LD_EXP 27
15651: PUSH
15652: LD_EXP 14
15656: AND
15657: PUSH
15658: LD_EXP 14
15662: PPUSH
15663: CALL_OW 255
15667: PUSH
15668: LD_INT 7
15670: EQUAL
15671: AND
15672: PUSH
15673: LD_EXP 14
15677: PPUSH
15678: CALL_OW 305
15682: AND
15683: IFFALSE 15697
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15685: LD_EXP 14
15689: PPUSH
15690: LD_STRING DEnd-Burlak-Lisa-1
15692: PPUSH
15693: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15697: LD_EXP 45
15701: PUSH
15702: LD_EXP 45
15706: PPUSH
15707: CALL_OW 305
15711: AND
15712: IFFALSE 15726
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15714: LD_EXP 45
15718: PPUSH
15719: LD_STRING DEnd-JMM-Bel-1
15721: PPUSH
15722: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15726: LD_EXP 46
15730: PUSH
15731: LD_EXP 46
15735: PPUSH
15736: CALL_OW 305
15740: AND
15741: IFFALSE 15755
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15743: LD_EXP 46
15747: PPUSH
15748: LD_STRING DEnd-JMM-Gny-1
15750: PPUSH
15751: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15755: LD_EXP 22
15759: PUSH
15760: LD_EXP 22
15764: PPUSH
15765: CALL_OW 255
15769: PUSH
15770: LD_INT 7
15772: EQUAL
15773: AND
15774: PUSH
15775: LD_EXP 22
15779: PPUSH
15780: CALL_OW 305
15784: AND
15785: IFFALSE 15799
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
15787: LD_EXP 22
15791: PPUSH
15792: LD_STRING DEnd-JMM-Corn-1
15794: PPUSH
15795: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
15799: LD_EXP 15
15803: PUSH
15804: LD_EXP 15
15808: PPUSH
15809: CALL_OW 255
15813: PUSH
15814: LD_INT 7
15816: EQUAL
15817: AND
15818: PUSH
15819: LD_EXP 15
15823: PPUSH
15824: CALL_OW 305
15828: AND
15829: IFFALSE 15843
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
15831: LD_EXP 15
15835: PPUSH
15836: LD_STRING DEnd-JMM-Don-1
15838: PPUSH
15839: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
15843: LD_EXP 16
15847: PUSH
15848: LD_EXP 16
15852: PPUSH
15853: CALL_OW 255
15857: PUSH
15858: LD_INT 7
15860: EQUAL
15861: AND
15862: PUSH
15863: LD_EXP 16
15867: PPUSH
15868: CALL_OW 305
15872: AND
15873: IFFALSE 15887
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
15875: LD_EXP 16
15879: PPUSH
15880: LD_STRING DEnd-JMM-Bobby-1
15882: PPUSH
15883: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
15887: LD_EXP 18
15891: PUSH
15892: LD_EXP 18
15896: PPUSH
15897: CALL_OW 255
15901: PUSH
15902: LD_INT 7
15904: EQUAL
15905: AND
15906: PUSH
15907: LD_EXP 18
15911: PPUSH
15912: CALL_OW 305
15916: AND
15917: IFFALSE 15931
// Say ( Denis , DEnd-JMM-Den-1 ) ;
15919: LD_EXP 18
15923: PPUSH
15924: LD_STRING DEnd-JMM-Den-1
15926: PPUSH
15927: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
15931: LD_EXP 20
15935: PUSH
15936: LD_EXP 20
15940: PPUSH
15941: CALL_OW 255
15945: PUSH
15946: LD_INT 7
15948: EQUAL
15949: AND
15950: PUSH
15951: LD_EXP 20
15955: PPUSH
15956: CALL_OW 305
15960: AND
15961: IFFALSE 15975
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
15963: LD_EXP 20
15967: PPUSH
15968: LD_STRING DEnd-JMM-Glad-1
15970: PPUSH
15971: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
15975: LD_EXP 25
15979: PUSH
15980: LD_EXP 25
15984: PPUSH
15985: CALL_OW 255
15989: PUSH
15990: LD_INT 7
15992: EQUAL
15993: AND
15994: PUSH
15995: LD_EXP 25
15999: PPUSH
16000: CALL_OW 305
16004: AND
16005: IFFALSE 16019
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16007: LD_EXP 25
16011: PPUSH
16012: LD_STRING DEnd-JMM-Yam-1
16014: PPUSH
16015: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16019: LD_EXP 19
16023: PUSH
16024: LD_EXP 19
16028: PPUSH
16029: CALL_OW 255
16033: PUSH
16034: LD_INT 7
16036: EQUAL
16037: AND
16038: PUSH
16039: LD_EXP 19
16043: PPUSH
16044: CALL_OW 305
16048: AND
16049: IFFALSE 16063
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16051: LD_EXP 19
16055: PPUSH
16056: LD_STRING DEnd-JMM-Brown-1
16058: PPUSH
16059: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16063: LD_EXP 29
16067: PUSH
16068: LD_EXP 29
16072: PPUSH
16073: CALL_OW 255
16077: PUSH
16078: LD_INT 7
16080: EQUAL
16081: AND
16082: PUSH
16083: LD_EXP 29
16087: PPUSH
16088: CALL_OW 305
16092: AND
16093: IFFALSE 16107
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16095: LD_EXP 29
16099: PPUSH
16100: LD_STRING DEnd-JMM-Con-1
16102: PPUSH
16103: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16107: LD_EXP 23
16111: PUSH
16112: LD_EXP 23
16116: PPUSH
16117: CALL_OW 255
16121: PUSH
16122: LD_INT 7
16124: EQUAL
16125: AND
16126: PUSH
16127: LD_EXP 23
16131: PPUSH
16132: CALL_OW 305
16136: AND
16137: IFFALSE 16151
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16139: LD_EXP 23
16143: PPUSH
16144: LD_STRING DEnd-JMM-Gary-1
16146: PPUSH
16147: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16151: LD_EXP 26
16155: PUSH
16156: LD_EXP 13
16160: AND
16161: PUSH
16162: LD_EXP 26
16166: PPUSH
16167: CALL_OW 305
16171: AND
16172: IFFALSE 16186
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16174: LD_EXP 26
16178: PPUSH
16179: LD_STRING DEnd-JMM-Sim-1
16181: PPUSH
16182: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16186: LD_EXP 21
16190: PUSH
16191: LD_EXP 21
16195: PPUSH
16196: CALL_OW 255
16200: PUSH
16201: LD_INT 7
16203: EQUAL
16204: AND
16205: PUSH
16206: LD_EXP 21
16210: PPUSH
16211: CALL_OW 305
16215: AND
16216: IFFALSE 16230
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16218: LD_EXP 21
16222: PPUSH
16223: LD_STRING DEnd-JMM-VanH-1
16225: PPUSH
16226: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16230: LD_EXP 34
16234: PUSH
16235: LD_EXP 34
16239: PPUSH
16240: CALL_OW 305
16244: AND
16245: IFFALSE 16259
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16247: LD_EXP 34
16251: PPUSH
16252: LD_STRING DEnd-JMM-Dol-1
16254: PPUSH
16255: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16259: LD_EXP 38
16263: PUSH
16264: LD_EXP 38
16268: PPUSH
16269: CALL_OW 305
16273: AND
16274: IFFALSE 16288
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16276: LD_EXP 38
16280: PPUSH
16281: LD_STRING DEnd-JMM-Kap-1
16283: PPUSH
16284: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16288: LD_EXP 41
16292: PUSH
16293: LD_EXP 41
16297: PPUSH
16298: CALL_OW 305
16302: AND
16303: IFFALSE 16317
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16305: LD_EXP 41
16309: PPUSH
16310: LD_STRING DEnd-JMM-Kov-1
16312: PPUSH
16313: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16317: LD_EXP 36
16321: PUSH
16322: LD_EXP 36
16326: PPUSH
16327: CALL_OW 305
16331: AND
16332: IFFALSE 16346
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16334: LD_EXP 36
16338: PPUSH
16339: LD_STRING DEnd-JMM-Sch-1
16341: PPUSH
16342: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16346: LD_EXP 32
16350: PUSH
16351: LD_EXP 32
16355: PPUSH
16356: CALL_OW 305
16360: AND
16361: IFFALSE 16375
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16363: LD_EXP 32
16367: PPUSH
16368: LD_STRING DEnd-JMM-Tit-1
16370: PPUSH
16371: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16375: LD_EXP 37
16379: PUSH
16380: LD_EXP 37
16384: PPUSH
16385: CALL_OW 305
16389: AND
16390: IFFALSE 16404
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16392: LD_EXP 37
16396: PPUSH
16397: LD_STRING DEnd-JMM-Obl-1
16399: PPUSH
16400: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16404: LD_EXP 39
16408: PUSH
16409: LD_EXP 39
16413: PPUSH
16414: CALL_OW 305
16418: AND
16419: IFFALSE 16433
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16421: LD_EXP 39
16425: PPUSH
16426: LD_STRING DEnd-JMM-Lip-1
16428: PPUSH
16429: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16433: LD_EXP 33
16437: PUSH
16438: LD_EXP 33
16442: PPUSH
16443: CALL_OW 305
16447: AND
16448: PUSH
16449: LD_EXP 44
16453: AND
16454: IFFALSE 16468
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16456: LD_EXP 33
16460: PPUSH
16461: LD_STRING DEnd-Burlak-Fad-1
16463: PPUSH
16464: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16468: LD_EXP 40
16472: PUSH
16473: LD_EXP 40
16477: PPUSH
16478: CALL_OW 305
16482: AND
16483: IFFALSE 16497
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16485: LD_EXP 40
16489: PPUSH
16490: LD_STRING DEnd-Burlak-Ptr-1
16492: PPUSH
16493: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16497: LD_EXP 42
16501: PUSH
16502: LD_EXP 42
16506: PPUSH
16507: CALL_OW 305
16511: AND
16512: IFFALSE 16526
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16514: LD_EXP 42
16518: PPUSH
16519: LD_STRING DEnd-Burlak-Kuz-1
16521: PPUSH
16522: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16526: LD_EXP 31
16530: PUSH
16531: LD_EXP 31
16535: PPUSH
16536: CALL_OW 305
16540: AND
16541: PUSH
16542: LD_EXP 44
16546: AND
16547: IFFALSE 16561
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16549: LD_EXP 31
16553: PPUSH
16554: LD_STRING DEnd-Burlak-Kir-1
16556: PPUSH
16557: CALL_OW 88
// if Burlak then
16561: LD_EXP 44
16565: IFFALSE 16579
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16567: LD_EXP 12
16571: PPUSH
16572: LD_STRING DEnd-Burlak-JMM-1
16574: PPUSH
16575: CALL_OW 88
// dwait ( 0 0$2 ) ;
16579: LD_INT 70
16581: PPUSH
16582: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16586: LD_EXP 49
16590: PPUSH
16591: LD_STRING DEnd-Szulc
16593: PPUSH
16594: CALL_OW 94
// dwait ( 0 0$1 ) ;
16598: LD_INT 35
16600: PPUSH
16601: CALL_OW 68
// if IsLive ( Burlak ) then
16605: LD_EXP 44
16609: PPUSH
16610: CALL_OW 300
16614: IFFALSE 16626
// med1 := 1 else
16616: LD_ADDR_VAR 0 1
16620: PUSH
16621: LD_INT 1
16623: ST_TO_ADDR
16624: GO 16635
// med1 := - 1 ;
16626: LD_ADDR_VAR 0 1
16630: PUSH
16631: LD_INT 1
16633: NEG
16634: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16635: LD_EXP 9
16639: PUSH
16640: LD_EXP 10
16644: AND
16645: PUSH
16646: LD_EXP 11
16650: AND
16651: IFFALSE 16663
// med2 := 1 else
16653: LD_ADDR_VAR 0 2
16657: PUSH
16658: LD_INT 1
16660: ST_TO_ADDR
16661: GO 16672
// med2 := - 1 ;
16663: LD_ADDR_VAR 0 2
16667: PUSH
16668: LD_INT 1
16670: NEG
16671: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
16672: LD_STRING Hero
16674: PPUSH
16675: LD_INT 1
16677: PPUSH
16678: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
16682: LD_STRING Artefact
16684: PPUSH
16685: LD_VAR 0 2
16689: PPUSH
16690: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
16694: LD_STRING ReconcileBurlak
16696: PPUSH
16697: LD_VAR 0 1
16701: PPUSH
16702: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
16706: LD_OWVAR 67
16710: PUSH
16711: LD_INT 3
16713: EQUAL
16714: PUSH
16715: LD_VAR 0 1
16719: PUSH
16720: LD_INT 1
16722: EQUAL
16723: AND
16724: PUSH
16725: LD_VAR 0 2
16729: PUSH
16730: LD_INT 1
16732: EQUAL
16733: AND
16734: IFFALSE 16746
// SetAchievementEX ( ACH_AMER , 19 ) ;
16736: LD_STRING ACH_AMER
16738: PPUSH
16739: LD_INT 19
16741: PPUSH
16742: CALL_OW 564
// GiveMedals ( MAIN ) ;
16746: LD_STRING MAIN
16748: PPUSH
16749: CALL_OW 102
// InGameOff ;
16753: CALL_OW 9
// DialogueOff ;
16757: CALL_OW 7
// music_nat := 1 ;
16761: LD_ADDR_OWVAR 71
16765: PUSH
16766: LD_INT 1
16768: ST_TO_ADDR
// music_class := 4 ;
16769: LD_ADDR_OWVAR 72
16773: PUSH
16774: LD_INT 4
16776: ST_TO_ADDR
// YouWin ;
16777: CALL_OW 103
// end ; end_of_file
16781: PPOPN 2
16783: END
// export function InitNature ; begin
16784: LD_INT 0
16786: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
16787: LD_INT 3
16789: PPUSH
16790: LD_INT 3
16792: PPUSH
16793: LD_INT 2
16795: PPUSH
16796: LD_INT 1
16798: PPUSH
16799: LD_INT 1
16801: PPUSH
16802: LD_INT 0
16804: PPUSH
16805: LD_INT 0
16807: PPUSH
16808: LD_INT 17
16810: PPUSH
16811: LD_INT 0
16813: PPUSH
16814: CALL 84685 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
16818: LD_INT 2
16820: PPUSH
16821: LD_INT 1
16823: PPUSH
16824: LD_INT 1
16826: PPUSH
16827: LD_INT 1
16829: PPUSH
16830: LD_INT 1
16832: PPUSH
16833: LD_INT 0
16835: PPUSH
16836: LD_INT 0
16838: PPUSH
16839: LD_INT 18
16841: PPUSH
16842: LD_INT 0
16844: PPUSH
16845: CALL 84685 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
16849: LD_INT 4
16851: PPUSH
16852: LD_INT 1
16854: PPUSH
16855: LD_INT 2
16857: PPUSH
16858: LD_INT 4
16860: PPUSH
16861: LD_INT 2
16863: PPUSH
16864: LD_INT 1
16866: PPUSH
16867: LD_INT 0
16869: PPUSH
16870: LD_INT 19
16872: PPUSH
16873: LD_INT 0
16875: PPUSH
16876: CALL 84685 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
16880: LD_INT 0
16882: PPUSH
16883: LD_INT 0
16885: PPUSH
16886: LD_INT 0
16888: PPUSH
16889: LD_INT 0
16891: PPUSH
16892: LD_INT 0
16894: PPUSH
16895: LD_INT 0
16897: PPUSH
16898: LD_INT 9
16900: PPUSH
16901: LD_INT 0
16903: PPUSH
16904: LD_INT 20
16906: PPUSH
16907: CALL 84685 0 9
// end ; end_of_file
16911: LD_VAR 0 1
16915: RET
// every 0 0$30 do var time ;
16916: GO 16918
16918: DISABLE
16919: LD_INT 0
16921: PPUSH
// begin time := 0 0$50 ;
16922: LD_ADDR_VAR 0 1
16926: PUSH
16927: LD_INT 1750
16929: ST_TO_ADDR
// repeat wait ( time ) ;
16930: LD_VAR 0 1
16934: PPUSH
16935: CALL_OW 67
// if Prob ( 50 ) then
16939: LD_INT 50
16941: PPUSH
16942: CALL_OW 13
16946: IFFALSE 16975
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
16948: LD_INT 1
16950: PPUSH
16951: LD_INT 5
16953: PPUSH
16954: CALL_OW 12
16958: PPUSH
16959: LD_INT 106
16961: PPUSH
16962: LD_INT 89
16964: PPUSH
16965: LD_INT 45
16967: PPUSH
16968: LD_INT 1
16970: PPUSH
16971: CALL_OW 56
// time := time + 0 0$3 ;
16975: LD_ADDR_VAR 0 1
16979: PUSH
16980: LD_VAR 0 1
16984: PUSH
16985: LD_INT 105
16987: PLUS
16988: ST_TO_ADDR
// if Prob ( 30 ) then
16989: LD_INT 30
16991: PPUSH
16992: CALL_OW 13
16996: IFFALSE 17042
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
16998: LD_INT 525
17000: PPUSH
17001: LD_INT 735
17003: PPUSH
17004: CALL_OW 12
17008: PPUSH
17009: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17013: LD_INT 1
17015: PPUSH
17016: LD_INT 5
17018: PPUSH
17019: CALL_OW 12
17023: PPUSH
17024: LD_INT 21
17026: PPUSH
17027: LD_INT 26
17029: PPUSH
17030: LD_INT 12
17032: PPUSH
17033: LD_INT 1
17035: PPUSH
17036: CALL_OW 56
// end else
17040: GO 17078
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17042: LD_INT 700
17044: PPUSH
17045: LD_INT 1225
17047: PPUSH
17048: CALL_OW 12
17052: PPUSH
17053: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17057: LD_INT 1
17059: PPUSH
17060: LD_INT 5
17062: PPUSH
17063: CALL_OW 12
17067: PPUSH
17068: LD_INT 14
17070: PPUSH
17071: LD_INT 1
17073: PPUSH
17074: CALL_OW 55
// end ; if Prob ( 50 ) then
17078: LD_INT 50
17080: PPUSH
17081: CALL_OW 13
17085: IFFALSE 17131
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17087: LD_INT 700
17089: PPUSH
17090: LD_INT 1050
17092: PPUSH
17093: CALL_OW 12
17097: PPUSH
17098: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17102: LD_INT 1
17104: PPUSH
17105: LD_INT 5
17107: PPUSH
17108: CALL_OW 12
17112: PPUSH
17113: LD_INT 181
17115: PPUSH
17116: LD_INT 218
17118: PPUSH
17119: LD_INT 16
17121: PPUSH
17122: LD_INT 1
17124: PPUSH
17125: CALL_OW 56
// end else
17129: GO 17203
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17131: LD_INT 350
17133: PPUSH
17134: LD_INT 525
17136: PPUSH
17137: CALL_OW 12
17141: PPUSH
17142: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17146: LD_INT 1
17148: PPUSH
17149: LD_INT 5
17151: PPUSH
17152: CALL_OW 12
17156: PPUSH
17157: LD_INT 13
17159: PPUSH
17160: LD_INT 1
17162: PPUSH
17163: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17167: LD_INT 350
17169: PPUSH
17170: LD_INT 700
17172: PPUSH
17173: CALL_OW 12
17177: PPUSH
17178: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17182: LD_INT 1
17184: PPUSH
17185: LD_INT 5
17187: PPUSH
17188: CALL_OW 12
17192: PPUSH
17193: LD_INT 33
17195: PPUSH
17196: LD_INT 1
17198: PPUSH
17199: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17203: LD_INT 65
17205: PUSH
17206: LD_INT 62
17208: PUSH
17209: LD_INT 55
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: PUSH
17217: LD_OWVAR 67
17221: ARRAY
17222: PPUSH
17223: CALL_OW 13
17227: IFFALSE 17273
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17229: LD_INT 525
17231: PPUSH
17232: LD_INT 875
17234: PPUSH
17235: CALL_OW 12
17239: PPUSH
17240: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17244: LD_INT 1
17246: PPUSH
17247: LD_INT 5
17249: PPUSH
17250: CALL_OW 12
17254: PPUSH
17255: LD_INT 294
17257: PPUSH
17258: LD_INT 211
17260: PPUSH
17261: LD_INT 30
17263: PPUSH
17264: LD_INT 1
17266: PPUSH
17267: CALL_OW 56
// end else
17271: GO 17315
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17273: LD_INT 420
17275: PPUSH
17276: LD_INT 770
17278: PPUSH
17279: CALL_OW 12
17283: PPUSH
17284: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17288: LD_INT 1
17290: PPUSH
17291: LD_INT 5
17293: PPUSH
17294: CALL_OW 12
17298: PPUSH
17299: LD_INT 294
17301: PPUSH
17302: LD_INT 211
17304: PPUSH
17305: LD_INT 30
17307: PPUSH
17308: LD_INT 1
17310: PPUSH
17311: CALL_OW 56
// end ; if time > 2 2$20 then
17315: LD_VAR 0 1
17319: PUSH
17320: LD_INT 4900
17322: GREATER
17323: IFFALSE 17333
// time := 0 0$50 ;
17325: LD_ADDR_VAR 0 1
17329: PUSH
17330: LD_INT 1750
17332: ST_TO_ADDR
// until false ;
17333: LD_INT 0
17335: IFFALSE 16930
// end ;
17337: PPOPN 1
17339: END
// every 0 0$45 trigger tick < 10 10$00 do
17340: LD_OWVAR 1
17344: PUSH
17345: LD_INT 21000
17347: LESS
17348: IFFALSE 17396
17350: GO 17352
17352: DISABLE
// begin enable ;
17353: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17354: LD_INT 350
17356: PPUSH
17357: LD_INT 700
17359: PPUSH
17360: CALL_OW 12
17364: PPUSH
17365: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17369: LD_INT 3
17371: PPUSH
17372: LD_INT 5
17374: PPUSH
17375: CALL_OW 12
17379: PPUSH
17380: LD_INT 181
17382: PPUSH
17383: LD_INT 13
17385: PPUSH
17386: LD_INT 20
17388: PPUSH
17389: LD_INT 1
17391: PPUSH
17392: CALL_OW 56
// end ; end_of_file
17396: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17397: LD_INT 0
17399: PPUSH
// SetArtifactRes ( 7 , true ) ;
17400: LD_INT 7
17402: PPUSH
17403: LD_INT 1
17405: PPUSH
17406: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17410: LD_ADDR_EXP 57
17414: PUSH
17415: EMPTY
17416: PUSH
17417: EMPTY
17418: PUSH
17419: EMPTY
17420: PUSH
17421: EMPTY
17422: LIST
17423: LIST
17424: LIST
17425: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17426: LD_ADDR_EXP 58
17430: PUSH
17431: LD_INT 1050
17433: PUSH
17434: LD_OWVAR 67
17438: MUL
17439: PUSH
17440: LD_INT 2800
17442: PUSH
17443: LD_OWVAR 67
17447: MUL
17448: PUSH
17449: LD_INT 1
17451: NEG
17452: PUSH
17453: EMPTY
17454: LIST
17455: LIST
17456: LIST
17457: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17458: LD_ADDR_EXP 59
17462: PUSH
17463: LD_INT 10
17465: PUSH
17466: LD_INT 35
17468: PUSH
17469: LD_INT 100
17471: PUSH
17472: EMPTY
17473: LIST
17474: LIST
17475: LIST
17476: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17477: LD_ADDR_EXP 60
17481: PUSH
17482: LD_INT 0
17484: PUSH
17485: LD_INT 0
17487: PUSH
17488: LD_INT 0
17490: PUSH
17491: EMPTY
17492: LIST
17493: LIST
17494: LIST
17495: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17496: LD_ADDR_EXP 62
17500: PUSH
17501: LD_INT 300
17503: PUSH
17504: LD_INT 500
17506: PUSH
17507: LD_INT 800
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: LIST
17514: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17515: LD_ADDR_EXP 63
17519: PUSH
17520: LD_INT 0
17522: PUSH
17523: LD_INT 0
17525: PUSH
17526: LD_INT 0
17528: PUSH
17529: EMPTY
17530: LIST
17531: LIST
17532: LIST
17533: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17534: LD_ADDR_EXP 64
17538: PUSH
17539: LD_INT 0
17541: PUSH
17542: LD_INT 0
17544: PUSH
17545: LD_INT 0
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: LIST
17552: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17553: LD_ADDR_EXP 61
17557: PUSH
17558: LD_INT 0
17560: PUSH
17561: LD_INT 0
17563: PUSH
17564: LD_INT 0
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: LIST
17571: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17572: LD_ADDR_EXP 65
17576: PUSH
17577: LD_INT 4
17579: PUSH
17580: LD_INT 3
17582: PUSH
17583: LD_INT 1
17585: PUSH
17586: EMPTY
17587: LIST
17588: LIST
17589: LIST
17590: PUSH
17591: LD_INT 5
17593: PUSH
17594: LD_INT 4
17596: PUSH
17597: LD_INT 2
17599: PUSH
17600: EMPTY
17601: LIST
17602: LIST
17603: LIST
17604: PUSH
17605: LD_INT 6
17607: PUSH
17608: LD_INT 3
17610: PUSH
17611: LD_INT 3
17613: PUSH
17614: EMPTY
17615: LIST
17616: LIST
17617: LIST
17618: PUSH
17619: EMPTY
17620: LIST
17621: LIST
17622: LIST
17623: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17624: LD_ADDR_EXP 66
17628: PUSH
17629: LD_INT 0
17631: PUSH
17632: LD_INT 0
17634: PUSH
17635: LD_INT 0
17637: PUSH
17638: EMPTY
17639: LIST
17640: LIST
17641: LIST
17642: ST_TO_ADDR
// end ;
17643: LD_VAR 0 1
17647: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17648: LD_INT 24
17650: PPUSH
17651: LD_INT 7
17653: PPUSH
17654: CALL_OW 321
17658: PUSH
17659: LD_INT 2
17661: EQUAL
17662: IFFALSE 18588
17664: GO 17666
17666: DISABLE
17667: LD_INT 0
17669: PPUSH
17670: PPUSH
17671: PPUSH
17672: PPUSH
17673: PPUSH
// begin enable ;
17674: ENABLE
// for i = 1 to 3 do
17675: LD_ADDR_VAR 0 1
17679: PUSH
17680: DOUBLE
17681: LD_INT 1
17683: DEC
17684: ST_TO_ADDR
17685: LD_INT 3
17687: PUSH
17688: FOR_TO
17689: IFFALSE 18586
// begin pos := FindArtifact ( i + 2 ) ;
17691: LD_ADDR_VAR 0 2
17695: PUSH
17696: LD_VAR 0 1
17700: PUSH
17701: LD_INT 2
17703: PLUS
17704: PPUSH
17705: CALL_OW 469
17709: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17710: LD_ADDR_EXP 57
17714: PUSH
17715: LD_EXP 57
17719: PPUSH
17720: LD_VAR 0 1
17724: PPUSH
17725: LD_VAR 0 2
17729: PPUSH
17730: CALL_OW 1
17734: ST_TO_ADDR
// if pos then
17735: LD_VAR 0 2
17739: IFFALSE 18447
// begin case i of 1 :
17741: LD_VAR 0 1
17745: PUSH
17746: LD_INT 1
17748: DOUBLE
17749: EQUAL
17750: IFTRUE 17754
17752: GO 17831
17754: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17755: LD_ADDR_VAR 0 4
17759: PUSH
17760: LD_INT 22
17762: PUSH
17763: LD_INT 7
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: PUSH
17770: LD_INT 23
17772: PUSH
17773: LD_INT 1
17775: PUSH
17776: EMPTY
17777: LIST
17778: LIST
17779: PUSH
17780: LD_INT 2
17782: PUSH
17783: LD_INT 30
17785: PUSH
17786: LD_INT 8
17788: PUSH
17789: EMPTY
17790: LIST
17791: LIST
17792: PUSH
17793: LD_INT 30
17795: PUSH
17796: LD_INT 7
17798: PUSH
17799: EMPTY
17800: LIST
17801: LIST
17802: PUSH
17803: LD_INT 30
17805: PUSH
17806: LD_INT 11
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: PUSH
17813: EMPTY
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: PPUSH
17824: CALL_OW 69
17828: ST_TO_ADDR
17829: GO 17939
17831: LD_INT 2
17833: DOUBLE
17834: EQUAL
17835: IFTRUE 17839
17837: GO 17916
17839: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
17840: LD_ADDR_VAR 0 4
17844: PUSH
17845: LD_INT 22
17847: PUSH
17848: LD_INT 7
17850: PUSH
17851: EMPTY
17852: LIST
17853: LIST
17854: PUSH
17855: LD_INT 23
17857: PUSH
17858: LD_INT 3
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: PUSH
17865: LD_INT 2
17867: PUSH
17868: LD_INT 30
17870: PUSH
17871: LD_INT 8
17873: PUSH
17874: EMPTY
17875: LIST
17876: LIST
17877: PUSH
17878: LD_INT 30
17880: PUSH
17881: LD_INT 7
17883: PUSH
17884: EMPTY
17885: LIST
17886: LIST
17887: PUSH
17888: LD_INT 30
17890: PUSH
17891: LD_INT 11
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: PUSH
17898: EMPTY
17899: LIST
17900: LIST
17901: LIST
17902: LIST
17903: PUSH
17904: EMPTY
17905: LIST
17906: LIST
17907: LIST
17908: PPUSH
17909: CALL_OW 69
17913: ST_TO_ADDR
17914: GO 17939
17916: LD_INT 3
17918: DOUBLE
17919: EQUAL
17920: IFTRUE 17924
17922: GO 17938
17924: POP
// labs := [ alien ] ; end ;
17925: LD_ADDR_VAR 0 4
17929: PUSH
17930: LD_INT 1
17932: PUSH
17933: EMPTY
17934: LIST
17935: ST_TO_ADDR
17936: GO 17939
17938: POP
// if not labs then
17939: LD_VAR 0 4
17943: NOT
17944: IFFALSE 17948
// continue ;
17946: GO 17688
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
17948: LD_ADDR_VAR 0 5
17952: PUSH
17953: LD_VAR 0 4
17957: PPUSH
17958: LD_EXP 57
17962: PUSH
17963: LD_VAR 0 1
17967: ARRAY
17968: PUSH
17969: LD_INT 1
17971: ARRAY
17972: PPUSH
17973: LD_EXP 57
17977: PUSH
17978: LD_VAR 0 1
17982: ARRAY
17983: PUSH
17984: LD_INT 2
17986: ARRAY
17987: PPUSH
17988: CALL_OW 73
17992: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
17993: LD_VAR 0 5
17997: NOT
17998: PUSH
17999: LD_VAR 0 5
18003: PUSH
18004: LD_EXP 64
18008: PUSH
18009: LD_VAR 0 1
18013: ARRAY
18014: NONEQUAL
18015: OR
18016: IFFALSE 18121
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18018: LD_INT 7
18020: PPUSH
18021: LD_EXP 65
18025: PUSH
18026: LD_VAR 0 1
18030: ARRAY
18031: PUSH
18032: LD_INT 3
18034: ARRAY
18035: PPUSH
18036: LD_INT 0
18038: PPUSH
18039: LD_EXP 64
18043: PUSH
18044: LD_VAR 0 1
18048: ARRAY
18049: PPUSH
18050: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18054: LD_INT 7
18056: PPUSH
18057: LD_EXP 65
18061: PUSH
18062: LD_VAR 0 1
18066: ARRAY
18067: PUSH
18068: LD_INT 1
18070: ARRAY
18071: PPUSH
18072: LD_INT 0
18074: PPUSH
18075: LD_EXP 64
18079: PUSH
18080: LD_VAR 0 1
18084: ARRAY
18085: PPUSH
18086: CALL_OW 468
// if nearestLab then
18090: LD_VAR 0 5
18094: IFFALSE 18121
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18096: LD_ADDR_EXP 64
18100: PUSH
18101: LD_EXP 64
18105: PPUSH
18106: LD_VAR 0 1
18110: PPUSH
18111: LD_VAR 0 5
18115: PPUSH
18116: CALL_OW 1
18120: ST_TO_ADDR
// end ; if not nearestLab then
18121: LD_VAR 0 5
18125: NOT
18126: IFFALSE 18130
// continue ;
18128: GO 17688
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18130: LD_VAR 0 5
18134: PPUSH
18135: LD_EXP 57
18139: PUSH
18140: LD_VAR 0 1
18144: ARRAY
18145: PUSH
18146: LD_INT 1
18148: ARRAY
18149: PPUSH
18150: LD_EXP 57
18154: PUSH
18155: LD_VAR 0 1
18159: ARRAY
18160: PUSH
18161: LD_INT 2
18163: ARRAY
18164: PPUSH
18165: CALL_OW 297
18169: PUSH
18170: LD_INT 8
18172: LESS
18173: IFFALSE 18370
// begin if not artifactsResearched [ i ] then
18175: LD_EXP 60
18179: PUSH
18180: LD_VAR 0 1
18184: ARRAY
18185: NOT
18186: IFFALSE 18267
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18188: LD_VAR 0 5
18192: PPUSH
18193: CALL_OW 461
18197: PUSH
18198: LD_INT 2
18200: EQUAL
18201: IFFALSE 18235
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18203: LD_INT 7
18205: PPUSH
18206: LD_EXP 65
18210: PUSH
18211: LD_VAR 0 1
18215: ARRAY
18216: PUSH
18217: LD_INT 3
18219: ARRAY
18220: PPUSH
18221: LD_INT 2
18223: PPUSH
18224: LD_VAR 0 5
18228: PPUSH
18229: CALL_OW 468
18233: GO 18265
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18235: LD_INT 7
18237: PPUSH
18238: LD_EXP 65
18242: PUSH
18243: LD_VAR 0 1
18247: ARRAY
18248: PUSH
18249: LD_INT 3
18251: ARRAY
18252: PPUSH
18253: LD_INT 1
18255: PPUSH
18256: LD_VAR 0 5
18260: PPUSH
18261: CALL_OW 468
// end else
18265: GO 18368
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18267: LD_VAR 0 5
18271: PPUSH
18272: CALL_OW 461
18276: PUSH
18277: LD_INT 2
18279: EQUAL
18280: PUSH
18281: LD_EXP 66
18285: PUSH
18286: LD_VAR 0 1
18290: ARRAY
18291: AND
18292: IFFALSE 18338
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18294: LD_INT 7
18296: PPUSH
18297: LD_EXP 65
18301: PUSH
18302: LD_VAR 0 1
18306: ARRAY
18307: PUSH
18308: LD_INT 1
18310: ARRAY
18311: PPUSH
18312: LD_EXP 65
18316: PUSH
18317: LD_VAR 0 1
18321: ARRAY
18322: PUSH
18323: LD_INT 2
18325: ARRAY
18326: PPUSH
18327: LD_VAR 0 5
18331: PPUSH
18332: CALL_OW 468
18336: GO 18368
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18338: LD_INT 7
18340: PPUSH
18341: LD_EXP 65
18345: PUSH
18346: LD_VAR 0 1
18350: ARRAY
18351: PUSH
18352: LD_INT 1
18354: ARRAY
18355: PPUSH
18356: LD_INT 1
18358: PPUSH
18359: LD_VAR 0 5
18363: PPUSH
18364: CALL_OW 468
// end else
18368: GO 18445
// begin if not artifactsResearched [ i ] then
18370: LD_EXP 60
18374: PUSH
18375: LD_VAR 0 1
18379: ARRAY
18380: NOT
18381: IFFALSE 18415
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18383: LD_INT 7
18385: PPUSH
18386: LD_EXP 65
18390: PUSH
18391: LD_VAR 0 1
18395: ARRAY
18396: PUSH
18397: LD_INT 3
18399: ARRAY
18400: PPUSH
18401: LD_INT 0
18403: PPUSH
18404: LD_VAR 0 5
18408: PPUSH
18409: CALL_OW 468
18413: GO 18445
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18415: LD_INT 7
18417: PPUSH
18418: LD_EXP 65
18422: PUSH
18423: LD_VAR 0 1
18427: ARRAY
18428: PUSH
18429: LD_INT 1
18431: ARRAY
18432: PPUSH
18433: LD_INT 0
18435: PPUSH
18436: LD_VAR 0 5
18440: PPUSH
18441: CALL_OW 468
// end ; end else
18445: GO 18584
// begin if not artifactsLabs [ i ] then
18447: LD_EXP 64
18451: PUSH
18452: LD_VAR 0 1
18456: ARRAY
18457: NOT
18458: IFFALSE 18462
// continue ;
18460: GO 17688
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18462: LD_INT 7
18464: PPUSH
18465: LD_EXP 65
18469: PUSH
18470: LD_VAR 0 1
18474: ARRAY
18475: PUSH
18476: LD_INT 3
18478: ARRAY
18479: PPUSH
18480: LD_INT 0
18482: PPUSH
18483: LD_EXP 64
18487: PUSH
18488: LD_VAR 0 1
18492: ARRAY
18493: PPUSH
18494: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18498: LD_INT 7
18500: PPUSH
18501: LD_EXP 65
18505: PUSH
18506: LD_VAR 0 1
18510: ARRAY
18511: PUSH
18512: LD_INT 1
18514: ARRAY
18515: PPUSH
18516: LD_INT 0
18518: PPUSH
18519: LD_EXP 64
18523: PUSH
18524: LD_VAR 0 1
18528: ARRAY
18529: PPUSH
18530: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18534: LD_EXP 61
18538: PUSH
18539: LD_VAR 0 1
18543: ARRAY
18544: IFFALSE 18584
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18546: LD_ADDR_EXP 61
18550: PUSH
18551: LD_EXP 61
18555: PPUSH
18556: LD_VAR 0 1
18560: PPUSH
18561: LD_INT 0
18563: PPUSH
18564: CALL_OW 1
18568: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18569: LD_EXP 64
18573: PUSH
18574: LD_VAR 0 1
18578: ARRAY
18579: PPUSH
18580: CALL_OW 127
// end ; end ; end ;
18584: GO 17688
18586: POP
18587: POP
// end ;
18588: PPOPN 5
18590: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18591: LD_INT 0
18593: PPUSH
18594: PPUSH
18595: PPUSH
18596: PPUSH
18597: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18598: LD_VAR 0 2
18602: PUSH
18603: LD_EXP 65
18607: PUSH
18608: LD_INT 1
18610: ARRAY
18611: PUSH
18612: LD_INT 3
18614: ARRAY
18615: EQUAL
18616: IFFALSE 18739
// begin lab := artifactsLabs [ 1 ] ;
18618: LD_ADDR_VAR 0 6
18622: PUSH
18623: LD_EXP 64
18627: PUSH
18628: LD_INT 1
18630: ARRAY
18631: ST_TO_ADDR
// if not lab then
18632: LD_VAR 0 6
18636: NOT
18637: IFFALSE 18641
// exit ;
18639: GO 19673
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18641: LD_VAR 0 6
18645: PPUSH
18646: LD_EXP 62
18650: PUSH
18651: LD_INT 1
18653: ARRAY
18654: PPUSH
18655: LD_INT 1
18657: PPUSH
18658: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18662: LD_EXP 63
18666: PUSH
18667: LD_INT 1
18669: ARRAY
18670: IFFALSE 18690
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18672: LD_VAR 0 6
18676: PPUSH
18677: LD_EXP 63
18681: PUSH
18682: LD_INT 1
18684: ARRAY
18685: PPUSH
18686: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18690: LD_ADDR_EXP 61
18694: PUSH
18695: LD_EXP 61
18699: PPUSH
18700: LD_INT 1
18702: PPUSH
18703: LD_INT 1
18705: PPUSH
18706: CALL_OW 1
18710: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18711: LD_INT 7
18713: PPUSH
18714: LD_EXP 65
18718: PUSH
18719: LD_INT 1
18721: ARRAY
18722: PUSH
18723: LD_INT 3
18725: ARRAY
18726: PPUSH
18727: LD_INT 0
18729: PPUSH
18730: LD_VAR 0 6
18734: PPUSH
18735: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18739: LD_VAR 0 2
18743: PUSH
18744: LD_EXP 65
18748: PUSH
18749: LD_INT 2
18751: ARRAY
18752: PUSH
18753: LD_INT 3
18755: ARRAY
18756: EQUAL
18757: IFFALSE 18880
// begin lab := artifactsLabs [ 2 ] ;
18759: LD_ADDR_VAR 0 6
18763: PUSH
18764: LD_EXP 64
18768: PUSH
18769: LD_INT 2
18771: ARRAY
18772: ST_TO_ADDR
// if not lab then
18773: LD_VAR 0 6
18777: NOT
18778: IFFALSE 18782
// exit ;
18780: GO 19673
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
18782: LD_VAR 0 6
18786: PPUSH
18787: LD_EXP 62
18791: PUSH
18792: LD_INT 2
18794: ARRAY
18795: PPUSH
18796: LD_INT 1
18798: PPUSH
18799: CALL_OW 486
// if artifactsResProgress [ 2 ] then
18803: LD_EXP 63
18807: PUSH
18808: LD_INT 2
18810: ARRAY
18811: IFFALSE 18831
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
18813: LD_VAR 0 6
18817: PPUSH
18818: LD_EXP 63
18822: PUSH
18823: LD_INT 2
18825: ARRAY
18826: PPUSH
18827: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
18831: LD_ADDR_EXP 61
18835: PUSH
18836: LD_EXP 61
18840: PPUSH
18841: LD_INT 2
18843: PPUSH
18844: LD_INT 1
18846: PPUSH
18847: CALL_OW 1
18851: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
18852: LD_INT 7
18854: PPUSH
18855: LD_EXP 65
18859: PUSH
18860: LD_INT 2
18862: ARRAY
18863: PUSH
18864: LD_INT 3
18866: ARRAY
18867: PPUSH
18868: LD_INT 0
18870: PPUSH
18871: LD_VAR 0 6
18875: PPUSH
18876: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
18880: LD_VAR 0 2
18884: PUSH
18885: LD_EXP 65
18889: PUSH
18890: LD_INT 3
18892: ARRAY
18893: PUSH
18894: LD_INT 3
18896: ARRAY
18897: EQUAL
18898: IFFALSE 19021
// begin lab := artifactsLabs [ 3 ] ;
18900: LD_ADDR_VAR 0 6
18904: PUSH
18905: LD_EXP 64
18909: PUSH
18910: LD_INT 3
18912: ARRAY
18913: ST_TO_ADDR
// if not lab then
18914: LD_VAR 0 6
18918: NOT
18919: IFFALSE 18923
// exit ;
18921: GO 19673
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
18923: LD_VAR 0 6
18927: PPUSH
18928: LD_EXP 62
18932: PUSH
18933: LD_INT 3
18935: ARRAY
18936: PPUSH
18937: LD_INT 1
18939: PPUSH
18940: CALL_OW 486
// if artifactsResProgress [ 3 ] then
18944: LD_EXP 63
18948: PUSH
18949: LD_INT 3
18951: ARRAY
18952: IFFALSE 18972
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
18954: LD_VAR 0 6
18958: PPUSH
18959: LD_EXP 63
18963: PUSH
18964: LD_INT 3
18966: ARRAY
18967: PPUSH
18968: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
18972: LD_ADDR_EXP 61
18976: PUSH
18977: LD_EXP 61
18981: PPUSH
18982: LD_INT 3
18984: PPUSH
18985: LD_INT 1
18987: PPUSH
18988: CALL_OW 1
18992: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
18993: LD_INT 7
18995: PPUSH
18996: LD_EXP 65
19000: PUSH
19001: LD_INT 3
19003: ARRAY
19004: PUSH
19005: LD_INT 3
19007: ARRAY
19008: PPUSH
19009: LD_INT 0
19011: PPUSH
19012: LD_VAR 0 6
19016: PPUSH
19017: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19021: LD_VAR 0 2
19025: PUSH
19026: LD_EXP 65
19030: PUSH
19031: LD_INT 1
19033: ARRAY
19034: PUSH
19035: LD_INT 1
19037: ARRAY
19038: EQUAL
19039: IFFALSE 19197
// begin lab := artifactsLabs [ 1 ] ;
19041: LD_ADDR_VAR 0 6
19045: PUSH
19046: LD_EXP 64
19050: PUSH
19051: LD_INT 1
19053: ARRAY
19054: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19055: LD_VAR 0 6
19059: PPUSH
19060: CALL_OW 274
19064: PPUSH
19065: CALL 92833 0 1
19069: PUSH
19070: LD_INT 3
19072: ARRAY
19073: PUSH
19074: LD_EXP 59
19078: PUSH
19079: LD_INT 1
19081: ARRAY
19082: LESS
19083: IFFALSE 19097
// begin HintSpec ( ArtifactCost , 2 ) ;
19085: LD_STRING ArtifactCost
19087: PPUSH
19088: LD_INT 2
19090: PPUSH
19091: CALL_OW 338
// exit ;
19095: GO 19673
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19097: LD_ADDR_EXP 66
19101: PUSH
19102: LD_EXP 66
19106: PPUSH
19107: LD_INT 1
19109: PPUSH
19110: LD_INT 0
19112: PPUSH
19113: CALL_OW 1
19117: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19118: LD_VAR 0 3
19122: PPUSH
19123: LD_VAR 0 4
19127: PPUSH
19128: LD_INT 7
19130: PPUSH
19131: LD_INT 12
19133: NEG
19134: PPUSH
19135: CALL_OW 330
// wait ( 0 0$30 ) ;
19139: LD_INT 1050
19141: PPUSH
19142: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19146: LD_VAR 0 3
19150: PPUSH
19151: LD_VAR 0 4
19155: PPUSH
19156: LD_INT 7
19158: PPUSH
19159: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19163: LD_EXP 58
19167: PUSH
19168: LD_INT 1
19170: ARRAY
19171: PPUSH
19172: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19176: LD_ADDR_EXP 66
19180: PUSH
19181: LD_EXP 66
19185: PPUSH
19186: LD_INT 1
19188: PPUSH
19189: LD_INT 1
19191: PPUSH
19192: CALL_OW 1
19196: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19197: LD_VAR 0 2
19201: PUSH
19202: LD_EXP 65
19206: PUSH
19207: LD_INT 2
19209: ARRAY
19210: PUSH
19211: LD_INT 1
19213: ARRAY
19214: EQUAL
19215: IFFALSE 19427
// begin lab := artifactsLabs [ 2 ] ;
19217: LD_ADDR_VAR 0 6
19221: PUSH
19222: LD_EXP 64
19226: PUSH
19227: LD_INT 2
19229: ARRAY
19230: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
19231: LD_VAR 0 3
19235: PUSH
19236: LD_INT 81
19238: PUSH
19239: LD_INT 7
19241: PUSH
19242: EMPTY
19243: LIST
19244: LIST
19245: PUSH
19246: LD_INT 2
19248: PUSH
19249: LD_INT 32
19251: PUSH
19252: LD_INT 3
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: PUSH
19259: LD_INT 30
19261: PUSH
19262: LD_INT 28
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: PUSH
19269: LD_INT 30
19271: PUSH
19272: LD_INT 30
19274: PUSH
19275: EMPTY
19276: LIST
19277: LIST
19278: PUSH
19279: LD_INT 35
19281: PUSH
19282: LD_INT 49
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: LD_INT 34
19291: PUSH
19292: LD_INT 49
19294: PUSH
19295: EMPTY
19296: LIST
19297: LIST
19298: PUSH
19299: EMPTY
19300: LIST
19301: LIST
19302: LIST
19303: LIST
19304: LIST
19305: LIST
19306: PUSH
19307: EMPTY
19308: LIST
19309: LIST
19310: PPUSH
19311: CALL_OW 69
19315: IN
19316: NOT
19317: IFFALSE 19321
// exit ;
19319: GO 19673
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19321: LD_VAR 0 6
19325: PPUSH
19326: CALL_OW 274
19330: PPUSH
19331: CALL 92833 0 1
19335: PUSH
19336: LD_INT 3
19338: ARRAY
19339: PUSH
19340: LD_EXP 59
19344: PUSH
19345: LD_INT 2
19347: ARRAY
19348: LESS
19349: IFFALSE 19363
// begin HintSpec ( ArtifactCost , 2 ) ;
19351: LD_STRING ArtifactCost
19353: PPUSH
19354: LD_INT 2
19356: PPUSH
19357: CALL_OW 338
// exit ;
19361: GO 19673
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19363: LD_ADDR_EXP 66
19367: PUSH
19368: LD_EXP 66
19372: PPUSH
19373: LD_INT 2
19375: PPUSH
19376: LD_INT 0
19378: PPUSH
19379: CALL_OW 1
19383: ST_TO_ADDR
// KillUnit ( x ) ;
19384: LD_VAR 0 3
19388: PPUSH
19389: CALL_OW 66
// wait ( artifactsRecharge [ 2 ] ) ;
19393: LD_EXP 58
19397: PUSH
19398: LD_INT 2
19400: ARRAY
19401: PPUSH
19402: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19406: LD_ADDR_EXP 66
19410: PUSH
19411: LD_EXP 66
19415: PPUSH
19416: LD_INT 2
19418: PPUSH
19419: LD_INT 1
19421: PPUSH
19422: CALL_OW 1
19426: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19427: LD_VAR 0 2
19431: PUSH
19432: LD_EXP 65
19436: PUSH
19437: LD_INT 3
19439: ARRAY
19440: PUSH
19441: LD_INT 1
19443: ARRAY
19444: EQUAL
19445: IFFALSE 19673
// begin lab := artifactsLabs [ 3 ] ;
19447: LD_ADDR_VAR 0 6
19451: PUSH
19452: LD_EXP 64
19456: PUSH
19457: LD_INT 3
19459: ARRAY
19460: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19461: LD_VAR 0 6
19465: PPUSH
19466: CALL_OW 274
19470: PPUSH
19471: CALL 92833 0 1
19475: PUSH
19476: LD_INT 3
19478: ARRAY
19479: PUSH
19480: LD_EXP 59
19484: PUSH
19485: LD_INT 3
19487: ARRAY
19488: LESS
19489: IFFALSE 19503
// begin HintSpec ( ArtifactCost , 2 ) ;
19491: LD_STRING ArtifactCost
19493: PPUSH
19494: LD_INT 2
19496: PPUSH
19497: CALL_OW 338
// exit ;
19501: GO 19673
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19503: LD_INT 37
19505: PPUSH
19506: LD_INT 1
19508: PPUSH
19509: CALL_OW 424
// time := 0 0$30 ;
19513: LD_ADDR_VAR 0 7
19517: PUSH
19518: LD_INT 1050
19520: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
19521: LD_ADDR_OWVAR 47
19525: PUSH
19526: LD_STRING Am15a-1
19528: PUSH
19529: LD_VAR 0 7
19533: PUSH
19534: EMPTY
19535: LIST
19536: LIST
19537: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19538: LD_INT 35
19540: PPUSH
19541: CALL_OW 67
// time := time - 0 0$1 ;
19545: LD_ADDR_VAR 0 7
19549: PUSH
19550: LD_VAR 0 7
19554: PUSH
19555: LD_INT 35
19557: MINUS
19558: ST_TO_ADDR
// until time = 0 0$00 ;
19559: LD_VAR 0 7
19563: PUSH
19564: LD_INT 0
19566: EQUAL
19567: IFFALSE 19521
// display_strings :=  ;
19569: LD_ADDR_OWVAR 47
19573: PUSH
19574: LD_STRING 
19576: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19577: LD_INT 37
19579: PPUSH
19580: LD_INT 0
19582: PPUSH
19583: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19587: LD_ADDR_VAR 0 8
19591: PUSH
19592: LD_INT 37
19594: PPUSH
19595: LD_INT 3
19597: PUSH
19598: LD_INT 21
19600: PUSH
19601: LD_INT 3
19603: PUSH
19604: EMPTY
19605: LIST
19606: LIST
19607: PUSH
19608: EMPTY
19609: LIST
19610: LIST
19611: PPUSH
19612: CALL_OW 70
19616: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19617: LD_VAR 0 3
19621: PPUSH
19622: LD_VAR 0 4
19626: PPUSH
19627: CALL_OW 84
// for un in list do
19631: LD_ADDR_VAR 0 9
19635: PUSH
19636: LD_VAR 0 8
19640: PUSH
19641: FOR_IN
19642: IFFALSE 19671
// TeleportUnit ( un , x , y , 12 , true ) ;
19644: LD_VAR 0 9
19648: PPUSH
19649: LD_VAR 0 3
19653: PPUSH
19654: LD_VAR 0 4
19658: PPUSH
19659: LD_INT 12
19661: PPUSH
19662: LD_INT 1
19664: PPUSH
19665: CALL_OW 483
19669: GO 19641
19671: POP
19672: POP
// end ; end ;
19673: PPOPN 9
19675: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19676: LD_INT 0
19678: PPUSH
19679: PPUSH
// begin labNum := 0 ;
19680: LD_ADDR_VAR 0 4
19684: PUSH
19685: LD_INT 0
19687: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19688: LD_ADDR_VAR 0 3
19692: PUSH
19693: DOUBLE
19694: LD_INT 1
19696: DEC
19697: ST_TO_ADDR
19698: LD_EXP 64
19702: PUSH
19703: FOR_TO
19704: IFFALSE 19738
// if artifactsLabs [ i ] = lab then
19706: LD_EXP 64
19710: PUSH
19711: LD_VAR 0 3
19715: ARRAY
19716: PUSH
19717: LD_VAR 0 1
19721: EQUAL
19722: IFFALSE 19736
// begin labNum := i ;
19724: LD_ADDR_VAR 0 4
19728: PUSH
19729: LD_VAR 0 3
19733: ST_TO_ADDR
// break ;
19734: GO 19738
// end ;
19736: GO 19703
19738: POP
19739: POP
// if not labNum then
19740: LD_VAR 0 4
19744: NOT
19745: IFFALSE 19749
// exit ;
19747: GO 19827
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
19749: LD_INT 7
19751: PPUSH
19752: LD_EXP 65
19756: PUSH
19757: LD_VAR 0 4
19761: ARRAY
19762: PUSH
19763: LD_INT 3
19765: ARRAY
19766: PPUSH
19767: LD_INT 2
19769: PPUSH
19770: LD_VAR 0 1
19774: PPUSH
19775: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
19779: LD_ADDR_EXP 63
19783: PUSH
19784: LD_EXP 63
19788: PPUSH
19789: LD_VAR 0 4
19793: PPUSH
19794: LD_VAR 0 2
19798: PPUSH
19799: CALL_OW 1
19803: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
19804: LD_ADDR_EXP 61
19808: PUSH
19809: LD_EXP 61
19813: PPUSH
19814: LD_VAR 0 4
19818: PPUSH
19819: LD_INT 0
19821: PPUSH
19822: CALL_OW 1
19826: ST_TO_ADDR
// end ;
19827: PPOPN 4
19829: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
19830: LD_INT 0
19832: PPUSH
19833: PPUSH
// begin labNum := 0 ;
19834: LD_ADDR_VAR 0 3
19838: PUSH
19839: LD_INT 0
19841: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19842: LD_ADDR_VAR 0 2
19846: PUSH
19847: DOUBLE
19848: LD_INT 1
19850: DEC
19851: ST_TO_ADDR
19852: LD_EXP 64
19856: PUSH
19857: FOR_TO
19858: IFFALSE 19892
// if artifactsLabs [ i ] = lab then
19860: LD_EXP 64
19864: PUSH
19865: LD_VAR 0 2
19869: ARRAY
19870: PUSH
19871: LD_VAR 0 1
19875: EQUAL
19876: IFFALSE 19890
// begin labNum := i ;
19878: LD_ADDR_VAR 0 3
19882: PUSH
19883: LD_VAR 0 2
19887: ST_TO_ADDR
// break ;
19888: GO 19892
// end ;
19890: GO 19857
19892: POP
19893: POP
// if not labNum then
19894: LD_VAR 0 3
19898: NOT
19899: IFFALSE 19903
// exit ;
19901: GO 20065
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
19903: LD_INT 7
19905: PPUSH
19906: LD_EXP 65
19910: PUSH
19911: LD_VAR 0 3
19915: ARRAY
19916: PUSH
19917: LD_INT 3
19919: ARRAY
19920: PPUSH
19921: LD_INT 0
19923: PPUSH
19924: LD_VAR 0 1
19928: PPUSH
19929: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
19933: LD_ADDR_EXP 60
19937: PUSH
19938: LD_EXP 60
19942: PPUSH
19943: LD_VAR 0 3
19947: PPUSH
19948: LD_INT 1
19950: PPUSH
19951: CALL_OW 1
19955: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
19956: LD_ADDR_EXP 66
19960: PUSH
19961: LD_EXP 66
19965: PPUSH
19966: LD_VAR 0 3
19970: PPUSH
19971: LD_INT 1
19973: PPUSH
19974: CALL_OW 1
19978: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
19979: LD_ADDR_EXP 61
19983: PUSH
19984: LD_EXP 61
19988: PPUSH
19989: LD_VAR 0 3
19993: PPUSH
19994: LD_INT 0
19996: PPUSH
19997: CALL_OW 1
20001: ST_TO_ADDR
// case labNum of 1 :
20002: LD_VAR 0 3
20006: PUSH
20007: LD_INT 1
20009: DOUBLE
20010: EQUAL
20011: IFTRUE 20015
20013: GO 20026
20015: POP
// artifactIResearched := true ; 2 :
20016: LD_ADDR_EXP 9
20020: PUSH
20021: LD_INT 1
20023: ST_TO_ADDR
20024: GO 20065
20026: LD_INT 2
20028: DOUBLE
20029: EQUAL
20030: IFTRUE 20034
20032: GO 20045
20034: POP
// artifactIIResearched := true ; 3 :
20035: LD_ADDR_EXP 10
20039: PUSH
20040: LD_INT 1
20042: ST_TO_ADDR
20043: GO 20065
20045: LD_INT 3
20047: DOUBLE
20048: EQUAL
20049: IFTRUE 20053
20051: GO 20064
20053: POP
// artifactIIIResearched := true ; end ;
20054: LD_ADDR_EXP 11
20058: PUSH
20059: LD_INT 1
20061: ST_TO_ADDR
20062: GO 20065
20064: POP
// end ; end_of_file
20065: PPOPN 3
20067: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20068: GO 20070
20070: DISABLE
// begin ru_radar := 98 ;
20071: LD_ADDR_EXP 67
20075: PUSH
20076: LD_INT 98
20078: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20079: LD_ADDR_EXP 68
20083: PUSH
20084: LD_INT 89
20086: ST_TO_ADDR
// us_hack := 99 ;
20087: LD_ADDR_EXP 69
20091: PUSH
20092: LD_INT 99
20094: ST_TO_ADDR
// us_artillery := 97 ;
20095: LD_ADDR_EXP 70
20099: PUSH
20100: LD_INT 97
20102: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20103: LD_ADDR_EXP 71
20107: PUSH
20108: LD_INT 91
20110: ST_TO_ADDR
// end ; end_of_file
20111: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20112: LD_INT 0
20114: PPUSH
20115: PPUSH
// skirmish := false ;
20116: LD_ADDR_EXP 72
20120: PUSH
20121: LD_INT 0
20123: ST_TO_ADDR
// debug_mc := false ;
20124: LD_ADDR_EXP 73
20128: PUSH
20129: LD_INT 0
20131: ST_TO_ADDR
// mc_bases := [ ] ;
20132: LD_ADDR_EXP 74
20136: PUSH
20137: EMPTY
20138: ST_TO_ADDR
// mc_sides := [ ] ;
20139: LD_ADDR_EXP 100
20143: PUSH
20144: EMPTY
20145: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20146: LD_ADDR_EXP 75
20150: PUSH
20151: EMPTY
20152: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20153: LD_ADDR_EXP 76
20157: PUSH
20158: EMPTY
20159: ST_TO_ADDR
// mc_need_heal := [ ] ;
20160: LD_ADDR_EXP 77
20164: PUSH
20165: EMPTY
20166: ST_TO_ADDR
// mc_healers := [ ] ;
20167: LD_ADDR_EXP 78
20171: PUSH
20172: EMPTY
20173: ST_TO_ADDR
// mc_build_list := [ ] ;
20174: LD_ADDR_EXP 79
20178: PUSH
20179: EMPTY
20180: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20181: LD_ADDR_EXP 106
20185: PUSH
20186: EMPTY
20187: ST_TO_ADDR
// mc_builders := [ ] ;
20188: LD_ADDR_EXP 80
20192: PUSH
20193: EMPTY
20194: ST_TO_ADDR
// mc_construct_list := [ ] ;
20195: LD_ADDR_EXP 81
20199: PUSH
20200: EMPTY
20201: ST_TO_ADDR
// mc_turret_list := [ ] ;
20202: LD_ADDR_EXP 82
20206: PUSH
20207: EMPTY
20208: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20209: LD_ADDR_EXP 83
20213: PUSH
20214: EMPTY
20215: ST_TO_ADDR
// mc_miners := [ ] ;
20216: LD_ADDR_EXP 88
20220: PUSH
20221: EMPTY
20222: ST_TO_ADDR
// mc_mines := [ ] ;
20223: LD_ADDR_EXP 87
20227: PUSH
20228: EMPTY
20229: ST_TO_ADDR
// mc_minefields := [ ] ;
20230: LD_ADDR_EXP 89
20234: PUSH
20235: EMPTY
20236: ST_TO_ADDR
// mc_crates := [ ] ;
20237: LD_ADDR_EXP 90
20241: PUSH
20242: EMPTY
20243: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20244: LD_ADDR_EXP 91
20248: PUSH
20249: EMPTY
20250: ST_TO_ADDR
// mc_crates_area := [ ] ;
20251: LD_ADDR_EXP 92
20255: PUSH
20256: EMPTY
20257: ST_TO_ADDR
// mc_vehicles := [ ] ;
20258: LD_ADDR_EXP 93
20262: PUSH
20263: EMPTY
20264: ST_TO_ADDR
// mc_attack := [ ] ;
20265: LD_ADDR_EXP 94
20269: PUSH
20270: EMPTY
20271: ST_TO_ADDR
// mc_produce := [ ] ;
20272: LD_ADDR_EXP 95
20276: PUSH
20277: EMPTY
20278: ST_TO_ADDR
// mc_defender := [ ] ;
20279: LD_ADDR_EXP 96
20283: PUSH
20284: EMPTY
20285: ST_TO_ADDR
// mc_parking := [ ] ;
20286: LD_ADDR_EXP 98
20290: PUSH
20291: EMPTY
20292: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20293: LD_ADDR_EXP 84
20297: PUSH
20298: EMPTY
20299: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20300: LD_ADDR_EXP 86
20304: PUSH
20305: EMPTY
20306: ST_TO_ADDR
// mc_scan := [ ] ;
20307: LD_ADDR_EXP 97
20311: PUSH
20312: EMPTY
20313: ST_TO_ADDR
// mc_scan_area := [ ] ;
20314: LD_ADDR_EXP 99
20318: PUSH
20319: EMPTY
20320: ST_TO_ADDR
// mc_tech := [ ] ;
20321: LD_ADDR_EXP 101
20325: PUSH
20326: EMPTY
20327: ST_TO_ADDR
// mc_class := [ ] ;
20328: LD_ADDR_EXP 115
20332: PUSH
20333: EMPTY
20334: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20335: LD_ADDR_EXP 116
20339: PUSH
20340: EMPTY
20341: ST_TO_ADDR
// end ;
20342: LD_VAR 0 1
20346: RET
// export function MC_Kill ( base ) ; begin
20347: LD_INT 0
20349: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20350: LD_ADDR_EXP 74
20354: PUSH
20355: LD_EXP 74
20359: PPUSH
20360: LD_VAR 0 1
20364: PPUSH
20365: EMPTY
20366: PPUSH
20367: CALL_OW 1
20371: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20372: LD_ADDR_EXP 75
20376: PUSH
20377: LD_EXP 75
20381: PPUSH
20382: LD_VAR 0 1
20386: PPUSH
20387: EMPTY
20388: PPUSH
20389: CALL_OW 1
20393: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20394: LD_ADDR_EXP 76
20398: PUSH
20399: LD_EXP 76
20403: PPUSH
20404: LD_VAR 0 1
20408: PPUSH
20409: EMPTY
20410: PPUSH
20411: CALL_OW 1
20415: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20416: LD_ADDR_EXP 77
20420: PUSH
20421: LD_EXP 77
20425: PPUSH
20426: LD_VAR 0 1
20430: PPUSH
20431: EMPTY
20432: PPUSH
20433: CALL_OW 1
20437: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20438: LD_ADDR_EXP 78
20442: PUSH
20443: LD_EXP 78
20447: PPUSH
20448: LD_VAR 0 1
20452: PPUSH
20453: EMPTY
20454: PPUSH
20455: CALL_OW 1
20459: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20460: LD_ADDR_EXP 79
20464: PUSH
20465: LD_EXP 79
20469: PPUSH
20470: LD_VAR 0 1
20474: PPUSH
20475: EMPTY
20476: PPUSH
20477: CALL_OW 1
20481: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20482: LD_ADDR_EXP 80
20486: PUSH
20487: LD_EXP 80
20491: PPUSH
20492: LD_VAR 0 1
20496: PPUSH
20497: EMPTY
20498: PPUSH
20499: CALL_OW 1
20503: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20504: LD_ADDR_EXP 81
20508: PUSH
20509: LD_EXP 81
20513: PPUSH
20514: LD_VAR 0 1
20518: PPUSH
20519: EMPTY
20520: PPUSH
20521: CALL_OW 1
20525: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20526: LD_ADDR_EXP 82
20530: PUSH
20531: LD_EXP 82
20535: PPUSH
20536: LD_VAR 0 1
20540: PPUSH
20541: EMPTY
20542: PPUSH
20543: CALL_OW 1
20547: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20548: LD_ADDR_EXP 83
20552: PUSH
20553: LD_EXP 83
20557: PPUSH
20558: LD_VAR 0 1
20562: PPUSH
20563: EMPTY
20564: PPUSH
20565: CALL_OW 1
20569: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20570: LD_ADDR_EXP 84
20574: PUSH
20575: LD_EXP 84
20579: PPUSH
20580: LD_VAR 0 1
20584: PPUSH
20585: EMPTY
20586: PPUSH
20587: CALL_OW 1
20591: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20592: LD_ADDR_EXP 85
20596: PUSH
20597: LD_EXP 85
20601: PPUSH
20602: LD_VAR 0 1
20606: PPUSH
20607: LD_INT 0
20609: PPUSH
20610: CALL_OW 1
20614: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20615: LD_ADDR_EXP 86
20619: PUSH
20620: LD_EXP 86
20624: PPUSH
20625: LD_VAR 0 1
20629: PPUSH
20630: EMPTY
20631: PPUSH
20632: CALL_OW 1
20636: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20637: LD_ADDR_EXP 87
20641: PUSH
20642: LD_EXP 87
20646: PPUSH
20647: LD_VAR 0 1
20651: PPUSH
20652: EMPTY
20653: PPUSH
20654: CALL_OW 1
20658: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20659: LD_ADDR_EXP 88
20663: PUSH
20664: LD_EXP 88
20668: PPUSH
20669: LD_VAR 0 1
20673: PPUSH
20674: EMPTY
20675: PPUSH
20676: CALL_OW 1
20680: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20681: LD_ADDR_EXP 89
20685: PUSH
20686: LD_EXP 89
20690: PPUSH
20691: LD_VAR 0 1
20695: PPUSH
20696: EMPTY
20697: PPUSH
20698: CALL_OW 1
20702: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20703: LD_ADDR_EXP 90
20707: PUSH
20708: LD_EXP 90
20712: PPUSH
20713: LD_VAR 0 1
20717: PPUSH
20718: EMPTY
20719: PPUSH
20720: CALL_OW 1
20724: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20725: LD_ADDR_EXP 91
20729: PUSH
20730: LD_EXP 91
20734: PPUSH
20735: LD_VAR 0 1
20739: PPUSH
20740: EMPTY
20741: PPUSH
20742: CALL_OW 1
20746: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20747: LD_ADDR_EXP 92
20751: PUSH
20752: LD_EXP 92
20756: PPUSH
20757: LD_VAR 0 1
20761: PPUSH
20762: EMPTY
20763: PPUSH
20764: CALL_OW 1
20768: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20769: LD_ADDR_EXP 93
20773: PUSH
20774: LD_EXP 93
20778: PPUSH
20779: LD_VAR 0 1
20783: PPUSH
20784: EMPTY
20785: PPUSH
20786: CALL_OW 1
20790: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20791: LD_ADDR_EXP 94
20795: PUSH
20796: LD_EXP 94
20800: PPUSH
20801: LD_VAR 0 1
20805: PPUSH
20806: EMPTY
20807: PPUSH
20808: CALL_OW 1
20812: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20813: LD_ADDR_EXP 95
20817: PUSH
20818: LD_EXP 95
20822: PPUSH
20823: LD_VAR 0 1
20827: PPUSH
20828: EMPTY
20829: PPUSH
20830: CALL_OW 1
20834: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20835: LD_ADDR_EXP 96
20839: PUSH
20840: LD_EXP 96
20844: PPUSH
20845: LD_VAR 0 1
20849: PPUSH
20850: EMPTY
20851: PPUSH
20852: CALL_OW 1
20856: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20857: LD_ADDR_EXP 97
20861: PUSH
20862: LD_EXP 97
20866: PPUSH
20867: LD_VAR 0 1
20871: PPUSH
20872: EMPTY
20873: PPUSH
20874: CALL_OW 1
20878: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20879: LD_ADDR_EXP 98
20883: PUSH
20884: LD_EXP 98
20888: PPUSH
20889: LD_VAR 0 1
20893: PPUSH
20894: EMPTY
20895: PPUSH
20896: CALL_OW 1
20900: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20901: LD_ADDR_EXP 99
20905: PUSH
20906: LD_EXP 99
20910: PPUSH
20911: LD_VAR 0 1
20915: PPUSH
20916: EMPTY
20917: PPUSH
20918: CALL_OW 1
20922: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20923: LD_ADDR_EXP 101
20927: PUSH
20928: LD_EXP 101
20932: PPUSH
20933: LD_VAR 0 1
20937: PPUSH
20938: EMPTY
20939: PPUSH
20940: CALL_OW 1
20944: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20945: LD_ADDR_EXP 103
20949: PUSH
20950: LD_EXP 103
20954: PPUSH
20955: LD_VAR 0 1
20959: PPUSH
20960: EMPTY
20961: PPUSH
20962: CALL_OW 1
20966: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20967: LD_ADDR_EXP 104
20971: PUSH
20972: LD_EXP 104
20976: PPUSH
20977: LD_VAR 0 1
20981: PPUSH
20982: EMPTY
20983: PPUSH
20984: CALL_OW 1
20988: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20989: LD_ADDR_EXP 105
20993: PUSH
20994: LD_EXP 105
20998: PPUSH
20999: LD_VAR 0 1
21003: PPUSH
21004: EMPTY
21005: PPUSH
21006: CALL_OW 1
21010: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21011: LD_ADDR_EXP 106
21015: PUSH
21016: LD_EXP 106
21020: PPUSH
21021: LD_VAR 0 1
21025: PPUSH
21026: EMPTY
21027: PPUSH
21028: CALL_OW 1
21032: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21033: LD_ADDR_EXP 107
21037: PUSH
21038: LD_EXP 107
21042: PPUSH
21043: LD_VAR 0 1
21047: PPUSH
21048: EMPTY
21049: PPUSH
21050: CALL_OW 1
21054: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21055: LD_ADDR_EXP 108
21059: PUSH
21060: LD_EXP 108
21064: PPUSH
21065: LD_VAR 0 1
21069: PPUSH
21070: EMPTY
21071: PPUSH
21072: CALL_OW 1
21076: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21077: LD_ADDR_EXP 109
21081: PUSH
21082: LD_EXP 109
21086: PPUSH
21087: LD_VAR 0 1
21091: PPUSH
21092: EMPTY
21093: PPUSH
21094: CALL_OW 1
21098: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21099: LD_ADDR_EXP 110
21103: PUSH
21104: LD_EXP 110
21108: PPUSH
21109: LD_VAR 0 1
21113: PPUSH
21114: EMPTY
21115: PPUSH
21116: CALL_OW 1
21120: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21121: LD_ADDR_EXP 111
21125: PUSH
21126: LD_EXP 111
21130: PPUSH
21131: LD_VAR 0 1
21135: PPUSH
21136: EMPTY
21137: PPUSH
21138: CALL_OW 1
21142: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21143: LD_ADDR_EXP 112
21147: PUSH
21148: LD_EXP 112
21152: PPUSH
21153: LD_VAR 0 1
21157: PPUSH
21158: EMPTY
21159: PPUSH
21160: CALL_OW 1
21164: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21165: LD_ADDR_EXP 113
21169: PUSH
21170: LD_EXP 113
21174: PPUSH
21175: LD_VAR 0 1
21179: PPUSH
21180: EMPTY
21181: PPUSH
21182: CALL_OW 1
21186: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21187: LD_ADDR_EXP 114
21191: PUSH
21192: LD_EXP 114
21196: PPUSH
21197: LD_VAR 0 1
21201: PPUSH
21202: EMPTY
21203: PPUSH
21204: CALL_OW 1
21208: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21209: LD_ADDR_EXP 115
21213: PUSH
21214: LD_EXP 115
21218: PPUSH
21219: LD_VAR 0 1
21223: PPUSH
21224: EMPTY
21225: PPUSH
21226: CALL_OW 1
21230: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21231: LD_ADDR_EXP 116
21235: PUSH
21236: LD_EXP 116
21240: PPUSH
21241: LD_VAR 0 1
21245: PPUSH
21246: LD_INT 0
21248: PPUSH
21249: CALL_OW 1
21253: ST_TO_ADDR
// end ;
21254: LD_VAR 0 2
21258: RET
// export function MC_Add ( side , units ) ; var base ; begin
21259: LD_INT 0
21261: PPUSH
21262: PPUSH
// base := mc_bases + 1 ;
21263: LD_ADDR_VAR 0 4
21267: PUSH
21268: LD_EXP 74
21272: PUSH
21273: LD_INT 1
21275: PLUS
21276: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21277: LD_ADDR_EXP 100
21281: PUSH
21282: LD_EXP 100
21286: PPUSH
21287: LD_VAR 0 4
21291: PPUSH
21292: LD_VAR 0 1
21296: PPUSH
21297: CALL_OW 1
21301: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21302: LD_ADDR_EXP 74
21306: PUSH
21307: LD_EXP 74
21311: PPUSH
21312: LD_VAR 0 4
21316: PPUSH
21317: LD_VAR 0 2
21321: PPUSH
21322: CALL_OW 1
21326: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21327: LD_ADDR_EXP 75
21331: PUSH
21332: LD_EXP 75
21336: PPUSH
21337: LD_VAR 0 4
21341: PPUSH
21342: EMPTY
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21349: LD_ADDR_EXP 76
21353: PUSH
21354: LD_EXP 76
21358: PPUSH
21359: LD_VAR 0 4
21363: PPUSH
21364: EMPTY
21365: PPUSH
21366: CALL_OW 1
21370: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21371: LD_ADDR_EXP 77
21375: PUSH
21376: LD_EXP 77
21380: PPUSH
21381: LD_VAR 0 4
21385: PPUSH
21386: EMPTY
21387: PPUSH
21388: CALL_OW 1
21392: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21393: LD_ADDR_EXP 78
21397: PUSH
21398: LD_EXP 78
21402: PPUSH
21403: LD_VAR 0 4
21407: PPUSH
21408: EMPTY
21409: PPUSH
21410: CALL_OW 1
21414: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21415: LD_ADDR_EXP 79
21419: PUSH
21420: LD_EXP 79
21424: PPUSH
21425: LD_VAR 0 4
21429: PPUSH
21430: EMPTY
21431: PPUSH
21432: CALL_OW 1
21436: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21437: LD_ADDR_EXP 80
21441: PUSH
21442: LD_EXP 80
21446: PPUSH
21447: LD_VAR 0 4
21451: PPUSH
21452: EMPTY
21453: PPUSH
21454: CALL_OW 1
21458: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21459: LD_ADDR_EXP 81
21463: PUSH
21464: LD_EXP 81
21468: PPUSH
21469: LD_VAR 0 4
21473: PPUSH
21474: EMPTY
21475: PPUSH
21476: CALL_OW 1
21480: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21481: LD_ADDR_EXP 82
21485: PUSH
21486: LD_EXP 82
21490: PPUSH
21491: LD_VAR 0 4
21495: PPUSH
21496: EMPTY
21497: PPUSH
21498: CALL_OW 1
21502: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21503: LD_ADDR_EXP 83
21507: PUSH
21508: LD_EXP 83
21512: PPUSH
21513: LD_VAR 0 4
21517: PPUSH
21518: EMPTY
21519: PPUSH
21520: CALL_OW 1
21524: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21525: LD_ADDR_EXP 84
21529: PUSH
21530: LD_EXP 84
21534: PPUSH
21535: LD_VAR 0 4
21539: PPUSH
21540: EMPTY
21541: PPUSH
21542: CALL_OW 1
21546: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21547: LD_ADDR_EXP 85
21551: PUSH
21552: LD_EXP 85
21556: PPUSH
21557: LD_VAR 0 4
21561: PPUSH
21562: LD_INT 0
21564: PPUSH
21565: CALL_OW 1
21569: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21570: LD_ADDR_EXP 86
21574: PUSH
21575: LD_EXP 86
21579: PPUSH
21580: LD_VAR 0 4
21584: PPUSH
21585: EMPTY
21586: PPUSH
21587: CALL_OW 1
21591: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21592: LD_ADDR_EXP 87
21596: PUSH
21597: LD_EXP 87
21601: PPUSH
21602: LD_VAR 0 4
21606: PPUSH
21607: EMPTY
21608: PPUSH
21609: CALL_OW 1
21613: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21614: LD_ADDR_EXP 88
21618: PUSH
21619: LD_EXP 88
21623: PPUSH
21624: LD_VAR 0 4
21628: PPUSH
21629: EMPTY
21630: PPUSH
21631: CALL_OW 1
21635: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21636: LD_ADDR_EXP 89
21640: PUSH
21641: LD_EXP 89
21645: PPUSH
21646: LD_VAR 0 4
21650: PPUSH
21651: EMPTY
21652: PPUSH
21653: CALL_OW 1
21657: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21658: LD_ADDR_EXP 90
21662: PUSH
21663: LD_EXP 90
21667: PPUSH
21668: LD_VAR 0 4
21672: PPUSH
21673: EMPTY
21674: PPUSH
21675: CALL_OW 1
21679: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21680: LD_ADDR_EXP 91
21684: PUSH
21685: LD_EXP 91
21689: PPUSH
21690: LD_VAR 0 4
21694: PPUSH
21695: EMPTY
21696: PPUSH
21697: CALL_OW 1
21701: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21702: LD_ADDR_EXP 92
21706: PUSH
21707: LD_EXP 92
21711: PPUSH
21712: LD_VAR 0 4
21716: PPUSH
21717: EMPTY
21718: PPUSH
21719: CALL_OW 1
21723: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21724: LD_ADDR_EXP 93
21728: PUSH
21729: LD_EXP 93
21733: PPUSH
21734: LD_VAR 0 4
21738: PPUSH
21739: EMPTY
21740: PPUSH
21741: CALL_OW 1
21745: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21746: LD_ADDR_EXP 94
21750: PUSH
21751: LD_EXP 94
21755: PPUSH
21756: LD_VAR 0 4
21760: PPUSH
21761: EMPTY
21762: PPUSH
21763: CALL_OW 1
21767: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21768: LD_ADDR_EXP 95
21772: PUSH
21773: LD_EXP 95
21777: PPUSH
21778: LD_VAR 0 4
21782: PPUSH
21783: EMPTY
21784: PPUSH
21785: CALL_OW 1
21789: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21790: LD_ADDR_EXP 96
21794: PUSH
21795: LD_EXP 96
21799: PPUSH
21800: LD_VAR 0 4
21804: PPUSH
21805: EMPTY
21806: PPUSH
21807: CALL_OW 1
21811: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21812: LD_ADDR_EXP 97
21816: PUSH
21817: LD_EXP 97
21821: PPUSH
21822: LD_VAR 0 4
21826: PPUSH
21827: EMPTY
21828: PPUSH
21829: CALL_OW 1
21833: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21834: LD_ADDR_EXP 98
21838: PUSH
21839: LD_EXP 98
21843: PPUSH
21844: LD_VAR 0 4
21848: PPUSH
21849: EMPTY
21850: PPUSH
21851: CALL_OW 1
21855: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21856: LD_ADDR_EXP 99
21860: PUSH
21861: LD_EXP 99
21865: PPUSH
21866: LD_VAR 0 4
21870: PPUSH
21871: EMPTY
21872: PPUSH
21873: CALL_OW 1
21877: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21878: LD_ADDR_EXP 101
21882: PUSH
21883: LD_EXP 101
21887: PPUSH
21888: LD_VAR 0 4
21892: PPUSH
21893: EMPTY
21894: PPUSH
21895: CALL_OW 1
21899: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21900: LD_ADDR_EXP 103
21904: PUSH
21905: LD_EXP 103
21909: PPUSH
21910: LD_VAR 0 4
21914: PPUSH
21915: EMPTY
21916: PPUSH
21917: CALL_OW 1
21921: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21922: LD_ADDR_EXP 104
21926: PUSH
21927: LD_EXP 104
21931: PPUSH
21932: LD_VAR 0 4
21936: PPUSH
21937: EMPTY
21938: PPUSH
21939: CALL_OW 1
21943: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21944: LD_ADDR_EXP 105
21948: PUSH
21949: LD_EXP 105
21953: PPUSH
21954: LD_VAR 0 4
21958: PPUSH
21959: EMPTY
21960: PPUSH
21961: CALL_OW 1
21965: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21966: LD_ADDR_EXP 106
21970: PUSH
21971: LD_EXP 106
21975: PPUSH
21976: LD_VAR 0 4
21980: PPUSH
21981: EMPTY
21982: PPUSH
21983: CALL_OW 1
21987: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21988: LD_ADDR_EXP 107
21992: PUSH
21993: LD_EXP 107
21997: PPUSH
21998: LD_VAR 0 4
22002: PPUSH
22003: EMPTY
22004: PPUSH
22005: CALL_OW 1
22009: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22010: LD_ADDR_EXP 108
22014: PUSH
22015: LD_EXP 108
22019: PPUSH
22020: LD_VAR 0 4
22024: PPUSH
22025: EMPTY
22026: PPUSH
22027: CALL_OW 1
22031: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22032: LD_ADDR_EXP 109
22036: PUSH
22037: LD_EXP 109
22041: PPUSH
22042: LD_VAR 0 4
22046: PPUSH
22047: EMPTY
22048: PPUSH
22049: CALL_OW 1
22053: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22054: LD_ADDR_EXP 110
22058: PUSH
22059: LD_EXP 110
22063: PPUSH
22064: LD_VAR 0 4
22068: PPUSH
22069: EMPTY
22070: PPUSH
22071: CALL_OW 1
22075: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22076: LD_ADDR_EXP 111
22080: PUSH
22081: LD_EXP 111
22085: PPUSH
22086: LD_VAR 0 4
22090: PPUSH
22091: EMPTY
22092: PPUSH
22093: CALL_OW 1
22097: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22098: LD_ADDR_EXP 112
22102: PUSH
22103: LD_EXP 112
22107: PPUSH
22108: LD_VAR 0 4
22112: PPUSH
22113: EMPTY
22114: PPUSH
22115: CALL_OW 1
22119: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22120: LD_ADDR_EXP 113
22124: PUSH
22125: LD_EXP 113
22129: PPUSH
22130: LD_VAR 0 4
22134: PPUSH
22135: EMPTY
22136: PPUSH
22137: CALL_OW 1
22141: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22142: LD_ADDR_EXP 114
22146: PUSH
22147: LD_EXP 114
22151: PPUSH
22152: LD_VAR 0 4
22156: PPUSH
22157: EMPTY
22158: PPUSH
22159: CALL_OW 1
22163: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22164: LD_ADDR_EXP 115
22168: PUSH
22169: LD_EXP 115
22173: PPUSH
22174: LD_VAR 0 4
22178: PPUSH
22179: EMPTY
22180: PPUSH
22181: CALL_OW 1
22185: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22186: LD_ADDR_EXP 116
22190: PUSH
22191: LD_EXP 116
22195: PPUSH
22196: LD_VAR 0 4
22200: PPUSH
22201: LD_INT 0
22203: PPUSH
22204: CALL_OW 1
22208: ST_TO_ADDR
// result := base ;
22209: LD_ADDR_VAR 0 3
22213: PUSH
22214: LD_VAR 0 4
22218: ST_TO_ADDR
// end ;
22219: LD_VAR 0 3
22223: RET
// export function MC_Start ( ) ; var i ; begin
22224: LD_INT 0
22226: PPUSH
22227: PPUSH
// for i = 1 to mc_bases do
22228: LD_ADDR_VAR 0 2
22232: PUSH
22233: DOUBLE
22234: LD_INT 1
22236: DEC
22237: ST_TO_ADDR
22238: LD_EXP 74
22242: PUSH
22243: FOR_TO
22244: IFFALSE 23321
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22246: LD_ADDR_EXP 74
22250: PUSH
22251: LD_EXP 74
22255: PPUSH
22256: LD_VAR 0 2
22260: PPUSH
22261: LD_EXP 74
22265: PUSH
22266: LD_VAR 0 2
22270: ARRAY
22271: PUSH
22272: LD_INT 0
22274: DIFF
22275: PPUSH
22276: CALL_OW 1
22280: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22281: LD_ADDR_EXP 75
22285: PUSH
22286: LD_EXP 75
22290: PPUSH
22291: LD_VAR 0 2
22295: PPUSH
22296: EMPTY
22297: PPUSH
22298: CALL_OW 1
22302: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22303: LD_ADDR_EXP 76
22307: PUSH
22308: LD_EXP 76
22312: PPUSH
22313: LD_VAR 0 2
22317: PPUSH
22318: EMPTY
22319: PPUSH
22320: CALL_OW 1
22324: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22325: LD_ADDR_EXP 77
22329: PUSH
22330: LD_EXP 77
22334: PPUSH
22335: LD_VAR 0 2
22339: PPUSH
22340: EMPTY
22341: PPUSH
22342: CALL_OW 1
22346: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22347: LD_ADDR_EXP 78
22351: PUSH
22352: LD_EXP 78
22356: PPUSH
22357: LD_VAR 0 2
22361: PPUSH
22362: EMPTY
22363: PUSH
22364: EMPTY
22365: PUSH
22366: EMPTY
22367: LIST
22368: LIST
22369: PPUSH
22370: CALL_OW 1
22374: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22375: LD_ADDR_EXP 79
22379: PUSH
22380: LD_EXP 79
22384: PPUSH
22385: LD_VAR 0 2
22389: PPUSH
22390: EMPTY
22391: PPUSH
22392: CALL_OW 1
22396: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22397: LD_ADDR_EXP 106
22401: PUSH
22402: LD_EXP 106
22406: PPUSH
22407: LD_VAR 0 2
22411: PPUSH
22412: EMPTY
22413: PPUSH
22414: CALL_OW 1
22418: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22419: LD_ADDR_EXP 80
22423: PUSH
22424: LD_EXP 80
22428: PPUSH
22429: LD_VAR 0 2
22433: PPUSH
22434: EMPTY
22435: PPUSH
22436: CALL_OW 1
22440: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22441: LD_ADDR_EXP 81
22445: PUSH
22446: LD_EXP 81
22450: PPUSH
22451: LD_VAR 0 2
22455: PPUSH
22456: EMPTY
22457: PPUSH
22458: CALL_OW 1
22462: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22463: LD_ADDR_EXP 82
22467: PUSH
22468: LD_EXP 82
22472: PPUSH
22473: LD_VAR 0 2
22477: PPUSH
22478: LD_EXP 74
22482: PUSH
22483: LD_VAR 0 2
22487: ARRAY
22488: PPUSH
22489: LD_INT 2
22491: PUSH
22492: LD_INT 30
22494: PUSH
22495: LD_INT 32
22497: PUSH
22498: EMPTY
22499: LIST
22500: LIST
22501: PUSH
22502: LD_INT 30
22504: PUSH
22505: LD_INT 33
22507: PUSH
22508: EMPTY
22509: LIST
22510: LIST
22511: PUSH
22512: EMPTY
22513: LIST
22514: LIST
22515: LIST
22516: PPUSH
22517: CALL_OW 72
22521: PPUSH
22522: CALL_OW 1
22526: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22527: LD_ADDR_EXP 83
22531: PUSH
22532: LD_EXP 83
22536: PPUSH
22537: LD_VAR 0 2
22541: PPUSH
22542: LD_EXP 74
22546: PUSH
22547: LD_VAR 0 2
22551: ARRAY
22552: PPUSH
22553: LD_INT 2
22555: PUSH
22556: LD_INT 30
22558: PUSH
22559: LD_INT 32
22561: PUSH
22562: EMPTY
22563: LIST
22564: LIST
22565: PUSH
22566: LD_INT 30
22568: PUSH
22569: LD_INT 31
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: LIST
22580: PUSH
22581: LD_INT 58
22583: PUSH
22584: EMPTY
22585: LIST
22586: PUSH
22587: EMPTY
22588: LIST
22589: LIST
22590: PPUSH
22591: CALL_OW 72
22595: PPUSH
22596: CALL_OW 1
22600: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22601: LD_ADDR_EXP 84
22605: PUSH
22606: LD_EXP 84
22610: PPUSH
22611: LD_VAR 0 2
22615: PPUSH
22616: EMPTY
22617: PPUSH
22618: CALL_OW 1
22622: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22623: LD_ADDR_EXP 88
22627: PUSH
22628: LD_EXP 88
22632: PPUSH
22633: LD_VAR 0 2
22637: PPUSH
22638: EMPTY
22639: PPUSH
22640: CALL_OW 1
22644: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22645: LD_ADDR_EXP 87
22649: PUSH
22650: LD_EXP 87
22654: PPUSH
22655: LD_VAR 0 2
22659: PPUSH
22660: EMPTY
22661: PPUSH
22662: CALL_OW 1
22666: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22667: LD_ADDR_EXP 89
22671: PUSH
22672: LD_EXP 89
22676: PPUSH
22677: LD_VAR 0 2
22681: PPUSH
22682: EMPTY
22683: PPUSH
22684: CALL_OW 1
22688: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22689: LD_ADDR_EXP 90
22693: PUSH
22694: LD_EXP 90
22698: PPUSH
22699: LD_VAR 0 2
22703: PPUSH
22704: EMPTY
22705: PPUSH
22706: CALL_OW 1
22710: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22711: LD_ADDR_EXP 91
22715: PUSH
22716: LD_EXP 91
22720: PPUSH
22721: LD_VAR 0 2
22725: PPUSH
22726: EMPTY
22727: PPUSH
22728: CALL_OW 1
22732: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22733: LD_ADDR_EXP 92
22737: PUSH
22738: LD_EXP 92
22742: PPUSH
22743: LD_VAR 0 2
22747: PPUSH
22748: EMPTY
22749: PPUSH
22750: CALL_OW 1
22754: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
22755: LD_ADDR_EXP 93
22759: PUSH
22760: LD_EXP 93
22764: PPUSH
22765: LD_VAR 0 2
22769: PPUSH
22770: EMPTY
22771: PPUSH
22772: CALL_OW 1
22776: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22777: LD_ADDR_EXP 94
22781: PUSH
22782: LD_EXP 94
22786: PPUSH
22787: LD_VAR 0 2
22791: PPUSH
22792: EMPTY
22793: PPUSH
22794: CALL_OW 1
22798: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
22799: LD_ADDR_EXP 95
22803: PUSH
22804: LD_EXP 95
22808: PPUSH
22809: LD_VAR 0 2
22813: PPUSH
22814: EMPTY
22815: PPUSH
22816: CALL_OW 1
22820: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
22821: LD_ADDR_EXP 96
22825: PUSH
22826: LD_EXP 96
22830: PPUSH
22831: LD_VAR 0 2
22835: PPUSH
22836: EMPTY
22837: PPUSH
22838: CALL_OW 1
22842: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
22843: LD_ADDR_EXP 85
22847: PUSH
22848: LD_EXP 85
22852: PPUSH
22853: LD_VAR 0 2
22857: PPUSH
22858: LD_INT 0
22860: PPUSH
22861: CALL_OW 1
22865: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
22866: LD_ADDR_EXP 98
22870: PUSH
22871: LD_EXP 98
22875: PPUSH
22876: LD_VAR 0 2
22880: PPUSH
22881: LD_INT 0
22883: PPUSH
22884: CALL_OW 1
22888: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
22889: LD_ADDR_EXP 86
22893: PUSH
22894: LD_EXP 86
22898: PPUSH
22899: LD_VAR 0 2
22903: PPUSH
22904: EMPTY
22905: PPUSH
22906: CALL_OW 1
22910: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
22911: LD_ADDR_EXP 97
22915: PUSH
22916: LD_EXP 97
22920: PPUSH
22921: LD_VAR 0 2
22925: PPUSH
22926: LD_INT 0
22928: PPUSH
22929: CALL_OW 1
22933: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
22934: LD_ADDR_EXP 99
22938: PUSH
22939: LD_EXP 99
22943: PPUSH
22944: LD_VAR 0 2
22948: PPUSH
22949: EMPTY
22950: PPUSH
22951: CALL_OW 1
22955: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
22956: LD_ADDR_EXP 102
22960: PUSH
22961: LD_EXP 102
22965: PPUSH
22966: LD_VAR 0 2
22970: PPUSH
22971: LD_INT 0
22973: PPUSH
22974: CALL_OW 1
22978: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
22979: LD_ADDR_EXP 103
22983: PUSH
22984: LD_EXP 103
22988: PPUSH
22989: LD_VAR 0 2
22993: PPUSH
22994: EMPTY
22995: PPUSH
22996: CALL_OW 1
23000: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23001: LD_ADDR_EXP 104
23005: PUSH
23006: LD_EXP 104
23010: PPUSH
23011: LD_VAR 0 2
23015: PPUSH
23016: EMPTY
23017: PPUSH
23018: CALL_OW 1
23022: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23023: LD_ADDR_EXP 105
23027: PUSH
23028: LD_EXP 105
23032: PPUSH
23033: LD_VAR 0 2
23037: PPUSH
23038: EMPTY
23039: PPUSH
23040: CALL_OW 1
23044: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23045: LD_ADDR_EXP 107
23049: PUSH
23050: LD_EXP 107
23054: PPUSH
23055: LD_VAR 0 2
23059: PPUSH
23060: LD_EXP 74
23064: PUSH
23065: LD_VAR 0 2
23069: ARRAY
23070: PPUSH
23071: LD_INT 2
23073: PUSH
23074: LD_INT 30
23076: PUSH
23077: LD_INT 6
23079: PUSH
23080: EMPTY
23081: LIST
23082: LIST
23083: PUSH
23084: LD_INT 30
23086: PUSH
23087: LD_INT 7
23089: PUSH
23090: EMPTY
23091: LIST
23092: LIST
23093: PUSH
23094: LD_INT 30
23096: PUSH
23097: LD_INT 8
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: LIST
23108: LIST
23109: PPUSH
23110: CALL_OW 72
23114: PPUSH
23115: CALL_OW 1
23119: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23120: LD_ADDR_EXP 108
23124: PUSH
23125: LD_EXP 108
23129: PPUSH
23130: LD_VAR 0 2
23134: PPUSH
23135: EMPTY
23136: PPUSH
23137: CALL_OW 1
23141: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23142: LD_ADDR_EXP 109
23146: PUSH
23147: LD_EXP 109
23151: PPUSH
23152: LD_VAR 0 2
23156: PPUSH
23157: EMPTY
23158: PPUSH
23159: CALL_OW 1
23163: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23164: LD_ADDR_EXP 110
23168: PUSH
23169: LD_EXP 110
23173: PPUSH
23174: LD_VAR 0 2
23178: PPUSH
23179: EMPTY
23180: PPUSH
23181: CALL_OW 1
23185: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23186: LD_ADDR_EXP 111
23190: PUSH
23191: LD_EXP 111
23195: PPUSH
23196: LD_VAR 0 2
23200: PPUSH
23201: EMPTY
23202: PPUSH
23203: CALL_OW 1
23207: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23208: LD_ADDR_EXP 112
23212: PUSH
23213: LD_EXP 112
23217: PPUSH
23218: LD_VAR 0 2
23222: PPUSH
23223: EMPTY
23224: PPUSH
23225: CALL_OW 1
23229: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23230: LD_ADDR_EXP 113
23234: PUSH
23235: LD_EXP 113
23239: PPUSH
23240: LD_VAR 0 2
23244: PPUSH
23245: EMPTY
23246: PPUSH
23247: CALL_OW 1
23251: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23252: LD_ADDR_EXP 114
23256: PUSH
23257: LD_EXP 114
23261: PPUSH
23262: LD_VAR 0 2
23266: PPUSH
23267: EMPTY
23268: PPUSH
23269: CALL_OW 1
23273: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23274: LD_ADDR_EXP 115
23278: PUSH
23279: LD_EXP 115
23283: PPUSH
23284: LD_VAR 0 2
23288: PPUSH
23289: EMPTY
23290: PPUSH
23291: CALL_OW 1
23295: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23296: LD_ADDR_EXP 116
23300: PUSH
23301: LD_EXP 116
23305: PPUSH
23306: LD_VAR 0 2
23310: PPUSH
23311: LD_INT 0
23313: PPUSH
23314: CALL_OW 1
23318: ST_TO_ADDR
// end ;
23319: GO 22243
23321: POP
23322: POP
// MC_InitSides ( ) ;
23323: CALL 23609 0 0
// MC_InitResearch ( ) ;
23327: CALL 23348 0 0
// CustomInitMacro ( ) ;
23331: CALL 173 0 0
// skirmish := true ;
23335: LD_ADDR_EXP 72
23339: PUSH
23340: LD_INT 1
23342: ST_TO_ADDR
// end ;
23343: LD_VAR 0 1
23347: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23348: LD_INT 0
23350: PPUSH
23351: PPUSH
23352: PPUSH
23353: PPUSH
23354: PPUSH
23355: PPUSH
// if not mc_bases then
23356: LD_EXP 74
23360: NOT
23361: IFFALSE 23365
// exit ;
23363: GO 23604
// for i = 1 to 8 do
23365: LD_ADDR_VAR 0 2
23369: PUSH
23370: DOUBLE
23371: LD_INT 1
23373: DEC
23374: ST_TO_ADDR
23375: LD_INT 8
23377: PUSH
23378: FOR_TO
23379: IFFALSE 23405
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23381: LD_ADDR_EXP 101
23385: PUSH
23386: LD_EXP 101
23390: PPUSH
23391: LD_VAR 0 2
23395: PPUSH
23396: EMPTY
23397: PPUSH
23398: CALL_OW 1
23402: ST_TO_ADDR
23403: GO 23378
23405: POP
23406: POP
// tmp := [ ] ;
23407: LD_ADDR_VAR 0 5
23411: PUSH
23412: EMPTY
23413: ST_TO_ADDR
// for i = 1 to mc_sides do
23414: LD_ADDR_VAR 0 2
23418: PUSH
23419: DOUBLE
23420: LD_INT 1
23422: DEC
23423: ST_TO_ADDR
23424: LD_EXP 100
23428: PUSH
23429: FOR_TO
23430: IFFALSE 23488
// if not mc_sides [ i ] in tmp then
23432: LD_EXP 100
23436: PUSH
23437: LD_VAR 0 2
23441: ARRAY
23442: PUSH
23443: LD_VAR 0 5
23447: IN
23448: NOT
23449: IFFALSE 23486
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23451: LD_ADDR_VAR 0 5
23455: PUSH
23456: LD_VAR 0 5
23460: PPUSH
23461: LD_VAR 0 5
23465: PUSH
23466: LD_INT 1
23468: PLUS
23469: PPUSH
23470: LD_EXP 100
23474: PUSH
23475: LD_VAR 0 2
23479: ARRAY
23480: PPUSH
23481: CALL_OW 2
23485: ST_TO_ADDR
23486: GO 23429
23488: POP
23489: POP
// if not tmp then
23490: LD_VAR 0 5
23494: NOT
23495: IFFALSE 23499
// exit ;
23497: GO 23604
// for j in tmp do
23499: LD_ADDR_VAR 0 3
23503: PUSH
23504: LD_VAR 0 5
23508: PUSH
23509: FOR_IN
23510: IFFALSE 23602
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23512: LD_ADDR_VAR 0 6
23516: PUSH
23517: LD_INT 22
23519: PUSH
23520: LD_VAR 0 3
23524: PUSH
23525: EMPTY
23526: LIST
23527: LIST
23528: PPUSH
23529: CALL_OW 69
23533: ST_TO_ADDR
// if not un then
23534: LD_VAR 0 6
23538: NOT
23539: IFFALSE 23543
// continue ;
23541: GO 23509
// nation := GetNation ( un [ 1 ] ) ;
23543: LD_ADDR_VAR 0 4
23547: PUSH
23548: LD_VAR 0 6
23552: PUSH
23553: LD_INT 1
23555: ARRAY
23556: PPUSH
23557: CALL_OW 248
23561: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23562: LD_ADDR_EXP 101
23566: PUSH
23567: LD_EXP 101
23571: PPUSH
23572: LD_VAR 0 3
23576: PPUSH
23577: LD_VAR 0 3
23581: PPUSH
23582: LD_VAR 0 4
23586: PPUSH
23587: LD_INT 1
23589: PPUSH
23590: CALL 49968 0 3
23594: PPUSH
23595: CALL_OW 1
23599: ST_TO_ADDR
// end ;
23600: GO 23509
23602: POP
23603: POP
// end ;
23604: LD_VAR 0 1
23608: RET
// export function MC_InitSides ( ) ; var i ; begin
23609: LD_INT 0
23611: PPUSH
23612: PPUSH
// if not mc_bases then
23613: LD_EXP 74
23617: NOT
23618: IFFALSE 23622
// exit ;
23620: GO 23696
// for i = 1 to mc_bases do
23622: LD_ADDR_VAR 0 2
23626: PUSH
23627: DOUBLE
23628: LD_INT 1
23630: DEC
23631: ST_TO_ADDR
23632: LD_EXP 74
23636: PUSH
23637: FOR_TO
23638: IFFALSE 23694
// if mc_bases [ i ] then
23640: LD_EXP 74
23644: PUSH
23645: LD_VAR 0 2
23649: ARRAY
23650: IFFALSE 23692
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23652: LD_ADDR_EXP 100
23656: PUSH
23657: LD_EXP 100
23661: PPUSH
23662: LD_VAR 0 2
23666: PPUSH
23667: LD_EXP 74
23671: PUSH
23672: LD_VAR 0 2
23676: ARRAY
23677: PUSH
23678: LD_INT 1
23680: ARRAY
23681: PPUSH
23682: CALL_OW 255
23686: PPUSH
23687: CALL_OW 1
23691: ST_TO_ADDR
23692: GO 23637
23694: POP
23695: POP
// end ;
23696: LD_VAR 0 1
23700: RET
// every 0 0$01 trigger skirmish do
23701: LD_EXP 72
23705: IFFALSE 23859
23707: GO 23709
23709: DISABLE
// begin enable ;
23710: ENABLE
// MC_CheckBuildings ( ) ;
23711: CALL 28357 0 0
// MC_CheckPeopleLife ( ) ;
23715: CALL 28482 0 0
// RaiseSailEvent ( 100 ) ;
23719: LD_INT 100
23721: PPUSH
23722: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23726: LD_INT 103
23728: PPUSH
23729: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23733: LD_INT 104
23735: PPUSH
23736: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23740: LD_INT 105
23742: PPUSH
23743: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
23747: LD_INT 106
23749: PPUSH
23750: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
23754: LD_INT 107
23756: PPUSH
23757: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
23761: LD_INT 108
23763: PPUSH
23764: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
23768: LD_INT 109
23770: PPUSH
23771: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
23775: LD_INT 110
23777: PPUSH
23778: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
23782: LD_INT 111
23784: PPUSH
23785: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
23789: LD_INT 112
23791: PPUSH
23792: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
23796: LD_INT 113
23798: PPUSH
23799: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
23803: LD_INT 120
23805: PPUSH
23806: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
23810: LD_INT 121
23812: PPUSH
23813: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
23817: LD_INT 122
23819: PPUSH
23820: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
23824: LD_INT 123
23826: PPUSH
23827: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
23831: LD_INT 124
23833: PPUSH
23834: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
23838: LD_INT 125
23840: PPUSH
23841: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
23845: LD_INT 126
23847: PPUSH
23848: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
23852: LD_INT 200
23854: PPUSH
23855: CALL_OW 427
// end ;
23859: END
// on SailEvent ( event ) do begin if event < 100 then
23860: LD_VAR 0 1
23864: PUSH
23865: LD_INT 100
23867: LESS
23868: IFFALSE 23879
// CustomEvent ( event ) ;
23870: LD_VAR 0 1
23874: PPUSH
23875: CALL 10216 0 1
// if event = 100 then
23879: LD_VAR 0 1
23883: PUSH
23884: LD_INT 100
23886: EQUAL
23887: IFFALSE 23893
// MC_ClassManager ( ) ;
23889: CALL 24285 0 0
// if event = 101 then
23893: LD_VAR 0 1
23897: PUSH
23898: LD_INT 101
23900: EQUAL
23901: IFFALSE 23907
// MC_RepairBuildings ( ) ;
23903: CALL 29078 0 0
// if event = 102 then
23907: LD_VAR 0 1
23911: PUSH
23912: LD_INT 102
23914: EQUAL
23915: IFFALSE 23921
// MC_Heal ( ) ;
23917: CALL 29810 0 0
// if event = 103 then
23921: LD_VAR 0 1
23925: PUSH
23926: LD_INT 103
23928: EQUAL
23929: IFFALSE 23935
// MC_Build ( ) ;
23931: CALL 30232 0 0
// if event = 104 then
23935: LD_VAR 0 1
23939: PUSH
23940: LD_INT 104
23942: EQUAL
23943: IFFALSE 23949
// MC_TurretWeapon ( ) ;
23945: CALL 31845 0 0
// if event = 105 then
23949: LD_VAR 0 1
23953: PUSH
23954: LD_INT 105
23956: EQUAL
23957: IFFALSE 23963
// MC_BuildUpgrade ( ) ;
23959: CALL 31396 0 0
// if event = 106 then
23963: LD_VAR 0 1
23967: PUSH
23968: LD_INT 106
23970: EQUAL
23971: IFFALSE 23977
// MC_PlantMines ( ) ;
23973: CALL 32275 0 0
// if event = 107 then
23977: LD_VAR 0 1
23981: PUSH
23982: LD_INT 107
23984: EQUAL
23985: IFFALSE 23991
// MC_CollectCrates ( ) ;
23987: CALL 33309 0 0
// if event = 108 then
23991: LD_VAR 0 1
23995: PUSH
23996: LD_INT 108
23998: EQUAL
23999: IFFALSE 24005
// MC_LinkRemoteControl ( ) ;
24001: CALL 35085 0 0
// if event = 109 then
24005: LD_VAR 0 1
24009: PUSH
24010: LD_INT 109
24012: EQUAL
24013: IFFALSE 24019
// MC_ProduceVehicle ( ) ;
24015: CALL 35266 0 0
// if event = 110 then
24019: LD_VAR 0 1
24023: PUSH
24024: LD_INT 110
24026: EQUAL
24027: IFFALSE 24033
// MC_SendAttack ( ) ;
24029: CALL 35732 0 0
// if event = 111 then
24033: LD_VAR 0 1
24037: PUSH
24038: LD_INT 111
24040: EQUAL
24041: IFFALSE 24047
// MC_Defend ( ) ;
24043: CALL 35840 0 0
// if event = 112 then
24047: LD_VAR 0 1
24051: PUSH
24052: LD_INT 112
24054: EQUAL
24055: IFFALSE 24061
// MC_Research ( ) ;
24057: CALL 36445 0 0
// if event = 113 then
24061: LD_VAR 0 1
24065: PUSH
24066: LD_INT 113
24068: EQUAL
24069: IFFALSE 24075
// MC_MinesTrigger ( ) ;
24071: CALL 37559 0 0
// if event = 120 then
24075: LD_VAR 0 1
24079: PUSH
24080: LD_INT 120
24082: EQUAL
24083: IFFALSE 24089
// MC_RepairVehicle ( ) ;
24085: CALL 37658 0 0
// if event = 121 then
24089: LD_VAR 0 1
24093: PUSH
24094: LD_INT 121
24096: EQUAL
24097: IFFALSE 24103
// MC_TameApe ( ) ;
24099: CALL 38388 0 0
// if event = 122 then
24103: LD_VAR 0 1
24107: PUSH
24108: LD_INT 122
24110: EQUAL
24111: IFFALSE 24117
// MC_ChangeApeClass ( ) ;
24113: CALL 39217 0 0
// if event = 123 then
24117: LD_VAR 0 1
24121: PUSH
24122: LD_INT 123
24124: EQUAL
24125: IFFALSE 24131
// MC_Bazooka ( ) ;
24127: CALL 39867 0 0
// if event = 124 then
24131: LD_VAR 0 1
24135: PUSH
24136: LD_INT 124
24138: EQUAL
24139: IFFALSE 24145
// MC_TeleportExit ( ) ;
24141: CALL 40065 0 0
// if event = 125 then
24145: LD_VAR 0 1
24149: PUSH
24150: LD_INT 125
24152: EQUAL
24153: IFFALSE 24159
// MC_Deposits ( ) ;
24155: CALL 40712 0 0
// if event = 126 then
24159: LD_VAR 0 1
24163: PUSH
24164: LD_INT 126
24166: EQUAL
24167: IFFALSE 24173
// MC_RemoteDriver ( ) ;
24169: CALL 41337 0 0
// if event = 200 then
24173: LD_VAR 0 1
24177: PUSH
24178: LD_INT 200
24180: EQUAL
24181: IFFALSE 24187
// MC_Idle ( ) ;
24183: CALL 43070 0 0
// end ;
24187: PPOPN 1
24189: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24190: LD_INT 0
24192: PPUSH
24193: PPUSH
// if not mc_bases [ base ] or not tag then
24194: LD_EXP 74
24198: PUSH
24199: LD_VAR 0 1
24203: ARRAY
24204: NOT
24205: PUSH
24206: LD_VAR 0 2
24210: NOT
24211: OR
24212: IFFALSE 24216
// exit ;
24214: GO 24280
// for i in mc_bases [ base ] union mc_ape [ base ] do
24216: LD_ADDR_VAR 0 4
24220: PUSH
24221: LD_EXP 74
24225: PUSH
24226: LD_VAR 0 1
24230: ARRAY
24231: PUSH
24232: LD_EXP 103
24236: PUSH
24237: LD_VAR 0 1
24241: ARRAY
24242: UNION
24243: PUSH
24244: FOR_IN
24245: IFFALSE 24278
// if GetTag ( i ) = tag then
24247: LD_VAR 0 4
24251: PPUSH
24252: CALL_OW 110
24256: PUSH
24257: LD_VAR 0 2
24261: EQUAL
24262: IFFALSE 24276
// SetTag ( i , 0 ) ;
24264: LD_VAR 0 4
24268: PPUSH
24269: LD_INT 0
24271: PPUSH
24272: CALL_OW 109
24276: GO 24244
24278: POP
24279: POP
// end ;
24280: LD_VAR 0 3
24284: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24285: LD_INT 0
24287: PPUSH
24288: PPUSH
24289: PPUSH
24290: PPUSH
24291: PPUSH
24292: PPUSH
24293: PPUSH
24294: PPUSH
// if not mc_bases then
24295: LD_EXP 74
24299: NOT
24300: IFFALSE 24304
// exit ;
24302: GO 24762
// for i = 1 to mc_bases do
24304: LD_ADDR_VAR 0 2
24308: PUSH
24309: DOUBLE
24310: LD_INT 1
24312: DEC
24313: ST_TO_ADDR
24314: LD_EXP 74
24318: PUSH
24319: FOR_TO
24320: IFFALSE 24760
// begin tmp := MC_ClassCheckReq ( i ) ;
24322: LD_ADDR_VAR 0 4
24326: PUSH
24327: LD_VAR 0 2
24331: PPUSH
24332: CALL 24767 0 1
24336: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24337: LD_ADDR_EXP 115
24341: PUSH
24342: LD_EXP 115
24346: PPUSH
24347: LD_VAR 0 2
24351: PPUSH
24352: LD_VAR 0 4
24356: PPUSH
24357: CALL_OW 1
24361: ST_TO_ADDR
// if not tmp then
24362: LD_VAR 0 4
24366: NOT
24367: IFFALSE 24371
// continue ;
24369: GO 24319
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24371: LD_ADDR_VAR 0 6
24375: PUSH
24376: LD_EXP 74
24380: PUSH
24381: LD_VAR 0 2
24385: ARRAY
24386: PPUSH
24387: LD_INT 2
24389: PUSH
24390: LD_INT 30
24392: PUSH
24393: LD_INT 4
24395: PUSH
24396: EMPTY
24397: LIST
24398: LIST
24399: PUSH
24400: LD_INT 30
24402: PUSH
24403: LD_INT 5
24405: PUSH
24406: EMPTY
24407: LIST
24408: LIST
24409: PUSH
24410: EMPTY
24411: LIST
24412: LIST
24413: LIST
24414: PPUSH
24415: CALL_OW 72
24419: PUSH
24420: LD_EXP 74
24424: PUSH
24425: LD_VAR 0 2
24429: ARRAY
24430: PPUSH
24431: LD_INT 2
24433: PUSH
24434: LD_INT 30
24436: PUSH
24437: LD_INT 0
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PUSH
24444: LD_INT 30
24446: PUSH
24447: LD_INT 1
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: LIST
24458: PPUSH
24459: CALL_OW 72
24463: PUSH
24464: LD_EXP 74
24468: PUSH
24469: LD_VAR 0 2
24473: ARRAY
24474: PPUSH
24475: LD_INT 30
24477: PUSH
24478: LD_INT 3
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PPUSH
24485: CALL_OW 72
24489: PUSH
24490: LD_EXP 74
24494: PUSH
24495: LD_VAR 0 2
24499: ARRAY
24500: PPUSH
24501: LD_INT 2
24503: PUSH
24504: LD_INT 30
24506: PUSH
24507: LD_INT 6
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 30
24516: PUSH
24517: LD_INT 7
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PUSH
24524: LD_INT 30
24526: PUSH
24527: LD_INT 8
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: PUSH
24534: EMPTY
24535: LIST
24536: LIST
24537: LIST
24538: LIST
24539: PPUSH
24540: CALL_OW 72
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: LIST
24549: LIST
24550: ST_TO_ADDR
// for j = 1 to 4 do
24551: LD_ADDR_VAR 0 3
24555: PUSH
24556: DOUBLE
24557: LD_INT 1
24559: DEC
24560: ST_TO_ADDR
24561: LD_INT 4
24563: PUSH
24564: FOR_TO
24565: IFFALSE 24756
// begin if not tmp [ j ] then
24567: LD_VAR 0 4
24571: PUSH
24572: LD_VAR 0 3
24576: ARRAY
24577: NOT
24578: IFFALSE 24582
// continue ;
24580: GO 24564
// for p in tmp [ j ] do
24582: LD_ADDR_VAR 0 5
24586: PUSH
24587: LD_VAR 0 4
24591: PUSH
24592: LD_VAR 0 3
24596: ARRAY
24597: PUSH
24598: FOR_IN
24599: IFFALSE 24752
// begin if not b [ j ] then
24601: LD_VAR 0 6
24605: PUSH
24606: LD_VAR 0 3
24610: ARRAY
24611: NOT
24612: IFFALSE 24616
// break ;
24614: GO 24752
// e := 0 ;
24616: LD_ADDR_VAR 0 7
24620: PUSH
24621: LD_INT 0
24623: ST_TO_ADDR
// for k in b [ j ] do
24624: LD_ADDR_VAR 0 8
24628: PUSH
24629: LD_VAR 0 6
24633: PUSH
24634: LD_VAR 0 3
24638: ARRAY
24639: PUSH
24640: FOR_IN
24641: IFFALSE 24668
// if IsNotFull ( k ) then
24643: LD_VAR 0 8
24647: PPUSH
24648: CALL 54259 0 1
24652: IFFALSE 24666
// begin e := k ;
24654: LD_ADDR_VAR 0 7
24658: PUSH
24659: LD_VAR 0 8
24663: ST_TO_ADDR
// break ;
24664: GO 24668
// end ;
24666: GO 24640
24668: POP
24669: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24670: LD_VAR 0 7
24674: PUSH
24675: LD_VAR 0 5
24679: PPUSH
24680: LD_VAR 0 7
24684: PPUSH
24685: CALL 91378 0 2
24689: NOT
24690: AND
24691: IFFALSE 24750
// begin if IsInUnit ( p ) then
24693: LD_VAR 0 5
24697: PPUSH
24698: CALL_OW 310
24702: IFFALSE 24713
// ComExitBuilding ( p ) ;
24704: LD_VAR 0 5
24708: PPUSH
24709: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24713: LD_VAR 0 5
24717: PPUSH
24718: LD_VAR 0 7
24722: PPUSH
24723: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24727: LD_VAR 0 5
24731: PPUSH
24732: LD_VAR 0 3
24736: PPUSH
24737: CALL_OW 183
// AddComExitBuilding ( p ) ;
24741: LD_VAR 0 5
24745: PPUSH
24746: CALL_OW 182
// end ; end ;
24750: GO 24598
24752: POP
24753: POP
// end ;
24754: GO 24564
24756: POP
24757: POP
// end ;
24758: GO 24319
24760: POP
24761: POP
// end ;
24762: LD_VAR 0 1
24766: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
24767: LD_INT 0
24769: PPUSH
24770: PPUSH
24771: PPUSH
24772: PPUSH
24773: PPUSH
24774: PPUSH
24775: PPUSH
24776: PPUSH
24777: PPUSH
24778: PPUSH
24779: PPUSH
24780: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24781: LD_VAR 0 1
24785: NOT
24786: PUSH
24787: LD_EXP 74
24791: PUSH
24792: LD_VAR 0 1
24796: ARRAY
24797: NOT
24798: OR
24799: PUSH
24800: LD_EXP 74
24804: PUSH
24805: LD_VAR 0 1
24809: ARRAY
24810: PPUSH
24811: LD_INT 2
24813: PUSH
24814: LD_INT 30
24816: PUSH
24817: LD_INT 0
24819: PUSH
24820: EMPTY
24821: LIST
24822: LIST
24823: PUSH
24824: LD_INT 30
24826: PUSH
24827: LD_INT 1
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: PUSH
24834: EMPTY
24835: LIST
24836: LIST
24837: LIST
24838: PPUSH
24839: CALL_OW 72
24843: NOT
24844: OR
24845: IFFALSE 24849
// exit ;
24847: GO 28352
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24849: LD_ADDR_VAR 0 4
24853: PUSH
24854: LD_EXP 74
24858: PUSH
24859: LD_VAR 0 1
24863: ARRAY
24864: PPUSH
24865: LD_INT 2
24867: PUSH
24868: LD_INT 25
24870: PUSH
24871: LD_INT 1
24873: PUSH
24874: EMPTY
24875: LIST
24876: LIST
24877: PUSH
24878: LD_INT 25
24880: PUSH
24881: LD_INT 2
24883: PUSH
24884: EMPTY
24885: LIST
24886: LIST
24887: PUSH
24888: LD_INT 25
24890: PUSH
24891: LD_INT 3
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PUSH
24898: LD_INT 25
24900: PUSH
24901: LD_INT 4
24903: PUSH
24904: EMPTY
24905: LIST
24906: LIST
24907: PUSH
24908: LD_INT 25
24910: PUSH
24911: LD_INT 5
24913: PUSH
24914: EMPTY
24915: LIST
24916: LIST
24917: PUSH
24918: LD_INT 25
24920: PUSH
24921: LD_INT 8
24923: PUSH
24924: EMPTY
24925: LIST
24926: LIST
24927: PUSH
24928: LD_INT 25
24930: PUSH
24931: LD_INT 9
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: LIST
24942: LIST
24943: LIST
24944: LIST
24945: LIST
24946: LIST
24947: PPUSH
24948: CALL_OW 72
24952: ST_TO_ADDR
// if not tmp then
24953: LD_VAR 0 4
24957: NOT
24958: IFFALSE 24962
// exit ;
24960: GO 28352
// for i in tmp do
24962: LD_ADDR_VAR 0 3
24966: PUSH
24967: LD_VAR 0 4
24971: PUSH
24972: FOR_IN
24973: IFFALSE 25004
// if GetTag ( i ) then
24975: LD_VAR 0 3
24979: PPUSH
24980: CALL_OW 110
24984: IFFALSE 25002
// tmp := tmp diff i ;
24986: LD_ADDR_VAR 0 4
24990: PUSH
24991: LD_VAR 0 4
24995: PUSH
24996: LD_VAR 0 3
25000: DIFF
25001: ST_TO_ADDR
25002: GO 24972
25004: POP
25005: POP
// if not tmp then
25006: LD_VAR 0 4
25010: NOT
25011: IFFALSE 25015
// exit ;
25013: GO 28352
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25015: LD_ADDR_VAR 0 5
25019: PUSH
25020: LD_EXP 74
25024: PUSH
25025: LD_VAR 0 1
25029: ARRAY
25030: PPUSH
25031: LD_INT 2
25033: PUSH
25034: LD_INT 25
25036: PUSH
25037: LD_INT 1
25039: PUSH
25040: EMPTY
25041: LIST
25042: LIST
25043: PUSH
25044: LD_INT 25
25046: PUSH
25047: LD_INT 5
25049: PUSH
25050: EMPTY
25051: LIST
25052: LIST
25053: PUSH
25054: LD_INT 25
25056: PUSH
25057: LD_INT 8
25059: PUSH
25060: EMPTY
25061: LIST
25062: LIST
25063: PUSH
25064: LD_INT 25
25066: PUSH
25067: LD_INT 9
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: LIST
25078: LIST
25079: LIST
25080: PPUSH
25081: CALL_OW 72
25085: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25086: LD_ADDR_VAR 0 6
25090: PUSH
25091: LD_EXP 74
25095: PUSH
25096: LD_VAR 0 1
25100: ARRAY
25101: PPUSH
25102: LD_INT 25
25104: PUSH
25105: LD_INT 2
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PPUSH
25112: CALL_OW 72
25116: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25117: LD_ADDR_VAR 0 7
25121: PUSH
25122: LD_EXP 74
25126: PUSH
25127: LD_VAR 0 1
25131: ARRAY
25132: PPUSH
25133: LD_INT 25
25135: PUSH
25136: LD_INT 3
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: PPUSH
25143: CALL_OW 72
25147: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25148: LD_ADDR_VAR 0 8
25152: PUSH
25153: LD_EXP 74
25157: PUSH
25158: LD_VAR 0 1
25162: ARRAY
25163: PPUSH
25164: LD_INT 25
25166: PUSH
25167: LD_INT 4
25169: PUSH
25170: EMPTY
25171: LIST
25172: LIST
25173: PUSH
25174: LD_INT 24
25176: PUSH
25177: LD_INT 251
25179: PUSH
25180: EMPTY
25181: LIST
25182: LIST
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: PPUSH
25188: CALL_OW 72
25192: ST_TO_ADDR
// if mc_scan [ base ] then
25193: LD_EXP 97
25197: PUSH
25198: LD_VAR 0 1
25202: ARRAY
25203: IFFALSE 25664
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25205: LD_ADDR_EXP 116
25209: PUSH
25210: LD_EXP 116
25214: PPUSH
25215: LD_VAR 0 1
25219: PPUSH
25220: LD_INT 4
25222: PPUSH
25223: CALL_OW 1
25227: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25228: LD_ADDR_VAR 0 12
25232: PUSH
25233: LD_EXP 74
25237: PUSH
25238: LD_VAR 0 1
25242: ARRAY
25243: PPUSH
25244: LD_INT 2
25246: PUSH
25247: LD_INT 30
25249: PUSH
25250: LD_INT 4
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PUSH
25257: LD_INT 30
25259: PUSH
25260: LD_INT 5
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: PUSH
25267: EMPTY
25268: LIST
25269: LIST
25270: LIST
25271: PPUSH
25272: CALL_OW 72
25276: ST_TO_ADDR
// if not b then
25277: LD_VAR 0 12
25281: NOT
25282: IFFALSE 25286
// exit ;
25284: GO 28352
// p := [ ] ;
25286: LD_ADDR_VAR 0 11
25290: PUSH
25291: EMPTY
25292: ST_TO_ADDR
// if sci >= 2 then
25293: LD_VAR 0 8
25297: PUSH
25298: LD_INT 2
25300: GREATEREQUAL
25301: IFFALSE 25332
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25303: LD_ADDR_VAR 0 8
25307: PUSH
25308: LD_VAR 0 8
25312: PUSH
25313: LD_INT 1
25315: ARRAY
25316: PUSH
25317: LD_VAR 0 8
25321: PUSH
25322: LD_INT 2
25324: ARRAY
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: ST_TO_ADDR
25330: GO 25393
// if sci = 1 then
25332: LD_VAR 0 8
25336: PUSH
25337: LD_INT 1
25339: EQUAL
25340: IFFALSE 25361
// sci := [ sci [ 1 ] ] else
25342: LD_ADDR_VAR 0 8
25346: PUSH
25347: LD_VAR 0 8
25351: PUSH
25352: LD_INT 1
25354: ARRAY
25355: PUSH
25356: EMPTY
25357: LIST
25358: ST_TO_ADDR
25359: GO 25393
// if sci = 0 then
25361: LD_VAR 0 8
25365: PUSH
25366: LD_INT 0
25368: EQUAL
25369: IFFALSE 25393
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25371: LD_ADDR_VAR 0 11
25375: PUSH
25376: LD_VAR 0 4
25380: PPUSH
25381: LD_INT 4
25383: PPUSH
25384: CALL 91241 0 2
25388: PUSH
25389: LD_INT 1
25391: ARRAY
25392: ST_TO_ADDR
// if eng > 4 then
25393: LD_VAR 0 6
25397: PUSH
25398: LD_INT 4
25400: GREATER
25401: IFFALSE 25447
// for i = eng downto 4 do
25403: LD_ADDR_VAR 0 3
25407: PUSH
25408: DOUBLE
25409: LD_VAR 0 6
25413: INC
25414: ST_TO_ADDR
25415: LD_INT 4
25417: PUSH
25418: FOR_DOWNTO
25419: IFFALSE 25445
// eng := eng diff eng [ i ] ;
25421: LD_ADDR_VAR 0 6
25425: PUSH
25426: LD_VAR 0 6
25430: PUSH
25431: LD_VAR 0 6
25435: PUSH
25436: LD_VAR 0 3
25440: ARRAY
25441: DIFF
25442: ST_TO_ADDR
25443: GO 25418
25445: POP
25446: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25447: LD_ADDR_VAR 0 4
25451: PUSH
25452: LD_VAR 0 4
25456: PUSH
25457: LD_VAR 0 5
25461: PUSH
25462: LD_VAR 0 6
25466: UNION
25467: PUSH
25468: LD_VAR 0 7
25472: UNION
25473: PUSH
25474: LD_VAR 0 8
25478: UNION
25479: DIFF
25480: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25481: LD_ADDR_VAR 0 13
25485: PUSH
25486: LD_EXP 74
25490: PUSH
25491: LD_VAR 0 1
25495: ARRAY
25496: PPUSH
25497: LD_INT 2
25499: PUSH
25500: LD_INT 30
25502: PUSH
25503: LD_INT 32
25505: PUSH
25506: EMPTY
25507: LIST
25508: LIST
25509: PUSH
25510: LD_INT 30
25512: PUSH
25513: LD_INT 31
25515: PUSH
25516: EMPTY
25517: LIST
25518: LIST
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: LIST
25524: PPUSH
25525: CALL_OW 72
25529: PUSH
25530: LD_EXP 74
25534: PUSH
25535: LD_VAR 0 1
25539: ARRAY
25540: PPUSH
25541: LD_INT 2
25543: PUSH
25544: LD_INT 30
25546: PUSH
25547: LD_INT 4
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PUSH
25554: LD_INT 30
25556: PUSH
25557: LD_INT 5
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: LIST
25568: PPUSH
25569: CALL_OW 72
25573: PUSH
25574: LD_INT 6
25576: MUL
25577: PLUS
25578: ST_TO_ADDR
// if bcount < tmp then
25579: LD_VAR 0 13
25583: PUSH
25584: LD_VAR 0 4
25588: LESS
25589: IFFALSE 25635
// for i = tmp downto bcount do
25591: LD_ADDR_VAR 0 3
25595: PUSH
25596: DOUBLE
25597: LD_VAR 0 4
25601: INC
25602: ST_TO_ADDR
25603: LD_VAR 0 13
25607: PUSH
25608: FOR_DOWNTO
25609: IFFALSE 25633
// tmp := Delete ( tmp , tmp ) ;
25611: LD_ADDR_VAR 0 4
25615: PUSH
25616: LD_VAR 0 4
25620: PPUSH
25621: LD_VAR 0 4
25625: PPUSH
25626: CALL_OW 3
25630: ST_TO_ADDR
25631: GO 25608
25633: POP
25634: POP
// result := [ tmp , 0 , 0 , p ] ;
25635: LD_ADDR_VAR 0 2
25639: PUSH
25640: LD_VAR 0 4
25644: PUSH
25645: LD_INT 0
25647: PUSH
25648: LD_INT 0
25650: PUSH
25651: LD_VAR 0 11
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: ST_TO_ADDR
// exit ;
25662: GO 28352
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25664: LD_EXP 74
25668: PUSH
25669: LD_VAR 0 1
25673: ARRAY
25674: PPUSH
25675: LD_INT 2
25677: PUSH
25678: LD_INT 30
25680: PUSH
25681: LD_INT 6
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: LD_INT 30
25690: PUSH
25691: LD_INT 7
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 30
25700: PUSH
25701: LD_INT 8
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: EMPTY
25709: LIST
25710: LIST
25711: LIST
25712: LIST
25713: PPUSH
25714: CALL_OW 72
25718: NOT
25719: PUSH
25720: LD_EXP 74
25724: PUSH
25725: LD_VAR 0 1
25729: ARRAY
25730: PPUSH
25731: LD_INT 30
25733: PUSH
25734: LD_INT 3
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PPUSH
25741: CALL_OW 72
25745: NOT
25746: AND
25747: IFFALSE 25819
// begin if eng = tmp then
25749: LD_VAR 0 6
25753: PUSH
25754: LD_VAR 0 4
25758: EQUAL
25759: IFFALSE 25763
// exit ;
25761: GO 28352
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
25763: LD_ADDR_EXP 116
25767: PUSH
25768: LD_EXP 116
25772: PPUSH
25773: LD_VAR 0 1
25777: PPUSH
25778: LD_INT 1
25780: PPUSH
25781: CALL_OW 1
25785: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
25786: LD_ADDR_VAR 0 2
25790: PUSH
25791: LD_INT 0
25793: PUSH
25794: LD_VAR 0 4
25798: PUSH
25799: LD_VAR 0 6
25803: DIFF
25804: PUSH
25805: LD_INT 0
25807: PUSH
25808: LD_INT 0
25810: PUSH
25811: EMPTY
25812: LIST
25813: LIST
25814: LIST
25815: LIST
25816: ST_TO_ADDR
// exit ;
25817: GO 28352
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25819: LD_EXP 101
25823: PUSH
25824: LD_EXP 100
25828: PUSH
25829: LD_VAR 0 1
25833: ARRAY
25834: ARRAY
25835: PUSH
25836: LD_EXP 74
25840: PUSH
25841: LD_VAR 0 1
25845: ARRAY
25846: PPUSH
25847: LD_INT 2
25849: PUSH
25850: LD_INT 30
25852: PUSH
25853: LD_INT 6
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 30
25862: PUSH
25863: LD_INT 7
25865: PUSH
25866: EMPTY
25867: LIST
25868: LIST
25869: PUSH
25870: LD_INT 30
25872: PUSH
25873: LD_INT 8
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: LIST
25884: LIST
25885: PPUSH
25886: CALL_OW 72
25890: AND
25891: PUSH
25892: LD_EXP 74
25896: PUSH
25897: LD_VAR 0 1
25901: ARRAY
25902: PPUSH
25903: LD_INT 30
25905: PUSH
25906: LD_INT 3
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PPUSH
25913: CALL_OW 72
25917: NOT
25918: AND
25919: IFFALSE 26133
// begin if sci >= 6 then
25921: LD_VAR 0 8
25925: PUSH
25926: LD_INT 6
25928: GREATEREQUAL
25929: IFFALSE 25933
// exit ;
25931: GO 28352
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
25933: LD_ADDR_EXP 116
25937: PUSH
25938: LD_EXP 116
25942: PPUSH
25943: LD_VAR 0 1
25947: PPUSH
25948: LD_INT 2
25950: PPUSH
25951: CALL_OW 1
25955: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
25956: LD_ADDR_VAR 0 9
25960: PUSH
25961: LD_VAR 0 4
25965: PUSH
25966: LD_VAR 0 8
25970: DIFF
25971: PPUSH
25972: LD_INT 4
25974: PPUSH
25975: CALL 91241 0 2
25979: ST_TO_ADDR
// p := [ ] ;
25980: LD_ADDR_VAR 0 11
25984: PUSH
25985: EMPTY
25986: ST_TO_ADDR
// if sci < 6 and sort > 6 then
25987: LD_VAR 0 8
25991: PUSH
25992: LD_INT 6
25994: LESS
25995: PUSH
25996: LD_VAR 0 9
26000: PUSH
26001: LD_INT 6
26003: GREATER
26004: AND
26005: IFFALSE 26086
// begin for i = 1 to 6 - sci do
26007: LD_ADDR_VAR 0 3
26011: PUSH
26012: DOUBLE
26013: LD_INT 1
26015: DEC
26016: ST_TO_ADDR
26017: LD_INT 6
26019: PUSH
26020: LD_VAR 0 8
26024: MINUS
26025: PUSH
26026: FOR_TO
26027: IFFALSE 26082
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26029: LD_ADDR_VAR 0 11
26033: PUSH
26034: LD_VAR 0 11
26038: PPUSH
26039: LD_VAR 0 11
26043: PUSH
26044: LD_INT 1
26046: PLUS
26047: PPUSH
26048: LD_VAR 0 9
26052: PUSH
26053: LD_INT 1
26055: ARRAY
26056: PPUSH
26057: CALL_OW 2
26061: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26062: LD_ADDR_VAR 0 9
26066: PUSH
26067: LD_VAR 0 9
26071: PPUSH
26072: LD_INT 1
26074: PPUSH
26075: CALL_OW 3
26079: ST_TO_ADDR
// end ;
26080: GO 26026
26082: POP
26083: POP
// end else
26084: GO 26106
// if sort then
26086: LD_VAR 0 9
26090: IFFALSE 26106
// p := sort [ 1 ] ;
26092: LD_ADDR_VAR 0 11
26096: PUSH
26097: LD_VAR 0 9
26101: PUSH
26102: LD_INT 1
26104: ARRAY
26105: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26106: LD_ADDR_VAR 0 2
26110: PUSH
26111: LD_INT 0
26113: PUSH
26114: LD_INT 0
26116: PUSH
26117: LD_INT 0
26119: PUSH
26120: LD_VAR 0 11
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: LIST
26129: LIST
26130: ST_TO_ADDR
// exit ;
26131: GO 28352
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26133: LD_EXP 101
26137: PUSH
26138: LD_EXP 100
26142: PUSH
26143: LD_VAR 0 1
26147: ARRAY
26148: ARRAY
26149: PUSH
26150: LD_EXP 74
26154: PUSH
26155: LD_VAR 0 1
26159: ARRAY
26160: PPUSH
26161: LD_INT 2
26163: PUSH
26164: LD_INT 30
26166: PUSH
26167: LD_INT 6
26169: PUSH
26170: EMPTY
26171: LIST
26172: LIST
26173: PUSH
26174: LD_INT 30
26176: PUSH
26177: LD_INT 7
26179: PUSH
26180: EMPTY
26181: LIST
26182: LIST
26183: PUSH
26184: LD_INT 30
26186: PUSH
26187: LD_INT 8
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: LIST
26198: LIST
26199: PPUSH
26200: CALL_OW 72
26204: AND
26205: PUSH
26206: LD_EXP 74
26210: PUSH
26211: LD_VAR 0 1
26215: ARRAY
26216: PPUSH
26217: LD_INT 30
26219: PUSH
26220: LD_INT 3
26222: PUSH
26223: EMPTY
26224: LIST
26225: LIST
26226: PPUSH
26227: CALL_OW 72
26231: AND
26232: IFFALSE 26966
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26234: LD_ADDR_EXP 116
26238: PUSH
26239: LD_EXP 116
26243: PPUSH
26244: LD_VAR 0 1
26248: PPUSH
26249: LD_INT 3
26251: PPUSH
26252: CALL_OW 1
26256: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26257: LD_ADDR_VAR 0 2
26261: PUSH
26262: LD_INT 0
26264: PUSH
26265: LD_INT 0
26267: PUSH
26268: LD_INT 0
26270: PUSH
26271: LD_INT 0
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: LIST
26278: LIST
26279: ST_TO_ADDR
// if not eng then
26280: LD_VAR 0 6
26284: NOT
26285: IFFALSE 26348
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26287: LD_ADDR_VAR 0 11
26291: PUSH
26292: LD_VAR 0 4
26296: PPUSH
26297: LD_INT 2
26299: PPUSH
26300: CALL 91241 0 2
26304: PUSH
26305: LD_INT 1
26307: ARRAY
26308: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26309: LD_ADDR_VAR 0 2
26313: PUSH
26314: LD_VAR 0 2
26318: PPUSH
26319: LD_INT 2
26321: PPUSH
26322: LD_VAR 0 11
26326: PPUSH
26327: CALL_OW 1
26331: ST_TO_ADDR
// tmp := tmp diff p ;
26332: LD_ADDR_VAR 0 4
26336: PUSH
26337: LD_VAR 0 4
26341: PUSH
26342: LD_VAR 0 11
26346: DIFF
26347: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26348: LD_VAR 0 4
26352: PUSH
26353: LD_VAR 0 8
26357: PUSH
26358: LD_INT 6
26360: LESS
26361: AND
26362: IFFALSE 26550
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26364: LD_ADDR_VAR 0 9
26368: PUSH
26369: LD_VAR 0 4
26373: PUSH
26374: LD_VAR 0 8
26378: PUSH
26379: LD_VAR 0 7
26383: UNION
26384: DIFF
26385: PPUSH
26386: LD_INT 4
26388: PPUSH
26389: CALL 91241 0 2
26393: ST_TO_ADDR
// p := [ ] ;
26394: LD_ADDR_VAR 0 11
26398: PUSH
26399: EMPTY
26400: ST_TO_ADDR
// if sort then
26401: LD_VAR 0 9
26405: IFFALSE 26521
// for i = 1 to 6 - sci do
26407: LD_ADDR_VAR 0 3
26411: PUSH
26412: DOUBLE
26413: LD_INT 1
26415: DEC
26416: ST_TO_ADDR
26417: LD_INT 6
26419: PUSH
26420: LD_VAR 0 8
26424: MINUS
26425: PUSH
26426: FOR_TO
26427: IFFALSE 26519
// begin if i = sort then
26429: LD_VAR 0 3
26433: PUSH
26434: LD_VAR 0 9
26438: EQUAL
26439: IFFALSE 26443
// break ;
26441: GO 26519
// if GetClass ( i ) = 4 then
26443: LD_VAR 0 3
26447: PPUSH
26448: CALL_OW 257
26452: PUSH
26453: LD_INT 4
26455: EQUAL
26456: IFFALSE 26460
// continue ;
26458: GO 26426
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26460: LD_ADDR_VAR 0 11
26464: PUSH
26465: LD_VAR 0 11
26469: PPUSH
26470: LD_VAR 0 11
26474: PUSH
26475: LD_INT 1
26477: PLUS
26478: PPUSH
26479: LD_VAR 0 9
26483: PUSH
26484: LD_VAR 0 3
26488: ARRAY
26489: PPUSH
26490: CALL_OW 2
26494: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26495: LD_ADDR_VAR 0 4
26499: PUSH
26500: LD_VAR 0 4
26504: PUSH
26505: LD_VAR 0 9
26509: PUSH
26510: LD_VAR 0 3
26514: ARRAY
26515: DIFF
26516: ST_TO_ADDR
// end ;
26517: GO 26426
26519: POP
26520: POP
// if p then
26521: LD_VAR 0 11
26525: IFFALSE 26550
// result := Replace ( result , 4 , p ) ;
26527: LD_ADDR_VAR 0 2
26531: PUSH
26532: LD_VAR 0 2
26536: PPUSH
26537: LD_INT 4
26539: PPUSH
26540: LD_VAR 0 11
26544: PPUSH
26545: CALL_OW 1
26549: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26550: LD_VAR 0 4
26554: PUSH
26555: LD_VAR 0 7
26559: PUSH
26560: LD_INT 6
26562: LESS
26563: AND
26564: IFFALSE 26752
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26566: LD_ADDR_VAR 0 9
26570: PUSH
26571: LD_VAR 0 4
26575: PUSH
26576: LD_VAR 0 8
26580: PUSH
26581: LD_VAR 0 7
26585: UNION
26586: DIFF
26587: PPUSH
26588: LD_INT 3
26590: PPUSH
26591: CALL 91241 0 2
26595: ST_TO_ADDR
// p := [ ] ;
26596: LD_ADDR_VAR 0 11
26600: PUSH
26601: EMPTY
26602: ST_TO_ADDR
// if sort then
26603: LD_VAR 0 9
26607: IFFALSE 26723
// for i = 1 to 6 - mech do
26609: LD_ADDR_VAR 0 3
26613: PUSH
26614: DOUBLE
26615: LD_INT 1
26617: DEC
26618: ST_TO_ADDR
26619: LD_INT 6
26621: PUSH
26622: LD_VAR 0 7
26626: MINUS
26627: PUSH
26628: FOR_TO
26629: IFFALSE 26721
// begin if i = sort then
26631: LD_VAR 0 3
26635: PUSH
26636: LD_VAR 0 9
26640: EQUAL
26641: IFFALSE 26645
// break ;
26643: GO 26721
// if GetClass ( i ) = 3 then
26645: LD_VAR 0 3
26649: PPUSH
26650: CALL_OW 257
26654: PUSH
26655: LD_INT 3
26657: EQUAL
26658: IFFALSE 26662
// continue ;
26660: GO 26628
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26662: LD_ADDR_VAR 0 11
26666: PUSH
26667: LD_VAR 0 11
26671: PPUSH
26672: LD_VAR 0 11
26676: PUSH
26677: LD_INT 1
26679: PLUS
26680: PPUSH
26681: LD_VAR 0 9
26685: PUSH
26686: LD_VAR 0 3
26690: ARRAY
26691: PPUSH
26692: CALL_OW 2
26696: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26697: LD_ADDR_VAR 0 4
26701: PUSH
26702: LD_VAR 0 4
26706: PUSH
26707: LD_VAR 0 9
26711: PUSH
26712: LD_VAR 0 3
26716: ARRAY
26717: DIFF
26718: ST_TO_ADDR
// end ;
26719: GO 26628
26721: POP
26722: POP
// if p then
26723: LD_VAR 0 11
26727: IFFALSE 26752
// result := Replace ( result , 3 , p ) ;
26729: LD_ADDR_VAR 0 2
26733: PUSH
26734: LD_VAR 0 2
26738: PPUSH
26739: LD_INT 3
26741: PPUSH
26742: LD_VAR 0 11
26746: PPUSH
26747: CALL_OW 1
26751: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
26752: LD_VAR 0 4
26756: PUSH
26757: LD_INT 6
26759: GREATER
26760: PUSH
26761: LD_VAR 0 6
26765: PUSH
26766: LD_INT 6
26768: LESS
26769: AND
26770: IFFALSE 26964
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26772: LD_ADDR_VAR 0 9
26776: PUSH
26777: LD_VAR 0 4
26781: PUSH
26782: LD_VAR 0 8
26786: PUSH
26787: LD_VAR 0 7
26791: UNION
26792: PUSH
26793: LD_VAR 0 6
26797: UNION
26798: DIFF
26799: PPUSH
26800: LD_INT 2
26802: PPUSH
26803: CALL 91241 0 2
26807: ST_TO_ADDR
// p := [ ] ;
26808: LD_ADDR_VAR 0 11
26812: PUSH
26813: EMPTY
26814: ST_TO_ADDR
// if sort then
26815: LD_VAR 0 9
26819: IFFALSE 26935
// for i = 1 to 6 - eng do
26821: LD_ADDR_VAR 0 3
26825: PUSH
26826: DOUBLE
26827: LD_INT 1
26829: DEC
26830: ST_TO_ADDR
26831: LD_INT 6
26833: PUSH
26834: LD_VAR 0 6
26838: MINUS
26839: PUSH
26840: FOR_TO
26841: IFFALSE 26933
// begin if i = sort then
26843: LD_VAR 0 3
26847: PUSH
26848: LD_VAR 0 9
26852: EQUAL
26853: IFFALSE 26857
// break ;
26855: GO 26933
// if GetClass ( i ) = 2 then
26857: LD_VAR 0 3
26861: PPUSH
26862: CALL_OW 257
26866: PUSH
26867: LD_INT 2
26869: EQUAL
26870: IFFALSE 26874
// continue ;
26872: GO 26840
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26874: LD_ADDR_VAR 0 11
26878: PUSH
26879: LD_VAR 0 11
26883: PPUSH
26884: LD_VAR 0 11
26888: PUSH
26889: LD_INT 1
26891: PLUS
26892: PPUSH
26893: LD_VAR 0 9
26897: PUSH
26898: LD_VAR 0 3
26902: ARRAY
26903: PPUSH
26904: CALL_OW 2
26908: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26909: LD_ADDR_VAR 0 4
26913: PUSH
26914: LD_VAR 0 4
26918: PUSH
26919: LD_VAR 0 9
26923: PUSH
26924: LD_VAR 0 3
26928: ARRAY
26929: DIFF
26930: ST_TO_ADDR
// end ;
26931: GO 26840
26933: POP
26934: POP
// if p then
26935: LD_VAR 0 11
26939: IFFALSE 26964
// result := Replace ( result , 2 , p ) ;
26941: LD_ADDR_VAR 0 2
26945: PUSH
26946: LD_VAR 0 2
26950: PPUSH
26951: LD_INT 2
26953: PPUSH
26954: LD_VAR 0 11
26958: PPUSH
26959: CALL_OW 1
26963: ST_TO_ADDR
// end ; exit ;
26964: GO 28352
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
26966: LD_EXP 101
26970: PUSH
26971: LD_EXP 100
26975: PUSH
26976: LD_VAR 0 1
26980: ARRAY
26981: ARRAY
26982: NOT
26983: PUSH
26984: LD_EXP 74
26988: PUSH
26989: LD_VAR 0 1
26993: ARRAY
26994: PPUSH
26995: LD_INT 30
26997: PUSH
26998: LD_INT 3
27000: PUSH
27001: EMPTY
27002: LIST
27003: LIST
27004: PPUSH
27005: CALL_OW 72
27009: AND
27010: PUSH
27011: LD_EXP 79
27015: PUSH
27016: LD_VAR 0 1
27020: ARRAY
27021: AND
27022: IFFALSE 27630
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27024: LD_ADDR_EXP 116
27028: PUSH
27029: LD_EXP 116
27033: PPUSH
27034: LD_VAR 0 1
27038: PPUSH
27039: LD_INT 5
27041: PPUSH
27042: CALL_OW 1
27046: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27047: LD_ADDR_VAR 0 2
27051: PUSH
27052: LD_INT 0
27054: PUSH
27055: LD_INT 0
27057: PUSH
27058: LD_INT 0
27060: PUSH
27061: LD_INT 0
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: LIST
27068: LIST
27069: ST_TO_ADDR
// if sci > 1 then
27070: LD_VAR 0 8
27074: PUSH
27075: LD_INT 1
27077: GREATER
27078: IFFALSE 27106
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27080: LD_ADDR_VAR 0 4
27084: PUSH
27085: LD_VAR 0 4
27089: PUSH
27090: LD_VAR 0 8
27094: PUSH
27095: LD_VAR 0 8
27099: PUSH
27100: LD_INT 1
27102: ARRAY
27103: DIFF
27104: DIFF
27105: ST_TO_ADDR
// if tmp and not sci then
27106: LD_VAR 0 4
27110: PUSH
27111: LD_VAR 0 8
27115: NOT
27116: AND
27117: IFFALSE 27186
// begin sort := SortBySkill ( tmp , 4 ) ;
27119: LD_ADDR_VAR 0 9
27123: PUSH
27124: LD_VAR 0 4
27128: PPUSH
27129: LD_INT 4
27131: PPUSH
27132: CALL 91241 0 2
27136: ST_TO_ADDR
// if sort then
27137: LD_VAR 0 9
27141: IFFALSE 27157
// p := sort [ 1 ] ;
27143: LD_ADDR_VAR 0 11
27147: PUSH
27148: LD_VAR 0 9
27152: PUSH
27153: LD_INT 1
27155: ARRAY
27156: ST_TO_ADDR
// if p then
27157: LD_VAR 0 11
27161: IFFALSE 27186
// result := Replace ( result , 4 , p ) ;
27163: LD_ADDR_VAR 0 2
27167: PUSH
27168: LD_VAR 0 2
27172: PPUSH
27173: LD_INT 4
27175: PPUSH
27176: LD_VAR 0 11
27180: PPUSH
27181: CALL_OW 1
27185: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27186: LD_ADDR_VAR 0 4
27190: PUSH
27191: LD_VAR 0 4
27195: PUSH
27196: LD_VAR 0 7
27200: DIFF
27201: ST_TO_ADDR
// if tmp and mech < 6 then
27202: LD_VAR 0 4
27206: PUSH
27207: LD_VAR 0 7
27211: PUSH
27212: LD_INT 6
27214: LESS
27215: AND
27216: IFFALSE 27404
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27218: LD_ADDR_VAR 0 9
27222: PUSH
27223: LD_VAR 0 4
27227: PUSH
27228: LD_VAR 0 8
27232: PUSH
27233: LD_VAR 0 7
27237: UNION
27238: DIFF
27239: PPUSH
27240: LD_INT 3
27242: PPUSH
27243: CALL 91241 0 2
27247: ST_TO_ADDR
// p := [ ] ;
27248: LD_ADDR_VAR 0 11
27252: PUSH
27253: EMPTY
27254: ST_TO_ADDR
// if sort then
27255: LD_VAR 0 9
27259: IFFALSE 27375
// for i = 1 to 6 - mech do
27261: LD_ADDR_VAR 0 3
27265: PUSH
27266: DOUBLE
27267: LD_INT 1
27269: DEC
27270: ST_TO_ADDR
27271: LD_INT 6
27273: PUSH
27274: LD_VAR 0 7
27278: MINUS
27279: PUSH
27280: FOR_TO
27281: IFFALSE 27373
// begin if i = sort then
27283: LD_VAR 0 3
27287: PUSH
27288: LD_VAR 0 9
27292: EQUAL
27293: IFFALSE 27297
// break ;
27295: GO 27373
// if GetClass ( i ) = 3 then
27297: LD_VAR 0 3
27301: PPUSH
27302: CALL_OW 257
27306: PUSH
27307: LD_INT 3
27309: EQUAL
27310: IFFALSE 27314
// continue ;
27312: GO 27280
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27314: LD_ADDR_VAR 0 11
27318: PUSH
27319: LD_VAR 0 11
27323: PPUSH
27324: LD_VAR 0 11
27328: PUSH
27329: LD_INT 1
27331: PLUS
27332: PPUSH
27333: LD_VAR 0 9
27337: PUSH
27338: LD_VAR 0 3
27342: ARRAY
27343: PPUSH
27344: CALL_OW 2
27348: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27349: LD_ADDR_VAR 0 4
27353: PUSH
27354: LD_VAR 0 4
27358: PUSH
27359: LD_VAR 0 9
27363: PUSH
27364: LD_VAR 0 3
27368: ARRAY
27369: DIFF
27370: ST_TO_ADDR
// end ;
27371: GO 27280
27373: POP
27374: POP
// if p then
27375: LD_VAR 0 11
27379: IFFALSE 27404
// result := Replace ( result , 3 , p ) ;
27381: LD_ADDR_VAR 0 2
27385: PUSH
27386: LD_VAR 0 2
27390: PPUSH
27391: LD_INT 3
27393: PPUSH
27394: LD_VAR 0 11
27398: PPUSH
27399: CALL_OW 1
27403: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27404: LD_ADDR_VAR 0 4
27408: PUSH
27409: LD_VAR 0 4
27413: PUSH
27414: LD_VAR 0 6
27418: DIFF
27419: ST_TO_ADDR
// if tmp and eng < 6 then
27420: LD_VAR 0 4
27424: PUSH
27425: LD_VAR 0 6
27429: PUSH
27430: LD_INT 6
27432: LESS
27433: AND
27434: IFFALSE 27628
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27436: LD_ADDR_VAR 0 9
27440: PUSH
27441: LD_VAR 0 4
27445: PUSH
27446: LD_VAR 0 8
27450: PUSH
27451: LD_VAR 0 7
27455: UNION
27456: PUSH
27457: LD_VAR 0 6
27461: UNION
27462: DIFF
27463: PPUSH
27464: LD_INT 2
27466: PPUSH
27467: CALL 91241 0 2
27471: ST_TO_ADDR
// p := [ ] ;
27472: LD_ADDR_VAR 0 11
27476: PUSH
27477: EMPTY
27478: ST_TO_ADDR
// if sort then
27479: LD_VAR 0 9
27483: IFFALSE 27599
// for i = 1 to 6 - eng do
27485: LD_ADDR_VAR 0 3
27489: PUSH
27490: DOUBLE
27491: LD_INT 1
27493: DEC
27494: ST_TO_ADDR
27495: LD_INT 6
27497: PUSH
27498: LD_VAR 0 6
27502: MINUS
27503: PUSH
27504: FOR_TO
27505: IFFALSE 27597
// begin if i = sort then
27507: LD_VAR 0 3
27511: PUSH
27512: LD_VAR 0 9
27516: EQUAL
27517: IFFALSE 27521
// break ;
27519: GO 27597
// if GetClass ( i ) = 2 then
27521: LD_VAR 0 3
27525: PPUSH
27526: CALL_OW 257
27530: PUSH
27531: LD_INT 2
27533: EQUAL
27534: IFFALSE 27538
// continue ;
27536: GO 27504
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27538: LD_ADDR_VAR 0 11
27542: PUSH
27543: LD_VAR 0 11
27547: PPUSH
27548: LD_VAR 0 11
27552: PUSH
27553: LD_INT 1
27555: PLUS
27556: PPUSH
27557: LD_VAR 0 9
27561: PUSH
27562: LD_VAR 0 3
27566: ARRAY
27567: PPUSH
27568: CALL_OW 2
27572: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27573: LD_ADDR_VAR 0 4
27577: PUSH
27578: LD_VAR 0 4
27582: PUSH
27583: LD_VAR 0 9
27587: PUSH
27588: LD_VAR 0 3
27592: ARRAY
27593: DIFF
27594: ST_TO_ADDR
// end ;
27595: GO 27504
27597: POP
27598: POP
// if p then
27599: LD_VAR 0 11
27603: IFFALSE 27628
// result := Replace ( result , 2 , p ) ;
27605: LD_ADDR_VAR 0 2
27609: PUSH
27610: LD_VAR 0 2
27614: PPUSH
27615: LD_INT 2
27617: PPUSH
27618: LD_VAR 0 11
27622: PPUSH
27623: CALL_OW 1
27627: ST_TO_ADDR
// end ; exit ;
27628: GO 28352
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27630: LD_EXP 101
27634: PUSH
27635: LD_EXP 100
27639: PUSH
27640: LD_VAR 0 1
27644: ARRAY
27645: ARRAY
27646: NOT
27647: PUSH
27648: LD_EXP 74
27652: PUSH
27653: LD_VAR 0 1
27657: ARRAY
27658: PPUSH
27659: LD_INT 30
27661: PUSH
27662: LD_INT 3
27664: PUSH
27665: EMPTY
27666: LIST
27667: LIST
27668: PPUSH
27669: CALL_OW 72
27673: AND
27674: PUSH
27675: LD_EXP 79
27679: PUSH
27680: LD_VAR 0 1
27684: ARRAY
27685: NOT
27686: AND
27687: IFFALSE 28352
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27689: LD_ADDR_EXP 116
27693: PUSH
27694: LD_EXP 116
27698: PPUSH
27699: LD_VAR 0 1
27703: PPUSH
27704: LD_INT 6
27706: PPUSH
27707: CALL_OW 1
27711: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27712: LD_ADDR_VAR 0 2
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: LD_INT 0
27722: PUSH
27723: LD_INT 0
27725: PUSH
27726: LD_INT 0
27728: PUSH
27729: EMPTY
27730: LIST
27731: LIST
27732: LIST
27733: LIST
27734: ST_TO_ADDR
// if sci >= 1 then
27735: LD_VAR 0 8
27739: PUSH
27740: LD_INT 1
27742: GREATEREQUAL
27743: IFFALSE 27765
// tmp := tmp diff sci [ 1 ] ;
27745: LD_ADDR_VAR 0 4
27749: PUSH
27750: LD_VAR 0 4
27754: PUSH
27755: LD_VAR 0 8
27759: PUSH
27760: LD_INT 1
27762: ARRAY
27763: DIFF
27764: ST_TO_ADDR
// if tmp and not sci then
27765: LD_VAR 0 4
27769: PUSH
27770: LD_VAR 0 8
27774: NOT
27775: AND
27776: IFFALSE 27845
// begin sort := SortBySkill ( tmp , 4 ) ;
27778: LD_ADDR_VAR 0 9
27782: PUSH
27783: LD_VAR 0 4
27787: PPUSH
27788: LD_INT 4
27790: PPUSH
27791: CALL 91241 0 2
27795: ST_TO_ADDR
// if sort then
27796: LD_VAR 0 9
27800: IFFALSE 27816
// p := sort [ 1 ] ;
27802: LD_ADDR_VAR 0 11
27806: PUSH
27807: LD_VAR 0 9
27811: PUSH
27812: LD_INT 1
27814: ARRAY
27815: ST_TO_ADDR
// if p then
27816: LD_VAR 0 11
27820: IFFALSE 27845
// result := Replace ( result , 4 , p ) ;
27822: LD_ADDR_VAR 0 2
27826: PUSH
27827: LD_VAR 0 2
27831: PPUSH
27832: LD_INT 4
27834: PPUSH
27835: LD_VAR 0 11
27839: PPUSH
27840: CALL_OW 1
27844: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27845: LD_ADDR_VAR 0 4
27849: PUSH
27850: LD_VAR 0 4
27854: PUSH
27855: LD_VAR 0 7
27859: DIFF
27860: ST_TO_ADDR
// if tmp and mech < 6 then
27861: LD_VAR 0 4
27865: PUSH
27866: LD_VAR 0 7
27870: PUSH
27871: LD_INT 6
27873: LESS
27874: AND
27875: IFFALSE 28057
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
27877: LD_ADDR_VAR 0 9
27881: PUSH
27882: LD_VAR 0 4
27886: PUSH
27887: LD_VAR 0 7
27891: DIFF
27892: PPUSH
27893: LD_INT 3
27895: PPUSH
27896: CALL 91241 0 2
27900: ST_TO_ADDR
// p := [ ] ;
27901: LD_ADDR_VAR 0 11
27905: PUSH
27906: EMPTY
27907: ST_TO_ADDR
// if sort then
27908: LD_VAR 0 9
27912: IFFALSE 28028
// for i = 1 to 6 - mech do
27914: LD_ADDR_VAR 0 3
27918: PUSH
27919: DOUBLE
27920: LD_INT 1
27922: DEC
27923: ST_TO_ADDR
27924: LD_INT 6
27926: PUSH
27927: LD_VAR 0 7
27931: MINUS
27932: PUSH
27933: FOR_TO
27934: IFFALSE 28026
// begin if i = sort then
27936: LD_VAR 0 3
27940: PUSH
27941: LD_VAR 0 9
27945: EQUAL
27946: IFFALSE 27950
// break ;
27948: GO 28026
// if GetClass ( i ) = 3 then
27950: LD_VAR 0 3
27954: PPUSH
27955: CALL_OW 257
27959: PUSH
27960: LD_INT 3
27962: EQUAL
27963: IFFALSE 27967
// continue ;
27965: GO 27933
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27967: LD_ADDR_VAR 0 11
27971: PUSH
27972: LD_VAR 0 11
27976: PPUSH
27977: LD_VAR 0 11
27981: PUSH
27982: LD_INT 1
27984: PLUS
27985: PPUSH
27986: LD_VAR 0 9
27990: PUSH
27991: LD_VAR 0 3
27995: ARRAY
27996: PPUSH
27997: CALL_OW 2
28001: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28002: LD_ADDR_VAR 0 4
28006: PUSH
28007: LD_VAR 0 4
28011: PUSH
28012: LD_VAR 0 9
28016: PUSH
28017: LD_VAR 0 3
28021: ARRAY
28022: DIFF
28023: ST_TO_ADDR
// end ;
28024: GO 27933
28026: POP
28027: POP
// if p then
28028: LD_VAR 0 11
28032: IFFALSE 28057
// result := Replace ( result , 3 , p ) ;
28034: LD_ADDR_VAR 0 2
28038: PUSH
28039: LD_VAR 0 2
28043: PPUSH
28044: LD_INT 3
28046: PPUSH
28047: LD_VAR 0 11
28051: PPUSH
28052: CALL_OW 1
28056: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28057: LD_ADDR_VAR 0 4
28061: PUSH
28062: LD_VAR 0 4
28066: PUSH
28067: LD_VAR 0 6
28071: DIFF
28072: ST_TO_ADDR
// if tmp and eng < 4 then
28073: LD_VAR 0 4
28077: PUSH
28078: LD_VAR 0 6
28082: PUSH
28083: LD_INT 4
28085: LESS
28086: AND
28087: IFFALSE 28277
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28089: LD_ADDR_VAR 0 9
28093: PUSH
28094: LD_VAR 0 4
28098: PUSH
28099: LD_VAR 0 7
28103: PUSH
28104: LD_VAR 0 6
28108: UNION
28109: DIFF
28110: PPUSH
28111: LD_INT 2
28113: PPUSH
28114: CALL 91241 0 2
28118: ST_TO_ADDR
// p := [ ] ;
28119: LD_ADDR_VAR 0 11
28123: PUSH
28124: EMPTY
28125: ST_TO_ADDR
// if sort then
28126: LD_VAR 0 9
28130: IFFALSE 28246
// for i = 1 to 4 - eng do
28132: LD_ADDR_VAR 0 3
28136: PUSH
28137: DOUBLE
28138: LD_INT 1
28140: DEC
28141: ST_TO_ADDR
28142: LD_INT 4
28144: PUSH
28145: LD_VAR 0 6
28149: MINUS
28150: PUSH
28151: FOR_TO
28152: IFFALSE 28244
// begin if i = sort then
28154: LD_VAR 0 3
28158: PUSH
28159: LD_VAR 0 9
28163: EQUAL
28164: IFFALSE 28168
// break ;
28166: GO 28244
// if GetClass ( i ) = 2 then
28168: LD_VAR 0 3
28172: PPUSH
28173: CALL_OW 257
28177: PUSH
28178: LD_INT 2
28180: EQUAL
28181: IFFALSE 28185
// continue ;
28183: GO 28151
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28185: LD_ADDR_VAR 0 11
28189: PUSH
28190: LD_VAR 0 11
28194: PPUSH
28195: LD_VAR 0 11
28199: PUSH
28200: LD_INT 1
28202: PLUS
28203: PPUSH
28204: LD_VAR 0 9
28208: PUSH
28209: LD_VAR 0 3
28213: ARRAY
28214: PPUSH
28215: CALL_OW 2
28219: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28220: LD_ADDR_VAR 0 4
28224: PUSH
28225: LD_VAR 0 4
28229: PUSH
28230: LD_VAR 0 9
28234: PUSH
28235: LD_VAR 0 3
28239: ARRAY
28240: DIFF
28241: ST_TO_ADDR
// end ;
28242: GO 28151
28244: POP
28245: POP
// if p then
28246: LD_VAR 0 11
28250: IFFALSE 28275
// result := Replace ( result , 2 , p ) ;
28252: LD_ADDR_VAR 0 2
28256: PUSH
28257: LD_VAR 0 2
28261: PPUSH
28262: LD_INT 2
28264: PPUSH
28265: LD_VAR 0 11
28269: PPUSH
28270: CALL_OW 1
28274: ST_TO_ADDR
// end else
28275: GO 28321
// for i = eng downto 5 do
28277: LD_ADDR_VAR 0 3
28281: PUSH
28282: DOUBLE
28283: LD_VAR 0 6
28287: INC
28288: ST_TO_ADDR
28289: LD_INT 5
28291: PUSH
28292: FOR_DOWNTO
28293: IFFALSE 28319
// tmp := tmp union eng [ i ] ;
28295: LD_ADDR_VAR 0 4
28299: PUSH
28300: LD_VAR 0 4
28304: PUSH
28305: LD_VAR 0 6
28309: PUSH
28310: LD_VAR 0 3
28314: ARRAY
28315: UNION
28316: ST_TO_ADDR
28317: GO 28292
28319: POP
28320: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28321: LD_ADDR_VAR 0 2
28325: PUSH
28326: LD_VAR 0 2
28330: PPUSH
28331: LD_INT 1
28333: PPUSH
28334: LD_VAR 0 4
28338: PUSH
28339: LD_VAR 0 5
28343: DIFF
28344: PPUSH
28345: CALL_OW 1
28349: ST_TO_ADDR
// exit ;
28350: GO 28352
// end ; end ;
28352: LD_VAR 0 2
28356: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28357: LD_INT 0
28359: PPUSH
28360: PPUSH
28361: PPUSH
// if not mc_bases then
28362: LD_EXP 74
28366: NOT
28367: IFFALSE 28371
// exit ;
28369: GO 28477
// for i = 1 to mc_bases do
28371: LD_ADDR_VAR 0 2
28375: PUSH
28376: DOUBLE
28377: LD_INT 1
28379: DEC
28380: ST_TO_ADDR
28381: LD_EXP 74
28385: PUSH
28386: FOR_TO
28387: IFFALSE 28468
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28389: LD_ADDR_VAR 0 3
28393: PUSH
28394: LD_EXP 74
28398: PUSH
28399: LD_VAR 0 2
28403: ARRAY
28404: PPUSH
28405: LD_INT 21
28407: PUSH
28408: LD_INT 3
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 3
28417: PUSH
28418: LD_INT 24
28420: PUSH
28421: LD_INT 1000
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PPUSH
28436: CALL_OW 72
28440: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28441: LD_ADDR_EXP 75
28445: PUSH
28446: LD_EXP 75
28450: PPUSH
28451: LD_VAR 0 2
28455: PPUSH
28456: LD_VAR 0 3
28460: PPUSH
28461: CALL_OW 1
28465: ST_TO_ADDR
// end ;
28466: GO 28386
28468: POP
28469: POP
// RaiseSailEvent ( 101 ) ;
28470: LD_INT 101
28472: PPUSH
28473: CALL_OW 427
// end ;
28477: LD_VAR 0 1
28481: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28482: LD_INT 0
28484: PPUSH
28485: PPUSH
28486: PPUSH
28487: PPUSH
28488: PPUSH
28489: PPUSH
28490: PPUSH
// if not mc_bases then
28491: LD_EXP 74
28495: NOT
28496: IFFALSE 28500
// exit ;
28498: GO 29073
// for i = 1 to mc_bases do
28500: LD_ADDR_VAR 0 2
28504: PUSH
28505: DOUBLE
28506: LD_INT 1
28508: DEC
28509: ST_TO_ADDR
28510: LD_EXP 74
28514: PUSH
28515: FOR_TO
28516: IFFALSE 29064
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28518: LD_ADDR_VAR 0 5
28522: PUSH
28523: LD_EXP 74
28527: PUSH
28528: LD_VAR 0 2
28532: ARRAY
28533: PUSH
28534: LD_EXP 103
28538: PUSH
28539: LD_VAR 0 2
28543: ARRAY
28544: UNION
28545: PPUSH
28546: LD_INT 21
28548: PUSH
28549: LD_INT 1
28551: PUSH
28552: EMPTY
28553: LIST
28554: LIST
28555: PUSH
28556: LD_INT 1
28558: PUSH
28559: LD_INT 3
28561: PUSH
28562: LD_INT 54
28564: PUSH
28565: EMPTY
28566: LIST
28567: PUSH
28568: EMPTY
28569: LIST
28570: LIST
28571: PUSH
28572: LD_INT 3
28574: PUSH
28575: LD_INT 24
28577: PUSH
28578: LD_INT 800
28580: PUSH
28581: EMPTY
28582: LIST
28583: LIST
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: LIST
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PPUSH
28598: CALL_OW 72
28602: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28603: LD_ADDR_VAR 0 6
28607: PUSH
28608: LD_EXP 74
28612: PUSH
28613: LD_VAR 0 2
28617: ARRAY
28618: PPUSH
28619: LD_INT 21
28621: PUSH
28622: LD_INT 1
28624: PUSH
28625: EMPTY
28626: LIST
28627: LIST
28628: PUSH
28629: LD_INT 1
28631: PUSH
28632: LD_INT 3
28634: PUSH
28635: LD_INT 54
28637: PUSH
28638: EMPTY
28639: LIST
28640: PUSH
28641: EMPTY
28642: LIST
28643: LIST
28644: PUSH
28645: LD_INT 3
28647: PUSH
28648: LD_INT 24
28650: PUSH
28651: LD_INT 250
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: EMPTY
28659: LIST
28660: LIST
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: LIST
28666: PUSH
28667: EMPTY
28668: LIST
28669: LIST
28670: PPUSH
28671: CALL_OW 72
28675: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28676: LD_ADDR_VAR 0 7
28680: PUSH
28681: LD_VAR 0 5
28685: PUSH
28686: LD_VAR 0 6
28690: DIFF
28691: ST_TO_ADDR
// if not need_heal_1 then
28692: LD_VAR 0 6
28696: NOT
28697: IFFALSE 28730
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28699: LD_ADDR_EXP 77
28703: PUSH
28704: LD_EXP 77
28708: PPUSH
28709: LD_VAR 0 2
28713: PUSH
28714: LD_INT 1
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: PPUSH
28721: EMPTY
28722: PPUSH
28723: CALL 56993 0 3
28727: ST_TO_ADDR
28728: GO 28800
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28730: LD_ADDR_EXP 77
28734: PUSH
28735: LD_EXP 77
28739: PPUSH
28740: LD_VAR 0 2
28744: PUSH
28745: LD_INT 1
28747: PUSH
28748: EMPTY
28749: LIST
28750: LIST
28751: PPUSH
28752: LD_EXP 77
28756: PUSH
28757: LD_VAR 0 2
28761: ARRAY
28762: PUSH
28763: LD_INT 1
28765: ARRAY
28766: PPUSH
28767: LD_INT 3
28769: PUSH
28770: LD_INT 24
28772: PUSH
28773: LD_INT 1000
28775: PUSH
28776: EMPTY
28777: LIST
28778: LIST
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PPUSH
28784: CALL_OW 72
28788: PUSH
28789: LD_VAR 0 6
28793: UNION
28794: PPUSH
28795: CALL 56993 0 3
28799: ST_TO_ADDR
// if not need_heal_2 then
28800: LD_VAR 0 7
28804: NOT
28805: IFFALSE 28838
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
28807: LD_ADDR_EXP 77
28811: PUSH
28812: LD_EXP 77
28816: PPUSH
28817: LD_VAR 0 2
28821: PUSH
28822: LD_INT 2
28824: PUSH
28825: EMPTY
28826: LIST
28827: LIST
28828: PPUSH
28829: EMPTY
28830: PPUSH
28831: CALL 56993 0 3
28835: ST_TO_ADDR
28836: GO 28870
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
28838: LD_ADDR_EXP 77
28842: PUSH
28843: LD_EXP 77
28847: PPUSH
28848: LD_VAR 0 2
28852: PUSH
28853: LD_INT 2
28855: PUSH
28856: EMPTY
28857: LIST
28858: LIST
28859: PPUSH
28860: LD_VAR 0 7
28864: PPUSH
28865: CALL 56993 0 3
28869: ST_TO_ADDR
// if need_heal_2 then
28870: LD_VAR 0 7
28874: IFFALSE 29046
// for j in need_heal_2 do
28876: LD_ADDR_VAR 0 3
28880: PUSH
28881: LD_VAR 0 7
28885: PUSH
28886: FOR_IN
28887: IFFALSE 29044
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
28889: LD_ADDR_VAR 0 5
28893: PUSH
28894: LD_EXP 74
28898: PUSH
28899: LD_VAR 0 2
28903: ARRAY
28904: PPUSH
28905: LD_INT 2
28907: PUSH
28908: LD_INT 30
28910: PUSH
28911: LD_INT 6
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 30
28920: PUSH
28921: LD_INT 7
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PUSH
28928: LD_INT 30
28930: PUSH
28931: LD_INT 8
28933: PUSH
28934: EMPTY
28935: LIST
28936: LIST
28937: PUSH
28938: LD_INT 30
28940: PUSH
28941: LD_INT 0
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: LD_INT 30
28950: PUSH
28951: LD_INT 1
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: LD_INT 25
28960: PUSH
28961: LD_INT 4
28963: PUSH
28964: EMPTY
28965: LIST
28966: LIST
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: LIST
28972: LIST
28973: LIST
28974: LIST
28975: LIST
28976: PPUSH
28977: CALL_OW 72
28981: ST_TO_ADDR
// if tmp then
28982: LD_VAR 0 5
28986: IFFALSE 29042
// begin k := NearestUnitToUnit ( tmp , j ) ;
28988: LD_ADDR_VAR 0 4
28992: PUSH
28993: LD_VAR 0 5
28997: PPUSH
28998: LD_VAR 0 3
29002: PPUSH
29003: CALL_OW 74
29007: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29008: LD_VAR 0 3
29012: PPUSH
29013: LD_VAR 0 4
29017: PPUSH
29018: CALL_OW 296
29022: PUSH
29023: LD_INT 7
29025: GREATER
29026: IFFALSE 29042
// ComMoveUnit ( j , k ) ;
29028: LD_VAR 0 3
29032: PPUSH
29033: LD_VAR 0 4
29037: PPUSH
29038: CALL_OW 112
// end ; end ;
29042: GO 28886
29044: POP
29045: POP
// if not need_heal_1 and not need_heal_2 then
29046: LD_VAR 0 6
29050: NOT
29051: PUSH
29052: LD_VAR 0 7
29056: NOT
29057: AND
29058: IFFALSE 29062
// continue ;
29060: GO 28515
// end ;
29062: GO 28515
29064: POP
29065: POP
// RaiseSailEvent ( 102 ) ;
29066: LD_INT 102
29068: PPUSH
29069: CALL_OW 427
// end ;
29073: LD_VAR 0 1
29077: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
29078: LD_INT 0
29080: PPUSH
29081: PPUSH
29082: PPUSH
29083: PPUSH
29084: PPUSH
29085: PPUSH
// if not mc_bases then
29086: LD_EXP 74
29090: NOT
29091: IFFALSE 29095
// exit ;
29093: GO 29805
// for i = 1 to mc_bases do
29095: LD_ADDR_VAR 0 2
29099: PUSH
29100: DOUBLE
29101: LD_INT 1
29103: DEC
29104: ST_TO_ADDR
29105: LD_EXP 74
29109: PUSH
29110: FOR_TO
29111: IFFALSE 29803
// begin if not mc_building_need_repair [ i ] then
29113: LD_EXP 75
29117: PUSH
29118: LD_VAR 0 2
29122: ARRAY
29123: NOT
29124: IFFALSE 29298
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29126: LD_ADDR_VAR 0 6
29130: PUSH
29131: LD_EXP 93
29135: PUSH
29136: LD_VAR 0 2
29140: ARRAY
29141: PPUSH
29142: LD_INT 3
29144: PUSH
29145: LD_INT 24
29147: PUSH
29148: LD_INT 1000
29150: PUSH
29151: EMPTY
29152: LIST
29153: LIST
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 2
29161: PUSH
29162: LD_INT 34
29164: PUSH
29165: LD_INT 13
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PUSH
29172: LD_INT 34
29174: PUSH
29175: LD_INT 52
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: LIST
29186: PUSH
29187: EMPTY
29188: LIST
29189: LIST
29190: PPUSH
29191: CALL_OW 72
29195: ST_TO_ADDR
// if cranes then
29196: LD_VAR 0 6
29200: IFFALSE 29262
// for j in cranes do
29202: LD_ADDR_VAR 0 3
29206: PUSH
29207: LD_VAR 0 6
29211: PUSH
29212: FOR_IN
29213: IFFALSE 29260
// if not IsInArea ( j , mc_parking [ i ] ) then
29215: LD_VAR 0 3
29219: PPUSH
29220: LD_EXP 98
29224: PUSH
29225: LD_VAR 0 2
29229: ARRAY
29230: PPUSH
29231: CALL_OW 308
29235: NOT
29236: IFFALSE 29258
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29238: LD_VAR 0 3
29242: PPUSH
29243: LD_EXP 98
29247: PUSH
29248: LD_VAR 0 2
29252: ARRAY
29253: PPUSH
29254: CALL_OW 113
29258: GO 29212
29260: POP
29261: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29262: LD_ADDR_EXP 76
29266: PUSH
29267: LD_EXP 76
29271: PPUSH
29272: LD_VAR 0 2
29276: PPUSH
29277: EMPTY
29278: PPUSH
29279: CALL_OW 1
29283: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29284: LD_VAR 0 2
29288: PPUSH
29289: LD_INT 101
29291: PPUSH
29292: CALL 24190 0 2
// continue ;
29296: GO 29110
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29298: LD_ADDR_EXP 80
29302: PUSH
29303: LD_EXP 80
29307: PPUSH
29308: LD_VAR 0 2
29312: PPUSH
29313: EMPTY
29314: PPUSH
29315: CALL_OW 1
29319: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29320: LD_VAR 0 2
29324: PPUSH
29325: LD_INT 103
29327: PPUSH
29328: CALL 24190 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29332: LD_ADDR_VAR 0 5
29336: PUSH
29337: LD_EXP 74
29341: PUSH
29342: LD_VAR 0 2
29346: ARRAY
29347: PUSH
29348: LD_EXP 103
29352: PUSH
29353: LD_VAR 0 2
29357: ARRAY
29358: UNION
29359: PPUSH
29360: LD_INT 2
29362: PUSH
29363: LD_INT 25
29365: PUSH
29366: LD_INT 2
29368: PUSH
29369: EMPTY
29370: LIST
29371: LIST
29372: PUSH
29373: LD_INT 25
29375: PUSH
29376: LD_INT 16
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: LIST
29387: PUSH
29388: EMPTY
29389: LIST
29390: PPUSH
29391: CALL_OW 72
29395: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29396: LD_ADDR_VAR 0 6
29400: PUSH
29401: LD_EXP 93
29405: PUSH
29406: LD_VAR 0 2
29410: ARRAY
29411: PPUSH
29412: LD_INT 2
29414: PUSH
29415: LD_INT 34
29417: PUSH
29418: LD_INT 13
29420: PUSH
29421: EMPTY
29422: LIST
29423: LIST
29424: PUSH
29425: LD_INT 34
29427: PUSH
29428: LD_INT 52
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: EMPTY
29436: LIST
29437: LIST
29438: LIST
29439: PPUSH
29440: CALL_OW 72
29444: ST_TO_ADDR
// if cranes then
29445: LD_VAR 0 6
29449: IFFALSE 29585
// begin for j in cranes do
29451: LD_ADDR_VAR 0 3
29455: PUSH
29456: LD_VAR 0 6
29460: PUSH
29461: FOR_IN
29462: IFFALSE 29583
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29464: LD_VAR 0 3
29468: PPUSH
29469: CALL_OW 256
29473: PUSH
29474: LD_INT 500
29476: GREATEREQUAL
29477: PUSH
29478: LD_VAR 0 3
29482: PPUSH
29483: CALL_OW 314
29487: NOT
29488: AND
29489: IFFALSE 29523
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29491: LD_VAR 0 3
29495: PPUSH
29496: LD_EXP 75
29500: PUSH
29501: LD_VAR 0 2
29505: ARRAY
29506: PPUSH
29507: LD_VAR 0 3
29511: PPUSH
29512: CALL_OW 74
29516: PPUSH
29517: CALL_OW 130
29521: GO 29581
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29523: LD_VAR 0 3
29527: PPUSH
29528: CALL_OW 256
29532: PUSH
29533: LD_INT 500
29535: LESS
29536: PUSH
29537: LD_VAR 0 3
29541: PPUSH
29542: LD_EXP 98
29546: PUSH
29547: LD_VAR 0 2
29551: ARRAY
29552: PPUSH
29553: CALL_OW 308
29557: NOT
29558: AND
29559: IFFALSE 29581
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29561: LD_VAR 0 3
29565: PPUSH
29566: LD_EXP 98
29570: PUSH
29571: LD_VAR 0 2
29575: ARRAY
29576: PPUSH
29577: CALL_OW 113
29581: GO 29461
29583: POP
29584: POP
// end ; if not tmp then
29585: LD_VAR 0 5
29589: NOT
29590: IFFALSE 29594
// continue ;
29592: GO 29110
// for j in tmp do
29594: LD_ADDR_VAR 0 3
29598: PUSH
29599: LD_VAR 0 5
29603: PUSH
29604: FOR_IN
29605: IFFALSE 29799
// begin if mc_need_heal [ i ] then
29607: LD_EXP 77
29611: PUSH
29612: LD_VAR 0 2
29616: ARRAY
29617: IFFALSE 29665
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29619: LD_VAR 0 3
29623: PUSH
29624: LD_EXP 77
29628: PUSH
29629: LD_VAR 0 2
29633: ARRAY
29634: PUSH
29635: LD_INT 1
29637: ARRAY
29638: IN
29639: PUSH
29640: LD_VAR 0 3
29644: PUSH
29645: LD_EXP 77
29649: PUSH
29650: LD_VAR 0 2
29654: ARRAY
29655: PUSH
29656: LD_INT 2
29658: ARRAY
29659: IN
29660: OR
29661: IFFALSE 29665
// continue ;
29663: GO 29604
// if IsInUnit ( j ) then
29665: LD_VAR 0 3
29669: PPUSH
29670: CALL_OW 310
29674: IFFALSE 29685
// ComExitBuilding ( j ) ;
29676: LD_VAR 0 3
29680: PPUSH
29681: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29685: LD_VAR 0 3
29689: PUSH
29690: LD_EXP 76
29694: PUSH
29695: LD_VAR 0 2
29699: ARRAY
29700: IN
29701: NOT
29702: IFFALSE 29760
// begin SetTag ( j , 101 ) ;
29704: LD_VAR 0 3
29708: PPUSH
29709: LD_INT 101
29711: PPUSH
29712: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29716: LD_ADDR_EXP 76
29720: PUSH
29721: LD_EXP 76
29725: PPUSH
29726: LD_VAR 0 2
29730: PUSH
29731: LD_EXP 76
29735: PUSH
29736: LD_VAR 0 2
29740: ARRAY
29741: PUSH
29742: LD_INT 1
29744: PLUS
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PPUSH
29750: LD_VAR 0 3
29754: PPUSH
29755: CALL 56993 0 3
29759: ST_TO_ADDR
// end ; wait ( 1 ) ;
29760: LD_INT 1
29762: PPUSH
29763: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
29767: LD_VAR 0 3
29771: PPUSH
29772: LD_EXP 75
29776: PUSH
29777: LD_VAR 0 2
29781: ARRAY
29782: PPUSH
29783: LD_VAR 0 3
29787: PPUSH
29788: CALL_OW 74
29792: PPUSH
29793: CALL_OW 130
// end ;
29797: GO 29604
29799: POP
29800: POP
// end ;
29801: GO 29110
29803: POP
29804: POP
// end ;
29805: LD_VAR 0 1
29809: RET
// export function MC_Heal ; var i , j , tmp ; begin
29810: LD_INT 0
29812: PPUSH
29813: PPUSH
29814: PPUSH
29815: PPUSH
// if not mc_bases then
29816: LD_EXP 74
29820: NOT
29821: IFFALSE 29825
// exit ;
29823: GO 30227
// for i = 1 to mc_bases do
29825: LD_ADDR_VAR 0 2
29829: PUSH
29830: DOUBLE
29831: LD_INT 1
29833: DEC
29834: ST_TO_ADDR
29835: LD_EXP 74
29839: PUSH
29840: FOR_TO
29841: IFFALSE 30225
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
29843: LD_EXP 77
29847: PUSH
29848: LD_VAR 0 2
29852: ARRAY
29853: PUSH
29854: LD_INT 1
29856: ARRAY
29857: NOT
29858: PUSH
29859: LD_EXP 77
29863: PUSH
29864: LD_VAR 0 2
29868: ARRAY
29869: PUSH
29870: LD_INT 2
29872: ARRAY
29873: NOT
29874: AND
29875: IFFALSE 29913
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
29877: LD_ADDR_EXP 78
29881: PUSH
29882: LD_EXP 78
29886: PPUSH
29887: LD_VAR 0 2
29891: PPUSH
29892: EMPTY
29893: PPUSH
29894: CALL_OW 1
29898: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
29899: LD_VAR 0 2
29903: PPUSH
29904: LD_INT 102
29906: PPUSH
29907: CALL 24190 0 2
// continue ;
29911: GO 29840
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
29913: LD_ADDR_VAR 0 4
29917: PUSH
29918: LD_EXP 74
29922: PUSH
29923: LD_VAR 0 2
29927: ARRAY
29928: PPUSH
29929: LD_INT 25
29931: PUSH
29932: LD_INT 4
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PPUSH
29939: CALL_OW 72
29943: ST_TO_ADDR
// if not tmp then
29944: LD_VAR 0 4
29948: NOT
29949: IFFALSE 29953
// continue ;
29951: GO 29840
// if mc_taming [ i ] then
29953: LD_EXP 105
29957: PUSH
29958: LD_VAR 0 2
29962: ARRAY
29963: IFFALSE 29987
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
29965: LD_ADDR_EXP 105
29969: PUSH
29970: LD_EXP 105
29974: PPUSH
29975: LD_VAR 0 2
29979: PPUSH
29980: EMPTY
29981: PPUSH
29982: CALL_OW 1
29986: ST_TO_ADDR
// for j in tmp do
29987: LD_ADDR_VAR 0 3
29991: PUSH
29992: LD_VAR 0 4
29996: PUSH
29997: FOR_IN
29998: IFFALSE 30221
// begin if IsInUnit ( j ) then
30000: LD_VAR 0 3
30004: PPUSH
30005: CALL_OW 310
30009: IFFALSE 30020
// ComExitBuilding ( j ) ;
30011: LD_VAR 0 3
30015: PPUSH
30016: CALL_OW 122
// if not j in mc_healers [ i ] then
30020: LD_VAR 0 3
30024: PUSH
30025: LD_EXP 78
30029: PUSH
30030: LD_VAR 0 2
30034: ARRAY
30035: IN
30036: NOT
30037: IFFALSE 30083
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30039: LD_ADDR_EXP 78
30043: PUSH
30044: LD_EXP 78
30048: PPUSH
30049: LD_VAR 0 2
30053: PUSH
30054: LD_EXP 78
30058: PUSH
30059: LD_VAR 0 2
30063: ARRAY
30064: PUSH
30065: LD_INT 1
30067: PLUS
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PPUSH
30073: LD_VAR 0 3
30077: PPUSH
30078: CALL 56993 0 3
30082: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30083: LD_VAR 0 3
30087: PPUSH
30088: CALL_OW 110
30092: PUSH
30093: LD_INT 102
30095: NONEQUAL
30096: IFFALSE 30110
// SetTag ( j , 102 ) ;
30098: LD_VAR 0 3
30102: PPUSH
30103: LD_INT 102
30105: PPUSH
30106: CALL_OW 109
// Wait ( 3 ) ;
30110: LD_INT 3
30112: PPUSH
30113: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30117: LD_EXP 77
30121: PUSH
30122: LD_VAR 0 2
30126: ARRAY
30127: PUSH
30128: LD_INT 1
30130: ARRAY
30131: IFFALSE 30163
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30133: LD_VAR 0 3
30137: PPUSH
30138: LD_EXP 77
30142: PUSH
30143: LD_VAR 0 2
30147: ARRAY
30148: PUSH
30149: LD_INT 1
30151: ARRAY
30152: PUSH
30153: LD_INT 1
30155: ARRAY
30156: PPUSH
30157: CALL_OW 128
30161: GO 30219
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30163: LD_VAR 0 3
30167: PPUSH
30168: CALL_OW 314
30172: NOT
30173: PUSH
30174: LD_EXP 77
30178: PUSH
30179: LD_VAR 0 2
30183: ARRAY
30184: PUSH
30185: LD_INT 2
30187: ARRAY
30188: AND
30189: IFFALSE 30219
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30191: LD_VAR 0 3
30195: PPUSH
30196: LD_EXP 77
30200: PUSH
30201: LD_VAR 0 2
30205: ARRAY
30206: PUSH
30207: LD_INT 2
30209: ARRAY
30210: PUSH
30211: LD_INT 1
30213: ARRAY
30214: PPUSH
30215: CALL_OW 128
// end ;
30219: GO 29997
30221: POP
30222: POP
// end ;
30223: GO 29840
30225: POP
30226: POP
// end ;
30227: LD_VAR 0 1
30231: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30232: LD_INT 0
30234: PPUSH
30235: PPUSH
30236: PPUSH
30237: PPUSH
30238: PPUSH
// if not mc_bases then
30239: LD_EXP 74
30243: NOT
30244: IFFALSE 30248
// exit ;
30246: GO 31391
// for i = 1 to mc_bases do
30248: LD_ADDR_VAR 0 2
30252: PUSH
30253: DOUBLE
30254: LD_INT 1
30256: DEC
30257: ST_TO_ADDR
30258: LD_EXP 74
30262: PUSH
30263: FOR_TO
30264: IFFALSE 31389
// begin if mc_scan [ i ] then
30266: LD_EXP 97
30270: PUSH
30271: LD_VAR 0 2
30275: ARRAY
30276: IFFALSE 30280
// continue ;
30278: GO 30263
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30280: LD_EXP 79
30284: PUSH
30285: LD_VAR 0 2
30289: ARRAY
30290: NOT
30291: PUSH
30292: LD_EXP 81
30296: PUSH
30297: LD_VAR 0 2
30301: ARRAY
30302: NOT
30303: AND
30304: PUSH
30305: LD_EXP 80
30309: PUSH
30310: LD_VAR 0 2
30314: ARRAY
30315: AND
30316: IFFALSE 30354
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30318: LD_ADDR_EXP 80
30322: PUSH
30323: LD_EXP 80
30327: PPUSH
30328: LD_VAR 0 2
30332: PPUSH
30333: EMPTY
30334: PPUSH
30335: CALL_OW 1
30339: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30340: LD_VAR 0 2
30344: PPUSH
30345: LD_INT 103
30347: PPUSH
30348: CALL 24190 0 2
// continue ;
30352: GO 30263
// end ; if mc_construct_list [ i ] then
30354: LD_EXP 81
30358: PUSH
30359: LD_VAR 0 2
30363: ARRAY
30364: IFFALSE 30584
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30366: LD_ADDR_VAR 0 4
30370: PUSH
30371: LD_EXP 74
30375: PUSH
30376: LD_VAR 0 2
30380: ARRAY
30381: PPUSH
30382: LD_INT 25
30384: PUSH
30385: LD_INT 2
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PPUSH
30392: CALL_OW 72
30396: PUSH
30397: LD_EXP 76
30401: PUSH
30402: LD_VAR 0 2
30406: ARRAY
30407: DIFF
30408: ST_TO_ADDR
// if not tmp then
30409: LD_VAR 0 4
30413: NOT
30414: IFFALSE 30418
// continue ;
30416: GO 30263
// for j in tmp do
30418: LD_ADDR_VAR 0 3
30422: PUSH
30423: LD_VAR 0 4
30427: PUSH
30428: FOR_IN
30429: IFFALSE 30580
// begin if not mc_builders [ i ] then
30431: LD_EXP 80
30435: PUSH
30436: LD_VAR 0 2
30440: ARRAY
30441: NOT
30442: IFFALSE 30500
// begin SetTag ( j , 103 ) ;
30444: LD_VAR 0 3
30448: PPUSH
30449: LD_INT 103
30451: PPUSH
30452: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30456: LD_ADDR_EXP 80
30460: PUSH
30461: LD_EXP 80
30465: PPUSH
30466: LD_VAR 0 2
30470: PUSH
30471: LD_EXP 80
30475: PUSH
30476: LD_VAR 0 2
30480: ARRAY
30481: PUSH
30482: LD_INT 1
30484: PLUS
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PPUSH
30490: LD_VAR 0 3
30494: PPUSH
30495: CALL 56993 0 3
30499: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30500: LD_VAR 0 3
30504: PPUSH
30505: CALL_OW 310
30509: IFFALSE 30520
// ComExitBuilding ( j ) ;
30511: LD_VAR 0 3
30515: PPUSH
30516: CALL_OW 122
// wait ( 3 ) ;
30520: LD_INT 3
30522: PPUSH
30523: CALL_OW 67
// if not mc_construct_list [ i ] then
30527: LD_EXP 81
30531: PUSH
30532: LD_VAR 0 2
30536: ARRAY
30537: NOT
30538: IFFALSE 30542
// break ;
30540: GO 30580
// if not HasTask ( j ) then
30542: LD_VAR 0 3
30546: PPUSH
30547: CALL_OW 314
30551: NOT
30552: IFFALSE 30578
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30554: LD_VAR 0 3
30558: PPUSH
30559: LD_EXP 81
30563: PUSH
30564: LD_VAR 0 2
30568: ARRAY
30569: PUSH
30570: LD_INT 1
30572: ARRAY
30573: PPUSH
30574: CALL 59844 0 2
// end ;
30578: GO 30428
30580: POP
30581: POP
// end else
30582: GO 31387
// if mc_build_list [ i ] then
30584: LD_EXP 79
30588: PUSH
30589: LD_VAR 0 2
30593: ARRAY
30594: IFFALSE 31387
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30596: LD_ADDR_VAR 0 5
30600: PUSH
30601: LD_EXP 74
30605: PUSH
30606: LD_VAR 0 2
30610: ARRAY
30611: PPUSH
30612: LD_INT 2
30614: PUSH
30615: LD_INT 30
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 30
30627: PUSH
30628: LD_INT 1
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: LIST
30639: PPUSH
30640: CALL_OW 72
30644: ST_TO_ADDR
// if depot then
30645: LD_VAR 0 5
30649: IFFALSE 30667
// depot := depot [ 1 ] else
30651: LD_ADDR_VAR 0 5
30655: PUSH
30656: LD_VAR 0 5
30660: PUSH
30661: LD_INT 1
30663: ARRAY
30664: ST_TO_ADDR
30665: GO 30675
// depot := 0 ;
30667: LD_ADDR_VAR 0 5
30671: PUSH
30672: LD_INT 0
30674: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
30675: LD_EXP 79
30679: PUSH
30680: LD_VAR 0 2
30684: ARRAY
30685: PUSH
30686: LD_INT 1
30688: ARRAY
30689: PUSH
30690: LD_INT 1
30692: ARRAY
30693: PPUSH
30694: CALL 59674 0 1
30698: PUSH
30699: LD_EXP 74
30703: PUSH
30704: LD_VAR 0 2
30708: ARRAY
30709: PPUSH
30710: LD_INT 2
30712: PUSH
30713: LD_INT 30
30715: PUSH
30716: LD_INT 2
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 30
30725: PUSH
30726: LD_INT 3
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: LIST
30737: PPUSH
30738: CALL_OW 72
30742: NOT
30743: AND
30744: IFFALSE 30849
// begin for j = 1 to mc_build_list [ i ] do
30746: LD_ADDR_VAR 0 3
30750: PUSH
30751: DOUBLE
30752: LD_INT 1
30754: DEC
30755: ST_TO_ADDR
30756: LD_EXP 79
30760: PUSH
30761: LD_VAR 0 2
30765: ARRAY
30766: PUSH
30767: FOR_TO
30768: IFFALSE 30847
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
30770: LD_EXP 79
30774: PUSH
30775: LD_VAR 0 2
30779: ARRAY
30780: PUSH
30781: LD_VAR 0 3
30785: ARRAY
30786: PUSH
30787: LD_INT 1
30789: ARRAY
30790: PUSH
30791: LD_INT 2
30793: EQUAL
30794: IFFALSE 30845
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
30796: LD_ADDR_EXP 79
30800: PUSH
30801: LD_EXP 79
30805: PPUSH
30806: LD_VAR 0 2
30810: PPUSH
30811: LD_EXP 79
30815: PUSH
30816: LD_VAR 0 2
30820: ARRAY
30821: PPUSH
30822: LD_VAR 0 3
30826: PPUSH
30827: LD_INT 1
30829: PPUSH
30830: LD_INT 0
30832: PPUSH
30833: CALL 56411 0 4
30837: PPUSH
30838: CALL_OW 1
30842: ST_TO_ADDR
// break ;
30843: GO 30847
// end ;
30845: GO 30767
30847: POP
30848: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
30849: LD_EXP 79
30853: PUSH
30854: LD_VAR 0 2
30858: ARRAY
30859: PUSH
30860: LD_INT 1
30862: ARRAY
30863: PUSH
30864: LD_INT 1
30866: ARRAY
30867: PUSH
30868: LD_INT 0
30870: EQUAL
30871: PUSH
30872: LD_VAR 0 5
30876: PUSH
30877: LD_VAR 0 5
30881: PPUSH
30882: LD_EXP 79
30886: PUSH
30887: LD_VAR 0 2
30891: ARRAY
30892: PUSH
30893: LD_INT 1
30895: ARRAY
30896: PUSH
30897: LD_INT 1
30899: ARRAY
30900: PPUSH
30901: LD_EXP 79
30905: PUSH
30906: LD_VAR 0 2
30910: ARRAY
30911: PUSH
30912: LD_INT 1
30914: ARRAY
30915: PUSH
30916: LD_INT 2
30918: ARRAY
30919: PPUSH
30920: LD_EXP 79
30924: PUSH
30925: LD_VAR 0 2
30929: ARRAY
30930: PUSH
30931: LD_INT 1
30933: ARRAY
30934: PUSH
30935: LD_INT 3
30937: ARRAY
30938: PPUSH
30939: LD_EXP 79
30943: PUSH
30944: LD_VAR 0 2
30948: ARRAY
30949: PUSH
30950: LD_INT 1
30952: ARRAY
30953: PUSH
30954: LD_INT 4
30956: ARRAY
30957: PPUSH
30958: CALL 64408 0 5
30962: AND
30963: OR
30964: IFFALSE 31245
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30966: LD_ADDR_VAR 0 4
30970: PUSH
30971: LD_EXP 74
30975: PUSH
30976: LD_VAR 0 2
30980: ARRAY
30981: PPUSH
30982: LD_INT 25
30984: PUSH
30985: LD_INT 2
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PPUSH
30992: CALL_OW 72
30996: PUSH
30997: LD_EXP 76
31001: PUSH
31002: LD_VAR 0 2
31006: ARRAY
31007: DIFF
31008: ST_TO_ADDR
// if not tmp then
31009: LD_VAR 0 4
31013: NOT
31014: IFFALSE 31018
// continue ;
31016: GO 30263
// for j in tmp do
31018: LD_ADDR_VAR 0 3
31022: PUSH
31023: LD_VAR 0 4
31027: PUSH
31028: FOR_IN
31029: IFFALSE 31241
// begin if not mc_builders [ i ] then
31031: LD_EXP 80
31035: PUSH
31036: LD_VAR 0 2
31040: ARRAY
31041: NOT
31042: IFFALSE 31100
// begin SetTag ( j , 103 ) ;
31044: LD_VAR 0 3
31048: PPUSH
31049: LD_INT 103
31051: PPUSH
31052: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31056: LD_ADDR_EXP 80
31060: PUSH
31061: LD_EXP 80
31065: PPUSH
31066: LD_VAR 0 2
31070: PUSH
31071: LD_EXP 80
31075: PUSH
31076: LD_VAR 0 2
31080: ARRAY
31081: PUSH
31082: LD_INT 1
31084: PLUS
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PPUSH
31090: LD_VAR 0 3
31094: PPUSH
31095: CALL 56993 0 3
31099: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31100: LD_VAR 0 3
31104: PPUSH
31105: CALL_OW 310
31109: IFFALSE 31120
// ComExitBuilding ( j ) ;
31111: LD_VAR 0 3
31115: PPUSH
31116: CALL_OW 122
// wait ( 3 ) ;
31120: LD_INT 3
31122: PPUSH
31123: CALL_OW 67
// if not mc_build_list [ i ] then
31127: LD_EXP 79
31131: PUSH
31132: LD_VAR 0 2
31136: ARRAY
31137: NOT
31138: IFFALSE 31142
// break ;
31140: GO 31241
// if not HasTask ( j ) then
31142: LD_VAR 0 3
31146: PPUSH
31147: CALL_OW 314
31151: NOT
31152: IFFALSE 31239
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31154: LD_VAR 0 3
31158: PPUSH
31159: LD_EXP 79
31163: PUSH
31164: LD_VAR 0 2
31168: ARRAY
31169: PUSH
31170: LD_INT 1
31172: ARRAY
31173: PUSH
31174: LD_INT 1
31176: ARRAY
31177: PPUSH
31178: LD_EXP 79
31182: PUSH
31183: LD_VAR 0 2
31187: ARRAY
31188: PUSH
31189: LD_INT 1
31191: ARRAY
31192: PUSH
31193: LD_INT 2
31195: ARRAY
31196: PPUSH
31197: LD_EXP 79
31201: PUSH
31202: LD_VAR 0 2
31206: ARRAY
31207: PUSH
31208: LD_INT 1
31210: ARRAY
31211: PUSH
31212: LD_INT 3
31214: ARRAY
31215: PPUSH
31216: LD_EXP 79
31220: PUSH
31221: LD_VAR 0 2
31225: ARRAY
31226: PUSH
31227: LD_INT 1
31229: ARRAY
31230: PUSH
31231: LD_INT 4
31233: ARRAY
31234: PPUSH
31235: CALL_OW 145
// end ;
31239: GO 31028
31241: POP
31242: POP
// end else
31243: GO 31387
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31245: LD_EXP 74
31249: PUSH
31250: LD_VAR 0 2
31254: ARRAY
31255: PPUSH
31256: LD_EXP 79
31260: PUSH
31261: LD_VAR 0 2
31265: ARRAY
31266: PUSH
31267: LD_INT 1
31269: ARRAY
31270: PUSH
31271: LD_INT 1
31273: ARRAY
31274: PPUSH
31275: LD_EXP 79
31279: PUSH
31280: LD_VAR 0 2
31284: ARRAY
31285: PUSH
31286: LD_INT 1
31288: ARRAY
31289: PUSH
31290: LD_INT 2
31292: ARRAY
31293: PPUSH
31294: LD_EXP 79
31298: PUSH
31299: LD_VAR 0 2
31303: ARRAY
31304: PUSH
31305: LD_INT 1
31307: ARRAY
31308: PUSH
31309: LD_INT 3
31311: ARRAY
31312: PPUSH
31313: LD_EXP 79
31317: PUSH
31318: LD_VAR 0 2
31322: ARRAY
31323: PUSH
31324: LD_INT 1
31326: ARRAY
31327: PUSH
31328: LD_INT 4
31330: ARRAY
31331: PPUSH
31332: CALL 63744 0 5
31336: NOT
31337: IFFALSE 31387
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31339: LD_ADDR_EXP 79
31343: PUSH
31344: LD_EXP 79
31348: PPUSH
31349: LD_VAR 0 2
31353: PPUSH
31354: LD_EXP 79
31358: PUSH
31359: LD_VAR 0 2
31363: ARRAY
31364: PPUSH
31365: LD_INT 1
31367: PPUSH
31368: LD_INT 1
31370: NEG
31371: PPUSH
31372: LD_INT 0
31374: PPUSH
31375: CALL 56411 0 4
31379: PPUSH
31380: CALL_OW 1
31384: ST_TO_ADDR
// continue ;
31385: GO 30263
// end ; end ; end ;
31387: GO 30263
31389: POP
31390: POP
// end ;
31391: LD_VAR 0 1
31395: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31396: LD_INT 0
31398: PPUSH
31399: PPUSH
31400: PPUSH
31401: PPUSH
31402: PPUSH
31403: PPUSH
// if not mc_bases then
31404: LD_EXP 74
31408: NOT
31409: IFFALSE 31413
// exit ;
31411: GO 31840
// for i = 1 to mc_bases do
31413: LD_ADDR_VAR 0 2
31417: PUSH
31418: DOUBLE
31419: LD_INT 1
31421: DEC
31422: ST_TO_ADDR
31423: LD_EXP 74
31427: PUSH
31428: FOR_TO
31429: IFFALSE 31838
// begin tmp := mc_build_upgrade [ i ] ;
31431: LD_ADDR_VAR 0 4
31435: PUSH
31436: LD_EXP 106
31440: PUSH
31441: LD_VAR 0 2
31445: ARRAY
31446: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31447: LD_ADDR_VAR 0 6
31451: PUSH
31452: LD_EXP 107
31456: PUSH
31457: LD_VAR 0 2
31461: ARRAY
31462: PPUSH
31463: LD_INT 2
31465: PUSH
31466: LD_INT 30
31468: PUSH
31469: LD_INT 6
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 30
31478: PUSH
31479: LD_INT 7
31481: PUSH
31482: EMPTY
31483: LIST
31484: LIST
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: LIST
31490: PPUSH
31491: CALL_OW 72
31495: ST_TO_ADDR
// if not tmp and not lab then
31496: LD_VAR 0 4
31500: NOT
31501: PUSH
31502: LD_VAR 0 6
31506: NOT
31507: AND
31508: IFFALSE 31512
// continue ;
31510: GO 31428
// if tmp then
31512: LD_VAR 0 4
31516: IFFALSE 31636
// for j in tmp do
31518: LD_ADDR_VAR 0 3
31522: PUSH
31523: LD_VAR 0 4
31527: PUSH
31528: FOR_IN
31529: IFFALSE 31634
// begin if UpgradeCost ( j ) then
31531: LD_VAR 0 3
31535: PPUSH
31536: CALL 63404 0 1
31540: IFFALSE 31632
// begin ComUpgrade ( j ) ;
31542: LD_VAR 0 3
31546: PPUSH
31547: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31551: LD_ADDR_EXP 106
31555: PUSH
31556: LD_EXP 106
31560: PPUSH
31561: LD_VAR 0 2
31565: PPUSH
31566: LD_EXP 106
31570: PUSH
31571: LD_VAR 0 2
31575: ARRAY
31576: PUSH
31577: LD_VAR 0 3
31581: DIFF
31582: PPUSH
31583: CALL_OW 1
31587: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31588: LD_ADDR_EXP 81
31592: PUSH
31593: LD_EXP 81
31597: PPUSH
31598: LD_VAR 0 2
31602: PUSH
31603: LD_EXP 81
31607: PUSH
31608: LD_VAR 0 2
31612: ARRAY
31613: PUSH
31614: LD_INT 1
31616: PLUS
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PPUSH
31622: LD_VAR 0 3
31626: PPUSH
31627: CALL 56993 0 3
31631: ST_TO_ADDR
// end ; end ;
31632: GO 31528
31634: POP
31635: POP
// if not lab or not mc_lab_upgrade [ i ] then
31636: LD_VAR 0 6
31640: NOT
31641: PUSH
31642: LD_EXP 108
31646: PUSH
31647: LD_VAR 0 2
31651: ARRAY
31652: NOT
31653: OR
31654: IFFALSE 31658
// continue ;
31656: GO 31428
// for j in lab do
31658: LD_ADDR_VAR 0 3
31662: PUSH
31663: LD_VAR 0 6
31667: PUSH
31668: FOR_IN
31669: IFFALSE 31834
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
31671: LD_VAR 0 3
31675: PPUSH
31676: CALL_OW 266
31680: PUSH
31681: LD_INT 6
31683: PUSH
31684: LD_INT 7
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: IN
31691: PUSH
31692: LD_VAR 0 3
31696: PPUSH
31697: CALL_OW 461
31701: PUSH
31702: LD_INT 1
31704: NONEQUAL
31705: AND
31706: IFFALSE 31832
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
31708: LD_VAR 0 3
31712: PPUSH
31713: LD_EXP 108
31717: PUSH
31718: LD_VAR 0 2
31722: ARRAY
31723: PUSH
31724: LD_INT 1
31726: ARRAY
31727: PPUSH
31728: CALL 63609 0 2
31732: IFFALSE 31832
// begin ComCancel ( j ) ;
31734: LD_VAR 0 3
31738: PPUSH
31739: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
31743: LD_VAR 0 3
31747: PPUSH
31748: LD_EXP 108
31752: PUSH
31753: LD_VAR 0 2
31757: ARRAY
31758: PUSH
31759: LD_INT 1
31761: ARRAY
31762: PPUSH
31763: CALL_OW 207
// if not j in mc_construct_list [ i ] then
31767: LD_VAR 0 3
31771: PUSH
31772: LD_EXP 81
31776: PUSH
31777: LD_VAR 0 2
31781: ARRAY
31782: IN
31783: NOT
31784: IFFALSE 31830
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31786: LD_ADDR_EXP 81
31790: PUSH
31791: LD_EXP 81
31795: PPUSH
31796: LD_VAR 0 2
31800: PUSH
31801: LD_EXP 81
31805: PUSH
31806: LD_VAR 0 2
31810: ARRAY
31811: PUSH
31812: LD_INT 1
31814: PLUS
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PPUSH
31820: LD_VAR 0 3
31824: PPUSH
31825: CALL 56993 0 3
31829: ST_TO_ADDR
// break ;
31830: GO 31834
// end ; end ; end ;
31832: GO 31668
31834: POP
31835: POP
// end ;
31836: GO 31428
31838: POP
31839: POP
// end ;
31840: LD_VAR 0 1
31844: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
31845: LD_INT 0
31847: PPUSH
31848: PPUSH
31849: PPUSH
31850: PPUSH
31851: PPUSH
31852: PPUSH
31853: PPUSH
31854: PPUSH
31855: PPUSH
// if not mc_bases then
31856: LD_EXP 74
31860: NOT
31861: IFFALSE 31865
// exit ;
31863: GO 32270
// for i = 1 to mc_bases do
31865: LD_ADDR_VAR 0 2
31869: PUSH
31870: DOUBLE
31871: LD_INT 1
31873: DEC
31874: ST_TO_ADDR
31875: LD_EXP 74
31879: PUSH
31880: FOR_TO
31881: IFFALSE 32268
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
31883: LD_EXP 82
31887: PUSH
31888: LD_VAR 0 2
31892: ARRAY
31893: NOT
31894: PUSH
31895: LD_EXP 74
31899: PUSH
31900: LD_VAR 0 2
31904: ARRAY
31905: PPUSH
31906: LD_INT 30
31908: PUSH
31909: LD_INT 3
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PPUSH
31916: CALL_OW 72
31920: NOT
31921: OR
31922: IFFALSE 31926
// continue ;
31924: GO 31880
// busy := false ;
31926: LD_ADDR_VAR 0 8
31930: PUSH
31931: LD_INT 0
31933: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
31934: LD_ADDR_VAR 0 4
31938: PUSH
31939: LD_EXP 74
31943: PUSH
31944: LD_VAR 0 2
31948: ARRAY
31949: PPUSH
31950: LD_INT 30
31952: PUSH
31953: LD_INT 3
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PPUSH
31960: CALL_OW 72
31964: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
31965: LD_ADDR_VAR 0 6
31969: PUSH
31970: LD_EXP 82
31974: PUSH
31975: LD_VAR 0 2
31979: ARRAY
31980: PPUSH
31981: LD_INT 2
31983: PUSH
31984: LD_INT 30
31986: PUSH
31987: LD_INT 32
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: LD_INT 30
31996: PUSH
31997: LD_INT 33
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: EMPTY
32005: LIST
32006: LIST
32007: LIST
32008: PPUSH
32009: CALL_OW 72
32013: ST_TO_ADDR
// if not t then
32014: LD_VAR 0 6
32018: NOT
32019: IFFALSE 32023
// continue ;
32021: GO 31880
// for j in tmp do
32023: LD_ADDR_VAR 0 3
32027: PUSH
32028: LD_VAR 0 4
32032: PUSH
32033: FOR_IN
32034: IFFALSE 32064
// if not BuildingStatus ( j ) = bs_idle then
32036: LD_VAR 0 3
32040: PPUSH
32041: CALL_OW 461
32045: PUSH
32046: LD_INT 2
32048: EQUAL
32049: NOT
32050: IFFALSE 32062
// begin busy := true ;
32052: LD_ADDR_VAR 0 8
32056: PUSH
32057: LD_INT 1
32059: ST_TO_ADDR
// break ;
32060: GO 32064
// end ;
32062: GO 32033
32064: POP
32065: POP
// if busy then
32066: LD_VAR 0 8
32070: IFFALSE 32074
// continue ;
32072: GO 31880
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32074: LD_ADDR_VAR 0 7
32078: PUSH
32079: LD_VAR 0 6
32083: PPUSH
32084: LD_INT 35
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PPUSH
32094: CALL_OW 72
32098: ST_TO_ADDR
// if tw then
32099: LD_VAR 0 7
32103: IFFALSE 32180
// begin tw := tw [ 1 ] ;
32105: LD_ADDR_VAR 0 7
32109: PUSH
32110: LD_VAR 0 7
32114: PUSH
32115: LD_INT 1
32117: ARRAY
32118: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32119: LD_ADDR_VAR 0 9
32123: PUSH
32124: LD_VAR 0 7
32128: PPUSH
32129: LD_EXP 99
32133: PUSH
32134: LD_VAR 0 2
32138: ARRAY
32139: PPUSH
32140: CALL 61963 0 2
32144: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32145: LD_EXP 113
32149: PUSH
32150: LD_VAR 0 2
32154: ARRAY
32155: IFFALSE 32178
// if not weapon in mc_allowed_tower_weapons [ i ] then
32157: LD_VAR 0 9
32161: PUSH
32162: LD_EXP 113
32166: PUSH
32167: LD_VAR 0 2
32171: ARRAY
32172: IN
32173: NOT
32174: IFFALSE 32178
// continue ;
32176: GO 31880
// end else
32178: GO 32243
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32180: LD_ADDR_VAR 0 5
32184: PUSH
32185: LD_EXP 82
32189: PUSH
32190: LD_VAR 0 2
32194: ARRAY
32195: PPUSH
32196: LD_VAR 0 4
32200: PPUSH
32201: CALL 92164 0 2
32205: ST_TO_ADDR
// if not tmp2 then
32206: LD_VAR 0 5
32210: NOT
32211: IFFALSE 32215
// continue ;
32213: GO 31880
// tw := tmp2 [ 1 ] ;
32215: LD_ADDR_VAR 0 7
32219: PUSH
32220: LD_VAR 0 5
32224: PUSH
32225: LD_INT 1
32227: ARRAY
32228: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32229: LD_ADDR_VAR 0 9
32233: PUSH
32234: LD_VAR 0 5
32238: PUSH
32239: LD_INT 2
32241: ARRAY
32242: ST_TO_ADDR
// end ; if not weapon then
32243: LD_VAR 0 9
32247: NOT
32248: IFFALSE 32252
// continue ;
32250: GO 31880
// ComPlaceWeapon ( tw , weapon ) ;
32252: LD_VAR 0 7
32256: PPUSH
32257: LD_VAR 0 9
32261: PPUSH
32262: CALL_OW 148
// end ;
32266: GO 31880
32268: POP
32269: POP
// end ;
32270: LD_VAR 0 1
32274: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32275: LD_INT 0
32277: PPUSH
32278: PPUSH
32279: PPUSH
32280: PPUSH
32281: PPUSH
32282: PPUSH
// if not mc_bases then
32283: LD_EXP 74
32287: NOT
32288: IFFALSE 32292
// exit ;
32290: GO 33304
// for i = 1 to mc_bases do
32292: LD_ADDR_VAR 0 2
32296: PUSH
32297: DOUBLE
32298: LD_INT 1
32300: DEC
32301: ST_TO_ADDR
32302: LD_EXP 74
32306: PUSH
32307: FOR_TO
32308: IFFALSE 33302
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
32310: LD_EXP 87
32314: PUSH
32315: LD_VAR 0 2
32319: ARRAY
32320: NOT
32321: PUSH
32322: LD_EXP 87
32326: PUSH
32327: LD_VAR 0 2
32331: ARRAY
32332: PUSH
32333: LD_EXP 88
32337: PUSH
32338: LD_VAR 0 2
32342: ARRAY
32343: EQUAL
32344: OR
32345: IFFALSE 32349
// continue ;
32347: GO 32307
// if mc_miners [ i ] then
32349: LD_EXP 88
32353: PUSH
32354: LD_VAR 0 2
32358: ARRAY
32359: IFFALSE 32989
// begin k := 1 ;
32361: LD_ADDR_VAR 0 4
32365: PUSH
32366: LD_INT 1
32368: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
32369: LD_ADDR_VAR 0 3
32373: PUSH
32374: DOUBLE
32375: LD_EXP 88
32379: PUSH
32380: LD_VAR 0 2
32384: ARRAY
32385: INC
32386: ST_TO_ADDR
32387: LD_INT 1
32389: PUSH
32390: FOR_DOWNTO
32391: IFFALSE 32987
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32393: LD_EXP 88
32397: PUSH
32398: LD_VAR 0 2
32402: ARRAY
32403: PUSH
32404: LD_VAR 0 3
32408: ARRAY
32409: PPUSH
32410: CALL_OW 301
32414: PUSH
32415: LD_EXP 88
32419: PUSH
32420: LD_VAR 0 2
32424: ARRAY
32425: PUSH
32426: LD_VAR 0 3
32430: ARRAY
32431: PPUSH
32432: CALL_OW 257
32436: PUSH
32437: LD_INT 1
32439: NONEQUAL
32440: OR
32441: IFFALSE 32504
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32443: LD_ADDR_VAR 0 5
32447: PUSH
32448: LD_EXP 88
32452: PUSH
32453: LD_VAR 0 2
32457: ARRAY
32458: PUSH
32459: LD_EXP 88
32463: PUSH
32464: LD_VAR 0 2
32468: ARRAY
32469: PUSH
32470: LD_VAR 0 3
32474: ARRAY
32475: DIFF
32476: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
32477: LD_ADDR_EXP 88
32481: PUSH
32482: LD_EXP 88
32486: PPUSH
32487: LD_VAR 0 2
32491: PPUSH
32492: LD_VAR 0 5
32496: PPUSH
32497: CALL_OW 1
32501: ST_TO_ADDR
// continue ;
32502: GO 32390
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
32504: LD_EXP 88
32508: PUSH
32509: LD_VAR 0 2
32513: ARRAY
32514: PUSH
32515: LD_VAR 0 3
32519: ARRAY
32520: PPUSH
32521: CALL 56929 0 1
32525: PUSH
32526: LD_EXP 88
32530: PUSH
32531: LD_VAR 0 2
32535: ARRAY
32536: PUSH
32537: LD_VAR 0 3
32541: ARRAY
32542: PPUSH
32543: CALL_OW 255
32547: PPUSH
32548: LD_EXP 87
32552: PUSH
32553: LD_VAR 0 2
32557: ARRAY
32558: PUSH
32559: LD_VAR 0 4
32563: ARRAY
32564: PUSH
32565: LD_INT 1
32567: ARRAY
32568: PPUSH
32569: LD_EXP 87
32573: PUSH
32574: LD_VAR 0 2
32578: ARRAY
32579: PUSH
32580: LD_VAR 0 4
32584: ARRAY
32585: PUSH
32586: LD_INT 2
32588: ARRAY
32589: PPUSH
32590: LD_INT 15
32592: PPUSH
32593: CALL 57889 0 4
32597: PUSH
32598: LD_INT 4
32600: ARRAY
32601: PUSH
32602: LD_EXP 88
32606: PUSH
32607: LD_VAR 0 2
32611: ARRAY
32612: PUSH
32613: LD_VAR 0 3
32617: ARRAY
32618: PPUSH
32619: LD_INT 10
32621: PPUSH
32622: CALL 59586 0 2
32626: PUSH
32627: LD_INT 4
32629: ARRAY
32630: OR
32631: AND
32632: IFFALSE 32655
// ComStop ( mc_miners [ i ] [ j ] ) ;
32634: LD_EXP 88
32638: PUSH
32639: LD_VAR 0 2
32643: ARRAY
32644: PUSH
32645: LD_VAR 0 3
32649: ARRAY
32650: PPUSH
32651: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
32655: LD_EXP 88
32659: PUSH
32660: LD_VAR 0 2
32664: ARRAY
32665: PUSH
32666: LD_VAR 0 3
32670: ARRAY
32671: PPUSH
32672: CALL_OW 257
32676: PUSH
32677: LD_INT 1
32679: EQUAL
32680: PUSH
32681: LD_EXP 88
32685: PUSH
32686: LD_VAR 0 2
32690: ARRAY
32691: PUSH
32692: LD_VAR 0 3
32696: ARRAY
32697: PPUSH
32698: CALL_OW 459
32702: NOT
32703: AND
32704: PUSH
32705: LD_EXP 88
32709: PUSH
32710: LD_VAR 0 2
32714: ARRAY
32715: PUSH
32716: LD_VAR 0 3
32720: ARRAY
32721: PPUSH
32722: CALL_OW 255
32726: PPUSH
32727: LD_EXP 87
32731: PUSH
32732: LD_VAR 0 2
32736: ARRAY
32737: PUSH
32738: LD_VAR 0 4
32742: ARRAY
32743: PUSH
32744: LD_INT 1
32746: ARRAY
32747: PPUSH
32748: LD_EXP 87
32752: PUSH
32753: LD_VAR 0 2
32757: ARRAY
32758: PUSH
32759: LD_VAR 0 4
32763: ARRAY
32764: PUSH
32765: LD_INT 2
32767: ARRAY
32768: PPUSH
32769: LD_INT 15
32771: PPUSH
32772: CALL 57889 0 4
32776: PUSH
32777: LD_INT 4
32779: ARRAY
32780: PUSH
32781: LD_INT 0
32783: EQUAL
32784: AND
32785: PUSH
32786: LD_EXP 88
32790: PUSH
32791: LD_VAR 0 2
32795: ARRAY
32796: PUSH
32797: LD_VAR 0 3
32801: ARRAY
32802: PPUSH
32803: CALL_OW 314
32807: NOT
32808: AND
32809: IFFALSE 32985
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32811: LD_EXP 88
32815: PUSH
32816: LD_VAR 0 2
32820: ARRAY
32821: PUSH
32822: LD_VAR 0 3
32826: ARRAY
32827: PPUSH
32828: CALL_OW 310
32832: IFFALSE 32855
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32834: LD_EXP 88
32838: PUSH
32839: LD_VAR 0 2
32843: ARRAY
32844: PUSH
32845: LD_VAR 0 3
32849: ARRAY
32850: PPUSH
32851: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
32855: LD_EXP 88
32859: PUSH
32860: LD_VAR 0 2
32864: ARRAY
32865: PUSH
32866: LD_VAR 0 3
32870: ARRAY
32871: PPUSH
32872: CALL_OW 314
32876: NOT
32877: IFFALSE 32945
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
32879: LD_EXP 88
32883: PUSH
32884: LD_VAR 0 2
32888: ARRAY
32889: PUSH
32890: LD_VAR 0 3
32894: ARRAY
32895: PPUSH
32896: LD_EXP 87
32900: PUSH
32901: LD_VAR 0 2
32905: ARRAY
32906: PUSH
32907: LD_VAR 0 4
32911: ARRAY
32912: PUSH
32913: LD_INT 1
32915: ARRAY
32916: PPUSH
32917: LD_EXP 87
32921: PUSH
32922: LD_VAR 0 2
32926: ARRAY
32927: PUSH
32928: LD_VAR 0 4
32932: ARRAY
32933: PUSH
32934: LD_INT 2
32936: ARRAY
32937: PPUSH
32938: LD_INT 0
32940: PPUSH
32941: CALL_OW 193
// k := k + 1 ;
32945: LD_ADDR_VAR 0 4
32949: PUSH
32950: LD_VAR 0 4
32954: PUSH
32955: LD_INT 1
32957: PLUS
32958: ST_TO_ADDR
// if k > mc_mines [ i ] then
32959: LD_VAR 0 4
32963: PUSH
32964: LD_EXP 87
32968: PUSH
32969: LD_VAR 0 2
32973: ARRAY
32974: GREATER
32975: IFFALSE 32985
// k := 1 ;
32977: LD_ADDR_VAR 0 4
32981: PUSH
32982: LD_INT 1
32984: ST_TO_ADDR
// end ; end ;
32985: GO 32390
32987: POP
32988: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
32989: LD_ADDR_VAR 0 5
32993: PUSH
32994: LD_EXP 74
32998: PUSH
32999: LD_VAR 0 2
33003: ARRAY
33004: PPUSH
33005: LD_INT 2
33007: PUSH
33008: LD_INT 30
33010: PUSH
33011: LD_INT 4
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 30
33020: PUSH
33021: LD_INT 5
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 30
33030: PUSH
33031: LD_INT 32
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: EMPTY
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: PPUSH
33044: CALL_OW 72
33048: ST_TO_ADDR
// if not tmp then
33049: LD_VAR 0 5
33053: NOT
33054: IFFALSE 33058
// continue ;
33056: GO 32307
// list := [ ] ;
33058: LD_ADDR_VAR 0 6
33062: PUSH
33063: EMPTY
33064: ST_TO_ADDR
// for j in tmp do
33065: LD_ADDR_VAR 0 3
33069: PUSH
33070: LD_VAR 0 5
33074: PUSH
33075: FOR_IN
33076: IFFALSE 33145
// begin for k in UnitsInside ( j ) do
33078: LD_ADDR_VAR 0 4
33082: PUSH
33083: LD_VAR 0 3
33087: PPUSH
33088: CALL_OW 313
33092: PUSH
33093: FOR_IN
33094: IFFALSE 33141
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33096: LD_VAR 0 4
33100: PPUSH
33101: CALL_OW 257
33105: PUSH
33106: LD_INT 1
33108: EQUAL
33109: PUSH
33110: LD_VAR 0 4
33114: PPUSH
33115: CALL_OW 459
33119: NOT
33120: AND
33121: IFFALSE 33139
// list := list ^ k ;
33123: LD_ADDR_VAR 0 6
33127: PUSH
33128: LD_VAR 0 6
33132: PUSH
33133: LD_VAR 0 4
33137: ADD
33138: ST_TO_ADDR
33139: GO 33093
33141: POP
33142: POP
// end ;
33143: GO 33075
33145: POP
33146: POP
// list := list diff mc_miners [ i ] ;
33147: LD_ADDR_VAR 0 6
33151: PUSH
33152: LD_VAR 0 6
33156: PUSH
33157: LD_EXP 88
33161: PUSH
33162: LD_VAR 0 2
33166: ARRAY
33167: DIFF
33168: ST_TO_ADDR
// if not list then
33169: LD_VAR 0 6
33173: NOT
33174: IFFALSE 33178
// continue ;
33176: GO 32307
// k := mc_mines [ i ] - mc_miners [ i ] ;
33178: LD_ADDR_VAR 0 4
33182: PUSH
33183: LD_EXP 87
33187: PUSH
33188: LD_VAR 0 2
33192: ARRAY
33193: PUSH
33194: LD_EXP 88
33198: PUSH
33199: LD_VAR 0 2
33203: ARRAY
33204: MINUS
33205: ST_TO_ADDR
// if k > list then
33206: LD_VAR 0 4
33210: PUSH
33211: LD_VAR 0 6
33215: GREATER
33216: IFFALSE 33228
// k := list ;
33218: LD_ADDR_VAR 0 4
33222: PUSH
33223: LD_VAR 0 6
33227: ST_TO_ADDR
// for j = 1 to k do
33228: LD_ADDR_VAR 0 3
33232: PUSH
33233: DOUBLE
33234: LD_INT 1
33236: DEC
33237: ST_TO_ADDR
33238: LD_VAR 0 4
33242: PUSH
33243: FOR_TO
33244: IFFALSE 33298
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33246: LD_ADDR_EXP 88
33250: PUSH
33251: LD_EXP 88
33255: PPUSH
33256: LD_VAR 0 2
33260: PUSH
33261: LD_EXP 88
33265: PUSH
33266: LD_VAR 0 2
33270: ARRAY
33271: PUSH
33272: LD_INT 1
33274: PLUS
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PPUSH
33280: LD_VAR 0 6
33284: PUSH
33285: LD_VAR 0 3
33289: ARRAY
33290: PPUSH
33291: CALL 56993 0 3
33295: ST_TO_ADDR
33296: GO 33243
33298: POP
33299: POP
// end ;
33300: GO 32307
33302: POP
33303: POP
// end ;
33304: LD_VAR 0 1
33308: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33309: LD_INT 0
33311: PPUSH
33312: PPUSH
33313: PPUSH
33314: PPUSH
33315: PPUSH
33316: PPUSH
33317: PPUSH
33318: PPUSH
33319: PPUSH
33320: PPUSH
// if not mc_bases then
33321: LD_EXP 74
33325: NOT
33326: IFFALSE 33330
// exit ;
33328: GO 35080
// for i = 1 to mc_bases do
33330: LD_ADDR_VAR 0 2
33334: PUSH
33335: DOUBLE
33336: LD_INT 1
33338: DEC
33339: ST_TO_ADDR
33340: LD_EXP 74
33344: PUSH
33345: FOR_TO
33346: IFFALSE 35078
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33348: LD_EXP 74
33352: PUSH
33353: LD_VAR 0 2
33357: ARRAY
33358: NOT
33359: PUSH
33360: LD_EXP 81
33364: PUSH
33365: LD_VAR 0 2
33369: ARRAY
33370: OR
33371: IFFALSE 33375
// continue ;
33373: GO 33345
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33375: LD_EXP 90
33379: PUSH
33380: LD_VAR 0 2
33384: ARRAY
33385: NOT
33386: PUSH
33387: LD_EXP 91
33391: PUSH
33392: LD_VAR 0 2
33396: ARRAY
33397: AND
33398: IFFALSE 33436
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33400: LD_ADDR_EXP 91
33404: PUSH
33405: LD_EXP 91
33409: PPUSH
33410: LD_VAR 0 2
33414: PPUSH
33415: EMPTY
33416: PPUSH
33417: CALL_OW 1
33421: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33422: LD_VAR 0 2
33426: PPUSH
33427: LD_INT 107
33429: PPUSH
33430: CALL 24190 0 2
// continue ;
33434: GO 33345
// end ; target := [ ] ;
33436: LD_ADDR_VAR 0 6
33440: PUSH
33441: EMPTY
33442: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33443: LD_ADDR_VAR 0 3
33447: PUSH
33448: DOUBLE
33449: LD_EXP 90
33453: PUSH
33454: LD_VAR 0 2
33458: ARRAY
33459: INC
33460: ST_TO_ADDR
33461: LD_INT 1
33463: PUSH
33464: FOR_DOWNTO
33465: IFFALSE 33725
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33467: LD_EXP 90
33471: PUSH
33472: LD_VAR 0 2
33476: ARRAY
33477: PUSH
33478: LD_VAR 0 3
33482: ARRAY
33483: PUSH
33484: LD_INT 2
33486: ARRAY
33487: PPUSH
33488: LD_EXP 90
33492: PUSH
33493: LD_VAR 0 2
33497: ARRAY
33498: PUSH
33499: LD_VAR 0 3
33503: ARRAY
33504: PUSH
33505: LD_INT 3
33507: ARRAY
33508: PPUSH
33509: CALL_OW 488
33513: PUSH
33514: LD_EXP 90
33518: PUSH
33519: LD_VAR 0 2
33523: ARRAY
33524: PUSH
33525: LD_VAR 0 3
33529: ARRAY
33530: PUSH
33531: LD_INT 2
33533: ARRAY
33534: PPUSH
33535: LD_EXP 90
33539: PUSH
33540: LD_VAR 0 2
33544: ARRAY
33545: PUSH
33546: LD_VAR 0 3
33550: ARRAY
33551: PUSH
33552: LD_INT 3
33554: ARRAY
33555: PPUSH
33556: CALL_OW 284
33560: PUSH
33561: LD_INT 0
33563: EQUAL
33564: AND
33565: IFFALSE 33620
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33567: LD_ADDR_VAR 0 5
33571: PUSH
33572: LD_EXP 90
33576: PUSH
33577: LD_VAR 0 2
33581: ARRAY
33582: PPUSH
33583: LD_VAR 0 3
33587: PPUSH
33588: CALL_OW 3
33592: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33593: LD_ADDR_EXP 90
33597: PUSH
33598: LD_EXP 90
33602: PPUSH
33603: LD_VAR 0 2
33607: PPUSH
33608: LD_VAR 0 5
33612: PPUSH
33613: CALL_OW 1
33617: ST_TO_ADDR
// continue ;
33618: GO 33464
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33620: LD_EXP 74
33624: PUSH
33625: LD_VAR 0 2
33629: ARRAY
33630: PUSH
33631: LD_INT 1
33633: ARRAY
33634: PPUSH
33635: CALL_OW 255
33639: PPUSH
33640: LD_EXP 90
33644: PUSH
33645: LD_VAR 0 2
33649: ARRAY
33650: PUSH
33651: LD_VAR 0 3
33655: ARRAY
33656: PUSH
33657: LD_INT 2
33659: ARRAY
33660: PPUSH
33661: LD_EXP 90
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: PUSH
33672: LD_VAR 0 3
33676: ARRAY
33677: PUSH
33678: LD_INT 3
33680: ARRAY
33681: PPUSH
33682: LD_INT 30
33684: PPUSH
33685: CALL 57889 0 4
33689: PUSH
33690: LD_INT 4
33692: ARRAY
33693: PUSH
33694: LD_INT 0
33696: EQUAL
33697: IFFALSE 33723
// begin target := mc_crates [ i ] [ j ] ;
33699: LD_ADDR_VAR 0 6
33703: PUSH
33704: LD_EXP 90
33708: PUSH
33709: LD_VAR 0 2
33713: ARRAY
33714: PUSH
33715: LD_VAR 0 3
33719: ARRAY
33720: ST_TO_ADDR
// break ;
33721: GO 33725
// end ; end ;
33723: GO 33464
33725: POP
33726: POP
// if not target then
33727: LD_VAR 0 6
33731: NOT
33732: IFFALSE 33736
// continue ;
33734: GO 33345
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33736: LD_ADDR_VAR 0 7
33740: PUSH
33741: LD_EXP 93
33745: PUSH
33746: LD_VAR 0 2
33750: ARRAY
33751: PPUSH
33752: LD_INT 2
33754: PUSH
33755: LD_INT 3
33757: PUSH
33758: LD_INT 58
33760: PUSH
33761: EMPTY
33762: LIST
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 61
33770: PUSH
33771: EMPTY
33772: LIST
33773: PUSH
33774: LD_INT 33
33776: PUSH
33777: LD_INT 5
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 33
33786: PUSH
33787: LD_INT 3
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: LIST
33798: LIST
33799: LIST
33800: PUSH
33801: LD_INT 2
33803: PUSH
33804: LD_INT 34
33806: PUSH
33807: LD_INT 32
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: LD_INT 34
33816: PUSH
33817: LD_INT 51
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: PUSH
33824: LD_INT 34
33826: PUSH
33827: LD_INT 12
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PPUSH
33844: CALL_OW 72
33848: ST_TO_ADDR
// if not cargo then
33849: LD_VAR 0 7
33853: NOT
33854: IFFALSE 34497
// begin if mc_crates_collector [ i ] < 5 then
33856: LD_EXP 91
33860: PUSH
33861: LD_VAR 0 2
33865: ARRAY
33866: PUSH
33867: LD_INT 5
33869: LESS
33870: IFFALSE 34236
// begin if mc_ape [ i ] then
33872: LD_EXP 103
33876: PUSH
33877: LD_VAR 0 2
33881: ARRAY
33882: IFFALSE 33929
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
33884: LD_ADDR_VAR 0 5
33888: PUSH
33889: LD_EXP 103
33893: PUSH
33894: LD_VAR 0 2
33898: ARRAY
33899: PPUSH
33900: LD_INT 25
33902: PUSH
33903: LD_INT 16
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: LD_INT 24
33912: PUSH
33913: LD_INT 750
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PPUSH
33924: CALL_OW 72
33928: ST_TO_ADDR
// if not tmp then
33929: LD_VAR 0 5
33933: NOT
33934: IFFALSE 33981
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
33936: LD_ADDR_VAR 0 5
33940: PUSH
33941: LD_EXP 74
33945: PUSH
33946: LD_VAR 0 2
33950: ARRAY
33951: PPUSH
33952: LD_INT 25
33954: PUSH
33955: LD_INT 2
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 24
33964: PUSH
33965: LD_INT 750
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: EMPTY
33973: LIST
33974: LIST
33975: PPUSH
33976: CALL_OW 72
33980: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
33981: LD_EXP 103
33985: PUSH
33986: LD_VAR 0 2
33990: ARRAY
33991: PUSH
33992: LD_EXP 74
33996: PUSH
33997: LD_VAR 0 2
34001: ARRAY
34002: PPUSH
34003: LD_INT 25
34005: PUSH
34006: LD_INT 2
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 24
34015: PUSH
34016: LD_INT 750
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PPUSH
34027: CALL_OW 72
34031: AND
34032: PUSH
34033: LD_VAR 0 5
34037: PUSH
34038: LD_INT 5
34040: LESS
34041: AND
34042: IFFALSE 34124
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34044: LD_ADDR_VAR 0 3
34048: PUSH
34049: LD_EXP 74
34053: PUSH
34054: LD_VAR 0 2
34058: ARRAY
34059: PPUSH
34060: LD_INT 25
34062: PUSH
34063: LD_INT 2
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 24
34072: PUSH
34073: LD_INT 750
34075: PUSH
34076: EMPTY
34077: LIST
34078: LIST
34079: PUSH
34080: EMPTY
34081: LIST
34082: LIST
34083: PPUSH
34084: CALL_OW 72
34088: PUSH
34089: FOR_IN
34090: IFFALSE 34122
// begin tmp := tmp union j ;
34092: LD_ADDR_VAR 0 5
34096: PUSH
34097: LD_VAR 0 5
34101: PUSH
34102: LD_VAR 0 3
34106: UNION
34107: ST_TO_ADDR
// if tmp >= 5 then
34108: LD_VAR 0 5
34112: PUSH
34113: LD_INT 5
34115: GREATEREQUAL
34116: IFFALSE 34120
// break ;
34118: GO 34122
// end ;
34120: GO 34089
34122: POP
34123: POP
// end ; if not tmp then
34124: LD_VAR 0 5
34128: NOT
34129: IFFALSE 34133
// continue ;
34131: GO 33345
// for j in tmp do
34133: LD_ADDR_VAR 0 3
34137: PUSH
34138: LD_VAR 0 5
34142: PUSH
34143: FOR_IN
34144: IFFALSE 34234
// if not GetTag ( j ) then
34146: LD_VAR 0 3
34150: PPUSH
34151: CALL_OW 110
34155: NOT
34156: IFFALSE 34232
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34158: LD_ADDR_EXP 91
34162: PUSH
34163: LD_EXP 91
34167: PPUSH
34168: LD_VAR 0 2
34172: PUSH
34173: LD_EXP 91
34177: PUSH
34178: LD_VAR 0 2
34182: ARRAY
34183: PUSH
34184: LD_INT 1
34186: PLUS
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PPUSH
34192: LD_VAR 0 3
34196: PPUSH
34197: CALL 56993 0 3
34201: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34202: LD_VAR 0 3
34206: PPUSH
34207: LD_INT 107
34209: PPUSH
34210: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34214: LD_EXP 91
34218: PUSH
34219: LD_VAR 0 2
34223: ARRAY
34224: PUSH
34225: LD_INT 5
34227: GREATEREQUAL
34228: IFFALSE 34232
// break ;
34230: GO 34234
// end ;
34232: GO 34143
34234: POP
34235: POP
// end ; if mc_crates_collector [ i ] and target then
34236: LD_EXP 91
34240: PUSH
34241: LD_VAR 0 2
34245: ARRAY
34246: PUSH
34247: LD_VAR 0 6
34251: AND
34252: IFFALSE 34495
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34254: LD_EXP 91
34258: PUSH
34259: LD_VAR 0 2
34263: ARRAY
34264: PUSH
34265: LD_VAR 0 6
34269: PUSH
34270: LD_INT 1
34272: ARRAY
34273: LESS
34274: IFFALSE 34294
// tmp := mc_crates_collector [ i ] else
34276: LD_ADDR_VAR 0 5
34280: PUSH
34281: LD_EXP 91
34285: PUSH
34286: LD_VAR 0 2
34290: ARRAY
34291: ST_TO_ADDR
34292: GO 34308
// tmp := target [ 1 ] ;
34294: LD_ADDR_VAR 0 5
34298: PUSH
34299: LD_VAR 0 6
34303: PUSH
34304: LD_INT 1
34306: ARRAY
34307: ST_TO_ADDR
// k := 0 ;
34308: LD_ADDR_VAR 0 4
34312: PUSH
34313: LD_INT 0
34315: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34316: LD_ADDR_VAR 0 3
34320: PUSH
34321: LD_EXP 91
34325: PUSH
34326: LD_VAR 0 2
34330: ARRAY
34331: PUSH
34332: FOR_IN
34333: IFFALSE 34493
// begin k := k + 1 ;
34335: LD_ADDR_VAR 0 4
34339: PUSH
34340: LD_VAR 0 4
34344: PUSH
34345: LD_INT 1
34347: PLUS
34348: ST_TO_ADDR
// if k > tmp then
34349: LD_VAR 0 4
34353: PUSH
34354: LD_VAR 0 5
34358: GREATER
34359: IFFALSE 34363
// break ;
34361: GO 34493
// if not GetClass ( j ) in [ 2 , 16 ] then
34363: LD_VAR 0 3
34367: PPUSH
34368: CALL_OW 257
34372: PUSH
34373: LD_INT 2
34375: PUSH
34376: LD_INT 16
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: IN
34383: NOT
34384: IFFALSE 34437
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34386: LD_ADDR_EXP 91
34390: PUSH
34391: LD_EXP 91
34395: PPUSH
34396: LD_VAR 0 2
34400: PPUSH
34401: LD_EXP 91
34405: PUSH
34406: LD_VAR 0 2
34410: ARRAY
34411: PUSH
34412: LD_VAR 0 3
34416: DIFF
34417: PPUSH
34418: CALL_OW 1
34422: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34423: LD_VAR 0 3
34427: PPUSH
34428: LD_INT 0
34430: PPUSH
34431: CALL_OW 109
// continue ;
34435: GO 34332
// end ; if IsInUnit ( j ) then
34437: LD_VAR 0 3
34441: PPUSH
34442: CALL_OW 310
34446: IFFALSE 34457
// ComExitBuilding ( j ) ;
34448: LD_VAR 0 3
34452: PPUSH
34453: CALL_OW 122
// wait ( 3 ) ;
34457: LD_INT 3
34459: PPUSH
34460: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34464: LD_VAR 0 3
34468: PPUSH
34469: LD_VAR 0 6
34473: PUSH
34474: LD_INT 2
34476: ARRAY
34477: PPUSH
34478: LD_VAR 0 6
34482: PUSH
34483: LD_INT 3
34485: ARRAY
34486: PPUSH
34487: CALL_OW 117
// end ;
34491: GO 34332
34493: POP
34494: POP
// end ; end else
34495: GO 35076
// begin for j in cargo do
34497: LD_ADDR_VAR 0 3
34501: PUSH
34502: LD_VAR 0 7
34506: PUSH
34507: FOR_IN
34508: IFFALSE 35074
// begin if GetTag ( j ) <> 0 then
34510: LD_VAR 0 3
34514: PPUSH
34515: CALL_OW 110
34519: PUSH
34520: LD_INT 0
34522: NONEQUAL
34523: IFFALSE 34527
// continue ;
34525: GO 34507
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34527: LD_VAR 0 3
34531: PPUSH
34532: CALL_OW 256
34536: PUSH
34537: LD_INT 1000
34539: LESS
34540: PUSH
34541: LD_VAR 0 3
34545: PPUSH
34546: LD_EXP 98
34550: PUSH
34551: LD_VAR 0 2
34555: ARRAY
34556: PPUSH
34557: CALL_OW 308
34561: NOT
34562: AND
34563: IFFALSE 34585
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34565: LD_VAR 0 3
34569: PPUSH
34570: LD_EXP 98
34574: PUSH
34575: LD_VAR 0 2
34579: ARRAY
34580: PPUSH
34581: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34585: LD_VAR 0 3
34589: PPUSH
34590: CALL_OW 256
34594: PUSH
34595: LD_INT 1000
34597: LESS
34598: PUSH
34599: LD_VAR 0 3
34603: PPUSH
34604: LD_EXP 98
34608: PUSH
34609: LD_VAR 0 2
34613: ARRAY
34614: PPUSH
34615: CALL_OW 308
34619: AND
34620: IFFALSE 34624
// continue ;
34622: GO 34507
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34624: LD_VAR 0 3
34628: PPUSH
34629: CALL_OW 262
34633: PUSH
34634: LD_INT 2
34636: EQUAL
34637: PUSH
34638: LD_VAR 0 3
34642: PPUSH
34643: CALL_OW 261
34647: PUSH
34648: LD_INT 15
34650: LESS
34651: AND
34652: IFFALSE 34656
// continue ;
34654: GO 34507
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34656: LD_VAR 0 3
34660: PPUSH
34661: CALL_OW 262
34665: PUSH
34666: LD_INT 1
34668: EQUAL
34669: PUSH
34670: LD_VAR 0 3
34674: PPUSH
34675: CALL_OW 261
34679: PUSH
34680: LD_INT 10
34682: LESS
34683: AND
34684: IFFALSE 35013
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34686: LD_ADDR_VAR 0 8
34690: PUSH
34691: LD_EXP 74
34695: PUSH
34696: LD_VAR 0 2
34700: ARRAY
34701: PPUSH
34702: LD_INT 2
34704: PUSH
34705: LD_INT 30
34707: PUSH
34708: LD_INT 0
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 30
34717: PUSH
34718: LD_INT 1
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: LIST
34729: PPUSH
34730: CALL_OW 72
34734: ST_TO_ADDR
// if not depot then
34735: LD_VAR 0 8
34739: NOT
34740: IFFALSE 34744
// continue ;
34742: GO 34507
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34744: LD_VAR 0 3
34748: PPUSH
34749: LD_VAR 0 8
34753: PPUSH
34754: LD_VAR 0 3
34758: PPUSH
34759: CALL_OW 74
34763: PPUSH
34764: CALL_OW 296
34768: PUSH
34769: LD_INT 6
34771: LESS
34772: IFFALSE 34788
// SetFuel ( j , 100 ) else
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 100
34781: PPUSH
34782: CALL_OW 240
34786: GO 35013
// if GetFuel ( j ) = 0 then
34788: LD_VAR 0 3
34792: PPUSH
34793: CALL_OW 261
34797: PUSH
34798: LD_INT 0
34800: EQUAL
34801: IFFALSE 35013
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34803: LD_ADDR_EXP 93
34807: PUSH
34808: LD_EXP 93
34812: PPUSH
34813: LD_VAR 0 2
34817: PPUSH
34818: LD_EXP 93
34822: PUSH
34823: LD_VAR 0 2
34827: ARRAY
34828: PUSH
34829: LD_VAR 0 3
34833: DIFF
34834: PPUSH
34835: CALL_OW 1
34839: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34840: LD_VAR 0 3
34844: PPUSH
34845: CALL_OW 263
34849: PUSH
34850: LD_INT 1
34852: EQUAL
34853: IFFALSE 34869
// ComExitVehicle ( IsInUnit ( j ) ) ;
34855: LD_VAR 0 3
34859: PPUSH
34860: CALL_OW 310
34864: PPUSH
34865: CALL_OW 121
// if GetControl ( j ) = control_remote then
34869: LD_VAR 0 3
34873: PPUSH
34874: CALL_OW 263
34878: PUSH
34879: LD_INT 2
34881: EQUAL
34882: IFFALSE 34893
// ComUnlink ( j ) ;
34884: LD_VAR 0 3
34888: PPUSH
34889: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
34893: LD_ADDR_VAR 0 9
34897: PUSH
34898: LD_VAR 0 2
34902: PPUSH
34903: LD_INT 3
34905: PPUSH
34906: CALL 44150 0 2
34910: ST_TO_ADDR
// if fac then
34911: LD_VAR 0 9
34915: IFFALSE 35011
// begin for k in fac do
34917: LD_ADDR_VAR 0 4
34921: PUSH
34922: LD_VAR 0 9
34926: PUSH
34927: FOR_IN
34928: IFFALSE 35009
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
34930: LD_ADDR_VAR 0 10
34934: PUSH
34935: LD_VAR 0 9
34939: PPUSH
34940: LD_VAR 0 3
34944: PPUSH
34945: CALL_OW 265
34949: PPUSH
34950: LD_VAR 0 3
34954: PPUSH
34955: CALL_OW 262
34959: PPUSH
34960: LD_VAR 0 3
34964: PPUSH
34965: CALL_OW 263
34969: PPUSH
34970: LD_VAR 0 3
34974: PPUSH
34975: CALL_OW 264
34979: PPUSH
34980: CALL 54525 0 5
34984: ST_TO_ADDR
// if components then
34985: LD_VAR 0 10
34989: IFFALSE 35007
// begin MC_InsertProduceList ( i , components ) ;
34991: LD_VAR 0 2
34995: PPUSH
34996: LD_VAR 0 10
35000: PPUSH
35001: CALL 43695 0 2
// break ;
35005: GO 35009
// end ; end ;
35007: GO 34927
35009: POP
35010: POP
// end ; continue ;
35011: GO 34507
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35013: LD_VAR 0 3
35017: PPUSH
35018: LD_INT 1
35020: PPUSH
35021: CALL_OW 289
35025: PUSH
35026: LD_INT 100
35028: LESS
35029: PUSH
35030: LD_VAR 0 3
35034: PPUSH
35035: CALL_OW 314
35039: NOT
35040: AND
35041: IFFALSE 35070
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35043: LD_VAR 0 3
35047: PPUSH
35048: LD_VAR 0 6
35052: PUSH
35053: LD_INT 2
35055: ARRAY
35056: PPUSH
35057: LD_VAR 0 6
35061: PUSH
35062: LD_INT 3
35064: ARRAY
35065: PPUSH
35066: CALL_OW 117
// break ;
35070: GO 35074
// end ;
35072: GO 34507
35074: POP
35075: POP
// end ; end ;
35076: GO 33345
35078: POP
35079: POP
// end ;
35080: LD_VAR 0 1
35084: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35085: LD_INT 0
35087: PPUSH
35088: PPUSH
35089: PPUSH
35090: PPUSH
// if not mc_bases then
35091: LD_EXP 74
35095: NOT
35096: IFFALSE 35100
// exit ;
35098: GO 35261
// for i = 1 to mc_bases do
35100: LD_ADDR_VAR 0 2
35104: PUSH
35105: DOUBLE
35106: LD_INT 1
35108: DEC
35109: ST_TO_ADDR
35110: LD_EXP 74
35114: PUSH
35115: FOR_TO
35116: IFFALSE 35259
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35118: LD_ADDR_VAR 0 4
35122: PUSH
35123: LD_EXP 93
35127: PUSH
35128: LD_VAR 0 2
35132: ARRAY
35133: PUSH
35134: LD_EXP 96
35138: PUSH
35139: LD_VAR 0 2
35143: ARRAY
35144: UNION
35145: PPUSH
35146: LD_INT 33
35148: PUSH
35149: LD_INT 2
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PPUSH
35156: CALL_OW 72
35160: ST_TO_ADDR
// if tmp then
35161: LD_VAR 0 4
35165: IFFALSE 35257
// for j in tmp do
35167: LD_ADDR_VAR 0 3
35171: PUSH
35172: LD_VAR 0 4
35176: PUSH
35177: FOR_IN
35178: IFFALSE 35255
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35180: LD_VAR 0 3
35184: PPUSH
35185: CALL_OW 312
35189: NOT
35190: PUSH
35191: LD_VAR 0 3
35195: PPUSH
35196: CALL_OW 256
35200: PUSH
35201: LD_INT 250
35203: GREATEREQUAL
35204: AND
35205: IFFALSE 35218
// Connect ( j ) else
35207: LD_VAR 0 3
35211: PPUSH
35212: CALL 59926 0 1
35216: GO 35253
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35218: LD_VAR 0 3
35222: PPUSH
35223: CALL_OW 256
35227: PUSH
35228: LD_INT 250
35230: LESS
35231: PUSH
35232: LD_VAR 0 3
35236: PPUSH
35237: CALL_OW 312
35241: AND
35242: IFFALSE 35253
// ComUnlink ( j ) ;
35244: LD_VAR 0 3
35248: PPUSH
35249: CALL_OW 136
35253: GO 35177
35255: POP
35256: POP
// end ;
35257: GO 35115
35259: POP
35260: POP
// end ;
35261: LD_VAR 0 1
35265: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35266: LD_INT 0
35268: PPUSH
35269: PPUSH
35270: PPUSH
35271: PPUSH
35272: PPUSH
// if not mc_bases then
35273: LD_EXP 74
35277: NOT
35278: IFFALSE 35282
// exit ;
35280: GO 35727
// for i = 1 to mc_bases do
35282: LD_ADDR_VAR 0 2
35286: PUSH
35287: DOUBLE
35288: LD_INT 1
35290: DEC
35291: ST_TO_ADDR
35292: LD_EXP 74
35296: PUSH
35297: FOR_TO
35298: IFFALSE 35725
// begin if not mc_produce [ i ] then
35300: LD_EXP 95
35304: PUSH
35305: LD_VAR 0 2
35309: ARRAY
35310: NOT
35311: IFFALSE 35315
// continue ;
35313: GO 35297
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35315: LD_ADDR_VAR 0 5
35319: PUSH
35320: LD_EXP 74
35324: PUSH
35325: LD_VAR 0 2
35329: ARRAY
35330: PPUSH
35331: LD_INT 30
35333: PUSH
35334: LD_INT 3
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PPUSH
35341: CALL_OW 72
35345: ST_TO_ADDR
// if not fac then
35346: LD_VAR 0 5
35350: NOT
35351: IFFALSE 35355
// continue ;
35353: GO 35297
// for j in fac do
35355: LD_ADDR_VAR 0 3
35359: PUSH
35360: LD_VAR 0 5
35364: PUSH
35365: FOR_IN
35366: IFFALSE 35721
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35368: LD_VAR 0 3
35372: PPUSH
35373: CALL_OW 461
35377: PUSH
35378: LD_INT 2
35380: NONEQUAL
35381: PUSH
35382: LD_VAR 0 3
35386: PPUSH
35387: LD_INT 15
35389: PPUSH
35390: CALL 59586 0 2
35394: PUSH
35395: LD_INT 4
35397: ARRAY
35398: OR
35399: IFFALSE 35403
// continue ;
35401: GO 35365
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35403: LD_VAR 0 3
35407: PPUSH
35408: LD_EXP 95
35412: PUSH
35413: LD_VAR 0 2
35417: ARRAY
35418: PUSH
35419: LD_INT 1
35421: ARRAY
35422: PUSH
35423: LD_INT 1
35425: ARRAY
35426: PPUSH
35427: LD_EXP 95
35431: PUSH
35432: LD_VAR 0 2
35436: ARRAY
35437: PUSH
35438: LD_INT 1
35440: ARRAY
35441: PUSH
35442: LD_INT 2
35444: ARRAY
35445: PPUSH
35446: LD_EXP 95
35450: PUSH
35451: LD_VAR 0 2
35455: ARRAY
35456: PUSH
35457: LD_INT 1
35459: ARRAY
35460: PUSH
35461: LD_INT 3
35463: ARRAY
35464: PPUSH
35465: LD_EXP 95
35469: PUSH
35470: LD_VAR 0 2
35474: ARRAY
35475: PUSH
35476: LD_INT 1
35478: ARRAY
35479: PUSH
35480: LD_INT 4
35482: ARRAY
35483: PPUSH
35484: CALL_OW 448
35488: PUSH
35489: LD_VAR 0 3
35493: PPUSH
35494: LD_EXP 95
35498: PUSH
35499: LD_VAR 0 2
35503: ARRAY
35504: PUSH
35505: LD_INT 1
35507: ARRAY
35508: PUSH
35509: LD_INT 1
35511: ARRAY
35512: PUSH
35513: LD_EXP 95
35517: PUSH
35518: LD_VAR 0 2
35522: ARRAY
35523: PUSH
35524: LD_INT 1
35526: ARRAY
35527: PUSH
35528: LD_INT 2
35530: ARRAY
35531: PUSH
35532: LD_EXP 95
35536: PUSH
35537: LD_VAR 0 2
35541: ARRAY
35542: PUSH
35543: LD_INT 1
35545: ARRAY
35546: PUSH
35547: LD_INT 3
35549: ARRAY
35550: PUSH
35551: LD_EXP 95
35555: PUSH
35556: LD_VAR 0 2
35560: ARRAY
35561: PUSH
35562: LD_INT 1
35564: ARRAY
35565: PUSH
35566: LD_INT 4
35568: ARRAY
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: PPUSH
35576: CALL 63257 0 2
35580: AND
35581: IFFALSE 35719
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35583: LD_VAR 0 3
35587: PPUSH
35588: LD_EXP 95
35592: PUSH
35593: LD_VAR 0 2
35597: ARRAY
35598: PUSH
35599: LD_INT 1
35601: ARRAY
35602: PUSH
35603: LD_INT 1
35605: ARRAY
35606: PPUSH
35607: LD_EXP 95
35611: PUSH
35612: LD_VAR 0 2
35616: ARRAY
35617: PUSH
35618: LD_INT 1
35620: ARRAY
35621: PUSH
35622: LD_INT 2
35624: ARRAY
35625: PPUSH
35626: LD_EXP 95
35630: PUSH
35631: LD_VAR 0 2
35635: ARRAY
35636: PUSH
35637: LD_INT 1
35639: ARRAY
35640: PUSH
35641: LD_INT 3
35643: ARRAY
35644: PPUSH
35645: LD_EXP 95
35649: PUSH
35650: LD_VAR 0 2
35654: ARRAY
35655: PUSH
35656: LD_INT 1
35658: ARRAY
35659: PUSH
35660: LD_INT 4
35662: ARRAY
35663: PPUSH
35664: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35668: LD_ADDR_VAR 0 4
35672: PUSH
35673: LD_EXP 95
35677: PUSH
35678: LD_VAR 0 2
35682: ARRAY
35683: PPUSH
35684: LD_INT 1
35686: PPUSH
35687: CALL_OW 3
35691: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35692: LD_ADDR_EXP 95
35696: PUSH
35697: LD_EXP 95
35701: PPUSH
35702: LD_VAR 0 2
35706: PPUSH
35707: LD_VAR 0 4
35711: PPUSH
35712: CALL_OW 1
35716: ST_TO_ADDR
// break ;
35717: GO 35721
// end ; end ;
35719: GO 35365
35721: POP
35722: POP
// end ;
35723: GO 35297
35725: POP
35726: POP
// end ;
35727: LD_VAR 0 1
35731: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35732: LD_INT 0
35734: PPUSH
35735: PPUSH
35736: PPUSH
// if not mc_bases then
35737: LD_EXP 74
35741: NOT
35742: IFFALSE 35746
// exit ;
35744: GO 35835
// for i = 1 to mc_bases do
35746: LD_ADDR_VAR 0 2
35750: PUSH
35751: DOUBLE
35752: LD_INT 1
35754: DEC
35755: ST_TO_ADDR
35756: LD_EXP 74
35760: PUSH
35761: FOR_TO
35762: IFFALSE 35833
// begin if mc_attack [ i ] then
35764: LD_EXP 94
35768: PUSH
35769: LD_VAR 0 2
35773: ARRAY
35774: IFFALSE 35831
// begin tmp := mc_attack [ i ] [ 1 ] ;
35776: LD_ADDR_VAR 0 3
35780: PUSH
35781: LD_EXP 94
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PUSH
35792: LD_INT 1
35794: ARRAY
35795: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35796: LD_ADDR_EXP 94
35800: PUSH
35801: LD_EXP 94
35805: PPUSH
35806: LD_VAR 0 2
35810: PPUSH
35811: EMPTY
35812: PPUSH
35813: CALL_OW 1
35817: ST_TO_ADDR
// Attack ( tmp ) ;
35818: LD_VAR 0 3
35822: PPUSH
35823: CALL 85470 0 1
// exit ;
35827: POP
35828: POP
35829: GO 35835
// end ; end ;
35831: GO 35761
35833: POP
35834: POP
// end ;
35835: LD_VAR 0 1
35839: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35840: LD_INT 0
35842: PPUSH
35843: PPUSH
35844: PPUSH
35845: PPUSH
35846: PPUSH
35847: PPUSH
35848: PPUSH
// if not mc_bases then
35849: LD_EXP 74
35853: NOT
35854: IFFALSE 35858
// exit ;
35856: GO 36440
// for i = 1 to mc_bases do
35858: LD_ADDR_VAR 0 2
35862: PUSH
35863: DOUBLE
35864: LD_INT 1
35866: DEC
35867: ST_TO_ADDR
35868: LD_EXP 74
35872: PUSH
35873: FOR_TO
35874: IFFALSE 36438
// begin if not mc_bases [ i ] then
35876: LD_EXP 74
35880: PUSH
35881: LD_VAR 0 2
35885: ARRAY
35886: NOT
35887: IFFALSE 35891
// continue ;
35889: GO 35873
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
35891: LD_ADDR_VAR 0 7
35895: PUSH
35896: LD_EXP 74
35900: PUSH
35901: LD_VAR 0 2
35905: ARRAY
35906: PUSH
35907: LD_INT 1
35909: ARRAY
35910: PPUSH
35911: CALL 53829 0 1
35915: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
35916: LD_ADDR_EXP 97
35920: PUSH
35921: LD_EXP 97
35925: PPUSH
35926: LD_VAR 0 2
35930: PPUSH
35931: LD_EXP 74
35935: PUSH
35936: LD_VAR 0 2
35940: ARRAY
35941: PUSH
35942: LD_INT 1
35944: ARRAY
35945: PPUSH
35946: CALL_OW 255
35950: PPUSH
35951: LD_EXP 99
35955: PUSH
35956: LD_VAR 0 2
35960: ARRAY
35961: PPUSH
35962: CALL 51532 0 2
35966: PPUSH
35967: CALL_OW 1
35971: ST_TO_ADDR
// if not mc_scan [ i ] then
35972: LD_EXP 97
35976: PUSH
35977: LD_VAR 0 2
35981: ARRAY
35982: NOT
35983: IFFALSE 36138
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35985: LD_ADDR_VAR 0 4
35989: PUSH
35990: LD_EXP 74
35994: PUSH
35995: LD_VAR 0 2
35999: ARRAY
36000: PPUSH
36001: LD_INT 2
36003: PUSH
36004: LD_INT 25
36006: PUSH
36007: LD_INT 5
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 25
36016: PUSH
36017: LD_INT 8
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 25
36026: PUSH
36027: LD_INT 9
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: EMPTY
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: PPUSH
36040: CALL_OW 72
36044: ST_TO_ADDR
// if not tmp then
36045: LD_VAR 0 4
36049: NOT
36050: IFFALSE 36054
// continue ;
36052: GO 35873
// for j in tmp do
36054: LD_ADDR_VAR 0 3
36058: PUSH
36059: LD_VAR 0 4
36063: PUSH
36064: FOR_IN
36065: IFFALSE 36136
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36067: LD_VAR 0 3
36071: PPUSH
36072: CALL_OW 310
36076: PPUSH
36077: CALL_OW 266
36081: PUSH
36082: LD_INT 5
36084: EQUAL
36085: PUSH
36086: LD_VAR 0 3
36090: PPUSH
36091: CALL_OW 257
36095: PUSH
36096: LD_INT 1
36098: EQUAL
36099: AND
36100: PUSH
36101: LD_VAR 0 3
36105: PPUSH
36106: CALL_OW 459
36110: NOT
36111: AND
36112: PUSH
36113: LD_VAR 0 7
36117: AND
36118: IFFALSE 36134
// ComChangeProfession ( j , class ) ;
36120: LD_VAR 0 3
36124: PPUSH
36125: LD_VAR 0 7
36129: PPUSH
36130: CALL_OW 123
36134: GO 36064
36136: POP
36137: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36138: LD_EXP 97
36142: PUSH
36143: LD_VAR 0 2
36147: ARRAY
36148: PUSH
36149: LD_EXP 96
36153: PUSH
36154: LD_VAR 0 2
36158: ARRAY
36159: NOT
36160: AND
36161: PUSH
36162: LD_EXP 74
36166: PUSH
36167: LD_VAR 0 2
36171: ARRAY
36172: PPUSH
36173: LD_INT 30
36175: PUSH
36176: LD_INT 32
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PPUSH
36183: CALL_OW 72
36187: NOT
36188: AND
36189: PUSH
36190: LD_EXP 74
36194: PUSH
36195: LD_VAR 0 2
36199: ARRAY
36200: PPUSH
36201: LD_INT 2
36203: PUSH
36204: LD_INT 30
36206: PUSH
36207: LD_INT 4
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 30
36216: PUSH
36217: LD_INT 5
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: LIST
36228: PPUSH
36229: CALL_OW 72
36233: NOT
36234: AND
36235: IFFALSE 36367
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36237: LD_ADDR_VAR 0 4
36241: PUSH
36242: LD_EXP 74
36246: PUSH
36247: LD_VAR 0 2
36251: ARRAY
36252: PPUSH
36253: LD_INT 2
36255: PUSH
36256: LD_INT 25
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 25
36268: PUSH
36269: LD_INT 5
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 25
36278: PUSH
36279: LD_INT 8
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 25
36288: PUSH
36289: LD_INT 9
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: LIST
36300: LIST
36301: LIST
36302: PPUSH
36303: CALL_OW 72
36307: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36308: LD_ADDR_VAR 0 4
36312: PUSH
36313: LD_VAR 0 4
36317: PUSH
36318: LD_VAR 0 4
36322: PPUSH
36323: LD_INT 18
36325: PPUSH
36326: CALL 90253 0 2
36330: DIFF
36331: ST_TO_ADDR
// if tmp then
36332: LD_VAR 0 4
36336: IFFALSE 36367
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36338: LD_VAR 0 2
36342: PPUSH
36343: LD_VAR 0 4
36347: PPUSH
36348: LD_EXP 99
36352: PUSH
36353: LD_VAR 0 2
36357: ARRAY
36358: PPUSH
36359: CALL 51567 0 3
// exit ;
36363: POP
36364: POP
36365: GO 36440
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36367: LD_EXP 97
36371: PUSH
36372: LD_VAR 0 2
36376: ARRAY
36377: PUSH
36378: LD_EXP 96
36382: PUSH
36383: LD_VAR 0 2
36387: ARRAY
36388: AND
36389: IFFALSE 36436
// begin tmp := mc_defender [ i ] ;
36391: LD_ADDR_VAR 0 4
36395: PUSH
36396: LD_EXP 96
36400: PUSH
36401: LD_VAR 0 2
36405: ARRAY
36406: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36407: LD_VAR 0 2
36411: PPUSH
36412: LD_VAR 0 4
36416: PPUSH
36417: LD_EXP 97
36421: PUSH
36422: LD_VAR 0 2
36426: ARRAY
36427: PPUSH
36428: CALL 52128 0 3
// exit ;
36432: POP
36433: POP
36434: GO 36440
// end ; end ;
36436: GO 35873
36438: POP
36439: POP
// end ;
36440: LD_VAR 0 1
36444: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36445: LD_INT 0
36447: PPUSH
36448: PPUSH
36449: PPUSH
36450: PPUSH
36451: PPUSH
36452: PPUSH
36453: PPUSH
36454: PPUSH
36455: PPUSH
36456: PPUSH
36457: PPUSH
// if not mc_bases then
36458: LD_EXP 74
36462: NOT
36463: IFFALSE 36467
// exit ;
36465: GO 37554
// for i = 1 to mc_bases do
36467: LD_ADDR_VAR 0 2
36471: PUSH
36472: DOUBLE
36473: LD_INT 1
36475: DEC
36476: ST_TO_ADDR
36477: LD_EXP 74
36481: PUSH
36482: FOR_TO
36483: IFFALSE 37552
// begin tmp := mc_lab [ i ] ;
36485: LD_ADDR_VAR 0 6
36489: PUSH
36490: LD_EXP 107
36494: PUSH
36495: LD_VAR 0 2
36499: ARRAY
36500: ST_TO_ADDR
// if not tmp then
36501: LD_VAR 0 6
36505: NOT
36506: IFFALSE 36510
// continue ;
36508: GO 36482
// idle_lab := 0 ;
36510: LD_ADDR_VAR 0 11
36514: PUSH
36515: LD_INT 0
36517: ST_TO_ADDR
// for j in tmp do
36518: LD_ADDR_VAR 0 3
36522: PUSH
36523: LD_VAR 0 6
36527: PUSH
36528: FOR_IN
36529: IFFALSE 37548
// begin researching := false ;
36531: LD_ADDR_VAR 0 10
36535: PUSH
36536: LD_INT 0
36538: ST_TO_ADDR
// side := GetSide ( j ) ;
36539: LD_ADDR_VAR 0 4
36543: PUSH
36544: LD_VAR 0 3
36548: PPUSH
36549: CALL_OW 255
36553: ST_TO_ADDR
// if not mc_tech [ side ] then
36554: LD_EXP 101
36558: PUSH
36559: LD_VAR 0 4
36563: ARRAY
36564: NOT
36565: IFFALSE 36569
// continue ;
36567: GO 36528
// if BuildingStatus ( j ) = bs_idle then
36569: LD_VAR 0 3
36573: PPUSH
36574: CALL_OW 461
36578: PUSH
36579: LD_INT 2
36581: EQUAL
36582: IFFALSE 36770
// begin if idle_lab and UnitsInside ( j ) < 6 then
36584: LD_VAR 0 11
36588: PUSH
36589: LD_VAR 0 3
36593: PPUSH
36594: CALL_OW 313
36598: PUSH
36599: LD_INT 6
36601: LESS
36602: AND
36603: IFFALSE 36674
// begin tmp2 := UnitsInside ( idle_lab ) ;
36605: LD_ADDR_VAR 0 9
36609: PUSH
36610: LD_VAR 0 11
36614: PPUSH
36615: CALL_OW 313
36619: ST_TO_ADDR
// if tmp2 then
36620: LD_VAR 0 9
36624: IFFALSE 36666
// for x in tmp2 do
36626: LD_ADDR_VAR 0 7
36630: PUSH
36631: LD_VAR 0 9
36635: PUSH
36636: FOR_IN
36637: IFFALSE 36664
// begin ComExitBuilding ( x ) ;
36639: LD_VAR 0 7
36643: PPUSH
36644: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36648: LD_VAR 0 7
36652: PPUSH
36653: LD_VAR 0 3
36657: PPUSH
36658: CALL_OW 180
// end ;
36662: GO 36636
36664: POP
36665: POP
// idle_lab := 0 ;
36666: LD_ADDR_VAR 0 11
36670: PUSH
36671: LD_INT 0
36673: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36674: LD_ADDR_VAR 0 5
36678: PUSH
36679: LD_EXP 101
36683: PUSH
36684: LD_VAR 0 4
36688: ARRAY
36689: PUSH
36690: FOR_IN
36691: IFFALSE 36751
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36693: LD_VAR 0 3
36697: PPUSH
36698: LD_VAR 0 5
36702: PPUSH
36703: CALL_OW 430
36707: PUSH
36708: LD_VAR 0 4
36712: PPUSH
36713: LD_VAR 0 5
36717: PPUSH
36718: CALL 50637 0 2
36722: AND
36723: IFFALSE 36749
// begin researching := true ;
36725: LD_ADDR_VAR 0 10
36729: PUSH
36730: LD_INT 1
36732: ST_TO_ADDR
// ComResearch ( j , t ) ;
36733: LD_VAR 0 3
36737: PPUSH
36738: LD_VAR 0 5
36742: PPUSH
36743: CALL_OW 124
// break ;
36747: GO 36751
// end ;
36749: GO 36690
36751: POP
36752: POP
// if not researching then
36753: LD_VAR 0 10
36757: NOT
36758: IFFALSE 36770
// idle_lab := j ;
36760: LD_ADDR_VAR 0 11
36764: PUSH
36765: LD_VAR 0 3
36769: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36770: LD_VAR 0 3
36774: PPUSH
36775: CALL_OW 461
36779: PUSH
36780: LD_INT 10
36782: EQUAL
36783: IFFALSE 37371
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36785: LD_EXP 103
36789: PUSH
36790: LD_VAR 0 2
36794: ARRAY
36795: NOT
36796: PUSH
36797: LD_EXP 104
36801: PUSH
36802: LD_VAR 0 2
36806: ARRAY
36807: NOT
36808: AND
36809: PUSH
36810: LD_EXP 101
36814: PUSH
36815: LD_VAR 0 4
36819: ARRAY
36820: PUSH
36821: LD_INT 1
36823: GREATER
36824: AND
36825: IFFALSE 36956
// begin ComCancel ( j ) ;
36827: LD_VAR 0 3
36831: PPUSH
36832: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36836: LD_ADDR_EXP 101
36840: PUSH
36841: LD_EXP 101
36845: PPUSH
36846: LD_VAR 0 4
36850: PPUSH
36851: LD_EXP 101
36855: PUSH
36856: LD_VAR 0 4
36860: ARRAY
36861: PPUSH
36862: LD_EXP 101
36866: PUSH
36867: LD_VAR 0 4
36871: ARRAY
36872: PUSH
36873: LD_INT 1
36875: MINUS
36876: PPUSH
36877: LD_EXP 101
36881: PUSH
36882: LD_VAR 0 4
36886: ARRAY
36887: PPUSH
36888: LD_INT 0
36890: PPUSH
36891: CALL 56411 0 4
36895: PPUSH
36896: CALL_OW 1
36900: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
36901: LD_ADDR_EXP 101
36905: PUSH
36906: LD_EXP 101
36910: PPUSH
36911: LD_VAR 0 4
36915: PPUSH
36916: LD_EXP 101
36920: PUSH
36921: LD_VAR 0 4
36925: ARRAY
36926: PPUSH
36927: LD_EXP 101
36931: PUSH
36932: LD_VAR 0 4
36936: ARRAY
36937: PPUSH
36938: LD_INT 1
36940: PPUSH
36941: LD_INT 0
36943: PPUSH
36944: CALL 56411 0 4
36948: PPUSH
36949: CALL_OW 1
36953: ST_TO_ADDR
// continue ;
36954: GO 36528
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
36956: LD_EXP 103
36960: PUSH
36961: LD_VAR 0 2
36965: ARRAY
36966: PUSH
36967: LD_EXP 104
36971: PUSH
36972: LD_VAR 0 2
36976: ARRAY
36977: NOT
36978: AND
36979: IFFALSE 37106
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
36981: LD_ADDR_EXP 104
36985: PUSH
36986: LD_EXP 104
36990: PPUSH
36991: LD_VAR 0 2
36995: PUSH
36996: LD_EXP 104
37000: PUSH
37001: LD_VAR 0 2
37005: ARRAY
37006: PUSH
37007: LD_INT 1
37009: PLUS
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PPUSH
37015: LD_EXP 103
37019: PUSH
37020: LD_VAR 0 2
37024: ARRAY
37025: PUSH
37026: LD_INT 1
37028: ARRAY
37029: PPUSH
37030: CALL 56993 0 3
37034: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37035: LD_EXP 103
37039: PUSH
37040: LD_VAR 0 2
37044: ARRAY
37045: PUSH
37046: LD_INT 1
37048: ARRAY
37049: PPUSH
37050: LD_INT 112
37052: PPUSH
37053: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37057: LD_ADDR_VAR 0 9
37061: PUSH
37062: LD_EXP 103
37066: PUSH
37067: LD_VAR 0 2
37071: ARRAY
37072: PPUSH
37073: LD_INT 1
37075: PPUSH
37076: CALL_OW 3
37080: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37081: LD_ADDR_EXP 103
37085: PUSH
37086: LD_EXP 103
37090: PPUSH
37091: LD_VAR 0 2
37095: PPUSH
37096: LD_VAR 0 9
37100: PPUSH
37101: CALL_OW 1
37105: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37106: LD_EXP 103
37110: PUSH
37111: LD_VAR 0 2
37115: ARRAY
37116: PUSH
37117: LD_EXP 104
37121: PUSH
37122: LD_VAR 0 2
37126: ARRAY
37127: AND
37128: PUSH
37129: LD_EXP 104
37133: PUSH
37134: LD_VAR 0 2
37138: ARRAY
37139: PUSH
37140: LD_INT 1
37142: ARRAY
37143: PPUSH
37144: CALL_OW 310
37148: NOT
37149: AND
37150: PUSH
37151: LD_VAR 0 3
37155: PPUSH
37156: CALL_OW 313
37160: PUSH
37161: LD_INT 6
37163: EQUAL
37164: AND
37165: IFFALSE 37221
// begin tmp2 := UnitsInside ( j ) ;
37167: LD_ADDR_VAR 0 9
37171: PUSH
37172: LD_VAR 0 3
37176: PPUSH
37177: CALL_OW 313
37181: ST_TO_ADDR
// if tmp2 = 6 then
37182: LD_VAR 0 9
37186: PUSH
37187: LD_INT 6
37189: EQUAL
37190: IFFALSE 37221
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37192: LD_VAR 0 9
37196: PUSH
37197: LD_INT 1
37199: ARRAY
37200: PPUSH
37201: LD_INT 112
37203: PPUSH
37204: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37208: LD_VAR 0 9
37212: PUSH
37213: LD_INT 1
37215: ARRAY
37216: PPUSH
37217: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37221: LD_EXP 104
37225: PUSH
37226: LD_VAR 0 2
37230: ARRAY
37231: PUSH
37232: LD_EXP 104
37236: PUSH
37237: LD_VAR 0 2
37241: ARRAY
37242: PUSH
37243: LD_INT 1
37245: ARRAY
37246: PPUSH
37247: CALL_OW 314
37251: NOT
37252: AND
37253: PUSH
37254: LD_EXP 104
37258: PUSH
37259: LD_VAR 0 2
37263: ARRAY
37264: PUSH
37265: LD_INT 1
37267: ARRAY
37268: PPUSH
37269: CALL_OW 310
37273: NOT
37274: AND
37275: IFFALSE 37301
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37277: LD_EXP 104
37281: PUSH
37282: LD_VAR 0 2
37286: ARRAY
37287: PUSH
37288: LD_INT 1
37290: ARRAY
37291: PPUSH
37292: LD_VAR 0 3
37296: PPUSH
37297: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37301: LD_EXP 104
37305: PUSH
37306: LD_VAR 0 2
37310: ARRAY
37311: PUSH
37312: LD_INT 1
37314: ARRAY
37315: PPUSH
37316: CALL_OW 310
37320: PUSH
37321: LD_EXP 104
37325: PUSH
37326: LD_VAR 0 2
37330: ARRAY
37331: PUSH
37332: LD_INT 1
37334: ARRAY
37335: PPUSH
37336: CALL_OW 310
37340: PPUSH
37341: CALL_OW 461
37345: PUSH
37346: LD_INT 3
37348: NONEQUAL
37349: AND
37350: IFFALSE 37371
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37352: LD_EXP 104
37356: PUSH
37357: LD_VAR 0 2
37361: ARRAY
37362: PUSH
37363: LD_INT 1
37365: ARRAY
37366: PPUSH
37367: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37371: LD_VAR 0 3
37375: PPUSH
37376: CALL_OW 461
37380: PUSH
37381: LD_INT 6
37383: EQUAL
37384: PUSH
37385: LD_VAR 0 6
37389: PUSH
37390: LD_INT 1
37392: GREATER
37393: AND
37394: IFFALSE 37546
// begin sci := [ ] ;
37396: LD_ADDR_VAR 0 8
37400: PUSH
37401: EMPTY
37402: ST_TO_ADDR
// for x in ( tmp diff j ) do
37403: LD_ADDR_VAR 0 7
37407: PUSH
37408: LD_VAR 0 6
37412: PUSH
37413: LD_VAR 0 3
37417: DIFF
37418: PUSH
37419: FOR_IN
37420: IFFALSE 37472
// begin if sci = 6 then
37422: LD_VAR 0 8
37426: PUSH
37427: LD_INT 6
37429: EQUAL
37430: IFFALSE 37434
// break ;
37432: GO 37472
// if BuildingStatus ( x ) = bs_idle then
37434: LD_VAR 0 7
37438: PPUSH
37439: CALL_OW 461
37443: PUSH
37444: LD_INT 2
37446: EQUAL
37447: IFFALSE 37470
// sci := sci ^ UnitsInside ( x ) ;
37449: LD_ADDR_VAR 0 8
37453: PUSH
37454: LD_VAR 0 8
37458: PUSH
37459: LD_VAR 0 7
37463: PPUSH
37464: CALL_OW 313
37468: ADD
37469: ST_TO_ADDR
// end ;
37470: GO 37419
37472: POP
37473: POP
// if not sci then
37474: LD_VAR 0 8
37478: NOT
37479: IFFALSE 37483
// continue ;
37481: GO 36528
// for x in sci do
37483: LD_ADDR_VAR 0 7
37487: PUSH
37488: LD_VAR 0 8
37492: PUSH
37493: FOR_IN
37494: IFFALSE 37544
// if IsInUnit ( x ) and not HasTask ( x ) then
37496: LD_VAR 0 7
37500: PPUSH
37501: CALL_OW 310
37505: PUSH
37506: LD_VAR 0 7
37510: PPUSH
37511: CALL_OW 314
37515: NOT
37516: AND
37517: IFFALSE 37542
// begin ComExitBuilding ( x ) ;
37519: LD_VAR 0 7
37523: PPUSH
37524: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37528: LD_VAR 0 7
37532: PPUSH
37533: LD_VAR 0 3
37537: PPUSH
37538: CALL_OW 180
// end ;
37542: GO 37493
37544: POP
37545: POP
// end ; end ;
37546: GO 36528
37548: POP
37549: POP
// end ;
37550: GO 36482
37552: POP
37553: POP
// end ;
37554: LD_VAR 0 1
37558: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37559: LD_INT 0
37561: PPUSH
37562: PPUSH
// if not mc_bases then
37563: LD_EXP 74
37567: NOT
37568: IFFALSE 37572
// exit ;
37570: GO 37653
// for i = 1 to mc_bases do
37572: LD_ADDR_VAR 0 2
37576: PUSH
37577: DOUBLE
37578: LD_INT 1
37580: DEC
37581: ST_TO_ADDR
37582: LD_EXP 74
37586: PUSH
37587: FOR_TO
37588: IFFALSE 37651
// if mc_mines [ i ] and mc_miners [ i ] then
37590: LD_EXP 87
37594: PUSH
37595: LD_VAR 0 2
37599: ARRAY
37600: PUSH
37601: LD_EXP 88
37605: PUSH
37606: LD_VAR 0 2
37610: ARRAY
37611: AND
37612: IFFALSE 37649
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37614: LD_EXP 88
37618: PUSH
37619: LD_VAR 0 2
37623: ARRAY
37624: PUSH
37625: LD_INT 1
37627: ARRAY
37628: PPUSH
37629: CALL_OW 255
37633: PPUSH
37634: LD_EXP 87
37638: PUSH
37639: LD_VAR 0 2
37643: ARRAY
37644: PPUSH
37645: CALL 53982 0 2
37649: GO 37587
37651: POP
37652: POP
// end ;
37653: LD_VAR 0 1
37657: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37658: LD_INT 0
37660: PPUSH
37661: PPUSH
37662: PPUSH
37663: PPUSH
37664: PPUSH
37665: PPUSH
37666: PPUSH
37667: PPUSH
// if not mc_bases or not mc_parking then
37668: LD_EXP 74
37672: NOT
37673: PUSH
37674: LD_EXP 98
37678: NOT
37679: OR
37680: IFFALSE 37684
// exit ;
37682: GO 38383
// for i = 1 to mc_bases do
37684: LD_ADDR_VAR 0 2
37688: PUSH
37689: DOUBLE
37690: LD_INT 1
37692: DEC
37693: ST_TO_ADDR
37694: LD_EXP 74
37698: PUSH
37699: FOR_TO
37700: IFFALSE 38381
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37702: LD_EXP 74
37706: PUSH
37707: LD_VAR 0 2
37711: ARRAY
37712: NOT
37713: PUSH
37714: LD_EXP 98
37718: PUSH
37719: LD_VAR 0 2
37723: ARRAY
37724: NOT
37725: OR
37726: IFFALSE 37730
// continue ;
37728: GO 37699
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37730: LD_ADDR_VAR 0 5
37734: PUSH
37735: LD_EXP 74
37739: PUSH
37740: LD_VAR 0 2
37744: ARRAY
37745: PUSH
37746: LD_INT 1
37748: ARRAY
37749: PPUSH
37750: CALL_OW 255
37754: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37755: LD_ADDR_VAR 0 6
37759: PUSH
37760: LD_EXP 74
37764: PUSH
37765: LD_VAR 0 2
37769: ARRAY
37770: PPUSH
37771: LD_INT 30
37773: PUSH
37774: LD_INT 3
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PPUSH
37781: CALL_OW 72
37785: ST_TO_ADDR
// if not fac then
37786: LD_VAR 0 6
37790: NOT
37791: IFFALSE 37842
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37793: LD_ADDR_VAR 0 6
37797: PUSH
37798: LD_EXP 74
37802: PUSH
37803: LD_VAR 0 2
37807: ARRAY
37808: PPUSH
37809: LD_INT 2
37811: PUSH
37812: LD_INT 30
37814: PUSH
37815: LD_INT 0
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 30
37824: PUSH
37825: LD_INT 1
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: LIST
37836: PPUSH
37837: CALL_OW 72
37841: ST_TO_ADDR
// if not fac then
37842: LD_VAR 0 6
37846: NOT
37847: IFFALSE 37851
// continue ;
37849: GO 37699
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37851: LD_ADDR_VAR 0 7
37855: PUSH
37856: LD_EXP 98
37860: PUSH
37861: LD_VAR 0 2
37865: ARRAY
37866: PPUSH
37867: LD_INT 22
37869: PUSH
37870: LD_VAR 0 5
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 21
37881: PUSH
37882: LD_INT 2
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 3
37891: PUSH
37892: LD_INT 24
37894: PUSH
37895: LD_INT 1000
37897: PUSH
37898: EMPTY
37899: LIST
37900: LIST
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: LIST
37910: PPUSH
37911: CALL_OW 70
37915: ST_TO_ADDR
// for j in fac do
37916: LD_ADDR_VAR 0 3
37920: PUSH
37921: LD_VAR 0 6
37925: PUSH
37926: FOR_IN
37927: IFFALSE 38008
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37929: LD_ADDR_VAR 0 7
37933: PUSH
37934: LD_VAR 0 7
37938: PUSH
37939: LD_INT 22
37941: PUSH
37942: LD_VAR 0 5
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: LD_INT 91
37953: PUSH
37954: LD_VAR 0 3
37958: PUSH
37959: LD_INT 15
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: LIST
37966: PUSH
37967: LD_INT 21
37969: PUSH
37970: LD_INT 2
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: LD_INT 3
37979: PUSH
37980: LD_INT 24
37982: PUSH
37983: LD_INT 1000
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: PPUSH
38000: CALL_OW 69
38004: UNION
38005: ST_TO_ADDR
38006: GO 37926
38008: POP
38009: POP
// if not vehs then
38010: LD_VAR 0 7
38014: NOT
38015: IFFALSE 38041
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38017: LD_ADDR_EXP 86
38021: PUSH
38022: LD_EXP 86
38026: PPUSH
38027: LD_VAR 0 2
38031: PPUSH
38032: EMPTY
38033: PPUSH
38034: CALL_OW 1
38038: ST_TO_ADDR
// continue ;
38039: GO 37699
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38041: LD_ADDR_VAR 0 8
38045: PUSH
38046: LD_EXP 74
38050: PUSH
38051: LD_VAR 0 2
38055: ARRAY
38056: PPUSH
38057: LD_INT 30
38059: PUSH
38060: LD_INT 3
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PPUSH
38067: CALL_OW 72
38071: ST_TO_ADDR
// if tmp then
38072: LD_VAR 0 8
38076: IFFALSE 38179
// begin for j in tmp do
38078: LD_ADDR_VAR 0 3
38082: PUSH
38083: LD_VAR 0 8
38087: PUSH
38088: FOR_IN
38089: IFFALSE 38177
// for k in UnitsInside ( j ) do
38091: LD_ADDR_VAR 0 4
38095: PUSH
38096: LD_VAR 0 3
38100: PPUSH
38101: CALL_OW 313
38105: PUSH
38106: FOR_IN
38107: IFFALSE 38173
// if k then
38109: LD_VAR 0 4
38113: IFFALSE 38171
// if not k in mc_repair_vehicle [ i ] then
38115: LD_VAR 0 4
38119: PUSH
38120: LD_EXP 86
38124: PUSH
38125: LD_VAR 0 2
38129: ARRAY
38130: IN
38131: NOT
38132: IFFALSE 38171
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38134: LD_ADDR_EXP 86
38138: PUSH
38139: LD_EXP 86
38143: PPUSH
38144: LD_VAR 0 2
38148: PPUSH
38149: LD_EXP 86
38153: PUSH
38154: LD_VAR 0 2
38158: ARRAY
38159: PUSH
38160: LD_VAR 0 4
38164: UNION
38165: PPUSH
38166: CALL_OW 1
38170: ST_TO_ADDR
38171: GO 38106
38173: POP
38174: POP
38175: GO 38088
38177: POP
38178: POP
// end ; if not mc_repair_vehicle [ i ] then
38179: LD_EXP 86
38183: PUSH
38184: LD_VAR 0 2
38188: ARRAY
38189: NOT
38190: IFFALSE 38194
// continue ;
38192: GO 37699
// for j in mc_repair_vehicle [ i ] do
38194: LD_ADDR_VAR 0 3
38198: PUSH
38199: LD_EXP 86
38203: PUSH
38204: LD_VAR 0 2
38208: ARRAY
38209: PUSH
38210: FOR_IN
38211: IFFALSE 38377
// begin if GetClass ( j ) <> 3 then
38213: LD_VAR 0 3
38217: PPUSH
38218: CALL_OW 257
38222: PUSH
38223: LD_INT 3
38225: NONEQUAL
38226: IFFALSE 38267
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38228: LD_ADDR_EXP 86
38232: PUSH
38233: LD_EXP 86
38237: PPUSH
38238: LD_VAR 0 2
38242: PPUSH
38243: LD_EXP 86
38247: PUSH
38248: LD_VAR 0 2
38252: ARRAY
38253: PUSH
38254: LD_VAR 0 3
38258: DIFF
38259: PPUSH
38260: CALL_OW 1
38264: ST_TO_ADDR
// continue ;
38265: GO 38210
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38267: LD_VAR 0 3
38271: PPUSH
38272: CALL_OW 311
38276: NOT
38277: PUSH
38278: LD_VAR 0 3
38282: PUSH
38283: LD_EXP 77
38287: PUSH
38288: LD_VAR 0 2
38292: ARRAY
38293: PUSH
38294: LD_INT 1
38296: ARRAY
38297: IN
38298: NOT
38299: AND
38300: PUSH
38301: LD_VAR 0 3
38305: PUSH
38306: LD_EXP 77
38310: PUSH
38311: LD_VAR 0 2
38315: ARRAY
38316: PUSH
38317: LD_INT 2
38319: ARRAY
38320: IN
38321: NOT
38322: AND
38323: IFFALSE 38375
// begin if IsInUnit ( j ) then
38325: LD_VAR 0 3
38329: PPUSH
38330: CALL_OW 310
38334: IFFALSE 38345
// ComExitBuilding ( j ) ;
38336: LD_VAR 0 3
38340: PPUSH
38341: CALL_OW 122
// if not HasTask ( j ) then
38345: LD_VAR 0 3
38349: PPUSH
38350: CALL_OW 314
38354: NOT
38355: IFFALSE 38375
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38357: LD_VAR 0 3
38361: PPUSH
38362: LD_VAR 0 7
38366: PUSH
38367: LD_INT 1
38369: ARRAY
38370: PPUSH
38371: CALL_OW 189
// end ; end ;
38375: GO 38210
38377: POP
38378: POP
// end ;
38379: GO 37699
38381: POP
38382: POP
// end ;
38383: LD_VAR 0 1
38387: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38388: LD_INT 0
38390: PPUSH
38391: PPUSH
38392: PPUSH
38393: PPUSH
38394: PPUSH
38395: PPUSH
38396: PPUSH
38397: PPUSH
38398: PPUSH
38399: PPUSH
38400: PPUSH
// if not mc_bases then
38401: LD_EXP 74
38405: NOT
38406: IFFALSE 38410
// exit ;
38408: GO 39212
// for i = 1 to mc_bases do
38410: LD_ADDR_VAR 0 2
38414: PUSH
38415: DOUBLE
38416: LD_INT 1
38418: DEC
38419: ST_TO_ADDR
38420: LD_EXP 74
38424: PUSH
38425: FOR_TO
38426: IFFALSE 39210
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38428: LD_EXP 102
38432: PUSH
38433: LD_VAR 0 2
38437: ARRAY
38438: NOT
38439: PUSH
38440: LD_EXP 77
38444: PUSH
38445: LD_VAR 0 2
38449: ARRAY
38450: PUSH
38451: LD_INT 1
38453: ARRAY
38454: OR
38455: PUSH
38456: LD_EXP 77
38460: PUSH
38461: LD_VAR 0 2
38465: ARRAY
38466: PUSH
38467: LD_INT 2
38469: ARRAY
38470: OR
38471: PUSH
38472: LD_EXP 100
38476: PUSH
38477: LD_VAR 0 2
38481: ARRAY
38482: PPUSH
38483: LD_INT 1
38485: PPUSH
38486: CALL_OW 325
38490: NOT
38491: OR
38492: PUSH
38493: LD_EXP 97
38497: PUSH
38498: LD_VAR 0 2
38502: ARRAY
38503: OR
38504: IFFALSE 38508
// continue ;
38506: GO 38425
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38508: LD_ADDR_VAR 0 8
38512: PUSH
38513: LD_EXP 74
38517: PUSH
38518: LD_VAR 0 2
38522: ARRAY
38523: PPUSH
38524: LD_INT 25
38526: PUSH
38527: LD_INT 4
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: LD_INT 50
38536: PUSH
38537: EMPTY
38538: LIST
38539: PUSH
38540: LD_INT 3
38542: PUSH
38543: LD_INT 60
38545: PUSH
38546: EMPTY
38547: LIST
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: LIST
38557: PPUSH
38558: CALL_OW 72
38562: PUSH
38563: LD_EXP 78
38567: PUSH
38568: LD_VAR 0 2
38572: ARRAY
38573: DIFF
38574: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38575: LD_ADDR_VAR 0 9
38579: PUSH
38580: LD_EXP 74
38584: PUSH
38585: LD_VAR 0 2
38589: ARRAY
38590: PPUSH
38591: LD_INT 2
38593: PUSH
38594: LD_INT 30
38596: PUSH
38597: LD_INT 0
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 30
38606: PUSH
38607: LD_INT 1
38609: PUSH
38610: EMPTY
38611: LIST
38612: LIST
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: LIST
38618: PPUSH
38619: CALL_OW 72
38623: ST_TO_ADDR
// if not tmp or not dep then
38624: LD_VAR 0 8
38628: NOT
38629: PUSH
38630: LD_VAR 0 9
38634: NOT
38635: OR
38636: IFFALSE 38640
// continue ;
38638: GO 38425
// side := GetSide ( tmp [ 1 ] ) ;
38640: LD_ADDR_VAR 0 11
38644: PUSH
38645: LD_VAR 0 8
38649: PUSH
38650: LD_INT 1
38652: ARRAY
38653: PPUSH
38654: CALL_OW 255
38658: ST_TO_ADDR
// dep := dep [ 1 ] ;
38659: LD_ADDR_VAR 0 9
38663: PUSH
38664: LD_VAR 0 9
38668: PUSH
38669: LD_INT 1
38671: ARRAY
38672: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38673: LD_ADDR_VAR 0 7
38677: PUSH
38678: LD_EXP 102
38682: PUSH
38683: LD_VAR 0 2
38687: ARRAY
38688: PPUSH
38689: LD_INT 22
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 25
38701: PUSH
38702: LD_INT 12
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PPUSH
38713: CALL_OW 70
38717: PUSH
38718: LD_INT 22
38720: PUSH
38721: LD_INT 0
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 25
38730: PUSH
38731: LD_INT 12
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 91
38740: PUSH
38741: LD_VAR 0 9
38745: PUSH
38746: LD_INT 20
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: LIST
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: LIST
38758: PPUSH
38759: CALL_OW 69
38763: UNION
38764: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38765: LD_ADDR_VAR 0 10
38769: PUSH
38770: LD_EXP 102
38774: PUSH
38775: LD_VAR 0 2
38779: ARRAY
38780: PPUSH
38781: LD_INT 81
38783: PUSH
38784: LD_VAR 0 11
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PPUSH
38793: CALL_OW 70
38797: ST_TO_ADDR
// if not apes or danger_at_area then
38798: LD_VAR 0 7
38802: NOT
38803: PUSH
38804: LD_VAR 0 10
38808: OR
38809: IFFALSE 38859
// begin if mc_taming [ i ] then
38811: LD_EXP 105
38815: PUSH
38816: LD_VAR 0 2
38820: ARRAY
38821: IFFALSE 38857
// begin MC_Reset ( i , 121 ) ;
38823: LD_VAR 0 2
38827: PPUSH
38828: LD_INT 121
38830: PPUSH
38831: CALL 24190 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38835: LD_ADDR_EXP 105
38839: PUSH
38840: LD_EXP 105
38844: PPUSH
38845: LD_VAR 0 2
38849: PPUSH
38850: EMPTY
38851: PPUSH
38852: CALL_OW 1
38856: ST_TO_ADDR
// end ; continue ;
38857: GO 38425
// end ; for j in tmp do
38859: LD_ADDR_VAR 0 3
38863: PUSH
38864: LD_VAR 0 8
38868: PUSH
38869: FOR_IN
38870: IFFALSE 39206
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
38872: LD_VAR 0 3
38876: PUSH
38877: LD_EXP 105
38881: PUSH
38882: LD_VAR 0 2
38886: ARRAY
38887: IN
38888: NOT
38889: PUSH
38890: LD_EXP 105
38894: PUSH
38895: LD_VAR 0 2
38899: ARRAY
38900: PUSH
38901: LD_INT 3
38903: LESS
38904: AND
38905: IFFALSE 38963
// begin SetTag ( j , 121 ) ;
38907: LD_VAR 0 3
38911: PPUSH
38912: LD_INT 121
38914: PPUSH
38915: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
38919: LD_ADDR_EXP 105
38923: PUSH
38924: LD_EXP 105
38928: PPUSH
38929: LD_VAR 0 2
38933: PUSH
38934: LD_EXP 105
38938: PUSH
38939: LD_VAR 0 2
38943: ARRAY
38944: PUSH
38945: LD_INT 1
38947: PLUS
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PPUSH
38953: LD_VAR 0 3
38957: PPUSH
38958: CALL 56993 0 3
38962: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
38963: LD_VAR 0 3
38967: PUSH
38968: LD_EXP 105
38972: PUSH
38973: LD_VAR 0 2
38977: ARRAY
38978: IN
38979: IFFALSE 39204
// begin if GetClass ( j ) <> 4 then
38981: LD_VAR 0 3
38985: PPUSH
38986: CALL_OW 257
38990: PUSH
38991: LD_INT 4
38993: NONEQUAL
38994: IFFALSE 39047
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
38996: LD_ADDR_EXP 105
39000: PUSH
39001: LD_EXP 105
39005: PPUSH
39006: LD_VAR 0 2
39010: PPUSH
39011: LD_EXP 105
39015: PUSH
39016: LD_VAR 0 2
39020: ARRAY
39021: PUSH
39022: LD_VAR 0 3
39026: DIFF
39027: PPUSH
39028: CALL_OW 1
39032: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39033: LD_VAR 0 3
39037: PPUSH
39038: LD_INT 0
39040: PPUSH
39041: CALL_OW 109
// continue ;
39045: GO 38869
// end ; if IsInUnit ( j ) then
39047: LD_VAR 0 3
39051: PPUSH
39052: CALL_OW 310
39056: IFFALSE 39067
// ComExitBuilding ( j ) ;
39058: LD_VAR 0 3
39062: PPUSH
39063: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39067: LD_ADDR_VAR 0 6
39071: PUSH
39072: LD_VAR 0 7
39076: PPUSH
39077: LD_VAR 0 3
39081: PPUSH
39082: CALL_OW 74
39086: ST_TO_ADDR
// if not ape then
39087: LD_VAR 0 6
39091: NOT
39092: IFFALSE 39096
// break ;
39094: GO 39206
// x := GetX ( ape ) ;
39096: LD_ADDR_VAR 0 4
39100: PUSH
39101: LD_VAR 0 6
39105: PPUSH
39106: CALL_OW 250
39110: ST_TO_ADDR
// y := GetY ( ape ) ;
39111: LD_ADDR_VAR 0 5
39115: PUSH
39116: LD_VAR 0 6
39120: PPUSH
39121: CALL_OW 251
39125: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39126: LD_VAR 0 4
39130: PPUSH
39131: LD_VAR 0 5
39135: PPUSH
39136: CALL_OW 488
39140: NOT
39141: PUSH
39142: LD_VAR 0 11
39146: PPUSH
39147: LD_VAR 0 4
39151: PPUSH
39152: LD_VAR 0 5
39156: PPUSH
39157: LD_INT 20
39159: PPUSH
39160: CALL 57889 0 4
39164: PUSH
39165: LD_INT 4
39167: ARRAY
39168: OR
39169: IFFALSE 39173
// break ;
39171: GO 39206
// if not HasTask ( j ) then
39173: LD_VAR 0 3
39177: PPUSH
39178: CALL_OW 314
39182: NOT
39183: IFFALSE 39204
// ComTameXY ( j , x , y ) ;
39185: LD_VAR 0 3
39189: PPUSH
39190: LD_VAR 0 4
39194: PPUSH
39195: LD_VAR 0 5
39199: PPUSH
39200: CALL_OW 131
// end ; end ;
39204: GO 38869
39206: POP
39207: POP
// end ;
39208: GO 38425
39210: POP
39211: POP
// end ;
39212: LD_VAR 0 1
39216: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39217: LD_INT 0
39219: PPUSH
39220: PPUSH
39221: PPUSH
39222: PPUSH
39223: PPUSH
39224: PPUSH
39225: PPUSH
39226: PPUSH
// if not mc_bases then
39227: LD_EXP 74
39231: NOT
39232: IFFALSE 39236
// exit ;
39234: GO 39862
// for i = 1 to mc_bases do
39236: LD_ADDR_VAR 0 2
39240: PUSH
39241: DOUBLE
39242: LD_INT 1
39244: DEC
39245: ST_TO_ADDR
39246: LD_EXP 74
39250: PUSH
39251: FOR_TO
39252: IFFALSE 39860
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39254: LD_EXP 103
39258: PUSH
39259: LD_VAR 0 2
39263: ARRAY
39264: NOT
39265: PUSH
39266: LD_EXP 103
39270: PUSH
39271: LD_VAR 0 2
39275: ARRAY
39276: PPUSH
39277: LD_INT 25
39279: PUSH
39280: LD_INT 12
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PPUSH
39287: CALL_OW 72
39291: NOT
39292: OR
39293: IFFALSE 39297
// continue ;
39295: GO 39251
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39297: LD_ADDR_VAR 0 5
39301: PUSH
39302: LD_EXP 103
39306: PUSH
39307: LD_VAR 0 2
39311: ARRAY
39312: PUSH
39313: LD_INT 1
39315: ARRAY
39316: PPUSH
39317: CALL_OW 255
39321: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39322: LD_VAR 0 5
39326: PPUSH
39327: LD_INT 2
39329: PPUSH
39330: CALL_OW 325
39334: IFFALSE 39587
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39336: LD_ADDR_VAR 0 4
39340: PUSH
39341: LD_EXP 103
39345: PUSH
39346: LD_VAR 0 2
39350: ARRAY
39351: PPUSH
39352: LD_INT 25
39354: PUSH
39355: LD_INT 16
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PPUSH
39362: CALL_OW 72
39366: ST_TO_ADDR
// if tmp < 6 then
39367: LD_VAR 0 4
39371: PUSH
39372: LD_INT 6
39374: LESS
39375: IFFALSE 39587
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39377: LD_ADDR_VAR 0 6
39381: PUSH
39382: LD_EXP 74
39386: PUSH
39387: LD_VAR 0 2
39391: ARRAY
39392: PPUSH
39393: LD_INT 2
39395: PUSH
39396: LD_INT 30
39398: PUSH
39399: LD_INT 0
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 30
39408: PUSH
39409: LD_INT 1
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: LIST
39420: PPUSH
39421: CALL_OW 72
39425: ST_TO_ADDR
// if depot then
39426: LD_VAR 0 6
39430: IFFALSE 39587
// begin selected := 0 ;
39432: LD_ADDR_VAR 0 7
39436: PUSH
39437: LD_INT 0
39439: ST_TO_ADDR
// for j in depot do
39440: LD_ADDR_VAR 0 3
39444: PUSH
39445: LD_VAR 0 6
39449: PUSH
39450: FOR_IN
39451: IFFALSE 39482
// begin if UnitsInside ( j ) < 6 then
39453: LD_VAR 0 3
39457: PPUSH
39458: CALL_OW 313
39462: PUSH
39463: LD_INT 6
39465: LESS
39466: IFFALSE 39480
// begin selected := j ;
39468: LD_ADDR_VAR 0 7
39472: PUSH
39473: LD_VAR 0 3
39477: ST_TO_ADDR
// break ;
39478: GO 39482
// end ; end ;
39480: GO 39450
39482: POP
39483: POP
// if selected then
39484: LD_VAR 0 7
39488: IFFALSE 39587
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39490: LD_ADDR_VAR 0 3
39494: PUSH
39495: LD_EXP 103
39499: PUSH
39500: LD_VAR 0 2
39504: ARRAY
39505: PPUSH
39506: LD_INT 25
39508: PUSH
39509: LD_INT 12
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PPUSH
39516: CALL_OW 72
39520: PUSH
39521: FOR_IN
39522: IFFALSE 39585
// if not HasTask ( j ) then
39524: LD_VAR 0 3
39528: PPUSH
39529: CALL_OW 314
39533: NOT
39534: IFFALSE 39583
// begin if not IsInUnit ( j ) then
39536: LD_VAR 0 3
39540: PPUSH
39541: CALL_OW 310
39545: NOT
39546: IFFALSE 39562
// ComEnterUnit ( j , selected ) ;
39548: LD_VAR 0 3
39552: PPUSH
39553: LD_VAR 0 7
39557: PPUSH
39558: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39562: LD_VAR 0 3
39566: PPUSH
39567: LD_INT 16
39569: PPUSH
39570: CALL_OW 183
// AddComExitBuilding ( j ) ;
39574: LD_VAR 0 3
39578: PPUSH
39579: CALL_OW 182
// end ;
39583: GO 39521
39585: POP
39586: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39587: LD_VAR 0 5
39591: PPUSH
39592: LD_INT 11
39594: PPUSH
39595: CALL_OW 325
39599: IFFALSE 39858
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39601: LD_ADDR_VAR 0 4
39605: PUSH
39606: LD_EXP 103
39610: PUSH
39611: LD_VAR 0 2
39615: ARRAY
39616: PPUSH
39617: LD_INT 25
39619: PUSH
39620: LD_INT 16
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PPUSH
39627: CALL_OW 72
39631: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39632: LD_VAR 0 4
39636: PUSH
39637: LD_INT 6
39639: GREATEREQUAL
39640: PUSH
39641: LD_VAR 0 5
39645: PPUSH
39646: LD_INT 2
39648: PPUSH
39649: CALL_OW 325
39653: NOT
39654: OR
39655: IFFALSE 39858
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39657: LD_ADDR_VAR 0 8
39661: PUSH
39662: LD_EXP 74
39666: PUSH
39667: LD_VAR 0 2
39671: ARRAY
39672: PPUSH
39673: LD_INT 2
39675: PUSH
39676: LD_INT 30
39678: PUSH
39679: LD_INT 4
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: LD_INT 30
39688: PUSH
39689: LD_INT 5
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: LIST
39700: PPUSH
39701: CALL_OW 72
39705: ST_TO_ADDR
// if barracks then
39706: LD_VAR 0 8
39710: IFFALSE 39858
// begin selected := 0 ;
39712: LD_ADDR_VAR 0 7
39716: PUSH
39717: LD_INT 0
39719: ST_TO_ADDR
// for j in barracks do
39720: LD_ADDR_VAR 0 3
39724: PUSH
39725: LD_VAR 0 8
39729: PUSH
39730: FOR_IN
39731: IFFALSE 39762
// begin if UnitsInside ( j ) < 6 then
39733: LD_VAR 0 3
39737: PPUSH
39738: CALL_OW 313
39742: PUSH
39743: LD_INT 6
39745: LESS
39746: IFFALSE 39760
// begin selected := j ;
39748: LD_ADDR_VAR 0 7
39752: PUSH
39753: LD_VAR 0 3
39757: ST_TO_ADDR
// break ;
39758: GO 39762
// end ; end ;
39760: GO 39730
39762: POP
39763: POP
// if selected then
39764: LD_VAR 0 7
39768: IFFALSE 39858
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39770: LD_ADDR_VAR 0 3
39774: PUSH
39775: LD_EXP 103
39779: PUSH
39780: LD_VAR 0 2
39784: ARRAY
39785: PPUSH
39786: LD_INT 25
39788: PUSH
39789: LD_INT 12
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PPUSH
39796: CALL_OW 72
39800: PUSH
39801: FOR_IN
39802: IFFALSE 39856
// if not IsInUnit ( j ) and not HasTask ( j ) then
39804: LD_VAR 0 3
39808: PPUSH
39809: CALL_OW 310
39813: NOT
39814: PUSH
39815: LD_VAR 0 3
39819: PPUSH
39820: CALL_OW 314
39824: NOT
39825: AND
39826: IFFALSE 39854
// begin ComEnterUnit ( j , selected ) ;
39828: LD_VAR 0 3
39832: PPUSH
39833: LD_VAR 0 7
39837: PPUSH
39838: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39842: LD_VAR 0 3
39846: PPUSH
39847: LD_INT 15
39849: PPUSH
39850: CALL_OW 183
// end ;
39854: GO 39801
39856: POP
39857: POP
// end ; end ; end ; end ; end ;
39858: GO 39251
39860: POP
39861: POP
// end ;
39862: LD_VAR 0 1
39866: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
39867: LD_INT 0
39869: PPUSH
39870: PPUSH
39871: PPUSH
39872: PPUSH
// if not mc_bases then
39873: LD_EXP 74
39877: NOT
39878: IFFALSE 39882
// exit ;
39880: GO 40060
// for i = 1 to mc_bases do
39882: LD_ADDR_VAR 0 2
39886: PUSH
39887: DOUBLE
39888: LD_INT 1
39890: DEC
39891: ST_TO_ADDR
39892: LD_EXP 74
39896: PUSH
39897: FOR_TO
39898: IFFALSE 40058
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
39900: LD_ADDR_VAR 0 4
39904: PUSH
39905: LD_EXP 74
39909: PUSH
39910: LD_VAR 0 2
39914: ARRAY
39915: PPUSH
39916: LD_INT 25
39918: PUSH
39919: LD_INT 9
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PPUSH
39926: CALL_OW 72
39930: ST_TO_ADDR
// if not tmp then
39931: LD_VAR 0 4
39935: NOT
39936: IFFALSE 39940
// continue ;
39938: GO 39897
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
39940: LD_EXP 100
39944: PUSH
39945: LD_VAR 0 2
39949: ARRAY
39950: PPUSH
39951: LD_INT 29
39953: PPUSH
39954: CALL_OW 325
39958: NOT
39959: PUSH
39960: LD_EXP 100
39964: PUSH
39965: LD_VAR 0 2
39969: ARRAY
39970: PPUSH
39971: LD_INT 28
39973: PPUSH
39974: CALL_OW 325
39978: NOT
39979: AND
39980: IFFALSE 39984
// continue ;
39982: GO 39897
// for j in tmp do
39984: LD_ADDR_VAR 0 3
39988: PUSH
39989: LD_VAR 0 4
39993: PUSH
39994: FOR_IN
39995: IFFALSE 40054
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39997: LD_VAR 0 3
40001: PUSH
40002: LD_EXP 77
40006: PUSH
40007: LD_VAR 0 2
40011: ARRAY
40012: PUSH
40013: LD_INT 1
40015: ARRAY
40016: IN
40017: NOT
40018: PUSH
40019: LD_VAR 0 3
40023: PUSH
40024: LD_EXP 77
40028: PUSH
40029: LD_VAR 0 2
40033: ARRAY
40034: PUSH
40035: LD_INT 2
40037: ARRAY
40038: IN
40039: NOT
40040: AND
40041: IFFALSE 40052
// ComSpaceTimeShoot ( j ) ;
40043: LD_VAR 0 3
40047: PPUSH
40048: CALL 50728 0 1
40052: GO 39994
40054: POP
40055: POP
// end ;
40056: GO 39897
40058: POP
40059: POP
// end ;
40060: LD_VAR 0 1
40064: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40065: LD_INT 0
40067: PPUSH
40068: PPUSH
40069: PPUSH
40070: PPUSH
40071: PPUSH
40072: PPUSH
40073: PPUSH
40074: PPUSH
40075: PPUSH
// if not mc_bases then
40076: LD_EXP 74
40080: NOT
40081: IFFALSE 40085
// exit ;
40083: GO 40707
// for i = 1 to mc_bases do
40085: LD_ADDR_VAR 0 2
40089: PUSH
40090: DOUBLE
40091: LD_INT 1
40093: DEC
40094: ST_TO_ADDR
40095: LD_EXP 74
40099: PUSH
40100: FOR_TO
40101: IFFALSE 40705
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40103: LD_EXP 109
40107: PUSH
40108: LD_VAR 0 2
40112: ARRAY
40113: NOT
40114: PUSH
40115: LD_INT 38
40117: PPUSH
40118: LD_EXP 100
40122: PUSH
40123: LD_VAR 0 2
40127: ARRAY
40128: PPUSH
40129: CALL_OW 321
40133: PUSH
40134: LD_INT 2
40136: NONEQUAL
40137: OR
40138: IFFALSE 40142
// continue ;
40140: GO 40100
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40142: LD_ADDR_VAR 0 8
40146: PUSH
40147: LD_EXP 74
40151: PUSH
40152: LD_VAR 0 2
40156: ARRAY
40157: PPUSH
40158: LD_INT 30
40160: PUSH
40161: LD_INT 34
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PPUSH
40168: CALL_OW 72
40172: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40173: LD_ADDR_VAR 0 9
40177: PUSH
40178: LD_EXP 74
40182: PUSH
40183: LD_VAR 0 2
40187: ARRAY
40188: PPUSH
40189: LD_INT 25
40191: PUSH
40192: LD_INT 4
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PPUSH
40199: CALL_OW 72
40203: PPUSH
40204: LD_INT 0
40206: PPUSH
40207: CALL 90253 0 2
40211: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40212: LD_VAR 0 9
40216: NOT
40217: PUSH
40218: LD_VAR 0 8
40222: NOT
40223: OR
40224: PUSH
40225: LD_EXP 74
40229: PUSH
40230: LD_VAR 0 2
40234: ARRAY
40235: PPUSH
40236: LD_INT 124
40238: PPUSH
40239: CALL 90253 0 2
40243: OR
40244: IFFALSE 40248
// continue ;
40246: GO 40100
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40248: LD_EXP 110
40252: PUSH
40253: LD_VAR 0 2
40257: ARRAY
40258: PUSH
40259: LD_EXP 109
40263: PUSH
40264: LD_VAR 0 2
40268: ARRAY
40269: LESS
40270: PUSH
40271: LD_EXP 110
40275: PUSH
40276: LD_VAR 0 2
40280: ARRAY
40281: PUSH
40282: LD_VAR 0 8
40286: LESS
40287: AND
40288: IFFALSE 40703
// begin tmp := sci [ 1 ] ;
40290: LD_ADDR_VAR 0 7
40294: PUSH
40295: LD_VAR 0 9
40299: PUSH
40300: LD_INT 1
40302: ARRAY
40303: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40304: LD_VAR 0 7
40308: PPUSH
40309: LD_INT 124
40311: PPUSH
40312: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40316: LD_ADDR_VAR 0 3
40320: PUSH
40321: DOUBLE
40322: LD_EXP 109
40326: PUSH
40327: LD_VAR 0 2
40331: ARRAY
40332: INC
40333: ST_TO_ADDR
40334: LD_EXP 109
40338: PUSH
40339: LD_VAR 0 2
40343: ARRAY
40344: PUSH
40345: FOR_DOWNTO
40346: IFFALSE 40689
// begin if IsInUnit ( tmp ) then
40348: LD_VAR 0 7
40352: PPUSH
40353: CALL_OW 310
40357: IFFALSE 40368
// ComExitBuilding ( tmp ) ;
40359: LD_VAR 0 7
40363: PPUSH
40364: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40368: LD_INT 35
40370: PPUSH
40371: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40375: LD_VAR 0 7
40379: PPUSH
40380: CALL_OW 310
40384: NOT
40385: PUSH
40386: LD_VAR 0 7
40390: PPUSH
40391: CALL_OW 314
40395: NOT
40396: AND
40397: IFFALSE 40368
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40399: LD_ADDR_VAR 0 6
40403: PUSH
40404: LD_VAR 0 7
40408: PPUSH
40409: CALL_OW 250
40413: PUSH
40414: LD_VAR 0 7
40418: PPUSH
40419: CALL_OW 251
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40428: LD_INT 35
40430: PPUSH
40431: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40435: LD_ADDR_VAR 0 4
40439: PUSH
40440: LD_EXP 109
40444: PUSH
40445: LD_VAR 0 2
40449: ARRAY
40450: PUSH
40451: LD_VAR 0 3
40455: ARRAY
40456: PUSH
40457: LD_INT 1
40459: ARRAY
40460: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40461: LD_ADDR_VAR 0 5
40465: PUSH
40466: LD_EXP 109
40470: PUSH
40471: LD_VAR 0 2
40475: ARRAY
40476: PUSH
40477: LD_VAR 0 3
40481: ARRAY
40482: PUSH
40483: LD_INT 2
40485: ARRAY
40486: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40487: LD_VAR 0 7
40491: PPUSH
40492: LD_INT 10
40494: PPUSH
40495: CALL 59586 0 2
40499: PUSH
40500: LD_INT 4
40502: ARRAY
40503: IFFALSE 40541
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40505: LD_VAR 0 7
40509: PPUSH
40510: LD_VAR 0 6
40514: PUSH
40515: LD_INT 1
40517: ARRAY
40518: PPUSH
40519: LD_VAR 0 6
40523: PUSH
40524: LD_INT 2
40526: ARRAY
40527: PPUSH
40528: CALL_OW 111
// wait ( 0 0$10 ) ;
40532: LD_INT 350
40534: PPUSH
40535: CALL_OW 67
// end else
40539: GO 40567
// begin ComMoveXY ( tmp , x , y ) ;
40541: LD_VAR 0 7
40545: PPUSH
40546: LD_VAR 0 4
40550: PPUSH
40551: LD_VAR 0 5
40555: PPUSH
40556: CALL_OW 111
// wait ( 0 0$3 ) ;
40560: LD_INT 105
40562: PPUSH
40563: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40567: LD_VAR 0 7
40571: PPUSH
40572: LD_VAR 0 4
40576: PPUSH
40577: LD_VAR 0 5
40581: PPUSH
40582: CALL_OW 307
40586: IFFALSE 40428
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40588: LD_VAR 0 7
40592: PPUSH
40593: LD_VAR 0 4
40597: PPUSH
40598: LD_VAR 0 5
40602: PPUSH
40603: LD_VAR 0 8
40607: PUSH
40608: LD_VAR 0 3
40612: ARRAY
40613: PPUSH
40614: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40618: LD_INT 35
40620: PPUSH
40621: CALL_OW 67
// until not HasTask ( tmp ) ;
40625: LD_VAR 0 7
40629: PPUSH
40630: CALL_OW 314
40634: NOT
40635: IFFALSE 40618
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40637: LD_ADDR_EXP 110
40641: PUSH
40642: LD_EXP 110
40646: PPUSH
40647: LD_VAR 0 2
40651: PUSH
40652: LD_EXP 110
40656: PUSH
40657: LD_VAR 0 2
40661: ARRAY
40662: PUSH
40663: LD_INT 1
40665: PLUS
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PPUSH
40671: LD_VAR 0 8
40675: PUSH
40676: LD_VAR 0 3
40680: ARRAY
40681: PPUSH
40682: CALL 56993 0 3
40686: ST_TO_ADDR
// end ;
40687: GO 40345
40689: POP
40690: POP
// MC_Reset ( i , 124 ) ;
40691: LD_VAR 0 2
40695: PPUSH
40696: LD_INT 124
40698: PPUSH
40699: CALL 24190 0 2
// end ; end ;
40703: GO 40100
40705: POP
40706: POP
// end ;
40707: LD_VAR 0 1
40711: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40712: LD_INT 0
40714: PPUSH
40715: PPUSH
40716: PPUSH
// if not mc_bases then
40717: LD_EXP 74
40721: NOT
40722: IFFALSE 40726
// exit ;
40724: GO 41332
// for i = 1 to mc_bases do
40726: LD_ADDR_VAR 0 2
40730: PUSH
40731: DOUBLE
40732: LD_INT 1
40734: DEC
40735: ST_TO_ADDR
40736: LD_EXP 74
40740: PUSH
40741: FOR_TO
40742: IFFALSE 41330
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40744: LD_ADDR_VAR 0 3
40748: PUSH
40749: LD_EXP 74
40753: PUSH
40754: LD_VAR 0 2
40758: ARRAY
40759: PPUSH
40760: LD_INT 25
40762: PUSH
40763: LD_INT 4
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PPUSH
40770: CALL_OW 72
40774: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40775: LD_VAR 0 3
40779: NOT
40780: PUSH
40781: LD_EXP 111
40785: PUSH
40786: LD_VAR 0 2
40790: ARRAY
40791: NOT
40792: OR
40793: PUSH
40794: LD_EXP 74
40798: PUSH
40799: LD_VAR 0 2
40803: ARRAY
40804: PPUSH
40805: LD_INT 2
40807: PUSH
40808: LD_INT 30
40810: PUSH
40811: LD_INT 0
40813: PUSH
40814: EMPTY
40815: LIST
40816: LIST
40817: PUSH
40818: LD_INT 30
40820: PUSH
40821: LD_INT 1
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: LIST
40832: PPUSH
40833: CALL_OW 72
40837: NOT
40838: OR
40839: IFFALSE 40889
// begin if mc_deposits_finder [ i ] then
40841: LD_EXP 112
40845: PUSH
40846: LD_VAR 0 2
40850: ARRAY
40851: IFFALSE 40887
// begin MC_Reset ( i , 125 ) ;
40853: LD_VAR 0 2
40857: PPUSH
40858: LD_INT 125
40860: PPUSH
40861: CALL 24190 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40865: LD_ADDR_EXP 112
40869: PUSH
40870: LD_EXP 112
40874: PPUSH
40875: LD_VAR 0 2
40879: PPUSH
40880: EMPTY
40881: PPUSH
40882: CALL_OW 1
40886: ST_TO_ADDR
// end ; continue ;
40887: GO 40741
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
40889: LD_EXP 111
40893: PUSH
40894: LD_VAR 0 2
40898: ARRAY
40899: PUSH
40900: LD_INT 1
40902: ARRAY
40903: PUSH
40904: LD_INT 3
40906: ARRAY
40907: PUSH
40908: LD_INT 1
40910: EQUAL
40911: PUSH
40912: LD_INT 20
40914: PPUSH
40915: LD_EXP 100
40919: PUSH
40920: LD_VAR 0 2
40924: ARRAY
40925: PPUSH
40926: CALL_OW 321
40930: PUSH
40931: LD_INT 2
40933: NONEQUAL
40934: AND
40935: IFFALSE 40985
// begin if mc_deposits_finder [ i ] then
40937: LD_EXP 112
40941: PUSH
40942: LD_VAR 0 2
40946: ARRAY
40947: IFFALSE 40983
// begin MC_Reset ( i , 125 ) ;
40949: LD_VAR 0 2
40953: PPUSH
40954: LD_INT 125
40956: PPUSH
40957: CALL 24190 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40961: LD_ADDR_EXP 112
40965: PUSH
40966: LD_EXP 112
40970: PPUSH
40971: LD_VAR 0 2
40975: PPUSH
40976: EMPTY
40977: PPUSH
40978: CALL_OW 1
40982: ST_TO_ADDR
// end ; continue ;
40983: GO 40741
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
40985: LD_EXP 111
40989: PUSH
40990: LD_VAR 0 2
40994: ARRAY
40995: PUSH
40996: LD_INT 1
40998: ARRAY
40999: PUSH
41000: LD_INT 1
41002: ARRAY
41003: PPUSH
41004: LD_EXP 111
41008: PUSH
41009: LD_VAR 0 2
41013: ARRAY
41014: PUSH
41015: LD_INT 1
41017: ARRAY
41018: PUSH
41019: LD_INT 2
41021: ARRAY
41022: PPUSH
41023: LD_EXP 100
41027: PUSH
41028: LD_VAR 0 2
41032: ARRAY
41033: PPUSH
41034: CALL_OW 440
41038: IFFALSE 41081
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41040: LD_ADDR_EXP 111
41044: PUSH
41045: LD_EXP 111
41049: PPUSH
41050: LD_VAR 0 2
41054: PPUSH
41055: LD_EXP 111
41059: PUSH
41060: LD_VAR 0 2
41064: ARRAY
41065: PPUSH
41066: LD_INT 1
41068: PPUSH
41069: CALL_OW 3
41073: PPUSH
41074: CALL_OW 1
41078: ST_TO_ADDR
41079: GO 41328
// begin if not mc_deposits_finder [ i ] then
41081: LD_EXP 112
41085: PUSH
41086: LD_VAR 0 2
41090: ARRAY
41091: NOT
41092: IFFALSE 41144
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41094: LD_ADDR_EXP 112
41098: PUSH
41099: LD_EXP 112
41103: PPUSH
41104: LD_VAR 0 2
41108: PPUSH
41109: LD_VAR 0 3
41113: PUSH
41114: LD_INT 1
41116: ARRAY
41117: PUSH
41118: EMPTY
41119: LIST
41120: PPUSH
41121: CALL_OW 1
41125: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41126: LD_VAR 0 3
41130: PUSH
41131: LD_INT 1
41133: ARRAY
41134: PPUSH
41135: LD_INT 125
41137: PPUSH
41138: CALL_OW 109
// end else
41142: GO 41328
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41144: LD_EXP 112
41148: PUSH
41149: LD_VAR 0 2
41153: ARRAY
41154: PUSH
41155: LD_INT 1
41157: ARRAY
41158: PPUSH
41159: CALL_OW 310
41163: IFFALSE 41186
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41165: LD_EXP 112
41169: PUSH
41170: LD_VAR 0 2
41174: ARRAY
41175: PUSH
41176: LD_INT 1
41178: ARRAY
41179: PPUSH
41180: CALL_OW 122
41184: GO 41328
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41186: LD_EXP 112
41190: PUSH
41191: LD_VAR 0 2
41195: ARRAY
41196: PUSH
41197: LD_INT 1
41199: ARRAY
41200: PPUSH
41201: CALL_OW 314
41205: NOT
41206: PUSH
41207: LD_EXP 112
41211: PUSH
41212: LD_VAR 0 2
41216: ARRAY
41217: PUSH
41218: LD_INT 1
41220: ARRAY
41221: PPUSH
41222: LD_EXP 111
41226: PUSH
41227: LD_VAR 0 2
41231: ARRAY
41232: PUSH
41233: LD_INT 1
41235: ARRAY
41236: PUSH
41237: LD_INT 1
41239: ARRAY
41240: PPUSH
41241: LD_EXP 111
41245: PUSH
41246: LD_VAR 0 2
41250: ARRAY
41251: PUSH
41252: LD_INT 1
41254: ARRAY
41255: PUSH
41256: LD_INT 2
41258: ARRAY
41259: PPUSH
41260: CALL_OW 297
41264: PUSH
41265: LD_INT 6
41267: GREATER
41268: AND
41269: IFFALSE 41328
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41271: LD_EXP 112
41275: PUSH
41276: LD_VAR 0 2
41280: ARRAY
41281: PUSH
41282: LD_INT 1
41284: ARRAY
41285: PPUSH
41286: LD_EXP 111
41290: PUSH
41291: LD_VAR 0 2
41295: ARRAY
41296: PUSH
41297: LD_INT 1
41299: ARRAY
41300: PUSH
41301: LD_INT 1
41303: ARRAY
41304: PPUSH
41305: LD_EXP 111
41309: PUSH
41310: LD_VAR 0 2
41314: ARRAY
41315: PUSH
41316: LD_INT 1
41318: ARRAY
41319: PUSH
41320: LD_INT 2
41322: ARRAY
41323: PPUSH
41324: CALL_OW 111
// end ; end ; end ;
41328: GO 40741
41330: POP
41331: POP
// end ;
41332: LD_VAR 0 1
41336: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41337: LD_INT 0
41339: PPUSH
41340: PPUSH
41341: PPUSH
41342: PPUSH
41343: PPUSH
41344: PPUSH
41345: PPUSH
41346: PPUSH
41347: PPUSH
41348: PPUSH
41349: PPUSH
// if not mc_bases then
41350: LD_EXP 74
41354: NOT
41355: IFFALSE 41359
// exit ;
41357: GO 42083
// for i = 1 to mc_bases do
41359: LD_ADDR_VAR 0 2
41363: PUSH
41364: DOUBLE
41365: LD_INT 1
41367: DEC
41368: ST_TO_ADDR
41369: LD_EXP 74
41373: PUSH
41374: FOR_TO
41375: IFFALSE 42081
// begin if not mc_bases [ i ] then
41377: LD_EXP 74
41381: PUSH
41382: LD_VAR 0 2
41386: ARRAY
41387: NOT
41388: IFFALSE 41392
// continue ;
41390: GO 41374
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41392: LD_ADDR_VAR 0 7
41396: PUSH
41397: LD_EXP 74
41401: PUSH
41402: LD_VAR 0 2
41406: ARRAY
41407: PUSH
41408: LD_INT 1
41410: ARRAY
41411: PPUSH
41412: CALL_OW 248
41416: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41417: LD_VAR 0 7
41421: PUSH
41422: LD_INT 3
41424: EQUAL
41425: PUSH
41426: LD_EXP 93
41430: PUSH
41431: LD_VAR 0 2
41435: ARRAY
41436: PUSH
41437: LD_EXP 96
41441: PUSH
41442: LD_VAR 0 2
41446: ARRAY
41447: UNION
41448: PPUSH
41449: LD_INT 33
41451: PUSH
41452: LD_INT 2
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PPUSH
41459: CALL_OW 72
41463: NOT
41464: OR
41465: IFFALSE 41469
// continue ;
41467: GO 41374
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41469: LD_ADDR_VAR 0 9
41473: PUSH
41474: LD_EXP 74
41478: PUSH
41479: LD_VAR 0 2
41483: ARRAY
41484: PPUSH
41485: LD_INT 30
41487: PUSH
41488: LD_INT 36
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PPUSH
41495: CALL_OW 72
41499: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41500: LD_ADDR_VAR 0 10
41504: PUSH
41505: LD_EXP 93
41509: PUSH
41510: LD_VAR 0 2
41514: ARRAY
41515: PPUSH
41516: LD_INT 34
41518: PUSH
41519: LD_INT 31
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: PPUSH
41526: CALL_OW 72
41530: ST_TO_ADDR
// if not cts and not mcts then
41531: LD_VAR 0 9
41535: NOT
41536: PUSH
41537: LD_VAR 0 10
41541: NOT
41542: AND
41543: IFFALSE 41547
// continue ;
41545: GO 41374
// x := cts ;
41547: LD_ADDR_VAR 0 11
41551: PUSH
41552: LD_VAR 0 9
41556: ST_TO_ADDR
// if not x then
41557: LD_VAR 0 11
41561: NOT
41562: IFFALSE 41574
// x := mcts ;
41564: LD_ADDR_VAR 0 11
41568: PUSH
41569: LD_VAR 0 10
41573: ST_TO_ADDR
// if mc_remote_driver [ i ] then
41574: LD_EXP 114
41578: PUSH
41579: LD_VAR 0 2
41583: ARRAY
41584: IFFALSE 41853
// for j in mc_remote_driver [ i ] do
41586: LD_ADDR_VAR 0 3
41590: PUSH
41591: LD_EXP 114
41595: PUSH
41596: LD_VAR 0 2
41600: ARRAY
41601: PUSH
41602: FOR_IN
41603: IFFALSE 41851
// begin if GetClass ( j ) <> 3 then
41605: LD_VAR 0 3
41609: PPUSH
41610: CALL_OW 257
41614: PUSH
41615: LD_INT 3
41617: NONEQUAL
41618: IFFALSE 41671
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41620: LD_ADDR_EXP 114
41624: PUSH
41625: LD_EXP 114
41629: PPUSH
41630: LD_VAR 0 2
41634: PPUSH
41635: LD_EXP 114
41639: PUSH
41640: LD_VAR 0 2
41644: ARRAY
41645: PUSH
41646: LD_VAR 0 3
41650: DIFF
41651: PPUSH
41652: CALL_OW 1
41656: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41657: LD_VAR 0 3
41661: PPUSH
41662: LD_INT 0
41664: PPUSH
41665: CALL_OW 109
// continue ;
41669: GO 41602
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41671: LD_VAR 0 3
41675: PPUSH
41676: CALL_OW 310
41680: NOT
41681: PUSH
41682: LD_VAR 0 3
41686: PPUSH
41687: CALL_OW 310
41691: PPUSH
41692: CALL_OW 266
41696: PUSH
41697: LD_INT 36
41699: NONEQUAL
41700: PUSH
41701: LD_VAR 0 3
41705: PPUSH
41706: CALL 90341 0 1
41710: NOT
41711: AND
41712: OR
41713: IFFALSE 41849
// begin if IsInUnit ( j ) then
41715: LD_VAR 0 3
41719: PPUSH
41720: CALL_OW 310
41724: IFFALSE 41735
// ComExitBuilding ( j ) ;
41726: LD_VAR 0 3
41730: PPUSH
41731: CALL_OW 122
// ct := 0 ;
41735: LD_ADDR_VAR 0 8
41739: PUSH
41740: LD_INT 0
41742: ST_TO_ADDR
// for k in x do
41743: LD_ADDR_VAR 0 4
41747: PUSH
41748: LD_VAR 0 11
41752: PUSH
41753: FOR_IN
41754: IFFALSE 41827
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
41756: LD_VAR 0 4
41760: PPUSH
41761: CALL_OW 264
41765: PUSH
41766: LD_INT 31
41768: EQUAL
41769: PUSH
41770: LD_VAR 0 4
41774: PPUSH
41775: CALL_OW 311
41779: NOT
41780: AND
41781: PUSH
41782: LD_VAR 0 4
41786: PPUSH
41787: CALL_OW 266
41791: PUSH
41792: LD_INT 36
41794: EQUAL
41795: PUSH
41796: LD_VAR 0 4
41800: PPUSH
41801: CALL_OW 313
41805: PUSH
41806: LD_INT 3
41808: LESS
41809: AND
41810: OR
41811: IFFALSE 41825
// begin ct := k ;
41813: LD_ADDR_VAR 0 8
41817: PUSH
41818: LD_VAR 0 4
41822: ST_TO_ADDR
// break ;
41823: GO 41827
// end ;
41825: GO 41753
41827: POP
41828: POP
// if ct then
41829: LD_VAR 0 8
41833: IFFALSE 41849
// ComEnterUnit ( j , ct ) ;
41835: LD_VAR 0 3
41839: PPUSH
41840: LD_VAR 0 8
41844: PPUSH
41845: CALL_OW 120
// end ; end ;
41849: GO 41602
41851: POP
41852: POP
// places := 0 ;
41853: LD_ADDR_VAR 0 5
41857: PUSH
41858: LD_INT 0
41860: ST_TO_ADDR
// for j = 1 to x do
41861: LD_ADDR_VAR 0 3
41865: PUSH
41866: DOUBLE
41867: LD_INT 1
41869: DEC
41870: ST_TO_ADDR
41871: LD_VAR 0 11
41875: PUSH
41876: FOR_TO
41877: IFFALSE 41932
// if GetWeapon ( x [ j ] ) = ar_control_tower then
41879: LD_VAR 0 11
41883: PUSH
41884: LD_VAR 0 3
41888: ARRAY
41889: PPUSH
41890: CALL_OW 264
41894: PUSH
41895: LD_INT 31
41897: EQUAL
41898: IFFALSE 41916
// places := places + 1 else
41900: LD_ADDR_VAR 0 5
41904: PUSH
41905: LD_VAR 0 5
41909: PUSH
41910: LD_INT 1
41912: PLUS
41913: ST_TO_ADDR
41914: GO 41930
// places := places + 3 ;
41916: LD_ADDR_VAR 0 5
41920: PUSH
41921: LD_VAR 0 5
41925: PUSH
41926: LD_INT 3
41928: PLUS
41929: ST_TO_ADDR
41930: GO 41876
41932: POP
41933: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
41934: LD_ADDR_VAR 0 6
41938: PUSH
41939: LD_EXP 74
41943: PUSH
41944: LD_VAR 0 2
41948: ARRAY
41949: PPUSH
41950: LD_INT 25
41952: PUSH
41953: LD_INT 3
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PPUSH
41960: CALL_OW 72
41964: PUSH
41965: LD_EXP 114
41969: PUSH
41970: LD_VAR 0 2
41974: ARRAY
41975: DIFF
41976: PPUSH
41977: LD_INT 3
41979: PPUSH
41980: CALL 91241 0 2
41984: ST_TO_ADDR
// if not tmp then
41985: LD_VAR 0 6
41989: NOT
41990: IFFALSE 41994
// continue ;
41992: GO 41374
// places := places - mc_remote_driver [ i ] ;
41994: LD_ADDR_VAR 0 5
41998: PUSH
41999: LD_VAR 0 5
42003: PUSH
42004: LD_EXP 114
42008: PUSH
42009: LD_VAR 0 2
42013: ARRAY
42014: MINUS
42015: ST_TO_ADDR
// if places then
42016: LD_VAR 0 5
42020: IFFALSE 42079
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42022: LD_ADDR_EXP 114
42026: PUSH
42027: LD_EXP 114
42031: PPUSH
42032: LD_VAR 0 2
42036: PPUSH
42037: LD_EXP 114
42041: PUSH
42042: LD_VAR 0 2
42046: ARRAY
42047: PUSH
42048: LD_VAR 0 6
42052: PUSH
42053: LD_INT 1
42055: ARRAY
42056: UNION
42057: PPUSH
42058: CALL_OW 1
42062: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42063: LD_VAR 0 6
42067: PUSH
42068: LD_INT 1
42070: ARRAY
42071: PPUSH
42072: LD_INT 126
42074: PPUSH
42075: CALL_OW 109
// end ; end ;
42079: GO 41374
42081: POP
42082: POP
// end ;
42083: LD_VAR 0 1
42087: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42088: LD_INT 0
42090: PPUSH
42091: PPUSH
42092: PPUSH
42093: PPUSH
42094: PPUSH
42095: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42096: LD_VAR 0 1
42100: NOT
42101: PUSH
42102: LD_VAR 0 2
42106: NOT
42107: OR
42108: PUSH
42109: LD_VAR 0 3
42113: NOT
42114: OR
42115: PUSH
42116: LD_VAR 0 4
42120: PUSH
42121: LD_INT 1
42123: PUSH
42124: LD_INT 2
42126: PUSH
42127: LD_INT 3
42129: PUSH
42130: LD_INT 4
42132: PUSH
42133: LD_INT 5
42135: PUSH
42136: LD_INT 8
42138: PUSH
42139: LD_INT 9
42141: PUSH
42142: LD_INT 15
42144: PUSH
42145: LD_INT 16
42147: PUSH
42148: EMPTY
42149: LIST
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: IN
42159: NOT
42160: OR
42161: IFFALSE 42165
// exit ;
42163: GO 43065
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42165: LD_ADDR_VAR 0 2
42169: PUSH
42170: LD_VAR 0 2
42174: PPUSH
42175: LD_INT 21
42177: PUSH
42178: LD_INT 3
42180: PUSH
42181: EMPTY
42182: LIST
42183: LIST
42184: PUSH
42185: LD_INT 24
42187: PUSH
42188: LD_INT 250
42190: PUSH
42191: EMPTY
42192: LIST
42193: LIST
42194: PUSH
42195: EMPTY
42196: LIST
42197: LIST
42198: PPUSH
42199: CALL_OW 72
42203: ST_TO_ADDR
// case class of 1 , 15 :
42204: LD_VAR 0 4
42208: PUSH
42209: LD_INT 1
42211: DOUBLE
42212: EQUAL
42213: IFTRUE 42223
42215: LD_INT 15
42217: DOUBLE
42218: EQUAL
42219: IFTRUE 42223
42221: GO 42308
42223: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42224: LD_ADDR_VAR 0 8
42228: PUSH
42229: LD_VAR 0 2
42233: PPUSH
42234: LD_INT 2
42236: PUSH
42237: LD_INT 30
42239: PUSH
42240: LD_INT 32
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 30
42249: PUSH
42250: LD_INT 31
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: LIST
42261: PPUSH
42262: CALL_OW 72
42266: PUSH
42267: LD_VAR 0 2
42271: PPUSH
42272: LD_INT 2
42274: PUSH
42275: LD_INT 30
42277: PUSH
42278: LD_INT 4
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 30
42287: PUSH
42288: LD_INT 5
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: LIST
42299: PPUSH
42300: CALL_OW 72
42304: ADD
42305: ST_TO_ADDR
42306: GO 42554
42308: LD_INT 2
42310: DOUBLE
42311: EQUAL
42312: IFTRUE 42322
42314: LD_INT 16
42316: DOUBLE
42317: EQUAL
42318: IFTRUE 42322
42320: GO 42368
42322: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42323: LD_ADDR_VAR 0 8
42327: PUSH
42328: LD_VAR 0 2
42332: PPUSH
42333: LD_INT 2
42335: PUSH
42336: LD_INT 30
42338: PUSH
42339: LD_INT 0
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 30
42348: PUSH
42349: LD_INT 1
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: LIST
42360: PPUSH
42361: CALL_OW 72
42365: ST_TO_ADDR
42366: GO 42554
42368: LD_INT 3
42370: DOUBLE
42371: EQUAL
42372: IFTRUE 42376
42374: GO 42422
42376: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42377: LD_ADDR_VAR 0 8
42381: PUSH
42382: LD_VAR 0 2
42386: PPUSH
42387: LD_INT 2
42389: PUSH
42390: LD_INT 30
42392: PUSH
42393: LD_INT 2
42395: PUSH
42396: EMPTY
42397: LIST
42398: LIST
42399: PUSH
42400: LD_INT 30
42402: PUSH
42403: LD_INT 3
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: LIST
42414: PPUSH
42415: CALL_OW 72
42419: ST_TO_ADDR
42420: GO 42554
42422: LD_INT 4
42424: DOUBLE
42425: EQUAL
42426: IFTRUE 42430
42428: GO 42487
42430: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42431: LD_ADDR_VAR 0 8
42435: PUSH
42436: LD_VAR 0 2
42440: PPUSH
42441: LD_INT 2
42443: PUSH
42444: LD_INT 30
42446: PUSH
42447: LD_INT 6
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: LD_INT 30
42456: PUSH
42457: LD_INT 7
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 30
42466: PUSH
42467: LD_INT 8
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: LIST
42478: LIST
42479: PPUSH
42480: CALL_OW 72
42484: ST_TO_ADDR
42485: GO 42554
42487: LD_INT 5
42489: DOUBLE
42490: EQUAL
42491: IFTRUE 42507
42493: LD_INT 8
42495: DOUBLE
42496: EQUAL
42497: IFTRUE 42507
42499: LD_INT 9
42501: DOUBLE
42502: EQUAL
42503: IFTRUE 42507
42505: GO 42553
42507: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42508: LD_ADDR_VAR 0 8
42512: PUSH
42513: LD_VAR 0 2
42517: PPUSH
42518: LD_INT 2
42520: PUSH
42521: LD_INT 30
42523: PUSH
42524: LD_INT 4
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: LD_INT 30
42533: PUSH
42534: LD_INT 5
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: LIST
42545: PPUSH
42546: CALL_OW 72
42550: ST_TO_ADDR
42551: GO 42554
42553: POP
// if not tmp then
42554: LD_VAR 0 8
42558: NOT
42559: IFFALSE 42563
// exit ;
42561: GO 43065
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42563: LD_VAR 0 4
42567: PUSH
42568: LD_INT 1
42570: PUSH
42571: LD_INT 15
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: IN
42578: PUSH
42579: LD_EXP 83
42583: PUSH
42584: LD_VAR 0 1
42588: ARRAY
42589: AND
42590: IFFALSE 42746
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42592: LD_ADDR_VAR 0 9
42596: PUSH
42597: LD_EXP 83
42601: PUSH
42602: LD_VAR 0 1
42606: ARRAY
42607: PUSH
42608: LD_INT 1
42610: ARRAY
42611: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42612: LD_VAR 0 9
42616: PUSH
42617: LD_EXP 84
42621: PUSH
42622: LD_VAR 0 1
42626: ARRAY
42627: IN
42628: NOT
42629: IFFALSE 42744
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42631: LD_ADDR_EXP 84
42635: PUSH
42636: LD_EXP 84
42640: PPUSH
42641: LD_VAR 0 1
42645: PUSH
42646: LD_EXP 84
42650: PUSH
42651: LD_VAR 0 1
42655: ARRAY
42656: PUSH
42657: LD_INT 1
42659: PLUS
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: PPUSH
42665: LD_VAR 0 9
42669: PPUSH
42670: CALL 56993 0 3
42674: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
42675: LD_ADDR_EXP 83
42679: PUSH
42680: LD_EXP 83
42684: PPUSH
42685: LD_VAR 0 1
42689: PPUSH
42690: LD_EXP 83
42694: PUSH
42695: LD_VAR 0 1
42699: ARRAY
42700: PUSH
42701: LD_VAR 0 9
42705: DIFF
42706: PPUSH
42707: CALL_OW 1
42711: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
42712: LD_VAR 0 3
42716: PPUSH
42717: LD_EXP 84
42721: PUSH
42722: LD_VAR 0 1
42726: ARRAY
42727: PUSH
42728: LD_EXP 84
42732: PUSH
42733: LD_VAR 0 1
42737: ARRAY
42738: ARRAY
42739: PPUSH
42740: CALL_OW 120
// end ; exit ;
42744: GO 43065
// end ; if tmp > 1 then
42746: LD_VAR 0 8
42750: PUSH
42751: LD_INT 1
42753: GREATER
42754: IFFALSE 42858
// for i = 2 to tmp do
42756: LD_ADDR_VAR 0 6
42760: PUSH
42761: DOUBLE
42762: LD_INT 2
42764: DEC
42765: ST_TO_ADDR
42766: LD_VAR 0 8
42770: PUSH
42771: FOR_TO
42772: IFFALSE 42856
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
42774: LD_VAR 0 8
42778: PUSH
42779: LD_VAR 0 6
42783: ARRAY
42784: PPUSH
42785: CALL_OW 461
42789: PUSH
42790: LD_INT 6
42792: EQUAL
42793: IFFALSE 42854
// begin x := tmp [ i ] ;
42795: LD_ADDR_VAR 0 9
42799: PUSH
42800: LD_VAR 0 8
42804: PUSH
42805: LD_VAR 0 6
42809: ARRAY
42810: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
42811: LD_ADDR_VAR 0 8
42815: PUSH
42816: LD_VAR 0 8
42820: PPUSH
42821: LD_VAR 0 6
42825: PPUSH
42826: CALL_OW 3
42830: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
42831: LD_ADDR_VAR 0 8
42835: PUSH
42836: LD_VAR 0 8
42840: PPUSH
42841: LD_INT 1
42843: PPUSH
42844: LD_VAR 0 9
42848: PPUSH
42849: CALL_OW 2
42853: ST_TO_ADDR
// end ;
42854: GO 42771
42856: POP
42857: POP
// for i in tmp do
42858: LD_ADDR_VAR 0 6
42862: PUSH
42863: LD_VAR 0 8
42867: PUSH
42868: FOR_IN
42869: IFFALSE 42938
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
42871: LD_VAR 0 6
42875: PPUSH
42876: CALL_OW 313
42880: PUSH
42881: LD_INT 6
42883: LESS
42884: PUSH
42885: LD_VAR 0 6
42889: PPUSH
42890: CALL_OW 266
42894: PUSH
42895: LD_INT 31
42897: PUSH
42898: LD_INT 32
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: IN
42905: NOT
42906: AND
42907: PUSH
42908: LD_VAR 0 6
42912: PPUSH
42913: CALL_OW 313
42917: PUSH
42918: LD_INT 0
42920: EQUAL
42921: OR
42922: IFFALSE 42936
// begin j := i ;
42924: LD_ADDR_VAR 0 7
42928: PUSH
42929: LD_VAR 0 6
42933: ST_TO_ADDR
// break ;
42934: GO 42938
// end ; end ;
42936: GO 42868
42938: POP
42939: POP
// if j then
42940: LD_VAR 0 7
42944: IFFALSE 42962
// ComEnterUnit ( unit , j ) else
42946: LD_VAR 0 3
42950: PPUSH
42951: LD_VAR 0 7
42955: PPUSH
42956: CALL_OW 120
42960: GO 43065
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42962: LD_ADDR_VAR 0 10
42966: PUSH
42967: LD_VAR 0 2
42971: PPUSH
42972: LD_INT 2
42974: PUSH
42975: LD_INT 30
42977: PUSH
42978: LD_INT 0
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 30
42987: PUSH
42988: LD_INT 1
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: LIST
42999: PPUSH
43000: CALL_OW 72
43004: ST_TO_ADDR
// if depot then
43005: LD_VAR 0 10
43009: IFFALSE 43065
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43011: LD_ADDR_VAR 0 10
43015: PUSH
43016: LD_VAR 0 10
43020: PPUSH
43021: LD_VAR 0 3
43025: PPUSH
43026: CALL_OW 74
43030: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43031: LD_VAR 0 3
43035: PPUSH
43036: LD_VAR 0 10
43040: PPUSH
43041: CALL_OW 296
43045: PUSH
43046: LD_INT 10
43048: GREATER
43049: IFFALSE 43065
// ComStandNearbyBuilding ( unit , depot ) ;
43051: LD_VAR 0 3
43055: PPUSH
43056: LD_VAR 0 10
43060: PPUSH
43061: CALL 51345 0 2
// end ; end ; end ;
43065: LD_VAR 0 5
43069: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43070: LD_INT 0
43072: PPUSH
43073: PPUSH
43074: PPUSH
43075: PPUSH
// if not mc_bases then
43076: LD_EXP 74
43080: NOT
43081: IFFALSE 43085
// exit ;
43083: GO 43324
// for i = 1 to mc_bases do
43085: LD_ADDR_VAR 0 2
43089: PUSH
43090: DOUBLE
43091: LD_INT 1
43093: DEC
43094: ST_TO_ADDR
43095: LD_EXP 74
43099: PUSH
43100: FOR_TO
43101: IFFALSE 43322
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43103: LD_ADDR_VAR 0 4
43107: PUSH
43108: LD_EXP 74
43112: PUSH
43113: LD_VAR 0 2
43117: ARRAY
43118: PPUSH
43119: LD_INT 21
43121: PUSH
43122: LD_INT 1
43124: PUSH
43125: EMPTY
43126: LIST
43127: LIST
43128: PPUSH
43129: CALL_OW 72
43133: PUSH
43134: LD_EXP 103
43138: PUSH
43139: LD_VAR 0 2
43143: ARRAY
43144: UNION
43145: ST_TO_ADDR
// if not tmp then
43146: LD_VAR 0 4
43150: NOT
43151: IFFALSE 43155
// continue ;
43153: GO 43100
// for j in tmp do
43155: LD_ADDR_VAR 0 3
43159: PUSH
43160: LD_VAR 0 4
43164: PUSH
43165: FOR_IN
43166: IFFALSE 43318
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43168: LD_VAR 0 3
43172: PPUSH
43173: CALL_OW 110
43177: NOT
43178: PUSH
43179: LD_VAR 0 3
43183: PPUSH
43184: CALL_OW 314
43188: NOT
43189: AND
43190: PUSH
43191: LD_VAR 0 3
43195: PPUSH
43196: CALL_OW 311
43200: NOT
43201: AND
43202: PUSH
43203: LD_VAR 0 3
43207: PPUSH
43208: CALL_OW 310
43212: NOT
43213: AND
43214: PUSH
43215: LD_VAR 0 3
43219: PUSH
43220: LD_EXP 77
43224: PUSH
43225: LD_VAR 0 2
43229: ARRAY
43230: PUSH
43231: LD_INT 1
43233: ARRAY
43234: IN
43235: NOT
43236: AND
43237: PUSH
43238: LD_VAR 0 3
43242: PUSH
43243: LD_EXP 77
43247: PUSH
43248: LD_VAR 0 2
43252: ARRAY
43253: PUSH
43254: LD_INT 2
43256: ARRAY
43257: IN
43258: NOT
43259: AND
43260: PUSH
43261: LD_VAR 0 3
43265: PUSH
43266: LD_EXP 86
43270: PUSH
43271: LD_VAR 0 2
43275: ARRAY
43276: IN
43277: NOT
43278: AND
43279: IFFALSE 43316
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43281: LD_VAR 0 2
43285: PPUSH
43286: LD_EXP 74
43290: PUSH
43291: LD_VAR 0 2
43295: ARRAY
43296: PPUSH
43297: LD_VAR 0 3
43301: PPUSH
43302: LD_VAR 0 3
43306: PPUSH
43307: CALL_OW 257
43311: PPUSH
43312: CALL 42088 0 4
// end ;
43316: GO 43165
43318: POP
43319: POP
// end ;
43320: GO 43100
43322: POP
43323: POP
// end ;
43324: LD_VAR 0 1
43328: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43329: LD_INT 0
43331: PPUSH
43332: PPUSH
43333: PPUSH
43334: PPUSH
43335: PPUSH
43336: PPUSH
// if not mc_bases [ base ] then
43337: LD_EXP 74
43341: PUSH
43342: LD_VAR 0 1
43346: ARRAY
43347: NOT
43348: IFFALSE 43352
// exit ;
43350: GO 43534
// tmp := [ ] ;
43352: LD_ADDR_VAR 0 6
43356: PUSH
43357: EMPTY
43358: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43359: LD_ADDR_VAR 0 7
43363: PUSH
43364: LD_VAR 0 3
43368: PPUSH
43369: LD_INT 0
43371: PPUSH
43372: CALL_OW 517
43376: ST_TO_ADDR
// if not list then
43377: LD_VAR 0 7
43381: NOT
43382: IFFALSE 43386
// exit ;
43384: GO 43534
// for i = 1 to amount do
43386: LD_ADDR_VAR 0 5
43390: PUSH
43391: DOUBLE
43392: LD_INT 1
43394: DEC
43395: ST_TO_ADDR
43396: LD_VAR 0 2
43400: PUSH
43401: FOR_TO
43402: IFFALSE 43482
// begin x := rand ( 1 , list [ 1 ] ) ;
43404: LD_ADDR_VAR 0 8
43408: PUSH
43409: LD_INT 1
43411: PPUSH
43412: LD_VAR 0 7
43416: PUSH
43417: LD_INT 1
43419: ARRAY
43420: PPUSH
43421: CALL_OW 12
43425: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43426: LD_ADDR_VAR 0 6
43430: PUSH
43431: LD_VAR 0 6
43435: PPUSH
43436: LD_VAR 0 5
43440: PPUSH
43441: LD_VAR 0 7
43445: PUSH
43446: LD_INT 1
43448: ARRAY
43449: PUSH
43450: LD_VAR 0 8
43454: ARRAY
43455: PUSH
43456: LD_VAR 0 7
43460: PUSH
43461: LD_INT 2
43463: ARRAY
43464: PUSH
43465: LD_VAR 0 8
43469: ARRAY
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PPUSH
43475: CALL_OW 1
43479: ST_TO_ADDR
// end ;
43480: GO 43401
43482: POP
43483: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43484: LD_ADDR_EXP 87
43488: PUSH
43489: LD_EXP 87
43493: PPUSH
43494: LD_VAR 0 1
43498: PPUSH
43499: LD_VAR 0 6
43503: PPUSH
43504: CALL_OW 1
43508: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43509: LD_ADDR_EXP 89
43513: PUSH
43514: LD_EXP 89
43518: PPUSH
43519: LD_VAR 0 1
43523: PPUSH
43524: LD_VAR 0 3
43528: PPUSH
43529: CALL_OW 1
43533: ST_TO_ADDR
// end ;
43534: LD_VAR 0 4
43538: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
43539: LD_INT 0
43541: PPUSH
// if not mc_bases [ base ] then
43542: LD_EXP 74
43546: PUSH
43547: LD_VAR 0 1
43551: ARRAY
43552: NOT
43553: IFFALSE 43557
// exit ;
43555: GO 43582
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43557: LD_ADDR_EXP 79
43561: PUSH
43562: LD_EXP 79
43566: PPUSH
43567: LD_VAR 0 1
43571: PPUSH
43572: LD_VAR 0 2
43576: PPUSH
43577: CALL_OW 1
43581: ST_TO_ADDR
// end ;
43582: LD_VAR 0 3
43586: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43587: LD_INT 0
43589: PPUSH
// if not mc_bases [ base ] then
43590: LD_EXP 74
43594: PUSH
43595: LD_VAR 0 1
43599: ARRAY
43600: NOT
43601: IFFALSE 43605
// exit ;
43603: GO 43642
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43605: LD_ADDR_EXP 79
43609: PUSH
43610: LD_EXP 79
43614: PPUSH
43615: LD_VAR 0 1
43619: PPUSH
43620: LD_EXP 79
43624: PUSH
43625: LD_VAR 0 1
43629: ARRAY
43630: PUSH
43631: LD_VAR 0 2
43635: UNION
43636: PPUSH
43637: CALL_OW 1
43641: ST_TO_ADDR
// end ;
43642: LD_VAR 0 3
43646: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
43647: LD_INT 0
43649: PPUSH
// if not mc_bases [ base ] then
43650: LD_EXP 74
43654: PUSH
43655: LD_VAR 0 1
43659: ARRAY
43660: NOT
43661: IFFALSE 43665
// exit ;
43663: GO 43690
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
43665: LD_ADDR_EXP 95
43669: PUSH
43670: LD_EXP 95
43674: PPUSH
43675: LD_VAR 0 1
43679: PPUSH
43680: LD_VAR 0 2
43684: PPUSH
43685: CALL_OW 1
43689: ST_TO_ADDR
// end ;
43690: LD_VAR 0 3
43694: RET
// export function MC_InsertProduceList ( base , components ) ; begin
43695: LD_INT 0
43697: PPUSH
// if not mc_bases [ base ] then
43698: LD_EXP 74
43702: PUSH
43703: LD_VAR 0 1
43707: ARRAY
43708: NOT
43709: IFFALSE 43713
// exit ;
43711: GO 43750
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
43713: LD_ADDR_EXP 95
43717: PUSH
43718: LD_EXP 95
43722: PPUSH
43723: LD_VAR 0 1
43727: PPUSH
43728: LD_EXP 95
43732: PUSH
43733: LD_VAR 0 1
43737: ARRAY
43738: PUSH
43739: LD_VAR 0 2
43743: ADD
43744: PPUSH
43745: CALL_OW 1
43749: ST_TO_ADDR
// end ;
43750: LD_VAR 0 3
43754: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
43755: LD_INT 0
43757: PPUSH
// if not mc_bases [ base ] then
43758: LD_EXP 74
43762: PUSH
43763: LD_VAR 0 1
43767: ARRAY
43768: NOT
43769: IFFALSE 43773
// exit ;
43771: GO 43827
// mc_defender := Replace ( mc_defender , base , deflist ) ;
43773: LD_ADDR_EXP 96
43777: PUSH
43778: LD_EXP 96
43782: PPUSH
43783: LD_VAR 0 1
43787: PPUSH
43788: LD_VAR 0 2
43792: PPUSH
43793: CALL_OW 1
43797: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
43798: LD_ADDR_EXP 85
43802: PUSH
43803: LD_EXP 85
43807: PPUSH
43808: LD_VAR 0 1
43812: PPUSH
43813: LD_VAR 0 2
43817: PUSH
43818: LD_INT 0
43820: PLUS
43821: PPUSH
43822: CALL_OW 1
43826: ST_TO_ADDR
// end ;
43827: LD_VAR 0 3
43831: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
43832: LD_INT 0
43834: PPUSH
// if not mc_bases [ base ] then
43835: LD_EXP 74
43839: PUSH
43840: LD_VAR 0 1
43844: ARRAY
43845: NOT
43846: IFFALSE 43850
// exit ;
43848: GO 43875
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
43850: LD_ADDR_EXP 85
43854: PUSH
43855: LD_EXP 85
43859: PPUSH
43860: LD_VAR 0 1
43864: PPUSH
43865: LD_VAR 0 2
43869: PPUSH
43870: CALL_OW 1
43874: ST_TO_ADDR
// end ;
43875: LD_VAR 0 3
43879: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
43880: LD_INT 0
43882: PPUSH
43883: PPUSH
43884: PPUSH
43885: PPUSH
// if not mc_bases [ base ] then
43886: LD_EXP 74
43890: PUSH
43891: LD_VAR 0 1
43895: ARRAY
43896: NOT
43897: IFFALSE 43901
// exit ;
43899: GO 43966
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
43901: LD_ADDR_EXP 94
43905: PUSH
43906: LD_EXP 94
43910: PPUSH
43911: LD_VAR 0 1
43915: PUSH
43916: LD_EXP 94
43920: PUSH
43921: LD_VAR 0 1
43925: ARRAY
43926: PUSH
43927: LD_INT 1
43929: PLUS
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PPUSH
43935: LD_VAR 0 1
43939: PUSH
43940: LD_VAR 0 2
43944: PUSH
43945: LD_VAR 0 3
43949: PUSH
43950: LD_VAR 0 4
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: PPUSH
43961: CALL 56993 0 3
43965: ST_TO_ADDR
// end ;
43966: LD_VAR 0 5
43970: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
43971: LD_INT 0
43973: PPUSH
// if not mc_bases [ base ] then
43974: LD_EXP 74
43978: PUSH
43979: LD_VAR 0 1
43983: ARRAY
43984: NOT
43985: IFFALSE 43989
// exit ;
43987: GO 44014
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
43989: LD_ADDR_EXP 111
43993: PUSH
43994: LD_EXP 111
43998: PPUSH
43999: LD_VAR 0 1
44003: PPUSH
44004: LD_VAR 0 2
44008: PPUSH
44009: CALL_OW 1
44013: ST_TO_ADDR
// end ;
44014: LD_VAR 0 3
44018: RET
// export function MC_GetMinesField ( base ) ; begin
44019: LD_INT 0
44021: PPUSH
// result := mc_mines [ base ] ;
44022: LD_ADDR_VAR 0 2
44026: PUSH
44027: LD_EXP 87
44031: PUSH
44032: LD_VAR 0 1
44036: ARRAY
44037: ST_TO_ADDR
// end ;
44038: LD_VAR 0 2
44042: RET
// export function MC_GetProduceList ( base ) ; begin
44043: LD_INT 0
44045: PPUSH
// result := mc_produce [ base ] ;
44046: LD_ADDR_VAR 0 2
44050: PUSH
44051: LD_EXP 95
44055: PUSH
44056: LD_VAR 0 1
44060: ARRAY
44061: ST_TO_ADDR
// end ;
44062: LD_VAR 0 2
44066: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44067: LD_INT 0
44069: PPUSH
44070: PPUSH
// if not mc_bases then
44071: LD_EXP 74
44075: NOT
44076: IFFALSE 44080
// exit ;
44078: GO 44145
// if mc_bases [ base ] then
44080: LD_EXP 74
44084: PUSH
44085: LD_VAR 0 1
44089: ARRAY
44090: IFFALSE 44145
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44092: LD_ADDR_VAR 0 3
44096: PUSH
44097: LD_EXP 74
44101: PUSH
44102: LD_VAR 0 1
44106: ARRAY
44107: PPUSH
44108: LD_INT 30
44110: PUSH
44111: LD_VAR 0 2
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PPUSH
44120: CALL_OW 72
44124: ST_TO_ADDR
// if result then
44125: LD_VAR 0 3
44129: IFFALSE 44145
// result := result [ 1 ] ;
44131: LD_ADDR_VAR 0 3
44135: PUSH
44136: LD_VAR 0 3
44140: PUSH
44141: LD_INT 1
44143: ARRAY
44144: ST_TO_ADDR
// end ; end ;
44145: LD_VAR 0 3
44149: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44150: LD_INT 0
44152: PPUSH
44153: PPUSH
// if not mc_bases then
44154: LD_EXP 74
44158: NOT
44159: IFFALSE 44163
// exit ;
44161: GO 44208
// if mc_bases [ base ] then
44163: LD_EXP 74
44167: PUSH
44168: LD_VAR 0 1
44172: ARRAY
44173: IFFALSE 44208
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44175: LD_ADDR_VAR 0 3
44179: PUSH
44180: LD_EXP 74
44184: PUSH
44185: LD_VAR 0 1
44189: ARRAY
44190: PPUSH
44191: LD_INT 30
44193: PUSH
44194: LD_VAR 0 2
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PPUSH
44203: CALL_OW 72
44207: ST_TO_ADDR
// end ;
44208: LD_VAR 0 3
44212: RET
// export function MC_SetTame ( base , area ) ; begin
44213: LD_INT 0
44215: PPUSH
// if not mc_bases or not base then
44216: LD_EXP 74
44220: NOT
44221: PUSH
44222: LD_VAR 0 1
44226: NOT
44227: OR
44228: IFFALSE 44232
// exit ;
44230: GO 44257
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44232: LD_ADDR_EXP 102
44236: PUSH
44237: LD_EXP 102
44241: PPUSH
44242: LD_VAR 0 1
44246: PPUSH
44247: LD_VAR 0 2
44251: PPUSH
44252: CALL_OW 1
44256: ST_TO_ADDR
// end ;
44257: LD_VAR 0 3
44261: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44262: LD_INT 0
44264: PPUSH
44265: PPUSH
// if not mc_bases or not base then
44266: LD_EXP 74
44270: NOT
44271: PUSH
44272: LD_VAR 0 1
44276: NOT
44277: OR
44278: IFFALSE 44282
// exit ;
44280: GO 44384
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44282: LD_ADDR_VAR 0 4
44286: PUSH
44287: LD_EXP 74
44291: PUSH
44292: LD_VAR 0 1
44296: ARRAY
44297: PPUSH
44298: LD_INT 30
44300: PUSH
44301: LD_VAR 0 2
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PPUSH
44310: CALL_OW 72
44314: ST_TO_ADDR
// if not tmp then
44315: LD_VAR 0 4
44319: NOT
44320: IFFALSE 44324
// exit ;
44322: GO 44384
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44324: LD_ADDR_EXP 106
44328: PUSH
44329: LD_EXP 106
44333: PPUSH
44334: LD_VAR 0 1
44338: PPUSH
44339: LD_EXP 106
44343: PUSH
44344: LD_VAR 0 1
44348: ARRAY
44349: PPUSH
44350: LD_EXP 106
44354: PUSH
44355: LD_VAR 0 1
44359: ARRAY
44360: PUSH
44361: LD_INT 1
44363: PLUS
44364: PPUSH
44365: LD_VAR 0 4
44369: PUSH
44370: LD_INT 1
44372: ARRAY
44373: PPUSH
44374: CALL_OW 2
44378: PPUSH
44379: CALL_OW 1
44383: ST_TO_ADDR
// end ;
44384: LD_VAR 0 3
44388: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44389: LD_INT 0
44391: PPUSH
44392: PPUSH
// if not mc_bases or not base or not kinds then
44393: LD_EXP 74
44397: NOT
44398: PUSH
44399: LD_VAR 0 1
44403: NOT
44404: OR
44405: PUSH
44406: LD_VAR 0 2
44410: NOT
44411: OR
44412: IFFALSE 44416
// exit ;
44414: GO 44477
// for i in kinds do
44416: LD_ADDR_VAR 0 4
44420: PUSH
44421: LD_VAR 0 2
44425: PUSH
44426: FOR_IN
44427: IFFALSE 44475
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44429: LD_ADDR_EXP 108
44433: PUSH
44434: LD_EXP 108
44438: PPUSH
44439: LD_VAR 0 1
44443: PUSH
44444: LD_EXP 108
44448: PUSH
44449: LD_VAR 0 1
44453: ARRAY
44454: PUSH
44455: LD_INT 1
44457: PLUS
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PPUSH
44463: LD_VAR 0 4
44467: PPUSH
44468: CALL 56993 0 3
44472: ST_TO_ADDR
44473: GO 44426
44475: POP
44476: POP
// end ;
44477: LD_VAR 0 3
44481: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44482: LD_INT 0
44484: PPUSH
// if not mc_bases or not base or not areas then
44485: LD_EXP 74
44489: NOT
44490: PUSH
44491: LD_VAR 0 1
44495: NOT
44496: OR
44497: PUSH
44498: LD_VAR 0 2
44502: NOT
44503: OR
44504: IFFALSE 44508
// exit ;
44506: GO 44533
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44508: LD_ADDR_EXP 92
44512: PUSH
44513: LD_EXP 92
44517: PPUSH
44518: LD_VAR 0 1
44522: PPUSH
44523: LD_VAR 0 2
44527: PPUSH
44528: CALL_OW 1
44532: ST_TO_ADDR
// end ;
44533: LD_VAR 0 3
44537: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
44538: LD_INT 0
44540: PPUSH
// if not mc_bases or not base or not teleports_exit then
44541: LD_EXP 74
44545: NOT
44546: PUSH
44547: LD_VAR 0 1
44551: NOT
44552: OR
44553: PUSH
44554: LD_VAR 0 2
44558: NOT
44559: OR
44560: IFFALSE 44564
// exit ;
44562: GO 44589
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44564: LD_ADDR_EXP 109
44568: PUSH
44569: LD_EXP 109
44573: PPUSH
44574: LD_VAR 0 1
44578: PPUSH
44579: LD_VAR 0 2
44583: PPUSH
44584: CALL_OW 1
44588: ST_TO_ADDR
// end ;
44589: LD_VAR 0 3
44593: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44594: LD_INT 0
44596: PPUSH
44597: PPUSH
44598: PPUSH
// if not mc_bases or not base or not ext_list then
44599: LD_EXP 74
44603: NOT
44604: PUSH
44605: LD_VAR 0 1
44609: NOT
44610: OR
44611: PUSH
44612: LD_VAR 0 5
44616: NOT
44617: OR
44618: IFFALSE 44622
// exit ;
44620: GO 44795
// tmp := GetFacExtXYD ( x , y , d ) ;
44622: LD_ADDR_VAR 0 8
44626: PUSH
44627: LD_VAR 0 2
44631: PPUSH
44632: LD_VAR 0 3
44636: PPUSH
44637: LD_VAR 0 4
44641: PPUSH
44642: CALL 90371 0 3
44646: ST_TO_ADDR
// if not tmp then
44647: LD_VAR 0 8
44651: NOT
44652: IFFALSE 44656
// exit ;
44654: GO 44795
// for i in tmp do
44656: LD_ADDR_VAR 0 7
44660: PUSH
44661: LD_VAR 0 8
44665: PUSH
44666: FOR_IN
44667: IFFALSE 44793
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
44669: LD_ADDR_EXP 79
44673: PUSH
44674: LD_EXP 79
44678: PPUSH
44679: LD_VAR 0 1
44683: PPUSH
44684: LD_EXP 79
44688: PUSH
44689: LD_VAR 0 1
44693: ARRAY
44694: PPUSH
44695: LD_EXP 79
44699: PUSH
44700: LD_VAR 0 1
44704: ARRAY
44705: PUSH
44706: LD_INT 1
44708: PLUS
44709: PPUSH
44710: LD_VAR 0 5
44714: PUSH
44715: LD_INT 1
44717: ARRAY
44718: PUSH
44719: LD_VAR 0 7
44723: PUSH
44724: LD_INT 1
44726: ARRAY
44727: PUSH
44728: LD_VAR 0 7
44732: PUSH
44733: LD_INT 2
44735: ARRAY
44736: PUSH
44737: LD_VAR 0 7
44741: PUSH
44742: LD_INT 3
44744: ARRAY
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: PPUSH
44752: CALL_OW 2
44756: PPUSH
44757: CALL_OW 1
44761: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
44762: LD_ADDR_VAR 0 5
44766: PUSH
44767: LD_VAR 0 5
44771: PPUSH
44772: LD_INT 1
44774: PPUSH
44775: CALL_OW 3
44779: ST_TO_ADDR
// if not ext_list then
44780: LD_VAR 0 5
44784: NOT
44785: IFFALSE 44791
// exit ;
44787: POP
44788: POP
44789: GO 44795
// end ;
44791: GO 44666
44793: POP
44794: POP
// end ;
44795: LD_VAR 0 6
44799: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
44800: LD_INT 0
44802: PPUSH
// if not mc_bases or not base or not weapon_list then
44803: LD_EXP 74
44807: NOT
44808: PUSH
44809: LD_VAR 0 1
44813: NOT
44814: OR
44815: PUSH
44816: LD_VAR 0 2
44820: NOT
44821: OR
44822: IFFALSE 44826
// exit ;
44824: GO 44851
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
44826: LD_ADDR_EXP 113
44830: PUSH
44831: LD_EXP 113
44835: PPUSH
44836: LD_VAR 0 1
44840: PPUSH
44841: LD_VAR 0 2
44845: PPUSH
44846: CALL_OW 1
44850: ST_TO_ADDR
// end ;
44851: LD_VAR 0 3
44855: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
44856: LD_INT 0
44858: PPUSH
// if not mc_bases or not base or not tech_list then
44859: LD_EXP 74
44863: NOT
44864: PUSH
44865: LD_VAR 0 1
44869: NOT
44870: OR
44871: PUSH
44872: LD_VAR 0 2
44876: NOT
44877: OR
44878: IFFALSE 44882
// exit ;
44880: GO 44907
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
44882: LD_ADDR_EXP 101
44886: PUSH
44887: LD_EXP 101
44891: PPUSH
44892: LD_VAR 0 1
44896: PPUSH
44897: LD_VAR 0 2
44901: PPUSH
44902: CALL_OW 1
44906: ST_TO_ADDR
// end ;
44907: LD_VAR 0 3
44911: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
44912: LD_INT 0
44914: PPUSH
// if not mc_bases or not parking_area or not base then
44915: LD_EXP 74
44919: NOT
44920: PUSH
44921: LD_VAR 0 2
44925: NOT
44926: OR
44927: PUSH
44928: LD_VAR 0 1
44932: NOT
44933: OR
44934: IFFALSE 44938
// exit ;
44936: GO 44963
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
44938: LD_ADDR_EXP 98
44942: PUSH
44943: LD_EXP 98
44947: PPUSH
44948: LD_VAR 0 1
44952: PPUSH
44953: LD_VAR 0 2
44957: PPUSH
44958: CALL_OW 1
44962: ST_TO_ADDR
// end ;
44963: LD_VAR 0 3
44967: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
44968: LD_INT 0
44970: PPUSH
// if not mc_bases or not base or not scan_area then
44971: LD_EXP 74
44975: NOT
44976: PUSH
44977: LD_VAR 0 1
44981: NOT
44982: OR
44983: PUSH
44984: LD_VAR 0 2
44988: NOT
44989: OR
44990: IFFALSE 44994
// exit ;
44992: GO 45019
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
44994: LD_ADDR_EXP 99
44998: PUSH
44999: LD_EXP 99
45003: PPUSH
45004: LD_VAR 0 1
45008: PPUSH
45009: LD_VAR 0 2
45013: PPUSH
45014: CALL_OW 1
45018: ST_TO_ADDR
// end ;
45019: LD_VAR 0 3
45023: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45024: LD_INT 0
45026: PPUSH
45027: PPUSH
// if not mc_bases or not base then
45028: LD_EXP 74
45032: NOT
45033: PUSH
45034: LD_VAR 0 1
45038: NOT
45039: OR
45040: IFFALSE 45044
// exit ;
45042: GO 45108
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45044: LD_ADDR_VAR 0 3
45048: PUSH
45049: LD_INT 1
45051: PUSH
45052: LD_INT 2
45054: PUSH
45055: LD_INT 3
45057: PUSH
45058: LD_INT 4
45060: PUSH
45061: LD_INT 11
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45071: LD_ADDR_EXP 101
45075: PUSH
45076: LD_EXP 101
45080: PPUSH
45081: LD_VAR 0 1
45085: PPUSH
45086: LD_EXP 101
45090: PUSH
45091: LD_VAR 0 1
45095: ARRAY
45096: PUSH
45097: LD_VAR 0 3
45101: DIFF
45102: PPUSH
45103: CALL_OW 1
45107: ST_TO_ADDR
// end ;
45108: LD_VAR 0 2
45112: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45113: LD_INT 0
45115: PPUSH
// result := mc_vehicles [ base ] ;
45116: LD_ADDR_VAR 0 3
45120: PUSH
45121: LD_EXP 93
45125: PUSH
45126: LD_VAR 0 1
45130: ARRAY
45131: ST_TO_ADDR
// if onlyCombat then
45132: LD_VAR 0 2
45136: IFFALSE 45301
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45138: LD_ADDR_VAR 0 3
45142: PUSH
45143: LD_VAR 0 3
45147: PUSH
45148: LD_VAR 0 3
45152: PPUSH
45153: LD_INT 2
45155: PUSH
45156: LD_INT 34
45158: PUSH
45159: LD_INT 12
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: PUSH
45166: LD_INT 34
45168: PUSH
45169: LD_INT 51
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: LD_INT 34
45178: PUSH
45179: LD_EXP 68
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: LD_INT 34
45190: PUSH
45191: LD_INT 32
45193: PUSH
45194: EMPTY
45195: LIST
45196: LIST
45197: PUSH
45198: LD_INT 34
45200: PUSH
45201: LD_INT 13
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: PUSH
45208: LD_INT 34
45210: PUSH
45211: LD_INT 52
45213: PUSH
45214: EMPTY
45215: LIST
45216: LIST
45217: PUSH
45218: LD_INT 34
45220: PUSH
45221: LD_INT 14
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: PUSH
45228: LD_INT 34
45230: PUSH
45231: LD_INT 53
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: LD_INT 34
45240: PUSH
45241: LD_EXP 67
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: PUSH
45250: LD_INT 34
45252: PUSH
45253: LD_INT 31
45255: PUSH
45256: EMPTY
45257: LIST
45258: LIST
45259: PUSH
45260: LD_INT 34
45262: PUSH
45263: LD_INT 48
45265: PUSH
45266: EMPTY
45267: LIST
45268: LIST
45269: PUSH
45270: LD_INT 34
45272: PUSH
45273: LD_INT 8
45275: PUSH
45276: EMPTY
45277: LIST
45278: LIST
45279: PUSH
45280: EMPTY
45281: LIST
45282: LIST
45283: LIST
45284: LIST
45285: LIST
45286: LIST
45287: LIST
45288: LIST
45289: LIST
45290: LIST
45291: LIST
45292: LIST
45293: LIST
45294: PPUSH
45295: CALL_OW 72
45299: DIFF
45300: ST_TO_ADDR
// end ; end_of_file
45301: LD_VAR 0 3
45305: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45306: LD_INT 0
45308: PPUSH
45309: PPUSH
45310: PPUSH
// if not mc_bases or not skirmish then
45311: LD_EXP 74
45315: NOT
45316: PUSH
45317: LD_EXP 72
45321: NOT
45322: OR
45323: IFFALSE 45327
// exit ;
45325: GO 45492
// for i = 1 to mc_bases do
45327: LD_ADDR_VAR 0 4
45331: PUSH
45332: DOUBLE
45333: LD_INT 1
45335: DEC
45336: ST_TO_ADDR
45337: LD_EXP 74
45341: PUSH
45342: FOR_TO
45343: IFFALSE 45490
// begin if sci in mc_bases [ i ] then
45345: LD_VAR 0 2
45349: PUSH
45350: LD_EXP 74
45354: PUSH
45355: LD_VAR 0 4
45359: ARRAY
45360: IN
45361: IFFALSE 45488
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45363: LD_ADDR_EXP 103
45367: PUSH
45368: LD_EXP 103
45372: PPUSH
45373: LD_VAR 0 4
45377: PUSH
45378: LD_EXP 103
45382: PUSH
45383: LD_VAR 0 4
45387: ARRAY
45388: PUSH
45389: LD_INT 1
45391: PLUS
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PPUSH
45397: LD_VAR 0 1
45401: PPUSH
45402: CALL 56993 0 3
45406: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45407: LD_ADDR_VAR 0 5
45411: PUSH
45412: LD_EXP 74
45416: PUSH
45417: LD_VAR 0 4
45421: ARRAY
45422: PPUSH
45423: LD_INT 2
45425: PUSH
45426: LD_INT 30
45428: PUSH
45429: LD_INT 0
45431: PUSH
45432: EMPTY
45433: LIST
45434: LIST
45435: PUSH
45436: LD_INT 30
45438: PUSH
45439: LD_INT 1
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: EMPTY
45447: LIST
45448: LIST
45449: LIST
45450: PPUSH
45451: CALL_OW 72
45455: PPUSH
45456: LD_VAR 0 1
45460: PPUSH
45461: CALL_OW 74
45465: ST_TO_ADDR
// if tmp then
45466: LD_VAR 0 5
45470: IFFALSE 45486
// ComStandNearbyBuilding ( ape , tmp ) ;
45472: LD_VAR 0 1
45476: PPUSH
45477: LD_VAR 0 5
45481: PPUSH
45482: CALL 51345 0 2
// break ;
45486: GO 45490
// end ; end ;
45488: GO 45342
45490: POP
45491: POP
// end ;
45492: LD_VAR 0 3
45496: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45497: LD_INT 0
45499: PPUSH
45500: PPUSH
45501: PPUSH
// if not mc_bases or not skirmish then
45502: LD_EXP 74
45506: NOT
45507: PUSH
45508: LD_EXP 72
45512: NOT
45513: OR
45514: IFFALSE 45518
// exit ;
45516: GO 45607
// for i = 1 to mc_bases do
45518: LD_ADDR_VAR 0 4
45522: PUSH
45523: DOUBLE
45524: LD_INT 1
45526: DEC
45527: ST_TO_ADDR
45528: LD_EXP 74
45532: PUSH
45533: FOR_TO
45534: IFFALSE 45605
// begin if building in mc_busy_turret_list [ i ] then
45536: LD_VAR 0 1
45540: PUSH
45541: LD_EXP 84
45545: PUSH
45546: LD_VAR 0 4
45550: ARRAY
45551: IN
45552: IFFALSE 45603
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45554: LD_ADDR_VAR 0 5
45558: PUSH
45559: LD_EXP 84
45563: PUSH
45564: LD_VAR 0 4
45568: ARRAY
45569: PUSH
45570: LD_VAR 0 1
45574: DIFF
45575: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45576: LD_ADDR_EXP 84
45580: PUSH
45581: LD_EXP 84
45585: PPUSH
45586: LD_VAR 0 4
45590: PPUSH
45591: LD_VAR 0 5
45595: PPUSH
45596: CALL_OW 1
45600: ST_TO_ADDR
// break ;
45601: GO 45605
// end ; end ;
45603: GO 45533
45605: POP
45606: POP
// end ;
45607: LD_VAR 0 3
45611: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45612: LD_INT 0
45614: PPUSH
45615: PPUSH
45616: PPUSH
// if not mc_bases or not skirmish then
45617: LD_EXP 74
45621: NOT
45622: PUSH
45623: LD_EXP 72
45627: NOT
45628: OR
45629: IFFALSE 45633
// exit ;
45631: GO 45832
// for i = 1 to mc_bases do
45633: LD_ADDR_VAR 0 5
45637: PUSH
45638: DOUBLE
45639: LD_INT 1
45641: DEC
45642: ST_TO_ADDR
45643: LD_EXP 74
45647: PUSH
45648: FOR_TO
45649: IFFALSE 45830
// if building in mc_bases [ i ] then
45651: LD_VAR 0 1
45655: PUSH
45656: LD_EXP 74
45660: PUSH
45661: LD_VAR 0 5
45665: ARRAY
45666: IN
45667: IFFALSE 45828
// begin tmp := mc_bases [ i ] diff building ;
45669: LD_ADDR_VAR 0 6
45673: PUSH
45674: LD_EXP 74
45678: PUSH
45679: LD_VAR 0 5
45683: ARRAY
45684: PUSH
45685: LD_VAR 0 1
45689: DIFF
45690: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
45691: LD_ADDR_EXP 74
45695: PUSH
45696: LD_EXP 74
45700: PPUSH
45701: LD_VAR 0 5
45705: PPUSH
45706: LD_VAR 0 6
45710: PPUSH
45711: CALL_OW 1
45715: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
45716: LD_VAR 0 1
45720: PUSH
45721: LD_EXP 82
45725: PUSH
45726: LD_VAR 0 5
45730: ARRAY
45731: IN
45732: IFFALSE 45771
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
45734: LD_ADDR_EXP 82
45738: PUSH
45739: LD_EXP 82
45743: PPUSH
45744: LD_VAR 0 5
45748: PPUSH
45749: LD_EXP 82
45753: PUSH
45754: LD_VAR 0 5
45758: ARRAY
45759: PUSH
45760: LD_VAR 0 1
45764: DIFF
45765: PPUSH
45766: CALL_OW 1
45770: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
45771: LD_VAR 0 1
45775: PUSH
45776: LD_EXP 83
45780: PUSH
45781: LD_VAR 0 5
45785: ARRAY
45786: IN
45787: IFFALSE 45826
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
45789: LD_ADDR_EXP 83
45793: PUSH
45794: LD_EXP 83
45798: PPUSH
45799: LD_VAR 0 5
45803: PPUSH
45804: LD_EXP 83
45808: PUSH
45809: LD_VAR 0 5
45813: ARRAY
45814: PUSH
45815: LD_VAR 0 1
45819: DIFF
45820: PPUSH
45821: CALL_OW 1
45825: ST_TO_ADDR
// break ;
45826: GO 45830
// end ;
45828: GO 45648
45830: POP
45831: POP
// end ;
45832: LD_VAR 0 4
45836: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
45837: LD_INT 0
45839: PPUSH
45840: PPUSH
45841: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
45842: LD_EXP 74
45846: NOT
45847: PUSH
45848: LD_EXP 72
45852: NOT
45853: OR
45854: PUSH
45855: LD_VAR 0 3
45859: PUSH
45860: LD_EXP 100
45864: IN
45865: NOT
45866: OR
45867: IFFALSE 45871
// exit ;
45869: GO 45994
// for i = 1 to mc_vehicles do
45871: LD_ADDR_VAR 0 6
45875: PUSH
45876: DOUBLE
45877: LD_INT 1
45879: DEC
45880: ST_TO_ADDR
45881: LD_EXP 93
45885: PUSH
45886: FOR_TO
45887: IFFALSE 45992
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
45889: LD_VAR 0 2
45893: PUSH
45894: LD_EXP 93
45898: PUSH
45899: LD_VAR 0 6
45903: ARRAY
45904: IN
45905: PUSH
45906: LD_VAR 0 1
45910: PUSH
45911: LD_EXP 93
45915: PUSH
45916: LD_VAR 0 6
45920: ARRAY
45921: IN
45922: OR
45923: IFFALSE 45990
// begin tmp := mc_vehicles [ i ] diff old ;
45925: LD_ADDR_VAR 0 7
45929: PUSH
45930: LD_EXP 93
45934: PUSH
45935: LD_VAR 0 6
45939: ARRAY
45940: PUSH
45941: LD_VAR 0 2
45945: DIFF
45946: ST_TO_ADDR
// tmp := tmp diff new ;
45947: LD_ADDR_VAR 0 7
45951: PUSH
45952: LD_VAR 0 7
45956: PUSH
45957: LD_VAR 0 1
45961: DIFF
45962: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
45963: LD_ADDR_EXP 93
45967: PUSH
45968: LD_EXP 93
45972: PPUSH
45973: LD_VAR 0 6
45977: PPUSH
45978: LD_VAR 0 7
45982: PPUSH
45983: CALL_OW 1
45987: ST_TO_ADDR
// break ;
45988: GO 45992
// end ;
45990: GO 45886
45992: POP
45993: POP
// end ;
45994: LD_VAR 0 5
45998: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
45999: LD_INT 0
46001: PPUSH
46002: PPUSH
46003: PPUSH
46004: PPUSH
// if not mc_bases or not skirmish then
46005: LD_EXP 74
46009: NOT
46010: PUSH
46011: LD_EXP 72
46015: NOT
46016: OR
46017: IFFALSE 46021
// exit ;
46019: GO 46398
// side := GetSide ( vehicle ) ;
46021: LD_ADDR_VAR 0 5
46025: PUSH
46026: LD_VAR 0 1
46030: PPUSH
46031: CALL_OW 255
46035: ST_TO_ADDR
// for i = 1 to mc_bases do
46036: LD_ADDR_VAR 0 4
46040: PUSH
46041: DOUBLE
46042: LD_INT 1
46044: DEC
46045: ST_TO_ADDR
46046: LD_EXP 74
46050: PUSH
46051: FOR_TO
46052: IFFALSE 46396
// begin if factory in mc_bases [ i ] then
46054: LD_VAR 0 2
46058: PUSH
46059: LD_EXP 74
46063: PUSH
46064: LD_VAR 0 4
46068: ARRAY
46069: IN
46070: IFFALSE 46394
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46072: LD_EXP 96
46076: PUSH
46077: LD_VAR 0 4
46081: ARRAY
46082: PUSH
46083: LD_EXP 85
46087: PUSH
46088: LD_VAR 0 4
46092: ARRAY
46093: LESS
46094: PUSH
46095: LD_VAR 0 1
46099: PPUSH
46100: CALL_OW 264
46104: PUSH
46105: LD_INT 31
46107: PUSH
46108: LD_INT 32
46110: PUSH
46111: LD_INT 51
46113: PUSH
46114: LD_EXP 68
46118: PUSH
46119: LD_INT 12
46121: PUSH
46122: LD_INT 30
46124: PUSH
46125: LD_EXP 67
46129: PUSH
46130: LD_INT 11
46132: PUSH
46133: LD_INT 53
46135: PUSH
46136: LD_INT 14
46138: PUSH
46139: LD_EXP 71
46143: PUSH
46144: LD_INT 29
46146: PUSH
46147: LD_EXP 69
46151: PUSH
46152: LD_INT 13
46154: PUSH
46155: LD_INT 52
46157: PUSH
46158: LD_INT 48
46160: PUSH
46161: LD_INT 8
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: IN
46183: NOT
46184: AND
46185: IFFALSE 46233
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46187: LD_ADDR_EXP 96
46191: PUSH
46192: LD_EXP 96
46196: PPUSH
46197: LD_VAR 0 4
46201: PUSH
46202: LD_EXP 96
46206: PUSH
46207: LD_VAR 0 4
46211: ARRAY
46212: PUSH
46213: LD_INT 1
46215: PLUS
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: PPUSH
46221: LD_VAR 0 1
46225: PPUSH
46226: CALL 56993 0 3
46230: ST_TO_ADDR
46231: GO 46277
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46233: LD_ADDR_EXP 93
46237: PUSH
46238: LD_EXP 93
46242: PPUSH
46243: LD_VAR 0 4
46247: PUSH
46248: LD_EXP 93
46252: PUSH
46253: LD_VAR 0 4
46257: ARRAY
46258: PUSH
46259: LD_INT 1
46261: PLUS
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PPUSH
46267: LD_VAR 0 1
46271: PPUSH
46272: CALL 56993 0 3
46276: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46277: LD_VAR 0 1
46281: PPUSH
46282: CALL_OW 263
46286: PUSH
46287: LD_INT 2
46289: EQUAL
46290: IFFALSE 46310
// begin repeat wait ( 0 0$1 ) ;
46292: LD_INT 35
46294: PPUSH
46295: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46299: LD_VAR 0 1
46303: PPUSH
46304: CALL_OW 312
46308: IFFALSE 46292
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46310: LD_VAR 0 1
46314: PPUSH
46315: LD_EXP 98
46319: PUSH
46320: LD_VAR 0 4
46324: ARRAY
46325: PPUSH
46326: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46330: LD_VAR 0 1
46334: PPUSH
46335: CALL_OW 263
46339: PUSH
46340: LD_INT 1
46342: NONEQUAL
46343: IFFALSE 46347
// break ;
46345: GO 46396
// repeat wait ( 0 0$1 ) ;
46347: LD_INT 35
46349: PPUSH
46350: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46354: LD_VAR 0 1
46358: PPUSH
46359: LD_EXP 98
46363: PUSH
46364: LD_VAR 0 4
46368: ARRAY
46369: PPUSH
46370: CALL_OW 308
46374: IFFALSE 46347
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46376: LD_VAR 0 1
46380: PPUSH
46381: CALL_OW 311
46385: PPUSH
46386: CALL_OW 121
// exit ;
46390: POP
46391: POP
46392: GO 46398
// end ; end ;
46394: GO 46051
46396: POP
46397: POP
// end ;
46398: LD_VAR 0 3
46402: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46403: LD_INT 0
46405: PPUSH
46406: PPUSH
46407: PPUSH
46408: PPUSH
// if not mc_bases or not skirmish then
46409: LD_EXP 74
46413: NOT
46414: PUSH
46415: LD_EXP 72
46419: NOT
46420: OR
46421: IFFALSE 46425
// exit ;
46423: GO 46778
// repeat wait ( 0 0$1 ) ;
46425: LD_INT 35
46427: PPUSH
46428: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46432: LD_VAR 0 2
46436: PPUSH
46437: LD_VAR 0 3
46441: PPUSH
46442: CALL_OW 284
46446: IFFALSE 46425
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46448: LD_VAR 0 2
46452: PPUSH
46453: LD_VAR 0 3
46457: PPUSH
46458: CALL_OW 283
46462: PUSH
46463: LD_INT 4
46465: EQUAL
46466: IFFALSE 46470
// exit ;
46468: GO 46778
// for i = 1 to mc_bases do
46470: LD_ADDR_VAR 0 7
46474: PUSH
46475: DOUBLE
46476: LD_INT 1
46478: DEC
46479: ST_TO_ADDR
46480: LD_EXP 74
46484: PUSH
46485: FOR_TO
46486: IFFALSE 46776
// begin if mc_crates_area [ i ] then
46488: LD_EXP 92
46492: PUSH
46493: LD_VAR 0 7
46497: ARRAY
46498: IFFALSE 46609
// for j in mc_crates_area [ i ] do
46500: LD_ADDR_VAR 0 8
46504: PUSH
46505: LD_EXP 92
46509: PUSH
46510: LD_VAR 0 7
46514: ARRAY
46515: PUSH
46516: FOR_IN
46517: IFFALSE 46607
// if InArea ( x , y , j ) then
46519: LD_VAR 0 2
46523: PPUSH
46524: LD_VAR 0 3
46528: PPUSH
46529: LD_VAR 0 8
46533: PPUSH
46534: CALL_OW 309
46538: IFFALSE 46605
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46540: LD_ADDR_EXP 90
46544: PUSH
46545: LD_EXP 90
46549: PPUSH
46550: LD_VAR 0 7
46554: PUSH
46555: LD_EXP 90
46559: PUSH
46560: LD_VAR 0 7
46564: ARRAY
46565: PUSH
46566: LD_INT 1
46568: PLUS
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: PPUSH
46574: LD_VAR 0 4
46578: PUSH
46579: LD_VAR 0 2
46583: PUSH
46584: LD_VAR 0 3
46588: PUSH
46589: EMPTY
46590: LIST
46591: LIST
46592: LIST
46593: PPUSH
46594: CALL 56993 0 3
46598: ST_TO_ADDR
// exit ;
46599: POP
46600: POP
46601: POP
46602: POP
46603: GO 46778
// end ;
46605: GO 46516
46607: POP
46608: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46609: LD_ADDR_VAR 0 9
46613: PUSH
46614: LD_EXP 74
46618: PUSH
46619: LD_VAR 0 7
46623: ARRAY
46624: PPUSH
46625: LD_INT 2
46627: PUSH
46628: LD_INT 30
46630: PUSH
46631: LD_INT 0
46633: PUSH
46634: EMPTY
46635: LIST
46636: LIST
46637: PUSH
46638: LD_INT 30
46640: PUSH
46641: LD_INT 1
46643: PUSH
46644: EMPTY
46645: LIST
46646: LIST
46647: PUSH
46648: EMPTY
46649: LIST
46650: LIST
46651: LIST
46652: PPUSH
46653: CALL_OW 72
46657: ST_TO_ADDR
// if not depot then
46658: LD_VAR 0 9
46662: NOT
46663: IFFALSE 46667
// continue ;
46665: GO 46485
// for j in depot do
46667: LD_ADDR_VAR 0 8
46671: PUSH
46672: LD_VAR 0 9
46676: PUSH
46677: FOR_IN
46678: IFFALSE 46772
// if GetDistUnitXY ( j , x , y ) < 30 then
46680: LD_VAR 0 8
46684: PPUSH
46685: LD_VAR 0 2
46689: PPUSH
46690: LD_VAR 0 3
46694: PPUSH
46695: CALL_OW 297
46699: PUSH
46700: LD_INT 30
46702: LESS
46703: IFFALSE 46770
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46705: LD_ADDR_EXP 90
46709: PUSH
46710: LD_EXP 90
46714: PPUSH
46715: LD_VAR 0 7
46719: PUSH
46720: LD_EXP 90
46724: PUSH
46725: LD_VAR 0 7
46729: ARRAY
46730: PUSH
46731: LD_INT 1
46733: PLUS
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: PPUSH
46739: LD_VAR 0 4
46743: PUSH
46744: LD_VAR 0 2
46748: PUSH
46749: LD_VAR 0 3
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: LIST
46758: PPUSH
46759: CALL 56993 0 3
46763: ST_TO_ADDR
// exit ;
46764: POP
46765: POP
46766: POP
46767: POP
46768: GO 46778
// end ;
46770: GO 46677
46772: POP
46773: POP
// end ;
46774: GO 46485
46776: POP
46777: POP
// end ;
46778: LD_VAR 0 6
46782: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
46783: LD_INT 0
46785: PPUSH
46786: PPUSH
46787: PPUSH
46788: PPUSH
// if not mc_bases or not skirmish then
46789: LD_EXP 74
46793: NOT
46794: PUSH
46795: LD_EXP 72
46799: NOT
46800: OR
46801: IFFALSE 46805
// exit ;
46803: GO 47082
// side := GetSide ( lab ) ;
46805: LD_ADDR_VAR 0 4
46809: PUSH
46810: LD_VAR 0 2
46814: PPUSH
46815: CALL_OW 255
46819: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
46820: LD_VAR 0 4
46824: PUSH
46825: LD_EXP 100
46829: IN
46830: NOT
46831: PUSH
46832: LD_EXP 101
46836: NOT
46837: OR
46838: PUSH
46839: LD_EXP 74
46843: NOT
46844: OR
46845: IFFALSE 46849
// exit ;
46847: GO 47082
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
46849: LD_ADDR_EXP 101
46853: PUSH
46854: LD_EXP 101
46858: PPUSH
46859: LD_VAR 0 4
46863: PPUSH
46864: LD_EXP 101
46868: PUSH
46869: LD_VAR 0 4
46873: ARRAY
46874: PUSH
46875: LD_VAR 0 1
46879: DIFF
46880: PPUSH
46881: CALL_OW 1
46885: ST_TO_ADDR
// for i = 1 to mc_bases do
46886: LD_ADDR_VAR 0 5
46890: PUSH
46891: DOUBLE
46892: LD_INT 1
46894: DEC
46895: ST_TO_ADDR
46896: LD_EXP 74
46900: PUSH
46901: FOR_TO
46902: IFFALSE 47080
// begin if lab in mc_bases [ i ] then
46904: LD_VAR 0 2
46908: PUSH
46909: LD_EXP 74
46913: PUSH
46914: LD_VAR 0 5
46918: ARRAY
46919: IN
46920: IFFALSE 47078
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
46922: LD_VAR 0 1
46926: PUSH
46927: LD_INT 11
46929: PUSH
46930: LD_INT 4
46932: PUSH
46933: LD_INT 3
46935: PUSH
46936: LD_INT 2
46938: PUSH
46939: EMPTY
46940: LIST
46941: LIST
46942: LIST
46943: LIST
46944: IN
46945: PUSH
46946: LD_EXP 104
46950: PUSH
46951: LD_VAR 0 5
46955: ARRAY
46956: AND
46957: IFFALSE 47078
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
46959: LD_ADDR_VAR 0 6
46963: PUSH
46964: LD_EXP 104
46968: PUSH
46969: LD_VAR 0 5
46973: ARRAY
46974: PUSH
46975: LD_INT 1
46977: ARRAY
46978: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46979: LD_ADDR_EXP 104
46983: PUSH
46984: LD_EXP 104
46988: PPUSH
46989: LD_VAR 0 5
46993: PPUSH
46994: EMPTY
46995: PPUSH
46996: CALL_OW 1
47000: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47001: LD_VAR 0 6
47005: PPUSH
47006: LD_INT 0
47008: PPUSH
47009: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47013: LD_VAR 0 6
47017: PPUSH
47018: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47022: LD_ADDR_EXP 103
47026: PUSH
47027: LD_EXP 103
47031: PPUSH
47032: LD_VAR 0 5
47036: PPUSH
47037: LD_EXP 103
47041: PUSH
47042: LD_VAR 0 5
47046: ARRAY
47047: PPUSH
47048: LD_INT 1
47050: PPUSH
47051: LD_VAR 0 6
47055: PPUSH
47056: CALL_OW 2
47060: PPUSH
47061: CALL_OW 1
47065: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47066: LD_VAR 0 5
47070: PPUSH
47071: LD_INT 112
47073: PPUSH
47074: CALL 24190 0 2
// end ; end ; end ;
47078: GO 46901
47080: POP
47081: POP
// end ;
47082: LD_VAR 0 3
47086: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47087: LD_INT 0
47089: PPUSH
47090: PPUSH
47091: PPUSH
47092: PPUSH
47093: PPUSH
47094: PPUSH
47095: PPUSH
47096: PPUSH
// if not mc_bases or not skirmish then
47097: LD_EXP 74
47101: NOT
47102: PUSH
47103: LD_EXP 72
47107: NOT
47108: OR
47109: IFFALSE 47113
// exit ;
47111: GO 48350
// for i = 1 to mc_bases do
47113: LD_ADDR_VAR 0 3
47117: PUSH
47118: DOUBLE
47119: LD_INT 1
47121: DEC
47122: ST_TO_ADDR
47123: LD_EXP 74
47127: PUSH
47128: FOR_TO
47129: IFFALSE 48348
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47131: LD_VAR 0 1
47135: PUSH
47136: LD_EXP 74
47140: PUSH
47141: LD_VAR 0 3
47145: ARRAY
47146: IN
47147: PUSH
47148: LD_VAR 0 1
47152: PUSH
47153: LD_EXP 81
47157: PUSH
47158: LD_VAR 0 3
47162: ARRAY
47163: IN
47164: OR
47165: PUSH
47166: LD_VAR 0 1
47170: PUSH
47171: LD_EXP 96
47175: PUSH
47176: LD_VAR 0 3
47180: ARRAY
47181: IN
47182: OR
47183: PUSH
47184: LD_VAR 0 1
47188: PUSH
47189: LD_EXP 93
47193: PUSH
47194: LD_VAR 0 3
47198: ARRAY
47199: IN
47200: OR
47201: PUSH
47202: LD_VAR 0 1
47206: PUSH
47207: LD_EXP 103
47211: PUSH
47212: LD_VAR 0 3
47216: ARRAY
47217: IN
47218: OR
47219: PUSH
47220: LD_VAR 0 1
47224: PUSH
47225: LD_EXP 104
47229: PUSH
47230: LD_VAR 0 3
47234: ARRAY
47235: IN
47236: OR
47237: IFFALSE 48346
// begin if un in mc_ape [ i ] then
47239: LD_VAR 0 1
47243: PUSH
47244: LD_EXP 103
47248: PUSH
47249: LD_VAR 0 3
47253: ARRAY
47254: IN
47255: IFFALSE 47294
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47257: LD_ADDR_EXP 103
47261: PUSH
47262: LD_EXP 103
47266: PPUSH
47267: LD_VAR 0 3
47271: PPUSH
47272: LD_EXP 103
47276: PUSH
47277: LD_VAR 0 3
47281: ARRAY
47282: PUSH
47283: LD_VAR 0 1
47287: DIFF
47288: PPUSH
47289: CALL_OW 1
47293: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47294: LD_VAR 0 1
47298: PUSH
47299: LD_EXP 104
47303: PUSH
47304: LD_VAR 0 3
47308: ARRAY
47309: IN
47310: IFFALSE 47334
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47312: LD_ADDR_EXP 104
47316: PUSH
47317: LD_EXP 104
47321: PPUSH
47322: LD_VAR 0 3
47326: PPUSH
47327: EMPTY
47328: PPUSH
47329: CALL_OW 1
47333: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
47334: LD_VAR 0 1
47338: PPUSH
47339: CALL_OW 247
47343: PUSH
47344: LD_INT 2
47346: EQUAL
47347: PUSH
47348: LD_VAR 0 1
47352: PPUSH
47353: CALL_OW 110
47357: PUSH
47358: LD_INT 20
47360: EQUAL
47361: PUSH
47362: LD_VAR 0 1
47366: PUSH
47367: LD_EXP 96
47371: PUSH
47372: LD_VAR 0 3
47376: ARRAY
47377: IN
47378: OR
47379: PUSH
47380: LD_VAR 0 1
47384: PPUSH
47385: CALL_OW 264
47389: PUSH
47390: LD_INT 12
47392: PUSH
47393: LD_INT 51
47395: PUSH
47396: LD_EXP 68
47400: PUSH
47401: LD_INT 32
47403: PUSH
47404: LD_INT 13
47406: PUSH
47407: LD_INT 52
47409: PUSH
47410: EMPTY
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: IN
47418: OR
47419: AND
47420: IFFALSE 47598
// begin if un in mc_defender [ i ] then
47422: LD_VAR 0 1
47426: PUSH
47427: LD_EXP 96
47431: PUSH
47432: LD_VAR 0 3
47436: ARRAY
47437: IN
47438: IFFALSE 47477
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47440: LD_ADDR_EXP 96
47444: PUSH
47445: LD_EXP 96
47449: PPUSH
47450: LD_VAR 0 3
47454: PPUSH
47455: LD_EXP 96
47459: PUSH
47460: LD_VAR 0 3
47464: ARRAY
47465: PUSH
47466: LD_VAR 0 1
47470: DIFF
47471: PPUSH
47472: CALL_OW 1
47476: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47477: LD_ADDR_VAR 0 8
47481: PUSH
47482: LD_VAR 0 3
47486: PPUSH
47487: LD_INT 3
47489: PPUSH
47490: CALL 44150 0 2
47494: ST_TO_ADDR
// if fac then
47495: LD_VAR 0 8
47499: IFFALSE 47598
// begin for j in fac do
47501: LD_ADDR_VAR 0 4
47505: PUSH
47506: LD_VAR 0 8
47510: PUSH
47511: FOR_IN
47512: IFFALSE 47596
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47514: LD_ADDR_VAR 0 9
47518: PUSH
47519: LD_VAR 0 8
47523: PPUSH
47524: LD_VAR 0 1
47528: PPUSH
47529: CALL_OW 265
47533: PPUSH
47534: LD_VAR 0 1
47538: PPUSH
47539: CALL_OW 262
47543: PPUSH
47544: LD_VAR 0 1
47548: PPUSH
47549: CALL_OW 263
47553: PPUSH
47554: LD_VAR 0 1
47558: PPUSH
47559: CALL_OW 264
47563: PPUSH
47564: CALL 54525 0 5
47568: ST_TO_ADDR
// if components then
47569: LD_VAR 0 9
47573: IFFALSE 47594
// begin MC_InsertProduceList ( i , [ components ] ) ;
47575: LD_VAR 0 3
47579: PPUSH
47580: LD_VAR 0 9
47584: PUSH
47585: EMPTY
47586: LIST
47587: PPUSH
47588: CALL 43695 0 2
// break ;
47592: GO 47596
// end ; end ;
47594: GO 47511
47596: POP
47597: POP
// end ; end ; if GetType ( un ) = unit_building then
47598: LD_VAR 0 1
47602: PPUSH
47603: CALL_OW 247
47607: PUSH
47608: LD_INT 3
47610: EQUAL
47611: IFFALSE 48014
// begin btype := GetBType ( un ) ;
47613: LD_ADDR_VAR 0 5
47617: PUSH
47618: LD_VAR 0 1
47622: PPUSH
47623: CALL_OW 266
47627: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
47628: LD_VAR 0 5
47632: PUSH
47633: LD_INT 29
47635: PUSH
47636: LD_INT 30
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: IN
47643: IFFALSE 47716
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
47645: LD_VAR 0 1
47649: PPUSH
47650: CALL_OW 250
47654: PPUSH
47655: LD_VAR 0 1
47659: PPUSH
47660: CALL_OW 251
47664: PPUSH
47665: LD_VAR 0 1
47669: PPUSH
47670: CALL_OW 255
47674: PPUSH
47675: CALL_OW 440
47679: NOT
47680: IFFALSE 47716
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
47682: LD_VAR 0 1
47686: PPUSH
47687: CALL_OW 250
47691: PPUSH
47692: LD_VAR 0 1
47696: PPUSH
47697: CALL_OW 251
47701: PPUSH
47702: LD_VAR 0 1
47706: PPUSH
47707: CALL_OW 255
47711: PPUSH
47712: CALL_OW 441
// end ; if btype = b_warehouse then
47716: LD_VAR 0 5
47720: PUSH
47721: LD_INT 1
47723: EQUAL
47724: IFFALSE 47742
// begin btype := b_depot ;
47726: LD_ADDR_VAR 0 5
47730: PUSH
47731: LD_INT 0
47733: ST_TO_ADDR
// pos := 1 ;
47734: LD_ADDR_VAR 0 6
47738: PUSH
47739: LD_INT 1
47741: ST_TO_ADDR
// end ; if btype = b_factory then
47742: LD_VAR 0 5
47746: PUSH
47747: LD_INT 3
47749: EQUAL
47750: IFFALSE 47768
// begin btype := b_workshop ;
47752: LD_ADDR_VAR 0 5
47756: PUSH
47757: LD_INT 2
47759: ST_TO_ADDR
// pos := 1 ;
47760: LD_ADDR_VAR 0 6
47764: PUSH
47765: LD_INT 1
47767: ST_TO_ADDR
// end ; if btype = b_barracks then
47768: LD_VAR 0 5
47772: PUSH
47773: LD_INT 5
47775: EQUAL
47776: IFFALSE 47786
// btype := b_armoury ;
47778: LD_ADDR_VAR 0 5
47782: PUSH
47783: LD_INT 4
47785: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
47786: LD_VAR 0 5
47790: PUSH
47791: LD_INT 7
47793: PUSH
47794: LD_INT 8
47796: PUSH
47797: EMPTY
47798: LIST
47799: LIST
47800: IN
47801: IFFALSE 47811
// btype := b_lab ;
47803: LD_ADDR_VAR 0 5
47807: PUSH
47808: LD_INT 6
47810: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
47811: LD_ADDR_EXP 79
47815: PUSH
47816: LD_EXP 79
47820: PPUSH
47821: LD_VAR 0 3
47825: PUSH
47826: LD_EXP 79
47830: PUSH
47831: LD_VAR 0 3
47835: ARRAY
47836: PUSH
47837: LD_INT 1
47839: PLUS
47840: PUSH
47841: EMPTY
47842: LIST
47843: LIST
47844: PPUSH
47845: LD_VAR 0 5
47849: PUSH
47850: LD_VAR 0 1
47854: PPUSH
47855: CALL_OW 250
47859: PUSH
47860: LD_VAR 0 1
47864: PPUSH
47865: CALL_OW 251
47869: PUSH
47870: LD_VAR 0 1
47874: PPUSH
47875: CALL_OW 254
47879: PUSH
47880: EMPTY
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: PPUSH
47886: CALL 56993 0 3
47890: ST_TO_ADDR
// if pos = 1 then
47891: LD_VAR 0 6
47895: PUSH
47896: LD_INT 1
47898: EQUAL
47899: IFFALSE 48014
// begin tmp := mc_build_list [ i ] ;
47901: LD_ADDR_VAR 0 7
47905: PUSH
47906: LD_EXP 79
47910: PUSH
47911: LD_VAR 0 3
47915: ARRAY
47916: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47917: LD_VAR 0 7
47921: PPUSH
47922: LD_INT 2
47924: PUSH
47925: LD_INT 30
47927: PUSH
47928: LD_INT 0
47930: PUSH
47931: EMPTY
47932: LIST
47933: LIST
47934: PUSH
47935: LD_INT 30
47937: PUSH
47938: LD_INT 1
47940: PUSH
47941: EMPTY
47942: LIST
47943: LIST
47944: PUSH
47945: EMPTY
47946: LIST
47947: LIST
47948: LIST
47949: PPUSH
47950: CALL_OW 72
47954: IFFALSE 47964
// pos := 2 ;
47956: LD_ADDR_VAR 0 6
47960: PUSH
47961: LD_INT 2
47963: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47964: LD_ADDR_VAR 0 7
47968: PUSH
47969: LD_VAR 0 7
47973: PPUSH
47974: LD_VAR 0 6
47978: PPUSH
47979: LD_VAR 0 7
47983: PPUSH
47984: CALL 57319 0 3
47988: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47989: LD_ADDR_EXP 79
47993: PUSH
47994: LD_EXP 79
47998: PPUSH
47999: LD_VAR 0 3
48003: PPUSH
48004: LD_VAR 0 7
48008: PPUSH
48009: CALL_OW 1
48013: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48014: LD_VAR 0 1
48018: PUSH
48019: LD_EXP 74
48023: PUSH
48024: LD_VAR 0 3
48028: ARRAY
48029: IN
48030: IFFALSE 48069
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48032: LD_ADDR_EXP 74
48036: PUSH
48037: LD_EXP 74
48041: PPUSH
48042: LD_VAR 0 3
48046: PPUSH
48047: LD_EXP 74
48051: PUSH
48052: LD_VAR 0 3
48056: ARRAY
48057: PUSH
48058: LD_VAR 0 1
48062: DIFF
48063: PPUSH
48064: CALL_OW 1
48068: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48069: LD_VAR 0 1
48073: PUSH
48074: LD_EXP 81
48078: PUSH
48079: LD_VAR 0 3
48083: ARRAY
48084: IN
48085: IFFALSE 48124
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48087: LD_ADDR_EXP 81
48091: PUSH
48092: LD_EXP 81
48096: PPUSH
48097: LD_VAR 0 3
48101: PPUSH
48102: LD_EXP 81
48106: PUSH
48107: LD_VAR 0 3
48111: ARRAY
48112: PUSH
48113: LD_VAR 0 1
48117: DIFF
48118: PPUSH
48119: CALL_OW 1
48123: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48124: LD_VAR 0 1
48128: PUSH
48129: LD_EXP 93
48133: PUSH
48134: LD_VAR 0 3
48138: ARRAY
48139: IN
48140: IFFALSE 48179
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48142: LD_ADDR_EXP 93
48146: PUSH
48147: LD_EXP 93
48151: PPUSH
48152: LD_VAR 0 3
48156: PPUSH
48157: LD_EXP 93
48161: PUSH
48162: LD_VAR 0 3
48166: ARRAY
48167: PUSH
48168: LD_VAR 0 1
48172: DIFF
48173: PPUSH
48174: CALL_OW 1
48178: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48179: LD_VAR 0 1
48183: PUSH
48184: LD_EXP 96
48188: PUSH
48189: LD_VAR 0 3
48193: ARRAY
48194: IN
48195: IFFALSE 48234
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48197: LD_ADDR_EXP 96
48201: PUSH
48202: LD_EXP 96
48206: PPUSH
48207: LD_VAR 0 3
48211: PPUSH
48212: LD_EXP 96
48216: PUSH
48217: LD_VAR 0 3
48221: ARRAY
48222: PUSH
48223: LD_VAR 0 1
48227: DIFF
48228: PPUSH
48229: CALL_OW 1
48233: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48234: LD_VAR 0 1
48238: PUSH
48239: LD_EXP 83
48243: PUSH
48244: LD_VAR 0 3
48248: ARRAY
48249: IN
48250: IFFALSE 48289
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48252: LD_ADDR_EXP 83
48256: PUSH
48257: LD_EXP 83
48261: PPUSH
48262: LD_VAR 0 3
48266: PPUSH
48267: LD_EXP 83
48271: PUSH
48272: LD_VAR 0 3
48276: ARRAY
48277: PUSH
48278: LD_VAR 0 1
48282: DIFF
48283: PPUSH
48284: CALL_OW 1
48288: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48289: LD_VAR 0 1
48293: PUSH
48294: LD_EXP 82
48298: PUSH
48299: LD_VAR 0 3
48303: ARRAY
48304: IN
48305: IFFALSE 48344
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48307: LD_ADDR_EXP 82
48311: PUSH
48312: LD_EXP 82
48316: PPUSH
48317: LD_VAR 0 3
48321: PPUSH
48322: LD_EXP 82
48326: PUSH
48327: LD_VAR 0 3
48331: ARRAY
48332: PUSH
48333: LD_VAR 0 1
48337: DIFF
48338: PPUSH
48339: CALL_OW 1
48343: ST_TO_ADDR
// end ; break ;
48344: GO 48348
// end ;
48346: GO 47128
48348: POP
48349: POP
// end ;
48350: LD_VAR 0 2
48354: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48355: LD_INT 0
48357: PPUSH
48358: PPUSH
48359: PPUSH
// if not mc_bases or not skirmish then
48360: LD_EXP 74
48364: NOT
48365: PUSH
48366: LD_EXP 72
48370: NOT
48371: OR
48372: IFFALSE 48376
// exit ;
48374: GO 48591
// for i = 1 to mc_bases do
48376: LD_ADDR_VAR 0 3
48380: PUSH
48381: DOUBLE
48382: LD_INT 1
48384: DEC
48385: ST_TO_ADDR
48386: LD_EXP 74
48390: PUSH
48391: FOR_TO
48392: IFFALSE 48589
// begin if building in mc_construct_list [ i ] then
48394: LD_VAR 0 1
48398: PUSH
48399: LD_EXP 81
48403: PUSH
48404: LD_VAR 0 3
48408: ARRAY
48409: IN
48410: IFFALSE 48587
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48412: LD_ADDR_EXP 81
48416: PUSH
48417: LD_EXP 81
48421: PPUSH
48422: LD_VAR 0 3
48426: PPUSH
48427: LD_EXP 81
48431: PUSH
48432: LD_VAR 0 3
48436: ARRAY
48437: PUSH
48438: LD_VAR 0 1
48442: DIFF
48443: PPUSH
48444: CALL_OW 1
48448: ST_TO_ADDR
// if building in mc_lab [ i ] then
48449: LD_VAR 0 1
48453: PUSH
48454: LD_EXP 107
48458: PUSH
48459: LD_VAR 0 3
48463: ARRAY
48464: IN
48465: IFFALSE 48520
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
48467: LD_ADDR_EXP 108
48471: PUSH
48472: LD_EXP 108
48476: PPUSH
48477: LD_VAR 0 3
48481: PPUSH
48482: LD_EXP 108
48486: PUSH
48487: LD_VAR 0 3
48491: ARRAY
48492: PPUSH
48493: LD_INT 1
48495: PPUSH
48496: LD_EXP 108
48500: PUSH
48501: LD_VAR 0 3
48505: ARRAY
48506: PPUSH
48507: LD_INT 0
48509: PPUSH
48510: CALL 56411 0 4
48514: PPUSH
48515: CALL_OW 1
48519: ST_TO_ADDR
// if not building in mc_bases [ i ] then
48520: LD_VAR 0 1
48524: PUSH
48525: LD_EXP 74
48529: PUSH
48530: LD_VAR 0 3
48534: ARRAY
48535: IN
48536: NOT
48537: IFFALSE 48583
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48539: LD_ADDR_EXP 74
48543: PUSH
48544: LD_EXP 74
48548: PPUSH
48549: LD_VAR 0 3
48553: PUSH
48554: LD_EXP 74
48558: PUSH
48559: LD_VAR 0 3
48563: ARRAY
48564: PUSH
48565: LD_INT 1
48567: PLUS
48568: PUSH
48569: EMPTY
48570: LIST
48571: LIST
48572: PPUSH
48573: LD_VAR 0 1
48577: PPUSH
48578: CALL 56993 0 3
48582: ST_TO_ADDR
// exit ;
48583: POP
48584: POP
48585: GO 48591
// end ; end ;
48587: GO 48391
48589: POP
48590: POP
// end ;
48591: LD_VAR 0 2
48595: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
48596: LD_INT 0
48598: PPUSH
48599: PPUSH
48600: PPUSH
48601: PPUSH
48602: PPUSH
48603: PPUSH
48604: PPUSH
// if not mc_bases or not skirmish then
48605: LD_EXP 74
48609: NOT
48610: PUSH
48611: LD_EXP 72
48615: NOT
48616: OR
48617: IFFALSE 48621
// exit ;
48619: GO 49282
// for i = 1 to mc_bases do
48621: LD_ADDR_VAR 0 3
48625: PUSH
48626: DOUBLE
48627: LD_INT 1
48629: DEC
48630: ST_TO_ADDR
48631: LD_EXP 74
48635: PUSH
48636: FOR_TO
48637: IFFALSE 49280
// begin if building in mc_construct_list [ i ] then
48639: LD_VAR 0 1
48643: PUSH
48644: LD_EXP 81
48648: PUSH
48649: LD_VAR 0 3
48653: ARRAY
48654: IN
48655: IFFALSE 49278
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48657: LD_ADDR_EXP 81
48661: PUSH
48662: LD_EXP 81
48666: PPUSH
48667: LD_VAR 0 3
48671: PPUSH
48672: LD_EXP 81
48676: PUSH
48677: LD_VAR 0 3
48681: ARRAY
48682: PUSH
48683: LD_VAR 0 1
48687: DIFF
48688: PPUSH
48689: CALL_OW 1
48693: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48694: LD_ADDR_EXP 74
48698: PUSH
48699: LD_EXP 74
48703: PPUSH
48704: LD_VAR 0 3
48708: PUSH
48709: LD_EXP 74
48713: PUSH
48714: LD_VAR 0 3
48718: ARRAY
48719: PUSH
48720: LD_INT 1
48722: PLUS
48723: PUSH
48724: EMPTY
48725: LIST
48726: LIST
48727: PPUSH
48728: LD_VAR 0 1
48732: PPUSH
48733: CALL 56993 0 3
48737: ST_TO_ADDR
// btype := GetBType ( building ) ;
48738: LD_ADDR_VAR 0 5
48742: PUSH
48743: LD_VAR 0 1
48747: PPUSH
48748: CALL_OW 266
48752: ST_TO_ADDR
// side := GetSide ( building ) ;
48753: LD_ADDR_VAR 0 8
48757: PUSH
48758: LD_VAR 0 1
48762: PPUSH
48763: CALL_OW 255
48767: ST_TO_ADDR
// if btype = b_lab then
48768: LD_VAR 0 5
48772: PUSH
48773: LD_INT 6
48775: EQUAL
48776: IFFALSE 48826
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
48778: LD_ADDR_EXP 107
48782: PUSH
48783: LD_EXP 107
48787: PPUSH
48788: LD_VAR 0 3
48792: PUSH
48793: LD_EXP 107
48797: PUSH
48798: LD_VAR 0 3
48802: ARRAY
48803: PUSH
48804: LD_INT 1
48806: PLUS
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: PPUSH
48812: LD_VAR 0 1
48816: PPUSH
48817: CALL 56993 0 3
48821: ST_TO_ADDR
// exit ;
48822: POP
48823: POP
48824: GO 49282
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
48826: LD_VAR 0 5
48830: PUSH
48831: LD_INT 0
48833: PUSH
48834: LD_INT 2
48836: PUSH
48837: LD_INT 4
48839: PUSH
48840: EMPTY
48841: LIST
48842: LIST
48843: LIST
48844: IN
48845: IFFALSE 48969
// begin if btype = b_armoury then
48847: LD_VAR 0 5
48851: PUSH
48852: LD_INT 4
48854: EQUAL
48855: IFFALSE 48865
// btype := b_barracks ;
48857: LD_ADDR_VAR 0 5
48861: PUSH
48862: LD_INT 5
48864: ST_TO_ADDR
// if btype = b_depot then
48865: LD_VAR 0 5
48869: PUSH
48870: LD_INT 0
48872: EQUAL
48873: IFFALSE 48883
// btype := b_warehouse ;
48875: LD_ADDR_VAR 0 5
48879: PUSH
48880: LD_INT 1
48882: ST_TO_ADDR
// if btype = b_workshop then
48883: LD_VAR 0 5
48887: PUSH
48888: LD_INT 2
48890: EQUAL
48891: IFFALSE 48901
// btype := b_factory ;
48893: LD_ADDR_VAR 0 5
48897: PUSH
48898: LD_INT 3
48900: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48901: LD_VAR 0 5
48905: PPUSH
48906: LD_VAR 0 8
48910: PPUSH
48911: CALL_OW 323
48915: PUSH
48916: LD_INT 1
48918: EQUAL
48919: IFFALSE 48965
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48921: LD_ADDR_EXP 106
48925: PUSH
48926: LD_EXP 106
48930: PPUSH
48931: LD_VAR 0 3
48935: PUSH
48936: LD_EXP 106
48940: PUSH
48941: LD_VAR 0 3
48945: ARRAY
48946: PUSH
48947: LD_INT 1
48949: PLUS
48950: PUSH
48951: EMPTY
48952: LIST
48953: LIST
48954: PPUSH
48955: LD_VAR 0 1
48959: PPUSH
48960: CALL 56993 0 3
48964: ST_TO_ADDR
// exit ;
48965: POP
48966: POP
48967: GO 49282
// end ; if btype in [ b_bunker , b_turret ] then
48969: LD_VAR 0 5
48973: PUSH
48974: LD_INT 32
48976: PUSH
48977: LD_INT 33
48979: PUSH
48980: EMPTY
48981: LIST
48982: LIST
48983: IN
48984: IFFALSE 49274
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48986: LD_ADDR_EXP 82
48990: PUSH
48991: LD_EXP 82
48995: PPUSH
48996: LD_VAR 0 3
49000: PUSH
49001: LD_EXP 82
49005: PUSH
49006: LD_VAR 0 3
49010: ARRAY
49011: PUSH
49012: LD_INT 1
49014: PLUS
49015: PUSH
49016: EMPTY
49017: LIST
49018: LIST
49019: PPUSH
49020: LD_VAR 0 1
49024: PPUSH
49025: CALL 56993 0 3
49029: ST_TO_ADDR
// if btype = b_bunker then
49030: LD_VAR 0 5
49034: PUSH
49035: LD_INT 32
49037: EQUAL
49038: IFFALSE 49274
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49040: LD_ADDR_EXP 83
49044: PUSH
49045: LD_EXP 83
49049: PPUSH
49050: LD_VAR 0 3
49054: PUSH
49055: LD_EXP 83
49059: PUSH
49060: LD_VAR 0 3
49064: ARRAY
49065: PUSH
49066: LD_INT 1
49068: PLUS
49069: PUSH
49070: EMPTY
49071: LIST
49072: LIST
49073: PPUSH
49074: LD_VAR 0 1
49078: PPUSH
49079: CALL 56993 0 3
49083: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49084: LD_ADDR_VAR 0 6
49088: PUSH
49089: LD_EXP 74
49093: PUSH
49094: LD_VAR 0 3
49098: ARRAY
49099: PPUSH
49100: LD_INT 25
49102: PUSH
49103: LD_INT 1
49105: PUSH
49106: EMPTY
49107: LIST
49108: LIST
49109: PUSH
49110: LD_INT 3
49112: PUSH
49113: LD_INT 54
49115: PUSH
49116: EMPTY
49117: LIST
49118: PUSH
49119: EMPTY
49120: LIST
49121: LIST
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: PPUSH
49127: CALL_OW 72
49131: ST_TO_ADDR
// if tmp then
49132: LD_VAR 0 6
49136: IFFALSE 49142
// exit ;
49138: POP
49139: POP
49140: GO 49282
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49142: LD_ADDR_VAR 0 6
49146: PUSH
49147: LD_EXP 74
49151: PUSH
49152: LD_VAR 0 3
49156: ARRAY
49157: PPUSH
49158: LD_INT 2
49160: PUSH
49161: LD_INT 30
49163: PUSH
49164: LD_INT 4
49166: PUSH
49167: EMPTY
49168: LIST
49169: LIST
49170: PUSH
49171: LD_INT 30
49173: PUSH
49174: LD_INT 5
49176: PUSH
49177: EMPTY
49178: LIST
49179: LIST
49180: PUSH
49181: EMPTY
49182: LIST
49183: LIST
49184: LIST
49185: PPUSH
49186: CALL_OW 72
49190: ST_TO_ADDR
// if not tmp then
49191: LD_VAR 0 6
49195: NOT
49196: IFFALSE 49202
// exit ;
49198: POP
49199: POP
49200: GO 49282
// for j in tmp do
49202: LD_ADDR_VAR 0 4
49206: PUSH
49207: LD_VAR 0 6
49211: PUSH
49212: FOR_IN
49213: IFFALSE 49272
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49215: LD_ADDR_VAR 0 7
49219: PUSH
49220: LD_VAR 0 4
49224: PPUSH
49225: CALL_OW 313
49229: PPUSH
49230: LD_INT 25
49232: PUSH
49233: LD_INT 1
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PPUSH
49240: CALL_OW 72
49244: ST_TO_ADDR
// if units then
49245: LD_VAR 0 7
49249: IFFALSE 49270
// begin ComExitBuilding ( units [ 1 ] ) ;
49251: LD_VAR 0 7
49255: PUSH
49256: LD_INT 1
49258: ARRAY
49259: PPUSH
49260: CALL_OW 122
// exit ;
49264: POP
49265: POP
49266: POP
49267: POP
49268: GO 49282
// end ; end ;
49270: GO 49212
49272: POP
49273: POP
// end ; end ; exit ;
49274: POP
49275: POP
49276: GO 49282
// end ; end ;
49278: GO 48636
49280: POP
49281: POP
// end ;
49282: LD_VAR 0 2
49286: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49287: LD_INT 0
49289: PPUSH
49290: PPUSH
49291: PPUSH
49292: PPUSH
49293: PPUSH
49294: PPUSH
49295: PPUSH
// if not mc_bases or not skirmish then
49296: LD_EXP 74
49300: NOT
49301: PUSH
49302: LD_EXP 72
49306: NOT
49307: OR
49308: IFFALSE 49312
// exit ;
49310: GO 49543
// btype := GetBType ( building ) ;
49312: LD_ADDR_VAR 0 6
49316: PUSH
49317: LD_VAR 0 1
49321: PPUSH
49322: CALL_OW 266
49326: ST_TO_ADDR
// x := GetX ( building ) ;
49327: LD_ADDR_VAR 0 7
49331: PUSH
49332: LD_VAR 0 1
49336: PPUSH
49337: CALL_OW 250
49341: ST_TO_ADDR
// y := GetY ( building ) ;
49342: LD_ADDR_VAR 0 8
49346: PUSH
49347: LD_VAR 0 1
49351: PPUSH
49352: CALL_OW 251
49356: ST_TO_ADDR
// d := GetDir ( building ) ;
49357: LD_ADDR_VAR 0 9
49361: PUSH
49362: LD_VAR 0 1
49366: PPUSH
49367: CALL_OW 254
49371: ST_TO_ADDR
// for i = 1 to mc_bases do
49372: LD_ADDR_VAR 0 4
49376: PUSH
49377: DOUBLE
49378: LD_INT 1
49380: DEC
49381: ST_TO_ADDR
49382: LD_EXP 74
49386: PUSH
49387: FOR_TO
49388: IFFALSE 49541
// begin if not mc_build_list [ i ] then
49390: LD_EXP 79
49394: PUSH
49395: LD_VAR 0 4
49399: ARRAY
49400: NOT
49401: IFFALSE 49405
// continue ;
49403: GO 49387
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
49405: LD_VAR 0 6
49409: PUSH
49410: LD_VAR 0 7
49414: PUSH
49415: LD_VAR 0 8
49419: PUSH
49420: LD_VAR 0 9
49424: PUSH
49425: EMPTY
49426: LIST
49427: LIST
49428: LIST
49429: LIST
49430: PPUSH
49431: LD_EXP 79
49435: PUSH
49436: LD_VAR 0 4
49440: ARRAY
49441: PUSH
49442: LD_INT 1
49444: ARRAY
49445: PPUSH
49446: CALL 63162 0 2
49450: IFFALSE 49539
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
49452: LD_ADDR_EXP 79
49456: PUSH
49457: LD_EXP 79
49461: PPUSH
49462: LD_VAR 0 4
49466: PPUSH
49467: LD_EXP 79
49471: PUSH
49472: LD_VAR 0 4
49476: ARRAY
49477: PPUSH
49478: LD_INT 1
49480: PPUSH
49481: CALL_OW 3
49485: PPUSH
49486: CALL_OW 1
49490: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
49491: LD_ADDR_EXP 81
49495: PUSH
49496: LD_EXP 81
49500: PPUSH
49501: LD_VAR 0 4
49505: PUSH
49506: LD_EXP 81
49510: PUSH
49511: LD_VAR 0 4
49515: ARRAY
49516: PUSH
49517: LD_INT 1
49519: PLUS
49520: PUSH
49521: EMPTY
49522: LIST
49523: LIST
49524: PPUSH
49525: LD_VAR 0 1
49529: PPUSH
49530: CALL 56993 0 3
49534: ST_TO_ADDR
// exit ;
49535: POP
49536: POP
49537: GO 49543
// end ; end ;
49539: GO 49387
49541: POP
49542: POP
// end ;
49543: LD_VAR 0 3
49547: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
49548: LD_INT 0
49550: PPUSH
49551: PPUSH
49552: PPUSH
// if not mc_bases or not skirmish then
49553: LD_EXP 74
49557: NOT
49558: PUSH
49559: LD_EXP 72
49563: NOT
49564: OR
49565: IFFALSE 49569
// exit ;
49567: GO 49759
// for i = 1 to mc_bases do
49569: LD_ADDR_VAR 0 4
49573: PUSH
49574: DOUBLE
49575: LD_INT 1
49577: DEC
49578: ST_TO_ADDR
49579: LD_EXP 74
49583: PUSH
49584: FOR_TO
49585: IFFALSE 49672
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
49587: LD_VAR 0 1
49591: PUSH
49592: LD_EXP 82
49596: PUSH
49597: LD_VAR 0 4
49601: ARRAY
49602: IN
49603: PUSH
49604: LD_VAR 0 1
49608: PUSH
49609: LD_EXP 83
49613: PUSH
49614: LD_VAR 0 4
49618: ARRAY
49619: IN
49620: NOT
49621: AND
49622: IFFALSE 49670
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49624: LD_ADDR_EXP 83
49628: PUSH
49629: LD_EXP 83
49633: PPUSH
49634: LD_VAR 0 4
49638: PUSH
49639: LD_EXP 83
49643: PUSH
49644: LD_VAR 0 4
49648: ARRAY
49649: PUSH
49650: LD_INT 1
49652: PLUS
49653: PUSH
49654: EMPTY
49655: LIST
49656: LIST
49657: PPUSH
49658: LD_VAR 0 1
49662: PPUSH
49663: CALL 56993 0 3
49667: ST_TO_ADDR
// break ;
49668: GO 49672
// end ; end ;
49670: GO 49584
49672: POP
49673: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
49674: LD_VAR 0 1
49678: PPUSH
49679: CALL_OW 257
49683: PUSH
49684: LD_EXP 100
49688: IN
49689: PUSH
49690: LD_VAR 0 1
49694: PPUSH
49695: CALL_OW 266
49699: PUSH
49700: LD_INT 5
49702: EQUAL
49703: AND
49704: PUSH
49705: LD_VAR 0 2
49709: PPUSH
49710: CALL_OW 110
49714: PUSH
49715: LD_INT 18
49717: NONEQUAL
49718: AND
49719: IFFALSE 49759
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
49721: LD_VAR 0 2
49725: PPUSH
49726: CALL_OW 257
49730: PUSH
49731: LD_INT 5
49733: PUSH
49734: LD_INT 8
49736: PUSH
49737: LD_INT 9
49739: PUSH
49740: EMPTY
49741: LIST
49742: LIST
49743: LIST
49744: IN
49745: IFFALSE 49759
// SetClass ( unit , 1 ) ;
49747: LD_VAR 0 2
49751: PPUSH
49752: LD_INT 1
49754: PPUSH
49755: CALL_OW 336
// end ;
49759: LD_VAR 0 3
49763: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
49764: LD_INT 0
49766: PPUSH
49767: PPUSH
// if not mc_bases or not skirmish then
49768: LD_EXP 74
49772: NOT
49773: PUSH
49774: LD_EXP 72
49778: NOT
49779: OR
49780: IFFALSE 49784
// exit ;
49782: GO 49900
// if GetLives ( abandoned_vehicle ) > 250 then
49784: LD_VAR 0 2
49788: PPUSH
49789: CALL_OW 256
49793: PUSH
49794: LD_INT 250
49796: GREATER
49797: IFFALSE 49801
// exit ;
49799: GO 49900
// for i = 1 to mc_bases do
49801: LD_ADDR_VAR 0 6
49805: PUSH
49806: DOUBLE
49807: LD_INT 1
49809: DEC
49810: ST_TO_ADDR
49811: LD_EXP 74
49815: PUSH
49816: FOR_TO
49817: IFFALSE 49898
// begin if driver in mc_bases [ i ] then
49819: LD_VAR 0 1
49823: PUSH
49824: LD_EXP 74
49828: PUSH
49829: LD_VAR 0 6
49833: ARRAY
49834: IN
49835: IFFALSE 49896
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49837: LD_VAR 0 1
49841: PPUSH
49842: LD_EXP 74
49846: PUSH
49847: LD_VAR 0 6
49851: ARRAY
49852: PPUSH
49853: LD_INT 2
49855: PUSH
49856: LD_INT 30
49858: PUSH
49859: LD_INT 0
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PUSH
49866: LD_INT 30
49868: PUSH
49869: LD_INT 1
49871: PUSH
49872: EMPTY
49873: LIST
49874: LIST
49875: PUSH
49876: EMPTY
49877: LIST
49878: LIST
49879: LIST
49880: PPUSH
49881: CALL_OW 72
49885: PUSH
49886: LD_INT 1
49888: ARRAY
49889: PPUSH
49890: CALL_OW 112
// break ;
49894: GO 49898
// end ; end ;
49896: GO 49816
49898: POP
49899: POP
// end ; end_of_file
49900: LD_VAR 0 5
49904: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49905: LD_INT 0
49907: PPUSH
49908: PPUSH
// if exist_mode then
49909: LD_VAR 0 2
49913: IFFALSE 49938
// unit := CreateCharacter ( prefix & ident ) else
49915: LD_ADDR_VAR 0 5
49919: PUSH
49920: LD_VAR 0 3
49924: PUSH
49925: LD_VAR 0 1
49929: STR
49930: PPUSH
49931: CALL_OW 34
49935: ST_TO_ADDR
49936: GO 49953
// unit := NewCharacter ( ident ) ;
49938: LD_ADDR_VAR 0 5
49942: PUSH
49943: LD_VAR 0 1
49947: PPUSH
49948: CALL_OW 25
49952: ST_TO_ADDR
// result := unit ;
49953: LD_ADDR_VAR 0 4
49957: PUSH
49958: LD_VAR 0 5
49962: ST_TO_ADDR
// end ;
49963: LD_VAR 0 4
49967: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49968: LD_INT 0
49970: PPUSH
49971: PPUSH
// if not side or not nation then
49972: LD_VAR 0 1
49976: NOT
49977: PUSH
49978: LD_VAR 0 2
49982: NOT
49983: OR
49984: IFFALSE 49988
// exit ;
49986: GO 50632
// case nation of nation_american :
49988: LD_VAR 0 2
49992: PUSH
49993: LD_INT 1
49995: DOUBLE
49996: EQUAL
49997: IFTRUE 50001
49999: GO 50175
50001: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
50002: LD_ADDR_VAR 0 4
50006: PUSH
50007: LD_INT 35
50009: PUSH
50010: LD_INT 45
50012: PUSH
50013: LD_INT 46
50015: PUSH
50016: LD_INT 47
50018: PUSH
50019: LD_INT 1
50021: PUSH
50022: LD_INT 2
50024: PUSH
50025: LD_INT 6
50027: PUSH
50028: LD_INT 15
50030: PUSH
50031: LD_INT 16
50033: PUSH
50034: LD_INT 7
50036: PUSH
50037: LD_INT 12
50039: PUSH
50040: LD_INT 13
50042: PUSH
50043: LD_INT 10
50045: PUSH
50046: LD_INT 14
50048: PUSH
50049: LD_INT 20
50051: PUSH
50052: LD_INT 21
50054: PUSH
50055: LD_INT 22
50057: PUSH
50058: LD_INT 25
50060: PUSH
50061: LD_INT 32
50063: PUSH
50064: LD_INT 27
50066: PUSH
50067: LD_INT 36
50069: PUSH
50070: LD_INT 69
50072: PUSH
50073: LD_INT 39
50075: PUSH
50076: LD_INT 34
50078: PUSH
50079: LD_INT 40
50081: PUSH
50082: LD_INT 48
50084: PUSH
50085: LD_INT 49
50087: PUSH
50088: LD_INT 50
50090: PUSH
50091: LD_INT 51
50093: PUSH
50094: LD_INT 52
50096: PUSH
50097: LD_INT 53
50099: PUSH
50100: LD_INT 54
50102: PUSH
50103: LD_INT 55
50105: PUSH
50106: LD_INT 56
50108: PUSH
50109: LD_INT 57
50111: PUSH
50112: LD_INT 58
50114: PUSH
50115: LD_INT 59
50117: PUSH
50118: LD_INT 60
50120: PUSH
50121: LD_INT 61
50123: PUSH
50124: LD_INT 62
50126: PUSH
50127: LD_INT 80
50129: PUSH
50130: EMPTY
50131: LIST
50132: LIST
50133: LIST
50134: LIST
50135: LIST
50136: LIST
50137: LIST
50138: LIST
50139: LIST
50140: LIST
50141: LIST
50142: LIST
50143: LIST
50144: LIST
50145: LIST
50146: LIST
50147: LIST
50148: LIST
50149: LIST
50150: LIST
50151: LIST
50152: LIST
50153: LIST
50154: LIST
50155: LIST
50156: LIST
50157: LIST
50158: LIST
50159: LIST
50160: LIST
50161: LIST
50162: LIST
50163: LIST
50164: LIST
50165: LIST
50166: LIST
50167: LIST
50168: LIST
50169: LIST
50170: LIST
50171: LIST
50172: ST_TO_ADDR
50173: GO 50556
50175: LD_INT 2
50177: DOUBLE
50178: EQUAL
50179: IFTRUE 50183
50181: GO 50365
50183: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50184: LD_ADDR_VAR 0 4
50188: PUSH
50189: LD_INT 35
50191: PUSH
50192: LD_INT 45
50194: PUSH
50195: LD_INT 46
50197: PUSH
50198: LD_INT 47
50200: PUSH
50201: LD_INT 70
50203: PUSH
50204: LD_INT 1
50206: PUSH
50207: LD_INT 11
50209: PUSH
50210: LD_INT 3
50212: PUSH
50213: LD_INT 4
50215: PUSH
50216: LD_INT 5
50218: PUSH
50219: LD_INT 6
50221: PUSH
50222: LD_INT 15
50224: PUSH
50225: LD_INT 18
50227: PUSH
50228: LD_INT 7
50230: PUSH
50231: LD_INT 17
50233: PUSH
50234: LD_INT 8
50236: PUSH
50237: LD_INT 20
50239: PUSH
50240: LD_INT 21
50242: PUSH
50243: LD_INT 22
50245: PUSH
50246: LD_INT 72
50248: PUSH
50249: LD_INT 26
50251: PUSH
50252: LD_INT 69
50254: PUSH
50255: LD_INT 39
50257: PUSH
50258: LD_INT 40
50260: PUSH
50261: LD_INT 41
50263: PUSH
50264: LD_INT 42
50266: PUSH
50267: LD_INT 43
50269: PUSH
50270: LD_INT 48
50272: PUSH
50273: LD_INT 49
50275: PUSH
50276: LD_INT 50
50278: PUSH
50279: LD_INT 51
50281: PUSH
50282: LD_INT 52
50284: PUSH
50285: LD_INT 53
50287: PUSH
50288: LD_INT 54
50290: PUSH
50291: LD_INT 55
50293: PUSH
50294: LD_INT 56
50296: PUSH
50297: LD_INT 60
50299: PUSH
50300: LD_INT 61
50302: PUSH
50303: LD_INT 62
50305: PUSH
50306: LD_INT 66
50308: PUSH
50309: LD_INT 67
50311: PUSH
50312: LD_INT 68
50314: PUSH
50315: LD_INT 81
50317: PUSH
50318: EMPTY
50319: LIST
50320: LIST
50321: LIST
50322: LIST
50323: LIST
50324: LIST
50325: LIST
50326: LIST
50327: LIST
50328: LIST
50329: LIST
50330: LIST
50331: LIST
50332: LIST
50333: LIST
50334: LIST
50335: LIST
50336: LIST
50337: LIST
50338: LIST
50339: LIST
50340: LIST
50341: LIST
50342: LIST
50343: LIST
50344: LIST
50345: LIST
50346: LIST
50347: LIST
50348: LIST
50349: LIST
50350: LIST
50351: LIST
50352: LIST
50353: LIST
50354: LIST
50355: LIST
50356: LIST
50357: LIST
50358: LIST
50359: LIST
50360: LIST
50361: LIST
50362: ST_TO_ADDR
50363: GO 50556
50365: LD_INT 3
50367: DOUBLE
50368: EQUAL
50369: IFTRUE 50373
50371: GO 50555
50373: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
50374: LD_ADDR_VAR 0 4
50378: PUSH
50379: LD_INT 46
50381: PUSH
50382: LD_INT 47
50384: PUSH
50385: LD_INT 1
50387: PUSH
50388: LD_INT 2
50390: PUSH
50391: LD_INT 11
50393: PUSH
50394: LD_INT 9
50396: PUSH
50397: LD_INT 20
50399: PUSH
50400: LD_INT 19
50402: PUSH
50403: LD_INT 21
50405: PUSH
50406: LD_INT 24
50408: PUSH
50409: LD_INT 22
50411: PUSH
50412: LD_INT 25
50414: PUSH
50415: LD_INT 28
50417: PUSH
50418: LD_INT 29
50420: PUSH
50421: LD_INT 30
50423: PUSH
50424: LD_INT 31
50426: PUSH
50427: LD_INT 37
50429: PUSH
50430: LD_INT 38
50432: PUSH
50433: LD_INT 32
50435: PUSH
50436: LD_INT 27
50438: PUSH
50439: LD_INT 33
50441: PUSH
50442: LD_INT 69
50444: PUSH
50445: LD_INT 39
50447: PUSH
50448: LD_INT 34
50450: PUSH
50451: LD_INT 40
50453: PUSH
50454: LD_INT 71
50456: PUSH
50457: LD_INT 23
50459: PUSH
50460: LD_INT 44
50462: PUSH
50463: LD_INT 48
50465: PUSH
50466: LD_INT 49
50468: PUSH
50469: LD_INT 50
50471: PUSH
50472: LD_INT 51
50474: PUSH
50475: LD_INT 52
50477: PUSH
50478: LD_INT 53
50480: PUSH
50481: LD_INT 54
50483: PUSH
50484: LD_INT 55
50486: PUSH
50487: LD_INT 56
50489: PUSH
50490: LD_INT 57
50492: PUSH
50493: LD_INT 58
50495: PUSH
50496: LD_INT 59
50498: PUSH
50499: LD_INT 63
50501: PUSH
50502: LD_INT 64
50504: PUSH
50505: LD_INT 65
50507: PUSH
50508: EMPTY
50509: LIST
50510: LIST
50511: LIST
50512: LIST
50513: LIST
50514: LIST
50515: LIST
50516: LIST
50517: LIST
50518: LIST
50519: LIST
50520: LIST
50521: LIST
50522: LIST
50523: LIST
50524: LIST
50525: LIST
50526: LIST
50527: LIST
50528: LIST
50529: LIST
50530: LIST
50531: LIST
50532: LIST
50533: LIST
50534: LIST
50535: LIST
50536: LIST
50537: LIST
50538: LIST
50539: LIST
50540: LIST
50541: LIST
50542: LIST
50543: LIST
50544: LIST
50545: LIST
50546: LIST
50547: LIST
50548: LIST
50549: LIST
50550: LIST
50551: LIST
50552: ST_TO_ADDR
50553: GO 50556
50555: POP
// if state > - 1 and state < 3 then
50556: LD_VAR 0 3
50560: PUSH
50561: LD_INT 1
50563: NEG
50564: GREATER
50565: PUSH
50566: LD_VAR 0 3
50570: PUSH
50571: LD_INT 3
50573: LESS
50574: AND
50575: IFFALSE 50632
// for i in result do
50577: LD_ADDR_VAR 0 5
50581: PUSH
50582: LD_VAR 0 4
50586: PUSH
50587: FOR_IN
50588: IFFALSE 50630
// if GetTech ( i , side ) <> state then
50590: LD_VAR 0 5
50594: PPUSH
50595: LD_VAR 0 1
50599: PPUSH
50600: CALL_OW 321
50604: PUSH
50605: LD_VAR 0 3
50609: NONEQUAL
50610: IFFALSE 50628
// result := result diff i ;
50612: LD_ADDR_VAR 0 4
50616: PUSH
50617: LD_VAR 0 4
50621: PUSH
50622: LD_VAR 0 5
50626: DIFF
50627: ST_TO_ADDR
50628: GO 50587
50630: POP
50631: POP
// end ;
50632: LD_VAR 0 4
50636: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50637: LD_INT 0
50639: PPUSH
50640: PPUSH
50641: PPUSH
// result := true ;
50642: LD_ADDR_VAR 0 3
50646: PUSH
50647: LD_INT 1
50649: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50650: LD_ADDR_VAR 0 5
50654: PUSH
50655: LD_VAR 0 2
50659: PPUSH
50660: CALL_OW 480
50664: ST_TO_ADDR
// if not tmp then
50665: LD_VAR 0 5
50669: NOT
50670: IFFALSE 50674
// exit ;
50672: GO 50723
// for i in tmp do
50674: LD_ADDR_VAR 0 4
50678: PUSH
50679: LD_VAR 0 5
50683: PUSH
50684: FOR_IN
50685: IFFALSE 50721
// if GetTech ( i , side ) <> state_researched then
50687: LD_VAR 0 4
50691: PPUSH
50692: LD_VAR 0 1
50696: PPUSH
50697: CALL_OW 321
50701: PUSH
50702: LD_INT 2
50704: NONEQUAL
50705: IFFALSE 50719
// begin result := false ;
50707: LD_ADDR_VAR 0 3
50711: PUSH
50712: LD_INT 0
50714: ST_TO_ADDR
// exit ;
50715: POP
50716: POP
50717: GO 50723
// end ;
50719: GO 50684
50721: POP
50722: POP
// end ;
50723: LD_VAR 0 3
50727: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50728: LD_INT 0
50730: PPUSH
50731: PPUSH
50732: PPUSH
50733: PPUSH
50734: PPUSH
50735: PPUSH
50736: PPUSH
50737: PPUSH
50738: PPUSH
50739: PPUSH
50740: PPUSH
50741: PPUSH
50742: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50743: LD_VAR 0 1
50747: NOT
50748: PUSH
50749: LD_VAR 0 1
50753: PPUSH
50754: CALL_OW 257
50758: PUSH
50759: LD_INT 9
50761: NONEQUAL
50762: OR
50763: IFFALSE 50767
// exit ;
50765: GO 51340
// side := GetSide ( unit ) ;
50767: LD_ADDR_VAR 0 9
50771: PUSH
50772: LD_VAR 0 1
50776: PPUSH
50777: CALL_OW 255
50781: ST_TO_ADDR
// tech_space := tech_spacanom ;
50782: LD_ADDR_VAR 0 12
50786: PUSH
50787: LD_INT 29
50789: ST_TO_ADDR
// tech_time := tech_taurad ;
50790: LD_ADDR_VAR 0 13
50794: PUSH
50795: LD_INT 28
50797: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50798: LD_ADDR_VAR 0 11
50802: PUSH
50803: LD_VAR 0 1
50807: PPUSH
50808: CALL_OW 310
50812: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50813: LD_VAR 0 11
50817: PPUSH
50818: CALL_OW 247
50822: PUSH
50823: LD_INT 2
50825: EQUAL
50826: IFFALSE 50830
// exit ;
50828: GO 51340
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50830: LD_ADDR_VAR 0 8
50834: PUSH
50835: LD_INT 81
50837: PUSH
50838: LD_VAR 0 9
50842: PUSH
50843: EMPTY
50844: LIST
50845: LIST
50846: PUSH
50847: LD_INT 3
50849: PUSH
50850: LD_INT 21
50852: PUSH
50853: LD_INT 3
50855: PUSH
50856: EMPTY
50857: LIST
50858: LIST
50859: PUSH
50860: EMPTY
50861: LIST
50862: LIST
50863: PUSH
50864: EMPTY
50865: LIST
50866: LIST
50867: PPUSH
50868: CALL_OW 69
50872: ST_TO_ADDR
// if not tmp then
50873: LD_VAR 0 8
50877: NOT
50878: IFFALSE 50882
// exit ;
50880: GO 51340
// if in_unit then
50882: LD_VAR 0 11
50886: IFFALSE 50910
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50888: LD_ADDR_VAR 0 10
50892: PUSH
50893: LD_VAR 0 8
50897: PPUSH
50898: LD_VAR 0 11
50902: PPUSH
50903: CALL_OW 74
50907: ST_TO_ADDR
50908: GO 50930
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50910: LD_ADDR_VAR 0 10
50914: PUSH
50915: LD_VAR 0 8
50919: PPUSH
50920: LD_VAR 0 1
50924: PPUSH
50925: CALL_OW 74
50929: ST_TO_ADDR
// if not enemy then
50930: LD_VAR 0 10
50934: NOT
50935: IFFALSE 50939
// exit ;
50937: GO 51340
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50939: LD_VAR 0 11
50943: PUSH
50944: LD_VAR 0 11
50948: PPUSH
50949: LD_VAR 0 10
50953: PPUSH
50954: CALL_OW 296
50958: PUSH
50959: LD_INT 13
50961: GREATER
50962: AND
50963: PUSH
50964: LD_VAR 0 1
50968: PPUSH
50969: LD_VAR 0 10
50973: PPUSH
50974: CALL_OW 296
50978: PUSH
50979: LD_INT 12
50981: GREATER
50982: OR
50983: IFFALSE 50987
// exit ;
50985: GO 51340
// missile := [ 1 ] ;
50987: LD_ADDR_VAR 0 14
50991: PUSH
50992: LD_INT 1
50994: PUSH
50995: EMPTY
50996: LIST
50997: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50998: LD_VAR 0 9
51002: PPUSH
51003: LD_VAR 0 12
51007: PPUSH
51008: CALL_OW 325
51012: IFFALSE 51041
// missile := Insert ( missile , missile + 1 , 2 ) ;
51014: LD_ADDR_VAR 0 14
51018: PUSH
51019: LD_VAR 0 14
51023: PPUSH
51024: LD_VAR 0 14
51028: PUSH
51029: LD_INT 1
51031: PLUS
51032: PPUSH
51033: LD_INT 2
51035: PPUSH
51036: CALL_OW 2
51040: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51041: LD_VAR 0 9
51045: PPUSH
51046: LD_VAR 0 13
51050: PPUSH
51051: CALL_OW 325
51055: PUSH
51056: LD_VAR 0 10
51060: PPUSH
51061: CALL_OW 255
51065: PPUSH
51066: LD_VAR 0 13
51070: PPUSH
51071: CALL_OW 325
51075: NOT
51076: AND
51077: IFFALSE 51106
// missile := Insert ( missile , missile + 1 , 3 ) ;
51079: LD_ADDR_VAR 0 14
51083: PUSH
51084: LD_VAR 0 14
51088: PPUSH
51089: LD_VAR 0 14
51093: PUSH
51094: LD_INT 1
51096: PLUS
51097: PPUSH
51098: LD_INT 3
51100: PPUSH
51101: CALL_OW 2
51105: ST_TO_ADDR
// if missile < 2 then
51106: LD_VAR 0 14
51110: PUSH
51111: LD_INT 2
51113: LESS
51114: IFFALSE 51118
// exit ;
51116: GO 51340
// x := GetX ( enemy ) ;
51118: LD_ADDR_VAR 0 4
51122: PUSH
51123: LD_VAR 0 10
51127: PPUSH
51128: CALL_OW 250
51132: ST_TO_ADDR
// y := GetY ( enemy ) ;
51133: LD_ADDR_VAR 0 5
51137: PUSH
51138: LD_VAR 0 10
51142: PPUSH
51143: CALL_OW 251
51147: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51148: LD_ADDR_VAR 0 6
51152: PUSH
51153: LD_VAR 0 4
51157: PUSH
51158: LD_INT 1
51160: NEG
51161: PPUSH
51162: LD_INT 1
51164: PPUSH
51165: CALL_OW 12
51169: PLUS
51170: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51171: LD_ADDR_VAR 0 7
51175: PUSH
51176: LD_VAR 0 5
51180: PUSH
51181: LD_INT 1
51183: NEG
51184: PPUSH
51185: LD_INT 1
51187: PPUSH
51188: CALL_OW 12
51192: PLUS
51193: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51194: LD_VAR 0 6
51198: PPUSH
51199: LD_VAR 0 7
51203: PPUSH
51204: CALL_OW 488
51208: NOT
51209: IFFALSE 51231
// begin _x := x ;
51211: LD_ADDR_VAR 0 6
51215: PUSH
51216: LD_VAR 0 4
51220: ST_TO_ADDR
// _y := y ;
51221: LD_ADDR_VAR 0 7
51225: PUSH
51226: LD_VAR 0 5
51230: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51231: LD_ADDR_VAR 0 3
51235: PUSH
51236: LD_INT 1
51238: PPUSH
51239: LD_VAR 0 14
51243: PPUSH
51244: CALL_OW 12
51248: ST_TO_ADDR
// case i of 1 :
51249: LD_VAR 0 3
51253: PUSH
51254: LD_INT 1
51256: DOUBLE
51257: EQUAL
51258: IFTRUE 51262
51260: GO 51279
51262: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51263: LD_VAR 0 1
51267: PPUSH
51268: LD_VAR 0 10
51272: PPUSH
51273: CALL_OW 115
51277: GO 51340
51279: LD_INT 2
51281: DOUBLE
51282: EQUAL
51283: IFTRUE 51287
51285: GO 51309
51287: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51288: LD_VAR 0 1
51292: PPUSH
51293: LD_VAR 0 6
51297: PPUSH
51298: LD_VAR 0 7
51302: PPUSH
51303: CALL_OW 153
51307: GO 51340
51309: LD_INT 3
51311: DOUBLE
51312: EQUAL
51313: IFTRUE 51317
51315: GO 51339
51317: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51318: LD_VAR 0 1
51322: PPUSH
51323: LD_VAR 0 6
51327: PPUSH
51328: LD_VAR 0 7
51332: PPUSH
51333: CALL_OW 154
51337: GO 51340
51339: POP
// end ;
51340: LD_VAR 0 2
51344: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51345: LD_INT 0
51347: PPUSH
51348: PPUSH
51349: PPUSH
51350: PPUSH
51351: PPUSH
51352: PPUSH
// if not unit or not building then
51353: LD_VAR 0 1
51357: NOT
51358: PUSH
51359: LD_VAR 0 2
51363: NOT
51364: OR
51365: IFFALSE 51369
// exit ;
51367: GO 51527
// x := GetX ( building ) ;
51369: LD_ADDR_VAR 0 5
51373: PUSH
51374: LD_VAR 0 2
51378: PPUSH
51379: CALL_OW 250
51383: ST_TO_ADDR
// y := GetY ( building ) ;
51384: LD_ADDR_VAR 0 6
51388: PUSH
51389: LD_VAR 0 2
51393: PPUSH
51394: CALL_OW 251
51398: ST_TO_ADDR
// for i = 0 to 5 do
51399: LD_ADDR_VAR 0 4
51403: PUSH
51404: DOUBLE
51405: LD_INT 0
51407: DEC
51408: ST_TO_ADDR
51409: LD_INT 5
51411: PUSH
51412: FOR_TO
51413: IFFALSE 51525
// begin _x := ShiftX ( x , i , 3 ) ;
51415: LD_ADDR_VAR 0 7
51419: PUSH
51420: LD_VAR 0 5
51424: PPUSH
51425: LD_VAR 0 4
51429: PPUSH
51430: LD_INT 3
51432: PPUSH
51433: CALL_OW 272
51437: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
51438: LD_ADDR_VAR 0 8
51442: PUSH
51443: LD_VAR 0 6
51447: PPUSH
51448: LD_VAR 0 4
51452: PPUSH
51453: LD_INT 3
51455: PPUSH
51456: CALL_OW 273
51460: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51461: LD_VAR 0 7
51465: PPUSH
51466: LD_VAR 0 8
51470: PPUSH
51471: CALL_OW 488
51475: NOT
51476: IFFALSE 51480
// continue ;
51478: GO 51412
// if HexInfo ( _x , _y ) = 0 then
51480: LD_VAR 0 7
51484: PPUSH
51485: LD_VAR 0 8
51489: PPUSH
51490: CALL_OW 428
51494: PUSH
51495: LD_INT 0
51497: EQUAL
51498: IFFALSE 51523
// begin ComMoveXY ( unit , _x , _y ) ;
51500: LD_VAR 0 1
51504: PPUSH
51505: LD_VAR 0 7
51509: PPUSH
51510: LD_VAR 0 8
51514: PPUSH
51515: CALL_OW 111
// exit ;
51519: POP
51520: POP
51521: GO 51527
// end ; end ;
51523: GO 51412
51525: POP
51526: POP
// end ;
51527: LD_VAR 0 3
51531: RET
// export function ScanBase ( side , base_area ) ; begin
51532: LD_INT 0
51534: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
51535: LD_ADDR_VAR 0 3
51539: PUSH
51540: LD_VAR 0 2
51544: PPUSH
51545: LD_INT 81
51547: PUSH
51548: LD_VAR 0 1
51552: PUSH
51553: EMPTY
51554: LIST
51555: LIST
51556: PPUSH
51557: CALL_OW 70
51561: ST_TO_ADDR
// end ;
51562: LD_VAR 0 3
51566: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
51567: LD_INT 0
51569: PPUSH
51570: PPUSH
51571: PPUSH
51572: PPUSH
51573: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
51574: LD_VAR 0 1
51578: NOT
51579: PUSH
51580: LD_EXP 74
51584: PUSH
51585: LD_VAR 0 1
51589: ARRAY
51590: NOT
51591: OR
51592: PUSH
51593: LD_VAR 0 2
51597: NOT
51598: OR
51599: PUSH
51600: LD_VAR 0 3
51604: NOT
51605: OR
51606: IFFALSE 51610
// exit ;
51608: GO 52123
// side := mc_sides [ base ] ;
51610: LD_ADDR_VAR 0 6
51614: PUSH
51615: LD_EXP 100
51619: PUSH
51620: LD_VAR 0 1
51624: ARRAY
51625: ST_TO_ADDR
// if not side then
51626: LD_VAR 0 6
51630: NOT
51631: IFFALSE 51635
// exit ;
51633: GO 52123
// for i in solds do
51635: LD_ADDR_VAR 0 7
51639: PUSH
51640: LD_VAR 0 2
51644: PUSH
51645: FOR_IN
51646: IFFALSE 51707
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
51648: LD_VAR 0 7
51652: PPUSH
51653: CALL_OW 310
51657: PPUSH
51658: CALL_OW 266
51662: PUSH
51663: LD_INT 32
51665: PUSH
51666: LD_INT 31
51668: PUSH
51669: EMPTY
51670: LIST
51671: LIST
51672: IN
51673: IFFALSE 51693
// solds := solds diff i else
51675: LD_ADDR_VAR 0 2
51679: PUSH
51680: LD_VAR 0 2
51684: PUSH
51685: LD_VAR 0 7
51689: DIFF
51690: ST_TO_ADDR
51691: GO 51705
// SetTag ( i , 18 ) ;
51693: LD_VAR 0 7
51697: PPUSH
51698: LD_INT 18
51700: PPUSH
51701: CALL_OW 109
51705: GO 51645
51707: POP
51708: POP
// if not solds then
51709: LD_VAR 0 2
51713: NOT
51714: IFFALSE 51718
// exit ;
51716: GO 52123
// repeat wait ( 0 0$1 ) ;
51718: LD_INT 35
51720: PPUSH
51721: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
51725: LD_ADDR_VAR 0 5
51729: PUSH
51730: LD_VAR 0 6
51734: PPUSH
51735: LD_VAR 0 3
51739: PPUSH
51740: CALL 51532 0 2
51744: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
51745: LD_EXP 74
51749: PUSH
51750: LD_VAR 0 1
51754: ARRAY
51755: NOT
51756: PUSH
51757: LD_EXP 74
51761: PUSH
51762: LD_VAR 0 1
51766: ARRAY
51767: PUSH
51768: EMPTY
51769: EQUAL
51770: OR
51771: IFFALSE 51808
// begin for i in solds do
51773: LD_ADDR_VAR 0 7
51777: PUSH
51778: LD_VAR 0 2
51782: PUSH
51783: FOR_IN
51784: IFFALSE 51797
// ComStop ( i ) ;
51786: LD_VAR 0 7
51790: PPUSH
51791: CALL_OW 141
51795: GO 51783
51797: POP
51798: POP
// solds := [ ] ;
51799: LD_ADDR_VAR 0 2
51803: PUSH
51804: EMPTY
51805: ST_TO_ADDR
// exit ;
51806: GO 52123
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
51808: LD_VAR 0 5
51812: NOT
51813: PUSH
51814: LD_VAR 0 5
51818: PUSH
51819: LD_INT 3
51821: GREATER
51822: OR
51823: PUSH
51824: LD_EXP 96
51828: PUSH
51829: LD_VAR 0 1
51833: ARRAY
51834: OR
51835: IFFALSE 51876
// begin for i in solds do
51837: LD_ADDR_VAR 0 7
51841: PUSH
51842: LD_VAR 0 2
51846: PUSH
51847: FOR_IN
51848: IFFALSE 51872
// if HasTask ( i ) then
51850: LD_VAR 0 7
51854: PPUSH
51855: CALL_OW 314
51859: IFFALSE 51870
// ComStop ( i ) ;
51861: LD_VAR 0 7
51865: PPUSH
51866: CALL_OW 141
51870: GO 51847
51872: POP
51873: POP
// break ;
51874: GO 52111
// end ; for i in solds do
51876: LD_ADDR_VAR 0 7
51880: PUSH
51881: LD_VAR 0 2
51885: PUSH
51886: FOR_IN
51887: IFFALSE 52103
// begin if IsInUnit ( i ) then
51889: LD_VAR 0 7
51893: PPUSH
51894: CALL_OW 310
51898: IFFALSE 51909
// ComExitBuilding ( i ) ;
51900: LD_VAR 0 7
51904: PPUSH
51905: CALL_OW 122
// if GetLives ( i ) > 333 then
51909: LD_VAR 0 7
51913: PPUSH
51914: CALL_OW 256
51918: PUSH
51919: LD_INT 333
51921: GREATER
51922: IFFALSE 51950
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51924: LD_VAR 0 7
51928: PPUSH
51929: LD_VAR 0 5
51933: PPUSH
51934: LD_VAR 0 7
51938: PPUSH
51939: CALL_OW 74
51943: PPUSH
51944: CALL_OW 115
51948: GO 52101
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
51950: LD_ADDR_VAR 0 8
51954: PUSH
51955: LD_EXP 74
51959: PUSH
51960: LD_VAR 0 1
51964: ARRAY
51965: PPUSH
51966: LD_INT 2
51968: PUSH
51969: LD_INT 30
51971: PUSH
51972: LD_INT 0
51974: PUSH
51975: EMPTY
51976: LIST
51977: LIST
51978: PUSH
51979: LD_INT 30
51981: PUSH
51982: LD_INT 1
51984: PUSH
51985: EMPTY
51986: LIST
51987: LIST
51988: PUSH
51989: LD_INT 30
51991: PUSH
51992: LD_INT 6
51994: PUSH
51995: EMPTY
51996: LIST
51997: LIST
51998: PUSH
51999: EMPTY
52000: LIST
52001: LIST
52002: LIST
52003: LIST
52004: PPUSH
52005: CALL_OW 72
52009: PPUSH
52010: LD_VAR 0 7
52014: PPUSH
52015: CALL_OW 74
52019: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52020: LD_VAR 0 7
52024: PPUSH
52025: LD_VAR 0 8
52029: PPUSH
52030: CALL_OW 250
52034: PPUSH
52035: LD_INT 3
52037: PPUSH
52038: LD_INT 5
52040: PPUSH
52041: CALL_OW 272
52045: PPUSH
52046: LD_VAR 0 8
52050: PPUSH
52051: CALL_OW 251
52055: PPUSH
52056: LD_INT 3
52058: PPUSH
52059: LD_INT 5
52061: PPUSH
52062: CALL_OW 273
52066: PPUSH
52067: CALL_OW 111
// SetTag ( i , 0 ) ;
52071: LD_VAR 0 7
52075: PPUSH
52076: LD_INT 0
52078: PPUSH
52079: CALL_OW 109
// solds := solds diff i ;
52083: LD_ADDR_VAR 0 2
52087: PUSH
52088: LD_VAR 0 2
52092: PUSH
52093: LD_VAR 0 7
52097: DIFF
52098: ST_TO_ADDR
// continue ;
52099: GO 51886
// end ; end ;
52101: GO 51886
52103: POP
52104: POP
// until solds ;
52105: LD_VAR 0 2
52109: IFFALSE 51718
// MC_Reset ( base , 18 ) ;
52111: LD_VAR 0 1
52115: PPUSH
52116: LD_INT 18
52118: PPUSH
52119: CALL 24190 0 2
// end ;
52123: LD_VAR 0 4
52127: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52128: LD_INT 0
52130: PPUSH
52131: PPUSH
52132: PPUSH
52133: PPUSH
52134: PPUSH
52135: PPUSH
52136: PPUSH
52137: PPUSH
52138: PPUSH
52139: PPUSH
52140: PPUSH
52141: PPUSH
52142: PPUSH
52143: PPUSH
52144: PPUSH
52145: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52146: LD_ADDR_VAR 0 12
52150: PUSH
52151: LD_EXP 74
52155: PUSH
52156: LD_VAR 0 1
52160: ARRAY
52161: PPUSH
52162: LD_INT 25
52164: PUSH
52165: LD_INT 3
52167: PUSH
52168: EMPTY
52169: LIST
52170: LIST
52171: PPUSH
52172: CALL_OW 72
52176: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52177: LD_EXP 114
52181: PUSH
52182: LD_VAR 0 1
52186: ARRAY
52187: IFFALSE 52211
// mechs := mechs diff mc_remote_driver [ base ] ;
52189: LD_ADDR_VAR 0 12
52193: PUSH
52194: LD_VAR 0 12
52198: PUSH
52199: LD_EXP 114
52203: PUSH
52204: LD_VAR 0 1
52208: ARRAY
52209: DIFF
52210: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52211: LD_ADDR_VAR 0 8
52215: PUSH
52216: LD_EXP 74
52220: PUSH
52221: LD_VAR 0 1
52225: ARRAY
52226: PPUSH
52227: LD_INT 2
52229: PUSH
52230: LD_INT 25
52232: PUSH
52233: LD_INT 1
52235: PUSH
52236: EMPTY
52237: LIST
52238: LIST
52239: PUSH
52240: LD_INT 25
52242: PUSH
52243: LD_INT 5
52245: PUSH
52246: EMPTY
52247: LIST
52248: LIST
52249: PUSH
52250: LD_INT 25
52252: PUSH
52253: LD_INT 8
52255: PUSH
52256: EMPTY
52257: LIST
52258: LIST
52259: PUSH
52260: LD_INT 25
52262: PUSH
52263: LD_INT 9
52265: PUSH
52266: EMPTY
52267: LIST
52268: LIST
52269: PUSH
52270: EMPTY
52271: LIST
52272: LIST
52273: LIST
52274: LIST
52275: LIST
52276: PPUSH
52277: CALL_OW 72
52281: ST_TO_ADDR
// if not defenders and not solds then
52282: LD_VAR 0 2
52286: NOT
52287: PUSH
52288: LD_VAR 0 8
52292: NOT
52293: AND
52294: IFFALSE 52298
// exit ;
52296: GO 53824
// depot_under_attack := false ;
52298: LD_ADDR_VAR 0 16
52302: PUSH
52303: LD_INT 0
52305: ST_TO_ADDR
// sold_defenders := [ ] ;
52306: LD_ADDR_VAR 0 17
52310: PUSH
52311: EMPTY
52312: ST_TO_ADDR
// if mechs then
52313: LD_VAR 0 12
52317: IFFALSE 52446
// for i in defenders do
52319: LD_ADDR_VAR 0 5
52323: PUSH
52324: LD_VAR 0 2
52328: PUSH
52329: FOR_IN
52330: IFFALSE 52444
// begin SetTag ( i , 20 ) ;
52332: LD_VAR 0 5
52336: PPUSH
52337: LD_INT 20
52339: PPUSH
52340: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
52344: LD_VAR 0 5
52348: PPUSH
52349: CALL_OW 263
52353: PUSH
52354: LD_INT 1
52356: EQUAL
52357: PUSH
52358: LD_VAR 0 5
52362: PPUSH
52363: CALL_OW 311
52367: NOT
52368: AND
52369: PUSH
52370: LD_VAR 0 12
52374: AND
52375: IFFALSE 52442
// begin un := mechs [ 1 ] ;
52377: LD_ADDR_VAR 0 10
52381: PUSH
52382: LD_VAR 0 12
52386: PUSH
52387: LD_INT 1
52389: ARRAY
52390: ST_TO_ADDR
// ComExitBuilding ( un ) ;
52391: LD_VAR 0 10
52395: PPUSH
52396: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
52400: LD_VAR 0 10
52404: PPUSH
52405: LD_VAR 0 5
52409: PPUSH
52410: CALL_OW 180
// SetTag ( un , 19 ) ;
52414: LD_VAR 0 10
52418: PPUSH
52419: LD_INT 19
52421: PPUSH
52422: CALL_OW 109
// mechs := mechs diff un ;
52426: LD_ADDR_VAR 0 12
52430: PUSH
52431: LD_VAR 0 12
52435: PUSH
52436: LD_VAR 0 10
52440: DIFF
52441: ST_TO_ADDR
// end ; end ;
52442: GO 52329
52444: POP
52445: POP
// if solds then
52446: LD_VAR 0 8
52450: IFFALSE 52509
// for i in solds do
52452: LD_ADDR_VAR 0 5
52456: PUSH
52457: LD_VAR 0 8
52461: PUSH
52462: FOR_IN
52463: IFFALSE 52507
// if not GetTag ( i ) then
52465: LD_VAR 0 5
52469: PPUSH
52470: CALL_OW 110
52474: NOT
52475: IFFALSE 52505
// begin defenders := defenders union i ;
52477: LD_ADDR_VAR 0 2
52481: PUSH
52482: LD_VAR 0 2
52486: PUSH
52487: LD_VAR 0 5
52491: UNION
52492: ST_TO_ADDR
// SetTag ( i , 18 ) ;
52493: LD_VAR 0 5
52497: PPUSH
52498: LD_INT 18
52500: PPUSH
52501: CALL_OW 109
// end ;
52505: GO 52462
52507: POP
52508: POP
// repeat wait ( 0 0$1 ) ;
52509: LD_INT 35
52511: PPUSH
52512: CALL_OW 67
// enemy := mc_scan [ base ] ;
52516: LD_ADDR_VAR 0 3
52520: PUSH
52521: LD_EXP 97
52525: PUSH
52526: LD_VAR 0 1
52530: ARRAY
52531: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52532: LD_EXP 74
52536: PUSH
52537: LD_VAR 0 1
52541: ARRAY
52542: NOT
52543: PUSH
52544: LD_EXP 74
52548: PUSH
52549: LD_VAR 0 1
52553: ARRAY
52554: PUSH
52555: EMPTY
52556: EQUAL
52557: OR
52558: IFFALSE 52595
// begin for i in defenders do
52560: LD_ADDR_VAR 0 5
52564: PUSH
52565: LD_VAR 0 2
52569: PUSH
52570: FOR_IN
52571: IFFALSE 52584
// ComStop ( i ) ;
52573: LD_VAR 0 5
52577: PPUSH
52578: CALL_OW 141
52582: GO 52570
52584: POP
52585: POP
// defenders := [ ] ;
52586: LD_ADDR_VAR 0 2
52590: PUSH
52591: EMPTY
52592: ST_TO_ADDR
// exit ;
52593: GO 53824
// end ; for i in defenders do
52595: LD_ADDR_VAR 0 5
52599: PUSH
52600: LD_VAR 0 2
52604: PUSH
52605: FOR_IN
52606: IFFALSE 53336
// begin e := NearestUnitToUnit ( enemy , i ) ;
52608: LD_ADDR_VAR 0 13
52612: PUSH
52613: LD_VAR 0 3
52617: PPUSH
52618: LD_VAR 0 5
52622: PPUSH
52623: CALL_OW 74
52627: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
52628: LD_ADDR_VAR 0 16
52632: PUSH
52633: LD_EXP 74
52637: PUSH
52638: LD_VAR 0 1
52642: ARRAY
52643: PPUSH
52644: LD_INT 2
52646: PUSH
52647: LD_INT 30
52649: PUSH
52650: LD_INT 0
52652: PUSH
52653: EMPTY
52654: LIST
52655: LIST
52656: PUSH
52657: LD_INT 30
52659: PUSH
52660: LD_INT 1
52662: PUSH
52663: EMPTY
52664: LIST
52665: LIST
52666: PUSH
52667: EMPTY
52668: LIST
52669: LIST
52670: LIST
52671: PPUSH
52672: CALL_OW 72
52676: NOT
52677: PUSH
52678: LD_EXP 74
52682: PUSH
52683: LD_VAR 0 1
52687: ARRAY
52688: PPUSH
52689: LD_INT 2
52691: PUSH
52692: LD_INT 30
52694: PUSH
52695: LD_INT 0
52697: PUSH
52698: EMPTY
52699: LIST
52700: LIST
52701: PUSH
52702: LD_INT 30
52704: PUSH
52705: LD_INT 1
52707: PUSH
52708: EMPTY
52709: LIST
52710: LIST
52711: PUSH
52712: EMPTY
52713: LIST
52714: LIST
52715: LIST
52716: PPUSH
52717: CALL_OW 72
52721: PPUSH
52722: CALL_OW 256
52726: PUSH
52727: LD_INT 600
52729: LESS
52730: OR
52731: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
52732: LD_VAR 0 5
52736: PPUSH
52737: CALL_OW 247
52741: PUSH
52742: LD_INT 2
52744: DOUBLE
52745: EQUAL
52746: IFTRUE 52750
52748: GO 53042
52750: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
52751: LD_VAR 0 5
52755: PPUSH
52756: CALL_OW 256
52760: PUSH
52761: LD_INT 650
52763: GREATER
52764: PUSH
52765: LD_VAR 0 5
52769: PPUSH
52770: LD_VAR 0 13
52774: PPUSH
52775: CALL_OW 296
52779: PUSH
52780: LD_INT 40
52782: LESS
52783: PUSH
52784: LD_VAR 0 13
52788: PPUSH
52789: LD_EXP 99
52793: PUSH
52794: LD_VAR 0 1
52798: ARRAY
52799: PPUSH
52800: CALL_OW 308
52804: OR
52805: AND
52806: IFFALSE 52824
// ComAttackUnit ( i , e ) else
52808: LD_VAR 0 5
52812: PPUSH
52813: LD_VAR 0 13
52817: PPUSH
52818: CALL_OW 115
52822: GO 52925
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
52824: LD_VAR 0 13
52828: PPUSH
52829: LD_EXP 99
52833: PUSH
52834: LD_VAR 0 1
52838: ARRAY
52839: PPUSH
52840: CALL_OW 308
52844: NOT
52845: PUSH
52846: LD_VAR 0 5
52850: PPUSH
52851: LD_VAR 0 13
52855: PPUSH
52856: CALL_OW 296
52860: PUSH
52861: LD_INT 40
52863: GREATEREQUAL
52864: AND
52865: PUSH
52866: LD_VAR 0 5
52870: PPUSH
52871: CALL_OW 256
52875: PUSH
52876: LD_INT 650
52878: LESSEQUAL
52879: OR
52880: PUSH
52881: LD_VAR 0 5
52885: PPUSH
52886: LD_EXP 98
52890: PUSH
52891: LD_VAR 0 1
52895: ARRAY
52896: PPUSH
52897: CALL_OW 308
52901: NOT
52902: AND
52903: IFFALSE 52925
// ComMoveToArea ( i , mc_parking [ base ] ) ;
52905: LD_VAR 0 5
52909: PPUSH
52910: LD_EXP 98
52914: PUSH
52915: LD_VAR 0 1
52919: ARRAY
52920: PPUSH
52921: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
52925: LD_VAR 0 5
52929: PPUSH
52930: CALL_OW 256
52934: PUSH
52935: LD_INT 998
52937: LESS
52938: PUSH
52939: LD_VAR 0 5
52943: PPUSH
52944: CALL_OW 263
52948: PUSH
52949: LD_INT 1
52951: EQUAL
52952: AND
52953: PUSH
52954: LD_VAR 0 5
52958: PPUSH
52959: CALL_OW 311
52963: AND
52964: PUSH
52965: LD_VAR 0 5
52969: PPUSH
52970: LD_EXP 98
52974: PUSH
52975: LD_VAR 0 1
52979: ARRAY
52980: PPUSH
52981: CALL_OW 308
52985: AND
52986: IFFALSE 53040
// begin mech := IsDrivenBy ( i ) ;
52988: LD_ADDR_VAR 0 9
52992: PUSH
52993: LD_VAR 0 5
52997: PPUSH
52998: CALL_OW 311
53002: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53003: LD_VAR 0 9
53007: PPUSH
53008: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53012: LD_VAR 0 9
53016: PPUSH
53017: LD_VAR 0 5
53021: PPUSH
53022: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53026: LD_VAR 0 9
53030: PPUSH
53031: LD_VAR 0 5
53035: PPUSH
53036: CALL_OW 180
// end ; end ; unit_human :
53040: GO 53307
53042: LD_INT 1
53044: DOUBLE
53045: EQUAL
53046: IFTRUE 53050
53048: GO 53306
53050: POP
// begin b := IsInUnit ( i ) ;
53051: LD_ADDR_VAR 0 18
53055: PUSH
53056: LD_VAR 0 5
53060: PPUSH
53061: CALL_OW 310
53065: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53066: LD_ADDR_VAR 0 19
53070: PUSH
53071: LD_VAR 0 18
53075: NOT
53076: PUSH
53077: LD_VAR 0 18
53081: PPUSH
53082: CALL_OW 266
53086: PUSH
53087: LD_INT 32
53089: PUSH
53090: LD_INT 31
53092: PUSH
53093: EMPTY
53094: LIST
53095: LIST
53096: IN
53097: OR
53098: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53099: LD_VAR 0 16
53103: PUSH
53104: LD_VAR 0 2
53108: PPUSH
53109: LD_INT 21
53111: PUSH
53112: LD_INT 2
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: PPUSH
53119: CALL_OW 72
53123: PUSH
53124: LD_INT 1
53126: LESSEQUAL
53127: OR
53128: PUSH
53129: LD_VAR 0 19
53133: AND
53134: PUSH
53135: LD_VAR 0 5
53139: PUSH
53140: LD_VAR 0 17
53144: IN
53145: NOT
53146: AND
53147: IFFALSE 53240
// begin if b then
53149: LD_VAR 0 18
53153: IFFALSE 53202
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53155: LD_VAR 0 18
53159: PPUSH
53160: LD_VAR 0 3
53164: PPUSH
53165: LD_VAR 0 18
53169: PPUSH
53170: CALL_OW 74
53174: PPUSH
53175: CALL_OW 296
53179: PUSH
53180: LD_INT 10
53182: LESS
53183: PUSH
53184: LD_VAR 0 18
53188: PPUSH
53189: CALL_OW 461
53193: PUSH
53194: LD_INT 7
53196: NONEQUAL
53197: AND
53198: IFFALSE 53202
// continue ;
53200: GO 52605
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53202: LD_ADDR_VAR 0 17
53206: PUSH
53207: LD_VAR 0 17
53211: PPUSH
53212: LD_VAR 0 17
53216: PUSH
53217: LD_INT 1
53219: PLUS
53220: PPUSH
53221: LD_VAR 0 5
53225: PPUSH
53226: CALL_OW 1
53230: ST_TO_ADDR
// ComExitBuilding ( i ) ;
53231: LD_VAR 0 5
53235: PPUSH
53236: CALL_OW 122
// end ; if sold_defenders then
53240: LD_VAR 0 17
53244: IFFALSE 53304
// if i in sold_defenders then
53246: LD_VAR 0 5
53250: PUSH
53251: LD_VAR 0 17
53255: IN
53256: IFFALSE 53304
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
53258: LD_VAR 0 5
53262: PPUSH
53263: CALL_OW 314
53267: NOT
53268: PUSH
53269: LD_VAR 0 5
53273: PPUSH
53274: LD_VAR 0 13
53278: PPUSH
53279: CALL_OW 296
53283: PUSH
53284: LD_INT 30
53286: LESS
53287: AND
53288: IFFALSE 53304
// ComAttackUnit ( i , e ) ;
53290: LD_VAR 0 5
53294: PPUSH
53295: LD_VAR 0 13
53299: PPUSH
53300: CALL_OW 115
// end ; end ; end ;
53304: GO 53307
53306: POP
// if IsDead ( i ) then
53307: LD_VAR 0 5
53311: PPUSH
53312: CALL_OW 301
53316: IFFALSE 53334
// defenders := defenders diff i ;
53318: LD_ADDR_VAR 0 2
53322: PUSH
53323: LD_VAR 0 2
53327: PUSH
53328: LD_VAR 0 5
53332: DIFF
53333: ST_TO_ADDR
// end ;
53334: GO 52605
53336: POP
53337: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
53338: LD_VAR 0 3
53342: NOT
53343: PUSH
53344: LD_VAR 0 2
53348: NOT
53349: OR
53350: PUSH
53351: LD_EXP 74
53355: PUSH
53356: LD_VAR 0 1
53360: ARRAY
53361: NOT
53362: OR
53363: IFFALSE 52509
// MC_Reset ( base , 18 ) ;
53365: LD_VAR 0 1
53369: PPUSH
53370: LD_INT 18
53372: PPUSH
53373: CALL 24190 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53377: LD_ADDR_VAR 0 2
53381: PUSH
53382: LD_VAR 0 2
53386: PUSH
53387: LD_VAR 0 2
53391: PPUSH
53392: LD_INT 2
53394: PUSH
53395: LD_INT 25
53397: PUSH
53398: LD_INT 1
53400: PUSH
53401: EMPTY
53402: LIST
53403: LIST
53404: PUSH
53405: LD_INT 25
53407: PUSH
53408: LD_INT 5
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: PUSH
53415: LD_INT 25
53417: PUSH
53418: LD_INT 8
53420: PUSH
53421: EMPTY
53422: LIST
53423: LIST
53424: PUSH
53425: LD_INT 25
53427: PUSH
53428: LD_INT 9
53430: PUSH
53431: EMPTY
53432: LIST
53433: LIST
53434: PUSH
53435: EMPTY
53436: LIST
53437: LIST
53438: LIST
53439: LIST
53440: LIST
53441: PPUSH
53442: CALL_OW 72
53446: DIFF
53447: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
53448: LD_VAR 0 3
53452: NOT
53453: PUSH
53454: LD_VAR 0 2
53458: PPUSH
53459: LD_INT 21
53461: PUSH
53462: LD_INT 2
53464: PUSH
53465: EMPTY
53466: LIST
53467: LIST
53468: PPUSH
53469: CALL_OW 72
53473: AND
53474: IFFALSE 53812
// begin tmp := FilterByTag ( defenders , 19 ) ;
53476: LD_ADDR_VAR 0 11
53480: PUSH
53481: LD_VAR 0 2
53485: PPUSH
53486: LD_INT 19
53488: PPUSH
53489: CALL 90253 0 2
53493: ST_TO_ADDR
// if tmp then
53494: LD_VAR 0 11
53498: IFFALSE 53568
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
53500: LD_ADDR_VAR 0 11
53504: PUSH
53505: LD_VAR 0 11
53509: PPUSH
53510: LD_INT 25
53512: PUSH
53513: LD_INT 3
53515: PUSH
53516: EMPTY
53517: LIST
53518: LIST
53519: PPUSH
53520: CALL_OW 72
53524: ST_TO_ADDR
// if tmp then
53525: LD_VAR 0 11
53529: IFFALSE 53568
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
53531: LD_ADDR_EXP 86
53535: PUSH
53536: LD_EXP 86
53540: PPUSH
53541: LD_VAR 0 1
53545: PPUSH
53546: LD_EXP 86
53550: PUSH
53551: LD_VAR 0 1
53555: ARRAY
53556: PUSH
53557: LD_VAR 0 11
53561: UNION
53562: PPUSH
53563: CALL_OW 1
53567: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
53568: LD_VAR 0 1
53572: PPUSH
53573: LD_INT 19
53575: PPUSH
53576: CALL 24190 0 2
// repeat wait ( 0 0$1 ) ;
53580: LD_INT 35
53582: PPUSH
53583: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53587: LD_EXP 74
53591: PUSH
53592: LD_VAR 0 1
53596: ARRAY
53597: NOT
53598: PUSH
53599: LD_EXP 74
53603: PUSH
53604: LD_VAR 0 1
53608: ARRAY
53609: PUSH
53610: EMPTY
53611: EQUAL
53612: OR
53613: IFFALSE 53650
// begin for i in defenders do
53615: LD_ADDR_VAR 0 5
53619: PUSH
53620: LD_VAR 0 2
53624: PUSH
53625: FOR_IN
53626: IFFALSE 53639
// ComStop ( i ) ;
53628: LD_VAR 0 5
53632: PPUSH
53633: CALL_OW 141
53637: GO 53625
53639: POP
53640: POP
// defenders := [ ] ;
53641: LD_ADDR_VAR 0 2
53645: PUSH
53646: EMPTY
53647: ST_TO_ADDR
// exit ;
53648: GO 53824
// end ; for i in defenders do
53650: LD_ADDR_VAR 0 5
53654: PUSH
53655: LD_VAR 0 2
53659: PUSH
53660: FOR_IN
53661: IFFALSE 53750
// begin if not IsInArea ( i , mc_parking [ base ] ) then
53663: LD_VAR 0 5
53667: PPUSH
53668: LD_EXP 98
53672: PUSH
53673: LD_VAR 0 1
53677: ARRAY
53678: PPUSH
53679: CALL_OW 308
53683: NOT
53684: IFFALSE 53708
// ComMoveToArea ( i , mc_parking [ base ] ) else
53686: LD_VAR 0 5
53690: PPUSH
53691: LD_EXP 98
53695: PUSH
53696: LD_VAR 0 1
53700: ARRAY
53701: PPUSH
53702: CALL_OW 113
53706: GO 53748
// if GetControl ( i ) = control_manual then
53708: LD_VAR 0 5
53712: PPUSH
53713: CALL_OW 263
53717: PUSH
53718: LD_INT 1
53720: EQUAL
53721: IFFALSE 53748
// if IsDrivenBy ( i ) then
53723: LD_VAR 0 5
53727: PPUSH
53728: CALL_OW 311
53732: IFFALSE 53748
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
53734: LD_VAR 0 5
53738: PPUSH
53739: CALL_OW 311
53743: PPUSH
53744: CALL_OW 121
// end ;
53748: GO 53660
53750: POP
53751: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
53752: LD_VAR 0 2
53756: PPUSH
53757: LD_INT 95
53759: PUSH
53760: LD_EXP 98
53764: PUSH
53765: LD_VAR 0 1
53769: ARRAY
53770: PUSH
53771: EMPTY
53772: LIST
53773: LIST
53774: PPUSH
53775: CALL_OW 72
53779: PUSH
53780: LD_VAR 0 2
53784: EQUAL
53785: PUSH
53786: LD_EXP 97
53790: PUSH
53791: LD_VAR 0 1
53795: ARRAY
53796: OR
53797: PUSH
53798: LD_EXP 74
53802: PUSH
53803: LD_VAR 0 1
53807: ARRAY
53808: NOT
53809: OR
53810: IFFALSE 53580
// end ; MC_Reset ( base , 20 ) ;
53812: LD_VAR 0 1
53816: PPUSH
53817: LD_INT 20
53819: PPUSH
53820: CALL 24190 0 2
// end ;
53824: LD_VAR 0 4
53828: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53829: LD_INT 0
53831: PPUSH
53832: PPUSH
53833: PPUSH
53834: PPUSH
// result := false ;
53835: LD_ADDR_VAR 0 2
53839: PUSH
53840: LD_INT 0
53842: ST_TO_ADDR
// side := GetSide ( unit ) ;
53843: LD_ADDR_VAR 0 3
53847: PUSH
53848: LD_VAR 0 1
53852: PPUSH
53853: CALL_OW 255
53857: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53858: LD_ADDR_VAR 0 4
53862: PUSH
53863: LD_VAR 0 1
53867: PPUSH
53868: CALL_OW 248
53872: ST_TO_ADDR
// case nat of 1 :
53873: LD_VAR 0 4
53877: PUSH
53878: LD_INT 1
53880: DOUBLE
53881: EQUAL
53882: IFTRUE 53886
53884: GO 53897
53886: POP
// tech := tech_lassight ; 2 :
53887: LD_ADDR_VAR 0 5
53891: PUSH
53892: LD_INT 12
53894: ST_TO_ADDR
53895: GO 53936
53897: LD_INT 2
53899: DOUBLE
53900: EQUAL
53901: IFTRUE 53905
53903: GO 53916
53905: POP
// tech := tech_mortar ; 3 :
53906: LD_ADDR_VAR 0 5
53910: PUSH
53911: LD_INT 41
53913: ST_TO_ADDR
53914: GO 53936
53916: LD_INT 3
53918: DOUBLE
53919: EQUAL
53920: IFTRUE 53924
53922: GO 53935
53924: POP
// tech := tech_bazooka ; end ;
53925: LD_ADDR_VAR 0 5
53929: PUSH
53930: LD_INT 44
53932: ST_TO_ADDR
53933: GO 53936
53935: POP
// if Researched ( side , tech ) then
53936: LD_VAR 0 3
53940: PPUSH
53941: LD_VAR 0 5
53945: PPUSH
53946: CALL_OW 325
53950: IFFALSE 53977
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53952: LD_ADDR_VAR 0 2
53956: PUSH
53957: LD_INT 5
53959: PUSH
53960: LD_INT 8
53962: PUSH
53963: LD_INT 9
53965: PUSH
53966: EMPTY
53967: LIST
53968: LIST
53969: LIST
53970: PUSH
53971: LD_VAR 0 4
53975: ARRAY
53976: ST_TO_ADDR
// end ;
53977: LD_VAR 0 2
53981: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53982: LD_INT 0
53984: PPUSH
53985: PPUSH
53986: PPUSH
// if not mines then
53987: LD_VAR 0 2
53991: NOT
53992: IFFALSE 53996
// exit ;
53994: GO 54140
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53996: LD_ADDR_VAR 0 5
54000: PUSH
54001: LD_INT 81
54003: PUSH
54004: LD_VAR 0 1
54008: PUSH
54009: EMPTY
54010: LIST
54011: LIST
54012: PUSH
54013: LD_INT 3
54015: PUSH
54016: LD_INT 21
54018: PUSH
54019: LD_INT 3
54021: PUSH
54022: EMPTY
54023: LIST
54024: LIST
54025: PUSH
54026: EMPTY
54027: LIST
54028: LIST
54029: PUSH
54030: EMPTY
54031: LIST
54032: LIST
54033: PPUSH
54034: CALL_OW 69
54038: ST_TO_ADDR
// for i in mines do
54039: LD_ADDR_VAR 0 4
54043: PUSH
54044: LD_VAR 0 2
54048: PUSH
54049: FOR_IN
54050: IFFALSE 54138
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54052: LD_VAR 0 4
54056: PUSH
54057: LD_INT 1
54059: ARRAY
54060: PPUSH
54061: LD_VAR 0 4
54065: PUSH
54066: LD_INT 2
54068: ARRAY
54069: PPUSH
54070: CALL_OW 458
54074: NOT
54075: IFFALSE 54079
// continue ;
54077: GO 54049
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54079: LD_VAR 0 4
54083: PUSH
54084: LD_INT 1
54086: ARRAY
54087: PPUSH
54088: LD_VAR 0 4
54092: PUSH
54093: LD_INT 2
54095: ARRAY
54096: PPUSH
54097: CALL_OW 428
54101: PUSH
54102: LD_VAR 0 5
54106: IN
54107: IFFALSE 54136
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54109: LD_VAR 0 4
54113: PUSH
54114: LD_INT 1
54116: ARRAY
54117: PPUSH
54118: LD_VAR 0 4
54122: PUSH
54123: LD_INT 2
54125: ARRAY
54126: PPUSH
54127: LD_VAR 0 1
54131: PPUSH
54132: CALL_OW 456
// end ;
54136: GO 54049
54138: POP
54139: POP
// end ;
54140: LD_VAR 0 3
54144: RET
// export function Count ( array ) ; var i ; begin
54145: LD_INT 0
54147: PPUSH
54148: PPUSH
// result := 0 ;
54149: LD_ADDR_VAR 0 2
54153: PUSH
54154: LD_INT 0
54156: ST_TO_ADDR
// for i in array do
54157: LD_ADDR_VAR 0 3
54161: PUSH
54162: LD_VAR 0 1
54166: PUSH
54167: FOR_IN
54168: IFFALSE 54192
// if i then
54170: LD_VAR 0 3
54174: IFFALSE 54190
// result := result + 1 ;
54176: LD_ADDR_VAR 0 2
54180: PUSH
54181: LD_VAR 0 2
54185: PUSH
54186: LD_INT 1
54188: PLUS
54189: ST_TO_ADDR
54190: GO 54167
54192: POP
54193: POP
// end ;
54194: LD_VAR 0 2
54198: RET
// export function IsEmpty ( building ) ; begin
54199: LD_INT 0
54201: PPUSH
// if not building then
54202: LD_VAR 0 1
54206: NOT
54207: IFFALSE 54211
// exit ;
54209: GO 54254
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54211: LD_ADDR_VAR 0 2
54215: PUSH
54216: LD_VAR 0 1
54220: PUSH
54221: LD_INT 22
54223: PUSH
54224: LD_VAR 0 1
54228: PPUSH
54229: CALL_OW 255
54233: PUSH
54234: EMPTY
54235: LIST
54236: LIST
54237: PUSH
54238: LD_INT 58
54240: PUSH
54241: EMPTY
54242: LIST
54243: PUSH
54244: EMPTY
54245: LIST
54246: LIST
54247: PPUSH
54248: CALL_OW 69
54252: IN
54253: ST_TO_ADDR
// end ;
54254: LD_VAR 0 2
54258: RET
// export function IsNotFull ( building ) ; begin
54259: LD_INT 0
54261: PPUSH
// if not building then
54262: LD_VAR 0 1
54266: NOT
54267: IFFALSE 54271
// exit ;
54269: GO 54290
// result := UnitsInside ( building ) < 6 ;
54271: LD_ADDR_VAR 0 2
54275: PUSH
54276: LD_VAR 0 1
54280: PPUSH
54281: CALL_OW 313
54285: PUSH
54286: LD_INT 6
54288: LESS
54289: ST_TO_ADDR
// end ;
54290: LD_VAR 0 2
54294: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54295: LD_INT 0
54297: PPUSH
54298: PPUSH
54299: PPUSH
54300: PPUSH
// tmp := [ ] ;
54301: LD_ADDR_VAR 0 3
54305: PUSH
54306: EMPTY
54307: ST_TO_ADDR
// list := [ ] ;
54308: LD_ADDR_VAR 0 5
54312: PUSH
54313: EMPTY
54314: ST_TO_ADDR
// for i = 16 to 25 do
54315: LD_ADDR_VAR 0 4
54319: PUSH
54320: DOUBLE
54321: LD_INT 16
54323: DEC
54324: ST_TO_ADDR
54325: LD_INT 25
54327: PUSH
54328: FOR_TO
54329: IFFALSE 54402
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54331: LD_ADDR_VAR 0 3
54335: PUSH
54336: LD_VAR 0 3
54340: PUSH
54341: LD_INT 22
54343: PUSH
54344: LD_VAR 0 1
54348: PPUSH
54349: CALL_OW 255
54353: PUSH
54354: EMPTY
54355: LIST
54356: LIST
54357: PUSH
54358: LD_INT 91
54360: PUSH
54361: LD_VAR 0 1
54365: PUSH
54366: LD_INT 6
54368: PUSH
54369: EMPTY
54370: LIST
54371: LIST
54372: LIST
54373: PUSH
54374: LD_INT 30
54376: PUSH
54377: LD_VAR 0 4
54381: PUSH
54382: EMPTY
54383: LIST
54384: LIST
54385: PUSH
54386: EMPTY
54387: LIST
54388: LIST
54389: LIST
54390: PUSH
54391: EMPTY
54392: LIST
54393: PPUSH
54394: CALL_OW 69
54398: ADD
54399: ST_TO_ADDR
54400: GO 54328
54402: POP
54403: POP
// for i = 1 to tmp do
54404: LD_ADDR_VAR 0 4
54408: PUSH
54409: DOUBLE
54410: LD_INT 1
54412: DEC
54413: ST_TO_ADDR
54414: LD_VAR 0 3
54418: PUSH
54419: FOR_TO
54420: IFFALSE 54508
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54422: LD_ADDR_VAR 0 5
54426: PUSH
54427: LD_VAR 0 5
54431: PUSH
54432: LD_VAR 0 3
54436: PUSH
54437: LD_VAR 0 4
54441: ARRAY
54442: PPUSH
54443: CALL_OW 266
54447: PUSH
54448: LD_VAR 0 3
54452: PUSH
54453: LD_VAR 0 4
54457: ARRAY
54458: PPUSH
54459: CALL_OW 250
54463: PUSH
54464: LD_VAR 0 3
54468: PUSH
54469: LD_VAR 0 4
54473: ARRAY
54474: PPUSH
54475: CALL_OW 251
54479: PUSH
54480: LD_VAR 0 3
54484: PUSH
54485: LD_VAR 0 4
54489: ARRAY
54490: PPUSH
54491: CALL_OW 254
54495: PUSH
54496: EMPTY
54497: LIST
54498: LIST
54499: LIST
54500: LIST
54501: PUSH
54502: EMPTY
54503: LIST
54504: ADD
54505: ST_TO_ADDR
54506: GO 54419
54508: POP
54509: POP
// result := list ;
54510: LD_ADDR_VAR 0 2
54514: PUSH
54515: LD_VAR 0 5
54519: ST_TO_ADDR
// end ;
54520: LD_VAR 0 2
54524: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54525: LD_INT 0
54527: PPUSH
54528: PPUSH
54529: PPUSH
54530: PPUSH
54531: PPUSH
54532: PPUSH
54533: PPUSH
// if not factory then
54534: LD_VAR 0 1
54538: NOT
54539: IFFALSE 54543
// exit ;
54541: GO 55136
// if control = control_apeman then
54543: LD_VAR 0 4
54547: PUSH
54548: LD_INT 5
54550: EQUAL
54551: IFFALSE 54660
// begin tmp := UnitsInside ( factory ) ;
54553: LD_ADDR_VAR 0 8
54557: PUSH
54558: LD_VAR 0 1
54562: PPUSH
54563: CALL_OW 313
54567: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54568: LD_VAR 0 8
54572: PPUSH
54573: LD_INT 25
54575: PUSH
54576: LD_INT 12
54578: PUSH
54579: EMPTY
54580: LIST
54581: LIST
54582: PPUSH
54583: CALL_OW 72
54587: NOT
54588: IFFALSE 54598
// control := control_manual ;
54590: LD_ADDR_VAR 0 4
54594: PUSH
54595: LD_INT 1
54597: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54598: LD_ADDR_VAR 0 8
54602: PUSH
54603: LD_VAR 0 1
54607: PPUSH
54608: CALL 54295 0 1
54612: ST_TO_ADDR
// if tmp then
54613: LD_VAR 0 8
54617: IFFALSE 54660
// begin for i in tmp do
54619: LD_ADDR_VAR 0 7
54623: PUSH
54624: LD_VAR 0 8
54628: PUSH
54629: FOR_IN
54630: IFFALSE 54658
// if i [ 1 ] = b_ext_radio then
54632: LD_VAR 0 7
54636: PUSH
54637: LD_INT 1
54639: ARRAY
54640: PUSH
54641: LD_INT 22
54643: EQUAL
54644: IFFALSE 54656
// begin control := control_remote ;
54646: LD_ADDR_VAR 0 4
54650: PUSH
54651: LD_INT 2
54653: ST_TO_ADDR
// break ;
54654: GO 54658
// end ;
54656: GO 54629
54658: POP
54659: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54660: LD_VAR 0 1
54664: PPUSH
54665: LD_VAR 0 2
54669: PPUSH
54670: LD_VAR 0 3
54674: PPUSH
54675: LD_VAR 0 4
54679: PPUSH
54680: LD_VAR 0 5
54684: PPUSH
54685: CALL_OW 448
54689: IFFALSE 54724
// begin result := [ chassis , engine , control , weapon ] ;
54691: LD_ADDR_VAR 0 6
54695: PUSH
54696: LD_VAR 0 2
54700: PUSH
54701: LD_VAR 0 3
54705: PUSH
54706: LD_VAR 0 4
54710: PUSH
54711: LD_VAR 0 5
54715: PUSH
54716: EMPTY
54717: LIST
54718: LIST
54719: LIST
54720: LIST
54721: ST_TO_ADDR
// exit ;
54722: GO 55136
// end ; _chassis := AvailableChassisList ( factory ) ;
54724: LD_ADDR_VAR 0 9
54728: PUSH
54729: LD_VAR 0 1
54733: PPUSH
54734: CALL_OW 475
54738: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54739: LD_ADDR_VAR 0 11
54743: PUSH
54744: LD_VAR 0 1
54748: PPUSH
54749: CALL_OW 476
54753: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54754: LD_ADDR_VAR 0 12
54758: PUSH
54759: LD_VAR 0 1
54763: PPUSH
54764: CALL_OW 477
54768: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54769: LD_ADDR_VAR 0 10
54773: PUSH
54774: LD_VAR 0 1
54778: PPUSH
54779: CALL_OW 478
54783: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54784: LD_VAR 0 9
54788: NOT
54789: PUSH
54790: LD_VAR 0 11
54794: NOT
54795: OR
54796: PUSH
54797: LD_VAR 0 12
54801: NOT
54802: OR
54803: PUSH
54804: LD_VAR 0 10
54808: NOT
54809: OR
54810: IFFALSE 54845
// begin result := [ chassis , engine , control , weapon ] ;
54812: LD_ADDR_VAR 0 6
54816: PUSH
54817: LD_VAR 0 2
54821: PUSH
54822: LD_VAR 0 3
54826: PUSH
54827: LD_VAR 0 4
54831: PUSH
54832: LD_VAR 0 5
54836: PUSH
54837: EMPTY
54838: LIST
54839: LIST
54840: LIST
54841: LIST
54842: ST_TO_ADDR
// exit ;
54843: GO 55136
// end ; if not chassis in _chassis then
54845: LD_VAR 0 2
54849: PUSH
54850: LD_VAR 0 9
54854: IN
54855: NOT
54856: IFFALSE 54882
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54858: LD_ADDR_VAR 0 2
54862: PUSH
54863: LD_VAR 0 9
54867: PUSH
54868: LD_INT 1
54870: PPUSH
54871: LD_VAR 0 9
54875: PPUSH
54876: CALL_OW 12
54880: ARRAY
54881: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54882: LD_VAR 0 2
54886: PPUSH
54887: LD_VAR 0 3
54891: PPUSH
54892: CALL 55141 0 2
54896: NOT
54897: IFFALSE 54956
// repeat engine := _engine [ 1 ] ;
54899: LD_ADDR_VAR 0 3
54903: PUSH
54904: LD_VAR 0 11
54908: PUSH
54909: LD_INT 1
54911: ARRAY
54912: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54913: LD_ADDR_VAR 0 11
54917: PUSH
54918: LD_VAR 0 11
54922: PPUSH
54923: LD_INT 1
54925: PPUSH
54926: CALL_OW 3
54930: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54931: LD_VAR 0 2
54935: PPUSH
54936: LD_VAR 0 3
54940: PPUSH
54941: CALL 55141 0 2
54945: PUSH
54946: LD_VAR 0 11
54950: PUSH
54951: EMPTY
54952: EQUAL
54953: OR
54954: IFFALSE 54899
// if not control in _control then
54956: LD_VAR 0 4
54960: PUSH
54961: LD_VAR 0 12
54965: IN
54966: NOT
54967: IFFALSE 54993
// control := _control [ rand ( 1 , _control ) ] ;
54969: LD_ADDR_VAR 0 4
54973: PUSH
54974: LD_VAR 0 12
54978: PUSH
54979: LD_INT 1
54981: PPUSH
54982: LD_VAR 0 12
54986: PPUSH
54987: CALL_OW 12
54991: ARRAY
54992: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54993: LD_VAR 0 2
54997: PPUSH
54998: LD_VAR 0 5
55002: PPUSH
55003: CALL 55361 0 2
55007: NOT
55008: IFFALSE 55067
// repeat weapon := _weapon [ 1 ] ;
55010: LD_ADDR_VAR 0 5
55014: PUSH
55015: LD_VAR 0 10
55019: PUSH
55020: LD_INT 1
55022: ARRAY
55023: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55024: LD_ADDR_VAR 0 10
55028: PUSH
55029: LD_VAR 0 10
55033: PPUSH
55034: LD_INT 1
55036: PPUSH
55037: CALL_OW 3
55041: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55042: LD_VAR 0 2
55046: PPUSH
55047: LD_VAR 0 5
55051: PPUSH
55052: CALL 55361 0 2
55056: PUSH
55057: LD_VAR 0 10
55061: PUSH
55062: EMPTY
55063: EQUAL
55064: OR
55065: IFFALSE 55010
// result := [ ] ;
55067: LD_ADDR_VAR 0 6
55071: PUSH
55072: EMPTY
55073: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55074: LD_VAR 0 1
55078: PPUSH
55079: LD_VAR 0 2
55083: PPUSH
55084: LD_VAR 0 3
55088: PPUSH
55089: LD_VAR 0 4
55093: PPUSH
55094: LD_VAR 0 5
55098: PPUSH
55099: CALL_OW 448
55103: IFFALSE 55136
// result := [ chassis , engine , control , weapon ] ;
55105: LD_ADDR_VAR 0 6
55109: PUSH
55110: LD_VAR 0 2
55114: PUSH
55115: LD_VAR 0 3
55119: PUSH
55120: LD_VAR 0 4
55124: PUSH
55125: LD_VAR 0 5
55129: PUSH
55130: EMPTY
55131: LIST
55132: LIST
55133: LIST
55134: LIST
55135: ST_TO_ADDR
// end ;
55136: LD_VAR 0 6
55140: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55141: LD_INT 0
55143: PPUSH
// if not chassis or not engine then
55144: LD_VAR 0 1
55148: NOT
55149: PUSH
55150: LD_VAR 0 2
55154: NOT
55155: OR
55156: IFFALSE 55160
// exit ;
55158: GO 55356
// case engine of engine_solar :
55160: LD_VAR 0 2
55164: PUSH
55165: LD_INT 2
55167: DOUBLE
55168: EQUAL
55169: IFTRUE 55173
55171: GO 55211
55173: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55174: LD_ADDR_VAR 0 3
55178: PUSH
55179: LD_INT 11
55181: PUSH
55182: LD_INT 12
55184: PUSH
55185: LD_INT 13
55187: PUSH
55188: LD_INT 14
55190: PUSH
55191: LD_INT 1
55193: PUSH
55194: LD_INT 2
55196: PUSH
55197: LD_INT 3
55199: PUSH
55200: EMPTY
55201: LIST
55202: LIST
55203: LIST
55204: LIST
55205: LIST
55206: LIST
55207: LIST
55208: ST_TO_ADDR
55209: GO 55340
55211: LD_INT 1
55213: DOUBLE
55214: EQUAL
55215: IFTRUE 55219
55217: GO 55281
55219: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55220: LD_ADDR_VAR 0 3
55224: PUSH
55225: LD_INT 11
55227: PUSH
55228: LD_INT 12
55230: PUSH
55231: LD_INT 13
55233: PUSH
55234: LD_INT 14
55236: PUSH
55237: LD_INT 1
55239: PUSH
55240: LD_INT 2
55242: PUSH
55243: LD_INT 3
55245: PUSH
55246: LD_INT 4
55248: PUSH
55249: LD_INT 5
55251: PUSH
55252: LD_INT 21
55254: PUSH
55255: LD_INT 23
55257: PUSH
55258: LD_INT 22
55260: PUSH
55261: LD_INT 24
55263: PUSH
55264: EMPTY
55265: LIST
55266: LIST
55267: LIST
55268: LIST
55269: LIST
55270: LIST
55271: LIST
55272: LIST
55273: LIST
55274: LIST
55275: LIST
55276: LIST
55277: LIST
55278: ST_TO_ADDR
55279: GO 55340
55281: LD_INT 3
55283: DOUBLE
55284: EQUAL
55285: IFTRUE 55289
55287: GO 55339
55289: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55290: LD_ADDR_VAR 0 3
55294: PUSH
55295: LD_INT 13
55297: PUSH
55298: LD_INT 14
55300: PUSH
55301: LD_INT 2
55303: PUSH
55304: LD_INT 3
55306: PUSH
55307: LD_INT 4
55309: PUSH
55310: LD_INT 5
55312: PUSH
55313: LD_INT 21
55315: PUSH
55316: LD_INT 22
55318: PUSH
55319: LD_INT 23
55321: PUSH
55322: LD_INT 24
55324: PUSH
55325: EMPTY
55326: LIST
55327: LIST
55328: LIST
55329: LIST
55330: LIST
55331: LIST
55332: LIST
55333: LIST
55334: LIST
55335: LIST
55336: ST_TO_ADDR
55337: GO 55340
55339: POP
// result := ( chassis in result ) ;
55340: LD_ADDR_VAR 0 3
55344: PUSH
55345: LD_VAR 0 1
55349: PUSH
55350: LD_VAR 0 3
55354: IN
55355: ST_TO_ADDR
// end ;
55356: LD_VAR 0 3
55360: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55361: LD_INT 0
55363: PPUSH
// if not chassis or not weapon then
55364: LD_VAR 0 1
55368: NOT
55369: PUSH
55370: LD_VAR 0 2
55374: NOT
55375: OR
55376: IFFALSE 55380
// exit ;
55378: GO 56406
// case weapon of us_machine_gun :
55380: LD_VAR 0 2
55384: PUSH
55385: LD_INT 2
55387: DOUBLE
55388: EQUAL
55389: IFTRUE 55393
55391: GO 55423
55393: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55394: LD_ADDR_VAR 0 3
55398: PUSH
55399: LD_INT 1
55401: PUSH
55402: LD_INT 2
55404: PUSH
55405: LD_INT 3
55407: PUSH
55408: LD_INT 4
55410: PUSH
55411: LD_INT 5
55413: PUSH
55414: EMPTY
55415: LIST
55416: LIST
55417: LIST
55418: LIST
55419: LIST
55420: ST_TO_ADDR
55421: GO 56390
55423: LD_INT 3
55425: DOUBLE
55426: EQUAL
55427: IFTRUE 55431
55429: GO 55461
55431: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55432: LD_ADDR_VAR 0 3
55436: PUSH
55437: LD_INT 1
55439: PUSH
55440: LD_INT 2
55442: PUSH
55443: LD_INT 3
55445: PUSH
55446: LD_INT 4
55448: PUSH
55449: LD_INT 5
55451: PUSH
55452: EMPTY
55453: LIST
55454: LIST
55455: LIST
55456: LIST
55457: LIST
55458: ST_TO_ADDR
55459: GO 56390
55461: LD_INT 11
55463: DOUBLE
55464: EQUAL
55465: IFTRUE 55469
55467: GO 55499
55469: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55470: LD_ADDR_VAR 0 3
55474: PUSH
55475: LD_INT 1
55477: PUSH
55478: LD_INT 2
55480: PUSH
55481: LD_INT 3
55483: PUSH
55484: LD_INT 4
55486: PUSH
55487: LD_INT 5
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: LIST
55494: LIST
55495: LIST
55496: ST_TO_ADDR
55497: GO 56390
55499: LD_INT 4
55501: DOUBLE
55502: EQUAL
55503: IFTRUE 55507
55505: GO 55533
55507: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55508: LD_ADDR_VAR 0 3
55512: PUSH
55513: LD_INT 2
55515: PUSH
55516: LD_INT 3
55518: PUSH
55519: LD_INT 4
55521: PUSH
55522: LD_INT 5
55524: PUSH
55525: EMPTY
55526: LIST
55527: LIST
55528: LIST
55529: LIST
55530: ST_TO_ADDR
55531: GO 56390
55533: LD_INT 5
55535: DOUBLE
55536: EQUAL
55537: IFTRUE 55541
55539: GO 55567
55541: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55542: LD_ADDR_VAR 0 3
55546: PUSH
55547: LD_INT 2
55549: PUSH
55550: LD_INT 3
55552: PUSH
55553: LD_INT 4
55555: PUSH
55556: LD_INT 5
55558: PUSH
55559: EMPTY
55560: LIST
55561: LIST
55562: LIST
55563: LIST
55564: ST_TO_ADDR
55565: GO 56390
55567: LD_INT 9
55569: DOUBLE
55570: EQUAL
55571: IFTRUE 55575
55573: GO 55601
55575: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55576: LD_ADDR_VAR 0 3
55580: PUSH
55581: LD_INT 2
55583: PUSH
55584: LD_INT 3
55586: PUSH
55587: LD_INT 4
55589: PUSH
55590: LD_INT 5
55592: PUSH
55593: EMPTY
55594: LIST
55595: LIST
55596: LIST
55597: LIST
55598: ST_TO_ADDR
55599: GO 56390
55601: LD_INT 7
55603: DOUBLE
55604: EQUAL
55605: IFTRUE 55609
55607: GO 55635
55609: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55610: LD_ADDR_VAR 0 3
55614: PUSH
55615: LD_INT 2
55617: PUSH
55618: LD_INT 3
55620: PUSH
55621: LD_INT 4
55623: PUSH
55624: LD_INT 5
55626: PUSH
55627: EMPTY
55628: LIST
55629: LIST
55630: LIST
55631: LIST
55632: ST_TO_ADDR
55633: GO 56390
55635: LD_INT 12
55637: DOUBLE
55638: EQUAL
55639: IFTRUE 55643
55641: GO 55669
55643: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55644: LD_ADDR_VAR 0 3
55648: PUSH
55649: LD_INT 2
55651: PUSH
55652: LD_INT 3
55654: PUSH
55655: LD_INT 4
55657: PUSH
55658: LD_INT 5
55660: PUSH
55661: EMPTY
55662: LIST
55663: LIST
55664: LIST
55665: LIST
55666: ST_TO_ADDR
55667: GO 56390
55669: LD_INT 13
55671: DOUBLE
55672: EQUAL
55673: IFTRUE 55677
55675: GO 55703
55677: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55678: LD_ADDR_VAR 0 3
55682: PUSH
55683: LD_INT 2
55685: PUSH
55686: LD_INT 3
55688: PUSH
55689: LD_INT 4
55691: PUSH
55692: LD_INT 5
55694: PUSH
55695: EMPTY
55696: LIST
55697: LIST
55698: LIST
55699: LIST
55700: ST_TO_ADDR
55701: GO 56390
55703: LD_INT 14
55705: DOUBLE
55706: EQUAL
55707: IFTRUE 55711
55709: GO 55729
55711: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55712: LD_ADDR_VAR 0 3
55716: PUSH
55717: LD_INT 4
55719: PUSH
55720: LD_INT 5
55722: PUSH
55723: EMPTY
55724: LIST
55725: LIST
55726: ST_TO_ADDR
55727: GO 56390
55729: LD_INT 6
55731: DOUBLE
55732: EQUAL
55733: IFTRUE 55737
55735: GO 55755
55737: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55738: LD_ADDR_VAR 0 3
55742: PUSH
55743: LD_INT 4
55745: PUSH
55746: LD_INT 5
55748: PUSH
55749: EMPTY
55750: LIST
55751: LIST
55752: ST_TO_ADDR
55753: GO 56390
55755: LD_INT 10
55757: DOUBLE
55758: EQUAL
55759: IFTRUE 55763
55761: GO 55781
55763: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55764: LD_ADDR_VAR 0 3
55768: PUSH
55769: LD_INT 4
55771: PUSH
55772: LD_INT 5
55774: PUSH
55775: EMPTY
55776: LIST
55777: LIST
55778: ST_TO_ADDR
55779: GO 56390
55781: LD_INT 22
55783: DOUBLE
55784: EQUAL
55785: IFTRUE 55789
55787: GO 55815
55789: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55790: LD_ADDR_VAR 0 3
55794: PUSH
55795: LD_INT 11
55797: PUSH
55798: LD_INT 12
55800: PUSH
55801: LD_INT 13
55803: PUSH
55804: LD_INT 14
55806: PUSH
55807: EMPTY
55808: LIST
55809: LIST
55810: LIST
55811: LIST
55812: ST_TO_ADDR
55813: GO 56390
55815: LD_INT 23
55817: DOUBLE
55818: EQUAL
55819: IFTRUE 55823
55821: GO 55849
55823: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55824: LD_ADDR_VAR 0 3
55828: PUSH
55829: LD_INT 11
55831: PUSH
55832: LD_INT 12
55834: PUSH
55835: LD_INT 13
55837: PUSH
55838: LD_INT 14
55840: PUSH
55841: EMPTY
55842: LIST
55843: LIST
55844: LIST
55845: LIST
55846: ST_TO_ADDR
55847: GO 56390
55849: LD_INT 24
55851: DOUBLE
55852: EQUAL
55853: IFTRUE 55857
55855: GO 55883
55857: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55858: LD_ADDR_VAR 0 3
55862: PUSH
55863: LD_INT 11
55865: PUSH
55866: LD_INT 12
55868: PUSH
55869: LD_INT 13
55871: PUSH
55872: LD_INT 14
55874: PUSH
55875: EMPTY
55876: LIST
55877: LIST
55878: LIST
55879: LIST
55880: ST_TO_ADDR
55881: GO 56390
55883: LD_INT 30
55885: DOUBLE
55886: EQUAL
55887: IFTRUE 55891
55889: GO 55917
55891: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55892: LD_ADDR_VAR 0 3
55896: PUSH
55897: LD_INT 11
55899: PUSH
55900: LD_INT 12
55902: PUSH
55903: LD_INT 13
55905: PUSH
55906: LD_INT 14
55908: PUSH
55909: EMPTY
55910: LIST
55911: LIST
55912: LIST
55913: LIST
55914: ST_TO_ADDR
55915: GO 56390
55917: LD_INT 25
55919: DOUBLE
55920: EQUAL
55921: IFTRUE 55925
55923: GO 55943
55925: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55926: LD_ADDR_VAR 0 3
55930: PUSH
55931: LD_INT 13
55933: PUSH
55934: LD_INT 14
55936: PUSH
55937: EMPTY
55938: LIST
55939: LIST
55940: ST_TO_ADDR
55941: GO 56390
55943: LD_INT 27
55945: DOUBLE
55946: EQUAL
55947: IFTRUE 55951
55949: GO 55969
55951: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55952: LD_ADDR_VAR 0 3
55956: PUSH
55957: LD_INT 13
55959: PUSH
55960: LD_INT 14
55962: PUSH
55963: EMPTY
55964: LIST
55965: LIST
55966: ST_TO_ADDR
55967: GO 56390
55969: LD_INT 28
55971: DOUBLE
55972: EQUAL
55973: IFTRUE 55977
55975: GO 55995
55977: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55978: LD_ADDR_VAR 0 3
55982: PUSH
55983: LD_INT 13
55985: PUSH
55986: LD_INT 14
55988: PUSH
55989: EMPTY
55990: LIST
55991: LIST
55992: ST_TO_ADDR
55993: GO 56390
55995: LD_INT 29
55997: DOUBLE
55998: EQUAL
55999: IFTRUE 56003
56001: GO 56021
56003: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56004: LD_ADDR_VAR 0 3
56008: PUSH
56009: LD_INT 13
56011: PUSH
56012: LD_INT 14
56014: PUSH
56015: EMPTY
56016: LIST
56017: LIST
56018: ST_TO_ADDR
56019: GO 56390
56021: LD_INT 31
56023: DOUBLE
56024: EQUAL
56025: IFTRUE 56029
56027: GO 56047
56029: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56030: LD_ADDR_VAR 0 3
56034: PUSH
56035: LD_INT 13
56037: PUSH
56038: LD_INT 14
56040: PUSH
56041: EMPTY
56042: LIST
56043: LIST
56044: ST_TO_ADDR
56045: GO 56390
56047: LD_INT 26
56049: DOUBLE
56050: EQUAL
56051: IFTRUE 56055
56053: GO 56073
56055: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56056: LD_ADDR_VAR 0 3
56060: PUSH
56061: LD_INT 13
56063: PUSH
56064: LD_INT 14
56066: PUSH
56067: EMPTY
56068: LIST
56069: LIST
56070: ST_TO_ADDR
56071: GO 56390
56073: LD_INT 42
56075: DOUBLE
56076: EQUAL
56077: IFTRUE 56081
56079: GO 56107
56081: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56082: LD_ADDR_VAR 0 3
56086: PUSH
56087: LD_INT 21
56089: PUSH
56090: LD_INT 22
56092: PUSH
56093: LD_INT 23
56095: PUSH
56096: LD_INT 24
56098: PUSH
56099: EMPTY
56100: LIST
56101: LIST
56102: LIST
56103: LIST
56104: ST_TO_ADDR
56105: GO 56390
56107: LD_INT 43
56109: DOUBLE
56110: EQUAL
56111: IFTRUE 56115
56113: GO 56141
56115: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56116: LD_ADDR_VAR 0 3
56120: PUSH
56121: LD_INT 21
56123: PUSH
56124: LD_INT 22
56126: PUSH
56127: LD_INT 23
56129: PUSH
56130: LD_INT 24
56132: PUSH
56133: EMPTY
56134: LIST
56135: LIST
56136: LIST
56137: LIST
56138: ST_TO_ADDR
56139: GO 56390
56141: LD_INT 44
56143: DOUBLE
56144: EQUAL
56145: IFTRUE 56149
56147: GO 56175
56149: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56150: LD_ADDR_VAR 0 3
56154: PUSH
56155: LD_INT 21
56157: PUSH
56158: LD_INT 22
56160: PUSH
56161: LD_INT 23
56163: PUSH
56164: LD_INT 24
56166: PUSH
56167: EMPTY
56168: LIST
56169: LIST
56170: LIST
56171: LIST
56172: ST_TO_ADDR
56173: GO 56390
56175: LD_INT 45
56177: DOUBLE
56178: EQUAL
56179: IFTRUE 56183
56181: GO 56209
56183: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56184: LD_ADDR_VAR 0 3
56188: PUSH
56189: LD_INT 21
56191: PUSH
56192: LD_INT 22
56194: PUSH
56195: LD_INT 23
56197: PUSH
56198: LD_INT 24
56200: PUSH
56201: EMPTY
56202: LIST
56203: LIST
56204: LIST
56205: LIST
56206: ST_TO_ADDR
56207: GO 56390
56209: LD_INT 49
56211: DOUBLE
56212: EQUAL
56213: IFTRUE 56217
56215: GO 56243
56217: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56218: LD_ADDR_VAR 0 3
56222: PUSH
56223: LD_INT 21
56225: PUSH
56226: LD_INT 22
56228: PUSH
56229: LD_INT 23
56231: PUSH
56232: LD_INT 24
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: LIST
56239: LIST
56240: ST_TO_ADDR
56241: GO 56390
56243: LD_INT 51
56245: DOUBLE
56246: EQUAL
56247: IFTRUE 56251
56249: GO 56277
56251: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56252: LD_ADDR_VAR 0 3
56256: PUSH
56257: LD_INT 21
56259: PUSH
56260: LD_INT 22
56262: PUSH
56263: LD_INT 23
56265: PUSH
56266: LD_INT 24
56268: PUSH
56269: EMPTY
56270: LIST
56271: LIST
56272: LIST
56273: LIST
56274: ST_TO_ADDR
56275: GO 56390
56277: LD_INT 52
56279: DOUBLE
56280: EQUAL
56281: IFTRUE 56285
56283: GO 56311
56285: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56286: LD_ADDR_VAR 0 3
56290: PUSH
56291: LD_INT 21
56293: PUSH
56294: LD_INT 22
56296: PUSH
56297: LD_INT 23
56299: PUSH
56300: LD_INT 24
56302: PUSH
56303: EMPTY
56304: LIST
56305: LIST
56306: LIST
56307: LIST
56308: ST_TO_ADDR
56309: GO 56390
56311: LD_INT 53
56313: DOUBLE
56314: EQUAL
56315: IFTRUE 56319
56317: GO 56337
56319: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56320: LD_ADDR_VAR 0 3
56324: PUSH
56325: LD_INT 23
56327: PUSH
56328: LD_INT 24
56330: PUSH
56331: EMPTY
56332: LIST
56333: LIST
56334: ST_TO_ADDR
56335: GO 56390
56337: LD_INT 46
56339: DOUBLE
56340: EQUAL
56341: IFTRUE 56345
56343: GO 56363
56345: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56346: LD_ADDR_VAR 0 3
56350: PUSH
56351: LD_INT 23
56353: PUSH
56354: LD_INT 24
56356: PUSH
56357: EMPTY
56358: LIST
56359: LIST
56360: ST_TO_ADDR
56361: GO 56390
56363: LD_INT 47
56365: DOUBLE
56366: EQUAL
56367: IFTRUE 56371
56369: GO 56389
56371: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56372: LD_ADDR_VAR 0 3
56376: PUSH
56377: LD_INT 23
56379: PUSH
56380: LD_INT 24
56382: PUSH
56383: EMPTY
56384: LIST
56385: LIST
56386: ST_TO_ADDR
56387: GO 56390
56389: POP
// result := ( chassis in result ) ;
56390: LD_ADDR_VAR 0 3
56394: PUSH
56395: LD_VAR 0 1
56399: PUSH
56400: LD_VAR 0 3
56404: IN
56405: ST_TO_ADDR
// end ;
56406: LD_VAR 0 3
56410: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56411: LD_INT 0
56413: PPUSH
56414: PPUSH
56415: PPUSH
56416: PPUSH
56417: PPUSH
56418: PPUSH
56419: PPUSH
// result := array ;
56420: LD_ADDR_VAR 0 5
56424: PUSH
56425: LD_VAR 0 1
56429: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56430: LD_VAR 0 1
56434: NOT
56435: PUSH
56436: LD_VAR 0 2
56440: NOT
56441: OR
56442: PUSH
56443: LD_VAR 0 3
56447: NOT
56448: OR
56449: PUSH
56450: LD_VAR 0 2
56454: PUSH
56455: LD_VAR 0 1
56459: GREATER
56460: OR
56461: PUSH
56462: LD_VAR 0 3
56466: PUSH
56467: LD_VAR 0 1
56471: GREATER
56472: OR
56473: IFFALSE 56477
// exit ;
56475: GO 56773
// if direction then
56477: LD_VAR 0 4
56481: IFFALSE 56545
// begin d := 1 ;
56483: LD_ADDR_VAR 0 9
56487: PUSH
56488: LD_INT 1
56490: ST_TO_ADDR
// if i_from > i_to then
56491: LD_VAR 0 2
56495: PUSH
56496: LD_VAR 0 3
56500: GREATER
56501: IFFALSE 56527
// length := ( array - i_from ) + i_to else
56503: LD_ADDR_VAR 0 11
56507: PUSH
56508: LD_VAR 0 1
56512: PUSH
56513: LD_VAR 0 2
56517: MINUS
56518: PUSH
56519: LD_VAR 0 3
56523: PLUS
56524: ST_TO_ADDR
56525: GO 56543
// length := i_to - i_from ;
56527: LD_ADDR_VAR 0 11
56531: PUSH
56532: LD_VAR 0 3
56536: PUSH
56537: LD_VAR 0 2
56541: MINUS
56542: ST_TO_ADDR
// end else
56543: GO 56606
// begin d := - 1 ;
56545: LD_ADDR_VAR 0 9
56549: PUSH
56550: LD_INT 1
56552: NEG
56553: ST_TO_ADDR
// if i_from > i_to then
56554: LD_VAR 0 2
56558: PUSH
56559: LD_VAR 0 3
56563: GREATER
56564: IFFALSE 56584
// length := i_from - i_to else
56566: LD_ADDR_VAR 0 11
56570: PUSH
56571: LD_VAR 0 2
56575: PUSH
56576: LD_VAR 0 3
56580: MINUS
56581: ST_TO_ADDR
56582: GO 56606
// length := ( array - i_to ) + i_from ;
56584: LD_ADDR_VAR 0 11
56588: PUSH
56589: LD_VAR 0 1
56593: PUSH
56594: LD_VAR 0 3
56598: MINUS
56599: PUSH
56600: LD_VAR 0 2
56604: PLUS
56605: ST_TO_ADDR
// end ; if not length then
56606: LD_VAR 0 11
56610: NOT
56611: IFFALSE 56615
// exit ;
56613: GO 56773
// tmp := array ;
56615: LD_ADDR_VAR 0 10
56619: PUSH
56620: LD_VAR 0 1
56624: ST_TO_ADDR
// for i = 1 to length do
56625: LD_ADDR_VAR 0 6
56629: PUSH
56630: DOUBLE
56631: LD_INT 1
56633: DEC
56634: ST_TO_ADDR
56635: LD_VAR 0 11
56639: PUSH
56640: FOR_TO
56641: IFFALSE 56761
// begin for j = 1 to array do
56643: LD_ADDR_VAR 0 7
56647: PUSH
56648: DOUBLE
56649: LD_INT 1
56651: DEC
56652: ST_TO_ADDR
56653: LD_VAR 0 1
56657: PUSH
56658: FOR_TO
56659: IFFALSE 56747
// begin k := j + d ;
56661: LD_ADDR_VAR 0 8
56665: PUSH
56666: LD_VAR 0 7
56670: PUSH
56671: LD_VAR 0 9
56675: PLUS
56676: ST_TO_ADDR
// if k > array then
56677: LD_VAR 0 8
56681: PUSH
56682: LD_VAR 0 1
56686: GREATER
56687: IFFALSE 56697
// k := 1 ;
56689: LD_ADDR_VAR 0 8
56693: PUSH
56694: LD_INT 1
56696: ST_TO_ADDR
// if not k then
56697: LD_VAR 0 8
56701: NOT
56702: IFFALSE 56714
// k := array ;
56704: LD_ADDR_VAR 0 8
56708: PUSH
56709: LD_VAR 0 1
56713: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56714: LD_ADDR_VAR 0 10
56718: PUSH
56719: LD_VAR 0 10
56723: PPUSH
56724: LD_VAR 0 8
56728: PPUSH
56729: LD_VAR 0 1
56733: PUSH
56734: LD_VAR 0 7
56738: ARRAY
56739: PPUSH
56740: CALL_OW 1
56744: ST_TO_ADDR
// end ;
56745: GO 56658
56747: POP
56748: POP
// array := tmp ;
56749: LD_ADDR_VAR 0 1
56753: PUSH
56754: LD_VAR 0 10
56758: ST_TO_ADDR
// end ;
56759: GO 56640
56761: POP
56762: POP
// result := array ;
56763: LD_ADDR_VAR 0 5
56767: PUSH
56768: LD_VAR 0 1
56772: ST_TO_ADDR
// end ;
56773: LD_VAR 0 5
56777: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56778: LD_INT 0
56780: PPUSH
56781: PPUSH
// result := 0 ;
56782: LD_ADDR_VAR 0 3
56786: PUSH
56787: LD_INT 0
56789: ST_TO_ADDR
// if not array or not value in array then
56790: LD_VAR 0 1
56794: NOT
56795: PUSH
56796: LD_VAR 0 2
56800: PUSH
56801: LD_VAR 0 1
56805: IN
56806: NOT
56807: OR
56808: IFFALSE 56812
// exit ;
56810: GO 56866
// for i = 1 to array do
56812: LD_ADDR_VAR 0 4
56816: PUSH
56817: DOUBLE
56818: LD_INT 1
56820: DEC
56821: ST_TO_ADDR
56822: LD_VAR 0 1
56826: PUSH
56827: FOR_TO
56828: IFFALSE 56864
// if value = array [ i ] then
56830: LD_VAR 0 2
56834: PUSH
56835: LD_VAR 0 1
56839: PUSH
56840: LD_VAR 0 4
56844: ARRAY
56845: EQUAL
56846: IFFALSE 56862
// begin result := i ;
56848: LD_ADDR_VAR 0 3
56852: PUSH
56853: LD_VAR 0 4
56857: ST_TO_ADDR
// exit ;
56858: POP
56859: POP
56860: GO 56866
// end ;
56862: GO 56827
56864: POP
56865: POP
// end ;
56866: LD_VAR 0 3
56870: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56871: LD_INT 0
56873: PPUSH
// vc_chassis := chassis ;
56874: LD_ADDR_OWVAR 37
56878: PUSH
56879: LD_VAR 0 1
56883: ST_TO_ADDR
// vc_engine := engine ;
56884: LD_ADDR_OWVAR 39
56888: PUSH
56889: LD_VAR 0 2
56893: ST_TO_ADDR
// vc_control := control ;
56894: LD_ADDR_OWVAR 38
56898: PUSH
56899: LD_VAR 0 3
56903: ST_TO_ADDR
// vc_weapon := weapon ;
56904: LD_ADDR_OWVAR 40
56908: PUSH
56909: LD_VAR 0 4
56913: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56914: LD_ADDR_OWVAR 41
56918: PUSH
56919: LD_VAR 0 5
56923: ST_TO_ADDR
// end ;
56924: LD_VAR 0 6
56928: RET
// export function WantPlant ( unit ) ; var task ; begin
56929: LD_INT 0
56931: PPUSH
56932: PPUSH
// result := false ;
56933: LD_ADDR_VAR 0 2
56937: PUSH
56938: LD_INT 0
56940: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56941: LD_ADDR_VAR 0 3
56945: PUSH
56946: LD_VAR 0 1
56950: PPUSH
56951: CALL_OW 437
56955: ST_TO_ADDR
// if task then
56956: LD_VAR 0 3
56960: IFFALSE 56988
// if task [ 1 ] [ 1 ] = p then
56962: LD_VAR 0 3
56966: PUSH
56967: LD_INT 1
56969: ARRAY
56970: PUSH
56971: LD_INT 1
56973: ARRAY
56974: PUSH
56975: LD_STRING p
56977: EQUAL
56978: IFFALSE 56988
// result := true ;
56980: LD_ADDR_VAR 0 2
56984: PUSH
56985: LD_INT 1
56987: ST_TO_ADDR
// end ;
56988: LD_VAR 0 2
56992: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56993: LD_INT 0
56995: PPUSH
56996: PPUSH
56997: PPUSH
56998: PPUSH
// if pos < 1 then
56999: LD_VAR 0 2
57003: PUSH
57004: LD_INT 1
57006: LESS
57007: IFFALSE 57011
// exit ;
57009: GO 57314
// if pos = 1 then
57011: LD_VAR 0 2
57015: PUSH
57016: LD_INT 1
57018: EQUAL
57019: IFFALSE 57052
// result := Replace ( arr , pos [ 1 ] , value ) else
57021: LD_ADDR_VAR 0 4
57025: PUSH
57026: LD_VAR 0 1
57030: PPUSH
57031: LD_VAR 0 2
57035: PUSH
57036: LD_INT 1
57038: ARRAY
57039: PPUSH
57040: LD_VAR 0 3
57044: PPUSH
57045: CALL_OW 1
57049: ST_TO_ADDR
57050: GO 57314
// begin tmp := arr ;
57052: LD_ADDR_VAR 0 6
57056: PUSH
57057: LD_VAR 0 1
57061: ST_TO_ADDR
// s_arr := [ tmp ] ;
57062: LD_ADDR_VAR 0 7
57066: PUSH
57067: LD_VAR 0 6
57071: PUSH
57072: EMPTY
57073: LIST
57074: ST_TO_ADDR
// for i = 1 to pos - 1 do
57075: LD_ADDR_VAR 0 5
57079: PUSH
57080: DOUBLE
57081: LD_INT 1
57083: DEC
57084: ST_TO_ADDR
57085: LD_VAR 0 2
57089: PUSH
57090: LD_INT 1
57092: MINUS
57093: PUSH
57094: FOR_TO
57095: IFFALSE 57140
// begin tmp := tmp [ pos [ i ] ] ;
57097: LD_ADDR_VAR 0 6
57101: PUSH
57102: LD_VAR 0 6
57106: PUSH
57107: LD_VAR 0 2
57111: PUSH
57112: LD_VAR 0 5
57116: ARRAY
57117: ARRAY
57118: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57119: LD_ADDR_VAR 0 7
57123: PUSH
57124: LD_VAR 0 7
57128: PUSH
57129: LD_VAR 0 6
57133: PUSH
57134: EMPTY
57135: LIST
57136: ADD
57137: ST_TO_ADDR
// end ;
57138: GO 57094
57140: POP
57141: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57142: LD_ADDR_VAR 0 6
57146: PUSH
57147: LD_VAR 0 6
57151: PPUSH
57152: LD_VAR 0 2
57156: PUSH
57157: LD_VAR 0 2
57161: ARRAY
57162: PPUSH
57163: LD_VAR 0 3
57167: PPUSH
57168: CALL_OW 1
57172: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57173: LD_ADDR_VAR 0 7
57177: PUSH
57178: LD_VAR 0 7
57182: PPUSH
57183: LD_VAR 0 7
57187: PPUSH
57188: LD_VAR 0 6
57192: PPUSH
57193: CALL_OW 1
57197: ST_TO_ADDR
// for i = s_arr downto 2 do
57198: LD_ADDR_VAR 0 5
57202: PUSH
57203: DOUBLE
57204: LD_VAR 0 7
57208: INC
57209: ST_TO_ADDR
57210: LD_INT 2
57212: PUSH
57213: FOR_DOWNTO
57214: IFFALSE 57298
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57216: LD_ADDR_VAR 0 6
57220: PUSH
57221: LD_VAR 0 7
57225: PUSH
57226: LD_VAR 0 5
57230: PUSH
57231: LD_INT 1
57233: MINUS
57234: ARRAY
57235: PPUSH
57236: LD_VAR 0 2
57240: PUSH
57241: LD_VAR 0 5
57245: PUSH
57246: LD_INT 1
57248: MINUS
57249: ARRAY
57250: PPUSH
57251: LD_VAR 0 7
57255: PUSH
57256: LD_VAR 0 5
57260: ARRAY
57261: PPUSH
57262: CALL_OW 1
57266: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57267: LD_ADDR_VAR 0 7
57271: PUSH
57272: LD_VAR 0 7
57276: PPUSH
57277: LD_VAR 0 5
57281: PUSH
57282: LD_INT 1
57284: MINUS
57285: PPUSH
57286: LD_VAR 0 6
57290: PPUSH
57291: CALL_OW 1
57295: ST_TO_ADDR
// end ;
57296: GO 57213
57298: POP
57299: POP
// result := s_arr [ 1 ] ;
57300: LD_ADDR_VAR 0 4
57304: PUSH
57305: LD_VAR 0 7
57309: PUSH
57310: LD_INT 1
57312: ARRAY
57313: ST_TO_ADDR
// end ; end ;
57314: LD_VAR 0 4
57318: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57319: LD_INT 0
57321: PPUSH
57322: PPUSH
// if not list then
57323: LD_VAR 0 1
57327: NOT
57328: IFFALSE 57332
// exit ;
57330: GO 57423
// i := list [ pos1 ] ;
57332: LD_ADDR_VAR 0 5
57336: PUSH
57337: LD_VAR 0 1
57341: PUSH
57342: LD_VAR 0 2
57346: ARRAY
57347: ST_TO_ADDR
// if not i then
57348: LD_VAR 0 5
57352: NOT
57353: IFFALSE 57357
// exit ;
57355: GO 57423
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57357: LD_ADDR_VAR 0 1
57361: PUSH
57362: LD_VAR 0 1
57366: PPUSH
57367: LD_VAR 0 2
57371: PPUSH
57372: LD_VAR 0 1
57376: PUSH
57377: LD_VAR 0 3
57381: ARRAY
57382: PPUSH
57383: CALL_OW 1
57387: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57388: LD_ADDR_VAR 0 1
57392: PUSH
57393: LD_VAR 0 1
57397: PPUSH
57398: LD_VAR 0 3
57402: PPUSH
57403: LD_VAR 0 5
57407: PPUSH
57408: CALL_OW 1
57412: ST_TO_ADDR
// result := list ;
57413: LD_ADDR_VAR 0 4
57417: PUSH
57418: LD_VAR 0 1
57422: ST_TO_ADDR
// end ;
57423: LD_VAR 0 4
57427: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57428: LD_INT 0
57430: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57431: LD_ADDR_VAR 0 5
57435: PUSH
57436: LD_VAR 0 1
57440: PPUSH
57441: CALL_OW 250
57445: PPUSH
57446: LD_VAR 0 1
57450: PPUSH
57451: CALL_OW 251
57455: PPUSH
57456: LD_VAR 0 2
57460: PPUSH
57461: LD_VAR 0 3
57465: PPUSH
57466: LD_VAR 0 4
57470: PPUSH
57471: CALL 57481 0 5
57475: ST_TO_ADDR
// end ;
57476: LD_VAR 0 5
57480: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57481: LD_INT 0
57483: PPUSH
57484: PPUSH
57485: PPUSH
57486: PPUSH
// if not list then
57487: LD_VAR 0 3
57491: NOT
57492: IFFALSE 57496
// exit ;
57494: GO 57884
// result := [ ] ;
57496: LD_ADDR_VAR 0 6
57500: PUSH
57501: EMPTY
57502: ST_TO_ADDR
// for i in list do
57503: LD_ADDR_VAR 0 7
57507: PUSH
57508: LD_VAR 0 3
57512: PUSH
57513: FOR_IN
57514: IFFALSE 57716
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57516: LD_ADDR_VAR 0 9
57520: PUSH
57521: LD_VAR 0 7
57525: PPUSH
57526: LD_VAR 0 1
57530: PPUSH
57531: LD_VAR 0 2
57535: PPUSH
57536: CALL_OW 297
57540: ST_TO_ADDR
// if not result then
57541: LD_VAR 0 6
57545: NOT
57546: IFFALSE 57572
// result := [ [ i , tmp ] ] else
57548: LD_ADDR_VAR 0 6
57552: PUSH
57553: LD_VAR 0 7
57557: PUSH
57558: LD_VAR 0 9
57562: PUSH
57563: EMPTY
57564: LIST
57565: LIST
57566: PUSH
57567: EMPTY
57568: LIST
57569: ST_TO_ADDR
57570: GO 57714
// begin if result [ result ] [ 2 ] < tmp then
57572: LD_VAR 0 6
57576: PUSH
57577: LD_VAR 0 6
57581: ARRAY
57582: PUSH
57583: LD_INT 2
57585: ARRAY
57586: PUSH
57587: LD_VAR 0 9
57591: LESS
57592: IFFALSE 57634
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57594: LD_ADDR_VAR 0 6
57598: PUSH
57599: LD_VAR 0 6
57603: PPUSH
57604: LD_VAR 0 6
57608: PUSH
57609: LD_INT 1
57611: PLUS
57612: PPUSH
57613: LD_VAR 0 7
57617: PUSH
57618: LD_VAR 0 9
57622: PUSH
57623: EMPTY
57624: LIST
57625: LIST
57626: PPUSH
57627: CALL_OW 2
57631: ST_TO_ADDR
57632: GO 57714
// for j = 1 to result do
57634: LD_ADDR_VAR 0 8
57638: PUSH
57639: DOUBLE
57640: LD_INT 1
57642: DEC
57643: ST_TO_ADDR
57644: LD_VAR 0 6
57648: PUSH
57649: FOR_TO
57650: IFFALSE 57712
// begin if tmp < result [ j ] [ 2 ] then
57652: LD_VAR 0 9
57656: PUSH
57657: LD_VAR 0 6
57661: PUSH
57662: LD_VAR 0 8
57666: ARRAY
57667: PUSH
57668: LD_INT 2
57670: ARRAY
57671: LESS
57672: IFFALSE 57710
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57674: LD_ADDR_VAR 0 6
57678: PUSH
57679: LD_VAR 0 6
57683: PPUSH
57684: LD_VAR 0 8
57688: PPUSH
57689: LD_VAR 0 7
57693: PUSH
57694: LD_VAR 0 9
57698: PUSH
57699: EMPTY
57700: LIST
57701: LIST
57702: PPUSH
57703: CALL_OW 2
57707: ST_TO_ADDR
// break ;
57708: GO 57712
// end ; end ;
57710: GO 57649
57712: POP
57713: POP
// end ; end ;
57714: GO 57513
57716: POP
57717: POP
// if result and not asc then
57718: LD_VAR 0 6
57722: PUSH
57723: LD_VAR 0 4
57727: NOT
57728: AND
57729: IFFALSE 57804
// begin tmp := result ;
57731: LD_ADDR_VAR 0 9
57735: PUSH
57736: LD_VAR 0 6
57740: ST_TO_ADDR
// for i = tmp downto 1 do
57741: LD_ADDR_VAR 0 7
57745: PUSH
57746: DOUBLE
57747: LD_VAR 0 9
57751: INC
57752: ST_TO_ADDR
57753: LD_INT 1
57755: PUSH
57756: FOR_DOWNTO
57757: IFFALSE 57802
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57759: LD_ADDR_VAR 0 6
57763: PUSH
57764: LD_VAR 0 6
57768: PPUSH
57769: LD_VAR 0 9
57773: PUSH
57774: LD_VAR 0 7
57778: MINUS
57779: PUSH
57780: LD_INT 1
57782: PLUS
57783: PPUSH
57784: LD_VAR 0 9
57788: PUSH
57789: LD_VAR 0 7
57793: ARRAY
57794: PPUSH
57795: CALL_OW 1
57799: ST_TO_ADDR
57800: GO 57756
57802: POP
57803: POP
// end ; tmp := [ ] ;
57804: LD_ADDR_VAR 0 9
57808: PUSH
57809: EMPTY
57810: ST_TO_ADDR
// if mode then
57811: LD_VAR 0 5
57815: IFFALSE 57884
// begin for i = 1 to result do
57817: LD_ADDR_VAR 0 7
57821: PUSH
57822: DOUBLE
57823: LD_INT 1
57825: DEC
57826: ST_TO_ADDR
57827: LD_VAR 0 6
57831: PUSH
57832: FOR_TO
57833: IFFALSE 57872
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57835: LD_ADDR_VAR 0 9
57839: PUSH
57840: LD_VAR 0 9
57844: PPUSH
57845: LD_VAR 0 7
57849: PPUSH
57850: LD_VAR 0 6
57854: PUSH
57855: LD_VAR 0 7
57859: ARRAY
57860: PUSH
57861: LD_INT 1
57863: ARRAY
57864: PPUSH
57865: CALL_OW 1
57869: ST_TO_ADDR
57870: GO 57832
57872: POP
57873: POP
// result := tmp ;
57874: LD_ADDR_VAR 0 6
57878: PUSH
57879: LD_VAR 0 9
57883: ST_TO_ADDR
// end ; end ;
57884: LD_VAR 0 6
57888: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57889: LD_INT 0
57891: PPUSH
57892: PPUSH
57893: PPUSH
57894: PPUSH
57895: PPUSH
57896: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57897: LD_ADDR_VAR 0 5
57901: PUSH
57902: LD_INT 0
57904: PUSH
57905: LD_INT 0
57907: PUSH
57908: LD_INT 0
57910: PUSH
57911: EMPTY
57912: PUSH
57913: EMPTY
57914: LIST
57915: LIST
57916: LIST
57917: LIST
57918: ST_TO_ADDR
// if not x or not y then
57919: LD_VAR 0 2
57923: NOT
57924: PUSH
57925: LD_VAR 0 3
57929: NOT
57930: OR
57931: IFFALSE 57935
// exit ;
57933: GO 59581
// if not range then
57935: LD_VAR 0 4
57939: NOT
57940: IFFALSE 57950
// range := 10 ;
57942: LD_ADDR_VAR 0 4
57946: PUSH
57947: LD_INT 10
57949: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57950: LD_ADDR_VAR 0 8
57954: PUSH
57955: LD_INT 81
57957: PUSH
57958: LD_VAR 0 1
57962: PUSH
57963: EMPTY
57964: LIST
57965: LIST
57966: PUSH
57967: LD_INT 92
57969: PUSH
57970: LD_VAR 0 2
57974: PUSH
57975: LD_VAR 0 3
57979: PUSH
57980: LD_VAR 0 4
57984: PUSH
57985: EMPTY
57986: LIST
57987: LIST
57988: LIST
57989: LIST
57990: PUSH
57991: LD_INT 3
57993: PUSH
57994: LD_INT 21
57996: PUSH
57997: LD_INT 3
57999: PUSH
58000: EMPTY
58001: LIST
58002: LIST
58003: PUSH
58004: EMPTY
58005: LIST
58006: LIST
58007: PUSH
58008: EMPTY
58009: LIST
58010: LIST
58011: LIST
58012: PPUSH
58013: CALL_OW 69
58017: ST_TO_ADDR
// if not tmp then
58018: LD_VAR 0 8
58022: NOT
58023: IFFALSE 58027
// exit ;
58025: GO 59581
// for i in tmp do
58027: LD_ADDR_VAR 0 6
58031: PUSH
58032: LD_VAR 0 8
58036: PUSH
58037: FOR_IN
58038: IFFALSE 59556
// begin points := [ 0 , 0 , 0 ] ;
58040: LD_ADDR_VAR 0 9
58044: PUSH
58045: LD_INT 0
58047: PUSH
58048: LD_INT 0
58050: PUSH
58051: LD_INT 0
58053: PUSH
58054: EMPTY
58055: LIST
58056: LIST
58057: LIST
58058: ST_TO_ADDR
// bpoints := 1 ;
58059: LD_ADDR_VAR 0 10
58063: PUSH
58064: LD_INT 1
58066: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58067: LD_VAR 0 6
58071: PPUSH
58072: CALL_OW 247
58076: PUSH
58077: LD_INT 1
58079: DOUBLE
58080: EQUAL
58081: IFTRUE 58085
58083: GO 58663
58085: POP
// begin if GetClass ( i ) = 1 then
58086: LD_VAR 0 6
58090: PPUSH
58091: CALL_OW 257
58095: PUSH
58096: LD_INT 1
58098: EQUAL
58099: IFFALSE 58120
// points := [ 10 , 5 , 3 ] ;
58101: LD_ADDR_VAR 0 9
58105: PUSH
58106: LD_INT 10
58108: PUSH
58109: LD_INT 5
58111: PUSH
58112: LD_INT 3
58114: PUSH
58115: EMPTY
58116: LIST
58117: LIST
58118: LIST
58119: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58120: LD_VAR 0 6
58124: PPUSH
58125: CALL_OW 257
58129: PUSH
58130: LD_INT 2
58132: PUSH
58133: LD_INT 3
58135: PUSH
58136: LD_INT 4
58138: PUSH
58139: EMPTY
58140: LIST
58141: LIST
58142: LIST
58143: IN
58144: IFFALSE 58165
// points := [ 3 , 2 , 1 ] ;
58146: LD_ADDR_VAR 0 9
58150: PUSH
58151: LD_INT 3
58153: PUSH
58154: LD_INT 2
58156: PUSH
58157: LD_INT 1
58159: PUSH
58160: EMPTY
58161: LIST
58162: LIST
58163: LIST
58164: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58165: LD_VAR 0 6
58169: PPUSH
58170: CALL_OW 257
58174: PUSH
58175: LD_INT 5
58177: EQUAL
58178: IFFALSE 58199
// points := [ 130 , 5 , 2 ] ;
58180: LD_ADDR_VAR 0 9
58184: PUSH
58185: LD_INT 130
58187: PUSH
58188: LD_INT 5
58190: PUSH
58191: LD_INT 2
58193: PUSH
58194: EMPTY
58195: LIST
58196: LIST
58197: LIST
58198: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58199: LD_VAR 0 6
58203: PPUSH
58204: CALL_OW 257
58208: PUSH
58209: LD_INT 8
58211: EQUAL
58212: IFFALSE 58233
// points := [ 35 , 35 , 30 ] ;
58214: LD_ADDR_VAR 0 9
58218: PUSH
58219: LD_INT 35
58221: PUSH
58222: LD_INT 35
58224: PUSH
58225: LD_INT 30
58227: PUSH
58228: EMPTY
58229: LIST
58230: LIST
58231: LIST
58232: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58233: LD_VAR 0 6
58237: PPUSH
58238: CALL_OW 257
58242: PUSH
58243: LD_INT 9
58245: EQUAL
58246: IFFALSE 58267
// points := [ 20 , 55 , 40 ] ;
58248: LD_ADDR_VAR 0 9
58252: PUSH
58253: LD_INT 20
58255: PUSH
58256: LD_INT 55
58258: PUSH
58259: LD_INT 40
58261: PUSH
58262: EMPTY
58263: LIST
58264: LIST
58265: LIST
58266: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58267: LD_VAR 0 6
58271: PPUSH
58272: CALL_OW 257
58276: PUSH
58277: LD_INT 12
58279: PUSH
58280: LD_INT 16
58282: PUSH
58283: EMPTY
58284: LIST
58285: LIST
58286: IN
58287: IFFALSE 58308
// points := [ 5 , 3 , 2 ] ;
58289: LD_ADDR_VAR 0 9
58293: PUSH
58294: LD_INT 5
58296: PUSH
58297: LD_INT 3
58299: PUSH
58300: LD_INT 2
58302: PUSH
58303: EMPTY
58304: LIST
58305: LIST
58306: LIST
58307: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58308: LD_VAR 0 6
58312: PPUSH
58313: CALL_OW 257
58317: PUSH
58318: LD_INT 17
58320: EQUAL
58321: IFFALSE 58342
// points := [ 100 , 50 , 75 ] ;
58323: LD_ADDR_VAR 0 9
58327: PUSH
58328: LD_INT 100
58330: PUSH
58331: LD_INT 50
58333: PUSH
58334: LD_INT 75
58336: PUSH
58337: EMPTY
58338: LIST
58339: LIST
58340: LIST
58341: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58342: LD_VAR 0 6
58346: PPUSH
58347: CALL_OW 257
58351: PUSH
58352: LD_INT 15
58354: EQUAL
58355: IFFALSE 58376
// points := [ 10 , 5 , 3 ] ;
58357: LD_ADDR_VAR 0 9
58361: PUSH
58362: LD_INT 10
58364: PUSH
58365: LD_INT 5
58367: PUSH
58368: LD_INT 3
58370: PUSH
58371: EMPTY
58372: LIST
58373: LIST
58374: LIST
58375: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58376: LD_VAR 0 6
58380: PPUSH
58381: CALL_OW 257
58385: PUSH
58386: LD_INT 14
58388: EQUAL
58389: IFFALSE 58410
// points := [ 10 , 0 , 0 ] ;
58391: LD_ADDR_VAR 0 9
58395: PUSH
58396: LD_INT 10
58398: PUSH
58399: LD_INT 0
58401: PUSH
58402: LD_INT 0
58404: PUSH
58405: EMPTY
58406: LIST
58407: LIST
58408: LIST
58409: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58410: LD_VAR 0 6
58414: PPUSH
58415: CALL_OW 257
58419: PUSH
58420: LD_INT 11
58422: EQUAL
58423: IFFALSE 58444
// points := [ 30 , 10 , 5 ] ;
58425: LD_ADDR_VAR 0 9
58429: PUSH
58430: LD_INT 30
58432: PUSH
58433: LD_INT 10
58435: PUSH
58436: LD_INT 5
58438: PUSH
58439: EMPTY
58440: LIST
58441: LIST
58442: LIST
58443: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58444: LD_VAR 0 1
58448: PPUSH
58449: LD_INT 5
58451: PPUSH
58452: CALL_OW 321
58456: PUSH
58457: LD_INT 2
58459: EQUAL
58460: IFFALSE 58477
// bpoints := bpoints * 1.8 ;
58462: LD_ADDR_VAR 0 10
58466: PUSH
58467: LD_VAR 0 10
58471: PUSH
58472: LD_REAL  1.80000000000000E+0000
58475: MUL
58476: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58477: LD_VAR 0 6
58481: PPUSH
58482: CALL_OW 257
58486: PUSH
58487: LD_INT 1
58489: PUSH
58490: LD_INT 2
58492: PUSH
58493: LD_INT 3
58495: PUSH
58496: LD_INT 4
58498: PUSH
58499: EMPTY
58500: LIST
58501: LIST
58502: LIST
58503: LIST
58504: IN
58505: PUSH
58506: LD_VAR 0 1
58510: PPUSH
58511: LD_INT 51
58513: PPUSH
58514: CALL_OW 321
58518: PUSH
58519: LD_INT 2
58521: EQUAL
58522: AND
58523: IFFALSE 58540
// bpoints := bpoints * 1.2 ;
58525: LD_ADDR_VAR 0 10
58529: PUSH
58530: LD_VAR 0 10
58534: PUSH
58535: LD_REAL  1.20000000000000E+0000
58538: MUL
58539: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58540: LD_VAR 0 6
58544: PPUSH
58545: CALL_OW 257
58549: PUSH
58550: LD_INT 5
58552: PUSH
58553: LD_INT 7
58555: PUSH
58556: LD_INT 9
58558: PUSH
58559: EMPTY
58560: LIST
58561: LIST
58562: LIST
58563: IN
58564: PUSH
58565: LD_VAR 0 1
58569: PPUSH
58570: LD_INT 52
58572: PPUSH
58573: CALL_OW 321
58577: PUSH
58578: LD_INT 2
58580: EQUAL
58581: AND
58582: IFFALSE 58599
// bpoints := bpoints * 1.5 ;
58584: LD_ADDR_VAR 0 10
58588: PUSH
58589: LD_VAR 0 10
58593: PUSH
58594: LD_REAL  1.50000000000000E+0000
58597: MUL
58598: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58599: LD_VAR 0 1
58603: PPUSH
58604: LD_INT 66
58606: PPUSH
58607: CALL_OW 321
58611: PUSH
58612: LD_INT 2
58614: EQUAL
58615: IFFALSE 58632
// bpoints := bpoints * 1.1 ;
58617: LD_ADDR_VAR 0 10
58621: PUSH
58622: LD_VAR 0 10
58626: PUSH
58627: LD_REAL  1.10000000000000E+0000
58630: MUL
58631: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58632: LD_ADDR_VAR 0 10
58636: PUSH
58637: LD_VAR 0 10
58641: PUSH
58642: LD_VAR 0 6
58646: PPUSH
58647: LD_INT 1
58649: PPUSH
58650: CALL_OW 259
58654: PUSH
58655: LD_REAL  1.15000000000000E+0000
58658: MUL
58659: MUL
58660: ST_TO_ADDR
// end ; unit_vehicle :
58661: GO 59485
58663: LD_INT 2
58665: DOUBLE
58666: EQUAL
58667: IFTRUE 58671
58669: GO 59473
58671: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58672: LD_VAR 0 6
58676: PPUSH
58677: CALL_OW 264
58681: PUSH
58682: LD_INT 2
58684: PUSH
58685: LD_INT 42
58687: PUSH
58688: LD_INT 24
58690: PUSH
58691: EMPTY
58692: LIST
58693: LIST
58694: LIST
58695: IN
58696: IFFALSE 58717
// points := [ 25 , 5 , 3 ] ;
58698: LD_ADDR_VAR 0 9
58702: PUSH
58703: LD_INT 25
58705: PUSH
58706: LD_INT 5
58708: PUSH
58709: LD_INT 3
58711: PUSH
58712: EMPTY
58713: LIST
58714: LIST
58715: LIST
58716: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58717: LD_VAR 0 6
58721: PPUSH
58722: CALL_OW 264
58726: PUSH
58727: LD_INT 4
58729: PUSH
58730: LD_INT 43
58732: PUSH
58733: LD_INT 25
58735: PUSH
58736: EMPTY
58737: LIST
58738: LIST
58739: LIST
58740: IN
58741: IFFALSE 58762
// points := [ 40 , 15 , 5 ] ;
58743: LD_ADDR_VAR 0 9
58747: PUSH
58748: LD_INT 40
58750: PUSH
58751: LD_INT 15
58753: PUSH
58754: LD_INT 5
58756: PUSH
58757: EMPTY
58758: LIST
58759: LIST
58760: LIST
58761: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58762: LD_VAR 0 6
58766: PPUSH
58767: CALL_OW 264
58771: PUSH
58772: LD_INT 3
58774: PUSH
58775: LD_INT 23
58777: PUSH
58778: EMPTY
58779: LIST
58780: LIST
58781: IN
58782: IFFALSE 58803
// points := [ 7 , 25 , 8 ] ;
58784: LD_ADDR_VAR 0 9
58788: PUSH
58789: LD_INT 7
58791: PUSH
58792: LD_INT 25
58794: PUSH
58795: LD_INT 8
58797: PUSH
58798: EMPTY
58799: LIST
58800: LIST
58801: LIST
58802: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58803: LD_VAR 0 6
58807: PPUSH
58808: CALL_OW 264
58812: PUSH
58813: LD_INT 5
58815: PUSH
58816: LD_INT 27
58818: PUSH
58819: LD_INT 44
58821: PUSH
58822: EMPTY
58823: LIST
58824: LIST
58825: LIST
58826: IN
58827: IFFALSE 58848
// points := [ 14 , 50 , 16 ] ;
58829: LD_ADDR_VAR 0 9
58833: PUSH
58834: LD_INT 14
58836: PUSH
58837: LD_INT 50
58839: PUSH
58840: LD_INT 16
58842: PUSH
58843: EMPTY
58844: LIST
58845: LIST
58846: LIST
58847: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58848: LD_VAR 0 6
58852: PPUSH
58853: CALL_OW 264
58857: PUSH
58858: LD_INT 6
58860: PUSH
58861: LD_INT 46
58863: PUSH
58864: EMPTY
58865: LIST
58866: LIST
58867: IN
58868: IFFALSE 58889
// points := [ 32 , 120 , 70 ] ;
58870: LD_ADDR_VAR 0 9
58874: PUSH
58875: LD_INT 32
58877: PUSH
58878: LD_INT 120
58880: PUSH
58881: LD_INT 70
58883: PUSH
58884: EMPTY
58885: LIST
58886: LIST
58887: LIST
58888: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
58889: LD_VAR 0 6
58893: PPUSH
58894: CALL_OW 264
58898: PUSH
58899: LD_INT 7
58901: PUSH
58902: LD_INT 28
58904: PUSH
58905: LD_INT 45
58907: PUSH
58908: EMPTY
58909: LIST
58910: LIST
58911: LIST
58912: IN
58913: IFFALSE 58934
// points := [ 35 , 20 , 45 ] ;
58915: LD_ADDR_VAR 0 9
58919: PUSH
58920: LD_INT 35
58922: PUSH
58923: LD_INT 20
58925: PUSH
58926: LD_INT 45
58928: PUSH
58929: EMPTY
58930: LIST
58931: LIST
58932: LIST
58933: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58934: LD_VAR 0 6
58938: PPUSH
58939: CALL_OW 264
58943: PUSH
58944: LD_INT 47
58946: PUSH
58947: EMPTY
58948: LIST
58949: IN
58950: IFFALSE 58971
// points := [ 67 , 45 , 75 ] ;
58952: LD_ADDR_VAR 0 9
58956: PUSH
58957: LD_INT 67
58959: PUSH
58960: LD_INT 45
58962: PUSH
58963: LD_INT 75
58965: PUSH
58966: EMPTY
58967: LIST
58968: LIST
58969: LIST
58970: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58971: LD_VAR 0 6
58975: PPUSH
58976: CALL_OW 264
58980: PUSH
58981: LD_INT 26
58983: PUSH
58984: EMPTY
58985: LIST
58986: IN
58987: IFFALSE 59008
// points := [ 120 , 30 , 80 ] ;
58989: LD_ADDR_VAR 0 9
58993: PUSH
58994: LD_INT 120
58996: PUSH
58997: LD_INT 30
58999: PUSH
59000: LD_INT 80
59002: PUSH
59003: EMPTY
59004: LIST
59005: LIST
59006: LIST
59007: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59008: LD_VAR 0 6
59012: PPUSH
59013: CALL_OW 264
59017: PUSH
59018: LD_INT 22
59020: PUSH
59021: EMPTY
59022: LIST
59023: IN
59024: IFFALSE 59045
// points := [ 40 , 1 , 1 ] ;
59026: LD_ADDR_VAR 0 9
59030: PUSH
59031: LD_INT 40
59033: PUSH
59034: LD_INT 1
59036: PUSH
59037: LD_INT 1
59039: PUSH
59040: EMPTY
59041: LIST
59042: LIST
59043: LIST
59044: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59045: LD_VAR 0 6
59049: PPUSH
59050: CALL_OW 264
59054: PUSH
59055: LD_INT 29
59057: PUSH
59058: EMPTY
59059: LIST
59060: IN
59061: IFFALSE 59082
// points := [ 70 , 200 , 400 ] ;
59063: LD_ADDR_VAR 0 9
59067: PUSH
59068: LD_INT 70
59070: PUSH
59071: LD_INT 200
59073: PUSH
59074: LD_INT 400
59076: PUSH
59077: EMPTY
59078: LIST
59079: LIST
59080: LIST
59081: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59082: LD_VAR 0 6
59086: PPUSH
59087: CALL_OW 264
59091: PUSH
59092: LD_INT 14
59094: PUSH
59095: LD_INT 53
59097: PUSH
59098: EMPTY
59099: LIST
59100: LIST
59101: IN
59102: IFFALSE 59123
// points := [ 40 , 10 , 20 ] ;
59104: LD_ADDR_VAR 0 9
59108: PUSH
59109: LD_INT 40
59111: PUSH
59112: LD_INT 10
59114: PUSH
59115: LD_INT 20
59117: PUSH
59118: EMPTY
59119: LIST
59120: LIST
59121: LIST
59122: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59123: LD_VAR 0 6
59127: PPUSH
59128: CALL_OW 264
59132: PUSH
59133: LD_INT 9
59135: PUSH
59136: EMPTY
59137: LIST
59138: IN
59139: IFFALSE 59160
// points := [ 5 , 70 , 20 ] ;
59141: LD_ADDR_VAR 0 9
59145: PUSH
59146: LD_INT 5
59148: PUSH
59149: LD_INT 70
59151: PUSH
59152: LD_INT 20
59154: PUSH
59155: EMPTY
59156: LIST
59157: LIST
59158: LIST
59159: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59160: LD_VAR 0 6
59164: PPUSH
59165: CALL_OW 264
59169: PUSH
59170: LD_INT 10
59172: PUSH
59173: EMPTY
59174: LIST
59175: IN
59176: IFFALSE 59197
// points := [ 35 , 110 , 70 ] ;
59178: LD_ADDR_VAR 0 9
59182: PUSH
59183: LD_INT 35
59185: PUSH
59186: LD_INT 110
59188: PUSH
59189: LD_INT 70
59191: PUSH
59192: EMPTY
59193: LIST
59194: LIST
59195: LIST
59196: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59197: LD_VAR 0 6
59201: PPUSH
59202: CALL_OW 265
59206: PUSH
59207: LD_INT 25
59209: EQUAL
59210: IFFALSE 59231
// points := [ 80 , 65 , 100 ] ;
59212: LD_ADDR_VAR 0 9
59216: PUSH
59217: LD_INT 80
59219: PUSH
59220: LD_INT 65
59222: PUSH
59223: LD_INT 100
59225: PUSH
59226: EMPTY
59227: LIST
59228: LIST
59229: LIST
59230: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59231: LD_VAR 0 6
59235: PPUSH
59236: CALL_OW 263
59240: PUSH
59241: LD_INT 1
59243: EQUAL
59244: IFFALSE 59279
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59246: LD_ADDR_VAR 0 10
59250: PUSH
59251: LD_VAR 0 10
59255: PUSH
59256: LD_VAR 0 6
59260: PPUSH
59261: CALL_OW 311
59265: PPUSH
59266: LD_INT 3
59268: PPUSH
59269: CALL_OW 259
59273: PUSH
59274: LD_INT 4
59276: MUL
59277: MUL
59278: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59279: LD_VAR 0 6
59283: PPUSH
59284: CALL_OW 263
59288: PUSH
59289: LD_INT 2
59291: EQUAL
59292: IFFALSE 59343
// begin j := IsControledBy ( i ) ;
59294: LD_ADDR_VAR 0 7
59298: PUSH
59299: LD_VAR 0 6
59303: PPUSH
59304: CALL_OW 312
59308: ST_TO_ADDR
// if j then
59309: LD_VAR 0 7
59313: IFFALSE 59343
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59315: LD_ADDR_VAR 0 10
59319: PUSH
59320: LD_VAR 0 10
59324: PUSH
59325: LD_VAR 0 7
59329: PPUSH
59330: LD_INT 3
59332: PPUSH
59333: CALL_OW 259
59337: PUSH
59338: LD_INT 3
59340: MUL
59341: MUL
59342: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59343: LD_VAR 0 6
59347: PPUSH
59348: CALL_OW 264
59352: PUSH
59353: LD_INT 5
59355: PUSH
59356: LD_INT 6
59358: PUSH
59359: LD_INT 46
59361: PUSH
59362: LD_INT 44
59364: PUSH
59365: LD_INT 47
59367: PUSH
59368: LD_INT 45
59370: PUSH
59371: LD_INT 28
59373: PUSH
59374: LD_INT 7
59376: PUSH
59377: LD_INT 27
59379: PUSH
59380: LD_INT 29
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: LIST
59387: LIST
59388: LIST
59389: LIST
59390: LIST
59391: LIST
59392: LIST
59393: LIST
59394: IN
59395: PUSH
59396: LD_VAR 0 1
59400: PPUSH
59401: LD_INT 52
59403: PPUSH
59404: CALL_OW 321
59408: PUSH
59409: LD_INT 2
59411: EQUAL
59412: AND
59413: IFFALSE 59430
// bpoints := bpoints * 1.2 ;
59415: LD_ADDR_VAR 0 10
59419: PUSH
59420: LD_VAR 0 10
59424: PUSH
59425: LD_REAL  1.20000000000000E+0000
59428: MUL
59429: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59430: LD_VAR 0 6
59434: PPUSH
59435: CALL_OW 264
59439: PUSH
59440: LD_INT 6
59442: PUSH
59443: LD_INT 46
59445: PUSH
59446: LD_INT 47
59448: PUSH
59449: EMPTY
59450: LIST
59451: LIST
59452: LIST
59453: IN
59454: IFFALSE 59471
// bpoints := bpoints * 1.2 ;
59456: LD_ADDR_VAR 0 10
59460: PUSH
59461: LD_VAR 0 10
59465: PUSH
59466: LD_REAL  1.20000000000000E+0000
59469: MUL
59470: ST_TO_ADDR
// end ; unit_building :
59471: GO 59485
59473: LD_INT 3
59475: DOUBLE
59476: EQUAL
59477: IFTRUE 59481
59479: GO 59484
59481: POP
// ; end ;
59482: GO 59485
59484: POP
// for j = 1 to 3 do
59485: LD_ADDR_VAR 0 7
59489: PUSH
59490: DOUBLE
59491: LD_INT 1
59493: DEC
59494: ST_TO_ADDR
59495: LD_INT 3
59497: PUSH
59498: FOR_TO
59499: IFFALSE 59552
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59501: LD_ADDR_VAR 0 5
59505: PUSH
59506: LD_VAR 0 5
59510: PPUSH
59511: LD_VAR 0 7
59515: PPUSH
59516: LD_VAR 0 5
59520: PUSH
59521: LD_VAR 0 7
59525: ARRAY
59526: PUSH
59527: LD_VAR 0 9
59531: PUSH
59532: LD_VAR 0 7
59536: ARRAY
59537: PUSH
59538: LD_VAR 0 10
59542: MUL
59543: PLUS
59544: PPUSH
59545: CALL_OW 1
59549: ST_TO_ADDR
59550: GO 59498
59552: POP
59553: POP
// end ;
59554: GO 58037
59556: POP
59557: POP
// result := Replace ( result , 4 , tmp ) ;
59558: LD_ADDR_VAR 0 5
59562: PUSH
59563: LD_VAR 0 5
59567: PPUSH
59568: LD_INT 4
59570: PPUSH
59571: LD_VAR 0 8
59575: PPUSH
59576: CALL_OW 1
59580: ST_TO_ADDR
// end ;
59581: LD_VAR 0 5
59585: RET
// export function DangerAtRange ( unit , range ) ; begin
59586: LD_INT 0
59588: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59589: LD_ADDR_VAR 0 3
59593: PUSH
59594: LD_VAR 0 1
59598: PPUSH
59599: CALL_OW 255
59603: PPUSH
59604: LD_VAR 0 1
59608: PPUSH
59609: CALL_OW 250
59613: PPUSH
59614: LD_VAR 0 1
59618: PPUSH
59619: CALL_OW 251
59623: PPUSH
59624: LD_VAR 0 2
59628: PPUSH
59629: CALL 57889 0 4
59633: ST_TO_ADDR
// end ;
59634: LD_VAR 0 3
59638: RET
// export function DangerInArea ( side , area ) ; begin
59639: LD_INT 0
59641: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59642: LD_ADDR_VAR 0 3
59646: PUSH
59647: LD_VAR 0 2
59651: PPUSH
59652: LD_INT 81
59654: PUSH
59655: LD_VAR 0 1
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: PPUSH
59664: CALL_OW 70
59668: ST_TO_ADDR
// end ;
59669: LD_VAR 0 3
59673: RET
// export function IsExtension ( b ) ; begin
59674: LD_INT 0
59676: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59677: LD_ADDR_VAR 0 2
59681: PUSH
59682: LD_VAR 0 1
59686: PUSH
59687: LD_INT 23
59689: PUSH
59690: LD_INT 20
59692: PUSH
59693: LD_INT 22
59695: PUSH
59696: LD_INT 17
59698: PUSH
59699: LD_INT 24
59701: PUSH
59702: LD_INT 21
59704: PUSH
59705: LD_INT 19
59707: PUSH
59708: LD_INT 16
59710: PUSH
59711: LD_INT 25
59713: PUSH
59714: LD_INT 18
59716: PUSH
59717: EMPTY
59718: LIST
59719: LIST
59720: LIST
59721: LIST
59722: LIST
59723: LIST
59724: LIST
59725: LIST
59726: LIST
59727: LIST
59728: IN
59729: ST_TO_ADDR
// end ;
59730: LD_VAR 0 2
59734: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
59735: LD_INT 0
59737: PPUSH
59738: PPUSH
59739: PPUSH
// result := [ ] ;
59740: LD_ADDR_VAR 0 3
59744: PUSH
59745: EMPTY
59746: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59747: LD_ADDR_VAR 0 4
59751: PUSH
59752: LD_VAR 0 2
59756: PPUSH
59757: LD_INT 21
59759: PUSH
59760: LD_INT 3
59762: PUSH
59763: EMPTY
59764: LIST
59765: LIST
59766: PPUSH
59767: CALL_OW 70
59771: ST_TO_ADDR
// if not tmp then
59772: LD_VAR 0 4
59776: NOT
59777: IFFALSE 59781
// exit ;
59779: GO 59839
// for i in tmp do
59781: LD_ADDR_VAR 0 5
59785: PUSH
59786: LD_VAR 0 4
59790: PUSH
59791: FOR_IN
59792: IFFALSE 59827
// if GetBase ( i ) <> base then
59794: LD_VAR 0 5
59798: PPUSH
59799: CALL_OW 274
59803: PUSH
59804: LD_VAR 0 1
59808: NONEQUAL
59809: IFFALSE 59825
// ComLinkToBase ( base , i ) ;
59811: LD_VAR 0 1
59815: PPUSH
59816: LD_VAR 0 5
59820: PPUSH
59821: CALL_OW 169
59825: GO 59791
59827: POP
59828: POP
// result := tmp ;
59829: LD_ADDR_VAR 0 3
59833: PUSH
59834: LD_VAR 0 4
59838: ST_TO_ADDR
// end ;
59839: LD_VAR 0 3
59843: RET
// export function ComComplete ( unit , b ) ; var i ; begin
59844: LD_INT 0
59846: PPUSH
59847: PPUSH
// if BuildingStatus ( b ) = bs_build then
59848: LD_VAR 0 2
59852: PPUSH
59853: CALL_OW 461
59857: PUSH
59858: LD_INT 1
59860: EQUAL
59861: IFFALSE 59921
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59863: LD_VAR 0 1
59867: PPUSH
59868: LD_STRING h
59870: PUSH
59871: LD_VAR 0 2
59875: PPUSH
59876: CALL_OW 250
59880: PUSH
59881: LD_VAR 0 2
59885: PPUSH
59886: CALL_OW 251
59890: PUSH
59891: LD_VAR 0 2
59895: PUSH
59896: LD_INT 0
59898: PUSH
59899: LD_INT 0
59901: PUSH
59902: LD_INT 0
59904: PUSH
59905: EMPTY
59906: LIST
59907: LIST
59908: LIST
59909: LIST
59910: LIST
59911: LIST
59912: LIST
59913: PUSH
59914: EMPTY
59915: LIST
59916: PPUSH
59917: CALL_OW 446
// end ;
59921: LD_VAR 0 3
59925: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59926: LD_INT 0
59928: PPUSH
59929: PPUSH
59930: PPUSH
59931: PPUSH
59932: PPUSH
59933: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
59934: LD_VAR 0 1
59938: NOT
59939: PUSH
59940: LD_VAR 0 1
59944: PPUSH
59945: CALL_OW 263
59949: PUSH
59950: LD_INT 2
59952: EQUAL
59953: NOT
59954: OR
59955: IFFALSE 59959
// exit ;
59957: GO 60275
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59959: LD_ADDR_VAR 0 6
59963: PUSH
59964: LD_INT 22
59966: PUSH
59967: LD_VAR 0 1
59971: PPUSH
59972: CALL_OW 255
59976: PUSH
59977: EMPTY
59978: LIST
59979: LIST
59980: PUSH
59981: LD_INT 2
59983: PUSH
59984: LD_INT 30
59986: PUSH
59987: LD_INT 36
59989: PUSH
59990: EMPTY
59991: LIST
59992: LIST
59993: PUSH
59994: LD_INT 34
59996: PUSH
59997: LD_INT 31
59999: PUSH
60000: EMPTY
60001: LIST
60002: LIST
60003: PUSH
60004: EMPTY
60005: LIST
60006: LIST
60007: LIST
60008: PUSH
60009: EMPTY
60010: LIST
60011: LIST
60012: PPUSH
60013: CALL_OW 69
60017: ST_TO_ADDR
// if not tmp then
60018: LD_VAR 0 6
60022: NOT
60023: IFFALSE 60027
// exit ;
60025: GO 60275
// result := [ ] ;
60027: LD_ADDR_VAR 0 2
60031: PUSH
60032: EMPTY
60033: ST_TO_ADDR
// for i in tmp do
60034: LD_ADDR_VAR 0 3
60038: PUSH
60039: LD_VAR 0 6
60043: PUSH
60044: FOR_IN
60045: IFFALSE 60116
// begin t := UnitsInside ( i ) ;
60047: LD_ADDR_VAR 0 4
60051: PUSH
60052: LD_VAR 0 3
60056: PPUSH
60057: CALL_OW 313
60061: ST_TO_ADDR
// if t then
60062: LD_VAR 0 4
60066: IFFALSE 60114
// for j in t do
60068: LD_ADDR_VAR 0 7
60072: PUSH
60073: LD_VAR 0 4
60077: PUSH
60078: FOR_IN
60079: IFFALSE 60112
// result := Insert ( result , result + 1 , j ) ;
60081: LD_ADDR_VAR 0 2
60085: PUSH
60086: LD_VAR 0 2
60090: PPUSH
60091: LD_VAR 0 2
60095: PUSH
60096: LD_INT 1
60098: PLUS
60099: PPUSH
60100: LD_VAR 0 7
60104: PPUSH
60105: CALL_OW 2
60109: ST_TO_ADDR
60110: GO 60078
60112: POP
60113: POP
// end ;
60114: GO 60044
60116: POP
60117: POP
// if not result then
60118: LD_VAR 0 2
60122: NOT
60123: IFFALSE 60127
// exit ;
60125: GO 60275
// mech := result [ 1 ] ;
60127: LD_ADDR_VAR 0 5
60131: PUSH
60132: LD_VAR 0 2
60136: PUSH
60137: LD_INT 1
60139: ARRAY
60140: ST_TO_ADDR
// if result > 1 then
60141: LD_VAR 0 2
60145: PUSH
60146: LD_INT 1
60148: GREATER
60149: IFFALSE 60261
// for i = 2 to result do
60151: LD_ADDR_VAR 0 3
60155: PUSH
60156: DOUBLE
60157: LD_INT 2
60159: DEC
60160: ST_TO_ADDR
60161: LD_VAR 0 2
60165: PUSH
60166: FOR_TO
60167: IFFALSE 60259
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60169: LD_ADDR_VAR 0 4
60173: PUSH
60174: LD_VAR 0 2
60178: PUSH
60179: LD_VAR 0 3
60183: ARRAY
60184: PPUSH
60185: LD_INT 3
60187: PPUSH
60188: CALL_OW 259
60192: PUSH
60193: LD_VAR 0 2
60197: PUSH
60198: LD_VAR 0 3
60202: ARRAY
60203: PPUSH
60204: CALL_OW 432
60208: MINUS
60209: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60210: LD_VAR 0 4
60214: PUSH
60215: LD_VAR 0 5
60219: PPUSH
60220: LD_INT 3
60222: PPUSH
60223: CALL_OW 259
60227: PUSH
60228: LD_VAR 0 5
60232: PPUSH
60233: CALL_OW 432
60237: MINUS
60238: GREATEREQUAL
60239: IFFALSE 60257
// mech := result [ i ] ;
60241: LD_ADDR_VAR 0 5
60245: PUSH
60246: LD_VAR 0 2
60250: PUSH
60251: LD_VAR 0 3
60255: ARRAY
60256: ST_TO_ADDR
// end ;
60257: GO 60166
60259: POP
60260: POP
// ComLinkTo ( vehicle , mech ) ;
60261: LD_VAR 0 1
60265: PPUSH
60266: LD_VAR 0 5
60270: PPUSH
60271: CALL_OW 135
// end ;
60275: LD_VAR 0 2
60279: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60280: LD_INT 0
60282: PPUSH
60283: PPUSH
60284: PPUSH
60285: PPUSH
60286: PPUSH
60287: PPUSH
60288: PPUSH
60289: PPUSH
60290: PPUSH
60291: PPUSH
60292: PPUSH
60293: PPUSH
60294: PPUSH
// result := [ ] ;
60295: LD_ADDR_VAR 0 7
60299: PUSH
60300: EMPTY
60301: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60302: LD_VAR 0 1
60306: PPUSH
60307: CALL_OW 266
60311: PUSH
60312: LD_INT 0
60314: PUSH
60315: LD_INT 1
60317: PUSH
60318: EMPTY
60319: LIST
60320: LIST
60321: IN
60322: NOT
60323: IFFALSE 60327
// exit ;
60325: GO 61958
// if name then
60327: LD_VAR 0 3
60331: IFFALSE 60347
// SetBName ( base_dep , name ) ;
60333: LD_VAR 0 1
60337: PPUSH
60338: LD_VAR 0 3
60342: PPUSH
60343: CALL_OW 500
// base := GetBase ( base_dep ) ;
60347: LD_ADDR_VAR 0 15
60351: PUSH
60352: LD_VAR 0 1
60356: PPUSH
60357: CALL_OW 274
60361: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60362: LD_ADDR_VAR 0 16
60366: PUSH
60367: LD_VAR 0 1
60371: PPUSH
60372: CALL_OW 255
60376: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60377: LD_ADDR_VAR 0 17
60381: PUSH
60382: LD_VAR 0 1
60386: PPUSH
60387: CALL_OW 248
60391: ST_TO_ADDR
// if sources then
60392: LD_VAR 0 5
60396: IFFALSE 60443
// for i = 1 to 3 do
60398: LD_ADDR_VAR 0 8
60402: PUSH
60403: DOUBLE
60404: LD_INT 1
60406: DEC
60407: ST_TO_ADDR
60408: LD_INT 3
60410: PUSH
60411: FOR_TO
60412: IFFALSE 60441
// AddResourceType ( base , i , sources [ i ] ) ;
60414: LD_VAR 0 15
60418: PPUSH
60419: LD_VAR 0 8
60423: PPUSH
60424: LD_VAR 0 5
60428: PUSH
60429: LD_VAR 0 8
60433: ARRAY
60434: PPUSH
60435: CALL_OW 276
60439: GO 60411
60441: POP
60442: POP
// buildings := GetBaseBuildings ( base , area ) ;
60443: LD_ADDR_VAR 0 18
60447: PUSH
60448: LD_VAR 0 15
60452: PPUSH
60453: LD_VAR 0 2
60457: PPUSH
60458: CALL 59735 0 2
60462: ST_TO_ADDR
// InitHc ;
60463: CALL_OW 19
// InitUc ;
60467: CALL_OW 18
// uc_side := side ;
60471: LD_ADDR_OWVAR 20
60475: PUSH
60476: LD_VAR 0 16
60480: ST_TO_ADDR
// uc_nation := nation ;
60481: LD_ADDR_OWVAR 21
60485: PUSH
60486: LD_VAR 0 17
60490: ST_TO_ADDR
// if buildings then
60491: LD_VAR 0 18
60495: IFFALSE 61817
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60497: LD_ADDR_VAR 0 19
60501: PUSH
60502: LD_VAR 0 18
60506: PPUSH
60507: LD_INT 2
60509: PUSH
60510: LD_INT 30
60512: PUSH
60513: LD_INT 29
60515: PUSH
60516: EMPTY
60517: LIST
60518: LIST
60519: PUSH
60520: LD_INT 30
60522: PUSH
60523: LD_INT 30
60525: PUSH
60526: EMPTY
60527: LIST
60528: LIST
60529: PUSH
60530: EMPTY
60531: LIST
60532: LIST
60533: LIST
60534: PPUSH
60535: CALL_OW 72
60539: ST_TO_ADDR
// if tmp then
60540: LD_VAR 0 19
60544: IFFALSE 60592
// for i in tmp do
60546: LD_ADDR_VAR 0 8
60550: PUSH
60551: LD_VAR 0 19
60555: PUSH
60556: FOR_IN
60557: IFFALSE 60590
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60559: LD_VAR 0 8
60563: PPUSH
60564: CALL_OW 250
60568: PPUSH
60569: LD_VAR 0 8
60573: PPUSH
60574: CALL_OW 251
60578: PPUSH
60579: LD_VAR 0 16
60583: PPUSH
60584: CALL_OW 441
60588: GO 60556
60590: POP
60591: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60592: LD_VAR 0 18
60596: PPUSH
60597: LD_INT 2
60599: PUSH
60600: LD_INT 30
60602: PUSH
60603: LD_INT 32
60605: PUSH
60606: EMPTY
60607: LIST
60608: LIST
60609: PUSH
60610: LD_INT 30
60612: PUSH
60613: LD_INT 33
60615: PUSH
60616: EMPTY
60617: LIST
60618: LIST
60619: PUSH
60620: EMPTY
60621: LIST
60622: LIST
60623: LIST
60624: PPUSH
60625: CALL_OW 72
60629: IFFALSE 60717
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60631: LD_ADDR_VAR 0 8
60635: PUSH
60636: LD_VAR 0 18
60640: PPUSH
60641: LD_INT 2
60643: PUSH
60644: LD_INT 30
60646: PUSH
60647: LD_INT 32
60649: PUSH
60650: EMPTY
60651: LIST
60652: LIST
60653: PUSH
60654: LD_INT 30
60656: PUSH
60657: LD_INT 33
60659: PUSH
60660: EMPTY
60661: LIST
60662: LIST
60663: PUSH
60664: EMPTY
60665: LIST
60666: LIST
60667: LIST
60668: PPUSH
60669: CALL_OW 72
60673: PUSH
60674: FOR_IN
60675: IFFALSE 60715
// begin if not GetBWeapon ( i ) then
60677: LD_VAR 0 8
60681: PPUSH
60682: CALL_OW 269
60686: NOT
60687: IFFALSE 60713
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60689: LD_VAR 0 8
60693: PPUSH
60694: LD_VAR 0 8
60698: PPUSH
60699: LD_VAR 0 2
60703: PPUSH
60704: CALL 61963 0 2
60708: PPUSH
60709: CALL_OW 431
// end ;
60713: GO 60674
60715: POP
60716: POP
// end ; for i = 1 to personel do
60717: LD_ADDR_VAR 0 8
60721: PUSH
60722: DOUBLE
60723: LD_INT 1
60725: DEC
60726: ST_TO_ADDR
60727: LD_VAR 0 6
60731: PUSH
60732: FOR_TO
60733: IFFALSE 61797
// begin if i > 4 then
60735: LD_VAR 0 8
60739: PUSH
60740: LD_INT 4
60742: GREATER
60743: IFFALSE 60747
// break ;
60745: GO 61797
// case i of 1 :
60747: LD_VAR 0 8
60751: PUSH
60752: LD_INT 1
60754: DOUBLE
60755: EQUAL
60756: IFTRUE 60760
60758: GO 60840
60760: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60761: LD_ADDR_VAR 0 12
60765: PUSH
60766: LD_VAR 0 18
60770: PPUSH
60771: LD_INT 22
60773: PUSH
60774: LD_VAR 0 16
60778: PUSH
60779: EMPTY
60780: LIST
60781: LIST
60782: PUSH
60783: LD_INT 58
60785: PUSH
60786: EMPTY
60787: LIST
60788: PUSH
60789: LD_INT 2
60791: PUSH
60792: LD_INT 30
60794: PUSH
60795: LD_INT 32
60797: PUSH
60798: EMPTY
60799: LIST
60800: LIST
60801: PUSH
60802: LD_INT 30
60804: PUSH
60805: LD_INT 4
60807: PUSH
60808: EMPTY
60809: LIST
60810: LIST
60811: PUSH
60812: LD_INT 30
60814: PUSH
60815: LD_INT 5
60817: PUSH
60818: EMPTY
60819: LIST
60820: LIST
60821: PUSH
60822: EMPTY
60823: LIST
60824: LIST
60825: LIST
60826: LIST
60827: PUSH
60828: EMPTY
60829: LIST
60830: LIST
60831: LIST
60832: PPUSH
60833: CALL_OW 72
60837: ST_TO_ADDR
60838: GO 61062
60840: LD_INT 2
60842: DOUBLE
60843: EQUAL
60844: IFTRUE 60848
60846: GO 60910
60848: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60849: LD_ADDR_VAR 0 12
60853: PUSH
60854: LD_VAR 0 18
60858: PPUSH
60859: LD_INT 22
60861: PUSH
60862: LD_VAR 0 16
60866: PUSH
60867: EMPTY
60868: LIST
60869: LIST
60870: PUSH
60871: LD_INT 2
60873: PUSH
60874: LD_INT 30
60876: PUSH
60877: LD_INT 0
60879: PUSH
60880: EMPTY
60881: LIST
60882: LIST
60883: PUSH
60884: LD_INT 30
60886: PUSH
60887: LD_INT 1
60889: PUSH
60890: EMPTY
60891: LIST
60892: LIST
60893: PUSH
60894: EMPTY
60895: LIST
60896: LIST
60897: LIST
60898: PUSH
60899: EMPTY
60900: LIST
60901: LIST
60902: PPUSH
60903: CALL_OW 72
60907: ST_TO_ADDR
60908: GO 61062
60910: LD_INT 3
60912: DOUBLE
60913: EQUAL
60914: IFTRUE 60918
60916: GO 60980
60918: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60919: LD_ADDR_VAR 0 12
60923: PUSH
60924: LD_VAR 0 18
60928: PPUSH
60929: LD_INT 22
60931: PUSH
60932: LD_VAR 0 16
60936: PUSH
60937: EMPTY
60938: LIST
60939: LIST
60940: PUSH
60941: LD_INT 2
60943: PUSH
60944: LD_INT 30
60946: PUSH
60947: LD_INT 2
60949: PUSH
60950: EMPTY
60951: LIST
60952: LIST
60953: PUSH
60954: LD_INT 30
60956: PUSH
60957: LD_INT 3
60959: PUSH
60960: EMPTY
60961: LIST
60962: LIST
60963: PUSH
60964: EMPTY
60965: LIST
60966: LIST
60967: LIST
60968: PUSH
60969: EMPTY
60970: LIST
60971: LIST
60972: PPUSH
60973: CALL_OW 72
60977: ST_TO_ADDR
60978: GO 61062
60980: LD_INT 4
60982: DOUBLE
60983: EQUAL
60984: IFTRUE 60988
60986: GO 61061
60988: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60989: LD_ADDR_VAR 0 12
60993: PUSH
60994: LD_VAR 0 18
60998: PPUSH
60999: LD_INT 22
61001: PUSH
61002: LD_VAR 0 16
61006: PUSH
61007: EMPTY
61008: LIST
61009: LIST
61010: PUSH
61011: LD_INT 2
61013: PUSH
61014: LD_INT 30
61016: PUSH
61017: LD_INT 6
61019: PUSH
61020: EMPTY
61021: LIST
61022: LIST
61023: PUSH
61024: LD_INT 30
61026: PUSH
61027: LD_INT 7
61029: PUSH
61030: EMPTY
61031: LIST
61032: LIST
61033: PUSH
61034: LD_INT 30
61036: PUSH
61037: LD_INT 8
61039: PUSH
61040: EMPTY
61041: LIST
61042: LIST
61043: PUSH
61044: EMPTY
61045: LIST
61046: LIST
61047: LIST
61048: LIST
61049: PUSH
61050: EMPTY
61051: LIST
61052: LIST
61053: PPUSH
61054: CALL_OW 72
61058: ST_TO_ADDR
61059: GO 61062
61061: POP
// if i = 1 then
61062: LD_VAR 0 8
61066: PUSH
61067: LD_INT 1
61069: EQUAL
61070: IFFALSE 61181
// begin tmp := [ ] ;
61072: LD_ADDR_VAR 0 19
61076: PUSH
61077: EMPTY
61078: ST_TO_ADDR
// for j in f do
61079: LD_ADDR_VAR 0 9
61083: PUSH
61084: LD_VAR 0 12
61088: PUSH
61089: FOR_IN
61090: IFFALSE 61163
// if GetBType ( j ) = b_bunker then
61092: LD_VAR 0 9
61096: PPUSH
61097: CALL_OW 266
61101: PUSH
61102: LD_INT 32
61104: EQUAL
61105: IFFALSE 61132
// tmp := Insert ( tmp , 1 , j ) else
61107: LD_ADDR_VAR 0 19
61111: PUSH
61112: LD_VAR 0 19
61116: PPUSH
61117: LD_INT 1
61119: PPUSH
61120: LD_VAR 0 9
61124: PPUSH
61125: CALL_OW 2
61129: ST_TO_ADDR
61130: GO 61161
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61132: LD_ADDR_VAR 0 19
61136: PUSH
61137: LD_VAR 0 19
61141: PPUSH
61142: LD_VAR 0 19
61146: PUSH
61147: LD_INT 1
61149: PLUS
61150: PPUSH
61151: LD_VAR 0 9
61155: PPUSH
61156: CALL_OW 2
61160: ST_TO_ADDR
61161: GO 61089
61163: POP
61164: POP
// if tmp then
61165: LD_VAR 0 19
61169: IFFALSE 61181
// f := tmp ;
61171: LD_ADDR_VAR 0 12
61175: PUSH
61176: LD_VAR 0 19
61180: ST_TO_ADDR
// end ; x := personel [ i ] ;
61181: LD_ADDR_VAR 0 13
61185: PUSH
61186: LD_VAR 0 6
61190: PUSH
61191: LD_VAR 0 8
61195: ARRAY
61196: ST_TO_ADDR
// if x = - 1 then
61197: LD_VAR 0 13
61201: PUSH
61202: LD_INT 1
61204: NEG
61205: EQUAL
61206: IFFALSE 61415
// begin for j in f do
61208: LD_ADDR_VAR 0 9
61212: PUSH
61213: LD_VAR 0 12
61217: PUSH
61218: FOR_IN
61219: IFFALSE 61411
// repeat InitHc ;
61221: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61225: LD_VAR 0 9
61229: PPUSH
61230: CALL_OW 266
61234: PUSH
61235: LD_INT 5
61237: EQUAL
61238: IFFALSE 61308
// begin if UnitsInside ( j ) < 3 then
61240: LD_VAR 0 9
61244: PPUSH
61245: CALL_OW 313
61249: PUSH
61250: LD_INT 3
61252: LESS
61253: IFFALSE 61289
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61255: LD_INT 0
61257: PPUSH
61258: LD_INT 5
61260: PUSH
61261: LD_INT 8
61263: PUSH
61264: LD_INT 9
61266: PUSH
61267: EMPTY
61268: LIST
61269: LIST
61270: LIST
61271: PUSH
61272: LD_VAR 0 17
61276: ARRAY
61277: PPUSH
61278: LD_VAR 0 4
61282: PPUSH
61283: CALL_OW 380
61287: GO 61306
// PrepareHuman ( false , i , skill ) ;
61289: LD_INT 0
61291: PPUSH
61292: LD_VAR 0 8
61296: PPUSH
61297: LD_VAR 0 4
61301: PPUSH
61302: CALL_OW 380
// end else
61306: GO 61325
// PrepareHuman ( false , i , skill ) ;
61308: LD_INT 0
61310: PPUSH
61311: LD_VAR 0 8
61315: PPUSH
61316: LD_VAR 0 4
61320: PPUSH
61321: CALL_OW 380
// un := CreateHuman ;
61325: LD_ADDR_VAR 0 14
61329: PUSH
61330: CALL_OW 44
61334: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61335: LD_ADDR_VAR 0 7
61339: PUSH
61340: LD_VAR 0 7
61344: PPUSH
61345: LD_INT 1
61347: PPUSH
61348: LD_VAR 0 14
61352: PPUSH
61353: CALL_OW 2
61357: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61358: LD_VAR 0 14
61362: PPUSH
61363: LD_VAR 0 9
61367: PPUSH
61368: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61372: LD_VAR 0 9
61376: PPUSH
61377: CALL_OW 313
61381: PUSH
61382: LD_INT 6
61384: EQUAL
61385: PUSH
61386: LD_VAR 0 9
61390: PPUSH
61391: CALL_OW 266
61395: PUSH
61396: LD_INT 32
61398: PUSH
61399: LD_INT 31
61401: PUSH
61402: EMPTY
61403: LIST
61404: LIST
61405: IN
61406: OR
61407: IFFALSE 61221
61409: GO 61218
61411: POP
61412: POP
// end else
61413: GO 61795
// for j = 1 to x do
61415: LD_ADDR_VAR 0 9
61419: PUSH
61420: DOUBLE
61421: LD_INT 1
61423: DEC
61424: ST_TO_ADDR
61425: LD_VAR 0 13
61429: PUSH
61430: FOR_TO
61431: IFFALSE 61793
// begin InitHc ;
61433: CALL_OW 19
// if not f then
61437: LD_VAR 0 12
61441: NOT
61442: IFFALSE 61531
// begin PrepareHuman ( false , i , skill ) ;
61444: LD_INT 0
61446: PPUSH
61447: LD_VAR 0 8
61451: PPUSH
61452: LD_VAR 0 4
61456: PPUSH
61457: CALL_OW 380
// un := CreateHuman ;
61461: LD_ADDR_VAR 0 14
61465: PUSH
61466: CALL_OW 44
61470: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61471: LD_ADDR_VAR 0 7
61475: PUSH
61476: LD_VAR 0 7
61480: PPUSH
61481: LD_INT 1
61483: PPUSH
61484: LD_VAR 0 14
61488: PPUSH
61489: CALL_OW 2
61493: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61494: LD_VAR 0 14
61498: PPUSH
61499: LD_VAR 0 1
61503: PPUSH
61504: CALL_OW 250
61508: PPUSH
61509: LD_VAR 0 1
61513: PPUSH
61514: CALL_OW 251
61518: PPUSH
61519: LD_INT 10
61521: PPUSH
61522: LD_INT 0
61524: PPUSH
61525: CALL_OW 50
// continue ;
61529: GO 61430
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61531: LD_VAR 0 12
61535: PUSH
61536: LD_INT 1
61538: ARRAY
61539: PPUSH
61540: CALL_OW 313
61544: PUSH
61545: LD_VAR 0 12
61549: PUSH
61550: LD_INT 1
61552: ARRAY
61553: PPUSH
61554: CALL_OW 266
61558: PUSH
61559: LD_INT 32
61561: PUSH
61562: LD_INT 31
61564: PUSH
61565: EMPTY
61566: LIST
61567: LIST
61568: IN
61569: AND
61570: PUSH
61571: LD_VAR 0 12
61575: PUSH
61576: LD_INT 1
61578: ARRAY
61579: PPUSH
61580: CALL_OW 313
61584: PUSH
61585: LD_INT 6
61587: EQUAL
61588: OR
61589: IFFALSE 61609
// f := Delete ( f , 1 ) ;
61591: LD_ADDR_VAR 0 12
61595: PUSH
61596: LD_VAR 0 12
61600: PPUSH
61601: LD_INT 1
61603: PPUSH
61604: CALL_OW 3
61608: ST_TO_ADDR
// if not f then
61609: LD_VAR 0 12
61613: NOT
61614: IFFALSE 61632
// begin x := x + 2 ;
61616: LD_ADDR_VAR 0 13
61620: PUSH
61621: LD_VAR 0 13
61625: PUSH
61626: LD_INT 2
61628: PLUS
61629: ST_TO_ADDR
// continue ;
61630: GO 61430
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61632: LD_VAR 0 12
61636: PUSH
61637: LD_INT 1
61639: ARRAY
61640: PPUSH
61641: CALL_OW 266
61645: PUSH
61646: LD_INT 5
61648: EQUAL
61649: IFFALSE 61723
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61651: LD_VAR 0 12
61655: PUSH
61656: LD_INT 1
61658: ARRAY
61659: PPUSH
61660: CALL_OW 313
61664: PUSH
61665: LD_INT 3
61667: LESS
61668: IFFALSE 61704
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61670: LD_INT 0
61672: PPUSH
61673: LD_INT 5
61675: PUSH
61676: LD_INT 8
61678: PUSH
61679: LD_INT 9
61681: PUSH
61682: EMPTY
61683: LIST
61684: LIST
61685: LIST
61686: PUSH
61687: LD_VAR 0 17
61691: ARRAY
61692: PPUSH
61693: LD_VAR 0 4
61697: PPUSH
61698: CALL_OW 380
61702: GO 61721
// PrepareHuman ( false , i , skill ) ;
61704: LD_INT 0
61706: PPUSH
61707: LD_VAR 0 8
61711: PPUSH
61712: LD_VAR 0 4
61716: PPUSH
61717: CALL_OW 380
// end else
61721: GO 61740
// PrepareHuman ( false , i , skill ) ;
61723: LD_INT 0
61725: PPUSH
61726: LD_VAR 0 8
61730: PPUSH
61731: LD_VAR 0 4
61735: PPUSH
61736: CALL_OW 380
// un := CreateHuman ;
61740: LD_ADDR_VAR 0 14
61744: PUSH
61745: CALL_OW 44
61749: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61750: LD_ADDR_VAR 0 7
61754: PUSH
61755: LD_VAR 0 7
61759: PPUSH
61760: LD_INT 1
61762: PPUSH
61763: LD_VAR 0 14
61767: PPUSH
61768: CALL_OW 2
61772: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61773: LD_VAR 0 14
61777: PPUSH
61778: LD_VAR 0 12
61782: PUSH
61783: LD_INT 1
61785: ARRAY
61786: PPUSH
61787: CALL_OW 52
// end ;
61791: GO 61430
61793: POP
61794: POP
// end ;
61795: GO 60732
61797: POP
61798: POP
// result := result ^ buildings ;
61799: LD_ADDR_VAR 0 7
61803: PUSH
61804: LD_VAR 0 7
61808: PUSH
61809: LD_VAR 0 18
61813: ADD
61814: ST_TO_ADDR
// end else
61815: GO 61958
// begin for i = 1 to personel do
61817: LD_ADDR_VAR 0 8
61821: PUSH
61822: DOUBLE
61823: LD_INT 1
61825: DEC
61826: ST_TO_ADDR
61827: LD_VAR 0 6
61831: PUSH
61832: FOR_TO
61833: IFFALSE 61956
// begin if i > 4 then
61835: LD_VAR 0 8
61839: PUSH
61840: LD_INT 4
61842: GREATER
61843: IFFALSE 61847
// break ;
61845: GO 61956
// x := personel [ i ] ;
61847: LD_ADDR_VAR 0 13
61851: PUSH
61852: LD_VAR 0 6
61856: PUSH
61857: LD_VAR 0 8
61861: ARRAY
61862: ST_TO_ADDR
// if x = - 1 then
61863: LD_VAR 0 13
61867: PUSH
61868: LD_INT 1
61870: NEG
61871: EQUAL
61872: IFFALSE 61876
// continue ;
61874: GO 61832
// PrepareHuman ( false , i , skill ) ;
61876: LD_INT 0
61878: PPUSH
61879: LD_VAR 0 8
61883: PPUSH
61884: LD_VAR 0 4
61888: PPUSH
61889: CALL_OW 380
// un := CreateHuman ;
61893: LD_ADDR_VAR 0 14
61897: PUSH
61898: CALL_OW 44
61902: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61903: LD_VAR 0 14
61907: PPUSH
61908: LD_VAR 0 1
61912: PPUSH
61913: CALL_OW 250
61917: PPUSH
61918: LD_VAR 0 1
61922: PPUSH
61923: CALL_OW 251
61927: PPUSH
61928: LD_INT 10
61930: PPUSH
61931: LD_INT 0
61933: PPUSH
61934: CALL_OW 50
// result := result ^ un ;
61938: LD_ADDR_VAR 0 7
61942: PUSH
61943: LD_VAR 0 7
61947: PUSH
61948: LD_VAR 0 14
61952: ADD
61953: ST_TO_ADDR
// end ;
61954: GO 61832
61956: POP
61957: POP
// end ; end ;
61958: LD_VAR 0 7
61962: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61963: LD_INT 0
61965: PPUSH
61966: PPUSH
61967: PPUSH
61968: PPUSH
61969: PPUSH
61970: PPUSH
61971: PPUSH
61972: PPUSH
61973: PPUSH
61974: PPUSH
61975: PPUSH
61976: PPUSH
61977: PPUSH
61978: PPUSH
61979: PPUSH
61980: PPUSH
// result := false ;
61981: LD_ADDR_VAR 0 3
61985: PUSH
61986: LD_INT 0
61988: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61989: LD_VAR 0 1
61993: NOT
61994: PUSH
61995: LD_VAR 0 1
61999: PPUSH
62000: CALL_OW 266
62004: PUSH
62005: LD_INT 32
62007: PUSH
62008: LD_INT 33
62010: PUSH
62011: EMPTY
62012: LIST
62013: LIST
62014: IN
62015: NOT
62016: OR
62017: IFFALSE 62021
// exit ;
62019: GO 63157
// nat := GetNation ( tower ) ;
62021: LD_ADDR_VAR 0 12
62025: PUSH
62026: LD_VAR 0 1
62030: PPUSH
62031: CALL_OW 248
62035: ST_TO_ADDR
// side := GetSide ( tower ) ;
62036: LD_ADDR_VAR 0 16
62040: PUSH
62041: LD_VAR 0 1
62045: PPUSH
62046: CALL_OW 255
62050: ST_TO_ADDR
// x := GetX ( tower ) ;
62051: LD_ADDR_VAR 0 10
62055: PUSH
62056: LD_VAR 0 1
62060: PPUSH
62061: CALL_OW 250
62065: ST_TO_ADDR
// y := GetY ( tower ) ;
62066: LD_ADDR_VAR 0 11
62070: PUSH
62071: LD_VAR 0 1
62075: PPUSH
62076: CALL_OW 251
62080: ST_TO_ADDR
// if not x or not y then
62081: LD_VAR 0 10
62085: NOT
62086: PUSH
62087: LD_VAR 0 11
62091: NOT
62092: OR
62093: IFFALSE 62097
// exit ;
62095: GO 63157
// weapon := 0 ;
62097: LD_ADDR_VAR 0 18
62101: PUSH
62102: LD_INT 0
62104: ST_TO_ADDR
// fac_list := [ ] ;
62105: LD_ADDR_VAR 0 17
62109: PUSH
62110: EMPTY
62111: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62112: LD_ADDR_VAR 0 6
62116: PUSH
62117: LD_VAR 0 1
62121: PPUSH
62122: CALL_OW 274
62126: PPUSH
62127: LD_VAR 0 2
62131: PPUSH
62132: CALL 59735 0 2
62136: PPUSH
62137: LD_INT 30
62139: PUSH
62140: LD_INT 3
62142: PUSH
62143: EMPTY
62144: LIST
62145: LIST
62146: PPUSH
62147: CALL_OW 72
62151: ST_TO_ADDR
// if not factories then
62152: LD_VAR 0 6
62156: NOT
62157: IFFALSE 62161
// exit ;
62159: GO 63157
// for i in factories do
62161: LD_ADDR_VAR 0 8
62165: PUSH
62166: LD_VAR 0 6
62170: PUSH
62171: FOR_IN
62172: IFFALSE 62197
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62174: LD_ADDR_VAR 0 17
62178: PUSH
62179: LD_VAR 0 17
62183: PUSH
62184: LD_VAR 0 8
62188: PPUSH
62189: CALL_OW 478
62193: UNION
62194: ST_TO_ADDR
62195: GO 62171
62197: POP
62198: POP
// if not fac_list then
62199: LD_VAR 0 17
62203: NOT
62204: IFFALSE 62208
// exit ;
62206: GO 63157
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62208: LD_ADDR_VAR 0 5
62212: PUSH
62213: LD_INT 4
62215: PUSH
62216: LD_INT 5
62218: PUSH
62219: LD_INT 9
62221: PUSH
62222: LD_INT 10
62224: PUSH
62225: LD_INT 6
62227: PUSH
62228: LD_INT 7
62230: PUSH
62231: LD_INT 11
62233: PUSH
62234: EMPTY
62235: LIST
62236: LIST
62237: LIST
62238: LIST
62239: LIST
62240: LIST
62241: LIST
62242: PUSH
62243: LD_INT 27
62245: PUSH
62246: LD_INT 28
62248: PUSH
62249: LD_INT 26
62251: PUSH
62252: LD_INT 30
62254: PUSH
62255: EMPTY
62256: LIST
62257: LIST
62258: LIST
62259: LIST
62260: PUSH
62261: LD_INT 43
62263: PUSH
62264: LD_INT 44
62266: PUSH
62267: LD_INT 46
62269: PUSH
62270: LD_INT 45
62272: PUSH
62273: LD_INT 47
62275: PUSH
62276: LD_INT 49
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: LIST
62283: LIST
62284: LIST
62285: LIST
62286: PUSH
62287: EMPTY
62288: LIST
62289: LIST
62290: LIST
62291: PUSH
62292: LD_VAR 0 12
62296: ARRAY
62297: ST_TO_ADDR
// for i in list do
62298: LD_ADDR_VAR 0 8
62302: PUSH
62303: LD_VAR 0 5
62307: PUSH
62308: FOR_IN
62309: IFFALSE 62342
// if not i in fac_list then
62311: LD_VAR 0 8
62315: PUSH
62316: LD_VAR 0 17
62320: IN
62321: NOT
62322: IFFALSE 62340
// list := list diff i ;
62324: LD_ADDR_VAR 0 5
62328: PUSH
62329: LD_VAR 0 5
62333: PUSH
62334: LD_VAR 0 8
62338: DIFF
62339: ST_TO_ADDR
62340: GO 62308
62342: POP
62343: POP
// if not list then
62344: LD_VAR 0 5
62348: NOT
62349: IFFALSE 62353
// exit ;
62351: GO 63157
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62353: LD_VAR 0 12
62357: PUSH
62358: LD_INT 3
62360: EQUAL
62361: PUSH
62362: LD_INT 49
62364: PUSH
62365: LD_VAR 0 5
62369: IN
62370: AND
62371: PUSH
62372: LD_INT 31
62374: PPUSH
62375: LD_VAR 0 16
62379: PPUSH
62380: CALL_OW 321
62384: PUSH
62385: LD_INT 2
62387: EQUAL
62388: AND
62389: IFFALSE 62449
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62391: LD_INT 22
62393: PUSH
62394: LD_VAR 0 16
62398: PUSH
62399: EMPTY
62400: LIST
62401: LIST
62402: PUSH
62403: LD_INT 35
62405: PUSH
62406: LD_INT 49
62408: PUSH
62409: EMPTY
62410: LIST
62411: LIST
62412: PUSH
62413: LD_INT 91
62415: PUSH
62416: LD_VAR 0 1
62420: PUSH
62421: LD_INT 10
62423: PUSH
62424: EMPTY
62425: LIST
62426: LIST
62427: LIST
62428: PUSH
62429: EMPTY
62430: LIST
62431: LIST
62432: LIST
62433: PPUSH
62434: CALL_OW 69
62438: NOT
62439: IFFALSE 62449
// weapon := ru_time_lapser ;
62441: LD_ADDR_VAR 0 18
62445: PUSH
62446: LD_INT 49
62448: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62449: LD_VAR 0 12
62453: PUSH
62454: LD_INT 1
62456: PUSH
62457: LD_INT 2
62459: PUSH
62460: EMPTY
62461: LIST
62462: LIST
62463: IN
62464: PUSH
62465: LD_INT 11
62467: PUSH
62468: LD_VAR 0 5
62472: IN
62473: PUSH
62474: LD_INT 30
62476: PUSH
62477: LD_VAR 0 5
62481: IN
62482: OR
62483: AND
62484: PUSH
62485: LD_INT 6
62487: PPUSH
62488: LD_VAR 0 16
62492: PPUSH
62493: CALL_OW 321
62497: PUSH
62498: LD_INT 2
62500: EQUAL
62501: AND
62502: IFFALSE 62667
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62504: LD_INT 22
62506: PUSH
62507: LD_VAR 0 16
62511: PUSH
62512: EMPTY
62513: LIST
62514: LIST
62515: PUSH
62516: LD_INT 2
62518: PUSH
62519: LD_INT 35
62521: PUSH
62522: LD_INT 11
62524: PUSH
62525: EMPTY
62526: LIST
62527: LIST
62528: PUSH
62529: LD_INT 35
62531: PUSH
62532: LD_INT 30
62534: PUSH
62535: EMPTY
62536: LIST
62537: LIST
62538: PUSH
62539: EMPTY
62540: LIST
62541: LIST
62542: LIST
62543: PUSH
62544: LD_INT 91
62546: PUSH
62547: LD_VAR 0 1
62551: PUSH
62552: LD_INT 18
62554: PUSH
62555: EMPTY
62556: LIST
62557: LIST
62558: LIST
62559: PUSH
62560: EMPTY
62561: LIST
62562: LIST
62563: LIST
62564: PPUSH
62565: CALL_OW 69
62569: NOT
62570: PUSH
62571: LD_INT 22
62573: PUSH
62574: LD_VAR 0 16
62578: PUSH
62579: EMPTY
62580: LIST
62581: LIST
62582: PUSH
62583: LD_INT 2
62585: PUSH
62586: LD_INT 30
62588: PUSH
62589: LD_INT 32
62591: PUSH
62592: EMPTY
62593: LIST
62594: LIST
62595: PUSH
62596: LD_INT 30
62598: PUSH
62599: LD_INT 33
62601: PUSH
62602: EMPTY
62603: LIST
62604: LIST
62605: PUSH
62606: EMPTY
62607: LIST
62608: LIST
62609: LIST
62610: PUSH
62611: LD_INT 91
62613: PUSH
62614: LD_VAR 0 1
62618: PUSH
62619: LD_INT 12
62621: PUSH
62622: EMPTY
62623: LIST
62624: LIST
62625: LIST
62626: PUSH
62627: EMPTY
62628: LIST
62629: LIST
62630: LIST
62631: PUSH
62632: EMPTY
62633: LIST
62634: PPUSH
62635: CALL_OW 69
62639: PUSH
62640: LD_INT 2
62642: GREATER
62643: AND
62644: IFFALSE 62667
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62646: LD_ADDR_VAR 0 18
62650: PUSH
62651: LD_INT 11
62653: PUSH
62654: LD_INT 30
62656: PUSH
62657: EMPTY
62658: LIST
62659: LIST
62660: PUSH
62661: LD_VAR 0 12
62665: ARRAY
62666: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62667: LD_VAR 0 18
62671: NOT
62672: PUSH
62673: LD_INT 40
62675: PPUSH
62676: LD_VAR 0 16
62680: PPUSH
62681: CALL_OW 321
62685: PUSH
62686: LD_INT 2
62688: EQUAL
62689: AND
62690: PUSH
62691: LD_INT 7
62693: PUSH
62694: LD_VAR 0 5
62698: IN
62699: PUSH
62700: LD_INT 28
62702: PUSH
62703: LD_VAR 0 5
62707: IN
62708: OR
62709: PUSH
62710: LD_INT 45
62712: PUSH
62713: LD_VAR 0 5
62717: IN
62718: OR
62719: AND
62720: IFFALSE 62974
// begin hex := GetHexInfo ( x , y ) ;
62722: LD_ADDR_VAR 0 4
62726: PUSH
62727: LD_VAR 0 10
62731: PPUSH
62732: LD_VAR 0 11
62736: PPUSH
62737: CALL_OW 546
62741: ST_TO_ADDR
// if hex [ 1 ] then
62742: LD_VAR 0 4
62746: PUSH
62747: LD_INT 1
62749: ARRAY
62750: IFFALSE 62754
// exit ;
62752: GO 63157
// height := hex [ 2 ] ;
62754: LD_ADDR_VAR 0 15
62758: PUSH
62759: LD_VAR 0 4
62763: PUSH
62764: LD_INT 2
62766: ARRAY
62767: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62768: LD_ADDR_VAR 0 14
62772: PUSH
62773: LD_INT 0
62775: PUSH
62776: LD_INT 2
62778: PUSH
62779: LD_INT 3
62781: PUSH
62782: LD_INT 5
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: LIST
62789: LIST
62790: ST_TO_ADDR
// for i in tmp do
62791: LD_ADDR_VAR 0 8
62795: PUSH
62796: LD_VAR 0 14
62800: PUSH
62801: FOR_IN
62802: IFFALSE 62972
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62804: LD_ADDR_VAR 0 9
62808: PUSH
62809: LD_VAR 0 10
62813: PPUSH
62814: LD_VAR 0 8
62818: PPUSH
62819: LD_INT 5
62821: PPUSH
62822: CALL_OW 272
62826: PUSH
62827: LD_VAR 0 11
62831: PPUSH
62832: LD_VAR 0 8
62836: PPUSH
62837: LD_INT 5
62839: PPUSH
62840: CALL_OW 273
62844: PUSH
62845: EMPTY
62846: LIST
62847: LIST
62848: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62849: LD_VAR 0 9
62853: PUSH
62854: LD_INT 1
62856: ARRAY
62857: PPUSH
62858: LD_VAR 0 9
62862: PUSH
62863: LD_INT 2
62865: ARRAY
62866: PPUSH
62867: CALL_OW 488
62871: IFFALSE 62970
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62873: LD_ADDR_VAR 0 4
62877: PUSH
62878: LD_VAR 0 9
62882: PUSH
62883: LD_INT 1
62885: ARRAY
62886: PPUSH
62887: LD_VAR 0 9
62891: PUSH
62892: LD_INT 2
62894: ARRAY
62895: PPUSH
62896: CALL_OW 546
62900: ST_TO_ADDR
// if hex [ 1 ] then
62901: LD_VAR 0 4
62905: PUSH
62906: LD_INT 1
62908: ARRAY
62909: IFFALSE 62913
// continue ;
62911: GO 62801
// h := hex [ 2 ] ;
62913: LD_ADDR_VAR 0 13
62917: PUSH
62918: LD_VAR 0 4
62922: PUSH
62923: LD_INT 2
62925: ARRAY
62926: ST_TO_ADDR
// if h + 7 < height then
62927: LD_VAR 0 13
62931: PUSH
62932: LD_INT 7
62934: PLUS
62935: PUSH
62936: LD_VAR 0 15
62940: LESS
62941: IFFALSE 62970
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62943: LD_ADDR_VAR 0 18
62947: PUSH
62948: LD_INT 7
62950: PUSH
62951: LD_INT 28
62953: PUSH
62954: LD_INT 45
62956: PUSH
62957: EMPTY
62958: LIST
62959: LIST
62960: LIST
62961: PUSH
62962: LD_VAR 0 12
62966: ARRAY
62967: ST_TO_ADDR
// break ;
62968: GO 62972
// end ; end ; end ;
62970: GO 62801
62972: POP
62973: POP
// end ; if not weapon then
62974: LD_VAR 0 18
62978: NOT
62979: IFFALSE 63039
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62981: LD_ADDR_VAR 0 5
62985: PUSH
62986: LD_VAR 0 5
62990: PUSH
62991: LD_INT 11
62993: PUSH
62994: LD_INT 30
62996: PUSH
62997: LD_INT 49
62999: PUSH
63000: EMPTY
63001: LIST
63002: LIST
63003: LIST
63004: DIFF
63005: ST_TO_ADDR
// if not list then
63006: LD_VAR 0 5
63010: NOT
63011: IFFALSE 63015
// exit ;
63013: GO 63157
// weapon := list [ rand ( 1 , list ) ] ;
63015: LD_ADDR_VAR 0 18
63019: PUSH
63020: LD_VAR 0 5
63024: PUSH
63025: LD_INT 1
63027: PPUSH
63028: LD_VAR 0 5
63032: PPUSH
63033: CALL_OW 12
63037: ARRAY
63038: ST_TO_ADDR
// end ; if weapon then
63039: LD_VAR 0 18
63043: IFFALSE 63157
// begin tmp := CostOfWeapon ( weapon ) ;
63045: LD_ADDR_VAR 0 14
63049: PUSH
63050: LD_VAR 0 18
63054: PPUSH
63055: CALL_OW 451
63059: ST_TO_ADDR
// j := GetBase ( tower ) ;
63060: LD_ADDR_VAR 0 9
63064: PUSH
63065: LD_VAR 0 1
63069: PPUSH
63070: CALL_OW 274
63074: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63075: LD_VAR 0 9
63079: PPUSH
63080: LD_INT 1
63082: PPUSH
63083: CALL_OW 275
63087: PUSH
63088: LD_VAR 0 14
63092: PUSH
63093: LD_INT 1
63095: ARRAY
63096: GREATEREQUAL
63097: PUSH
63098: LD_VAR 0 9
63102: PPUSH
63103: LD_INT 2
63105: PPUSH
63106: CALL_OW 275
63110: PUSH
63111: LD_VAR 0 14
63115: PUSH
63116: LD_INT 2
63118: ARRAY
63119: GREATEREQUAL
63120: AND
63121: PUSH
63122: LD_VAR 0 9
63126: PPUSH
63127: LD_INT 3
63129: PPUSH
63130: CALL_OW 275
63134: PUSH
63135: LD_VAR 0 14
63139: PUSH
63140: LD_INT 3
63142: ARRAY
63143: GREATEREQUAL
63144: AND
63145: IFFALSE 63157
// result := weapon ;
63147: LD_ADDR_VAR 0 3
63151: PUSH
63152: LD_VAR 0 18
63156: ST_TO_ADDR
// end ; end ;
63157: LD_VAR 0 3
63161: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63162: LD_INT 0
63164: PPUSH
63165: PPUSH
// result := true ;
63166: LD_ADDR_VAR 0 3
63170: PUSH
63171: LD_INT 1
63173: ST_TO_ADDR
// if array1 = array2 then
63174: LD_VAR 0 1
63178: PUSH
63179: LD_VAR 0 2
63183: EQUAL
63184: IFFALSE 63244
// begin for i = 1 to array1 do
63186: LD_ADDR_VAR 0 4
63190: PUSH
63191: DOUBLE
63192: LD_INT 1
63194: DEC
63195: ST_TO_ADDR
63196: LD_VAR 0 1
63200: PUSH
63201: FOR_TO
63202: IFFALSE 63240
// if array1 [ i ] <> array2 [ i ] then
63204: LD_VAR 0 1
63208: PUSH
63209: LD_VAR 0 4
63213: ARRAY
63214: PUSH
63215: LD_VAR 0 2
63219: PUSH
63220: LD_VAR 0 4
63224: ARRAY
63225: NONEQUAL
63226: IFFALSE 63238
// begin result := false ;
63228: LD_ADDR_VAR 0 3
63232: PUSH
63233: LD_INT 0
63235: ST_TO_ADDR
// break ;
63236: GO 63240
// end ;
63238: GO 63201
63240: POP
63241: POP
// end else
63242: GO 63252
// result := false ;
63244: LD_ADDR_VAR 0 3
63248: PUSH
63249: LD_INT 0
63251: ST_TO_ADDR
// end ;
63252: LD_VAR 0 3
63256: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63257: LD_INT 0
63259: PPUSH
63260: PPUSH
63261: PPUSH
// pom := GetBase ( fac ) ;
63262: LD_ADDR_VAR 0 5
63266: PUSH
63267: LD_VAR 0 1
63271: PPUSH
63272: CALL_OW 274
63276: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63277: LD_ADDR_VAR 0 4
63281: PUSH
63282: LD_VAR 0 2
63286: PUSH
63287: LD_INT 1
63289: ARRAY
63290: PPUSH
63291: LD_VAR 0 2
63295: PUSH
63296: LD_INT 2
63298: ARRAY
63299: PPUSH
63300: LD_VAR 0 2
63304: PUSH
63305: LD_INT 3
63307: ARRAY
63308: PPUSH
63309: LD_VAR 0 2
63313: PUSH
63314: LD_INT 4
63316: ARRAY
63317: PPUSH
63318: CALL_OW 449
63322: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63323: LD_ADDR_VAR 0 3
63327: PUSH
63328: LD_VAR 0 5
63332: PPUSH
63333: LD_INT 1
63335: PPUSH
63336: CALL_OW 275
63340: PUSH
63341: LD_VAR 0 4
63345: PUSH
63346: LD_INT 1
63348: ARRAY
63349: GREATEREQUAL
63350: PUSH
63351: LD_VAR 0 5
63355: PPUSH
63356: LD_INT 2
63358: PPUSH
63359: CALL_OW 275
63363: PUSH
63364: LD_VAR 0 4
63368: PUSH
63369: LD_INT 2
63371: ARRAY
63372: GREATEREQUAL
63373: AND
63374: PUSH
63375: LD_VAR 0 5
63379: PPUSH
63380: LD_INT 3
63382: PPUSH
63383: CALL_OW 275
63387: PUSH
63388: LD_VAR 0 4
63392: PUSH
63393: LD_INT 3
63395: ARRAY
63396: GREATEREQUAL
63397: AND
63398: ST_TO_ADDR
// end ;
63399: LD_VAR 0 3
63403: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63404: LD_INT 0
63406: PPUSH
63407: PPUSH
63408: PPUSH
63409: PPUSH
// pom := GetBase ( building ) ;
63410: LD_ADDR_VAR 0 3
63414: PUSH
63415: LD_VAR 0 1
63419: PPUSH
63420: CALL_OW 274
63424: ST_TO_ADDR
// if not pom then
63425: LD_VAR 0 3
63429: NOT
63430: IFFALSE 63434
// exit ;
63432: GO 63604
// btype := GetBType ( building ) ;
63434: LD_ADDR_VAR 0 5
63438: PUSH
63439: LD_VAR 0 1
63443: PPUSH
63444: CALL_OW 266
63448: ST_TO_ADDR
// if btype = b_armoury then
63449: LD_VAR 0 5
63453: PUSH
63454: LD_INT 4
63456: EQUAL
63457: IFFALSE 63467
// btype := b_barracks ;
63459: LD_ADDR_VAR 0 5
63463: PUSH
63464: LD_INT 5
63466: ST_TO_ADDR
// if btype = b_depot then
63467: LD_VAR 0 5
63471: PUSH
63472: LD_INT 0
63474: EQUAL
63475: IFFALSE 63485
// btype := b_warehouse ;
63477: LD_ADDR_VAR 0 5
63481: PUSH
63482: LD_INT 1
63484: ST_TO_ADDR
// if btype = b_workshop then
63485: LD_VAR 0 5
63489: PUSH
63490: LD_INT 2
63492: EQUAL
63493: IFFALSE 63503
// btype := b_factory ;
63495: LD_ADDR_VAR 0 5
63499: PUSH
63500: LD_INT 3
63502: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63503: LD_ADDR_VAR 0 4
63507: PUSH
63508: LD_VAR 0 5
63512: PPUSH
63513: LD_VAR 0 1
63517: PPUSH
63518: CALL_OW 248
63522: PPUSH
63523: CALL_OW 450
63527: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63528: LD_ADDR_VAR 0 2
63532: PUSH
63533: LD_VAR 0 3
63537: PPUSH
63538: LD_INT 1
63540: PPUSH
63541: CALL_OW 275
63545: PUSH
63546: LD_VAR 0 4
63550: PUSH
63551: LD_INT 1
63553: ARRAY
63554: GREATEREQUAL
63555: PUSH
63556: LD_VAR 0 3
63560: PPUSH
63561: LD_INT 2
63563: PPUSH
63564: CALL_OW 275
63568: PUSH
63569: LD_VAR 0 4
63573: PUSH
63574: LD_INT 2
63576: ARRAY
63577: GREATEREQUAL
63578: AND
63579: PUSH
63580: LD_VAR 0 3
63584: PPUSH
63585: LD_INT 3
63587: PPUSH
63588: CALL_OW 275
63592: PUSH
63593: LD_VAR 0 4
63597: PUSH
63598: LD_INT 3
63600: ARRAY
63601: GREATEREQUAL
63602: AND
63603: ST_TO_ADDR
// end ;
63604: LD_VAR 0 2
63608: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63609: LD_INT 0
63611: PPUSH
63612: PPUSH
63613: PPUSH
// pom := GetBase ( building ) ;
63614: LD_ADDR_VAR 0 4
63618: PUSH
63619: LD_VAR 0 1
63623: PPUSH
63624: CALL_OW 274
63628: ST_TO_ADDR
// if not pom then
63629: LD_VAR 0 4
63633: NOT
63634: IFFALSE 63638
// exit ;
63636: GO 63739
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63638: LD_ADDR_VAR 0 5
63642: PUSH
63643: LD_VAR 0 2
63647: PPUSH
63648: LD_VAR 0 1
63652: PPUSH
63653: CALL_OW 248
63657: PPUSH
63658: CALL_OW 450
63662: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63663: LD_ADDR_VAR 0 3
63667: PUSH
63668: LD_VAR 0 4
63672: PPUSH
63673: LD_INT 1
63675: PPUSH
63676: CALL_OW 275
63680: PUSH
63681: LD_VAR 0 5
63685: PUSH
63686: LD_INT 1
63688: ARRAY
63689: GREATEREQUAL
63690: PUSH
63691: LD_VAR 0 4
63695: PPUSH
63696: LD_INT 2
63698: PPUSH
63699: CALL_OW 275
63703: PUSH
63704: LD_VAR 0 5
63708: PUSH
63709: LD_INT 2
63711: ARRAY
63712: GREATEREQUAL
63713: AND
63714: PUSH
63715: LD_VAR 0 4
63719: PPUSH
63720: LD_INT 3
63722: PPUSH
63723: CALL_OW 275
63727: PUSH
63728: LD_VAR 0 5
63732: PUSH
63733: LD_INT 3
63735: ARRAY
63736: GREATEREQUAL
63737: AND
63738: ST_TO_ADDR
// end ;
63739: LD_VAR 0 3
63743: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
63744: LD_INT 0
63746: PPUSH
63747: PPUSH
63748: PPUSH
63749: PPUSH
63750: PPUSH
63751: PPUSH
63752: PPUSH
63753: PPUSH
63754: PPUSH
63755: PPUSH
// result := false ;
63756: LD_ADDR_VAR 0 6
63760: PUSH
63761: LD_INT 0
63763: ST_TO_ADDR
// if not base or not btype or not x or not y then
63764: LD_VAR 0 1
63768: NOT
63769: PUSH
63770: LD_VAR 0 2
63774: NOT
63775: OR
63776: PUSH
63777: LD_VAR 0 3
63781: NOT
63782: OR
63783: PUSH
63784: LD_VAR 0 4
63788: NOT
63789: OR
63790: IFFALSE 63794
// exit ;
63792: GO 64403
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
63794: LD_ADDR_VAR 0 12
63798: PUSH
63799: LD_VAR 0 2
63803: PPUSH
63804: LD_VAR 0 3
63808: PPUSH
63809: LD_VAR 0 4
63813: PPUSH
63814: LD_VAR 0 5
63818: PPUSH
63819: LD_VAR 0 1
63823: PUSH
63824: LD_INT 1
63826: ARRAY
63827: PPUSH
63828: CALL_OW 248
63832: PPUSH
63833: LD_INT 0
63835: PPUSH
63836: CALL 65240 0 6
63840: ST_TO_ADDR
// if not hexes then
63841: LD_VAR 0 12
63845: NOT
63846: IFFALSE 63850
// exit ;
63848: GO 64403
// for i = 1 to hexes do
63850: LD_ADDR_VAR 0 7
63854: PUSH
63855: DOUBLE
63856: LD_INT 1
63858: DEC
63859: ST_TO_ADDR
63860: LD_VAR 0 12
63864: PUSH
63865: FOR_TO
63866: IFFALSE 64401
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63868: LD_ADDR_VAR 0 11
63872: PUSH
63873: LD_VAR 0 12
63877: PUSH
63878: LD_VAR 0 7
63882: ARRAY
63883: PUSH
63884: LD_INT 1
63886: ARRAY
63887: PPUSH
63888: LD_VAR 0 12
63892: PUSH
63893: LD_VAR 0 7
63897: ARRAY
63898: PUSH
63899: LD_INT 2
63901: ARRAY
63902: PPUSH
63903: CALL_OW 428
63907: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63908: LD_VAR 0 12
63912: PUSH
63913: LD_VAR 0 7
63917: ARRAY
63918: PUSH
63919: LD_INT 1
63921: ARRAY
63922: PPUSH
63923: LD_VAR 0 12
63927: PUSH
63928: LD_VAR 0 7
63932: ARRAY
63933: PUSH
63934: LD_INT 2
63936: ARRAY
63937: PPUSH
63938: CALL_OW 351
63942: PUSH
63943: LD_VAR 0 12
63947: PUSH
63948: LD_VAR 0 7
63952: ARRAY
63953: PUSH
63954: LD_INT 1
63956: ARRAY
63957: PPUSH
63958: LD_VAR 0 12
63962: PUSH
63963: LD_VAR 0 7
63967: ARRAY
63968: PUSH
63969: LD_INT 2
63971: ARRAY
63972: PPUSH
63973: CALL_OW 488
63977: NOT
63978: OR
63979: PUSH
63980: LD_VAR 0 11
63984: PPUSH
63985: CALL_OW 247
63989: PUSH
63990: LD_INT 3
63992: EQUAL
63993: OR
63994: IFFALSE 64000
// exit ;
63996: POP
63997: POP
63998: GO 64403
// if not tmp or not tmp in base then
64000: LD_VAR 0 11
64004: NOT
64005: PUSH
64006: LD_VAR 0 11
64010: PUSH
64011: LD_VAR 0 1
64015: IN
64016: NOT
64017: OR
64018: IFFALSE 64022
// continue ;
64020: GO 63865
// result := true ;
64022: LD_ADDR_VAR 0 6
64026: PUSH
64027: LD_INT 1
64029: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64030: LD_ADDR_VAR 0 15
64034: PUSH
64035: LD_VAR 0 1
64039: PPUSH
64040: LD_INT 22
64042: PUSH
64043: LD_VAR 0 11
64047: PPUSH
64048: CALL_OW 255
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: PUSH
64057: LD_INT 2
64059: PUSH
64060: LD_INT 30
64062: PUSH
64063: LD_INT 0
64065: PUSH
64066: EMPTY
64067: LIST
64068: LIST
64069: PUSH
64070: LD_INT 30
64072: PUSH
64073: LD_INT 1
64075: PUSH
64076: EMPTY
64077: LIST
64078: LIST
64079: PUSH
64080: EMPTY
64081: LIST
64082: LIST
64083: LIST
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PPUSH
64089: CALL_OW 72
64093: ST_TO_ADDR
// if dep then
64094: LD_VAR 0 15
64098: IFFALSE 64234
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64100: LD_ADDR_VAR 0 14
64104: PUSH
64105: LD_VAR 0 15
64109: PUSH
64110: LD_INT 1
64112: ARRAY
64113: PPUSH
64114: CALL_OW 250
64118: PPUSH
64119: LD_VAR 0 15
64123: PUSH
64124: LD_INT 1
64126: ARRAY
64127: PPUSH
64128: CALL_OW 254
64132: PPUSH
64133: LD_INT 5
64135: PPUSH
64136: CALL_OW 272
64140: PUSH
64141: LD_VAR 0 15
64145: PUSH
64146: LD_INT 1
64148: ARRAY
64149: PPUSH
64150: CALL_OW 251
64154: PPUSH
64155: LD_VAR 0 15
64159: PUSH
64160: LD_INT 1
64162: ARRAY
64163: PPUSH
64164: CALL_OW 254
64168: PPUSH
64169: LD_INT 5
64171: PPUSH
64172: CALL_OW 273
64176: PUSH
64177: EMPTY
64178: LIST
64179: LIST
64180: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64181: LD_VAR 0 14
64185: PUSH
64186: LD_INT 1
64188: ARRAY
64189: PPUSH
64190: LD_VAR 0 14
64194: PUSH
64195: LD_INT 2
64197: ARRAY
64198: PPUSH
64199: CALL_OW 488
64203: IFFALSE 64234
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64205: LD_VAR 0 11
64209: PPUSH
64210: LD_VAR 0 14
64214: PUSH
64215: LD_INT 1
64217: ARRAY
64218: PPUSH
64219: LD_VAR 0 14
64223: PUSH
64224: LD_INT 2
64226: ARRAY
64227: PPUSH
64228: CALL_OW 111
// continue ;
64232: GO 63865
// end ; end ; r := GetDir ( tmp ) ;
64234: LD_ADDR_VAR 0 13
64238: PUSH
64239: LD_VAR 0 11
64243: PPUSH
64244: CALL_OW 254
64248: ST_TO_ADDR
// if r = 5 then
64249: LD_VAR 0 13
64253: PUSH
64254: LD_INT 5
64256: EQUAL
64257: IFFALSE 64267
// r := 0 ;
64259: LD_ADDR_VAR 0 13
64263: PUSH
64264: LD_INT 0
64266: ST_TO_ADDR
// for j = r to 5 do
64267: LD_ADDR_VAR 0 8
64271: PUSH
64272: DOUBLE
64273: LD_VAR 0 13
64277: DEC
64278: ST_TO_ADDR
64279: LD_INT 5
64281: PUSH
64282: FOR_TO
64283: IFFALSE 64397
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64285: LD_ADDR_VAR 0 9
64289: PUSH
64290: LD_VAR 0 11
64294: PPUSH
64295: CALL_OW 250
64299: PPUSH
64300: LD_VAR 0 8
64304: PPUSH
64305: LD_INT 2
64307: PPUSH
64308: CALL_OW 272
64312: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64313: LD_ADDR_VAR 0 10
64317: PUSH
64318: LD_VAR 0 11
64322: PPUSH
64323: CALL_OW 251
64327: PPUSH
64328: LD_VAR 0 8
64332: PPUSH
64333: LD_INT 2
64335: PPUSH
64336: CALL_OW 273
64340: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64341: LD_VAR 0 9
64345: PPUSH
64346: LD_VAR 0 10
64350: PPUSH
64351: CALL_OW 488
64355: PUSH
64356: LD_VAR 0 9
64360: PPUSH
64361: LD_VAR 0 10
64365: PPUSH
64366: CALL_OW 428
64370: NOT
64371: AND
64372: IFFALSE 64395
// begin ComMoveXY ( tmp , _x , _y ) ;
64374: LD_VAR 0 11
64378: PPUSH
64379: LD_VAR 0 9
64383: PPUSH
64384: LD_VAR 0 10
64388: PPUSH
64389: CALL_OW 111
// break ;
64393: GO 64397
// end ; end ;
64395: GO 64282
64397: POP
64398: POP
// end ;
64399: GO 63865
64401: POP
64402: POP
// end ;
64403: LD_VAR 0 6
64407: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
64408: LD_INT 0
64410: PPUSH
64411: PPUSH
64412: PPUSH
64413: PPUSH
64414: PPUSH
64415: PPUSH
64416: PPUSH
64417: PPUSH
64418: PPUSH
64419: PPUSH
// result := false ;
64420: LD_ADDR_VAR 0 6
64424: PUSH
64425: LD_INT 0
64427: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64428: LD_VAR 0 1
64432: NOT
64433: PUSH
64434: LD_VAR 0 1
64438: PPUSH
64439: CALL_OW 266
64443: PUSH
64444: LD_INT 0
64446: PUSH
64447: LD_INT 1
64449: PUSH
64450: EMPTY
64451: LIST
64452: LIST
64453: IN
64454: NOT
64455: OR
64456: PUSH
64457: LD_VAR 0 2
64461: NOT
64462: OR
64463: PUSH
64464: LD_VAR 0 5
64468: PUSH
64469: LD_INT 0
64471: PUSH
64472: LD_INT 1
64474: PUSH
64475: LD_INT 2
64477: PUSH
64478: LD_INT 3
64480: PUSH
64481: LD_INT 4
64483: PUSH
64484: LD_INT 5
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: LIST
64494: IN
64495: NOT
64496: OR
64497: PUSH
64498: LD_VAR 0 3
64502: PPUSH
64503: LD_VAR 0 4
64507: PPUSH
64508: CALL_OW 488
64512: NOT
64513: OR
64514: IFFALSE 64518
// exit ;
64516: GO 65235
// pom := GetBase ( depot ) ;
64518: LD_ADDR_VAR 0 10
64522: PUSH
64523: LD_VAR 0 1
64527: PPUSH
64528: CALL_OW 274
64532: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64533: LD_ADDR_VAR 0 11
64537: PUSH
64538: LD_VAR 0 2
64542: PPUSH
64543: LD_VAR 0 1
64547: PPUSH
64548: CALL_OW 248
64552: PPUSH
64553: CALL_OW 450
64557: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64558: LD_VAR 0 10
64562: PPUSH
64563: LD_INT 1
64565: PPUSH
64566: CALL_OW 275
64570: PUSH
64571: LD_VAR 0 11
64575: PUSH
64576: LD_INT 1
64578: ARRAY
64579: GREATEREQUAL
64580: PUSH
64581: LD_VAR 0 10
64585: PPUSH
64586: LD_INT 2
64588: PPUSH
64589: CALL_OW 275
64593: PUSH
64594: LD_VAR 0 11
64598: PUSH
64599: LD_INT 2
64601: ARRAY
64602: GREATEREQUAL
64603: AND
64604: PUSH
64605: LD_VAR 0 10
64609: PPUSH
64610: LD_INT 3
64612: PPUSH
64613: CALL_OW 275
64617: PUSH
64618: LD_VAR 0 11
64622: PUSH
64623: LD_INT 3
64625: ARRAY
64626: GREATEREQUAL
64627: AND
64628: NOT
64629: IFFALSE 64633
// exit ;
64631: GO 65235
// if GetBType ( depot ) = b_depot then
64633: LD_VAR 0 1
64637: PPUSH
64638: CALL_OW 266
64642: PUSH
64643: LD_INT 0
64645: EQUAL
64646: IFFALSE 64658
// dist := 28 else
64648: LD_ADDR_VAR 0 14
64652: PUSH
64653: LD_INT 28
64655: ST_TO_ADDR
64656: GO 64666
// dist := 36 ;
64658: LD_ADDR_VAR 0 14
64662: PUSH
64663: LD_INT 36
64665: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
64666: LD_VAR 0 1
64670: PPUSH
64671: LD_VAR 0 3
64675: PPUSH
64676: LD_VAR 0 4
64680: PPUSH
64681: CALL_OW 297
64685: PUSH
64686: LD_VAR 0 14
64690: GREATER
64691: IFFALSE 64695
// exit ;
64693: GO 65235
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
64695: LD_ADDR_VAR 0 12
64699: PUSH
64700: LD_VAR 0 2
64704: PPUSH
64705: LD_VAR 0 3
64709: PPUSH
64710: LD_VAR 0 4
64714: PPUSH
64715: LD_VAR 0 5
64719: PPUSH
64720: LD_VAR 0 1
64724: PPUSH
64725: CALL_OW 248
64729: PPUSH
64730: LD_INT 0
64732: PPUSH
64733: CALL 65240 0 6
64737: ST_TO_ADDR
// if not hexes then
64738: LD_VAR 0 12
64742: NOT
64743: IFFALSE 64747
// exit ;
64745: GO 65235
// hex := GetHexInfo ( x , y ) ;
64747: LD_ADDR_VAR 0 15
64751: PUSH
64752: LD_VAR 0 3
64756: PPUSH
64757: LD_VAR 0 4
64761: PPUSH
64762: CALL_OW 546
64766: ST_TO_ADDR
// if hex [ 1 ] then
64767: LD_VAR 0 15
64771: PUSH
64772: LD_INT 1
64774: ARRAY
64775: IFFALSE 64779
// exit ;
64777: GO 65235
// height := hex [ 2 ] ;
64779: LD_ADDR_VAR 0 13
64783: PUSH
64784: LD_VAR 0 15
64788: PUSH
64789: LD_INT 2
64791: ARRAY
64792: ST_TO_ADDR
// for i = 1 to hexes do
64793: LD_ADDR_VAR 0 7
64797: PUSH
64798: DOUBLE
64799: LD_INT 1
64801: DEC
64802: ST_TO_ADDR
64803: LD_VAR 0 12
64807: PUSH
64808: FOR_TO
64809: IFFALSE 65139
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
64811: LD_VAR 0 12
64815: PUSH
64816: LD_VAR 0 7
64820: ARRAY
64821: PUSH
64822: LD_INT 1
64824: ARRAY
64825: PPUSH
64826: LD_VAR 0 12
64830: PUSH
64831: LD_VAR 0 7
64835: ARRAY
64836: PUSH
64837: LD_INT 2
64839: ARRAY
64840: PPUSH
64841: CALL_OW 488
64845: NOT
64846: PUSH
64847: LD_VAR 0 12
64851: PUSH
64852: LD_VAR 0 7
64856: ARRAY
64857: PUSH
64858: LD_INT 1
64860: ARRAY
64861: PPUSH
64862: LD_VAR 0 12
64866: PUSH
64867: LD_VAR 0 7
64871: ARRAY
64872: PUSH
64873: LD_INT 2
64875: ARRAY
64876: PPUSH
64877: CALL_OW 428
64881: PUSH
64882: LD_INT 0
64884: GREATER
64885: OR
64886: PUSH
64887: LD_VAR 0 12
64891: PUSH
64892: LD_VAR 0 7
64896: ARRAY
64897: PUSH
64898: LD_INT 1
64900: ARRAY
64901: PPUSH
64902: LD_VAR 0 12
64906: PUSH
64907: LD_VAR 0 7
64911: ARRAY
64912: PUSH
64913: LD_INT 2
64915: ARRAY
64916: PPUSH
64917: CALL_OW 351
64921: OR
64922: IFFALSE 64928
// exit ;
64924: POP
64925: POP
64926: GO 65235
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64928: LD_ADDR_VAR 0 8
64932: PUSH
64933: LD_VAR 0 12
64937: PUSH
64938: LD_VAR 0 7
64942: ARRAY
64943: PUSH
64944: LD_INT 1
64946: ARRAY
64947: PPUSH
64948: LD_VAR 0 12
64952: PUSH
64953: LD_VAR 0 7
64957: ARRAY
64958: PUSH
64959: LD_INT 2
64961: ARRAY
64962: PPUSH
64963: CALL_OW 546
64967: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64968: LD_VAR 0 8
64972: PUSH
64973: LD_INT 1
64975: ARRAY
64976: PUSH
64977: LD_VAR 0 8
64981: PUSH
64982: LD_INT 2
64984: ARRAY
64985: PUSH
64986: LD_VAR 0 13
64990: PUSH
64991: LD_INT 2
64993: PLUS
64994: GREATER
64995: OR
64996: PUSH
64997: LD_VAR 0 8
65001: PUSH
65002: LD_INT 2
65004: ARRAY
65005: PUSH
65006: LD_VAR 0 13
65010: PUSH
65011: LD_INT 2
65013: MINUS
65014: LESS
65015: OR
65016: PUSH
65017: LD_VAR 0 8
65021: PUSH
65022: LD_INT 3
65024: ARRAY
65025: PUSH
65026: LD_INT 0
65028: PUSH
65029: LD_INT 8
65031: PUSH
65032: LD_INT 9
65034: PUSH
65035: LD_INT 10
65037: PUSH
65038: LD_INT 11
65040: PUSH
65041: LD_INT 12
65043: PUSH
65044: LD_INT 13
65046: PUSH
65047: LD_INT 16
65049: PUSH
65050: LD_INT 17
65052: PUSH
65053: LD_INT 18
65055: PUSH
65056: LD_INT 19
65058: PUSH
65059: LD_INT 20
65061: PUSH
65062: LD_INT 21
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: LIST
65069: LIST
65070: LIST
65071: LIST
65072: LIST
65073: LIST
65074: LIST
65075: LIST
65076: LIST
65077: LIST
65078: LIST
65079: IN
65080: NOT
65081: OR
65082: PUSH
65083: LD_VAR 0 8
65087: PUSH
65088: LD_INT 5
65090: ARRAY
65091: NOT
65092: OR
65093: PUSH
65094: LD_VAR 0 8
65098: PUSH
65099: LD_INT 6
65101: ARRAY
65102: PUSH
65103: LD_INT 1
65105: PUSH
65106: LD_INT 2
65108: PUSH
65109: LD_INT 7
65111: PUSH
65112: LD_INT 9
65114: PUSH
65115: LD_INT 10
65117: PUSH
65118: LD_INT 11
65120: PUSH
65121: EMPTY
65122: LIST
65123: LIST
65124: LIST
65125: LIST
65126: LIST
65127: LIST
65128: IN
65129: NOT
65130: OR
65131: IFFALSE 65137
// exit ;
65133: POP
65134: POP
65135: GO 65235
// end ;
65137: GO 64808
65139: POP
65140: POP
// side := GetSide ( depot ) ;
65141: LD_ADDR_VAR 0 9
65145: PUSH
65146: LD_VAR 0 1
65150: PPUSH
65151: CALL_OW 255
65155: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65156: LD_VAR 0 9
65160: PPUSH
65161: LD_VAR 0 3
65165: PPUSH
65166: LD_VAR 0 4
65170: PPUSH
65171: LD_INT 20
65173: PPUSH
65174: CALL 57889 0 4
65178: PUSH
65179: LD_INT 4
65181: ARRAY
65182: IFFALSE 65186
// exit ;
65184: GO 65235
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65186: LD_VAR 0 2
65190: PUSH
65191: LD_INT 29
65193: PUSH
65194: LD_INT 30
65196: PUSH
65197: EMPTY
65198: LIST
65199: LIST
65200: IN
65201: PUSH
65202: LD_VAR 0 3
65206: PPUSH
65207: LD_VAR 0 4
65211: PPUSH
65212: LD_VAR 0 9
65216: PPUSH
65217: CALL_OW 440
65221: NOT
65222: AND
65223: IFFALSE 65227
// exit ;
65225: GO 65235
// result := true ;
65227: LD_ADDR_VAR 0 6
65231: PUSH
65232: LD_INT 1
65234: ST_TO_ADDR
// end ;
65235: LD_VAR 0 6
65239: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
65240: LD_INT 0
65242: PPUSH
65243: PPUSH
65244: PPUSH
65245: PPUSH
65246: PPUSH
65247: PPUSH
65248: PPUSH
65249: PPUSH
65250: PPUSH
65251: PPUSH
65252: PPUSH
65253: PPUSH
65254: PPUSH
65255: PPUSH
65256: PPUSH
65257: PPUSH
65258: PPUSH
65259: PPUSH
65260: PPUSH
65261: PPUSH
65262: PPUSH
65263: PPUSH
65264: PPUSH
65265: PPUSH
65266: PPUSH
65267: PPUSH
65268: PPUSH
65269: PPUSH
65270: PPUSH
65271: PPUSH
65272: PPUSH
65273: PPUSH
65274: PPUSH
65275: PPUSH
65276: PPUSH
65277: PPUSH
65278: PPUSH
65279: PPUSH
65280: PPUSH
65281: PPUSH
65282: PPUSH
65283: PPUSH
65284: PPUSH
65285: PPUSH
65286: PPUSH
65287: PPUSH
65288: PPUSH
65289: PPUSH
65290: PPUSH
65291: PPUSH
65292: PPUSH
65293: PPUSH
65294: PPUSH
65295: PPUSH
65296: PPUSH
65297: PPUSH
65298: PPUSH
65299: PPUSH
// result = [ ] ;
65300: LD_ADDR_VAR 0 7
65304: PUSH
65305: EMPTY
65306: ST_TO_ADDR
// temp_list = [ ] ;
65307: LD_ADDR_VAR 0 9
65311: PUSH
65312: EMPTY
65313: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65314: LD_VAR 0 4
65318: PUSH
65319: LD_INT 0
65321: PUSH
65322: LD_INT 1
65324: PUSH
65325: LD_INT 2
65327: PUSH
65328: LD_INT 3
65330: PUSH
65331: LD_INT 4
65333: PUSH
65334: LD_INT 5
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: IN
65345: NOT
65346: PUSH
65347: LD_VAR 0 1
65351: PUSH
65352: LD_INT 0
65354: PUSH
65355: LD_INT 1
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: IN
65362: PUSH
65363: LD_VAR 0 5
65367: PUSH
65368: LD_INT 1
65370: PUSH
65371: LD_INT 2
65373: PUSH
65374: LD_INT 3
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: LIST
65381: IN
65382: NOT
65383: AND
65384: OR
65385: IFFALSE 65389
// exit ;
65387: GO 83780
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65389: LD_VAR 0 1
65393: PUSH
65394: LD_INT 6
65396: PUSH
65397: LD_INT 7
65399: PUSH
65400: LD_INT 8
65402: PUSH
65403: LD_INT 13
65405: PUSH
65406: LD_INT 12
65408: PUSH
65409: LD_INT 15
65411: PUSH
65412: LD_INT 11
65414: PUSH
65415: LD_INT 14
65417: PUSH
65418: LD_INT 10
65420: PUSH
65421: EMPTY
65422: LIST
65423: LIST
65424: LIST
65425: LIST
65426: LIST
65427: LIST
65428: LIST
65429: LIST
65430: LIST
65431: IN
65432: IFFALSE 65442
// btype = b_lab ;
65434: LD_ADDR_VAR 0 1
65438: PUSH
65439: LD_INT 6
65441: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65442: LD_VAR 0 6
65446: PUSH
65447: LD_INT 0
65449: PUSH
65450: LD_INT 1
65452: PUSH
65453: LD_INT 2
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: LIST
65460: IN
65461: NOT
65462: PUSH
65463: LD_VAR 0 1
65467: PUSH
65468: LD_INT 0
65470: PUSH
65471: LD_INT 1
65473: PUSH
65474: LD_INT 2
65476: PUSH
65477: LD_INT 3
65479: PUSH
65480: LD_INT 6
65482: PUSH
65483: LD_INT 36
65485: PUSH
65486: LD_INT 4
65488: PUSH
65489: LD_INT 5
65491: PUSH
65492: LD_INT 31
65494: PUSH
65495: LD_INT 32
65497: PUSH
65498: LD_INT 33
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: IN
65514: NOT
65515: PUSH
65516: LD_VAR 0 6
65520: PUSH
65521: LD_INT 1
65523: EQUAL
65524: AND
65525: OR
65526: PUSH
65527: LD_VAR 0 1
65531: PUSH
65532: LD_INT 2
65534: PUSH
65535: LD_INT 3
65537: PUSH
65538: EMPTY
65539: LIST
65540: LIST
65541: IN
65542: NOT
65543: PUSH
65544: LD_VAR 0 6
65548: PUSH
65549: LD_INT 2
65551: EQUAL
65552: AND
65553: OR
65554: IFFALSE 65564
// mode = 0 ;
65556: LD_ADDR_VAR 0 6
65560: PUSH
65561: LD_INT 0
65563: ST_TO_ADDR
// case mode of 0 :
65564: LD_VAR 0 6
65568: PUSH
65569: LD_INT 0
65571: DOUBLE
65572: EQUAL
65573: IFTRUE 65577
65575: GO 77030
65577: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65578: LD_ADDR_VAR 0 11
65582: PUSH
65583: LD_INT 0
65585: PUSH
65586: LD_INT 0
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 0
65595: PUSH
65596: LD_INT 1
65598: NEG
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: PUSH
65604: LD_INT 1
65606: PUSH
65607: LD_INT 0
65609: PUSH
65610: EMPTY
65611: LIST
65612: LIST
65613: PUSH
65614: LD_INT 1
65616: PUSH
65617: LD_INT 1
65619: PUSH
65620: EMPTY
65621: LIST
65622: LIST
65623: PUSH
65624: LD_INT 0
65626: PUSH
65627: LD_INT 1
65629: PUSH
65630: EMPTY
65631: LIST
65632: LIST
65633: PUSH
65634: LD_INT 1
65636: NEG
65637: PUSH
65638: LD_INT 0
65640: PUSH
65641: EMPTY
65642: LIST
65643: LIST
65644: PUSH
65645: LD_INT 1
65647: NEG
65648: PUSH
65649: LD_INT 1
65651: NEG
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PUSH
65657: LD_INT 1
65659: NEG
65660: PUSH
65661: LD_INT 2
65663: NEG
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: PUSH
65669: LD_INT 0
65671: PUSH
65672: LD_INT 2
65674: NEG
65675: PUSH
65676: EMPTY
65677: LIST
65678: LIST
65679: PUSH
65680: LD_INT 1
65682: PUSH
65683: LD_INT 1
65685: NEG
65686: PUSH
65687: EMPTY
65688: LIST
65689: LIST
65690: PUSH
65691: LD_INT 1
65693: PUSH
65694: LD_INT 2
65696: PUSH
65697: EMPTY
65698: LIST
65699: LIST
65700: PUSH
65701: LD_INT 0
65703: PUSH
65704: LD_INT 2
65706: PUSH
65707: EMPTY
65708: LIST
65709: LIST
65710: PUSH
65711: LD_INT 1
65713: NEG
65714: PUSH
65715: LD_INT 1
65717: PUSH
65718: EMPTY
65719: LIST
65720: LIST
65721: PUSH
65722: LD_INT 1
65724: PUSH
65725: LD_INT 3
65727: PUSH
65728: EMPTY
65729: LIST
65730: LIST
65731: PUSH
65732: LD_INT 0
65734: PUSH
65735: LD_INT 3
65737: PUSH
65738: EMPTY
65739: LIST
65740: LIST
65741: PUSH
65742: LD_INT 1
65744: NEG
65745: PUSH
65746: LD_INT 2
65748: PUSH
65749: EMPTY
65750: LIST
65751: LIST
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: LIST
65757: LIST
65758: LIST
65759: LIST
65760: LIST
65761: LIST
65762: LIST
65763: LIST
65764: LIST
65765: LIST
65766: LIST
65767: LIST
65768: LIST
65769: LIST
65770: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65771: LD_ADDR_VAR 0 12
65775: PUSH
65776: LD_INT 0
65778: PUSH
65779: LD_INT 0
65781: PUSH
65782: EMPTY
65783: LIST
65784: LIST
65785: PUSH
65786: LD_INT 0
65788: PUSH
65789: LD_INT 1
65791: NEG
65792: PUSH
65793: EMPTY
65794: LIST
65795: LIST
65796: PUSH
65797: LD_INT 1
65799: PUSH
65800: LD_INT 0
65802: PUSH
65803: EMPTY
65804: LIST
65805: LIST
65806: PUSH
65807: LD_INT 1
65809: PUSH
65810: LD_INT 1
65812: PUSH
65813: EMPTY
65814: LIST
65815: LIST
65816: PUSH
65817: LD_INT 0
65819: PUSH
65820: LD_INT 1
65822: PUSH
65823: EMPTY
65824: LIST
65825: LIST
65826: PUSH
65827: LD_INT 1
65829: NEG
65830: PUSH
65831: LD_INT 0
65833: PUSH
65834: EMPTY
65835: LIST
65836: LIST
65837: PUSH
65838: LD_INT 1
65840: NEG
65841: PUSH
65842: LD_INT 1
65844: NEG
65845: PUSH
65846: EMPTY
65847: LIST
65848: LIST
65849: PUSH
65850: LD_INT 1
65852: PUSH
65853: LD_INT 1
65855: NEG
65856: PUSH
65857: EMPTY
65858: LIST
65859: LIST
65860: PUSH
65861: LD_INT 2
65863: PUSH
65864: LD_INT 0
65866: PUSH
65867: EMPTY
65868: LIST
65869: LIST
65870: PUSH
65871: LD_INT 2
65873: PUSH
65874: LD_INT 1
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: PUSH
65881: LD_INT 1
65883: NEG
65884: PUSH
65885: LD_INT 1
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PUSH
65892: LD_INT 2
65894: NEG
65895: PUSH
65896: LD_INT 0
65898: PUSH
65899: EMPTY
65900: LIST
65901: LIST
65902: PUSH
65903: LD_INT 2
65905: NEG
65906: PUSH
65907: LD_INT 1
65909: NEG
65910: PUSH
65911: EMPTY
65912: LIST
65913: LIST
65914: PUSH
65915: LD_INT 2
65917: NEG
65918: PUSH
65919: LD_INT 1
65921: PUSH
65922: EMPTY
65923: LIST
65924: LIST
65925: PUSH
65926: LD_INT 3
65928: NEG
65929: PUSH
65930: LD_INT 0
65932: PUSH
65933: EMPTY
65934: LIST
65935: LIST
65936: PUSH
65937: LD_INT 3
65939: NEG
65940: PUSH
65941: LD_INT 1
65943: NEG
65944: PUSH
65945: EMPTY
65946: LIST
65947: LIST
65948: PUSH
65949: EMPTY
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: LIST
65966: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65967: LD_ADDR_VAR 0 13
65971: PUSH
65972: LD_INT 0
65974: PUSH
65975: LD_INT 0
65977: PUSH
65978: EMPTY
65979: LIST
65980: LIST
65981: PUSH
65982: LD_INT 0
65984: PUSH
65985: LD_INT 1
65987: NEG
65988: PUSH
65989: EMPTY
65990: LIST
65991: LIST
65992: PUSH
65993: LD_INT 1
65995: PUSH
65996: LD_INT 0
65998: PUSH
65999: EMPTY
66000: LIST
66001: LIST
66002: PUSH
66003: LD_INT 1
66005: PUSH
66006: LD_INT 1
66008: PUSH
66009: EMPTY
66010: LIST
66011: LIST
66012: PUSH
66013: LD_INT 0
66015: PUSH
66016: LD_INT 1
66018: PUSH
66019: EMPTY
66020: LIST
66021: LIST
66022: PUSH
66023: LD_INT 1
66025: NEG
66026: PUSH
66027: LD_INT 0
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PUSH
66034: LD_INT 1
66036: NEG
66037: PUSH
66038: LD_INT 1
66040: NEG
66041: PUSH
66042: EMPTY
66043: LIST
66044: LIST
66045: PUSH
66046: LD_INT 1
66048: NEG
66049: PUSH
66050: LD_INT 2
66052: NEG
66053: PUSH
66054: EMPTY
66055: LIST
66056: LIST
66057: PUSH
66058: LD_INT 2
66060: PUSH
66061: LD_INT 1
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: PUSH
66068: LD_INT 2
66070: PUSH
66071: LD_INT 2
66073: PUSH
66074: EMPTY
66075: LIST
66076: LIST
66077: PUSH
66078: LD_INT 1
66080: PUSH
66081: LD_INT 2
66083: PUSH
66084: EMPTY
66085: LIST
66086: LIST
66087: PUSH
66088: LD_INT 2
66090: NEG
66091: PUSH
66092: LD_INT 1
66094: NEG
66095: PUSH
66096: EMPTY
66097: LIST
66098: LIST
66099: PUSH
66100: LD_INT 2
66102: NEG
66103: PUSH
66104: LD_INT 2
66106: NEG
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: PUSH
66112: LD_INT 2
66114: NEG
66115: PUSH
66116: LD_INT 3
66118: NEG
66119: PUSH
66120: EMPTY
66121: LIST
66122: LIST
66123: PUSH
66124: LD_INT 3
66126: NEG
66127: PUSH
66128: LD_INT 2
66130: NEG
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: PUSH
66136: LD_INT 3
66138: NEG
66139: PUSH
66140: LD_INT 3
66142: NEG
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66166: LD_ADDR_VAR 0 14
66170: PUSH
66171: LD_INT 0
66173: PUSH
66174: LD_INT 0
66176: PUSH
66177: EMPTY
66178: LIST
66179: LIST
66180: PUSH
66181: LD_INT 0
66183: PUSH
66184: LD_INT 1
66186: NEG
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 1
66194: PUSH
66195: LD_INT 0
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PUSH
66202: LD_INT 1
66204: PUSH
66205: LD_INT 1
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PUSH
66212: LD_INT 0
66214: PUSH
66215: LD_INT 1
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: PUSH
66222: LD_INT 1
66224: NEG
66225: PUSH
66226: LD_INT 0
66228: PUSH
66229: EMPTY
66230: LIST
66231: LIST
66232: PUSH
66233: LD_INT 1
66235: NEG
66236: PUSH
66237: LD_INT 1
66239: NEG
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: PUSH
66245: LD_INT 1
66247: NEG
66248: PUSH
66249: LD_INT 2
66251: NEG
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: PUSH
66257: LD_INT 0
66259: PUSH
66260: LD_INT 2
66262: NEG
66263: PUSH
66264: EMPTY
66265: LIST
66266: LIST
66267: PUSH
66268: LD_INT 1
66270: PUSH
66271: LD_INT 1
66273: NEG
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: LD_INT 1
66281: PUSH
66282: LD_INT 2
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: LD_INT 0
66291: PUSH
66292: LD_INT 2
66294: PUSH
66295: EMPTY
66296: LIST
66297: LIST
66298: PUSH
66299: LD_INT 1
66301: NEG
66302: PUSH
66303: LD_INT 1
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PUSH
66310: LD_INT 1
66312: NEG
66313: PUSH
66314: LD_INT 3
66316: NEG
66317: PUSH
66318: EMPTY
66319: LIST
66320: LIST
66321: PUSH
66322: LD_INT 0
66324: PUSH
66325: LD_INT 3
66327: NEG
66328: PUSH
66329: EMPTY
66330: LIST
66331: LIST
66332: PUSH
66333: LD_INT 1
66335: PUSH
66336: LD_INT 2
66338: NEG
66339: PUSH
66340: EMPTY
66341: LIST
66342: LIST
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: LIST
66348: LIST
66349: LIST
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: LIST
66355: LIST
66356: LIST
66357: LIST
66358: LIST
66359: LIST
66360: LIST
66361: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66362: LD_ADDR_VAR 0 15
66366: PUSH
66367: LD_INT 0
66369: PUSH
66370: LD_INT 0
66372: PUSH
66373: EMPTY
66374: LIST
66375: LIST
66376: PUSH
66377: LD_INT 0
66379: PUSH
66380: LD_INT 1
66382: NEG
66383: PUSH
66384: EMPTY
66385: LIST
66386: LIST
66387: PUSH
66388: LD_INT 1
66390: PUSH
66391: LD_INT 0
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 1
66400: PUSH
66401: LD_INT 1
66403: PUSH
66404: EMPTY
66405: LIST
66406: LIST
66407: PUSH
66408: LD_INT 0
66410: PUSH
66411: LD_INT 1
66413: PUSH
66414: EMPTY
66415: LIST
66416: LIST
66417: PUSH
66418: LD_INT 1
66420: NEG
66421: PUSH
66422: LD_INT 0
66424: PUSH
66425: EMPTY
66426: LIST
66427: LIST
66428: PUSH
66429: LD_INT 1
66431: NEG
66432: PUSH
66433: LD_INT 1
66435: NEG
66436: PUSH
66437: EMPTY
66438: LIST
66439: LIST
66440: PUSH
66441: LD_INT 1
66443: PUSH
66444: LD_INT 1
66446: NEG
66447: PUSH
66448: EMPTY
66449: LIST
66450: LIST
66451: PUSH
66452: LD_INT 2
66454: PUSH
66455: LD_INT 0
66457: PUSH
66458: EMPTY
66459: LIST
66460: LIST
66461: PUSH
66462: LD_INT 2
66464: PUSH
66465: LD_INT 1
66467: PUSH
66468: EMPTY
66469: LIST
66470: LIST
66471: PUSH
66472: LD_INT 1
66474: NEG
66475: PUSH
66476: LD_INT 1
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 2
66485: NEG
66486: PUSH
66487: LD_INT 0
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: LD_INT 2
66496: NEG
66497: PUSH
66498: LD_INT 1
66500: NEG
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: LD_INT 2
66508: PUSH
66509: LD_INT 1
66511: NEG
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PUSH
66517: LD_INT 3
66519: PUSH
66520: LD_INT 0
66522: PUSH
66523: EMPTY
66524: LIST
66525: LIST
66526: PUSH
66527: LD_INT 3
66529: PUSH
66530: LD_INT 1
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: LIST
66544: LIST
66545: LIST
66546: LIST
66547: LIST
66548: LIST
66549: LIST
66550: LIST
66551: LIST
66552: LIST
66553: LIST
66554: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66555: LD_ADDR_VAR 0 16
66559: PUSH
66560: LD_INT 0
66562: PUSH
66563: LD_INT 0
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 0
66572: PUSH
66573: LD_INT 1
66575: NEG
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 1
66583: PUSH
66584: LD_INT 0
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PUSH
66591: LD_INT 1
66593: PUSH
66594: LD_INT 1
66596: PUSH
66597: EMPTY
66598: LIST
66599: LIST
66600: PUSH
66601: LD_INT 0
66603: PUSH
66604: LD_INT 1
66606: PUSH
66607: EMPTY
66608: LIST
66609: LIST
66610: PUSH
66611: LD_INT 1
66613: NEG
66614: PUSH
66615: LD_INT 0
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 1
66624: NEG
66625: PUSH
66626: LD_INT 1
66628: NEG
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: PUSH
66634: LD_INT 1
66636: NEG
66637: PUSH
66638: LD_INT 2
66640: NEG
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: PUSH
66646: LD_INT 2
66648: PUSH
66649: LD_INT 1
66651: PUSH
66652: EMPTY
66653: LIST
66654: LIST
66655: PUSH
66656: LD_INT 2
66658: PUSH
66659: LD_INT 2
66661: PUSH
66662: EMPTY
66663: LIST
66664: LIST
66665: PUSH
66666: LD_INT 1
66668: PUSH
66669: LD_INT 2
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: LD_INT 2
66678: NEG
66679: PUSH
66680: LD_INT 1
66682: NEG
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: PUSH
66688: LD_INT 2
66690: NEG
66691: PUSH
66692: LD_INT 2
66694: NEG
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: LD_INT 3
66702: PUSH
66703: LD_INT 2
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: LD_INT 3
66712: PUSH
66713: LD_INT 3
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: LD_INT 2
66722: PUSH
66723: LD_INT 3
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66748: LD_ADDR_VAR 0 17
66752: PUSH
66753: LD_INT 0
66755: PUSH
66756: LD_INT 0
66758: PUSH
66759: EMPTY
66760: LIST
66761: LIST
66762: PUSH
66763: LD_INT 0
66765: PUSH
66766: LD_INT 1
66768: NEG
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PUSH
66774: LD_INT 1
66776: PUSH
66777: LD_INT 0
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 1
66786: PUSH
66787: LD_INT 1
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: PUSH
66794: LD_INT 0
66796: PUSH
66797: LD_INT 1
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PUSH
66804: LD_INT 1
66806: NEG
66807: PUSH
66808: LD_INT 0
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PUSH
66815: LD_INT 1
66817: NEG
66818: PUSH
66819: LD_INT 1
66821: NEG
66822: PUSH
66823: EMPTY
66824: LIST
66825: LIST
66826: PUSH
66827: LD_INT 1
66829: NEG
66830: PUSH
66831: LD_INT 2
66833: NEG
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 0
66841: PUSH
66842: LD_INT 2
66844: NEG
66845: PUSH
66846: EMPTY
66847: LIST
66848: LIST
66849: PUSH
66850: LD_INT 1
66852: PUSH
66853: LD_INT 1
66855: NEG
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 2
66863: PUSH
66864: LD_INT 0
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: LD_INT 2
66873: PUSH
66874: LD_INT 1
66876: PUSH
66877: EMPTY
66878: LIST
66879: LIST
66880: PUSH
66881: LD_INT 2
66883: PUSH
66884: LD_INT 2
66886: PUSH
66887: EMPTY
66888: LIST
66889: LIST
66890: PUSH
66891: LD_INT 1
66893: PUSH
66894: LD_INT 2
66896: PUSH
66897: EMPTY
66898: LIST
66899: LIST
66900: PUSH
66901: LD_INT 0
66903: PUSH
66904: LD_INT 2
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: LD_INT 1
66913: NEG
66914: PUSH
66915: LD_INT 1
66917: PUSH
66918: EMPTY
66919: LIST
66920: LIST
66921: PUSH
66922: LD_INT 2
66924: NEG
66925: PUSH
66926: LD_INT 0
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: PUSH
66933: LD_INT 2
66935: NEG
66936: PUSH
66937: LD_INT 1
66939: NEG
66940: PUSH
66941: EMPTY
66942: LIST
66943: LIST
66944: PUSH
66945: LD_INT 2
66947: NEG
66948: PUSH
66949: LD_INT 2
66951: NEG
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: LIST
66961: LIST
66962: LIST
66963: LIST
66964: LIST
66965: LIST
66966: LIST
66967: LIST
66968: LIST
66969: LIST
66970: LIST
66971: LIST
66972: LIST
66973: LIST
66974: LIST
66975: LIST
66976: LIST
66977: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66978: LD_ADDR_VAR 0 18
66982: PUSH
66983: LD_INT 0
66985: PUSH
66986: LD_INT 0
66988: PUSH
66989: EMPTY
66990: LIST
66991: LIST
66992: PUSH
66993: LD_INT 0
66995: PUSH
66996: LD_INT 1
66998: NEG
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: PUSH
67004: LD_INT 1
67006: PUSH
67007: LD_INT 0
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: LD_INT 1
67016: PUSH
67017: LD_INT 1
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: PUSH
67024: LD_INT 0
67026: PUSH
67027: LD_INT 1
67029: PUSH
67030: EMPTY
67031: LIST
67032: LIST
67033: PUSH
67034: LD_INT 1
67036: NEG
67037: PUSH
67038: LD_INT 0
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: PUSH
67045: LD_INT 1
67047: NEG
67048: PUSH
67049: LD_INT 1
67051: NEG
67052: PUSH
67053: EMPTY
67054: LIST
67055: LIST
67056: PUSH
67057: LD_INT 1
67059: NEG
67060: PUSH
67061: LD_INT 2
67063: NEG
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: LD_INT 0
67071: PUSH
67072: LD_INT 2
67074: NEG
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 1
67082: PUSH
67083: LD_INT 1
67085: NEG
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 2
67093: PUSH
67094: LD_INT 0
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: PUSH
67101: LD_INT 2
67103: PUSH
67104: LD_INT 1
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 2
67113: PUSH
67114: LD_INT 2
67116: PUSH
67117: EMPTY
67118: LIST
67119: LIST
67120: PUSH
67121: LD_INT 1
67123: PUSH
67124: LD_INT 2
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 0
67133: PUSH
67134: LD_INT 2
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 1
67143: NEG
67144: PUSH
67145: LD_INT 1
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: PUSH
67152: LD_INT 2
67154: NEG
67155: PUSH
67156: LD_INT 0
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: PUSH
67163: LD_INT 2
67165: NEG
67166: PUSH
67167: LD_INT 1
67169: NEG
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 2
67177: NEG
67178: PUSH
67179: LD_INT 2
67181: NEG
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: LIST
67191: LIST
67192: LIST
67193: LIST
67194: LIST
67195: LIST
67196: LIST
67197: LIST
67198: LIST
67199: LIST
67200: LIST
67201: LIST
67202: LIST
67203: LIST
67204: LIST
67205: LIST
67206: LIST
67207: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67208: LD_ADDR_VAR 0 19
67212: PUSH
67213: LD_INT 0
67215: PUSH
67216: LD_INT 0
67218: PUSH
67219: EMPTY
67220: LIST
67221: LIST
67222: PUSH
67223: LD_INT 0
67225: PUSH
67226: LD_INT 1
67228: NEG
67229: PUSH
67230: EMPTY
67231: LIST
67232: LIST
67233: PUSH
67234: LD_INT 1
67236: PUSH
67237: LD_INT 0
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 1
67246: PUSH
67247: LD_INT 1
67249: PUSH
67250: EMPTY
67251: LIST
67252: LIST
67253: PUSH
67254: LD_INT 0
67256: PUSH
67257: LD_INT 1
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: LD_INT 1
67266: NEG
67267: PUSH
67268: LD_INT 0
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: LD_INT 1
67277: NEG
67278: PUSH
67279: LD_INT 1
67281: NEG
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: PUSH
67287: LD_INT 1
67289: NEG
67290: PUSH
67291: LD_INT 2
67293: NEG
67294: PUSH
67295: EMPTY
67296: LIST
67297: LIST
67298: PUSH
67299: LD_INT 0
67301: PUSH
67302: LD_INT 2
67304: NEG
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: PUSH
67310: LD_INT 1
67312: PUSH
67313: LD_INT 1
67315: NEG
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 2
67323: PUSH
67324: LD_INT 0
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: LD_INT 2
67333: PUSH
67334: LD_INT 1
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: PUSH
67341: LD_INT 2
67343: PUSH
67344: LD_INT 2
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: PUSH
67351: LD_INT 1
67353: PUSH
67354: LD_INT 2
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: PUSH
67361: LD_INT 0
67363: PUSH
67364: LD_INT 2
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: LD_INT 1
67373: NEG
67374: PUSH
67375: LD_INT 1
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: LD_INT 2
67384: NEG
67385: PUSH
67386: LD_INT 0
67388: PUSH
67389: EMPTY
67390: LIST
67391: LIST
67392: PUSH
67393: LD_INT 2
67395: NEG
67396: PUSH
67397: LD_INT 1
67399: NEG
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: PUSH
67405: LD_INT 2
67407: NEG
67408: PUSH
67409: LD_INT 2
67411: NEG
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: LIST
67421: LIST
67422: LIST
67423: LIST
67424: LIST
67425: LIST
67426: LIST
67427: LIST
67428: LIST
67429: LIST
67430: LIST
67431: LIST
67432: LIST
67433: LIST
67434: LIST
67435: LIST
67436: LIST
67437: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67438: LD_ADDR_VAR 0 20
67442: PUSH
67443: LD_INT 0
67445: PUSH
67446: LD_INT 0
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 0
67455: PUSH
67456: LD_INT 1
67458: NEG
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 1
67466: PUSH
67467: LD_INT 0
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 1
67476: PUSH
67477: LD_INT 1
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: LD_INT 0
67486: PUSH
67487: LD_INT 1
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 1
67496: NEG
67497: PUSH
67498: LD_INT 0
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: PUSH
67505: LD_INT 1
67507: NEG
67508: PUSH
67509: LD_INT 1
67511: NEG
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 1
67519: NEG
67520: PUSH
67521: LD_INT 2
67523: NEG
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: PUSH
67529: LD_INT 0
67531: PUSH
67532: LD_INT 2
67534: NEG
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: LD_INT 1
67542: PUSH
67543: LD_INT 1
67545: NEG
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: LD_INT 2
67553: PUSH
67554: LD_INT 0
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PUSH
67561: LD_INT 2
67563: PUSH
67564: LD_INT 1
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 2
67573: PUSH
67574: LD_INT 2
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: LD_INT 1
67583: PUSH
67584: LD_INT 2
67586: PUSH
67587: EMPTY
67588: LIST
67589: LIST
67590: PUSH
67591: LD_INT 0
67593: PUSH
67594: LD_INT 2
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: PUSH
67601: LD_INT 1
67603: NEG
67604: PUSH
67605: LD_INT 1
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PUSH
67612: LD_INT 2
67614: NEG
67615: PUSH
67616: LD_INT 0
67618: PUSH
67619: EMPTY
67620: LIST
67621: LIST
67622: PUSH
67623: LD_INT 2
67625: NEG
67626: PUSH
67627: LD_INT 1
67629: NEG
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: PUSH
67635: LD_INT 2
67637: NEG
67638: PUSH
67639: LD_INT 2
67641: NEG
67642: PUSH
67643: EMPTY
67644: LIST
67645: LIST
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: LIST
67658: LIST
67659: LIST
67660: LIST
67661: LIST
67662: LIST
67663: LIST
67664: LIST
67665: LIST
67666: LIST
67667: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67668: LD_ADDR_VAR 0 21
67672: PUSH
67673: LD_INT 0
67675: PUSH
67676: LD_INT 0
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 0
67685: PUSH
67686: LD_INT 1
67688: NEG
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 1
67696: PUSH
67697: LD_INT 0
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: LD_INT 1
67706: PUSH
67707: LD_INT 1
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: LD_INT 0
67716: PUSH
67717: LD_INT 1
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: LD_INT 1
67726: NEG
67727: PUSH
67728: LD_INT 0
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 1
67737: NEG
67738: PUSH
67739: LD_INT 1
67741: NEG
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: PUSH
67747: LD_INT 1
67749: NEG
67750: PUSH
67751: LD_INT 2
67753: NEG
67754: PUSH
67755: EMPTY
67756: LIST
67757: LIST
67758: PUSH
67759: LD_INT 0
67761: PUSH
67762: LD_INT 2
67764: NEG
67765: PUSH
67766: EMPTY
67767: LIST
67768: LIST
67769: PUSH
67770: LD_INT 1
67772: PUSH
67773: LD_INT 1
67775: NEG
67776: PUSH
67777: EMPTY
67778: LIST
67779: LIST
67780: PUSH
67781: LD_INT 2
67783: PUSH
67784: LD_INT 0
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PUSH
67791: LD_INT 2
67793: PUSH
67794: LD_INT 1
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 2
67803: PUSH
67804: LD_INT 2
67806: PUSH
67807: EMPTY
67808: LIST
67809: LIST
67810: PUSH
67811: LD_INT 1
67813: PUSH
67814: LD_INT 2
67816: PUSH
67817: EMPTY
67818: LIST
67819: LIST
67820: PUSH
67821: LD_INT 0
67823: PUSH
67824: LD_INT 2
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: PUSH
67831: LD_INT 1
67833: NEG
67834: PUSH
67835: LD_INT 1
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: LD_INT 2
67844: NEG
67845: PUSH
67846: LD_INT 0
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 2
67855: NEG
67856: PUSH
67857: LD_INT 1
67859: NEG
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: PUSH
67865: LD_INT 2
67867: NEG
67868: PUSH
67869: LD_INT 2
67871: NEG
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PUSH
67877: EMPTY
67878: LIST
67879: LIST
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: LIST
67886: LIST
67887: LIST
67888: LIST
67889: LIST
67890: LIST
67891: LIST
67892: LIST
67893: LIST
67894: LIST
67895: LIST
67896: LIST
67897: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67898: LD_ADDR_VAR 0 22
67902: PUSH
67903: LD_INT 0
67905: PUSH
67906: LD_INT 0
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: PUSH
67913: LD_INT 0
67915: PUSH
67916: LD_INT 1
67918: NEG
67919: PUSH
67920: EMPTY
67921: LIST
67922: LIST
67923: PUSH
67924: LD_INT 1
67926: PUSH
67927: LD_INT 0
67929: PUSH
67930: EMPTY
67931: LIST
67932: LIST
67933: PUSH
67934: LD_INT 1
67936: PUSH
67937: LD_INT 1
67939: PUSH
67940: EMPTY
67941: LIST
67942: LIST
67943: PUSH
67944: LD_INT 0
67946: PUSH
67947: LD_INT 1
67949: PUSH
67950: EMPTY
67951: LIST
67952: LIST
67953: PUSH
67954: LD_INT 1
67956: NEG
67957: PUSH
67958: LD_INT 0
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: PUSH
67965: LD_INT 1
67967: NEG
67968: PUSH
67969: LD_INT 1
67971: NEG
67972: PUSH
67973: EMPTY
67974: LIST
67975: LIST
67976: PUSH
67977: LD_INT 1
67979: NEG
67980: PUSH
67981: LD_INT 2
67983: NEG
67984: PUSH
67985: EMPTY
67986: LIST
67987: LIST
67988: PUSH
67989: LD_INT 0
67991: PUSH
67992: LD_INT 2
67994: NEG
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: PUSH
68000: LD_INT 1
68002: PUSH
68003: LD_INT 1
68005: NEG
68006: PUSH
68007: EMPTY
68008: LIST
68009: LIST
68010: PUSH
68011: LD_INT 2
68013: PUSH
68014: LD_INT 0
68016: PUSH
68017: EMPTY
68018: LIST
68019: LIST
68020: PUSH
68021: LD_INT 2
68023: PUSH
68024: LD_INT 1
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PUSH
68031: LD_INT 2
68033: PUSH
68034: LD_INT 2
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: PUSH
68041: LD_INT 1
68043: PUSH
68044: LD_INT 2
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: PUSH
68051: LD_INT 0
68053: PUSH
68054: LD_INT 2
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: PUSH
68061: LD_INT 1
68063: NEG
68064: PUSH
68065: LD_INT 1
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: PUSH
68072: LD_INT 2
68074: NEG
68075: PUSH
68076: LD_INT 0
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 2
68085: NEG
68086: PUSH
68087: LD_INT 1
68089: NEG
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: LD_INT 2
68097: NEG
68098: PUSH
68099: LD_INT 2
68101: NEG
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68128: LD_ADDR_VAR 0 23
68132: PUSH
68133: LD_INT 0
68135: PUSH
68136: LD_INT 0
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PUSH
68143: LD_INT 0
68145: PUSH
68146: LD_INT 1
68148: NEG
68149: PUSH
68150: EMPTY
68151: LIST
68152: LIST
68153: PUSH
68154: LD_INT 1
68156: PUSH
68157: LD_INT 0
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: PUSH
68164: LD_INT 1
68166: PUSH
68167: LD_INT 1
68169: PUSH
68170: EMPTY
68171: LIST
68172: LIST
68173: PUSH
68174: LD_INT 0
68176: PUSH
68177: LD_INT 1
68179: PUSH
68180: EMPTY
68181: LIST
68182: LIST
68183: PUSH
68184: LD_INT 1
68186: NEG
68187: PUSH
68188: LD_INT 0
68190: PUSH
68191: EMPTY
68192: LIST
68193: LIST
68194: PUSH
68195: LD_INT 1
68197: NEG
68198: PUSH
68199: LD_INT 1
68201: NEG
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 1
68209: NEG
68210: PUSH
68211: LD_INT 2
68213: NEG
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: PUSH
68219: LD_INT 0
68221: PUSH
68222: LD_INT 2
68224: NEG
68225: PUSH
68226: EMPTY
68227: LIST
68228: LIST
68229: PUSH
68230: LD_INT 1
68232: PUSH
68233: LD_INT 1
68235: NEG
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: PUSH
68241: LD_INT 2
68243: PUSH
68244: LD_INT 0
68246: PUSH
68247: EMPTY
68248: LIST
68249: LIST
68250: PUSH
68251: LD_INT 2
68253: PUSH
68254: LD_INT 1
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 2
68263: PUSH
68264: LD_INT 2
68266: PUSH
68267: EMPTY
68268: LIST
68269: LIST
68270: PUSH
68271: LD_INT 1
68273: PUSH
68274: LD_INT 2
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: PUSH
68281: LD_INT 0
68283: PUSH
68284: LD_INT 2
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 1
68293: NEG
68294: PUSH
68295: LD_INT 1
68297: PUSH
68298: EMPTY
68299: LIST
68300: LIST
68301: PUSH
68302: LD_INT 2
68304: NEG
68305: PUSH
68306: LD_INT 0
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: LD_INT 2
68315: NEG
68316: PUSH
68317: LD_INT 1
68319: NEG
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: LD_INT 2
68327: NEG
68328: PUSH
68329: LD_INT 2
68331: NEG
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 2
68339: NEG
68340: PUSH
68341: LD_INT 3
68343: NEG
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: PUSH
68349: LD_INT 1
68351: NEG
68352: PUSH
68353: LD_INT 3
68355: NEG
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 1
68363: PUSH
68364: LD_INT 2
68366: NEG
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PUSH
68372: LD_INT 2
68374: PUSH
68375: LD_INT 1
68377: NEG
68378: PUSH
68379: EMPTY
68380: LIST
68381: LIST
68382: PUSH
68383: EMPTY
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68408: LD_ADDR_VAR 0 24
68412: PUSH
68413: LD_INT 0
68415: PUSH
68416: LD_INT 0
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 0
68425: PUSH
68426: LD_INT 1
68428: NEG
68429: PUSH
68430: EMPTY
68431: LIST
68432: LIST
68433: PUSH
68434: LD_INT 1
68436: PUSH
68437: LD_INT 0
68439: PUSH
68440: EMPTY
68441: LIST
68442: LIST
68443: PUSH
68444: LD_INT 1
68446: PUSH
68447: LD_INT 1
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: LD_INT 0
68456: PUSH
68457: LD_INT 1
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 1
68466: NEG
68467: PUSH
68468: LD_INT 0
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: PUSH
68475: LD_INT 1
68477: NEG
68478: PUSH
68479: LD_INT 1
68481: NEG
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: PUSH
68487: LD_INT 1
68489: NEG
68490: PUSH
68491: LD_INT 2
68493: NEG
68494: PUSH
68495: EMPTY
68496: LIST
68497: LIST
68498: PUSH
68499: LD_INT 0
68501: PUSH
68502: LD_INT 2
68504: NEG
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: LD_INT 1
68512: PUSH
68513: LD_INT 1
68515: NEG
68516: PUSH
68517: EMPTY
68518: LIST
68519: LIST
68520: PUSH
68521: LD_INT 2
68523: PUSH
68524: LD_INT 0
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 2
68533: PUSH
68534: LD_INT 1
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 2
68543: PUSH
68544: LD_INT 2
68546: PUSH
68547: EMPTY
68548: LIST
68549: LIST
68550: PUSH
68551: LD_INT 1
68553: PUSH
68554: LD_INT 2
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 0
68563: PUSH
68564: LD_INT 2
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 1
68573: NEG
68574: PUSH
68575: LD_INT 1
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PUSH
68582: LD_INT 2
68584: NEG
68585: PUSH
68586: LD_INT 0
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 2
68595: NEG
68596: PUSH
68597: LD_INT 1
68599: NEG
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: LD_INT 2
68607: NEG
68608: PUSH
68609: LD_INT 2
68611: NEG
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: LD_INT 1
68619: PUSH
68620: LD_INT 2
68622: NEG
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: LD_INT 2
68630: PUSH
68631: LD_INT 1
68633: NEG
68634: PUSH
68635: EMPTY
68636: LIST
68637: LIST
68638: PUSH
68639: LD_INT 3
68641: PUSH
68642: LD_INT 1
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: PUSH
68649: LD_INT 3
68651: PUSH
68652: LD_INT 2
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: PUSH
68659: EMPTY
68660: LIST
68661: LIST
68662: LIST
68663: LIST
68664: LIST
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: LIST
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
68684: LD_ADDR_VAR 0 25
68688: PUSH
68689: LD_INT 0
68691: PUSH
68692: LD_INT 0
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: LD_INT 0
68701: PUSH
68702: LD_INT 1
68704: NEG
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 1
68712: PUSH
68713: LD_INT 0
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: PUSH
68720: LD_INT 1
68722: PUSH
68723: LD_INT 1
68725: PUSH
68726: EMPTY
68727: LIST
68728: LIST
68729: PUSH
68730: LD_INT 0
68732: PUSH
68733: LD_INT 1
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: LD_INT 1
68742: NEG
68743: PUSH
68744: LD_INT 0
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PUSH
68751: LD_INT 1
68753: NEG
68754: PUSH
68755: LD_INT 1
68757: NEG
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PUSH
68763: LD_INT 1
68765: NEG
68766: PUSH
68767: LD_INT 2
68769: NEG
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: LD_INT 0
68777: PUSH
68778: LD_INT 2
68780: NEG
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: PUSH
68786: LD_INT 1
68788: PUSH
68789: LD_INT 1
68791: NEG
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: PUSH
68797: LD_INT 2
68799: PUSH
68800: LD_INT 0
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 2
68809: PUSH
68810: LD_INT 1
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 2
68819: PUSH
68820: LD_INT 2
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 1
68829: PUSH
68830: LD_INT 2
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 0
68839: PUSH
68840: LD_INT 2
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 1
68849: NEG
68850: PUSH
68851: LD_INT 1
68853: PUSH
68854: EMPTY
68855: LIST
68856: LIST
68857: PUSH
68858: LD_INT 2
68860: NEG
68861: PUSH
68862: LD_INT 0
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: LD_INT 2
68871: NEG
68872: PUSH
68873: LD_INT 1
68875: NEG
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: LD_INT 2
68883: NEG
68884: PUSH
68885: LD_INT 2
68887: NEG
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 3
68895: PUSH
68896: LD_INT 1
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: LD_INT 3
68905: PUSH
68906: LD_INT 2
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: LD_INT 2
68915: PUSH
68916: LD_INT 3
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: PUSH
68923: LD_INT 1
68925: PUSH
68926: LD_INT 3
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PUSH
68933: EMPTY
68934: LIST
68935: LIST
68936: LIST
68937: LIST
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68958: LD_ADDR_VAR 0 26
68962: PUSH
68963: LD_INT 0
68965: PUSH
68966: LD_INT 0
68968: PUSH
68969: EMPTY
68970: LIST
68971: LIST
68972: PUSH
68973: LD_INT 0
68975: PUSH
68976: LD_INT 1
68978: NEG
68979: PUSH
68980: EMPTY
68981: LIST
68982: LIST
68983: PUSH
68984: LD_INT 1
68986: PUSH
68987: LD_INT 0
68989: PUSH
68990: EMPTY
68991: LIST
68992: LIST
68993: PUSH
68994: LD_INT 1
68996: PUSH
68997: LD_INT 1
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 0
69006: PUSH
69007: LD_INT 1
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 1
69016: NEG
69017: PUSH
69018: LD_INT 0
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 1
69027: NEG
69028: PUSH
69029: LD_INT 1
69031: NEG
69032: PUSH
69033: EMPTY
69034: LIST
69035: LIST
69036: PUSH
69037: LD_INT 1
69039: NEG
69040: PUSH
69041: LD_INT 2
69043: NEG
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 0
69051: PUSH
69052: LD_INT 2
69054: NEG
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: LD_INT 1
69062: PUSH
69063: LD_INT 1
69065: NEG
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 2
69073: PUSH
69074: LD_INT 0
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 2
69083: PUSH
69084: LD_INT 1
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: PUSH
69091: LD_INT 2
69093: PUSH
69094: LD_INT 2
69096: PUSH
69097: EMPTY
69098: LIST
69099: LIST
69100: PUSH
69101: LD_INT 1
69103: PUSH
69104: LD_INT 2
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PUSH
69111: LD_INT 0
69113: PUSH
69114: LD_INT 2
69116: PUSH
69117: EMPTY
69118: LIST
69119: LIST
69120: PUSH
69121: LD_INT 1
69123: NEG
69124: PUSH
69125: LD_INT 1
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 2
69134: NEG
69135: PUSH
69136: LD_INT 0
69138: PUSH
69139: EMPTY
69140: LIST
69141: LIST
69142: PUSH
69143: LD_INT 2
69145: NEG
69146: PUSH
69147: LD_INT 1
69149: NEG
69150: PUSH
69151: EMPTY
69152: LIST
69153: LIST
69154: PUSH
69155: LD_INT 2
69157: NEG
69158: PUSH
69159: LD_INT 2
69161: NEG
69162: PUSH
69163: EMPTY
69164: LIST
69165: LIST
69166: PUSH
69167: LD_INT 2
69169: PUSH
69170: LD_INT 3
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: PUSH
69177: LD_INT 1
69179: PUSH
69180: LD_INT 3
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 1
69189: NEG
69190: PUSH
69191: LD_INT 2
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 2
69200: NEG
69201: PUSH
69202: LD_INT 1
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: LIST
69215: LIST
69216: LIST
69217: LIST
69218: LIST
69219: LIST
69220: LIST
69221: LIST
69222: LIST
69223: LIST
69224: LIST
69225: LIST
69226: LIST
69227: LIST
69228: LIST
69229: LIST
69230: LIST
69231: LIST
69232: LIST
69233: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69234: LD_ADDR_VAR 0 27
69238: PUSH
69239: LD_INT 0
69241: PUSH
69242: LD_INT 0
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 0
69251: PUSH
69252: LD_INT 1
69254: NEG
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 1
69262: PUSH
69263: LD_INT 0
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 1
69272: PUSH
69273: LD_INT 1
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 0
69282: PUSH
69283: LD_INT 1
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 1
69292: NEG
69293: PUSH
69294: LD_INT 0
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: PUSH
69301: LD_INT 1
69303: NEG
69304: PUSH
69305: LD_INT 1
69307: NEG
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 1
69315: NEG
69316: PUSH
69317: LD_INT 2
69319: NEG
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 0
69327: PUSH
69328: LD_INT 2
69330: NEG
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 1
69338: PUSH
69339: LD_INT 1
69341: NEG
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: PUSH
69347: LD_INT 2
69349: PUSH
69350: LD_INT 0
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 2
69359: PUSH
69360: LD_INT 1
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 2
69369: PUSH
69370: LD_INT 2
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: PUSH
69377: LD_INT 1
69379: PUSH
69380: LD_INT 2
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 0
69389: PUSH
69390: LD_INT 2
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: LD_INT 1
69399: NEG
69400: PUSH
69401: LD_INT 1
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PUSH
69408: LD_INT 2
69410: NEG
69411: PUSH
69412: LD_INT 0
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: PUSH
69419: LD_INT 2
69421: NEG
69422: PUSH
69423: LD_INT 1
69425: NEG
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: PUSH
69431: LD_INT 2
69433: NEG
69434: PUSH
69435: LD_INT 2
69437: NEG
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: PUSH
69443: LD_INT 1
69445: NEG
69446: PUSH
69447: LD_INT 2
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 2
69456: NEG
69457: PUSH
69458: LD_INT 1
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: PUSH
69465: LD_INT 3
69467: NEG
69468: PUSH
69469: LD_INT 1
69471: NEG
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: LD_INT 3
69479: NEG
69480: PUSH
69481: LD_INT 2
69483: NEG
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: LIST
69493: LIST
69494: LIST
69495: LIST
69496: LIST
69497: LIST
69498: LIST
69499: LIST
69500: LIST
69501: LIST
69502: LIST
69503: LIST
69504: LIST
69505: LIST
69506: LIST
69507: LIST
69508: LIST
69509: LIST
69510: LIST
69511: LIST
69512: LIST
69513: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69514: LD_ADDR_VAR 0 28
69518: PUSH
69519: LD_INT 0
69521: PUSH
69522: LD_INT 0
69524: PUSH
69525: EMPTY
69526: LIST
69527: LIST
69528: PUSH
69529: LD_INT 0
69531: PUSH
69532: LD_INT 1
69534: NEG
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: PUSH
69540: LD_INT 1
69542: PUSH
69543: LD_INT 0
69545: PUSH
69546: EMPTY
69547: LIST
69548: LIST
69549: PUSH
69550: LD_INT 1
69552: PUSH
69553: LD_INT 1
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 0
69562: PUSH
69563: LD_INT 1
69565: PUSH
69566: EMPTY
69567: LIST
69568: LIST
69569: PUSH
69570: LD_INT 1
69572: NEG
69573: PUSH
69574: LD_INT 0
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: PUSH
69581: LD_INT 1
69583: NEG
69584: PUSH
69585: LD_INT 1
69587: NEG
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 1
69595: NEG
69596: PUSH
69597: LD_INT 2
69599: NEG
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 0
69607: PUSH
69608: LD_INT 2
69610: NEG
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 1
69618: PUSH
69619: LD_INT 1
69621: NEG
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 2
69629: PUSH
69630: LD_INT 0
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 2
69639: PUSH
69640: LD_INT 1
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 2
69649: PUSH
69650: LD_INT 2
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 1
69659: PUSH
69660: LD_INT 2
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 0
69669: PUSH
69670: LD_INT 2
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 1
69679: NEG
69680: PUSH
69681: LD_INT 1
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: PUSH
69688: LD_INT 2
69690: NEG
69691: PUSH
69692: LD_INT 0
69694: PUSH
69695: EMPTY
69696: LIST
69697: LIST
69698: PUSH
69699: LD_INT 2
69701: NEG
69702: PUSH
69703: LD_INT 1
69705: NEG
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 2
69713: NEG
69714: PUSH
69715: LD_INT 2
69717: NEG
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 2
69725: NEG
69726: PUSH
69727: LD_INT 3
69729: NEG
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: LD_INT 1
69737: NEG
69738: PUSH
69739: LD_INT 3
69741: NEG
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: PUSH
69747: LD_INT 3
69749: NEG
69750: PUSH
69751: LD_INT 1
69753: NEG
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: PUSH
69759: LD_INT 3
69761: NEG
69762: PUSH
69763: LD_INT 2
69765: NEG
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: LIST
69775: LIST
69776: LIST
69777: LIST
69778: LIST
69779: LIST
69780: LIST
69781: LIST
69782: LIST
69783: LIST
69784: LIST
69785: LIST
69786: LIST
69787: LIST
69788: LIST
69789: LIST
69790: LIST
69791: LIST
69792: LIST
69793: LIST
69794: LIST
69795: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69796: LD_ADDR_VAR 0 29
69800: PUSH
69801: LD_INT 0
69803: PUSH
69804: LD_INT 0
69806: PUSH
69807: EMPTY
69808: LIST
69809: LIST
69810: PUSH
69811: LD_INT 0
69813: PUSH
69814: LD_INT 1
69816: NEG
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: LD_INT 1
69824: PUSH
69825: LD_INT 0
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 1
69834: PUSH
69835: LD_INT 1
69837: PUSH
69838: EMPTY
69839: LIST
69840: LIST
69841: PUSH
69842: LD_INT 0
69844: PUSH
69845: LD_INT 1
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: PUSH
69852: LD_INT 1
69854: NEG
69855: PUSH
69856: LD_INT 0
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: PUSH
69863: LD_INT 1
69865: NEG
69866: PUSH
69867: LD_INT 1
69869: NEG
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PUSH
69875: LD_INT 1
69877: NEG
69878: PUSH
69879: LD_INT 2
69881: NEG
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 0
69889: PUSH
69890: LD_INT 2
69892: NEG
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: PUSH
69898: LD_INT 1
69900: PUSH
69901: LD_INT 1
69903: NEG
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: LD_INT 2
69911: PUSH
69912: LD_INT 0
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 2
69921: PUSH
69922: LD_INT 1
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 1
69931: PUSH
69932: LD_INT 2
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: PUSH
69939: LD_INT 0
69941: PUSH
69942: LD_INT 2
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: PUSH
69949: LD_INT 1
69951: NEG
69952: PUSH
69953: LD_INT 1
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 2
69962: NEG
69963: PUSH
69964: LD_INT 1
69966: NEG
69967: PUSH
69968: EMPTY
69969: LIST
69970: LIST
69971: PUSH
69972: LD_INT 2
69974: NEG
69975: PUSH
69976: LD_INT 2
69978: NEG
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: LD_INT 2
69986: NEG
69987: PUSH
69988: LD_INT 3
69990: NEG
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PUSH
69996: LD_INT 2
69998: PUSH
69999: LD_INT 1
70001: NEG
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: LD_INT 3
70009: PUSH
70010: LD_INT 1
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: LD_INT 1
70019: PUSH
70020: LD_INT 3
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: PUSH
70027: LD_INT 1
70029: NEG
70030: PUSH
70031: LD_INT 2
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: PUSH
70038: LD_INT 3
70040: NEG
70041: PUSH
70042: LD_INT 2
70044: NEG
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: LIST
70054: LIST
70055: LIST
70056: LIST
70057: LIST
70058: LIST
70059: LIST
70060: LIST
70061: LIST
70062: LIST
70063: LIST
70064: LIST
70065: LIST
70066: LIST
70067: LIST
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70075: LD_ADDR_VAR 0 30
70079: PUSH
70080: LD_INT 0
70082: PUSH
70083: LD_INT 0
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: PUSH
70090: LD_INT 0
70092: PUSH
70093: LD_INT 1
70095: NEG
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 1
70103: PUSH
70104: LD_INT 0
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 1
70113: PUSH
70114: LD_INT 1
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 0
70123: PUSH
70124: LD_INT 1
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 1
70133: NEG
70134: PUSH
70135: LD_INT 0
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: LD_INT 1
70144: NEG
70145: PUSH
70146: LD_INT 1
70148: NEG
70149: PUSH
70150: EMPTY
70151: LIST
70152: LIST
70153: PUSH
70154: LD_INT 1
70156: NEG
70157: PUSH
70158: LD_INT 2
70160: NEG
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: LD_INT 0
70168: PUSH
70169: LD_INT 2
70171: NEG
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: PUSH
70177: LD_INT 1
70179: PUSH
70180: LD_INT 1
70182: NEG
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 2
70190: PUSH
70191: LD_INT 0
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 2
70200: PUSH
70201: LD_INT 1
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PUSH
70208: LD_INT 2
70210: PUSH
70211: LD_INT 2
70213: PUSH
70214: EMPTY
70215: LIST
70216: LIST
70217: PUSH
70218: LD_INT 1
70220: PUSH
70221: LD_INT 2
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 1
70230: NEG
70231: PUSH
70232: LD_INT 1
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: LD_INT 2
70241: NEG
70242: PUSH
70243: LD_INT 0
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: LD_INT 2
70252: NEG
70253: PUSH
70254: LD_INT 1
70256: NEG
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PUSH
70262: LD_INT 1
70264: NEG
70265: PUSH
70266: LD_INT 3
70268: NEG
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: PUSH
70274: LD_INT 1
70276: PUSH
70277: LD_INT 2
70279: NEG
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PUSH
70285: LD_INT 3
70287: PUSH
70288: LD_INT 2
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 2
70297: PUSH
70298: LD_INT 3
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 2
70307: NEG
70308: PUSH
70309: LD_INT 1
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 3
70318: NEG
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: EMPTY
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: LIST
70338: LIST
70339: LIST
70340: LIST
70341: LIST
70342: LIST
70343: LIST
70344: LIST
70345: LIST
70346: LIST
70347: LIST
70348: LIST
70349: LIST
70350: LIST
70351: LIST
70352: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70353: LD_ADDR_VAR 0 31
70357: PUSH
70358: LD_INT 0
70360: PUSH
70361: LD_INT 0
70363: PUSH
70364: EMPTY
70365: LIST
70366: LIST
70367: PUSH
70368: LD_INT 0
70370: PUSH
70371: LD_INT 1
70373: NEG
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 1
70381: PUSH
70382: LD_INT 0
70384: PUSH
70385: EMPTY
70386: LIST
70387: LIST
70388: PUSH
70389: LD_INT 1
70391: PUSH
70392: LD_INT 1
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 0
70401: PUSH
70402: LD_INT 1
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 1
70411: NEG
70412: PUSH
70413: LD_INT 0
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 1
70422: NEG
70423: PUSH
70424: LD_INT 1
70426: NEG
70427: PUSH
70428: EMPTY
70429: LIST
70430: LIST
70431: PUSH
70432: LD_INT 1
70434: NEG
70435: PUSH
70436: LD_INT 2
70438: NEG
70439: PUSH
70440: EMPTY
70441: LIST
70442: LIST
70443: PUSH
70444: LD_INT 1
70446: PUSH
70447: LD_INT 1
70449: NEG
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: PUSH
70455: LD_INT 2
70457: PUSH
70458: LD_INT 0
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: PUSH
70465: LD_INT 2
70467: PUSH
70468: LD_INT 1
70470: PUSH
70471: EMPTY
70472: LIST
70473: LIST
70474: PUSH
70475: LD_INT 2
70477: PUSH
70478: LD_INT 2
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PUSH
70485: LD_INT 1
70487: PUSH
70488: LD_INT 2
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: LD_INT 0
70497: PUSH
70498: LD_INT 2
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PUSH
70505: LD_INT 1
70507: NEG
70508: PUSH
70509: LD_INT 1
70511: PUSH
70512: EMPTY
70513: LIST
70514: LIST
70515: PUSH
70516: LD_INT 2
70518: NEG
70519: PUSH
70520: LD_INT 1
70522: NEG
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PUSH
70528: LD_INT 2
70530: NEG
70531: PUSH
70532: LD_INT 2
70534: NEG
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: PUSH
70540: LD_INT 2
70542: NEG
70543: PUSH
70544: LD_INT 3
70546: NEG
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: PUSH
70552: LD_INT 2
70554: PUSH
70555: LD_INT 1
70557: NEG
70558: PUSH
70559: EMPTY
70560: LIST
70561: LIST
70562: PUSH
70563: LD_INT 3
70565: PUSH
70566: LD_INT 1
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: PUSH
70573: LD_INT 1
70575: PUSH
70576: LD_INT 3
70578: PUSH
70579: EMPTY
70580: LIST
70581: LIST
70582: PUSH
70583: LD_INT 1
70585: NEG
70586: PUSH
70587: LD_INT 2
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: PUSH
70594: LD_INT 3
70596: NEG
70597: PUSH
70598: LD_INT 2
70600: NEG
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: LIST
70610: LIST
70611: LIST
70612: LIST
70613: LIST
70614: LIST
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70631: LD_ADDR_VAR 0 32
70635: PUSH
70636: LD_INT 0
70638: PUSH
70639: LD_INT 0
70641: PUSH
70642: EMPTY
70643: LIST
70644: LIST
70645: PUSH
70646: LD_INT 0
70648: PUSH
70649: LD_INT 1
70651: NEG
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: PUSH
70657: LD_INT 1
70659: PUSH
70660: LD_INT 0
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: LD_INT 1
70669: PUSH
70670: LD_INT 1
70672: PUSH
70673: EMPTY
70674: LIST
70675: LIST
70676: PUSH
70677: LD_INT 0
70679: PUSH
70680: LD_INT 1
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: LD_INT 1
70689: NEG
70690: PUSH
70691: LD_INT 0
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 1
70700: NEG
70701: PUSH
70702: LD_INT 1
70704: NEG
70705: PUSH
70706: EMPTY
70707: LIST
70708: LIST
70709: PUSH
70710: LD_INT 1
70712: NEG
70713: PUSH
70714: LD_INT 2
70716: NEG
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: LD_INT 0
70724: PUSH
70725: LD_INT 2
70727: NEG
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: LD_INT 1
70735: PUSH
70736: LD_INT 1
70738: NEG
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 2
70746: PUSH
70747: LD_INT 1
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 2
70756: PUSH
70757: LD_INT 2
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 1
70766: PUSH
70767: LD_INT 2
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: PUSH
70774: LD_INT 0
70776: PUSH
70777: LD_INT 2
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: PUSH
70784: LD_INT 1
70786: NEG
70787: PUSH
70788: LD_INT 1
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: LD_INT 2
70797: NEG
70798: PUSH
70799: LD_INT 0
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 2
70808: NEG
70809: PUSH
70810: LD_INT 1
70812: NEG
70813: PUSH
70814: EMPTY
70815: LIST
70816: LIST
70817: PUSH
70818: LD_INT 1
70820: NEG
70821: PUSH
70822: LD_INT 3
70824: NEG
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: LD_INT 2
70835: NEG
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 3
70843: PUSH
70844: LD_INT 2
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 2
70853: PUSH
70854: LD_INT 3
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 2
70863: NEG
70864: PUSH
70865: LD_INT 1
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: PUSH
70872: LD_INT 3
70874: NEG
70875: PUSH
70876: LD_INT 1
70878: NEG
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: LIST
70891: LIST
70892: LIST
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70909: LD_ADDR_VAR 0 33
70913: PUSH
70914: LD_INT 0
70916: PUSH
70917: LD_INT 0
70919: PUSH
70920: EMPTY
70921: LIST
70922: LIST
70923: PUSH
70924: LD_INT 0
70926: PUSH
70927: LD_INT 1
70929: NEG
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: LD_INT 1
70937: PUSH
70938: LD_INT 0
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: PUSH
70945: LD_INT 1
70947: PUSH
70948: LD_INT 1
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 0
70957: PUSH
70958: LD_INT 1
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: LD_INT 1
70967: NEG
70968: PUSH
70969: LD_INT 0
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: PUSH
70976: LD_INT 1
70978: NEG
70979: PUSH
70980: LD_INT 1
70982: NEG
70983: PUSH
70984: EMPTY
70985: LIST
70986: LIST
70987: PUSH
70988: LD_INT 1
70990: NEG
70991: PUSH
70992: LD_INT 2
70994: NEG
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: PUSH
71000: LD_INT 1
71002: PUSH
71003: LD_INT 1
71005: NEG
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: LD_INT 2
71013: PUSH
71014: LD_INT 0
71016: PUSH
71017: EMPTY
71018: LIST
71019: LIST
71020: PUSH
71021: LD_INT 2
71023: PUSH
71024: LD_INT 1
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: PUSH
71031: LD_INT 1
71033: PUSH
71034: LD_INT 2
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: LD_INT 0
71043: PUSH
71044: LD_INT 2
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 1
71053: NEG
71054: PUSH
71055: LD_INT 1
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 2
71064: NEG
71065: PUSH
71066: LD_INT 0
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 2
71075: NEG
71076: PUSH
71077: LD_INT 1
71079: NEG
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 2
71087: NEG
71088: PUSH
71089: LD_INT 2
71091: NEG
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: PUSH
71097: LD_INT 2
71099: NEG
71100: PUSH
71101: LD_INT 3
71103: NEG
71104: PUSH
71105: EMPTY
71106: LIST
71107: LIST
71108: PUSH
71109: LD_INT 2
71111: PUSH
71112: LD_INT 1
71114: NEG
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 3
71122: PUSH
71123: LD_INT 1
71125: PUSH
71126: EMPTY
71127: LIST
71128: LIST
71129: PUSH
71130: LD_INT 1
71132: PUSH
71133: LD_INT 3
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: PUSH
71140: LD_INT 1
71142: NEG
71143: PUSH
71144: LD_INT 2
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 3
71153: NEG
71154: PUSH
71155: LD_INT 2
71157: NEG
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: LIST
71167: LIST
71168: LIST
71169: LIST
71170: LIST
71171: LIST
71172: LIST
71173: LIST
71174: LIST
71175: LIST
71176: LIST
71177: LIST
71178: LIST
71179: LIST
71180: LIST
71181: LIST
71182: LIST
71183: LIST
71184: LIST
71185: LIST
71186: LIST
71187: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71188: LD_ADDR_VAR 0 34
71192: PUSH
71193: LD_INT 0
71195: PUSH
71196: LD_INT 0
71198: PUSH
71199: EMPTY
71200: LIST
71201: LIST
71202: PUSH
71203: LD_INT 0
71205: PUSH
71206: LD_INT 1
71208: NEG
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 1
71216: PUSH
71217: LD_INT 0
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 1
71226: PUSH
71227: LD_INT 1
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 0
71236: PUSH
71237: LD_INT 1
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 1
71246: NEG
71247: PUSH
71248: LD_INT 0
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 1
71257: NEG
71258: PUSH
71259: LD_INT 1
71261: NEG
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 1
71269: NEG
71270: PUSH
71271: LD_INT 2
71273: NEG
71274: PUSH
71275: EMPTY
71276: LIST
71277: LIST
71278: PUSH
71279: LD_INT 0
71281: PUSH
71282: LD_INT 2
71284: NEG
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 1
71292: PUSH
71293: LD_INT 1
71295: NEG
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 2
71303: PUSH
71304: LD_INT 1
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 2
71313: PUSH
71314: LD_INT 2
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 1
71323: PUSH
71324: LD_INT 2
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 1
71333: NEG
71334: PUSH
71335: LD_INT 1
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: PUSH
71342: LD_INT 2
71344: NEG
71345: PUSH
71346: LD_INT 0
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: LD_INT 2
71355: NEG
71356: PUSH
71357: LD_INT 1
71359: NEG
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 2
71367: NEG
71368: PUSH
71369: LD_INT 2
71371: NEG
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 1
71379: NEG
71380: PUSH
71381: LD_INT 3
71383: NEG
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: PUSH
71389: LD_INT 1
71391: PUSH
71392: LD_INT 2
71394: NEG
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: LD_INT 3
71402: PUSH
71403: LD_INT 2
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PUSH
71410: LD_INT 2
71412: PUSH
71413: LD_INT 3
71415: PUSH
71416: EMPTY
71417: LIST
71418: LIST
71419: PUSH
71420: LD_INT 2
71422: NEG
71423: PUSH
71424: LD_INT 1
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: LD_INT 3
71433: NEG
71434: PUSH
71435: LD_INT 1
71437: NEG
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: PUSH
71443: EMPTY
71444: LIST
71445: LIST
71446: LIST
71447: LIST
71448: LIST
71449: LIST
71450: LIST
71451: LIST
71452: LIST
71453: LIST
71454: LIST
71455: LIST
71456: LIST
71457: LIST
71458: LIST
71459: LIST
71460: LIST
71461: LIST
71462: LIST
71463: LIST
71464: LIST
71465: LIST
71466: LIST
71467: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71468: LD_ADDR_VAR 0 35
71472: PUSH
71473: LD_INT 0
71475: PUSH
71476: LD_INT 0
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: PUSH
71483: LD_INT 0
71485: PUSH
71486: LD_INT 1
71488: NEG
71489: PUSH
71490: EMPTY
71491: LIST
71492: LIST
71493: PUSH
71494: LD_INT 1
71496: PUSH
71497: LD_INT 0
71499: PUSH
71500: EMPTY
71501: LIST
71502: LIST
71503: PUSH
71504: LD_INT 1
71506: PUSH
71507: LD_INT 1
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: LD_INT 0
71516: PUSH
71517: LD_INT 1
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PUSH
71524: LD_INT 1
71526: NEG
71527: PUSH
71528: LD_INT 0
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 1
71537: NEG
71538: PUSH
71539: LD_INT 1
71541: NEG
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 2
71549: PUSH
71550: LD_INT 1
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 2
71559: NEG
71560: PUSH
71561: LD_INT 1
71563: NEG
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: LIST
71573: LIST
71574: LIST
71575: LIST
71576: LIST
71577: LIST
71578: LIST
71579: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71580: LD_ADDR_VAR 0 36
71584: PUSH
71585: LD_INT 0
71587: PUSH
71588: LD_INT 0
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: PUSH
71595: LD_INT 0
71597: PUSH
71598: LD_INT 1
71600: NEG
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 1
71608: PUSH
71609: LD_INT 0
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: PUSH
71616: LD_INT 1
71618: PUSH
71619: LD_INT 1
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PUSH
71626: LD_INT 0
71628: PUSH
71629: LD_INT 1
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 1
71638: NEG
71639: PUSH
71640: LD_INT 0
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: PUSH
71647: LD_INT 1
71649: NEG
71650: PUSH
71651: LD_INT 1
71653: NEG
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: PUSH
71659: LD_INT 1
71661: NEG
71662: PUSH
71663: LD_INT 2
71665: NEG
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: PUSH
71671: LD_INT 1
71673: PUSH
71674: LD_INT 2
71676: PUSH
71677: EMPTY
71678: LIST
71679: LIST
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: LIST
71685: LIST
71686: LIST
71687: LIST
71688: LIST
71689: LIST
71690: LIST
71691: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71692: LD_ADDR_VAR 0 37
71696: PUSH
71697: LD_INT 0
71699: PUSH
71700: LD_INT 0
71702: PUSH
71703: EMPTY
71704: LIST
71705: LIST
71706: PUSH
71707: LD_INT 0
71709: PUSH
71710: LD_INT 1
71712: NEG
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PUSH
71718: LD_INT 1
71720: PUSH
71721: LD_INT 0
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 1
71730: PUSH
71731: LD_INT 1
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 0
71740: PUSH
71741: LD_INT 1
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 1
71750: NEG
71751: PUSH
71752: LD_INT 0
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: LD_INT 1
71761: NEG
71762: PUSH
71763: LD_INT 1
71765: NEG
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PUSH
71771: LD_INT 1
71773: PUSH
71774: LD_INT 1
71776: NEG
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 1
71784: NEG
71785: PUSH
71786: LD_INT 1
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: EMPTY
71794: LIST
71795: LIST
71796: LIST
71797: LIST
71798: LIST
71799: LIST
71800: LIST
71801: LIST
71802: LIST
71803: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71804: LD_ADDR_VAR 0 38
71808: PUSH
71809: LD_INT 0
71811: PUSH
71812: LD_INT 0
71814: PUSH
71815: EMPTY
71816: LIST
71817: LIST
71818: PUSH
71819: LD_INT 0
71821: PUSH
71822: LD_INT 1
71824: NEG
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: PUSH
71830: LD_INT 1
71832: PUSH
71833: LD_INT 0
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: PUSH
71840: LD_INT 1
71842: PUSH
71843: LD_INT 1
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: PUSH
71850: LD_INT 0
71852: PUSH
71853: LD_INT 1
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 1
71862: NEG
71863: PUSH
71864: LD_INT 0
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: LD_INT 1
71873: NEG
71874: PUSH
71875: LD_INT 1
71877: NEG
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: PUSH
71883: LD_INT 2
71885: PUSH
71886: LD_INT 1
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: PUSH
71893: LD_INT 2
71895: NEG
71896: PUSH
71897: LD_INT 1
71899: NEG
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: PUSH
71905: EMPTY
71906: LIST
71907: LIST
71908: LIST
71909: LIST
71910: LIST
71911: LIST
71912: LIST
71913: LIST
71914: LIST
71915: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71916: LD_ADDR_VAR 0 39
71920: PUSH
71921: LD_INT 0
71923: PUSH
71924: LD_INT 0
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: PUSH
71931: LD_INT 0
71933: PUSH
71934: LD_INT 1
71936: NEG
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: PUSH
71942: LD_INT 1
71944: PUSH
71945: LD_INT 0
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 1
71954: PUSH
71955: LD_INT 1
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PUSH
71962: LD_INT 0
71964: PUSH
71965: LD_INT 1
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 1
71974: NEG
71975: PUSH
71976: LD_INT 0
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: PUSH
71983: LD_INT 1
71985: NEG
71986: PUSH
71987: LD_INT 1
71989: NEG
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PUSH
71995: LD_INT 1
71997: NEG
71998: PUSH
71999: LD_INT 2
72001: NEG
72002: PUSH
72003: EMPTY
72004: LIST
72005: LIST
72006: PUSH
72007: LD_INT 1
72009: PUSH
72010: LD_INT 2
72012: PUSH
72013: EMPTY
72014: LIST
72015: LIST
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: LIST
72021: LIST
72022: LIST
72023: LIST
72024: LIST
72025: LIST
72026: LIST
72027: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72028: LD_ADDR_VAR 0 40
72032: PUSH
72033: LD_INT 0
72035: PUSH
72036: LD_INT 0
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 0
72045: PUSH
72046: LD_INT 1
72048: NEG
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: LD_INT 1
72056: PUSH
72057: LD_INT 0
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: LD_INT 1
72066: PUSH
72067: LD_INT 1
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: LD_INT 0
72076: PUSH
72077: LD_INT 1
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: LD_INT 1
72086: NEG
72087: PUSH
72088: LD_INT 0
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: PUSH
72095: LD_INT 1
72097: NEG
72098: PUSH
72099: LD_INT 1
72101: NEG
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 1
72109: PUSH
72110: LD_INT 1
72112: NEG
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: LD_INT 1
72120: NEG
72121: PUSH
72122: LD_INT 1
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: PUSH
72129: EMPTY
72130: LIST
72131: LIST
72132: LIST
72133: LIST
72134: LIST
72135: LIST
72136: LIST
72137: LIST
72138: LIST
72139: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72140: LD_ADDR_VAR 0 41
72144: PUSH
72145: LD_INT 0
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: PUSH
72155: LD_INT 0
72157: PUSH
72158: LD_INT 1
72160: NEG
72161: PUSH
72162: EMPTY
72163: LIST
72164: LIST
72165: PUSH
72166: LD_INT 1
72168: PUSH
72169: LD_INT 0
72171: PUSH
72172: EMPTY
72173: LIST
72174: LIST
72175: PUSH
72176: LD_INT 1
72178: PUSH
72179: LD_INT 1
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 0
72188: PUSH
72189: LD_INT 1
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: LD_INT 1
72198: NEG
72199: PUSH
72200: LD_INT 0
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: PUSH
72207: LD_INT 1
72209: NEG
72210: PUSH
72211: LD_INT 1
72213: NEG
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: PUSH
72219: LD_INT 1
72221: NEG
72222: PUSH
72223: LD_INT 2
72225: NEG
72226: PUSH
72227: EMPTY
72228: LIST
72229: LIST
72230: PUSH
72231: LD_INT 1
72233: PUSH
72234: LD_INT 1
72236: NEG
72237: PUSH
72238: EMPTY
72239: LIST
72240: LIST
72241: PUSH
72242: LD_INT 2
72244: PUSH
72245: LD_INT 0
72247: PUSH
72248: EMPTY
72249: LIST
72250: LIST
72251: PUSH
72252: LD_INT 2
72254: PUSH
72255: LD_INT 1
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: PUSH
72262: LD_INT 2
72264: PUSH
72265: LD_INT 2
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PUSH
72272: LD_INT 1
72274: PUSH
72275: LD_INT 2
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 1
72284: NEG
72285: PUSH
72286: LD_INT 1
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 2
72295: NEG
72296: PUSH
72297: LD_INT 0
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 2
72306: NEG
72307: PUSH
72308: LD_INT 1
72310: NEG
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 2
72318: NEG
72319: PUSH
72320: LD_INT 2
72322: NEG
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: LD_INT 2
72330: NEG
72331: PUSH
72332: LD_INT 3
72334: NEG
72335: PUSH
72336: EMPTY
72337: LIST
72338: LIST
72339: PUSH
72340: LD_INT 2
72342: PUSH
72343: LD_INT 1
72345: NEG
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: LD_INT 3
72353: PUSH
72354: LD_INT 0
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: PUSH
72361: LD_INT 3
72363: PUSH
72364: LD_INT 1
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PUSH
72371: LD_INT 3
72373: PUSH
72374: LD_INT 2
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: PUSH
72381: LD_INT 3
72383: PUSH
72384: LD_INT 3
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 2
72393: PUSH
72394: LD_INT 3
72396: PUSH
72397: EMPTY
72398: LIST
72399: LIST
72400: PUSH
72401: LD_INT 2
72403: NEG
72404: PUSH
72405: LD_INT 1
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: LD_INT 3
72414: NEG
72415: PUSH
72416: LD_INT 0
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: PUSH
72423: LD_INT 3
72425: NEG
72426: PUSH
72427: LD_INT 1
72429: NEG
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 3
72437: NEG
72438: PUSH
72439: LD_INT 2
72441: NEG
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: PUSH
72447: LD_INT 3
72449: NEG
72450: PUSH
72451: LD_INT 3
72453: NEG
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: EMPTY
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: LIST
72469: LIST
72470: LIST
72471: LIST
72472: LIST
72473: LIST
72474: LIST
72475: LIST
72476: LIST
72477: LIST
72478: LIST
72479: LIST
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: LIST
72489: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72490: LD_ADDR_VAR 0 42
72494: PUSH
72495: LD_INT 0
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 0
72507: PUSH
72508: LD_INT 1
72510: NEG
72511: PUSH
72512: EMPTY
72513: LIST
72514: LIST
72515: PUSH
72516: LD_INT 1
72518: PUSH
72519: LD_INT 0
72521: PUSH
72522: EMPTY
72523: LIST
72524: LIST
72525: PUSH
72526: LD_INT 1
72528: PUSH
72529: LD_INT 1
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: LD_INT 0
72538: PUSH
72539: LD_INT 1
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 1
72548: NEG
72549: PUSH
72550: LD_INT 0
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 1
72559: NEG
72560: PUSH
72561: LD_INT 1
72563: NEG
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: PUSH
72569: LD_INT 1
72571: NEG
72572: PUSH
72573: LD_INT 2
72575: NEG
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: PUSH
72581: LD_INT 0
72583: PUSH
72584: LD_INT 2
72586: NEG
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 1
72594: PUSH
72595: LD_INT 1
72597: NEG
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 2
72605: PUSH
72606: LD_INT 1
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: LD_INT 2
72615: PUSH
72616: LD_INT 2
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: LD_INT 1
72625: PUSH
72626: LD_INT 2
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 0
72635: PUSH
72636: LD_INT 2
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: PUSH
72643: LD_INT 1
72645: NEG
72646: PUSH
72647: LD_INT 1
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: LD_INT 2
72656: NEG
72657: PUSH
72658: LD_INT 1
72660: NEG
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 2
72668: NEG
72669: PUSH
72670: LD_INT 2
72672: NEG
72673: PUSH
72674: EMPTY
72675: LIST
72676: LIST
72677: PUSH
72678: LD_INT 2
72680: NEG
72681: PUSH
72682: LD_INT 3
72684: NEG
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: PUSH
72690: LD_INT 1
72692: NEG
72693: PUSH
72694: LD_INT 3
72696: NEG
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 0
72704: PUSH
72705: LD_INT 3
72707: NEG
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: LD_INT 1
72715: PUSH
72716: LD_INT 2
72718: NEG
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: PUSH
72724: LD_INT 3
72726: PUSH
72727: LD_INT 2
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: PUSH
72734: LD_INT 3
72736: PUSH
72737: LD_INT 3
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: PUSH
72744: LD_INT 2
72746: PUSH
72747: LD_INT 3
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PUSH
72754: LD_INT 1
72756: PUSH
72757: LD_INT 3
72759: PUSH
72760: EMPTY
72761: LIST
72762: LIST
72763: PUSH
72764: LD_INT 0
72766: PUSH
72767: LD_INT 3
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 1
72776: NEG
72777: PUSH
72778: LD_INT 2
72780: PUSH
72781: EMPTY
72782: LIST
72783: LIST
72784: PUSH
72785: LD_INT 3
72787: NEG
72788: PUSH
72789: LD_INT 2
72791: NEG
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: LD_INT 3
72799: NEG
72800: PUSH
72801: LD_INT 3
72803: NEG
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: LIST
72813: LIST
72814: LIST
72815: LIST
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: LIST
72824: LIST
72825: LIST
72826: LIST
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72840: LD_ADDR_VAR 0 43
72844: PUSH
72845: LD_INT 0
72847: PUSH
72848: LD_INT 0
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 0
72857: PUSH
72858: LD_INT 1
72860: NEG
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 1
72868: PUSH
72869: LD_INT 0
72871: PUSH
72872: EMPTY
72873: LIST
72874: LIST
72875: PUSH
72876: LD_INT 1
72878: PUSH
72879: LD_INT 1
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: PUSH
72886: LD_INT 0
72888: PUSH
72889: LD_INT 1
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 1
72898: NEG
72899: PUSH
72900: LD_INT 0
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: LD_INT 1
72913: NEG
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: LD_INT 1
72921: NEG
72922: PUSH
72923: LD_INT 2
72925: NEG
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PUSH
72931: LD_INT 0
72933: PUSH
72934: LD_INT 2
72936: NEG
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: PUSH
72942: LD_INT 1
72944: PUSH
72945: LD_INT 1
72947: NEG
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: LD_INT 2
72955: PUSH
72956: LD_INT 0
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PUSH
72963: LD_INT 2
72965: PUSH
72966: LD_INT 1
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: LD_INT 1
72975: PUSH
72976: LD_INT 2
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: PUSH
72983: LD_INT 0
72985: PUSH
72986: LD_INT 2
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 1
72995: NEG
72996: PUSH
72997: LD_INT 1
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: PUSH
73004: LD_INT 2
73006: NEG
73007: PUSH
73008: LD_INT 0
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: PUSH
73015: LD_INT 2
73017: NEG
73018: PUSH
73019: LD_INT 1
73021: NEG
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: PUSH
73027: LD_INT 1
73029: NEG
73030: PUSH
73031: LD_INT 3
73033: NEG
73034: PUSH
73035: EMPTY
73036: LIST
73037: LIST
73038: PUSH
73039: LD_INT 0
73041: PUSH
73042: LD_INT 3
73044: NEG
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: LD_INT 1
73052: PUSH
73053: LD_INT 2
73055: NEG
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: PUSH
73061: LD_INT 2
73063: PUSH
73064: LD_INT 1
73066: NEG
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: LD_INT 3
73074: PUSH
73075: LD_INT 0
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 3
73084: PUSH
73085: LD_INT 1
73087: PUSH
73088: EMPTY
73089: LIST
73090: LIST
73091: PUSH
73092: LD_INT 1
73094: PUSH
73095: LD_INT 3
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: LD_INT 0
73104: PUSH
73105: LD_INT 3
73107: PUSH
73108: EMPTY
73109: LIST
73110: LIST
73111: PUSH
73112: LD_INT 1
73114: NEG
73115: PUSH
73116: LD_INT 2
73118: PUSH
73119: EMPTY
73120: LIST
73121: LIST
73122: PUSH
73123: LD_INT 2
73125: NEG
73126: PUSH
73127: LD_INT 1
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 3
73136: NEG
73137: PUSH
73138: LD_INT 0
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 3
73147: NEG
73148: PUSH
73149: LD_INT 1
73151: NEG
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: LIST
73161: LIST
73162: LIST
73163: LIST
73164: LIST
73165: LIST
73166: LIST
73167: LIST
73168: LIST
73169: LIST
73170: LIST
73171: LIST
73172: LIST
73173: LIST
73174: LIST
73175: LIST
73176: LIST
73177: LIST
73178: LIST
73179: LIST
73180: LIST
73181: LIST
73182: LIST
73183: LIST
73184: LIST
73185: LIST
73186: LIST
73187: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73188: LD_ADDR_VAR 0 44
73192: PUSH
73193: LD_INT 0
73195: PUSH
73196: LD_INT 0
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: PUSH
73203: LD_INT 0
73205: PUSH
73206: LD_INT 1
73208: NEG
73209: PUSH
73210: EMPTY
73211: LIST
73212: LIST
73213: PUSH
73214: LD_INT 1
73216: PUSH
73217: LD_INT 0
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 1
73226: PUSH
73227: LD_INT 1
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 0
73236: PUSH
73237: LD_INT 1
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 1
73246: NEG
73247: PUSH
73248: LD_INT 0
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 1
73257: NEG
73258: PUSH
73259: LD_INT 1
73261: NEG
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: PUSH
73267: LD_INT 1
73269: NEG
73270: PUSH
73271: LD_INT 2
73273: NEG
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: LD_INT 1
73281: PUSH
73282: LD_INT 1
73284: NEG
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 2
73292: PUSH
73293: LD_INT 0
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: LD_INT 2
73302: PUSH
73303: LD_INT 1
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 2
73312: PUSH
73313: LD_INT 2
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: LD_INT 1
73322: PUSH
73323: LD_INT 2
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 1
73332: NEG
73333: PUSH
73334: LD_INT 1
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: LD_INT 2
73343: NEG
73344: PUSH
73345: LD_INT 0
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 2
73354: NEG
73355: PUSH
73356: LD_INT 1
73358: NEG
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: LD_INT 2
73366: NEG
73367: PUSH
73368: LD_INT 2
73370: NEG
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 2
73378: NEG
73379: PUSH
73380: LD_INT 3
73382: NEG
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 2
73390: PUSH
73391: LD_INT 1
73393: NEG
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 3
73401: PUSH
73402: LD_INT 0
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 3
73411: PUSH
73412: LD_INT 1
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PUSH
73419: LD_INT 3
73421: PUSH
73422: LD_INT 2
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 3
73431: PUSH
73432: LD_INT 3
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PUSH
73439: LD_INT 2
73441: PUSH
73442: LD_INT 3
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 2
73451: NEG
73452: PUSH
73453: LD_INT 1
73455: PUSH
73456: EMPTY
73457: LIST
73458: LIST
73459: PUSH
73460: LD_INT 3
73462: NEG
73463: PUSH
73464: LD_INT 0
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 3
73473: NEG
73474: PUSH
73475: LD_INT 1
73477: NEG
73478: PUSH
73479: EMPTY
73480: LIST
73481: LIST
73482: PUSH
73483: LD_INT 3
73485: NEG
73486: PUSH
73487: LD_INT 2
73489: NEG
73490: PUSH
73491: EMPTY
73492: LIST
73493: LIST
73494: PUSH
73495: LD_INT 3
73497: NEG
73498: PUSH
73499: LD_INT 3
73501: NEG
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: PUSH
73507: EMPTY
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73538: LD_ADDR_VAR 0 45
73542: PUSH
73543: LD_INT 0
73545: PUSH
73546: LD_INT 0
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PUSH
73553: LD_INT 0
73555: PUSH
73556: LD_INT 1
73558: NEG
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: LD_INT 1
73566: PUSH
73567: LD_INT 0
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 1
73576: PUSH
73577: LD_INT 1
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: PUSH
73584: LD_INT 0
73586: PUSH
73587: LD_INT 1
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 1
73596: NEG
73597: PUSH
73598: LD_INT 0
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 1
73607: NEG
73608: PUSH
73609: LD_INT 1
73611: NEG
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 1
73619: NEG
73620: PUSH
73621: LD_INT 2
73623: NEG
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 0
73631: PUSH
73632: LD_INT 2
73634: NEG
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: PUSH
73640: LD_INT 1
73642: PUSH
73643: LD_INT 1
73645: NEG
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 2
73653: PUSH
73654: LD_INT 1
73656: PUSH
73657: EMPTY
73658: LIST
73659: LIST
73660: PUSH
73661: LD_INT 2
73663: PUSH
73664: LD_INT 2
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 1
73673: PUSH
73674: LD_INT 2
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PUSH
73681: LD_INT 0
73683: PUSH
73684: LD_INT 2
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: PUSH
73691: LD_INT 1
73693: NEG
73694: PUSH
73695: LD_INT 1
73697: PUSH
73698: EMPTY
73699: LIST
73700: LIST
73701: PUSH
73702: LD_INT 2
73704: NEG
73705: PUSH
73706: LD_INT 1
73708: NEG
73709: PUSH
73710: EMPTY
73711: LIST
73712: LIST
73713: PUSH
73714: LD_INT 2
73716: NEG
73717: PUSH
73718: LD_INT 2
73720: NEG
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 2
73728: NEG
73729: PUSH
73730: LD_INT 3
73732: NEG
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 1
73740: NEG
73741: PUSH
73742: LD_INT 3
73744: NEG
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: LD_INT 0
73752: PUSH
73753: LD_INT 3
73755: NEG
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: LD_INT 1
73763: PUSH
73764: LD_INT 2
73766: NEG
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 3
73774: PUSH
73775: LD_INT 2
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 3
73784: PUSH
73785: LD_INT 3
73787: PUSH
73788: EMPTY
73789: LIST
73790: LIST
73791: PUSH
73792: LD_INT 2
73794: PUSH
73795: LD_INT 3
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: PUSH
73802: LD_INT 1
73804: PUSH
73805: LD_INT 3
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 0
73814: PUSH
73815: LD_INT 3
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: PUSH
73822: LD_INT 1
73824: NEG
73825: PUSH
73826: LD_INT 2
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: PUSH
73833: LD_INT 3
73835: NEG
73836: PUSH
73837: LD_INT 2
73839: NEG
73840: PUSH
73841: EMPTY
73842: LIST
73843: LIST
73844: PUSH
73845: LD_INT 3
73847: NEG
73848: PUSH
73849: LD_INT 3
73851: NEG
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: LIST
73861: LIST
73862: LIST
73863: LIST
73864: LIST
73865: LIST
73866: LIST
73867: LIST
73868: LIST
73869: LIST
73870: LIST
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: LIST
73877: LIST
73878: LIST
73879: LIST
73880: LIST
73881: LIST
73882: LIST
73883: LIST
73884: LIST
73885: LIST
73886: LIST
73887: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73888: LD_ADDR_VAR 0 46
73892: PUSH
73893: LD_INT 0
73895: PUSH
73896: LD_INT 0
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 0
73905: PUSH
73906: LD_INT 1
73908: NEG
73909: PUSH
73910: EMPTY
73911: LIST
73912: LIST
73913: PUSH
73914: LD_INT 1
73916: PUSH
73917: LD_INT 0
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PUSH
73924: LD_INT 1
73926: PUSH
73927: LD_INT 1
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: PUSH
73934: LD_INT 0
73936: PUSH
73937: LD_INT 1
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: PUSH
73944: LD_INT 1
73946: NEG
73947: PUSH
73948: LD_INT 0
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: PUSH
73955: LD_INT 1
73957: NEG
73958: PUSH
73959: LD_INT 1
73961: NEG
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: PUSH
73967: LD_INT 1
73969: NEG
73970: PUSH
73971: LD_INT 2
73973: NEG
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: LD_INT 0
73981: PUSH
73982: LD_INT 2
73984: NEG
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: LD_INT 1
73992: PUSH
73993: LD_INT 1
73995: NEG
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 2
74003: PUSH
74004: LD_INT 0
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: LD_INT 2
74013: PUSH
74014: LD_INT 1
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: LD_INT 1
74023: PUSH
74024: LD_INT 2
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 0
74033: PUSH
74034: LD_INT 2
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 1
74043: NEG
74044: PUSH
74045: LD_INT 1
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: LD_INT 2
74054: NEG
74055: PUSH
74056: LD_INT 0
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: PUSH
74063: LD_INT 2
74065: NEG
74066: PUSH
74067: LD_INT 1
74069: NEG
74070: PUSH
74071: EMPTY
74072: LIST
74073: LIST
74074: PUSH
74075: LD_INT 1
74077: NEG
74078: PUSH
74079: LD_INT 3
74081: NEG
74082: PUSH
74083: EMPTY
74084: LIST
74085: LIST
74086: PUSH
74087: LD_INT 0
74089: PUSH
74090: LD_INT 3
74092: NEG
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 1
74100: PUSH
74101: LD_INT 2
74103: NEG
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PUSH
74109: LD_INT 2
74111: PUSH
74112: LD_INT 1
74114: NEG
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 3
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 3
74132: PUSH
74133: LD_INT 1
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 1
74142: PUSH
74143: LD_INT 3
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: LD_INT 0
74152: PUSH
74153: LD_INT 3
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 1
74162: NEG
74163: PUSH
74164: LD_INT 2
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 2
74173: NEG
74174: PUSH
74175: LD_INT 1
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: PUSH
74182: LD_INT 3
74184: NEG
74185: PUSH
74186: LD_INT 0
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: LD_INT 3
74195: NEG
74196: PUSH
74197: LD_INT 1
74199: NEG
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: PUSH
74205: EMPTY
74206: LIST
74207: LIST
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: LIST
74218: LIST
74219: LIST
74220: LIST
74221: LIST
74222: LIST
74223: LIST
74224: LIST
74225: LIST
74226: LIST
74227: LIST
74228: LIST
74229: LIST
74230: LIST
74231: LIST
74232: LIST
74233: LIST
74234: LIST
74235: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74236: LD_ADDR_VAR 0 47
74240: PUSH
74241: LD_INT 0
74243: PUSH
74244: LD_INT 0
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: PUSH
74251: LD_INT 0
74253: PUSH
74254: LD_INT 1
74256: NEG
74257: PUSH
74258: EMPTY
74259: LIST
74260: LIST
74261: PUSH
74262: LD_INT 1
74264: PUSH
74265: LD_INT 0
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 1
74274: PUSH
74275: LD_INT 1
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: LD_INT 0
74284: PUSH
74285: LD_INT 1
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 1
74294: NEG
74295: PUSH
74296: LD_INT 0
74298: PUSH
74299: EMPTY
74300: LIST
74301: LIST
74302: PUSH
74303: LD_INT 1
74305: NEG
74306: PUSH
74307: LD_INT 1
74309: NEG
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: PUSH
74315: LD_INT 1
74317: NEG
74318: PUSH
74319: LD_INT 2
74321: NEG
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: LD_INT 0
74329: PUSH
74330: LD_INT 2
74332: NEG
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PUSH
74338: LD_INT 1
74340: PUSH
74341: LD_INT 1
74343: NEG
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: LD_INT 2
74351: NEG
74352: PUSH
74353: LD_INT 1
74355: NEG
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: PUSH
74361: LD_INT 2
74363: NEG
74364: PUSH
74365: LD_INT 2
74367: NEG
74368: PUSH
74369: EMPTY
74370: LIST
74371: LIST
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: LIST
74377: LIST
74378: LIST
74379: LIST
74380: LIST
74381: LIST
74382: LIST
74383: LIST
74384: LIST
74385: LIST
74386: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74387: LD_ADDR_VAR 0 48
74391: PUSH
74392: LD_INT 0
74394: PUSH
74395: LD_INT 0
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: LD_INT 0
74404: PUSH
74405: LD_INT 1
74407: NEG
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: LD_INT 1
74415: PUSH
74416: LD_INT 0
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: LD_INT 1
74425: PUSH
74426: LD_INT 1
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PUSH
74433: LD_INT 0
74435: PUSH
74436: LD_INT 1
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: LD_INT 1
74445: NEG
74446: PUSH
74447: LD_INT 0
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: PUSH
74454: LD_INT 1
74456: NEG
74457: PUSH
74458: LD_INT 1
74460: NEG
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PUSH
74466: LD_INT 1
74468: NEG
74469: PUSH
74470: LD_INT 2
74472: NEG
74473: PUSH
74474: EMPTY
74475: LIST
74476: LIST
74477: PUSH
74478: LD_INT 0
74480: PUSH
74481: LD_INT 2
74483: NEG
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 1
74491: PUSH
74492: LD_INT 1
74494: NEG
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: LD_INT 2
74502: PUSH
74503: LD_INT 0
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: LD_INT 2
74512: PUSH
74513: LD_INT 1
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: LIST
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: LIST
74529: LIST
74530: LIST
74531: LIST
74532: LIST
74533: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74534: LD_ADDR_VAR 0 49
74538: PUSH
74539: LD_INT 0
74541: PUSH
74542: LD_INT 0
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: PUSH
74549: LD_INT 0
74551: PUSH
74552: LD_INT 1
74554: NEG
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: LD_INT 1
74562: PUSH
74563: LD_INT 0
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PUSH
74570: LD_INT 1
74572: PUSH
74573: LD_INT 1
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: PUSH
74580: LD_INT 0
74582: PUSH
74583: LD_INT 1
74585: PUSH
74586: EMPTY
74587: LIST
74588: LIST
74589: PUSH
74590: LD_INT 1
74592: NEG
74593: PUSH
74594: LD_INT 0
74596: PUSH
74597: EMPTY
74598: LIST
74599: LIST
74600: PUSH
74601: LD_INT 1
74603: NEG
74604: PUSH
74605: LD_INT 1
74607: NEG
74608: PUSH
74609: EMPTY
74610: LIST
74611: LIST
74612: PUSH
74613: LD_INT 1
74615: PUSH
74616: LD_INT 1
74618: NEG
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: PUSH
74624: LD_INT 2
74626: PUSH
74627: LD_INT 0
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: PUSH
74634: LD_INT 2
74636: PUSH
74637: LD_INT 1
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 2
74646: PUSH
74647: LD_INT 2
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 1
74656: PUSH
74657: LD_INT 2
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: EMPTY
74665: LIST
74666: LIST
74667: LIST
74668: LIST
74669: LIST
74670: LIST
74671: LIST
74672: LIST
74673: LIST
74674: LIST
74675: LIST
74676: LIST
74677: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74678: LD_ADDR_VAR 0 50
74682: PUSH
74683: LD_INT 0
74685: PUSH
74686: LD_INT 0
74688: PUSH
74689: EMPTY
74690: LIST
74691: LIST
74692: PUSH
74693: LD_INT 0
74695: PUSH
74696: LD_INT 1
74698: NEG
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: PUSH
74704: LD_INT 1
74706: PUSH
74707: LD_INT 0
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PUSH
74714: LD_INT 1
74716: PUSH
74717: LD_INT 1
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 0
74726: PUSH
74727: LD_INT 1
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: PUSH
74734: LD_INT 1
74736: NEG
74737: PUSH
74738: LD_INT 0
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: LD_INT 1
74747: NEG
74748: PUSH
74749: LD_INT 1
74751: NEG
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PUSH
74757: LD_INT 2
74759: PUSH
74760: LD_INT 1
74762: PUSH
74763: EMPTY
74764: LIST
74765: LIST
74766: PUSH
74767: LD_INT 2
74769: PUSH
74770: LD_INT 2
74772: PUSH
74773: EMPTY
74774: LIST
74775: LIST
74776: PUSH
74777: LD_INT 1
74779: PUSH
74780: LD_INT 2
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: PUSH
74787: LD_INT 0
74789: PUSH
74790: LD_INT 2
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 1
74799: NEG
74800: PUSH
74801: LD_INT 1
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: LIST
74812: LIST
74813: LIST
74814: LIST
74815: LIST
74816: LIST
74817: LIST
74818: LIST
74819: LIST
74820: LIST
74821: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74822: LD_ADDR_VAR 0 51
74826: PUSH
74827: LD_INT 0
74829: PUSH
74830: LD_INT 0
74832: PUSH
74833: EMPTY
74834: LIST
74835: LIST
74836: PUSH
74837: LD_INT 0
74839: PUSH
74840: LD_INT 1
74842: NEG
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: LD_INT 1
74850: PUSH
74851: LD_INT 0
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: PUSH
74858: LD_INT 1
74860: PUSH
74861: LD_INT 1
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PUSH
74868: LD_INT 0
74870: PUSH
74871: LD_INT 1
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: LD_INT 1
74880: NEG
74881: PUSH
74882: LD_INT 0
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: PUSH
74889: LD_INT 1
74891: NEG
74892: PUSH
74893: LD_INT 1
74895: NEG
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 1
74903: PUSH
74904: LD_INT 2
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PUSH
74911: LD_INT 0
74913: PUSH
74914: LD_INT 2
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: PUSH
74921: LD_INT 1
74923: NEG
74924: PUSH
74925: LD_INT 1
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: PUSH
74932: LD_INT 2
74934: NEG
74935: PUSH
74936: LD_INT 0
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: LD_INT 2
74945: NEG
74946: PUSH
74947: LD_INT 1
74949: NEG
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: EMPTY
74956: LIST
74957: LIST
74958: LIST
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: LIST
74968: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74969: LD_ADDR_VAR 0 52
74973: PUSH
74974: LD_INT 0
74976: PUSH
74977: LD_INT 0
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 0
74986: PUSH
74987: LD_INT 1
74989: NEG
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 1
74997: PUSH
74998: LD_INT 0
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: LD_INT 1
75007: PUSH
75008: LD_INT 1
75010: PUSH
75011: EMPTY
75012: LIST
75013: LIST
75014: PUSH
75015: LD_INT 0
75017: PUSH
75018: LD_INT 1
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PUSH
75025: LD_INT 1
75027: NEG
75028: PUSH
75029: LD_INT 0
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: LD_INT 1
75038: NEG
75039: PUSH
75040: LD_INT 1
75042: NEG
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PUSH
75048: LD_INT 1
75050: NEG
75051: PUSH
75052: LD_INT 2
75054: NEG
75055: PUSH
75056: EMPTY
75057: LIST
75058: LIST
75059: PUSH
75060: LD_INT 1
75062: NEG
75063: PUSH
75064: LD_INT 1
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: LD_INT 2
75073: NEG
75074: PUSH
75075: LD_INT 0
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 2
75084: NEG
75085: PUSH
75086: LD_INT 1
75088: NEG
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: LD_INT 2
75096: NEG
75097: PUSH
75098: LD_INT 2
75100: NEG
75101: PUSH
75102: EMPTY
75103: LIST
75104: LIST
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: LIST
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: LIST
75119: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75120: LD_ADDR_VAR 0 53
75124: PUSH
75125: LD_INT 0
75127: PUSH
75128: LD_INT 0
75130: PUSH
75131: EMPTY
75132: LIST
75133: LIST
75134: PUSH
75135: LD_INT 0
75137: PUSH
75138: LD_INT 1
75140: NEG
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 1
75148: PUSH
75149: LD_INT 0
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: LD_INT 1
75158: PUSH
75159: LD_INT 1
75161: PUSH
75162: EMPTY
75163: LIST
75164: LIST
75165: PUSH
75166: LD_INT 0
75168: PUSH
75169: LD_INT 1
75171: PUSH
75172: EMPTY
75173: LIST
75174: LIST
75175: PUSH
75176: LD_INT 1
75178: NEG
75179: PUSH
75180: LD_INT 0
75182: PUSH
75183: EMPTY
75184: LIST
75185: LIST
75186: PUSH
75187: LD_INT 1
75189: NEG
75190: PUSH
75191: LD_INT 1
75193: NEG
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 1
75201: NEG
75202: PUSH
75203: LD_INT 2
75205: NEG
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PUSH
75211: LD_INT 0
75213: PUSH
75214: LD_INT 2
75216: NEG
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: PUSH
75222: LD_INT 1
75224: PUSH
75225: LD_INT 1
75227: NEG
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 2
75235: PUSH
75236: LD_INT 0
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 2
75245: PUSH
75246: LD_INT 1
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: LD_INT 2
75255: PUSH
75256: LD_INT 2
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: PUSH
75263: LD_INT 1
75265: PUSH
75266: LD_INT 2
75268: PUSH
75269: EMPTY
75270: LIST
75271: LIST
75272: PUSH
75273: LD_INT 0
75275: PUSH
75276: LD_INT 2
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: PUSH
75283: LD_INT 1
75285: NEG
75286: PUSH
75287: LD_INT 1
75289: PUSH
75290: EMPTY
75291: LIST
75292: LIST
75293: PUSH
75294: LD_INT 2
75296: NEG
75297: PUSH
75298: LD_INT 0
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 2
75307: NEG
75308: PUSH
75309: LD_INT 1
75311: NEG
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: PUSH
75317: LD_INT 2
75319: NEG
75320: PUSH
75321: LD_INT 2
75323: NEG
75324: PUSH
75325: EMPTY
75326: LIST
75327: LIST
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: LIST
75333: LIST
75334: LIST
75335: LIST
75336: LIST
75337: LIST
75338: LIST
75339: LIST
75340: LIST
75341: LIST
75342: LIST
75343: LIST
75344: LIST
75345: LIST
75346: LIST
75347: LIST
75348: LIST
75349: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75350: LD_ADDR_VAR 0 54
75354: PUSH
75355: LD_INT 0
75357: PUSH
75358: LD_INT 0
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: LD_INT 0
75367: PUSH
75368: LD_INT 1
75370: NEG
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 1
75378: PUSH
75379: LD_INT 0
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 1
75388: PUSH
75389: LD_INT 1
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: LD_INT 0
75398: PUSH
75399: LD_INT 1
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: PUSH
75406: LD_INT 1
75408: NEG
75409: PUSH
75410: LD_INT 0
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: LD_INT 1
75419: NEG
75420: PUSH
75421: LD_INT 1
75423: NEG
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: PUSH
75429: LD_INT 1
75431: NEG
75432: PUSH
75433: LD_INT 2
75435: NEG
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: PUSH
75441: LD_INT 0
75443: PUSH
75444: LD_INT 2
75446: NEG
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: LD_INT 1
75454: PUSH
75455: LD_INT 1
75457: NEG
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 2
75465: PUSH
75466: LD_INT 0
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: LD_INT 2
75475: PUSH
75476: LD_INT 1
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 2
75485: PUSH
75486: LD_INT 2
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PUSH
75493: LD_INT 1
75495: PUSH
75496: LD_INT 2
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: PUSH
75503: LD_INT 0
75505: PUSH
75506: LD_INT 2
75508: PUSH
75509: EMPTY
75510: LIST
75511: LIST
75512: PUSH
75513: LD_INT 1
75515: NEG
75516: PUSH
75517: LD_INT 1
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 2
75526: NEG
75527: PUSH
75528: LD_INT 0
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 2
75537: NEG
75538: PUSH
75539: LD_INT 1
75541: NEG
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PUSH
75547: LD_INT 2
75549: NEG
75550: PUSH
75551: LD_INT 2
75553: NEG
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: LIST
75563: LIST
75564: LIST
75565: LIST
75566: LIST
75567: LIST
75568: LIST
75569: LIST
75570: LIST
75571: LIST
75572: LIST
75573: LIST
75574: LIST
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75580: LD_ADDR_VAR 0 55
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: LD_INT 0
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 0
75597: PUSH
75598: LD_INT 1
75600: NEG
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: LD_INT 1
75608: PUSH
75609: LD_INT 0
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 1
75618: PUSH
75619: LD_INT 1
75621: PUSH
75622: EMPTY
75623: LIST
75624: LIST
75625: PUSH
75626: LD_INT 0
75628: PUSH
75629: LD_INT 1
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: PUSH
75636: LD_INT 1
75638: NEG
75639: PUSH
75640: LD_INT 0
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: PUSH
75647: LD_INT 1
75649: NEG
75650: PUSH
75651: LD_INT 1
75653: NEG
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 1
75661: NEG
75662: PUSH
75663: LD_INT 2
75665: NEG
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: PUSH
75671: LD_INT 0
75673: PUSH
75674: LD_INT 2
75676: NEG
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 1
75684: PUSH
75685: LD_INT 1
75687: NEG
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 2
75695: PUSH
75696: LD_INT 0
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: LD_INT 2
75705: PUSH
75706: LD_INT 1
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: LD_INT 2
75715: PUSH
75716: LD_INT 2
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: PUSH
75723: LD_INT 1
75725: PUSH
75726: LD_INT 2
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 0
75735: PUSH
75736: LD_INT 2
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: PUSH
75743: LD_INT 1
75745: NEG
75746: PUSH
75747: LD_INT 1
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: PUSH
75754: LD_INT 2
75756: NEG
75757: PUSH
75758: LD_INT 0
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 2
75767: NEG
75768: PUSH
75769: LD_INT 1
75771: NEG
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: PUSH
75777: LD_INT 2
75779: NEG
75780: PUSH
75781: LD_INT 2
75783: NEG
75784: PUSH
75785: EMPTY
75786: LIST
75787: LIST
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: LIST
75793: LIST
75794: LIST
75795: LIST
75796: LIST
75797: LIST
75798: LIST
75799: LIST
75800: LIST
75801: LIST
75802: LIST
75803: LIST
75804: LIST
75805: LIST
75806: LIST
75807: LIST
75808: LIST
75809: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75810: LD_ADDR_VAR 0 56
75814: PUSH
75815: LD_INT 0
75817: PUSH
75818: LD_INT 0
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_INT 0
75827: PUSH
75828: LD_INT 1
75830: NEG
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 1
75838: PUSH
75839: LD_INT 0
75841: PUSH
75842: EMPTY
75843: LIST
75844: LIST
75845: PUSH
75846: LD_INT 1
75848: PUSH
75849: LD_INT 1
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: PUSH
75856: LD_INT 0
75858: PUSH
75859: LD_INT 1
75861: PUSH
75862: EMPTY
75863: LIST
75864: LIST
75865: PUSH
75866: LD_INT 1
75868: NEG
75869: PUSH
75870: LD_INT 0
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PUSH
75877: LD_INT 1
75879: NEG
75880: PUSH
75881: LD_INT 1
75883: NEG
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: PUSH
75889: LD_INT 1
75891: NEG
75892: PUSH
75893: LD_INT 2
75895: NEG
75896: PUSH
75897: EMPTY
75898: LIST
75899: LIST
75900: PUSH
75901: LD_INT 0
75903: PUSH
75904: LD_INT 2
75906: NEG
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 1
75914: PUSH
75915: LD_INT 1
75917: NEG
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 2
75925: PUSH
75926: LD_INT 0
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: PUSH
75933: LD_INT 2
75935: PUSH
75936: LD_INT 1
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 2
75945: PUSH
75946: LD_INT 2
75948: PUSH
75949: EMPTY
75950: LIST
75951: LIST
75952: PUSH
75953: LD_INT 1
75955: PUSH
75956: LD_INT 2
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: LD_INT 0
75965: PUSH
75966: LD_INT 2
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: PUSH
75973: LD_INT 1
75975: NEG
75976: PUSH
75977: LD_INT 1
75979: PUSH
75980: EMPTY
75981: LIST
75982: LIST
75983: PUSH
75984: LD_INT 2
75986: NEG
75987: PUSH
75988: LD_INT 0
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 2
75997: NEG
75998: PUSH
75999: LD_INT 1
76001: NEG
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 2
76009: NEG
76010: PUSH
76011: LD_INT 2
76013: NEG
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: LIST
76023: LIST
76024: LIST
76025: LIST
76026: LIST
76027: LIST
76028: LIST
76029: LIST
76030: LIST
76031: LIST
76032: LIST
76033: LIST
76034: LIST
76035: LIST
76036: LIST
76037: LIST
76038: LIST
76039: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76040: LD_ADDR_VAR 0 57
76044: PUSH
76045: LD_INT 0
76047: PUSH
76048: LD_INT 0
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PUSH
76055: LD_INT 0
76057: PUSH
76058: LD_INT 1
76060: NEG
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: PUSH
76066: LD_INT 1
76068: PUSH
76069: LD_INT 0
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: LD_INT 1
76078: PUSH
76079: LD_INT 1
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: PUSH
76086: LD_INT 0
76088: PUSH
76089: LD_INT 1
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: PUSH
76096: LD_INT 1
76098: NEG
76099: PUSH
76100: LD_INT 0
76102: PUSH
76103: EMPTY
76104: LIST
76105: LIST
76106: PUSH
76107: LD_INT 1
76109: NEG
76110: PUSH
76111: LD_INT 1
76113: NEG
76114: PUSH
76115: EMPTY
76116: LIST
76117: LIST
76118: PUSH
76119: LD_INT 1
76121: NEG
76122: PUSH
76123: LD_INT 2
76125: NEG
76126: PUSH
76127: EMPTY
76128: LIST
76129: LIST
76130: PUSH
76131: LD_INT 0
76133: PUSH
76134: LD_INT 2
76136: NEG
76137: PUSH
76138: EMPTY
76139: LIST
76140: LIST
76141: PUSH
76142: LD_INT 1
76144: PUSH
76145: LD_INT 1
76147: NEG
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 2
76155: PUSH
76156: LD_INT 0
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: PUSH
76163: LD_INT 2
76165: PUSH
76166: LD_INT 1
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 2
76175: PUSH
76176: LD_INT 2
76178: PUSH
76179: EMPTY
76180: LIST
76181: LIST
76182: PUSH
76183: LD_INT 1
76185: PUSH
76186: LD_INT 2
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: PUSH
76193: LD_INT 0
76195: PUSH
76196: LD_INT 2
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: PUSH
76203: LD_INT 1
76205: NEG
76206: PUSH
76207: LD_INT 1
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: LD_INT 2
76216: NEG
76217: PUSH
76218: LD_INT 0
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: LD_INT 2
76227: NEG
76228: PUSH
76229: LD_INT 1
76231: NEG
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 2
76239: NEG
76240: PUSH
76241: LD_INT 2
76243: NEG
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: LIST
76257: LIST
76258: LIST
76259: LIST
76260: LIST
76261: LIST
76262: LIST
76263: LIST
76264: LIST
76265: LIST
76266: LIST
76267: LIST
76268: LIST
76269: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76270: LD_ADDR_VAR 0 58
76274: PUSH
76275: LD_INT 0
76277: PUSH
76278: LD_INT 0
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 0
76287: PUSH
76288: LD_INT 1
76290: NEG
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 1
76298: PUSH
76299: LD_INT 0
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: LD_INT 1
76308: PUSH
76309: LD_INT 1
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 0
76318: PUSH
76319: LD_INT 1
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: LD_INT 1
76328: NEG
76329: PUSH
76330: LD_INT 0
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 1
76339: NEG
76340: PUSH
76341: LD_INT 1
76343: NEG
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 1
76351: NEG
76352: PUSH
76353: LD_INT 2
76355: NEG
76356: PUSH
76357: EMPTY
76358: LIST
76359: LIST
76360: PUSH
76361: LD_INT 0
76363: PUSH
76364: LD_INT 2
76366: NEG
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: LD_INT 1
76374: PUSH
76375: LD_INT 1
76377: NEG
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PUSH
76383: LD_INT 2
76385: PUSH
76386: LD_INT 0
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: PUSH
76393: LD_INT 2
76395: PUSH
76396: LD_INT 1
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 2
76405: PUSH
76406: LD_INT 2
76408: PUSH
76409: EMPTY
76410: LIST
76411: LIST
76412: PUSH
76413: LD_INT 1
76415: PUSH
76416: LD_INT 2
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: LD_INT 0
76425: PUSH
76426: LD_INT 2
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: LD_INT 1
76435: NEG
76436: PUSH
76437: LD_INT 1
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 2
76446: NEG
76447: PUSH
76448: LD_INT 0
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PUSH
76455: LD_INT 2
76457: NEG
76458: PUSH
76459: LD_INT 1
76461: NEG
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: LD_INT 2
76469: NEG
76470: PUSH
76471: LD_INT 2
76473: NEG
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: LIST
76483: LIST
76484: LIST
76485: LIST
76486: LIST
76487: LIST
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: LIST
76493: LIST
76494: LIST
76495: LIST
76496: LIST
76497: LIST
76498: LIST
76499: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76500: LD_ADDR_VAR 0 59
76504: PUSH
76505: LD_INT 0
76507: PUSH
76508: LD_INT 0
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PUSH
76515: LD_INT 0
76517: PUSH
76518: LD_INT 1
76520: NEG
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PUSH
76526: LD_INT 1
76528: PUSH
76529: LD_INT 0
76531: PUSH
76532: EMPTY
76533: LIST
76534: LIST
76535: PUSH
76536: LD_INT 1
76538: PUSH
76539: LD_INT 1
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: LD_INT 0
76548: PUSH
76549: LD_INT 1
76551: PUSH
76552: EMPTY
76553: LIST
76554: LIST
76555: PUSH
76556: LD_INT 1
76558: NEG
76559: PUSH
76560: LD_INT 0
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 1
76569: NEG
76570: PUSH
76571: LD_INT 1
76573: NEG
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: LIST
76583: LIST
76584: LIST
76585: LIST
76586: LIST
76587: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76588: LD_ADDR_VAR 0 60
76592: PUSH
76593: LD_INT 0
76595: PUSH
76596: LD_INT 0
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PUSH
76603: LD_INT 0
76605: PUSH
76606: LD_INT 1
76608: NEG
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: LD_INT 1
76616: PUSH
76617: LD_INT 0
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PUSH
76624: LD_INT 1
76626: PUSH
76627: LD_INT 1
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PUSH
76634: LD_INT 0
76636: PUSH
76637: LD_INT 1
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 1
76646: NEG
76647: PUSH
76648: LD_INT 0
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: LD_INT 1
76657: NEG
76658: PUSH
76659: LD_INT 1
76661: NEG
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76676: LD_ADDR_VAR 0 61
76680: PUSH
76681: LD_INT 0
76683: PUSH
76684: LD_INT 0
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: PUSH
76691: LD_INT 0
76693: PUSH
76694: LD_INT 1
76696: NEG
76697: PUSH
76698: EMPTY
76699: LIST
76700: LIST
76701: PUSH
76702: LD_INT 1
76704: PUSH
76705: LD_INT 0
76707: PUSH
76708: EMPTY
76709: LIST
76710: LIST
76711: PUSH
76712: LD_INT 1
76714: PUSH
76715: LD_INT 1
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PUSH
76722: LD_INT 0
76724: PUSH
76725: LD_INT 1
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 1
76734: NEG
76735: PUSH
76736: LD_INT 0
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: PUSH
76743: LD_INT 1
76745: NEG
76746: PUSH
76747: LD_INT 1
76749: NEG
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: PUSH
76755: EMPTY
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: LIST
76763: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76764: LD_ADDR_VAR 0 62
76768: PUSH
76769: LD_INT 0
76771: PUSH
76772: LD_INT 0
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: LD_INT 0
76781: PUSH
76782: LD_INT 1
76784: NEG
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: PUSH
76790: LD_INT 1
76792: PUSH
76793: LD_INT 0
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: PUSH
76800: LD_INT 1
76802: PUSH
76803: LD_INT 1
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: PUSH
76810: LD_INT 0
76812: PUSH
76813: LD_INT 1
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: LD_INT 1
76822: NEG
76823: PUSH
76824: LD_INT 0
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PUSH
76831: LD_INT 1
76833: NEG
76834: PUSH
76835: LD_INT 1
76837: NEG
76838: PUSH
76839: EMPTY
76840: LIST
76841: LIST
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: LIST
76847: LIST
76848: LIST
76849: LIST
76850: LIST
76851: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76852: LD_ADDR_VAR 0 63
76856: PUSH
76857: LD_INT 0
76859: PUSH
76860: LD_INT 0
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: LD_INT 0
76869: PUSH
76870: LD_INT 1
76872: NEG
76873: PUSH
76874: EMPTY
76875: LIST
76876: LIST
76877: PUSH
76878: LD_INT 1
76880: PUSH
76881: LD_INT 0
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: PUSH
76888: LD_INT 1
76890: PUSH
76891: LD_INT 1
76893: PUSH
76894: EMPTY
76895: LIST
76896: LIST
76897: PUSH
76898: LD_INT 0
76900: PUSH
76901: LD_INT 1
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: PUSH
76908: LD_INT 1
76910: NEG
76911: PUSH
76912: LD_INT 0
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: LD_INT 1
76921: NEG
76922: PUSH
76923: LD_INT 1
76925: NEG
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: LIST
76935: LIST
76936: LIST
76937: LIST
76938: LIST
76939: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76940: LD_ADDR_VAR 0 64
76944: PUSH
76945: LD_INT 0
76947: PUSH
76948: LD_INT 0
76950: PUSH
76951: EMPTY
76952: LIST
76953: LIST
76954: PUSH
76955: LD_INT 0
76957: PUSH
76958: LD_INT 1
76960: NEG
76961: PUSH
76962: EMPTY
76963: LIST
76964: LIST
76965: PUSH
76966: LD_INT 1
76968: PUSH
76969: LD_INT 0
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: LD_INT 1
76978: PUSH
76979: LD_INT 1
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: PUSH
76986: LD_INT 0
76988: PUSH
76989: LD_INT 1
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PUSH
76996: LD_INT 1
76998: NEG
76999: PUSH
77000: LD_INT 0
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: PUSH
77007: LD_INT 1
77009: NEG
77010: PUSH
77011: LD_INT 1
77013: NEG
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: LIST
77023: LIST
77024: LIST
77025: LIST
77026: LIST
77027: ST_TO_ADDR
// end ; 1 :
77028: GO 82925
77030: LD_INT 1
77032: DOUBLE
77033: EQUAL
77034: IFTRUE 77038
77036: GO 79661
77038: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77039: LD_ADDR_VAR 0 11
77043: PUSH
77044: LD_INT 1
77046: NEG
77047: PUSH
77048: LD_INT 3
77050: NEG
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 0
77058: PUSH
77059: LD_INT 3
77061: NEG
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 1
77069: PUSH
77070: LD_INT 2
77072: NEG
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: LIST
77082: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77083: LD_ADDR_VAR 0 12
77087: PUSH
77088: LD_INT 2
77090: PUSH
77091: LD_INT 1
77093: NEG
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 3
77101: PUSH
77102: LD_INT 0
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: LD_INT 3
77111: PUSH
77112: LD_INT 1
77114: PUSH
77115: EMPTY
77116: LIST
77117: LIST
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: LIST
77123: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77124: LD_ADDR_VAR 0 13
77128: PUSH
77129: LD_INT 3
77131: PUSH
77132: LD_INT 2
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: PUSH
77139: LD_INT 3
77141: PUSH
77142: LD_INT 3
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 2
77151: PUSH
77152: LD_INT 3
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: LIST
77163: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77164: LD_ADDR_VAR 0 14
77168: PUSH
77169: LD_INT 1
77171: PUSH
77172: LD_INT 3
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 0
77181: PUSH
77182: LD_INT 3
77184: PUSH
77185: EMPTY
77186: LIST
77187: LIST
77188: PUSH
77189: LD_INT 1
77191: NEG
77192: PUSH
77193: LD_INT 2
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: LIST
77204: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77205: LD_ADDR_VAR 0 15
77209: PUSH
77210: LD_INT 2
77212: NEG
77213: PUSH
77214: LD_INT 1
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PUSH
77221: LD_INT 3
77223: NEG
77224: PUSH
77225: LD_INT 0
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: PUSH
77232: LD_INT 3
77234: NEG
77235: PUSH
77236: LD_INT 1
77238: NEG
77239: PUSH
77240: EMPTY
77241: LIST
77242: LIST
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: LIST
77248: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77249: LD_ADDR_VAR 0 16
77253: PUSH
77254: LD_INT 2
77256: NEG
77257: PUSH
77258: LD_INT 3
77260: NEG
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: LD_INT 3
77268: NEG
77269: PUSH
77270: LD_INT 2
77272: NEG
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: PUSH
77278: LD_INT 3
77280: NEG
77281: PUSH
77282: LD_INT 3
77284: NEG
77285: PUSH
77286: EMPTY
77287: LIST
77288: LIST
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: LIST
77294: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77295: LD_ADDR_VAR 0 17
77299: PUSH
77300: LD_INT 1
77302: NEG
77303: PUSH
77304: LD_INT 3
77306: NEG
77307: PUSH
77308: EMPTY
77309: LIST
77310: LIST
77311: PUSH
77312: LD_INT 0
77314: PUSH
77315: LD_INT 3
77317: NEG
77318: PUSH
77319: EMPTY
77320: LIST
77321: LIST
77322: PUSH
77323: LD_INT 1
77325: PUSH
77326: LD_INT 2
77328: NEG
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: LIST
77338: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77339: LD_ADDR_VAR 0 18
77343: PUSH
77344: LD_INT 2
77346: PUSH
77347: LD_INT 1
77349: NEG
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PUSH
77355: LD_INT 3
77357: PUSH
77358: LD_INT 0
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 3
77367: PUSH
77368: LD_INT 1
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: LIST
77379: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77380: LD_ADDR_VAR 0 19
77384: PUSH
77385: LD_INT 3
77387: PUSH
77388: LD_INT 2
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: PUSH
77395: LD_INT 3
77397: PUSH
77398: LD_INT 3
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 2
77407: PUSH
77408: LD_INT 3
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: PUSH
77415: EMPTY
77416: LIST
77417: LIST
77418: LIST
77419: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77420: LD_ADDR_VAR 0 20
77424: PUSH
77425: LD_INT 1
77427: PUSH
77428: LD_INT 3
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: LD_INT 0
77437: PUSH
77438: LD_INT 3
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: PUSH
77445: LD_INT 1
77447: NEG
77448: PUSH
77449: LD_INT 2
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: LIST
77460: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77461: LD_ADDR_VAR 0 21
77465: PUSH
77466: LD_INT 2
77468: NEG
77469: PUSH
77470: LD_INT 1
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: PUSH
77477: LD_INT 3
77479: NEG
77480: PUSH
77481: LD_INT 0
77483: PUSH
77484: EMPTY
77485: LIST
77486: LIST
77487: PUSH
77488: LD_INT 3
77490: NEG
77491: PUSH
77492: LD_INT 1
77494: NEG
77495: PUSH
77496: EMPTY
77497: LIST
77498: LIST
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: LIST
77504: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77505: LD_ADDR_VAR 0 22
77509: PUSH
77510: LD_INT 2
77512: NEG
77513: PUSH
77514: LD_INT 3
77516: NEG
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 3
77524: NEG
77525: PUSH
77526: LD_INT 2
77528: NEG
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PUSH
77534: LD_INT 3
77536: NEG
77537: PUSH
77538: LD_INT 3
77540: NEG
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: LIST
77550: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77551: LD_ADDR_VAR 0 23
77555: PUSH
77556: LD_INT 0
77558: PUSH
77559: LD_INT 3
77561: NEG
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PUSH
77567: LD_INT 1
77569: NEG
77570: PUSH
77571: LD_INT 4
77573: NEG
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PUSH
77579: LD_INT 1
77581: PUSH
77582: LD_INT 3
77584: NEG
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: LIST
77594: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
77595: LD_ADDR_VAR 0 24
77599: PUSH
77600: LD_INT 3
77602: PUSH
77603: LD_INT 0
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 3
77612: PUSH
77613: LD_INT 1
77615: NEG
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_INT 4
77623: PUSH
77624: LD_INT 1
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: LIST
77635: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
77636: LD_ADDR_VAR 0 25
77640: PUSH
77641: LD_INT 3
77643: PUSH
77644: LD_INT 3
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_INT 4
77653: PUSH
77654: LD_INT 3
77656: PUSH
77657: EMPTY
77658: LIST
77659: LIST
77660: PUSH
77661: LD_INT 3
77663: PUSH
77664: LD_INT 4
77666: PUSH
77667: EMPTY
77668: LIST
77669: LIST
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: LIST
77675: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
77676: LD_ADDR_VAR 0 26
77680: PUSH
77681: LD_INT 0
77683: PUSH
77684: LD_INT 3
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: PUSH
77691: LD_INT 1
77693: PUSH
77694: LD_INT 4
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: PUSH
77701: LD_INT 1
77703: NEG
77704: PUSH
77705: LD_INT 3
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: LIST
77716: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
77717: LD_ADDR_VAR 0 27
77721: PUSH
77722: LD_INT 3
77724: NEG
77725: PUSH
77726: LD_INT 0
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: PUSH
77733: LD_INT 3
77735: NEG
77736: PUSH
77737: LD_INT 1
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: LD_INT 4
77746: NEG
77747: PUSH
77748: LD_INT 1
77750: NEG
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: LIST
77760: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77761: LD_ADDR_VAR 0 28
77765: PUSH
77766: LD_INT 3
77768: NEG
77769: PUSH
77770: LD_INT 3
77772: NEG
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: PUSH
77778: LD_INT 3
77780: NEG
77781: PUSH
77782: LD_INT 4
77784: NEG
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 4
77792: NEG
77793: PUSH
77794: LD_INT 3
77796: NEG
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: LIST
77806: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77807: LD_ADDR_VAR 0 29
77811: PUSH
77812: LD_INT 1
77814: NEG
77815: PUSH
77816: LD_INT 3
77818: NEG
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: PUSH
77824: LD_INT 0
77826: PUSH
77827: LD_INT 3
77829: NEG
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 1
77837: PUSH
77838: LD_INT 2
77840: NEG
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PUSH
77846: LD_INT 1
77848: NEG
77849: PUSH
77850: LD_INT 4
77852: NEG
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 0
77860: PUSH
77861: LD_INT 4
77863: NEG
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: LD_INT 1
77871: PUSH
77872: LD_INT 3
77874: NEG
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PUSH
77880: LD_INT 1
77882: NEG
77883: PUSH
77884: LD_INT 5
77886: NEG
77887: PUSH
77888: EMPTY
77889: LIST
77890: LIST
77891: PUSH
77892: LD_INT 0
77894: PUSH
77895: LD_INT 5
77897: NEG
77898: PUSH
77899: EMPTY
77900: LIST
77901: LIST
77902: PUSH
77903: LD_INT 1
77905: PUSH
77906: LD_INT 4
77908: NEG
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: PUSH
77914: LD_INT 1
77916: NEG
77917: PUSH
77918: LD_INT 6
77920: NEG
77921: PUSH
77922: EMPTY
77923: LIST
77924: LIST
77925: PUSH
77926: LD_INT 0
77928: PUSH
77929: LD_INT 6
77931: NEG
77932: PUSH
77933: EMPTY
77934: LIST
77935: LIST
77936: PUSH
77937: LD_INT 1
77939: PUSH
77940: LD_INT 5
77942: NEG
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: LIST
77952: LIST
77953: LIST
77954: LIST
77955: LIST
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77962: LD_ADDR_VAR 0 30
77966: PUSH
77967: LD_INT 2
77969: PUSH
77970: LD_INT 1
77972: NEG
77973: PUSH
77974: EMPTY
77975: LIST
77976: LIST
77977: PUSH
77978: LD_INT 3
77980: PUSH
77981: LD_INT 0
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: LD_INT 3
77990: PUSH
77991: LD_INT 1
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 3
78000: PUSH
78001: LD_INT 1
78003: NEG
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: LD_INT 4
78011: PUSH
78012: LD_INT 0
78014: PUSH
78015: EMPTY
78016: LIST
78017: LIST
78018: PUSH
78019: LD_INT 4
78021: PUSH
78022: LD_INT 1
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: LD_INT 4
78031: PUSH
78032: LD_INT 1
78034: NEG
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: LD_INT 5
78042: PUSH
78043: LD_INT 0
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 5
78052: PUSH
78053: LD_INT 1
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 5
78062: PUSH
78063: LD_INT 1
78065: NEG
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 6
78073: PUSH
78074: LD_INT 0
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: LD_INT 6
78083: PUSH
78084: LD_INT 1
78086: PUSH
78087: EMPTY
78088: LIST
78089: LIST
78090: PUSH
78091: EMPTY
78092: LIST
78093: LIST
78094: LIST
78095: LIST
78096: LIST
78097: LIST
78098: LIST
78099: LIST
78100: LIST
78101: LIST
78102: LIST
78103: LIST
78104: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78105: LD_ADDR_VAR 0 31
78109: PUSH
78110: LD_INT 3
78112: PUSH
78113: LD_INT 2
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 3
78122: PUSH
78123: LD_INT 3
78125: PUSH
78126: EMPTY
78127: LIST
78128: LIST
78129: PUSH
78130: LD_INT 2
78132: PUSH
78133: LD_INT 3
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: PUSH
78140: LD_INT 4
78142: PUSH
78143: LD_INT 3
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: LD_INT 4
78152: PUSH
78153: LD_INT 4
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PUSH
78160: LD_INT 3
78162: PUSH
78163: LD_INT 4
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: LD_INT 5
78172: PUSH
78173: LD_INT 4
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 5
78182: PUSH
78183: LD_INT 5
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 4
78192: PUSH
78193: LD_INT 5
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 6
78202: PUSH
78203: LD_INT 5
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: PUSH
78210: LD_INT 6
78212: PUSH
78213: LD_INT 6
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PUSH
78220: LD_INT 5
78222: PUSH
78223: LD_INT 6
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: EMPTY
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78244: LD_ADDR_VAR 0 32
78248: PUSH
78249: LD_INT 1
78251: PUSH
78252: LD_INT 3
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PUSH
78259: LD_INT 0
78261: PUSH
78262: LD_INT 3
78264: PUSH
78265: EMPTY
78266: LIST
78267: LIST
78268: PUSH
78269: LD_INT 1
78271: NEG
78272: PUSH
78273: LD_INT 2
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 1
78282: PUSH
78283: LD_INT 4
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 0
78292: PUSH
78293: LD_INT 4
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: PUSH
78300: LD_INT 1
78302: NEG
78303: PUSH
78304: LD_INT 3
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: PUSH
78311: LD_INT 1
78313: PUSH
78314: LD_INT 5
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PUSH
78321: LD_INT 0
78323: PUSH
78324: LD_INT 5
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 1
78333: NEG
78334: PUSH
78335: LD_INT 4
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 1
78344: PUSH
78345: LD_INT 6
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 0
78354: PUSH
78355: LD_INT 6
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: LD_INT 1
78364: NEG
78365: PUSH
78366: LD_INT 5
78368: PUSH
78369: EMPTY
78370: LIST
78371: LIST
78372: PUSH
78373: EMPTY
78374: LIST
78375: LIST
78376: LIST
78377: LIST
78378: LIST
78379: LIST
78380: LIST
78381: LIST
78382: LIST
78383: LIST
78384: LIST
78385: LIST
78386: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78387: LD_ADDR_VAR 0 33
78391: PUSH
78392: LD_INT 2
78394: NEG
78395: PUSH
78396: LD_INT 1
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: PUSH
78403: LD_INT 3
78405: NEG
78406: PUSH
78407: LD_INT 0
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 3
78416: NEG
78417: PUSH
78418: LD_INT 1
78420: NEG
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 3
78428: NEG
78429: PUSH
78430: LD_INT 1
78432: PUSH
78433: EMPTY
78434: LIST
78435: LIST
78436: PUSH
78437: LD_INT 4
78439: NEG
78440: PUSH
78441: LD_INT 0
78443: PUSH
78444: EMPTY
78445: LIST
78446: LIST
78447: PUSH
78448: LD_INT 4
78450: NEG
78451: PUSH
78452: LD_INT 1
78454: NEG
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 4
78462: NEG
78463: PUSH
78464: LD_INT 1
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 5
78473: NEG
78474: PUSH
78475: LD_INT 0
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 5
78484: NEG
78485: PUSH
78486: LD_INT 1
78488: NEG
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 5
78496: NEG
78497: PUSH
78498: LD_INT 1
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 6
78507: NEG
78508: PUSH
78509: LD_INT 0
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 6
78518: NEG
78519: PUSH
78520: LD_INT 1
78522: NEG
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: PUSH
78528: EMPTY
78529: LIST
78530: LIST
78531: LIST
78532: LIST
78533: LIST
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: LIST
78541: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78542: LD_ADDR_VAR 0 34
78546: PUSH
78547: LD_INT 2
78549: NEG
78550: PUSH
78551: LD_INT 3
78553: NEG
78554: PUSH
78555: EMPTY
78556: LIST
78557: LIST
78558: PUSH
78559: LD_INT 3
78561: NEG
78562: PUSH
78563: LD_INT 2
78565: NEG
78566: PUSH
78567: EMPTY
78568: LIST
78569: LIST
78570: PUSH
78571: LD_INT 3
78573: NEG
78574: PUSH
78575: LD_INT 3
78577: NEG
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 3
78585: NEG
78586: PUSH
78587: LD_INT 4
78589: NEG
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 4
78597: NEG
78598: PUSH
78599: LD_INT 3
78601: NEG
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 4
78609: NEG
78610: PUSH
78611: LD_INT 4
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 4
78621: NEG
78622: PUSH
78623: LD_INT 5
78625: NEG
78626: PUSH
78627: EMPTY
78628: LIST
78629: LIST
78630: PUSH
78631: LD_INT 5
78633: NEG
78634: PUSH
78635: LD_INT 4
78637: NEG
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: PUSH
78643: LD_INT 5
78645: NEG
78646: PUSH
78647: LD_INT 5
78649: NEG
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: PUSH
78655: LD_INT 5
78657: NEG
78658: PUSH
78659: LD_INT 6
78661: NEG
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: LD_INT 6
78669: NEG
78670: PUSH
78671: LD_INT 5
78673: NEG
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 6
78681: NEG
78682: PUSH
78683: LD_INT 6
78685: NEG
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: EMPTY
78692: LIST
78693: LIST
78694: LIST
78695: LIST
78696: LIST
78697: LIST
78698: LIST
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: LIST
78704: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
78705: LD_ADDR_VAR 0 41
78709: PUSH
78710: LD_INT 0
78712: PUSH
78713: LD_INT 2
78715: NEG
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 1
78723: NEG
78724: PUSH
78725: LD_INT 3
78727: NEG
78728: PUSH
78729: EMPTY
78730: LIST
78731: LIST
78732: PUSH
78733: LD_INT 1
78735: PUSH
78736: LD_INT 2
78738: NEG
78739: PUSH
78740: EMPTY
78741: LIST
78742: LIST
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: LIST
78748: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
78749: LD_ADDR_VAR 0 42
78753: PUSH
78754: LD_INT 2
78756: PUSH
78757: LD_INT 0
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 2
78766: PUSH
78767: LD_INT 1
78769: NEG
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 3
78777: PUSH
78778: LD_INT 1
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: EMPTY
78786: LIST
78787: LIST
78788: LIST
78789: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78790: LD_ADDR_VAR 0 43
78794: PUSH
78795: LD_INT 2
78797: PUSH
78798: LD_INT 2
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: PUSH
78805: LD_INT 3
78807: PUSH
78808: LD_INT 2
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 2
78817: PUSH
78818: LD_INT 3
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: LIST
78829: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78830: LD_ADDR_VAR 0 44
78834: PUSH
78835: LD_INT 0
78837: PUSH
78838: LD_INT 2
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: LD_INT 1
78847: PUSH
78848: LD_INT 3
78850: PUSH
78851: EMPTY
78852: LIST
78853: LIST
78854: PUSH
78855: LD_INT 1
78857: NEG
78858: PUSH
78859: LD_INT 2
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: LIST
78870: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78871: LD_ADDR_VAR 0 45
78875: PUSH
78876: LD_INT 2
78878: NEG
78879: PUSH
78880: LD_INT 0
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 2
78889: NEG
78890: PUSH
78891: LD_INT 1
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: PUSH
78898: LD_INT 3
78900: NEG
78901: PUSH
78902: LD_INT 1
78904: NEG
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: LIST
78914: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78915: LD_ADDR_VAR 0 46
78919: PUSH
78920: LD_INT 2
78922: NEG
78923: PUSH
78924: LD_INT 2
78926: NEG
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: PUSH
78932: LD_INT 2
78934: NEG
78935: PUSH
78936: LD_INT 3
78938: NEG
78939: PUSH
78940: EMPTY
78941: LIST
78942: LIST
78943: PUSH
78944: LD_INT 3
78946: NEG
78947: PUSH
78948: LD_INT 2
78950: NEG
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: LIST
78960: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78961: LD_ADDR_VAR 0 47
78965: PUSH
78966: LD_INT 2
78968: NEG
78969: PUSH
78970: LD_INT 3
78972: NEG
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: PUSH
78978: LD_INT 1
78980: NEG
78981: PUSH
78982: LD_INT 3
78984: NEG
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78994: LD_ADDR_VAR 0 48
78998: PUSH
78999: LD_INT 1
79001: PUSH
79002: LD_INT 2
79004: NEG
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: LD_INT 2
79012: PUSH
79013: LD_INT 1
79015: NEG
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79025: LD_ADDR_VAR 0 49
79029: PUSH
79030: LD_INT 3
79032: PUSH
79033: LD_INT 1
79035: PUSH
79036: EMPTY
79037: LIST
79038: LIST
79039: PUSH
79040: LD_INT 3
79042: PUSH
79043: LD_INT 2
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79054: LD_ADDR_VAR 0 50
79058: PUSH
79059: LD_INT 2
79061: PUSH
79062: LD_INT 3
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 1
79071: PUSH
79072: LD_INT 3
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79083: LD_ADDR_VAR 0 51
79087: PUSH
79088: LD_INT 1
79090: NEG
79091: PUSH
79092: LD_INT 2
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: LD_INT 2
79101: NEG
79102: PUSH
79103: LD_INT 1
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79114: LD_ADDR_VAR 0 52
79118: PUSH
79119: LD_INT 3
79121: NEG
79122: PUSH
79123: LD_INT 1
79125: NEG
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: PUSH
79131: LD_INT 3
79133: NEG
79134: PUSH
79135: LD_INT 2
79137: NEG
79138: PUSH
79139: EMPTY
79140: LIST
79141: LIST
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79147: LD_ADDR_VAR 0 53
79151: PUSH
79152: LD_INT 1
79154: NEG
79155: PUSH
79156: LD_INT 3
79158: NEG
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 0
79166: PUSH
79167: LD_INT 3
79169: NEG
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: PUSH
79175: LD_INT 1
79177: PUSH
79178: LD_INT 2
79180: NEG
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: LIST
79190: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79191: LD_ADDR_VAR 0 54
79195: PUSH
79196: LD_INT 2
79198: PUSH
79199: LD_INT 1
79201: NEG
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 3
79209: PUSH
79210: LD_INT 0
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 3
79219: PUSH
79220: LD_INT 1
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: EMPTY
79228: LIST
79229: LIST
79230: LIST
79231: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79232: LD_ADDR_VAR 0 55
79236: PUSH
79237: LD_INT 3
79239: PUSH
79240: LD_INT 2
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PUSH
79247: LD_INT 3
79249: PUSH
79250: LD_INT 3
79252: PUSH
79253: EMPTY
79254: LIST
79255: LIST
79256: PUSH
79257: LD_INT 2
79259: PUSH
79260: LD_INT 3
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: PUSH
79267: EMPTY
79268: LIST
79269: LIST
79270: LIST
79271: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79272: LD_ADDR_VAR 0 56
79276: PUSH
79277: LD_INT 1
79279: PUSH
79280: LD_INT 3
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PUSH
79287: LD_INT 0
79289: PUSH
79290: LD_INT 3
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 1
79299: NEG
79300: PUSH
79301: LD_INT 2
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: LIST
79312: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79313: LD_ADDR_VAR 0 57
79317: PUSH
79318: LD_INT 2
79320: NEG
79321: PUSH
79322: LD_INT 1
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PUSH
79329: LD_INT 3
79331: NEG
79332: PUSH
79333: LD_INT 0
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: LD_INT 3
79342: NEG
79343: PUSH
79344: LD_INT 1
79346: NEG
79347: PUSH
79348: EMPTY
79349: LIST
79350: LIST
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: LIST
79356: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79357: LD_ADDR_VAR 0 58
79361: PUSH
79362: LD_INT 2
79364: NEG
79365: PUSH
79366: LD_INT 3
79368: NEG
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 3
79376: NEG
79377: PUSH
79378: LD_INT 2
79380: NEG
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 3
79388: NEG
79389: PUSH
79390: LD_INT 3
79392: NEG
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: LIST
79402: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79403: LD_ADDR_VAR 0 59
79407: PUSH
79408: LD_INT 1
79410: NEG
79411: PUSH
79412: LD_INT 2
79414: NEG
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PUSH
79420: LD_INT 0
79422: PUSH
79423: LD_INT 2
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 1
79433: PUSH
79434: LD_INT 1
79436: NEG
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: LIST
79446: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79447: LD_ADDR_VAR 0 60
79451: PUSH
79452: LD_INT 1
79454: PUSH
79455: LD_INT 1
79457: NEG
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 2
79465: PUSH
79466: LD_INT 0
79468: PUSH
79469: EMPTY
79470: LIST
79471: LIST
79472: PUSH
79473: LD_INT 2
79475: PUSH
79476: LD_INT 1
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: LIST
79487: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79488: LD_ADDR_VAR 0 61
79492: PUSH
79493: LD_INT 2
79495: PUSH
79496: LD_INT 1
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 2
79505: PUSH
79506: LD_INT 2
79508: PUSH
79509: EMPTY
79510: LIST
79511: LIST
79512: PUSH
79513: LD_INT 1
79515: PUSH
79516: LD_INT 2
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: LIST
79527: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79528: LD_ADDR_VAR 0 62
79532: PUSH
79533: LD_INT 1
79535: PUSH
79536: LD_INT 2
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 0
79545: PUSH
79546: LD_INT 2
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 1
79555: NEG
79556: PUSH
79557: LD_INT 1
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: EMPTY
79565: LIST
79566: LIST
79567: LIST
79568: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79569: LD_ADDR_VAR 0 63
79573: PUSH
79574: LD_INT 1
79576: NEG
79577: PUSH
79578: LD_INT 1
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 2
79587: NEG
79588: PUSH
79589: LD_INT 0
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 2
79598: NEG
79599: PUSH
79600: LD_INT 1
79602: NEG
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: LIST
79612: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79613: LD_ADDR_VAR 0 64
79617: PUSH
79618: LD_INT 1
79620: NEG
79621: PUSH
79622: LD_INT 2
79624: NEG
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: PUSH
79630: LD_INT 2
79632: NEG
79633: PUSH
79634: LD_INT 1
79636: NEG
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: LD_INT 2
79644: NEG
79645: PUSH
79646: LD_INT 2
79648: NEG
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: LIST
79658: ST_TO_ADDR
// end ; 2 :
79659: GO 82925
79661: LD_INT 2
79663: DOUBLE
79664: EQUAL
79665: IFTRUE 79669
79667: GO 82924
79669: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
79670: LD_ADDR_VAR 0 29
79674: PUSH
79675: LD_INT 4
79677: PUSH
79678: LD_INT 0
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: PUSH
79685: LD_INT 4
79687: PUSH
79688: LD_INT 1
79690: NEG
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 5
79698: PUSH
79699: LD_INT 0
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 5
79708: PUSH
79709: LD_INT 1
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: LD_INT 4
79718: PUSH
79719: LD_INT 1
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PUSH
79726: LD_INT 3
79728: PUSH
79729: LD_INT 0
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: PUSH
79736: LD_INT 3
79738: PUSH
79739: LD_INT 1
79741: NEG
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 3
79749: PUSH
79750: LD_INT 2
79752: NEG
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 5
79760: PUSH
79761: LD_INT 2
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 3
79770: PUSH
79771: LD_INT 3
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 3
79780: PUSH
79781: LD_INT 2
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 4
79790: PUSH
79791: LD_INT 3
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 4
79800: PUSH
79801: LD_INT 4
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: PUSH
79808: LD_INT 3
79810: PUSH
79811: LD_INT 4
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 2
79820: PUSH
79821: LD_INT 3
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 2
79830: PUSH
79831: LD_INT 2
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 4
79840: PUSH
79841: LD_INT 2
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: LD_INT 2
79850: PUSH
79851: LD_INT 4
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 0
79860: PUSH
79861: LD_INT 4
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PUSH
79868: LD_INT 0
79870: PUSH
79871: LD_INT 3
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: LD_INT 1
79880: PUSH
79881: LD_INT 4
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: PUSH
79888: LD_INT 1
79890: PUSH
79891: LD_INT 5
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 0
79900: PUSH
79901: LD_INT 5
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 1
79910: NEG
79911: PUSH
79912: LD_INT 4
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 1
79921: NEG
79922: PUSH
79923: LD_INT 3
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 2
79932: PUSH
79933: LD_INT 5
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 2
79942: NEG
79943: PUSH
79944: LD_INT 3
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 3
79953: NEG
79954: PUSH
79955: LD_INT 0
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: PUSH
79962: LD_INT 3
79964: NEG
79965: PUSH
79966: LD_INT 1
79968: NEG
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 2
79976: NEG
79977: PUSH
79978: LD_INT 0
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 2
79987: NEG
79988: PUSH
79989: LD_INT 1
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PUSH
79996: LD_INT 3
79998: NEG
79999: PUSH
80000: LD_INT 1
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 4
80009: NEG
80010: PUSH
80011: LD_INT 0
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 4
80020: NEG
80021: PUSH
80022: LD_INT 1
80024: NEG
80025: PUSH
80026: EMPTY
80027: LIST
80028: LIST
80029: PUSH
80030: LD_INT 4
80032: NEG
80033: PUSH
80034: LD_INT 2
80036: NEG
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 2
80044: NEG
80045: PUSH
80046: LD_INT 2
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 4
80055: NEG
80056: PUSH
80057: LD_INT 4
80059: NEG
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: LD_INT 4
80067: NEG
80068: PUSH
80069: LD_INT 5
80071: NEG
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 3
80079: NEG
80080: PUSH
80081: LD_INT 4
80083: NEG
80084: PUSH
80085: EMPTY
80086: LIST
80087: LIST
80088: PUSH
80089: LD_INT 3
80091: NEG
80092: PUSH
80093: LD_INT 3
80095: NEG
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 4
80103: NEG
80104: PUSH
80105: LD_INT 3
80107: NEG
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 5
80115: NEG
80116: PUSH
80117: LD_INT 4
80119: NEG
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 5
80127: NEG
80128: PUSH
80129: LD_INT 5
80131: NEG
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 3
80139: NEG
80140: PUSH
80141: LD_INT 5
80143: NEG
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 5
80151: NEG
80152: PUSH
80153: LD_INT 3
80155: NEG
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: LIST
80194: LIST
80195: LIST
80196: LIST
80197: LIST
80198: LIST
80199: LIST
80200: LIST
80201: LIST
80202: LIST
80203: LIST
80204: LIST
80205: LIST
80206: LIST
80207: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80208: LD_ADDR_VAR 0 30
80212: PUSH
80213: LD_INT 4
80215: PUSH
80216: LD_INT 4
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 4
80225: PUSH
80226: LD_INT 3
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 5
80235: PUSH
80236: LD_INT 4
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 5
80245: PUSH
80246: LD_INT 5
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: LD_INT 4
80255: PUSH
80256: LD_INT 5
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 3
80265: PUSH
80266: LD_INT 4
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 3
80275: PUSH
80276: LD_INT 3
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 5
80285: PUSH
80286: LD_INT 3
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 3
80295: PUSH
80296: LD_INT 5
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 0
80305: PUSH
80306: LD_INT 3
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 0
80315: PUSH
80316: LD_INT 2
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 1
80325: PUSH
80326: LD_INT 3
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 1
80335: PUSH
80336: LD_INT 4
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 0
80345: PUSH
80346: LD_INT 4
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 1
80355: NEG
80356: PUSH
80357: LD_INT 3
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: LD_INT 1
80366: NEG
80367: PUSH
80368: LD_INT 2
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PUSH
80375: LD_INT 2
80377: PUSH
80378: LD_INT 4
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 2
80387: NEG
80388: PUSH
80389: LD_INT 2
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PUSH
80396: LD_INT 4
80398: NEG
80399: PUSH
80400: LD_INT 0
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: LD_INT 4
80409: NEG
80410: PUSH
80411: LD_INT 1
80413: NEG
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: PUSH
80419: LD_INT 3
80421: NEG
80422: PUSH
80423: LD_INT 0
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: PUSH
80430: LD_INT 3
80432: NEG
80433: PUSH
80434: LD_INT 1
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: PUSH
80441: LD_INT 4
80443: NEG
80444: PUSH
80445: LD_INT 1
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: LD_INT 5
80454: NEG
80455: PUSH
80456: LD_INT 0
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 5
80465: NEG
80466: PUSH
80467: LD_INT 1
80469: NEG
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 5
80477: NEG
80478: PUSH
80479: LD_INT 2
80481: NEG
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 3
80489: NEG
80490: PUSH
80491: LD_INT 2
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 3
80500: NEG
80501: PUSH
80502: LD_INT 3
80504: NEG
80505: PUSH
80506: EMPTY
80507: LIST
80508: LIST
80509: PUSH
80510: LD_INT 3
80512: NEG
80513: PUSH
80514: LD_INT 4
80516: NEG
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: PUSH
80522: LD_INT 2
80524: NEG
80525: PUSH
80526: LD_INT 3
80528: NEG
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 2
80536: NEG
80537: PUSH
80538: LD_INT 2
80540: NEG
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 3
80548: NEG
80549: PUSH
80550: LD_INT 2
80552: NEG
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 4
80560: NEG
80561: PUSH
80562: LD_INT 3
80564: NEG
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PUSH
80570: LD_INT 4
80572: NEG
80573: PUSH
80574: LD_INT 4
80576: NEG
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: PUSH
80582: LD_INT 2
80584: NEG
80585: PUSH
80586: LD_INT 4
80588: NEG
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: LD_INT 4
80596: NEG
80597: PUSH
80598: LD_INT 2
80600: NEG
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: PUSH
80606: LD_INT 0
80608: PUSH
80609: LD_INT 4
80611: NEG
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: LD_INT 0
80619: PUSH
80620: LD_INT 5
80622: NEG
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 1
80630: PUSH
80631: LD_INT 4
80633: NEG
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: PUSH
80639: LD_INT 1
80641: PUSH
80642: LD_INT 3
80644: NEG
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: PUSH
80650: LD_INT 0
80652: PUSH
80653: LD_INT 3
80655: NEG
80656: PUSH
80657: EMPTY
80658: LIST
80659: LIST
80660: PUSH
80661: LD_INT 1
80663: NEG
80664: PUSH
80665: LD_INT 4
80667: NEG
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 1
80675: NEG
80676: PUSH
80677: LD_INT 5
80679: NEG
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 2
80687: PUSH
80688: LD_INT 3
80690: NEG
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 2
80698: NEG
80699: PUSH
80700: LD_INT 5
80702: NEG
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: LIST
80722: LIST
80723: LIST
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: LIST
80736: LIST
80737: LIST
80738: LIST
80739: LIST
80740: LIST
80741: LIST
80742: LIST
80743: LIST
80744: LIST
80745: LIST
80746: LIST
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: LIST
80752: LIST
80753: LIST
80754: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80755: LD_ADDR_VAR 0 31
80759: PUSH
80760: LD_INT 0
80762: PUSH
80763: LD_INT 4
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: PUSH
80770: LD_INT 0
80772: PUSH
80773: LD_INT 3
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 1
80782: PUSH
80783: LD_INT 4
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: LD_INT 1
80792: PUSH
80793: LD_INT 5
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: LD_INT 0
80802: PUSH
80803: LD_INT 5
80805: PUSH
80806: EMPTY
80807: LIST
80808: LIST
80809: PUSH
80810: LD_INT 1
80812: NEG
80813: PUSH
80814: LD_INT 4
80816: PUSH
80817: EMPTY
80818: LIST
80819: LIST
80820: PUSH
80821: LD_INT 1
80823: NEG
80824: PUSH
80825: LD_INT 3
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 2
80834: PUSH
80835: LD_INT 5
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: LD_INT 2
80844: NEG
80845: PUSH
80846: LD_INT 3
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: PUSH
80853: LD_INT 3
80855: NEG
80856: PUSH
80857: LD_INT 0
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: PUSH
80864: LD_INT 3
80866: NEG
80867: PUSH
80868: LD_INT 1
80870: NEG
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 2
80878: NEG
80879: PUSH
80880: LD_INT 0
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PUSH
80887: LD_INT 2
80889: NEG
80890: PUSH
80891: LD_INT 1
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 3
80900: NEG
80901: PUSH
80902: LD_INT 1
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PUSH
80909: LD_INT 4
80911: NEG
80912: PUSH
80913: LD_INT 0
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 4
80922: NEG
80923: PUSH
80924: LD_INT 1
80926: NEG
80927: PUSH
80928: EMPTY
80929: LIST
80930: LIST
80931: PUSH
80932: LD_INT 4
80934: NEG
80935: PUSH
80936: LD_INT 2
80938: NEG
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PUSH
80944: LD_INT 2
80946: NEG
80947: PUSH
80948: LD_INT 2
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 4
80957: NEG
80958: PUSH
80959: LD_INT 4
80961: NEG
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PUSH
80967: LD_INT 4
80969: NEG
80970: PUSH
80971: LD_INT 5
80973: NEG
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 3
80981: NEG
80982: PUSH
80983: LD_INT 4
80985: NEG
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 3
80993: NEG
80994: PUSH
80995: LD_INT 3
80997: NEG
80998: PUSH
80999: EMPTY
81000: LIST
81001: LIST
81002: PUSH
81003: LD_INT 4
81005: NEG
81006: PUSH
81007: LD_INT 3
81009: NEG
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 5
81017: NEG
81018: PUSH
81019: LD_INT 4
81021: NEG
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 5
81029: NEG
81030: PUSH
81031: LD_INT 5
81033: NEG
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 3
81041: NEG
81042: PUSH
81043: LD_INT 5
81045: NEG
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: LD_INT 5
81053: NEG
81054: PUSH
81055: LD_INT 3
81057: NEG
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: LD_INT 0
81065: PUSH
81066: LD_INT 3
81068: NEG
81069: PUSH
81070: EMPTY
81071: LIST
81072: LIST
81073: PUSH
81074: LD_INT 0
81076: PUSH
81077: LD_INT 4
81079: NEG
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: LD_INT 1
81087: PUSH
81088: LD_INT 3
81090: NEG
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PUSH
81096: LD_INT 1
81098: PUSH
81099: LD_INT 2
81101: NEG
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 0
81109: PUSH
81110: LD_INT 2
81112: NEG
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: PUSH
81118: LD_INT 1
81120: NEG
81121: PUSH
81122: LD_INT 3
81124: NEG
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: PUSH
81130: LD_INT 1
81132: NEG
81133: PUSH
81134: LD_INT 4
81136: NEG
81137: PUSH
81138: EMPTY
81139: LIST
81140: LIST
81141: PUSH
81142: LD_INT 2
81144: PUSH
81145: LD_INT 2
81147: NEG
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 2
81155: NEG
81156: PUSH
81157: LD_INT 4
81159: NEG
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 4
81167: PUSH
81168: LD_INT 0
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 4
81177: PUSH
81178: LD_INT 1
81180: NEG
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PUSH
81186: LD_INT 5
81188: PUSH
81189: LD_INT 0
81191: PUSH
81192: EMPTY
81193: LIST
81194: LIST
81195: PUSH
81196: LD_INT 5
81198: PUSH
81199: LD_INT 1
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: PUSH
81206: LD_INT 4
81208: PUSH
81209: LD_INT 1
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 3
81218: PUSH
81219: LD_INT 0
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 3
81228: PUSH
81229: LD_INT 1
81231: NEG
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 3
81239: PUSH
81240: LD_INT 2
81242: NEG
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 5
81250: PUSH
81251: LD_INT 2
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: LIST
81285: LIST
81286: LIST
81287: LIST
81288: LIST
81289: LIST
81290: LIST
81291: LIST
81292: LIST
81293: LIST
81294: LIST
81295: LIST
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: LIST
81302: LIST
81303: LIST
81304: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81305: LD_ADDR_VAR 0 32
81309: PUSH
81310: LD_INT 4
81312: NEG
81313: PUSH
81314: LD_INT 0
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 4
81323: NEG
81324: PUSH
81325: LD_INT 1
81327: NEG
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PUSH
81333: LD_INT 3
81335: NEG
81336: PUSH
81337: LD_INT 0
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 3
81346: NEG
81347: PUSH
81348: LD_INT 1
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 4
81357: NEG
81358: PUSH
81359: LD_INT 1
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 5
81368: NEG
81369: PUSH
81370: LD_INT 0
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 5
81379: NEG
81380: PUSH
81381: LD_INT 1
81383: NEG
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: LD_INT 5
81391: NEG
81392: PUSH
81393: LD_INT 2
81395: NEG
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 3
81403: NEG
81404: PUSH
81405: LD_INT 2
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: LD_INT 3
81414: NEG
81415: PUSH
81416: LD_INT 3
81418: NEG
81419: PUSH
81420: EMPTY
81421: LIST
81422: LIST
81423: PUSH
81424: LD_INT 3
81426: NEG
81427: PUSH
81428: LD_INT 4
81430: NEG
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: LD_INT 2
81438: NEG
81439: PUSH
81440: LD_INT 3
81442: NEG
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 2
81450: NEG
81451: PUSH
81452: LD_INT 2
81454: NEG
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 3
81462: NEG
81463: PUSH
81464: LD_INT 2
81466: NEG
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 4
81474: NEG
81475: PUSH
81476: LD_INT 3
81478: NEG
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 4
81486: NEG
81487: PUSH
81488: LD_INT 4
81490: NEG
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: PUSH
81496: LD_INT 2
81498: NEG
81499: PUSH
81500: LD_INT 4
81502: NEG
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: PUSH
81508: LD_INT 4
81510: NEG
81511: PUSH
81512: LD_INT 2
81514: NEG
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 0
81522: PUSH
81523: LD_INT 4
81525: NEG
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 0
81533: PUSH
81534: LD_INT 5
81536: NEG
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 1
81544: PUSH
81545: LD_INT 4
81547: NEG
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 1
81555: PUSH
81556: LD_INT 3
81558: NEG
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PUSH
81564: LD_INT 0
81566: PUSH
81567: LD_INT 3
81569: NEG
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 1
81577: NEG
81578: PUSH
81579: LD_INT 4
81581: NEG
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 1
81589: NEG
81590: PUSH
81591: LD_INT 5
81593: NEG
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 2
81601: PUSH
81602: LD_INT 3
81604: NEG
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 2
81612: NEG
81613: PUSH
81614: LD_INT 5
81616: NEG
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: PUSH
81622: LD_INT 3
81624: PUSH
81625: LD_INT 0
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 3
81634: PUSH
81635: LD_INT 1
81637: NEG
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 4
81645: PUSH
81646: LD_INT 0
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 4
81655: PUSH
81656: LD_INT 1
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 3
81665: PUSH
81666: LD_INT 1
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 2
81675: PUSH
81676: LD_INT 0
81678: PUSH
81679: EMPTY
81680: LIST
81681: LIST
81682: PUSH
81683: LD_INT 2
81685: PUSH
81686: LD_INT 1
81688: NEG
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 2
81696: PUSH
81697: LD_INT 2
81699: NEG
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 4
81707: PUSH
81708: LD_INT 2
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 4
81717: PUSH
81718: LD_INT 4
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 4
81727: PUSH
81728: LD_INT 3
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 5
81737: PUSH
81738: LD_INT 4
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 5
81747: PUSH
81748: LD_INT 5
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 4
81757: PUSH
81758: LD_INT 5
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 3
81767: PUSH
81768: LD_INT 4
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 3
81777: PUSH
81778: LD_INT 3
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 5
81787: PUSH
81788: LD_INT 3
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 3
81797: PUSH
81798: LD_INT 5
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: LIST
81819: LIST
81820: LIST
81821: LIST
81822: LIST
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: LIST
81842: LIST
81843: LIST
81844: LIST
81845: LIST
81846: LIST
81847: LIST
81848: LIST
81849: LIST
81850: LIST
81851: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81852: LD_ADDR_VAR 0 33
81856: PUSH
81857: LD_INT 4
81859: NEG
81860: PUSH
81861: LD_INT 4
81863: NEG
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PUSH
81869: LD_INT 4
81871: NEG
81872: PUSH
81873: LD_INT 5
81875: NEG
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PUSH
81881: LD_INT 3
81883: NEG
81884: PUSH
81885: LD_INT 4
81887: NEG
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_INT 3
81895: NEG
81896: PUSH
81897: LD_INT 3
81899: NEG
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: PUSH
81905: LD_INT 4
81907: NEG
81908: PUSH
81909: LD_INT 3
81911: NEG
81912: PUSH
81913: EMPTY
81914: LIST
81915: LIST
81916: PUSH
81917: LD_INT 5
81919: NEG
81920: PUSH
81921: LD_INT 4
81923: NEG
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_INT 5
81931: NEG
81932: PUSH
81933: LD_INT 5
81935: NEG
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PUSH
81941: LD_INT 3
81943: NEG
81944: PUSH
81945: LD_INT 5
81947: NEG
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 5
81955: NEG
81956: PUSH
81957: LD_INT 3
81959: NEG
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 0
81967: PUSH
81968: LD_INT 3
81970: NEG
81971: PUSH
81972: EMPTY
81973: LIST
81974: LIST
81975: PUSH
81976: LD_INT 0
81978: PUSH
81979: LD_INT 4
81981: NEG
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_INT 1
81989: PUSH
81990: LD_INT 3
81992: NEG
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PUSH
81998: LD_INT 1
82000: PUSH
82001: LD_INT 2
82003: NEG
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 0
82011: PUSH
82012: LD_INT 2
82014: NEG
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: PUSH
82020: LD_INT 1
82022: NEG
82023: PUSH
82024: LD_INT 3
82026: NEG
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 1
82034: NEG
82035: PUSH
82036: LD_INT 4
82038: NEG
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 2
82046: PUSH
82047: LD_INT 2
82049: NEG
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 2
82057: NEG
82058: PUSH
82059: LD_INT 4
82061: NEG
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 4
82069: PUSH
82070: LD_INT 0
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: PUSH
82077: LD_INT 4
82079: PUSH
82080: LD_INT 1
82082: NEG
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 5
82090: PUSH
82091: LD_INT 0
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 5
82100: PUSH
82101: LD_INT 1
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 4
82110: PUSH
82111: LD_INT 1
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 3
82120: PUSH
82121: LD_INT 0
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 3
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 3
82141: PUSH
82142: LD_INT 2
82144: NEG
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 5
82152: PUSH
82153: LD_INT 2
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 3
82162: PUSH
82163: LD_INT 3
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 3
82172: PUSH
82173: LD_INT 2
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 4
82182: PUSH
82183: LD_INT 3
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 4
82192: PUSH
82193: LD_INT 4
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 3
82202: PUSH
82203: LD_INT 4
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: PUSH
82210: LD_INT 2
82212: PUSH
82213: LD_INT 3
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 2
82222: PUSH
82223: LD_INT 2
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 4
82232: PUSH
82233: LD_INT 2
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 2
82242: PUSH
82243: LD_INT 4
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: PUSH
82250: LD_INT 0
82252: PUSH
82253: LD_INT 4
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 0
82262: PUSH
82263: LD_INT 3
82265: PUSH
82266: EMPTY
82267: LIST
82268: LIST
82269: PUSH
82270: LD_INT 1
82272: PUSH
82273: LD_INT 4
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 1
82282: PUSH
82283: LD_INT 5
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 0
82292: PUSH
82293: LD_INT 5
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 1
82302: NEG
82303: PUSH
82304: LD_INT 4
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 1
82313: NEG
82314: PUSH
82315: LD_INT 3
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PUSH
82322: LD_INT 2
82324: PUSH
82325: LD_INT 5
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 2
82334: NEG
82335: PUSH
82336: LD_INT 3
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: LIST
82347: LIST
82348: LIST
82349: LIST
82350: LIST
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: LIST
82356: LIST
82357: LIST
82358: LIST
82359: LIST
82360: LIST
82361: LIST
82362: LIST
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: LIST
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82390: LD_ADDR_VAR 0 34
82394: PUSH
82395: LD_INT 0
82397: PUSH
82398: LD_INT 4
82400: NEG
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 0
82408: PUSH
82409: LD_INT 5
82411: NEG
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 1
82419: PUSH
82420: LD_INT 4
82422: NEG
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 1
82430: PUSH
82431: LD_INT 3
82433: NEG
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 0
82441: PUSH
82442: LD_INT 3
82444: NEG
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 1
82452: NEG
82453: PUSH
82454: LD_INT 4
82456: NEG
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 1
82464: NEG
82465: PUSH
82466: LD_INT 5
82468: NEG
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 2
82476: PUSH
82477: LD_INT 3
82479: NEG
82480: PUSH
82481: EMPTY
82482: LIST
82483: LIST
82484: PUSH
82485: LD_INT 2
82487: NEG
82488: PUSH
82489: LD_INT 5
82491: NEG
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: PUSH
82497: LD_INT 3
82499: PUSH
82500: LD_INT 0
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 3
82509: PUSH
82510: LD_INT 1
82512: NEG
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 4
82520: PUSH
82521: LD_INT 0
82523: PUSH
82524: EMPTY
82525: LIST
82526: LIST
82527: PUSH
82528: LD_INT 4
82530: PUSH
82531: LD_INT 1
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: PUSH
82538: LD_INT 3
82540: PUSH
82541: LD_INT 1
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 2
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 2
82560: PUSH
82561: LD_INT 1
82563: NEG
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 2
82571: PUSH
82572: LD_INT 2
82574: NEG
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 4
82582: PUSH
82583: LD_INT 2
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 4
82592: PUSH
82593: LD_INT 4
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 4
82602: PUSH
82603: LD_INT 3
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: PUSH
82610: LD_INT 5
82612: PUSH
82613: LD_INT 4
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: LD_INT 5
82622: PUSH
82623: LD_INT 5
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 4
82632: PUSH
82633: LD_INT 5
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 3
82642: PUSH
82643: LD_INT 4
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 3
82652: PUSH
82653: LD_INT 3
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 5
82662: PUSH
82663: LD_INT 3
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 3
82672: PUSH
82673: LD_INT 5
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 0
82682: PUSH
82683: LD_INT 3
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 0
82692: PUSH
82693: LD_INT 2
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: LD_INT 1
82702: PUSH
82703: LD_INT 3
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 1
82712: PUSH
82713: LD_INT 4
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_INT 0
82722: PUSH
82723: LD_INT 4
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 1
82732: NEG
82733: PUSH
82734: LD_INT 3
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 1
82743: NEG
82744: PUSH
82745: LD_INT 2
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 2
82754: PUSH
82755: LD_INT 4
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 2
82764: NEG
82765: PUSH
82766: LD_INT 2
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: LD_INT 4
82775: NEG
82776: PUSH
82777: LD_INT 0
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 4
82786: NEG
82787: PUSH
82788: LD_INT 1
82790: NEG
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 3
82798: NEG
82799: PUSH
82800: LD_INT 0
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: PUSH
82807: LD_INT 3
82809: NEG
82810: PUSH
82811: LD_INT 1
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: PUSH
82818: LD_INT 4
82820: NEG
82821: PUSH
82822: LD_INT 1
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 5
82831: NEG
82832: PUSH
82833: LD_INT 0
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: PUSH
82840: LD_INT 5
82842: NEG
82843: PUSH
82844: LD_INT 1
82846: NEG
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 5
82854: NEG
82855: PUSH
82856: LD_INT 2
82858: NEG
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: PUSH
82864: LD_INT 3
82866: NEG
82867: PUSH
82868: LD_INT 2
82870: PUSH
82871: EMPTY
82872: LIST
82873: LIST
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: LIST
82885: LIST
82886: LIST
82887: LIST
82888: LIST
82889: LIST
82890: LIST
82891: LIST
82892: LIST
82893: LIST
82894: LIST
82895: LIST
82896: LIST
82897: LIST
82898: LIST
82899: LIST
82900: LIST
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: ST_TO_ADDR
// end ; end ;
82922: GO 82925
82924: POP
// case btype of b_depot , b_warehouse :
82925: LD_VAR 0 1
82929: PUSH
82930: LD_INT 0
82932: DOUBLE
82933: EQUAL
82934: IFTRUE 82944
82936: LD_INT 1
82938: DOUBLE
82939: EQUAL
82940: IFTRUE 82944
82942: GO 83145
82944: POP
// case nation of nation_american :
82945: LD_VAR 0 5
82949: PUSH
82950: LD_INT 1
82952: DOUBLE
82953: EQUAL
82954: IFTRUE 82958
82956: GO 83014
82958: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
82959: LD_ADDR_VAR 0 9
82963: PUSH
82964: LD_VAR 0 11
82968: PUSH
82969: LD_VAR 0 12
82973: PUSH
82974: LD_VAR 0 13
82978: PUSH
82979: LD_VAR 0 14
82983: PUSH
82984: LD_VAR 0 15
82988: PUSH
82989: LD_VAR 0 16
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: PUSH
83002: LD_VAR 0 4
83006: PUSH
83007: LD_INT 1
83009: PLUS
83010: ARRAY
83011: ST_TO_ADDR
83012: GO 83143
83014: LD_INT 2
83016: DOUBLE
83017: EQUAL
83018: IFTRUE 83022
83020: GO 83078
83022: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83023: LD_ADDR_VAR 0 9
83027: PUSH
83028: LD_VAR 0 17
83032: PUSH
83033: LD_VAR 0 18
83037: PUSH
83038: LD_VAR 0 19
83042: PUSH
83043: LD_VAR 0 20
83047: PUSH
83048: LD_VAR 0 21
83052: PUSH
83053: LD_VAR 0 22
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: LIST
83062: LIST
83063: LIST
83064: LIST
83065: PUSH
83066: LD_VAR 0 4
83070: PUSH
83071: LD_INT 1
83073: PLUS
83074: ARRAY
83075: ST_TO_ADDR
83076: GO 83143
83078: LD_INT 3
83080: DOUBLE
83081: EQUAL
83082: IFTRUE 83086
83084: GO 83142
83086: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83087: LD_ADDR_VAR 0 9
83091: PUSH
83092: LD_VAR 0 23
83096: PUSH
83097: LD_VAR 0 24
83101: PUSH
83102: LD_VAR 0 25
83106: PUSH
83107: LD_VAR 0 26
83111: PUSH
83112: LD_VAR 0 27
83116: PUSH
83117: LD_VAR 0 28
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: PUSH
83130: LD_VAR 0 4
83134: PUSH
83135: LD_INT 1
83137: PLUS
83138: ARRAY
83139: ST_TO_ADDR
83140: GO 83143
83142: POP
83143: GO 83698
83145: LD_INT 2
83147: DOUBLE
83148: EQUAL
83149: IFTRUE 83159
83151: LD_INT 3
83153: DOUBLE
83154: EQUAL
83155: IFTRUE 83159
83157: GO 83215
83159: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83160: LD_ADDR_VAR 0 9
83164: PUSH
83165: LD_VAR 0 29
83169: PUSH
83170: LD_VAR 0 30
83174: PUSH
83175: LD_VAR 0 31
83179: PUSH
83180: LD_VAR 0 32
83184: PUSH
83185: LD_VAR 0 33
83189: PUSH
83190: LD_VAR 0 34
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: LIST
83199: LIST
83200: LIST
83201: LIST
83202: PUSH
83203: LD_VAR 0 4
83207: PUSH
83208: LD_INT 1
83210: PLUS
83211: ARRAY
83212: ST_TO_ADDR
83213: GO 83698
83215: LD_INT 16
83217: DOUBLE
83218: EQUAL
83219: IFTRUE 83277
83221: LD_INT 17
83223: DOUBLE
83224: EQUAL
83225: IFTRUE 83277
83227: LD_INT 18
83229: DOUBLE
83230: EQUAL
83231: IFTRUE 83277
83233: LD_INT 19
83235: DOUBLE
83236: EQUAL
83237: IFTRUE 83277
83239: LD_INT 22
83241: DOUBLE
83242: EQUAL
83243: IFTRUE 83277
83245: LD_INT 20
83247: DOUBLE
83248: EQUAL
83249: IFTRUE 83277
83251: LD_INT 21
83253: DOUBLE
83254: EQUAL
83255: IFTRUE 83277
83257: LD_INT 23
83259: DOUBLE
83260: EQUAL
83261: IFTRUE 83277
83263: LD_INT 24
83265: DOUBLE
83266: EQUAL
83267: IFTRUE 83277
83269: LD_INT 25
83271: DOUBLE
83272: EQUAL
83273: IFTRUE 83277
83275: GO 83333
83277: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83278: LD_ADDR_VAR 0 9
83282: PUSH
83283: LD_VAR 0 35
83287: PUSH
83288: LD_VAR 0 36
83292: PUSH
83293: LD_VAR 0 37
83297: PUSH
83298: LD_VAR 0 38
83302: PUSH
83303: LD_VAR 0 39
83307: PUSH
83308: LD_VAR 0 40
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: LIST
83317: LIST
83318: LIST
83319: LIST
83320: PUSH
83321: LD_VAR 0 4
83325: PUSH
83326: LD_INT 1
83328: PLUS
83329: ARRAY
83330: ST_TO_ADDR
83331: GO 83698
83333: LD_INT 6
83335: DOUBLE
83336: EQUAL
83337: IFTRUE 83389
83339: LD_INT 7
83341: DOUBLE
83342: EQUAL
83343: IFTRUE 83389
83345: LD_INT 8
83347: DOUBLE
83348: EQUAL
83349: IFTRUE 83389
83351: LD_INT 13
83353: DOUBLE
83354: EQUAL
83355: IFTRUE 83389
83357: LD_INT 12
83359: DOUBLE
83360: EQUAL
83361: IFTRUE 83389
83363: LD_INT 15
83365: DOUBLE
83366: EQUAL
83367: IFTRUE 83389
83369: LD_INT 11
83371: DOUBLE
83372: EQUAL
83373: IFTRUE 83389
83375: LD_INT 14
83377: DOUBLE
83378: EQUAL
83379: IFTRUE 83389
83381: LD_INT 10
83383: DOUBLE
83384: EQUAL
83385: IFTRUE 83389
83387: GO 83445
83389: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
83390: LD_ADDR_VAR 0 9
83394: PUSH
83395: LD_VAR 0 41
83399: PUSH
83400: LD_VAR 0 42
83404: PUSH
83405: LD_VAR 0 43
83409: PUSH
83410: LD_VAR 0 44
83414: PUSH
83415: LD_VAR 0 45
83419: PUSH
83420: LD_VAR 0 46
83424: PUSH
83425: EMPTY
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: PUSH
83433: LD_VAR 0 4
83437: PUSH
83438: LD_INT 1
83440: PLUS
83441: ARRAY
83442: ST_TO_ADDR
83443: GO 83698
83445: LD_INT 36
83447: DOUBLE
83448: EQUAL
83449: IFTRUE 83453
83451: GO 83509
83453: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83454: LD_ADDR_VAR 0 9
83458: PUSH
83459: LD_VAR 0 47
83463: PUSH
83464: LD_VAR 0 48
83468: PUSH
83469: LD_VAR 0 49
83473: PUSH
83474: LD_VAR 0 50
83478: PUSH
83479: LD_VAR 0 51
83483: PUSH
83484: LD_VAR 0 52
83488: PUSH
83489: EMPTY
83490: LIST
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: LIST
83496: PUSH
83497: LD_VAR 0 4
83501: PUSH
83502: LD_INT 1
83504: PLUS
83505: ARRAY
83506: ST_TO_ADDR
83507: GO 83698
83509: LD_INT 4
83511: DOUBLE
83512: EQUAL
83513: IFTRUE 83535
83515: LD_INT 5
83517: DOUBLE
83518: EQUAL
83519: IFTRUE 83535
83521: LD_INT 34
83523: DOUBLE
83524: EQUAL
83525: IFTRUE 83535
83527: LD_INT 37
83529: DOUBLE
83530: EQUAL
83531: IFTRUE 83535
83533: GO 83591
83535: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83536: LD_ADDR_VAR 0 9
83540: PUSH
83541: LD_VAR 0 53
83545: PUSH
83546: LD_VAR 0 54
83550: PUSH
83551: LD_VAR 0 55
83555: PUSH
83556: LD_VAR 0 56
83560: PUSH
83561: LD_VAR 0 57
83565: PUSH
83566: LD_VAR 0 58
83570: PUSH
83571: EMPTY
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: PUSH
83579: LD_VAR 0 4
83583: PUSH
83584: LD_INT 1
83586: PLUS
83587: ARRAY
83588: ST_TO_ADDR
83589: GO 83698
83591: LD_INT 31
83593: DOUBLE
83594: EQUAL
83595: IFTRUE 83641
83597: LD_INT 32
83599: DOUBLE
83600: EQUAL
83601: IFTRUE 83641
83603: LD_INT 33
83605: DOUBLE
83606: EQUAL
83607: IFTRUE 83641
83609: LD_INT 27
83611: DOUBLE
83612: EQUAL
83613: IFTRUE 83641
83615: LD_INT 26
83617: DOUBLE
83618: EQUAL
83619: IFTRUE 83641
83621: LD_INT 28
83623: DOUBLE
83624: EQUAL
83625: IFTRUE 83641
83627: LD_INT 29
83629: DOUBLE
83630: EQUAL
83631: IFTRUE 83641
83633: LD_INT 30
83635: DOUBLE
83636: EQUAL
83637: IFTRUE 83641
83639: GO 83697
83641: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
83642: LD_ADDR_VAR 0 9
83646: PUSH
83647: LD_VAR 0 59
83651: PUSH
83652: LD_VAR 0 60
83656: PUSH
83657: LD_VAR 0 61
83661: PUSH
83662: LD_VAR 0 62
83666: PUSH
83667: LD_VAR 0 63
83671: PUSH
83672: LD_VAR 0 64
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: PUSH
83685: LD_VAR 0 4
83689: PUSH
83690: LD_INT 1
83692: PLUS
83693: ARRAY
83694: ST_TO_ADDR
83695: GO 83698
83697: POP
// temp_list2 = [ ] ;
83698: LD_ADDR_VAR 0 10
83702: PUSH
83703: EMPTY
83704: ST_TO_ADDR
// for i in temp_list do
83705: LD_ADDR_VAR 0 8
83709: PUSH
83710: LD_VAR 0 9
83714: PUSH
83715: FOR_IN
83716: IFFALSE 83768
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
83718: LD_ADDR_VAR 0 10
83722: PUSH
83723: LD_VAR 0 10
83727: PUSH
83728: LD_VAR 0 8
83732: PUSH
83733: LD_INT 1
83735: ARRAY
83736: PUSH
83737: LD_VAR 0 2
83741: PLUS
83742: PUSH
83743: LD_VAR 0 8
83747: PUSH
83748: LD_INT 2
83750: ARRAY
83751: PUSH
83752: LD_VAR 0 3
83756: PLUS
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: EMPTY
83763: LIST
83764: ADD
83765: ST_TO_ADDR
83766: GO 83715
83768: POP
83769: POP
// result = temp_list2 ;
83770: LD_ADDR_VAR 0 7
83774: PUSH
83775: LD_VAR 0 10
83779: ST_TO_ADDR
// end ;
83780: LD_VAR 0 7
83784: RET
// export function EnemyInRange ( unit , dist ) ; begin
83785: LD_INT 0
83787: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83788: LD_ADDR_VAR 0 3
83792: PUSH
83793: LD_VAR 0 1
83797: PPUSH
83798: CALL_OW 255
83802: PPUSH
83803: LD_VAR 0 1
83807: PPUSH
83808: CALL_OW 250
83812: PPUSH
83813: LD_VAR 0 1
83817: PPUSH
83818: CALL_OW 251
83822: PPUSH
83823: LD_VAR 0 2
83827: PPUSH
83828: CALL 57889 0 4
83832: PUSH
83833: LD_INT 4
83835: ARRAY
83836: ST_TO_ADDR
// end ;
83837: LD_VAR 0 3
83841: RET
// export function PlayerSeeMe ( unit ) ; begin
83842: LD_INT 0
83844: PPUSH
// result := See ( your_side , unit ) ;
83845: LD_ADDR_VAR 0 2
83849: PUSH
83850: LD_OWVAR 2
83854: PPUSH
83855: LD_VAR 0 1
83859: PPUSH
83860: CALL_OW 292
83864: ST_TO_ADDR
// end ;
83865: LD_VAR 0 2
83869: RET
// export function ReverseDir ( unit ) ; begin
83870: LD_INT 0
83872: PPUSH
// if not unit then
83873: LD_VAR 0 1
83877: NOT
83878: IFFALSE 83882
// exit ;
83880: GO 83928
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
83882: LD_ADDR_VAR 0 2
83886: PUSH
83887: LD_INT 3
83889: PUSH
83890: LD_INT 4
83892: PUSH
83893: LD_INT 5
83895: PUSH
83896: LD_INT 0
83898: PUSH
83899: LD_INT 1
83901: PUSH
83902: LD_INT 2
83904: PUSH
83905: EMPTY
83906: LIST
83907: LIST
83908: LIST
83909: LIST
83910: LIST
83911: LIST
83912: PUSH
83913: LD_VAR 0 1
83917: PPUSH
83918: CALL_OW 254
83922: PUSH
83923: LD_INT 1
83925: PLUS
83926: ARRAY
83927: ST_TO_ADDR
// end ;
83928: LD_VAR 0 2
83932: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83933: LD_INT 0
83935: PPUSH
83936: PPUSH
83937: PPUSH
83938: PPUSH
83939: PPUSH
// if not hexes then
83940: LD_VAR 0 2
83944: NOT
83945: IFFALSE 83949
// exit ;
83947: GO 84097
// dist := 9999 ;
83949: LD_ADDR_VAR 0 5
83953: PUSH
83954: LD_INT 9999
83956: ST_TO_ADDR
// for i = 1 to hexes do
83957: LD_ADDR_VAR 0 4
83961: PUSH
83962: DOUBLE
83963: LD_INT 1
83965: DEC
83966: ST_TO_ADDR
83967: LD_VAR 0 2
83971: PUSH
83972: FOR_TO
83973: IFFALSE 84085
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83975: LD_VAR 0 1
83979: PPUSH
83980: LD_VAR 0 2
83984: PUSH
83985: LD_VAR 0 4
83989: ARRAY
83990: PUSH
83991: LD_INT 1
83993: ARRAY
83994: PPUSH
83995: LD_VAR 0 2
83999: PUSH
84000: LD_VAR 0 4
84004: ARRAY
84005: PUSH
84006: LD_INT 2
84008: ARRAY
84009: PPUSH
84010: CALL_OW 297
84014: PUSH
84015: LD_VAR 0 5
84019: LESS
84020: IFFALSE 84083
// begin hex := hexes [ i ] ;
84022: LD_ADDR_VAR 0 7
84026: PUSH
84027: LD_VAR 0 2
84031: PUSH
84032: LD_VAR 0 4
84036: ARRAY
84037: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84038: LD_ADDR_VAR 0 5
84042: PUSH
84043: LD_VAR 0 1
84047: PPUSH
84048: LD_VAR 0 2
84052: PUSH
84053: LD_VAR 0 4
84057: ARRAY
84058: PUSH
84059: LD_INT 1
84061: ARRAY
84062: PPUSH
84063: LD_VAR 0 2
84067: PUSH
84068: LD_VAR 0 4
84072: ARRAY
84073: PUSH
84074: LD_INT 2
84076: ARRAY
84077: PPUSH
84078: CALL_OW 297
84082: ST_TO_ADDR
// end ; end ;
84083: GO 83972
84085: POP
84086: POP
// result := hex ;
84087: LD_ADDR_VAR 0 3
84091: PUSH
84092: LD_VAR 0 7
84096: ST_TO_ADDR
// end ;
84097: LD_VAR 0 3
84101: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84102: LD_INT 0
84104: PPUSH
84105: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84106: LD_VAR 0 1
84110: NOT
84111: PUSH
84112: LD_VAR 0 1
84116: PUSH
84117: LD_INT 21
84119: PUSH
84120: LD_INT 2
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 23
84129: PUSH
84130: LD_INT 2
84132: PUSH
84133: EMPTY
84134: LIST
84135: LIST
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PPUSH
84141: CALL_OW 69
84145: IN
84146: NOT
84147: OR
84148: IFFALSE 84152
// exit ;
84150: GO 84199
// for i = 1 to 3 do
84152: LD_ADDR_VAR 0 3
84156: PUSH
84157: DOUBLE
84158: LD_INT 1
84160: DEC
84161: ST_TO_ADDR
84162: LD_INT 3
84164: PUSH
84165: FOR_TO
84166: IFFALSE 84197
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84168: LD_VAR 0 1
84172: PPUSH
84173: CALL_OW 250
84177: PPUSH
84178: LD_VAR 0 1
84182: PPUSH
84183: CALL_OW 251
84187: PPUSH
84188: LD_INT 1
84190: PPUSH
84191: CALL_OW 453
84195: GO 84165
84197: POP
84198: POP
// end ;
84199: LD_VAR 0 2
84203: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84204: LD_INT 0
84206: PPUSH
84207: PPUSH
84208: PPUSH
84209: PPUSH
84210: PPUSH
84211: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84212: LD_VAR 0 1
84216: NOT
84217: PUSH
84218: LD_VAR 0 2
84222: NOT
84223: OR
84224: PUSH
84225: LD_VAR 0 1
84229: PPUSH
84230: CALL_OW 314
84234: OR
84235: IFFALSE 84239
// exit ;
84237: GO 84680
// x := GetX ( enemy_unit ) ;
84239: LD_ADDR_VAR 0 7
84243: PUSH
84244: LD_VAR 0 2
84248: PPUSH
84249: CALL_OW 250
84253: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84254: LD_ADDR_VAR 0 8
84258: PUSH
84259: LD_VAR 0 2
84263: PPUSH
84264: CALL_OW 251
84268: ST_TO_ADDR
// if not x or not y then
84269: LD_VAR 0 7
84273: NOT
84274: PUSH
84275: LD_VAR 0 8
84279: NOT
84280: OR
84281: IFFALSE 84285
// exit ;
84283: GO 84680
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84285: LD_ADDR_VAR 0 6
84289: PUSH
84290: LD_VAR 0 7
84294: PPUSH
84295: LD_INT 0
84297: PPUSH
84298: LD_INT 4
84300: PPUSH
84301: CALL_OW 272
84305: PUSH
84306: LD_VAR 0 8
84310: PPUSH
84311: LD_INT 0
84313: PPUSH
84314: LD_INT 4
84316: PPUSH
84317: CALL_OW 273
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PUSH
84326: LD_VAR 0 7
84330: PPUSH
84331: LD_INT 1
84333: PPUSH
84334: LD_INT 4
84336: PPUSH
84337: CALL_OW 272
84341: PUSH
84342: LD_VAR 0 8
84346: PPUSH
84347: LD_INT 1
84349: PPUSH
84350: LD_INT 4
84352: PPUSH
84353: CALL_OW 273
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_VAR 0 7
84366: PPUSH
84367: LD_INT 2
84369: PPUSH
84370: LD_INT 4
84372: PPUSH
84373: CALL_OW 272
84377: PUSH
84378: LD_VAR 0 8
84382: PPUSH
84383: LD_INT 2
84385: PPUSH
84386: LD_INT 4
84388: PPUSH
84389: CALL_OW 273
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: LD_VAR 0 7
84402: PPUSH
84403: LD_INT 3
84405: PPUSH
84406: LD_INT 4
84408: PPUSH
84409: CALL_OW 272
84413: PUSH
84414: LD_VAR 0 8
84418: PPUSH
84419: LD_INT 3
84421: PPUSH
84422: LD_INT 4
84424: PPUSH
84425: CALL_OW 273
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_VAR 0 7
84438: PPUSH
84439: LD_INT 4
84441: PPUSH
84442: LD_INT 4
84444: PPUSH
84445: CALL_OW 272
84449: PUSH
84450: LD_VAR 0 8
84454: PPUSH
84455: LD_INT 4
84457: PPUSH
84458: LD_INT 4
84460: PPUSH
84461: CALL_OW 273
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PUSH
84470: LD_VAR 0 7
84474: PPUSH
84475: LD_INT 5
84477: PPUSH
84478: LD_INT 4
84480: PPUSH
84481: CALL_OW 272
84485: PUSH
84486: LD_VAR 0 8
84490: PPUSH
84491: LD_INT 5
84493: PPUSH
84494: LD_INT 4
84496: PPUSH
84497: CALL_OW 273
84501: PUSH
84502: EMPTY
84503: LIST
84504: LIST
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: ST_TO_ADDR
// for i = tmp downto 1 do
84514: LD_ADDR_VAR 0 4
84518: PUSH
84519: DOUBLE
84520: LD_VAR 0 6
84524: INC
84525: ST_TO_ADDR
84526: LD_INT 1
84528: PUSH
84529: FOR_DOWNTO
84530: IFFALSE 84631
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84532: LD_VAR 0 6
84536: PUSH
84537: LD_VAR 0 4
84541: ARRAY
84542: PUSH
84543: LD_INT 1
84545: ARRAY
84546: PPUSH
84547: LD_VAR 0 6
84551: PUSH
84552: LD_VAR 0 4
84556: ARRAY
84557: PUSH
84558: LD_INT 2
84560: ARRAY
84561: PPUSH
84562: CALL_OW 488
84566: NOT
84567: PUSH
84568: LD_VAR 0 6
84572: PUSH
84573: LD_VAR 0 4
84577: ARRAY
84578: PUSH
84579: LD_INT 1
84581: ARRAY
84582: PPUSH
84583: LD_VAR 0 6
84587: PUSH
84588: LD_VAR 0 4
84592: ARRAY
84593: PUSH
84594: LD_INT 2
84596: ARRAY
84597: PPUSH
84598: CALL_OW 428
84602: PUSH
84603: LD_INT 0
84605: NONEQUAL
84606: OR
84607: IFFALSE 84629
// tmp := Delete ( tmp , i ) ;
84609: LD_ADDR_VAR 0 6
84613: PUSH
84614: LD_VAR 0 6
84618: PPUSH
84619: LD_VAR 0 4
84623: PPUSH
84624: CALL_OW 3
84628: ST_TO_ADDR
84629: GO 84529
84631: POP
84632: POP
// j := GetClosestHex ( unit , tmp ) ;
84633: LD_ADDR_VAR 0 5
84637: PUSH
84638: LD_VAR 0 1
84642: PPUSH
84643: LD_VAR 0 6
84647: PPUSH
84648: CALL 83933 0 2
84652: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
84653: LD_VAR 0 1
84657: PPUSH
84658: LD_VAR 0 5
84662: PUSH
84663: LD_INT 1
84665: ARRAY
84666: PPUSH
84667: LD_VAR 0 5
84671: PUSH
84672: LD_INT 2
84674: ARRAY
84675: PPUSH
84676: CALL_OW 111
// end ;
84680: LD_VAR 0 3
84684: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84685: LD_INT 0
84687: PPUSH
84688: PPUSH
84689: PPUSH
// uc_side = 0 ;
84690: LD_ADDR_OWVAR 20
84694: PUSH
84695: LD_INT 0
84697: ST_TO_ADDR
// uc_nation = 0 ;
84698: LD_ADDR_OWVAR 21
84702: PUSH
84703: LD_INT 0
84705: ST_TO_ADDR
// InitHc ;
84706: CALL_OW 19
// InitVc ;
84710: CALL_OW 20
// if mastodonts then
84714: LD_VAR 0 6
84718: IFFALSE 84785
// for i = 1 to mastodonts do
84720: LD_ADDR_VAR 0 11
84724: PUSH
84725: DOUBLE
84726: LD_INT 1
84728: DEC
84729: ST_TO_ADDR
84730: LD_VAR 0 6
84734: PUSH
84735: FOR_TO
84736: IFFALSE 84783
// begin vc_chassis := 31 ;
84738: LD_ADDR_OWVAR 37
84742: PUSH
84743: LD_INT 31
84745: ST_TO_ADDR
// vc_control := control_rider ;
84746: LD_ADDR_OWVAR 38
84750: PUSH
84751: LD_INT 4
84753: ST_TO_ADDR
// animal := CreateVehicle ;
84754: LD_ADDR_VAR 0 12
84758: PUSH
84759: CALL_OW 45
84763: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84764: LD_VAR 0 12
84768: PPUSH
84769: LD_VAR 0 8
84773: PPUSH
84774: LD_INT 0
84776: PPUSH
84777: CALL 91530 0 3
// end ;
84781: GO 84735
84783: POP
84784: POP
// if horses then
84785: LD_VAR 0 5
84789: IFFALSE 84856
// for i = 1 to horses do
84791: LD_ADDR_VAR 0 11
84795: PUSH
84796: DOUBLE
84797: LD_INT 1
84799: DEC
84800: ST_TO_ADDR
84801: LD_VAR 0 5
84805: PUSH
84806: FOR_TO
84807: IFFALSE 84854
// begin hc_class := 21 ;
84809: LD_ADDR_OWVAR 28
84813: PUSH
84814: LD_INT 21
84816: ST_TO_ADDR
// hc_gallery :=  ;
84817: LD_ADDR_OWVAR 33
84821: PUSH
84822: LD_STRING 
84824: ST_TO_ADDR
// animal := CreateHuman ;
84825: LD_ADDR_VAR 0 12
84829: PUSH
84830: CALL_OW 44
84834: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84835: LD_VAR 0 12
84839: PPUSH
84840: LD_VAR 0 8
84844: PPUSH
84845: LD_INT 0
84847: PPUSH
84848: CALL 91530 0 3
// end ;
84852: GO 84806
84854: POP
84855: POP
// if birds then
84856: LD_VAR 0 1
84860: IFFALSE 84927
// for i = 1 to birds do
84862: LD_ADDR_VAR 0 11
84866: PUSH
84867: DOUBLE
84868: LD_INT 1
84870: DEC
84871: ST_TO_ADDR
84872: LD_VAR 0 1
84876: PUSH
84877: FOR_TO
84878: IFFALSE 84925
// begin hc_class = 18 ;
84880: LD_ADDR_OWVAR 28
84884: PUSH
84885: LD_INT 18
84887: ST_TO_ADDR
// hc_gallery =  ;
84888: LD_ADDR_OWVAR 33
84892: PUSH
84893: LD_STRING 
84895: ST_TO_ADDR
// animal := CreateHuman ;
84896: LD_ADDR_VAR 0 12
84900: PUSH
84901: CALL_OW 44
84905: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84906: LD_VAR 0 12
84910: PPUSH
84911: LD_VAR 0 8
84915: PPUSH
84916: LD_INT 0
84918: PPUSH
84919: CALL 91530 0 3
// end ;
84923: GO 84877
84925: POP
84926: POP
// if tigers then
84927: LD_VAR 0 2
84931: IFFALSE 85015
// for i = 1 to tigers do
84933: LD_ADDR_VAR 0 11
84937: PUSH
84938: DOUBLE
84939: LD_INT 1
84941: DEC
84942: ST_TO_ADDR
84943: LD_VAR 0 2
84947: PUSH
84948: FOR_TO
84949: IFFALSE 85013
// begin hc_class = class_tiger ;
84951: LD_ADDR_OWVAR 28
84955: PUSH
84956: LD_INT 14
84958: ST_TO_ADDR
// hc_gallery =  ;
84959: LD_ADDR_OWVAR 33
84963: PUSH
84964: LD_STRING 
84966: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84967: LD_ADDR_OWVAR 35
84971: PUSH
84972: LD_INT 7
84974: NEG
84975: PPUSH
84976: LD_INT 7
84978: PPUSH
84979: CALL_OW 12
84983: ST_TO_ADDR
// animal := CreateHuman ;
84984: LD_ADDR_VAR 0 12
84988: PUSH
84989: CALL_OW 44
84993: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84994: LD_VAR 0 12
84998: PPUSH
84999: LD_VAR 0 8
85003: PPUSH
85004: LD_INT 0
85006: PPUSH
85007: CALL 91530 0 3
// end ;
85011: GO 84948
85013: POP
85014: POP
// if apemans then
85015: LD_VAR 0 3
85019: IFFALSE 85142
// for i = 1 to apemans do
85021: LD_ADDR_VAR 0 11
85025: PUSH
85026: DOUBLE
85027: LD_INT 1
85029: DEC
85030: ST_TO_ADDR
85031: LD_VAR 0 3
85035: PUSH
85036: FOR_TO
85037: IFFALSE 85140
// begin hc_class = class_apeman ;
85039: LD_ADDR_OWVAR 28
85043: PUSH
85044: LD_INT 12
85046: ST_TO_ADDR
// hc_gallery =  ;
85047: LD_ADDR_OWVAR 33
85051: PUSH
85052: LD_STRING 
85054: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85055: LD_ADDR_OWVAR 35
85059: PUSH
85060: LD_INT 5
85062: NEG
85063: PPUSH
85064: LD_INT 5
85066: PPUSH
85067: CALL_OW 12
85071: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85072: LD_ADDR_OWVAR 31
85076: PUSH
85077: LD_INT 1
85079: PPUSH
85080: LD_INT 3
85082: PPUSH
85083: CALL_OW 12
85087: PUSH
85088: LD_INT 1
85090: PPUSH
85091: LD_INT 3
85093: PPUSH
85094: CALL_OW 12
85098: PUSH
85099: LD_INT 0
85101: PUSH
85102: LD_INT 0
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: ST_TO_ADDR
// animal := CreateHuman ;
85111: LD_ADDR_VAR 0 12
85115: PUSH
85116: CALL_OW 44
85120: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85121: LD_VAR 0 12
85125: PPUSH
85126: LD_VAR 0 8
85130: PPUSH
85131: LD_INT 0
85133: PPUSH
85134: CALL 91530 0 3
// end ;
85138: GO 85036
85140: POP
85141: POP
// if enchidnas then
85142: LD_VAR 0 4
85146: IFFALSE 85213
// for i = 1 to enchidnas do
85148: LD_ADDR_VAR 0 11
85152: PUSH
85153: DOUBLE
85154: LD_INT 1
85156: DEC
85157: ST_TO_ADDR
85158: LD_VAR 0 4
85162: PUSH
85163: FOR_TO
85164: IFFALSE 85211
// begin hc_class = 13 ;
85166: LD_ADDR_OWVAR 28
85170: PUSH
85171: LD_INT 13
85173: ST_TO_ADDR
// hc_gallery =  ;
85174: LD_ADDR_OWVAR 33
85178: PUSH
85179: LD_STRING 
85181: ST_TO_ADDR
// animal := CreateHuman ;
85182: LD_ADDR_VAR 0 12
85186: PUSH
85187: CALL_OW 44
85191: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85192: LD_VAR 0 12
85196: PPUSH
85197: LD_VAR 0 8
85201: PPUSH
85202: LD_INT 0
85204: PPUSH
85205: CALL 91530 0 3
// end ;
85209: GO 85163
85211: POP
85212: POP
// if fishes then
85213: LD_VAR 0 7
85217: IFFALSE 85284
// for i = 1 to fishes do
85219: LD_ADDR_VAR 0 11
85223: PUSH
85224: DOUBLE
85225: LD_INT 1
85227: DEC
85228: ST_TO_ADDR
85229: LD_VAR 0 7
85233: PUSH
85234: FOR_TO
85235: IFFALSE 85282
// begin hc_class = 20 ;
85237: LD_ADDR_OWVAR 28
85241: PUSH
85242: LD_INT 20
85244: ST_TO_ADDR
// hc_gallery =  ;
85245: LD_ADDR_OWVAR 33
85249: PUSH
85250: LD_STRING 
85252: ST_TO_ADDR
// animal := CreateHuman ;
85253: LD_ADDR_VAR 0 12
85257: PUSH
85258: CALL_OW 44
85262: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85263: LD_VAR 0 12
85267: PPUSH
85268: LD_VAR 0 9
85272: PPUSH
85273: LD_INT 0
85275: PPUSH
85276: CALL 91530 0 3
// end ;
85280: GO 85234
85282: POP
85283: POP
// end ;
85284: LD_VAR 0 10
85288: RET
// export function WantHeal ( sci , unit ) ; begin
85289: LD_INT 0
85291: PPUSH
// if GetTaskList ( sci ) > 0 then
85292: LD_VAR 0 1
85296: PPUSH
85297: CALL_OW 437
85301: PUSH
85302: LD_INT 0
85304: GREATER
85305: IFFALSE 85375
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85307: LD_VAR 0 1
85311: PPUSH
85312: CALL_OW 437
85316: PUSH
85317: LD_INT 1
85319: ARRAY
85320: PUSH
85321: LD_INT 1
85323: ARRAY
85324: PUSH
85325: LD_STRING l
85327: EQUAL
85328: PUSH
85329: LD_VAR 0 1
85333: PPUSH
85334: CALL_OW 437
85338: PUSH
85339: LD_INT 1
85341: ARRAY
85342: PUSH
85343: LD_INT 4
85345: ARRAY
85346: PUSH
85347: LD_VAR 0 2
85351: EQUAL
85352: AND
85353: IFFALSE 85365
// result := true else
85355: LD_ADDR_VAR 0 3
85359: PUSH
85360: LD_INT 1
85362: ST_TO_ADDR
85363: GO 85373
// result := false ;
85365: LD_ADDR_VAR 0 3
85369: PUSH
85370: LD_INT 0
85372: ST_TO_ADDR
// end else
85373: GO 85383
// result := false ;
85375: LD_ADDR_VAR 0 3
85379: PUSH
85380: LD_INT 0
85382: ST_TO_ADDR
// end ;
85383: LD_VAR 0 3
85387: RET
// export function HealTarget ( sci ) ; begin
85388: LD_INT 0
85390: PPUSH
// if not sci then
85391: LD_VAR 0 1
85395: NOT
85396: IFFALSE 85400
// exit ;
85398: GO 85465
// result := 0 ;
85400: LD_ADDR_VAR 0 2
85404: PUSH
85405: LD_INT 0
85407: ST_TO_ADDR
// if GetTaskList ( sci ) then
85408: LD_VAR 0 1
85412: PPUSH
85413: CALL_OW 437
85417: IFFALSE 85465
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85419: LD_VAR 0 1
85423: PPUSH
85424: CALL_OW 437
85428: PUSH
85429: LD_INT 1
85431: ARRAY
85432: PUSH
85433: LD_INT 1
85435: ARRAY
85436: PUSH
85437: LD_STRING l
85439: EQUAL
85440: IFFALSE 85465
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85442: LD_ADDR_VAR 0 2
85446: PUSH
85447: LD_VAR 0 1
85451: PPUSH
85452: CALL_OW 437
85456: PUSH
85457: LD_INT 1
85459: ARRAY
85460: PUSH
85461: LD_INT 4
85463: ARRAY
85464: ST_TO_ADDR
// end ;
85465: LD_VAR 0 2
85469: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
85470: LD_INT 0
85472: PPUSH
85473: PPUSH
85474: PPUSH
85475: PPUSH
85476: PPUSH
85477: PPUSH
85478: PPUSH
85479: PPUSH
85480: PPUSH
85481: PPUSH
85482: PPUSH
85483: PPUSH
85484: PPUSH
85485: PPUSH
85486: PPUSH
85487: PPUSH
85488: PPUSH
85489: PPUSH
85490: PPUSH
85491: PPUSH
85492: PPUSH
85493: PPUSH
85494: PPUSH
85495: PPUSH
85496: PPUSH
85497: PPUSH
85498: PPUSH
85499: PPUSH
85500: PPUSH
85501: PPUSH
85502: PPUSH
85503: PPUSH
85504: PPUSH
85505: PPUSH
// if not list then
85506: LD_VAR 0 1
85510: NOT
85511: IFFALSE 85515
// exit ;
85513: GO 90141
// base := list [ 1 ] ;
85515: LD_ADDR_VAR 0 3
85519: PUSH
85520: LD_VAR 0 1
85524: PUSH
85525: LD_INT 1
85527: ARRAY
85528: ST_TO_ADDR
// group := list [ 2 ] ;
85529: LD_ADDR_VAR 0 4
85533: PUSH
85534: LD_VAR 0 1
85538: PUSH
85539: LD_INT 2
85541: ARRAY
85542: ST_TO_ADDR
// path := list [ 3 ] ;
85543: LD_ADDR_VAR 0 5
85547: PUSH
85548: LD_VAR 0 1
85552: PUSH
85553: LD_INT 3
85555: ARRAY
85556: ST_TO_ADDR
// flags := list [ 4 ] ;
85557: LD_ADDR_VAR 0 6
85561: PUSH
85562: LD_VAR 0 1
85566: PUSH
85567: LD_INT 4
85569: ARRAY
85570: ST_TO_ADDR
// mined := [ ] ;
85571: LD_ADDR_VAR 0 27
85575: PUSH
85576: EMPTY
85577: ST_TO_ADDR
// bombed := [ ] ;
85578: LD_ADDR_VAR 0 28
85582: PUSH
85583: EMPTY
85584: ST_TO_ADDR
// healers := [ ] ;
85585: LD_ADDR_VAR 0 31
85589: PUSH
85590: EMPTY
85591: ST_TO_ADDR
// to_heal := [ ] ;
85592: LD_ADDR_VAR 0 30
85596: PUSH
85597: EMPTY
85598: ST_TO_ADDR
// repairs := [ ] ;
85599: LD_ADDR_VAR 0 33
85603: PUSH
85604: EMPTY
85605: ST_TO_ADDR
// to_repair := [ ] ;
85606: LD_ADDR_VAR 0 32
85610: PUSH
85611: EMPTY
85612: ST_TO_ADDR
// if not group or not path then
85613: LD_VAR 0 4
85617: NOT
85618: PUSH
85619: LD_VAR 0 5
85623: NOT
85624: OR
85625: IFFALSE 85629
// exit ;
85627: GO 90141
// side := GetSide ( group [ 1 ] ) ;
85629: LD_ADDR_VAR 0 35
85633: PUSH
85634: LD_VAR 0 4
85638: PUSH
85639: LD_INT 1
85641: ARRAY
85642: PPUSH
85643: CALL_OW 255
85647: ST_TO_ADDR
// if flags then
85648: LD_VAR 0 6
85652: IFFALSE 85796
// begin f_ignore_area := flags [ 1 ] ;
85654: LD_ADDR_VAR 0 17
85658: PUSH
85659: LD_VAR 0 6
85663: PUSH
85664: LD_INT 1
85666: ARRAY
85667: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
85668: LD_ADDR_VAR 0 18
85672: PUSH
85673: LD_VAR 0 6
85677: PUSH
85678: LD_INT 2
85680: ARRAY
85681: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
85682: LD_ADDR_VAR 0 19
85686: PUSH
85687: LD_VAR 0 6
85691: PUSH
85692: LD_INT 3
85694: ARRAY
85695: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
85696: LD_ADDR_VAR 0 20
85700: PUSH
85701: LD_VAR 0 6
85705: PUSH
85706: LD_INT 4
85708: ARRAY
85709: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
85710: LD_ADDR_VAR 0 21
85714: PUSH
85715: LD_VAR 0 6
85719: PUSH
85720: LD_INT 5
85722: ARRAY
85723: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
85724: LD_ADDR_VAR 0 22
85728: PUSH
85729: LD_VAR 0 6
85733: PUSH
85734: LD_INT 6
85736: ARRAY
85737: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
85738: LD_ADDR_VAR 0 23
85742: PUSH
85743: LD_VAR 0 6
85747: PUSH
85748: LD_INT 7
85750: ARRAY
85751: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
85752: LD_ADDR_VAR 0 24
85756: PUSH
85757: LD_VAR 0 6
85761: PUSH
85762: LD_INT 8
85764: ARRAY
85765: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
85766: LD_ADDR_VAR 0 25
85770: PUSH
85771: LD_VAR 0 6
85775: PUSH
85776: LD_INT 9
85778: ARRAY
85779: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
85780: LD_ADDR_VAR 0 26
85784: PUSH
85785: LD_VAR 0 6
85789: PUSH
85790: LD_INT 10
85792: ARRAY
85793: ST_TO_ADDR
// end else
85794: GO 85876
// begin f_ignore_area := false ;
85796: LD_ADDR_VAR 0 17
85800: PUSH
85801: LD_INT 0
85803: ST_TO_ADDR
// f_capture := false ;
85804: LD_ADDR_VAR 0 18
85808: PUSH
85809: LD_INT 0
85811: ST_TO_ADDR
// f_ignore_civ := false ;
85812: LD_ADDR_VAR 0 19
85816: PUSH
85817: LD_INT 0
85819: ST_TO_ADDR
// f_murder := false ;
85820: LD_ADDR_VAR 0 20
85824: PUSH
85825: LD_INT 0
85827: ST_TO_ADDR
// f_mines := false ;
85828: LD_ADDR_VAR 0 21
85832: PUSH
85833: LD_INT 0
85835: ST_TO_ADDR
// f_repair := false ;
85836: LD_ADDR_VAR 0 22
85840: PUSH
85841: LD_INT 0
85843: ST_TO_ADDR
// f_heal := false ;
85844: LD_ADDR_VAR 0 23
85848: PUSH
85849: LD_INT 0
85851: ST_TO_ADDR
// f_spacetime := false ;
85852: LD_ADDR_VAR 0 24
85856: PUSH
85857: LD_INT 0
85859: ST_TO_ADDR
// f_attack_depot := false ;
85860: LD_ADDR_VAR 0 25
85864: PUSH
85865: LD_INT 0
85867: ST_TO_ADDR
// f_crawl := false ;
85868: LD_ADDR_VAR 0 26
85872: PUSH
85873: LD_INT 0
85875: ST_TO_ADDR
// end ; if f_heal then
85876: LD_VAR 0 23
85880: IFFALSE 85907
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
85882: LD_ADDR_VAR 0 31
85886: PUSH
85887: LD_VAR 0 4
85891: PPUSH
85892: LD_INT 25
85894: PUSH
85895: LD_INT 4
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: PPUSH
85902: CALL_OW 72
85906: ST_TO_ADDR
// if f_repair then
85907: LD_VAR 0 22
85911: IFFALSE 85938
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
85913: LD_ADDR_VAR 0 33
85917: PUSH
85918: LD_VAR 0 4
85922: PPUSH
85923: LD_INT 25
85925: PUSH
85926: LD_INT 3
85928: PUSH
85929: EMPTY
85930: LIST
85931: LIST
85932: PPUSH
85933: CALL_OW 72
85937: ST_TO_ADDR
// units_path := [ ] ;
85938: LD_ADDR_VAR 0 16
85942: PUSH
85943: EMPTY
85944: ST_TO_ADDR
// for i = 1 to group do
85945: LD_ADDR_VAR 0 7
85949: PUSH
85950: DOUBLE
85951: LD_INT 1
85953: DEC
85954: ST_TO_ADDR
85955: LD_VAR 0 4
85959: PUSH
85960: FOR_TO
85961: IFFALSE 85990
// units_path := Replace ( units_path , i , path ) ;
85963: LD_ADDR_VAR 0 16
85967: PUSH
85968: LD_VAR 0 16
85972: PPUSH
85973: LD_VAR 0 7
85977: PPUSH
85978: LD_VAR 0 5
85982: PPUSH
85983: CALL_OW 1
85987: ST_TO_ADDR
85988: GO 85960
85990: POP
85991: POP
// repeat for i = group downto 1 do
85992: LD_ADDR_VAR 0 7
85996: PUSH
85997: DOUBLE
85998: LD_VAR 0 4
86002: INC
86003: ST_TO_ADDR
86004: LD_INT 1
86006: PUSH
86007: FOR_DOWNTO
86008: IFFALSE 90104
// begin wait ( 5 ) ;
86010: LD_INT 5
86012: PPUSH
86013: CALL_OW 67
// tmp := [ ] ;
86017: LD_ADDR_VAR 0 14
86021: PUSH
86022: EMPTY
86023: ST_TO_ADDR
// attacking := false ;
86024: LD_ADDR_VAR 0 29
86028: PUSH
86029: LD_INT 0
86031: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86032: LD_VAR 0 4
86036: PUSH
86037: LD_VAR 0 7
86041: ARRAY
86042: PPUSH
86043: CALL_OW 301
86047: PUSH
86048: LD_VAR 0 4
86052: PUSH
86053: LD_VAR 0 7
86057: ARRAY
86058: NOT
86059: OR
86060: IFFALSE 86169
// begin if GetType ( group [ i ] ) = unit_human then
86062: LD_VAR 0 4
86066: PUSH
86067: LD_VAR 0 7
86071: ARRAY
86072: PPUSH
86073: CALL_OW 247
86077: PUSH
86078: LD_INT 1
86080: EQUAL
86081: IFFALSE 86127
// begin to_heal := to_heal diff group [ i ] ;
86083: LD_ADDR_VAR 0 30
86087: PUSH
86088: LD_VAR 0 30
86092: PUSH
86093: LD_VAR 0 4
86097: PUSH
86098: LD_VAR 0 7
86102: ARRAY
86103: DIFF
86104: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86105: LD_ADDR_VAR 0 31
86109: PUSH
86110: LD_VAR 0 31
86114: PUSH
86115: LD_VAR 0 4
86119: PUSH
86120: LD_VAR 0 7
86124: ARRAY
86125: DIFF
86126: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86127: LD_ADDR_VAR 0 4
86131: PUSH
86132: LD_VAR 0 4
86136: PPUSH
86137: LD_VAR 0 7
86141: PPUSH
86142: CALL_OW 3
86146: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86147: LD_ADDR_VAR 0 16
86151: PUSH
86152: LD_VAR 0 16
86156: PPUSH
86157: LD_VAR 0 7
86161: PPUSH
86162: CALL_OW 3
86166: ST_TO_ADDR
// continue ;
86167: GO 86007
// end ; if f_repair then
86169: LD_VAR 0 22
86173: IFFALSE 86662
// begin if GetType ( group [ i ] ) = unit_vehicle then
86175: LD_VAR 0 4
86179: PUSH
86180: LD_VAR 0 7
86184: ARRAY
86185: PPUSH
86186: CALL_OW 247
86190: PUSH
86191: LD_INT 2
86193: EQUAL
86194: IFFALSE 86384
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86196: LD_VAR 0 4
86200: PUSH
86201: LD_VAR 0 7
86205: ARRAY
86206: PPUSH
86207: CALL_OW 256
86211: PUSH
86212: LD_INT 700
86214: LESS
86215: PUSH
86216: LD_VAR 0 4
86220: PUSH
86221: LD_VAR 0 7
86225: ARRAY
86226: PUSH
86227: LD_VAR 0 32
86231: IN
86232: NOT
86233: AND
86234: IFFALSE 86258
// to_repair := to_repair union group [ i ] ;
86236: LD_ADDR_VAR 0 32
86240: PUSH
86241: LD_VAR 0 32
86245: PUSH
86246: LD_VAR 0 4
86250: PUSH
86251: LD_VAR 0 7
86255: ARRAY
86256: UNION
86257: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86258: LD_VAR 0 4
86262: PUSH
86263: LD_VAR 0 7
86267: ARRAY
86268: PPUSH
86269: CALL_OW 256
86273: PUSH
86274: LD_INT 1000
86276: EQUAL
86277: PUSH
86278: LD_VAR 0 4
86282: PUSH
86283: LD_VAR 0 7
86287: ARRAY
86288: PUSH
86289: LD_VAR 0 32
86293: IN
86294: AND
86295: IFFALSE 86319
// to_repair := to_repair diff group [ i ] ;
86297: LD_ADDR_VAR 0 32
86301: PUSH
86302: LD_VAR 0 32
86306: PUSH
86307: LD_VAR 0 4
86311: PUSH
86312: LD_VAR 0 7
86316: ARRAY
86317: DIFF
86318: ST_TO_ADDR
// if group [ i ] in to_repair then
86319: LD_VAR 0 4
86323: PUSH
86324: LD_VAR 0 7
86328: ARRAY
86329: PUSH
86330: LD_VAR 0 32
86334: IN
86335: IFFALSE 86382
// begin if not IsInArea ( group [ i ] , f_repair ) then
86337: LD_VAR 0 4
86341: PUSH
86342: LD_VAR 0 7
86346: ARRAY
86347: PPUSH
86348: LD_VAR 0 22
86352: PPUSH
86353: CALL_OW 308
86357: NOT
86358: IFFALSE 86380
// ComMoveToArea ( group [ i ] , f_repair ) ;
86360: LD_VAR 0 4
86364: PUSH
86365: LD_VAR 0 7
86369: ARRAY
86370: PPUSH
86371: LD_VAR 0 22
86375: PPUSH
86376: CALL_OW 113
// continue ;
86380: GO 86007
// end ; end else
86382: GO 86662
// if group [ i ] in repairs then
86384: LD_VAR 0 4
86388: PUSH
86389: LD_VAR 0 7
86393: ARRAY
86394: PUSH
86395: LD_VAR 0 33
86399: IN
86400: IFFALSE 86662
// begin if IsInUnit ( group [ i ] ) then
86402: LD_VAR 0 4
86406: PUSH
86407: LD_VAR 0 7
86411: ARRAY
86412: PPUSH
86413: CALL_OW 310
86417: IFFALSE 86485
// begin z := IsInUnit ( group [ i ] ) ;
86419: LD_ADDR_VAR 0 13
86423: PUSH
86424: LD_VAR 0 4
86428: PUSH
86429: LD_VAR 0 7
86433: ARRAY
86434: PPUSH
86435: CALL_OW 310
86439: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
86440: LD_VAR 0 13
86444: PUSH
86445: LD_VAR 0 32
86449: IN
86450: PUSH
86451: LD_VAR 0 13
86455: PPUSH
86456: LD_VAR 0 22
86460: PPUSH
86461: CALL_OW 308
86465: AND
86466: IFFALSE 86483
// ComExitVehicle ( group [ i ] ) ;
86468: LD_VAR 0 4
86472: PUSH
86473: LD_VAR 0 7
86477: ARRAY
86478: PPUSH
86479: CALL_OW 121
// end else
86483: GO 86662
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
86485: LD_ADDR_VAR 0 13
86489: PUSH
86490: LD_VAR 0 4
86494: PPUSH
86495: LD_INT 95
86497: PUSH
86498: LD_VAR 0 22
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 58
86509: PUSH
86510: EMPTY
86511: LIST
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: PPUSH
86517: CALL_OW 72
86521: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
86522: LD_VAR 0 4
86526: PUSH
86527: LD_VAR 0 7
86531: ARRAY
86532: PPUSH
86533: CALL_OW 314
86537: NOT
86538: IFFALSE 86660
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
86540: LD_ADDR_VAR 0 10
86544: PUSH
86545: LD_VAR 0 13
86549: PPUSH
86550: LD_VAR 0 4
86554: PUSH
86555: LD_VAR 0 7
86559: ARRAY
86560: PPUSH
86561: CALL_OW 74
86565: ST_TO_ADDR
// if not x then
86566: LD_VAR 0 10
86570: NOT
86571: IFFALSE 86575
// continue ;
86573: GO 86007
// if GetLives ( x ) < 1000 then
86575: LD_VAR 0 10
86579: PPUSH
86580: CALL_OW 256
86584: PUSH
86585: LD_INT 1000
86587: LESS
86588: IFFALSE 86612
// ComRepairVehicle ( group [ i ] , x ) else
86590: LD_VAR 0 4
86594: PUSH
86595: LD_VAR 0 7
86599: ARRAY
86600: PPUSH
86601: LD_VAR 0 10
86605: PPUSH
86606: CALL_OW 129
86610: GO 86660
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
86612: LD_VAR 0 23
86616: PUSH
86617: LD_VAR 0 4
86621: PUSH
86622: LD_VAR 0 7
86626: ARRAY
86627: PPUSH
86628: CALL_OW 256
86632: PUSH
86633: LD_INT 1000
86635: LESS
86636: AND
86637: NOT
86638: IFFALSE 86660
// ComEnterUnit ( group [ i ] , x ) ;
86640: LD_VAR 0 4
86644: PUSH
86645: LD_VAR 0 7
86649: ARRAY
86650: PPUSH
86651: LD_VAR 0 10
86655: PPUSH
86656: CALL_OW 120
// end ; continue ;
86660: GO 86007
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
86662: LD_VAR 0 23
86666: PUSH
86667: LD_VAR 0 4
86671: PUSH
86672: LD_VAR 0 7
86676: ARRAY
86677: PPUSH
86678: CALL_OW 247
86682: PUSH
86683: LD_INT 1
86685: EQUAL
86686: AND
86687: IFFALSE 87165
// begin if group [ i ] in healers then
86689: LD_VAR 0 4
86693: PUSH
86694: LD_VAR 0 7
86698: ARRAY
86699: PUSH
86700: LD_VAR 0 31
86704: IN
86705: IFFALSE 86978
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
86707: LD_VAR 0 4
86711: PUSH
86712: LD_VAR 0 7
86716: ARRAY
86717: PPUSH
86718: LD_VAR 0 23
86722: PPUSH
86723: CALL_OW 308
86727: NOT
86728: PUSH
86729: LD_VAR 0 4
86733: PUSH
86734: LD_VAR 0 7
86738: ARRAY
86739: PPUSH
86740: CALL_OW 314
86744: NOT
86745: AND
86746: IFFALSE 86770
// ComMoveToArea ( group [ i ] , f_heal ) else
86748: LD_VAR 0 4
86752: PUSH
86753: LD_VAR 0 7
86757: ARRAY
86758: PPUSH
86759: LD_VAR 0 23
86763: PPUSH
86764: CALL_OW 113
86768: GO 86976
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
86770: LD_VAR 0 4
86774: PUSH
86775: LD_VAR 0 7
86779: ARRAY
86780: PPUSH
86781: CALL 85388 0 1
86785: PPUSH
86786: CALL_OW 256
86790: PUSH
86791: LD_INT 1000
86793: EQUAL
86794: IFFALSE 86813
// ComStop ( group [ i ] ) else
86796: LD_VAR 0 4
86800: PUSH
86801: LD_VAR 0 7
86805: ARRAY
86806: PPUSH
86807: CALL_OW 141
86811: GO 86976
// if not HasTask ( group [ i ] ) and to_heal then
86813: LD_VAR 0 4
86817: PUSH
86818: LD_VAR 0 7
86822: ARRAY
86823: PPUSH
86824: CALL_OW 314
86828: NOT
86829: PUSH
86830: LD_VAR 0 30
86834: AND
86835: IFFALSE 86976
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
86837: LD_ADDR_VAR 0 13
86841: PUSH
86842: LD_VAR 0 30
86846: PPUSH
86847: LD_INT 3
86849: PUSH
86850: LD_INT 54
86852: PUSH
86853: EMPTY
86854: LIST
86855: PUSH
86856: EMPTY
86857: LIST
86858: LIST
86859: PPUSH
86860: CALL_OW 72
86864: PPUSH
86865: LD_VAR 0 4
86869: PUSH
86870: LD_VAR 0 7
86874: ARRAY
86875: PPUSH
86876: CALL_OW 74
86880: ST_TO_ADDR
// if z then
86881: LD_VAR 0 13
86885: IFFALSE 86976
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
86887: LD_INT 91
86889: PUSH
86890: LD_VAR 0 13
86894: PUSH
86895: LD_INT 10
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: LIST
86902: PUSH
86903: LD_INT 81
86905: PUSH
86906: LD_VAR 0 13
86910: PPUSH
86911: CALL_OW 255
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: EMPTY
86921: LIST
86922: LIST
86923: PPUSH
86924: CALL_OW 69
86928: PUSH
86929: LD_INT 0
86931: EQUAL
86932: IFFALSE 86956
// ComHeal ( group [ i ] , z ) else
86934: LD_VAR 0 4
86938: PUSH
86939: LD_VAR 0 7
86943: ARRAY
86944: PPUSH
86945: LD_VAR 0 13
86949: PPUSH
86950: CALL_OW 128
86954: GO 86976
// ComMoveToArea ( group [ i ] , f_heal ) ;
86956: LD_VAR 0 4
86960: PUSH
86961: LD_VAR 0 7
86965: ARRAY
86966: PPUSH
86967: LD_VAR 0 23
86971: PPUSH
86972: CALL_OW 113
// end ; continue ;
86976: GO 86007
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
86978: LD_VAR 0 4
86982: PUSH
86983: LD_VAR 0 7
86987: ARRAY
86988: PPUSH
86989: CALL_OW 256
86993: PUSH
86994: LD_INT 700
86996: LESS
86997: PUSH
86998: LD_VAR 0 4
87002: PUSH
87003: LD_VAR 0 7
87007: ARRAY
87008: PUSH
87009: LD_VAR 0 30
87013: IN
87014: NOT
87015: AND
87016: IFFALSE 87040
// to_heal := to_heal union group [ i ] ;
87018: LD_ADDR_VAR 0 30
87022: PUSH
87023: LD_VAR 0 30
87027: PUSH
87028: LD_VAR 0 4
87032: PUSH
87033: LD_VAR 0 7
87037: ARRAY
87038: UNION
87039: ST_TO_ADDR
// if group [ i ] in to_heal then
87040: LD_VAR 0 4
87044: PUSH
87045: LD_VAR 0 7
87049: ARRAY
87050: PUSH
87051: LD_VAR 0 30
87055: IN
87056: IFFALSE 87165
// begin if GetLives ( group [ i ] ) = 1000 then
87058: LD_VAR 0 4
87062: PUSH
87063: LD_VAR 0 7
87067: ARRAY
87068: PPUSH
87069: CALL_OW 256
87073: PUSH
87074: LD_INT 1000
87076: EQUAL
87077: IFFALSE 87103
// to_heal := to_heal diff group [ i ] else
87079: LD_ADDR_VAR 0 30
87083: PUSH
87084: LD_VAR 0 30
87088: PUSH
87089: LD_VAR 0 4
87093: PUSH
87094: LD_VAR 0 7
87098: ARRAY
87099: DIFF
87100: ST_TO_ADDR
87101: GO 87165
// begin if not IsInArea ( group [ i ] , to_heal ) then
87103: LD_VAR 0 4
87107: PUSH
87108: LD_VAR 0 7
87112: ARRAY
87113: PPUSH
87114: LD_VAR 0 30
87118: PPUSH
87119: CALL_OW 308
87123: NOT
87124: IFFALSE 87148
// ComMoveToArea ( group [ i ] , f_heal ) else
87126: LD_VAR 0 4
87130: PUSH
87131: LD_VAR 0 7
87135: ARRAY
87136: PPUSH
87137: LD_VAR 0 23
87141: PPUSH
87142: CALL_OW 113
87146: GO 87163
// ComHold ( group [ i ] ) ;
87148: LD_VAR 0 4
87152: PUSH
87153: LD_VAR 0 7
87157: ARRAY
87158: PPUSH
87159: CALL_OW 140
// continue ;
87163: GO 86007
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87165: LD_VAR 0 4
87169: PUSH
87170: LD_VAR 0 7
87174: ARRAY
87175: PPUSH
87176: LD_INT 10
87178: PPUSH
87179: CALL 83785 0 2
87183: NOT
87184: PUSH
87185: LD_VAR 0 16
87189: PUSH
87190: LD_VAR 0 7
87194: ARRAY
87195: PUSH
87196: EMPTY
87197: EQUAL
87198: NOT
87199: AND
87200: IFFALSE 87466
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87202: LD_VAR 0 4
87206: PUSH
87207: LD_VAR 0 7
87211: ARRAY
87212: PPUSH
87213: CALL_OW 262
87217: PUSH
87218: LD_INT 1
87220: PUSH
87221: LD_INT 2
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: IN
87228: IFFALSE 87269
// if GetFuel ( group [ i ] ) < 10 then
87230: LD_VAR 0 4
87234: PUSH
87235: LD_VAR 0 7
87239: ARRAY
87240: PPUSH
87241: CALL_OW 261
87245: PUSH
87246: LD_INT 10
87248: LESS
87249: IFFALSE 87269
// SetFuel ( group [ i ] , 12 ) ;
87251: LD_VAR 0 4
87255: PUSH
87256: LD_VAR 0 7
87260: ARRAY
87261: PPUSH
87262: LD_INT 12
87264: PPUSH
87265: CALL_OW 240
// if units_path [ i ] then
87269: LD_VAR 0 16
87273: PUSH
87274: LD_VAR 0 7
87278: ARRAY
87279: IFFALSE 87464
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
87281: LD_VAR 0 4
87285: PUSH
87286: LD_VAR 0 7
87290: ARRAY
87291: PPUSH
87292: LD_VAR 0 16
87296: PUSH
87297: LD_VAR 0 7
87301: ARRAY
87302: PUSH
87303: LD_INT 1
87305: ARRAY
87306: PUSH
87307: LD_INT 1
87309: ARRAY
87310: PPUSH
87311: LD_VAR 0 16
87315: PUSH
87316: LD_VAR 0 7
87320: ARRAY
87321: PUSH
87322: LD_INT 1
87324: ARRAY
87325: PUSH
87326: LD_INT 2
87328: ARRAY
87329: PPUSH
87330: CALL_OW 297
87334: PUSH
87335: LD_INT 6
87337: GREATER
87338: IFFALSE 87413
// begin if not HasTask ( group [ i ] ) then
87340: LD_VAR 0 4
87344: PUSH
87345: LD_VAR 0 7
87349: ARRAY
87350: PPUSH
87351: CALL_OW 314
87355: NOT
87356: IFFALSE 87411
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
87358: LD_VAR 0 4
87362: PUSH
87363: LD_VAR 0 7
87367: ARRAY
87368: PPUSH
87369: LD_VAR 0 16
87373: PUSH
87374: LD_VAR 0 7
87378: ARRAY
87379: PUSH
87380: LD_INT 1
87382: ARRAY
87383: PUSH
87384: LD_INT 1
87386: ARRAY
87387: PPUSH
87388: LD_VAR 0 16
87392: PUSH
87393: LD_VAR 0 7
87397: ARRAY
87398: PUSH
87399: LD_INT 1
87401: ARRAY
87402: PUSH
87403: LD_INT 2
87405: ARRAY
87406: PPUSH
87407: CALL_OW 114
// end else
87411: GO 87464
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
87413: LD_ADDR_VAR 0 15
87417: PUSH
87418: LD_VAR 0 16
87422: PUSH
87423: LD_VAR 0 7
87427: ARRAY
87428: PPUSH
87429: LD_INT 1
87431: PPUSH
87432: CALL_OW 3
87436: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
87437: LD_ADDR_VAR 0 16
87441: PUSH
87442: LD_VAR 0 16
87446: PPUSH
87447: LD_VAR 0 7
87451: PPUSH
87452: LD_VAR 0 15
87456: PPUSH
87457: CALL_OW 1
87461: ST_TO_ADDR
// continue ;
87462: GO 86007
// end ; end ; end else
87464: GO 90102
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
87466: LD_ADDR_VAR 0 14
87470: PUSH
87471: LD_INT 81
87473: PUSH
87474: LD_VAR 0 4
87478: PUSH
87479: LD_VAR 0 7
87483: ARRAY
87484: PPUSH
87485: CALL_OW 255
87489: PUSH
87490: EMPTY
87491: LIST
87492: LIST
87493: PPUSH
87494: CALL_OW 69
87498: ST_TO_ADDR
// if not tmp then
87499: LD_VAR 0 14
87503: NOT
87504: IFFALSE 87508
// continue ;
87506: GO 86007
// if f_ignore_area then
87508: LD_VAR 0 17
87512: IFFALSE 87600
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
87514: LD_ADDR_VAR 0 15
87518: PUSH
87519: LD_VAR 0 14
87523: PPUSH
87524: LD_INT 3
87526: PUSH
87527: LD_INT 92
87529: PUSH
87530: LD_VAR 0 17
87534: PUSH
87535: LD_INT 1
87537: ARRAY
87538: PUSH
87539: LD_VAR 0 17
87543: PUSH
87544: LD_INT 2
87546: ARRAY
87547: PUSH
87548: LD_VAR 0 17
87552: PUSH
87553: LD_INT 3
87555: ARRAY
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PPUSH
87567: CALL_OW 72
87571: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87572: LD_VAR 0 14
87576: PUSH
87577: LD_VAR 0 15
87581: DIFF
87582: IFFALSE 87600
// tmp := tmp diff tmp2 ;
87584: LD_ADDR_VAR 0 14
87588: PUSH
87589: LD_VAR 0 14
87593: PUSH
87594: LD_VAR 0 15
87598: DIFF
87599: ST_TO_ADDR
// end ; if not f_murder then
87600: LD_VAR 0 20
87604: NOT
87605: IFFALSE 87663
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
87607: LD_ADDR_VAR 0 15
87611: PUSH
87612: LD_VAR 0 14
87616: PPUSH
87617: LD_INT 3
87619: PUSH
87620: LD_INT 50
87622: PUSH
87623: EMPTY
87624: LIST
87625: PUSH
87626: EMPTY
87627: LIST
87628: LIST
87629: PPUSH
87630: CALL_OW 72
87634: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87635: LD_VAR 0 14
87639: PUSH
87640: LD_VAR 0 15
87644: DIFF
87645: IFFALSE 87663
// tmp := tmp diff tmp2 ;
87647: LD_ADDR_VAR 0 14
87651: PUSH
87652: LD_VAR 0 14
87656: PUSH
87657: LD_VAR 0 15
87661: DIFF
87662: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
87663: LD_ADDR_VAR 0 14
87667: PUSH
87668: LD_VAR 0 4
87672: PUSH
87673: LD_VAR 0 7
87677: ARRAY
87678: PPUSH
87679: LD_VAR 0 14
87683: PPUSH
87684: LD_INT 1
87686: PPUSH
87687: LD_INT 1
87689: PPUSH
87690: CALL 57428 0 4
87694: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
87695: LD_VAR 0 4
87699: PUSH
87700: LD_VAR 0 7
87704: ARRAY
87705: PPUSH
87706: CALL_OW 257
87710: PUSH
87711: LD_INT 1
87713: EQUAL
87714: IFFALSE 88162
// begin if WantPlant ( group [ i ] ) then
87716: LD_VAR 0 4
87720: PUSH
87721: LD_VAR 0 7
87725: ARRAY
87726: PPUSH
87727: CALL 56929 0 1
87731: IFFALSE 87735
// continue ;
87733: GO 86007
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
87735: LD_VAR 0 18
87739: PUSH
87740: LD_VAR 0 4
87744: PUSH
87745: LD_VAR 0 7
87749: ARRAY
87750: PPUSH
87751: CALL_OW 310
87755: NOT
87756: AND
87757: PUSH
87758: LD_VAR 0 14
87762: PUSH
87763: LD_INT 1
87765: ARRAY
87766: PUSH
87767: LD_VAR 0 14
87771: PPUSH
87772: LD_INT 21
87774: PUSH
87775: LD_INT 2
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 58
87784: PUSH
87785: EMPTY
87786: LIST
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: PPUSH
87792: CALL_OW 72
87796: IN
87797: AND
87798: IFFALSE 87834
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
87800: LD_VAR 0 4
87804: PUSH
87805: LD_VAR 0 7
87809: ARRAY
87810: PPUSH
87811: LD_VAR 0 14
87815: PUSH
87816: LD_INT 1
87818: ARRAY
87819: PPUSH
87820: CALL_OW 120
// attacking := true ;
87824: LD_ADDR_VAR 0 29
87828: PUSH
87829: LD_INT 1
87831: ST_TO_ADDR
// continue ;
87832: GO 86007
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
87834: LD_VAR 0 26
87838: PUSH
87839: LD_VAR 0 4
87843: PUSH
87844: LD_VAR 0 7
87848: ARRAY
87849: PPUSH
87850: CALL_OW 257
87854: PUSH
87855: LD_INT 1
87857: EQUAL
87858: AND
87859: PUSH
87860: LD_VAR 0 4
87864: PUSH
87865: LD_VAR 0 7
87869: ARRAY
87870: PPUSH
87871: CALL_OW 256
87875: PUSH
87876: LD_INT 800
87878: LESS
87879: AND
87880: PUSH
87881: LD_VAR 0 4
87885: PUSH
87886: LD_VAR 0 7
87890: ARRAY
87891: PPUSH
87892: CALL_OW 318
87896: NOT
87897: AND
87898: IFFALSE 87915
// ComCrawl ( group [ i ] ) ;
87900: LD_VAR 0 4
87904: PUSH
87905: LD_VAR 0 7
87909: ARRAY
87910: PPUSH
87911: CALL_OW 137
// if f_mines then
87915: LD_VAR 0 21
87919: IFFALSE 88162
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
87921: LD_VAR 0 14
87925: PUSH
87926: LD_INT 1
87928: ARRAY
87929: PPUSH
87930: CALL_OW 247
87934: PUSH
87935: LD_INT 3
87937: EQUAL
87938: PUSH
87939: LD_VAR 0 14
87943: PUSH
87944: LD_INT 1
87946: ARRAY
87947: PUSH
87948: LD_VAR 0 27
87952: IN
87953: NOT
87954: AND
87955: IFFALSE 88162
// begin x := GetX ( tmp [ 1 ] ) ;
87957: LD_ADDR_VAR 0 10
87961: PUSH
87962: LD_VAR 0 14
87966: PUSH
87967: LD_INT 1
87969: ARRAY
87970: PPUSH
87971: CALL_OW 250
87975: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
87976: LD_ADDR_VAR 0 11
87980: PUSH
87981: LD_VAR 0 14
87985: PUSH
87986: LD_INT 1
87988: ARRAY
87989: PPUSH
87990: CALL_OW 251
87994: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
87995: LD_ADDR_VAR 0 12
87999: PUSH
88000: LD_VAR 0 4
88004: PUSH
88005: LD_VAR 0 7
88009: ARRAY
88010: PPUSH
88011: CALL 83870 0 1
88015: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88016: LD_VAR 0 4
88020: PUSH
88021: LD_VAR 0 7
88025: ARRAY
88026: PPUSH
88027: LD_VAR 0 10
88031: PPUSH
88032: LD_VAR 0 11
88036: PPUSH
88037: LD_VAR 0 14
88041: PUSH
88042: LD_INT 1
88044: ARRAY
88045: PPUSH
88046: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88050: LD_VAR 0 4
88054: PUSH
88055: LD_VAR 0 7
88059: ARRAY
88060: PPUSH
88061: LD_VAR 0 10
88065: PPUSH
88066: LD_VAR 0 12
88070: PPUSH
88071: LD_INT 7
88073: PPUSH
88074: CALL_OW 272
88078: PPUSH
88079: LD_VAR 0 11
88083: PPUSH
88084: LD_VAR 0 12
88088: PPUSH
88089: LD_INT 7
88091: PPUSH
88092: CALL_OW 273
88096: PPUSH
88097: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88101: LD_VAR 0 4
88105: PUSH
88106: LD_VAR 0 7
88110: ARRAY
88111: PPUSH
88112: LD_INT 71
88114: PPUSH
88115: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88119: LD_ADDR_VAR 0 27
88123: PUSH
88124: LD_VAR 0 27
88128: PPUSH
88129: LD_VAR 0 27
88133: PUSH
88134: LD_INT 1
88136: PLUS
88137: PPUSH
88138: LD_VAR 0 14
88142: PUSH
88143: LD_INT 1
88145: ARRAY
88146: PPUSH
88147: CALL_OW 1
88151: ST_TO_ADDR
// attacking := true ;
88152: LD_ADDR_VAR 0 29
88156: PUSH
88157: LD_INT 1
88159: ST_TO_ADDR
// continue ;
88160: GO 86007
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88162: LD_VAR 0 4
88166: PUSH
88167: LD_VAR 0 7
88171: ARRAY
88172: PPUSH
88173: CALL_OW 257
88177: PUSH
88178: LD_INT 17
88180: EQUAL
88181: PUSH
88182: LD_VAR 0 4
88186: PUSH
88187: LD_VAR 0 7
88191: ARRAY
88192: PPUSH
88193: CALL_OW 110
88197: PUSH
88198: LD_INT 71
88200: EQUAL
88201: NOT
88202: AND
88203: IFFALSE 88349
// begin attacking := false ;
88205: LD_ADDR_VAR 0 29
88209: PUSH
88210: LD_INT 0
88212: ST_TO_ADDR
// k := 5 ;
88213: LD_ADDR_VAR 0 9
88217: PUSH
88218: LD_INT 5
88220: ST_TO_ADDR
// if tmp < k then
88221: LD_VAR 0 14
88225: PUSH
88226: LD_VAR 0 9
88230: LESS
88231: IFFALSE 88243
// k := tmp ;
88233: LD_ADDR_VAR 0 9
88237: PUSH
88238: LD_VAR 0 14
88242: ST_TO_ADDR
// for j = 1 to k do
88243: LD_ADDR_VAR 0 8
88247: PUSH
88248: DOUBLE
88249: LD_INT 1
88251: DEC
88252: ST_TO_ADDR
88253: LD_VAR 0 9
88257: PUSH
88258: FOR_TO
88259: IFFALSE 88347
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88261: LD_VAR 0 14
88265: PUSH
88266: LD_VAR 0 8
88270: ARRAY
88271: PUSH
88272: LD_VAR 0 14
88276: PPUSH
88277: LD_INT 58
88279: PUSH
88280: EMPTY
88281: LIST
88282: PPUSH
88283: CALL_OW 72
88287: IN
88288: NOT
88289: IFFALSE 88345
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88291: LD_VAR 0 4
88295: PUSH
88296: LD_VAR 0 7
88300: ARRAY
88301: PPUSH
88302: LD_VAR 0 14
88306: PUSH
88307: LD_VAR 0 8
88311: ARRAY
88312: PPUSH
88313: CALL_OW 115
// attacking := true ;
88317: LD_ADDR_VAR 0 29
88321: PUSH
88322: LD_INT 1
88324: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
88325: LD_VAR 0 4
88329: PUSH
88330: LD_VAR 0 7
88334: ARRAY
88335: PPUSH
88336: LD_INT 71
88338: PPUSH
88339: CALL_OW 109
// continue ;
88343: GO 88258
// end ; end ;
88345: GO 88258
88347: POP
88348: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
88349: LD_VAR 0 4
88353: PUSH
88354: LD_VAR 0 7
88358: ARRAY
88359: PPUSH
88360: CALL_OW 257
88364: PUSH
88365: LD_INT 8
88367: EQUAL
88368: PUSH
88369: LD_VAR 0 4
88373: PUSH
88374: LD_VAR 0 7
88378: ARRAY
88379: PPUSH
88380: CALL_OW 264
88384: PUSH
88385: LD_INT 28
88387: PUSH
88388: LD_INT 45
88390: PUSH
88391: LD_INT 7
88393: PUSH
88394: LD_INT 47
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: IN
88403: OR
88404: IFFALSE 88634
// begin attacking := false ;
88406: LD_ADDR_VAR 0 29
88410: PUSH
88411: LD_INT 0
88413: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
88414: LD_VAR 0 14
88418: PUSH
88419: LD_INT 1
88421: ARRAY
88422: PPUSH
88423: CALL_OW 266
88427: PUSH
88428: LD_INT 32
88430: PUSH
88431: LD_INT 31
88433: PUSH
88434: LD_INT 33
88436: PUSH
88437: LD_INT 4
88439: PUSH
88440: LD_INT 5
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: IN
88450: IFFALSE 88634
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
88452: LD_ADDR_VAR 0 9
88456: PUSH
88457: LD_VAR 0 14
88461: PUSH
88462: LD_INT 1
88464: ARRAY
88465: PPUSH
88466: CALL_OW 266
88470: PPUSH
88471: LD_VAR 0 14
88475: PUSH
88476: LD_INT 1
88478: ARRAY
88479: PPUSH
88480: CALL_OW 250
88484: PPUSH
88485: LD_VAR 0 14
88489: PUSH
88490: LD_INT 1
88492: ARRAY
88493: PPUSH
88494: CALL_OW 251
88498: PPUSH
88499: LD_VAR 0 14
88503: PUSH
88504: LD_INT 1
88506: ARRAY
88507: PPUSH
88508: CALL_OW 254
88512: PPUSH
88513: LD_VAR 0 14
88517: PUSH
88518: LD_INT 1
88520: ARRAY
88521: PPUSH
88522: CALL_OW 248
88526: PPUSH
88527: LD_INT 0
88529: PPUSH
88530: CALL 65240 0 6
88534: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
88535: LD_ADDR_VAR 0 8
88539: PUSH
88540: LD_VAR 0 4
88544: PUSH
88545: LD_VAR 0 7
88549: ARRAY
88550: PPUSH
88551: LD_VAR 0 9
88555: PPUSH
88556: CALL 83933 0 2
88560: ST_TO_ADDR
// if j then
88561: LD_VAR 0 8
88565: IFFALSE 88634
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
88567: LD_VAR 0 8
88571: PUSH
88572: LD_INT 1
88574: ARRAY
88575: PPUSH
88576: LD_VAR 0 8
88580: PUSH
88581: LD_INT 2
88583: ARRAY
88584: PPUSH
88585: CALL_OW 488
88589: IFFALSE 88634
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
88591: LD_VAR 0 4
88595: PUSH
88596: LD_VAR 0 7
88600: ARRAY
88601: PPUSH
88602: LD_VAR 0 8
88606: PUSH
88607: LD_INT 1
88609: ARRAY
88610: PPUSH
88611: LD_VAR 0 8
88615: PUSH
88616: LD_INT 2
88618: ARRAY
88619: PPUSH
88620: CALL_OW 116
// attacking := true ;
88624: LD_ADDR_VAR 0 29
88628: PUSH
88629: LD_INT 1
88631: ST_TO_ADDR
// continue ;
88632: GO 86007
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
88634: LD_VAR 0 4
88638: PUSH
88639: LD_VAR 0 7
88643: ARRAY
88644: PPUSH
88645: CALL_OW 265
88649: PUSH
88650: LD_INT 11
88652: EQUAL
88653: IFFALSE 88931
// begin k := 10 ;
88655: LD_ADDR_VAR 0 9
88659: PUSH
88660: LD_INT 10
88662: ST_TO_ADDR
// x := 0 ;
88663: LD_ADDR_VAR 0 10
88667: PUSH
88668: LD_INT 0
88670: ST_TO_ADDR
// if tmp < k then
88671: LD_VAR 0 14
88675: PUSH
88676: LD_VAR 0 9
88680: LESS
88681: IFFALSE 88693
// k := tmp ;
88683: LD_ADDR_VAR 0 9
88687: PUSH
88688: LD_VAR 0 14
88692: ST_TO_ADDR
// for j = k downto 1 do
88693: LD_ADDR_VAR 0 8
88697: PUSH
88698: DOUBLE
88699: LD_VAR 0 9
88703: INC
88704: ST_TO_ADDR
88705: LD_INT 1
88707: PUSH
88708: FOR_DOWNTO
88709: IFFALSE 88784
// begin if GetType ( tmp [ j ] ) = unit_human then
88711: LD_VAR 0 14
88715: PUSH
88716: LD_VAR 0 8
88720: ARRAY
88721: PPUSH
88722: CALL_OW 247
88726: PUSH
88727: LD_INT 1
88729: EQUAL
88730: IFFALSE 88782
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
88732: LD_VAR 0 4
88736: PUSH
88737: LD_VAR 0 7
88741: ARRAY
88742: PPUSH
88743: LD_VAR 0 14
88747: PUSH
88748: LD_VAR 0 8
88752: ARRAY
88753: PPUSH
88754: CALL 84204 0 2
// x := tmp [ j ] ;
88758: LD_ADDR_VAR 0 10
88762: PUSH
88763: LD_VAR 0 14
88767: PUSH
88768: LD_VAR 0 8
88772: ARRAY
88773: ST_TO_ADDR
// attacking := true ;
88774: LD_ADDR_VAR 0 29
88778: PUSH
88779: LD_INT 1
88781: ST_TO_ADDR
// end ; end ;
88782: GO 88708
88784: POP
88785: POP
// if not x then
88786: LD_VAR 0 10
88790: NOT
88791: IFFALSE 88931
// begin attacking := true ;
88793: LD_ADDR_VAR 0 29
88797: PUSH
88798: LD_INT 1
88800: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
88801: LD_VAR 0 4
88805: PUSH
88806: LD_VAR 0 7
88810: ARRAY
88811: PPUSH
88812: CALL_OW 250
88816: PPUSH
88817: LD_VAR 0 4
88821: PUSH
88822: LD_VAR 0 7
88826: ARRAY
88827: PPUSH
88828: CALL_OW 251
88832: PPUSH
88833: CALL_OW 546
88837: PUSH
88838: LD_INT 2
88840: ARRAY
88841: PUSH
88842: LD_VAR 0 14
88846: PUSH
88847: LD_INT 1
88849: ARRAY
88850: PPUSH
88851: CALL_OW 250
88855: PPUSH
88856: LD_VAR 0 14
88860: PUSH
88861: LD_INT 1
88863: ARRAY
88864: PPUSH
88865: CALL_OW 251
88869: PPUSH
88870: CALL_OW 546
88874: PUSH
88875: LD_INT 2
88877: ARRAY
88878: EQUAL
88879: IFFALSE 88907
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
88881: LD_VAR 0 4
88885: PUSH
88886: LD_VAR 0 7
88890: ARRAY
88891: PPUSH
88892: LD_VAR 0 14
88896: PUSH
88897: LD_INT 1
88899: ARRAY
88900: PPUSH
88901: CALL 84204 0 2
88905: GO 88931
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88907: LD_VAR 0 4
88911: PUSH
88912: LD_VAR 0 7
88916: ARRAY
88917: PPUSH
88918: LD_VAR 0 14
88922: PUSH
88923: LD_INT 1
88925: ARRAY
88926: PPUSH
88927: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
88931: LD_VAR 0 4
88935: PUSH
88936: LD_VAR 0 7
88940: ARRAY
88941: PPUSH
88942: CALL_OW 264
88946: PUSH
88947: LD_INT 29
88949: EQUAL
88950: IFFALSE 89316
// begin if WantsToAttack ( group [ i ] ) in bombed then
88952: LD_VAR 0 4
88956: PUSH
88957: LD_VAR 0 7
88961: ARRAY
88962: PPUSH
88963: CALL_OW 319
88967: PUSH
88968: LD_VAR 0 28
88972: IN
88973: IFFALSE 88977
// continue ;
88975: GO 86007
// k := 8 ;
88977: LD_ADDR_VAR 0 9
88981: PUSH
88982: LD_INT 8
88984: ST_TO_ADDR
// x := 0 ;
88985: LD_ADDR_VAR 0 10
88989: PUSH
88990: LD_INT 0
88992: ST_TO_ADDR
// if tmp < k then
88993: LD_VAR 0 14
88997: PUSH
88998: LD_VAR 0 9
89002: LESS
89003: IFFALSE 89015
// k := tmp ;
89005: LD_ADDR_VAR 0 9
89009: PUSH
89010: LD_VAR 0 14
89014: ST_TO_ADDR
// for j = 1 to k do
89015: LD_ADDR_VAR 0 8
89019: PUSH
89020: DOUBLE
89021: LD_INT 1
89023: DEC
89024: ST_TO_ADDR
89025: LD_VAR 0 9
89029: PUSH
89030: FOR_TO
89031: IFFALSE 89163
// begin if GetType ( tmp [ j ] ) = unit_building then
89033: LD_VAR 0 14
89037: PUSH
89038: LD_VAR 0 8
89042: ARRAY
89043: PPUSH
89044: CALL_OW 247
89048: PUSH
89049: LD_INT 3
89051: EQUAL
89052: IFFALSE 89161
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89054: LD_VAR 0 14
89058: PUSH
89059: LD_VAR 0 8
89063: ARRAY
89064: PUSH
89065: LD_VAR 0 28
89069: IN
89070: NOT
89071: PUSH
89072: LD_VAR 0 14
89076: PUSH
89077: LD_VAR 0 8
89081: ARRAY
89082: PPUSH
89083: CALL_OW 313
89087: AND
89088: IFFALSE 89161
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89090: LD_VAR 0 4
89094: PUSH
89095: LD_VAR 0 7
89099: ARRAY
89100: PPUSH
89101: LD_VAR 0 14
89105: PUSH
89106: LD_VAR 0 8
89110: ARRAY
89111: PPUSH
89112: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89116: LD_ADDR_VAR 0 28
89120: PUSH
89121: LD_VAR 0 28
89125: PPUSH
89126: LD_VAR 0 28
89130: PUSH
89131: LD_INT 1
89133: PLUS
89134: PPUSH
89135: LD_VAR 0 14
89139: PUSH
89140: LD_VAR 0 8
89144: ARRAY
89145: PPUSH
89146: CALL_OW 1
89150: ST_TO_ADDR
// attacking := true ;
89151: LD_ADDR_VAR 0 29
89155: PUSH
89156: LD_INT 1
89158: ST_TO_ADDR
// break ;
89159: GO 89163
// end ; end ;
89161: GO 89030
89163: POP
89164: POP
// if not attacking and f_attack_depot then
89165: LD_VAR 0 29
89169: NOT
89170: PUSH
89171: LD_VAR 0 25
89175: AND
89176: IFFALSE 89271
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89178: LD_ADDR_VAR 0 13
89182: PUSH
89183: LD_VAR 0 14
89187: PPUSH
89188: LD_INT 2
89190: PUSH
89191: LD_INT 30
89193: PUSH
89194: LD_INT 0
89196: PUSH
89197: EMPTY
89198: LIST
89199: LIST
89200: PUSH
89201: LD_INT 30
89203: PUSH
89204: LD_INT 1
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: EMPTY
89212: LIST
89213: LIST
89214: LIST
89215: PPUSH
89216: CALL_OW 72
89220: ST_TO_ADDR
// if z then
89221: LD_VAR 0 13
89225: IFFALSE 89271
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89227: LD_VAR 0 4
89231: PUSH
89232: LD_VAR 0 7
89236: ARRAY
89237: PPUSH
89238: LD_VAR 0 13
89242: PPUSH
89243: LD_VAR 0 4
89247: PUSH
89248: LD_VAR 0 7
89252: ARRAY
89253: PPUSH
89254: CALL_OW 74
89258: PPUSH
89259: CALL_OW 115
// attacking := true ;
89263: LD_ADDR_VAR 0 29
89267: PUSH
89268: LD_INT 1
89270: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
89271: LD_VAR 0 4
89275: PUSH
89276: LD_VAR 0 7
89280: ARRAY
89281: PPUSH
89282: CALL_OW 256
89286: PUSH
89287: LD_INT 500
89289: LESS
89290: IFFALSE 89316
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89292: LD_VAR 0 4
89296: PUSH
89297: LD_VAR 0 7
89301: ARRAY
89302: PPUSH
89303: LD_VAR 0 14
89307: PUSH
89308: LD_INT 1
89310: ARRAY
89311: PPUSH
89312: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
89316: LD_VAR 0 4
89320: PUSH
89321: LD_VAR 0 7
89325: ARRAY
89326: PPUSH
89327: CALL_OW 264
89331: PUSH
89332: LD_INT 49
89334: EQUAL
89335: IFFALSE 89456
// begin if not HasTask ( group [ i ] ) then
89337: LD_VAR 0 4
89341: PUSH
89342: LD_VAR 0 7
89346: ARRAY
89347: PPUSH
89348: CALL_OW 314
89352: NOT
89353: IFFALSE 89456
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
89355: LD_ADDR_VAR 0 9
89359: PUSH
89360: LD_INT 81
89362: PUSH
89363: LD_VAR 0 4
89367: PUSH
89368: LD_VAR 0 7
89372: ARRAY
89373: PPUSH
89374: CALL_OW 255
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PPUSH
89383: CALL_OW 69
89387: PPUSH
89388: LD_VAR 0 4
89392: PUSH
89393: LD_VAR 0 7
89397: ARRAY
89398: PPUSH
89399: CALL_OW 74
89403: ST_TO_ADDR
// if k then
89404: LD_VAR 0 9
89408: IFFALSE 89456
// if GetDistUnits ( group [ i ] , k ) > 10 then
89410: LD_VAR 0 4
89414: PUSH
89415: LD_VAR 0 7
89419: ARRAY
89420: PPUSH
89421: LD_VAR 0 9
89425: PPUSH
89426: CALL_OW 296
89430: PUSH
89431: LD_INT 10
89433: GREATER
89434: IFFALSE 89456
// ComMoveUnit ( group [ i ] , k ) ;
89436: LD_VAR 0 4
89440: PUSH
89441: LD_VAR 0 7
89445: ARRAY
89446: PPUSH
89447: LD_VAR 0 9
89451: PPUSH
89452: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
89456: LD_VAR 0 4
89460: PUSH
89461: LD_VAR 0 7
89465: ARRAY
89466: PPUSH
89467: CALL_OW 256
89471: PUSH
89472: LD_INT 250
89474: LESS
89475: PUSH
89476: LD_VAR 0 4
89480: PUSH
89481: LD_VAR 0 7
89485: ARRAY
89486: PUSH
89487: LD_INT 21
89489: PUSH
89490: LD_INT 2
89492: PUSH
89493: EMPTY
89494: LIST
89495: LIST
89496: PUSH
89497: LD_INT 23
89499: PUSH
89500: LD_INT 2
89502: PUSH
89503: EMPTY
89504: LIST
89505: LIST
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PPUSH
89511: CALL_OW 69
89515: IN
89516: AND
89517: IFFALSE 89642
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
89519: LD_ADDR_VAR 0 9
89523: PUSH
89524: LD_OWVAR 3
89528: PUSH
89529: LD_VAR 0 4
89533: PUSH
89534: LD_VAR 0 7
89538: ARRAY
89539: DIFF
89540: PPUSH
89541: LD_VAR 0 4
89545: PUSH
89546: LD_VAR 0 7
89550: ARRAY
89551: PPUSH
89552: CALL_OW 74
89556: ST_TO_ADDR
// if not k then
89557: LD_VAR 0 9
89561: NOT
89562: IFFALSE 89566
// continue ;
89564: GO 86007
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
89566: LD_VAR 0 9
89570: PUSH
89571: LD_INT 81
89573: PUSH
89574: LD_VAR 0 4
89578: PUSH
89579: LD_VAR 0 7
89583: ARRAY
89584: PPUSH
89585: CALL_OW 255
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PPUSH
89594: CALL_OW 69
89598: IN
89599: PUSH
89600: LD_VAR 0 9
89604: PPUSH
89605: LD_VAR 0 4
89609: PUSH
89610: LD_VAR 0 7
89614: ARRAY
89615: PPUSH
89616: CALL_OW 296
89620: PUSH
89621: LD_INT 5
89623: LESS
89624: AND
89625: IFFALSE 89642
// ComAutodestruct ( group [ i ] ) ;
89627: LD_VAR 0 4
89631: PUSH
89632: LD_VAR 0 7
89636: ARRAY
89637: PPUSH
89638: CALL 84102 0 1
// end ; if f_attack_depot then
89642: LD_VAR 0 25
89646: IFFALSE 89758
// begin k := 6 ;
89648: LD_ADDR_VAR 0 9
89652: PUSH
89653: LD_INT 6
89655: ST_TO_ADDR
// if tmp < k then
89656: LD_VAR 0 14
89660: PUSH
89661: LD_VAR 0 9
89665: LESS
89666: IFFALSE 89678
// k := tmp ;
89668: LD_ADDR_VAR 0 9
89672: PUSH
89673: LD_VAR 0 14
89677: ST_TO_ADDR
// for j = 1 to k do
89678: LD_ADDR_VAR 0 8
89682: PUSH
89683: DOUBLE
89684: LD_INT 1
89686: DEC
89687: ST_TO_ADDR
89688: LD_VAR 0 9
89692: PUSH
89693: FOR_TO
89694: IFFALSE 89756
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
89696: LD_VAR 0 8
89700: PPUSH
89701: CALL_OW 266
89705: PUSH
89706: LD_INT 0
89708: PUSH
89709: LD_INT 1
89711: PUSH
89712: EMPTY
89713: LIST
89714: LIST
89715: IN
89716: IFFALSE 89754
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89718: LD_VAR 0 4
89722: PUSH
89723: LD_VAR 0 7
89727: ARRAY
89728: PPUSH
89729: LD_VAR 0 14
89733: PUSH
89734: LD_VAR 0 8
89738: ARRAY
89739: PPUSH
89740: CALL_OW 115
// attacking := true ;
89744: LD_ADDR_VAR 0 29
89748: PUSH
89749: LD_INT 1
89751: ST_TO_ADDR
// break ;
89752: GO 89756
// end ;
89754: GO 89693
89756: POP
89757: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
89758: LD_VAR 0 4
89762: PUSH
89763: LD_VAR 0 7
89767: ARRAY
89768: PPUSH
89769: CALL_OW 302
89773: PUSH
89774: LD_VAR 0 29
89778: NOT
89779: AND
89780: IFFALSE 90102
// begin if GetTag ( group [ i ] ) = 71 then
89782: LD_VAR 0 4
89786: PUSH
89787: LD_VAR 0 7
89791: ARRAY
89792: PPUSH
89793: CALL_OW 110
89797: PUSH
89798: LD_INT 71
89800: EQUAL
89801: IFFALSE 89842
// begin if HasTask ( group [ i ] ) then
89803: LD_VAR 0 4
89807: PUSH
89808: LD_VAR 0 7
89812: ARRAY
89813: PPUSH
89814: CALL_OW 314
89818: IFFALSE 89824
// continue else
89820: GO 86007
89822: GO 89842
// SetTag ( group [ i ] , 0 ) ;
89824: LD_VAR 0 4
89828: PUSH
89829: LD_VAR 0 7
89833: ARRAY
89834: PPUSH
89835: LD_INT 0
89837: PPUSH
89838: CALL_OW 109
// end ; k := 8 ;
89842: LD_ADDR_VAR 0 9
89846: PUSH
89847: LD_INT 8
89849: ST_TO_ADDR
// x := 0 ;
89850: LD_ADDR_VAR 0 10
89854: PUSH
89855: LD_INT 0
89857: ST_TO_ADDR
// if tmp < k then
89858: LD_VAR 0 14
89862: PUSH
89863: LD_VAR 0 9
89867: LESS
89868: IFFALSE 89880
// k := tmp ;
89870: LD_ADDR_VAR 0 9
89874: PUSH
89875: LD_VAR 0 14
89879: ST_TO_ADDR
// for j = 1 to k do
89880: LD_ADDR_VAR 0 8
89884: PUSH
89885: DOUBLE
89886: LD_INT 1
89888: DEC
89889: ST_TO_ADDR
89890: LD_VAR 0 9
89894: PUSH
89895: FOR_TO
89896: IFFALSE 89994
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
89898: LD_VAR 0 14
89902: PUSH
89903: LD_VAR 0 8
89907: ARRAY
89908: PPUSH
89909: CALL_OW 247
89913: PUSH
89914: LD_INT 1
89916: EQUAL
89917: PUSH
89918: LD_VAR 0 14
89922: PUSH
89923: LD_VAR 0 8
89927: ARRAY
89928: PPUSH
89929: CALL_OW 256
89933: PUSH
89934: LD_INT 250
89936: LESS
89937: PUSH
89938: LD_VAR 0 20
89942: AND
89943: PUSH
89944: LD_VAR 0 20
89948: NOT
89949: PUSH
89950: LD_VAR 0 14
89954: PUSH
89955: LD_VAR 0 8
89959: ARRAY
89960: PPUSH
89961: CALL_OW 256
89965: PUSH
89966: LD_INT 250
89968: GREATEREQUAL
89969: AND
89970: OR
89971: AND
89972: IFFALSE 89992
// begin x := tmp [ j ] ;
89974: LD_ADDR_VAR 0 10
89978: PUSH
89979: LD_VAR 0 14
89983: PUSH
89984: LD_VAR 0 8
89988: ARRAY
89989: ST_TO_ADDR
// break ;
89990: GO 89994
// end ;
89992: GO 89895
89994: POP
89995: POP
// if x then
89996: LD_VAR 0 10
90000: IFFALSE 90024
// ComAttackUnit ( group [ i ] , x ) else
90002: LD_VAR 0 4
90006: PUSH
90007: LD_VAR 0 7
90011: ARRAY
90012: PPUSH
90013: LD_VAR 0 10
90017: PPUSH
90018: CALL_OW 115
90022: GO 90048
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90024: LD_VAR 0 4
90028: PUSH
90029: LD_VAR 0 7
90033: ARRAY
90034: PPUSH
90035: LD_VAR 0 14
90039: PUSH
90040: LD_INT 1
90042: ARRAY
90043: PPUSH
90044: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90048: LD_VAR 0 4
90052: PUSH
90053: LD_VAR 0 7
90057: ARRAY
90058: PPUSH
90059: CALL_OW 314
90063: NOT
90064: IFFALSE 90102
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90066: LD_VAR 0 4
90070: PUSH
90071: LD_VAR 0 7
90075: ARRAY
90076: PPUSH
90077: LD_VAR 0 14
90081: PPUSH
90082: LD_VAR 0 4
90086: PUSH
90087: LD_VAR 0 7
90091: ARRAY
90092: PPUSH
90093: CALL_OW 74
90097: PPUSH
90098: CALL_OW 115
// end ; end ; end ;
90102: GO 86007
90104: POP
90105: POP
// wait ( 0 0$1 ) ;
90106: LD_INT 35
90108: PPUSH
90109: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90113: LD_VAR 0 4
90117: PUSH
90118: EMPTY
90119: EQUAL
90120: PUSH
90121: LD_INT 81
90123: PUSH
90124: LD_VAR 0 35
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PPUSH
90133: CALL_OW 69
90137: NOT
90138: OR
90139: IFFALSE 85992
// end ;
90141: LD_VAR 0 2
90145: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90146: LD_INT 0
90148: PPUSH
90149: PPUSH
90150: PPUSH
90151: PPUSH
// if not base_units then
90152: LD_VAR 0 1
90156: NOT
90157: IFFALSE 90161
// exit ;
90159: GO 90248
// result := false ;
90161: LD_ADDR_VAR 0 2
90165: PUSH
90166: LD_INT 0
90168: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90169: LD_ADDR_VAR 0 5
90173: PUSH
90174: LD_VAR 0 1
90178: PPUSH
90179: LD_INT 21
90181: PUSH
90182: LD_INT 3
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: PPUSH
90189: CALL_OW 72
90193: ST_TO_ADDR
// if not tmp then
90194: LD_VAR 0 5
90198: NOT
90199: IFFALSE 90203
// exit ;
90201: GO 90248
// for i in tmp do
90203: LD_ADDR_VAR 0 3
90207: PUSH
90208: LD_VAR 0 5
90212: PUSH
90213: FOR_IN
90214: IFFALSE 90246
// begin result := EnemyInRange ( i , 22 ) ;
90216: LD_ADDR_VAR 0 2
90220: PUSH
90221: LD_VAR 0 3
90225: PPUSH
90226: LD_INT 22
90228: PPUSH
90229: CALL 83785 0 2
90233: ST_TO_ADDR
// if result then
90234: LD_VAR 0 2
90238: IFFALSE 90244
// exit ;
90240: POP
90241: POP
90242: GO 90248
// end ;
90244: GO 90213
90246: POP
90247: POP
// end ;
90248: LD_VAR 0 2
90252: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
90253: LD_INT 0
90255: PPUSH
90256: PPUSH
// if not units then
90257: LD_VAR 0 1
90261: NOT
90262: IFFALSE 90266
// exit ;
90264: GO 90336
// result := [ ] ;
90266: LD_ADDR_VAR 0 3
90270: PUSH
90271: EMPTY
90272: ST_TO_ADDR
// for i in units do
90273: LD_ADDR_VAR 0 4
90277: PUSH
90278: LD_VAR 0 1
90282: PUSH
90283: FOR_IN
90284: IFFALSE 90334
// if GetTag ( i ) = tag then
90286: LD_VAR 0 4
90290: PPUSH
90291: CALL_OW 110
90295: PUSH
90296: LD_VAR 0 2
90300: EQUAL
90301: IFFALSE 90332
// result := Insert ( result , result + 1 , i ) ;
90303: LD_ADDR_VAR 0 3
90307: PUSH
90308: LD_VAR 0 3
90312: PPUSH
90313: LD_VAR 0 3
90317: PUSH
90318: LD_INT 1
90320: PLUS
90321: PPUSH
90322: LD_VAR 0 4
90326: PPUSH
90327: CALL_OW 2
90331: ST_TO_ADDR
90332: GO 90283
90334: POP
90335: POP
// end ;
90336: LD_VAR 0 3
90340: RET
// export function IsDriver ( un ) ; begin
90341: LD_INT 0
90343: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
90344: LD_ADDR_VAR 0 2
90348: PUSH
90349: LD_VAR 0 1
90353: PUSH
90354: LD_INT 55
90356: PUSH
90357: EMPTY
90358: LIST
90359: PPUSH
90360: CALL_OW 69
90364: IN
90365: ST_TO_ADDR
// end ;
90366: LD_VAR 0 2
90370: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
90371: LD_INT 0
90373: PPUSH
90374: PPUSH
// list := [ ] ;
90375: LD_ADDR_VAR 0 5
90379: PUSH
90380: EMPTY
90381: ST_TO_ADDR
// case d of 0 :
90382: LD_VAR 0 3
90386: PUSH
90387: LD_INT 0
90389: DOUBLE
90390: EQUAL
90391: IFTRUE 90395
90393: GO 90528
90395: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
90396: LD_ADDR_VAR 0 5
90400: PUSH
90401: LD_VAR 0 1
90405: PUSH
90406: LD_INT 4
90408: MINUS
90409: PUSH
90410: LD_VAR 0 2
90414: PUSH
90415: LD_INT 4
90417: MINUS
90418: PUSH
90419: LD_INT 2
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: LIST
90426: PUSH
90427: LD_VAR 0 1
90431: PUSH
90432: LD_INT 3
90434: MINUS
90435: PUSH
90436: LD_VAR 0 2
90440: PUSH
90441: LD_INT 1
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: LIST
90448: PUSH
90449: LD_VAR 0 1
90453: PUSH
90454: LD_INT 4
90456: PLUS
90457: PUSH
90458: LD_VAR 0 2
90462: PUSH
90463: LD_INT 4
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: LIST
90470: PUSH
90471: LD_VAR 0 1
90475: PUSH
90476: LD_INT 3
90478: PLUS
90479: PUSH
90480: LD_VAR 0 2
90484: PUSH
90485: LD_INT 3
90487: PLUS
90488: PUSH
90489: LD_INT 5
90491: PUSH
90492: EMPTY
90493: LIST
90494: LIST
90495: LIST
90496: PUSH
90497: LD_VAR 0 1
90501: PUSH
90502: LD_VAR 0 2
90506: PUSH
90507: LD_INT 4
90509: PLUS
90510: PUSH
90511: LD_INT 0
90513: PUSH
90514: EMPTY
90515: LIST
90516: LIST
90517: LIST
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: ST_TO_ADDR
// end ; 1 :
90526: GO 91226
90528: LD_INT 1
90530: DOUBLE
90531: EQUAL
90532: IFTRUE 90536
90534: GO 90669
90536: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
90537: LD_ADDR_VAR 0 5
90541: PUSH
90542: LD_VAR 0 1
90546: PUSH
90547: LD_VAR 0 2
90551: PUSH
90552: LD_INT 4
90554: MINUS
90555: PUSH
90556: LD_INT 3
90558: PUSH
90559: EMPTY
90560: LIST
90561: LIST
90562: LIST
90563: PUSH
90564: LD_VAR 0 1
90568: PUSH
90569: LD_INT 3
90571: MINUS
90572: PUSH
90573: LD_VAR 0 2
90577: PUSH
90578: LD_INT 3
90580: MINUS
90581: PUSH
90582: LD_INT 2
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: LIST
90589: PUSH
90590: LD_VAR 0 1
90594: PUSH
90595: LD_INT 4
90597: MINUS
90598: PUSH
90599: LD_VAR 0 2
90603: PUSH
90604: LD_INT 1
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: LIST
90611: PUSH
90612: LD_VAR 0 1
90616: PUSH
90617: LD_VAR 0 2
90621: PUSH
90622: LD_INT 3
90624: PLUS
90625: PUSH
90626: LD_INT 0
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: LIST
90633: PUSH
90634: LD_VAR 0 1
90638: PUSH
90639: LD_INT 4
90641: PLUS
90642: PUSH
90643: LD_VAR 0 2
90647: PUSH
90648: LD_INT 4
90650: PLUS
90651: PUSH
90652: LD_INT 5
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: LIST
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: ST_TO_ADDR
// end ; 2 :
90667: GO 91226
90669: LD_INT 2
90671: DOUBLE
90672: EQUAL
90673: IFTRUE 90677
90675: GO 90806
90677: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
90678: LD_ADDR_VAR 0 5
90682: PUSH
90683: LD_VAR 0 1
90687: PUSH
90688: LD_VAR 0 2
90692: PUSH
90693: LD_INT 3
90695: MINUS
90696: PUSH
90697: LD_INT 3
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: LIST
90704: PUSH
90705: LD_VAR 0 1
90709: PUSH
90710: LD_INT 4
90712: PLUS
90713: PUSH
90714: LD_VAR 0 2
90718: PUSH
90719: LD_INT 4
90721: PUSH
90722: EMPTY
90723: LIST
90724: LIST
90725: LIST
90726: PUSH
90727: LD_VAR 0 1
90731: PUSH
90732: LD_VAR 0 2
90736: PUSH
90737: LD_INT 4
90739: PLUS
90740: PUSH
90741: LD_INT 0
90743: PUSH
90744: EMPTY
90745: LIST
90746: LIST
90747: LIST
90748: PUSH
90749: LD_VAR 0 1
90753: PUSH
90754: LD_INT 3
90756: MINUS
90757: PUSH
90758: LD_VAR 0 2
90762: PUSH
90763: LD_INT 1
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: LIST
90770: PUSH
90771: LD_VAR 0 1
90775: PUSH
90776: LD_INT 4
90778: MINUS
90779: PUSH
90780: LD_VAR 0 2
90784: PUSH
90785: LD_INT 4
90787: MINUS
90788: PUSH
90789: LD_INT 2
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: LIST
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: ST_TO_ADDR
// end ; 3 :
90804: GO 91226
90806: LD_INT 3
90808: DOUBLE
90809: EQUAL
90810: IFTRUE 90814
90812: GO 90947
90814: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
90815: LD_ADDR_VAR 0 5
90819: PUSH
90820: LD_VAR 0 1
90824: PUSH
90825: LD_INT 3
90827: PLUS
90828: PUSH
90829: LD_VAR 0 2
90833: PUSH
90834: LD_INT 4
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: LIST
90841: PUSH
90842: LD_VAR 0 1
90846: PUSH
90847: LD_INT 4
90849: PLUS
90850: PUSH
90851: LD_VAR 0 2
90855: PUSH
90856: LD_INT 4
90858: PLUS
90859: PUSH
90860: LD_INT 5
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: LIST
90867: PUSH
90868: LD_VAR 0 1
90872: PUSH
90873: LD_INT 4
90875: MINUS
90876: PUSH
90877: LD_VAR 0 2
90881: PUSH
90882: LD_INT 1
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: LIST
90889: PUSH
90890: LD_VAR 0 1
90894: PUSH
90895: LD_VAR 0 2
90899: PUSH
90900: LD_INT 4
90902: MINUS
90903: PUSH
90904: LD_INT 3
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: LIST
90911: PUSH
90912: LD_VAR 0 1
90916: PUSH
90917: LD_INT 3
90919: MINUS
90920: PUSH
90921: LD_VAR 0 2
90925: PUSH
90926: LD_INT 3
90928: MINUS
90929: PUSH
90930: LD_INT 2
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: LIST
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: ST_TO_ADDR
// end ; 4 :
90945: GO 91226
90947: LD_INT 4
90949: DOUBLE
90950: EQUAL
90951: IFTRUE 90955
90953: GO 91088
90955: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
90956: LD_ADDR_VAR 0 5
90960: PUSH
90961: LD_VAR 0 1
90965: PUSH
90966: LD_VAR 0 2
90970: PUSH
90971: LD_INT 4
90973: PLUS
90974: PUSH
90975: LD_INT 0
90977: PUSH
90978: EMPTY
90979: LIST
90980: LIST
90981: LIST
90982: PUSH
90983: LD_VAR 0 1
90987: PUSH
90988: LD_INT 3
90990: PLUS
90991: PUSH
90992: LD_VAR 0 2
90996: PUSH
90997: LD_INT 3
90999: PLUS
91000: PUSH
91001: LD_INT 5
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: LIST
91008: PUSH
91009: LD_VAR 0 1
91013: PUSH
91014: LD_INT 4
91016: PLUS
91017: PUSH
91018: LD_VAR 0 2
91022: PUSH
91023: LD_INT 4
91025: PUSH
91026: EMPTY
91027: LIST
91028: LIST
91029: LIST
91030: PUSH
91031: LD_VAR 0 1
91035: PUSH
91036: LD_VAR 0 2
91040: PUSH
91041: LD_INT 3
91043: MINUS
91044: PUSH
91045: LD_INT 3
91047: PUSH
91048: EMPTY
91049: LIST
91050: LIST
91051: LIST
91052: PUSH
91053: LD_VAR 0 1
91057: PUSH
91058: LD_INT 4
91060: MINUS
91061: PUSH
91062: LD_VAR 0 2
91066: PUSH
91067: LD_INT 4
91069: MINUS
91070: PUSH
91071: LD_INT 2
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: LIST
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: ST_TO_ADDR
// end ; 5 :
91086: GO 91226
91088: LD_INT 5
91090: DOUBLE
91091: EQUAL
91092: IFTRUE 91096
91094: GO 91225
91096: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91097: LD_ADDR_VAR 0 5
91101: PUSH
91102: LD_VAR 0 1
91106: PUSH
91107: LD_INT 4
91109: MINUS
91110: PUSH
91111: LD_VAR 0 2
91115: PUSH
91116: LD_INT 1
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: LIST
91123: PUSH
91124: LD_VAR 0 1
91128: PUSH
91129: LD_VAR 0 2
91133: PUSH
91134: LD_INT 4
91136: MINUS
91137: PUSH
91138: LD_INT 3
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: LIST
91145: PUSH
91146: LD_VAR 0 1
91150: PUSH
91151: LD_INT 4
91153: PLUS
91154: PUSH
91155: LD_VAR 0 2
91159: PUSH
91160: LD_INT 4
91162: PLUS
91163: PUSH
91164: LD_INT 5
91166: PUSH
91167: EMPTY
91168: LIST
91169: LIST
91170: LIST
91171: PUSH
91172: LD_VAR 0 1
91176: PUSH
91177: LD_INT 3
91179: PLUS
91180: PUSH
91181: LD_VAR 0 2
91185: PUSH
91186: LD_INT 4
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: LIST
91193: PUSH
91194: LD_VAR 0 1
91198: PUSH
91199: LD_VAR 0 2
91203: PUSH
91204: LD_INT 3
91206: PLUS
91207: PUSH
91208: LD_INT 0
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: LIST
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: ST_TO_ADDR
// end ; end ;
91223: GO 91226
91225: POP
// result := list ;
91226: LD_ADDR_VAR 0 4
91230: PUSH
91231: LD_VAR 0 5
91235: ST_TO_ADDR
// end ;
91236: LD_VAR 0 4
91240: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91241: LD_INT 0
91243: PPUSH
91244: PPUSH
91245: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91246: LD_VAR 0 1
91250: NOT
91251: PUSH
91252: LD_VAR 0 2
91256: PUSH
91257: LD_INT 1
91259: PUSH
91260: LD_INT 2
91262: PUSH
91263: LD_INT 3
91265: PUSH
91266: LD_INT 4
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: IN
91275: NOT
91276: OR
91277: IFFALSE 91281
// exit ;
91279: GO 91373
// tmp := [ ] ;
91281: LD_ADDR_VAR 0 5
91285: PUSH
91286: EMPTY
91287: ST_TO_ADDR
// for i in units do
91288: LD_ADDR_VAR 0 4
91292: PUSH
91293: LD_VAR 0 1
91297: PUSH
91298: FOR_IN
91299: IFFALSE 91342
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
91301: LD_ADDR_VAR 0 5
91305: PUSH
91306: LD_VAR 0 5
91310: PPUSH
91311: LD_VAR 0 5
91315: PUSH
91316: LD_INT 1
91318: PLUS
91319: PPUSH
91320: LD_VAR 0 4
91324: PPUSH
91325: LD_VAR 0 2
91329: PPUSH
91330: CALL_OW 259
91334: PPUSH
91335: CALL_OW 2
91339: ST_TO_ADDR
91340: GO 91298
91342: POP
91343: POP
// if not tmp then
91344: LD_VAR 0 5
91348: NOT
91349: IFFALSE 91353
// exit ;
91351: GO 91373
// result := SortListByListDesc ( units , tmp ) ;
91353: LD_ADDR_VAR 0 3
91357: PUSH
91358: LD_VAR 0 1
91362: PPUSH
91363: LD_VAR 0 5
91367: PPUSH
91368: CALL_OW 77
91372: ST_TO_ADDR
// end ;
91373: LD_VAR 0 3
91377: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
91378: LD_INT 0
91380: PPUSH
91381: PPUSH
91382: PPUSH
// x := GetX ( building ) ;
91383: LD_ADDR_VAR 0 4
91387: PUSH
91388: LD_VAR 0 2
91392: PPUSH
91393: CALL_OW 250
91397: ST_TO_ADDR
// y := GetY ( building ) ;
91398: LD_ADDR_VAR 0 5
91402: PUSH
91403: LD_VAR 0 2
91407: PPUSH
91408: CALL_OW 251
91412: ST_TO_ADDR
// if GetTaskList ( unit ) then
91413: LD_VAR 0 1
91417: PPUSH
91418: CALL_OW 437
91422: IFFALSE 91517
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91424: LD_STRING e
91426: PUSH
91427: LD_VAR 0 1
91431: PPUSH
91432: CALL_OW 437
91436: PUSH
91437: LD_INT 1
91439: ARRAY
91440: PUSH
91441: LD_INT 1
91443: ARRAY
91444: EQUAL
91445: PUSH
91446: LD_VAR 0 4
91450: PUSH
91451: LD_VAR 0 1
91455: PPUSH
91456: CALL_OW 437
91460: PUSH
91461: LD_INT 1
91463: ARRAY
91464: PUSH
91465: LD_INT 2
91467: ARRAY
91468: EQUAL
91469: AND
91470: PUSH
91471: LD_VAR 0 5
91475: PUSH
91476: LD_VAR 0 1
91480: PPUSH
91481: CALL_OW 437
91485: PUSH
91486: LD_INT 1
91488: ARRAY
91489: PUSH
91490: LD_INT 3
91492: ARRAY
91493: EQUAL
91494: AND
91495: IFFALSE 91507
// result := true else
91497: LD_ADDR_VAR 0 3
91501: PUSH
91502: LD_INT 1
91504: ST_TO_ADDR
91505: GO 91515
// result := false ;
91507: LD_ADDR_VAR 0 3
91511: PUSH
91512: LD_INT 0
91514: ST_TO_ADDR
// end else
91515: GO 91525
// result := false ;
91517: LD_ADDR_VAR 0 3
91521: PUSH
91522: LD_INT 0
91524: ST_TO_ADDR
// end ;
91525: LD_VAR 0 3
91529: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
91530: LD_INT 0
91532: PPUSH
91533: PPUSH
91534: PPUSH
91535: PPUSH
// if not unit or not area then
91536: LD_VAR 0 1
91540: NOT
91541: PUSH
91542: LD_VAR 0 2
91546: NOT
91547: OR
91548: IFFALSE 91552
// exit ;
91550: GO 91716
// tmp := AreaToList ( area , i ) ;
91552: LD_ADDR_VAR 0 6
91556: PUSH
91557: LD_VAR 0 2
91561: PPUSH
91562: LD_VAR 0 5
91566: PPUSH
91567: CALL_OW 517
91571: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
91572: LD_ADDR_VAR 0 5
91576: PUSH
91577: DOUBLE
91578: LD_INT 1
91580: DEC
91581: ST_TO_ADDR
91582: LD_VAR 0 6
91586: PUSH
91587: LD_INT 1
91589: ARRAY
91590: PUSH
91591: FOR_TO
91592: IFFALSE 91714
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
91594: LD_ADDR_VAR 0 7
91598: PUSH
91599: LD_VAR 0 6
91603: PUSH
91604: LD_INT 1
91606: ARRAY
91607: PUSH
91608: LD_VAR 0 5
91612: ARRAY
91613: PUSH
91614: LD_VAR 0 6
91618: PUSH
91619: LD_INT 2
91621: ARRAY
91622: PUSH
91623: LD_VAR 0 5
91627: ARRAY
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
91633: LD_VAR 0 7
91637: PUSH
91638: LD_INT 1
91640: ARRAY
91641: PPUSH
91642: LD_VAR 0 7
91646: PUSH
91647: LD_INT 2
91649: ARRAY
91650: PPUSH
91651: CALL_OW 428
91655: PUSH
91656: LD_INT 0
91658: EQUAL
91659: IFFALSE 91712
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
91661: LD_VAR 0 1
91665: PPUSH
91666: LD_VAR 0 7
91670: PUSH
91671: LD_INT 1
91673: ARRAY
91674: PPUSH
91675: LD_VAR 0 7
91679: PUSH
91680: LD_INT 2
91682: ARRAY
91683: PPUSH
91684: LD_VAR 0 3
91688: PPUSH
91689: CALL_OW 48
// result := IsPlaced ( unit ) ;
91693: LD_ADDR_VAR 0 4
91697: PUSH
91698: LD_VAR 0 1
91702: PPUSH
91703: CALL_OW 305
91707: ST_TO_ADDR
// exit ;
91708: POP
91709: POP
91710: GO 91716
// end ; end ;
91712: GO 91591
91714: POP
91715: POP
// end ;
91716: LD_VAR 0 4
91720: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
91721: LD_INT 0
91723: PPUSH
91724: PPUSH
91725: PPUSH
// if not side or side > 8 then
91726: LD_VAR 0 1
91730: NOT
91731: PUSH
91732: LD_VAR 0 1
91736: PUSH
91737: LD_INT 8
91739: GREATER
91740: OR
91741: IFFALSE 91745
// exit ;
91743: GO 91932
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
91745: LD_ADDR_VAR 0 4
91749: PUSH
91750: LD_INT 22
91752: PUSH
91753: LD_VAR 0 1
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 21
91764: PUSH
91765: LD_INT 3
91767: PUSH
91768: EMPTY
91769: LIST
91770: LIST
91771: PUSH
91772: EMPTY
91773: LIST
91774: LIST
91775: PPUSH
91776: CALL_OW 69
91780: ST_TO_ADDR
// if not tmp then
91781: LD_VAR 0 4
91785: NOT
91786: IFFALSE 91790
// exit ;
91788: GO 91932
// enable_addtolog := true ;
91790: LD_ADDR_OWVAR 81
91794: PUSH
91795: LD_INT 1
91797: ST_TO_ADDR
// AddToLog ( [ ) ;
91798: LD_STRING [
91800: PPUSH
91801: CALL_OW 561
// for i in tmp do
91805: LD_ADDR_VAR 0 3
91809: PUSH
91810: LD_VAR 0 4
91814: PUSH
91815: FOR_IN
91816: IFFALSE 91923
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
91818: LD_STRING [
91820: PUSH
91821: LD_VAR 0 3
91825: PPUSH
91826: CALL_OW 266
91830: STR
91831: PUSH
91832: LD_STRING , 
91834: STR
91835: PUSH
91836: LD_VAR 0 3
91840: PPUSH
91841: CALL_OW 250
91845: STR
91846: PUSH
91847: LD_STRING , 
91849: STR
91850: PUSH
91851: LD_VAR 0 3
91855: PPUSH
91856: CALL_OW 251
91860: STR
91861: PUSH
91862: LD_STRING , 
91864: STR
91865: PUSH
91866: LD_VAR 0 3
91870: PPUSH
91871: CALL_OW 254
91875: STR
91876: PUSH
91877: LD_STRING , 
91879: STR
91880: PUSH
91881: LD_VAR 0 3
91885: PPUSH
91886: LD_INT 1
91888: PPUSH
91889: CALL_OW 268
91893: STR
91894: PUSH
91895: LD_STRING , 
91897: STR
91898: PUSH
91899: LD_VAR 0 3
91903: PPUSH
91904: LD_INT 2
91906: PPUSH
91907: CALL_OW 268
91911: STR
91912: PUSH
91913: LD_STRING ],
91915: STR
91916: PPUSH
91917: CALL_OW 561
// end ;
91921: GO 91815
91923: POP
91924: POP
// AddToLog ( ]; ) ;
91925: LD_STRING ];
91927: PPUSH
91928: CALL_OW 561
// end ;
91932: LD_VAR 0 2
91936: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
91937: LD_INT 0
91939: PPUSH
91940: PPUSH
91941: PPUSH
91942: PPUSH
91943: PPUSH
// if not area or not rate or not max then
91944: LD_VAR 0 1
91948: NOT
91949: PUSH
91950: LD_VAR 0 2
91954: NOT
91955: OR
91956: PUSH
91957: LD_VAR 0 4
91961: NOT
91962: OR
91963: IFFALSE 91967
// exit ;
91965: GO 92159
// while 1 do
91967: LD_INT 1
91969: IFFALSE 92159
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
91971: LD_ADDR_VAR 0 9
91975: PUSH
91976: LD_VAR 0 1
91980: PPUSH
91981: LD_INT 1
91983: PPUSH
91984: CALL_OW 287
91988: PUSH
91989: LD_INT 10
91991: MUL
91992: ST_TO_ADDR
// r := rate / 10 ;
91993: LD_ADDR_VAR 0 7
91997: PUSH
91998: LD_VAR 0 2
92002: PUSH
92003: LD_INT 10
92005: DIVREAL
92006: ST_TO_ADDR
// time := 1 1$00 ;
92007: LD_ADDR_VAR 0 8
92011: PUSH
92012: LD_INT 2100
92014: ST_TO_ADDR
// if amount < min then
92015: LD_VAR 0 9
92019: PUSH
92020: LD_VAR 0 3
92024: LESS
92025: IFFALSE 92043
// r := r * 2 else
92027: LD_ADDR_VAR 0 7
92031: PUSH
92032: LD_VAR 0 7
92036: PUSH
92037: LD_INT 2
92039: MUL
92040: ST_TO_ADDR
92041: GO 92069
// if amount > max then
92043: LD_VAR 0 9
92047: PUSH
92048: LD_VAR 0 4
92052: GREATER
92053: IFFALSE 92069
// r := r / 2 ;
92055: LD_ADDR_VAR 0 7
92059: PUSH
92060: LD_VAR 0 7
92064: PUSH
92065: LD_INT 2
92067: DIVREAL
92068: ST_TO_ADDR
// time := time / r ;
92069: LD_ADDR_VAR 0 8
92073: PUSH
92074: LD_VAR 0 8
92078: PUSH
92079: LD_VAR 0 7
92083: DIVREAL
92084: ST_TO_ADDR
// if time < 0 then
92085: LD_VAR 0 8
92089: PUSH
92090: LD_INT 0
92092: LESS
92093: IFFALSE 92110
// time := time * - 1 ;
92095: LD_ADDR_VAR 0 8
92099: PUSH
92100: LD_VAR 0 8
92104: PUSH
92105: LD_INT 1
92107: NEG
92108: MUL
92109: ST_TO_ADDR
// wait ( time ) ;
92110: LD_VAR 0 8
92114: PPUSH
92115: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92119: LD_INT 35
92121: PPUSH
92122: LD_INT 875
92124: PPUSH
92125: CALL_OW 12
92129: PPUSH
92130: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92134: LD_INT 1
92136: PPUSH
92137: LD_INT 5
92139: PPUSH
92140: CALL_OW 12
92144: PPUSH
92145: LD_VAR 0 1
92149: PPUSH
92150: LD_INT 1
92152: PPUSH
92153: CALL_OW 55
// end ;
92157: GO 91967
// end ;
92159: LD_VAR 0 5
92163: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92164: LD_INT 0
92166: PPUSH
92167: PPUSH
92168: PPUSH
92169: PPUSH
92170: PPUSH
92171: PPUSH
92172: PPUSH
92173: PPUSH
// if not turrets or not factories then
92174: LD_VAR 0 1
92178: NOT
92179: PUSH
92180: LD_VAR 0 2
92184: NOT
92185: OR
92186: IFFALSE 92190
// exit ;
92188: GO 92497
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92190: LD_ADDR_VAR 0 10
92194: PUSH
92195: LD_INT 5
92197: PUSH
92198: LD_INT 6
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 2
92207: PUSH
92208: LD_INT 4
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: PUSH
92215: LD_INT 3
92217: PUSH
92218: LD_INT 5
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: LIST
92229: PUSH
92230: LD_INT 24
92232: PUSH
92233: LD_INT 25
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: PUSH
92240: LD_INT 23
92242: PUSH
92243: LD_INT 27
92245: PUSH
92246: EMPTY
92247: LIST
92248: LIST
92249: PUSH
92250: EMPTY
92251: LIST
92252: LIST
92253: PUSH
92254: LD_INT 42
92256: PUSH
92257: LD_INT 43
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: LD_INT 44
92266: PUSH
92267: LD_INT 46
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: LD_INT 45
92276: PUSH
92277: LD_INT 47
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: LIST
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: LIST
92293: ST_TO_ADDR
// result := [ ] ;
92294: LD_ADDR_VAR 0 3
92298: PUSH
92299: EMPTY
92300: ST_TO_ADDR
// for i in turrets do
92301: LD_ADDR_VAR 0 4
92305: PUSH
92306: LD_VAR 0 1
92310: PUSH
92311: FOR_IN
92312: IFFALSE 92495
// begin nat := GetNation ( i ) ;
92314: LD_ADDR_VAR 0 7
92318: PUSH
92319: LD_VAR 0 4
92323: PPUSH
92324: CALL_OW 248
92328: ST_TO_ADDR
// weapon := 0 ;
92329: LD_ADDR_VAR 0 8
92333: PUSH
92334: LD_INT 0
92336: ST_TO_ADDR
// if not nat then
92337: LD_VAR 0 7
92341: NOT
92342: IFFALSE 92346
// continue ;
92344: GO 92311
// for j in list [ nat ] do
92346: LD_ADDR_VAR 0 5
92350: PUSH
92351: LD_VAR 0 10
92355: PUSH
92356: LD_VAR 0 7
92360: ARRAY
92361: PUSH
92362: FOR_IN
92363: IFFALSE 92404
// if GetBWeapon ( i ) = j [ 1 ] then
92365: LD_VAR 0 4
92369: PPUSH
92370: CALL_OW 269
92374: PUSH
92375: LD_VAR 0 5
92379: PUSH
92380: LD_INT 1
92382: ARRAY
92383: EQUAL
92384: IFFALSE 92402
// begin weapon := j [ 2 ] ;
92386: LD_ADDR_VAR 0 8
92390: PUSH
92391: LD_VAR 0 5
92395: PUSH
92396: LD_INT 2
92398: ARRAY
92399: ST_TO_ADDR
// break ;
92400: GO 92404
// end ;
92402: GO 92362
92404: POP
92405: POP
// if not weapon then
92406: LD_VAR 0 8
92410: NOT
92411: IFFALSE 92415
// continue ;
92413: GO 92311
// for k in factories do
92415: LD_ADDR_VAR 0 6
92419: PUSH
92420: LD_VAR 0 2
92424: PUSH
92425: FOR_IN
92426: IFFALSE 92491
// begin weapons := AvailableWeaponList ( k ) ;
92428: LD_ADDR_VAR 0 9
92432: PUSH
92433: LD_VAR 0 6
92437: PPUSH
92438: CALL_OW 478
92442: ST_TO_ADDR
// if not weapons then
92443: LD_VAR 0 9
92447: NOT
92448: IFFALSE 92452
// continue ;
92450: GO 92425
// if weapon in weapons then
92452: LD_VAR 0 8
92456: PUSH
92457: LD_VAR 0 9
92461: IN
92462: IFFALSE 92489
// begin result := [ i , weapon ] ;
92464: LD_ADDR_VAR 0 3
92468: PUSH
92469: LD_VAR 0 4
92473: PUSH
92474: LD_VAR 0 8
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: ST_TO_ADDR
// exit ;
92483: POP
92484: POP
92485: POP
92486: POP
92487: GO 92497
// end ; end ;
92489: GO 92425
92491: POP
92492: POP
// end ;
92493: GO 92311
92495: POP
92496: POP
// end ;
92497: LD_VAR 0 3
92501: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
92502: LD_INT 0
92504: PPUSH
// if not side or side > 8 then
92505: LD_VAR 0 3
92509: NOT
92510: PUSH
92511: LD_VAR 0 3
92515: PUSH
92516: LD_INT 8
92518: GREATER
92519: OR
92520: IFFALSE 92524
// exit ;
92522: GO 92583
// if not range then
92524: LD_VAR 0 4
92528: NOT
92529: IFFALSE 92540
// range := - 12 ;
92531: LD_ADDR_VAR 0 4
92535: PUSH
92536: LD_INT 12
92538: NEG
92539: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
92540: LD_VAR 0 1
92544: PPUSH
92545: LD_VAR 0 2
92549: PPUSH
92550: LD_VAR 0 3
92554: PPUSH
92555: LD_VAR 0 4
92559: PPUSH
92560: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
92564: LD_VAR 0 1
92568: PPUSH
92569: LD_VAR 0 2
92573: PPUSH
92574: LD_VAR 0 3
92578: PPUSH
92579: CALL_OW 331
// end ;
92583: LD_VAR 0 5
92587: RET
// export function Video ( mode ) ; begin
92588: LD_INT 0
92590: PPUSH
// ingame_video = mode ;
92591: LD_ADDR_OWVAR 52
92595: PUSH
92596: LD_VAR 0 1
92600: ST_TO_ADDR
// interface_hidden = mode ;
92601: LD_ADDR_OWVAR 54
92605: PUSH
92606: LD_VAR 0 1
92610: ST_TO_ADDR
// end ;
92611: LD_VAR 0 2
92615: RET
// export function Join ( array , element ) ; begin
92616: LD_INT 0
92618: PPUSH
// result := array ^ element ;
92619: LD_ADDR_VAR 0 3
92623: PUSH
92624: LD_VAR 0 1
92628: PUSH
92629: LD_VAR 0 2
92633: ADD
92634: ST_TO_ADDR
// end ;
92635: LD_VAR 0 3
92639: RET
// export function JoinUnion ( array , element ) ; begin
92640: LD_INT 0
92642: PPUSH
// result := array union element ;
92643: LD_ADDR_VAR 0 3
92647: PUSH
92648: LD_VAR 0 1
92652: PUSH
92653: LD_VAR 0 2
92657: UNION
92658: ST_TO_ADDR
// end ;
92659: LD_VAR 0 3
92663: RET
// export function GetBehemoths ( side ) ; begin
92664: LD_INT 0
92666: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
92667: LD_ADDR_VAR 0 2
92671: PUSH
92672: LD_INT 22
92674: PUSH
92675: LD_VAR 0 1
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: PUSH
92684: LD_INT 31
92686: PUSH
92687: LD_INT 25
92689: PUSH
92690: EMPTY
92691: LIST
92692: LIST
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PPUSH
92698: CALL_OW 69
92702: ST_TO_ADDR
// end ;
92703: LD_VAR 0 2
92707: RET
// export function Shuffle ( array ) ; var i , index ; begin
92708: LD_INT 0
92710: PPUSH
92711: PPUSH
92712: PPUSH
// result := [ ] ;
92713: LD_ADDR_VAR 0 2
92717: PUSH
92718: EMPTY
92719: ST_TO_ADDR
// if not array then
92720: LD_VAR 0 1
92724: NOT
92725: IFFALSE 92729
// exit ;
92727: GO 92828
// Randomize ;
92729: CALL_OW 10
// for i = array downto 1 do
92733: LD_ADDR_VAR 0 3
92737: PUSH
92738: DOUBLE
92739: LD_VAR 0 1
92743: INC
92744: ST_TO_ADDR
92745: LD_INT 1
92747: PUSH
92748: FOR_DOWNTO
92749: IFFALSE 92826
// begin index := rand ( 1 , array ) ;
92751: LD_ADDR_VAR 0 4
92755: PUSH
92756: LD_INT 1
92758: PPUSH
92759: LD_VAR 0 1
92763: PPUSH
92764: CALL_OW 12
92768: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
92769: LD_ADDR_VAR 0 2
92773: PUSH
92774: LD_VAR 0 2
92778: PPUSH
92779: LD_VAR 0 2
92783: PUSH
92784: LD_INT 1
92786: PLUS
92787: PPUSH
92788: LD_VAR 0 1
92792: PUSH
92793: LD_VAR 0 4
92797: ARRAY
92798: PPUSH
92799: CALL_OW 2
92803: ST_TO_ADDR
// array := Delete ( array , index ) ;
92804: LD_ADDR_VAR 0 1
92808: PUSH
92809: LD_VAR 0 1
92813: PPUSH
92814: LD_VAR 0 4
92818: PPUSH
92819: CALL_OW 3
92823: ST_TO_ADDR
// end ;
92824: GO 92748
92826: POP
92827: POP
// end ;
92828: LD_VAR 0 2
92832: RET
// export function GetBaseMaterials ( base ) ; begin
92833: LD_INT 0
92835: PPUSH
// result := [ 0 , 0 , 0 ] ;
92836: LD_ADDR_VAR 0 2
92840: PUSH
92841: LD_INT 0
92843: PUSH
92844: LD_INT 0
92846: PUSH
92847: LD_INT 0
92849: PUSH
92850: EMPTY
92851: LIST
92852: LIST
92853: LIST
92854: ST_TO_ADDR
// if not base then
92855: LD_VAR 0 1
92859: NOT
92860: IFFALSE 92864
// exit ;
92862: GO 92913
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
92864: LD_ADDR_VAR 0 2
92868: PUSH
92869: LD_VAR 0 1
92873: PPUSH
92874: LD_INT 1
92876: PPUSH
92877: CALL_OW 275
92881: PUSH
92882: LD_VAR 0 1
92886: PPUSH
92887: LD_INT 2
92889: PPUSH
92890: CALL_OW 275
92894: PUSH
92895: LD_VAR 0 1
92899: PPUSH
92900: LD_INT 3
92902: PPUSH
92903: CALL_OW 275
92907: PUSH
92908: EMPTY
92909: LIST
92910: LIST
92911: LIST
92912: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
92913: LD_VAR 0 2
92917: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
92918: LD_INT 0
92920: PPUSH
92921: PPUSH
92922: PPUSH
92923: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
92924: LD_VAR 0 1
92928: PPUSH
92929: CALL_OW 264
92933: PUSH
92934: LD_EXP 71
92938: EQUAL
92939: IFFALSE 93011
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
92941: LD_INT 68
92943: PPUSH
92944: LD_VAR 0 1
92948: PPUSH
92949: CALL_OW 255
92953: PPUSH
92954: CALL_OW 321
92958: PUSH
92959: LD_INT 2
92961: EQUAL
92962: IFFALSE 92974
// eff := 70 else
92964: LD_ADDR_VAR 0 6
92968: PUSH
92969: LD_INT 70
92971: ST_TO_ADDR
92972: GO 92982
// eff := 30 ;
92974: LD_ADDR_VAR 0 6
92978: PUSH
92979: LD_INT 30
92981: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
92982: LD_VAR 0 1
92986: PPUSH
92987: CALL_OW 250
92991: PPUSH
92992: LD_VAR 0 1
92996: PPUSH
92997: CALL_OW 251
93001: PPUSH
93002: LD_VAR 0 6
93006: PPUSH
93007: CALL_OW 495
// end ; end ;
93011: LD_VAR 0 4
93015: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
93016: LD_INT 0
93018: PPUSH
93019: PPUSH
93020: PPUSH
93021: PPUSH
93022: PPUSH
93023: PPUSH
// if cmd = 124 then
93024: LD_VAR 0 1
93028: PUSH
93029: LD_INT 124
93031: EQUAL
93032: IFFALSE 93238
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
93034: LD_ADDR_VAR 0 5
93038: PUSH
93039: LD_INT 2
93041: PUSH
93042: LD_INT 34
93044: PUSH
93045: LD_INT 53
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 34
93054: PUSH
93055: LD_INT 14
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: LIST
93066: PPUSH
93067: CALL_OW 69
93071: ST_TO_ADDR
// if not tmp then
93072: LD_VAR 0 5
93076: NOT
93077: IFFALSE 93081
// exit ;
93079: GO 93238
// for i in tmp do
93081: LD_ADDR_VAR 0 3
93085: PUSH
93086: LD_VAR 0 5
93090: PUSH
93091: FOR_IN
93092: IFFALSE 93236
// begin taskList := GetTaskList ( i ) ;
93094: LD_ADDR_VAR 0 6
93098: PUSH
93099: LD_VAR 0 3
93103: PPUSH
93104: CALL_OW 437
93108: ST_TO_ADDR
// if not taskList then
93109: LD_VAR 0 6
93113: NOT
93114: IFFALSE 93118
// continue ;
93116: GO 93091
// for j = 1 to taskList do
93118: LD_ADDR_VAR 0 4
93122: PUSH
93123: DOUBLE
93124: LD_INT 1
93126: DEC
93127: ST_TO_ADDR
93128: LD_VAR 0 6
93132: PUSH
93133: FOR_TO
93134: IFFALSE 93232
// if taskList [ j ] [ 1 ] = | then
93136: LD_VAR 0 6
93140: PUSH
93141: LD_VAR 0 4
93145: ARRAY
93146: PUSH
93147: LD_INT 1
93149: ARRAY
93150: PUSH
93151: LD_STRING |
93153: EQUAL
93154: IFFALSE 93230
// begin _taskList := Delete ( taskList , 1 ) ;
93156: LD_ADDR_VAR 0 7
93160: PUSH
93161: LD_VAR 0 6
93165: PPUSH
93166: LD_INT 1
93168: PPUSH
93169: CALL_OW 3
93173: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
93174: LD_VAR 0 3
93178: PPUSH
93179: LD_VAR 0 7
93183: PPUSH
93184: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
93188: LD_VAR 0 3
93192: PPUSH
93193: LD_VAR 0 6
93197: PUSH
93198: LD_VAR 0 4
93202: ARRAY
93203: PUSH
93204: LD_INT 2
93206: ARRAY
93207: PPUSH
93208: LD_VAR 0 6
93212: PUSH
93213: LD_VAR 0 4
93217: ARRAY
93218: PUSH
93219: LD_INT 3
93221: ARRAY
93222: PPUSH
93223: LD_INT 8
93225: PPUSH
93226: CALL 93243 0 4
// end ;
93230: GO 93133
93232: POP
93233: POP
// end ;
93234: GO 93091
93236: POP
93237: POP
// end ; end ;
93238: LD_VAR 0 2
93242: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93243: LD_INT 0
93245: PPUSH
93246: PPUSH
93247: PPUSH
93248: PPUSH
93249: PPUSH
93250: PPUSH
93251: PPUSH
93252: PPUSH
93253: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93254: LD_VAR 0 1
93258: NOT
93259: PUSH
93260: LD_VAR 0 2
93264: PPUSH
93265: LD_VAR 0 3
93269: PPUSH
93270: CALL_OW 488
93274: NOT
93275: OR
93276: PUSH
93277: LD_VAR 0 4
93281: NOT
93282: OR
93283: IFFALSE 93287
// exit ;
93285: GO 93627
// list := [ ] ;
93287: LD_ADDR_VAR 0 13
93291: PUSH
93292: EMPTY
93293: ST_TO_ADDR
// if x - r < 0 then
93294: LD_VAR 0 2
93298: PUSH
93299: LD_VAR 0 4
93303: MINUS
93304: PUSH
93305: LD_INT 0
93307: LESS
93308: IFFALSE 93320
// min_x := 0 else
93310: LD_ADDR_VAR 0 7
93314: PUSH
93315: LD_INT 0
93317: ST_TO_ADDR
93318: GO 93336
// min_x := x - r ;
93320: LD_ADDR_VAR 0 7
93324: PUSH
93325: LD_VAR 0 2
93329: PUSH
93330: LD_VAR 0 4
93334: MINUS
93335: ST_TO_ADDR
// if y - r < 0 then
93336: LD_VAR 0 3
93340: PUSH
93341: LD_VAR 0 4
93345: MINUS
93346: PUSH
93347: LD_INT 0
93349: LESS
93350: IFFALSE 93362
// min_y := 0 else
93352: LD_ADDR_VAR 0 8
93356: PUSH
93357: LD_INT 0
93359: ST_TO_ADDR
93360: GO 93378
// min_y := y - r ;
93362: LD_ADDR_VAR 0 8
93366: PUSH
93367: LD_VAR 0 3
93371: PUSH
93372: LD_VAR 0 4
93376: MINUS
93377: ST_TO_ADDR
// max_x := x + r ;
93378: LD_ADDR_VAR 0 9
93382: PUSH
93383: LD_VAR 0 2
93387: PUSH
93388: LD_VAR 0 4
93392: PLUS
93393: ST_TO_ADDR
// max_y := y + r ;
93394: LD_ADDR_VAR 0 10
93398: PUSH
93399: LD_VAR 0 3
93403: PUSH
93404: LD_VAR 0 4
93408: PLUS
93409: ST_TO_ADDR
// for _x = min_x to max_x do
93410: LD_ADDR_VAR 0 11
93414: PUSH
93415: DOUBLE
93416: LD_VAR 0 7
93420: DEC
93421: ST_TO_ADDR
93422: LD_VAR 0 9
93426: PUSH
93427: FOR_TO
93428: IFFALSE 93545
// for _y = min_y to max_y do
93430: LD_ADDR_VAR 0 12
93434: PUSH
93435: DOUBLE
93436: LD_VAR 0 8
93440: DEC
93441: ST_TO_ADDR
93442: LD_VAR 0 10
93446: PUSH
93447: FOR_TO
93448: IFFALSE 93541
// begin if not ValidHex ( _x , _y ) then
93450: LD_VAR 0 11
93454: PPUSH
93455: LD_VAR 0 12
93459: PPUSH
93460: CALL_OW 488
93464: NOT
93465: IFFALSE 93469
// continue ;
93467: GO 93447
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
93469: LD_VAR 0 11
93473: PPUSH
93474: LD_VAR 0 12
93478: PPUSH
93479: CALL_OW 351
93483: PUSH
93484: LD_VAR 0 11
93488: PPUSH
93489: LD_VAR 0 12
93493: PPUSH
93494: CALL_OW 554
93498: AND
93499: IFFALSE 93539
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
93501: LD_ADDR_VAR 0 13
93505: PUSH
93506: LD_VAR 0 13
93510: PPUSH
93511: LD_VAR 0 13
93515: PUSH
93516: LD_INT 1
93518: PLUS
93519: PPUSH
93520: LD_VAR 0 11
93524: PUSH
93525: LD_VAR 0 12
93529: PUSH
93530: EMPTY
93531: LIST
93532: LIST
93533: PPUSH
93534: CALL_OW 2
93538: ST_TO_ADDR
// end ;
93539: GO 93447
93541: POP
93542: POP
93543: GO 93427
93545: POP
93546: POP
// if not list then
93547: LD_VAR 0 13
93551: NOT
93552: IFFALSE 93556
// exit ;
93554: GO 93627
// for i in list do
93556: LD_ADDR_VAR 0 6
93560: PUSH
93561: LD_VAR 0 13
93565: PUSH
93566: FOR_IN
93567: IFFALSE 93625
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
93569: LD_VAR 0 1
93573: PPUSH
93574: LD_STRING M
93576: PUSH
93577: LD_VAR 0 6
93581: PUSH
93582: LD_INT 1
93584: ARRAY
93585: PUSH
93586: LD_VAR 0 6
93590: PUSH
93591: LD_INT 2
93593: ARRAY
93594: PUSH
93595: LD_INT 0
93597: PUSH
93598: LD_INT 0
93600: PUSH
93601: LD_INT 0
93603: PUSH
93604: LD_INT 0
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: PUSH
93616: EMPTY
93617: LIST
93618: PPUSH
93619: CALL_OW 447
93623: GO 93566
93625: POP
93626: POP
// end ;
93627: LD_VAR 0 5
93631: RET
