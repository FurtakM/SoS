// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 21252 0 0
// InitMacro ;
  19: CALL 21428 0 0
// InitNature ;
  23: CALL 17918 0 0
// InitArtifact ;
  27: CALL 18535 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 5067 0 0
// PrepareAlliance ;
  48: CALL 1444 0 0
// PrepareArabian ;
  52: CALL 6839 0 0
// PrepareRussian ;
  56: CALL 8848 0 0
// PrepareLegion ;
  60: CALL 7271 0 0
// Action ;
  64: CALL 11481 0 0
// MC_Start ( ) ;
  68: CALL 23593 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// allianceTeam := [ ] ;
 212: LD_ADDR_EXP 17
 216: PUSH
 217: EMPTY
 218: ST_TO_ADDR
// arabianAttacked := false ;
 219: LD_ADDR_EXP 18
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// end ;
 227: LD_VAR 0 1
 231: RET
// export function CustomInitMacro ( ) ; begin
 232: LD_INT 0
 234: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 235: LD_ADDR_EXP 120
 239: PUSH
 240: LD_INT 26
 242: PUSH
 243: LD_INT 1
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: LD_INT 8
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 258: LD_ADDR_EXP 121
 262: PUSH
 263: LD_INT 27
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: LD_INT 3
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: EMPTY
 276: LIST
 277: LIST
 278: LIST
 279: LIST
 280: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 281: LD_INT 1
 283: PPUSH
 284: LD_INT 6
 286: PUSH
 287: LD_INT 7
 289: PUSH
 290: LD_INT 9
 292: PUSH
 293: LD_INT 10
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: PUSH
 302: LD_OWVAR 67
 306: ARRAY
 307: PPUSH
 308: LD_INT 28
 310: PPUSH
 311: CALL 45282 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 315: LD_INT 1
 317: PPUSH
 318: LD_INT 10
 320: PUSH
 321: LD_INT 11
 323: PUSH
 324: LD_INT 13
 326: PUSH
 327: LD_INT 15
 329: PUSH
 330: EMPTY
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: PPUSH
 336: CALL 46342 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 29
 345: PUSH
 346: EMPTY
 347: LIST
 348: PPUSH
 349: CALL 46435 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 353: LD_ADDR_EXP 125
 357: PUSH
 358: LD_EXP 125
 362: PPUSH
 363: LD_INT 1
 365: PPUSH
 366: LD_INT 22
 368: PUSH
 369: LD_INT 2
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 25
 378: PUSH
 379: LD_INT 15
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL_OW 69
 394: PPUSH
 395: CALL_OW 1
 399: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 400: LD_INT 1
 402: PPUSH
 403: LD_INT 13
 405: PUSH
 406: LD_INT 2
 408: PUSH
 409: LD_INT 1
 411: PUSH
 412: LD_INT 31
 414: PUSH
 415: EMPTY
 416: LIST
 417: LIST
 418: LIST
 419: LIST
 420: PUSH
 421: LD_INT 13
 423: PUSH
 424: LD_INT 2
 426: PUSH
 427: LD_INT 1
 429: PUSH
 430: LD_INT 31
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 13
 441: PUSH
 442: LD_INT 1
 444: PUSH
 445: LD_INT 1
 447: PUSH
 448: LD_INT 28
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 13
 459: PUSH
 460: LD_INT 1
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 28
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 13
 477: PUSH
 478: LD_INT 1
 480: PUSH
 481: LD_INT 1
 483: PUSH
 484: LD_INT 28
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 13
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: LD_INT 28
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 13
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_EXP 80
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PPUSH
 540: CALL 45600 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 544: LD_INT 1
 546: PPUSH
 547: LD_INT 4
 549: PPUSH
 550: CALL 45785 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 554: LD_INT 2
 556: PPUSH
 557: LD_INT 10
 559: PUSH
 560: LD_INT 11
 562: PUSH
 563: LD_INT 12
 565: PUSH
 566: LD_INT 14
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PPUSH
 575: CALL 46342 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 579: LD_INT 2
 581: PPUSH
 582: LD_INT 14
 584: PUSH
 585: EMPTY
 586: LIST
 587: PPUSH
 588: CALL 46435 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 21
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 51
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 22
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 52
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 24
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 47
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: PPUSH
 749: CALL 45600 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 753: LD_INT 2
 755: PPUSH
 756: LD_INT 5
 758: PPUSH
 759: CALL 45785 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 763: LD_INT 2
 765: PPUSH
 766: LD_INT 0
 768: PPUSH
 769: CALL 46215 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 773: LD_INT 3
 775: PPUSH
 776: LD_INT 10
 778: PUSH
 779: LD_INT 12
 781: PUSH
 782: LD_INT 14
 784: PUSH
 785: LD_INT 15
 787: PUSH
 788: EMPTY
 789: LIST
 790: LIST
 791: LIST
 792: LIST
 793: PUSH
 794: LD_OWVAR 67
 798: ARRAY
 799: PPUSH
 800: LD_INT 24
 802: PPUSH
 803: CALL 45282 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 10
 812: PUSH
 813: LD_INT 11
 815: PUSH
 816: LD_INT 13
 818: PUSH
 819: LD_INT 15
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 46342 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 13
 837: PUSH
 838: EMPTY
 839: LIST
 840: PPUSH
 841: CALL 46435 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 845: LD_ADDR_EXP 125
 849: PUSH
 850: LD_EXP 125
 854: PPUSH
 855: LD_INT 3
 857: PPUSH
 858: LD_INT 22
 860: PUSH
 861: LD_INT 8
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 25
 870: PUSH
 871: LD_INT 15
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: PPUSH
 882: CALL_OW 69
 886: PPUSH
 887: CALL_OW 1
 891: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 892: LD_INT 3
 894: PPUSH
 895: LD_INT 13
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 31
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 3
 936: PUSH
 937: LD_INT 2
 939: PUSH
 940: LD_INT 32
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 14
 951: PUSH
 952: LD_INT 1
 954: PUSH
 955: LD_INT 1
 957: PUSH
 958: LD_INT 28
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 2
1029: PUSH
1030: LD_EXP 80
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: PPUSH
1051: CALL 45600 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 4
1060: PPUSH
1061: CALL 45785 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1065: LD_INT 4
1067: PPUSH
1068: LD_INT 10
1070: PUSH
1071: LD_INT 12
1073: PUSH
1074: LD_INT 11
1076: PUSH
1077: LD_INT 15
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: PPUSH
1086: CALL 46342 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1090: LD_INT 4
1092: PPUSH
1093: LD_INT 33
1095: PUSH
1096: EMPTY
1097: LIST
1098: PPUSH
1099: CALL 46435 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1103: LD_INT 4
1105: PPUSH
1106: LD_INT 5
1108: PUSH
1109: LD_INT 6
1111: PUSH
1112: LD_INT 7
1114: PUSH
1115: LD_INT 9
1117: PUSH
1118: LD_INT 10
1120: PUSH
1121: EMPTY
1122: LIST
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PPUSH
1128: CALL 46753 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1132: LD_INT 4
1134: PPUSH
1135: LD_INT 54
1137: PPUSH
1138: LD_INT 85
1140: PPUSH
1141: LD_INT 2
1143: PPUSH
1144: LD_INT 25
1146: PUSH
1147: LD_INT 16
1149: PUSH
1150: LD_INT 17
1152: PUSH
1153: LD_INT 18
1155: PUSH
1156: LD_INT 22
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: PPUSH
1166: CALL 46547 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1170: LD_INT 4
1172: PPUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 1
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 7
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 5
1193: PUSH
1194: LD_INT 1
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 6
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 5
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: LD_INT 1
1217: PUSH
1218: LD_INT 7
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: LD_INT 1
1232: PUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: LD_INT 1
1250: PUSH
1251: LD_INT 3
1253: PUSH
1254: LD_INT 12
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: PUSH
1263: LD_INT 3
1265: PUSH
1266: LD_INT 1
1268: PUSH
1269: LD_INT 3
1271: PUSH
1272: LD_INT 13
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PUSH
1281: EMPTY
1282: LIST
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: PPUSH
1289: CALL 45600 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1293: LD_INT 4
1295: PPUSH
1296: LD_INT 4
1298: PPUSH
1299: CALL 45785 0 2
// MC_SetTame ( 4 , powellApe ) ;
1303: LD_INT 4
1305: PPUSH
1306: LD_INT 11
1308: PPUSH
1309: CALL 46166 0 2
// end ;
1313: LD_VAR 0 1
1317: RET
// every 0 0$1 trigger debug do var i ;
1318: LD_EXP 1
1322: IFFALSE 1420
1324: GO 1326
1326: DISABLE
1327: LD_INT 0
1329: PPUSH
// begin enable ;
1330: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1331: LD_ADDR_VAR 0 1
1335: PUSH
1336: LD_INT 22
1338: PUSH
1339: LD_INT 7
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 2
1348: PUSH
1349: LD_INT 21
1351: PUSH
1352: LD_INT 1
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 21
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: PUSH
1374: LD_INT 3
1376: PUSH
1377: LD_INT 24
1379: PUSH
1380: LD_INT 1000
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PUSH
1391: EMPTY
1392: LIST
1393: LIST
1394: LIST
1395: PPUSH
1396: CALL_OW 69
1400: PUSH
1401: FOR_IN
1402: IFFALSE 1418
// SetLives ( i , 1000 ) ;
1404: LD_VAR 0 1
1408: PPUSH
1409: LD_INT 1000
1411: PPUSH
1412: CALL_OW 234
1416: GO 1401
1418: POP
1419: POP
// end ;
1420: PPOPN 1
1422: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1423: LD_EXP 16
1427: PUSH
1428: LD_INT 5
1430: GREATEREQUAL
1431: IFFALSE 1443
1433: GO 1435
1435: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1436: LD_STRING ACH_ARTIFACT
1438: PPUSH
1439: CALL_OW 543
1443: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1444: LD_INT 0
1446: PPUSH
1447: PPUSH
1448: PPUSH
1449: PPUSH
1450: PPUSH
// uc_side := 7 ;
1451: LD_ADDR_OWVAR 20
1455: PUSH
1456: LD_INT 7
1458: ST_TO_ADDR
// tmp := [ ] ;
1459: LD_ADDR_VAR 0 5
1463: PUSH
1464: EMPTY
1465: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1466: LD_ADDR_EXP 19
1470: PUSH
1471: LD_STRING JMM
1473: PPUSH
1474: LD_EXP 1
1478: NOT
1479: PPUSH
1480: LD_STRING 14a_
1482: PPUSH
1483: CALL 52054 0 3
1487: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1488: LD_ADDR_EXP 51
1492: PUSH
1493: LD_STRING Burlak
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: LD_STRING 14a_
1504: PPUSH
1505: CALL 52054 0 3
1509: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1510: LD_ADDR_EXP 34
1514: PUSH
1515: LD_STRING Joan
1517: PPUSH
1518: LD_EXP 1
1522: NOT
1523: PPUSH
1524: LD_STRING 13a_
1526: PPUSH
1527: CALL 52054 0 3
1531: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1532: LD_ADDR_EXP 20
1536: PUSH
1537: LD_STRING Roth
1539: PPUSH
1540: LD_EXP 1
1544: NOT
1545: PPUSH
1546: LD_STRING 13a_
1548: PPUSH
1549: CALL 52054 0 3
1553: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1554: LD_ADDR_EXP 37
1558: PUSH
1559: LD_STRING Gossudarov
1561: PPUSH
1562: LD_EXP 1
1566: NOT
1567: PPUSH
1568: LD_STRING 13a_
1570: PPUSH
1571: CALL 52054 0 3
1575: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1576: LD_ADDR_EXP 25
1580: PUSH
1581: LD_STRING Denis
1583: PPUSH
1584: LD_EXP 1
1588: NOT
1589: PPUSH
1590: LD_STRING 13a_
1592: PPUSH
1593: CALL 52054 0 3
1597: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1598: LD_ADDR_EXP 35
1602: PUSH
1603: LD_STRING DeltaDoctor
1605: PPUSH
1606: LD_EXP 1
1610: NOT
1611: PPUSH
1612: LD_STRING 13a_
1614: PPUSH
1615: CALL 52054 0 3
1619: ST_TO_ADDR
// if DeltaDoctor then
1620: LD_EXP 35
1624: IFFALSE 1642
// tmp := tmp ^ DeltaDoctor ;
1626: LD_ADDR_VAR 0 5
1630: PUSH
1631: LD_VAR 0 5
1635: PUSH
1636: LD_EXP 35
1640: ADD
1641: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1642: LD_ADDR_EXP 33
1646: PUSH
1647: LD_STRING Simms
1649: PPUSH
1650: LD_EXP 1
1654: NOT
1655: PPUSH
1656: LD_STRING 13a_
1658: PPUSH
1659: CALL 52054 0 3
1663: ST_TO_ADDR
// if Simms then
1664: LD_EXP 33
1668: IFFALSE 1686
// tmp := tmp ^ Simms ;
1670: LD_ADDR_VAR 0 5
1674: PUSH
1675: LD_VAR 0 5
1679: PUSH
1680: LD_EXP 33
1684: ADD
1685: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1686: LD_ADDR_EXP 31
1690: PUSH
1691: LD_STRING Frank
1693: PPUSH
1694: LD_EXP 1
1698: NOT
1699: PPUSH
1700: LD_STRING 13a_
1702: PPUSH
1703: CALL 52054 0 3
1707: ST_TO_ADDR
// if Frank then
1708: LD_EXP 31
1712: IFFALSE 1730
// tmp := tmp ^ Frank ;
1714: LD_ADDR_VAR 0 5
1718: PUSH
1719: LD_VAR 0 5
1723: PUSH
1724: LD_EXP 31
1728: ADD
1729: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1730: LD_ADDR_EXP 38
1734: PUSH
1735: LD_STRING Kirilenkova
1737: PPUSH
1738: LD_EXP 1
1742: NOT
1743: PPUSH
1744: LD_STRING 13a_
1746: PPUSH
1747: CALL 52054 0 3
1751: ST_TO_ADDR
// if Kirilenkova then
1752: LD_EXP 38
1756: IFFALSE 1774
// tmp := tmp ^ Kirilenkova ;
1758: LD_ADDR_VAR 0 5
1762: PUSH
1763: LD_VAR 0 5
1767: PUSH
1768: LD_EXP 38
1772: ADD
1773: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1774: LD_ADDR_EXP 39
1778: PUSH
1779: LD_STRING Titov
1781: PPUSH
1782: LD_EXP 1
1786: NOT
1787: PPUSH
1788: LD_STRING 13a_
1790: PPUSH
1791: CALL 52054 0 3
1795: ST_TO_ADDR
// if Titov then
1796: LD_EXP 39
1800: IFFALSE 1818
// tmp := tmp ^ Titov ;
1802: LD_ADDR_VAR 0 5
1806: PUSH
1807: LD_VAR 0 5
1811: PUSH
1812: LD_EXP 39
1816: ADD
1817: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1818: LD_ADDR_EXP 40
1822: PUSH
1823: LD_STRING Fadeev
1825: PPUSH
1826: LD_EXP 1
1830: NOT
1831: PPUSH
1832: LD_STRING 13a_
1834: PPUSH
1835: CALL 52054 0 3
1839: ST_TO_ADDR
// if Fadeev then
1840: LD_EXP 40
1844: IFFALSE 1862
// tmp := tmp ^ Fadeev ;
1846: LD_ADDR_VAR 0 5
1850: PUSH
1851: LD_VAR 0 5
1855: PUSH
1856: LD_EXP 40
1860: ADD
1861: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1862: LD_ADDR_EXP 41
1866: PUSH
1867: LD_STRING Dolgov
1869: PPUSH
1870: LD_EXP 1
1874: NOT
1875: PPUSH
1876: LD_STRING 13a_
1878: PPUSH
1879: CALL 52054 0 3
1883: ST_TO_ADDR
// if Dolgov then
1884: LD_EXP 41
1888: IFFALSE 1906
// tmp := tmp ^ Dolgov ;
1890: LD_ADDR_VAR 0 5
1894: PUSH
1895: LD_VAR 0 5
1899: PUSH
1900: LD_EXP 41
1904: ADD
1905: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1906: LD_ADDR_EXP 42
1910: PUSH
1911: LD_STRING Petrosyan
1913: PPUSH
1914: LD_EXP 1
1918: NOT
1919: PPUSH
1920: LD_STRING 13a_
1922: PPUSH
1923: CALL 52054 0 3
1927: ST_TO_ADDR
// if Petrosyan then
1928: LD_EXP 42
1932: IFFALSE 1950
// tmp := tmp ^ Petrosyan ;
1934: LD_ADDR_VAR 0 5
1938: PUSH
1939: LD_VAR 0 5
1943: PUSH
1944: LD_EXP 42
1948: ADD
1949: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1950: LD_ADDR_EXP 43
1954: PUSH
1955: LD_STRING Scholtze
1957: PPUSH
1958: LD_EXP 1
1962: NOT
1963: PPUSH
1964: LD_STRING 13a_
1966: PPUSH
1967: CALL 52054 0 3
1971: ST_TO_ADDR
// if Scholtze then
1972: LD_EXP 43
1976: IFFALSE 1994
// tmp := tmp ^ Scholtze ;
1978: LD_ADDR_VAR 0 5
1982: PUSH
1983: LD_VAR 0 5
1987: PUSH
1988: LD_EXP 43
1992: ADD
1993: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1994: LD_ADDR_EXP 44
1998: PUSH
1999: LD_STRING Oblukov
2001: PPUSH
2002: LD_EXP 1
2006: NOT
2007: PPUSH
2008: LD_STRING 13a_
2010: PPUSH
2011: CALL 52054 0 3
2015: ST_TO_ADDR
// if Oblukov then
2016: LD_EXP 44
2020: IFFALSE 2038
// tmp := tmp ^ Oblukov ;
2022: LD_ADDR_VAR 0 5
2026: PUSH
2027: LD_VAR 0 5
2031: PUSH
2032: LD_EXP 44
2036: ADD
2037: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2038: LD_ADDR_EXP 45
2042: PUSH
2043: LD_STRING Kapitsova
2045: PPUSH
2046: LD_EXP 1
2050: NOT
2051: PPUSH
2052: LD_STRING 13a_
2054: PPUSH
2055: CALL 52054 0 3
2059: ST_TO_ADDR
// if Kapitsova then
2060: LD_EXP 45
2064: IFFALSE 2082
// tmp := tmp ^ Kapitsova ;
2066: LD_ADDR_VAR 0 5
2070: PUSH
2071: LD_VAR 0 5
2075: PUSH
2076: LD_EXP 45
2080: ADD
2081: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2082: LD_ADDR_EXP 46
2086: PUSH
2087: LD_STRING Lipshchin
2089: PPUSH
2090: LD_EXP 1
2094: NOT
2095: PPUSH
2096: LD_STRING 13a_
2098: PPUSH
2099: CALL 52054 0 3
2103: ST_TO_ADDR
// if Lipshchin then
2104: LD_EXP 46
2108: IFFALSE 2126
// tmp := tmp ^ Lipshchin ;
2110: LD_ADDR_VAR 0 5
2114: PUSH
2115: LD_VAR 0 5
2119: PUSH
2120: LD_EXP 46
2124: ADD
2125: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2126: LD_ADDR_EXP 47
2130: PUSH
2131: LD_STRING Petrovova
2133: PPUSH
2134: LD_EXP 1
2138: NOT
2139: PPUSH
2140: LD_STRING 13a_
2142: PPUSH
2143: CALL 52054 0 3
2147: ST_TO_ADDR
// if Petrovova then
2148: LD_EXP 47
2152: IFFALSE 2170
// tmp := tmp ^ Petrovova ;
2154: LD_ADDR_VAR 0 5
2158: PUSH
2159: LD_VAR 0 5
2163: PUSH
2164: LD_EXP 47
2168: ADD
2169: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2170: LD_ADDR_EXP 48
2174: PUSH
2175: LD_STRING Kovalyuk
2177: PPUSH
2178: LD_EXP 1
2182: NOT
2183: PPUSH
2184: LD_STRING 13a_
2186: PPUSH
2187: CALL 52054 0 3
2191: ST_TO_ADDR
// if Kovalyuk then
2192: LD_EXP 48
2196: IFFALSE 2214
// tmp := tmp ^ Kovalyuk ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_EXP 48
2212: ADD
2213: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2214: LD_ADDR_EXP 49
2218: PUSH
2219: LD_STRING Kuzmov
2221: PPUSH
2222: LD_EXP 1
2226: NOT
2227: PPUSH
2228: LD_STRING 13a_
2230: PPUSH
2231: CALL 52054 0 3
2235: ST_TO_ADDR
// if Kuzmov then
2236: LD_EXP 49
2240: IFFALSE 2258
// tmp := tmp ^ Kuzmov ;
2242: LD_ADDR_VAR 0 5
2246: PUSH
2247: LD_VAR 0 5
2251: PUSH
2252: LD_EXP 49
2256: ADD
2257: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 50
2262: PUSH
2263: LD_STRING Karamazov
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 52054 0 3
2279: ST_TO_ADDR
// if Karamazov then
2280: LD_EXP 50
2284: IFFALSE 2302
// tmp := tmp ^ Karamazov ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 50
2300: ADD
2301: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2302: LD_ADDR_EXP 52
2306: PUSH
2307: LD_STRING Belkov
2309: PPUSH
2310: LD_EXP 1
2314: NOT
2315: PPUSH
2316: LD_STRING 13a_
2318: PPUSH
2319: CALL 52054 0 3
2323: ST_TO_ADDR
// if Belkov then
2324: LD_EXP 52
2328: IFFALSE 2346
// tmp := tmp ^ Belkov ;
2330: LD_ADDR_VAR 0 5
2334: PUSH
2335: LD_VAR 0 5
2339: PUSH
2340: LD_EXP 52
2344: ADD
2345: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2346: LD_ADDR_EXP 53
2350: PUSH
2351: LD_STRING Gnyevko
2353: PPUSH
2354: LD_EXP 1
2358: NOT
2359: PPUSH
2360: LD_STRING 13a_
2362: PPUSH
2363: CALL 52054 0 3
2367: ST_TO_ADDR
// if Gnyevko then
2368: LD_EXP 53
2372: IFFALSE 2390
// tmp := tmp ^ Gnyevko ;
2374: LD_ADDR_VAR 0 5
2378: PUSH
2379: LD_VAR 0 5
2383: PUSH
2384: LD_EXP 53
2388: ADD
2389: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2390: LD_ADDR_EXP 36
2394: PUSH
2395: LD_STRING Coonie
2397: PPUSH
2398: CALL_OW 25
2402: ST_TO_ADDR
// if not Lisa then
2403: LD_EXP 21
2407: NOT
2408: IFFALSE 2454
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2410: LD_ADDR_EXP 21
2414: PUSH
2415: LD_STRING Lisa
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13a_
2426: PPUSH
2427: CALL 52054 0 3
2431: ST_TO_ADDR
// if Lisa then
2432: LD_EXP 21
2436: IFFALSE 2454
// tmp := tmp ^ Lisa ;
2438: LD_ADDR_VAR 0 5
2442: PUSH
2443: LD_VAR 0 5
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: ST_TO_ADDR
// end ; if not Donaldson then
2454: LD_EXP 22
2458: NOT
2459: IFFALSE 2505
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2461: LD_ADDR_EXP 22
2465: PUSH
2466: LD_STRING Donaldson
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13a_
2477: PPUSH
2478: CALL 52054 0 3
2482: ST_TO_ADDR
// if Donaldson then
2483: LD_EXP 22
2487: IFFALSE 2505
// tmp := tmp ^ Donaldson ;
2489: LD_ADDR_VAR 0 5
2493: PUSH
2494: LD_VAR 0 5
2498: PUSH
2499: LD_EXP 22
2503: ADD
2504: ST_TO_ADDR
// end ; if not Bobby then
2505: LD_EXP 23
2509: NOT
2510: IFFALSE 2556
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2512: LD_ADDR_EXP 23
2516: PUSH
2517: LD_STRING Bobby
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13a_
2528: PPUSH
2529: CALL 52054 0 3
2533: ST_TO_ADDR
// if Bobby then
2534: LD_EXP 23
2538: IFFALSE 2556
// tmp := tmp ^ Bobby ;
2540: LD_ADDR_VAR 0 5
2544: PUSH
2545: LD_VAR 0 5
2549: PUSH
2550: LD_EXP 23
2554: ADD
2555: ST_TO_ADDR
// end ; if not Cyrus then
2556: LD_EXP 24
2560: NOT
2561: IFFALSE 2607
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2563: LD_ADDR_EXP 24
2567: PUSH
2568: LD_STRING Cyrus
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13a_
2579: PPUSH
2580: CALL 52054 0 3
2584: ST_TO_ADDR
// if Cyrus then
2585: LD_EXP 24
2589: IFFALSE 2607
// tmp := tmp ^ Cyrus ;
2591: LD_ADDR_VAR 0 5
2595: PUSH
2596: LD_VAR 0 5
2600: PUSH
2601: LD_EXP 24
2605: ADD
2606: ST_TO_ADDR
// end ; if not Brown then
2607: LD_EXP 26
2611: NOT
2612: IFFALSE 2658
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2614: LD_ADDR_EXP 26
2618: PUSH
2619: LD_STRING Brown
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13a_
2630: PPUSH
2631: CALL 52054 0 3
2635: ST_TO_ADDR
// if Brown then
2636: LD_EXP 26
2640: IFFALSE 2658
// tmp := tmp ^ Brown ;
2642: LD_ADDR_VAR 0 5
2646: PUSH
2647: LD_VAR 0 5
2651: PUSH
2652: LD_EXP 26
2656: ADD
2657: ST_TO_ADDR
// end ; if not Gladstone then
2658: LD_EXP 27
2662: NOT
2663: IFFALSE 2709
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2665: LD_ADDR_EXP 27
2669: PUSH
2670: LD_STRING Gladstone
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13a_
2681: PPUSH
2682: CALL 52054 0 3
2686: ST_TO_ADDR
// if Gladstone then
2687: LD_EXP 27
2691: IFFALSE 2709
// tmp := tmp ^ Gladstone ;
2693: LD_ADDR_VAR 0 5
2697: PUSH
2698: LD_VAR 0 5
2702: PUSH
2703: LD_EXP 27
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 29
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2716: LD_ADDR_EXP 29
2720: PUSH
2721: LD_STRING Cornel
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13a_
2732: PPUSH
2733: CALL 52054 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 29
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 5
2748: PUSH
2749: LD_VAR 0 5
2753: PUSH
2754: LD_EXP 29
2758: ADD
2759: ST_TO_ADDR
// end ; if not Houten then
2760: LD_EXP 28
2764: NOT
2765: IFFALSE 2811
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2767: LD_ADDR_EXP 28
2771: PUSH
2772: LD_STRING Houten
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13a_
2783: PPUSH
2784: CALL 52054 0 3
2788: ST_TO_ADDR
// if Houten then
2789: LD_EXP 28
2793: IFFALSE 2811
// tmp := tmp ^ Houten ;
2795: LD_ADDR_VAR 0 5
2799: PUSH
2800: LD_VAR 0 5
2804: PUSH
2805: LD_EXP 28
2809: ADD
2810: ST_TO_ADDR
// end ; if not Gary then
2811: LD_EXP 30
2815: NOT
2816: IFFALSE 2862
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2818: LD_ADDR_EXP 30
2822: PUSH
2823: LD_STRING Gary
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13a_
2834: PPUSH
2835: CALL 52054 0 3
2839: ST_TO_ADDR
// if Gary then
2840: LD_EXP 30
2844: IFFALSE 2862
// tmp := tmp ^ Gary ;
2846: LD_ADDR_VAR 0 5
2850: PUSH
2851: LD_VAR 0 5
2855: PUSH
2856: LD_EXP 30
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 32
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2869: LD_ADDR_EXP 32
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13a_
2885: PPUSH
2886: CALL 52054 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 32
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 5
2901: PUSH
2902: LD_VAR 0 5
2906: PUSH
2907: LD_EXP 32
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2913: LD_ADDR_VAR 0 5
2917: PUSH
2918: LD_VAR 0 5
2922: PUSH
2923: LD_STRING 13a_others
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// tmp := tmp diff 0 ;
2932: LD_ADDR_VAR 0 5
2936: PUSH
2937: LD_VAR 0 5
2941: PUSH
2942: LD_INT 0
2944: DIFF
2945: ST_TO_ADDR
// if tmp < 15 then
2946: LD_VAR 0 5
2950: PUSH
2951: LD_INT 15
2953: LESS
2954: IFFALSE 3042
// for i = 15 downto tmp do
2956: LD_ADDR_VAR 0 2
2960: PUSH
2961: DOUBLE
2962: LD_INT 15
2964: INC
2965: ST_TO_ADDR
2966: LD_VAR 0 5
2970: PUSH
2971: FOR_DOWNTO
2972: IFFALSE 3040
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2974: LD_ADDR_OWVAR 21
2978: PUSH
2979: LD_INT 1
2981: PUSH
2982: LD_INT 3
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 1
2991: PPUSH
2992: LD_INT 2
2994: PPUSH
2995: CALL_OW 12
2999: ARRAY
3000: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3001: LD_INT 0
3003: PPUSH
3004: LD_INT 1
3006: PPUSH
3007: LD_INT 4
3009: PPUSH
3010: CALL_OW 12
3014: PPUSH
3015: LD_INT 8
3017: PPUSH
3018: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3022: LD_ADDR_VAR 0 5
3026: PUSH
3027: LD_VAR 0 5
3031: PUSH
3032: CALL_OW 44
3036: ADD
3037: ST_TO_ADDR
// end ;
3038: GO 2971
3040: POP
3041: POP
// if not debug then
3042: LD_EXP 1
3046: NOT
3047: IFFALSE 3227
// selected = CharacterSelection (  , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3049: LD_ADDR_VAR 0 4
3053: PUSH
3054: LD_STRING 
3056: PPUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 14
3062: PUSH
3063: LD_INT 13
3065: PUSH
3066: LD_INT 12
3068: PUSH
3069: EMPTY
3070: LIST
3071: LIST
3072: LIST
3073: LIST
3074: PUSH
3075: LD_OWVAR 67
3079: ARRAY
3080: PPUSH
3081: LD_INT 14
3083: PUSH
3084: LD_INT 14
3086: PUSH
3087: LD_INT 13
3089: PUSH
3090: LD_INT 12
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_OWVAR 67
3103: ARRAY
3104: PPUSH
3105: LD_INT -5
3107: PUSH
3108: LD_EXP 19
3112: PUSH
3113: LD_EXP 51
3117: PUSH
3118: LD_EXP 20
3122: PUSH
3123: LD_EXP 34
3127: PUSH
3128: LD_EXP 25
3132: PUSH
3133: LD_EXP 37
3137: PUSH
3138: LD_INT -2
3140: PUSH
3141: LD_INT -3
3143: PUSH
3144: LD_INT -5
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: PUSH
3159: LD_VAR 0 5
3163: ADD
3164: PPUSH
3165: LD_INT 1
3167: PUSH
3168: LD_INT 4
3170: PUSH
3171: LD_INT 2
3173: PUSH
3174: LD_INT 1
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 3
3183: PUSH
3184: LD_INT 5
3186: PUSH
3187: LD_INT 0
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: PUSH
3198: LD_INT 9
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PPUSH
3220: CALL_OW 42
3224: ST_TO_ADDR
3225: GO 3276
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3227: LD_ADDR_VAR 0 4
3231: PUSH
3232: LD_EXP 39
3236: PUSH
3237: LD_EXP 40
3241: PUSH
3242: LD_EXP 41
3246: PUSH
3247: LD_EXP 42
3251: PUSH
3252: LD_EXP 43
3256: PUSH
3257: LD_EXP 44
3261: PUSH
3262: LD_EXP 45
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: LIST
3275: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3276: LD_ADDR_EXP 17
3280: PUSH
3281: LD_VAR 0 5
3285: PUSH
3286: LD_VAR 0 4
3290: DIFF
3291: ST_TO_ADDR
// uc_nation := 1 ;
3292: LD_ADDR_OWVAR 21
3296: PUSH
3297: LD_INT 1
3299: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3300: LD_INT 5
3302: PPUSH
3303: LD_INT 3
3305: PPUSH
3306: LD_INT 1
3308: PPUSH
3309: LD_INT 6
3311: PPUSH
3312: LD_INT 100
3314: PPUSH
3315: CALL 57071 0 5
// veh := CreateVehicle ;
3319: LD_ADDR_VAR 0 3
3323: PUSH
3324: CALL_OW 45
3328: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3329: LD_VAR 0 3
3333: PPUSH
3334: LD_INT 7
3336: NEG
3337: PPUSH
3338: CALL_OW 242
// SetDir ( veh , 3 ) ;
3342: LD_VAR 0 3
3346: PPUSH
3347: LD_INT 3
3349: PPUSH
3350: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3354: LD_VAR 0 3
3358: PPUSH
3359: LD_INT 31
3361: PPUSH
3362: LD_INT 0
3364: PPUSH
3365: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3369: LD_EXP 19
3373: PPUSH
3374: LD_VAR 0 3
3378: PPUSH
3379: CALL_OW 52
// if Joan then
3383: LD_EXP 34
3387: IFFALSE 3459
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3389: LD_INT 3
3391: PPUSH
3392: LD_INT 3
3394: PPUSH
3395: LD_INT 1
3397: PPUSH
3398: LD_INT 11
3400: PPUSH
3401: LD_INT 100
3403: PPUSH
3404: CALL 57071 0 5
// veh := CreateVehicle ;
3408: LD_ADDR_VAR 0 3
3412: PUSH
3413: CALL_OW 45
3417: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3418: LD_VAR 0 3
3422: PPUSH
3423: LD_INT 3
3425: PPUSH
3426: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3430: LD_VAR 0 3
3434: PPUSH
3435: LD_INT 30
3437: PPUSH
3438: LD_INT 0
3440: PPUSH
3441: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3445: LD_EXP 34
3449: PPUSH
3450: LD_VAR 0 3
3454: PPUSH
3455: CALL_OW 52
// end ; if Roth then
3459: LD_EXP 20
3463: IFFALSE 3535
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3465: LD_INT 3
3467: PPUSH
3468: LD_INT 3
3470: PPUSH
3471: LD_INT 1
3473: PPUSH
3474: LD_INT 11
3476: PPUSH
3477: LD_INT 100
3479: PPUSH
3480: CALL 57071 0 5
// veh := CreateVehicle ;
3484: LD_ADDR_VAR 0 3
3488: PUSH
3489: CALL_OW 45
3493: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3494: LD_VAR 0 3
3498: PPUSH
3499: LD_INT 3
3501: PPUSH
3502: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 30
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3521: LD_EXP 20
3525: PPUSH
3526: LD_VAR 0 3
3530: PPUSH
3531: CALL_OW 52
// end ; if Denis then
3535: LD_EXP 25
3539: IFFALSE 3611
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3541: LD_INT 5
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: LD_INT 1
3549: PPUSH
3550: LD_INT 9
3552: PPUSH
3553: LD_INT 100
3555: PPUSH
3556: CALL 57071 0 5
// veh := CreateVehicle ;
3560: LD_ADDR_VAR 0 3
3564: PUSH
3565: CALL_OW 45
3569: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3570: LD_VAR 0 3
3574: PPUSH
3575: LD_INT 3
3577: PPUSH
3578: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3582: LD_VAR 0 3
3586: PPUSH
3587: LD_INT 30
3589: PPUSH
3590: LD_INT 0
3592: PPUSH
3593: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3597: LD_EXP 25
3601: PPUSH
3602: LD_VAR 0 3
3606: PPUSH
3607: CALL_OW 52
// end ; uc_nation := 3 ;
3611: LD_ADDR_OWVAR 21
3615: PUSH
3616: LD_INT 3
3618: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3619: LD_INT 22
3621: PPUSH
3622: LD_INT 3
3624: PPUSH
3625: LD_INT 1
3627: PPUSH
3628: LD_INT 45
3630: PPUSH
3631: LD_INT 100
3633: PPUSH
3634: CALL 57071 0 5
// veh := CreateVehicle ;
3638: LD_ADDR_VAR 0 3
3642: PUSH
3643: CALL_OW 45
3647: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3648: LD_VAR 0 3
3652: PPUSH
3653: LD_INT 7
3655: NEG
3656: PPUSH
3657: CALL_OW 242
// SetDir ( veh , 3 ) ;
3661: LD_VAR 0 3
3665: PPUSH
3666: LD_INT 3
3668: PPUSH
3669: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3673: LD_VAR 0 3
3677: PPUSH
3678: LD_INT 31
3680: PPUSH
3681: LD_INT 0
3683: PPUSH
3684: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3688: LD_EXP 51
3692: PPUSH
3693: LD_VAR 0 3
3697: PPUSH
3698: CALL_OW 52
// if Gossudarov then
3702: LD_EXP 37
3706: IFFALSE 3793
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3708: LD_INT 22
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 51
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 57071 0 5
// veh := CreateVehicle ;
3727: LD_ADDR_VAR 0 3
3731: PUSH
3732: CALL_OW 45
3736: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3737: LD_VAR 0 3
3741: PPUSH
3742: LD_INT 3
3744: PPUSH
3745: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3749: LD_VAR 0 3
3753: PPUSH
3754: LD_INT 30
3756: PPUSH
3757: LD_INT 0
3759: PPUSH
3760: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3764: LD_EXP 37
3768: PPUSH
3769: LD_VAR 0 3
3773: PPUSH
3774: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3778: LD_VAR 0 3
3782: PPUSH
3783: LD_INT 1
3785: PPUSH
3786: LD_INT 100
3788: PPUSH
3789: CALL_OW 290
// end ; for i in selected do
3793: LD_ADDR_VAR 0 2
3797: PUSH
3798: LD_VAR 0 4
3802: PUSH
3803: FOR_IN
3804: IFFALSE 4362
// begin uc_nation := GetNation ( i ) ;
3806: LD_ADDR_OWVAR 21
3810: PUSH
3811: LD_VAR 0 2
3815: PPUSH
3816: CALL_OW 248
3820: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3821: LD_VAR 0 2
3825: PUSH
3826: LD_EXP 21
3830: PUSH
3831: LD_EXP 22
3835: PUSH
3836: LD_EXP 24
3840: PUSH
3841: LD_EXP 23
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: LIST
3851: IN
3852: IFFALSE 3875
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3854: LD_INT 5
3856: PPUSH
3857: LD_INT 3
3859: PPUSH
3860: LD_INT 1
3862: PPUSH
3863: LD_INT 6
3865: PPUSH
3866: LD_INT 100
3868: PPUSH
3869: CALL 57071 0 5
3873: GO 4309
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3875: LD_VAR 0 2
3879: PUSH
3880: LD_EXP 44
3884: PUSH
3885: LD_EXP 49
3889: PUSH
3890: LD_EXP 47
3894: PUSH
3895: LD_EXP 39
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: LIST
3904: LIST
3905: IN
3906: IFFALSE 3937
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3908: LD_INT 24
3910: PPUSH
3911: LD_INT 1
3913: PPUSH
3914: LD_INT 1
3916: PPUSH
3917: LD_INT 46
3919: PPUSH
3920: LD_INT 65
3922: PPUSH
3923: LD_INT 75
3925: PPUSH
3926: CALL_OW 12
3930: PPUSH
3931: CALL 57071 0 5
3935: GO 4309
// if i = Karamazov then
3937: LD_VAR 0 2
3941: PUSH
3942: LD_EXP 50
3946: EQUAL
3947: IFFALSE 3970
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3949: LD_INT 22
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 52
3960: PPUSH
3961: LD_INT 100
3963: PPUSH
3964: CALL 57071 0 5
3968: GO 4309
// if i = Brown then
3970: LD_VAR 0 2
3974: PUSH
3975: LD_EXP 26
3979: EQUAL
3980: IFFALSE 4003
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3982: LD_INT 3
3984: PPUSH
3985: LD_INT 3
3987: PPUSH
3988: LD_INT 1
3990: PPUSH
3991: LD_INT 13
3993: PPUSH
3994: LD_INT 100
3996: PPUSH
3997: CALL 57071 0 5
4001: GO 4309
// if uc_nation = nation_american then
4003: LD_OWVAR 21
4007: PUSH
4008: LD_INT 1
4010: EQUAL
4011: IFFALSE 4162
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4013: LD_INT 3
4015: PUSH
4016: LD_INT 5
4018: PUSH
4019: LD_INT 5
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: PUSH
4027: LD_OWVAR 21
4031: PUSH
4032: LD_INT 3
4034: MOD
4035: PUSH
4036: LD_INT 1
4038: PLUS
4039: ARRAY
4040: PPUSH
4041: LD_INT 1
4043: PUSH
4044: LD_INT 3
4046: PUSH
4047: LD_INT 1
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: LIST
4054: PUSH
4055: LD_OWVAR 21
4059: PUSH
4060: LD_INT 3
4062: MOD
4063: PUSH
4064: LD_INT 1
4066: PLUS
4067: ARRAY
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_INT 11
4074: PUSH
4075: LD_INT 4
4077: PUSH
4078: LD_INT 5
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 6
4088: PUSH
4089: LD_INT 7
4091: PUSH
4092: LD_INT 9
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 6
4102: PUSH
4103: LD_INT 9
4105: PUSH
4106: LD_INT 12
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: PUSH
4119: LD_OWVAR 21
4123: PUSH
4124: LD_INT 3
4126: MOD
4127: PUSH
4128: LD_INT 1
4130: PLUS
4131: ARRAY
4132: PUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_INT 3
4138: PPUSH
4139: CALL_OW 12
4143: ARRAY
4144: PPUSH
4145: LD_INT 65
4147: PPUSH
4148: LD_INT 75
4150: PPUSH
4151: CALL_OW 12
4155: PPUSH
4156: CALL 57071 0 5
// end else
4160: GO 4309
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4162: LD_INT 22
4164: PUSH
4165: LD_INT 23
4167: PUSH
4168: LD_INT 23
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: PUSH
4176: LD_OWVAR 21
4180: PUSH
4181: LD_INT 3
4183: MOD
4184: PUSH
4185: LD_INT 1
4187: PLUS
4188: ARRAY
4189: PPUSH
4190: LD_INT 1
4192: PUSH
4193: LD_INT 3
4195: PUSH
4196: LD_INT 1
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: PUSH
4204: LD_OWVAR 21
4208: PUSH
4209: LD_INT 3
4211: MOD
4212: PUSH
4213: LD_INT 1
4215: PLUS
4216: ARRAY
4217: PPUSH
4218: LD_INT 1
4220: PPUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 43
4226: PUSH
4227: LD_INT 44
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: PUSH
4235: LD_INT 46
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: LD_INT 44
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 46
4251: PUSH
4252: LD_INT 43
4254: PUSH
4255: LD_INT 45
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: LIST
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_OWVAR 21
4272: PUSH
4273: LD_INT 3
4275: MOD
4276: PUSH
4277: LD_INT 1
4279: PLUS
4280: ARRAY
4281: PUSH
4282: LD_INT 1
4284: PPUSH
4285: LD_INT 3
4287: PPUSH
4288: CALL_OW 12
4292: ARRAY
4293: PPUSH
4294: LD_INT 65
4296: PPUSH
4297: LD_INT 75
4299: PPUSH
4300: CALL_OW 12
4304: PPUSH
4305: CALL 57071 0 5
// end ; veh := CreateVehicle ;
4309: LD_ADDR_VAR 0 3
4313: PUSH
4314: CALL_OW 45
4318: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4319: LD_VAR 0 3
4323: PPUSH
4324: LD_INT 3
4326: PPUSH
4327: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4331: LD_VAR 0 3
4335: PPUSH
4336: LD_INT 30
4338: PPUSH
4339: LD_INT 0
4341: PPUSH
4342: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4346: LD_VAR 0 2
4350: PPUSH
4351: LD_VAR 0 3
4355: PPUSH
4356: CALL_OW 52
// end ;
4360: GO 3803
4362: POP
4363: POP
// if artifactArCaptured then
4364: LD_EXP 9
4368: IFFALSE 4454
// begin uc_nation := nation_american ;
4370: LD_ADDR_OWVAR 21
4374: PUSH
4375: LD_INT 1
4377: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4378: LD_INT 3
4380: PPUSH
4381: LD_INT 3
4383: PPUSH
4384: LD_INT 3
4386: PPUSH
4387: LD_INT 12
4389: PPUSH
4390: LD_INT 100
4392: PPUSH
4393: CALL 57071 0 5
// veh := CreateVehicle ;
4397: LD_ADDR_VAR 0 3
4401: PUSH
4402: CALL_OW 45
4406: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4407: LD_VAR 0 3
4411: PPUSH
4412: LD_INT 3
4414: PPUSH
4415: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4419: LD_VAR 0 3
4423: PPUSH
4424: LD_INT 198
4426: PPUSH
4427: LD_INT 22
4429: PPUSH
4430: LD_INT 0
4432: PPUSH
4433: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4437: LD_VAR 0 3
4441: PPUSH
4442: LD_INT 4
4444: PPUSH
4445: LD_INT 50
4447: PPUSH
4448: CALL_OW 290
// end else
4452: GO 4473
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4454: LD_INT 4
4456: PPUSH
4457: LD_INT 5
4459: PPUSH
4460: LD_INT 267
4462: PPUSH
4463: LD_INT 226
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 58
// end ; uc_nation := nation_american ;
4473: LD_ADDR_OWVAR 21
4477: PUSH
4478: LD_INT 1
4480: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4481: LD_INT 3
4483: PPUSH
4484: LD_INT 3
4486: PPUSH
4487: LD_INT 3
4489: PPUSH
4490: LD_INT 12
4492: PPUSH
4493: LD_INT 100
4495: PPUSH
4496: CALL 57071 0 5
// veh := CreateVehicle ;
4500: LD_ADDR_VAR 0 3
4504: PUSH
4505: CALL_OW 45
4509: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4510: LD_VAR 0 3
4514: PPUSH
4515: LD_INT 3
4517: PPUSH
4518: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4522: LD_VAR 0 3
4526: PPUSH
4527: LD_INT 218
4529: PPUSH
4530: LD_INT 23
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4540: LD_VAR 0 3
4544: PPUSH
4545: LD_INT 4
4547: PPUSH
4548: LD_INT 30
4550: PPUSH
4551: CALL_OW 290
// uc_nation := nation_russian ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 3
4562: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4563: LD_INT 22
4565: PPUSH
4566: LD_INT 3
4568: PPUSH
4569: LD_INT 3
4571: PPUSH
4572: LD_INT 51
4574: PPUSH
4575: LD_INT 100
4577: PPUSH
4578: CALL 57071 0 5
// veh := CreateVehicle ;
4582: LD_ADDR_VAR 0 3
4586: PUSH
4587: CALL_OW 45
4591: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4592: LD_VAR 0 3
4596: PPUSH
4597: LD_INT 3
4599: PPUSH
4600: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4604: LD_VAR 0 3
4608: PPUSH
4609: LD_INT 214
4611: PPUSH
4612: LD_INT 20
4614: PPUSH
4615: LD_INT 0
4617: PPUSH
4618: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4622: LD_VAR 0 3
4626: PPUSH
4627: LD_INT 4
4629: PPUSH
4630: LD_INT 40
4632: PPUSH
4633: CALL_OW 290
// end ;
4637: LD_VAR 0 1
4641: RET
// export function AllianceSupport ; var i , veh ; begin
4642: LD_INT 0
4644: PPUSH
4645: PPUSH
4646: PPUSH
// if not allianceTeam then
4647: LD_EXP 17
4651: NOT
4652: IFFALSE 4656
// exit ;
4654: GO 5062
// for i := 1 to 6 do
4656: LD_ADDR_VAR 0 2
4660: PUSH
4661: DOUBLE
4662: LD_INT 1
4664: DEC
4665: ST_TO_ADDR
4666: LD_INT 6
4668: PUSH
4669: FOR_TO
4670: IFFALSE 4966
// begin uc_side := 7 ;
4672: LD_ADDR_OWVAR 20
4676: PUSH
4677: LD_INT 7
4679: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4680: LD_ADDR_OWVAR 21
4684: PUSH
4685: LD_INT 1
4687: PUSH
4688: LD_INT 3
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PUSH
4695: LD_VAR 0 2
4699: PUSH
4700: LD_INT 2
4702: MOD
4703: PUSH
4704: LD_INT 1
4706: PLUS
4707: ARRAY
4708: ST_TO_ADDR
// if uc_nation = 1 then
4709: LD_OWVAR 21
4713: PUSH
4714: LD_INT 1
4716: EQUAL
4717: IFFALSE 4759
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4719: LD_INT 5
4721: PPUSH
4722: LD_INT 3
4724: PPUSH
4725: LD_INT 1
4727: PPUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 7
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: LD_INT 1
4740: PPUSH
4741: LD_INT 2
4743: PPUSH
4744: CALL_OW 12
4748: ARRAY
4749: PPUSH
4750: LD_INT 100
4752: PPUSH
4753: CALL 57071 0 5
4757: GO 4797
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4759: LD_INT 23
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 1
4767: PPUSH
4768: LD_INT 46
4770: PUSH
4771: LD_INT 47
4773: PUSH
4774: EMPTY
4775: LIST
4776: LIST
4777: PUSH
4778: LD_INT 1
4780: PPUSH
4781: LD_INT 2
4783: PPUSH
4784: CALL_OW 12
4788: ARRAY
4789: PPUSH
4790: LD_INT 100
4792: PPUSH
4793: CALL 57071 0 5
// if not allianceTeam then
4797: LD_EXP 17
4801: NOT
4802: IFFALSE 4806
// break ;
4804: GO 4966
// veh := CreateVehicle ;
4806: LD_ADDR_VAR 0 3
4810: PUSH
4811: CALL_OW 45
4815: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4816: LD_VAR 0 3
4820: PPUSH
4821: LD_INT 4
4823: PPUSH
4824: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4828: LD_VAR 0 3
4832: PPUSH
4833: LD_INT 38
4835: PPUSH
4836: LD_INT 0
4838: PPUSH
4839: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4843: LD_EXP 17
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 3
4854: PPUSH
4855: CALL_OW 259
4859: PUSH
4860: LD_INT 4
4862: GREATER
4863: IFFALSE 4881
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4865: LD_EXP 17
4869: PUSH
4870: LD_INT 1
4872: ARRAY
4873: PPUSH
4874: LD_INT 3
4876: PPUSH
4877: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4881: LD_EXP 17
4885: PUSH
4886: LD_INT 1
4888: ARRAY
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 259
4897: PUSH
4898: LD_INT 8
4900: GREATER
4901: IFFALSE 4919
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4903: LD_EXP 17
4907: PUSH
4908: LD_INT 1
4910: ARRAY
4911: PPUSH
4912: LD_INT 4
4914: PPUSH
4915: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4919: LD_EXP 17
4923: PUSH
4924: LD_INT 1
4926: ARRAY
4927: PPUSH
4928: LD_VAR 0 3
4932: PPUSH
4933: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4937: LD_ADDR_EXP 17
4941: PUSH
4942: LD_EXP 17
4946: PPUSH
4947: LD_INT 1
4949: PPUSH
4950: CALL_OW 3
4954: ST_TO_ADDR
// ComHold ( veh ) ;
4955: LD_VAR 0 3
4959: PPUSH
4960: CALL_OW 140
// end ;
4964: GO 4669
4966: POP
4967: POP
// uc_side := 7 ;
4968: LD_ADDR_OWVAR 20
4972: PUSH
4973: LD_INT 7
4975: ST_TO_ADDR
// uc_nation := 1 ;
4976: LD_ADDR_OWVAR 21
4980: PUSH
4981: LD_INT 1
4983: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
4984: LD_INT 5
4986: PPUSH
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 3
4992: PPUSH
4993: LD_INT 11
4995: PPUSH
4996: LD_INT 100
4998: PPUSH
4999: CALL 57071 0 5
// veh := CreateVehicle ;
5003: LD_ADDR_VAR 0 3
5007: PUSH
5008: CALL_OW 45
5012: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5013: LD_VAR 0 3
5017: PPUSH
5018: LD_INT 4
5020: PPUSH
5021: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5025: LD_VAR 0 3
5029: PPUSH
5030: LD_INT 305
5032: PPUSH
5033: LD_INT 218
5035: PPUSH
5036: LD_INT 0
5038: PPUSH
5039: CALL_OW 48
// ComHold ( veh ) ;
5043: LD_VAR 0 3
5047: PPUSH
5048: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5052: LD_INT 313
5054: PPUSH
5055: LD_INT 220
5057: PPUSH
5058: CALL_OW 86
// end ; end_of_file
5062: LD_VAR 0 1
5066: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5067: LD_INT 0
5069: PPUSH
5070: PPUSH
5071: PPUSH
5072: PPUSH
5073: PPUSH
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
// InitHc ;
5079: CALL_OW 19
// uc_side := 1 ;
5083: LD_ADDR_OWVAR 20
5087: PUSH
5088: LD_INT 1
5090: ST_TO_ADDR
// uc_nation := 1 ;
5091: LD_ADDR_OWVAR 21
5095: PUSH
5096: LD_INT 1
5098: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5099: LD_ADDR_VAR 0 2
5103: PUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 1
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: LD_INT 3
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: FOR_IN
5134: IFFALSE 5150
// SetBLevel ( i , 10 ) ;
5136: LD_VAR 0 2
5140: PPUSH
5141: LD_INT 10
5143: PPUSH
5144: CALL_OW 241
5148: GO 5133
5150: POP
5151: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5152: LD_INT 387
5154: PPUSH
5155: CALL_OW 274
5159: PPUSH
5160: LD_INT 1
5162: PPUSH
5163: LD_INT 7500
5165: PPUSH
5166: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5170: LD_INT 387
5172: PPUSH
5173: CALL_OW 274
5177: PPUSH
5178: LD_INT 2
5180: PPUSH
5181: LD_INT 4000
5183: PPUSH
5184: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5188: LD_INT 387
5190: PPUSH
5191: CALL_OW 274
5195: PPUSH
5196: LD_INT 3
5198: PPUSH
5199: LD_INT 50
5201: PPUSH
5202: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5206: LD_INT 476
5208: PPUSH
5209: CALL_OW 274
5213: PPUSH
5214: LD_INT 1
5216: PPUSH
5217: LD_INT 5500
5219: PPUSH
5220: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5224: LD_INT 476
5226: PPUSH
5227: CALL_OW 274
5231: PPUSH
5232: LD_INT 2
5234: PPUSH
5235: LD_INT 4000
5237: PPUSH
5238: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5242: LD_INT 476
5244: PPUSH
5245: CALL_OW 274
5249: PPUSH
5250: LD_INT 3
5252: PPUSH
5253: LD_INT 10
5255: PPUSH
5256: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5260: LD_ADDR_EXP 54
5264: PUSH
5265: LD_STRING Powell
5267: PPUSH
5268: CALL_OW 25
5272: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5273: LD_EXP 54
5277: PPUSH
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 52
// tmp := [ ] ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: EMPTY
5291: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5292: LD_ADDR_EXP 21
5296: PUSH
5297: LD_STRING Lisa
5299: PPUSH
5300: LD_EXP 1
5304: NOT
5305: PPUSH
5306: LD_STRING 12p_
5308: PPUSH
5309: CALL 52054 0 3
5313: ST_TO_ADDR
// if Lisa then
5314: LD_EXP 21
5318: IFFALSE 5336
// tmp := tmp ^ Lisa ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: LD_VAR 0 6
5329: PUSH
5330: LD_EXP 21
5334: ADD
5335: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5336: LD_ADDR_EXP 22
5340: PUSH
5341: LD_STRING Donaldson
5343: PPUSH
5344: LD_EXP 1
5348: NOT
5349: PPUSH
5350: LD_STRING 12p_
5352: PPUSH
5353: CALL 52054 0 3
5357: ST_TO_ADDR
// if Donaldson then
5358: LD_EXP 22
5362: IFFALSE 5380
// tmp := tmp ^ Donaldson ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: LD_EXP 22
5378: ADD
5379: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5380: LD_ADDR_EXP 23
5384: PUSH
5385: LD_STRING Bobby
5387: PPUSH
5388: LD_EXP 1
5392: NOT
5393: PPUSH
5394: LD_STRING 12p_
5396: PPUSH
5397: CALL 52054 0 3
5401: ST_TO_ADDR
// if Bobby then
5402: LD_EXP 23
5406: IFFALSE 5424
// tmp := tmp ^ Bobby ;
5408: LD_ADDR_VAR 0 6
5412: PUSH
5413: LD_VAR 0 6
5417: PUSH
5418: LD_EXP 23
5422: ADD
5423: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5424: LD_ADDR_EXP 24
5428: PUSH
5429: LD_STRING Cyrus
5431: PPUSH
5432: LD_EXP 1
5436: NOT
5437: PPUSH
5438: LD_STRING 12p_
5440: PPUSH
5441: CALL 52054 0 3
5445: ST_TO_ADDR
// if Cyrus then
5446: LD_EXP 24
5450: IFFALSE 5468
// tmp := tmp ^ Cyrus ;
5452: LD_ADDR_VAR 0 6
5456: PUSH
5457: LD_VAR 0 6
5461: PUSH
5462: LD_EXP 24
5466: ADD
5467: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5468: LD_ADDR_EXP 26
5472: PUSH
5473: LD_STRING Brown
5475: PPUSH
5476: LD_EXP 1
5480: NOT
5481: PPUSH
5482: LD_STRING 12p_
5484: PPUSH
5485: CALL 52054 0 3
5489: ST_TO_ADDR
// if Brown then
5490: LD_EXP 26
5494: IFFALSE 5512
// tmp := tmp ^ Brown ;
5496: LD_ADDR_VAR 0 6
5500: PUSH
5501: LD_VAR 0 6
5505: PUSH
5506: LD_EXP 26
5510: ADD
5511: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5512: LD_ADDR_EXP 27
5516: PUSH
5517: LD_STRING Gladstone
5519: PPUSH
5520: LD_EXP 1
5524: NOT
5525: PPUSH
5526: LD_STRING 12p_
5528: PPUSH
5529: CALL 52054 0 3
5533: ST_TO_ADDR
// if Gladstone then
5534: LD_EXP 27
5538: IFFALSE 5556
// tmp := tmp ^ Gladstone ;
5540: LD_ADDR_VAR 0 6
5544: PUSH
5545: LD_VAR 0 6
5549: PUSH
5550: LD_EXP 27
5554: ADD
5555: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5556: LD_ADDR_EXP 28
5560: PUSH
5561: LD_STRING Houten
5563: PPUSH
5564: LD_EXP 1
5568: NOT
5569: PPUSH
5570: LD_STRING 12p_
5572: PPUSH
5573: CALL 52054 0 3
5577: ST_TO_ADDR
// if Houten then
5578: LD_EXP 28
5582: IFFALSE 5600
// tmp := tmp ^ Houten ;
5584: LD_ADDR_VAR 0 6
5588: PUSH
5589: LD_VAR 0 6
5593: PUSH
5594: LD_EXP 28
5598: ADD
5599: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5600: LD_ADDR_EXP 29
5604: PUSH
5605: LD_STRING Cornel
5607: PPUSH
5608: LD_EXP 1
5612: NOT
5613: PPUSH
5614: LD_STRING 12p_
5616: PPUSH
5617: CALL 52054 0 3
5621: ST_TO_ADDR
// if Cornel then
5622: LD_EXP 29
5626: IFFALSE 5644
// tmp := tmp ^ Cornel ;
5628: LD_ADDR_VAR 0 6
5632: PUSH
5633: LD_VAR 0 6
5637: PUSH
5638: LD_EXP 29
5642: ADD
5643: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5644: LD_ADDR_EXP 30
5648: PUSH
5649: LD_STRING Gary
5651: PPUSH
5652: LD_EXP 1
5656: NOT
5657: PPUSH
5658: LD_STRING 12p_
5660: PPUSH
5661: CALL 52054 0 3
5665: ST_TO_ADDR
// if Gary then
5666: LD_EXP 30
5670: IFFALSE 5688
// tmp := tmp ^ Gary ;
5672: LD_ADDR_VAR 0 6
5676: PUSH
5677: LD_VAR 0 6
5681: PUSH
5682: LD_EXP 30
5686: ADD
5687: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5688: LD_ADDR_EXP 32
5692: PUSH
5693: LD_STRING Kikuchi
5695: PPUSH
5696: LD_EXP 1
5700: NOT
5701: PPUSH
5702: LD_STRING 12p_
5704: PPUSH
5705: CALL 52054 0 3
5709: ST_TO_ADDR
// if Kikuchi then
5710: LD_EXP 32
5714: IFFALSE 5732
// tmp := tmp ^ Kikuchi ;
5716: LD_ADDR_VAR 0 6
5720: PUSH
5721: LD_VAR 0 6
5725: PUSH
5726: LD_EXP 32
5730: ADD
5731: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5732: LD_ADDR_VAR 0 6
5736: PUSH
5737: LD_VAR 0 6
5741: PUSH
5742: LD_STRING 12p_others
5744: PPUSH
5745: CALL_OW 31
5749: UNION
5750: ST_TO_ADDR
// if tmp < 36 then
5751: LD_VAR 0 6
5755: PUSH
5756: LD_INT 36
5758: LESS
5759: IFFALSE 5826
// for i = 1 to 36 - tmp do
5761: LD_ADDR_VAR 0 2
5765: PUSH
5766: DOUBLE
5767: LD_INT 1
5769: DEC
5770: ST_TO_ADDR
5771: LD_INT 36
5773: PUSH
5774: LD_VAR 0 6
5778: MINUS
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5824
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5783: LD_INT 1
5785: PPUSH
5786: LD_VAR 0 2
5790: PUSH
5791: LD_INT 4
5793: MOD
5794: PUSH
5795: LD_INT 1
5797: PLUS
5798: PPUSH
5799: LD_INT 10
5801: PPUSH
5802: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5806: LD_ADDR_VAR 0 6
5810: PUSH
5811: LD_VAR 0 6
5815: PUSH
5816: CALL_OW 44
5820: ADD
5821: ST_TO_ADDR
// end ;
5822: GO 5780
5824: POP
5825: POP
// for i in tmp do
5826: LD_ADDR_VAR 0 2
5830: PUSH
5831: LD_VAR 0 6
5835: PUSH
5836: FOR_IN
5837: IFFALSE 5862
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5839: LD_VAR 0 2
5843: PPUSH
5844: LD_INT 62
5846: PPUSH
5847: LD_INT 93
5849: PPUSH
5850: LD_INT 9
5852: PPUSH
5853: LD_INT 0
5855: PPUSH
5856: CALL_OW 50
5860: GO 5836
5862: POP
5863: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5864: LD_ADDR_EXP 96
5868: PUSH
5869: LD_EXP 96
5873: PPUSH
5874: LD_INT 4
5876: PPUSH
5877: LD_INT 22
5879: PUSH
5880: LD_INT 1
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: PPUSH
5887: CALL_OW 69
5891: PUSH
5892: LD_EXP 54
5896: DIFF
5897: PPUSH
5898: CALL_OW 1
5902: ST_TO_ADDR
// uc_side := 0 ;
5903: LD_ADDR_OWVAR 20
5907: PUSH
5908: LD_INT 0
5910: ST_TO_ADDR
// uc_nation := 0 ;
5911: LD_ADDR_OWVAR 21
5915: PUSH
5916: LD_INT 0
5918: ST_TO_ADDR
// for i = 1 to 4 do
5919: LD_ADDR_VAR 0 2
5923: PUSH
5924: DOUBLE
5925: LD_INT 1
5927: DEC
5928: ST_TO_ADDR
5929: LD_INT 4
5931: PUSH
5932: FOR_TO
5933: IFFALSE 5964
// begin InitHc ;
5935: CALL_OW 19
// hc_class := class_apeman ;
5939: LD_ADDR_OWVAR 28
5943: PUSH
5944: LD_INT 12
5946: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5947: CALL_OW 44
5951: PPUSH
5952: LD_INT 11
5954: PPUSH
5955: LD_INT 0
5957: PPUSH
5958: CALL_OW 49
// end ;
5962: GO 5932
5964: POP
5965: POP
// end ;
5966: LD_VAR 0 1
5970: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5971: LD_EXP 4
5975: NOT
5976: PUSH
5977: LD_INT 4
5979: PPUSH
5980: LD_INT 1
5982: PPUSH
5983: CALL 47066 0 2
5987: NOT
5988: AND
5989: IFFALSE 6761
5991: GO 5993
5993: DISABLE
5994: LD_INT 0
5996: PPUSH
5997: PPUSH
5998: PPUSH
// begin enable ;
5999: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6000: LD_INT 22
6002: PUSH
6003: LD_INT 1
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PUSH
6010: LD_INT 23
6012: PUSH
6013: LD_INT 1
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: PUSH
6020: LD_INT 30
6022: PUSH
6023: LD_INT 3
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: LIST
6034: PPUSH
6035: CALL_OW 69
6039: NOT
6040: IFFALSE 6044
// exit ;
6042: GO 6761
// if Prob ( 40 ) then
6044: LD_INT 40
6046: PPUSH
6047: CALL_OW 13
6051: IFFALSE 6178
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6053: LD_INT 4
6055: PPUSH
6056: LD_INT 5
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: LD_INT 2
6064: PUSH
6065: LD_INT 7
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: PUSH
6074: LD_INT 5
6076: PUSH
6077: LD_INT 1
6079: PUSH
6080: LD_INT 2
6082: PUSH
6083: LD_INT 7
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 5
6094: PUSH
6095: LD_INT 1
6097: PUSH
6098: LD_INT 2
6100: PUSH
6101: LD_INT 7
6103: PUSH
6104: EMPTY
6105: LIST
6106: LIST
6107: LIST
6108: LIST
6109: PUSH
6110: LD_INT 5
6112: PUSH
6113: LD_INT 1
6115: PUSH
6116: LD_INT 2
6118: PUSH
6119: LD_INT 6
6121: PUSH
6122: EMPTY
6123: LIST
6124: LIST
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 5
6130: PUSH
6131: LD_INT 1
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: LD_INT 6
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: LIST
6144: LIST
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: LD_INT 1
6151: PUSH
6152: LD_INT 2
6154: PUSH
6155: LD_INT 6
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: LIST
6169: LIST
6170: LIST
6171: PPUSH
6172: CALL 45648 0 2
// end else
6176: GO 6301
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6178: LD_INT 4
6180: PPUSH
6181: LD_INT 5
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 7
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: LIST
6198: PUSH
6199: LD_INT 5
6201: PUSH
6202: LD_INT 1
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 9
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: LIST
6215: LIST
6216: PUSH
6217: LD_INT 5
6219: PUSH
6220: LD_INT 1
6222: PUSH
6223: LD_INT 2
6225: PUSH
6226: LD_INT 9
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 5
6237: PUSH
6238: LD_INT 1
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: LD_INT 6
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: LIST
6251: LIST
6252: PUSH
6253: LD_INT 5
6255: PUSH
6256: LD_INT 1
6258: PUSH
6259: LD_INT 2
6261: PUSH
6262: LD_INT 6
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: PUSH
6271: LD_INT 5
6273: PUSH
6274: LD_INT 1
6276: PUSH
6277: LD_INT 2
6279: PUSH
6280: LD_INT 6
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL 45648 0 2
// end ; repeat wait ( 0 0$1 ) ;
6301: LD_INT 35
6303: PPUSH
6304: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6308: LD_INT 4
6310: PPUSH
6311: LD_INT 1
6313: PPUSH
6314: CALL 47066 0 2
6318: PUSH
6319: LD_INT 6
6321: GREATEREQUAL
6322: IFFALSE 6301
// wait ( 0 0$30 ) ;
6324: LD_INT 1050
6326: PPUSH
6327: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6331: LD_ADDR_VAR 0 2
6335: PUSH
6336: LD_INT 4
6338: PPUSH
6339: LD_INT 1
6341: PPUSH
6342: CALL 47066 0 2
6346: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6347: LD_ADDR_EXP 115
6351: PUSH
6352: LD_EXP 115
6356: PPUSH
6357: LD_INT 4
6359: PPUSH
6360: LD_EXP 115
6364: PUSH
6365: LD_INT 4
6367: ARRAY
6368: PUSH
6369: LD_VAR 0 2
6373: DIFF
6374: PPUSH
6375: CALL_OW 1
6379: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6380: LD_ADDR_VAR 0 3
6384: PUSH
6385: LD_INT 0
6387: PPUSH
6388: LD_INT 2
6390: PPUSH
6391: CALL_OW 12
6395: ST_TO_ADDR
// if target then
6396: LD_VAR 0 3
6400: IFFALSE 6528
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6402: LD_ADDR_VAR 0 2
6406: PUSH
6407: LD_VAR 0 2
6411: PPUSH
6412: LD_INT 24
6414: PUSH
6415: LD_INT 250
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: PPUSH
6422: CALL_OW 72
6426: ST_TO_ADDR
// for i in tmp do
6427: LD_ADDR_VAR 0 1
6431: PUSH
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_IN
6438: IFFALSE 6478
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6440: LD_VAR 0 1
6444: PPUSH
6445: LD_INT 114
6447: PPUSH
6448: LD_INT 108
6450: PPUSH
6451: CALL_OW 297
6455: PUSH
6456: LD_INT 9
6458: GREATER
6459: IFFALSE 6476
// ComMoveXY ( i , 114 , 108 ) ;
6461: LD_VAR 0 1
6465: PPUSH
6466: LD_INT 114
6468: PPUSH
6469: LD_INT 108
6471: PPUSH
6472: CALL_OW 111
6476: GO 6437
6478: POP
6479: POP
// wait ( 0 0$1 ) ;
6480: LD_INT 35
6482: PPUSH
6483: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6487: LD_VAR 0 2
6491: PPUSH
6492: LD_INT 92
6494: PUSH
6495: LD_INT 114
6497: PUSH
6498: LD_INT 108
6500: PUSH
6501: LD_INT 9
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PPUSH
6510: CALL_OW 72
6514: PUSH
6515: LD_VAR 0 2
6519: PUSH
6520: LD_INT 1
6522: MINUS
6523: GREATEREQUAL
6524: IFFALSE 6402
// end else
6526: GO 6652
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6528: LD_ADDR_VAR 0 2
6532: PUSH
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_INT 24
6540: PUSH
6541: LD_INT 250
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PPUSH
6548: CALL_OW 72
6552: ST_TO_ADDR
// for i in tmp do
6553: LD_ADDR_VAR 0 1
6557: PUSH
6558: LD_VAR 0 2
6562: PUSH
6563: FOR_IN
6564: IFFALSE 6604
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6566: LD_VAR 0 1
6570: PPUSH
6571: LD_INT 129
6573: PPUSH
6574: LD_INT 139
6576: PPUSH
6577: CALL_OW 297
6581: PUSH
6582: LD_INT 9
6584: GREATER
6585: IFFALSE 6602
// ComMoveXY ( i , 129 , 139 ) ;
6587: LD_VAR 0 1
6591: PPUSH
6592: LD_INT 129
6594: PPUSH
6595: LD_INT 139
6597: PPUSH
6598: CALL_OW 111
6602: GO 6563
6604: POP
6605: POP
// wait ( 0 0$1 ) ;
6606: LD_INT 35
6608: PPUSH
6609: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6613: LD_VAR 0 2
6617: PPUSH
6618: LD_INT 92
6620: PUSH
6621: LD_INT 129
6623: PUSH
6624: LD_INT 139
6626: PUSH
6627: LD_INT 9
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PPUSH
6636: CALL_OW 72
6640: PUSH
6641: LD_VAR 0 2
6645: PUSH
6646: LD_INT 1
6648: MINUS
6649: GREATEREQUAL
6650: IFFALSE 6528
// end ; repeat wait ( 0 0$1 ) ;
6652: LD_INT 35
6654: PPUSH
6655: CALL_OW 67
// for i in tmp do
6659: LD_ADDR_VAR 0 1
6663: PUSH
6664: LD_VAR 0 2
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6752
// begin if GetLives ( i ) > 251 then
6672: LD_VAR 0 1
6676: PPUSH
6677: CALL_OW 256
6681: PUSH
6682: LD_INT 251
6684: GREATER
6685: IFFALSE 6723
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6687: LD_VAR 0 1
6691: PPUSH
6692: LD_INT 81
6694: PUSH
6695: LD_INT 1
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 69
6706: PPUSH
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 74
6716: PPUSH
6717: CALL_OW 115
6721: GO 6750
// if IsDead ( i ) then
6723: LD_VAR 0 1
6727: PPUSH
6728: CALL_OW 301
6732: IFFALSE 6750
// tmp := tmp diff i ;
6734: LD_ADDR_VAR 0 2
6738: PUSH
6739: LD_VAR 0 2
6743: PUSH
6744: LD_VAR 0 1
6748: DIFF
6749: ST_TO_ADDR
// end ;
6750: GO 6669
6752: POP
6753: POP
// until not tmp ;
6754: LD_VAR 0 2
6758: NOT
6759: IFFALSE 6652
// end ;
6761: PPOPN 3
6763: END
// every 30 30$00 trigger not americanDestroyed do
6764: LD_EXP 4
6768: NOT
6769: IFFALSE 6838
6771: GO 6773
6773: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6774: LD_INT 63000
6776: PUSH
6777: LD_INT 42000
6779: PUSH
6780: LD_INT 31500
6782: PUSH
6783: LD_INT 21000
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: LD_OWVAR 67
6796: ARRAY
6797: PPUSH
6798: CALL_OW 67
// if americanDestroyed then
6802: LD_EXP 4
6806: IFFALSE 6810
// exit ;
6808: GO 6838
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6810: LD_INT 4
6812: PPUSH
6813: LD_INT 5
6815: PUSH
6816: LD_INT 3
6818: PUSH
6819: LD_INT 1
6821: PUSH
6822: LD_INT 8
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: LIST
6829: LIST
6830: PUSH
6831: EMPTY
6832: LIST
6833: PPUSH
6834: CALL 45648 0 2
// end ; end_of_file
6838: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6839: LD_INT 0
6841: PPUSH
6842: PPUSH
6843: PPUSH
6844: PPUSH
6845: PPUSH
// side := 2 ;
6846: LD_ADDR_VAR 0 5
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// InitHc ;
6854: CALL_OW 19
// uc_side := side ;
6858: LD_ADDR_OWVAR 20
6862: PUSH
6863: LD_VAR 0 5
6867: ST_TO_ADDR
// uc_nation := 2 ;
6868: LD_ADDR_OWVAR 21
6872: PUSH
6873: LD_INT 2
6875: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6876: LD_ADDR_VAR 0 2
6880: PUSH
6881: LD_INT 22
6883: PUSH
6884: LD_INT 2
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PUSH
6891: LD_INT 21
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: PPUSH
6905: CALL_OW 69
6909: PUSH
6910: FOR_IN
6911: IFFALSE 6927
// SetBLevel ( i , 10 ) ;
6913: LD_VAR 0 2
6917: PPUSH
6918: LD_INT 10
6920: PPUSH
6921: CALL_OW 241
6925: GO 6910
6927: POP
6928: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6929: LD_ADDR_VAR 0 4
6933: PUSH
6934: LD_INT 22
6936: PUSH
6937: LD_VAR 0 5
6941: PUSH
6942: EMPTY
6943: LIST
6944: LIST
6945: PUSH
6946: LD_INT 30
6948: PUSH
6949: LD_INT 32
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: LD_INT 58
6958: PUSH
6959: EMPTY
6960: LIST
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: LIST
6966: PPUSH
6967: CALL_OW 69
6971: ST_TO_ADDR
// for i = 1 to 10 do
6972: LD_ADDR_VAR 0 2
6976: PUSH
6977: DOUBLE
6978: LD_INT 1
6980: DEC
6981: ST_TO_ADDR
6982: LD_INT 10
6984: PUSH
6985: FOR_TO
6986: IFFALSE 7058
// begin uc_nation := nation_nature ;
6988: LD_ADDR_OWVAR 21
6992: PUSH
6993: LD_INT 0
6995: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6996: LD_ADDR_OWVAR 28
7000: PUSH
7001: LD_INT 15
7003: ST_TO_ADDR
// hc_gallery :=  ;
7004: LD_ADDR_OWVAR 33
7008: PUSH
7009: LD_STRING 
7011: ST_TO_ADDR
// hc_name :=  ;
7012: LD_ADDR_OWVAR 26
7016: PUSH
7017: LD_STRING 
7019: ST_TO_ADDR
// un := CreateHuman ;
7020: LD_ADDR_VAR 0 3
7024: PUSH
7025: CALL_OW 44
7029: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7030: LD_VAR 0 3
7034: PPUSH
7035: LD_VAR 0 4
7039: PUSH
7040: LD_VAR 0 4
7044: PUSH
7045: LD_VAR 0 2
7049: MINUS
7050: ARRAY
7051: PPUSH
7052: CALL_OW 52
// end ;
7056: GO 6985
7058: POP
7059: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7060: LD_INT 503
7062: PPUSH
7063: LD_INT 27
7065: PPUSH
7066: LD_STRING 
7068: PPUSH
7069: LD_INT 8
7071: PUSH
7072: LD_INT 9
7074: PUSH
7075: LD_INT 10
7077: PUSH
7078: LD_INT 10
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_OWVAR 67
7091: ARRAY
7092: PPUSH
7093: LD_INT 3000
7095: PUSH
7096: LD_INT 500
7098: PUSH
7099: LD_INT 150
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: LIST
7106: PPUSH
7107: LD_INT 16
7109: PUSH
7110: LD_INT 6
7112: PUSH
7113: LD_INT 6
7115: PUSH
7116: LD_INT 6
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL 60517 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7129: LD_ADDR_EXP 96
7133: PUSH
7134: LD_EXP 96
7138: PPUSH
7139: LD_INT 1
7141: PPUSH
7142: LD_INT 22
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: PUSH
7154: LD_INT 23
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PUSH
7164: LD_INT 3
7166: PUSH
7167: LD_INT 21
7169: PUSH
7170: LD_INT 2
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: LIST
7185: PPUSH
7186: CALL_OW 69
7190: PPUSH
7191: CALL_OW 1
7195: ST_TO_ADDR
// end ;
7196: LD_VAR 0 1
7200: RET
// export Omar ; export function PrepareOmarAli ; begin
7201: LD_INT 0
7203: PPUSH
// uc_side := 5 ;
7204: LD_ADDR_OWVAR 20
7208: PUSH
7209: LD_INT 5
7211: ST_TO_ADDR
// uc_nation := 2 ;
7212: LD_ADDR_OWVAR 21
7216: PUSH
7217: LD_INT 2
7219: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7220: LD_ADDR_EXP 55
7224: PUSH
7225: LD_STRING Omar
7227: PPUSH
7228: CALL_OW 25
7232: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7233: LD_EXP 55
7237: PPUSH
7238: LD_INT 330
7240: PPUSH
7241: LD_INT 244
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7251: LD_EXP 55
7255: PPUSH
7256: LD_INT 252
7258: PPUSH
7259: LD_INT 220
7261: PPUSH
7262: CALL_OW 111
// end ; end_of_file
7266: LD_VAR 0 1
7270: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
7271: LD_INT 0
7273: PPUSH
7274: PPUSH
7275: PPUSH
7276: PPUSH
7277: PPUSH
// side := 8 ;
7278: LD_ADDR_VAR 0 3
7282: PUSH
7283: LD_INT 8
7285: ST_TO_ADDR
// InitHc ;
7286: CALL_OW 19
// uc_side := side ;
7290: LD_ADDR_OWVAR 20
7294: PUSH
7295: LD_VAR 0 3
7299: ST_TO_ADDR
// uc_nation := 2 ;
7300: LD_ADDR_OWVAR 21
7304: PUSH
7305: LD_INT 2
7307: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7308: LD_ADDR_VAR 0 2
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_VAR 0 3
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PUSH
7325: LD_INT 21
7327: PUSH
7328: LD_INT 3
7330: PUSH
7331: EMPTY
7332: LIST
7333: LIST
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PPUSH
7339: CALL_OW 69
7343: PUSH
7344: FOR_IN
7345: IFFALSE 7361
// SetBLevel ( i , 10 ) ;
7347: LD_VAR 0 2
7351: PPUSH
7352: LD_INT 10
7354: PPUSH
7355: CALL_OW 241
7359: GO 7344
7361: POP
7362: POP
// Schulz := NewCharacter ( Schulz ) ;
7363: LD_ADDR_EXP 56
7367: PUSH
7368: LD_STRING Schulz
7370: PPUSH
7371: CALL_OW 25
7375: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7376: LD_ADDR_EXP 57
7380: PUSH
7381: LD_STRING Kozlov
7383: PPUSH
7384: LD_INT 0
7386: PPUSH
7387: LD_STRING 
7389: PPUSH
7390: CALL 52054 0 3
7394: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7395: LD_EXP 57
7399: PPUSH
7400: LD_INT 22
7402: PUSH
7403: LD_INT 8
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: LD_INT 23
7412: PUSH
7413: LD_INT 3
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: PUSH
7420: LD_INT 30
7422: PUSH
7423: LD_INT 8
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: LIST
7434: PPUSH
7435: CALL_OW 69
7439: PUSH
7440: LD_INT 1
7442: ARRAY
7443: PPUSH
7444: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7448: LD_EXP 57
7452: PPUSH
7453: LD_INT 3
7455: PPUSH
7456: LD_INT 10
7458: PPUSH
7459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7463: LD_ADDR_VAR 0 5
7467: PUSH
7468: LD_INT 22
7470: PUSH
7471: LD_VAR 0 3
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 30
7482: PUSH
7483: LD_INT 32
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 58
7492: PUSH
7493: EMPTY
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: PPUSH
7501: CALL_OW 69
7505: ST_TO_ADDR
// for i = 1 to 10 do
7506: LD_ADDR_VAR 0 2
7510: PUSH
7511: DOUBLE
7512: LD_INT 1
7514: DEC
7515: ST_TO_ADDR
7516: LD_INT 10
7518: PUSH
7519: FOR_TO
7520: IFFALSE 7592
// begin uc_nation := nation_nature ;
7522: LD_ADDR_OWVAR 21
7526: PUSH
7527: LD_INT 0
7529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7530: LD_ADDR_OWVAR 28
7534: PUSH
7535: LD_INT 15
7537: ST_TO_ADDR
// hc_gallery :=  ;
7538: LD_ADDR_OWVAR 33
7542: PUSH
7543: LD_STRING 
7545: ST_TO_ADDR
// hc_name :=  ;
7546: LD_ADDR_OWVAR 26
7550: PUSH
7551: LD_STRING 
7553: ST_TO_ADDR
// un := CreateHuman ;
7554: LD_ADDR_VAR 0 4
7558: PUSH
7559: CALL_OW 44
7563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7564: LD_VAR 0 4
7568: PPUSH
7569: LD_VAR 0 5
7573: PUSH
7574: LD_VAR 0 5
7578: PUSH
7579: LD_VAR 0 2
7583: MINUS
7584: ARRAY
7585: PPUSH
7586: CALL_OW 52
// end ;
7590: GO 7519
7592: POP
7593: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7594: LD_INT 324
7596: PPUSH
7597: LD_INT 3
7599: PPUSH
7600: LD_STRING 
7602: PPUSH
7603: LD_INT 8
7605: PUSH
7606: LD_INT 9
7608: PUSH
7609: LD_INT 10
7611: PUSH
7612: LD_INT 10
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: PUSH
7621: LD_OWVAR 67
7625: ARRAY
7626: PPUSH
7627: LD_INT 3000
7629: PUSH
7630: LD_INT 500
7632: PUSH
7633: LD_INT 150
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: LIST
7640: PPUSH
7641: LD_INT 16
7643: PUSH
7644: LD_INT 6
7646: PUSH
7647: LD_INT 6
7649: PUSH
7650: LD_INT 8
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PPUSH
7659: CALL 60517 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7663: LD_ADDR_EXP 96
7667: PUSH
7668: LD_EXP 96
7672: PPUSH
7673: LD_INT 3
7675: PPUSH
7676: LD_INT 22
7678: PUSH
7679: LD_VAR 0 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 23
7690: PUSH
7691: LD_INT 2
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 21
7703: PUSH
7704: LD_INT 2
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: PUSH
7725: LD_EXP 56
7729: DIFF
7730: PPUSH
7731: CALL_OW 1
7735: ST_TO_ADDR
// end ;
7736: LD_VAR 0 1
7740: RET
// export function BuildKozlovBomb ; begin
7741: LD_INT 0
7743: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7744: LD_INT 332
7746: PPUSH
7747: CALL_OW 302
7751: NOT
7752: PUSH
7753: LD_INT 336
7755: PPUSH
7756: CALL_OW 302
7760: NOT
7761: OR
7762: IFFALSE 7766
// exit ;
7764: GO 7863
// ComChangeProfession ( Kozlov , 4 ) ;
7766: LD_EXP 57
7770: PPUSH
7771: LD_INT 4
7773: PPUSH
7774: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7778: LD_INT 336
7780: PPUSH
7781: LD_INT 25
7783: PPUSH
7784: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7788: LD_INT 35
7790: PPUSH
7791: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7795: LD_INT 25
7797: PPUSH
7798: LD_INT 8
7800: PPUSH
7801: CALL_OW 321
7805: PUSH
7806: LD_INT 2
7808: EQUAL
7809: IFFALSE 7788
// ComExitBuilding ( Kozlov ) ;
7811: LD_EXP 57
7815: PPUSH
7816: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7820: LD_EXP 57
7824: PPUSH
7825: LD_INT 332
7827: PPUSH
7828: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7832: LD_EXP 57
7836: PPUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7844: LD_INT 332
7846: PPUSH
7847: LD_INT 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_INT 1
7855: PPUSH
7856: LD_INT 48
7858: PPUSH
7859: CALL_OW 125
// end ;
7863: LD_VAR 0 1
7867: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7868: LD_EXP 3
7872: NOT
7873: PUSH
7874: LD_INT 3
7876: PPUSH
7877: LD_INT 1
7879: PPUSH
7880: CALL 47066 0 2
7884: NOT
7885: AND
7886: IFFALSE 8742
7888: GO 7890
7890: DISABLE
7891: LD_INT 0
7893: PPUSH
7894: PPUSH
7895: PPUSH
// begin enable ;
7896: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7897: LD_INT 22
7899: PUSH
7900: LD_INT 8
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 23
7909: PUSH
7910: LD_INT 2
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 3
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: IFFALSE 7941
// exit ;
7939: GO 8742
// if Prob ( 40 ) then
7941: LD_INT 40
7943: PPUSH
7944: CALL_OW 13
7948: IFFALSE 8075
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7950: LD_INT 3
7952: PPUSH
7953: LD_INT 14
7955: PUSH
7956: LD_INT 1
7958: PUSH
7959: LD_INT 2
7961: PUSH
7962: LD_INT 28
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: LIST
7969: LIST
7970: PUSH
7971: LD_INT 14
7973: PUSH
7974: LD_INT 1
7976: PUSH
7977: LD_INT 2
7979: PUSH
7980: LD_INT 28
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: LIST
7988: PUSH
7989: LD_INT 14
7991: PUSH
7992: LD_INT 1
7994: PUSH
7995: LD_INT 2
7997: PUSH
7998: LD_INT 28
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: LIST
8005: LIST
8006: PUSH
8007: LD_INT 14
8009: PUSH
8010: LD_INT 1
8012: PUSH
8013: LD_INT 2
8015: PUSH
8016: LD_INT 28
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: PUSH
8025: LD_INT 14
8027: PUSH
8028: LD_INT 1
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 28
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: PUSH
8043: LD_INT 14
8045: PUSH
8046: LD_INT 1
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: LD_INT 26
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: LIST
8059: LIST
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: LIST
8067: LIST
8068: PPUSH
8069: CALL 45648 0 2
// end else
8073: GO 8282
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8075: LD_INT 3
8077: PPUSH
8078: LD_INT 14
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: LD_INT 2
8086: PUSH
8087: LD_INT 27
8089: PUSH
8090: LD_INT 26
8092: PUSH
8093: LD_INT 26
8095: PUSH
8096: LD_INT 28
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: LIST
8103: LIST
8104: PUSH
8105: LD_OWVAR 67
8109: ARRAY
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: LIST
8115: LIST
8116: PUSH
8117: LD_INT 14
8119: PUSH
8120: LD_INT 1
8122: PUSH
8123: LD_INT 2
8125: PUSH
8126: LD_INT 27
8128: PUSH
8129: LD_INT 26
8131: PUSH
8132: LD_INT 26
8134: PUSH
8135: LD_INT 26
8137: PUSH
8138: EMPTY
8139: LIST
8140: LIST
8141: LIST
8142: LIST
8143: PUSH
8144: LD_OWVAR 67
8148: ARRAY
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: LIST
8154: LIST
8155: PUSH
8156: LD_INT 14
8158: PUSH
8159: LD_INT 1
8161: PUSH
8162: LD_INT 2
8164: PUSH
8165: LD_INT 26
8167: PUSH
8168: LD_INT 26
8170: PUSH
8171: LD_INT 29
8173: PUSH
8174: LD_INT 29
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: LIST
8181: LIST
8182: PUSH
8183: LD_OWVAR 67
8187: ARRAY
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: LIST
8193: LIST
8194: PUSH
8195: LD_INT 13
8197: PUSH
8198: LD_INT 1
8200: PUSH
8201: LD_INT 2
8203: PUSH
8204: LD_INT 26
8206: PUSH
8207: LD_INT 29
8209: PUSH
8210: LD_INT 29
8212: PUSH
8213: LD_INT 29
8215: PUSH
8216: EMPTY
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: PUSH
8222: LD_OWVAR 67
8226: ARRAY
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: PUSH
8234: LD_INT 13
8236: PUSH
8237: LD_INT 1
8239: PUSH
8240: LD_INT 2
8242: PUSH
8243: LD_INT 29
8245: PUSH
8246: EMPTY
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: PUSH
8252: LD_INT 14
8254: PUSH
8255: LD_INT 1
8257: PUSH
8258: LD_INT 2
8260: PUSH
8261: LD_INT 26
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: PPUSH
8278: CALL 45648 0 2
// end ; repeat wait ( 0 0$1 ) ;
8282: LD_INT 35
8284: PPUSH
8285: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 1
8294: PPUSH
8295: CALL 47066 0 2
8299: PUSH
8300: LD_INT 6
8302: GREATEREQUAL
8303: IFFALSE 8282
// wait ( 0 0$30 ) ;
8305: LD_INT 1050
8307: PPUSH
8308: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8312: LD_ADDR_VAR 0 2
8316: PUSH
8317: LD_INT 3
8319: PPUSH
8320: LD_INT 1
8322: PPUSH
8323: CALL 47066 0 2
8327: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8328: LD_ADDR_EXP 115
8332: PUSH
8333: LD_EXP 115
8337: PPUSH
8338: LD_INT 3
8340: PPUSH
8341: LD_EXP 115
8345: PUSH
8346: LD_INT 3
8348: ARRAY
8349: PUSH
8350: LD_VAR 0 2
8354: DIFF
8355: PPUSH
8356: CALL_OW 1
8360: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8361: LD_ADDR_VAR 0 3
8365: PUSH
8366: LD_INT 0
8368: PPUSH
8369: LD_INT 2
8371: PPUSH
8372: CALL_OW 12
8376: ST_TO_ADDR
// if target then
8377: LD_VAR 0 3
8381: IFFALSE 8509
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8383: LD_ADDR_VAR 0 2
8387: PUSH
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 24
8395: PUSH
8396: LD_INT 250
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PPUSH
8403: CALL_OW 72
8407: ST_TO_ADDR
// for i in tmp do
8408: LD_ADDR_VAR 0 1
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: FOR_IN
8419: IFFALSE 8459
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8421: LD_VAR 0 1
8425: PPUSH
8426: LD_INT 89
8428: PPUSH
8429: LD_INT 71
8431: PPUSH
8432: CALL_OW 297
8436: PUSH
8437: LD_INT 9
8439: GREATER
8440: IFFALSE 8457
// ComMoveXY ( i , 89 , 71 ) ;
8442: LD_VAR 0 1
8446: PPUSH
8447: LD_INT 89
8449: PPUSH
8450: LD_INT 71
8452: PPUSH
8453: CALL_OW 111
8457: GO 8418
8459: POP
8460: POP
// wait ( 0 0$1 ) ;
8461: LD_INT 35
8463: PPUSH
8464: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8468: LD_VAR 0 2
8472: PPUSH
8473: LD_INT 92
8475: PUSH
8476: LD_INT 89
8478: PUSH
8479: LD_INT 71
8481: PUSH
8482: LD_INT 9
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 72
8495: PUSH
8496: LD_VAR 0 2
8500: PUSH
8501: LD_INT 1
8503: MINUS
8504: GREATEREQUAL
8505: IFFALSE 8383
// end else
8507: GO 8633
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8509: LD_ADDR_VAR 0 2
8513: PUSH
8514: LD_VAR 0 2
8518: PPUSH
8519: LD_INT 24
8521: PUSH
8522: LD_INT 250
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PPUSH
8529: CALL_OW 72
8533: ST_TO_ADDR
// for i in tmp do
8534: LD_ADDR_VAR 0 1
8538: PUSH
8539: LD_VAR 0 2
8543: PUSH
8544: FOR_IN
8545: IFFALSE 8585
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8547: LD_VAR 0 1
8551: PPUSH
8552: LD_INT 147
8554: PPUSH
8555: LD_INT 4
8557: PPUSH
8558: CALL_OW 297
8562: PUSH
8563: LD_INT 9
8565: GREATER
8566: IFFALSE 8583
// ComMoveXY ( i , 147 , 4 ) ;
8568: LD_VAR 0 1
8572: PPUSH
8573: LD_INT 147
8575: PPUSH
8576: LD_INT 4
8578: PPUSH
8579: CALL_OW 111
8583: GO 8544
8585: POP
8586: POP
// wait ( 0 0$1 ) ;
8587: LD_INT 35
8589: PPUSH
8590: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8594: LD_VAR 0 2
8598: PPUSH
8599: LD_INT 92
8601: PUSH
8602: LD_INT 147
8604: PUSH
8605: LD_INT 4
8607: PUSH
8608: LD_INT 9
8610: PUSH
8611: EMPTY
8612: LIST
8613: LIST
8614: LIST
8615: LIST
8616: PPUSH
8617: CALL_OW 72
8621: PUSH
8622: LD_VAR 0 2
8626: PUSH
8627: LD_INT 1
8629: MINUS
8630: GREATEREQUAL
8631: IFFALSE 8509
// end ; repeat wait ( 0 0$1 ) ;
8633: LD_INT 35
8635: PPUSH
8636: CALL_OW 67
// for i in tmp do
8640: LD_ADDR_VAR 0 1
8644: PUSH
8645: LD_VAR 0 2
8649: PUSH
8650: FOR_IN
8651: IFFALSE 8733
// begin if GetLives ( i ) > 251 then
8653: LD_VAR 0 1
8657: PPUSH
8658: CALL_OW 256
8662: PUSH
8663: LD_INT 251
8665: GREATER
8666: IFFALSE 8704
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8668: LD_VAR 0 1
8672: PPUSH
8673: LD_INT 81
8675: PUSH
8676: LD_INT 8
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PPUSH
8683: CALL_OW 69
8687: PPUSH
8688: LD_VAR 0 1
8692: PPUSH
8693: CALL_OW 74
8697: PPUSH
8698: CALL_OW 115
8702: GO 8731
// if IsDead ( i ) then
8704: LD_VAR 0 1
8708: PPUSH
8709: CALL_OW 301
8713: IFFALSE 8731
// tmp := tmp diff i ;
8715: LD_ADDR_VAR 0 2
8719: PUSH
8720: LD_VAR 0 2
8724: PUSH
8725: LD_VAR 0 1
8729: DIFF
8730: ST_TO_ADDR
// end ;
8731: GO 8650
8733: POP
8734: POP
// until not tmp ;
8735: LD_VAR 0 2
8739: NOT
8740: IFFALSE 8633
// end ;
8742: PPOPN 3
8744: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8745: LD_EXP 57
8749: PPUSH
8750: CALL_OW 302
8754: PUSH
8755: LD_EXP 3
8759: NOT
8760: AND
8761: IFFALSE 8770
8763: GO 8765
8765: DISABLE
// BuildKozlovBomb ;
8766: CALL 7741 0 0
8770: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8771: LD_INT 22
8773: PUSH
8774: LD_INT 8
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 34
8783: PUSH
8784: LD_INT 48
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PPUSH
8795: CALL_OW 69
8799: IFFALSE 8847
8801: GO 8803
8803: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8804: LD_INT 22
8806: PUSH
8807: LD_INT 8
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PUSH
8814: LD_INT 34
8816: PUSH
8817: LD_INT 48
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: PPUSH
8828: CALL_OW 69
8832: PUSH
8833: LD_INT 1
8835: ARRAY
8836: PPUSH
8837: LD_INT 173
8839: PPUSH
8840: LD_INT 96
8842: PPUSH
8843: CALL_OW 116
// end ; end_of_file
8847: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8848: LD_INT 0
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// side := 3 ;
8859: LD_ADDR_VAR 0 6
8863: PUSH
8864: LD_INT 3
8866: ST_TO_ADDR
// InitHc ;
8867: CALL_OW 19
// uc_side := side ;
8871: LD_ADDR_OWVAR 20
8875: PUSH
8876: LD_VAR 0 6
8880: ST_TO_ADDR
// uc_nation := 3 ;
8881: LD_ADDR_OWVAR 21
8885: PUSH
8886: LD_INT 3
8888: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8889: LD_ADDR_VAR 0 2
8893: PUSH
8894: LD_INT 22
8896: PUSH
8897: LD_VAR 0 6
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 21
8908: PUSH
8909: LD_INT 3
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PPUSH
8920: CALL_OW 69
8924: PUSH
8925: FOR_IN
8926: IFFALSE 8942
// SetBLevel ( i , 10 ) ;
8928: LD_VAR 0 2
8932: PPUSH
8933: LD_INT 10
8935: PPUSH
8936: CALL_OW 241
8940: GO 8925
8942: POP
8943: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8944: LD_ADDR_VAR 0 9
8948: PUSH
8949: LD_INT 22
8951: PUSH
8952: LD_VAR 0 6
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 30
8963: PUSH
8964: LD_INT 34
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PPUSH
8975: CALL_OW 69
8979: ST_TO_ADDR
// if teleport then
8980: LD_VAR 0 9
8984: IFFALSE 9005
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8986: LD_VAR 0 9
8990: PUSH
8991: LD_INT 1
8993: ARRAY
8994: PPUSH
8995: LD_INT 123
8997: PPUSH
8998: LD_INT 122
9000: PPUSH
9001: CALL_OW 243
// hc_importance := 0 ;
9005: LD_ADDR_OWVAR 32
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9013: LD_ADDR_EXP 58
9017: PUSH
9018: LD_STRING Platonov
9020: PPUSH
9021: CALL_OW 25
9025: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9026: LD_ADDR_EXP 59
9030: PUSH
9031: LD_STRING Yakotich
9033: PPUSH
9034: LD_EXP 1
9038: NOT
9039: PPUSH
9040: LD_STRING 09_
9042: PPUSH
9043: CALL 52054 0 3
9047: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9048: LD_ADDR_EXP 60
9052: PUSH
9053: LD_STRING Gleb
9055: PPUSH
9056: CALL_OW 25
9060: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9061: LD_STRING 03_Cornel
9063: PPUSH
9064: CALL_OW 28
9068: IFFALSE 9116
// begin Bierezov := NewCharacter ( Mikhail ) ;
9070: LD_ADDR_EXP 61
9074: PUSH
9075: LD_STRING Mikhail
9077: PPUSH
9078: CALL_OW 25
9082: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9083: LD_EXP 61
9087: PPUSH
9088: LD_INT 197
9090: PPUSH
9091: LD_INT 111
9093: PPUSH
9094: LD_INT 9
9096: PPUSH
9097: LD_INT 0
9099: PPUSH
9100: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9104: LD_EXP 61
9108: PPUSH
9109: LD_INT 3
9111: PPUSH
9112: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9116: LD_EXP 58
9120: PPUSH
9121: LD_INT 126
9123: PPUSH
9124: CALL_OW 52
// if Yakotich then
9128: LD_EXP 59
9132: IFFALSE 9155
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9134: LD_EXP 59
9138: PPUSH
9139: LD_INT 197
9141: PPUSH
9142: LD_INT 111
9144: PPUSH
9145: LD_INT 9
9147: PPUSH
9148: LD_INT 0
9150: PPUSH
9151: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9155: LD_EXP 60
9159: PPUSH
9160: LD_INT 197
9162: PPUSH
9163: LD_INT 111
9165: PPUSH
9166: LD_INT 9
9168: PPUSH
9169: LD_INT 0
9171: PPUSH
9172: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9176: LD_ADDR_VAR 0 5
9180: PUSH
9181: LD_INT 126
9183: PPUSH
9184: LD_INT 2
9186: PPUSH
9187: LD_STRING zhukov
9189: PPUSH
9190: LD_INT 9
9192: PUSH
9193: LD_INT 10
9195: PUSH
9196: LD_INT 10
9198: PUSH
9199: LD_INT 10
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: LIST
9206: LIST
9207: PUSH
9208: LD_OWVAR 67
9212: ARRAY
9213: PPUSH
9214: LD_INT 9000
9216: PUSH
9217: LD_INT 1000
9219: PUSH
9220: LD_INT 300
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: LIST
9227: PPUSH
9228: LD_INT 21
9230: PUSH
9231: LD_INT 8
9233: PUSH
9234: LD_INT 13
9236: PUSH
9237: LD_INT 8
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: LIST
9244: LIST
9245: PPUSH
9246: CALL 60517 0 6
9250: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9251: LD_ADDR_VAR 0 4
9255: PUSH
9256: LD_INT 267
9258: PPUSH
9259: CALL_OW 274
9263: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9264: LD_VAR 0 4
9268: PPUSH
9269: LD_INT 1
9271: PPUSH
9272: LD_INT 5000
9274: PPUSH
9275: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9279: LD_VAR 0 4
9283: PPUSH
9284: LD_INT 2
9286: PPUSH
9287: LD_INT 200
9289: PPUSH
9290: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9294: LD_VAR 0 4
9298: PPUSH
9299: LD_INT 3
9301: PPUSH
9302: LD_INT 200
9304: PPUSH
9305: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
9309: LD_ADDR_EXP 96
9313: PUSH
9314: LD_EXP 96
9318: PPUSH
9319: LD_INT 2
9321: PPUSH
9322: LD_VAR 0 5
9326: PUSH
9327: LD_INT 22
9329: PUSH
9330: LD_VAR 0 6
9334: PUSH
9335: EMPTY
9336: LIST
9337: LIST
9338: PUSH
9339: LD_INT 3
9341: PUSH
9342: LD_INT 21
9344: PUSH
9345: LD_INT 2
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PUSH
9352: EMPTY
9353: LIST
9354: LIST
9355: PUSH
9356: EMPTY
9357: LIST
9358: LIST
9359: PPUSH
9360: CALL_OW 69
9364: UNION
9365: PUSH
9366: LD_EXP 58
9370: DIFF
9371: PPUSH
9372: CALL_OW 1
9376: ST_TO_ADDR
// behemoths := [ ] ;
9377: LD_ADDR_EXP 62
9381: PUSH
9382: EMPTY
9383: ST_TO_ADDR
// behemothBuilders := [ ] ;
9384: LD_ADDR_EXP 63
9388: PUSH
9389: EMPTY
9390: ST_TO_ADDR
// j := 3 ;
9391: LD_ADDR_VAR 0 3
9395: PUSH
9396: LD_INT 3
9398: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9399: LD_ADDR_VAR 0 2
9403: PUSH
9404: LD_INT 22
9406: PUSH
9407: LD_INT 3
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: PUSH
9414: LD_INT 25
9416: PUSH
9417: LD_INT 3
9419: PUSH
9420: EMPTY
9421: LIST
9422: LIST
9423: PUSH
9424: EMPTY
9425: LIST
9426: LIST
9427: PPUSH
9428: CALL_OW 69
9432: PUSH
9433: FOR_IN
9434: IFFALSE 9484
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9436: LD_ADDR_EXP 63
9440: PUSH
9441: LD_EXP 63
9445: PPUSH
9446: LD_VAR 0 2
9450: PPUSH
9451: CALL 88888 0 2
9455: ST_TO_ADDR
// j := j - 1 ;
9456: LD_ADDR_VAR 0 3
9460: PUSH
9461: LD_VAR 0 3
9465: PUSH
9466: LD_INT 1
9468: MINUS
9469: ST_TO_ADDR
// if j = 0 then
9470: LD_VAR 0 3
9474: PUSH
9475: LD_INT 0
9477: EQUAL
9478: IFFALSE 9482
// break ;
9480: GO 9484
// end ;
9482: GO 9433
9484: POP
9485: POP
// end ;
9486: LD_VAR 0 1
9490: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9491: LD_INT 0
9493: PPUSH
9494: PPUSH
9495: PPUSH
9496: PPUSH
9497: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9498: LD_ADDR_VAR 0 4
9502: PUSH
9503: LD_INT 209
9505: PUSH
9506: LD_INT 149
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: PUSH
9513: LD_INT 219
9515: PUSH
9516: LD_INT 154
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: PUSH
9523: LD_INT 223
9525: PUSH
9526: LD_INT 149
9528: PUSH
9529: EMPTY
9530: LIST
9531: LIST
9532: PUSH
9533: LD_INT 232
9535: PUSH
9536: LD_INT 155
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: LIST
9547: LIST
9548: ST_TO_ADDR
// if not behemothBuilders then
9549: LD_EXP 63
9553: NOT
9554: IFFALSE 9558
// exit ;
9556: GO 9662
// j := 1 ;
9558: LD_ADDR_VAR 0 3
9562: PUSH
9563: LD_INT 1
9565: ST_TO_ADDR
// for i in behemothBuilders do
9566: LD_ADDR_VAR 0 2
9570: PUSH
9571: LD_EXP 63
9575: PUSH
9576: FOR_IN
9577: IFFALSE 9660
// begin if IsInUnit ( i ) then
9579: LD_VAR 0 2
9583: PPUSH
9584: CALL_OW 310
9588: IFFALSE 9599
// ComExitBuilding ( i ) ;
9590: LD_VAR 0 2
9594: PPUSH
9595: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9599: LD_VAR 0 2
9603: PPUSH
9604: LD_INT 37
9606: PPUSH
9607: LD_VAR 0 4
9611: PUSH
9612: LD_VAR 0 3
9616: ARRAY
9617: PUSH
9618: LD_INT 1
9620: ARRAY
9621: PPUSH
9622: LD_VAR 0 4
9626: PUSH
9627: LD_VAR 0 3
9631: ARRAY
9632: PUSH
9633: LD_INT 2
9635: ARRAY
9636: PPUSH
9637: LD_INT 0
9639: PPUSH
9640: CALL_OW 230
// j := j + 1 ;
9644: LD_ADDR_VAR 0 3
9648: PUSH
9649: LD_VAR 0 3
9653: PUSH
9654: LD_INT 1
9656: PLUS
9657: ST_TO_ADDR
// end ;
9658: GO 9576
9660: POP
9661: POP
// end ;
9662: LD_VAR 0 1
9666: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9667: LD_INT 3
9669: PPUSH
9670: CALL 88949 0 1
9674: PUSH
9675: LD_INT 22
9677: PUSH
9678: LD_INT 3
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: PUSH
9685: LD_INT 30
9687: PUSH
9688: LD_INT 37
9690: PUSH
9691: EMPTY
9692: LIST
9693: LIST
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: PPUSH
9699: CALL_OW 69
9703: NOT
9704: AND
9705: IFFALSE 9891
9707: GO 9709
9709: DISABLE
9710: LD_INT 0
9712: PPUSH
9713: PPUSH
// begin enable ;
9714: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9715: LD_ADDR_VAR 0 2
9719: PUSH
9720: LD_INT 3
9722: PPUSH
9723: CALL 88949 0 1
9727: ST_TO_ADDR
// for i in tmp do
9728: LD_ADDR_VAR 0 1
9732: PUSH
9733: LD_VAR 0 2
9737: PUSH
9738: FOR_IN
9739: IFFALSE 9889
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9741: LD_VAR 0 1
9745: PPUSH
9746: LD_INT 7
9748: PPUSH
9749: CALL_OW 308
9753: PUSH
9754: LD_VAR 0 1
9758: PPUSH
9759: CALL_OW 110
9763: PUSH
9764: LD_INT 2
9766: EQUAL
9767: NOT
9768: AND
9769: IFFALSE 9783
// SetTag ( i , 2 ) ;
9771: LD_VAR 0 1
9775: PPUSH
9776: LD_INT 2
9778: PPUSH
9779: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9783: LD_INT 81
9785: PUSH
9786: LD_INT 3
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PUSH
9793: LD_INT 91
9795: PUSH
9796: LD_VAR 0 1
9800: PUSH
9801: LD_INT 12
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: LIST
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PPUSH
9813: CALL_OW 69
9817: NOT
9818: PUSH
9819: LD_VAR 0 1
9823: PPUSH
9824: CALL_OW 110
9828: PUSH
9829: LD_INT 2
9831: EQUAL
9832: NOT
9833: AND
9834: IFFALSE 9853
// ComAgressiveMove ( i , 64 , 93 ) else
9836: LD_VAR 0 1
9840: PPUSH
9841: LD_INT 64
9843: PPUSH
9844: LD_INT 93
9846: PPUSH
9847: CALL_OW 114
9851: GO 9887
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9853: LD_VAR 0 1
9857: PPUSH
9858: LD_INT 81
9860: PUSH
9861: LD_INT 3
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PPUSH
9868: CALL_OW 69
9872: PPUSH
9873: LD_VAR 0 1
9877: PPUSH
9878: CALL_OW 74
9882: PPUSH
9883: CALL_OW 115
// end ;
9887: GO 9738
9889: POP
9890: POP
// end ;
9891: PPOPN 2
9893: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9894: LD_EXP 2
9898: NOT
9899: PUSH
9900: LD_INT 2
9902: PPUSH
9903: LD_INT 1
9905: PPUSH
9906: CALL 47066 0 2
9910: NOT
9911: AND
9912: IFFALSE 10836
9914: GO 9916
9916: DISABLE
9917: LD_INT 0
9919: PPUSH
9920: PPUSH
9921: PPUSH
9922: PPUSH
// begin enable ;
9923: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9924: LD_INT 22
9926: PUSH
9927: LD_INT 3
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PUSH
9934: LD_INT 30
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: EMPTY
9945: LIST
9946: LIST
9947: PPUSH
9948: CALL_OW 69
9952: NOT
9953: IFFALSE 9957
// exit ;
9955: GO 10836
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9957: LD_ADDR_VAR 0 4
9961: PUSH
9962: LD_INT 22
9964: PUSH
9965: LD_INT 3
9967: PUSH
9968: EMPTY
9969: LIST
9970: LIST
9971: PUSH
9972: LD_INT 30
9974: PUSH
9975: LD_INT 34
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PUSH
9982: EMPTY
9983: LIST
9984: LIST
9985: PPUSH
9986: CALL_OW 69
9990: ST_TO_ADDR
// if Prob ( 40 ) then
9991: LD_INT 40
9993: PPUSH
9994: CALL_OW 13
9998: IFFALSE 10125
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10000: LD_INT 2
10002: PPUSH
10003: LD_INT 22
10005: PUSH
10006: LD_INT 3
10008: PUSH
10009: LD_INT 3
10011: PUSH
10012: LD_INT 49
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: LIST
10019: LIST
10020: PUSH
10021: LD_INT 22
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: LD_INT 3
10029: PUSH
10030: LD_INT 49
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: LIST
10037: LIST
10038: PUSH
10039: LD_INT 22
10041: PUSH
10042: LD_INT 3
10044: PUSH
10045: LD_INT 3
10047: PUSH
10048: LD_INT 49
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: PUSH
10057: LD_INT 24
10059: PUSH
10060: LD_INT 3
10062: PUSH
10063: LD_INT 3
10065: PUSH
10066: LD_INT 46
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: PUSH
10075: LD_INT 24
10077: PUSH
10078: LD_INT 3
10080: PUSH
10081: LD_INT 3
10083: PUSH
10084: LD_INT 46
10086: PUSH
10087: EMPTY
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 24
10095: PUSH
10096: LD_INT 3
10098: PUSH
10099: LD_INT 3
10101: PUSH
10102: LD_INT 46
10104: PUSH
10105: EMPTY
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: PPUSH
10119: CALL 45648 0 2
// end else
10123: GO 10248
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10125: LD_INT 2
10127: PPUSH
10128: LD_INT 24
10130: PUSH
10131: LD_INT 3
10133: PUSH
10134: LD_INT 3
10136: PUSH
10137: LD_INT 47
10139: PUSH
10140: EMPTY
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: PUSH
10146: LD_INT 24
10148: PUSH
10149: LD_INT 3
10151: PUSH
10152: LD_INT 3
10154: PUSH
10155: LD_INT 47
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: PUSH
10164: LD_INT 24
10166: PUSH
10167: LD_INT 3
10169: PUSH
10170: LD_INT 3
10172: PUSH
10173: LD_INT 47
10175: PUSH
10176: EMPTY
10177: LIST
10178: LIST
10179: LIST
10180: LIST
10181: PUSH
10182: LD_INT 24
10184: PUSH
10185: LD_INT 3
10187: PUSH
10188: LD_INT 3
10190: PUSH
10191: LD_INT 46
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 24
10202: PUSH
10203: LD_INT 3
10205: PUSH
10206: LD_INT 3
10208: PUSH
10209: LD_INT 46
10211: PUSH
10212: EMPTY
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: PUSH
10218: LD_INT 24
10220: PUSH
10221: LD_INT 3
10223: PUSH
10224: LD_INT 3
10226: PUSH
10227: LD_INT 46
10229: PUSH
10230: EMPTY
10231: LIST
10232: LIST
10233: LIST
10234: LIST
10235: PUSH
10236: EMPTY
10237: LIST
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: LIST
10243: PPUSH
10244: CALL 45648 0 2
// end ; if Difficulty > 1 then
10248: LD_OWVAR 67
10252: PUSH
10253: LD_INT 1
10255: GREATER
10256: IFFALSE 10286
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10258: LD_INT 2
10260: PPUSH
10261: LD_INT 24
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 47
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: EMPTY
10280: LIST
10281: PPUSH
10282: CALL 45648 0 2
// repeat wait ( 0 0$1 ) ;
10286: LD_INT 35
10288: PPUSH
10289: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10293: LD_INT 2
10295: PPUSH
10296: LD_INT 1
10298: PPUSH
10299: CALL 47066 0 2
10303: PUSH
10304: LD_INT 6
10306: PUSH
10307: LD_INT 7
10309: PUSH
10310: LD_INT 7
10312: PUSH
10313: LD_INT 7
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: PUSH
10322: LD_OWVAR 67
10326: ARRAY
10327: GREATEREQUAL
10328: IFFALSE 10286
// wait ( 0 0$30 ) ;
10330: LD_INT 1050
10332: PPUSH
10333: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10337: LD_ADDR_VAR 0 2
10341: PUSH
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 1
10347: PPUSH
10348: CALL 47066 0 2
10352: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10353: LD_ADDR_EXP 115
10357: PUSH
10358: LD_EXP 115
10362: PPUSH
10363: LD_INT 2
10365: PPUSH
10366: LD_EXP 115
10370: PUSH
10371: LD_INT 2
10373: ARRAY
10374: PUSH
10375: LD_VAR 0 2
10379: DIFF
10380: PPUSH
10381: CALL_OW 1
10385: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10386: LD_ADDR_VAR 0 3
10390: PUSH
10391: LD_INT 0
10393: PPUSH
10394: LD_INT 1
10396: PPUSH
10397: CALL_OW 12
10401: ST_TO_ADDR
// if target then
10402: LD_VAR 0 3
10406: IFFALSE 10534
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10408: LD_ADDR_VAR 0 2
10412: PUSH
10413: LD_VAR 0 2
10417: PPUSH
10418: LD_INT 24
10420: PUSH
10421: LD_INT 250
10423: PUSH
10424: EMPTY
10425: LIST
10426: LIST
10427: PPUSH
10428: CALL_OW 72
10432: ST_TO_ADDR
// for i in tmp do
10433: LD_ADDR_VAR 0 1
10437: PUSH
10438: LD_VAR 0 2
10442: PUSH
10443: FOR_IN
10444: IFFALSE 10484
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10446: LD_VAR 0 1
10450: PPUSH
10451: LD_INT 139
10453: PPUSH
10454: LD_INT 89
10456: PPUSH
10457: CALL_OW 297
10461: PUSH
10462: LD_INT 9
10464: GREATER
10465: IFFALSE 10482
// ComMoveXY ( i , 139 , 89 ) ;
10467: LD_VAR 0 1
10471: PPUSH
10472: LD_INT 139
10474: PPUSH
10475: LD_INT 89
10477: PPUSH
10478: CALL_OW 111
10482: GO 10443
10484: POP
10485: POP
// wait ( 0 0$1 ) ;
10486: LD_INT 35
10488: PPUSH
10489: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10493: LD_VAR 0 2
10497: PPUSH
10498: LD_INT 92
10500: PUSH
10501: LD_INT 139
10503: PUSH
10504: LD_INT 89
10506: PUSH
10507: LD_INT 9
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: LIST
10514: LIST
10515: PPUSH
10516: CALL_OW 72
10520: PUSH
10521: LD_VAR 0 2
10525: PUSH
10526: LD_INT 1
10528: MINUS
10529: GREATEREQUAL
10530: IFFALSE 10408
// end else
10532: GO 10676
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10534: LD_VAR 0 2
10538: PPUSH
10539: LD_VAR 0 4
10543: PUSH
10544: LD_INT 1
10546: ARRAY
10547: PPUSH
10548: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10552: LD_ADDR_VAR 0 2
10556: PUSH
10557: LD_VAR 0 2
10561: PPUSH
10562: LD_INT 24
10564: PUSH
10565: LD_INT 250
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: PPUSH
10572: CALL_OW 72
10576: ST_TO_ADDR
// for i in tmp do
10577: LD_ADDR_VAR 0 1
10581: PUSH
10582: LD_VAR 0 2
10586: PUSH
10587: FOR_IN
10588: IFFALSE 10628
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10590: LD_VAR 0 1
10594: PPUSH
10595: LD_INT 124
10597: PPUSH
10598: LD_INT 139
10600: PPUSH
10601: CALL_OW 297
10605: PUSH
10606: LD_INT 9
10608: GREATER
10609: IFFALSE 10626
// ComMoveXY ( i , 124 , 139 ) ;
10611: LD_VAR 0 1
10615: PPUSH
10616: LD_INT 124
10618: PPUSH
10619: LD_INT 139
10621: PPUSH
10622: CALL_OW 111
10626: GO 10587
10628: POP
10629: POP
// wait ( 0 0$1 ) ;
10630: LD_INT 35
10632: PPUSH
10633: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10637: LD_VAR 0 2
10641: PPUSH
10642: LD_INT 92
10644: PUSH
10645: LD_INT 124
10647: PUSH
10648: LD_INT 139
10650: PUSH
10651: LD_INT 9
10653: PUSH
10654: EMPTY
10655: LIST
10656: LIST
10657: LIST
10658: LIST
10659: PPUSH
10660: CALL_OW 72
10664: PUSH
10665: LD_VAR 0 2
10669: PUSH
10670: LD_INT 1
10672: MINUS
10673: GREATEREQUAL
10674: IFFALSE 10552
// end ; repeat wait ( 0 0$1 ) ;
10676: LD_INT 35
10678: PPUSH
10679: CALL_OW 67
// for i in tmp do
10683: LD_ADDR_VAR 0 1
10687: PUSH
10688: LD_VAR 0 2
10692: PUSH
10693: FOR_IN
10694: IFFALSE 10827
// begin if GetLives ( i ) > 251 then
10696: LD_VAR 0 1
10700: PPUSH
10701: CALL_OW 256
10705: PUSH
10706: LD_INT 251
10708: GREATER
10709: IFFALSE 10798
// begin if GetWeapon ( i ) = ru_time_lapser then
10711: LD_VAR 0 1
10715: PPUSH
10716: CALL_OW 264
10720: PUSH
10721: LD_INT 49
10723: EQUAL
10724: IFFALSE 10762
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10726: LD_VAR 0 1
10730: PPUSH
10731: LD_INT 81
10733: PUSH
10734: LD_INT 3
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PPUSH
10741: CALL_OW 69
10745: PPUSH
10746: LD_VAR 0 1
10750: PPUSH
10751: CALL_OW 74
10755: PPUSH
10756: CALL_OW 112
10760: GO 10796
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10762: LD_VAR 0 1
10766: PPUSH
10767: LD_INT 81
10769: PUSH
10770: LD_INT 3
10772: PUSH
10773: EMPTY
10774: LIST
10775: LIST
10776: PPUSH
10777: CALL_OW 69
10781: PPUSH
10782: LD_VAR 0 1
10786: PPUSH
10787: CALL_OW 74
10791: PPUSH
10792: CALL_OW 115
// end else
10796: GO 10825
// if IsDead ( i ) then
10798: LD_VAR 0 1
10802: PPUSH
10803: CALL_OW 301
10807: IFFALSE 10825
// tmp := tmp diff i ;
10809: LD_ADDR_VAR 0 2
10813: PUSH
10814: LD_VAR 0 2
10818: PUSH
10819: LD_VAR 0 1
10823: DIFF
10824: ST_TO_ADDR
// end ;
10825: GO 10693
10827: POP
10828: POP
// until not tmp ;
10829: LD_VAR 0 2
10833: NOT
10834: IFFALSE 10676
// end ;
10836: PPOPN 4
10838: END
// every 30 30$00 trigger not russianDestroyed do
10839: LD_EXP 2
10843: NOT
10844: IFFALSE 10913
10846: GO 10848
10848: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10849: LD_INT 105000
10851: PUSH
10852: LD_INT 84000
10854: PUSH
10855: LD_INT 63000
10857: PUSH
10858: LD_INT 52500
10860: PUSH
10861: EMPTY
10862: LIST
10863: LIST
10864: LIST
10865: LIST
10866: PUSH
10867: LD_OWVAR 67
10871: ARRAY
10872: PPUSH
10873: CALL_OW 67
// if russianDestroyed then
10877: LD_EXP 2
10881: IFFALSE 10885
// exit ;
10883: GO 10913
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10885: LD_INT 2
10887: PPUSH
10888: LD_INT 23
10890: PUSH
10891: LD_INT 3
10893: PUSH
10894: LD_INT 1
10896: PUSH
10897: LD_INT 48
10899: PUSH
10900: EMPTY
10901: LIST
10902: LIST
10903: LIST
10904: LIST
10905: PUSH
10906: EMPTY
10907: LIST
10908: PPUSH
10909: CALL 45648 0 2
// end ; end_of_file
10913: END
// export function CustomEvent ( event ) ; begin
10914: LD_INT 0
10916: PPUSH
// end ;
10917: LD_VAR 0 2
10921: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10922: LD_VAR 0 2
10926: PPUSH
10927: LD_VAR 0 3
10931: PPUSH
10932: LD_INT 15
10934: PPUSH
10935: CALL_OW 309
10939: IFFALSE 10948
// YouLost ( MothContaminate ) ;
10941: LD_STRING MothContaminate
10943: PPUSH
10944: CALL_OW 104
// end ;
10948: PPOPN 3
10950: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10951: LD_VAR 0 2
10955: PPUSH
10956: LD_VAR 0 3
10960: PPUSH
10961: LD_INT 15
10963: PPUSH
10964: CALL_OW 309
10968: IFFALSE 10984
// begin wait ( 0 0$6 ) ;
10970: LD_INT 210
10972: PPUSH
10973: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10977: LD_STRING MothContaminateBomb
10979: PPUSH
10980: CALL_OW 104
// end ; end ;
10984: PPOPN 3
10986: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10987: LD_VAR 0 1
10991: PPUSH
10992: CALL 106976 0 1
// if un = JMM then
10996: LD_VAR 0 1
11000: PUSH
11001: LD_EXP 19
11005: EQUAL
11006: IFFALSE 11017
// begin YouLost ( JMM ) ;
11008: LD_STRING JMM
11010: PPUSH
11011: CALL_OW 104
// exit ;
11015: GO 11146
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11017: LD_VAR 0 1
11021: PPUSH
11022: CALL_OW 255
11026: PUSH
11027: LD_INT 2
11029: EQUAL
11030: PUSH
11031: LD_EXP 18
11035: NOT
11036: AND
11037: IFFALSE 11047
// arabianAttacked := true ;
11039: LD_ADDR_EXP 18
11043: PUSH
11044: LD_INT 1
11046: ST_TO_ADDR
// if un = Powell then
11047: LD_VAR 0 1
11051: PUSH
11052: LD_EXP 54
11056: EQUAL
11057: IFFALSE 11067
// americanDestroyed := true ;
11059: LD_ADDR_EXP 4
11063: PUSH
11064: LD_INT 1
11066: ST_TO_ADDR
// if un = Platonov then
11067: LD_VAR 0 1
11071: PUSH
11072: LD_EXP 58
11076: EQUAL
11077: IFFALSE 11087
// russianDestroyed := true ;
11079: LD_ADDR_EXP 2
11083: PUSH
11084: LD_INT 1
11086: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11087: LD_VAR 0 1
11091: PUSH
11092: LD_INT 22
11094: PUSH
11095: LD_INT 7
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: PUSH
11102: LD_INT 21
11104: PUSH
11105: LD_INT 2
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: PUSH
11112: EMPTY
11113: LIST
11114: LIST
11115: PPUSH
11116: CALL_OW 69
11120: IN
11121: IFFALSE 11137
// vehicleLostCounter := vehicleLostCounter + 1 ;
11123: LD_ADDR_EXP 15
11127: PUSH
11128: LD_EXP 15
11132: PUSH
11133: LD_INT 1
11135: PLUS
11136: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11137: LD_VAR 0 1
11141: PPUSH
11142: CALL 49068 0 1
// end ;
11146: PPOPN 1
11148: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11149: LD_VAR 0 1
11153: PPUSH
11154: LD_VAR 0 2
11158: PPUSH
11159: CALL 51402 0 2
// end ;
11163: PPOPN 2
11165: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11166: LD_VAR 0 1
11170: PPUSH
11171: CALL 50470 0 1
// end ;
11175: PPOPN 1
11177: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11178: LD_VAR 0 1
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 8
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PUSH
11193: LD_INT 30
11195: PUSH
11196: LD_INT 2
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: LD_INT 23
11205: PUSH
11206: LD_INT 3
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: LIST
11217: PPUSH
11218: CALL_OW 69
11222: IN
11223: IFFALSE 11250
// begin ComUpgrade ( building ) ;
11225: LD_VAR 0 1
11229: PPUSH
11230: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11234: LD_EXP 57
11238: PPUSH
11239: LD_VAR 0 1
11243: PPUSH
11244: CALL 60056 0 2
// exit ;
11248: GO 11259
// end ; MCE_BuildingComplete ( building ) ;
11250: LD_VAR 0 1
11254: PPUSH
11255: CALL 50711 0 1
// end ;
11259: PPOPN 1
11261: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11262: LD_VAR 0 1
11266: PPUSH
11267: LD_VAR 0 2
11271: PPUSH
11272: CALL 48764 0 2
// end ;
11276: PPOPN 2
11278: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11279: LD_VAR 0 1
11283: PPUSH
11284: LD_VAR 0 2
11288: PPUSH
11289: LD_VAR 0 3
11293: PPUSH
11294: LD_VAR 0 4
11298: PPUSH
11299: LD_VAR 0 5
11303: PPUSH
11304: CALL 48384 0 5
// end ;
11308: PPOPN 5
11310: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11311: LD_VAR 0 1
11315: PPUSH
11316: LD_VAR 0 2
11320: PPUSH
11321: CALL 107098 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11325: LD_VAR 0 1
11329: PPUSH
11330: LD_VAR 0 2
11334: PPUSH
11335: CALL 47965 0 2
// end ;
11339: PPOPN 2
11341: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11342: LD_VAR 0 1
11346: PPUSH
11347: LD_VAR 0 2
11351: PPUSH
11352: LD_VAR 0 3
11356: PPUSH
11357: LD_VAR 0 4
11361: PPUSH
11362: CALL 47803 0 4
// end ;
11366: PPOPN 4
11368: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11369: LD_VAR 0 1
11373: PPUSH
11374: LD_VAR 0 2
11378: PPUSH
11379: LD_VAR 0 3
11383: PPUSH
11384: CALL 47578 0 3
// end ;
11388: PPOPN 3
11390: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11391: LD_VAR 0 1
11395: PPUSH
11396: LD_VAR 0 2
11400: PPUSH
11401: CALL 47463 0 2
// end ;
11405: PPOPN 2
11407: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11408: LD_VAR 0 1
11412: PPUSH
11413: LD_VAR 0 2
11417: PPUSH
11418: CALL 51697 0 2
// end ;
11422: PPOPN 2
11424: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11425: LD_VAR 0 1
11429: PPUSH
11430: LD_VAR 0 2
11434: PPUSH
11435: LD_VAR 0 3
11439: PPUSH
11440: LD_VAR 0 4
11444: PPUSH
11445: CALL 51913 0 4
// end ;
11449: PPOPN 4
11451: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11452: LD_VAR 0 1
11456: PPUSH
11457: LD_VAR 0 2
11461: PPUSH
11462: CALL 47272 0 2
// end ;
11466: PPOPN 2
11468: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11469: LD_VAR 0 1
11473: PPUSH
11474: CALL 107082 0 1
// end ; end_of_file
11478: PPOPN 1
11480: END
// export function Action ; begin
11481: LD_INT 0
11483: PPUSH
// InGameOn ;
11484: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11488: LD_INT 206
11490: PPUSH
11491: LD_INT 11
11493: PPUSH
11494: CALL_OW 86
// wait ( 0 0$1 ) ;
11498: LD_INT 35
11500: PPUSH
11501: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11505: LD_EXP 19
11509: PPUSH
11510: LD_STRING DStart-JMM-JMM-1
11512: PPUSH
11513: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11517: LD_EXP 51
11521: PPUSH
11522: LD_STRING DStart-JMM-Bur-1
11524: PPUSH
11525: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11529: LD_EXP 19
11533: PPUSH
11534: LD_STRING DStart-JMM-JMM-2
11536: PPUSH
11537: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11541: LD_EXP 51
11545: PPUSH
11546: LD_STRING DStart-JMM-Bur-2
11548: PPUSH
11549: CALL_OW 88
// InGameOff ;
11553: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11557: LD_STRING MStart
11559: PPUSH
11560: CALL_OW 337
// SaveForQuickRestart ;
11564: CALL_OW 22
// end ;
11568: LD_VAR 0 1
11572: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11573: LD_INT 7
11575: PPUSH
11576: LD_INT 255
11578: PPUSH
11579: LD_INT 219
11581: PPUSH
11582: CALL_OW 293
11586: IFFALSE 12195
11588: GO 11590
11590: DISABLE
11591: LD_INT 0
11593: PPUSH
// begin wait ( 0 0$3 ) ;
11594: LD_INT 105
11596: PPUSH
11597: CALL_OW 67
// alienSpotted := true ;
11601: LD_ADDR_EXP 10
11605: PUSH
11606: LD_INT 1
11608: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11609: LD_ADDR_VAR 0 1
11613: PUSH
11614: LD_INT 22
11616: PUSH
11617: LD_INT 7
11619: PUSH
11620: EMPTY
11621: LIST
11622: LIST
11623: PUSH
11624: LD_INT 23
11626: PUSH
11627: LD_INT 3
11629: PUSH
11630: EMPTY
11631: LIST
11632: LIST
11633: PUSH
11634: LD_INT 21
11636: PUSH
11637: LD_INT 1
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PUSH
11644: LD_INT 26
11646: PUSH
11647: LD_INT 1
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: PUSH
11654: EMPTY
11655: LIST
11656: LIST
11657: LIST
11658: LIST
11659: PPUSH
11660: CALL_OW 69
11664: PUSH
11665: LD_EXP 51
11669: PUSH
11670: LD_EXP 39
11674: PUSH
11675: LD_EXP 41
11679: PUSH
11680: LD_EXP 42
11684: PUSH
11685: LD_EXP 49
11689: PUSH
11690: LD_EXP 48
11694: PUSH
11695: LD_EXP 43
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: DIFF
11709: ST_TO_ADDR
// DialogueOn ;
11710: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11714: LD_INT 255
11716: PPUSH
11717: LD_INT 219
11719: PPUSH
11720: LD_INT 7
11722: PPUSH
11723: LD_INT 20
11725: NEG
11726: PPUSH
11727: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11731: LD_INT 255
11733: PPUSH
11734: LD_INT 219
11736: PPUSH
11737: CALL_OW 86
// if speaker then
11741: LD_VAR 0 1
11745: IFFALSE 11763
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11747: LD_VAR 0 1
11751: PUSH
11752: LD_INT 1
11754: ARRAY
11755: PPUSH
11756: LD_STRING DAlienBase-RSol1-1
11758: PPUSH
11759: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11763: LD_EXP 19
11767: PPUSH
11768: LD_STRING DAlienBase-JMM-1
11770: PPUSH
11771: CALL_OW 88
// if IsOk ( Burlak ) then
11775: LD_EXP 51
11779: PPUSH
11780: CALL_OW 302
11784: IFFALSE 11805
// begin dwait ( 0 0$1 ) ;
11786: LD_INT 35
11788: PPUSH
11789: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11793: LD_EXP 51
11797: PPUSH
11798: LD_STRING DAlienBase-Bur-1
11800: PPUSH
11801: CALL_OW 88
// end ; if IsOk ( Roth ) then
11805: LD_EXP 20
11809: PPUSH
11810: CALL_OW 302
11814: IFFALSE 11828
// Say ( Roth , DAlienBase-Roth-1 ) ;
11816: LD_EXP 20
11820: PPUSH
11821: LD_STRING DAlienBase-Roth-1
11823: PPUSH
11824: CALL_OW 88
// if IsOk ( Gossudarov ) then
11828: LD_EXP 37
11832: PPUSH
11833: CALL_OW 302
11837: IFFALSE 11853
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11839: LD_EXP 37
11843: PPUSH
11844: LD_STRING DAlienBase-Gos-1
11846: PPUSH
11847: CALL_OW 88
11851: GO 11970
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11853: LD_ADDR_VAR 0 1
11857: PUSH
11858: LD_INT 22
11860: PUSH
11861: LD_INT 7
11863: PUSH
11864: EMPTY
11865: LIST
11866: LIST
11867: PUSH
11868: LD_INT 25
11870: PUSH
11871: LD_INT 4
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: PUSH
11878: LD_INT 21
11880: PUSH
11881: LD_INT 1
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: PUSH
11888: LD_INT 26
11890: PUSH
11891: LD_INT 1
11893: PUSH
11894: EMPTY
11895: LIST
11896: LIST
11897: PUSH
11898: EMPTY
11899: LIST
11900: LIST
11901: LIST
11902: LIST
11903: PPUSH
11904: CALL_OW 69
11908: PUSH
11909: LD_EXP 20
11913: PUSH
11914: LD_EXP 19
11918: PUSH
11919: LD_EXP 51
11923: PUSH
11924: LD_EXP 39
11928: PUSH
11929: LD_EXP 49
11933: PUSH
11934: LD_EXP 48
11938: PUSH
11939: EMPTY
11940: LIST
11941: LIST
11942: LIST
11943: LIST
11944: LIST
11945: LIST
11946: DIFF
11947: ST_TO_ADDR
// if speaker then
11948: LD_VAR 0 1
11952: IFFALSE 11970
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11954: LD_VAR 0 1
11958: PUSH
11959: LD_INT 1
11961: ARRAY
11962: PPUSH
11963: LD_STRING DAlienBase-Sci1-1
11965: PPUSH
11966: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11970: LD_INT 255
11972: PPUSH
11973: LD_INT 219
11975: PPUSH
11976: LD_INT 7
11978: PPUSH
11979: CALL_OW 331
// DialogueOff ;
11983: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11987: LD_INT 35
11989: PPUSH
11990: CALL_OW 67
// until IsSelected ( alien ) ;
11994: LD_INT 1
11996: PPUSH
11997: CALL_OW 306
12001: IFFALSE 11987
// if not artifactIResearched or not artifactIIResearched then
12003: LD_EXP 12
12007: NOT
12008: PUSH
12009: LD_EXP 13
12013: NOT
12014: OR
12015: IFFALSE 12195
// begin if IsOk ( Roth ) then
12017: LD_EXP 20
12021: PPUSH
12022: CALL_OW 302
12026: IFFALSE 12042
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12028: LD_EXP 20
12032: PPUSH
12033: LD_STRING DAlieBaseNotReady-Roth-1
12035: PPUSH
12036: CALL_OW 88
12040: GO 12195
// if IsOk ( Gossudarov ) then
12042: LD_EXP 37
12046: PPUSH
12047: CALL_OW 302
12051: IFFALSE 12067
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12053: LD_EXP 37
12057: PPUSH
12058: LD_STRING DAlieBaseNotReady-Gos-1
12060: PPUSH
12061: CALL_OW 88
12065: GO 12195
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12067: LD_ADDR_VAR 0 1
12071: PUSH
12072: LD_INT 22
12074: PUSH
12075: LD_INT 7
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: LD_INT 23
12084: PUSH
12085: LD_INT 3
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: PUSH
12092: LD_INT 25
12094: PUSH
12095: LD_INT 4
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PUSH
12102: LD_INT 21
12104: PUSH
12105: LD_INT 1
12107: PUSH
12108: EMPTY
12109: LIST
12110: LIST
12111: PUSH
12112: LD_INT 26
12114: PUSH
12115: LD_INT 1
12117: PUSH
12118: EMPTY
12119: LIST
12120: LIST
12121: PUSH
12122: EMPTY
12123: LIST
12124: LIST
12125: LIST
12126: LIST
12127: LIST
12128: PPUSH
12129: CALL_OW 69
12133: PUSH
12134: LD_EXP 20
12138: PUSH
12139: LD_EXP 19
12143: PUSH
12144: LD_EXP 51
12148: PUSH
12149: LD_EXP 39
12153: PUSH
12154: LD_EXP 49
12158: PUSH
12159: LD_EXP 48
12163: PUSH
12164: EMPTY
12165: LIST
12166: LIST
12167: LIST
12168: LIST
12169: LIST
12170: LIST
12171: DIFF
12172: ST_TO_ADDR
// if speaker then
12173: LD_VAR 0 1
12177: IFFALSE 12195
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12179: LD_VAR 0 1
12183: PUSH
12184: LD_INT 1
12186: ARRAY
12187: PPUSH
12188: LD_STRING DAlieBaseNotReady-RSci1-1
12190: PPUSH
12191: CALL_OW 88
// end ; end ; end ;
12195: PPOPN 1
12197: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12198: LD_INT 24
12200: PPUSH
12201: LD_INT 7
12203: PPUSH
12204: CALL_OW 321
12208: PUSH
12209: LD_INT 2
12211: EQUAL
12212: IFFALSE 12903
12214: GO 12216
12216: DISABLE
12217: LD_INT 0
12219: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12220: LD_ADDR_VAR 0 1
12224: PUSH
12225: LD_INT 22
12227: PUSH
12228: LD_INT 7
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: LD_INT 23
12237: PUSH
12238: LD_INT 3
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: LD_INT 25
12247: PUSH
12248: LD_INT 4
12250: PUSH
12251: EMPTY
12252: LIST
12253: LIST
12254: PUSH
12255: LD_INT 21
12257: PUSH
12258: LD_INT 1
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PUSH
12265: LD_INT 26
12267: PUSH
12268: LD_INT 1
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: EMPTY
12276: LIST
12277: LIST
12278: LIST
12279: LIST
12280: LIST
12281: PPUSH
12282: CALL_OW 69
12286: PUSH
12287: LD_EXP 20
12291: PUSH
12292: LD_EXP 19
12296: PUSH
12297: LD_EXP 51
12301: PUSH
12302: LD_EXP 39
12306: PUSH
12307: LD_EXP 49
12311: PUSH
12312: LD_EXP 48
12316: PUSH
12317: EMPTY
12318: LIST
12319: LIST
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: DIFF
12325: ST_TO_ADDR
// if not speaker then
12326: LD_VAR 0 1
12330: NOT
12331: IFFALSE 12335
// exit ;
12333: GO 12903
// DialogueOn ;
12335: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12339: LD_VAR 0 1
12343: PUSH
12344: LD_INT 1
12346: ARRAY
12347: PPUSH
12348: LD_STRING DArtefTechnology-RSci1-1
12350: PPUSH
12351: CALL_OW 88
// if IsOk ( Burlak ) then
12355: LD_EXP 51
12359: PPUSH
12360: CALL_OW 302
12364: IFFALSE 12378
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12366: LD_EXP 51
12370: PPUSH
12371: LD_STRING DArtefTechnology-Bur-1
12373: PPUSH
12374: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12378: LD_VAR 0 1
12382: PUSH
12383: LD_INT 1
12385: ARRAY
12386: PPUSH
12387: LD_STRING DArtefTechnology-RSci1-2
12389: PPUSH
12390: CALL_OW 88
// if Denis then
12394: LD_EXP 25
12398: IFFALSE 12415
// speaker := [ Denis ] else
12400: LD_ADDR_VAR 0 1
12404: PUSH
12405: LD_EXP 25
12409: PUSH
12410: EMPTY
12411: LIST
12412: ST_TO_ADDR
12413: GO 12521
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12415: LD_ADDR_VAR 0 1
12419: PUSH
12420: LD_INT 22
12422: PUSH
12423: LD_INT 7
12425: PUSH
12426: EMPTY
12427: LIST
12428: LIST
12429: PUSH
12430: LD_INT 23
12432: PUSH
12433: LD_INT 1
12435: PUSH
12436: EMPTY
12437: LIST
12438: LIST
12439: PUSH
12440: LD_INT 25
12442: PUSH
12443: LD_INT 4
12445: PUSH
12446: EMPTY
12447: LIST
12448: LIST
12449: PUSH
12450: LD_INT 21
12452: PUSH
12453: LD_INT 1
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 26
12462: PUSH
12463: LD_INT 1
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: EMPTY
12471: LIST
12472: LIST
12473: LIST
12474: LIST
12475: LIST
12476: PPUSH
12477: CALL_OW 69
12481: PUSH
12482: LD_EXP 20
12486: PUSH
12487: LD_EXP 19
12491: PUSH
12492: LD_EXP 51
12496: PUSH
12497: LD_EXP 39
12501: PUSH
12502: LD_EXP 49
12506: PUSH
12507: LD_EXP 48
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: LIST
12516: LIST
12517: LIST
12518: LIST
12519: DIFF
12520: ST_TO_ADDR
// if speaker then
12521: LD_VAR 0 1
12525: IFFALSE 12543
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12527: LD_VAR 0 1
12531: PUSH
12532: LD_INT 1
12534: ARRAY
12535: PPUSH
12536: LD_STRING DArtefTechnology-Sci1-2
12538: PPUSH
12539: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12543: LD_ADDR_VAR 0 1
12547: PUSH
12548: LD_INT 22
12550: PUSH
12551: LD_INT 7
12553: PUSH
12554: EMPTY
12555: LIST
12556: LIST
12557: PUSH
12558: LD_INT 23
12560: PUSH
12561: LD_INT 3
12563: PUSH
12564: EMPTY
12565: LIST
12566: LIST
12567: PUSH
12568: LD_INT 25
12570: PUSH
12571: LD_INT 4
12573: PUSH
12574: EMPTY
12575: LIST
12576: LIST
12577: PUSH
12578: LD_INT 21
12580: PUSH
12581: LD_INT 1
12583: PUSH
12584: EMPTY
12585: LIST
12586: LIST
12587: PUSH
12588: LD_INT 26
12590: PUSH
12591: LD_INT 1
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: PPUSH
12605: CALL_OW 69
12609: PUSH
12610: LD_EXP 20
12614: PUSH
12615: LD_EXP 19
12619: PUSH
12620: LD_EXP 51
12624: PUSH
12625: LD_EXP 39
12629: PUSH
12630: LD_EXP 49
12634: PUSH
12635: LD_EXP 48
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: LIST
12644: LIST
12645: LIST
12646: LIST
12647: DIFF
12648: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12649: LD_VAR 0 1
12653: PUSH
12654: LD_EXP 9
12658: PUSH
12659: LD_EXP 5
12663: OR
12664: AND
12665: IFFALSE 12899
// begin if arabianDestroyed and IsOk ( Burlak ) then
12667: LD_EXP 5
12671: PUSH
12672: LD_EXP 51
12676: PPUSH
12677: CALL_OW 302
12681: AND
12682: IFFALSE 12698
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12684: LD_EXP 51
12688: PPUSH
12689: LD_STRING DArtefTechnology-Bur-2
12691: PPUSH
12692: CALL_OW 88
12696: GO 12710
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12698: LD_EXP 19
12702: PPUSH
12703: LD_STRING DArtefTechnology-JMM-2
12705: PPUSH
12706: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12710: LD_VAR 0 1
12714: PUSH
12715: LD_INT 1
12717: ARRAY
12718: PPUSH
12719: LD_STRING DArtefTechnology-RSci1-3
12721: PPUSH
12722: CALL_OW 88
// if Denis then
12726: LD_EXP 25
12730: IFFALSE 12747
// speaker := [ Denis ] else
12732: LD_ADDR_VAR 0 1
12736: PUSH
12737: LD_EXP 25
12741: PUSH
12742: EMPTY
12743: LIST
12744: ST_TO_ADDR
12745: GO 12853
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12747: LD_ADDR_VAR 0 1
12751: PUSH
12752: LD_INT 22
12754: PUSH
12755: LD_INT 7
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: LD_INT 23
12764: PUSH
12765: LD_INT 1
12767: PUSH
12768: EMPTY
12769: LIST
12770: LIST
12771: PUSH
12772: LD_INT 25
12774: PUSH
12775: LD_INT 4
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: PUSH
12782: LD_INT 21
12784: PUSH
12785: LD_INT 1
12787: PUSH
12788: EMPTY
12789: LIST
12790: LIST
12791: PUSH
12792: LD_INT 26
12794: PUSH
12795: LD_INT 1
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: PPUSH
12809: CALL_OW 69
12813: PUSH
12814: LD_EXP 20
12818: PUSH
12819: LD_EXP 19
12823: PUSH
12824: LD_EXP 51
12828: PUSH
12829: LD_EXP 39
12833: PUSH
12834: LD_EXP 49
12838: PUSH
12839: LD_EXP 48
12843: PUSH
12844: EMPTY
12845: LIST
12846: LIST
12847: LIST
12848: LIST
12849: LIST
12850: LIST
12851: DIFF
12852: ST_TO_ADDR
// if speaker then
12853: LD_VAR 0 1
12857: IFFALSE 12899
// if alienSpotted then
12859: LD_EXP 10
12863: IFFALSE 12883
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12865: LD_VAR 0 1
12869: PUSH
12870: LD_INT 1
12872: ARRAY
12873: PPUSH
12874: LD_STRING DArtefTechnology-Sci1-3
12876: PPUSH
12877: CALL_OW 88
12881: GO 12899
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12883: LD_VAR 0 1
12887: PUSH
12888: LD_INT 1
12890: ARRAY
12891: PPUSH
12892: LD_STRING DArtefTechnology-Sci1-3a
12894: PPUSH
12895: CALL_OW 88
// end ; DialogueOff ;
12899: CALL_OW 7
// end ;
12903: PPOPN 1
12905: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12906: LD_EXP 12
12910: IFFALSE 13113
12912: GO 12914
12914: DISABLE
12915: LD_INT 0
12917: PPUSH
// begin if Denis then
12918: LD_EXP 25
12922: IFFALSE 12939
// speaker := [ Denis ] else
12924: LD_ADDR_VAR 0 1
12928: PUSH
12929: LD_EXP 25
12933: PUSH
12934: EMPTY
12935: LIST
12936: ST_TO_ADDR
12937: GO 13045
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12939: LD_ADDR_VAR 0 1
12943: PUSH
12944: LD_INT 22
12946: PUSH
12947: LD_INT 7
12949: PUSH
12950: EMPTY
12951: LIST
12952: LIST
12953: PUSH
12954: LD_INT 23
12956: PUSH
12957: LD_INT 1
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 25
12966: PUSH
12967: LD_INT 4
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 21
12976: PUSH
12977: LD_INT 1
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: PUSH
12984: LD_INT 26
12986: PUSH
12987: LD_INT 1
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: PPUSH
13001: CALL_OW 69
13005: PUSH
13006: LD_EXP 20
13010: PUSH
13011: LD_EXP 19
13015: PUSH
13016: LD_EXP 51
13020: PUSH
13021: LD_EXP 39
13025: PUSH
13026: LD_EXP 49
13030: PUSH
13031: LD_EXP 48
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: LIST
13042: LIST
13043: DIFF
13044: ST_TO_ADDR
// if not speaker then
13045: LD_VAR 0 1
13049: NOT
13050: IFFALSE 13054
// exit ;
13052: GO 13113
// DialogueOn ;
13054: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13058: LD_VAR 0 1
13062: PUSH
13063: LD_INT 1
13065: ARRAY
13066: PPUSH
13067: LD_STRING DArtefTechnologyAm-Sci1-1
13069: PPUSH
13070: CALL_OW 88
// if IsOk ( Burlak ) then
13074: LD_EXP 51
13078: PPUSH
13079: CALL_OW 302
13083: IFFALSE 13097
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13085: LD_EXP 51
13089: PPUSH
13090: LD_STRING DArtefTechnologyAm-Bur-1
13092: PPUSH
13093: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13097: LD_EXP 19
13101: PPUSH
13102: LD_STRING DArtefTechnologyAm-JMM-1
13104: PPUSH
13105: CALL_OW 88
// DialogueOff ;
13109: CALL_OW 7
// end ;
13113: PPOPN 1
13115: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13116: LD_EXP 13
13120: IFFALSE 13322
13122: GO 13124
13124: DISABLE
13125: LD_INT 0
13127: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13128: LD_ADDR_VAR 0 1
13132: PUSH
13133: LD_INT 22
13135: PUSH
13136: LD_INT 7
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: PUSH
13143: LD_INT 23
13145: PUSH
13146: LD_INT 3
13148: PUSH
13149: EMPTY
13150: LIST
13151: LIST
13152: PUSH
13153: LD_INT 25
13155: PUSH
13156: LD_INT 4
13158: PUSH
13159: EMPTY
13160: LIST
13161: LIST
13162: PUSH
13163: LD_INT 21
13165: PUSH
13166: LD_INT 1
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: PUSH
13173: LD_INT 26
13175: PUSH
13176: LD_INT 1
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: PUSH
13183: EMPTY
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PPUSH
13190: CALL_OW 69
13194: PUSH
13195: LD_EXP 20
13199: PUSH
13200: LD_EXP 19
13204: PUSH
13205: LD_EXP 51
13209: PUSH
13210: LD_EXP 39
13214: PUSH
13215: LD_EXP 49
13219: PUSH
13220: LD_EXP 48
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: DIFF
13233: ST_TO_ADDR
// if not speaker then
13234: LD_VAR 0 1
13238: NOT
13239: IFFALSE 13243
// exit ;
13241: GO 13322
// DialogueOn ;
13243: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13247: LD_VAR 0 1
13251: PUSH
13252: LD_VAR 0 1
13256: ARRAY
13257: PPUSH
13258: LD_STRING DArtefTechnologyRu-RSci1-1
13260: PPUSH
13261: CALL_OW 88
// if IsOk ( Burlak ) then
13265: LD_EXP 51
13269: PPUSH
13270: CALL_OW 302
13274: IFFALSE 13288
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13276: LD_EXP 51
13280: PPUSH
13281: LD_STRING DArtefTechnologyRu-Bur-1
13283: PPUSH
13284: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13288: LD_VAR 0 1
13292: PUSH
13293: LD_VAR 0 1
13297: ARRAY
13298: PPUSH
13299: LD_STRING DArtefTechnologyRu-RSci1-2
13301: PPUSH
13302: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13306: LD_EXP 19
13310: PPUSH
13311: LD_STRING DArtefTechnologyRu-JMM-1
13313: PPUSH
13314: CALL_OW 88
// DialogueOff ;
13318: CALL_OW 7
// end ;
13322: PPOPN 1
13324: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13325: LD_INT 24
13327: PPUSH
13328: LD_INT 7
13330: PPUSH
13331: CALL_OW 321
13335: PUSH
13336: LD_INT 2
13338: EQUAL
13339: PUSH
13340: LD_INT 1
13342: PPUSH
13343: CALL_OW 255
13347: PUSH
13348: LD_INT 7
13350: EQUAL
13351: AND
13352: IFFALSE 13520
13354: GO 13356
13356: DISABLE
13357: LD_INT 0
13359: PPUSH
// begin if Denis then
13360: LD_EXP 25
13364: IFFALSE 13381
// speaker := [ Denis ] else
13366: LD_ADDR_VAR 0 1
13370: PUSH
13371: LD_EXP 25
13375: PUSH
13376: EMPTY
13377: LIST
13378: ST_TO_ADDR
13379: GO 13487
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13381: LD_ADDR_VAR 0 1
13385: PUSH
13386: LD_INT 22
13388: PUSH
13389: LD_INT 7
13391: PUSH
13392: EMPTY
13393: LIST
13394: LIST
13395: PUSH
13396: LD_INT 23
13398: PUSH
13399: LD_INT 1
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PUSH
13406: LD_INT 25
13408: PUSH
13409: LD_INT 4
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PUSH
13416: LD_INT 21
13418: PUSH
13419: LD_INT 1
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PUSH
13426: LD_INT 26
13428: PUSH
13429: LD_INT 1
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: LIST
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 69
13447: PUSH
13448: LD_EXP 20
13452: PUSH
13453: LD_EXP 19
13457: PUSH
13458: LD_EXP 51
13462: PUSH
13463: LD_EXP 39
13467: PUSH
13468: LD_EXP 49
13472: PUSH
13473: LD_EXP 48
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: LIST
13482: LIST
13483: LIST
13484: LIST
13485: DIFF
13486: ST_TO_ADDR
// if not speaker then
13487: LD_VAR 0 1
13491: NOT
13492: IFFALSE 13496
// exit ;
13494: GO 13520
// DialogueOn ;
13496: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13500: LD_VAR 0 1
13504: PUSH
13505: LD_INT 1
13507: ARRAY
13508: PPUSH
13509: LD_STRING DArtefTechnologyArStart-Sci1-1
13511: PPUSH
13512: CALL_OW 88
// DialogueOff ;
13516: CALL_OW 7
// end ;
13520: PPOPN 1
13522: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13523: LD_EXP 14
13527: IFFALSE 13808
13529: GO 13531
13531: DISABLE
13532: LD_INT 0
13534: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13535: LD_ADDR_VAR 0 1
13539: PUSH
13540: LD_INT 22
13542: PUSH
13543: LD_INT 7
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: PUSH
13550: LD_INT 23
13552: PUSH
13553: LD_INT 3
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PUSH
13560: LD_INT 25
13562: PUSH
13563: LD_INT 4
13565: PUSH
13566: EMPTY
13567: LIST
13568: LIST
13569: PUSH
13570: LD_INT 21
13572: PUSH
13573: LD_INT 1
13575: PUSH
13576: EMPTY
13577: LIST
13578: LIST
13579: PUSH
13580: LD_INT 26
13582: PUSH
13583: LD_INT 1
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: LIST
13594: LIST
13595: LIST
13596: PPUSH
13597: CALL_OW 69
13601: PUSH
13602: LD_EXP 20
13606: PUSH
13607: LD_EXP 19
13611: PUSH
13612: LD_EXP 51
13616: PUSH
13617: LD_EXP 39
13621: PUSH
13622: LD_EXP 49
13626: PUSH
13627: LD_EXP 48
13631: PUSH
13632: EMPTY
13633: LIST
13634: LIST
13635: LIST
13636: LIST
13637: LIST
13638: LIST
13639: DIFF
13640: ST_TO_ADDR
// if not speaker then
13641: LD_VAR 0 1
13645: NOT
13646: IFFALSE 13650
// exit ;
13648: GO 13808
// DialogueOn ;
13650: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13654: LD_VAR 0 1
13658: PUSH
13659: LD_INT 1
13661: ARRAY
13662: PPUSH
13663: LD_STRING DArtefTechnologyAr-RSci1-1
13665: PPUSH
13666: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13670: LD_EXP 19
13674: PPUSH
13675: LD_STRING DArtefTechnologyAr-JMM-1
13677: PPUSH
13678: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13682: LD_VAR 0 1
13686: PUSH
13687: LD_INT 1
13689: ARRAY
13690: PPUSH
13691: LD_STRING DArtefTechnologyAr-RSci1-2
13693: PPUSH
13694: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13698: LD_EXP 19
13702: PPUSH
13703: LD_STRING DArtefTechnologyAr-JMM-2
13705: PPUSH
13706: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13710: LD_VAR 0 1
13714: PUSH
13715: LD_INT 1
13717: ARRAY
13718: PPUSH
13719: LD_STRING DArtefTechnologyAr-RSci1-3
13721: PPUSH
13722: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13726: LD_EXP 19
13730: PPUSH
13731: LD_STRING DArtefTechnologyAr-JMM-3
13733: PPUSH
13734: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13738: LD_VAR 0 1
13742: PUSH
13743: LD_INT 1
13745: ARRAY
13746: PPUSH
13747: LD_STRING DArtefTechnologyAr-RSci1-4
13749: PPUSH
13750: CALL_OW 88
// if IsOk ( Burlak ) then
13754: LD_EXP 51
13758: PPUSH
13759: CALL_OW 302
13763: IFFALSE 13777
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13765: LD_EXP 51
13769: PPUSH
13770: LD_STRING DArtefTechnologyAr-Bur-4
13772: PPUSH
13773: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13777: LD_EXP 19
13781: PPUSH
13782: LD_STRING DArtefTechnologyAr-JMM-4
13784: PPUSH
13785: CALL_OW 88
// DialogueOff ;
13789: CALL_OW 7
// wait ( 0 0$45 ) ;
13793: LD_INT 1575
13795: PPUSH
13796: CALL_OW 67
// spawnOmar := true ;
13800: LD_ADDR_EXP 11
13804: PUSH
13805: LD_INT 1
13807: ST_TO_ADDR
// end ;
13808: PPOPN 1
13810: END
// every 0 0$1 trigger spawnOmar do
13811: LD_EXP 11
13815: IFFALSE 14195
13817: GO 13819
13819: DISABLE
// begin PrepareOmarAli ;
13820: CALL 7201 0 0
// if not HasTask ( Omar ) then
13824: LD_EXP 55
13828: PPUSH
13829: CALL_OW 314
13833: NOT
13834: IFFALSE 13851
// ComMoveXY ( Omar , 252 , 220 ) ;
13836: LD_EXP 55
13840: PPUSH
13841: LD_INT 252
13843: PPUSH
13844: LD_INT 220
13846: PPUSH
13847: CALL_OW 111
// if not Omar then
13851: LD_EXP 55
13855: NOT
13856: IFFALSE 13860
// exit ;
13858: GO 14195
// repeat wait ( 0 0$1 ) ;
13860: LD_INT 35
13862: PPUSH
13863: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13867: LD_EXP 55
13871: PPUSH
13872: CALL_OW 314
13876: NOT
13877: PUSH
13878: LD_EXP 55
13882: PPUSH
13883: LD_INT 252
13885: PPUSH
13886: LD_INT 220
13888: PPUSH
13889: CALL_OW 297
13893: PUSH
13894: LD_INT 6
13896: GREATER
13897: AND
13898: IFFALSE 13915
// ComMoveXY ( Omar , 252 , 220 ) ;
13900: LD_EXP 55
13904: PPUSH
13905: LD_INT 252
13907: PPUSH
13908: LD_INT 220
13910: PPUSH
13911: CALL_OW 111
// until See ( 7 , Omar ) ;
13915: LD_INT 7
13917: PPUSH
13918: LD_EXP 55
13922: PPUSH
13923: CALL_OW 292
13927: IFFALSE 13860
// CenterNowOnUnits ( Omar ) ;
13929: LD_EXP 55
13933: PPUSH
13934: CALL_OW 87
// DialogueOn ;
13938: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13942: LD_EXP 55
13946: PPUSH
13947: LD_STRING DOmar-Omar-1
13949: PPUSH
13950: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13954: LD_EXP 19
13958: PPUSH
13959: LD_STRING DOmar-JMM-1
13961: PPUSH
13962: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13966: LD_EXP 55
13970: PPUSH
13971: LD_STRING DOmar-Omar-2
13973: PPUSH
13974: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13978: LD_EXP 19
13982: PPUSH
13983: LD_STRING DOmar-JMM-2
13985: PPUSH
13986: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13990: LD_EXP 55
13994: PPUSH
13995: LD_STRING DOmar-Omar-3
13997: PPUSH
13998: CALL_OW 88
// if IsOk ( Burlak ) then
14002: LD_EXP 51
14006: PPUSH
14007: CALL_OW 302
14011: IFFALSE 14027
// Say ( Burlak , DOmar-Bur-3 ) else
14013: LD_EXP 51
14017: PPUSH
14018: LD_STRING DOmar-Bur-3
14020: PPUSH
14021: CALL_OW 88
14025: GO 14039
// Say ( JMM , DOmar-JMM-3 ) ;
14027: LD_EXP 19
14031: PPUSH
14032: LD_STRING DOmar-JMM-3
14034: PPUSH
14035: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14039: LD_EXP 55
14043: PPUSH
14044: LD_STRING DOmar-Omar-4
14046: PPUSH
14047: CALL_OW 88
// case Query ( QAccept ) of 1 :
14051: LD_STRING QAccept
14053: PPUSH
14054: CALL_OW 97
14058: PUSH
14059: LD_INT 1
14061: DOUBLE
14062: EQUAL
14063: IFTRUE 14067
14065: GO 14103
14067: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14068: LD_EXP 19
14072: PPUSH
14073: LD_STRING DQrAccept#1-JMM-1
14075: PPUSH
14076: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14080: LD_EXP 55
14084: PPUSH
14085: LD_INT 7
14087: PPUSH
14088: CALL_OW 235
// ComStop ( Omar ) ;
14092: LD_EXP 55
14096: PPUSH
14097: CALL_OW 141
// end ; 2 :
14101: GO 14152
14103: LD_INT 2
14105: DOUBLE
14106: EQUAL
14107: IFTRUE 14111
14109: GO 14151
14111: POP
// begin if IsOk ( Burlak ) then
14112: LD_EXP 51
14116: PPUSH
14117: CALL_OW 302
14121: IFFALSE 14137
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14123: LD_EXP 51
14127: PPUSH
14128: LD_STRING DQrAccept#2-Bur-1
14130: PPUSH
14131: CALL_OW 88
14135: GO 14149
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14137: LD_EXP 19
14141: PPUSH
14142: LD_STRING DQrAccept#2-JMM-1
14144: PPUSH
14145: CALL_OW 88
// end ; end ;
14149: GO 14152
14151: POP
// DialogueOff ;
14152: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14156: LD_EXP 55
14160: PPUSH
14161: CALL_OW 255
14165: PUSH
14166: LD_INT 7
14168: EQUAL
14169: IFFALSE 14180
// begin SetAchievement ( ACH_OMAR ) ;
14171: LD_STRING ACH_OMAR
14173: PPUSH
14174: CALL_OW 543
// exit ;
14178: GO 14195
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14180: LD_EXP 55
14184: PPUSH
14185: LD_INT 202
14187: PPUSH
14188: LD_INT 115
14190: PPUSH
14191: CALL_OW 111
// end ;
14195: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14196: LD_EXP 55
14200: PPUSH
14201: LD_INT 200
14203: PPUSH
14204: LD_INT 98
14206: PPUSH
14207: CALL_OW 297
14211: PUSH
14212: LD_INT 40
14214: LESS
14215: PUSH
14216: LD_EXP 2
14220: AND
14221: IFFALSE 14439
14223: GO 14225
14225: DISABLE
// begin SetSide ( Omar , 5 ) ;
14226: LD_EXP 55
14230: PPUSH
14231: LD_INT 5
14233: PPUSH
14234: CALL_OW 235
// if IsInUnit ( Omar ) then
14238: LD_EXP 55
14242: PPUSH
14243: CALL_OW 310
14247: IFFALSE 14258
// ComExitVehicle ( Omar ) ;
14249: LD_EXP 55
14253: PPUSH
14254: CALL_OW 121
// if IsInUnit ( Omar ) then
14258: LD_EXP 55
14262: PPUSH
14263: CALL_OW 310
14267: IFFALSE 14278
// ComExitBuilding ( Omar ) ;
14269: LD_EXP 55
14273: PPUSH
14274: CALL_OW 122
// wait ( 0 0$1 ) ;
14278: LD_INT 35
14280: PPUSH
14281: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14285: LD_EXP 55
14289: PPUSH
14290: LD_INT 203
14292: PPUSH
14293: LD_INT 120
14295: PPUSH
14296: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14300: LD_INT 35
14302: PPUSH
14303: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14307: LD_EXP 55
14311: PPUSH
14312: CALL_OW 306
14316: PUSH
14317: LD_EXP 55
14321: PPUSH
14322: LD_INT 203
14324: PPUSH
14325: LD_INT 120
14327: PPUSH
14328: CALL_OW 297
14332: PUSH
14333: LD_INT 6
14335: LESS
14336: OR
14337: IFFALSE 14300
// CenterNowOnUnits ( Omar ) ;
14339: LD_EXP 55
14343: PPUSH
14344: CALL_OW 87
// DialogueOn ;
14348: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14352: LD_EXP 19
14356: PPUSH
14357: LD_STRING DOmarContam-JMM-1
14359: PPUSH
14360: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14364: LD_EXP 55
14368: PPUSH
14369: LD_STRING DOmarContam-Omar-1
14371: PPUSH
14372: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14376: LD_EXP 19
14380: PPUSH
14381: LD_STRING DOmarContam-JMM-2
14383: PPUSH
14384: CALL_OW 88
// DialogueOff ;
14388: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14392: LD_INT 5
14394: PPUSH
14395: LD_INT 7
14397: PPUSH
14398: LD_INT 2
14400: PPUSH
14401: LD_INT 1
14403: PPUSH
14404: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14408: LD_INT 105
14410: PPUSH
14411: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14415: LD_EXP 55
14419: PPUSH
14420: LD_INT 203
14422: PPUSH
14423: LD_INT 120
14425: PPUSH
14426: CALL_OW 307
14430: IFFALSE 14408
// YouLost ( MothContaminate ) ;
14432: LD_STRING MothContaminate
14434: PPUSH
14435: CALL_OW 104
// end ;
14439: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14440: LD_EXP 4
14444: NOT
14445: PUSH
14446: LD_INT 22
14448: PUSH
14449: LD_INT 1
14451: PUSH
14452: EMPTY
14453: LIST
14454: LIST
14455: PUSH
14456: LD_INT 34
14458: PUSH
14459: LD_INT 8
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PPUSH
14470: CALL_OW 69
14474: AND
14475: IFFALSE 14594
14477: GO 14479
14479: DISABLE
// begin wait ( 0 0$5 ) ;
14480: LD_INT 175
14482: PPUSH
14483: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14487: LD_EXP 54
14491: PPUSH
14492: CALL_OW 302
14496: NOT
14497: PUSH
14498: LD_INT 22
14500: PUSH
14501: LD_INT 1
14503: PUSH
14504: EMPTY
14505: LIST
14506: LIST
14507: PUSH
14508: LD_INT 34
14510: PUSH
14511: LD_INT 8
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: PUSH
14518: EMPTY
14519: LIST
14520: LIST
14521: PPUSH
14522: CALL_OW 69
14526: NOT
14527: OR
14528: IFFALSE 14532
// exit ;
14530: GO 14594
// DialogueOn ;
14532: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14536: LD_EXP 54
14540: PPUSH
14541: LD_STRING DWinAmericans-Pow-1
14543: PPUSH
14544: CALL_OW 94
// if IsOk ( Burlak ) then
14548: LD_EXP 51
14552: PPUSH
14553: CALL_OW 302
14557: IFFALSE 14571
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14559: LD_EXP 51
14563: PPUSH
14564: LD_STRING DWinAmericans-Bur-1
14566: PPUSH
14567: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14571: LD_EXP 19
14575: PPUSH
14576: LD_STRING DWinAmericans-JMM-1
14578: PPUSH
14579: CALL_OW 88
// DialogueOff ;
14583: CALL_OW 7
// YouLost ( AmBomb ) ;
14587: LD_STRING AmBomb
14589: PPUSH
14590: CALL_OW 104
// end ;
14594: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14595: LD_EXP 2
14599: NOT
14600: PUSH
14601: LD_INT 22
14603: PUSH
14604: LD_INT 3
14606: PUSH
14607: EMPTY
14608: LIST
14609: LIST
14610: PUSH
14611: LD_INT 34
14613: PUSH
14614: LD_INT 48
14616: PUSH
14617: EMPTY
14618: LIST
14619: LIST
14620: PUSH
14621: EMPTY
14622: LIST
14623: LIST
14624: PPUSH
14625: CALL_OW 69
14629: AND
14630: IFFALSE 14749
14632: GO 14634
14634: DISABLE
// begin wait ( 0 0$5 ) ;
14635: LD_INT 175
14637: PPUSH
14638: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14642: LD_EXP 58
14646: PPUSH
14647: CALL_OW 302
14651: NOT
14652: PUSH
14653: LD_INT 22
14655: PUSH
14656: LD_INT 3
14658: PUSH
14659: EMPTY
14660: LIST
14661: LIST
14662: PUSH
14663: LD_INT 34
14665: PUSH
14666: LD_INT 48
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PPUSH
14677: CALL_OW 69
14681: NOT
14682: OR
14683: IFFALSE 14687
// exit ;
14685: GO 14749
// DialogueOn ;
14687: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14691: LD_EXP 58
14695: PPUSH
14696: LD_STRING DWinRussians-Pla-1
14698: PPUSH
14699: CALL_OW 94
// if IsOk ( Burlak ) then
14703: LD_EXP 51
14707: PPUSH
14708: CALL_OW 302
14712: IFFALSE 14726
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14714: LD_EXP 51
14718: PPUSH
14719: LD_STRING DWinRussians-Bur-1
14721: PPUSH
14722: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14726: LD_EXP 19
14730: PPUSH
14731: LD_STRING DWinRussians-JMM-1
14733: PPUSH
14734: CALL_OW 88
// DialogueOff ;
14738: CALL_OW 7
// YouLost ( RuBomb ) ;
14742: LD_STRING RuBomb
14744: PPUSH
14745: CALL_OW 104
// end ;
14749: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14750: LD_INT 7
14752: PPUSH
14753: LD_INT 22
14755: PUSH
14756: LD_INT 7
14758: PUSH
14759: EMPTY
14760: LIST
14761: LIST
14762: PPUSH
14763: CALL_OW 70
14767: PUSH
14768: LD_EXP 4
14772: NOT
14773: AND
14774: IFFALSE 14803
14776: GO 14778
14778: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14779: LD_EXP 54
14783: PPUSH
14784: LD_STRING DSurrenderAmericans-Pow-1
14786: PPUSH
14787: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14791: LD_EXP 19
14795: PPUSH
14796: LD_STRING DSurrenderAmericans-JMM-1
14798: PPUSH
14799: CALL_OW 88
// end ;
14803: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14804: LD_INT 2
14806: PPUSH
14807: LD_INT 22
14809: PUSH
14810: LD_INT 7
14812: PUSH
14813: EMPTY
14814: LIST
14815: LIST
14816: PPUSH
14817: CALL_OW 70
14821: PUSH
14822: LD_EXP 2
14826: NOT
14827: AND
14828: PUSH
14829: LD_EXP 51
14833: AND
14834: IFFALSE 14863
14836: GO 14838
14838: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14839: LD_EXP 58
14843: PPUSH
14844: LD_STRING DSurrenderRussians-Pla-1
14846: PPUSH
14847: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14851: LD_EXP 51
14855: PPUSH
14856: LD_STRING DSurrenderRussians-Bur-1
14858: PPUSH
14859: CALL_OW 88
// end ;
14863: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14864: LD_EXP 4
14868: IFFALSE 15251
14870: GO 14872
14872: DISABLE
14873: LD_INT 0
14875: PPUSH
14876: PPUSH
14877: PPUSH
// begin MC_Kill ( 4 ) ;
14878: LD_INT 4
14880: PPUSH
14881: CALL 21670 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14885: LD_INT 1
14887: PPUSH
14888: LD_INT 7
14890: PPUSH
14891: LD_INT 1
14893: PPUSH
14894: LD_INT 1
14896: PPUSH
14897: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14901: LD_ADDR_VAR 0 3
14905: PUSH
14906: LD_INT 22
14908: PUSH
14909: LD_INT 1
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: PUSH
14916: LD_INT 26
14918: PUSH
14919: LD_INT 1
14921: PUSH
14922: EMPTY
14923: LIST
14924: LIST
14925: PUSH
14926: LD_INT 23
14928: PUSH
14929: LD_INT 1
14931: PUSH
14932: EMPTY
14933: LIST
14934: LIST
14935: PUSH
14936: EMPTY
14937: LIST
14938: LIST
14939: LIST
14940: PPUSH
14941: CALL_OW 69
14945: PUSH
14946: LD_EXP 54
14950: PUSH
14951: LD_EXP 27
14955: PUSH
14956: LD_EXP 24
14960: PUSH
14961: LD_EXP 23
14965: PUSH
14966: LD_EXP 30
14970: PUSH
14971: LD_EXP 28
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: LIST
14980: LIST
14981: LIST
14982: LIST
14983: DIFF
14984: ST_TO_ADDR
// if speaker then
14985: LD_VAR 0 3
14989: IFFALSE 15015
// begin DialogueOn ;
14991: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14995: LD_VAR 0 3
14999: PUSH
15000: LD_INT 1
15002: ARRAY
15003: PPUSH
15004: LD_STRING DSurrenderAmericans-Sol1-1a
15006: PPUSH
15007: CALL_OW 94
// DialogueOff ;
15011: CALL_OW 7
// end ; americanCapitulated := true ;
15015: LD_ADDR_EXP 6
15019: PUSH
15020: LD_INT 1
15022: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15023: LD_ADDR_VAR 0 2
15027: PUSH
15028: LD_INT 22
15030: PUSH
15031: LD_INT 1
15033: PUSH
15034: EMPTY
15035: LIST
15036: LIST
15037: PUSH
15038: LD_INT 21
15040: PUSH
15041: LD_INT 1
15043: PUSH
15044: EMPTY
15045: LIST
15046: LIST
15047: PUSH
15048: EMPTY
15049: LIST
15050: LIST
15051: PPUSH
15052: CALL_OW 69
15056: PUSH
15057: LD_INT 22
15059: PUSH
15060: LD_INT 1
15062: PUSH
15063: EMPTY
15064: LIST
15065: LIST
15066: PUSH
15067: LD_INT 21
15069: PUSH
15070: LD_INT 2
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: PUSH
15077: LD_INT 1
15079: PUSH
15080: EMPTY
15081: LIST
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: LIST
15087: PPUSH
15088: CALL_OW 69
15092: ADD
15093: ST_TO_ADDR
// if tmp then
15094: LD_VAR 0 2
15098: IFFALSE 15251
// repeat wait ( 0 0$1 ) ;
15100: LD_INT 35
15102: PPUSH
15103: CALL_OW 67
// for i in tmp do
15107: LD_ADDR_VAR 0 1
15111: PUSH
15112: LD_VAR 0 2
15116: PUSH
15117: FOR_IN
15118: IFFALSE 15200
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15120: LD_VAR 0 1
15124: PPUSH
15125: CALL_OW 310
15129: PUSH
15130: LD_VAR 0 1
15134: PPUSH
15135: CALL_OW 310
15139: PPUSH
15140: CALL_OW 247
15144: PUSH
15145: LD_INT 3
15147: EQUAL
15148: AND
15149: IFFALSE 15160
// ComExitBuilding ( i ) ;
15151: LD_VAR 0 1
15155: PPUSH
15156: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15160: LD_VAR 0 1
15164: PPUSH
15165: LD_INT 122
15167: PPUSH
15168: LD_INT 242
15170: PPUSH
15171: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15175: LD_VAR 0 1
15179: PPUSH
15180: LD_INT 35
15182: PPUSH
15183: CALL_OW 308
15187: IFFALSE 15198
// RemoveUnit ( i ) ;
15189: LD_VAR 0 1
15193: PPUSH
15194: CALL_OW 64
// end ;
15198: GO 15117
15200: POP
15201: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15202: LD_INT 22
15204: PUSH
15205: LD_INT 1
15207: PUSH
15208: EMPTY
15209: LIST
15210: LIST
15211: PUSH
15212: LD_INT 2
15214: PUSH
15215: LD_INT 21
15217: PUSH
15218: LD_INT 1
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: PUSH
15225: LD_INT 33
15227: PUSH
15228: LD_INT 1
15230: PUSH
15231: EMPTY
15232: LIST
15233: LIST
15234: PUSH
15235: EMPTY
15236: LIST
15237: LIST
15238: LIST
15239: PUSH
15240: EMPTY
15241: LIST
15242: LIST
15243: PPUSH
15244: CALL_OW 69
15248: NOT
15249: IFFALSE 15100
// end ;
15251: PPOPN 3
15253: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15254: LD_EXP 2
15258: IFFALSE 15659
15260: GO 15262
15262: DISABLE
15263: LD_INT 0
15265: PPUSH
15266: PPUSH
15267: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15268: LD_INT 35
15270: PPUSH
15271: CALL_OW 67
// until IsDead ( Yakotich ) ;
15275: LD_EXP 59
15279: PPUSH
15280: CALL_OW 301
15284: IFFALSE 15268
// MC_Kill ( 2 ) ;
15286: LD_INT 2
15288: PPUSH
15289: CALL 21670 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15293: LD_INT 3
15295: PPUSH
15296: LD_INT 7
15298: PPUSH
15299: LD_INT 1
15301: PPUSH
15302: LD_INT 1
15304: PPUSH
15305: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15309: LD_ADDR_VAR 0 3
15313: PUSH
15314: LD_INT 22
15316: PUSH
15317: LD_INT 3
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: LD_INT 26
15326: PUSH
15327: LD_INT 1
15329: PUSH
15330: EMPTY
15331: LIST
15332: LIST
15333: PUSH
15334: LD_INT 23
15336: PUSH
15337: LD_INT 3
15339: PUSH
15340: EMPTY
15341: LIST
15342: LIST
15343: PUSH
15344: EMPTY
15345: LIST
15346: LIST
15347: LIST
15348: PPUSH
15349: CALL_OW 69
15353: PUSH
15354: LD_EXP 58
15358: PUSH
15359: LD_EXP 59
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: DIFF
15368: ST_TO_ADDR
// if speaker then
15369: LD_VAR 0 3
15373: IFFALSE 15423
// begin DialogueOn ;
15375: CALL_OW 6
// if Burlak then
15379: LD_EXP 51
15383: IFFALSE 15403
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15385: LD_VAR 0 3
15389: PUSH
15390: LD_INT 1
15392: ARRAY
15393: PPUSH
15394: LD_STRING DSurrenderRussians-RSol1-1
15396: PPUSH
15397: CALL_OW 94
15401: GO 15419
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15403: LD_VAR 0 3
15407: PUSH
15408: LD_INT 1
15410: ARRAY
15411: PPUSH
15412: LD_STRING DSurrenderRussians-RSol1-1a
15414: PPUSH
15415: CALL_OW 94
// DialogueOff ;
15419: CALL_OW 7
// end ; russianCapitulated := true ;
15423: LD_ADDR_EXP 7
15427: PUSH
15428: LD_INT 1
15430: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15431: LD_ADDR_VAR 0 2
15435: PUSH
15436: LD_INT 22
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: LD_INT 21
15448: PUSH
15449: LD_INT 1
15451: PUSH
15452: EMPTY
15453: LIST
15454: LIST
15455: PUSH
15456: EMPTY
15457: LIST
15458: LIST
15459: PPUSH
15460: CALL_OW 69
15464: PUSH
15465: LD_INT 22
15467: PUSH
15468: LD_INT 3
15470: PUSH
15471: EMPTY
15472: LIST
15473: LIST
15474: PUSH
15475: LD_INT 21
15477: PUSH
15478: LD_INT 2
15480: PUSH
15481: EMPTY
15482: LIST
15483: LIST
15484: PUSH
15485: LD_INT 1
15487: PUSH
15488: EMPTY
15489: LIST
15490: PUSH
15491: EMPTY
15492: LIST
15493: LIST
15494: LIST
15495: PPUSH
15496: CALL_OW 69
15500: ADD
15501: ST_TO_ADDR
// if tmp then
15502: LD_VAR 0 2
15506: IFFALSE 15659
// repeat wait ( 0 0$1 ) ;
15508: LD_INT 35
15510: PPUSH
15511: CALL_OW 67
// for i in tmp do
15515: LD_ADDR_VAR 0 1
15519: PUSH
15520: LD_VAR 0 2
15524: PUSH
15525: FOR_IN
15526: IFFALSE 15608
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15528: LD_VAR 0 1
15532: PPUSH
15533: CALL_OW 310
15537: PUSH
15538: LD_VAR 0 1
15542: PPUSH
15543: CALL_OW 310
15547: PPUSH
15548: CALL_OW 247
15552: PUSH
15553: LD_INT 3
15555: EQUAL
15556: AND
15557: IFFALSE 15568
// ComExitBuilding ( i ) ;
15559: LD_VAR 0 1
15563: PPUSH
15564: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15568: LD_VAR 0 1
15572: PPUSH
15573: LD_INT 154
15575: PPUSH
15576: LD_INT 1
15578: PPUSH
15579: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15583: LD_VAR 0 1
15587: PPUSH
15588: LD_INT 36
15590: PPUSH
15591: CALL_OW 308
15595: IFFALSE 15606
// RemoveUnit ( i ) ;
15597: LD_VAR 0 1
15601: PPUSH
15602: CALL_OW 64
// end ;
15606: GO 15525
15608: POP
15609: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15610: LD_INT 22
15612: PUSH
15613: LD_INT 3
15615: PUSH
15616: EMPTY
15617: LIST
15618: LIST
15619: PUSH
15620: LD_INT 2
15622: PUSH
15623: LD_INT 21
15625: PUSH
15626: LD_INT 1
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: PUSH
15633: LD_INT 33
15635: PUSH
15636: LD_INT 1
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: LIST
15647: PUSH
15648: EMPTY
15649: LIST
15650: LIST
15651: PPUSH
15652: CALL_OW 69
15656: NOT
15657: IFFALSE 15508
// end ;
15659: PPOPN 3
15661: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15662: LD_INT 22
15664: PUSH
15665: LD_INT 8
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: PUSH
15672: LD_INT 21
15674: PUSH
15675: LD_INT 1
15677: PUSH
15678: EMPTY
15679: LIST
15680: LIST
15681: PUSH
15682: LD_INT 23
15684: PUSH
15685: LD_INT 2
15687: PUSH
15688: EMPTY
15689: LIST
15690: LIST
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: LIST
15696: PPUSH
15697: CALL_OW 69
15701: PUSH
15702: LD_INT 18
15704: LESS
15705: PUSH
15706: LD_EXP 57
15710: PPUSH
15711: CALL_OW 301
15715: OR
15716: PUSH
15717: LD_INT 324
15719: PPUSH
15720: CALL_OW 255
15724: PUSH
15725: LD_INT 7
15727: EQUAL
15728: OR
15729: IFFALSE 15742
15731: GO 15733
15733: DISABLE
// legionDestroyed := true ;
15734: LD_ADDR_EXP 3
15738: PUSH
15739: LD_INT 1
15741: ST_TO_ADDR
15742: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15743: LD_INT 22
15745: PUSH
15746: LD_INT 2
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PUSH
15753: LD_INT 21
15755: PUSH
15756: LD_INT 1
15758: PUSH
15759: EMPTY
15760: LIST
15761: LIST
15762: PUSH
15763: LD_INT 23
15765: PUSH
15766: LD_INT 2
15768: PUSH
15769: EMPTY
15770: LIST
15771: LIST
15772: PUSH
15773: EMPTY
15774: LIST
15775: LIST
15776: LIST
15777: PPUSH
15778: CALL_OW 69
15782: PUSH
15783: LD_INT 9
15785: LESS
15786: IFFALSE 15799
15788: GO 15790
15790: DISABLE
// arabianDestroyed := true ;
15791: LD_ADDR_EXP 5
15795: PUSH
15796: LD_INT 1
15798: ST_TO_ADDR
15799: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15800: LD_EXP 5
15804: IFFALSE 16048
15806: GO 15808
15808: DISABLE
15809: LD_INT 0
15811: PPUSH
15812: PPUSH
// begin MC_Kill ( 1 ) ;
15813: LD_INT 1
15815: PPUSH
15816: CALL 21670 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15820: LD_ADDR_VAR 0 2
15824: PUSH
15825: LD_INT 22
15827: PUSH
15828: LD_INT 2
15830: PUSH
15831: EMPTY
15832: LIST
15833: LIST
15834: PUSH
15835: LD_INT 21
15837: PUSH
15838: LD_INT 1
15840: PUSH
15841: EMPTY
15842: LIST
15843: LIST
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: PPUSH
15849: CALL_OW 69
15853: PUSH
15854: LD_INT 22
15856: PUSH
15857: LD_INT 8
15859: PUSH
15860: EMPTY
15861: LIST
15862: LIST
15863: PUSH
15864: LD_INT 21
15866: PUSH
15867: LD_INT 2
15869: PUSH
15870: EMPTY
15871: LIST
15872: LIST
15873: PUSH
15874: LD_INT 1
15876: PUSH
15877: EMPTY
15878: LIST
15879: PUSH
15880: EMPTY
15881: LIST
15882: LIST
15883: LIST
15884: PPUSH
15885: CALL_OW 69
15889: ADD
15890: ST_TO_ADDR
// if tmp then
15891: LD_VAR 0 2
15895: IFFALSE 16048
// repeat wait ( 0 0$1 ) ;
15897: LD_INT 35
15899: PPUSH
15900: CALL_OW 67
// for i in tmp do
15904: LD_ADDR_VAR 0 1
15908: PUSH
15909: LD_VAR 0 2
15913: PUSH
15914: FOR_IN
15915: IFFALSE 15997
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15917: LD_VAR 0 1
15921: PPUSH
15922: CALL_OW 310
15926: PUSH
15927: LD_VAR 0 1
15931: PPUSH
15932: CALL_OW 310
15936: PPUSH
15937: CALL_OW 247
15941: PUSH
15942: LD_INT 3
15944: EQUAL
15945: AND
15946: IFFALSE 15957
// ComExitBuilding ( i ) ;
15948: LD_VAR 0 1
15952: PPUSH
15953: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15957: LD_VAR 0 1
15961: PPUSH
15962: LD_INT 254
15964: PPUSH
15965: LD_INT 268
15967: PPUSH
15968: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15972: LD_VAR 0 1
15976: PPUSH
15977: LD_INT 34
15979: PPUSH
15980: CALL_OW 308
15984: IFFALSE 15995
// RemoveUnit ( i ) ;
15986: LD_VAR 0 1
15990: PPUSH
15991: CALL_OW 64
// end ;
15995: GO 15914
15997: POP
15998: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15999: LD_INT 22
16001: PUSH
16002: LD_INT 2
16004: PUSH
16005: EMPTY
16006: LIST
16007: LIST
16008: PUSH
16009: LD_INT 2
16011: PUSH
16012: LD_INT 21
16014: PUSH
16015: LD_INT 1
16017: PUSH
16018: EMPTY
16019: LIST
16020: LIST
16021: PUSH
16022: LD_INT 33
16024: PUSH
16025: LD_INT 1
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: LIST
16036: PUSH
16037: EMPTY
16038: LIST
16039: LIST
16040: PPUSH
16041: CALL_OW 69
16045: NOT
16046: IFFALSE 15897
// end ;
16048: PPOPN 2
16050: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16051: LD_EXP 3
16055: IFFALSE 16407
16057: GO 16059
16059: DISABLE
16060: LD_INT 0
16062: PPUSH
16063: PPUSH
// begin MC_Kill ( 3 ) ;
16064: LD_INT 3
16066: PPUSH
16067: CALL 21670 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16071: LD_INT 8
16073: PPUSH
16074: LD_INT 7
16076: PPUSH
16077: LD_INT 1
16079: PPUSH
16080: LD_INT 1
16082: PPUSH
16083: CALL_OW 80
// DialogueOn ;
16087: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16091: LD_EXP 56
16095: PPUSH
16096: LD_STRING D15-Szulc-1
16098: PPUSH
16099: CALL_OW 94
// DialogueOff ;
16103: CALL_OW 7
// legionCapitulated := true ;
16107: LD_ADDR_EXP 8
16111: PUSH
16112: LD_INT 1
16114: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16115: LD_ADDR_VAR 0 1
16119: PUSH
16120: LD_INT 22
16122: PUSH
16123: LD_INT 8
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: PUSH
16130: LD_INT 21
16132: PUSH
16133: LD_INT 3
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: PUSH
16140: LD_INT 23
16142: PUSH
16143: LD_INT 3
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: LIST
16154: PPUSH
16155: CALL_OW 69
16159: PUSH
16160: FOR_IN
16161: IFFALSE 16177
// SetLives ( i , 3 ) ;
16163: LD_VAR 0 1
16167: PPUSH
16168: LD_INT 3
16170: PPUSH
16171: CALL_OW 234
16175: GO 16160
16177: POP
16178: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16179: LD_ADDR_VAR 0 2
16183: PUSH
16184: LD_INT 22
16186: PUSH
16187: LD_INT 8
16189: PUSH
16190: EMPTY
16191: LIST
16192: LIST
16193: PUSH
16194: LD_INT 21
16196: PUSH
16197: LD_INT 1
16199: PUSH
16200: EMPTY
16201: LIST
16202: LIST
16203: PUSH
16204: EMPTY
16205: LIST
16206: LIST
16207: PPUSH
16208: CALL_OW 69
16212: PUSH
16213: LD_INT 22
16215: PUSH
16216: LD_INT 8
16218: PUSH
16219: EMPTY
16220: LIST
16221: LIST
16222: PUSH
16223: LD_INT 21
16225: PUSH
16226: LD_INT 2
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: PUSH
16233: LD_INT 1
16235: PUSH
16236: EMPTY
16237: LIST
16238: PUSH
16239: EMPTY
16240: LIST
16241: LIST
16242: LIST
16243: PPUSH
16244: CALL_OW 69
16248: ADD
16249: ST_TO_ADDR
// if tmp then
16250: LD_VAR 0 2
16254: IFFALSE 16407
// repeat wait ( 0 0$1 ) ;
16256: LD_INT 35
16258: PPUSH
16259: CALL_OW 67
// for i in tmp do
16263: LD_ADDR_VAR 0 1
16267: PUSH
16268: LD_VAR 0 2
16272: PUSH
16273: FOR_IN
16274: IFFALSE 16356
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16276: LD_VAR 0 1
16280: PPUSH
16281: CALL_OW 310
16285: PUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 310
16295: PPUSH
16296: CALL_OW 247
16300: PUSH
16301: LD_INT 3
16303: EQUAL
16304: AND
16305: IFFALSE 16316
// ComExitBuilding ( i ) ;
16307: LD_VAR 0 1
16311: PPUSH
16312: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16316: LD_VAR 0 1
16320: PPUSH
16321: LD_INT 10
16323: PPUSH
16324: LD_INT 1
16326: PPUSH
16327: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16331: LD_VAR 0 1
16335: PPUSH
16336: LD_INT 32
16338: PPUSH
16339: CALL_OW 308
16343: IFFALSE 16354
// RemoveUnit ( i ) ;
16345: LD_VAR 0 1
16349: PPUSH
16350: CALL_OW 64
// end ;
16354: GO 16273
16356: POP
16357: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16358: LD_INT 22
16360: PUSH
16361: LD_INT 8
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: PUSH
16368: LD_INT 2
16370: PUSH
16371: LD_INT 21
16373: PUSH
16374: LD_INT 1
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 33
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: LIST
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: PPUSH
16400: CALL_OW 69
16404: NOT
16405: IFFALSE 16256
// end ;
16407: PPOPN 2
16409: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 do
16410: LD_EXP 5
16414: NOT
16415: PUSH
16416: LD_OWVAR 1
16420: PUSH
16421: LD_INT 63000
16423: GREATEREQUAL
16424: AND
16425: IFFALSE 16434
16427: GO 16429
16429: DISABLE
// AllianceSupport ;
16430: CALL 4642 0 0
16434: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16435: LD_EXP 4
16439: PUSH
16440: LD_EXP 2
16444: AND
16445: PUSH
16446: LD_EXP 3
16450: AND
16451: PUSH
16452: LD_EXP 5
16456: AND
16457: PUSH
16458: LD_EXP 6
16462: AND
16463: PUSH
16464: LD_EXP 7
16468: AND
16469: PUSH
16470: LD_EXP 8
16474: AND
16475: PUSH
16476: LD_EXP 55
16480: PPUSH
16481: CALL_OW 255
16485: PUSH
16486: LD_INT 5
16488: NONEQUAL
16489: PUSH
16490: LD_EXP 55
16494: PPUSH
16495: CALL_OW 301
16499: OR
16500: PUSH
16501: LD_EXP 55
16505: PPUSH
16506: CALL_OW 305
16510: NOT
16511: OR
16512: AND
16513: IFFALSE 17915
16515: GO 16517
16517: DISABLE
16518: LD_INT 0
16520: PPUSH
16521: PPUSH
// begin wait ( 0 0$5 ) ;
16522: LD_INT 175
16524: PPUSH
16525: CALL_OW 67
// music_class := 5 ;
16529: LD_ADDR_OWVAR 72
16533: PUSH
16534: LD_INT 5
16536: ST_TO_ADDR
// music_nat := 5 ;
16537: LD_ADDR_OWVAR 71
16541: PUSH
16542: LD_INT 5
16544: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16545: LD_EXP 15
16549: PUSH
16550: LD_INT 3
16552: LESS
16553: IFFALSE 16562
// SetAchievement ( ACH_ECONOMY ) ;
16555: LD_STRING ACH_ECONOMY
16557: PPUSH
16558: CALL_OW 543
// if tick < 60 60$00 then
16562: LD_OWVAR 1
16566: PUSH
16567: LD_INT 126000
16569: LESS
16570: IFFALSE 16586
// begin wait ( 3 ) ;
16572: LD_INT 3
16574: PPUSH
16575: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16579: LD_STRING ACH_ASPEED_19
16581: PPUSH
16582: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16586: LD_EXP 19
16590: PPUSH
16591: CALL_OW 87
// InGameOn ;
16595: CALL_OW 8
// DialogueOn ;
16599: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16603: LD_EXP 19
16607: PPUSH
16608: LD_STRING DEnd-JMM-JMM-1
16610: PPUSH
16611: CALL_OW 88
// if Joan then
16615: LD_EXP 34
16619: IFFALSE 16635
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16621: LD_EXP 34
16625: PPUSH
16626: LD_STRING DEnd-JMM-Joan-1
16628: PPUSH
16629: CALL_OW 88
16633: GO 16679
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16635: LD_EXP 21
16639: PUSH
16640: LD_EXP 21
16644: PPUSH
16645: CALL_OW 255
16649: PUSH
16650: LD_INT 7
16652: EQUAL
16653: AND
16654: PUSH
16655: LD_EXP 21
16659: PPUSH
16660: CALL_OW 305
16664: AND
16665: IFFALSE 16679
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16667: LD_EXP 21
16671: PPUSH
16672: LD_STRING DEnd-JMM-Lisa-1
16674: PPUSH
16675: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16679: LD_EXP 31
16683: PUSH
16684: LD_EXP 31
16688: PPUSH
16689: CALL_OW 305
16693: AND
16694: IFFALSE 16708
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16696: LD_EXP 31
16700: PPUSH
16701: LD_STRING DEnd-JMM-Frank-1
16703: PPUSH
16704: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16708: LD_EXP 24
16712: PUSH
16713: LD_EXP 24
16717: PPUSH
16718: CALL_OW 255
16722: PUSH
16723: LD_INT 7
16725: EQUAL
16726: AND
16727: PUSH
16728: LD_EXP 24
16732: PPUSH
16733: CALL_OW 305
16737: AND
16738: IFFALSE 16752
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16740: LD_EXP 24
16744: PPUSH
16745: LD_STRING DEnd-JMM-Cyrus-1
16747: PPUSH
16748: CALL_OW 88
// if Burlak then
16752: LD_EXP 51
16756: IFFALSE 16770
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16758: LD_EXP 51
16762: PPUSH
16763: LD_STRING DEnd-JMM-Bur-1
16765: PPUSH
16766: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
16770: LD_EXP 34
16774: PUSH
16775: LD_EXP 21
16779: AND
16780: PUSH
16781: LD_EXP 21
16785: PPUSH
16786: CALL_OW 255
16790: PUSH
16791: LD_INT 7
16793: EQUAL
16794: AND
16795: PUSH
16796: LD_EXP 21
16800: PPUSH
16801: CALL_OW 305
16805: AND
16806: PUSH
16807: LD_EXP 51
16811: PPUSH
16812: CALL_OW 302
16816: AND
16817: IFFALSE 16831
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16819: LD_EXP 21
16823: PPUSH
16824: LD_STRING DEnd-Burlak-Lisa-1
16826: PPUSH
16827: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16831: LD_EXP 52
16835: PUSH
16836: LD_EXP 52
16840: PPUSH
16841: CALL_OW 305
16845: AND
16846: IFFALSE 16860
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16848: LD_EXP 52
16852: PPUSH
16853: LD_STRING DEnd-JMM-Bel-1
16855: PPUSH
16856: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16860: LD_EXP 53
16864: PUSH
16865: LD_EXP 53
16869: PPUSH
16870: CALL_OW 305
16874: AND
16875: IFFALSE 16889
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16877: LD_EXP 53
16881: PPUSH
16882: LD_STRING DEnd-JMM-Gny-1
16884: PPUSH
16885: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16889: LD_EXP 29
16893: PUSH
16894: LD_EXP 29
16898: PPUSH
16899: CALL_OW 255
16903: PUSH
16904: LD_INT 7
16906: EQUAL
16907: AND
16908: PUSH
16909: LD_EXP 29
16913: PPUSH
16914: CALL_OW 305
16918: AND
16919: IFFALSE 16933
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16921: LD_EXP 29
16925: PPUSH
16926: LD_STRING DEnd-JMM-Corn-1
16928: PPUSH
16929: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16933: LD_EXP 22
16937: PUSH
16938: LD_EXP 22
16942: PPUSH
16943: CALL_OW 255
16947: PUSH
16948: LD_INT 7
16950: EQUAL
16951: AND
16952: PUSH
16953: LD_EXP 22
16957: PPUSH
16958: CALL_OW 305
16962: AND
16963: IFFALSE 16977
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16965: LD_EXP 22
16969: PPUSH
16970: LD_STRING DEnd-JMM-Don-1
16972: PPUSH
16973: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16977: LD_EXP 23
16981: PUSH
16982: LD_EXP 23
16986: PPUSH
16987: CALL_OW 255
16991: PUSH
16992: LD_INT 7
16994: EQUAL
16995: AND
16996: PUSH
16997: LD_EXP 23
17001: PPUSH
17002: CALL_OW 305
17006: AND
17007: IFFALSE 17021
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17009: LD_EXP 23
17013: PPUSH
17014: LD_STRING DEnd-JMM-Bobby-1
17016: PPUSH
17017: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17021: LD_EXP 25
17025: PUSH
17026: LD_EXP 25
17030: PPUSH
17031: CALL_OW 255
17035: PUSH
17036: LD_INT 7
17038: EQUAL
17039: AND
17040: PUSH
17041: LD_EXP 25
17045: PPUSH
17046: CALL_OW 305
17050: AND
17051: IFFALSE 17065
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17053: LD_EXP 25
17057: PPUSH
17058: LD_STRING DEnd-JMM-Den-1
17060: PPUSH
17061: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17065: LD_EXP 27
17069: PUSH
17070: LD_EXP 27
17074: PPUSH
17075: CALL_OW 255
17079: PUSH
17080: LD_INT 7
17082: EQUAL
17083: AND
17084: PUSH
17085: LD_EXP 27
17089: PPUSH
17090: CALL_OW 305
17094: AND
17095: IFFALSE 17109
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17097: LD_EXP 27
17101: PPUSH
17102: LD_STRING DEnd-JMM-Glad-1
17104: PPUSH
17105: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17109: LD_EXP 32
17113: PUSH
17114: LD_EXP 32
17118: PPUSH
17119: CALL_OW 255
17123: PUSH
17124: LD_INT 7
17126: EQUAL
17127: AND
17128: PUSH
17129: LD_EXP 32
17133: PPUSH
17134: CALL_OW 305
17138: AND
17139: IFFALSE 17153
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17141: LD_EXP 32
17145: PPUSH
17146: LD_STRING DEnd-JMM-Yam-1
17148: PPUSH
17149: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17153: LD_EXP 26
17157: PUSH
17158: LD_EXP 26
17162: PPUSH
17163: CALL_OW 255
17167: PUSH
17168: LD_INT 7
17170: EQUAL
17171: AND
17172: PUSH
17173: LD_EXP 26
17177: PPUSH
17178: CALL_OW 305
17182: AND
17183: IFFALSE 17197
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17185: LD_EXP 26
17189: PPUSH
17190: LD_STRING DEnd-JMM-Brown-1
17192: PPUSH
17193: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17197: LD_EXP 36
17201: PUSH
17202: LD_EXP 36
17206: PPUSH
17207: CALL_OW 255
17211: PUSH
17212: LD_INT 7
17214: EQUAL
17215: AND
17216: PUSH
17217: LD_EXP 36
17221: PPUSH
17222: CALL_OW 305
17226: AND
17227: IFFALSE 17241
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17229: LD_EXP 36
17233: PPUSH
17234: LD_STRING DEnd-JMM-Con-1
17236: PPUSH
17237: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17241: LD_EXP 30
17245: PUSH
17246: LD_EXP 30
17250: PPUSH
17251: CALL_OW 255
17255: PUSH
17256: LD_INT 7
17258: EQUAL
17259: AND
17260: PUSH
17261: LD_EXP 30
17265: PPUSH
17266: CALL_OW 305
17270: AND
17271: IFFALSE 17285
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17273: LD_EXP 30
17277: PPUSH
17278: LD_STRING DEnd-JMM-Gary-1
17280: PPUSH
17281: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17285: LD_EXP 33
17289: PUSH
17290: LD_EXP 20
17294: AND
17295: PUSH
17296: LD_EXP 33
17300: PPUSH
17301: CALL_OW 305
17305: AND
17306: IFFALSE 17320
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17308: LD_EXP 33
17312: PPUSH
17313: LD_STRING DEnd-JMM-Sim-1
17315: PPUSH
17316: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17320: LD_EXP 28
17324: PUSH
17325: LD_EXP 28
17329: PPUSH
17330: CALL_OW 255
17334: PUSH
17335: LD_INT 7
17337: EQUAL
17338: AND
17339: PUSH
17340: LD_EXP 28
17344: PPUSH
17345: CALL_OW 305
17349: AND
17350: IFFALSE 17364
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17352: LD_EXP 28
17356: PPUSH
17357: LD_STRING DEnd-JMM-VanH-1
17359: PPUSH
17360: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17364: LD_EXP 41
17368: PUSH
17369: LD_EXP 41
17373: PPUSH
17374: CALL_OW 305
17378: AND
17379: IFFALSE 17393
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17381: LD_EXP 41
17385: PPUSH
17386: LD_STRING DEnd-JMM-Dol-1
17388: PPUSH
17389: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17393: LD_EXP 45
17397: PUSH
17398: LD_EXP 45
17402: PPUSH
17403: CALL_OW 305
17407: AND
17408: IFFALSE 17422
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17410: LD_EXP 45
17414: PPUSH
17415: LD_STRING DEnd-JMM-Kap-1
17417: PPUSH
17418: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17422: LD_EXP 48
17426: PUSH
17427: LD_EXP 48
17431: PPUSH
17432: CALL_OW 305
17436: AND
17437: IFFALSE 17451
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17439: LD_EXP 48
17443: PPUSH
17444: LD_STRING DEnd-JMM-Kov-1
17446: PPUSH
17447: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17451: LD_EXP 43
17455: PUSH
17456: LD_EXP 43
17460: PPUSH
17461: CALL_OW 305
17465: AND
17466: IFFALSE 17480
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17468: LD_EXP 43
17472: PPUSH
17473: LD_STRING DEnd-JMM-Sch-1
17475: PPUSH
17476: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17480: LD_EXP 39
17484: PUSH
17485: LD_EXP 39
17489: PPUSH
17490: CALL_OW 305
17494: AND
17495: IFFALSE 17509
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17497: LD_EXP 39
17501: PPUSH
17502: LD_STRING DEnd-JMM-Tit-1
17504: PPUSH
17505: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17509: LD_EXP 44
17513: PUSH
17514: LD_EXP 44
17518: PPUSH
17519: CALL_OW 305
17523: AND
17524: IFFALSE 17538
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17526: LD_EXP 44
17530: PPUSH
17531: LD_STRING DEnd-JMM-Obl-1
17533: PPUSH
17534: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17538: LD_EXP 46
17542: PUSH
17543: LD_EXP 46
17547: PPUSH
17548: CALL_OW 305
17552: AND
17553: IFFALSE 17567
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17555: LD_EXP 46
17559: PPUSH
17560: LD_STRING DEnd-JMM-Lip-1
17562: PPUSH
17563: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17567: LD_EXP 40
17571: PUSH
17572: LD_EXP 40
17576: PPUSH
17577: CALL_OW 305
17581: AND
17582: PUSH
17583: LD_EXP 51
17587: AND
17588: IFFALSE 17602
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17590: LD_EXP 40
17594: PPUSH
17595: LD_STRING DEnd-Burlak-Fad-1
17597: PPUSH
17598: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17602: LD_EXP 47
17606: PUSH
17607: LD_EXP 47
17611: PPUSH
17612: CALL_OW 305
17616: AND
17617: IFFALSE 17631
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17619: LD_EXP 47
17623: PPUSH
17624: LD_STRING DEnd-Burlak-Ptr-1
17626: PPUSH
17627: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17631: LD_EXP 49
17635: PUSH
17636: LD_EXP 49
17640: PPUSH
17641: CALL_OW 305
17645: AND
17646: IFFALSE 17660
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17648: LD_EXP 49
17652: PPUSH
17653: LD_STRING DEnd-Burlak-Kuz-1
17655: PPUSH
17656: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17660: LD_EXP 38
17664: PUSH
17665: LD_EXP 38
17669: PPUSH
17670: CALL_OW 305
17674: AND
17675: PUSH
17676: LD_EXP 51
17680: AND
17681: IFFALSE 17695
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17683: LD_EXP 38
17687: PPUSH
17688: LD_STRING DEnd-Burlak-Kir-1
17690: PPUSH
17691: CALL_OW 88
// if Burlak then
17695: LD_EXP 51
17699: IFFALSE 17713
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17701: LD_EXP 19
17705: PPUSH
17706: LD_STRING DEnd-Burlak-JMM-1
17708: PPUSH
17709: CALL_OW 88
// dwait ( 0 0$2 ) ;
17713: LD_INT 70
17715: PPUSH
17716: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17720: LD_EXP 56
17724: PPUSH
17725: LD_STRING DEnd-Szulc
17727: PPUSH
17728: CALL_OW 94
// dwait ( 0 0$1 ) ;
17732: LD_INT 35
17734: PPUSH
17735: CALL_OW 68
// if IsLive ( Burlak ) then
17739: LD_EXP 51
17743: PPUSH
17744: CALL_OW 300
17748: IFFALSE 17760
// med1 := 1 else
17750: LD_ADDR_VAR 0 1
17754: PUSH
17755: LD_INT 1
17757: ST_TO_ADDR
17758: GO 17769
// med1 := - 1 ;
17760: LD_ADDR_VAR 0 1
17764: PUSH
17765: LD_INT 1
17767: NEG
17768: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17769: LD_EXP 12
17773: PUSH
17774: LD_EXP 13
17778: AND
17779: PUSH
17780: LD_EXP 14
17784: AND
17785: IFFALSE 17797
// med2 := 1 else
17787: LD_ADDR_VAR 0 2
17791: PUSH
17792: LD_INT 1
17794: ST_TO_ADDR
17795: GO 17806
// med2 := - 1 ;
17797: LD_ADDR_VAR 0 2
17801: PUSH
17802: LD_INT 1
17804: NEG
17805: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17806: LD_STRING Hero
17808: PPUSH
17809: LD_INT 1
17811: PPUSH
17812: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17816: LD_STRING Artefact
17818: PPUSH
17819: LD_VAR 0 2
17823: PPUSH
17824: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17828: LD_STRING ReconcileBurlak
17830: PPUSH
17831: LD_VAR 0 1
17835: PPUSH
17836: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17840: LD_OWVAR 67
17844: PUSH
17845: LD_INT 3
17847: GREATEREQUAL
17848: PUSH
17849: LD_VAR 0 1
17853: PUSH
17854: LD_INT 1
17856: EQUAL
17857: AND
17858: PUSH
17859: LD_VAR 0 2
17863: PUSH
17864: LD_INT 1
17866: EQUAL
17867: AND
17868: IFFALSE 17880
// SetAchievementEX ( ACH_AMER , 19 ) ;
17870: LD_STRING ACH_AMER
17872: PPUSH
17873: LD_INT 19
17875: PPUSH
17876: CALL_OW 564
// GiveMedals ( MAIN ) ;
17880: LD_STRING MAIN
17882: PPUSH
17883: CALL_OW 102
// InGameOff ;
17887: CALL_OW 9
// DialogueOff ;
17891: CALL_OW 7
// music_nat := 1 ;
17895: LD_ADDR_OWVAR 71
17899: PUSH
17900: LD_INT 1
17902: ST_TO_ADDR
// music_class := 4 ;
17903: LD_ADDR_OWVAR 72
17907: PUSH
17908: LD_INT 4
17910: ST_TO_ADDR
// YouWin ;
17911: CALL_OW 103
// end ; end_of_file
17915: PPOPN 2
17917: END
// export function InitNature ; begin
17918: LD_INT 0
17920: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17921: LD_INT 3
17923: PPUSH
17924: LD_INT 3
17926: PPUSH
17927: LD_INT 2
17929: PPUSH
17930: LD_INT 1
17932: PPUSH
17933: LD_INT 1
17935: PPUSH
17936: LD_INT 0
17938: PPUSH
17939: LD_INT 0
17941: PPUSH
17942: LD_INT 17
17944: PPUSH
17945: LD_INT 0
17947: PPUSH
17948: CALL 85570 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17952: LD_INT 2
17954: PPUSH
17955: LD_INT 1
17957: PPUSH
17958: LD_INT 1
17960: PPUSH
17961: LD_INT 1
17963: PPUSH
17964: LD_INT 1
17966: PPUSH
17967: LD_INT 0
17969: PPUSH
17970: LD_INT 0
17972: PPUSH
17973: LD_INT 18
17975: PPUSH
17976: LD_INT 0
17978: PPUSH
17979: CALL 85570 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17983: LD_INT 4
17985: PPUSH
17986: LD_INT 1
17988: PPUSH
17989: LD_INT 2
17991: PPUSH
17992: LD_INT 4
17994: PPUSH
17995: LD_INT 2
17997: PPUSH
17998: LD_INT 1
18000: PPUSH
18001: LD_INT 0
18003: PPUSH
18004: LD_INT 19
18006: PPUSH
18007: LD_INT 0
18009: PPUSH
18010: CALL 85570 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18014: LD_INT 0
18016: PPUSH
18017: LD_INT 0
18019: PPUSH
18020: LD_INT 0
18022: PPUSH
18023: LD_INT 0
18025: PPUSH
18026: LD_INT 0
18028: PPUSH
18029: LD_INT 0
18031: PPUSH
18032: LD_INT 9
18034: PPUSH
18035: LD_INT 0
18037: PPUSH
18038: LD_INT 20
18040: PPUSH
18041: CALL 85570 0 9
// end ; end_of_file
18045: LD_VAR 0 1
18049: RET
// every 0 0$30 do var time ;
18050: GO 18052
18052: DISABLE
18053: LD_INT 0
18055: PPUSH
// begin time := 0 0$30 ;
18056: LD_ADDR_VAR 0 1
18060: PUSH
18061: LD_INT 1050
18063: ST_TO_ADDR
// repeat wait ( time ) ;
18064: LD_VAR 0 1
18068: PPUSH
18069: CALL_OW 67
// if Prob ( 50 ) then
18073: LD_INT 50
18075: PPUSH
18076: CALL_OW 13
18080: IFFALSE 18109
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18082: LD_INT 1
18084: PPUSH
18085: LD_INT 5
18087: PPUSH
18088: CALL_OW 12
18092: PPUSH
18093: LD_INT 106
18095: PPUSH
18096: LD_INT 89
18098: PPUSH
18099: LD_INT 45
18101: PPUSH
18102: LD_INT 1
18104: PPUSH
18105: CALL_OW 56
// time := time + 0 0$3 ;
18109: LD_ADDR_VAR 0 1
18113: PUSH
18114: LD_VAR 0 1
18118: PUSH
18119: LD_INT 105
18121: PLUS
18122: ST_TO_ADDR
// if Prob ( 30 ) then
18123: LD_INT 30
18125: PPUSH
18126: CALL_OW 13
18130: IFFALSE 18176
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18132: LD_INT 525
18134: PPUSH
18135: LD_INT 735
18137: PPUSH
18138: CALL_OW 12
18142: PPUSH
18143: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18147: LD_INT 1
18149: PPUSH
18150: LD_INT 5
18152: PPUSH
18153: CALL_OW 12
18157: PPUSH
18158: LD_INT 21
18160: PPUSH
18161: LD_INT 26
18163: PPUSH
18164: LD_INT 12
18166: PPUSH
18167: LD_INT 1
18169: PPUSH
18170: CALL_OW 56
// end else
18174: GO 18212
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18176: LD_INT 700
18178: PPUSH
18179: LD_INT 1225
18181: PPUSH
18182: CALL_OW 12
18186: PPUSH
18187: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18191: LD_INT 1
18193: PPUSH
18194: LD_INT 5
18196: PPUSH
18197: CALL_OW 12
18201: PPUSH
18202: LD_INT 14
18204: PPUSH
18205: LD_INT 1
18207: PPUSH
18208: CALL_OW 55
// end ; if Prob ( 50 ) then
18212: LD_INT 50
18214: PPUSH
18215: CALL_OW 13
18219: IFFALSE 18265
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18221: LD_INT 700
18223: PPUSH
18224: LD_INT 1050
18226: PPUSH
18227: CALL_OW 12
18231: PPUSH
18232: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18236: LD_INT 1
18238: PPUSH
18239: LD_INT 5
18241: PPUSH
18242: CALL_OW 12
18246: PPUSH
18247: LD_INT 181
18249: PPUSH
18250: LD_INT 218
18252: PPUSH
18253: LD_INT 16
18255: PPUSH
18256: LD_INT 1
18258: PPUSH
18259: CALL_OW 56
// end else
18263: GO 18337
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18265: LD_INT 350
18267: PPUSH
18268: LD_INT 525
18270: PPUSH
18271: CALL_OW 12
18275: PPUSH
18276: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18280: LD_INT 1
18282: PPUSH
18283: LD_INT 5
18285: PPUSH
18286: CALL_OW 12
18290: PPUSH
18291: LD_INT 13
18293: PPUSH
18294: LD_INT 1
18296: PPUSH
18297: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18301: LD_INT 350
18303: PPUSH
18304: LD_INT 700
18306: PPUSH
18307: CALL_OW 12
18311: PPUSH
18312: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18316: LD_INT 1
18318: PPUSH
18319: LD_INT 5
18321: PPUSH
18322: CALL_OW 12
18326: PPUSH
18327: LD_INT 33
18329: PPUSH
18330: LD_INT 1
18332: PPUSH
18333: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18337: LD_INT 65
18339: PUSH
18340: LD_INT 62
18342: PUSH
18343: LD_INT 55
18345: PUSH
18346: LD_INT 50
18348: PUSH
18349: EMPTY
18350: LIST
18351: LIST
18352: LIST
18353: LIST
18354: PUSH
18355: LD_OWVAR 67
18359: ARRAY
18360: PPUSH
18361: CALL_OW 13
18365: IFFALSE 18411
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18367: LD_INT 525
18369: PPUSH
18370: LD_INT 875
18372: PPUSH
18373: CALL_OW 12
18377: PPUSH
18378: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18382: LD_INT 1
18384: PPUSH
18385: LD_INT 5
18387: PPUSH
18388: CALL_OW 12
18392: PPUSH
18393: LD_INT 294
18395: PPUSH
18396: LD_INT 211
18398: PPUSH
18399: LD_INT 30
18401: PPUSH
18402: LD_INT 1
18404: PPUSH
18405: CALL_OW 56
// end else
18409: GO 18453
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18411: LD_INT 420
18413: PPUSH
18414: LD_INT 770
18416: PPUSH
18417: CALL_OW 12
18421: PPUSH
18422: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18426: LD_INT 1
18428: PPUSH
18429: LD_INT 5
18431: PPUSH
18432: CALL_OW 12
18436: PPUSH
18437: LD_INT 294
18439: PPUSH
18440: LD_INT 211
18442: PPUSH
18443: LD_INT 30
18445: PPUSH
18446: LD_INT 1
18448: PPUSH
18449: CALL_OW 56
// end ; if time > 2 2$20 then
18453: LD_VAR 0 1
18457: PUSH
18458: LD_INT 4900
18460: GREATER
18461: IFFALSE 18471
// time := 0 0$50 ;
18463: LD_ADDR_VAR 0 1
18467: PUSH
18468: LD_INT 1750
18470: ST_TO_ADDR
// until false ;
18471: LD_INT 0
18473: IFFALSE 18064
// end ;
18475: PPOPN 1
18477: END
// every 0 0$45 trigger tick < 10 10$00 do
18478: LD_OWVAR 1
18482: PUSH
18483: LD_INT 21000
18485: LESS
18486: IFFALSE 18534
18488: GO 18490
18490: DISABLE
// begin enable ;
18491: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18492: LD_INT 350
18494: PPUSH
18495: LD_INT 700
18497: PPUSH
18498: CALL_OW 12
18502: PPUSH
18503: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18507: LD_INT 3
18509: PPUSH
18510: LD_INT 5
18512: PPUSH
18513: CALL_OW 12
18517: PPUSH
18518: LD_INT 181
18520: PPUSH
18521: LD_INT 13
18523: PPUSH
18524: LD_INT 20
18526: PPUSH
18527: LD_INT 1
18529: PPUSH
18530: CALL_OW 56
// end ; end_of_file
18534: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18535: LD_INT 0
18537: PPUSH
// SetArtifactRes ( 7 , true ) ;
18538: LD_INT 7
18540: PPUSH
18541: LD_INT 1
18543: PPUSH
18544: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18548: LD_ADDR_EXP 64
18552: PUSH
18553: EMPTY
18554: PUSH
18555: EMPTY
18556: PUSH
18557: EMPTY
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: LIST
18563: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18564: LD_ADDR_EXP 65
18568: PUSH
18569: LD_INT 1050
18571: PUSH
18572: LD_OWVAR 67
18576: MUL
18577: PUSH
18578: LD_INT 2800
18580: PUSH
18581: LD_OWVAR 67
18585: MUL
18586: PUSH
18587: LD_INT 1
18589: NEG
18590: PUSH
18591: EMPTY
18592: LIST
18593: LIST
18594: LIST
18595: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18596: LD_ADDR_EXP 66
18600: PUSH
18601: LD_INT 10
18603: PUSH
18604: LD_INT 35
18606: PUSH
18607: LD_INT 100
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: LIST
18614: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18615: LD_ADDR_EXP 67
18619: PUSH
18620: LD_INT 0
18622: PUSH
18623: LD_INT 0
18625: PUSH
18626: LD_INT 0
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: LIST
18633: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18634: LD_ADDR_EXP 69
18638: PUSH
18639: LD_INT 300
18641: PUSH
18642: LD_INT 500
18644: PUSH
18645: LD_INT 800
18647: PUSH
18648: EMPTY
18649: LIST
18650: LIST
18651: LIST
18652: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18653: LD_ADDR_EXP 70
18657: PUSH
18658: LD_INT 0
18660: PUSH
18661: LD_INT 0
18663: PUSH
18664: LD_INT 0
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: LIST
18671: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18672: LD_ADDR_EXP 71
18676: PUSH
18677: LD_INT 0
18679: PUSH
18680: LD_INT 0
18682: PUSH
18683: LD_INT 0
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: LIST
18690: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18691: LD_ADDR_EXP 68
18695: PUSH
18696: LD_INT 0
18698: PUSH
18699: LD_INT 0
18701: PUSH
18702: LD_INT 0
18704: PUSH
18705: EMPTY
18706: LIST
18707: LIST
18708: LIST
18709: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18710: LD_ADDR_EXP 72
18714: PUSH
18715: LD_INT 4
18717: PUSH
18718: LD_INT 3
18720: PUSH
18721: LD_INT 1
18723: PUSH
18724: EMPTY
18725: LIST
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 5
18731: PUSH
18732: LD_INT 4
18734: PUSH
18735: LD_INT 2
18737: PUSH
18738: EMPTY
18739: LIST
18740: LIST
18741: LIST
18742: PUSH
18743: LD_INT 6
18745: PUSH
18746: LD_INT 3
18748: PUSH
18749: LD_INT 3
18751: PUSH
18752: EMPTY
18753: LIST
18754: LIST
18755: LIST
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: LIST
18761: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18762: LD_ADDR_EXP 73
18766: PUSH
18767: LD_INT 0
18769: PUSH
18770: LD_INT 0
18772: PUSH
18773: LD_INT 0
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: LIST
18780: ST_TO_ADDR
// end ;
18781: LD_VAR 0 1
18785: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18786: LD_INT 24
18788: PPUSH
18789: LD_INT 7
18791: PPUSH
18792: CALL_OW 321
18796: PUSH
18797: LD_INT 2
18799: EQUAL
18800: IFFALSE 19726
18802: GO 18804
18804: DISABLE
18805: LD_INT 0
18807: PPUSH
18808: PPUSH
18809: PPUSH
18810: PPUSH
18811: PPUSH
// begin enable ;
18812: ENABLE
// for i = 1 to 3 do
18813: LD_ADDR_VAR 0 1
18817: PUSH
18818: DOUBLE
18819: LD_INT 1
18821: DEC
18822: ST_TO_ADDR
18823: LD_INT 3
18825: PUSH
18826: FOR_TO
18827: IFFALSE 19724
// begin pos := FindArtifact ( i + 2 ) ;
18829: LD_ADDR_VAR 0 2
18833: PUSH
18834: LD_VAR 0 1
18838: PUSH
18839: LD_INT 2
18841: PLUS
18842: PPUSH
18843: CALL_OW 469
18847: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18848: LD_ADDR_EXP 64
18852: PUSH
18853: LD_EXP 64
18857: PPUSH
18858: LD_VAR 0 1
18862: PPUSH
18863: LD_VAR 0 2
18867: PPUSH
18868: CALL_OW 1
18872: ST_TO_ADDR
// if pos then
18873: LD_VAR 0 2
18877: IFFALSE 19585
// begin case i of 1 :
18879: LD_VAR 0 1
18883: PUSH
18884: LD_INT 1
18886: DOUBLE
18887: EQUAL
18888: IFTRUE 18892
18890: GO 18969
18892: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18893: LD_ADDR_VAR 0 4
18897: PUSH
18898: LD_INT 22
18900: PUSH
18901: LD_INT 7
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PUSH
18908: LD_INT 23
18910: PUSH
18911: LD_INT 1
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PUSH
18918: LD_INT 2
18920: PUSH
18921: LD_INT 30
18923: PUSH
18924: LD_INT 8
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PUSH
18931: LD_INT 30
18933: PUSH
18934: LD_INT 7
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: PUSH
18941: LD_INT 30
18943: PUSH
18944: LD_INT 11
18946: PUSH
18947: EMPTY
18948: LIST
18949: LIST
18950: PUSH
18951: EMPTY
18952: LIST
18953: LIST
18954: LIST
18955: LIST
18956: PUSH
18957: EMPTY
18958: LIST
18959: LIST
18960: LIST
18961: PPUSH
18962: CALL_OW 69
18966: ST_TO_ADDR
18967: GO 19077
18969: LD_INT 2
18971: DOUBLE
18972: EQUAL
18973: IFTRUE 18977
18975: GO 19054
18977: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18978: LD_ADDR_VAR 0 4
18982: PUSH
18983: LD_INT 22
18985: PUSH
18986: LD_INT 7
18988: PUSH
18989: EMPTY
18990: LIST
18991: LIST
18992: PUSH
18993: LD_INT 23
18995: PUSH
18996: LD_INT 3
18998: PUSH
18999: EMPTY
19000: LIST
19001: LIST
19002: PUSH
19003: LD_INT 2
19005: PUSH
19006: LD_INT 30
19008: PUSH
19009: LD_INT 8
19011: PUSH
19012: EMPTY
19013: LIST
19014: LIST
19015: PUSH
19016: LD_INT 30
19018: PUSH
19019: LD_INT 7
19021: PUSH
19022: EMPTY
19023: LIST
19024: LIST
19025: PUSH
19026: LD_INT 30
19028: PUSH
19029: LD_INT 11
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: PUSH
19036: EMPTY
19037: LIST
19038: LIST
19039: LIST
19040: LIST
19041: PUSH
19042: EMPTY
19043: LIST
19044: LIST
19045: LIST
19046: PPUSH
19047: CALL_OW 69
19051: ST_TO_ADDR
19052: GO 19077
19054: LD_INT 3
19056: DOUBLE
19057: EQUAL
19058: IFTRUE 19062
19060: GO 19076
19062: POP
// labs := [ alien ] ; end ;
19063: LD_ADDR_VAR 0 4
19067: PUSH
19068: LD_INT 1
19070: PUSH
19071: EMPTY
19072: LIST
19073: ST_TO_ADDR
19074: GO 19077
19076: POP
// if not labs then
19077: LD_VAR 0 4
19081: NOT
19082: IFFALSE 19086
// continue ;
19084: GO 18826
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19086: LD_ADDR_VAR 0 5
19090: PUSH
19091: LD_VAR 0 4
19095: PPUSH
19096: LD_EXP 64
19100: PUSH
19101: LD_VAR 0 1
19105: ARRAY
19106: PUSH
19107: LD_INT 1
19109: ARRAY
19110: PPUSH
19111: LD_EXP 64
19115: PUSH
19116: LD_VAR 0 1
19120: ARRAY
19121: PUSH
19122: LD_INT 2
19124: ARRAY
19125: PPUSH
19126: CALL_OW 73
19130: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19131: LD_VAR 0 5
19135: NOT
19136: PUSH
19137: LD_VAR 0 5
19141: PUSH
19142: LD_EXP 71
19146: PUSH
19147: LD_VAR 0 1
19151: ARRAY
19152: NONEQUAL
19153: OR
19154: IFFALSE 19259
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19156: LD_INT 7
19158: PPUSH
19159: LD_EXP 72
19163: PUSH
19164: LD_VAR 0 1
19168: ARRAY
19169: PUSH
19170: LD_INT 3
19172: ARRAY
19173: PPUSH
19174: LD_INT 0
19176: PPUSH
19177: LD_EXP 71
19181: PUSH
19182: LD_VAR 0 1
19186: ARRAY
19187: PPUSH
19188: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19192: LD_INT 7
19194: PPUSH
19195: LD_EXP 72
19199: PUSH
19200: LD_VAR 0 1
19204: ARRAY
19205: PUSH
19206: LD_INT 1
19208: ARRAY
19209: PPUSH
19210: LD_INT 0
19212: PPUSH
19213: LD_EXP 71
19217: PUSH
19218: LD_VAR 0 1
19222: ARRAY
19223: PPUSH
19224: CALL_OW 468
// if nearestLab then
19228: LD_VAR 0 5
19232: IFFALSE 19259
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19234: LD_ADDR_EXP 71
19238: PUSH
19239: LD_EXP 71
19243: PPUSH
19244: LD_VAR 0 1
19248: PPUSH
19249: LD_VAR 0 5
19253: PPUSH
19254: CALL_OW 1
19258: ST_TO_ADDR
// end ; if not nearestLab then
19259: LD_VAR 0 5
19263: NOT
19264: IFFALSE 19268
// continue ;
19266: GO 18826
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19268: LD_VAR 0 5
19272: PPUSH
19273: LD_EXP 64
19277: PUSH
19278: LD_VAR 0 1
19282: ARRAY
19283: PUSH
19284: LD_INT 1
19286: ARRAY
19287: PPUSH
19288: LD_EXP 64
19292: PUSH
19293: LD_VAR 0 1
19297: ARRAY
19298: PUSH
19299: LD_INT 2
19301: ARRAY
19302: PPUSH
19303: CALL_OW 297
19307: PUSH
19308: LD_INT 8
19310: LESS
19311: IFFALSE 19508
// begin if not artifactsResearched [ i ] then
19313: LD_EXP 67
19317: PUSH
19318: LD_VAR 0 1
19322: ARRAY
19323: NOT
19324: IFFALSE 19405
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19326: LD_VAR 0 5
19330: PPUSH
19331: CALL_OW 461
19335: PUSH
19336: LD_INT 2
19338: EQUAL
19339: IFFALSE 19373
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19341: LD_INT 7
19343: PPUSH
19344: LD_EXP 72
19348: PUSH
19349: LD_VAR 0 1
19353: ARRAY
19354: PUSH
19355: LD_INT 3
19357: ARRAY
19358: PPUSH
19359: LD_INT 2
19361: PPUSH
19362: LD_VAR 0 5
19366: PPUSH
19367: CALL_OW 468
19371: GO 19403
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19373: LD_INT 7
19375: PPUSH
19376: LD_EXP 72
19380: PUSH
19381: LD_VAR 0 1
19385: ARRAY
19386: PUSH
19387: LD_INT 3
19389: ARRAY
19390: PPUSH
19391: LD_INT 1
19393: PPUSH
19394: LD_VAR 0 5
19398: PPUSH
19399: CALL_OW 468
// end else
19403: GO 19506
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19405: LD_VAR 0 5
19409: PPUSH
19410: CALL_OW 461
19414: PUSH
19415: LD_INT 2
19417: EQUAL
19418: PUSH
19419: LD_EXP 73
19423: PUSH
19424: LD_VAR 0 1
19428: ARRAY
19429: AND
19430: IFFALSE 19476
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19432: LD_INT 7
19434: PPUSH
19435: LD_EXP 72
19439: PUSH
19440: LD_VAR 0 1
19444: ARRAY
19445: PUSH
19446: LD_INT 1
19448: ARRAY
19449: PPUSH
19450: LD_EXP 72
19454: PUSH
19455: LD_VAR 0 1
19459: ARRAY
19460: PUSH
19461: LD_INT 2
19463: ARRAY
19464: PPUSH
19465: LD_VAR 0 5
19469: PPUSH
19470: CALL_OW 468
19474: GO 19506
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19476: LD_INT 7
19478: PPUSH
19479: LD_EXP 72
19483: PUSH
19484: LD_VAR 0 1
19488: ARRAY
19489: PUSH
19490: LD_INT 1
19492: ARRAY
19493: PPUSH
19494: LD_INT 1
19496: PPUSH
19497: LD_VAR 0 5
19501: PPUSH
19502: CALL_OW 468
// end else
19506: GO 19583
// begin if not artifactsResearched [ i ] then
19508: LD_EXP 67
19512: PUSH
19513: LD_VAR 0 1
19517: ARRAY
19518: NOT
19519: IFFALSE 19553
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19521: LD_INT 7
19523: PPUSH
19524: LD_EXP 72
19528: PUSH
19529: LD_VAR 0 1
19533: ARRAY
19534: PUSH
19535: LD_INT 3
19537: ARRAY
19538: PPUSH
19539: LD_INT 0
19541: PPUSH
19542: LD_VAR 0 5
19546: PPUSH
19547: CALL_OW 468
19551: GO 19583
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19553: LD_INT 7
19555: PPUSH
19556: LD_EXP 72
19560: PUSH
19561: LD_VAR 0 1
19565: ARRAY
19566: PUSH
19567: LD_INT 1
19569: ARRAY
19570: PPUSH
19571: LD_INT 0
19573: PPUSH
19574: LD_VAR 0 5
19578: PPUSH
19579: CALL_OW 468
// end ; end else
19583: GO 19722
// begin if not artifactsLabs [ i ] then
19585: LD_EXP 71
19589: PUSH
19590: LD_VAR 0 1
19594: ARRAY
19595: NOT
19596: IFFALSE 19600
// continue ;
19598: GO 18826
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19600: LD_INT 7
19602: PPUSH
19603: LD_EXP 72
19607: PUSH
19608: LD_VAR 0 1
19612: ARRAY
19613: PUSH
19614: LD_INT 3
19616: ARRAY
19617: PPUSH
19618: LD_INT 0
19620: PPUSH
19621: LD_EXP 71
19625: PUSH
19626: LD_VAR 0 1
19630: ARRAY
19631: PPUSH
19632: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19636: LD_INT 7
19638: PPUSH
19639: LD_EXP 72
19643: PUSH
19644: LD_VAR 0 1
19648: ARRAY
19649: PUSH
19650: LD_INT 1
19652: ARRAY
19653: PPUSH
19654: LD_INT 0
19656: PPUSH
19657: LD_EXP 71
19661: PUSH
19662: LD_VAR 0 1
19666: ARRAY
19667: PPUSH
19668: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19672: LD_EXP 68
19676: PUSH
19677: LD_VAR 0 1
19681: ARRAY
19682: IFFALSE 19722
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19684: LD_ADDR_EXP 68
19688: PUSH
19689: LD_EXP 68
19693: PPUSH
19694: LD_VAR 0 1
19698: PPUSH
19699: LD_INT 0
19701: PPUSH
19702: CALL_OW 1
19706: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19707: LD_EXP 71
19711: PUSH
19712: LD_VAR 0 1
19716: ARRAY
19717: PPUSH
19718: CALL_OW 127
// end ; end ; end ;
19722: GO 18826
19724: POP
19725: POP
// end ;
19726: PPOPN 5
19728: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19729: LD_INT 0
19731: PPUSH
19732: PPUSH
19733: PPUSH
19734: PPUSH
19735: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19736: LD_VAR 0 2
19740: PUSH
19741: LD_EXP 72
19745: PUSH
19746: LD_INT 1
19748: ARRAY
19749: PUSH
19750: LD_INT 3
19752: ARRAY
19753: EQUAL
19754: IFFALSE 19877
// begin lab := artifactsLabs [ 1 ] ;
19756: LD_ADDR_VAR 0 6
19760: PUSH
19761: LD_EXP 71
19765: PUSH
19766: LD_INT 1
19768: ARRAY
19769: ST_TO_ADDR
// if not lab then
19770: LD_VAR 0 6
19774: NOT
19775: IFFALSE 19779
// exit ;
19777: GO 20857
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19779: LD_VAR 0 6
19783: PPUSH
19784: LD_EXP 69
19788: PUSH
19789: LD_INT 1
19791: ARRAY
19792: PPUSH
19793: LD_INT 1
19795: PPUSH
19796: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19800: LD_EXP 70
19804: PUSH
19805: LD_INT 1
19807: ARRAY
19808: IFFALSE 19828
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19810: LD_VAR 0 6
19814: PPUSH
19815: LD_EXP 70
19819: PUSH
19820: LD_INT 1
19822: ARRAY
19823: PPUSH
19824: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19828: LD_ADDR_EXP 68
19832: PUSH
19833: LD_EXP 68
19837: PPUSH
19838: LD_INT 1
19840: PPUSH
19841: LD_INT 1
19843: PPUSH
19844: CALL_OW 1
19848: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19849: LD_INT 7
19851: PPUSH
19852: LD_EXP 72
19856: PUSH
19857: LD_INT 1
19859: ARRAY
19860: PUSH
19861: LD_INT 3
19863: ARRAY
19864: PPUSH
19865: LD_INT 0
19867: PPUSH
19868: LD_VAR 0 6
19872: PPUSH
19873: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19877: LD_VAR 0 2
19881: PUSH
19882: LD_EXP 72
19886: PUSH
19887: LD_INT 2
19889: ARRAY
19890: PUSH
19891: LD_INT 3
19893: ARRAY
19894: EQUAL
19895: IFFALSE 20018
// begin lab := artifactsLabs [ 2 ] ;
19897: LD_ADDR_VAR 0 6
19901: PUSH
19902: LD_EXP 71
19906: PUSH
19907: LD_INT 2
19909: ARRAY
19910: ST_TO_ADDR
// if not lab then
19911: LD_VAR 0 6
19915: NOT
19916: IFFALSE 19920
// exit ;
19918: GO 20857
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19920: LD_VAR 0 6
19924: PPUSH
19925: LD_EXP 69
19929: PUSH
19930: LD_INT 2
19932: ARRAY
19933: PPUSH
19934: LD_INT 1
19936: PPUSH
19937: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19941: LD_EXP 70
19945: PUSH
19946: LD_INT 2
19948: ARRAY
19949: IFFALSE 19969
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19951: LD_VAR 0 6
19955: PPUSH
19956: LD_EXP 70
19960: PUSH
19961: LD_INT 2
19963: ARRAY
19964: PPUSH
19965: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19969: LD_ADDR_EXP 68
19973: PUSH
19974: LD_EXP 68
19978: PPUSH
19979: LD_INT 2
19981: PPUSH
19982: LD_INT 1
19984: PPUSH
19985: CALL_OW 1
19989: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19990: LD_INT 7
19992: PPUSH
19993: LD_EXP 72
19997: PUSH
19998: LD_INT 2
20000: ARRAY
20001: PUSH
20002: LD_INT 3
20004: ARRAY
20005: PPUSH
20006: LD_INT 0
20008: PPUSH
20009: LD_VAR 0 6
20013: PPUSH
20014: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20018: LD_VAR 0 2
20022: PUSH
20023: LD_EXP 72
20027: PUSH
20028: LD_INT 3
20030: ARRAY
20031: PUSH
20032: LD_INT 3
20034: ARRAY
20035: EQUAL
20036: IFFALSE 20159
// begin lab := artifactsLabs [ 3 ] ;
20038: LD_ADDR_VAR 0 6
20042: PUSH
20043: LD_EXP 71
20047: PUSH
20048: LD_INT 3
20050: ARRAY
20051: ST_TO_ADDR
// if not lab then
20052: LD_VAR 0 6
20056: NOT
20057: IFFALSE 20061
// exit ;
20059: GO 20857
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20061: LD_VAR 0 6
20065: PPUSH
20066: LD_EXP 69
20070: PUSH
20071: LD_INT 3
20073: ARRAY
20074: PPUSH
20075: LD_INT 1
20077: PPUSH
20078: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20082: LD_EXP 70
20086: PUSH
20087: LD_INT 3
20089: ARRAY
20090: IFFALSE 20110
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20092: LD_VAR 0 6
20096: PPUSH
20097: LD_EXP 70
20101: PUSH
20102: LD_INT 3
20104: ARRAY
20105: PPUSH
20106: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20110: LD_ADDR_EXP 68
20114: PUSH
20115: LD_EXP 68
20119: PPUSH
20120: LD_INT 3
20122: PPUSH
20123: LD_INT 1
20125: PPUSH
20126: CALL_OW 1
20130: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20131: LD_INT 7
20133: PPUSH
20134: LD_EXP 72
20138: PUSH
20139: LD_INT 3
20141: ARRAY
20142: PUSH
20143: LD_INT 3
20145: ARRAY
20146: PPUSH
20147: LD_INT 0
20149: PPUSH
20150: LD_VAR 0 6
20154: PPUSH
20155: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20159: LD_VAR 0 2
20163: PUSH
20164: LD_EXP 72
20168: PUSH
20169: LD_INT 1
20171: ARRAY
20172: PUSH
20173: LD_INT 1
20175: ARRAY
20176: EQUAL
20177: IFFALSE 20335
// begin lab := artifactsLabs [ 1 ] ;
20179: LD_ADDR_VAR 0 6
20183: PUSH
20184: LD_EXP 71
20188: PUSH
20189: LD_INT 1
20191: ARRAY
20192: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20193: LD_VAR 0 6
20197: PPUSH
20198: CALL_OW 274
20202: PPUSH
20203: CALL 89118 0 1
20207: PUSH
20208: LD_INT 3
20210: ARRAY
20211: PUSH
20212: LD_EXP 66
20216: PUSH
20217: LD_INT 1
20219: ARRAY
20220: LESS
20221: IFFALSE 20235
// begin HintSpec ( ArtifactCost , 2 ) ;
20223: LD_STRING ArtifactCost
20225: PPUSH
20226: LD_INT 2
20228: PPUSH
20229: CALL_OW 338
// exit ;
20233: GO 20857
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20235: LD_ADDR_EXP 73
20239: PUSH
20240: LD_EXP 73
20244: PPUSH
20245: LD_INT 1
20247: PPUSH
20248: LD_INT 0
20250: PPUSH
20251: CALL_OW 1
20255: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20256: LD_VAR 0 3
20260: PPUSH
20261: LD_VAR 0 4
20265: PPUSH
20266: LD_INT 7
20268: PPUSH
20269: LD_INT 12
20271: NEG
20272: PPUSH
20273: CALL_OW 330
// wait ( 0 0$30 ) ;
20277: LD_INT 1050
20279: PPUSH
20280: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20284: LD_VAR 0 3
20288: PPUSH
20289: LD_VAR 0 4
20293: PPUSH
20294: LD_INT 7
20296: PPUSH
20297: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20301: LD_EXP 65
20305: PUSH
20306: LD_INT 1
20308: ARRAY
20309: PPUSH
20310: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20314: LD_ADDR_EXP 73
20318: PUSH
20319: LD_EXP 73
20323: PPUSH
20324: LD_INT 1
20326: PPUSH
20327: LD_INT 1
20329: PPUSH
20330: CALL_OW 1
20334: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20335: LD_VAR 0 2
20339: PUSH
20340: LD_EXP 72
20344: PUSH
20345: LD_INT 2
20347: ARRAY
20348: PUSH
20349: LD_INT 1
20351: ARRAY
20352: EQUAL
20353: IFFALSE 20590
// begin lab := artifactsLabs [ 2 ] ;
20355: LD_ADDR_VAR 0 6
20359: PUSH
20360: LD_EXP 71
20364: PUSH
20365: LD_INT 2
20367: ARRAY
20368: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20369: LD_VAR 0 3
20373: PUSH
20374: LD_INT 81
20376: PUSH
20377: LD_INT 7
20379: PUSH
20380: EMPTY
20381: LIST
20382: LIST
20383: PUSH
20384: LD_INT 2
20386: PUSH
20387: LD_INT 32
20389: PUSH
20390: LD_INT 3
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 30
20399: PUSH
20400: LD_INT 28
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: PUSH
20407: LD_INT 30
20409: PUSH
20410: LD_INT 30
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: PUSH
20417: LD_INT 35
20419: PUSH
20420: LD_INT 49
20422: PUSH
20423: EMPTY
20424: LIST
20425: LIST
20426: PUSH
20427: LD_INT 34
20429: PUSH
20430: LD_INT 49
20432: PUSH
20433: EMPTY
20434: LIST
20435: LIST
20436: PUSH
20437: LD_INT 30
20439: PUSH
20440: LD_INT 21
20442: PUSH
20443: EMPTY
20444: LIST
20445: LIST
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: LIST
20451: LIST
20452: LIST
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PPUSH
20460: CALL_OW 69
20464: IN
20465: NOT
20466: IFFALSE 20470
// exit ;
20468: GO 20857
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20470: LD_VAR 0 6
20474: PPUSH
20475: CALL_OW 274
20479: PPUSH
20480: CALL 89118 0 1
20484: PUSH
20485: LD_INT 3
20487: ARRAY
20488: PUSH
20489: LD_EXP 66
20493: PUSH
20494: LD_INT 2
20496: ARRAY
20497: LESS
20498: IFFALSE 20512
// begin HintSpec ( ArtifactCost , 2 ) ;
20500: LD_STRING ArtifactCost
20502: PPUSH
20503: LD_INT 2
20505: PPUSH
20506: CALL_OW 338
// exit ;
20510: GO 20857
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20512: LD_ADDR_EXP 73
20516: PUSH
20517: LD_EXP 73
20521: PPUSH
20522: LD_INT 2
20524: PPUSH
20525: LD_INT 0
20527: PPUSH
20528: CALL_OW 1
20532: ST_TO_ADDR
// KillUnit ( x ) ;
20533: LD_VAR 0 3
20537: PPUSH
20538: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20542: LD_ADDR_EXP 16
20546: PUSH
20547: LD_EXP 16
20551: PUSH
20552: LD_INT 1
20554: PLUS
20555: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20556: LD_EXP 65
20560: PUSH
20561: LD_INT 2
20563: ARRAY
20564: PPUSH
20565: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20569: LD_ADDR_EXP 73
20573: PUSH
20574: LD_EXP 73
20578: PPUSH
20579: LD_INT 2
20581: PPUSH
20582: LD_INT 1
20584: PPUSH
20585: CALL_OW 1
20589: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20590: LD_VAR 0 2
20594: PUSH
20595: LD_EXP 72
20599: PUSH
20600: LD_INT 3
20602: ARRAY
20603: PUSH
20604: LD_INT 1
20606: ARRAY
20607: EQUAL
20608: IFFALSE 20857
// begin lab := artifactsLabs [ 3 ] ;
20610: LD_ADDR_VAR 0 6
20614: PUSH
20615: LD_EXP 71
20619: PUSH
20620: LD_INT 3
20622: ARRAY
20623: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20624: LD_VAR 0 6
20628: PPUSH
20629: CALL_OW 274
20633: PPUSH
20634: CALL 89118 0 1
20638: PUSH
20639: LD_INT 3
20641: ARRAY
20642: PUSH
20643: LD_EXP 66
20647: PUSH
20648: LD_INT 3
20650: ARRAY
20651: LESS
20652: IFFALSE 20666
// begin HintSpec ( ArtifactCost , 2 ) ;
20654: LD_STRING ArtifactCost
20656: PPUSH
20657: LD_INT 2
20659: PPUSH
20660: CALL_OW 338
// exit ;
20664: GO 20857
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20666: LD_INT 37
20668: PPUSH
20669: LD_INT 1
20671: PPUSH
20672: CALL_OW 424
// time := 0 0$30 ;
20676: LD_ADDR_VAR 0 7
20680: PUSH
20681: LD_INT 1050
20683: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20684: LD_ADDR_EXP 73
20688: PUSH
20689: LD_EXP 73
20693: PPUSH
20694: LD_INT 3
20696: PPUSH
20697: LD_INT 0
20699: PPUSH
20700: CALL_OW 1
20704: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20705: LD_ADDR_OWVAR 47
20709: PUSH
20710: LD_STRING #Am15a-1
20712: PUSH
20713: LD_VAR 0 7
20717: PUSH
20718: EMPTY
20719: LIST
20720: LIST
20721: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20722: LD_INT 35
20724: PPUSH
20725: CALL_OW 67
// time := time - 0 0$1 ;
20729: LD_ADDR_VAR 0 7
20733: PUSH
20734: LD_VAR 0 7
20738: PUSH
20739: LD_INT 35
20741: MINUS
20742: ST_TO_ADDR
// until time = 0 0$00 ;
20743: LD_VAR 0 7
20747: PUSH
20748: LD_INT 0
20750: EQUAL
20751: IFFALSE 20705
// display_strings :=  ;
20753: LD_ADDR_OWVAR 47
20757: PUSH
20758: LD_STRING 
20760: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20761: LD_INT 37
20763: PPUSH
20764: LD_INT 0
20766: PPUSH
20767: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20771: LD_ADDR_VAR 0 8
20775: PUSH
20776: LD_INT 37
20778: PPUSH
20779: LD_INT 3
20781: PUSH
20782: LD_INT 21
20784: PUSH
20785: LD_INT 3
20787: PUSH
20788: EMPTY
20789: LIST
20790: LIST
20791: PUSH
20792: EMPTY
20793: LIST
20794: LIST
20795: PPUSH
20796: CALL_OW 70
20800: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20801: LD_VAR 0 3
20805: PPUSH
20806: LD_VAR 0 4
20810: PPUSH
20811: CALL_OW 84
// for un in list do
20815: LD_ADDR_VAR 0 9
20819: PUSH
20820: LD_VAR 0 8
20824: PUSH
20825: FOR_IN
20826: IFFALSE 20855
// TeleportUnit ( un , x , y , 12 , true ) ;
20828: LD_VAR 0 9
20832: PPUSH
20833: LD_VAR 0 3
20837: PPUSH
20838: LD_VAR 0 4
20842: PPUSH
20843: LD_INT 12
20845: PPUSH
20846: LD_INT 1
20848: PPUSH
20849: CALL_OW 483
20853: GO 20825
20855: POP
20856: POP
// end ; end ;
20857: PPOPN 9
20859: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20860: LD_INT 0
20862: PPUSH
20863: PPUSH
// begin labNum := 0 ;
20864: LD_ADDR_VAR 0 4
20868: PUSH
20869: LD_INT 0
20871: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20872: LD_ADDR_VAR 0 3
20876: PUSH
20877: DOUBLE
20878: LD_INT 1
20880: DEC
20881: ST_TO_ADDR
20882: LD_EXP 71
20886: PUSH
20887: FOR_TO
20888: IFFALSE 20922
// if artifactsLabs [ i ] = lab then
20890: LD_EXP 71
20894: PUSH
20895: LD_VAR 0 3
20899: ARRAY
20900: PUSH
20901: LD_VAR 0 1
20905: EQUAL
20906: IFFALSE 20920
// begin labNum := i ;
20908: LD_ADDR_VAR 0 4
20912: PUSH
20913: LD_VAR 0 3
20917: ST_TO_ADDR
// break ;
20918: GO 20922
// end ;
20920: GO 20887
20922: POP
20923: POP
// if not labNum then
20924: LD_VAR 0 4
20928: NOT
20929: IFFALSE 20933
// exit ;
20931: GO 21011
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20933: LD_INT 7
20935: PPUSH
20936: LD_EXP 72
20940: PUSH
20941: LD_VAR 0 4
20945: ARRAY
20946: PUSH
20947: LD_INT 3
20949: ARRAY
20950: PPUSH
20951: LD_INT 2
20953: PPUSH
20954: LD_VAR 0 1
20958: PPUSH
20959: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20963: LD_ADDR_EXP 70
20967: PUSH
20968: LD_EXP 70
20972: PPUSH
20973: LD_VAR 0 4
20977: PPUSH
20978: LD_VAR 0 2
20982: PPUSH
20983: CALL_OW 1
20987: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20988: LD_ADDR_EXP 68
20992: PUSH
20993: LD_EXP 68
20997: PPUSH
20998: LD_VAR 0 4
21002: PPUSH
21003: LD_INT 0
21005: PPUSH
21006: CALL_OW 1
21010: ST_TO_ADDR
// end ;
21011: PPOPN 4
21013: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21014: LD_INT 0
21016: PPUSH
21017: PPUSH
// begin labNum := 0 ;
21018: LD_ADDR_VAR 0 3
21022: PUSH
21023: LD_INT 0
21025: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21026: LD_ADDR_VAR 0 2
21030: PUSH
21031: DOUBLE
21032: LD_INT 1
21034: DEC
21035: ST_TO_ADDR
21036: LD_EXP 71
21040: PUSH
21041: FOR_TO
21042: IFFALSE 21076
// if artifactsLabs [ i ] = lab then
21044: LD_EXP 71
21048: PUSH
21049: LD_VAR 0 2
21053: ARRAY
21054: PUSH
21055: LD_VAR 0 1
21059: EQUAL
21060: IFFALSE 21074
// begin labNum := i ;
21062: LD_ADDR_VAR 0 3
21066: PUSH
21067: LD_VAR 0 2
21071: ST_TO_ADDR
// break ;
21072: GO 21076
// end ;
21074: GO 21041
21076: POP
21077: POP
// if not labNum then
21078: LD_VAR 0 3
21082: NOT
21083: IFFALSE 21087
// exit ;
21085: GO 21249
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21087: LD_INT 7
21089: PPUSH
21090: LD_EXP 72
21094: PUSH
21095: LD_VAR 0 3
21099: ARRAY
21100: PUSH
21101: LD_INT 3
21103: ARRAY
21104: PPUSH
21105: LD_INT 0
21107: PPUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21117: LD_ADDR_EXP 67
21121: PUSH
21122: LD_EXP 67
21126: PPUSH
21127: LD_VAR 0 3
21131: PPUSH
21132: LD_INT 1
21134: PPUSH
21135: CALL_OW 1
21139: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21140: LD_ADDR_EXP 73
21144: PUSH
21145: LD_EXP 73
21149: PPUSH
21150: LD_VAR 0 3
21154: PPUSH
21155: LD_INT 1
21157: PPUSH
21158: CALL_OW 1
21162: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21163: LD_ADDR_EXP 68
21167: PUSH
21168: LD_EXP 68
21172: PPUSH
21173: LD_VAR 0 3
21177: PPUSH
21178: LD_INT 0
21180: PPUSH
21181: CALL_OW 1
21185: ST_TO_ADDR
// case labNum of 1 :
21186: LD_VAR 0 3
21190: PUSH
21191: LD_INT 1
21193: DOUBLE
21194: EQUAL
21195: IFTRUE 21199
21197: GO 21210
21199: POP
// artifactIResearched := true ; 2 :
21200: LD_ADDR_EXP 12
21204: PUSH
21205: LD_INT 1
21207: ST_TO_ADDR
21208: GO 21249
21210: LD_INT 2
21212: DOUBLE
21213: EQUAL
21214: IFTRUE 21218
21216: GO 21229
21218: POP
// artifactIIResearched := true ; 3 :
21219: LD_ADDR_EXP 13
21223: PUSH
21224: LD_INT 1
21226: ST_TO_ADDR
21227: GO 21249
21229: LD_INT 3
21231: DOUBLE
21232: EQUAL
21233: IFTRUE 21237
21235: GO 21248
21237: POP
// artifactIIIResearched := true ; end ;
21238: LD_ADDR_EXP 14
21242: PUSH
21243: LD_INT 1
21245: ST_TO_ADDR
21246: GO 21249
21248: POP
// end ; end_of_file
21249: PPOPN 3
21251: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
21252: LD_INT 0
21254: PPUSH
// ar_miner := 81 ;
21255: LD_ADDR_EXP 81
21259: PUSH
21260: LD_INT 81
21262: ST_TO_ADDR
// ar_crane := 88 ;
21263: LD_ADDR_EXP 80
21267: PUSH
21268: LD_INT 88
21270: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
21271: LD_ADDR_EXP 75
21275: PUSH
21276: LD_INT 89
21278: ST_TO_ADDR
// us_hack := 99 ;
21279: LD_ADDR_EXP 76
21283: PUSH
21284: LD_INT 99
21286: ST_TO_ADDR
// us_artillery := 97 ;
21287: LD_ADDR_EXP 77
21291: PUSH
21292: LD_INT 97
21294: ST_TO_ADDR
// ar_bio_bomb := 91 ;
21295: LD_ADDR_EXP 78
21299: PUSH
21300: LD_INT 91
21302: ST_TO_ADDR
// ar_mortar := 92 ;
21303: LD_ADDR_EXP 79
21307: PUSH
21308: LD_INT 92
21310: ST_TO_ADDR
// ru_flamethrower := 93 ;
21311: LD_ADDR_EXP 82
21315: PUSH
21316: LD_INT 93
21318: ST_TO_ADDR
// ru_radar := 98 ;
21319: LD_ADDR_EXP 74
21323: PUSH
21324: LD_INT 98
21326: ST_TO_ADDR
// tech_Artillery := 80 ;
21327: LD_ADDR_EXP 83
21331: PUSH
21332: LD_INT 80
21334: ST_TO_ADDR
// tech_RadMat := 81 ;
21335: LD_ADDR_EXP 84
21339: PUSH
21340: LD_INT 81
21342: ST_TO_ADDR
// tech_BasicTools := 82 ;
21343: LD_ADDR_EXP 85
21347: PUSH
21348: LD_INT 82
21350: ST_TO_ADDR
// tech_Cargo := 83 ;
21351: LD_ADDR_EXP 86
21355: PUSH
21356: LD_INT 83
21358: ST_TO_ADDR
// tech_Track := 84 ;
21359: LD_ADDR_EXP 87
21363: PUSH
21364: LD_INT 84
21366: ST_TO_ADDR
// tech_Crane := 85 ;
21367: LD_ADDR_EXP 88
21371: PUSH
21372: LD_INT 85
21374: ST_TO_ADDR
// tech_Bulldozer := 86 ;
21375: LD_ADDR_EXP 89
21379: PUSH
21380: LD_INT 86
21382: ST_TO_ADDR
// tech_Hovercraft := 87 ;
21383: LD_ADDR_EXP 90
21387: PUSH
21388: LD_INT 87
21390: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
21391: LD_ADDR_EXP 91
21395: PUSH
21396: LD_INT 88
21398: ST_TO_ADDR
// class_mastodont := 31 ;
21399: LD_ADDR_EXP 92
21403: PUSH
21404: LD_INT 31
21406: ST_TO_ADDR
// class_horse := 21 ;
21407: LD_ADDR_EXP 93
21411: PUSH
21412: LD_INT 21
21414: ST_TO_ADDR
// end ;
21415: LD_VAR 0 1
21419: RET
// every 1 do
21420: GO 21422
21422: DISABLE
// InitGlobalVariables ; end_of_file
21423: CALL 21252 0 0
21427: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
21428: LD_INT 0
21430: PPUSH
21431: PPUSH
// skirmish := false ;
21432: LD_ADDR_EXP 94
21436: PUSH
21437: LD_INT 0
21439: ST_TO_ADDR
// debug_mc := false ;
21440: LD_ADDR_EXP 95
21444: PUSH
21445: LD_INT 0
21447: ST_TO_ADDR
// mc_bases := [ ] ;
21448: LD_ADDR_EXP 96
21452: PUSH
21453: EMPTY
21454: ST_TO_ADDR
// mc_sides := [ ] ;
21455: LD_ADDR_EXP 122
21459: PUSH
21460: EMPTY
21461: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21462: LD_ADDR_EXP 97
21466: PUSH
21467: EMPTY
21468: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21469: LD_ADDR_EXP 98
21473: PUSH
21474: EMPTY
21475: ST_TO_ADDR
// mc_need_heal := [ ] ;
21476: LD_ADDR_EXP 99
21480: PUSH
21481: EMPTY
21482: ST_TO_ADDR
// mc_healers := [ ] ;
21483: LD_ADDR_EXP 100
21487: PUSH
21488: EMPTY
21489: ST_TO_ADDR
// mc_build_list := [ ] ;
21490: LD_ADDR_EXP 101
21494: PUSH
21495: EMPTY
21496: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21497: LD_ADDR_EXP 128
21501: PUSH
21502: EMPTY
21503: ST_TO_ADDR
// mc_builders := [ ] ;
21504: LD_ADDR_EXP 102
21508: PUSH
21509: EMPTY
21510: ST_TO_ADDR
// mc_construct_list := [ ] ;
21511: LD_ADDR_EXP 103
21515: PUSH
21516: EMPTY
21517: ST_TO_ADDR
// mc_turret_list := [ ] ;
21518: LD_ADDR_EXP 104
21522: PUSH
21523: EMPTY
21524: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21525: LD_ADDR_EXP 105
21529: PUSH
21530: EMPTY
21531: ST_TO_ADDR
// mc_miners := [ ] ;
21532: LD_ADDR_EXP 110
21536: PUSH
21537: EMPTY
21538: ST_TO_ADDR
// mc_mines := [ ] ;
21539: LD_ADDR_EXP 109
21543: PUSH
21544: EMPTY
21545: ST_TO_ADDR
// mc_minefields := [ ] ;
21546: LD_ADDR_EXP 111
21550: PUSH
21551: EMPTY
21552: ST_TO_ADDR
// mc_crates := [ ] ;
21553: LD_ADDR_EXP 112
21557: PUSH
21558: EMPTY
21559: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21560: LD_ADDR_EXP 113
21564: PUSH
21565: EMPTY
21566: ST_TO_ADDR
// mc_crates_area := [ ] ;
21567: LD_ADDR_EXP 114
21571: PUSH
21572: EMPTY
21573: ST_TO_ADDR
// mc_vehicles := [ ] ;
21574: LD_ADDR_EXP 115
21578: PUSH
21579: EMPTY
21580: ST_TO_ADDR
// mc_attack := [ ] ;
21581: LD_ADDR_EXP 116
21585: PUSH
21586: EMPTY
21587: ST_TO_ADDR
// mc_produce := [ ] ;
21588: LD_ADDR_EXP 117
21592: PUSH
21593: EMPTY
21594: ST_TO_ADDR
// mc_defender := [ ] ;
21595: LD_ADDR_EXP 118
21599: PUSH
21600: EMPTY
21601: ST_TO_ADDR
// mc_parking := [ ] ;
21602: LD_ADDR_EXP 120
21606: PUSH
21607: EMPTY
21608: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21609: LD_ADDR_EXP 106
21613: PUSH
21614: EMPTY
21615: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21616: LD_ADDR_EXP 108
21620: PUSH
21621: EMPTY
21622: ST_TO_ADDR
// mc_scan := [ ] ;
21623: LD_ADDR_EXP 119
21627: PUSH
21628: EMPTY
21629: ST_TO_ADDR
// mc_scan_area := [ ] ;
21630: LD_ADDR_EXP 121
21634: PUSH
21635: EMPTY
21636: ST_TO_ADDR
// mc_tech := [ ] ;
21637: LD_ADDR_EXP 123
21641: PUSH
21642: EMPTY
21643: ST_TO_ADDR
// mc_class := [ ] ;
21644: LD_ADDR_EXP 137
21648: PUSH
21649: EMPTY
21650: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21651: LD_ADDR_EXP 138
21655: PUSH
21656: EMPTY
21657: ST_TO_ADDR
// mc_is_defending := [ ] ;
21658: LD_ADDR_EXP 139
21662: PUSH
21663: EMPTY
21664: ST_TO_ADDR
// end ;
21665: LD_VAR 0 1
21669: RET
// export function MC_Kill ( base ) ; begin
21670: LD_INT 0
21672: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21673: LD_ADDR_EXP 96
21677: PUSH
21678: LD_EXP 96
21682: PPUSH
21683: LD_VAR 0 1
21687: PPUSH
21688: EMPTY
21689: PPUSH
21690: CALL_OW 1
21694: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21695: LD_ADDR_EXP 97
21699: PUSH
21700: LD_EXP 97
21704: PPUSH
21705: LD_VAR 0 1
21709: PPUSH
21710: EMPTY
21711: PPUSH
21712: CALL_OW 1
21716: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21717: LD_ADDR_EXP 98
21721: PUSH
21722: LD_EXP 98
21726: PPUSH
21727: LD_VAR 0 1
21731: PPUSH
21732: EMPTY
21733: PPUSH
21734: CALL_OW 1
21738: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21739: LD_ADDR_EXP 99
21743: PUSH
21744: LD_EXP 99
21748: PPUSH
21749: LD_VAR 0 1
21753: PPUSH
21754: EMPTY
21755: PPUSH
21756: CALL_OW 1
21760: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21761: LD_ADDR_EXP 100
21765: PUSH
21766: LD_EXP 100
21770: PPUSH
21771: LD_VAR 0 1
21775: PPUSH
21776: EMPTY
21777: PPUSH
21778: CALL_OW 1
21782: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21783: LD_ADDR_EXP 101
21787: PUSH
21788: LD_EXP 101
21792: PPUSH
21793: LD_VAR 0 1
21797: PPUSH
21798: EMPTY
21799: PPUSH
21800: CALL_OW 1
21804: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21805: LD_ADDR_EXP 102
21809: PUSH
21810: LD_EXP 102
21814: PPUSH
21815: LD_VAR 0 1
21819: PPUSH
21820: EMPTY
21821: PPUSH
21822: CALL_OW 1
21826: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21827: LD_ADDR_EXP 103
21831: PUSH
21832: LD_EXP 103
21836: PPUSH
21837: LD_VAR 0 1
21841: PPUSH
21842: EMPTY
21843: PPUSH
21844: CALL_OW 1
21848: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21849: LD_ADDR_EXP 104
21853: PUSH
21854: LD_EXP 104
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: EMPTY
21865: PPUSH
21866: CALL_OW 1
21870: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21871: LD_ADDR_EXP 105
21875: PUSH
21876: LD_EXP 105
21880: PPUSH
21881: LD_VAR 0 1
21885: PPUSH
21886: EMPTY
21887: PPUSH
21888: CALL_OW 1
21892: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21893: LD_ADDR_EXP 106
21897: PUSH
21898: LD_EXP 106
21902: PPUSH
21903: LD_VAR 0 1
21907: PPUSH
21908: EMPTY
21909: PPUSH
21910: CALL_OW 1
21914: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21915: LD_ADDR_EXP 107
21919: PUSH
21920: LD_EXP 107
21924: PPUSH
21925: LD_VAR 0 1
21929: PPUSH
21930: LD_INT 0
21932: PPUSH
21933: CALL_OW 1
21937: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21938: LD_ADDR_EXP 108
21942: PUSH
21943: LD_EXP 108
21947: PPUSH
21948: LD_VAR 0 1
21952: PPUSH
21953: EMPTY
21954: PPUSH
21955: CALL_OW 1
21959: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21960: LD_ADDR_EXP 109
21964: PUSH
21965: LD_EXP 109
21969: PPUSH
21970: LD_VAR 0 1
21974: PPUSH
21975: EMPTY
21976: PPUSH
21977: CALL_OW 1
21981: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21982: LD_ADDR_EXP 110
21986: PUSH
21987: LD_EXP 110
21991: PPUSH
21992: LD_VAR 0 1
21996: PPUSH
21997: EMPTY
21998: PPUSH
21999: CALL_OW 1
22003: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22004: LD_ADDR_EXP 111
22008: PUSH
22009: LD_EXP 111
22013: PPUSH
22014: LD_VAR 0 1
22018: PPUSH
22019: EMPTY
22020: PPUSH
22021: CALL_OW 1
22025: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22026: LD_ADDR_EXP 112
22030: PUSH
22031: LD_EXP 112
22035: PPUSH
22036: LD_VAR 0 1
22040: PPUSH
22041: EMPTY
22042: PPUSH
22043: CALL_OW 1
22047: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22048: LD_ADDR_EXP 113
22052: PUSH
22053: LD_EXP 113
22057: PPUSH
22058: LD_VAR 0 1
22062: PPUSH
22063: EMPTY
22064: PPUSH
22065: CALL_OW 1
22069: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22070: LD_ADDR_EXP 114
22074: PUSH
22075: LD_EXP 114
22079: PPUSH
22080: LD_VAR 0 1
22084: PPUSH
22085: EMPTY
22086: PPUSH
22087: CALL_OW 1
22091: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22092: LD_ADDR_EXP 115
22096: PUSH
22097: LD_EXP 115
22101: PPUSH
22102: LD_VAR 0 1
22106: PPUSH
22107: EMPTY
22108: PPUSH
22109: CALL_OW 1
22113: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22114: LD_ADDR_EXP 116
22118: PUSH
22119: LD_EXP 116
22123: PPUSH
22124: LD_VAR 0 1
22128: PPUSH
22129: EMPTY
22130: PPUSH
22131: CALL_OW 1
22135: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22136: LD_ADDR_EXP 117
22140: PUSH
22141: LD_EXP 117
22145: PPUSH
22146: LD_VAR 0 1
22150: PPUSH
22151: EMPTY
22152: PPUSH
22153: CALL_OW 1
22157: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22158: LD_ADDR_EXP 118
22162: PUSH
22163: LD_EXP 118
22167: PPUSH
22168: LD_VAR 0 1
22172: PPUSH
22173: EMPTY
22174: PPUSH
22175: CALL_OW 1
22179: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22180: LD_ADDR_EXP 119
22184: PUSH
22185: LD_EXP 119
22189: PPUSH
22190: LD_VAR 0 1
22194: PPUSH
22195: EMPTY
22196: PPUSH
22197: CALL_OW 1
22201: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22202: LD_ADDR_EXP 120
22206: PUSH
22207: LD_EXP 120
22211: PPUSH
22212: LD_VAR 0 1
22216: PPUSH
22217: EMPTY
22218: PPUSH
22219: CALL_OW 1
22223: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22224: LD_ADDR_EXP 121
22228: PUSH
22229: LD_EXP 121
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: EMPTY
22240: PPUSH
22241: CALL_OW 1
22245: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22246: LD_ADDR_EXP 123
22250: PUSH
22251: LD_EXP 123
22255: PPUSH
22256: LD_VAR 0 1
22260: PPUSH
22261: EMPTY
22262: PPUSH
22263: CALL_OW 1
22267: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22268: LD_ADDR_EXP 125
22272: PUSH
22273: LD_EXP 125
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: EMPTY
22284: PPUSH
22285: CALL_OW 1
22289: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22290: LD_ADDR_EXP 126
22294: PUSH
22295: LD_EXP 126
22299: PPUSH
22300: LD_VAR 0 1
22304: PPUSH
22305: EMPTY
22306: PPUSH
22307: CALL_OW 1
22311: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22312: LD_ADDR_EXP 127
22316: PUSH
22317: LD_EXP 127
22321: PPUSH
22322: LD_VAR 0 1
22326: PPUSH
22327: EMPTY
22328: PPUSH
22329: CALL_OW 1
22333: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22334: LD_ADDR_EXP 128
22338: PUSH
22339: LD_EXP 128
22343: PPUSH
22344: LD_VAR 0 1
22348: PPUSH
22349: EMPTY
22350: PPUSH
22351: CALL_OW 1
22355: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22356: LD_ADDR_EXP 129
22360: PUSH
22361: LD_EXP 129
22365: PPUSH
22366: LD_VAR 0 1
22370: PPUSH
22371: EMPTY
22372: PPUSH
22373: CALL_OW 1
22377: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22378: LD_ADDR_EXP 130
22382: PUSH
22383: LD_EXP 130
22387: PPUSH
22388: LD_VAR 0 1
22392: PPUSH
22393: EMPTY
22394: PPUSH
22395: CALL_OW 1
22399: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22400: LD_ADDR_EXP 131
22404: PUSH
22405: LD_EXP 131
22409: PPUSH
22410: LD_VAR 0 1
22414: PPUSH
22415: EMPTY
22416: PPUSH
22417: CALL_OW 1
22421: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22422: LD_ADDR_EXP 132
22426: PUSH
22427: LD_EXP 132
22431: PPUSH
22432: LD_VAR 0 1
22436: PPUSH
22437: EMPTY
22438: PPUSH
22439: CALL_OW 1
22443: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22444: LD_ADDR_EXP 133
22448: PUSH
22449: LD_EXP 133
22453: PPUSH
22454: LD_VAR 0 1
22458: PPUSH
22459: EMPTY
22460: PPUSH
22461: CALL_OW 1
22465: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22466: LD_ADDR_EXP 134
22470: PUSH
22471: LD_EXP 134
22475: PPUSH
22476: LD_VAR 0 1
22480: PPUSH
22481: EMPTY
22482: PPUSH
22483: CALL_OW 1
22487: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22488: LD_ADDR_EXP 135
22492: PUSH
22493: LD_EXP 135
22497: PPUSH
22498: LD_VAR 0 1
22502: PPUSH
22503: EMPTY
22504: PPUSH
22505: CALL_OW 1
22509: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22510: LD_ADDR_EXP 136
22514: PUSH
22515: LD_EXP 136
22519: PPUSH
22520: LD_VAR 0 1
22524: PPUSH
22525: EMPTY
22526: PPUSH
22527: CALL_OW 1
22531: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22532: LD_ADDR_EXP 137
22536: PUSH
22537: LD_EXP 137
22541: PPUSH
22542: LD_VAR 0 1
22546: PPUSH
22547: EMPTY
22548: PPUSH
22549: CALL_OW 1
22553: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22554: LD_ADDR_EXP 138
22558: PUSH
22559: LD_EXP 138
22563: PPUSH
22564: LD_VAR 0 1
22568: PPUSH
22569: LD_INT 0
22571: PPUSH
22572: CALL_OW 1
22576: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22577: LD_ADDR_EXP 139
22581: PUSH
22582: LD_EXP 139
22586: PPUSH
22587: LD_VAR 0 1
22591: PPUSH
22592: LD_INT 0
22594: PPUSH
22595: CALL_OW 1
22599: ST_TO_ADDR
// end ;
22600: LD_VAR 0 2
22604: RET
// export function MC_Add ( side , units ) ; var base ; begin
22605: LD_INT 0
22607: PPUSH
22608: PPUSH
// base := mc_bases + 1 ;
22609: LD_ADDR_VAR 0 4
22613: PUSH
22614: LD_EXP 96
22618: PUSH
22619: LD_INT 1
22621: PLUS
22622: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22623: LD_ADDR_EXP 122
22627: PUSH
22628: LD_EXP 122
22632: PPUSH
22633: LD_VAR 0 4
22637: PPUSH
22638: LD_VAR 0 1
22642: PPUSH
22643: CALL_OW 1
22647: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22648: LD_ADDR_EXP 96
22652: PUSH
22653: LD_EXP 96
22657: PPUSH
22658: LD_VAR 0 4
22662: PPUSH
22663: LD_VAR 0 2
22667: PPUSH
22668: CALL_OW 1
22672: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22673: LD_ADDR_EXP 97
22677: PUSH
22678: LD_EXP 97
22682: PPUSH
22683: LD_VAR 0 4
22687: PPUSH
22688: EMPTY
22689: PPUSH
22690: CALL_OW 1
22694: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22695: LD_ADDR_EXP 98
22699: PUSH
22700: LD_EXP 98
22704: PPUSH
22705: LD_VAR 0 4
22709: PPUSH
22710: EMPTY
22711: PPUSH
22712: CALL_OW 1
22716: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22717: LD_ADDR_EXP 99
22721: PUSH
22722: LD_EXP 99
22726: PPUSH
22727: LD_VAR 0 4
22731: PPUSH
22732: EMPTY
22733: PPUSH
22734: CALL_OW 1
22738: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22739: LD_ADDR_EXP 100
22743: PUSH
22744: LD_EXP 100
22748: PPUSH
22749: LD_VAR 0 4
22753: PPUSH
22754: EMPTY
22755: PPUSH
22756: CALL_OW 1
22760: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22761: LD_ADDR_EXP 101
22765: PUSH
22766: LD_EXP 101
22770: PPUSH
22771: LD_VAR 0 4
22775: PPUSH
22776: EMPTY
22777: PPUSH
22778: CALL_OW 1
22782: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22783: LD_ADDR_EXP 102
22787: PUSH
22788: LD_EXP 102
22792: PPUSH
22793: LD_VAR 0 4
22797: PPUSH
22798: EMPTY
22799: PPUSH
22800: CALL_OW 1
22804: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22805: LD_ADDR_EXP 103
22809: PUSH
22810: LD_EXP 103
22814: PPUSH
22815: LD_VAR 0 4
22819: PPUSH
22820: EMPTY
22821: PPUSH
22822: CALL_OW 1
22826: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22827: LD_ADDR_EXP 104
22831: PUSH
22832: LD_EXP 104
22836: PPUSH
22837: LD_VAR 0 4
22841: PPUSH
22842: EMPTY
22843: PPUSH
22844: CALL_OW 1
22848: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22849: LD_ADDR_EXP 105
22853: PUSH
22854: LD_EXP 105
22858: PPUSH
22859: LD_VAR 0 4
22863: PPUSH
22864: EMPTY
22865: PPUSH
22866: CALL_OW 1
22870: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22871: LD_ADDR_EXP 106
22875: PUSH
22876: LD_EXP 106
22880: PPUSH
22881: LD_VAR 0 4
22885: PPUSH
22886: EMPTY
22887: PPUSH
22888: CALL_OW 1
22892: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22893: LD_ADDR_EXP 107
22897: PUSH
22898: LD_EXP 107
22902: PPUSH
22903: LD_VAR 0 4
22907: PPUSH
22908: LD_INT 0
22910: PPUSH
22911: CALL_OW 1
22915: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22916: LD_ADDR_EXP 108
22920: PUSH
22921: LD_EXP 108
22925: PPUSH
22926: LD_VAR 0 4
22930: PPUSH
22931: EMPTY
22932: PPUSH
22933: CALL_OW 1
22937: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22938: LD_ADDR_EXP 109
22942: PUSH
22943: LD_EXP 109
22947: PPUSH
22948: LD_VAR 0 4
22952: PPUSH
22953: EMPTY
22954: PPUSH
22955: CALL_OW 1
22959: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22960: LD_ADDR_EXP 110
22964: PUSH
22965: LD_EXP 110
22969: PPUSH
22970: LD_VAR 0 4
22974: PPUSH
22975: EMPTY
22976: PPUSH
22977: CALL_OW 1
22981: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22982: LD_ADDR_EXP 111
22986: PUSH
22987: LD_EXP 111
22991: PPUSH
22992: LD_VAR 0 4
22996: PPUSH
22997: EMPTY
22998: PPUSH
22999: CALL_OW 1
23003: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23004: LD_ADDR_EXP 112
23008: PUSH
23009: LD_EXP 112
23013: PPUSH
23014: LD_VAR 0 4
23018: PPUSH
23019: EMPTY
23020: PPUSH
23021: CALL_OW 1
23025: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23026: LD_ADDR_EXP 113
23030: PUSH
23031: LD_EXP 113
23035: PPUSH
23036: LD_VAR 0 4
23040: PPUSH
23041: EMPTY
23042: PPUSH
23043: CALL_OW 1
23047: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23048: LD_ADDR_EXP 114
23052: PUSH
23053: LD_EXP 114
23057: PPUSH
23058: LD_VAR 0 4
23062: PPUSH
23063: EMPTY
23064: PPUSH
23065: CALL_OW 1
23069: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23070: LD_ADDR_EXP 115
23074: PUSH
23075: LD_EXP 115
23079: PPUSH
23080: LD_VAR 0 4
23084: PPUSH
23085: EMPTY
23086: PPUSH
23087: CALL_OW 1
23091: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23092: LD_ADDR_EXP 116
23096: PUSH
23097: LD_EXP 116
23101: PPUSH
23102: LD_VAR 0 4
23106: PPUSH
23107: EMPTY
23108: PPUSH
23109: CALL_OW 1
23113: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23114: LD_ADDR_EXP 117
23118: PUSH
23119: LD_EXP 117
23123: PPUSH
23124: LD_VAR 0 4
23128: PPUSH
23129: EMPTY
23130: PPUSH
23131: CALL_OW 1
23135: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23136: LD_ADDR_EXP 118
23140: PUSH
23141: LD_EXP 118
23145: PPUSH
23146: LD_VAR 0 4
23150: PPUSH
23151: EMPTY
23152: PPUSH
23153: CALL_OW 1
23157: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23158: LD_ADDR_EXP 119
23162: PUSH
23163: LD_EXP 119
23167: PPUSH
23168: LD_VAR 0 4
23172: PPUSH
23173: EMPTY
23174: PPUSH
23175: CALL_OW 1
23179: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23180: LD_ADDR_EXP 120
23184: PUSH
23185: LD_EXP 120
23189: PPUSH
23190: LD_VAR 0 4
23194: PPUSH
23195: EMPTY
23196: PPUSH
23197: CALL_OW 1
23201: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23202: LD_ADDR_EXP 121
23206: PUSH
23207: LD_EXP 121
23211: PPUSH
23212: LD_VAR 0 4
23216: PPUSH
23217: EMPTY
23218: PPUSH
23219: CALL_OW 1
23223: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23224: LD_ADDR_EXP 123
23228: PUSH
23229: LD_EXP 123
23233: PPUSH
23234: LD_VAR 0 4
23238: PPUSH
23239: EMPTY
23240: PPUSH
23241: CALL_OW 1
23245: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23246: LD_ADDR_EXP 125
23250: PUSH
23251: LD_EXP 125
23255: PPUSH
23256: LD_VAR 0 4
23260: PPUSH
23261: EMPTY
23262: PPUSH
23263: CALL_OW 1
23267: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23268: LD_ADDR_EXP 126
23272: PUSH
23273: LD_EXP 126
23277: PPUSH
23278: LD_VAR 0 4
23282: PPUSH
23283: EMPTY
23284: PPUSH
23285: CALL_OW 1
23289: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23290: LD_ADDR_EXP 127
23294: PUSH
23295: LD_EXP 127
23299: PPUSH
23300: LD_VAR 0 4
23304: PPUSH
23305: EMPTY
23306: PPUSH
23307: CALL_OW 1
23311: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23312: LD_ADDR_EXP 128
23316: PUSH
23317: LD_EXP 128
23321: PPUSH
23322: LD_VAR 0 4
23326: PPUSH
23327: EMPTY
23328: PPUSH
23329: CALL_OW 1
23333: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23334: LD_ADDR_EXP 129
23338: PUSH
23339: LD_EXP 129
23343: PPUSH
23344: LD_VAR 0 4
23348: PPUSH
23349: EMPTY
23350: PPUSH
23351: CALL_OW 1
23355: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23356: LD_ADDR_EXP 130
23360: PUSH
23361: LD_EXP 130
23365: PPUSH
23366: LD_VAR 0 4
23370: PPUSH
23371: EMPTY
23372: PPUSH
23373: CALL_OW 1
23377: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23378: LD_ADDR_EXP 131
23382: PUSH
23383: LD_EXP 131
23387: PPUSH
23388: LD_VAR 0 4
23392: PPUSH
23393: EMPTY
23394: PPUSH
23395: CALL_OW 1
23399: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23400: LD_ADDR_EXP 132
23404: PUSH
23405: LD_EXP 132
23409: PPUSH
23410: LD_VAR 0 4
23414: PPUSH
23415: EMPTY
23416: PPUSH
23417: CALL_OW 1
23421: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23422: LD_ADDR_EXP 133
23426: PUSH
23427: LD_EXP 133
23431: PPUSH
23432: LD_VAR 0 4
23436: PPUSH
23437: EMPTY
23438: PPUSH
23439: CALL_OW 1
23443: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23444: LD_ADDR_EXP 134
23448: PUSH
23449: LD_EXP 134
23453: PPUSH
23454: LD_VAR 0 4
23458: PPUSH
23459: EMPTY
23460: PPUSH
23461: CALL_OW 1
23465: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23466: LD_ADDR_EXP 135
23470: PUSH
23471: LD_EXP 135
23475: PPUSH
23476: LD_VAR 0 4
23480: PPUSH
23481: EMPTY
23482: PPUSH
23483: CALL_OW 1
23487: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23488: LD_ADDR_EXP 136
23492: PUSH
23493: LD_EXP 136
23497: PPUSH
23498: LD_VAR 0 4
23502: PPUSH
23503: EMPTY
23504: PPUSH
23505: CALL_OW 1
23509: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23510: LD_ADDR_EXP 137
23514: PUSH
23515: LD_EXP 137
23519: PPUSH
23520: LD_VAR 0 4
23524: PPUSH
23525: EMPTY
23526: PPUSH
23527: CALL_OW 1
23531: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23532: LD_ADDR_EXP 138
23536: PUSH
23537: LD_EXP 138
23541: PPUSH
23542: LD_VAR 0 4
23546: PPUSH
23547: LD_INT 0
23549: PPUSH
23550: CALL_OW 1
23554: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23555: LD_ADDR_EXP 139
23559: PUSH
23560: LD_EXP 139
23564: PPUSH
23565: LD_VAR 0 4
23569: PPUSH
23570: LD_INT 0
23572: PPUSH
23573: CALL_OW 1
23577: ST_TO_ADDR
// result := base ;
23578: LD_ADDR_VAR 0 3
23582: PUSH
23583: LD_VAR 0 4
23587: ST_TO_ADDR
// end ;
23588: LD_VAR 0 3
23592: RET
// export function MC_Start ( ) ; var i ; begin
23593: LD_INT 0
23595: PPUSH
23596: PPUSH
// for i = 1 to mc_bases do
23597: LD_ADDR_VAR 0 2
23601: PUSH
23602: DOUBLE
23603: LD_INT 1
23605: DEC
23606: ST_TO_ADDR
23607: LD_EXP 96
23611: PUSH
23612: FOR_TO
23613: IFFALSE 24713
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23615: LD_ADDR_EXP 96
23619: PUSH
23620: LD_EXP 96
23624: PPUSH
23625: LD_VAR 0 2
23629: PPUSH
23630: LD_EXP 96
23634: PUSH
23635: LD_VAR 0 2
23639: ARRAY
23640: PUSH
23641: LD_INT 0
23643: DIFF
23644: PPUSH
23645: CALL_OW 1
23649: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23650: LD_ADDR_EXP 97
23654: PUSH
23655: LD_EXP 97
23659: PPUSH
23660: LD_VAR 0 2
23664: PPUSH
23665: EMPTY
23666: PPUSH
23667: CALL_OW 1
23671: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23672: LD_ADDR_EXP 98
23676: PUSH
23677: LD_EXP 98
23681: PPUSH
23682: LD_VAR 0 2
23686: PPUSH
23687: EMPTY
23688: PPUSH
23689: CALL_OW 1
23693: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23694: LD_ADDR_EXP 99
23698: PUSH
23699: LD_EXP 99
23703: PPUSH
23704: LD_VAR 0 2
23708: PPUSH
23709: EMPTY
23710: PPUSH
23711: CALL_OW 1
23715: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23716: LD_ADDR_EXP 100
23720: PUSH
23721: LD_EXP 100
23725: PPUSH
23726: LD_VAR 0 2
23730: PPUSH
23731: EMPTY
23732: PUSH
23733: EMPTY
23734: PUSH
23735: EMPTY
23736: LIST
23737: LIST
23738: PPUSH
23739: CALL_OW 1
23743: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23744: LD_ADDR_EXP 101
23748: PUSH
23749: LD_EXP 101
23753: PPUSH
23754: LD_VAR 0 2
23758: PPUSH
23759: EMPTY
23760: PPUSH
23761: CALL_OW 1
23765: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23766: LD_ADDR_EXP 128
23770: PUSH
23771: LD_EXP 128
23775: PPUSH
23776: LD_VAR 0 2
23780: PPUSH
23781: EMPTY
23782: PPUSH
23783: CALL_OW 1
23787: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23788: LD_ADDR_EXP 102
23792: PUSH
23793: LD_EXP 102
23797: PPUSH
23798: LD_VAR 0 2
23802: PPUSH
23803: EMPTY
23804: PPUSH
23805: CALL_OW 1
23809: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23810: LD_ADDR_EXP 103
23814: PUSH
23815: LD_EXP 103
23819: PPUSH
23820: LD_VAR 0 2
23824: PPUSH
23825: EMPTY
23826: PPUSH
23827: CALL_OW 1
23831: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23832: LD_ADDR_EXP 104
23836: PUSH
23837: LD_EXP 104
23841: PPUSH
23842: LD_VAR 0 2
23846: PPUSH
23847: LD_EXP 96
23851: PUSH
23852: LD_VAR 0 2
23856: ARRAY
23857: PPUSH
23858: LD_INT 2
23860: PUSH
23861: LD_INT 30
23863: PUSH
23864: LD_INT 32
23866: PUSH
23867: EMPTY
23868: LIST
23869: LIST
23870: PUSH
23871: LD_INT 30
23873: PUSH
23874: LD_INT 33
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: PUSH
23881: EMPTY
23882: LIST
23883: LIST
23884: LIST
23885: PPUSH
23886: CALL_OW 72
23890: PPUSH
23891: CALL_OW 1
23895: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23896: LD_ADDR_EXP 105
23900: PUSH
23901: LD_EXP 105
23905: PPUSH
23906: LD_VAR 0 2
23910: PPUSH
23911: LD_EXP 96
23915: PUSH
23916: LD_VAR 0 2
23920: ARRAY
23921: PPUSH
23922: LD_INT 2
23924: PUSH
23925: LD_INT 30
23927: PUSH
23928: LD_INT 32
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: PUSH
23935: LD_INT 30
23937: PUSH
23938: LD_INT 31
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: PUSH
23945: EMPTY
23946: LIST
23947: LIST
23948: LIST
23949: PUSH
23950: LD_INT 58
23952: PUSH
23953: EMPTY
23954: LIST
23955: PUSH
23956: EMPTY
23957: LIST
23958: LIST
23959: PPUSH
23960: CALL_OW 72
23964: PPUSH
23965: CALL_OW 1
23969: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23970: LD_ADDR_EXP 106
23974: PUSH
23975: LD_EXP 106
23979: PPUSH
23980: LD_VAR 0 2
23984: PPUSH
23985: EMPTY
23986: PPUSH
23987: CALL_OW 1
23991: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23992: LD_ADDR_EXP 110
23996: PUSH
23997: LD_EXP 110
24001: PPUSH
24002: LD_VAR 0 2
24006: PPUSH
24007: EMPTY
24008: PPUSH
24009: CALL_OW 1
24013: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
24014: LD_ADDR_EXP 109
24018: PUSH
24019: LD_EXP 109
24023: PPUSH
24024: LD_VAR 0 2
24028: PPUSH
24029: EMPTY
24030: PPUSH
24031: CALL_OW 1
24035: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24036: LD_ADDR_EXP 111
24040: PUSH
24041: LD_EXP 111
24045: PPUSH
24046: LD_VAR 0 2
24050: PPUSH
24051: EMPTY
24052: PPUSH
24053: CALL_OW 1
24057: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24058: LD_ADDR_EXP 112
24062: PUSH
24063: LD_EXP 112
24067: PPUSH
24068: LD_VAR 0 2
24072: PPUSH
24073: EMPTY
24074: PPUSH
24075: CALL_OW 1
24079: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24080: LD_ADDR_EXP 113
24084: PUSH
24085: LD_EXP 113
24089: PPUSH
24090: LD_VAR 0 2
24094: PPUSH
24095: EMPTY
24096: PPUSH
24097: CALL_OW 1
24101: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24102: LD_ADDR_EXP 114
24106: PUSH
24107: LD_EXP 114
24111: PPUSH
24112: LD_VAR 0 2
24116: PPUSH
24117: EMPTY
24118: PPUSH
24119: CALL_OW 1
24123: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24124: LD_ADDR_EXP 115
24128: PUSH
24129: LD_EXP 115
24133: PPUSH
24134: LD_VAR 0 2
24138: PPUSH
24139: EMPTY
24140: PPUSH
24141: CALL_OW 1
24145: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24146: LD_ADDR_EXP 116
24150: PUSH
24151: LD_EXP 116
24155: PPUSH
24156: LD_VAR 0 2
24160: PPUSH
24161: EMPTY
24162: PPUSH
24163: CALL_OW 1
24167: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24168: LD_ADDR_EXP 117
24172: PUSH
24173: LD_EXP 117
24177: PPUSH
24178: LD_VAR 0 2
24182: PPUSH
24183: EMPTY
24184: PPUSH
24185: CALL_OW 1
24189: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24190: LD_ADDR_EXP 118
24194: PUSH
24195: LD_EXP 118
24199: PPUSH
24200: LD_VAR 0 2
24204: PPUSH
24205: EMPTY
24206: PPUSH
24207: CALL_OW 1
24211: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24212: LD_ADDR_EXP 107
24216: PUSH
24217: LD_EXP 107
24221: PPUSH
24222: LD_VAR 0 2
24226: PPUSH
24227: LD_INT 0
24229: PPUSH
24230: CALL_OW 1
24234: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24235: LD_ADDR_EXP 120
24239: PUSH
24240: LD_EXP 120
24244: PPUSH
24245: LD_VAR 0 2
24249: PPUSH
24250: LD_INT 0
24252: PPUSH
24253: CALL_OW 1
24257: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24258: LD_ADDR_EXP 108
24262: PUSH
24263: LD_EXP 108
24267: PPUSH
24268: LD_VAR 0 2
24272: PPUSH
24273: EMPTY
24274: PPUSH
24275: CALL_OW 1
24279: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24280: LD_ADDR_EXP 119
24284: PUSH
24285: LD_EXP 119
24289: PPUSH
24290: LD_VAR 0 2
24294: PPUSH
24295: LD_INT 0
24297: PPUSH
24298: CALL_OW 1
24302: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24303: LD_ADDR_EXP 121
24307: PUSH
24308: LD_EXP 121
24312: PPUSH
24313: LD_VAR 0 2
24317: PPUSH
24318: EMPTY
24319: PPUSH
24320: CALL_OW 1
24324: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24325: LD_ADDR_EXP 124
24329: PUSH
24330: LD_EXP 124
24334: PPUSH
24335: LD_VAR 0 2
24339: PPUSH
24340: LD_INT 0
24342: PPUSH
24343: CALL_OW 1
24347: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24348: LD_ADDR_EXP 125
24352: PUSH
24353: LD_EXP 125
24357: PPUSH
24358: LD_VAR 0 2
24362: PPUSH
24363: EMPTY
24364: PPUSH
24365: CALL_OW 1
24369: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24370: LD_ADDR_EXP 126
24374: PUSH
24375: LD_EXP 126
24379: PPUSH
24380: LD_VAR 0 2
24384: PPUSH
24385: EMPTY
24386: PPUSH
24387: CALL_OW 1
24391: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24392: LD_ADDR_EXP 127
24396: PUSH
24397: LD_EXP 127
24401: PPUSH
24402: LD_VAR 0 2
24406: PPUSH
24407: EMPTY
24408: PPUSH
24409: CALL_OW 1
24413: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24414: LD_ADDR_EXP 129
24418: PUSH
24419: LD_EXP 129
24423: PPUSH
24424: LD_VAR 0 2
24428: PPUSH
24429: LD_EXP 96
24433: PUSH
24434: LD_VAR 0 2
24438: ARRAY
24439: PPUSH
24440: LD_INT 2
24442: PUSH
24443: LD_INT 30
24445: PUSH
24446: LD_INT 6
24448: PUSH
24449: EMPTY
24450: LIST
24451: LIST
24452: PUSH
24453: LD_INT 30
24455: PUSH
24456: LD_INT 7
24458: PUSH
24459: EMPTY
24460: LIST
24461: LIST
24462: PUSH
24463: LD_INT 30
24465: PUSH
24466: LD_INT 8
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: LIST
24477: LIST
24478: PPUSH
24479: CALL_OW 72
24483: PPUSH
24484: CALL_OW 1
24488: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24489: LD_ADDR_EXP 130
24493: PUSH
24494: LD_EXP 130
24498: PPUSH
24499: LD_VAR 0 2
24503: PPUSH
24504: EMPTY
24505: PPUSH
24506: CALL_OW 1
24510: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24511: LD_ADDR_EXP 131
24515: PUSH
24516: LD_EXP 131
24520: PPUSH
24521: LD_VAR 0 2
24525: PPUSH
24526: EMPTY
24527: PPUSH
24528: CALL_OW 1
24532: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24533: LD_ADDR_EXP 132
24537: PUSH
24538: LD_EXP 132
24542: PPUSH
24543: LD_VAR 0 2
24547: PPUSH
24548: EMPTY
24549: PPUSH
24550: CALL_OW 1
24554: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24555: LD_ADDR_EXP 133
24559: PUSH
24560: LD_EXP 133
24564: PPUSH
24565: LD_VAR 0 2
24569: PPUSH
24570: EMPTY
24571: PPUSH
24572: CALL_OW 1
24576: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24577: LD_ADDR_EXP 134
24581: PUSH
24582: LD_EXP 134
24586: PPUSH
24587: LD_VAR 0 2
24591: PPUSH
24592: EMPTY
24593: PPUSH
24594: CALL_OW 1
24598: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24599: LD_ADDR_EXP 135
24603: PUSH
24604: LD_EXP 135
24608: PPUSH
24609: LD_VAR 0 2
24613: PPUSH
24614: EMPTY
24615: PPUSH
24616: CALL_OW 1
24620: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24621: LD_ADDR_EXP 136
24625: PUSH
24626: LD_EXP 136
24630: PPUSH
24631: LD_VAR 0 2
24635: PPUSH
24636: EMPTY
24637: PPUSH
24638: CALL_OW 1
24642: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24643: LD_ADDR_EXP 137
24647: PUSH
24648: LD_EXP 137
24652: PPUSH
24653: LD_VAR 0 2
24657: PPUSH
24658: EMPTY
24659: PPUSH
24660: CALL_OW 1
24664: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24665: LD_ADDR_EXP 138
24669: PUSH
24670: LD_EXP 138
24674: PPUSH
24675: LD_VAR 0 2
24679: PPUSH
24680: LD_INT 0
24682: PPUSH
24683: CALL_OW 1
24687: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24688: LD_ADDR_EXP 139
24692: PUSH
24693: LD_EXP 139
24697: PPUSH
24698: LD_VAR 0 2
24702: PPUSH
24703: LD_INT 0
24705: PPUSH
24706: CALL_OW 1
24710: ST_TO_ADDR
// end ;
24711: GO 23612
24713: POP
24714: POP
// MC_InitSides ( ) ;
24715: CALL 25001 0 0
// MC_InitResearch ( ) ;
24719: CALL 24740 0 0
// CustomInitMacro ( ) ;
24723: CALL 232 0 0
// skirmish := true ;
24727: LD_ADDR_EXP 94
24731: PUSH
24732: LD_INT 1
24734: ST_TO_ADDR
// end ;
24735: LD_VAR 0 1
24739: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24740: LD_INT 0
24742: PPUSH
24743: PPUSH
24744: PPUSH
24745: PPUSH
24746: PPUSH
24747: PPUSH
// if not mc_bases then
24748: LD_EXP 96
24752: NOT
24753: IFFALSE 24757
// exit ;
24755: GO 24996
// for i = 1 to 8 do
24757: LD_ADDR_VAR 0 2
24761: PUSH
24762: DOUBLE
24763: LD_INT 1
24765: DEC
24766: ST_TO_ADDR
24767: LD_INT 8
24769: PUSH
24770: FOR_TO
24771: IFFALSE 24797
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24773: LD_ADDR_EXP 123
24777: PUSH
24778: LD_EXP 123
24782: PPUSH
24783: LD_VAR 0 2
24787: PPUSH
24788: EMPTY
24789: PPUSH
24790: CALL_OW 1
24794: ST_TO_ADDR
24795: GO 24770
24797: POP
24798: POP
// tmp := [ ] ;
24799: LD_ADDR_VAR 0 5
24803: PUSH
24804: EMPTY
24805: ST_TO_ADDR
// for i = 1 to mc_sides do
24806: LD_ADDR_VAR 0 2
24810: PUSH
24811: DOUBLE
24812: LD_INT 1
24814: DEC
24815: ST_TO_ADDR
24816: LD_EXP 122
24820: PUSH
24821: FOR_TO
24822: IFFALSE 24880
// if not mc_sides [ i ] in tmp then
24824: LD_EXP 122
24828: PUSH
24829: LD_VAR 0 2
24833: ARRAY
24834: PUSH
24835: LD_VAR 0 5
24839: IN
24840: NOT
24841: IFFALSE 24878
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24843: LD_ADDR_VAR 0 5
24847: PUSH
24848: LD_VAR 0 5
24852: PPUSH
24853: LD_VAR 0 5
24857: PUSH
24858: LD_INT 1
24860: PLUS
24861: PPUSH
24862: LD_EXP 122
24866: PUSH
24867: LD_VAR 0 2
24871: ARRAY
24872: PPUSH
24873: CALL_OW 2
24877: ST_TO_ADDR
24878: GO 24821
24880: POP
24881: POP
// if not tmp then
24882: LD_VAR 0 5
24886: NOT
24887: IFFALSE 24891
// exit ;
24889: GO 24996
// for j in tmp do
24891: LD_ADDR_VAR 0 3
24895: PUSH
24896: LD_VAR 0 5
24900: PUSH
24901: FOR_IN
24902: IFFALSE 24994
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24904: LD_ADDR_VAR 0 6
24908: PUSH
24909: LD_INT 22
24911: PUSH
24912: LD_VAR 0 3
24916: PUSH
24917: EMPTY
24918: LIST
24919: LIST
24920: PPUSH
24921: CALL_OW 69
24925: ST_TO_ADDR
// if not un then
24926: LD_VAR 0 6
24930: NOT
24931: IFFALSE 24935
// continue ;
24933: GO 24901
// nation := GetNation ( un [ 1 ] ) ;
24935: LD_ADDR_VAR 0 4
24939: PUSH
24940: LD_VAR 0 6
24944: PUSH
24945: LD_INT 1
24947: ARRAY
24948: PPUSH
24949: CALL_OW 248
24953: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24954: LD_ADDR_EXP 123
24958: PUSH
24959: LD_EXP 123
24963: PPUSH
24964: LD_VAR 0 3
24968: PPUSH
24969: LD_VAR 0 3
24973: PPUSH
24974: LD_VAR 0 4
24978: PPUSH
24979: LD_INT 1
24981: PPUSH
24982: CALL 52117 0 3
24986: PPUSH
24987: CALL_OW 1
24991: ST_TO_ADDR
// end ;
24992: GO 24901
24994: POP
24995: POP
// end ;
24996: LD_VAR 0 1
25000: RET
// export function MC_InitSides ( ) ; var i ; begin
25001: LD_INT 0
25003: PPUSH
25004: PPUSH
// if not mc_bases then
25005: LD_EXP 96
25009: NOT
25010: IFFALSE 25014
// exit ;
25012: GO 25088
// for i = 1 to mc_bases do
25014: LD_ADDR_VAR 0 2
25018: PUSH
25019: DOUBLE
25020: LD_INT 1
25022: DEC
25023: ST_TO_ADDR
25024: LD_EXP 96
25028: PUSH
25029: FOR_TO
25030: IFFALSE 25086
// if mc_bases [ i ] then
25032: LD_EXP 96
25036: PUSH
25037: LD_VAR 0 2
25041: ARRAY
25042: IFFALSE 25084
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25044: LD_ADDR_EXP 122
25048: PUSH
25049: LD_EXP 122
25053: PPUSH
25054: LD_VAR 0 2
25058: PPUSH
25059: LD_EXP 96
25063: PUSH
25064: LD_VAR 0 2
25068: ARRAY
25069: PUSH
25070: LD_INT 1
25072: ARRAY
25073: PPUSH
25074: CALL_OW 255
25078: PPUSH
25079: CALL_OW 1
25083: ST_TO_ADDR
25084: GO 25029
25086: POP
25087: POP
// end ;
25088: LD_VAR 0 1
25092: RET
// every 0 0$03 trigger skirmish do
25093: LD_EXP 94
25097: IFFALSE 25251
25099: GO 25101
25101: DISABLE
// begin enable ;
25102: ENABLE
// MC_CheckBuildings ( ) ;
25103: CALL 29749 0 0
// MC_CheckPeopleLife ( ) ;
25107: CALL 29910 0 0
// RaiseSailEvent ( 100 ) ;
25111: LD_INT 100
25113: PPUSH
25114: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25118: LD_INT 103
25120: PPUSH
25121: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25125: LD_INT 104
25127: PPUSH
25128: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25132: LD_INT 105
25134: PPUSH
25135: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25139: LD_INT 106
25141: PPUSH
25142: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25146: LD_INT 107
25148: PPUSH
25149: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25153: LD_INT 108
25155: PPUSH
25156: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25160: LD_INT 109
25162: PPUSH
25163: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25167: LD_INT 110
25169: PPUSH
25170: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25174: LD_INT 111
25176: PPUSH
25177: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25181: LD_INT 112
25183: PPUSH
25184: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25188: LD_INT 113
25190: PPUSH
25191: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25195: LD_INT 120
25197: PPUSH
25198: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25202: LD_INT 121
25204: PPUSH
25205: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25209: LD_INT 122
25211: PPUSH
25212: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25216: LD_INT 123
25218: PPUSH
25219: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25223: LD_INT 124
25225: PPUSH
25226: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25230: LD_INT 125
25232: PPUSH
25233: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25237: LD_INT 126
25239: PPUSH
25240: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25244: LD_INT 200
25246: PPUSH
25247: CALL_OW 427
// end ;
25251: END
// on SailEvent ( event ) do begin if event < 100 then
25252: LD_VAR 0 1
25256: PUSH
25257: LD_INT 100
25259: LESS
25260: IFFALSE 25271
// CustomEvent ( event ) ;
25262: LD_VAR 0 1
25266: PPUSH
25267: CALL 10914 0 1
// if event = 100 then
25271: LD_VAR 0 1
25275: PUSH
25276: LD_INT 100
25278: EQUAL
25279: IFFALSE 25285
// MC_ClassManager ( ) ;
25281: CALL 25677 0 0
// if event = 101 then
25285: LD_VAR 0 1
25289: PUSH
25290: LD_INT 101
25292: EQUAL
25293: IFFALSE 25299
// MC_RepairBuildings ( ) ;
25295: CALL 30495 0 0
// if event = 102 then
25299: LD_VAR 0 1
25303: PUSH
25304: LD_INT 102
25306: EQUAL
25307: IFFALSE 25313
// MC_Heal ( ) ;
25309: CALL 31402 0 0
// if event = 103 then
25313: LD_VAR 0 1
25317: PUSH
25318: LD_INT 103
25320: EQUAL
25321: IFFALSE 25327
// MC_Build ( ) ;
25323: CALL 31824 0 0
// if event = 104 then
25327: LD_VAR 0 1
25331: PUSH
25332: LD_INT 104
25334: EQUAL
25335: IFFALSE 25341
// MC_TurretWeapon ( ) ;
25337: CALL 33465 0 0
// if event = 105 then
25341: LD_VAR 0 1
25345: PUSH
25346: LD_INT 105
25348: EQUAL
25349: IFFALSE 25355
// MC_BuildUpgrade ( ) ;
25351: CALL 33016 0 0
// if event = 106 then
25355: LD_VAR 0 1
25359: PUSH
25360: LD_INT 106
25362: EQUAL
25363: IFFALSE 25369
// MC_PlantMines ( ) ;
25365: CALL 33895 0 0
// if event = 107 then
25369: LD_VAR 0 1
25373: PUSH
25374: LD_INT 107
25376: EQUAL
25377: IFFALSE 25383
// MC_CollectCrates ( ) ;
25379: CALL 34686 0 0
// if event = 108 then
25383: LD_VAR 0 1
25387: PUSH
25388: LD_INT 108
25390: EQUAL
25391: IFFALSE 25397
// MC_LinkRemoteControl ( ) ;
25393: CALL 36536 0 0
// if event = 109 then
25397: LD_VAR 0 1
25401: PUSH
25402: LD_INT 109
25404: EQUAL
25405: IFFALSE 25411
// MC_ProduceVehicle ( ) ;
25407: CALL 36717 0 0
// if event = 110 then
25411: LD_VAR 0 1
25415: PUSH
25416: LD_INT 110
25418: EQUAL
25419: IFFALSE 25425
// MC_SendAttack ( ) ;
25421: CALL 37183 0 0
// if event = 111 then
25425: LD_VAR 0 1
25429: PUSH
25430: LD_INT 111
25432: EQUAL
25433: IFFALSE 25439
// MC_Defend ( ) ;
25435: CALL 37291 0 0
// if event = 112 then
25439: LD_VAR 0 1
25443: PUSH
25444: LD_INT 112
25446: EQUAL
25447: IFFALSE 25453
// MC_Research ( ) ;
25449: CALL 38171 0 0
// if event = 113 then
25453: LD_VAR 0 1
25457: PUSH
25458: LD_INT 113
25460: EQUAL
25461: IFFALSE 25467
// MC_MinesTrigger ( ) ;
25463: CALL 39285 0 0
// if event = 120 then
25467: LD_VAR 0 1
25471: PUSH
25472: LD_INT 120
25474: EQUAL
25475: IFFALSE 25481
// MC_RepairVehicle ( ) ;
25477: CALL 39384 0 0
// if event = 121 then
25481: LD_VAR 0 1
25485: PUSH
25486: LD_INT 121
25488: EQUAL
25489: IFFALSE 25495
// MC_TameApe ( ) ;
25491: CALL 40125 0 0
// if event = 122 then
25495: LD_VAR 0 1
25499: PUSH
25500: LD_INT 122
25502: EQUAL
25503: IFFALSE 25509
// MC_ChangeApeClass ( ) ;
25505: CALL 40954 0 0
// if event = 123 then
25509: LD_VAR 0 1
25513: PUSH
25514: LD_INT 123
25516: EQUAL
25517: IFFALSE 25523
// MC_Bazooka ( ) ;
25519: CALL 41604 0 0
// if event = 124 then
25523: LD_VAR 0 1
25527: PUSH
25528: LD_INT 124
25530: EQUAL
25531: IFFALSE 25537
// MC_TeleportExit ( ) ;
25533: CALL 41802 0 0
// if event = 125 then
25537: LD_VAR 0 1
25541: PUSH
25542: LD_INT 125
25544: EQUAL
25545: IFFALSE 25551
// MC_Deposits ( ) ;
25547: CALL 42449 0 0
// if event = 126 then
25551: LD_VAR 0 1
25555: PUSH
25556: LD_INT 126
25558: EQUAL
25559: IFFALSE 25565
// MC_RemoteDriver ( ) ;
25561: CALL 43074 0 0
// if event = 200 then
25565: LD_VAR 0 1
25569: PUSH
25570: LD_INT 200
25572: EQUAL
25573: IFFALSE 25579
// MC_Idle ( ) ;
25575: CALL 45023 0 0
// end ;
25579: PPOPN 1
25581: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25582: LD_INT 0
25584: PPUSH
25585: PPUSH
// if not mc_bases [ base ] or not tag then
25586: LD_EXP 96
25590: PUSH
25591: LD_VAR 0 1
25595: ARRAY
25596: NOT
25597: PUSH
25598: LD_VAR 0 2
25602: NOT
25603: OR
25604: IFFALSE 25608
// exit ;
25606: GO 25672
// for i in mc_bases [ base ] union mc_ape [ base ] do
25608: LD_ADDR_VAR 0 4
25612: PUSH
25613: LD_EXP 96
25617: PUSH
25618: LD_VAR 0 1
25622: ARRAY
25623: PUSH
25624: LD_EXP 125
25628: PUSH
25629: LD_VAR 0 1
25633: ARRAY
25634: UNION
25635: PUSH
25636: FOR_IN
25637: IFFALSE 25670
// if GetTag ( i ) = tag then
25639: LD_VAR 0 4
25643: PPUSH
25644: CALL_OW 110
25648: PUSH
25649: LD_VAR 0 2
25653: EQUAL
25654: IFFALSE 25668
// SetTag ( i , 0 ) ;
25656: LD_VAR 0 4
25660: PPUSH
25661: LD_INT 0
25663: PPUSH
25664: CALL_OW 109
25668: GO 25636
25670: POP
25671: POP
// end ;
25672: LD_VAR 0 3
25676: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25677: LD_INT 0
25679: PPUSH
25680: PPUSH
25681: PPUSH
25682: PPUSH
25683: PPUSH
25684: PPUSH
25685: PPUSH
25686: PPUSH
// if not mc_bases then
25687: LD_EXP 96
25691: NOT
25692: IFFALSE 25696
// exit ;
25694: GO 26154
// for i = 1 to mc_bases do
25696: LD_ADDR_VAR 0 2
25700: PUSH
25701: DOUBLE
25702: LD_INT 1
25704: DEC
25705: ST_TO_ADDR
25706: LD_EXP 96
25710: PUSH
25711: FOR_TO
25712: IFFALSE 26152
// begin tmp := MC_ClassCheckReq ( i ) ;
25714: LD_ADDR_VAR 0 4
25718: PUSH
25719: LD_VAR 0 2
25723: PPUSH
25724: CALL 26159 0 1
25728: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25729: LD_ADDR_EXP 137
25733: PUSH
25734: LD_EXP 137
25738: PPUSH
25739: LD_VAR 0 2
25743: PPUSH
25744: LD_VAR 0 4
25748: PPUSH
25749: CALL_OW 1
25753: ST_TO_ADDR
// if not tmp then
25754: LD_VAR 0 4
25758: NOT
25759: IFFALSE 25763
// continue ;
25761: GO 25711
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25763: LD_ADDR_VAR 0 6
25767: PUSH
25768: LD_EXP 96
25772: PUSH
25773: LD_VAR 0 2
25777: ARRAY
25778: PPUSH
25779: LD_INT 2
25781: PUSH
25782: LD_INT 30
25784: PUSH
25785: LD_INT 4
25787: PUSH
25788: EMPTY
25789: LIST
25790: LIST
25791: PUSH
25792: LD_INT 30
25794: PUSH
25795: LD_INT 5
25797: PUSH
25798: EMPTY
25799: LIST
25800: LIST
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: LIST
25806: PPUSH
25807: CALL_OW 72
25811: PUSH
25812: LD_EXP 96
25816: PUSH
25817: LD_VAR 0 2
25821: ARRAY
25822: PPUSH
25823: LD_INT 2
25825: PUSH
25826: LD_INT 30
25828: PUSH
25829: LD_INT 0
25831: PUSH
25832: EMPTY
25833: LIST
25834: LIST
25835: PUSH
25836: LD_INT 30
25838: PUSH
25839: LD_INT 1
25841: PUSH
25842: EMPTY
25843: LIST
25844: LIST
25845: PUSH
25846: EMPTY
25847: LIST
25848: LIST
25849: LIST
25850: PPUSH
25851: CALL_OW 72
25855: PUSH
25856: LD_EXP 96
25860: PUSH
25861: LD_VAR 0 2
25865: ARRAY
25866: PPUSH
25867: LD_INT 30
25869: PUSH
25870: LD_INT 3
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PPUSH
25877: CALL_OW 72
25881: PUSH
25882: LD_EXP 96
25886: PUSH
25887: LD_VAR 0 2
25891: ARRAY
25892: PPUSH
25893: LD_INT 2
25895: PUSH
25896: LD_INT 30
25898: PUSH
25899: LD_INT 6
25901: PUSH
25902: EMPTY
25903: LIST
25904: LIST
25905: PUSH
25906: LD_INT 30
25908: PUSH
25909: LD_INT 7
25911: PUSH
25912: EMPTY
25913: LIST
25914: LIST
25915: PUSH
25916: LD_INT 30
25918: PUSH
25919: LD_INT 8
25921: PUSH
25922: EMPTY
25923: LIST
25924: LIST
25925: PUSH
25926: EMPTY
25927: LIST
25928: LIST
25929: LIST
25930: LIST
25931: PPUSH
25932: CALL_OW 72
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: LIST
25941: LIST
25942: ST_TO_ADDR
// for j = 1 to 4 do
25943: LD_ADDR_VAR 0 3
25947: PUSH
25948: DOUBLE
25949: LD_INT 1
25951: DEC
25952: ST_TO_ADDR
25953: LD_INT 4
25955: PUSH
25956: FOR_TO
25957: IFFALSE 26148
// begin if not tmp [ j ] then
25959: LD_VAR 0 4
25963: PUSH
25964: LD_VAR 0 3
25968: ARRAY
25969: NOT
25970: IFFALSE 25974
// continue ;
25972: GO 25956
// for p in tmp [ j ] do
25974: LD_ADDR_VAR 0 5
25978: PUSH
25979: LD_VAR 0 4
25983: PUSH
25984: LD_VAR 0 3
25988: ARRAY
25989: PUSH
25990: FOR_IN
25991: IFFALSE 26144
// begin if not b [ j ] then
25993: LD_VAR 0 6
25997: PUSH
25998: LD_VAR 0 3
26002: ARRAY
26003: NOT
26004: IFFALSE 26008
// break ;
26006: GO 26144
// e := 0 ;
26008: LD_ADDR_VAR 0 7
26012: PUSH
26013: LD_INT 0
26015: ST_TO_ADDR
// for k in b [ j ] do
26016: LD_ADDR_VAR 0 8
26020: PUSH
26021: LD_VAR 0 6
26025: PUSH
26026: LD_VAR 0 3
26030: ARRAY
26031: PUSH
26032: FOR_IN
26033: IFFALSE 26060
// if IsNotFull ( k ) then
26035: LD_VAR 0 8
26039: PPUSH
26040: CALL 54270 0 1
26044: IFFALSE 26058
// begin e := k ;
26046: LD_ADDR_VAR 0 7
26050: PUSH
26051: LD_VAR 0 8
26055: ST_TO_ADDR
// break ;
26056: GO 26060
// end ;
26058: GO 26032
26060: POP
26061: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26062: LD_VAR 0 7
26066: PUSH
26067: LD_VAR 0 5
26071: PPUSH
26072: LD_VAR 0 7
26076: PPUSH
26077: CALL 87534 0 2
26081: NOT
26082: AND
26083: IFFALSE 26142
// begin if IsInUnit ( p ) then
26085: LD_VAR 0 5
26089: PPUSH
26090: CALL_OW 310
26094: IFFALSE 26105
// ComExitBuilding ( p ) ;
26096: LD_VAR 0 5
26100: PPUSH
26101: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26105: LD_VAR 0 5
26109: PPUSH
26110: LD_VAR 0 7
26114: PPUSH
26115: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26119: LD_VAR 0 5
26123: PPUSH
26124: LD_VAR 0 3
26128: PPUSH
26129: CALL_OW 183
// AddComExitBuilding ( p ) ;
26133: LD_VAR 0 5
26137: PPUSH
26138: CALL_OW 182
// end ; end ;
26142: GO 25990
26144: POP
26145: POP
// end ;
26146: GO 25956
26148: POP
26149: POP
// end ;
26150: GO 25711
26152: POP
26153: POP
// end ;
26154: LD_VAR 0 1
26158: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26159: LD_INT 0
26161: PPUSH
26162: PPUSH
26163: PPUSH
26164: PPUSH
26165: PPUSH
26166: PPUSH
26167: PPUSH
26168: PPUSH
26169: PPUSH
26170: PPUSH
26171: PPUSH
26172: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26173: LD_VAR 0 1
26177: NOT
26178: PUSH
26179: LD_EXP 96
26183: PUSH
26184: LD_VAR 0 1
26188: ARRAY
26189: NOT
26190: OR
26191: PUSH
26192: LD_EXP 96
26196: PUSH
26197: LD_VAR 0 1
26201: ARRAY
26202: PPUSH
26203: LD_INT 2
26205: PUSH
26206: LD_INT 30
26208: PUSH
26209: LD_INT 0
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 30
26218: PUSH
26219: LD_INT 1
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: PUSH
26226: EMPTY
26227: LIST
26228: LIST
26229: LIST
26230: PPUSH
26231: CALL_OW 72
26235: NOT
26236: OR
26237: IFFALSE 26241
// exit ;
26239: GO 29744
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26241: LD_ADDR_VAR 0 4
26245: PUSH
26246: LD_EXP 96
26250: PUSH
26251: LD_VAR 0 1
26255: ARRAY
26256: PPUSH
26257: LD_INT 2
26259: PUSH
26260: LD_INT 25
26262: PUSH
26263: LD_INT 1
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: PUSH
26270: LD_INT 25
26272: PUSH
26273: LD_INT 2
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: PUSH
26280: LD_INT 25
26282: PUSH
26283: LD_INT 3
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: PUSH
26290: LD_INT 25
26292: PUSH
26293: LD_INT 4
26295: PUSH
26296: EMPTY
26297: LIST
26298: LIST
26299: PUSH
26300: LD_INT 25
26302: PUSH
26303: LD_INT 5
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: PUSH
26310: LD_INT 25
26312: PUSH
26313: LD_INT 8
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 25
26322: PUSH
26323: LD_INT 9
26325: PUSH
26326: EMPTY
26327: LIST
26328: LIST
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: LIST
26334: LIST
26335: LIST
26336: LIST
26337: LIST
26338: LIST
26339: PPUSH
26340: CALL_OW 72
26344: ST_TO_ADDR
// if not tmp then
26345: LD_VAR 0 4
26349: NOT
26350: IFFALSE 26354
// exit ;
26352: GO 29744
// for i in tmp do
26354: LD_ADDR_VAR 0 3
26358: PUSH
26359: LD_VAR 0 4
26363: PUSH
26364: FOR_IN
26365: IFFALSE 26396
// if GetTag ( i ) then
26367: LD_VAR 0 3
26371: PPUSH
26372: CALL_OW 110
26376: IFFALSE 26394
// tmp := tmp diff i ;
26378: LD_ADDR_VAR 0 4
26382: PUSH
26383: LD_VAR 0 4
26387: PUSH
26388: LD_VAR 0 3
26392: DIFF
26393: ST_TO_ADDR
26394: GO 26364
26396: POP
26397: POP
// if not tmp then
26398: LD_VAR 0 4
26402: NOT
26403: IFFALSE 26407
// exit ;
26405: GO 29744
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26407: LD_ADDR_VAR 0 5
26411: PUSH
26412: LD_EXP 96
26416: PUSH
26417: LD_VAR 0 1
26421: ARRAY
26422: PPUSH
26423: LD_INT 2
26425: PUSH
26426: LD_INT 25
26428: PUSH
26429: LD_INT 1
26431: PUSH
26432: EMPTY
26433: LIST
26434: LIST
26435: PUSH
26436: LD_INT 25
26438: PUSH
26439: LD_INT 5
26441: PUSH
26442: EMPTY
26443: LIST
26444: LIST
26445: PUSH
26446: LD_INT 25
26448: PUSH
26449: LD_INT 8
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: PUSH
26456: LD_INT 25
26458: PUSH
26459: LD_INT 9
26461: PUSH
26462: EMPTY
26463: LIST
26464: LIST
26465: PUSH
26466: EMPTY
26467: LIST
26468: LIST
26469: LIST
26470: LIST
26471: LIST
26472: PPUSH
26473: CALL_OW 72
26477: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26478: LD_ADDR_VAR 0 6
26482: PUSH
26483: LD_EXP 96
26487: PUSH
26488: LD_VAR 0 1
26492: ARRAY
26493: PPUSH
26494: LD_INT 25
26496: PUSH
26497: LD_INT 2
26499: PUSH
26500: EMPTY
26501: LIST
26502: LIST
26503: PPUSH
26504: CALL_OW 72
26508: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26509: LD_ADDR_VAR 0 7
26513: PUSH
26514: LD_EXP 96
26518: PUSH
26519: LD_VAR 0 1
26523: ARRAY
26524: PPUSH
26525: LD_INT 25
26527: PUSH
26528: LD_INT 3
26530: PUSH
26531: EMPTY
26532: LIST
26533: LIST
26534: PPUSH
26535: CALL_OW 72
26539: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26540: LD_ADDR_VAR 0 8
26544: PUSH
26545: LD_EXP 96
26549: PUSH
26550: LD_VAR 0 1
26554: ARRAY
26555: PPUSH
26556: LD_INT 25
26558: PUSH
26559: LD_INT 4
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 24
26568: PUSH
26569: LD_INT 251
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PPUSH
26580: CALL_OW 72
26584: ST_TO_ADDR
// if mc_is_defending [ base ] then
26585: LD_EXP 139
26589: PUSH
26590: LD_VAR 0 1
26594: ARRAY
26595: IFFALSE 27056
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26597: LD_ADDR_EXP 138
26601: PUSH
26602: LD_EXP 138
26606: PPUSH
26607: LD_VAR 0 1
26611: PPUSH
26612: LD_INT 4
26614: PPUSH
26615: CALL_OW 1
26619: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26620: LD_ADDR_VAR 0 12
26624: PUSH
26625: LD_EXP 96
26629: PUSH
26630: LD_VAR 0 1
26634: ARRAY
26635: PPUSH
26636: LD_INT 2
26638: PUSH
26639: LD_INT 30
26641: PUSH
26642: LD_INT 4
26644: PUSH
26645: EMPTY
26646: LIST
26647: LIST
26648: PUSH
26649: LD_INT 30
26651: PUSH
26652: LD_INT 5
26654: PUSH
26655: EMPTY
26656: LIST
26657: LIST
26658: PUSH
26659: EMPTY
26660: LIST
26661: LIST
26662: LIST
26663: PPUSH
26664: CALL_OW 72
26668: ST_TO_ADDR
// if not b then
26669: LD_VAR 0 12
26673: NOT
26674: IFFALSE 26678
// exit ;
26676: GO 29744
// p := [ ] ;
26678: LD_ADDR_VAR 0 11
26682: PUSH
26683: EMPTY
26684: ST_TO_ADDR
// if sci >= 2 then
26685: LD_VAR 0 8
26689: PUSH
26690: LD_INT 2
26692: GREATEREQUAL
26693: IFFALSE 26724
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26695: LD_ADDR_VAR 0 8
26699: PUSH
26700: LD_VAR 0 8
26704: PUSH
26705: LD_INT 1
26707: ARRAY
26708: PUSH
26709: LD_VAR 0 8
26713: PUSH
26714: LD_INT 2
26716: ARRAY
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: ST_TO_ADDR
26722: GO 26785
// if sci = 1 then
26724: LD_VAR 0 8
26728: PUSH
26729: LD_INT 1
26731: EQUAL
26732: IFFALSE 26753
// sci := [ sci [ 1 ] ] else
26734: LD_ADDR_VAR 0 8
26738: PUSH
26739: LD_VAR 0 8
26743: PUSH
26744: LD_INT 1
26746: ARRAY
26747: PUSH
26748: EMPTY
26749: LIST
26750: ST_TO_ADDR
26751: GO 26785
// if sci = 0 then
26753: LD_VAR 0 8
26757: PUSH
26758: LD_INT 0
26760: EQUAL
26761: IFFALSE 26785
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26763: LD_ADDR_VAR 0 11
26767: PUSH
26768: LD_VAR 0 4
26772: PPUSH
26773: LD_INT 4
26775: PPUSH
26776: CALL 87397 0 2
26780: PUSH
26781: LD_INT 1
26783: ARRAY
26784: ST_TO_ADDR
// if eng > 4 then
26785: LD_VAR 0 6
26789: PUSH
26790: LD_INT 4
26792: GREATER
26793: IFFALSE 26839
// for i = eng downto 4 do
26795: LD_ADDR_VAR 0 3
26799: PUSH
26800: DOUBLE
26801: LD_VAR 0 6
26805: INC
26806: ST_TO_ADDR
26807: LD_INT 4
26809: PUSH
26810: FOR_DOWNTO
26811: IFFALSE 26837
// eng := eng diff eng [ i ] ;
26813: LD_ADDR_VAR 0 6
26817: PUSH
26818: LD_VAR 0 6
26822: PUSH
26823: LD_VAR 0 6
26827: PUSH
26828: LD_VAR 0 3
26832: ARRAY
26833: DIFF
26834: ST_TO_ADDR
26835: GO 26810
26837: POP
26838: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26839: LD_ADDR_VAR 0 4
26843: PUSH
26844: LD_VAR 0 4
26848: PUSH
26849: LD_VAR 0 5
26853: PUSH
26854: LD_VAR 0 6
26858: UNION
26859: PUSH
26860: LD_VAR 0 7
26864: UNION
26865: PUSH
26866: LD_VAR 0 8
26870: UNION
26871: DIFF
26872: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26873: LD_ADDR_VAR 0 13
26877: PUSH
26878: LD_EXP 96
26882: PUSH
26883: LD_VAR 0 1
26887: ARRAY
26888: PPUSH
26889: LD_INT 2
26891: PUSH
26892: LD_INT 30
26894: PUSH
26895: LD_INT 32
26897: PUSH
26898: EMPTY
26899: LIST
26900: LIST
26901: PUSH
26902: LD_INT 30
26904: PUSH
26905: LD_INT 31
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: LIST
26916: PPUSH
26917: CALL_OW 72
26921: PUSH
26922: LD_EXP 96
26926: PUSH
26927: LD_VAR 0 1
26931: ARRAY
26932: PPUSH
26933: LD_INT 2
26935: PUSH
26936: LD_INT 30
26938: PUSH
26939: LD_INT 4
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 30
26948: PUSH
26949: LD_INT 5
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: LIST
26960: PPUSH
26961: CALL_OW 72
26965: PUSH
26966: LD_INT 6
26968: MUL
26969: PLUS
26970: ST_TO_ADDR
// if bcount < tmp then
26971: LD_VAR 0 13
26975: PUSH
26976: LD_VAR 0 4
26980: LESS
26981: IFFALSE 27027
// for i = tmp downto bcount do
26983: LD_ADDR_VAR 0 3
26987: PUSH
26988: DOUBLE
26989: LD_VAR 0 4
26993: INC
26994: ST_TO_ADDR
26995: LD_VAR 0 13
26999: PUSH
27000: FOR_DOWNTO
27001: IFFALSE 27025
// tmp := Delete ( tmp , tmp ) ;
27003: LD_ADDR_VAR 0 4
27007: PUSH
27008: LD_VAR 0 4
27012: PPUSH
27013: LD_VAR 0 4
27017: PPUSH
27018: CALL_OW 3
27022: ST_TO_ADDR
27023: GO 27000
27025: POP
27026: POP
// result := [ tmp , 0 , 0 , p ] ;
27027: LD_ADDR_VAR 0 2
27031: PUSH
27032: LD_VAR 0 4
27036: PUSH
27037: LD_INT 0
27039: PUSH
27040: LD_INT 0
27042: PUSH
27043: LD_VAR 0 11
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: LIST
27052: LIST
27053: ST_TO_ADDR
// exit ;
27054: GO 29744
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27056: LD_EXP 96
27060: PUSH
27061: LD_VAR 0 1
27065: ARRAY
27066: PPUSH
27067: LD_INT 2
27069: PUSH
27070: LD_INT 30
27072: PUSH
27073: LD_INT 6
27075: PUSH
27076: EMPTY
27077: LIST
27078: LIST
27079: PUSH
27080: LD_INT 30
27082: PUSH
27083: LD_INT 7
27085: PUSH
27086: EMPTY
27087: LIST
27088: LIST
27089: PUSH
27090: LD_INT 30
27092: PUSH
27093: LD_INT 8
27095: PUSH
27096: EMPTY
27097: LIST
27098: LIST
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: LIST
27104: LIST
27105: PPUSH
27106: CALL_OW 72
27110: NOT
27111: PUSH
27112: LD_EXP 96
27116: PUSH
27117: LD_VAR 0 1
27121: ARRAY
27122: PPUSH
27123: LD_INT 30
27125: PUSH
27126: LD_INT 3
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: PPUSH
27133: CALL_OW 72
27137: NOT
27138: AND
27139: IFFALSE 27211
// begin if eng = tmp then
27141: LD_VAR 0 6
27145: PUSH
27146: LD_VAR 0 4
27150: EQUAL
27151: IFFALSE 27155
// exit ;
27153: GO 29744
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27155: LD_ADDR_EXP 138
27159: PUSH
27160: LD_EXP 138
27164: PPUSH
27165: LD_VAR 0 1
27169: PPUSH
27170: LD_INT 1
27172: PPUSH
27173: CALL_OW 1
27177: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27178: LD_ADDR_VAR 0 2
27182: PUSH
27183: LD_INT 0
27185: PUSH
27186: LD_VAR 0 4
27190: PUSH
27191: LD_VAR 0 6
27195: DIFF
27196: PUSH
27197: LD_INT 0
27199: PUSH
27200: LD_INT 0
27202: PUSH
27203: EMPTY
27204: LIST
27205: LIST
27206: LIST
27207: LIST
27208: ST_TO_ADDR
// exit ;
27209: GO 29744
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27211: LD_EXP 123
27215: PUSH
27216: LD_EXP 122
27220: PUSH
27221: LD_VAR 0 1
27225: ARRAY
27226: ARRAY
27227: PUSH
27228: LD_EXP 96
27232: PUSH
27233: LD_VAR 0 1
27237: ARRAY
27238: PPUSH
27239: LD_INT 2
27241: PUSH
27242: LD_INT 30
27244: PUSH
27245: LD_INT 6
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: LD_INT 30
27254: PUSH
27255: LD_INT 7
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: PUSH
27262: LD_INT 30
27264: PUSH
27265: LD_INT 8
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: LIST
27276: LIST
27277: PPUSH
27278: CALL_OW 72
27282: AND
27283: PUSH
27284: LD_EXP 96
27288: PUSH
27289: LD_VAR 0 1
27293: ARRAY
27294: PPUSH
27295: LD_INT 30
27297: PUSH
27298: LD_INT 3
27300: PUSH
27301: EMPTY
27302: LIST
27303: LIST
27304: PPUSH
27305: CALL_OW 72
27309: NOT
27310: AND
27311: IFFALSE 27525
// begin if sci >= 6 then
27313: LD_VAR 0 8
27317: PUSH
27318: LD_INT 6
27320: GREATEREQUAL
27321: IFFALSE 27325
// exit ;
27323: GO 29744
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27325: LD_ADDR_EXP 138
27329: PUSH
27330: LD_EXP 138
27334: PPUSH
27335: LD_VAR 0 1
27339: PPUSH
27340: LD_INT 2
27342: PPUSH
27343: CALL_OW 1
27347: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27348: LD_ADDR_VAR 0 9
27352: PUSH
27353: LD_VAR 0 4
27357: PUSH
27358: LD_VAR 0 8
27362: DIFF
27363: PPUSH
27364: LD_INT 4
27366: PPUSH
27367: CALL 87397 0 2
27371: ST_TO_ADDR
// p := [ ] ;
27372: LD_ADDR_VAR 0 11
27376: PUSH
27377: EMPTY
27378: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27379: LD_VAR 0 8
27383: PUSH
27384: LD_INT 6
27386: LESS
27387: PUSH
27388: LD_VAR 0 9
27392: PUSH
27393: LD_INT 6
27395: GREATER
27396: AND
27397: IFFALSE 27478
// begin for i = 1 to 6 - sci do
27399: LD_ADDR_VAR 0 3
27403: PUSH
27404: DOUBLE
27405: LD_INT 1
27407: DEC
27408: ST_TO_ADDR
27409: LD_INT 6
27411: PUSH
27412: LD_VAR 0 8
27416: MINUS
27417: PUSH
27418: FOR_TO
27419: IFFALSE 27474
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27421: LD_ADDR_VAR 0 11
27425: PUSH
27426: LD_VAR 0 11
27430: PPUSH
27431: LD_VAR 0 11
27435: PUSH
27436: LD_INT 1
27438: PLUS
27439: PPUSH
27440: LD_VAR 0 9
27444: PUSH
27445: LD_INT 1
27447: ARRAY
27448: PPUSH
27449: CALL_OW 2
27453: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27454: LD_ADDR_VAR 0 9
27458: PUSH
27459: LD_VAR 0 9
27463: PPUSH
27464: LD_INT 1
27466: PPUSH
27467: CALL_OW 3
27471: ST_TO_ADDR
// end ;
27472: GO 27418
27474: POP
27475: POP
// end else
27476: GO 27498
// if sort then
27478: LD_VAR 0 9
27482: IFFALSE 27498
// p := sort [ 1 ] ;
27484: LD_ADDR_VAR 0 11
27488: PUSH
27489: LD_VAR 0 9
27493: PUSH
27494: LD_INT 1
27496: ARRAY
27497: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27498: LD_ADDR_VAR 0 2
27502: PUSH
27503: LD_INT 0
27505: PUSH
27506: LD_INT 0
27508: PUSH
27509: LD_INT 0
27511: PUSH
27512: LD_VAR 0 11
27516: PUSH
27517: EMPTY
27518: LIST
27519: LIST
27520: LIST
27521: LIST
27522: ST_TO_ADDR
// exit ;
27523: GO 29744
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27525: LD_EXP 123
27529: PUSH
27530: LD_EXP 122
27534: PUSH
27535: LD_VAR 0 1
27539: ARRAY
27540: ARRAY
27541: PUSH
27542: LD_EXP 96
27546: PUSH
27547: LD_VAR 0 1
27551: ARRAY
27552: PPUSH
27553: LD_INT 2
27555: PUSH
27556: LD_INT 30
27558: PUSH
27559: LD_INT 6
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: LD_INT 30
27568: PUSH
27569: LD_INT 7
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: PUSH
27576: LD_INT 30
27578: PUSH
27579: LD_INT 8
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: PUSH
27586: EMPTY
27587: LIST
27588: LIST
27589: LIST
27590: LIST
27591: PPUSH
27592: CALL_OW 72
27596: AND
27597: PUSH
27598: LD_EXP 96
27602: PUSH
27603: LD_VAR 0 1
27607: ARRAY
27608: PPUSH
27609: LD_INT 30
27611: PUSH
27612: LD_INT 3
27614: PUSH
27615: EMPTY
27616: LIST
27617: LIST
27618: PPUSH
27619: CALL_OW 72
27623: AND
27624: IFFALSE 28358
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27626: LD_ADDR_EXP 138
27630: PUSH
27631: LD_EXP 138
27635: PPUSH
27636: LD_VAR 0 1
27640: PPUSH
27641: LD_INT 3
27643: PPUSH
27644: CALL_OW 1
27648: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27649: LD_ADDR_VAR 0 2
27653: PUSH
27654: LD_INT 0
27656: PUSH
27657: LD_INT 0
27659: PUSH
27660: LD_INT 0
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: LIST
27670: LIST
27671: ST_TO_ADDR
// if not eng then
27672: LD_VAR 0 6
27676: NOT
27677: IFFALSE 27740
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27679: LD_ADDR_VAR 0 11
27683: PUSH
27684: LD_VAR 0 4
27688: PPUSH
27689: LD_INT 2
27691: PPUSH
27692: CALL 87397 0 2
27696: PUSH
27697: LD_INT 1
27699: ARRAY
27700: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27701: LD_ADDR_VAR 0 2
27705: PUSH
27706: LD_VAR 0 2
27710: PPUSH
27711: LD_INT 2
27713: PPUSH
27714: LD_VAR 0 11
27718: PPUSH
27719: CALL_OW 1
27723: ST_TO_ADDR
// tmp := tmp diff p ;
27724: LD_ADDR_VAR 0 4
27728: PUSH
27729: LD_VAR 0 4
27733: PUSH
27734: LD_VAR 0 11
27738: DIFF
27739: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27740: LD_VAR 0 4
27744: PUSH
27745: LD_VAR 0 8
27749: PUSH
27750: LD_INT 6
27752: LESS
27753: AND
27754: IFFALSE 27942
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27756: LD_ADDR_VAR 0 9
27760: PUSH
27761: LD_VAR 0 4
27765: PUSH
27766: LD_VAR 0 8
27770: PUSH
27771: LD_VAR 0 7
27775: UNION
27776: DIFF
27777: PPUSH
27778: LD_INT 4
27780: PPUSH
27781: CALL 87397 0 2
27785: ST_TO_ADDR
// p := [ ] ;
27786: LD_ADDR_VAR 0 11
27790: PUSH
27791: EMPTY
27792: ST_TO_ADDR
// if sort then
27793: LD_VAR 0 9
27797: IFFALSE 27913
// for i = 1 to 6 - sci do
27799: LD_ADDR_VAR 0 3
27803: PUSH
27804: DOUBLE
27805: LD_INT 1
27807: DEC
27808: ST_TO_ADDR
27809: LD_INT 6
27811: PUSH
27812: LD_VAR 0 8
27816: MINUS
27817: PUSH
27818: FOR_TO
27819: IFFALSE 27911
// begin if i = sort then
27821: LD_VAR 0 3
27825: PUSH
27826: LD_VAR 0 9
27830: EQUAL
27831: IFFALSE 27835
// break ;
27833: GO 27911
// if GetClass ( i ) = 4 then
27835: LD_VAR 0 3
27839: PPUSH
27840: CALL_OW 257
27844: PUSH
27845: LD_INT 4
27847: EQUAL
27848: IFFALSE 27852
// continue ;
27850: GO 27818
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27852: LD_ADDR_VAR 0 11
27856: PUSH
27857: LD_VAR 0 11
27861: PPUSH
27862: LD_VAR 0 11
27866: PUSH
27867: LD_INT 1
27869: PLUS
27870: PPUSH
27871: LD_VAR 0 9
27875: PUSH
27876: LD_VAR 0 3
27880: ARRAY
27881: PPUSH
27882: CALL_OW 2
27886: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27887: LD_ADDR_VAR 0 4
27891: PUSH
27892: LD_VAR 0 4
27896: PUSH
27897: LD_VAR 0 9
27901: PUSH
27902: LD_VAR 0 3
27906: ARRAY
27907: DIFF
27908: ST_TO_ADDR
// end ;
27909: GO 27818
27911: POP
27912: POP
// if p then
27913: LD_VAR 0 11
27917: IFFALSE 27942
// result := Replace ( result , 4 , p ) ;
27919: LD_ADDR_VAR 0 2
27923: PUSH
27924: LD_VAR 0 2
27928: PPUSH
27929: LD_INT 4
27931: PPUSH
27932: LD_VAR 0 11
27936: PPUSH
27937: CALL_OW 1
27941: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27942: LD_VAR 0 4
27946: PUSH
27947: LD_VAR 0 7
27951: PUSH
27952: LD_INT 6
27954: LESS
27955: AND
27956: IFFALSE 28144
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27958: LD_ADDR_VAR 0 9
27962: PUSH
27963: LD_VAR 0 4
27967: PUSH
27968: LD_VAR 0 8
27972: PUSH
27973: LD_VAR 0 7
27977: UNION
27978: DIFF
27979: PPUSH
27980: LD_INT 3
27982: PPUSH
27983: CALL 87397 0 2
27987: ST_TO_ADDR
// p := [ ] ;
27988: LD_ADDR_VAR 0 11
27992: PUSH
27993: EMPTY
27994: ST_TO_ADDR
// if sort then
27995: LD_VAR 0 9
27999: IFFALSE 28115
// for i = 1 to 6 - mech do
28001: LD_ADDR_VAR 0 3
28005: PUSH
28006: DOUBLE
28007: LD_INT 1
28009: DEC
28010: ST_TO_ADDR
28011: LD_INT 6
28013: PUSH
28014: LD_VAR 0 7
28018: MINUS
28019: PUSH
28020: FOR_TO
28021: IFFALSE 28113
// begin if i = sort then
28023: LD_VAR 0 3
28027: PUSH
28028: LD_VAR 0 9
28032: EQUAL
28033: IFFALSE 28037
// break ;
28035: GO 28113
// if GetClass ( i ) = 3 then
28037: LD_VAR 0 3
28041: PPUSH
28042: CALL_OW 257
28046: PUSH
28047: LD_INT 3
28049: EQUAL
28050: IFFALSE 28054
// continue ;
28052: GO 28020
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28054: LD_ADDR_VAR 0 11
28058: PUSH
28059: LD_VAR 0 11
28063: PPUSH
28064: LD_VAR 0 11
28068: PUSH
28069: LD_INT 1
28071: PLUS
28072: PPUSH
28073: LD_VAR 0 9
28077: PUSH
28078: LD_VAR 0 3
28082: ARRAY
28083: PPUSH
28084: CALL_OW 2
28088: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28089: LD_ADDR_VAR 0 4
28093: PUSH
28094: LD_VAR 0 4
28098: PUSH
28099: LD_VAR 0 9
28103: PUSH
28104: LD_VAR 0 3
28108: ARRAY
28109: DIFF
28110: ST_TO_ADDR
// end ;
28111: GO 28020
28113: POP
28114: POP
// if p then
28115: LD_VAR 0 11
28119: IFFALSE 28144
// result := Replace ( result , 3 , p ) ;
28121: LD_ADDR_VAR 0 2
28125: PUSH
28126: LD_VAR 0 2
28130: PPUSH
28131: LD_INT 3
28133: PPUSH
28134: LD_VAR 0 11
28138: PPUSH
28139: CALL_OW 1
28143: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28144: LD_VAR 0 4
28148: PUSH
28149: LD_INT 6
28151: GREATER
28152: PUSH
28153: LD_VAR 0 6
28157: PUSH
28158: LD_INT 6
28160: LESS
28161: AND
28162: IFFALSE 28356
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28164: LD_ADDR_VAR 0 9
28168: PUSH
28169: LD_VAR 0 4
28173: PUSH
28174: LD_VAR 0 8
28178: PUSH
28179: LD_VAR 0 7
28183: UNION
28184: PUSH
28185: LD_VAR 0 6
28189: UNION
28190: DIFF
28191: PPUSH
28192: LD_INT 2
28194: PPUSH
28195: CALL 87397 0 2
28199: ST_TO_ADDR
// p := [ ] ;
28200: LD_ADDR_VAR 0 11
28204: PUSH
28205: EMPTY
28206: ST_TO_ADDR
// if sort then
28207: LD_VAR 0 9
28211: IFFALSE 28327
// for i = 1 to 6 - eng do
28213: LD_ADDR_VAR 0 3
28217: PUSH
28218: DOUBLE
28219: LD_INT 1
28221: DEC
28222: ST_TO_ADDR
28223: LD_INT 6
28225: PUSH
28226: LD_VAR 0 6
28230: MINUS
28231: PUSH
28232: FOR_TO
28233: IFFALSE 28325
// begin if i = sort then
28235: LD_VAR 0 3
28239: PUSH
28240: LD_VAR 0 9
28244: EQUAL
28245: IFFALSE 28249
// break ;
28247: GO 28325
// if GetClass ( i ) = 2 then
28249: LD_VAR 0 3
28253: PPUSH
28254: CALL_OW 257
28258: PUSH
28259: LD_INT 2
28261: EQUAL
28262: IFFALSE 28266
// continue ;
28264: GO 28232
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28266: LD_ADDR_VAR 0 11
28270: PUSH
28271: LD_VAR 0 11
28275: PPUSH
28276: LD_VAR 0 11
28280: PUSH
28281: LD_INT 1
28283: PLUS
28284: PPUSH
28285: LD_VAR 0 9
28289: PUSH
28290: LD_VAR 0 3
28294: ARRAY
28295: PPUSH
28296: CALL_OW 2
28300: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28301: LD_ADDR_VAR 0 4
28305: PUSH
28306: LD_VAR 0 4
28310: PUSH
28311: LD_VAR 0 9
28315: PUSH
28316: LD_VAR 0 3
28320: ARRAY
28321: DIFF
28322: ST_TO_ADDR
// end ;
28323: GO 28232
28325: POP
28326: POP
// if p then
28327: LD_VAR 0 11
28331: IFFALSE 28356
// result := Replace ( result , 2 , p ) ;
28333: LD_ADDR_VAR 0 2
28337: PUSH
28338: LD_VAR 0 2
28342: PPUSH
28343: LD_INT 2
28345: PPUSH
28346: LD_VAR 0 11
28350: PPUSH
28351: CALL_OW 1
28355: ST_TO_ADDR
// end ; exit ;
28356: GO 29744
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28358: LD_EXP 123
28362: PUSH
28363: LD_EXP 122
28367: PUSH
28368: LD_VAR 0 1
28372: ARRAY
28373: ARRAY
28374: NOT
28375: PUSH
28376: LD_EXP 96
28380: PUSH
28381: LD_VAR 0 1
28385: ARRAY
28386: PPUSH
28387: LD_INT 30
28389: PUSH
28390: LD_INT 3
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: PPUSH
28397: CALL_OW 72
28401: AND
28402: PUSH
28403: LD_EXP 101
28407: PUSH
28408: LD_VAR 0 1
28412: ARRAY
28413: AND
28414: IFFALSE 29022
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28416: LD_ADDR_EXP 138
28420: PUSH
28421: LD_EXP 138
28425: PPUSH
28426: LD_VAR 0 1
28430: PPUSH
28431: LD_INT 5
28433: PPUSH
28434: CALL_OW 1
28438: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28439: LD_ADDR_VAR 0 2
28443: PUSH
28444: LD_INT 0
28446: PUSH
28447: LD_INT 0
28449: PUSH
28450: LD_INT 0
28452: PUSH
28453: LD_INT 0
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: LIST
28460: LIST
28461: ST_TO_ADDR
// if sci > 1 then
28462: LD_VAR 0 8
28466: PUSH
28467: LD_INT 1
28469: GREATER
28470: IFFALSE 28498
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28472: LD_ADDR_VAR 0 4
28476: PUSH
28477: LD_VAR 0 4
28481: PUSH
28482: LD_VAR 0 8
28486: PUSH
28487: LD_VAR 0 8
28491: PUSH
28492: LD_INT 1
28494: ARRAY
28495: DIFF
28496: DIFF
28497: ST_TO_ADDR
// if tmp and not sci then
28498: LD_VAR 0 4
28502: PUSH
28503: LD_VAR 0 8
28507: NOT
28508: AND
28509: IFFALSE 28578
// begin sort := SortBySkill ( tmp , 4 ) ;
28511: LD_ADDR_VAR 0 9
28515: PUSH
28516: LD_VAR 0 4
28520: PPUSH
28521: LD_INT 4
28523: PPUSH
28524: CALL 87397 0 2
28528: ST_TO_ADDR
// if sort then
28529: LD_VAR 0 9
28533: IFFALSE 28549
// p := sort [ 1 ] ;
28535: LD_ADDR_VAR 0 11
28539: PUSH
28540: LD_VAR 0 9
28544: PUSH
28545: LD_INT 1
28547: ARRAY
28548: ST_TO_ADDR
// if p then
28549: LD_VAR 0 11
28553: IFFALSE 28578
// result := Replace ( result , 4 , p ) ;
28555: LD_ADDR_VAR 0 2
28559: PUSH
28560: LD_VAR 0 2
28564: PPUSH
28565: LD_INT 4
28567: PPUSH
28568: LD_VAR 0 11
28572: PPUSH
28573: CALL_OW 1
28577: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28578: LD_ADDR_VAR 0 4
28582: PUSH
28583: LD_VAR 0 4
28587: PUSH
28588: LD_VAR 0 7
28592: DIFF
28593: ST_TO_ADDR
// if tmp and mech < 6 then
28594: LD_VAR 0 4
28598: PUSH
28599: LD_VAR 0 7
28603: PUSH
28604: LD_INT 6
28606: LESS
28607: AND
28608: IFFALSE 28796
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28610: LD_ADDR_VAR 0 9
28614: PUSH
28615: LD_VAR 0 4
28619: PUSH
28620: LD_VAR 0 8
28624: PUSH
28625: LD_VAR 0 7
28629: UNION
28630: DIFF
28631: PPUSH
28632: LD_INT 3
28634: PPUSH
28635: CALL 87397 0 2
28639: ST_TO_ADDR
// p := [ ] ;
28640: LD_ADDR_VAR 0 11
28644: PUSH
28645: EMPTY
28646: ST_TO_ADDR
// if sort then
28647: LD_VAR 0 9
28651: IFFALSE 28767
// for i = 1 to 6 - mech do
28653: LD_ADDR_VAR 0 3
28657: PUSH
28658: DOUBLE
28659: LD_INT 1
28661: DEC
28662: ST_TO_ADDR
28663: LD_INT 6
28665: PUSH
28666: LD_VAR 0 7
28670: MINUS
28671: PUSH
28672: FOR_TO
28673: IFFALSE 28765
// begin if i = sort then
28675: LD_VAR 0 3
28679: PUSH
28680: LD_VAR 0 9
28684: EQUAL
28685: IFFALSE 28689
// break ;
28687: GO 28765
// if GetClass ( i ) = 3 then
28689: LD_VAR 0 3
28693: PPUSH
28694: CALL_OW 257
28698: PUSH
28699: LD_INT 3
28701: EQUAL
28702: IFFALSE 28706
// continue ;
28704: GO 28672
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28706: LD_ADDR_VAR 0 11
28710: PUSH
28711: LD_VAR 0 11
28715: PPUSH
28716: LD_VAR 0 11
28720: PUSH
28721: LD_INT 1
28723: PLUS
28724: PPUSH
28725: LD_VAR 0 9
28729: PUSH
28730: LD_VAR 0 3
28734: ARRAY
28735: PPUSH
28736: CALL_OW 2
28740: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28741: LD_ADDR_VAR 0 4
28745: PUSH
28746: LD_VAR 0 4
28750: PUSH
28751: LD_VAR 0 9
28755: PUSH
28756: LD_VAR 0 3
28760: ARRAY
28761: DIFF
28762: ST_TO_ADDR
// end ;
28763: GO 28672
28765: POP
28766: POP
// if p then
28767: LD_VAR 0 11
28771: IFFALSE 28796
// result := Replace ( result , 3 , p ) ;
28773: LD_ADDR_VAR 0 2
28777: PUSH
28778: LD_VAR 0 2
28782: PPUSH
28783: LD_INT 3
28785: PPUSH
28786: LD_VAR 0 11
28790: PPUSH
28791: CALL_OW 1
28795: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28796: LD_ADDR_VAR 0 4
28800: PUSH
28801: LD_VAR 0 4
28805: PUSH
28806: LD_VAR 0 6
28810: DIFF
28811: ST_TO_ADDR
// if tmp and eng < 6 then
28812: LD_VAR 0 4
28816: PUSH
28817: LD_VAR 0 6
28821: PUSH
28822: LD_INT 6
28824: LESS
28825: AND
28826: IFFALSE 29020
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28828: LD_ADDR_VAR 0 9
28832: PUSH
28833: LD_VAR 0 4
28837: PUSH
28838: LD_VAR 0 8
28842: PUSH
28843: LD_VAR 0 7
28847: UNION
28848: PUSH
28849: LD_VAR 0 6
28853: UNION
28854: DIFF
28855: PPUSH
28856: LD_INT 2
28858: PPUSH
28859: CALL 87397 0 2
28863: ST_TO_ADDR
// p := [ ] ;
28864: LD_ADDR_VAR 0 11
28868: PUSH
28869: EMPTY
28870: ST_TO_ADDR
// if sort then
28871: LD_VAR 0 9
28875: IFFALSE 28991
// for i = 1 to 6 - eng do
28877: LD_ADDR_VAR 0 3
28881: PUSH
28882: DOUBLE
28883: LD_INT 1
28885: DEC
28886: ST_TO_ADDR
28887: LD_INT 6
28889: PUSH
28890: LD_VAR 0 6
28894: MINUS
28895: PUSH
28896: FOR_TO
28897: IFFALSE 28989
// begin if i = sort then
28899: LD_VAR 0 3
28903: PUSH
28904: LD_VAR 0 9
28908: EQUAL
28909: IFFALSE 28913
// break ;
28911: GO 28989
// if GetClass ( i ) = 2 then
28913: LD_VAR 0 3
28917: PPUSH
28918: CALL_OW 257
28922: PUSH
28923: LD_INT 2
28925: EQUAL
28926: IFFALSE 28930
// continue ;
28928: GO 28896
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28930: LD_ADDR_VAR 0 11
28934: PUSH
28935: LD_VAR 0 11
28939: PPUSH
28940: LD_VAR 0 11
28944: PUSH
28945: LD_INT 1
28947: PLUS
28948: PPUSH
28949: LD_VAR 0 9
28953: PUSH
28954: LD_VAR 0 3
28958: ARRAY
28959: PPUSH
28960: CALL_OW 2
28964: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28965: LD_ADDR_VAR 0 4
28969: PUSH
28970: LD_VAR 0 4
28974: PUSH
28975: LD_VAR 0 9
28979: PUSH
28980: LD_VAR 0 3
28984: ARRAY
28985: DIFF
28986: ST_TO_ADDR
// end ;
28987: GO 28896
28989: POP
28990: POP
// if p then
28991: LD_VAR 0 11
28995: IFFALSE 29020
// result := Replace ( result , 2 , p ) ;
28997: LD_ADDR_VAR 0 2
29001: PUSH
29002: LD_VAR 0 2
29006: PPUSH
29007: LD_INT 2
29009: PPUSH
29010: LD_VAR 0 11
29014: PPUSH
29015: CALL_OW 1
29019: ST_TO_ADDR
// end ; exit ;
29020: GO 29744
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
29022: LD_EXP 123
29026: PUSH
29027: LD_EXP 122
29031: PUSH
29032: LD_VAR 0 1
29036: ARRAY
29037: ARRAY
29038: NOT
29039: PUSH
29040: LD_EXP 96
29044: PUSH
29045: LD_VAR 0 1
29049: ARRAY
29050: PPUSH
29051: LD_INT 30
29053: PUSH
29054: LD_INT 3
29056: PUSH
29057: EMPTY
29058: LIST
29059: LIST
29060: PPUSH
29061: CALL_OW 72
29065: AND
29066: PUSH
29067: LD_EXP 101
29071: PUSH
29072: LD_VAR 0 1
29076: ARRAY
29077: NOT
29078: AND
29079: IFFALSE 29744
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29081: LD_ADDR_EXP 138
29085: PUSH
29086: LD_EXP 138
29090: PPUSH
29091: LD_VAR 0 1
29095: PPUSH
29096: LD_INT 6
29098: PPUSH
29099: CALL_OW 1
29103: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29104: LD_ADDR_VAR 0 2
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: LD_INT 0
29114: PUSH
29115: LD_INT 0
29117: PUSH
29118: LD_INT 0
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: LIST
29125: LIST
29126: ST_TO_ADDR
// if sci >= 1 then
29127: LD_VAR 0 8
29131: PUSH
29132: LD_INT 1
29134: GREATEREQUAL
29135: IFFALSE 29157
// tmp := tmp diff sci [ 1 ] ;
29137: LD_ADDR_VAR 0 4
29141: PUSH
29142: LD_VAR 0 4
29146: PUSH
29147: LD_VAR 0 8
29151: PUSH
29152: LD_INT 1
29154: ARRAY
29155: DIFF
29156: ST_TO_ADDR
// if tmp and not sci then
29157: LD_VAR 0 4
29161: PUSH
29162: LD_VAR 0 8
29166: NOT
29167: AND
29168: IFFALSE 29237
// begin sort := SortBySkill ( tmp , 4 ) ;
29170: LD_ADDR_VAR 0 9
29174: PUSH
29175: LD_VAR 0 4
29179: PPUSH
29180: LD_INT 4
29182: PPUSH
29183: CALL 87397 0 2
29187: ST_TO_ADDR
// if sort then
29188: LD_VAR 0 9
29192: IFFALSE 29208
// p := sort [ 1 ] ;
29194: LD_ADDR_VAR 0 11
29198: PUSH
29199: LD_VAR 0 9
29203: PUSH
29204: LD_INT 1
29206: ARRAY
29207: ST_TO_ADDR
// if p then
29208: LD_VAR 0 11
29212: IFFALSE 29237
// result := Replace ( result , 4 , p ) ;
29214: LD_ADDR_VAR 0 2
29218: PUSH
29219: LD_VAR 0 2
29223: PPUSH
29224: LD_INT 4
29226: PPUSH
29227: LD_VAR 0 11
29231: PPUSH
29232: CALL_OW 1
29236: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29237: LD_ADDR_VAR 0 4
29241: PUSH
29242: LD_VAR 0 4
29246: PUSH
29247: LD_VAR 0 7
29251: DIFF
29252: ST_TO_ADDR
// if tmp and mech < 6 then
29253: LD_VAR 0 4
29257: PUSH
29258: LD_VAR 0 7
29262: PUSH
29263: LD_INT 6
29265: LESS
29266: AND
29267: IFFALSE 29449
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29269: LD_ADDR_VAR 0 9
29273: PUSH
29274: LD_VAR 0 4
29278: PUSH
29279: LD_VAR 0 7
29283: DIFF
29284: PPUSH
29285: LD_INT 3
29287: PPUSH
29288: CALL 87397 0 2
29292: ST_TO_ADDR
// p := [ ] ;
29293: LD_ADDR_VAR 0 11
29297: PUSH
29298: EMPTY
29299: ST_TO_ADDR
// if sort then
29300: LD_VAR 0 9
29304: IFFALSE 29420
// for i = 1 to 6 - mech do
29306: LD_ADDR_VAR 0 3
29310: PUSH
29311: DOUBLE
29312: LD_INT 1
29314: DEC
29315: ST_TO_ADDR
29316: LD_INT 6
29318: PUSH
29319: LD_VAR 0 7
29323: MINUS
29324: PUSH
29325: FOR_TO
29326: IFFALSE 29418
// begin if i = sort then
29328: LD_VAR 0 3
29332: PUSH
29333: LD_VAR 0 9
29337: EQUAL
29338: IFFALSE 29342
// break ;
29340: GO 29418
// if GetClass ( i ) = 3 then
29342: LD_VAR 0 3
29346: PPUSH
29347: CALL_OW 257
29351: PUSH
29352: LD_INT 3
29354: EQUAL
29355: IFFALSE 29359
// continue ;
29357: GO 29325
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29359: LD_ADDR_VAR 0 11
29363: PUSH
29364: LD_VAR 0 11
29368: PPUSH
29369: LD_VAR 0 11
29373: PUSH
29374: LD_INT 1
29376: PLUS
29377: PPUSH
29378: LD_VAR 0 9
29382: PUSH
29383: LD_VAR 0 3
29387: ARRAY
29388: PPUSH
29389: CALL_OW 2
29393: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29394: LD_ADDR_VAR 0 4
29398: PUSH
29399: LD_VAR 0 4
29403: PUSH
29404: LD_VAR 0 9
29408: PUSH
29409: LD_VAR 0 3
29413: ARRAY
29414: DIFF
29415: ST_TO_ADDR
// end ;
29416: GO 29325
29418: POP
29419: POP
// if p then
29420: LD_VAR 0 11
29424: IFFALSE 29449
// result := Replace ( result , 3 , p ) ;
29426: LD_ADDR_VAR 0 2
29430: PUSH
29431: LD_VAR 0 2
29435: PPUSH
29436: LD_INT 3
29438: PPUSH
29439: LD_VAR 0 11
29443: PPUSH
29444: CALL_OW 1
29448: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29449: LD_ADDR_VAR 0 4
29453: PUSH
29454: LD_VAR 0 4
29458: PUSH
29459: LD_VAR 0 6
29463: DIFF
29464: ST_TO_ADDR
// if tmp and eng < 4 then
29465: LD_VAR 0 4
29469: PUSH
29470: LD_VAR 0 6
29474: PUSH
29475: LD_INT 4
29477: LESS
29478: AND
29479: IFFALSE 29669
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29481: LD_ADDR_VAR 0 9
29485: PUSH
29486: LD_VAR 0 4
29490: PUSH
29491: LD_VAR 0 7
29495: PUSH
29496: LD_VAR 0 6
29500: UNION
29501: DIFF
29502: PPUSH
29503: LD_INT 2
29505: PPUSH
29506: CALL 87397 0 2
29510: ST_TO_ADDR
// p := [ ] ;
29511: LD_ADDR_VAR 0 11
29515: PUSH
29516: EMPTY
29517: ST_TO_ADDR
// if sort then
29518: LD_VAR 0 9
29522: IFFALSE 29638
// for i = 1 to 4 - eng do
29524: LD_ADDR_VAR 0 3
29528: PUSH
29529: DOUBLE
29530: LD_INT 1
29532: DEC
29533: ST_TO_ADDR
29534: LD_INT 4
29536: PUSH
29537: LD_VAR 0 6
29541: MINUS
29542: PUSH
29543: FOR_TO
29544: IFFALSE 29636
// begin if i = sort then
29546: LD_VAR 0 3
29550: PUSH
29551: LD_VAR 0 9
29555: EQUAL
29556: IFFALSE 29560
// break ;
29558: GO 29636
// if GetClass ( i ) = 2 then
29560: LD_VAR 0 3
29564: PPUSH
29565: CALL_OW 257
29569: PUSH
29570: LD_INT 2
29572: EQUAL
29573: IFFALSE 29577
// continue ;
29575: GO 29543
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29577: LD_ADDR_VAR 0 11
29581: PUSH
29582: LD_VAR 0 11
29586: PPUSH
29587: LD_VAR 0 11
29591: PUSH
29592: LD_INT 1
29594: PLUS
29595: PPUSH
29596: LD_VAR 0 9
29600: PUSH
29601: LD_VAR 0 3
29605: ARRAY
29606: PPUSH
29607: CALL_OW 2
29611: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29612: LD_ADDR_VAR 0 4
29616: PUSH
29617: LD_VAR 0 4
29621: PUSH
29622: LD_VAR 0 9
29626: PUSH
29627: LD_VAR 0 3
29631: ARRAY
29632: DIFF
29633: ST_TO_ADDR
// end ;
29634: GO 29543
29636: POP
29637: POP
// if p then
29638: LD_VAR 0 11
29642: IFFALSE 29667
// result := Replace ( result , 2 , p ) ;
29644: LD_ADDR_VAR 0 2
29648: PUSH
29649: LD_VAR 0 2
29653: PPUSH
29654: LD_INT 2
29656: PPUSH
29657: LD_VAR 0 11
29661: PPUSH
29662: CALL_OW 1
29666: ST_TO_ADDR
// end else
29667: GO 29713
// for i = eng downto 5 do
29669: LD_ADDR_VAR 0 3
29673: PUSH
29674: DOUBLE
29675: LD_VAR 0 6
29679: INC
29680: ST_TO_ADDR
29681: LD_INT 5
29683: PUSH
29684: FOR_DOWNTO
29685: IFFALSE 29711
// tmp := tmp union eng [ i ] ;
29687: LD_ADDR_VAR 0 4
29691: PUSH
29692: LD_VAR 0 4
29696: PUSH
29697: LD_VAR 0 6
29701: PUSH
29702: LD_VAR 0 3
29706: ARRAY
29707: UNION
29708: ST_TO_ADDR
29709: GO 29684
29711: POP
29712: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29713: LD_ADDR_VAR 0 2
29717: PUSH
29718: LD_VAR 0 2
29722: PPUSH
29723: LD_INT 1
29725: PPUSH
29726: LD_VAR 0 4
29730: PUSH
29731: LD_VAR 0 5
29735: DIFF
29736: PPUSH
29737: CALL_OW 1
29741: ST_TO_ADDR
// exit ;
29742: GO 29744
// end ; end ;
29744: LD_VAR 0 2
29748: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29749: LD_INT 0
29751: PPUSH
29752: PPUSH
29753: PPUSH
// if not mc_bases then
29754: LD_EXP 96
29758: NOT
29759: IFFALSE 29763
// exit ;
29761: GO 29905
// for i = 1 to mc_bases do
29763: LD_ADDR_VAR 0 2
29767: PUSH
29768: DOUBLE
29769: LD_INT 1
29771: DEC
29772: ST_TO_ADDR
29773: LD_EXP 96
29777: PUSH
29778: FOR_TO
29779: IFFALSE 29896
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29781: LD_ADDR_VAR 0 3
29785: PUSH
29786: LD_EXP 96
29790: PUSH
29791: LD_VAR 0 2
29795: ARRAY
29796: PPUSH
29797: LD_INT 21
29799: PUSH
29800: LD_INT 3
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 3
29809: PUSH
29810: LD_INT 2
29812: PUSH
29813: LD_INT 30
29815: PUSH
29816: LD_INT 29
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PUSH
29823: LD_INT 30
29825: PUSH
29826: LD_INT 30
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: LIST
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 3
29844: PUSH
29845: LD_INT 24
29847: PUSH
29848: LD_INT 1000
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: LIST
29863: PPUSH
29864: CALL_OW 72
29868: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29869: LD_ADDR_EXP 97
29873: PUSH
29874: LD_EXP 97
29878: PPUSH
29879: LD_VAR 0 2
29883: PPUSH
29884: LD_VAR 0 3
29888: PPUSH
29889: CALL_OW 1
29893: ST_TO_ADDR
// end ;
29894: GO 29778
29896: POP
29897: POP
// RaiseSailEvent ( 101 ) ;
29898: LD_INT 101
29900: PPUSH
29901: CALL_OW 427
// end ;
29905: LD_VAR 0 1
29909: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29910: LD_INT 0
29912: PPUSH
29913: PPUSH
29914: PPUSH
29915: PPUSH
29916: PPUSH
29917: PPUSH
29918: PPUSH
// if not mc_bases then
29919: LD_EXP 96
29923: NOT
29924: IFFALSE 29928
// exit ;
29926: GO 30490
// for i = 1 to mc_bases do
29928: LD_ADDR_VAR 0 2
29932: PUSH
29933: DOUBLE
29934: LD_INT 1
29936: DEC
29937: ST_TO_ADDR
29938: LD_EXP 96
29942: PUSH
29943: FOR_TO
29944: IFFALSE 30481
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29946: LD_ADDR_VAR 0 5
29950: PUSH
29951: LD_EXP 96
29955: PUSH
29956: LD_VAR 0 2
29960: ARRAY
29961: PUSH
29962: LD_EXP 125
29966: PUSH
29967: LD_VAR 0 2
29971: ARRAY
29972: UNION
29973: PPUSH
29974: LD_INT 21
29976: PUSH
29977: LD_INT 1
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: PUSH
29984: LD_INT 1
29986: PUSH
29987: LD_INT 3
29989: PUSH
29990: LD_INT 54
29992: PUSH
29993: EMPTY
29994: LIST
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 3
30002: PUSH
30003: LD_INT 24
30005: PUSH
30006: LD_INT 1000
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: EMPTY
30018: LIST
30019: LIST
30020: LIST
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PPUSH
30026: CALL_OW 72
30030: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30031: LD_ADDR_VAR 0 6
30035: PUSH
30036: LD_EXP 96
30040: PUSH
30041: LD_VAR 0 2
30045: ARRAY
30046: PPUSH
30047: LD_INT 21
30049: PUSH
30050: LD_INT 1
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PUSH
30057: LD_INT 1
30059: PUSH
30060: LD_INT 3
30062: PUSH
30063: LD_INT 54
30065: PUSH
30066: EMPTY
30067: LIST
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 3
30075: PUSH
30076: LD_INT 24
30078: PUSH
30079: LD_INT 250
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: LIST
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PPUSH
30099: CALL_OW 72
30103: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30104: LD_ADDR_VAR 0 7
30108: PUSH
30109: LD_VAR 0 5
30113: PUSH
30114: LD_VAR 0 6
30118: DIFF
30119: ST_TO_ADDR
// if not need_heal_1 then
30120: LD_VAR 0 6
30124: NOT
30125: IFFALSE 30158
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30127: LD_ADDR_EXP 99
30131: PUSH
30132: LD_EXP 99
30136: PPUSH
30137: LD_VAR 0 2
30141: PUSH
30142: LD_INT 1
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PPUSH
30149: EMPTY
30150: PPUSH
30151: CALL 57193 0 3
30155: ST_TO_ADDR
30156: GO 30228
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30158: LD_ADDR_EXP 99
30162: PUSH
30163: LD_EXP 99
30167: PPUSH
30168: LD_VAR 0 2
30172: PUSH
30173: LD_INT 1
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PPUSH
30180: LD_EXP 99
30184: PUSH
30185: LD_VAR 0 2
30189: ARRAY
30190: PUSH
30191: LD_INT 1
30193: ARRAY
30194: PPUSH
30195: LD_INT 3
30197: PUSH
30198: LD_INT 24
30200: PUSH
30201: LD_INT 1000
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PPUSH
30212: CALL_OW 72
30216: PUSH
30217: LD_VAR 0 6
30221: UNION
30222: PPUSH
30223: CALL 57193 0 3
30227: ST_TO_ADDR
// if not need_heal_2 then
30228: LD_VAR 0 7
30232: NOT
30233: IFFALSE 30266
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30235: LD_ADDR_EXP 99
30239: PUSH
30240: LD_EXP 99
30244: PPUSH
30245: LD_VAR 0 2
30249: PUSH
30250: LD_INT 2
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PPUSH
30257: EMPTY
30258: PPUSH
30259: CALL 57193 0 3
30263: ST_TO_ADDR
30264: GO 30298
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30266: LD_ADDR_EXP 99
30270: PUSH
30271: LD_EXP 99
30275: PPUSH
30276: LD_VAR 0 2
30280: PUSH
30281: LD_INT 2
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PPUSH
30288: LD_VAR 0 7
30292: PPUSH
30293: CALL 57193 0 3
30297: ST_TO_ADDR
// if need_heal_2 then
30298: LD_VAR 0 7
30302: IFFALSE 30463
// for j in need_heal_2 do
30304: LD_ADDR_VAR 0 3
30308: PUSH
30309: LD_VAR 0 7
30313: PUSH
30314: FOR_IN
30315: IFFALSE 30461
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30317: LD_ADDR_VAR 0 5
30321: PUSH
30322: LD_EXP 96
30326: PUSH
30327: LD_VAR 0 2
30331: ARRAY
30332: PPUSH
30333: LD_INT 2
30335: PUSH
30336: LD_INT 30
30338: PUSH
30339: LD_INT 6
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 30
30348: PUSH
30349: LD_INT 7
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 30
30358: PUSH
30359: LD_INT 8
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 30
30368: PUSH
30369: LD_INT 0
30371: PUSH
30372: EMPTY
30373: LIST
30374: LIST
30375: PUSH
30376: LD_INT 30
30378: PUSH
30379: LD_INT 1
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: PPUSH
30394: CALL_OW 72
30398: ST_TO_ADDR
// if tmp then
30399: LD_VAR 0 5
30403: IFFALSE 30459
// begin k := NearestUnitToUnit ( tmp , j ) ;
30405: LD_ADDR_VAR 0 4
30409: PUSH
30410: LD_VAR 0 5
30414: PPUSH
30415: LD_VAR 0 3
30419: PPUSH
30420: CALL_OW 74
30424: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30425: LD_VAR 0 3
30429: PPUSH
30430: LD_VAR 0 4
30434: PPUSH
30435: CALL_OW 296
30439: PUSH
30440: LD_INT 5
30442: GREATER
30443: IFFALSE 30459
// ComMoveToNearbyEntrance ( j , k ) ;
30445: LD_VAR 0 3
30449: PPUSH
30450: LD_VAR 0 4
30454: PPUSH
30455: CALL 89755 0 2
// end ; end ;
30459: GO 30314
30461: POP
30462: POP
// if not need_heal_1 and not need_heal_2 then
30463: LD_VAR 0 6
30467: NOT
30468: PUSH
30469: LD_VAR 0 7
30473: NOT
30474: AND
30475: IFFALSE 30479
// continue ;
30477: GO 29943
// end ;
30479: GO 29943
30481: POP
30482: POP
// RaiseSailEvent ( 102 ) ;
30483: LD_INT 102
30485: PPUSH
30486: CALL_OW 427
// end ;
30490: LD_VAR 0 1
30494: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30495: LD_INT 0
30497: PPUSH
30498: PPUSH
30499: PPUSH
30500: PPUSH
30501: PPUSH
30502: PPUSH
30503: PPUSH
30504: PPUSH
// if not mc_bases then
30505: LD_EXP 96
30509: NOT
30510: IFFALSE 30514
// exit ;
30512: GO 31397
// for i = 1 to mc_bases do
30514: LD_ADDR_VAR 0 2
30518: PUSH
30519: DOUBLE
30520: LD_INT 1
30522: DEC
30523: ST_TO_ADDR
30524: LD_EXP 96
30528: PUSH
30529: FOR_TO
30530: IFFALSE 31395
// begin if not mc_building_need_repair [ i ] then
30532: LD_EXP 97
30536: PUSH
30537: LD_VAR 0 2
30541: ARRAY
30542: NOT
30543: IFFALSE 30730
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30545: LD_ADDR_VAR 0 6
30549: PUSH
30550: LD_EXP 115
30554: PUSH
30555: LD_VAR 0 2
30559: ARRAY
30560: PPUSH
30561: LD_INT 3
30563: PUSH
30564: LD_INT 24
30566: PUSH
30567: LD_INT 1000
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 2
30580: PUSH
30581: LD_INT 34
30583: PUSH
30584: LD_INT 13
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 34
30593: PUSH
30594: LD_INT 52
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: PUSH
30601: LD_INT 34
30603: PUSH
30604: LD_EXP 80
30608: PUSH
30609: EMPTY
30610: LIST
30611: LIST
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: PUSH
30619: EMPTY
30620: LIST
30621: LIST
30622: PPUSH
30623: CALL_OW 72
30627: ST_TO_ADDR
// if cranes then
30628: LD_VAR 0 6
30632: IFFALSE 30694
// for j in cranes do
30634: LD_ADDR_VAR 0 3
30638: PUSH
30639: LD_VAR 0 6
30643: PUSH
30644: FOR_IN
30645: IFFALSE 30692
// if not IsInArea ( j , mc_parking [ i ] ) then
30647: LD_VAR 0 3
30651: PPUSH
30652: LD_EXP 120
30656: PUSH
30657: LD_VAR 0 2
30661: ARRAY
30662: PPUSH
30663: CALL_OW 308
30667: NOT
30668: IFFALSE 30690
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30670: LD_VAR 0 3
30674: PPUSH
30675: LD_EXP 120
30679: PUSH
30680: LD_VAR 0 2
30684: ARRAY
30685: PPUSH
30686: CALL_OW 113
30690: GO 30644
30692: POP
30693: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30694: LD_ADDR_EXP 98
30698: PUSH
30699: LD_EXP 98
30703: PPUSH
30704: LD_VAR 0 2
30708: PPUSH
30709: EMPTY
30710: PPUSH
30711: CALL_OW 1
30715: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30716: LD_VAR 0 2
30720: PPUSH
30721: LD_INT 101
30723: PPUSH
30724: CALL 25582 0 2
// continue ;
30728: GO 30529
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30730: LD_ADDR_EXP 102
30734: PUSH
30735: LD_EXP 102
30739: PPUSH
30740: LD_VAR 0 2
30744: PPUSH
30745: EMPTY
30746: PPUSH
30747: CALL_OW 1
30751: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30752: LD_VAR 0 2
30756: PPUSH
30757: LD_INT 103
30759: PPUSH
30760: CALL 25582 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30764: LD_ADDR_VAR 0 5
30768: PUSH
30769: LD_EXP 96
30773: PUSH
30774: LD_VAR 0 2
30778: ARRAY
30779: PUSH
30780: LD_EXP 125
30784: PUSH
30785: LD_VAR 0 2
30789: ARRAY
30790: UNION
30791: PPUSH
30792: LD_INT 2
30794: PUSH
30795: LD_INT 25
30797: PUSH
30798: LD_INT 2
30800: PUSH
30801: EMPTY
30802: LIST
30803: LIST
30804: PUSH
30805: LD_INT 25
30807: PUSH
30808: LD_INT 16
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: LIST
30819: PUSH
30820: EMPTY
30821: LIST
30822: PPUSH
30823: CALL_OW 72
30827: ST_TO_ADDR
// if mc_need_heal [ i ] then
30828: LD_EXP 99
30832: PUSH
30833: LD_VAR 0 2
30837: ARRAY
30838: IFFALSE 30882
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30840: LD_ADDR_VAR 0 5
30844: PUSH
30845: LD_VAR 0 5
30849: PUSH
30850: LD_EXP 99
30854: PUSH
30855: LD_VAR 0 2
30859: ARRAY
30860: PUSH
30861: LD_INT 1
30863: ARRAY
30864: PUSH
30865: LD_EXP 99
30869: PUSH
30870: LD_VAR 0 2
30874: ARRAY
30875: PUSH
30876: LD_INT 2
30878: ARRAY
30879: UNION
30880: DIFF
30881: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30882: LD_ADDR_VAR 0 6
30886: PUSH
30887: LD_EXP 115
30891: PUSH
30892: LD_VAR 0 2
30896: ARRAY
30897: PPUSH
30898: LD_INT 2
30900: PUSH
30901: LD_INT 34
30903: PUSH
30904: LD_INT 13
30906: PUSH
30907: EMPTY
30908: LIST
30909: LIST
30910: PUSH
30911: LD_INT 34
30913: PUSH
30914: LD_INT 52
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: PUSH
30921: LD_INT 34
30923: PUSH
30924: LD_EXP 80
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: PPUSH
30939: CALL_OW 72
30943: ST_TO_ADDR
// if cranes then
30944: LD_VAR 0 6
30948: IFFALSE 31084
// begin for j in cranes do
30950: LD_ADDR_VAR 0 3
30954: PUSH
30955: LD_VAR 0 6
30959: PUSH
30960: FOR_IN
30961: IFFALSE 31082
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30963: LD_VAR 0 3
30967: PPUSH
30968: CALL_OW 256
30972: PUSH
30973: LD_INT 1000
30975: EQUAL
30976: PUSH
30977: LD_VAR 0 3
30981: PPUSH
30982: CALL_OW 314
30986: NOT
30987: AND
30988: IFFALSE 31022
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30990: LD_VAR 0 3
30994: PPUSH
30995: LD_EXP 97
30999: PUSH
31000: LD_VAR 0 2
31004: ARRAY
31005: PPUSH
31006: LD_VAR 0 3
31010: PPUSH
31011: CALL_OW 74
31015: PPUSH
31016: CALL_OW 130
31020: GO 31080
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
31022: LD_VAR 0 3
31026: PPUSH
31027: CALL_OW 256
31031: PUSH
31032: LD_INT 500
31034: LESS
31035: PUSH
31036: LD_VAR 0 3
31040: PPUSH
31041: LD_EXP 120
31045: PUSH
31046: LD_VAR 0 2
31050: ARRAY
31051: PPUSH
31052: CALL_OW 308
31056: NOT
31057: AND
31058: IFFALSE 31080
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31060: LD_VAR 0 3
31064: PPUSH
31065: LD_EXP 120
31069: PUSH
31070: LD_VAR 0 2
31074: ARRAY
31075: PPUSH
31076: CALL_OW 113
// end ;
31080: GO 30960
31082: POP
31083: POP
// end ; if tmp > 3 then
31084: LD_VAR 0 5
31088: PUSH
31089: LD_INT 3
31091: GREATER
31092: IFFALSE 31112
// tmp := ShrinkArray ( tmp , 4 ) ;
31094: LD_ADDR_VAR 0 5
31098: PUSH
31099: LD_VAR 0 5
31103: PPUSH
31104: LD_INT 4
31106: PPUSH
31107: CALL 89203 0 2
31111: ST_TO_ADDR
// if not tmp then
31112: LD_VAR 0 5
31116: NOT
31117: IFFALSE 31121
// continue ;
31119: GO 30529
// for j in tmp do
31121: LD_ADDR_VAR 0 3
31125: PUSH
31126: LD_VAR 0 5
31130: PUSH
31131: FOR_IN
31132: IFFALSE 31391
// begin if IsInUnit ( j ) then
31134: LD_VAR 0 3
31138: PPUSH
31139: CALL_OW 310
31143: IFFALSE 31154
// ComExitBuilding ( j ) ;
31145: LD_VAR 0 3
31149: PPUSH
31150: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31154: LD_VAR 0 3
31158: PUSH
31159: LD_EXP 98
31163: PUSH
31164: LD_VAR 0 2
31168: ARRAY
31169: IN
31170: NOT
31171: IFFALSE 31229
// begin SetTag ( j , 101 ) ;
31173: LD_VAR 0 3
31177: PPUSH
31178: LD_INT 101
31180: PPUSH
31181: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31185: LD_ADDR_EXP 98
31189: PUSH
31190: LD_EXP 98
31194: PPUSH
31195: LD_VAR 0 2
31199: PUSH
31200: LD_EXP 98
31204: PUSH
31205: LD_VAR 0 2
31209: ARRAY
31210: PUSH
31211: LD_INT 1
31213: PLUS
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PPUSH
31219: LD_VAR 0 3
31223: PPUSH
31224: CALL 57193 0 3
31228: ST_TO_ADDR
// end ; wait ( 1 ) ;
31229: LD_INT 1
31231: PPUSH
31232: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31236: LD_ADDR_VAR 0 7
31240: PUSH
31241: LD_EXP 97
31245: PUSH
31246: LD_VAR 0 2
31250: ARRAY
31251: ST_TO_ADDR
// if mc_scan [ i ] then
31252: LD_EXP 119
31256: PUSH
31257: LD_VAR 0 2
31261: ARRAY
31262: IFFALSE 31324
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31264: LD_ADDR_VAR 0 7
31268: PUSH
31269: LD_EXP 97
31273: PUSH
31274: LD_VAR 0 2
31278: ARRAY
31279: PPUSH
31280: LD_INT 3
31282: PUSH
31283: LD_INT 30
31285: PUSH
31286: LD_INT 32
31288: PUSH
31289: EMPTY
31290: LIST
31291: LIST
31292: PUSH
31293: LD_INT 30
31295: PUSH
31296: LD_INT 33
31298: PUSH
31299: EMPTY
31300: LIST
31301: LIST
31302: PUSH
31303: LD_INT 30
31305: PUSH
31306: LD_INT 31
31308: PUSH
31309: EMPTY
31310: LIST
31311: LIST
31312: PUSH
31313: EMPTY
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: PPUSH
31319: CALL_OW 72
31323: ST_TO_ADDR
// if not to_repair_tmp then
31324: LD_VAR 0 7
31328: NOT
31329: IFFALSE 31333
// continue ;
31331: GO 31131
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31333: LD_ADDR_VAR 0 8
31337: PUSH
31338: LD_VAR 0 7
31342: PPUSH
31343: LD_VAR 0 3
31347: PPUSH
31348: CALL_OW 74
31352: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31353: LD_VAR 0 8
31357: PPUSH
31358: LD_INT 16
31360: PPUSH
31361: CALL 59792 0 2
31365: PUSH
31366: LD_INT 4
31368: ARRAY
31369: PUSH
31370: LD_INT 10
31372: LESS
31373: IFFALSE 31389
// ComRepairBuilding ( j , to_repair ) ;
31375: LD_VAR 0 3
31379: PPUSH
31380: LD_VAR 0 8
31384: PPUSH
31385: CALL_OW 130
// end ;
31389: GO 31131
31391: POP
31392: POP
// end ;
31393: GO 30529
31395: POP
31396: POP
// end ;
31397: LD_VAR 0 1
31401: RET
// export function MC_Heal ; var i , j , tmp ; begin
31402: LD_INT 0
31404: PPUSH
31405: PPUSH
31406: PPUSH
31407: PPUSH
// if not mc_bases then
31408: LD_EXP 96
31412: NOT
31413: IFFALSE 31417
// exit ;
31415: GO 31819
// for i = 1 to mc_bases do
31417: LD_ADDR_VAR 0 2
31421: PUSH
31422: DOUBLE
31423: LD_INT 1
31425: DEC
31426: ST_TO_ADDR
31427: LD_EXP 96
31431: PUSH
31432: FOR_TO
31433: IFFALSE 31817
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31435: LD_EXP 99
31439: PUSH
31440: LD_VAR 0 2
31444: ARRAY
31445: PUSH
31446: LD_INT 1
31448: ARRAY
31449: NOT
31450: PUSH
31451: LD_EXP 99
31455: PUSH
31456: LD_VAR 0 2
31460: ARRAY
31461: PUSH
31462: LD_INT 2
31464: ARRAY
31465: NOT
31466: AND
31467: IFFALSE 31505
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31469: LD_ADDR_EXP 100
31473: PUSH
31474: LD_EXP 100
31478: PPUSH
31479: LD_VAR 0 2
31483: PPUSH
31484: EMPTY
31485: PPUSH
31486: CALL_OW 1
31490: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31491: LD_VAR 0 2
31495: PPUSH
31496: LD_INT 102
31498: PPUSH
31499: CALL 25582 0 2
// continue ;
31503: GO 31432
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31505: LD_ADDR_VAR 0 4
31509: PUSH
31510: LD_EXP 96
31514: PUSH
31515: LD_VAR 0 2
31519: ARRAY
31520: PPUSH
31521: LD_INT 25
31523: PUSH
31524: LD_INT 4
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PPUSH
31531: CALL_OW 72
31535: ST_TO_ADDR
// if not tmp then
31536: LD_VAR 0 4
31540: NOT
31541: IFFALSE 31545
// continue ;
31543: GO 31432
// if mc_taming [ i ] then
31545: LD_EXP 127
31549: PUSH
31550: LD_VAR 0 2
31554: ARRAY
31555: IFFALSE 31579
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31557: LD_ADDR_EXP 127
31561: PUSH
31562: LD_EXP 127
31566: PPUSH
31567: LD_VAR 0 2
31571: PPUSH
31572: EMPTY
31573: PPUSH
31574: CALL_OW 1
31578: ST_TO_ADDR
// for j in tmp do
31579: LD_ADDR_VAR 0 3
31583: PUSH
31584: LD_VAR 0 4
31588: PUSH
31589: FOR_IN
31590: IFFALSE 31813
// begin if IsInUnit ( j ) then
31592: LD_VAR 0 3
31596: PPUSH
31597: CALL_OW 310
31601: IFFALSE 31612
// ComExitBuilding ( j ) ;
31603: LD_VAR 0 3
31607: PPUSH
31608: CALL_OW 122
// if not j in mc_healers [ i ] then
31612: LD_VAR 0 3
31616: PUSH
31617: LD_EXP 100
31621: PUSH
31622: LD_VAR 0 2
31626: ARRAY
31627: IN
31628: NOT
31629: IFFALSE 31675
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31631: LD_ADDR_EXP 100
31635: PUSH
31636: LD_EXP 100
31640: PPUSH
31641: LD_VAR 0 2
31645: PUSH
31646: LD_EXP 100
31650: PUSH
31651: LD_VAR 0 2
31655: ARRAY
31656: PUSH
31657: LD_INT 1
31659: PLUS
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PPUSH
31665: LD_VAR 0 3
31669: PPUSH
31670: CALL 57193 0 3
31674: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31675: LD_VAR 0 3
31679: PPUSH
31680: CALL_OW 110
31684: PUSH
31685: LD_INT 102
31687: NONEQUAL
31688: IFFALSE 31702
// SetTag ( j , 102 ) ;
31690: LD_VAR 0 3
31694: PPUSH
31695: LD_INT 102
31697: PPUSH
31698: CALL_OW 109
// Wait ( 3 ) ;
31702: LD_INT 3
31704: PPUSH
31705: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31709: LD_EXP 99
31713: PUSH
31714: LD_VAR 0 2
31718: ARRAY
31719: PUSH
31720: LD_INT 1
31722: ARRAY
31723: IFFALSE 31755
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31725: LD_VAR 0 3
31729: PPUSH
31730: LD_EXP 99
31734: PUSH
31735: LD_VAR 0 2
31739: ARRAY
31740: PUSH
31741: LD_INT 1
31743: ARRAY
31744: PUSH
31745: LD_INT 1
31747: ARRAY
31748: PPUSH
31749: CALL_OW 128
31753: GO 31811
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31755: LD_VAR 0 3
31759: PPUSH
31760: CALL_OW 314
31764: NOT
31765: PUSH
31766: LD_EXP 99
31770: PUSH
31771: LD_VAR 0 2
31775: ARRAY
31776: PUSH
31777: LD_INT 2
31779: ARRAY
31780: AND
31781: IFFALSE 31811
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31783: LD_VAR 0 3
31787: PPUSH
31788: LD_EXP 99
31792: PUSH
31793: LD_VAR 0 2
31797: ARRAY
31798: PUSH
31799: LD_INT 2
31801: ARRAY
31802: PUSH
31803: LD_INT 1
31805: ARRAY
31806: PPUSH
31807: CALL_OW 128
// end ;
31811: GO 31589
31813: POP
31814: POP
// end ;
31815: GO 31432
31817: POP
31818: POP
// end ;
31819: LD_VAR 0 1
31823: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31824: LD_INT 0
31826: PPUSH
31827: PPUSH
31828: PPUSH
31829: PPUSH
31830: PPUSH
// if not mc_bases then
31831: LD_EXP 96
31835: NOT
31836: IFFALSE 31840
// exit ;
31838: GO 33011
// for i = 1 to mc_bases do
31840: LD_ADDR_VAR 0 2
31844: PUSH
31845: DOUBLE
31846: LD_INT 1
31848: DEC
31849: ST_TO_ADDR
31850: LD_EXP 96
31854: PUSH
31855: FOR_TO
31856: IFFALSE 33009
// begin if mc_scan [ i ] then
31858: LD_EXP 119
31862: PUSH
31863: LD_VAR 0 2
31867: ARRAY
31868: IFFALSE 31872
// continue ;
31870: GO 31855
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31872: LD_EXP 101
31876: PUSH
31877: LD_VAR 0 2
31881: ARRAY
31882: NOT
31883: PUSH
31884: LD_EXP 103
31888: PUSH
31889: LD_VAR 0 2
31893: ARRAY
31894: NOT
31895: AND
31896: PUSH
31897: LD_EXP 102
31901: PUSH
31902: LD_VAR 0 2
31906: ARRAY
31907: AND
31908: IFFALSE 31946
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31910: LD_ADDR_EXP 102
31914: PUSH
31915: LD_EXP 102
31919: PPUSH
31920: LD_VAR 0 2
31924: PPUSH
31925: EMPTY
31926: PPUSH
31927: CALL_OW 1
31931: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31932: LD_VAR 0 2
31936: PPUSH
31937: LD_INT 103
31939: PPUSH
31940: CALL 25582 0 2
// continue ;
31944: GO 31855
// end ; if mc_construct_list [ i ] then
31946: LD_EXP 103
31950: PUSH
31951: LD_VAR 0 2
31955: ARRAY
31956: IFFALSE 32176
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31958: LD_ADDR_VAR 0 4
31962: PUSH
31963: LD_EXP 96
31967: PUSH
31968: LD_VAR 0 2
31972: ARRAY
31973: PPUSH
31974: LD_INT 25
31976: PUSH
31977: LD_INT 2
31979: PUSH
31980: EMPTY
31981: LIST
31982: LIST
31983: PPUSH
31984: CALL_OW 72
31988: PUSH
31989: LD_EXP 98
31993: PUSH
31994: LD_VAR 0 2
31998: ARRAY
31999: DIFF
32000: ST_TO_ADDR
// if not tmp then
32001: LD_VAR 0 4
32005: NOT
32006: IFFALSE 32010
// continue ;
32008: GO 31855
// for j in tmp do
32010: LD_ADDR_VAR 0 3
32014: PUSH
32015: LD_VAR 0 4
32019: PUSH
32020: FOR_IN
32021: IFFALSE 32172
// begin if not mc_builders [ i ] then
32023: LD_EXP 102
32027: PUSH
32028: LD_VAR 0 2
32032: ARRAY
32033: NOT
32034: IFFALSE 32092
// begin SetTag ( j , 103 ) ;
32036: LD_VAR 0 3
32040: PPUSH
32041: LD_INT 103
32043: PPUSH
32044: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32048: LD_ADDR_EXP 102
32052: PUSH
32053: LD_EXP 102
32057: PPUSH
32058: LD_VAR 0 2
32062: PUSH
32063: LD_EXP 102
32067: PUSH
32068: LD_VAR 0 2
32072: ARRAY
32073: PUSH
32074: LD_INT 1
32076: PLUS
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: PPUSH
32082: LD_VAR 0 3
32086: PPUSH
32087: CALL 57193 0 3
32091: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32092: LD_VAR 0 3
32096: PPUSH
32097: CALL_OW 310
32101: IFFALSE 32112
// ComExitBuilding ( j ) ;
32103: LD_VAR 0 3
32107: PPUSH
32108: CALL_OW 122
// wait ( 3 ) ;
32112: LD_INT 3
32114: PPUSH
32115: CALL_OW 67
// if not mc_construct_list [ i ] then
32119: LD_EXP 103
32123: PUSH
32124: LD_VAR 0 2
32128: ARRAY
32129: NOT
32130: IFFALSE 32134
// break ;
32132: GO 32172
// if not HasTask ( j ) then
32134: LD_VAR 0 3
32138: PPUSH
32139: CALL_OW 314
32143: NOT
32144: IFFALSE 32170
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32146: LD_VAR 0 3
32150: PPUSH
32151: LD_EXP 103
32155: PUSH
32156: LD_VAR 0 2
32160: ARRAY
32161: PUSH
32162: LD_INT 1
32164: ARRAY
32165: PPUSH
32166: CALL 60056 0 2
// end ;
32170: GO 32020
32172: POP
32173: POP
// end else
32174: GO 33007
// if mc_build_list [ i ] then
32176: LD_EXP 101
32180: PUSH
32181: LD_VAR 0 2
32185: ARRAY
32186: IFFALSE 33007
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32188: LD_ADDR_VAR 0 5
32192: PUSH
32193: LD_EXP 96
32197: PUSH
32198: LD_VAR 0 2
32202: ARRAY
32203: PPUSH
32204: LD_INT 2
32206: PUSH
32207: LD_INT 30
32209: PUSH
32210: LD_INT 0
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 30
32219: PUSH
32220: LD_INT 1
32222: PUSH
32223: EMPTY
32224: LIST
32225: LIST
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: LIST
32231: PPUSH
32232: CALL_OW 72
32236: ST_TO_ADDR
// if depot then
32237: LD_VAR 0 5
32241: IFFALSE 32259
// depot := depot [ 1 ] else
32243: LD_ADDR_VAR 0 5
32247: PUSH
32248: LD_VAR 0 5
32252: PUSH
32253: LD_INT 1
32255: ARRAY
32256: ST_TO_ADDR
32257: GO 32267
// depot := 0 ;
32259: LD_ADDR_VAR 0 5
32263: PUSH
32264: LD_INT 0
32266: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32267: LD_EXP 101
32271: PUSH
32272: LD_VAR 0 2
32276: ARRAY
32277: PUSH
32278: LD_INT 1
32280: ARRAY
32281: PUSH
32282: LD_INT 1
32284: ARRAY
32285: PPUSH
32286: CALL 59880 0 1
32290: PUSH
32291: LD_EXP 96
32295: PUSH
32296: LD_VAR 0 2
32300: ARRAY
32301: PPUSH
32302: LD_INT 2
32304: PUSH
32305: LD_INT 30
32307: PUSH
32308: LD_INT 2
32310: PUSH
32311: EMPTY
32312: LIST
32313: LIST
32314: PUSH
32315: LD_INT 30
32317: PUSH
32318: LD_INT 3
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: LIST
32329: PPUSH
32330: CALL_OW 72
32334: NOT
32335: AND
32336: IFFALSE 32441
// begin for j = 1 to mc_build_list [ i ] do
32338: LD_ADDR_VAR 0 3
32342: PUSH
32343: DOUBLE
32344: LD_INT 1
32346: DEC
32347: ST_TO_ADDR
32348: LD_EXP 101
32352: PUSH
32353: LD_VAR 0 2
32357: ARRAY
32358: PUSH
32359: FOR_TO
32360: IFFALSE 32439
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32362: LD_EXP 101
32366: PUSH
32367: LD_VAR 0 2
32371: ARRAY
32372: PUSH
32373: LD_VAR 0 3
32377: ARRAY
32378: PUSH
32379: LD_INT 1
32381: ARRAY
32382: PUSH
32383: LD_INT 2
32385: EQUAL
32386: IFFALSE 32437
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32388: LD_ADDR_EXP 101
32392: PUSH
32393: LD_EXP 101
32397: PPUSH
32398: LD_VAR 0 2
32402: PPUSH
32403: LD_EXP 101
32407: PUSH
32408: LD_VAR 0 2
32412: ARRAY
32413: PPUSH
32414: LD_VAR 0 3
32418: PPUSH
32419: LD_INT 1
32421: PPUSH
32422: LD_INT 0
32424: PPUSH
32425: CALL 56611 0 4
32429: PPUSH
32430: CALL_OW 1
32434: ST_TO_ADDR
// break ;
32435: GO 32439
// end ;
32437: GO 32359
32439: POP
32440: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
32441: LD_EXP 101
32445: PUSH
32446: LD_VAR 0 2
32450: ARRAY
32451: PUSH
32452: LD_INT 1
32454: ARRAY
32455: PUSH
32456: LD_INT 1
32458: ARRAY
32459: PUSH
32460: LD_INT 0
32462: EQUAL
32463: PUSH
32464: LD_VAR 0 5
32468: PUSH
32469: LD_VAR 0 5
32473: PPUSH
32474: LD_EXP 101
32478: PUSH
32479: LD_VAR 0 2
32483: ARRAY
32484: PUSH
32485: LD_INT 1
32487: ARRAY
32488: PUSH
32489: LD_INT 1
32491: ARRAY
32492: PPUSH
32493: LD_EXP 101
32497: PUSH
32498: LD_VAR 0 2
32502: ARRAY
32503: PUSH
32504: LD_INT 1
32506: ARRAY
32507: PUSH
32508: LD_INT 2
32510: ARRAY
32511: PPUSH
32512: LD_EXP 101
32516: PUSH
32517: LD_VAR 0 2
32521: ARRAY
32522: PUSH
32523: LD_INT 1
32525: ARRAY
32526: PUSH
32527: LD_INT 3
32529: ARRAY
32530: PPUSH
32531: LD_EXP 101
32535: PUSH
32536: LD_VAR 0 2
32540: ARRAY
32541: PUSH
32542: LD_INT 1
32544: ARRAY
32545: PUSH
32546: LD_INT 4
32548: ARRAY
32549: PPUSH
32550: CALL 65296 0 5
32554: AND
32555: OR
32556: IFFALSE 32837
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32558: LD_ADDR_VAR 0 4
32562: PUSH
32563: LD_EXP 96
32567: PUSH
32568: LD_VAR 0 2
32572: ARRAY
32573: PPUSH
32574: LD_INT 25
32576: PUSH
32577: LD_INT 2
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PPUSH
32584: CALL_OW 72
32588: PUSH
32589: LD_EXP 98
32593: PUSH
32594: LD_VAR 0 2
32598: ARRAY
32599: DIFF
32600: ST_TO_ADDR
// if not tmp then
32601: LD_VAR 0 4
32605: NOT
32606: IFFALSE 32610
// continue ;
32608: GO 31855
// for j in tmp do
32610: LD_ADDR_VAR 0 3
32614: PUSH
32615: LD_VAR 0 4
32619: PUSH
32620: FOR_IN
32621: IFFALSE 32833
// begin if not mc_builders [ i ] then
32623: LD_EXP 102
32627: PUSH
32628: LD_VAR 0 2
32632: ARRAY
32633: NOT
32634: IFFALSE 32692
// begin SetTag ( j , 103 ) ;
32636: LD_VAR 0 3
32640: PPUSH
32641: LD_INT 103
32643: PPUSH
32644: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32648: LD_ADDR_EXP 102
32652: PUSH
32653: LD_EXP 102
32657: PPUSH
32658: LD_VAR 0 2
32662: PUSH
32663: LD_EXP 102
32667: PUSH
32668: LD_VAR 0 2
32672: ARRAY
32673: PUSH
32674: LD_INT 1
32676: PLUS
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PPUSH
32682: LD_VAR 0 3
32686: PPUSH
32687: CALL 57193 0 3
32691: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32692: LD_VAR 0 3
32696: PPUSH
32697: CALL_OW 310
32701: IFFALSE 32712
// ComExitBuilding ( j ) ;
32703: LD_VAR 0 3
32707: PPUSH
32708: CALL_OW 122
// wait ( 3 ) ;
32712: LD_INT 3
32714: PPUSH
32715: CALL_OW 67
// if not mc_build_list [ i ] then
32719: LD_EXP 101
32723: PUSH
32724: LD_VAR 0 2
32728: ARRAY
32729: NOT
32730: IFFALSE 32734
// break ;
32732: GO 32833
// if not HasTask ( j ) then
32734: LD_VAR 0 3
32738: PPUSH
32739: CALL_OW 314
32743: NOT
32744: IFFALSE 32831
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32746: LD_VAR 0 3
32750: PPUSH
32751: LD_EXP 101
32755: PUSH
32756: LD_VAR 0 2
32760: ARRAY
32761: PUSH
32762: LD_INT 1
32764: ARRAY
32765: PUSH
32766: LD_INT 1
32768: ARRAY
32769: PPUSH
32770: LD_EXP 101
32774: PUSH
32775: LD_VAR 0 2
32779: ARRAY
32780: PUSH
32781: LD_INT 1
32783: ARRAY
32784: PUSH
32785: LD_INT 2
32787: ARRAY
32788: PPUSH
32789: LD_EXP 101
32793: PUSH
32794: LD_VAR 0 2
32798: ARRAY
32799: PUSH
32800: LD_INT 1
32802: ARRAY
32803: PUSH
32804: LD_INT 3
32806: ARRAY
32807: PPUSH
32808: LD_EXP 101
32812: PUSH
32813: LD_VAR 0 2
32817: ARRAY
32818: PUSH
32819: LD_INT 1
32821: ARRAY
32822: PUSH
32823: LD_INT 4
32825: ARRAY
32826: PPUSH
32827: CALL_OW 145
// end ;
32831: GO 32620
32833: POP
32834: POP
// end else
32835: GO 33007
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32837: LD_EXP 96
32841: PUSH
32842: LD_VAR 0 2
32846: ARRAY
32847: PPUSH
32848: LD_EXP 101
32852: PUSH
32853: LD_VAR 0 2
32857: ARRAY
32858: PUSH
32859: LD_INT 1
32861: ARRAY
32862: PUSH
32863: LD_INT 1
32865: ARRAY
32866: PPUSH
32867: LD_EXP 101
32871: PUSH
32872: LD_VAR 0 2
32876: ARRAY
32877: PUSH
32878: LD_INT 1
32880: ARRAY
32881: PUSH
32882: LD_INT 2
32884: ARRAY
32885: PPUSH
32886: LD_EXP 101
32890: PUSH
32891: LD_VAR 0 2
32895: ARRAY
32896: PUSH
32897: LD_INT 1
32899: ARRAY
32900: PUSH
32901: LD_INT 3
32903: ARRAY
32904: PPUSH
32905: LD_EXP 101
32909: PUSH
32910: LD_VAR 0 2
32914: ARRAY
32915: PUSH
32916: LD_INT 1
32918: ARRAY
32919: PUSH
32920: LD_INT 4
32922: ARRAY
32923: PPUSH
32924: LD_EXP 96
32928: PUSH
32929: LD_VAR 0 2
32933: ARRAY
32934: PPUSH
32935: LD_INT 21
32937: PUSH
32938: LD_INT 3
32940: PUSH
32941: EMPTY
32942: LIST
32943: LIST
32944: PPUSH
32945: CALL_OW 72
32949: PPUSH
32950: EMPTY
32951: PPUSH
32952: CALL 64046 0 7
32956: NOT
32957: IFFALSE 33007
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32959: LD_ADDR_EXP 101
32963: PUSH
32964: LD_EXP 101
32968: PPUSH
32969: LD_VAR 0 2
32973: PPUSH
32974: LD_EXP 101
32978: PUSH
32979: LD_VAR 0 2
32983: ARRAY
32984: PPUSH
32985: LD_INT 1
32987: PPUSH
32988: LD_INT 1
32990: NEG
32991: PPUSH
32992: LD_INT 0
32994: PPUSH
32995: CALL 56611 0 4
32999: PPUSH
33000: CALL_OW 1
33004: ST_TO_ADDR
// continue ;
33005: GO 31855
// end ; end ; end ;
33007: GO 31855
33009: POP
33010: POP
// end ;
33011: LD_VAR 0 1
33015: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
33016: LD_INT 0
33018: PPUSH
33019: PPUSH
33020: PPUSH
33021: PPUSH
33022: PPUSH
33023: PPUSH
// if not mc_bases then
33024: LD_EXP 96
33028: NOT
33029: IFFALSE 33033
// exit ;
33031: GO 33460
// for i = 1 to mc_bases do
33033: LD_ADDR_VAR 0 2
33037: PUSH
33038: DOUBLE
33039: LD_INT 1
33041: DEC
33042: ST_TO_ADDR
33043: LD_EXP 96
33047: PUSH
33048: FOR_TO
33049: IFFALSE 33458
// begin tmp := mc_build_upgrade [ i ] ;
33051: LD_ADDR_VAR 0 4
33055: PUSH
33056: LD_EXP 128
33060: PUSH
33061: LD_VAR 0 2
33065: ARRAY
33066: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33067: LD_ADDR_VAR 0 6
33071: PUSH
33072: LD_EXP 129
33076: PUSH
33077: LD_VAR 0 2
33081: ARRAY
33082: PPUSH
33083: LD_INT 2
33085: PUSH
33086: LD_INT 30
33088: PUSH
33089: LD_INT 6
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: PUSH
33096: LD_INT 30
33098: PUSH
33099: LD_INT 7
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: LIST
33110: PPUSH
33111: CALL_OW 72
33115: ST_TO_ADDR
// if not tmp and not lab then
33116: LD_VAR 0 4
33120: NOT
33121: PUSH
33122: LD_VAR 0 6
33126: NOT
33127: AND
33128: IFFALSE 33132
// continue ;
33130: GO 33048
// if tmp then
33132: LD_VAR 0 4
33136: IFFALSE 33256
// for j in tmp do
33138: LD_ADDR_VAR 0 3
33142: PUSH
33143: LD_VAR 0 4
33147: PUSH
33148: FOR_IN
33149: IFFALSE 33254
// begin if UpgradeCost ( j ) then
33151: LD_VAR 0 3
33155: PPUSH
33156: CALL 63706 0 1
33160: IFFALSE 33252
// begin ComUpgrade ( j ) ;
33162: LD_VAR 0 3
33166: PPUSH
33167: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33171: LD_ADDR_EXP 128
33175: PUSH
33176: LD_EXP 128
33180: PPUSH
33181: LD_VAR 0 2
33185: PPUSH
33186: LD_EXP 128
33190: PUSH
33191: LD_VAR 0 2
33195: ARRAY
33196: PUSH
33197: LD_VAR 0 3
33201: DIFF
33202: PPUSH
33203: CALL_OW 1
33207: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33208: LD_ADDR_EXP 103
33212: PUSH
33213: LD_EXP 103
33217: PPUSH
33218: LD_VAR 0 2
33222: PUSH
33223: LD_EXP 103
33227: PUSH
33228: LD_VAR 0 2
33232: ARRAY
33233: PUSH
33234: LD_INT 1
33236: PLUS
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: PPUSH
33242: LD_VAR 0 3
33246: PPUSH
33247: CALL 57193 0 3
33251: ST_TO_ADDR
// end ; end ;
33252: GO 33148
33254: POP
33255: POP
// if not lab or not mc_lab_upgrade [ i ] then
33256: LD_VAR 0 6
33260: NOT
33261: PUSH
33262: LD_EXP 130
33266: PUSH
33267: LD_VAR 0 2
33271: ARRAY
33272: NOT
33273: OR
33274: IFFALSE 33278
// continue ;
33276: GO 33048
// for j in lab do
33278: LD_ADDR_VAR 0 3
33282: PUSH
33283: LD_VAR 0 6
33287: PUSH
33288: FOR_IN
33289: IFFALSE 33454
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33291: LD_VAR 0 3
33295: PPUSH
33296: CALL_OW 266
33300: PUSH
33301: LD_INT 6
33303: PUSH
33304: LD_INT 7
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: IN
33311: PUSH
33312: LD_VAR 0 3
33316: PPUSH
33317: CALL_OW 461
33321: PUSH
33322: LD_INT 1
33324: NONEQUAL
33325: AND
33326: IFFALSE 33452
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33328: LD_VAR 0 3
33332: PPUSH
33333: LD_EXP 130
33337: PUSH
33338: LD_VAR 0 2
33342: ARRAY
33343: PUSH
33344: LD_INT 1
33346: ARRAY
33347: PPUSH
33348: CALL 63911 0 2
33352: IFFALSE 33452
// begin ComCancel ( j ) ;
33354: LD_VAR 0 3
33358: PPUSH
33359: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33363: LD_VAR 0 3
33367: PPUSH
33368: LD_EXP 130
33372: PUSH
33373: LD_VAR 0 2
33377: ARRAY
33378: PUSH
33379: LD_INT 1
33381: ARRAY
33382: PPUSH
33383: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33387: LD_VAR 0 3
33391: PUSH
33392: LD_EXP 103
33396: PUSH
33397: LD_VAR 0 2
33401: ARRAY
33402: IN
33403: NOT
33404: IFFALSE 33450
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33406: LD_ADDR_EXP 103
33410: PUSH
33411: LD_EXP 103
33415: PPUSH
33416: LD_VAR 0 2
33420: PUSH
33421: LD_EXP 103
33425: PUSH
33426: LD_VAR 0 2
33430: ARRAY
33431: PUSH
33432: LD_INT 1
33434: PLUS
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PPUSH
33440: LD_VAR 0 3
33444: PPUSH
33445: CALL 57193 0 3
33449: ST_TO_ADDR
// break ;
33450: GO 33454
// end ; end ; end ;
33452: GO 33288
33454: POP
33455: POP
// end ;
33456: GO 33048
33458: POP
33459: POP
// end ;
33460: LD_VAR 0 1
33464: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33465: LD_INT 0
33467: PPUSH
33468: PPUSH
33469: PPUSH
33470: PPUSH
33471: PPUSH
33472: PPUSH
33473: PPUSH
33474: PPUSH
33475: PPUSH
// if not mc_bases then
33476: LD_EXP 96
33480: NOT
33481: IFFALSE 33485
// exit ;
33483: GO 33890
// for i = 1 to mc_bases do
33485: LD_ADDR_VAR 0 2
33489: PUSH
33490: DOUBLE
33491: LD_INT 1
33493: DEC
33494: ST_TO_ADDR
33495: LD_EXP 96
33499: PUSH
33500: FOR_TO
33501: IFFALSE 33888
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33503: LD_EXP 104
33507: PUSH
33508: LD_VAR 0 2
33512: ARRAY
33513: NOT
33514: PUSH
33515: LD_EXP 96
33519: PUSH
33520: LD_VAR 0 2
33524: ARRAY
33525: PPUSH
33526: LD_INT 30
33528: PUSH
33529: LD_INT 3
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PPUSH
33536: CALL_OW 72
33540: NOT
33541: OR
33542: IFFALSE 33546
// continue ;
33544: GO 33500
// busy := false ;
33546: LD_ADDR_VAR 0 8
33550: PUSH
33551: LD_INT 0
33553: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33554: LD_ADDR_VAR 0 4
33558: PUSH
33559: LD_EXP 96
33563: PUSH
33564: LD_VAR 0 2
33568: ARRAY
33569: PPUSH
33570: LD_INT 30
33572: PUSH
33573: LD_INT 3
33575: PUSH
33576: EMPTY
33577: LIST
33578: LIST
33579: PPUSH
33580: CALL_OW 72
33584: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33585: LD_ADDR_VAR 0 6
33589: PUSH
33590: LD_EXP 104
33594: PUSH
33595: LD_VAR 0 2
33599: ARRAY
33600: PPUSH
33601: LD_INT 2
33603: PUSH
33604: LD_INT 30
33606: PUSH
33607: LD_INT 32
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: PUSH
33614: LD_INT 30
33616: PUSH
33617: LD_INT 33
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: LIST
33628: PPUSH
33629: CALL_OW 72
33633: ST_TO_ADDR
// if not t then
33634: LD_VAR 0 6
33638: NOT
33639: IFFALSE 33643
// continue ;
33641: GO 33500
// for j in tmp do
33643: LD_ADDR_VAR 0 3
33647: PUSH
33648: LD_VAR 0 4
33652: PUSH
33653: FOR_IN
33654: IFFALSE 33684
// if not BuildingStatus ( j ) = bs_idle then
33656: LD_VAR 0 3
33660: PPUSH
33661: CALL_OW 461
33665: PUSH
33666: LD_INT 2
33668: EQUAL
33669: NOT
33670: IFFALSE 33682
// begin busy := true ;
33672: LD_ADDR_VAR 0 8
33676: PUSH
33677: LD_INT 1
33679: ST_TO_ADDR
// break ;
33680: GO 33684
// end ;
33682: GO 33653
33684: POP
33685: POP
// if busy then
33686: LD_VAR 0 8
33690: IFFALSE 33694
// continue ;
33692: GO 33500
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33694: LD_ADDR_VAR 0 7
33698: PUSH
33699: LD_VAR 0 6
33703: PPUSH
33704: LD_INT 35
33706: PUSH
33707: LD_INT 0
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PPUSH
33714: CALL_OW 72
33718: ST_TO_ADDR
// if tw then
33719: LD_VAR 0 7
33723: IFFALSE 33800
// begin tw := tw [ 1 ] ;
33725: LD_ADDR_VAR 0 7
33729: PUSH
33730: LD_VAR 0 7
33734: PUSH
33735: LD_INT 1
33737: ARRAY
33738: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33739: LD_ADDR_VAR 0 9
33743: PUSH
33744: LD_VAR 0 7
33748: PPUSH
33749: LD_EXP 121
33753: PUSH
33754: LD_VAR 0 2
33758: ARRAY
33759: PPUSH
33760: CALL 62203 0 2
33764: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33765: LD_EXP 135
33769: PUSH
33770: LD_VAR 0 2
33774: ARRAY
33775: IFFALSE 33798
// if not weapon in mc_allowed_tower_weapons [ i ] then
33777: LD_VAR 0 9
33781: PUSH
33782: LD_EXP 135
33786: PUSH
33787: LD_VAR 0 2
33791: ARRAY
33792: IN
33793: NOT
33794: IFFALSE 33798
// continue ;
33796: GO 33500
// end else
33798: GO 33863
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33800: LD_ADDR_VAR 0 5
33804: PUSH
33805: LD_EXP 104
33809: PUSH
33810: LD_VAR 0 2
33814: ARRAY
33815: PPUSH
33816: LD_VAR 0 4
33820: PPUSH
33821: CALL 88436 0 2
33825: ST_TO_ADDR
// if not tmp2 then
33826: LD_VAR 0 5
33830: NOT
33831: IFFALSE 33835
// continue ;
33833: GO 33500
// tw := tmp2 [ 1 ] ;
33835: LD_ADDR_VAR 0 7
33839: PUSH
33840: LD_VAR 0 5
33844: PUSH
33845: LD_INT 1
33847: ARRAY
33848: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33849: LD_ADDR_VAR 0 9
33853: PUSH
33854: LD_VAR 0 5
33858: PUSH
33859: LD_INT 2
33861: ARRAY
33862: ST_TO_ADDR
// end ; if not weapon then
33863: LD_VAR 0 9
33867: NOT
33868: IFFALSE 33872
// continue ;
33870: GO 33500
// ComPlaceWeapon ( tw , weapon ) ;
33872: LD_VAR 0 7
33876: PPUSH
33877: LD_VAR 0 9
33881: PPUSH
33882: CALL_OW 148
// end ;
33886: GO 33500
33888: POP
33889: POP
// end ;
33890: LD_VAR 0 1
33894: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33895: LD_INT 0
33897: PPUSH
33898: PPUSH
33899: PPUSH
33900: PPUSH
33901: PPUSH
33902: PPUSH
33903: PPUSH
// if not mc_bases then
33904: LD_EXP 96
33908: NOT
33909: IFFALSE 33913
// exit ;
33911: GO 34681
// for i = 1 to mc_bases do
33913: LD_ADDR_VAR 0 2
33917: PUSH
33918: DOUBLE
33919: LD_INT 1
33921: DEC
33922: ST_TO_ADDR
33923: LD_EXP 96
33927: PUSH
33928: FOR_TO
33929: IFFALSE 34679
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33931: LD_EXP 109
33935: PUSH
33936: LD_VAR 0 2
33940: ARRAY
33941: NOT
33942: PUSH
33943: LD_EXP 109
33947: PUSH
33948: LD_VAR 0 2
33952: ARRAY
33953: PUSH
33954: LD_EXP 110
33958: PUSH
33959: LD_VAR 0 2
33963: ARRAY
33964: EQUAL
33965: OR
33966: PUSH
33967: LD_EXP 119
33971: PUSH
33972: LD_VAR 0 2
33976: ARRAY
33977: OR
33978: IFFALSE 33982
// continue ;
33980: GO 33928
// if mc_miners [ i ] then
33982: LD_EXP 110
33986: PUSH
33987: LD_VAR 0 2
33991: ARRAY
33992: IFFALSE 34366
// begin for j = mc_miners [ i ] downto 1 do
33994: LD_ADDR_VAR 0 3
33998: PUSH
33999: DOUBLE
34000: LD_EXP 110
34004: PUSH
34005: LD_VAR 0 2
34009: ARRAY
34010: INC
34011: ST_TO_ADDR
34012: LD_INT 1
34014: PUSH
34015: FOR_DOWNTO
34016: IFFALSE 34364
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
34018: LD_EXP 110
34022: PUSH
34023: LD_VAR 0 2
34027: ARRAY
34028: PUSH
34029: LD_VAR 0 3
34033: ARRAY
34034: PPUSH
34035: CALL_OW 301
34039: PUSH
34040: LD_EXP 110
34044: PUSH
34045: LD_VAR 0 2
34049: ARRAY
34050: PUSH
34051: LD_VAR 0 3
34055: ARRAY
34056: PPUSH
34057: CALL_OW 257
34061: PUSH
34062: LD_INT 1
34064: NONEQUAL
34065: OR
34066: IFFALSE 34129
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34068: LD_ADDR_VAR 0 5
34072: PUSH
34073: LD_EXP 110
34077: PUSH
34078: LD_VAR 0 2
34082: ARRAY
34083: PUSH
34084: LD_EXP 110
34088: PUSH
34089: LD_VAR 0 2
34093: ARRAY
34094: PUSH
34095: LD_VAR 0 3
34099: ARRAY
34100: DIFF
34101: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34102: LD_ADDR_EXP 110
34106: PUSH
34107: LD_EXP 110
34111: PPUSH
34112: LD_VAR 0 2
34116: PPUSH
34117: LD_VAR 0 5
34121: PPUSH
34122: CALL_OW 1
34126: ST_TO_ADDR
// continue ;
34127: GO 34015
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34129: LD_EXP 110
34133: PUSH
34134: LD_VAR 0 2
34138: ARRAY
34139: PUSH
34140: LD_VAR 0 3
34144: ARRAY
34145: PPUSH
34146: CALL_OW 257
34150: PUSH
34151: LD_INT 1
34153: EQUAL
34154: PUSH
34155: LD_EXP 110
34159: PUSH
34160: LD_VAR 0 2
34164: ARRAY
34165: PUSH
34166: LD_VAR 0 3
34170: ARRAY
34171: PPUSH
34172: CALL_OW 459
34176: NOT
34177: AND
34178: PUSH
34179: LD_EXP 110
34183: PUSH
34184: LD_VAR 0 2
34188: ARRAY
34189: PUSH
34190: LD_VAR 0 3
34194: ARRAY
34195: PPUSH
34196: CALL_OW 314
34200: NOT
34201: AND
34202: IFFALSE 34362
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34204: LD_EXP 110
34208: PUSH
34209: LD_VAR 0 2
34213: ARRAY
34214: PUSH
34215: LD_VAR 0 3
34219: ARRAY
34220: PPUSH
34221: CALL_OW 310
34225: IFFALSE 34248
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34227: LD_EXP 110
34231: PUSH
34232: LD_VAR 0 2
34236: ARRAY
34237: PUSH
34238: LD_VAR 0 3
34242: ARRAY
34243: PPUSH
34244: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34248: LD_EXP 110
34252: PUSH
34253: LD_VAR 0 2
34257: ARRAY
34258: PUSH
34259: LD_VAR 0 3
34263: ARRAY
34264: PPUSH
34265: CALL_OW 314
34269: NOT
34270: IFFALSE 34362
// begin r := rand ( 1 , mc_mines [ i ] ) ;
34272: LD_ADDR_VAR 0 7
34276: PUSH
34277: LD_INT 1
34279: PPUSH
34280: LD_EXP 109
34284: PUSH
34285: LD_VAR 0 2
34289: ARRAY
34290: PPUSH
34291: CALL_OW 12
34295: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34296: LD_EXP 110
34300: PUSH
34301: LD_VAR 0 2
34305: ARRAY
34306: PUSH
34307: LD_VAR 0 3
34311: ARRAY
34312: PPUSH
34313: LD_EXP 109
34317: PUSH
34318: LD_VAR 0 2
34322: ARRAY
34323: PUSH
34324: LD_VAR 0 7
34328: ARRAY
34329: PUSH
34330: LD_INT 1
34332: ARRAY
34333: PPUSH
34334: LD_EXP 109
34338: PUSH
34339: LD_VAR 0 2
34343: ARRAY
34344: PUSH
34345: LD_VAR 0 7
34349: ARRAY
34350: PUSH
34351: LD_INT 2
34353: ARRAY
34354: PPUSH
34355: LD_INT 0
34357: PPUSH
34358: CALL_OW 193
// end ; end ; end ;
34362: GO 34015
34364: POP
34365: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34366: LD_ADDR_VAR 0 5
34370: PUSH
34371: LD_EXP 96
34375: PUSH
34376: LD_VAR 0 2
34380: ARRAY
34381: PPUSH
34382: LD_INT 2
34384: PUSH
34385: LD_INT 30
34387: PUSH
34388: LD_INT 4
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 30
34397: PUSH
34398: LD_INT 5
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 30
34407: PUSH
34408: LD_INT 32
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: PPUSH
34421: CALL_OW 72
34425: ST_TO_ADDR
// if not tmp then
34426: LD_VAR 0 5
34430: NOT
34431: IFFALSE 34435
// continue ;
34433: GO 33928
// list := [ ] ;
34435: LD_ADDR_VAR 0 6
34439: PUSH
34440: EMPTY
34441: ST_TO_ADDR
// for j in tmp do
34442: LD_ADDR_VAR 0 3
34446: PUSH
34447: LD_VAR 0 5
34451: PUSH
34452: FOR_IN
34453: IFFALSE 34522
// begin for k in UnitsInside ( j ) do
34455: LD_ADDR_VAR 0 4
34459: PUSH
34460: LD_VAR 0 3
34464: PPUSH
34465: CALL_OW 313
34469: PUSH
34470: FOR_IN
34471: IFFALSE 34518
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34473: LD_VAR 0 4
34477: PPUSH
34478: CALL_OW 257
34482: PUSH
34483: LD_INT 1
34485: EQUAL
34486: PUSH
34487: LD_VAR 0 4
34491: PPUSH
34492: CALL_OW 459
34496: NOT
34497: AND
34498: IFFALSE 34516
// list := list ^ k ;
34500: LD_ADDR_VAR 0 6
34504: PUSH
34505: LD_VAR 0 6
34509: PUSH
34510: LD_VAR 0 4
34514: ADD
34515: ST_TO_ADDR
34516: GO 34470
34518: POP
34519: POP
// end ;
34520: GO 34452
34522: POP
34523: POP
// list := list diff mc_miners [ i ] ;
34524: LD_ADDR_VAR 0 6
34528: PUSH
34529: LD_VAR 0 6
34533: PUSH
34534: LD_EXP 110
34538: PUSH
34539: LD_VAR 0 2
34543: ARRAY
34544: DIFF
34545: ST_TO_ADDR
// if not list then
34546: LD_VAR 0 6
34550: NOT
34551: IFFALSE 34555
// continue ;
34553: GO 33928
// k := mc_mines [ i ] - mc_miners [ i ] ;
34555: LD_ADDR_VAR 0 4
34559: PUSH
34560: LD_EXP 109
34564: PUSH
34565: LD_VAR 0 2
34569: ARRAY
34570: PUSH
34571: LD_EXP 110
34575: PUSH
34576: LD_VAR 0 2
34580: ARRAY
34581: MINUS
34582: ST_TO_ADDR
// if k > list then
34583: LD_VAR 0 4
34587: PUSH
34588: LD_VAR 0 6
34592: GREATER
34593: IFFALSE 34605
// k := list ;
34595: LD_ADDR_VAR 0 4
34599: PUSH
34600: LD_VAR 0 6
34604: ST_TO_ADDR
// for j = 1 to k do
34605: LD_ADDR_VAR 0 3
34609: PUSH
34610: DOUBLE
34611: LD_INT 1
34613: DEC
34614: ST_TO_ADDR
34615: LD_VAR 0 4
34619: PUSH
34620: FOR_TO
34621: IFFALSE 34675
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34623: LD_ADDR_EXP 110
34627: PUSH
34628: LD_EXP 110
34632: PPUSH
34633: LD_VAR 0 2
34637: PUSH
34638: LD_EXP 110
34642: PUSH
34643: LD_VAR 0 2
34647: ARRAY
34648: PUSH
34649: LD_INT 1
34651: PLUS
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PPUSH
34657: LD_VAR 0 6
34661: PUSH
34662: LD_VAR 0 3
34666: ARRAY
34667: PPUSH
34668: CALL 57193 0 3
34672: ST_TO_ADDR
34673: GO 34620
34675: POP
34676: POP
// end ;
34677: GO 33928
34679: POP
34680: POP
// end ;
34681: LD_VAR 0 1
34685: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34686: LD_INT 0
34688: PPUSH
34689: PPUSH
34690: PPUSH
34691: PPUSH
34692: PPUSH
34693: PPUSH
34694: PPUSH
34695: PPUSH
34696: PPUSH
34697: PPUSH
34698: PPUSH
// if not mc_bases then
34699: LD_EXP 96
34703: NOT
34704: IFFALSE 34708
// exit ;
34706: GO 36531
// for i = 1 to mc_bases do
34708: LD_ADDR_VAR 0 2
34712: PUSH
34713: DOUBLE
34714: LD_INT 1
34716: DEC
34717: ST_TO_ADDR
34718: LD_EXP 96
34722: PUSH
34723: FOR_TO
34724: IFFALSE 36529
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34726: LD_EXP 96
34730: PUSH
34731: LD_VAR 0 2
34735: ARRAY
34736: NOT
34737: PUSH
34738: LD_EXP 103
34742: PUSH
34743: LD_VAR 0 2
34747: ARRAY
34748: OR
34749: IFFALSE 34753
// continue ;
34751: GO 34723
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34753: LD_EXP 112
34757: PUSH
34758: LD_VAR 0 2
34762: ARRAY
34763: NOT
34764: PUSH
34765: LD_EXP 113
34769: PUSH
34770: LD_VAR 0 2
34774: ARRAY
34775: AND
34776: IFFALSE 34814
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34778: LD_ADDR_EXP 113
34782: PUSH
34783: LD_EXP 113
34787: PPUSH
34788: LD_VAR 0 2
34792: PPUSH
34793: EMPTY
34794: PPUSH
34795: CALL_OW 1
34799: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34800: LD_VAR 0 2
34804: PPUSH
34805: LD_INT 107
34807: PPUSH
34808: CALL 25582 0 2
// continue ;
34812: GO 34723
// end ; target := [ ] ;
34814: LD_ADDR_VAR 0 7
34818: PUSH
34819: EMPTY
34820: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34821: LD_ADDR_VAR 0 6
34825: PUSH
34826: LD_EXP 96
34830: PUSH
34831: LD_VAR 0 2
34835: ARRAY
34836: PUSH
34837: LD_INT 1
34839: ARRAY
34840: PPUSH
34841: CALL_OW 255
34845: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34846: LD_ADDR_VAR 0 9
34850: PUSH
34851: LD_EXP 96
34855: PUSH
34856: LD_VAR 0 2
34860: ARRAY
34861: PPUSH
34862: LD_INT 2
34864: PUSH
34865: LD_INT 30
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 30
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: LIST
34889: PPUSH
34890: CALL_OW 72
34894: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34895: LD_ADDR_VAR 0 3
34899: PUSH
34900: DOUBLE
34901: LD_EXP 112
34905: PUSH
34906: LD_VAR 0 2
34910: ARRAY
34911: INC
34912: ST_TO_ADDR
34913: LD_INT 1
34915: PUSH
34916: FOR_DOWNTO
34917: IFFALSE 35162
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34919: LD_EXP 112
34923: PUSH
34924: LD_VAR 0 2
34928: ARRAY
34929: PUSH
34930: LD_VAR 0 3
34934: ARRAY
34935: PUSH
34936: LD_INT 2
34938: ARRAY
34939: PPUSH
34940: LD_EXP 112
34944: PUSH
34945: LD_VAR 0 2
34949: ARRAY
34950: PUSH
34951: LD_VAR 0 3
34955: ARRAY
34956: PUSH
34957: LD_INT 3
34959: ARRAY
34960: PPUSH
34961: CALL_OW 488
34965: PUSH
34966: LD_EXP 112
34970: PUSH
34971: LD_VAR 0 2
34975: ARRAY
34976: PUSH
34977: LD_VAR 0 3
34981: ARRAY
34982: PUSH
34983: LD_INT 2
34985: ARRAY
34986: PPUSH
34987: LD_EXP 112
34991: PUSH
34992: LD_VAR 0 2
34996: ARRAY
34997: PUSH
34998: LD_VAR 0 3
35002: ARRAY
35003: PUSH
35004: LD_INT 3
35006: ARRAY
35007: PPUSH
35008: CALL_OW 284
35012: PUSH
35013: LD_INT 0
35015: EQUAL
35016: AND
35017: IFFALSE 35072
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
35019: LD_ADDR_VAR 0 5
35023: PUSH
35024: LD_EXP 112
35028: PUSH
35029: LD_VAR 0 2
35033: ARRAY
35034: PPUSH
35035: LD_VAR 0 3
35039: PPUSH
35040: CALL_OW 3
35044: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35045: LD_ADDR_EXP 112
35049: PUSH
35050: LD_EXP 112
35054: PPUSH
35055: LD_VAR 0 2
35059: PPUSH
35060: LD_VAR 0 5
35064: PPUSH
35065: CALL_OW 1
35069: ST_TO_ADDR
// continue ;
35070: GO 34916
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35072: LD_VAR 0 6
35076: PPUSH
35077: LD_EXP 112
35081: PUSH
35082: LD_VAR 0 2
35086: ARRAY
35087: PUSH
35088: LD_VAR 0 3
35092: ARRAY
35093: PUSH
35094: LD_INT 2
35096: ARRAY
35097: PPUSH
35098: LD_EXP 112
35102: PUSH
35103: LD_VAR 0 2
35107: ARRAY
35108: PUSH
35109: LD_VAR 0 3
35113: ARRAY
35114: PUSH
35115: LD_INT 3
35117: ARRAY
35118: PPUSH
35119: LD_INT 30
35121: PPUSH
35122: CALL 58089 0 4
35126: PUSH
35127: LD_INT 4
35129: ARRAY
35130: PUSH
35131: LD_INT 0
35133: EQUAL
35134: IFFALSE 35160
// begin target := mc_crates [ i ] [ j ] ;
35136: LD_ADDR_VAR 0 7
35140: PUSH
35141: LD_EXP 112
35145: PUSH
35146: LD_VAR 0 2
35150: ARRAY
35151: PUSH
35152: LD_VAR 0 3
35156: ARRAY
35157: ST_TO_ADDR
// break ;
35158: GO 35162
// end ; end ;
35160: GO 34916
35162: POP
35163: POP
// if not target then
35164: LD_VAR 0 7
35168: NOT
35169: IFFALSE 35173
// continue ;
35171: GO 34723
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35173: LD_ADDR_VAR 0 8
35177: PUSH
35178: LD_EXP 115
35182: PUSH
35183: LD_VAR 0 2
35187: ARRAY
35188: PPUSH
35189: LD_INT 2
35191: PUSH
35192: LD_INT 3
35194: PUSH
35195: LD_INT 58
35197: PUSH
35198: EMPTY
35199: LIST
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: LD_INT 61
35207: PUSH
35208: EMPTY
35209: LIST
35210: PUSH
35211: LD_INT 33
35213: PUSH
35214: LD_INT 5
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 33
35223: PUSH
35224: LD_INT 3
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: LIST
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 2
35240: PUSH
35241: LD_INT 34
35243: PUSH
35244: LD_INT 32
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 34
35253: PUSH
35254: LD_INT 51
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 34
35263: PUSH
35264: LD_INT 12
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PPUSH
35281: CALL_OW 72
35285: ST_TO_ADDR
// if not cargo then
35286: LD_VAR 0 8
35290: NOT
35291: IFFALSE 35997
// begin if mc_crates_collector [ i ] < 5 then
35293: LD_EXP 113
35297: PUSH
35298: LD_VAR 0 2
35302: ARRAY
35303: PUSH
35304: LD_INT 5
35306: LESS
35307: IFFALSE 35673
// begin if mc_ape [ i ] then
35309: LD_EXP 125
35313: PUSH
35314: LD_VAR 0 2
35318: ARRAY
35319: IFFALSE 35366
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35321: LD_ADDR_VAR 0 5
35325: PUSH
35326: LD_EXP 125
35330: PUSH
35331: LD_VAR 0 2
35335: ARRAY
35336: PPUSH
35337: LD_INT 25
35339: PUSH
35340: LD_INT 16
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 24
35349: PUSH
35350: LD_INT 750
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PPUSH
35361: CALL_OW 72
35365: ST_TO_ADDR
// if not tmp then
35366: LD_VAR 0 5
35370: NOT
35371: IFFALSE 35418
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35373: LD_ADDR_VAR 0 5
35377: PUSH
35378: LD_EXP 96
35382: PUSH
35383: LD_VAR 0 2
35387: ARRAY
35388: PPUSH
35389: LD_INT 25
35391: PUSH
35392: LD_INT 2
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 24
35401: PUSH
35402: LD_INT 750
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PPUSH
35413: CALL_OW 72
35417: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35418: LD_EXP 125
35422: PUSH
35423: LD_VAR 0 2
35427: ARRAY
35428: PUSH
35429: LD_EXP 96
35433: PUSH
35434: LD_VAR 0 2
35438: ARRAY
35439: PPUSH
35440: LD_INT 25
35442: PUSH
35443: LD_INT 2
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 24
35452: PUSH
35453: LD_INT 750
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: PPUSH
35464: CALL_OW 72
35468: AND
35469: PUSH
35470: LD_VAR 0 5
35474: PUSH
35475: LD_INT 5
35477: LESS
35478: AND
35479: IFFALSE 35561
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35481: LD_ADDR_VAR 0 3
35485: PUSH
35486: LD_EXP 96
35490: PUSH
35491: LD_VAR 0 2
35495: ARRAY
35496: PPUSH
35497: LD_INT 25
35499: PUSH
35500: LD_INT 2
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 24
35509: PUSH
35510: LD_INT 750
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: EMPTY
35518: LIST
35519: LIST
35520: PPUSH
35521: CALL_OW 72
35525: PUSH
35526: FOR_IN
35527: IFFALSE 35559
// begin tmp := tmp union j ;
35529: LD_ADDR_VAR 0 5
35533: PUSH
35534: LD_VAR 0 5
35538: PUSH
35539: LD_VAR 0 3
35543: UNION
35544: ST_TO_ADDR
// if tmp >= 5 then
35545: LD_VAR 0 5
35549: PUSH
35550: LD_INT 5
35552: GREATEREQUAL
35553: IFFALSE 35557
// break ;
35555: GO 35559
// end ;
35557: GO 35526
35559: POP
35560: POP
// end ; if not tmp then
35561: LD_VAR 0 5
35565: NOT
35566: IFFALSE 35570
// continue ;
35568: GO 34723
// for j in tmp do
35570: LD_ADDR_VAR 0 3
35574: PUSH
35575: LD_VAR 0 5
35579: PUSH
35580: FOR_IN
35581: IFFALSE 35671
// if not GetTag ( j ) then
35583: LD_VAR 0 3
35587: PPUSH
35588: CALL_OW 110
35592: NOT
35593: IFFALSE 35669
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35595: LD_ADDR_EXP 113
35599: PUSH
35600: LD_EXP 113
35604: PPUSH
35605: LD_VAR 0 2
35609: PUSH
35610: LD_EXP 113
35614: PUSH
35615: LD_VAR 0 2
35619: ARRAY
35620: PUSH
35621: LD_INT 1
35623: PLUS
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PPUSH
35629: LD_VAR 0 3
35633: PPUSH
35634: CALL 57193 0 3
35638: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35639: LD_VAR 0 3
35643: PPUSH
35644: LD_INT 107
35646: PPUSH
35647: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35651: LD_EXP 113
35655: PUSH
35656: LD_VAR 0 2
35660: ARRAY
35661: PUSH
35662: LD_INT 5
35664: GREATEREQUAL
35665: IFFALSE 35669
// break ;
35667: GO 35671
// end ;
35669: GO 35580
35671: POP
35672: POP
// end ; if mc_crates_collector [ i ] and target then
35673: LD_EXP 113
35677: PUSH
35678: LD_VAR 0 2
35682: ARRAY
35683: PUSH
35684: LD_VAR 0 7
35688: AND
35689: IFFALSE 35995
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35691: LD_EXP 113
35695: PUSH
35696: LD_VAR 0 2
35700: ARRAY
35701: PUSH
35702: LD_VAR 0 7
35706: PUSH
35707: LD_INT 1
35709: ARRAY
35710: LESS
35711: IFFALSE 35731
// tmp := mc_crates_collector [ i ] else
35713: LD_ADDR_VAR 0 5
35717: PUSH
35718: LD_EXP 113
35722: PUSH
35723: LD_VAR 0 2
35727: ARRAY
35728: ST_TO_ADDR
35729: GO 35745
// tmp := target [ 1 ] ;
35731: LD_ADDR_VAR 0 5
35735: PUSH
35736: LD_VAR 0 7
35740: PUSH
35741: LD_INT 1
35743: ARRAY
35744: ST_TO_ADDR
// k := 0 ;
35745: LD_ADDR_VAR 0 4
35749: PUSH
35750: LD_INT 0
35752: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35753: LD_ADDR_VAR 0 3
35757: PUSH
35758: LD_EXP 113
35762: PUSH
35763: LD_VAR 0 2
35767: ARRAY
35768: PUSH
35769: FOR_IN
35770: IFFALSE 35993
// begin k := k + 1 ;
35772: LD_ADDR_VAR 0 4
35776: PUSH
35777: LD_VAR 0 4
35781: PUSH
35782: LD_INT 1
35784: PLUS
35785: ST_TO_ADDR
// if k > tmp then
35786: LD_VAR 0 4
35790: PUSH
35791: LD_VAR 0 5
35795: GREATER
35796: IFFALSE 35800
// break ;
35798: GO 35993
// if not GetClass ( j ) in [ 2 , 16 ] then
35800: LD_VAR 0 3
35804: PPUSH
35805: CALL_OW 257
35809: PUSH
35810: LD_INT 2
35812: PUSH
35813: LD_INT 16
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: IN
35820: NOT
35821: IFFALSE 35874
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35823: LD_ADDR_EXP 113
35827: PUSH
35828: LD_EXP 113
35832: PPUSH
35833: LD_VAR 0 2
35837: PPUSH
35838: LD_EXP 113
35842: PUSH
35843: LD_VAR 0 2
35847: ARRAY
35848: PUSH
35849: LD_VAR 0 3
35853: DIFF
35854: PPUSH
35855: CALL_OW 1
35859: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35860: LD_VAR 0 3
35864: PPUSH
35865: LD_INT 0
35867: PPUSH
35868: CALL_OW 109
// continue ;
35872: GO 35769
// end ; if IsInUnit ( j ) then
35874: LD_VAR 0 3
35878: PPUSH
35879: CALL_OW 310
35883: IFFALSE 35894
// ComExitBuilding ( j ) ;
35885: LD_VAR 0 3
35889: PPUSH
35890: CALL_OW 122
// wait ( 3 ) ;
35894: LD_INT 3
35896: PPUSH
35897: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35901: LD_VAR 0 3
35905: PPUSH
35906: CALL_OW 314
35910: PUSH
35911: LD_VAR 0 6
35915: PPUSH
35916: LD_VAR 0 7
35920: PUSH
35921: LD_INT 2
35923: ARRAY
35924: PPUSH
35925: LD_VAR 0 7
35929: PUSH
35930: LD_INT 3
35932: ARRAY
35933: PPUSH
35934: LD_INT 30
35936: PPUSH
35937: CALL 58089 0 4
35941: PUSH
35942: LD_INT 4
35944: ARRAY
35945: AND
35946: IFFALSE 35964
// ComStandNearbyBuilding ( j , depot ) else
35948: LD_VAR 0 3
35952: PPUSH
35953: LD_VAR 0 9
35957: PPUSH
35958: CALL 53618 0 2
35962: GO 35991
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35964: LD_VAR 0 3
35968: PPUSH
35969: LD_VAR 0 7
35973: PUSH
35974: LD_INT 2
35976: ARRAY
35977: PPUSH
35978: LD_VAR 0 7
35982: PUSH
35983: LD_INT 3
35985: ARRAY
35986: PPUSH
35987: CALL_OW 117
// end ;
35991: GO 35769
35993: POP
35994: POP
// end ; end else
35995: GO 36527
// begin for j in cargo do
35997: LD_ADDR_VAR 0 3
36001: PUSH
36002: LD_VAR 0 8
36006: PUSH
36007: FOR_IN
36008: IFFALSE 36525
// begin if GetTag ( j ) <> 0 then
36010: LD_VAR 0 3
36014: PPUSH
36015: CALL_OW 110
36019: PUSH
36020: LD_INT 0
36022: NONEQUAL
36023: IFFALSE 36027
// continue ;
36025: GO 36007
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
36027: LD_VAR 0 3
36031: PPUSH
36032: CALL_OW 256
36036: PUSH
36037: LD_INT 1000
36039: LESS
36040: PUSH
36041: LD_VAR 0 3
36045: PPUSH
36046: LD_EXP 120
36050: PUSH
36051: LD_VAR 0 2
36055: ARRAY
36056: PPUSH
36057: CALL_OW 308
36061: NOT
36062: AND
36063: IFFALSE 36085
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36065: LD_VAR 0 3
36069: PPUSH
36070: LD_EXP 120
36074: PUSH
36075: LD_VAR 0 2
36079: ARRAY
36080: PPUSH
36081: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36085: LD_VAR 0 3
36089: PPUSH
36090: CALL_OW 256
36094: PUSH
36095: LD_INT 1000
36097: LESS
36098: PUSH
36099: LD_VAR 0 3
36103: PPUSH
36104: LD_EXP 120
36108: PUSH
36109: LD_VAR 0 2
36113: ARRAY
36114: PPUSH
36115: CALL_OW 308
36119: AND
36120: IFFALSE 36124
// continue ;
36122: GO 36007
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36124: LD_VAR 0 3
36128: PPUSH
36129: CALL_OW 262
36133: PUSH
36134: LD_INT 2
36136: EQUAL
36137: PUSH
36138: LD_VAR 0 3
36142: PPUSH
36143: CALL_OW 261
36147: PUSH
36148: LD_INT 15
36150: LESS
36151: AND
36152: IFFALSE 36156
// continue ;
36154: GO 36007
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36156: LD_VAR 0 3
36160: PPUSH
36161: CALL_OW 262
36165: PUSH
36166: LD_INT 1
36168: EQUAL
36169: PUSH
36170: LD_VAR 0 3
36174: PPUSH
36175: CALL_OW 261
36179: PUSH
36180: LD_INT 10
36182: LESS
36183: AND
36184: IFFALSE 36464
// begin if not depot then
36186: LD_VAR 0 9
36190: NOT
36191: IFFALSE 36195
// continue ;
36193: GO 36007
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36195: LD_VAR 0 3
36199: PPUSH
36200: LD_VAR 0 9
36204: PPUSH
36205: LD_VAR 0 3
36209: PPUSH
36210: CALL_OW 74
36214: PPUSH
36215: CALL_OW 296
36219: PUSH
36220: LD_INT 6
36222: LESS
36223: IFFALSE 36239
// SetFuel ( j , 100 ) else
36225: LD_VAR 0 3
36229: PPUSH
36230: LD_INT 100
36232: PPUSH
36233: CALL_OW 240
36237: GO 36464
// if GetFuel ( j ) = 0 then
36239: LD_VAR 0 3
36243: PPUSH
36244: CALL_OW 261
36248: PUSH
36249: LD_INT 0
36251: EQUAL
36252: IFFALSE 36464
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36254: LD_ADDR_EXP 115
36258: PUSH
36259: LD_EXP 115
36263: PPUSH
36264: LD_VAR 0 2
36268: PPUSH
36269: LD_EXP 115
36273: PUSH
36274: LD_VAR 0 2
36278: ARRAY
36279: PUSH
36280: LD_VAR 0 3
36284: DIFF
36285: PPUSH
36286: CALL_OW 1
36290: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36291: LD_VAR 0 3
36295: PPUSH
36296: CALL_OW 263
36300: PUSH
36301: LD_INT 1
36303: EQUAL
36304: IFFALSE 36320
// ComExitVehicle ( IsInUnit ( j ) ) ;
36306: LD_VAR 0 3
36310: PPUSH
36311: CALL_OW 310
36315: PPUSH
36316: CALL_OW 121
// if GetControl ( j ) = control_remote then
36320: LD_VAR 0 3
36324: PPUSH
36325: CALL_OW 263
36329: PUSH
36330: LD_INT 2
36332: EQUAL
36333: IFFALSE 36344
// ComUnlink ( j ) ;
36335: LD_VAR 0 3
36339: PPUSH
36340: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36344: LD_ADDR_VAR 0 10
36348: PUSH
36349: LD_VAR 0 2
36353: PPUSH
36354: LD_INT 3
36356: PPUSH
36357: CALL 46103 0 2
36361: ST_TO_ADDR
// if fac then
36362: LD_VAR 0 10
36366: IFFALSE 36462
// begin for k in fac do
36368: LD_ADDR_VAR 0 4
36372: PUSH
36373: LD_VAR 0 10
36377: PUSH
36378: FOR_IN
36379: IFFALSE 36460
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36381: LD_ADDR_VAR 0 11
36385: PUSH
36386: LD_VAR 0 10
36390: PPUSH
36391: LD_VAR 0 3
36395: PPUSH
36396: CALL_OW 265
36400: PPUSH
36401: LD_VAR 0 3
36405: PPUSH
36406: CALL_OW 262
36410: PPUSH
36411: LD_VAR 0 3
36415: PPUSH
36416: CALL_OW 263
36420: PPUSH
36421: LD_VAR 0 3
36425: PPUSH
36426: CALL_OW 264
36430: PPUSH
36431: CALL 54689 0 5
36435: ST_TO_ADDR
// if components then
36436: LD_VAR 0 11
36440: IFFALSE 36458
// begin MC_InsertProduceList ( i , components ) ;
36442: LD_VAR 0 2
36446: PPUSH
36447: LD_VAR 0 11
36451: PPUSH
36452: CALL 45648 0 2
// break ;
36456: GO 36460
// end ; end ;
36458: GO 36378
36460: POP
36461: POP
// end ; continue ;
36462: GO 36007
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36464: LD_VAR 0 3
36468: PPUSH
36469: LD_INT 1
36471: PPUSH
36472: CALL_OW 289
36476: PUSH
36477: LD_INT 100
36479: LESS
36480: PUSH
36481: LD_VAR 0 3
36485: PPUSH
36486: CALL_OW 314
36490: NOT
36491: AND
36492: IFFALSE 36521
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36494: LD_VAR 0 3
36498: PPUSH
36499: LD_VAR 0 7
36503: PUSH
36504: LD_INT 2
36506: ARRAY
36507: PPUSH
36508: LD_VAR 0 7
36512: PUSH
36513: LD_INT 3
36515: ARRAY
36516: PPUSH
36517: CALL_OW 117
// break ;
36521: GO 36525
// end ;
36523: GO 36007
36525: POP
36526: POP
// end ; end ;
36527: GO 34723
36529: POP
36530: POP
// end ;
36531: LD_VAR 0 1
36535: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36536: LD_INT 0
36538: PPUSH
36539: PPUSH
36540: PPUSH
36541: PPUSH
// if not mc_bases then
36542: LD_EXP 96
36546: NOT
36547: IFFALSE 36551
// exit ;
36549: GO 36712
// for i = 1 to mc_bases do
36551: LD_ADDR_VAR 0 2
36555: PUSH
36556: DOUBLE
36557: LD_INT 1
36559: DEC
36560: ST_TO_ADDR
36561: LD_EXP 96
36565: PUSH
36566: FOR_TO
36567: IFFALSE 36710
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36569: LD_ADDR_VAR 0 4
36573: PUSH
36574: LD_EXP 115
36578: PUSH
36579: LD_VAR 0 2
36583: ARRAY
36584: PUSH
36585: LD_EXP 118
36589: PUSH
36590: LD_VAR 0 2
36594: ARRAY
36595: UNION
36596: PPUSH
36597: LD_INT 33
36599: PUSH
36600: LD_INT 2
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PPUSH
36607: CALL_OW 72
36611: ST_TO_ADDR
// if tmp then
36612: LD_VAR 0 4
36616: IFFALSE 36708
// for j in tmp do
36618: LD_ADDR_VAR 0 3
36622: PUSH
36623: LD_VAR 0 4
36627: PUSH
36628: FOR_IN
36629: IFFALSE 36706
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36631: LD_VAR 0 3
36635: PPUSH
36636: CALL_OW 312
36640: NOT
36641: PUSH
36642: LD_VAR 0 3
36646: PPUSH
36647: CALL_OW 256
36651: PUSH
36652: LD_INT 250
36654: GREATEREQUAL
36655: AND
36656: IFFALSE 36669
// Connect ( j ) else
36658: LD_VAR 0 3
36662: PPUSH
36663: CALL 60164 0 1
36667: GO 36704
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36669: LD_VAR 0 3
36673: PPUSH
36674: CALL_OW 256
36678: PUSH
36679: LD_INT 250
36681: LESS
36682: PUSH
36683: LD_VAR 0 3
36687: PPUSH
36688: CALL_OW 312
36692: AND
36693: IFFALSE 36704
// ComUnlink ( j ) ;
36695: LD_VAR 0 3
36699: PPUSH
36700: CALL_OW 136
36704: GO 36628
36706: POP
36707: POP
// end ;
36708: GO 36566
36710: POP
36711: POP
// end ;
36712: LD_VAR 0 1
36716: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36717: LD_INT 0
36719: PPUSH
36720: PPUSH
36721: PPUSH
36722: PPUSH
36723: PPUSH
// if not mc_bases then
36724: LD_EXP 96
36728: NOT
36729: IFFALSE 36733
// exit ;
36731: GO 37178
// for i = 1 to mc_bases do
36733: LD_ADDR_VAR 0 2
36737: PUSH
36738: DOUBLE
36739: LD_INT 1
36741: DEC
36742: ST_TO_ADDR
36743: LD_EXP 96
36747: PUSH
36748: FOR_TO
36749: IFFALSE 37176
// begin if not mc_produce [ i ] then
36751: LD_EXP 117
36755: PUSH
36756: LD_VAR 0 2
36760: ARRAY
36761: NOT
36762: IFFALSE 36766
// continue ;
36764: GO 36748
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36766: LD_ADDR_VAR 0 5
36770: PUSH
36771: LD_EXP 96
36775: PUSH
36776: LD_VAR 0 2
36780: ARRAY
36781: PPUSH
36782: LD_INT 30
36784: PUSH
36785: LD_INT 3
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PPUSH
36792: CALL_OW 72
36796: ST_TO_ADDR
// if not fac then
36797: LD_VAR 0 5
36801: NOT
36802: IFFALSE 36806
// continue ;
36804: GO 36748
// for j in fac do
36806: LD_ADDR_VAR 0 3
36810: PUSH
36811: LD_VAR 0 5
36815: PUSH
36816: FOR_IN
36817: IFFALSE 37172
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36819: LD_VAR 0 3
36823: PPUSH
36824: CALL_OW 461
36828: PUSH
36829: LD_INT 2
36831: NONEQUAL
36832: PUSH
36833: LD_VAR 0 3
36837: PPUSH
36838: LD_INT 15
36840: PPUSH
36841: CALL 59792 0 2
36845: PUSH
36846: LD_INT 4
36848: ARRAY
36849: OR
36850: IFFALSE 36854
// continue ;
36852: GO 36816
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36854: LD_VAR 0 3
36858: PPUSH
36859: LD_EXP 117
36863: PUSH
36864: LD_VAR 0 2
36868: ARRAY
36869: PUSH
36870: LD_INT 1
36872: ARRAY
36873: PUSH
36874: LD_INT 1
36876: ARRAY
36877: PPUSH
36878: LD_EXP 117
36882: PUSH
36883: LD_VAR 0 2
36887: ARRAY
36888: PUSH
36889: LD_INT 1
36891: ARRAY
36892: PUSH
36893: LD_INT 2
36895: ARRAY
36896: PPUSH
36897: LD_EXP 117
36901: PUSH
36902: LD_VAR 0 2
36906: ARRAY
36907: PUSH
36908: LD_INT 1
36910: ARRAY
36911: PUSH
36912: LD_INT 3
36914: ARRAY
36915: PPUSH
36916: LD_EXP 117
36920: PUSH
36921: LD_VAR 0 2
36925: ARRAY
36926: PUSH
36927: LD_INT 1
36929: ARRAY
36930: PUSH
36931: LD_INT 4
36933: ARRAY
36934: PPUSH
36935: CALL_OW 448
36939: PUSH
36940: LD_VAR 0 3
36944: PPUSH
36945: LD_EXP 117
36949: PUSH
36950: LD_VAR 0 2
36954: ARRAY
36955: PUSH
36956: LD_INT 1
36958: ARRAY
36959: PUSH
36960: LD_INT 1
36962: ARRAY
36963: PUSH
36964: LD_EXP 117
36968: PUSH
36969: LD_VAR 0 2
36973: ARRAY
36974: PUSH
36975: LD_INT 1
36977: ARRAY
36978: PUSH
36979: LD_INT 2
36981: ARRAY
36982: PUSH
36983: LD_EXP 117
36987: PUSH
36988: LD_VAR 0 2
36992: ARRAY
36993: PUSH
36994: LD_INT 1
36996: ARRAY
36997: PUSH
36998: LD_INT 3
37000: ARRAY
37001: PUSH
37002: LD_EXP 117
37006: PUSH
37007: LD_VAR 0 2
37011: ARRAY
37012: PUSH
37013: LD_INT 1
37015: ARRAY
37016: PUSH
37017: LD_INT 4
37019: ARRAY
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: PPUSH
37027: CALL 63559 0 2
37031: AND
37032: IFFALSE 37170
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37034: LD_VAR 0 3
37038: PPUSH
37039: LD_EXP 117
37043: PUSH
37044: LD_VAR 0 2
37048: ARRAY
37049: PUSH
37050: LD_INT 1
37052: ARRAY
37053: PUSH
37054: LD_INT 1
37056: ARRAY
37057: PPUSH
37058: LD_EXP 117
37062: PUSH
37063: LD_VAR 0 2
37067: ARRAY
37068: PUSH
37069: LD_INT 1
37071: ARRAY
37072: PUSH
37073: LD_INT 2
37075: ARRAY
37076: PPUSH
37077: LD_EXP 117
37081: PUSH
37082: LD_VAR 0 2
37086: ARRAY
37087: PUSH
37088: LD_INT 1
37090: ARRAY
37091: PUSH
37092: LD_INT 3
37094: ARRAY
37095: PPUSH
37096: LD_EXP 117
37100: PUSH
37101: LD_VAR 0 2
37105: ARRAY
37106: PUSH
37107: LD_INT 1
37109: ARRAY
37110: PUSH
37111: LD_INT 4
37113: ARRAY
37114: PPUSH
37115: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37119: LD_ADDR_VAR 0 4
37123: PUSH
37124: LD_EXP 117
37128: PUSH
37129: LD_VAR 0 2
37133: ARRAY
37134: PPUSH
37135: LD_INT 1
37137: PPUSH
37138: CALL_OW 3
37142: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37143: LD_ADDR_EXP 117
37147: PUSH
37148: LD_EXP 117
37152: PPUSH
37153: LD_VAR 0 2
37157: PPUSH
37158: LD_VAR 0 4
37162: PPUSH
37163: CALL_OW 1
37167: ST_TO_ADDR
// break ;
37168: GO 37172
// end ; end ;
37170: GO 36816
37172: POP
37173: POP
// end ;
37174: GO 36748
37176: POP
37177: POP
// end ;
37178: LD_VAR 0 1
37182: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37183: LD_INT 0
37185: PPUSH
37186: PPUSH
37187: PPUSH
// if not mc_bases then
37188: LD_EXP 96
37192: NOT
37193: IFFALSE 37197
// exit ;
37195: GO 37286
// for i = 1 to mc_bases do
37197: LD_ADDR_VAR 0 2
37201: PUSH
37202: DOUBLE
37203: LD_INT 1
37205: DEC
37206: ST_TO_ADDR
37207: LD_EXP 96
37211: PUSH
37212: FOR_TO
37213: IFFALSE 37284
// begin if mc_attack [ i ] then
37215: LD_EXP 116
37219: PUSH
37220: LD_VAR 0 2
37224: ARRAY
37225: IFFALSE 37282
// begin tmp := mc_attack [ i ] [ 1 ] ;
37227: LD_ADDR_VAR 0 3
37231: PUSH
37232: LD_EXP 116
37236: PUSH
37237: LD_VAR 0 2
37241: ARRAY
37242: PUSH
37243: LD_INT 1
37245: ARRAY
37246: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37247: LD_ADDR_EXP 116
37251: PUSH
37252: LD_EXP 116
37256: PPUSH
37257: LD_VAR 0 2
37261: PPUSH
37262: EMPTY
37263: PPUSH
37264: CALL_OW 1
37268: ST_TO_ADDR
// Attack ( tmp ) ;
37269: LD_VAR 0 3
37273: PPUSH
37274: CALL 111616 0 1
// exit ;
37278: POP
37279: POP
37280: GO 37286
// end ; end ;
37282: GO 37212
37284: POP
37285: POP
// end ;
37286: LD_VAR 0 1
37290: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37291: LD_INT 0
37293: PPUSH
37294: PPUSH
37295: PPUSH
37296: PPUSH
37297: PPUSH
37298: PPUSH
37299: PPUSH
// if not mc_bases then
37300: LD_EXP 96
37304: NOT
37305: IFFALSE 37309
// exit ;
37307: GO 38166
// for i = 1 to mc_bases do
37309: LD_ADDR_VAR 0 2
37313: PUSH
37314: DOUBLE
37315: LD_INT 1
37317: DEC
37318: ST_TO_ADDR
37319: LD_EXP 96
37323: PUSH
37324: FOR_TO
37325: IFFALSE 38164
// begin if not mc_bases [ i ] then
37327: LD_EXP 96
37331: PUSH
37332: LD_VAR 0 2
37336: ARRAY
37337: NOT
37338: IFFALSE 37342
// continue ;
37340: GO 37324
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37342: LD_ADDR_VAR 0 7
37346: PUSH
37347: LD_EXP 96
37351: PUSH
37352: LD_VAR 0 2
37356: ARRAY
37357: PUSH
37358: LD_INT 1
37360: ARRAY
37361: PPUSH
37362: CALL 53840 0 1
37366: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37367: LD_ADDR_EXP 119
37371: PUSH
37372: LD_EXP 119
37376: PPUSH
37377: LD_VAR 0 2
37381: PPUSH
37382: LD_EXP 96
37386: PUSH
37387: LD_VAR 0 2
37391: ARRAY
37392: PUSH
37393: LD_INT 1
37395: ARRAY
37396: PPUSH
37397: CALL_OW 255
37401: PPUSH
37402: LD_EXP 121
37406: PUSH
37407: LD_VAR 0 2
37411: ARRAY
37412: PPUSH
37413: CALL 53805 0 2
37417: PPUSH
37418: CALL_OW 1
37422: ST_TO_ADDR
// if not mc_scan [ i ] then
37423: LD_EXP 119
37427: PUSH
37428: LD_VAR 0 2
37432: ARRAY
37433: NOT
37434: IFFALSE 37612
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37436: LD_ADDR_EXP 139
37440: PUSH
37441: LD_EXP 139
37445: PPUSH
37446: LD_VAR 0 2
37450: PPUSH
37451: LD_INT 0
37453: PPUSH
37454: CALL_OW 1
37458: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37459: LD_ADDR_VAR 0 4
37463: PUSH
37464: LD_EXP 96
37468: PUSH
37469: LD_VAR 0 2
37473: ARRAY
37474: PPUSH
37475: LD_INT 2
37477: PUSH
37478: LD_INT 25
37480: PUSH
37481: LD_INT 5
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 25
37490: PUSH
37491: LD_INT 8
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 25
37500: PUSH
37501: LD_INT 9
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: LIST
37512: LIST
37513: PPUSH
37514: CALL_OW 72
37518: ST_TO_ADDR
// if not tmp then
37519: LD_VAR 0 4
37523: NOT
37524: IFFALSE 37528
// continue ;
37526: GO 37324
// for j in tmp do
37528: LD_ADDR_VAR 0 3
37532: PUSH
37533: LD_VAR 0 4
37537: PUSH
37538: FOR_IN
37539: IFFALSE 37610
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37541: LD_VAR 0 3
37545: PPUSH
37546: CALL_OW 310
37550: PPUSH
37551: CALL_OW 266
37555: PUSH
37556: LD_INT 5
37558: EQUAL
37559: PUSH
37560: LD_VAR 0 3
37564: PPUSH
37565: CALL_OW 257
37569: PUSH
37570: LD_INT 1
37572: EQUAL
37573: AND
37574: PUSH
37575: LD_VAR 0 3
37579: PPUSH
37580: CALL_OW 459
37584: NOT
37585: AND
37586: PUSH
37587: LD_VAR 0 7
37591: AND
37592: IFFALSE 37608
// ComChangeProfession ( j , class ) ;
37594: LD_VAR 0 3
37598: PPUSH
37599: LD_VAR 0 7
37603: PPUSH
37604: CALL_OW 123
37608: GO 37538
37610: POP
37611: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37612: LD_EXP 119
37616: PUSH
37617: LD_VAR 0 2
37621: ARRAY
37622: PUSH
37623: LD_EXP 139
37627: PUSH
37628: LD_VAR 0 2
37632: ARRAY
37633: NOT
37634: AND
37635: PUSH
37636: LD_EXP 118
37640: PUSH
37641: LD_VAR 0 2
37645: ARRAY
37646: NOT
37647: AND
37648: PUSH
37649: LD_EXP 96
37653: PUSH
37654: LD_VAR 0 2
37658: ARRAY
37659: PPUSH
37660: LD_INT 50
37662: PUSH
37663: EMPTY
37664: LIST
37665: PUSH
37666: LD_INT 2
37668: PUSH
37669: LD_INT 30
37671: PUSH
37672: LD_INT 32
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 30
37681: PUSH
37682: LD_INT 33
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 30
37691: PUSH
37692: LD_INT 4
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 30
37701: PUSH
37702: LD_INT 5
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PPUSH
37720: CALL_OW 72
37724: PUSH
37725: LD_INT 4
37727: LESS
37728: PUSH
37729: LD_EXP 96
37733: PUSH
37734: LD_VAR 0 2
37738: ARRAY
37739: PPUSH
37740: LD_INT 3
37742: PUSH
37743: LD_INT 24
37745: PUSH
37746: LD_INT 1000
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 2
37759: PUSH
37760: LD_INT 30
37762: PUSH
37763: LD_INT 0
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 30
37772: PUSH
37773: LD_INT 1
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: LIST
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PPUSH
37789: CALL_OW 72
37793: OR
37794: AND
37795: IFFALSE 38046
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37797: LD_ADDR_EXP 139
37801: PUSH
37802: LD_EXP 139
37806: PPUSH
37807: LD_VAR 0 2
37811: PPUSH
37812: LD_INT 1
37814: PPUSH
37815: CALL_OW 1
37819: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37820: LD_ADDR_VAR 0 4
37824: PUSH
37825: LD_EXP 96
37829: PUSH
37830: LD_VAR 0 2
37834: ARRAY
37835: PPUSH
37836: LD_INT 2
37838: PUSH
37839: LD_INT 25
37841: PUSH
37842: LD_INT 1
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 25
37851: PUSH
37852: LD_INT 5
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 25
37861: PUSH
37862: LD_INT 8
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 25
37871: PUSH
37872: LD_INT 9
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: PPUSH
37886: CALL_OW 72
37890: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37891: LD_ADDR_VAR 0 4
37895: PUSH
37896: LD_VAR 0 4
37900: PUSH
37901: LD_VAR 0 4
37905: PPUSH
37906: LD_INT 18
37908: PPUSH
37909: CALL 86462 0 2
37913: DIFF
37914: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37915: LD_VAR 0 4
37919: NOT
37920: PUSH
37921: LD_EXP 96
37925: PUSH
37926: LD_VAR 0 2
37930: ARRAY
37931: PPUSH
37932: LD_INT 2
37934: PUSH
37935: LD_INT 30
37937: PUSH
37938: LD_INT 4
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 30
37947: PUSH
37948: LD_INT 5
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: LIST
37959: PPUSH
37960: CALL_OW 72
37964: NOT
37965: AND
37966: IFFALSE 38028
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37968: LD_ADDR_VAR 0 4
37972: PUSH
37973: LD_EXP 96
37977: PUSH
37978: LD_VAR 0 2
37982: ARRAY
37983: PPUSH
37984: LD_INT 2
37986: PUSH
37987: LD_INT 25
37989: PUSH
37990: LD_INT 2
37992: PUSH
37993: EMPTY
37994: LIST
37995: LIST
37996: PUSH
37997: LD_INT 25
37999: PUSH
38000: LD_INT 3
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 25
38009: PUSH
38010: LD_INT 4
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: LIST
38021: LIST
38022: PPUSH
38023: CALL_OW 72
38027: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38028: LD_VAR 0 2
38032: PPUSH
38033: LD_VAR 0 4
38037: PPUSH
38038: CALL 116325 0 2
// exit ;
38042: POP
38043: POP
38044: GO 38166
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38046: LD_EXP 119
38050: PUSH
38051: LD_VAR 0 2
38055: ARRAY
38056: PUSH
38057: LD_EXP 139
38061: PUSH
38062: LD_VAR 0 2
38066: ARRAY
38067: NOT
38068: AND
38069: PUSH
38070: LD_EXP 118
38074: PUSH
38075: LD_VAR 0 2
38079: ARRAY
38080: AND
38081: IFFALSE 38162
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38083: LD_ADDR_EXP 139
38087: PUSH
38088: LD_EXP 139
38092: PPUSH
38093: LD_VAR 0 2
38097: PPUSH
38098: LD_INT 1
38100: PPUSH
38101: CALL_OW 1
38105: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38106: LD_ADDR_VAR 0 4
38110: PUSH
38111: LD_EXP 118
38115: PUSH
38116: LD_VAR 0 2
38120: ARRAY
38121: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38122: LD_ADDR_EXP 118
38126: PUSH
38127: LD_EXP 118
38131: PPUSH
38132: LD_VAR 0 2
38136: PPUSH
38137: EMPTY
38138: PPUSH
38139: CALL_OW 1
38143: ST_TO_ADDR
// Defend ( i , tmp ) ;
38144: LD_VAR 0 2
38148: PPUSH
38149: LD_VAR 0 4
38153: PPUSH
38154: CALL 116921 0 2
// exit ;
38158: POP
38159: POP
38160: GO 38166
// end ; end ;
38162: GO 37324
38164: POP
38165: POP
// end ;
38166: LD_VAR 0 1
38170: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38171: LD_INT 0
38173: PPUSH
38174: PPUSH
38175: PPUSH
38176: PPUSH
38177: PPUSH
38178: PPUSH
38179: PPUSH
38180: PPUSH
38181: PPUSH
38182: PPUSH
38183: PPUSH
// if not mc_bases then
38184: LD_EXP 96
38188: NOT
38189: IFFALSE 38193
// exit ;
38191: GO 39280
// for i = 1 to mc_bases do
38193: LD_ADDR_VAR 0 2
38197: PUSH
38198: DOUBLE
38199: LD_INT 1
38201: DEC
38202: ST_TO_ADDR
38203: LD_EXP 96
38207: PUSH
38208: FOR_TO
38209: IFFALSE 39278
// begin tmp := mc_lab [ i ] ;
38211: LD_ADDR_VAR 0 6
38215: PUSH
38216: LD_EXP 129
38220: PUSH
38221: LD_VAR 0 2
38225: ARRAY
38226: ST_TO_ADDR
// if not tmp then
38227: LD_VAR 0 6
38231: NOT
38232: IFFALSE 38236
// continue ;
38234: GO 38208
// idle_lab := 0 ;
38236: LD_ADDR_VAR 0 11
38240: PUSH
38241: LD_INT 0
38243: ST_TO_ADDR
// for j in tmp do
38244: LD_ADDR_VAR 0 3
38248: PUSH
38249: LD_VAR 0 6
38253: PUSH
38254: FOR_IN
38255: IFFALSE 39274
// begin researching := false ;
38257: LD_ADDR_VAR 0 10
38261: PUSH
38262: LD_INT 0
38264: ST_TO_ADDR
// side := GetSide ( j ) ;
38265: LD_ADDR_VAR 0 4
38269: PUSH
38270: LD_VAR 0 3
38274: PPUSH
38275: CALL_OW 255
38279: ST_TO_ADDR
// if not mc_tech [ side ] then
38280: LD_EXP 123
38284: PUSH
38285: LD_VAR 0 4
38289: ARRAY
38290: NOT
38291: IFFALSE 38295
// continue ;
38293: GO 38254
// if BuildingStatus ( j ) = bs_idle then
38295: LD_VAR 0 3
38299: PPUSH
38300: CALL_OW 461
38304: PUSH
38305: LD_INT 2
38307: EQUAL
38308: IFFALSE 38496
// begin if idle_lab and UnitsInside ( j ) < 6 then
38310: LD_VAR 0 11
38314: PUSH
38315: LD_VAR 0 3
38319: PPUSH
38320: CALL_OW 313
38324: PUSH
38325: LD_INT 6
38327: LESS
38328: AND
38329: IFFALSE 38400
// begin tmp2 := UnitsInside ( idle_lab ) ;
38331: LD_ADDR_VAR 0 9
38335: PUSH
38336: LD_VAR 0 11
38340: PPUSH
38341: CALL_OW 313
38345: ST_TO_ADDR
// if tmp2 then
38346: LD_VAR 0 9
38350: IFFALSE 38392
// for x in tmp2 do
38352: LD_ADDR_VAR 0 7
38356: PUSH
38357: LD_VAR 0 9
38361: PUSH
38362: FOR_IN
38363: IFFALSE 38390
// begin ComExitBuilding ( x ) ;
38365: LD_VAR 0 7
38369: PPUSH
38370: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38374: LD_VAR 0 7
38378: PPUSH
38379: LD_VAR 0 3
38383: PPUSH
38384: CALL_OW 180
// end ;
38388: GO 38362
38390: POP
38391: POP
// idle_lab := 0 ;
38392: LD_ADDR_VAR 0 11
38396: PUSH
38397: LD_INT 0
38399: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38400: LD_ADDR_VAR 0 5
38404: PUSH
38405: LD_EXP 123
38409: PUSH
38410: LD_VAR 0 4
38414: ARRAY
38415: PUSH
38416: FOR_IN
38417: IFFALSE 38477
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38419: LD_VAR 0 3
38423: PPUSH
38424: LD_VAR 0 5
38428: PPUSH
38429: CALL_OW 430
38433: PUSH
38434: LD_VAR 0 4
38438: PPUSH
38439: LD_VAR 0 5
38443: PPUSH
38444: CALL 52910 0 2
38448: AND
38449: IFFALSE 38475
// begin researching := true ;
38451: LD_ADDR_VAR 0 10
38455: PUSH
38456: LD_INT 1
38458: ST_TO_ADDR
// ComResearch ( j , t ) ;
38459: LD_VAR 0 3
38463: PPUSH
38464: LD_VAR 0 5
38468: PPUSH
38469: CALL_OW 124
// break ;
38473: GO 38477
// end ;
38475: GO 38416
38477: POP
38478: POP
// if not researching then
38479: LD_VAR 0 10
38483: NOT
38484: IFFALSE 38496
// idle_lab := j ;
38486: LD_ADDR_VAR 0 11
38490: PUSH
38491: LD_VAR 0 3
38495: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38496: LD_VAR 0 3
38500: PPUSH
38501: CALL_OW 461
38505: PUSH
38506: LD_INT 10
38508: EQUAL
38509: IFFALSE 39097
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38511: LD_EXP 125
38515: PUSH
38516: LD_VAR 0 2
38520: ARRAY
38521: NOT
38522: PUSH
38523: LD_EXP 126
38527: PUSH
38528: LD_VAR 0 2
38532: ARRAY
38533: NOT
38534: AND
38535: PUSH
38536: LD_EXP 123
38540: PUSH
38541: LD_VAR 0 4
38545: ARRAY
38546: PUSH
38547: LD_INT 1
38549: GREATER
38550: AND
38551: IFFALSE 38682
// begin ComCancel ( j ) ;
38553: LD_VAR 0 3
38557: PPUSH
38558: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38562: LD_ADDR_EXP 123
38566: PUSH
38567: LD_EXP 123
38571: PPUSH
38572: LD_VAR 0 4
38576: PPUSH
38577: LD_EXP 123
38581: PUSH
38582: LD_VAR 0 4
38586: ARRAY
38587: PPUSH
38588: LD_EXP 123
38592: PUSH
38593: LD_VAR 0 4
38597: ARRAY
38598: PUSH
38599: LD_INT 1
38601: MINUS
38602: PPUSH
38603: LD_EXP 123
38607: PUSH
38608: LD_VAR 0 4
38612: ARRAY
38613: PPUSH
38614: LD_INT 0
38616: PPUSH
38617: CALL 56611 0 4
38621: PPUSH
38622: CALL_OW 1
38626: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38627: LD_ADDR_EXP 123
38631: PUSH
38632: LD_EXP 123
38636: PPUSH
38637: LD_VAR 0 4
38641: PPUSH
38642: LD_EXP 123
38646: PUSH
38647: LD_VAR 0 4
38651: ARRAY
38652: PPUSH
38653: LD_EXP 123
38657: PUSH
38658: LD_VAR 0 4
38662: ARRAY
38663: PPUSH
38664: LD_INT 1
38666: PPUSH
38667: LD_INT 0
38669: PPUSH
38670: CALL 56611 0 4
38674: PPUSH
38675: CALL_OW 1
38679: ST_TO_ADDR
// continue ;
38680: GO 38254
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38682: LD_EXP 125
38686: PUSH
38687: LD_VAR 0 2
38691: ARRAY
38692: PUSH
38693: LD_EXP 126
38697: PUSH
38698: LD_VAR 0 2
38702: ARRAY
38703: NOT
38704: AND
38705: IFFALSE 38832
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38707: LD_ADDR_EXP 126
38711: PUSH
38712: LD_EXP 126
38716: PPUSH
38717: LD_VAR 0 2
38721: PUSH
38722: LD_EXP 126
38726: PUSH
38727: LD_VAR 0 2
38731: ARRAY
38732: PUSH
38733: LD_INT 1
38735: PLUS
38736: PUSH
38737: EMPTY
38738: LIST
38739: LIST
38740: PPUSH
38741: LD_EXP 125
38745: PUSH
38746: LD_VAR 0 2
38750: ARRAY
38751: PUSH
38752: LD_INT 1
38754: ARRAY
38755: PPUSH
38756: CALL 57193 0 3
38760: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38761: LD_EXP 125
38765: PUSH
38766: LD_VAR 0 2
38770: ARRAY
38771: PUSH
38772: LD_INT 1
38774: ARRAY
38775: PPUSH
38776: LD_INT 112
38778: PPUSH
38779: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38783: LD_ADDR_VAR 0 9
38787: PUSH
38788: LD_EXP 125
38792: PUSH
38793: LD_VAR 0 2
38797: ARRAY
38798: PPUSH
38799: LD_INT 1
38801: PPUSH
38802: CALL_OW 3
38806: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38807: LD_ADDR_EXP 125
38811: PUSH
38812: LD_EXP 125
38816: PPUSH
38817: LD_VAR 0 2
38821: PPUSH
38822: LD_VAR 0 9
38826: PPUSH
38827: CALL_OW 1
38831: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38832: LD_EXP 125
38836: PUSH
38837: LD_VAR 0 2
38841: ARRAY
38842: PUSH
38843: LD_EXP 126
38847: PUSH
38848: LD_VAR 0 2
38852: ARRAY
38853: AND
38854: PUSH
38855: LD_EXP 126
38859: PUSH
38860: LD_VAR 0 2
38864: ARRAY
38865: PUSH
38866: LD_INT 1
38868: ARRAY
38869: PPUSH
38870: CALL_OW 310
38874: NOT
38875: AND
38876: PUSH
38877: LD_VAR 0 3
38881: PPUSH
38882: CALL_OW 313
38886: PUSH
38887: LD_INT 6
38889: EQUAL
38890: AND
38891: IFFALSE 38947
// begin tmp2 := UnitsInside ( j ) ;
38893: LD_ADDR_VAR 0 9
38897: PUSH
38898: LD_VAR 0 3
38902: PPUSH
38903: CALL_OW 313
38907: ST_TO_ADDR
// if tmp2 = 6 then
38908: LD_VAR 0 9
38912: PUSH
38913: LD_INT 6
38915: EQUAL
38916: IFFALSE 38947
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38918: LD_VAR 0 9
38922: PUSH
38923: LD_INT 1
38925: ARRAY
38926: PPUSH
38927: LD_INT 112
38929: PPUSH
38930: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38934: LD_VAR 0 9
38938: PUSH
38939: LD_INT 1
38941: ARRAY
38942: PPUSH
38943: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38947: LD_EXP 126
38951: PUSH
38952: LD_VAR 0 2
38956: ARRAY
38957: PUSH
38958: LD_EXP 126
38962: PUSH
38963: LD_VAR 0 2
38967: ARRAY
38968: PUSH
38969: LD_INT 1
38971: ARRAY
38972: PPUSH
38973: CALL_OW 314
38977: NOT
38978: AND
38979: PUSH
38980: LD_EXP 126
38984: PUSH
38985: LD_VAR 0 2
38989: ARRAY
38990: PUSH
38991: LD_INT 1
38993: ARRAY
38994: PPUSH
38995: CALL_OW 310
38999: NOT
39000: AND
39001: IFFALSE 39027
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
39003: LD_EXP 126
39007: PUSH
39008: LD_VAR 0 2
39012: ARRAY
39013: PUSH
39014: LD_INT 1
39016: ARRAY
39017: PPUSH
39018: LD_VAR 0 3
39022: PPUSH
39023: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
39027: LD_EXP 126
39031: PUSH
39032: LD_VAR 0 2
39036: ARRAY
39037: PUSH
39038: LD_INT 1
39040: ARRAY
39041: PPUSH
39042: CALL_OW 310
39046: PUSH
39047: LD_EXP 126
39051: PUSH
39052: LD_VAR 0 2
39056: ARRAY
39057: PUSH
39058: LD_INT 1
39060: ARRAY
39061: PPUSH
39062: CALL_OW 310
39066: PPUSH
39067: CALL_OW 461
39071: PUSH
39072: LD_INT 3
39074: NONEQUAL
39075: AND
39076: IFFALSE 39097
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39078: LD_EXP 126
39082: PUSH
39083: LD_VAR 0 2
39087: ARRAY
39088: PUSH
39089: LD_INT 1
39091: ARRAY
39092: PPUSH
39093: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39097: LD_VAR 0 3
39101: PPUSH
39102: CALL_OW 461
39106: PUSH
39107: LD_INT 6
39109: EQUAL
39110: PUSH
39111: LD_VAR 0 6
39115: PUSH
39116: LD_INT 1
39118: GREATER
39119: AND
39120: IFFALSE 39272
// begin sci := [ ] ;
39122: LD_ADDR_VAR 0 8
39126: PUSH
39127: EMPTY
39128: ST_TO_ADDR
// for x in ( tmp diff j ) do
39129: LD_ADDR_VAR 0 7
39133: PUSH
39134: LD_VAR 0 6
39138: PUSH
39139: LD_VAR 0 3
39143: DIFF
39144: PUSH
39145: FOR_IN
39146: IFFALSE 39198
// begin if sci = 6 then
39148: LD_VAR 0 8
39152: PUSH
39153: LD_INT 6
39155: EQUAL
39156: IFFALSE 39160
// break ;
39158: GO 39198
// if BuildingStatus ( x ) = bs_idle then
39160: LD_VAR 0 7
39164: PPUSH
39165: CALL_OW 461
39169: PUSH
39170: LD_INT 2
39172: EQUAL
39173: IFFALSE 39196
// sci := sci ^ UnitsInside ( x ) ;
39175: LD_ADDR_VAR 0 8
39179: PUSH
39180: LD_VAR 0 8
39184: PUSH
39185: LD_VAR 0 7
39189: PPUSH
39190: CALL_OW 313
39194: ADD
39195: ST_TO_ADDR
// end ;
39196: GO 39145
39198: POP
39199: POP
// if not sci then
39200: LD_VAR 0 8
39204: NOT
39205: IFFALSE 39209
// continue ;
39207: GO 38254
// for x in sci do
39209: LD_ADDR_VAR 0 7
39213: PUSH
39214: LD_VAR 0 8
39218: PUSH
39219: FOR_IN
39220: IFFALSE 39270
// if IsInUnit ( x ) and not HasTask ( x ) then
39222: LD_VAR 0 7
39226: PPUSH
39227: CALL_OW 310
39231: PUSH
39232: LD_VAR 0 7
39236: PPUSH
39237: CALL_OW 314
39241: NOT
39242: AND
39243: IFFALSE 39268
// begin ComExitBuilding ( x ) ;
39245: LD_VAR 0 7
39249: PPUSH
39250: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39254: LD_VAR 0 7
39258: PPUSH
39259: LD_VAR 0 3
39263: PPUSH
39264: CALL_OW 180
// end ;
39268: GO 39219
39270: POP
39271: POP
// end ; end ;
39272: GO 38254
39274: POP
39275: POP
// end ;
39276: GO 38208
39278: POP
39279: POP
// end ;
39280: LD_VAR 0 1
39284: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39285: LD_INT 0
39287: PPUSH
39288: PPUSH
// if not mc_bases then
39289: LD_EXP 96
39293: NOT
39294: IFFALSE 39298
// exit ;
39296: GO 39379
// for i = 1 to mc_bases do
39298: LD_ADDR_VAR 0 2
39302: PUSH
39303: DOUBLE
39304: LD_INT 1
39306: DEC
39307: ST_TO_ADDR
39308: LD_EXP 96
39312: PUSH
39313: FOR_TO
39314: IFFALSE 39377
// if mc_mines [ i ] and mc_miners [ i ] then
39316: LD_EXP 109
39320: PUSH
39321: LD_VAR 0 2
39325: ARRAY
39326: PUSH
39327: LD_EXP 110
39331: PUSH
39332: LD_VAR 0 2
39336: ARRAY
39337: AND
39338: IFFALSE 39375
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39340: LD_EXP 110
39344: PUSH
39345: LD_VAR 0 2
39349: ARRAY
39350: PUSH
39351: LD_INT 1
39353: ARRAY
39354: PPUSH
39355: CALL_OW 255
39359: PPUSH
39360: LD_EXP 109
39364: PUSH
39365: LD_VAR 0 2
39369: ARRAY
39370: PPUSH
39371: CALL 53993 0 2
39375: GO 39313
39377: POP
39378: POP
// end ;
39379: LD_VAR 0 1
39383: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39384: LD_INT 0
39386: PPUSH
39387: PPUSH
39388: PPUSH
39389: PPUSH
39390: PPUSH
39391: PPUSH
39392: PPUSH
39393: PPUSH
// if not mc_bases or not mc_parking then
39394: LD_EXP 96
39398: NOT
39399: PUSH
39400: LD_EXP 120
39404: NOT
39405: OR
39406: IFFALSE 39410
// exit ;
39408: GO 40120
// for i = 1 to mc_bases do
39410: LD_ADDR_VAR 0 2
39414: PUSH
39415: DOUBLE
39416: LD_INT 1
39418: DEC
39419: ST_TO_ADDR
39420: LD_EXP 96
39424: PUSH
39425: FOR_TO
39426: IFFALSE 40118
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39428: LD_EXP 96
39432: PUSH
39433: LD_VAR 0 2
39437: ARRAY
39438: NOT
39439: PUSH
39440: LD_EXP 120
39444: PUSH
39445: LD_VAR 0 2
39449: ARRAY
39450: NOT
39451: OR
39452: IFFALSE 39456
// continue ;
39454: GO 39425
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39456: LD_ADDR_VAR 0 5
39460: PUSH
39461: LD_EXP 96
39465: PUSH
39466: LD_VAR 0 2
39470: ARRAY
39471: PUSH
39472: LD_INT 1
39474: ARRAY
39475: PPUSH
39476: CALL_OW 255
39480: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39481: LD_ADDR_VAR 0 6
39485: PUSH
39486: LD_EXP 96
39490: PUSH
39491: LD_VAR 0 2
39495: ARRAY
39496: PPUSH
39497: LD_INT 30
39499: PUSH
39500: LD_INT 3
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PPUSH
39507: CALL_OW 72
39511: ST_TO_ADDR
// if not fac then
39512: LD_VAR 0 6
39516: NOT
39517: IFFALSE 39568
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39519: LD_ADDR_VAR 0 6
39523: PUSH
39524: LD_EXP 96
39528: PUSH
39529: LD_VAR 0 2
39533: ARRAY
39534: PPUSH
39535: LD_INT 2
39537: PUSH
39538: LD_INT 30
39540: PUSH
39541: LD_INT 0
39543: PUSH
39544: EMPTY
39545: LIST
39546: LIST
39547: PUSH
39548: LD_INT 30
39550: PUSH
39551: LD_INT 1
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: LIST
39562: PPUSH
39563: CALL_OW 72
39567: ST_TO_ADDR
// if not fac then
39568: LD_VAR 0 6
39572: NOT
39573: IFFALSE 39577
// continue ;
39575: GO 39425
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39577: LD_ADDR_VAR 0 7
39581: PUSH
39582: LD_EXP 120
39586: PUSH
39587: LD_VAR 0 2
39591: ARRAY
39592: PPUSH
39593: LD_INT 22
39595: PUSH
39596: LD_VAR 0 5
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 21
39607: PUSH
39608: LD_INT 2
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 3
39617: PUSH
39618: LD_INT 24
39620: PUSH
39621: LD_INT 1000
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: LIST
39636: PPUSH
39637: CALL_OW 70
39641: ST_TO_ADDR
// for j in fac do
39642: LD_ADDR_VAR 0 3
39646: PUSH
39647: LD_VAR 0 6
39651: PUSH
39652: FOR_IN
39653: IFFALSE 39734
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39655: LD_ADDR_VAR 0 7
39659: PUSH
39660: LD_VAR 0 7
39664: PUSH
39665: LD_INT 22
39667: PUSH
39668: LD_VAR 0 5
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 91
39679: PUSH
39680: LD_VAR 0 3
39684: PUSH
39685: LD_INT 15
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: LIST
39692: PUSH
39693: LD_INT 21
39695: PUSH
39696: LD_INT 2
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 3
39705: PUSH
39706: LD_INT 24
39708: PUSH
39709: LD_INT 1000
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: EMPTY
39717: LIST
39718: LIST
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: PPUSH
39726: CALL_OW 69
39730: UNION
39731: ST_TO_ADDR
39732: GO 39652
39734: POP
39735: POP
// if not vehs then
39736: LD_VAR 0 7
39740: NOT
39741: IFFALSE 39767
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39743: LD_ADDR_EXP 108
39747: PUSH
39748: LD_EXP 108
39752: PPUSH
39753: LD_VAR 0 2
39757: PPUSH
39758: EMPTY
39759: PPUSH
39760: CALL_OW 1
39764: ST_TO_ADDR
// continue ;
39765: GO 39425
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39767: LD_ADDR_VAR 0 8
39771: PUSH
39772: LD_EXP 96
39776: PUSH
39777: LD_VAR 0 2
39781: ARRAY
39782: PPUSH
39783: LD_INT 30
39785: PUSH
39786: LD_INT 3
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PPUSH
39793: CALL_OW 72
39797: ST_TO_ADDR
// if tmp then
39798: LD_VAR 0 8
39802: IFFALSE 39905
// begin for j in tmp do
39804: LD_ADDR_VAR 0 3
39808: PUSH
39809: LD_VAR 0 8
39813: PUSH
39814: FOR_IN
39815: IFFALSE 39903
// for k in UnitsInside ( j ) do
39817: LD_ADDR_VAR 0 4
39821: PUSH
39822: LD_VAR 0 3
39826: PPUSH
39827: CALL_OW 313
39831: PUSH
39832: FOR_IN
39833: IFFALSE 39899
// if k then
39835: LD_VAR 0 4
39839: IFFALSE 39897
// if not k in mc_repair_vehicle [ i ] then
39841: LD_VAR 0 4
39845: PUSH
39846: LD_EXP 108
39850: PUSH
39851: LD_VAR 0 2
39855: ARRAY
39856: IN
39857: NOT
39858: IFFALSE 39897
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39860: LD_ADDR_EXP 108
39864: PUSH
39865: LD_EXP 108
39869: PPUSH
39870: LD_VAR 0 2
39874: PPUSH
39875: LD_EXP 108
39879: PUSH
39880: LD_VAR 0 2
39884: ARRAY
39885: PUSH
39886: LD_VAR 0 4
39890: UNION
39891: PPUSH
39892: CALL_OW 1
39896: ST_TO_ADDR
39897: GO 39832
39899: POP
39900: POP
39901: GO 39814
39903: POP
39904: POP
// end ; if not mc_repair_vehicle [ i ] then
39905: LD_EXP 108
39909: PUSH
39910: LD_VAR 0 2
39914: ARRAY
39915: NOT
39916: IFFALSE 39920
// continue ;
39918: GO 39425
// for j in mc_repair_vehicle [ i ] do
39920: LD_ADDR_VAR 0 3
39924: PUSH
39925: LD_EXP 108
39929: PUSH
39930: LD_VAR 0 2
39934: ARRAY
39935: PUSH
39936: FOR_IN
39937: IFFALSE 40114
// begin if GetClass ( j ) <> 3 then
39939: LD_VAR 0 3
39943: PPUSH
39944: CALL_OW 257
39948: PUSH
39949: LD_INT 3
39951: NONEQUAL
39952: IFFALSE 39993
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39954: LD_ADDR_EXP 108
39958: PUSH
39959: LD_EXP 108
39963: PPUSH
39964: LD_VAR 0 2
39968: PPUSH
39969: LD_EXP 108
39973: PUSH
39974: LD_VAR 0 2
39978: ARRAY
39979: PUSH
39980: LD_VAR 0 3
39984: DIFF
39985: PPUSH
39986: CALL_OW 1
39990: ST_TO_ADDR
// continue ;
39991: GO 39936
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39993: LD_VAR 0 3
39997: PPUSH
39998: CALL_OW 311
40002: NOT
40003: PUSH
40004: LD_VAR 0 3
40008: PUSH
40009: LD_EXP 99
40013: PUSH
40014: LD_VAR 0 2
40018: ARRAY
40019: PUSH
40020: LD_INT 1
40022: ARRAY
40023: IN
40024: NOT
40025: AND
40026: PUSH
40027: LD_VAR 0 3
40031: PUSH
40032: LD_EXP 99
40036: PUSH
40037: LD_VAR 0 2
40041: ARRAY
40042: PUSH
40043: LD_INT 2
40045: ARRAY
40046: IN
40047: NOT
40048: AND
40049: IFFALSE 40112
// begin if IsInUnit ( j ) then
40051: LD_VAR 0 3
40055: PPUSH
40056: CALL_OW 310
40060: IFFALSE 40073
// ComExitBuilding ( j ) else
40062: LD_VAR 0 3
40066: PPUSH
40067: CALL_OW 122
40071: GO 40112
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40073: LD_VAR 0 3
40077: PPUSH
40078: LD_VAR 0 7
40082: PUSH
40083: LD_INT 1
40085: ARRAY
40086: PPUSH
40087: CALL 90945 0 2
40091: NOT
40092: IFFALSE 40112
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40094: LD_VAR 0 3
40098: PPUSH
40099: LD_VAR 0 7
40103: PUSH
40104: LD_INT 1
40106: ARRAY
40107: PPUSH
40108: CALL_OW 129
// end ; end ;
40112: GO 39936
40114: POP
40115: POP
// end ;
40116: GO 39425
40118: POP
40119: POP
// end ;
40120: LD_VAR 0 1
40124: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40125: LD_INT 0
40127: PPUSH
40128: PPUSH
40129: PPUSH
40130: PPUSH
40131: PPUSH
40132: PPUSH
40133: PPUSH
40134: PPUSH
40135: PPUSH
40136: PPUSH
40137: PPUSH
// if not mc_bases then
40138: LD_EXP 96
40142: NOT
40143: IFFALSE 40147
// exit ;
40145: GO 40949
// for i = 1 to mc_bases do
40147: LD_ADDR_VAR 0 2
40151: PUSH
40152: DOUBLE
40153: LD_INT 1
40155: DEC
40156: ST_TO_ADDR
40157: LD_EXP 96
40161: PUSH
40162: FOR_TO
40163: IFFALSE 40947
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40165: LD_EXP 124
40169: PUSH
40170: LD_VAR 0 2
40174: ARRAY
40175: NOT
40176: PUSH
40177: LD_EXP 99
40181: PUSH
40182: LD_VAR 0 2
40186: ARRAY
40187: PUSH
40188: LD_INT 1
40190: ARRAY
40191: OR
40192: PUSH
40193: LD_EXP 99
40197: PUSH
40198: LD_VAR 0 2
40202: ARRAY
40203: PUSH
40204: LD_INT 2
40206: ARRAY
40207: OR
40208: PUSH
40209: LD_EXP 122
40213: PUSH
40214: LD_VAR 0 2
40218: ARRAY
40219: PPUSH
40220: LD_INT 1
40222: PPUSH
40223: CALL_OW 325
40227: NOT
40228: OR
40229: PUSH
40230: LD_EXP 119
40234: PUSH
40235: LD_VAR 0 2
40239: ARRAY
40240: OR
40241: IFFALSE 40245
// continue ;
40243: GO 40162
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40245: LD_ADDR_VAR 0 8
40249: PUSH
40250: LD_EXP 96
40254: PUSH
40255: LD_VAR 0 2
40259: ARRAY
40260: PPUSH
40261: LD_INT 25
40263: PUSH
40264: LD_INT 4
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 50
40273: PUSH
40274: EMPTY
40275: LIST
40276: PUSH
40277: LD_INT 3
40279: PUSH
40280: LD_INT 60
40282: PUSH
40283: EMPTY
40284: LIST
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: LIST
40294: PPUSH
40295: CALL_OW 72
40299: PUSH
40300: LD_EXP 100
40304: PUSH
40305: LD_VAR 0 2
40309: ARRAY
40310: DIFF
40311: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40312: LD_ADDR_VAR 0 9
40316: PUSH
40317: LD_EXP 96
40321: PUSH
40322: LD_VAR 0 2
40326: ARRAY
40327: PPUSH
40328: LD_INT 2
40330: PUSH
40331: LD_INT 30
40333: PUSH
40334: LD_INT 0
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 30
40343: PUSH
40344: LD_INT 1
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: LIST
40355: PPUSH
40356: CALL_OW 72
40360: ST_TO_ADDR
// if not tmp or not dep then
40361: LD_VAR 0 8
40365: NOT
40366: PUSH
40367: LD_VAR 0 9
40371: NOT
40372: OR
40373: IFFALSE 40377
// continue ;
40375: GO 40162
// side := GetSide ( tmp [ 1 ] ) ;
40377: LD_ADDR_VAR 0 11
40381: PUSH
40382: LD_VAR 0 8
40386: PUSH
40387: LD_INT 1
40389: ARRAY
40390: PPUSH
40391: CALL_OW 255
40395: ST_TO_ADDR
// dep := dep [ 1 ] ;
40396: LD_ADDR_VAR 0 9
40400: PUSH
40401: LD_VAR 0 9
40405: PUSH
40406: LD_INT 1
40408: ARRAY
40409: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40410: LD_ADDR_VAR 0 7
40414: PUSH
40415: LD_EXP 124
40419: PUSH
40420: LD_VAR 0 2
40424: ARRAY
40425: PPUSH
40426: LD_INT 22
40428: PUSH
40429: LD_INT 0
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 25
40438: PUSH
40439: LD_INT 12
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PPUSH
40450: CALL_OW 70
40454: PUSH
40455: LD_INT 22
40457: PUSH
40458: LD_INT 0
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 25
40467: PUSH
40468: LD_INT 12
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: LD_INT 91
40477: PUSH
40478: LD_VAR 0 9
40482: PUSH
40483: LD_INT 20
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: LIST
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: LIST
40495: PPUSH
40496: CALL_OW 69
40500: UNION
40501: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40502: LD_ADDR_VAR 0 10
40506: PUSH
40507: LD_EXP 124
40511: PUSH
40512: LD_VAR 0 2
40516: ARRAY
40517: PPUSH
40518: LD_INT 81
40520: PUSH
40521: LD_VAR 0 11
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: PPUSH
40530: CALL_OW 70
40534: ST_TO_ADDR
// if not apes or danger_at_area then
40535: LD_VAR 0 7
40539: NOT
40540: PUSH
40541: LD_VAR 0 10
40545: OR
40546: IFFALSE 40596
// begin if mc_taming [ i ] then
40548: LD_EXP 127
40552: PUSH
40553: LD_VAR 0 2
40557: ARRAY
40558: IFFALSE 40594
// begin MC_Reset ( i , 121 ) ;
40560: LD_VAR 0 2
40564: PPUSH
40565: LD_INT 121
40567: PPUSH
40568: CALL 25582 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40572: LD_ADDR_EXP 127
40576: PUSH
40577: LD_EXP 127
40581: PPUSH
40582: LD_VAR 0 2
40586: PPUSH
40587: EMPTY
40588: PPUSH
40589: CALL_OW 1
40593: ST_TO_ADDR
// end ; continue ;
40594: GO 40162
// end ; for j in tmp do
40596: LD_ADDR_VAR 0 3
40600: PUSH
40601: LD_VAR 0 8
40605: PUSH
40606: FOR_IN
40607: IFFALSE 40943
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40609: LD_VAR 0 3
40613: PUSH
40614: LD_EXP 127
40618: PUSH
40619: LD_VAR 0 2
40623: ARRAY
40624: IN
40625: NOT
40626: PUSH
40627: LD_EXP 127
40631: PUSH
40632: LD_VAR 0 2
40636: ARRAY
40637: PUSH
40638: LD_INT 3
40640: LESS
40641: AND
40642: IFFALSE 40700
// begin SetTag ( j , 121 ) ;
40644: LD_VAR 0 3
40648: PPUSH
40649: LD_INT 121
40651: PPUSH
40652: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40656: LD_ADDR_EXP 127
40660: PUSH
40661: LD_EXP 127
40665: PPUSH
40666: LD_VAR 0 2
40670: PUSH
40671: LD_EXP 127
40675: PUSH
40676: LD_VAR 0 2
40680: ARRAY
40681: PUSH
40682: LD_INT 1
40684: PLUS
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PPUSH
40690: LD_VAR 0 3
40694: PPUSH
40695: CALL 57193 0 3
40699: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40700: LD_VAR 0 3
40704: PUSH
40705: LD_EXP 127
40709: PUSH
40710: LD_VAR 0 2
40714: ARRAY
40715: IN
40716: IFFALSE 40941
// begin if GetClass ( j ) <> 4 then
40718: LD_VAR 0 3
40722: PPUSH
40723: CALL_OW 257
40727: PUSH
40728: LD_INT 4
40730: NONEQUAL
40731: IFFALSE 40784
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40733: LD_ADDR_EXP 127
40737: PUSH
40738: LD_EXP 127
40742: PPUSH
40743: LD_VAR 0 2
40747: PPUSH
40748: LD_EXP 127
40752: PUSH
40753: LD_VAR 0 2
40757: ARRAY
40758: PUSH
40759: LD_VAR 0 3
40763: DIFF
40764: PPUSH
40765: CALL_OW 1
40769: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40770: LD_VAR 0 3
40774: PPUSH
40775: LD_INT 0
40777: PPUSH
40778: CALL_OW 109
// continue ;
40782: GO 40606
// end ; if IsInUnit ( j ) then
40784: LD_VAR 0 3
40788: PPUSH
40789: CALL_OW 310
40793: IFFALSE 40804
// ComExitBuilding ( j ) ;
40795: LD_VAR 0 3
40799: PPUSH
40800: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40804: LD_ADDR_VAR 0 6
40808: PUSH
40809: LD_VAR 0 7
40813: PPUSH
40814: LD_VAR 0 3
40818: PPUSH
40819: CALL_OW 74
40823: ST_TO_ADDR
// if not ape then
40824: LD_VAR 0 6
40828: NOT
40829: IFFALSE 40833
// break ;
40831: GO 40943
// x := GetX ( ape ) ;
40833: LD_ADDR_VAR 0 4
40837: PUSH
40838: LD_VAR 0 6
40842: PPUSH
40843: CALL_OW 250
40847: ST_TO_ADDR
// y := GetY ( ape ) ;
40848: LD_ADDR_VAR 0 5
40852: PUSH
40853: LD_VAR 0 6
40857: PPUSH
40858: CALL_OW 251
40862: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40863: LD_VAR 0 4
40867: PPUSH
40868: LD_VAR 0 5
40872: PPUSH
40873: CALL_OW 488
40877: NOT
40878: PUSH
40879: LD_VAR 0 11
40883: PPUSH
40884: LD_VAR 0 4
40888: PPUSH
40889: LD_VAR 0 5
40893: PPUSH
40894: LD_INT 20
40896: PPUSH
40897: CALL 58089 0 4
40901: PUSH
40902: LD_INT 4
40904: ARRAY
40905: OR
40906: IFFALSE 40910
// break ;
40908: GO 40943
// if not HasTask ( j ) then
40910: LD_VAR 0 3
40914: PPUSH
40915: CALL_OW 314
40919: NOT
40920: IFFALSE 40941
// ComTameXY ( j , x , y ) ;
40922: LD_VAR 0 3
40926: PPUSH
40927: LD_VAR 0 4
40931: PPUSH
40932: LD_VAR 0 5
40936: PPUSH
40937: CALL_OW 131
// end ; end ;
40941: GO 40606
40943: POP
40944: POP
// end ;
40945: GO 40162
40947: POP
40948: POP
// end ;
40949: LD_VAR 0 1
40953: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40954: LD_INT 0
40956: PPUSH
40957: PPUSH
40958: PPUSH
40959: PPUSH
40960: PPUSH
40961: PPUSH
40962: PPUSH
40963: PPUSH
// if not mc_bases then
40964: LD_EXP 96
40968: NOT
40969: IFFALSE 40973
// exit ;
40971: GO 41599
// for i = 1 to mc_bases do
40973: LD_ADDR_VAR 0 2
40977: PUSH
40978: DOUBLE
40979: LD_INT 1
40981: DEC
40982: ST_TO_ADDR
40983: LD_EXP 96
40987: PUSH
40988: FOR_TO
40989: IFFALSE 41597
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40991: LD_EXP 125
40995: PUSH
40996: LD_VAR 0 2
41000: ARRAY
41001: NOT
41002: PUSH
41003: LD_EXP 125
41007: PUSH
41008: LD_VAR 0 2
41012: ARRAY
41013: PPUSH
41014: LD_INT 25
41016: PUSH
41017: LD_INT 12
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PPUSH
41024: CALL_OW 72
41028: NOT
41029: OR
41030: IFFALSE 41034
// continue ;
41032: GO 40988
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41034: LD_ADDR_VAR 0 5
41038: PUSH
41039: LD_EXP 125
41043: PUSH
41044: LD_VAR 0 2
41048: ARRAY
41049: PUSH
41050: LD_INT 1
41052: ARRAY
41053: PPUSH
41054: CALL_OW 255
41058: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41059: LD_VAR 0 5
41063: PPUSH
41064: LD_INT 2
41066: PPUSH
41067: CALL_OW 325
41071: IFFALSE 41324
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41073: LD_ADDR_VAR 0 4
41077: PUSH
41078: LD_EXP 125
41082: PUSH
41083: LD_VAR 0 2
41087: ARRAY
41088: PPUSH
41089: LD_INT 25
41091: PUSH
41092: LD_INT 16
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PPUSH
41099: CALL_OW 72
41103: ST_TO_ADDR
// if tmp < 6 then
41104: LD_VAR 0 4
41108: PUSH
41109: LD_INT 6
41111: LESS
41112: IFFALSE 41324
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41114: LD_ADDR_VAR 0 6
41118: PUSH
41119: LD_EXP 96
41123: PUSH
41124: LD_VAR 0 2
41128: ARRAY
41129: PPUSH
41130: LD_INT 2
41132: PUSH
41133: LD_INT 30
41135: PUSH
41136: LD_INT 0
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 30
41145: PUSH
41146: LD_INT 1
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: LIST
41157: PPUSH
41158: CALL_OW 72
41162: ST_TO_ADDR
// if depot then
41163: LD_VAR 0 6
41167: IFFALSE 41324
// begin selected := 0 ;
41169: LD_ADDR_VAR 0 7
41173: PUSH
41174: LD_INT 0
41176: ST_TO_ADDR
// for j in depot do
41177: LD_ADDR_VAR 0 3
41181: PUSH
41182: LD_VAR 0 6
41186: PUSH
41187: FOR_IN
41188: IFFALSE 41219
// begin if UnitsInside ( j ) < 6 then
41190: LD_VAR 0 3
41194: PPUSH
41195: CALL_OW 313
41199: PUSH
41200: LD_INT 6
41202: LESS
41203: IFFALSE 41217
// begin selected := j ;
41205: LD_ADDR_VAR 0 7
41209: PUSH
41210: LD_VAR 0 3
41214: ST_TO_ADDR
// break ;
41215: GO 41219
// end ; end ;
41217: GO 41187
41219: POP
41220: POP
// if selected then
41221: LD_VAR 0 7
41225: IFFALSE 41324
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41227: LD_ADDR_VAR 0 3
41231: PUSH
41232: LD_EXP 125
41236: PUSH
41237: LD_VAR 0 2
41241: ARRAY
41242: PPUSH
41243: LD_INT 25
41245: PUSH
41246: LD_INT 12
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PPUSH
41253: CALL_OW 72
41257: PUSH
41258: FOR_IN
41259: IFFALSE 41322
// if not HasTask ( j ) then
41261: LD_VAR 0 3
41265: PPUSH
41266: CALL_OW 314
41270: NOT
41271: IFFALSE 41320
// begin if not IsInUnit ( j ) then
41273: LD_VAR 0 3
41277: PPUSH
41278: CALL_OW 310
41282: NOT
41283: IFFALSE 41299
// ComEnterUnit ( j , selected ) ;
41285: LD_VAR 0 3
41289: PPUSH
41290: LD_VAR 0 7
41294: PPUSH
41295: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41299: LD_VAR 0 3
41303: PPUSH
41304: LD_INT 16
41306: PPUSH
41307: CALL_OW 183
// AddComExitBuilding ( j ) ;
41311: LD_VAR 0 3
41315: PPUSH
41316: CALL_OW 182
// end ;
41320: GO 41258
41322: POP
41323: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41324: LD_VAR 0 5
41328: PPUSH
41329: LD_INT 11
41331: PPUSH
41332: CALL_OW 325
41336: IFFALSE 41595
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41338: LD_ADDR_VAR 0 4
41342: PUSH
41343: LD_EXP 125
41347: PUSH
41348: LD_VAR 0 2
41352: ARRAY
41353: PPUSH
41354: LD_INT 25
41356: PUSH
41357: LD_INT 16
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PPUSH
41364: CALL_OW 72
41368: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41369: LD_VAR 0 4
41373: PUSH
41374: LD_INT 6
41376: GREATEREQUAL
41377: PUSH
41378: LD_VAR 0 5
41382: PPUSH
41383: LD_INT 2
41385: PPUSH
41386: CALL_OW 325
41390: NOT
41391: OR
41392: IFFALSE 41595
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41394: LD_ADDR_VAR 0 8
41398: PUSH
41399: LD_EXP 96
41403: PUSH
41404: LD_VAR 0 2
41408: ARRAY
41409: PPUSH
41410: LD_INT 2
41412: PUSH
41413: LD_INT 30
41415: PUSH
41416: LD_INT 4
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: PUSH
41423: LD_INT 30
41425: PUSH
41426: LD_INT 5
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: EMPTY
41434: LIST
41435: LIST
41436: LIST
41437: PPUSH
41438: CALL_OW 72
41442: ST_TO_ADDR
// if barracks then
41443: LD_VAR 0 8
41447: IFFALSE 41595
// begin selected := 0 ;
41449: LD_ADDR_VAR 0 7
41453: PUSH
41454: LD_INT 0
41456: ST_TO_ADDR
// for j in barracks do
41457: LD_ADDR_VAR 0 3
41461: PUSH
41462: LD_VAR 0 8
41466: PUSH
41467: FOR_IN
41468: IFFALSE 41499
// begin if UnitsInside ( j ) < 6 then
41470: LD_VAR 0 3
41474: PPUSH
41475: CALL_OW 313
41479: PUSH
41480: LD_INT 6
41482: LESS
41483: IFFALSE 41497
// begin selected := j ;
41485: LD_ADDR_VAR 0 7
41489: PUSH
41490: LD_VAR 0 3
41494: ST_TO_ADDR
// break ;
41495: GO 41499
// end ; end ;
41497: GO 41467
41499: POP
41500: POP
// if selected then
41501: LD_VAR 0 7
41505: IFFALSE 41595
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41507: LD_ADDR_VAR 0 3
41511: PUSH
41512: LD_EXP 125
41516: PUSH
41517: LD_VAR 0 2
41521: ARRAY
41522: PPUSH
41523: LD_INT 25
41525: PUSH
41526: LD_INT 12
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PPUSH
41533: CALL_OW 72
41537: PUSH
41538: FOR_IN
41539: IFFALSE 41593
// if not IsInUnit ( j ) and not HasTask ( j ) then
41541: LD_VAR 0 3
41545: PPUSH
41546: CALL_OW 310
41550: NOT
41551: PUSH
41552: LD_VAR 0 3
41556: PPUSH
41557: CALL_OW 314
41561: NOT
41562: AND
41563: IFFALSE 41591
// begin ComEnterUnit ( j , selected ) ;
41565: LD_VAR 0 3
41569: PPUSH
41570: LD_VAR 0 7
41574: PPUSH
41575: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41579: LD_VAR 0 3
41583: PPUSH
41584: LD_INT 15
41586: PPUSH
41587: CALL_OW 183
// end ;
41591: GO 41538
41593: POP
41594: POP
// end ; end ; end ; end ; end ;
41595: GO 40988
41597: POP
41598: POP
// end ;
41599: LD_VAR 0 1
41603: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41604: LD_INT 0
41606: PPUSH
41607: PPUSH
41608: PPUSH
41609: PPUSH
// if not mc_bases then
41610: LD_EXP 96
41614: NOT
41615: IFFALSE 41619
// exit ;
41617: GO 41797
// for i = 1 to mc_bases do
41619: LD_ADDR_VAR 0 2
41623: PUSH
41624: DOUBLE
41625: LD_INT 1
41627: DEC
41628: ST_TO_ADDR
41629: LD_EXP 96
41633: PUSH
41634: FOR_TO
41635: IFFALSE 41795
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41637: LD_ADDR_VAR 0 4
41641: PUSH
41642: LD_EXP 96
41646: PUSH
41647: LD_VAR 0 2
41651: ARRAY
41652: PPUSH
41653: LD_INT 25
41655: PUSH
41656: LD_INT 9
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PPUSH
41663: CALL_OW 72
41667: ST_TO_ADDR
// if not tmp then
41668: LD_VAR 0 4
41672: NOT
41673: IFFALSE 41677
// continue ;
41675: GO 41634
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41677: LD_EXP 122
41681: PUSH
41682: LD_VAR 0 2
41686: ARRAY
41687: PPUSH
41688: LD_INT 29
41690: PPUSH
41691: CALL_OW 325
41695: NOT
41696: PUSH
41697: LD_EXP 122
41701: PUSH
41702: LD_VAR 0 2
41706: ARRAY
41707: PPUSH
41708: LD_INT 28
41710: PPUSH
41711: CALL_OW 325
41715: NOT
41716: AND
41717: IFFALSE 41721
// continue ;
41719: GO 41634
// for j in tmp do
41721: LD_ADDR_VAR 0 3
41725: PUSH
41726: LD_VAR 0 4
41730: PUSH
41731: FOR_IN
41732: IFFALSE 41791
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41734: LD_VAR 0 3
41738: PUSH
41739: LD_EXP 99
41743: PUSH
41744: LD_VAR 0 2
41748: ARRAY
41749: PUSH
41750: LD_INT 1
41752: ARRAY
41753: IN
41754: NOT
41755: PUSH
41756: LD_VAR 0 3
41760: PUSH
41761: LD_EXP 99
41765: PUSH
41766: LD_VAR 0 2
41770: ARRAY
41771: PUSH
41772: LD_INT 2
41774: ARRAY
41775: IN
41776: NOT
41777: AND
41778: IFFALSE 41789
// ComSpaceTimeShoot ( j ) ;
41780: LD_VAR 0 3
41784: PPUSH
41785: CALL 53001 0 1
41789: GO 41731
41791: POP
41792: POP
// end ;
41793: GO 41634
41795: POP
41796: POP
// end ;
41797: LD_VAR 0 1
41801: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41802: LD_INT 0
41804: PPUSH
41805: PPUSH
41806: PPUSH
41807: PPUSH
41808: PPUSH
41809: PPUSH
41810: PPUSH
41811: PPUSH
41812: PPUSH
// if not mc_bases then
41813: LD_EXP 96
41817: NOT
41818: IFFALSE 41822
// exit ;
41820: GO 42444
// for i = 1 to mc_bases do
41822: LD_ADDR_VAR 0 2
41826: PUSH
41827: DOUBLE
41828: LD_INT 1
41830: DEC
41831: ST_TO_ADDR
41832: LD_EXP 96
41836: PUSH
41837: FOR_TO
41838: IFFALSE 42442
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41840: LD_EXP 131
41844: PUSH
41845: LD_VAR 0 2
41849: ARRAY
41850: NOT
41851: PUSH
41852: LD_INT 38
41854: PPUSH
41855: LD_EXP 122
41859: PUSH
41860: LD_VAR 0 2
41864: ARRAY
41865: PPUSH
41866: CALL_OW 321
41870: PUSH
41871: LD_INT 2
41873: NONEQUAL
41874: OR
41875: IFFALSE 41879
// continue ;
41877: GO 41837
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41879: LD_ADDR_VAR 0 8
41883: PUSH
41884: LD_EXP 96
41888: PUSH
41889: LD_VAR 0 2
41893: ARRAY
41894: PPUSH
41895: LD_INT 30
41897: PUSH
41898: LD_INT 34
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PPUSH
41905: CALL_OW 72
41909: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41910: LD_ADDR_VAR 0 9
41914: PUSH
41915: LD_EXP 96
41919: PUSH
41920: LD_VAR 0 2
41924: ARRAY
41925: PPUSH
41926: LD_INT 25
41928: PUSH
41929: LD_INT 4
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PPUSH
41936: CALL_OW 72
41940: PPUSH
41941: LD_INT 0
41943: PPUSH
41944: CALL 86462 0 2
41948: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41949: LD_VAR 0 9
41953: NOT
41954: PUSH
41955: LD_VAR 0 8
41959: NOT
41960: OR
41961: PUSH
41962: LD_EXP 96
41966: PUSH
41967: LD_VAR 0 2
41971: ARRAY
41972: PPUSH
41973: LD_INT 124
41975: PPUSH
41976: CALL 86462 0 2
41980: OR
41981: IFFALSE 41985
// continue ;
41983: GO 41837
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41985: LD_EXP 132
41989: PUSH
41990: LD_VAR 0 2
41994: ARRAY
41995: PUSH
41996: LD_EXP 131
42000: PUSH
42001: LD_VAR 0 2
42005: ARRAY
42006: LESS
42007: PUSH
42008: LD_EXP 132
42012: PUSH
42013: LD_VAR 0 2
42017: ARRAY
42018: PUSH
42019: LD_VAR 0 8
42023: LESS
42024: AND
42025: IFFALSE 42440
// begin tmp := sci [ 1 ] ;
42027: LD_ADDR_VAR 0 7
42031: PUSH
42032: LD_VAR 0 9
42036: PUSH
42037: LD_INT 1
42039: ARRAY
42040: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42041: LD_VAR 0 7
42045: PPUSH
42046: LD_INT 124
42048: PPUSH
42049: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42053: LD_ADDR_VAR 0 3
42057: PUSH
42058: DOUBLE
42059: LD_EXP 131
42063: PUSH
42064: LD_VAR 0 2
42068: ARRAY
42069: INC
42070: ST_TO_ADDR
42071: LD_EXP 131
42075: PUSH
42076: LD_VAR 0 2
42080: ARRAY
42081: PUSH
42082: FOR_DOWNTO
42083: IFFALSE 42426
// begin if IsInUnit ( tmp ) then
42085: LD_VAR 0 7
42089: PPUSH
42090: CALL_OW 310
42094: IFFALSE 42105
// ComExitBuilding ( tmp ) ;
42096: LD_VAR 0 7
42100: PPUSH
42101: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42105: LD_INT 35
42107: PPUSH
42108: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42112: LD_VAR 0 7
42116: PPUSH
42117: CALL_OW 310
42121: NOT
42122: PUSH
42123: LD_VAR 0 7
42127: PPUSH
42128: CALL_OW 314
42132: NOT
42133: AND
42134: IFFALSE 42105
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42136: LD_ADDR_VAR 0 6
42140: PUSH
42141: LD_VAR 0 7
42145: PPUSH
42146: CALL_OW 250
42150: PUSH
42151: LD_VAR 0 7
42155: PPUSH
42156: CALL_OW 251
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42165: LD_INT 35
42167: PPUSH
42168: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42172: LD_ADDR_VAR 0 4
42176: PUSH
42177: LD_EXP 131
42181: PUSH
42182: LD_VAR 0 2
42186: ARRAY
42187: PUSH
42188: LD_VAR 0 3
42192: ARRAY
42193: PUSH
42194: LD_INT 1
42196: ARRAY
42197: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42198: LD_ADDR_VAR 0 5
42202: PUSH
42203: LD_EXP 131
42207: PUSH
42208: LD_VAR 0 2
42212: ARRAY
42213: PUSH
42214: LD_VAR 0 3
42218: ARRAY
42219: PUSH
42220: LD_INT 2
42222: ARRAY
42223: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42224: LD_VAR 0 7
42228: PPUSH
42229: LD_INT 10
42231: PPUSH
42232: CALL 59792 0 2
42236: PUSH
42237: LD_INT 4
42239: ARRAY
42240: IFFALSE 42278
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42242: LD_VAR 0 7
42246: PPUSH
42247: LD_VAR 0 6
42251: PUSH
42252: LD_INT 1
42254: ARRAY
42255: PPUSH
42256: LD_VAR 0 6
42260: PUSH
42261: LD_INT 2
42263: ARRAY
42264: PPUSH
42265: CALL_OW 111
// wait ( 0 0$10 ) ;
42269: LD_INT 350
42271: PPUSH
42272: CALL_OW 67
// end else
42276: GO 42304
// begin ComMoveXY ( tmp , x , y ) ;
42278: LD_VAR 0 7
42282: PPUSH
42283: LD_VAR 0 4
42287: PPUSH
42288: LD_VAR 0 5
42292: PPUSH
42293: CALL_OW 111
// wait ( 0 0$3 ) ;
42297: LD_INT 105
42299: PPUSH
42300: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42304: LD_VAR 0 7
42308: PPUSH
42309: LD_VAR 0 4
42313: PPUSH
42314: LD_VAR 0 5
42318: PPUSH
42319: CALL_OW 307
42323: IFFALSE 42165
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42325: LD_VAR 0 7
42329: PPUSH
42330: LD_VAR 0 4
42334: PPUSH
42335: LD_VAR 0 5
42339: PPUSH
42340: LD_VAR 0 8
42344: PUSH
42345: LD_VAR 0 3
42349: ARRAY
42350: PPUSH
42351: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42355: LD_INT 35
42357: PPUSH
42358: CALL_OW 67
// until not HasTask ( tmp ) ;
42362: LD_VAR 0 7
42366: PPUSH
42367: CALL_OW 314
42371: NOT
42372: IFFALSE 42355
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42374: LD_ADDR_EXP 132
42378: PUSH
42379: LD_EXP 132
42383: PPUSH
42384: LD_VAR 0 2
42388: PUSH
42389: LD_EXP 132
42393: PUSH
42394: LD_VAR 0 2
42398: ARRAY
42399: PUSH
42400: LD_INT 1
42402: PLUS
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PPUSH
42408: LD_VAR 0 8
42412: PUSH
42413: LD_VAR 0 3
42417: ARRAY
42418: PPUSH
42419: CALL 57193 0 3
42423: ST_TO_ADDR
// end ;
42424: GO 42082
42426: POP
42427: POP
// MC_Reset ( i , 124 ) ;
42428: LD_VAR 0 2
42432: PPUSH
42433: LD_INT 124
42435: PPUSH
42436: CALL 25582 0 2
// end ; end ;
42440: GO 41837
42442: POP
42443: POP
// end ;
42444: LD_VAR 0 1
42448: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42449: LD_INT 0
42451: PPUSH
42452: PPUSH
42453: PPUSH
// if not mc_bases then
42454: LD_EXP 96
42458: NOT
42459: IFFALSE 42463
// exit ;
42461: GO 43069
// for i = 1 to mc_bases do
42463: LD_ADDR_VAR 0 2
42467: PUSH
42468: DOUBLE
42469: LD_INT 1
42471: DEC
42472: ST_TO_ADDR
42473: LD_EXP 96
42477: PUSH
42478: FOR_TO
42479: IFFALSE 43067
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42481: LD_ADDR_VAR 0 3
42485: PUSH
42486: LD_EXP 96
42490: PUSH
42491: LD_VAR 0 2
42495: ARRAY
42496: PPUSH
42497: LD_INT 25
42499: PUSH
42500: LD_INT 4
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PPUSH
42507: CALL_OW 72
42511: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42512: LD_VAR 0 3
42516: NOT
42517: PUSH
42518: LD_EXP 133
42522: PUSH
42523: LD_VAR 0 2
42527: ARRAY
42528: NOT
42529: OR
42530: PUSH
42531: LD_EXP 96
42535: PUSH
42536: LD_VAR 0 2
42540: ARRAY
42541: PPUSH
42542: LD_INT 2
42544: PUSH
42545: LD_INT 30
42547: PUSH
42548: LD_INT 0
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: LD_INT 30
42557: PUSH
42558: LD_INT 1
42560: PUSH
42561: EMPTY
42562: LIST
42563: LIST
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: LIST
42569: PPUSH
42570: CALL_OW 72
42574: NOT
42575: OR
42576: IFFALSE 42626
// begin if mc_deposits_finder [ i ] then
42578: LD_EXP 134
42582: PUSH
42583: LD_VAR 0 2
42587: ARRAY
42588: IFFALSE 42624
// begin MC_Reset ( i , 125 ) ;
42590: LD_VAR 0 2
42594: PPUSH
42595: LD_INT 125
42597: PPUSH
42598: CALL 25582 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42602: LD_ADDR_EXP 134
42606: PUSH
42607: LD_EXP 134
42611: PPUSH
42612: LD_VAR 0 2
42616: PPUSH
42617: EMPTY
42618: PPUSH
42619: CALL_OW 1
42623: ST_TO_ADDR
// end ; continue ;
42624: GO 42478
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42626: LD_EXP 133
42630: PUSH
42631: LD_VAR 0 2
42635: ARRAY
42636: PUSH
42637: LD_INT 1
42639: ARRAY
42640: PUSH
42641: LD_INT 3
42643: ARRAY
42644: PUSH
42645: LD_INT 1
42647: EQUAL
42648: PUSH
42649: LD_INT 20
42651: PPUSH
42652: LD_EXP 122
42656: PUSH
42657: LD_VAR 0 2
42661: ARRAY
42662: PPUSH
42663: CALL_OW 321
42667: PUSH
42668: LD_INT 2
42670: NONEQUAL
42671: AND
42672: IFFALSE 42722
// begin if mc_deposits_finder [ i ] then
42674: LD_EXP 134
42678: PUSH
42679: LD_VAR 0 2
42683: ARRAY
42684: IFFALSE 42720
// begin MC_Reset ( i , 125 ) ;
42686: LD_VAR 0 2
42690: PPUSH
42691: LD_INT 125
42693: PPUSH
42694: CALL 25582 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42698: LD_ADDR_EXP 134
42702: PUSH
42703: LD_EXP 134
42707: PPUSH
42708: LD_VAR 0 2
42712: PPUSH
42713: EMPTY
42714: PPUSH
42715: CALL_OW 1
42719: ST_TO_ADDR
// end ; continue ;
42720: GO 42478
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42722: LD_EXP 133
42726: PUSH
42727: LD_VAR 0 2
42731: ARRAY
42732: PUSH
42733: LD_INT 1
42735: ARRAY
42736: PUSH
42737: LD_INT 1
42739: ARRAY
42740: PPUSH
42741: LD_EXP 133
42745: PUSH
42746: LD_VAR 0 2
42750: ARRAY
42751: PUSH
42752: LD_INT 1
42754: ARRAY
42755: PUSH
42756: LD_INT 2
42758: ARRAY
42759: PPUSH
42760: LD_EXP 122
42764: PUSH
42765: LD_VAR 0 2
42769: ARRAY
42770: PPUSH
42771: CALL_OW 440
42775: IFFALSE 42818
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42777: LD_ADDR_EXP 133
42781: PUSH
42782: LD_EXP 133
42786: PPUSH
42787: LD_VAR 0 2
42791: PPUSH
42792: LD_EXP 133
42796: PUSH
42797: LD_VAR 0 2
42801: ARRAY
42802: PPUSH
42803: LD_INT 1
42805: PPUSH
42806: CALL_OW 3
42810: PPUSH
42811: CALL_OW 1
42815: ST_TO_ADDR
42816: GO 43065
// begin if not mc_deposits_finder [ i ] then
42818: LD_EXP 134
42822: PUSH
42823: LD_VAR 0 2
42827: ARRAY
42828: NOT
42829: IFFALSE 42881
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42831: LD_ADDR_EXP 134
42835: PUSH
42836: LD_EXP 134
42840: PPUSH
42841: LD_VAR 0 2
42845: PPUSH
42846: LD_VAR 0 3
42850: PUSH
42851: LD_INT 1
42853: ARRAY
42854: PUSH
42855: EMPTY
42856: LIST
42857: PPUSH
42858: CALL_OW 1
42862: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42863: LD_VAR 0 3
42867: PUSH
42868: LD_INT 1
42870: ARRAY
42871: PPUSH
42872: LD_INT 125
42874: PPUSH
42875: CALL_OW 109
// end else
42879: GO 43065
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42881: LD_EXP 134
42885: PUSH
42886: LD_VAR 0 2
42890: ARRAY
42891: PUSH
42892: LD_INT 1
42894: ARRAY
42895: PPUSH
42896: CALL_OW 310
42900: IFFALSE 42923
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42902: LD_EXP 134
42906: PUSH
42907: LD_VAR 0 2
42911: ARRAY
42912: PUSH
42913: LD_INT 1
42915: ARRAY
42916: PPUSH
42917: CALL_OW 122
42921: GO 43065
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42923: LD_EXP 134
42927: PUSH
42928: LD_VAR 0 2
42932: ARRAY
42933: PUSH
42934: LD_INT 1
42936: ARRAY
42937: PPUSH
42938: CALL_OW 314
42942: NOT
42943: PUSH
42944: LD_EXP 134
42948: PUSH
42949: LD_VAR 0 2
42953: ARRAY
42954: PUSH
42955: LD_INT 1
42957: ARRAY
42958: PPUSH
42959: LD_EXP 133
42963: PUSH
42964: LD_VAR 0 2
42968: ARRAY
42969: PUSH
42970: LD_INT 1
42972: ARRAY
42973: PUSH
42974: LD_INT 1
42976: ARRAY
42977: PPUSH
42978: LD_EXP 133
42982: PUSH
42983: LD_VAR 0 2
42987: ARRAY
42988: PUSH
42989: LD_INT 1
42991: ARRAY
42992: PUSH
42993: LD_INT 2
42995: ARRAY
42996: PPUSH
42997: CALL_OW 297
43001: PUSH
43002: LD_INT 6
43004: GREATER
43005: AND
43006: IFFALSE 43065
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
43008: LD_EXP 134
43012: PUSH
43013: LD_VAR 0 2
43017: ARRAY
43018: PUSH
43019: LD_INT 1
43021: ARRAY
43022: PPUSH
43023: LD_EXP 133
43027: PUSH
43028: LD_VAR 0 2
43032: ARRAY
43033: PUSH
43034: LD_INT 1
43036: ARRAY
43037: PUSH
43038: LD_INT 1
43040: ARRAY
43041: PPUSH
43042: LD_EXP 133
43046: PUSH
43047: LD_VAR 0 2
43051: ARRAY
43052: PUSH
43053: LD_INT 1
43055: ARRAY
43056: PUSH
43057: LD_INT 2
43059: ARRAY
43060: PPUSH
43061: CALL_OW 111
// end ; end ; end ;
43065: GO 42478
43067: POP
43068: POP
// end ;
43069: LD_VAR 0 1
43073: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43074: LD_INT 0
43076: PPUSH
43077: PPUSH
43078: PPUSH
43079: PPUSH
43080: PPUSH
43081: PPUSH
43082: PPUSH
43083: PPUSH
43084: PPUSH
43085: PPUSH
43086: PPUSH
// if not mc_bases then
43087: LD_EXP 96
43091: NOT
43092: IFFALSE 43096
// exit ;
43094: GO 44036
// for i = 1 to mc_bases do
43096: LD_ADDR_VAR 0 2
43100: PUSH
43101: DOUBLE
43102: LD_INT 1
43104: DEC
43105: ST_TO_ADDR
43106: LD_EXP 96
43110: PUSH
43111: FOR_TO
43112: IFFALSE 44034
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43114: LD_EXP 96
43118: PUSH
43119: LD_VAR 0 2
43123: ARRAY
43124: NOT
43125: PUSH
43126: LD_EXP 119
43130: PUSH
43131: LD_VAR 0 2
43135: ARRAY
43136: OR
43137: IFFALSE 43141
// continue ;
43139: GO 43111
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43141: LD_ADDR_VAR 0 7
43145: PUSH
43146: LD_EXP 96
43150: PUSH
43151: LD_VAR 0 2
43155: ARRAY
43156: PUSH
43157: LD_INT 1
43159: ARRAY
43160: PPUSH
43161: CALL_OW 248
43165: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43166: LD_VAR 0 7
43170: PUSH
43171: LD_INT 3
43173: EQUAL
43174: PUSH
43175: LD_EXP 115
43179: PUSH
43180: LD_VAR 0 2
43184: ARRAY
43185: PUSH
43186: LD_EXP 118
43190: PUSH
43191: LD_VAR 0 2
43195: ARRAY
43196: UNION
43197: PPUSH
43198: LD_INT 33
43200: PUSH
43201: LD_INT 2
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PPUSH
43208: CALL_OW 72
43212: NOT
43213: OR
43214: IFFALSE 43218
// continue ;
43216: GO 43111
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43218: LD_ADDR_VAR 0 9
43222: PUSH
43223: LD_EXP 96
43227: PUSH
43228: LD_VAR 0 2
43232: ARRAY
43233: PPUSH
43234: LD_INT 30
43236: PUSH
43237: LD_INT 36
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PPUSH
43244: CALL_OW 72
43248: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43249: LD_ADDR_VAR 0 10
43253: PUSH
43254: LD_EXP 115
43258: PUSH
43259: LD_VAR 0 2
43263: ARRAY
43264: PPUSH
43265: LD_INT 34
43267: PUSH
43268: LD_INT 31
43270: PUSH
43271: EMPTY
43272: LIST
43273: LIST
43274: PPUSH
43275: CALL_OW 72
43279: ST_TO_ADDR
// if not cts and not mcts then
43280: LD_VAR 0 9
43284: NOT
43285: PUSH
43286: LD_VAR 0 10
43290: NOT
43291: AND
43292: IFFALSE 43296
// continue ;
43294: GO 43111
// x := cts ;
43296: LD_ADDR_VAR 0 11
43300: PUSH
43301: LD_VAR 0 9
43305: ST_TO_ADDR
// if not x then
43306: LD_VAR 0 11
43310: NOT
43311: IFFALSE 43323
// x := mcts ;
43313: LD_ADDR_VAR 0 11
43317: PUSH
43318: LD_VAR 0 10
43322: ST_TO_ADDR
// if not x then
43323: LD_VAR 0 11
43327: NOT
43328: IFFALSE 43332
// continue ;
43330: GO 43111
// if mc_remote_driver [ i ] then
43332: LD_EXP 136
43336: PUSH
43337: LD_VAR 0 2
43341: ARRAY
43342: IFFALSE 43729
// for j in mc_remote_driver [ i ] do
43344: LD_ADDR_VAR 0 3
43348: PUSH
43349: LD_EXP 136
43353: PUSH
43354: LD_VAR 0 2
43358: ARRAY
43359: PUSH
43360: FOR_IN
43361: IFFALSE 43727
// begin if GetClass ( j ) <> 3 then
43363: LD_VAR 0 3
43367: PPUSH
43368: CALL_OW 257
43372: PUSH
43373: LD_INT 3
43375: NONEQUAL
43376: IFFALSE 43429
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43378: LD_ADDR_EXP 136
43382: PUSH
43383: LD_EXP 136
43387: PPUSH
43388: LD_VAR 0 2
43392: PPUSH
43393: LD_EXP 136
43397: PUSH
43398: LD_VAR 0 2
43402: ARRAY
43403: PUSH
43404: LD_VAR 0 3
43408: DIFF
43409: PPUSH
43410: CALL_OW 1
43414: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43415: LD_VAR 0 3
43419: PPUSH
43420: LD_INT 0
43422: PPUSH
43423: CALL_OW 109
// continue ;
43427: GO 43360
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43429: LD_EXP 115
43433: PUSH
43434: LD_VAR 0 2
43438: ARRAY
43439: PPUSH
43440: LD_INT 34
43442: PUSH
43443: LD_INT 31
43445: PUSH
43446: EMPTY
43447: LIST
43448: LIST
43449: PUSH
43450: LD_INT 58
43452: PUSH
43453: EMPTY
43454: LIST
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PPUSH
43460: CALL_OW 72
43464: PUSH
43465: LD_VAR 0 3
43469: PPUSH
43470: CALL 86497 0 1
43474: NOT
43475: AND
43476: IFFALSE 43547
// begin if IsInUnit ( j ) then
43478: LD_VAR 0 3
43482: PPUSH
43483: CALL_OW 310
43487: IFFALSE 43498
// ComExitBuilding ( j ) ;
43489: LD_VAR 0 3
43493: PPUSH
43494: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43498: LD_VAR 0 3
43502: PPUSH
43503: LD_EXP 115
43507: PUSH
43508: LD_VAR 0 2
43512: ARRAY
43513: PPUSH
43514: LD_INT 34
43516: PUSH
43517: LD_INT 31
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 58
43526: PUSH
43527: EMPTY
43528: LIST
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PPUSH
43534: CALL_OW 72
43538: PUSH
43539: LD_INT 1
43541: ARRAY
43542: PPUSH
43543: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43547: LD_VAR 0 3
43551: PPUSH
43552: CALL_OW 310
43556: NOT
43557: PUSH
43558: LD_VAR 0 3
43562: PPUSH
43563: CALL_OW 310
43567: PPUSH
43568: CALL_OW 266
43572: PUSH
43573: LD_INT 36
43575: NONEQUAL
43576: PUSH
43577: LD_VAR 0 3
43581: PPUSH
43582: CALL 86497 0 1
43586: NOT
43587: AND
43588: OR
43589: IFFALSE 43725
// begin if IsInUnit ( j ) then
43591: LD_VAR 0 3
43595: PPUSH
43596: CALL_OW 310
43600: IFFALSE 43611
// ComExitBuilding ( j ) ;
43602: LD_VAR 0 3
43606: PPUSH
43607: CALL_OW 122
// ct := 0 ;
43611: LD_ADDR_VAR 0 8
43615: PUSH
43616: LD_INT 0
43618: ST_TO_ADDR
// for k in x do
43619: LD_ADDR_VAR 0 4
43623: PUSH
43624: LD_VAR 0 11
43628: PUSH
43629: FOR_IN
43630: IFFALSE 43703
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43632: LD_VAR 0 4
43636: PPUSH
43637: CALL_OW 264
43641: PUSH
43642: LD_INT 31
43644: EQUAL
43645: PUSH
43646: LD_VAR 0 4
43650: PPUSH
43651: CALL_OW 311
43655: NOT
43656: AND
43657: PUSH
43658: LD_VAR 0 4
43662: PPUSH
43663: CALL_OW 266
43667: PUSH
43668: LD_INT 36
43670: EQUAL
43671: PUSH
43672: LD_VAR 0 4
43676: PPUSH
43677: CALL_OW 313
43681: PUSH
43682: LD_INT 3
43684: LESS
43685: AND
43686: OR
43687: IFFALSE 43701
// begin ct := k ;
43689: LD_ADDR_VAR 0 8
43693: PUSH
43694: LD_VAR 0 4
43698: ST_TO_ADDR
// break ;
43699: GO 43703
// end ;
43701: GO 43629
43703: POP
43704: POP
// if ct then
43705: LD_VAR 0 8
43709: IFFALSE 43725
// ComEnterUnit ( j , ct ) ;
43711: LD_VAR 0 3
43715: PPUSH
43716: LD_VAR 0 8
43720: PPUSH
43721: CALL_OW 120
// end ; end ;
43725: GO 43360
43727: POP
43728: POP
// places := 0 ;
43729: LD_ADDR_VAR 0 5
43733: PUSH
43734: LD_INT 0
43736: ST_TO_ADDR
// for j = 1 to x do
43737: LD_ADDR_VAR 0 3
43741: PUSH
43742: DOUBLE
43743: LD_INT 1
43745: DEC
43746: ST_TO_ADDR
43747: LD_VAR 0 11
43751: PUSH
43752: FOR_TO
43753: IFFALSE 43829
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43755: LD_VAR 0 11
43759: PUSH
43760: LD_VAR 0 3
43764: ARRAY
43765: PPUSH
43766: CALL_OW 264
43770: PUSH
43771: LD_INT 31
43773: EQUAL
43774: IFFALSE 43792
// places := places + 1 else
43776: LD_ADDR_VAR 0 5
43780: PUSH
43781: LD_VAR 0 5
43785: PUSH
43786: LD_INT 1
43788: PLUS
43789: ST_TO_ADDR
43790: GO 43827
// if GetBType ( x [ j ] ) = b_control_tower then
43792: LD_VAR 0 11
43796: PUSH
43797: LD_VAR 0 3
43801: ARRAY
43802: PPUSH
43803: CALL_OW 266
43807: PUSH
43808: LD_INT 36
43810: EQUAL
43811: IFFALSE 43827
// places := places + 3 ;
43813: LD_ADDR_VAR 0 5
43817: PUSH
43818: LD_VAR 0 5
43822: PUSH
43823: LD_INT 3
43825: PLUS
43826: ST_TO_ADDR
43827: GO 43752
43829: POP
43830: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43831: LD_VAR 0 5
43835: PUSH
43836: LD_INT 0
43838: EQUAL
43839: PUSH
43840: LD_VAR 0 5
43844: PUSH
43845: LD_EXP 136
43849: PUSH
43850: LD_VAR 0 2
43854: ARRAY
43855: LESSEQUAL
43856: OR
43857: IFFALSE 43861
// continue ;
43859: GO 43111
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43861: LD_ADDR_VAR 0 6
43865: PUSH
43866: LD_EXP 96
43870: PUSH
43871: LD_VAR 0 2
43875: ARRAY
43876: PPUSH
43877: LD_INT 25
43879: PUSH
43880: LD_INT 3
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PPUSH
43887: CALL_OW 72
43891: PUSH
43892: LD_EXP 136
43896: PUSH
43897: LD_VAR 0 2
43901: ARRAY
43902: DIFF
43903: PPUSH
43904: LD_INT 3
43906: PPUSH
43907: CALL 87397 0 2
43911: ST_TO_ADDR
// for j in tmp do
43912: LD_ADDR_VAR 0 3
43916: PUSH
43917: LD_VAR 0 6
43921: PUSH
43922: FOR_IN
43923: IFFALSE 43958
// if GetTag ( j ) > 0 then
43925: LD_VAR 0 3
43929: PPUSH
43930: CALL_OW 110
43934: PUSH
43935: LD_INT 0
43937: GREATER
43938: IFFALSE 43956
// tmp := tmp diff j ;
43940: LD_ADDR_VAR 0 6
43944: PUSH
43945: LD_VAR 0 6
43949: PUSH
43950: LD_VAR 0 3
43954: DIFF
43955: ST_TO_ADDR
43956: GO 43922
43958: POP
43959: POP
// if not tmp then
43960: LD_VAR 0 6
43964: NOT
43965: IFFALSE 43969
// continue ;
43967: GO 43111
// if places then
43969: LD_VAR 0 5
43973: IFFALSE 44032
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43975: LD_ADDR_EXP 136
43979: PUSH
43980: LD_EXP 136
43984: PPUSH
43985: LD_VAR 0 2
43989: PPUSH
43990: LD_EXP 136
43994: PUSH
43995: LD_VAR 0 2
43999: ARRAY
44000: PUSH
44001: LD_VAR 0 6
44005: PUSH
44006: LD_INT 1
44008: ARRAY
44009: UNION
44010: PPUSH
44011: CALL_OW 1
44015: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
44016: LD_VAR 0 6
44020: PUSH
44021: LD_INT 1
44023: ARRAY
44024: PPUSH
44025: LD_INT 126
44027: PPUSH
44028: CALL_OW 109
// end ; end ;
44032: GO 43111
44034: POP
44035: POP
// end ;
44036: LD_VAR 0 1
44040: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44041: LD_INT 0
44043: PPUSH
44044: PPUSH
44045: PPUSH
44046: PPUSH
44047: PPUSH
44048: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44049: LD_VAR 0 1
44053: NOT
44054: PUSH
44055: LD_VAR 0 2
44059: NOT
44060: OR
44061: PUSH
44062: LD_VAR 0 3
44066: NOT
44067: OR
44068: PUSH
44069: LD_VAR 0 4
44073: PUSH
44074: LD_INT 1
44076: PUSH
44077: LD_INT 2
44079: PUSH
44080: LD_INT 3
44082: PUSH
44083: LD_INT 4
44085: PUSH
44086: LD_INT 5
44088: PUSH
44089: LD_INT 8
44091: PUSH
44092: LD_INT 9
44094: PUSH
44095: LD_INT 15
44097: PUSH
44098: LD_INT 16
44100: PUSH
44101: EMPTY
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: LIST
44110: LIST
44111: IN
44112: NOT
44113: OR
44114: IFFALSE 44118
// exit ;
44116: GO 45018
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44118: LD_ADDR_VAR 0 2
44122: PUSH
44123: LD_VAR 0 2
44127: PPUSH
44128: LD_INT 21
44130: PUSH
44131: LD_INT 3
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 24
44140: PUSH
44141: LD_INT 250
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PPUSH
44152: CALL_OW 72
44156: ST_TO_ADDR
// case class of 1 , 15 :
44157: LD_VAR 0 4
44161: PUSH
44162: LD_INT 1
44164: DOUBLE
44165: EQUAL
44166: IFTRUE 44176
44168: LD_INT 15
44170: DOUBLE
44171: EQUAL
44172: IFTRUE 44176
44174: GO 44261
44176: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44177: LD_ADDR_VAR 0 8
44181: PUSH
44182: LD_VAR 0 2
44186: PPUSH
44187: LD_INT 2
44189: PUSH
44190: LD_INT 30
44192: PUSH
44193: LD_INT 32
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 30
44202: PUSH
44203: LD_INT 31
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: LIST
44214: PPUSH
44215: CALL_OW 72
44219: PUSH
44220: LD_VAR 0 2
44224: PPUSH
44225: LD_INT 2
44227: PUSH
44228: LD_INT 30
44230: PUSH
44231: LD_INT 4
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: LD_INT 30
44240: PUSH
44241: LD_INT 5
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: LIST
44252: PPUSH
44253: CALL_OW 72
44257: ADD
44258: ST_TO_ADDR
44259: GO 44507
44261: LD_INT 2
44263: DOUBLE
44264: EQUAL
44265: IFTRUE 44275
44267: LD_INT 16
44269: DOUBLE
44270: EQUAL
44271: IFTRUE 44275
44273: GO 44321
44275: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44276: LD_ADDR_VAR 0 8
44280: PUSH
44281: LD_VAR 0 2
44285: PPUSH
44286: LD_INT 2
44288: PUSH
44289: LD_INT 30
44291: PUSH
44292: LD_INT 0
44294: PUSH
44295: EMPTY
44296: LIST
44297: LIST
44298: PUSH
44299: LD_INT 30
44301: PUSH
44302: LD_INT 1
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: LIST
44313: PPUSH
44314: CALL_OW 72
44318: ST_TO_ADDR
44319: GO 44507
44321: LD_INT 3
44323: DOUBLE
44324: EQUAL
44325: IFTRUE 44329
44327: GO 44375
44329: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44330: LD_ADDR_VAR 0 8
44334: PUSH
44335: LD_VAR 0 2
44339: PPUSH
44340: LD_INT 2
44342: PUSH
44343: LD_INT 30
44345: PUSH
44346: LD_INT 2
44348: PUSH
44349: EMPTY
44350: LIST
44351: LIST
44352: PUSH
44353: LD_INT 30
44355: PUSH
44356: LD_INT 3
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: EMPTY
44364: LIST
44365: LIST
44366: LIST
44367: PPUSH
44368: CALL_OW 72
44372: ST_TO_ADDR
44373: GO 44507
44375: LD_INT 4
44377: DOUBLE
44378: EQUAL
44379: IFTRUE 44383
44381: GO 44440
44383: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44384: LD_ADDR_VAR 0 8
44388: PUSH
44389: LD_VAR 0 2
44393: PPUSH
44394: LD_INT 2
44396: PUSH
44397: LD_INT 30
44399: PUSH
44400: LD_INT 6
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: PUSH
44407: LD_INT 30
44409: PUSH
44410: LD_INT 7
44412: PUSH
44413: EMPTY
44414: LIST
44415: LIST
44416: PUSH
44417: LD_INT 30
44419: PUSH
44420: LD_INT 8
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: LIST
44431: LIST
44432: PPUSH
44433: CALL_OW 72
44437: ST_TO_ADDR
44438: GO 44507
44440: LD_INT 5
44442: DOUBLE
44443: EQUAL
44444: IFTRUE 44460
44446: LD_INT 8
44448: DOUBLE
44449: EQUAL
44450: IFTRUE 44460
44452: LD_INT 9
44454: DOUBLE
44455: EQUAL
44456: IFTRUE 44460
44458: GO 44506
44460: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44461: LD_ADDR_VAR 0 8
44465: PUSH
44466: LD_VAR 0 2
44470: PPUSH
44471: LD_INT 2
44473: PUSH
44474: LD_INT 30
44476: PUSH
44477: LD_INT 4
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 30
44486: PUSH
44487: LD_INT 5
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: LIST
44498: PPUSH
44499: CALL_OW 72
44503: ST_TO_ADDR
44504: GO 44507
44506: POP
// if not tmp then
44507: LD_VAR 0 8
44511: NOT
44512: IFFALSE 44516
// exit ;
44514: GO 45018
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44516: LD_VAR 0 4
44520: PUSH
44521: LD_INT 1
44523: PUSH
44524: LD_INT 15
44526: PUSH
44527: EMPTY
44528: LIST
44529: LIST
44530: IN
44531: PUSH
44532: LD_EXP 105
44536: PUSH
44537: LD_VAR 0 1
44541: ARRAY
44542: AND
44543: IFFALSE 44699
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44545: LD_ADDR_VAR 0 9
44549: PUSH
44550: LD_EXP 105
44554: PUSH
44555: LD_VAR 0 1
44559: ARRAY
44560: PUSH
44561: LD_INT 1
44563: ARRAY
44564: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44565: LD_VAR 0 9
44569: PUSH
44570: LD_EXP 106
44574: PUSH
44575: LD_VAR 0 1
44579: ARRAY
44580: IN
44581: NOT
44582: IFFALSE 44697
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44584: LD_ADDR_EXP 106
44588: PUSH
44589: LD_EXP 106
44593: PPUSH
44594: LD_VAR 0 1
44598: PUSH
44599: LD_EXP 106
44603: PUSH
44604: LD_VAR 0 1
44608: ARRAY
44609: PUSH
44610: LD_INT 1
44612: PLUS
44613: PUSH
44614: EMPTY
44615: LIST
44616: LIST
44617: PPUSH
44618: LD_VAR 0 9
44622: PPUSH
44623: CALL 57193 0 3
44627: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44628: LD_ADDR_EXP 105
44632: PUSH
44633: LD_EXP 105
44637: PPUSH
44638: LD_VAR 0 1
44642: PPUSH
44643: LD_EXP 105
44647: PUSH
44648: LD_VAR 0 1
44652: ARRAY
44653: PUSH
44654: LD_VAR 0 9
44658: DIFF
44659: PPUSH
44660: CALL_OW 1
44664: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44665: LD_VAR 0 3
44669: PPUSH
44670: LD_EXP 106
44674: PUSH
44675: LD_VAR 0 1
44679: ARRAY
44680: PUSH
44681: LD_EXP 106
44685: PUSH
44686: LD_VAR 0 1
44690: ARRAY
44691: ARRAY
44692: PPUSH
44693: CALL_OW 120
// end ; exit ;
44697: GO 45018
// end ; if tmp > 1 then
44699: LD_VAR 0 8
44703: PUSH
44704: LD_INT 1
44706: GREATER
44707: IFFALSE 44811
// for i = 2 to tmp do
44709: LD_ADDR_VAR 0 6
44713: PUSH
44714: DOUBLE
44715: LD_INT 2
44717: DEC
44718: ST_TO_ADDR
44719: LD_VAR 0 8
44723: PUSH
44724: FOR_TO
44725: IFFALSE 44809
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44727: LD_VAR 0 8
44731: PUSH
44732: LD_VAR 0 6
44736: ARRAY
44737: PPUSH
44738: CALL_OW 461
44742: PUSH
44743: LD_INT 6
44745: EQUAL
44746: IFFALSE 44807
// begin x := tmp [ i ] ;
44748: LD_ADDR_VAR 0 9
44752: PUSH
44753: LD_VAR 0 8
44757: PUSH
44758: LD_VAR 0 6
44762: ARRAY
44763: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44764: LD_ADDR_VAR 0 8
44768: PUSH
44769: LD_VAR 0 8
44773: PPUSH
44774: LD_VAR 0 6
44778: PPUSH
44779: CALL_OW 3
44783: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44784: LD_ADDR_VAR 0 8
44788: PUSH
44789: LD_VAR 0 8
44793: PPUSH
44794: LD_INT 1
44796: PPUSH
44797: LD_VAR 0 9
44801: PPUSH
44802: CALL_OW 2
44806: ST_TO_ADDR
// end ;
44807: GO 44724
44809: POP
44810: POP
// for i in tmp do
44811: LD_ADDR_VAR 0 6
44815: PUSH
44816: LD_VAR 0 8
44820: PUSH
44821: FOR_IN
44822: IFFALSE 44891
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44824: LD_VAR 0 6
44828: PPUSH
44829: CALL_OW 313
44833: PUSH
44834: LD_INT 6
44836: LESS
44837: PUSH
44838: LD_VAR 0 6
44842: PPUSH
44843: CALL_OW 266
44847: PUSH
44848: LD_INT 31
44850: PUSH
44851: LD_INT 32
44853: PUSH
44854: EMPTY
44855: LIST
44856: LIST
44857: IN
44858: NOT
44859: AND
44860: PUSH
44861: LD_VAR 0 6
44865: PPUSH
44866: CALL_OW 313
44870: PUSH
44871: LD_INT 0
44873: EQUAL
44874: OR
44875: IFFALSE 44889
// begin j := i ;
44877: LD_ADDR_VAR 0 7
44881: PUSH
44882: LD_VAR 0 6
44886: ST_TO_ADDR
// break ;
44887: GO 44891
// end ; end ;
44889: GO 44821
44891: POP
44892: POP
// if j then
44893: LD_VAR 0 7
44897: IFFALSE 44915
// ComEnterUnit ( unit , j ) else
44899: LD_VAR 0 3
44903: PPUSH
44904: LD_VAR 0 7
44908: PPUSH
44909: CALL_OW 120
44913: GO 45018
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44915: LD_ADDR_VAR 0 10
44919: PUSH
44920: LD_VAR 0 2
44924: PPUSH
44925: LD_INT 2
44927: PUSH
44928: LD_INT 30
44930: PUSH
44931: LD_INT 0
44933: PUSH
44934: EMPTY
44935: LIST
44936: LIST
44937: PUSH
44938: LD_INT 30
44940: PUSH
44941: LD_INT 1
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: LIST
44952: PPUSH
44953: CALL_OW 72
44957: ST_TO_ADDR
// if depot then
44958: LD_VAR 0 10
44962: IFFALSE 45018
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44964: LD_ADDR_VAR 0 10
44968: PUSH
44969: LD_VAR 0 10
44973: PPUSH
44974: LD_VAR 0 3
44978: PPUSH
44979: CALL_OW 74
44983: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44984: LD_VAR 0 3
44988: PPUSH
44989: LD_VAR 0 10
44993: PPUSH
44994: CALL_OW 296
44998: PUSH
44999: LD_INT 10
45001: GREATER
45002: IFFALSE 45018
// ComStandNearbyBuilding ( unit , depot ) ;
45004: LD_VAR 0 3
45008: PPUSH
45009: LD_VAR 0 10
45013: PPUSH
45014: CALL 53618 0 2
// end ; end ; end ;
45018: LD_VAR 0 5
45022: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
45023: LD_INT 0
45025: PPUSH
45026: PPUSH
45027: PPUSH
45028: PPUSH
// if not mc_bases then
45029: LD_EXP 96
45033: NOT
45034: IFFALSE 45038
// exit ;
45036: GO 45277
// for i = 1 to mc_bases do
45038: LD_ADDR_VAR 0 2
45042: PUSH
45043: DOUBLE
45044: LD_INT 1
45046: DEC
45047: ST_TO_ADDR
45048: LD_EXP 96
45052: PUSH
45053: FOR_TO
45054: IFFALSE 45275
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45056: LD_ADDR_VAR 0 4
45060: PUSH
45061: LD_EXP 96
45065: PUSH
45066: LD_VAR 0 2
45070: ARRAY
45071: PPUSH
45072: LD_INT 21
45074: PUSH
45075: LD_INT 1
45077: PUSH
45078: EMPTY
45079: LIST
45080: LIST
45081: PPUSH
45082: CALL_OW 72
45086: PUSH
45087: LD_EXP 125
45091: PUSH
45092: LD_VAR 0 2
45096: ARRAY
45097: UNION
45098: ST_TO_ADDR
// if not tmp then
45099: LD_VAR 0 4
45103: NOT
45104: IFFALSE 45108
// continue ;
45106: GO 45053
// for j in tmp do
45108: LD_ADDR_VAR 0 3
45112: PUSH
45113: LD_VAR 0 4
45117: PUSH
45118: FOR_IN
45119: IFFALSE 45271
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45121: LD_VAR 0 3
45125: PPUSH
45126: CALL_OW 110
45130: NOT
45131: PUSH
45132: LD_VAR 0 3
45136: PPUSH
45137: CALL_OW 314
45141: NOT
45142: AND
45143: PUSH
45144: LD_VAR 0 3
45148: PPUSH
45149: CALL_OW 311
45153: NOT
45154: AND
45155: PUSH
45156: LD_VAR 0 3
45160: PPUSH
45161: CALL_OW 310
45165: NOT
45166: AND
45167: PUSH
45168: LD_VAR 0 3
45172: PUSH
45173: LD_EXP 99
45177: PUSH
45178: LD_VAR 0 2
45182: ARRAY
45183: PUSH
45184: LD_INT 1
45186: ARRAY
45187: IN
45188: NOT
45189: AND
45190: PUSH
45191: LD_VAR 0 3
45195: PUSH
45196: LD_EXP 99
45200: PUSH
45201: LD_VAR 0 2
45205: ARRAY
45206: PUSH
45207: LD_INT 2
45209: ARRAY
45210: IN
45211: NOT
45212: AND
45213: PUSH
45214: LD_VAR 0 3
45218: PUSH
45219: LD_EXP 108
45223: PUSH
45224: LD_VAR 0 2
45228: ARRAY
45229: IN
45230: NOT
45231: AND
45232: IFFALSE 45269
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45234: LD_VAR 0 2
45238: PPUSH
45239: LD_EXP 96
45243: PUSH
45244: LD_VAR 0 2
45248: ARRAY
45249: PPUSH
45250: LD_VAR 0 3
45254: PPUSH
45255: LD_VAR 0 3
45259: PPUSH
45260: CALL_OW 257
45264: PPUSH
45265: CALL 44041 0 4
// end ;
45269: GO 45118
45271: POP
45272: POP
// end ;
45273: GO 45053
45275: POP
45276: POP
// end ;
45277: LD_VAR 0 1
45281: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
45282: LD_INT 0
45284: PPUSH
45285: PPUSH
45286: PPUSH
45287: PPUSH
45288: PPUSH
45289: PPUSH
// if not mc_bases [ base ] then
45290: LD_EXP 96
45294: PUSH
45295: LD_VAR 0 1
45299: ARRAY
45300: NOT
45301: IFFALSE 45305
// exit ;
45303: GO 45487
// tmp := [ ] ;
45305: LD_ADDR_VAR 0 6
45309: PUSH
45310: EMPTY
45311: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45312: LD_ADDR_VAR 0 7
45316: PUSH
45317: LD_VAR 0 3
45321: PPUSH
45322: LD_INT 0
45324: PPUSH
45325: CALL_OW 517
45329: ST_TO_ADDR
// if not list then
45330: LD_VAR 0 7
45334: NOT
45335: IFFALSE 45339
// exit ;
45337: GO 45487
// for i = 1 to amount do
45339: LD_ADDR_VAR 0 5
45343: PUSH
45344: DOUBLE
45345: LD_INT 1
45347: DEC
45348: ST_TO_ADDR
45349: LD_VAR 0 2
45353: PUSH
45354: FOR_TO
45355: IFFALSE 45435
// begin x := rand ( 1 , list [ 1 ] ) ;
45357: LD_ADDR_VAR 0 8
45361: PUSH
45362: LD_INT 1
45364: PPUSH
45365: LD_VAR 0 7
45369: PUSH
45370: LD_INT 1
45372: ARRAY
45373: PPUSH
45374: CALL_OW 12
45378: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
45379: LD_ADDR_VAR 0 6
45383: PUSH
45384: LD_VAR 0 6
45388: PPUSH
45389: LD_VAR 0 5
45393: PPUSH
45394: LD_VAR 0 7
45398: PUSH
45399: LD_INT 1
45401: ARRAY
45402: PUSH
45403: LD_VAR 0 8
45407: ARRAY
45408: PUSH
45409: LD_VAR 0 7
45413: PUSH
45414: LD_INT 2
45416: ARRAY
45417: PUSH
45418: LD_VAR 0 8
45422: ARRAY
45423: PUSH
45424: EMPTY
45425: LIST
45426: LIST
45427: PPUSH
45428: CALL_OW 1
45432: ST_TO_ADDR
// end ;
45433: GO 45354
45435: POP
45436: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45437: LD_ADDR_EXP 109
45441: PUSH
45442: LD_EXP 109
45446: PPUSH
45447: LD_VAR 0 1
45451: PPUSH
45452: LD_VAR 0 6
45456: PPUSH
45457: CALL_OW 1
45461: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45462: LD_ADDR_EXP 111
45466: PUSH
45467: LD_EXP 111
45471: PPUSH
45472: LD_VAR 0 1
45476: PPUSH
45477: LD_VAR 0 3
45481: PPUSH
45482: CALL_OW 1
45486: ST_TO_ADDR
// end ;
45487: LD_VAR 0 4
45491: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45492: LD_INT 0
45494: PPUSH
// if not mc_bases [ base ] then
45495: LD_EXP 96
45499: PUSH
45500: LD_VAR 0 1
45504: ARRAY
45505: NOT
45506: IFFALSE 45510
// exit ;
45508: GO 45535
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45510: LD_ADDR_EXP 101
45514: PUSH
45515: LD_EXP 101
45519: PPUSH
45520: LD_VAR 0 1
45524: PPUSH
45525: LD_VAR 0 2
45529: PPUSH
45530: CALL_OW 1
45534: ST_TO_ADDR
// end ;
45535: LD_VAR 0 3
45539: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45540: LD_INT 0
45542: PPUSH
// if not mc_bases [ base ] then
45543: LD_EXP 96
45547: PUSH
45548: LD_VAR 0 1
45552: ARRAY
45553: NOT
45554: IFFALSE 45558
// exit ;
45556: GO 45595
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45558: LD_ADDR_EXP 101
45562: PUSH
45563: LD_EXP 101
45567: PPUSH
45568: LD_VAR 0 1
45572: PPUSH
45573: LD_EXP 101
45577: PUSH
45578: LD_VAR 0 1
45582: ARRAY
45583: PUSH
45584: LD_VAR 0 2
45588: UNION
45589: PPUSH
45590: CALL_OW 1
45594: ST_TO_ADDR
// end ;
45595: LD_VAR 0 3
45599: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45600: LD_INT 0
45602: PPUSH
// if not mc_bases [ base ] then
45603: LD_EXP 96
45607: PUSH
45608: LD_VAR 0 1
45612: ARRAY
45613: NOT
45614: IFFALSE 45618
// exit ;
45616: GO 45643
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45618: LD_ADDR_EXP 117
45622: PUSH
45623: LD_EXP 117
45627: PPUSH
45628: LD_VAR 0 1
45632: PPUSH
45633: LD_VAR 0 2
45637: PPUSH
45638: CALL_OW 1
45642: ST_TO_ADDR
// end ;
45643: LD_VAR 0 3
45647: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45648: LD_INT 0
45650: PPUSH
// if not mc_bases [ base ] then
45651: LD_EXP 96
45655: PUSH
45656: LD_VAR 0 1
45660: ARRAY
45661: NOT
45662: IFFALSE 45666
// exit ;
45664: GO 45703
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45666: LD_ADDR_EXP 117
45670: PUSH
45671: LD_EXP 117
45675: PPUSH
45676: LD_VAR 0 1
45680: PPUSH
45681: LD_EXP 117
45685: PUSH
45686: LD_VAR 0 1
45690: ARRAY
45691: PUSH
45692: LD_VAR 0 2
45696: ADD
45697: PPUSH
45698: CALL_OW 1
45702: ST_TO_ADDR
// end ;
45703: LD_VAR 0 3
45707: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45708: LD_INT 0
45710: PPUSH
// if not mc_bases [ base ] then
45711: LD_EXP 96
45715: PUSH
45716: LD_VAR 0 1
45720: ARRAY
45721: NOT
45722: IFFALSE 45726
// exit ;
45724: GO 45780
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45726: LD_ADDR_EXP 118
45730: PUSH
45731: LD_EXP 118
45735: PPUSH
45736: LD_VAR 0 1
45740: PPUSH
45741: LD_VAR 0 2
45745: PPUSH
45746: CALL_OW 1
45750: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45751: LD_ADDR_EXP 107
45755: PUSH
45756: LD_EXP 107
45760: PPUSH
45761: LD_VAR 0 1
45765: PPUSH
45766: LD_VAR 0 2
45770: PUSH
45771: LD_INT 0
45773: PLUS
45774: PPUSH
45775: CALL_OW 1
45779: ST_TO_ADDR
// end ;
45780: LD_VAR 0 3
45784: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45785: LD_INT 0
45787: PPUSH
// if not mc_bases [ base ] then
45788: LD_EXP 96
45792: PUSH
45793: LD_VAR 0 1
45797: ARRAY
45798: NOT
45799: IFFALSE 45803
// exit ;
45801: GO 45828
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45803: LD_ADDR_EXP 107
45807: PUSH
45808: LD_EXP 107
45812: PPUSH
45813: LD_VAR 0 1
45817: PPUSH
45818: LD_VAR 0 2
45822: PPUSH
45823: CALL_OW 1
45827: ST_TO_ADDR
// end ;
45828: LD_VAR 0 3
45832: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45833: LD_INT 0
45835: PPUSH
45836: PPUSH
45837: PPUSH
45838: PPUSH
// if not mc_bases [ base ] then
45839: LD_EXP 96
45843: PUSH
45844: LD_VAR 0 1
45848: ARRAY
45849: NOT
45850: IFFALSE 45854
// exit ;
45852: GO 45919
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45854: LD_ADDR_EXP 116
45858: PUSH
45859: LD_EXP 116
45863: PPUSH
45864: LD_VAR 0 1
45868: PUSH
45869: LD_EXP 116
45873: PUSH
45874: LD_VAR 0 1
45878: ARRAY
45879: PUSH
45880: LD_INT 1
45882: PLUS
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: PPUSH
45888: LD_VAR 0 1
45892: PUSH
45893: LD_VAR 0 2
45897: PUSH
45898: LD_VAR 0 3
45902: PUSH
45903: LD_VAR 0 4
45907: PUSH
45908: EMPTY
45909: LIST
45910: LIST
45911: LIST
45912: LIST
45913: PPUSH
45914: CALL 57193 0 3
45918: ST_TO_ADDR
// end ;
45919: LD_VAR 0 5
45923: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45924: LD_INT 0
45926: PPUSH
// if not mc_bases [ base ] then
45927: LD_EXP 96
45931: PUSH
45932: LD_VAR 0 1
45936: ARRAY
45937: NOT
45938: IFFALSE 45942
// exit ;
45940: GO 45967
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45942: LD_ADDR_EXP 133
45946: PUSH
45947: LD_EXP 133
45951: PPUSH
45952: LD_VAR 0 1
45956: PPUSH
45957: LD_VAR 0 2
45961: PPUSH
45962: CALL_OW 1
45966: ST_TO_ADDR
// end ;
45967: LD_VAR 0 3
45971: RET
// export function MC_GetMinesField ( base ) ; begin
45972: LD_INT 0
45974: PPUSH
// result := mc_mines [ base ] ;
45975: LD_ADDR_VAR 0 2
45979: PUSH
45980: LD_EXP 109
45984: PUSH
45985: LD_VAR 0 1
45989: ARRAY
45990: ST_TO_ADDR
// end ;
45991: LD_VAR 0 2
45995: RET
// export function MC_GetProduceList ( base ) ; begin
45996: LD_INT 0
45998: PPUSH
// result := mc_produce [ base ] ;
45999: LD_ADDR_VAR 0 2
46003: PUSH
46004: LD_EXP 117
46008: PUSH
46009: LD_VAR 0 1
46013: ARRAY
46014: ST_TO_ADDR
// end ;
46015: LD_VAR 0 2
46019: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
46020: LD_INT 0
46022: PPUSH
46023: PPUSH
// if not mc_bases then
46024: LD_EXP 96
46028: NOT
46029: IFFALSE 46033
// exit ;
46031: GO 46098
// if mc_bases [ base ] then
46033: LD_EXP 96
46037: PUSH
46038: LD_VAR 0 1
46042: ARRAY
46043: IFFALSE 46098
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46045: LD_ADDR_VAR 0 3
46049: PUSH
46050: LD_EXP 96
46054: PUSH
46055: LD_VAR 0 1
46059: ARRAY
46060: PPUSH
46061: LD_INT 30
46063: PUSH
46064: LD_VAR 0 2
46068: PUSH
46069: EMPTY
46070: LIST
46071: LIST
46072: PPUSH
46073: CALL_OW 72
46077: ST_TO_ADDR
// if result then
46078: LD_VAR 0 3
46082: IFFALSE 46098
// result := result [ 1 ] ;
46084: LD_ADDR_VAR 0 3
46088: PUSH
46089: LD_VAR 0 3
46093: PUSH
46094: LD_INT 1
46096: ARRAY
46097: ST_TO_ADDR
// end ; end ;
46098: LD_VAR 0 3
46102: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46103: LD_INT 0
46105: PPUSH
46106: PPUSH
// if not mc_bases then
46107: LD_EXP 96
46111: NOT
46112: IFFALSE 46116
// exit ;
46114: GO 46161
// if mc_bases [ base ] then
46116: LD_EXP 96
46120: PUSH
46121: LD_VAR 0 1
46125: ARRAY
46126: IFFALSE 46161
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46128: LD_ADDR_VAR 0 3
46132: PUSH
46133: LD_EXP 96
46137: PUSH
46138: LD_VAR 0 1
46142: ARRAY
46143: PPUSH
46144: LD_INT 30
46146: PUSH
46147: LD_VAR 0 2
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PPUSH
46156: CALL_OW 72
46160: ST_TO_ADDR
// end ;
46161: LD_VAR 0 3
46165: RET
// export function MC_SetTame ( base , area ) ; begin
46166: LD_INT 0
46168: PPUSH
// if not mc_bases or not base then
46169: LD_EXP 96
46173: NOT
46174: PUSH
46175: LD_VAR 0 1
46179: NOT
46180: OR
46181: IFFALSE 46185
// exit ;
46183: GO 46210
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46185: LD_ADDR_EXP 124
46189: PUSH
46190: LD_EXP 124
46194: PPUSH
46195: LD_VAR 0 1
46199: PPUSH
46200: LD_VAR 0 2
46204: PPUSH
46205: CALL_OW 1
46209: ST_TO_ADDR
// end ;
46210: LD_VAR 0 3
46214: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46215: LD_INT 0
46217: PPUSH
46218: PPUSH
// if not mc_bases or not base then
46219: LD_EXP 96
46223: NOT
46224: PUSH
46225: LD_VAR 0 1
46229: NOT
46230: OR
46231: IFFALSE 46235
// exit ;
46233: GO 46337
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46235: LD_ADDR_VAR 0 4
46239: PUSH
46240: LD_EXP 96
46244: PUSH
46245: LD_VAR 0 1
46249: ARRAY
46250: PPUSH
46251: LD_INT 30
46253: PUSH
46254: LD_VAR 0 2
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PPUSH
46263: CALL_OW 72
46267: ST_TO_ADDR
// if not tmp then
46268: LD_VAR 0 4
46272: NOT
46273: IFFALSE 46277
// exit ;
46275: GO 46337
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46277: LD_ADDR_EXP 128
46281: PUSH
46282: LD_EXP 128
46286: PPUSH
46287: LD_VAR 0 1
46291: PPUSH
46292: LD_EXP 128
46296: PUSH
46297: LD_VAR 0 1
46301: ARRAY
46302: PPUSH
46303: LD_EXP 128
46307: PUSH
46308: LD_VAR 0 1
46312: ARRAY
46313: PUSH
46314: LD_INT 1
46316: PLUS
46317: PPUSH
46318: LD_VAR 0 4
46322: PUSH
46323: LD_INT 1
46325: ARRAY
46326: PPUSH
46327: CALL_OW 2
46331: PPUSH
46332: CALL_OW 1
46336: ST_TO_ADDR
// end ;
46337: LD_VAR 0 3
46341: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46342: LD_INT 0
46344: PPUSH
46345: PPUSH
// if not mc_bases or not base or not kinds then
46346: LD_EXP 96
46350: NOT
46351: PUSH
46352: LD_VAR 0 1
46356: NOT
46357: OR
46358: PUSH
46359: LD_VAR 0 2
46363: NOT
46364: OR
46365: IFFALSE 46369
// exit ;
46367: GO 46430
// for i in kinds do
46369: LD_ADDR_VAR 0 4
46373: PUSH
46374: LD_VAR 0 2
46378: PUSH
46379: FOR_IN
46380: IFFALSE 46428
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46382: LD_ADDR_EXP 130
46386: PUSH
46387: LD_EXP 130
46391: PPUSH
46392: LD_VAR 0 1
46396: PUSH
46397: LD_EXP 130
46401: PUSH
46402: LD_VAR 0 1
46406: ARRAY
46407: PUSH
46408: LD_INT 1
46410: PLUS
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: PPUSH
46416: LD_VAR 0 4
46420: PPUSH
46421: CALL 57193 0 3
46425: ST_TO_ADDR
46426: GO 46379
46428: POP
46429: POP
// end ;
46430: LD_VAR 0 3
46434: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46435: LD_INT 0
46437: PPUSH
// if not mc_bases or not base or not areas then
46438: LD_EXP 96
46442: NOT
46443: PUSH
46444: LD_VAR 0 1
46448: NOT
46449: OR
46450: PUSH
46451: LD_VAR 0 2
46455: NOT
46456: OR
46457: IFFALSE 46461
// exit ;
46459: GO 46486
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46461: LD_ADDR_EXP 114
46465: PUSH
46466: LD_EXP 114
46470: PPUSH
46471: LD_VAR 0 1
46475: PPUSH
46476: LD_VAR 0 2
46480: PPUSH
46481: CALL_OW 1
46485: ST_TO_ADDR
// end ;
46486: LD_VAR 0 3
46490: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46491: LD_INT 0
46493: PPUSH
// if not mc_bases or not base or not teleports_exit then
46494: LD_EXP 96
46498: NOT
46499: PUSH
46500: LD_VAR 0 1
46504: NOT
46505: OR
46506: PUSH
46507: LD_VAR 0 2
46511: NOT
46512: OR
46513: IFFALSE 46517
// exit ;
46515: GO 46542
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46517: LD_ADDR_EXP 131
46521: PUSH
46522: LD_EXP 131
46526: PPUSH
46527: LD_VAR 0 1
46531: PPUSH
46532: LD_VAR 0 2
46536: PPUSH
46537: CALL_OW 1
46541: ST_TO_ADDR
// end ;
46542: LD_VAR 0 3
46546: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46547: LD_INT 0
46549: PPUSH
46550: PPUSH
46551: PPUSH
// if not mc_bases or not base or not ext_list then
46552: LD_EXP 96
46556: NOT
46557: PUSH
46558: LD_VAR 0 1
46562: NOT
46563: OR
46564: PUSH
46565: LD_VAR 0 5
46569: NOT
46570: OR
46571: IFFALSE 46575
// exit ;
46573: GO 46748
// tmp := GetFacExtXYD ( x , y , d ) ;
46575: LD_ADDR_VAR 0 8
46579: PUSH
46580: LD_VAR 0 2
46584: PPUSH
46585: LD_VAR 0 3
46589: PPUSH
46590: LD_VAR 0 4
46594: PPUSH
46595: CALL 86527 0 3
46599: ST_TO_ADDR
// if not tmp then
46600: LD_VAR 0 8
46604: NOT
46605: IFFALSE 46609
// exit ;
46607: GO 46748
// for i in tmp do
46609: LD_ADDR_VAR 0 7
46613: PUSH
46614: LD_VAR 0 8
46618: PUSH
46619: FOR_IN
46620: IFFALSE 46746
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46622: LD_ADDR_EXP 101
46626: PUSH
46627: LD_EXP 101
46631: PPUSH
46632: LD_VAR 0 1
46636: PPUSH
46637: LD_EXP 101
46641: PUSH
46642: LD_VAR 0 1
46646: ARRAY
46647: PPUSH
46648: LD_EXP 101
46652: PUSH
46653: LD_VAR 0 1
46657: ARRAY
46658: PUSH
46659: LD_INT 1
46661: PLUS
46662: PPUSH
46663: LD_VAR 0 5
46667: PUSH
46668: LD_INT 1
46670: ARRAY
46671: PUSH
46672: LD_VAR 0 7
46676: PUSH
46677: LD_INT 1
46679: ARRAY
46680: PUSH
46681: LD_VAR 0 7
46685: PUSH
46686: LD_INT 2
46688: ARRAY
46689: PUSH
46690: LD_VAR 0 7
46694: PUSH
46695: LD_INT 3
46697: ARRAY
46698: PUSH
46699: EMPTY
46700: LIST
46701: LIST
46702: LIST
46703: LIST
46704: PPUSH
46705: CALL_OW 2
46709: PPUSH
46710: CALL_OW 1
46714: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46715: LD_ADDR_VAR 0 5
46719: PUSH
46720: LD_VAR 0 5
46724: PPUSH
46725: LD_INT 1
46727: PPUSH
46728: CALL_OW 3
46732: ST_TO_ADDR
// if not ext_list then
46733: LD_VAR 0 5
46737: NOT
46738: IFFALSE 46744
// exit ;
46740: POP
46741: POP
46742: GO 46748
// end ;
46744: GO 46619
46746: POP
46747: POP
// end ;
46748: LD_VAR 0 6
46752: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46753: LD_INT 0
46755: PPUSH
// if not mc_bases or not base or not weapon_list then
46756: LD_EXP 96
46760: NOT
46761: PUSH
46762: LD_VAR 0 1
46766: NOT
46767: OR
46768: PUSH
46769: LD_VAR 0 2
46773: NOT
46774: OR
46775: IFFALSE 46779
// exit ;
46777: GO 46804
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46779: LD_ADDR_EXP 135
46783: PUSH
46784: LD_EXP 135
46788: PPUSH
46789: LD_VAR 0 1
46793: PPUSH
46794: LD_VAR 0 2
46798: PPUSH
46799: CALL_OW 1
46803: ST_TO_ADDR
// end ;
46804: LD_VAR 0 3
46808: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46809: LD_INT 0
46811: PPUSH
// if not mc_bases or not base or not tech_list then
46812: LD_EXP 96
46816: NOT
46817: PUSH
46818: LD_VAR 0 1
46822: NOT
46823: OR
46824: PUSH
46825: LD_VAR 0 2
46829: NOT
46830: OR
46831: IFFALSE 46835
// exit ;
46833: GO 46860
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46835: LD_ADDR_EXP 123
46839: PUSH
46840: LD_EXP 123
46844: PPUSH
46845: LD_VAR 0 1
46849: PPUSH
46850: LD_VAR 0 2
46854: PPUSH
46855: CALL_OW 1
46859: ST_TO_ADDR
// end ;
46860: LD_VAR 0 3
46864: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46865: LD_INT 0
46867: PPUSH
// if not mc_bases or not parking_area or not base then
46868: LD_EXP 96
46872: NOT
46873: PUSH
46874: LD_VAR 0 2
46878: NOT
46879: OR
46880: PUSH
46881: LD_VAR 0 1
46885: NOT
46886: OR
46887: IFFALSE 46891
// exit ;
46889: GO 46916
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46891: LD_ADDR_EXP 120
46895: PUSH
46896: LD_EXP 120
46900: PPUSH
46901: LD_VAR 0 1
46905: PPUSH
46906: LD_VAR 0 2
46910: PPUSH
46911: CALL_OW 1
46915: ST_TO_ADDR
// end ;
46916: LD_VAR 0 3
46920: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46921: LD_INT 0
46923: PPUSH
// if not mc_bases or not base or not scan_area then
46924: LD_EXP 96
46928: NOT
46929: PUSH
46930: LD_VAR 0 1
46934: NOT
46935: OR
46936: PUSH
46937: LD_VAR 0 2
46941: NOT
46942: OR
46943: IFFALSE 46947
// exit ;
46945: GO 46972
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46947: LD_ADDR_EXP 121
46951: PUSH
46952: LD_EXP 121
46956: PPUSH
46957: LD_VAR 0 1
46961: PPUSH
46962: LD_VAR 0 2
46966: PPUSH
46967: CALL_OW 1
46971: ST_TO_ADDR
// end ;
46972: LD_VAR 0 3
46976: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46977: LD_INT 0
46979: PPUSH
46980: PPUSH
// if not mc_bases or not base then
46981: LD_EXP 96
46985: NOT
46986: PUSH
46987: LD_VAR 0 1
46991: NOT
46992: OR
46993: IFFALSE 46997
// exit ;
46995: GO 47061
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46997: LD_ADDR_VAR 0 3
47001: PUSH
47002: LD_INT 1
47004: PUSH
47005: LD_INT 2
47007: PUSH
47008: LD_INT 3
47010: PUSH
47011: LD_INT 4
47013: PUSH
47014: LD_INT 11
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: LIST
47021: LIST
47022: LIST
47023: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
47024: LD_ADDR_EXP 123
47028: PUSH
47029: LD_EXP 123
47033: PPUSH
47034: LD_VAR 0 1
47038: PPUSH
47039: LD_EXP 123
47043: PUSH
47044: LD_VAR 0 1
47048: ARRAY
47049: PUSH
47050: LD_VAR 0 3
47054: DIFF
47055: PPUSH
47056: CALL_OW 1
47060: ST_TO_ADDR
// end ;
47061: LD_VAR 0 2
47065: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47066: LD_INT 0
47068: PPUSH
// result := mc_vehicles [ base ] ;
47069: LD_ADDR_VAR 0 3
47073: PUSH
47074: LD_EXP 115
47078: PUSH
47079: LD_VAR 0 1
47083: ARRAY
47084: ST_TO_ADDR
// if onlyCombat then
47085: LD_VAR 0 2
47089: IFFALSE 47267
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47091: LD_ADDR_VAR 0 3
47095: PUSH
47096: LD_VAR 0 3
47100: PUSH
47101: LD_VAR 0 3
47105: PPUSH
47106: LD_INT 2
47108: PUSH
47109: LD_INT 34
47111: PUSH
47112: LD_INT 12
47114: PUSH
47115: EMPTY
47116: LIST
47117: LIST
47118: PUSH
47119: LD_INT 34
47121: PUSH
47122: LD_INT 51
47124: PUSH
47125: EMPTY
47126: LIST
47127: LIST
47128: PUSH
47129: LD_INT 34
47131: PUSH
47132: LD_EXP 75
47136: PUSH
47137: EMPTY
47138: LIST
47139: LIST
47140: PUSH
47141: LD_INT 34
47143: PUSH
47144: LD_INT 32
47146: PUSH
47147: EMPTY
47148: LIST
47149: LIST
47150: PUSH
47151: LD_INT 34
47153: PUSH
47154: LD_INT 13
47156: PUSH
47157: EMPTY
47158: LIST
47159: LIST
47160: PUSH
47161: LD_INT 34
47163: PUSH
47164: LD_INT 52
47166: PUSH
47167: EMPTY
47168: LIST
47169: LIST
47170: PUSH
47171: LD_INT 34
47173: PUSH
47174: LD_EXP 80
47178: PUSH
47179: EMPTY
47180: LIST
47181: LIST
47182: PUSH
47183: LD_INT 34
47185: PUSH
47186: LD_INT 14
47188: PUSH
47189: EMPTY
47190: LIST
47191: LIST
47192: PUSH
47193: LD_INT 34
47195: PUSH
47196: LD_INT 53
47198: PUSH
47199: EMPTY
47200: LIST
47201: LIST
47202: PUSH
47203: LD_INT 34
47205: PUSH
47206: LD_EXP 74
47210: PUSH
47211: EMPTY
47212: LIST
47213: LIST
47214: PUSH
47215: LD_INT 34
47217: PUSH
47218: LD_INT 31
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: PUSH
47225: LD_INT 34
47227: PUSH
47228: LD_INT 48
47230: PUSH
47231: EMPTY
47232: LIST
47233: LIST
47234: PUSH
47235: LD_INT 34
47237: PUSH
47238: LD_INT 8
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: PUSH
47245: EMPTY
47246: LIST
47247: LIST
47248: LIST
47249: LIST
47250: LIST
47251: LIST
47252: LIST
47253: LIST
47254: LIST
47255: LIST
47256: LIST
47257: LIST
47258: LIST
47259: LIST
47260: PPUSH
47261: CALL_OW 72
47265: DIFF
47266: ST_TO_ADDR
// end ; end_of_file
47267: LD_VAR 0 3
47271: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47272: LD_INT 0
47274: PPUSH
47275: PPUSH
47276: PPUSH
// if not mc_bases or not skirmish then
47277: LD_EXP 96
47281: NOT
47282: PUSH
47283: LD_EXP 94
47287: NOT
47288: OR
47289: IFFALSE 47293
// exit ;
47291: GO 47458
// for i = 1 to mc_bases do
47293: LD_ADDR_VAR 0 4
47297: PUSH
47298: DOUBLE
47299: LD_INT 1
47301: DEC
47302: ST_TO_ADDR
47303: LD_EXP 96
47307: PUSH
47308: FOR_TO
47309: IFFALSE 47456
// begin if sci in mc_bases [ i ] then
47311: LD_VAR 0 2
47315: PUSH
47316: LD_EXP 96
47320: PUSH
47321: LD_VAR 0 4
47325: ARRAY
47326: IN
47327: IFFALSE 47454
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47329: LD_ADDR_EXP 125
47333: PUSH
47334: LD_EXP 125
47338: PPUSH
47339: LD_VAR 0 4
47343: PUSH
47344: LD_EXP 125
47348: PUSH
47349: LD_VAR 0 4
47353: ARRAY
47354: PUSH
47355: LD_INT 1
47357: PLUS
47358: PUSH
47359: EMPTY
47360: LIST
47361: LIST
47362: PPUSH
47363: LD_VAR 0 1
47367: PPUSH
47368: CALL 57193 0 3
47372: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47373: LD_ADDR_VAR 0 5
47377: PUSH
47378: LD_EXP 96
47382: PUSH
47383: LD_VAR 0 4
47387: ARRAY
47388: PPUSH
47389: LD_INT 2
47391: PUSH
47392: LD_INT 30
47394: PUSH
47395: LD_INT 0
47397: PUSH
47398: EMPTY
47399: LIST
47400: LIST
47401: PUSH
47402: LD_INT 30
47404: PUSH
47405: LD_INT 1
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: PUSH
47412: EMPTY
47413: LIST
47414: LIST
47415: LIST
47416: PPUSH
47417: CALL_OW 72
47421: PPUSH
47422: LD_VAR 0 1
47426: PPUSH
47427: CALL_OW 74
47431: ST_TO_ADDR
// if tmp then
47432: LD_VAR 0 5
47436: IFFALSE 47452
// ComStandNearbyBuilding ( ape , tmp ) ;
47438: LD_VAR 0 1
47442: PPUSH
47443: LD_VAR 0 5
47447: PPUSH
47448: CALL 53618 0 2
// break ;
47452: GO 47456
// end ; end ;
47454: GO 47308
47456: POP
47457: POP
// end ;
47458: LD_VAR 0 3
47462: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47463: LD_INT 0
47465: PPUSH
47466: PPUSH
47467: PPUSH
// if not mc_bases or not skirmish then
47468: LD_EXP 96
47472: NOT
47473: PUSH
47474: LD_EXP 94
47478: NOT
47479: OR
47480: IFFALSE 47484
// exit ;
47482: GO 47573
// for i = 1 to mc_bases do
47484: LD_ADDR_VAR 0 4
47488: PUSH
47489: DOUBLE
47490: LD_INT 1
47492: DEC
47493: ST_TO_ADDR
47494: LD_EXP 96
47498: PUSH
47499: FOR_TO
47500: IFFALSE 47571
// begin if building in mc_busy_turret_list [ i ] then
47502: LD_VAR 0 1
47506: PUSH
47507: LD_EXP 106
47511: PUSH
47512: LD_VAR 0 4
47516: ARRAY
47517: IN
47518: IFFALSE 47569
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47520: LD_ADDR_VAR 0 5
47524: PUSH
47525: LD_EXP 106
47529: PUSH
47530: LD_VAR 0 4
47534: ARRAY
47535: PUSH
47536: LD_VAR 0 1
47540: DIFF
47541: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47542: LD_ADDR_EXP 106
47546: PUSH
47547: LD_EXP 106
47551: PPUSH
47552: LD_VAR 0 4
47556: PPUSH
47557: LD_VAR 0 5
47561: PPUSH
47562: CALL_OW 1
47566: ST_TO_ADDR
// break ;
47567: GO 47571
// end ; end ;
47569: GO 47499
47571: POP
47572: POP
// end ;
47573: LD_VAR 0 3
47577: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47578: LD_INT 0
47580: PPUSH
47581: PPUSH
47582: PPUSH
// if not mc_bases or not skirmish then
47583: LD_EXP 96
47587: NOT
47588: PUSH
47589: LD_EXP 94
47593: NOT
47594: OR
47595: IFFALSE 47599
// exit ;
47597: GO 47798
// for i = 1 to mc_bases do
47599: LD_ADDR_VAR 0 5
47603: PUSH
47604: DOUBLE
47605: LD_INT 1
47607: DEC
47608: ST_TO_ADDR
47609: LD_EXP 96
47613: PUSH
47614: FOR_TO
47615: IFFALSE 47796
// if building in mc_bases [ i ] then
47617: LD_VAR 0 1
47621: PUSH
47622: LD_EXP 96
47626: PUSH
47627: LD_VAR 0 5
47631: ARRAY
47632: IN
47633: IFFALSE 47794
// begin tmp := mc_bases [ i ] diff building ;
47635: LD_ADDR_VAR 0 6
47639: PUSH
47640: LD_EXP 96
47644: PUSH
47645: LD_VAR 0 5
47649: ARRAY
47650: PUSH
47651: LD_VAR 0 1
47655: DIFF
47656: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47657: LD_ADDR_EXP 96
47661: PUSH
47662: LD_EXP 96
47666: PPUSH
47667: LD_VAR 0 5
47671: PPUSH
47672: LD_VAR 0 6
47676: PPUSH
47677: CALL_OW 1
47681: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47682: LD_VAR 0 1
47686: PUSH
47687: LD_EXP 104
47691: PUSH
47692: LD_VAR 0 5
47696: ARRAY
47697: IN
47698: IFFALSE 47737
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47700: LD_ADDR_EXP 104
47704: PUSH
47705: LD_EXP 104
47709: PPUSH
47710: LD_VAR 0 5
47714: PPUSH
47715: LD_EXP 104
47719: PUSH
47720: LD_VAR 0 5
47724: ARRAY
47725: PUSH
47726: LD_VAR 0 1
47730: DIFF
47731: PPUSH
47732: CALL_OW 1
47736: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47737: LD_VAR 0 1
47741: PUSH
47742: LD_EXP 105
47746: PUSH
47747: LD_VAR 0 5
47751: ARRAY
47752: IN
47753: IFFALSE 47792
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47755: LD_ADDR_EXP 105
47759: PUSH
47760: LD_EXP 105
47764: PPUSH
47765: LD_VAR 0 5
47769: PPUSH
47770: LD_EXP 105
47774: PUSH
47775: LD_VAR 0 5
47779: ARRAY
47780: PUSH
47781: LD_VAR 0 1
47785: DIFF
47786: PPUSH
47787: CALL_OW 1
47791: ST_TO_ADDR
// break ;
47792: GO 47796
// end ;
47794: GO 47614
47796: POP
47797: POP
// end ;
47798: LD_VAR 0 4
47802: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47803: LD_INT 0
47805: PPUSH
47806: PPUSH
47807: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47808: LD_EXP 96
47812: NOT
47813: PUSH
47814: LD_EXP 94
47818: NOT
47819: OR
47820: PUSH
47821: LD_VAR 0 3
47825: PUSH
47826: LD_EXP 122
47830: IN
47831: NOT
47832: OR
47833: IFFALSE 47837
// exit ;
47835: GO 47960
// for i = 1 to mc_vehicles do
47837: LD_ADDR_VAR 0 6
47841: PUSH
47842: DOUBLE
47843: LD_INT 1
47845: DEC
47846: ST_TO_ADDR
47847: LD_EXP 115
47851: PUSH
47852: FOR_TO
47853: IFFALSE 47958
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47855: LD_VAR 0 2
47859: PUSH
47860: LD_EXP 115
47864: PUSH
47865: LD_VAR 0 6
47869: ARRAY
47870: IN
47871: PUSH
47872: LD_VAR 0 1
47876: PUSH
47877: LD_EXP 115
47881: PUSH
47882: LD_VAR 0 6
47886: ARRAY
47887: IN
47888: OR
47889: IFFALSE 47956
// begin tmp := mc_vehicles [ i ] diff old ;
47891: LD_ADDR_VAR 0 7
47895: PUSH
47896: LD_EXP 115
47900: PUSH
47901: LD_VAR 0 6
47905: ARRAY
47906: PUSH
47907: LD_VAR 0 2
47911: DIFF
47912: ST_TO_ADDR
// tmp := tmp diff new ;
47913: LD_ADDR_VAR 0 7
47917: PUSH
47918: LD_VAR 0 7
47922: PUSH
47923: LD_VAR 0 1
47927: DIFF
47928: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47929: LD_ADDR_EXP 115
47933: PUSH
47934: LD_EXP 115
47938: PPUSH
47939: LD_VAR 0 6
47943: PPUSH
47944: LD_VAR 0 7
47948: PPUSH
47949: CALL_OW 1
47953: ST_TO_ADDR
// break ;
47954: GO 47958
// end ;
47956: GO 47852
47958: POP
47959: POP
// end ;
47960: LD_VAR 0 5
47964: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47965: LD_INT 0
47967: PPUSH
47968: PPUSH
47969: PPUSH
47970: PPUSH
// if not mc_bases or not skirmish then
47971: LD_EXP 96
47975: NOT
47976: PUSH
47977: LD_EXP 94
47981: NOT
47982: OR
47983: IFFALSE 47987
// exit ;
47985: GO 48379
// side := GetSide ( vehicle ) ;
47987: LD_ADDR_VAR 0 5
47991: PUSH
47992: LD_VAR 0 1
47996: PPUSH
47997: CALL_OW 255
48001: ST_TO_ADDR
// for i = 1 to mc_bases do
48002: LD_ADDR_VAR 0 4
48006: PUSH
48007: DOUBLE
48008: LD_INT 1
48010: DEC
48011: ST_TO_ADDR
48012: LD_EXP 96
48016: PUSH
48017: FOR_TO
48018: IFFALSE 48377
// begin if factory in mc_bases [ i ] then
48020: LD_VAR 0 2
48024: PUSH
48025: LD_EXP 96
48029: PUSH
48030: LD_VAR 0 4
48034: ARRAY
48035: IN
48036: IFFALSE 48375
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48038: LD_EXP 118
48042: PUSH
48043: LD_VAR 0 4
48047: ARRAY
48048: PUSH
48049: LD_EXP 107
48053: PUSH
48054: LD_VAR 0 4
48058: ARRAY
48059: LESS
48060: PUSH
48061: LD_VAR 0 1
48065: PPUSH
48066: CALL_OW 264
48070: PUSH
48071: LD_INT 31
48073: PUSH
48074: LD_INT 32
48076: PUSH
48077: LD_INT 51
48079: PUSH
48080: LD_EXP 75
48084: PUSH
48085: LD_INT 12
48087: PUSH
48088: LD_INT 30
48090: PUSH
48091: LD_EXP 74
48095: PUSH
48096: LD_INT 11
48098: PUSH
48099: LD_INT 53
48101: PUSH
48102: LD_INT 14
48104: PUSH
48105: LD_EXP 78
48109: PUSH
48110: LD_INT 29
48112: PUSH
48113: LD_EXP 76
48117: PUSH
48118: LD_INT 13
48120: PUSH
48121: LD_INT 52
48123: PUSH
48124: LD_EXP 80
48128: PUSH
48129: LD_INT 48
48131: PUSH
48132: LD_INT 8
48134: PUSH
48135: EMPTY
48136: LIST
48137: LIST
48138: LIST
48139: LIST
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: LIST
48153: LIST
48154: IN
48155: NOT
48156: AND
48157: IFFALSE 48205
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48159: LD_ADDR_EXP 118
48163: PUSH
48164: LD_EXP 118
48168: PPUSH
48169: LD_VAR 0 4
48173: PUSH
48174: LD_EXP 118
48178: PUSH
48179: LD_VAR 0 4
48183: ARRAY
48184: PUSH
48185: LD_INT 1
48187: PLUS
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PPUSH
48193: LD_VAR 0 1
48197: PPUSH
48198: CALL 57193 0 3
48202: ST_TO_ADDR
48203: GO 48249
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48205: LD_ADDR_EXP 115
48209: PUSH
48210: LD_EXP 115
48214: PPUSH
48215: LD_VAR 0 4
48219: PUSH
48220: LD_EXP 115
48224: PUSH
48225: LD_VAR 0 4
48229: ARRAY
48230: PUSH
48231: LD_INT 1
48233: PLUS
48234: PUSH
48235: EMPTY
48236: LIST
48237: LIST
48238: PPUSH
48239: LD_VAR 0 1
48243: PPUSH
48244: CALL 57193 0 3
48248: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48249: LD_VAR 0 1
48253: PPUSH
48254: CALL_OW 263
48258: PUSH
48259: LD_INT 2
48261: EQUAL
48262: IFFALSE 48291
// begin repeat wait ( 0 0$3 ) ;
48264: LD_INT 105
48266: PPUSH
48267: CALL_OW 67
// Connect ( vehicle ) ;
48271: LD_VAR 0 1
48275: PPUSH
48276: CALL 60164 0 1
// until IsControledBy ( vehicle ) ;
48280: LD_VAR 0 1
48284: PPUSH
48285: CALL_OW 312
48289: IFFALSE 48264
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48291: LD_VAR 0 1
48295: PPUSH
48296: LD_EXP 120
48300: PUSH
48301: LD_VAR 0 4
48305: ARRAY
48306: PPUSH
48307: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48311: LD_VAR 0 1
48315: PPUSH
48316: CALL_OW 263
48320: PUSH
48321: LD_INT 1
48323: NONEQUAL
48324: IFFALSE 48328
// break ;
48326: GO 48377
// repeat wait ( 0 0$1 ) ;
48328: LD_INT 35
48330: PPUSH
48331: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48335: LD_VAR 0 1
48339: PPUSH
48340: LD_EXP 120
48344: PUSH
48345: LD_VAR 0 4
48349: ARRAY
48350: PPUSH
48351: CALL_OW 308
48355: IFFALSE 48328
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48357: LD_VAR 0 1
48361: PPUSH
48362: CALL_OW 311
48366: PPUSH
48367: CALL_OW 121
// exit ;
48371: POP
48372: POP
48373: GO 48379
// end ; end ;
48375: GO 48017
48377: POP
48378: POP
// end ;
48379: LD_VAR 0 3
48383: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48384: LD_INT 0
48386: PPUSH
48387: PPUSH
48388: PPUSH
48389: PPUSH
// if not mc_bases or not skirmish then
48390: LD_EXP 96
48394: NOT
48395: PUSH
48396: LD_EXP 94
48400: NOT
48401: OR
48402: IFFALSE 48406
// exit ;
48404: GO 48759
// repeat wait ( 0 0$1 ) ;
48406: LD_INT 35
48408: PPUSH
48409: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48413: LD_VAR 0 2
48417: PPUSH
48418: LD_VAR 0 3
48422: PPUSH
48423: CALL_OW 284
48427: IFFALSE 48406
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48429: LD_VAR 0 2
48433: PPUSH
48434: LD_VAR 0 3
48438: PPUSH
48439: CALL_OW 283
48443: PUSH
48444: LD_INT 4
48446: EQUAL
48447: IFFALSE 48451
// exit ;
48449: GO 48759
// for i = 1 to mc_bases do
48451: LD_ADDR_VAR 0 7
48455: PUSH
48456: DOUBLE
48457: LD_INT 1
48459: DEC
48460: ST_TO_ADDR
48461: LD_EXP 96
48465: PUSH
48466: FOR_TO
48467: IFFALSE 48757
// begin if mc_crates_area [ i ] then
48469: LD_EXP 114
48473: PUSH
48474: LD_VAR 0 7
48478: ARRAY
48479: IFFALSE 48590
// for j in mc_crates_area [ i ] do
48481: LD_ADDR_VAR 0 8
48485: PUSH
48486: LD_EXP 114
48490: PUSH
48491: LD_VAR 0 7
48495: ARRAY
48496: PUSH
48497: FOR_IN
48498: IFFALSE 48588
// if InArea ( x , y , j ) then
48500: LD_VAR 0 2
48504: PPUSH
48505: LD_VAR 0 3
48509: PPUSH
48510: LD_VAR 0 8
48514: PPUSH
48515: CALL_OW 309
48519: IFFALSE 48586
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48521: LD_ADDR_EXP 112
48525: PUSH
48526: LD_EXP 112
48530: PPUSH
48531: LD_VAR 0 7
48535: PUSH
48536: LD_EXP 112
48540: PUSH
48541: LD_VAR 0 7
48545: ARRAY
48546: PUSH
48547: LD_INT 1
48549: PLUS
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: PPUSH
48555: LD_VAR 0 4
48559: PUSH
48560: LD_VAR 0 2
48564: PUSH
48565: LD_VAR 0 3
48569: PUSH
48570: EMPTY
48571: LIST
48572: LIST
48573: LIST
48574: PPUSH
48575: CALL 57193 0 3
48579: ST_TO_ADDR
// exit ;
48580: POP
48581: POP
48582: POP
48583: POP
48584: GO 48759
// end ;
48586: GO 48497
48588: POP
48589: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48590: LD_ADDR_VAR 0 9
48594: PUSH
48595: LD_EXP 96
48599: PUSH
48600: LD_VAR 0 7
48604: ARRAY
48605: PPUSH
48606: LD_INT 2
48608: PUSH
48609: LD_INT 30
48611: PUSH
48612: LD_INT 0
48614: PUSH
48615: EMPTY
48616: LIST
48617: LIST
48618: PUSH
48619: LD_INT 30
48621: PUSH
48622: LD_INT 1
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: LIST
48633: PPUSH
48634: CALL_OW 72
48638: ST_TO_ADDR
// if not depot then
48639: LD_VAR 0 9
48643: NOT
48644: IFFALSE 48648
// continue ;
48646: GO 48466
// for j in depot do
48648: LD_ADDR_VAR 0 8
48652: PUSH
48653: LD_VAR 0 9
48657: PUSH
48658: FOR_IN
48659: IFFALSE 48753
// if GetDistUnitXY ( j , x , y ) < 30 then
48661: LD_VAR 0 8
48665: PPUSH
48666: LD_VAR 0 2
48670: PPUSH
48671: LD_VAR 0 3
48675: PPUSH
48676: CALL_OW 297
48680: PUSH
48681: LD_INT 30
48683: LESS
48684: IFFALSE 48751
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48686: LD_ADDR_EXP 112
48690: PUSH
48691: LD_EXP 112
48695: PPUSH
48696: LD_VAR 0 7
48700: PUSH
48701: LD_EXP 112
48705: PUSH
48706: LD_VAR 0 7
48710: ARRAY
48711: PUSH
48712: LD_INT 1
48714: PLUS
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: PPUSH
48720: LD_VAR 0 4
48724: PUSH
48725: LD_VAR 0 2
48729: PUSH
48730: LD_VAR 0 3
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: LIST
48739: PPUSH
48740: CALL 57193 0 3
48744: ST_TO_ADDR
// exit ;
48745: POP
48746: POP
48747: POP
48748: POP
48749: GO 48759
// end ;
48751: GO 48658
48753: POP
48754: POP
// end ;
48755: GO 48466
48757: POP
48758: POP
// end ;
48759: LD_VAR 0 6
48763: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48764: LD_INT 0
48766: PPUSH
48767: PPUSH
48768: PPUSH
48769: PPUSH
// if not mc_bases or not skirmish then
48770: LD_EXP 96
48774: NOT
48775: PUSH
48776: LD_EXP 94
48780: NOT
48781: OR
48782: IFFALSE 48786
// exit ;
48784: GO 49063
// side := GetSide ( lab ) ;
48786: LD_ADDR_VAR 0 4
48790: PUSH
48791: LD_VAR 0 2
48795: PPUSH
48796: CALL_OW 255
48800: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48801: LD_VAR 0 4
48805: PUSH
48806: LD_EXP 122
48810: IN
48811: NOT
48812: PUSH
48813: LD_EXP 123
48817: NOT
48818: OR
48819: PUSH
48820: LD_EXP 96
48824: NOT
48825: OR
48826: IFFALSE 48830
// exit ;
48828: GO 49063
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48830: LD_ADDR_EXP 123
48834: PUSH
48835: LD_EXP 123
48839: PPUSH
48840: LD_VAR 0 4
48844: PPUSH
48845: LD_EXP 123
48849: PUSH
48850: LD_VAR 0 4
48854: ARRAY
48855: PUSH
48856: LD_VAR 0 1
48860: DIFF
48861: PPUSH
48862: CALL_OW 1
48866: ST_TO_ADDR
// for i = 1 to mc_bases do
48867: LD_ADDR_VAR 0 5
48871: PUSH
48872: DOUBLE
48873: LD_INT 1
48875: DEC
48876: ST_TO_ADDR
48877: LD_EXP 96
48881: PUSH
48882: FOR_TO
48883: IFFALSE 49061
// begin if lab in mc_bases [ i ] then
48885: LD_VAR 0 2
48889: PUSH
48890: LD_EXP 96
48894: PUSH
48895: LD_VAR 0 5
48899: ARRAY
48900: IN
48901: IFFALSE 49059
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48903: LD_VAR 0 1
48907: PUSH
48908: LD_INT 11
48910: PUSH
48911: LD_INT 4
48913: PUSH
48914: LD_INT 3
48916: PUSH
48917: LD_INT 2
48919: PUSH
48920: EMPTY
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: IN
48926: PUSH
48927: LD_EXP 126
48931: PUSH
48932: LD_VAR 0 5
48936: ARRAY
48937: AND
48938: IFFALSE 49059
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48940: LD_ADDR_VAR 0 6
48944: PUSH
48945: LD_EXP 126
48949: PUSH
48950: LD_VAR 0 5
48954: ARRAY
48955: PUSH
48956: LD_INT 1
48958: ARRAY
48959: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48960: LD_ADDR_EXP 126
48964: PUSH
48965: LD_EXP 126
48969: PPUSH
48970: LD_VAR 0 5
48974: PPUSH
48975: EMPTY
48976: PPUSH
48977: CALL_OW 1
48981: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48982: LD_VAR 0 6
48986: PPUSH
48987: LD_INT 0
48989: PPUSH
48990: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48994: LD_VAR 0 6
48998: PPUSH
48999: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
49003: LD_ADDR_EXP 125
49007: PUSH
49008: LD_EXP 125
49012: PPUSH
49013: LD_VAR 0 5
49017: PPUSH
49018: LD_EXP 125
49022: PUSH
49023: LD_VAR 0 5
49027: ARRAY
49028: PPUSH
49029: LD_INT 1
49031: PPUSH
49032: LD_VAR 0 6
49036: PPUSH
49037: CALL_OW 2
49041: PPUSH
49042: CALL_OW 1
49046: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49047: LD_VAR 0 5
49051: PPUSH
49052: LD_INT 112
49054: PPUSH
49055: CALL 25582 0 2
// end ; end ; end ;
49059: GO 48882
49061: POP
49062: POP
// end ;
49063: LD_VAR 0 3
49067: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49068: LD_INT 0
49070: PPUSH
49071: PPUSH
49072: PPUSH
49073: PPUSH
49074: PPUSH
49075: PPUSH
49076: PPUSH
49077: PPUSH
// if not mc_bases or not skirmish then
49078: LD_EXP 96
49082: NOT
49083: PUSH
49084: LD_EXP 94
49088: NOT
49089: OR
49090: IFFALSE 49094
// exit ;
49092: GO 50465
// for i = 1 to mc_bases do
49094: LD_ADDR_VAR 0 3
49098: PUSH
49099: DOUBLE
49100: LD_INT 1
49102: DEC
49103: ST_TO_ADDR
49104: LD_EXP 96
49108: PUSH
49109: FOR_TO
49110: IFFALSE 50463
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49112: LD_VAR 0 1
49116: PUSH
49117: LD_EXP 96
49121: PUSH
49122: LD_VAR 0 3
49126: ARRAY
49127: IN
49128: PUSH
49129: LD_VAR 0 1
49133: PUSH
49134: LD_EXP 103
49138: PUSH
49139: LD_VAR 0 3
49143: ARRAY
49144: IN
49145: OR
49146: PUSH
49147: LD_VAR 0 1
49151: PUSH
49152: LD_EXP 118
49156: PUSH
49157: LD_VAR 0 3
49161: ARRAY
49162: IN
49163: OR
49164: PUSH
49165: LD_VAR 0 1
49169: PUSH
49170: LD_EXP 115
49174: PUSH
49175: LD_VAR 0 3
49179: ARRAY
49180: IN
49181: OR
49182: PUSH
49183: LD_VAR 0 1
49187: PUSH
49188: LD_EXP 125
49192: PUSH
49193: LD_VAR 0 3
49197: ARRAY
49198: IN
49199: OR
49200: PUSH
49201: LD_VAR 0 1
49205: PUSH
49206: LD_EXP 126
49210: PUSH
49211: LD_VAR 0 3
49215: ARRAY
49216: IN
49217: OR
49218: IFFALSE 50461
// begin if un in mc_ape [ i ] then
49220: LD_VAR 0 1
49224: PUSH
49225: LD_EXP 125
49229: PUSH
49230: LD_VAR 0 3
49234: ARRAY
49235: IN
49236: IFFALSE 49275
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49238: LD_ADDR_EXP 125
49242: PUSH
49243: LD_EXP 125
49247: PPUSH
49248: LD_VAR 0 3
49252: PPUSH
49253: LD_EXP 125
49257: PUSH
49258: LD_VAR 0 3
49262: ARRAY
49263: PUSH
49264: LD_VAR 0 1
49268: DIFF
49269: PPUSH
49270: CALL_OW 1
49274: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49275: LD_VAR 0 1
49279: PUSH
49280: LD_EXP 126
49284: PUSH
49285: LD_VAR 0 3
49289: ARRAY
49290: IN
49291: IFFALSE 49315
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49293: LD_ADDR_EXP 126
49297: PUSH
49298: LD_EXP 126
49302: PPUSH
49303: LD_VAR 0 3
49307: PPUSH
49308: EMPTY
49309: PPUSH
49310: CALL_OW 1
49314: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49315: LD_VAR 0 1
49319: PPUSH
49320: CALL_OW 247
49324: PUSH
49325: LD_INT 2
49327: EQUAL
49328: PUSH
49329: LD_VAR 0 1
49333: PPUSH
49334: CALL_OW 110
49338: PUSH
49339: LD_INT 20
49341: EQUAL
49342: PUSH
49343: LD_VAR 0 1
49347: PUSH
49348: LD_EXP 118
49352: PUSH
49353: LD_VAR 0 3
49357: ARRAY
49358: IN
49359: OR
49360: PUSH
49361: LD_VAR 0 1
49365: PPUSH
49366: CALL_OW 264
49370: PUSH
49371: LD_INT 12
49373: PUSH
49374: LD_INT 51
49376: PUSH
49377: LD_EXP 75
49381: PUSH
49382: LD_INT 32
49384: PUSH
49385: LD_INT 13
49387: PUSH
49388: LD_INT 52
49390: PUSH
49391: LD_INT 31
49393: PUSH
49394: EMPTY
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: IN
49403: OR
49404: AND
49405: IFFALSE 49713
// begin if un in mc_defender [ i ] then
49407: LD_VAR 0 1
49411: PUSH
49412: LD_EXP 118
49416: PUSH
49417: LD_VAR 0 3
49421: ARRAY
49422: IN
49423: IFFALSE 49462
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49425: LD_ADDR_EXP 118
49429: PUSH
49430: LD_EXP 118
49434: PPUSH
49435: LD_VAR 0 3
49439: PPUSH
49440: LD_EXP 118
49444: PUSH
49445: LD_VAR 0 3
49449: ARRAY
49450: PUSH
49451: LD_VAR 0 1
49455: DIFF
49456: PPUSH
49457: CALL_OW 1
49461: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49462: LD_ADDR_VAR 0 8
49466: PUSH
49467: LD_VAR 0 3
49471: PPUSH
49472: LD_INT 3
49474: PPUSH
49475: CALL 46103 0 2
49479: ST_TO_ADDR
// if fac then
49480: LD_VAR 0 8
49484: IFFALSE 49713
// begin for j in fac do
49486: LD_ADDR_VAR 0 4
49490: PUSH
49491: LD_VAR 0 8
49495: PUSH
49496: FOR_IN
49497: IFFALSE 49711
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49499: LD_ADDR_VAR 0 9
49503: PUSH
49504: LD_VAR 0 8
49508: PPUSH
49509: LD_VAR 0 1
49513: PPUSH
49514: CALL_OW 265
49518: PPUSH
49519: LD_VAR 0 1
49523: PPUSH
49524: CALL_OW 262
49528: PPUSH
49529: LD_VAR 0 1
49533: PPUSH
49534: CALL_OW 263
49538: PPUSH
49539: LD_VAR 0 1
49543: PPUSH
49544: CALL_OW 264
49548: PPUSH
49549: CALL 54689 0 5
49553: ST_TO_ADDR
// if components then
49554: LD_VAR 0 9
49558: IFFALSE 49709
// begin if GetWeapon ( un ) = ar_control_tower then
49560: LD_VAR 0 1
49564: PPUSH
49565: CALL_OW 264
49569: PUSH
49570: LD_INT 31
49572: EQUAL
49573: IFFALSE 49690
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49575: LD_VAR 0 1
49579: PPUSH
49580: CALL_OW 311
49584: PPUSH
49585: LD_INT 0
49587: PPUSH
49588: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49592: LD_ADDR_EXP 136
49596: PUSH
49597: LD_EXP 136
49601: PPUSH
49602: LD_VAR 0 3
49606: PPUSH
49607: LD_EXP 136
49611: PUSH
49612: LD_VAR 0 3
49616: ARRAY
49617: PUSH
49618: LD_VAR 0 1
49622: PPUSH
49623: CALL_OW 311
49627: DIFF
49628: PPUSH
49629: CALL_OW 1
49633: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49634: LD_ADDR_VAR 0 7
49638: PUSH
49639: LD_EXP 117
49643: PUSH
49644: LD_VAR 0 3
49648: ARRAY
49649: PPUSH
49650: LD_INT 1
49652: PPUSH
49653: LD_VAR 0 9
49657: PPUSH
49658: CALL_OW 2
49662: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49663: LD_ADDR_EXP 117
49667: PUSH
49668: LD_EXP 117
49672: PPUSH
49673: LD_VAR 0 3
49677: PPUSH
49678: LD_VAR 0 7
49682: PPUSH
49683: CALL_OW 1
49687: ST_TO_ADDR
// end else
49688: GO 49707
// MC_InsertProduceList ( i , [ components ] ) ;
49690: LD_VAR 0 3
49694: PPUSH
49695: LD_VAR 0 9
49699: PUSH
49700: EMPTY
49701: LIST
49702: PPUSH
49703: CALL 45648 0 2
// break ;
49707: GO 49711
// end ; end ;
49709: GO 49496
49711: POP
49712: POP
// end ; end ; if GetType ( un ) = unit_building then
49713: LD_VAR 0 1
49717: PPUSH
49718: CALL_OW 247
49722: PUSH
49723: LD_INT 3
49725: EQUAL
49726: IFFALSE 50129
// begin btype := GetBType ( un ) ;
49728: LD_ADDR_VAR 0 5
49732: PUSH
49733: LD_VAR 0 1
49737: PPUSH
49738: CALL_OW 266
49742: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49743: LD_VAR 0 5
49747: PUSH
49748: LD_INT 29
49750: PUSH
49751: LD_INT 30
49753: PUSH
49754: EMPTY
49755: LIST
49756: LIST
49757: IN
49758: IFFALSE 49831
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49760: LD_VAR 0 1
49764: PPUSH
49765: CALL_OW 250
49769: PPUSH
49770: LD_VAR 0 1
49774: PPUSH
49775: CALL_OW 251
49779: PPUSH
49780: LD_VAR 0 1
49784: PPUSH
49785: CALL_OW 255
49789: PPUSH
49790: CALL_OW 440
49794: NOT
49795: IFFALSE 49831
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49797: LD_VAR 0 1
49801: PPUSH
49802: CALL_OW 250
49806: PPUSH
49807: LD_VAR 0 1
49811: PPUSH
49812: CALL_OW 251
49816: PPUSH
49817: LD_VAR 0 1
49821: PPUSH
49822: CALL_OW 255
49826: PPUSH
49827: CALL_OW 441
// end ; if btype = b_warehouse then
49831: LD_VAR 0 5
49835: PUSH
49836: LD_INT 1
49838: EQUAL
49839: IFFALSE 49857
// begin btype := b_depot ;
49841: LD_ADDR_VAR 0 5
49845: PUSH
49846: LD_INT 0
49848: ST_TO_ADDR
// pos := 1 ;
49849: LD_ADDR_VAR 0 6
49853: PUSH
49854: LD_INT 1
49856: ST_TO_ADDR
// end ; if btype = b_factory then
49857: LD_VAR 0 5
49861: PUSH
49862: LD_INT 3
49864: EQUAL
49865: IFFALSE 49883
// begin btype := b_workshop ;
49867: LD_ADDR_VAR 0 5
49871: PUSH
49872: LD_INT 2
49874: ST_TO_ADDR
// pos := 1 ;
49875: LD_ADDR_VAR 0 6
49879: PUSH
49880: LD_INT 1
49882: ST_TO_ADDR
// end ; if btype = b_barracks then
49883: LD_VAR 0 5
49887: PUSH
49888: LD_INT 5
49890: EQUAL
49891: IFFALSE 49901
// btype := b_armoury ;
49893: LD_ADDR_VAR 0 5
49897: PUSH
49898: LD_INT 4
49900: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49901: LD_VAR 0 5
49905: PUSH
49906: LD_INT 7
49908: PUSH
49909: LD_INT 8
49911: PUSH
49912: EMPTY
49913: LIST
49914: LIST
49915: IN
49916: IFFALSE 49926
// btype := b_lab ;
49918: LD_ADDR_VAR 0 5
49922: PUSH
49923: LD_INT 6
49925: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49926: LD_ADDR_EXP 101
49930: PUSH
49931: LD_EXP 101
49935: PPUSH
49936: LD_VAR 0 3
49940: PUSH
49941: LD_EXP 101
49945: PUSH
49946: LD_VAR 0 3
49950: ARRAY
49951: PUSH
49952: LD_INT 1
49954: PLUS
49955: PUSH
49956: EMPTY
49957: LIST
49958: LIST
49959: PPUSH
49960: LD_VAR 0 5
49964: PUSH
49965: LD_VAR 0 1
49969: PPUSH
49970: CALL_OW 250
49974: PUSH
49975: LD_VAR 0 1
49979: PPUSH
49980: CALL_OW 251
49984: PUSH
49985: LD_VAR 0 1
49989: PPUSH
49990: CALL_OW 254
49994: PUSH
49995: EMPTY
49996: LIST
49997: LIST
49998: LIST
49999: LIST
50000: PPUSH
50001: CALL 57193 0 3
50005: ST_TO_ADDR
// if pos = 1 then
50006: LD_VAR 0 6
50010: PUSH
50011: LD_INT 1
50013: EQUAL
50014: IFFALSE 50129
// begin tmp := mc_build_list [ i ] ;
50016: LD_ADDR_VAR 0 7
50020: PUSH
50021: LD_EXP 101
50025: PUSH
50026: LD_VAR 0 3
50030: ARRAY
50031: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50032: LD_VAR 0 7
50036: PPUSH
50037: LD_INT 2
50039: PUSH
50040: LD_INT 30
50042: PUSH
50043: LD_INT 0
50045: PUSH
50046: EMPTY
50047: LIST
50048: LIST
50049: PUSH
50050: LD_INT 30
50052: PUSH
50053: LD_INT 1
50055: PUSH
50056: EMPTY
50057: LIST
50058: LIST
50059: PUSH
50060: EMPTY
50061: LIST
50062: LIST
50063: LIST
50064: PPUSH
50065: CALL_OW 72
50069: IFFALSE 50079
// pos := 2 ;
50071: LD_ADDR_VAR 0 6
50075: PUSH
50076: LD_INT 2
50078: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50079: LD_ADDR_VAR 0 7
50083: PUSH
50084: LD_VAR 0 7
50088: PPUSH
50089: LD_VAR 0 6
50093: PPUSH
50094: LD_VAR 0 7
50098: PPUSH
50099: CALL 57519 0 3
50103: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50104: LD_ADDR_EXP 101
50108: PUSH
50109: LD_EXP 101
50113: PPUSH
50114: LD_VAR 0 3
50118: PPUSH
50119: LD_VAR 0 7
50123: PPUSH
50124: CALL_OW 1
50128: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50129: LD_VAR 0 1
50133: PUSH
50134: LD_EXP 96
50138: PUSH
50139: LD_VAR 0 3
50143: ARRAY
50144: IN
50145: IFFALSE 50184
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50147: LD_ADDR_EXP 96
50151: PUSH
50152: LD_EXP 96
50156: PPUSH
50157: LD_VAR 0 3
50161: PPUSH
50162: LD_EXP 96
50166: PUSH
50167: LD_VAR 0 3
50171: ARRAY
50172: PUSH
50173: LD_VAR 0 1
50177: DIFF
50178: PPUSH
50179: CALL_OW 1
50183: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50184: LD_VAR 0 1
50188: PUSH
50189: LD_EXP 103
50193: PUSH
50194: LD_VAR 0 3
50198: ARRAY
50199: IN
50200: IFFALSE 50239
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50202: LD_ADDR_EXP 103
50206: PUSH
50207: LD_EXP 103
50211: PPUSH
50212: LD_VAR 0 3
50216: PPUSH
50217: LD_EXP 103
50221: PUSH
50222: LD_VAR 0 3
50226: ARRAY
50227: PUSH
50228: LD_VAR 0 1
50232: DIFF
50233: PPUSH
50234: CALL_OW 1
50238: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50239: LD_VAR 0 1
50243: PUSH
50244: LD_EXP 115
50248: PUSH
50249: LD_VAR 0 3
50253: ARRAY
50254: IN
50255: IFFALSE 50294
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50257: LD_ADDR_EXP 115
50261: PUSH
50262: LD_EXP 115
50266: PPUSH
50267: LD_VAR 0 3
50271: PPUSH
50272: LD_EXP 115
50276: PUSH
50277: LD_VAR 0 3
50281: ARRAY
50282: PUSH
50283: LD_VAR 0 1
50287: DIFF
50288: PPUSH
50289: CALL_OW 1
50293: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50294: LD_VAR 0 1
50298: PUSH
50299: LD_EXP 118
50303: PUSH
50304: LD_VAR 0 3
50308: ARRAY
50309: IN
50310: IFFALSE 50349
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50312: LD_ADDR_EXP 118
50316: PUSH
50317: LD_EXP 118
50321: PPUSH
50322: LD_VAR 0 3
50326: PPUSH
50327: LD_EXP 118
50331: PUSH
50332: LD_VAR 0 3
50336: ARRAY
50337: PUSH
50338: LD_VAR 0 1
50342: DIFF
50343: PPUSH
50344: CALL_OW 1
50348: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50349: LD_VAR 0 1
50353: PUSH
50354: LD_EXP 105
50358: PUSH
50359: LD_VAR 0 3
50363: ARRAY
50364: IN
50365: IFFALSE 50404
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50367: LD_ADDR_EXP 105
50371: PUSH
50372: LD_EXP 105
50376: PPUSH
50377: LD_VAR 0 3
50381: PPUSH
50382: LD_EXP 105
50386: PUSH
50387: LD_VAR 0 3
50391: ARRAY
50392: PUSH
50393: LD_VAR 0 1
50397: DIFF
50398: PPUSH
50399: CALL_OW 1
50403: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50404: LD_VAR 0 1
50408: PUSH
50409: LD_EXP 104
50413: PUSH
50414: LD_VAR 0 3
50418: ARRAY
50419: IN
50420: IFFALSE 50459
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50422: LD_ADDR_EXP 104
50426: PUSH
50427: LD_EXP 104
50431: PPUSH
50432: LD_VAR 0 3
50436: PPUSH
50437: LD_EXP 104
50441: PUSH
50442: LD_VAR 0 3
50446: ARRAY
50447: PUSH
50448: LD_VAR 0 1
50452: DIFF
50453: PPUSH
50454: CALL_OW 1
50458: ST_TO_ADDR
// end ; break ;
50459: GO 50463
// end ;
50461: GO 49109
50463: POP
50464: POP
// end ;
50465: LD_VAR 0 2
50469: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50470: LD_INT 0
50472: PPUSH
50473: PPUSH
50474: PPUSH
// if not mc_bases or not skirmish then
50475: LD_EXP 96
50479: NOT
50480: PUSH
50481: LD_EXP 94
50485: NOT
50486: OR
50487: IFFALSE 50491
// exit ;
50489: GO 50706
// for i = 1 to mc_bases do
50491: LD_ADDR_VAR 0 3
50495: PUSH
50496: DOUBLE
50497: LD_INT 1
50499: DEC
50500: ST_TO_ADDR
50501: LD_EXP 96
50505: PUSH
50506: FOR_TO
50507: IFFALSE 50704
// begin if building in mc_construct_list [ i ] then
50509: LD_VAR 0 1
50513: PUSH
50514: LD_EXP 103
50518: PUSH
50519: LD_VAR 0 3
50523: ARRAY
50524: IN
50525: IFFALSE 50702
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50527: LD_ADDR_EXP 103
50531: PUSH
50532: LD_EXP 103
50536: PPUSH
50537: LD_VAR 0 3
50541: PPUSH
50542: LD_EXP 103
50546: PUSH
50547: LD_VAR 0 3
50551: ARRAY
50552: PUSH
50553: LD_VAR 0 1
50557: DIFF
50558: PPUSH
50559: CALL_OW 1
50563: ST_TO_ADDR
// if building in mc_lab [ i ] then
50564: LD_VAR 0 1
50568: PUSH
50569: LD_EXP 129
50573: PUSH
50574: LD_VAR 0 3
50578: ARRAY
50579: IN
50580: IFFALSE 50635
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50582: LD_ADDR_EXP 130
50586: PUSH
50587: LD_EXP 130
50591: PPUSH
50592: LD_VAR 0 3
50596: PPUSH
50597: LD_EXP 130
50601: PUSH
50602: LD_VAR 0 3
50606: ARRAY
50607: PPUSH
50608: LD_INT 1
50610: PPUSH
50611: LD_EXP 130
50615: PUSH
50616: LD_VAR 0 3
50620: ARRAY
50621: PPUSH
50622: LD_INT 0
50624: PPUSH
50625: CALL 56611 0 4
50629: PPUSH
50630: CALL_OW 1
50634: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50635: LD_VAR 0 1
50639: PUSH
50640: LD_EXP 96
50644: PUSH
50645: LD_VAR 0 3
50649: ARRAY
50650: IN
50651: NOT
50652: IFFALSE 50698
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50654: LD_ADDR_EXP 96
50658: PUSH
50659: LD_EXP 96
50663: PPUSH
50664: LD_VAR 0 3
50668: PUSH
50669: LD_EXP 96
50673: PUSH
50674: LD_VAR 0 3
50678: ARRAY
50679: PUSH
50680: LD_INT 1
50682: PLUS
50683: PUSH
50684: EMPTY
50685: LIST
50686: LIST
50687: PPUSH
50688: LD_VAR 0 1
50692: PPUSH
50693: CALL 57193 0 3
50697: ST_TO_ADDR
// exit ;
50698: POP
50699: POP
50700: GO 50706
// end ; end ;
50702: GO 50506
50704: POP
50705: POP
// end ;
50706: LD_VAR 0 2
50710: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50711: LD_INT 0
50713: PPUSH
50714: PPUSH
50715: PPUSH
50716: PPUSH
50717: PPUSH
50718: PPUSH
50719: PPUSH
// if not mc_bases or not skirmish then
50720: LD_EXP 96
50724: NOT
50725: PUSH
50726: LD_EXP 94
50730: NOT
50731: OR
50732: IFFALSE 50736
// exit ;
50734: GO 51397
// for i = 1 to mc_bases do
50736: LD_ADDR_VAR 0 3
50740: PUSH
50741: DOUBLE
50742: LD_INT 1
50744: DEC
50745: ST_TO_ADDR
50746: LD_EXP 96
50750: PUSH
50751: FOR_TO
50752: IFFALSE 51395
// begin if building in mc_construct_list [ i ] then
50754: LD_VAR 0 1
50758: PUSH
50759: LD_EXP 103
50763: PUSH
50764: LD_VAR 0 3
50768: ARRAY
50769: IN
50770: IFFALSE 51393
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50772: LD_ADDR_EXP 103
50776: PUSH
50777: LD_EXP 103
50781: PPUSH
50782: LD_VAR 0 3
50786: PPUSH
50787: LD_EXP 103
50791: PUSH
50792: LD_VAR 0 3
50796: ARRAY
50797: PUSH
50798: LD_VAR 0 1
50802: DIFF
50803: PPUSH
50804: CALL_OW 1
50808: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50809: LD_ADDR_EXP 96
50813: PUSH
50814: LD_EXP 96
50818: PPUSH
50819: LD_VAR 0 3
50823: PUSH
50824: LD_EXP 96
50828: PUSH
50829: LD_VAR 0 3
50833: ARRAY
50834: PUSH
50835: LD_INT 1
50837: PLUS
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: PPUSH
50843: LD_VAR 0 1
50847: PPUSH
50848: CALL 57193 0 3
50852: ST_TO_ADDR
// btype := GetBType ( building ) ;
50853: LD_ADDR_VAR 0 5
50857: PUSH
50858: LD_VAR 0 1
50862: PPUSH
50863: CALL_OW 266
50867: ST_TO_ADDR
// side := GetSide ( building ) ;
50868: LD_ADDR_VAR 0 8
50872: PUSH
50873: LD_VAR 0 1
50877: PPUSH
50878: CALL_OW 255
50882: ST_TO_ADDR
// if btype = b_lab then
50883: LD_VAR 0 5
50887: PUSH
50888: LD_INT 6
50890: EQUAL
50891: IFFALSE 50941
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50893: LD_ADDR_EXP 129
50897: PUSH
50898: LD_EXP 129
50902: PPUSH
50903: LD_VAR 0 3
50907: PUSH
50908: LD_EXP 129
50912: PUSH
50913: LD_VAR 0 3
50917: ARRAY
50918: PUSH
50919: LD_INT 1
50921: PLUS
50922: PUSH
50923: EMPTY
50924: LIST
50925: LIST
50926: PPUSH
50927: LD_VAR 0 1
50931: PPUSH
50932: CALL 57193 0 3
50936: ST_TO_ADDR
// exit ;
50937: POP
50938: POP
50939: GO 51397
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50941: LD_VAR 0 5
50945: PUSH
50946: LD_INT 0
50948: PUSH
50949: LD_INT 2
50951: PUSH
50952: LD_INT 4
50954: PUSH
50955: EMPTY
50956: LIST
50957: LIST
50958: LIST
50959: IN
50960: IFFALSE 51084
// begin if btype = b_armoury then
50962: LD_VAR 0 5
50966: PUSH
50967: LD_INT 4
50969: EQUAL
50970: IFFALSE 50980
// btype := b_barracks ;
50972: LD_ADDR_VAR 0 5
50976: PUSH
50977: LD_INT 5
50979: ST_TO_ADDR
// if btype = b_depot then
50980: LD_VAR 0 5
50984: PUSH
50985: LD_INT 0
50987: EQUAL
50988: IFFALSE 50998
// btype := b_warehouse ;
50990: LD_ADDR_VAR 0 5
50994: PUSH
50995: LD_INT 1
50997: ST_TO_ADDR
// if btype = b_workshop then
50998: LD_VAR 0 5
51002: PUSH
51003: LD_INT 2
51005: EQUAL
51006: IFFALSE 51016
// btype := b_factory ;
51008: LD_ADDR_VAR 0 5
51012: PUSH
51013: LD_INT 3
51015: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
51016: LD_VAR 0 5
51020: PPUSH
51021: LD_VAR 0 8
51025: PPUSH
51026: CALL_OW 323
51030: PUSH
51031: LD_INT 1
51033: EQUAL
51034: IFFALSE 51080
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51036: LD_ADDR_EXP 128
51040: PUSH
51041: LD_EXP 128
51045: PPUSH
51046: LD_VAR 0 3
51050: PUSH
51051: LD_EXP 128
51055: PUSH
51056: LD_VAR 0 3
51060: ARRAY
51061: PUSH
51062: LD_INT 1
51064: PLUS
51065: PUSH
51066: EMPTY
51067: LIST
51068: LIST
51069: PPUSH
51070: LD_VAR 0 1
51074: PPUSH
51075: CALL 57193 0 3
51079: ST_TO_ADDR
// exit ;
51080: POP
51081: POP
51082: GO 51397
// end ; if btype in [ b_bunker , b_turret ] then
51084: LD_VAR 0 5
51088: PUSH
51089: LD_INT 32
51091: PUSH
51092: LD_INT 33
51094: PUSH
51095: EMPTY
51096: LIST
51097: LIST
51098: IN
51099: IFFALSE 51389
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51101: LD_ADDR_EXP 104
51105: PUSH
51106: LD_EXP 104
51110: PPUSH
51111: LD_VAR 0 3
51115: PUSH
51116: LD_EXP 104
51120: PUSH
51121: LD_VAR 0 3
51125: ARRAY
51126: PUSH
51127: LD_INT 1
51129: PLUS
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: PPUSH
51135: LD_VAR 0 1
51139: PPUSH
51140: CALL 57193 0 3
51144: ST_TO_ADDR
// if btype = b_bunker then
51145: LD_VAR 0 5
51149: PUSH
51150: LD_INT 32
51152: EQUAL
51153: IFFALSE 51389
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51155: LD_ADDR_EXP 105
51159: PUSH
51160: LD_EXP 105
51164: PPUSH
51165: LD_VAR 0 3
51169: PUSH
51170: LD_EXP 105
51174: PUSH
51175: LD_VAR 0 3
51179: ARRAY
51180: PUSH
51181: LD_INT 1
51183: PLUS
51184: PUSH
51185: EMPTY
51186: LIST
51187: LIST
51188: PPUSH
51189: LD_VAR 0 1
51193: PPUSH
51194: CALL 57193 0 3
51198: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51199: LD_ADDR_VAR 0 6
51203: PUSH
51204: LD_EXP 96
51208: PUSH
51209: LD_VAR 0 3
51213: ARRAY
51214: PPUSH
51215: LD_INT 25
51217: PUSH
51218: LD_INT 1
51220: PUSH
51221: EMPTY
51222: LIST
51223: LIST
51224: PUSH
51225: LD_INT 3
51227: PUSH
51228: LD_INT 54
51230: PUSH
51231: EMPTY
51232: LIST
51233: PUSH
51234: EMPTY
51235: LIST
51236: LIST
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: PPUSH
51242: CALL_OW 72
51246: ST_TO_ADDR
// if tmp then
51247: LD_VAR 0 6
51251: IFFALSE 51257
// exit ;
51253: POP
51254: POP
51255: GO 51397
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51257: LD_ADDR_VAR 0 6
51261: PUSH
51262: LD_EXP 96
51266: PUSH
51267: LD_VAR 0 3
51271: ARRAY
51272: PPUSH
51273: LD_INT 2
51275: PUSH
51276: LD_INT 30
51278: PUSH
51279: LD_INT 4
51281: PUSH
51282: EMPTY
51283: LIST
51284: LIST
51285: PUSH
51286: LD_INT 30
51288: PUSH
51289: LD_INT 5
51291: PUSH
51292: EMPTY
51293: LIST
51294: LIST
51295: PUSH
51296: EMPTY
51297: LIST
51298: LIST
51299: LIST
51300: PPUSH
51301: CALL_OW 72
51305: ST_TO_ADDR
// if not tmp then
51306: LD_VAR 0 6
51310: NOT
51311: IFFALSE 51317
// exit ;
51313: POP
51314: POP
51315: GO 51397
// for j in tmp do
51317: LD_ADDR_VAR 0 4
51321: PUSH
51322: LD_VAR 0 6
51326: PUSH
51327: FOR_IN
51328: IFFALSE 51387
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51330: LD_ADDR_VAR 0 7
51334: PUSH
51335: LD_VAR 0 4
51339: PPUSH
51340: CALL_OW 313
51344: PPUSH
51345: LD_INT 25
51347: PUSH
51348: LD_INT 1
51350: PUSH
51351: EMPTY
51352: LIST
51353: LIST
51354: PPUSH
51355: CALL_OW 72
51359: ST_TO_ADDR
// if units then
51360: LD_VAR 0 7
51364: IFFALSE 51385
// begin ComExitBuilding ( units [ 1 ] ) ;
51366: LD_VAR 0 7
51370: PUSH
51371: LD_INT 1
51373: ARRAY
51374: PPUSH
51375: CALL_OW 122
// exit ;
51379: POP
51380: POP
51381: POP
51382: POP
51383: GO 51397
// end ; end ;
51385: GO 51327
51387: POP
51388: POP
// end ; end ; exit ;
51389: POP
51390: POP
51391: GO 51397
// end ; end ;
51393: GO 50751
51395: POP
51396: POP
// end ;
51397: LD_VAR 0 2
51401: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51402: LD_INT 0
51404: PPUSH
51405: PPUSH
51406: PPUSH
51407: PPUSH
51408: PPUSH
51409: PPUSH
51410: PPUSH
// if not mc_bases or not skirmish then
51411: LD_EXP 96
51415: NOT
51416: PUSH
51417: LD_EXP 94
51421: NOT
51422: OR
51423: IFFALSE 51427
// exit ;
51425: GO 51692
// btype := GetBType ( building ) ;
51427: LD_ADDR_VAR 0 6
51431: PUSH
51432: LD_VAR 0 1
51436: PPUSH
51437: CALL_OW 266
51441: ST_TO_ADDR
// x := GetX ( building ) ;
51442: LD_ADDR_VAR 0 7
51446: PUSH
51447: LD_VAR 0 1
51451: PPUSH
51452: CALL_OW 250
51456: ST_TO_ADDR
// y := GetY ( building ) ;
51457: LD_ADDR_VAR 0 8
51461: PUSH
51462: LD_VAR 0 1
51466: PPUSH
51467: CALL_OW 251
51471: ST_TO_ADDR
// d := GetDir ( building ) ;
51472: LD_ADDR_VAR 0 9
51476: PUSH
51477: LD_VAR 0 1
51481: PPUSH
51482: CALL_OW 254
51486: ST_TO_ADDR
// for i = 1 to mc_bases do
51487: LD_ADDR_VAR 0 4
51491: PUSH
51492: DOUBLE
51493: LD_INT 1
51495: DEC
51496: ST_TO_ADDR
51497: LD_EXP 96
51501: PUSH
51502: FOR_TO
51503: IFFALSE 51690
// begin if not mc_build_list [ i ] then
51505: LD_EXP 101
51509: PUSH
51510: LD_VAR 0 4
51514: ARRAY
51515: NOT
51516: IFFALSE 51520
// continue ;
51518: GO 51502
// for j := 1 to mc_build_list [ i ] do
51520: LD_ADDR_VAR 0 5
51524: PUSH
51525: DOUBLE
51526: LD_INT 1
51528: DEC
51529: ST_TO_ADDR
51530: LD_EXP 101
51534: PUSH
51535: LD_VAR 0 4
51539: ARRAY
51540: PUSH
51541: FOR_TO
51542: IFFALSE 51686
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51544: LD_VAR 0 6
51548: PUSH
51549: LD_VAR 0 7
51553: PUSH
51554: LD_VAR 0 8
51558: PUSH
51559: LD_VAR 0 9
51563: PUSH
51564: EMPTY
51565: LIST
51566: LIST
51567: LIST
51568: LIST
51569: PPUSH
51570: LD_EXP 101
51574: PUSH
51575: LD_VAR 0 4
51579: ARRAY
51580: PUSH
51581: LD_VAR 0 5
51585: ARRAY
51586: PPUSH
51587: CALL 63375 0 2
51591: IFFALSE 51684
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51593: LD_ADDR_EXP 101
51597: PUSH
51598: LD_EXP 101
51602: PPUSH
51603: LD_VAR 0 4
51607: PPUSH
51608: LD_EXP 101
51612: PUSH
51613: LD_VAR 0 4
51617: ARRAY
51618: PPUSH
51619: LD_VAR 0 5
51623: PPUSH
51624: CALL_OW 3
51628: PPUSH
51629: CALL_OW 1
51633: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51634: LD_ADDR_EXP 103
51638: PUSH
51639: LD_EXP 103
51643: PPUSH
51644: LD_VAR 0 4
51648: PUSH
51649: LD_EXP 103
51653: PUSH
51654: LD_VAR 0 4
51658: ARRAY
51659: PUSH
51660: LD_INT 1
51662: PLUS
51663: PUSH
51664: EMPTY
51665: LIST
51666: LIST
51667: PPUSH
51668: LD_VAR 0 1
51672: PPUSH
51673: CALL 57193 0 3
51677: ST_TO_ADDR
// exit ;
51678: POP
51679: POP
51680: POP
51681: POP
51682: GO 51692
// end ;
51684: GO 51541
51686: POP
51687: POP
// end ;
51688: GO 51502
51690: POP
51691: POP
// end ;
51692: LD_VAR 0 3
51696: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51697: LD_INT 0
51699: PPUSH
51700: PPUSH
51701: PPUSH
// if not mc_bases or not skirmish then
51702: LD_EXP 96
51706: NOT
51707: PUSH
51708: LD_EXP 94
51712: NOT
51713: OR
51714: IFFALSE 51718
// exit ;
51716: GO 51908
// for i = 1 to mc_bases do
51718: LD_ADDR_VAR 0 4
51722: PUSH
51723: DOUBLE
51724: LD_INT 1
51726: DEC
51727: ST_TO_ADDR
51728: LD_EXP 96
51732: PUSH
51733: FOR_TO
51734: IFFALSE 51821
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51736: LD_VAR 0 1
51740: PUSH
51741: LD_EXP 104
51745: PUSH
51746: LD_VAR 0 4
51750: ARRAY
51751: IN
51752: PUSH
51753: LD_VAR 0 1
51757: PUSH
51758: LD_EXP 105
51762: PUSH
51763: LD_VAR 0 4
51767: ARRAY
51768: IN
51769: NOT
51770: AND
51771: IFFALSE 51819
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51773: LD_ADDR_EXP 105
51777: PUSH
51778: LD_EXP 105
51782: PPUSH
51783: LD_VAR 0 4
51787: PUSH
51788: LD_EXP 105
51792: PUSH
51793: LD_VAR 0 4
51797: ARRAY
51798: PUSH
51799: LD_INT 1
51801: PLUS
51802: PUSH
51803: EMPTY
51804: LIST
51805: LIST
51806: PPUSH
51807: LD_VAR 0 1
51811: PPUSH
51812: CALL 57193 0 3
51816: ST_TO_ADDR
// break ;
51817: GO 51821
// end ; end ;
51819: GO 51733
51821: POP
51822: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51823: LD_VAR 0 1
51827: PPUSH
51828: CALL_OW 257
51832: PUSH
51833: LD_EXP 122
51837: IN
51838: PUSH
51839: LD_VAR 0 1
51843: PPUSH
51844: CALL_OW 266
51848: PUSH
51849: LD_INT 5
51851: EQUAL
51852: AND
51853: PUSH
51854: LD_VAR 0 2
51858: PPUSH
51859: CALL_OW 110
51863: PUSH
51864: LD_INT 18
51866: NONEQUAL
51867: AND
51868: IFFALSE 51908
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51870: LD_VAR 0 2
51874: PPUSH
51875: CALL_OW 257
51879: PUSH
51880: LD_INT 5
51882: PUSH
51883: LD_INT 8
51885: PUSH
51886: LD_INT 9
51888: PUSH
51889: EMPTY
51890: LIST
51891: LIST
51892: LIST
51893: IN
51894: IFFALSE 51908
// SetClass ( unit , 1 ) ;
51896: LD_VAR 0 2
51900: PPUSH
51901: LD_INT 1
51903: PPUSH
51904: CALL_OW 336
// end ;
51908: LD_VAR 0 3
51912: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51913: LD_INT 0
51915: PPUSH
51916: PPUSH
// if not mc_bases or not skirmish then
51917: LD_EXP 96
51921: NOT
51922: PUSH
51923: LD_EXP 94
51927: NOT
51928: OR
51929: IFFALSE 51933
// exit ;
51931: GO 52049
// if GetLives ( abandoned_vehicle ) > 250 then
51933: LD_VAR 0 2
51937: PPUSH
51938: CALL_OW 256
51942: PUSH
51943: LD_INT 250
51945: GREATER
51946: IFFALSE 51950
// exit ;
51948: GO 52049
// for i = 1 to mc_bases do
51950: LD_ADDR_VAR 0 6
51954: PUSH
51955: DOUBLE
51956: LD_INT 1
51958: DEC
51959: ST_TO_ADDR
51960: LD_EXP 96
51964: PUSH
51965: FOR_TO
51966: IFFALSE 52047
// begin if driver in mc_bases [ i ] then
51968: LD_VAR 0 1
51972: PUSH
51973: LD_EXP 96
51977: PUSH
51978: LD_VAR 0 6
51982: ARRAY
51983: IN
51984: IFFALSE 52045
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51986: LD_VAR 0 1
51990: PPUSH
51991: LD_EXP 96
51995: PUSH
51996: LD_VAR 0 6
52000: ARRAY
52001: PPUSH
52002: LD_INT 2
52004: PUSH
52005: LD_INT 30
52007: PUSH
52008: LD_INT 0
52010: PUSH
52011: EMPTY
52012: LIST
52013: LIST
52014: PUSH
52015: LD_INT 30
52017: PUSH
52018: LD_INT 1
52020: PUSH
52021: EMPTY
52022: LIST
52023: LIST
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: LIST
52029: PPUSH
52030: CALL_OW 72
52034: PUSH
52035: LD_INT 1
52037: ARRAY
52038: PPUSH
52039: CALL 89755 0 2
// break ;
52043: GO 52047
// end ; end ;
52045: GO 51965
52047: POP
52048: POP
// end ; end_of_file
52049: LD_VAR 0 5
52053: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52054: LD_INT 0
52056: PPUSH
52057: PPUSH
// if exist_mode then
52058: LD_VAR 0 2
52062: IFFALSE 52087
// unit := CreateCharacter ( prefix & ident ) else
52064: LD_ADDR_VAR 0 5
52068: PUSH
52069: LD_VAR 0 3
52073: PUSH
52074: LD_VAR 0 1
52078: STR
52079: PPUSH
52080: CALL_OW 34
52084: ST_TO_ADDR
52085: GO 52102
// unit := NewCharacter ( ident ) ;
52087: LD_ADDR_VAR 0 5
52091: PUSH
52092: LD_VAR 0 1
52096: PPUSH
52097: CALL_OW 25
52101: ST_TO_ADDR
// result := unit ;
52102: LD_ADDR_VAR 0 4
52106: PUSH
52107: LD_VAR 0 5
52111: ST_TO_ADDR
// end ;
52112: LD_VAR 0 4
52116: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52117: LD_INT 0
52119: PPUSH
52120: PPUSH
// if not side or not nation then
52121: LD_VAR 0 1
52125: NOT
52126: PUSH
52127: LD_VAR 0 2
52131: NOT
52132: OR
52133: IFFALSE 52137
// exit ;
52135: GO 52905
// case nation of nation_american :
52137: LD_VAR 0 2
52141: PUSH
52142: LD_INT 1
52144: DOUBLE
52145: EQUAL
52146: IFTRUE 52150
52148: GO 52364
52150: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52151: LD_ADDR_VAR 0 4
52155: PUSH
52156: LD_INT 35
52158: PUSH
52159: LD_INT 45
52161: PUSH
52162: LD_INT 46
52164: PUSH
52165: LD_INT 47
52167: PUSH
52168: LD_INT 82
52170: PUSH
52171: LD_INT 83
52173: PUSH
52174: LD_INT 84
52176: PUSH
52177: LD_INT 85
52179: PUSH
52180: LD_INT 86
52182: PUSH
52183: LD_INT 1
52185: PUSH
52186: LD_INT 2
52188: PUSH
52189: LD_INT 6
52191: PUSH
52192: LD_INT 15
52194: PUSH
52195: LD_INT 16
52197: PUSH
52198: LD_INT 7
52200: PUSH
52201: LD_INT 12
52203: PUSH
52204: LD_INT 13
52206: PUSH
52207: LD_INT 10
52209: PUSH
52210: LD_INT 14
52212: PUSH
52213: LD_INT 20
52215: PUSH
52216: LD_INT 21
52218: PUSH
52219: LD_INT 22
52221: PUSH
52222: LD_INT 25
52224: PUSH
52225: LD_INT 32
52227: PUSH
52228: LD_INT 27
52230: PUSH
52231: LD_INT 36
52233: PUSH
52234: LD_INT 69
52236: PUSH
52237: LD_INT 39
52239: PUSH
52240: LD_INT 34
52242: PUSH
52243: LD_INT 40
52245: PUSH
52246: LD_INT 48
52248: PUSH
52249: LD_INT 49
52251: PUSH
52252: LD_INT 50
52254: PUSH
52255: LD_INT 51
52257: PUSH
52258: LD_INT 52
52260: PUSH
52261: LD_INT 53
52263: PUSH
52264: LD_INT 54
52266: PUSH
52267: LD_INT 55
52269: PUSH
52270: LD_INT 56
52272: PUSH
52273: LD_INT 57
52275: PUSH
52276: LD_INT 58
52278: PUSH
52279: LD_INT 59
52281: PUSH
52282: LD_INT 60
52284: PUSH
52285: LD_INT 61
52287: PUSH
52288: LD_INT 62
52290: PUSH
52291: LD_INT 80
52293: PUSH
52294: LD_INT 82
52296: PUSH
52297: LD_INT 83
52299: PUSH
52300: LD_INT 84
52302: PUSH
52303: LD_INT 85
52305: PUSH
52306: LD_INT 86
52308: PUSH
52309: EMPTY
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: LIST
52319: LIST
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: LIST
52328: LIST
52329: LIST
52330: LIST
52331: LIST
52332: LIST
52333: LIST
52334: LIST
52335: LIST
52336: LIST
52337: LIST
52338: LIST
52339: LIST
52340: LIST
52341: LIST
52342: LIST
52343: LIST
52344: LIST
52345: LIST
52346: LIST
52347: LIST
52348: LIST
52349: LIST
52350: LIST
52351: LIST
52352: LIST
52353: LIST
52354: LIST
52355: LIST
52356: LIST
52357: LIST
52358: LIST
52359: LIST
52360: LIST
52361: ST_TO_ADDR
52362: GO 52829
52364: LD_INT 2
52366: DOUBLE
52367: EQUAL
52368: IFTRUE 52372
52370: GO 52598
52372: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52373: LD_ADDR_VAR 0 4
52377: PUSH
52378: LD_INT 35
52380: PUSH
52381: LD_INT 45
52383: PUSH
52384: LD_INT 46
52386: PUSH
52387: LD_INT 47
52389: PUSH
52390: LD_INT 82
52392: PUSH
52393: LD_INT 83
52395: PUSH
52396: LD_INT 84
52398: PUSH
52399: LD_INT 85
52401: PUSH
52402: LD_INT 87
52404: PUSH
52405: LD_INT 70
52407: PUSH
52408: LD_INT 1
52410: PUSH
52411: LD_INT 11
52413: PUSH
52414: LD_INT 3
52416: PUSH
52417: LD_INT 4
52419: PUSH
52420: LD_INT 5
52422: PUSH
52423: LD_INT 6
52425: PUSH
52426: LD_INT 15
52428: PUSH
52429: LD_INT 18
52431: PUSH
52432: LD_INT 7
52434: PUSH
52435: LD_INT 17
52437: PUSH
52438: LD_INT 8
52440: PUSH
52441: LD_INT 20
52443: PUSH
52444: LD_INT 21
52446: PUSH
52447: LD_INT 22
52449: PUSH
52450: LD_INT 72
52452: PUSH
52453: LD_INT 26
52455: PUSH
52456: LD_INT 69
52458: PUSH
52459: LD_INT 39
52461: PUSH
52462: LD_INT 40
52464: PUSH
52465: LD_INT 41
52467: PUSH
52468: LD_INT 42
52470: PUSH
52471: LD_INT 43
52473: PUSH
52474: LD_INT 48
52476: PUSH
52477: LD_INT 49
52479: PUSH
52480: LD_INT 50
52482: PUSH
52483: LD_INT 51
52485: PUSH
52486: LD_INT 52
52488: PUSH
52489: LD_INT 53
52491: PUSH
52492: LD_INT 54
52494: PUSH
52495: LD_INT 55
52497: PUSH
52498: LD_INT 56
52500: PUSH
52501: LD_INT 60
52503: PUSH
52504: LD_INT 61
52506: PUSH
52507: LD_INT 62
52509: PUSH
52510: LD_INT 66
52512: PUSH
52513: LD_INT 67
52515: PUSH
52516: LD_INT 68
52518: PUSH
52519: LD_INT 81
52521: PUSH
52522: LD_INT 82
52524: PUSH
52525: LD_INT 83
52527: PUSH
52528: LD_INT 84
52530: PUSH
52531: LD_INT 85
52533: PUSH
52534: LD_INT 87
52536: PUSH
52537: LD_INT 88
52539: PUSH
52540: EMPTY
52541: LIST
52542: LIST
52543: LIST
52544: LIST
52545: LIST
52546: LIST
52547: LIST
52548: LIST
52549: LIST
52550: LIST
52551: LIST
52552: LIST
52553: LIST
52554: LIST
52555: LIST
52556: LIST
52557: LIST
52558: LIST
52559: LIST
52560: LIST
52561: LIST
52562: LIST
52563: LIST
52564: LIST
52565: LIST
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: LIST
52571: LIST
52572: LIST
52573: LIST
52574: LIST
52575: LIST
52576: LIST
52577: LIST
52578: LIST
52579: LIST
52580: LIST
52581: LIST
52582: LIST
52583: LIST
52584: LIST
52585: LIST
52586: LIST
52587: LIST
52588: LIST
52589: LIST
52590: LIST
52591: LIST
52592: LIST
52593: LIST
52594: LIST
52595: ST_TO_ADDR
52596: GO 52829
52598: LD_INT 3
52600: DOUBLE
52601: EQUAL
52602: IFTRUE 52606
52604: GO 52828
52606: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52607: LD_ADDR_VAR 0 4
52611: PUSH
52612: LD_INT 46
52614: PUSH
52615: LD_INT 47
52617: PUSH
52618: LD_INT 1
52620: PUSH
52621: LD_INT 2
52623: PUSH
52624: LD_INT 82
52626: PUSH
52627: LD_INT 83
52629: PUSH
52630: LD_INT 84
52632: PUSH
52633: LD_INT 85
52635: PUSH
52636: LD_INT 86
52638: PUSH
52639: LD_INT 11
52641: PUSH
52642: LD_INT 9
52644: PUSH
52645: LD_INT 20
52647: PUSH
52648: LD_INT 19
52650: PUSH
52651: LD_INT 21
52653: PUSH
52654: LD_INT 24
52656: PUSH
52657: LD_INT 22
52659: PUSH
52660: LD_INT 25
52662: PUSH
52663: LD_INT 28
52665: PUSH
52666: LD_INT 29
52668: PUSH
52669: LD_INT 30
52671: PUSH
52672: LD_INT 31
52674: PUSH
52675: LD_INT 37
52677: PUSH
52678: LD_INT 38
52680: PUSH
52681: LD_INT 32
52683: PUSH
52684: LD_INT 27
52686: PUSH
52687: LD_INT 33
52689: PUSH
52690: LD_INT 69
52692: PUSH
52693: LD_INT 39
52695: PUSH
52696: LD_INT 34
52698: PUSH
52699: LD_INT 40
52701: PUSH
52702: LD_INT 71
52704: PUSH
52705: LD_INT 23
52707: PUSH
52708: LD_INT 44
52710: PUSH
52711: LD_INT 48
52713: PUSH
52714: LD_INT 49
52716: PUSH
52717: LD_INT 50
52719: PUSH
52720: LD_INT 51
52722: PUSH
52723: LD_INT 52
52725: PUSH
52726: LD_INT 53
52728: PUSH
52729: LD_INT 54
52731: PUSH
52732: LD_INT 55
52734: PUSH
52735: LD_INT 56
52737: PUSH
52738: LD_INT 57
52740: PUSH
52741: LD_INT 58
52743: PUSH
52744: LD_INT 59
52746: PUSH
52747: LD_INT 63
52749: PUSH
52750: LD_INT 64
52752: PUSH
52753: LD_INT 65
52755: PUSH
52756: LD_INT 82
52758: PUSH
52759: LD_INT 83
52761: PUSH
52762: LD_INT 84
52764: PUSH
52765: LD_INT 85
52767: PUSH
52768: LD_INT 86
52770: PUSH
52771: EMPTY
52772: LIST
52773: LIST
52774: LIST
52775: LIST
52776: LIST
52777: LIST
52778: LIST
52779: LIST
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: LIST
52789: LIST
52790: LIST
52791: LIST
52792: LIST
52793: LIST
52794: LIST
52795: LIST
52796: LIST
52797: LIST
52798: LIST
52799: LIST
52800: LIST
52801: LIST
52802: LIST
52803: LIST
52804: LIST
52805: LIST
52806: LIST
52807: LIST
52808: LIST
52809: LIST
52810: LIST
52811: LIST
52812: LIST
52813: LIST
52814: LIST
52815: LIST
52816: LIST
52817: LIST
52818: LIST
52819: LIST
52820: LIST
52821: LIST
52822: LIST
52823: LIST
52824: LIST
52825: ST_TO_ADDR
52826: GO 52829
52828: POP
// if state > - 1 and state < 3 then
52829: LD_VAR 0 3
52833: PUSH
52834: LD_INT 1
52836: NEG
52837: GREATER
52838: PUSH
52839: LD_VAR 0 3
52843: PUSH
52844: LD_INT 3
52846: LESS
52847: AND
52848: IFFALSE 52905
// for i in result do
52850: LD_ADDR_VAR 0 5
52854: PUSH
52855: LD_VAR 0 4
52859: PUSH
52860: FOR_IN
52861: IFFALSE 52903
// if GetTech ( i , side ) <> state then
52863: LD_VAR 0 5
52867: PPUSH
52868: LD_VAR 0 1
52872: PPUSH
52873: CALL_OW 321
52877: PUSH
52878: LD_VAR 0 3
52882: NONEQUAL
52883: IFFALSE 52901
// result := result diff i ;
52885: LD_ADDR_VAR 0 4
52889: PUSH
52890: LD_VAR 0 4
52894: PUSH
52895: LD_VAR 0 5
52899: DIFF
52900: ST_TO_ADDR
52901: GO 52860
52903: POP
52904: POP
// end ;
52905: LD_VAR 0 4
52909: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52910: LD_INT 0
52912: PPUSH
52913: PPUSH
52914: PPUSH
// result := true ;
52915: LD_ADDR_VAR 0 3
52919: PUSH
52920: LD_INT 1
52922: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52923: LD_ADDR_VAR 0 5
52927: PUSH
52928: LD_VAR 0 2
52932: PPUSH
52933: CALL_OW 480
52937: ST_TO_ADDR
// if not tmp then
52938: LD_VAR 0 5
52942: NOT
52943: IFFALSE 52947
// exit ;
52945: GO 52996
// for i in tmp do
52947: LD_ADDR_VAR 0 4
52951: PUSH
52952: LD_VAR 0 5
52956: PUSH
52957: FOR_IN
52958: IFFALSE 52994
// if GetTech ( i , side ) <> state_researched then
52960: LD_VAR 0 4
52964: PPUSH
52965: LD_VAR 0 1
52969: PPUSH
52970: CALL_OW 321
52974: PUSH
52975: LD_INT 2
52977: NONEQUAL
52978: IFFALSE 52992
// begin result := false ;
52980: LD_ADDR_VAR 0 3
52984: PUSH
52985: LD_INT 0
52987: ST_TO_ADDR
// exit ;
52988: POP
52989: POP
52990: GO 52996
// end ;
52992: GO 52957
52994: POP
52995: POP
// end ;
52996: LD_VAR 0 3
53000: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
53001: LD_INT 0
53003: PPUSH
53004: PPUSH
53005: PPUSH
53006: PPUSH
53007: PPUSH
53008: PPUSH
53009: PPUSH
53010: PPUSH
53011: PPUSH
53012: PPUSH
53013: PPUSH
53014: PPUSH
53015: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
53016: LD_VAR 0 1
53020: NOT
53021: PUSH
53022: LD_VAR 0 1
53026: PPUSH
53027: CALL_OW 257
53031: PUSH
53032: LD_INT 9
53034: NONEQUAL
53035: OR
53036: IFFALSE 53040
// exit ;
53038: GO 53613
// side := GetSide ( unit ) ;
53040: LD_ADDR_VAR 0 9
53044: PUSH
53045: LD_VAR 0 1
53049: PPUSH
53050: CALL_OW 255
53054: ST_TO_ADDR
// tech_space := tech_spacanom ;
53055: LD_ADDR_VAR 0 12
53059: PUSH
53060: LD_INT 29
53062: ST_TO_ADDR
// tech_time := tech_taurad ;
53063: LD_ADDR_VAR 0 13
53067: PUSH
53068: LD_INT 28
53070: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53071: LD_ADDR_VAR 0 11
53075: PUSH
53076: LD_VAR 0 1
53080: PPUSH
53081: CALL_OW 310
53085: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53086: LD_VAR 0 11
53090: PPUSH
53091: CALL_OW 247
53095: PUSH
53096: LD_INT 2
53098: EQUAL
53099: IFFALSE 53103
// exit ;
53101: GO 53613
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53103: LD_ADDR_VAR 0 8
53107: PUSH
53108: LD_INT 81
53110: PUSH
53111: LD_VAR 0 9
53115: PUSH
53116: EMPTY
53117: LIST
53118: LIST
53119: PUSH
53120: LD_INT 3
53122: PUSH
53123: LD_INT 21
53125: PUSH
53126: LD_INT 3
53128: PUSH
53129: EMPTY
53130: LIST
53131: LIST
53132: PUSH
53133: EMPTY
53134: LIST
53135: LIST
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: PPUSH
53141: CALL_OW 69
53145: ST_TO_ADDR
// if not tmp then
53146: LD_VAR 0 8
53150: NOT
53151: IFFALSE 53155
// exit ;
53153: GO 53613
// if in_unit then
53155: LD_VAR 0 11
53159: IFFALSE 53183
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53161: LD_ADDR_VAR 0 10
53165: PUSH
53166: LD_VAR 0 8
53170: PPUSH
53171: LD_VAR 0 11
53175: PPUSH
53176: CALL_OW 74
53180: ST_TO_ADDR
53181: GO 53203
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53183: LD_ADDR_VAR 0 10
53187: PUSH
53188: LD_VAR 0 8
53192: PPUSH
53193: LD_VAR 0 1
53197: PPUSH
53198: CALL_OW 74
53202: ST_TO_ADDR
// if not enemy then
53203: LD_VAR 0 10
53207: NOT
53208: IFFALSE 53212
// exit ;
53210: GO 53613
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53212: LD_VAR 0 11
53216: PUSH
53217: LD_VAR 0 11
53221: PPUSH
53222: LD_VAR 0 10
53226: PPUSH
53227: CALL_OW 296
53231: PUSH
53232: LD_INT 13
53234: GREATER
53235: AND
53236: PUSH
53237: LD_VAR 0 1
53241: PPUSH
53242: LD_VAR 0 10
53246: PPUSH
53247: CALL_OW 296
53251: PUSH
53252: LD_INT 12
53254: GREATER
53255: OR
53256: IFFALSE 53260
// exit ;
53258: GO 53613
// missile := [ 1 ] ;
53260: LD_ADDR_VAR 0 14
53264: PUSH
53265: LD_INT 1
53267: PUSH
53268: EMPTY
53269: LIST
53270: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53271: LD_VAR 0 9
53275: PPUSH
53276: LD_VAR 0 12
53280: PPUSH
53281: CALL_OW 325
53285: IFFALSE 53314
// missile := Replace ( missile , missile + 1 , 2 ) ;
53287: LD_ADDR_VAR 0 14
53291: PUSH
53292: LD_VAR 0 14
53296: PPUSH
53297: LD_VAR 0 14
53301: PUSH
53302: LD_INT 1
53304: PLUS
53305: PPUSH
53306: LD_INT 2
53308: PPUSH
53309: CALL_OW 1
53313: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53314: LD_VAR 0 9
53318: PPUSH
53319: LD_VAR 0 13
53323: PPUSH
53324: CALL_OW 325
53328: PUSH
53329: LD_VAR 0 10
53333: PPUSH
53334: CALL_OW 255
53338: PPUSH
53339: LD_VAR 0 13
53343: PPUSH
53344: CALL_OW 325
53348: NOT
53349: AND
53350: IFFALSE 53379
// missile := Replace ( missile , missile + 1 , 3 ) ;
53352: LD_ADDR_VAR 0 14
53356: PUSH
53357: LD_VAR 0 14
53361: PPUSH
53362: LD_VAR 0 14
53366: PUSH
53367: LD_INT 1
53369: PLUS
53370: PPUSH
53371: LD_INT 3
53373: PPUSH
53374: CALL_OW 1
53378: ST_TO_ADDR
// if missile < 2 then
53379: LD_VAR 0 14
53383: PUSH
53384: LD_INT 2
53386: LESS
53387: IFFALSE 53391
// exit ;
53389: GO 53613
// x := GetX ( enemy ) ;
53391: LD_ADDR_VAR 0 4
53395: PUSH
53396: LD_VAR 0 10
53400: PPUSH
53401: CALL_OW 250
53405: ST_TO_ADDR
// y := GetY ( enemy ) ;
53406: LD_ADDR_VAR 0 5
53410: PUSH
53411: LD_VAR 0 10
53415: PPUSH
53416: CALL_OW 251
53420: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53421: LD_ADDR_VAR 0 6
53425: PUSH
53426: LD_VAR 0 4
53430: PUSH
53431: LD_INT 1
53433: NEG
53434: PPUSH
53435: LD_INT 1
53437: PPUSH
53438: CALL_OW 12
53442: PLUS
53443: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53444: LD_ADDR_VAR 0 7
53448: PUSH
53449: LD_VAR 0 5
53453: PUSH
53454: LD_INT 1
53456: NEG
53457: PPUSH
53458: LD_INT 1
53460: PPUSH
53461: CALL_OW 12
53465: PLUS
53466: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53467: LD_VAR 0 6
53471: PPUSH
53472: LD_VAR 0 7
53476: PPUSH
53477: CALL_OW 488
53481: NOT
53482: IFFALSE 53504
// begin _x := x ;
53484: LD_ADDR_VAR 0 6
53488: PUSH
53489: LD_VAR 0 4
53493: ST_TO_ADDR
// _y := y ;
53494: LD_ADDR_VAR 0 7
53498: PUSH
53499: LD_VAR 0 5
53503: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53504: LD_ADDR_VAR 0 3
53508: PUSH
53509: LD_INT 1
53511: PPUSH
53512: LD_VAR 0 14
53516: PPUSH
53517: CALL_OW 12
53521: ST_TO_ADDR
// case i of 1 :
53522: LD_VAR 0 3
53526: PUSH
53527: LD_INT 1
53529: DOUBLE
53530: EQUAL
53531: IFTRUE 53535
53533: GO 53552
53535: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53536: LD_VAR 0 1
53540: PPUSH
53541: LD_VAR 0 10
53545: PPUSH
53546: CALL_OW 115
53550: GO 53613
53552: LD_INT 2
53554: DOUBLE
53555: EQUAL
53556: IFTRUE 53560
53558: GO 53582
53560: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53561: LD_VAR 0 1
53565: PPUSH
53566: LD_VAR 0 6
53570: PPUSH
53571: LD_VAR 0 7
53575: PPUSH
53576: CALL_OW 153
53580: GO 53613
53582: LD_INT 3
53584: DOUBLE
53585: EQUAL
53586: IFTRUE 53590
53588: GO 53612
53590: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53591: LD_VAR 0 1
53595: PPUSH
53596: LD_VAR 0 6
53600: PPUSH
53601: LD_VAR 0 7
53605: PPUSH
53606: CALL_OW 154
53610: GO 53613
53612: POP
// end ;
53613: LD_VAR 0 2
53617: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53618: LD_INT 0
53620: PPUSH
53621: PPUSH
53622: PPUSH
53623: PPUSH
53624: PPUSH
53625: PPUSH
// if not unit or not building then
53626: LD_VAR 0 1
53630: NOT
53631: PUSH
53632: LD_VAR 0 2
53636: NOT
53637: OR
53638: IFFALSE 53642
// exit ;
53640: GO 53800
// x := GetX ( building ) ;
53642: LD_ADDR_VAR 0 5
53646: PUSH
53647: LD_VAR 0 2
53651: PPUSH
53652: CALL_OW 250
53656: ST_TO_ADDR
// y := GetY ( building ) ;
53657: LD_ADDR_VAR 0 6
53661: PUSH
53662: LD_VAR 0 2
53666: PPUSH
53667: CALL_OW 251
53671: ST_TO_ADDR
// for i = 0 to 5 do
53672: LD_ADDR_VAR 0 4
53676: PUSH
53677: DOUBLE
53678: LD_INT 0
53680: DEC
53681: ST_TO_ADDR
53682: LD_INT 5
53684: PUSH
53685: FOR_TO
53686: IFFALSE 53798
// begin _x := ShiftX ( x , i , 3 ) ;
53688: LD_ADDR_VAR 0 7
53692: PUSH
53693: LD_VAR 0 5
53697: PPUSH
53698: LD_VAR 0 4
53702: PPUSH
53703: LD_INT 3
53705: PPUSH
53706: CALL_OW 272
53710: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53711: LD_ADDR_VAR 0 8
53715: PUSH
53716: LD_VAR 0 6
53720: PPUSH
53721: LD_VAR 0 4
53725: PPUSH
53726: LD_INT 3
53728: PPUSH
53729: CALL_OW 273
53733: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53734: LD_VAR 0 7
53738: PPUSH
53739: LD_VAR 0 8
53743: PPUSH
53744: CALL_OW 488
53748: NOT
53749: IFFALSE 53753
// continue ;
53751: GO 53685
// if HexInfo ( _x , _y ) = 0 then
53753: LD_VAR 0 7
53757: PPUSH
53758: LD_VAR 0 8
53762: PPUSH
53763: CALL_OW 428
53767: PUSH
53768: LD_INT 0
53770: EQUAL
53771: IFFALSE 53796
// begin ComMoveXY ( unit , _x , _y ) ;
53773: LD_VAR 0 1
53777: PPUSH
53778: LD_VAR 0 7
53782: PPUSH
53783: LD_VAR 0 8
53787: PPUSH
53788: CALL_OW 111
// exit ;
53792: POP
53793: POP
53794: GO 53800
// end ; end ;
53796: GO 53685
53798: POP
53799: POP
// end ;
53800: LD_VAR 0 3
53804: RET
// export function ScanBase ( side , base_area ) ; begin
53805: LD_INT 0
53807: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53808: LD_ADDR_VAR 0 3
53812: PUSH
53813: LD_VAR 0 2
53817: PPUSH
53818: LD_INT 81
53820: PUSH
53821: LD_VAR 0 1
53825: PUSH
53826: EMPTY
53827: LIST
53828: LIST
53829: PPUSH
53830: CALL_OW 70
53834: ST_TO_ADDR
// end ;
53835: LD_VAR 0 3
53839: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53840: LD_INT 0
53842: PPUSH
53843: PPUSH
53844: PPUSH
53845: PPUSH
// result := false ;
53846: LD_ADDR_VAR 0 2
53850: PUSH
53851: LD_INT 0
53853: ST_TO_ADDR
// side := GetSide ( unit ) ;
53854: LD_ADDR_VAR 0 3
53858: PUSH
53859: LD_VAR 0 1
53863: PPUSH
53864: CALL_OW 255
53868: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53869: LD_ADDR_VAR 0 4
53873: PUSH
53874: LD_VAR 0 1
53878: PPUSH
53879: CALL_OW 248
53883: ST_TO_ADDR
// case nat of 1 :
53884: LD_VAR 0 4
53888: PUSH
53889: LD_INT 1
53891: DOUBLE
53892: EQUAL
53893: IFTRUE 53897
53895: GO 53908
53897: POP
// tech := tech_lassight ; 2 :
53898: LD_ADDR_VAR 0 5
53902: PUSH
53903: LD_INT 12
53905: ST_TO_ADDR
53906: GO 53947
53908: LD_INT 2
53910: DOUBLE
53911: EQUAL
53912: IFTRUE 53916
53914: GO 53927
53916: POP
// tech := tech_mortar ; 3 :
53917: LD_ADDR_VAR 0 5
53921: PUSH
53922: LD_INT 41
53924: ST_TO_ADDR
53925: GO 53947
53927: LD_INT 3
53929: DOUBLE
53930: EQUAL
53931: IFTRUE 53935
53933: GO 53946
53935: POP
// tech := tech_bazooka ; end ;
53936: LD_ADDR_VAR 0 5
53940: PUSH
53941: LD_INT 44
53943: ST_TO_ADDR
53944: GO 53947
53946: POP
// if Researched ( side , tech ) then
53947: LD_VAR 0 3
53951: PPUSH
53952: LD_VAR 0 5
53956: PPUSH
53957: CALL_OW 325
53961: IFFALSE 53988
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53963: LD_ADDR_VAR 0 2
53967: PUSH
53968: LD_INT 5
53970: PUSH
53971: LD_INT 8
53973: PUSH
53974: LD_INT 9
53976: PUSH
53977: EMPTY
53978: LIST
53979: LIST
53980: LIST
53981: PUSH
53982: LD_VAR 0 4
53986: ARRAY
53987: ST_TO_ADDR
// end ;
53988: LD_VAR 0 2
53992: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53993: LD_INT 0
53995: PPUSH
53996: PPUSH
53997: PPUSH
// if not mines then
53998: LD_VAR 0 2
54002: NOT
54003: IFFALSE 54007
// exit ;
54005: GO 54151
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54007: LD_ADDR_VAR 0 5
54011: PUSH
54012: LD_INT 81
54014: PUSH
54015: LD_VAR 0 1
54019: PUSH
54020: EMPTY
54021: LIST
54022: LIST
54023: PUSH
54024: LD_INT 3
54026: PUSH
54027: LD_INT 21
54029: PUSH
54030: LD_INT 3
54032: PUSH
54033: EMPTY
54034: LIST
54035: LIST
54036: PUSH
54037: EMPTY
54038: LIST
54039: LIST
54040: PUSH
54041: EMPTY
54042: LIST
54043: LIST
54044: PPUSH
54045: CALL_OW 69
54049: ST_TO_ADDR
// for i in mines do
54050: LD_ADDR_VAR 0 4
54054: PUSH
54055: LD_VAR 0 2
54059: PUSH
54060: FOR_IN
54061: IFFALSE 54149
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54063: LD_VAR 0 4
54067: PUSH
54068: LD_INT 1
54070: ARRAY
54071: PPUSH
54072: LD_VAR 0 4
54076: PUSH
54077: LD_INT 2
54079: ARRAY
54080: PPUSH
54081: CALL_OW 458
54085: NOT
54086: IFFALSE 54090
// continue ;
54088: GO 54060
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54090: LD_VAR 0 4
54094: PUSH
54095: LD_INT 1
54097: ARRAY
54098: PPUSH
54099: LD_VAR 0 4
54103: PUSH
54104: LD_INT 2
54106: ARRAY
54107: PPUSH
54108: CALL_OW 428
54112: PUSH
54113: LD_VAR 0 5
54117: IN
54118: IFFALSE 54147
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54120: LD_VAR 0 4
54124: PUSH
54125: LD_INT 1
54127: ARRAY
54128: PPUSH
54129: LD_VAR 0 4
54133: PUSH
54134: LD_INT 2
54136: ARRAY
54137: PPUSH
54138: LD_VAR 0 1
54142: PPUSH
54143: CALL_OW 456
// end ;
54147: GO 54060
54149: POP
54150: POP
// end ;
54151: LD_VAR 0 3
54155: RET
// export function Count ( array ) ; var i ; begin
54156: LD_INT 0
54158: PPUSH
54159: PPUSH
// result := 0 ;
54160: LD_ADDR_VAR 0 2
54164: PUSH
54165: LD_INT 0
54167: ST_TO_ADDR
// for i in array do
54168: LD_ADDR_VAR 0 3
54172: PUSH
54173: LD_VAR 0 1
54177: PUSH
54178: FOR_IN
54179: IFFALSE 54203
// if i then
54181: LD_VAR 0 3
54185: IFFALSE 54201
// result := result + 1 ;
54187: LD_ADDR_VAR 0 2
54191: PUSH
54192: LD_VAR 0 2
54196: PUSH
54197: LD_INT 1
54199: PLUS
54200: ST_TO_ADDR
54201: GO 54178
54203: POP
54204: POP
// end ;
54205: LD_VAR 0 2
54209: RET
// export function IsEmpty ( building ) ; begin
54210: LD_INT 0
54212: PPUSH
// if not building then
54213: LD_VAR 0 1
54217: NOT
54218: IFFALSE 54222
// exit ;
54220: GO 54265
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54222: LD_ADDR_VAR 0 2
54226: PUSH
54227: LD_VAR 0 1
54231: PUSH
54232: LD_INT 22
54234: PUSH
54235: LD_VAR 0 1
54239: PPUSH
54240: CALL_OW 255
54244: PUSH
54245: EMPTY
54246: LIST
54247: LIST
54248: PUSH
54249: LD_INT 58
54251: PUSH
54252: EMPTY
54253: LIST
54254: PUSH
54255: EMPTY
54256: LIST
54257: LIST
54258: PPUSH
54259: CALL_OW 69
54263: IN
54264: ST_TO_ADDR
// end ;
54265: LD_VAR 0 2
54269: RET
// export function IsNotFull ( building ) ; var places ; begin
54270: LD_INT 0
54272: PPUSH
54273: PPUSH
// if not building then
54274: LD_VAR 0 1
54278: NOT
54279: IFFALSE 54283
// exit ;
54281: GO 54454
// result := false ;
54283: LD_ADDR_VAR 0 2
54287: PUSH
54288: LD_INT 0
54290: ST_TO_ADDR
// places := 0 ;
54291: LD_ADDR_VAR 0 3
54295: PUSH
54296: LD_INT 0
54298: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
54299: LD_VAR 0 1
54303: PPUSH
54304: CALL_OW 266
54308: PUSH
54309: LD_INT 0
54311: DOUBLE
54312: EQUAL
54313: IFTRUE 54371
54315: LD_INT 1
54317: DOUBLE
54318: EQUAL
54319: IFTRUE 54371
54321: LD_INT 6
54323: DOUBLE
54324: EQUAL
54325: IFTRUE 54371
54327: LD_INT 7
54329: DOUBLE
54330: EQUAL
54331: IFTRUE 54371
54333: LD_INT 8
54335: DOUBLE
54336: EQUAL
54337: IFTRUE 54371
54339: LD_INT 4
54341: DOUBLE
54342: EQUAL
54343: IFTRUE 54371
54345: LD_INT 5
54347: DOUBLE
54348: EQUAL
54349: IFTRUE 54371
54351: LD_INT 2
54353: DOUBLE
54354: EQUAL
54355: IFTRUE 54371
54357: LD_INT 3
54359: DOUBLE
54360: EQUAL
54361: IFTRUE 54371
54363: LD_INT 35
54365: DOUBLE
54366: EQUAL
54367: IFTRUE 54371
54369: GO 54382
54371: POP
// places := 6 ; b_bunker , b_breastwork :
54372: LD_ADDR_VAR 0 3
54376: PUSH
54377: LD_INT 6
54379: ST_TO_ADDR
54380: GO 54427
54382: LD_INT 32
54384: DOUBLE
54385: EQUAL
54386: IFTRUE 54396
54388: LD_INT 31
54390: DOUBLE
54391: EQUAL
54392: IFTRUE 54396
54394: GO 54407
54396: POP
// places := 1 ; b_control_tower :
54397: LD_ADDR_VAR 0 3
54401: PUSH
54402: LD_INT 1
54404: ST_TO_ADDR
54405: GO 54427
54407: LD_INT 36
54409: DOUBLE
54410: EQUAL
54411: IFTRUE 54415
54413: GO 54426
54415: POP
// places := 3 ; end ;
54416: LD_ADDR_VAR 0 3
54420: PUSH
54421: LD_INT 3
54423: ST_TO_ADDR
54424: GO 54427
54426: POP
// if places then
54427: LD_VAR 0 3
54431: IFFALSE 54454
// result := UnitsInside ( building ) < places ;
54433: LD_ADDR_VAR 0 2
54437: PUSH
54438: LD_VAR 0 1
54442: PPUSH
54443: CALL_OW 313
54447: PUSH
54448: LD_VAR 0 3
54452: LESS
54453: ST_TO_ADDR
// end ;
54454: LD_VAR 0 2
54458: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54459: LD_INT 0
54461: PPUSH
54462: PPUSH
54463: PPUSH
54464: PPUSH
// tmp := [ ] ;
54465: LD_ADDR_VAR 0 3
54469: PUSH
54470: EMPTY
54471: ST_TO_ADDR
// list := [ ] ;
54472: LD_ADDR_VAR 0 5
54476: PUSH
54477: EMPTY
54478: ST_TO_ADDR
// for i = 16 to 25 do
54479: LD_ADDR_VAR 0 4
54483: PUSH
54484: DOUBLE
54485: LD_INT 16
54487: DEC
54488: ST_TO_ADDR
54489: LD_INT 25
54491: PUSH
54492: FOR_TO
54493: IFFALSE 54566
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54495: LD_ADDR_VAR 0 3
54499: PUSH
54500: LD_VAR 0 3
54504: PUSH
54505: LD_INT 22
54507: PUSH
54508: LD_VAR 0 1
54512: PPUSH
54513: CALL_OW 255
54517: PUSH
54518: EMPTY
54519: LIST
54520: LIST
54521: PUSH
54522: LD_INT 91
54524: PUSH
54525: LD_VAR 0 1
54529: PUSH
54530: LD_INT 6
54532: PUSH
54533: EMPTY
54534: LIST
54535: LIST
54536: LIST
54537: PUSH
54538: LD_INT 30
54540: PUSH
54541: LD_VAR 0 4
54545: PUSH
54546: EMPTY
54547: LIST
54548: LIST
54549: PUSH
54550: EMPTY
54551: LIST
54552: LIST
54553: LIST
54554: PUSH
54555: EMPTY
54556: LIST
54557: PPUSH
54558: CALL_OW 69
54562: ADD
54563: ST_TO_ADDR
54564: GO 54492
54566: POP
54567: POP
// for i = 1 to tmp do
54568: LD_ADDR_VAR 0 4
54572: PUSH
54573: DOUBLE
54574: LD_INT 1
54576: DEC
54577: ST_TO_ADDR
54578: LD_VAR 0 3
54582: PUSH
54583: FOR_TO
54584: IFFALSE 54672
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54586: LD_ADDR_VAR 0 5
54590: PUSH
54591: LD_VAR 0 5
54595: PUSH
54596: LD_VAR 0 3
54600: PUSH
54601: LD_VAR 0 4
54605: ARRAY
54606: PPUSH
54607: CALL_OW 266
54611: PUSH
54612: LD_VAR 0 3
54616: PUSH
54617: LD_VAR 0 4
54621: ARRAY
54622: PPUSH
54623: CALL_OW 250
54627: PUSH
54628: LD_VAR 0 3
54632: PUSH
54633: LD_VAR 0 4
54637: ARRAY
54638: PPUSH
54639: CALL_OW 251
54643: PUSH
54644: LD_VAR 0 3
54648: PUSH
54649: LD_VAR 0 4
54653: ARRAY
54654: PPUSH
54655: CALL_OW 254
54659: PUSH
54660: EMPTY
54661: LIST
54662: LIST
54663: LIST
54664: LIST
54665: PUSH
54666: EMPTY
54667: LIST
54668: ADD
54669: ST_TO_ADDR
54670: GO 54583
54672: POP
54673: POP
// result := list ;
54674: LD_ADDR_VAR 0 2
54678: PUSH
54679: LD_VAR 0 5
54683: ST_TO_ADDR
// end ;
54684: LD_VAR 0 2
54688: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54689: LD_INT 0
54691: PPUSH
54692: PPUSH
54693: PPUSH
54694: PPUSH
54695: PPUSH
54696: PPUSH
54697: PPUSH
// if not factory then
54698: LD_VAR 0 1
54702: NOT
54703: IFFALSE 54707
// exit ;
54705: GO 55300
// if control = control_apeman then
54707: LD_VAR 0 4
54711: PUSH
54712: LD_INT 5
54714: EQUAL
54715: IFFALSE 54824
// begin tmp := UnitsInside ( factory ) ;
54717: LD_ADDR_VAR 0 8
54721: PUSH
54722: LD_VAR 0 1
54726: PPUSH
54727: CALL_OW 313
54731: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54732: LD_VAR 0 8
54736: PPUSH
54737: LD_INT 25
54739: PUSH
54740: LD_INT 12
54742: PUSH
54743: EMPTY
54744: LIST
54745: LIST
54746: PPUSH
54747: CALL_OW 72
54751: NOT
54752: IFFALSE 54762
// control := control_manual ;
54754: LD_ADDR_VAR 0 4
54758: PUSH
54759: LD_INT 1
54761: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54762: LD_ADDR_VAR 0 8
54766: PUSH
54767: LD_VAR 0 1
54771: PPUSH
54772: CALL 54459 0 1
54776: ST_TO_ADDR
// if tmp then
54777: LD_VAR 0 8
54781: IFFALSE 54824
// begin for i in tmp do
54783: LD_ADDR_VAR 0 7
54787: PUSH
54788: LD_VAR 0 8
54792: PUSH
54793: FOR_IN
54794: IFFALSE 54822
// if i [ 1 ] = b_ext_radio then
54796: LD_VAR 0 7
54800: PUSH
54801: LD_INT 1
54803: ARRAY
54804: PUSH
54805: LD_INT 22
54807: EQUAL
54808: IFFALSE 54820
// begin control := control_remote ;
54810: LD_ADDR_VAR 0 4
54814: PUSH
54815: LD_INT 2
54817: ST_TO_ADDR
// break ;
54818: GO 54822
// end ;
54820: GO 54793
54822: POP
54823: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54824: LD_VAR 0 1
54828: PPUSH
54829: LD_VAR 0 2
54833: PPUSH
54834: LD_VAR 0 3
54838: PPUSH
54839: LD_VAR 0 4
54843: PPUSH
54844: LD_VAR 0 5
54848: PPUSH
54849: CALL_OW 448
54853: IFFALSE 54888
// begin result := [ chassis , engine , control , weapon ] ;
54855: LD_ADDR_VAR 0 6
54859: PUSH
54860: LD_VAR 0 2
54864: PUSH
54865: LD_VAR 0 3
54869: PUSH
54870: LD_VAR 0 4
54874: PUSH
54875: LD_VAR 0 5
54879: PUSH
54880: EMPTY
54881: LIST
54882: LIST
54883: LIST
54884: LIST
54885: ST_TO_ADDR
// exit ;
54886: GO 55300
// end ; _chassis := AvailableChassisList ( factory ) ;
54888: LD_ADDR_VAR 0 9
54892: PUSH
54893: LD_VAR 0 1
54897: PPUSH
54898: CALL_OW 475
54902: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54903: LD_ADDR_VAR 0 11
54907: PUSH
54908: LD_VAR 0 1
54912: PPUSH
54913: CALL_OW 476
54917: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54918: LD_ADDR_VAR 0 12
54922: PUSH
54923: LD_VAR 0 1
54927: PPUSH
54928: CALL_OW 477
54932: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54933: LD_ADDR_VAR 0 10
54937: PUSH
54938: LD_VAR 0 1
54942: PPUSH
54943: CALL_OW 478
54947: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54948: LD_VAR 0 9
54952: NOT
54953: PUSH
54954: LD_VAR 0 11
54958: NOT
54959: OR
54960: PUSH
54961: LD_VAR 0 12
54965: NOT
54966: OR
54967: PUSH
54968: LD_VAR 0 10
54972: NOT
54973: OR
54974: IFFALSE 55009
// begin result := [ chassis , engine , control , weapon ] ;
54976: LD_ADDR_VAR 0 6
54980: PUSH
54981: LD_VAR 0 2
54985: PUSH
54986: LD_VAR 0 3
54990: PUSH
54991: LD_VAR 0 4
54995: PUSH
54996: LD_VAR 0 5
55000: PUSH
55001: EMPTY
55002: LIST
55003: LIST
55004: LIST
55005: LIST
55006: ST_TO_ADDR
// exit ;
55007: GO 55300
// end ; if not chassis in _chassis then
55009: LD_VAR 0 2
55013: PUSH
55014: LD_VAR 0 9
55018: IN
55019: NOT
55020: IFFALSE 55046
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55022: LD_ADDR_VAR 0 2
55026: PUSH
55027: LD_VAR 0 9
55031: PUSH
55032: LD_INT 1
55034: PPUSH
55035: LD_VAR 0 9
55039: PPUSH
55040: CALL_OW 12
55044: ARRAY
55045: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55046: LD_VAR 0 2
55050: PPUSH
55051: LD_VAR 0 3
55055: PPUSH
55056: CALL 55305 0 2
55060: NOT
55061: IFFALSE 55120
// repeat engine := _engine [ 1 ] ;
55063: LD_ADDR_VAR 0 3
55067: PUSH
55068: LD_VAR 0 11
55072: PUSH
55073: LD_INT 1
55075: ARRAY
55076: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55077: LD_ADDR_VAR 0 11
55081: PUSH
55082: LD_VAR 0 11
55086: PPUSH
55087: LD_INT 1
55089: PPUSH
55090: CALL_OW 3
55094: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55095: LD_VAR 0 2
55099: PPUSH
55100: LD_VAR 0 3
55104: PPUSH
55105: CALL 55305 0 2
55109: PUSH
55110: LD_VAR 0 11
55114: PUSH
55115: EMPTY
55116: EQUAL
55117: OR
55118: IFFALSE 55063
// if not control in _control then
55120: LD_VAR 0 4
55124: PUSH
55125: LD_VAR 0 12
55129: IN
55130: NOT
55131: IFFALSE 55157
// control := _control [ rand ( 1 , _control ) ] ;
55133: LD_ADDR_VAR 0 4
55137: PUSH
55138: LD_VAR 0 12
55142: PUSH
55143: LD_INT 1
55145: PPUSH
55146: LD_VAR 0 12
55150: PPUSH
55151: CALL_OW 12
55155: ARRAY
55156: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55157: LD_VAR 0 2
55161: PPUSH
55162: LD_VAR 0 5
55166: PPUSH
55167: CALL 55525 0 2
55171: NOT
55172: IFFALSE 55231
// repeat weapon := _weapon [ 1 ] ;
55174: LD_ADDR_VAR 0 5
55178: PUSH
55179: LD_VAR 0 10
55183: PUSH
55184: LD_INT 1
55186: ARRAY
55187: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55188: LD_ADDR_VAR 0 10
55192: PUSH
55193: LD_VAR 0 10
55197: PPUSH
55198: LD_INT 1
55200: PPUSH
55201: CALL_OW 3
55205: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55206: LD_VAR 0 2
55210: PPUSH
55211: LD_VAR 0 5
55215: PPUSH
55216: CALL 55525 0 2
55220: PUSH
55221: LD_VAR 0 10
55225: PUSH
55226: EMPTY
55227: EQUAL
55228: OR
55229: IFFALSE 55174
// result := [ ] ;
55231: LD_ADDR_VAR 0 6
55235: PUSH
55236: EMPTY
55237: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55238: LD_VAR 0 1
55242: PPUSH
55243: LD_VAR 0 2
55247: PPUSH
55248: LD_VAR 0 3
55252: PPUSH
55253: LD_VAR 0 4
55257: PPUSH
55258: LD_VAR 0 5
55262: PPUSH
55263: CALL_OW 448
55267: IFFALSE 55300
// result := [ chassis , engine , control , weapon ] ;
55269: LD_ADDR_VAR 0 6
55273: PUSH
55274: LD_VAR 0 2
55278: PUSH
55279: LD_VAR 0 3
55283: PUSH
55284: LD_VAR 0 4
55288: PUSH
55289: LD_VAR 0 5
55293: PUSH
55294: EMPTY
55295: LIST
55296: LIST
55297: LIST
55298: LIST
55299: ST_TO_ADDR
// end ;
55300: LD_VAR 0 6
55304: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55305: LD_INT 0
55307: PPUSH
// if not chassis or not engine then
55308: LD_VAR 0 1
55312: NOT
55313: PUSH
55314: LD_VAR 0 2
55318: NOT
55319: OR
55320: IFFALSE 55324
// exit ;
55322: GO 55520
// case engine of engine_solar :
55324: LD_VAR 0 2
55328: PUSH
55329: LD_INT 2
55331: DOUBLE
55332: EQUAL
55333: IFTRUE 55337
55335: GO 55375
55337: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55338: LD_ADDR_VAR 0 3
55342: PUSH
55343: LD_INT 11
55345: PUSH
55346: LD_INT 12
55348: PUSH
55349: LD_INT 13
55351: PUSH
55352: LD_INT 14
55354: PUSH
55355: LD_INT 1
55357: PUSH
55358: LD_INT 2
55360: PUSH
55361: LD_INT 3
55363: PUSH
55364: EMPTY
55365: LIST
55366: LIST
55367: LIST
55368: LIST
55369: LIST
55370: LIST
55371: LIST
55372: ST_TO_ADDR
55373: GO 55504
55375: LD_INT 1
55377: DOUBLE
55378: EQUAL
55379: IFTRUE 55383
55381: GO 55445
55383: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55384: LD_ADDR_VAR 0 3
55388: PUSH
55389: LD_INT 11
55391: PUSH
55392: LD_INT 12
55394: PUSH
55395: LD_INT 13
55397: PUSH
55398: LD_INT 14
55400: PUSH
55401: LD_INT 1
55403: PUSH
55404: LD_INT 2
55406: PUSH
55407: LD_INT 3
55409: PUSH
55410: LD_INT 4
55412: PUSH
55413: LD_INT 5
55415: PUSH
55416: LD_INT 21
55418: PUSH
55419: LD_INT 23
55421: PUSH
55422: LD_INT 22
55424: PUSH
55425: LD_INT 24
55427: PUSH
55428: EMPTY
55429: LIST
55430: LIST
55431: LIST
55432: LIST
55433: LIST
55434: LIST
55435: LIST
55436: LIST
55437: LIST
55438: LIST
55439: LIST
55440: LIST
55441: LIST
55442: ST_TO_ADDR
55443: GO 55504
55445: LD_INT 3
55447: DOUBLE
55448: EQUAL
55449: IFTRUE 55453
55451: GO 55503
55453: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55454: LD_ADDR_VAR 0 3
55458: PUSH
55459: LD_INT 13
55461: PUSH
55462: LD_INT 14
55464: PUSH
55465: LD_INT 2
55467: PUSH
55468: LD_INT 3
55470: PUSH
55471: LD_INT 4
55473: PUSH
55474: LD_INT 5
55476: PUSH
55477: LD_INT 21
55479: PUSH
55480: LD_INT 22
55482: PUSH
55483: LD_INT 23
55485: PUSH
55486: LD_INT 24
55488: PUSH
55489: EMPTY
55490: LIST
55491: LIST
55492: LIST
55493: LIST
55494: LIST
55495: LIST
55496: LIST
55497: LIST
55498: LIST
55499: LIST
55500: ST_TO_ADDR
55501: GO 55504
55503: POP
// result := ( chassis in result ) ;
55504: LD_ADDR_VAR 0 3
55508: PUSH
55509: LD_VAR 0 1
55513: PUSH
55514: LD_VAR 0 3
55518: IN
55519: ST_TO_ADDR
// end ;
55520: LD_VAR 0 3
55524: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55525: LD_INT 0
55527: PPUSH
// if not chassis or not weapon then
55528: LD_VAR 0 1
55532: NOT
55533: PUSH
55534: LD_VAR 0 2
55538: NOT
55539: OR
55540: IFFALSE 55544
// exit ;
55542: GO 56606
// case weapon of us_machine_gun :
55544: LD_VAR 0 2
55548: PUSH
55549: LD_INT 2
55551: DOUBLE
55552: EQUAL
55553: IFTRUE 55557
55555: GO 55587
55557: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55558: LD_ADDR_VAR 0 3
55562: PUSH
55563: LD_INT 1
55565: PUSH
55566: LD_INT 2
55568: PUSH
55569: LD_INT 3
55571: PUSH
55572: LD_INT 4
55574: PUSH
55575: LD_INT 5
55577: PUSH
55578: EMPTY
55579: LIST
55580: LIST
55581: LIST
55582: LIST
55583: LIST
55584: ST_TO_ADDR
55585: GO 56590
55587: LD_INT 3
55589: DOUBLE
55590: EQUAL
55591: IFTRUE 55595
55593: GO 55625
55595: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55596: LD_ADDR_VAR 0 3
55600: PUSH
55601: LD_INT 1
55603: PUSH
55604: LD_INT 2
55606: PUSH
55607: LD_INT 3
55609: PUSH
55610: LD_INT 4
55612: PUSH
55613: LD_INT 5
55615: PUSH
55616: EMPTY
55617: LIST
55618: LIST
55619: LIST
55620: LIST
55621: LIST
55622: ST_TO_ADDR
55623: GO 56590
55625: LD_INT 11
55627: DOUBLE
55628: EQUAL
55629: IFTRUE 55633
55631: GO 55663
55633: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55634: LD_ADDR_VAR 0 3
55638: PUSH
55639: LD_INT 1
55641: PUSH
55642: LD_INT 2
55644: PUSH
55645: LD_INT 3
55647: PUSH
55648: LD_INT 4
55650: PUSH
55651: LD_INT 5
55653: PUSH
55654: EMPTY
55655: LIST
55656: LIST
55657: LIST
55658: LIST
55659: LIST
55660: ST_TO_ADDR
55661: GO 56590
55663: LD_INT 4
55665: DOUBLE
55666: EQUAL
55667: IFTRUE 55671
55669: GO 55697
55671: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55672: LD_ADDR_VAR 0 3
55676: PUSH
55677: LD_INT 2
55679: PUSH
55680: LD_INT 3
55682: PUSH
55683: LD_INT 4
55685: PUSH
55686: LD_INT 5
55688: PUSH
55689: EMPTY
55690: LIST
55691: LIST
55692: LIST
55693: LIST
55694: ST_TO_ADDR
55695: GO 56590
55697: LD_INT 5
55699: DOUBLE
55700: EQUAL
55701: IFTRUE 55705
55703: GO 55731
55705: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55706: LD_ADDR_VAR 0 3
55710: PUSH
55711: LD_INT 2
55713: PUSH
55714: LD_INT 3
55716: PUSH
55717: LD_INT 4
55719: PUSH
55720: LD_INT 5
55722: PUSH
55723: EMPTY
55724: LIST
55725: LIST
55726: LIST
55727: LIST
55728: ST_TO_ADDR
55729: GO 56590
55731: LD_INT 9
55733: DOUBLE
55734: EQUAL
55735: IFTRUE 55739
55737: GO 55765
55739: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55740: LD_ADDR_VAR 0 3
55744: PUSH
55745: LD_INT 2
55747: PUSH
55748: LD_INT 3
55750: PUSH
55751: LD_INT 4
55753: PUSH
55754: LD_INT 5
55756: PUSH
55757: EMPTY
55758: LIST
55759: LIST
55760: LIST
55761: LIST
55762: ST_TO_ADDR
55763: GO 56590
55765: LD_INT 7
55767: DOUBLE
55768: EQUAL
55769: IFTRUE 55773
55771: GO 55799
55773: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55774: LD_ADDR_VAR 0 3
55778: PUSH
55779: LD_INT 2
55781: PUSH
55782: LD_INT 3
55784: PUSH
55785: LD_INT 4
55787: PUSH
55788: LD_INT 5
55790: PUSH
55791: EMPTY
55792: LIST
55793: LIST
55794: LIST
55795: LIST
55796: ST_TO_ADDR
55797: GO 56590
55799: LD_INT 12
55801: DOUBLE
55802: EQUAL
55803: IFTRUE 55807
55805: GO 55833
55807: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55808: LD_ADDR_VAR 0 3
55812: PUSH
55813: LD_INT 2
55815: PUSH
55816: LD_INT 3
55818: PUSH
55819: LD_INT 4
55821: PUSH
55822: LD_INT 5
55824: PUSH
55825: EMPTY
55826: LIST
55827: LIST
55828: LIST
55829: LIST
55830: ST_TO_ADDR
55831: GO 56590
55833: LD_INT 13
55835: DOUBLE
55836: EQUAL
55837: IFTRUE 55841
55839: GO 55867
55841: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55842: LD_ADDR_VAR 0 3
55846: PUSH
55847: LD_INT 2
55849: PUSH
55850: LD_INT 3
55852: PUSH
55853: LD_INT 4
55855: PUSH
55856: LD_INT 5
55858: PUSH
55859: EMPTY
55860: LIST
55861: LIST
55862: LIST
55863: LIST
55864: ST_TO_ADDR
55865: GO 56590
55867: LD_INT 14
55869: DOUBLE
55870: EQUAL
55871: IFTRUE 55875
55873: GO 55893
55875: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55876: LD_ADDR_VAR 0 3
55880: PUSH
55881: LD_INT 4
55883: PUSH
55884: LD_INT 5
55886: PUSH
55887: EMPTY
55888: LIST
55889: LIST
55890: ST_TO_ADDR
55891: GO 56590
55893: LD_INT 6
55895: DOUBLE
55896: EQUAL
55897: IFTRUE 55901
55899: GO 55919
55901: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55902: LD_ADDR_VAR 0 3
55906: PUSH
55907: LD_INT 4
55909: PUSH
55910: LD_INT 5
55912: PUSH
55913: EMPTY
55914: LIST
55915: LIST
55916: ST_TO_ADDR
55917: GO 56590
55919: LD_INT 10
55921: DOUBLE
55922: EQUAL
55923: IFTRUE 55927
55925: GO 55945
55927: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55928: LD_ADDR_VAR 0 3
55932: PUSH
55933: LD_INT 4
55935: PUSH
55936: LD_INT 5
55938: PUSH
55939: EMPTY
55940: LIST
55941: LIST
55942: ST_TO_ADDR
55943: GO 56590
55945: LD_INT 22
55947: DOUBLE
55948: EQUAL
55949: IFTRUE 55953
55951: GO 55979
55953: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55954: LD_ADDR_VAR 0 3
55958: PUSH
55959: LD_INT 11
55961: PUSH
55962: LD_INT 12
55964: PUSH
55965: LD_INT 13
55967: PUSH
55968: LD_INT 14
55970: PUSH
55971: EMPTY
55972: LIST
55973: LIST
55974: LIST
55975: LIST
55976: ST_TO_ADDR
55977: GO 56590
55979: LD_INT 23
55981: DOUBLE
55982: EQUAL
55983: IFTRUE 55987
55985: GO 56013
55987: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55988: LD_ADDR_VAR 0 3
55992: PUSH
55993: LD_INT 11
55995: PUSH
55996: LD_INT 12
55998: PUSH
55999: LD_INT 13
56001: PUSH
56002: LD_INT 14
56004: PUSH
56005: EMPTY
56006: LIST
56007: LIST
56008: LIST
56009: LIST
56010: ST_TO_ADDR
56011: GO 56590
56013: LD_INT 24
56015: DOUBLE
56016: EQUAL
56017: IFTRUE 56021
56019: GO 56047
56021: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56022: LD_ADDR_VAR 0 3
56026: PUSH
56027: LD_INT 11
56029: PUSH
56030: LD_INT 12
56032: PUSH
56033: LD_INT 13
56035: PUSH
56036: LD_INT 14
56038: PUSH
56039: EMPTY
56040: LIST
56041: LIST
56042: LIST
56043: LIST
56044: ST_TO_ADDR
56045: GO 56590
56047: LD_INT 30
56049: DOUBLE
56050: EQUAL
56051: IFTRUE 56055
56053: GO 56081
56055: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56056: LD_ADDR_VAR 0 3
56060: PUSH
56061: LD_INT 11
56063: PUSH
56064: LD_INT 12
56066: PUSH
56067: LD_INT 13
56069: PUSH
56070: LD_INT 14
56072: PUSH
56073: EMPTY
56074: LIST
56075: LIST
56076: LIST
56077: LIST
56078: ST_TO_ADDR
56079: GO 56590
56081: LD_INT 25
56083: DOUBLE
56084: EQUAL
56085: IFTRUE 56089
56087: GO 56107
56089: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56090: LD_ADDR_VAR 0 3
56094: PUSH
56095: LD_INT 13
56097: PUSH
56098: LD_INT 14
56100: PUSH
56101: EMPTY
56102: LIST
56103: LIST
56104: ST_TO_ADDR
56105: GO 56590
56107: LD_INT 27
56109: DOUBLE
56110: EQUAL
56111: IFTRUE 56115
56113: GO 56133
56115: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
56116: LD_ADDR_VAR 0 3
56120: PUSH
56121: LD_INT 13
56123: PUSH
56124: LD_INT 14
56126: PUSH
56127: EMPTY
56128: LIST
56129: LIST
56130: ST_TO_ADDR
56131: GO 56590
56133: LD_EXP 79
56137: DOUBLE
56138: EQUAL
56139: IFTRUE 56143
56141: GO 56169
56143: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56144: LD_ADDR_VAR 0 3
56148: PUSH
56149: LD_INT 11
56151: PUSH
56152: LD_INT 12
56154: PUSH
56155: LD_INT 13
56157: PUSH
56158: LD_INT 14
56160: PUSH
56161: EMPTY
56162: LIST
56163: LIST
56164: LIST
56165: LIST
56166: ST_TO_ADDR
56167: GO 56590
56169: LD_INT 28
56171: DOUBLE
56172: EQUAL
56173: IFTRUE 56177
56175: GO 56195
56177: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56178: LD_ADDR_VAR 0 3
56182: PUSH
56183: LD_INT 13
56185: PUSH
56186: LD_INT 14
56188: PUSH
56189: EMPTY
56190: LIST
56191: LIST
56192: ST_TO_ADDR
56193: GO 56590
56195: LD_INT 29
56197: DOUBLE
56198: EQUAL
56199: IFTRUE 56203
56201: GO 56221
56203: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56204: LD_ADDR_VAR 0 3
56208: PUSH
56209: LD_INT 13
56211: PUSH
56212: LD_INT 14
56214: PUSH
56215: EMPTY
56216: LIST
56217: LIST
56218: ST_TO_ADDR
56219: GO 56590
56221: LD_INT 31
56223: DOUBLE
56224: EQUAL
56225: IFTRUE 56229
56227: GO 56247
56229: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56230: LD_ADDR_VAR 0 3
56234: PUSH
56235: LD_INT 13
56237: PUSH
56238: LD_INT 14
56240: PUSH
56241: EMPTY
56242: LIST
56243: LIST
56244: ST_TO_ADDR
56245: GO 56590
56247: LD_INT 26
56249: DOUBLE
56250: EQUAL
56251: IFTRUE 56255
56253: GO 56273
56255: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56256: LD_ADDR_VAR 0 3
56260: PUSH
56261: LD_INT 13
56263: PUSH
56264: LD_INT 14
56266: PUSH
56267: EMPTY
56268: LIST
56269: LIST
56270: ST_TO_ADDR
56271: GO 56590
56273: LD_INT 42
56275: DOUBLE
56276: EQUAL
56277: IFTRUE 56281
56279: GO 56307
56281: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56282: LD_ADDR_VAR 0 3
56286: PUSH
56287: LD_INT 21
56289: PUSH
56290: LD_INT 22
56292: PUSH
56293: LD_INT 23
56295: PUSH
56296: LD_INT 24
56298: PUSH
56299: EMPTY
56300: LIST
56301: LIST
56302: LIST
56303: LIST
56304: ST_TO_ADDR
56305: GO 56590
56307: LD_INT 43
56309: DOUBLE
56310: EQUAL
56311: IFTRUE 56315
56313: GO 56341
56315: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56316: LD_ADDR_VAR 0 3
56320: PUSH
56321: LD_INT 21
56323: PUSH
56324: LD_INT 22
56326: PUSH
56327: LD_INT 23
56329: PUSH
56330: LD_INT 24
56332: PUSH
56333: EMPTY
56334: LIST
56335: LIST
56336: LIST
56337: LIST
56338: ST_TO_ADDR
56339: GO 56590
56341: LD_INT 44
56343: DOUBLE
56344: EQUAL
56345: IFTRUE 56349
56347: GO 56375
56349: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56350: LD_ADDR_VAR 0 3
56354: PUSH
56355: LD_INT 21
56357: PUSH
56358: LD_INT 22
56360: PUSH
56361: LD_INT 23
56363: PUSH
56364: LD_INT 24
56366: PUSH
56367: EMPTY
56368: LIST
56369: LIST
56370: LIST
56371: LIST
56372: ST_TO_ADDR
56373: GO 56590
56375: LD_INT 45
56377: DOUBLE
56378: EQUAL
56379: IFTRUE 56383
56381: GO 56409
56383: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56384: LD_ADDR_VAR 0 3
56388: PUSH
56389: LD_INT 21
56391: PUSH
56392: LD_INT 22
56394: PUSH
56395: LD_INT 23
56397: PUSH
56398: LD_INT 24
56400: PUSH
56401: EMPTY
56402: LIST
56403: LIST
56404: LIST
56405: LIST
56406: ST_TO_ADDR
56407: GO 56590
56409: LD_INT 49
56411: DOUBLE
56412: EQUAL
56413: IFTRUE 56417
56415: GO 56443
56417: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56418: LD_ADDR_VAR 0 3
56422: PUSH
56423: LD_INT 21
56425: PUSH
56426: LD_INT 22
56428: PUSH
56429: LD_INT 23
56431: PUSH
56432: LD_INT 24
56434: PUSH
56435: EMPTY
56436: LIST
56437: LIST
56438: LIST
56439: LIST
56440: ST_TO_ADDR
56441: GO 56590
56443: LD_INT 51
56445: DOUBLE
56446: EQUAL
56447: IFTRUE 56451
56449: GO 56477
56451: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56452: LD_ADDR_VAR 0 3
56456: PUSH
56457: LD_INT 21
56459: PUSH
56460: LD_INT 22
56462: PUSH
56463: LD_INT 23
56465: PUSH
56466: LD_INT 24
56468: PUSH
56469: EMPTY
56470: LIST
56471: LIST
56472: LIST
56473: LIST
56474: ST_TO_ADDR
56475: GO 56590
56477: LD_INT 52
56479: DOUBLE
56480: EQUAL
56481: IFTRUE 56485
56483: GO 56511
56485: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56486: LD_ADDR_VAR 0 3
56490: PUSH
56491: LD_INT 21
56493: PUSH
56494: LD_INT 22
56496: PUSH
56497: LD_INT 23
56499: PUSH
56500: LD_INT 24
56502: PUSH
56503: EMPTY
56504: LIST
56505: LIST
56506: LIST
56507: LIST
56508: ST_TO_ADDR
56509: GO 56590
56511: LD_INT 53
56513: DOUBLE
56514: EQUAL
56515: IFTRUE 56519
56517: GO 56537
56519: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56520: LD_ADDR_VAR 0 3
56524: PUSH
56525: LD_INT 23
56527: PUSH
56528: LD_INT 24
56530: PUSH
56531: EMPTY
56532: LIST
56533: LIST
56534: ST_TO_ADDR
56535: GO 56590
56537: LD_INT 46
56539: DOUBLE
56540: EQUAL
56541: IFTRUE 56545
56543: GO 56563
56545: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56546: LD_ADDR_VAR 0 3
56550: PUSH
56551: LD_INT 23
56553: PUSH
56554: LD_INT 24
56556: PUSH
56557: EMPTY
56558: LIST
56559: LIST
56560: ST_TO_ADDR
56561: GO 56590
56563: LD_INT 47
56565: DOUBLE
56566: EQUAL
56567: IFTRUE 56571
56569: GO 56589
56571: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56572: LD_ADDR_VAR 0 3
56576: PUSH
56577: LD_INT 23
56579: PUSH
56580: LD_INT 24
56582: PUSH
56583: EMPTY
56584: LIST
56585: LIST
56586: ST_TO_ADDR
56587: GO 56590
56589: POP
// result := ( chassis in result ) ;
56590: LD_ADDR_VAR 0 3
56594: PUSH
56595: LD_VAR 0 1
56599: PUSH
56600: LD_VAR 0 3
56604: IN
56605: ST_TO_ADDR
// end ;
56606: LD_VAR 0 3
56610: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56611: LD_INT 0
56613: PPUSH
56614: PPUSH
56615: PPUSH
56616: PPUSH
56617: PPUSH
56618: PPUSH
56619: PPUSH
// result := array ;
56620: LD_ADDR_VAR 0 5
56624: PUSH
56625: LD_VAR 0 1
56629: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56630: LD_VAR 0 1
56634: NOT
56635: PUSH
56636: LD_VAR 0 2
56640: NOT
56641: OR
56642: PUSH
56643: LD_VAR 0 3
56647: NOT
56648: OR
56649: PUSH
56650: LD_VAR 0 2
56654: PUSH
56655: LD_VAR 0 1
56659: GREATER
56660: OR
56661: PUSH
56662: LD_VAR 0 3
56666: PUSH
56667: LD_VAR 0 1
56671: GREATER
56672: OR
56673: IFFALSE 56677
// exit ;
56675: GO 56973
// if direction then
56677: LD_VAR 0 4
56681: IFFALSE 56745
// begin d := 1 ;
56683: LD_ADDR_VAR 0 9
56687: PUSH
56688: LD_INT 1
56690: ST_TO_ADDR
// if i_from > i_to then
56691: LD_VAR 0 2
56695: PUSH
56696: LD_VAR 0 3
56700: GREATER
56701: IFFALSE 56727
// length := ( array - i_from ) + i_to else
56703: LD_ADDR_VAR 0 11
56707: PUSH
56708: LD_VAR 0 1
56712: PUSH
56713: LD_VAR 0 2
56717: MINUS
56718: PUSH
56719: LD_VAR 0 3
56723: PLUS
56724: ST_TO_ADDR
56725: GO 56743
// length := i_to - i_from ;
56727: LD_ADDR_VAR 0 11
56731: PUSH
56732: LD_VAR 0 3
56736: PUSH
56737: LD_VAR 0 2
56741: MINUS
56742: ST_TO_ADDR
// end else
56743: GO 56806
// begin d := - 1 ;
56745: LD_ADDR_VAR 0 9
56749: PUSH
56750: LD_INT 1
56752: NEG
56753: ST_TO_ADDR
// if i_from > i_to then
56754: LD_VAR 0 2
56758: PUSH
56759: LD_VAR 0 3
56763: GREATER
56764: IFFALSE 56784
// length := i_from - i_to else
56766: LD_ADDR_VAR 0 11
56770: PUSH
56771: LD_VAR 0 2
56775: PUSH
56776: LD_VAR 0 3
56780: MINUS
56781: ST_TO_ADDR
56782: GO 56806
// length := ( array - i_to ) + i_from ;
56784: LD_ADDR_VAR 0 11
56788: PUSH
56789: LD_VAR 0 1
56793: PUSH
56794: LD_VAR 0 3
56798: MINUS
56799: PUSH
56800: LD_VAR 0 2
56804: PLUS
56805: ST_TO_ADDR
// end ; if not length then
56806: LD_VAR 0 11
56810: NOT
56811: IFFALSE 56815
// exit ;
56813: GO 56973
// tmp := array ;
56815: LD_ADDR_VAR 0 10
56819: PUSH
56820: LD_VAR 0 1
56824: ST_TO_ADDR
// for i = 1 to length do
56825: LD_ADDR_VAR 0 6
56829: PUSH
56830: DOUBLE
56831: LD_INT 1
56833: DEC
56834: ST_TO_ADDR
56835: LD_VAR 0 11
56839: PUSH
56840: FOR_TO
56841: IFFALSE 56961
// begin for j = 1 to array do
56843: LD_ADDR_VAR 0 7
56847: PUSH
56848: DOUBLE
56849: LD_INT 1
56851: DEC
56852: ST_TO_ADDR
56853: LD_VAR 0 1
56857: PUSH
56858: FOR_TO
56859: IFFALSE 56947
// begin k := j + d ;
56861: LD_ADDR_VAR 0 8
56865: PUSH
56866: LD_VAR 0 7
56870: PUSH
56871: LD_VAR 0 9
56875: PLUS
56876: ST_TO_ADDR
// if k > array then
56877: LD_VAR 0 8
56881: PUSH
56882: LD_VAR 0 1
56886: GREATER
56887: IFFALSE 56897
// k := 1 ;
56889: LD_ADDR_VAR 0 8
56893: PUSH
56894: LD_INT 1
56896: ST_TO_ADDR
// if not k then
56897: LD_VAR 0 8
56901: NOT
56902: IFFALSE 56914
// k := array ;
56904: LD_ADDR_VAR 0 8
56908: PUSH
56909: LD_VAR 0 1
56913: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56914: LD_ADDR_VAR 0 10
56918: PUSH
56919: LD_VAR 0 10
56923: PPUSH
56924: LD_VAR 0 8
56928: PPUSH
56929: LD_VAR 0 1
56933: PUSH
56934: LD_VAR 0 7
56938: ARRAY
56939: PPUSH
56940: CALL_OW 1
56944: ST_TO_ADDR
// end ;
56945: GO 56858
56947: POP
56948: POP
// array := tmp ;
56949: LD_ADDR_VAR 0 1
56953: PUSH
56954: LD_VAR 0 10
56958: ST_TO_ADDR
// end ;
56959: GO 56840
56961: POP
56962: POP
// result := array ;
56963: LD_ADDR_VAR 0 5
56967: PUSH
56968: LD_VAR 0 1
56972: ST_TO_ADDR
// end ;
56973: LD_VAR 0 5
56977: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56978: LD_INT 0
56980: PPUSH
56981: PPUSH
// result := 0 ;
56982: LD_ADDR_VAR 0 3
56986: PUSH
56987: LD_INT 0
56989: ST_TO_ADDR
// if not array or not value in array then
56990: LD_VAR 0 1
56994: NOT
56995: PUSH
56996: LD_VAR 0 2
57000: PUSH
57001: LD_VAR 0 1
57005: IN
57006: NOT
57007: OR
57008: IFFALSE 57012
// exit ;
57010: GO 57066
// for i = 1 to array do
57012: LD_ADDR_VAR 0 4
57016: PUSH
57017: DOUBLE
57018: LD_INT 1
57020: DEC
57021: ST_TO_ADDR
57022: LD_VAR 0 1
57026: PUSH
57027: FOR_TO
57028: IFFALSE 57064
// if value = array [ i ] then
57030: LD_VAR 0 2
57034: PUSH
57035: LD_VAR 0 1
57039: PUSH
57040: LD_VAR 0 4
57044: ARRAY
57045: EQUAL
57046: IFFALSE 57062
// begin result := i ;
57048: LD_ADDR_VAR 0 3
57052: PUSH
57053: LD_VAR 0 4
57057: ST_TO_ADDR
// exit ;
57058: POP
57059: POP
57060: GO 57066
// end ;
57062: GO 57027
57064: POP
57065: POP
// end ;
57066: LD_VAR 0 3
57070: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57071: LD_INT 0
57073: PPUSH
// vc_chassis := chassis ;
57074: LD_ADDR_OWVAR 37
57078: PUSH
57079: LD_VAR 0 1
57083: ST_TO_ADDR
// vc_engine := engine ;
57084: LD_ADDR_OWVAR 39
57088: PUSH
57089: LD_VAR 0 2
57093: ST_TO_ADDR
// vc_control := control ;
57094: LD_ADDR_OWVAR 38
57098: PUSH
57099: LD_VAR 0 3
57103: ST_TO_ADDR
// vc_weapon := weapon ;
57104: LD_ADDR_OWVAR 40
57108: PUSH
57109: LD_VAR 0 4
57113: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57114: LD_ADDR_OWVAR 41
57118: PUSH
57119: LD_VAR 0 5
57123: ST_TO_ADDR
// end ;
57124: LD_VAR 0 6
57128: RET
// export function WantPlant ( unit ) ; var task ; begin
57129: LD_INT 0
57131: PPUSH
57132: PPUSH
// result := false ;
57133: LD_ADDR_VAR 0 2
57137: PUSH
57138: LD_INT 0
57140: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57141: LD_ADDR_VAR 0 3
57145: PUSH
57146: LD_VAR 0 1
57150: PPUSH
57151: CALL_OW 437
57155: ST_TO_ADDR
// if task then
57156: LD_VAR 0 3
57160: IFFALSE 57188
// if task [ 1 ] [ 1 ] = p then
57162: LD_VAR 0 3
57166: PUSH
57167: LD_INT 1
57169: ARRAY
57170: PUSH
57171: LD_INT 1
57173: ARRAY
57174: PUSH
57175: LD_STRING p
57177: EQUAL
57178: IFFALSE 57188
// result := true ;
57180: LD_ADDR_VAR 0 2
57184: PUSH
57185: LD_INT 1
57187: ST_TO_ADDR
// end ;
57188: LD_VAR 0 2
57192: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57193: LD_INT 0
57195: PPUSH
57196: PPUSH
57197: PPUSH
57198: PPUSH
// if pos < 1 then
57199: LD_VAR 0 2
57203: PUSH
57204: LD_INT 1
57206: LESS
57207: IFFALSE 57211
// exit ;
57209: GO 57514
// if pos = 1 then
57211: LD_VAR 0 2
57215: PUSH
57216: LD_INT 1
57218: EQUAL
57219: IFFALSE 57252
// result := Replace ( arr , pos [ 1 ] , value ) else
57221: LD_ADDR_VAR 0 4
57225: PUSH
57226: LD_VAR 0 1
57230: PPUSH
57231: LD_VAR 0 2
57235: PUSH
57236: LD_INT 1
57238: ARRAY
57239: PPUSH
57240: LD_VAR 0 3
57244: PPUSH
57245: CALL_OW 1
57249: ST_TO_ADDR
57250: GO 57514
// begin tmp := arr ;
57252: LD_ADDR_VAR 0 6
57256: PUSH
57257: LD_VAR 0 1
57261: ST_TO_ADDR
// s_arr := [ tmp ] ;
57262: LD_ADDR_VAR 0 7
57266: PUSH
57267: LD_VAR 0 6
57271: PUSH
57272: EMPTY
57273: LIST
57274: ST_TO_ADDR
// for i = 1 to pos - 1 do
57275: LD_ADDR_VAR 0 5
57279: PUSH
57280: DOUBLE
57281: LD_INT 1
57283: DEC
57284: ST_TO_ADDR
57285: LD_VAR 0 2
57289: PUSH
57290: LD_INT 1
57292: MINUS
57293: PUSH
57294: FOR_TO
57295: IFFALSE 57340
// begin tmp := tmp [ pos [ i ] ] ;
57297: LD_ADDR_VAR 0 6
57301: PUSH
57302: LD_VAR 0 6
57306: PUSH
57307: LD_VAR 0 2
57311: PUSH
57312: LD_VAR 0 5
57316: ARRAY
57317: ARRAY
57318: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57319: LD_ADDR_VAR 0 7
57323: PUSH
57324: LD_VAR 0 7
57328: PUSH
57329: LD_VAR 0 6
57333: PUSH
57334: EMPTY
57335: LIST
57336: ADD
57337: ST_TO_ADDR
// end ;
57338: GO 57294
57340: POP
57341: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57342: LD_ADDR_VAR 0 6
57346: PUSH
57347: LD_VAR 0 6
57351: PPUSH
57352: LD_VAR 0 2
57356: PUSH
57357: LD_VAR 0 2
57361: ARRAY
57362: PPUSH
57363: LD_VAR 0 3
57367: PPUSH
57368: CALL_OW 1
57372: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57373: LD_ADDR_VAR 0 7
57377: PUSH
57378: LD_VAR 0 7
57382: PPUSH
57383: LD_VAR 0 7
57387: PPUSH
57388: LD_VAR 0 6
57392: PPUSH
57393: CALL_OW 1
57397: ST_TO_ADDR
// for i = s_arr downto 2 do
57398: LD_ADDR_VAR 0 5
57402: PUSH
57403: DOUBLE
57404: LD_VAR 0 7
57408: INC
57409: ST_TO_ADDR
57410: LD_INT 2
57412: PUSH
57413: FOR_DOWNTO
57414: IFFALSE 57498
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57416: LD_ADDR_VAR 0 6
57420: PUSH
57421: LD_VAR 0 7
57425: PUSH
57426: LD_VAR 0 5
57430: PUSH
57431: LD_INT 1
57433: MINUS
57434: ARRAY
57435: PPUSH
57436: LD_VAR 0 2
57440: PUSH
57441: LD_VAR 0 5
57445: PUSH
57446: LD_INT 1
57448: MINUS
57449: ARRAY
57450: PPUSH
57451: LD_VAR 0 7
57455: PUSH
57456: LD_VAR 0 5
57460: ARRAY
57461: PPUSH
57462: CALL_OW 1
57466: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57467: LD_ADDR_VAR 0 7
57471: PUSH
57472: LD_VAR 0 7
57476: PPUSH
57477: LD_VAR 0 5
57481: PUSH
57482: LD_INT 1
57484: MINUS
57485: PPUSH
57486: LD_VAR 0 6
57490: PPUSH
57491: CALL_OW 1
57495: ST_TO_ADDR
// end ;
57496: GO 57413
57498: POP
57499: POP
// result := s_arr [ 1 ] ;
57500: LD_ADDR_VAR 0 4
57504: PUSH
57505: LD_VAR 0 7
57509: PUSH
57510: LD_INT 1
57512: ARRAY
57513: ST_TO_ADDR
// end ; end ;
57514: LD_VAR 0 4
57518: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57519: LD_INT 0
57521: PPUSH
57522: PPUSH
// if not list then
57523: LD_VAR 0 1
57527: NOT
57528: IFFALSE 57532
// exit ;
57530: GO 57623
// i := list [ pos1 ] ;
57532: LD_ADDR_VAR 0 5
57536: PUSH
57537: LD_VAR 0 1
57541: PUSH
57542: LD_VAR 0 2
57546: ARRAY
57547: ST_TO_ADDR
// if not i then
57548: LD_VAR 0 5
57552: NOT
57553: IFFALSE 57557
// exit ;
57555: GO 57623
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57557: LD_ADDR_VAR 0 1
57561: PUSH
57562: LD_VAR 0 1
57566: PPUSH
57567: LD_VAR 0 2
57571: PPUSH
57572: LD_VAR 0 1
57576: PUSH
57577: LD_VAR 0 3
57581: ARRAY
57582: PPUSH
57583: CALL_OW 1
57587: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57588: LD_ADDR_VAR 0 1
57592: PUSH
57593: LD_VAR 0 1
57597: PPUSH
57598: LD_VAR 0 3
57602: PPUSH
57603: LD_VAR 0 5
57607: PPUSH
57608: CALL_OW 1
57612: ST_TO_ADDR
// result := list ;
57613: LD_ADDR_VAR 0 4
57617: PUSH
57618: LD_VAR 0 1
57622: ST_TO_ADDR
// end ;
57623: LD_VAR 0 4
57627: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57628: LD_INT 0
57630: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57631: LD_ADDR_VAR 0 5
57635: PUSH
57636: LD_VAR 0 1
57640: PPUSH
57641: CALL_OW 250
57645: PPUSH
57646: LD_VAR 0 1
57650: PPUSH
57651: CALL_OW 251
57655: PPUSH
57656: LD_VAR 0 2
57660: PPUSH
57661: LD_VAR 0 3
57665: PPUSH
57666: LD_VAR 0 4
57670: PPUSH
57671: CALL 57681 0 5
57675: ST_TO_ADDR
// end ;
57676: LD_VAR 0 5
57680: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57681: LD_INT 0
57683: PPUSH
57684: PPUSH
57685: PPUSH
57686: PPUSH
// if not list then
57687: LD_VAR 0 3
57691: NOT
57692: IFFALSE 57696
// exit ;
57694: GO 58084
// result := [ ] ;
57696: LD_ADDR_VAR 0 6
57700: PUSH
57701: EMPTY
57702: ST_TO_ADDR
// for i in list do
57703: LD_ADDR_VAR 0 7
57707: PUSH
57708: LD_VAR 0 3
57712: PUSH
57713: FOR_IN
57714: IFFALSE 57916
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57716: LD_ADDR_VAR 0 9
57720: PUSH
57721: LD_VAR 0 7
57725: PPUSH
57726: LD_VAR 0 1
57730: PPUSH
57731: LD_VAR 0 2
57735: PPUSH
57736: CALL_OW 297
57740: ST_TO_ADDR
// if not result then
57741: LD_VAR 0 6
57745: NOT
57746: IFFALSE 57772
// result := [ [ i , tmp ] ] else
57748: LD_ADDR_VAR 0 6
57752: PUSH
57753: LD_VAR 0 7
57757: PUSH
57758: LD_VAR 0 9
57762: PUSH
57763: EMPTY
57764: LIST
57765: LIST
57766: PUSH
57767: EMPTY
57768: LIST
57769: ST_TO_ADDR
57770: GO 57914
// begin if result [ result ] [ 2 ] < tmp then
57772: LD_VAR 0 6
57776: PUSH
57777: LD_VAR 0 6
57781: ARRAY
57782: PUSH
57783: LD_INT 2
57785: ARRAY
57786: PUSH
57787: LD_VAR 0 9
57791: LESS
57792: IFFALSE 57834
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57794: LD_ADDR_VAR 0 6
57798: PUSH
57799: LD_VAR 0 6
57803: PPUSH
57804: LD_VAR 0 6
57808: PUSH
57809: LD_INT 1
57811: PLUS
57812: PPUSH
57813: LD_VAR 0 7
57817: PUSH
57818: LD_VAR 0 9
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: PPUSH
57827: CALL_OW 2
57831: ST_TO_ADDR
57832: GO 57914
// for j = 1 to result do
57834: LD_ADDR_VAR 0 8
57838: PUSH
57839: DOUBLE
57840: LD_INT 1
57842: DEC
57843: ST_TO_ADDR
57844: LD_VAR 0 6
57848: PUSH
57849: FOR_TO
57850: IFFALSE 57912
// begin if tmp < result [ j ] [ 2 ] then
57852: LD_VAR 0 9
57856: PUSH
57857: LD_VAR 0 6
57861: PUSH
57862: LD_VAR 0 8
57866: ARRAY
57867: PUSH
57868: LD_INT 2
57870: ARRAY
57871: LESS
57872: IFFALSE 57910
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57874: LD_ADDR_VAR 0 6
57878: PUSH
57879: LD_VAR 0 6
57883: PPUSH
57884: LD_VAR 0 8
57888: PPUSH
57889: LD_VAR 0 7
57893: PUSH
57894: LD_VAR 0 9
57898: PUSH
57899: EMPTY
57900: LIST
57901: LIST
57902: PPUSH
57903: CALL_OW 2
57907: ST_TO_ADDR
// break ;
57908: GO 57912
// end ; end ;
57910: GO 57849
57912: POP
57913: POP
// end ; end ;
57914: GO 57713
57916: POP
57917: POP
// if result and not asc then
57918: LD_VAR 0 6
57922: PUSH
57923: LD_VAR 0 4
57927: NOT
57928: AND
57929: IFFALSE 58004
// begin tmp := result ;
57931: LD_ADDR_VAR 0 9
57935: PUSH
57936: LD_VAR 0 6
57940: ST_TO_ADDR
// for i = tmp downto 1 do
57941: LD_ADDR_VAR 0 7
57945: PUSH
57946: DOUBLE
57947: LD_VAR 0 9
57951: INC
57952: ST_TO_ADDR
57953: LD_INT 1
57955: PUSH
57956: FOR_DOWNTO
57957: IFFALSE 58002
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57959: LD_ADDR_VAR 0 6
57963: PUSH
57964: LD_VAR 0 6
57968: PPUSH
57969: LD_VAR 0 9
57973: PUSH
57974: LD_VAR 0 7
57978: MINUS
57979: PUSH
57980: LD_INT 1
57982: PLUS
57983: PPUSH
57984: LD_VAR 0 9
57988: PUSH
57989: LD_VAR 0 7
57993: ARRAY
57994: PPUSH
57995: CALL_OW 1
57999: ST_TO_ADDR
58000: GO 57956
58002: POP
58003: POP
// end ; tmp := [ ] ;
58004: LD_ADDR_VAR 0 9
58008: PUSH
58009: EMPTY
58010: ST_TO_ADDR
// if mode then
58011: LD_VAR 0 5
58015: IFFALSE 58084
// begin for i = 1 to result do
58017: LD_ADDR_VAR 0 7
58021: PUSH
58022: DOUBLE
58023: LD_INT 1
58025: DEC
58026: ST_TO_ADDR
58027: LD_VAR 0 6
58031: PUSH
58032: FOR_TO
58033: IFFALSE 58072
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58035: LD_ADDR_VAR 0 9
58039: PUSH
58040: LD_VAR 0 9
58044: PPUSH
58045: LD_VAR 0 7
58049: PPUSH
58050: LD_VAR 0 6
58054: PUSH
58055: LD_VAR 0 7
58059: ARRAY
58060: PUSH
58061: LD_INT 1
58063: ARRAY
58064: PPUSH
58065: CALL_OW 1
58069: ST_TO_ADDR
58070: GO 58032
58072: POP
58073: POP
// result := tmp ;
58074: LD_ADDR_VAR 0 6
58078: PUSH
58079: LD_VAR 0 9
58083: ST_TO_ADDR
// end ; end ;
58084: LD_VAR 0 6
58088: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58089: LD_INT 0
58091: PPUSH
58092: PPUSH
58093: PPUSH
58094: PPUSH
58095: PPUSH
58096: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58097: LD_ADDR_VAR 0 5
58101: PUSH
58102: LD_INT 0
58104: PUSH
58105: LD_INT 0
58107: PUSH
58108: LD_INT 0
58110: PUSH
58111: EMPTY
58112: PUSH
58113: EMPTY
58114: LIST
58115: LIST
58116: LIST
58117: LIST
58118: ST_TO_ADDR
// if not x or not y then
58119: LD_VAR 0 2
58123: NOT
58124: PUSH
58125: LD_VAR 0 3
58129: NOT
58130: OR
58131: IFFALSE 58135
// exit ;
58133: GO 59787
// if not range then
58135: LD_VAR 0 4
58139: NOT
58140: IFFALSE 58150
// range := 10 ;
58142: LD_ADDR_VAR 0 4
58146: PUSH
58147: LD_INT 10
58149: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58150: LD_ADDR_VAR 0 8
58154: PUSH
58155: LD_INT 81
58157: PUSH
58158: LD_VAR 0 1
58162: PUSH
58163: EMPTY
58164: LIST
58165: LIST
58166: PUSH
58167: LD_INT 92
58169: PUSH
58170: LD_VAR 0 2
58174: PUSH
58175: LD_VAR 0 3
58179: PUSH
58180: LD_VAR 0 4
58184: PUSH
58185: EMPTY
58186: LIST
58187: LIST
58188: LIST
58189: LIST
58190: PUSH
58191: LD_INT 3
58193: PUSH
58194: LD_INT 21
58196: PUSH
58197: LD_INT 3
58199: PUSH
58200: EMPTY
58201: LIST
58202: LIST
58203: PUSH
58204: EMPTY
58205: LIST
58206: LIST
58207: PUSH
58208: EMPTY
58209: LIST
58210: LIST
58211: LIST
58212: PPUSH
58213: CALL_OW 69
58217: ST_TO_ADDR
// if not tmp then
58218: LD_VAR 0 8
58222: NOT
58223: IFFALSE 58227
// exit ;
58225: GO 59787
// for i in tmp do
58227: LD_ADDR_VAR 0 6
58231: PUSH
58232: LD_VAR 0 8
58236: PUSH
58237: FOR_IN
58238: IFFALSE 59762
// begin points := [ 0 , 0 , 0 ] ;
58240: LD_ADDR_VAR 0 9
58244: PUSH
58245: LD_INT 0
58247: PUSH
58248: LD_INT 0
58250: PUSH
58251: LD_INT 0
58253: PUSH
58254: EMPTY
58255: LIST
58256: LIST
58257: LIST
58258: ST_TO_ADDR
// bpoints := 1 ;
58259: LD_ADDR_VAR 0 10
58263: PUSH
58264: LD_INT 1
58266: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58267: LD_VAR 0 6
58271: PPUSH
58272: CALL_OW 247
58276: PUSH
58277: LD_INT 1
58279: DOUBLE
58280: EQUAL
58281: IFTRUE 58285
58283: GO 58863
58285: POP
// begin if GetClass ( i ) = 1 then
58286: LD_VAR 0 6
58290: PPUSH
58291: CALL_OW 257
58295: PUSH
58296: LD_INT 1
58298: EQUAL
58299: IFFALSE 58320
// points := [ 10 , 5 , 3 ] ;
58301: LD_ADDR_VAR 0 9
58305: PUSH
58306: LD_INT 10
58308: PUSH
58309: LD_INT 5
58311: PUSH
58312: LD_INT 3
58314: PUSH
58315: EMPTY
58316: LIST
58317: LIST
58318: LIST
58319: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58320: LD_VAR 0 6
58324: PPUSH
58325: CALL_OW 257
58329: PUSH
58330: LD_INT 2
58332: PUSH
58333: LD_INT 3
58335: PUSH
58336: LD_INT 4
58338: PUSH
58339: EMPTY
58340: LIST
58341: LIST
58342: LIST
58343: IN
58344: IFFALSE 58365
// points := [ 3 , 2 , 1 ] ;
58346: LD_ADDR_VAR 0 9
58350: PUSH
58351: LD_INT 3
58353: PUSH
58354: LD_INT 2
58356: PUSH
58357: LD_INT 1
58359: PUSH
58360: EMPTY
58361: LIST
58362: LIST
58363: LIST
58364: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58365: LD_VAR 0 6
58369: PPUSH
58370: CALL_OW 257
58374: PUSH
58375: LD_INT 5
58377: EQUAL
58378: IFFALSE 58399
// points := [ 130 , 5 , 2 ] ;
58380: LD_ADDR_VAR 0 9
58384: PUSH
58385: LD_INT 130
58387: PUSH
58388: LD_INT 5
58390: PUSH
58391: LD_INT 2
58393: PUSH
58394: EMPTY
58395: LIST
58396: LIST
58397: LIST
58398: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58399: LD_VAR 0 6
58403: PPUSH
58404: CALL_OW 257
58408: PUSH
58409: LD_INT 8
58411: EQUAL
58412: IFFALSE 58433
// points := [ 35 , 35 , 30 ] ;
58414: LD_ADDR_VAR 0 9
58418: PUSH
58419: LD_INT 35
58421: PUSH
58422: LD_INT 35
58424: PUSH
58425: LD_INT 30
58427: PUSH
58428: EMPTY
58429: LIST
58430: LIST
58431: LIST
58432: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58433: LD_VAR 0 6
58437: PPUSH
58438: CALL_OW 257
58442: PUSH
58443: LD_INT 9
58445: EQUAL
58446: IFFALSE 58467
// points := [ 20 , 55 , 40 ] ;
58448: LD_ADDR_VAR 0 9
58452: PUSH
58453: LD_INT 20
58455: PUSH
58456: LD_INT 55
58458: PUSH
58459: LD_INT 40
58461: PUSH
58462: EMPTY
58463: LIST
58464: LIST
58465: LIST
58466: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58467: LD_VAR 0 6
58471: PPUSH
58472: CALL_OW 257
58476: PUSH
58477: LD_INT 12
58479: PUSH
58480: LD_INT 16
58482: PUSH
58483: EMPTY
58484: LIST
58485: LIST
58486: IN
58487: IFFALSE 58508
// points := [ 5 , 3 , 2 ] ;
58489: LD_ADDR_VAR 0 9
58493: PUSH
58494: LD_INT 5
58496: PUSH
58497: LD_INT 3
58499: PUSH
58500: LD_INT 2
58502: PUSH
58503: EMPTY
58504: LIST
58505: LIST
58506: LIST
58507: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58508: LD_VAR 0 6
58512: PPUSH
58513: CALL_OW 257
58517: PUSH
58518: LD_INT 17
58520: EQUAL
58521: IFFALSE 58542
// points := [ 100 , 50 , 75 ] ;
58523: LD_ADDR_VAR 0 9
58527: PUSH
58528: LD_INT 100
58530: PUSH
58531: LD_INT 50
58533: PUSH
58534: LD_INT 75
58536: PUSH
58537: EMPTY
58538: LIST
58539: LIST
58540: LIST
58541: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58542: LD_VAR 0 6
58546: PPUSH
58547: CALL_OW 257
58551: PUSH
58552: LD_INT 15
58554: EQUAL
58555: IFFALSE 58576
// points := [ 10 , 5 , 3 ] ;
58557: LD_ADDR_VAR 0 9
58561: PUSH
58562: LD_INT 10
58564: PUSH
58565: LD_INT 5
58567: PUSH
58568: LD_INT 3
58570: PUSH
58571: EMPTY
58572: LIST
58573: LIST
58574: LIST
58575: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58576: LD_VAR 0 6
58580: PPUSH
58581: CALL_OW 257
58585: PUSH
58586: LD_INT 14
58588: EQUAL
58589: IFFALSE 58610
// points := [ 10 , 0 , 0 ] ;
58591: LD_ADDR_VAR 0 9
58595: PUSH
58596: LD_INT 10
58598: PUSH
58599: LD_INT 0
58601: PUSH
58602: LD_INT 0
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: LIST
58609: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58610: LD_VAR 0 6
58614: PPUSH
58615: CALL_OW 257
58619: PUSH
58620: LD_INT 11
58622: EQUAL
58623: IFFALSE 58644
// points := [ 30 , 10 , 5 ] ;
58625: LD_ADDR_VAR 0 9
58629: PUSH
58630: LD_INT 30
58632: PUSH
58633: LD_INT 10
58635: PUSH
58636: LD_INT 5
58638: PUSH
58639: EMPTY
58640: LIST
58641: LIST
58642: LIST
58643: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58644: LD_VAR 0 1
58648: PPUSH
58649: LD_INT 5
58651: PPUSH
58652: CALL_OW 321
58656: PUSH
58657: LD_INT 2
58659: EQUAL
58660: IFFALSE 58677
// bpoints := bpoints * 1.8 ;
58662: LD_ADDR_VAR 0 10
58666: PUSH
58667: LD_VAR 0 10
58671: PUSH
58672: LD_REAL  1.80000000000000E+0000
58675: MUL
58676: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58677: LD_VAR 0 6
58681: PPUSH
58682: CALL_OW 257
58686: PUSH
58687: LD_INT 1
58689: PUSH
58690: LD_INT 2
58692: PUSH
58693: LD_INT 3
58695: PUSH
58696: LD_INT 4
58698: PUSH
58699: EMPTY
58700: LIST
58701: LIST
58702: LIST
58703: LIST
58704: IN
58705: PUSH
58706: LD_VAR 0 1
58710: PPUSH
58711: LD_INT 51
58713: PPUSH
58714: CALL_OW 321
58718: PUSH
58719: LD_INT 2
58721: EQUAL
58722: AND
58723: IFFALSE 58740
// bpoints := bpoints * 1.2 ;
58725: LD_ADDR_VAR 0 10
58729: PUSH
58730: LD_VAR 0 10
58734: PUSH
58735: LD_REAL  1.20000000000000E+0000
58738: MUL
58739: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58740: LD_VAR 0 6
58744: PPUSH
58745: CALL_OW 257
58749: PUSH
58750: LD_INT 5
58752: PUSH
58753: LD_INT 7
58755: PUSH
58756: LD_INT 9
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: LIST
58763: IN
58764: PUSH
58765: LD_VAR 0 1
58769: PPUSH
58770: LD_INT 52
58772: PPUSH
58773: CALL_OW 321
58777: PUSH
58778: LD_INT 2
58780: EQUAL
58781: AND
58782: IFFALSE 58799
// bpoints := bpoints * 1.5 ;
58784: LD_ADDR_VAR 0 10
58788: PUSH
58789: LD_VAR 0 10
58793: PUSH
58794: LD_REAL  1.50000000000000E+0000
58797: MUL
58798: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58799: LD_VAR 0 1
58803: PPUSH
58804: LD_INT 66
58806: PPUSH
58807: CALL_OW 321
58811: PUSH
58812: LD_INT 2
58814: EQUAL
58815: IFFALSE 58832
// bpoints := bpoints * 1.1 ;
58817: LD_ADDR_VAR 0 10
58821: PUSH
58822: LD_VAR 0 10
58826: PUSH
58827: LD_REAL  1.10000000000000E+0000
58830: MUL
58831: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58832: LD_ADDR_VAR 0 10
58836: PUSH
58837: LD_VAR 0 10
58841: PUSH
58842: LD_VAR 0 6
58846: PPUSH
58847: LD_INT 1
58849: PPUSH
58850: CALL_OW 259
58854: PUSH
58855: LD_REAL  1.15000000000000E+0000
58858: MUL
58859: MUL
58860: ST_TO_ADDR
// end ; unit_vehicle :
58861: GO 59691
58863: LD_INT 2
58865: DOUBLE
58866: EQUAL
58867: IFTRUE 58871
58869: GO 59679
58871: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58872: LD_VAR 0 6
58876: PPUSH
58877: CALL_OW 264
58881: PUSH
58882: LD_INT 2
58884: PUSH
58885: LD_INT 42
58887: PUSH
58888: LD_INT 24
58890: PUSH
58891: EMPTY
58892: LIST
58893: LIST
58894: LIST
58895: IN
58896: IFFALSE 58917
// points := [ 25 , 5 , 3 ] ;
58898: LD_ADDR_VAR 0 9
58902: PUSH
58903: LD_INT 25
58905: PUSH
58906: LD_INT 5
58908: PUSH
58909: LD_INT 3
58911: PUSH
58912: EMPTY
58913: LIST
58914: LIST
58915: LIST
58916: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58917: LD_VAR 0 6
58921: PPUSH
58922: CALL_OW 264
58926: PUSH
58927: LD_INT 4
58929: PUSH
58930: LD_INT 43
58932: PUSH
58933: LD_INT 25
58935: PUSH
58936: EMPTY
58937: LIST
58938: LIST
58939: LIST
58940: IN
58941: IFFALSE 58962
// points := [ 40 , 15 , 5 ] ;
58943: LD_ADDR_VAR 0 9
58947: PUSH
58948: LD_INT 40
58950: PUSH
58951: LD_INT 15
58953: PUSH
58954: LD_INT 5
58956: PUSH
58957: EMPTY
58958: LIST
58959: LIST
58960: LIST
58961: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58962: LD_VAR 0 6
58966: PPUSH
58967: CALL_OW 264
58971: PUSH
58972: LD_INT 3
58974: PUSH
58975: LD_INT 23
58977: PUSH
58978: EMPTY
58979: LIST
58980: LIST
58981: IN
58982: IFFALSE 59003
// points := [ 7 , 25 , 8 ] ;
58984: LD_ADDR_VAR 0 9
58988: PUSH
58989: LD_INT 7
58991: PUSH
58992: LD_INT 25
58994: PUSH
58995: LD_INT 8
58997: PUSH
58998: EMPTY
58999: LIST
59000: LIST
59001: LIST
59002: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59003: LD_VAR 0 6
59007: PPUSH
59008: CALL_OW 264
59012: PUSH
59013: LD_INT 5
59015: PUSH
59016: LD_INT 27
59018: PUSH
59019: LD_INT 44
59021: PUSH
59022: EMPTY
59023: LIST
59024: LIST
59025: LIST
59026: IN
59027: IFFALSE 59048
// points := [ 14 , 50 , 16 ] ;
59029: LD_ADDR_VAR 0 9
59033: PUSH
59034: LD_INT 14
59036: PUSH
59037: LD_INT 50
59039: PUSH
59040: LD_INT 16
59042: PUSH
59043: EMPTY
59044: LIST
59045: LIST
59046: LIST
59047: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59048: LD_VAR 0 6
59052: PPUSH
59053: CALL_OW 264
59057: PUSH
59058: LD_INT 6
59060: PUSH
59061: LD_INT 46
59063: PUSH
59064: EMPTY
59065: LIST
59066: LIST
59067: IN
59068: IFFALSE 59089
// points := [ 32 , 120 , 70 ] ;
59070: LD_ADDR_VAR 0 9
59074: PUSH
59075: LD_INT 32
59077: PUSH
59078: LD_INT 120
59080: PUSH
59081: LD_INT 70
59083: PUSH
59084: EMPTY
59085: LIST
59086: LIST
59087: LIST
59088: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
59089: LD_VAR 0 6
59093: PPUSH
59094: CALL_OW 264
59098: PUSH
59099: LD_INT 7
59101: PUSH
59102: LD_INT 28
59104: PUSH
59105: LD_INT 45
59107: PUSH
59108: LD_EXP 79
59112: PUSH
59113: EMPTY
59114: LIST
59115: LIST
59116: LIST
59117: LIST
59118: IN
59119: IFFALSE 59140
// points := [ 35 , 20 , 45 ] ;
59121: LD_ADDR_VAR 0 9
59125: PUSH
59126: LD_INT 35
59128: PUSH
59129: LD_INT 20
59131: PUSH
59132: LD_INT 45
59134: PUSH
59135: EMPTY
59136: LIST
59137: LIST
59138: LIST
59139: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59140: LD_VAR 0 6
59144: PPUSH
59145: CALL_OW 264
59149: PUSH
59150: LD_INT 47
59152: PUSH
59153: EMPTY
59154: LIST
59155: IN
59156: IFFALSE 59177
// points := [ 67 , 45 , 75 ] ;
59158: LD_ADDR_VAR 0 9
59162: PUSH
59163: LD_INT 67
59165: PUSH
59166: LD_INT 45
59168: PUSH
59169: LD_INT 75
59171: PUSH
59172: EMPTY
59173: LIST
59174: LIST
59175: LIST
59176: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59177: LD_VAR 0 6
59181: PPUSH
59182: CALL_OW 264
59186: PUSH
59187: LD_INT 26
59189: PUSH
59190: EMPTY
59191: LIST
59192: IN
59193: IFFALSE 59214
// points := [ 120 , 30 , 80 ] ;
59195: LD_ADDR_VAR 0 9
59199: PUSH
59200: LD_INT 120
59202: PUSH
59203: LD_INT 30
59205: PUSH
59206: LD_INT 80
59208: PUSH
59209: EMPTY
59210: LIST
59211: LIST
59212: LIST
59213: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59214: LD_VAR 0 6
59218: PPUSH
59219: CALL_OW 264
59223: PUSH
59224: LD_INT 22
59226: PUSH
59227: EMPTY
59228: LIST
59229: IN
59230: IFFALSE 59251
// points := [ 40 , 1 , 1 ] ;
59232: LD_ADDR_VAR 0 9
59236: PUSH
59237: LD_INT 40
59239: PUSH
59240: LD_INT 1
59242: PUSH
59243: LD_INT 1
59245: PUSH
59246: EMPTY
59247: LIST
59248: LIST
59249: LIST
59250: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59251: LD_VAR 0 6
59255: PPUSH
59256: CALL_OW 264
59260: PUSH
59261: LD_INT 29
59263: PUSH
59264: EMPTY
59265: LIST
59266: IN
59267: IFFALSE 59288
// points := [ 70 , 200 , 400 ] ;
59269: LD_ADDR_VAR 0 9
59273: PUSH
59274: LD_INT 70
59276: PUSH
59277: LD_INT 200
59279: PUSH
59280: LD_INT 400
59282: PUSH
59283: EMPTY
59284: LIST
59285: LIST
59286: LIST
59287: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59288: LD_VAR 0 6
59292: PPUSH
59293: CALL_OW 264
59297: PUSH
59298: LD_INT 14
59300: PUSH
59301: LD_INT 53
59303: PUSH
59304: EMPTY
59305: LIST
59306: LIST
59307: IN
59308: IFFALSE 59329
// points := [ 40 , 10 , 20 ] ;
59310: LD_ADDR_VAR 0 9
59314: PUSH
59315: LD_INT 40
59317: PUSH
59318: LD_INT 10
59320: PUSH
59321: LD_INT 20
59323: PUSH
59324: EMPTY
59325: LIST
59326: LIST
59327: LIST
59328: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59329: LD_VAR 0 6
59333: PPUSH
59334: CALL_OW 264
59338: PUSH
59339: LD_INT 9
59341: PUSH
59342: EMPTY
59343: LIST
59344: IN
59345: IFFALSE 59366
// points := [ 5 , 70 , 20 ] ;
59347: LD_ADDR_VAR 0 9
59351: PUSH
59352: LD_INT 5
59354: PUSH
59355: LD_INT 70
59357: PUSH
59358: LD_INT 20
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: LIST
59365: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59366: LD_VAR 0 6
59370: PPUSH
59371: CALL_OW 264
59375: PUSH
59376: LD_INT 10
59378: PUSH
59379: EMPTY
59380: LIST
59381: IN
59382: IFFALSE 59403
// points := [ 35 , 110 , 70 ] ;
59384: LD_ADDR_VAR 0 9
59388: PUSH
59389: LD_INT 35
59391: PUSH
59392: LD_INT 110
59394: PUSH
59395: LD_INT 70
59397: PUSH
59398: EMPTY
59399: LIST
59400: LIST
59401: LIST
59402: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59403: LD_VAR 0 6
59407: PPUSH
59408: CALL_OW 265
59412: PUSH
59413: LD_INT 25
59415: EQUAL
59416: IFFALSE 59437
// points := [ 80 , 65 , 100 ] ;
59418: LD_ADDR_VAR 0 9
59422: PUSH
59423: LD_INT 80
59425: PUSH
59426: LD_INT 65
59428: PUSH
59429: LD_INT 100
59431: PUSH
59432: EMPTY
59433: LIST
59434: LIST
59435: LIST
59436: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59437: LD_VAR 0 6
59441: PPUSH
59442: CALL_OW 263
59446: PUSH
59447: LD_INT 1
59449: EQUAL
59450: IFFALSE 59485
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59452: LD_ADDR_VAR 0 10
59456: PUSH
59457: LD_VAR 0 10
59461: PUSH
59462: LD_VAR 0 6
59466: PPUSH
59467: CALL_OW 311
59471: PPUSH
59472: LD_INT 3
59474: PPUSH
59475: CALL_OW 259
59479: PUSH
59480: LD_INT 4
59482: MUL
59483: MUL
59484: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59485: LD_VAR 0 6
59489: PPUSH
59490: CALL_OW 263
59494: PUSH
59495: LD_INT 2
59497: EQUAL
59498: IFFALSE 59549
// begin j := IsControledBy ( i ) ;
59500: LD_ADDR_VAR 0 7
59504: PUSH
59505: LD_VAR 0 6
59509: PPUSH
59510: CALL_OW 312
59514: ST_TO_ADDR
// if j then
59515: LD_VAR 0 7
59519: IFFALSE 59549
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59521: LD_ADDR_VAR 0 10
59525: PUSH
59526: LD_VAR 0 10
59530: PUSH
59531: LD_VAR 0 7
59535: PPUSH
59536: LD_INT 3
59538: PPUSH
59539: CALL_OW 259
59543: PUSH
59544: LD_INT 3
59546: MUL
59547: MUL
59548: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59549: LD_VAR 0 6
59553: PPUSH
59554: CALL_OW 264
59558: PUSH
59559: LD_INT 5
59561: PUSH
59562: LD_INT 6
59564: PUSH
59565: LD_INT 46
59567: PUSH
59568: LD_INT 44
59570: PUSH
59571: LD_INT 47
59573: PUSH
59574: LD_INT 45
59576: PUSH
59577: LD_INT 28
59579: PUSH
59580: LD_INT 7
59582: PUSH
59583: LD_INT 27
59585: PUSH
59586: LD_INT 29
59588: PUSH
59589: EMPTY
59590: LIST
59591: LIST
59592: LIST
59593: LIST
59594: LIST
59595: LIST
59596: LIST
59597: LIST
59598: LIST
59599: LIST
59600: IN
59601: PUSH
59602: LD_VAR 0 1
59606: PPUSH
59607: LD_INT 52
59609: PPUSH
59610: CALL_OW 321
59614: PUSH
59615: LD_INT 2
59617: EQUAL
59618: AND
59619: IFFALSE 59636
// bpoints := bpoints * 1.2 ;
59621: LD_ADDR_VAR 0 10
59625: PUSH
59626: LD_VAR 0 10
59630: PUSH
59631: LD_REAL  1.20000000000000E+0000
59634: MUL
59635: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59636: LD_VAR 0 6
59640: PPUSH
59641: CALL_OW 264
59645: PUSH
59646: LD_INT 6
59648: PUSH
59649: LD_INT 46
59651: PUSH
59652: LD_INT 47
59654: PUSH
59655: EMPTY
59656: LIST
59657: LIST
59658: LIST
59659: IN
59660: IFFALSE 59677
// bpoints := bpoints * 1.2 ;
59662: LD_ADDR_VAR 0 10
59666: PUSH
59667: LD_VAR 0 10
59671: PUSH
59672: LD_REAL  1.20000000000000E+0000
59675: MUL
59676: ST_TO_ADDR
// end ; unit_building :
59677: GO 59691
59679: LD_INT 3
59681: DOUBLE
59682: EQUAL
59683: IFTRUE 59687
59685: GO 59690
59687: POP
// ; end ;
59688: GO 59691
59690: POP
// for j = 1 to 3 do
59691: LD_ADDR_VAR 0 7
59695: PUSH
59696: DOUBLE
59697: LD_INT 1
59699: DEC
59700: ST_TO_ADDR
59701: LD_INT 3
59703: PUSH
59704: FOR_TO
59705: IFFALSE 59758
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59707: LD_ADDR_VAR 0 5
59711: PUSH
59712: LD_VAR 0 5
59716: PPUSH
59717: LD_VAR 0 7
59721: PPUSH
59722: LD_VAR 0 5
59726: PUSH
59727: LD_VAR 0 7
59731: ARRAY
59732: PUSH
59733: LD_VAR 0 9
59737: PUSH
59738: LD_VAR 0 7
59742: ARRAY
59743: PUSH
59744: LD_VAR 0 10
59748: MUL
59749: PLUS
59750: PPUSH
59751: CALL_OW 1
59755: ST_TO_ADDR
59756: GO 59704
59758: POP
59759: POP
// end ;
59760: GO 58237
59762: POP
59763: POP
// result := Replace ( result , 4 , tmp ) ;
59764: LD_ADDR_VAR 0 5
59768: PUSH
59769: LD_VAR 0 5
59773: PPUSH
59774: LD_INT 4
59776: PPUSH
59777: LD_VAR 0 8
59781: PPUSH
59782: CALL_OW 1
59786: ST_TO_ADDR
// end ;
59787: LD_VAR 0 5
59791: RET
// export function DangerAtRange ( unit , range ) ; begin
59792: LD_INT 0
59794: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59795: LD_ADDR_VAR 0 3
59799: PUSH
59800: LD_VAR 0 1
59804: PPUSH
59805: CALL_OW 255
59809: PPUSH
59810: LD_VAR 0 1
59814: PPUSH
59815: CALL_OW 250
59819: PPUSH
59820: LD_VAR 0 1
59824: PPUSH
59825: CALL_OW 251
59829: PPUSH
59830: LD_VAR 0 2
59834: PPUSH
59835: CALL 58089 0 4
59839: ST_TO_ADDR
// end ;
59840: LD_VAR 0 3
59844: RET
// export function DangerInArea ( side , area ) ; begin
59845: LD_INT 0
59847: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59848: LD_ADDR_VAR 0 3
59852: PUSH
59853: LD_VAR 0 2
59857: PPUSH
59858: LD_INT 81
59860: PUSH
59861: LD_VAR 0 1
59865: PUSH
59866: EMPTY
59867: LIST
59868: LIST
59869: PPUSH
59870: CALL_OW 70
59874: ST_TO_ADDR
// end ;
59875: LD_VAR 0 3
59879: RET
// export function IsExtension ( b ) ; begin
59880: LD_INT 0
59882: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59883: LD_ADDR_VAR 0 2
59887: PUSH
59888: LD_VAR 0 1
59892: PUSH
59893: LD_INT 23
59895: PUSH
59896: LD_INT 20
59898: PUSH
59899: LD_INT 22
59901: PUSH
59902: LD_INT 17
59904: PUSH
59905: LD_INT 24
59907: PUSH
59908: LD_INT 21
59910: PUSH
59911: LD_INT 19
59913: PUSH
59914: LD_INT 16
59916: PUSH
59917: LD_INT 25
59919: PUSH
59920: LD_INT 18
59922: PUSH
59923: EMPTY
59924: LIST
59925: LIST
59926: LIST
59927: LIST
59928: LIST
59929: LIST
59930: LIST
59931: LIST
59932: LIST
59933: LIST
59934: IN
59935: ST_TO_ADDR
// end ;
59936: LD_VAR 0 2
59940: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59941: LD_INT 0
59943: PPUSH
59944: PPUSH
59945: PPUSH
// result := [ ] ;
59946: LD_ADDR_VAR 0 4
59950: PUSH
59951: EMPTY
59952: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59953: LD_ADDR_VAR 0 5
59957: PUSH
59958: LD_VAR 0 2
59962: PPUSH
59963: LD_INT 21
59965: PUSH
59966: LD_INT 3
59968: PUSH
59969: EMPTY
59970: LIST
59971: LIST
59972: PPUSH
59973: CALL_OW 70
59977: ST_TO_ADDR
// if not tmp then
59978: LD_VAR 0 5
59982: NOT
59983: IFFALSE 59987
// exit ;
59985: GO 60051
// if checkLink then
59987: LD_VAR 0 3
59991: IFFALSE 60041
// begin for i in tmp do
59993: LD_ADDR_VAR 0 6
59997: PUSH
59998: LD_VAR 0 5
60002: PUSH
60003: FOR_IN
60004: IFFALSE 60039
// if GetBase ( i ) <> base then
60006: LD_VAR 0 6
60010: PPUSH
60011: CALL_OW 274
60015: PUSH
60016: LD_VAR 0 1
60020: NONEQUAL
60021: IFFALSE 60037
// ComLinkToBase ( base , i ) ;
60023: LD_VAR 0 1
60027: PPUSH
60028: LD_VAR 0 6
60032: PPUSH
60033: CALL_OW 169
60037: GO 60003
60039: POP
60040: POP
// end ; result := tmp ;
60041: LD_ADDR_VAR 0 4
60045: PUSH
60046: LD_VAR 0 5
60050: ST_TO_ADDR
// end ;
60051: LD_VAR 0 4
60055: RET
// export function ComComplete ( units , b ) ; var i ; begin
60056: LD_INT 0
60058: PPUSH
60059: PPUSH
// if not units then
60060: LD_VAR 0 1
60064: NOT
60065: IFFALSE 60069
// exit ;
60067: GO 60159
// for i in units do
60069: LD_ADDR_VAR 0 4
60073: PUSH
60074: LD_VAR 0 1
60078: PUSH
60079: FOR_IN
60080: IFFALSE 60157
// if BuildingStatus ( b ) = bs_build then
60082: LD_VAR 0 2
60086: PPUSH
60087: CALL_OW 461
60091: PUSH
60092: LD_INT 1
60094: EQUAL
60095: IFFALSE 60155
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60097: LD_VAR 0 4
60101: PPUSH
60102: LD_STRING h
60104: PUSH
60105: LD_VAR 0 2
60109: PPUSH
60110: CALL_OW 250
60114: PUSH
60115: LD_VAR 0 2
60119: PPUSH
60120: CALL_OW 251
60124: PUSH
60125: LD_VAR 0 2
60129: PUSH
60130: LD_INT 0
60132: PUSH
60133: LD_INT 0
60135: PUSH
60136: LD_INT 0
60138: PUSH
60139: EMPTY
60140: LIST
60141: LIST
60142: LIST
60143: LIST
60144: LIST
60145: LIST
60146: LIST
60147: PUSH
60148: EMPTY
60149: LIST
60150: PPUSH
60151: CALL_OW 446
60155: GO 60079
60157: POP
60158: POP
// end ;
60159: LD_VAR 0 3
60163: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60164: LD_INT 0
60166: PPUSH
60167: PPUSH
60168: PPUSH
60169: PPUSH
60170: PPUSH
60171: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
60172: LD_VAR 0 1
60176: NOT
60177: PUSH
60178: LD_VAR 0 1
60182: PPUSH
60183: CALL_OW 263
60187: PUSH
60188: LD_INT 2
60190: NONEQUAL
60191: OR
60192: IFFALSE 60196
// exit ;
60194: GO 60512
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60196: LD_ADDR_VAR 0 6
60200: PUSH
60201: LD_INT 22
60203: PUSH
60204: LD_VAR 0 1
60208: PPUSH
60209: CALL_OW 255
60213: PUSH
60214: EMPTY
60215: LIST
60216: LIST
60217: PUSH
60218: LD_INT 2
60220: PUSH
60221: LD_INT 30
60223: PUSH
60224: LD_INT 36
60226: PUSH
60227: EMPTY
60228: LIST
60229: LIST
60230: PUSH
60231: LD_INT 34
60233: PUSH
60234: LD_INT 31
60236: PUSH
60237: EMPTY
60238: LIST
60239: LIST
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: LIST
60245: PUSH
60246: EMPTY
60247: LIST
60248: LIST
60249: PPUSH
60250: CALL_OW 69
60254: ST_TO_ADDR
// if not tmp then
60255: LD_VAR 0 6
60259: NOT
60260: IFFALSE 60264
// exit ;
60262: GO 60512
// result := [ ] ;
60264: LD_ADDR_VAR 0 2
60268: PUSH
60269: EMPTY
60270: ST_TO_ADDR
// for i in tmp do
60271: LD_ADDR_VAR 0 3
60275: PUSH
60276: LD_VAR 0 6
60280: PUSH
60281: FOR_IN
60282: IFFALSE 60353
// begin t := UnitsInside ( i ) ;
60284: LD_ADDR_VAR 0 4
60288: PUSH
60289: LD_VAR 0 3
60293: PPUSH
60294: CALL_OW 313
60298: ST_TO_ADDR
// if t then
60299: LD_VAR 0 4
60303: IFFALSE 60351
// for j in t do
60305: LD_ADDR_VAR 0 7
60309: PUSH
60310: LD_VAR 0 4
60314: PUSH
60315: FOR_IN
60316: IFFALSE 60349
// result := Replace ( result , result + 1 , j ) ;
60318: LD_ADDR_VAR 0 2
60322: PUSH
60323: LD_VAR 0 2
60327: PPUSH
60328: LD_VAR 0 2
60332: PUSH
60333: LD_INT 1
60335: PLUS
60336: PPUSH
60337: LD_VAR 0 7
60341: PPUSH
60342: CALL_OW 1
60346: ST_TO_ADDR
60347: GO 60315
60349: POP
60350: POP
// end ;
60351: GO 60281
60353: POP
60354: POP
// if not result then
60355: LD_VAR 0 2
60359: NOT
60360: IFFALSE 60364
// exit ;
60362: GO 60512
// mech := result [ 1 ] ;
60364: LD_ADDR_VAR 0 5
60368: PUSH
60369: LD_VAR 0 2
60373: PUSH
60374: LD_INT 1
60376: ARRAY
60377: ST_TO_ADDR
// if result > 1 then
60378: LD_VAR 0 2
60382: PUSH
60383: LD_INT 1
60385: GREATER
60386: IFFALSE 60498
// begin for i = 2 to result do
60388: LD_ADDR_VAR 0 3
60392: PUSH
60393: DOUBLE
60394: LD_INT 2
60396: DEC
60397: ST_TO_ADDR
60398: LD_VAR 0 2
60402: PUSH
60403: FOR_TO
60404: IFFALSE 60496
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60406: LD_ADDR_VAR 0 4
60410: PUSH
60411: LD_VAR 0 2
60415: PUSH
60416: LD_VAR 0 3
60420: ARRAY
60421: PPUSH
60422: LD_INT 3
60424: PPUSH
60425: CALL_OW 259
60429: PUSH
60430: LD_VAR 0 2
60434: PUSH
60435: LD_VAR 0 3
60439: ARRAY
60440: PPUSH
60441: CALL_OW 432
60445: MINUS
60446: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60447: LD_VAR 0 4
60451: PUSH
60452: LD_VAR 0 5
60456: PPUSH
60457: LD_INT 3
60459: PPUSH
60460: CALL_OW 259
60464: PUSH
60465: LD_VAR 0 5
60469: PPUSH
60470: CALL_OW 432
60474: MINUS
60475: GREATEREQUAL
60476: IFFALSE 60494
// mech := result [ i ] ;
60478: LD_ADDR_VAR 0 5
60482: PUSH
60483: LD_VAR 0 2
60487: PUSH
60488: LD_VAR 0 3
60492: ARRAY
60493: ST_TO_ADDR
// end ;
60494: GO 60403
60496: POP
60497: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60498: LD_VAR 0 1
60502: PPUSH
60503: LD_VAR 0 5
60507: PPUSH
60508: CALL_OW 135
// end ;
60512: LD_VAR 0 2
60516: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60517: LD_INT 0
60519: PPUSH
60520: PPUSH
60521: PPUSH
60522: PPUSH
60523: PPUSH
60524: PPUSH
60525: PPUSH
60526: PPUSH
60527: PPUSH
60528: PPUSH
60529: PPUSH
60530: PPUSH
60531: PPUSH
// result := [ ] ;
60532: LD_ADDR_VAR 0 7
60536: PUSH
60537: EMPTY
60538: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60539: LD_VAR 0 1
60543: PPUSH
60544: CALL_OW 266
60548: PUSH
60549: LD_INT 0
60551: PUSH
60552: LD_INT 1
60554: PUSH
60555: EMPTY
60556: LIST
60557: LIST
60558: IN
60559: NOT
60560: IFFALSE 60564
// exit ;
60562: GO 62198
// if name then
60564: LD_VAR 0 3
60568: IFFALSE 60584
// SetBName ( base_dep , name ) ;
60570: LD_VAR 0 1
60574: PPUSH
60575: LD_VAR 0 3
60579: PPUSH
60580: CALL_OW 500
// base := GetBase ( base_dep ) ;
60584: LD_ADDR_VAR 0 15
60588: PUSH
60589: LD_VAR 0 1
60593: PPUSH
60594: CALL_OW 274
60598: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60599: LD_ADDR_VAR 0 16
60603: PUSH
60604: LD_VAR 0 1
60608: PPUSH
60609: CALL_OW 255
60613: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60614: LD_ADDR_VAR 0 17
60618: PUSH
60619: LD_VAR 0 1
60623: PPUSH
60624: CALL_OW 248
60628: ST_TO_ADDR
// if sources then
60629: LD_VAR 0 5
60633: IFFALSE 60680
// for i = 1 to 3 do
60635: LD_ADDR_VAR 0 8
60639: PUSH
60640: DOUBLE
60641: LD_INT 1
60643: DEC
60644: ST_TO_ADDR
60645: LD_INT 3
60647: PUSH
60648: FOR_TO
60649: IFFALSE 60678
// AddResourceType ( base , i , sources [ i ] ) ;
60651: LD_VAR 0 15
60655: PPUSH
60656: LD_VAR 0 8
60660: PPUSH
60661: LD_VAR 0 5
60665: PUSH
60666: LD_VAR 0 8
60670: ARRAY
60671: PPUSH
60672: CALL_OW 276
60676: GO 60648
60678: POP
60679: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60680: LD_ADDR_VAR 0 18
60684: PUSH
60685: LD_VAR 0 15
60689: PPUSH
60690: LD_VAR 0 2
60694: PPUSH
60695: LD_INT 1
60697: PPUSH
60698: CALL 59941 0 3
60702: ST_TO_ADDR
// InitHc ;
60703: CALL_OW 19
// InitUc ;
60707: CALL_OW 18
// uc_side := side ;
60711: LD_ADDR_OWVAR 20
60715: PUSH
60716: LD_VAR 0 16
60720: ST_TO_ADDR
// uc_nation := nation ;
60721: LD_ADDR_OWVAR 21
60725: PUSH
60726: LD_VAR 0 17
60730: ST_TO_ADDR
// if buildings then
60731: LD_VAR 0 18
60735: IFFALSE 62057
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60737: LD_ADDR_VAR 0 19
60741: PUSH
60742: LD_VAR 0 18
60746: PPUSH
60747: LD_INT 2
60749: PUSH
60750: LD_INT 30
60752: PUSH
60753: LD_INT 29
60755: PUSH
60756: EMPTY
60757: LIST
60758: LIST
60759: PUSH
60760: LD_INT 30
60762: PUSH
60763: LD_INT 30
60765: PUSH
60766: EMPTY
60767: LIST
60768: LIST
60769: PUSH
60770: EMPTY
60771: LIST
60772: LIST
60773: LIST
60774: PPUSH
60775: CALL_OW 72
60779: ST_TO_ADDR
// if tmp then
60780: LD_VAR 0 19
60784: IFFALSE 60832
// for i in tmp do
60786: LD_ADDR_VAR 0 8
60790: PUSH
60791: LD_VAR 0 19
60795: PUSH
60796: FOR_IN
60797: IFFALSE 60830
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60799: LD_VAR 0 8
60803: PPUSH
60804: CALL_OW 250
60808: PPUSH
60809: LD_VAR 0 8
60813: PPUSH
60814: CALL_OW 251
60818: PPUSH
60819: LD_VAR 0 16
60823: PPUSH
60824: CALL_OW 441
60828: GO 60796
60830: POP
60831: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60832: LD_VAR 0 18
60836: PPUSH
60837: LD_INT 2
60839: PUSH
60840: LD_INT 30
60842: PUSH
60843: LD_INT 32
60845: PUSH
60846: EMPTY
60847: LIST
60848: LIST
60849: PUSH
60850: LD_INT 30
60852: PUSH
60853: LD_INT 33
60855: PUSH
60856: EMPTY
60857: LIST
60858: LIST
60859: PUSH
60860: EMPTY
60861: LIST
60862: LIST
60863: LIST
60864: PPUSH
60865: CALL_OW 72
60869: IFFALSE 60957
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60871: LD_ADDR_VAR 0 8
60875: PUSH
60876: LD_VAR 0 18
60880: PPUSH
60881: LD_INT 2
60883: PUSH
60884: LD_INT 30
60886: PUSH
60887: LD_INT 32
60889: PUSH
60890: EMPTY
60891: LIST
60892: LIST
60893: PUSH
60894: LD_INT 30
60896: PUSH
60897: LD_INT 33
60899: PUSH
60900: EMPTY
60901: LIST
60902: LIST
60903: PUSH
60904: EMPTY
60905: LIST
60906: LIST
60907: LIST
60908: PPUSH
60909: CALL_OW 72
60913: PUSH
60914: FOR_IN
60915: IFFALSE 60955
// begin if not GetBWeapon ( i ) then
60917: LD_VAR 0 8
60921: PPUSH
60922: CALL_OW 269
60926: NOT
60927: IFFALSE 60953
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60929: LD_VAR 0 8
60933: PPUSH
60934: LD_VAR 0 8
60938: PPUSH
60939: LD_VAR 0 2
60943: PPUSH
60944: CALL 62203 0 2
60948: PPUSH
60949: CALL_OW 431
// end ;
60953: GO 60914
60955: POP
60956: POP
// end ; for i = 1 to personel do
60957: LD_ADDR_VAR 0 8
60961: PUSH
60962: DOUBLE
60963: LD_INT 1
60965: DEC
60966: ST_TO_ADDR
60967: LD_VAR 0 6
60971: PUSH
60972: FOR_TO
60973: IFFALSE 62037
// begin if i > 4 then
60975: LD_VAR 0 8
60979: PUSH
60980: LD_INT 4
60982: GREATER
60983: IFFALSE 60987
// break ;
60985: GO 62037
// case i of 1 :
60987: LD_VAR 0 8
60991: PUSH
60992: LD_INT 1
60994: DOUBLE
60995: EQUAL
60996: IFTRUE 61000
60998: GO 61080
61000: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61001: LD_ADDR_VAR 0 12
61005: PUSH
61006: LD_VAR 0 18
61010: PPUSH
61011: LD_INT 22
61013: PUSH
61014: LD_VAR 0 16
61018: PUSH
61019: EMPTY
61020: LIST
61021: LIST
61022: PUSH
61023: LD_INT 58
61025: PUSH
61026: EMPTY
61027: LIST
61028: PUSH
61029: LD_INT 2
61031: PUSH
61032: LD_INT 30
61034: PUSH
61035: LD_INT 32
61037: PUSH
61038: EMPTY
61039: LIST
61040: LIST
61041: PUSH
61042: LD_INT 30
61044: PUSH
61045: LD_INT 4
61047: PUSH
61048: EMPTY
61049: LIST
61050: LIST
61051: PUSH
61052: LD_INT 30
61054: PUSH
61055: LD_INT 5
61057: PUSH
61058: EMPTY
61059: LIST
61060: LIST
61061: PUSH
61062: EMPTY
61063: LIST
61064: LIST
61065: LIST
61066: LIST
61067: PUSH
61068: EMPTY
61069: LIST
61070: LIST
61071: LIST
61072: PPUSH
61073: CALL_OW 72
61077: ST_TO_ADDR
61078: GO 61302
61080: LD_INT 2
61082: DOUBLE
61083: EQUAL
61084: IFTRUE 61088
61086: GO 61150
61088: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61089: LD_ADDR_VAR 0 12
61093: PUSH
61094: LD_VAR 0 18
61098: PPUSH
61099: LD_INT 22
61101: PUSH
61102: LD_VAR 0 16
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: PUSH
61111: LD_INT 2
61113: PUSH
61114: LD_INT 30
61116: PUSH
61117: LD_INT 0
61119: PUSH
61120: EMPTY
61121: LIST
61122: LIST
61123: PUSH
61124: LD_INT 30
61126: PUSH
61127: LD_INT 1
61129: PUSH
61130: EMPTY
61131: LIST
61132: LIST
61133: PUSH
61134: EMPTY
61135: LIST
61136: LIST
61137: LIST
61138: PUSH
61139: EMPTY
61140: LIST
61141: LIST
61142: PPUSH
61143: CALL_OW 72
61147: ST_TO_ADDR
61148: GO 61302
61150: LD_INT 3
61152: DOUBLE
61153: EQUAL
61154: IFTRUE 61158
61156: GO 61220
61158: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61159: LD_ADDR_VAR 0 12
61163: PUSH
61164: LD_VAR 0 18
61168: PPUSH
61169: LD_INT 22
61171: PUSH
61172: LD_VAR 0 16
61176: PUSH
61177: EMPTY
61178: LIST
61179: LIST
61180: PUSH
61181: LD_INT 2
61183: PUSH
61184: LD_INT 30
61186: PUSH
61187: LD_INT 2
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: PUSH
61194: LD_INT 30
61196: PUSH
61197: LD_INT 3
61199: PUSH
61200: EMPTY
61201: LIST
61202: LIST
61203: PUSH
61204: EMPTY
61205: LIST
61206: LIST
61207: LIST
61208: PUSH
61209: EMPTY
61210: LIST
61211: LIST
61212: PPUSH
61213: CALL_OW 72
61217: ST_TO_ADDR
61218: GO 61302
61220: LD_INT 4
61222: DOUBLE
61223: EQUAL
61224: IFTRUE 61228
61226: GO 61301
61228: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61229: LD_ADDR_VAR 0 12
61233: PUSH
61234: LD_VAR 0 18
61238: PPUSH
61239: LD_INT 22
61241: PUSH
61242: LD_VAR 0 16
61246: PUSH
61247: EMPTY
61248: LIST
61249: LIST
61250: PUSH
61251: LD_INT 2
61253: PUSH
61254: LD_INT 30
61256: PUSH
61257: LD_INT 6
61259: PUSH
61260: EMPTY
61261: LIST
61262: LIST
61263: PUSH
61264: LD_INT 30
61266: PUSH
61267: LD_INT 7
61269: PUSH
61270: EMPTY
61271: LIST
61272: LIST
61273: PUSH
61274: LD_INT 30
61276: PUSH
61277: LD_INT 8
61279: PUSH
61280: EMPTY
61281: LIST
61282: LIST
61283: PUSH
61284: EMPTY
61285: LIST
61286: LIST
61287: LIST
61288: LIST
61289: PUSH
61290: EMPTY
61291: LIST
61292: LIST
61293: PPUSH
61294: CALL_OW 72
61298: ST_TO_ADDR
61299: GO 61302
61301: POP
// if i = 1 then
61302: LD_VAR 0 8
61306: PUSH
61307: LD_INT 1
61309: EQUAL
61310: IFFALSE 61421
// begin tmp := [ ] ;
61312: LD_ADDR_VAR 0 19
61316: PUSH
61317: EMPTY
61318: ST_TO_ADDR
// for j in f do
61319: LD_ADDR_VAR 0 9
61323: PUSH
61324: LD_VAR 0 12
61328: PUSH
61329: FOR_IN
61330: IFFALSE 61403
// if GetBType ( j ) = b_bunker then
61332: LD_VAR 0 9
61336: PPUSH
61337: CALL_OW 266
61341: PUSH
61342: LD_INT 32
61344: EQUAL
61345: IFFALSE 61372
// tmp := Insert ( tmp , 1 , j ) else
61347: LD_ADDR_VAR 0 19
61351: PUSH
61352: LD_VAR 0 19
61356: PPUSH
61357: LD_INT 1
61359: PPUSH
61360: LD_VAR 0 9
61364: PPUSH
61365: CALL_OW 2
61369: ST_TO_ADDR
61370: GO 61401
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61372: LD_ADDR_VAR 0 19
61376: PUSH
61377: LD_VAR 0 19
61381: PPUSH
61382: LD_VAR 0 19
61386: PUSH
61387: LD_INT 1
61389: PLUS
61390: PPUSH
61391: LD_VAR 0 9
61395: PPUSH
61396: CALL_OW 2
61400: ST_TO_ADDR
61401: GO 61329
61403: POP
61404: POP
// if tmp then
61405: LD_VAR 0 19
61409: IFFALSE 61421
// f := tmp ;
61411: LD_ADDR_VAR 0 12
61415: PUSH
61416: LD_VAR 0 19
61420: ST_TO_ADDR
// end ; x := personel [ i ] ;
61421: LD_ADDR_VAR 0 13
61425: PUSH
61426: LD_VAR 0 6
61430: PUSH
61431: LD_VAR 0 8
61435: ARRAY
61436: ST_TO_ADDR
// if x = - 1 then
61437: LD_VAR 0 13
61441: PUSH
61442: LD_INT 1
61444: NEG
61445: EQUAL
61446: IFFALSE 61655
// begin for j in f do
61448: LD_ADDR_VAR 0 9
61452: PUSH
61453: LD_VAR 0 12
61457: PUSH
61458: FOR_IN
61459: IFFALSE 61651
// repeat InitHc ;
61461: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61465: LD_VAR 0 9
61469: PPUSH
61470: CALL_OW 266
61474: PUSH
61475: LD_INT 5
61477: EQUAL
61478: IFFALSE 61548
// begin if UnitsInside ( j ) < 3 then
61480: LD_VAR 0 9
61484: PPUSH
61485: CALL_OW 313
61489: PUSH
61490: LD_INT 3
61492: LESS
61493: IFFALSE 61529
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61495: LD_INT 0
61497: PPUSH
61498: LD_INT 5
61500: PUSH
61501: LD_INT 8
61503: PUSH
61504: LD_INT 9
61506: PUSH
61507: EMPTY
61508: LIST
61509: LIST
61510: LIST
61511: PUSH
61512: LD_VAR 0 17
61516: ARRAY
61517: PPUSH
61518: LD_VAR 0 4
61522: PPUSH
61523: CALL_OW 380
61527: GO 61546
// PrepareHuman ( false , i , skill ) ;
61529: LD_INT 0
61531: PPUSH
61532: LD_VAR 0 8
61536: PPUSH
61537: LD_VAR 0 4
61541: PPUSH
61542: CALL_OW 380
// end else
61546: GO 61565
// PrepareHuman ( false , i , skill ) ;
61548: LD_INT 0
61550: PPUSH
61551: LD_VAR 0 8
61555: PPUSH
61556: LD_VAR 0 4
61560: PPUSH
61561: CALL_OW 380
// un := CreateHuman ;
61565: LD_ADDR_VAR 0 14
61569: PUSH
61570: CALL_OW 44
61574: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61575: LD_ADDR_VAR 0 7
61579: PUSH
61580: LD_VAR 0 7
61584: PPUSH
61585: LD_INT 1
61587: PPUSH
61588: LD_VAR 0 14
61592: PPUSH
61593: CALL_OW 2
61597: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61598: LD_VAR 0 14
61602: PPUSH
61603: LD_VAR 0 9
61607: PPUSH
61608: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61612: LD_VAR 0 9
61616: PPUSH
61617: CALL_OW 313
61621: PUSH
61622: LD_INT 6
61624: EQUAL
61625: PUSH
61626: LD_VAR 0 9
61630: PPUSH
61631: CALL_OW 266
61635: PUSH
61636: LD_INT 32
61638: PUSH
61639: LD_INT 31
61641: PUSH
61642: EMPTY
61643: LIST
61644: LIST
61645: IN
61646: OR
61647: IFFALSE 61461
61649: GO 61458
61651: POP
61652: POP
// end else
61653: GO 62035
// for j = 1 to x do
61655: LD_ADDR_VAR 0 9
61659: PUSH
61660: DOUBLE
61661: LD_INT 1
61663: DEC
61664: ST_TO_ADDR
61665: LD_VAR 0 13
61669: PUSH
61670: FOR_TO
61671: IFFALSE 62033
// begin InitHc ;
61673: CALL_OW 19
// if not f then
61677: LD_VAR 0 12
61681: NOT
61682: IFFALSE 61771
// begin PrepareHuman ( false , i , skill ) ;
61684: LD_INT 0
61686: PPUSH
61687: LD_VAR 0 8
61691: PPUSH
61692: LD_VAR 0 4
61696: PPUSH
61697: CALL_OW 380
// un := CreateHuman ;
61701: LD_ADDR_VAR 0 14
61705: PUSH
61706: CALL_OW 44
61710: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61711: LD_ADDR_VAR 0 7
61715: PUSH
61716: LD_VAR 0 7
61720: PPUSH
61721: LD_INT 1
61723: PPUSH
61724: LD_VAR 0 14
61728: PPUSH
61729: CALL_OW 2
61733: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61734: LD_VAR 0 14
61738: PPUSH
61739: LD_VAR 0 1
61743: PPUSH
61744: CALL_OW 250
61748: PPUSH
61749: LD_VAR 0 1
61753: PPUSH
61754: CALL_OW 251
61758: PPUSH
61759: LD_INT 10
61761: PPUSH
61762: LD_INT 0
61764: PPUSH
61765: CALL_OW 50
// continue ;
61769: GO 61670
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61771: LD_VAR 0 12
61775: PUSH
61776: LD_INT 1
61778: ARRAY
61779: PPUSH
61780: CALL_OW 313
61784: PUSH
61785: LD_VAR 0 12
61789: PUSH
61790: LD_INT 1
61792: ARRAY
61793: PPUSH
61794: CALL_OW 266
61798: PUSH
61799: LD_INT 32
61801: PUSH
61802: LD_INT 31
61804: PUSH
61805: EMPTY
61806: LIST
61807: LIST
61808: IN
61809: AND
61810: PUSH
61811: LD_VAR 0 12
61815: PUSH
61816: LD_INT 1
61818: ARRAY
61819: PPUSH
61820: CALL_OW 313
61824: PUSH
61825: LD_INT 6
61827: EQUAL
61828: OR
61829: IFFALSE 61849
// f := Delete ( f , 1 ) ;
61831: LD_ADDR_VAR 0 12
61835: PUSH
61836: LD_VAR 0 12
61840: PPUSH
61841: LD_INT 1
61843: PPUSH
61844: CALL_OW 3
61848: ST_TO_ADDR
// if not f then
61849: LD_VAR 0 12
61853: NOT
61854: IFFALSE 61872
// begin x := x + 2 ;
61856: LD_ADDR_VAR 0 13
61860: PUSH
61861: LD_VAR 0 13
61865: PUSH
61866: LD_INT 2
61868: PLUS
61869: ST_TO_ADDR
// continue ;
61870: GO 61670
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61872: LD_VAR 0 12
61876: PUSH
61877: LD_INT 1
61879: ARRAY
61880: PPUSH
61881: CALL_OW 266
61885: PUSH
61886: LD_INT 5
61888: EQUAL
61889: IFFALSE 61963
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61891: LD_VAR 0 12
61895: PUSH
61896: LD_INT 1
61898: ARRAY
61899: PPUSH
61900: CALL_OW 313
61904: PUSH
61905: LD_INT 3
61907: LESS
61908: IFFALSE 61944
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61910: LD_INT 0
61912: PPUSH
61913: LD_INT 5
61915: PUSH
61916: LD_INT 8
61918: PUSH
61919: LD_INT 9
61921: PUSH
61922: EMPTY
61923: LIST
61924: LIST
61925: LIST
61926: PUSH
61927: LD_VAR 0 17
61931: ARRAY
61932: PPUSH
61933: LD_VAR 0 4
61937: PPUSH
61938: CALL_OW 380
61942: GO 61961
// PrepareHuman ( false , i , skill ) ;
61944: LD_INT 0
61946: PPUSH
61947: LD_VAR 0 8
61951: PPUSH
61952: LD_VAR 0 4
61956: PPUSH
61957: CALL_OW 380
// end else
61961: GO 61980
// PrepareHuman ( false , i , skill ) ;
61963: LD_INT 0
61965: PPUSH
61966: LD_VAR 0 8
61970: PPUSH
61971: LD_VAR 0 4
61975: PPUSH
61976: CALL_OW 380
// un := CreateHuman ;
61980: LD_ADDR_VAR 0 14
61984: PUSH
61985: CALL_OW 44
61989: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61990: LD_ADDR_VAR 0 7
61994: PUSH
61995: LD_VAR 0 7
61999: PPUSH
62000: LD_INT 1
62002: PPUSH
62003: LD_VAR 0 14
62007: PPUSH
62008: CALL_OW 2
62012: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62013: LD_VAR 0 14
62017: PPUSH
62018: LD_VAR 0 12
62022: PUSH
62023: LD_INT 1
62025: ARRAY
62026: PPUSH
62027: CALL_OW 52
// end ;
62031: GO 61670
62033: POP
62034: POP
// end ;
62035: GO 60972
62037: POP
62038: POP
// result := result ^ buildings ;
62039: LD_ADDR_VAR 0 7
62043: PUSH
62044: LD_VAR 0 7
62048: PUSH
62049: LD_VAR 0 18
62053: ADD
62054: ST_TO_ADDR
// end else
62055: GO 62198
// begin for i = 1 to personel do
62057: LD_ADDR_VAR 0 8
62061: PUSH
62062: DOUBLE
62063: LD_INT 1
62065: DEC
62066: ST_TO_ADDR
62067: LD_VAR 0 6
62071: PUSH
62072: FOR_TO
62073: IFFALSE 62196
// begin if i > 4 then
62075: LD_VAR 0 8
62079: PUSH
62080: LD_INT 4
62082: GREATER
62083: IFFALSE 62087
// break ;
62085: GO 62196
// x := personel [ i ] ;
62087: LD_ADDR_VAR 0 13
62091: PUSH
62092: LD_VAR 0 6
62096: PUSH
62097: LD_VAR 0 8
62101: ARRAY
62102: ST_TO_ADDR
// if x = - 1 then
62103: LD_VAR 0 13
62107: PUSH
62108: LD_INT 1
62110: NEG
62111: EQUAL
62112: IFFALSE 62116
// continue ;
62114: GO 62072
// PrepareHuman ( false , i , skill ) ;
62116: LD_INT 0
62118: PPUSH
62119: LD_VAR 0 8
62123: PPUSH
62124: LD_VAR 0 4
62128: PPUSH
62129: CALL_OW 380
// un := CreateHuman ;
62133: LD_ADDR_VAR 0 14
62137: PUSH
62138: CALL_OW 44
62142: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62143: LD_VAR 0 14
62147: PPUSH
62148: LD_VAR 0 1
62152: PPUSH
62153: CALL_OW 250
62157: PPUSH
62158: LD_VAR 0 1
62162: PPUSH
62163: CALL_OW 251
62167: PPUSH
62168: LD_INT 10
62170: PPUSH
62171: LD_INT 0
62173: PPUSH
62174: CALL_OW 50
// result := result ^ un ;
62178: LD_ADDR_VAR 0 7
62182: PUSH
62183: LD_VAR 0 7
62187: PUSH
62188: LD_VAR 0 14
62192: ADD
62193: ST_TO_ADDR
// end ;
62194: GO 62072
62196: POP
62197: POP
// end ; end ;
62198: LD_VAR 0 7
62202: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62203: LD_INT 0
62205: PPUSH
62206: PPUSH
62207: PPUSH
62208: PPUSH
62209: PPUSH
62210: PPUSH
62211: PPUSH
62212: PPUSH
62213: PPUSH
62214: PPUSH
62215: PPUSH
62216: PPUSH
62217: PPUSH
62218: PPUSH
62219: PPUSH
62220: PPUSH
// result := false ;
62221: LD_ADDR_VAR 0 3
62225: PUSH
62226: LD_INT 0
62228: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62229: LD_VAR 0 1
62233: NOT
62234: PUSH
62235: LD_VAR 0 1
62239: PPUSH
62240: CALL_OW 266
62244: PUSH
62245: LD_INT 32
62247: PUSH
62248: LD_INT 33
62250: PUSH
62251: EMPTY
62252: LIST
62253: LIST
62254: IN
62255: NOT
62256: OR
62257: IFFALSE 62261
// exit ;
62259: GO 63370
// nat := GetNation ( tower ) ;
62261: LD_ADDR_VAR 0 12
62265: PUSH
62266: LD_VAR 0 1
62270: PPUSH
62271: CALL_OW 248
62275: ST_TO_ADDR
// side := GetSide ( tower ) ;
62276: LD_ADDR_VAR 0 16
62280: PUSH
62281: LD_VAR 0 1
62285: PPUSH
62286: CALL_OW 255
62290: ST_TO_ADDR
// x := GetX ( tower ) ;
62291: LD_ADDR_VAR 0 10
62295: PUSH
62296: LD_VAR 0 1
62300: PPUSH
62301: CALL_OW 250
62305: ST_TO_ADDR
// y := GetY ( tower ) ;
62306: LD_ADDR_VAR 0 11
62310: PUSH
62311: LD_VAR 0 1
62315: PPUSH
62316: CALL_OW 251
62320: ST_TO_ADDR
// if not x or not y then
62321: LD_VAR 0 10
62325: NOT
62326: PUSH
62327: LD_VAR 0 11
62331: NOT
62332: OR
62333: IFFALSE 62337
// exit ;
62335: GO 63370
// weapon := 0 ;
62337: LD_ADDR_VAR 0 18
62341: PUSH
62342: LD_INT 0
62344: ST_TO_ADDR
// fac_list := [ ] ;
62345: LD_ADDR_VAR 0 17
62349: PUSH
62350: EMPTY
62351: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62352: LD_ADDR_VAR 0 6
62356: PUSH
62357: LD_VAR 0 1
62361: PPUSH
62362: CALL_OW 274
62366: PPUSH
62367: LD_VAR 0 2
62371: PPUSH
62372: LD_INT 0
62374: PPUSH
62375: CALL 59941 0 3
62379: PPUSH
62380: LD_INT 30
62382: PUSH
62383: LD_INT 3
62385: PUSH
62386: EMPTY
62387: LIST
62388: LIST
62389: PPUSH
62390: CALL_OW 72
62394: ST_TO_ADDR
// if not factories then
62395: LD_VAR 0 6
62399: NOT
62400: IFFALSE 62404
// exit ;
62402: GO 63370
// for i in factories do
62404: LD_ADDR_VAR 0 8
62408: PUSH
62409: LD_VAR 0 6
62413: PUSH
62414: FOR_IN
62415: IFFALSE 62440
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62417: LD_ADDR_VAR 0 17
62421: PUSH
62422: LD_VAR 0 17
62426: PUSH
62427: LD_VAR 0 8
62431: PPUSH
62432: CALL_OW 478
62436: UNION
62437: ST_TO_ADDR
62438: GO 62414
62440: POP
62441: POP
// if not fac_list then
62442: LD_VAR 0 17
62446: NOT
62447: IFFALSE 62451
// exit ;
62449: GO 63370
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62451: LD_ADDR_VAR 0 5
62455: PUSH
62456: LD_INT 4
62458: PUSH
62459: LD_INT 5
62461: PUSH
62462: LD_INT 9
62464: PUSH
62465: LD_INT 10
62467: PUSH
62468: LD_INT 6
62470: PUSH
62471: LD_INT 7
62473: PUSH
62474: LD_INT 11
62476: PUSH
62477: EMPTY
62478: LIST
62479: LIST
62480: LIST
62481: LIST
62482: LIST
62483: LIST
62484: LIST
62485: PUSH
62486: LD_INT 27
62488: PUSH
62489: LD_INT 28
62491: PUSH
62492: LD_INT 26
62494: PUSH
62495: LD_INT 30
62497: PUSH
62498: EMPTY
62499: LIST
62500: LIST
62501: LIST
62502: LIST
62503: PUSH
62504: LD_INT 43
62506: PUSH
62507: LD_INT 44
62509: PUSH
62510: LD_INT 46
62512: PUSH
62513: LD_INT 45
62515: PUSH
62516: LD_INT 47
62518: PUSH
62519: LD_INT 49
62521: PUSH
62522: EMPTY
62523: LIST
62524: LIST
62525: LIST
62526: LIST
62527: LIST
62528: LIST
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: LIST
62534: PUSH
62535: LD_VAR 0 12
62539: ARRAY
62540: ST_TO_ADDR
// list := list isect fac_list ;
62541: LD_ADDR_VAR 0 5
62545: PUSH
62546: LD_VAR 0 5
62550: PUSH
62551: LD_VAR 0 17
62555: ISECT
62556: ST_TO_ADDR
// if not list then
62557: LD_VAR 0 5
62561: NOT
62562: IFFALSE 62566
// exit ;
62564: GO 63370
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62566: LD_VAR 0 12
62570: PUSH
62571: LD_INT 3
62573: EQUAL
62574: PUSH
62575: LD_INT 49
62577: PUSH
62578: LD_VAR 0 5
62582: IN
62583: AND
62584: PUSH
62585: LD_INT 31
62587: PPUSH
62588: LD_VAR 0 16
62592: PPUSH
62593: CALL_OW 321
62597: PUSH
62598: LD_INT 2
62600: EQUAL
62601: AND
62602: IFFALSE 62662
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62604: LD_INT 22
62606: PUSH
62607: LD_VAR 0 16
62611: PUSH
62612: EMPTY
62613: LIST
62614: LIST
62615: PUSH
62616: LD_INT 35
62618: PUSH
62619: LD_INT 49
62621: PUSH
62622: EMPTY
62623: LIST
62624: LIST
62625: PUSH
62626: LD_INT 91
62628: PUSH
62629: LD_VAR 0 1
62633: PUSH
62634: LD_INT 10
62636: PUSH
62637: EMPTY
62638: LIST
62639: LIST
62640: LIST
62641: PUSH
62642: EMPTY
62643: LIST
62644: LIST
62645: LIST
62646: PPUSH
62647: CALL_OW 69
62651: NOT
62652: IFFALSE 62662
// weapon := ru_time_lapser ;
62654: LD_ADDR_VAR 0 18
62658: PUSH
62659: LD_INT 49
62661: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62662: LD_VAR 0 12
62666: PUSH
62667: LD_INT 1
62669: PUSH
62670: LD_INT 2
62672: PUSH
62673: EMPTY
62674: LIST
62675: LIST
62676: IN
62677: PUSH
62678: LD_INT 11
62680: PUSH
62681: LD_VAR 0 5
62685: IN
62686: PUSH
62687: LD_INT 30
62689: PUSH
62690: LD_VAR 0 5
62694: IN
62695: OR
62696: AND
62697: PUSH
62698: LD_INT 6
62700: PPUSH
62701: LD_VAR 0 16
62705: PPUSH
62706: CALL_OW 321
62710: PUSH
62711: LD_INT 2
62713: EQUAL
62714: AND
62715: IFFALSE 62880
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62717: LD_INT 22
62719: PUSH
62720: LD_VAR 0 16
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PUSH
62729: LD_INT 2
62731: PUSH
62732: LD_INT 35
62734: PUSH
62735: LD_INT 11
62737: PUSH
62738: EMPTY
62739: LIST
62740: LIST
62741: PUSH
62742: LD_INT 35
62744: PUSH
62745: LD_INT 30
62747: PUSH
62748: EMPTY
62749: LIST
62750: LIST
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: LIST
62756: PUSH
62757: LD_INT 91
62759: PUSH
62760: LD_VAR 0 1
62764: PUSH
62765: LD_INT 18
62767: PUSH
62768: EMPTY
62769: LIST
62770: LIST
62771: LIST
62772: PUSH
62773: EMPTY
62774: LIST
62775: LIST
62776: LIST
62777: PPUSH
62778: CALL_OW 69
62782: NOT
62783: PUSH
62784: LD_INT 22
62786: PUSH
62787: LD_VAR 0 16
62791: PUSH
62792: EMPTY
62793: LIST
62794: LIST
62795: PUSH
62796: LD_INT 2
62798: PUSH
62799: LD_INT 30
62801: PUSH
62802: LD_INT 32
62804: PUSH
62805: EMPTY
62806: LIST
62807: LIST
62808: PUSH
62809: LD_INT 30
62811: PUSH
62812: LD_INT 33
62814: PUSH
62815: EMPTY
62816: LIST
62817: LIST
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: LIST
62823: PUSH
62824: LD_INT 91
62826: PUSH
62827: LD_VAR 0 1
62831: PUSH
62832: LD_INT 12
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: LIST
62839: PUSH
62840: EMPTY
62841: LIST
62842: LIST
62843: LIST
62844: PUSH
62845: EMPTY
62846: LIST
62847: PPUSH
62848: CALL_OW 69
62852: PUSH
62853: LD_INT 2
62855: GREATER
62856: AND
62857: IFFALSE 62880
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62859: LD_ADDR_VAR 0 18
62863: PUSH
62864: LD_INT 11
62866: PUSH
62867: LD_INT 30
62869: PUSH
62870: EMPTY
62871: LIST
62872: LIST
62873: PUSH
62874: LD_VAR 0 12
62878: ARRAY
62879: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62880: LD_VAR 0 18
62884: NOT
62885: PUSH
62886: LD_INT 40
62888: PPUSH
62889: LD_VAR 0 16
62893: PPUSH
62894: CALL_OW 321
62898: PUSH
62899: LD_INT 2
62901: EQUAL
62902: AND
62903: PUSH
62904: LD_INT 7
62906: PUSH
62907: LD_VAR 0 5
62911: IN
62912: PUSH
62913: LD_INT 28
62915: PUSH
62916: LD_VAR 0 5
62920: IN
62921: OR
62922: PUSH
62923: LD_INT 45
62925: PUSH
62926: LD_VAR 0 5
62930: IN
62931: OR
62932: AND
62933: IFFALSE 63187
// begin hex := GetHexInfo ( x , y ) ;
62935: LD_ADDR_VAR 0 4
62939: PUSH
62940: LD_VAR 0 10
62944: PPUSH
62945: LD_VAR 0 11
62949: PPUSH
62950: CALL_OW 546
62954: ST_TO_ADDR
// if hex [ 1 ] then
62955: LD_VAR 0 4
62959: PUSH
62960: LD_INT 1
62962: ARRAY
62963: IFFALSE 62967
// exit ;
62965: GO 63370
// height := hex [ 2 ] ;
62967: LD_ADDR_VAR 0 15
62971: PUSH
62972: LD_VAR 0 4
62976: PUSH
62977: LD_INT 2
62979: ARRAY
62980: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62981: LD_ADDR_VAR 0 14
62985: PUSH
62986: LD_INT 0
62988: PUSH
62989: LD_INT 2
62991: PUSH
62992: LD_INT 3
62994: PUSH
62995: LD_INT 5
62997: PUSH
62998: EMPTY
62999: LIST
63000: LIST
63001: LIST
63002: LIST
63003: ST_TO_ADDR
// for i in tmp do
63004: LD_ADDR_VAR 0 8
63008: PUSH
63009: LD_VAR 0 14
63013: PUSH
63014: FOR_IN
63015: IFFALSE 63185
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63017: LD_ADDR_VAR 0 9
63021: PUSH
63022: LD_VAR 0 10
63026: PPUSH
63027: LD_VAR 0 8
63031: PPUSH
63032: LD_INT 5
63034: PPUSH
63035: CALL_OW 272
63039: PUSH
63040: LD_VAR 0 11
63044: PPUSH
63045: LD_VAR 0 8
63049: PPUSH
63050: LD_INT 5
63052: PPUSH
63053: CALL_OW 273
63057: PUSH
63058: EMPTY
63059: LIST
63060: LIST
63061: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63062: LD_VAR 0 9
63066: PUSH
63067: LD_INT 1
63069: ARRAY
63070: PPUSH
63071: LD_VAR 0 9
63075: PUSH
63076: LD_INT 2
63078: ARRAY
63079: PPUSH
63080: CALL_OW 488
63084: IFFALSE 63183
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63086: LD_ADDR_VAR 0 4
63090: PUSH
63091: LD_VAR 0 9
63095: PUSH
63096: LD_INT 1
63098: ARRAY
63099: PPUSH
63100: LD_VAR 0 9
63104: PUSH
63105: LD_INT 2
63107: ARRAY
63108: PPUSH
63109: CALL_OW 546
63113: ST_TO_ADDR
// if hex [ 1 ] then
63114: LD_VAR 0 4
63118: PUSH
63119: LD_INT 1
63121: ARRAY
63122: IFFALSE 63126
// continue ;
63124: GO 63014
// h := hex [ 2 ] ;
63126: LD_ADDR_VAR 0 13
63130: PUSH
63131: LD_VAR 0 4
63135: PUSH
63136: LD_INT 2
63138: ARRAY
63139: ST_TO_ADDR
// if h + 7 < height then
63140: LD_VAR 0 13
63144: PUSH
63145: LD_INT 7
63147: PLUS
63148: PUSH
63149: LD_VAR 0 15
63153: LESS
63154: IFFALSE 63183
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63156: LD_ADDR_VAR 0 18
63160: PUSH
63161: LD_INT 7
63163: PUSH
63164: LD_INT 28
63166: PUSH
63167: LD_INT 45
63169: PUSH
63170: EMPTY
63171: LIST
63172: LIST
63173: LIST
63174: PUSH
63175: LD_VAR 0 12
63179: ARRAY
63180: ST_TO_ADDR
// break ;
63181: GO 63185
// end ; end ; end ;
63183: GO 63014
63185: POP
63186: POP
// end ; if not weapon then
63187: LD_VAR 0 18
63191: NOT
63192: IFFALSE 63252
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63194: LD_ADDR_VAR 0 5
63198: PUSH
63199: LD_VAR 0 5
63203: PUSH
63204: LD_INT 11
63206: PUSH
63207: LD_INT 30
63209: PUSH
63210: LD_INT 49
63212: PUSH
63213: EMPTY
63214: LIST
63215: LIST
63216: LIST
63217: DIFF
63218: ST_TO_ADDR
// if not list then
63219: LD_VAR 0 5
63223: NOT
63224: IFFALSE 63228
// exit ;
63226: GO 63370
// weapon := list [ rand ( 1 , list ) ] ;
63228: LD_ADDR_VAR 0 18
63232: PUSH
63233: LD_VAR 0 5
63237: PUSH
63238: LD_INT 1
63240: PPUSH
63241: LD_VAR 0 5
63245: PPUSH
63246: CALL_OW 12
63250: ARRAY
63251: ST_TO_ADDR
// end ; if weapon then
63252: LD_VAR 0 18
63256: IFFALSE 63370
// begin tmp := CostOfWeapon ( weapon ) ;
63258: LD_ADDR_VAR 0 14
63262: PUSH
63263: LD_VAR 0 18
63267: PPUSH
63268: CALL_OW 451
63272: ST_TO_ADDR
// j := GetBase ( tower ) ;
63273: LD_ADDR_VAR 0 9
63277: PUSH
63278: LD_VAR 0 1
63282: PPUSH
63283: CALL_OW 274
63287: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63288: LD_VAR 0 9
63292: PPUSH
63293: LD_INT 1
63295: PPUSH
63296: CALL_OW 275
63300: PUSH
63301: LD_VAR 0 14
63305: PUSH
63306: LD_INT 1
63308: ARRAY
63309: GREATEREQUAL
63310: PUSH
63311: LD_VAR 0 9
63315: PPUSH
63316: LD_INT 2
63318: PPUSH
63319: CALL_OW 275
63323: PUSH
63324: LD_VAR 0 14
63328: PUSH
63329: LD_INT 2
63331: ARRAY
63332: GREATEREQUAL
63333: AND
63334: PUSH
63335: LD_VAR 0 9
63339: PPUSH
63340: LD_INT 3
63342: PPUSH
63343: CALL_OW 275
63347: PUSH
63348: LD_VAR 0 14
63352: PUSH
63353: LD_INT 3
63355: ARRAY
63356: GREATEREQUAL
63357: AND
63358: IFFALSE 63370
// result := weapon ;
63360: LD_ADDR_VAR 0 3
63364: PUSH
63365: LD_VAR 0 18
63369: ST_TO_ADDR
// end ; end ;
63370: LD_VAR 0 3
63374: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63375: LD_INT 0
63377: PPUSH
63378: PPUSH
// result := true ;
63379: LD_ADDR_VAR 0 3
63383: PUSH
63384: LD_INT 1
63386: ST_TO_ADDR
// if array1 = array2 then
63387: LD_VAR 0 1
63391: PUSH
63392: LD_VAR 0 2
63396: EQUAL
63397: IFFALSE 63457
// begin for i = 1 to array1 do
63399: LD_ADDR_VAR 0 4
63403: PUSH
63404: DOUBLE
63405: LD_INT 1
63407: DEC
63408: ST_TO_ADDR
63409: LD_VAR 0 1
63413: PUSH
63414: FOR_TO
63415: IFFALSE 63453
// if array1 [ i ] <> array2 [ i ] then
63417: LD_VAR 0 1
63421: PUSH
63422: LD_VAR 0 4
63426: ARRAY
63427: PUSH
63428: LD_VAR 0 2
63432: PUSH
63433: LD_VAR 0 4
63437: ARRAY
63438: NONEQUAL
63439: IFFALSE 63451
// begin result := false ;
63441: LD_ADDR_VAR 0 3
63445: PUSH
63446: LD_INT 0
63448: ST_TO_ADDR
// break ;
63449: GO 63453
// end ;
63451: GO 63414
63453: POP
63454: POP
// end else
63455: GO 63465
// result := false ;
63457: LD_ADDR_VAR 0 3
63461: PUSH
63462: LD_INT 0
63464: ST_TO_ADDR
// end ;
63465: LD_VAR 0 3
63469: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63470: LD_INT 0
63472: PPUSH
63473: PPUSH
// if not array1 or not array2 then
63474: LD_VAR 0 1
63478: NOT
63479: PUSH
63480: LD_VAR 0 2
63484: NOT
63485: OR
63486: IFFALSE 63490
// exit ;
63488: GO 63554
// result := true ;
63490: LD_ADDR_VAR 0 3
63494: PUSH
63495: LD_INT 1
63497: ST_TO_ADDR
// for i = 1 to array1 do
63498: LD_ADDR_VAR 0 4
63502: PUSH
63503: DOUBLE
63504: LD_INT 1
63506: DEC
63507: ST_TO_ADDR
63508: LD_VAR 0 1
63512: PUSH
63513: FOR_TO
63514: IFFALSE 63552
// if array1 [ i ] <> array2 [ i ] then
63516: LD_VAR 0 1
63520: PUSH
63521: LD_VAR 0 4
63525: ARRAY
63526: PUSH
63527: LD_VAR 0 2
63531: PUSH
63532: LD_VAR 0 4
63536: ARRAY
63537: NONEQUAL
63538: IFFALSE 63550
// begin result := false ;
63540: LD_ADDR_VAR 0 3
63544: PUSH
63545: LD_INT 0
63547: ST_TO_ADDR
// break ;
63548: GO 63552
// end ;
63550: GO 63513
63552: POP
63553: POP
// end ;
63554: LD_VAR 0 3
63558: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63559: LD_INT 0
63561: PPUSH
63562: PPUSH
63563: PPUSH
// pom := GetBase ( fac ) ;
63564: LD_ADDR_VAR 0 5
63568: PUSH
63569: LD_VAR 0 1
63573: PPUSH
63574: CALL_OW 274
63578: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63579: LD_ADDR_VAR 0 4
63583: PUSH
63584: LD_VAR 0 2
63588: PUSH
63589: LD_INT 1
63591: ARRAY
63592: PPUSH
63593: LD_VAR 0 2
63597: PUSH
63598: LD_INT 2
63600: ARRAY
63601: PPUSH
63602: LD_VAR 0 2
63606: PUSH
63607: LD_INT 3
63609: ARRAY
63610: PPUSH
63611: LD_VAR 0 2
63615: PUSH
63616: LD_INT 4
63618: ARRAY
63619: PPUSH
63620: CALL_OW 449
63624: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63625: LD_ADDR_VAR 0 3
63629: PUSH
63630: LD_VAR 0 5
63634: PPUSH
63635: LD_INT 1
63637: PPUSH
63638: CALL_OW 275
63642: PUSH
63643: LD_VAR 0 4
63647: PUSH
63648: LD_INT 1
63650: ARRAY
63651: GREATEREQUAL
63652: PUSH
63653: LD_VAR 0 5
63657: PPUSH
63658: LD_INT 2
63660: PPUSH
63661: CALL_OW 275
63665: PUSH
63666: LD_VAR 0 4
63670: PUSH
63671: LD_INT 2
63673: ARRAY
63674: GREATEREQUAL
63675: AND
63676: PUSH
63677: LD_VAR 0 5
63681: PPUSH
63682: LD_INT 3
63684: PPUSH
63685: CALL_OW 275
63689: PUSH
63690: LD_VAR 0 4
63694: PUSH
63695: LD_INT 3
63697: ARRAY
63698: GREATEREQUAL
63699: AND
63700: ST_TO_ADDR
// end ;
63701: LD_VAR 0 3
63705: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63706: LD_INT 0
63708: PPUSH
63709: PPUSH
63710: PPUSH
63711: PPUSH
// pom := GetBase ( building ) ;
63712: LD_ADDR_VAR 0 3
63716: PUSH
63717: LD_VAR 0 1
63721: PPUSH
63722: CALL_OW 274
63726: ST_TO_ADDR
// if not pom then
63727: LD_VAR 0 3
63731: NOT
63732: IFFALSE 63736
// exit ;
63734: GO 63906
// btype := GetBType ( building ) ;
63736: LD_ADDR_VAR 0 5
63740: PUSH
63741: LD_VAR 0 1
63745: PPUSH
63746: CALL_OW 266
63750: ST_TO_ADDR
// if btype = b_armoury then
63751: LD_VAR 0 5
63755: PUSH
63756: LD_INT 4
63758: EQUAL
63759: IFFALSE 63769
// btype := b_barracks ;
63761: LD_ADDR_VAR 0 5
63765: PUSH
63766: LD_INT 5
63768: ST_TO_ADDR
// if btype = b_depot then
63769: LD_VAR 0 5
63773: PUSH
63774: LD_INT 0
63776: EQUAL
63777: IFFALSE 63787
// btype := b_warehouse ;
63779: LD_ADDR_VAR 0 5
63783: PUSH
63784: LD_INT 1
63786: ST_TO_ADDR
// if btype = b_workshop then
63787: LD_VAR 0 5
63791: PUSH
63792: LD_INT 2
63794: EQUAL
63795: IFFALSE 63805
// btype := b_factory ;
63797: LD_ADDR_VAR 0 5
63801: PUSH
63802: LD_INT 3
63804: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63805: LD_ADDR_VAR 0 4
63809: PUSH
63810: LD_VAR 0 5
63814: PPUSH
63815: LD_VAR 0 1
63819: PPUSH
63820: CALL_OW 248
63824: PPUSH
63825: CALL_OW 450
63829: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63830: LD_ADDR_VAR 0 2
63834: PUSH
63835: LD_VAR 0 3
63839: PPUSH
63840: LD_INT 1
63842: PPUSH
63843: CALL_OW 275
63847: PUSH
63848: LD_VAR 0 4
63852: PUSH
63853: LD_INT 1
63855: ARRAY
63856: GREATEREQUAL
63857: PUSH
63858: LD_VAR 0 3
63862: PPUSH
63863: LD_INT 2
63865: PPUSH
63866: CALL_OW 275
63870: PUSH
63871: LD_VAR 0 4
63875: PUSH
63876: LD_INT 2
63878: ARRAY
63879: GREATEREQUAL
63880: AND
63881: PUSH
63882: LD_VAR 0 3
63886: PPUSH
63887: LD_INT 3
63889: PPUSH
63890: CALL_OW 275
63894: PUSH
63895: LD_VAR 0 4
63899: PUSH
63900: LD_INT 3
63902: ARRAY
63903: GREATEREQUAL
63904: AND
63905: ST_TO_ADDR
// end ;
63906: LD_VAR 0 2
63910: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63911: LD_INT 0
63913: PPUSH
63914: PPUSH
63915: PPUSH
// pom := GetBase ( building ) ;
63916: LD_ADDR_VAR 0 4
63920: PUSH
63921: LD_VAR 0 1
63925: PPUSH
63926: CALL_OW 274
63930: ST_TO_ADDR
// if not pom then
63931: LD_VAR 0 4
63935: NOT
63936: IFFALSE 63940
// exit ;
63938: GO 64041
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63940: LD_ADDR_VAR 0 5
63944: PUSH
63945: LD_VAR 0 2
63949: PPUSH
63950: LD_VAR 0 1
63954: PPUSH
63955: CALL_OW 248
63959: PPUSH
63960: CALL_OW 450
63964: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63965: LD_ADDR_VAR 0 3
63969: PUSH
63970: LD_VAR 0 4
63974: PPUSH
63975: LD_INT 1
63977: PPUSH
63978: CALL_OW 275
63982: PUSH
63983: LD_VAR 0 5
63987: PUSH
63988: LD_INT 1
63990: ARRAY
63991: GREATEREQUAL
63992: PUSH
63993: LD_VAR 0 4
63997: PPUSH
63998: LD_INT 2
64000: PPUSH
64001: CALL_OW 275
64005: PUSH
64006: LD_VAR 0 5
64010: PUSH
64011: LD_INT 2
64013: ARRAY
64014: GREATEREQUAL
64015: AND
64016: PUSH
64017: LD_VAR 0 4
64021: PPUSH
64022: LD_INT 3
64024: PPUSH
64025: CALL_OW 275
64029: PUSH
64030: LD_VAR 0 5
64034: PUSH
64035: LD_INT 3
64037: ARRAY
64038: GREATEREQUAL
64039: AND
64040: ST_TO_ADDR
// end ;
64041: LD_VAR 0 3
64045: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
64046: LD_INT 0
64048: PPUSH
64049: PPUSH
64050: PPUSH
64051: PPUSH
64052: PPUSH
64053: PPUSH
64054: PPUSH
64055: PPUSH
64056: PPUSH
64057: PPUSH
64058: PPUSH
// result := false ;
64059: LD_ADDR_VAR 0 8
64063: PUSH
64064: LD_INT 0
64066: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
64067: LD_VAR 0 5
64071: NOT
64072: PUSH
64073: LD_VAR 0 1
64077: NOT
64078: OR
64079: PUSH
64080: LD_VAR 0 2
64084: NOT
64085: OR
64086: PUSH
64087: LD_VAR 0 3
64091: NOT
64092: OR
64093: IFFALSE 64097
// exit ;
64095: GO 64911
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
64097: LD_ADDR_VAR 0 14
64101: PUSH
64102: LD_VAR 0 1
64106: PPUSH
64107: LD_VAR 0 2
64111: PPUSH
64112: LD_VAR 0 3
64116: PPUSH
64117: LD_VAR 0 4
64121: PPUSH
64122: LD_VAR 0 5
64126: PUSH
64127: LD_INT 1
64129: ARRAY
64130: PPUSH
64131: CALL_OW 248
64135: PPUSH
64136: LD_INT 0
64138: PPUSH
64139: CALL 66148 0 6
64143: ST_TO_ADDR
// if not hexes then
64144: LD_VAR 0 14
64148: NOT
64149: IFFALSE 64153
// exit ;
64151: GO 64911
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64153: LD_ADDR_VAR 0 17
64157: PUSH
64158: LD_VAR 0 5
64162: PPUSH
64163: LD_INT 22
64165: PUSH
64166: LD_VAR 0 13
64170: PPUSH
64171: CALL_OW 255
64175: PUSH
64176: EMPTY
64177: LIST
64178: LIST
64179: PUSH
64180: LD_INT 2
64182: PUSH
64183: LD_INT 30
64185: PUSH
64186: LD_INT 0
64188: PUSH
64189: EMPTY
64190: LIST
64191: LIST
64192: PUSH
64193: LD_INT 30
64195: PUSH
64196: LD_INT 1
64198: PUSH
64199: EMPTY
64200: LIST
64201: LIST
64202: PUSH
64203: EMPTY
64204: LIST
64205: LIST
64206: LIST
64207: PUSH
64208: EMPTY
64209: LIST
64210: LIST
64211: PPUSH
64212: CALL_OW 72
64216: ST_TO_ADDR
// for i = 1 to hexes do
64217: LD_ADDR_VAR 0 9
64221: PUSH
64222: DOUBLE
64223: LD_INT 1
64225: DEC
64226: ST_TO_ADDR
64227: LD_VAR 0 14
64231: PUSH
64232: FOR_TO
64233: IFFALSE 64909
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64235: LD_ADDR_VAR 0 13
64239: PUSH
64240: LD_VAR 0 14
64244: PUSH
64245: LD_VAR 0 9
64249: ARRAY
64250: PUSH
64251: LD_INT 1
64253: ARRAY
64254: PPUSH
64255: LD_VAR 0 14
64259: PUSH
64260: LD_VAR 0 9
64264: ARRAY
64265: PUSH
64266: LD_INT 2
64268: ARRAY
64269: PPUSH
64270: CALL_OW 428
64274: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64275: LD_VAR 0 14
64279: PUSH
64280: LD_VAR 0 9
64284: ARRAY
64285: PUSH
64286: LD_INT 1
64288: ARRAY
64289: PPUSH
64290: LD_VAR 0 14
64294: PUSH
64295: LD_VAR 0 9
64299: ARRAY
64300: PUSH
64301: LD_INT 2
64303: ARRAY
64304: PPUSH
64305: CALL_OW 351
64309: PUSH
64310: LD_VAR 0 14
64314: PUSH
64315: LD_VAR 0 9
64319: ARRAY
64320: PUSH
64321: LD_INT 1
64323: ARRAY
64324: PPUSH
64325: LD_VAR 0 14
64329: PUSH
64330: LD_VAR 0 9
64334: ARRAY
64335: PUSH
64336: LD_INT 2
64338: ARRAY
64339: PPUSH
64340: CALL_OW 488
64344: NOT
64345: OR
64346: PUSH
64347: LD_VAR 0 13
64351: PPUSH
64352: CALL_OW 247
64356: PUSH
64357: LD_INT 3
64359: EQUAL
64360: OR
64361: IFFALSE 64367
// exit ;
64363: POP
64364: POP
64365: GO 64911
// if not tmp then
64367: LD_VAR 0 13
64371: NOT
64372: IFFALSE 64376
// continue ;
64374: GO 64232
// result := true ;
64376: LD_ADDR_VAR 0 8
64380: PUSH
64381: LD_INT 1
64383: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64384: LD_VAR 0 6
64388: PUSH
64389: LD_VAR 0 13
64393: PPUSH
64394: CALL_OW 247
64398: PUSH
64399: LD_INT 2
64401: EQUAL
64402: AND
64403: PUSH
64404: LD_VAR 0 13
64408: PPUSH
64409: CALL_OW 263
64413: PUSH
64414: LD_INT 1
64416: EQUAL
64417: AND
64418: IFFALSE 64582
// begin if IsDrivenBy ( tmp ) then
64420: LD_VAR 0 13
64424: PPUSH
64425: CALL_OW 311
64429: IFFALSE 64433
// continue ;
64431: GO 64232
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64433: LD_VAR 0 6
64437: PPUSH
64438: LD_INT 3
64440: PUSH
64441: LD_INT 60
64443: PUSH
64444: EMPTY
64445: LIST
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: PUSH
64451: LD_INT 3
64453: PUSH
64454: LD_INT 55
64456: PUSH
64457: EMPTY
64458: LIST
64459: PUSH
64460: EMPTY
64461: LIST
64462: LIST
64463: PUSH
64464: EMPTY
64465: LIST
64466: LIST
64467: PPUSH
64468: CALL_OW 72
64472: IFFALSE 64580
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64474: LD_ADDR_VAR 0 18
64478: PUSH
64479: LD_VAR 0 6
64483: PPUSH
64484: LD_INT 3
64486: PUSH
64487: LD_INT 60
64489: PUSH
64490: EMPTY
64491: LIST
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: LD_INT 3
64499: PUSH
64500: LD_INT 55
64502: PUSH
64503: EMPTY
64504: LIST
64505: PUSH
64506: EMPTY
64507: LIST
64508: LIST
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PPUSH
64514: CALL_OW 72
64518: PUSH
64519: LD_INT 1
64521: ARRAY
64522: ST_TO_ADDR
// if IsInUnit ( driver ) then
64523: LD_VAR 0 18
64527: PPUSH
64528: CALL_OW 310
64532: IFFALSE 64543
// ComExit ( driver ) ;
64534: LD_VAR 0 18
64538: PPUSH
64539: CALL 89276 0 1
// AddComEnterUnit ( driver , tmp ) ;
64543: LD_VAR 0 18
64547: PPUSH
64548: LD_VAR 0 13
64552: PPUSH
64553: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64557: LD_VAR 0 18
64561: PPUSH
64562: LD_VAR 0 7
64566: PPUSH
64567: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64571: LD_VAR 0 18
64575: PPUSH
64576: CALL_OW 181
// end ; continue ;
64580: GO 64232
// end ; if not cleaners or not tmp in cleaners then
64582: LD_VAR 0 6
64586: NOT
64587: PUSH
64588: LD_VAR 0 13
64592: PUSH
64593: LD_VAR 0 6
64597: IN
64598: NOT
64599: OR
64600: IFFALSE 64907
// begin if dep then
64602: LD_VAR 0 17
64606: IFFALSE 64742
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64608: LD_ADDR_VAR 0 16
64612: PUSH
64613: LD_VAR 0 17
64617: PUSH
64618: LD_INT 1
64620: ARRAY
64621: PPUSH
64622: CALL_OW 250
64626: PPUSH
64627: LD_VAR 0 17
64631: PUSH
64632: LD_INT 1
64634: ARRAY
64635: PPUSH
64636: CALL_OW 254
64640: PPUSH
64641: LD_INT 5
64643: PPUSH
64644: CALL_OW 272
64648: PUSH
64649: LD_VAR 0 17
64653: PUSH
64654: LD_INT 1
64656: ARRAY
64657: PPUSH
64658: CALL_OW 251
64662: PPUSH
64663: LD_VAR 0 17
64667: PUSH
64668: LD_INT 1
64670: ARRAY
64671: PPUSH
64672: CALL_OW 254
64676: PPUSH
64677: LD_INT 5
64679: PPUSH
64680: CALL_OW 273
64684: PUSH
64685: EMPTY
64686: LIST
64687: LIST
64688: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64689: LD_VAR 0 16
64693: PUSH
64694: LD_INT 1
64696: ARRAY
64697: PPUSH
64698: LD_VAR 0 16
64702: PUSH
64703: LD_INT 2
64705: ARRAY
64706: PPUSH
64707: CALL_OW 488
64711: IFFALSE 64742
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64713: LD_VAR 0 13
64717: PPUSH
64718: LD_VAR 0 16
64722: PUSH
64723: LD_INT 1
64725: ARRAY
64726: PPUSH
64727: LD_VAR 0 16
64731: PUSH
64732: LD_INT 2
64734: ARRAY
64735: PPUSH
64736: CALL_OW 111
// continue ;
64740: GO 64232
// end ; end ; r := GetDir ( tmp ) ;
64742: LD_ADDR_VAR 0 15
64746: PUSH
64747: LD_VAR 0 13
64751: PPUSH
64752: CALL_OW 254
64756: ST_TO_ADDR
// if r = 5 then
64757: LD_VAR 0 15
64761: PUSH
64762: LD_INT 5
64764: EQUAL
64765: IFFALSE 64775
// r := 0 ;
64767: LD_ADDR_VAR 0 15
64771: PUSH
64772: LD_INT 0
64774: ST_TO_ADDR
// for j = r to 5 do
64775: LD_ADDR_VAR 0 10
64779: PUSH
64780: DOUBLE
64781: LD_VAR 0 15
64785: DEC
64786: ST_TO_ADDR
64787: LD_INT 5
64789: PUSH
64790: FOR_TO
64791: IFFALSE 64905
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64793: LD_ADDR_VAR 0 11
64797: PUSH
64798: LD_VAR 0 13
64802: PPUSH
64803: CALL_OW 250
64807: PPUSH
64808: LD_VAR 0 10
64812: PPUSH
64813: LD_INT 2
64815: PPUSH
64816: CALL_OW 272
64820: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64821: LD_ADDR_VAR 0 12
64825: PUSH
64826: LD_VAR 0 13
64830: PPUSH
64831: CALL_OW 251
64835: PPUSH
64836: LD_VAR 0 10
64840: PPUSH
64841: LD_INT 2
64843: PPUSH
64844: CALL_OW 273
64848: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64849: LD_VAR 0 11
64853: PPUSH
64854: LD_VAR 0 12
64858: PPUSH
64859: CALL_OW 488
64863: PUSH
64864: LD_VAR 0 11
64868: PPUSH
64869: LD_VAR 0 12
64873: PPUSH
64874: CALL_OW 428
64878: NOT
64879: AND
64880: IFFALSE 64903
// begin ComMoveXY ( tmp , _x , _y ) ;
64882: LD_VAR 0 13
64886: PPUSH
64887: LD_VAR 0 11
64891: PPUSH
64892: LD_VAR 0 12
64896: PPUSH
64897: CALL_OW 111
// break ;
64901: GO 64905
// end ; end ;
64903: GO 64790
64905: POP
64906: POP
// end ; end ;
64907: GO 64232
64909: POP
64910: POP
// end ;
64911: LD_VAR 0 8
64915: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64916: LD_INT 0
64918: PPUSH
// result := true ;
64919: LD_ADDR_VAR 0 3
64923: PUSH
64924: LD_INT 1
64926: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64927: LD_VAR 0 2
64931: PUSH
64932: LD_INT 24
64934: DOUBLE
64935: EQUAL
64936: IFTRUE 64946
64938: LD_INT 33
64940: DOUBLE
64941: EQUAL
64942: IFTRUE 64946
64944: GO 64971
64946: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64947: LD_ADDR_VAR 0 3
64951: PUSH
64952: LD_INT 32
64954: PPUSH
64955: LD_VAR 0 1
64959: PPUSH
64960: CALL_OW 321
64964: PUSH
64965: LD_INT 2
64967: EQUAL
64968: ST_TO_ADDR
64969: GO 65291
64971: LD_INT 20
64973: DOUBLE
64974: EQUAL
64975: IFTRUE 64979
64977: GO 65004
64979: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64980: LD_ADDR_VAR 0 3
64984: PUSH
64985: LD_INT 6
64987: PPUSH
64988: LD_VAR 0 1
64992: PPUSH
64993: CALL_OW 321
64997: PUSH
64998: LD_INT 2
65000: EQUAL
65001: ST_TO_ADDR
65002: GO 65291
65004: LD_INT 22
65006: DOUBLE
65007: EQUAL
65008: IFTRUE 65018
65010: LD_INT 36
65012: DOUBLE
65013: EQUAL
65014: IFTRUE 65018
65016: GO 65043
65018: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
65019: LD_ADDR_VAR 0 3
65023: PUSH
65024: LD_INT 15
65026: PPUSH
65027: LD_VAR 0 1
65031: PPUSH
65032: CALL_OW 321
65036: PUSH
65037: LD_INT 2
65039: EQUAL
65040: ST_TO_ADDR
65041: GO 65291
65043: LD_INT 30
65045: DOUBLE
65046: EQUAL
65047: IFTRUE 65051
65049: GO 65076
65051: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
65052: LD_ADDR_VAR 0 3
65056: PUSH
65057: LD_INT 20
65059: PPUSH
65060: LD_VAR 0 1
65064: PPUSH
65065: CALL_OW 321
65069: PUSH
65070: LD_INT 2
65072: EQUAL
65073: ST_TO_ADDR
65074: GO 65291
65076: LD_INT 28
65078: DOUBLE
65079: EQUAL
65080: IFTRUE 65090
65082: LD_INT 21
65084: DOUBLE
65085: EQUAL
65086: IFTRUE 65090
65088: GO 65115
65090: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
65091: LD_ADDR_VAR 0 3
65095: PUSH
65096: LD_INT 21
65098: PPUSH
65099: LD_VAR 0 1
65103: PPUSH
65104: CALL_OW 321
65108: PUSH
65109: LD_INT 2
65111: EQUAL
65112: ST_TO_ADDR
65113: GO 65291
65115: LD_INT 16
65117: DOUBLE
65118: EQUAL
65119: IFTRUE 65123
65121: GO 65150
65123: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
65124: LD_ADDR_VAR 0 3
65128: PUSH
65129: LD_EXP 87
65133: PPUSH
65134: LD_VAR 0 1
65138: PPUSH
65139: CALL_OW 321
65143: PUSH
65144: LD_INT 2
65146: EQUAL
65147: ST_TO_ADDR
65148: GO 65291
65150: LD_INT 19
65152: DOUBLE
65153: EQUAL
65154: IFTRUE 65164
65156: LD_INT 23
65158: DOUBLE
65159: EQUAL
65160: IFTRUE 65164
65162: GO 65191
65164: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
65165: LD_ADDR_VAR 0 3
65169: PUSH
65170: LD_EXP 86
65174: PPUSH
65175: LD_VAR 0 1
65179: PPUSH
65180: CALL_OW 321
65184: PUSH
65185: LD_INT 2
65187: EQUAL
65188: ST_TO_ADDR
65189: GO 65291
65191: LD_INT 17
65193: DOUBLE
65194: EQUAL
65195: IFTRUE 65199
65197: GO 65224
65199: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65200: LD_ADDR_VAR 0 3
65204: PUSH
65205: LD_INT 39
65207: PPUSH
65208: LD_VAR 0 1
65212: PPUSH
65213: CALL_OW 321
65217: PUSH
65218: LD_INT 2
65220: EQUAL
65221: ST_TO_ADDR
65222: GO 65291
65224: LD_INT 18
65226: DOUBLE
65227: EQUAL
65228: IFTRUE 65232
65230: GO 65257
65232: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65233: LD_ADDR_VAR 0 3
65237: PUSH
65238: LD_INT 40
65240: PPUSH
65241: LD_VAR 0 1
65245: PPUSH
65246: CALL_OW 321
65250: PUSH
65251: LD_INT 2
65253: EQUAL
65254: ST_TO_ADDR
65255: GO 65291
65257: LD_INT 27
65259: DOUBLE
65260: EQUAL
65261: IFTRUE 65265
65263: GO 65290
65265: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65266: LD_ADDR_VAR 0 3
65270: PUSH
65271: LD_INT 35
65273: PPUSH
65274: LD_VAR 0 1
65278: PPUSH
65279: CALL_OW 321
65283: PUSH
65284: LD_INT 2
65286: EQUAL
65287: ST_TO_ADDR
65288: GO 65291
65290: POP
// end ;
65291: LD_VAR 0 3
65295: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65296: LD_INT 0
65298: PPUSH
65299: PPUSH
65300: PPUSH
65301: PPUSH
65302: PPUSH
65303: PPUSH
65304: PPUSH
65305: PPUSH
65306: PPUSH
65307: PPUSH
65308: PPUSH
// result := false ;
65309: LD_ADDR_VAR 0 6
65313: PUSH
65314: LD_INT 0
65316: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65317: LD_VAR 0 1
65321: NOT
65322: PUSH
65323: LD_VAR 0 1
65327: PPUSH
65328: CALL_OW 266
65332: PUSH
65333: LD_INT 0
65335: PUSH
65336: LD_INT 1
65338: PUSH
65339: EMPTY
65340: LIST
65341: LIST
65342: IN
65343: NOT
65344: OR
65345: PUSH
65346: LD_VAR 0 2
65350: NOT
65351: OR
65352: PUSH
65353: LD_VAR 0 5
65357: PUSH
65358: LD_INT 0
65360: PUSH
65361: LD_INT 1
65363: PUSH
65364: LD_INT 2
65366: PUSH
65367: LD_INT 3
65369: PUSH
65370: LD_INT 4
65372: PUSH
65373: LD_INT 5
65375: PUSH
65376: EMPTY
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: IN
65384: NOT
65385: OR
65386: PUSH
65387: LD_VAR 0 3
65391: PPUSH
65392: LD_VAR 0 4
65396: PPUSH
65397: CALL_OW 488
65401: NOT
65402: OR
65403: IFFALSE 65407
// exit ;
65405: GO 66143
// side := GetSide ( depot ) ;
65407: LD_ADDR_VAR 0 9
65411: PUSH
65412: LD_VAR 0 1
65416: PPUSH
65417: CALL_OW 255
65421: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65422: LD_VAR 0 9
65426: PPUSH
65427: LD_VAR 0 2
65431: PPUSH
65432: CALL 64916 0 2
65436: NOT
65437: IFFALSE 65441
// exit ;
65439: GO 66143
// pom := GetBase ( depot ) ;
65441: LD_ADDR_VAR 0 10
65445: PUSH
65446: LD_VAR 0 1
65450: PPUSH
65451: CALL_OW 274
65455: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65456: LD_ADDR_VAR 0 11
65460: PUSH
65461: LD_VAR 0 2
65465: PPUSH
65466: LD_VAR 0 1
65470: PPUSH
65471: CALL_OW 248
65475: PPUSH
65476: CALL_OW 450
65480: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65481: LD_VAR 0 10
65485: PPUSH
65486: LD_INT 1
65488: PPUSH
65489: CALL_OW 275
65493: PUSH
65494: LD_VAR 0 11
65498: PUSH
65499: LD_INT 1
65501: ARRAY
65502: GREATEREQUAL
65503: PUSH
65504: LD_VAR 0 10
65508: PPUSH
65509: LD_INT 2
65511: PPUSH
65512: CALL_OW 275
65516: PUSH
65517: LD_VAR 0 11
65521: PUSH
65522: LD_INT 2
65524: ARRAY
65525: GREATEREQUAL
65526: AND
65527: PUSH
65528: LD_VAR 0 10
65532: PPUSH
65533: LD_INT 3
65535: PPUSH
65536: CALL_OW 275
65540: PUSH
65541: LD_VAR 0 11
65545: PUSH
65546: LD_INT 3
65548: ARRAY
65549: GREATEREQUAL
65550: AND
65551: NOT
65552: IFFALSE 65556
// exit ;
65554: GO 66143
// if GetBType ( depot ) = b_depot then
65556: LD_VAR 0 1
65560: PPUSH
65561: CALL_OW 266
65565: PUSH
65566: LD_INT 0
65568: EQUAL
65569: IFFALSE 65581
// dist := 28 else
65571: LD_ADDR_VAR 0 14
65575: PUSH
65576: LD_INT 28
65578: ST_TO_ADDR
65579: GO 65589
// dist := 36 ;
65581: LD_ADDR_VAR 0 14
65585: PUSH
65586: LD_INT 36
65588: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65589: LD_VAR 0 1
65593: PPUSH
65594: LD_VAR 0 3
65598: PPUSH
65599: LD_VAR 0 4
65603: PPUSH
65604: CALL_OW 297
65608: PUSH
65609: LD_VAR 0 14
65613: GREATER
65614: IFFALSE 65618
// exit ;
65616: GO 66143
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65618: LD_ADDR_VAR 0 12
65622: PUSH
65623: LD_VAR 0 2
65627: PPUSH
65628: LD_VAR 0 3
65632: PPUSH
65633: LD_VAR 0 4
65637: PPUSH
65638: LD_VAR 0 5
65642: PPUSH
65643: LD_VAR 0 1
65647: PPUSH
65648: CALL_OW 248
65652: PPUSH
65653: LD_INT 0
65655: PPUSH
65656: CALL 66148 0 6
65660: ST_TO_ADDR
// if not hexes then
65661: LD_VAR 0 12
65665: NOT
65666: IFFALSE 65670
// exit ;
65668: GO 66143
// hex := GetHexInfo ( x , y ) ;
65670: LD_ADDR_VAR 0 15
65674: PUSH
65675: LD_VAR 0 3
65679: PPUSH
65680: LD_VAR 0 4
65684: PPUSH
65685: CALL_OW 546
65689: ST_TO_ADDR
// if hex [ 1 ] then
65690: LD_VAR 0 15
65694: PUSH
65695: LD_INT 1
65697: ARRAY
65698: IFFALSE 65702
// exit ;
65700: GO 66143
// height := hex [ 2 ] ;
65702: LD_ADDR_VAR 0 13
65706: PUSH
65707: LD_VAR 0 15
65711: PUSH
65712: LD_INT 2
65714: ARRAY
65715: ST_TO_ADDR
// for i = 1 to hexes do
65716: LD_ADDR_VAR 0 7
65720: PUSH
65721: DOUBLE
65722: LD_INT 1
65724: DEC
65725: ST_TO_ADDR
65726: LD_VAR 0 12
65730: PUSH
65731: FOR_TO
65732: IFFALSE 66062
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65734: LD_VAR 0 12
65738: PUSH
65739: LD_VAR 0 7
65743: ARRAY
65744: PUSH
65745: LD_INT 1
65747: ARRAY
65748: PPUSH
65749: LD_VAR 0 12
65753: PUSH
65754: LD_VAR 0 7
65758: ARRAY
65759: PUSH
65760: LD_INT 2
65762: ARRAY
65763: PPUSH
65764: CALL_OW 488
65768: NOT
65769: PUSH
65770: LD_VAR 0 12
65774: PUSH
65775: LD_VAR 0 7
65779: ARRAY
65780: PUSH
65781: LD_INT 1
65783: ARRAY
65784: PPUSH
65785: LD_VAR 0 12
65789: PUSH
65790: LD_VAR 0 7
65794: ARRAY
65795: PUSH
65796: LD_INT 2
65798: ARRAY
65799: PPUSH
65800: CALL_OW 428
65804: PUSH
65805: LD_INT 0
65807: GREATER
65808: OR
65809: PUSH
65810: LD_VAR 0 12
65814: PUSH
65815: LD_VAR 0 7
65819: ARRAY
65820: PUSH
65821: LD_INT 1
65823: ARRAY
65824: PPUSH
65825: LD_VAR 0 12
65829: PUSH
65830: LD_VAR 0 7
65834: ARRAY
65835: PUSH
65836: LD_INT 2
65838: ARRAY
65839: PPUSH
65840: CALL_OW 351
65844: OR
65845: IFFALSE 65851
// exit ;
65847: POP
65848: POP
65849: GO 66143
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65851: LD_ADDR_VAR 0 8
65855: PUSH
65856: LD_VAR 0 12
65860: PUSH
65861: LD_VAR 0 7
65865: ARRAY
65866: PUSH
65867: LD_INT 1
65869: ARRAY
65870: PPUSH
65871: LD_VAR 0 12
65875: PUSH
65876: LD_VAR 0 7
65880: ARRAY
65881: PUSH
65882: LD_INT 2
65884: ARRAY
65885: PPUSH
65886: CALL_OW 546
65890: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65891: LD_VAR 0 8
65895: PUSH
65896: LD_INT 1
65898: ARRAY
65899: PUSH
65900: LD_VAR 0 8
65904: PUSH
65905: LD_INT 2
65907: ARRAY
65908: PUSH
65909: LD_VAR 0 13
65913: PUSH
65914: LD_INT 2
65916: PLUS
65917: GREATER
65918: OR
65919: PUSH
65920: LD_VAR 0 8
65924: PUSH
65925: LD_INT 2
65927: ARRAY
65928: PUSH
65929: LD_VAR 0 13
65933: PUSH
65934: LD_INT 2
65936: MINUS
65937: LESS
65938: OR
65939: PUSH
65940: LD_VAR 0 8
65944: PUSH
65945: LD_INT 3
65947: ARRAY
65948: PUSH
65949: LD_INT 0
65951: PUSH
65952: LD_INT 8
65954: PUSH
65955: LD_INT 9
65957: PUSH
65958: LD_INT 10
65960: PUSH
65961: LD_INT 11
65963: PUSH
65964: LD_INT 12
65966: PUSH
65967: LD_INT 13
65969: PUSH
65970: LD_INT 16
65972: PUSH
65973: LD_INT 17
65975: PUSH
65976: LD_INT 18
65978: PUSH
65979: LD_INT 19
65981: PUSH
65982: LD_INT 20
65984: PUSH
65985: LD_INT 21
65987: PUSH
65988: EMPTY
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: IN
66003: NOT
66004: OR
66005: PUSH
66006: LD_VAR 0 8
66010: PUSH
66011: LD_INT 5
66013: ARRAY
66014: NOT
66015: OR
66016: PUSH
66017: LD_VAR 0 8
66021: PUSH
66022: LD_INT 6
66024: ARRAY
66025: PUSH
66026: LD_INT 1
66028: PUSH
66029: LD_INT 2
66031: PUSH
66032: LD_INT 7
66034: PUSH
66035: LD_INT 9
66037: PUSH
66038: LD_INT 10
66040: PUSH
66041: LD_INT 11
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: IN
66052: NOT
66053: OR
66054: IFFALSE 66060
// exit ;
66056: POP
66057: POP
66058: GO 66143
// end ;
66060: GO 65731
66062: POP
66063: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66064: LD_VAR 0 9
66068: PPUSH
66069: LD_VAR 0 3
66073: PPUSH
66074: LD_VAR 0 4
66078: PPUSH
66079: LD_INT 20
66081: PPUSH
66082: CALL 58089 0 4
66086: PUSH
66087: LD_INT 4
66089: ARRAY
66090: IFFALSE 66094
// exit ;
66092: GO 66143
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
66094: LD_VAR 0 2
66098: PUSH
66099: LD_INT 29
66101: PUSH
66102: LD_INT 30
66104: PUSH
66105: EMPTY
66106: LIST
66107: LIST
66108: IN
66109: PUSH
66110: LD_VAR 0 3
66114: PPUSH
66115: LD_VAR 0 4
66119: PPUSH
66120: LD_VAR 0 9
66124: PPUSH
66125: CALL_OW 440
66129: NOT
66130: AND
66131: IFFALSE 66135
// exit ;
66133: GO 66143
// result := true ;
66135: LD_ADDR_VAR 0 6
66139: PUSH
66140: LD_INT 1
66142: ST_TO_ADDR
// end ;
66143: LD_VAR 0 6
66147: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
66148: LD_INT 0
66150: PPUSH
66151: PPUSH
66152: PPUSH
66153: PPUSH
66154: PPUSH
66155: PPUSH
66156: PPUSH
66157: PPUSH
66158: PPUSH
66159: PPUSH
66160: PPUSH
66161: PPUSH
66162: PPUSH
66163: PPUSH
66164: PPUSH
66165: PPUSH
66166: PPUSH
66167: PPUSH
66168: PPUSH
66169: PPUSH
66170: PPUSH
66171: PPUSH
66172: PPUSH
66173: PPUSH
66174: PPUSH
66175: PPUSH
66176: PPUSH
66177: PPUSH
66178: PPUSH
66179: PPUSH
66180: PPUSH
66181: PPUSH
66182: PPUSH
66183: PPUSH
66184: PPUSH
66185: PPUSH
66186: PPUSH
66187: PPUSH
66188: PPUSH
66189: PPUSH
66190: PPUSH
66191: PPUSH
66192: PPUSH
66193: PPUSH
66194: PPUSH
66195: PPUSH
66196: PPUSH
66197: PPUSH
66198: PPUSH
66199: PPUSH
66200: PPUSH
66201: PPUSH
66202: PPUSH
66203: PPUSH
66204: PPUSH
66205: PPUSH
66206: PPUSH
66207: PPUSH
// result = [ ] ;
66208: LD_ADDR_VAR 0 7
66212: PUSH
66213: EMPTY
66214: ST_TO_ADDR
// temp_list = [ ] ;
66215: LD_ADDR_VAR 0 9
66219: PUSH
66220: EMPTY
66221: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66222: LD_VAR 0 4
66226: PUSH
66227: LD_INT 0
66229: PUSH
66230: LD_INT 1
66232: PUSH
66233: LD_INT 2
66235: PUSH
66236: LD_INT 3
66238: PUSH
66239: LD_INT 4
66241: PUSH
66242: LD_INT 5
66244: PUSH
66245: EMPTY
66246: LIST
66247: LIST
66248: LIST
66249: LIST
66250: LIST
66251: LIST
66252: IN
66253: NOT
66254: PUSH
66255: LD_VAR 0 1
66259: PUSH
66260: LD_INT 0
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: IN
66270: PUSH
66271: LD_VAR 0 5
66275: PUSH
66276: LD_INT 1
66278: PUSH
66279: LD_INT 2
66281: PUSH
66282: LD_INT 3
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: LIST
66289: IN
66290: NOT
66291: AND
66292: OR
66293: IFFALSE 66297
// exit ;
66295: GO 84688
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66297: LD_VAR 0 1
66301: PUSH
66302: LD_INT 6
66304: PUSH
66305: LD_INT 7
66307: PUSH
66308: LD_INT 8
66310: PUSH
66311: LD_INT 13
66313: PUSH
66314: LD_INT 12
66316: PUSH
66317: LD_INT 15
66319: PUSH
66320: LD_INT 11
66322: PUSH
66323: LD_INT 14
66325: PUSH
66326: LD_INT 10
66328: PUSH
66329: EMPTY
66330: LIST
66331: LIST
66332: LIST
66333: LIST
66334: LIST
66335: LIST
66336: LIST
66337: LIST
66338: LIST
66339: IN
66340: IFFALSE 66350
// btype = b_lab ;
66342: LD_ADDR_VAR 0 1
66346: PUSH
66347: LD_INT 6
66349: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66350: LD_VAR 0 6
66354: PUSH
66355: LD_INT 0
66357: PUSH
66358: LD_INT 1
66360: PUSH
66361: LD_INT 2
66363: PUSH
66364: EMPTY
66365: LIST
66366: LIST
66367: LIST
66368: IN
66369: NOT
66370: PUSH
66371: LD_VAR 0 1
66375: PUSH
66376: LD_INT 0
66378: PUSH
66379: LD_INT 1
66381: PUSH
66382: LD_INT 2
66384: PUSH
66385: LD_INT 3
66387: PUSH
66388: LD_INT 6
66390: PUSH
66391: LD_INT 36
66393: PUSH
66394: LD_INT 4
66396: PUSH
66397: LD_INT 5
66399: PUSH
66400: LD_INT 31
66402: PUSH
66403: LD_INT 32
66405: PUSH
66406: LD_INT 33
66408: PUSH
66409: EMPTY
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: LIST
66419: LIST
66420: LIST
66421: IN
66422: NOT
66423: PUSH
66424: LD_VAR 0 6
66428: PUSH
66429: LD_INT 1
66431: EQUAL
66432: AND
66433: OR
66434: PUSH
66435: LD_VAR 0 1
66439: PUSH
66440: LD_INT 2
66442: PUSH
66443: LD_INT 3
66445: PUSH
66446: EMPTY
66447: LIST
66448: LIST
66449: IN
66450: NOT
66451: PUSH
66452: LD_VAR 0 6
66456: PUSH
66457: LD_INT 2
66459: EQUAL
66460: AND
66461: OR
66462: IFFALSE 66472
// mode = 0 ;
66464: LD_ADDR_VAR 0 6
66468: PUSH
66469: LD_INT 0
66471: ST_TO_ADDR
// case mode of 0 :
66472: LD_VAR 0 6
66476: PUSH
66477: LD_INT 0
66479: DOUBLE
66480: EQUAL
66481: IFTRUE 66485
66483: GO 77938
66485: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66486: LD_ADDR_VAR 0 11
66490: PUSH
66491: LD_INT 0
66493: PUSH
66494: LD_INT 0
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: LD_INT 0
66503: PUSH
66504: LD_INT 1
66506: NEG
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: LD_INT 1
66514: PUSH
66515: LD_INT 0
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 1
66524: PUSH
66525: LD_INT 1
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 0
66534: PUSH
66535: LD_INT 1
66537: PUSH
66538: EMPTY
66539: LIST
66540: LIST
66541: PUSH
66542: LD_INT 1
66544: NEG
66545: PUSH
66546: LD_INT 0
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PUSH
66553: LD_INT 1
66555: NEG
66556: PUSH
66557: LD_INT 1
66559: NEG
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 1
66567: NEG
66568: PUSH
66569: LD_INT 2
66571: NEG
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 0
66579: PUSH
66580: LD_INT 2
66582: NEG
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: PUSH
66588: LD_INT 1
66590: PUSH
66591: LD_INT 1
66593: NEG
66594: PUSH
66595: EMPTY
66596: LIST
66597: LIST
66598: PUSH
66599: LD_INT 1
66601: PUSH
66602: LD_INT 2
66604: PUSH
66605: EMPTY
66606: LIST
66607: LIST
66608: PUSH
66609: LD_INT 0
66611: PUSH
66612: LD_INT 2
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: PUSH
66619: LD_INT 1
66621: NEG
66622: PUSH
66623: LD_INT 1
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 1
66632: PUSH
66633: LD_INT 3
66635: PUSH
66636: EMPTY
66637: LIST
66638: LIST
66639: PUSH
66640: LD_INT 0
66642: PUSH
66643: LD_INT 3
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: PUSH
66650: LD_INT 1
66652: NEG
66653: PUSH
66654: LD_INT 2
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: LIST
66671: LIST
66672: LIST
66673: LIST
66674: LIST
66675: LIST
66676: LIST
66677: LIST
66678: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66679: LD_ADDR_VAR 0 12
66683: PUSH
66684: LD_INT 0
66686: PUSH
66687: LD_INT 0
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: PUSH
66694: LD_INT 0
66696: PUSH
66697: LD_INT 1
66699: NEG
66700: PUSH
66701: EMPTY
66702: LIST
66703: LIST
66704: PUSH
66705: LD_INT 1
66707: PUSH
66708: LD_INT 0
66710: PUSH
66711: EMPTY
66712: LIST
66713: LIST
66714: PUSH
66715: LD_INT 1
66717: PUSH
66718: LD_INT 1
66720: PUSH
66721: EMPTY
66722: LIST
66723: LIST
66724: PUSH
66725: LD_INT 0
66727: PUSH
66728: LD_INT 1
66730: PUSH
66731: EMPTY
66732: LIST
66733: LIST
66734: PUSH
66735: LD_INT 1
66737: NEG
66738: PUSH
66739: LD_INT 0
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: PUSH
66746: LD_INT 1
66748: NEG
66749: PUSH
66750: LD_INT 1
66752: NEG
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 1
66760: PUSH
66761: LD_INT 1
66763: NEG
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 2
66771: PUSH
66772: LD_INT 0
66774: PUSH
66775: EMPTY
66776: LIST
66777: LIST
66778: PUSH
66779: LD_INT 2
66781: PUSH
66782: LD_INT 1
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: PUSH
66789: LD_INT 1
66791: NEG
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 2
66802: NEG
66803: PUSH
66804: LD_INT 0
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: LD_INT 2
66813: NEG
66814: PUSH
66815: LD_INT 1
66817: NEG
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 2
66825: NEG
66826: PUSH
66827: LD_INT 1
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: LD_INT 3
66836: NEG
66837: PUSH
66838: LD_INT 0
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 3
66847: NEG
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: LIST
66861: LIST
66862: LIST
66863: LIST
66864: LIST
66865: LIST
66866: LIST
66867: LIST
66868: LIST
66869: LIST
66870: LIST
66871: LIST
66872: LIST
66873: LIST
66874: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66875: LD_ADDR_VAR 0 13
66879: PUSH
66880: LD_INT 0
66882: PUSH
66883: LD_INT 0
66885: PUSH
66886: EMPTY
66887: LIST
66888: LIST
66889: PUSH
66890: LD_INT 0
66892: PUSH
66893: LD_INT 1
66895: NEG
66896: PUSH
66897: EMPTY
66898: LIST
66899: LIST
66900: PUSH
66901: LD_INT 1
66903: PUSH
66904: LD_INT 0
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: LD_INT 1
66913: PUSH
66914: LD_INT 1
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: PUSH
66921: LD_INT 0
66923: PUSH
66924: LD_INT 1
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PUSH
66931: LD_INT 1
66933: NEG
66934: PUSH
66935: LD_INT 0
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: PUSH
66942: LD_INT 1
66944: NEG
66945: PUSH
66946: LD_INT 1
66948: NEG
66949: PUSH
66950: EMPTY
66951: LIST
66952: LIST
66953: PUSH
66954: LD_INT 1
66956: NEG
66957: PUSH
66958: LD_INT 2
66960: NEG
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: PUSH
66966: LD_INT 2
66968: PUSH
66969: LD_INT 1
66971: PUSH
66972: EMPTY
66973: LIST
66974: LIST
66975: PUSH
66976: LD_INT 2
66978: PUSH
66979: LD_INT 2
66981: PUSH
66982: EMPTY
66983: LIST
66984: LIST
66985: PUSH
66986: LD_INT 1
66988: PUSH
66989: LD_INT 2
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: PUSH
66996: LD_INT 2
66998: NEG
66999: PUSH
67000: LD_INT 1
67002: NEG
67003: PUSH
67004: EMPTY
67005: LIST
67006: LIST
67007: PUSH
67008: LD_INT 2
67010: NEG
67011: PUSH
67012: LD_INT 2
67014: NEG
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PUSH
67020: LD_INT 2
67022: NEG
67023: PUSH
67024: LD_INT 3
67026: NEG
67027: PUSH
67028: EMPTY
67029: LIST
67030: LIST
67031: PUSH
67032: LD_INT 3
67034: NEG
67035: PUSH
67036: LD_INT 2
67038: NEG
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PUSH
67044: LD_INT 3
67046: NEG
67047: PUSH
67048: LD_INT 3
67050: NEG
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67074: LD_ADDR_VAR 0 14
67078: PUSH
67079: LD_INT 0
67081: PUSH
67082: LD_INT 0
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PUSH
67089: LD_INT 0
67091: PUSH
67092: LD_INT 1
67094: NEG
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 1
67102: PUSH
67103: LD_INT 0
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 1
67112: PUSH
67113: LD_INT 1
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 0
67122: PUSH
67123: LD_INT 1
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 1
67132: NEG
67133: PUSH
67134: LD_INT 0
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 1
67143: NEG
67144: PUSH
67145: LD_INT 1
67147: NEG
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: PUSH
67153: LD_INT 1
67155: NEG
67156: PUSH
67157: LD_INT 2
67159: NEG
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: LD_INT 0
67167: PUSH
67168: LD_INT 2
67170: NEG
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: LD_INT 1
67178: PUSH
67179: LD_INT 1
67181: NEG
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: LD_INT 1
67189: PUSH
67190: LD_INT 2
67192: PUSH
67193: EMPTY
67194: LIST
67195: LIST
67196: PUSH
67197: LD_INT 0
67199: PUSH
67200: LD_INT 2
67202: PUSH
67203: EMPTY
67204: LIST
67205: LIST
67206: PUSH
67207: LD_INT 1
67209: NEG
67210: PUSH
67211: LD_INT 1
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: PUSH
67218: LD_INT 1
67220: NEG
67221: PUSH
67222: LD_INT 3
67224: NEG
67225: PUSH
67226: EMPTY
67227: LIST
67228: LIST
67229: PUSH
67230: LD_INT 0
67232: PUSH
67233: LD_INT 3
67235: NEG
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 1
67243: PUSH
67244: LD_INT 2
67246: NEG
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: EMPTY
67253: LIST
67254: LIST
67255: LIST
67256: LIST
67257: LIST
67258: LIST
67259: LIST
67260: LIST
67261: LIST
67262: LIST
67263: LIST
67264: LIST
67265: LIST
67266: LIST
67267: LIST
67268: LIST
67269: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67270: LD_ADDR_VAR 0 15
67274: PUSH
67275: LD_INT 0
67277: PUSH
67278: LD_INT 0
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: LD_INT 0
67287: PUSH
67288: LD_INT 1
67290: NEG
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 1
67298: PUSH
67299: LD_INT 0
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: LD_INT 1
67308: PUSH
67309: LD_INT 1
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 0
67318: PUSH
67319: LD_INT 1
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 1
67328: NEG
67329: PUSH
67330: LD_INT 0
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: PUSH
67337: LD_INT 1
67339: NEG
67340: PUSH
67341: LD_INT 1
67343: NEG
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 1
67351: PUSH
67352: LD_INT 1
67354: NEG
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 2
67362: PUSH
67363: LD_INT 0
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 2
67372: PUSH
67373: LD_INT 1
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: LD_INT 1
67382: NEG
67383: PUSH
67384: LD_INT 1
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 2
67393: NEG
67394: PUSH
67395: LD_INT 0
67397: PUSH
67398: EMPTY
67399: LIST
67400: LIST
67401: PUSH
67402: LD_INT 2
67404: NEG
67405: PUSH
67406: LD_INT 1
67408: NEG
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: LD_INT 2
67416: PUSH
67417: LD_INT 1
67419: NEG
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: PUSH
67425: LD_INT 3
67427: PUSH
67428: LD_INT 0
67430: PUSH
67431: EMPTY
67432: LIST
67433: LIST
67434: PUSH
67435: LD_INT 3
67437: PUSH
67438: LD_INT 1
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67463: LD_ADDR_VAR 0 16
67467: PUSH
67468: LD_INT 0
67470: PUSH
67471: LD_INT 0
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: PUSH
67478: LD_INT 0
67480: PUSH
67481: LD_INT 1
67483: NEG
67484: PUSH
67485: EMPTY
67486: LIST
67487: LIST
67488: PUSH
67489: LD_INT 1
67491: PUSH
67492: LD_INT 0
67494: PUSH
67495: EMPTY
67496: LIST
67497: LIST
67498: PUSH
67499: LD_INT 1
67501: PUSH
67502: LD_INT 1
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: PUSH
67509: LD_INT 0
67511: PUSH
67512: LD_INT 1
67514: PUSH
67515: EMPTY
67516: LIST
67517: LIST
67518: PUSH
67519: LD_INT 1
67521: NEG
67522: PUSH
67523: LD_INT 0
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 1
67532: NEG
67533: PUSH
67534: LD_INT 1
67536: NEG
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PUSH
67542: LD_INT 1
67544: NEG
67545: PUSH
67546: LD_INT 2
67548: NEG
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 2
67556: PUSH
67557: LD_INT 1
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 2
67566: PUSH
67567: LD_INT 2
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: PUSH
67574: LD_INT 1
67576: PUSH
67577: LD_INT 2
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 2
67586: NEG
67587: PUSH
67588: LD_INT 1
67590: NEG
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: LD_INT 2
67598: NEG
67599: PUSH
67600: LD_INT 2
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 3
67610: PUSH
67611: LD_INT 2
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 3
67620: PUSH
67621: LD_INT 3
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 2
67630: PUSH
67631: LD_INT 3
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67656: LD_ADDR_VAR 0 17
67660: PUSH
67661: LD_INT 0
67663: PUSH
67664: LD_INT 0
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 0
67673: PUSH
67674: LD_INT 1
67676: NEG
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 1
67684: PUSH
67685: LD_INT 0
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 1
67694: PUSH
67695: LD_INT 1
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 0
67704: PUSH
67705: LD_INT 1
67707: PUSH
67708: EMPTY
67709: LIST
67710: LIST
67711: PUSH
67712: LD_INT 1
67714: NEG
67715: PUSH
67716: LD_INT 0
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 1
67725: NEG
67726: PUSH
67727: LD_INT 1
67729: NEG
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 1
67737: NEG
67738: PUSH
67739: LD_INT 2
67741: NEG
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: LD_INT 2
67752: NEG
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PUSH
67758: LD_INT 1
67760: PUSH
67761: LD_INT 1
67763: NEG
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: PUSH
67769: LD_INT 2
67771: PUSH
67772: LD_INT 0
67774: PUSH
67775: EMPTY
67776: LIST
67777: LIST
67778: PUSH
67779: LD_INT 2
67781: PUSH
67782: LD_INT 1
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 2
67791: PUSH
67792: LD_INT 2
67794: PUSH
67795: EMPTY
67796: LIST
67797: LIST
67798: PUSH
67799: LD_INT 1
67801: PUSH
67802: LD_INT 2
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: PUSH
67809: LD_INT 0
67811: PUSH
67812: LD_INT 2
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 1
67821: NEG
67822: PUSH
67823: LD_INT 1
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: LD_INT 2
67832: NEG
67833: PUSH
67834: LD_INT 0
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: PUSH
67841: LD_INT 2
67843: NEG
67844: PUSH
67845: LD_INT 1
67847: NEG
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 2
67855: NEG
67856: PUSH
67857: LD_INT 2
67859: NEG
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: LIST
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67886: LD_ADDR_VAR 0 18
67890: PUSH
67891: LD_INT 0
67893: PUSH
67894: LD_INT 0
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: LD_INT 0
67903: PUSH
67904: LD_INT 1
67906: NEG
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: PUSH
67912: LD_INT 1
67914: PUSH
67915: LD_INT 0
67917: PUSH
67918: EMPTY
67919: LIST
67920: LIST
67921: PUSH
67922: LD_INT 1
67924: PUSH
67925: LD_INT 1
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: PUSH
67932: LD_INT 0
67934: PUSH
67935: LD_INT 1
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: LD_INT 1
67944: NEG
67945: PUSH
67946: LD_INT 0
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 1
67955: NEG
67956: PUSH
67957: LD_INT 1
67959: NEG
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: PUSH
67965: LD_INT 1
67967: NEG
67968: PUSH
67969: LD_INT 2
67971: NEG
67972: PUSH
67973: EMPTY
67974: LIST
67975: LIST
67976: PUSH
67977: LD_INT 0
67979: PUSH
67980: LD_INT 2
67982: NEG
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 1
67990: PUSH
67991: LD_INT 1
67993: NEG
67994: PUSH
67995: EMPTY
67996: LIST
67997: LIST
67998: PUSH
67999: LD_INT 2
68001: PUSH
68002: LD_INT 0
68004: PUSH
68005: EMPTY
68006: LIST
68007: LIST
68008: PUSH
68009: LD_INT 2
68011: PUSH
68012: LD_INT 1
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: LD_INT 2
68021: PUSH
68022: LD_INT 2
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 1
68031: PUSH
68032: LD_INT 2
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: LD_INT 0
68041: PUSH
68042: LD_INT 2
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: PUSH
68049: LD_INT 1
68051: NEG
68052: PUSH
68053: LD_INT 1
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: LD_INT 2
68062: NEG
68063: PUSH
68064: LD_INT 0
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 2
68073: NEG
68074: PUSH
68075: LD_INT 1
68077: NEG
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 2
68085: NEG
68086: PUSH
68087: LD_INT 2
68089: NEG
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: EMPTY
68096: LIST
68097: LIST
68098: LIST
68099: LIST
68100: LIST
68101: LIST
68102: LIST
68103: LIST
68104: LIST
68105: LIST
68106: LIST
68107: LIST
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68116: LD_ADDR_VAR 0 19
68120: PUSH
68121: LD_INT 0
68123: PUSH
68124: LD_INT 0
68126: PUSH
68127: EMPTY
68128: LIST
68129: LIST
68130: PUSH
68131: LD_INT 0
68133: PUSH
68134: LD_INT 1
68136: NEG
68137: PUSH
68138: EMPTY
68139: LIST
68140: LIST
68141: PUSH
68142: LD_INT 1
68144: PUSH
68145: LD_INT 0
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PUSH
68152: LD_INT 1
68154: PUSH
68155: LD_INT 1
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: LD_INT 0
68164: PUSH
68165: LD_INT 1
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: LD_INT 1
68174: NEG
68175: PUSH
68176: LD_INT 0
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 1
68185: NEG
68186: PUSH
68187: LD_INT 1
68189: NEG
68190: PUSH
68191: EMPTY
68192: LIST
68193: LIST
68194: PUSH
68195: LD_INT 1
68197: NEG
68198: PUSH
68199: LD_INT 2
68201: NEG
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 0
68209: PUSH
68210: LD_INT 2
68212: NEG
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 1
68220: PUSH
68221: LD_INT 1
68223: NEG
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 2
68231: PUSH
68232: LD_INT 0
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 2
68241: PUSH
68242: LD_INT 1
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 2
68251: PUSH
68252: LD_INT 2
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: LD_INT 1
68261: PUSH
68262: LD_INT 2
68264: PUSH
68265: EMPTY
68266: LIST
68267: LIST
68268: PUSH
68269: LD_INT 0
68271: PUSH
68272: LD_INT 2
68274: PUSH
68275: EMPTY
68276: LIST
68277: LIST
68278: PUSH
68279: LD_INT 1
68281: NEG
68282: PUSH
68283: LD_INT 1
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 2
68292: NEG
68293: PUSH
68294: LD_INT 0
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 2
68303: NEG
68304: PUSH
68305: LD_INT 1
68307: NEG
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: LD_INT 2
68315: NEG
68316: PUSH
68317: LD_INT 2
68319: NEG
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: LIST
68335: LIST
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68346: LD_ADDR_VAR 0 20
68350: PUSH
68351: LD_INT 0
68353: PUSH
68354: LD_INT 0
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 0
68363: PUSH
68364: LD_INT 1
68366: NEG
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PUSH
68372: LD_INT 1
68374: PUSH
68375: LD_INT 0
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: LD_INT 1
68384: PUSH
68385: LD_INT 1
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PUSH
68392: LD_INT 0
68394: PUSH
68395: LD_INT 1
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: LD_INT 1
68404: NEG
68405: PUSH
68406: LD_INT 0
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 1
68415: NEG
68416: PUSH
68417: LD_INT 1
68419: NEG
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PUSH
68425: LD_INT 1
68427: NEG
68428: PUSH
68429: LD_INT 2
68431: NEG
68432: PUSH
68433: EMPTY
68434: LIST
68435: LIST
68436: PUSH
68437: LD_INT 0
68439: PUSH
68440: LD_INT 2
68442: NEG
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 1
68450: PUSH
68451: LD_INT 1
68453: NEG
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 2
68461: PUSH
68462: LD_INT 0
68464: PUSH
68465: EMPTY
68466: LIST
68467: LIST
68468: PUSH
68469: LD_INT 2
68471: PUSH
68472: LD_INT 1
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PUSH
68479: LD_INT 2
68481: PUSH
68482: LD_INT 2
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PUSH
68489: LD_INT 1
68491: PUSH
68492: LD_INT 2
68494: PUSH
68495: EMPTY
68496: LIST
68497: LIST
68498: PUSH
68499: LD_INT 0
68501: PUSH
68502: LD_INT 2
68504: PUSH
68505: EMPTY
68506: LIST
68507: LIST
68508: PUSH
68509: LD_INT 1
68511: NEG
68512: PUSH
68513: LD_INT 1
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: LD_INT 2
68522: NEG
68523: PUSH
68524: LD_INT 0
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 2
68533: NEG
68534: PUSH
68535: LD_INT 1
68537: NEG
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: LD_INT 2
68545: NEG
68546: PUSH
68547: LD_INT 2
68549: NEG
68550: PUSH
68551: EMPTY
68552: LIST
68553: LIST
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: LIST
68574: LIST
68575: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68576: LD_ADDR_VAR 0 21
68580: PUSH
68581: LD_INT 0
68583: PUSH
68584: LD_INT 0
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 0
68593: PUSH
68594: LD_INT 1
68596: NEG
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 1
68604: PUSH
68605: LD_INT 0
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PUSH
68612: LD_INT 1
68614: PUSH
68615: LD_INT 1
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: PUSH
68622: LD_INT 0
68624: PUSH
68625: LD_INT 1
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PUSH
68632: LD_INT 1
68634: NEG
68635: PUSH
68636: LD_INT 0
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 1
68645: NEG
68646: PUSH
68647: LD_INT 1
68649: NEG
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 1
68657: NEG
68658: PUSH
68659: LD_INT 2
68661: NEG
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: PUSH
68667: LD_INT 0
68669: PUSH
68670: LD_INT 2
68672: NEG
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 1
68680: PUSH
68681: LD_INT 1
68683: NEG
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 2
68691: PUSH
68692: LD_INT 0
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: LD_INT 2
68701: PUSH
68702: LD_INT 1
68704: PUSH
68705: EMPTY
68706: LIST
68707: LIST
68708: PUSH
68709: LD_INT 2
68711: PUSH
68712: LD_INT 2
68714: PUSH
68715: EMPTY
68716: LIST
68717: LIST
68718: PUSH
68719: LD_INT 1
68721: PUSH
68722: LD_INT 2
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PUSH
68729: LD_INT 0
68731: PUSH
68732: LD_INT 2
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 1
68741: NEG
68742: PUSH
68743: LD_INT 1
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 2
68752: NEG
68753: PUSH
68754: LD_INT 0
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: PUSH
68761: LD_INT 2
68763: NEG
68764: PUSH
68765: LD_INT 1
68767: NEG
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 2
68775: NEG
68776: PUSH
68777: LD_INT 2
68779: NEG
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: LIST
68789: LIST
68790: LIST
68791: LIST
68792: LIST
68793: LIST
68794: LIST
68795: LIST
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: LIST
68804: LIST
68805: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68806: LD_ADDR_VAR 0 22
68810: PUSH
68811: LD_INT 0
68813: PUSH
68814: LD_INT 0
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 0
68823: PUSH
68824: LD_INT 1
68826: NEG
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PUSH
68832: LD_INT 1
68834: PUSH
68835: LD_INT 0
68837: PUSH
68838: EMPTY
68839: LIST
68840: LIST
68841: PUSH
68842: LD_INT 1
68844: PUSH
68845: LD_INT 1
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 0
68854: PUSH
68855: LD_INT 1
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: LD_INT 1
68864: NEG
68865: PUSH
68866: LD_INT 0
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 1
68875: NEG
68876: PUSH
68877: LD_INT 1
68879: NEG
68880: PUSH
68881: EMPTY
68882: LIST
68883: LIST
68884: PUSH
68885: LD_INT 1
68887: NEG
68888: PUSH
68889: LD_INT 2
68891: NEG
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: LD_INT 0
68899: PUSH
68900: LD_INT 2
68902: NEG
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 1
68910: PUSH
68911: LD_INT 1
68913: NEG
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 2
68921: PUSH
68922: LD_INT 0
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: LD_INT 2
68931: PUSH
68932: LD_INT 1
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 2
68941: PUSH
68942: LD_INT 2
68944: PUSH
68945: EMPTY
68946: LIST
68947: LIST
68948: PUSH
68949: LD_INT 1
68951: PUSH
68952: LD_INT 2
68954: PUSH
68955: EMPTY
68956: LIST
68957: LIST
68958: PUSH
68959: LD_INT 0
68961: PUSH
68962: LD_INT 2
68964: PUSH
68965: EMPTY
68966: LIST
68967: LIST
68968: PUSH
68969: LD_INT 1
68971: NEG
68972: PUSH
68973: LD_INT 1
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 2
68982: NEG
68983: PUSH
68984: LD_INT 0
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 2
68993: NEG
68994: PUSH
68995: LD_INT 1
68997: NEG
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 2
69005: NEG
69006: PUSH
69007: LD_INT 2
69009: NEG
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: LIST
69028: LIST
69029: LIST
69030: LIST
69031: LIST
69032: LIST
69033: LIST
69034: LIST
69035: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69036: LD_ADDR_VAR 0 23
69040: PUSH
69041: LD_INT 0
69043: PUSH
69044: LD_INT 0
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 0
69053: PUSH
69054: LD_INT 1
69056: NEG
69057: PUSH
69058: EMPTY
69059: LIST
69060: LIST
69061: PUSH
69062: LD_INT 1
69064: PUSH
69065: LD_INT 0
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 1
69074: PUSH
69075: LD_INT 1
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: LD_INT 0
69084: PUSH
69085: LD_INT 1
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 1
69094: NEG
69095: PUSH
69096: LD_INT 0
69098: PUSH
69099: EMPTY
69100: LIST
69101: LIST
69102: PUSH
69103: LD_INT 1
69105: NEG
69106: PUSH
69107: LD_INT 1
69109: NEG
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 1
69117: NEG
69118: PUSH
69119: LD_INT 2
69121: NEG
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: PUSH
69127: LD_INT 0
69129: PUSH
69130: LD_INT 2
69132: NEG
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 1
69140: PUSH
69141: LD_INT 1
69143: NEG
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 2
69151: PUSH
69152: LD_INT 0
69154: PUSH
69155: EMPTY
69156: LIST
69157: LIST
69158: PUSH
69159: LD_INT 2
69161: PUSH
69162: LD_INT 1
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 2
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: LD_INT 1
69181: PUSH
69182: LD_INT 2
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: PUSH
69189: LD_INT 0
69191: PUSH
69192: LD_INT 2
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: PUSH
69199: LD_INT 1
69201: NEG
69202: PUSH
69203: LD_INT 1
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: PUSH
69210: LD_INT 2
69212: NEG
69213: PUSH
69214: LD_INT 0
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: LD_INT 2
69223: NEG
69224: PUSH
69225: LD_INT 1
69227: NEG
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: LD_INT 2
69235: NEG
69236: PUSH
69237: LD_INT 2
69239: NEG
69240: PUSH
69241: EMPTY
69242: LIST
69243: LIST
69244: PUSH
69245: LD_INT 2
69247: NEG
69248: PUSH
69249: LD_INT 3
69251: NEG
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 1
69259: NEG
69260: PUSH
69261: LD_INT 3
69263: NEG
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PUSH
69269: LD_INT 1
69271: PUSH
69272: LD_INT 2
69274: NEG
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 2
69282: PUSH
69283: LD_INT 1
69285: NEG
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: LIST
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: LIST
69315: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69316: LD_ADDR_VAR 0 24
69320: PUSH
69321: LD_INT 0
69323: PUSH
69324: LD_INT 0
69326: PUSH
69327: EMPTY
69328: LIST
69329: LIST
69330: PUSH
69331: LD_INT 0
69333: PUSH
69334: LD_INT 1
69336: NEG
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PUSH
69342: LD_INT 1
69344: PUSH
69345: LD_INT 0
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: PUSH
69352: LD_INT 1
69354: PUSH
69355: LD_INT 1
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: PUSH
69362: LD_INT 0
69364: PUSH
69365: LD_INT 1
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: PUSH
69372: LD_INT 1
69374: NEG
69375: PUSH
69376: LD_INT 0
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 1
69385: NEG
69386: PUSH
69387: LD_INT 1
69389: NEG
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 1
69397: NEG
69398: PUSH
69399: LD_INT 2
69401: NEG
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 0
69409: PUSH
69410: LD_INT 2
69412: NEG
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 1
69420: PUSH
69421: LD_INT 1
69423: NEG
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 2
69431: PUSH
69432: LD_INT 0
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PUSH
69439: LD_INT 2
69441: PUSH
69442: LD_INT 1
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 2
69451: PUSH
69452: LD_INT 2
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 1
69461: PUSH
69462: LD_INT 2
69464: PUSH
69465: EMPTY
69466: LIST
69467: LIST
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: LD_INT 2
69474: PUSH
69475: EMPTY
69476: LIST
69477: LIST
69478: PUSH
69479: LD_INT 1
69481: NEG
69482: PUSH
69483: LD_INT 1
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 2
69492: NEG
69493: PUSH
69494: LD_INT 0
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 2
69503: NEG
69504: PUSH
69505: LD_INT 1
69507: NEG
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 2
69515: NEG
69516: PUSH
69517: LD_INT 2
69519: NEG
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: LD_INT 1
69527: PUSH
69528: LD_INT 2
69530: NEG
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 2
69538: PUSH
69539: LD_INT 1
69541: NEG
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: LD_INT 3
69549: PUSH
69550: LD_INT 1
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: LD_INT 3
69559: PUSH
69560: LD_INT 2
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: LIST
69574: LIST
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69592: LD_ADDR_VAR 0 25
69596: PUSH
69597: LD_INT 0
69599: PUSH
69600: LD_INT 0
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 0
69609: PUSH
69610: LD_INT 1
69612: NEG
69613: PUSH
69614: EMPTY
69615: LIST
69616: LIST
69617: PUSH
69618: LD_INT 1
69620: PUSH
69621: LD_INT 0
69623: PUSH
69624: EMPTY
69625: LIST
69626: LIST
69627: PUSH
69628: LD_INT 1
69630: PUSH
69631: LD_INT 1
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: PUSH
69638: LD_INT 0
69640: PUSH
69641: LD_INT 1
69643: PUSH
69644: EMPTY
69645: LIST
69646: LIST
69647: PUSH
69648: LD_INT 1
69650: NEG
69651: PUSH
69652: LD_INT 0
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: PUSH
69659: LD_INT 1
69661: NEG
69662: PUSH
69663: LD_INT 1
69665: NEG
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 1
69673: NEG
69674: PUSH
69675: LD_INT 2
69677: NEG
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: LD_INT 0
69685: PUSH
69686: LD_INT 2
69688: NEG
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: LD_INT 1
69696: PUSH
69697: LD_INT 1
69699: NEG
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 2
69707: PUSH
69708: LD_INT 0
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: LD_INT 2
69717: PUSH
69718: LD_INT 1
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: LD_INT 2
69727: PUSH
69728: LD_INT 2
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: LD_INT 1
69737: PUSH
69738: LD_INT 2
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: PUSH
69745: LD_INT 0
69747: PUSH
69748: LD_INT 2
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: PUSH
69755: LD_INT 1
69757: NEG
69758: PUSH
69759: LD_INT 1
69761: PUSH
69762: EMPTY
69763: LIST
69764: LIST
69765: PUSH
69766: LD_INT 2
69768: NEG
69769: PUSH
69770: LD_INT 0
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 2
69779: NEG
69780: PUSH
69781: LD_INT 1
69783: NEG
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: PUSH
69789: LD_INT 2
69791: NEG
69792: PUSH
69793: LD_INT 2
69795: NEG
69796: PUSH
69797: EMPTY
69798: LIST
69799: LIST
69800: PUSH
69801: LD_INT 3
69803: PUSH
69804: LD_INT 1
69806: PUSH
69807: EMPTY
69808: LIST
69809: LIST
69810: PUSH
69811: LD_INT 3
69813: PUSH
69814: LD_INT 2
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 2
69823: PUSH
69824: LD_INT 3
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: PUSH
69831: LD_INT 1
69833: PUSH
69834: LD_INT 3
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69866: LD_ADDR_VAR 0 26
69870: PUSH
69871: LD_INT 0
69873: PUSH
69874: LD_INT 0
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: LD_INT 0
69883: PUSH
69884: LD_INT 1
69886: NEG
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: PUSH
69892: LD_INT 1
69894: PUSH
69895: LD_INT 0
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 1
69904: PUSH
69905: LD_INT 1
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 0
69914: PUSH
69915: LD_INT 1
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 1
69924: NEG
69925: PUSH
69926: LD_INT 0
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 1
69935: NEG
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 1
69947: NEG
69948: PUSH
69949: LD_INT 2
69951: NEG
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: LD_INT 0
69959: PUSH
69960: LD_INT 2
69962: NEG
69963: PUSH
69964: EMPTY
69965: LIST
69966: LIST
69967: PUSH
69968: LD_INT 1
69970: PUSH
69971: LD_INT 1
69973: NEG
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 2
69981: PUSH
69982: LD_INT 0
69984: PUSH
69985: EMPTY
69986: LIST
69987: LIST
69988: PUSH
69989: LD_INT 2
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 2
70001: PUSH
70002: LD_INT 2
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: LD_INT 1
70011: PUSH
70012: LD_INT 2
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: PUSH
70019: LD_INT 0
70021: PUSH
70022: LD_INT 2
70024: PUSH
70025: EMPTY
70026: LIST
70027: LIST
70028: PUSH
70029: LD_INT 1
70031: NEG
70032: PUSH
70033: LD_INT 1
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 2
70042: NEG
70043: PUSH
70044: LD_INT 0
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 2
70053: NEG
70054: PUSH
70055: LD_INT 1
70057: NEG
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: PUSH
70063: LD_INT 2
70065: NEG
70066: PUSH
70067: LD_INT 2
70069: NEG
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 2
70077: PUSH
70078: LD_INT 3
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PUSH
70085: LD_INT 1
70087: PUSH
70088: LD_INT 3
70090: PUSH
70091: EMPTY
70092: LIST
70093: LIST
70094: PUSH
70095: LD_INT 1
70097: NEG
70098: PUSH
70099: LD_INT 2
70101: PUSH
70102: EMPTY
70103: LIST
70104: LIST
70105: PUSH
70106: LD_INT 2
70108: NEG
70109: PUSH
70110: LD_INT 1
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: LIST
70121: LIST
70122: LIST
70123: LIST
70124: LIST
70125: LIST
70126: LIST
70127: LIST
70128: LIST
70129: LIST
70130: LIST
70131: LIST
70132: LIST
70133: LIST
70134: LIST
70135: LIST
70136: LIST
70137: LIST
70138: LIST
70139: LIST
70140: LIST
70141: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70142: LD_ADDR_VAR 0 27
70146: PUSH
70147: LD_INT 0
70149: PUSH
70150: LD_INT 0
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 0
70159: PUSH
70160: LD_INT 1
70162: NEG
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PUSH
70168: LD_INT 1
70170: PUSH
70171: LD_INT 0
70173: PUSH
70174: EMPTY
70175: LIST
70176: LIST
70177: PUSH
70178: LD_INT 1
70180: PUSH
70181: LD_INT 1
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 0
70190: PUSH
70191: LD_INT 1
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 1
70200: NEG
70201: PUSH
70202: LD_INT 0
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 1
70211: NEG
70212: PUSH
70213: LD_INT 1
70215: NEG
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 1
70223: NEG
70224: PUSH
70225: LD_INT 2
70227: NEG
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 0
70235: PUSH
70236: LD_INT 2
70238: NEG
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 1
70246: PUSH
70247: LD_INT 1
70249: NEG
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 2
70257: PUSH
70258: LD_INT 0
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: PUSH
70265: LD_INT 2
70267: PUSH
70268: LD_INT 1
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 2
70277: PUSH
70278: LD_INT 2
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PUSH
70285: LD_INT 1
70287: PUSH
70288: LD_INT 2
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 0
70297: PUSH
70298: LD_INT 2
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 1
70307: NEG
70308: PUSH
70309: LD_INT 1
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 2
70318: NEG
70319: PUSH
70320: LD_INT 0
70322: PUSH
70323: EMPTY
70324: LIST
70325: LIST
70326: PUSH
70327: LD_INT 2
70329: NEG
70330: PUSH
70331: LD_INT 1
70333: NEG
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 2
70341: NEG
70342: PUSH
70343: LD_INT 2
70345: NEG
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: PUSH
70351: LD_INT 1
70353: NEG
70354: PUSH
70355: LD_INT 2
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: PUSH
70362: LD_INT 2
70364: NEG
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PUSH
70373: LD_INT 3
70375: NEG
70376: PUSH
70377: LD_INT 1
70379: NEG
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: PUSH
70385: LD_INT 3
70387: NEG
70388: PUSH
70389: LD_INT 2
70391: NEG
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: LIST
70401: LIST
70402: LIST
70403: LIST
70404: LIST
70405: LIST
70406: LIST
70407: LIST
70408: LIST
70409: LIST
70410: LIST
70411: LIST
70412: LIST
70413: LIST
70414: LIST
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70422: LD_ADDR_VAR 0 28
70426: PUSH
70427: LD_INT 0
70429: PUSH
70430: LD_INT 0
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 0
70439: PUSH
70440: LD_INT 1
70442: NEG
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 1
70450: PUSH
70451: LD_INT 0
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 1
70460: PUSH
70461: LD_INT 1
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: PUSH
70468: LD_INT 0
70470: PUSH
70471: LD_INT 1
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 1
70480: NEG
70481: PUSH
70482: LD_INT 0
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 1
70491: NEG
70492: PUSH
70493: LD_INT 1
70495: NEG
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 1
70503: NEG
70504: PUSH
70505: LD_INT 2
70507: NEG
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 0
70515: PUSH
70516: LD_INT 2
70518: NEG
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 1
70526: PUSH
70527: LD_INT 1
70529: NEG
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 2
70537: PUSH
70538: LD_INT 0
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 2
70547: PUSH
70548: LD_INT 1
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 2
70557: PUSH
70558: LD_INT 2
70560: PUSH
70561: EMPTY
70562: LIST
70563: LIST
70564: PUSH
70565: LD_INT 1
70567: PUSH
70568: LD_INT 2
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PUSH
70575: LD_INT 0
70577: PUSH
70578: LD_INT 2
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: LD_INT 1
70587: NEG
70588: PUSH
70589: LD_INT 1
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 2
70598: NEG
70599: PUSH
70600: LD_INT 0
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 2
70609: NEG
70610: PUSH
70611: LD_INT 1
70613: NEG
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 2
70621: NEG
70622: PUSH
70623: LD_INT 2
70625: NEG
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 2
70633: NEG
70634: PUSH
70635: LD_INT 3
70637: NEG
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 1
70645: NEG
70646: PUSH
70647: LD_INT 3
70649: NEG
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 3
70657: NEG
70658: PUSH
70659: LD_INT 1
70661: NEG
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: LD_INT 3
70669: NEG
70670: PUSH
70671: LD_INT 2
70673: NEG
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: LIST
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70704: LD_ADDR_VAR 0 29
70708: PUSH
70709: LD_INT 0
70711: PUSH
70712: LD_INT 0
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 0
70721: PUSH
70722: LD_INT 1
70724: NEG
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 1
70732: PUSH
70733: LD_INT 0
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 1
70742: PUSH
70743: LD_INT 1
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 0
70752: PUSH
70753: LD_INT 1
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: LD_INT 1
70762: NEG
70763: PUSH
70764: LD_INT 0
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: PUSH
70771: LD_INT 1
70773: NEG
70774: PUSH
70775: LD_INT 1
70777: NEG
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: PUSH
70783: LD_INT 1
70785: NEG
70786: PUSH
70787: LD_INT 2
70789: NEG
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: LD_INT 0
70797: PUSH
70798: LD_INT 2
70800: NEG
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 1
70808: PUSH
70809: LD_INT 1
70811: NEG
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 2
70819: PUSH
70820: LD_INT 0
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: PUSH
70827: LD_INT 2
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: LD_INT 1
70839: PUSH
70840: LD_INT 2
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 0
70849: PUSH
70850: LD_INT 2
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 1
70859: NEG
70860: PUSH
70861: LD_INT 1
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: LD_INT 2
70870: NEG
70871: PUSH
70872: LD_INT 1
70874: NEG
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 2
70882: NEG
70883: PUSH
70884: LD_INT 2
70886: NEG
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 2
70894: NEG
70895: PUSH
70896: LD_INT 3
70898: NEG
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 2
70906: PUSH
70907: LD_INT 1
70909: NEG
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 3
70917: PUSH
70918: LD_INT 1
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PUSH
70925: LD_INT 1
70927: PUSH
70928: LD_INT 3
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: LD_INT 1
70937: NEG
70938: PUSH
70939: LD_INT 2
70941: PUSH
70942: EMPTY
70943: LIST
70944: LIST
70945: PUSH
70946: LD_INT 3
70948: NEG
70949: PUSH
70950: LD_INT 2
70952: NEG
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: LIST
70962: LIST
70963: LIST
70964: LIST
70965: LIST
70966: LIST
70967: LIST
70968: LIST
70969: LIST
70970: LIST
70971: LIST
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70983: LD_ADDR_VAR 0 30
70987: PUSH
70988: LD_INT 0
70990: PUSH
70991: LD_INT 0
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PUSH
70998: LD_INT 0
71000: PUSH
71001: LD_INT 1
71003: NEG
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: PUSH
71009: LD_INT 1
71011: PUSH
71012: LD_INT 0
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 1
71021: PUSH
71022: LD_INT 1
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 0
71031: PUSH
71032: LD_INT 1
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 1
71041: NEG
71042: PUSH
71043: LD_INT 0
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 1
71052: NEG
71053: PUSH
71054: LD_INT 1
71056: NEG
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 1
71064: NEG
71065: PUSH
71066: LD_INT 2
71068: NEG
71069: PUSH
71070: EMPTY
71071: LIST
71072: LIST
71073: PUSH
71074: LD_INT 0
71076: PUSH
71077: LD_INT 2
71079: NEG
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 1
71087: PUSH
71088: LD_INT 1
71090: NEG
71091: PUSH
71092: EMPTY
71093: LIST
71094: LIST
71095: PUSH
71096: LD_INT 2
71098: PUSH
71099: LD_INT 0
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 2
71108: PUSH
71109: LD_INT 1
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 2
71118: PUSH
71119: LD_INT 2
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 1
71128: PUSH
71129: LD_INT 2
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 1
71138: NEG
71139: PUSH
71140: LD_INT 1
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: LD_INT 2
71149: NEG
71150: PUSH
71151: LD_INT 0
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: PUSH
71158: LD_INT 2
71160: NEG
71161: PUSH
71162: LD_INT 1
71164: NEG
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 1
71172: NEG
71173: PUSH
71174: LD_INT 3
71176: NEG
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 1
71184: PUSH
71185: LD_INT 2
71187: NEG
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 3
71195: PUSH
71196: LD_INT 2
71198: PUSH
71199: EMPTY
71200: LIST
71201: LIST
71202: PUSH
71203: LD_INT 2
71205: PUSH
71206: LD_INT 3
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: LD_INT 2
71215: NEG
71216: PUSH
71217: LD_INT 1
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 3
71226: NEG
71227: PUSH
71228: LD_INT 1
71230: NEG
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: LIST
71240: LIST
71241: LIST
71242: LIST
71243: LIST
71244: LIST
71245: LIST
71246: LIST
71247: LIST
71248: LIST
71249: LIST
71250: LIST
71251: LIST
71252: LIST
71253: LIST
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71261: LD_ADDR_VAR 0 31
71265: PUSH
71266: LD_INT 0
71268: PUSH
71269: LD_INT 0
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: PUSH
71276: LD_INT 0
71278: PUSH
71279: LD_INT 1
71281: NEG
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PUSH
71287: LD_INT 1
71289: PUSH
71290: LD_INT 0
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 1
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 0
71309: PUSH
71310: LD_INT 1
71312: PUSH
71313: EMPTY
71314: LIST
71315: LIST
71316: PUSH
71317: LD_INT 1
71319: NEG
71320: PUSH
71321: LD_INT 0
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: LD_INT 1
71330: NEG
71331: PUSH
71332: LD_INT 1
71334: NEG
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 1
71342: NEG
71343: PUSH
71344: LD_INT 2
71346: NEG
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PUSH
71352: LD_INT 1
71354: PUSH
71355: LD_INT 1
71357: NEG
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 2
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 2
71375: PUSH
71376: LD_INT 1
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: PUSH
71383: LD_INT 2
71385: PUSH
71386: LD_INT 2
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: PUSH
71393: LD_INT 1
71395: PUSH
71396: LD_INT 2
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: PUSH
71403: LD_INT 0
71405: PUSH
71406: LD_INT 2
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 1
71415: NEG
71416: PUSH
71417: LD_INT 1
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 2
71426: NEG
71427: PUSH
71428: LD_INT 1
71430: NEG
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: PUSH
71436: LD_INT 2
71438: NEG
71439: PUSH
71440: LD_INT 2
71442: NEG
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: PUSH
71448: LD_INT 2
71450: NEG
71451: PUSH
71452: LD_INT 3
71454: NEG
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: LD_INT 2
71462: PUSH
71463: LD_INT 1
71465: NEG
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: PUSH
71471: LD_INT 3
71473: PUSH
71474: LD_INT 1
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 1
71483: PUSH
71484: LD_INT 3
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 1
71493: NEG
71494: PUSH
71495: LD_INT 2
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: PUSH
71502: LD_INT 3
71504: NEG
71505: PUSH
71506: LD_INT 2
71508: NEG
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: LIST
71518: LIST
71519: LIST
71520: LIST
71521: LIST
71522: LIST
71523: LIST
71524: LIST
71525: LIST
71526: LIST
71527: LIST
71528: LIST
71529: LIST
71530: LIST
71531: LIST
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71539: LD_ADDR_VAR 0 32
71543: PUSH
71544: LD_INT 0
71546: PUSH
71547: LD_INT 0
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: LD_INT 0
71556: PUSH
71557: LD_INT 1
71559: NEG
71560: PUSH
71561: EMPTY
71562: LIST
71563: LIST
71564: PUSH
71565: LD_INT 1
71567: PUSH
71568: LD_INT 0
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 1
71577: PUSH
71578: LD_INT 1
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PUSH
71585: LD_INT 0
71587: PUSH
71588: LD_INT 1
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: PUSH
71595: LD_INT 1
71597: NEG
71598: PUSH
71599: LD_INT 0
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 1
71608: NEG
71609: PUSH
71610: LD_INT 1
71612: NEG
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 1
71620: NEG
71621: PUSH
71622: LD_INT 2
71624: NEG
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: PUSH
71630: LD_INT 0
71632: PUSH
71633: LD_INT 2
71635: NEG
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 1
71643: PUSH
71644: LD_INT 1
71646: NEG
71647: PUSH
71648: EMPTY
71649: LIST
71650: LIST
71651: PUSH
71652: LD_INT 2
71654: PUSH
71655: LD_INT 1
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 2
71664: PUSH
71665: LD_INT 2
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 1
71674: PUSH
71675: LD_INT 2
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: LD_INT 2
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 1
71694: NEG
71695: PUSH
71696: LD_INT 1
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 2
71705: NEG
71706: PUSH
71707: LD_INT 0
71709: PUSH
71710: EMPTY
71711: LIST
71712: LIST
71713: PUSH
71714: LD_INT 2
71716: NEG
71717: PUSH
71718: LD_INT 1
71720: NEG
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: PUSH
71726: LD_INT 1
71728: NEG
71729: PUSH
71730: LD_INT 3
71732: NEG
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 1
71740: PUSH
71741: LD_INT 2
71743: NEG
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 3
71751: PUSH
71752: LD_INT 2
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: LD_INT 2
71761: PUSH
71762: LD_INT 3
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 2
71771: NEG
71772: PUSH
71773: LD_INT 1
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 3
71782: NEG
71783: PUSH
71784: LD_INT 1
71786: NEG
71787: PUSH
71788: EMPTY
71789: LIST
71790: LIST
71791: PUSH
71792: EMPTY
71793: LIST
71794: LIST
71795: LIST
71796: LIST
71797: LIST
71798: LIST
71799: LIST
71800: LIST
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: LIST
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: LIST
71813: LIST
71814: LIST
71815: LIST
71816: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71817: LD_ADDR_VAR 0 33
71821: PUSH
71822: LD_INT 0
71824: PUSH
71825: LD_INT 0
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 0
71834: PUSH
71835: LD_INT 1
71837: NEG
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 1
71845: PUSH
71846: LD_INT 0
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 1
71855: PUSH
71856: LD_INT 1
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: PUSH
71863: LD_INT 0
71865: PUSH
71866: LD_INT 1
71868: PUSH
71869: EMPTY
71870: LIST
71871: LIST
71872: PUSH
71873: LD_INT 1
71875: NEG
71876: PUSH
71877: LD_INT 0
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 1
71886: NEG
71887: PUSH
71888: LD_INT 1
71890: NEG
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 1
71898: NEG
71899: PUSH
71900: LD_INT 2
71902: NEG
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: PUSH
71908: LD_INT 1
71910: PUSH
71911: LD_INT 1
71913: NEG
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 2
71921: PUSH
71922: LD_INT 0
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 2
71931: PUSH
71932: LD_INT 1
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PUSH
71939: LD_INT 1
71941: PUSH
71942: LD_INT 2
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 0
71951: PUSH
71952: LD_INT 2
71954: PUSH
71955: EMPTY
71956: LIST
71957: LIST
71958: PUSH
71959: LD_INT 1
71961: NEG
71962: PUSH
71963: LD_INT 1
71965: PUSH
71966: EMPTY
71967: LIST
71968: LIST
71969: PUSH
71970: LD_INT 2
71972: NEG
71973: PUSH
71974: LD_INT 0
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: PUSH
71981: LD_INT 2
71983: NEG
71984: PUSH
71985: LD_INT 1
71987: NEG
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 2
71995: NEG
71996: PUSH
71997: LD_INT 2
71999: NEG
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 2
72007: NEG
72008: PUSH
72009: LD_INT 3
72011: NEG
72012: PUSH
72013: EMPTY
72014: LIST
72015: LIST
72016: PUSH
72017: LD_INT 2
72019: PUSH
72020: LD_INT 1
72022: NEG
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PUSH
72028: LD_INT 3
72030: PUSH
72031: LD_INT 1
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 1
72040: PUSH
72041: LD_INT 3
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PUSH
72048: LD_INT 1
72050: NEG
72051: PUSH
72052: LD_INT 2
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: LD_INT 3
72061: NEG
72062: PUSH
72063: LD_INT 2
72065: NEG
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: EMPTY
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: LIST
72078: LIST
72079: LIST
72080: LIST
72081: LIST
72082: LIST
72083: LIST
72084: LIST
72085: LIST
72086: LIST
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72096: LD_ADDR_VAR 0 34
72100: PUSH
72101: LD_INT 0
72103: PUSH
72104: LD_INT 0
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 0
72113: PUSH
72114: LD_INT 1
72116: NEG
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 1
72124: PUSH
72125: LD_INT 0
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 1
72134: PUSH
72135: LD_INT 1
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: LD_INT 0
72144: PUSH
72145: LD_INT 1
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 1
72154: NEG
72155: PUSH
72156: LD_INT 0
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 1
72165: NEG
72166: PUSH
72167: LD_INT 1
72169: NEG
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 1
72177: NEG
72178: PUSH
72179: LD_INT 2
72181: NEG
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: LD_INT 0
72189: PUSH
72190: LD_INT 2
72192: NEG
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: LD_INT 1
72203: NEG
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PUSH
72209: LD_INT 2
72211: PUSH
72212: LD_INT 1
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: PUSH
72219: LD_INT 2
72221: PUSH
72222: LD_INT 2
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 1
72231: PUSH
72232: LD_INT 2
72234: PUSH
72235: EMPTY
72236: LIST
72237: LIST
72238: PUSH
72239: LD_INT 1
72241: NEG
72242: PUSH
72243: LD_INT 1
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: LD_INT 2
72252: NEG
72253: PUSH
72254: LD_INT 0
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: LD_INT 2
72263: NEG
72264: PUSH
72265: LD_INT 1
72267: NEG
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 2
72275: NEG
72276: PUSH
72277: LD_INT 2
72279: NEG
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 1
72287: NEG
72288: PUSH
72289: LD_INT 3
72291: NEG
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 1
72299: PUSH
72300: LD_INT 2
72302: NEG
72303: PUSH
72304: EMPTY
72305: LIST
72306: LIST
72307: PUSH
72308: LD_INT 3
72310: PUSH
72311: LD_INT 2
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: PUSH
72318: LD_INT 2
72320: PUSH
72321: LD_INT 3
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: LD_INT 2
72330: NEG
72331: PUSH
72332: LD_INT 1
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 3
72341: NEG
72342: PUSH
72343: LD_INT 1
72345: NEG
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: LIST
72355: LIST
72356: LIST
72357: LIST
72358: LIST
72359: LIST
72360: LIST
72361: LIST
72362: LIST
72363: LIST
72364: LIST
72365: LIST
72366: LIST
72367: LIST
72368: LIST
72369: LIST
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72376: LD_ADDR_VAR 0 35
72380: PUSH
72381: LD_INT 0
72383: PUSH
72384: LD_INT 0
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 0
72393: PUSH
72394: LD_INT 1
72396: NEG
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: LD_INT 0
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: LD_INT 1
72414: PUSH
72415: LD_INT 1
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 0
72424: PUSH
72425: LD_INT 1
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: LD_INT 1
72434: NEG
72435: PUSH
72436: LD_INT 0
72438: PUSH
72439: EMPTY
72440: LIST
72441: LIST
72442: PUSH
72443: LD_INT 1
72445: NEG
72446: PUSH
72447: LD_INT 1
72449: NEG
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 2
72457: PUSH
72458: LD_INT 1
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 2
72467: NEG
72468: PUSH
72469: LD_INT 1
72471: NEG
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72488: LD_ADDR_VAR 0 36
72492: PUSH
72493: LD_INT 0
72495: PUSH
72496: LD_INT 0
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 0
72505: PUSH
72506: LD_INT 1
72508: NEG
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 1
72516: PUSH
72517: LD_INT 0
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PUSH
72524: LD_INT 1
72526: PUSH
72527: LD_INT 1
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 0
72536: PUSH
72537: LD_INT 1
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 1
72546: NEG
72547: PUSH
72548: LD_INT 0
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: PUSH
72555: LD_INT 1
72557: NEG
72558: PUSH
72559: LD_INT 1
72561: NEG
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: LD_INT 1
72569: NEG
72570: PUSH
72571: LD_INT 2
72573: NEG
72574: PUSH
72575: EMPTY
72576: LIST
72577: LIST
72578: PUSH
72579: LD_INT 1
72581: PUSH
72582: LD_INT 2
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72600: LD_ADDR_VAR 0 37
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: LD_INT 0
72610: PUSH
72611: EMPTY
72612: LIST
72613: LIST
72614: PUSH
72615: LD_INT 0
72617: PUSH
72618: LD_INT 1
72620: NEG
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: PUSH
72626: LD_INT 1
72628: PUSH
72629: LD_INT 0
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 1
72638: PUSH
72639: LD_INT 1
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: PUSH
72646: LD_INT 0
72648: PUSH
72649: LD_INT 1
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 1
72658: NEG
72659: PUSH
72660: LD_INT 0
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: PUSH
72667: LD_INT 1
72669: NEG
72670: PUSH
72671: LD_INT 1
72673: NEG
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PUSH
72679: LD_INT 1
72681: PUSH
72682: LD_INT 1
72684: NEG
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: PUSH
72690: LD_INT 1
72692: NEG
72693: PUSH
72694: LD_INT 1
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: LIST
72705: LIST
72706: LIST
72707: LIST
72708: LIST
72709: LIST
72710: LIST
72711: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72712: LD_ADDR_VAR 0 38
72716: PUSH
72717: LD_INT 0
72719: PUSH
72720: LD_INT 0
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 0
72729: PUSH
72730: LD_INT 1
72732: NEG
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 1
72740: PUSH
72741: LD_INT 0
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 1
72750: PUSH
72751: LD_INT 1
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 0
72760: PUSH
72761: LD_INT 1
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PUSH
72768: LD_INT 1
72770: NEG
72771: PUSH
72772: LD_INT 0
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PUSH
72779: LD_INT 1
72781: NEG
72782: PUSH
72783: LD_INT 1
72785: NEG
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 2
72793: PUSH
72794: LD_INT 1
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 2
72803: NEG
72804: PUSH
72805: LD_INT 1
72807: NEG
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72824: LD_ADDR_VAR 0 39
72828: PUSH
72829: LD_INT 0
72831: PUSH
72832: LD_INT 0
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 0
72841: PUSH
72842: LD_INT 1
72844: NEG
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: PUSH
72850: LD_INT 1
72852: PUSH
72853: LD_INT 0
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: PUSH
72860: LD_INT 1
72862: PUSH
72863: LD_INT 1
72865: PUSH
72866: EMPTY
72867: LIST
72868: LIST
72869: PUSH
72870: LD_INT 0
72872: PUSH
72873: LD_INT 1
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 1
72882: NEG
72883: PUSH
72884: LD_INT 0
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: LD_INT 1
72893: NEG
72894: PUSH
72895: LD_INT 1
72897: NEG
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 1
72905: NEG
72906: PUSH
72907: LD_INT 2
72909: NEG
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 1
72917: PUSH
72918: LD_INT 2
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72936: LD_ADDR_VAR 0 40
72940: PUSH
72941: LD_INT 0
72943: PUSH
72944: LD_INT 0
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 0
72953: PUSH
72954: LD_INT 1
72956: NEG
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 1
72964: PUSH
72965: LD_INT 0
72967: PUSH
72968: EMPTY
72969: LIST
72970: LIST
72971: PUSH
72972: LD_INT 1
72974: PUSH
72975: LD_INT 1
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 0
72984: PUSH
72985: LD_INT 1
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 1
72994: NEG
72995: PUSH
72996: LD_INT 0
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 1
73005: NEG
73006: PUSH
73007: LD_INT 1
73009: NEG
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: PUSH
73015: LD_INT 1
73017: PUSH
73018: LD_INT 1
73020: NEG
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: LD_INT 1
73028: NEG
73029: PUSH
73030: LD_INT 1
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: LIST
73041: LIST
73042: LIST
73043: LIST
73044: LIST
73045: LIST
73046: LIST
73047: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73048: LD_ADDR_VAR 0 41
73052: PUSH
73053: LD_INT 0
73055: PUSH
73056: LD_INT 0
73058: PUSH
73059: EMPTY
73060: LIST
73061: LIST
73062: PUSH
73063: LD_INT 0
73065: PUSH
73066: LD_INT 1
73068: NEG
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PUSH
73074: LD_INT 1
73076: PUSH
73077: LD_INT 0
73079: PUSH
73080: EMPTY
73081: LIST
73082: LIST
73083: PUSH
73084: LD_INT 1
73086: PUSH
73087: LD_INT 1
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 0
73096: PUSH
73097: LD_INT 1
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 1
73106: NEG
73107: PUSH
73108: LD_INT 0
73110: PUSH
73111: EMPTY
73112: LIST
73113: LIST
73114: PUSH
73115: LD_INT 1
73117: NEG
73118: PUSH
73119: LD_INT 1
73121: NEG
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: PUSH
73127: LD_INT 1
73129: NEG
73130: PUSH
73131: LD_INT 2
73133: NEG
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: LD_INT 1
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: LD_INT 2
73152: PUSH
73153: LD_INT 0
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 2
73162: PUSH
73163: LD_INT 1
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PUSH
73170: LD_INT 2
73172: PUSH
73173: LD_INT 2
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PUSH
73180: LD_INT 1
73182: PUSH
73183: LD_INT 2
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: PUSH
73190: LD_INT 1
73192: NEG
73193: PUSH
73194: LD_INT 1
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 2
73203: NEG
73204: PUSH
73205: LD_INT 0
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 2
73214: NEG
73215: PUSH
73216: LD_INT 1
73218: NEG
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 2
73226: NEG
73227: PUSH
73228: LD_INT 2
73230: NEG
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: PUSH
73236: LD_INT 2
73238: NEG
73239: PUSH
73240: LD_INT 3
73242: NEG
73243: PUSH
73244: EMPTY
73245: LIST
73246: LIST
73247: PUSH
73248: LD_INT 2
73250: PUSH
73251: LD_INT 1
73253: NEG
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: PUSH
73259: LD_INT 3
73261: PUSH
73262: LD_INT 0
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 3
73271: PUSH
73272: LD_INT 1
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: LD_INT 3
73281: PUSH
73282: LD_INT 2
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: PUSH
73289: LD_INT 3
73291: PUSH
73292: LD_INT 3
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: LD_INT 2
73301: PUSH
73302: LD_INT 3
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PUSH
73309: LD_INT 2
73311: NEG
73312: PUSH
73313: LD_INT 1
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: LD_INT 3
73322: NEG
73323: PUSH
73324: LD_INT 0
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: PUSH
73331: LD_INT 3
73333: NEG
73334: PUSH
73335: LD_INT 1
73337: NEG
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 3
73345: NEG
73346: PUSH
73347: LD_INT 2
73349: NEG
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 3
73357: NEG
73358: PUSH
73359: LD_INT 3
73361: NEG
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: EMPTY
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: LIST
73380: LIST
73381: LIST
73382: LIST
73383: LIST
73384: LIST
73385: LIST
73386: LIST
73387: LIST
73388: LIST
73389: LIST
73390: LIST
73391: LIST
73392: LIST
73393: LIST
73394: LIST
73395: LIST
73396: LIST
73397: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73398: LD_ADDR_VAR 0 42
73402: PUSH
73403: LD_INT 0
73405: PUSH
73406: LD_INT 0
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 0
73415: PUSH
73416: LD_INT 1
73418: NEG
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: LD_INT 1
73426: PUSH
73427: LD_INT 0
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 1
73436: PUSH
73437: LD_INT 1
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: LD_INT 0
73446: PUSH
73447: LD_INT 1
73449: PUSH
73450: EMPTY
73451: LIST
73452: LIST
73453: PUSH
73454: LD_INT 1
73456: NEG
73457: PUSH
73458: LD_INT 0
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 1
73467: NEG
73468: PUSH
73469: LD_INT 1
73471: NEG
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: LD_INT 1
73479: NEG
73480: PUSH
73481: LD_INT 2
73483: NEG
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: LD_INT 0
73491: PUSH
73492: LD_INT 2
73494: NEG
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: PUSH
73500: LD_INT 1
73502: PUSH
73503: LD_INT 1
73505: NEG
73506: PUSH
73507: EMPTY
73508: LIST
73509: LIST
73510: PUSH
73511: LD_INT 2
73513: PUSH
73514: LD_INT 1
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: PUSH
73521: LD_INT 2
73523: PUSH
73524: LD_INT 2
73526: PUSH
73527: EMPTY
73528: LIST
73529: LIST
73530: PUSH
73531: LD_INT 1
73533: PUSH
73534: LD_INT 2
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: PUSH
73541: LD_INT 0
73543: PUSH
73544: LD_INT 2
73546: PUSH
73547: EMPTY
73548: LIST
73549: LIST
73550: PUSH
73551: LD_INT 1
73553: NEG
73554: PUSH
73555: LD_INT 1
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: LD_INT 2
73564: NEG
73565: PUSH
73566: LD_INT 1
73568: NEG
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 2
73576: NEG
73577: PUSH
73578: LD_INT 2
73580: NEG
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 2
73588: NEG
73589: PUSH
73590: LD_INT 3
73592: NEG
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: PUSH
73598: LD_INT 1
73600: NEG
73601: PUSH
73602: LD_INT 3
73604: NEG
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: PUSH
73610: LD_INT 0
73612: PUSH
73613: LD_INT 3
73615: NEG
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: LD_INT 1
73623: PUSH
73624: LD_INT 2
73626: NEG
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PUSH
73632: LD_INT 3
73634: PUSH
73635: LD_INT 2
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: PUSH
73642: LD_INT 3
73644: PUSH
73645: LD_INT 3
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 2
73654: PUSH
73655: LD_INT 3
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: PUSH
73662: LD_INT 1
73664: PUSH
73665: LD_INT 3
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 0
73674: PUSH
73675: LD_INT 3
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: NEG
73685: PUSH
73686: LD_INT 2
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 3
73695: NEG
73696: PUSH
73697: LD_INT 2
73699: NEG
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: LD_INT 3
73707: NEG
73708: PUSH
73709: LD_INT 3
73711: NEG
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: PUSH
73717: EMPTY
73718: LIST
73719: LIST
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: LIST
73725: LIST
73726: LIST
73727: LIST
73728: LIST
73729: LIST
73730: LIST
73731: LIST
73732: LIST
73733: LIST
73734: LIST
73735: LIST
73736: LIST
73737: LIST
73738: LIST
73739: LIST
73740: LIST
73741: LIST
73742: LIST
73743: LIST
73744: LIST
73745: LIST
73746: LIST
73747: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73748: LD_ADDR_VAR 0 43
73752: PUSH
73753: LD_INT 0
73755: PUSH
73756: LD_INT 0
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: LD_INT 0
73765: PUSH
73766: LD_INT 1
73768: NEG
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PUSH
73774: LD_INT 1
73776: PUSH
73777: LD_INT 0
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: PUSH
73784: LD_INT 1
73786: PUSH
73787: LD_INT 1
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 0
73796: PUSH
73797: LD_INT 1
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 1
73806: NEG
73807: PUSH
73808: LD_INT 0
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 1
73817: NEG
73818: PUSH
73819: LD_INT 1
73821: NEG
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 1
73829: NEG
73830: PUSH
73831: LD_INT 2
73833: NEG
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: LD_INT 2
73844: NEG
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 1
73852: PUSH
73853: LD_INT 1
73855: NEG
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 2
73863: PUSH
73864: LD_INT 0
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: PUSH
73871: LD_INT 2
73873: PUSH
73874: LD_INT 1
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 1
73883: PUSH
73884: LD_INT 2
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 0
73893: PUSH
73894: LD_INT 2
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 1
73903: NEG
73904: PUSH
73905: LD_INT 1
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 2
73914: NEG
73915: PUSH
73916: LD_INT 0
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 2
73925: NEG
73926: PUSH
73927: LD_INT 1
73929: NEG
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 1
73937: NEG
73938: PUSH
73939: LD_INT 3
73941: NEG
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 0
73949: PUSH
73950: LD_INT 3
73952: NEG
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: LD_INT 1
73960: PUSH
73961: LD_INT 2
73963: NEG
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 2
73971: PUSH
73972: LD_INT 1
73974: NEG
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: PUSH
73980: LD_INT 3
73982: PUSH
73983: LD_INT 0
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: LD_INT 3
73992: PUSH
73993: LD_INT 1
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: PUSH
74000: LD_INT 1
74002: PUSH
74003: LD_INT 3
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: LD_INT 0
74012: PUSH
74013: LD_INT 3
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: PUSH
74020: LD_INT 1
74022: NEG
74023: PUSH
74024: LD_INT 2
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 2
74033: NEG
74034: PUSH
74035: LD_INT 1
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 3
74044: NEG
74045: PUSH
74046: LD_INT 0
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 3
74055: NEG
74056: PUSH
74057: LD_INT 1
74059: NEG
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: LIST
74075: LIST
74076: LIST
74077: LIST
74078: LIST
74079: LIST
74080: LIST
74081: LIST
74082: LIST
74083: LIST
74084: LIST
74085: LIST
74086: LIST
74087: LIST
74088: LIST
74089: LIST
74090: LIST
74091: LIST
74092: LIST
74093: LIST
74094: LIST
74095: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74096: LD_ADDR_VAR 0 44
74100: PUSH
74101: LD_INT 0
74103: PUSH
74104: LD_INT 0
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 0
74113: PUSH
74114: LD_INT 1
74116: NEG
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 1
74124: PUSH
74125: LD_INT 0
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: PUSH
74132: LD_INT 1
74134: PUSH
74135: LD_INT 1
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 0
74144: PUSH
74145: LD_INT 1
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: PUSH
74152: LD_INT 1
74154: NEG
74155: PUSH
74156: LD_INT 0
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_INT 1
74165: NEG
74166: PUSH
74167: LD_INT 1
74169: NEG
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 1
74177: NEG
74178: PUSH
74179: LD_INT 2
74181: NEG
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 1
74189: PUSH
74190: LD_INT 1
74192: NEG
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PUSH
74198: LD_INT 2
74200: PUSH
74201: LD_INT 0
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 2
74210: PUSH
74211: LD_INT 1
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 2
74220: PUSH
74221: LD_INT 2
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 1
74230: PUSH
74231: LD_INT 2
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: LD_INT 1
74240: NEG
74241: PUSH
74242: LD_INT 1
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: LD_INT 2
74251: NEG
74252: PUSH
74253: LD_INT 0
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 2
74262: NEG
74263: PUSH
74264: LD_INT 1
74266: NEG
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 2
74274: NEG
74275: PUSH
74276: LD_INT 2
74278: NEG
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 2
74286: NEG
74287: PUSH
74288: LD_INT 3
74290: NEG
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: LD_INT 2
74298: PUSH
74299: LD_INT 1
74301: NEG
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: PUSH
74307: LD_INT 3
74309: PUSH
74310: LD_INT 0
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PUSH
74317: LD_INT 3
74319: PUSH
74320: LD_INT 1
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: LD_INT 3
74329: PUSH
74330: LD_INT 2
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 3
74339: PUSH
74340: LD_INT 3
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 2
74349: PUSH
74350: LD_INT 3
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: PUSH
74357: LD_INT 2
74359: NEG
74360: PUSH
74361: LD_INT 1
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: PUSH
74368: LD_INT 3
74370: NEG
74371: PUSH
74372: LD_INT 0
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: LD_INT 3
74381: NEG
74382: PUSH
74383: LD_INT 1
74385: NEG
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: PUSH
74391: LD_INT 3
74393: NEG
74394: PUSH
74395: LD_INT 2
74397: NEG
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 3
74405: NEG
74406: PUSH
74407: LD_INT 3
74409: NEG
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: LIST
74425: LIST
74426: LIST
74427: LIST
74428: LIST
74429: LIST
74430: LIST
74431: LIST
74432: LIST
74433: LIST
74434: LIST
74435: LIST
74436: LIST
74437: LIST
74438: LIST
74439: LIST
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: LIST
74445: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74446: LD_ADDR_VAR 0 45
74450: PUSH
74451: LD_INT 0
74453: PUSH
74454: LD_INT 0
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 0
74463: PUSH
74464: LD_INT 1
74466: NEG
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: LD_INT 1
74474: PUSH
74475: LD_INT 0
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PUSH
74482: LD_INT 1
74484: PUSH
74485: LD_INT 1
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 0
74494: PUSH
74495: LD_INT 1
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 1
74504: NEG
74505: PUSH
74506: LD_INT 0
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: PUSH
74513: LD_INT 1
74515: NEG
74516: PUSH
74517: LD_INT 1
74519: NEG
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_INT 1
74527: NEG
74528: PUSH
74529: LD_INT 2
74531: NEG
74532: PUSH
74533: EMPTY
74534: LIST
74535: LIST
74536: PUSH
74537: LD_INT 0
74539: PUSH
74540: LD_INT 2
74542: NEG
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 1
74550: PUSH
74551: LD_INT 1
74553: NEG
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: LD_INT 2
74561: PUSH
74562: LD_INT 1
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: LD_INT 2
74571: PUSH
74572: LD_INT 2
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: LD_INT 1
74581: PUSH
74582: LD_INT 2
74584: PUSH
74585: EMPTY
74586: LIST
74587: LIST
74588: PUSH
74589: LD_INT 0
74591: PUSH
74592: LD_INT 2
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: PUSH
74599: LD_INT 1
74601: NEG
74602: PUSH
74603: LD_INT 1
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: LD_INT 2
74612: NEG
74613: PUSH
74614: LD_INT 1
74616: NEG
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 2
74624: NEG
74625: PUSH
74626: LD_INT 2
74628: NEG
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: PUSH
74634: LD_INT 2
74636: NEG
74637: PUSH
74638: LD_INT 3
74640: NEG
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: LD_INT 1
74648: NEG
74649: PUSH
74650: LD_INT 3
74652: NEG
74653: PUSH
74654: EMPTY
74655: LIST
74656: LIST
74657: PUSH
74658: LD_INT 0
74660: PUSH
74661: LD_INT 3
74663: NEG
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: PUSH
74669: LD_INT 1
74671: PUSH
74672: LD_INT 2
74674: NEG
74675: PUSH
74676: EMPTY
74677: LIST
74678: LIST
74679: PUSH
74680: LD_INT 3
74682: PUSH
74683: LD_INT 2
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: LD_INT 3
74692: PUSH
74693: LD_INT 3
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: LD_INT 2
74702: PUSH
74703: LD_INT 3
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 1
74712: PUSH
74713: LD_INT 3
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 0
74722: PUSH
74723: LD_INT 3
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 1
74732: NEG
74733: PUSH
74734: LD_INT 2
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 3
74743: NEG
74744: PUSH
74745: LD_INT 2
74747: NEG
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: PUSH
74753: LD_INT 3
74755: NEG
74756: PUSH
74757: LD_INT 3
74759: NEG
74760: PUSH
74761: EMPTY
74762: LIST
74763: LIST
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: LIST
74775: LIST
74776: LIST
74777: LIST
74778: LIST
74779: LIST
74780: LIST
74781: LIST
74782: LIST
74783: LIST
74784: LIST
74785: LIST
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: LIST
74792: LIST
74793: LIST
74794: LIST
74795: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74796: LD_ADDR_VAR 0 46
74800: PUSH
74801: LD_INT 0
74803: PUSH
74804: LD_INT 0
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 0
74813: PUSH
74814: LD_INT 1
74816: NEG
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: LD_INT 1
74824: PUSH
74825: LD_INT 0
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 1
74834: PUSH
74835: LD_INT 1
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 0
74844: PUSH
74845: LD_INT 1
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 1
74854: NEG
74855: PUSH
74856: LD_INT 0
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 1
74865: NEG
74866: PUSH
74867: LD_INT 1
74869: NEG
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 1
74877: NEG
74878: PUSH
74879: LD_INT 2
74881: NEG
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: LD_INT 2
74892: NEG
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: LD_INT 1
74903: NEG
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 2
74911: PUSH
74912: LD_INT 0
74914: PUSH
74915: EMPTY
74916: LIST
74917: LIST
74918: PUSH
74919: LD_INT 2
74921: PUSH
74922: LD_INT 1
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 1
74931: PUSH
74932: LD_INT 2
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: PUSH
74939: LD_INT 0
74941: PUSH
74942: LD_INT 2
74944: PUSH
74945: EMPTY
74946: LIST
74947: LIST
74948: PUSH
74949: LD_INT 1
74951: NEG
74952: PUSH
74953: LD_INT 1
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: PUSH
74960: LD_INT 2
74962: NEG
74963: PUSH
74964: LD_INT 0
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: PUSH
74971: LD_INT 2
74973: NEG
74974: PUSH
74975: LD_INT 1
74977: NEG
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 1
74985: NEG
74986: PUSH
74987: LD_INT 3
74989: NEG
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 0
74997: PUSH
74998: LD_INT 3
75000: NEG
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: LD_INT 1
75008: PUSH
75009: LD_INT 2
75011: NEG
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 2
75019: PUSH
75020: LD_INT 1
75022: NEG
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: PUSH
75028: LD_INT 3
75030: PUSH
75031: LD_INT 0
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: PUSH
75038: LD_INT 3
75040: PUSH
75041: LD_INT 1
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PUSH
75048: LD_INT 1
75050: PUSH
75051: LD_INT 3
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: LD_INT 0
75060: PUSH
75061: LD_INT 3
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: PUSH
75068: LD_INT 1
75070: NEG
75071: PUSH
75072: LD_INT 2
75074: PUSH
75075: EMPTY
75076: LIST
75077: LIST
75078: PUSH
75079: LD_INT 2
75081: NEG
75082: PUSH
75083: LD_INT 1
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 3
75092: NEG
75093: PUSH
75094: LD_INT 0
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 3
75103: NEG
75104: PUSH
75105: LD_INT 1
75107: NEG
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: LIST
75119: LIST
75120: LIST
75121: LIST
75122: LIST
75123: LIST
75124: LIST
75125: LIST
75126: LIST
75127: LIST
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: LIST
75134: LIST
75135: LIST
75136: LIST
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: LIST
75142: LIST
75143: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75144: LD_ADDR_VAR 0 47
75148: PUSH
75149: LD_INT 0
75151: PUSH
75152: LD_INT 0
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 0
75161: PUSH
75162: LD_INT 1
75164: NEG
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 1
75172: PUSH
75173: LD_INT 0
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: LD_INT 1
75182: PUSH
75183: LD_INT 1
75185: PUSH
75186: EMPTY
75187: LIST
75188: LIST
75189: PUSH
75190: LD_INT 0
75192: PUSH
75193: LD_INT 1
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 1
75202: NEG
75203: PUSH
75204: LD_INT 0
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PUSH
75211: LD_INT 1
75213: NEG
75214: PUSH
75215: LD_INT 1
75217: NEG
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 1
75225: NEG
75226: PUSH
75227: LD_INT 2
75229: NEG
75230: PUSH
75231: EMPTY
75232: LIST
75233: LIST
75234: PUSH
75235: LD_INT 0
75237: PUSH
75238: LD_INT 2
75240: NEG
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: PUSH
75246: LD_INT 1
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: PUSH
75257: LD_INT 2
75259: NEG
75260: PUSH
75261: LD_INT 1
75263: NEG
75264: PUSH
75265: EMPTY
75266: LIST
75267: LIST
75268: PUSH
75269: LD_INT 2
75271: NEG
75272: PUSH
75273: LD_INT 2
75275: NEG
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: LIST
75285: LIST
75286: LIST
75287: LIST
75288: LIST
75289: LIST
75290: LIST
75291: LIST
75292: LIST
75293: LIST
75294: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75295: LD_ADDR_VAR 0 48
75299: PUSH
75300: LD_INT 0
75302: PUSH
75303: LD_INT 0
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: LD_INT 0
75312: PUSH
75313: LD_INT 1
75315: NEG
75316: PUSH
75317: EMPTY
75318: LIST
75319: LIST
75320: PUSH
75321: LD_INT 1
75323: PUSH
75324: LD_INT 0
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: LD_INT 1
75333: PUSH
75334: LD_INT 1
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: PUSH
75341: LD_INT 0
75343: PUSH
75344: LD_INT 1
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: LD_INT 1
75353: NEG
75354: PUSH
75355: LD_INT 0
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: PUSH
75362: LD_INT 1
75364: NEG
75365: PUSH
75366: LD_INT 1
75368: NEG
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: LD_INT 1
75376: NEG
75377: PUSH
75378: LD_INT 2
75380: NEG
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 0
75388: PUSH
75389: LD_INT 2
75391: NEG
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 1
75399: PUSH
75400: LD_INT 1
75402: NEG
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 2
75410: PUSH
75411: LD_INT 0
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 2
75420: PUSH
75421: LD_INT 1
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: LIST
75432: LIST
75433: LIST
75434: LIST
75435: LIST
75436: LIST
75437: LIST
75438: LIST
75439: LIST
75440: LIST
75441: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75442: LD_ADDR_VAR 0 49
75446: PUSH
75447: LD_INT 0
75449: PUSH
75450: LD_INT 0
75452: PUSH
75453: EMPTY
75454: LIST
75455: LIST
75456: PUSH
75457: LD_INT 0
75459: PUSH
75460: LD_INT 1
75462: NEG
75463: PUSH
75464: EMPTY
75465: LIST
75466: LIST
75467: PUSH
75468: LD_INT 1
75470: PUSH
75471: LD_INT 0
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: LD_INT 1
75480: PUSH
75481: LD_INT 1
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: LD_INT 1
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PUSH
75498: LD_INT 1
75500: NEG
75501: PUSH
75502: LD_INT 0
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 1
75511: NEG
75512: PUSH
75513: LD_INT 1
75515: NEG
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: LD_INT 1
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: PUSH
75532: LD_INT 2
75534: PUSH
75535: LD_INT 0
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 2
75544: PUSH
75545: LD_INT 1
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 2
75554: PUSH
75555: LD_INT 2
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: LD_INT 1
75564: PUSH
75565: LD_INT 2
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: LIST
75580: LIST
75581: LIST
75582: LIST
75583: LIST
75584: LIST
75585: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75586: LD_ADDR_VAR 0 50
75590: PUSH
75591: LD_INT 0
75593: PUSH
75594: LD_INT 0
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 0
75603: PUSH
75604: LD_INT 1
75606: NEG
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 1
75614: PUSH
75615: LD_INT 0
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: LD_INT 1
75624: PUSH
75625: LD_INT 1
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 0
75634: PUSH
75635: LD_INT 1
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PUSH
75642: LD_INT 1
75644: NEG
75645: PUSH
75646: LD_INT 0
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 1
75655: NEG
75656: PUSH
75657: LD_INT 1
75659: NEG
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: PUSH
75665: LD_INT 2
75667: PUSH
75668: LD_INT 1
75670: PUSH
75671: EMPTY
75672: LIST
75673: LIST
75674: PUSH
75675: LD_INT 2
75677: PUSH
75678: LD_INT 2
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 1
75687: PUSH
75688: LD_INT 2
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: LD_INT 0
75697: PUSH
75698: LD_INT 2
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: LD_INT 1
75707: NEG
75708: PUSH
75709: LD_INT 1
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: LIST
75720: LIST
75721: LIST
75722: LIST
75723: LIST
75724: LIST
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75730: LD_ADDR_VAR 0 51
75734: PUSH
75735: LD_INT 0
75737: PUSH
75738: LD_INT 0
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 0
75747: PUSH
75748: LD_INT 1
75750: NEG
75751: PUSH
75752: EMPTY
75753: LIST
75754: LIST
75755: PUSH
75756: LD_INT 1
75758: PUSH
75759: LD_INT 0
75761: PUSH
75762: EMPTY
75763: LIST
75764: LIST
75765: PUSH
75766: LD_INT 1
75768: PUSH
75769: LD_INT 1
75771: PUSH
75772: EMPTY
75773: LIST
75774: LIST
75775: PUSH
75776: LD_INT 0
75778: PUSH
75779: LD_INT 1
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 1
75788: NEG
75789: PUSH
75790: LD_INT 0
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 1
75799: NEG
75800: PUSH
75801: LD_INT 1
75803: NEG
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 1
75811: PUSH
75812: LD_INT 2
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: LD_INT 0
75821: PUSH
75822: LD_INT 2
75824: PUSH
75825: EMPTY
75826: LIST
75827: LIST
75828: PUSH
75829: LD_INT 1
75831: NEG
75832: PUSH
75833: LD_INT 1
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: LD_INT 2
75842: NEG
75843: PUSH
75844: LD_INT 0
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PUSH
75851: LD_INT 2
75853: NEG
75854: PUSH
75855: LD_INT 1
75857: NEG
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: LIST
75867: LIST
75868: LIST
75869: LIST
75870: LIST
75871: LIST
75872: LIST
75873: LIST
75874: LIST
75875: LIST
75876: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75877: LD_ADDR_VAR 0 52
75881: PUSH
75882: LD_INT 0
75884: PUSH
75885: LD_INT 0
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 0
75894: PUSH
75895: LD_INT 1
75897: NEG
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: LD_INT 1
75905: PUSH
75906: LD_INT 0
75908: PUSH
75909: EMPTY
75910: LIST
75911: LIST
75912: PUSH
75913: LD_INT 1
75915: PUSH
75916: LD_INT 1
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 0
75925: PUSH
75926: LD_INT 1
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: PUSH
75933: LD_INT 1
75935: NEG
75936: PUSH
75937: LD_INT 0
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: LD_INT 1
75946: NEG
75947: PUSH
75948: LD_INT 1
75950: NEG
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 1
75958: NEG
75959: PUSH
75960: LD_INT 2
75962: NEG
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: PUSH
75968: LD_INT 1
75970: NEG
75971: PUSH
75972: LD_INT 1
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: LD_INT 2
75981: NEG
75982: PUSH
75983: LD_INT 0
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: PUSH
75990: LD_INT 2
75992: NEG
75993: PUSH
75994: LD_INT 1
75996: NEG
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: LD_INT 2
76004: NEG
76005: PUSH
76006: LD_INT 2
76008: NEG
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: LIST
76018: LIST
76019: LIST
76020: LIST
76021: LIST
76022: LIST
76023: LIST
76024: LIST
76025: LIST
76026: LIST
76027: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76028: LD_ADDR_VAR 0 53
76032: PUSH
76033: LD_INT 0
76035: PUSH
76036: LD_INT 0
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 0
76045: PUSH
76046: LD_INT 1
76048: NEG
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 1
76056: PUSH
76057: LD_INT 0
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 1
76066: PUSH
76067: LD_INT 1
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 0
76076: PUSH
76077: LD_INT 1
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 1
76086: NEG
76087: PUSH
76088: LD_INT 0
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 1
76097: NEG
76098: PUSH
76099: LD_INT 1
76101: NEG
76102: PUSH
76103: EMPTY
76104: LIST
76105: LIST
76106: PUSH
76107: LD_INT 1
76109: NEG
76110: PUSH
76111: LD_INT 2
76113: NEG
76114: PUSH
76115: EMPTY
76116: LIST
76117: LIST
76118: PUSH
76119: LD_INT 0
76121: PUSH
76122: LD_INT 2
76124: NEG
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 1
76132: PUSH
76133: LD_INT 1
76135: NEG
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: LD_INT 2
76143: PUSH
76144: LD_INT 0
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PUSH
76151: LD_INT 2
76153: PUSH
76154: LD_INT 1
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 2
76163: PUSH
76164: LD_INT 2
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 1
76173: PUSH
76174: LD_INT 2
76176: PUSH
76177: EMPTY
76178: LIST
76179: LIST
76180: PUSH
76181: LD_INT 0
76183: PUSH
76184: LD_INT 2
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: PUSH
76191: LD_INT 1
76193: NEG
76194: PUSH
76195: LD_INT 1
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 2
76204: NEG
76205: PUSH
76206: LD_INT 0
76208: PUSH
76209: EMPTY
76210: LIST
76211: LIST
76212: PUSH
76213: LD_INT 2
76215: NEG
76216: PUSH
76217: LD_INT 1
76219: NEG
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: LD_INT 2
76227: NEG
76228: PUSH
76229: LD_INT 2
76231: NEG
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: LIST
76241: LIST
76242: LIST
76243: LIST
76244: LIST
76245: LIST
76246: LIST
76247: LIST
76248: LIST
76249: LIST
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: LIST
76257: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76258: LD_ADDR_VAR 0 54
76262: PUSH
76263: LD_INT 0
76265: PUSH
76266: LD_INT 0
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 0
76275: PUSH
76276: LD_INT 1
76278: NEG
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 1
76286: PUSH
76287: LD_INT 0
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: LD_INT 1
76296: PUSH
76297: LD_INT 1
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: LD_INT 0
76306: PUSH
76307: LD_INT 1
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 1
76316: NEG
76317: PUSH
76318: LD_INT 0
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 1
76327: NEG
76328: PUSH
76329: LD_INT 1
76331: NEG
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 1
76339: NEG
76340: PUSH
76341: LD_INT 2
76343: NEG
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 0
76351: PUSH
76352: LD_INT 2
76354: NEG
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: PUSH
76360: LD_INT 1
76362: PUSH
76363: LD_INT 1
76365: NEG
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PUSH
76371: LD_INT 2
76373: PUSH
76374: LD_INT 0
76376: PUSH
76377: EMPTY
76378: LIST
76379: LIST
76380: PUSH
76381: LD_INT 2
76383: PUSH
76384: LD_INT 1
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PUSH
76391: LD_INT 2
76393: PUSH
76394: LD_INT 2
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 1
76403: PUSH
76404: LD_INT 2
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: LD_INT 0
76413: PUSH
76414: LD_INT 2
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: PUSH
76421: LD_INT 1
76423: NEG
76424: PUSH
76425: LD_INT 1
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PUSH
76432: LD_INT 2
76434: NEG
76435: PUSH
76436: LD_INT 0
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: LD_INT 2
76445: NEG
76446: PUSH
76447: LD_INT 1
76449: NEG
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PUSH
76455: LD_INT 2
76457: NEG
76458: PUSH
76459: LD_INT 2
76461: NEG
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: LIST
76471: LIST
76472: LIST
76473: LIST
76474: LIST
76475: LIST
76476: LIST
76477: LIST
76478: LIST
76479: LIST
76480: LIST
76481: LIST
76482: LIST
76483: LIST
76484: LIST
76485: LIST
76486: LIST
76487: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76488: LD_ADDR_VAR 0 55
76492: PUSH
76493: LD_INT 0
76495: PUSH
76496: LD_INT 0
76498: PUSH
76499: EMPTY
76500: LIST
76501: LIST
76502: PUSH
76503: LD_INT 0
76505: PUSH
76506: LD_INT 1
76508: NEG
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: PUSH
76514: LD_INT 1
76516: PUSH
76517: LD_INT 0
76519: PUSH
76520: EMPTY
76521: LIST
76522: LIST
76523: PUSH
76524: LD_INT 1
76526: PUSH
76527: LD_INT 1
76529: PUSH
76530: EMPTY
76531: LIST
76532: LIST
76533: PUSH
76534: LD_INT 0
76536: PUSH
76537: LD_INT 1
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: PUSH
76544: LD_INT 1
76546: NEG
76547: PUSH
76548: LD_INT 0
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: LD_INT 1
76561: NEG
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 1
76569: NEG
76570: PUSH
76571: LD_INT 2
76573: NEG
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: LD_INT 0
76581: PUSH
76582: LD_INT 2
76584: NEG
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 1
76592: PUSH
76593: LD_INT 1
76595: NEG
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: LD_INT 2
76603: PUSH
76604: LD_INT 0
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: PUSH
76611: LD_INT 2
76613: PUSH
76614: LD_INT 1
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 2
76623: PUSH
76624: LD_INT 2
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: LD_INT 1
76633: PUSH
76634: LD_INT 2
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 0
76643: PUSH
76644: LD_INT 2
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PUSH
76651: LD_INT 1
76653: NEG
76654: PUSH
76655: LD_INT 1
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 2
76664: NEG
76665: PUSH
76666: LD_INT 0
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: LD_INT 2
76675: NEG
76676: PUSH
76677: LD_INT 1
76679: NEG
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PUSH
76685: LD_INT 2
76687: NEG
76688: PUSH
76689: LD_INT 2
76691: NEG
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: LIST
76701: LIST
76702: LIST
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: LIST
76708: LIST
76709: LIST
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: LIST
76715: LIST
76716: LIST
76717: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76718: LD_ADDR_VAR 0 56
76722: PUSH
76723: LD_INT 0
76725: PUSH
76726: LD_INT 0
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PUSH
76733: LD_INT 0
76735: PUSH
76736: LD_INT 1
76738: NEG
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 1
76746: PUSH
76747: LD_INT 0
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 1
76756: PUSH
76757: LD_INT 1
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 0
76766: PUSH
76767: LD_INT 1
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 1
76776: NEG
76777: PUSH
76778: LD_INT 0
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 1
76787: NEG
76788: PUSH
76789: LD_INT 1
76791: NEG
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 1
76799: NEG
76800: PUSH
76801: LD_INT 2
76803: NEG
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: LD_INT 0
76811: PUSH
76812: LD_INT 2
76814: NEG
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: LD_INT 1
76822: PUSH
76823: LD_INT 1
76825: NEG
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PUSH
76831: LD_INT 2
76833: PUSH
76834: LD_INT 0
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: PUSH
76841: LD_INT 2
76843: PUSH
76844: LD_INT 1
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: PUSH
76851: LD_INT 2
76853: PUSH
76854: LD_INT 2
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: LD_INT 1
76863: PUSH
76864: LD_INT 2
76866: PUSH
76867: EMPTY
76868: LIST
76869: LIST
76870: PUSH
76871: LD_INT 0
76873: PUSH
76874: LD_INT 2
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 1
76883: NEG
76884: PUSH
76885: LD_INT 1
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 2
76894: NEG
76895: PUSH
76896: LD_INT 0
76898: PUSH
76899: EMPTY
76900: LIST
76901: LIST
76902: PUSH
76903: LD_INT 2
76905: NEG
76906: PUSH
76907: LD_INT 1
76909: NEG
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 2
76917: NEG
76918: PUSH
76919: LD_INT 2
76921: NEG
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: LIST
76931: LIST
76932: LIST
76933: LIST
76934: LIST
76935: LIST
76936: LIST
76937: LIST
76938: LIST
76939: LIST
76940: LIST
76941: LIST
76942: LIST
76943: LIST
76944: LIST
76945: LIST
76946: LIST
76947: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76948: LD_ADDR_VAR 0 57
76952: PUSH
76953: LD_INT 0
76955: PUSH
76956: LD_INT 0
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: PUSH
76963: LD_INT 0
76965: PUSH
76966: LD_INT 1
76968: NEG
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: PUSH
76974: LD_INT 1
76976: PUSH
76977: LD_INT 0
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: PUSH
76984: LD_INT 1
76986: PUSH
76987: LD_INT 1
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: PUSH
76994: LD_INT 0
76996: PUSH
76997: LD_INT 1
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 1
77006: NEG
77007: PUSH
77008: LD_INT 0
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 1
77017: NEG
77018: PUSH
77019: LD_INT 1
77021: NEG
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 1
77029: NEG
77030: PUSH
77031: LD_INT 2
77033: NEG
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: LD_INT 0
77041: PUSH
77042: LD_INT 2
77044: NEG
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: PUSH
77050: LD_INT 1
77052: PUSH
77053: LD_INT 1
77055: NEG
77056: PUSH
77057: EMPTY
77058: LIST
77059: LIST
77060: PUSH
77061: LD_INT 2
77063: PUSH
77064: LD_INT 0
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: PUSH
77071: LD_INT 2
77073: PUSH
77074: LD_INT 1
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: PUSH
77081: LD_INT 2
77083: PUSH
77084: LD_INT 2
77086: PUSH
77087: EMPTY
77088: LIST
77089: LIST
77090: PUSH
77091: LD_INT 1
77093: PUSH
77094: LD_INT 2
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PUSH
77101: LD_INT 0
77103: PUSH
77104: LD_INT 2
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: LD_INT 1
77113: NEG
77114: PUSH
77115: LD_INT 1
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 2
77124: NEG
77125: PUSH
77126: LD_INT 0
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 2
77135: NEG
77136: PUSH
77137: LD_INT 1
77139: NEG
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 2
77147: NEG
77148: PUSH
77149: LD_INT 2
77151: NEG
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: LIST
77161: LIST
77162: LIST
77163: LIST
77164: LIST
77165: LIST
77166: LIST
77167: LIST
77168: LIST
77169: LIST
77170: LIST
77171: LIST
77172: LIST
77173: LIST
77174: LIST
77175: LIST
77176: LIST
77177: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77178: LD_ADDR_VAR 0 58
77182: PUSH
77183: LD_INT 0
77185: PUSH
77186: LD_INT 0
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: PUSH
77193: LD_INT 0
77195: PUSH
77196: LD_INT 1
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 1
77206: PUSH
77207: LD_INT 0
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: LD_INT 1
77216: PUSH
77217: LD_INT 1
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PUSH
77224: LD_INT 0
77226: PUSH
77227: LD_INT 1
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 1
77236: NEG
77237: PUSH
77238: LD_INT 0
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: PUSH
77249: LD_INT 1
77251: NEG
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PUSH
77257: LD_INT 1
77259: NEG
77260: PUSH
77261: LD_INT 2
77263: NEG
77264: PUSH
77265: EMPTY
77266: LIST
77267: LIST
77268: PUSH
77269: LD_INT 0
77271: PUSH
77272: LD_INT 2
77274: NEG
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: PUSH
77280: LD_INT 1
77282: PUSH
77283: LD_INT 1
77285: NEG
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 2
77293: PUSH
77294: LD_INT 0
77296: PUSH
77297: EMPTY
77298: LIST
77299: LIST
77300: PUSH
77301: LD_INT 2
77303: PUSH
77304: LD_INT 1
77306: PUSH
77307: EMPTY
77308: LIST
77309: LIST
77310: PUSH
77311: LD_INT 2
77313: PUSH
77314: LD_INT 2
77316: PUSH
77317: EMPTY
77318: LIST
77319: LIST
77320: PUSH
77321: LD_INT 1
77323: PUSH
77324: LD_INT 2
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: PUSH
77331: LD_INT 0
77333: PUSH
77334: LD_INT 2
77336: PUSH
77337: EMPTY
77338: LIST
77339: LIST
77340: PUSH
77341: LD_INT 1
77343: NEG
77344: PUSH
77345: LD_INT 1
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 2
77354: NEG
77355: PUSH
77356: LD_INT 0
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: PUSH
77363: LD_INT 2
77365: NEG
77366: PUSH
77367: LD_INT 1
77369: NEG
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: LD_INT 2
77377: NEG
77378: PUSH
77379: LD_INT 2
77381: NEG
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: LIST
77391: LIST
77392: LIST
77393: LIST
77394: LIST
77395: LIST
77396: LIST
77397: LIST
77398: LIST
77399: LIST
77400: LIST
77401: LIST
77402: LIST
77403: LIST
77404: LIST
77405: LIST
77406: LIST
77407: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77408: LD_ADDR_VAR 0 59
77412: PUSH
77413: LD_INT 0
77415: PUSH
77416: LD_INT 0
77418: PUSH
77419: EMPTY
77420: LIST
77421: LIST
77422: PUSH
77423: LD_INT 0
77425: PUSH
77426: LD_INT 1
77428: NEG
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: PUSH
77434: LD_INT 1
77436: PUSH
77437: LD_INT 0
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: LD_INT 1
77446: PUSH
77447: LD_INT 1
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: PUSH
77454: LD_INT 0
77456: PUSH
77457: LD_INT 1
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: LD_INT 1
77466: NEG
77467: PUSH
77468: LD_INT 0
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: PUSH
77475: LD_INT 1
77477: NEG
77478: PUSH
77479: LD_INT 1
77481: NEG
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: LIST
77491: LIST
77492: LIST
77493: LIST
77494: LIST
77495: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77496: LD_ADDR_VAR 0 60
77500: PUSH
77501: LD_INT 0
77503: PUSH
77504: LD_INT 0
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 0
77513: PUSH
77514: LD_INT 1
77516: NEG
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 1
77524: PUSH
77525: LD_INT 0
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: PUSH
77532: LD_INT 1
77534: PUSH
77535: LD_INT 1
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 0
77544: PUSH
77545: LD_INT 1
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 1
77554: NEG
77555: PUSH
77556: LD_INT 0
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 1
77565: NEG
77566: PUSH
77567: LD_INT 1
77569: NEG
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77584: LD_ADDR_VAR 0 61
77588: PUSH
77589: LD_INT 0
77591: PUSH
77592: LD_INT 0
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 0
77601: PUSH
77602: LD_INT 1
77604: NEG
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 1
77612: PUSH
77613: LD_INT 0
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 1
77622: PUSH
77623: LD_INT 1
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PUSH
77630: LD_INT 0
77632: PUSH
77633: LD_INT 1
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: LD_INT 1
77642: NEG
77643: PUSH
77644: LD_INT 0
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_INT 1
77653: NEG
77654: PUSH
77655: LD_INT 1
77657: NEG
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77672: LD_ADDR_VAR 0 62
77676: PUSH
77677: LD_INT 0
77679: PUSH
77680: LD_INT 0
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_INT 0
77689: PUSH
77690: LD_INT 1
77692: NEG
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PUSH
77698: LD_INT 1
77700: PUSH
77701: LD_INT 0
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 1
77710: PUSH
77711: LD_INT 1
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 0
77720: PUSH
77721: LD_INT 1
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PUSH
77728: LD_INT 1
77730: NEG
77731: PUSH
77732: LD_INT 0
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 1
77741: NEG
77742: PUSH
77743: LD_INT 1
77745: NEG
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: LIST
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77760: LD_ADDR_VAR 0 63
77764: PUSH
77765: LD_INT 0
77767: PUSH
77768: LD_INT 0
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: PUSH
77775: LD_INT 0
77777: PUSH
77778: LD_INT 1
77780: NEG
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 1
77788: PUSH
77789: LD_INT 0
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: PUSH
77796: LD_INT 1
77798: PUSH
77799: LD_INT 1
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 0
77808: PUSH
77809: LD_INT 1
77811: PUSH
77812: EMPTY
77813: LIST
77814: LIST
77815: PUSH
77816: LD_INT 1
77818: NEG
77819: PUSH
77820: LD_INT 0
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PUSH
77827: LD_INT 1
77829: NEG
77830: PUSH
77831: LD_INT 1
77833: NEG
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: LIST
77843: LIST
77844: LIST
77845: LIST
77846: LIST
77847: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77848: LD_ADDR_VAR 0 64
77852: PUSH
77853: LD_INT 0
77855: PUSH
77856: LD_INT 0
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 0
77865: PUSH
77866: LD_INT 1
77868: NEG
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 1
77876: PUSH
77877: LD_INT 0
77879: PUSH
77880: EMPTY
77881: LIST
77882: LIST
77883: PUSH
77884: LD_INT 1
77886: PUSH
77887: LD_INT 1
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 0
77896: PUSH
77897: LD_INT 1
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PUSH
77904: LD_INT 1
77906: NEG
77907: PUSH
77908: LD_INT 0
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 1
77917: NEG
77918: PUSH
77919: LD_INT 1
77921: NEG
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: LIST
77931: LIST
77932: LIST
77933: LIST
77934: LIST
77935: ST_TO_ADDR
// end ; 1 :
77936: GO 83833
77938: LD_INT 1
77940: DOUBLE
77941: EQUAL
77942: IFTRUE 77946
77944: GO 80569
77946: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77947: LD_ADDR_VAR 0 11
77951: PUSH
77952: LD_INT 1
77954: NEG
77955: PUSH
77956: LD_INT 3
77958: NEG
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 0
77966: PUSH
77967: LD_INT 3
77969: NEG
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: LD_INT 1
77977: PUSH
77978: LD_INT 2
77980: NEG
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: LIST
77990: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77991: LD_ADDR_VAR 0 12
77995: PUSH
77996: LD_INT 2
77998: PUSH
77999: LD_INT 1
78001: NEG
78002: PUSH
78003: EMPTY
78004: LIST
78005: LIST
78006: PUSH
78007: LD_INT 3
78009: PUSH
78010: LD_INT 0
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: LD_INT 3
78019: PUSH
78020: LD_INT 1
78022: PUSH
78023: EMPTY
78024: LIST
78025: LIST
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: LIST
78031: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78032: LD_ADDR_VAR 0 13
78036: PUSH
78037: LD_INT 3
78039: PUSH
78040: LD_INT 2
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 3
78049: PUSH
78050: LD_INT 3
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 2
78059: PUSH
78060: LD_INT 3
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: LIST
78071: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78072: LD_ADDR_VAR 0 14
78076: PUSH
78077: LD_INT 1
78079: PUSH
78080: LD_INT 3
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: PUSH
78087: LD_INT 0
78089: PUSH
78090: LD_INT 3
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 1
78099: NEG
78100: PUSH
78101: LD_INT 2
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: LIST
78112: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78113: LD_ADDR_VAR 0 15
78117: PUSH
78118: LD_INT 2
78120: NEG
78121: PUSH
78122: LD_INT 1
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 3
78131: NEG
78132: PUSH
78133: LD_INT 0
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: PUSH
78140: LD_INT 3
78142: NEG
78143: PUSH
78144: LD_INT 1
78146: NEG
78147: PUSH
78148: EMPTY
78149: LIST
78150: LIST
78151: PUSH
78152: EMPTY
78153: LIST
78154: LIST
78155: LIST
78156: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78157: LD_ADDR_VAR 0 16
78161: PUSH
78162: LD_INT 2
78164: NEG
78165: PUSH
78166: LD_INT 3
78168: NEG
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: LD_INT 3
78176: NEG
78177: PUSH
78178: LD_INT 2
78180: NEG
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 3
78188: NEG
78189: PUSH
78190: LD_INT 3
78192: NEG
78193: PUSH
78194: EMPTY
78195: LIST
78196: LIST
78197: PUSH
78198: EMPTY
78199: LIST
78200: LIST
78201: LIST
78202: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78203: LD_ADDR_VAR 0 17
78207: PUSH
78208: LD_INT 1
78210: NEG
78211: PUSH
78212: LD_INT 3
78214: NEG
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PUSH
78220: LD_INT 0
78222: PUSH
78223: LD_INT 3
78225: NEG
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: PUSH
78231: LD_INT 1
78233: PUSH
78234: LD_INT 2
78236: NEG
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: LIST
78246: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78247: LD_ADDR_VAR 0 18
78251: PUSH
78252: LD_INT 2
78254: PUSH
78255: LD_INT 1
78257: NEG
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: LD_INT 3
78265: PUSH
78266: LD_INT 0
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: LD_INT 3
78275: PUSH
78276: LD_INT 1
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: LIST
78287: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78288: LD_ADDR_VAR 0 19
78292: PUSH
78293: LD_INT 3
78295: PUSH
78296: LD_INT 2
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: PUSH
78303: LD_INT 3
78305: PUSH
78306: LD_INT 3
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 2
78315: PUSH
78316: LD_INT 3
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: LIST
78327: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78328: LD_ADDR_VAR 0 20
78332: PUSH
78333: LD_INT 1
78335: PUSH
78336: LD_INT 3
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: LD_INT 0
78345: PUSH
78346: LD_INT 3
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 1
78355: NEG
78356: PUSH
78357: LD_INT 2
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: LIST
78368: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78369: LD_ADDR_VAR 0 21
78373: PUSH
78374: LD_INT 2
78376: NEG
78377: PUSH
78378: LD_INT 1
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 3
78387: NEG
78388: PUSH
78389: LD_INT 0
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 3
78398: NEG
78399: PUSH
78400: LD_INT 1
78402: NEG
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: LIST
78412: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78413: LD_ADDR_VAR 0 22
78417: PUSH
78418: LD_INT 2
78420: NEG
78421: PUSH
78422: LD_INT 3
78424: NEG
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 3
78432: NEG
78433: PUSH
78434: LD_INT 2
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 3
78444: NEG
78445: PUSH
78446: LD_INT 3
78448: NEG
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: LIST
78458: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78459: LD_ADDR_VAR 0 23
78463: PUSH
78464: LD_INT 0
78466: PUSH
78467: LD_INT 3
78469: NEG
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: LD_INT 1
78477: NEG
78478: PUSH
78479: LD_INT 4
78481: NEG
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: LD_INT 1
78489: PUSH
78490: LD_INT 3
78492: NEG
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: LIST
78502: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78503: LD_ADDR_VAR 0 24
78507: PUSH
78508: LD_INT 3
78510: PUSH
78511: LD_INT 0
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PUSH
78518: LD_INT 3
78520: PUSH
78521: LD_INT 1
78523: NEG
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 4
78531: PUSH
78532: LD_INT 1
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: LIST
78543: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78544: LD_ADDR_VAR 0 25
78548: PUSH
78549: LD_INT 3
78551: PUSH
78552: LD_INT 3
78554: PUSH
78555: EMPTY
78556: LIST
78557: LIST
78558: PUSH
78559: LD_INT 4
78561: PUSH
78562: LD_INT 3
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 3
78571: PUSH
78572: LD_INT 4
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: LIST
78583: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78584: LD_ADDR_VAR 0 26
78588: PUSH
78589: LD_INT 0
78591: PUSH
78592: LD_INT 3
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: PUSH
78599: LD_INT 1
78601: PUSH
78602: LD_INT 4
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: PUSH
78609: LD_INT 1
78611: NEG
78612: PUSH
78613: LD_INT 3
78615: PUSH
78616: EMPTY
78617: LIST
78618: LIST
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: LIST
78624: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78625: LD_ADDR_VAR 0 27
78629: PUSH
78630: LD_INT 3
78632: NEG
78633: PUSH
78634: LD_INT 0
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 3
78643: NEG
78644: PUSH
78645: LD_INT 1
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 4
78654: NEG
78655: PUSH
78656: LD_INT 1
78658: NEG
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: LIST
78668: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78669: LD_ADDR_VAR 0 28
78673: PUSH
78674: LD_INT 3
78676: NEG
78677: PUSH
78678: LD_INT 3
78680: NEG
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PUSH
78686: LD_INT 3
78688: NEG
78689: PUSH
78690: LD_INT 4
78692: NEG
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 4
78700: NEG
78701: PUSH
78702: LD_INT 3
78704: NEG
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: LIST
78714: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78715: LD_ADDR_VAR 0 29
78719: PUSH
78720: LD_INT 1
78722: NEG
78723: PUSH
78724: LD_INT 3
78726: NEG
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: LD_INT 0
78734: PUSH
78735: LD_INT 3
78737: NEG
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: PUSH
78743: LD_INT 1
78745: PUSH
78746: LD_INT 2
78748: NEG
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 1
78756: NEG
78757: PUSH
78758: LD_INT 4
78760: NEG
78761: PUSH
78762: EMPTY
78763: LIST
78764: LIST
78765: PUSH
78766: LD_INT 0
78768: PUSH
78769: LD_INT 4
78771: NEG
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 1
78779: PUSH
78780: LD_INT 3
78782: NEG
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 1
78790: NEG
78791: PUSH
78792: LD_INT 5
78794: NEG
78795: PUSH
78796: EMPTY
78797: LIST
78798: LIST
78799: PUSH
78800: LD_INT 0
78802: PUSH
78803: LD_INT 5
78805: NEG
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PUSH
78811: LD_INT 1
78813: PUSH
78814: LD_INT 4
78816: NEG
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: PUSH
78822: LD_INT 1
78824: NEG
78825: PUSH
78826: LD_INT 6
78828: NEG
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: LD_INT 0
78836: PUSH
78837: LD_INT 6
78839: NEG
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: LD_INT 1
78847: PUSH
78848: LD_INT 5
78850: NEG
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: LIST
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78870: LD_ADDR_VAR 0 30
78874: PUSH
78875: LD_INT 2
78877: PUSH
78878: LD_INT 1
78880: NEG
78881: PUSH
78882: EMPTY
78883: LIST
78884: LIST
78885: PUSH
78886: LD_INT 3
78888: PUSH
78889: LD_INT 0
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: PUSH
78896: LD_INT 3
78898: PUSH
78899: LD_INT 1
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 3
78908: PUSH
78909: LD_INT 1
78911: NEG
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 4
78919: PUSH
78920: LD_INT 0
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: PUSH
78927: LD_INT 4
78929: PUSH
78930: LD_INT 1
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 4
78939: PUSH
78940: LD_INT 1
78942: NEG
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PUSH
78948: LD_INT 5
78950: PUSH
78951: LD_INT 0
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 5
78960: PUSH
78961: LD_INT 1
78963: PUSH
78964: EMPTY
78965: LIST
78966: LIST
78967: PUSH
78968: LD_INT 5
78970: PUSH
78971: LD_INT 1
78973: NEG
78974: PUSH
78975: EMPTY
78976: LIST
78977: LIST
78978: PUSH
78979: LD_INT 6
78981: PUSH
78982: LD_INT 0
78984: PUSH
78985: EMPTY
78986: LIST
78987: LIST
78988: PUSH
78989: LD_INT 6
78991: PUSH
78992: LD_INT 1
78994: PUSH
78995: EMPTY
78996: LIST
78997: LIST
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: LIST
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: LIST
79012: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
79013: LD_ADDR_VAR 0 31
79017: PUSH
79018: LD_INT 3
79020: PUSH
79021: LD_INT 2
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 3
79030: PUSH
79031: LD_INT 3
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 2
79040: PUSH
79041: LD_INT 3
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 4
79050: PUSH
79051: LD_INT 3
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 4
79060: PUSH
79061: LD_INT 4
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 3
79070: PUSH
79071: LD_INT 4
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PUSH
79078: LD_INT 5
79080: PUSH
79081: LD_INT 4
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 5
79090: PUSH
79091: LD_INT 5
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: LD_INT 4
79100: PUSH
79101: LD_INT 5
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: LD_INT 6
79110: PUSH
79111: LD_INT 5
79113: PUSH
79114: EMPTY
79115: LIST
79116: LIST
79117: PUSH
79118: LD_INT 6
79120: PUSH
79121: LD_INT 6
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 5
79130: PUSH
79131: LD_INT 6
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: LIST
79142: LIST
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79152: LD_ADDR_VAR 0 32
79156: PUSH
79157: LD_INT 1
79159: PUSH
79160: LD_INT 3
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 0
79169: PUSH
79170: LD_INT 3
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 1
79179: NEG
79180: PUSH
79181: LD_INT 2
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PUSH
79188: LD_INT 1
79190: PUSH
79191: LD_INT 4
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 0
79200: PUSH
79201: LD_INT 4
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PUSH
79208: LD_INT 1
79210: NEG
79211: PUSH
79212: LD_INT 3
79214: PUSH
79215: EMPTY
79216: LIST
79217: LIST
79218: PUSH
79219: LD_INT 1
79221: PUSH
79222: LD_INT 5
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 0
79231: PUSH
79232: LD_INT 5
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 1
79241: NEG
79242: PUSH
79243: LD_INT 4
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 1
79252: PUSH
79253: LD_INT 6
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 0
79262: PUSH
79263: LD_INT 6
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PUSH
79270: LD_INT 1
79272: NEG
79273: PUSH
79274: LD_INT 5
79276: PUSH
79277: EMPTY
79278: LIST
79279: LIST
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: LIST
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79295: LD_ADDR_VAR 0 33
79299: PUSH
79300: LD_INT 2
79302: NEG
79303: PUSH
79304: LD_INT 1
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 3
79313: NEG
79314: PUSH
79315: LD_INT 0
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 3
79324: NEG
79325: PUSH
79326: LD_INT 1
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 3
79336: NEG
79337: PUSH
79338: LD_INT 1
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 4
79347: NEG
79348: PUSH
79349: LD_INT 0
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 4
79358: NEG
79359: PUSH
79360: LD_INT 1
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 4
79370: NEG
79371: PUSH
79372: LD_INT 1
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 5
79381: NEG
79382: PUSH
79383: LD_INT 0
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: PUSH
79390: LD_INT 5
79392: NEG
79393: PUSH
79394: LD_INT 1
79396: NEG
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: LD_INT 5
79404: NEG
79405: PUSH
79406: LD_INT 1
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: PUSH
79413: LD_INT 6
79415: NEG
79416: PUSH
79417: LD_INT 0
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 6
79426: NEG
79427: PUSH
79428: LD_INT 1
79430: NEG
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79450: LD_ADDR_VAR 0 34
79454: PUSH
79455: LD_INT 2
79457: NEG
79458: PUSH
79459: LD_INT 3
79461: NEG
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 3
79469: NEG
79470: PUSH
79471: LD_INT 2
79473: NEG
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 3
79481: NEG
79482: PUSH
79483: LD_INT 3
79485: NEG
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 3
79493: NEG
79494: PUSH
79495: LD_INT 4
79497: NEG
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 4
79505: NEG
79506: PUSH
79507: LD_INT 3
79509: NEG
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 4
79517: NEG
79518: PUSH
79519: LD_INT 4
79521: NEG
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 4
79529: NEG
79530: PUSH
79531: LD_INT 5
79533: NEG
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 5
79541: NEG
79542: PUSH
79543: LD_INT 4
79545: NEG
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: PUSH
79551: LD_INT 5
79553: NEG
79554: PUSH
79555: LD_INT 5
79557: NEG
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PUSH
79563: LD_INT 5
79565: NEG
79566: PUSH
79567: LD_INT 6
79569: NEG
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 6
79577: NEG
79578: PUSH
79579: LD_INT 5
79581: NEG
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 6
79589: NEG
79590: PUSH
79591: LD_INT 6
79593: NEG
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79613: LD_ADDR_VAR 0 41
79617: PUSH
79618: LD_INT 0
79620: PUSH
79621: LD_INT 2
79623: NEG
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: LD_INT 3
79635: NEG
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_INT 1
79643: PUSH
79644: LD_INT 2
79646: NEG
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: LIST
79656: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79657: LD_ADDR_VAR 0 42
79661: PUSH
79662: LD_INT 2
79664: PUSH
79665: LD_INT 0
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 2
79674: PUSH
79675: LD_INT 1
79677: NEG
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 3
79685: PUSH
79686: LD_INT 1
79688: PUSH
79689: EMPTY
79690: LIST
79691: LIST
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: LIST
79697: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79698: LD_ADDR_VAR 0 43
79702: PUSH
79703: LD_INT 2
79705: PUSH
79706: LD_INT 2
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 3
79715: PUSH
79716: LD_INT 2
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 2
79725: PUSH
79726: LD_INT 3
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: LIST
79737: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79738: LD_ADDR_VAR 0 44
79742: PUSH
79743: LD_INT 0
79745: PUSH
79746: LD_INT 2
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 1
79755: PUSH
79756: LD_INT 3
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 1
79765: NEG
79766: PUSH
79767: LD_INT 2
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: LIST
79778: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79779: LD_ADDR_VAR 0 45
79783: PUSH
79784: LD_INT 2
79786: NEG
79787: PUSH
79788: LD_INT 0
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 2
79797: NEG
79798: PUSH
79799: LD_INT 1
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: LD_INT 3
79808: NEG
79809: PUSH
79810: LD_INT 1
79812: NEG
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: LIST
79822: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79823: LD_ADDR_VAR 0 46
79827: PUSH
79828: LD_INT 2
79830: NEG
79831: PUSH
79832: LD_INT 2
79834: NEG
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 2
79842: NEG
79843: PUSH
79844: LD_INT 3
79846: NEG
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 3
79854: NEG
79855: PUSH
79856: LD_INT 2
79858: NEG
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: LIST
79868: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79869: LD_ADDR_VAR 0 47
79873: PUSH
79874: LD_INT 2
79876: NEG
79877: PUSH
79878: LD_INT 3
79880: NEG
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 1
79888: NEG
79889: PUSH
79890: LD_INT 3
79892: NEG
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79902: LD_ADDR_VAR 0 48
79906: PUSH
79907: LD_INT 1
79909: PUSH
79910: LD_INT 2
79912: NEG
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 2
79920: PUSH
79921: LD_INT 1
79923: NEG
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79933: LD_ADDR_VAR 0 49
79937: PUSH
79938: LD_INT 3
79940: PUSH
79941: LD_INT 1
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 3
79950: PUSH
79951: LD_INT 2
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79962: LD_ADDR_VAR 0 50
79966: PUSH
79967: LD_INT 2
79969: PUSH
79970: LD_INT 3
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 1
79979: PUSH
79980: LD_INT 3
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79991: LD_ADDR_VAR 0 51
79995: PUSH
79996: LD_INT 1
79998: NEG
79999: PUSH
80000: LD_INT 2
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 2
80009: NEG
80010: PUSH
80011: LD_INT 1
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80022: LD_ADDR_VAR 0 52
80026: PUSH
80027: LD_INT 3
80029: NEG
80030: PUSH
80031: LD_INT 1
80033: NEG
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 3
80041: NEG
80042: PUSH
80043: LD_INT 2
80045: NEG
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80055: LD_ADDR_VAR 0 53
80059: PUSH
80060: LD_INT 1
80062: NEG
80063: PUSH
80064: LD_INT 3
80066: NEG
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: PUSH
80072: LD_INT 0
80074: PUSH
80075: LD_INT 3
80077: NEG
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: LD_INT 1
80085: PUSH
80086: LD_INT 2
80088: NEG
80089: PUSH
80090: EMPTY
80091: LIST
80092: LIST
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: LIST
80098: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80099: LD_ADDR_VAR 0 54
80103: PUSH
80104: LD_INT 2
80106: PUSH
80107: LD_INT 1
80109: NEG
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: PUSH
80115: LD_INT 3
80117: PUSH
80118: LD_INT 0
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 3
80127: PUSH
80128: LD_INT 1
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: LIST
80139: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80140: LD_ADDR_VAR 0 55
80144: PUSH
80145: LD_INT 3
80147: PUSH
80148: LD_INT 2
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: LD_INT 3
80157: PUSH
80158: LD_INT 3
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: LD_INT 2
80167: PUSH
80168: LD_INT 3
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: LIST
80179: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80180: LD_ADDR_VAR 0 56
80184: PUSH
80185: LD_INT 1
80187: PUSH
80188: LD_INT 3
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 0
80197: PUSH
80198: LD_INT 3
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 1
80207: NEG
80208: PUSH
80209: LD_INT 2
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: LIST
80220: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80221: LD_ADDR_VAR 0 57
80225: PUSH
80226: LD_INT 2
80228: NEG
80229: PUSH
80230: LD_INT 1
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 3
80239: NEG
80240: PUSH
80241: LD_INT 0
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 3
80250: NEG
80251: PUSH
80252: LD_INT 1
80254: NEG
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: LIST
80264: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80265: LD_ADDR_VAR 0 58
80269: PUSH
80270: LD_INT 2
80272: NEG
80273: PUSH
80274: LD_INT 3
80276: NEG
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 3
80284: NEG
80285: PUSH
80286: LD_INT 2
80288: NEG
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 3
80296: NEG
80297: PUSH
80298: LD_INT 3
80300: NEG
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: LIST
80310: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80311: LD_ADDR_VAR 0 59
80315: PUSH
80316: LD_INT 1
80318: NEG
80319: PUSH
80320: LD_INT 2
80322: NEG
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 0
80330: PUSH
80331: LD_INT 2
80333: NEG
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 1
80341: PUSH
80342: LD_INT 1
80344: NEG
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: LIST
80354: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80355: LD_ADDR_VAR 0 60
80359: PUSH
80360: LD_INT 1
80362: PUSH
80363: LD_INT 1
80365: NEG
80366: PUSH
80367: EMPTY
80368: LIST
80369: LIST
80370: PUSH
80371: LD_INT 2
80373: PUSH
80374: LD_INT 0
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 2
80383: PUSH
80384: LD_INT 1
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: LIST
80395: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80396: LD_ADDR_VAR 0 61
80400: PUSH
80401: LD_INT 2
80403: PUSH
80404: LD_INT 1
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 2
80413: PUSH
80414: LD_INT 2
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PUSH
80421: LD_INT 1
80423: PUSH
80424: LD_INT 2
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: LIST
80435: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80436: LD_ADDR_VAR 0 62
80440: PUSH
80441: LD_INT 1
80443: PUSH
80444: LD_INT 2
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 0
80453: PUSH
80454: LD_INT 2
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 1
80463: NEG
80464: PUSH
80465: LD_INT 1
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: EMPTY
80473: LIST
80474: LIST
80475: LIST
80476: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80477: LD_ADDR_VAR 0 63
80481: PUSH
80482: LD_INT 1
80484: NEG
80485: PUSH
80486: LD_INT 1
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 2
80495: NEG
80496: PUSH
80497: LD_INT 0
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 2
80506: NEG
80507: PUSH
80508: LD_INT 1
80510: NEG
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: LIST
80520: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80521: LD_ADDR_VAR 0 64
80525: PUSH
80526: LD_INT 1
80528: NEG
80529: PUSH
80530: LD_INT 2
80532: NEG
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PUSH
80538: LD_INT 2
80540: NEG
80541: PUSH
80542: LD_INT 1
80544: NEG
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 2
80552: NEG
80553: PUSH
80554: LD_INT 2
80556: NEG
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: LIST
80566: ST_TO_ADDR
// end ; 2 :
80567: GO 83833
80569: LD_INT 2
80571: DOUBLE
80572: EQUAL
80573: IFTRUE 80577
80575: GO 83832
80577: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80578: LD_ADDR_VAR 0 29
80582: PUSH
80583: LD_INT 4
80585: PUSH
80586: LD_INT 0
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: LD_INT 4
80595: PUSH
80596: LD_INT 1
80598: NEG
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 5
80606: PUSH
80607: LD_INT 0
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: LD_INT 5
80616: PUSH
80617: LD_INT 1
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 4
80626: PUSH
80627: LD_INT 1
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: PUSH
80634: LD_INT 3
80636: PUSH
80637: LD_INT 0
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 3
80646: PUSH
80647: LD_INT 1
80649: NEG
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 3
80657: PUSH
80658: LD_INT 2
80660: NEG
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 5
80668: PUSH
80669: LD_INT 2
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 3
80678: PUSH
80679: LD_INT 3
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 3
80688: PUSH
80689: LD_INT 2
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 4
80698: PUSH
80699: LD_INT 3
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: LD_INT 4
80708: PUSH
80709: LD_INT 4
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 3
80718: PUSH
80719: LD_INT 4
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 2
80728: PUSH
80729: LD_INT 3
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 2
80738: PUSH
80739: LD_INT 2
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: LD_INT 4
80748: PUSH
80749: LD_INT 2
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: LD_INT 2
80758: PUSH
80759: LD_INT 4
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 0
80768: PUSH
80769: LD_INT 4
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 0
80778: PUSH
80779: LD_INT 3
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 1
80788: PUSH
80789: LD_INT 4
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 1
80798: PUSH
80799: LD_INT 5
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 5
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 1
80818: NEG
80819: PUSH
80820: LD_INT 4
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: LD_INT 3
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 2
80840: PUSH
80841: LD_INT 5
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 2
80850: NEG
80851: PUSH
80852: LD_INT 3
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 3
80861: NEG
80862: PUSH
80863: LD_INT 0
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 3
80872: NEG
80873: PUSH
80874: LD_INT 1
80876: NEG
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 2
80884: NEG
80885: PUSH
80886: LD_INT 0
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 2
80895: NEG
80896: PUSH
80897: LD_INT 1
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 3
80906: NEG
80907: PUSH
80908: LD_INT 1
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 4
80917: NEG
80918: PUSH
80919: LD_INT 0
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 4
80928: NEG
80929: PUSH
80930: LD_INT 1
80932: NEG
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 4
80940: NEG
80941: PUSH
80942: LD_INT 2
80944: NEG
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 2
80952: NEG
80953: PUSH
80954: LD_INT 2
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 4
80963: NEG
80964: PUSH
80965: LD_INT 4
80967: NEG
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: LD_INT 4
80975: NEG
80976: PUSH
80977: LD_INT 5
80979: NEG
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 3
80987: NEG
80988: PUSH
80989: LD_INT 4
80991: NEG
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 3
80999: NEG
81000: PUSH
81001: LD_INT 3
81003: NEG
81004: PUSH
81005: EMPTY
81006: LIST
81007: LIST
81008: PUSH
81009: LD_INT 4
81011: NEG
81012: PUSH
81013: LD_INT 3
81015: NEG
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 5
81023: NEG
81024: PUSH
81025: LD_INT 4
81027: NEG
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 5
81035: NEG
81036: PUSH
81037: LD_INT 5
81039: NEG
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 3
81047: NEG
81048: PUSH
81049: LD_INT 5
81051: NEG
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: PUSH
81057: LD_INT 5
81059: NEG
81060: PUSH
81061: LD_INT 3
81063: NEG
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: LIST
81097: LIST
81098: LIST
81099: LIST
81100: LIST
81101: LIST
81102: LIST
81103: LIST
81104: LIST
81105: LIST
81106: LIST
81107: LIST
81108: LIST
81109: LIST
81110: LIST
81111: LIST
81112: LIST
81113: LIST
81114: LIST
81115: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
81116: LD_ADDR_VAR 0 30
81120: PUSH
81121: LD_INT 4
81123: PUSH
81124: LD_INT 4
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 4
81133: PUSH
81134: LD_INT 3
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 5
81143: PUSH
81144: LD_INT 4
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 5
81153: PUSH
81154: LD_INT 5
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 4
81163: PUSH
81164: LD_INT 5
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 3
81173: PUSH
81174: LD_INT 4
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: PUSH
81181: LD_INT 3
81183: PUSH
81184: LD_INT 3
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: PUSH
81191: LD_INT 5
81193: PUSH
81194: LD_INT 3
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: LD_INT 3
81203: PUSH
81204: LD_INT 5
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: PUSH
81211: LD_INT 0
81213: PUSH
81214: LD_INT 3
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 0
81223: PUSH
81224: LD_INT 2
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 1
81233: PUSH
81234: LD_INT 3
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: PUSH
81241: LD_INT 1
81243: PUSH
81244: LD_INT 4
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: PUSH
81251: LD_INT 0
81253: PUSH
81254: LD_INT 4
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 1
81263: NEG
81264: PUSH
81265: LD_INT 3
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: LD_INT 1
81274: NEG
81275: PUSH
81276: LD_INT 2
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 2
81285: PUSH
81286: LD_INT 4
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: LD_INT 2
81295: NEG
81296: PUSH
81297: LD_INT 2
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 4
81306: NEG
81307: PUSH
81308: LD_INT 0
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 4
81317: NEG
81318: PUSH
81319: LD_INT 1
81321: NEG
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 3
81329: NEG
81330: PUSH
81331: LD_INT 0
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 3
81340: NEG
81341: PUSH
81342: LD_INT 1
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 4
81351: NEG
81352: PUSH
81353: LD_INT 1
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 5
81362: NEG
81363: PUSH
81364: LD_INT 0
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 5
81373: NEG
81374: PUSH
81375: LD_INT 1
81377: NEG
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 5
81385: NEG
81386: PUSH
81387: LD_INT 2
81389: NEG
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 3
81397: NEG
81398: PUSH
81399: LD_INT 2
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 3
81408: NEG
81409: PUSH
81410: LD_INT 3
81412: NEG
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 3
81420: NEG
81421: PUSH
81422: LD_INT 4
81424: NEG
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 2
81432: NEG
81433: PUSH
81434: LD_INT 3
81436: NEG
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 2
81444: NEG
81445: PUSH
81446: LD_INT 2
81448: NEG
81449: PUSH
81450: EMPTY
81451: LIST
81452: LIST
81453: PUSH
81454: LD_INT 3
81456: NEG
81457: PUSH
81458: LD_INT 2
81460: NEG
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PUSH
81466: LD_INT 4
81468: NEG
81469: PUSH
81470: LD_INT 3
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 4
81480: NEG
81481: PUSH
81482: LD_INT 4
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 2
81492: NEG
81493: PUSH
81494: LD_INT 4
81496: NEG
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 4
81504: NEG
81505: PUSH
81506: LD_INT 2
81508: NEG
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: LD_INT 0
81516: PUSH
81517: LD_INT 4
81519: NEG
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 0
81527: PUSH
81528: LD_INT 5
81530: NEG
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 1
81538: PUSH
81539: LD_INT 4
81541: NEG
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 1
81549: PUSH
81550: LD_INT 3
81552: NEG
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 0
81560: PUSH
81561: LD_INT 3
81563: NEG
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 1
81571: NEG
81572: PUSH
81573: LD_INT 4
81575: NEG
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: PUSH
81581: LD_INT 1
81583: NEG
81584: PUSH
81585: LD_INT 5
81587: NEG
81588: PUSH
81589: EMPTY
81590: LIST
81591: LIST
81592: PUSH
81593: LD_INT 2
81595: PUSH
81596: LD_INT 3
81598: NEG
81599: PUSH
81600: EMPTY
81601: LIST
81602: LIST
81603: PUSH
81604: LD_INT 2
81606: NEG
81607: PUSH
81608: LD_INT 5
81610: NEG
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: EMPTY
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: LIST
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: LIST
81642: LIST
81643: LIST
81644: LIST
81645: LIST
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: LIST
81659: LIST
81660: LIST
81661: LIST
81662: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81663: LD_ADDR_VAR 0 31
81667: PUSH
81668: LD_INT 0
81670: PUSH
81671: LD_INT 4
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 0
81680: PUSH
81681: LD_INT 3
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: LD_INT 1
81690: PUSH
81691: LD_INT 4
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 1
81700: PUSH
81701: LD_INT 5
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 0
81710: PUSH
81711: LD_INT 5
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 1
81720: NEG
81721: PUSH
81722: LD_INT 4
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 1
81731: NEG
81732: PUSH
81733: LD_INT 3
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 2
81742: PUSH
81743: LD_INT 5
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 2
81752: NEG
81753: PUSH
81754: LD_INT 3
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 3
81763: NEG
81764: PUSH
81765: LD_INT 0
81767: PUSH
81768: EMPTY
81769: LIST
81770: LIST
81771: PUSH
81772: LD_INT 3
81774: NEG
81775: PUSH
81776: LD_INT 1
81778: NEG
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: PUSH
81784: LD_INT 2
81786: NEG
81787: PUSH
81788: LD_INT 0
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 2
81797: NEG
81798: PUSH
81799: LD_INT 1
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 3
81808: NEG
81809: PUSH
81810: LD_INT 1
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 4
81819: NEG
81820: PUSH
81821: LD_INT 0
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 4
81830: NEG
81831: PUSH
81832: LD_INT 1
81834: NEG
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 4
81842: NEG
81843: PUSH
81844: LD_INT 2
81846: NEG
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 2
81854: NEG
81855: PUSH
81856: LD_INT 2
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: LD_INT 4
81865: NEG
81866: PUSH
81867: LD_INT 4
81869: NEG
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 4
81877: NEG
81878: PUSH
81879: LD_INT 5
81881: NEG
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 3
81889: NEG
81890: PUSH
81891: LD_INT 4
81893: NEG
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 3
81901: NEG
81902: PUSH
81903: LD_INT 3
81905: NEG
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 4
81913: NEG
81914: PUSH
81915: LD_INT 3
81917: NEG
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 5
81925: NEG
81926: PUSH
81927: LD_INT 4
81929: NEG
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 5
81937: NEG
81938: PUSH
81939: LD_INT 5
81941: NEG
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 3
81949: NEG
81950: PUSH
81951: LD_INT 5
81953: NEG
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: PUSH
81959: LD_INT 5
81961: NEG
81962: PUSH
81963: LD_INT 3
81965: NEG
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: PUSH
81971: LD_INT 0
81973: PUSH
81974: LD_INT 3
81976: NEG
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: PUSH
81982: LD_INT 0
81984: PUSH
81985: LD_INT 4
81987: NEG
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PUSH
81993: LD_INT 1
81995: PUSH
81996: LD_INT 3
81998: NEG
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 1
82006: PUSH
82007: LD_INT 2
82009: NEG
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 0
82017: PUSH
82018: LD_INT 2
82020: NEG
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: LD_INT 1
82028: NEG
82029: PUSH
82030: LD_INT 3
82032: NEG
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 1
82040: NEG
82041: PUSH
82042: LD_INT 4
82044: NEG
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 2
82052: PUSH
82053: LD_INT 2
82055: NEG
82056: PUSH
82057: EMPTY
82058: LIST
82059: LIST
82060: PUSH
82061: LD_INT 2
82063: NEG
82064: PUSH
82065: LD_INT 4
82067: NEG
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 4
82075: PUSH
82076: LD_INT 0
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 4
82085: PUSH
82086: LD_INT 1
82088: NEG
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PUSH
82094: LD_INT 5
82096: PUSH
82097: LD_INT 0
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 5
82106: PUSH
82107: LD_INT 1
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 4
82116: PUSH
82117: LD_INT 1
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: PUSH
82124: LD_INT 3
82126: PUSH
82127: LD_INT 0
82129: PUSH
82130: EMPTY
82131: LIST
82132: LIST
82133: PUSH
82134: LD_INT 3
82136: PUSH
82137: LD_INT 1
82139: NEG
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: LD_INT 3
82147: PUSH
82148: LD_INT 2
82150: NEG
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 5
82158: PUSH
82159: LD_INT 2
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: LIST
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: LIST
82209: LIST
82210: LIST
82211: LIST
82212: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82213: LD_ADDR_VAR 0 32
82217: PUSH
82218: LD_INT 4
82220: NEG
82221: PUSH
82222: LD_INT 0
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 4
82231: NEG
82232: PUSH
82233: LD_INT 1
82235: NEG
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 3
82243: NEG
82244: PUSH
82245: LD_INT 0
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 3
82254: NEG
82255: PUSH
82256: LD_INT 1
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 4
82265: NEG
82266: PUSH
82267: LD_INT 1
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 5
82276: NEG
82277: PUSH
82278: LD_INT 0
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PUSH
82285: LD_INT 5
82287: NEG
82288: PUSH
82289: LD_INT 1
82291: NEG
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PUSH
82297: LD_INT 5
82299: NEG
82300: PUSH
82301: LD_INT 2
82303: NEG
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: PUSH
82309: LD_INT 3
82311: NEG
82312: PUSH
82313: LD_INT 2
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: LD_INT 3
82322: NEG
82323: PUSH
82324: LD_INT 3
82326: NEG
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 3
82334: NEG
82335: PUSH
82336: LD_INT 4
82338: NEG
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: LD_INT 2
82346: NEG
82347: PUSH
82348: LD_INT 3
82350: NEG
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 2
82358: NEG
82359: PUSH
82360: LD_INT 2
82362: NEG
82363: PUSH
82364: EMPTY
82365: LIST
82366: LIST
82367: PUSH
82368: LD_INT 3
82370: NEG
82371: PUSH
82372: LD_INT 2
82374: NEG
82375: PUSH
82376: EMPTY
82377: LIST
82378: LIST
82379: PUSH
82380: LD_INT 4
82382: NEG
82383: PUSH
82384: LD_INT 3
82386: NEG
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 4
82394: NEG
82395: PUSH
82396: LD_INT 4
82398: NEG
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 2
82406: NEG
82407: PUSH
82408: LD_INT 4
82410: NEG
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 4
82418: NEG
82419: PUSH
82420: LD_INT 2
82422: NEG
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 0
82430: PUSH
82431: LD_INT 4
82433: NEG
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 0
82441: PUSH
82442: LD_INT 5
82444: NEG
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 1
82452: PUSH
82453: LD_INT 4
82455: NEG
82456: PUSH
82457: EMPTY
82458: LIST
82459: LIST
82460: PUSH
82461: LD_INT 1
82463: PUSH
82464: LD_INT 3
82466: NEG
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 0
82474: PUSH
82475: LD_INT 3
82477: NEG
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 1
82485: NEG
82486: PUSH
82487: LD_INT 4
82489: NEG
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 1
82497: NEG
82498: PUSH
82499: LD_INT 5
82501: NEG
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 2
82509: PUSH
82510: LD_INT 3
82512: NEG
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 2
82520: NEG
82521: PUSH
82522: LD_INT 5
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 3
82532: PUSH
82533: LD_INT 0
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 3
82542: PUSH
82543: LD_INT 1
82545: NEG
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 4
82553: PUSH
82554: LD_INT 0
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 4
82563: PUSH
82564: LD_INT 1
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 3
82573: PUSH
82574: LD_INT 1
82576: PUSH
82577: EMPTY
82578: LIST
82579: LIST
82580: PUSH
82581: LD_INT 2
82583: PUSH
82584: LD_INT 0
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PUSH
82591: LD_INT 2
82593: PUSH
82594: LD_INT 1
82596: NEG
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 2
82604: PUSH
82605: LD_INT 2
82607: NEG
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 4
82615: PUSH
82616: LD_INT 2
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 4
82625: PUSH
82626: LD_INT 4
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: LD_INT 4
82635: PUSH
82636: LD_INT 3
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 5
82645: PUSH
82646: LD_INT 4
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: LD_INT 5
82655: PUSH
82656: LD_INT 5
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: LD_INT 4
82665: PUSH
82666: LD_INT 5
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 3
82675: PUSH
82676: LD_INT 4
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 3
82685: PUSH
82686: LD_INT 3
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 5
82695: PUSH
82696: LD_INT 3
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 3
82705: PUSH
82706: LD_INT 5
82708: PUSH
82709: EMPTY
82710: LIST
82711: LIST
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: LIST
82746: LIST
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: LIST
82752: LIST
82753: LIST
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: LIST
82759: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82760: LD_ADDR_VAR 0 33
82764: PUSH
82765: LD_INT 4
82767: NEG
82768: PUSH
82769: LD_INT 4
82771: NEG
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 4
82779: NEG
82780: PUSH
82781: LD_INT 5
82783: NEG
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 3
82791: NEG
82792: PUSH
82793: LD_INT 4
82795: NEG
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 3
82803: NEG
82804: PUSH
82805: LD_INT 3
82807: NEG
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: PUSH
82813: LD_INT 4
82815: NEG
82816: PUSH
82817: LD_INT 3
82819: NEG
82820: PUSH
82821: EMPTY
82822: LIST
82823: LIST
82824: PUSH
82825: LD_INT 5
82827: NEG
82828: PUSH
82829: LD_INT 4
82831: NEG
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 5
82839: NEG
82840: PUSH
82841: LD_INT 5
82843: NEG
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 3
82851: NEG
82852: PUSH
82853: LD_INT 5
82855: NEG
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PUSH
82861: LD_INT 5
82863: NEG
82864: PUSH
82865: LD_INT 3
82867: NEG
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 0
82875: PUSH
82876: LD_INT 3
82878: NEG
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 0
82886: PUSH
82887: LD_INT 4
82889: NEG
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: LD_INT 1
82897: PUSH
82898: LD_INT 3
82900: NEG
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 1
82908: PUSH
82909: LD_INT 2
82911: NEG
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 0
82919: PUSH
82920: LD_INT 2
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 1
82930: NEG
82931: PUSH
82932: LD_INT 3
82934: NEG
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 1
82942: NEG
82943: PUSH
82944: LD_INT 4
82946: NEG
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 2
82954: PUSH
82955: LD_INT 2
82957: NEG
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 2
82965: NEG
82966: PUSH
82967: LD_INT 4
82969: NEG
82970: PUSH
82971: EMPTY
82972: LIST
82973: LIST
82974: PUSH
82975: LD_INT 4
82977: PUSH
82978: LD_INT 0
82980: PUSH
82981: EMPTY
82982: LIST
82983: LIST
82984: PUSH
82985: LD_INT 4
82987: PUSH
82988: LD_INT 1
82990: NEG
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: PUSH
82996: LD_INT 5
82998: PUSH
82999: LD_INT 0
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PUSH
83006: LD_INT 5
83008: PUSH
83009: LD_INT 1
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 4
83018: PUSH
83019: LD_INT 1
83021: PUSH
83022: EMPTY
83023: LIST
83024: LIST
83025: PUSH
83026: LD_INT 3
83028: PUSH
83029: LD_INT 0
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: LD_INT 3
83038: PUSH
83039: LD_INT 1
83041: NEG
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PUSH
83047: LD_INT 3
83049: PUSH
83050: LD_INT 2
83052: NEG
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: PUSH
83058: LD_INT 5
83060: PUSH
83061: LD_INT 2
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: PUSH
83068: LD_INT 3
83070: PUSH
83071: LD_INT 3
83073: PUSH
83074: EMPTY
83075: LIST
83076: LIST
83077: PUSH
83078: LD_INT 3
83080: PUSH
83081: LD_INT 2
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PUSH
83088: LD_INT 4
83090: PUSH
83091: LD_INT 3
83093: PUSH
83094: EMPTY
83095: LIST
83096: LIST
83097: PUSH
83098: LD_INT 4
83100: PUSH
83101: LD_INT 4
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: PUSH
83108: LD_INT 3
83110: PUSH
83111: LD_INT 4
83113: PUSH
83114: EMPTY
83115: LIST
83116: LIST
83117: PUSH
83118: LD_INT 2
83120: PUSH
83121: LD_INT 3
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 2
83130: PUSH
83131: LD_INT 2
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 4
83140: PUSH
83141: LD_INT 2
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 2
83150: PUSH
83151: LD_INT 4
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 0
83160: PUSH
83161: LD_INT 4
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 0
83170: PUSH
83171: LD_INT 3
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 1
83180: PUSH
83181: LD_INT 4
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 1
83190: PUSH
83191: LD_INT 5
83193: PUSH
83194: EMPTY
83195: LIST
83196: LIST
83197: PUSH
83198: LD_INT 0
83200: PUSH
83201: LD_INT 5
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: PUSH
83208: LD_INT 1
83210: NEG
83211: PUSH
83212: LD_INT 4
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: LD_INT 1
83221: NEG
83222: PUSH
83223: LD_INT 3
83225: PUSH
83226: EMPTY
83227: LIST
83228: LIST
83229: PUSH
83230: LD_INT 2
83232: PUSH
83233: LD_INT 5
83235: PUSH
83236: EMPTY
83237: LIST
83238: LIST
83239: PUSH
83240: LD_INT 2
83242: NEG
83243: PUSH
83244: LD_INT 3
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83298: LD_ADDR_VAR 0 34
83302: PUSH
83303: LD_INT 0
83305: PUSH
83306: LD_INT 4
83308: NEG
83309: PUSH
83310: EMPTY
83311: LIST
83312: LIST
83313: PUSH
83314: LD_INT 0
83316: PUSH
83317: LD_INT 5
83319: NEG
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: PUSH
83325: LD_INT 1
83327: PUSH
83328: LD_INT 4
83330: NEG
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PUSH
83336: LD_INT 1
83338: PUSH
83339: LD_INT 3
83341: NEG
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 0
83349: PUSH
83350: LD_INT 3
83352: NEG
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: PUSH
83358: LD_INT 1
83360: NEG
83361: PUSH
83362: LD_INT 4
83364: NEG
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: PUSH
83370: LD_INT 1
83372: NEG
83373: PUSH
83374: LD_INT 5
83376: NEG
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: LD_INT 2
83384: PUSH
83385: LD_INT 3
83387: NEG
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PUSH
83393: LD_INT 2
83395: NEG
83396: PUSH
83397: LD_INT 5
83399: NEG
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 3
83407: PUSH
83408: LD_INT 0
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 3
83417: PUSH
83418: LD_INT 1
83420: NEG
83421: PUSH
83422: EMPTY
83423: LIST
83424: LIST
83425: PUSH
83426: LD_INT 4
83428: PUSH
83429: LD_INT 0
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 4
83438: PUSH
83439: LD_INT 1
83441: PUSH
83442: EMPTY
83443: LIST
83444: LIST
83445: PUSH
83446: LD_INT 3
83448: PUSH
83449: LD_INT 1
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 2
83458: PUSH
83459: LD_INT 0
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 2
83468: PUSH
83469: LD_INT 1
83471: NEG
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 2
83479: PUSH
83480: LD_INT 2
83482: NEG
83483: PUSH
83484: EMPTY
83485: LIST
83486: LIST
83487: PUSH
83488: LD_INT 4
83490: PUSH
83491: LD_INT 2
83493: PUSH
83494: EMPTY
83495: LIST
83496: LIST
83497: PUSH
83498: LD_INT 4
83500: PUSH
83501: LD_INT 4
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: PUSH
83508: LD_INT 4
83510: PUSH
83511: LD_INT 3
83513: PUSH
83514: EMPTY
83515: LIST
83516: LIST
83517: PUSH
83518: LD_INT 5
83520: PUSH
83521: LD_INT 4
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: LD_INT 5
83530: PUSH
83531: LD_INT 5
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 4
83540: PUSH
83541: LD_INT 5
83543: PUSH
83544: EMPTY
83545: LIST
83546: LIST
83547: PUSH
83548: LD_INT 3
83550: PUSH
83551: LD_INT 4
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 3
83560: PUSH
83561: LD_INT 3
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 5
83570: PUSH
83571: LD_INT 3
83573: PUSH
83574: EMPTY
83575: LIST
83576: LIST
83577: PUSH
83578: LD_INT 3
83580: PUSH
83581: LD_INT 5
83583: PUSH
83584: EMPTY
83585: LIST
83586: LIST
83587: PUSH
83588: LD_INT 0
83590: PUSH
83591: LD_INT 3
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PUSH
83598: LD_INT 0
83600: PUSH
83601: LD_INT 2
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 1
83610: PUSH
83611: LD_INT 3
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 1
83620: PUSH
83621: LD_INT 4
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 0
83630: PUSH
83631: LD_INT 4
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 1
83640: NEG
83641: PUSH
83642: LD_INT 3
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 1
83651: NEG
83652: PUSH
83653: LD_INT 2
83655: PUSH
83656: EMPTY
83657: LIST
83658: LIST
83659: PUSH
83660: LD_INT 2
83662: PUSH
83663: LD_INT 4
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_INT 2
83672: NEG
83673: PUSH
83674: LD_INT 2
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 4
83683: NEG
83684: PUSH
83685: LD_INT 0
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 4
83694: NEG
83695: PUSH
83696: LD_INT 1
83698: NEG
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PUSH
83704: LD_INT 3
83706: NEG
83707: PUSH
83708: LD_INT 0
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 3
83717: NEG
83718: PUSH
83719: LD_INT 1
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 4
83728: NEG
83729: PUSH
83730: LD_INT 1
83732: PUSH
83733: EMPTY
83734: LIST
83735: LIST
83736: PUSH
83737: LD_INT 5
83739: NEG
83740: PUSH
83741: LD_INT 0
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: PUSH
83748: LD_INT 5
83750: NEG
83751: PUSH
83752: LD_INT 1
83754: NEG
83755: PUSH
83756: EMPTY
83757: LIST
83758: LIST
83759: PUSH
83760: LD_INT 5
83762: NEG
83763: PUSH
83764: LD_INT 2
83766: NEG
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 3
83774: NEG
83775: PUSH
83776: LD_INT 2
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: ST_TO_ADDR
// end ; end ;
83830: GO 83833
83832: POP
// case btype of b_depot , b_warehouse :
83833: LD_VAR 0 1
83837: PUSH
83838: LD_INT 0
83840: DOUBLE
83841: EQUAL
83842: IFTRUE 83852
83844: LD_INT 1
83846: DOUBLE
83847: EQUAL
83848: IFTRUE 83852
83850: GO 84053
83852: POP
// case nation of nation_american :
83853: LD_VAR 0 5
83857: PUSH
83858: LD_INT 1
83860: DOUBLE
83861: EQUAL
83862: IFTRUE 83866
83864: GO 83922
83866: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83867: LD_ADDR_VAR 0 9
83871: PUSH
83872: LD_VAR 0 11
83876: PUSH
83877: LD_VAR 0 12
83881: PUSH
83882: LD_VAR 0 13
83886: PUSH
83887: LD_VAR 0 14
83891: PUSH
83892: LD_VAR 0 15
83896: PUSH
83897: LD_VAR 0 16
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: LIST
83906: LIST
83907: LIST
83908: LIST
83909: PUSH
83910: LD_VAR 0 4
83914: PUSH
83915: LD_INT 1
83917: PLUS
83918: ARRAY
83919: ST_TO_ADDR
83920: GO 84051
83922: LD_INT 2
83924: DOUBLE
83925: EQUAL
83926: IFTRUE 83930
83928: GO 83986
83930: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83931: LD_ADDR_VAR 0 9
83935: PUSH
83936: LD_VAR 0 17
83940: PUSH
83941: LD_VAR 0 18
83945: PUSH
83946: LD_VAR 0 19
83950: PUSH
83951: LD_VAR 0 20
83955: PUSH
83956: LD_VAR 0 21
83960: PUSH
83961: LD_VAR 0 22
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: PUSH
83974: LD_VAR 0 4
83978: PUSH
83979: LD_INT 1
83981: PLUS
83982: ARRAY
83983: ST_TO_ADDR
83984: GO 84051
83986: LD_INT 3
83988: DOUBLE
83989: EQUAL
83990: IFTRUE 83994
83992: GO 84050
83994: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83995: LD_ADDR_VAR 0 9
83999: PUSH
84000: LD_VAR 0 23
84004: PUSH
84005: LD_VAR 0 24
84009: PUSH
84010: LD_VAR 0 25
84014: PUSH
84015: LD_VAR 0 26
84019: PUSH
84020: LD_VAR 0 27
84024: PUSH
84025: LD_VAR 0 28
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: PUSH
84038: LD_VAR 0 4
84042: PUSH
84043: LD_INT 1
84045: PLUS
84046: ARRAY
84047: ST_TO_ADDR
84048: GO 84051
84050: POP
84051: GO 84606
84053: LD_INT 2
84055: DOUBLE
84056: EQUAL
84057: IFTRUE 84067
84059: LD_INT 3
84061: DOUBLE
84062: EQUAL
84063: IFTRUE 84067
84065: GO 84123
84067: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
84068: LD_ADDR_VAR 0 9
84072: PUSH
84073: LD_VAR 0 29
84077: PUSH
84078: LD_VAR 0 30
84082: PUSH
84083: LD_VAR 0 31
84087: PUSH
84088: LD_VAR 0 32
84092: PUSH
84093: LD_VAR 0 33
84097: PUSH
84098: LD_VAR 0 34
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: PUSH
84111: LD_VAR 0 4
84115: PUSH
84116: LD_INT 1
84118: PLUS
84119: ARRAY
84120: ST_TO_ADDR
84121: GO 84606
84123: LD_INT 16
84125: DOUBLE
84126: EQUAL
84127: IFTRUE 84185
84129: LD_INT 17
84131: DOUBLE
84132: EQUAL
84133: IFTRUE 84185
84135: LD_INT 18
84137: DOUBLE
84138: EQUAL
84139: IFTRUE 84185
84141: LD_INT 19
84143: DOUBLE
84144: EQUAL
84145: IFTRUE 84185
84147: LD_INT 22
84149: DOUBLE
84150: EQUAL
84151: IFTRUE 84185
84153: LD_INT 20
84155: DOUBLE
84156: EQUAL
84157: IFTRUE 84185
84159: LD_INT 21
84161: DOUBLE
84162: EQUAL
84163: IFTRUE 84185
84165: LD_INT 23
84167: DOUBLE
84168: EQUAL
84169: IFTRUE 84185
84171: LD_INT 24
84173: DOUBLE
84174: EQUAL
84175: IFTRUE 84185
84177: LD_INT 25
84179: DOUBLE
84180: EQUAL
84181: IFTRUE 84185
84183: GO 84241
84185: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84186: LD_ADDR_VAR 0 9
84190: PUSH
84191: LD_VAR 0 35
84195: PUSH
84196: LD_VAR 0 36
84200: PUSH
84201: LD_VAR 0 37
84205: PUSH
84206: LD_VAR 0 38
84210: PUSH
84211: LD_VAR 0 39
84215: PUSH
84216: LD_VAR 0 40
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: PUSH
84229: LD_VAR 0 4
84233: PUSH
84234: LD_INT 1
84236: PLUS
84237: ARRAY
84238: ST_TO_ADDR
84239: GO 84606
84241: LD_INT 6
84243: DOUBLE
84244: EQUAL
84245: IFTRUE 84297
84247: LD_INT 7
84249: DOUBLE
84250: EQUAL
84251: IFTRUE 84297
84253: LD_INT 8
84255: DOUBLE
84256: EQUAL
84257: IFTRUE 84297
84259: LD_INT 13
84261: DOUBLE
84262: EQUAL
84263: IFTRUE 84297
84265: LD_INT 12
84267: DOUBLE
84268: EQUAL
84269: IFTRUE 84297
84271: LD_INT 15
84273: DOUBLE
84274: EQUAL
84275: IFTRUE 84297
84277: LD_INT 11
84279: DOUBLE
84280: EQUAL
84281: IFTRUE 84297
84283: LD_INT 14
84285: DOUBLE
84286: EQUAL
84287: IFTRUE 84297
84289: LD_INT 10
84291: DOUBLE
84292: EQUAL
84293: IFTRUE 84297
84295: GO 84353
84297: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84298: LD_ADDR_VAR 0 9
84302: PUSH
84303: LD_VAR 0 41
84307: PUSH
84308: LD_VAR 0 42
84312: PUSH
84313: LD_VAR 0 43
84317: PUSH
84318: LD_VAR 0 44
84322: PUSH
84323: LD_VAR 0 45
84327: PUSH
84328: LD_VAR 0 46
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: PUSH
84341: LD_VAR 0 4
84345: PUSH
84346: LD_INT 1
84348: PLUS
84349: ARRAY
84350: ST_TO_ADDR
84351: GO 84606
84353: LD_INT 36
84355: DOUBLE
84356: EQUAL
84357: IFTRUE 84361
84359: GO 84417
84361: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84362: LD_ADDR_VAR 0 9
84366: PUSH
84367: LD_VAR 0 47
84371: PUSH
84372: LD_VAR 0 48
84376: PUSH
84377: LD_VAR 0 49
84381: PUSH
84382: LD_VAR 0 50
84386: PUSH
84387: LD_VAR 0 51
84391: PUSH
84392: LD_VAR 0 52
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: PUSH
84405: LD_VAR 0 4
84409: PUSH
84410: LD_INT 1
84412: PLUS
84413: ARRAY
84414: ST_TO_ADDR
84415: GO 84606
84417: LD_INT 4
84419: DOUBLE
84420: EQUAL
84421: IFTRUE 84443
84423: LD_INT 5
84425: DOUBLE
84426: EQUAL
84427: IFTRUE 84443
84429: LD_INT 34
84431: DOUBLE
84432: EQUAL
84433: IFTRUE 84443
84435: LD_INT 37
84437: DOUBLE
84438: EQUAL
84439: IFTRUE 84443
84441: GO 84499
84443: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84444: LD_ADDR_VAR 0 9
84448: PUSH
84449: LD_VAR 0 53
84453: PUSH
84454: LD_VAR 0 54
84458: PUSH
84459: LD_VAR 0 55
84463: PUSH
84464: LD_VAR 0 56
84468: PUSH
84469: LD_VAR 0 57
84473: PUSH
84474: LD_VAR 0 58
84478: PUSH
84479: EMPTY
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: PUSH
84487: LD_VAR 0 4
84491: PUSH
84492: LD_INT 1
84494: PLUS
84495: ARRAY
84496: ST_TO_ADDR
84497: GO 84606
84499: LD_INT 31
84501: DOUBLE
84502: EQUAL
84503: IFTRUE 84549
84505: LD_INT 32
84507: DOUBLE
84508: EQUAL
84509: IFTRUE 84549
84511: LD_INT 33
84513: DOUBLE
84514: EQUAL
84515: IFTRUE 84549
84517: LD_INT 27
84519: DOUBLE
84520: EQUAL
84521: IFTRUE 84549
84523: LD_INT 26
84525: DOUBLE
84526: EQUAL
84527: IFTRUE 84549
84529: LD_INT 28
84531: DOUBLE
84532: EQUAL
84533: IFTRUE 84549
84535: LD_INT 29
84537: DOUBLE
84538: EQUAL
84539: IFTRUE 84549
84541: LD_INT 30
84543: DOUBLE
84544: EQUAL
84545: IFTRUE 84549
84547: GO 84605
84549: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84550: LD_ADDR_VAR 0 9
84554: PUSH
84555: LD_VAR 0 59
84559: PUSH
84560: LD_VAR 0 60
84564: PUSH
84565: LD_VAR 0 61
84569: PUSH
84570: LD_VAR 0 62
84574: PUSH
84575: LD_VAR 0 63
84579: PUSH
84580: LD_VAR 0 64
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: PUSH
84593: LD_VAR 0 4
84597: PUSH
84598: LD_INT 1
84600: PLUS
84601: ARRAY
84602: ST_TO_ADDR
84603: GO 84606
84605: POP
// temp_list2 = [ ] ;
84606: LD_ADDR_VAR 0 10
84610: PUSH
84611: EMPTY
84612: ST_TO_ADDR
// for i in temp_list do
84613: LD_ADDR_VAR 0 8
84617: PUSH
84618: LD_VAR 0 9
84622: PUSH
84623: FOR_IN
84624: IFFALSE 84676
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84626: LD_ADDR_VAR 0 10
84630: PUSH
84631: LD_VAR 0 10
84635: PUSH
84636: LD_VAR 0 8
84640: PUSH
84641: LD_INT 1
84643: ARRAY
84644: PUSH
84645: LD_VAR 0 2
84649: PLUS
84650: PUSH
84651: LD_VAR 0 8
84655: PUSH
84656: LD_INT 2
84658: ARRAY
84659: PUSH
84660: LD_VAR 0 3
84664: PLUS
84665: PUSH
84666: EMPTY
84667: LIST
84668: LIST
84669: PUSH
84670: EMPTY
84671: LIST
84672: ADD
84673: ST_TO_ADDR
84674: GO 84623
84676: POP
84677: POP
// result = temp_list2 ;
84678: LD_ADDR_VAR 0 7
84682: PUSH
84683: LD_VAR 0 10
84687: ST_TO_ADDR
// end ;
84688: LD_VAR 0 7
84692: RET
// export function EnemyInRange ( unit , dist ) ; begin
84693: LD_INT 0
84695: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84696: LD_ADDR_VAR 0 3
84700: PUSH
84701: LD_VAR 0 1
84705: PPUSH
84706: CALL_OW 255
84710: PPUSH
84711: LD_VAR 0 1
84715: PPUSH
84716: CALL_OW 250
84720: PPUSH
84721: LD_VAR 0 1
84725: PPUSH
84726: CALL_OW 251
84730: PPUSH
84731: LD_VAR 0 2
84735: PPUSH
84736: CALL 58089 0 4
84740: PUSH
84741: LD_INT 4
84743: ARRAY
84744: ST_TO_ADDR
// end ;
84745: LD_VAR 0 3
84749: RET
// export function PlayerSeeMe ( unit ) ; begin
84750: LD_INT 0
84752: PPUSH
// result := See ( your_side , unit ) ;
84753: LD_ADDR_VAR 0 2
84757: PUSH
84758: LD_OWVAR 2
84762: PPUSH
84763: LD_VAR 0 1
84767: PPUSH
84768: CALL_OW 292
84772: ST_TO_ADDR
// end ;
84773: LD_VAR 0 2
84777: RET
// export function ReverseDir ( unit ) ; begin
84778: LD_INT 0
84780: PPUSH
// if not unit then
84781: LD_VAR 0 1
84785: NOT
84786: IFFALSE 84790
// exit ;
84788: GO 84813
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84790: LD_ADDR_VAR 0 2
84794: PUSH
84795: LD_VAR 0 1
84799: PPUSH
84800: CALL_OW 254
84804: PUSH
84805: LD_INT 3
84807: PLUS
84808: PUSH
84809: LD_INT 6
84811: MOD
84812: ST_TO_ADDR
// end ;
84813: LD_VAR 0 2
84817: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84818: LD_INT 0
84820: PPUSH
84821: PPUSH
84822: PPUSH
84823: PPUSH
84824: PPUSH
// if not hexes then
84825: LD_VAR 0 2
84829: NOT
84830: IFFALSE 84834
// exit ;
84832: GO 84982
// dist := 9999 ;
84834: LD_ADDR_VAR 0 5
84838: PUSH
84839: LD_INT 9999
84841: ST_TO_ADDR
// for i = 1 to hexes do
84842: LD_ADDR_VAR 0 4
84846: PUSH
84847: DOUBLE
84848: LD_INT 1
84850: DEC
84851: ST_TO_ADDR
84852: LD_VAR 0 2
84856: PUSH
84857: FOR_TO
84858: IFFALSE 84970
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84860: LD_VAR 0 1
84864: PPUSH
84865: LD_VAR 0 2
84869: PUSH
84870: LD_VAR 0 4
84874: ARRAY
84875: PUSH
84876: LD_INT 1
84878: ARRAY
84879: PPUSH
84880: LD_VAR 0 2
84884: PUSH
84885: LD_VAR 0 4
84889: ARRAY
84890: PUSH
84891: LD_INT 2
84893: ARRAY
84894: PPUSH
84895: CALL_OW 297
84899: PUSH
84900: LD_VAR 0 5
84904: LESS
84905: IFFALSE 84968
// begin hex := hexes [ i ] ;
84907: LD_ADDR_VAR 0 7
84911: PUSH
84912: LD_VAR 0 2
84916: PUSH
84917: LD_VAR 0 4
84921: ARRAY
84922: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84923: LD_ADDR_VAR 0 5
84927: PUSH
84928: LD_VAR 0 1
84932: PPUSH
84933: LD_VAR 0 2
84937: PUSH
84938: LD_VAR 0 4
84942: ARRAY
84943: PUSH
84944: LD_INT 1
84946: ARRAY
84947: PPUSH
84948: LD_VAR 0 2
84952: PUSH
84953: LD_VAR 0 4
84957: ARRAY
84958: PUSH
84959: LD_INT 2
84961: ARRAY
84962: PPUSH
84963: CALL_OW 297
84967: ST_TO_ADDR
// end ; end ;
84968: GO 84857
84970: POP
84971: POP
// result := hex ;
84972: LD_ADDR_VAR 0 3
84976: PUSH
84977: LD_VAR 0 7
84981: ST_TO_ADDR
// end ;
84982: LD_VAR 0 3
84986: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84987: LD_INT 0
84989: PPUSH
84990: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84991: LD_VAR 0 1
84995: NOT
84996: PUSH
84997: LD_VAR 0 1
85001: PUSH
85002: LD_INT 21
85004: PUSH
85005: LD_INT 2
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 23
85014: PUSH
85015: LD_INT 2
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: PPUSH
85026: CALL_OW 69
85030: IN
85031: NOT
85032: OR
85033: IFFALSE 85037
// exit ;
85035: GO 85084
// for i = 1 to 3 do
85037: LD_ADDR_VAR 0 3
85041: PUSH
85042: DOUBLE
85043: LD_INT 1
85045: DEC
85046: ST_TO_ADDR
85047: LD_INT 3
85049: PUSH
85050: FOR_TO
85051: IFFALSE 85082
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
85053: LD_VAR 0 1
85057: PPUSH
85058: CALL_OW 250
85062: PPUSH
85063: LD_VAR 0 1
85067: PPUSH
85068: CALL_OW 251
85072: PPUSH
85073: LD_INT 1
85075: PPUSH
85076: CALL_OW 453
85080: GO 85050
85082: POP
85083: POP
// end ;
85084: LD_VAR 0 2
85088: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
85089: LD_INT 0
85091: PPUSH
85092: PPUSH
85093: PPUSH
85094: PPUSH
85095: PPUSH
85096: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
85097: LD_VAR 0 1
85101: NOT
85102: PUSH
85103: LD_VAR 0 2
85107: NOT
85108: OR
85109: PUSH
85110: LD_VAR 0 1
85114: PPUSH
85115: CALL_OW 314
85119: OR
85120: IFFALSE 85124
// exit ;
85122: GO 85565
// x := GetX ( enemy_unit ) ;
85124: LD_ADDR_VAR 0 7
85128: PUSH
85129: LD_VAR 0 2
85133: PPUSH
85134: CALL_OW 250
85138: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85139: LD_ADDR_VAR 0 8
85143: PUSH
85144: LD_VAR 0 2
85148: PPUSH
85149: CALL_OW 251
85153: ST_TO_ADDR
// if not x or not y then
85154: LD_VAR 0 7
85158: NOT
85159: PUSH
85160: LD_VAR 0 8
85164: NOT
85165: OR
85166: IFFALSE 85170
// exit ;
85168: GO 85565
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85170: LD_ADDR_VAR 0 6
85174: PUSH
85175: LD_VAR 0 7
85179: PPUSH
85180: LD_INT 0
85182: PPUSH
85183: LD_INT 4
85185: PPUSH
85186: CALL_OW 272
85190: PUSH
85191: LD_VAR 0 8
85195: PPUSH
85196: LD_INT 0
85198: PPUSH
85199: LD_INT 4
85201: PPUSH
85202: CALL_OW 273
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_VAR 0 7
85215: PPUSH
85216: LD_INT 1
85218: PPUSH
85219: LD_INT 4
85221: PPUSH
85222: CALL_OW 272
85226: PUSH
85227: LD_VAR 0 8
85231: PPUSH
85232: LD_INT 1
85234: PPUSH
85235: LD_INT 4
85237: PPUSH
85238: CALL_OW 273
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_VAR 0 7
85251: PPUSH
85252: LD_INT 2
85254: PPUSH
85255: LD_INT 4
85257: PPUSH
85258: CALL_OW 272
85262: PUSH
85263: LD_VAR 0 8
85267: PPUSH
85268: LD_INT 2
85270: PPUSH
85271: LD_INT 4
85273: PPUSH
85274: CALL_OW 273
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: PUSH
85283: LD_VAR 0 7
85287: PPUSH
85288: LD_INT 3
85290: PPUSH
85291: LD_INT 4
85293: PPUSH
85294: CALL_OW 272
85298: PUSH
85299: LD_VAR 0 8
85303: PPUSH
85304: LD_INT 3
85306: PPUSH
85307: LD_INT 4
85309: PPUSH
85310: CALL_OW 273
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_VAR 0 7
85323: PPUSH
85324: LD_INT 4
85326: PPUSH
85327: LD_INT 4
85329: PPUSH
85330: CALL_OW 272
85334: PUSH
85335: LD_VAR 0 8
85339: PPUSH
85340: LD_INT 4
85342: PPUSH
85343: LD_INT 4
85345: PPUSH
85346: CALL_OW 273
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PUSH
85355: LD_VAR 0 7
85359: PPUSH
85360: LD_INT 5
85362: PPUSH
85363: LD_INT 4
85365: PPUSH
85366: CALL_OW 272
85370: PUSH
85371: LD_VAR 0 8
85375: PPUSH
85376: LD_INT 5
85378: PPUSH
85379: LD_INT 4
85381: PPUSH
85382: CALL_OW 273
85386: PUSH
85387: EMPTY
85388: LIST
85389: LIST
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: ST_TO_ADDR
// for i = tmp downto 1 do
85399: LD_ADDR_VAR 0 4
85403: PUSH
85404: DOUBLE
85405: LD_VAR 0 6
85409: INC
85410: ST_TO_ADDR
85411: LD_INT 1
85413: PUSH
85414: FOR_DOWNTO
85415: IFFALSE 85516
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85417: LD_VAR 0 6
85421: PUSH
85422: LD_VAR 0 4
85426: ARRAY
85427: PUSH
85428: LD_INT 1
85430: ARRAY
85431: PPUSH
85432: LD_VAR 0 6
85436: PUSH
85437: LD_VAR 0 4
85441: ARRAY
85442: PUSH
85443: LD_INT 2
85445: ARRAY
85446: PPUSH
85447: CALL_OW 488
85451: NOT
85452: PUSH
85453: LD_VAR 0 6
85457: PUSH
85458: LD_VAR 0 4
85462: ARRAY
85463: PUSH
85464: LD_INT 1
85466: ARRAY
85467: PPUSH
85468: LD_VAR 0 6
85472: PUSH
85473: LD_VAR 0 4
85477: ARRAY
85478: PUSH
85479: LD_INT 2
85481: ARRAY
85482: PPUSH
85483: CALL_OW 428
85487: PUSH
85488: LD_INT 0
85490: NONEQUAL
85491: OR
85492: IFFALSE 85514
// tmp := Delete ( tmp , i ) ;
85494: LD_ADDR_VAR 0 6
85498: PUSH
85499: LD_VAR 0 6
85503: PPUSH
85504: LD_VAR 0 4
85508: PPUSH
85509: CALL_OW 3
85513: ST_TO_ADDR
85514: GO 85414
85516: POP
85517: POP
// j := GetClosestHex ( unit , tmp ) ;
85518: LD_ADDR_VAR 0 5
85522: PUSH
85523: LD_VAR 0 1
85527: PPUSH
85528: LD_VAR 0 6
85532: PPUSH
85533: CALL 84818 0 2
85537: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85538: LD_VAR 0 1
85542: PPUSH
85543: LD_VAR 0 5
85547: PUSH
85548: LD_INT 1
85550: ARRAY
85551: PPUSH
85552: LD_VAR 0 5
85556: PUSH
85557: LD_INT 2
85559: ARRAY
85560: PPUSH
85561: CALL_OW 111
// end ;
85565: LD_VAR 0 3
85569: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85570: LD_INT 0
85572: PPUSH
85573: PPUSH
85574: PPUSH
// uc_side = 0 ;
85575: LD_ADDR_OWVAR 20
85579: PUSH
85580: LD_INT 0
85582: ST_TO_ADDR
// uc_nation = 0 ;
85583: LD_ADDR_OWVAR 21
85587: PUSH
85588: LD_INT 0
85590: ST_TO_ADDR
// InitHc_All ( ) ;
85591: CALL_OW 584
// InitVc ;
85595: CALL_OW 20
// if mastodonts then
85599: LD_VAR 0 6
85603: IFFALSE 85670
// for i = 1 to mastodonts do
85605: LD_ADDR_VAR 0 11
85609: PUSH
85610: DOUBLE
85611: LD_INT 1
85613: DEC
85614: ST_TO_ADDR
85615: LD_VAR 0 6
85619: PUSH
85620: FOR_TO
85621: IFFALSE 85668
// begin vc_chassis := 31 ;
85623: LD_ADDR_OWVAR 37
85627: PUSH
85628: LD_INT 31
85630: ST_TO_ADDR
// vc_control := control_rider ;
85631: LD_ADDR_OWVAR 38
85635: PUSH
85636: LD_INT 4
85638: ST_TO_ADDR
// animal := CreateVehicle ;
85639: LD_ADDR_VAR 0 12
85643: PUSH
85644: CALL_OW 45
85648: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85649: LD_VAR 0 12
85653: PPUSH
85654: LD_VAR 0 8
85658: PPUSH
85659: LD_INT 0
85661: PPUSH
85662: CALL 87805 0 3
// end ;
85666: GO 85620
85668: POP
85669: POP
// if horses then
85670: LD_VAR 0 5
85674: IFFALSE 85741
// for i = 1 to horses do
85676: LD_ADDR_VAR 0 11
85680: PUSH
85681: DOUBLE
85682: LD_INT 1
85684: DEC
85685: ST_TO_ADDR
85686: LD_VAR 0 5
85690: PUSH
85691: FOR_TO
85692: IFFALSE 85739
// begin hc_class := 21 ;
85694: LD_ADDR_OWVAR 28
85698: PUSH
85699: LD_INT 21
85701: ST_TO_ADDR
// hc_gallery :=  ;
85702: LD_ADDR_OWVAR 33
85706: PUSH
85707: LD_STRING 
85709: ST_TO_ADDR
// animal := CreateHuman ;
85710: LD_ADDR_VAR 0 12
85714: PUSH
85715: CALL_OW 44
85719: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85720: LD_VAR 0 12
85724: PPUSH
85725: LD_VAR 0 8
85729: PPUSH
85730: LD_INT 0
85732: PPUSH
85733: CALL 87805 0 3
// end ;
85737: GO 85691
85739: POP
85740: POP
// if birds then
85741: LD_VAR 0 1
85745: IFFALSE 85812
// for i = 1 to birds do
85747: LD_ADDR_VAR 0 11
85751: PUSH
85752: DOUBLE
85753: LD_INT 1
85755: DEC
85756: ST_TO_ADDR
85757: LD_VAR 0 1
85761: PUSH
85762: FOR_TO
85763: IFFALSE 85810
// begin hc_class = 18 ;
85765: LD_ADDR_OWVAR 28
85769: PUSH
85770: LD_INT 18
85772: ST_TO_ADDR
// hc_gallery =  ;
85773: LD_ADDR_OWVAR 33
85777: PUSH
85778: LD_STRING 
85780: ST_TO_ADDR
// animal := CreateHuman ;
85781: LD_ADDR_VAR 0 12
85785: PUSH
85786: CALL_OW 44
85790: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85791: LD_VAR 0 12
85795: PPUSH
85796: LD_VAR 0 8
85800: PPUSH
85801: LD_INT 0
85803: PPUSH
85804: CALL 87805 0 3
// end ;
85808: GO 85762
85810: POP
85811: POP
// if tigers then
85812: LD_VAR 0 2
85816: IFFALSE 85900
// for i = 1 to tigers do
85818: LD_ADDR_VAR 0 11
85822: PUSH
85823: DOUBLE
85824: LD_INT 1
85826: DEC
85827: ST_TO_ADDR
85828: LD_VAR 0 2
85832: PUSH
85833: FOR_TO
85834: IFFALSE 85898
// begin hc_class = class_tiger ;
85836: LD_ADDR_OWVAR 28
85840: PUSH
85841: LD_INT 14
85843: ST_TO_ADDR
// hc_gallery =  ;
85844: LD_ADDR_OWVAR 33
85848: PUSH
85849: LD_STRING 
85851: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85852: LD_ADDR_OWVAR 35
85856: PUSH
85857: LD_INT 7
85859: NEG
85860: PPUSH
85861: LD_INT 7
85863: PPUSH
85864: CALL_OW 12
85868: ST_TO_ADDR
// animal := CreateHuman ;
85869: LD_ADDR_VAR 0 12
85873: PUSH
85874: CALL_OW 44
85878: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85879: LD_VAR 0 12
85883: PPUSH
85884: LD_VAR 0 8
85888: PPUSH
85889: LD_INT 0
85891: PPUSH
85892: CALL 87805 0 3
// end ;
85896: GO 85833
85898: POP
85899: POP
// if apemans then
85900: LD_VAR 0 3
85904: IFFALSE 86027
// for i = 1 to apemans do
85906: LD_ADDR_VAR 0 11
85910: PUSH
85911: DOUBLE
85912: LD_INT 1
85914: DEC
85915: ST_TO_ADDR
85916: LD_VAR 0 3
85920: PUSH
85921: FOR_TO
85922: IFFALSE 86025
// begin hc_class = class_apeman ;
85924: LD_ADDR_OWVAR 28
85928: PUSH
85929: LD_INT 12
85931: ST_TO_ADDR
// hc_gallery =  ;
85932: LD_ADDR_OWVAR 33
85936: PUSH
85937: LD_STRING 
85939: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
85940: LD_ADDR_OWVAR 35
85944: PUSH
85945: LD_INT 2
85947: NEG
85948: PPUSH
85949: LD_INT 2
85951: PPUSH
85952: CALL_OW 12
85956: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85957: LD_ADDR_OWVAR 31
85961: PUSH
85962: LD_INT 1
85964: PPUSH
85965: LD_INT 3
85967: PPUSH
85968: CALL_OW 12
85972: PUSH
85973: LD_INT 1
85975: PPUSH
85976: LD_INT 3
85978: PPUSH
85979: CALL_OW 12
85983: PUSH
85984: LD_INT 0
85986: PUSH
85987: LD_INT 0
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: ST_TO_ADDR
// animal := CreateHuman ;
85996: LD_ADDR_VAR 0 12
86000: PUSH
86001: CALL_OW 44
86005: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86006: LD_VAR 0 12
86010: PPUSH
86011: LD_VAR 0 8
86015: PPUSH
86016: LD_INT 0
86018: PPUSH
86019: CALL 87805 0 3
// end ;
86023: GO 85921
86025: POP
86026: POP
// if enchidnas then
86027: LD_VAR 0 4
86031: IFFALSE 86098
// for i = 1 to enchidnas do
86033: LD_ADDR_VAR 0 11
86037: PUSH
86038: DOUBLE
86039: LD_INT 1
86041: DEC
86042: ST_TO_ADDR
86043: LD_VAR 0 4
86047: PUSH
86048: FOR_TO
86049: IFFALSE 86096
// begin hc_class = 13 ;
86051: LD_ADDR_OWVAR 28
86055: PUSH
86056: LD_INT 13
86058: ST_TO_ADDR
// hc_gallery =  ;
86059: LD_ADDR_OWVAR 33
86063: PUSH
86064: LD_STRING 
86066: ST_TO_ADDR
// animal := CreateHuman ;
86067: LD_ADDR_VAR 0 12
86071: PUSH
86072: CALL_OW 44
86076: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86077: LD_VAR 0 12
86081: PPUSH
86082: LD_VAR 0 8
86086: PPUSH
86087: LD_INT 0
86089: PPUSH
86090: CALL 87805 0 3
// end ;
86094: GO 86048
86096: POP
86097: POP
// if fishes then
86098: LD_VAR 0 7
86102: IFFALSE 86169
// for i = 1 to fishes do
86104: LD_ADDR_VAR 0 11
86108: PUSH
86109: DOUBLE
86110: LD_INT 1
86112: DEC
86113: ST_TO_ADDR
86114: LD_VAR 0 7
86118: PUSH
86119: FOR_TO
86120: IFFALSE 86167
// begin hc_class = 20 ;
86122: LD_ADDR_OWVAR 28
86126: PUSH
86127: LD_INT 20
86129: ST_TO_ADDR
// hc_gallery =  ;
86130: LD_ADDR_OWVAR 33
86134: PUSH
86135: LD_STRING 
86137: ST_TO_ADDR
// animal := CreateHuman ;
86138: LD_ADDR_VAR 0 12
86142: PUSH
86143: CALL_OW 44
86147: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
86148: LD_VAR 0 12
86152: PPUSH
86153: LD_VAR 0 9
86157: PPUSH
86158: LD_INT 0
86160: PPUSH
86161: CALL 87805 0 3
// end ;
86165: GO 86119
86167: POP
86168: POP
// end ;
86169: LD_VAR 0 10
86173: RET
// export function WantHeal ( sci , unit ) ; begin
86174: LD_INT 0
86176: PPUSH
// if GetTaskList ( sci ) > 0 then
86177: LD_VAR 0 1
86181: PPUSH
86182: CALL_OW 437
86186: PUSH
86187: LD_INT 0
86189: GREATER
86190: IFFALSE 86260
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86192: LD_VAR 0 1
86196: PPUSH
86197: CALL_OW 437
86201: PUSH
86202: LD_INT 1
86204: ARRAY
86205: PUSH
86206: LD_INT 1
86208: ARRAY
86209: PUSH
86210: LD_STRING l
86212: EQUAL
86213: PUSH
86214: LD_VAR 0 1
86218: PPUSH
86219: CALL_OW 437
86223: PUSH
86224: LD_INT 1
86226: ARRAY
86227: PUSH
86228: LD_INT 4
86230: ARRAY
86231: PUSH
86232: LD_VAR 0 2
86236: EQUAL
86237: AND
86238: IFFALSE 86250
// result := true else
86240: LD_ADDR_VAR 0 3
86244: PUSH
86245: LD_INT 1
86247: ST_TO_ADDR
86248: GO 86258
// result := false ;
86250: LD_ADDR_VAR 0 3
86254: PUSH
86255: LD_INT 0
86257: ST_TO_ADDR
// end else
86258: GO 86268
// result := false ;
86260: LD_ADDR_VAR 0 3
86264: PUSH
86265: LD_INT 0
86267: ST_TO_ADDR
// end ;
86268: LD_VAR 0 3
86272: RET
// export function HealTarget ( sci ) ; begin
86273: LD_INT 0
86275: PPUSH
// if not sci then
86276: LD_VAR 0 1
86280: NOT
86281: IFFALSE 86285
// exit ;
86283: GO 86350
// result := 0 ;
86285: LD_ADDR_VAR 0 2
86289: PUSH
86290: LD_INT 0
86292: ST_TO_ADDR
// if GetTaskList ( sci ) then
86293: LD_VAR 0 1
86297: PPUSH
86298: CALL_OW 437
86302: IFFALSE 86350
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86304: LD_VAR 0 1
86308: PPUSH
86309: CALL_OW 437
86313: PUSH
86314: LD_INT 1
86316: ARRAY
86317: PUSH
86318: LD_INT 1
86320: ARRAY
86321: PUSH
86322: LD_STRING l
86324: EQUAL
86325: IFFALSE 86350
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86327: LD_ADDR_VAR 0 2
86331: PUSH
86332: LD_VAR 0 1
86336: PPUSH
86337: CALL_OW 437
86341: PUSH
86342: LD_INT 1
86344: ARRAY
86345: PUSH
86346: LD_INT 4
86348: ARRAY
86349: ST_TO_ADDR
// end ;
86350: LD_VAR 0 2
86354: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86355: LD_INT 0
86357: PPUSH
86358: PPUSH
86359: PPUSH
86360: PPUSH
// if not base_units then
86361: LD_VAR 0 1
86365: NOT
86366: IFFALSE 86370
// exit ;
86368: GO 86457
// result := false ;
86370: LD_ADDR_VAR 0 2
86374: PUSH
86375: LD_INT 0
86377: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
86378: LD_ADDR_VAR 0 5
86382: PUSH
86383: LD_VAR 0 1
86387: PPUSH
86388: LD_INT 21
86390: PUSH
86391: LD_INT 3
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PPUSH
86398: CALL_OW 72
86402: ST_TO_ADDR
// if not tmp then
86403: LD_VAR 0 5
86407: NOT
86408: IFFALSE 86412
// exit ;
86410: GO 86457
// for i in tmp do
86412: LD_ADDR_VAR 0 3
86416: PUSH
86417: LD_VAR 0 5
86421: PUSH
86422: FOR_IN
86423: IFFALSE 86455
// begin result := EnemyInRange ( i , 22 ) ;
86425: LD_ADDR_VAR 0 2
86429: PUSH
86430: LD_VAR 0 3
86434: PPUSH
86435: LD_INT 22
86437: PPUSH
86438: CALL 84693 0 2
86442: ST_TO_ADDR
// if result then
86443: LD_VAR 0 2
86447: IFFALSE 86453
// exit ;
86449: POP
86450: POP
86451: GO 86457
// end ;
86453: GO 86422
86455: POP
86456: POP
// end ;
86457: LD_VAR 0 2
86461: RET
// export function FilterByTag ( units , tag ) ; begin
86462: LD_INT 0
86464: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
86465: LD_ADDR_VAR 0 3
86469: PUSH
86470: LD_VAR 0 1
86474: PPUSH
86475: LD_INT 120
86477: PUSH
86478: LD_VAR 0 2
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PPUSH
86487: CALL_OW 72
86491: ST_TO_ADDR
// end ;
86492: LD_VAR 0 3
86496: RET
// export function IsDriver ( un ) ; begin
86497: LD_INT 0
86499: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
86500: LD_ADDR_VAR 0 2
86504: PUSH
86505: LD_VAR 0 1
86509: PUSH
86510: LD_INT 55
86512: PUSH
86513: EMPTY
86514: LIST
86515: PPUSH
86516: CALL_OW 69
86520: IN
86521: ST_TO_ADDR
// end ;
86522: LD_VAR 0 2
86526: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
86527: LD_INT 0
86529: PPUSH
86530: PPUSH
// list := [ ] ;
86531: LD_ADDR_VAR 0 5
86535: PUSH
86536: EMPTY
86537: ST_TO_ADDR
// case d of 0 :
86538: LD_VAR 0 3
86542: PUSH
86543: LD_INT 0
86545: DOUBLE
86546: EQUAL
86547: IFTRUE 86551
86549: GO 86684
86551: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
86552: LD_ADDR_VAR 0 5
86556: PUSH
86557: LD_VAR 0 1
86561: PUSH
86562: LD_INT 4
86564: MINUS
86565: PUSH
86566: LD_VAR 0 2
86570: PUSH
86571: LD_INT 4
86573: MINUS
86574: PUSH
86575: LD_INT 2
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: LIST
86582: PUSH
86583: LD_VAR 0 1
86587: PUSH
86588: LD_INT 3
86590: MINUS
86591: PUSH
86592: LD_VAR 0 2
86596: PUSH
86597: LD_INT 1
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: LIST
86604: PUSH
86605: LD_VAR 0 1
86609: PUSH
86610: LD_INT 4
86612: PLUS
86613: PUSH
86614: LD_VAR 0 2
86618: PUSH
86619: LD_INT 4
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: LIST
86626: PUSH
86627: LD_VAR 0 1
86631: PUSH
86632: LD_INT 3
86634: PLUS
86635: PUSH
86636: LD_VAR 0 2
86640: PUSH
86641: LD_INT 3
86643: PLUS
86644: PUSH
86645: LD_INT 5
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: LIST
86652: PUSH
86653: LD_VAR 0 1
86657: PUSH
86658: LD_VAR 0 2
86662: PUSH
86663: LD_INT 4
86665: PLUS
86666: PUSH
86667: LD_INT 0
86669: PUSH
86670: EMPTY
86671: LIST
86672: LIST
86673: LIST
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: ST_TO_ADDR
// end ; 1 :
86682: GO 87382
86684: LD_INT 1
86686: DOUBLE
86687: EQUAL
86688: IFTRUE 86692
86690: GO 86825
86692: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
86693: LD_ADDR_VAR 0 5
86697: PUSH
86698: LD_VAR 0 1
86702: PUSH
86703: LD_VAR 0 2
86707: PUSH
86708: LD_INT 4
86710: MINUS
86711: PUSH
86712: LD_INT 3
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: LIST
86719: PUSH
86720: LD_VAR 0 1
86724: PUSH
86725: LD_INT 3
86727: MINUS
86728: PUSH
86729: LD_VAR 0 2
86733: PUSH
86734: LD_INT 3
86736: MINUS
86737: PUSH
86738: LD_INT 2
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: LIST
86745: PUSH
86746: LD_VAR 0 1
86750: PUSH
86751: LD_INT 4
86753: MINUS
86754: PUSH
86755: LD_VAR 0 2
86759: PUSH
86760: LD_INT 1
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: LIST
86767: PUSH
86768: LD_VAR 0 1
86772: PUSH
86773: LD_VAR 0 2
86777: PUSH
86778: LD_INT 3
86780: PLUS
86781: PUSH
86782: LD_INT 0
86784: PUSH
86785: EMPTY
86786: LIST
86787: LIST
86788: LIST
86789: PUSH
86790: LD_VAR 0 1
86794: PUSH
86795: LD_INT 4
86797: PLUS
86798: PUSH
86799: LD_VAR 0 2
86803: PUSH
86804: LD_INT 4
86806: PLUS
86807: PUSH
86808: LD_INT 5
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: LIST
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: LIST
86820: LIST
86821: LIST
86822: ST_TO_ADDR
// end ; 2 :
86823: GO 87382
86825: LD_INT 2
86827: DOUBLE
86828: EQUAL
86829: IFTRUE 86833
86831: GO 86962
86833: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
86834: LD_ADDR_VAR 0 5
86838: PUSH
86839: LD_VAR 0 1
86843: PUSH
86844: LD_VAR 0 2
86848: PUSH
86849: LD_INT 3
86851: MINUS
86852: PUSH
86853: LD_INT 3
86855: PUSH
86856: EMPTY
86857: LIST
86858: LIST
86859: LIST
86860: PUSH
86861: LD_VAR 0 1
86865: PUSH
86866: LD_INT 4
86868: PLUS
86869: PUSH
86870: LD_VAR 0 2
86874: PUSH
86875: LD_INT 4
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: LIST
86882: PUSH
86883: LD_VAR 0 1
86887: PUSH
86888: LD_VAR 0 2
86892: PUSH
86893: LD_INT 4
86895: PLUS
86896: PUSH
86897: LD_INT 0
86899: PUSH
86900: EMPTY
86901: LIST
86902: LIST
86903: LIST
86904: PUSH
86905: LD_VAR 0 1
86909: PUSH
86910: LD_INT 3
86912: MINUS
86913: PUSH
86914: LD_VAR 0 2
86918: PUSH
86919: LD_INT 1
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: LIST
86926: PUSH
86927: LD_VAR 0 1
86931: PUSH
86932: LD_INT 4
86934: MINUS
86935: PUSH
86936: LD_VAR 0 2
86940: PUSH
86941: LD_INT 4
86943: MINUS
86944: PUSH
86945: LD_INT 2
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: LIST
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: LIST
86957: LIST
86958: LIST
86959: ST_TO_ADDR
// end ; 3 :
86960: GO 87382
86962: LD_INT 3
86964: DOUBLE
86965: EQUAL
86966: IFTRUE 86970
86968: GO 87103
86970: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86971: LD_ADDR_VAR 0 5
86975: PUSH
86976: LD_VAR 0 1
86980: PUSH
86981: LD_INT 3
86983: PLUS
86984: PUSH
86985: LD_VAR 0 2
86989: PUSH
86990: LD_INT 4
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: LIST
86997: PUSH
86998: LD_VAR 0 1
87002: PUSH
87003: LD_INT 4
87005: PLUS
87006: PUSH
87007: LD_VAR 0 2
87011: PUSH
87012: LD_INT 4
87014: PLUS
87015: PUSH
87016: LD_INT 5
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: LIST
87023: PUSH
87024: LD_VAR 0 1
87028: PUSH
87029: LD_INT 4
87031: MINUS
87032: PUSH
87033: LD_VAR 0 2
87037: PUSH
87038: LD_INT 1
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: LIST
87045: PUSH
87046: LD_VAR 0 1
87050: PUSH
87051: LD_VAR 0 2
87055: PUSH
87056: LD_INT 4
87058: MINUS
87059: PUSH
87060: LD_INT 3
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: LIST
87067: PUSH
87068: LD_VAR 0 1
87072: PUSH
87073: LD_INT 3
87075: MINUS
87076: PUSH
87077: LD_VAR 0 2
87081: PUSH
87082: LD_INT 3
87084: MINUS
87085: PUSH
87086: LD_INT 2
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: LIST
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: LIST
87098: LIST
87099: LIST
87100: ST_TO_ADDR
// end ; 4 :
87101: GO 87382
87103: LD_INT 4
87105: DOUBLE
87106: EQUAL
87107: IFTRUE 87111
87109: GO 87244
87111: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
87112: LD_ADDR_VAR 0 5
87116: PUSH
87117: LD_VAR 0 1
87121: PUSH
87122: LD_VAR 0 2
87126: PUSH
87127: LD_INT 4
87129: PLUS
87130: PUSH
87131: LD_INT 0
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: LIST
87138: PUSH
87139: LD_VAR 0 1
87143: PUSH
87144: LD_INT 3
87146: PLUS
87147: PUSH
87148: LD_VAR 0 2
87152: PUSH
87153: LD_INT 3
87155: PLUS
87156: PUSH
87157: LD_INT 5
87159: PUSH
87160: EMPTY
87161: LIST
87162: LIST
87163: LIST
87164: PUSH
87165: LD_VAR 0 1
87169: PUSH
87170: LD_INT 4
87172: PLUS
87173: PUSH
87174: LD_VAR 0 2
87178: PUSH
87179: LD_INT 4
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: LIST
87186: PUSH
87187: LD_VAR 0 1
87191: PUSH
87192: LD_VAR 0 2
87196: PUSH
87197: LD_INT 3
87199: MINUS
87200: PUSH
87201: LD_INT 3
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: LIST
87208: PUSH
87209: LD_VAR 0 1
87213: PUSH
87214: LD_INT 4
87216: MINUS
87217: PUSH
87218: LD_VAR 0 2
87222: PUSH
87223: LD_INT 4
87225: MINUS
87226: PUSH
87227: LD_INT 2
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: LIST
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: ST_TO_ADDR
// end ; 5 :
87242: GO 87382
87244: LD_INT 5
87246: DOUBLE
87247: EQUAL
87248: IFTRUE 87252
87250: GO 87381
87252: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87253: LD_ADDR_VAR 0 5
87257: PUSH
87258: LD_VAR 0 1
87262: PUSH
87263: LD_INT 4
87265: MINUS
87266: PUSH
87267: LD_VAR 0 2
87271: PUSH
87272: LD_INT 1
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: LIST
87279: PUSH
87280: LD_VAR 0 1
87284: PUSH
87285: LD_VAR 0 2
87289: PUSH
87290: LD_INT 4
87292: MINUS
87293: PUSH
87294: LD_INT 3
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: LIST
87301: PUSH
87302: LD_VAR 0 1
87306: PUSH
87307: LD_INT 4
87309: PLUS
87310: PUSH
87311: LD_VAR 0 2
87315: PUSH
87316: LD_INT 4
87318: PLUS
87319: PUSH
87320: LD_INT 5
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: LIST
87327: PUSH
87328: LD_VAR 0 1
87332: PUSH
87333: LD_INT 3
87335: PLUS
87336: PUSH
87337: LD_VAR 0 2
87341: PUSH
87342: LD_INT 4
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: LIST
87349: PUSH
87350: LD_VAR 0 1
87354: PUSH
87355: LD_VAR 0 2
87359: PUSH
87360: LD_INT 3
87362: PLUS
87363: PUSH
87364: LD_INT 0
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: LIST
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: ST_TO_ADDR
// end ; end ;
87379: GO 87382
87381: POP
// result := list ;
87382: LD_ADDR_VAR 0 4
87386: PUSH
87387: LD_VAR 0 5
87391: ST_TO_ADDR
// end ;
87392: LD_VAR 0 4
87396: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
87397: LD_INT 0
87399: PPUSH
87400: PPUSH
87401: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
87402: LD_VAR 0 1
87406: NOT
87407: PUSH
87408: LD_VAR 0 2
87412: PUSH
87413: LD_INT 1
87415: PUSH
87416: LD_INT 2
87418: PUSH
87419: LD_INT 3
87421: PUSH
87422: LD_INT 4
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: LIST
87429: LIST
87430: IN
87431: NOT
87432: OR
87433: IFFALSE 87437
// exit ;
87435: GO 87529
// tmp := [ ] ;
87437: LD_ADDR_VAR 0 5
87441: PUSH
87442: EMPTY
87443: ST_TO_ADDR
// for i in units do
87444: LD_ADDR_VAR 0 4
87448: PUSH
87449: LD_VAR 0 1
87453: PUSH
87454: FOR_IN
87455: IFFALSE 87498
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
87457: LD_ADDR_VAR 0 5
87461: PUSH
87462: LD_VAR 0 5
87466: PPUSH
87467: LD_VAR 0 5
87471: PUSH
87472: LD_INT 1
87474: PLUS
87475: PPUSH
87476: LD_VAR 0 4
87480: PPUSH
87481: LD_VAR 0 2
87485: PPUSH
87486: CALL_OW 259
87490: PPUSH
87491: CALL_OW 2
87495: ST_TO_ADDR
87496: GO 87454
87498: POP
87499: POP
// if not tmp then
87500: LD_VAR 0 5
87504: NOT
87505: IFFALSE 87509
// exit ;
87507: GO 87529
// result := SortListByListDesc ( units , tmp ) ;
87509: LD_ADDR_VAR 0 3
87513: PUSH
87514: LD_VAR 0 1
87518: PPUSH
87519: LD_VAR 0 5
87523: PPUSH
87524: CALL_OW 77
87528: ST_TO_ADDR
// end ;
87529: LD_VAR 0 3
87533: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
87534: LD_INT 0
87536: PPUSH
87537: PPUSH
87538: PPUSH
// result := false ;
87539: LD_ADDR_VAR 0 3
87543: PUSH
87544: LD_INT 0
87546: ST_TO_ADDR
// x := GetX ( building ) ;
87547: LD_ADDR_VAR 0 4
87551: PUSH
87552: LD_VAR 0 2
87556: PPUSH
87557: CALL_OW 250
87561: ST_TO_ADDR
// y := GetY ( building ) ;
87562: LD_ADDR_VAR 0 5
87566: PUSH
87567: LD_VAR 0 2
87571: PPUSH
87572: CALL_OW 251
87576: ST_TO_ADDR
// if not building or not x or not y then
87577: LD_VAR 0 2
87581: NOT
87582: PUSH
87583: LD_VAR 0 4
87587: NOT
87588: OR
87589: PUSH
87590: LD_VAR 0 5
87594: NOT
87595: OR
87596: IFFALSE 87600
// exit ;
87598: GO 87692
// if GetTaskList ( unit ) then
87600: LD_VAR 0 1
87604: PPUSH
87605: CALL_OW 437
87609: IFFALSE 87692
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87611: LD_STRING e
87613: PUSH
87614: LD_VAR 0 1
87618: PPUSH
87619: CALL_OW 437
87623: PUSH
87624: LD_INT 1
87626: ARRAY
87627: PUSH
87628: LD_INT 1
87630: ARRAY
87631: EQUAL
87632: PUSH
87633: LD_VAR 0 4
87637: PUSH
87638: LD_VAR 0 1
87642: PPUSH
87643: CALL_OW 437
87647: PUSH
87648: LD_INT 1
87650: ARRAY
87651: PUSH
87652: LD_INT 2
87654: ARRAY
87655: EQUAL
87656: AND
87657: PUSH
87658: LD_VAR 0 5
87662: PUSH
87663: LD_VAR 0 1
87667: PPUSH
87668: CALL_OW 437
87672: PUSH
87673: LD_INT 1
87675: ARRAY
87676: PUSH
87677: LD_INT 3
87679: ARRAY
87680: EQUAL
87681: AND
87682: IFFALSE 87692
// result := true end ;
87684: LD_ADDR_VAR 0 3
87688: PUSH
87689: LD_INT 1
87691: ST_TO_ADDR
// end ;
87692: LD_VAR 0 3
87696: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
87697: LD_INT 0
87699: PPUSH
// result := false ;
87700: LD_ADDR_VAR 0 4
87704: PUSH
87705: LD_INT 0
87707: ST_TO_ADDR
// if GetTaskList ( unit ) then
87708: LD_VAR 0 1
87712: PPUSH
87713: CALL_OW 437
87717: IFFALSE 87800
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87719: LD_STRING M
87721: PUSH
87722: LD_VAR 0 1
87726: PPUSH
87727: CALL_OW 437
87731: PUSH
87732: LD_INT 1
87734: ARRAY
87735: PUSH
87736: LD_INT 1
87738: ARRAY
87739: EQUAL
87740: PUSH
87741: LD_VAR 0 2
87745: PUSH
87746: LD_VAR 0 1
87750: PPUSH
87751: CALL_OW 437
87755: PUSH
87756: LD_INT 1
87758: ARRAY
87759: PUSH
87760: LD_INT 2
87762: ARRAY
87763: EQUAL
87764: AND
87765: PUSH
87766: LD_VAR 0 3
87770: PUSH
87771: LD_VAR 0 1
87775: PPUSH
87776: CALL_OW 437
87780: PUSH
87781: LD_INT 1
87783: ARRAY
87784: PUSH
87785: LD_INT 3
87787: ARRAY
87788: EQUAL
87789: AND
87790: IFFALSE 87800
// result := true ;
87792: LD_ADDR_VAR 0 4
87796: PUSH
87797: LD_INT 1
87799: ST_TO_ADDR
// end ; end ;
87800: LD_VAR 0 4
87804: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
87805: LD_INT 0
87807: PPUSH
87808: PPUSH
87809: PPUSH
87810: PPUSH
// if not unit or not area then
87811: LD_VAR 0 1
87815: NOT
87816: PUSH
87817: LD_VAR 0 2
87821: NOT
87822: OR
87823: IFFALSE 87827
// exit ;
87825: GO 87991
// tmp := AreaToList ( area , i ) ;
87827: LD_ADDR_VAR 0 6
87831: PUSH
87832: LD_VAR 0 2
87836: PPUSH
87837: LD_VAR 0 5
87841: PPUSH
87842: CALL_OW 517
87846: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
87847: LD_ADDR_VAR 0 5
87851: PUSH
87852: DOUBLE
87853: LD_INT 1
87855: DEC
87856: ST_TO_ADDR
87857: LD_VAR 0 6
87861: PUSH
87862: LD_INT 1
87864: ARRAY
87865: PUSH
87866: FOR_TO
87867: IFFALSE 87989
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
87869: LD_ADDR_VAR 0 7
87873: PUSH
87874: LD_VAR 0 6
87878: PUSH
87879: LD_INT 1
87881: ARRAY
87882: PUSH
87883: LD_VAR 0 5
87887: ARRAY
87888: PUSH
87889: LD_VAR 0 6
87893: PUSH
87894: LD_INT 2
87896: ARRAY
87897: PUSH
87898: LD_VAR 0 5
87902: ARRAY
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
87908: LD_VAR 0 7
87912: PUSH
87913: LD_INT 1
87915: ARRAY
87916: PPUSH
87917: LD_VAR 0 7
87921: PUSH
87922: LD_INT 2
87924: ARRAY
87925: PPUSH
87926: CALL_OW 428
87930: PUSH
87931: LD_INT 0
87933: EQUAL
87934: IFFALSE 87987
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
87936: LD_VAR 0 1
87940: PPUSH
87941: LD_VAR 0 7
87945: PUSH
87946: LD_INT 1
87948: ARRAY
87949: PPUSH
87950: LD_VAR 0 7
87954: PUSH
87955: LD_INT 2
87957: ARRAY
87958: PPUSH
87959: LD_VAR 0 3
87963: PPUSH
87964: CALL_OW 48
// result := IsPlaced ( unit ) ;
87968: LD_ADDR_VAR 0 4
87972: PUSH
87973: LD_VAR 0 1
87977: PPUSH
87978: CALL_OW 305
87982: ST_TO_ADDR
// exit ;
87983: POP
87984: POP
87985: GO 87991
// end ; end ;
87987: GO 87866
87989: POP
87990: POP
// end ;
87991: LD_VAR 0 4
87995: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87996: LD_INT 0
87998: PPUSH
87999: PPUSH
88000: PPUSH
// if not side or side > 8 then
88001: LD_VAR 0 1
88005: NOT
88006: PUSH
88007: LD_VAR 0 1
88011: PUSH
88012: LD_INT 8
88014: GREATER
88015: OR
88016: IFFALSE 88020
// exit ;
88018: GO 88207
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
88020: LD_ADDR_VAR 0 4
88024: PUSH
88025: LD_INT 22
88027: PUSH
88028: LD_VAR 0 1
88032: PUSH
88033: EMPTY
88034: LIST
88035: LIST
88036: PUSH
88037: LD_INT 21
88039: PUSH
88040: LD_INT 3
88042: PUSH
88043: EMPTY
88044: LIST
88045: LIST
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: PPUSH
88051: CALL_OW 69
88055: ST_TO_ADDR
// if not tmp then
88056: LD_VAR 0 4
88060: NOT
88061: IFFALSE 88065
// exit ;
88063: GO 88207
// enable_addtolog := true ;
88065: LD_ADDR_OWVAR 81
88069: PUSH
88070: LD_INT 1
88072: ST_TO_ADDR
// AddToLog ( [ ) ;
88073: LD_STRING [
88075: PPUSH
88076: CALL_OW 561
// for i in tmp do
88080: LD_ADDR_VAR 0 3
88084: PUSH
88085: LD_VAR 0 4
88089: PUSH
88090: FOR_IN
88091: IFFALSE 88198
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
88093: LD_STRING [
88095: PUSH
88096: LD_VAR 0 3
88100: PPUSH
88101: CALL_OW 266
88105: STR
88106: PUSH
88107: LD_STRING , 
88109: STR
88110: PUSH
88111: LD_VAR 0 3
88115: PPUSH
88116: CALL_OW 250
88120: STR
88121: PUSH
88122: LD_STRING , 
88124: STR
88125: PUSH
88126: LD_VAR 0 3
88130: PPUSH
88131: CALL_OW 251
88135: STR
88136: PUSH
88137: LD_STRING , 
88139: STR
88140: PUSH
88141: LD_VAR 0 3
88145: PPUSH
88146: CALL_OW 254
88150: STR
88151: PUSH
88152: LD_STRING , 
88154: STR
88155: PUSH
88156: LD_VAR 0 3
88160: PPUSH
88161: LD_INT 1
88163: PPUSH
88164: CALL_OW 268
88168: STR
88169: PUSH
88170: LD_STRING , 
88172: STR
88173: PUSH
88174: LD_VAR 0 3
88178: PPUSH
88179: LD_INT 2
88181: PPUSH
88182: CALL_OW 268
88186: STR
88187: PUSH
88188: LD_STRING ],
88190: STR
88191: PPUSH
88192: CALL_OW 561
// end ;
88196: GO 88090
88198: POP
88199: POP
// AddToLog ( ]; ) ;
88200: LD_STRING ];
88202: PPUSH
88203: CALL_OW 561
// end ;
88207: LD_VAR 0 2
88211: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88212: LD_INT 0
88214: PPUSH
88215: PPUSH
88216: PPUSH
88217: PPUSH
88218: PPUSH
// if not area or not rate or not max then
88219: LD_VAR 0 1
88223: NOT
88224: PUSH
88225: LD_VAR 0 2
88229: NOT
88230: OR
88231: PUSH
88232: LD_VAR 0 4
88236: NOT
88237: OR
88238: IFFALSE 88242
// exit ;
88240: GO 88431
// while 1 do
88242: LD_INT 1
88244: IFFALSE 88431
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88246: LD_ADDR_VAR 0 9
88250: PUSH
88251: LD_VAR 0 1
88255: PPUSH
88256: LD_INT 1
88258: PPUSH
88259: CALL_OW 287
88263: PUSH
88264: LD_INT 10
88266: MUL
88267: ST_TO_ADDR
// r := rate / 10 ;
88268: LD_ADDR_VAR 0 7
88272: PUSH
88273: LD_VAR 0 2
88277: PUSH
88278: LD_INT 10
88280: DIVREAL
88281: ST_TO_ADDR
// time := 1 1$00 ;
88282: LD_ADDR_VAR 0 8
88286: PUSH
88287: LD_INT 2100
88289: ST_TO_ADDR
// if amount < min then
88290: LD_VAR 0 9
88294: PUSH
88295: LD_VAR 0 3
88299: LESS
88300: IFFALSE 88318
// r := r * 2 else
88302: LD_ADDR_VAR 0 7
88306: PUSH
88307: LD_VAR 0 7
88311: PUSH
88312: LD_INT 2
88314: MUL
88315: ST_TO_ADDR
88316: GO 88344
// if amount > max then
88318: LD_VAR 0 9
88322: PUSH
88323: LD_VAR 0 4
88327: GREATER
88328: IFFALSE 88344
// r := r / 2 ;
88330: LD_ADDR_VAR 0 7
88334: PUSH
88335: LD_VAR 0 7
88339: PUSH
88340: LD_INT 2
88342: DIVREAL
88343: ST_TO_ADDR
// time := time / r ;
88344: LD_ADDR_VAR 0 8
88348: PUSH
88349: LD_VAR 0 8
88353: PUSH
88354: LD_VAR 0 7
88358: DIVREAL
88359: ST_TO_ADDR
// if time < 0 then
88360: LD_VAR 0 8
88364: PUSH
88365: LD_INT 0
88367: LESS
88368: IFFALSE 88385
// time := time * - 1 ;
88370: LD_ADDR_VAR 0 8
88374: PUSH
88375: LD_VAR 0 8
88379: PUSH
88380: LD_INT 1
88382: NEG
88383: MUL
88384: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
88385: LD_VAR 0 8
88389: PUSH
88390: LD_INT 35
88392: PPUSH
88393: LD_INT 875
88395: PPUSH
88396: CALL_OW 12
88400: PLUS
88401: PPUSH
88402: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
88406: LD_INT 1
88408: PPUSH
88409: LD_INT 5
88411: PPUSH
88412: CALL_OW 12
88416: PPUSH
88417: LD_VAR 0 1
88421: PPUSH
88422: LD_INT 1
88424: PPUSH
88425: CALL_OW 55
// end ;
88429: GO 88242
// end ;
88431: LD_VAR 0 5
88435: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
88436: LD_INT 0
88438: PPUSH
88439: PPUSH
88440: PPUSH
88441: PPUSH
88442: PPUSH
88443: PPUSH
88444: PPUSH
88445: PPUSH
// if not turrets or not factories then
88446: LD_VAR 0 1
88450: NOT
88451: PUSH
88452: LD_VAR 0 2
88456: NOT
88457: OR
88458: IFFALSE 88462
// exit ;
88460: GO 88769
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
88462: LD_ADDR_VAR 0 10
88466: PUSH
88467: LD_INT 5
88469: PUSH
88470: LD_INT 6
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: PUSH
88477: LD_INT 2
88479: PUSH
88480: LD_INT 4
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: PUSH
88487: LD_INT 3
88489: PUSH
88490: LD_INT 5
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: EMPTY
88498: LIST
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 24
88504: PUSH
88505: LD_INT 25
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: LD_INT 23
88514: PUSH
88515: LD_INT 27
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: EMPTY
88523: LIST
88524: LIST
88525: PUSH
88526: LD_INT 42
88528: PUSH
88529: LD_INT 43
88531: PUSH
88532: EMPTY
88533: LIST
88534: LIST
88535: PUSH
88536: LD_INT 44
88538: PUSH
88539: LD_INT 46
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 45
88548: PUSH
88549: LD_INT 47
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: LIST
88560: PUSH
88561: EMPTY
88562: LIST
88563: LIST
88564: LIST
88565: ST_TO_ADDR
// result := [ ] ;
88566: LD_ADDR_VAR 0 3
88570: PUSH
88571: EMPTY
88572: ST_TO_ADDR
// for i in turrets do
88573: LD_ADDR_VAR 0 4
88577: PUSH
88578: LD_VAR 0 1
88582: PUSH
88583: FOR_IN
88584: IFFALSE 88767
// begin nat := GetNation ( i ) ;
88586: LD_ADDR_VAR 0 7
88590: PUSH
88591: LD_VAR 0 4
88595: PPUSH
88596: CALL_OW 248
88600: ST_TO_ADDR
// weapon := 0 ;
88601: LD_ADDR_VAR 0 8
88605: PUSH
88606: LD_INT 0
88608: ST_TO_ADDR
// if not nat then
88609: LD_VAR 0 7
88613: NOT
88614: IFFALSE 88618
// continue ;
88616: GO 88583
// for j in list [ nat ] do
88618: LD_ADDR_VAR 0 5
88622: PUSH
88623: LD_VAR 0 10
88627: PUSH
88628: LD_VAR 0 7
88632: ARRAY
88633: PUSH
88634: FOR_IN
88635: IFFALSE 88676
// if GetBWeapon ( i ) = j [ 1 ] then
88637: LD_VAR 0 4
88641: PPUSH
88642: CALL_OW 269
88646: PUSH
88647: LD_VAR 0 5
88651: PUSH
88652: LD_INT 1
88654: ARRAY
88655: EQUAL
88656: IFFALSE 88674
// begin weapon := j [ 2 ] ;
88658: LD_ADDR_VAR 0 8
88662: PUSH
88663: LD_VAR 0 5
88667: PUSH
88668: LD_INT 2
88670: ARRAY
88671: ST_TO_ADDR
// break ;
88672: GO 88676
// end ;
88674: GO 88634
88676: POP
88677: POP
// if not weapon then
88678: LD_VAR 0 8
88682: NOT
88683: IFFALSE 88687
// continue ;
88685: GO 88583
// for k in factories do
88687: LD_ADDR_VAR 0 6
88691: PUSH
88692: LD_VAR 0 2
88696: PUSH
88697: FOR_IN
88698: IFFALSE 88763
// begin weapons := AvailableWeaponList ( k ) ;
88700: LD_ADDR_VAR 0 9
88704: PUSH
88705: LD_VAR 0 6
88709: PPUSH
88710: CALL_OW 478
88714: ST_TO_ADDR
// if not weapons then
88715: LD_VAR 0 9
88719: NOT
88720: IFFALSE 88724
// continue ;
88722: GO 88697
// if weapon in weapons then
88724: LD_VAR 0 8
88728: PUSH
88729: LD_VAR 0 9
88733: IN
88734: IFFALSE 88761
// begin result := [ i , weapon ] ;
88736: LD_ADDR_VAR 0 3
88740: PUSH
88741: LD_VAR 0 4
88745: PUSH
88746: LD_VAR 0 8
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: ST_TO_ADDR
// exit ;
88755: POP
88756: POP
88757: POP
88758: POP
88759: GO 88769
// end ; end ;
88761: GO 88697
88763: POP
88764: POP
// end ;
88765: GO 88583
88767: POP
88768: POP
// end ;
88769: LD_VAR 0 3
88773: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
88774: LD_INT 0
88776: PPUSH
// if not side or side > 8 then
88777: LD_VAR 0 3
88781: NOT
88782: PUSH
88783: LD_VAR 0 3
88787: PUSH
88788: LD_INT 8
88790: GREATER
88791: OR
88792: IFFALSE 88796
// exit ;
88794: GO 88855
// if not range then
88796: LD_VAR 0 4
88800: NOT
88801: IFFALSE 88812
// range := - 12 ;
88803: LD_ADDR_VAR 0 4
88807: PUSH
88808: LD_INT 12
88810: NEG
88811: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
88812: LD_VAR 0 1
88816: PPUSH
88817: LD_VAR 0 2
88821: PPUSH
88822: LD_VAR 0 3
88826: PPUSH
88827: LD_VAR 0 4
88831: PPUSH
88832: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
88836: LD_VAR 0 1
88840: PPUSH
88841: LD_VAR 0 2
88845: PPUSH
88846: LD_VAR 0 3
88850: PPUSH
88851: CALL_OW 331
// end ;
88855: LD_VAR 0 5
88859: RET
// export function Video ( mode ) ; begin
88860: LD_INT 0
88862: PPUSH
// ingame_video = mode ;
88863: LD_ADDR_OWVAR 52
88867: PUSH
88868: LD_VAR 0 1
88872: ST_TO_ADDR
// interface_hidden = mode ;
88873: LD_ADDR_OWVAR 54
88877: PUSH
88878: LD_VAR 0 1
88882: ST_TO_ADDR
// end ;
88883: LD_VAR 0 2
88887: RET
// export function Join ( array , element ) ; begin
88888: LD_INT 0
88890: PPUSH
// result := Replace ( array , array + 1 , element ) ;
88891: LD_ADDR_VAR 0 3
88895: PUSH
88896: LD_VAR 0 1
88900: PPUSH
88901: LD_VAR 0 1
88905: PUSH
88906: LD_INT 1
88908: PLUS
88909: PPUSH
88910: LD_VAR 0 2
88914: PPUSH
88915: CALL_OW 1
88919: ST_TO_ADDR
// end ;
88920: LD_VAR 0 3
88924: RET
// export function JoinUnion ( array , element ) ; begin
88925: LD_INT 0
88927: PPUSH
// result := array union element ;
88928: LD_ADDR_VAR 0 3
88932: PUSH
88933: LD_VAR 0 1
88937: PUSH
88938: LD_VAR 0 2
88942: UNION
88943: ST_TO_ADDR
// end ;
88944: LD_VAR 0 3
88948: RET
// export function GetBehemoths ( side ) ; begin
88949: LD_INT 0
88951: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
88952: LD_ADDR_VAR 0 2
88956: PUSH
88957: LD_INT 22
88959: PUSH
88960: LD_VAR 0 1
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 31
88971: PUSH
88972: LD_INT 25
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PPUSH
88983: CALL_OW 69
88987: ST_TO_ADDR
// end ;
88988: LD_VAR 0 2
88992: RET
// export function Shuffle ( array ) ; var i , index ; begin
88993: LD_INT 0
88995: PPUSH
88996: PPUSH
88997: PPUSH
// result := [ ] ;
88998: LD_ADDR_VAR 0 2
89002: PUSH
89003: EMPTY
89004: ST_TO_ADDR
// if not array then
89005: LD_VAR 0 1
89009: NOT
89010: IFFALSE 89014
// exit ;
89012: GO 89113
// Randomize ;
89014: CALL_OW 10
// for i = array downto 1 do
89018: LD_ADDR_VAR 0 3
89022: PUSH
89023: DOUBLE
89024: LD_VAR 0 1
89028: INC
89029: ST_TO_ADDR
89030: LD_INT 1
89032: PUSH
89033: FOR_DOWNTO
89034: IFFALSE 89111
// begin index := rand ( 1 , array ) ;
89036: LD_ADDR_VAR 0 4
89040: PUSH
89041: LD_INT 1
89043: PPUSH
89044: LD_VAR 0 1
89048: PPUSH
89049: CALL_OW 12
89053: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
89054: LD_ADDR_VAR 0 2
89058: PUSH
89059: LD_VAR 0 2
89063: PPUSH
89064: LD_VAR 0 2
89068: PUSH
89069: LD_INT 1
89071: PLUS
89072: PPUSH
89073: LD_VAR 0 1
89077: PUSH
89078: LD_VAR 0 4
89082: ARRAY
89083: PPUSH
89084: CALL_OW 2
89088: ST_TO_ADDR
// array := Delete ( array , index ) ;
89089: LD_ADDR_VAR 0 1
89093: PUSH
89094: LD_VAR 0 1
89098: PPUSH
89099: LD_VAR 0 4
89103: PPUSH
89104: CALL_OW 3
89108: ST_TO_ADDR
// end ;
89109: GO 89033
89111: POP
89112: POP
// end ;
89113: LD_VAR 0 2
89117: RET
// export function GetBaseMaterials ( base ) ; begin
89118: LD_INT 0
89120: PPUSH
// result := [ 0 , 0 , 0 ] ;
89121: LD_ADDR_VAR 0 2
89125: PUSH
89126: LD_INT 0
89128: PUSH
89129: LD_INT 0
89131: PUSH
89132: LD_INT 0
89134: PUSH
89135: EMPTY
89136: LIST
89137: LIST
89138: LIST
89139: ST_TO_ADDR
// if not base then
89140: LD_VAR 0 1
89144: NOT
89145: IFFALSE 89149
// exit ;
89147: GO 89198
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89149: LD_ADDR_VAR 0 2
89153: PUSH
89154: LD_VAR 0 1
89158: PPUSH
89159: LD_INT 1
89161: PPUSH
89162: CALL_OW 275
89166: PUSH
89167: LD_VAR 0 1
89171: PPUSH
89172: LD_INT 2
89174: PPUSH
89175: CALL_OW 275
89179: PUSH
89180: LD_VAR 0 1
89184: PPUSH
89185: LD_INT 3
89187: PPUSH
89188: CALL_OW 275
89192: PUSH
89193: EMPTY
89194: LIST
89195: LIST
89196: LIST
89197: ST_TO_ADDR
// end ;
89198: LD_VAR 0 2
89202: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89203: LD_INT 0
89205: PPUSH
89206: PPUSH
// result := array ;
89207: LD_ADDR_VAR 0 3
89211: PUSH
89212: LD_VAR 0 1
89216: ST_TO_ADDR
// if size > 0 then
89217: LD_VAR 0 2
89221: PUSH
89222: LD_INT 0
89224: GREATER
89225: IFFALSE 89271
// for i := array downto size do
89227: LD_ADDR_VAR 0 4
89231: PUSH
89232: DOUBLE
89233: LD_VAR 0 1
89237: INC
89238: ST_TO_ADDR
89239: LD_VAR 0 2
89243: PUSH
89244: FOR_DOWNTO
89245: IFFALSE 89269
// result := Delete ( result , result ) ;
89247: LD_ADDR_VAR 0 3
89251: PUSH
89252: LD_VAR 0 3
89256: PPUSH
89257: LD_VAR 0 3
89261: PPUSH
89262: CALL_OW 3
89266: ST_TO_ADDR
89267: GO 89244
89269: POP
89270: POP
// end ;
89271: LD_VAR 0 3
89275: RET
// export function ComExit ( unit ) ; var tmp ; begin
89276: LD_INT 0
89278: PPUSH
89279: PPUSH
// if not IsInUnit ( unit ) then
89280: LD_VAR 0 1
89284: PPUSH
89285: CALL_OW 310
89289: NOT
89290: IFFALSE 89294
// exit ;
89292: GO 89354
// tmp := IsInUnit ( unit ) ;
89294: LD_ADDR_VAR 0 3
89298: PUSH
89299: LD_VAR 0 1
89303: PPUSH
89304: CALL_OW 310
89308: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89309: LD_VAR 0 3
89313: PPUSH
89314: CALL_OW 247
89318: PUSH
89319: LD_INT 2
89321: EQUAL
89322: IFFALSE 89335
// ComExitVehicle ( unit ) else
89324: LD_VAR 0 1
89328: PPUSH
89329: CALL_OW 121
89333: GO 89344
// ComExitBuilding ( unit ) ;
89335: LD_VAR 0 1
89339: PPUSH
89340: CALL_OW 122
// result := tmp ;
89344: LD_ADDR_VAR 0 2
89348: PUSH
89349: LD_VAR 0 3
89353: ST_TO_ADDR
// end ;
89354: LD_VAR 0 2
89358: RET
// export function ComExitAll ( units ) ; var i ; begin
89359: LD_INT 0
89361: PPUSH
89362: PPUSH
// if not units then
89363: LD_VAR 0 1
89367: NOT
89368: IFFALSE 89372
// exit ;
89370: GO 89398
// for i in units do
89372: LD_ADDR_VAR 0 3
89376: PUSH
89377: LD_VAR 0 1
89381: PUSH
89382: FOR_IN
89383: IFFALSE 89396
// ComExit ( i ) ;
89385: LD_VAR 0 3
89389: PPUSH
89390: CALL 89276 0 1
89394: GO 89382
89396: POP
89397: POP
// end ;
89398: LD_VAR 0 2
89402: RET
// export function ResetHc ; begin
89403: LD_INT 0
89405: PPUSH
// InitHc ;
89406: CALL_OW 19
// hc_importance := 0 ;
89410: LD_ADDR_OWVAR 32
89414: PUSH
89415: LD_INT 0
89417: ST_TO_ADDR
// end ;
89418: LD_VAR 0 1
89422: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
89423: LD_INT 0
89425: PPUSH
89426: PPUSH
89427: PPUSH
// _x := ( x1 + x2 ) div 2 ;
89428: LD_ADDR_VAR 0 6
89432: PUSH
89433: LD_VAR 0 1
89437: PUSH
89438: LD_VAR 0 3
89442: PLUS
89443: PUSH
89444: LD_INT 2
89446: DIV
89447: ST_TO_ADDR
// if _x < 0 then
89448: LD_VAR 0 6
89452: PUSH
89453: LD_INT 0
89455: LESS
89456: IFFALSE 89473
// _x := _x * - 1 ;
89458: LD_ADDR_VAR 0 6
89462: PUSH
89463: LD_VAR 0 6
89467: PUSH
89468: LD_INT 1
89470: NEG
89471: MUL
89472: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
89473: LD_ADDR_VAR 0 7
89477: PUSH
89478: LD_VAR 0 2
89482: PUSH
89483: LD_VAR 0 4
89487: PLUS
89488: PUSH
89489: LD_INT 2
89491: DIV
89492: ST_TO_ADDR
// if _y < 0 then
89493: LD_VAR 0 7
89497: PUSH
89498: LD_INT 0
89500: LESS
89501: IFFALSE 89518
// _y := _y * - 1 ;
89503: LD_ADDR_VAR 0 7
89507: PUSH
89508: LD_VAR 0 7
89512: PUSH
89513: LD_INT 1
89515: NEG
89516: MUL
89517: ST_TO_ADDR
// result := [ _x , _y ] ;
89518: LD_ADDR_VAR 0 5
89522: PUSH
89523: LD_VAR 0 6
89527: PUSH
89528: LD_VAR 0 7
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: ST_TO_ADDR
// end ;
89537: LD_VAR 0 5
89541: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
89542: LD_INT 0
89544: PPUSH
89545: PPUSH
89546: PPUSH
89547: PPUSH
// task := GetTaskList ( unit ) ;
89548: LD_ADDR_VAR 0 7
89552: PUSH
89553: LD_VAR 0 1
89557: PPUSH
89558: CALL_OW 437
89562: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
89563: LD_VAR 0 7
89567: NOT
89568: PUSH
89569: LD_VAR 0 1
89573: PPUSH
89574: LD_VAR 0 2
89578: PPUSH
89579: CALL_OW 308
89583: NOT
89584: AND
89585: IFFALSE 89589
// exit ;
89587: GO 89707
// if IsInArea ( unit , area ) then
89589: LD_VAR 0 1
89593: PPUSH
89594: LD_VAR 0 2
89598: PPUSH
89599: CALL_OW 308
89603: IFFALSE 89621
// begin ComMoveToArea ( unit , goAway ) ;
89605: LD_VAR 0 1
89609: PPUSH
89610: LD_VAR 0 3
89614: PPUSH
89615: CALL_OW 113
// exit ;
89619: GO 89707
// end ; if task [ 1 ] [ 1 ] <> M then
89621: LD_VAR 0 7
89625: PUSH
89626: LD_INT 1
89628: ARRAY
89629: PUSH
89630: LD_INT 1
89632: ARRAY
89633: PUSH
89634: LD_STRING M
89636: NONEQUAL
89637: IFFALSE 89641
// exit ;
89639: GO 89707
// x := task [ 1 ] [ 2 ] ;
89641: LD_ADDR_VAR 0 5
89645: PUSH
89646: LD_VAR 0 7
89650: PUSH
89651: LD_INT 1
89653: ARRAY
89654: PUSH
89655: LD_INT 2
89657: ARRAY
89658: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
89659: LD_ADDR_VAR 0 6
89663: PUSH
89664: LD_VAR 0 7
89668: PUSH
89669: LD_INT 1
89671: ARRAY
89672: PUSH
89673: LD_INT 3
89675: ARRAY
89676: ST_TO_ADDR
// if InArea ( x , y , area ) then
89677: LD_VAR 0 5
89681: PPUSH
89682: LD_VAR 0 6
89686: PPUSH
89687: LD_VAR 0 2
89691: PPUSH
89692: CALL_OW 309
89696: IFFALSE 89707
// ComStop ( unit ) ;
89698: LD_VAR 0 1
89702: PPUSH
89703: CALL_OW 141
// end ;
89707: LD_VAR 0 4
89711: RET
// export function Abs ( value ) ; begin
89712: LD_INT 0
89714: PPUSH
// result := value ;
89715: LD_ADDR_VAR 0 2
89719: PUSH
89720: LD_VAR 0 1
89724: ST_TO_ADDR
// if value < 0 then
89725: LD_VAR 0 1
89729: PUSH
89730: LD_INT 0
89732: LESS
89733: IFFALSE 89750
// result := value * - 1 ;
89735: LD_ADDR_VAR 0 2
89739: PUSH
89740: LD_VAR 0 1
89744: PUSH
89745: LD_INT 1
89747: NEG
89748: MUL
89749: ST_TO_ADDR
// end ;
89750: LD_VAR 0 2
89754: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
89755: LD_INT 0
89757: PPUSH
89758: PPUSH
89759: PPUSH
89760: PPUSH
89761: PPUSH
89762: PPUSH
89763: PPUSH
89764: PPUSH
// if not unit or not building then
89765: LD_VAR 0 1
89769: NOT
89770: PUSH
89771: LD_VAR 0 2
89775: NOT
89776: OR
89777: IFFALSE 89781
// exit ;
89779: GO 90007
// x := GetX ( building ) ;
89781: LD_ADDR_VAR 0 4
89785: PUSH
89786: LD_VAR 0 2
89790: PPUSH
89791: CALL_OW 250
89795: ST_TO_ADDR
// y := GetY ( building ) ;
89796: LD_ADDR_VAR 0 6
89800: PUSH
89801: LD_VAR 0 2
89805: PPUSH
89806: CALL_OW 251
89810: ST_TO_ADDR
// d := GetDir ( building ) ;
89811: LD_ADDR_VAR 0 8
89815: PUSH
89816: LD_VAR 0 2
89820: PPUSH
89821: CALL_OW 254
89825: ST_TO_ADDR
// r := 4 ;
89826: LD_ADDR_VAR 0 9
89830: PUSH
89831: LD_INT 4
89833: ST_TO_ADDR
// for i := 1 to 5 do
89834: LD_ADDR_VAR 0 10
89838: PUSH
89839: DOUBLE
89840: LD_INT 1
89842: DEC
89843: ST_TO_ADDR
89844: LD_INT 5
89846: PUSH
89847: FOR_TO
89848: IFFALSE 90005
// begin _x := ShiftX ( x , d , r + i ) ;
89850: LD_ADDR_VAR 0 5
89854: PUSH
89855: LD_VAR 0 4
89859: PPUSH
89860: LD_VAR 0 8
89864: PPUSH
89865: LD_VAR 0 9
89869: PUSH
89870: LD_VAR 0 10
89874: PLUS
89875: PPUSH
89876: CALL_OW 272
89880: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
89881: LD_ADDR_VAR 0 7
89885: PUSH
89886: LD_VAR 0 6
89890: PPUSH
89891: LD_VAR 0 8
89895: PPUSH
89896: LD_VAR 0 9
89900: PUSH
89901: LD_VAR 0 10
89905: PLUS
89906: PPUSH
89907: CALL_OW 273
89911: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
89912: LD_VAR 0 5
89916: PPUSH
89917: LD_VAR 0 7
89921: PPUSH
89922: CALL_OW 488
89926: PUSH
89927: LD_VAR 0 5
89931: PPUSH
89932: LD_VAR 0 7
89936: PPUSH
89937: CALL_OW 428
89941: PPUSH
89942: CALL_OW 247
89946: PUSH
89947: LD_INT 3
89949: PUSH
89950: LD_INT 2
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: IN
89957: NOT
89958: AND
89959: IFFALSE 90003
// begin ComMoveXY ( unit , _x , _y ) ;
89961: LD_VAR 0 1
89965: PPUSH
89966: LD_VAR 0 5
89970: PPUSH
89971: LD_VAR 0 7
89975: PPUSH
89976: CALL_OW 111
// result := [ _x , _y ] ;
89980: LD_ADDR_VAR 0 3
89984: PUSH
89985: LD_VAR 0 5
89989: PUSH
89990: LD_VAR 0 7
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: ST_TO_ADDR
// exit ;
89999: POP
90000: POP
90001: GO 90007
// end ; end ;
90003: GO 89847
90005: POP
90006: POP
// end ;
90007: LD_VAR 0 3
90011: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
90012: LD_INT 0
90014: PPUSH
90015: PPUSH
90016: PPUSH
// result := 0 ;
90017: LD_ADDR_VAR 0 3
90021: PUSH
90022: LD_INT 0
90024: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
90025: LD_VAR 0 1
90029: PUSH
90030: LD_INT 0
90032: LESS
90033: PUSH
90034: LD_VAR 0 1
90038: PUSH
90039: LD_INT 8
90041: GREATER
90042: OR
90043: PUSH
90044: LD_VAR 0 2
90048: PUSH
90049: LD_INT 0
90051: LESS
90052: OR
90053: PUSH
90054: LD_VAR 0 2
90058: PUSH
90059: LD_INT 8
90061: GREATER
90062: OR
90063: IFFALSE 90067
// exit ;
90065: GO 90142
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
90067: LD_ADDR_VAR 0 4
90071: PUSH
90072: LD_INT 22
90074: PUSH
90075: LD_VAR 0 2
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: PPUSH
90084: CALL_OW 69
90088: PUSH
90089: FOR_IN
90090: IFFALSE 90140
// begin un := UnitShoot ( i ) ;
90092: LD_ADDR_VAR 0 5
90096: PUSH
90097: LD_VAR 0 4
90101: PPUSH
90102: CALL_OW 504
90106: ST_TO_ADDR
// if GetSide ( un ) = side1 then
90107: LD_VAR 0 5
90111: PPUSH
90112: CALL_OW 255
90116: PUSH
90117: LD_VAR 0 1
90121: EQUAL
90122: IFFALSE 90138
// begin result := un ;
90124: LD_ADDR_VAR 0 3
90128: PUSH
90129: LD_VAR 0 5
90133: ST_TO_ADDR
// exit ;
90134: POP
90135: POP
90136: GO 90142
// end ; end ;
90138: GO 90089
90140: POP
90141: POP
// end ;
90142: LD_VAR 0 3
90146: RET
// export function GetCargoBay ( units ) ; begin
90147: LD_INT 0
90149: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
90150: LD_ADDR_VAR 0 2
90154: PUSH
90155: LD_VAR 0 1
90159: PPUSH
90160: LD_INT 2
90162: PUSH
90163: LD_INT 34
90165: PUSH
90166: LD_INT 12
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: PUSH
90173: LD_INT 34
90175: PUSH
90176: LD_INT 51
90178: PUSH
90179: EMPTY
90180: LIST
90181: LIST
90182: PUSH
90183: LD_INT 34
90185: PUSH
90186: LD_INT 32
90188: PUSH
90189: EMPTY
90190: LIST
90191: LIST
90192: PUSH
90193: LD_INT 34
90195: PUSH
90196: LD_EXP 75
90200: PUSH
90201: EMPTY
90202: LIST
90203: LIST
90204: PUSH
90205: EMPTY
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: LIST
90211: PPUSH
90212: CALL_OW 72
90216: ST_TO_ADDR
// end ;
90217: LD_VAR 0 2
90221: RET
// export function Negate ( value ) ; begin
90222: LD_INT 0
90224: PPUSH
// result := not value ;
90225: LD_ADDR_VAR 0 2
90229: PUSH
90230: LD_VAR 0 1
90234: NOT
90235: ST_TO_ADDR
// end ;
90236: LD_VAR 0 2
90240: RET
// export function Inc ( value ) ; begin
90241: LD_INT 0
90243: PPUSH
// result := value + 1 ;
90244: LD_ADDR_VAR 0 2
90248: PUSH
90249: LD_VAR 0 1
90253: PUSH
90254: LD_INT 1
90256: PLUS
90257: ST_TO_ADDR
// end ;
90258: LD_VAR 0 2
90262: RET
// export function Dec ( value ) ; begin
90263: LD_INT 0
90265: PPUSH
// result := value - 1 ;
90266: LD_ADDR_VAR 0 2
90270: PUSH
90271: LD_VAR 0 1
90275: PUSH
90276: LD_INT 1
90278: MINUS
90279: ST_TO_ADDR
// end ;
90280: LD_VAR 0 2
90284: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
90285: LD_INT 0
90287: PPUSH
90288: PPUSH
90289: PPUSH
90290: PPUSH
90291: PPUSH
90292: PPUSH
90293: PPUSH
90294: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
90295: LD_VAR 0 1
90299: PPUSH
90300: LD_VAR 0 2
90304: PPUSH
90305: CALL_OW 488
90309: NOT
90310: PUSH
90311: LD_VAR 0 3
90315: PPUSH
90316: LD_VAR 0 4
90320: PPUSH
90321: CALL_OW 488
90325: NOT
90326: OR
90327: IFFALSE 90340
// begin result := - 1 ;
90329: LD_ADDR_VAR 0 5
90333: PUSH
90334: LD_INT 1
90336: NEG
90337: ST_TO_ADDR
// exit ;
90338: GO 90575
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
90340: LD_ADDR_VAR 0 12
90344: PUSH
90345: LD_VAR 0 1
90349: PPUSH
90350: LD_VAR 0 2
90354: PPUSH
90355: LD_VAR 0 3
90359: PPUSH
90360: LD_VAR 0 4
90364: PPUSH
90365: CALL 89423 0 4
90369: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
90370: LD_ADDR_VAR 0 11
90374: PUSH
90375: LD_VAR 0 1
90379: PPUSH
90380: LD_VAR 0 2
90384: PPUSH
90385: LD_VAR 0 12
90389: PUSH
90390: LD_INT 1
90392: ARRAY
90393: PPUSH
90394: LD_VAR 0 12
90398: PUSH
90399: LD_INT 2
90401: ARRAY
90402: PPUSH
90403: CALL_OW 298
90407: ST_TO_ADDR
// distance := 9999 ;
90408: LD_ADDR_VAR 0 10
90412: PUSH
90413: LD_INT 9999
90415: ST_TO_ADDR
// for i := 0 to 5 do
90416: LD_ADDR_VAR 0 6
90420: PUSH
90421: DOUBLE
90422: LD_INT 0
90424: DEC
90425: ST_TO_ADDR
90426: LD_INT 5
90428: PUSH
90429: FOR_TO
90430: IFFALSE 90573
// begin _x := ShiftX ( x1 , i , centerDist ) ;
90432: LD_ADDR_VAR 0 7
90436: PUSH
90437: LD_VAR 0 1
90441: PPUSH
90442: LD_VAR 0 6
90446: PPUSH
90447: LD_VAR 0 11
90451: PPUSH
90452: CALL_OW 272
90456: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
90457: LD_ADDR_VAR 0 8
90461: PUSH
90462: LD_VAR 0 2
90466: PPUSH
90467: LD_VAR 0 6
90471: PPUSH
90472: LD_VAR 0 11
90476: PPUSH
90477: CALL_OW 273
90481: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
90482: LD_VAR 0 7
90486: PPUSH
90487: LD_VAR 0 8
90491: PPUSH
90492: CALL_OW 488
90496: NOT
90497: IFFALSE 90501
// continue ;
90499: GO 90429
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
90501: LD_ADDR_VAR 0 9
90505: PUSH
90506: LD_VAR 0 12
90510: PUSH
90511: LD_INT 1
90513: ARRAY
90514: PPUSH
90515: LD_VAR 0 12
90519: PUSH
90520: LD_INT 2
90522: ARRAY
90523: PPUSH
90524: LD_VAR 0 7
90528: PPUSH
90529: LD_VAR 0 8
90533: PPUSH
90534: CALL_OW 298
90538: ST_TO_ADDR
// if tmp < distance then
90539: LD_VAR 0 9
90543: PUSH
90544: LD_VAR 0 10
90548: LESS
90549: IFFALSE 90571
// begin result := i ;
90551: LD_ADDR_VAR 0 5
90555: PUSH
90556: LD_VAR 0 6
90560: ST_TO_ADDR
// distance := tmp ;
90561: LD_ADDR_VAR 0 10
90565: PUSH
90566: LD_VAR 0 9
90570: ST_TO_ADDR
// end ; end ;
90571: GO 90429
90573: POP
90574: POP
// end ;
90575: LD_VAR 0 5
90579: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90580: LD_INT 0
90582: PPUSH
90583: PPUSH
// if not driver or not IsInUnit ( driver ) then
90584: LD_VAR 0 1
90588: NOT
90589: PUSH
90590: LD_VAR 0 1
90594: PPUSH
90595: CALL_OW 310
90599: NOT
90600: OR
90601: IFFALSE 90605
// exit ;
90603: GO 90695
// vehicle := IsInUnit ( driver ) ;
90605: LD_ADDR_VAR 0 3
90609: PUSH
90610: LD_VAR 0 1
90614: PPUSH
90615: CALL_OW 310
90619: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90620: LD_VAR 0 1
90624: PPUSH
90625: LD_STRING \
90627: PUSH
90628: LD_INT 0
90630: PUSH
90631: LD_INT 0
90633: PUSH
90634: LD_INT 0
90636: PUSH
90637: LD_INT 0
90639: PUSH
90640: LD_INT 0
90642: PUSH
90643: LD_INT 0
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: PUSH
90655: LD_STRING E
90657: PUSH
90658: LD_INT 0
90660: PUSH
90661: LD_INT 0
90663: PUSH
90664: LD_VAR 0 3
90668: PUSH
90669: LD_INT 0
90671: PUSH
90672: LD_INT 0
90674: PUSH
90675: LD_INT 0
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: LIST
90682: LIST
90683: LIST
90684: LIST
90685: LIST
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PPUSH
90691: CALL_OW 446
// end ;
90695: LD_VAR 0 2
90699: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90700: LD_INT 0
90702: PPUSH
90703: PPUSH
// if not driver or not IsInUnit ( driver ) then
90704: LD_VAR 0 1
90708: NOT
90709: PUSH
90710: LD_VAR 0 1
90714: PPUSH
90715: CALL_OW 310
90719: NOT
90720: OR
90721: IFFALSE 90725
// exit ;
90723: GO 90815
// vehicle := IsInUnit ( driver ) ;
90725: LD_ADDR_VAR 0 3
90729: PUSH
90730: LD_VAR 0 1
90734: PPUSH
90735: CALL_OW 310
90739: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90740: LD_VAR 0 1
90744: PPUSH
90745: LD_STRING \
90747: PUSH
90748: LD_INT 0
90750: PUSH
90751: LD_INT 0
90753: PUSH
90754: LD_INT 0
90756: PUSH
90757: LD_INT 0
90759: PUSH
90760: LD_INT 0
90762: PUSH
90763: LD_INT 0
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: PUSH
90775: LD_STRING E
90777: PUSH
90778: LD_INT 0
90780: PUSH
90781: LD_INT 0
90783: PUSH
90784: LD_VAR 0 3
90788: PUSH
90789: LD_INT 0
90791: PUSH
90792: LD_INT 0
90794: PUSH
90795: LD_INT 0
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: PPUSH
90811: CALL_OW 447
// end ;
90815: LD_VAR 0 2
90819: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
90820: LD_INT 0
90822: PPUSH
90823: PPUSH
90824: PPUSH
// tmp := [ ] ;
90825: LD_ADDR_VAR 0 5
90829: PUSH
90830: EMPTY
90831: ST_TO_ADDR
// for i in units do
90832: LD_ADDR_VAR 0 4
90836: PUSH
90837: LD_VAR 0 1
90841: PUSH
90842: FOR_IN
90843: IFFALSE 90881
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
90845: LD_ADDR_VAR 0 5
90849: PUSH
90850: LD_VAR 0 5
90854: PPUSH
90855: LD_VAR 0 5
90859: PUSH
90860: LD_INT 1
90862: PLUS
90863: PPUSH
90864: LD_VAR 0 4
90868: PPUSH
90869: CALL_OW 256
90873: PPUSH
90874: CALL_OW 2
90878: ST_TO_ADDR
90879: GO 90842
90881: POP
90882: POP
// if not tmp then
90883: LD_VAR 0 5
90887: NOT
90888: IFFALSE 90892
// exit ;
90890: GO 90940
// if asc then
90892: LD_VAR 0 2
90896: IFFALSE 90920
// result := SortListByListAsc ( units , tmp ) else
90898: LD_ADDR_VAR 0 3
90902: PUSH
90903: LD_VAR 0 1
90907: PPUSH
90908: LD_VAR 0 5
90912: PPUSH
90913: CALL_OW 76
90917: ST_TO_ADDR
90918: GO 90940
// result := SortListByListDesc ( units , tmp ) ;
90920: LD_ADDR_VAR 0 3
90924: PUSH
90925: LD_VAR 0 1
90929: PPUSH
90930: LD_VAR 0 5
90934: PPUSH
90935: CALL_OW 77
90939: ST_TO_ADDR
// end ;
90940: LD_VAR 0 3
90944: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
90945: LD_INT 0
90947: PPUSH
90948: PPUSH
// task := GetTaskList ( mech ) ;
90949: LD_ADDR_VAR 0 4
90953: PUSH
90954: LD_VAR 0 1
90958: PPUSH
90959: CALL_OW 437
90963: ST_TO_ADDR
// if not task then
90964: LD_VAR 0 4
90968: NOT
90969: IFFALSE 90973
// exit ;
90971: GO 91015
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
90973: LD_ADDR_VAR 0 3
90977: PUSH
90978: LD_VAR 0 4
90982: PUSH
90983: LD_INT 1
90985: ARRAY
90986: PUSH
90987: LD_INT 1
90989: ARRAY
90990: PUSH
90991: LD_STRING r
90993: EQUAL
90994: PUSH
90995: LD_VAR 0 4
90999: PUSH
91000: LD_INT 1
91002: ARRAY
91003: PUSH
91004: LD_INT 4
91006: ARRAY
91007: PUSH
91008: LD_VAR 0 2
91012: EQUAL
91013: AND
91014: ST_TO_ADDR
// end ;
91015: LD_VAR 0 3
91019: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
91020: LD_INT 0
91022: PPUSH
// SetDir ( unit , d ) ;
91023: LD_VAR 0 1
91027: PPUSH
91028: LD_VAR 0 4
91032: PPUSH
91033: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
91037: LD_VAR 0 1
91041: PPUSH
91042: LD_VAR 0 2
91046: PPUSH
91047: LD_VAR 0 3
91051: PPUSH
91052: LD_VAR 0 5
91056: PPUSH
91057: CALL_OW 48
// end ;
91061: LD_VAR 0 6
91065: RET
// export function ToNaturalNumber ( number ) ; begin
91066: LD_INT 0
91068: PPUSH
// result := number div 1 ;
91069: LD_ADDR_VAR 0 2
91073: PUSH
91074: LD_VAR 0 1
91078: PUSH
91079: LD_INT 1
91081: DIV
91082: ST_TO_ADDR
// if number < 0 then
91083: LD_VAR 0 1
91087: PUSH
91088: LD_INT 0
91090: LESS
91091: IFFALSE 91101
// result := 0 ;
91093: LD_ADDR_VAR 0 2
91097: PUSH
91098: LD_INT 0
91100: ST_TO_ADDR
// end ;
91101: LD_VAR 0 2
91105: RET
// export function SortByClass ( units , class ) ; var un ; begin
91106: LD_INT 0
91108: PPUSH
91109: PPUSH
// if not units or not class then
91110: LD_VAR 0 1
91114: NOT
91115: PUSH
91116: LD_VAR 0 2
91120: NOT
91121: OR
91122: IFFALSE 91126
// exit ;
91124: GO 91221
// result := [ ] ;
91126: LD_ADDR_VAR 0 3
91130: PUSH
91131: EMPTY
91132: ST_TO_ADDR
// for un in units do
91133: LD_ADDR_VAR 0 4
91137: PUSH
91138: LD_VAR 0 1
91142: PUSH
91143: FOR_IN
91144: IFFALSE 91219
// if GetClass ( un ) = class then
91146: LD_VAR 0 4
91150: PPUSH
91151: CALL_OW 257
91155: PUSH
91156: LD_VAR 0 2
91160: EQUAL
91161: IFFALSE 91188
// result := Insert ( result , 1 , un ) else
91163: LD_ADDR_VAR 0 3
91167: PUSH
91168: LD_VAR 0 3
91172: PPUSH
91173: LD_INT 1
91175: PPUSH
91176: LD_VAR 0 4
91180: PPUSH
91181: CALL_OW 2
91185: ST_TO_ADDR
91186: GO 91217
// result := Replace ( result , result + 1 , un ) ;
91188: LD_ADDR_VAR 0 3
91192: PUSH
91193: LD_VAR 0 3
91197: PPUSH
91198: LD_VAR 0 3
91202: PUSH
91203: LD_INT 1
91205: PLUS
91206: PPUSH
91207: LD_VAR 0 4
91211: PPUSH
91212: CALL_OW 1
91216: ST_TO_ADDR
91217: GO 91143
91219: POP
91220: POP
// end ;
91221: LD_VAR 0 3
91225: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
91226: LD_INT 0
91228: PPUSH
91229: PPUSH
91230: PPUSH
91231: PPUSH
91232: PPUSH
91233: PPUSH
91234: PPUSH
// result := [ ] ;
91235: LD_ADDR_VAR 0 4
91239: PUSH
91240: EMPTY
91241: ST_TO_ADDR
// if x - r < 0 then
91242: LD_VAR 0 1
91246: PUSH
91247: LD_VAR 0 3
91251: MINUS
91252: PUSH
91253: LD_INT 0
91255: LESS
91256: IFFALSE 91268
// min_x := 0 else
91258: LD_ADDR_VAR 0 8
91262: PUSH
91263: LD_INT 0
91265: ST_TO_ADDR
91266: GO 91284
// min_x := x - r ;
91268: LD_ADDR_VAR 0 8
91272: PUSH
91273: LD_VAR 0 1
91277: PUSH
91278: LD_VAR 0 3
91282: MINUS
91283: ST_TO_ADDR
// if y - r < 0 then
91284: LD_VAR 0 2
91288: PUSH
91289: LD_VAR 0 3
91293: MINUS
91294: PUSH
91295: LD_INT 0
91297: LESS
91298: IFFALSE 91310
// min_y := 0 else
91300: LD_ADDR_VAR 0 7
91304: PUSH
91305: LD_INT 0
91307: ST_TO_ADDR
91308: GO 91326
// min_y := y - r ;
91310: LD_ADDR_VAR 0 7
91314: PUSH
91315: LD_VAR 0 2
91319: PUSH
91320: LD_VAR 0 3
91324: MINUS
91325: ST_TO_ADDR
// max_x := x + r ;
91326: LD_ADDR_VAR 0 9
91330: PUSH
91331: LD_VAR 0 1
91335: PUSH
91336: LD_VAR 0 3
91340: PLUS
91341: ST_TO_ADDR
// max_y := y + r ;
91342: LD_ADDR_VAR 0 10
91346: PUSH
91347: LD_VAR 0 2
91351: PUSH
91352: LD_VAR 0 3
91356: PLUS
91357: ST_TO_ADDR
// for _x = min_x to max_x do
91358: LD_ADDR_VAR 0 5
91362: PUSH
91363: DOUBLE
91364: LD_VAR 0 8
91368: DEC
91369: ST_TO_ADDR
91370: LD_VAR 0 9
91374: PUSH
91375: FOR_TO
91376: IFFALSE 91477
// for _y = min_y to max_y do
91378: LD_ADDR_VAR 0 6
91382: PUSH
91383: DOUBLE
91384: LD_VAR 0 7
91388: DEC
91389: ST_TO_ADDR
91390: LD_VAR 0 10
91394: PUSH
91395: FOR_TO
91396: IFFALSE 91473
// begin if not ValidHex ( _x , _y ) then
91398: LD_VAR 0 5
91402: PPUSH
91403: LD_VAR 0 6
91407: PPUSH
91408: CALL_OW 488
91412: NOT
91413: IFFALSE 91417
// continue ;
91415: GO 91395
// if GetResourceTypeXY ( _x , _y ) then
91417: LD_VAR 0 5
91421: PPUSH
91422: LD_VAR 0 6
91426: PPUSH
91427: CALL_OW 283
91431: IFFALSE 91471
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
91433: LD_ADDR_VAR 0 4
91437: PUSH
91438: LD_VAR 0 4
91442: PPUSH
91443: LD_VAR 0 4
91447: PUSH
91448: LD_INT 1
91450: PLUS
91451: PPUSH
91452: LD_VAR 0 5
91456: PUSH
91457: LD_VAR 0 6
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PPUSH
91466: CALL_OW 1
91470: ST_TO_ADDR
// end ;
91471: GO 91395
91473: POP
91474: POP
91475: GO 91375
91477: POP
91478: POP
// end ;
91479: LD_VAR 0 4
91483: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
91484: LD_INT 0
91486: PPUSH
91487: PPUSH
91488: PPUSH
91489: PPUSH
91490: PPUSH
91491: PPUSH
91492: PPUSH
91493: PPUSH
// if not units then
91494: LD_VAR 0 1
91498: NOT
91499: IFFALSE 91503
// exit ;
91501: GO 92029
// result := UnitFilter ( units , [ f_ok ] ) ;
91503: LD_ADDR_VAR 0 3
91507: PUSH
91508: LD_VAR 0 1
91512: PPUSH
91513: LD_INT 50
91515: PUSH
91516: EMPTY
91517: LIST
91518: PPUSH
91519: CALL_OW 72
91523: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
91524: LD_ADDR_VAR 0 8
91528: PUSH
91529: LD_VAR 0 1
91533: PUSH
91534: LD_INT 1
91536: ARRAY
91537: PPUSH
91538: CALL_OW 255
91542: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
91543: LD_ADDR_VAR 0 10
91547: PUSH
91548: LD_INT 29
91550: PUSH
91551: LD_EXP 78
91555: PUSH
91556: LD_INT 49
91558: PUSH
91559: EMPTY
91560: LIST
91561: LIST
91562: LIST
91563: ST_TO_ADDR
// if not result then
91564: LD_VAR 0 3
91568: NOT
91569: IFFALSE 91573
// exit ;
91571: GO 92029
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
91573: LD_ADDR_VAR 0 5
91577: PUSH
91578: LD_INT 81
91580: PUSH
91581: LD_VAR 0 8
91585: PUSH
91586: EMPTY
91587: LIST
91588: LIST
91589: PPUSH
91590: CALL_OW 69
91594: ST_TO_ADDR
// for i in result do
91595: LD_ADDR_VAR 0 4
91599: PUSH
91600: LD_VAR 0 3
91604: PUSH
91605: FOR_IN
91606: IFFALSE 92027
// begin tag := GetTag ( i ) + 1 ;
91608: LD_ADDR_VAR 0 9
91612: PUSH
91613: LD_VAR 0 4
91617: PPUSH
91618: CALL_OW 110
91622: PUSH
91623: LD_INT 1
91625: PLUS
91626: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
91627: LD_ADDR_VAR 0 7
91631: PUSH
91632: LD_VAR 0 4
91636: PPUSH
91637: CALL_OW 250
91641: PPUSH
91642: LD_VAR 0 4
91646: PPUSH
91647: CALL_OW 251
91651: PPUSH
91652: LD_INT 6
91654: PPUSH
91655: CALL 91226 0 3
91659: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
91660: LD_VAR 0 4
91664: PPUSH
91665: CALL_OW 247
91669: PUSH
91670: LD_INT 2
91672: EQUAL
91673: PUSH
91674: LD_VAR 0 7
91678: AND
91679: PUSH
91680: LD_VAR 0 4
91684: PPUSH
91685: CALL_OW 264
91689: PUSH
91690: LD_VAR 0 10
91694: IN
91695: NOT
91696: AND
91697: IFFALSE 91736
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
91699: LD_VAR 0 4
91703: PPUSH
91704: LD_VAR 0 7
91708: PUSH
91709: LD_INT 1
91711: ARRAY
91712: PUSH
91713: LD_INT 1
91715: ARRAY
91716: PPUSH
91717: LD_VAR 0 7
91721: PUSH
91722: LD_INT 1
91724: ARRAY
91725: PUSH
91726: LD_INT 2
91728: ARRAY
91729: PPUSH
91730: CALL_OW 116
91734: GO 92025
// if path > tag then
91736: LD_VAR 0 2
91740: PUSH
91741: LD_VAR 0 9
91745: GREATER
91746: IFFALSE 91954
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
91748: LD_ADDR_VAR 0 6
91752: PUSH
91753: LD_VAR 0 5
91757: PPUSH
91758: LD_INT 91
91760: PUSH
91761: LD_VAR 0 4
91765: PUSH
91766: LD_INT 8
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: LIST
91773: PPUSH
91774: CALL_OW 72
91778: ST_TO_ADDR
// if nearEnemy then
91779: LD_VAR 0 6
91783: IFFALSE 91852
// begin if GetWeapon ( i ) = ru_time_lapser then
91785: LD_VAR 0 4
91789: PPUSH
91790: CALL_OW 264
91794: PUSH
91795: LD_INT 49
91797: EQUAL
91798: IFFALSE 91826
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
91800: LD_VAR 0 4
91804: PPUSH
91805: LD_VAR 0 6
91809: PPUSH
91810: LD_VAR 0 4
91814: PPUSH
91815: CALL_OW 74
91819: PPUSH
91820: CALL_OW 112
91824: GO 91850
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
91826: LD_VAR 0 4
91830: PPUSH
91831: LD_VAR 0 6
91835: PPUSH
91836: LD_VAR 0 4
91840: PPUSH
91841: CALL_OW 74
91845: PPUSH
91846: CALL_OW 115
// end else
91850: GO 91952
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
91852: LD_VAR 0 4
91856: PPUSH
91857: LD_VAR 0 2
91861: PUSH
91862: LD_VAR 0 9
91866: ARRAY
91867: PUSH
91868: LD_INT 1
91870: ARRAY
91871: PPUSH
91872: LD_VAR 0 2
91876: PUSH
91877: LD_VAR 0 9
91881: ARRAY
91882: PUSH
91883: LD_INT 2
91885: ARRAY
91886: PPUSH
91887: CALL_OW 297
91891: PUSH
91892: LD_INT 6
91894: GREATER
91895: IFFALSE 91938
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
91897: LD_VAR 0 4
91901: PPUSH
91902: LD_VAR 0 2
91906: PUSH
91907: LD_VAR 0 9
91911: ARRAY
91912: PUSH
91913: LD_INT 1
91915: ARRAY
91916: PPUSH
91917: LD_VAR 0 2
91921: PUSH
91922: LD_VAR 0 9
91926: ARRAY
91927: PUSH
91928: LD_INT 2
91930: ARRAY
91931: PPUSH
91932: CALL_OW 114
91936: GO 91952
// SetTag ( i , tag ) ;
91938: LD_VAR 0 4
91942: PPUSH
91943: LD_VAR 0 9
91947: PPUSH
91948: CALL_OW 109
// end else
91952: GO 92025
// if enemy then
91954: LD_VAR 0 5
91958: IFFALSE 92025
// begin if GetWeapon ( i ) = ru_time_lapser then
91960: LD_VAR 0 4
91964: PPUSH
91965: CALL_OW 264
91969: PUSH
91970: LD_INT 49
91972: EQUAL
91973: IFFALSE 92001
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
91975: LD_VAR 0 4
91979: PPUSH
91980: LD_VAR 0 5
91984: PPUSH
91985: LD_VAR 0 4
91989: PPUSH
91990: CALL_OW 74
91994: PPUSH
91995: CALL_OW 112
91999: GO 92025
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
92001: LD_VAR 0 4
92005: PPUSH
92006: LD_VAR 0 5
92010: PPUSH
92011: LD_VAR 0 4
92015: PPUSH
92016: CALL_OW 74
92020: PPUSH
92021: CALL_OW 115
// end ; end ;
92025: GO 91605
92027: POP
92028: POP
// end ;
92029: LD_VAR 0 3
92033: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
92034: LD_INT 0
92036: PPUSH
92037: PPUSH
92038: PPUSH
// if not unit or IsInUnit ( unit ) then
92039: LD_VAR 0 1
92043: NOT
92044: PUSH
92045: LD_VAR 0 1
92049: PPUSH
92050: CALL_OW 310
92054: OR
92055: IFFALSE 92059
// exit ;
92057: GO 92150
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
92059: LD_ADDR_VAR 0 4
92063: PUSH
92064: LD_VAR 0 1
92068: PPUSH
92069: CALL_OW 250
92073: PPUSH
92074: LD_VAR 0 2
92078: PPUSH
92079: LD_INT 1
92081: PPUSH
92082: CALL_OW 272
92086: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
92087: LD_ADDR_VAR 0 5
92091: PUSH
92092: LD_VAR 0 1
92096: PPUSH
92097: CALL_OW 251
92101: PPUSH
92102: LD_VAR 0 2
92106: PPUSH
92107: LD_INT 1
92109: PPUSH
92110: CALL_OW 273
92114: ST_TO_ADDR
// if ValidHex ( x , y ) then
92115: LD_VAR 0 4
92119: PPUSH
92120: LD_VAR 0 5
92124: PPUSH
92125: CALL_OW 488
92129: IFFALSE 92150
// ComTurnXY ( unit , x , y ) ;
92131: LD_VAR 0 1
92135: PPUSH
92136: LD_VAR 0 4
92140: PPUSH
92141: LD_VAR 0 5
92145: PPUSH
92146: CALL_OW 118
// end ;
92150: LD_VAR 0 3
92154: RET
// export function SeeUnits ( side , units ) ; var i ; begin
92155: LD_INT 0
92157: PPUSH
92158: PPUSH
// result := false ;
92159: LD_ADDR_VAR 0 3
92163: PUSH
92164: LD_INT 0
92166: ST_TO_ADDR
// if not units then
92167: LD_VAR 0 2
92171: NOT
92172: IFFALSE 92176
// exit ;
92174: GO 92221
// for i in units do
92176: LD_ADDR_VAR 0 4
92180: PUSH
92181: LD_VAR 0 2
92185: PUSH
92186: FOR_IN
92187: IFFALSE 92219
// if See ( side , i ) then
92189: LD_VAR 0 1
92193: PPUSH
92194: LD_VAR 0 4
92198: PPUSH
92199: CALL_OW 292
92203: IFFALSE 92217
// begin result := true ;
92205: LD_ADDR_VAR 0 3
92209: PUSH
92210: LD_INT 1
92212: ST_TO_ADDR
// exit ;
92213: POP
92214: POP
92215: GO 92221
// end ;
92217: GO 92186
92219: POP
92220: POP
// end ;
92221: LD_VAR 0 3
92225: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
92226: LD_INT 0
92228: PPUSH
92229: PPUSH
92230: PPUSH
92231: PPUSH
// if not unit or not points then
92232: LD_VAR 0 1
92236: NOT
92237: PUSH
92238: LD_VAR 0 2
92242: NOT
92243: OR
92244: IFFALSE 92248
// exit ;
92246: GO 92338
// dist := 99999 ;
92248: LD_ADDR_VAR 0 5
92252: PUSH
92253: LD_INT 99999
92255: ST_TO_ADDR
// for i in points do
92256: LD_ADDR_VAR 0 4
92260: PUSH
92261: LD_VAR 0 2
92265: PUSH
92266: FOR_IN
92267: IFFALSE 92336
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
92269: LD_ADDR_VAR 0 6
92273: PUSH
92274: LD_VAR 0 1
92278: PPUSH
92279: LD_VAR 0 4
92283: PUSH
92284: LD_INT 1
92286: ARRAY
92287: PPUSH
92288: LD_VAR 0 4
92292: PUSH
92293: LD_INT 2
92295: ARRAY
92296: PPUSH
92297: CALL_OW 297
92301: ST_TO_ADDR
// if tmpDist < dist then
92302: LD_VAR 0 6
92306: PUSH
92307: LD_VAR 0 5
92311: LESS
92312: IFFALSE 92334
// begin result := i ;
92314: LD_ADDR_VAR 0 3
92318: PUSH
92319: LD_VAR 0 4
92323: ST_TO_ADDR
// dist := tmpDist ;
92324: LD_ADDR_VAR 0 5
92328: PUSH
92329: LD_VAR 0 6
92333: ST_TO_ADDR
// end ; end ;
92334: GO 92266
92336: POP
92337: POP
// end ;
92338: LD_VAR 0 3
92342: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
92343: LD_INT 0
92345: PPUSH
// uc_side := side ;
92346: LD_ADDR_OWVAR 20
92350: PUSH
92351: LD_VAR 0 1
92355: ST_TO_ADDR
// uc_nation := 3 ;
92356: LD_ADDR_OWVAR 21
92360: PUSH
92361: LD_INT 3
92363: ST_TO_ADDR
// vc_chassis := 25 ;
92364: LD_ADDR_OWVAR 37
92368: PUSH
92369: LD_INT 25
92371: ST_TO_ADDR
// vc_engine := engine_siberite ;
92372: LD_ADDR_OWVAR 39
92376: PUSH
92377: LD_INT 3
92379: ST_TO_ADDR
// vc_control := control_computer ;
92380: LD_ADDR_OWVAR 38
92384: PUSH
92385: LD_INT 3
92387: ST_TO_ADDR
// vc_weapon := 59 ;
92388: LD_ADDR_OWVAR 40
92392: PUSH
92393: LD_INT 59
92395: ST_TO_ADDR
// result := CreateVehicle ;
92396: LD_ADDR_VAR 0 5
92400: PUSH
92401: CALL_OW 45
92405: ST_TO_ADDR
// SetDir ( result , d ) ;
92406: LD_VAR 0 5
92410: PPUSH
92411: LD_VAR 0 4
92415: PPUSH
92416: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
92420: LD_VAR 0 5
92424: PPUSH
92425: LD_VAR 0 2
92429: PPUSH
92430: LD_VAR 0 3
92434: PPUSH
92435: LD_INT 0
92437: PPUSH
92438: CALL_OW 48
// end ;
92442: LD_VAR 0 5
92446: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
92447: LD_INT 0
92449: PPUSH
92450: PPUSH
92451: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
92452: LD_ADDR_VAR 0 2
92456: PUSH
92457: LD_INT 0
92459: PUSH
92460: LD_INT 0
92462: PUSH
92463: LD_INT 0
92465: PUSH
92466: LD_INT 0
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: LIST
92473: LIST
92474: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
92475: LD_VAR 0 1
92479: NOT
92480: PUSH
92481: LD_VAR 0 1
92485: PPUSH
92486: CALL_OW 264
92490: PUSH
92491: LD_INT 12
92493: PUSH
92494: LD_INT 51
92496: PUSH
92497: LD_INT 32
92499: PUSH
92500: LD_EXP 75
92504: PUSH
92505: EMPTY
92506: LIST
92507: LIST
92508: LIST
92509: LIST
92510: IN
92511: NOT
92512: OR
92513: IFFALSE 92517
// exit ;
92515: GO 92615
// for i := 1 to 3 do
92517: LD_ADDR_VAR 0 3
92521: PUSH
92522: DOUBLE
92523: LD_INT 1
92525: DEC
92526: ST_TO_ADDR
92527: LD_INT 3
92529: PUSH
92530: FOR_TO
92531: IFFALSE 92613
// begin tmp := GetCargo ( cargo , i ) ;
92533: LD_ADDR_VAR 0 4
92537: PUSH
92538: LD_VAR 0 1
92542: PPUSH
92543: LD_VAR 0 3
92547: PPUSH
92548: CALL_OW 289
92552: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
92553: LD_ADDR_VAR 0 2
92557: PUSH
92558: LD_VAR 0 2
92562: PPUSH
92563: LD_VAR 0 3
92567: PPUSH
92568: LD_VAR 0 4
92572: PPUSH
92573: CALL_OW 1
92577: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
92578: LD_ADDR_VAR 0 2
92582: PUSH
92583: LD_VAR 0 2
92587: PPUSH
92588: LD_INT 4
92590: PPUSH
92591: LD_VAR 0 2
92595: PUSH
92596: LD_INT 4
92598: ARRAY
92599: PUSH
92600: LD_VAR 0 4
92604: PLUS
92605: PPUSH
92606: CALL_OW 1
92610: ST_TO_ADDR
// end ;
92611: GO 92530
92613: POP
92614: POP
// end ;
92615: LD_VAR 0 2
92619: RET
// export function Length ( array ) ; begin
92620: LD_INT 0
92622: PPUSH
// result := array + 0 ;
92623: LD_ADDR_VAR 0 2
92627: PUSH
92628: LD_VAR 0 1
92632: PUSH
92633: LD_INT 0
92635: PLUS
92636: ST_TO_ADDR
// end ; end_of_file end_of_file
92637: LD_VAR 0 2
92641: RET
// every 0 0$1 do
92642: GO 92644
92644: DISABLE
// begin enable ;
92645: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
92646: LD_STRING updateTimer(
92648: PUSH
92649: LD_OWVAR 1
92653: STR
92654: PUSH
92655: LD_STRING );
92657: STR
92658: PPUSH
92659: CALL_OW 559
// end ;
92663: END
// export function SOS_MapStart ( ) ; begin
92664: LD_INT 0
92666: PPUSH
// if streamModeActive then
92667: LD_EXP 140
92671: IFFALSE 92680
// DefineStreamItems ( true ) ;
92673: LD_INT 1
92675: PPUSH
92676: CALL 94330 0 1
// UpdateFactoryWaypoints ( ) ;
92680: CALL 107914 0 0
// end ;
92684: LD_VAR 0 1
92688: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92689: LD_INT 0
92691: PPUSH
// if p2 = 100 then
92692: LD_VAR 0 2
92696: PUSH
92697: LD_INT 100
92699: EQUAL
92700: IFFALSE 93703
// begin if not StreamModeActive then
92702: LD_EXP 140
92706: NOT
92707: IFFALSE 92717
// StreamModeActive := true ;
92709: LD_ADDR_EXP 140
92713: PUSH
92714: LD_INT 1
92716: ST_TO_ADDR
// if p3 = 0 then
92717: LD_VAR 0 3
92721: PUSH
92722: LD_INT 0
92724: EQUAL
92725: IFFALSE 92731
// InitStreamMode ;
92727: CALL 93866 0 0
// if p3 = 1 then
92731: LD_VAR 0 3
92735: PUSH
92736: LD_INT 1
92738: EQUAL
92739: IFFALSE 92749
// sRocket := true ;
92741: LD_ADDR_EXP 145
92745: PUSH
92746: LD_INT 1
92748: ST_TO_ADDR
// if p3 = 2 then
92749: LD_VAR 0 3
92753: PUSH
92754: LD_INT 2
92756: EQUAL
92757: IFFALSE 92767
// sSpeed := true ;
92759: LD_ADDR_EXP 144
92763: PUSH
92764: LD_INT 1
92766: ST_TO_ADDR
// if p3 = 3 then
92767: LD_VAR 0 3
92771: PUSH
92772: LD_INT 3
92774: EQUAL
92775: IFFALSE 92785
// sEngine := true ;
92777: LD_ADDR_EXP 146
92781: PUSH
92782: LD_INT 1
92784: ST_TO_ADDR
// if p3 = 4 then
92785: LD_VAR 0 3
92789: PUSH
92790: LD_INT 4
92792: EQUAL
92793: IFFALSE 92803
// sSpec := true ;
92795: LD_ADDR_EXP 143
92799: PUSH
92800: LD_INT 1
92802: ST_TO_ADDR
// if p3 = 5 then
92803: LD_VAR 0 3
92807: PUSH
92808: LD_INT 5
92810: EQUAL
92811: IFFALSE 92821
// sLevel := true ;
92813: LD_ADDR_EXP 147
92817: PUSH
92818: LD_INT 1
92820: ST_TO_ADDR
// if p3 = 6 then
92821: LD_VAR 0 3
92825: PUSH
92826: LD_INT 6
92828: EQUAL
92829: IFFALSE 92839
// sArmoury := true ;
92831: LD_ADDR_EXP 148
92835: PUSH
92836: LD_INT 1
92838: ST_TO_ADDR
// if p3 = 7 then
92839: LD_VAR 0 3
92843: PUSH
92844: LD_INT 7
92846: EQUAL
92847: IFFALSE 92857
// sRadar := true ;
92849: LD_ADDR_EXP 149
92853: PUSH
92854: LD_INT 1
92856: ST_TO_ADDR
// if p3 = 8 then
92857: LD_VAR 0 3
92861: PUSH
92862: LD_INT 8
92864: EQUAL
92865: IFFALSE 92875
// sBunker := true ;
92867: LD_ADDR_EXP 150
92871: PUSH
92872: LD_INT 1
92874: ST_TO_ADDR
// if p3 = 9 then
92875: LD_VAR 0 3
92879: PUSH
92880: LD_INT 9
92882: EQUAL
92883: IFFALSE 92893
// sHack := true ;
92885: LD_ADDR_EXP 151
92889: PUSH
92890: LD_INT 1
92892: ST_TO_ADDR
// if p3 = 10 then
92893: LD_VAR 0 3
92897: PUSH
92898: LD_INT 10
92900: EQUAL
92901: IFFALSE 92911
// sFire := true ;
92903: LD_ADDR_EXP 152
92907: PUSH
92908: LD_INT 1
92910: ST_TO_ADDR
// if p3 = 11 then
92911: LD_VAR 0 3
92915: PUSH
92916: LD_INT 11
92918: EQUAL
92919: IFFALSE 92929
// sRefresh := true ;
92921: LD_ADDR_EXP 153
92925: PUSH
92926: LD_INT 1
92928: ST_TO_ADDR
// if p3 = 12 then
92929: LD_VAR 0 3
92933: PUSH
92934: LD_INT 12
92936: EQUAL
92937: IFFALSE 92947
// sExp := true ;
92939: LD_ADDR_EXP 154
92943: PUSH
92944: LD_INT 1
92946: ST_TO_ADDR
// if p3 = 13 then
92947: LD_VAR 0 3
92951: PUSH
92952: LD_INT 13
92954: EQUAL
92955: IFFALSE 92965
// sDepot := true ;
92957: LD_ADDR_EXP 155
92961: PUSH
92962: LD_INT 1
92964: ST_TO_ADDR
// if p3 = 14 then
92965: LD_VAR 0 3
92969: PUSH
92970: LD_INT 14
92972: EQUAL
92973: IFFALSE 92983
// sFlag := true ;
92975: LD_ADDR_EXP 156
92979: PUSH
92980: LD_INT 1
92982: ST_TO_ADDR
// if p3 = 15 then
92983: LD_VAR 0 3
92987: PUSH
92988: LD_INT 15
92990: EQUAL
92991: IFFALSE 93001
// sKamikadze := true ;
92993: LD_ADDR_EXP 164
92997: PUSH
92998: LD_INT 1
93000: ST_TO_ADDR
// if p3 = 16 then
93001: LD_VAR 0 3
93005: PUSH
93006: LD_INT 16
93008: EQUAL
93009: IFFALSE 93019
// sTroll := true ;
93011: LD_ADDR_EXP 165
93015: PUSH
93016: LD_INT 1
93018: ST_TO_ADDR
// if p3 = 17 then
93019: LD_VAR 0 3
93023: PUSH
93024: LD_INT 17
93026: EQUAL
93027: IFFALSE 93037
// sSlow := true ;
93029: LD_ADDR_EXP 166
93033: PUSH
93034: LD_INT 1
93036: ST_TO_ADDR
// if p3 = 18 then
93037: LD_VAR 0 3
93041: PUSH
93042: LD_INT 18
93044: EQUAL
93045: IFFALSE 93055
// sLack := true ;
93047: LD_ADDR_EXP 167
93051: PUSH
93052: LD_INT 1
93054: ST_TO_ADDR
// if p3 = 19 then
93055: LD_VAR 0 3
93059: PUSH
93060: LD_INT 19
93062: EQUAL
93063: IFFALSE 93073
// sTank := true ;
93065: LD_ADDR_EXP 169
93069: PUSH
93070: LD_INT 1
93072: ST_TO_ADDR
// if p3 = 20 then
93073: LD_VAR 0 3
93077: PUSH
93078: LD_INT 20
93080: EQUAL
93081: IFFALSE 93091
// sRemote := true ;
93083: LD_ADDR_EXP 170
93087: PUSH
93088: LD_INT 1
93090: ST_TO_ADDR
// if p3 = 21 then
93091: LD_VAR 0 3
93095: PUSH
93096: LD_INT 21
93098: EQUAL
93099: IFFALSE 93109
// sPowell := true ;
93101: LD_ADDR_EXP 171
93105: PUSH
93106: LD_INT 1
93108: ST_TO_ADDR
// if p3 = 22 then
93109: LD_VAR 0 3
93113: PUSH
93114: LD_INT 22
93116: EQUAL
93117: IFFALSE 93127
// sTeleport := true ;
93119: LD_ADDR_EXP 174
93123: PUSH
93124: LD_INT 1
93126: ST_TO_ADDR
// if p3 = 23 then
93127: LD_VAR 0 3
93131: PUSH
93132: LD_INT 23
93134: EQUAL
93135: IFFALSE 93145
// sOilTower := true ;
93137: LD_ADDR_EXP 176
93141: PUSH
93142: LD_INT 1
93144: ST_TO_ADDR
// if p3 = 24 then
93145: LD_VAR 0 3
93149: PUSH
93150: LD_INT 24
93152: EQUAL
93153: IFFALSE 93163
// sShovel := true ;
93155: LD_ADDR_EXP 177
93159: PUSH
93160: LD_INT 1
93162: ST_TO_ADDR
// if p3 = 25 then
93163: LD_VAR 0 3
93167: PUSH
93168: LD_INT 25
93170: EQUAL
93171: IFFALSE 93181
// sSheik := true ;
93173: LD_ADDR_EXP 178
93177: PUSH
93178: LD_INT 1
93180: ST_TO_ADDR
// if p3 = 26 then
93181: LD_VAR 0 3
93185: PUSH
93186: LD_INT 26
93188: EQUAL
93189: IFFALSE 93199
// sEarthquake := true ;
93191: LD_ADDR_EXP 180
93195: PUSH
93196: LD_INT 1
93198: ST_TO_ADDR
// if p3 = 27 then
93199: LD_VAR 0 3
93203: PUSH
93204: LD_INT 27
93206: EQUAL
93207: IFFALSE 93217
// sAI := true ;
93209: LD_ADDR_EXP 181
93213: PUSH
93214: LD_INT 1
93216: ST_TO_ADDR
// if p3 = 28 then
93217: LD_VAR 0 3
93221: PUSH
93222: LD_INT 28
93224: EQUAL
93225: IFFALSE 93235
// sCargo := true ;
93227: LD_ADDR_EXP 184
93231: PUSH
93232: LD_INT 1
93234: ST_TO_ADDR
// if p3 = 29 then
93235: LD_VAR 0 3
93239: PUSH
93240: LD_INT 29
93242: EQUAL
93243: IFFALSE 93253
// sDLaser := true ;
93245: LD_ADDR_EXP 185
93249: PUSH
93250: LD_INT 1
93252: ST_TO_ADDR
// if p3 = 30 then
93253: LD_VAR 0 3
93257: PUSH
93258: LD_INT 30
93260: EQUAL
93261: IFFALSE 93271
// sExchange := true ;
93263: LD_ADDR_EXP 186
93267: PUSH
93268: LD_INT 1
93270: ST_TO_ADDR
// if p3 = 31 then
93271: LD_VAR 0 3
93275: PUSH
93276: LD_INT 31
93278: EQUAL
93279: IFFALSE 93289
// sFac := true ;
93281: LD_ADDR_EXP 187
93285: PUSH
93286: LD_INT 1
93288: ST_TO_ADDR
// if p3 = 32 then
93289: LD_VAR 0 3
93293: PUSH
93294: LD_INT 32
93296: EQUAL
93297: IFFALSE 93307
// sPower := true ;
93299: LD_ADDR_EXP 188
93303: PUSH
93304: LD_INT 1
93306: ST_TO_ADDR
// if p3 = 33 then
93307: LD_VAR 0 3
93311: PUSH
93312: LD_INT 33
93314: EQUAL
93315: IFFALSE 93325
// sRandom := true ;
93317: LD_ADDR_EXP 189
93321: PUSH
93322: LD_INT 1
93324: ST_TO_ADDR
// if p3 = 34 then
93325: LD_VAR 0 3
93329: PUSH
93330: LD_INT 34
93332: EQUAL
93333: IFFALSE 93343
// sShield := true ;
93335: LD_ADDR_EXP 190
93339: PUSH
93340: LD_INT 1
93342: ST_TO_ADDR
// if p3 = 35 then
93343: LD_VAR 0 3
93347: PUSH
93348: LD_INT 35
93350: EQUAL
93351: IFFALSE 93361
// sTime := true ;
93353: LD_ADDR_EXP 191
93357: PUSH
93358: LD_INT 1
93360: ST_TO_ADDR
// if p3 = 36 then
93361: LD_VAR 0 3
93365: PUSH
93366: LD_INT 36
93368: EQUAL
93369: IFFALSE 93379
// sTools := true ;
93371: LD_ADDR_EXP 192
93375: PUSH
93376: LD_INT 1
93378: ST_TO_ADDR
// if p3 = 101 then
93379: LD_VAR 0 3
93383: PUSH
93384: LD_INT 101
93386: EQUAL
93387: IFFALSE 93397
// sSold := true ;
93389: LD_ADDR_EXP 157
93393: PUSH
93394: LD_INT 1
93396: ST_TO_ADDR
// if p3 = 102 then
93397: LD_VAR 0 3
93401: PUSH
93402: LD_INT 102
93404: EQUAL
93405: IFFALSE 93415
// sDiff := true ;
93407: LD_ADDR_EXP 158
93411: PUSH
93412: LD_INT 1
93414: ST_TO_ADDR
// if p3 = 103 then
93415: LD_VAR 0 3
93419: PUSH
93420: LD_INT 103
93422: EQUAL
93423: IFFALSE 93433
// sFog := true ;
93425: LD_ADDR_EXP 161
93429: PUSH
93430: LD_INT 1
93432: ST_TO_ADDR
// if p3 = 104 then
93433: LD_VAR 0 3
93437: PUSH
93438: LD_INT 104
93440: EQUAL
93441: IFFALSE 93451
// sReset := true ;
93443: LD_ADDR_EXP 162
93447: PUSH
93448: LD_INT 1
93450: ST_TO_ADDR
// if p3 = 105 then
93451: LD_VAR 0 3
93455: PUSH
93456: LD_INT 105
93458: EQUAL
93459: IFFALSE 93469
// sSun := true ;
93461: LD_ADDR_EXP 163
93465: PUSH
93466: LD_INT 1
93468: ST_TO_ADDR
// if p3 = 106 then
93469: LD_VAR 0 3
93473: PUSH
93474: LD_INT 106
93476: EQUAL
93477: IFFALSE 93487
// sTiger := true ;
93479: LD_ADDR_EXP 159
93483: PUSH
93484: LD_INT 1
93486: ST_TO_ADDR
// if p3 = 107 then
93487: LD_VAR 0 3
93491: PUSH
93492: LD_INT 107
93494: EQUAL
93495: IFFALSE 93505
// sBomb := true ;
93497: LD_ADDR_EXP 160
93501: PUSH
93502: LD_INT 1
93504: ST_TO_ADDR
// if p3 = 108 then
93505: LD_VAR 0 3
93509: PUSH
93510: LD_INT 108
93512: EQUAL
93513: IFFALSE 93523
// sWound := true ;
93515: LD_ADDR_EXP 168
93519: PUSH
93520: LD_INT 1
93522: ST_TO_ADDR
// if p3 = 109 then
93523: LD_VAR 0 3
93527: PUSH
93528: LD_INT 109
93530: EQUAL
93531: IFFALSE 93541
// sBetray := true ;
93533: LD_ADDR_EXP 172
93537: PUSH
93538: LD_INT 1
93540: ST_TO_ADDR
// if p3 = 110 then
93541: LD_VAR 0 3
93545: PUSH
93546: LD_INT 110
93548: EQUAL
93549: IFFALSE 93559
// sContamin := true ;
93551: LD_ADDR_EXP 173
93555: PUSH
93556: LD_INT 1
93558: ST_TO_ADDR
// if p3 = 111 then
93559: LD_VAR 0 3
93563: PUSH
93564: LD_INT 111
93566: EQUAL
93567: IFFALSE 93577
// sOil := true ;
93569: LD_ADDR_EXP 175
93573: PUSH
93574: LD_INT 1
93576: ST_TO_ADDR
// if p3 = 112 then
93577: LD_VAR 0 3
93581: PUSH
93582: LD_INT 112
93584: EQUAL
93585: IFFALSE 93595
// sStu := true ;
93587: LD_ADDR_EXP 179
93591: PUSH
93592: LD_INT 1
93594: ST_TO_ADDR
// if p3 = 113 then
93595: LD_VAR 0 3
93599: PUSH
93600: LD_INT 113
93602: EQUAL
93603: IFFALSE 93613
// sBazooka := true ;
93605: LD_ADDR_EXP 182
93609: PUSH
93610: LD_INT 1
93612: ST_TO_ADDR
// if p3 = 114 then
93613: LD_VAR 0 3
93617: PUSH
93618: LD_INT 114
93620: EQUAL
93621: IFFALSE 93631
// sMortar := true ;
93623: LD_ADDR_EXP 183
93627: PUSH
93628: LD_INT 1
93630: ST_TO_ADDR
// if p3 = 115 then
93631: LD_VAR 0 3
93635: PUSH
93636: LD_INT 115
93638: EQUAL
93639: IFFALSE 93649
// sRanger := true ;
93641: LD_ADDR_EXP 193
93645: PUSH
93646: LD_INT 1
93648: ST_TO_ADDR
// if p3 = 116 then
93649: LD_VAR 0 3
93653: PUSH
93654: LD_INT 116
93656: EQUAL
93657: IFFALSE 93667
// sComputer := true ;
93659: LD_ADDR_EXP 194
93663: PUSH
93664: LD_INT 1
93666: ST_TO_ADDR
// if p3 = 117 then
93667: LD_VAR 0 3
93671: PUSH
93672: LD_INT 117
93674: EQUAL
93675: IFFALSE 93685
// s30 := true ;
93677: LD_ADDR_EXP 195
93681: PUSH
93682: LD_INT 1
93684: ST_TO_ADDR
// if p3 = 118 then
93685: LD_VAR 0 3
93689: PUSH
93690: LD_INT 118
93692: EQUAL
93693: IFFALSE 93703
// s60 := true ;
93695: LD_ADDR_EXP 196
93699: PUSH
93700: LD_INT 1
93702: ST_TO_ADDR
// end ; if p2 = 101 then
93703: LD_VAR 0 2
93707: PUSH
93708: LD_INT 101
93710: EQUAL
93711: IFFALSE 93839
// begin case p3 of 1 :
93713: LD_VAR 0 3
93717: PUSH
93718: LD_INT 1
93720: DOUBLE
93721: EQUAL
93722: IFTRUE 93726
93724: GO 93733
93726: POP
// hHackUnlimitedResources ; 2 :
93727: CALL 105937 0 0
93731: GO 93839
93733: LD_INT 2
93735: DOUBLE
93736: EQUAL
93737: IFTRUE 93741
93739: GO 93748
93741: POP
// hHackSetLevel10 ; 3 :
93742: CALL 106070 0 0
93746: GO 93839
93748: LD_INT 3
93750: DOUBLE
93751: EQUAL
93752: IFTRUE 93756
93754: GO 93763
93756: POP
// hHackSetLevel10YourUnits ; 4 :
93757: CALL 106155 0 0
93761: GO 93839
93763: LD_INT 4
93765: DOUBLE
93766: EQUAL
93767: IFTRUE 93771
93769: GO 93778
93771: POP
// hHackInvincible ; 5 :
93772: CALL 106603 0 0
93776: GO 93839
93778: LD_INT 5
93780: DOUBLE
93781: EQUAL
93782: IFTRUE 93786
93784: GO 93793
93786: POP
// hHackInvisible ; 6 :
93787: CALL 106714 0 0
93791: GO 93839
93793: LD_INT 6
93795: DOUBLE
93796: EQUAL
93797: IFTRUE 93801
93799: GO 93808
93801: POP
// hHackChangeYourSide ; 7 :
93802: CALL 106771 0 0
93806: GO 93839
93808: LD_INT 7
93810: DOUBLE
93811: EQUAL
93812: IFTRUE 93816
93814: GO 93823
93816: POP
// hHackChangeUnitSide ; 8 :
93817: CALL 106813 0 0
93821: GO 93839
93823: LD_INT 8
93825: DOUBLE
93826: EQUAL
93827: IFTRUE 93831
93829: GO 93838
93831: POP
// hHackFog ; end ;
93832: CALL 106914 0 0
93836: GO 93839
93838: POP
// end ; end ;
93839: LD_VAR 0 7
93843: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
93844: GO 93846
93846: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93847: LD_STRING initStreamRollete();
93849: PPUSH
93850: CALL_OW 559
// InitStreamMode ;
93854: CALL 93866 0 0
// DefineStreamItems ( false ) ;
93858: LD_INT 0
93860: PPUSH
93861: CALL 94330 0 1
// end ;
93865: END
// function InitStreamMode ; begin
93866: LD_INT 0
93868: PPUSH
// streamModeActive := false ;
93869: LD_ADDR_EXP 140
93873: PUSH
93874: LD_INT 0
93876: ST_TO_ADDR
// normalCounter := 36 ;
93877: LD_ADDR_EXP 141
93881: PUSH
93882: LD_INT 36
93884: ST_TO_ADDR
// hardcoreCounter := 18 ;
93885: LD_ADDR_EXP 142
93889: PUSH
93890: LD_INT 18
93892: ST_TO_ADDR
// sRocket := false ;
93893: LD_ADDR_EXP 145
93897: PUSH
93898: LD_INT 0
93900: ST_TO_ADDR
// sSpeed := false ;
93901: LD_ADDR_EXP 144
93905: PUSH
93906: LD_INT 0
93908: ST_TO_ADDR
// sEngine := false ;
93909: LD_ADDR_EXP 146
93913: PUSH
93914: LD_INT 0
93916: ST_TO_ADDR
// sSpec := false ;
93917: LD_ADDR_EXP 143
93921: PUSH
93922: LD_INT 0
93924: ST_TO_ADDR
// sLevel := false ;
93925: LD_ADDR_EXP 147
93929: PUSH
93930: LD_INT 0
93932: ST_TO_ADDR
// sArmoury := false ;
93933: LD_ADDR_EXP 148
93937: PUSH
93938: LD_INT 0
93940: ST_TO_ADDR
// sRadar := false ;
93941: LD_ADDR_EXP 149
93945: PUSH
93946: LD_INT 0
93948: ST_TO_ADDR
// sBunker := false ;
93949: LD_ADDR_EXP 150
93953: PUSH
93954: LD_INT 0
93956: ST_TO_ADDR
// sHack := false ;
93957: LD_ADDR_EXP 151
93961: PUSH
93962: LD_INT 0
93964: ST_TO_ADDR
// sFire := false ;
93965: LD_ADDR_EXP 152
93969: PUSH
93970: LD_INT 0
93972: ST_TO_ADDR
// sRefresh := false ;
93973: LD_ADDR_EXP 153
93977: PUSH
93978: LD_INT 0
93980: ST_TO_ADDR
// sExp := false ;
93981: LD_ADDR_EXP 154
93985: PUSH
93986: LD_INT 0
93988: ST_TO_ADDR
// sDepot := false ;
93989: LD_ADDR_EXP 155
93993: PUSH
93994: LD_INT 0
93996: ST_TO_ADDR
// sFlag := false ;
93997: LD_ADDR_EXP 156
94001: PUSH
94002: LD_INT 0
94004: ST_TO_ADDR
// sKamikadze := false ;
94005: LD_ADDR_EXP 164
94009: PUSH
94010: LD_INT 0
94012: ST_TO_ADDR
// sTroll := false ;
94013: LD_ADDR_EXP 165
94017: PUSH
94018: LD_INT 0
94020: ST_TO_ADDR
// sSlow := false ;
94021: LD_ADDR_EXP 166
94025: PUSH
94026: LD_INT 0
94028: ST_TO_ADDR
// sLack := false ;
94029: LD_ADDR_EXP 167
94033: PUSH
94034: LD_INT 0
94036: ST_TO_ADDR
// sTank := false ;
94037: LD_ADDR_EXP 169
94041: PUSH
94042: LD_INT 0
94044: ST_TO_ADDR
// sRemote := false ;
94045: LD_ADDR_EXP 170
94049: PUSH
94050: LD_INT 0
94052: ST_TO_ADDR
// sPowell := false ;
94053: LD_ADDR_EXP 171
94057: PUSH
94058: LD_INT 0
94060: ST_TO_ADDR
// sTeleport := false ;
94061: LD_ADDR_EXP 174
94065: PUSH
94066: LD_INT 0
94068: ST_TO_ADDR
// sOilTower := false ;
94069: LD_ADDR_EXP 176
94073: PUSH
94074: LD_INT 0
94076: ST_TO_ADDR
// sShovel := false ;
94077: LD_ADDR_EXP 177
94081: PUSH
94082: LD_INT 0
94084: ST_TO_ADDR
// sSheik := false ;
94085: LD_ADDR_EXP 178
94089: PUSH
94090: LD_INT 0
94092: ST_TO_ADDR
// sEarthquake := false ;
94093: LD_ADDR_EXP 180
94097: PUSH
94098: LD_INT 0
94100: ST_TO_ADDR
// sAI := false ;
94101: LD_ADDR_EXP 181
94105: PUSH
94106: LD_INT 0
94108: ST_TO_ADDR
// sCargo := false ;
94109: LD_ADDR_EXP 184
94113: PUSH
94114: LD_INT 0
94116: ST_TO_ADDR
// sDLaser := false ;
94117: LD_ADDR_EXP 185
94121: PUSH
94122: LD_INT 0
94124: ST_TO_ADDR
// sExchange := false ;
94125: LD_ADDR_EXP 186
94129: PUSH
94130: LD_INT 0
94132: ST_TO_ADDR
// sFac := false ;
94133: LD_ADDR_EXP 187
94137: PUSH
94138: LD_INT 0
94140: ST_TO_ADDR
// sPower := false ;
94141: LD_ADDR_EXP 188
94145: PUSH
94146: LD_INT 0
94148: ST_TO_ADDR
// sRandom := false ;
94149: LD_ADDR_EXP 189
94153: PUSH
94154: LD_INT 0
94156: ST_TO_ADDR
// sShield := false ;
94157: LD_ADDR_EXP 190
94161: PUSH
94162: LD_INT 0
94164: ST_TO_ADDR
// sTime := false ;
94165: LD_ADDR_EXP 191
94169: PUSH
94170: LD_INT 0
94172: ST_TO_ADDR
// sTools := false ;
94173: LD_ADDR_EXP 192
94177: PUSH
94178: LD_INT 0
94180: ST_TO_ADDR
// sSold := false ;
94181: LD_ADDR_EXP 157
94185: PUSH
94186: LD_INT 0
94188: ST_TO_ADDR
// sDiff := false ;
94189: LD_ADDR_EXP 158
94193: PUSH
94194: LD_INT 0
94196: ST_TO_ADDR
// sFog := false ;
94197: LD_ADDR_EXP 161
94201: PUSH
94202: LD_INT 0
94204: ST_TO_ADDR
// sReset := false ;
94205: LD_ADDR_EXP 162
94209: PUSH
94210: LD_INT 0
94212: ST_TO_ADDR
// sSun := false ;
94213: LD_ADDR_EXP 163
94217: PUSH
94218: LD_INT 0
94220: ST_TO_ADDR
// sTiger := false ;
94221: LD_ADDR_EXP 159
94225: PUSH
94226: LD_INT 0
94228: ST_TO_ADDR
// sBomb := false ;
94229: LD_ADDR_EXP 160
94233: PUSH
94234: LD_INT 0
94236: ST_TO_ADDR
// sWound := false ;
94237: LD_ADDR_EXP 168
94241: PUSH
94242: LD_INT 0
94244: ST_TO_ADDR
// sBetray := false ;
94245: LD_ADDR_EXP 172
94249: PUSH
94250: LD_INT 0
94252: ST_TO_ADDR
// sContamin := false ;
94253: LD_ADDR_EXP 173
94257: PUSH
94258: LD_INT 0
94260: ST_TO_ADDR
// sOil := false ;
94261: LD_ADDR_EXP 175
94265: PUSH
94266: LD_INT 0
94268: ST_TO_ADDR
// sStu := false ;
94269: LD_ADDR_EXP 179
94273: PUSH
94274: LD_INT 0
94276: ST_TO_ADDR
// sBazooka := false ;
94277: LD_ADDR_EXP 182
94281: PUSH
94282: LD_INT 0
94284: ST_TO_ADDR
// sMortar := false ;
94285: LD_ADDR_EXP 183
94289: PUSH
94290: LD_INT 0
94292: ST_TO_ADDR
// sRanger := false ;
94293: LD_ADDR_EXP 193
94297: PUSH
94298: LD_INT 0
94300: ST_TO_ADDR
// sComputer := false ;
94301: LD_ADDR_EXP 194
94305: PUSH
94306: LD_INT 0
94308: ST_TO_ADDR
// s30 := false ;
94309: LD_ADDR_EXP 195
94313: PUSH
94314: LD_INT 0
94316: ST_TO_ADDR
// s60 := false ;
94317: LD_ADDR_EXP 196
94321: PUSH
94322: LD_INT 0
94324: ST_TO_ADDR
// end ;
94325: LD_VAR 0 1
94329: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
94330: LD_INT 0
94332: PPUSH
94333: PPUSH
94334: PPUSH
94335: PPUSH
94336: PPUSH
94337: PPUSH
94338: PPUSH
// result := [ ] ;
94339: LD_ADDR_VAR 0 2
94343: PUSH
94344: EMPTY
94345: ST_TO_ADDR
// if campaign_id = 1 then
94346: LD_OWVAR 69
94350: PUSH
94351: LD_INT 1
94353: EQUAL
94354: IFFALSE 97520
// begin case mission_number of 1 :
94356: LD_OWVAR 70
94360: PUSH
94361: LD_INT 1
94363: DOUBLE
94364: EQUAL
94365: IFTRUE 94369
94367: GO 94445
94369: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
94370: LD_ADDR_VAR 0 2
94374: PUSH
94375: LD_INT 2
94377: PUSH
94378: LD_INT 4
94380: PUSH
94381: LD_INT 11
94383: PUSH
94384: LD_INT 12
94386: PUSH
94387: LD_INT 15
94389: PUSH
94390: LD_INT 16
94392: PUSH
94393: LD_INT 22
94395: PUSH
94396: LD_INT 23
94398: PUSH
94399: LD_INT 26
94401: PUSH
94402: EMPTY
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: PUSH
94413: LD_INT 101
94415: PUSH
94416: LD_INT 102
94418: PUSH
94419: LD_INT 106
94421: PUSH
94422: LD_INT 116
94424: PUSH
94425: LD_INT 117
94427: PUSH
94428: LD_INT 118
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: PUSH
94439: EMPTY
94440: LIST
94441: LIST
94442: ST_TO_ADDR
94443: GO 97518
94445: LD_INT 2
94447: DOUBLE
94448: EQUAL
94449: IFTRUE 94453
94451: GO 94537
94453: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
94454: LD_ADDR_VAR 0 2
94458: PUSH
94459: LD_INT 2
94461: PUSH
94462: LD_INT 4
94464: PUSH
94465: LD_INT 11
94467: PUSH
94468: LD_INT 12
94470: PUSH
94471: LD_INT 15
94473: PUSH
94474: LD_INT 16
94476: PUSH
94477: LD_INT 22
94479: PUSH
94480: LD_INT 23
94482: PUSH
94483: LD_INT 26
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: PUSH
94497: LD_INT 101
94499: PUSH
94500: LD_INT 102
94502: PUSH
94503: LD_INT 105
94505: PUSH
94506: LD_INT 106
94508: PUSH
94509: LD_INT 108
94511: PUSH
94512: LD_INT 116
94514: PUSH
94515: LD_INT 117
94517: PUSH
94518: LD_INT 118
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: ST_TO_ADDR
94535: GO 97518
94537: LD_INT 3
94539: DOUBLE
94540: EQUAL
94541: IFTRUE 94545
94543: GO 94633
94545: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94546: LD_ADDR_VAR 0 2
94550: PUSH
94551: LD_INT 2
94553: PUSH
94554: LD_INT 4
94556: PUSH
94557: LD_INT 5
94559: PUSH
94560: LD_INT 11
94562: PUSH
94563: LD_INT 12
94565: PUSH
94566: LD_INT 15
94568: PUSH
94569: LD_INT 16
94571: PUSH
94572: LD_INT 22
94574: PUSH
94575: LD_INT 26
94577: PUSH
94578: LD_INT 36
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 101
94595: PUSH
94596: LD_INT 102
94598: PUSH
94599: LD_INT 105
94601: PUSH
94602: LD_INT 106
94604: PUSH
94605: LD_INT 108
94607: PUSH
94608: LD_INT 116
94610: PUSH
94611: LD_INT 117
94613: PUSH
94614: LD_INT 118
94616: PUSH
94617: EMPTY
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: ST_TO_ADDR
94631: GO 97518
94633: LD_INT 4
94635: DOUBLE
94636: EQUAL
94637: IFTRUE 94641
94639: GO 94737
94641: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94642: LD_ADDR_VAR 0 2
94646: PUSH
94647: LD_INT 2
94649: PUSH
94650: LD_INT 4
94652: PUSH
94653: LD_INT 5
94655: PUSH
94656: LD_INT 8
94658: PUSH
94659: LD_INT 11
94661: PUSH
94662: LD_INT 12
94664: PUSH
94665: LD_INT 15
94667: PUSH
94668: LD_INT 16
94670: PUSH
94671: LD_INT 22
94673: PUSH
94674: LD_INT 23
94676: PUSH
94677: LD_INT 26
94679: PUSH
94680: LD_INT 36
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: PUSH
94697: LD_INT 101
94699: PUSH
94700: LD_INT 102
94702: PUSH
94703: LD_INT 105
94705: PUSH
94706: LD_INT 106
94708: PUSH
94709: LD_INT 108
94711: PUSH
94712: LD_INT 116
94714: PUSH
94715: LD_INT 117
94717: PUSH
94718: LD_INT 118
94720: PUSH
94721: EMPTY
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: ST_TO_ADDR
94735: GO 97518
94737: LD_INT 5
94739: DOUBLE
94740: EQUAL
94741: IFTRUE 94745
94743: GO 94857
94745: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94746: LD_ADDR_VAR 0 2
94750: PUSH
94751: LD_INT 2
94753: PUSH
94754: LD_INT 4
94756: PUSH
94757: LD_INT 5
94759: PUSH
94760: LD_INT 6
94762: PUSH
94763: LD_INT 8
94765: PUSH
94766: LD_INT 11
94768: PUSH
94769: LD_INT 12
94771: PUSH
94772: LD_INT 15
94774: PUSH
94775: LD_INT 16
94777: PUSH
94778: LD_INT 22
94780: PUSH
94781: LD_INT 23
94783: PUSH
94784: LD_INT 25
94786: PUSH
94787: LD_INT 26
94789: PUSH
94790: LD_INT 36
94792: PUSH
94793: EMPTY
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: PUSH
94809: LD_INT 101
94811: PUSH
94812: LD_INT 102
94814: PUSH
94815: LD_INT 105
94817: PUSH
94818: LD_INT 106
94820: PUSH
94821: LD_INT 108
94823: PUSH
94824: LD_INT 109
94826: PUSH
94827: LD_INT 112
94829: PUSH
94830: LD_INT 116
94832: PUSH
94833: LD_INT 117
94835: PUSH
94836: LD_INT 118
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: PUSH
94851: EMPTY
94852: LIST
94853: LIST
94854: ST_TO_ADDR
94855: GO 97518
94857: LD_INT 6
94859: DOUBLE
94860: EQUAL
94861: IFTRUE 94865
94863: GO 94997
94865: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94866: LD_ADDR_VAR 0 2
94870: PUSH
94871: LD_INT 2
94873: PUSH
94874: LD_INT 4
94876: PUSH
94877: LD_INT 5
94879: PUSH
94880: LD_INT 6
94882: PUSH
94883: LD_INT 8
94885: PUSH
94886: LD_INT 11
94888: PUSH
94889: LD_INT 12
94891: PUSH
94892: LD_INT 15
94894: PUSH
94895: LD_INT 16
94897: PUSH
94898: LD_INT 20
94900: PUSH
94901: LD_INT 21
94903: PUSH
94904: LD_INT 22
94906: PUSH
94907: LD_INT 23
94909: PUSH
94910: LD_INT 25
94912: PUSH
94913: LD_INT 26
94915: PUSH
94916: LD_INT 30
94918: PUSH
94919: LD_INT 31
94921: PUSH
94922: LD_INT 32
94924: PUSH
94925: LD_INT 36
94927: PUSH
94928: EMPTY
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: PUSH
94949: LD_INT 101
94951: PUSH
94952: LD_INT 102
94954: PUSH
94955: LD_INT 105
94957: PUSH
94958: LD_INT 106
94960: PUSH
94961: LD_INT 108
94963: PUSH
94964: LD_INT 109
94966: PUSH
94967: LD_INT 112
94969: PUSH
94970: LD_INT 116
94972: PUSH
94973: LD_INT 117
94975: PUSH
94976: LD_INT 118
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: PUSH
94991: EMPTY
94992: LIST
94993: LIST
94994: ST_TO_ADDR
94995: GO 97518
94997: LD_INT 7
94999: DOUBLE
95000: EQUAL
95001: IFTRUE 95005
95003: GO 95117
95005: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95006: LD_ADDR_VAR 0 2
95010: PUSH
95011: LD_INT 2
95013: PUSH
95014: LD_INT 4
95016: PUSH
95017: LD_INT 5
95019: PUSH
95020: LD_INT 7
95022: PUSH
95023: LD_INT 11
95025: PUSH
95026: LD_INT 12
95028: PUSH
95029: LD_INT 15
95031: PUSH
95032: LD_INT 16
95034: PUSH
95035: LD_INT 20
95037: PUSH
95038: LD_INT 21
95040: PUSH
95041: LD_INT 22
95043: PUSH
95044: LD_INT 23
95046: PUSH
95047: LD_INT 25
95049: PUSH
95050: LD_INT 26
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: PUSH
95069: LD_INT 101
95071: PUSH
95072: LD_INT 102
95074: PUSH
95075: LD_INT 103
95077: PUSH
95078: LD_INT 105
95080: PUSH
95081: LD_INT 106
95083: PUSH
95084: LD_INT 108
95086: PUSH
95087: LD_INT 112
95089: PUSH
95090: LD_INT 116
95092: PUSH
95093: LD_INT 117
95095: PUSH
95096: LD_INT 118
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: ST_TO_ADDR
95115: GO 97518
95117: LD_INT 8
95119: DOUBLE
95120: EQUAL
95121: IFTRUE 95125
95123: GO 95265
95125: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95126: LD_ADDR_VAR 0 2
95130: PUSH
95131: LD_INT 2
95133: PUSH
95134: LD_INT 4
95136: PUSH
95137: LD_INT 5
95139: PUSH
95140: LD_INT 6
95142: PUSH
95143: LD_INT 7
95145: PUSH
95146: LD_INT 8
95148: PUSH
95149: LD_INT 11
95151: PUSH
95152: LD_INT 12
95154: PUSH
95155: LD_INT 15
95157: PUSH
95158: LD_INT 16
95160: PUSH
95161: LD_INT 20
95163: PUSH
95164: LD_INT 21
95166: PUSH
95167: LD_INT 22
95169: PUSH
95170: LD_INT 23
95172: PUSH
95173: LD_INT 25
95175: PUSH
95176: LD_INT 26
95178: PUSH
95179: LD_INT 30
95181: PUSH
95182: LD_INT 31
95184: PUSH
95185: LD_INT 32
95187: PUSH
95188: LD_INT 36
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: PUSH
95213: LD_INT 101
95215: PUSH
95216: LD_INT 102
95218: PUSH
95219: LD_INT 103
95221: PUSH
95222: LD_INT 105
95224: PUSH
95225: LD_INT 106
95227: PUSH
95228: LD_INT 108
95230: PUSH
95231: LD_INT 109
95233: PUSH
95234: LD_INT 112
95236: PUSH
95237: LD_INT 116
95239: PUSH
95240: LD_INT 117
95242: PUSH
95243: LD_INT 118
95245: PUSH
95246: EMPTY
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: ST_TO_ADDR
95263: GO 97518
95265: LD_INT 9
95267: DOUBLE
95268: EQUAL
95269: IFTRUE 95273
95271: GO 95421
95273: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
95274: LD_ADDR_VAR 0 2
95278: PUSH
95279: LD_INT 2
95281: PUSH
95282: LD_INT 4
95284: PUSH
95285: LD_INT 5
95287: PUSH
95288: LD_INT 6
95290: PUSH
95291: LD_INT 7
95293: PUSH
95294: LD_INT 8
95296: PUSH
95297: LD_INT 11
95299: PUSH
95300: LD_INT 12
95302: PUSH
95303: LD_INT 15
95305: PUSH
95306: LD_INT 16
95308: PUSH
95309: LD_INT 20
95311: PUSH
95312: LD_INT 21
95314: PUSH
95315: LD_INT 22
95317: PUSH
95318: LD_INT 23
95320: PUSH
95321: LD_INT 25
95323: PUSH
95324: LD_INT 26
95326: PUSH
95327: LD_INT 28
95329: PUSH
95330: LD_INT 30
95332: PUSH
95333: LD_INT 31
95335: PUSH
95336: LD_INT 32
95338: PUSH
95339: LD_INT 36
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: PUSH
95365: LD_INT 101
95367: PUSH
95368: LD_INT 102
95370: PUSH
95371: LD_INT 103
95373: PUSH
95374: LD_INT 105
95376: PUSH
95377: LD_INT 106
95379: PUSH
95380: LD_INT 108
95382: PUSH
95383: LD_INT 109
95385: PUSH
95386: LD_INT 112
95388: PUSH
95389: LD_INT 114
95391: PUSH
95392: LD_INT 116
95394: PUSH
95395: LD_INT 117
95397: PUSH
95398: LD_INT 118
95400: PUSH
95401: EMPTY
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: PUSH
95415: EMPTY
95416: LIST
95417: LIST
95418: ST_TO_ADDR
95419: GO 97518
95421: LD_INT 10
95423: DOUBLE
95424: EQUAL
95425: IFTRUE 95429
95427: GO 95625
95429: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
95430: LD_ADDR_VAR 0 2
95434: PUSH
95435: LD_INT 2
95437: PUSH
95438: LD_INT 4
95440: PUSH
95441: LD_INT 5
95443: PUSH
95444: LD_INT 6
95446: PUSH
95447: LD_INT 7
95449: PUSH
95450: LD_INT 8
95452: PUSH
95453: LD_INT 9
95455: PUSH
95456: LD_INT 10
95458: PUSH
95459: LD_INT 11
95461: PUSH
95462: LD_INT 12
95464: PUSH
95465: LD_INT 13
95467: PUSH
95468: LD_INT 14
95470: PUSH
95471: LD_INT 15
95473: PUSH
95474: LD_INT 16
95476: PUSH
95477: LD_INT 17
95479: PUSH
95480: LD_INT 18
95482: PUSH
95483: LD_INT 19
95485: PUSH
95486: LD_INT 20
95488: PUSH
95489: LD_INT 21
95491: PUSH
95492: LD_INT 22
95494: PUSH
95495: LD_INT 23
95497: PUSH
95498: LD_INT 24
95500: PUSH
95501: LD_INT 25
95503: PUSH
95504: LD_INT 26
95506: PUSH
95507: LD_INT 28
95509: PUSH
95510: LD_INT 30
95512: PUSH
95513: LD_INT 31
95515: PUSH
95516: LD_INT 32
95518: PUSH
95519: LD_INT 36
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: PUSH
95553: LD_INT 101
95555: PUSH
95556: LD_INT 102
95558: PUSH
95559: LD_INT 103
95561: PUSH
95562: LD_INT 104
95564: PUSH
95565: LD_INT 105
95567: PUSH
95568: LD_INT 106
95570: PUSH
95571: LD_INT 107
95573: PUSH
95574: LD_INT 108
95576: PUSH
95577: LD_INT 109
95579: PUSH
95580: LD_INT 110
95582: PUSH
95583: LD_INT 111
95585: PUSH
95586: LD_INT 112
95588: PUSH
95589: LD_INT 114
95591: PUSH
95592: LD_INT 116
95594: PUSH
95595: LD_INT 117
95597: PUSH
95598: LD_INT 118
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: ST_TO_ADDR
95623: GO 97518
95625: LD_INT 11
95627: DOUBLE
95628: EQUAL
95629: IFTRUE 95633
95631: GO 95837
95633: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95634: LD_ADDR_VAR 0 2
95638: PUSH
95639: LD_INT 2
95641: PUSH
95642: LD_INT 3
95644: PUSH
95645: LD_INT 4
95647: PUSH
95648: LD_INT 5
95650: PUSH
95651: LD_INT 6
95653: PUSH
95654: LD_INT 7
95656: PUSH
95657: LD_INT 8
95659: PUSH
95660: LD_INT 9
95662: PUSH
95663: LD_INT 10
95665: PUSH
95666: LD_INT 11
95668: PUSH
95669: LD_INT 12
95671: PUSH
95672: LD_INT 13
95674: PUSH
95675: LD_INT 14
95677: PUSH
95678: LD_INT 15
95680: PUSH
95681: LD_INT 16
95683: PUSH
95684: LD_INT 17
95686: PUSH
95687: LD_INT 18
95689: PUSH
95690: LD_INT 19
95692: PUSH
95693: LD_INT 20
95695: PUSH
95696: LD_INT 21
95698: PUSH
95699: LD_INT 22
95701: PUSH
95702: LD_INT 23
95704: PUSH
95705: LD_INT 24
95707: PUSH
95708: LD_INT 25
95710: PUSH
95711: LD_INT 26
95713: PUSH
95714: LD_INT 28
95716: PUSH
95717: LD_INT 30
95719: PUSH
95720: LD_INT 31
95722: PUSH
95723: LD_INT 32
95725: PUSH
95726: LD_INT 34
95728: PUSH
95729: LD_INT 36
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: PUSH
95765: LD_INT 101
95767: PUSH
95768: LD_INT 102
95770: PUSH
95771: LD_INT 103
95773: PUSH
95774: LD_INT 104
95776: PUSH
95777: LD_INT 105
95779: PUSH
95780: LD_INT 106
95782: PUSH
95783: LD_INT 107
95785: PUSH
95786: LD_INT 108
95788: PUSH
95789: LD_INT 109
95791: PUSH
95792: LD_INT 110
95794: PUSH
95795: LD_INT 111
95797: PUSH
95798: LD_INT 112
95800: PUSH
95801: LD_INT 114
95803: PUSH
95804: LD_INT 116
95806: PUSH
95807: LD_INT 117
95809: PUSH
95810: LD_INT 118
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: PUSH
95831: EMPTY
95832: LIST
95833: LIST
95834: ST_TO_ADDR
95835: GO 97518
95837: LD_INT 12
95839: DOUBLE
95840: EQUAL
95841: IFTRUE 95845
95843: GO 96065
95845: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95846: LD_ADDR_VAR 0 2
95850: PUSH
95851: LD_INT 1
95853: PUSH
95854: LD_INT 2
95856: PUSH
95857: LD_INT 3
95859: PUSH
95860: LD_INT 4
95862: PUSH
95863: LD_INT 5
95865: PUSH
95866: LD_INT 6
95868: PUSH
95869: LD_INT 7
95871: PUSH
95872: LD_INT 8
95874: PUSH
95875: LD_INT 9
95877: PUSH
95878: LD_INT 10
95880: PUSH
95881: LD_INT 11
95883: PUSH
95884: LD_INT 12
95886: PUSH
95887: LD_INT 13
95889: PUSH
95890: LD_INT 14
95892: PUSH
95893: LD_INT 15
95895: PUSH
95896: LD_INT 16
95898: PUSH
95899: LD_INT 17
95901: PUSH
95902: LD_INT 18
95904: PUSH
95905: LD_INT 19
95907: PUSH
95908: LD_INT 20
95910: PUSH
95911: LD_INT 21
95913: PUSH
95914: LD_INT 22
95916: PUSH
95917: LD_INT 23
95919: PUSH
95920: LD_INT 24
95922: PUSH
95923: LD_INT 25
95925: PUSH
95926: LD_INT 26
95928: PUSH
95929: LD_INT 27
95931: PUSH
95932: LD_INT 28
95934: PUSH
95935: LD_INT 30
95937: PUSH
95938: LD_INT 31
95940: PUSH
95941: LD_INT 32
95943: PUSH
95944: LD_INT 33
95946: PUSH
95947: LD_INT 34
95949: PUSH
95950: LD_INT 36
95952: PUSH
95953: EMPTY
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: LIST
95985: LIST
95986: LIST
95987: LIST
95988: PUSH
95989: LD_INT 101
95991: PUSH
95992: LD_INT 102
95994: PUSH
95995: LD_INT 103
95997: PUSH
95998: LD_INT 104
96000: PUSH
96001: LD_INT 105
96003: PUSH
96004: LD_INT 106
96006: PUSH
96007: LD_INT 107
96009: PUSH
96010: LD_INT 108
96012: PUSH
96013: LD_INT 109
96015: PUSH
96016: LD_INT 110
96018: PUSH
96019: LD_INT 111
96021: PUSH
96022: LD_INT 112
96024: PUSH
96025: LD_INT 113
96027: PUSH
96028: LD_INT 114
96030: PUSH
96031: LD_INT 116
96033: PUSH
96034: LD_INT 117
96036: PUSH
96037: LD_INT 118
96039: PUSH
96040: EMPTY
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: PUSH
96059: EMPTY
96060: LIST
96061: LIST
96062: ST_TO_ADDR
96063: GO 97518
96065: LD_INT 13
96067: DOUBLE
96068: EQUAL
96069: IFTRUE 96073
96071: GO 96281
96073: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96074: LD_ADDR_VAR 0 2
96078: PUSH
96079: LD_INT 1
96081: PUSH
96082: LD_INT 2
96084: PUSH
96085: LD_INT 3
96087: PUSH
96088: LD_INT 4
96090: PUSH
96091: LD_INT 5
96093: PUSH
96094: LD_INT 8
96096: PUSH
96097: LD_INT 9
96099: PUSH
96100: LD_INT 10
96102: PUSH
96103: LD_INT 11
96105: PUSH
96106: LD_INT 12
96108: PUSH
96109: LD_INT 14
96111: PUSH
96112: LD_INT 15
96114: PUSH
96115: LD_INT 16
96117: PUSH
96118: LD_INT 17
96120: PUSH
96121: LD_INT 18
96123: PUSH
96124: LD_INT 19
96126: PUSH
96127: LD_INT 20
96129: PUSH
96130: LD_INT 21
96132: PUSH
96133: LD_INT 22
96135: PUSH
96136: LD_INT 23
96138: PUSH
96139: LD_INT 24
96141: PUSH
96142: LD_INT 25
96144: PUSH
96145: LD_INT 26
96147: PUSH
96148: LD_INT 27
96150: PUSH
96151: LD_INT 28
96153: PUSH
96154: LD_INT 30
96156: PUSH
96157: LD_INT 31
96159: PUSH
96160: LD_INT 32
96162: PUSH
96163: LD_INT 33
96165: PUSH
96166: LD_INT 34
96168: PUSH
96169: LD_INT 36
96171: PUSH
96172: EMPTY
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: LIST
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: PUSH
96205: LD_INT 101
96207: PUSH
96208: LD_INT 102
96210: PUSH
96211: LD_INT 103
96213: PUSH
96214: LD_INT 104
96216: PUSH
96217: LD_INT 105
96219: PUSH
96220: LD_INT 106
96222: PUSH
96223: LD_INT 107
96225: PUSH
96226: LD_INT 108
96228: PUSH
96229: LD_INT 109
96231: PUSH
96232: LD_INT 110
96234: PUSH
96235: LD_INT 111
96237: PUSH
96238: LD_INT 112
96240: PUSH
96241: LD_INT 113
96243: PUSH
96244: LD_INT 114
96246: PUSH
96247: LD_INT 116
96249: PUSH
96250: LD_INT 117
96252: PUSH
96253: LD_INT 118
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: PUSH
96275: EMPTY
96276: LIST
96277: LIST
96278: ST_TO_ADDR
96279: GO 97518
96281: LD_INT 14
96283: DOUBLE
96284: EQUAL
96285: IFTRUE 96289
96287: GO 96513
96289: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
96290: LD_ADDR_VAR 0 2
96294: PUSH
96295: LD_INT 1
96297: PUSH
96298: LD_INT 2
96300: PUSH
96301: LD_INT 3
96303: PUSH
96304: LD_INT 4
96306: PUSH
96307: LD_INT 5
96309: PUSH
96310: LD_INT 6
96312: PUSH
96313: LD_INT 7
96315: PUSH
96316: LD_INT 8
96318: PUSH
96319: LD_INT 9
96321: PUSH
96322: LD_INT 10
96324: PUSH
96325: LD_INT 11
96327: PUSH
96328: LD_INT 12
96330: PUSH
96331: LD_INT 13
96333: PUSH
96334: LD_INT 14
96336: PUSH
96337: LD_INT 15
96339: PUSH
96340: LD_INT 16
96342: PUSH
96343: LD_INT 17
96345: PUSH
96346: LD_INT 18
96348: PUSH
96349: LD_INT 19
96351: PUSH
96352: LD_INT 20
96354: PUSH
96355: LD_INT 21
96357: PUSH
96358: LD_INT 22
96360: PUSH
96361: LD_INT 23
96363: PUSH
96364: LD_INT 24
96366: PUSH
96367: LD_INT 25
96369: PUSH
96370: LD_INT 26
96372: PUSH
96373: LD_INT 27
96375: PUSH
96376: LD_INT 28
96378: PUSH
96379: LD_INT 29
96381: PUSH
96382: LD_INT 30
96384: PUSH
96385: LD_INT 31
96387: PUSH
96388: LD_INT 32
96390: PUSH
96391: LD_INT 33
96393: PUSH
96394: LD_INT 34
96396: PUSH
96397: LD_INT 36
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: PUSH
96437: LD_INT 101
96439: PUSH
96440: LD_INT 102
96442: PUSH
96443: LD_INT 103
96445: PUSH
96446: LD_INT 104
96448: PUSH
96449: LD_INT 105
96451: PUSH
96452: LD_INT 106
96454: PUSH
96455: LD_INT 107
96457: PUSH
96458: LD_INT 108
96460: PUSH
96461: LD_INT 109
96463: PUSH
96464: LD_INT 110
96466: PUSH
96467: LD_INT 111
96469: PUSH
96470: LD_INT 112
96472: PUSH
96473: LD_INT 113
96475: PUSH
96476: LD_INT 114
96478: PUSH
96479: LD_INT 116
96481: PUSH
96482: LD_INT 117
96484: PUSH
96485: LD_INT 118
96487: PUSH
96488: EMPTY
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: PUSH
96507: EMPTY
96508: LIST
96509: LIST
96510: ST_TO_ADDR
96511: GO 97518
96513: LD_INT 15
96515: DOUBLE
96516: EQUAL
96517: IFTRUE 96521
96519: GO 96745
96521: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96522: LD_ADDR_VAR 0 2
96526: PUSH
96527: LD_INT 1
96529: PUSH
96530: LD_INT 2
96532: PUSH
96533: LD_INT 3
96535: PUSH
96536: LD_INT 4
96538: PUSH
96539: LD_INT 5
96541: PUSH
96542: LD_INT 6
96544: PUSH
96545: LD_INT 7
96547: PUSH
96548: LD_INT 8
96550: PUSH
96551: LD_INT 9
96553: PUSH
96554: LD_INT 10
96556: PUSH
96557: LD_INT 11
96559: PUSH
96560: LD_INT 12
96562: PUSH
96563: LD_INT 13
96565: PUSH
96566: LD_INT 14
96568: PUSH
96569: LD_INT 15
96571: PUSH
96572: LD_INT 16
96574: PUSH
96575: LD_INT 17
96577: PUSH
96578: LD_INT 18
96580: PUSH
96581: LD_INT 19
96583: PUSH
96584: LD_INT 20
96586: PUSH
96587: LD_INT 21
96589: PUSH
96590: LD_INT 22
96592: PUSH
96593: LD_INT 23
96595: PUSH
96596: LD_INT 24
96598: PUSH
96599: LD_INT 25
96601: PUSH
96602: LD_INT 26
96604: PUSH
96605: LD_INT 27
96607: PUSH
96608: LD_INT 28
96610: PUSH
96611: LD_INT 29
96613: PUSH
96614: LD_INT 30
96616: PUSH
96617: LD_INT 31
96619: PUSH
96620: LD_INT 32
96622: PUSH
96623: LD_INT 33
96625: PUSH
96626: LD_INT 34
96628: PUSH
96629: LD_INT 36
96631: PUSH
96632: EMPTY
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: LIST
96645: LIST
96646: LIST
96647: LIST
96648: LIST
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: PUSH
96669: LD_INT 101
96671: PUSH
96672: LD_INT 102
96674: PUSH
96675: LD_INT 103
96677: PUSH
96678: LD_INT 104
96680: PUSH
96681: LD_INT 105
96683: PUSH
96684: LD_INT 106
96686: PUSH
96687: LD_INT 107
96689: PUSH
96690: LD_INT 108
96692: PUSH
96693: LD_INT 109
96695: PUSH
96696: LD_INT 110
96698: PUSH
96699: LD_INT 111
96701: PUSH
96702: LD_INT 112
96704: PUSH
96705: LD_INT 113
96707: PUSH
96708: LD_INT 114
96710: PUSH
96711: LD_INT 116
96713: PUSH
96714: LD_INT 117
96716: PUSH
96717: LD_INT 118
96719: PUSH
96720: EMPTY
96721: LIST
96722: LIST
96723: LIST
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: PUSH
96739: EMPTY
96740: LIST
96741: LIST
96742: ST_TO_ADDR
96743: GO 97518
96745: LD_INT 16
96747: DOUBLE
96748: EQUAL
96749: IFTRUE 96753
96751: GO 96889
96753: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96754: LD_ADDR_VAR 0 2
96758: PUSH
96759: LD_INT 2
96761: PUSH
96762: LD_INT 4
96764: PUSH
96765: LD_INT 5
96767: PUSH
96768: LD_INT 7
96770: PUSH
96771: LD_INT 11
96773: PUSH
96774: LD_INT 12
96776: PUSH
96777: LD_INT 15
96779: PUSH
96780: LD_INT 16
96782: PUSH
96783: LD_INT 20
96785: PUSH
96786: LD_INT 21
96788: PUSH
96789: LD_INT 22
96791: PUSH
96792: LD_INT 23
96794: PUSH
96795: LD_INT 25
96797: PUSH
96798: LD_INT 26
96800: PUSH
96801: LD_INT 30
96803: PUSH
96804: LD_INT 31
96806: PUSH
96807: LD_INT 32
96809: PUSH
96810: LD_INT 33
96812: PUSH
96813: LD_INT 34
96815: PUSH
96816: EMPTY
96817: LIST
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: PUSH
96837: LD_INT 101
96839: PUSH
96840: LD_INT 102
96842: PUSH
96843: LD_INT 103
96845: PUSH
96846: LD_INT 106
96848: PUSH
96849: LD_INT 108
96851: PUSH
96852: LD_INT 112
96854: PUSH
96855: LD_INT 113
96857: PUSH
96858: LD_INT 114
96860: PUSH
96861: LD_INT 116
96863: PUSH
96864: LD_INT 117
96866: PUSH
96867: LD_INT 118
96869: PUSH
96870: EMPTY
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: PUSH
96883: EMPTY
96884: LIST
96885: LIST
96886: ST_TO_ADDR
96887: GO 97518
96889: LD_INT 17
96891: DOUBLE
96892: EQUAL
96893: IFTRUE 96897
96895: GO 97121
96897: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96898: LD_ADDR_VAR 0 2
96902: PUSH
96903: LD_INT 1
96905: PUSH
96906: LD_INT 2
96908: PUSH
96909: LD_INT 3
96911: PUSH
96912: LD_INT 4
96914: PUSH
96915: LD_INT 5
96917: PUSH
96918: LD_INT 6
96920: PUSH
96921: LD_INT 7
96923: PUSH
96924: LD_INT 8
96926: PUSH
96927: LD_INT 9
96929: PUSH
96930: LD_INT 10
96932: PUSH
96933: LD_INT 11
96935: PUSH
96936: LD_INT 12
96938: PUSH
96939: LD_INT 13
96941: PUSH
96942: LD_INT 14
96944: PUSH
96945: LD_INT 15
96947: PUSH
96948: LD_INT 16
96950: PUSH
96951: LD_INT 17
96953: PUSH
96954: LD_INT 18
96956: PUSH
96957: LD_INT 19
96959: PUSH
96960: LD_INT 20
96962: PUSH
96963: LD_INT 21
96965: PUSH
96966: LD_INT 22
96968: PUSH
96969: LD_INT 23
96971: PUSH
96972: LD_INT 24
96974: PUSH
96975: LD_INT 25
96977: PUSH
96978: LD_INT 26
96980: PUSH
96981: LD_INT 27
96983: PUSH
96984: LD_INT 28
96986: PUSH
96987: LD_INT 29
96989: PUSH
96990: LD_INT 30
96992: PUSH
96993: LD_INT 31
96995: PUSH
96996: LD_INT 32
96998: PUSH
96999: LD_INT 33
97001: PUSH
97002: LD_INT 34
97004: PUSH
97005: LD_INT 36
97007: PUSH
97008: EMPTY
97009: LIST
97010: LIST
97011: LIST
97012: LIST
97013: LIST
97014: LIST
97015: LIST
97016: LIST
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: PUSH
97045: LD_INT 101
97047: PUSH
97048: LD_INT 102
97050: PUSH
97051: LD_INT 103
97053: PUSH
97054: LD_INT 104
97056: PUSH
97057: LD_INT 105
97059: PUSH
97060: LD_INT 106
97062: PUSH
97063: LD_INT 107
97065: PUSH
97066: LD_INT 108
97068: PUSH
97069: LD_INT 109
97071: PUSH
97072: LD_INT 110
97074: PUSH
97075: LD_INT 111
97077: PUSH
97078: LD_INT 112
97080: PUSH
97081: LD_INT 113
97083: PUSH
97084: LD_INT 114
97086: PUSH
97087: LD_INT 116
97089: PUSH
97090: LD_INT 117
97092: PUSH
97093: LD_INT 118
97095: PUSH
97096: EMPTY
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: ST_TO_ADDR
97119: GO 97518
97121: LD_INT 18
97123: DOUBLE
97124: EQUAL
97125: IFTRUE 97129
97127: GO 97277
97129: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97130: LD_ADDR_VAR 0 2
97134: PUSH
97135: LD_INT 2
97137: PUSH
97138: LD_INT 4
97140: PUSH
97141: LD_INT 5
97143: PUSH
97144: LD_INT 7
97146: PUSH
97147: LD_INT 11
97149: PUSH
97150: LD_INT 12
97152: PUSH
97153: LD_INT 15
97155: PUSH
97156: LD_INT 16
97158: PUSH
97159: LD_INT 20
97161: PUSH
97162: LD_INT 21
97164: PUSH
97165: LD_INT 22
97167: PUSH
97168: LD_INT 23
97170: PUSH
97171: LD_INT 25
97173: PUSH
97174: LD_INT 26
97176: PUSH
97177: LD_INT 30
97179: PUSH
97180: LD_INT 31
97182: PUSH
97183: LD_INT 32
97185: PUSH
97186: LD_INT 33
97188: PUSH
97189: LD_INT 34
97191: PUSH
97192: LD_INT 35
97194: PUSH
97195: LD_INT 36
97197: PUSH
97198: EMPTY
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: PUSH
97221: LD_INT 101
97223: PUSH
97224: LD_INT 102
97226: PUSH
97227: LD_INT 103
97229: PUSH
97230: LD_INT 106
97232: PUSH
97233: LD_INT 108
97235: PUSH
97236: LD_INT 112
97238: PUSH
97239: LD_INT 113
97241: PUSH
97242: LD_INT 114
97244: PUSH
97245: LD_INT 115
97247: PUSH
97248: LD_INT 116
97250: PUSH
97251: LD_INT 117
97253: PUSH
97254: LD_INT 118
97256: PUSH
97257: EMPTY
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: ST_TO_ADDR
97275: GO 97518
97277: LD_INT 19
97279: DOUBLE
97280: EQUAL
97281: IFTRUE 97285
97283: GO 97517
97285: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
97286: LD_ADDR_VAR 0 2
97290: PUSH
97291: LD_INT 1
97293: PUSH
97294: LD_INT 2
97296: PUSH
97297: LD_INT 3
97299: PUSH
97300: LD_INT 4
97302: PUSH
97303: LD_INT 5
97305: PUSH
97306: LD_INT 6
97308: PUSH
97309: LD_INT 7
97311: PUSH
97312: LD_INT 8
97314: PUSH
97315: LD_INT 9
97317: PUSH
97318: LD_INT 10
97320: PUSH
97321: LD_INT 11
97323: PUSH
97324: LD_INT 12
97326: PUSH
97327: LD_INT 13
97329: PUSH
97330: LD_INT 14
97332: PUSH
97333: LD_INT 15
97335: PUSH
97336: LD_INT 16
97338: PUSH
97339: LD_INT 17
97341: PUSH
97342: LD_INT 18
97344: PUSH
97345: LD_INT 19
97347: PUSH
97348: LD_INT 20
97350: PUSH
97351: LD_INT 21
97353: PUSH
97354: LD_INT 22
97356: PUSH
97357: LD_INT 23
97359: PUSH
97360: LD_INT 24
97362: PUSH
97363: LD_INT 25
97365: PUSH
97366: LD_INT 26
97368: PUSH
97369: LD_INT 27
97371: PUSH
97372: LD_INT 28
97374: PUSH
97375: LD_INT 29
97377: PUSH
97378: LD_INT 30
97380: PUSH
97381: LD_INT 31
97383: PUSH
97384: LD_INT 32
97386: PUSH
97387: LD_INT 33
97389: PUSH
97390: LD_INT 34
97392: PUSH
97393: LD_INT 35
97395: PUSH
97396: LD_INT 36
97398: PUSH
97399: EMPTY
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: LIST
97436: PUSH
97437: LD_INT 101
97439: PUSH
97440: LD_INT 102
97442: PUSH
97443: LD_INT 103
97445: PUSH
97446: LD_INT 104
97448: PUSH
97449: LD_INT 105
97451: PUSH
97452: LD_INT 106
97454: PUSH
97455: LD_INT 107
97457: PUSH
97458: LD_INT 108
97460: PUSH
97461: LD_INT 109
97463: PUSH
97464: LD_INT 110
97466: PUSH
97467: LD_INT 111
97469: PUSH
97470: LD_INT 112
97472: PUSH
97473: LD_INT 113
97475: PUSH
97476: LD_INT 114
97478: PUSH
97479: LD_INT 115
97481: PUSH
97482: LD_INT 116
97484: PUSH
97485: LD_INT 117
97487: PUSH
97488: LD_INT 118
97490: PUSH
97491: EMPTY
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: PUSH
97511: EMPTY
97512: LIST
97513: LIST
97514: ST_TO_ADDR
97515: GO 97518
97517: POP
// end else
97518: GO 97749
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97520: LD_ADDR_VAR 0 2
97524: PUSH
97525: LD_INT 1
97527: PUSH
97528: LD_INT 2
97530: PUSH
97531: LD_INT 3
97533: PUSH
97534: LD_INT 4
97536: PUSH
97537: LD_INT 5
97539: PUSH
97540: LD_INT 6
97542: PUSH
97543: LD_INT 7
97545: PUSH
97546: LD_INT 8
97548: PUSH
97549: LD_INT 9
97551: PUSH
97552: LD_INT 10
97554: PUSH
97555: LD_INT 11
97557: PUSH
97558: LD_INT 12
97560: PUSH
97561: LD_INT 13
97563: PUSH
97564: LD_INT 14
97566: PUSH
97567: LD_INT 15
97569: PUSH
97570: LD_INT 16
97572: PUSH
97573: LD_INT 17
97575: PUSH
97576: LD_INT 18
97578: PUSH
97579: LD_INT 19
97581: PUSH
97582: LD_INT 20
97584: PUSH
97585: LD_INT 21
97587: PUSH
97588: LD_INT 22
97590: PUSH
97591: LD_INT 23
97593: PUSH
97594: LD_INT 24
97596: PUSH
97597: LD_INT 25
97599: PUSH
97600: LD_INT 26
97602: PUSH
97603: LD_INT 27
97605: PUSH
97606: LD_INT 28
97608: PUSH
97609: LD_INT 29
97611: PUSH
97612: LD_INT 30
97614: PUSH
97615: LD_INT 31
97617: PUSH
97618: LD_INT 32
97620: PUSH
97621: LD_INT 33
97623: PUSH
97624: LD_INT 34
97626: PUSH
97627: LD_INT 35
97629: PUSH
97630: LD_INT 36
97632: PUSH
97633: EMPTY
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: PUSH
97671: LD_INT 101
97673: PUSH
97674: LD_INT 102
97676: PUSH
97677: LD_INT 103
97679: PUSH
97680: LD_INT 104
97682: PUSH
97683: LD_INT 105
97685: PUSH
97686: LD_INT 106
97688: PUSH
97689: LD_INT 107
97691: PUSH
97692: LD_INT 108
97694: PUSH
97695: LD_INT 109
97697: PUSH
97698: LD_INT 110
97700: PUSH
97701: LD_INT 111
97703: PUSH
97704: LD_INT 112
97706: PUSH
97707: LD_INT 113
97709: PUSH
97710: LD_INT 114
97712: PUSH
97713: LD_INT 115
97715: PUSH
97716: LD_INT 116
97718: PUSH
97719: LD_INT 117
97721: PUSH
97722: LD_INT 118
97724: PUSH
97725: EMPTY
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: PUSH
97745: EMPTY
97746: LIST
97747: LIST
97748: ST_TO_ADDR
// if result then
97749: LD_VAR 0 2
97753: IFFALSE 98539
// begin normal :=  ;
97755: LD_ADDR_VAR 0 5
97759: PUSH
97760: LD_STRING 
97762: ST_TO_ADDR
// hardcore :=  ;
97763: LD_ADDR_VAR 0 6
97767: PUSH
97768: LD_STRING 
97770: ST_TO_ADDR
// active :=  ;
97771: LD_ADDR_VAR 0 7
97775: PUSH
97776: LD_STRING 
97778: ST_TO_ADDR
// for i = 1 to normalCounter do
97779: LD_ADDR_VAR 0 8
97783: PUSH
97784: DOUBLE
97785: LD_INT 1
97787: DEC
97788: ST_TO_ADDR
97789: LD_EXP 141
97793: PUSH
97794: FOR_TO
97795: IFFALSE 97896
// begin tmp := 0 ;
97797: LD_ADDR_VAR 0 3
97801: PUSH
97802: LD_STRING 0
97804: ST_TO_ADDR
// if result [ 1 ] then
97805: LD_VAR 0 2
97809: PUSH
97810: LD_INT 1
97812: ARRAY
97813: IFFALSE 97878
// if result [ 1 ] [ 1 ] = i then
97815: LD_VAR 0 2
97819: PUSH
97820: LD_INT 1
97822: ARRAY
97823: PUSH
97824: LD_INT 1
97826: ARRAY
97827: PUSH
97828: LD_VAR 0 8
97832: EQUAL
97833: IFFALSE 97878
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97835: LD_ADDR_VAR 0 2
97839: PUSH
97840: LD_VAR 0 2
97844: PPUSH
97845: LD_INT 1
97847: PPUSH
97848: LD_VAR 0 2
97852: PUSH
97853: LD_INT 1
97855: ARRAY
97856: PPUSH
97857: LD_INT 1
97859: PPUSH
97860: CALL_OW 3
97864: PPUSH
97865: CALL_OW 1
97869: ST_TO_ADDR
// tmp := 1 ;
97870: LD_ADDR_VAR 0 3
97874: PUSH
97875: LD_STRING 1
97877: ST_TO_ADDR
// end ; normal := normal & tmp ;
97878: LD_ADDR_VAR 0 5
97882: PUSH
97883: LD_VAR 0 5
97887: PUSH
97888: LD_VAR 0 3
97892: STR
97893: ST_TO_ADDR
// end ;
97894: GO 97794
97896: POP
97897: POP
// for i = 1 to hardcoreCounter do
97898: LD_ADDR_VAR 0 8
97902: PUSH
97903: DOUBLE
97904: LD_INT 1
97906: DEC
97907: ST_TO_ADDR
97908: LD_EXP 142
97912: PUSH
97913: FOR_TO
97914: IFFALSE 98019
// begin tmp := 0 ;
97916: LD_ADDR_VAR 0 3
97920: PUSH
97921: LD_STRING 0
97923: ST_TO_ADDR
// if result [ 2 ] then
97924: LD_VAR 0 2
97928: PUSH
97929: LD_INT 2
97931: ARRAY
97932: IFFALSE 98001
// if result [ 2 ] [ 1 ] = 100 + i then
97934: LD_VAR 0 2
97938: PUSH
97939: LD_INT 2
97941: ARRAY
97942: PUSH
97943: LD_INT 1
97945: ARRAY
97946: PUSH
97947: LD_INT 100
97949: PUSH
97950: LD_VAR 0 8
97954: PLUS
97955: EQUAL
97956: IFFALSE 98001
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97958: LD_ADDR_VAR 0 2
97962: PUSH
97963: LD_VAR 0 2
97967: PPUSH
97968: LD_INT 2
97970: PPUSH
97971: LD_VAR 0 2
97975: PUSH
97976: LD_INT 2
97978: ARRAY
97979: PPUSH
97980: LD_INT 1
97982: PPUSH
97983: CALL_OW 3
97987: PPUSH
97988: CALL_OW 1
97992: ST_TO_ADDR
// tmp := 1 ;
97993: LD_ADDR_VAR 0 3
97997: PUSH
97998: LD_STRING 1
98000: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98001: LD_ADDR_VAR 0 6
98005: PUSH
98006: LD_VAR 0 6
98010: PUSH
98011: LD_VAR 0 3
98015: STR
98016: ST_TO_ADDR
// end ;
98017: GO 97913
98019: POP
98020: POP
// if isGameLoad then
98021: LD_VAR 0 1
98025: IFFALSE 98500
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
98027: LD_ADDR_VAR 0 4
98031: PUSH
98032: LD_EXP 145
98036: PUSH
98037: LD_EXP 144
98041: PUSH
98042: LD_EXP 146
98046: PUSH
98047: LD_EXP 143
98051: PUSH
98052: LD_EXP 147
98056: PUSH
98057: LD_EXP 148
98061: PUSH
98062: LD_EXP 149
98066: PUSH
98067: LD_EXP 150
98071: PUSH
98072: LD_EXP 151
98076: PUSH
98077: LD_EXP 152
98081: PUSH
98082: LD_EXP 153
98086: PUSH
98087: LD_EXP 154
98091: PUSH
98092: LD_EXP 155
98096: PUSH
98097: LD_EXP 156
98101: PUSH
98102: LD_EXP 164
98106: PUSH
98107: LD_EXP 165
98111: PUSH
98112: LD_EXP 166
98116: PUSH
98117: LD_EXP 167
98121: PUSH
98122: LD_EXP 169
98126: PUSH
98127: LD_EXP 170
98131: PUSH
98132: LD_EXP 171
98136: PUSH
98137: LD_EXP 174
98141: PUSH
98142: LD_EXP 176
98146: PUSH
98147: LD_EXP 177
98151: PUSH
98152: LD_EXP 178
98156: PUSH
98157: LD_EXP 180
98161: PUSH
98162: LD_EXP 181
98166: PUSH
98167: LD_EXP 184
98171: PUSH
98172: LD_EXP 185
98176: PUSH
98177: LD_EXP 186
98181: PUSH
98182: LD_EXP 187
98186: PUSH
98187: LD_EXP 188
98191: PUSH
98192: LD_EXP 189
98196: PUSH
98197: LD_EXP 190
98201: PUSH
98202: LD_EXP 191
98206: PUSH
98207: LD_EXP 192
98211: PUSH
98212: LD_EXP 157
98216: PUSH
98217: LD_EXP 158
98221: PUSH
98222: LD_EXP 161
98226: PUSH
98227: LD_EXP 162
98231: PUSH
98232: LD_EXP 163
98236: PUSH
98237: LD_EXP 159
98241: PUSH
98242: LD_EXP 160
98246: PUSH
98247: LD_EXP 168
98251: PUSH
98252: LD_EXP 172
98256: PUSH
98257: LD_EXP 173
98261: PUSH
98262: LD_EXP 175
98266: PUSH
98267: LD_EXP 179
98271: PUSH
98272: LD_EXP 182
98276: PUSH
98277: LD_EXP 183
98281: PUSH
98282: LD_EXP 193
98286: PUSH
98287: LD_EXP 194
98291: PUSH
98292: LD_EXP 195
98296: PUSH
98297: LD_EXP 196
98301: PUSH
98302: EMPTY
98303: LIST
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: LIST
98309: LIST
98310: LIST
98311: LIST
98312: LIST
98313: LIST
98314: LIST
98315: LIST
98316: LIST
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: ST_TO_ADDR
// tmp :=  ;
98358: LD_ADDR_VAR 0 3
98362: PUSH
98363: LD_STRING 
98365: ST_TO_ADDR
// for i = 1 to normalCounter do
98366: LD_ADDR_VAR 0 8
98370: PUSH
98371: DOUBLE
98372: LD_INT 1
98374: DEC
98375: ST_TO_ADDR
98376: LD_EXP 141
98380: PUSH
98381: FOR_TO
98382: IFFALSE 98418
// begin if flags [ i ] then
98384: LD_VAR 0 4
98388: PUSH
98389: LD_VAR 0 8
98393: ARRAY
98394: IFFALSE 98416
// tmp := tmp & i & ; ;
98396: LD_ADDR_VAR 0 3
98400: PUSH
98401: LD_VAR 0 3
98405: PUSH
98406: LD_VAR 0 8
98410: STR
98411: PUSH
98412: LD_STRING ;
98414: STR
98415: ST_TO_ADDR
// end ;
98416: GO 98381
98418: POP
98419: POP
// for i = 1 to hardcoreCounter do
98420: LD_ADDR_VAR 0 8
98424: PUSH
98425: DOUBLE
98426: LD_INT 1
98428: DEC
98429: ST_TO_ADDR
98430: LD_EXP 142
98434: PUSH
98435: FOR_TO
98436: IFFALSE 98482
// begin if flags [ normalCounter + i ] then
98438: LD_VAR 0 4
98442: PUSH
98443: LD_EXP 141
98447: PUSH
98448: LD_VAR 0 8
98452: PLUS
98453: ARRAY
98454: IFFALSE 98480
// tmp := tmp & ( 100 + i ) & ; ;
98456: LD_ADDR_VAR 0 3
98460: PUSH
98461: LD_VAR 0 3
98465: PUSH
98466: LD_INT 100
98468: PUSH
98469: LD_VAR 0 8
98473: PLUS
98474: STR
98475: PUSH
98476: LD_STRING ;
98478: STR
98479: ST_TO_ADDR
// end ;
98480: GO 98435
98482: POP
98483: POP
// if tmp then
98484: LD_VAR 0 3
98488: IFFALSE 98500
// active := tmp ;
98490: LD_ADDR_VAR 0 7
98494: PUSH
98495: LD_VAR 0 3
98499: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
98500: LD_STRING getStreamItemsFromMission("
98502: PUSH
98503: LD_VAR 0 5
98507: STR
98508: PUSH
98509: LD_STRING ","
98511: STR
98512: PUSH
98513: LD_VAR 0 6
98517: STR
98518: PUSH
98519: LD_STRING ","
98521: STR
98522: PUSH
98523: LD_VAR 0 7
98527: STR
98528: PUSH
98529: LD_STRING ")
98531: STR
98532: PPUSH
98533: CALL_OW 559
// end else
98537: GO 98546
// ToLua ( getStreamItemsFromMission("","","") ) ;
98539: LD_STRING getStreamItemsFromMission("","","")
98541: PPUSH
98542: CALL_OW 559
// end ;
98546: LD_VAR 0 2
98550: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98551: LD_EXP 140
98555: PUSH
98556: LD_EXP 145
98560: AND
98561: IFFALSE 98685
98563: GO 98565
98565: DISABLE
98566: LD_INT 0
98568: PPUSH
98569: PPUSH
// begin enable ;
98570: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98571: LD_ADDR_VAR 0 2
98575: PUSH
98576: LD_INT 22
98578: PUSH
98579: LD_OWVAR 2
98583: PUSH
98584: EMPTY
98585: LIST
98586: LIST
98587: PUSH
98588: LD_INT 2
98590: PUSH
98591: LD_INT 34
98593: PUSH
98594: LD_INT 7
98596: PUSH
98597: EMPTY
98598: LIST
98599: LIST
98600: PUSH
98601: LD_INT 34
98603: PUSH
98604: LD_INT 45
98606: PUSH
98607: EMPTY
98608: LIST
98609: LIST
98610: PUSH
98611: LD_INT 34
98613: PUSH
98614: LD_INT 28
98616: PUSH
98617: EMPTY
98618: LIST
98619: LIST
98620: PUSH
98621: LD_INT 34
98623: PUSH
98624: LD_INT 47
98626: PUSH
98627: EMPTY
98628: LIST
98629: LIST
98630: PUSH
98631: EMPTY
98632: LIST
98633: LIST
98634: LIST
98635: LIST
98636: LIST
98637: PUSH
98638: EMPTY
98639: LIST
98640: LIST
98641: PPUSH
98642: CALL_OW 69
98646: ST_TO_ADDR
// if not tmp then
98647: LD_VAR 0 2
98651: NOT
98652: IFFALSE 98656
// exit ;
98654: GO 98685
// for i in tmp do
98656: LD_ADDR_VAR 0 1
98660: PUSH
98661: LD_VAR 0 2
98665: PUSH
98666: FOR_IN
98667: IFFALSE 98683
// begin SetLives ( i , 0 ) ;
98669: LD_VAR 0 1
98673: PPUSH
98674: LD_INT 0
98676: PPUSH
98677: CALL_OW 234
// end ;
98681: GO 98666
98683: POP
98684: POP
// end ;
98685: PPOPN 2
98687: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98688: LD_EXP 140
98692: PUSH
98693: LD_EXP 146
98697: AND
98698: IFFALSE 98782
98700: GO 98702
98702: DISABLE
98703: LD_INT 0
98705: PPUSH
98706: PPUSH
// begin enable ;
98707: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98708: LD_ADDR_VAR 0 2
98712: PUSH
98713: LD_INT 22
98715: PUSH
98716: LD_OWVAR 2
98720: PUSH
98721: EMPTY
98722: LIST
98723: LIST
98724: PUSH
98725: LD_INT 32
98727: PUSH
98728: LD_INT 3
98730: PUSH
98731: EMPTY
98732: LIST
98733: LIST
98734: PUSH
98735: EMPTY
98736: LIST
98737: LIST
98738: PPUSH
98739: CALL_OW 69
98743: ST_TO_ADDR
// if not tmp then
98744: LD_VAR 0 2
98748: NOT
98749: IFFALSE 98753
// exit ;
98751: GO 98782
// for i in tmp do
98753: LD_ADDR_VAR 0 1
98757: PUSH
98758: LD_VAR 0 2
98762: PUSH
98763: FOR_IN
98764: IFFALSE 98780
// begin SetLives ( i , 0 ) ;
98766: LD_VAR 0 1
98770: PPUSH
98771: LD_INT 0
98773: PPUSH
98774: CALL_OW 234
// end ;
98778: GO 98763
98780: POP
98781: POP
// end ;
98782: PPOPN 2
98784: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98785: LD_EXP 140
98789: PUSH
98790: LD_EXP 143
98794: AND
98795: IFFALSE 98888
98797: GO 98799
98799: DISABLE
98800: LD_INT 0
98802: PPUSH
// begin enable ;
98803: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98804: LD_ADDR_VAR 0 1
98808: PUSH
98809: LD_INT 22
98811: PUSH
98812: LD_OWVAR 2
98816: PUSH
98817: EMPTY
98818: LIST
98819: LIST
98820: PUSH
98821: LD_INT 2
98823: PUSH
98824: LD_INT 25
98826: PUSH
98827: LD_INT 5
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: PUSH
98834: LD_INT 25
98836: PUSH
98837: LD_INT 9
98839: PUSH
98840: EMPTY
98841: LIST
98842: LIST
98843: PUSH
98844: LD_INT 25
98846: PUSH
98847: LD_INT 8
98849: PUSH
98850: EMPTY
98851: LIST
98852: LIST
98853: PUSH
98854: EMPTY
98855: LIST
98856: LIST
98857: LIST
98858: LIST
98859: PUSH
98860: EMPTY
98861: LIST
98862: LIST
98863: PPUSH
98864: CALL_OW 69
98868: PUSH
98869: FOR_IN
98870: IFFALSE 98886
// begin SetClass ( i , 1 ) ;
98872: LD_VAR 0 1
98876: PPUSH
98877: LD_INT 1
98879: PPUSH
98880: CALL_OW 336
// end ;
98884: GO 98869
98886: POP
98887: POP
// end ;
98888: PPOPN 1
98890: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98891: LD_EXP 140
98895: PUSH
98896: LD_EXP 144
98900: AND
98901: PUSH
98902: LD_OWVAR 65
98906: PUSH
98907: LD_INT 7
98909: LESS
98910: AND
98911: IFFALSE 98925
98913: GO 98915
98915: DISABLE
// begin enable ;
98916: ENABLE
// game_speed := 7 ;
98917: LD_ADDR_OWVAR 65
98921: PUSH
98922: LD_INT 7
98924: ST_TO_ADDR
// end ;
98925: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98926: LD_EXP 140
98930: PUSH
98931: LD_EXP 147
98935: AND
98936: IFFALSE 99138
98938: GO 98940
98940: DISABLE
98941: LD_INT 0
98943: PPUSH
98944: PPUSH
98945: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98946: LD_ADDR_VAR 0 3
98950: PUSH
98951: LD_INT 81
98953: PUSH
98954: LD_OWVAR 2
98958: PUSH
98959: EMPTY
98960: LIST
98961: LIST
98962: PUSH
98963: LD_INT 21
98965: PUSH
98966: LD_INT 1
98968: PUSH
98969: EMPTY
98970: LIST
98971: LIST
98972: PUSH
98973: EMPTY
98974: LIST
98975: LIST
98976: PPUSH
98977: CALL_OW 69
98981: ST_TO_ADDR
// if not tmp then
98982: LD_VAR 0 3
98986: NOT
98987: IFFALSE 98991
// exit ;
98989: GO 99138
// if tmp > 5 then
98991: LD_VAR 0 3
98995: PUSH
98996: LD_INT 5
98998: GREATER
98999: IFFALSE 99011
// k := 5 else
99001: LD_ADDR_VAR 0 2
99005: PUSH
99006: LD_INT 5
99008: ST_TO_ADDR
99009: GO 99021
// k := tmp ;
99011: LD_ADDR_VAR 0 2
99015: PUSH
99016: LD_VAR 0 3
99020: ST_TO_ADDR
// for i := 1 to k do
99021: LD_ADDR_VAR 0 1
99025: PUSH
99026: DOUBLE
99027: LD_INT 1
99029: DEC
99030: ST_TO_ADDR
99031: LD_VAR 0 2
99035: PUSH
99036: FOR_TO
99037: IFFALSE 99136
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
99039: LD_VAR 0 3
99043: PUSH
99044: LD_VAR 0 1
99048: ARRAY
99049: PPUSH
99050: LD_VAR 0 1
99054: PUSH
99055: LD_INT 4
99057: MOD
99058: PUSH
99059: LD_INT 1
99061: PLUS
99062: PPUSH
99063: CALL_OW 259
99067: PUSH
99068: LD_INT 10
99070: LESS
99071: IFFALSE 99134
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99073: LD_VAR 0 3
99077: PUSH
99078: LD_VAR 0 1
99082: ARRAY
99083: PPUSH
99084: LD_VAR 0 1
99088: PUSH
99089: LD_INT 4
99091: MOD
99092: PUSH
99093: LD_INT 1
99095: PLUS
99096: PPUSH
99097: LD_VAR 0 3
99101: PUSH
99102: LD_VAR 0 1
99106: ARRAY
99107: PPUSH
99108: LD_VAR 0 1
99112: PUSH
99113: LD_INT 4
99115: MOD
99116: PUSH
99117: LD_INT 1
99119: PLUS
99120: PPUSH
99121: CALL_OW 259
99125: PUSH
99126: LD_INT 1
99128: PLUS
99129: PPUSH
99130: CALL_OW 237
99134: GO 99036
99136: POP
99137: POP
// end ;
99138: PPOPN 3
99140: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99141: LD_EXP 140
99145: PUSH
99146: LD_EXP 148
99150: AND
99151: IFFALSE 99171
99153: GO 99155
99155: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99156: LD_INT 4
99158: PPUSH
99159: LD_OWVAR 2
99163: PPUSH
99164: LD_INT 0
99166: PPUSH
99167: CALL_OW 324
99171: END
// every 0 0$1 trigger StreamModeActive and sShovel do
99172: LD_EXP 140
99176: PUSH
99177: LD_EXP 177
99181: AND
99182: IFFALSE 99202
99184: GO 99186
99186: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
99187: LD_INT 19
99189: PPUSH
99190: LD_OWVAR 2
99194: PPUSH
99195: LD_INT 0
99197: PPUSH
99198: CALL_OW 324
99202: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
99203: LD_EXP 140
99207: PUSH
99208: LD_EXP 149
99212: AND
99213: IFFALSE 99315
99215: GO 99217
99217: DISABLE
99218: LD_INT 0
99220: PPUSH
99221: PPUSH
// begin enable ;
99222: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
99223: LD_ADDR_VAR 0 2
99227: PUSH
99228: LD_INT 22
99230: PUSH
99231: LD_OWVAR 2
99235: PUSH
99236: EMPTY
99237: LIST
99238: LIST
99239: PUSH
99240: LD_INT 2
99242: PUSH
99243: LD_INT 34
99245: PUSH
99246: LD_INT 11
99248: PUSH
99249: EMPTY
99250: LIST
99251: LIST
99252: PUSH
99253: LD_INT 34
99255: PUSH
99256: LD_INT 30
99258: PUSH
99259: EMPTY
99260: LIST
99261: LIST
99262: PUSH
99263: EMPTY
99264: LIST
99265: LIST
99266: LIST
99267: PUSH
99268: EMPTY
99269: LIST
99270: LIST
99271: PPUSH
99272: CALL_OW 69
99276: ST_TO_ADDR
// if not tmp then
99277: LD_VAR 0 2
99281: NOT
99282: IFFALSE 99286
// exit ;
99284: GO 99315
// for i in tmp do
99286: LD_ADDR_VAR 0 1
99290: PUSH
99291: LD_VAR 0 2
99295: PUSH
99296: FOR_IN
99297: IFFALSE 99313
// begin SetLives ( i , 0 ) ;
99299: LD_VAR 0 1
99303: PPUSH
99304: LD_INT 0
99306: PPUSH
99307: CALL_OW 234
// end ;
99311: GO 99296
99313: POP
99314: POP
// end ;
99315: PPOPN 2
99317: END
// every 0 0$1 trigger StreamModeActive and sBunker do
99318: LD_EXP 140
99322: PUSH
99323: LD_EXP 150
99327: AND
99328: IFFALSE 99348
99330: GO 99332
99332: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
99333: LD_INT 32
99335: PPUSH
99336: LD_OWVAR 2
99340: PPUSH
99341: LD_INT 0
99343: PPUSH
99344: CALL_OW 324
99348: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
99349: LD_EXP 140
99353: PUSH
99354: LD_EXP 151
99358: AND
99359: IFFALSE 99540
99361: GO 99363
99363: DISABLE
99364: LD_INT 0
99366: PPUSH
99367: PPUSH
99368: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99369: LD_ADDR_VAR 0 2
99373: PUSH
99374: LD_INT 22
99376: PUSH
99377: LD_OWVAR 2
99381: PUSH
99382: EMPTY
99383: LIST
99384: LIST
99385: PUSH
99386: LD_INT 33
99388: PUSH
99389: LD_INT 3
99391: PUSH
99392: EMPTY
99393: LIST
99394: LIST
99395: PUSH
99396: EMPTY
99397: LIST
99398: LIST
99399: PPUSH
99400: CALL_OW 69
99404: ST_TO_ADDR
// if not tmp then
99405: LD_VAR 0 2
99409: NOT
99410: IFFALSE 99414
// exit ;
99412: GO 99540
// side := 0 ;
99414: LD_ADDR_VAR 0 3
99418: PUSH
99419: LD_INT 0
99421: ST_TO_ADDR
// for i := 1 to 8 do
99422: LD_ADDR_VAR 0 1
99426: PUSH
99427: DOUBLE
99428: LD_INT 1
99430: DEC
99431: ST_TO_ADDR
99432: LD_INT 8
99434: PUSH
99435: FOR_TO
99436: IFFALSE 99484
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99438: LD_OWVAR 2
99442: PUSH
99443: LD_VAR 0 1
99447: NONEQUAL
99448: PUSH
99449: LD_OWVAR 2
99453: PPUSH
99454: LD_VAR 0 1
99458: PPUSH
99459: CALL_OW 81
99463: PUSH
99464: LD_INT 2
99466: EQUAL
99467: AND
99468: IFFALSE 99482
// begin side := i ;
99470: LD_ADDR_VAR 0 3
99474: PUSH
99475: LD_VAR 0 1
99479: ST_TO_ADDR
// break ;
99480: GO 99484
// end ;
99482: GO 99435
99484: POP
99485: POP
// if not side then
99486: LD_VAR 0 3
99490: NOT
99491: IFFALSE 99495
// exit ;
99493: GO 99540
// for i := 1 to tmp do
99495: LD_ADDR_VAR 0 1
99499: PUSH
99500: DOUBLE
99501: LD_INT 1
99503: DEC
99504: ST_TO_ADDR
99505: LD_VAR 0 2
99509: PUSH
99510: FOR_TO
99511: IFFALSE 99538
// if Prob ( 60 ) then
99513: LD_INT 60
99515: PPUSH
99516: CALL_OW 13
99520: IFFALSE 99536
// SetSide ( i , side ) ;
99522: LD_VAR 0 1
99526: PPUSH
99527: LD_VAR 0 3
99531: PPUSH
99532: CALL_OW 235
99536: GO 99510
99538: POP
99539: POP
// end ;
99540: PPOPN 3
99542: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99543: LD_EXP 140
99547: PUSH
99548: LD_EXP 153
99552: AND
99553: IFFALSE 99672
99555: GO 99557
99557: DISABLE
99558: LD_INT 0
99560: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99561: LD_ADDR_VAR 0 1
99565: PUSH
99566: LD_INT 22
99568: PUSH
99569: LD_OWVAR 2
99573: PUSH
99574: EMPTY
99575: LIST
99576: LIST
99577: PUSH
99578: LD_INT 21
99580: PUSH
99581: LD_INT 1
99583: PUSH
99584: EMPTY
99585: LIST
99586: LIST
99587: PUSH
99588: LD_INT 3
99590: PUSH
99591: LD_INT 23
99593: PUSH
99594: LD_INT 0
99596: PUSH
99597: EMPTY
99598: LIST
99599: LIST
99600: PUSH
99601: EMPTY
99602: LIST
99603: LIST
99604: PUSH
99605: EMPTY
99606: LIST
99607: LIST
99608: LIST
99609: PPUSH
99610: CALL_OW 69
99614: PUSH
99615: FOR_IN
99616: IFFALSE 99670
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99618: LD_VAR 0 1
99622: PPUSH
99623: CALL_OW 257
99627: PUSH
99628: LD_INT 1
99630: PUSH
99631: LD_INT 2
99633: PUSH
99634: LD_INT 3
99636: PUSH
99637: LD_INT 4
99639: PUSH
99640: EMPTY
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: IN
99646: IFFALSE 99668
// SetClass ( un , rand ( 1 , 4 ) ) ;
99648: LD_VAR 0 1
99652: PPUSH
99653: LD_INT 1
99655: PPUSH
99656: LD_INT 4
99658: PPUSH
99659: CALL_OW 12
99663: PPUSH
99664: CALL_OW 336
99668: GO 99615
99670: POP
99671: POP
// end ;
99672: PPOPN 1
99674: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99675: LD_EXP 140
99679: PUSH
99680: LD_EXP 152
99684: AND
99685: IFFALSE 99764
99687: GO 99689
99689: DISABLE
99690: LD_INT 0
99692: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99693: LD_ADDR_VAR 0 1
99697: PUSH
99698: LD_INT 22
99700: PUSH
99701: LD_OWVAR 2
99705: PUSH
99706: EMPTY
99707: LIST
99708: LIST
99709: PUSH
99710: LD_INT 21
99712: PUSH
99713: LD_INT 3
99715: PUSH
99716: EMPTY
99717: LIST
99718: LIST
99719: PUSH
99720: EMPTY
99721: LIST
99722: LIST
99723: PPUSH
99724: CALL_OW 69
99728: ST_TO_ADDR
// if not tmp then
99729: LD_VAR 0 1
99733: NOT
99734: IFFALSE 99738
// exit ;
99736: GO 99764
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99738: LD_VAR 0 1
99742: PUSH
99743: LD_INT 1
99745: PPUSH
99746: LD_VAR 0 1
99750: PPUSH
99751: CALL_OW 12
99755: ARRAY
99756: PPUSH
99757: LD_INT 100
99759: PPUSH
99760: CALL_OW 234
// end ;
99764: PPOPN 1
99766: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99767: LD_EXP 140
99771: PUSH
99772: LD_EXP 154
99776: AND
99777: IFFALSE 99875
99779: GO 99781
99781: DISABLE
99782: LD_INT 0
99784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99785: LD_ADDR_VAR 0 1
99789: PUSH
99790: LD_INT 22
99792: PUSH
99793: LD_OWVAR 2
99797: PUSH
99798: EMPTY
99799: LIST
99800: LIST
99801: PUSH
99802: LD_INT 21
99804: PUSH
99805: LD_INT 1
99807: PUSH
99808: EMPTY
99809: LIST
99810: LIST
99811: PUSH
99812: EMPTY
99813: LIST
99814: LIST
99815: PPUSH
99816: CALL_OW 69
99820: ST_TO_ADDR
// if not tmp then
99821: LD_VAR 0 1
99825: NOT
99826: IFFALSE 99830
// exit ;
99828: GO 99875
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99830: LD_VAR 0 1
99834: PUSH
99835: LD_INT 1
99837: PPUSH
99838: LD_VAR 0 1
99842: PPUSH
99843: CALL_OW 12
99847: ARRAY
99848: PPUSH
99849: LD_INT 1
99851: PPUSH
99852: LD_INT 4
99854: PPUSH
99855: CALL_OW 12
99859: PPUSH
99860: LD_INT 3000
99862: PPUSH
99863: LD_INT 9000
99865: PPUSH
99866: CALL_OW 12
99870: PPUSH
99871: CALL_OW 492
// end ;
99875: PPOPN 1
99877: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99878: LD_EXP 140
99882: PUSH
99883: LD_EXP 155
99887: AND
99888: IFFALSE 99908
99890: GO 99892
99892: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99893: LD_INT 1
99895: PPUSH
99896: LD_OWVAR 2
99900: PPUSH
99901: LD_INT 0
99903: PPUSH
99904: CALL_OW 324
99908: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99909: LD_EXP 140
99913: PUSH
99914: LD_EXP 156
99918: AND
99919: IFFALSE 100002
99921: GO 99923
99923: DISABLE
99924: LD_INT 0
99926: PPUSH
99927: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99928: LD_ADDR_VAR 0 2
99932: PUSH
99933: LD_INT 22
99935: PUSH
99936: LD_OWVAR 2
99940: PUSH
99941: EMPTY
99942: LIST
99943: LIST
99944: PUSH
99945: LD_INT 21
99947: PUSH
99948: LD_INT 3
99950: PUSH
99951: EMPTY
99952: LIST
99953: LIST
99954: PUSH
99955: EMPTY
99956: LIST
99957: LIST
99958: PPUSH
99959: CALL_OW 69
99963: ST_TO_ADDR
// if not tmp then
99964: LD_VAR 0 2
99968: NOT
99969: IFFALSE 99973
// exit ;
99971: GO 100002
// for i in tmp do
99973: LD_ADDR_VAR 0 1
99977: PUSH
99978: LD_VAR 0 2
99982: PUSH
99983: FOR_IN
99984: IFFALSE 100000
// SetBLevel ( i , 10 ) ;
99986: LD_VAR 0 1
99990: PPUSH
99991: LD_INT 10
99993: PPUSH
99994: CALL_OW 241
99998: GO 99983
100000: POP
100001: POP
// end ;
100002: PPOPN 2
100004: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100005: LD_EXP 140
100009: PUSH
100010: LD_EXP 157
100014: AND
100015: IFFALSE 100126
100017: GO 100019
100019: DISABLE
100020: LD_INT 0
100022: PPUSH
100023: PPUSH
100024: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100025: LD_ADDR_VAR 0 3
100029: PUSH
100030: LD_INT 22
100032: PUSH
100033: LD_OWVAR 2
100037: PUSH
100038: EMPTY
100039: LIST
100040: LIST
100041: PUSH
100042: LD_INT 25
100044: PUSH
100045: LD_INT 1
100047: PUSH
100048: EMPTY
100049: LIST
100050: LIST
100051: PUSH
100052: EMPTY
100053: LIST
100054: LIST
100055: PPUSH
100056: CALL_OW 69
100060: ST_TO_ADDR
// if not tmp then
100061: LD_VAR 0 3
100065: NOT
100066: IFFALSE 100070
// exit ;
100068: GO 100126
// un := tmp [ rand ( 1 , tmp ) ] ;
100070: LD_ADDR_VAR 0 2
100074: PUSH
100075: LD_VAR 0 3
100079: PUSH
100080: LD_INT 1
100082: PPUSH
100083: LD_VAR 0 3
100087: PPUSH
100088: CALL_OW 12
100092: ARRAY
100093: ST_TO_ADDR
// if Crawls ( un ) then
100094: LD_VAR 0 2
100098: PPUSH
100099: CALL_OW 318
100103: IFFALSE 100114
// ComWalk ( un ) ;
100105: LD_VAR 0 2
100109: PPUSH
100110: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100114: LD_VAR 0 2
100118: PPUSH
100119: LD_INT 5
100121: PPUSH
100122: CALL_OW 336
// end ;
100126: PPOPN 3
100128: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
100129: LD_EXP 140
100133: PUSH
100134: LD_EXP 158
100138: AND
100139: PUSH
100140: LD_OWVAR 67
100144: PUSH
100145: LD_INT 4
100147: LESS
100148: AND
100149: IFFALSE 100168
100151: GO 100153
100153: DISABLE
// begin Difficulty := Difficulty + 1 ;
100154: LD_ADDR_OWVAR 67
100158: PUSH
100159: LD_OWVAR 67
100163: PUSH
100164: LD_INT 1
100166: PLUS
100167: ST_TO_ADDR
// end ;
100168: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
100169: LD_EXP 140
100173: PUSH
100174: LD_EXP 159
100178: AND
100179: IFFALSE 100282
100181: GO 100183
100183: DISABLE
100184: LD_INT 0
100186: PPUSH
// begin for i := 1 to 5 do
100187: LD_ADDR_VAR 0 1
100191: PUSH
100192: DOUBLE
100193: LD_INT 1
100195: DEC
100196: ST_TO_ADDR
100197: LD_INT 5
100199: PUSH
100200: FOR_TO
100201: IFFALSE 100280
// begin uc_nation := nation_nature ;
100203: LD_ADDR_OWVAR 21
100207: PUSH
100208: LD_INT 0
100210: ST_TO_ADDR
// uc_side := 0 ;
100211: LD_ADDR_OWVAR 20
100215: PUSH
100216: LD_INT 0
100218: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100219: LD_ADDR_OWVAR 29
100223: PUSH
100224: LD_INT 12
100226: PUSH
100227: LD_INT 12
100229: PUSH
100230: EMPTY
100231: LIST
100232: LIST
100233: ST_TO_ADDR
// hc_agressivity := 20 ;
100234: LD_ADDR_OWVAR 35
100238: PUSH
100239: LD_INT 20
100241: ST_TO_ADDR
// hc_class := class_tiger ;
100242: LD_ADDR_OWVAR 28
100246: PUSH
100247: LD_INT 14
100249: ST_TO_ADDR
// hc_gallery :=  ;
100250: LD_ADDR_OWVAR 33
100254: PUSH
100255: LD_STRING 
100257: ST_TO_ADDR
// hc_name :=  ;
100258: LD_ADDR_OWVAR 26
100262: PUSH
100263: LD_STRING 
100265: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
100266: CALL_OW 44
100270: PPUSH
100271: LD_INT 0
100273: PPUSH
100274: CALL_OW 51
// end ;
100278: GO 100200
100280: POP
100281: POP
// end ;
100282: PPOPN 1
100284: END
// every 0 0$1 trigger StreamModeActive and sBomb do
100285: LD_EXP 140
100289: PUSH
100290: LD_EXP 160
100294: AND
100295: IFFALSE 100304
100297: GO 100299
100299: DISABLE
// StreamSibBomb ;
100300: CALL 100305 0 0
100304: END
// export function StreamSibBomb ; var i , x , y ; begin
100305: LD_INT 0
100307: PPUSH
100308: PPUSH
100309: PPUSH
100310: PPUSH
// result := false ;
100311: LD_ADDR_VAR 0 1
100315: PUSH
100316: LD_INT 0
100318: ST_TO_ADDR
// for i := 1 to 16 do
100319: LD_ADDR_VAR 0 2
100323: PUSH
100324: DOUBLE
100325: LD_INT 1
100327: DEC
100328: ST_TO_ADDR
100329: LD_INT 16
100331: PUSH
100332: FOR_TO
100333: IFFALSE 100532
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100335: LD_ADDR_VAR 0 3
100339: PUSH
100340: LD_INT 10
100342: PUSH
100343: LD_INT 20
100345: PUSH
100346: LD_INT 30
100348: PUSH
100349: LD_INT 40
100351: PUSH
100352: LD_INT 50
100354: PUSH
100355: LD_INT 60
100357: PUSH
100358: LD_INT 70
100360: PUSH
100361: LD_INT 80
100363: PUSH
100364: LD_INT 90
100366: PUSH
100367: LD_INT 100
100369: PUSH
100370: LD_INT 110
100372: PUSH
100373: LD_INT 120
100375: PUSH
100376: LD_INT 130
100378: PUSH
100379: LD_INT 140
100381: PUSH
100382: LD_INT 150
100384: PUSH
100385: EMPTY
100386: LIST
100387: LIST
100388: LIST
100389: LIST
100390: LIST
100391: LIST
100392: LIST
100393: LIST
100394: LIST
100395: LIST
100396: LIST
100397: LIST
100398: LIST
100399: LIST
100400: LIST
100401: PUSH
100402: LD_INT 1
100404: PPUSH
100405: LD_INT 15
100407: PPUSH
100408: CALL_OW 12
100412: ARRAY
100413: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100414: LD_ADDR_VAR 0 4
100418: PUSH
100419: LD_INT 10
100421: PUSH
100422: LD_INT 20
100424: PUSH
100425: LD_INT 30
100427: PUSH
100428: LD_INT 40
100430: PUSH
100431: LD_INT 50
100433: PUSH
100434: LD_INT 60
100436: PUSH
100437: LD_INT 70
100439: PUSH
100440: LD_INT 80
100442: PUSH
100443: LD_INT 90
100445: PUSH
100446: LD_INT 100
100448: PUSH
100449: LD_INT 110
100451: PUSH
100452: LD_INT 120
100454: PUSH
100455: LD_INT 130
100457: PUSH
100458: LD_INT 140
100460: PUSH
100461: LD_INT 150
100463: PUSH
100464: EMPTY
100465: LIST
100466: LIST
100467: LIST
100468: LIST
100469: LIST
100470: LIST
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: PUSH
100481: LD_INT 1
100483: PPUSH
100484: LD_INT 15
100486: PPUSH
100487: CALL_OW 12
100491: ARRAY
100492: ST_TO_ADDR
// if ValidHex ( x , y ) then
100493: LD_VAR 0 3
100497: PPUSH
100498: LD_VAR 0 4
100502: PPUSH
100503: CALL_OW 488
100507: IFFALSE 100530
// begin result := [ x , y ] ;
100509: LD_ADDR_VAR 0 1
100513: PUSH
100514: LD_VAR 0 3
100518: PUSH
100519: LD_VAR 0 4
100523: PUSH
100524: EMPTY
100525: LIST
100526: LIST
100527: ST_TO_ADDR
// break ;
100528: GO 100532
// end ; end ;
100530: GO 100332
100532: POP
100533: POP
// if result then
100534: LD_VAR 0 1
100538: IFFALSE 100598
// begin ToLua ( playSibBomb() ) ;
100540: LD_STRING playSibBomb()
100542: PPUSH
100543: CALL_OW 559
// wait ( 0 0$14 ) ;
100547: LD_INT 490
100549: PPUSH
100550: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100554: LD_VAR 0 1
100558: PUSH
100559: LD_INT 1
100561: ARRAY
100562: PPUSH
100563: LD_VAR 0 1
100567: PUSH
100568: LD_INT 2
100570: ARRAY
100571: PPUSH
100572: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100576: LD_VAR 0 1
100580: PUSH
100581: LD_INT 1
100583: ARRAY
100584: PPUSH
100585: LD_VAR 0 1
100589: PUSH
100590: LD_INT 2
100592: ARRAY
100593: PPUSH
100594: CALL_OW 429
// end ; end ;
100598: LD_VAR 0 1
100602: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100603: LD_EXP 140
100607: PUSH
100608: LD_EXP 162
100612: AND
100613: IFFALSE 100625
100615: GO 100617
100617: DISABLE
// YouLost (  ) ;
100618: LD_STRING 
100620: PPUSH
100621: CALL_OW 104
100625: END
// every 0 0$1 trigger StreamModeActive and sFog do
100626: LD_EXP 140
100630: PUSH
100631: LD_EXP 161
100635: AND
100636: IFFALSE 100650
100638: GO 100640
100640: DISABLE
// FogOff ( your_side ) ;
100641: LD_OWVAR 2
100645: PPUSH
100646: CALL_OW 344
100650: END
// every 0 0$1 trigger StreamModeActive and sSun do
100651: LD_EXP 140
100655: PUSH
100656: LD_EXP 163
100660: AND
100661: IFFALSE 100689
100663: GO 100665
100665: DISABLE
// begin solar_recharge_percent := 0 ;
100666: LD_ADDR_OWVAR 79
100670: PUSH
100671: LD_INT 0
100673: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100674: LD_INT 10500
100676: PPUSH
100677: CALL_OW 67
// solar_recharge_percent := 100 ;
100681: LD_ADDR_OWVAR 79
100685: PUSH
100686: LD_INT 100
100688: ST_TO_ADDR
// end ;
100689: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100690: LD_EXP 140
100694: PUSH
100695: LD_EXP 164
100699: AND
100700: IFFALSE 100939
100702: GO 100704
100704: DISABLE
100705: LD_INT 0
100707: PPUSH
100708: PPUSH
100709: PPUSH
// begin tmp := [ ] ;
100710: LD_ADDR_VAR 0 3
100714: PUSH
100715: EMPTY
100716: ST_TO_ADDR
// for i := 1 to 6 do
100717: LD_ADDR_VAR 0 1
100721: PUSH
100722: DOUBLE
100723: LD_INT 1
100725: DEC
100726: ST_TO_ADDR
100727: LD_INT 6
100729: PUSH
100730: FOR_TO
100731: IFFALSE 100836
// begin uc_nation := nation_nature ;
100733: LD_ADDR_OWVAR 21
100737: PUSH
100738: LD_INT 0
100740: ST_TO_ADDR
// uc_side := 0 ;
100741: LD_ADDR_OWVAR 20
100745: PUSH
100746: LD_INT 0
100748: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100749: LD_ADDR_OWVAR 29
100753: PUSH
100754: LD_INT 12
100756: PUSH
100757: LD_INT 12
100759: PUSH
100760: EMPTY
100761: LIST
100762: LIST
100763: ST_TO_ADDR
// hc_agressivity := 20 ;
100764: LD_ADDR_OWVAR 35
100768: PUSH
100769: LD_INT 20
100771: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100772: LD_ADDR_OWVAR 28
100776: PUSH
100777: LD_INT 17
100779: ST_TO_ADDR
// hc_gallery :=  ;
100780: LD_ADDR_OWVAR 33
100784: PUSH
100785: LD_STRING 
100787: ST_TO_ADDR
// hc_name :=  ;
100788: LD_ADDR_OWVAR 26
100792: PUSH
100793: LD_STRING 
100795: ST_TO_ADDR
// un := CreateHuman ;
100796: LD_ADDR_VAR 0 2
100800: PUSH
100801: CALL_OW 44
100805: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100806: LD_VAR 0 2
100810: PPUSH
100811: LD_INT 1
100813: PPUSH
100814: CALL_OW 51
// tmp := tmp ^ un ;
100818: LD_ADDR_VAR 0 3
100822: PUSH
100823: LD_VAR 0 3
100827: PUSH
100828: LD_VAR 0 2
100832: ADD
100833: ST_TO_ADDR
// end ;
100834: GO 100730
100836: POP
100837: POP
// repeat wait ( 0 0$1 ) ;
100838: LD_INT 35
100840: PPUSH
100841: CALL_OW 67
// for un in tmp do
100845: LD_ADDR_VAR 0 2
100849: PUSH
100850: LD_VAR 0 3
100854: PUSH
100855: FOR_IN
100856: IFFALSE 100930
// begin if IsDead ( un ) then
100858: LD_VAR 0 2
100862: PPUSH
100863: CALL_OW 301
100867: IFFALSE 100887
// begin tmp := tmp diff un ;
100869: LD_ADDR_VAR 0 3
100873: PUSH
100874: LD_VAR 0 3
100878: PUSH
100879: LD_VAR 0 2
100883: DIFF
100884: ST_TO_ADDR
// continue ;
100885: GO 100855
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100887: LD_VAR 0 2
100891: PPUSH
100892: LD_INT 3
100894: PUSH
100895: LD_INT 22
100897: PUSH
100898: LD_INT 0
100900: PUSH
100901: EMPTY
100902: LIST
100903: LIST
100904: PUSH
100905: EMPTY
100906: LIST
100907: LIST
100908: PPUSH
100909: CALL_OW 69
100913: PPUSH
100914: LD_VAR 0 2
100918: PPUSH
100919: CALL_OW 74
100923: PPUSH
100924: CALL_OW 115
// end ;
100928: GO 100855
100930: POP
100931: POP
// until not tmp ;
100932: LD_VAR 0 3
100936: NOT
100937: IFFALSE 100838
// end ;
100939: PPOPN 3
100941: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100942: LD_EXP 140
100946: PUSH
100947: LD_EXP 165
100951: AND
100952: IFFALSE 101006
100954: GO 100956
100956: DISABLE
// begin ToLua ( displayTroll(); ) ;
100957: LD_STRING displayTroll();
100959: PPUSH
100960: CALL_OW 559
// wait ( 3 3$00 ) ;
100964: LD_INT 6300
100966: PPUSH
100967: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100971: LD_STRING hideTroll();
100973: PPUSH
100974: CALL_OW 559
// wait ( 1 1$00 ) ;
100978: LD_INT 2100
100980: PPUSH
100981: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100985: LD_STRING displayTroll();
100987: PPUSH
100988: CALL_OW 559
// wait ( 1 1$00 ) ;
100992: LD_INT 2100
100994: PPUSH
100995: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100999: LD_STRING hideTroll();
101001: PPUSH
101002: CALL_OW 559
// end ;
101006: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101007: LD_EXP 140
101011: PUSH
101012: LD_EXP 166
101016: AND
101017: IFFALSE 101080
101019: GO 101021
101021: DISABLE
101022: LD_INT 0
101024: PPUSH
// begin p := 0 ;
101025: LD_ADDR_VAR 0 1
101029: PUSH
101030: LD_INT 0
101032: ST_TO_ADDR
// repeat game_speed := 1 ;
101033: LD_ADDR_OWVAR 65
101037: PUSH
101038: LD_INT 1
101040: ST_TO_ADDR
// wait ( 0 0$1 ) ;
101041: LD_INT 35
101043: PPUSH
101044: CALL_OW 67
// p := p + 1 ;
101048: LD_ADDR_VAR 0 1
101052: PUSH
101053: LD_VAR 0 1
101057: PUSH
101058: LD_INT 1
101060: PLUS
101061: ST_TO_ADDR
// until p >= 60 ;
101062: LD_VAR 0 1
101066: PUSH
101067: LD_INT 60
101069: GREATEREQUAL
101070: IFFALSE 101033
// game_speed := 4 ;
101072: LD_ADDR_OWVAR 65
101076: PUSH
101077: LD_INT 4
101079: ST_TO_ADDR
// end ;
101080: PPOPN 1
101082: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101083: LD_EXP 140
101087: PUSH
101088: LD_EXP 167
101092: AND
101093: IFFALSE 101239
101095: GO 101097
101097: DISABLE
101098: LD_INT 0
101100: PPUSH
101101: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101102: LD_ADDR_VAR 0 1
101106: PUSH
101107: LD_INT 22
101109: PUSH
101110: LD_OWVAR 2
101114: PUSH
101115: EMPTY
101116: LIST
101117: LIST
101118: PUSH
101119: LD_INT 2
101121: PUSH
101122: LD_INT 30
101124: PUSH
101125: LD_INT 0
101127: PUSH
101128: EMPTY
101129: LIST
101130: LIST
101131: PUSH
101132: LD_INT 30
101134: PUSH
101135: LD_INT 1
101137: PUSH
101138: EMPTY
101139: LIST
101140: LIST
101141: PUSH
101142: EMPTY
101143: LIST
101144: LIST
101145: LIST
101146: PUSH
101147: EMPTY
101148: LIST
101149: LIST
101150: PPUSH
101151: CALL_OW 69
101155: ST_TO_ADDR
// if not depot then
101156: LD_VAR 0 1
101160: NOT
101161: IFFALSE 101165
// exit ;
101163: GO 101239
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
101165: LD_ADDR_VAR 0 2
101169: PUSH
101170: LD_VAR 0 1
101174: PUSH
101175: LD_INT 1
101177: PPUSH
101178: LD_VAR 0 1
101182: PPUSH
101183: CALL_OW 12
101187: ARRAY
101188: PPUSH
101189: CALL_OW 274
101193: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
101194: LD_VAR 0 2
101198: PPUSH
101199: LD_INT 1
101201: PPUSH
101202: LD_INT 0
101204: PPUSH
101205: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
101209: LD_VAR 0 2
101213: PPUSH
101214: LD_INT 2
101216: PPUSH
101217: LD_INT 0
101219: PPUSH
101220: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
101224: LD_VAR 0 2
101228: PPUSH
101229: LD_INT 3
101231: PPUSH
101232: LD_INT 0
101234: PPUSH
101235: CALL_OW 277
// end ;
101239: PPOPN 2
101241: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
101242: LD_EXP 140
101246: PUSH
101247: LD_EXP 168
101251: AND
101252: IFFALSE 101349
101254: GO 101256
101256: DISABLE
101257: LD_INT 0
101259: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101260: LD_ADDR_VAR 0 1
101264: PUSH
101265: LD_INT 22
101267: PUSH
101268: LD_OWVAR 2
101272: PUSH
101273: EMPTY
101274: LIST
101275: LIST
101276: PUSH
101277: LD_INT 21
101279: PUSH
101280: LD_INT 1
101282: PUSH
101283: EMPTY
101284: LIST
101285: LIST
101286: PUSH
101287: LD_INT 3
101289: PUSH
101290: LD_INT 23
101292: PUSH
101293: LD_INT 0
101295: PUSH
101296: EMPTY
101297: LIST
101298: LIST
101299: PUSH
101300: EMPTY
101301: LIST
101302: LIST
101303: PUSH
101304: EMPTY
101305: LIST
101306: LIST
101307: LIST
101308: PPUSH
101309: CALL_OW 69
101313: ST_TO_ADDR
// if not tmp then
101314: LD_VAR 0 1
101318: NOT
101319: IFFALSE 101323
// exit ;
101321: GO 101349
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
101323: LD_VAR 0 1
101327: PUSH
101328: LD_INT 1
101330: PPUSH
101331: LD_VAR 0 1
101335: PPUSH
101336: CALL_OW 12
101340: ARRAY
101341: PPUSH
101342: LD_INT 200
101344: PPUSH
101345: CALL_OW 234
// end ;
101349: PPOPN 1
101351: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
101352: LD_EXP 140
101356: PUSH
101357: LD_EXP 169
101361: AND
101362: IFFALSE 101441
101364: GO 101366
101366: DISABLE
101367: LD_INT 0
101369: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101370: LD_ADDR_VAR 0 1
101374: PUSH
101375: LD_INT 22
101377: PUSH
101378: LD_OWVAR 2
101382: PUSH
101383: EMPTY
101384: LIST
101385: LIST
101386: PUSH
101387: LD_INT 21
101389: PUSH
101390: LD_INT 2
101392: PUSH
101393: EMPTY
101394: LIST
101395: LIST
101396: PUSH
101397: EMPTY
101398: LIST
101399: LIST
101400: PPUSH
101401: CALL_OW 69
101405: ST_TO_ADDR
// if not tmp then
101406: LD_VAR 0 1
101410: NOT
101411: IFFALSE 101415
// exit ;
101413: GO 101441
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101415: LD_VAR 0 1
101419: PUSH
101420: LD_INT 1
101422: PPUSH
101423: LD_VAR 0 1
101427: PPUSH
101428: CALL_OW 12
101432: ARRAY
101433: PPUSH
101434: LD_INT 60
101436: PPUSH
101437: CALL_OW 234
// end ;
101441: PPOPN 1
101443: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101444: LD_EXP 140
101448: PUSH
101449: LD_EXP 170
101453: AND
101454: IFFALSE 101553
101456: GO 101458
101458: DISABLE
101459: LD_INT 0
101461: PPUSH
101462: PPUSH
// begin enable ;
101463: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101464: LD_ADDR_VAR 0 1
101468: PUSH
101469: LD_INT 22
101471: PUSH
101472: LD_OWVAR 2
101476: PUSH
101477: EMPTY
101478: LIST
101479: LIST
101480: PUSH
101481: LD_INT 61
101483: PUSH
101484: EMPTY
101485: LIST
101486: PUSH
101487: LD_INT 33
101489: PUSH
101490: LD_INT 2
101492: PUSH
101493: EMPTY
101494: LIST
101495: LIST
101496: PUSH
101497: EMPTY
101498: LIST
101499: LIST
101500: LIST
101501: PPUSH
101502: CALL_OW 69
101506: ST_TO_ADDR
// if not tmp then
101507: LD_VAR 0 1
101511: NOT
101512: IFFALSE 101516
// exit ;
101514: GO 101553
// for i in tmp do
101516: LD_ADDR_VAR 0 2
101520: PUSH
101521: LD_VAR 0 1
101525: PUSH
101526: FOR_IN
101527: IFFALSE 101551
// if IsControledBy ( i ) then
101529: LD_VAR 0 2
101533: PPUSH
101534: CALL_OW 312
101538: IFFALSE 101549
// ComUnlink ( i ) ;
101540: LD_VAR 0 2
101544: PPUSH
101545: CALL_OW 136
101549: GO 101526
101551: POP
101552: POP
// end ;
101553: PPOPN 2
101555: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101556: LD_EXP 140
101560: PUSH
101561: LD_EXP 171
101565: AND
101566: IFFALSE 101706
101568: GO 101570
101570: DISABLE
101571: LD_INT 0
101573: PPUSH
101574: PPUSH
// begin ToLua ( displayPowell(); ) ;
101575: LD_STRING displayPowell();
101577: PPUSH
101578: CALL_OW 559
// uc_side := 0 ;
101582: LD_ADDR_OWVAR 20
101586: PUSH
101587: LD_INT 0
101589: ST_TO_ADDR
// uc_nation := 2 ;
101590: LD_ADDR_OWVAR 21
101594: PUSH
101595: LD_INT 2
101597: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101598: LD_ADDR_OWVAR 37
101602: PUSH
101603: LD_INT 14
101605: ST_TO_ADDR
// vc_engine := engine_siberite ;
101606: LD_ADDR_OWVAR 39
101610: PUSH
101611: LD_INT 3
101613: ST_TO_ADDR
// vc_control := control_apeman ;
101614: LD_ADDR_OWVAR 38
101618: PUSH
101619: LD_INT 5
101621: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101622: LD_ADDR_OWVAR 40
101626: PUSH
101627: LD_INT 29
101629: ST_TO_ADDR
// un := CreateVehicle ;
101630: LD_ADDR_VAR 0 2
101634: PUSH
101635: CALL_OW 45
101639: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101640: LD_VAR 0 2
101644: PPUSH
101645: LD_INT 1
101647: PPUSH
101648: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101652: LD_INT 35
101654: PPUSH
101655: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101659: LD_VAR 0 2
101663: PPUSH
101664: LD_INT 22
101666: PUSH
101667: LD_OWVAR 2
101671: PUSH
101672: EMPTY
101673: LIST
101674: LIST
101675: PPUSH
101676: CALL_OW 69
101680: PPUSH
101681: LD_VAR 0 2
101685: PPUSH
101686: CALL_OW 74
101690: PPUSH
101691: CALL_OW 115
// until IsDead ( un ) ;
101695: LD_VAR 0 2
101699: PPUSH
101700: CALL_OW 301
101704: IFFALSE 101652
// end ;
101706: PPOPN 2
101708: END
// every 0 0$1 trigger StreamModeActive and sStu do
101709: LD_EXP 140
101713: PUSH
101714: LD_EXP 179
101718: AND
101719: IFFALSE 101735
101721: GO 101723
101723: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101724: LD_STRING displayStucuk();
101726: PPUSH
101727: CALL_OW 559
// ResetFog ;
101731: CALL_OW 335
// end ;
101735: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101736: LD_EXP 140
101740: PUSH
101741: LD_EXP 172
101745: AND
101746: IFFALSE 101887
101748: GO 101750
101750: DISABLE
101751: LD_INT 0
101753: PPUSH
101754: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101755: LD_ADDR_VAR 0 2
101759: PUSH
101760: LD_INT 22
101762: PUSH
101763: LD_OWVAR 2
101767: PUSH
101768: EMPTY
101769: LIST
101770: LIST
101771: PUSH
101772: LD_INT 21
101774: PUSH
101775: LD_INT 1
101777: PUSH
101778: EMPTY
101779: LIST
101780: LIST
101781: PUSH
101782: EMPTY
101783: LIST
101784: LIST
101785: PPUSH
101786: CALL_OW 69
101790: ST_TO_ADDR
// if not tmp then
101791: LD_VAR 0 2
101795: NOT
101796: IFFALSE 101800
// exit ;
101798: GO 101887
// un := tmp [ rand ( 1 , tmp ) ] ;
101800: LD_ADDR_VAR 0 1
101804: PUSH
101805: LD_VAR 0 2
101809: PUSH
101810: LD_INT 1
101812: PPUSH
101813: LD_VAR 0 2
101817: PPUSH
101818: CALL_OW 12
101822: ARRAY
101823: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101824: LD_VAR 0 1
101828: PPUSH
101829: LD_INT 0
101831: PPUSH
101832: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101836: LD_VAR 0 1
101840: PPUSH
101841: LD_OWVAR 3
101845: PUSH
101846: LD_VAR 0 1
101850: DIFF
101851: PPUSH
101852: LD_VAR 0 1
101856: PPUSH
101857: CALL_OW 74
101861: PPUSH
101862: CALL_OW 115
// wait ( 0 0$20 ) ;
101866: LD_INT 700
101868: PPUSH
101869: CALL_OW 67
// SetSide ( un , your_side ) ;
101873: LD_VAR 0 1
101877: PPUSH
101878: LD_OWVAR 2
101882: PPUSH
101883: CALL_OW 235
// end ;
101887: PPOPN 2
101889: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101890: LD_EXP 140
101894: PUSH
101895: LD_EXP 173
101899: AND
101900: IFFALSE 102006
101902: GO 101904
101904: DISABLE
101905: LD_INT 0
101907: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101908: LD_ADDR_VAR 0 1
101912: PUSH
101913: LD_INT 22
101915: PUSH
101916: LD_OWVAR 2
101920: PUSH
101921: EMPTY
101922: LIST
101923: LIST
101924: PUSH
101925: LD_INT 2
101927: PUSH
101928: LD_INT 30
101930: PUSH
101931: LD_INT 0
101933: PUSH
101934: EMPTY
101935: LIST
101936: LIST
101937: PUSH
101938: LD_INT 30
101940: PUSH
101941: LD_INT 1
101943: PUSH
101944: EMPTY
101945: LIST
101946: LIST
101947: PUSH
101948: EMPTY
101949: LIST
101950: LIST
101951: LIST
101952: PUSH
101953: EMPTY
101954: LIST
101955: LIST
101956: PPUSH
101957: CALL_OW 69
101961: ST_TO_ADDR
// if not depot then
101962: LD_VAR 0 1
101966: NOT
101967: IFFALSE 101971
// exit ;
101969: GO 102006
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101971: LD_VAR 0 1
101975: PUSH
101976: LD_INT 1
101978: ARRAY
101979: PPUSH
101980: CALL_OW 250
101984: PPUSH
101985: LD_VAR 0 1
101989: PUSH
101990: LD_INT 1
101992: ARRAY
101993: PPUSH
101994: CALL_OW 251
101998: PPUSH
101999: LD_INT 70
102001: PPUSH
102002: CALL_OW 495
// end ;
102006: PPOPN 1
102008: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102009: LD_EXP 140
102013: PUSH
102014: LD_EXP 174
102018: AND
102019: IFFALSE 102230
102021: GO 102023
102023: DISABLE
102024: LD_INT 0
102026: PPUSH
102027: PPUSH
102028: PPUSH
102029: PPUSH
102030: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102031: LD_ADDR_VAR 0 5
102035: PUSH
102036: LD_INT 22
102038: PUSH
102039: LD_OWVAR 2
102043: PUSH
102044: EMPTY
102045: LIST
102046: LIST
102047: PUSH
102048: LD_INT 21
102050: PUSH
102051: LD_INT 1
102053: PUSH
102054: EMPTY
102055: LIST
102056: LIST
102057: PUSH
102058: EMPTY
102059: LIST
102060: LIST
102061: PPUSH
102062: CALL_OW 69
102066: ST_TO_ADDR
// if not tmp then
102067: LD_VAR 0 5
102071: NOT
102072: IFFALSE 102076
// exit ;
102074: GO 102230
// for i in tmp do
102076: LD_ADDR_VAR 0 1
102080: PUSH
102081: LD_VAR 0 5
102085: PUSH
102086: FOR_IN
102087: IFFALSE 102228
// begin d := rand ( 0 , 5 ) ;
102089: LD_ADDR_VAR 0 4
102093: PUSH
102094: LD_INT 0
102096: PPUSH
102097: LD_INT 5
102099: PPUSH
102100: CALL_OW 12
102104: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
102105: LD_ADDR_VAR 0 2
102109: PUSH
102110: LD_VAR 0 1
102114: PPUSH
102115: CALL_OW 250
102119: PPUSH
102120: LD_VAR 0 4
102124: PPUSH
102125: LD_INT 3
102127: PPUSH
102128: LD_INT 12
102130: PPUSH
102131: CALL_OW 12
102135: PPUSH
102136: CALL_OW 272
102140: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102141: LD_ADDR_VAR 0 3
102145: PUSH
102146: LD_VAR 0 1
102150: PPUSH
102151: CALL_OW 251
102155: PPUSH
102156: LD_VAR 0 4
102160: PPUSH
102161: LD_INT 3
102163: PPUSH
102164: LD_INT 12
102166: PPUSH
102167: CALL_OW 12
102171: PPUSH
102172: CALL_OW 273
102176: ST_TO_ADDR
// if ValidHex ( x , y ) then
102177: LD_VAR 0 2
102181: PPUSH
102182: LD_VAR 0 3
102186: PPUSH
102187: CALL_OW 488
102191: IFFALSE 102226
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
102193: LD_VAR 0 1
102197: PPUSH
102198: LD_VAR 0 2
102202: PPUSH
102203: LD_VAR 0 3
102207: PPUSH
102208: LD_INT 3
102210: PPUSH
102211: LD_INT 6
102213: PPUSH
102214: CALL_OW 12
102218: PPUSH
102219: LD_INT 1
102221: PPUSH
102222: CALL_OW 483
// end ;
102226: GO 102086
102228: POP
102229: POP
// end ;
102230: PPOPN 5
102232: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
102233: LD_EXP 140
102237: PUSH
102238: LD_EXP 175
102242: AND
102243: IFFALSE 102337
102245: GO 102247
102247: DISABLE
102248: LD_INT 0
102250: PPUSH
102251: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
102252: LD_ADDR_VAR 0 2
102256: PUSH
102257: LD_INT 22
102259: PUSH
102260: LD_OWVAR 2
102264: PUSH
102265: EMPTY
102266: LIST
102267: LIST
102268: PUSH
102269: LD_INT 32
102271: PUSH
102272: LD_INT 1
102274: PUSH
102275: EMPTY
102276: LIST
102277: LIST
102278: PUSH
102279: LD_INT 21
102281: PUSH
102282: LD_INT 2
102284: PUSH
102285: EMPTY
102286: LIST
102287: LIST
102288: PUSH
102289: EMPTY
102290: LIST
102291: LIST
102292: LIST
102293: PPUSH
102294: CALL_OW 69
102298: ST_TO_ADDR
// if not tmp then
102299: LD_VAR 0 2
102303: NOT
102304: IFFALSE 102308
// exit ;
102306: GO 102337
// for i in tmp do
102308: LD_ADDR_VAR 0 1
102312: PUSH
102313: LD_VAR 0 2
102317: PUSH
102318: FOR_IN
102319: IFFALSE 102335
// SetFuel ( i , 0 ) ;
102321: LD_VAR 0 1
102325: PPUSH
102326: LD_INT 0
102328: PPUSH
102329: CALL_OW 240
102333: GO 102318
102335: POP
102336: POP
// end ;
102337: PPOPN 2
102339: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
102340: LD_EXP 140
102344: PUSH
102345: LD_EXP 176
102349: AND
102350: IFFALSE 102416
102352: GO 102354
102354: DISABLE
102355: LD_INT 0
102357: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102358: LD_ADDR_VAR 0 1
102362: PUSH
102363: LD_INT 22
102365: PUSH
102366: LD_OWVAR 2
102370: PUSH
102371: EMPTY
102372: LIST
102373: LIST
102374: PUSH
102375: LD_INT 30
102377: PUSH
102378: LD_INT 29
102380: PUSH
102381: EMPTY
102382: LIST
102383: LIST
102384: PUSH
102385: EMPTY
102386: LIST
102387: LIST
102388: PPUSH
102389: CALL_OW 69
102393: ST_TO_ADDR
// if not tmp then
102394: LD_VAR 0 1
102398: NOT
102399: IFFALSE 102403
// exit ;
102401: GO 102416
// DestroyUnit ( tmp [ 1 ] ) ;
102403: LD_VAR 0 1
102407: PUSH
102408: LD_INT 1
102410: ARRAY
102411: PPUSH
102412: CALL_OW 65
// end ;
102416: PPOPN 1
102418: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102419: LD_EXP 140
102423: PUSH
102424: LD_EXP 178
102428: AND
102429: IFFALSE 102558
102431: GO 102433
102433: DISABLE
102434: LD_INT 0
102436: PPUSH
// begin uc_side := 0 ;
102437: LD_ADDR_OWVAR 20
102441: PUSH
102442: LD_INT 0
102444: ST_TO_ADDR
// uc_nation := nation_arabian ;
102445: LD_ADDR_OWVAR 21
102449: PUSH
102450: LD_INT 2
102452: ST_TO_ADDR
// hc_gallery :=  ;
102453: LD_ADDR_OWVAR 33
102457: PUSH
102458: LD_STRING 
102460: ST_TO_ADDR
// hc_name :=  ;
102461: LD_ADDR_OWVAR 26
102465: PUSH
102466: LD_STRING 
102468: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102469: LD_INT 1
102471: PPUSH
102472: LD_INT 11
102474: PPUSH
102475: LD_INT 10
102477: PPUSH
102478: CALL_OW 380
// un := CreateHuman ;
102482: LD_ADDR_VAR 0 1
102486: PUSH
102487: CALL_OW 44
102491: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102492: LD_VAR 0 1
102496: PPUSH
102497: LD_INT 1
102499: PPUSH
102500: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102504: LD_INT 35
102506: PPUSH
102507: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102511: LD_VAR 0 1
102515: PPUSH
102516: LD_INT 22
102518: PUSH
102519: LD_OWVAR 2
102523: PUSH
102524: EMPTY
102525: LIST
102526: LIST
102527: PPUSH
102528: CALL_OW 69
102532: PPUSH
102533: LD_VAR 0 1
102537: PPUSH
102538: CALL_OW 74
102542: PPUSH
102543: CALL_OW 115
// until IsDead ( un ) ;
102547: LD_VAR 0 1
102551: PPUSH
102552: CALL_OW 301
102556: IFFALSE 102504
// end ;
102558: PPOPN 1
102560: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102561: LD_EXP 140
102565: PUSH
102566: LD_EXP 180
102570: AND
102571: IFFALSE 102583
102573: GO 102575
102575: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102576: LD_STRING earthquake(getX(game), 0, 32)
102578: PPUSH
102579: CALL_OW 559
102583: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102584: LD_EXP 140
102588: PUSH
102589: LD_EXP 181
102593: AND
102594: IFFALSE 102685
102596: GO 102598
102598: DISABLE
102599: LD_INT 0
102601: PPUSH
// begin enable ;
102602: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102603: LD_ADDR_VAR 0 1
102607: PUSH
102608: LD_INT 22
102610: PUSH
102611: LD_OWVAR 2
102615: PUSH
102616: EMPTY
102617: LIST
102618: LIST
102619: PUSH
102620: LD_INT 21
102622: PUSH
102623: LD_INT 2
102625: PUSH
102626: EMPTY
102627: LIST
102628: LIST
102629: PUSH
102630: LD_INT 33
102632: PUSH
102633: LD_INT 3
102635: PUSH
102636: EMPTY
102637: LIST
102638: LIST
102639: PUSH
102640: EMPTY
102641: LIST
102642: LIST
102643: LIST
102644: PPUSH
102645: CALL_OW 69
102649: ST_TO_ADDR
// if not tmp then
102650: LD_VAR 0 1
102654: NOT
102655: IFFALSE 102659
// exit ;
102657: GO 102685
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102659: LD_VAR 0 1
102663: PUSH
102664: LD_INT 1
102666: PPUSH
102667: LD_VAR 0 1
102671: PPUSH
102672: CALL_OW 12
102676: ARRAY
102677: PPUSH
102678: LD_INT 1
102680: PPUSH
102681: CALL_OW 234
// end ;
102685: PPOPN 1
102687: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102688: LD_EXP 140
102692: PUSH
102693: LD_EXP 182
102697: AND
102698: IFFALSE 102839
102700: GO 102702
102702: DISABLE
102703: LD_INT 0
102705: PPUSH
102706: PPUSH
102707: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102708: LD_ADDR_VAR 0 3
102712: PUSH
102713: LD_INT 22
102715: PUSH
102716: LD_OWVAR 2
102720: PUSH
102721: EMPTY
102722: LIST
102723: LIST
102724: PUSH
102725: LD_INT 25
102727: PUSH
102728: LD_INT 1
102730: PUSH
102731: EMPTY
102732: LIST
102733: LIST
102734: PUSH
102735: EMPTY
102736: LIST
102737: LIST
102738: PPUSH
102739: CALL_OW 69
102743: ST_TO_ADDR
// if not tmp then
102744: LD_VAR 0 3
102748: NOT
102749: IFFALSE 102753
// exit ;
102751: GO 102839
// un := tmp [ rand ( 1 , tmp ) ] ;
102753: LD_ADDR_VAR 0 2
102757: PUSH
102758: LD_VAR 0 3
102762: PUSH
102763: LD_INT 1
102765: PPUSH
102766: LD_VAR 0 3
102770: PPUSH
102771: CALL_OW 12
102775: ARRAY
102776: ST_TO_ADDR
// if Crawls ( un ) then
102777: LD_VAR 0 2
102781: PPUSH
102782: CALL_OW 318
102786: IFFALSE 102797
// ComWalk ( un ) ;
102788: LD_VAR 0 2
102792: PPUSH
102793: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102797: LD_VAR 0 2
102801: PPUSH
102802: LD_INT 9
102804: PPUSH
102805: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102809: LD_INT 28
102811: PPUSH
102812: LD_OWVAR 2
102816: PPUSH
102817: LD_INT 2
102819: PPUSH
102820: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102824: LD_INT 29
102826: PPUSH
102827: LD_OWVAR 2
102831: PPUSH
102832: LD_INT 2
102834: PPUSH
102835: CALL_OW 322
// end ;
102839: PPOPN 3
102841: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102842: LD_EXP 140
102846: PUSH
102847: LD_EXP 183
102851: AND
102852: IFFALSE 102963
102854: GO 102856
102856: DISABLE
102857: LD_INT 0
102859: PPUSH
102860: PPUSH
102861: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102862: LD_ADDR_VAR 0 3
102866: PUSH
102867: LD_INT 22
102869: PUSH
102870: LD_OWVAR 2
102874: PUSH
102875: EMPTY
102876: LIST
102877: LIST
102878: PUSH
102879: LD_INT 25
102881: PUSH
102882: LD_INT 1
102884: PUSH
102885: EMPTY
102886: LIST
102887: LIST
102888: PUSH
102889: EMPTY
102890: LIST
102891: LIST
102892: PPUSH
102893: CALL_OW 69
102897: ST_TO_ADDR
// if not tmp then
102898: LD_VAR 0 3
102902: NOT
102903: IFFALSE 102907
// exit ;
102905: GO 102963
// un := tmp [ rand ( 1 , tmp ) ] ;
102907: LD_ADDR_VAR 0 2
102911: PUSH
102912: LD_VAR 0 3
102916: PUSH
102917: LD_INT 1
102919: PPUSH
102920: LD_VAR 0 3
102924: PPUSH
102925: CALL_OW 12
102929: ARRAY
102930: ST_TO_ADDR
// if Crawls ( un ) then
102931: LD_VAR 0 2
102935: PPUSH
102936: CALL_OW 318
102940: IFFALSE 102951
// ComWalk ( un ) ;
102942: LD_VAR 0 2
102946: PPUSH
102947: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102951: LD_VAR 0 2
102955: PPUSH
102956: LD_INT 8
102958: PPUSH
102959: CALL_OW 336
// end ;
102963: PPOPN 3
102965: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102966: LD_EXP 140
102970: PUSH
102971: LD_EXP 184
102975: AND
102976: IFFALSE 103120
102978: GO 102980
102980: DISABLE
102981: LD_INT 0
102983: PPUSH
102984: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102985: LD_ADDR_VAR 0 2
102989: PUSH
102990: LD_INT 22
102992: PUSH
102993: LD_OWVAR 2
102997: PUSH
102998: EMPTY
102999: LIST
103000: LIST
103001: PUSH
103002: LD_INT 21
103004: PUSH
103005: LD_INT 2
103007: PUSH
103008: EMPTY
103009: LIST
103010: LIST
103011: PUSH
103012: LD_INT 2
103014: PUSH
103015: LD_INT 34
103017: PUSH
103018: LD_INT 12
103020: PUSH
103021: EMPTY
103022: LIST
103023: LIST
103024: PUSH
103025: LD_INT 34
103027: PUSH
103028: LD_INT 51
103030: PUSH
103031: EMPTY
103032: LIST
103033: LIST
103034: PUSH
103035: LD_INT 34
103037: PUSH
103038: LD_INT 32
103040: PUSH
103041: EMPTY
103042: LIST
103043: LIST
103044: PUSH
103045: EMPTY
103046: LIST
103047: LIST
103048: LIST
103049: LIST
103050: PUSH
103051: EMPTY
103052: LIST
103053: LIST
103054: LIST
103055: PPUSH
103056: CALL_OW 69
103060: ST_TO_ADDR
// if not tmp then
103061: LD_VAR 0 2
103065: NOT
103066: IFFALSE 103070
// exit ;
103068: GO 103120
// for i in tmp do
103070: LD_ADDR_VAR 0 1
103074: PUSH
103075: LD_VAR 0 2
103079: PUSH
103080: FOR_IN
103081: IFFALSE 103118
// if GetCargo ( i , mat_artifact ) = 0 then
103083: LD_VAR 0 1
103087: PPUSH
103088: LD_INT 4
103090: PPUSH
103091: CALL_OW 289
103095: PUSH
103096: LD_INT 0
103098: EQUAL
103099: IFFALSE 103116
// SetCargo ( i , mat_siberit , 100 ) ;
103101: LD_VAR 0 1
103105: PPUSH
103106: LD_INT 3
103108: PPUSH
103109: LD_INT 100
103111: PPUSH
103112: CALL_OW 290
103116: GO 103080
103118: POP
103119: POP
// end ;
103120: PPOPN 2
103122: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103123: LD_EXP 140
103127: PUSH
103128: LD_EXP 185
103132: AND
103133: IFFALSE 103316
103135: GO 103137
103137: DISABLE
103138: LD_INT 0
103140: PPUSH
103141: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103142: LD_ADDR_VAR 0 2
103146: PUSH
103147: LD_INT 22
103149: PUSH
103150: LD_OWVAR 2
103154: PUSH
103155: EMPTY
103156: LIST
103157: LIST
103158: PPUSH
103159: CALL_OW 69
103163: ST_TO_ADDR
// if not tmp then
103164: LD_VAR 0 2
103168: NOT
103169: IFFALSE 103173
// exit ;
103171: GO 103316
// for i := 1 to 2 do
103173: LD_ADDR_VAR 0 1
103177: PUSH
103178: DOUBLE
103179: LD_INT 1
103181: DEC
103182: ST_TO_ADDR
103183: LD_INT 2
103185: PUSH
103186: FOR_TO
103187: IFFALSE 103314
// begin uc_side := your_side ;
103189: LD_ADDR_OWVAR 20
103193: PUSH
103194: LD_OWVAR 2
103198: ST_TO_ADDR
// uc_nation := nation_american ;
103199: LD_ADDR_OWVAR 21
103203: PUSH
103204: LD_INT 1
103206: ST_TO_ADDR
// vc_chassis := us_morphling ;
103207: LD_ADDR_OWVAR 37
103211: PUSH
103212: LD_INT 5
103214: ST_TO_ADDR
// vc_engine := engine_siberite ;
103215: LD_ADDR_OWVAR 39
103219: PUSH
103220: LD_INT 3
103222: ST_TO_ADDR
// vc_control := control_computer ;
103223: LD_ADDR_OWVAR 38
103227: PUSH
103228: LD_INT 3
103230: ST_TO_ADDR
// vc_weapon := us_double_laser ;
103231: LD_ADDR_OWVAR 40
103235: PUSH
103236: LD_INT 10
103238: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
103239: LD_VAR 0 2
103243: PUSH
103244: LD_INT 1
103246: ARRAY
103247: PPUSH
103248: CALL_OW 310
103252: NOT
103253: IFFALSE 103300
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
103255: CALL_OW 45
103259: PPUSH
103260: LD_VAR 0 2
103264: PUSH
103265: LD_INT 1
103267: ARRAY
103268: PPUSH
103269: CALL_OW 250
103273: PPUSH
103274: LD_VAR 0 2
103278: PUSH
103279: LD_INT 1
103281: ARRAY
103282: PPUSH
103283: CALL_OW 251
103287: PPUSH
103288: LD_INT 12
103290: PPUSH
103291: LD_INT 1
103293: PPUSH
103294: CALL_OW 50
103298: GO 103312
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
103300: CALL_OW 45
103304: PPUSH
103305: LD_INT 1
103307: PPUSH
103308: CALL_OW 51
// end ;
103312: GO 103186
103314: POP
103315: POP
// end ;
103316: PPOPN 2
103318: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
103319: LD_EXP 140
103323: PUSH
103324: LD_EXP 186
103328: AND
103329: IFFALSE 103551
103331: GO 103333
103333: DISABLE
103334: LD_INT 0
103336: PPUSH
103337: PPUSH
103338: PPUSH
103339: PPUSH
103340: PPUSH
103341: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103342: LD_ADDR_VAR 0 6
103346: PUSH
103347: LD_INT 22
103349: PUSH
103350: LD_OWVAR 2
103354: PUSH
103355: EMPTY
103356: LIST
103357: LIST
103358: PUSH
103359: LD_INT 21
103361: PUSH
103362: LD_INT 1
103364: PUSH
103365: EMPTY
103366: LIST
103367: LIST
103368: PUSH
103369: LD_INT 3
103371: PUSH
103372: LD_INT 23
103374: PUSH
103375: LD_INT 0
103377: PUSH
103378: EMPTY
103379: LIST
103380: LIST
103381: PUSH
103382: EMPTY
103383: LIST
103384: LIST
103385: PUSH
103386: EMPTY
103387: LIST
103388: LIST
103389: LIST
103390: PPUSH
103391: CALL_OW 69
103395: ST_TO_ADDR
// if not tmp then
103396: LD_VAR 0 6
103400: NOT
103401: IFFALSE 103405
// exit ;
103403: GO 103551
// s1 := rand ( 1 , 4 ) ;
103405: LD_ADDR_VAR 0 2
103409: PUSH
103410: LD_INT 1
103412: PPUSH
103413: LD_INT 4
103415: PPUSH
103416: CALL_OW 12
103420: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103421: LD_ADDR_VAR 0 4
103425: PUSH
103426: LD_VAR 0 6
103430: PUSH
103431: LD_INT 1
103433: ARRAY
103434: PPUSH
103435: LD_VAR 0 2
103439: PPUSH
103440: CALL_OW 259
103444: ST_TO_ADDR
// if s1 = 1 then
103445: LD_VAR 0 2
103449: PUSH
103450: LD_INT 1
103452: EQUAL
103453: IFFALSE 103473
// s2 := rand ( 2 , 4 ) else
103455: LD_ADDR_VAR 0 3
103459: PUSH
103460: LD_INT 2
103462: PPUSH
103463: LD_INT 4
103465: PPUSH
103466: CALL_OW 12
103470: ST_TO_ADDR
103471: GO 103481
// s2 := 1 ;
103473: LD_ADDR_VAR 0 3
103477: PUSH
103478: LD_INT 1
103480: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103481: LD_ADDR_VAR 0 5
103485: PUSH
103486: LD_VAR 0 6
103490: PUSH
103491: LD_INT 1
103493: ARRAY
103494: PPUSH
103495: LD_VAR 0 3
103499: PPUSH
103500: CALL_OW 259
103504: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103505: LD_VAR 0 6
103509: PUSH
103510: LD_INT 1
103512: ARRAY
103513: PPUSH
103514: LD_VAR 0 2
103518: PPUSH
103519: LD_VAR 0 5
103523: PPUSH
103524: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103528: LD_VAR 0 6
103532: PUSH
103533: LD_INT 1
103535: ARRAY
103536: PPUSH
103537: LD_VAR 0 3
103541: PPUSH
103542: LD_VAR 0 4
103546: PPUSH
103547: CALL_OW 237
// end ;
103551: PPOPN 6
103553: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103554: LD_EXP 140
103558: PUSH
103559: LD_EXP 187
103563: AND
103564: IFFALSE 103643
103566: GO 103568
103568: DISABLE
103569: LD_INT 0
103571: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103572: LD_ADDR_VAR 0 1
103576: PUSH
103577: LD_INT 22
103579: PUSH
103580: LD_OWVAR 2
103584: PUSH
103585: EMPTY
103586: LIST
103587: LIST
103588: PUSH
103589: LD_INT 30
103591: PUSH
103592: LD_INT 3
103594: PUSH
103595: EMPTY
103596: LIST
103597: LIST
103598: PUSH
103599: EMPTY
103600: LIST
103601: LIST
103602: PPUSH
103603: CALL_OW 69
103607: ST_TO_ADDR
// if not tmp then
103608: LD_VAR 0 1
103612: NOT
103613: IFFALSE 103617
// exit ;
103615: GO 103643
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103617: LD_VAR 0 1
103621: PUSH
103622: LD_INT 1
103624: PPUSH
103625: LD_VAR 0 1
103629: PPUSH
103630: CALL_OW 12
103634: ARRAY
103635: PPUSH
103636: LD_INT 1
103638: PPUSH
103639: CALL_OW 234
// end ;
103643: PPOPN 1
103645: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103646: LD_EXP 140
103650: PUSH
103651: LD_EXP 188
103655: AND
103656: IFFALSE 103768
103658: GO 103660
103660: DISABLE
103661: LD_INT 0
103663: PPUSH
103664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103665: LD_ADDR_VAR 0 2
103669: PUSH
103670: LD_INT 22
103672: PUSH
103673: LD_OWVAR 2
103677: PUSH
103678: EMPTY
103679: LIST
103680: LIST
103681: PUSH
103682: LD_INT 2
103684: PUSH
103685: LD_INT 30
103687: PUSH
103688: LD_INT 27
103690: PUSH
103691: EMPTY
103692: LIST
103693: LIST
103694: PUSH
103695: LD_INT 30
103697: PUSH
103698: LD_INT 26
103700: PUSH
103701: EMPTY
103702: LIST
103703: LIST
103704: PUSH
103705: LD_INT 30
103707: PUSH
103708: LD_INT 28
103710: PUSH
103711: EMPTY
103712: LIST
103713: LIST
103714: PUSH
103715: EMPTY
103716: LIST
103717: LIST
103718: LIST
103719: LIST
103720: PUSH
103721: EMPTY
103722: LIST
103723: LIST
103724: PPUSH
103725: CALL_OW 69
103729: ST_TO_ADDR
// if not tmp then
103730: LD_VAR 0 2
103734: NOT
103735: IFFALSE 103739
// exit ;
103737: GO 103768
// for i in tmp do
103739: LD_ADDR_VAR 0 1
103743: PUSH
103744: LD_VAR 0 2
103748: PUSH
103749: FOR_IN
103750: IFFALSE 103766
// SetLives ( i , 1 ) ;
103752: LD_VAR 0 1
103756: PPUSH
103757: LD_INT 1
103759: PPUSH
103760: CALL_OW 234
103764: GO 103749
103766: POP
103767: POP
// end ;
103768: PPOPN 2
103770: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103771: LD_EXP 140
103775: PUSH
103776: LD_EXP 189
103780: AND
103781: IFFALSE 104068
103783: GO 103785
103785: DISABLE
103786: LD_INT 0
103788: PPUSH
103789: PPUSH
103790: PPUSH
// begin i := rand ( 1 , 7 ) ;
103791: LD_ADDR_VAR 0 1
103795: PUSH
103796: LD_INT 1
103798: PPUSH
103799: LD_INT 7
103801: PPUSH
103802: CALL_OW 12
103806: ST_TO_ADDR
// case i of 1 :
103807: LD_VAR 0 1
103811: PUSH
103812: LD_INT 1
103814: DOUBLE
103815: EQUAL
103816: IFTRUE 103820
103818: GO 103830
103820: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103821: LD_STRING earthquake(getX(game), 0, 32)
103823: PPUSH
103824: CALL_OW 559
103828: GO 104068
103830: LD_INT 2
103832: DOUBLE
103833: EQUAL
103834: IFTRUE 103838
103836: GO 103852
103838: POP
// begin ToLua ( displayStucuk(); ) ;
103839: LD_STRING displayStucuk();
103841: PPUSH
103842: CALL_OW 559
// ResetFog ;
103846: CALL_OW 335
// end ; 3 :
103850: GO 104068
103852: LD_INT 3
103854: DOUBLE
103855: EQUAL
103856: IFTRUE 103860
103858: GO 103964
103860: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103861: LD_ADDR_VAR 0 2
103865: PUSH
103866: LD_INT 22
103868: PUSH
103869: LD_OWVAR 2
103873: PUSH
103874: EMPTY
103875: LIST
103876: LIST
103877: PUSH
103878: LD_INT 25
103880: PUSH
103881: LD_INT 1
103883: PUSH
103884: EMPTY
103885: LIST
103886: LIST
103887: PUSH
103888: EMPTY
103889: LIST
103890: LIST
103891: PPUSH
103892: CALL_OW 69
103896: ST_TO_ADDR
// if not tmp then
103897: LD_VAR 0 2
103901: NOT
103902: IFFALSE 103906
// exit ;
103904: GO 104068
// un := tmp [ rand ( 1 , tmp ) ] ;
103906: LD_ADDR_VAR 0 3
103910: PUSH
103911: LD_VAR 0 2
103915: PUSH
103916: LD_INT 1
103918: PPUSH
103919: LD_VAR 0 2
103923: PPUSH
103924: CALL_OW 12
103928: ARRAY
103929: ST_TO_ADDR
// if Crawls ( un ) then
103930: LD_VAR 0 3
103934: PPUSH
103935: CALL_OW 318
103939: IFFALSE 103950
// ComWalk ( un ) ;
103941: LD_VAR 0 3
103945: PPUSH
103946: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103950: LD_VAR 0 3
103954: PPUSH
103955: LD_INT 8
103957: PPUSH
103958: CALL_OW 336
// end ; 4 :
103962: GO 104068
103964: LD_INT 4
103966: DOUBLE
103967: EQUAL
103968: IFTRUE 103972
103970: GO 104046
103972: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103973: LD_ADDR_VAR 0 2
103977: PUSH
103978: LD_INT 22
103980: PUSH
103981: LD_OWVAR 2
103985: PUSH
103986: EMPTY
103987: LIST
103988: LIST
103989: PUSH
103990: LD_INT 30
103992: PUSH
103993: LD_INT 29
103995: PUSH
103996: EMPTY
103997: LIST
103998: LIST
103999: PUSH
104000: EMPTY
104001: LIST
104002: LIST
104003: PPUSH
104004: CALL_OW 69
104008: ST_TO_ADDR
// if not tmp then
104009: LD_VAR 0 2
104013: NOT
104014: IFFALSE 104018
// exit ;
104016: GO 104068
// CenterNowOnUnits ( tmp [ 1 ] ) ;
104018: LD_VAR 0 2
104022: PUSH
104023: LD_INT 1
104025: ARRAY
104026: PPUSH
104027: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
104031: LD_VAR 0 2
104035: PUSH
104036: LD_INT 1
104038: ARRAY
104039: PPUSH
104040: CALL_OW 65
// end ; 5 .. 7 :
104044: GO 104068
104046: LD_INT 5
104048: DOUBLE
104049: GREATEREQUAL
104050: IFFALSE 104058
104052: LD_INT 7
104054: DOUBLE
104055: LESSEQUAL
104056: IFTRUE 104060
104058: GO 104067
104060: POP
// StreamSibBomb ; end ;
104061: CALL 100305 0 0
104065: GO 104068
104067: POP
// end ;
104068: PPOPN 3
104070: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
104071: LD_EXP 140
104075: PUSH
104076: LD_EXP 190
104080: AND
104081: IFFALSE 104237
104083: GO 104085
104085: DISABLE
104086: LD_INT 0
104088: PPUSH
104089: PPUSH
104090: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
104091: LD_ADDR_VAR 0 2
104095: PUSH
104096: LD_INT 81
104098: PUSH
104099: LD_OWVAR 2
104103: PUSH
104104: EMPTY
104105: LIST
104106: LIST
104107: PUSH
104108: LD_INT 2
104110: PUSH
104111: LD_INT 21
104113: PUSH
104114: LD_INT 1
104116: PUSH
104117: EMPTY
104118: LIST
104119: LIST
104120: PUSH
104121: LD_INT 21
104123: PUSH
104124: LD_INT 2
104126: PUSH
104127: EMPTY
104128: LIST
104129: LIST
104130: PUSH
104131: EMPTY
104132: LIST
104133: LIST
104134: LIST
104135: PUSH
104136: EMPTY
104137: LIST
104138: LIST
104139: PPUSH
104140: CALL_OW 69
104144: ST_TO_ADDR
// if not tmp then
104145: LD_VAR 0 2
104149: NOT
104150: IFFALSE 104154
// exit ;
104152: GO 104237
// p := 0 ;
104154: LD_ADDR_VAR 0 3
104158: PUSH
104159: LD_INT 0
104161: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104162: LD_INT 35
104164: PPUSH
104165: CALL_OW 67
// p := p + 1 ;
104169: LD_ADDR_VAR 0 3
104173: PUSH
104174: LD_VAR 0 3
104178: PUSH
104179: LD_INT 1
104181: PLUS
104182: ST_TO_ADDR
// for i in tmp do
104183: LD_ADDR_VAR 0 1
104187: PUSH
104188: LD_VAR 0 2
104192: PUSH
104193: FOR_IN
104194: IFFALSE 104225
// if GetLives ( i ) < 1000 then
104196: LD_VAR 0 1
104200: PPUSH
104201: CALL_OW 256
104205: PUSH
104206: LD_INT 1000
104208: LESS
104209: IFFALSE 104223
// SetLives ( i , 1000 ) ;
104211: LD_VAR 0 1
104215: PPUSH
104216: LD_INT 1000
104218: PPUSH
104219: CALL_OW 234
104223: GO 104193
104225: POP
104226: POP
// until p > 20 ;
104227: LD_VAR 0 3
104231: PUSH
104232: LD_INT 20
104234: GREATER
104235: IFFALSE 104162
// end ;
104237: PPOPN 3
104239: END
// every 0 0$1 trigger StreamModeActive and sTime do
104240: LD_EXP 140
104244: PUSH
104245: LD_EXP 191
104249: AND
104250: IFFALSE 104285
104252: GO 104254
104254: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
104255: LD_INT 28
104257: PPUSH
104258: LD_OWVAR 2
104262: PPUSH
104263: LD_INT 2
104265: PPUSH
104266: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
104270: LD_INT 30
104272: PPUSH
104273: LD_OWVAR 2
104277: PPUSH
104278: LD_INT 2
104280: PPUSH
104281: CALL_OW 322
// end ;
104285: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
104286: LD_EXP 140
104290: PUSH
104291: LD_EXP 192
104295: AND
104296: IFFALSE 104417
104298: GO 104300
104300: DISABLE
104301: LD_INT 0
104303: PPUSH
104304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104305: LD_ADDR_VAR 0 2
104309: PUSH
104310: LD_INT 22
104312: PUSH
104313: LD_OWVAR 2
104317: PUSH
104318: EMPTY
104319: LIST
104320: LIST
104321: PUSH
104322: LD_INT 21
104324: PUSH
104325: LD_INT 1
104327: PUSH
104328: EMPTY
104329: LIST
104330: LIST
104331: PUSH
104332: LD_INT 3
104334: PUSH
104335: LD_INT 23
104337: PUSH
104338: LD_INT 0
104340: PUSH
104341: EMPTY
104342: LIST
104343: LIST
104344: PUSH
104345: EMPTY
104346: LIST
104347: LIST
104348: PUSH
104349: EMPTY
104350: LIST
104351: LIST
104352: LIST
104353: PPUSH
104354: CALL_OW 69
104358: ST_TO_ADDR
// if not tmp then
104359: LD_VAR 0 2
104363: NOT
104364: IFFALSE 104368
// exit ;
104366: GO 104417
// for i in tmp do
104368: LD_ADDR_VAR 0 1
104372: PUSH
104373: LD_VAR 0 2
104377: PUSH
104378: FOR_IN
104379: IFFALSE 104415
// begin if Crawls ( i ) then
104381: LD_VAR 0 1
104385: PPUSH
104386: CALL_OW 318
104390: IFFALSE 104401
// ComWalk ( i ) ;
104392: LD_VAR 0 1
104396: PPUSH
104397: CALL_OW 138
// SetClass ( i , 2 ) ;
104401: LD_VAR 0 1
104405: PPUSH
104406: LD_INT 2
104408: PPUSH
104409: CALL_OW 336
// end ;
104413: GO 104378
104415: POP
104416: POP
// end ;
104417: PPOPN 2
104419: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104420: LD_EXP 140
104424: PUSH
104425: LD_EXP 193
104429: AND
104430: IFFALSE 104718
104432: GO 104434
104434: DISABLE
104435: LD_INT 0
104437: PPUSH
104438: PPUSH
104439: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104440: LD_OWVAR 2
104444: PPUSH
104445: LD_INT 9
104447: PPUSH
104448: LD_INT 1
104450: PPUSH
104451: LD_INT 1
104453: PPUSH
104454: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104458: LD_INT 9
104460: PPUSH
104461: LD_OWVAR 2
104465: PPUSH
104466: CALL_OW 343
// uc_side := 9 ;
104470: LD_ADDR_OWVAR 20
104474: PUSH
104475: LD_INT 9
104477: ST_TO_ADDR
// uc_nation := 2 ;
104478: LD_ADDR_OWVAR 21
104482: PUSH
104483: LD_INT 2
104485: ST_TO_ADDR
// hc_name := Dark Warrior ;
104486: LD_ADDR_OWVAR 26
104490: PUSH
104491: LD_STRING Dark Warrior
104493: ST_TO_ADDR
// hc_gallery :=  ;
104494: LD_ADDR_OWVAR 33
104498: PUSH
104499: LD_STRING 
104501: ST_TO_ADDR
// hc_noskilllimit := true ;
104502: LD_ADDR_OWVAR 76
104506: PUSH
104507: LD_INT 1
104509: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104510: LD_ADDR_OWVAR 31
104514: PUSH
104515: LD_INT 30
104517: PUSH
104518: LD_INT 30
104520: PUSH
104521: LD_INT 30
104523: PUSH
104524: LD_INT 30
104526: PUSH
104527: EMPTY
104528: LIST
104529: LIST
104530: LIST
104531: LIST
104532: ST_TO_ADDR
// un := CreateHuman ;
104533: LD_ADDR_VAR 0 3
104537: PUSH
104538: CALL_OW 44
104542: ST_TO_ADDR
// hc_noskilllimit := false ;
104543: LD_ADDR_OWVAR 76
104547: PUSH
104548: LD_INT 0
104550: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104551: LD_VAR 0 3
104555: PPUSH
104556: LD_INT 1
104558: PPUSH
104559: CALL_OW 51
// ToLua ( playRanger() ) ;
104563: LD_STRING playRanger()
104565: PPUSH
104566: CALL_OW 559
// p := 0 ;
104570: LD_ADDR_VAR 0 2
104574: PUSH
104575: LD_INT 0
104577: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104578: LD_INT 35
104580: PPUSH
104581: CALL_OW 67
// p := p + 1 ;
104585: LD_ADDR_VAR 0 2
104589: PUSH
104590: LD_VAR 0 2
104594: PUSH
104595: LD_INT 1
104597: PLUS
104598: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104599: LD_VAR 0 3
104603: PPUSH
104604: CALL_OW 256
104608: PUSH
104609: LD_INT 1000
104611: LESS
104612: IFFALSE 104626
// SetLives ( un , 1000 ) ;
104614: LD_VAR 0 3
104618: PPUSH
104619: LD_INT 1000
104621: PPUSH
104622: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104626: LD_VAR 0 3
104630: PPUSH
104631: LD_INT 81
104633: PUSH
104634: LD_OWVAR 2
104638: PUSH
104639: EMPTY
104640: LIST
104641: LIST
104642: PUSH
104643: LD_INT 91
104645: PUSH
104646: LD_VAR 0 3
104650: PUSH
104651: LD_INT 30
104653: PUSH
104654: EMPTY
104655: LIST
104656: LIST
104657: LIST
104658: PUSH
104659: EMPTY
104660: LIST
104661: LIST
104662: PPUSH
104663: CALL_OW 69
104667: PPUSH
104668: LD_VAR 0 3
104672: PPUSH
104673: CALL_OW 74
104677: PPUSH
104678: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104682: LD_VAR 0 2
104686: PUSH
104687: LD_INT 80
104689: GREATER
104690: PUSH
104691: LD_VAR 0 3
104695: PPUSH
104696: CALL_OW 301
104700: OR
104701: IFFALSE 104578
// if un then
104703: LD_VAR 0 3
104707: IFFALSE 104718
// RemoveUnit ( un ) ;
104709: LD_VAR 0 3
104713: PPUSH
104714: CALL_OW 64
// end ;
104718: PPOPN 3
104720: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104721: LD_EXP 194
104725: IFFALSE 104841
104727: GO 104729
104729: DISABLE
104730: LD_INT 0
104732: PPUSH
104733: PPUSH
104734: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104735: LD_ADDR_VAR 0 2
104739: PUSH
104740: LD_INT 81
104742: PUSH
104743: LD_OWVAR 2
104747: PUSH
104748: EMPTY
104749: LIST
104750: LIST
104751: PUSH
104752: LD_INT 21
104754: PUSH
104755: LD_INT 1
104757: PUSH
104758: EMPTY
104759: LIST
104760: LIST
104761: PUSH
104762: EMPTY
104763: LIST
104764: LIST
104765: PPUSH
104766: CALL_OW 69
104770: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104771: LD_STRING playComputer()
104773: PPUSH
104774: CALL_OW 559
// if not tmp then
104778: LD_VAR 0 2
104782: NOT
104783: IFFALSE 104787
// exit ;
104785: GO 104841
// for i in tmp do
104787: LD_ADDR_VAR 0 1
104791: PUSH
104792: LD_VAR 0 2
104796: PUSH
104797: FOR_IN
104798: IFFALSE 104839
// for j := 1 to 4 do
104800: LD_ADDR_VAR 0 3
104804: PUSH
104805: DOUBLE
104806: LD_INT 1
104808: DEC
104809: ST_TO_ADDR
104810: LD_INT 4
104812: PUSH
104813: FOR_TO
104814: IFFALSE 104835
// SetSkill ( i , j , 10 ) ;
104816: LD_VAR 0 1
104820: PPUSH
104821: LD_VAR 0 3
104825: PPUSH
104826: LD_INT 10
104828: PPUSH
104829: CALL_OW 237
104833: GO 104813
104835: POP
104836: POP
104837: GO 104797
104839: POP
104840: POP
// end ;
104841: PPOPN 3
104843: END
// every 0 0$1 trigger s30 do var i , tmp ;
104844: LD_EXP 195
104848: IFFALSE 104917
104850: GO 104852
104852: DISABLE
104853: LD_INT 0
104855: PPUSH
104856: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104857: LD_ADDR_VAR 0 2
104861: PUSH
104862: LD_INT 22
104864: PUSH
104865: LD_OWVAR 2
104869: PUSH
104870: EMPTY
104871: LIST
104872: LIST
104873: PPUSH
104874: CALL_OW 69
104878: ST_TO_ADDR
// if not tmp then
104879: LD_VAR 0 2
104883: NOT
104884: IFFALSE 104888
// exit ;
104886: GO 104917
// for i in tmp do
104888: LD_ADDR_VAR 0 1
104892: PUSH
104893: LD_VAR 0 2
104897: PUSH
104898: FOR_IN
104899: IFFALSE 104915
// SetLives ( i , 300 ) ;
104901: LD_VAR 0 1
104905: PPUSH
104906: LD_INT 300
104908: PPUSH
104909: CALL_OW 234
104913: GO 104898
104915: POP
104916: POP
// end ;
104917: PPOPN 2
104919: END
// every 0 0$1 trigger s60 do var i , tmp ;
104920: LD_EXP 196
104924: IFFALSE 104993
104926: GO 104928
104928: DISABLE
104929: LD_INT 0
104931: PPUSH
104932: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104933: LD_ADDR_VAR 0 2
104937: PUSH
104938: LD_INT 22
104940: PUSH
104941: LD_OWVAR 2
104945: PUSH
104946: EMPTY
104947: LIST
104948: LIST
104949: PPUSH
104950: CALL_OW 69
104954: ST_TO_ADDR
// if not tmp then
104955: LD_VAR 0 2
104959: NOT
104960: IFFALSE 104964
// exit ;
104962: GO 104993
// for i in tmp do
104964: LD_ADDR_VAR 0 1
104968: PUSH
104969: LD_VAR 0 2
104973: PUSH
104974: FOR_IN
104975: IFFALSE 104991
// SetLives ( i , 600 ) ;
104977: LD_VAR 0 1
104981: PPUSH
104982: LD_INT 600
104984: PPUSH
104985: CALL_OW 234
104989: GO 104974
104991: POP
104992: POP
// end ;
104993: PPOPN 2
104995: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104996: LD_INT 0
104998: PPUSH
// case cmd of 301 :
104999: LD_VAR 0 1
105003: PUSH
105004: LD_INT 301
105006: DOUBLE
105007: EQUAL
105008: IFTRUE 105012
105010: GO 105044
105012: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
105013: LD_VAR 0 6
105017: PPUSH
105018: LD_VAR 0 7
105022: PPUSH
105023: LD_VAR 0 8
105027: PPUSH
105028: LD_VAR 0 4
105032: PPUSH
105033: LD_VAR 0 5
105037: PPUSH
105038: CALL 106245 0 5
105042: GO 105165
105044: LD_INT 302
105046: DOUBLE
105047: EQUAL
105048: IFTRUE 105052
105050: GO 105089
105052: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
105053: LD_VAR 0 6
105057: PPUSH
105058: LD_VAR 0 7
105062: PPUSH
105063: LD_VAR 0 8
105067: PPUSH
105068: LD_VAR 0 9
105072: PPUSH
105073: LD_VAR 0 4
105077: PPUSH
105078: LD_VAR 0 5
105082: PPUSH
105083: CALL 106336 0 6
105087: GO 105165
105089: LD_INT 303
105091: DOUBLE
105092: EQUAL
105093: IFTRUE 105097
105095: GO 105134
105097: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
105098: LD_VAR 0 6
105102: PPUSH
105103: LD_VAR 0 7
105107: PPUSH
105108: LD_VAR 0 8
105112: PPUSH
105113: LD_VAR 0 9
105117: PPUSH
105118: LD_VAR 0 4
105122: PPUSH
105123: LD_VAR 0 5
105127: PPUSH
105128: CALL 105170 0 6
105132: GO 105165
105134: LD_INT 304
105136: DOUBLE
105137: EQUAL
105138: IFTRUE 105142
105140: GO 105164
105142: POP
// hHackTeleport ( unit , x , y ) ; end ;
105143: LD_VAR 0 2
105147: PPUSH
105148: LD_VAR 0 4
105152: PPUSH
105153: LD_VAR 0 5
105157: PPUSH
105158: CALL 106929 0 3
105162: GO 105165
105164: POP
// end ;
105165: LD_VAR 0 12
105169: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
105170: LD_INT 0
105172: PPUSH
105173: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
105174: LD_VAR 0 1
105178: PUSH
105179: LD_INT 1
105181: LESS
105182: PUSH
105183: LD_VAR 0 1
105187: PUSH
105188: LD_INT 3
105190: GREATER
105191: OR
105192: PUSH
105193: LD_VAR 0 5
105197: PPUSH
105198: LD_VAR 0 6
105202: PPUSH
105203: CALL_OW 428
105207: OR
105208: IFFALSE 105212
// exit ;
105210: GO 105932
// uc_side := your_side ;
105212: LD_ADDR_OWVAR 20
105216: PUSH
105217: LD_OWVAR 2
105221: ST_TO_ADDR
// uc_nation := nation ;
105222: LD_ADDR_OWVAR 21
105226: PUSH
105227: LD_VAR 0 1
105231: ST_TO_ADDR
// bc_level = 1 ;
105232: LD_ADDR_OWVAR 43
105236: PUSH
105237: LD_INT 1
105239: ST_TO_ADDR
// case btype of 1 :
105240: LD_VAR 0 2
105244: PUSH
105245: LD_INT 1
105247: DOUBLE
105248: EQUAL
105249: IFTRUE 105253
105251: GO 105264
105253: POP
// bc_type := b_depot ; 2 :
105254: LD_ADDR_OWVAR 42
105258: PUSH
105259: LD_INT 0
105261: ST_TO_ADDR
105262: GO 105876
105264: LD_INT 2
105266: DOUBLE
105267: EQUAL
105268: IFTRUE 105272
105270: GO 105283
105272: POP
// bc_type := b_warehouse ; 3 :
105273: LD_ADDR_OWVAR 42
105277: PUSH
105278: LD_INT 1
105280: ST_TO_ADDR
105281: GO 105876
105283: LD_INT 3
105285: DOUBLE
105286: EQUAL
105287: IFTRUE 105291
105289: GO 105302
105291: POP
// bc_type := b_lab ; 4 .. 9 :
105292: LD_ADDR_OWVAR 42
105296: PUSH
105297: LD_INT 6
105299: ST_TO_ADDR
105300: GO 105876
105302: LD_INT 4
105304: DOUBLE
105305: GREATEREQUAL
105306: IFFALSE 105314
105308: LD_INT 9
105310: DOUBLE
105311: LESSEQUAL
105312: IFTRUE 105316
105314: GO 105368
105316: POP
// begin bc_type := b_lab_half ;
105317: LD_ADDR_OWVAR 42
105321: PUSH
105322: LD_INT 7
105324: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
105325: LD_ADDR_OWVAR 44
105329: PUSH
105330: LD_INT 10
105332: PUSH
105333: LD_INT 11
105335: PUSH
105336: LD_INT 12
105338: PUSH
105339: LD_INT 15
105341: PUSH
105342: LD_INT 14
105344: PUSH
105345: LD_INT 13
105347: PUSH
105348: EMPTY
105349: LIST
105350: LIST
105351: LIST
105352: LIST
105353: LIST
105354: LIST
105355: PUSH
105356: LD_VAR 0 2
105360: PUSH
105361: LD_INT 3
105363: MINUS
105364: ARRAY
105365: ST_TO_ADDR
// end ; 10 .. 13 :
105366: GO 105876
105368: LD_INT 10
105370: DOUBLE
105371: GREATEREQUAL
105372: IFFALSE 105380
105374: LD_INT 13
105376: DOUBLE
105377: LESSEQUAL
105378: IFTRUE 105382
105380: GO 105459
105382: POP
// begin bc_type := b_lab_full ;
105383: LD_ADDR_OWVAR 42
105387: PUSH
105388: LD_INT 8
105390: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
105391: LD_ADDR_OWVAR 44
105395: PUSH
105396: LD_INT 10
105398: PUSH
105399: LD_INT 12
105401: PUSH
105402: LD_INT 14
105404: PUSH
105405: LD_INT 13
105407: PUSH
105408: EMPTY
105409: LIST
105410: LIST
105411: LIST
105412: LIST
105413: PUSH
105414: LD_VAR 0 2
105418: PUSH
105419: LD_INT 9
105421: MINUS
105422: ARRAY
105423: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105424: LD_ADDR_OWVAR 45
105428: PUSH
105429: LD_INT 11
105431: PUSH
105432: LD_INT 15
105434: PUSH
105435: LD_INT 12
105437: PUSH
105438: LD_INT 15
105440: PUSH
105441: EMPTY
105442: LIST
105443: LIST
105444: LIST
105445: LIST
105446: PUSH
105447: LD_VAR 0 2
105451: PUSH
105452: LD_INT 9
105454: MINUS
105455: ARRAY
105456: ST_TO_ADDR
// end ; 14 :
105457: GO 105876
105459: LD_INT 14
105461: DOUBLE
105462: EQUAL
105463: IFTRUE 105467
105465: GO 105478
105467: POP
// bc_type := b_workshop ; 15 :
105468: LD_ADDR_OWVAR 42
105472: PUSH
105473: LD_INT 2
105475: ST_TO_ADDR
105476: GO 105876
105478: LD_INT 15
105480: DOUBLE
105481: EQUAL
105482: IFTRUE 105486
105484: GO 105497
105486: POP
// bc_type := b_factory ; 16 :
105487: LD_ADDR_OWVAR 42
105491: PUSH
105492: LD_INT 3
105494: ST_TO_ADDR
105495: GO 105876
105497: LD_INT 16
105499: DOUBLE
105500: EQUAL
105501: IFTRUE 105505
105503: GO 105516
105505: POP
// bc_type := b_ext_gun ; 17 :
105506: LD_ADDR_OWVAR 42
105510: PUSH
105511: LD_INT 17
105513: ST_TO_ADDR
105514: GO 105876
105516: LD_INT 17
105518: DOUBLE
105519: EQUAL
105520: IFTRUE 105524
105522: GO 105552
105524: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105525: LD_ADDR_OWVAR 42
105529: PUSH
105530: LD_INT 19
105532: PUSH
105533: LD_INT 23
105535: PUSH
105536: LD_INT 19
105538: PUSH
105539: EMPTY
105540: LIST
105541: LIST
105542: LIST
105543: PUSH
105544: LD_VAR 0 1
105548: ARRAY
105549: ST_TO_ADDR
105550: GO 105876
105552: LD_INT 18
105554: DOUBLE
105555: EQUAL
105556: IFTRUE 105560
105558: GO 105571
105560: POP
// bc_type := b_ext_radar ; 19 :
105561: LD_ADDR_OWVAR 42
105565: PUSH
105566: LD_INT 20
105568: ST_TO_ADDR
105569: GO 105876
105571: LD_INT 19
105573: DOUBLE
105574: EQUAL
105575: IFTRUE 105579
105577: GO 105590
105579: POP
// bc_type := b_ext_radio ; 20 :
105580: LD_ADDR_OWVAR 42
105584: PUSH
105585: LD_INT 22
105587: ST_TO_ADDR
105588: GO 105876
105590: LD_INT 20
105592: DOUBLE
105593: EQUAL
105594: IFTRUE 105598
105596: GO 105609
105598: POP
// bc_type := b_ext_siberium ; 21 :
105599: LD_ADDR_OWVAR 42
105603: PUSH
105604: LD_INT 21
105606: ST_TO_ADDR
105607: GO 105876
105609: LD_INT 21
105611: DOUBLE
105612: EQUAL
105613: IFTRUE 105617
105615: GO 105628
105617: POP
// bc_type := b_ext_computer ; 22 :
105618: LD_ADDR_OWVAR 42
105622: PUSH
105623: LD_INT 24
105625: ST_TO_ADDR
105626: GO 105876
105628: LD_INT 22
105630: DOUBLE
105631: EQUAL
105632: IFTRUE 105636
105634: GO 105647
105636: POP
// bc_type := b_ext_track ; 23 :
105637: LD_ADDR_OWVAR 42
105641: PUSH
105642: LD_INT 16
105644: ST_TO_ADDR
105645: GO 105876
105647: LD_INT 23
105649: DOUBLE
105650: EQUAL
105651: IFTRUE 105655
105653: GO 105666
105655: POP
// bc_type := b_ext_laser ; 24 :
105656: LD_ADDR_OWVAR 42
105660: PUSH
105661: LD_INT 25
105663: ST_TO_ADDR
105664: GO 105876
105666: LD_INT 24
105668: DOUBLE
105669: EQUAL
105670: IFTRUE 105674
105672: GO 105685
105674: POP
// bc_type := b_control_tower ; 25 :
105675: LD_ADDR_OWVAR 42
105679: PUSH
105680: LD_INT 36
105682: ST_TO_ADDR
105683: GO 105876
105685: LD_INT 25
105687: DOUBLE
105688: EQUAL
105689: IFTRUE 105693
105691: GO 105704
105693: POP
// bc_type := b_breastwork ; 26 :
105694: LD_ADDR_OWVAR 42
105698: PUSH
105699: LD_INT 31
105701: ST_TO_ADDR
105702: GO 105876
105704: LD_INT 26
105706: DOUBLE
105707: EQUAL
105708: IFTRUE 105712
105710: GO 105723
105712: POP
// bc_type := b_bunker ; 27 :
105713: LD_ADDR_OWVAR 42
105717: PUSH
105718: LD_INT 32
105720: ST_TO_ADDR
105721: GO 105876
105723: LD_INT 27
105725: DOUBLE
105726: EQUAL
105727: IFTRUE 105731
105729: GO 105742
105731: POP
// bc_type := b_turret ; 28 :
105732: LD_ADDR_OWVAR 42
105736: PUSH
105737: LD_INT 33
105739: ST_TO_ADDR
105740: GO 105876
105742: LD_INT 28
105744: DOUBLE
105745: EQUAL
105746: IFTRUE 105750
105748: GO 105761
105750: POP
// bc_type := b_armoury ; 29 :
105751: LD_ADDR_OWVAR 42
105755: PUSH
105756: LD_INT 4
105758: ST_TO_ADDR
105759: GO 105876
105761: LD_INT 29
105763: DOUBLE
105764: EQUAL
105765: IFTRUE 105769
105767: GO 105780
105769: POP
// bc_type := b_barracks ; 30 :
105770: LD_ADDR_OWVAR 42
105774: PUSH
105775: LD_INT 5
105777: ST_TO_ADDR
105778: GO 105876
105780: LD_INT 30
105782: DOUBLE
105783: EQUAL
105784: IFTRUE 105788
105786: GO 105799
105788: POP
// bc_type := b_solar_power ; 31 :
105789: LD_ADDR_OWVAR 42
105793: PUSH
105794: LD_INT 27
105796: ST_TO_ADDR
105797: GO 105876
105799: LD_INT 31
105801: DOUBLE
105802: EQUAL
105803: IFTRUE 105807
105805: GO 105818
105807: POP
// bc_type := b_oil_power ; 32 :
105808: LD_ADDR_OWVAR 42
105812: PUSH
105813: LD_INT 26
105815: ST_TO_ADDR
105816: GO 105876
105818: LD_INT 32
105820: DOUBLE
105821: EQUAL
105822: IFTRUE 105826
105824: GO 105837
105826: POP
// bc_type := b_siberite_power ; 33 :
105827: LD_ADDR_OWVAR 42
105831: PUSH
105832: LD_INT 28
105834: ST_TO_ADDR
105835: GO 105876
105837: LD_INT 33
105839: DOUBLE
105840: EQUAL
105841: IFTRUE 105845
105843: GO 105856
105845: POP
// bc_type := b_oil_mine ; 34 :
105846: LD_ADDR_OWVAR 42
105850: PUSH
105851: LD_INT 29
105853: ST_TO_ADDR
105854: GO 105876
105856: LD_INT 34
105858: DOUBLE
105859: EQUAL
105860: IFTRUE 105864
105862: GO 105875
105864: POP
// bc_type := b_siberite_mine ; end ;
105865: LD_ADDR_OWVAR 42
105869: PUSH
105870: LD_INT 30
105872: ST_TO_ADDR
105873: GO 105876
105875: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105876: LD_ADDR_VAR 0 8
105880: PUSH
105881: LD_VAR 0 5
105885: PPUSH
105886: LD_VAR 0 6
105890: PPUSH
105891: LD_VAR 0 3
105895: PPUSH
105896: CALL_OW 47
105900: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105901: LD_OWVAR 42
105905: PUSH
105906: LD_INT 32
105908: PUSH
105909: LD_INT 33
105911: PUSH
105912: EMPTY
105913: LIST
105914: LIST
105915: IN
105916: IFFALSE 105932
// PlaceWeaponTurret ( b , weapon ) ;
105918: LD_VAR 0 8
105922: PPUSH
105923: LD_VAR 0 4
105927: PPUSH
105928: CALL_OW 431
// end ;
105932: LD_VAR 0 7
105936: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105937: LD_INT 0
105939: PPUSH
105940: PPUSH
105941: PPUSH
105942: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105943: LD_ADDR_VAR 0 4
105947: PUSH
105948: LD_INT 22
105950: PUSH
105951: LD_OWVAR 2
105955: PUSH
105956: EMPTY
105957: LIST
105958: LIST
105959: PUSH
105960: LD_INT 2
105962: PUSH
105963: LD_INT 30
105965: PUSH
105966: LD_INT 0
105968: PUSH
105969: EMPTY
105970: LIST
105971: LIST
105972: PUSH
105973: LD_INT 30
105975: PUSH
105976: LD_INT 1
105978: PUSH
105979: EMPTY
105980: LIST
105981: LIST
105982: PUSH
105983: EMPTY
105984: LIST
105985: LIST
105986: LIST
105987: PUSH
105988: EMPTY
105989: LIST
105990: LIST
105991: PPUSH
105992: CALL_OW 69
105996: ST_TO_ADDR
// if not tmp then
105997: LD_VAR 0 4
106001: NOT
106002: IFFALSE 106006
// exit ;
106004: GO 106065
// for i in tmp do
106006: LD_ADDR_VAR 0 2
106010: PUSH
106011: LD_VAR 0 4
106015: PUSH
106016: FOR_IN
106017: IFFALSE 106063
// for j = 1 to 3 do
106019: LD_ADDR_VAR 0 3
106023: PUSH
106024: DOUBLE
106025: LD_INT 1
106027: DEC
106028: ST_TO_ADDR
106029: LD_INT 3
106031: PUSH
106032: FOR_TO
106033: IFFALSE 106059
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
106035: LD_VAR 0 2
106039: PPUSH
106040: CALL_OW 274
106044: PPUSH
106045: LD_VAR 0 3
106049: PPUSH
106050: LD_INT 99999
106052: PPUSH
106053: CALL_OW 277
106057: GO 106032
106059: POP
106060: POP
106061: GO 106016
106063: POP
106064: POP
// end ;
106065: LD_VAR 0 1
106069: RET
// export function hHackSetLevel10 ; var i , j ; begin
106070: LD_INT 0
106072: PPUSH
106073: PPUSH
106074: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106075: LD_ADDR_VAR 0 2
106079: PUSH
106080: LD_INT 21
106082: PUSH
106083: LD_INT 1
106085: PUSH
106086: EMPTY
106087: LIST
106088: LIST
106089: PPUSH
106090: CALL_OW 69
106094: PUSH
106095: FOR_IN
106096: IFFALSE 106148
// if IsSelected ( i ) then
106098: LD_VAR 0 2
106102: PPUSH
106103: CALL_OW 306
106107: IFFALSE 106146
// begin for j := 1 to 4 do
106109: LD_ADDR_VAR 0 3
106113: PUSH
106114: DOUBLE
106115: LD_INT 1
106117: DEC
106118: ST_TO_ADDR
106119: LD_INT 4
106121: PUSH
106122: FOR_TO
106123: IFFALSE 106144
// SetSkill ( i , j , 10 ) ;
106125: LD_VAR 0 2
106129: PPUSH
106130: LD_VAR 0 3
106134: PPUSH
106135: LD_INT 10
106137: PPUSH
106138: CALL_OW 237
106142: GO 106122
106144: POP
106145: POP
// end ;
106146: GO 106095
106148: POP
106149: POP
// end ;
106150: LD_VAR 0 1
106154: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
106155: LD_INT 0
106157: PPUSH
106158: PPUSH
106159: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
106160: LD_ADDR_VAR 0 2
106164: PUSH
106165: LD_INT 22
106167: PUSH
106168: LD_OWVAR 2
106172: PUSH
106173: EMPTY
106174: LIST
106175: LIST
106176: PUSH
106177: LD_INT 21
106179: PUSH
106180: LD_INT 1
106182: PUSH
106183: EMPTY
106184: LIST
106185: LIST
106186: PUSH
106187: EMPTY
106188: LIST
106189: LIST
106190: PPUSH
106191: CALL_OW 69
106195: PUSH
106196: FOR_IN
106197: IFFALSE 106238
// begin for j := 1 to 4 do
106199: LD_ADDR_VAR 0 3
106203: PUSH
106204: DOUBLE
106205: LD_INT 1
106207: DEC
106208: ST_TO_ADDR
106209: LD_INT 4
106211: PUSH
106212: FOR_TO
106213: IFFALSE 106234
// SetSkill ( i , j , 10 ) ;
106215: LD_VAR 0 2
106219: PPUSH
106220: LD_VAR 0 3
106224: PPUSH
106225: LD_INT 10
106227: PPUSH
106228: CALL_OW 237
106232: GO 106212
106234: POP
106235: POP
// end ;
106236: GO 106196
106238: POP
106239: POP
// end ;
106240: LD_VAR 0 1
106244: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
106245: LD_INT 0
106247: PPUSH
// uc_side := your_side ;
106248: LD_ADDR_OWVAR 20
106252: PUSH
106253: LD_OWVAR 2
106257: ST_TO_ADDR
// uc_nation := nation ;
106258: LD_ADDR_OWVAR 21
106262: PUSH
106263: LD_VAR 0 1
106267: ST_TO_ADDR
// InitHc ;
106268: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
106272: LD_INT 0
106274: PPUSH
106275: LD_VAR 0 2
106279: PPUSH
106280: LD_VAR 0 3
106284: PPUSH
106285: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
106289: LD_VAR 0 4
106293: PPUSH
106294: LD_VAR 0 5
106298: PPUSH
106299: CALL_OW 428
106303: PUSH
106304: LD_INT 0
106306: EQUAL
106307: IFFALSE 106331
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
106309: CALL_OW 44
106313: PPUSH
106314: LD_VAR 0 4
106318: PPUSH
106319: LD_VAR 0 5
106323: PPUSH
106324: LD_INT 1
106326: PPUSH
106327: CALL_OW 48
// end ;
106331: LD_VAR 0 6
106335: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
106336: LD_INT 0
106338: PPUSH
106339: PPUSH
// uc_side := your_side ;
106340: LD_ADDR_OWVAR 20
106344: PUSH
106345: LD_OWVAR 2
106349: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
106350: LD_VAR 0 1
106354: PUSH
106355: LD_INT 1
106357: PUSH
106358: LD_INT 2
106360: PUSH
106361: LD_INT 3
106363: PUSH
106364: LD_INT 4
106366: PUSH
106367: LD_INT 5
106369: PUSH
106370: EMPTY
106371: LIST
106372: LIST
106373: LIST
106374: LIST
106375: LIST
106376: IN
106377: IFFALSE 106389
// uc_nation := nation_american else
106379: LD_ADDR_OWVAR 21
106383: PUSH
106384: LD_INT 1
106386: ST_TO_ADDR
106387: GO 106432
// if chassis in [ 11 , 12 , 13 , 14 ] then
106389: LD_VAR 0 1
106393: PUSH
106394: LD_INT 11
106396: PUSH
106397: LD_INT 12
106399: PUSH
106400: LD_INT 13
106402: PUSH
106403: LD_INT 14
106405: PUSH
106406: EMPTY
106407: LIST
106408: LIST
106409: LIST
106410: LIST
106411: IN
106412: IFFALSE 106424
// uc_nation := nation_arabian else
106414: LD_ADDR_OWVAR 21
106418: PUSH
106419: LD_INT 2
106421: ST_TO_ADDR
106422: GO 106432
// uc_nation := nation_russian ;
106424: LD_ADDR_OWVAR 21
106428: PUSH
106429: LD_INT 3
106431: ST_TO_ADDR
// vc_chassis := chassis ;
106432: LD_ADDR_OWVAR 37
106436: PUSH
106437: LD_VAR 0 1
106441: ST_TO_ADDR
// vc_engine := engine ;
106442: LD_ADDR_OWVAR 39
106446: PUSH
106447: LD_VAR 0 2
106451: ST_TO_ADDR
// vc_control := control ;
106452: LD_ADDR_OWVAR 38
106456: PUSH
106457: LD_VAR 0 3
106461: ST_TO_ADDR
// vc_weapon := weapon ;
106462: LD_ADDR_OWVAR 40
106466: PUSH
106467: LD_VAR 0 4
106471: ST_TO_ADDR
// un := CreateVehicle ;
106472: LD_ADDR_VAR 0 8
106476: PUSH
106477: CALL_OW 45
106481: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106482: LD_VAR 0 8
106486: PPUSH
106487: LD_INT 0
106489: PPUSH
106490: LD_INT 5
106492: PPUSH
106493: CALL_OW 12
106497: PPUSH
106498: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106502: LD_VAR 0 8
106506: PPUSH
106507: LD_VAR 0 5
106511: PPUSH
106512: LD_VAR 0 6
106516: PPUSH
106517: LD_INT 1
106519: PPUSH
106520: CALL_OW 48
// end ;
106524: LD_VAR 0 7
106528: RET
// export hInvincible ; every 1 do
106529: GO 106531
106531: DISABLE
// hInvincible := [ ] ;
106532: LD_ADDR_EXP 197
106536: PUSH
106537: EMPTY
106538: ST_TO_ADDR
106539: END
// every 10 do var i ;
106540: GO 106542
106542: DISABLE
106543: LD_INT 0
106545: PPUSH
// begin enable ;
106546: ENABLE
// if not hInvincible then
106547: LD_EXP 197
106551: NOT
106552: IFFALSE 106556
// exit ;
106554: GO 106600
// for i in hInvincible do
106556: LD_ADDR_VAR 0 1
106560: PUSH
106561: LD_EXP 197
106565: PUSH
106566: FOR_IN
106567: IFFALSE 106598
// if GetLives ( i ) < 1000 then
106569: LD_VAR 0 1
106573: PPUSH
106574: CALL_OW 256
106578: PUSH
106579: LD_INT 1000
106581: LESS
106582: IFFALSE 106596
// SetLives ( i , 1000 ) ;
106584: LD_VAR 0 1
106588: PPUSH
106589: LD_INT 1000
106591: PPUSH
106592: CALL_OW 234
106596: GO 106566
106598: POP
106599: POP
// end ;
106600: PPOPN 1
106602: END
// export function hHackInvincible ; var i ; begin
106603: LD_INT 0
106605: PPUSH
106606: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106607: LD_ADDR_VAR 0 2
106611: PUSH
106612: LD_INT 2
106614: PUSH
106615: LD_INT 21
106617: PUSH
106618: LD_INT 1
106620: PUSH
106621: EMPTY
106622: LIST
106623: LIST
106624: PUSH
106625: LD_INT 21
106627: PUSH
106628: LD_INT 2
106630: PUSH
106631: EMPTY
106632: LIST
106633: LIST
106634: PUSH
106635: EMPTY
106636: LIST
106637: LIST
106638: LIST
106639: PPUSH
106640: CALL_OW 69
106644: PUSH
106645: FOR_IN
106646: IFFALSE 106707
// if IsSelected ( i ) then
106648: LD_VAR 0 2
106652: PPUSH
106653: CALL_OW 306
106657: IFFALSE 106705
// begin if i in hInvincible then
106659: LD_VAR 0 2
106663: PUSH
106664: LD_EXP 197
106668: IN
106669: IFFALSE 106689
// hInvincible := hInvincible diff i else
106671: LD_ADDR_EXP 197
106675: PUSH
106676: LD_EXP 197
106680: PUSH
106681: LD_VAR 0 2
106685: DIFF
106686: ST_TO_ADDR
106687: GO 106705
// hInvincible := hInvincible union i ;
106689: LD_ADDR_EXP 197
106693: PUSH
106694: LD_EXP 197
106698: PUSH
106699: LD_VAR 0 2
106703: UNION
106704: ST_TO_ADDR
// end ;
106705: GO 106645
106707: POP
106708: POP
// end ;
106709: LD_VAR 0 1
106713: RET
// export function hHackInvisible ; var i , j ; begin
106714: LD_INT 0
106716: PPUSH
106717: PPUSH
106718: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106719: LD_ADDR_VAR 0 2
106723: PUSH
106724: LD_INT 21
106726: PUSH
106727: LD_INT 1
106729: PUSH
106730: EMPTY
106731: LIST
106732: LIST
106733: PPUSH
106734: CALL_OW 69
106738: PUSH
106739: FOR_IN
106740: IFFALSE 106764
// if IsSelected ( i ) then
106742: LD_VAR 0 2
106746: PPUSH
106747: CALL_OW 306
106751: IFFALSE 106762
// ComForceInvisible ( i ) ;
106753: LD_VAR 0 2
106757: PPUSH
106758: CALL_OW 496
106762: GO 106739
106764: POP
106765: POP
// end ;
106766: LD_VAR 0 1
106770: RET
// export function hHackChangeYourSide ; begin
106771: LD_INT 0
106773: PPUSH
// if your_side = 8 then
106774: LD_OWVAR 2
106778: PUSH
106779: LD_INT 8
106781: EQUAL
106782: IFFALSE 106794
// your_side := 0 else
106784: LD_ADDR_OWVAR 2
106788: PUSH
106789: LD_INT 0
106791: ST_TO_ADDR
106792: GO 106808
// your_side := your_side + 1 ;
106794: LD_ADDR_OWVAR 2
106798: PUSH
106799: LD_OWVAR 2
106803: PUSH
106804: LD_INT 1
106806: PLUS
106807: ST_TO_ADDR
// end ;
106808: LD_VAR 0 1
106812: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106813: LD_INT 0
106815: PPUSH
106816: PPUSH
106817: PPUSH
// for i in all_units do
106818: LD_ADDR_VAR 0 2
106822: PUSH
106823: LD_OWVAR 3
106827: PUSH
106828: FOR_IN
106829: IFFALSE 106907
// if IsSelected ( i ) then
106831: LD_VAR 0 2
106835: PPUSH
106836: CALL_OW 306
106840: IFFALSE 106905
// begin j := GetSide ( i ) ;
106842: LD_ADDR_VAR 0 3
106846: PUSH
106847: LD_VAR 0 2
106851: PPUSH
106852: CALL_OW 255
106856: ST_TO_ADDR
// if j = 8 then
106857: LD_VAR 0 3
106861: PUSH
106862: LD_INT 8
106864: EQUAL
106865: IFFALSE 106877
// j := 0 else
106867: LD_ADDR_VAR 0 3
106871: PUSH
106872: LD_INT 0
106874: ST_TO_ADDR
106875: GO 106891
// j := j + 1 ;
106877: LD_ADDR_VAR 0 3
106881: PUSH
106882: LD_VAR 0 3
106886: PUSH
106887: LD_INT 1
106889: PLUS
106890: ST_TO_ADDR
// SetSide ( i , j ) ;
106891: LD_VAR 0 2
106895: PPUSH
106896: LD_VAR 0 3
106900: PPUSH
106901: CALL_OW 235
// end ;
106905: GO 106828
106907: POP
106908: POP
// end ;
106909: LD_VAR 0 1
106913: RET
// export function hHackFog ; begin
106914: LD_INT 0
106916: PPUSH
// FogOff ( true ) ;
106917: LD_INT 1
106919: PPUSH
106920: CALL_OW 344
// end ;
106924: LD_VAR 0 1
106928: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106929: LD_INT 0
106931: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106932: LD_VAR 0 1
106936: PPUSH
106937: LD_VAR 0 2
106941: PPUSH
106942: LD_VAR 0 3
106946: PPUSH
106947: LD_INT 1
106949: PPUSH
106950: LD_INT 1
106952: PPUSH
106953: CALL_OW 483
// CenterOnXY ( x , y ) ;
106957: LD_VAR 0 2
106961: PPUSH
106962: LD_VAR 0 3
106966: PPUSH
106967: CALL_OW 84
// end ; end_of_file
106971: LD_VAR 0 4
106975: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
106976: LD_INT 0
106978: PPUSH
106979: PPUSH
106980: PPUSH
106981: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106982: LD_VAR 0 1
106986: PPUSH
106987: CALL_OW 264
106991: PUSH
106992: LD_EXP 78
106996: EQUAL
106997: IFFALSE 107069
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106999: LD_INT 68
107001: PPUSH
107002: LD_VAR 0 1
107006: PPUSH
107007: CALL_OW 255
107011: PPUSH
107012: CALL_OW 321
107016: PUSH
107017: LD_INT 2
107019: EQUAL
107020: IFFALSE 107032
// eff := 70 else
107022: LD_ADDR_VAR 0 4
107026: PUSH
107027: LD_INT 70
107029: ST_TO_ADDR
107030: GO 107040
// eff := 30 ;
107032: LD_ADDR_VAR 0 4
107036: PUSH
107037: LD_INT 30
107039: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107040: LD_VAR 0 1
107044: PPUSH
107045: CALL_OW 250
107049: PPUSH
107050: LD_VAR 0 1
107054: PPUSH
107055: CALL_OW 251
107059: PPUSH
107060: LD_VAR 0 4
107064: PPUSH
107065: CALL_OW 495
// end ; end ;
107069: LD_VAR 0 2
107073: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107074: LD_INT 0
107076: PPUSH
// end ;
107077: LD_VAR 0 4
107081: RET
// export function SOS_Command ( cmd ) ; begin
107082: LD_INT 0
107084: PPUSH
// end ;
107085: LD_VAR 0 2
107089: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107090: LD_INT 0
107092: PPUSH
// end ;
107093: LD_VAR 0 6
107097: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107098: LD_INT 0
107100: PPUSH
107101: PPUSH
// if not vehicle or not factory then
107102: LD_VAR 0 1
107106: NOT
107107: PUSH
107108: LD_VAR 0 2
107112: NOT
107113: OR
107114: IFFALSE 107118
// exit ;
107116: GO 107349
// if factoryWaypoints >= factory then
107118: LD_EXP 198
107122: PUSH
107123: LD_VAR 0 2
107127: GREATEREQUAL
107128: IFFALSE 107349
// if factoryWaypoints [ factory ] then
107130: LD_EXP 198
107134: PUSH
107135: LD_VAR 0 2
107139: ARRAY
107140: IFFALSE 107349
// begin if GetControl ( vehicle ) = control_manual then
107142: LD_VAR 0 1
107146: PPUSH
107147: CALL_OW 263
107151: PUSH
107152: LD_INT 1
107154: EQUAL
107155: IFFALSE 107236
// begin driver := IsDrivenBy ( vehicle ) ;
107157: LD_ADDR_VAR 0 4
107161: PUSH
107162: LD_VAR 0 1
107166: PPUSH
107167: CALL_OW 311
107171: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107172: LD_VAR 0 4
107176: PPUSH
107177: LD_EXP 198
107181: PUSH
107182: LD_VAR 0 2
107186: ARRAY
107187: PUSH
107188: LD_INT 3
107190: ARRAY
107191: PPUSH
107192: LD_EXP 198
107196: PUSH
107197: LD_VAR 0 2
107201: ARRAY
107202: PUSH
107203: LD_INT 4
107205: ARRAY
107206: PPUSH
107207: CALL_OW 171
// AddComExitVehicle ( driver ) ;
107211: LD_VAR 0 4
107215: PPUSH
107216: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
107220: LD_VAR 0 4
107224: PPUSH
107225: LD_VAR 0 2
107229: PPUSH
107230: CALL_OW 180
// end else
107234: GO 107349
// if GetControl ( vehicle ) = control_remote then
107236: LD_VAR 0 1
107240: PPUSH
107241: CALL_OW 263
107245: PUSH
107246: LD_INT 2
107248: EQUAL
107249: IFFALSE 107310
// begin wait ( 0 0$2 ) ;
107251: LD_INT 70
107253: PPUSH
107254: CALL_OW 67
// if Connect ( vehicle ) then
107258: LD_VAR 0 1
107262: PPUSH
107263: CALL 60164 0 1
107267: IFFALSE 107308
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107269: LD_VAR 0 1
107273: PPUSH
107274: LD_EXP 198
107278: PUSH
107279: LD_VAR 0 2
107283: ARRAY
107284: PUSH
107285: LD_INT 3
107287: ARRAY
107288: PPUSH
107289: LD_EXP 198
107293: PUSH
107294: LD_VAR 0 2
107298: ARRAY
107299: PUSH
107300: LD_INT 4
107302: ARRAY
107303: PPUSH
107304: CALL_OW 171
// end else
107308: GO 107349
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107310: LD_VAR 0 1
107314: PPUSH
107315: LD_EXP 198
107319: PUSH
107320: LD_VAR 0 2
107324: ARRAY
107325: PUSH
107326: LD_INT 3
107328: ARRAY
107329: PPUSH
107330: LD_EXP 198
107334: PUSH
107335: LD_VAR 0 2
107339: ARRAY
107340: PUSH
107341: LD_INT 4
107343: ARRAY
107344: PPUSH
107345: CALL_OW 171
// end ; end ;
107349: LD_VAR 0 3
107353: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
107354: LD_INT 0
107356: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
107357: LD_VAR 0 1
107361: PUSH
107362: LD_INT 250
107364: EQUAL
107365: PUSH
107366: LD_VAR 0 2
107370: PPUSH
107371: CALL_OW 264
107375: PUSH
107376: LD_EXP 81
107380: EQUAL
107381: AND
107382: IFFALSE 107403
// MinerPlaceMine ( unit , x , y ) ;
107384: LD_VAR 0 2
107388: PPUSH
107389: LD_VAR 0 4
107393: PPUSH
107394: LD_VAR 0 5
107398: PPUSH
107399: CALL 110131 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
107403: LD_VAR 0 1
107407: PUSH
107408: LD_INT 251
107410: EQUAL
107411: PUSH
107412: LD_VAR 0 2
107416: PPUSH
107417: CALL_OW 264
107421: PUSH
107422: LD_EXP 81
107426: EQUAL
107427: AND
107428: IFFALSE 107449
// MinerDetonateMine ( unit , x , y ) ;
107430: LD_VAR 0 2
107434: PPUSH
107435: LD_VAR 0 4
107439: PPUSH
107440: LD_VAR 0 5
107444: PPUSH
107445: CALL 110408 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
107449: LD_VAR 0 1
107453: PUSH
107454: LD_INT 252
107456: EQUAL
107457: PUSH
107458: LD_VAR 0 2
107462: PPUSH
107463: CALL_OW 264
107467: PUSH
107468: LD_EXP 81
107472: EQUAL
107473: AND
107474: IFFALSE 107495
// MinerCreateMinefield ( unit , x , y ) ;
107476: LD_VAR 0 2
107480: PPUSH
107481: LD_VAR 0 4
107485: PPUSH
107486: LD_VAR 0 5
107490: PPUSH
107491: CALL 110825 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
107495: LD_VAR 0 1
107499: PUSH
107500: LD_INT 253
107502: EQUAL
107503: PUSH
107504: LD_VAR 0 2
107508: PPUSH
107509: CALL_OW 257
107513: PUSH
107514: LD_INT 5
107516: EQUAL
107517: AND
107518: IFFALSE 107539
// ComBinocular ( unit , x , y ) ;
107520: LD_VAR 0 2
107524: PPUSH
107525: LD_VAR 0 4
107529: PPUSH
107530: LD_VAR 0 5
107534: PPUSH
107535: CALL 111196 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
107539: LD_VAR 0 1
107543: PUSH
107544: LD_INT 254
107546: EQUAL
107547: PUSH
107548: LD_VAR 0 2
107552: PPUSH
107553: CALL_OW 264
107557: PUSH
107558: LD_EXP 76
107562: EQUAL
107563: AND
107564: PUSH
107565: LD_VAR 0 3
107569: PPUSH
107570: CALL_OW 263
107574: PUSH
107575: LD_INT 3
107577: EQUAL
107578: AND
107579: IFFALSE 107595
// HackDestroyVehicle ( unit , selectedUnit ) ;
107581: LD_VAR 0 2
107585: PPUSH
107586: LD_VAR 0 3
107590: PPUSH
107591: CALL 109491 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107595: LD_VAR 0 1
107599: PUSH
107600: LD_INT 255
107602: EQUAL
107603: PUSH
107604: LD_VAR 0 2
107608: PPUSH
107609: CALL_OW 264
107613: PUSH
107614: LD_INT 14
107616: PUSH
107617: LD_INT 53
107619: PUSH
107620: EMPTY
107621: LIST
107622: LIST
107623: IN
107624: AND
107625: PUSH
107626: LD_VAR 0 4
107630: PPUSH
107631: LD_VAR 0 5
107635: PPUSH
107636: CALL_OW 488
107640: AND
107641: IFFALSE 107665
// CutTreeXYR ( unit , x , y , 12 ) ;
107643: LD_VAR 0 2
107647: PPUSH
107648: LD_VAR 0 4
107652: PPUSH
107653: LD_VAR 0 5
107657: PPUSH
107658: LD_INT 12
107660: PPUSH
107661: CALL 108057 0 4
// if cmd = 256 then
107665: LD_VAR 0 1
107669: PUSH
107670: LD_INT 256
107672: EQUAL
107673: IFFALSE 107694
// SetFactoryWaypoint ( unit , x , y ) ;
107675: LD_VAR 0 2
107679: PPUSH
107680: LD_VAR 0 4
107684: PPUSH
107685: LD_VAR 0 5
107689: PPUSH
107690: CALL 107699 0 3
// end ;
107694: LD_VAR 0 6
107698: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107699: LD_INT 0
107701: PPUSH
107702: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107703: LD_VAR 0 1
107707: NOT
107708: PUSH
107709: LD_VAR 0 2
107713: PPUSH
107714: LD_VAR 0 3
107718: PPUSH
107719: CALL_OW 488
107723: NOT
107724: OR
107725: PUSH
107726: LD_VAR 0 1
107730: PPUSH
107731: CALL_OW 266
107735: PUSH
107736: LD_INT 3
107738: NONEQUAL
107739: PUSH
107740: LD_VAR 0 1
107744: PPUSH
107745: CALL_OW 247
107749: PUSH
107750: LD_INT 1
107752: EQUAL
107753: NOT
107754: AND
107755: OR
107756: IFFALSE 107760
// exit ;
107758: GO 107909
// if GetType ( factory ) = unit_human then
107760: LD_VAR 0 1
107764: PPUSH
107765: CALL_OW 247
107769: PUSH
107770: LD_INT 1
107772: EQUAL
107773: IFFALSE 107790
// factory := IsInUnit ( factory ) ;
107775: LD_ADDR_VAR 0 1
107779: PUSH
107780: LD_VAR 0 1
107784: PPUSH
107785: CALL_OW 310
107789: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
107790: LD_VAR 0 1
107794: PPUSH
107795: CALL_OW 266
107799: PUSH
107800: LD_INT 3
107802: NONEQUAL
107803: IFFALSE 107807
// exit ;
107805: GO 107909
// if HexInfo ( x , y ) = factory then
107807: LD_VAR 0 2
107811: PPUSH
107812: LD_VAR 0 3
107816: PPUSH
107817: CALL_OW 428
107821: PUSH
107822: LD_VAR 0 1
107826: EQUAL
107827: IFFALSE 107854
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
107829: LD_ADDR_EXP 198
107833: PUSH
107834: LD_EXP 198
107838: PPUSH
107839: LD_VAR 0 1
107843: PPUSH
107844: LD_INT 0
107846: PPUSH
107847: CALL_OW 1
107851: ST_TO_ADDR
107852: GO 107905
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
107854: LD_ADDR_EXP 198
107858: PUSH
107859: LD_EXP 198
107863: PPUSH
107864: LD_VAR 0 1
107868: PPUSH
107869: LD_VAR 0 1
107873: PPUSH
107874: CALL_OW 255
107878: PUSH
107879: LD_VAR 0 1
107883: PUSH
107884: LD_VAR 0 2
107888: PUSH
107889: LD_VAR 0 3
107893: PUSH
107894: EMPTY
107895: LIST
107896: LIST
107897: LIST
107898: LIST
107899: PPUSH
107900: CALL_OW 1
107904: ST_TO_ADDR
// UpdateFactoryWaypoints ;
107905: CALL 107914 0 0
// end ;
107909: LD_VAR 0 4
107913: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
107914: LD_INT 0
107916: PPUSH
107917: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
107918: LD_STRING resetFactoryWaypoint();
107920: PPUSH
107921: CALL_OW 559
// if factoryWaypoints then
107925: LD_EXP 198
107929: IFFALSE 108052
// begin for i := 1 to factoryWaypoints do
107931: LD_ADDR_VAR 0 2
107935: PUSH
107936: DOUBLE
107937: LD_INT 1
107939: DEC
107940: ST_TO_ADDR
107941: LD_EXP 198
107945: PUSH
107946: FOR_TO
107947: IFFALSE 108050
// if factoryWaypoints [ i ] then
107949: LD_EXP 198
107953: PUSH
107954: LD_VAR 0 2
107958: ARRAY
107959: IFFALSE 108048
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
107961: LD_STRING setFactoryWaypointXY(
107963: PUSH
107964: LD_EXP 198
107968: PUSH
107969: LD_VAR 0 2
107973: ARRAY
107974: PUSH
107975: LD_INT 1
107977: ARRAY
107978: STR
107979: PUSH
107980: LD_STRING ,
107982: STR
107983: PUSH
107984: LD_EXP 198
107988: PUSH
107989: LD_VAR 0 2
107993: ARRAY
107994: PUSH
107995: LD_INT 2
107997: ARRAY
107998: STR
107999: PUSH
108000: LD_STRING ,
108002: STR
108003: PUSH
108004: LD_EXP 198
108008: PUSH
108009: LD_VAR 0 2
108013: ARRAY
108014: PUSH
108015: LD_INT 3
108017: ARRAY
108018: STR
108019: PUSH
108020: LD_STRING ,
108022: STR
108023: PUSH
108024: LD_EXP 198
108028: PUSH
108029: LD_VAR 0 2
108033: ARRAY
108034: PUSH
108035: LD_INT 4
108037: ARRAY
108038: STR
108039: PUSH
108040: LD_STRING )
108042: STR
108043: PPUSH
108044: CALL_OW 559
108048: GO 107946
108050: POP
108051: POP
// end ; end ;
108052: LD_VAR 0 1
108056: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108057: LD_INT 0
108059: PPUSH
108060: PPUSH
108061: PPUSH
108062: PPUSH
108063: PPUSH
108064: PPUSH
108065: PPUSH
108066: PPUSH
108067: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108068: LD_VAR 0 1
108072: NOT
108073: PUSH
108074: LD_VAR 0 2
108078: PPUSH
108079: LD_VAR 0 3
108083: PPUSH
108084: CALL_OW 488
108088: NOT
108089: OR
108090: PUSH
108091: LD_VAR 0 4
108095: NOT
108096: OR
108097: IFFALSE 108101
// exit ;
108099: GO 108441
// list := [ ] ;
108101: LD_ADDR_VAR 0 13
108105: PUSH
108106: EMPTY
108107: ST_TO_ADDR
// if x - r < 0 then
108108: LD_VAR 0 2
108112: PUSH
108113: LD_VAR 0 4
108117: MINUS
108118: PUSH
108119: LD_INT 0
108121: LESS
108122: IFFALSE 108134
// min_x := 0 else
108124: LD_ADDR_VAR 0 7
108128: PUSH
108129: LD_INT 0
108131: ST_TO_ADDR
108132: GO 108150
// min_x := x - r ;
108134: LD_ADDR_VAR 0 7
108138: PUSH
108139: LD_VAR 0 2
108143: PUSH
108144: LD_VAR 0 4
108148: MINUS
108149: ST_TO_ADDR
// if y - r < 0 then
108150: LD_VAR 0 3
108154: PUSH
108155: LD_VAR 0 4
108159: MINUS
108160: PUSH
108161: LD_INT 0
108163: LESS
108164: IFFALSE 108176
// min_y := 0 else
108166: LD_ADDR_VAR 0 8
108170: PUSH
108171: LD_INT 0
108173: ST_TO_ADDR
108174: GO 108192
// min_y := y - r ;
108176: LD_ADDR_VAR 0 8
108180: PUSH
108181: LD_VAR 0 3
108185: PUSH
108186: LD_VAR 0 4
108190: MINUS
108191: ST_TO_ADDR
// max_x := x + r ;
108192: LD_ADDR_VAR 0 9
108196: PUSH
108197: LD_VAR 0 2
108201: PUSH
108202: LD_VAR 0 4
108206: PLUS
108207: ST_TO_ADDR
// max_y := y + r ;
108208: LD_ADDR_VAR 0 10
108212: PUSH
108213: LD_VAR 0 3
108217: PUSH
108218: LD_VAR 0 4
108222: PLUS
108223: ST_TO_ADDR
// for _x = min_x to max_x do
108224: LD_ADDR_VAR 0 11
108228: PUSH
108229: DOUBLE
108230: LD_VAR 0 7
108234: DEC
108235: ST_TO_ADDR
108236: LD_VAR 0 9
108240: PUSH
108241: FOR_TO
108242: IFFALSE 108359
// for _y = min_y to max_y do
108244: LD_ADDR_VAR 0 12
108248: PUSH
108249: DOUBLE
108250: LD_VAR 0 8
108254: DEC
108255: ST_TO_ADDR
108256: LD_VAR 0 10
108260: PUSH
108261: FOR_TO
108262: IFFALSE 108355
// begin if not ValidHex ( _x , _y ) then
108264: LD_VAR 0 11
108268: PPUSH
108269: LD_VAR 0 12
108273: PPUSH
108274: CALL_OW 488
108278: NOT
108279: IFFALSE 108283
// continue ;
108281: GO 108261
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108283: LD_VAR 0 11
108287: PPUSH
108288: LD_VAR 0 12
108292: PPUSH
108293: CALL_OW 351
108297: PUSH
108298: LD_VAR 0 11
108302: PPUSH
108303: LD_VAR 0 12
108307: PPUSH
108308: CALL_OW 554
108312: AND
108313: IFFALSE 108353
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108315: LD_ADDR_VAR 0 13
108319: PUSH
108320: LD_VAR 0 13
108324: PPUSH
108325: LD_VAR 0 13
108329: PUSH
108330: LD_INT 1
108332: PLUS
108333: PPUSH
108334: LD_VAR 0 11
108338: PUSH
108339: LD_VAR 0 12
108343: PUSH
108344: EMPTY
108345: LIST
108346: LIST
108347: PPUSH
108348: CALL_OW 2
108352: ST_TO_ADDR
// end ;
108353: GO 108261
108355: POP
108356: POP
108357: GO 108241
108359: POP
108360: POP
// if not list then
108361: LD_VAR 0 13
108365: NOT
108366: IFFALSE 108370
// exit ;
108368: GO 108441
// for i in list do
108370: LD_ADDR_VAR 0 6
108374: PUSH
108375: LD_VAR 0 13
108379: PUSH
108380: FOR_IN
108381: IFFALSE 108439
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108383: LD_VAR 0 1
108387: PPUSH
108388: LD_STRING M
108390: PUSH
108391: LD_VAR 0 6
108395: PUSH
108396: LD_INT 1
108398: ARRAY
108399: PUSH
108400: LD_VAR 0 6
108404: PUSH
108405: LD_INT 2
108407: ARRAY
108408: PUSH
108409: LD_INT 0
108411: PUSH
108412: LD_INT 0
108414: PUSH
108415: LD_INT 0
108417: PUSH
108418: LD_INT 0
108420: PUSH
108421: EMPTY
108422: LIST
108423: LIST
108424: LIST
108425: LIST
108426: LIST
108427: LIST
108428: LIST
108429: PUSH
108430: EMPTY
108431: LIST
108432: PPUSH
108433: CALL_OW 447
108437: GO 108380
108439: POP
108440: POP
// end ;
108441: LD_VAR 0 5
108445: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108446: LD_EXP 199
108450: NOT
108451: IFFALSE 108501
108453: GO 108455
108455: DISABLE
// begin initHack := true ;
108456: LD_ADDR_EXP 199
108460: PUSH
108461: LD_INT 1
108463: ST_TO_ADDR
// hackTanks := [ ] ;
108464: LD_ADDR_EXP 200
108468: PUSH
108469: EMPTY
108470: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108471: LD_ADDR_EXP 201
108475: PUSH
108476: EMPTY
108477: ST_TO_ADDR
// hackLimit := 3 ;
108478: LD_ADDR_EXP 202
108482: PUSH
108483: LD_INT 3
108485: ST_TO_ADDR
// hackDist := 12 ;
108486: LD_ADDR_EXP 203
108490: PUSH
108491: LD_INT 12
108493: ST_TO_ADDR
// hackCounter := [ ] ;
108494: LD_ADDR_EXP 204
108498: PUSH
108499: EMPTY
108500: ST_TO_ADDR
// end ;
108501: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108502: LD_EXP 199
108506: PUSH
108507: LD_INT 34
108509: PUSH
108510: LD_EXP 76
108514: PUSH
108515: EMPTY
108516: LIST
108517: LIST
108518: PPUSH
108519: CALL_OW 69
108523: AND
108524: IFFALSE 108779
108526: GO 108528
108528: DISABLE
108529: LD_INT 0
108531: PPUSH
108532: PPUSH
// begin enable ;
108533: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108534: LD_ADDR_VAR 0 1
108538: PUSH
108539: LD_INT 34
108541: PUSH
108542: LD_EXP 76
108546: PUSH
108547: EMPTY
108548: LIST
108549: LIST
108550: PPUSH
108551: CALL_OW 69
108555: PUSH
108556: FOR_IN
108557: IFFALSE 108777
// begin if not i in hackTanks then
108559: LD_VAR 0 1
108563: PUSH
108564: LD_EXP 200
108568: IN
108569: NOT
108570: IFFALSE 108653
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
108572: LD_ADDR_EXP 200
108576: PUSH
108577: LD_EXP 200
108581: PPUSH
108582: LD_EXP 200
108586: PUSH
108587: LD_INT 1
108589: PLUS
108590: PPUSH
108591: LD_VAR 0 1
108595: PPUSH
108596: CALL_OW 1
108600: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
108601: LD_ADDR_EXP 201
108605: PUSH
108606: LD_EXP 201
108610: PPUSH
108611: LD_EXP 201
108615: PUSH
108616: LD_INT 1
108618: PLUS
108619: PPUSH
108620: EMPTY
108621: PPUSH
108622: CALL_OW 1
108626: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
108627: LD_ADDR_EXP 204
108631: PUSH
108632: LD_EXP 204
108636: PPUSH
108637: LD_EXP 204
108641: PUSH
108642: LD_INT 1
108644: PLUS
108645: PPUSH
108646: EMPTY
108647: PPUSH
108648: CALL_OW 1
108652: ST_TO_ADDR
// end ; if not IsOk ( i ) then
108653: LD_VAR 0 1
108657: PPUSH
108658: CALL_OW 302
108662: NOT
108663: IFFALSE 108676
// begin HackUnlinkAll ( i ) ;
108665: LD_VAR 0 1
108669: PPUSH
108670: CALL 108782 0 1
// continue ;
108674: GO 108556
// end ; HackCheckCapturedStatus ( i ) ;
108676: LD_VAR 0 1
108680: PPUSH
108681: CALL 109225 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
108685: LD_ADDR_VAR 0 2
108689: PUSH
108690: LD_INT 81
108692: PUSH
108693: LD_VAR 0 1
108697: PPUSH
108698: CALL_OW 255
108702: PUSH
108703: EMPTY
108704: LIST
108705: LIST
108706: PUSH
108707: LD_INT 33
108709: PUSH
108710: LD_INT 3
108712: PUSH
108713: EMPTY
108714: LIST
108715: LIST
108716: PUSH
108717: LD_INT 91
108719: PUSH
108720: LD_VAR 0 1
108724: PUSH
108725: LD_EXP 203
108729: PUSH
108730: EMPTY
108731: LIST
108732: LIST
108733: LIST
108734: PUSH
108735: LD_INT 50
108737: PUSH
108738: EMPTY
108739: LIST
108740: PUSH
108741: EMPTY
108742: LIST
108743: LIST
108744: LIST
108745: LIST
108746: PPUSH
108747: CALL_OW 69
108751: ST_TO_ADDR
// if not tmp then
108752: LD_VAR 0 2
108756: NOT
108757: IFFALSE 108761
// continue ;
108759: GO 108556
// HackLink ( i , tmp ) ;
108761: LD_VAR 0 1
108765: PPUSH
108766: LD_VAR 0 2
108770: PPUSH
108771: CALL 108918 0 2
// end ;
108775: GO 108556
108777: POP
108778: POP
// end ;
108779: PPOPN 2
108781: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
108782: LD_INT 0
108784: PPUSH
108785: PPUSH
108786: PPUSH
// if not hack in hackTanks then
108787: LD_VAR 0 1
108791: PUSH
108792: LD_EXP 200
108796: IN
108797: NOT
108798: IFFALSE 108802
// exit ;
108800: GO 108913
// index := GetElementIndex ( hackTanks , hack ) ;
108802: LD_ADDR_VAR 0 4
108806: PUSH
108807: LD_EXP 200
108811: PPUSH
108812: LD_VAR 0 1
108816: PPUSH
108817: CALL 56978 0 2
108821: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
108822: LD_EXP 201
108826: PUSH
108827: LD_VAR 0 4
108831: ARRAY
108832: IFFALSE 108913
// begin for i in hackTanksCaptured [ index ] do
108834: LD_ADDR_VAR 0 3
108838: PUSH
108839: LD_EXP 201
108843: PUSH
108844: LD_VAR 0 4
108848: ARRAY
108849: PUSH
108850: FOR_IN
108851: IFFALSE 108877
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
108853: LD_VAR 0 3
108857: PUSH
108858: LD_INT 1
108860: ARRAY
108861: PPUSH
108862: LD_VAR 0 3
108866: PUSH
108867: LD_INT 2
108869: ARRAY
108870: PPUSH
108871: CALL_OW 235
108875: GO 108850
108877: POP
108878: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
108879: LD_ADDR_EXP 201
108883: PUSH
108884: LD_EXP 201
108888: PPUSH
108889: LD_VAR 0 4
108893: PPUSH
108894: EMPTY
108895: PPUSH
108896: CALL_OW 1
108900: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
108901: LD_VAR 0 1
108905: PPUSH
108906: LD_INT 0
108908: PPUSH
108909: CALL_OW 505
// end ; end ;
108913: LD_VAR 0 2
108917: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
108918: LD_INT 0
108920: PPUSH
108921: PPUSH
108922: PPUSH
// if not hack in hackTanks or not vehicles then
108923: LD_VAR 0 1
108927: PUSH
108928: LD_EXP 200
108932: IN
108933: NOT
108934: PUSH
108935: LD_VAR 0 2
108939: NOT
108940: OR
108941: IFFALSE 108945
// exit ;
108943: GO 109220
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
108945: LD_ADDR_VAR 0 2
108949: PUSH
108950: LD_VAR 0 1
108954: PPUSH
108955: LD_VAR 0 2
108959: PPUSH
108960: LD_INT 1
108962: PPUSH
108963: LD_INT 1
108965: PPUSH
108966: CALL 57628 0 4
108970: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
108971: LD_ADDR_VAR 0 5
108975: PUSH
108976: LD_EXP 200
108980: PPUSH
108981: LD_VAR 0 1
108985: PPUSH
108986: CALL 56978 0 2
108990: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108991: LD_EXP 201
108995: PUSH
108996: LD_VAR 0 5
109000: ARRAY
109001: PUSH
109002: LD_EXP 202
109006: LESS
109007: IFFALSE 109196
// begin for i := 1 to vehicles do
109009: LD_ADDR_VAR 0 4
109013: PUSH
109014: DOUBLE
109015: LD_INT 1
109017: DEC
109018: ST_TO_ADDR
109019: LD_VAR 0 2
109023: PUSH
109024: FOR_TO
109025: IFFALSE 109194
// begin if hackTanksCaptured [ index ] = hackLimit then
109027: LD_EXP 201
109031: PUSH
109032: LD_VAR 0 5
109036: ARRAY
109037: PUSH
109038: LD_EXP 202
109042: EQUAL
109043: IFFALSE 109047
// break ;
109045: GO 109194
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109047: LD_ADDR_EXP 204
109051: PUSH
109052: LD_EXP 204
109056: PPUSH
109057: LD_VAR 0 5
109061: PPUSH
109062: LD_EXP 204
109066: PUSH
109067: LD_VAR 0 5
109071: ARRAY
109072: PUSH
109073: LD_INT 1
109075: PLUS
109076: PPUSH
109077: CALL_OW 1
109081: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109082: LD_ADDR_EXP 201
109086: PUSH
109087: LD_EXP 201
109091: PPUSH
109092: LD_VAR 0 5
109096: PUSH
109097: LD_EXP 201
109101: PUSH
109102: LD_VAR 0 5
109106: ARRAY
109107: PUSH
109108: LD_INT 1
109110: PLUS
109111: PUSH
109112: EMPTY
109113: LIST
109114: LIST
109115: PPUSH
109116: LD_VAR 0 2
109120: PUSH
109121: LD_VAR 0 4
109125: ARRAY
109126: PUSH
109127: LD_VAR 0 2
109131: PUSH
109132: LD_VAR 0 4
109136: ARRAY
109137: PPUSH
109138: CALL_OW 255
109142: PUSH
109143: EMPTY
109144: LIST
109145: LIST
109146: PPUSH
109147: CALL 57193 0 3
109151: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109152: LD_VAR 0 2
109156: PUSH
109157: LD_VAR 0 4
109161: ARRAY
109162: PPUSH
109163: LD_VAR 0 1
109167: PPUSH
109168: CALL_OW 255
109172: PPUSH
109173: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109177: LD_VAR 0 2
109181: PUSH
109182: LD_VAR 0 4
109186: ARRAY
109187: PPUSH
109188: CALL_OW 141
// end ;
109192: GO 109024
109194: POP
109195: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109196: LD_VAR 0 1
109200: PPUSH
109201: LD_EXP 201
109205: PUSH
109206: LD_VAR 0 5
109210: ARRAY
109211: PUSH
109212: LD_INT 0
109214: PLUS
109215: PPUSH
109216: CALL_OW 505
// end ;
109220: LD_VAR 0 3
109224: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109225: LD_INT 0
109227: PPUSH
109228: PPUSH
109229: PPUSH
109230: PPUSH
// if not hack in hackTanks then
109231: LD_VAR 0 1
109235: PUSH
109236: LD_EXP 200
109240: IN
109241: NOT
109242: IFFALSE 109246
// exit ;
109244: GO 109486
// index := GetElementIndex ( hackTanks , hack ) ;
109246: LD_ADDR_VAR 0 4
109250: PUSH
109251: LD_EXP 200
109255: PPUSH
109256: LD_VAR 0 1
109260: PPUSH
109261: CALL 56978 0 2
109265: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109266: LD_ADDR_VAR 0 3
109270: PUSH
109271: DOUBLE
109272: LD_EXP 201
109276: PUSH
109277: LD_VAR 0 4
109281: ARRAY
109282: INC
109283: ST_TO_ADDR
109284: LD_INT 1
109286: PUSH
109287: FOR_DOWNTO
109288: IFFALSE 109460
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109290: LD_ADDR_VAR 0 5
109294: PUSH
109295: LD_EXP 201
109299: PUSH
109300: LD_VAR 0 4
109304: ARRAY
109305: PUSH
109306: LD_VAR 0 3
109310: ARRAY
109311: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109312: LD_VAR 0 5
109316: PUSH
109317: LD_INT 1
109319: ARRAY
109320: PPUSH
109321: CALL_OW 302
109325: NOT
109326: PUSH
109327: LD_VAR 0 5
109331: PUSH
109332: LD_INT 1
109334: ARRAY
109335: PPUSH
109336: CALL_OW 255
109340: PUSH
109341: LD_VAR 0 1
109345: PPUSH
109346: CALL_OW 255
109350: NONEQUAL
109351: OR
109352: IFFALSE 109458
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109354: LD_VAR 0 5
109358: PUSH
109359: LD_INT 1
109361: ARRAY
109362: PPUSH
109363: CALL_OW 305
109367: PUSH
109368: LD_VAR 0 5
109372: PUSH
109373: LD_INT 1
109375: ARRAY
109376: PPUSH
109377: CALL_OW 255
109381: PUSH
109382: LD_VAR 0 1
109386: PPUSH
109387: CALL_OW 255
109391: EQUAL
109392: AND
109393: IFFALSE 109417
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109395: LD_VAR 0 5
109399: PUSH
109400: LD_INT 1
109402: ARRAY
109403: PPUSH
109404: LD_VAR 0 5
109408: PUSH
109409: LD_INT 2
109411: ARRAY
109412: PPUSH
109413: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109417: LD_ADDR_EXP 201
109421: PUSH
109422: LD_EXP 201
109426: PPUSH
109427: LD_VAR 0 4
109431: PPUSH
109432: LD_EXP 201
109436: PUSH
109437: LD_VAR 0 4
109441: ARRAY
109442: PPUSH
109443: LD_VAR 0 3
109447: PPUSH
109448: CALL_OW 3
109452: PPUSH
109453: CALL_OW 1
109457: ST_TO_ADDR
// end ; end ;
109458: GO 109287
109460: POP
109461: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109462: LD_VAR 0 1
109466: PPUSH
109467: LD_EXP 201
109471: PUSH
109472: LD_VAR 0 4
109476: ARRAY
109477: PUSH
109478: LD_INT 0
109480: PLUS
109481: PPUSH
109482: CALL_OW 505
// end ;
109486: LD_VAR 0 2
109490: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109491: LD_INT 0
109493: PPUSH
109494: PPUSH
109495: PPUSH
109496: PPUSH
// if not hack in hackTanks then
109497: LD_VAR 0 1
109501: PUSH
109502: LD_EXP 200
109506: IN
109507: NOT
109508: IFFALSE 109512
// exit ;
109510: GO 109597
// index := GetElementIndex ( hackTanks , hack ) ;
109512: LD_ADDR_VAR 0 5
109516: PUSH
109517: LD_EXP 200
109521: PPUSH
109522: LD_VAR 0 1
109526: PPUSH
109527: CALL 56978 0 2
109531: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109532: LD_ADDR_VAR 0 4
109536: PUSH
109537: DOUBLE
109538: LD_INT 1
109540: DEC
109541: ST_TO_ADDR
109542: LD_EXP 201
109546: PUSH
109547: LD_VAR 0 5
109551: ARRAY
109552: PUSH
109553: FOR_TO
109554: IFFALSE 109595
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109556: LD_EXP 201
109560: PUSH
109561: LD_VAR 0 5
109565: ARRAY
109566: PUSH
109567: LD_VAR 0 4
109571: ARRAY
109572: PUSH
109573: LD_INT 1
109575: ARRAY
109576: PUSH
109577: LD_VAR 0 2
109581: EQUAL
109582: IFFALSE 109593
// KillUnit ( vehicle ) ;
109584: LD_VAR 0 2
109588: PPUSH
109589: CALL_OW 66
109593: GO 109553
109595: POP
109596: POP
// end ;
109597: LD_VAR 0 3
109601: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
109602: LD_EXP 205
109606: NOT
109607: IFFALSE 109642
109609: GO 109611
109611: DISABLE
// begin initMiner := true ;
109612: LD_ADDR_EXP 205
109616: PUSH
109617: LD_INT 1
109619: ST_TO_ADDR
// minersList := [ ] ;
109620: LD_ADDR_EXP 206
109624: PUSH
109625: EMPTY
109626: ST_TO_ADDR
// minerMinesList := [ ] ;
109627: LD_ADDR_EXP 207
109631: PUSH
109632: EMPTY
109633: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
109634: LD_ADDR_EXP 208
109638: PUSH
109639: LD_INT 5
109641: ST_TO_ADDR
// end ;
109642: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
109643: LD_EXP 205
109647: PUSH
109648: LD_INT 34
109650: PUSH
109651: LD_EXP 81
109655: PUSH
109656: EMPTY
109657: LIST
109658: LIST
109659: PPUSH
109660: CALL_OW 69
109664: AND
109665: IFFALSE 110128
109667: GO 109669
109669: DISABLE
109670: LD_INT 0
109672: PPUSH
109673: PPUSH
109674: PPUSH
109675: PPUSH
// begin enable ;
109676: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
109677: LD_ADDR_VAR 0 1
109681: PUSH
109682: LD_INT 34
109684: PUSH
109685: LD_EXP 81
109689: PUSH
109690: EMPTY
109691: LIST
109692: LIST
109693: PPUSH
109694: CALL_OW 69
109698: PUSH
109699: FOR_IN
109700: IFFALSE 109772
// begin if not i in minersList then
109702: LD_VAR 0 1
109706: PUSH
109707: LD_EXP 206
109711: IN
109712: NOT
109713: IFFALSE 109770
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
109715: LD_ADDR_EXP 206
109719: PUSH
109720: LD_EXP 206
109724: PPUSH
109725: LD_EXP 206
109729: PUSH
109730: LD_INT 1
109732: PLUS
109733: PPUSH
109734: LD_VAR 0 1
109738: PPUSH
109739: CALL_OW 1
109743: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
109744: LD_ADDR_EXP 207
109748: PUSH
109749: LD_EXP 207
109753: PPUSH
109754: LD_EXP 207
109758: PUSH
109759: LD_INT 1
109761: PLUS
109762: PPUSH
109763: EMPTY
109764: PPUSH
109765: CALL_OW 1
109769: ST_TO_ADDR
// end end ;
109770: GO 109699
109772: POP
109773: POP
// for i := minerMinesList downto 1 do
109774: LD_ADDR_VAR 0 1
109778: PUSH
109779: DOUBLE
109780: LD_EXP 207
109784: INC
109785: ST_TO_ADDR
109786: LD_INT 1
109788: PUSH
109789: FOR_DOWNTO
109790: IFFALSE 110126
// begin if IsLive ( minersList [ i ] ) then
109792: LD_EXP 206
109796: PUSH
109797: LD_VAR 0 1
109801: ARRAY
109802: PPUSH
109803: CALL_OW 300
109807: IFFALSE 109835
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
109809: LD_EXP 206
109813: PUSH
109814: LD_VAR 0 1
109818: ARRAY
109819: PPUSH
109820: LD_EXP 207
109824: PUSH
109825: LD_VAR 0 1
109829: ARRAY
109830: PPUSH
109831: CALL_OW 505
// if not minerMinesList [ i ] then
109835: LD_EXP 207
109839: PUSH
109840: LD_VAR 0 1
109844: ARRAY
109845: NOT
109846: IFFALSE 109850
// continue ;
109848: GO 109789
// for j := minerMinesList [ i ] downto 1 do
109850: LD_ADDR_VAR 0 2
109854: PUSH
109855: DOUBLE
109856: LD_EXP 207
109860: PUSH
109861: LD_VAR 0 1
109865: ARRAY
109866: INC
109867: ST_TO_ADDR
109868: LD_INT 1
109870: PUSH
109871: FOR_DOWNTO
109872: IFFALSE 110122
// begin side := GetSide ( minersList [ i ] ) ;
109874: LD_ADDR_VAR 0 3
109878: PUSH
109879: LD_EXP 206
109883: PUSH
109884: LD_VAR 0 1
109888: ARRAY
109889: PPUSH
109890: CALL_OW 255
109894: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
109895: LD_ADDR_VAR 0 4
109899: PUSH
109900: LD_EXP 207
109904: PUSH
109905: LD_VAR 0 1
109909: ARRAY
109910: PUSH
109911: LD_VAR 0 2
109915: ARRAY
109916: PUSH
109917: LD_INT 1
109919: ARRAY
109920: PPUSH
109921: LD_EXP 207
109925: PUSH
109926: LD_VAR 0 1
109930: ARRAY
109931: PUSH
109932: LD_VAR 0 2
109936: ARRAY
109937: PUSH
109938: LD_INT 2
109940: ARRAY
109941: PPUSH
109942: CALL_OW 428
109946: ST_TO_ADDR
// if not tmp then
109947: LD_VAR 0 4
109951: NOT
109952: IFFALSE 109956
// continue ;
109954: GO 109871
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
109956: LD_VAR 0 4
109960: PUSH
109961: LD_INT 81
109963: PUSH
109964: LD_VAR 0 3
109968: PUSH
109969: EMPTY
109970: LIST
109971: LIST
109972: PPUSH
109973: CALL_OW 69
109977: IN
109978: PUSH
109979: LD_EXP 207
109983: PUSH
109984: LD_VAR 0 1
109988: ARRAY
109989: PUSH
109990: LD_VAR 0 2
109994: ARRAY
109995: PUSH
109996: LD_INT 1
109998: ARRAY
109999: PPUSH
110000: LD_EXP 207
110004: PUSH
110005: LD_VAR 0 1
110009: ARRAY
110010: PUSH
110011: LD_VAR 0 2
110015: ARRAY
110016: PUSH
110017: LD_INT 2
110019: ARRAY
110020: PPUSH
110021: CALL_OW 458
110025: AND
110026: IFFALSE 110120
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110028: LD_EXP 207
110032: PUSH
110033: LD_VAR 0 1
110037: ARRAY
110038: PUSH
110039: LD_VAR 0 2
110043: ARRAY
110044: PUSH
110045: LD_INT 1
110047: ARRAY
110048: PPUSH
110049: LD_EXP 207
110053: PUSH
110054: LD_VAR 0 1
110058: ARRAY
110059: PUSH
110060: LD_VAR 0 2
110064: ARRAY
110065: PUSH
110066: LD_INT 2
110068: ARRAY
110069: PPUSH
110070: LD_VAR 0 3
110074: PPUSH
110075: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110079: LD_ADDR_EXP 207
110083: PUSH
110084: LD_EXP 207
110088: PPUSH
110089: LD_VAR 0 1
110093: PPUSH
110094: LD_EXP 207
110098: PUSH
110099: LD_VAR 0 1
110103: ARRAY
110104: PPUSH
110105: LD_VAR 0 2
110109: PPUSH
110110: CALL_OW 3
110114: PPUSH
110115: CALL_OW 1
110119: ST_TO_ADDR
// end ; end ;
110120: GO 109871
110122: POP
110123: POP
// end ;
110124: GO 109789
110126: POP
110127: POP
// end ;
110128: PPOPN 4
110130: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110131: LD_INT 0
110133: PPUSH
110134: PPUSH
// result := false ;
110135: LD_ADDR_VAR 0 4
110139: PUSH
110140: LD_INT 0
110142: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110143: LD_VAR 0 1
110147: PPUSH
110148: CALL_OW 264
110152: PUSH
110153: LD_EXP 81
110157: EQUAL
110158: NOT
110159: IFFALSE 110163
// exit ;
110161: GO 110403
// index := GetElementIndex ( minersList , unit ) ;
110163: LD_ADDR_VAR 0 5
110167: PUSH
110168: LD_EXP 206
110172: PPUSH
110173: LD_VAR 0 1
110177: PPUSH
110178: CALL 56978 0 2
110182: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110183: LD_EXP 207
110187: PUSH
110188: LD_VAR 0 5
110192: ARRAY
110193: PUSH
110194: LD_EXP 208
110198: GREATEREQUAL
110199: IFFALSE 110203
// exit ;
110201: GO 110403
// ComMoveXY ( unit , x , y ) ;
110203: LD_VAR 0 1
110207: PPUSH
110208: LD_VAR 0 2
110212: PPUSH
110213: LD_VAR 0 3
110217: PPUSH
110218: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110222: LD_INT 35
110224: PPUSH
110225: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110229: LD_VAR 0 1
110233: PPUSH
110234: LD_VAR 0 2
110238: PPUSH
110239: LD_VAR 0 3
110243: PPUSH
110244: CALL 87697 0 3
110248: NOT
110249: PUSH
110250: LD_VAR 0 1
110254: PPUSH
110255: CALL_OW 314
110259: AND
110260: IFFALSE 110264
// exit ;
110262: GO 110403
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110264: LD_VAR 0 2
110268: PPUSH
110269: LD_VAR 0 3
110273: PPUSH
110274: CALL_OW 428
110278: PUSH
110279: LD_VAR 0 1
110283: EQUAL
110284: PUSH
110285: LD_VAR 0 1
110289: PPUSH
110290: CALL_OW 314
110294: NOT
110295: AND
110296: IFFALSE 110222
// PlaySoundXY ( x , y , PlantMine ) ;
110298: LD_VAR 0 2
110302: PPUSH
110303: LD_VAR 0 3
110307: PPUSH
110308: LD_STRING PlantMine
110310: PPUSH
110311: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110315: LD_VAR 0 2
110319: PPUSH
110320: LD_VAR 0 3
110324: PPUSH
110325: LD_VAR 0 1
110329: PPUSH
110330: CALL_OW 255
110334: PPUSH
110335: LD_INT 0
110337: PPUSH
110338: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110342: LD_ADDR_EXP 207
110346: PUSH
110347: LD_EXP 207
110351: PPUSH
110352: LD_VAR 0 5
110356: PUSH
110357: LD_EXP 207
110361: PUSH
110362: LD_VAR 0 5
110366: ARRAY
110367: PUSH
110368: LD_INT 1
110370: PLUS
110371: PUSH
110372: EMPTY
110373: LIST
110374: LIST
110375: PPUSH
110376: LD_VAR 0 2
110380: PUSH
110381: LD_VAR 0 3
110385: PUSH
110386: EMPTY
110387: LIST
110388: LIST
110389: PPUSH
110390: CALL 57193 0 3
110394: ST_TO_ADDR
// result := true ;
110395: LD_ADDR_VAR 0 4
110399: PUSH
110400: LD_INT 1
110402: ST_TO_ADDR
// end ;
110403: LD_VAR 0 4
110407: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110408: LD_INT 0
110410: PPUSH
110411: PPUSH
110412: PPUSH
// if not unit in minersList then
110413: LD_VAR 0 1
110417: PUSH
110418: LD_EXP 206
110422: IN
110423: NOT
110424: IFFALSE 110428
// exit ;
110426: GO 110820
// index := GetElementIndex ( minersList , unit ) ;
110428: LD_ADDR_VAR 0 6
110432: PUSH
110433: LD_EXP 206
110437: PPUSH
110438: LD_VAR 0 1
110442: PPUSH
110443: CALL 56978 0 2
110447: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110448: LD_ADDR_VAR 0 5
110452: PUSH
110453: DOUBLE
110454: LD_EXP 207
110458: PUSH
110459: LD_VAR 0 6
110463: ARRAY
110464: INC
110465: ST_TO_ADDR
110466: LD_INT 1
110468: PUSH
110469: FOR_DOWNTO
110470: IFFALSE 110631
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110472: LD_EXP 207
110476: PUSH
110477: LD_VAR 0 6
110481: ARRAY
110482: PUSH
110483: LD_VAR 0 5
110487: ARRAY
110488: PUSH
110489: LD_INT 1
110491: ARRAY
110492: PUSH
110493: LD_VAR 0 2
110497: EQUAL
110498: PUSH
110499: LD_EXP 207
110503: PUSH
110504: LD_VAR 0 6
110508: ARRAY
110509: PUSH
110510: LD_VAR 0 5
110514: ARRAY
110515: PUSH
110516: LD_INT 2
110518: ARRAY
110519: PUSH
110520: LD_VAR 0 3
110524: EQUAL
110525: AND
110526: IFFALSE 110629
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110528: LD_EXP 207
110532: PUSH
110533: LD_VAR 0 6
110537: ARRAY
110538: PUSH
110539: LD_VAR 0 5
110543: ARRAY
110544: PUSH
110545: LD_INT 1
110547: ARRAY
110548: PPUSH
110549: LD_EXP 207
110553: PUSH
110554: LD_VAR 0 6
110558: ARRAY
110559: PUSH
110560: LD_VAR 0 5
110564: ARRAY
110565: PUSH
110566: LD_INT 2
110568: ARRAY
110569: PPUSH
110570: LD_VAR 0 1
110574: PPUSH
110575: CALL_OW 255
110579: PPUSH
110580: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110584: LD_ADDR_EXP 207
110588: PUSH
110589: LD_EXP 207
110593: PPUSH
110594: LD_VAR 0 6
110598: PPUSH
110599: LD_EXP 207
110603: PUSH
110604: LD_VAR 0 6
110608: ARRAY
110609: PPUSH
110610: LD_VAR 0 5
110614: PPUSH
110615: CALL_OW 3
110619: PPUSH
110620: CALL_OW 1
110624: ST_TO_ADDR
// exit ;
110625: POP
110626: POP
110627: GO 110820
// end ; end ;
110629: GO 110469
110631: POP
110632: POP
// for i := minerMinesList [ index ] downto 1 do
110633: LD_ADDR_VAR 0 5
110637: PUSH
110638: DOUBLE
110639: LD_EXP 207
110643: PUSH
110644: LD_VAR 0 6
110648: ARRAY
110649: INC
110650: ST_TO_ADDR
110651: LD_INT 1
110653: PUSH
110654: FOR_DOWNTO
110655: IFFALSE 110818
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
110657: LD_EXP 207
110661: PUSH
110662: LD_VAR 0 6
110666: ARRAY
110667: PUSH
110668: LD_VAR 0 5
110672: ARRAY
110673: PUSH
110674: LD_INT 1
110676: ARRAY
110677: PPUSH
110678: LD_EXP 207
110682: PUSH
110683: LD_VAR 0 6
110687: ARRAY
110688: PUSH
110689: LD_VAR 0 5
110693: ARRAY
110694: PUSH
110695: LD_INT 2
110697: ARRAY
110698: PPUSH
110699: LD_VAR 0 2
110703: PPUSH
110704: LD_VAR 0 3
110708: PPUSH
110709: CALL_OW 298
110713: PUSH
110714: LD_INT 6
110716: LESS
110717: IFFALSE 110816
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110719: LD_EXP 207
110723: PUSH
110724: LD_VAR 0 6
110728: ARRAY
110729: PUSH
110730: LD_VAR 0 5
110734: ARRAY
110735: PUSH
110736: LD_INT 1
110738: ARRAY
110739: PPUSH
110740: LD_EXP 207
110744: PUSH
110745: LD_VAR 0 6
110749: ARRAY
110750: PUSH
110751: LD_VAR 0 5
110755: ARRAY
110756: PUSH
110757: LD_INT 2
110759: ARRAY
110760: PPUSH
110761: LD_VAR 0 1
110765: PPUSH
110766: CALL_OW 255
110770: PPUSH
110771: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110775: LD_ADDR_EXP 207
110779: PUSH
110780: LD_EXP 207
110784: PPUSH
110785: LD_VAR 0 6
110789: PPUSH
110790: LD_EXP 207
110794: PUSH
110795: LD_VAR 0 6
110799: ARRAY
110800: PPUSH
110801: LD_VAR 0 5
110805: PPUSH
110806: CALL_OW 3
110810: PPUSH
110811: CALL_OW 1
110815: ST_TO_ADDR
// end ; end ;
110816: GO 110654
110818: POP
110819: POP
// end ;
110820: LD_VAR 0 4
110824: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
110825: LD_INT 0
110827: PPUSH
110828: PPUSH
110829: PPUSH
110830: PPUSH
110831: PPUSH
110832: PPUSH
110833: PPUSH
110834: PPUSH
110835: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
110836: LD_VAR 0 1
110840: PPUSH
110841: CALL_OW 264
110845: PUSH
110846: LD_EXP 81
110850: EQUAL
110851: NOT
110852: PUSH
110853: LD_VAR 0 1
110857: PUSH
110858: LD_EXP 206
110862: IN
110863: NOT
110864: OR
110865: IFFALSE 110869
// exit ;
110867: GO 111191
// index := GetElementIndex ( minersList , unit ) ;
110869: LD_ADDR_VAR 0 6
110873: PUSH
110874: LD_EXP 206
110878: PPUSH
110879: LD_VAR 0 1
110883: PPUSH
110884: CALL 56978 0 2
110888: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
110889: LD_ADDR_VAR 0 8
110893: PUSH
110894: LD_EXP 208
110898: PUSH
110899: LD_EXP 207
110903: PUSH
110904: LD_VAR 0 6
110908: ARRAY
110909: MINUS
110910: ST_TO_ADDR
// if not minesFreeAmount then
110911: LD_VAR 0 8
110915: NOT
110916: IFFALSE 110920
// exit ;
110918: GO 111191
// tmp := [ ] ;
110920: LD_ADDR_VAR 0 7
110924: PUSH
110925: EMPTY
110926: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
110927: LD_ADDR_VAR 0 5
110931: PUSH
110932: DOUBLE
110933: LD_INT 1
110935: DEC
110936: ST_TO_ADDR
110937: LD_VAR 0 8
110941: PUSH
110942: FOR_TO
110943: IFFALSE 111138
// begin _d := rand ( 0 , 5 ) ;
110945: LD_ADDR_VAR 0 11
110949: PUSH
110950: LD_INT 0
110952: PPUSH
110953: LD_INT 5
110955: PPUSH
110956: CALL_OW 12
110960: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
110961: LD_ADDR_VAR 0 12
110965: PUSH
110966: LD_INT 2
110968: PPUSH
110969: LD_INT 6
110971: PPUSH
110972: CALL_OW 12
110976: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
110977: LD_ADDR_VAR 0 9
110981: PUSH
110982: LD_VAR 0 2
110986: PPUSH
110987: LD_VAR 0 11
110991: PPUSH
110992: LD_VAR 0 12
110996: PPUSH
110997: CALL_OW 272
111001: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111002: LD_ADDR_VAR 0 10
111006: PUSH
111007: LD_VAR 0 3
111011: PPUSH
111012: LD_VAR 0 11
111016: PPUSH
111017: LD_VAR 0 12
111021: PPUSH
111022: CALL_OW 273
111026: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111027: LD_VAR 0 9
111031: PPUSH
111032: LD_VAR 0 10
111036: PPUSH
111037: CALL_OW 488
111041: PUSH
111042: LD_VAR 0 9
111046: PUSH
111047: LD_VAR 0 10
111051: PUSH
111052: EMPTY
111053: LIST
111054: LIST
111055: PUSH
111056: LD_VAR 0 7
111060: IN
111061: NOT
111062: AND
111063: PUSH
111064: LD_VAR 0 9
111068: PPUSH
111069: LD_VAR 0 10
111073: PPUSH
111074: CALL_OW 458
111078: NOT
111079: AND
111080: IFFALSE 111122
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111082: LD_ADDR_VAR 0 7
111086: PUSH
111087: LD_VAR 0 7
111091: PPUSH
111092: LD_VAR 0 7
111096: PUSH
111097: LD_INT 1
111099: PLUS
111100: PPUSH
111101: LD_VAR 0 9
111105: PUSH
111106: LD_VAR 0 10
111110: PUSH
111111: EMPTY
111112: LIST
111113: LIST
111114: PPUSH
111115: CALL_OW 1
111119: ST_TO_ADDR
111120: GO 111136
// i := i - 1 ;
111122: LD_ADDR_VAR 0 5
111126: PUSH
111127: LD_VAR 0 5
111131: PUSH
111132: LD_INT 1
111134: MINUS
111135: ST_TO_ADDR
// end ;
111136: GO 110942
111138: POP
111139: POP
// for i in tmp do
111140: LD_ADDR_VAR 0 5
111144: PUSH
111145: LD_VAR 0 7
111149: PUSH
111150: FOR_IN
111151: IFFALSE 111189
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111153: LD_VAR 0 1
111157: PPUSH
111158: LD_VAR 0 5
111162: PUSH
111163: LD_INT 1
111165: ARRAY
111166: PPUSH
111167: LD_VAR 0 5
111171: PUSH
111172: LD_INT 2
111174: ARRAY
111175: PPUSH
111176: CALL 110131 0 3
111180: NOT
111181: IFFALSE 111187
// exit ;
111183: POP
111184: POP
111185: GO 111191
111187: GO 111150
111189: POP
111190: POP
// end ;
111191: LD_VAR 0 4
111195: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
111196: LD_INT 0
111198: PPUSH
111199: PPUSH
111200: PPUSH
111201: PPUSH
111202: PPUSH
111203: PPUSH
111204: PPUSH
// if not GetClass ( unit ) = class_sniper then
111205: LD_VAR 0 1
111209: PPUSH
111210: CALL_OW 257
111214: PUSH
111215: LD_INT 5
111217: EQUAL
111218: NOT
111219: IFFALSE 111223
// exit ;
111221: GO 111611
// dist := 8 ;
111223: LD_ADDR_VAR 0 5
111227: PUSH
111228: LD_INT 8
111230: ST_TO_ADDR
// viewRange := 12 ;
111231: LD_ADDR_VAR 0 7
111235: PUSH
111236: LD_INT 12
111238: ST_TO_ADDR
// side := GetSide ( unit ) ;
111239: LD_ADDR_VAR 0 6
111243: PUSH
111244: LD_VAR 0 1
111248: PPUSH
111249: CALL_OW 255
111253: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111254: LD_INT 61
111256: PPUSH
111257: LD_VAR 0 6
111261: PPUSH
111262: CALL_OW 321
111266: PUSH
111267: LD_INT 2
111269: EQUAL
111270: IFFALSE 111280
// viewRange := 16 ;
111272: LD_ADDR_VAR 0 7
111276: PUSH
111277: LD_INT 16
111279: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111280: LD_VAR 0 1
111284: PPUSH
111285: LD_VAR 0 2
111289: PPUSH
111290: LD_VAR 0 3
111294: PPUSH
111295: CALL_OW 297
111299: PUSH
111300: LD_VAR 0 5
111304: GREATER
111305: IFFALSE 111384
// begin ComMoveXY ( unit , x , y ) ;
111307: LD_VAR 0 1
111311: PPUSH
111312: LD_VAR 0 2
111316: PPUSH
111317: LD_VAR 0 3
111321: PPUSH
111322: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111326: LD_INT 35
111328: PPUSH
111329: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111333: LD_VAR 0 1
111337: PPUSH
111338: LD_VAR 0 2
111342: PPUSH
111343: LD_VAR 0 3
111347: PPUSH
111348: CALL 87697 0 3
111352: NOT
111353: IFFALSE 111357
// exit ;
111355: GO 111611
// until GetDistUnitXY ( unit , x , y ) < dist ;
111357: LD_VAR 0 1
111361: PPUSH
111362: LD_VAR 0 2
111366: PPUSH
111367: LD_VAR 0 3
111371: PPUSH
111372: CALL_OW 297
111376: PUSH
111377: LD_VAR 0 5
111381: LESS
111382: IFFALSE 111326
// end ; ComTurnXY ( unit , x , y ) ;
111384: LD_VAR 0 1
111388: PPUSH
111389: LD_VAR 0 2
111393: PPUSH
111394: LD_VAR 0 3
111398: PPUSH
111399: CALL_OW 118
// wait ( 5 ) ;
111403: LD_INT 5
111405: PPUSH
111406: CALL_OW 67
// _d := GetDir ( unit ) ;
111410: LD_ADDR_VAR 0 10
111414: PUSH
111415: LD_VAR 0 1
111419: PPUSH
111420: CALL_OW 254
111424: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
111425: LD_ADDR_VAR 0 8
111429: PUSH
111430: LD_VAR 0 1
111434: PPUSH
111435: CALL_OW 250
111439: PPUSH
111440: LD_VAR 0 10
111444: PPUSH
111445: LD_VAR 0 5
111449: PPUSH
111450: CALL_OW 272
111454: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
111455: LD_ADDR_VAR 0 9
111459: PUSH
111460: LD_VAR 0 1
111464: PPUSH
111465: CALL_OW 251
111469: PPUSH
111470: LD_VAR 0 10
111474: PPUSH
111475: LD_VAR 0 5
111479: PPUSH
111480: CALL_OW 273
111484: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111485: LD_VAR 0 8
111489: PPUSH
111490: LD_VAR 0 9
111494: PPUSH
111495: CALL_OW 488
111499: NOT
111500: IFFALSE 111504
// exit ;
111502: GO 111611
// ComAnimCustom ( unit , 1 ) ;
111504: LD_VAR 0 1
111508: PPUSH
111509: LD_INT 1
111511: PPUSH
111512: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111516: LD_VAR 0 8
111520: PPUSH
111521: LD_VAR 0 9
111525: PPUSH
111526: LD_VAR 0 6
111530: PPUSH
111531: LD_VAR 0 7
111535: PPUSH
111536: CALL_OW 330
// repeat wait ( 1 ) ;
111540: LD_INT 1
111542: PPUSH
111543: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111547: LD_VAR 0 1
111551: PPUSH
111552: CALL_OW 316
111556: PUSH
111557: LD_VAR 0 1
111561: PPUSH
111562: CALL_OW 314
111566: OR
111567: PUSH
111568: LD_VAR 0 1
111572: PPUSH
111573: CALL_OW 302
111577: NOT
111578: OR
111579: PUSH
111580: LD_VAR 0 1
111584: PPUSH
111585: CALL_OW 301
111589: OR
111590: IFFALSE 111540
// RemoveSeeing ( _x , _y , side ) ;
111592: LD_VAR 0 8
111596: PPUSH
111597: LD_VAR 0 9
111601: PPUSH
111602: LD_VAR 0 6
111606: PPUSH
111607: CALL_OW 331
// end ; end_of_file
111611: LD_VAR 0 4
111615: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
111616: LD_INT 0
111618: PPUSH
111619: PPUSH
111620: PPUSH
111621: PPUSH
111622: PPUSH
111623: PPUSH
111624: PPUSH
111625: PPUSH
111626: PPUSH
111627: PPUSH
111628: PPUSH
111629: PPUSH
111630: PPUSH
111631: PPUSH
111632: PPUSH
111633: PPUSH
111634: PPUSH
111635: PPUSH
111636: PPUSH
111637: PPUSH
111638: PPUSH
111639: PPUSH
111640: PPUSH
111641: PPUSH
111642: PPUSH
111643: PPUSH
111644: PPUSH
111645: PPUSH
111646: PPUSH
111647: PPUSH
111648: PPUSH
111649: PPUSH
111650: PPUSH
111651: PPUSH
// if not list then
111652: LD_VAR 0 1
111656: NOT
111657: IFFALSE 111661
// exit ;
111659: GO 116320
// base := list [ 1 ] ;
111661: LD_ADDR_VAR 0 3
111665: PUSH
111666: LD_VAR 0 1
111670: PUSH
111671: LD_INT 1
111673: ARRAY
111674: ST_TO_ADDR
// group := list [ 2 ] ;
111675: LD_ADDR_VAR 0 4
111679: PUSH
111680: LD_VAR 0 1
111684: PUSH
111685: LD_INT 2
111687: ARRAY
111688: ST_TO_ADDR
// path := list [ 3 ] ;
111689: LD_ADDR_VAR 0 5
111693: PUSH
111694: LD_VAR 0 1
111698: PUSH
111699: LD_INT 3
111701: ARRAY
111702: ST_TO_ADDR
// flags := list [ 4 ] ;
111703: LD_ADDR_VAR 0 6
111707: PUSH
111708: LD_VAR 0 1
111712: PUSH
111713: LD_INT 4
111715: ARRAY
111716: ST_TO_ADDR
// mined := [ ] ;
111717: LD_ADDR_VAR 0 27
111721: PUSH
111722: EMPTY
111723: ST_TO_ADDR
// bombed := [ ] ;
111724: LD_ADDR_VAR 0 28
111728: PUSH
111729: EMPTY
111730: ST_TO_ADDR
// healers := [ ] ;
111731: LD_ADDR_VAR 0 31
111735: PUSH
111736: EMPTY
111737: ST_TO_ADDR
// to_heal := [ ] ;
111738: LD_ADDR_VAR 0 30
111742: PUSH
111743: EMPTY
111744: ST_TO_ADDR
// repairs := [ ] ;
111745: LD_ADDR_VAR 0 33
111749: PUSH
111750: EMPTY
111751: ST_TO_ADDR
// to_repair := [ ] ;
111752: LD_ADDR_VAR 0 32
111756: PUSH
111757: EMPTY
111758: ST_TO_ADDR
// if not group or not path then
111759: LD_VAR 0 4
111763: NOT
111764: PUSH
111765: LD_VAR 0 5
111769: NOT
111770: OR
111771: IFFALSE 111775
// exit ;
111773: GO 116320
// side := GetSide ( group [ 1 ] ) ;
111775: LD_ADDR_VAR 0 35
111779: PUSH
111780: LD_VAR 0 4
111784: PUSH
111785: LD_INT 1
111787: ARRAY
111788: PPUSH
111789: CALL_OW 255
111793: ST_TO_ADDR
// if flags then
111794: LD_VAR 0 6
111798: IFFALSE 111942
// begin f_ignore_area := flags [ 1 ] ;
111800: LD_ADDR_VAR 0 17
111804: PUSH
111805: LD_VAR 0 6
111809: PUSH
111810: LD_INT 1
111812: ARRAY
111813: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
111814: LD_ADDR_VAR 0 18
111818: PUSH
111819: LD_VAR 0 6
111823: PUSH
111824: LD_INT 2
111826: ARRAY
111827: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
111828: LD_ADDR_VAR 0 19
111832: PUSH
111833: LD_VAR 0 6
111837: PUSH
111838: LD_INT 3
111840: ARRAY
111841: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
111842: LD_ADDR_VAR 0 20
111846: PUSH
111847: LD_VAR 0 6
111851: PUSH
111852: LD_INT 4
111854: ARRAY
111855: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
111856: LD_ADDR_VAR 0 21
111860: PUSH
111861: LD_VAR 0 6
111865: PUSH
111866: LD_INT 5
111868: ARRAY
111869: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
111870: LD_ADDR_VAR 0 22
111874: PUSH
111875: LD_VAR 0 6
111879: PUSH
111880: LD_INT 6
111882: ARRAY
111883: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
111884: LD_ADDR_VAR 0 23
111888: PUSH
111889: LD_VAR 0 6
111893: PUSH
111894: LD_INT 7
111896: ARRAY
111897: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
111898: LD_ADDR_VAR 0 24
111902: PUSH
111903: LD_VAR 0 6
111907: PUSH
111908: LD_INT 8
111910: ARRAY
111911: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
111912: LD_ADDR_VAR 0 25
111916: PUSH
111917: LD_VAR 0 6
111921: PUSH
111922: LD_INT 9
111924: ARRAY
111925: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
111926: LD_ADDR_VAR 0 26
111930: PUSH
111931: LD_VAR 0 6
111935: PUSH
111936: LD_INT 10
111938: ARRAY
111939: ST_TO_ADDR
// end else
111940: GO 112022
// begin f_ignore_area := false ;
111942: LD_ADDR_VAR 0 17
111946: PUSH
111947: LD_INT 0
111949: ST_TO_ADDR
// f_capture := false ;
111950: LD_ADDR_VAR 0 18
111954: PUSH
111955: LD_INT 0
111957: ST_TO_ADDR
// f_ignore_civ := false ;
111958: LD_ADDR_VAR 0 19
111962: PUSH
111963: LD_INT 0
111965: ST_TO_ADDR
// f_murder := false ;
111966: LD_ADDR_VAR 0 20
111970: PUSH
111971: LD_INT 0
111973: ST_TO_ADDR
// f_mines := false ;
111974: LD_ADDR_VAR 0 21
111978: PUSH
111979: LD_INT 0
111981: ST_TO_ADDR
// f_repair := false ;
111982: LD_ADDR_VAR 0 22
111986: PUSH
111987: LD_INT 0
111989: ST_TO_ADDR
// f_heal := false ;
111990: LD_ADDR_VAR 0 23
111994: PUSH
111995: LD_INT 0
111997: ST_TO_ADDR
// f_spacetime := false ;
111998: LD_ADDR_VAR 0 24
112002: PUSH
112003: LD_INT 0
112005: ST_TO_ADDR
// f_attack_depot := false ;
112006: LD_ADDR_VAR 0 25
112010: PUSH
112011: LD_INT 0
112013: ST_TO_ADDR
// f_crawl := false ;
112014: LD_ADDR_VAR 0 26
112018: PUSH
112019: LD_INT 0
112021: ST_TO_ADDR
// end ; if f_heal then
112022: LD_VAR 0 23
112026: IFFALSE 112053
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112028: LD_ADDR_VAR 0 31
112032: PUSH
112033: LD_VAR 0 4
112037: PPUSH
112038: LD_INT 25
112040: PUSH
112041: LD_INT 4
112043: PUSH
112044: EMPTY
112045: LIST
112046: LIST
112047: PPUSH
112048: CALL_OW 72
112052: ST_TO_ADDR
// if f_repair then
112053: LD_VAR 0 22
112057: IFFALSE 112084
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112059: LD_ADDR_VAR 0 33
112063: PUSH
112064: LD_VAR 0 4
112068: PPUSH
112069: LD_INT 25
112071: PUSH
112072: LD_INT 3
112074: PUSH
112075: EMPTY
112076: LIST
112077: LIST
112078: PPUSH
112079: CALL_OW 72
112083: ST_TO_ADDR
// units_path := [ ] ;
112084: LD_ADDR_VAR 0 16
112088: PUSH
112089: EMPTY
112090: ST_TO_ADDR
// for i = 1 to group do
112091: LD_ADDR_VAR 0 7
112095: PUSH
112096: DOUBLE
112097: LD_INT 1
112099: DEC
112100: ST_TO_ADDR
112101: LD_VAR 0 4
112105: PUSH
112106: FOR_TO
112107: IFFALSE 112136
// units_path := Replace ( units_path , i , path ) ;
112109: LD_ADDR_VAR 0 16
112113: PUSH
112114: LD_VAR 0 16
112118: PPUSH
112119: LD_VAR 0 7
112123: PPUSH
112124: LD_VAR 0 5
112128: PPUSH
112129: CALL_OW 1
112133: ST_TO_ADDR
112134: GO 112106
112136: POP
112137: POP
// repeat for i = group downto 1 do
112138: LD_ADDR_VAR 0 7
112142: PUSH
112143: DOUBLE
112144: LD_VAR 0 4
112148: INC
112149: ST_TO_ADDR
112150: LD_INT 1
112152: PUSH
112153: FOR_DOWNTO
112154: IFFALSE 116276
// begin wait ( 5 ) ;
112156: LD_INT 5
112158: PPUSH
112159: CALL_OW 67
// tmp := [ ] ;
112163: LD_ADDR_VAR 0 14
112167: PUSH
112168: EMPTY
112169: ST_TO_ADDR
// attacking := false ;
112170: LD_ADDR_VAR 0 29
112174: PUSH
112175: LD_INT 0
112177: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112178: LD_VAR 0 4
112182: PUSH
112183: LD_VAR 0 7
112187: ARRAY
112188: PPUSH
112189: CALL_OW 301
112193: PUSH
112194: LD_VAR 0 4
112198: PUSH
112199: LD_VAR 0 7
112203: ARRAY
112204: NOT
112205: OR
112206: IFFALSE 112315
// begin if GetType ( group [ i ] ) = unit_human then
112208: LD_VAR 0 4
112212: PUSH
112213: LD_VAR 0 7
112217: ARRAY
112218: PPUSH
112219: CALL_OW 247
112223: PUSH
112224: LD_INT 1
112226: EQUAL
112227: IFFALSE 112273
// begin to_heal := to_heal diff group [ i ] ;
112229: LD_ADDR_VAR 0 30
112233: PUSH
112234: LD_VAR 0 30
112238: PUSH
112239: LD_VAR 0 4
112243: PUSH
112244: LD_VAR 0 7
112248: ARRAY
112249: DIFF
112250: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112251: LD_ADDR_VAR 0 31
112255: PUSH
112256: LD_VAR 0 31
112260: PUSH
112261: LD_VAR 0 4
112265: PUSH
112266: LD_VAR 0 7
112270: ARRAY
112271: DIFF
112272: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112273: LD_ADDR_VAR 0 4
112277: PUSH
112278: LD_VAR 0 4
112282: PPUSH
112283: LD_VAR 0 7
112287: PPUSH
112288: CALL_OW 3
112292: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112293: LD_ADDR_VAR 0 16
112297: PUSH
112298: LD_VAR 0 16
112302: PPUSH
112303: LD_VAR 0 7
112307: PPUSH
112308: CALL_OW 3
112312: ST_TO_ADDR
// continue ;
112313: GO 112153
// end ; if f_repair then
112315: LD_VAR 0 22
112319: IFFALSE 112808
// begin if GetType ( group [ i ] ) = unit_vehicle then
112321: LD_VAR 0 4
112325: PUSH
112326: LD_VAR 0 7
112330: ARRAY
112331: PPUSH
112332: CALL_OW 247
112336: PUSH
112337: LD_INT 2
112339: EQUAL
112340: IFFALSE 112530
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112342: LD_VAR 0 4
112346: PUSH
112347: LD_VAR 0 7
112351: ARRAY
112352: PPUSH
112353: CALL_OW 256
112357: PUSH
112358: LD_INT 700
112360: LESS
112361: PUSH
112362: LD_VAR 0 4
112366: PUSH
112367: LD_VAR 0 7
112371: ARRAY
112372: PUSH
112373: LD_VAR 0 32
112377: IN
112378: NOT
112379: AND
112380: IFFALSE 112404
// to_repair := to_repair union group [ i ] ;
112382: LD_ADDR_VAR 0 32
112386: PUSH
112387: LD_VAR 0 32
112391: PUSH
112392: LD_VAR 0 4
112396: PUSH
112397: LD_VAR 0 7
112401: ARRAY
112402: UNION
112403: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112404: LD_VAR 0 4
112408: PUSH
112409: LD_VAR 0 7
112413: ARRAY
112414: PPUSH
112415: CALL_OW 256
112419: PUSH
112420: LD_INT 1000
112422: EQUAL
112423: PUSH
112424: LD_VAR 0 4
112428: PUSH
112429: LD_VAR 0 7
112433: ARRAY
112434: PUSH
112435: LD_VAR 0 32
112439: IN
112440: AND
112441: IFFALSE 112465
// to_repair := to_repair diff group [ i ] ;
112443: LD_ADDR_VAR 0 32
112447: PUSH
112448: LD_VAR 0 32
112452: PUSH
112453: LD_VAR 0 4
112457: PUSH
112458: LD_VAR 0 7
112462: ARRAY
112463: DIFF
112464: ST_TO_ADDR
// if group [ i ] in to_repair then
112465: LD_VAR 0 4
112469: PUSH
112470: LD_VAR 0 7
112474: ARRAY
112475: PUSH
112476: LD_VAR 0 32
112480: IN
112481: IFFALSE 112528
// begin if not IsInArea ( group [ i ] , f_repair ) then
112483: LD_VAR 0 4
112487: PUSH
112488: LD_VAR 0 7
112492: ARRAY
112493: PPUSH
112494: LD_VAR 0 22
112498: PPUSH
112499: CALL_OW 308
112503: NOT
112504: IFFALSE 112526
// ComMoveToArea ( group [ i ] , f_repair ) ;
112506: LD_VAR 0 4
112510: PUSH
112511: LD_VAR 0 7
112515: ARRAY
112516: PPUSH
112517: LD_VAR 0 22
112521: PPUSH
112522: CALL_OW 113
// continue ;
112526: GO 112153
// end ; end else
112528: GO 112808
// if group [ i ] in repairs then
112530: LD_VAR 0 4
112534: PUSH
112535: LD_VAR 0 7
112539: ARRAY
112540: PUSH
112541: LD_VAR 0 33
112545: IN
112546: IFFALSE 112808
// begin if IsInUnit ( group [ i ] ) then
112548: LD_VAR 0 4
112552: PUSH
112553: LD_VAR 0 7
112557: ARRAY
112558: PPUSH
112559: CALL_OW 310
112563: IFFALSE 112631
// begin z := IsInUnit ( group [ i ] ) ;
112565: LD_ADDR_VAR 0 13
112569: PUSH
112570: LD_VAR 0 4
112574: PUSH
112575: LD_VAR 0 7
112579: ARRAY
112580: PPUSH
112581: CALL_OW 310
112585: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
112586: LD_VAR 0 13
112590: PUSH
112591: LD_VAR 0 32
112595: IN
112596: PUSH
112597: LD_VAR 0 13
112601: PPUSH
112602: LD_VAR 0 22
112606: PPUSH
112607: CALL_OW 308
112611: AND
112612: IFFALSE 112629
// ComExitVehicle ( group [ i ] ) ;
112614: LD_VAR 0 4
112618: PUSH
112619: LD_VAR 0 7
112623: ARRAY
112624: PPUSH
112625: CALL_OW 121
// end else
112629: GO 112808
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
112631: LD_ADDR_VAR 0 13
112635: PUSH
112636: LD_VAR 0 4
112640: PPUSH
112641: LD_INT 95
112643: PUSH
112644: LD_VAR 0 22
112648: PUSH
112649: EMPTY
112650: LIST
112651: LIST
112652: PUSH
112653: LD_INT 58
112655: PUSH
112656: EMPTY
112657: LIST
112658: PUSH
112659: EMPTY
112660: LIST
112661: LIST
112662: PPUSH
112663: CALL_OW 72
112667: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
112668: LD_VAR 0 4
112672: PUSH
112673: LD_VAR 0 7
112677: ARRAY
112678: PPUSH
112679: CALL_OW 314
112683: NOT
112684: IFFALSE 112806
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
112686: LD_ADDR_VAR 0 10
112690: PUSH
112691: LD_VAR 0 13
112695: PPUSH
112696: LD_VAR 0 4
112700: PUSH
112701: LD_VAR 0 7
112705: ARRAY
112706: PPUSH
112707: CALL_OW 74
112711: ST_TO_ADDR
// if not x then
112712: LD_VAR 0 10
112716: NOT
112717: IFFALSE 112721
// continue ;
112719: GO 112153
// if GetLives ( x ) < 1000 then
112721: LD_VAR 0 10
112725: PPUSH
112726: CALL_OW 256
112730: PUSH
112731: LD_INT 1000
112733: LESS
112734: IFFALSE 112758
// ComRepairVehicle ( group [ i ] , x ) else
112736: LD_VAR 0 4
112740: PUSH
112741: LD_VAR 0 7
112745: ARRAY
112746: PPUSH
112747: LD_VAR 0 10
112751: PPUSH
112752: CALL_OW 129
112756: GO 112806
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
112758: LD_VAR 0 23
112762: PUSH
112763: LD_VAR 0 4
112767: PUSH
112768: LD_VAR 0 7
112772: ARRAY
112773: PPUSH
112774: CALL_OW 256
112778: PUSH
112779: LD_INT 1000
112781: LESS
112782: AND
112783: NOT
112784: IFFALSE 112806
// ComEnterUnit ( group [ i ] , x ) ;
112786: LD_VAR 0 4
112790: PUSH
112791: LD_VAR 0 7
112795: ARRAY
112796: PPUSH
112797: LD_VAR 0 10
112801: PPUSH
112802: CALL_OW 120
// end ; continue ;
112806: GO 112153
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
112808: LD_VAR 0 23
112812: PUSH
112813: LD_VAR 0 4
112817: PUSH
112818: LD_VAR 0 7
112822: ARRAY
112823: PPUSH
112824: CALL_OW 247
112828: PUSH
112829: LD_INT 1
112831: EQUAL
112832: AND
112833: IFFALSE 113311
// begin if group [ i ] in healers then
112835: LD_VAR 0 4
112839: PUSH
112840: LD_VAR 0 7
112844: ARRAY
112845: PUSH
112846: LD_VAR 0 31
112850: IN
112851: IFFALSE 113124
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
112853: LD_VAR 0 4
112857: PUSH
112858: LD_VAR 0 7
112862: ARRAY
112863: PPUSH
112864: LD_VAR 0 23
112868: PPUSH
112869: CALL_OW 308
112873: NOT
112874: PUSH
112875: LD_VAR 0 4
112879: PUSH
112880: LD_VAR 0 7
112884: ARRAY
112885: PPUSH
112886: CALL_OW 314
112890: NOT
112891: AND
112892: IFFALSE 112916
// ComMoveToArea ( group [ i ] , f_heal ) else
112894: LD_VAR 0 4
112898: PUSH
112899: LD_VAR 0 7
112903: ARRAY
112904: PPUSH
112905: LD_VAR 0 23
112909: PPUSH
112910: CALL_OW 113
112914: GO 113122
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
112916: LD_VAR 0 4
112920: PUSH
112921: LD_VAR 0 7
112925: ARRAY
112926: PPUSH
112927: CALL 86273 0 1
112931: PPUSH
112932: CALL_OW 256
112936: PUSH
112937: LD_INT 1000
112939: EQUAL
112940: IFFALSE 112959
// ComStop ( group [ i ] ) else
112942: LD_VAR 0 4
112946: PUSH
112947: LD_VAR 0 7
112951: ARRAY
112952: PPUSH
112953: CALL_OW 141
112957: GO 113122
// if not HasTask ( group [ i ] ) and to_heal then
112959: LD_VAR 0 4
112963: PUSH
112964: LD_VAR 0 7
112968: ARRAY
112969: PPUSH
112970: CALL_OW 314
112974: NOT
112975: PUSH
112976: LD_VAR 0 30
112980: AND
112981: IFFALSE 113122
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
112983: LD_ADDR_VAR 0 13
112987: PUSH
112988: LD_VAR 0 30
112992: PPUSH
112993: LD_INT 3
112995: PUSH
112996: LD_INT 54
112998: PUSH
112999: EMPTY
113000: LIST
113001: PUSH
113002: EMPTY
113003: LIST
113004: LIST
113005: PPUSH
113006: CALL_OW 72
113010: PPUSH
113011: LD_VAR 0 4
113015: PUSH
113016: LD_VAR 0 7
113020: ARRAY
113021: PPUSH
113022: CALL_OW 74
113026: ST_TO_ADDR
// if z then
113027: LD_VAR 0 13
113031: IFFALSE 113122
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113033: LD_INT 91
113035: PUSH
113036: LD_VAR 0 13
113040: PUSH
113041: LD_INT 10
113043: PUSH
113044: EMPTY
113045: LIST
113046: LIST
113047: LIST
113048: PUSH
113049: LD_INT 81
113051: PUSH
113052: LD_VAR 0 13
113056: PPUSH
113057: CALL_OW 255
113061: PUSH
113062: EMPTY
113063: LIST
113064: LIST
113065: PUSH
113066: EMPTY
113067: LIST
113068: LIST
113069: PPUSH
113070: CALL_OW 69
113074: PUSH
113075: LD_INT 0
113077: EQUAL
113078: IFFALSE 113102
// ComHeal ( group [ i ] , z ) else
113080: LD_VAR 0 4
113084: PUSH
113085: LD_VAR 0 7
113089: ARRAY
113090: PPUSH
113091: LD_VAR 0 13
113095: PPUSH
113096: CALL_OW 128
113100: GO 113122
// ComMoveToArea ( group [ i ] , f_heal ) ;
113102: LD_VAR 0 4
113106: PUSH
113107: LD_VAR 0 7
113111: ARRAY
113112: PPUSH
113113: LD_VAR 0 23
113117: PPUSH
113118: CALL_OW 113
// end ; continue ;
113122: GO 112153
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113124: LD_VAR 0 4
113128: PUSH
113129: LD_VAR 0 7
113133: ARRAY
113134: PPUSH
113135: CALL_OW 256
113139: PUSH
113140: LD_INT 700
113142: LESS
113143: PUSH
113144: LD_VAR 0 4
113148: PUSH
113149: LD_VAR 0 7
113153: ARRAY
113154: PUSH
113155: LD_VAR 0 30
113159: IN
113160: NOT
113161: AND
113162: IFFALSE 113186
// to_heal := to_heal union group [ i ] ;
113164: LD_ADDR_VAR 0 30
113168: PUSH
113169: LD_VAR 0 30
113173: PUSH
113174: LD_VAR 0 4
113178: PUSH
113179: LD_VAR 0 7
113183: ARRAY
113184: UNION
113185: ST_TO_ADDR
// if group [ i ] in to_heal then
113186: LD_VAR 0 4
113190: PUSH
113191: LD_VAR 0 7
113195: ARRAY
113196: PUSH
113197: LD_VAR 0 30
113201: IN
113202: IFFALSE 113311
// begin if GetLives ( group [ i ] ) = 1000 then
113204: LD_VAR 0 4
113208: PUSH
113209: LD_VAR 0 7
113213: ARRAY
113214: PPUSH
113215: CALL_OW 256
113219: PUSH
113220: LD_INT 1000
113222: EQUAL
113223: IFFALSE 113249
// to_heal := to_heal diff group [ i ] else
113225: LD_ADDR_VAR 0 30
113229: PUSH
113230: LD_VAR 0 30
113234: PUSH
113235: LD_VAR 0 4
113239: PUSH
113240: LD_VAR 0 7
113244: ARRAY
113245: DIFF
113246: ST_TO_ADDR
113247: GO 113311
// begin if not IsInArea ( group [ i ] , to_heal ) then
113249: LD_VAR 0 4
113253: PUSH
113254: LD_VAR 0 7
113258: ARRAY
113259: PPUSH
113260: LD_VAR 0 30
113264: PPUSH
113265: CALL_OW 308
113269: NOT
113270: IFFALSE 113294
// ComMoveToArea ( group [ i ] , f_heal ) else
113272: LD_VAR 0 4
113276: PUSH
113277: LD_VAR 0 7
113281: ARRAY
113282: PPUSH
113283: LD_VAR 0 23
113287: PPUSH
113288: CALL_OW 113
113292: GO 113309
// ComHold ( group [ i ] ) ;
113294: LD_VAR 0 4
113298: PUSH
113299: LD_VAR 0 7
113303: ARRAY
113304: PPUSH
113305: CALL_OW 140
// continue ;
113309: GO 112153
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113311: LD_VAR 0 4
113315: PUSH
113316: LD_VAR 0 7
113320: ARRAY
113321: PPUSH
113322: LD_INT 10
113324: PPUSH
113325: CALL 84693 0 2
113329: NOT
113330: PUSH
113331: LD_VAR 0 16
113335: PUSH
113336: LD_VAR 0 7
113340: ARRAY
113341: PUSH
113342: EMPTY
113343: EQUAL
113344: NOT
113345: AND
113346: IFFALSE 113612
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113348: LD_VAR 0 4
113352: PUSH
113353: LD_VAR 0 7
113357: ARRAY
113358: PPUSH
113359: CALL_OW 262
113363: PUSH
113364: LD_INT 1
113366: PUSH
113367: LD_INT 2
113369: PUSH
113370: EMPTY
113371: LIST
113372: LIST
113373: IN
113374: IFFALSE 113415
// if GetFuel ( group [ i ] ) < 10 then
113376: LD_VAR 0 4
113380: PUSH
113381: LD_VAR 0 7
113385: ARRAY
113386: PPUSH
113387: CALL_OW 261
113391: PUSH
113392: LD_INT 10
113394: LESS
113395: IFFALSE 113415
// SetFuel ( group [ i ] , 12 ) ;
113397: LD_VAR 0 4
113401: PUSH
113402: LD_VAR 0 7
113406: ARRAY
113407: PPUSH
113408: LD_INT 12
113410: PPUSH
113411: CALL_OW 240
// if units_path [ i ] then
113415: LD_VAR 0 16
113419: PUSH
113420: LD_VAR 0 7
113424: ARRAY
113425: IFFALSE 113610
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113427: LD_VAR 0 4
113431: PUSH
113432: LD_VAR 0 7
113436: ARRAY
113437: PPUSH
113438: LD_VAR 0 16
113442: PUSH
113443: LD_VAR 0 7
113447: ARRAY
113448: PUSH
113449: LD_INT 1
113451: ARRAY
113452: PUSH
113453: LD_INT 1
113455: ARRAY
113456: PPUSH
113457: LD_VAR 0 16
113461: PUSH
113462: LD_VAR 0 7
113466: ARRAY
113467: PUSH
113468: LD_INT 1
113470: ARRAY
113471: PUSH
113472: LD_INT 2
113474: ARRAY
113475: PPUSH
113476: CALL_OW 297
113480: PUSH
113481: LD_INT 6
113483: GREATER
113484: IFFALSE 113559
// begin if not HasTask ( group [ i ] ) then
113486: LD_VAR 0 4
113490: PUSH
113491: LD_VAR 0 7
113495: ARRAY
113496: PPUSH
113497: CALL_OW 314
113501: NOT
113502: IFFALSE 113557
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113504: LD_VAR 0 4
113508: PUSH
113509: LD_VAR 0 7
113513: ARRAY
113514: PPUSH
113515: LD_VAR 0 16
113519: PUSH
113520: LD_VAR 0 7
113524: ARRAY
113525: PUSH
113526: LD_INT 1
113528: ARRAY
113529: PUSH
113530: LD_INT 1
113532: ARRAY
113533: PPUSH
113534: LD_VAR 0 16
113538: PUSH
113539: LD_VAR 0 7
113543: ARRAY
113544: PUSH
113545: LD_INT 1
113547: ARRAY
113548: PUSH
113549: LD_INT 2
113551: ARRAY
113552: PPUSH
113553: CALL_OW 114
// end else
113557: GO 113610
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113559: LD_ADDR_VAR 0 15
113563: PUSH
113564: LD_VAR 0 16
113568: PUSH
113569: LD_VAR 0 7
113573: ARRAY
113574: PPUSH
113575: LD_INT 1
113577: PPUSH
113578: CALL_OW 3
113582: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113583: LD_ADDR_VAR 0 16
113587: PUSH
113588: LD_VAR 0 16
113592: PPUSH
113593: LD_VAR 0 7
113597: PPUSH
113598: LD_VAR 0 15
113602: PPUSH
113603: CALL_OW 1
113607: ST_TO_ADDR
// continue ;
113608: GO 112153
// end ; end ; end else
113610: GO 116274
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
113612: LD_ADDR_VAR 0 14
113616: PUSH
113617: LD_INT 81
113619: PUSH
113620: LD_VAR 0 4
113624: PUSH
113625: LD_VAR 0 7
113629: ARRAY
113630: PPUSH
113631: CALL_OW 255
113635: PUSH
113636: EMPTY
113637: LIST
113638: LIST
113639: PPUSH
113640: CALL_OW 69
113644: ST_TO_ADDR
// if not tmp then
113645: LD_VAR 0 14
113649: NOT
113650: IFFALSE 113654
// continue ;
113652: GO 112153
// if f_ignore_area then
113654: LD_VAR 0 17
113658: IFFALSE 113746
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
113660: LD_ADDR_VAR 0 15
113664: PUSH
113665: LD_VAR 0 14
113669: PPUSH
113670: LD_INT 3
113672: PUSH
113673: LD_INT 92
113675: PUSH
113676: LD_VAR 0 17
113680: PUSH
113681: LD_INT 1
113683: ARRAY
113684: PUSH
113685: LD_VAR 0 17
113689: PUSH
113690: LD_INT 2
113692: ARRAY
113693: PUSH
113694: LD_VAR 0 17
113698: PUSH
113699: LD_INT 3
113701: ARRAY
113702: PUSH
113703: EMPTY
113704: LIST
113705: LIST
113706: LIST
113707: LIST
113708: PUSH
113709: EMPTY
113710: LIST
113711: LIST
113712: PPUSH
113713: CALL_OW 72
113717: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113718: LD_VAR 0 14
113722: PUSH
113723: LD_VAR 0 15
113727: DIFF
113728: IFFALSE 113746
// tmp := tmp diff tmp2 ;
113730: LD_ADDR_VAR 0 14
113734: PUSH
113735: LD_VAR 0 14
113739: PUSH
113740: LD_VAR 0 15
113744: DIFF
113745: ST_TO_ADDR
// end ; if not f_murder then
113746: LD_VAR 0 20
113750: NOT
113751: IFFALSE 113809
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
113753: LD_ADDR_VAR 0 15
113757: PUSH
113758: LD_VAR 0 14
113762: PPUSH
113763: LD_INT 3
113765: PUSH
113766: LD_INT 50
113768: PUSH
113769: EMPTY
113770: LIST
113771: PUSH
113772: EMPTY
113773: LIST
113774: LIST
113775: PPUSH
113776: CALL_OW 72
113780: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113781: LD_VAR 0 14
113785: PUSH
113786: LD_VAR 0 15
113790: DIFF
113791: IFFALSE 113809
// tmp := tmp diff tmp2 ;
113793: LD_ADDR_VAR 0 14
113797: PUSH
113798: LD_VAR 0 14
113802: PUSH
113803: LD_VAR 0 15
113807: DIFF
113808: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
113809: LD_ADDR_VAR 0 14
113813: PUSH
113814: LD_VAR 0 4
113818: PUSH
113819: LD_VAR 0 7
113823: ARRAY
113824: PPUSH
113825: LD_VAR 0 14
113829: PPUSH
113830: LD_INT 1
113832: PPUSH
113833: LD_INT 1
113835: PPUSH
113836: CALL 57628 0 4
113840: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
113841: LD_VAR 0 4
113845: PUSH
113846: LD_VAR 0 7
113850: ARRAY
113851: PPUSH
113852: CALL_OW 257
113856: PUSH
113857: LD_INT 1
113859: EQUAL
113860: IFFALSE 114308
// begin if WantPlant ( group [ i ] ) then
113862: LD_VAR 0 4
113866: PUSH
113867: LD_VAR 0 7
113871: ARRAY
113872: PPUSH
113873: CALL 57129 0 1
113877: IFFALSE 113881
// continue ;
113879: GO 112153
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
113881: LD_VAR 0 18
113885: PUSH
113886: LD_VAR 0 4
113890: PUSH
113891: LD_VAR 0 7
113895: ARRAY
113896: PPUSH
113897: CALL_OW 310
113901: NOT
113902: AND
113903: PUSH
113904: LD_VAR 0 14
113908: PUSH
113909: LD_INT 1
113911: ARRAY
113912: PUSH
113913: LD_VAR 0 14
113917: PPUSH
113918: LD_INT 21
113920: PUSH
113921: LD_INT 2
113923: PUSH
113924: EMPTY
113925: LIST
113926: LIST
113927: PUSH
113928: LD_INT 58
113930: PUSH
113931: EMPTY
113932: LIST
113933: PUSH
113934: EMPTY
113935: LIST
113936: LIST
113937: PPUSH
113938: CALL_OW 72
113942: IN
113943: AND
113944: IFFALSE 113980
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
113946: LD_VAR 0 4
113950: PUSH
113951: LD_VAR 0 7
113955: ARRAY
113956: PPUSH
113957: LD_VAR 0 14
113961: PUSH
113962: LD_INT 1
113964: ARRAY
113965: PPUSH
113966: CALL_OW 120
// attacking := true ;
113970: LD_ADDR_VAR 0 29
113974: PUSH
113975: LD_INT 1
113977: ST_TO_ADDR
// continue ;
113978: GO 112153
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
113980: LD_VAR 0 26
113984: PUSH
113985: LD_VAR 0 4
113989: PUSH
113990: LD_VAR 0 7
113994: ARRAY
113995: PPUSH
113996: CALL_OW 257
114000: PUSH
114001: LD_INT 1
114003: EQUAL
114004: AND
114005: PUSH
114006: LD_VAR 0 4
114010: PUSH
114011: LD_VAR 0 7
114015: ARRAY
114016: PPUSH
114017: CALL_OW 256
114021: PUSH
114022: LD_INT 800
114024: LESS
114025: AND
114026: PUSH
114027: LD_VAR 0 4
114031: PUSH
114032: LD_VAR 0 7
114036: ARRAY
114037: PPUSH
114038: CALL_OW 318
114042: NOT
114043: AND
114044: IFFALSE 114061
// ComCrawl ( group [ i ] ) ;
114046: LD_VAR 0 4
114050: PUSH
114051: LD_VAR 0 7
114055: ARRAY
114056: PPUSH
114057: CALL_OW 137
// if f_mines then
114061: LD_VAR 0 21
114065: IFFALSE 114308
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114067: LD_VAR 0 14
114071: PUSH
114072: LD_INT 1
114074: ARRAY
114075: PPUSH
114076: CALL_OW 247
114080: PUSH
114081: LD_INT 3
114083: EQUAL
114084: PUSH
114085: LD_VAR 0 14
114089: PUSH
114090: LD_INT 1
114092: ARRAY
114093: PUSH
114094: LD_VAR 0 27
114098: IN
114099: NOT
114100: AND
114101: IFFALSE 114308
// begin x := GetX ( tmp [ 1 ] ) ;
114103: LD_ADDR_VAR 0 10
114107: PUSH
114108: LD_VAR 0 14
114112: PUSH
114113: LD_INT 1
114115: ARRAY
114116: PPUSH
114117: CALL_OW 250
114121: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114122: LD_ADDR_VAR 0 11
114126: PUSH
114127: LD_VAR 0 14
114131: PUSH
114132: LD_INT 1
114134: ARRAY
114135: PPUSH
114136: CALL_OW 251
114140: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114141: LD_ADDR_VAR 0 12
114145: PUSH
114146: LD_VAR 0 4
114150: PUSH
114151: LD_VAR 0 7
114155: ARRAY
114156: PPUSH
114157: CALL 84778 0 1
114161: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114162: LD_VAR 0 4
114166: PUSH
114167: LD_VAR 0 7
114171: ARRAY
114172: PPUSH
114173: LD_VAR 0 10
114177: PPUSH
114178: LD_VAR 0 11
114182: PPUSH
114183: LD_VAR 0 14
114187: PUSH
114188: LD_INT 1
114190: ARRAY
114191: PPUSH
114192: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114196: LD_VAR 0 4
114200: PUSH
114201: LD_VAR 0 7
114205: ARRAY
114206: PPUSH
114207: LD_VAR 0 10
114211: PPUSH
114212: LD_VAR 0 12
114216: PPUSH
114217: LD_INT 7
114219: PPUSH
114220: CALL_OW 272
114224: PPUSH
114225: LD_VAR 0 11
114229: PPUSH
114230: LD_VAR 0 12
114234: PPUSH
114235: LD_INT 7
114237: PPUSH
114238: CALL_OW 273
114242: PPUSH
114243: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114247: LD_VAR 0 4
114251: PUSH
114252: LD_VAR 0 7
114256: ARRAY
114257: PPUSH
114258: LD_INT 71
114260: PPUSH
114261: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114265: LD_ADDR_VAR 0 27
114269: PUSH
114270: LD_VAR 0 27
114274: PPUSH
114275: LD_VAR 0 27
114279: PUSH
114280: LD_INT 1
114282: PLUS
114283: PPUSH
114284: LD_VAR 0 14
114288: PUSH
114289: LD_INT 1
114291: ARRAY
114292: PPUSH
114293: CALL_OW 1
114297: ST_TO_ADDR
// attacking := true ;
114298: LD_ADDR_VAR 0 29
114302: PUSH
114303: LD_INT 1
114305: ST_TO_ADDR
// continue ;
114306: GO 112153
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114308: LD_VAR 0 4
114312: PUSH
114313: LD_VAR 0 7
114317: ARRAY
114318: PPUSH
114319: CALL_OW 257
114323: PUSH
114324: LD_INT 17
114326: EQUAL
114327: PUSH
114328: LD_VAR 0 4
114332: PUSH
114333: LD_VAR 0 7
114337: ARRAY
114338: PPUSH
114339: CALL_OW 110
114343: PUSH
114344: LD_INT 71
114346: EQUAL
114347: NOT
114348: AND
114349: IFFALSE 114495
// begin attacking := false ;
114351: LD_ADDR_VAR 0 29
114355: PUSH
114356: LD_INT 0
114358: ST_TO_ADDR
// k := 5 ;
114359: LD_ADDR_VAR 0 9
114363: PUSH
114364: LD_INT 5
114366: ST_TO_ADDR
// if tmp < k then
114367: LD_VAR 0 14
114371: PUSH
114372: LD_VAR 0 9
114376: LESS
114377: IFFALSE 114389
// k := tmp ;
114379: LD_ADDR_VAR 0 9
114383: PUSH
114384: LD_VAR 0 14
114388: ST_TO_ADDR
// for j = 1 to k do
114389: LD_ADDR_VAR 0 8
114393: PUSH
114394: DOUBLE
114395: LD_INT 1
114397: DEC
114398: ST_TO_ADDR
114399: LD_VAR 0 9
114403: PUSH
114404: FOR_TO
114405: IFFALSE 114493
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114407: LD_VAR 0 14
114411: PUSH
114412: LD_VAR 0 8
114416: ARRAY
114417: PUSH
114418: LD_VAR 0 14
114422: PPUSH
114423: LD_INT 58
114425: PUSH
114426: EMPTY
114427: LIST
114428: PPUSH
114429: CALL_OW 72
114433: IN
114434: NOT
114435: IFFALSE 114491
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114437: LD_VAR 0 4
114441: PUSH
114442: LD_VAR 0 7
114446: ARRAY
114447: PPUSH
114448: LD_VAR 0 14
114452: PUSH
114453: LD_VAR 0 8
114457: ARRAY
114458: PPUSH
114459: CALL_OW 115
// attacking := true ;
114463: LD_ADDR_VAR 0 29
114467: PUSH
114468: LD_INT 1
114470: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114471: LD_VAR 0 4
114475: PUSH
114476: LD_VAR 0 7
114480: ARRAY
114481: PPUSH
114482: LD_INT 71
114484: PPUSH
114485: CALL_OW 109
// continue ;
114489: GO 114404
// end ; end ;
114491: GO 114404
114493: POP
114494: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114495: LD_VAR 0 4
114499: PUSH
114500: LD_VAR 0 7
114504: ARRAY
114505: PPUSH
114506: CALL_OW 257
114510: PUSH
114511: LD_INT 8
114513: EQUAL
114514: PUSH
114515: LD_VAR 0 4
114519: PUSH
114520: LD_VAR 0 7
114524: ARRAY
114525: PPUSH
114526: CALL_OW 264
114530: PUSH
114531: LD_INT 28
114533: PUSH
114534: LD_INT 45
114536: PUSH
114537: LD_INT 7
114539: PUSH
114540: LD_INT 47
114542: PUSH
114543: EMPTY
114544: LIST
114545: LIST
114546: LIST
114547: LIST
114548: IN
114549: OR
114550: IFFALSE 114806
// begin attacking := false ;
114552: LD_ADDR_VAR 0 29
114556: PUSH
114557: LD_INT 0
114559: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114560: LD_VAR 0 14
114564: PUSH
114565: LD_INT 1
114567: ARRAY
114568: PPUSH
114569: CALL_OW 266
114573: PUSH
114574: LD_INT 32
114576: PUSH
114577: LD_INT 31
114579: PUSH
114580: LD_INT 33
114582: PUSH
114583: LD_INT 4
114585: PUSH
114586: LD_INT 5
114588: PUSH
114589: EMPTY
114590: LIST
114591: LIST
114592: LIST
114593: LIST
114594: LIST
114595: IN
114596: IFFALSE 114782
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
114598: LD_ADDR_VAR 0 9
114602: PUSH
114603: LD_VAR 0 14
114607: PUSH
114608: LD_INT 1
114610: ARRAY
114611: PPUSH
114612: CALL_OW 266
114616: PPUSH
114617: LD_VAR 0 14
114621: PUSH
114622: LD_INT 1
114624: ARRAY
114625: PPUSH
114626: CALL_OW 250
114630: PPUSH
114631: LD_VAR 0 14
114635: PUSH
114636: LD_INT 1
114638: ARRAY
114639: PPUSH
114640: CALL_OW 251
114644: PPUSH
114645: LD_VAR 0 14
114649: PUSH
114650: LD_INT 1
114652: ARRAY
114653: PPUSH
114654: CALL_OW 254
114658: PPUSH
114659: LD_VAR 0 14
114663: PUSH
114664: LD_INT 1
114666: ARRAY
114667: PPUSH
114668: CALL_OW 248
114672: PPUSH
114673: LD_INT 0
114675: PPUSH
114676: CALL 66148 0 6
114680: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
114681: LD_ADDR_VAR 0 8
114685: PUSH
114686: LD_VAR 0 4
114690: PUSH
114691: LD_VAR 0 7
114695: ARRAY
114696: PPUSH
114697: LD_VAR 0 9
114701: PPUSH
114702: CALL 84818 0 2
114706: ST_TO_ADDR
// if j then
114707: LD_VAR 0 8
114711: IFFALSE 114780
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
114713: LD_VAR 0 8
114717: PUSH
114718: LD_INT 1
114720: ARRAY
114721: PPUSH
114722: LD_VAR 0 8
114726: PUSH
114727: LD_INT 2
114729: ARRAY
114730: PPUSH
114731: CALL_OW 488
114735: IFFALSE 114780
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
114737: LD_VAR 0 4
114741: PUSH
114742: LD_VAR 0 7
114746: ARRAY
114747: PPUSH
114748: LD_VAR 0 8
114752: PUSH
114753: LD_INT 1
114755: ARRAY
114756: PPUSH
114757: LD_VAR 0 8
114761: PUSH
114762: LD_INT 2
114764: ARRAY
114765: PPUSH
114766: CALL_OW 116
// attacking := true ;
114770: LD_ADDR_VAR 0 29
114774: PUSH
114775: LD_INT 1
114777: ST_TO_ADDR
// continue ;
114778: GO 112153
// end ; end else
114780: GO 114806
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114782: LD_VAR 0 4
114786: PUSH
114787: LD_VAR 0 7
114791: ARRAY
114792: PPUSH
114793: LD_VAR 0 14
114797: PUSH
114798: LD_INT 1
114800: ARRAY
114801: PPUSH
114802: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
114806: LD_VAR 0 4
114810: PUSH
114811: LD_VAR 0 7
114815: ARRAY
114816: PPUSH
114817: CALL_OW 265
114821: PUSH
114822: LD_INT 11
114824: EQUAL
114825: IFFALSE 115103
// begin k := 10 ;
114827: LD_ADDR_VAR 0 9
114831: PUSH
114832: LD_INT 10
114834: ST_TO_ADDR
// x := 0 ;
114835: LD_ADDR_VAR 0 10
114839: PUSH
114840: LD_INT 0
114842: ST_TO_ADDR
// if tmp < k then
114843: LD_VAR 0 14
114847: PUSH
114848: LD_VAR 0 9
114852: LESS
114853: IFFALSE 114865
// k := tmp ;
114855: LD_ADDR_VAR 0 9
114859: PUSH
114860: LD_VAR 0 14
114864: ST_TO_ADDR
// for j = k downto 1 do
114865: LD_ADDR_VAR 0 8
114869: PUSH
114870: DOUBLE
114871: LD_VAR 0 9
114875: INC
114876: ST_TO_ADDR
114877: LD_INT 1
114879: PUSH
114880: FOR_DOWNTO
114881: IFFALSE 114956
// begin if GetType ( tmp [ j ] ) = unit_human then
114883: LD_VAR 0 14
114887: PUSH
114888: LD_VAR 0 8
114892: ARRAY
114893: PPUSH
114894: CALL_OW 247
114898: PUSH
114899: LD_INT 1
114901: EQUAL
114902: IFFALSE 114954
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
114904: LD_VAR 0 4
114908: PUSH
114909: LD_VAR 0 7
114913: ARRAY
114914: PPUSH
114915: LD_VAR 0 14
114919: PUSH
114920: LD_VAR 0 8
114924: ARRAY
114925: PPUSH
114926: CALL 85089 0 2
// x := tmp [ j ] ;
114930: LD_ADDR_VAR 0 10
114934: PUSH
114935: LD_VAR 0 14
114939: PUSH
114940: LD_VAR 0 8
114944: ARRAY
114945: ST_TO_ADDR
// attacking := true ;
114946: LD_ADDR_VAR 0 29
114950: PUSH
114951: LD_INT 1
114953: ST_TO_ADDR
// end ; end ;
114954: GO 114880
114956: POP
114957: POP
// if not x then
114958: LD_VAR 0 10
114962: NOT
114963: IFFALSE 115103
// begin attacking := true ;
114965: LD_ADDR_VAR 0 29
114969: PUSH
114970: LD_INT 1
114972: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
114973: LD_VAR 0 4
114977: PUSH
114978: LD_VAR 0 7
114982: ARRAY
114983: PPUSH
114984: CALL_OW 250
114988: PPUSH
114989: LD_VAR 0 4
114993: PUSH
114994: LD_VAR 0 7
114998: ARRAY
114999: PPUSH
115000: CALL_OW 251
115004: PPUSH
115005: CALL_OW 546
115009: PUSH
115010: LD_INT 2
115012: ARRAY
115013: PUSH
115014: LD_VAR 0 14
115018: PUSH
115019: LD_INT 1
115021: ARRAY
115022: PPUSH
115023: CALL_OW 250
115027: PPUSH
115028: LD_VAR 0 14
115032: PUSH
115033: LD_INT 1
115035: ARRAY
115036: PPUSH
115037: CALL_OW 251
115041: PPUSH
115042: CALL_OW 546
115046: PUSH
115047: LD_INT 2
115049: ARRAY
115050: EQUAL
115051: IFFALSE 115079
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115053: LD_VAR 0 4
115057: PUSH
115058: LD_VAR 0 7
115062: ARRAY
115063: PPUSH
115064: LD_VAR 0 14
115068: PUSH
115069: LD_INT 1
115071: ARRAY
115072: PPUSH
115073: CALL 85089 0 2
115077: GO 115103
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115079: LD_VAR 0 4
115083: PUSH
115084: LD_VAR 0 7
115088: ARRAY
115089: PPUSH
115090: LD_VAR 0 14
115094: PUSH
115095: LD_INT 1
115097: ARRAY
115098: PPUSH
115099: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115103: LD_VAR 0 4
115107: PUSH
115108: LD_VAR 0 7
115112: ARRAY
115113: PPUSH
115114: CALL_OW 264
115118: PUSH
115119: LD_INT 29
115121: EQUAL
115122: IFFALSE 115488
// begin if WantsToAttack ( group [ i ] ) in bombed then
115124: LD_VAR 0 4
115128: PUSH
115129: LD_VAR 0 7
115133: ARRAY
115134: PPUSH
115135: CALL_OW 319
115139: PUSH
115140: LD_VAR 0 28
115144: IN
115145: IFFALSE 115149
// continue ;
115147: GO 112153
// k := 8 ;
115149: LD_ADDR_VAR 0 9
115153: PUSH
115154: LD_INT 8
115156: ST_TO_ADDR
// x := 0 ;
115157: LD_ADDR_VAR 0 10
115161: PUSH
115162: LD_INT 0
115164: ST_TO_ADDR
// if tmp < k then
115165: LD_VAR 0 14
115169: PUSH
115170: LD_VAR 0 9
115174: LESS
115175: IFFALSE 115187
// k := tmp ;
115177: LD_ADDR_VAR 0 9
115181: PUSH
115182: LD_VAR 0 14
115186: ST_TO_ADDR
// for j = 1 to k do
115187: LD_ADDR_VAR 0 8
115191: PUSH
115192: DOUBLE
115193: LD_INT 1
115195: DEC
115196: ST_TO_ADDR
115197: LD_VAR 0 9
115201: PUSH
115202: FOR_TO
115203: IFFALSE 115335
// begin if GetType ( tmp [ j ] ) = unit_building then
115205: LD_VAR 0 14
115209: PUSH
115210: LD_VAR 0 8
115214: ARRAY
115215: PPUSH
115216: CALL_OW 247
115220: PUSH
115221: LD_INT 3
115223: EQUAL
115224: IFFALSE 115333
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115226: LD_VAR 0 14
115230: PUSH
115231: LD_VAR 0 8
115235: ARRAY
115236: PUSH
115237: LD_VAR 0 28
115241: IN
115242: NOT
115243: PUSH
115244: LD_VAR 0 14
115248: PUSH
115249: LD_VAR 0 8
115253: ARRAY
115254: PPUSH
115255: CALL_OW 313
115259: AND
115260: IFFALSE 115333
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115262: LD_VAR 0 4
115266: PUSH
115267: LD_VAR 0 7
115271: ARRAY
115272: PPUSH
115273: LD_VAR 0 14
115277: PUSH
115278: LD_VAR 0 8
115282: ARRAY
115283: PPUSH
115284: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115288: LD_ADDR_VAR 0 28
115292: PUSH
115293: LD_VAR 0 28
115297: PPUSH
115298: LD_VAR 0 28
115302: PUSH
115303: LD_INT 1
115305: PLUS
115306: PPUSH
115307: LD_VAR 0 14
115311: PUSH
115312: LD_VAR 0 8
115316: ARRAY
115317: PPUSH
115318: CALL_OW 1
115322: ST_TO_ADDR
// attacking := true ;
115323: LD_ADDR_VAR 0 29
115327: PUSH
115328: LD_INT 1
115330: ST_TO_ADDR
// break ;
115331: GO 115335
// end ; end ;
115333: GO 115202
115335: POP
115336: POP
// if not attacking and f_attack_depot then
115337: LD_VAR 0 29
115341: NOT
115342: PUSH
115343: LD_VAR 0 25
115347: AND
115348: IFFALSE 115443
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115350: LD_ADDR_VAR 0 13
115354: PUSH
115355: LD_VAR 0 14
115359: PPUSH
115360: LD_INT 2
115362: PUSH
115363: LD_INT 30
115365: PUSH
115366: LD_INT 0
115368: PUSH
115369: EMPTY
115370: LIST
115371: LIST
115372: PUSH
115373: LD_INT 30
115375: PUSH
115376: LD_INT 1
115378: PUSH
115379: EMPTY
115380: LIST
115381: LIST
115382: PUSH
115383: EMPTY
115384: LIST
115385: LIST
115386: LIST
115387: PPUSH
115388: CALL_OW 72
115392: ST_TO_ADDR
// if z then
115393: LD_VAR 0 13
115397: IFFALSE 115443
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115399: LD_VAR 0 4
115403: PUSH
115404: LD_VAR 0 7
115408: ARRAY
115409: PPUSH
115410: LD_VAR 0 13
115414: PPUSH
115415: LD_VAR 0 4
115419: PUSH
115420: LD_VAR 0 7
115424: ARRAY
115425: PPUSH
115426: CALL_OW 74
115430: PPUSH
115431: CALL_OW 115
// attacking := true ;
115435: LD_ADDR_VAR 0 29
115439: PUSH
115440: LD_INT 1
115442: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115443: LD_VAR 0 4
115447: PUSH
115448: LD_VAR 0 7
115452: ARRAY
115453: PPUSH
115454: CALL_OW 256
115458: PUSH
115459: LD_INT 500
115461: LESS
115462: IFFALSE 115488
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115464: LD_VAR 0 4
115468: PUSH
115469: LD_VAR 0 7
115473: ARRAY
115474: PPUSH
115475: LD_VAR 0 14
115479: PUSH
115480: LD_INT 1
115482: ARRAY
115483: PPUSH
115484: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115488: LD_VAR 0 4
115492: PUSH
115493: LD_VAR 0 7
115497: ARRAY
115498: PPUSH
115499: CALL_OW 264
115503: PUSH
115504: LD_INT 49
115506: EQUAL
115507: IFFALSE 115628
// begin if not HasTask ( group [ i ] ) then
115509: LD_VAR 0 4
115513: PUSH
115514: LD_VAR 0 7
115518: ARRAY
115519: PPUSH
115520: CALL_OW 314
115524: NOT
115525: IFFALSE 115628
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115527: LD_ADDR_VAR 0 9
115531: PUSH
115532: LD_INT 81
115534: PUSH
115535: LD_VAR 0 4
115539: PUSH
115540: LD_VAR 0 7
115544: ARRAY
115545: PPUSH
115546: CALL_OW 255
115550: PUSH
115551: EMPTY
115552: LIST
115553: LIST
115554: PPUSH
115555: CALL_OW 69
115559: PPUSH
115560: LD_VAR 0 4
115564: PUSH
115565: LD_VAR 0 7
115569: ARRAY
115570: PPUSH
115571: CALL_OW 74
115575: ST_TO_ADDR
// if k then
115576: LD_VAR 0 9
115580: IFFALSE 115628
// if GetDistUnits ( group [ i ] , k ) > 10 then
115582: LD_VAR 0 4
115586: PUSH
115587: LD_VAR 0 7
115591: ARRAY
115592: PPUSH
115593: LD_VAR 0 9
115597: PPUSH
115598: CALL_OW 296
115602: PUSH
115603: LD_INT 10
115605: GREATER
115606: IFFALSE 115628
// ComMoveUnit ( group [ i ] , k ) ;
115608: LD_VAR 0 4
115612: PUSH
115613: LD_VAR 0 7
115617: ARRAY
115618: PPUSH
115619: LD_VAR 0 9
115623: PPUSH
115624: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
115628: LD_VAR 0 4
115632: PUSH
115633: LD_VAR 0 7
115637: ARRAY
115638: PPUSH
115639: CALL_OW 256
115643: PUSH
115644: LD_INT 250
115646: LESS
115647: PUSH
115648: LD_VAR 0 4
115652: PUSH
115653: LD_VAR 0 7
115657: ARRAY
115658: PUSH
115659: LD_INT 21
115661: PUSH
115662: LD_INT 2
115664: PUSH
115665: EMPTY
115666: LIST
115667: LIST
115668: PUSH
115669: LD_INT 23
115671: PUSH
115672: LD_INT 2
115674: PUSH
115675: EMPTY
115676: LIST
115677: LIST
115678: PUSH
115679: EMPTY
115680: LIST
115681: LIST
115682: PPUSH
115683: CALL_OW 69
115687: IN
115688: AND
115689: IFFALSE 115814
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
115691: LD_ADDR_VAR 0 9
115695: PUSH
115696: LD_OWVAR 3
115700: PUSH
115701: LD_VAR 0 4
115705: PUSH
115706: LD_VAR 0 7
115710: ARRAY
115711: DIFF
115712: PPUSH
115713: LD_VAR 0 4
115717: PUSH
115718: LD_VAR 0 7
115722: ARRAY
115723: PPUSH
115724: CALL_OW 74
115728: ST_TO_ADDR
// if not k then
115729: LD_VAR 0 9
115733: NOT
115734: IFFALSE 115738
// continue ;
115736: GO 112153
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
115738: LD_VAR 0 9
115742: PUSH
115743: LD_INT 81
115745: PUSH
115746: LD_VAR 0 4
115750: PUSH
115751: LD_VAR 0 7
115755: ARRAY
115756: PPUSH
115757: CALL_OW 255
115761: PUSH
115762: EMPTY
115763: LIST
115764: LIST
115765: PPUSH
115766: CALL_OW 69
115770: IN
115771: PUSH
115772: LD_VAR 0 9
115776: PPUSH
115777: LD_VAR 0 4
115781: PUSH
115782: LD_VAR 0 7
115786: ARRAY
115787: PPUSH
115788: CALL_OW 296
115792: PUSH
115793: LD_INT 5
115795: LESS
115796: AND
115797: IFFALSE 115814
// ComAutodestruct ( group [ i ] ) ;
115799: LD_VAR 0 4
115803: PUSH
115804: LD_VAR 0 7
115808: ARRAY
115809: PPUSH
115810: CALL 84987 0 1
// end ; if f_attack_depot then
115814: LD_VAR 0 25
115818: IFFALSE 115930
// begin k := 6 ;
115820: LD_ADDR_VAR 0 9
115824: PUSH
115825: LD_INT 6
115827: ST_TO_ADDR
// if tmp < k then
115828: LD_VAR 0 14
115832: PUSH
115833: LD_VAR 0 9
115837: LESS
115838: IFFALSE 115850
// k := tmp ;
115840: LD_ADDR_VAR 0 9
115844: PUSH
115845: LD_VAR 0 14
115849: ST_TO_ADDR
// for j = 1 to k do
115850: LD_ADDR_VAR 0 8
115854: PUSH
115855: DOUBLE
115856: LD_INT 1
115858: DEC
115859: ST_TO_ADDR
115860: LD_VAR 0 9
115864: PUSH
115865: FOR_TO
115866: IFFALSE 115928
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
115868: LD_VAR 0 8
115872: PPUSH
115873: CALL_OW 266
115877: PUSH
115878: LD_INT 0
115880: PUSH
115881: LD_INT 1
115883: PUSH
115884: EMPTY
115885: LIST
115886: LIST
115887: IN
115888: IFFALSE 115926
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115890: LD_VAR 0 4
115894: PUSH
115895: LD_VAR 0 7
115899: ARRAY
115900: PPUSH
115901: LD_VAR 0 14
115905: PUSH
115906: LD_VAR 0 8
115910: ARRAY
115911: PPUSH
115912: CALL_OW 115
// attacking := true ;
115916: LD_ADDR_VAR 0 29
115920: PUSH
115921: LD_INT 1
115923: ST_TO_ADDR
// break ;
115924: GO 115928
// end ;
115926: GO 115865
115928: POP
115929: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
115930: LD_VAR 0 4
115934: PUSH
115935: LD_VAR 0 7
115939: ARRAY
115940: PPUSH
115941: CALL_OW 302
115945: PUSH
115946: LD_VAR 0 29
115950: NOT
115951: AND
115952: IFFALSE 116274
// begin if GetTag ( group [ i ] ) = 71 then
115954: LD_VAR 0 4
115958: PUSH
115959: LD_VAR 0 7
115963: ARRAY
115964: PPUSH
115965: CALL_OW 110
115969: PUSH
115970: LD_INT 71
115972: EQUAL
115973: IFFALSE 116014
// begin if HasTask ( group [ i ] ) then
115975: LD_VAR 0 4
115979: PUSH
115980: LD_VAR 0 7
115984: ARRAY
115985: PPUSH
115986: CALL_OW 314
115990: IFFALSE 115996
// continue else
115992: GO 112153
115994: GO 116014
// SetTag ( group [ i ] , 0 ) ;
115996: LD_VAR 0 4
116000: PUSH
116001: LD_VAR 0 7
116005: ARRAY
116006: PPUSH
116007: LD_INT 0
116009: PPUSH
116010: CALL_OW 109
// end ; k := 8 ;
116014: LD_ADDR_VAR 0 9
116018: PUSH
116019: LD_INT 8
116021: ST_TO_ADDR
// x := 0 ;
116022: LD_ADDR_VAR 0 10
116026: PUSH
116027: LD_INT 0
116029: ST_TO_ADDR
// if tmp < k then
116030: LD_VAR 0 14
116034: PUSH
116035: LD_VAR 0 9
116039: LESS
116040: IFFALSE 116052
// k := tmp ;
116042: LD_ADDR_VAR 0 9
116046: PUSH
116047: LD_VAR 0 14
116051: ST_TO_ADDR
// for j = 1 to k do
116052: LD_ADDR_VAR 0 8
116056: PUSH
116057: DOUBLE
116058: LD_INT 1
116060: DEC
116061: ST_TO_ADDR
116062: LD_VAR 0 9
116066: PUSH
116067: FOR_TO
116068: IFFALSE 116166
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116070: LD_VAR 0 14
116074: PUSH
116075: LD_VAR 0 8
116079: ARRAY
116080: PPUSH
116081: CALL_OW 247
116085: PUSH
116086: LD_INT 1
116088: EQUAL
116089: PUSH
116090: LD_VAR 0 14
116094: PUSH
116095: LD_VAR 0 8
116099: ARRAY
116100: PPUSH
116101: CALL_OW 256
116105: PUSH
116106: LD_INT 250
116108: LESS
116109: PUSH
116110: LD_VAR 0 20
116114: AND
116115: PUSH
116116: LD_VAR 0 20
116120: NOT
116121: PUSH
116122: LD_VAR 0 14
116126: PUSH
116127: LD_VAR 0 8
116131: ARRAY
116132: PPUSH
116133: CALL_OW 256
116137: PUSH
116138: LD_INT 250
116140: GREATEREQUAL
116141: AND
116142: OR
116143: AND
116144: IFFALSE 116164
// begin x := tmp [ j ] ;
116146: LD_ADDR_VAR 0 10
116150: PUSH
116151: LD_VAR 0 14
116155: PUSH
116156: LD_VAR 0 8
116160: ARRAY
116161: ST_TO_ADDR
// break ;
116162: GO 116166
// end ;
116164: GO 116067
116166: POP
116167: POP
// if x then
116168: LD_VAR 0 10
116172: IFFALSE 116196
// ComAttackUnit ( group [ i ] , x ) else
116174: LD_VAR 0 4
116178: PUSH
116179: LD_VAR 0 7
116183: ARRAY
116184: PPUSH
116185: LD_VAR 0 10
116189: PPUSH
116190: CALL_OW 115
116194: GO 116220
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116196: LD_VAR 0 4
116200: PUSH
116201: LD_VAR 0 7
116205: ARRAY
116206: PPUSH
116207: LD_VAR 0 14
116211: PUSH
116212: LD_INT 1
116214: ARRAY
116215: PPUSH
116216: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116220: LD_VAR 0 4
116224: PUSH
116225: LD_VAR 0 7
116229: ARRAY
116230: PPUSH
116231: CALL_OW 314
116235: NOT
116236: IFFALSE 116274
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116238: LD_VAR 0 4
116242: PUSH
116243: LD_VAR 0 7
116247: ARRAY
116248: PPUSH
116249: LD_VAR 0 14
116253: PPUSH
116254: LD_VAR 0 4
116258: PUSH
116259: LD_VAR 0 7
116263: ARRAY
116264: PPUSH
116265: CALL_OW 74
116269: PPUSH
116270: CALL_OW 115
// end ; end ; end ;
116274: GO 112153
116276: POP
116277: POP
// wait ( 0 0$2 ) ;
116278: LD_INT 70
116280: PPUSH
116281: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116285: LD_VAR 0 4
116289: NOT
116290: PUSH
116291: LD_VAR 0 4
116295: PUSH
116296: EMPTY
116297: EQUAL
116298: OR
116299: PUSH
116300: LD_INT 81
116302: PUSH
116303: LD_VAR 0 35
116307: PUSH
116308: EMPTY
116309: LIST
116310: LIST
116311: PPUSH
116312: CALL_OW 69
116316: NOT
116317: OR
116318: IFFALSE 112138
// end ;
116320: LD_VAR 0 2
116324: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116325: LD_INT 0
116327: PPUSH
116328: PPUSH
116329: PPUSH
116330: PPUSH
116331: PPUSH
116332: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116333: LD_VAR 0 1
116337: NOT
116338: PUSH
116339: LD_EXP 96
116343: PUSH
116344: LD_VAR 0 1
116348: ARRAY
116349: NOT
116350: OR
116351: PUSH
116352: LD_VAR 0 2
116356: NOT
116357: OR
116358: IFFALSE 116362
// exit ;
116360: GO 116916
// side := mc_sides [ base ] ;
116362: LD_ADDR_VAR 0 6
116366: PUSH
116367: LD_EXP 122
116371: PUSH
116372: LD_VAR 0 1
116376: ARRAY
116377: ST_TO_ADDR
// if not side then
116378: LD_VAR 0 6
116382: NOT
116383: IFFALSE 116387
// exit ;
116385: GO 116916
// for i in solds do
116387: LD_ADDR_VAR 0 7
116391: PUSH
116392: LD_VAR 0 2
116396: PUSH
116397: FOR_IN
116398: IFFALSE 116459
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116400: LD_VAR 0 7
116404: PPUSH
116405: CALL_OW 310
116409: PPUSH
116410: CALL_OW 266
116414: PUSH
116415: LD_INT 32
116417: PUSH
116418: LD_INT 31
116420: PUSH
116421: EMPTY
116422: LIST
116423: LIST
116424: IN
116425: IFFALSE 116445
// solds := solds diff i else
116427: LD_ADDR_VAR 0 2
116431: PUSH
116432: LD_VAR 0 2
116436: PUSH
116437: LD_VAR 0 7
116441: DIFF
116442: ST_TO_ADDR
116443: GO 116457
// SetTag ( i , 18 ) ;
116445: LD_VAR 0 7
116449: PPUSH
116450: LD_INT 18
116452: PPUSH
116453: CALL_OW 109
116457: GO 116397
116459: POP
116460: POP
// if not solds then
116461: LD_VAR 0 2
116465: NOT
116466: IFFALSE 116470
// exit ;
116468: GO 116916
// repeat wait ( 0 0$2 ) ;
116470: LD_INT 70
116472: PPUSH
116473: CALL_OW 67
// enemy := mc_scan [ base ] ;
116477: LD_ADDR_VAR 0 4
116481: PUSH
116482: LD_EXP 119
116486: PUSH
116487: LD_VAR 0 1
116491: ARRAY
116492: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116493: LD_EXP 96
116497: PUSH
116498: LD_VAR 0 1
116502: ARRAY
116503: NOT
116504: PUSH
116505: LD_EXP 96
116509: PUSH
116510: LD_VAR 0 1
116514: ARRAY
116515: PUSH
116516: EMPTY
116517: EQUAL
116518: OR
116519: IFFALSE 116556
// begin for i in solds do
116521: LD_ADDR_VAR 0 7
116525: PUSH
116526: LD_VAR 0 2
116530: PUSH
116531: FOR_IN
116532: IFFALSE 116545
// ComStop ( i ) ;
116534: LD_VAR 0 7
116538: PPUSH
116539: CALL_OW 141
116543: GO 116531
116545: POP
116546: POP
// solds := [ ] ;
116547: LD_ADDR_VAR 0 2
116551: PUSH
116552: EMPTY
116553: ST_TO_ADDR
// exit ;
116554: GO 116916
// end ; for i in solds do
116556: LD_ADDR_VAR 0 7
116560: PUSH
116561: LD_VAR 0 2
116565: PUSH
116566: FOR_IN
116567: IFFALSE 116888
// begin if IsInUnit ( i ) then
116569: LD_VAR 0 7
116573: PPUSH
116574: CALL_OW 310
116578: IFFALSE 116589
// ComExitBuilding ( i ) ;
116580: LD_VAR 0 7
116584: PPUSH
116585: CALL_OW 122
// if GetLives ( i ) > 500 then
116589: LD_VAR 0 7
116593: PPUSH
116594: CALL_OW 256
116598: PUSH
116599: LD_INT 500
116601: GREATER
116602: IFFALSE 116655
// begin e := NearestUnitToUnit ( enemy , i ) ;
116604: LD_ADDR_VAR 0 5
116608: PUSH
116609: LD_VAR 0 4
116613: PPUSH
116614: LD_VAR 0 7
116618: PPUSH
116619: CALL_OW 74
116623: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
116624: LD_VAR 0 7
116628: PPUSH
116629: LD_VAR 0 5
116633: PPUSH
116634: CALL_OW 250
116638: PPUSH
116639: LD_VAR 0 5
116643: PPUSH
116644: CALL_OW 251
116648: PPUSH
116649: CALL_OW 114
// end else
116653: GO 116886
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
116655: LD_VAR 0 7
116659: PPUSH
116660: LD_EXP 96
116664: PUSH
116665: LD_VAR 0 1
116669: ARRAY
116670: PPUSH
116671: LD_INT 2
116673: PUSH
116674: LD_INT 30
116676: PUSH
116677: LD_INT 0
116679: PUSH
116680: EMPTY
116681: LIST
116682: LIST
116683: PUSH
116684: LD_INT 30
116686: PUSH
116687: LD_INT 1
116689: PUSH
116690: EMPTY
116691: LIST
116692: LIST
116693: PUSH
116694: LD_INT 30
116696: PUSH
116697: LD_INT 6
116699: PUSH
116700: EMPTY
116701: LIST
116702: LIST
116703: PUSH
116704: EMPTY
116705: LIST
116706: LIST
116707: LIST
116708: LIST
116709: PPUSH
116710: CALL_OW 72
116714: PPUSH
116715: LD_VAR 0 7
116719: PPUSH
116720: CALL_OW 74
116724: PPUSH
116725: CALL_OW 296
116729: PUSH
116730: LD_INT 10
116732: GREATER
116733: IFFALSE 116886
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
116735: LD_ADDR_VAR 0 8
116739: PUSH
116740: LD_EXP 96
116744: PUSH
116745: LD_VAR 0 1
116749: ARRAY
116750: PPUSH
116751: LD_INT 2
116753: PUSH
116754: LD_INT 30
116756: PUSH
116757: LD_INT 0
116759: PUSH
116760: EMPTY
116761: LIST
116762: LIST
116763: PUSH
116764: LD_INT 30
116766: PUSH
116767: LD_INT 1
116769: PUSH
116770: EMPTY
116771: LIST
116772: LIST
116773: PUSH
116774: LD_INT 30
116776: PUSH
116777: LD_INT 6
116779: PUSH
116780: EMPTY
116781: LIST
116782: LIST
116783: PUSH
116784: EMPTY
116785: LIST
116786: LIST
116787: LIST
116788: LIST
116789: PPUSH
116790: CALL_OW 72
116794: PPUSH
116795: LD_VAR 0 7
116799: PPUSH
116800: CALL_OW 74
116804: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
116805: LD_VAR 0 7
116809: PPUSH
116810: LD_VAR 0 8
116814: PPUSH
116815: CALL_OW 250
116819: PPUSH
116820: LD_INT 3
116822: PPUSH
116823: LD_INT 5
116825: PPUSH
116826: CALL_OW 272
116830: PPUSH
116831: LD_VAR 0 8
116835: PPUSH
116836: CALL_OW 251
116840: PPUSH
116841: LD_INT 3
116843: PPUSH
116844: LD_INT 5
116846: PPUSH
116847: CALL_OW 273
116851: PPUSH
116852: CALL_OW 111
// SetTag ( i , 0 ) ;
116856: LD_VAR 0 7
116860: PPUSH
116861: LD_INT 0
116863: PPUSH
116864: CALL_OW 109
// solds := solds diff i ;
116868: LD_ADDR_VAR 0 2
116872: PUSH
116873: LD_VAR 0 2
116877: PUSH
116878: LD_VAR 0 7
116882: DIFF
116883: ST_TO_ADDR
// continue ;
116884: GO 116566
// end ; end ;
116886: GO 116566
116888: POP
116889: POP
// until not solds or not enemy ;
116890: LD_VAR 0 2
116894: NOT
116895: PUSH
116896: LD_VAR 0 4
116900: NOT
116901: OR
116902: IFFALSE 116470
// MC_Reset ( base , 18 ) ;
116904: LD_VAR 0 1
116908: PPUSH
116909: LD_INT 18
116911: PPUSH
116912: CALL 25582 0 2
// end ;
116916: LD_VAR 0 3
116920: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
116921: LD_INT 0
116923: PPUSH
116924: PPUSH
116925: PPUSH
116926: PPUSH
116927: PPUSH
116928: PPUSH
116929: PPUSH
116930: PPUSH
116931: PPUSH
116932: PPUSH
116933: PPUSH
116934: PPUSH
116935: PPUSH
116936: PPUSH
116937: PPUSH
116938: PPUSH
116939: PPUSH
116940: PPUSH
116941: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
116942: LD_ADDR_VAR 0 12
116946: PUSH
116947: LD_EXP 96
116951: PUSH
116952: LD_VAR 0 1
116956: ARRAY
116957: PPUSH
116958: LD_INT 25
116960: PUSH
116961: LD_INT 3
116963: PUSH
116964: EMPTY
116965: LIST
116966: LIST
116967: PPUSH
116968: CALL_OW 72
116972: ST_TO_ADDR
// if mc_remote_driver [ base ] then
116973: LD_EXP 136
116977: PUSH
116978: LD_VAR 0 1
116982: ARRAY
116983: IFFALSE 117007
// mechs := mechs diff mc_remote_driver [ base ] ;
116985: LD_ADDR_VAR 0 12
116989: PUSH
116990: LD_VAR 0 12
116994: PUSH
116995: LD_EXP 136
116999: PUSH
117000: LD_VAR 0 1
117004: ARRAY
117005: DIFF
117006: ST_TO_ADDR
// for i in mechs do
117007: LD_ADDR_VAR 0 4
117011: PUSH
117012: LD_VAR 0 12
117016: PUSH
117017: FOR_IN
117018: IFFALSE 117053
// if GetTag ( i ) > 0 then
117020: LD_VAR 0 4
117024: PPUSH
117025: CALL_OW 110
117029: PUSH
117030: LD_INT 0
117032: GREATER
117033: IFFALSE 117051
// mechs := mechs diff i ;
117035: LD_ADDR_VAR 0 12
117039: PUSH
117040: LD_VAR 0 12
117044: PUSH
117045: LD_VAR 0 4
117049: DIFF
117050: ST_TO_ADDR
117051: GO 117017
117053: POP
117054: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117055: LD_ADDR_VAR 0 8
117059: PUSH
117060: LD_EXP 96
117064: PUSH
117065: LD_VAR 0 1
117069: ARRAY
117070: PPUSH
117071: LD_INT 2
117073: PUSH
117074: LD_INT 25
117076: PUSH
117077: LD_INT 1
117079: PUSH
117080: EMPTY
117081: LIST
117082: LIST
117083: PUSH
117084: LD_INT 25
117086: PUSH
117087: LD_INT 5
117089: PUSH
117090: EMPTY
117091: LIST
117092: LIST
117093: PUSH
117094: LD_INT 25
117096: PUSH
117097: LD_INT 8
117099: PUSH
117100: EMPTY
117101: LIST
117102: LIST
117103: PUSH
117104: LD_INT 25
117106: PUSH
117107: LD_INT 9
117109: PUSH
117110: EMPTY
117111: LIST
117112: LIST
117113: PUSH
117114: EMPTY
117115: LIST
117116: LIST
117117: LIST
117118: LIST
117119: LIST
117120: PPUSH
117121: CALL_OW 72
117125: ST_TO_ADDR
// if not defenders and not solds then
117126: LD_VAR 0 2
117130: NOT
117131: PUSH
117132: LD_VAR 0 8
117136: NOT
117137: AND
117138: IFFALSE 117142
// exit ;
117140: GO 118912
// depot_under_attack := false ;
117142: LD_ADDR_VAR 0 16
117146: PUSH
117147: LD_INT 0
117149: ST_TO_ADDR
// sold_defenders := [ ] ;
117150: LD_ADDR_VAR 0 17
117154: PUSH
117155: EMPTY
117156: ST_TO_ADDR
// if mechs then
117157: LD_VAR 0 12
117161: IFFALSE 117314
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117163: LD_ADDR_VAR 0 4
117167: PUSH
117168: LD_VAR 0 2
117172: PPUSH
117173: LD_INT 21
117175: PUSH
117176: LD_INT 2
117178: PUSH
117179: EMPTY
117180: LIST
117181: LIST
117182: PPUSH
117183: CALL_OW 72
117187: PUSH
117188: FOR_IN
117189: IFFALSE 117312
// begin if GetTag ( i ) <> 20 then
117191: LD_VAR 0 4
117195: PPUSH
117196: CALL_OW 110
117200: PUSH
117201: LD_INT 20
117203: NONEQUAL
117204: IFFALSE 117218
// SetTag ( i , 20 ) ;
117206: LD_VAR 0 4
117210: PPUSH
117211: LD_INT 20
117213: PPUSH
117214: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117218: LD_VAR 0 4
117222: PPUSH
117223: CALL_OW 263
117227: PUSH
117228: LD_INT 1
117230: EQUAL
117231: PUSH
117232: LD_VAR 0 4
117236: PPUSH
117237: CALL_OW 311
117241: NOT
117242: AND
117243: IFFALSE 117310
// begin un := mechs [ 1 ] ;
117245: LD_ADDR_VAR 0 10
117249: PUSH
117250: LD_VAR 0 12
117254: PUSH
117255: LD_INT 1
117257: ARRAY
117258: ST_TO_ADDR
// ComExit ( un ) ;
117259: LD_VAR 0 10
117263: PPUSH
117264: CALL 89276 0 1
// AddComEnterUnit ( un , i ) ;
117268: LD_VAR 0 10
117272: PPUSH
117273: LD_VAR 0 4
117277: PPUSH
117278: CALL_OW 180
// SetTag ( un , 19 ) ;
117282: LD_VAR 0 10
117286: PPUSH
117287: LD_INT 19
117289: PPUSH
117290: CALL_OW 109
// mechs := mechs diff un ;
117294: LD_ADDR_VAR 0 12
117298: PUSH
117299: LD_VAR 0 12
117303: PUSH
117304: LD_VAR 0 10
117308: DIFF
117309: ST_TO_ADDR
// end ; end ;
117310: GO 117188
117312: POP
117313: POP
// if solds then
117314: LD_VAR 0 8
117318: IFFALSE 117377
// for i in solds do
117320: LD_ADDR_VAR 0 4
117324: PUSH
117325: LD_VAR 0 8
117329: PUSH
117330: FOR_IN
117331: IFFALSE 117375
// if not GetTag ( i ) then
117333: LD_VAR 0 4
117337: PPUSH
117338: CALL_OW 110
117342: NOT
117343: IFFALSE 117373
// begin defenders := defenders union i ;
117345: LD_ADDR_VAR 0 2
117349: PUSH
117350: LD_VAR 0 2
117354: PUSH
117355: LD_VAR 0 4
117359: UNION
117360: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117361: LD_VAR 0 4
117365: PPUSH
117366: LD_INT 18
117368: PPUSH
117369: CALL_OW 109
// end ;
117373: GO 117330
117375: POP
117376: POP
// repeat wait ( 0 0$2 ) ;
117377: LD_INT 70
117379: PPUSH
117380: CALL_OW 67
// enemy := mc_scan [ base ] ;
117384: LD_ADDR_VAR 0 21
117388: PUSH
117389: LD_EXP 119
117393: PUSH
117394: LD_VAR 0 1
117398: ARRAY
117399: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117400: LD_EXP 96
117404: PUSH
117405: LD_VAR 0 1
117409: ARRAY
117410: NOT
117411: PUSH
117412: LD_EXP 96
117416: PUSH
117417: LD_VAR 0 1
117421: ARRAY
117422: PUSH
117423: EMPTY
117424: EQUAL
117425: OR
117426: IFFALSE 117463
// begin for i in defenders do
117428: LD_ADDR_VAR 0 4
117432: PUSH
117433: LD_VAR 0 2
117437: PUSH
117438: FOR_IN
117439: IFFALSE 117452
// ComStop ( i ) ;
117441: LD_VAR 0 4
117445: PPUSH
117446: CALL_OW 141
117450: GO 117438
117452: POP
117453: POP
// defenders := [ ] ;
117454: LD_ADDR_VAR 0 2
117458: PUSH
117459: EMPTY
117460: ST_TO_ADDR
// exit ;
117461: GO 118912
// end ; for i in defenders do
117463: LD_ADDR_VAR 0 4
117467: PUSH
117468: LD_VAR 0 2
117472: PUSH
117473: FOR_IN
117474: IFFALSE 118372
// begin e := NearestUnitToUnit ( enemy , i ) ;
117476: LD_ADDR_VAR 0 13
117480: PUSH
117481: LD_VAR 0 21
117485: PPUSH
117486: LD_VAR 0 4
117490: PPUSH
117491: CALL_OW 74
117495: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117496: LD_ADDR_VAR 0 7
117500: PUSH
117501: LD_EXP 96
117505: PUSH
117506: LD_VAR 0 1
117510: ARRAY
117511: PPUSH
117512: LD_INT 2
117514: PUSH
117515: LD_INT 30
117517: PUSH
117518: LD_INT 0
117520: PUSH
117521: EMPTY
117522: LIST
117523: LIST
117524: PUSH
117525: LD_INT 30
117527: PUSH
117528: LD_INT 1
117530: PUSH
117531: EMPTY
117532: LIST
117533: LIST
117534: PUSH
117535: EMPTY
117536: LIST
117537: LIST
117538: LIST
117539: PPUSH
117540: CALL_OW 72
117544: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117545: LD_ADDR_VAR 0 16
117549: PUSH
117550: LD_VAR 0 7
117554: NOT
117555: PUSH
117556: LD_VAR 0 7
117560: PPUSH
117561: LD_INT 3
117563: PUSH
117564: LD_INT 24
117566: PUSH
117567: LD_INT 600
117569: PUSH
117570: EMPTY
117571: LIST
117572: LIST
117573: PUSH
117574: EMPTY
117575: LIST
117576: LIST
117577: PPUSH
117578: CALL_OW 72
117582: OR
117583: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117584: LD_VAR 0 4
117588: PPUSH
117589: CALL_OW 247
117593: PUSH
117594: LD_INT 2
117596: DOUBLE
117597: EQUAL
117598: IFTRUE 117602
117600: GO 117998
117602: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
117603: LD_VAR 0 4
117607: PPUSH
117608: CALL_OW 256
117612: PUSH
117613: LD_INT 1000
117615: EQUAL
117616: PUSH
117617: LD_VAR 0 4
117621: PPUSH
117622: LD_VAR 0 13
117626: PPUSH
117627: CALL_OW 296
117631: PUSH
117632: LD_INT 40
117634: LESS
117635: PUSH
117636: LD_VAR 0 13
117640: PPUSH
117641: LD_EXP 121
117645: PUSH
117646: LD_VAR 0 1
117650: ARRAY
117651: PPUSH
117652: CALL_OW 308
117656: OR
117657: AND
117658: IFFALSE 117780
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
117660: LD_VAR 0 4
117664: PPUSH
117665: CALL_OW 262
117669: PUSH
117670: LD_INT 1
117672: EQUAL
117673: PUSH
117674: LD_VAR 0 4
117678: PPUSH
117679: CALL_OW 261
117683: PUSH
117684: LD_INT 30
117686: LESS
117687: AND
117688: PUSH
117689: LD_VAR 0 7
117693: AND
117694: IFFALSE 117764
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
117696: LD_VAR 0 4
117700: PPUSH
117701: LD_VAR 0 7
117705: PPUSH
117706: LD_VAR 0 4
117710: PPUSH
117711: CALL_OW 74
117715: PPUSH
117716: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
117720: LD_VAR 0 4
117724: PPUSH
117725: LD_VAR 0 7
117729: PPUSH
117730: LD_VAR 0 4
117734: PPUSH
117735: CALL_OW 74
117739: PPUSH
117740: CALL_OW 296
117744: PUSH
117745: LD_INT 6
117747: LESS
117748: IFFALSE 117762
// SetFuel ( i , 100 ) ;
117750: LD_VAR 0 4
117754: PPUSH
117755: LD_INT 100
117757: PPUSH
117758: CALL_OW 240
// end else
117762: GO 117778
// ComAttackUnit ( i , e ) ;
117764: LD_VAR 0 4
117768: PPUSH
117769: LD_VAR 0 13
117773: PPUSH
117774: CALL_OW 115
// end else
117778: GO 117881
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
117780: LD_VAR 0 13
117784: PPUSH
117785: LD_EXP 121
117789: PUSH
117790: LD_VAR 0 1
117794: ARRAY
117795: PPUSH
117796: CALL_OW 308
117800: NOT
117801: PUSH
117802: LD_VAR 0 4
117806: PPUSH
117807: LD_VAR 0 13
117811: PPUSH
117812: CALL_OW 296
117816: PUSH
117817: LD_INT 40
117819: GREATEREQUAL
117820: AND
117821: PUSH
117822: LD_VAR 0 4
117826: PPUSH
117827: CALL_OW 256
117831: PUSH
117832: LD_INT 650
117834: LESSEQUAL
117835: OR
117836: PUSH
117837: LD_VAR 0 4
117841: PPUSH
117842: LD_EXP 120
117846: PUSH
117847: LD_VAR 0 1
117851: ARRAY
117852: PPUSH
117853: CALL_OW 308
117857: NOT
117858: AND
117859: IFFALSE 117881
// ComMoveToArea ( i , mc_parking [ base ] ) ;
117861: LD_VAR 0 4
117865: PPUSH
117866: LD_EXP 120
117870: PUSH
117871: LD_VAR 0 1
117875: ARRAY
117876: PPUSH
117877: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
117881: LD_VAR 0 4
117885: PPUSH
117886: CALL_OW 256
117890: PUSH
117891: LD_INT 1000
117893: LESS
117894: PUSH
117895: LD_VAR 0 4
117899: PPUSH
117900: CALL_OW 263
117904: PUSH
117905: LD_INT 1
117907: EQUAL
117908: AND
117909: PUSH
117910: LD_VAR 0 4
117914: PPUSH
117915: CALL_OW 311
117919: AND
117920: PUSH
117921: LD_VAR 0 4
117925: PPUSH
117926: LD_EXP 120
117930: PUSH
117931: LD_VAR 0 1
117935: ARRAY
117936: PPUSH
117937: CALL_OW 308
117941: AND
117942: IFFALSE 117996
// begin mech := IsDrivenBy ( i ) ;
117944: LD_ADDR_VAR 0 9
117948: PUSH
117949: LD_VAR 0 4
117953: PPUSH
117954: CALL_OW 311
117958: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
117959: LD_VAR 0 9
117963: PPUSH
117964: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
117968: LD_VAR 0 9
117972: PPUSH
117973: LD_VAR 0 4
117977: PPUSH
117978: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
117982: LD_VAR 0 9
117986: PPUSH
117987: LD_VAR 0 4
117991: PPUSH
117992: CALL_OW 180
// end ; end ; unit_human :
117996: GO 118343
117998: LD_INT 1
118000: DOUBLE
118001: EQUAL
118002: IFTRUE 118006
118004: GO 118342
118006: POP
// begin b := IsInUnit ( i ) ;
118007: LD_ADDR_VAR 0 18
118011: PUSH
118012: LD_VAR 0 4
118016: PPUSH
118017: CALL_OW 310
118021: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118022: LD_ADDR_VAR 0 19
118026: PUSH
118027: LD_VAR 0 18
118031: NOT
118032: PUSH
118033: LD_VAR 0 18
118037: PPUSH
118038: CALL_OW 266
118042: PUSH
118043: LD_INT 32
118045: PUSH
118046: LD_INT 31
118048: PUSH
118049: EMPTY
118050: LIST
118051: LIST
118052: IN
118053: OR
118054: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118055: LD_VAR 0 18
118059: PPUSH
118060: CALL_OW 266
118064: PUSH
118065: LD_INT 5
118067: EQUAL
118068: PUSH
118069: LD_VAR 0 4
118073: PPUSH
118074: CALL_OW 257
118078: PUSH
118079: LD_INT 1
118081: PUSH
118082: LD_INT 2
118084: PUSH
118085: LD_INT 3
118087: PUSH
118088: LD_INT 4
118090: PUSH
118091: EMPTY
118092: LIST
118093: LIST
118094: LIST
118095: LIST
118096: IN
118097: AND
118098: IFFALSE 118135
// begin class := AllowSpecClass ( i ) ;
118100: LD_ADDR_VAR 0 20
118104: PUSH
118105: LD_VAR 0 4
118109: PPUSH
118110: CALL 53840 0 1
118114: ST_TO_ADDR
// if class then
118115: LD_VAR 0 20
118119: IFFALSE 118135
// ComChangeProfession ( i , class ) ;
118121: LD_VAR 0 4
118125: PPUSH
118126: LD_VAR 0 20
118130: PPUSH
118131: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118135: LD_VAR 0 16
118139: PUSH
118140: LD_VAR 0 2
118144: PPUSH
118145: LD_INT 21
118147: PUSH
118148: LD_INT 2
118150: PUSH
118151: EMPTY
118152: LIST
118153: LIST
118154: PPUSH
118155: CALL_OW 72
118159: PUSH
118160: LD_INT 1
118162: LESSEQUAL
118163: OR
118164: PUSH
118165: LD_VAR 0 19
118169: AND
118170: PUSH
118171: LD_VAR 0 4
118175: PUSH
118176: LD_VAR 0 17
118180: IN
118181: NOT
118182: AND
118183: IFFALSE 118276
// begin if b then
118185: LD_VAR 0 18
118189: IFFALSE 118238
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118191: LD_VAR 0 18
118195: PPUSH
118196: LD_VAR 0 21
118200: PPUSH
118201: LD_VAR 0 18
118205: PPUSH
118206: CALL_OW 74
118210: PPUSH
118211: CALL_OW 296
118215: PUSH
118216: LD_INT 10
118218: LESS
118219: PUSH
118220: LD_VAR 0 18
118224: PPUSH
118225: CALL_OW 461
118229: PUSH
118230: LD_INT 7
118232: NONEQUAL
118233: AND
118234: IFFALSE 118238
// continue ;
118236: GO 117473
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118238: LD_ADDR_VAR 0 17
118242: PUSH
118243: LD_VAR 0 17
118247: PPUSH
118248: LD_VAR 0 17
118252: PUSH
118253: LD_INT 1
118255: PLUS
118256: PPUSH
118257: LD_VAR 0 4
118261: PPUSH
118262: CALL_OW 1
118266: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118267: LD_VAR 0 4
118271: PPUSH
118272: CALL_OW 122
// end ; if sold_defenders then
118276: LD_VAR 0 17
118280: IFFALSE 118340
// if i in sold_defenders then
118282: LD_VAR 0 4
118286: PUSH
118287: LD_VAR 0 17
118291: IN
118292: IFFALSE 118340
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118294: LD_VAR 0 4
118298: PPUSH
118299: CALL_OW 314
118303: NOT
118304: PUSH
118305: LD_VAR 0 4
118309: PPUSH
118310: LD_VAR 0 13
118314: PPUSH
118315: CALL_OW 296
118319: PUSH
118320: LD_INT 30
118322: LESS
118323: AND
118324: IFFALSE 118340
// ComAttackUnit ( i , e ) ;
118326: LD_VAR 0 4
118330: PPUSH
118331: LD_VAR 0 13
118335: PPUSH
118336: CALL_OW 115
// end ; end ; end ;
118340: GO 118343
118342: POP
// if IsDead ( i ) then
118343: LD_VAR 0 4
118347: PPUSH
118348: CALL_OW 301
118352: IFFALSE 118370
// defenders := defenders diff i ;
118354: LD_ADDR_VAR 0 2
118358: PUSH
118359: LD_VAR 0 2
118363: PUSH
118364: LD_VAR 0 4
118368: DIFF
118369: ST_TO_ADDR
// end ;
118370: GO 117473
118372: POP
118373: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118374: LD_VAR 0 21
118378: NOT
118379: PUSH
118380: LD_VAR 0 2
118384: NOT
118385: OR
118386: PUSH
118387: LD_EXP 96
118391: PUSH
118392: LD_VAR 0 1
118396: ARRAY
118397: NOT
118398: OR
118399: IFFALSE 117377
// MC_Reset ( base , 18 ) ;
118401: LD_VAR 0 1
118405: PPUSH
118406: LD_INT 18
118408: PPUSH
118409: CALL 25582 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118413: LD_ADDR_VAR 0 2
118417: PUSH
118418: LD_VAR 0 2
118422: PUSH
118423: LD_VAR 0 2
118427: PPUSH
118428: LD_INT 2
118430: PUSH
118431: LD_INT 25
118433: PUSH
118434: LD_INT 1
118436: PUSH
118437: EMPTY
118438: LIST
118439: LIST
118440: PUSH
118441: LD_INT 25
118443: PUSH
118444: LD_INT 5
118446: PUSH
118447: EMPTY
118448: LIST
118449: LIST
118450: PUSH
118451: LD_INT 25
118453: PUSH
118454: LD_INT 8
118456: PUSH
118457: EMPTY
118458: LIST
118459: LIST
118460: PUSH
118461: LD_INT 25
118463: PUSH
118464: LD_INT 9
118466: PUSH
118467: EMPTY
118468: LIST
118469: LIST
118470: PUSH
118471: EMPTY
118472: LIST
118473: LIST
118474: LIST
118475: LIST
118476: LIST
118477: PPUSH
118478: CALL_OW 72
118482: DIFF
118483: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118484: LD_VAR 0 21
118488: NOT
118489: PUSH
118490: LD_VAR 0 2
118494: PPUSH
118495: LD_INT 21
118497: PUSH
118498: LD_INT 2
118500: PUSH
118501: EMPTY
118502: LIST
118503: LIST
118504: PPUSH
118505: CALL_OW 72
118509: AND
118510: IFFALSE 118848
// begin tmp := FilterByTag ( defenders , 19 ) ;
118512: LD_ADDR_VAR 0 11
118516: PUSH
118517: LD_VAR 0 2
118521: PPUSH
118522: LD_INT 19
118524: PPUSH
118525: CALL 86462 0 2
118529: ST_TO_ADDR
// if tmp then
118530: LD_VAR 0 11
118534: IFFALSE 118604
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118536: LD_ADDR_VAR 0 11
118540: PUSH
118541: LD_VAR 0 11
118545: PPUSH
118546: LD_INT 25
118548: PUSH
118549: LD_INT 3
118551: PUSH
118552: EMPTY
118553: LIST
118554: LIST
118555: PPUSH
118556: CALL_OW 72
118560: ST_TO_ADDR
// if tmp then
118561: LD_VAR 0 11
118565: IFFALSE 118604
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118567: LD_ADDR_EXP 108
118571: PUSH
118572: LD_EXP 108
118576: PPUSH
118577: LD_VAR 0 1
118581: PPUSH
118582: LD_EXP 108
118586: PUSH
118587: LD_VAR 0 1
118591: ARRAY
118592: PUSH
118593: LD_VAR 0 11
118597: UNION
118598: PPUSH
118599: CALL_OW 1
118603: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
118604: LD_VAR 0 1
118608: PPUSH
118609: LD_INT 19
118611: PPUSH
118612: CALL 25582 0 2
// repeat wait ( 0 0$1 ) ;
118616: LD_INT 35
118618: PPUSH
118619: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118623: LD_EXP 96
118627: PUSH
118628: LD_VAR 0 1
118632: ARRAY
118633: NOT
118634: PUSH
118635: LD_EXP 96
118639: PUSH
118640: LD_VAR 0 1
118644: ARRAY
118645: PUSH
118646: EMPTY
118647: EQUAL
118648: OR
118649: IFFALSE 118686
// begin for i in defenders do
118651: LD_ADDR_VAR 0 4
118655: PUSH
118656: LD_VAR 0 2
118660: PUSH
118661: FOR_IN
118662: IFFALSE 118675
// ComStop ( i ) ;
118664: LD_VAR 0 4
118668: PPUSH
118669: CALL_OW 141
118673: GO 118661
118675: POP
118676: POP
// defenders := [ ] ;
118677: LD_ADDR_VAR 0 2
118681: PUSH
118682: EMPTY
118683: ST_TO_ADDR
// exit ;
118684: GO 118912
// end ; for i in defenders do
118686: LD_ADDR_VAR 0 4
118690: PUSH
118691: LD_VAR 0 2
118695: PUSH
118696: FOR_IN
118697: IFFALSE 118786
// begin if not IsInArea ( i , mc_parking [ base ] ) then
118699: LD_VAR 0 4
118703: PPUSH
118704: LD_EXP 120
118708: PUSH
118709: LD_VAR 0 1
118713: ARRAY
118714: PPUSH
118715: CALL_OW 308
118719: NOT
118720: IFFALSE 118744
// ComMoveToArea ( i , mc_parking [ base ] ) else
118722: LD_VAR 0 4
118726: PPUSH
118727: LD_EXP 120
118731: PUSH
118732: LD_VAR 0 1
118736: ARRAY
118737: PPUSH
118738: CALL_OW 113
118742: GO 118784
// if GetControl ( i ) = control_manual then
118744: LD_VAR 0 4
118748: PPUSH
118749: CALL_OW 263
118753: PUSH
118754: LD_INT 1
118756: EQUAL
118757: IFFALSE 118784
// if IsDrivenBy ( i ) then
118759: LD_VAR 0 4
118763: PPUSH
118764: CALL_OW 311
118768: IFFALSE 118784
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
118770: LD_VAR 0 4
118774: PPUSH
118775: CALL_OW 311
118779: PPUSH
118780: CALL_OW 121
// end ;
118784: GO 118696
118786: POP
118787: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
118788: LD_VAR 0 2
118792: PPUSH
118793: LD_INT 95
118795: PUSH
118796: LD_EXP 120
118800: PUSH
118801: LD_VAR 0 1
118805: ARRAY
118806: PUSH
118807: EMPTY
118808: LIST
118809: LIST
118810: PPUSH
118811: CALL_OW 72
118815: PUSH
118816: LD_VAR 0 2
118820: EQUAL
118821: PUSH
118822: LD_EXP 119
118826: PUSH
118827: LD_VAR 0 1
118831: ARRAY
118832: OR
118833: PUSH
118834: LD_EXP 96
118838: PUSH
118839: LD_VAR 0 1
118843: ARRAY
118844: NOT
118845: OR
118846: IFFALSE 118616
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
118848: LD_ADDR_EXP 118
118852: PUSH
118853: LD_EXP 118
118857: PPUSH
118858: LD_VAR 0 1
118862: PPUSH
118863: LD_VAR 0 2
118867: PPUSH
118868: LD_INT 21
118870: PUSH
118871: LD_INT 2
118873: PUSH
118874: EMPTY
118875: LIST
118876: LIST
118877: PPUSH
118878: CALL_OW 72
118882: PPUSH
118883: CALL_OW 1
118887: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
118888: LD_VAR 0 1
118892: PPUSH
118893: LD_INT 19
118895: PPUSH
118896: CALL 25582 0 2
// MC_Reset ( base , 20 ) ;
118900: LD_VAR 0 1
118904: PPUSH
118905: LD_INT 20
118907: PPUSH
118908: CALL 25582 0 2
// end ; end_of_file
118912: LD_VAR 0 3
118916: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
118917: LD_VAR 0 1
118921: PUSH
118922: LD_INT 200
118924: DOUBLE
118925: GREATEREQUAL
118926: IFFALSE 118934
118928: LD_INT 299
118930: DOUBLE
118931: LESSEQUAL
118932: IFTRUE 118936
118934: GO 118968
118936: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
118937: LD_VAR 0 1
118941: PPUSH
118942: LD_VAR 0 2
118946: PPUSH
118947: LD_VAR 0 3
118951: PPUSH
118952: LD_VAR 0 4
118956: PPUSH
118957: LD_VAR 0 5
118961: PPUSH
118962: CALL 107354 0 5
118966: GO 119045
118968: LD_INT 300
118970: DOUBLE
118971: GREATEREQUAL
118972: IFFALSE 118980
118974: LD_INT 399
118976: DOUBLE
118977: LESSEQUAL
118978: IFTRUE 118982
118980: GO 119044
118982: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
118983: LD_VAR 0 1
118987: PPUSH
118988: LD_VAR 0 2
118992: PPUSH
118993: LD_VAR 0 3
118997: PPUSH
118998: LD_VAR 0 4
119002: PPUSH
119003: LD_VAR 0 5
119007: PPUSH
119008: LD_VAR 0 6
119012: PPUSH
119013: LD_VAR 0 7
119017: PPUSH
119018: LD_VAR 0 8
119022: PPUSH
119023: LD_VAR 0 9
119027: PPUSH
119028: LD_VAR 0 10
119032: PPUSH
119033: LD_VAR 0 11
119037: PPUSH
119038: CALL 104996 0 11
119042: GO 119045
119044: POP
// end ;
119045: PPOPN 11
119047: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119048: LD_VAR 0 1
119052: PPUSH
119053: LD_VAR 0 2
119057: PPUSH
119058: LD_VAR 0 3
119062: PPUSH
119063: LD_VAR 0 4
119067: PPUSH
119068: LD_VAR 0 5
119072: PPUSH
119073: CALL 107090 0 5
// end ; end_of_file
119077: PPOPN 5
119079: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119080: LD_VAR 0 1
119084: PPUSH
119085: LD_VAR 0 2
119089: PPUSH
119090: LD_VAR 0 3
119094: PPUSH
119095: LD_VAR 0 4
119099: PPUSH
119100: LD_VAR 0 5
119104: PPUSH
119105: LD_VAR 0 6
119109: PPUSH
119110: CALL 92689 0 6
// end ;
119114: PPOPN 6
119116: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119117: LD_INT 0
119119: PPUSH
// begin if not units then
119120: LD_VAR 0 1
119124: NOT
119125: IFFALSE 119129
// exit ;
119127: GO 119217
// if p1 = 1 then
119129: LD_VAR 0 2
119133: PUSH
119134: LD_INT 1
119136: EQUAL
119137: IFFALSE 119217
// begin if p2 = 1 then
119139: LD_VAR 0 3
119143: PUSH
119144: LD_INT 1
119146: EQUAL
119147: IFFALSE 119178
// begin for i in units do
119149: LD_ADDR_VAR 0 7
119153: PUSH
119154: LD_VAR 0 1
119158: PUSH
119159: FOR_IN
119160: IFFALSE 119176
// begin SetUnitAttackType ( i , 3 ) ;
119162: LD_VAR 0 7
119166: PPUSH
119167: LD_INT 3
119169: PPUSH
119170: CALL_OW 603
// end ;
119174: GO 119159
119176: POP
119177: POP
// end ; if p2 = 2 then
119178: LD_VAR 0 3
119182: PUSH
119183: LD_INT 2
119185: EQUAL
119186: IFFALSE 119217
// begin for i in units do
119188: LD_ADDR_VAR 0 7
119192: PUSH
119193: LD_VAR 0 1
119197: PUSH
119198: FOR_IN
119199: IFFALSE 119215
// begin SetUnitAttackType ( i , 1 ) ;
119201: LD_VAR 0 7
119205: PPUSH
119206: LD_INT 1
119208: PPUSH
119209: CALL_OW 603
// end ;
119213: GO 119198
119215: POP
119216: POP
// end ; end ; end ;
119217: PPOPN 7
119219: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119220: CALL 92664 0 0
// end ;
119224: PPOPN 1
119226: END
