// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 22195 0 0
// InitNature ;
  19: CALL 18861 0 0
// InitArtifact ;
  23: CALL 19478 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5102 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 6982 0 0
// PrepareRussian ;
  52: CALL 9102 0 0
// PrepareLegion ;
  56: CALL 7479 0 0
// Action ;
  60: CALL 11926 0 0
// MC_Start ( ) ;
  64: CALL 24375 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 102
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 103
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 46092 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 47171 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 47264 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 107
 353: PUSH
 354: LD_EXP 107
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 46429 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 46614 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 47171 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 47264 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 46429 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 46614 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 47044 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 46092 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 47171 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 47264 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 107
 843: PUSH
 844: LD_EXP 107
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 46429 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 46614 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 47171 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 47264 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 47582 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 47376 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 46429 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 46614 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 46995 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// uc_side := 7 ;
1443: LD_ADDR_OWVAR 20
1447: PUSH
1448: LD_INT 7
1450: ST_TO_ADDR
// tmp := [ ] ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: EMPTY
1457: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1458: LD_ADDR_EXP 19
1462: PUSH
1463: LD_STRING JMM
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: LD_STRING 14a_
1474: PPUSH
1475: CALL 52903 0 3
1479: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1480: LD_ADDR_EXP 52
1484: PUSH
1485: LD_STRING Burlak
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: LD_STRING 14a_
1496: PPUSH
1497: CALL 52903 0 3
1501: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1502: LD_ADDR_EXP 34
1506: PUSH
1507: LD_STRING Joan
1509: PPUSH
1510: LD_EXP 1
1514: NOT
1515: PPUSH
1516: LD_STRING 13a_
1518: PPUSH
1519: CALL 52903 0 3
1523: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1524: LD_ADDR_EXP 20
1528: PUSH
1529: LD_STRING Roth
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_STRING 13a_
1540: PPUSH
1541: CALL 52903 0 3
1545: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1546: LD_ADDR_EXP 38
1550: PUSH
1551: LD_STRING Gossudarov
1553: PPUSH
1554: LD_EXP 1
1558: NOT
1559: PPUSH
1560: LD_STRING 13a_
1562: PPUSH
1563: CALL 52903 0 3
1567: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1568: LD_ADDR_EXP 25
1572: PUSH
1573: LD_STRING Denis
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 13a_
1584: PPUSH
1585: CALL 52903 0 3
1589: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING DeltaDoctor
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 13a_
1606: PPUSH
1607: CALL 52903 0 3
1611: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1612: LD_ADDR_EXP 37
1616: PUSH
1617: LD_STRING Mike
1619: PPUSH
1620: LD_EXP 1
1624: NOT
1625: PPUSH
1626: LD_STRING 13a_
1628: PPUSH
1629: CALL 52903 0 3
1633: ST_TO_ADDR
// if DeltaDoctor then
1634: LD_EXP 35
1638: IFFALSE 1656
// tmp := tmp ^ DeltaDoctor ;
1640: LD_ADDR_VAR 0 5
1644: PUSH
1645: LD_VAR 0 5
1649: PUSH
1650: LD_EXP 35
1654: ADD
1655: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1656: LD_ADDR_EXP 33
1660: PUSH
1661: LD_STRING Simms
1663: PPUSH
1664: LD_EXP 1
1668: NOT
1669: PPUSH
1670: LD_STRING 13a_
1672: PPUSH
1673: CALL 52903 0 3
1677: ST_TO_ADDR
// if Simms then
1678: LD_EXP 33
1682: IFFALSE 1700
// tmp := tmp ^ Simms ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_VAR 0 5
1693: PUSH
1694: LD_EXP 33
1698: ADD
1699: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1700: LD_ADDR_EXP 31
1704: PUSH
1705: LD_STRING Frank
1707: PPUSH
1708: LD_EXP 1
1712: NOT
1713: PPUSH
1714: LD_STRING 13a_
1716: PPUSH
1717: CALL 52903 0 3
1721: ST_TO_ADDR
// if Frank then
1722: LD_EXP 31
1726: IFFALSE 1744
// tmp := tmp ^ Frank ;
1728: LD_ADDR_VAR 0 5
1732: PUSH
1733: LD_VAR 0 5
1737: PUSH
1738: LD_EXP 31
1742: ADD
1743: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1744: LD_ADDR_EXP 39
1748: PUSH
1749: LD_STRING Kirilenkova
1751: PPUSH
1752: LD_EXP 1
1756: NOT
1757: PPUSH
1758: LD_STRING 13a_
1760: PPUSH
1761: CALL 52903 0 3
1765: ST_TO_ADDR
// if Kirilenkova then
1766: LD_EXP 39
1770: IFFALSE 1788
// tmp := tmp ^ Kirilenkova ;
1772: LD_ADDR_VAR 0 5
1776: PUSH
1777: LD_VAR 0 5
1781: PUSH
1782: LD_EXP 39
1786: ADD
1787: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1788: LD_ADDR_EXP 40
1792: PUSH
1793: LD_STRING Titov
1795: PPUSH
1796: LD_EXP 1
1800: NOT
1801: PPUSH
1802: LD_STRING 13a_
1804: PPUSH
1805: CALL 52903 0 3
1809: ST_TO_ADDR
// if Titov then
1810: LD_EXP 40
1814: IFFALSE 1832
// tmp := tmp ^ Titov ;
1816: LD_ADDR_VAR 0 5
1820: PUSH
1821: LD_VAR 0 5
1825: PUSH
1826: LD_EXP 40
1830: ADD
1831: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1832: LD_ADDR_EXP 41
1836: PUSH
1837: LD_STRING Fadeev
1839: PPUSH
1840: LD_EXP 1
1844: NOT
1845: PPUSH
1846: LD_STRING 13a_
1848: PPUSH
1849: CALL 52903 0 3
1853: ST_TO_ADDR
// if Fadeev then
1854: LD_EXP 41
1858: IFFALSE 1876
// tmp := tmp ^ Fadeev ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_EXP 41
1874: ADD
1875: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1876: LD_ADDR_EXP 42
1880: PUSH
1881: LD_STRING Dolgov
1883: PPUSH
1884: LD_EXP 1
1888: NOT
1889: PPUSH
1890: LD_STRING 13a_
1892: PPUSH
1893: CALL 52903 0 3
1897: ST_TO_ADDR
// if Dolgov then
1898: LD_EXP 42
1902: IFFALSE 1920
// tmp := tmp ^ Dolgov ;
1904: LD_ADDR_VAR 0 5
1908: PUSH
1909: LD_VAR 0 5
1913: PUSH
1914: LD_EXP 42
1918: ADD
1919: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1920: LD_ADDR_EXP 43
1924: PUSH
1925: LD_STRING Petrosyan
1927: PPUSH
1928: LD_EXP 1
1932: NOT
1933: PPUSH
1934: LD_STRING 13a_
1936: PPUSH
1937: CALL 52903 0 3
1941: ST_TO_ADDR
// if Petrosyan then
1942: LD_EXP 43
1946: IFFALSE 1964
// tmp := tmp ^ Petrosyan ;
1948: LD_ADDR_VAR 0 5
1952: PUSH
1953: LD_VAR 0 5
1957: PUSH
1958: LD_EXP 43
1962: ADD
1963: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1964: LD_ADDR_EXP 44
1968: PUSH
1969: LD_STRING Scholtze
1971: PPUSH
1972: LD_EXP 1
1976: NOT
1977: PPUSH
1978: LD_STRING 13a_
1980: PPUSH
1981: CALL 52903 0 3
1985: ST_TO_ADDR
// if Scholtze then
1986: LD_EXP 44
1990: IFFALSE 2008
// tmp := tmp ^ Scholtze ;
1992: LD_ADDR_VAR 0 5
1996: PUSH
1997: LD_VAR 0 5
2001: PUSH
2002: LD_EXP 44
2006: ADD
2007: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2008: LD_ADDR_EXP 45
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: LD_EXP 1
2020: NOT
2021: PPUSH
2022: LD_STRING 13a_
2024: PPUSH
2025: CALL 52903 0 3
2029: ST_TO_ADDR
// if Oblukov then
2030: LD_EXP 45
2034: IFFALSE 2052
// tmp := tmp ^ Oblukov ;
2036: LD_ADDR_VAR 0 5
2040: PUSH
2041: LD_VAR 0 5
2045: PUSH
2046: LD_EXP 45
2050: ADD
2051: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2052: LD_ADDR_EXP 46
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: LD_EXP 1
2064: NOT
2065: PPUSH
2066: LD_STRING 13a_
2068: PPUSH
2069: CALL 52903 0 3
2073: ST_TO_ADDR
// if Kapitsova then
2074: LD_EXP 46
2078: IFFALSE 2096
// tmp := tmp ^ Kapitsova ;
2080: LD_ADDR_VAR 0 5
2084: PUSH
2085: LD_VAR 0 5
2089: PUSH
2090: LD_EXP 46
2094: ADD
2095: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2096: LD_ADDR_EXP 47
2100: PUSH
2101: LD_STRING Lipshchin
2103: PPUSH
2104: LD_EXP 1
2108: NOT
2109: PPUSH
2110: LD_STRING 13a_
2112: PPUSH
2113: CALL 52903 0 3
2117: ST_TO_ADDR
// if Lipshchin then
2118: LD_EXP 47
2122: IFFALSE 2140
// tmp := tmp ^ Lipshchin ;
2124: LD_ADDR_VAR 0 5
2128: PUSH
2129: LD_VAR 0 5
2133: PUSH
2134: LD_EXP 47
2138: ADD
2139: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2140: LD_ADDR_EXP 48
2144: PUSH
2145: LD_STRING Petrovova
2147: PPUSH
2148: LD_EXP 1
2152: NOT
2153: PPUSH
2154: LD_STRING 13a_
2156: PPUSH
2157: CALL 52903 0 3
2161: ST_TO_ADDR
// if Petrovova then
2162: LD_EXP 48
2166: IFFALSE 2184
// tmp := tmp ^ Petrovova ;
2168: LD_ADDR_VAR 0 5
2172: PUSH
2173: LD_VAR 0 5
2177: PUSH
2178: LD_EXP 48
2182: ADD
2183: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2184: LD_ADDR_EXP 49
2188: PUSH
2189: LD_STRING Kovalyuk
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13a_
2200: PPUSH
2201: CALL 52903 0 3
2205: ST_TO_ADDR
// if Kovalyuk then
2206: LD_EXP 49
2210: IFFALSE 2228
// tmp := tmp ^ Kovalyuk ;
2212: LD_ADDR_VAR 0 5
2216: PUSH
2217: LD_VAR 0 5
2221: PUSH
2222: LD_EXP 49
2226: ADD
2227: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2228: LD_ADDR_EXP 50
2232: PUSH
2233: LD_STRING Kuzmov
2235: PPUSH
2236: LD_EXP 1
2240: NOT
2241: PPUSH
2242: LD_STRING 13a_
2244: PPUSH
2245: CALL 52903 0 3
2249: ST_TO_ADDR
// if Kuzmov then
2250: LD_EXP 50
2254: IFFALSE 2272
// tmp := tmp ^ Kuzmov ;
2256: LD_ADDR_VAR 0 5
2260: PUSH
2261: LD_VAR 0 5
2265: PUSH
2266: LD_EXP 50
2270: ADD
2271: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2272: LD_ADDR_EXP 51
2276: PUSH
2277: LD_STRING Karamazov
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: LD_STRING 13a_
2288: PPUSH
2289: CALL 52903 0 3
2293: ST_TO_ADDR
// if Karamazov then
2294: LD_EXP 51
2298: IFFALSE 2316
// tmp := tmp ^ Karamazov ;
2300: LD_ADDR_VAR 0 5
2304: PUSH
2305: LD_VAR 0 5
2309: PUSH
2310: LD_EXP 51
2314: ADD
2315: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2316: LD_ADDR_EXP 53
2320: PUSH
2321: LD_STRING Belkov
2323: PPUSH
2324: LD_EXP 1
2328: NOT
2329: PPUSH
2330: LD_STRING 13a_
2332: PPUSH
2333: CALL 52903 0 3
2337: ST_TO_ADDR
// if Belkov then
2338: LD_EXP 53
2342: IFFALSE 2360
// tmp := tmp ^ Belkov ;
2344: LD_ADDR_VAR 0 5
2348: PUSH
2349: LD_VAR 0 5
2353: PUSH
2354: LD_EXP 53
2358: ADD
2359: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 54
2364: PUSH
2365: LD_STRING Gnyevko
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 52903 0 3
2381: ST_TO_ADDR
// if Gnyevko then
2382: LD_EXP 54
2386: IFFALSE 2404
// tmp := tmp ^ Gnyevko ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 54
2402: ADD
2403: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2404: LD_ADDR_EXP 36
2408: PUSH
2409: LD_STRING Coonie
2411: PPUSH
2412: CALL_OW 25
2416: ST_TO_ADDR
// if not Lisa then
2417: LD_EXP 21
2421: NOT
2422: IFFALSE 2468
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2424: LD_ADDR_EXP 21
2428: PUSH
2429: LD_STRING Lisa
2431: PPUSH
2432: LD_EXP 1
2436: NOT
2437: PPUSH
2438: LD_STRING 13a_
2440: PPUSH
2441: CALL 52903 0 3
2445: ST_TO_ADDR
// if Lisa then
2446: LD_EXP 21
2450: IFFALSE 2468
// tmp := tmp ^ Lisa ;
2452: LD_ADDR_VAR 0 5
2456: PUSH
2457: LD_VAR 0 5
2461: PUSH
2462: LD_EXP 21
2466: ADD
2467: ST_TO_ADDR
// end ; if not Donaldson then
2468: LD_EXP 22
2472: NOT
2473: IFFALSE 2519
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2475: LD_ADDR_EXP 22
2479: PUSH
2480: LD_STRING Donaldson
2482: PPUSH
2483: LD_EXP 1
2487: NOT
2488: PPUSH
2489: LD_STRING 13a_
2491: PPUSH
2492: CALL 52903 0 3
2496: ST_TO_ADDR
// if Donaldson then
2497: LD_EXP 22
2501: IFFALSE 2519
// tmp := tmp ^ Donaldson ;
2503: LD_ADDR_VAR 0 5
2507: PUSH
2508: LD_VAR 0 5
2512: PUSH
2513: LD_EXP 22
2517: ADD
2518: ST_TO_ADDR
// end ; if not Bobby then
2519: LD_EXP 23
2523: NOT
2524: IFFALSE 2570
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2526: LD_ADDR_EXP 23
2530: PUSH
2531: LD_STRING Bobby
2533: PPUSH
2534: LD_EXP 1
2538: NOT
2539: PPUSH
2540: LD_STRING 13a_
2542: PPUSH
2543: CALL 52903 0 3
2547: ST_TO_ADDR
// if Bobby then
2548: LD_EXP 23
2552: IFFALSE 2570
// tmp := tmp ^ Bobby ;
2554: LD_ADDR_VAR 0 5
2558: PUSH
2559: LD_VAR 0 5
2563: PUSH
2564: LD_EXP 23
2568: ADD
2569: ST_TO_ADDR
// end ; if not Cyrus then
2570: LD_EXP 24
2574: NOT
2575: IFFALSE 2621
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2577: LD_ADDR_EXP 24
2581: PUSH
2582: LD_STRING Cyrus
2584: PPUSH
2585: LD_EXP 1
2589: NOT
2590: PPUSH
2591: LD_STRING 13a_
2593: PPUSH
2594: CALL 52903 0 3
2598: ST_TO_ADDR
// if Cyrus then
2599: LD_EXP 24
2603: IFFALSE 2621
// tmp := tmp ^ Cyrus ;
2605: LD_ADDR_VAR 0 5
2609: PUSH
2610: LD_VAR 0 5
2614: PUSH
2615: LD_EXP 24
2619: ADD
2620: ST_TO_ADDR
// end ; if not Brown then
2621: LD_EXP 26
2625: NOT
2626: IFFALSE 2672
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2628: LD_ADDR_EXP 26
2632: PUSH
2633: LD_STRING Brown
2635: PPUSH
2636: LD_EXP 1
2640: NOT
2641: PPUSH
2642: LD_STRING 13a_
2644: PPUSH
2645: CALL 52903 0 3
2649: ST_TO_ADDR
// if Brown then
2650: LD_EXP 26
2654: IFFALSE 2672
// tmp := tmp ^ Brown ;
2656: LD_ADDR_VAR 0 5
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_EXP 26
2670: ADD
2671: ST_TO_ADDR
// end ; if not Gladstone then
2672: LD_EXP 27
2676: NOT
2677: IFFALSE 2723
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2679: LD_ADDR_EXP 27
2683: PUSH
2684: LD_STRING Gladstone
2686: PPUSH
2687: LD_EXP 1
2691: NOT
2692: PPUSH
2693: LD_STRING 13a_
2695: PPUSH
2696: CALL 52903 0 3
2700: ST_TO_ADDR
// if Gladstone then
2701: LD_EXP 27
2705: IFFALSE 2723
// tmp := tmp ^ Gladstone ;
2707: LD_ADDR_VAR 0 5
2711: PUSH
2712: LD_VAR 0 5
2716: PUSH
2717: LD_EXP 27
2721: ADD
2722: ST_TO_ADDR
// end ; if not Cornel then
2723: LD_EXP 29
2727: NOT
2728: IFFALSE 2774
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2730: LD_ADDR_EXP 29
2734: PUSH
2735: LD_STRING Cornel
2737: PPUSH
2738: LD_EXP 1
2742: NOT
2743: PPUSH
2744: LD_STRING 13a_
2746: PPUSH
2747: CALL 52903 0 3
2751: ST_TO_ADDR
// if Cornel then
2752: LD_EXP 29
2756: IFFALSE 2774
// tmp := tmp ^ Cornel ;
2758: LD_ADDR_VAR 0 5
2762: PUSH
2763: LD_VAR 0 5
2767: PUSH
2768: LD_EXP 29
2772: ADD
2773: ST_TO_ADDR
// end ; if not Houten then
2774: LD_EXP 28
2778: NOT
2779: IFFALSE 2825
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2781: LD_ADDR_EXP 28
2785: PUSH
2786: LD_STRING Houten
2788: PPUSH
2789: LD_EXP 1
2793: NOT
2794: PPUSH
2795: LD_STRING 13a_
2797: PPUSH
2798: CALL 52903 0 3
2802: ST_TO_ADDR
// if Houten then
2803: LD_EXP 28
2807: IFFALSE 2825
// tmp := tmp ^ Houten ;
2809: LD_ADDR_VAR 0 5
2813: PUSH
2814: LD_VAR 0 5
2818: PUSH
2819: LD_EXP 28
2823: ADD
2824: ST_TO_ADDR
// end ; if not Gary then
2825: LD_EXP 30
2829: NOT
2830: IFFALSE 2876
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2832: LD_ADDR_EXP 30
2836: PUSH
2837: LD_STRING Gary
2839: PPUSH
2840: LD_EXP 1
2844: NOT
2845: PPUSH
2846: LD_STRING 13a_
2848: PPUSH
2849: CALL 52903 0 3
2853: ST_TO_ADDR
// if Gary then
2854: LD_EXP 30
2858: IFFALSE 2876
// tmp := tmp ^ Gary ;
2860: LD_ADDR_VAR 0 5
2864: PUSH
2865: LD_VAR 0 5
2869: PUSH
2870: LD_EXP 30
2874: ADD
2875: ST_TO_ADDR
// end ; if not Kikuchi then
2876: LD_EXP 32
2880: NOT
2881: IFFALSE 2927
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2883: LD_ADDR_EXP 32
2887: PUSH
2888: LD_STRING Kikuchi
2890: PPUSH
2891: LD_EXP 1
2895: NOT
2896: PPUSH
2897: LD_STRING 13a_
2899: PPUSH
2900: CALL 52903 0 3
2904: ST_TO_ADDR
// if Kikuchi then
2905: LD_EXP 32
2909: IFFALSE 2927
// tmp := tmp ^ Kikuchi ;
2911: LD_ADDR_VAR 0 5
2915: PUSH
2916: LD_VAR 0 5
2920: PUSH
2921: LD_EXP 32
2925: ADD
2926: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2927: LD_ADDR_VAR 0 5
2931: PUSH
2932: LD_VAR 0 5
2936: PUSH
2937: LD_STRING 13a_others
2939: PPUSH
2940: CALL_OW 31
2944: UNION
2945: ST_TO_ADDR
// tmp := tmp diff 0 ;
2946: LD_ADDR_VAR 0 5
2950: PUSH
2951: LD_VAR 0 5
2955: PUSH
2956: LD_INT 0
2958: DIFF
2959: ST_TO_ADDR
// if tmp < 15 then
2960: LD_VAR 0 5
2964: PUSH
2965: LD_INT 15
2967: LESS
2968: IFFALSE 3056
// for i = 15 downto tmp do
2970: LD_ADDR_VAR 0 2
2974: PUSH
2975: DOUBLE
2976: LD_INT 15
2978: INC
2979: ST_TO_ADDR
2980: LD_VAR 0 5
2984: PUSH
2985: FOR_DOWNTO
2986: IFFALSE 3054
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2988: LD_ADDR_OWVAR 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: PUSH
3003: LD_INT 1
3005: PPUSH
3006: LD_INT 2
3008: PPUSH
3009: CALL_OW 12
3013: ARRAY
3014: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3015: LD_INT 0
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: LD_INT 4
3023: PPUSH
3024: CALL_OW 12
3028: PPUSH
3029: LD_INT 8
3031: PPUSH
3032: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3036: LD_ADDR_VAR 0 5
3040: PUSH
3041: LD_VAR 0 5
3045: PUSH
3046: CALL_OW 44
3050: ADD
3051: ST_TO_ADDR
// end ;
3052: GO 2985
3054: POP
3055: POP
// if not debug then
3056: LD_EXP 1
3060: NOT
3061: IFFALSE 3241
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3063: LD_ADDR_VAR 0 4
3067: PUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_INT 14
3073: PUSH
3074: LD_INT 13
3076: PUSH
3077: LD_INT 12
3079: PUSH
3080: LD_INT 11
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: LD_OWVAR 67
3093: ARRAY
3094: PPUSH
3095: LD_INT 14
3097: PUSH
3098: LD_INT 13
3100: PUSH
3101: LD_INT 12
3103: PUSH
3104: LD_INT 11
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: LD_INT -5
3121: PUSH
3122: LD_EXP 19
3126: PUSH
3127: LD_EXP 52
3131: PUSH
3132: LD_EXP 20
3136: PUSH
3137: LD_EXP 34
3141: PUSH
3142: LD_EXP 25
3146: PUSH
3147: LD_EXP 38
3151: PUSH
3152: LD_INT -2
3154: PUSH
3155: LD_INT -3
3157: PUSH
3158: LD_INT -5
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: PUSH
3173: LD_VAR 0 5
3177: ADD
3178: PPUSH
3179: LD_INT 1
3181: PUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 1
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 3
3197: PUSH
3198: LD_INT 5
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 9
3214: PUSH
3215: LD_INT 0
3217: PUSH
3218: LD_INT 3
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: PPUSH
3234: CALL_OW 42
3238: ST_TO_ADDR
3239: GO 3290
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3241: LD_ADDR_VAR 0 4
3245: PUSH
3246: LD_EXP 40
3250: PUSH
3251: LD_EXP 41
3255: PUSH
3256: LD_EXP 42
3260: PUSH
3261: LD_EXP 43
3265: PUSH
3266: LD_EXP 44
3270: PUSH
3271: LD_EXP 45
3275: PUSH
3276: LD_EXP 46
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3290: LD_ADDR_EXP 17
3294: PUSH
3295: LD_VAR 0 5
3299: PUSH
3300: LD_VAR 0 4
3304: DIFF
3305: ST_TO_ADDR
// uc_nation := 1 ;
3306: LD_ADDR_OWVAR 21
3310: PUSH
3311: LD_INT 1
3313: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3314: LD_INT 5
3316: PPUSH
3317: LD_INT 3
3319: PPUSH
3320: LD_INT 1
3322: PPUSH
3323: LD_INT 6
3325: PPUSH
3326: LD_INT 100
3328: PPUSH
3329: CALL 57743 0 5
// veh := CreateVehicle ;
3333: LD_ADDR_VAR 0 3
3337: PUSH
3338: CALL_OW 45
3342: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3343: LD_VAR 0 3
3347: PPUSH
3348: LD_INT 7
3350: NEG
3351: PPUSH
3352: CALL_OW 242
// SetDir ( veh , 3 ) ;
3356: LD_VAR 0 3
3360: PPUSH
3361: LD_INT 3
3363: PPUSH
3364: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3368: LD_VAR 0 3
3372: PPUSH
3373: LD_INT 31
3375: PPUSH
3376: LD_INT 0
3378: PPUSH
3379: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3383: LD_EXP 19
3387: PPUSH
3388: LD_VAR 0 3
3392: PPUSH
3393: CALL_OW 52
// if Joan then
3397: LD_EXP 34
3401: IFFALSE 3473
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3403: LD_INT 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: LD_INT 1
3411: PPUSH
3412: LD_INT 11
3414: PPUSH
3415: LD_INT 100
3417: PPUSH
3418: CALL 57743 0 5
// veh := CreateVehicle ;
3422: LD_ADDR_VAR 0 3
3426: PUSH
3427: CALL_OW 45
3431: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3432: LD_VAR 0 3
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3444: LD_VAR 0 3
3448: PPUSH
3449: LD_INT 30
3451: PPUSH
3452: LD_INT 0
3454: PPUSH
3455: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3459: LD_EXP 34
3463: PPUSH
3464: LD_VAR 0 3
3468: PPUSH
3469: CALL_OW 52
// end ; if Roth then
3473: LD_EXP 20
3477: IFFALSE 3549
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3479: LD_INT 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: LD_INT 11
3490: PPUSH
3491: LD_INT 100
3493: PPUSH
3494: CALL 57743 0 5
// veh := CreateVehicle ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: CALL_OW 45
3507: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3508: LD_VAR 0 3
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3520: LD_VAR 0 3
3524: PPUSH
3525: LD_INT 30
3527: PPUSH
3528: LD_INT 0
3530: PPUSH
3531: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3535: LD_EXP 20
3539: PPUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: CALL_OW 52
// end ; if Denis then
3549: LD_EXP 25
3553: IFFALSE 3625
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3555: LD_INT 5
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: LD_INT 1
3563: PPUSH
3564: LD_INT 9
3566: PPUSH
3567: LD_INT 100
3569: PPUSH
3570: CALL 57743 0 5
// veh := CreateVehicle ;
3574: LD_ADDR_VAR 0 3
3578: PUSH
3579: CALL_OW 45
3583: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3584: LD_VAR 0 3
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3596: LD_VAR 0 3
3600: PPUSH
3601: LD_INT 30
3603: PPUSH
3604: LD_INT 0
3606: PPUSH
3607: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3611: LD_EXP 25
3615: PPUSH
3616: LD_VAR 0 3
3620: PPUSH
3621: CALL_OW 52
// end ; uc_nation := 3 ;
3625: LD_ADDR_OWVAR 21
3629: PUSH
3630: LD_INT 3
3632: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3633: LD_INT 22
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: LD_INT 1
3641: PPUSH
3642: LD_INT 45
3644: PPUSH
3645: LD_INT 100
3647: PPUSH
3648: CALL 57743 0 5
// veh := CreateVehicle ;
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: CALL_OW 45
3661: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3662: LD_VAR 0 3
3666: PPUSH
3667: LD_INT 7
3669: NEG
3670: PPUSH
3671: CALL_OW 242
// SetDir ( veh , 3 ) ;
3675: LD_VAR 0 3
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3687: LD_VAR 0 3
3691: PPUSH
3692: LD_INT 31
3694: PPUSH
3695: LD_INT 0
3697: PPUSH
3698: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3702: LD_EXP 52
3706: PPUSH
3707: LD_VAR 0 3
3711: PPUSH
3712: CALL_OW 52
// if Gossudarov then
3716: LD_EXP 38
3720: IFFALSE 3807
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3722: LD_INT 22
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: LD_INT 51
3733: PPUSH
3734: LD_INT 100
3736: PPUSH
3737: CALL 57743 0 5
// veh := CreateVehicle ;
3741: LD_ADDR_VAR 0 3
3745: PUSH
3746: CALL_OW 45
3750: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3751: LD_VAR 0 3
3755: PPUSH
3756: LD_INT 3
3758: PPUSH
3759: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3763: LD_VAR 0 3
3767: PPUSH
3768: LD_INT 30
3770: PPUSH
3771: LD_INT 0
3773: PPUSH
3774: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3778: LD_EXP 38
3782: PPUSH
3783: LD_VAR 0 3
3787: PPUSH
3788: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3792: LD_VAR 0 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL_OW 290
// end ; if Mike then
3807: LD_EXP 37
3811: IFFALSE 3828
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3813: LD_EXP 37
3817: PPUSH
3818: LD_INT 30
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 49
// for i in selected do
3828: LD_ADDR_VAR 0 2
3832: PUSH
3833: LD_VAR 0 4
3837: PUSH
3838: FOR_IN
3839: IFFALSE 4397
// begin uc_nation := GetNation ( i ) ;
3841: LD_ADDR_OWVAR 21
3845: PUSH
3846: LD_VAR 0 2
3850: PPUSH
3851: CALL_OW 248
3855: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3856: LD_VAR 0 2
3860: PUSH
3861: LD_EXP 21
3865: PUSH
3866: LD_EXP 22
3870: PUSH
3871: LD_EXP 24
3875: PUSH
3876: LD_EXP 23
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: IN
3887: IFFALSE 3910
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3889: LD_INT 5
3891: PPUSH
3892: LD_INT 3
3894: PPUSH
3895: LD_INT 1
3897: PPUSH
3898: LD_INT 6
3900: PPUSH
3901: LD_INT 100
3903: PPUSH
3904: CALL 57743 0 5
3908: GO 4344
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3910: LD_VAR 0 2
3914: PUSH
3915: LD_EXP 45
3919: PUSH
3920: LD_EXP 50
3924: PUSH
3925: LD_EXP 48
3929: PUSH
3930: LD_EXP 40
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: IN
3941: IFFALSE 3972
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3943: LD_INT 24
3945: PPUSH
3946: LD_INT 1
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: LD_INT 46
3954: PPUSH
3955: LD_INT 65
3957: PPUSH
3958: LD_INT 75
3960: PPUSH
3961: CALL_OW 12
3965: PPUSH
3966: CALL 57743 0 5
3970: GO 4344
// if i = Karamazov then
3972: LD_VAR 0 2
3976: PUSH
3977: LD_EXP 51
3981: EQUAL
3982: IFFALSE 4005
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3984: LD_INT 22
3986: PPUSH
3987: LD_INT 3
3989: PPUSH
3990: LD_INT 1
3992: PPUSH
3993: LD_INT 52
3995: PPUSH
3996: LD_INT 100
3998: PPUSH
3999: CALL 57743 0 5
4003: GO 4344
// if i = Brown then
4005: LD_VAR 0 2
4009: PUSH
4010: LD_EXP 26
4014: EQUAL
4015: IFFALSE 4038
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4017: LD_INT 3
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 1
4025: PPUSH
4026: LD_INT 13
4028: PPUSH
4029: LD_INT 100
4031: PPUSH
4032: CALL 57743 0 5
4036: GO 4344
// if uc_nation = nation_american then
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 1
4045: EQUAL
4046: IFFALSE 4197
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4048: LD_INT 3
4050: PUSH
4051: LD_INT 5
4053: PUSH
4054: LD_INT 5
4056: PUSH
4057: EMPTY
4058: LIST
4059: LIST
4060: LIST
4061: PUSH
4062: LD_OWVAR 21
4066: PUSH
4067: LD_INT 3
4069: MOD
4070: PUSH
4071: LD_INT 1
4073: PLUS
4074: ARRAY
4075: PPUSH
4076: LD_INT 1
4078: PUSH
4079: LD_INT 3
4081: PUSH
4082: LD_INT 1
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PUSH
4090: LD_OWVAR 21
4094: PUSH
4095: LD_INT 3
4097: MOD
4098: PUSH
4099: LD_INT 1
4101: PLUS
4102: ARRAY
4103: PPUSH
4104: LD_INT 1
4106: PPUSH
4107: LD_INT 11
4109: PUSH
4110: LD_INT 4
4112: PUSH
4113: LD_INT 5
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: LD_INT 6
4123: PUSH
4124: LD_INT 7
4126: PUSH
4127: LD_INT 9
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: PUSH
4135: LD_INT 6
4137: PUSH
4138: LD_INT 9
4140: PUSH
4141: LD_INT 12
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: LIST
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: LD_OWVAR 21
4158: PUSH
4159: LD_INT 3
4161: MOD
4162: PUSH
4163: LD_INT 1
4165: PLUS
4166: ARRAY
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 3
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 65
4182: PPUSH
4183: LD_INT 75
4185: PPUSH
4186: CALL_OW 12
4190: PPUSH
4191: CALL 57743 0 5
// end else
4195: GO 4344
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4197: LD_INT 22
4199: PUSH
4200: LD_INT 23
4202: PUSH
4203: LD_INT 23
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: PUSH
4211: LD_OWVAR 21
4215: PUSH
4216: LD_INT 3
4218: MOD
4219: PUSH
4220: LD_INT 1
4222: PLUS
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PUSH
4228: LD_INT 3
4230: PUSH
4231: LD_INT 1
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: LIST
4238: PUSH
4239: LD_OWVAR 21
4243: PUSH
4244: LD_INT 3
4246: MOD
4247: PUSH
4248: LD_INT 1
4250: PLUS
4251: ARRAY
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 43
4261: PUSH
4262: LD_INT 44
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 46
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 44
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 46
4286: PUSH
4287: LD_INT 43
4289: PUSH
4290: LD_INT 45
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: LIST
4302: PUSH
4303: LD_OWVAR 21
4307: PUSH
4308: LD_INT 3
4310: MOD
4311: PUSH
4312: LD_INT 1
4314: PLUS
4315: ARRAY
4316: PUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 3
4322: PPUSH
4323: CALL_OW 12
4327: ARRAY
4328: PPUSH
4329: LD_INT 65
4331: PPUSH
4332: LD_INT 75
4334: PPUSH
4335: CALL_OW 12
4339: PPUSH
4340: CALL 57743 0 5
// end ; veh := CreateVehicle ;
4344: LD_ADDR_VAR 0 3
4348: PUSH
4349: CALL_OW 45
4353: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4354: LD_VAR 0 3
4358: PPUSH
4359: LD_INT 3
4361: PPUSH
4362: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4366: LD_VAR 0 3
4370: PPUSH
4371: LD_INT 30
4373: PPUSH
4374: LD_INT 0
4376: PPUSH
4377: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 3
4390: PPUSH
4391: CALL_OW 52
// end ;
4395: GO 3838
4397: POP
4398: POP
// if artifactArCaptured then
4399: LD_EXP 9
4403: IFFALSE 4489
// begin uc_nation := nation_american ;
4405: LD_ADDR_OWVAR 21
4409: PUSH
4410: LD_INT 1
4412: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4413: LD_INT 3
4415: PPUSH
4416: LD_INT 3
4418: PPUSH
4419: LD_INT 3
4421: PPUSH
4422: LD_INT 12
4424: PPUSH
4425: LD_INT 100
4427: PPUSH
4428: CALL 57743 0 5
// veh := CreateVehicle ;
4432: LD_ADDR_VAR 0 3
4436: PUSH
4437: CALL_OW 45
4441: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4442: LD_VAR 0 3
4446: PPUSH
4447: LD_INT 3
4449: PPUSH
4450: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4454: LD_VAR 0 3
4458: PPUSH
4459: LD_INT 198
4461: PPUSH
4462: LD_INT 22
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 4
4479: PPUSH
4480: LD_INT 50
4482: PPUSH
4483: CALL_OW 290
// end else
4487: GO 4508
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4489: LD_INT 4
4491: PPUSH
4492: LD_INT 5
4494: PPUSH
4495: LD_INT 267
4497: PPUSH
4498: LD_INT 226
4500: PPUSH
4501: LD_INT 0
4503: PPUSH
4504: CALL_OW 58
// end ; uc_nation := nation_american ;
4508: LD_ADDR_OWVAR 21
4512: PUSH
4513: LD_INT 1
4515: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4516: LD_INT 3
4518: PPUSH
4519: LD_INT 3
4521: PPUSH
4522: LD_INT 3
4524: PPUSH
4525: LD_INT 12
4527: PPUSH
4528: LD_INT 100
4530: PPUSH
4531: CALL 57743 0 5
// veh := CreateVehicle ;
4535: LD_ADDR_VAR 0 3
4539: PUSH
4540: CALL_OW 45
4544: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4545: LD_VAR 0 3
4549: PPUSH
4550: LD_INT 3
4552: PPUSH
4553: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4557: LD_VAR 0 3
4561: PPUSH
4562: LD_INT 218
4564: PPUSH
4565: LD_INT 23
4567: PPUSH
4568: LD_INT 0
4570: PPUSH
4571: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 4
4582: PPUSH
4583: LD_INT 30
4585: PPUSH
4586: CALL_OW 290
// uc_nation := nation_russian ;
4590: LD_ADDR_OWVAR 21
4594: PUSH
4595: LD_INT 3
4597: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4598: LD_INT 22
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: LD_INT 3
4606: PPUSH
4607: LD_INT 51
4609: PPUSH
4610: LD_INT 100
4612: PPUSH
4613: CALL 57743 0 5
// veh := CreateVehicle ;
4617: LD_ADDR_VAR 0 3
4621: PUSH
4622: CALL_OW 45
4626: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4627: LD_VAR 0 3
4631: PPUSH
4632: LD_INT 3
4634: PPUSH
4635: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4639: LD_VAR 0 3
4643: PPUSH
4644: LD_INT 214
4646: PPUSH
4647: LD_INT 20
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4657: LD_VAR 0 3
4661: PPUSH
4662: LD_INT 4
4664: PPUSH
4665: LD_INT 40
4667: PPUSH
4668: CALL_OW 290
// end ;
4672: LD_VAR 0 1
4676: RET
// export function AllianceSupport ; var i , veh ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if not allianceTeam then
4682: LD_EXP 17
4686: NOT
4687: IFFALSE 4691
// exit ;
4689: GO 5097
// for i := 1 to 6 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 6
4703: PUSH
4704: FOR_TO
4705: IFFALSE 5001
// begin uc_side := 7 ;
4707: LD_ADDR_OWVAR 20
4711: PUSH
4712: LD_INT 7
4714: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4715: LD_ADDR_OWVAR 21
4719: PUSH
4720: LD_INT 1
4722: PUSH
4723: LD_INT 3
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_VAR 0 2
4734: PUSH
4735: LD_INT 2
4737: MOD
4738: PUSH
4739: LD_INT 1
4741: PLUS
4742: ARRAY
4743: ST_TO_ADDR
// if uc_nation = 1 then
4744: LD_OWVAR 21
4748: PUSH
4749: LD_INT 1
4751: EQUAL
4752: IFFALSE 4794
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4754: LD_INT 5
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 1
4762: PPUSH
4763: LD_INT 6
4765: PUSH
4766: LD_INT 7
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 2
4778: PPUSH
4779: CALL_OW 12
4783: ARRAY
4784: PPUSH
4785: LD_INT 100
4787: PPUSH
4788: CALL 57743 0 5
4792: GO 4832
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4794: LD_INT 23
4796: PPUSH
4797: LD_INT 3
4799: PPUSH
4800: LD_INT 1
4802: PPUSH
4803: LD_INT 46
4805: PUSH
4806: LD_INT 47
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: PUSH
4813: LD_INT 1
4815: PPUSH
4816: LD_INT 2
4818: PPUSH
4819: CALL_OW 12
4823: ARRAY
4824: PPUSH
4825: LD_INT 100
4827: PPUSH
4828: CALL 57743 0 5
// if not allianceTeam then
4832: LD_EXP 17
4836: NOT
4837: IFFALSE 4841
// break ;
4839: GO 5001
// veh := CreateVehicle ;
4841: LD_ADDR_VAR 0 3
4845: PUSH
4846: CALL_OW 45
4850: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4851: LD_VAR 0 3
4855: PPUSH
4856: LD_INT 4
4858: PPUSH
4859: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4863: LD_VAR 0 3
4867: PPUSH
4868: LD_INT 38
4870: PPUSH
4871: LD_INT 0
4873: PPUSH
4874: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4878: LD_EXP 17
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: LD_INT 3
4889: PPUSH
4890: CALL_OW 259
4894: PUSH
4895: LD_INT 4
4897: GREATER
4898: IFFALSE 4916
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4900: LD_EXP 17
4904: PUSH
4905: LD_INT 1
4907: ARRAY
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4916: LD_EXP 17
4920: PUSH
4921: LD_INT 1
4923: ARRAY
4924: PPUSH
4925: LD_INT 4
4927: PPUSH
4928: CALL_OW 259
4932: PUSH
4933: LD_INT 8
4935: GREATER
4936: IFFALSE 4954
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4938: LD_EXP 17
4942: PUSH
4943: LD_INT 1
4945: ARRAY
4946: PPUSH
4947: LD_INT 4
4949: PPUSH
4950: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4954: LD_EXP 17
4958: PUSH
4959: LD_INT 1
4961: ARRAY
4962: PPUSH
4963: LD_VAR 0 3
4967: PPUSH
4968: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4972: LD_ADDR_EXP 17
4976: PUSH
4977: LD_EXP 17
4981: PPUSH
4982: LD_INT 1
4984: PPUSH
4985: CALL_OW 3
4989: ST_TO_ADDR
// ComHold ( veh ) ;
4990: LD_VAR 0 3
4994: PPUSH
4995: CALL_OW 140
// end ;
4999: GO 4704
5001: POP
5002: POP
// uc_side := 7 ;
5003: LD_ADDR_OWVAR 20
5007: PUSH
5008: LD_INT 7
5010: ST_TO_ADDR
// uc_nation := 1 ;
5011: LD_ADDR_OWVAR 21
5015: PUSH
5016: LD_INT 1
5018: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5019: LD_INT 5
5021: PPUSH
5022: LD_INT 3
5024: PPUSH
5025: LD_INT 3
5027: PPUSH
5028: LD_INT 11
5030: PPUSH
5031: LD_INT 100
5033: PPUSH
5034: CALL 57743 0 5
// veh := CreateVehicle ;
5038: LD_ADDR_VAR 0 3
5042: PUSH
5043: CALL_OW 45
5047: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5048: LD_VAR 0 3
5052: PPUSH
5053: LD_INT 4
5055: PPUSH
5056: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 305
5067: PPUSH
5068: LD_INT 218
5070: PPUSH
5071: LD_INT 0
5073: PPUSH
5074: CALL_OW 48
// ComHold ( veh ) ;
5078: LD_VAR 0 3
5082: PPUSH
5083: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5087: LD_INT 313
5089: PPUSH
5090: LD_INT 220
5092: PPUSH
5093: CALL_OW 86
// end ; end_of_file
5097: LD_VAR 0 1
5101: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5102: LD_INT 0
5104: PPUSH
5105: PPUSH
5106: PPUSH
5107: PPUSH
5108: PPUSH
5109: PPUSH
5110: PPUSH
5111: PPUSH
5112: PPUSH
5113: PPUSH
5114: PPUSH
// InitHc ;
5115: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5119: LD_INT 387
5121: PPUSH
5122: LD_STRING sigma
5124: PPUSH
5125: CALL_OW 500
// uc_side := 1 ;
5129: LD_ADDR_OWVAR 20
5133: PUSH
5134: LD_INT 1
5136: ST_TO_ADDR
// uc_nation := 1 ;
5137: LD_ADDR_OWVAR 21
5141: PUSH
5142: LD_INT 1
5144: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5145: LD_ADDR_VAR 0 2
5149: PUSH
5150: LD_INT 22
5152: PUSH
5153: LD_INT 1
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 21
5162: PUSH
5163: LD_INT 3
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: PUSH
5179: FOR_IN
5180: IFFALSE 5196
// SetBLevel ( i , 10 ) ;
5182: LD_VAR 0 2
5186: PPUSH
5187: LD_INT 10
5189: PPUSH
5190: CALL_OW 241
5194: GO 5179
5196: POP
5197: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5198: LD_INT 387
5200: PPUSH
5201: CALL_OW 274
5205: PPUSH
5206: LD_INT 1
5208: PPUSH
5209: LD_INT 7500
5211: PPUSH
5212: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5216: LD_INT 387
5218: PPUSH
5219: CALL_OW 274
5223: PPUSH
5224: LD_INT 2
5226: PPUSH
5227: LD_INT 4000
5229: PPUSH
5230: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5234: LD_INT 387
5236: PPUSH
5237: CALL_OW 274
5241: PPUSH
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 50
5247: PPUSH
5248: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5252: LD_INT 476
5254: PPUSH
5255: CALL_OW 274
5259: PPUSH
5260: LD_INT 1
5262: PPUSH
5263: LD_INT 5500
5265: PPUSH
5266: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5270: LD_INT 476
5272: PPUSH
5273: CALL_OW 274
5277: PPUSH
5278: LD_INT 2
5280: PPUSH
5281: LD_INT 4000
5283: PPUSH
5284: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5288: LD_INT 476
5290: PPUSH
5291: CALL_OW 274
5295: PPUSH
5296: LD_INT 3
5298: PPUSH
5299: LD_INT 10
5301: PPUSH
5302: CALL_OW 277
// if LoadVariable ( 12a_PowellKilled , false ) then
5306: LD_STRING 12a_PowellKilled
5308: PPUSH
5309: LD_INT 0
5311: PPUSH
5312: CALL_OW 30
5316: IFFALSE 5343
// begin PrepareHuman ( sex_male , class_soldier , 10 ) ;
5318: LD_INT 1
5320: PPUSH
5321: LD_INT 1
5323: PPUSH
5324: LD_INT 10
5326: PPUSH
5327: CALL_OW 380
// Powell := CreateHuman ;
5331: LD_ADDR_EXP 55
5335: PUSH
5336: CALL_OW 44
5340: ST_TO_ADDR
// end else
5341: GO 5356
// Powell := NewCharacter ( Powell ) ;
5343: LD_ADDR_EXP 55
5347: PUSH
5348: LD_STRING Powell
5350: PPUSH
5351: CALL_OW 25
5355: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5356: LD_EXP 55
5360: PPUSH
5361: LD_INT 387
5363: PPUSH
5364: CALL_OW 52
// tmp := [ ] ;
5368: LD_ADDR_VAR 0 7
5372: PUSH
5373: EMPTY
5374: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5375: LD_ADDR_EXP 21
5379: PUSH
5380: LD_STRING Lisa
5382: PPUSH
5383: LD_EXP 1
5387: NOT
5388: PPUSH
5389: LD_STRING 12p_
5391: PPUSH
5392: CALL 52903 0 3
5396: ST_TO_ADDR
// if Lisa then
5397: LD_EXP 21
5401: IFFALSE 5419
// tmp := tmp ^ Lisa ;
5403: LD_ADDR_VAR 0 7
5407: PUSH
5408: LD_VAR 0 7
5412: PUSH
5413: LD_EXP 21
5417: ADD
5418: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5419: LD_ADDR_EXP 22
5423: PUSH
5424: LD_STRING Donaldson
5426: PPUSH
5427: LD_EXP 1
5431: NOT
5432: PPUSH
5433: LD_STRING 12p_
5435: PPUSH
5436: CALL 52903 0 3
5440: ST_TO_ADDR
// if Donaldson then
5441: LD_EXP 22
5445: IFFALSE 5463
// tmp := tmp ^ Donaldson ;
5447: LD_ADDR_VAR 0 7
5451: PUSH
5452: LD_VAR 0 7
5456: PUSH
5457: LD_EXP 22
5461: ADD
5462: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5463: LD_ADDR_EXP 23
5467: PUSH
5468: LD_STRING Bobby
5470: PPUSH
5471: LD_EXP 1
5475: NOT
5476: PPUSH
5477: LD_STRING 12p_
5479: PPUSH
5480: CALL 52903 0 3
5484: ST_TO_ADDR
// if Bobby then
5485: LD_EXP 23
5489: IFFALSE 5507
// tmp := tmp ^ Bobby ;
5491: LD_ADDR_VAR 0 7
5495: PUSH
5496: LD_VAR 0 7
5500: PUSH
5501: LD_EXP 23
5505: ADD
5506: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5507: LD_ADDR_EXP 24
5511: PUSH
5512: LD_STRING Cyrus
5514: PPUSH
5515: LD_EXP 1
5519: NOT
5520: PPUSH
5521: LD_STRING 12p_
5523: PPUSH
5524: CALL 52903 0 3
5528: ST_TO_ADDR
// if Cyrus then
5529: LD_EXP 24
5533: IFFALSE 5551
// tmp := tmp ^ Cyrus ;
5535: LD_ADDR_VAR 0 7
5539: PUSH
5540: LD_VAR 0 7
5544: PUSH
5545: LD_EXP 24
5549: ADD
5550: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5551: LD_ADDR_EXP 26
5555: PUSH
5556: LD_STRING Brown
5558: PPUSH
5559: LD_EXP 1
5563: NOT
5564: PPUSH
5565: LD_STRING 12p_
5567: PPUSH
5568: CALL 52903 0 3
5572: ST_TO_ADDR
// if Brown then
5573: LD_EXP 26
5577: IFFALSE 5595
// tmp := tmp ^ Brown ;
5579: LD_ADDR_VAR 0 7
5583: PUSH
5584: LD_VAR 0 7
5588: PUSH
5589: LD_EXP 26
5593: ADD
5594: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5595: LD_ADDR_EXP 27
5599: PUSH
5600: LD_STRING Gladstone
5602: PPUSH
5603: LD_EXP 1
5607: NOT
5608: PPUSH
5609: LD_STRING 12p_
5611: PPUSH
5612: CALL 52903 0 3
5616: ST_TO_ADDR
// if Gladstone then
5617: LD_EXP 27
5621: IFFALSE 5639
// tmp := tmp ^ Gladstone ;
5623: LD_ADDR_VAR 0 7
5627: PUSH
5628: LD_VAR 0 7
5632: PUSH
5633: LD_EXP 27
5637: ADD
5638: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5639: LD_ADDR_EXP 28
5643: PUSH
5644: LD_STRING Houten
5646: PPUSH
5647: LD_EXP 1
5651: NOT
5652: PPUSH
5653: LD_STRING 12p_
5655: PPUSH
5656: CALL 52903 0 3
5660: ST_TO_ADDR
// if Houten then
5661: LD_EXP 28
5665: IFFALSE 5683
// tmp := tmp ^ Houten ;
5667: LD_ADDR_VAR 0 7
5671: PUSH
5672: LD_VAR 0 7
5676: PUSH
5677: LD_EXP 28
5681: ADD
5682: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5683: LD_ADDR_EXP 29
5687: PUSH
5688: LD_STRING Cornel
5690: PPUSH
5691: LD_EXP 1
5695: NOT
5696: PPUSH
5697: LD_STRING 12p_
5699: PPUSH
5700: CALL 52903 0 3
5704: ST_TO_ADDR
// if Cornel then
5705: LD_EXP 29
5709: IFFALSE 5727
// tmp := tmp ^ Cornel ;
5711: LD_ADDR_VAR 0 7
5715: PUSH
5716: LD_VAR 0 7
5720: PUSH
5721: LD_EXP 29
5725: ADD
5726: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5727: LD_ADDR_EXP 30
5731: PUSH
5732: LD_STRING Gary
5734: PPUSH
5735: LD_EXP 1
5739: NOT
5740: PPUSH
5741: LD_STRING 12p_
5743: PPUSH
5744: CALL 52903 0 3
5748: ST_TO_ADDR
// if Gary then
5749: LD_EXP 30
5753: IFFALSE 5771
// tmp := tmp ^ Gary ;
5755: LD_ADDR_VAR 0 7
5759: PUSH
5760: LD_VAR 0 7
5764: PUSH
5765: LD_EXP 30
5769: ADD
5770: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5771: LD_ADDR_EXP 32
5775: PUSH
5776: LD_STRING Kikuchi
5778: PPUSH
5779: LD_EXP 1
5783: NOT
5784: PPUSH
5785: LD_STRING 12p_
5787: PPUSH
5788: CALL 52903 0 3
5792: ST_TO_ADDR
// if Kikuchi then
5793: LD_EXP 32
5797: IFFALSE 5815
// tmp := tmp ^ Kikuchi ;
5799: LD_ADDR_VAR 0 7
5803: PUSH
5804: LD_VAR 0 7
5808: PUSH
5809: LD_EXP 32
5813: ADD
5814: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5815: LD_ADDR_VAR 0 7
5819: PUSH
5820: LD_VAR 0 7
5824: PUSH
5825: LD_STRING 12p_others
5827: PPUSH
5828: CALL_OW 31
5832: UNION
5833: ST_TO_ADDR
// InitHc_All ( ) ;
5834: CALL_OW 584
// if tmp < 36 then
5838: LD_VAR 0 7
5842: PUSH
5843: LD_INT 36
5845: LESS
5846: IFFALSE 5913
// for i = 1 to 36 - tmp do
5848: LD_ADDR_VAR 0 2
5852: PUSH
5853: DOUBLE
5854: LD_INT 1
5856: DEC
5857: ST_TO_ADDR
5858: LD_INT 36
5860: PUSH
5861: LD_VAR 0 7
5865: MINUS
5866: PUSH
5867: FOR_TO
5868: IFFALSE 5911
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5870: LD_INT 1
5872: PPUSH
5873: LD_VAR 0 2
5877: PUSH
5878: LD_INT 4
5880: MOD
5881: PUSH
5882: LD_INT 1
5884: PLUS
5885: PPUSH
5886: LD_INT 10
5888: PPUSH
5889: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5893: LD_ADDR_VAR 0 7
5897: PUSH
5898: LD_VAR 0 7
5902: PUSH
5903: CALL_OW 44
5907: ADD
5908: ST_TO_ADDR
// end ;
5909: GO 5867
5911: POP
5912: POP
// p := 0 ;
5913: LD_ADDR_VAR 0 6
5917: PUSH
5918: LD_INT 0
5920: ST_TO_ADDR
// for i in tmp do
5921: LD_ADDR_VAR 0 2
5925: PUSH
5926: LD_VAR 0 7
5930: PUSH
5931: FOR_IN
5932: IFFALSE 5984
// begin p := Inc ( p ) ;
5934: LD_ADDR_VAR 0 6
5938: PUSH
5939: LD_VAR 0 6
5943: PPUSH
5944: CALL 91966 0 1
5948: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5949: LD_VAR 0 2
5953: PPUSH
5954: LD_INT 62
5956: PPUSH
5957: LD_INT 93
5959: PPUSH
5960: LD_INT 9
5962: PPUSH
5963: LD_INT 0
5965: PPUSH
5966: CALL_OW 50
// if p > 36 then
5970: LD_VAR 0 6
5974: PUSH
5975: LD_INT 36
5977: GREATER
5978: IFFALSE 5982
// break ;
5980: GO 5984
// end ;
5982: GO 5931
5984: POP
5985: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5986: LD_ADDR_EXP 78
5990: PUSH
5991: LD_EXP 78
5995: PPUSH
5996: LD_INT 4
5998: PPUSH
5999: LD_INT 22
6001: PUSH
6002: LD_INT 1
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: PPUSH
6009: CALL_OW 69
6013: PUSH
6014: LD_EXP 55
6018: DIFF
6019: PPUSH
6020: CALL_OW 1
6024: ST_TO_ADDR
// uc_side := 0 ;
6025: LD_ADDR_OWVAR 20
6029: PUSH
6030: LD_INT 0
6032: ST_TO_ADDR
// uc_nation := 0 ;
6033: LD_ADDR_OWVAR 21
6037: PUSH
6038: LD_INT 0
6040: ST_TO_ADDR
// for i = 1 to 4 do
6041: LD_ADDR_VAR 0 2
6045: PUSH
6046: DOUBLE
6047: LD_INT 1
6049: DEC
6050: ST_TO_ADDR
6051: LD_INT 4
6053: PUSH
6054: FOR_TO
6055: IFFALSE 6086
// begin InitHc ;
6057: CALL_OW 19
// hc_class := class_apeman ;
6061: LD_ADDR_OWVAR 28
6065: PUSH
6066: LD_INT 12
6068: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6069: CALL_OW 44
6073: PPUSH
6074: LD_INT 11
6076: PPUSH
6077: LD_INT 0
6079: PPUSH
6080: CALL_OW 49
// end ;
6084: GO 6054
6086: POP
6087: POP
// end ;
6088: LD_VAR 0 1
6092: RET
// every 9 9$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6093: LD_EXP 4
6097: NOT
6098: IFFALSE 6904
6100: GO 6102
6102: DISABLE
6103: LD_INT 0
6105: PPUSH
6106: PPUSH
6107: PPUSH
6108: PPUSH
// begin enable ;
6109: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6110: LD_INT 22
6112: PUSH
6113: LD_INT 1
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 23
6122: PUSH
6123: LD_INT 1
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: PUSH
6130: LD_INT 30
6132: PUSH
6133: LD_INT 3
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: LIST
6144: PPUSH
6145: CALL_OW 69
6149: NOT
6150: IFFALSE 6154
// exit ;
6152: GO 6904
// if Prob ( 40 ) then
6154: LD_INT 40
6156: PPUSH
6157: CALL_OW 13
6161: IFFALSE 6288
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6163: LD_INT 4
6165: PPUSH
6166: LD_INT 5
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 7
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 5
6186: PUSH
6187: LD_INT 1
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 7
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 5
6204: PUSH
6205: LD_INT 1
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 7
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: LD_INT 5
6222: PUSH
6223: LD_INT 1
6225: PUSH
6226: LD_INT 2
6228: PUSH
6229: LD_INT 6
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 5
6240: PUSH
6241: LD_INT 1
6243: PUSH
6244: LD_INT 2
6246: PUSH
6247: LD_INT 6
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PUSH
6256: LD_INT 5
6258: PUSH
6259: LD_INT 1
6261: PUSH
6262: LD_INT 2
6264: PUSH
6265: LD_INT 6
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: PUSH
6274: EMPTY
6275: LIST
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: LIST
6281: PPUSH
6282: CALL 46477 0 2
// end else
6286: GO 6411
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6288: LD_INT 4
6290: PPUSH
6291: LD_INT 5
6293: PUSH
6294: LD_INT 1
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 7
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: LIST
6307: LIST
6308: PUSH
6309: LD_INT 5
6311: PUSH
6312: LD_INT 1
6314: PUSH
6315: LD_INT 2
6317: PUSH
6318: LD_INT 9
6320: PUSH
6321: EMPTY
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: PUSH
6327: LD_INT 5
6329: PUSH
6330: LD_INT 1
6332: PUSH
6333: LD_INT 2
6335: PUSH
6336: LD_INT 9
6338: PUSH
6339: EMPTY
6340: LIST
6341: LIST
6342: LIST
6343: LIST
6344: PUSH
6345: LD_INT 5
6347: PUSH
6348: LD_INT 1
6350: PUSH
6351: LD_INT 2
6353: PUSH
6354: LD_INT 6
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PUSH
6363: LD_INT 5
6365: PUSH
6366: LD_INT 1
6368: PUSH
6369: LD_INT 2
6371: PUSH
6372: LD_INT 6
6374: PUSH
6375: EMPTY
6376: LIST
6377: LIST
6378: LIST
6379: LIST
6380: PUSH
6381: LD_INT 5
6383: PUSH
6384: LD_INT 1
6386: PUSH
6387: LD_INT 2
6389: PUSH
6390: LD_INT 6
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: LIST
6397: LIST
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: LIST
6406: PPUSH
6407: CALL 46477 0 2
// end ; p := 0 ;
6411: LD_ADDR_VAR 0 4
6415: PUSH
6416: LD_INT 0
6418: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6419: LD_INT 35
6421: PPUSH
6422: CALL_OW 67
// p := Inc ( p ) ;
6426: LD_ADDR_VAR 0 4
6430: PUSH
6431: LD_VAR 0 4
6435: PPUSH
6436: CALL 91966 0 1
6440: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6441: LD_INT 4
6443: PPUSH
6444: LD_INT 1
6446: PPUSH
6447: CALL 47895 0 2
6451: PUSH
6452: LD_INT 6
6454: GREATEREQUAL
6455: PUSH
6456: LD_VAR 0 4
6460: PUSH
6461: LD_INT 100
6463: GREATER
6464: OR
6465: IFFALSE 6419
// wait ( 0 0$30 ) ;
6467: LD_INT 1050
6469: PPUSH
6470: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6474: LD_ADDR_VAR 0 2
6478: PUSH
6479: LD_INT 4
6481: PPUSH
6482: LD_INT 1
6484: PPUSH
6485: CALL 47895 0 2
6489: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6490: LD_ADDR_EXP 97
6494: PUSH
6495: LD_EXP 97
6499: PPUSH
6500: LD_INT 4
6502: PPUSH
6503: LD_EXP 97
6507: PUSH
6508: LD_INT 4
6510: ARRAY
6511: PUSH
6512: LD_VAR 0 2
6516: DIFF
6517: PPUSH
6518: CALL_OW 1
6522: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6523: LD_ADDR_VAR 0 3
6527: PUSH
6528: LD_INT 0
6530: PPUSH
6531: LD_INT 2
6533: PPUSH
6534: CALL_OW 12
6538: ST_TO_ADDR
// if target then
6539: LD_VAR 0 3
6543: IFFALSE 6671
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6545: LD_ADDR_VAR 0 2
6549: PUSH
6550: LD_VAR 0 2
6554: PPUSH
6555: LD_INT 24
6557: PUSH
6558: LD_INT 250
6560: PUSH
6561: EMPTY
6562: LIST
6563: LIST
6564: PPUSH
6565: CALL_OW 72
6569: ST_TO_ADDR
// for i in tmp do
6570: LD_ADDR_VAR 0 1
6574: PUSH
6575: LD_VAR 0 2
6579: PUSH
6580: FOR_IN
6581: IFFALSE 6621
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6583: LD_VAR 0 1
6587: PPUSH
6588: LD_INT 114
6590: PPUSH
6591: LD_INT 108
6593: PPUSH
6594: CALL_OW 297
6598: PUSH
6599: LD_INT 9
6601: GREATER
6602: IFFALSE 6619
// ComMoveXY ( i , 114 , 108 ) ;
6604: LD_VAR 0 1
6608: PPUSH
6609: LD_INT 114
6611: PPUSH
6612: LD_INT 108
6614: PPUSH
6615: CALL_OW 111
6619: GO 6580
6621: POP
6622: POP
// wait ( 0 0$1 ) ;
6623: LD_INT 35
6625: PPUSH
6626: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6630: LD_VAR 0 2
6634: PPUSH
6635: LD_INT 92
6637: PUSH
6638: LD_INT 114
6640: PUSH
6641: LD_INT 108
6643: PUSH
6644: LD_INT 9
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: PPUSH
6653: CALL_OW 72
6657: PUSH
6658: LD_VAR 0 2
6662: PUSH
6663: LD_INT 1
6665: MINUS
6666: GREATEREQUAL
6667: IFFALSE 6545
// end else
6669: GO 6795
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6671: LD_ADDR_VAR 0 2
6675: PUSH
6676: LD_VAR 0 2
6680: PPUSH
6681: LD_INT 24
6683: PUSH
6684: LD_INT 250
6686: PUSH
6687: EMPTY
6688: LIST
6689: LIST
6690: PPUSH
6691: CALL_OW 72
6695: ST_TO_ADDR
// for i in tmp do
6696: LD_ADDR_VAR 0 1
6700: PUSH
6701: LD_VAR 0 2
6705: PUSH
6706: FOR_IN
6707: IFFALSE 6747
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6709: LD_VAR 0 1
6713: PPUSH
6714: LD_INT 129
6716: PPUSH
6717: LD_INT 139
6719: PPUSH
6720: CALL_OW 297
6724: PUSH
6725: LD_INT 9
6727: GREATER
6728: IFFALSE 6745
// ComMoveXY ( i , 129 , 139 ) ;
6730: LD_VAR 0 1
6734: PPUSH
6735: LD_INT 129
6737: PPUSH
6738: LD_INT 139
6740: PPUSH
6741: CALL_OW 111
6745: GO 6706
6747: POP
6748: POP
// wait ( 0 0$1 ) ;
6749: LD_INT 35
6751: PPUSH
6752: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6756: LD_VAR 0 2
6760: PPUSH
6761: LD_INT 92
6763: PUSH
6764: LD_INT 129
6766: PUSH
6767: LD_INT 139
6769: PUSH
6770: LD_INT 9
6772: PUSH
6773: EMPTY
6774: LIST
6775: LIST
6776: LIST
6777: LIST
6778: PPUSH
6779: CALL_OW 72
6783: PUSH
6784: LD_VAR 0 2
6788: PUSH
6789: LD_INT 1
6791: MINUS
6792: GREATEREQUAL
6793: IFFALSE 6671
// end ; repeat wait ( 0 0$1 ) ;
6795: LD_INT 35
6797: PPUSH
6798: CALL_OW 67
// for i in tmp do
6802: LD_ADDR_VAR 0 1
6806: PUSH
6807: LD_VAR 0 2
6811: PUSH
6812: FOR_IN
6813: IFFALSE 6895
// begin if GetLives ( i ) > 251 then
6815: LD_VAR 0 1
6819: PPUSH
6820: CALL_OW 256
6824: PUSH
6825: LD_INT 251
6827: GREATER
6828: IFFALSE 6866
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6830: LD_VAR 0 1
6834: PPUSH
6835: LD_INT 81
6837: PUSH
6838: LD_INT 1
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: PPUSH
6845: CALL_OW 69
6849: PPUSH
6850: LD_VAR 0 1
6854: PPUSH
6855: CALL_OW 74
6859: PPUSH
6860: CALL_OW 115
6864: GO 6893
// if IsDead ( i ) then
6866: LD_VAR 0 1
6870: PPUSH
6871: CALL_OW 301
6875: IFFALSE 6893
// tmp := tmp diff i ;
6877: LD_ADDR_VAR 0 2
6881: PUSH
6882: LD_VAR 0 2
6886: PUSH
6887: LD_VAR 0 1
6891: DIFF
6892: ST_TO_ADDR
// end ;
6893: GO 6812
6895: POP
6896: POP
// until not tmp ;
6897: LD_VAR 0 2
6901: NOT
6902: IFFALSE 6795
// end ;
6904: PPOPN 4
6906: END
// every 30 30$00 trigger not americanDestroyed do
6907: LD_EXP 4
6911: NOT
6912: IFFALSE 6981
6914: GO 6916
6916: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6917: LD_INT 63000
6919: PUSH
6920: LD_INT 42000
6922: PUSH
6923: LD_INT 31500
6925: PUSH
6926: LD_INT 21000
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: LIST
6933: LIST
6934: PUSH
6935: LD_OWVAR 67
6939: ARRAY
6940: PPUSH
6941: CALL_OW 67
// if americanDestroyed then
6945: LD_EXP 4
6949: IFFALSE 6953
// exit ;
6951: GO 6981
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6953: LD_INT 4
6955: PPUSH
6956: LD_INT 5
6958: PUSH
6959: LD_INT 3
6961: PUSH
6962: LD_INT 1
6964: PUSH
6965: LD_INT 8
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: LIST
6972: LIST
6973: PUSH
6974: EMPTY
6975: LIST
6976: PPUSH
6977: CALL 46477 0 2
// end ; end_of_file
6981: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6982: LD_INT 0
6984: PPUSH
6985: PPUSH
6986: PPUSH
6987: PPUSH
6988: PPUSH
// side := 2 ;
6989: LD_ADDR_VAR 0 5
6993: PUSH
6994: LD_INT 2
6996: ST_TO_ADDR
// InitHc ;
6997: CALL_OW 19
// uc_side := side ;
7001: LD_ADDR_OWVAR 20
7005: PUSH
7006: LD_VAR 0 5
7010: ST_TO_ADDR
// uc_nation := 2 ;
7011: LD_ADDR_OWVAR 21
7015: PUSH
7016: LD_INT 2
7018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
7019: LD_ADDR_VAR 0 2
7023: PUSH
7024: LD_INT 22
7026: PUSH
7027: LD_INT 2
7029: PUSH
7030: EMPTY
7031: LIST
7032: LIST
7033: PUSH
7034: LD_INT 21
7036: PUSH
7037: LD_INT 3
7039: PUSH
7040: EMPTY
7041: LIST
7042: LIST
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PPUSH
7048: CALL_OW 69
7052: PUSH
7053: FOR_IN
7054: IFFALSE 7070
// SetBLevel ( i , 10 ) ;
7056: LD_VAR 0 2
7060: PPUSH
7061: LD_INT 10
7063: PPUSH
7064: CALL_OW 241
7068: GO 7053
7070: POP
7071: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7072: LD_ADDR_VAR 0 4
7076: PUSH
7077: LD_INT 22
7079: PUSH
7080: LD_VAR 0 5
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: PUSH
7089: LD_INT 30
7091: PUSH
7092: LD_INT 32
7094: PUSH
7095: EMPTY
7096: LIST
7097: LIST
7098: PUSH
7099: LD_INT 58
7101: PUSH
7102: EMPTY
7103: LIST
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: PPUSH
7110: CALL_OW 69
7114: ST_TO_ADDR
// for i = 1 to 10 do
7115: LD_ADDR_VAR 0 2
7119: PUSH
7120: DOUBLE
7121: LD_INT 1
7123: DEC
7124: ST_TO_ADDR
7125: LD_INT 10
7127: PUSH
7128: FOR_TO
7129: IFFALSE 7201
// begin uc_nation := nation_nature ;
7131: LD_ADDR_OWVAR 21
7135: PUSH
7136: LD_INT 0
7138: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7139: LD_ADDR_OWVAR 28
7143: PUSH
7144: LD_INT 15
7146: ST_TO_ADDR
// hc_gallery :=  ;
7147: LD_ADDR_OWVAR 33
7151: PUSH
7152: LD_STRING 
7154: ST_TO_ADDR
// hc_name :=  ;
7155: LD_ADDR_OWVAR 26
7159: PUSH
7160: LD_STRING 
7162: ST_TO_ADDR
// un := CreateHuman ;
7163: LD_ADDR_VAR 0 3
7167: PUSH
7168: CALL_OW 44
7172: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7173: LD_VAR 0 3
7177: PPUSH
7178: LD_VAR 0 4
7182: PUSH
7183: LD_VAR 0 4
7187: PUSH
7188: LD_VAR 0 2
7192: MINUS
7193: ARRAY
7194: PPUSH
7195: CALL_OW 52
// end ;
7199: GO 7128
7201: POP
7202: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7203: LD_INT 503
7205: PPUSH
7206: LD_INT 27
7208: PPUSH
7209: LD_STRING 
7211: PPUSH
7212: LD_INT 8
7214: PUSH
7215: LD_INT 9
7217: PUSH
7218: LD_INT 10
7220: PUSH
7221: LD_INT 10
7223: PUSH
7224: EMPTY
7225: LIST
7226: LIST
7227: LIST
7228: LIST
7229: PUSH
7230: LD_OWVAR 67
7234: ARRAY
7235: PPUSH
7236: LD_INT 3000
7238: PUSH
7239: LD_INT 500
7241: PUSH
7242: LD_INT 150
7244: PUSH
7245: EMPTY
7246: LIST
7247: LIST
7248: LIST
7249: PPUSH
7250: LD_INT 16
7252: PUSH
7253: LD_INT 6
7255: PUSH
7256: LD_INT 6
7258: PUSH
7259: LD_INT 6
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: PPUSH
7268: CALL 61564 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7272: LD_ADDR_EXP 78
7276: PUSH
7277: LD_EXP 78
7281: PPUSH
7282: LD_INT 1
7284: PPUSH
7285: LD_INT 22
7287: PUSH
7288: LD_VAR 0 5
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PUSH
7297: LD_INT 23
7299: PUSH
7300: LD_INT 2
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 3
7309: PUSH
7310: LD_INT 21
7312: PUSH
7313: LD_INT 2
7315: PUSH
7316: EMPTY
7317: LIST
7318: LIST
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: LIST
7328: PPUSH
7329: CALL_OW 69
7333: PPUSH
7334: CALL_OW 1
7338: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7339: LD_INT 216
7341: PPUSH
7342: LD_INT 228
7344: PPUSH
7345: LD_INT 2
7347: PPUSH
7348: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7352: LD_INT 223
7354: PPUSH
7355: LD_INT 241
7357: PPUSH
7358: LD_INT 2
7360: PPUSH
7361: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7365: LD_INT 216
7367: PPUSH
7368: LD_INT 217
7370: PPUSH
7371: LD_INT 2
7373: PPUSH
7374: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7378: LD_INT 233
7380: PPUSH
7381: LD_INT 257
7383: PPUSH
7384: LD_INT 2
7386: PPUSH
7387: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7391: LD_INT 230
7393: PPUSH
7394: LD_INT 199
7396: PPUSH
7397: LD_INT 2
7399: PPUSH
7400: CALL_OW 244
// end ;
7404: LD_VAR 0 1
7408: RET
// export Omar ; export function PrepareOmarAli ; begin
7409: LD_INT 0
7411: PPUSH
// uc_side := 5 ;
7412: LD_ADDR_OWVAR 20
7416: PUSH
7417: LD_INT 5
7419: ST_TO_ADDR
// uc_nation := 2 ;
7420: LD_ADDR_OWVAR 21
7424: PUSH
7425: LD_INT 2
7427: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7428: LD_ADDR_EXP 56
7432: PUSH
7433: LD_STRING Omar
7435: PPUSH
7436: CALL_OW 25
7440: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7441: LD_EXP 56
7445: PPUSH
7446: LD_INT 330
7448: PPUSH
7449: LD_INT 244
7451: PPUSH
7452: LD_INT 0
7454: PPUSH
7455: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7459: LD_EXP 56
7463: PPUSH
7464: LD_INT 252
7466: PPUSH
7467: LD_INT 220
7469: PPUSH
7470: CALL_OW 111
// end ; end_of_file
7474: LD_VAR 0 1
7478: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7479: LD_INT 0
7481: PPUSH
7482: PPUSH
7483: PPUSH
7484: PPUSH
7485: PPUSH
// side := 8 ;
7486: LD_ADDR_VAR 0 3
7490: PUSH
7491: LD_INT 8
7493: ST_TO_ADDR
// InitHc ;
7494: CALL_OW 19
// uc_side := side ;
7498: LD_ADDR_OWVAR 20
7502: PUSH
7503: LD_VAR 0 3
7507: ST_TO_ADDR
// uc_nation := 2 ;
7508: LD_ADDR_OWVAR 21
7512: PUSH
7513: LD_INT 2
7515: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7516: LD_ADDR_VAR 0 2
7520: PUSH
7521: LD_INT 22
7523: PUSH
7524: LD_VAR 0 3
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: PUSH
7533: LD_INT 21
7535: PUSH
7536: LD_INT 3
7538: PUSH
7539: EMPTY
7540: LIST
7541: LIST
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PPUSH
7547: CALL_OW 69
7551: PUSH
7552: FOR_IN
7553: IFFALSE 7569
// SetBLevel ( i , 10 ) ;
7555: LD_VAR 0 2
7559: PPUSH
7560: LD_INT 10
7562: PPUSH
7563: CALL_OW 241
7567: GO 7552
7569: POP
7570: POP
// Schulz := NewCharacter ( Schulz ) ;
7571: LD_ADDR_EXP 57
7575: PUSH
7576: LD_STRING Schulz
7578: PPUSH
7579: CALL_OW 25
7583: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7584: LD_ADDR_EXP 59
7588: PUSH
7589: LD_STRING Kaia
7591: PPUSH
7592: CALL_OW 25
7596: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7597: LD_EXP 59
7601: PPUSH
7602: LD_INT 324
7604: PPUSH
7605: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7609: LD_ADDR_EXP 58
7613: PUSH
7614: LD_STRING Kozlov
7616: PPUSH
7617: LD_INT 0
7619: PPUSH
7620: LD_STRING 
7622: PPUSH
7623: CALL 52903 0 3
7627: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7628: LD_EXP 58
7632: PPUSH
7633: LD_INT 22
7635: PUSH
7636: LD_INT 8
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: PUSH
7643: LD_INT 23
7645: PUSH
7646: LD_INT 3
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 30
7655: PUSH
7656: LD_INT 8
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: LIST
7667: PPUSH
7668: CALL_OW 69
7672: PUSH
7673: LD_INT 1
7675: ARRAY
7676: PPUSH
7677: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7681: LD_EXP 58
7685: PPUSH
7686: LD_INT 3
7688: PPUSH
7689: LD_INT 10
7691: PPUSH
7692: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7696: LD_ADDR_VAR 0 5
7700: PUSH
7701: LD_INT 22
7703: PUSH
7704: LD_VAR 0 3
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: LD_INT 30
7715: PUSH
7716: LD_INT 32
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: LD_INT 58
7725: PUSH
7726: EMPTY
7727: LIST
7728: PUSH
7729: EMPTY
7730: LIST
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL_OW 69
7738: ST_TO_ADDR
// for i = 1 to 10 do
7739: LD_ADDR_VAR 0 2
7743: PUSH
7744: DOUBLE
7745: LD_INT 1
7747: DEC
7748: ST_TO_ADDR
7749: LD_INT 10
7751: PUSH
7752: FOR_TO
7753: IFFALSE 7825
// begin uc_nation := nation_nature ;
7755: LD_ADDR_OWVAR 21
7759: PUSH
7760: LD_INT 0
7762: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7763: LD_ADDR_OWVAR 28
7767: PUSH
7768: LD_INT 15
7770: ST_TO_ADDR
// hc_gallery :=  ;
7771: LD_ADDR_OWVAR 33
7775: PUSH
7776: LD_STRING 
7778: ST_TO_ADDR
// hc_name :=  ;
7779: LD_ADDR_OWVAR 26
7783: PUSH
7784: LD_STRING 
7786: ST_TO_ADDR
// un := CreateHuman ;
7787: LD_ADDR_VAR 0 4
7791: PUSH
7792: CALL_OW 44
7796: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7797: LD_VAR 0 4
7801: PPUSH
7802: LD_VAR 0 5
7806: PUSH
7807: LD_VAR 0 5
7811: PUSH
7812: LD_VAR 0 2
7816: MINUS
7817: ARRAY
7818: PPUSH
7819: CALL_OW 52
// end ;
7823: GO 7752
7825: POP
7826: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7827: LD_INT 324
7829: PPUSH
7830: LD_INT 3
7832: PPUSH
7833: LD_STRING 
7835: PPUSH
7836: LD_INT 8
7838: PUSH
7839: LD_INT 9
7841: PUSH
7842: LD_INT 10
7844: PUSH
7845: LD_INT 10
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: LIST
7852: LIST
7853: PUSH
7854: LD_OWVAR 67
7858: ARRAY
7859: PPUSH
7860: LD_INT 3000
7862: PUSH
7863: LD_INT 500
7865: PUSH
7866: LD_INT 150
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: LIST
7873: PPUSH
7874: LD_INT 16
7876: PUSH
7877: LD_INT 6
7879: PUSH
7880: LD_INT 6
7882: PUSH
7883: LD_INT 8
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: PPUSH
7892: CALL 61564 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7896: LD_ADDR_EXP 78
7900: PUSH
7901: LD_EXP 78
7905: PPUSH
7906: LD_INT 3
7908: PPUSH
7909: LD_INT 22
7911: PUSH
7912: LD_VAR 0 3
7916: PUSH
7917: EMPTY
7918: LIST
7919: LIST
7920: PUSH
7921: LD_INT 23
7923: PUSH
7924: LD_INT 2
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: PUSH
7931: LD_INT 3
7933: PUSH
7934: LD_INT 21
7936: PUSH
7937: LD_INT 2
7939: PUSH
7940: EMPTY
7941: LIST
7942: LIST
7943: PUSH
7944: EMPTY
7945: LIST
7946: LIST
7947: PUSH
7948: EMPTY
7949: LIST
7950: LIST
7951: LIST
7952: PPUSH
7953: CALL_OW 69
7957: PUSH
7958: LD_EXP 57
7962: DIFF
7963: PPUSH
7964: CALL_OW 1
7968: ST_TO_ADDR
// end ;
7969: LD_VAR 0 1
7973: RET
// export function BuildKozlovBomb ; begin
7974: LD_INT 0
7976: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7977: LD_INT 332
7979: PPUSH
7980: CALL_OW 302
7984: NOT
7985: PUSH
7986: LD_INT 336
7988: PPUSH
7989: CALL_OW 302
7993: NOT
7994: OR
7995: IFFALSE 7999
// exit ;
7997: GO 8096
// ComChangeProfession ( Kozlov , 4 ) ;
7999: LD_EXP 58
8003: PPUSH
8004: LD_INT 4
8006: PPUSH
8007: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
8011: LD_INT 336
8013: PPUSH
8014: LD_INT 25
8016: PPUSH
8017: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
8021: LD_INT 35
8023: PPUSH
8024: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
8028: LD_INT 25
8030: PPUSH
8031: LD_INT 8
8033: PPUSH
8034: CALL_OW 321
8038: PUSH
8039: LD_INT 2
8041: EQUAL
8042: IFFALSE 8021
// ComExitBuilding ( Kozlov ) ;
8044: LD_EXP 58
8048: PPUSH
8049: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8053: LD_EXP 58
8057: PPUSH
8058: LD_INT 332
8060: PPUSH
8061: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8065: LD_EXP 58
8069: PPUSH
8070: LD_INT 3
8072: PPUSH
8073: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8077: LD_INT 332
8079: PPUSH
8080: LD_INT 23
8082: PPUSH
8083: LD_INT 3
8085: PPUSH
8086: LD_INT 1
8088: PPUSH
8089: LD_INT 48
8091: PPUSH
8092: CALL_OW 125
// end ;
8096: LD_VAR 0 1
8100: RET
// every 9 9$30 + 7 7$00 trigger not legionDestroyed do var i , tmp , target , p ;
8101: LD_EXP 3
8105: NOT
8106: IFFALSE 8996
8108: GO 8110
8110: DISABLE
8111: LD_INT 0
8113: PPUSH
8114: PPUSH
8115: PPUSH
8116: PPUSH
// begin enable ;
8117: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8118: LD_INT 22
8120: PUSH
8121: LD_INT 8
8123: PUSH
8124: EMPTY
8125: LIST
8126: LIST
8127: PUSH
8128: LD_INT 23
8130: PUSH
8131: LD_INT 2
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PUSH
8138: LD_INT 30
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: LIST
8152: PPUSH
8153: CALL_OW 69
8157: NOT
8158: IFFALSE 8162
// exit ;
8160: GO 8996
// if Prob ( 40 ) then
8162: LD_INT 40
8164: PPUSH
8165: CALL_OW 13
8169: IFFALSE 8296
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8171: LD_INT 3
8173: PPUSH
8174: LD_INT 14
8176: PUSH
8177: LD_INT 1
8179: PUSH
8180: LD_INT 2
8182: PUSH
8183: LD_INT 28
8185: PUSH
8186: EMPTY
8187: LIST
8188: LIST
8189: LIST
8190: LIST
8191: PUSH
8192: LD_INT 14
8194: PUSH
8195: LD_INT 1
8197: PUSH
8198: LD_INT 2
8200: PUSH
8201: LD_INT 28
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: LIST
8208: LIST
8209: PUSH
8210: LD_INT 14
8212: PUSH
8213: LD_INT 1
8215: PUSH
8216: LD_INT 2
8218: PUSH
8219: LD_INT 28
8221: PUSH
8222: EMPTY
8223: LIST
8224: LIST
8225: LIST
8226: LIST
8227: PUSH
8228: LD_INT 14
8230: PUSH
8231: LD_INT 1
8233: PUSH
8234: LD_INT 2
8236: PUSH
8237: LD_INT 28
8239: PUSH
8240: EMPTY
8241: LIST
8242: LIST
8243: LIST
8244: LIST
8245: PUSH
8246: LD_INT 14
8248: PUSH
8249: LD_INT 1
8251: PUSH
8252: LD_INT 2
8254: PUSH
8255: LD_INT 28
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: LIST
8262: LIST
8263: PUSH
8264: LD_INT 14
8266: PUSH
8267: LD_INT 1
8269: PUSH
8270: LD_INT 2
8272: PUSH
8273: LD_INT 26
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: LIST
8280: LIST
8281: PUSH
8282: EMPTY
8283: LIST
8284: LIST
8285: LIST
8286: LIST
8287: LIST
8288: LIST
8289: PPUSH
8290: CALL 46477 0 2
// end else
8294: GO 8503
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8296: LD_INT 3
8298: PPUSH
8299: LD_INT 14
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: LD_INT 2
8307: PUSH
8308: LD_INT 27
8310: PUSH
8311: LD_INT 26
8313: PUSH
8314: LD_INT 26
8316: PUSH
8317: LD_INT 28
8319: PUSH
8320: EMPTY
8321: LIST
8322: LIST
8323: LIST
8324: LIST
8325: PUSH
8326: LD_OWVAR 67
8330: ARRAY
8331: PUSH
8332: EMPTY
8333: LIST
8334: LIST
8335: LIST
8336: LIST
8337: PUSH
8338: LD_INT 14
8340: PUSH
8341: LD_INT 1
8343: PUSH
8344: LD_INT 2
8346: PUSH
8347: LD_INT 27
8349: PUSH
8350: LD_INT 26
8352: PUSH
8353: LD_INT 26
8355: PUSH
8356: LD_INT 26
8358: PUSH
8359: EMPTY
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: PUSH
8365: LD_OWVAR 67
8369: ARRAY
8370: PUSH
8371: EMPTY
8372: LIST
8373: LIST
8374: LIST
8375: LIST
8376: PUSH
8377: LD_INT 14
8379: PUSH
8380: LD_INT 1
8382: PUSH
8383: LD_INT 2
8385: PUSH
8386: LD_INT 26
8388: PUSH
8389: LD_INT 26
8391: PUSH
8392: LD_INT 29
8394: PUSH
8395: LD_INT 29
8397: PUSH
8398: EMPTY
8399: LIST
8400: LIST
8401: LIST
8402: LIST
8403: PUSH
8404: LD_OWVAR 67
8408: ARRAY
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 13
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 2
8424: PUSH
8425: LD_INT 26
8427: PUSH
8428: LD_INT 29
8430: PUSH
8431: LD_INT 29
8433: PUSH
8434: LD_INT 29
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: LIST
8441: LIST
8442: PUSH
8443: LD_OWVAR 67
8447: ARRAY
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: LIST
8453: LIST
8454: PUSH
8455: LD_INT 13
8457: PUSH
8458: LD_INT 1
8460: PUSH
8461: LD_INT 2
8463: PUSH
8464: LD_INT 29
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: LIST
8472: PUSH
8473: LD_INT 14
8475: PUSH
8476: LD_INT 1
8478: PUSH
8479: LD_INT 2
8481: PUSH
8482: LD_INT 26
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: LIST
8489: LIST
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: LIST
8495: LIST
8496: LIST
8497: LIST
8498: PPUSH
8499: CALL 46477 0 2
// end ; p := 0 ;
8503: LD_ADDR_VAR 0 4
8507: PUSH
8508: LD_INT 0
8510: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8511: LD_INT 35
8513: PPUSH
8514: CALL_OW 67
// p := Inc ( p ) ;
8518: LD_ADDR_VAR 0 4
8522: PUSH
8523: LD_VAR 0 4
8527: PPUSH
8528: CALL 91966 0 1
8532: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8533: LD_INT 3
8535: PPUSH
8536: LD_INT 1
8538: PPUSH
8539: CALL 47895 0 2
8543: PUSH
8544: LD_INT 6
8546: GREATEREQUAL
8547: PUSH
8548: LD_VAR 0 4
8552: PUSH
8553: LD_INT 100
8555: GREATER
8556: OR
8557: IFFALSE 8511
// wait ( 0 0$30 ) ;
8559: LD_INT 1050
8561: PPUSH
8562: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8566: LD_ADDR_VAR 0 2
8570: PUSH
8571: LD_INT 3
8573: PPUSH
8574: LD_INT 1
8576: PPUSH
8577: CALL 47895 0 2
8581: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8582: LD_ADDR_EXP 97
8586: PUSH
8587: LD_EXP 97
8591: PPUSH
8592: LD_INT 3
8594: PPUSH
8595: LD_EXP 97
8599: PUSH
8600: LD_INT 3
8602: ARRAY
8603: PUSH
8604: LD_VAR 0 2
8608: DIFF
8609: PPUSH
8610: CALL_OW 1
8614: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8615: LD_ADDR_VAR 0 3
8619: PUSH
8620: LD_INT 0
8622: PPUSH
8623: LD_INT 2
8625: PPUSH
8626: CALL_OW 12
8630: ST_TO_ADDR
// if target then
8631: LD_VAR 0 3
8635: IFFALSE 8763
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8637: LD_ADDR_VAR 0 2
8641: PUSH
8642: LD_VAR 0 2
8646: PPUSH
8647: LD_INT 24
8649: PUSH
8650: LD_INT 250
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: PPUSH
8657: CALL_OW 72
8661: ST_TO_ADDR
// for i in tmp do
8662: LD_ADDR_VAR 0 1
8666: PUSH
8667: LD_VAR 0 2
8671: PUSH
8672: FOR_IN
8673: IFFALSE 8713
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8675: LD_VAR 0 1
8679: PPUSH
8680: LD_INT 89
8682: PPUSH
8683: LD_INT 71
8685: PPUSH
8686: CALL_OW 297
8690: PUSH
8691: LD_INT 9
8693: GREATER
8694: IFFALSE 8711
// ComMoveXY ( i , 89 , 71 ) ;
8696: LD_VAR 0 1
8700: PPUSH
8701: LD_INT 89
8703: PPUSH
8704: LD_INT 71
8706: PPUSH
8707: CALL_OW 111
8711: GO 8672
8713: POP
8714: POP
// wait ( 0 0$1 ) ;
8715: LD_INT 35
8717: PPUSH
8718: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8722: LD_VAR 0 2
8726: PPUSH
8727: LD_INT 92
8729: PUSH
8730: LD_INT 89
8732: PUSH
8733: LD_INT 71
8735: PUSH
8736: LD_INT 9
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: LIST
8743: LIST
8744: PPUSH
8745: CALL_OW 72
8749: PUSH
8750: LD_VAR 0 2
8754: PUSH
8755: LD_INT 1
8757: MINUS
8758: GREATEREQUAL
8759: IFFALSE 8637
// end else
8761: GO 8887
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8763: LD_ADDR_VAR 0 2
8767: PUSH
8768: LD_VAR 0 2
8772: PPUSH
8773: LD_INT 24
8775: PUSH
8776: LD_INT 250
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: PPUSH
8783: CALL_OW 72
8787: ST_TO_ADDR
// for i in tmp do
8788: LD_ADDR_VAR 0 1
8792: PUSH
8793: LD_VAR 0 2
8797: PUSH
8798: FOR_IN
8799: IFFALSE 8839
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8801: LD_VAR 0 1
8805: PPUSH
8806: LD_INT 147
8808: PPUSH
8809: LD_INT 4
8811: PPUSH
8812: CALL_OW 297
8816: PUSH
8817: LD_INT 9
8819: GREATER
8820: IFFALSE 8837
// ComMoveXY ( i , 147 , 4 ) ;
8822: LD_VAR 0 1
8826: PPUSH
8827: LD_INT 147
8829: PPUSH
8830: LD_INT 4
8832: PPUSH
8833: CALL_OW 111
8837: GO 8798
8839: POP
8840: POP
// wait ( 0 0$1 ) ;
8841: LD_INT 35
8843: PPUSH
8844: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8848: LD_VAR 0 2
8852: PPUSH
8853: LD_INT 92
8855: PUSH
8856: LD_INT 147
8858: PUSH
8859: LD_INT 4
8861: PUSH
8862: LD_INT 9
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: LIST
8869: LIST
8870: PPUSH
8871: CALL_OW 72
8875: PUSH
8876: LD_VAR 0 2
8880: PUSH
8881: LD_INT 1
8883: MINUS
8884: GREATEREQUAL
8885: IFFALSE 8763
// end ; repeat wait ( 0 0$1 ) ;
8887: LD_INT 35
8889: PPUSH
8890: CALL_OW 67
// for i in tmp do
8894: LD_ADDR_VAR 0 1
8898: PUSH
8899: LD_VAR 0 2
8903: PUSH
8904: FOR_IN
8905: IFFALSE 8987
// begin if GetLives ( i ) > 251 then
8907: LD_VAR 0 1
8911: PPUSH
8912: CALL_OW 256
8916: PUSH
8917: LD_INT 251
8919: GREATER
8920: IFFALSE 8958
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8922: LD_VAR 0 1
8926: PPUSH
8927: LD_INT 81
8929: PUSH
8930: LD_INT 8
8932: PUSH
8933: EMPTY
8934: LIST
8935: LIST
8936: PPUSH
8937: CALL_OW 69
8941: PPUSH
8942: LD_VAR 0 1
8946: PPUSH
8947: CALL_OW 74
8951: PPUSH
8952: CALL_OW 115
8956: GO 8985
// if IsDead ( i ) then
8958: LD_VAR 0 1
8962: PPUSH
8963: CALL_OW 301
8967: IFFALSE 8985
// tmp := tmp diff i ;
8969: LD_ADDR_VAR 0 2
8973: PUSH
8974: LD_VAR 0 2
8978: PUSH
8979: LD_VAR 0 1
8983: DIFF
8984: ST_TO_ADDR
// end ;
8985: GO 8904
8987: POP
8988: POP
// until not tmp ;
8989: LD_VAR 0 2
8993: NOT
8994: IFFALSE 8887
// end ;
8996: PPOPN 4
8998: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8999: LD_EXP 58
9003: PPUSH
9004: CALL_OW 302
9008: PUSH
9009: LD_EXP 3
9013: NOT
9014: AND
9015: IFFALSE 9024
9017: GO 9019
9019: DISABLE
// BuildKozlovBomb ;
9020: CALL 7974 0 0
9024: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
9025: LD_INT 22
9027: PUSH
9028: LD_INT 8
9030: PUSH
9031: EMPTY
9032: LIST
9033: LIST
9034: PUSH
9035: LD_INT 34
9037: PUSH
9038: LD_INT 48
9040: PUSH
9041: EMPTY
9042: LIST
9043: LIST
9044: PUSH
9045: EMPTY
9046: LIST
9047: LIST
9048: PPUSH
9049: CALL_OW 69
9053: IFFALSE 9101
9055: GO 9057
9057: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9058: LD_INT 22
9060: PUSH
9061: LD_INT 8
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: PUSH
9068: LD_INT 34
9070: PUSH
9071: LD_INT 48
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PPUSH
9082: CALL_OW 69
9086: PUSH
9087: LD_INT 1
9089: ARRAY
9090: PPUSH
9091: LD_INT 173
9093: PPUSH
9094: LD_INT 96
9096: PPUSH
9097: CALL_OW 116
// end ; end_of_file
9101: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9102: LD_INT 0
9104: PPUSH
9105: PPUSH
9106: PPUSH
9107: PPUSH
9108: PPUSH
9109: PPUSH
9110: PPUSH
9111: PPUSH
9112: PPUSH
9113: PPUSH
// side := 3 ;
9114: LD_ADDR_VAR 0 6
9118: PUSH
9119: LD_INT 3
9121: ST_TO_ADDR
// InitHc ;
9122: CALL_OW 19
// uc_side := side ;
9126: LD_ADDR_OWVAR 20
9130: PUSH
9131: LD_VAR 0 6
9135: ST_TO_ADDR
// uc_nation := 3 ;
9136: LD_ADDR_OWVAR 21
9140: PUSH
9141: LD_INT 3
9143: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9144: LD_ADDR_VAR 0 2
9148: PUSH
9149: LD_INT 22
9151: PUSH
9152: LD_VAR 0 6
9156: PUSH
9157: EMPTY
9158: LIST
9159: LIST
9160: PUSH
9161: LD_INT 21
9163: PUSH
9164: LD_INT 3
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: PPUSH
9175: CALL_OW 69
9179: PUSH
9180: FOR_IN
9181: IFFALSE 9197
// SetBLevel ( i , 10 ) ;
9183: LD_VAR 0 2
9187: PPUSH
9188: LD_INT 10
9190: PPUSH
9191: CALL_OW 241
9195: GO 9180
9197: POP
9198: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9199: LD_ADDR_VAR 0 10
9203: PUSH
9204: LD_INT 22
9206: PUSH
9207: LD_VAR 0 6
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: PUSH
9216: LD_INT 30
9218: PUSH
9219: LD_INT 34
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: PPUSH
9230: CALL_OW 69
9234: ST_TO_ADDR
// if teleport then
9235: LD_VAR 0 10
9239: IFFALSE 9260
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9241: LD_VAR 0 10
9245: PUSH
9246: LD_INT 1
9248: ARRAY
9249: PPUSH
9250: LD_INT 123
9252: PPUSH
9253: LD_INT 122
9255: PPUSH
9256: CALL_OW 243
// hc_importance := 0 ;
9260: LD_ADDR_OWVAR 32
9264: PUSH
9265: LD_INT 0
9267: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9268: LD_ADDR_EXP 60
9272: PUSH
9273: LD_STRING Platonov
9275: PPUSH
9276: CALL_OW 25
9280: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9281: LD_ADDR_EXP 61
9285: PUSH
9286: LD_STRING Yakotich
9288: PPUSH
9289: LD_EXP 1
9293: NOT
9294: PPUSH
9295: LD_STRING 09_
9297: PPUSH
9298: CALL 52903 0 3
9302: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9303: LD_ADDR_EXP 62
9307: PUSH
9308: LD_STRING Gleb
9310: PPUSH
9311: CALL_OW 25
9315: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9316: LD_STRING 03_Cornel
9318: PPUSH
9319: CALL_OW 28
9323: IFFALSE 9371
// begin Bierezov := NewCharacter ( Mikhail ) ;
9325: LD_ADDR_EXP 63
9329: PUSH
9330: LD_STRING Mikhail
9332: PPUSH
9333: CALL_OW 25
9337: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9338: LD_EXP 63
9342: PPUSH
9343: LD_INT 197
9345: PPUSH
9346: LD_INT 111
9348: PPUSH
9349: LD_INT 9
9351: PPUSH
9352: LD_INT 0
9354: PPUSH
9355: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9359: LD_EXP 63
9363: PPUSH
9364: LD_INT 3
9366: PPUSH
9367: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9371: LD_EXP 60
9375: PPUSH
9376: LD_INT 126
9378: PPUSH
9379: CALL_OW 52
// if Yakotich then
9383: LD_EXP 61
9387: IFFALSE 9410
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9389: LD_EXP 61
9393: PPUSH
9394: LD_INT 197
9396: PPUSH
9397: LD_INT 111
9399: PPUSH
9400: LD_INT 9
9402: PPUSH
9403: LD_INT 0
9405: PPUSH
9406: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9410: LD_EXP 62
9414: PPUSH
9415: LD_INT 197
9417: PPUSH
9418: LD_INT 111
9420: PPUSH
9421: LD_INT 9
9423: PPUSH
9424: LD_INT 0
9426: PPUSH
9427: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9431: LD_ADDR_VAR 0 5
9435: PUSH
9436: LD_INT 126
9438: PPUSH
9439: LD_INT 2
9441: PPUSH
9442: LD_STRING zhukov
9444: PPUSH
9445: LD_INT 9
9447: PUSH
9448: LD_INT 10
9450: PUSH
9451: LD_INT 10
9453: PUSH
9454: LD_INT 10
9456: PUSH
9457: EMPTY
9458: LIST
9459: LIST
9460: LIST
9461: LIST
9462: PUSH
9463: LD_OWVAR 67
9467: ARRAY
9468: PPUSH
9469: LD_INT 9000
9471: PUSH
9472: LD_INT 1000
9474: PUSH
9475: LD_INT 300
9477: PUSH
9478: EMPTY
9479: LIST
9480: LIST
9481: LIST
9482: PPUSH
9483: LD_INT 21
9485: PUSH
9486: LD_INT 8
9488: PUSH
9489: LD_INT 13
9491: PUSH
9492: LD_INT 8
9494: PUSH
9495: EMPTY
9496: LIST
9497: LIST
9498: LIST
9499: LIST
9500: PPUSH
9501: CALL 61564 0 6
9505: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9506: LD_ADDR_EXP 78
9510: PUSH
9511: LD_EXP 78
9515: PPUSH
9516: LD_INT 2
9518: PPUSH
9519: LD_VAR 0 5
9523: PUSH
9524: LD_EXP 61
9528: PUSH
9529: LD_EXP 62
9533: PUSH
9534: LD_EXP 63
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: LIST
9543: UNION
9544: PPUSH
9545: CALL_OW 1
9549: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9550: LD_ADDR_VAR 0 4
9554: PUSH
9555: LD_INT 267
9557: PPUSH
9558: CALL_OW 274
9562: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9563: LD_VAR 0 4
9567: PPUSH
9568: LD_INT 1
9570: PPUSH
9571: LD_INT 5000
9573: PPUSH
9574: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9578: LD_VAR 0 4
9582: PPUSH
9583: LD_INT 2
9585: PPUSH
9586: LD_INT 200
9588: PPUSH
9589: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9593: LD_VAR 0 4
9597: PPUSH
9598: LD_INT 3
9600: PPUSH
9601: LD_INT 200
9603: PPUSH
9604: CALL_OW 277
// for i := 1 to 6 do
9608: LD_ADDR_VAR 0 2
9612: PUSH
9613: DOUBLE
9614: LD_INT 1
9616: DEC
9617: ST_TO_ADDR
9618: LD_INT 6
9620: PUSH
9621: FOR_TO
9622: IFFALSE 9705
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
9624: LD_INT 0
9626: PPUSH
9627: LD_INT 8
9629: PUSH
9630: LD_INT 9
9632: PUSH
9633: LD_INT 10
9635: PUSH
9636: LD_INT 10
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: PUSH
9645: LD_OWVAR 67
9649: ARRAY
9650: PPUSH
9651: CALL_OW 381
// un := CreateHuman ;
9655: LD_ADDR_VAR 0 8
9659: PUSH
9660: CALL_OW 44
9664: ST_TO_ADDR
// if i mod 2 = 0 then
9665: LD_VAR 0 2
9669: PUSH
9670: LD_INT 2
9672: MOD
9673: PUSH
9674: LD_INT 0
9676: EQUAL
9677: IFFALSE 9691
// SetClass ( un , class_bazooker ) ;
9679: LD_VAR 0 8
9683: PPUSH
9684: LD_INT 9
9686: PPUSH
9687: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
9691: LD_VAR 0 8
9695: PPUSH
9696: LD_INT 674
9698: PPUSH
9699: CALL_OW 52
// end ;
9703: GO 9621
9705: POP
9706: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
9707: LD_INT 21
9709: PPUSH
9710: LD_INT 3
9712: PPUSH
9713: LD_INT 3
9715: PPUSH
9716: LD_INT 52
9718: PPUSH
9719: LD_INT 100
9721: PPUSH
9722: CALL 57743 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
9726: CALL_OW 45
9730: PPUSH
9731: LD_INT 259
9733: PPUSH
9734: LD_INT 145
9736: PPUSH
9737: LD_INT 3
9739: PPUSH
9740: LD_INT 0
9742: PPUSH
9743: CALL 92745 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
9747: CALL_OW 45
9751: PPUSH
9752: LD_INT 245
9754: PPUSH
9755: LD_INT 139
9757: PPUSH
9758: LD_INT 3
9760: PPUSH
9761: LD_INT 0
9763: PPUSH
9764: CALL 92745 0 5
// behemoths := [ ] ;
9768: LD_ADDR_EXP 64
9772: PUSH
9773: EMPTY
9774: ST_TO_ADDR
// behemothBuilders := [ ] ;
9775: LD_ADDR_EXP 65
9779: PUSH
9780: EMPTY
9781: ST_TO_ADDR
// j := 3 ;
9782: LD_ADDR_VAR 0 3
9786: PUSH
9787: LD_INT 3
9789: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9790: LD_ADDR_VAR 0 2
9794: PUSH
9795: LD_INT 22
9797: PUSH
9798: LD_INT 3
9800: PUSH
9801: EMPTY
9802: LIST
9803: LIST
9804: PUSH
9805: LD_INT 25
9807: PUSH
9808: LD_INT 3
9810: PUSH
9811: EMPTY
9812: LIST
9813: LIST
9814: PUSH
9815: EMPTY
9816: LIST
9817: LIST
9818: PPUSH
9819: CALL_OW 69
9823: PUSH
9824: FOR_IN
9825: IFFALSE 9875
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9827: LD_ADDR_EXP 65
9831: PUSH
9832: LD_EXP 65
9836: PPUSH
9837: LD_VAR 0 2
9841: PPUSH
9842: CALL 90605 0 2
9846: ST_TO_ADDR
// j := j - 1 ;
9847: LD_ADDR_VAR 0 3
9851: PUSH
9852: LD_VAR 0 3
9856: PUSH
9857: LD_INT 1
9859: MINUS
9860: ST_TO_ADDR
// if j = 0 then
9861: LD_VAR 0 3
9865: PUSH
9866: LD_INT 0
9868: EQUAL
9869: IFFALSE 9873
// break ;
9871: GO 9875
// end ;
9873: GO 9824
9875: POP
9876: POP
// end ;
9877: LD_VAR 0 1
9881: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9882: LD_INT 0
9884: PPUSH
9885: PPUSH
9886: PPUSH
9887: PPUSH
9888: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9889: LD_ADDR_VAR 0 4
9893: PUSH
9894: LD_INT 209
9896: PUSH
9897: LD_INT 149
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: PUSH
9904: LD_INT 219
9906: PUSH
9907: LD_INT 154
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: PUSH
9914: LD_INT 223
9916: PUSH
9917: LD_INT 149
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PUSH
9924: LD_INT 232
9926: PUSH
9927: LD_INT 155
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PUSH
9934: EMPTY
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: ST_TO_ADDR
// if not behemothBuilders then
9940: LD_EXP 65
9944: NOT
9945: IFFALSE 9949
// exit ;
9947: GO 10053
// j := 1 ;
9949: LD_ADDR_VAR 0 3
9953: PUSH
9954: LD_INT 1
9956: ST_TO_ADDR
// for i in behemothBuilders do
9957: LD_ADDR_VAR 0 2
9961: PUSH
9962: LD_EXP 65
9966: PUSH
9967: FOR_IN
9968: IFFALSE 10051
// begin if IsInUnit ( i ) then
9970: LD_VAR 0 2
9974: PPUSH
9975: CALL_OW 310
9979: IFFALSE 9990
// ComExitBuilding ( i ) ;
9981: LD_VAR 0 2
9985: PPUSH
9986: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9990: LD_VAR 0 2
9994: PPUSH
9995: LD_INT 37
9997: PPUSH
9998: LD_VAR 0 4
10002: PUSH
10003: LD_VAR 0 3
10007: ARRAY
10008: PUSH
10009: LD_INT 1
10011: ARRAY
10012: PPUSH
10013: LD_VAR 0 4
10017: PUSH
10018: LD_VAR 0 3
10022: ARRAY
10023: PUSH
10024: LD_INT 2
10026: ARRAY
10027: PPUSH
10028: LD_INT 0
10030: PPUSH
10031: CALL_OW 230
// j := j + 1 ;
10035: LD_ADDR_VAR 0 3
10039: PUSH
10040: LD_VAR 0 3
10044: PUSH
10045: LD_INT 1
10047: PLUS
10048: ST_TO_ADDR
// end ;
10049: GO 9967
10051: POP
10052: POP
// end ;
10053: LD_VAR 0 1
10057: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10058: LD_INT 3
10060: PPUSH
10061: CALL 90666 0 1
10065: PUSH
10066: LD_INT 22
10068: PUSH
10069: LD_INT 3
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: PUSH
10076: LD_INT 30
10078: PUSH
10079: LD_INT 37
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: PUSH
10086: EMPTY
10087: LIST
10088: LIST
10089: PPUSH
10090: CALL_OW 69
10094: NOT
10095: AND
10096: IFFALSE 10282
10098: GO 10100
10100: DISABLE
10101: LD_INT 0
10103: PPUSH
10104: PPUSH
// begin enable ;
10105: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10106: LD_ADDR_VAR 0 2
10110: PUSH
10111: LD_INT 3
10113: PPUSH
10114: CALL 90666 0 1
10118: ST_TO_ADDR
// for i in tmp do
10119: LD_ADDR_VAR 0 1
10123: PUSH
10124: LD_VAR 0 2
10128: PUSH
10129: FOR_IN
10130: IFFALSE 10280
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10132: LD_VAR 0 1
10136: PPUSH
10137: LD_INT 7
10139: PPUSH
10140: CALL_OW 308
10144: PUSH
10145: LD_VAR 0 1
10149: PPUSH
10150: CALL_OW 110
10154: PUSH
10155: LD_INT 2
10157: EQUAL
10158: NOT
10159: AND
10160: IFFALSE 10174
// SetTag ( i , 2 ) ;
10162: LD_VAR 0 1
10166: PPUSH
10167: LD_INT 2
10169: PPUSH
10170: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10174: LD_INT 81
10176: PUSH
10177: LD_INT 3
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: PUSH
10184: LD_INT 91
10186: PUSH
10187: LD_VAR 0 1
10191: PUSH
10192: LD_INT 12
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: LIST
10199: PUSH
10200: EMPTY
10201: LIST
10202: LIST
10203: PPUSH
10204: CALL_OW 69
10208: NOT
10209: PUSH
10210: LD_VAR 0 1
10214: PPUSH
10215: CALL_OW 110
10219: PUSH
10220: LD_INT 2
10222: EQUAL
10223: NOT
10224: AND
10225: IFFALSE 10244
// ComAgressiveMove ( i , 64 , 93 ) else
10227: LD_VAR 0 1
10231: PPUSH
10232: LD_INT 64
10234: PPUSH
10235: LD_INT 93
10237: PPUSH
10238: CALL_OW 114
10242: GO 10278
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10244: LD_VAR 0 1
10248: PPUSH
10249: LD_INT 81
10251: PUSH
10252: LD_INT 3
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PPUSH
10259: CALL_OW 69
10263: PPUSH
10264: LD_VAR 0 1
10268: PPUSH
10269: CALL_OW 74
10273: PPUSH
10274: CALL_OW 115
// end ;
10278: GO 10129
10280: POP
10281: POP
// end ;
10282: PPOPN 2
10284: END
// every 9 9$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10285: LD_EXP 2
10289: NOT
10290: IFFALSE 11248
10292: GO 10294
10294: DISABLE
10295: LD_INT 0
10297: PPUSH
10298: PPUSH
10299: PPUSH
10300: PPUSH
10301: PPUSH
// begin enable ;
10302: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10303: LD_INT 22
10305: PUSH
10306: LD_INT 3
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: PUSH
10313: LD_INT 30
10315: PUSH
10316: LD_INT 3
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PPUSH
10327: CALL_OW 69
10331: NOT
10332: IFFALSE 10336
// exit ;
10334: GO 11248
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10336: LD_ADDR_VAR 0 4
10340: PUSH
10341: LD_INT 22
10343: PUSH
10344: LD_INT 3
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: PUSH
10351: LD_INT 30
10353: PUSH
10354: LD_INT 34
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: PUSH
10361: EMPTY
10362: LIST
10363: LIST
10364: PPUSH
10365: CALL_OW 69
10369: ST_TO_ADDR
// if Prob ( 40 ) then
10370: LD_INT 40
10372: PPUSH
10373: CALL_OW 13
10377: IFFALSE 10504
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10379: LD_INT 2
10381: PPUSH
10382: LD_INT 22
10384: PUSH
10385: LD_INT 3
10387: PUSH
10388: LD_INT 3
10390: PUSH
10391: LD_INT 49
10393: PUSH
10394: EMPTY
10395: LIST
10396: LIST
10397: LIST
10398: LIST
10399: PUSH
10400: LD_INT 22
10402: PUSH
10403: LD_INT 3
10405: PUSH
10406: LD_INT 3
10408: PUSH
10409: LD_INT 49
10411: PUSH
10412: EMPTY
10413: LIST
10414: LIST
10415: LIST
10416: LIST
10417: PUSH
10418: LD_INT 22
10420: PUSH
10421: LD_INT 3
10423: PUSH
10424: LD_INT 3
10426: PUSH
10427: LD_INT 49
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: LIST
10434: LIST
10435: PUSH
10436: LD_INT 24
10438: PUSH
10439: LD_INT 3
10441: PUSH
10442: LD_INT 3
10444: PUSH
10445: LD_INT 46
10447: PUSH
10448: EMPTY
10449: LIST
10450: LIST
10451: LIST
10452: LIST
10453: PUSH
10454: LD_INT 24
10456: PUSH
10457: LD_INT 3
10459: PUSH
10460: LD_INT 3
10462: PUSH
10463: LD_INT 46
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: LIST
10470: LIST
10471: PUSH
10472: LD_INT 24
10474: PUSH
10475: LD_INT 3
10477: PUSH
10478: LD_INT 3
10480: PUSH
10481: LD_INT 46
10483: PUSH
10484: EMPTY
10485: LIST
10486: LIST
10487: LIST
10488: LIST
10489: PUSH
10490: EMPTY
10491: LIST
10492: LIST
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: PPUSH
10498: CALL 46477 0 2
// end else
10502: GO 10627
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10504: LD_INT 2
10506: PPUSH
10507: LD_INT 24
10509: PUSH
10510: LD_INT 3
10512: PUSH
10513: LD_INT 3
10515: PUSH
10516: LD_INT 47
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: PUSH
10525: LD_INT 24
10527: PUSH
10528: LD_INT 3
10530: PUSH
10531: LD_INT 3
10533: PUSH
10534: LD_INT 47
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: PUSH
10543: LD_INT 24
10545: PUSH
10546: LD_INT 3
10548: PUSH
10549: LD_INT 3
10551: PUSH
10552: LD_INT 47
10554: PUSH
10555: EMPTY
10556: LIST
10557: LIST
10558: LIST
10559: LIST
10560: PUSH
10561: LD_INT 24
10563: PUSH
10564: LD_INT 3
10566: PUSH
10567: LD_INT 3
10569: PUSH
10570: LD_INT 46
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: PUSH
10579: LD_INT 24
10581: PUSH
10582: LD_INT 3
10584: PUSH
10585: LD_INT 3
10587: PUSH
10588: LD_INT 46
10590: PUSH
10591: EMPTY
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: PUSH
10597: LD_INT 24
10599: PUSH
10600: LD_INT 3
10602: PUSH
10603: LD_INT 3
10605: PUSH
10606: LD_INT 46
10608: PUSH
10609: EMPTY
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: PUSH
10615: EMPTY
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: PPUSH
10623: CALL 46477 0 2
// end ; if Difficulty > 1 then
10627: LD_OWVAR 67
10631: PUSH
10632: LD_INT 1
10634: GREATER
10635: IFFALSE 10665
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10637: LD_INT 2
10639: PPUSH
10640: LD_INT 24
10642: PUSH
10643: LD_INT 3
10645: PUSH
10646: LD_INT 3
10648: PUSH
10649: LD_INT 47
10651: PUSH
10652: EMPTY
10653: LIST
10654: LIST
10655: LIST
10656: LIST
10657: PUSH
10658: EMPTY
10659: LIST
10660: PPUSH
10661: CALL 46477 0 2
// p := 0 ;
10665: LD_ADDR_VAR 0 5
10669: PUSH
10670: LD_INT 0
10672: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10673: LD_INT 35
10675: PPUSH
10676: CALL_OW 67
// p := Inc ( p ) ;
10680: LD_ADDR_VAR 0 5
10684: PUSH
10685: LD_VAR 0 5
10689: PPUSH
10690: CALL 91966 0 1
10694: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 100 ;
10695: LD_INT 2
10697: PPUSH
10698: LD_INT 1
10700: PPUSH
10701: CALL 47895 0 2
10705: PUSH
10706: LD_INT 6
10708: PUSH
10709: LD_INT 7
10711: PUSH
10712: LD_INT 7
10714: PUSH
10715: LD_INT 7
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: LIST
10722: LIST
10723: PUSH
10724: LD_OWVAR 67
10728: ARRAY
10729: GREATEREQUAL
10730: PUSH
10731: LD_VAR 0 5
10735: PUSH
10736: LD_INT 100
10738: GREATER
10739: OR
10740: IFFALSE 10673
// wait ( 0 0$30 ) ;
10742: LD_INT 1050
10744: PPUSH
10745: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10749: LD_ADDR_VAR 0 2
10753: PUSH
10754: LD_INT 2
10756: PPUSH
10757: LD_INT 1
10759: PPUSH
10760: CALL 47895 0 2
10764: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10765: LD_ADDR_EXP 97
10769: PUSH
10770: LD_EXP 97
10774: PPUSH
10775: LD_INT 2
10777: PPUSH
10778: LD_EXP 97
10782: PUSH
10783: LD_INT 2
10785: ARRAY
10786: PUSH
10787: LD_VAR 0 2
10791: DIFF
10792: PPUSH
10793: CALL_OW 1
10797: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10798: LD_ADDR_VAR 0 3
10802: PUSH
10803: LD_INT 0
10805: PPUSH
10806: LD_INT 1
10808: PPUSH
10809: CALL_OW 12
10813: ST_TO_ADDR
// if target then
10814: LD_VAR 0 3
10818: IFFALSE 10946
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10820: LD_ADDR_VAR 0 2
10824: PUSH
10825: LD_VAR 0 2
10829: PPUSH
10830: LD_INT 24
10832: PUSH
10833: LD_INT 250
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: PPUSH
10840: CALL_OW 72
10844: ST_TO_ADDR
// for i in tmp do
10845: LD_ADDR_VAR 0 1
10849: PUSH
10850: LD_VAR 0 2
10854: PUSH
10855: FOR_IN
10856: IFFALSE 10896
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10858: LD_VAR 0 1
10862: PPUSH
10863: LD_INT 139
10865: PPUSH
10866: LD_INT 89
10868: PPUSH
10869: CALL_OW 297
10873: PUSH
10874: LD_INT 9
10876: GREATER
10877: IFFALSE 10894
// ComMoveXY ( i , 139 , 89 ) ;
10879: LD_VAR 0 1
10883: PPUSH
10884: LD_INT 139
10886: PPUSH
10887: LD_INT 89
10889: PPUSH
10890: CALL_OW 111
10894: GO 10855
10896: POP
10897: POP
// wait ( 0 0$1 ) ;
10898: LD_INT 35
10900: PPUSH
10901: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10905: LD_VAR 0 2
10909: PPUSH
10910: LD_INT 92
10912: PUSH
10913: LD_INT 139
10915: PUSH
10916: LD_INT 89
10918: PUSH
10919: LD_INT 9
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: LIST
10926: LIST
10927: PPUSH
10928: CALL_OW 72
10932: PUSH
10933: LD_VAR 0 2
10937: PUSH
10938: LD_INT 1
10940: MINUS
10941: GREATEREQUAL
10942: IFFALSE 10820
// end else
10944: GO 11088
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10946: LD_VAR 0 2
10950: PPUSH
10951: LD_VAR 0 4
10955: PUSH
10956: LD_INT 1
10958: ARRAY
10959: PPUSH
10960: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10964: LD_ADDR_VAR 0 2
10968: PUSH
10969: LD_VAR 0 2
10973: PPUSH
10974: LD_INT 24
10976: PUSH
10977: LD_INT 250
10979: PUSH
10980: EMPTY
10981: LIST
10982: LIST
10983: PPUSH
10984: CALL_OW 72
10988: ST_TO_ADDR
// for i in tmp do
10989: LD_ADDR_VAR 0 1
10993: PUSH
10994: LD_VAR 0 2
10998: PUSH
10999: FOR_IN
11000: IFFALSE 11040
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11002: LD_VAR 0 1
11006: PPUSH
11007: LD_INT 124
11009: PPUSH
11010: LD_INT 139
11012: PPUSH
11013: CALL_OW 297
11017: PUSH
11018: LD_INT 9
11020: GREATER
11021: IFFALSE 11038
// ComMoveXY ( i , 124 , 139 ) ;
11023: LD_VAR 0 1
11027: PPUSH
11028: LD_INT 124
11030: PPUSH
11031: LD_INT 139
11033: PPUSH
11034: CALL_OW 111
11038: GO 10999
11040: POP
11041: POP
// wait ( 0 0$1 ) ;
11042: LD_INT 35
11044: PPUSH
11045: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
11049: LD_VAR 0 2
11053: PPUSH
11054: LD_INT 92
11056: PUSH
11057: LD_INT 124
11059: PUSH
11060: LD_INT 139
11062: PUSH
11063: LD_INT 9
11065: PUSH
11066: EMPTY
11067: LIST
11068: LIST
11069: LIST
11070: LIST
11071: PPUSH
11072: CALL_OW 72
11076: PUSH
11077: LD_VAR 0 2
11081: PUSH
11082: LD_INT 1
11084: MINUS
11085: GREATEREQUAL
11086: IFFALSE 10964
// end ; repeat wait ( 0 0$1 ) ;
11088: LD_INT 35
11090: PPUSH
11091: CALL_OW 67
// for i in tmp do
11095: LD_ADDR_VAR 0 1
11099: PUSH
11100: LD_VAR 0 2
11104: PUSH
11105: FOR_IN
11106: IFFALSE 11239
// begin if GetLives ( i ) > 251 then
11108: LD_VAR 0 1
11112: PPUSH
11113: CALL_OW 256
11117: PUSH
11118: LD_INT 251
11120: GREATER
11121: IFFALSE 11210
// begin if GetWeapon ( i ) = ru_time_lapser then
11123: LD_VAR 0 1
11127: PPUSH
11128: CALL_OW 264
11132: PUSH
11133: LD_INT 49
11135: EQUAL
11136: IFFALSE 11174
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11138: LD_VAR 0 1
11142: PPUSH
11143: LD_INT 81
11145: PUSH
11146: LD_INT 3
11148: PUSH
11149: EMPTY
11150: LIST
11151: LIST
11152: PPUSH
11153: CALL_OW 69
11157: PPUSH
11158: LD_VAR 0 1
11162: PPUSH
11163: CALL_OW 74
11167: PPUSH
11168: CALL_OW 112
11172: GO 11208
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11174: LD_VAR 0 1
11178: PPUSH
11179: LD_INT 81
11181: PUSH
11182: LD_INT 3
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: PPUSH
11189: CALL_OW 69
11193: PPUSH
11194: LD_VAR 0 1
11198: PPUSH
11199: CALL_OW 74
11203: PPUSH
11204: CALL_OW 115
// end else
11208: GO 11237
// if IsDead ( i ) then
11210: LD_VAR 0 1
11214: PPUSH
11215: CALL_OW 301
11219: IFFALSE 11237
// tmp := tmp diff i ;
11221: LD_ADDR_VAR 0 2
11225: PUSH
11226: LD_VAR 0 2
11230: PUSH
11231: LD_VAR 0 1
11235: DIFF
11236: ST_TO_ADDR
// end ;
11237: GO 11105
11239: POP
11240: POP
// until not tmp ;
11241: LD_VAR 0 2
11245: NOT
11246: IFFALSE 11088
// end ;
11248: PPOPN 5
11250: END
// every 30 30$00 trigger not russianDestroyed do
11251: LD_EXP 2
11255: NOT
11256: IFFALSE 11325
11258: GO 11260
11260: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11261: LD_INT 105000
11263: PUSH
11264: LD_INT 84000
11266: PUSH
11267: LD_INT 63000
11269: PUSH
11270: LD_INT 52500
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: PUSH
11279: LD_OWVAR 67
11283: ARRAY
11284: PPUSH
11285: CALL_OW 67
// if russianDestroyed then
11289: LD_EXP 2
11293: IFFALSE 11297
// exit ;
11295: GO 11325
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11297: LD_INT 2
11299: PPUSH
11300: LD_INT 23
11302: PUSH
11303: LD_INT 3
11305: PUSH
11306: LD_INT 1
11308: PUSH
11309: LD_INT 48
11311: PUSH
11312: EMPTY
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: PUSH
11318: EMPTY
11319: LIST
11320: PPUSH
11321: CALL 46477 0 2
// end ; end_of_file
11325: END
// export function CustomEvent ( event ) ; begin
11326: LD_INT 0
11328: PPUSH
// end ;
11329: LD_VAR 0 2
11333: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11334: LD_VAR 0 2
11338: PPUSH
11339: LD_VAR 0 3
11343: PPUSH
11344: LD_INT 15
11346: PPUSH
11347: CALL_OW 309
11351: IFFALSE 11360
// YouLost ( MothContaminate ) ;
11353: LD_STRING MothContaminate
11355: PPUSH
11356: CALL_OW 104
// end ;
11360: PPOPN 3
11362: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11363: LD_VAR 0 2
11367: PPUSH
11368: LD_VAR 0 3
11372: PPUSH
11373: LD_INT 15
11375: PPUSH
11376: CALL_OW 309
11380: IFFALSE 11396
// begin wait ( 0 0$6 ) ;
11382: LD_INT 210
11384: PPUSH
11385: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11389: LD_STRING MothContaminateBomb
11391: PPUSH
11392: CALL_OW 104
// end ; end ;
11396: PPOPN 3
11398: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11399: LD_VAR 0 1
11403: PPUSH
11404: CALL 110870 0 1
// if un = JMM then
11408: LD_VAR 0 1
11412: PUSH
11413: LD_EXP 19
11417: EQUAL
11418: IFFALSE 11429
// begin YouLost ( JMM ) ;
11420: LD_STRING JMM
11422: PPUSH
11423: CALL_OW 104
// exit ;
11427: GO 11558
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11429: LD_VAR 0 1
11433: PPUSH
11434: CALL_OW 255
11438: PUSH
11439: LD_INT 2
11441: EQUAL
11442: PUSH
11443: LD_EXP 18
11447: NOT
11448: AND
11449: IFFALSE 11459
// arabianAttacked := true ;
11451: LD_ADDR_EXP 18
11455: PUSH
11456: LD_INT 1
11458: ST_TO_ADDR
// if un = Powell then
11459: LD_VAR 0 1
11463: PUSH
11464: LD_EXP 55
11468: EQUAL
11469: IFFALSE 11479
// americanDestroyed := true ;
11471: LD_ADDR_EXP 4
11475: PUSH
11476: LD_INT 1
11478: ST_TO_ADDR
// if un = Platonov then
11479: LD_VAR 0 1
11483: PUSH
11484: LD_EXP 60
11488: EQUAL
11489: IFFALSE 11499
// russianDestroyed := true ;
11491: LD_ADDR_EXP 2
11495: PUSH
11496: LD_INT 1
11498: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11499: LD_VAR 0 1
11503: PUSH
11504: LD_INT 22
11506: PUSH
11507: LD_INT 7
11509: PUSH
11510: EMPTY
11511: LIST
11512: LIST
11513: PUSH
11514: LD_INT 21
11516: PUSH
11517: LD_INT 2
11519: PUSH
11520: EMPTY
11521: LIST
11522: LIST
11523: PUSH
11524: EMPTY
11525: LIST
11526: LIST
11527: PPUSH
11528: CALL_OW 69
11532: IN
11533: IFFALSE 11549
// vehicleLostCounter := vehicleLostCounter + 1 ;
11535: LD_ADDR_EXP 15
11539: PUSH
11540: LD_EXP 15
11544: PUSH
11545: LD_INT 1
11547: PLUS
11548: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11549: LD_VAR 0 1
11553: PPUSH
11554: CALL 49919 0 1
// end ;
11558: PPOPN 1
11560: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11561: LD_VAR 0 1
11565: PPUSH
11566: LD_VAR 0 2
11570: PPUSH
11571: CALL 52251 0 2
// end ;
11575: PPOPN 2
11577: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11578: LD_VAR 0 1
11582: PPUSH
11583: CALL 51319 0 1
// end ;
11587: PPOPN 1
11589: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11590: LD_VAR 0 1
11594: PUSH
11595: LD_INT 22
11597: PUSH
11598: LD_INT 8
11600: PUSH
11601: EMPTY
11602: LIST
11603: LIST
11604: PUSH
11605: LD_INT 30
11607: PUSH
11608: LD_INT 2
11610: PUSH
11611: EMPTY
11612: LIST
11613: LIST
11614: PUSH
11615: LD_INT 23
11617: PUSH
11618: LD_INT 3
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PUSH
11625: EMPTY
11626: LIST
11627: LIST
11628: LIST
11629: PPUSH
11630: CALL_OW 69
11634: IN
11635: IFFALSE 11662
// begin ComUpgrade ( building ) ;
11637: LD_VAR 0 1
11641: PPUSH
11642: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11646: LD_EXP 58
11650: PPUSH
11651: LD_VAR 0 1
11655: PPUSH
11656: CALL 61103 0 2
// exit ;
11660: GO 11671
// end ; MCE_BuildingComplete ( building ) ;
11662: LD_VAR 0 1
11666: PPUSH
11667: CALL 51560 0 1
// end ;
11671: PPOPN 1
11673: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11674: LD_VAR 0 1
11678: PPUSH
11679: LD_VAR 0 2
11683: PPUSH
11684: CALL 49615 0 2
// end ;
11688: PPOPN 2
11690: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: LD_VAR 0 3
11705: PPUSH
11706: LD_VAR 0 4
11710: PPUSH
11711: LD_VAR 0 5
11715: PPUSH
11716: CALL 49235 0 5
// end ;
11720: PPOPN 5
11722: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11723: LD_VAR 0 1
11727: PPUSH
11728: LD_VAR 0 2
11732: PPUSH
11733: CALL 110990 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11737: LD_VAR 0 1
11741: PPUSH
11742: LD_VAR 0 2
11746: PPUSH
11747: CALL 48788 0 2
// end ;
11751: PPOPN 2
11753: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11754: LD_VAR 0 1
11758: PPUSH
11759: LD_VAR 0 2
11763: PPUSH
11764: LD_VAR 0 3
11768: PPUSH
11769: LD_VAR 0 4
11773: PPUSH
11774: CALL 48626 0 4
// end ;
11778: PPOPN 4
11780: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11781: LD_VAR 0 1
11785: PPUSH
11786: LD_VAR 0 2
11790: PPUSH
11791: LD_VAR 0 3
11795: PPUSH
11796: CALL 48401 0 3
// end ;
11800: PPOPN 3
11802: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11803: LD_VAR 0 1
11807: PPUSH
11808: LD_VAR 0 2
11812: PPUSH
11813: CALL 48286 0 2
// end ;
11817: PPOPN 2
11819: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11820: LD_VAR 0 1
11824: PPUSH
11825: LD_VAR 0 2
11829: PPUSH
11830: CALL 52546 0 2
// end ;
11834: PPOPN 2
11836: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
11837: LD_VAR 0 1
11841: PUSH
11842: LD_INT 674
11844: EQUAL
11845: IFFALSE 11867
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
11847: LD_VAR 0 2
11851: PPUSH
11852: LD_INT 227
11854: PPUSH
11855: LD_INT 136
11857: PPUSH
11858: CALL_OW 428
11862: PPUSH
11863: CALL_OW 120
// end ;
11867: PPOPN 2
11869: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11870: LD_VAR 0 1
11874: PPUSH
11875: LD_VAR 0 2
11879: PPUSH
11880: LD_VAR 0 3
11884: PPUSH
11885: LD_VAR 0 4
11889: PPUSH
11890: CALL 52762 0 4
// end ;
11894: PPOPN 4
11896: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11897: LD_VAR 0 1
11901: PPUSH
11902: LD_VAR 0 2
11906: PPUSH
11907: CALL 48095 0 2
// end ;
11911: PPOPN 2
11913: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11914: LD_VAR 0 1
11918: PPUSH
11919: CALL 110974 0 1
// end ; end_of_file
11923: PPOPN 1
11925: END
// export function Action ; begin
11926: LD_INT 0
11928: PPUSH
// InGameOn ;
11929: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11933: LD_INT 206
11935: PPUSH
11936: LD_INT 11
11938: PPUSH
11939: CALL_OW 86
// wait ( 0 0$1 ) ;
11943: LD_INT 35
11945: PPUSH
11946: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11950: LD_EXP 19
11954: PPUSH
11955: LD_STRING DStart-JMM-JMM-1
11957: PPUSH
11958: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11962: LD_EXP 52
11966: PPUSH
11967: LD_STRING DStart-JMM-Bur-1
11969: PPUSH
11970: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11974: LD_EXP 19
11978: PPUSH
11979: LD_STRING DStart-JMM-JMM-2
11981: PPUSH
11982: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11986: LD_EXP 52
11990: PPUSH
11991: LD_STRING DStart-JMM-Bur-2
11993: PPUSH
11994: CALL_OW 88
// InGameOff ;
11998: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
12002: LD_STRING MStart
12004: PPUSH
12005: CALL_OW 337
// SaveForQuickRestart ;
12009: CALL_OW 22
// end ;
12013: LD_VAR 0 1
12017: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
12018: LD_INT 7
12020: PPUSH
12021: LD_INT 255
12023: PPUSH
12024: LD_INT 219
12026: PPUSH
12027: CALL_OW 293
12031: IFFALSE 12640
12033: GO 12035
12035: DISABLE
12036: LD_INT 0
12038: PPUSH
// begin wait ( 0 0$3 ) ;
12039: LD_INT 105
12041: PPUSH
12042: CALL_OW 67
// alienSpotted := true ;
12046: LD_ADDR_EXP 10
12050: PUSH
12051: LD_INT 1
12053: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12054: LD_ADDR_VAR 0 1
12058: PUSH
12059: LD_INT 22
12061: PUSH
12062: LD_INT 7
12064: PUSH
12065: EMPTY
12066: LIST
12067: LIST
12068: PUSH
12069: LD_INT 23
12071: PUSH
12072: LD_INT 3
12074: PUSH
12075: EMPTY
12076: LIST
12077: LIST
12078: PUSH
12079: LD_INT 21
12081: PUSH
12082: LD_INT 1
12084: PUSH
12085: EMPTY
12086: LIST
12087: LIST
12088: PUSH
12089: LD_INT 26
12091: PUSH
12092: LD_INT 1
12094: PUSH
12095: EMPTY
12096: LIST
12097: LIST
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: LIST
12103: LIST
12104: PPUSH
12105: CALL_OW 69
12109: PUSH
12110: LD_EXP 52
12114: PUSH
12115: LD_EXP 40
12119: PUSH
12120: LD_EXP 42
12124: PUSH
12125: LD_EXP 43
12129: PUSH
12130: LD_EXP 50
12134: PUSH
12135: LD_EXP 49
12139: PUSH
12140: LD_EXP 44
12144: PUSH
12145: EMPTY
12146: LIST
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: LIST
12153: DIFF
12154: ST_TO_ADDR
// DialogueOn ;
12155: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12159: LD_INT 255
12161: PPUSH
12162: LD_INT 219
12164: PPUSH
12165: LD_INT 7
12167: PPUSH
12168: LD_INT 20
12170: NEG
12171: PPUSH
12172: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12176: LD_INT 255
12178: PPUSH
12179: LD_INT 219
12181: PPUSH
12182: CALL_OW 86
// if speaker then
12186: LD_VAR 0 1
12190: IFFALSE 12208
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12192: LD_VAR 0 1
12196: PUSH
12197: LD_INT 1
12199: ARRAY
12200: PPUSH
12201: LD_STRING DAlienBase-RSol1-1
12203: PPUSH
12204: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12208: LD_EXP 19
12212: PPUSH
12213: LD_STRING DAlienBase-JMM-1
12215: PPUSH
12216: CALL_OW 88
// if IsOk ( Burlak ) then
12220: LD_EXP 52
12224: PPUSH
12225: CALL_OW 302
12229: IFFALSE 12250
// begin dwait ( 0 0$1 ) ;
12231: LD_INT 35
12233: PPUSH
12234: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12238: LD_EXP 52
12242: PPUSH
12243: LD_STRING DAlienBase-Bur-1
12245: PPUSH
12246: CALL_OW 88
// end ; if IsOk ( Roth ) then
12250: LD_EXP 20
12254: PPUSH
12255: CALL_OW 302
12259: IFFALSE 12273
// Say ( Roth , DAlienBase-Roth-1 ) ;
12261: LD_EXP 20
12265: PPUSH
12266: LD_STRING DAlienBase-Roth-1
12268: PPUSH
12269: CALL_OW 88
// if IsOk ( Gossudarov ) then
12273: LD_EXP 38
12277: PPUSH
12278: CALL_OW 302
12282: IFFALSE 12298
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12284: LD_EXP 38
12288: PPUSH
12289: LD_STRING DAlienBase-Gos-1
12291: PPUSH
12292: CALL_OW 88
12296: GO 12415
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12298: LD_ADDR_VAR 0 1
12302: PUSH
12303: LD_INT 22
12305: PUSH
12306: LD_INT 7
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PUSH
12313: LD_INT 25
12315: PUSH
12316: LD_INT 4
12318: PUSH
12319: EMPTY
12320: LIST
12321: LIST
12322: PUSH
12323: LD_INT 21
12325: PUSH
12326: LD_INT 1
12328: PUSH
12329: EMPTY
12330: LIST
12331: LIST
12332: PUSH
12333: LD_INT 26
12335: PUSH
12336: LD_INT 1
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: LIST
12347: LIST
12348: PPUSH
12349: CALL_OW 69
12353: PUSH
12354: LD_EXP 20
12358: PUSH
12359: LD_EXP 19
12363: PUSH
12364: LD_EXP 52
12368: PUSH
12369: LD_EXP 40
12373: PUSH
12374: LD_EXP 50
12378: PUSH
12379: LD_EXP 49
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: DIFF
12392: ST_TO_ADDR
// if speaker then
12393: LD_VAR 0 1
12397: IFFALSE 12415
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12399: LD_VAR 0 1
12403: PUSH
12404: LD_INT 1
12406: ARRAY
12407: PPUSH
12408: LD_STRING DAlienBase-Sci1-1
12410: PPUSH
12411: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12415: LD_INT 255
12417: PPUSH
12418: LD_INT 219
12420: PPUSH
12421: LD_INT 7
12423: PPUSH
12424: CALL_OW 331
// DialogueOff ;
12428: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12432: LD_INT 35
12434: PPUSH
12435: CALL_OW 67
// until IsSelected ( alien ) ;
12439: LD_INT 1
12441: PPUSH
12442: CALL_OW 306
12446: IFFALSE 12432
// if not artifactIResearched or not artifactIIResearched then
12448: LD_EXP 12
12452: NOT
12453: PUSH
12454: LD_EXP 13
12458: NOT
12459: OR
12460: IFFALSE 12640
// begin if IsOk ( Roth ) then
12462: LD_EXP 20
12466: PPUSH
12467: CALL_OW 302
12471: IFFALSE 12487
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12473: LD_EXP 20
12477: PPUSH
12478: LD_STRING DAlieBaseNotReady-Roth-1
12480: PPUSH
12481: CALL_OW 88
12485: GO 12640
// if IsOk ( Gossudarov ) then
12487: LD_EXP 38
12491: PPUSH
12492: CALL_OW 302
12496: IFFALSE 12512
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12498: LD_EXP 38
12502: PPUSH
12503: LD_STRING DAlieBaseNotReady-Gos-1
12505: PPUSH
12506: CALL_OW 88
12510: GO 12640
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12512: LD_ADDR_VAR 0 1
12516: PUSH
12517: LD_INT 22
12519: PUSH
12520: LD_INT 7
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PUSH
12527: LD_INT 23
12529: PUSH
12530: LD_INT 3
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: PUSH
12537: LD_INT 25
12539: PUSH
12540: LD_INT 4
12542: PUSH
12543: EMPTY
12544: LIST
12545: LIST
12546: PUSH
12547: LD_INT 21
12549: PUSH
12550: LD_INT 1
12552: PUSH
12553: EMPTY
12554: LIST
12555: LIST
12556: PUSH
12557: LD_INT 26
12559: PUSH
12560: LD_INT 1
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: LIST
12571: LIST
12572: LIST
12573: PPUSH
12574: CALL_OW 69
12578: PUSH
12579: LD_EXP 20
12583: PUSH
12584: LD_EXP 19
12588: PUSH
12589: LD_EXP 52
12593: PUSH
12594: LD_EXP 40
12598: PUSH
12599: LD_EXP 50
12603: PUSH
12604: LD_EXP 49
12608: PUSH
12609: EMPTY
12610: LIST
12611: LIST
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: DIFF
12617: ST_TO_ADDR
// if speaker then
12618: LD_VAR 0 1
12622: IFFALSE 12640
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12624: LD_VAR 0 1
12628: PUSH
12629: LD_INT 1
12631: ARRAY
12632: PPUSH
12633: LD_STRING DAlieBaseNotReady-RSci1-1
12635: PPUSH
12636: CALL_OW 88
// end ; end ; end ;
12640: PPOPN 1
12642: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12643: LD_INT 24
12645: PPUSH
12646: LD_INT 7
12648: PPUSH
12649: CALL_OW 321
12653: PUSH
12654: LD_INT 2
12656: EQUAL
12657: IFFALSE 13348
12659: GO 12661
12661: DISABLE
12662: LD_INT 0
12664: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12665: LD_ADDR_VAR 0 1
12669: PUSH
12670: LD_INT 22
12672: PUSH
12673: LD_INT 7
12675: PUSH
12676: EMPTY
12677: LIST
12678: LIST
12679: PUSH
12680: LD_INT 23
12682: PUSH
12683: LD_INT 3
12685: PUSH
12686: EMPTY
12687: LIST
12688: LIST
12689: PUSH
12690: LD_INT 25
12692: PUSH
12693: LD_INT 4
12695: PUSH
12696: EMPTY
12697: LIST
12698: LIST
12699: PUSH
12700: LD_INT 21
12702: PUSH
12703: LD_INT 1
12705: PUSH
12706: EMPTY
12707: LIST
12708: LIST
12709: PUSH
12710: LD_INT 26
12712: PUSH
12713: LD_INT 1
12715: PUSH
12716: EMPTY
12717: LIST
12718: LIST
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: PPUSH
12727: CALL_OW 69
12731: PUSH
12732: LD_EXP 20
12736: PUSH
12737: LD_EXP 19
12741: PUSH
12742: LD_EXP 52
12746: PUSH
12747: LD_EXP 40
12751: PUSH
12752: LD_EXP 50
12756: PUSH
12757: LD_EXP 49
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: DIFF
12770: ST_TO_ADDR
// if not speaker then
12771: LD_VAR 0 1
12775: NOT
12776: IFFALSE 12780
// exit ;
12778: GO 13348
// DialogueOn ;
12780: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12784: LD_VAR 0 1
12788: PUSH
12789: LD_INT 1
12791: ARRAY
12792: PPUSH
12793: LD_STRING DArtefTechnology-RSci1-1
12795: PPUSH
12796: CALL_OW 88
// if IsOk ( Burlak ) then
12800: LD_EXP 52
12804: PPUSH
12805: CALL_OW 302
12809: IFFALSE 12823
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12811: LD_EXP 52
12815: PPUSH
12816: LD_STRING DArtefTechnology-Bur-1
12818: PPUSH
12819: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12823: LD_VAR 0 1
12827: PUSH
12828: LD_INT 1
12830: ARRAY
12831: PPUSH
12832: LD_STRING DArtefTechnology-RSci1-2
12834: PPUSH
12835: CALL_OW 88
// if Denis then
12839: LD_EXP 25
12843: IFFALSE 12860
// speaker := [ Denis ] else
12845: LD_ADDR_VAR 0 1
12849: PUSH
12850: LD_EXP 25
12854: PUSH
12855: EMPTY
12856: LIST
12857: ST_TO_ADDR
12858: GO 12966
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12860: LD_ADDR_VAR 0 1
12864: PUSH
12865: LD_INT 22
12867: PUSH
12868: LD_INT 7
12870: PUSH
12871: EMPTY
12872: LIST
12873: LIST
12874: PUSH
12875: LD_INT 23
12877: PUSH
12878: LD_INT 1
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: PUSH
12885: LD_INT 25
12887: PUSH
12888: LD_INT 4
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: PUSH
12895: LD_INT 21
12897: PUSH
12898: LD_INT 1
12900: PUSH
12901: EMPTY
12902: LIST
12903: LIST
12904: PUSH
12905: LD_INT 26
12907: PUSH
12908: LD_INT 1
12910: PUSH
12911: EMPTY
12912: LIST
12913: LIST
12914: PUSH
12915: EMPTY
12916: LIST
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: PPUSH
12922: CALL_OW 69
12926: PUSH
12927: LD_EXP 20
12931: PUSH
12932: LD_EXP 19
12936: PUSH
12937: LD_EXP 52
12941: PUSH
12942: LD_EXP 40
12946: PUSH
12947: LD_EXP 50
12951: PUSH
12952: LD_EXP 49
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: DIFF
12965: ST_TO_ADDR
// if speaker then
12966: LD_VAR 0 1
12970: IFFALSE 12988
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12972: LD_VAR 0 1
12976: PUSH
12977: LD_INT 1
12979: ARRAY
12980: PPUSH
12981: LD_STRING DArtefTechnology-Sci1-2
12983: PPUSH
12984: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12988: LD_ADDR_VAR 0 1
12992: PUSH
12993: LD_INT 22
12995: PUSH
12996: LD_INT 7
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: LD_INT 23
13005: PUSH
13006: LD_INT 3
13008: PUSH
13009: EMPTY
13010: LIST
13011: LIST
13012: PUSH
13013: LD_INT 25
13015: PUSH
13016: LD_INT 4
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PUSH
13023: LD_INT 21
13025: PUSH
13026: LD_INT 1
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: PUSH
13033: LD_INT 26
13035: PUSH
13036: LD_INT 1
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: LIST
13047: LIST
13048: LIST
13049: PPUSH
13050: CALL_OW 69
13054: PUSH
13055: LD_EXP 20
13059: PUSH
13060: LD_EXP 19
13064: PUSH
13065: LD_EXP 52
13069: PUSH
13070: LD_EXP 40
13074: PUSH
13075: LD_EXP 50
13079: PUSH
13080: LD_EXP 49
13084: PUSH
13085: EMPTY
13086: LIST
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: LIST
13092: DIFF
13093: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13094: LD_VAR 0 1
13098: PUSH
13099: LD_EXP 9
13103: PUSH
13104: LD_EXP 5
13108: OR
13109: AND
13110: IFFALSE 13344
// begin if arabianDestroyed and IsOk ( Burlak ) then
13112: LD_EXP 5
13116: PUSH
13117: LD_EXP 52
13121: PPUSH
13122: CALL_OW 302
13126: AND
13127: IFFALSE 13143
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13129: LD_EXP 52
13133: PPUSH
13134: LD_STRING DArtefTechnology-Bur-2
13136: PPUSH
13137: CALL_OW 88
13141: GO 13155
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13143: LD_EXP 19
13147: PPUSH
13148: LD_STRING DArtefTechnology-JMM-2
13150: PPUSH
13151: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13155: LD_VAR 0 1
13159: PUSH
13160: LD_INT 1
13162: ARRAY
13163: PPUSH
13164: LD_STRING DArtefTechnology-RSci1-3
13166: PPUSH
13167: CALL_OW 88
// if Denis then
13171: LD_EXP 25
13175: IFFALSE 13192
// speaker := [ Denis ] else
13177: LD_ADDR_VAR 0 1
13181: PUSH
13182: LD_EXP 25
13186: PUSH
13187: EMPTY
13188: LIST
13189: ST_TO_ADDR
13190: GO 13298
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13192: LD_ADDR_VAR 0 1
13196: PUSH
13197: LD_INT 22
13199: PUSH
13200: LD_INT 7
13202: PUSH
13203: EMPTY
13204: LIST
13205: LIST
13206: PUSH
13207: LD_INT 23
13209: PUSH
13210: LD_INT 1
13212: PUSH
13213: EMPTY
13214: LIST
13215: LIST
13216: PUSH
13217: LD_INT 25
13219: PUSH
13220: LD_INT 4
13222: PUSH
13223: EMPTY
13224: LIST
13225: LIST
13226: PUSH
13227: LD_INT 21
13229: PUSH
13230: LD_INT 1
13232: PUSH
13233: EMPTY
13234: LIST
13235: LIST
13236: PUSH
13237: LD_INT 26
13239: PUSH
13240: LD_INT 1
13242: PUSH
13243: EMPTY
13244: LIST
13245: LIST
13246: PUSH
13247: EMPTY
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: PPUSH
13254: CALL_OW 69
13258: PUSH
13259: LD_EXP 20
13263: PUSH
13264: LD_EXP 19
13268: PUSH
13269: LD_EXP 52
13273: PUSH
13274: LD_EXP 40
13278: PUSH
13279: LD_EXP 50
13283: PUSH
13284: LD_EXP 49
13288: PUSH
13289: EMPTY
13290: LIST
13291: LIST
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: DIFF
13297: ST_TO_ADDR
// if speaker then
13298: LD_VAR 0 1
13302: IFFALSE 13344
// if alienSpotted then
13304: LD_EXP 10
13308: IFFALSE 13328
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13310: LD_VAR 0 1
13314: PUSH
13315: LD_INT 1
13317: ARRAY
13318: PPUSH
13319: LD_STRING DArtefTechnology-Sci1-3
13321: PPUSH
13322: CALL_OW 88
13326: GO 13344
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13328: LD_VAR 0 1
13332: PUSH
13333: LD_INT 1
13335: ARRAY
13336: PPUSH
13337: LD_STRING DArtefTechnology-Sci1-3a
13339: PPUSH
13340: CALL_OW 88
// end ; DialogueOff ;
13344: CALL_OW 7
// end ;
13348: PPOPN 1
13350: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13351: LD_EXP 12
13355: IFFALSE 13558
13357: GO 13359
13359: DISABLE
13360: LD_INT 0
13362: PPUSH
// begin if Denis then
13363: LD_EXP 25
13367: IFFALSE 13384
// speaker := [ Denis ] else
13369: LD_ADDR_VAR 0 1
13373: PUSH
13374: LD_EXP 25
13378: PUSH
13379: EMPTY
13380: LIST
13381: ST_TO_ADDR
13382: GO 13490
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13384: LD_ADDR_VAR 0 1
13388: PUSH
13389: LD_INT 22
13391: PUSH
13392: LD_INT 7
13394: PUSH
13395: EMPTY
13396: LIST
13397: LIST
13398: PUSH
13399: LD_INT 23
13401: PUSH
13402: LD_INT 1
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PUSH
13409: LD_INT 25
13411: PUSH
13412: LD_INT 4
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: LD_INT 21
13421: PUSH
13422: LD_INT 1
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PUSH
13429: LD_INT 26
13431: PUSH
13432: LD_INT 1
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: PPUSH
13446: CALL_OW 69
13450: PUSH
13451: LD_EXP 20
13455: PUSH
13456: LD_EXP 19
13460: PUSH
13461: LD_EXP 52
13465: PUSH
13466: LD_EXP 40
13470: PUSH
13471: LD_EXP 50
13475: PUSH
13476: LD_EXP 49
13480: PUSH
13481: EMPTY
13482: LIST
13483: LIST
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: DIFF
13489: ST_TO_ADDR
// if not speaker then
13490: LD_VAR 0 1
13494: NOT
13495: IFFALSE 13499
// exit ;
13497: GO 13558
// DialogueOn ;
13499: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13503: LD_VAR 0 1
13507: PUSH
13508: LD_INT 1
13510: ARRAY
13511: PPUSH
13512: LD_STRING DArtefTechnologyAm-Sci1-1
13514: PPUSH
13515: CALL_OW 88
// if IsOk ( Burlak ) then
13519: LD_EXP 52
13523: PPUSH
13524: CALL_OW 302
13528: IFFALSE 13542
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13530: LD_EXP 52
13534: PPUSH
13535: LD_STRING DArtefTechnologyAm-Bur-1
13537: PPUSH
13538: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13542: LD_EXP 19
13546: PPUSH
13547: LD_STRING DArtefTechnologyAm-JMM-1
13549: PPUSH
13550: CALL_OW 88
// DialogueOff ;
13554: CALL_OW 7
// end ;
13558: PPOPN 1
13560: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13561: LD_EXP 13
13565: IFFALSE 13767
13567: GO 13569
13569: DISABLE
13570: LD_INT 0
13572: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13573: LD_ADDR_VAR 0 1
13577: PUSH
13578: LD_INT 22
13580: PUSH
13581: LD_INT 7
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: PUSH
13588: LD_INT 23
13590: PUSH
13591: LD_INT 3
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 25
13600: PUSH
13601: LD_INT 4
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: LD_INT 21
13610: PUSH
13611: LD_INT 1
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PUSH
13618: LD_INT 26
13620: PUSH
13621: LD_INT 1
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: EMPTY
13629: LIST
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 69
13639: PUSH
13640: LD_EXP 20
13644: PUSH
13645: LD_EXP 19
13649: PUSH
13650: LD_EXP 52
13654: PUSH
13655: LD_EXP 40
13659: PUSH
13660: LD_EXP 50
13664: PUSH
13665: LD_EXP 49
13669: PUSH
13670: EMPTY
13671: LIST
13672: LIST
13673: LIST
13674: LIST
13675: LIST
13676: LIST
13677: DIFF
13678: ST_TO_ADDR
// if not speaker then
13679: LD_VAR 0 1
13683: NOT
13684: IFFALSE 13688
// exit ;
13686: GO 13767
// DialogueOn ;
13688: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13692: LD_VAR 0 1
13696: PUSH
13697: LD_VAR 0 1
13701: ARRAY
13702: PPUSH
13703: LD_STRING DArtefTechnologyRu-RSci1-1
13705: PPUSH
13706: CALL_OW 88
// if IsOk ( Burlak ) then
13710: LD_EXP 52
13714: PPUSH
13715: CALL_OW 302
13719: IFFALSE 13733
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13721: LD_EXP 52
13725: PPUSH
13726: LD_STRING DArtefTechnologyRu-Bur-1
13728: PPUSH
13729: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13733: LD_VAR 0 1
13737: PUSH
13738: LD_VAR 0 1
13742: ARRAY
13743: PPUSH
13744: LD_STRING DArtefTechnologyRu-RSci1-2
13746: PPUSH
13747: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13751: LD_EXP 19
13755: PPUSH
13756: LD_STRING DArtefTechnologyRu-JMM-1
13758: PPUSH
13759: CALL_OW 88
// DialogueOff ;
13763: CALL_OW 7
// end ;
13767: PPOPN 1
13769: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13770: LD_INT 24
13772: PPUSH
13773: LD_INT 7
13775: PPUSH
13776: CALL_OW 321
13780: PUSH
13781: LD_INT 2
13783: EQUAL
13784: PUSH
13785: LD_INT 1
13787: PPUSH
13788: CALL_OW 255
13792: PUSH
13793: LD_INT 7
13795: EQUAL
13796: AND
13797: IFFALSE 13965
13799: GO 13801
13801: DISABLE
13802: LD_INT 0
13804: PPUSH
// begin if Denis then
13805: LD_EXP 25
13809: IFFALSE 13826
// speaker := [ Denis ] else
13811: LD_ADDR_VAR 0 1
13815: PUSH
13816: LD_EXP 25
13820: PUSH
13821: EMPTY
13822: LIST
13823: ST_TO_ADDR
13824: GO 13932
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13826: LD_ADDR_VAR 0 1
13830: PUSH
13831: LD_INT 22
13833: PUSH
13834: LD_INT 7
13836: PUSH
13837: EMPTY
13838: LIST
13839: LIST
13840: PUSH
13841: LD_INT 23
13843: PUSH
13844: LD_INT 1
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: PUSH
13851: LD_INT 25
13853: PUSH
13854: LD_INT 4
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: PUSH
13861: LD_INT 21
13863: PUSH
13864: LD_INT 1
13866: PUSH
13867: EMPTY
13868: LIST
13869: LIST
13870: PUSH
13871: LD_INT 26
13873: PUSH
13874: LD_INT 1
13876: PUSH
13877: EMPTY
13878: LIST
13879: LIST
13880: PUSH
13881: EMPTY
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: PPUSH
13888: CALL_OW 69
13892: PUSH
13893: LD_EXP 20
13897: PUSH
13898: LD_EXP 19
13902: PUSH
13903: LD_EXP 52
13907: PUSH
13908: LD_EXP 40
13912: PUSH
13913: LD_EXP 50
13917: PUSH
13918: LD_EXP 49
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: DIFF
13931: ST_TO_ADDR
// if not speaker then
13932: LD_VAR 0 1
13936: NOT
13937: IFFALSE 13941
// exit ;
13939: GO 13965
// DialogueOn ;
13941: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13945: LD_VAR 0 1
13949: PUSH
13950: LD_INT 1
13952: ARRAY
13953: PPUSH
13954: LD_STRING DArtefTechnologyArStart-Sci1-1
13956: PPUSH
13957: CALL_OW 88
// DialogueOff ;
13961: CALL_OW 7
// end ;
13965: PPOPN 1
13967: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13968: LD_EXP 14
13972: IFFALSE 14253
13974: GO 13976
13976: DISABLE
13977: LD_INT 0
13979: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13980: LD_ADDR_VAR 0 1
13984: PUSH
13985: LD_INT 22
13987: PUSH
13988: LD_INT 7
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: PUSH
13995: LD_INT 23
13997: PUSH
13998: LD_INT 3
14000: PUSH
14001: EMPTY
14002: LIST
14003: LIST
14004: PUSH
14005: LD_INT 25
14007: PUSH
14008: LD_INT 4
14010: PUSH
14011: EMPTY
14012: LIST
14013: LIST
14014: PUSH
14015: LD_INT 21
14017: PUSH
14018: LD_INT 1
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: PUSH
14025: LD_INT 26
14027: PUSH
14028: LD_INT 1
14030: PUSH
14031: EMPTY
14032: LIST
14033: LIST
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: PPUSH
14042: CALL_OW 69
14046: PUSH
14047: LD_EXP 20
14051: PUSH
14052: LD_EXP 19
14056: PUSH
14057: LD_EXP 52
14061: PUSH
14062: LD_EXP 40
14066: PUSH
14067: LD_EXP 50
14071: PUSH
14072: LD_EXP 49
14076: PUSH
14077: EMPTY
14078: LIST
14079: LIST
14080: LIST
14081: LIST
14082: LIST
14083: LIST
14084: DIFF
14085: ST_TO_ADDR
// if not speaker then
14086: LD_VAR 0 1
14090: NOT
14091: IFFALSE 14095
// exit ;
14093: GO 14253
// DialogueOn ;
14095: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14099: LD_VAR 0 1
14103: PUSH
14104: LD_INT 1
14106: ARRAY
14107: PPUSH
14108: LD_STRING DArtefTechnologyAr-RSci1-1
14110: PPUSH
14111: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14115: LD_EXP 19
14119: PPUSH
14120: LD_STRING DArtefTechnologyAr-JMM-1
14122: PPUSH
14123: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14127: LD_VAR 0 1
14131: PUSH
14132: LD_INT 1
14134: ARRAY
14135: PPUSH
14136: LD_STRING DArtefTechnologyAr-RSci1-2
14138: PPUSH
14139: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14143: LD_EXP 19
14147: PPUSH
14148: LD_STRING DArtefTechnologyAr-JMM-2
14150: PPUSH
14151: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14155: LD_VAR 0 1
14159: PUSH
14160: LD_INT 1
14162: ARRAY
14163: PPUSH
14164: LD_STRING DArtefTechnologyAr-RSci1-3
14166: PPUSH
14167: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14171: LD_EXP 19
14175: PPUSH
14176: LD_STRING DArtefTechnologyAr-JMM-3
14178: PPUSH
14179: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14183: LD_VAR 0 1
14187: PUSH
14188: LD_INT 1
14190: ARRAY
14191: PPUSH
14192: LD_STRING DArtefTechnologyAr-RSci1-4
14194: PPUSH
14195: CALL_OW 88
// if IsOk ( Burlak ) then
14199: LD_EXP 52
14203: PPUSH
14204: CALL_OW 302
14208: IFFALSE 14222
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14210: LD_EXP 52
14214: PPUSH
14215: LD_STRING DArtefTechnologyAr-Bur-4
14217: PPUSH
14218: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14222: LD_EXP 19
14226: PPUSH
14227: LD_STRING DArtefTechnologyAr-JMM-4
14229: PPUSH
14230: CALL_OW 88
// DialogueOff ;
14234: CALL_OW 7
// wait ( 0 0$45 ) ;
14238: LD_INT 1575
14240: PPUSH
14241: CALL_OW 67
// spawnOmar := true ;
14245: LD_ADDR_EXP 11
14249: PUSH
14250: LD_INT 1
14252: ST_TO_ADDR
// end ;
14253: PPOPN 1
14255: END
// every 0 0$1 trigger spawnOmar do
14256: LD_EXP 11
14260: IFFALSE 14640
14262: GO 14264
14264: DISABLE
// begin PrepareOmarAli ;
14265: CALL 7409 0 0
// if not HasTask ( Omar ) then
14269: LD_EXP 56
14273: PPUSH
14274: CALL_OW 314
14278: NOT
14279: IFFALSE 14296
// ComMoveXY ( Omar , 252 , 220 ) ;
14281: LD_EXP 56
14285: PPUSH
14286: LD_INT 252
14288: PPUSH
14289: LD_INT 220
14291: PPUSH
14292: CALL_OW 111
// if not Omar then
14296: LD_EXP 56
14300: NOT
14301: IFFALSE 14305
// exit ;
14303: GO 14640
// repeat wait ( 0 0$1 ) ;
14305: LD_INT 35
14307: PPUSH
14308: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14312: LD_EXP 56
14316: PPUSH
14317: CALL_OW 314
14321: NOT
14322: PUSH
14323: LD_EXP 56
14327: PPUSH
14328: LD_INT 252
14330: PPUSH
14331: LD_INT 220
14333: PPUSH
14334: CALL_OW 297
14338: PUSH
14339: LD_INT 6
14341: GREATER
14342: AND
14343: IFFALSE 14360
// ComMoveXY ( Omar , 252 , 220 ) ;
14345: LD_EXP 56
14349: PPUSH
14350: LD_INT 252
14352: PPUSH
14353: LD_INT 220
14355: PPUSH
14356: CALL_OW 111
// until See ( 7 , Omar ) ;
14360: LD_INT 7
14362: PPUSH
14363: LD_EXP 56
14367: PPUSH
14368: CALL_OW 292
14372: IFFALSE 14305
// CenterNowOnUnits ( Omar ) ;
14374: LD_EXP 56
14378: PPUSH
14379: CALL_OW 87
// DialogueOn ;
14383: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14387: LD_EXP 56
14391: PPUSH
14392: LD_STRING DOmar-Omar-1
14394: PPUSH
14395: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14399: LD_EXP 19
14403: PPUSH
14404: LD_STRING DOmar-JMM-1
14406: PPUSH
14407: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14411: LD_EXP 56
14415: PPUSH
14416: LD_STRING DOmar-Omar-2
14418: PPUSH
14419: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14423: LD_EXP 19
14427: PPUSH
14428: LD_STRING DOmar-JMM-2
14430: PPUSH
14431: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14435: LD_EXP 56
14439: PPUSH
14440: LD_STRING DOmar-Omar-3
14442: PPUSH
14443: CALL_OW 88
// if IsOk ( Burlak ) then
14447: LD_EXP 52
14451: PPUSH
14452: CALL_OW 302
14456: IFFALSE 14472
// Say ( Burlak , DOmar-Bur-3 ) else
14458: LD_EXP 52
14462: PPUSH
14463: LD_STRING DOmar-Bur-3
14465: PPUSH
14466: CALL_OW 88
14470: GO 14484
// Say ( JMM , DOmar-JMM-3 ) ;
14472: LD_EXP 19
14476: PPUSH
14477: LD_STRING DOmar-JMM-3
14479: PPUSH
14480: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14484: LD_EXP 56
14488: PPUSH
14489: LD_STRING DOmar-Omar-4
14491: PPUSH
14492: CALL_OW 88
// case Query ( QAccept ) of 1 :
14496: LD_STRING QAccept
14498: PPUSH
14499: CALL_OW 97
14503: PUSH
14504: LD_INT 1
14506: DOUBLE
14507: EQUAL
14508: IFTRUE 14512
14510: GO 14548
14512: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14513: LD_EXP 19
14517: PPUSH
14518: LD_STRING DQrAccept#1-JMM-1
14520: PPUSH
14521: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14525: LD_EXP 56
14529: PPUSH
14530: LD_INT 7
14532: PPUSH
14533: CALL_OW 235
// ComStop ( Omar ) ;
14537: LD_EXP 56
14541: PPUSH
14542: CALL_OW 141
// end ; 2 :
14546: GO 14597
14548: LD_INT 2
14550: DOUBLE
14551: EQUAL
14552: IFTRUE 14556
14554: GO 14596
14556: POP
// begin if IsOk ( Burlak ) then
14557: LD_EXP 52
14561: PPUSH
14562: CALL_OW 302
14566: IFFALSE 14582
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14568: LD_EXP 52
14572: PPUSH
14573: LD_STRING DQrAccept#2-Bur-1
14575: PPUSH
14576: CALL_OW 88
14580: GO 14594
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14582: LD_EXP 19
14586: PPUSH
14587: LD_STRING DQrAccept#2-JMM-1
14589: PPUSH
14590: CALL_OW 88
// end ; end ;
14594: GO 14597
14596: POP
// DialogueOff ;
14597: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14601: LD_EXP 56
14605: PPUSH
14606: CALL_OW 255
14610: PUSH
14611: LD_INT 7
14613: EQUAL
14614: IFFALSE 14625
// begin SetAchievement ( ACH_OMAR ) ;
14616: LD_STRING ACH_OMAR
14618: PPUSH
14619: CALL_OW 543
// exit ;
14623: GO 14640
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14625: LD_EXP 56
14629: PPUSH
14630: LD_INT 202
14632: PPUSH
14633: LD_INT 115
14635: PPUSH
14636: CALL_OW 111
// end ;
14640: END
// every 0 0$1 trigger IsOk ( Omar ) and russianDestroyed do var i ;
14641: LD_EXP 56
14645: PPUSH
14646: CALL_OW 302
14650: PUSH
14651: LD_EXP 2
14655: AND
14656: IFFALSE 15141
14658: GO 14660
14660: DISABLE
14661: LD_INT 0
14663: PPUSH
// begin SetSide ( Omar , 5 ) ;
14664: LD_EXP 56
14668: PPUSH
14669: LD_INT 5
14671: PPUSH
14672: CALL_OW 235
// if IsInUnit ( Omar ) then
14676: LD_EXP 56
14680: PPUSH
14681: CALL_OW 310
14685: IFFALSE 14696
// ComExitVehicle ( Omar ) ;
14687: LD_EXP 56
14691: PPUSH
14692: CALL_OW 121
// if IsInUnit ( Omar ) then
14696: LD_EXP 56
14700: PPUSH
14701: CALL_OW 310
14705: IFFALSE 14716
// ComExitBuilding ( Omar ) ;
14707: LD_EXP 56
14711: PPUSH
14712: CALL_OW 122
// wait ( 0 0$1 ) ;
14716: LD_INT 35
14718: PPUSH
14719: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14723: LD_EXP 56
14727: PPUSH
14728: LD_INT 203
14730: PPUSH
14731: LD_INT 120
14733: PPUSH
14734: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14738: LD_INT 35
14740: PPUSH
14741: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
14745: LD_EXP 56
14749: PPUSH
14750: CALL_OW 306
14754: PUSH
14755: LD_EXP 56
14759: PPUSH
14760: LD_INT 203
14762: PPUSH
14763: LD_INT 120
14765: PPUSH
14766: CALL_OW 297
14770: PUSH
14771: LD_INT 20
14773: LESS
14774: OR
14775: IFFALSE 14738
// DialogueOn ;
14777: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
14781: LD_EXP 56
14785: PPUSH
14786: CALL_OW 250
14790: PPUSH
14791: LD_EXP 56
14795: PPUSH
14796: CALL_OW 251
14800: PPUSH
14801: LD_INT 7
14803: PPUSH
14804: LD_INT 6
14806: NEG
14807: PPUSH
14808: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
14812: LD_EXP 56
14816: PPUSH
14817: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
14821: LD_EXP 19
14825: PPUSH
14826: LD_STRING DOmarContam-JMM-1
14828: PPUSH
14829: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14833: LD_EXP 56
14837: PPUSH
14838: LD_STRING DOmarContam-Omar-1
14840: PPUSH
14841: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14845: LD_EXP 19
14849: PPUSH
14850: LD_STRING DOmarContam-JMM-2
14852: PPUSH
14853: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
14857: LD_EXP 56
14861: PPUSH
14862: CALL_OW 250
14866: PPUSH
14867: LD_EXP 56
14871: PPUSH
14872: CALL_OW 251
14876: PPUSH
14877: LD_INT 7
14879: PPUSH
14880: CALL_OW 331
// DialogueOff ;
14884: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14888: LD_INT 5
14890: PPUSH
14891: LD_INT 7
14893: PPUSH
14894: LD_INT 2
14896: PPUSH
14897: LD_INT 1
14899: PPUSH
14900: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14904: LD_INT 105
14906: PPUSH
14907: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14911: LD_EXP 56
14915: PPUSH
14916: LD_INT 203
14918: PPUSH
14919: LD_INT 120
14921: PPUSH
14922: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
14926: LD_EXP 56
14930: PPUSH
14931: LD_INT 203
14933: PPUSH
14934: LD_INT 120
14936: PPUSH
14937: CALL_OW 307
14941: IFFALSE 14904
// ComHold ( Omar ) ;
14943: LD_EXP 56
14947: PPUSH
14948: CALL_OW 140
// InGameOn ;
14952: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
14956: LD_INT 203
14958: PPUSH
14959: LD_INT 120
14961: PPUSH
14962: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
14966: LD_INT 203
14968: PPUSH
14969: LD_INT 120
14971: PPUSH
14972: LD_INT 7
14974: PPUSH
14975: LD_INT 30
14977: NEG
14978: PPUSH
14979: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
14983: LD_ADDR_VAR 0 1
14987: PUSH
14988: LD_INT 203
14990: PUSH
14991: LD_INT 120
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: PUSH
14998: LD_INT 202
15000: PUSH
15001: LD_INT 125
15003: PUSH
15004: EMPTY
15005: LIST
15006: LIST
15007: PUSH
15008: LD_INT 195
15010: PUSH
15011: LD_INT 117
15013: PUSH
15014: EMPTY
15015: LIST
15016: LIST
15017: PUSH
15018: LD_INT 216
15020: PUSH
15021: LD_INT 123
15023: PUSH
15024: EMPTY
15025: LIST
15026: LIST
15027: PUSH
15028: LD_INT 224
15030: PUSH
15031: LD_INT 131
15033: PUSH
15034: EMPTY
15035: LIST
15036: LIST
15037: PUSH
15038: LD_INT 212
15040: PUSH
15041: LD_INT 133
15043: PUSH
15044: EMPTY
15045: LIST
15046: LIST
15047: PUSH
15048: EMPTY
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: PUSH
15056: FOR_IN
15057: IFFALSE 15093
// begin wait ( 0 0$0.5 ) ;
15059: LD_INT 18
15061: PPUSH
15062: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15066: LD_VAR 0 1
15070: PUSH
15071: LD_INT 1
15073: ARRAY
15074: PPUSH
15075: LD_VAR 0 1
15079: PUSH
15080: LD_INT 2
15082: ARRAY
15083: PPUSH
15084: LD_INT 5
15086: PPUSH
15087: CALL_OW 495
// end ;
15091: GO 15056
15093: POP
15094: POP
// KillUnit ( Omar ) ;
15095: LD_EXP 56
15099: PPUSH
15100: CALL_OW 66
// wait ( 0 0$3 ) ;
15104: LD_INT 105
15106: PPUSH
15107: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15111: LD_EXP 19
15115: PPUSH
15116: LD_STRING D16b-JMM-1
15118: PPUSH
15119: CALL_OW 91
// wait ( 0 0$2 ) ;
15123: LD_INT 70
15125: PPUSH
15126: CALL_OW 67
// InGameOff ;
15130: CALL_OW 9
// YouLost ( MothContaminate ) ;
15134: LD_STRING MothContaminate
15136: PPUSH
15137: CALL_OW 104
// end ;
15141: PPOPN 1
15143: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15144: LD_EXP 4
15148: NOT
15149: PUSH
15150: LD_INT 22
15152: PUSH
15153: LD_INT 1
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: PUSH
15160: LD_INT 34
15162: PUSH
15163: LD_INT 8
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: PPUSH
15174: CALL_OW 69
15178: AND
15179: IFFALSE 15298
15181: GO 15183
15183: DISABLE
// begin wait ( 0 0$10 ) ;
15184: LD_INT 350
15186: PPUSH
15187: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15191: LD_EXP 55
15195: PPUSH
15196: CALL_OW 302
15200: NOT
15201: PUSH
15202: LD_INT 22
15204: PUSH
15205: LD_INT 1
15207: PUSH
15208: EMPTY
15209: LIST
15210: LIST
15211: PUSH
15212: LD_INT 34
15214: PUSH
15215: LD_INT 8
15217: PUSH
15218: EMPTY
15219: LIST
15220: LIST
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PPUSH
15226: CALL_OW 69
15230: NOT
15231: OR
15232: IFFALSE 15236
// exit ;
15234: GO 15298
// DialogueOn ;
15236: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15240: LD_EXP 55
15244: PPUSH
15245: LD_STRING DWinAmericans-Pow-1
15247: PPUSH
15248: CALL_OW 94
// if IsOk ( Burlak ) then
15252: LD_EXP 52
15256: PPUSH
15257: CALL_OW 302
15261: IFFALSE 15275
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15263: LD_EXP 52
15267: PPUSH
15268: LD_STRING DWinAmericans-Bur-1
15270: PPUSH
15271: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15275: LD_EXP 19
15279: PPUSH
15280: LD_STRING DWinAmericans-JMM-1
15282: PPUSH
15283: CALL_OW 88
// DialogueOff ;
15287: CALL_OW 7
// YouLost ( AmBomb ) ;
15291: LD_STRING AmBomb
15293: PPUSH
15294: CALL_OW 104
// end ;
15298: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15299: LD_EXP 2
15303: NOT
15304: PUSH
15305: LD_INT 22
15307: PUSH
15308: LD_INT 3
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: PUSH
15315: LD_INT 34
15317: PUSH
15318: LD_INT 48
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: PUSH
15325: EMPTY
15326: LIST
15327: LIST
15328: PPUSH
15329: CALL_OW 69
15333: AND
15334: IFFALSE 15453
15336: GO 15338
15338: DISABLE
// begin wait ( 0 0$10 ) ;
15339: LD_INT 350
15341: PPUSH
15342: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15346: LD_EXP 60
15350: PPUSH
15351: CALL_OW 302
15355: NOT
15356: PUSH
15357: LD_INT 22
15359: PUSH
15360: LD_INT 3
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PUSH
15367: LD_INT 34
15369: PUSH
15370: LD_INT 48
15372: PUSH
15373: EMPTY
15374: LIST
15375: LIST
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PPUSH
15381: CALL_OW 69
15385: NOT
15386: OR
15387: IFFALSE 15391
// exit ;
15389: GO 15453
// DialogueOn ;
15391: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15395: LD_EXP 60
15399: PPUSH
15400: LD_STRING DWinRussians-Pla-1
15402: PPUSH
15403: CALL_OW 94
// if IsOk ( Burlak ) then
15407: LD_EXP 52
15411: PPUSH
15412: CALL_OW 302
15416: IFFALSE 15430
// Say ( Burlak , DWinRussians-Bur-1 ) ;
15418: LD_EXP 52
15422: PPUSH
15423: LD_STRING DWinRussians-Bur-1
15425: PPUSH
15426: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
15430: LD_EXP 19
15434: PPUSH
15435: LD_STRING DWinRussians-JMM-1
15437: PPUSH
15438: CALL_OW 88
// DialogueOff ;
15442: CALL_OW 7
// YouLost ( RuBomb ) ;
15446: LD_STRING RuBomb
15448: PPUSH
15449: CALL_OW 104
// end ;
15453: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
15454: LD_INT 7
15456: PPUSH
15457: LD_INT 22
15459: PUSH
15460: LD_INT 7
15462: PUSH
15463: EMPTY
15464: LIST
15465: LIST
15466: PPUSH
15467: CALL_OW 70
15471: PUSH
15472: LD_EXP 4
15476: NOT
15477: AND
15478: IFFALSE 15507
15480: GO 15482
15482: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
15483: LD_EXP 55
15487: PPUSH
15488: LD_STRING DSurrenderAmericans-Pow-1
15490: PPUSH
15491: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
15495: LD_EXP 19
15499: PPUSH
15500: LD_STRING DSurrenderAmericans-JMM-1
15502: PPUSH
15503: CALL_OW 88
// end ;
15507: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
15508: LD_INT 2
15510: PPUSH
15511: LD_INT 22
15513: PUSH
15514: LD_INT 7
15516: PUSH
15517: EMPTY
15518: LIST
15519: LIST
15520: PPUSH
15521: CALL_OW 70
15525: PUSH
15526: LD_EXP 2
15530: NOT
15531: AND
15532: PUSH
15533: LD_EXP 52
15537: AND
15538: IFFALSE 15567
15540: GO 15542
15542: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
15543: LD_EXP 60
15547: PPUSH
15548: LD_STRING DSurrenderRussians-Pla-1
15550: PPUSH
15551: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15555: LD_EXP 52
15559: PPUSH
15560: LD_STRING DSurrenderRussians-Bur-1
15562: PPUSH
15563: CALL_OW 88
// end ;
15567: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
15568: LD_EXP 4
15572: IFFALSE 16004
15574: GO 15576
15576: DISABLE
15577: LD_INT 0
15579: PPUSH
15580: PPUSH
15581: PPUSH
// begin MC_Kill ( 4 ) ;
15582: LD_INT 4
15584: PPUSH
15585: CALL 22452 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
15589: LD_INT 1
15591: PPUSH
15592: LD_INT 7
15594: PPUSH
15595: LD_INT 1
15597: PPUSH
15598: LD_INT 1
15600: PPUSH
15601: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
15605: LD_ADDR_VAR 0 3
15609: PUSH
15610: LD_INT 22
15612: PUSH
15613: LD_INT 1
15615: PUSH
15616: EMPTY
15617: LIST
15618: LIST
15619: PUSH
15620: LD_INT 26
15622: PUSH
15623: LD_INT 1
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: PUSH
15630: LD_INT 23
15632: PUSH
15633: LD_INT 1
15635: PUSH
15636: EMPTY
15637: LIST
15638: LIST
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: LIST
15644: PPUSH
15645: CALL_OW 69
15649: PUSH
15650: LD_EXP 55
15654: PUSH
15655: LD_EXP 27
15659: PUSH
15660: LD_EXP 24
15664: PUSH
15665: LD_EXP 23
15669: PUSH
15670: LD_EXP 30
15674: PUSH
15675: LD_EXP 28
15679: PUSH
15680: EMPTY
15681: LIST
15682: LIST
15683: LIST
15684: LIST
15685: LIST
15686: LIST
15687: DIFF
15688: ST_TO_ADDR
// if not speaker then
15689: LD_VAR 0 3
15693: NOT
15694: IFFALSE 15734
// begin uc_side := 1 ;
15696: LD_ADDR_OWVAR 20
15700: PUSH
15701: LD_INT 1
15703: ST_TO_ADDR
// uc_nation := 1 ;
15704: LD_ADDR_OWVAR 21
15708: PUSH
15709: LD_INT 1
15711: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
15712: LD_INT 1
15714: PPUSH
15715: LD_INT 0
15717: PPUSH
15718: CALL_OW 381
// speaker := CreateHuman ;
15722: LD_ADDR_VAR 0 3
15726: PUSH
15727: CALL_OW 44
15731: ST_TO_ADDR
// end else
15732: GO 15748
// speaker := speaker [ 1 ] ;
15734: LD_ADDR_VAR 0 3
15738: PUSH
15739: LD_VAR 0 3
15743: PUSH
15744: LD_INT 1
15746: ARRAY
15747: ST_TO_ADDR
// DialogueOn ;
15748: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
15752: LD_VAR 0 3
15756: PPUSH
15757: LD_STRING DSurrenderAmericans-Sol1-1a
15759: PPUSH
15760: CALL_OW 94
// DialogueOff ;
15764: CALL_OW 7
// americanCapitulated := true ;
15768: LD_ADDR_EXP 6
15772: PUSH
15773: LD_INT 1
15775: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15776: LD_ADDR_VAR 0 2
15780: PUSH
15781: LD_INT 22
15783: PUSH
15784: LD_INT 1
15786: PUSH
15787: EMPTY
15788: LIST
15789: LIST
15790: PUSH
15791: LD_INT 21
15793: PUSH
15794: LD_INT 1
15796: PUSH
15797: EMPTY
15798: LIST
15799: LIST
15800: PUSH
15801: EMPTY
15802: LIST
15803: LIST
15804: PPUSH
15805: CALL_OW 69
15809: PUSH
15810: LD_INT 22
15812: PUSH
15813: LD_INT 1
15815: PUSH
15816: EMPTY
15817: LIST
15818: LIST
15819: PUSH
15820: LD_INT 21
15822: PUSH
15823: LD_INT 2
15825: PUSH
15826: EMPTY
15827: LIST
15828: LIST
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: PUSH
15836: EMPTY
15837: LIST
15838: LIST
15839: LIST
15840: PPUSH
15841: CALL_OW 69
15845: ADD
15846: ST_TO_ADDR
// if tmp then
15847: LD_VAR 0 2
15851: IFFALSE 16004
// repeat wait ( 0 0$1 ) ;
15853: LD_INT 35
15855: PPUSH
15856: CALL_OW 67
// for i in tmp do
15860: LD_ADDR_VAR 0 1
15864: PUSH
15865: LD_VAR 0 2
15869: PUSH
15870: FOR_IN
15871: IFFALSE 15953
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15873: LD_VAR 0 1
15877: PPUSH
15878: CALL_OW 310
15882: PUSH
15883: LD_VAR 0 1
15887: PPUSH
15888: CALL_OW 310
15892: PPUSH
15893: CALL_OW 247
15897: PUSH
15898: LD_INT 3
15900: EQUAL
15901: AND
15902: IFFALSE 15913
// ComExitBuilding ( i ) ;
15904: LD_VAR 0 1
15908: PPUSH
15909: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15913: LD_VAR 0 1
15917: PPUSH
15918: LD_INT 122
15920: PPUSH
15921: LD_INT 242
15923: PPUSH
15924: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15928: LD_VAR 0 1
15932: PPUSH
15933: LD_INT 35
15935: PPUSH
15936: CALL_OW 308
15940: IFFALSE 15951
// RemoveUnit ( i ) ;
15942: LD_VAR 0 1
15946: PPUSH
15947: CALL_OW 64
// end ;
15951: GO 15870
15953: POP
15954: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15955: LD_INT 22
15957: PUSH
15958: LD_INT 1
15960: PUSH
15961: EMPTY
15962: LIST
15963: LIST
15964: PUSH
15965: LD_INT 2
15967: PUSH
15968: LD_INT 21
15970: PUSH
15971: LD_INT 1
15973: PUSH
15974: EMPTY
15975: LIST
15976: LIST
15977: PUSH
15978: LD_INT 33
15980: PUSH
15981: LD_INT 1
15983: PUSH
15984: EMPTY
15985: LIST
15986: LIST
15987: PUSH
15988: EMPTY
15989: LIST
15990: LIST
15991: LIST
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: PPUSH
15997: CALL_OW 69
16001: NOT
16002: IFFALSE 15853
// end ;
16004: PPOPN 3
16006: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
16007: LD_EXP 2
16011: IFFALSE 16453
16013: GO 16015
16015: DISABLE
16016: LD_INT 0
16018: PPUSH
16019: PPUSH
16020: PPUSH
// begin repeat wait ( 0 0$1 ) ;
16021: LD_INT 35
16023: PPUSH
16024: CALL_OW 67
// until IsDead ( Yakotich ) ;
16028: LD_EXP 61
16032: PPUSH
16033: CALL_OW 301
16037: IFFALSE 16021
// MC_Kill ( 2 ) ;
16039: LD_INT 2
16041: PPUSH
16042: CALL 22452 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16046: LD_INT 3
16048: PPUSH
16049: LD_INT 7
16051: PPUSH
16052: LD_INT 1
16054: PPUSH
16055: LD_INT 1
16057: PPUSH
16058: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16062: LD_ADDR_VAR 0 3
16066: PUSH
16067: LD_INT 22
16069: PUSH
16070: LD_INT 3
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: PUSH
16077: LD_INT 26
16079: PUSH
16080: LD_INT 1
16082: PUSH
16083: EMPTY
16084: LIST
16085: LIST
16086: PUSH
16087: LD_INT 23
16089: PUSH
16090: LD_INT 3
16092: PUSH
16093: EMPTY
16094: LIST
16095: LIST
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: LIST
16101: PPUSH
16102: CALL_OW 69
16106: PUSH
16107: LD_EXP 60
16111: DIFF
16112: ST_TO_ADDR
// if not speaker then
16113: LD_VAR 0 3
16117: NOT
16118: IFFALSE 16158
// begin uc_side := 3 ;
16120: LD_ADDR_OWVAR 20
16124: PUSH
16125: LD_INT 3
16127: ST_TO_ADDR
// uc_nation := 3 ;
16128: LD_ADDR_OWVAR 21
16132: PUSH
16133: LD_INT 3
16135: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16136: LD_INT 1
16138: PPUSH
16139: LD_INT 0
16141: PPUSH
16142: CALL_OW 381
// speaker := CreateHuman ;
16146: LD_ADDR_VAR 0 3
16150: PUSH
16151: CALL_OW 44
16155: ST_TO_ADDR
// end else
16156: GO 16172
// speaker := speaker [ 1 ] ;
16158: LD_ADDR_VAR 0 3
16162: PUSH
16163: LD_VAR 0 3
16167: PUSH
16168: LD_INT 1
16170: ARRAY
16171: ST_TO_ADDR
// DialogueOn ;
16172: CALL_OW 6
// if IsOK ( Burlak ) then
16176: LD_EXP 52
16180: PPUSH
16181: CALL_OW 302
16185: IFFALSE 16201
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16187: LD_VAR 0 3
16191: PPUSH
16192: LD_STRING DSurrenderRussians-RSol1-1
16194: PPUSH
16195: CALL_OW 94
16199: GO 16213
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16201: LD_VAR 0 3
16205: PPUSH
16206: LD_STRING DSurrenderRussians-RSol1-1a
16208: PPUSH
16209: CALL_OW 94
// DialogueOff ;
16213: CALL_OW 7
// russianCapitulated := true ;
16217: LD_ADDR_EXP 7
16221: PUSH
16222: LD_INT 1
16224: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16225: LD_ADDR_VAR 0 2
16229: PUSH
16230: LD_INT 22
16232: PUSH
16233: LD_INT 3
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: PUSH
16240: LD_INT 21
16242: PUSH
16243: LD_INT 1
16245: PUSH
16246: EMPTY
16247: LIST
16248: LIST
16249: PUSH
16250: EMPTY
16251: LIST
16252: LIST
16253: PPUSH
16254: CALL_OW 69
16258: PUSH
16259: LD_INT 22
16261: PUSH
16262: LD_INT 3
16264: PUSH
16265: EMPTY
16266: LIST
16267: LIST
16268: PUSH
16269: LD_INT 21
16271: PUSH
16272: LD_INT 2
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PUSH
16279: LD_INT 1
16281: PUSH
16282: EMPTY
16283: LIST
16284: PUSH
16285: EMPTY
16286: LIST
16287: LIST
16288: LIST
16289: PPUSH
16290: CALL_OW 69
16294: ADD
16295: ST_TO_ADDR
// if tmp then
16296: LD_VAR 0 2
16300: IFFALSE 16453
// repeat wait ( 0 0$1 ) ;
16302: LD_INT 35
16304: PPUSH
16305: CALL_OW 67
// for i in tmp do
16309: LD_ADDR_VAR 0 1
16313: PUSH
16314: LD_VAR 0 2
16318: PUSH
16319: FOR_IN
16320: IFFALSE 16402
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16322: LD_VAR 0 1
16326: PPUSH
16327: CALL_OW 310
16331: PUSH
16332: LD_VAR 0 1
16336: PPUSH
16337: CALL_OW 310
16341: PPUSH
16342: CALL_OW 247
16346: PUSH
16347: LD_INT 3
16349: EQUAL
16350: AND
16351: IFFALSE 16362
// ComExitBuilding ( i ) ;
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16362: LD_VAR 0 1
16366: PPUSH
16367: LD_INT 154
16369: PPUSH
16370: LD_INT 1
16372: PPUSH
16373: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16377: LD_VAR 0 1
16381: PPUSH
16382: LD_INT 36
16384: PPUSH
16385: CALL_OW 308
16389: IFFALSE 16400
// RemoveUnit ( i ) ;
16391: LD_VAR 0 1
16395: PPUSH
16396: CALL_OW 64
// end ;
16400: GO 16319
16402: POP
16403: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16404: LD_INT 22
16406: PUSH
16407: LD_INT 3
16409: PUSH
16410: EMPTY
16411: LIST
16412: LIST
16413: PUSH
16414: LD_INT 2
16416: PUSH
16417: LD_INT 21
16419: PUSH
16420: LD_INT 1
16422: PUSH
16423: EMPTY
16424: LIST
16425: LIST
16426: PUSH
16427: LD_INT 33
16429: PUSH
16430: LD_INT 1
16432: PUSH
16433: EMPTY
16434: LIST
16435: LIST
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: LIST
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: PPUSH
16446: CALL_OW 69
16450: NOT
16451: IFFALSE 16302
// end ;
16453: PPOPN 3
16455: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
16456: LD_INT 22
16458: PUSH
16459: LD_INT 8
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PUSH
16466: LD_INT 21
16468: PUSH
16469: LD_INT 1
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: PUSH
16476: LD_INT 23
16478: PUSH
16479: LD_INT 2
16481: PUSH
16482: EMPTY
16483: LIST
16484: LIST
16485: PUSH
16486: EMPTY
16487: LIST
16488: LIST
16489: LIST
16490: PPUSH
16491: CALL_OW 69
16495: PUSH
16496: LD_INT 18
16498: LESS
16499: PUSH
16500: LD_EXP 58
16504: PPUSH
16505: CALL_OW 301
16509: OR
16510: PUSH
16511: LD_INT 324
16513: PPUSH
16514: CALL_OW 255
16518: PUSH
16519: LD_INT 7
16521: EQUAL
16522: OR
16523: IFFALSE 16536
16525: GO 16527
16527: DISABLE
// legionDestroyed := true ;
16528: LD_ADDR_EXP 3
16532: PUSH
16533: LD_INT 1
16535: ST_TO_ADDR
16536: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
16537: LD_INT 22
16539: PUSH
16540: LD_INT 2
16542: PUSH
16543: EMPTY
16544: LIST
16545: LIST
16546: PUSH
16547: LD_INT 21
16549: PUSH
16550: LD_INT 1
16552: PUSH
16553: EMPTY
16554: LIST
16555: LIST
16556: PUSH
16557: LD_INT 23
16559: PUSH
16560: LD_INT 2
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: LIST
16571: PPUSH
16572: CALL_OW 69
16576: PUSH
16577: LD_INT 9
16579: LESS
16580: PUSH
16581: LD_INT 503
16583: PPUSH
16584: CALL_OW 301
16588: OR
16589: PUSH
16590: LD_INT 503
16592: PPUSH
16593: CALL_OW 255
16597: PUSH
16598: LD_INT 7
16600: EQUAL
16601: OR
16602: IFFALSE 16615
16604: GO 16606
16606: DISABLE
// arabianDestroyed := true ;
16607: LD_ADDR_EXP 5
16611: PUSH
16612: LD_INT 1
16614: ST_TO_ADDR
16615: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
16616: LD_EXP 5
16620: IFFALSE 16864
16622: GO 16624
16624: DISABLE
16625: LD_INT 0
16627: PPUSH
16628: PPUSH
// begin MC_Kill ( 1 ) ;
16629: LD_INT 1
16631: PPUSH
16632: CALL 22452 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16636: LD_ADDR_VAR 0 2
16640: PUSH
16641: LD_INT 22
16643: PUSH
16644: LD_INT 2
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: PUSH
16651: LD_INT 21
16653: PUSH
16654: LD_INT 1
16656: PUSH
16657: EMPTY
16658: LIST
16659: LIST
16660: PUSH
16661: EMPTY
16662: LIST
16663: LIST
16664: PPUSH
16665: CALL_OW 69
16669: PUSH
16670: LD_INT 22
16672: PUSH
16673: LD_INT 2
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PUSH
16680: LD_INT 21
16682: PUSH
16683: LD_INT 2
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: LD_INT 1
16692: PUSH
16693: EMPTY
16694: LIST
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: LIST
16700: PPUSH
16701: CALL_OW 69
16705: ADD
16706: ST_TO_ADDR
// if tmp then
16707: LD_VAR 0 2
16711: IFFALSE 16864
// repeat wait ( 0 0$1 ) ;
16713: LD_INT 35
16715: PPUSH
16716: CALL_OW 67
// for i in tmp do
16720: LD_ADDR_VAR 0 1
16724: PUSH
16725: LD_VAR 0 2
16729: PUSH
16730: FOR_IN
16731: IFFALSE 16813
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16733: LD_VAR 0 1
16737: PPUSH
16738: CALL_OW 310
16742: PUSH
16743: LD_VAR 0 1
16747: PPUSH
16748: CALL_OW 310
16752: PPUSH
16753: CALL_OW 247
16757: PUSH
16758: LD_INT 3
16760: EQUAL
16761: AND
16762: IFFALSE 16773
// ComExitBuilding ( i ) ;
16764: LD_VAR 0 1
16768: PPUSH
16769: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
16773: LD_VAR 0 1
16777: PPUSH
16778: LD_INT 254
16780: PPUSH
16781: LD_INT 268
16783: PPUSH
16784: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
16788: LD_VAR 0 1
16792: PPUSH
16793: LD_INT 34
16795: PPUSH
16796: CALL_OW 308
16800: IFFALSE 16811
// RemoveUnit ( i ) ;
16802: LD_VAR 0 1
16806: PPUSH
16807: CALL_OW 64
// end ;
16811: GO 16730
16813: POP
16814: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16815: LD_INT 22
16817: PUSH
16818: LD_INT 2
16820: PUSH
16821: EMPTY
16822: LIST
16823: LIST
16824: PUSH
16825: LD_INT 2
16827: PUSH
16828: LD_INT 21
16830: PUSH
16831: LD_INT 1
16833: PUSH
16834: EMPTY
16835: LIST
16836: LIST
16837: PUSH
16838: LD_INT 33
16840: PUSH
16841: LD_INT 1
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PUSH
16848: EMPTY
16849: LIST
16850: LIST
16851: LIST
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PPUSH
16857: CALL_OW 69
16861: NOT
16862: IFFALSE 16713
// end ;
16864: PPOPN 2
16866: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16867: LD_EXP 3
16871: IFFALSE 17223
16873: GO 16875
16875: DISABLE
16876: LD_INT 0
16878: PPUSH
16879: PPUSH
// begin MC_Kill ( 3 ) ;
16880: LD_INT 3
16882: PPUSH
16883: CALL 22452 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16887: LD_INT 8
16889: PPUSH
16890: LD_INT 7
16892: PPUSH
16893: LD_INT 1
16895: PPUSH
16896: LD_INT 1
16898: PPUSH
16899: CALL_OW 80
// DialogueOn ;
16903: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16907: LD_EXP 57
16911: PPUSH
16912: LD_STRING D15-Szulc-1
16914: PPUSH
16915: CALL_OW 94
// DialogueOff ;
16919: CALL_OW 7
// legionCapitulated := true ;
16923: LD_ADDR_EXP 8
16927: PUSH
16928: LD_INT 1
16930: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16931: LD_ADDR_VAR 0 1
16935: PUSH
16936: LD_INT 22
16938: PUSH
16939: LD_INT 8
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: PUSH
16946: LD_INT 21
16948: PUSH
16949: LD_INT 3
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: PUSH
16956: LD_INT 23
16958: PUSH
16959: LD_INT 3
16961: PUSH
16962: EMPTY
16963: LIST
16964: LIST
16965: PUSH
16966: EMPTY
16967: LIST
16968: LIST
16969: LIST
16970: PPUSH
16971: CALL_OW 69
16975: PUSH
16976: FOR_IN
16977: IFFALSE 16993
// SetLives ( i , 3 ) ;
16979: LD_VAR 0 1
16983: PPUSH
16984: LD_INT 3
16986: PPUSH
16987: CALL_OW 234
16991: GO 16976
16993: POP
16994: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16995: LD_ADDR_VAR 0 2
16999: PUSH
17000: LD_INT 22
17002: PUSH
17003: LD_INT 8
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: PUSH
17010: LD_INT 21
17012: PUSH
17013: LD_INT 1
17015: PUSH
17016: EMPTY
17017: LIST
17018: LIST
17019: PUSH
17020: EMPTY
17021: LIST
17022: LIST
17023: PPUSH
17024: CALL_OW 69
17028: PUSH
17029: LD_INT 22
17031: PUSH
17032: LD_INT 8
17034: PUSH
17035: EMPTY
17036: LIST
17037: LIST
17038: PUSH
17039: LD_INT 21
17041: PUSH
17042: LD_INT 2
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: PUSH
17049: LD_INT 1
17051: PUSH
17052: EMPTY
17053: LIST
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: LIST
17059: PPUSH
17060: CALL_OW 69
17064: ADD
17065: ST_TO_ADDR
// if tmp then
17066: LD_VAR 0 2
17070: IFFALSE 17223
// repeat wait ( 0 0$1 ) ;
17072: LD_INT 35
17074: PPUSH
17075: CALL_OW 67
// for i in tmp do
17079: LD_ADDR_VAR 0 1
17083: PUSH
17084: LD_VAR 0 2
17088: PUSH
17089: FOR_IN
17090: IFFALSE 17172
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17092: LD_VAR 0 1
17096: PPUSH
17097: CALL_OW 310
17101: PUSH
17102: LD_VAR 0 1
17106: PPUSH
17107: CALL_OW 310
17111: PPUSH
17112: CALL_OW 247
17116: PUSH
17117: LD_INT 3
17119: EQUAL
17120: AND
17121: IFFALSE 17132
// ComExitBuilding ( i ) ;
17123: LD_VAR 0 1
17127: PPUSH
17128: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17132: LD_VAR 0 1
17136: PPUSH
17137: LD_INT 10
17139: PPUSH
17140: LD_INT 1
17142: PPUSH
17143: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17147: LD_VAR 0 1
17151: PPUSH
17152: LD_INT 32
17154: PPUSH
17155: CALL_OW 308
17159: IFFALSE 17170
// RemoveUnit ( i ) ;
17161: LD_VAR 0 1
17165: PPUSH
17166: CALL_OW 64
// end ;
17170: GO 17089
17172: POP
17173: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17174: LD_INT 22
17176: PUSH
17177: LD_INT 8
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: PUSH
17184: LD_INT 2
17186: PUSH
17187: LD_INT 21
17189: PUSH
17190: LD_INT 1
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: PUSH
17197: LD_INT 33
17199: PUSH
17200: LD_INT 1
17202: PUSH
17203: EMPTY
17204: LIST
17205: LIST
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: PPUSH
17216: CALL_OW 69
17220: NOT
17221: IFFALSE 17072
// end ;
17223: PPOPN 2
17225: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17226: LD_EXP 5
17230: NOT
17231: PUSH
17232: LD_OWVAR 1
17236: PUSH
17237: LD_INT 63000
17239: GREATEREQUAL
17240: AND
17241: PUSH
17242: LD_OWVAR 67
17246: PUSH
17247: LD_INT 3
17249: LESS
17250: AND
17251: IFFALSE 17260
17253: GO 17255
17255: DISABLE
// AllianceSupport ;
17256: CALL 4677 0 0
17260: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17261: LD_EXP 4
17265: PUSH
17266: LD_EXP 2
17270: AND
17271: PUSH
17272: LD_EXP 3
17276: AND
17277: PUSH
17278: LD_EXP 5
17282: AND
17283: PUSH
17284: LD_EXP 6
17288: AND
17289: PUSH
17290: LD_EXP 7
17294: AND
17295: PUSH
17296: LD_EXP 8
17300: AND
17301: PUSH
17302: LD_EXP 56
17306: PPUSH
17307: CALL_OW 255
17311: PUSH
17312: LD_INT 5
17314: NONEQUAL
17315: PUSH
17316: LD_EXP 56
17320: PPUSH
17321: CALL_OW 301
17325: OR
17326: PUSH
17327: LD_EXP 56
17331: PPUSH
17332: CALL_OW 305
17336: NOT
17337: OR
17338: AND
17339: IFFALSE 18858
17341: GO 17343
17343: DISABLE
17344: LD_INT 0
17346: PPUSH
17347: PPUSH
// begin wait ( 0 0$5 ) ;
17348: LD_INT 175
17350: PPUSH
17351: CALL_OW 67
// music_class := 5 ;
17355: LD_ADDR_OWVAR 72
17359: PUSH
17360: LD_INT 5
17362: ST_TO_ADDR
// music_nat := 5 ;
17363: LD_ADDR_OWVAR 71
17367: PUSH
17368: LD_INT 5
17370: ST_TO_ADDR
// if vehicleLostCounter < 3 then
17371: LD_EXP 15
17375: PUSH
17376: LD_INT 3
17378: LESS
17379: IFFALSE 17388
// SetAchievement ( ACH_ECONOMY ) ;
17381: LD_STRING ACH_ECONOMY
17383: PPUSH
17384: CALL_OW 543
// if tick < 60 60$00 then
17388: LD_OWVAR 1
17392: PUSH
17393: LD_INT 126000
17395: LESS
17396: IFFALSE 17412
// begin wait ( 3 ) ;
17398: LD_INT 3
17400: PPUSH
17401: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
17405: LD_STRING ACH_ASPEED_19
17407: PPUSH
17408: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
17412: LD_EXP 19
17416: PPUSH
17417: CALL_OW 87
// InGameOn ;
17421: CALL_OW 8
// DialogueOn ;
17425: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
17429: LD_EXP 19
17433: PPUSH
17434: LD_STRING DEnd-JMM-JMM-1
17436: PPUSH
17437: CALL_OW 88
// if Joan then
17441: LD_EXP 34
17445: IFFALSE 17461
// Say ( Joan , DEnd-JMM-Joan-1 ) else
17447: LD_EXP 34
17451: PPUSH
17452: LD_STRING DEnd-JMM-Joan-1
17454: PPUSH
17455: CALL_OW 88
17459: GO 17505
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
17461: LD_EXP 21
17465: PUSH
17466: LD_EXP 21
17470: PPUSH
17471: CALL_OW 255
17475: PUSH
17476: LD_INT 7
17478: EQUAL
17479: AND
17480: PUSH
17481: LD_EXP 21
17485: PPUSH
17486: CALL_OW 305
17490: AND
17491: IFFALSE 17505
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17493: LD_EXP 21
17497: PPUSH
17498: LD_STRING DEnd-JMM-Lisa-1
17500: PPUSH
17501: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
17505: LD_EXP 31
17509: PUSH
17510: LD_EXP 31
17514: PPUSH
17515: CALL_OW 305
17519: AND
17520: IFFALSE 17534
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17522: LD_EXP 31
17526: PPUSH
17527: LD_STRING DEnd-JMM-Frank-1
17529: PPUSH
17530: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
17534: LD_EXP 24
17538: PUSH
17539: LD_EXP 24
17543: PPUSH
17544: CALL_OW 255
17548: PUSH
17549: LD_INT 7
17551: EQUAL
17552: AND
17553: PUSH
17554: LD_EXP 24
17558: PPUSH
17559: CALL_OW 305
17563: AND
17564: IFFALSE 17578
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17566: LD_EXP 24
17570: PPUSH
17571: LD_STRING DEnd-JMM-Cyrus-1
17573: PPUSH
17574: CALL_OW 88
// if Burlak then
17578: LD_EXP 52
17582: IFFALSE 17596
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17584: LD_EXP 52
17588: PPUSH
17589: LD_STRING DEnd-JMM-Bur-1
17591: PPUSH
17592: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
17596: LD_EXP 34
17600: PUSH
17601: LD_EXP 21
17605: AND
17606: PUSH
17607: LD_EXP 21
17611: PPUSH
17612: CALL_OW 255
17616: PUSH
17617: LD_INT 7
17619: EQUAL
17620: AND
17621: PUSH
17622: LD_EXP 21
17626: PPUSH
17627: CALL_OW 305
17631: AND
17632: PUSH
17633: LD_EXP 52
17637: PPUSH
17638: CALL_OW 302
17642: AND
17643: IFFALSE 17657
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
17645: LD_EXP 21
17649: PPUSH
17650: LD_STRING DEnd-Burlak-Lisa-1
17652: PPUSH
17653: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
17657: LD_EXP 53
17661: PUSH
17662: LD_EXP 53
17666: PPUSH
17667: CALL_OW 305
17671: AND
17672: IFFALSE 17686
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
17674: LD_EXP 53
17678: PPUSH
17679: LD_STRING DEnd-JMM-Bel-1
17681: PPUSH
17682: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
17686: LD_EXP 54
17690: PUSH
17691: LD_EXP 54
17695: PPUSH
17696: CALL_OW 305
17700: AND
17701: IFFALSE 17715
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
17703: LD_EXP 54
17707: PPUSH
17708: LD_STRING DEnd-JMM-Gny-1
17710: PPUSH
17711: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
17715: LD_EXP 29
17719: PUSH
17720: LD_EXP 29
17724: PPUSH
17725: CALL_OW 255
17729: PUSH
17730: LD_INT 7
17732: EQUAL
17733: AND
17734: PUSH
17735: LD_EXP 29
17739: PPUSH
17740: CALL_OW 305
17744: AND
17745: IFFALSE 17759
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
17747: LD_EXP 29
17751: PPUSH
17752: LD_STRING DEnd-JMM-Corn-1
17754: PPUSH
17755: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
17759: LD_EXP 22
17763: PUSH
17764: LD_EXP 22
17768: PPUSH
17769: CALL_OW 255
17773: PUSH
17774: LD_INT 7
17776: EQUAL
17777: AND
17778: PUSH
17779: LD_EXP 22
17783: PPUSH
17784: CALL_OW 305
17788: AND
17789: IFFALSE 17803
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17791: LD_EXP 22
17795: PPUSH
17796: LD_STRING DEnd-JMM-Don-1
17798: PPUSH
17799: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
17803: LD_EXP 23
17807: PUSH
17808: LD_EXP 23
17812: PPUSH
17813: CALL_OW 255
17817: PUSH
17818: LD_INT 7
17820: EQUAL
17821: AND
17822: PUSH
17823: LD_EXP 23
17827: PPUSH
17828: CALL_OW 305
17832: AND
17833: IFFALSE 17847
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17835: LD_EXP 23
17839: PPUSH
17840: LD_STRING DEnd-JMM-Bobby-1
17842: PPUSH
17843: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17847: LD_EXP 25
17851: PUSH
17852: LD_EXP 25
17856: PPUSH
17857: CALL_OW 255
17861: PUSH
17862: LD_INT 7
17864: EQUAL
17865: AND
17866: PUSH
17867: LD_EXP 25
17871: PPUSH
17872: CALL_OW 305
17876: AND
17877: IFFALSE 17891
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17879: LD_EXP 25
17883: PPUSH
17884: LD_STRING DEnd-JMM-Den-1
17886: PPUSH
17887: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17891: LD_EXP 27
17895: PUSH
17896: LD_EXP 27
17900: PPUSH
17901: CALL_OW 255
17905: PUSH
17906: LD_INT 7
17908: EQUAL
17909: AND
17910: PUSH
17911: LD_EXP 27
17915: PPUSH
17916: CALL_OW 305
17920: AND
17921: IFFALSE 17935
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17923: LD_EXP 27
17927: PPUSH
17928: LD_STRING DEnd-JMM-Glad-1
17930: PPUSH
17931: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17935: LD_EXP 32
17939: PUSH
17940: LD_EXP 32
17944: PPUSH
17945: CALL_OW 255
17949: PUSH
17950: LD_INT 7
17952: EQUAL
17953: AND
17954: PUSH
17955: LD_EXP 32
17959: PPUSH
17960: CALL_OW 305
17964: AND
17965: IFFALSE 17979
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17967: LD_EXP 32
17971: PPUSH
17972: LD_STRING DEnd-JMM-Yam-1
17974: PPUSH
17975: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17979: LD_EXP 26
17983: PUSH
17984: LD_EXP 26
17988: PPUSH
17989: CALL_OW 255
17993: PUSH
17994: LD_INT 7
17996: EQUAL
17997: AND
17998: PUSH
17999: LD_EXP 26
18003: PPUSH
18004: CALL_OW 305
18008: AND
18009: IFFALSE 18023
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
18011: LD_EXP 26
18015: PPUSH
18016: LD_STRING DEnd-JMM-Brown-1
18018: PPUSH
18019: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
18023: LD_EXP 36
18027: PUSH
18028: LD_EXP 36
18032: PPUSH
18033: CALL_OW 255
18037: PUSH
18038: LD_INT 7
18040: EQUAL
18041: AND
18042: PUSH
18043: LD_EXP 36
18047: PPUSH
18048: CALL_OW 305
18052: AND
18053: IFFALSE 18067
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18055: LD_EXP 36
18059: PPUSH
18060: LD_STRING DEnd-JMM-Con-1
18062: PPUSH
18063: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
18067: LD_EXP 30
18071: PUSH
18072: LD_EXP 30
18076: PPUSH
18077: CALL_OW 255
18081: PUSH
18082: LD_INT 7
18084: EQUAL
18085: AND
18086: PUSH
18087: LD_EXP 30
18091: PPUSH
18092: CALL_OW 305
18096: AND
18097: IFFALSE 18111
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18099: LD_EXP 30
18103: PPUSH
18104: LD_STRING DEnd-JMM-Gary-1
18106: PPUSH
18107: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18111: LD_EXP 20
18115: PUSH
18116: LD_EXP 20
18120: PPUSH
18121: CALL_OW 305
18125: AND
18126: IFFALSE 18140
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18128: LD_EXP 20
18132: PPUSH
18133: LD_STRING DEnd-JMM-Roth-1
18135: PPUSH
18136: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18140: LD_EXP 33
18144: PUSH
18145: LD_EXP 20
18149: AND
18150: PUSH
18151: LD_EXP 33
18155: PPUSH
18156: CALL_OW 305
18160: AND
18161: IFFALSE 18175
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18163: LD_EXP 33
18167: PPUSH
18168: LD_STRING DEnd-JMM-Sim-1
18170: PPUSH
18171: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18175: LD_EXP 28
18179: PUSH
18180: LD_EXP 28
18184: PPUSH
18185: CALL_OW 255
18189: PUSH
18190: LD_INT 7
18192: EQUAL
18193: AND
18194: PUSH
18195: LD_EXP 28
18199: PPUSH
18200: CALL_OW 305
18204: AND
18205: IFFALSE 18219
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18207: LD_EXP 28
18211: PPUSH
18212: LD_STRING DEnd-JMM-VanH-1
18214: PPUSH
18215: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18219: LD_EXP 42
18223: PUSH
18224: LD_EXP 42
18228: PPUSH
18229: CALL_OW 305
18233: AND
18234: IFFALSE 18248
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18236: LD_EXP 42
18240: PPUSH
18241: LD_STRING DEnd-JMM-Dol-1
18243: PPUSH
18244: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18248: LD_EXP 32
18252: PUSH
18253: LD_EXP 32
18257: PPUSH
18258: CALL_OW 255
18262: PUSH
18263: LD_INT 7
18265: EQUAL
18266: AND
18267: PUSH
18268: LD_EXP 32
18272: PPUSH
18273: CALL_OW 305
18277: AND
18278: IFFALSE 18292
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18280: LD_EXP 32
18284: PPUSH
18285: LD_STRING DEnd-JMM-Yam-1
18287: PPUSH
18288: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18292: LD_EXP 46
18296: PUSH
18297: LD_EXP 46
18301: PPUSH
18302: CALL_OW 305
18306: AND
18307: IFFALSE 18321
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18309: LD_EXP 46
18313: PPUSH
18314: LD_STRING DEnd-JMM-Kap-1
18316: PPUSH
18317: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18321: LD_EXP 49
18325: PUSH
18326: LD_EXP 49
18330: PPUSH
18331: CALL_OW 305
18335: AND
18336: IFFALSE 18350
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18338: LD_EXP 49
18342: PPUSH
18343: LD_STRING DEnd-JMM-Kov-1
18345: PPUSH
18346: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
18350: LD_EXP 44
18354: PUSH
18355: LD_EXP 44
18359: PPUSH
18360: CALL_OW 305
18364: AND
18365: IFFALSE 18379
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18367: LD_EXP 44
18371: PPUSH
18372: LD_STRING DEnd-JMM-Sch-1
18374: PPUSH
18375: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
18379: LD_EXP 40
18383: PUSH
18384: LD_EXP 40
18388: PPUSH
18389: CALL_OW 305
18393: AND
18394: PUSH
18395: LD_EXP 52
18399: PPUSH
18400: CALL_OW 302
18404: AND
18405: IFFALSE 18419
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18407: LD_EXP 40
18411: PPUSH
18412: LD_STRING DEnd-JMM-Tit-1
18414: PPUSH
18415: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
18419: LD_EXP 45
18423: PUSH
18424: LD_EXP 45
18428: PPUSH
18429: CALL_OW 305
18433: AND
18434: IFFALSE 18448
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18436: LD_EXP 45
18440: PPUSH
18441: LD_STRING DEnd-JMM-Obl-1
18443: PPUSH
18444: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
18448: LD_EXP 47
18452: PUSH
18453: LD_EXP 47
18457: PPUSH
18458: CALL_OW 305
18462: AND
18463: IFFALSE 18477
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18465: LD_EXP 47
18469: PPUSH
18470: LD_STRING DEnd-JMM-Lip-1
18472: PPUSH
18473: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
18477: LD_EXP 41
18481: PUSH
18482: LD_EXP 41
18486: PPUSH
18487: CALL_OW 305
18491: AND
18492: PUSH
18493: LD_EXP 52
18497: PPUSH
18498: CALL_OW 302
18502: AND
18503: IFFALSE 18517
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
18505: LD_EXP 41
18509: PPUSH
18510: LD_STRING DEnd-Burlak-Fad-1
18512: PPUSH
18513: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
18517: LD_EXP 48
18521: PUSH
18522: LD_EXP 48
18526: PPUSH
18527: CALL_OW 305
18531: AND
18532: IFFALSE 18546
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
18534: LD_EXP 48
18538: PPUSH
18539: LD_STRING DEnd-Burlak-Ptr-1
18541: PPUSH
18542: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
18546: LD_EXP 50
18550: PUSH
18551: LD_EXP 50
18555: PPUSH
18556: CALL_OW 305
18560: AND
18561: IFFALSE 18575
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
18563: LD_EXP 50
18567: PPUSH
18568: LD_STRING DEnd-Burlak-Kuz-1
18570: PPUSH
18571: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
18575: LD_EXP 39
18579: PUSH
18580: LD_EXP 39
18584: PPUSH
18585: CALL_OW 305
18589: AND
18590: PUSH
18591: LD_EXP 52
18595: PPUSH
18596: CALL_OW 302
18600: AND
18601: IFFALSE 18615
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
18603: LD_EXP 39
18607: PPUSH
18608: LD_STRING DEnd-Burlak-Kir-1
18610: PPUSH
18611: CALL_OW 88
// if Joan then
18615: LD_EXP 34
18619: IFFALSE 18633
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
18621: LD_EXP 34
18625: PPUSH
18626: LD_STRING DEnd-Burlak-Joan-1
18628: PPUSH
18629: CALL_OW 88
// if IsOk ( Burlak ) then
18633: LD_EXP 52
18637: PPUSH
18638: CALL_OW 302
18642: IFFALSE 18656
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
18644: LD_EXP 19
18648: PPUSH
18649: LD_STRING DEnd-Burlak-JMM-1
18651: PPUSH
18652: CALL_OW 88
// dwait ( 0 0$2 ) ;
18656: LD_INT 70
18658: PPUSH
18659: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
18663: LD_EXP 57
18667: PPUSH
18668: LD_STRING DEnd-Szulc
18670: PPUSH
18671: CALL_OW 94
// dwait ( 0 0$1 ) ;
18675: LD_INT 35
18677: PPUSH
18678: CALL_OW 68
// if IsLive ( Burlak ) then
18682: LD_EXP 52
18686: PPUSH
18687: CALL_OW 300
18691: IFFALSE 18703
// med1 := 1 else
18693: LD_ADDR_VAR 0 1
18697: PUSH
18698: LD_INT 1
18700: ST_TO_ADDR
18701: GO 18712
// med1 := - 1 ;
18703: LD_ADDR_VAR 0 1
18707: PUSH
18708: LD_INT 1
18710: NEG
18711: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
18712: LD_EXP 12
18716: PUSH
18717: LD_EXP 13
18721: AND
18722: PUSH
18723: LD_EXP 14
18727: AND
18728: IFFALSE 18740
// med2 := 1 else
18730: LD_ADDR_VAR 0 2
18734: PUSH
18735: LD_INT 1
18737: ST_TO_ADDR
18738: GO 18749
// med2 := - 1 ;
18740: LD_ADDR_VAR 0 2
18744: PUSH
18745: LD_INT 1
18747: NEG
18748: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
18749: LD_STRING Hero
18751: PPUSH
18752: LD_INT 1
18754: PPUSH
18755: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
18759: LD_STRING Artefact
18761: PPUSH
18762: LD_VAR 0 2
18766: PPUSH
18767: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
18771: LD_STRING ReconcileBurlak
18773: PPUSH
18774: LD_VAR 0 1
18778: PPUSH
18779: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
18783: LD_OWVAR 67
18787: PUSH
18788: LD_INT 3
18790: GREATEREQUAL
18791: PUSH
18792: LD_VAR 0 1
18796: PUSH
18797: LD_INT 1
18799: EQUAL
18800: AND
18801: PUSH
18802: LD_VAR 0 2
18806: PUSH
18807: LD_INT 1
18809: EQUAL
18810: AND
18811: IFFALSE 18823
// SetAchievementEX ( ACH_AMER , 19 ) ;
18813: LD_STRING ACH_AMER
18815: PPUSH
18816: LD_INT 19
18818: PPUSH
18819: CALL_OW 564
// GiveMedals ( MAIN ) ;
18823: LD_STRING MAIN
18825: PPUSH
18826: CALL_OW 102
// InGameOff ;
18830: CALL_OW 9
// DialogueOff ;
18834: CALL_OW 7
// music_nat := 1 ;
18838: LD_ADDR_OWVAR 71
18842: PUSH
18843: LD_INT 1
18845: ST_TO_ADDR
// music_class := 4 ;
18846: LD_ADDR_OWVAR 72
18850: PUSH
18851: LD_INT 4
18853: ST_TO_ADDR
// YouWin ;
18854: CALL_OW 103
// end ; end_of_file
18858: PPOPN 2
18860: END
// export function InitNature ; begin
18861: LD_INT 0
18863: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
18864: LD_INT 3
18866: PPUSH
18867: LD_INT 3
18869: PPUSH
18870: LD_INT 2
18872: PPUSH
18873: LD_INT 1
18875: PPUSH
18876: LD_INT 1
18878: PPUSH
18879: LD_INT 0
18881: PPUSH
18882: LD_INT 0
18884: PPUSH
18885: LD_INT 17
18887: PPUSH
18888: LD_INT 0
18890: PPUSH
18891: CALL 87282 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
18895: LD_INT 2
18897: PPUSH
18898: LD_INT 1
18900: PPUSH
18901: LD_INT 1
18903: PPUSH
18904: LD_INT 1
18906: PPUSH
18907: LD_INT 1
18909: PPUSH
18910: LD_INT 0
18912: PPUSH
18913: LD_INT 0
18915: PPUSH
18916: LD_INT 18
18918: PPUSH
18919: LD_INT 0
18921: PPUSH
18922: CALL 87282 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
18926: LD_INT 4
18928: PPUSH
18929: LD_INT 1
18931: PPUSH
18932: LD_INT 2
18934: PPUSH
18935: LD_INT 4
18937: PPUSH
18938: LD_INT 2
18940: PPUSH
18941: LD_INT 1
18943: PPUSH
18944: LD_INT 0
18946: PPUSH
18947: LD_INT 19
18949: PPUSH
18950: LD_INT 0
18952: PPUSH
18953: CALL 87282 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18957: LD_INT 0
18959: PPUSH
18960: LD_INT 0
18962: PPUSH
18963: LD_INT 0
18965: PPUSH
18966: LD_INT 0
18968: PPUSH
18969: LD_INT 0
18971: PPUSH
18972: LD_INT 0
18974: PPUSH
18975: LD_INT 9
18977: PPUSH
18978: LD_INT 0
18980: PPUSH
18981: LD_INT 20
18983: PPUSH
18984: CALL 87282 0 9
// end ; end_of_file
18988: LD_VAR 0 1
18992: RET
// every 0 0$30 do var time ;
18993: GO 18995
18995: DISABLE
18996: LD_INT 0
18998: PPUSH
// begin time := 0 0$30 ;
18999: LD_ADDR_VAR 0 1
19003: PUSH
19004: LD_INT 1050
19006: ST_TO_ADDR
// repeat wait ( time ) ;
19007: LD_VAR 0 1
19011: PPUSH
19012: CALL_OW 67
// if Prob ( 50 ) then
19016: LD_INT 50
19018: PPUSH
19019: CALL_OW 13
19023: IFFALSE 19052
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
19025: LD_INT 1
19027: PPUSH
19028: LD_INT 5
19030: PPUSH
19031: CALL_OW 12
19035: PPUSH
19036: LD_INT 106
19038: PPUSH
19039: LD_INT 89
19041: PPUSH
19042: LD_INT 45
19044: PPUSH
19045: LD_INT 1
19047: PPUSH
19048: CALL_OW 56
// time := time + 0 0$3 ;
19052: LD_ADDR_VAR 0 1
19056: PUSH
19057: LD_VAR 0 1
19061: PUSH
19062: LD_INT 105
19064: PLUS
19065: ST_TO_ADDR
// if Prob ( 30 ) then
19066: LD_INT 30
19068: PPUSH
19069: CALL_OW 13
19073: IFFALSE 19119
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
19075: LD_INT 525
19077: PPUSH
19078: LD_INT 735
19080: PPUSH
19081: CALL_OW 12
19085: PPUSH
19086: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19090: LD_INT 1
19092: PPUSH
19093: LD_INT 5
19095: PPUSH
19096: CALL_OW 12
19100: PPUSH
19101: LD_INT 21
19103: PPUSH
19104: LD_INT 26
19106: PPUSH
19107: LD_INT 12
19109: PPUSH
19110: LD_INT 1
19112: PPUSH
19113: CALL_OW 56
// end else
19117: GO 19155
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19119: LD_INT 700
19121: PPUSH
19122: LD_INT 1225
19124: PPUSH
19125: CALL_OW 12
19129: PPUSH
19130: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19134: LD_INT 1
19136: PPUSH
19137: LD_INT 5
19139: PPUSH
19140: CALL_OW 12
19144: PPUSH
19145: LD_INT 14
19147: PPUSH
19148: LD_INT 1
19150: PPUSH
19151: CALL_OW 55
// end ; if Prob ( 50 ) then
19155: LD_INT 50
19157: PPUSH
19158: CALL_OW 13
19162: IFFALSE 19208
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19164: LD_INT 700
19166: PPUSH
19167: LD_INT 1050
19169: PPUSH
19170: CALL_OW 12
19174: PPUSH
19175: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19179: LD_INT 1
19181: PPUSH
19182: LD_INT 5
19184: PPUSH
19185: CALL_OW 12
19189: PPUSH
19190: LD_INT 181
19192: PPUSH
19193: LD_INT 218
19195: PPUSH
19196: LD_INT 16
19198: PPUSH
19199: LD_INT 1
19201: PPUSH
19202: CALL_OW 56
// end else
19206: GO 19280
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19208: LD_INT 350
19210: PPUSH
19211: LD_INT 525
19213: PPUSH
19214: CALL_OW 12
19218: PPUSH
19219: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19223: LD_INT 1
19225: PPUSH
19226: LD_INT 5
19228: PPUSH
19229: CALL_OW 12
19233: PPUSH
19234: LD_INT 13
19236: PPUSH
19237: LD_INT 1
19239: PPUSH
19240: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19244: LD_INT 350
19246: PPUSH
19247: LD_INT 700
19249: PPUSH
19250: CALL_OW 12
19254: PPUSH
19255: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19259: LD_INT 1
19261: PPUSH
19262: LD_INT 5
19264: PPUSH
19265: CALL_OW 12
19269: PPUSH
19270: LD_INT 33
19272: PPUSH
19273: LD_INT 1
19275: PPUSH
19276: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19280: LD_INT 65
19282: PUSH
19283: LD_INT 62
19285: PUSH
19286: LD_INT 55
19288: PUSH
19289: LD_INT 50
19291: PUSH
19292: EMPTY
19293: LIST
19294: LIST
19295: LIST
19296: LIST
19297: PUSH
19298: LD_OWVAR 67
19302: ARRAY
19303: PPUSH
19304: CALL_OW 13
19308: IFFALSE 19354
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19310: LD_INT 525
19312: PPUSH
19313: LD_INT 875
19315: PPUSH
19316: CALL_OW 12
19320: PPUSH
19321: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19325: LD_INT 1
19327: PPUSH
19328: LD_INT 5
19330: PPUSH
19331: CALL_OW 12
19335: PPUSH
19336: LD_INT 294
19338: PPUSH
19339: LD_INT 211
19341: PPUSH
19342: LD_INT 30
19344: PPUSH
19345: LD_INT 1
19347: PPUSH
19348: CALL_OW 56
// end else
19352: GO 19396
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
19354: LD_INT 420
19356: PPUSH
19357: LD_INT 770
19359: PPUSH
19360: CALL_OW 12
19364: PPUSH
19365: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19369: LD_INT 1
19371: PPUSH
19372: LD_INT 5
19374: PPUSH
19375: CALL_OW 12
19379: PPUSH
19380: LD_INT 294
19382: PPUSH
19383: LD_INT 211
19385: PPUSH
19386: LD_INT 30
19388: PPUSH
19389: LD_INT 1
19391: PPUSH
19392: CALL_OW 56
// end ; if time > 2 2$20 then
19396: LD_VAR 0 1
19400: PUSH
19401: LD_INT 4900
19403: GREATER
19404: IFFALSE 19414
// time := 0 0$50 ;
19406: LD_ADDR_VAR 0 1
19410: PUSH
19411: LD_INT 1750
19413: ST_TO_ADDR
// until false ;
19414: LD_INT 0
19416: IFFALSE 19007
// end ;
19418: PPOPN 1
19420: END
// every 0 0$45 trigger tick < 10 10$00 do
19421: LD_OWVAR 1
19425: PUSH
19426: LD_INT 21000
19428: LESS
19429: IFFALSE 19477
19431: GO 19433
19433: DISABLE
// begin enable ;
19434: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19435: LD_INT 350
19437: PPUSH
19438: LD_INT 700
19440: PPUSH
19441: CALL_OW 12
19445: PPUSH
19446: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
19450: LD_INT 3
19452: PPUSH
19453: LD_INT 5
19455: PPUSH
19456: CALL_OW 12
19460: PPUSH
19461: LD_INT 181
19463: PPUSH
19464: LD_INT 13
19466: PPUSH
19467: LD_INT 20
19469: PPUSH
19470: LD_INT 1
19472: PPUSH
19473: CALL_OW 56
// end ; end_of_file
19477: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
19478: LD_INT 0
19480: PPUSH
// SetArtifactRes ( 7 , true ) ;
19481: LD_INT 7
19483: PPUSH
19484: LD_INT 1
19486: PPUSH
19487: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
19491: LD_ADDR_EXP 66
19495: PUSH
19496: EMPTY
19497: PUSH
19498: EMPTY
19499: PUSH
19500: EMPTY
19501: PUSH
19502: EMPTY
19503: LIST
19504: LIST
19505: LIST
19506: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
19507: LD_ADDR_EXP 67
19511: PUSH
19512: LD_INT 1050
19514: PUSH
19515: LD_OWVAR 67
19519: MUL
19520: PUSH
19521: LD_INT 2800
19523: PUSH
19524: LD_OWVAR 67
19528: MUL
19529: PUSH
19530: LD_INT 1
19532: NEG
19533: PUSH
19534: EMPTY
19535: LIST
19536: LIST
19537: LIST
19538: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
19539: LD_ADDR_EXP 68
19543: PUSH
19544: LD_INT 10
19546: PUSH
19547: LD_INT 35
19549: PUSH
19550: LD_INT 100
19552: PUSH
19553: EMPTY
19554: LIST
19555: LIST
19556: LIST
19557: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
19558: LD_ADDR_EXP 69
19562: PUSH
19563: LD_INT 0
19565: PUSH
19566: LD_INT 0
19568: PUSH
19569: LD_INT 0
19571: PUSH
19572: EMPTY
19573: LIST
19574: LIST
19575: LIST
19576: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
19577: LD_ADDR_EXP 71
19581: PUSH
19582: LD_INT 300
19584: PUSH
19585: LD_INT 500
19587: PUSH
19588: LD_INT 800
19590: PUSH
19591: EMPTY
19592: LIST
19593: LIST
19594: LIST
19595: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
19596: LD_ADDR_EXP 72
19600: PUSH
19601: LD_INT 0
19603: PUSH
19604: LD_INT 0
19606: PUSH
19607: LD_INT 0
19609: PUSH
19610: EMPTY
19611: LIST
19612: LIST
19613: LIST
19614: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
19615: LD_ADDR_EXP 73
19619: PUSH
19620: LD_INT 0
19622: PUSH
19623: LD_INT 0
19625: PUSH
19626: LD_INT 0
19628: PUSH
19629: EMPTY
19630: LIST
19631: LIST
19632: LIST
19633: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
19634: LD_ADDR_EXP 70
19638: PUSH
19639: LD_INT 0
19641: PUSH
19642: LD_INT 0
19644: PUSH
19645: LD_INT 0
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
19653: LD_ADDR_EXP 74
19657: PUSH
19658: LD_INT 4
19660: PUSH
19661: LD_INT 3
19663: PUSH
19664: LD_INT 1
19666: PUSH
19667: EMPTY
19668: LIST
19669: LIST
19670: LIST
19671: PUSH
19672: LD_INT 5
19674: PUSH
19675: LD_INT 4
19677: PUSH
19678: LD_INT 2
19680: PUSH
19681: EMPTY
19682: LIST
19683: LIST
19684: LIST
19685: PUSH
19686: LD_INT 6
19688: PUSH
19689: LD_INT 3
19691: PUSH
19692: LD_INT 3
19694: PUSH
19695: EMPTY
19696: LIST
19697: LIST
19698: LIST
19699: PUSH
19700: EMPTY
19701: LIST
19702: LIST
19703: LIST
19704: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
19705: LD_ADDR_EXP 75
19709: PUSH
19710: LD_INT 0
19712: PUSH
19713: LD_INT 0
19715: PUSH
19716: LD_INT 0
19718: PUSH
19719: EMPTY
19720: LIST
19721: LIST
19722: LIST
19723: ST_TO_ADDR
// end ;
19724: LD_VAR 0 1
19728: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
19729: LD_INT 24
19731: PPUSH
19732: LD_INT 7
19734: PPUSH
19735: CALL_OW 321
19739: PUSH
19740: LD_INT 2
19742: EQUAL
19743: IFFALSE 20669
19745: GO 19747
19747: DISABLE
19748: LD_INT 0
19750: PPUSH
19751: PPUSH
19752: PPUSH
19753: PPUSH
19754: PPUSH
// begin enable ;
19755: ENABLE
// for i = 1 to 3 do
19756: LD_ADDR_VAR 0 1
19760: PUSH
19761: DOUBLE
19762: LD_INT 1
19764: DEC
19765: ST_TO_ADDR
19766: LD_INT 3
19768: PUSH
19769: FOR_TO
19770: IFFALSE 20667
// begin pos := FindArtifact ( i + 2 ) ;
19772: LD_ADDR_VAR 0 2
19776: PUSH
19777: LD_VAR 0 1
19781: PUSH
19782: LD_INT 2
19784: PLUS
19785: PPUSH
19786: CALL_OW 469
19790: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
19791: LD_ADDR_EXP 66
19795: PUSH
19796: LD_EXP 66
19800: PPUSH
19801: LD_VAR 0 1
19805: PPUSH
19806: LD_VAR 0 2
19810: PPUSH
19811: CALL_OW 1
19815: ST_TO_ADDR
// if pos then
19816: LD_VAR 0 2
19820: IFFALSE 20528
// begin case i of 1 :
19822: LD_VAR 0 1
19826: PUSH
19827: LD_INT 1
19829: DOUBLE
19830: EQUAL
19831: IFTRUE 19835
19833: GO 19912
19835: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
19836: LD_ADDR_VAR 0 4
19840: PUSH
19841: LD_INT 22
19843: PUSH
19844: LD_INT 7
19846: PUSH
19847: EMPTY
19848: LIST
19849: LIST
19850: PUSH
19851: LD_INT 23
19853: PUSH
19854: LD_INT 1
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: PUSH
19861: LD_INT 2
19863: PUSH
19864: LD_INT 30
19866: PUSH
19867: LD_INT 8
19869: PUSH
19870: EMPTY
19871: LIST
19872: LIST
19873: PUSH
19874: LD_INT 30
19876: PUSH
19877: LD_INT 7
19879: PUSH
19880: EMPTY
19881: LIST
19882: LIST
19883: PUSH
19884: LD_INT 30
19886: PUSH
19887: LD_INT 11
19889: PUSH
19890: EMPTY
19891: LIST
19892: LIST
19893: PUSH
19894: EMPTY
19895: LIST
19896: LIST
19897: LIST
19898: LIST
19899: PUSH
19900: EMPTY
19901: LIST
19902: LIST
19903: LIST
19904: PPUSH
19905: CALL_OW 69
19909: ST_TO_ADDR
19910: GO 20020
19912: LD_INT 2
19914: DOUBLE
19915: EQUAL
19916: IFTRUE 19920
19918: GO 19997
19920: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
19921: LD_ADDR_VAR 0 4
19925: PUSH
19926: LD_INT 22
19928: PUSH
19929: LD_INT 7
19931: PUSH
19932: EMPTY
19933: LIST
19934: LIST
19935: PUSH
19936: LD_INT 23
19938: PUSH
19939: LD_INT 3
19941: PUSH
19942: EMPTY
19943: LIST
19944: LIST
19945: PUSH
19946: LD_INT 2
19948: PUSH
19949: LD_INT 30
19951: PUSH
19952: LD_INT 8
19954: PUSH
19955: EMPTY
19956: LIST
19957: LIST
19958: PUSH
19959: LD_INT 30
19961: PUSH
19962: LD_INT 7
19964: PUSH
19965: EMPTY
19966: LIST
19967: LIST
19968: PUSH
19969: LD_INT 30
19971: PUSH
19972: LD_INT 11
19974: PUSH
19975: EMPTY
19976: LIST
19977: LIST
19978: PUSH
19979: EMPTY
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: LIST
19989: PPUSH
19990: CALL_OW 69
19994: ST_TO_ADDR
19995: GO 20020
19997: LD_INT 3
19999: DOUBLE
20000: EQUAL
20001: IFTRUE 20005
20003: GO 20019
20005: POP
// labs := [ alien ] ; end ;
20006: LD_ADDR_VAR 0 4
20010: PUSH
20011: LD_INT 1
20013: PUSH
20014: EMPTY
20015: LIST
20016: ST_TO_ADDR
20017: GO 20020
20019: POP
// if not labs then
20020: LD_VAR 0 4
20024: NOT
20025: IFFALSE 20029
// continue ;
20027: GO 19769
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
20029: LD_ADDR_VAR 0 5
20033: PUSH
20034: LD_VAR 0 4
20038: PPUSH
20039: LD_EXP 66
20043: PUSH
20044: LD_VAR 0 1
20048: ARRAY
20049: PUSH
20050: LD_INT 1
20052: ARRAY
20053: PPUSH
20054: LD_EXP 66
20058: PUSH
20059: LD_VAR 0 1
20063: ARRAY
20064: PUSH
20065: LD_INT 2
20067: ARRAY
20068: PPUSH
20069: CALL_OW 73
20073: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
20074: LD_VAR 0 5
20078: NOT
20079: PUSH
20080: LD_VAR 0 5
20084: PUSH
20085: LD_EXP 73
20089: PUSH
20090: LD_VAR 0 1
20094: ARRAY
20095: NONEQUAL
20096: OR
20097: IFFALSE 20202
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20099: LD_INT 7
20101: PPUSH
20102: LD_EXP 74
20106: PUSH
20107: LD_VAR 0 1
20111: ARRAY
20112: PUSH
20113: LD_INT 3
20115: ARRAY
20116: PPUSH
20117: LD_INT 0
20119: PPUSH
20120: LD_EXP 73
20124: PUSH
20125: LD_VAR 0 1
20129: ARRAY
20130: PPUSH
20131: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20135: LD_INT 7
20137: PPUSH
20138: LD_EXP 74
20142: PUSH
20143: LD_VAR 0 1
20147: ARRAY
20148: PUSH
20149: LD_INT 1
20151: ARRAY
20152: PPUSH
20153: LD_INT 0
20155: PPUSH
20156: LD_EXP 73
20160: PUSH
20161: LD_VAR 0 1
20165: ARRAY
20166: PPUSH
20167: CALL_OW 468
// if nearestLab then
20171: LD_VAR 0 5
20175: IFFALSE 20202
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20177: LD_ADDR_EXP 73
20181: PUSH
20182: LD_EXP 73
20186: PPUSH
20187: LD_VAR 0 1
20191: PPUSH
20192: LD_VAR 0 5
20196: PPUSH
20197: CALL_OW 1
20201: ST_TO_ADDR
// end ; if not nearestLab then
20202: LD_VAR 0 5
20206: NOT
20207: IFFALSE 20211
// continue ;
20209: GO 19769
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20211: LD_VAR 0 5
20215: PPUSH
20216: LD_EXP 66
20220: PUSH
20221: LD_VAR 0 1
20225: ARRAY
20226: PUSH
20227: LD_INT 1
20229: ARRAY
20230: PPUSH
20231: LD_EXP 66
20235: PUSH
20236: LD_VAR 0 1
20240: ARRAY
20241: PUSH
20242: LD_INT 2
20244: ARRAY
20245: PPUSH
20246: CALL_OW 297
20250: PUSH
20251: LD_INT 8
20253: LESS
20254: IFFALSE 20451
// begin if not artifactsResearched [ i ] then
20256: LD_EXP 69
20260: PUSH
20261: LD_VAR 0 1
20265: ARRAY
20266: NOT
20267: IFFALSE 20348
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20269: LD_VAR 0 5
20273: PPUSH
20274: CALL_OW 461
20278: PUSH
20279: LD_INT 2
20281: EQUAL
20282: IFFALSE 20316
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20284: LD_INT 7
20286: PPUSH
20287: LD_EXP 74
20291: PUSH
20292: LD_VAR 0 1
20296: ARRAY
20297: PUSH
20298: LD_INT 3
20300: ARRAY
20301: PPUSH
20302: LD_INT 2
20304: PPUSH
20305: LD_VAR 0 5
20309: PPUSH
20310: CALL_OW 468
20314: GO 20346
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20316: LD_INT 7
20318: PPUSH
20319: LD_EXP 74
20323: PUSH
20324: LD_VAR 0 1
20328: ARRAY
20329: PUSH
20330: LD_INT 3
20332: ARRAY
20333: PPUSH
20334: LD_INT 1
20336: PPUSH
20337: LD_VAR 0 5
20341: PPUSH
20342: CALL_OW 468
// end else
20346: GO 20449
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
20348: LD_VAR 0 5
20352: PPUSH
20353: CALL_OW 461
20357: PUSH
20358: LD_INT 2
20360: EQUAL
20361: PUSH
20362: LD_EXP 75
20366: PUSH
20367: LD_VAR 0 1
20371: ARRAY
20372: AND
20373: IFFALSE 20419
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
20375: LD_INT 7
20377: PPUSH
20378: LD_EXP 74
20382: PUSH
20383: LD_VAR 0 1
20387: ARRAY
20388: PUSH
20389: LD_INT 1
20391: ARRAY
20392: PPUSH
20393: LD_EXP 74
20397: PUSH
20398: LD_VAR 0 1
20402: ARRAY
20403: PUSH
20404: LD_INT 2
20406: ARRAY
20407: PPUSH
20408: LD_VAR 0 5
20412: PPUSH
20413: CALL_OW 468
20417: GO 20449
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
20419: LD_INT 7
20421: PPUSH
20422: LD_EXP 74
20426: PUSH
20427: LD_VAR 0 1
20431: ARRAY
20432: PUSH
20433: LD_INT 1
20435: ARRAY
20436: PPUSH
20437: LD_INT 1
20439: PPUSH
20440: LD_VAR 0 5
20444: PPUSH
20445: CALL_OW 468
// end else
20449: GO 20526
// begin if not artifactsResearched [ i ] then
20451: LD_EXP 69
20455: PUSH
20456: LD_VAR 0 1
20460: ARRAY
20461: NOT
20462: IFFALSE 20496
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
20464: LD_INT 7
20466: PPUSH
20467: LD_EXP 74
20471: PUSH
20472: LD_VAR 0 1
20476: ARRAY
20477: PUSH
20478: LD_INT 3
20480: ARRAY
20481: PPUSH
20482: LD_INT 0
20484: PPUSH
20485: LD_VAR 0 5
20489: PPUSH
20490: CALL_OW 468
20494: GO 20526
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
20496: LD_INT 7
20498: PPUSH
20499: LD_EXP 74
20503: PUSH
20504: LD_VAR 0 1
20508: ARRAY
20509: PUSH
20510: LD_INT 1
20512: ARRAY
20513: PPUSH
20514: LD_INT 0
20516: PPUSH
20517: LD_VAR 0 5
20521: PPUSH
20522: CALL_OW 468
// end ; end else
20526: GO 20665
// begin if not artifactsLabs [ i ] then
20528: LD_EXP 73
20532: PUSH
20533: LD_VAR 0 1
20537: ARRAY
20538: NOT
20539: IFFALSE 20543
// continue ;
20541: GO 19769
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20543: LD_INT 7
20545: PPUSH
20546: LD_EXP 74
20550: PUSH
20551: LD_VAR 0 1
20555: ARRAY
20556: PUSH
20557: LD_INT 3
20559: ARRAY
20560: PPUSH
20561: LD_INT 0
20563: PPUSH
20564: LD_EXP 73
20568: PUSH
20569: LD_VAR 0 1
20573: ARRAY
20574: PPUSH
20575: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20579: LD_INT 7
20581: PPUSH
20582: LD_EXP 74
20586: PUSH
20587: LD_VAR 0 1
20591: ARRAY
20592: PUSH
20593: LD_INT 1
20595: ARRAY
20596: PPUSH
20597: LD_INT 0
20599: PPUSH
20600: LD_EXP 73
20604: PUSH
20605: LD_VAR 0 1
20609: ARRAY
20610: PPUSH
20611: CALL_OW 468
// if artifactsLabsWorking [ i ] then
20615: LD_EXP 70
20619: PUSH
20620: LD_VAR 0 1
20624: ARRAY
20625: IFFALSE 20665
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
20627: LD_ADDR_EXP 70
20631: PUSH
20632: LD_EXP 70
20636: PPUSH
20637: LD_VAR 0 1
20641: PPUSH
20642: LD_INT 0
20644: PPUSH
20645: CALL_OW 1
20649: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
20650: LD_EXP 73
20654: PUSH
20655: LD_VAR 0 1
20659: ARRAY
20660: PPUSH
20661: CALL_OW 127
// end ; end ; end ;
20665: GO 19769
20667: POP
20668: POP
// end ;
20669: PPOPN 5
20671: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
20672: LD_INT 0
20674: PPUSH
20675: PPUSH
20676: PPUSH
20677: PPUSH
20678: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
20679: LD_VAR 0 2
20683: PUSH
20684: LD_EXP 74
20688: PUSH
20689: LD_INT 1
20691: ARRAY
20692: PUSH
20693: LD_INT 3
20695: ARRAY
20696: EQUAL
20697: IFFALSE 20820
// begin lab := artifactsLabs [ 1 ] ;
20699: LD_ADDR_VAR 0 6
20703: PUSH
20704: LD_EXP 73
20708: PUSH
20709: LD_INT 1
20711: ARRAY
20712: ST_TO_ADDR
// if not lab then
20713: LD_VAR 0 6
20717: NOT
20718: IFFALSE 20722
// exit ;
20720: GO 21800
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
20722: LD_VAR 0 6
20726: PPUSH
20727: LD_EXP 71
20731: PUSH
20732: LD_INT 1
20734: ARRAY
20735: PPUSH
20736: LD_INT 1
20738: PPUSH
20739: CALL_OW 486
// if artifactsResProgress [ 1 ] then
20743: LD_EXP 72
20747: PUSH
20748: LD_INT 1
20750: ARRAY
20751: IFFALSE 20771
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
20753: LD_VAR 0 6
20757: PPUSH
20758: LD_EXP 72
20762: PUSH
20763: LD_INT 1
20765: ARRAY
20766: PPUSH
20767: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
20771: LD_ADDR_EXP 70
20775: PUSH
20776: LD_EXP 70
20780: PPUSH
20781: LD_INT 1
20783: PPUSH
20784: LD_INT 1
20786: PPUSH
20787: CALL_OW 1
20791: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
20792: LD_INT 7
20794: PPUSH
20795: LD_EXP 74
20799: PUSH
20800: LD_INT 1
20802: ARRAY
20803: PUSH
20804: LD_INT 3
20806: ARRAY
20807: PPUSH
20808: LD_INT 0
20810: PPUSH
20811: LD_VAR 0 6
20815: PPUSH
20816: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
20820: LD_VAR 0 2
20824: PUSH
20825: LD_EXP 74
20829: PUSH
20830: LD_INT 2
20832: ARRAY
20833: PUSH
20834: LD_INT 3
20836: ARRAY
20837: EQUAL
20838: IFFALSE 20961
// begin lab := artifactsLabs [ 2 ] ;
20840: LD_ADDR_VAR 0 6
20844: PUSH
20845: LD_EXP 73
20849: PUSH
20850: LD_INT 2
20852: ARRAY
20853: ST_TO_ADDR
// if not lab then
20854: LD_VAR 0 6
20858: NOT
20859: IFFALSE 20863
// exit ;
20861: GO 21800
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
20863: LD_VAR 0 6
20867: PPUSH
20868: LD_EXP 71
20872: PUSH
20873: LD_INT 2
20875: ARRAY
20876: PPUSH
20877: LD_INT 1
20879: PPUSH
20880: CALL_OW 486
// if artifactsResProgress [ 2 ] then
20884: LD_EXP 72
20888: PUSH
20889: LD_INT 2
20891: ARRAY
20892: IFFALSE 20912
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
20894: LD_VAR 0 6
20898: PPUSH
20899: LD_EXP 72
20903: PUSH
20904: LD_INT 2
20906: ARRAY
20907: PPUSH
20908: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
20912: LD_ADDR_EXP 70
20916: PUSH
20917: LD_EXP 70
20921: PPUSH
20922: LD_INT 2
20924: PPUSH
20925: LD_INT 1
20927: PPUSH
20928: CALL_OW 1
20932: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
20933: LD_INT 7
20935: PPUSH
20936: LD_EXP 74
20940: PUSH
20941: LD_INT 2
20943: ARRAY
20944: PUSH
20945: LD_INT 3
20947: ARRAY
20948: PPUSH
20949: LD_INT 0
20951: PPUSH
20952: LD_VAR 0 6
20956: PPUSH
20957: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20961: LD_VAR 0 2
20965: PUSH
20966: LD_EXP 74
20970: PUSH
20971: LD_INT 3
20973: ARRAY
20974: PUSH
20975: LD_INT 3
20977: ARRAY
20978: EQUAL
20979: IFFALSE 21102
// begin lab := artifactsLabs [ 3 ] ;
20981: LD_ADDR_VAR 0 6
20985: PUSH
20986: LD_EXP 73
20990: PUSH
20991: LD_INT 3
20993: ARRAY
20994: ST_TO_ADDR
// if not lab then
20995: LD_VAR 0 6
20999: NOT
21000: IFFALSE 21004
// exit ;
21002: GO 21800
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
21004: LD_VAR 0 6
21008: PPUSH
21009: LD_EXP 71
21013: PUSH
21014: LD_INT 3
21016: ARRAY
21017: PPUSH
21018: LD_INT 1
21020: PPUSH
21021: CALL_OW 486
// if artifactsResProgress [ 3 ] then
21025: LD_EXP 72
21029: PUSH
21030: LD_INT 3
21032: ARRAY
21033: IFFALSE 21053
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
21035: LD_VAR 0 6
21039: PPUSH
21040: LD_EXP 72
21044: PUSH
21045: LD_INT 3
21047: ARRAY
21048: PPUSH
21049: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
21053: LD_ADDR_EXP 70
21057: PUSH
21058: LD_EXP 70
21062: PPUSH
21063: LD_INT 3
21065: PPUSH
21066: LD_INT 1
21068: PPUSH
21069: CALL_OW 1
21073: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
21074: LD_INT 7
21076: PPUSH
21077: LD_EXP 74
21081: PUSH
21082: LD_INT 3
21084: ARRAY
21085: PUSH
21086: LD_INT 3
21088: ARRAY
21089: PPUSH
21090: LD_INT 0
21092: PPUSH
21093: LD_VAR 0 6
21097: PPUSH
21098: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21102: LD_VAR 0 2
21106: PUSH
21107: LD_EXP 74
21111: PUSH
21112: LD_INT 1
21114: ARRAY
21115: PUSH
21116: LD_INT 1
21118: ARRAY
21119: EQUAL
21120: IFFALSE 21278
// begin lab := artifactsLabs [ 1 ] ;
21122: LD_ADDR_VAR 0 6
21126: PUSH
21127: LD_EXP 73
21131: PUSH
21132: LD_INT 1
21134: ARRAY
21135: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21136: LD_VAR 0 6
21140: PPUSH
21141: CALL_OW 274
21145: PPUSH
21146: CALL 90835 0 1
21150: PUSH
21151: LD_INT 3
21153: ARRAY
21154: PUSH
21155: LD_EXP 68
21159: PUSH
21160: LD_INT 1
21162: ARRAY
21163: LESS
21164: IFFALSE 21178
// begin HintSpec ( ArtifactCost , 2 ) ;
21166: LD_STRING ArtifactCost
21168: PPUSH
21169: LD_INT 2
21171: PPUSH
21172: CALL_OW 338
// exit ;
21176: GO 21800
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21178: LD_ADDR_EXP 75
21182: PUSH
21183: LD_EXP 75
21187: PPUSH
21188: LD_INT 1
21190: PPUSH
21191: LD_INT 0
21193: PPUSH
21194: CALL_OW 1
21198: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21199: LD_VAR 0 3
21203: PPUSH
21204: LD_VAR 0 4
21208: PPUSH
21209: LD_INT 7
21211: PPUSH
21212: LD_INT 12
21214: NEG
21215: PPUSH
21216: CALL_OW 330
// wait ( 0 0$30 ) ;
21220: LD_INT 1050
21222: PPUSH
21223: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21227: LD_VAR 0 3
21231: PPUSH
21232: LD_VAR 0 4
21236: PPUSH
21237: LD_INT 7
21239: PPUSH
21240: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21244: LD_EXP 67
21248: PUSH
21249: LD_INT 1
21251: ARRAY
21252: PPUSH
21253: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21257: LD_ADDR_EXP 75
21261: PUSH
21262: LD_EXP 75
21266: PPUSH
21267: LD_INT 1
21269: PPUSH
21270: LD_INT 1
21272: PPUSH
21273: CALL_OW 1
21277: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
21278: LD_VAR 0 2
21282: PUSH
21283: LD_EXP 74
21287: PUSH
21288: LD_INT 2
21290: ARRAY
21291: PUSH
21292: LD_INT 1
21294: ARRAY
21295: EQUAL
21296: IFFALSE 21533
// begin lab := artifactsLabs [ 2 ] ;
21298: LD_ADDR_VAR 0 6
21302: PUSH
21303: LD_EXP 73
21307: PUSH
21308: LD_INT 2
21310: ARRAY
21311: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
21312: LD_VAR 0 3
21316: PUSH
21317: LD_INT 81
21319: PUSH
21320: LD_INT 7
21322: PUSH
21323: EMPTY
21324: LIST
21325: LIST
21326: PUSH
21327: LD_INT 2
21329: PUSH
21330: LD_INT 32
21332: PUSH
21333: LD_INT 3
21335: PUSH
21336: EMPTY
21337: LIST
21338: LIST
21339: PUSH
21340: LD_INT 30
21342: PUSH
21343: LD_INT 28
21345: PUSH
21346: EMPTY
21347: LIST
21348: LIST
21349: PUSH
21350: LD_INT 30
21352: PUSH
21353: LD_INT 30
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: PUSH
21360: LD_INT 35
21362: PUSH
21363: LD_INT 49
21365: PUSH
21366: EMPTY
21367: LIST
21368: LIST
21369: PUSH
21370: LD_INT 34
21372: PUSH
21373: LD_INT 49
21375: PUSH
21376: EMPTY
21377: LIST
21378: LIST
21379: PUSH
21380: LD_INT 30
21382: PUSH
21383: LD_INT 21
21385: PUSH
21386: EMPTY
21387: LIST
21388: LIST
21389: PUSH
21390: EMPTY
21391: LIST
21392: LIST
21393: LIST
21394: LIST
21395: LIST
21396: LIST
21397: LIST
21398: PUSH
21399: EMPTY
21400: LIST
21401: LIST
21402: PPUSH
21403: CALL_OW 69
21407: IN
21408: NOT
21409: IFFALSE 21413
// exit ;
21411: GO 21800
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
21413: LD_VAR 0 6
21417: PPUSH
21418: CALL_OW 274
21422: PPUSH
21423: CALL 90835 0 1
21427: PUSH
21428: LD_INT 3
21430: ARRAY
21431: PUSH
21432: LD_EXP 68
21436: PUSH
21437: LD_INT 2
21439: ARRAY
21440: LESS
21441: IFFALSE 21455
// begin HintSpec ( ArtifactCost , 2 ) ;
21443: LD_STRING ArtifactCost
21445: PPUSH
21446: LD_INT 2
21448: PPUSH
21449: CALL_OW 338
// exit ;
21453: GO 21800
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
21455: LD_ADDR_EXP 75
21459: PUSH
21460: LD_EXP 75
21464: PPUSH
21465: LD_INT 2
21467: PPUSH
21468: LD_INT 0
21470: PPUSH
21471: CALL_OW 1
21475: ST_TO_ADDR
// KillUnit ( x ) ;
21476: LD_VAR 0 3
21480: PPUSH
21481: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
21485: LD_ADDR_EXP 16
21489: PUSH
21490: LD_EXP 16
21494: PUSH
21495: LD_INT 1
21497: PLUS
21498: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
21499: LD_EXP 67
21503: PUSH
21504: LD_INT 2
21506: ARRAY
21507: PPUSH
21508: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
21512: LD_ADDR_EXP 75
21516: PUSH
21517: LD_EXP 75
21521: PPUSH
21522: LD_INT 2
21524: PPUSH
21525: LD_INT 1
21527: PPUSH
21528: CALL_OW 1
21532: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
21533: LD_VAR 0 2
21537: PUSH
21538: LD_EXP 74
21542: PUSH
21543: LD_INT 3
21545: ARRAY
21546: PUSH
21547: LD_INT 1
21549: ARRAY
21550: EQUAL
21551: IFFALSE 21800
// begin lab := artifactsLabs [ 3 ] ;
21553: LD_ADDR_VAR 0 6
21557: PUSH
21558: LD_EXP 73
21562: PUSH
21563: LD_INT 3
21565: ARRAY
21566: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
21567: LD_VAR 0 6
21571: PPUSH
21572: CALL_OW 274
21576: PPUSH
21577: CALL 90835 0 1
21581: PUSH
21582: LD_INT 3
21584: ARRAY
21585: PUSH
21586: LD_EXP 68
21590: PUSH
21591: LD_INT 3
21593: ARRAY
21594: LESS
21595: IFFALSE 21609
// begin HintSpec ( ArtifactCost , 2 ) ;
21597: LD_STRING ArtifactCost
21599: PPUSH
21600: LD_INT 2
21602: PPUSH
21603: CALL_OW 338
// exit ;
21607: GO 21800
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
21609: LD_INT 37
21611: PPUSH
21612: LD_INT 1
21614: PPUSH
21615: CALL_OW 424
// time := 0 0$30 ;
21619: LD_ADDR_VAR 0 7
21623: PUSH
21624: LD_INT 1050
21626: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
21627: LD_ADDR_EXP 75
21631: PUSH
21632: LD_EXP 75
21636: PPUSH
21637: LD_INT 3
21639: PPUSH
21640: LD_INT 0
21642: PPUSH
21643: CALL_OW 1
21647: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
21648: LD_ADDR_OWVAR 47
21652: PUSH
21653: LD_STRING #Am15a-1
21655: PUSH
21656: LD_VAR 0 7
21660: PUSH
21661: EMPTY
21662: LIST
21663: LIST
21664: ST_TO_ADDR
// wait ( 0 0$1 ) ;
21665: LD_INT 35
21667: PPUSH
21668: CALL_OW 67
// time := time - 0 0$1 ;
21672: LD_ADDR_VAR 0 7
21676: PUSH
21677: LD_VAR 0 7
21681: PUSH
21682: LD_INT 35
21684: MINUS
21685: ST_TO_ADDR
// until time = 0 0$00 ;
21686: LD_VAR 0 7
21690: PUSH
21691: LD_INT 0
21693: EQUAL
21694: IFFALSE 21648
// display_strings :=  ;
21696: LD_ADDR_OWVAR 47
21700: PUSH
21701: LD_STRING 
21703: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
21704: LD_INT 37
21706: PPUSH
21707: LD_INT 0
21709: PPUSH
21710: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
21714: LD_ADDR_VAR 0 8
21718: PUSH
21719: LD_INT 37
21721: PPUSH
21722: LD_INT 3
21724: PUSH
21725: LD_INT 21
21727: PUSH
21728: LD_INT 3
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PUSH
21735: EMPTY
21736: LIST
21737: LIST
21738: PPUSH
21739: CALL_OW 70
21743: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
21744: LD_VAR 0 3
21748: PPUSH
21749: LD_VAR 0 4
21753: PPUSH
21754: CALL_OW 84
// for un in list do
21758: LD_ADDR_VAR 0 9
21762: PUSH
21763: LD_VAR 0 8
21767: PUSH
21768: FOR_IN
21769: IFFALSE 21798
// TeleportUnit ( un , x , y , 12 , true ) ;
21771: LD_VAR 0 9
21775: PPUSH
21776: LD_VAR 0 3
21780: PPUSH
21781: LD_VAR 0 4
21785: PPUSH
21786: LD_INT 12
21788: PPUSH
21789: LD_INT 1
21791: PPUSH
21792: CALL_OW 483
21796: GO 21768
21798: POP
21799: POP
// end ; end ;
21800: PPOPN 9
21802: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
21803: LD_INT 0
21805: PPUSH
21806: PPUSH
// begin labNum := 0 ;
21807: LD_ADDR_VAR 0 4
21811: PUSH
21812: LD_INT 0
21814: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21815: LD_ADDR_VAR 0 3
21819: PUSH
21820: DOUBLE
21821: LD_INT 1
21823: DEC
21824: ST_TO_ADDR
21825: LD_EXP 73
21829: PUSH
21830: FOR_TO
21831: IFFALSE 21865
// if artifactsLabs [ i ] = lab then
21833: LD_EXP 73
21837: PUSH
21838: LD_VAR 0 3
21842: ARRAY
21843: PUSH
21844: LD_VAR 0 1
21848: EQUAL
21849: IFFALSE 21863
// begin labNum := i ;
21851: LD_ADDR_VAR 0 4
21855: PUSH
21856: LD_VAR 0 3
21860: ST_TO_ADDR
// break ;
21861: GO 21865
// end ;
21863: GO 21830
21865: POP
21866: POP
// if not labNum then
21867: LD_VAR 0 4
21871: NOT
21872: IFFALSE 21876
// exit ;
21874: GO 21954
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
21876: LD_INT 7
21878: PPUSH
21879: LD_EXP 74
21883: PUSH
21884: LD_VAR 0 4
21888: ARRAY
21889: PUSH
21890: LD_INT 3
21892: ARRAY
21893: PPUSH
21894: LD_INT 2
21896: PPUSH
21897: LD_VAR 0 1
21901: PPUSH
21902: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
21906: LD_ADDR_EXP 72
21910: PUSH
21911: LD_EXP 72
21915: PPUSH
21916: LD_VAR 0 4
21920: PPUSH
21921: LD_VAR 0 2
21925: PPUSH
21926: CALL_OW 1
21930: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
21931: LD_ADDR_EXP 70
21935: PUSH
21936: LD_EXP 70
21940: PPUSH
21941: LD_VAR 0 4
21945: PPUSH
21946: LD_INT 0
21948: PPUSH
21949: CALL_OW 1
21953: ST_TO_ADDR
// end ;
21954: PPOPN 4
21956: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21957: LD_INT 0
21959: PPUSH
21960: PPUSH
// begin labNum := 0 ;
21961: LD_ADDR_VAR 0 3
21965: PUSH
21966: LD_INT 0
21968: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21969: LD_ADDR_VAR 0 2
21973: PUSH
21974: DOUBLE
21975: LD_INT 1
21977: DEC
21978: ST_TO_ADDR
21979: LD_EXP 73
21983: PUSH
21984: FOR_TO
21985: IFFALSE 22019
// if artifactsLabs [ i ] = lab then
21987: LD_EXP 73
21991: PUSH
21992: LD_VAR 0 2
21996: ARRAY
21997: PUSH
21998: LD_VAR 0 1
22002: EQUAL
22003: IFFALSE 22017
// begin labNum := i ;
22005: LD_ADDR_VAR 0 3
22009: PUSH
22010: LD_VAR 0 2
22014: ST_TO_ADDR
// break ;
22015: GO 22019
// end ;
22017: GO 21984
22019: POP
22020: POP
// if not labNum then
22021: LD_VAR 0 3
22025: NOT
22026: IFFALSE 22030
// exit ;
22028: GO 22192
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
22030: LD_INT 7
22032: PPUSH
22033: LD_EXP 74
22037: PUSH
22038: LD_VAR 0 3
22042: ARRAY
22043: PUSH
22044: LD_INT 3
22046: ARRAY
22047: PPUSH
22048: LD_INT 0
22050: PPUSH
22051: LD_VAR 0 1
22055: PPUSH
22056: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
22060: LD_ADDR_EXP 69
22064: PUSH
22065: LD_EXP 69
22069: PPUSH
22070: LD_VAR 0 3
22074: PPUSH
22075: LD_INT 1
22077: PPUSH
22078: CALL_OW 1
22082: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22083: LD_ADDR_EXP 75
22087: PUSH
22088: LD_EXP 75
22092: PPUSH
22093: LD_VAR 0 3
22097: PPUSH
22098: LD_INT 1
22100: PPUSH
22101: CALL_OW 1
22105: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22106: LD_ADDR_EXP 70
22110: PUSH
22111: LD_EXP 70
22115: PPUSH
22116: LD_VAR 0 3
22120: PPUSH
22121: LD_INT 0
22123: PPUSH
22124: CALL_OW 1
22128: ST_TO_ADDR
// case labNum of 1 :
22129: LD_VAR 0 3
22133: PUSH
22134: LD_INT 1
22136: DOUBLE
22137: EQUAL
22138: IFTRUE 22142
22140: GO 22153
22142: POP
// artifactIResearched := true ; 2 :
22143: LD_ADDR_EXP 12
22147: PUSH
22148: LD_INT 1
22150: ST_TO_ADDR
22151: GO 22192
22153: LD_INT 2
22155: DOUBLE
22156: EQUAL
22157: IFTRUE 22161
22159: GO 22172
22161: POP
// artifactIIResearched := true ; 3 :
22162: LD_ADDR_EXP 13
22166: PUSH
22167: LD_INT 1
22169: ST_TO_ADDR
22170: GO 22192
22172: LD_INT 3
22174: DOUBLE
22175: EQUAL
22176: IFTRUE 22180
22178: GO 22191
22180: POP
// artifactIIIResearched := true ; end ;
22181: LD_ADDR_EXP 14
22185: PUSH
22186: LD_INT 1
22188: ST_TO_ADDR
22189: GO 22192
22191: POP
// end ; end_of_file
22192: PPOPN 3
22194: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
22195: LD_INT 0
22197: PPUSH
22198: PPUSH
// skirmish := false ;
22199: LD_ADDR_EXP 76
22203: PUSH
22204: LD_INT 0
22206: ST_TO_ADDR
// debug_mc := false ;
22207: LD_ADDR_EXP 77
22211: PUSH
22212: LD_INT 0
22214: ST_TO_ADDR
// mc_bases := [ ] ;
22215: LD_ADDR_EXP 78
22219: PUSH
22220: EMPTY
22221: ST_TO_ADDR
// mc_sides := [ ] ;
22222: LD_ADDR_EXP 104
22226: PUSH
22227: EMPTY
22228: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
22229: LD_ADDR_EXP 79
22233: PUSH
22234: EMPTY
22235: ST_TO_ADDR
// mc_building_repairs := [ ] ;
22236: LD_ADDR_EXP 80
22240: PUSH
22241: EMPTY
22242: ST_TO_ADDR
// mc_need_heal := [ ] ;
22243: LD_ADDR_EXP 81
22247: PUSH
22248: EMPTY
22249: ST_TO_ADDR
// mc_healers := [ ] ;
22250: LD_ADDR_EXP 82
22254: PUSH
22255: EMPTY
22256: ST_TO_ADDR
// mc_build_list := [ ] ;
22257: LD_ADDR_EXP 83
22261: PUSH
22262: EMPTY
22263: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
22264: LD_ADDR_EXP 110
22268: PUSH
22269: EMPTY
22270: ST_TO_ADDR
// mc_builders := [ ] ;
22271: LD_ADDR_EXP 84
22275: PUSH
22276: EMPTY
22277: ST_TO_ADDR
// mc_construct_list := [ ] ;
22278: LD_ADDR_EXP 85
22282: PUSH
22283: EMPTY
22284: ST_TO_ADDR
// mc_turret_list := [ ] ;
22285: LD_ADDR_EXP 86
22289: PUSH
22290: EMPTY
22291: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
22292: LD_ADDR_EXP 87
22296: PUSH
22297: EMPTY
22298: ST_TO_ADDR
// mc_miners := [ ] ;
22299: LD_ADDR_EXP 92
22303: PUSH
22304: EMPTY
22305: ST_TO_ADDR
// mc_mines := [ ] ;
22306: LD_ADDR_EXP 91
22310: PUSH
22311: EMPTY
22312: ST_TO_ADDR
// mc_minefields := [ ] ;
22313: LD_ADDR_EXP 93
22317: PUSH
22318: EMPTY
22319: ST_TO_ADDR
// mc_crates := [ ] ;
22320: LD_ADDR_EXP 94
22324: PUSH
22325: EMPTY
22326: ST_TO_ADDR
// mc_crates_collector := [ ] ;
22327: LD_ADDR_EXP 95
22331: PUSH
22332: EMPTY
22333: ST_TO_ADDR
// mc_crates_area := [ ] ;
22334: LD_ADDR_EXP 96
22338: PUSH
22339: EMPTY
22340: ST_TO_ADDR
// mc_vehicles := [ ] ;
22341: LD_ADDR_EXP 97
22345: PUSH
22346: EMPTY
22347: ST_TO_ADDR
// mc_attack := [ ] ;
22348: LD_ADDR_EXP 98
22352: PUSH
22353: EMPTY
22354: ST_TO_ADDR
// mc_produce := [ ] ;
22355: LD_ADDR_EXP 99
22359: PUSH
22360: EMPTY
22361: ST_TO_ADDR
// mc_defender := [ ] ;
22362: LD_ADDR_EXP 100
22366: PUSH
22367: EMPTY
22368: ST_TO_ADDR
// mc_parking := [ ] ;
22369: LD_ADDR_EXP 102
22373: PUSH
22374: EMPTY
22375: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
22376: LD_ADDR_EXP 88
22380: PUSH
22381: EMPTY
22382: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
22383: LD_ADDR_EXP 90
22387: PUSH
22388: EMPTY
22389: ST_TO_ADDR
// mc_scan := [ ] ;
22390: LD_ADDR_EXP 101
22394: PUSH
22395: EMPTY
22396: ST_TO_ADDR
// mc_scan_area := [ ] ;
22397: LD_ADDR_EXP 103
22401: PUSH
22402: EMPTY
22403: ST_TO_ADDR
// mc_tech := [ ] ;
22404: LD_ADDR_EXP 105
22408: PUSH
22409: EMPTY
22410: ST_TO_ADDR
// mc_class := [ ] ;
22411: LD_ADDR_EXP 119
22415: PUSH
22416: EMPTY
22417: ST_TO_ADDR
// mc_class_case_use := [ ] ;
22418: LD_ADDR_EXP 120
22422: PUSH
22423: EMPTY
22424: ST_TO_ADDR
// mc_is_defending := [ ] ;
22425: LD_ADDR_EXP 121
22429: PUSH
22430: EMPTY
22431: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
22432: LD_ADDR_EXP 112
22436: PUSH
22437: EMPTY
22438: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
22439: LD_ADDR_EXP 122
22443: PUSH
22444: LD_INT 0
22446: ST_TO_ADDR
// end ;
22447: LD_VAR 0 1
22451: RET
// export function MC_Kill ( base ) ; begin
22452: LD_INT 0
22454: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
22455: LD_ADDR_EXP 78
22459: PUSH
22460: LD_EXP 78
22464: PPUSH
22465: LD_VAR 0 1
22469: PPUSH
22470: EMPTY
22471: PPUSH
22472: CALL_OW 1
22476: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22477: LD_ADDR_EXP 79
22481: PUSH
22482: LD_EXP 79
22486: PPUSH
22487: LD_VAR 0 1
22491: PPUSH
22492: EMPTY
22493: PPUSH
22494: CALL_OW 1
22498: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22499: LD_ADDR_EXP 80
22503: PUSH
22504: LD_EXP 80
22508: PPUSH
22509: LD_VAR 0 1
22513: PPUSH
22514: EMPTY
22515: PPUSH
22516: CALL_OW 1
22520: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22521: LD_ADDR_EXP 81
22525: PUSH
22526: LD_EXP 81
22530: PPUSH
22531: LD_VAR 0 1
22535: PPUSH
22536: EMPTY
22537: PPUSH
22538: CALL_OW 1
22542: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22543: LD_ADDR_EXP 82
22547: PUSH
22548: LD_EXP 82
22552: PPUSH
22553: LD_VAR 0 1
22557: PPUSH
22558: EMPTY
22559: PPUSH
22560: CALL_OW 1
22564: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22565: LD_ADDR_EXP 83
22569: PUSH
22570: LD_EXP 83
22574: PPUSH
22575: LD_VAR 0 1
22579: PPUSH
22580: EMPTY
22581: PPUSH
22582: CALL_OW 1
22586: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22587: LD_ADDR_EXP 84
22591: PUSH
22592: LD_EXP 84
22596: PPUSH
22597: LD_VAR 0 1
22601: PPUSH
22602: EMPTY
22603: PPUSH
22604: CALL_OW 1
22608: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22609: LD_ADDR_EXP 85
22613: PUSH
22614: LD_EXP 85
22618: PPUSH
22619: LD_VAR 0 1
22623: PPUSH
22624: EMPTY
22625: PPUSH
22626: CALL_OW 1
22630: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22631: LD_ADDR_EXP 86
22635: PUSH
22636: LD_EXP 86
22640: PPUSH
22641: LD_VAR 0 1
22645: PPUSH
22646: EMPTY
22647: PPUSH
22648: CALL_OW 1
22652: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22653: LD_ADDR_EXP 87
22657: PUSH
22658: LD_EXP 87
22662: PPUSH
22663: LD_VAR 0 1
22667: PPUSH
22668: EMPTY
22669: PPUSH
22670: CALL_OW 1
22674: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22675: LD_ADDR_EXP 88
22679: PUSH
22680: LD_EXP 88
22684: PPUSH
22685: LD_VAR 0 1
22689: PPUSH
22690: EMPTY
22691: PPUSH
22692: CALL_OW 1
22696: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22697: LD_ADDR_EXP 89
22701: PUSH
22702: LD_EXP 89
22706: PPUSH
22707: LD_VAR 0 1
22711: PPUSH
22712: LD_INT 0
22714: PPUSH
22715: CALL_OW 1
22719: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22720: LD_ADDR_EXP 90
22724: PUSH
22725: LD_EXP 90
22729: PPUSH
22730: LD_VAR 0 1
22734: PPUSH
22735: EMPTY
22736: PPUSH
22737: CALL_OW 1
22741: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22742: LD_ADDR_EXP 91
22746: PUSH
22747: LD_EXP 91
22751: PPUSH
22752: LD_VAR 0 1
22756: PPUSH
22757: EMPTY
22758: PPUSH
22759: CALL_OW 1
22763: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22764: LD_ADDR_EXP 92
22768: PUSH
22769: LD_EXP 92
22773: PPUSH
22774: LD_VAR 0 1
22778: PPUSH
22779: EMPTY
22780: PPUSH
22781: CALL_OW 1
22785: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22786: LD_ADDR_EXP 93
22790: PUSH
22791: LD_EXP 93
22795: PPUSH
22796: LD_VAR 0 1
22800: PPUSH
22801: EMPTY
22802: PPUSH
22803: CALL_OW 1
22807: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22808: LD_ADDR_EXP 94
22812: PUSH
22813: LD_EXP 94
22817: PPUSH
22818: LD_VAR 0 1
22822: PPUSH
22823: EMPTY
22824: PPUSH
22825: CALL_OW 1
22829: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22830: LD_ADDR_EXP 95
22834: PUSH
22835: LD_EXP 95
22839: PPUSH
22840: LD_VAR 0 1
22844: PPUSH
22845: EMPTY
22846: PPUSH
22847: CALL_OW 1
22851: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22852: LD_ADDR_EXP 96
22856: PUSH
22857: LD_EXP 96
22861: PPUSH
22862: LD_VAR 0 1
22866: PPUSH
22867: EMPTY
22868: PPUSH
22869: CALL_OW 1
22873: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22874: LD_ADDR_EXP 97
22878: PUSH
22879: LD_EXP 97
22883: PPUSH
22884: LD_VAR 0 1
22888: PPUSH
22889: EMPTY
22890: PPUSH
22891: CALL_OW 1
22895: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22896: LD_ADDR_EXP 98
22900: PUSH
22901: LD_EXP 98
22905: PPUSH
22906: LD_VAR 0 1
22910: PPUSH
22911: EMPTY
22912: PPUSH
22913: CALL_OW 1
22917: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22918: LD_ADDR_EXP 99
22922: PUSH
22923: LD_EXP 99
22927: PPUSH
22928: LD_VAR 0 1
22932: PPUSH
22933: EMPTY
22934: PPUSH
22935: CALL_OW 1
22939: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22940: LD_ADDR_EXP 100
22944: PUSH
22945: LD_EXP 100
22949: PPUSH
22950: LD_VAR 0 1
22954: PPUSH
22955: EMPTY
22956: PPUSH
22957: CALL_OW 1
22961: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22962: LD_ADDR_EXP 101
22966: PUSH
22967: LD_EXP 101
22971: PPUSH
22972: LD_VAR 0 1
22976: PPUSH
22977: EMPTY
22978: PPUSH
22979: CALL_OW 1
22983: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22984: LD_ADDR_EXP 102
22988: PUSH
22989: LD_EXP 102
22993: PPUSH
22994: LD_VAR 0 1
22998: PPUSH
22999: EMPTY
23000: PPUSH
23001: CALL_OW 1
23005: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23006: LD_ADDR_EXP 103
23010: PUSH
23011: LD_EXP 103
23015: PPUSH
23016: LD_VAR 0 1
23020: PPUSH
23021: EMPTY
23022: PPUSH
23023: CALL_OW 1
23027: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23028: LD_ADDR_EXP 105
23032: PUSH
23033: LD_EXP 105
23037: PPUSH
23038: LD_VAR 0 1
23042: PPUSH
23043: EMPTY
23044: PPUSH
23045: CALL_OW 1
23049: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23050: LD_ADDR_EXP 107
23054: PUSH
23055: LD_EXP 107
23059: PPUSH
23060: LD_VAR 0 1
23064: PPUSH
23065: EMPTY
23066: PPUSH
23067: CALL_OW 1
23071: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23072: LD_ADDR_EXP 108
23076: PUSH
23077: LD_EXP 108
23081: PPUSH
23082: LD_VAR 0 1
23086: PPUSH
23087: EMPTY
23088: PPUSH
23089: CALL_OW 1
23093: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23094: LD_ADDR_EXP 109
23098: PUSH
23099: LD_EXP 109
23103: PPUSH
23104: LD_VAR 0 1
23108: PPUSH
23109: EMPTY
23110: PPUSH
23111: CALL_OW 1
23115: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23116: LD_ADDR_EXP 110
23120: PUSH
23121: LD_EXP 110
23125: PPUSH
23126: LD_VAR 0 1
23130: PPUSH
23131: EMPTY
23132: PPUSH
23133: CALL_OW 1
23137: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23138: LD_ADDR_EXP 111
23142: PUSH
23143: LD_EXP 111
23147: PPUSH
23148: LD_VAR 0 1
23152: PPUSH
23153: EMPTY
23154: PPUSH
23155: CALL_OW 1
23159: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23160: LD_ADDR_EXP 112
23164: PUSH
23165: LD_EXP 112
23169: PPUSH
23170: LD_VAR 0 1
23174: PPUSH
23175: EMPTY
23176: PPUSH
23177: CALL_OW 1
23181: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23182: LD_ADDR_EXP 113
23186: PUSH
23187: LD_EXP 113
23191: PPUSH
23192: LD_VAR 0 1
23196: PPUSH
23197: EMPTY
23198: PPUSH
23199: CALL_OW 1
23203: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23204: LD_ADDR_EXP 114
23208: PUSH
23209: LD_EXP 114
23213: PPUSH
23214: LD_VAR 0 1
23218: PPUSH
23219: EMPTY
23220: PPUSH
23221: CALL_OW 1
23225: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23226: LD_ADDR_EXP 115
23230: PUSH
23231: LD_EXP 115
23235: PPUSH
23236: LD_VAR 0 1
23240: PPUSH
23241: EMPTY
23242: PPUSH
23243: CALL_OW 1
23247: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23248: LD_ADDR_EXP 116
23252: PUSH
23253: LD_EXP 116
23257: PPUSH
23258: LD_VAR 0 1
23262: PPUSH
23263: EMPTY
23264: PPUSH
23265: CALL_OW 1
23269: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23270: LD_ADDR_EXP 117
23274: PUSH
23275: LD_EXP 117
23279: PPUSH
23280: LD_VAR 0 1
23284: PPUSH
23285: EMPTY
23286: PPUSH
23287: CALL_OW 1
23291: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23292: LD_ADDR_EXP 118
23296: PUSH
23297: LD_EXP 118
23301: PPUSH
23302: LD_VAR 0 1
23306: PPUSH
23307: EMPTY
23308: PPUSH
23309: CALL_OW 1
23313: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23314: LD_ADDR_EXP 119
23318: PUSH
23319: LD_EXP 119
23323: PPUSH
23324: LD_VAR 0 1
23328: PPUSH
23329: EMPTY
23330: PPUSH
23331: CALL_OW 1
23335: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23336: LD_ADDR_EXP 120
23340: PUSH
23341: LD_EXP 120
23345: PPUSH
23346: LD_VAR 0 1
23350: PPUSH
23351: LD_INT 0
23353: PPUSH
23354: CALL_OW 1
23358: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23359: LD_ADDR_EXP 121
23363: PUSH
23364: LD_EXP 121
23368: PPUSH
23369: LD_VAR 0 1
23373: PPUSH
23374: LD_INT 0
23376: PPUSH
23377: CALL_OW 1
23381: ST_TO_ADDR
// end ;
23382: LD_VAR 0 2
23386: RET
// export function MC_Add ( side , units ) ; var base ; begin
23387: LD_INT 0
23389: PPUSH
23390: PPUSH
// base := mc_bases + 1 ;
23391: LD_ADDR_VAR 0 4
23395: PUSH
23396: LD_EXP 78
23400: PUSH
23401: LD_INT 1
23403: PLUS
23404: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
23405: LD_ADDR_EXP 104
23409: PUSH
23410: LD_EXP 104
23414: PPUSH
23415: LD_VAR 0 4
23419: PPUSH
23420: LD_VAR 0 1
23424: PPUSH
23425: CALL_OW 1
23429: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
23430: LD_ADDR_EXP 78
23434: PUSH
23435: LD_EXP 78
23439: PPUSH
23440: LD_VAR 0 4
23444: PPUSH
23445: LD_VAR 0 2
23449: PPUSH
23450: CALL_OW 1
23454: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23455: LD_ADDR_EXP 79
23459: PUSH
23460: LD_EXP 79
23464: PPUSH
23465: LD_VAR 0 4
23469: PPUSH
23470: EMPTY
23471: PPUSH
23472: CALL_OW 1
23476: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23477: LD_ADDR_EXP 80
23481: PUSH
23482: LD_EXP 80
23486: PPUSH
23487: LD_VAR 0 4
23491: PPUSH
23492: EMPTY
23493: PPUSH
23494: CALL_OW 1
23498: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23499: LD_ADDR_EXP 81
23503: PUSH
23504: LD_EXP 81
23508: PPUSH
23509: LD_VAR 0 4
23513: PPUSH
23514: EMPTY
23515: PPUSH
23516: CALL_OW 1
23520: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23521: LD_ADDR_EXP 82
23525: PUSH
23526: LD_EXP 82
23530: PPUSH
23531: LD_VAR 0 4
23535: PPUSH
23536: EMPTY
23537: PPUSH
23538: CALL_OW 1
23542: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23543: LD_ADDR_EXP 83
23547: PUSH
23548: LD_EXP 83
23552: PPUSH
23553: LD_VAR 0 4
23557: PPUSH
23558: EMPTY
23559: PPUSH
23560: CALL_OW 1
23564: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23565: LD_ADDR_EXP 84
23569: PUSH
23570: LD_EXP 84
23574: PPUSH
23575: LD_VAR 0 4
23579: PPUSH
23580: EMPTY
23581: PPUSH
23582: CALL_OW 1
23586: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23587: LD_ADDR_EXP 85
23591: PUSH
23592: LD_EXP 85
23596: PPUSH
23597: LD_VAR 0 4
23601: PPUSH
23602: EMPTY
23603: PPUSH
23604: CALL_OW 1
23608: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23609: LD_ADDR_EXP 86
23613: PUSH
23614: LD_EXP 86
23618: PPUSH
23619: LD_VAR 0 4
23623: PPUSH
23624: EMPTY
23625: PPUSH
23626: CALL_OW 1
23630: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23631: LD_ADDR_EXP 87
23635: PUSH
23636: LD_EXP 87
23640: PPUSH
23641: LD_VAR 0 4
23645: PPUSH
23646: EMPTY
23647: PPUSH
23648: CALL_OW 1
23652: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23653: LD_ADDR_EXP 88
23657: PUSH
23658: LD_EXP 88
23662: PPUSH
23663: LD_VAR 0 4
23667: PPUSH
23668: EMPTY
23669: PPUSH
23670: CALL_OW 1
23674: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23675: LD_ADDR_EXP 89
23679: PUSH
23680: LD_EXP 89
23684: PPUSH
23685: LD_VAR 0 4
23689: PPUSH
23690: LD_INT 0
23692: PPUSH
23693: CALL_OW 1
23697: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23698: LD_ADDR_EXP 90
23702: PUSH
23703: LD_EXP 90
23707: PPUSH
23708: LD_VAR 0 4
23712: PPUSH
23713: EMPTY
23714: PPUSH
23715: CALL_OW 1
23719: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23720: LD_ADDR_EXP 91
23724: PUSH
23725: LD_EXP 91
23729: PPUSH
23730: LD_VAR 0 4
23734: PPUSH
23735: EMPTY
23736: PPUSH
23737: CALL_OW 1
23741: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23742: LD_ADDR_EXP 92
23746: PUSH
23747: LD_EXP 92
23751: PPUSH
23752: LD_VAR 0 4
23756: PPUSH
23757: EMPTY
23758: PPUSH
23759: CALL_OW 1
23763: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23764: LD_ADDR_EXP 93
23768: PUSH
23769: LD_EXP 93
23773: PPUSH
23774: LD_VAR 0 4
23778: PPUSH
23779: EMPTY
23780: PPUSH
23781: CALL_OW 1
23785: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23786: LD_ADDR_EXP 94
23790: PUSH
23791: LD_EXP 94
23795: PPUSH
23796: LD_VAR 0 4
23800: PPUSH
23801: EMPTY
23802: PPUSH
23803: CALL_OW 1
23807: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23808: LD_ADDR_EXP 95
23812: PUSH
23813: LD_EXP 95
23817: PPUSH
23818: LD_VAR 0 4
23822: PPUSH
23823: EMPTY
23824: PPUSH
23825: CALL_OW 1
23829: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23830: LD_ADDR_EXP 96
23834: PUSH
23835: LD_EXP 96
23839: PPUSH
23840: LD_VAR 0 4
23844: PPUSH
23845: EMPTY
23846: PPUSH
23847: CALL_OW 1
23851: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23852: LD_ADDR_EXP 97
23856: PUSH
23857: LD_EXP 97
23861: PPUSH
23862: LD_VAR 0 4
23866: PPUSH
23867: EMPTY
23868: PPUSH
23869: CALL_OW 1
23873: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23874: LD_ADDR_EXP 98
23878: PUSH
23879: LD_EXP 98
23883: PPUSH
23884: LD_VAR 0 4
23888: PPUSH
23889: EMPTY
23890: PPUSH
23891: CALL_OW 1
23895: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23896: LD_ADDR_EXP 99
23900: PUSH
23901: LD_EXP 99
23905: PPUSH
23906: LD_VAR 0 4
23910: PPUSH
23911: EMPTY
23912: PPUSH
23913: CALL_OW 1
23917: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23918: LD_ADDR_EXP 100
23922: PUSH
23923: LD_EXP 100
23927: PPUSH
23928: LD_VAR 0 4
23932: PPUSH
23933: EMPTY
23934: PPUSH
23935: CALL_OW 1
23939: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23940: LD_ADDR_EXP 101
23944: PUSH
23945: LD_EXP 101
23949: PPUSH
23950: LD_VAR 0 4
23954: PPUSH
23955: EMPTY
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23962: LD_ADDR_EXP 102
23966: PUSH
23967: LD_EXP 102
23971: PPUSH
23972: LD_VAR 0 4
23976: PPUSH
23977: EMPTY
23978: PPUSH
23979: CALL_OW 1
23983: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23984: LD_ADDR_EXP 103
23988: PUSH
23989: LD_EXP 103
23993: PPUSH
23994: LD_VAR 0 4
23998: PPUSH
23999: EMPTY
24000: PPUSH
24001: CALL_OW 1
24005: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
24006: LD_ADDR_EXP 105
24010: PUSH
24011: LD_EXP 105
24015: PPUSH
24016: LD_VAR 0 4
24020: PPUSH
24021: EMPTY
24022: PPUSH
24023: CALL_OW 1
24027: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
24028: LD_ADDR_EXP 107
24032: PUSH
24033: LD_EXP 107
24037: PPUSH
24038: LD_VAR 0 4
24042: PPUSH
24043: EMPTY
24044: PPUSH
24045: CALL_OW 1
24049: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24050: LD_ADDR_EXP 108
24054: PUSH
24055: LD_EXP 108
24059: PPUSH
24060: LD_VAR 0 4
24064: PPUSH
24065: EMPTY
24066: PPUSH
24067: CALL_OW 1
24071: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24072: LD_ADDR_EXP 109
24076: PUSH
24077: LD_EXP 109
24081: PPUSH
24082: LD_VAR 0 4
24086: PPUSH
24087: EMPTY
24088: PPUSH
24089: CALL_OW 1
24093: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24094: LD_ADDR_EXP 110
24098: PUSH
24099: LD_EXP 110
24103: PPUSH
24104: LD_VAR 0 4
24108: PPUSH
24109: EMPTY
24110: PPUSH
24111: CALL_OW 1
24115: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24116: LD_ADDR_EXP 111
24120: PUSH
24121: LD_EXP 111
24125: PPUSH
24126: LD_VAR 0 4
24130: PPUSH
24131: EMPTY
24132: PPUSH
24133: CALL_OW 1
24137: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24138: LD_ADDR_EXP 112
24142: PUSH
24143: LD_EXP 112
24147: PPUSH
24148: LD_VAR 0 4
24152: PPUSH
24153: EMPTY
24154: PPUSH
24155: CALL_OW 1
24159: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24160: LD_ADDR_EXP 113
24164: PUSH
24165: LD_EXP 113
24169: PPUSH
24170: LD_VAR 0 4
24174: PPUSH
24175: EMPTY
24176: PPUSH
24177: CALL_OW 1
24181: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24182: LD_ADDR_EXP 114
24186: PUSH
24187: LD_EXP 114
24191: PPUSH
24192: LD_VAR 0 4
24196: PPUSH
24197: EMPTY
24198: PPUSH
24199: CALL_OW 1
24203: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24204: LD_ADDR_EXP 115
24208: PUSH
24209: LD_EXP 115
24213: PPUSH
24214: LD_VAR 0 4
24218: PPUSH
24219: EMPTY
24220: PPUSH
24221: CALL_OW 1
24225: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24226: LD_ADDR_EXP 116
24230: PUSH
24231: LD_EXP 116
24235: PPUSH
24236: LD_VAR 0 4
24240: PPUSH
24241: EMPTY
24242: PPUSH
24243: CALL_OW 1
24247: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24248: LD_ADDR_EXP 117
24252: PUSH
24253: LD_EXP 117
24257: PPUSH
24258: LD_VAR 0 4
24262: PPUSH
24263: EMPTY
24264: PPUSH
24265: CALL_OW 1
24269: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24270: LD_ADDR_EXP 118
24274: PUSH
24275: LD_EXP 118
24279: PPUSH
24280: LD_VAR 0 4
24284: PPUSH
24285: EMPTY
24286: PPUSH
24287: CALL_OW 1
24291: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24292: LD_ADDR_EXP 119
24296: PUSH
24297: LD_EXP 119
24301: PPUSH
24302: LD_VAR 0 4
24306: PPUSH
24307: EMPTY
24308: PPUSH
24309: CALL_OW 1
24313: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24314: LD_ADDR_EXP 120
24318: PUSH
24319: LD_EXP 120
24323: PPUSH
24324: LD_VAR 0 4
24328: PPUSH
24329: LD_INT 0
24331: PPUSH
24332: CALL_OW 1
24336: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24337: LD_ADDR_EXP 121
24341: PUSH
24342: LD_EXP 121
24346: PPUSH
24347: LD_VAR 0 4
24351: PPUSH
24352: LD_INT 0
24354: PPUSH
24355: CALL_OW 1
24359: ST_TO_ADDR
// result := base ;
24360: LD_ADDR_VAR 0 3
24364: PUSH
24365: LD_VAR 0 4
24369: ST_TO_ADDR
// end ;
24370: LD_VAR 0 3
24374: RET
// export function MC_Start ( ) ; var i ; begin
24375: LD_INT 0
24377: PPUSH
24378: PPUSH
// for i = 1 to mc_bases do
24379: LD_ADDR_VAR 0 2
24383: PUSH
24384: DOUBLE
24385: LD_INT 1
24387: DEC
24388: ST_TO_ADDR
24389: LD_EXP 78
24393: PUSH
24394: FOR_TO
24395: IFFALSE 25495
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
24397: LD_ADDR_EXP 78
24401: PUSH
24402: LD_EXP 78
24406: PPUSH
24407: LD_VAR 0 2
24411: PPUSH
24412: LD_EXP 78
24416: PUSH
24417: LD_VAR 0 2
24421: ARRAY
24422: PUSH
24423: LD_INT 0
24425: DIFF
24426: PPUSH
24427: CALL_OW 1
24431: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
24432: LD_ADDR_EXP 79
24436: PUSH
24437: LD_EXP 79
24441: PPUSH
24442: LD_VAR 0 2
24446: PPUSH
24447: EMPTY
24448: PPUSH
24449: CALL_OW 1
24453: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
24454: LD_ADDR_EXP 80
24458: PUSH
24459: LD_EXP 80
24463: PPUSH
24464: LD_VAR 0 2
24468: PPUSH
24469: EMPTY
24470: PPUSH
24471: CALL_OW 1
24475: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
24476: LD_ADDR_EXP 81
24480: PUSH
24481: LD_EXP 81
24485: PPUSH
24486: LD_VAR 0 2
24490: PPUSH
24491: EMPTY
24492: PPUSH
24493: CALL_OW 1
24497: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
24498: LD_ADDR_EXP 82
24502: PUSH
24503: LD_EXP 82
24507: PPUSH
24508: LD_VAR 0 2
24512: PPUSH
24513: EMPTY
24514: PUSH
24515: EMPTY
24516: PUSH
24517: EMPTY
24518: LIST
24519: LIST
24520: PPUSH
24521: CALL_OW 1
24525: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
24526: LD_ADDR_EXP 83
24530: PUSH
24531: LD_EXP 83
24535: PPUSH
24536: LD_VAR 0 2
24540: PPUSH
24541: EMPTY
24542: PPUSH
24543: CALL_OW 1
24547: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
24548: LD_ADDR_EXP 110
24552: PUSH
24553: LD_EXP 110
24557: PPUSH
24558: LD_VAR 0 2
24562: PPUSH
24563: EMPTY
24564: PPUSH
24565: CALL_OW 1
24569: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
24570: LD_ADDR_EXP 84
24574: PUSH
24575: LD_EXP 84
24579: PPUSH
24580: LD_VAR 0 2
24584: PPUSH
24585: EMPTY
24586: PPUSH
24587: CALL_OW 1
24591: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
24592: LD_ADDR_EXP 85
24596: PUSH
24597: LD_EXP 85
24601: PPUSH
24602: LD_VAR 0 2
24606: PPUSH
24607: EMPTY
24608: PPUSH
24609: CALL_OW 1
24613: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
24614: LD_ADDR_EXP 86
24618: PUSH
24619: LD_EXP 86
24623: PPUSH
24624: LD_VAR 0 2
24628: PPUSH
24629: LD_EXP 78
24633: PUSH
24634: LD_VAR 0 2
24638: ARRAY
24639: PPUSH
24640: LD_INT 2
24642: PUSH
24643: LD_INT 30
24645: PUSH
24646: LD_INT 32
24648: PUSH
24649: EMPTY
24650: LIST
24651: LIST
24652: PUSH
24653: LD_INT 30
24655: PUSH
24656: LD_INT 33
24658: PUSH
24659: EMPTY
24660: LIST
24661: LIST
24662: PUSH
24663: EMPTY
24664: LIST
24665: LIST
24666: LIST
24667: PPUSH
24668: CALL_OW 72
24672: PPUSH
24673: CALL_OW 1
24677: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
24678: LD_ADDR_EXP 87
24682: PUSH
24683: LD_EXP 87
24687: PPUSH
24688: LD_VAR 0 2
24692: PPUSH
24693: LD_EXP 78
24697: PUSH
24698: LD_VAR 0 2
24702: ARRAY
24703: PPUSH
24704: LD_INT 2
24706: PUSH
24707: LD_INT 30
24709: PUSH
24710: LD_INT 32
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: PUSH
24717: LD_INT 30
24719: PUSH
24720: LD_INT 31
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: LIST
24731: PUSH
24732: LD_INT 58
24734: PUSH
24735: EMPTY
24736: LIST
24737: PUSH
24738: EMPTY
24739: LIST
24740: LIST
24741: PPUSH
24742: CALL_OW 72
24746: PPUSH
24747: CALL_OW 1
24751: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
24752: LD_ADDR_EXP 88
24756: PUSH
24757: LD_EXP 88
24761: PPUSH
24762: LD_VAR 0 2
24766: PPUSH
24767: EMPTY
24768: PPUSH
24769: CALL_OW 1
24773: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
24774: LD_ADDR_EXP 92
24778: PUSH
24779: LD_EXP 92
24783: PPUSH
24784: LD_VAR 0 2
24788: PPUSH
24789: EMPTY
24790: PPUSH
24791: CALL_OW 1
24795: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
24796: LD_ADDR_EXP 91
24800: PUSH
24801: LD_EXP 91
24805: PPUSH
24806: LD_VAR 0 2
24810: PPUSH
24811: EMPTY
24812: PPUSH
24813: CALL_OW 1
24817: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24818: LD_ADDR_EXP 93
24822: PUSH
24823: LD_EXP 93
24827: PPUSH
24828: LD_VAR 0 2
24832: PPUSH
24833: EMPTY
24834: PPUSH
24835: CALL_OW 1
24839: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24840: LD_ADDR_EXP 94
24844: PUSH
24845: LD_EXP 94
24849: PPUSH
24850: LD_VAR 0 2
24854: PPUSH
24855: EMPTY
24856: PPUSH
24857: CALL_OW 1
24861: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24862: LD_ADDR_EXP 95
24866: PUSH
24867: LD_EXP 95
24871: PPUSH
24872: LD_VAR 0 2
24876: PPUSH
24877: EMPTY
24878: PPUSH
24879: CALL_OW 1
24883: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24884: LD_ADDR_EXP 96
24888: PUSH
24889: LD_EXP 96
24893: PPUSH
24894: LD_VAR 0 2
24898: PPUSH
24899: EMPTY
24900: PPUSH
24901: CALL_OW 1
24905: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24906: LD_ADDR_EXP 97
24910: PUSH
24911: LD_EXP 97
24915: PPUSH
24916: LD_VAR 0 2
24920: PPUSH
24921: EMPTY
24922: PPUSH
24923: CALL_OW 1
24927: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24928: LD_ADDR_EXP 98
24932: PUSH
24933: LD_EXP 98
24937: PPUSH
24938: LD_VAR 0 2
24942: PPUSH
24943: EMPTY
24944: PPUSH
24945: CALL_OW 1
24949: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24950: LD_ADDR_EXP 99
24954: PUSH
24955: LD_EXP 99
24959: PPUSH
24960: LD_VAR 0 2
24964: PPUSH
24965: EMPTY
24966: PPUSH
24967: CALL_OW 1
24971: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24972: LD_ADDR_EXP 100
24976: PUSH
24977: LD_EXP 100
24981: PPUSH
24982: LD_VAR 0 2
24986: PPUSH
24987: EMPTY
24988: PPUSH
24989: CALL_OW 1
24993: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24994: LD_ADDR_EXP 89
24998: PUSH
24999: LD_EXP 89
25003: PPUSH
25004: LD_VAR 0 2
25008: PPUSH
25009: LD_INT 0
25011: PPUSH
25012: CALL_OW 1
25016: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
25017: LD_ADDR_EXP 102
25021: PUSH
25022: LD_EXP 102
25026: PPUSH
25027: LD_VAR 0 2
25031: PPUSH
25032: LD_INT 0
25034: PPUSH
25035: CALL_OW 1
25039: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
25040: LD_ADDR_EXP 90
25044: PUSH
25045: LD_EXP 90
25049: PPUSH
25050: LD_VAR 0 2
25054: PPUSH
25055: EMPTY
25056: PPUSH
25057: CALL_OW 1
25061: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
25062: LD_ADDR_EXP 101
25066: PUSH
25067: LD_EXP 101
25071: PPUSH
25072: LD_VAR 0 2
25076: PPUSH
25077: LD_INT 0
25079: PPUSH
25080: CALL_OW 1
25084: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25085: LD_ADDR_EXP 103
25089: PUSH
25090: LD_EXP 103
25094: PPUSH
25095: LD_VAR 0 2
25099: PPUSH
25100: EMPTY
25101: PPUSH
25102: CALL_OW 1
25106: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25107: LD_ADDR_EXP 106
25111: PUSH
25112: LD_EXP 106
25116: PPUSH
25117: LD_VAR 0 2
25121: PPUSH
25122: LD_INT 0
25124: PPUSH
25125: CALL_OW 1
25129: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25130: LD_ADDR_EXP 107
25134: PUSH
25135: LD_EXP 107
25139: PPUSH
25140: LD_VAR 0 2
25144: PPUSH
25145: EMPTY
25146: PPUSH
25147: CALL_OW 1
25151: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25152: LD_ADDR_EXP 108
25156: PUSH
25157: LD_EXP 108
25161: PPUSH
25162: LD_VAR 0 2
25166: PPUSH
25167: EMPTY
25168: PPUSH
25169: CALL_OW 1
25173: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25174: LD_ADDR_EXP 109
25178: PUSH
25179: LD_EXP 109
25183: PPUSH
25184: LD_VAR 0 2
25188: PPUSH
25189: EMPTY
25190: PPUSH
25191: CALL_OW 1
25195: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
25196: LD_ADDR_EXP 111
25200: PUSH
25201: LD_EXP 111
25205: PPUSH
25206: LD_VAR 0 2
25210: PPUSH
25211: LD_EXP 78
25215: PUSH
25216: LD_VAR 0 2
25220: ARRAY
25221: PPUSH
25222: LD_INT 2
25224: PUSH
25225: LD_INT 30
25227: PUSH
25228: LD_INT 6
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PUSH
25235: LD_INT 30
25237: PUSH
25238: LD_INT 7
25240: PUSH
25241: EMPTY
25242: LIST
25243: LIST
25244: PUSH
25245: LD_INT 30
25247: PUSH
25248: LD_INT 8
25250: PUSH
25251: EMPTY
25252: LIST
25253: LIST
25254: PUSH
25255: EMPTY
25256: LIST
25257: LIST
25258: LIST
25259: LIST
25260: PPUSH
25261: CALL_OW 72
25265: PPUSH
25266: CALL_OW 1
25270: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
25271: LD_ADDR_EXP 112
25275: PUSH
25276: LD_EXP 112
25280: PPUSH
25281: LD_VAR 0 2
25285: PPUSH
25286: EMPTY
25287: PPUSH
25288: CALL_OW 1
25292: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
25293: LD_ADDR_EXP 113
25297: PUSH
25298: LD_EXP 113
25302: PPUSH
25303: LD_VAR 0 2
25307: PPUSH
25308: EMPTY
25309: PPUSH
25310: CALL_OW 1
25314: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
25315: LD_ADDR_EXP 114
25319: PUSH
25320: LD_EXP 114
25324: PPUSH
25325: LD_VAR 0 2
25329: PPUSH
25330: EMPTY
25331: PPUSH
25332: CALL_OW 1
25336: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
25337: LD_ADDR_EXP 115
25341: PUSH
25342: LD_EXP 115
25346: PPUSH
25347: LD_VAR 0 2
25351: PPUSH
25352: EMPTY
25353: PPUSH
25354: CALL_OW 1
25358: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
25359: LD_ADDR_EXP 116
25363: PUSH
25364: LD_EXP 116
25368: PPUSH
25369: LD_VAR 0 2
25373: PPUSH
25374: EMPTY
25375: PPUSH
25376: CALL_OW 1
25380: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
25381: LD_ADDR_EXP 117
25385: PUSH
25386: LD_EXP 117
25390: PPUSH
25391: LD_VAR 0 2
25395: PPUSH
25396: EMPTY
25397: PPUSH
25398: CALL_OW 1
25402: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
25403: LD_ADDR_EXP 118
25407: PUSH
25408: LD_EXP 118
25412: PPUSH
25413: LD_VAR 0 2
25417: PPUSH
25418: EMPTY
25419: PPUSH
25420: CALL_OW 1
25424: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
25425: LD_ADDR_EXP 119
25429: PUSH
25430: LD_EXP 119
25434: PPUSH
25435: LD_VAR 0 2
25439: PPUSH
25440: EMPTY
25441: PPUSH
25442: CALL_OW 1
25446: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
25447: LD_ADDR_EXP 120
25451: PUSH
25452: LD_EXP 120
25456: PPUSH
25457: LD_VAR 0 2
25461: PPUSH
25462: LD_INT 0
25464: PPUSH
25465: CALL_OW 1
25469: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
25470: LD_ADDR_EXP 121
25474: PUSH
25475: LD_EXP 121
25479: PPUSH
25480: LD_VAR 0 2
25484: PPUSH
25485: LD_INT 0
25487: PPUSH
25488: CALL_OW 1
25492: ST_TO_ADDR
// end ;
25493: GO 24394
25495: POP
25496: POP
// MC_InitSides ( ) ;
25497: CALL 25783 0 0
// MC_InitResearch ( ) ;
25501: CALL 25522 0 0
// CustomInitMacro ( ) ;
25505: CALL 228 0 0
// skirmish := true ;
25509: LD_ADDR_EXP 76
25513: PUSH
25514: LD_INT 1
25516: ST_TO_ADDR
// end ;
25517: LD_VAR 0 1
25521: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
25522: LD_INT 0
25524: PPUSH
25525: PPUSH
25526: PPUSH
25527: PPUSH
25528: PPUSH
25529: PPUSH
// if not mc_bases then
25530: LD_EXP 78
25534: NOT
25535: IFFALSE 25539
// exit ;
25537: GO 25778
// for i = 1 to 8 do
25539: LD_ADDR_VAR 0 2
25543: PUSH
25544: DOUBLE
25545: LD_INT 1
25547: DEC
25548: ST_TO_ADDR
25549: LD_INT 8
25551: PUSH
25552: FOR_TO
25553: IFFALSE 25579
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
25555: LD_ADDR_EXP 105
25559: PUSH
25560: LD_EXP 105
25564: PPUSH
25565: LD_VAR 0 2
25569: PPUSH
25570: EMPTY
25571: PPUSH
25572: CALL_OW 1
25576: ST_TO_ADDR
25577: GO 25552
25579: POP
25580: POP
// tmp := [ ] ;
25581: LD_ADDR_VAR 0 5
25585: PUSH
25586: EMPTY
25587: ST_TO_ADDR
// for i = 1 to mc_sides do
25588: LD_ADDR_VAR 0 2
25592: PUSH
25593: DOUBLE
25594: LD_INT 1
25596: DEC
25597: ST_TO_ADDR
25598: LD_EXP 104
25602: PUSH
25603: FOR_TO
25604: IFFALSE 25662
// if not mc_sides [ i ] in tmp then
25606: LD_EXP 104
25610: PUSH
25611: LD_VAR 0 2
25615: ARRAY
25616: PUSH
25617: LD_VAR 0 5
25621: IN
25622: NOT
25623: IFFALSE 25660
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
25625: LD_ADDR_VAR 0 5
25629: PUSH
25630: LD_VAR 0 5
25634: PPUSH
25635: LD_VAR 0 5
25639: PUSH
25640: LD_INT 1
25642: PLUS
25643: PPUSH
25644: LD_EXP 104
25648: PUSH
25649: LD_VAR 0 2
25653: ARRAY
25654: PPUSH
25655: CALL_OW 2
25659: ST_TO_ADDR
25660: GO 25603
25662: POP
25663: POP
// if not tmp then
25664: LD_VAR 0 5
25668: NOT
25669: IFFALSE 25673
// exit ;
25671: GO 25778
// for j in tmp do
25673: LD_ADDR_VAR 0 3
25677: PUSH
25678: LD_VAR 0 5
25682: PUSH
25683: FOR_IN
25684: IFFALSE 25776
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
25686: LD_ADDR_VAR 0 6
25690: PUSH
25691: LD_INT 22
25693: PUSH
25694: LD_VAR 0 3
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PPUSH
25703: CALL_OW 69
25707: ST_TO_ADDR
// if not un then
25708: LD_VAR 0 6
25712: NOT
25713: IFFALSE 25717
// continue ;
25715: GO 25683
// nation := GetNation ( un [ 1 ] ) ;
25717: LD_ADDR_VAR 0 4
25721: PUSH
25722: LD_VAR 0 6
25726: PUSH
25727: LD_INT 1
25729: ARRAY
25730: PPUSH
25731: CALL_OW 248
25735: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
25736: LD_ADDR_EXP 105
25740: PUSH
25741: LD_EXP 105
25745: PPUSH
25746: LD_VAR 0 3
25750: PPUSH
25751: LD_VAR 0 3
25755: PPUSH
25756: LD_VAR 0 4
25760: PPUSH
25761: LD_INT 1
25763: PPUSH
25764: CALL 52966 0 3
25768: PPUSH
25769: CALL_OW 1
25773: ST_TO_ADDR
// end ;
25774: GO 25683
25776: POP
25777: POP
// end ;
25778: LD_VAR 0 1
25782: RET
// export function MC_InitSides ( ) ; var i ; begin
25783: LD_INT 0
25785: PPUSH
25786: PPUSH
// if not mc_bases then
25787: LD_EXP 78
25791: NOT
25792: IFFALSE 25796
// exit ;
25794: GO 25870
// for i = 1 to mc_bases do
25796: LD_ADDR_VAR 0 2
25800: PUSH
25801: DOUBLE
25802: LD_INT 1
25804: DEC
25805: ST_TO_ADDR
25806: LD_EXP 78
25810: PUSH
25811: FOR_TO
25812: IFFALSE 25868
// if mc_bases [ i ] then
25814: LD_EXP 78
25818: PUSH
25819: LD_VAR 0 2
25823: ARRAY
25824: IFFALSE 25866
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25826: LD_ADDR_EXP 104
25830: PUSH
25831: LD_EXP 104
25835: PPUSH
25836: LD_VAR 0 2
25840: PPUSH
25841: LD_EXP 78
25845: PUSH
25846: LD_VAR 0 2
25850: ARRAY
25851: PUSH
25852: LD_INT 1
25854: ARRAY
25855: PPUSH
25856: CALL_OW 255
25860: PPUSH
25861: CALL_OW 1
25865: ST_TO_ADDR
25866: GO 25811
25868: POP
25869: POP
// end ;
25870: LD_VAR 0 1
25874: RET
// every 0 0$03 trigger skirmish do
25875: LD_EXP 76
25879: IFFALSE 26033
25881: GO 25883
25883: DISABLE
// begin enable ;
25884: ENABLE
// MC_CheckBuildings ( ) ;
25885: CALL 30545 0 0
// MC_CheckPeopleLife ( ) ;
25889: CALL 30706 0 0
// RaiseSailEvent ( 100 ) ;
25893: LD_INT 100
25895: PPUSH
25896: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25900: LD_INT 103
25902: PPUSH
25903: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25907: LD_INT 104
25909: PPUSH
25910: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25914: LD_INT 105
25916: PPUSH
25917: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25921: LD_INT 106
25923: PPUSH
25924: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25928: LD_INT 107
25930: PPUSH
25931: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25935: LD_INT 108
25937: PPUSH
25938: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25942: LD_INT 109
25944: PPUSH
25945: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25949: LD_INT 110
25951: PPUSH
25952: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25956: LD_INT 111
25958: PPUSH
25959: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25963: LD_INT 112
25965: PPUSH
25966: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25970: LD_INT 113
25972: PPUSH
25973: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25977: LD_INT 120
25979: PPUSH
25980: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25984: LD_INT 121
25986: PPUSH
25987: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25991: LD_INT 122
25993: PPUSH
25994: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25998: LD_INT 123
26000: PPUSH
26001: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
26005: LD_INT 124
26007: PPUSH
26008: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
26012: LD_INT 125
26014: PPUSH
26015: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
26019: LD_INT 126
26021: PPUSH
26022: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
26026: LD_INT 200
26028: PPUSH
26029: CALL_OW 427
// end ;
26033: END
// on SailEvent ( event ) do begin if event < 100 then
26034: LD_VAR 0 1
26038: PUSH
26039: LD_INT 100
26041: LESS
26042: IFFALSE 26053
// CustomEvent ( event ) ;
26044: LD_VAR 0 1
26048: PPUSH
26049: CALL 11326 0 1
// if event = 100 then
26053: LD_VAR 0 1
26057: PUSH
26058: LD_INT 100
26060: EQUAL
26061: IFFALSE 26067
// MC_ClassManager ( ) ;
26063: CALL 26459 0 0
// if event = 101 then
26067: LD_VAR 0 1
26071: PUSH
26072: LD_INT 101
26074: EQUAL
26075: IFFALSE 26081
// MC_RepairBuildings ( ) ;
26077: CALL 31291 0 0
// if event = 102 then
26081: LD_VAR 0 1
26085: PUSH
26086: LD_INT 102
26088: EQUAL
26089: IFFALSE 26095
// MC_Heal ( ) ;
26091: CALL 32226 0 0
// if event = 103 then
26095: LD_VAR 0 1
26099: PUSH
26100: LD_INT 103
26102: EQUAL
26103: IFFALSE 26109
// MC_Build ( ) ;
26105: CALL 32648 0 0
// if event = 104 then
26109: LD_VAR 0 1
26113: PUSH
26114: LD_INT 104
26116: EQUAL
26117: IFFALSE 26123
// MC_TurretWeapon ( ) ;
26119: CALL 34282 0 0
// if event = 105 then
26123: LD_VAR 0 1
26127: PUSH
26128: LD_INT 105
26130: EQUAL
26131: IFFALSE 26137
// MC_BuildUpgrade ( ) ;
26133: CALL 33833 0 0
// if event = 106 then
26137: LD_VAR 0 1
26141: PUSH
26142: LD_INT 106
26144: EQUAL
26145: IFFALSE 26151
// MC_PlantMines ( ) ;
26147: CALL 34712 0 0
// if event = 107 then
26151: LD_VAR 0 1
26155: PUSH
26156: LD_INT 107
26158: EQUAL
26159: IFFALSE 26165
// MC_CollectCrates ( ) ;
26161: CALL 35510 0 0
// if event = 108 then
26165: LD_VAR 0 1
26169: PUSH
26170: LD_INT 108
26172: EQUAL
26173: IFFALSE 26179
// MC_LinkRemoteControl ( ) ;
26175: CALL 37360 0 0
// if event = 109 then
26179: LD_VAR 0 1
26183: PUSH
26184: LD_INT 109
26186: EQUAL
26187: IFFALSE 26193
// MC_ProduceVehicle ( ) ;
26189: CALL 37541 0 0
// if event = 110 then
26193: LD_VAR 0 1
26197: PUSH
26198: LD_INT 110
26200: EQUAL
26201: IFFALSE 26207
// MC_SendAttack ( ) ;
26203: CALL 38007 0 0
// if event = 111 then
26207: LD_VAR 0 1
26211: PUSH
26212: LD_INT 111
26214: EQUAL
26215: IFFALSE 26221
// MC_Defend ( ) ;
26217: CALL 38115 0 0
// if event = 112 then
26221: LD_VAR 0 1
26225: PUSH
26226: LD_INT 112
26228: EQUAL
26229: IFFALSE 26235
// MC_Research ( ) ;
26231: CALL 38995 0 0
// if event = 113 then
26235: LD_VAR 0 1
26239: PUSH
26240: LD_INT 113
26242: EQUAL
26243: IFFALSE 26249
// MC_MinesTrigger ( ) ;
26245: CALL 40109 0 0
// if event = 120 then
26249: LD_VAR 0 1
26253: PUSH
26254: LD_INT 120
26256: EQUAL
26257: IFFALSE 26263
// MC_RepairVehicle ( ) ;
26259: CALL 40208 0 0
// if event = 121 then
26263: LD_VAR 0 1
26267: PUSH
26268: LD_INT 121
26270: EQUAL
26271: IFFALSE 26277
// MC_TameApe ( ) ;
26273: CALL 40977 0 0
// if event = 122 then
26277: LD_VAR 0 1
26281: PUSH
26282: LD_INT 122
26284: EQUAL
26285: IFFALSE 26291
// MC_ChangeApeClass ( ) ;
26287: CALL 41806 0 0
// if event = 123 then
26291: LD_VAR 0 1
26295: PUSH
26296: LD_INT 123
26298: EQUAL
26299: IFFALSE 26305
// MC_Bazooka ( ) ;
26301: CALL 42456 0 0
// if event = 124 then
26305: LD_VAR 0 1
26309: PUSH
26310: LD_INT 124
26312: EQUAL
26313: IFFALSE 26319
// MC_TeleportExit ( ) ;
26315: CALL 42654 0 0
// if event = 125 then
26319: LD_VAR 0 1
26323: PUSH
26324: LD_INT 125
26326: EQUAL
26327: IFFALSE 26333
// MC_Deposits ( ) ;
26329: CALL 43301 0 0
// if event = 126 then
26333: LD_VAR 0 1
26337: PUSH
26338: LD_INT 126
26340: EQUAL
26341: IFFALSE 26347
// MC_RemoteDriver ( ) ;
26343: CALL 43926 0 0
// if event = 200 then
26347: LD_VAR 0 1
26351: PUSH
26352: LD_INT 200
26354: EQUAL
26355: IFFALSE 26361
// MC_Idle ( ) ;
26357: CALL 45833 0 0
// end ;
26361: PPOPN 1
26363: END
// export function MC_Reset ( base , tag ) ; var i ; begin
26364: LD_INT 0
26366: PPUSH
26367: PPUSH
// if not mc_bases [ base ] or not tag then
26368: LD_EXP 78
26372: PUSH
26373: LD_VAR 0 1
26377: ARRAY
26378: NOT
26379: PUSH
26380: LD_VAR 0 2
26384: NOT
26385: OR
26386: IFFALSE 26390
// exit ;
26388: GO 26454
// for i in mc_bases [ base ] union mc_ape [ base ] do
26390: LD_ADDR_VAR 0 4
26394: PUSH
26395: LD_EXP 78
26399: PUSH
26400: LD_VAR 0 1
26404: ARRAY
26405: PUSH
26406: LD_EXP 107
26410: PUSH
26411: LD_VAR 0 1
26415: ARRAY
26416: UNION
26417: PUSH
26418: FOR_IN
26419: IFFALSE 26452
// if GetTag ( i ) = tag then
26421: LD_VAR 0 4
26425: PPUSH
26426: CALL_OW 110
26430: PUSH
26431: LD_VAR 0 2
26435: EQUAL
26436: IFFALSE 26450
// SetTag ( i , 0 ) ;
26438: LD_VAR 0 4
26442: PPUSH
26443: LD_INT 0
26445: PPUSH
26446: CALL_OW 109
26450: GO 26418
26452: POP
26453: POP
// end ;
26454: LD_VAR 0 3
26458: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
26459: LD_INT 0
26461: PPUSH
26462: PPUSH
26463: PPUSH
26464: PPUSH
26465: PPUSH
26466: PPUSH
26467: PPUSH
26468: PPUSH
// if not mc_bases then
26469: LD_EXP 78
26473: NOT
26474: IFFALSE 26478
// exit ;
26476: GO 26927
// for i = 1 to mc_bases do
26478: LD_ADDR_VAR 0 2
26482: PUSH
26483: DOUBLE
26484: LD_INT 1
26486: DEC
26487: ST_TO_ADDR
26488: LD_EXP 78
26492: PUSH
26493: FOR_TO
26494: IFFALSE 26925
// begin tmp := MC_ClassCheckReq ( i ) ;
26496: LD_ADDR_VAR 0 4
26500: PUSH
26501: LD_VAR 0 2
26505: PPUSH
26506: CALL 26932 0 1
26510: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
26511: LD_ADDR_EXP 119
26515: PUSH
26516: LD_EXP 119
26520: PPUSH
26521: LD_VAR 0 2
26525: PPUSH
26526: LD_VAR 0 4
26530: PPUSH
26531: CALL_OW 1
26535: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
26536: LD_ADDR_VAR 0 6
26540: PUSH
26541: LD_EXP 78
26545: PUSH
26546: LD_VAR 0 2
26550: ARRAY
26551: PPUSH
26552: LD_INT 2
26554: PUSH
26555: LD_INT 30
26557: PUSH
26558: LD_INT 4
26560: PUSH
26561: EMPTY
26562: LIST
26563: LIST
26564: PUSH
26565: LD_INT 30
26567: PUSH
26568: LD_INT 5
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: LIST
26579: PPUSH
26580: CALL_OW 72
26584: PUSH
26585: LD_EXP 78
26589: PUSH
26590: LD_VAR 0 2
26594: ARRAY
26595: PPUSH
26596: LD_INT 2
26598: PUSH
26599: LD_INT 30
26601: PUSH
26602: LD_INT 0
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PUSH
26609: LD_INT 30
26611: PUSH
26612: LD_INT 1
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: LIST
26623: PPUSH
26624: CALL_OW 72
26628: PUSH
26629: LD_EXP 78
26633: PUSH
26634: LD_VAR 0 2
26638: ARRAY
26639: PPUSH
26640: LD_INT 30
26642: PUSH
26643: LD_INT 3
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PPUSH
26650: CALL_OW 72
26654: PUSH
26655: LD_EXP 78
26659: PUSH
26660: LD_VAR 0 2
26664: ARRAY
26665: PPUSH
26666: LD_INT 2
26668: PUSH
26669: LD_INT 30
26671: PUSH
26672: LD_INT 6
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: PUSH
26679: LD_INT 30
26681: PUSH
26682: LD_INT 7
26684: PUSH
26685: EMPTY
26686: LIST
26687: LIST
26688: PUSH
26689: LD_INT 30
26691: PUSH
26692: LD_INT 8
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: PUSH
26699: EMPTY
26700: LIST
26701: LIST
26702: LIST
26703: LIST
26704: PPUSH
26705: CALL_OW 72
26709: PUSH
26710: EMPTY
26711: LIST
26712: LIST
26713: LIST
26714: LIST
26715: ST_TO_ADDR
// for j := 1 to 4 do
26716: LD_ADDR_VAR 0 3
26720: PUSH
26721: DOUBLE
26722: LD_INT 1
26724: DEC
26725: ST_TO_ADDR
26726: LD_INT 4
26728: PUSH
26729: FOR_TO
26730: IFFALSE 26921
// begin if not tmp [ j ] then
26732: LD_VAR 0 4
26736: PUSH
26737: LD_VAR 0 3
26741: ARRAY
26742: NOT
26743: IFFALSE 26747
// continue ;
26745: GO 26729
// for p in tmp [ j ] do
26747: LD_ADDR_VAR 0 5
26751: PUSH
26752: LD_VAR 0 4
26756: PUSH
26757: LD_VAR 0 3
26761: ARRAY
26762: PUSH
26763: FOR_IN
26764: IFFALSE 26917
// begin if not b [ j ] then
26766: LD_VAR 0 6
26770: PUSH
26771: LD_VAR 0 3
26775: ARRAY
26776: NOT
26777: IFFALSE 26781
// break ;
26779: GO 26917
// e := 0 ;
26781: LD_ADDR_VAR 0 7
26785: PUSH
26786: LD_INT 0
26788: ST_TO_ADDR
// for k in b [ j ] do
26789: LD_ADDR_VAR 0 8
26793: PUSH
26794: LD_VAR 0 6
26798: PUSH
26799: LD_VAR 0 3
26803: ARRAY
26804: PUSH
26805: FOR_IN
26806: IFFALSE 26833
// if IsNotFull ( k ) then
26808: LD_VAR 0 8
26812: PPUSH
26813: CALL 55087 0 1
26817: IFFALSE 26831
// begin e := k ;
26819: LD_ADDR_VAR 0 7
26823: PUSH
26824: LD_VAR 0 8
26828: ST_TO_ADDR
// break ;
26829: GO 26833
// end ;
26831: GO 26805
26833: POP
26834: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26835: LD_VAR 0 7
26839: PUSH
26840: LD_VAR 0 5
26844: PPUSH
26845: LD_VAR 0 7
26849: PPUSH
26850: CALL 89237 0 2
26854: NOT
26855: AND
26856: IFFALSE 26915
// begin if IsInUnit ( p ) then
26858: LD_VAR 0 5
26862: PPUSH
26863: CALL_OW 310
26867: IFFALSE 26878
// ComExitBuilding ( p ) ;
26869: LD_VAR 0 5
26873: PPUSH
26874: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26878: LD_VAR 0 5
26882: PPUSH
26883: LD_VAR 0 7
26887: PPUSH
26888: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26892: LD_VAR 0 5
26896: PPUSH
26897: LD_VAR 0 3
26901: PPUSH
26902: CALL_OW 183
// AddComExitBuilding ( p ) ;
26906: LD_VAR 0 5
26910: PPUSH
26911: CALL_OW 182
// end ; end ;
26915: GO 26763
26917: POP
26918: POP
// end ;
26919: GO 26729
26921: POP
26922: POP
// end ;
26923: GO 26493
26925: POP
26926: POP
// end ;
26927: LD_VAR 0 1
26931: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26932: LD_INT 0
26934: PPUSH
26935: PPUSH
26936: PPUSH
26937: PPUSH
26938: PPUSH
26939: PPUSH
26940: PPUSH
26941: PPUSH
26942: PPUSH
26943: PPUSH
26944: PPUSH
26945: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
26946: LD_ADDR_VAR 0 2
26950: PUSH
26951: LD_INT 0
26953: PUSH
26954: LD_INT 0
26956: PUSH
26957: LD_INT 0
26959: PUSH
26960: LD_INT 0
26962: PUSH
26963: EMPTY
26964: LIST
26965: LIST
26966: LIST
26967: LIST
26968: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26969: LD_VAR 0 1
26973: NOT
26974: PUSH
26975: LD_EXP 78
26979: PUSH
26980: LD_VAR 0 1
26984: ARRAY
26985: NOT
26986: OR
26987: PUSH
26988: LD_EXP 78
26992: PUSH
26993: LD_VAR 0 1
26997: ARRAY
26998: PPUSH
26999: LD_INT 2
27001: PUSH
27002: LD_INT 30
27004: PUSH
27005: LD_INT 0
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: LD_INT 30
27014: PUSH
27015: LD_INT 1
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: EMPTY
27023: LIST
27024: LIST
27025: LIST
27026: PPUSH
27027: CALL_OW 72
27031: NOT
27032: OR
27033: IFFALSE 27037
// exit ;
27035: GO 30540
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27037: LD_ADDR_VAR 0 4
27041: PUSH
27042: LD_EXP 78
27046: PUSH
27047: LD_VAR 0 1
27051: ARRAY
27052: PPUSH
27053: LD_INT 2
27055: PUSH
27056: LD_INT 25
27058: PUSH
27059: LD_INT 1
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PUSH
27066: LD_INT 25
27068: PUSH
27069: LD_INT 2
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: LD_INT 25
27078: PUSH
27079: LD_INT 3
27081: PUSH
27082: EMPTY
27083: LIST
27084: LIST
27085: PUSH
27086: LD_INT 25
27088: PUSH
27089: LD_INT 4
27091: PUSH
27092: EMPTY
27093: LIST
27094: LIST
27095: PUSH
27096: LD_INT 25
27098: PUSH
27099: LD_INT 5
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: PUSH
27106: LD_INT 25
27108: PUSH
27109: LD_INT 8
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PUSH
27116: LD_INT 25
27118: PUSH
27119: LD_INT 9
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: PUSH
27126: EMPTY
27127: LIST
27128: LIST
27129: LIST
27130: LIST
27131: LIST
27132: LIST
27133: LIST
27134: LIST
27135: PPUSH
27136: CALL_OW 72
27140: ST_TO_ADDR
// if not tmp then
27141: LD_VAR 0 4
27145: NOT
27146: IFFALSE 27150
// exit ;
27148: GO 30540
// for i in tmp do
27150: LD_ADDR_VAR 0 3
27154: PUSH
27155: LD_VAR 0 4
27159: PUSH
27160: FOR_IN
27161: IFFALSE 27192
// if GetTag ( i ) then
27163: LD_VAR 0 3
27167: PPUSH
27168: CALL_OW 110
27172: IFFALSE 27190
// tmp := tmp diff i ;
27174: LD_ADDR_VAR 0 4
27178: PUSH
27179: LD_VAR 0 4
27183: PUSH
27184: LD_VAR 0 3
27188: DIFF
27189: ST_TO_ADDR
27190: GO 27160
27192: POP
27193: POP
// if not tmp then
27194: LD_VAR 0 4
27198: NOT
27199: IFFALSE 27203
// exit ;
27201: GO 30540
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27203: LD_ADDR_VAR 0 5
27207: PUSH
27208: LD_EXP 78
27212: PUSH
27213: LD_VAR 0 1
27217: ARRAY
27218: PPUSH
27219: LD_INT 2
27221: PUSH
27222: LD_INT 25
27224: PUSH
27225: LD_INT 1
27227: PUSH
27228: EMPTY
27229: LIST
27230: LIST
27231: PUSH
27232: LD_INT 25
27234: PUSH
27235: LD_INT 5
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PUSH
27242: LD_INT 25
27244: PUSH
27245: LD_INT 8
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: LD_INT 25
27254: PUSH
27255: LD_INT 9
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: LIST
27266: LIST
27267: LIST
27268: PPUSH
27269: CALL_OW 72
27273: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
27274: LD_ADDR_VAR 0 6
27278: PUSH
27279: LD_EXP 78
27283: PUSH
27284: LD_VAR 0 1
27288: ARRAY
27289: PPUSH
27290: LD_INT 25
27292: PUSH
27293: LD_INT 2
27295: PUSH
27296: EMPTY
27297: LIST
27298: LIST
27299: PPUSH
27300: CALL_OW 72
27304: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
27305: LD_ADDR_VAR 0 7
27309: PUSH
27310: LD_EXP 78
27314: PUSH
27315: LD_VAR 0 1
27319: ARRAY
27320: PPUSH
27321: LD_INT 25
27323: PUSH
27324: LD_INT 3
27326: PUSH
27327: EMPTY
27328: LIST
27329: LIST
27330: PPUSH
27331: CALL_OW 72
27335: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
27336: LD_ADDR_VAR 0 8
27340: PUSH
27341: LD_EXP 78
27345: PUSH
27346: LD_VAR 0 1
27350: ARRAY
27351: PPUSH
27352: LD_INT 25
27354: PUSH
27355: LD_INT 4
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: PUSH
27362: LD_INT 24
27364: PUSH
27365: LD_INT 251
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PUSH
27372: EMPTY
27373: LIST
27374: LIST
27375: PPUSH
27376: CALL_OW 72
27380: ST_TO_ADDR
// if mc_is_defending [ base ] then
27381: LD_EXP 121
27385: PUSH
27386: LD_VAR 0 1
27390: ARRAY
27391: IFFALSE 27852
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
27393: LD_ADDR_EXP 120
27397: PUSH
27398: LD_EXP 120
27402: PPUSH
27403: LD_VAR 0 1
27407: PPUSH
27408: LD_INT 4
27410: PPUSH
27411: CALL_OW 1
27415: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
27416: LD_ADDR_VAR 0 12
27420: PUSH
27421: LD_EXP 78
27425: PUSH
27426: LD_VAR 0 1
27430: ARRAY
27431: PPUSH
27432: LD_INT 2
27434: PUSH
27435: LD_INT 30
27437: PUSH
27438: LD_INT 4
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 30
27447: PUSH
27448: LD_INT 5
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PUSH
27455: EMPTY
27456: LIST
27457: LIST
27458: LIST
27459: PPUSH
27460: CALL_OW 72
27464: ST_TO_ADDR
// if not b then
27465: LD_VAR 0 12
27469: NOT
27470: IFFALSE 27474
// exit ;
27472: GO 30540
// p := [ ] ;
27474: LD_ADDR_VAR 0 11
27478: PUSH
27479: EMPTY
27480: ST_TO_ADDR
// if sci >= 2 then
27481: LD_VAR 0 8
27485: PUSH
27486: LD_INT 2
27488: GREATEREQUAL
27489: IFFALSE 27520
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
27491: LD_ADDR_VAR 0 8
27495: PUSH
27496: LD_VAR 0 8
27500: PUSH
27501: LD_INT 1
27503: ARRAY
27504: PUSH
27505: LD_VAR 0 8
27509: PUSH
27510: LD_INT 2
27512: ARRAY
27513: PUSH
27514: EMPTY
27515: LIST
27516: LIST
27517: ST_TO_ADDR
27518: GO 27581
// if sci = 1 then
27520: LD_VAR 0 8
27524: PUSH
27525: LD_INT 1
27527: EQUAL
27528: IFFALSE 27549
// sci := [ sci [ 1 ] ] else
27530: LD_ADDR_VAR 0 8
27534: PUSH
27535: LD_VAR 0 8
27539: PUSH
27540: LD_INT 1
27542: ARRAY
27543: PUSH
27544: EMPTY
27545: LIST
27546: ST_TO_ADDR
27547: GO 27581
// if sci = 0 then
27549: LD_VAR 0 8
27553: PUSH
27554: LD_INT 0
27556: EQUAL
27557: IFFALSE 27581
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
27559: LD_ADDR_VAR 0 11
27563: PUSH
27564: LD_VAR 0 4
27568: PPUSH
27569: LD_INT 4
27571: PPUSH
27572: CALL 89109 0 2
27576: PUSH
27577: LD_INT 1
27579: ARRAY
27580: ST_TO_ADDR
// if eng > 4 then
27581: LD_VAR 0 6
27585: PUSH
27586: LD_INT 4
27588: GREATER
27589: IFFALSE 27635
// for i = eng downto 4 do
27591: LD_ADDR_VAR 0 3
27595: PUSH
27596: DOUBLE
27597: LD_VAR 0 6
27601: INC
27602: ST_TO_ADDR
27603: LD_INT 4
27605: PUSH
27606: FOR_DOWNTO
27607: IFFALSE 27633
// eng := eng diff eng [ i ] ;
27609: LD_ADDR_VAR 0 6
27613: PUSH
27614: LD_VAR 0 6
27618: PUSH
27619: LD_VAR 0 6
27623: PUSH
27624: LD_VAR 0 3
27628: ARRAY
27629: DIFF
27630: ST_TO_ADDR
27631: GO 27606
27633: POP
27634: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
27635: LD_ADDR_VAR 0 4
27639: PUSH
27640: LD_VAR 0 4
27644: PUSH
27645: LD_VAR 0 5
27649: PUSH
27650: LD_VAR 0 6
27654: UNION
27655: PUSH
27656: LD_VAR 0 7
27660: UNION
27661: PUSH
27662: LD_VAR 0 8
27666: UNION
27667: DIFF
27668: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
27669: LD_ADDR_VAR 0 13
27673: PUSH
27674: LD_EXP 78
27678: PUSH
27679: LD_VAR 0 1
27683: ARRAY
27684: PPUSH
27685: LD_INT 2
27687: PUSH
27688: LD_INT 30
27690: PUSH
27691: LD_INT 32
27693: PUSH
27694: EMPTY
27695: LIST
27696: LIST
27697: PUSH
27698: LD_INT 30
27700: PUSH
27701: LD_INT 31
27703: PUSH
27704: EMPTY
27705: LIST
27706: LIST
27707: PUSH
27708: EMPTY
27709: LIST
27710: LIST
27711: LIST
27712: PPUSH
27713: CALL_OW 72
27717: PUSH
27718: LD_EXP 78
27722: PUSH
27723: LD_VAR 0 1
27727: ARRAY
27728: PPUSH
27729: LD_INT 2
27731: PUSH
27732: LD_INT 30
27734: PUSH
27735: LD_INT 4
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: PUSH
27742: LD_INT 30
27744: PUSH
27745: LD_INT 5
27747: PUSH
27748: EMPTY
27749: LIST
27750: LIST
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: LIST
27756: PPUSH
27757: CALL_OW 72
27761: PUSH
27762: LD_INT 6
27764: MUL
27765: PLUS
27766: ST_TO_ADDR
// if bcount < tmp then
27767: LD_VAR 0 13
27771: PUSH
27772: LD_VAR 0 4
27776: LESS
27777: IFFALSE 27823
// for i = tmp downto bcount do
27779: LD_ADDR_VAR 0 3
27783: PUSH
27784: DOUBLE
27785: LD_VAR 0 4
27789: INC
27790: ST_TO_ADDR
27791: LD_VAR 0 13
27795: PUSH
27796: FOR_DOWNTO
27797: IFFALSE 27821
// tmp := Delete ( tmp , tmp ) ;
27799: LD_ADDR_VAR 0 4
27803: PUSH
27804: LD_VAR 0 4
27808: PPUSH
27809: LD_VAR 0 4
27813: PPUSH
27814: CALL_OW 3
27818: ST_TO_ADDR
27819: GO 27796
27821: POP
27822: POP
// result := [ tmp , 0 , 0 , p ] ;
27823: LD_ADDR_VAR 0 2
27827: PUSH
27828: LD_VAR 0 4
27832: PUSH
27833: LD_INT 0
27835: PUSH
27836: LD_INT 0
27838: PUSH
27839: LD_VAR 0 11
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: LIST
27848: LIST
27849: ST_TO_ADDR
// exit ;
27850: GO 30540
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27852: LD_EXP 78
27856: PUSH
27857: LD_VAR 0 1
27861: ARRAY
27862: PPUSH
27863: LD_INT 2
27865: PUSH
27866: LD_INT 30
27868: PUSH
27869: LD_INT 6
27871: PUSH
27872: EMPTY
27873: LIST
27874: LIST
27875: PUSH
27876: LD_INT 30
27878: PUSH
27879: LD_INT 7
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: PUSH
27886: LD_INT 30
27888: PUSH
27889: LD_INT 8
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: LIST
27900: LIST
27901: PPUSH
27902: CALL_OW 72
27906: NOT
27907: PUSH
27908: LD_EXP 78
27912: PUSH
27913: LD_VAR 0 1
27917: ARRAY
27918: PPUSH
27919: LD_INT 30
27921: PUSH
27922: LD_INT 3
27924: PUSH
27925: EMPTY
27926: LIST
27927: LIST
27928: PPUSH
27929: CALL_OW 72
27933: NOT
27934: AND
27935: IFFALSE 28007
// begin if eng = tmp then
27937: LD_VAR 0 6
27941: PUSH
27942: LD_VAR 0 4
27946: EQUAL
27947: IFFALSE 27951
// exit ;
27949: GO 30540
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27951: LD_ADDR_EXP 120
27955: PUSH
27956: LD_EXP 120
27960: PPUSH
27961: LD_VAR 0 1
27965: PPUSH
27966: LD_INT 1
27968: PPUSH
27969: CALL_OW 1
27973: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27974: LD_ADDR_VAR 0 2
27978: PUSH
27979: LD_INT 0
27981: PUSH
27982: LD_VAR 0 4
27986: PUSH
27987: LD_VAR 0 6
27991: DIFF
27992: PUSH
27993: LD_INT 0
27995: PUSH
27996: LD_INT 0
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: ST_TO_ADDR
// exit ;
28005: GO 30540
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28007: LD_EXP 105
28011: PUSH
28012: LD_EXP 104
28016: PUSH
28017: LD_VAR 0 1
28021: ARRAY
28022: ARRAY
28023: PUSH
28024: LD_EXP 78
28028: PUSH
28029: LD_VAR 0 1
28033: ARRAY
28034: PPUSH
28035: LD_INT 2
28037: PUSH
28038: LD_INT 30
28040: PUSH
28041: LD_INT 6
28043: PUSH
28044: EMPTY
28045: LIST
28046: LIST
28047: PUSH
28048: LD_INT 30
28050: PUSH
28051: LD_INT 7
28053: PUSH
28054: EMPTY
28055: LIST
28056: LIST
28057: PUSH
28058: LD_INT 30
28060: PUSH
28061: LD_INT 8
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: PPUSH
28074: CALL_OW 72
28078: AND
28079: PUSH
28080: LD_EXP 78
28084: PUSH
28085: LD_VAR 0 1
28089: ARRAY
28090: PPUSH
28091: LD_INT 30
28093: PUSH
28094: LD_INT 3
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PPUSH
28101: CALL_OW 72
28105: NOT
28106: AND
28107: IFFALSE 28321
// begin if sci >= 6 then
28109: LD_VAR 0 8
28113: PUSH
28114: LD_INT 6
28116: GREATEREQUAL
28117: IFFALSE 28121
// exit ;
28119: GO 30540
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28121: LD_ADDR_EXP 120
28125: PUSH
28126: LD_EXP 120
28130: PPUSH
28131: LD_VAR 0 1
28135: PPUSH
28136: LD_INT 2
28138: PPUSH
28139: CALL_OW 1
28143: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28144: LD_ADDR_VAR 0 9
28148: PUSH
28149: LD_VAR 0 4
28153: PUSH
28154: LD_VAR 0 8
28158: DIFF
28159: PPUSH
28160: LD_INT 4
28162: PPUSH
28163: CALL 89109 0 2
28167: ST_TO_ADDR
// p := [ ] ;
28168: LD_ADDR_VAR 0 11
28172: PUSH
28173: EMPTY
28174: ST_TO_ADDR
// if sci < 6 and sort > 6 then
28175: LD_VAR 0 8
28179: PUSH
28180: LD_INT 6
28182: LESS
28183: PUSH
28184: LD_VAR 0 9
28188: PUSH
28189: LD_INT 6
28191: GREATER
28192: AND
28193: IFFALSE 28274
// begin for i = 1 to 6 - sci do
28195: LD_ADDR_VAR 0 3
28199: PUSH
28200: DOUBLE
28201: LD_INT 1
28203: DEC
28204: ST_TO_ADDR
28205: LD_INT 6
28207: PUSH
28208: LD_VAR 0 8
28212: MINUS
28213: PUSH
28214: FOR_TO
28215: IFFALSE 28270
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
28217: LD_ADDR_VAR 0 11
28221: PUSH
28222: LD_VAR 0 11
28226: PPUSH
28227: LD_VAR 0 11
28231: PUSH
28232: LD_INT 1
28234: PLUS
28235: PPUSH
28236: LD_VAR 0 9
28240: PUSH
28241: LD_INT 1
28243: ARRAY
28244: PPUSH
28245: CALL_OW 2
28249: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
28250: LD_ADDR_VAR 0 9
28254: PUSH
28255: LD_VAR 0 9
28259: PPUSH
28260: LD_INT 1
28262: PPUSH
28263: CALL_OW 3
28267: ST_TO_ADDR
// end ;
28268: GO 28214
28270: POP
28271: POP
// end else
28272: GO 28294
// if sort then
28274: LD_VAR 0 9
28278: IFFALSE 28294
// p := sort [ 1 ] ;
28280: LD_ADDR_VAR 0 11
28284: PUSH
28285: LD_VAR 0 9
28289: PUSH
28290: LD_INT 1
28292: ARRAY
28293: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
28294: LD_ADDR_VAR 0 2
28298: PUSH
28299: LD_INT 0
28301: PUSH
28302: LD_INT 0
28304: PUSH
28305: LD_INT 0
28307: PUSH
28308: LD_VAR 0 11
28312: PUSH
28313: EMPTY
28314: LIST
28315: LIST
28316: LIST
28317: LIST
28318: ST_TO_ADDR
// exit ;
28319: GO 30540
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28321: LD_EXP 105
28325: PUSH
28326: LD_EXP 104
28330: PUSH
28331: LD_VAR 0 1
28335: ARRAY
28336: ARRAY
28337: PUSH
28338: LD_EXP 78
28342: PUSH
28343: LD_VAR 0 1
28347: ARRAY
28348: PPUSH
28349: LD_INT 2
28351: PUSH
28352: LD_INT 30
28354: PUSH
28355: LD_INT 6
28357: PUSH
28358: EMPTY
28359: LIST
28360: LIST
28361: PUSH
28362: LD_INT 30
28364: PUSH
28365: LD_INT 7
28367: PUSH
28368: EMPTY
28369: LIST
28370: LIST
28371: PUSH
28372: LD_INT 30
28374: PUSH
28375: LD_INT 8
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: EMPTY
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: PPUSH
28388: CALL_OW 72
28392: AND
28393: PUSH
28394: LD_EXP 78
28398: PUSH
28399: LD_VAR 0 1
28403: ARRAY
28404: PPUSH
28405: LD_INT 30
28407: PUSH
28408: LD_INT 3
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PPUSH
28415: CALL_OW 72
28419: AND
28420: IFFALSE 29154
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
28422: LD_ADDR_EXP 120
28426: PUSH
28427: LD_EXP 120
28431: PPUSH
28432: LD_VAR 0 1
28436: PPUSH
28437: LD_INT 3
28439: PPUSH
28440: CALL_OW 1
28444: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28445: LD_ADDR_VAR 0 2
28449: PUSH
28450: LD_INT 0
28452: PUSH
28453: LD_INT 0
28455: PUSH
28456: LD_INT 0
28458: PUSH
28459: LD_INT 0
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: LIST
28466: LIST
28467: ST_TO_ADDR
// if not eng then
28468: LD_VAR 0 6
28472: NOT
28473: IFFALSE 28536
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
28475: LD_ADDR_VAR 0 11
28479: PUSH
28480: LD_VAR 0 4
28484: PPUSH
28485: LD_INT 2
28487: PPUSH
28488: CALL 89109 0 2
28492: PUSH
28493: LD_INT 1
28495: ARRAY
28496: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
28497: LD_ADDR_VAR 0 2
28501: PUSH
28502: LD_VAR 0 2
28506: PPUSH
28507: LD_INT 2
28509: PPUSH
28510: LD_VAR 0 11
28514: PPUSH
28515: CALL_OW 1
28519: ST_TO_ADDR
// tmp := tmp diff p ;
28520: LD_ADDR_VAR 0 4
28524: PUSH
28525: LD_VAR 0 4
28529: PUSH
28530: LD_VAR 0 11
28534: DIFF
28535: ST_TO_ADDR
// end ; if tmp and sci < 6 then
28536: LD_VAR 0 4
28540: PUSH
28541: LD_VAR 0 8
28545: PUSH
28546: LD_INT 6
28548: LESS
28549: AND
28550: IFFALSE 28738
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
28552: LD_ADDR_VAR 0 9
28556: PUSH
28557: LD_VAR 0 4
28561: PUSH
28562: LD_VAR 0 8
28566: PUSH
28567: LD_VAR 0 7
28571: UNION
28572: DIFF
28573: PPUSH
28574: LD_INT 4
28576: PPUSH
28577: CALL 89109 0 2
28581: ST_TO_ADDR
// p := [ ] ;
28582: LD_ADDR_VAR 0 11
28586: PUSH
28587: EMPTY
28588: ST_TO_ADDR
// if sort then
28589: LD_VAR 0 9
28593: IFFALSE 28709
// for i = 1 to 6 - sci do
28595: LD_ADDR_VAR 0 3
28599: PUSH
28600: DOUBLE
28601: LD_INT 1
28603: DEC
28604: ST_TO_ADDR
28605: LD_INT 6
28607: PUSH
28608: LD_VAR 0 8
28612: MINUS
28613: PUSH
28614: FOR_TO
28615: IFFALSE 28707
// begin if i = sort then
28617: LD_VAR 0 3
28621: PUSH
28622: LD_VAR 0 9
28626: EQUAL
28627: IFFALSE 28631
// break ;
28629: GO 28707
// if GetClass ( i ) = 4 then
28631: LD_VAR 0 3
28635: PPUSH
28636: CALL_OW 257
28640: PUSH
28641: LD_INT 4
28643: EQUAL
28644: IFFALSE 28648
// continue ;
28646: GO 28614
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28648: LD_ADDR_VAR 0 11
28652: PUSH
28653: LD_VAR 0 11
28657: PPUSH
28658: LD_VAR 0 11
28662: PUSH
28663: LD_INT 1
28665: PLUS
28666: PPUSH
28667: LD_VAR 0 9
28671: PUSH
28672: LD_VAR 0 3
28676: ARRAY
28677: PPUSH
28678: CALL_OW 2
28682: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28683: LD_ADDR_VAR 0 4
28687: PUSH
28688: LD_VAR 0 4
28692: PUSH
28693: LD_VAR 0 9
28697: PUSH
28698: LD_VAR 0 3
28702: ARRAY
28703: DIFF
28704: ST_TO_ADDR
// end ;
28705: GO 28614
28707: POP
28708: POP
// if p then
28709: LD_VAR 0 11
28713: IFFALSE 28738
// result := Replace ( result , 4 , p ) ;
28715: LD_ADDR_VAR 0 2
28719: PUSH
28720: LD_VAR 0 2
28724: PPUSH
28725: LD_INT 4
28727: PPUSH
28728: LD_VAR 0 11
28732: PPUSH
28733: CALL_OW 1
28737: ST_TO_ADDR
// end ; if tmp and mech < 6 then
28738: LD_VAR 0 4
28742: PUSH
28743: LD_VAR 0 7
28747: PUSH
28748: LD_INT 6
28750: LESS
28751: AND
28752: IFFALSE 28940
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28754: LD_ADDR_VAR 0 9
28758: PUSH
28759: LD_VAR 0 4
28763: PUSH
28764: LD_VAR 0 8
28768: PUSH
28769: LD_VAR 0 7
28773: UNION
28774: DIFF
28775: PPUSH
28776: LD_INT 3
28778: PPUSH
28779: CALL 89109 0 2
28783: ST_TO_ADDR
// p := [ ] ;
28784: LD_ADDR_VAR 0 11
28788: PUSH
28789: EMPTY
28790: ST_TO_ADDR
// if sort then
28791: LD_VAR 0 9
28795: IFFALSE 28911
// for i = 1 to 6 - mech do
28797: LD_ADDR_VAR 0 3
28801: PUSH
28802: DOUBLE
28803: LD_INT 1
28805: DEC
28806: ST_TO_ADDR
28807: LD_INT 6
28809: PUSH
28810: LD_VAR 0 7
28814: MINUS
28815: PUSH
28816: FOR_TO
28817: IFFALSE 28909
// begin if i = sort then
28819: LD_VAR 0 3
28823: PUSH
28824: LD_VAR 0 9
28828: EQUAL
28829: IFFALSE 28833
// break ;
28831: GO 28909
// if GetClass ( i ) = 3 then
28833: LD_VAR 0 3
28837: PPUSH
28838: CALL_OW 257
28842: PUSH
28843: LD_INT 3
28845: EQUAL
28846: IFFALSE 28850
// continue ;
28848: GO 28816
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28850: LD_ADDR_VAR 0 11
28854: PUSH
28855: LD_VAR 0 11
28859: PPUSH
28860: LD_VAR 0 11
28864: PUSH
28865: LD_INT 1
28867: PLUS
28868: PPUSH
28869: LD_VAR 0 9
28873: PUSH
28874: LD_VAR 0 3
28878: ARRAY
28879: PPUSH
28880: CALL_OW 2
28884: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28885: LD_ADDR_VAR 0 4
28889: PUSH
28890: LD_VAR 0 4
28894: PUSH
28895: LD_VAR 0 9
28899: PUSH
28900: LD_VAR 0 3
28904: ARRAY
28905: DIFF
28906: ST_TO_ADDR
// end ;
28907: GO 28816
28909: POP
28910: POP
// if p then
28911: LD_VAR 0 11
28915: IFFALSE 28940
// result := Replace ( result , 3 , p ) ;
28917: LD_ADDR_VAR 0 2
28921: PUSH
28922: LD_VAR 0 2
28926: PPUSH
28927: LD_INT 3
28929: PPUSH
28930: LD_VAR 0 11
28934: PPUSH
28935: CALL_OW 1
28939: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28940: LD_VAR 0 4
28944: PUSH
28945: LD_INT 6
28947: GREATER
28948: PUSH
28949: LD_VAR 0 6
28953: PUSH
28954: LD_INT 6
28956: LESS
28957: AND
28958: IFFALSE 29152
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28960: LD_ADDR_VAR 0 9
28964: PUSH
28965: LD_VAR 0 4
28969: PUSH
28970: LD_VAR 0 8
28974: PUSH
28975: LD_VAR 0 7
28979: UNION
28980: PUSH
28981: LD_VAR 0 6
28985: UNION
28986: DIFF
28987: PPUSH
28988: LD_INT 2
28990: PPUSH
28991: CALL 89109 0 2
28995: ST_TO_ADDR
// p := [ ] ;
28996: LD_ADDR_VAR 0 11
29000: PUSH
29001: EMPTY
29002: ST_TO_ADDR
// if sort then
29003: LD_VAR 0 9
29007: IFFALSE 29123
// for i = 1 to 6 - eng do
29009: LD_ADDR_VAR 0 3
29013: PUSH
29014: DOUBLE
29015: LD_INT 1
29017: DEC
29018: ST_TO_ADDR
29019: LD_INT 6
29021: PUSH
29022: LD_VAR 0 6
29026: MINUS
29027: PUSH
29028: FOR_TO
29029: IFFALSE 29121
// begin if i = sort then
29031: LD_VAR 0 3
29035: PUSH
29036: LD_VAR 0 9
29040: EQUAL
29041: IFFALSE 29045
// break ;
29043: GO 29121
// if GetClass ( i ) = 2 then
29045: LD_VAR 0 3
29049: PPUSH
29050: CALL_OW 257
29054: PUSH
29055: LD_INT 2
29057: EQUAL
29058: IFFALSE 29062
// continue ;
29060: GO 29028
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29062: LD_ADDR_VAR 0 11
29066: PUSH
29067: LD_VAR 0 11
29071: PPUSH
29072: LD_VAR 0 11
29076: PUSH
29077: LD_INT 1
29079: PLUS
29080: PPUSH
29081: LD_VAR 0 9
29085: PUSH
29086: LD_VAR 0 3
29090: ARRAY
29091: PPUSH
29092: CALL_OW 2
29096: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29097: LD_ADDR_VAR 0 4
29101: PUSH
29102: LD_VAR 0 4
29106: PUSH
29107: LD_VAR 0 9
29111: PUSH
29112: LD_VAR 0 3
29116: ARRAY
29117: DIFF
29118: ST_TO_ADDR
// end ;
29119: GO 29028
29121: POP
29122: POP
// if p then
29123: LD_VAR 0 11
29127: IFFALSE 29152
// result := Replace ( result , 2 , p ) ;
29129: LD_ADDR_VAR 0 2
29133: PUSH
29134: LD_VAR 0 2
29138: PPUSH
29139: LD_INT 2
29141: PPUSH
29142: LD_VAR 0 11
29146: PPUSH
29147: CALL_OW 1
29151: ST_TO_ADDR
// end ; exit ;
29152: GO 30540
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29154: LD_EXP 105
29158: PUSH
29159: LD_EXP 104
29163: PUSH
29164: LD_VAR 0 1
29168: ARRAY
29169: ARRAY
29170: NOT
29171: PUSH
29172: LD_EXP 78
29176: PUSH
29177: LD_VAR 0 1
29181: ARRAY
29182: PPUSH
29183: LD_INT 30
29185: PUSH
29186: LD_INT 3
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: PPUSH
29193: CALL_OW 72
29197: AND
29198: PUSH
29199: LD_EXP 83
29203: PUSH
29204: LD_VAR 0 1
29208: ARRAY
29209: AND
29210: IFFALSE 29818
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
29212: LD_ADDR_EXP 120
29216: PUSH
29217: LD_EXP 120
29221: PPUSH
29222: LD_VAR 0 1
29226: PPUSH
29227: LD_INT 5
29229: PPUSH
29230: CALL_OW 1
29234: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29235: LD_ADDR_VAR 0 2
29239: PUSH
29240: LD_INT 0
29242: PUSH
29243: LD_INT 0
29245: PUSH
29246: LD_INT 0
29248: PUSH
29249: LD_INT 0
29251: PUSH
29252: EMPTY
29253: LIST
29254: LIST
29255: LIST
29256: LIST
29257: ST_TO_ADDR
// if sci > 1 then
29258: LD_VAR 0 8
29262: PUSH
29263: LD_INT 1
29265: GREATER
29266: IFFALSE 29294
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
29268: LD_ADDR_VAR 0 4
29272: PUSH
29273: LD_VAR 0 4
29277: PUSH
29278: LD_VAR 0 8
29282: PUSH
29283: LD_VAR 0 8
29287: PUSH
29288: LD_INT 1
29290: ARRAY
29291: DIFF
29292: DIFF
29293: ST_TO_ADDR
// if tmp and not sci then
29294: LD_VAR 0 4
29298: PUSH
29299: LD_VAR 0 8
29303: NOT
29304: AND
29305: IFFALSE 29374
// begin sort := SortBySkill ( tmp , 4 ) ;
29307: LD_ADDR_VAR 0 9
29311: PUSH
29312: LD_VAR 0 4
29316: PPUSH
29317: LD_INT 4
29319: PPUSH
29320: CALL 89109 0 2
29324: ST_TO_ADDR
// if sort then
29325: LD_VAR 0 9
29329: IFFALSE 29345
// p := sort [ 1 ] ;
29331: LD_ADDR_VAR 0 11
29335: PUSH
29336: LD_VAR 0 9
29340: PUSH
29341: LD_INT 1
29343: ARRAY
29344: ST_TO_ADDR
// if p then
29345: LD_VAR 0 11
29349: IFFALSE 29374
// result := Replace ( result , 4 , p ) ;
29351: LD_ADDR_VAR 0 2
29355: PUSH
29356: LD_VAR 0 2
29360: PPUSH
29361: LD_INT 4
29363: PPUSH
29364: LD_VAR 0 11
29368: PPUSH
29369: CALL_OW 1
29373: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29374: LD_ADDR_VAR 0 4
29378: PUSH
29379: LD_VAR 0 4
29383: PUSH
29384: LD_VAR 0 7
29388: DIFF
29389: ST_TO_ADDR
// if tmp and mech < 6 then
29390: LD_VAR 0 4
29394: PUSH
29395: LD_VAR 0 7
29399: PUSH
29400: LD_INT 6
29402: LESS
29403: AND
29404: IFFALSE 29592
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29406: LD_ADDR_VAR 0 9
29410: PUSH
29411: LD_VAR 0 4
29415: PUSH
29416: LD_VAR 0 8
29420: PUSH
29421: LD_VAR 0 7
29425: UNION
29426: DIFF
29427: PPUSH
29428: LD_INT 3
29430: PPUSH
29431: CALL 89109 0 2
29435: ST_TO_ADDR
// p := [ ] ;
29436: LD_ADDR_VAR 0 11
29440: PUSH
29441: EMPTY
29442: ST_TO_ADDR
// if sort then
29443: LD_VAR 0 9
29447: IFFALSE 29563
// for i = 1 to 6 - mech do
29449: LD_ADDR_VAR 0 3
29453: PUSH
29454: DOUBLE
29455: LD_INT 1
29457: DEC
29458: ST_TO_ADDR
29459: LD_INT 6
29461: PUSH
29462: LD_VAR 0 7
29466: MINUS
29467: PUSH
29468: FOR_TO
29469: IFFALSE 29561
// begin if i = sort then
29471: LD_VAR 0 3
29475: PUSH
29476: LD_VAR 0 9
29480: EQUAL
29481: IFFALSE 29485
// break ;
29483: GO 29561
// if GetClass ( i ) = 3 then
29485: LD_VAR 0 3
29489: PPUSH
29490: CALL_OW 257
29494: PUSH
29495: LD_INT 3
29497: EQUAL
29498: IFFALSE 29502
// continue ;
29500: GO 29468
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29502: LD_ADDR_VAR 0 11
29506: PUSH
29507: LD_VAR 0 11
29511: PPUSH
29512: LD_VAR 0 11
29516: PUSH
29517: LD_INT 1
29519: PLUS
29520: PPUSH
29521: LD_VAR 0 9
29525: PUSH
29526: LD_VAR 0 3
29530: ARRAY
29531: PPUSH
29532: CALL_OW 2
29536: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29537: LD_ADDR_VAR 0 4
29541: PUSH
29542: LD_VAR 0 4
29546: PUSH
29547: LD_VAR 0 9
29551: PUSH
29552: LD_VAR 0 3
29556: ARRAY
29557: DIFF
29558: ST_TO_ADDR
// end ;
29559: GO 29468
29561: POP
29562: POP
// if p then
29563: LD_VAR 0 11
29567: IFFALSE 29592
// result := Replace ( result , 3 , p ) ;
29569: LD_ADDR_VAR 0 2
29573: PUSH
29574: LD_VAR 0 2
29578: PPUSH
29579: LD_INT 3
29581: PPUSH
29582: LD_VAR 0 11
29586: PPUSH
29587: CALL_OW 1
29591: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29592: LD_ADDR_VAR 0 4
29596: PUSH
29597: LD_VAR 0 4
29601: PUSH
29602: LD_VAR 0 6
29606: DIFF
29607: ST_TO_ADDR
// if tmp and eng < 6 then
29608: LD_VAR 0 4
29612: PUSH
29613: LD_VAR 0 6
29617: PUSH
29618: LD_INT 6
29620: LESS
29621: AND
29622: IFFALSE 29816
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29624: LD_ADDR_VAR 0 9
29628: PUSH
29629: LD_VAR 0 4
29633: PUSH
29634: LD_VAR 0 8
29638: PUSH
29639: LD_VAR 0 7
29643: UNION
29644: PUSH
29645: LD_VAR 0 6
29649: UNION
29650: DIFF
29651: PPUSH
29652: LD_INT 2
29654: PPUSH
29655: CALL 89109 0 2
29659: ST_TO_ADDR
// p := [ ] ;
29660: LD_ADDR_VAR 0 11
29664: PUSH
29665: EMPTY
29666: ST_TO_ADDR
// if sort then
29667: LD_VAR 0 9
29671: IFFALSE 29787
// for i = 1 to 6 - eng do
29673: LD_ADDR_VAR 0 3
29677: PUSH
29678: DOUBLE
29679: LD_INT 1
29681: DEC
29682: ST_TO_ADDR
29683: LD_INT 6
29685: PUSH
29686: LD_VAR 0 6
29690: MINUS
29691: PUSH
29692: FOR_TO
29693: IFFALSE 29785
// begin if i = sort then
29695: LD_VAR 0 3
29699: PUSH
29700: LD_VAR 0 9
29704: EQUAL
29705: IFFALSE 29709
// break ;
29707: GO 29785
// if GetClass ( i ) = 2 then
29709: LD_VAR 0 3
29713: PPUSH
29714: CALL_OW 257
29718: PUSH
29719: LD_INT 2
29721: EQUAL
29722: IFFALSE 29726
// continue ;
29724: GO 29692
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29726: LD_ADDR_VAR 0 11
29730: PUSH
29731: LD_VAR 0 11
29735: PPUSH
29736: LD_VAR 0 11
29740: PUSH
29741: LD_INT 1
29743: PLUS
29744: PPUSH
29745: LD_VAR 0 9
29749: PUSH
29750: LD_VAR 0 3
29754: ARRAY
29755: PPUSH
29756: CALL_OW 2
29760: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29761: LD_ADDR_VAR 0 4
29765: PUSH
29766: LD_VAR 0 4
29770: PUSH
29771: LD_VAR 0 9
29775: PUSH
29776: LD_VAR 0 3
29780: ARRAY
29781: DIFF
29782: ST_TO_ADDR
// end ;
29783: GO 29692
29785: POP
29786: POP
// if p then
29787: LD_VAR 0 11
29791: IFFALSE 29816
// result := Replace ( result , 2 , p ) ;
29793: LD_ADDR_VAR 0 2
29797: PUSH
29798: LD_VAR 0 2
29802: PPUSH
29803: LD_INT 2
29805: PPUSH
29806: LD_VAR 0 11
29810: PPUSH
29811: CALL_OW 1
29815: ST_TO_ADDR
// end ; exit ;
29816: GO 30540
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
29818: LD_EXP 105
29822: PUSH
29823: LD_EXP 104
29827: PUSH
29828: LD_VAR 0 1
29832: ARRAY
29833: ARRAY
29834: NOT
29835: PUSH
29836: LD_EXP 78
29840: PUSH
29841: LD_VAR 0 1
29845: ARRAY
29846: PPUSH
29847: LD_INT 30
29849: PUSH
29850: LD_INT 3
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PPUSH
29857: CALL_OW 72
29861: AND
29862: PUSH
29863: LD_EXP 83
29867: PUSH
29868: LD_VAR 0 1
29872: ARRAY
29873: NOT
29874: AND
29875: IFFALSE 30540
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29877: LD_ADDR_EXP 120
29881: PUSH
29882: LD_EXP 120
29886: PPUSH
29887: LD_VAR 0 1
29891: PPUSH
29892: LD_INT 6
29894: PPUSH
29895: CALL_OW 1
29899: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29900: LD_ADDR_VAR 0 2
29904: PUSH
29905: LD_INT 0
29907: PUSH
29908: LD_INT 0
29910: PUSH
29911: LD_INT 0
29913: PUSH
29914: LD_INT 0
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: LIST
29921: LIST
29922: ST_TO_ADDR
// if sci >= 1 then
29923: LD_VAR 0 8
29927: PUSH
29928: LD_INT 1
29930: GREATEREQUAL
29931: IFFALSE 29953
// tmp := tmp diff sci [ 1 ] ;
29933: LD_ADDR_VAR 0 4
29937: PUSH
29938: LD_VAR 0 4
29942: PUSH
29943: LD_VAR 0 8
29947: PUSH
29948: LD_INT 1
29950: ARRAY
29951: DIFF
29952: ST_TO_ADDR
// if tmp and not sci then
29953: LD_VAR 0 4
29957: PUSH
29958: LD_VAR 0 8
29962: NOT
29963: AND
29964: IFFALSE 30033
// begin sort := SortBySkill ( tmp , 4 ) ;
29966: LD_ADDR_VAR 0 9
29970: PUSH
29971: LD_VAR 0 4
29975: PPUSH
29976: LD_INT 4
29978: PPUSH
29979: CALL 89109 0 2
29983: ST_TO_ADDR
// if sort then
29984: LD_VAR 0 9
29988: IFFALSE 30004
// p := sort [ 1 ] ;
29990: LD_ADDR_VAR 0 11
29994: PUSH
29995: LD_VAR 0 9
29999: PUSH
30000: LD_INT 1
30002: ARRAY
30003: ST_TO_ADDR
// if p then
30004: LD_VAR 0 11
30008: IFFALSE 30033
// result := Replace ( result , 4 , p ) ;
30010: LD_ADDR_VAR 0 2
30014: PUSH
30015: LD_VAR 0 2
30019: PPUSH
30020: LD_INT 4
30022: PPUSH
30023: LD_VAR 0 11
30027: PPUSH
30028: CALL_OW 1
30032: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30033: LD_ADDR_VAR 0 4
30037: PUSH
30038: LD_VAR 0 4
30042: PUSH
30043: LD_VAR 0 7
30047: DIFF
30048: ST_TO_ADDR
// if tmp and mech < 6 then
30049: LD_VAR 0 4
30053: PUSH
30054: LD_VAR 0 7
30058: PUSH
30059: LD_INT 6
30061: LESS
30062: AND
30063: IFFALSE 30245
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
30065: LD_ADDR_VAR 0 9
30069: PUSH
30070: LD_VAR 0 4
30074: PUSH
30075: LD_VAR 0 7
30079: DIFF
30080: PPUSH
30081: LD_INT 3
30083: PPUSH
30084: CALL 89109 0 2
30088: ST_TO_ADDR
// p := [ ] ;
30089: LD_ADDR_VAR 0 11
30093: PUSH
30094: EMPTY
30095: ST_TO_ADDR
// if sort then
30096: LD_VAR 0 9
30100: IFFALSE 30216
// for i = 1 to 6 - mech do
30102: LD_ADDR_VAR 0 3
30106: PUSH
30107: DOUBLE
30108: LD_INT 1
30110: DEC
30111: ST_TO_ADDR
30112: LD_INT 6
30114: PUSH
30115: LD_VAR 0 7
30119: MINUS
30120: PUSH
30121: FOR_TO
30122: IFFALSE 30214
// begin if i = sort then
30124: LD_VAR 0 3
30128: PUSH
30129: LD_VAR 0 9
30133: EQUAL
30134: IFFALSE 30138
// break ;
30136: GO 30214
// if GetClass ( i ) = 3 then
30138: LD_VAR 0 3
30142: PPUSH
30143: CALL_OW 257
30147: PUSH
30148: LD_INT 3
30150: EQUAL
30151: IFFALSE 30155
// continue ;
30153: GO 30121
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30155: LD_ADDR_VAR 0 11
30159: PUSH
30160: LD_VAR 0 11
30164: PPUSH
30165: LD_VAR 0 11
30169: PUSH
30170: LD_INT 1
30172: PLUS
30173: PPUSH
30174: LD_VAR 0 9
30178: PUSH
30179: LD_VAR 0 3
30183: ARRAY
30184: PPUSH
30185: CALL_OW 2
30189: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30190: LD_ADDR_VAR 0 4
30194: PUSH
30195: LD_VAR 0 4
30199: PUSH
30200: LD_VAR 0 9
30204: PUSH
30205: LD_VAR 0 3
30209: ARRAY
30210: DIFF
30211: ST_TO_ADDR
// end ;
30212: GO 30121
30214: POP
30215: POP
// if p then
30216: LD_VAR 0 11
30220: IFFALSE 30245
// result := Replace ( result , 3 , p ) ;
30222: LD_ADDR_VAR 0 2
30226: PUSH
30227: LD_VAR 0 2
30231: PPUSH
30232: LD_INT 3
30234: PPUSH
30235: LD_VAR 0 11
30239: PPUSH
30240: CALL_OW 1
30244: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30245: LD_ADDR_VAR 0 4
30249: PUSH
30250: LD_VAR 0 4
30254: PUSH
30255: LD_VAR 0 6
30259: DIFF
30260: ST_TO_ADDR
// if tmp and eng < 4 then
30261: LD_VAR 0 4
30265: PUSH
30266: LD_VAR 0 6
30270: PUSH
30271: LD_INT 4
30273: LESS
30274: AND
30275: IFFALSE 30465
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
30277: LD_ADDR_VAR 0 9
30281: PUSH
30282: LD_VAR 0 4
30286: PUSH
30287: LD_VAR 0 7
30291: PUSH
30292: LD_VAR 0 6
30296: UNION
30297: DIFF
30298: PPUSH
30299: LD_INT 2
30301: PPUSH
30302: CALL 89109 0 2
30306: ST_TO_ADDR
// p := [ ] ;
30307: LD_ADDR_VAR 0 11
30311: PUSH
30312: EMPTY
30313: ST_TO_ADDR
// if sort then
30314: LD_VAR 0 9
30318: IFFALSE 30434
// for i = 1 to 4 - eng do
30320: LD_ADDR_VAR 0 3
30324: PUSH
30325: DOUBLE
30326: LD_INT 1
30328: DEC
30329: ST_TO_ADDR
30330: LD_INT 4
30332: PUSH
30333: LD_VAR 0 6
30337: MINUS
30338: PUSH
30339: FOR_TO
30340: IFFALSE 30432
// begin if i = sort then
30342: LD_VAR 0 3
30346: PUSH
30347: LD_VAR 0 9
30351: EQUAL
30352: IFFALSE 30356
// break ;
30354: GO 30432
// if GetClass ( i ) = 2 then
30356: LD_VAR 0 3
30360: PPUSH
30361: CALL_OW 257
30365: PUSH
30366: LD_INT 2
30368: EQUAL
30369: IFFALSE 30373
// continue ;
30371: GO 30339
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30373: LD_ADDR_VAR 0 11
30377: PUSH
30378: LD_VAR 0 11
30382: PPUSH
30383: LD_VAR 0 11
30387: PUSH
30388: LD_INT 1
30390: PLUS
30391: PPUSH
30392: LD_VAR 0 9
30396: PUSH
30397: LD_VAR 0 3
30401: ARRAY
30402: PPUSH
30403: CALL_OW 2
30407: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30408: LD_ADDR_VAR 0 4
30412: PUSH
30413: LD_VAR 0 4
30417: PUSH
30418: LD_VAR 0 9
30422: PUSH
30423: LD_VAR 0 3
30427: ARRAY
30428: DIFF
30429: ST_TO_ADDR
// end ;
30430: GO 30339
30432: POP
30433: POP
// if p then
30434: LD_VAR 0 11
30438: IFFALSE 30463
// result := Replace ( result , 2 , p ) ;
30440: LD_ADDR_VAR 0 2
30444: PUSH
30445: LD_VAR 0 2
30449: PPUSH
30450: LD_INT 2
30452: PPUSH
30453: LD_VAR 0 11
30457: PPUSH
30458: CALL_OW 1
30462: ST_TO_ADDR
// end else
30463: GO 30509
// for i = eng downto 5 do
30465: LD_ADDR_VAR 0 3
30469: PUSH
30470: DOUBLE
30471: LD_VAR 0 6
30475: INC
30476: ST_TO_ADDR
30477: LD_INT 5
30479: PUSH
30480: FOR_DOWNTO
30481: IFFALSE 30507
// tmp := tmp union eng [ i ] ;
30483: LD_ADDR_VAR 0 4
30487: PUSH
30488: LD_VAR 0 4
30492: PUSH
30493: LD_VAR 0 6
30497: PUSH
30498: LD_VAR 0 3
30502: ARRAY
30503: UNION
30504: ST_TO_ADDR
30505: GO 30480
30507: POP
30508: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
30509: LD_ADDR_VAR 0 2
30513: PUSH
30514: LD_VAR 0 2
30518: PPUSH
30519: LD_INT 1
30521: PPUSH
30522: LD_VAR 0 4
30526: PUSH
30527: LD_VAR 0 5
30531: DIFF
30532: PPUSH
30533: CALL_OW 1
30537: ST_TO_ADDR
// exit ;
30538: GO 30540
// end ; end ;
30540: LD_VAR 0 2
30544: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
30545: LD_INT 0
30547: PPUSH
30548: PPUSH
30549: PPUSH
// if not mc_bases then
30550: LD_EXP 78
30554: NOT
30555: IFFALSE 30559
// exit ;
30557: GO 30701
// for i = 1 to mc_bases do
30559: LD_ADDR_VAR 0 2
30563: PUSH
30564: DOUBLE
30565: LD_INT 1
30567: DEC
30568: ST_TO_ADDR
30569: LD_EXP 78
30573: PUSH
30574: FOR_TO
30575: IFFALSE 30692
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
30577: LD_ADDR_VAR 0 3
30581: PUSH
30582: LD_EXP 78
30586: PUSH
30587: LD_VAR 0 2
30591: ARRAY
30592: PPUSH
30593: LD_INT 21
30595: PUSH
30596: LD_INT 3
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 3
30605: PUSH
30606: LD_INT 2
30608: PUSH
30609: LD_INT 30
30611: PUSH
30612: LD_INT 29
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 30
30621: PUSH
30622: LD_INT 30
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: LIST
30633: PUSH
30634: EMPTY
30635: LIST
30636: LIST
30637: PUSH
30638: LD_INT 3
30640: PUSH
30641: LD_INT 24
30643: PUSH
30644: LD_INT 1000
30646: PUSH
30647: EMPTY
30648: LIST
30649: LIST
30650: PUSH
30651: EMPTY
30652: LIST
30653: LIST
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: LIST
30659: PPUSH
30660: CALL_OW 72
30664: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
30665: LD_ADDR_EXP 79
30669: PUSH
30670: LD_EXP 79
30674: PPUSH
30675: LD_VAR 0 2
30679: PPUSH
30680: LD_VAR 0 3
30684: PPUSH
30685: CALL_OW 1
30689: ST_TO_ADDR
// end ;
30690: GO 30574
30692: POP
30693: POP
// RaiseSailEvent ( 101 ) ;
30694: LD_INT 101
30696: PPUSH
30697: CALL_OW 427
// end ;
30701: LD_VAR 0 1
30705: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
30706: LD_INT 0
30708: PPUSH
30709: PPUSH
30710: PPUSH
30711: PPUSH
30712: PPUSH
30713: PPUSH
30714: PPUSH
// if not mc_bases then
30715: LD_EXP 78
30719: NOT
30720: IFFALSE 30724
// exit ;
30722: GO 31286
// for i = 1 to mc_bases do
30724: LD_ADDR_VAR 0 2
30728: PUSH
30729: DOUBLE
30730: LD_INT 1
30732: DEC
30733: ST_TO_ADDR
30734: LD_EXP 78
30738: PUSH
30739: FOR_TO
30740: IFFALSE 31277
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
30742: LD_ADDR_VAR 0 5
30746: PUSH
30747: LD_EXP 78
30751: PUSH
30752: LD_VAR 0 2
30756: ARRAY
30757: PUSH
30758: LD_EXP 107
30762: PUSH
30763: LD_VAR 0 2
30767: ARRAY
30768: UNION
30769: PPUSH
30770: LD_INT 21
30772: PUSH
30773: LD_INT 1
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: PUSH
30783: LD_INT 3
30785: PUSH
30786: LD_INT 54
30788: PUSH
30789: EMPTY
30790: LIST
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 3
30798: PUSH
30799: LD_INT 24
30801: PUSH
30802: LD_INT 1000
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: LIST
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: PPUSH
30822: CALL_OW 72
30826: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30827: LD_ADDR_VAR 0 6
30831: PUSH
30832: LD_EXP 78
30836: PUSH
30837: LD_VAR 0 2
30841: ARRAY
30842: PPUSH
30843: LD_INT 21
30845: PUSH
30846: LD_INT 1
30848: PUSH
30849: EMPTY
30850: LIST
30851: LIST
30852: PUSH
30853: LD_INT 1
30855: PUSH
30856: LD_INT 3
30858: PUSH
30859: LD_INT 54
30861: PUSH
30862: EMPTY
30863: LIST
30864: PUSH
30865: EMPTY
30866: LIST
30867: LIST
30868: PUSH
30869: LD_INT 3
30871: PUSH
30872: LD_INT 24
30874: PUSH
30875: LD_INT 250
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: EMPTY
30883: LIST
30884: LIST
30885: PUSH
30886: EMPTY
30887: LIST
30888: LIST
30889: LIST
30890: PUSH
30891: EMPTY
30892: LIST
30893: LIST
30894: PPUSH
30895: CALL_OW 72
30899: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30900: LD_ADDR_VAR 0 7
30904: PUSH
30905: LD_VAR 0 5
30909: PUSH
30910: LD_VAR 0 6
30914: DIFF
30915: ST_TO_ADDR
// if not need_heal_1 then
30916: LD_VAR 0 6
30920: NOT
30921: IFFALSE 30954
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30923: LD_ADDR_EXP 81
30927: PUSH
30928: LD_EXP 81
30932: PPUSH
30933: LD_VAR 0 2
30937: PUSH
30938: LD_INT 1
30940: PUSH
30941: EMPTY
30942: LIST
30943: LIST
30944: PPUSH
30945: EMPTY
30946: PPUSH
30947: CALL 57865 0 3
30951: ST_TO_ADDR
30952: GO 31024
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30954: LD_ADDR_EXP 81
30958: PUSH
30959: LD_EXP 81
30963: PPUSH
30964: LD_VAR 0 2
30968: PUSH
30969: LD_INT 1
30971: PUSH
30972: EMPTY
30973: LIST
30974: LIST
30975: PPUSH
30976: LD_EXP 81
30980: PUSH
30981: LD_VAR 0 2
30985: ARRAY
30986: PUSH
30987: LD_INT 1
30989: ARRAY
30990: PPUSH
30991: LD_INT 3
30993: PUSH
30994: LD_INT 24
30996: PUSH
30997: LD_INT 1000
30999: PUSH
31000: EMPTY
31001: LIST
31002: LIST
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PPUSH
31008: CALL_OW 72
31012: PUSH
31013: LD_VAR 0 6
31017: UNION
31018: PPUSH
31019: CALL 57865 0 3
31023: ST_TO_ADDR
// if not need_heal_2 then
31024: LD_VAR 0 7
31028: NOT
31029: IFFALSE 31062
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
31031: LD_ADDR_EXP 81
31035: PUSH
31036: LD_EXP 81
31040: PPUSH
31041: LD_VAR 0 2
31045: PUSH
31046: LD_INT 2
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: PPUSH
31053: EMPTY
31054: PPUSH
31055: CALL 57865 0 3
31059: ST_TO_ADDR
31060: GO 31094
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
31062: LD_ADDR_EXP 81
31066: PUSH
31067: LD_EXP 81
31071: PPUSH
31072: LD_VAR 0 2
31076: PUSH
31077: LD_INT 2
31079: PUSH
31080: EMPTY
31081: LIST
31082: LIST
31083: PPUSH
31084: LD_VAR 0 7
31088: PPUSH
31089: CALL 57865 0 3
31093: ST_TO_ADDR
// if need_heal_2 then
31094: LD_VAR 0 7
31098: IFFALSE 31259
// for j in need_heal_2 do
31100: LD_ADDR_VAR 0 3
31104: PUSH
31105: LD_VAR 0 7
31109: PUSH
31110: FOR_IN
31111: IFFALSE 31257
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31113: LD_ADDR_VAR 0 5
31117: PUSH
31118: LD_EXP 78
31122: PUSH
31123: LD_VAR 0 2
31127: ARRAY
31128: PPUSH
31129: LD_INT 2
31131: PUSH
31132: LD_INT 30
31134: PUSH
31135: LD_INT 6
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 30
31144: PUSH
31145: LD_INT 7
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 30
31154: PUSH
31155: LD_INT 8
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 30
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 30
31174: PUSH
31175: LD_INT 1
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: EMPTY
31183: LIST
31184: LIST
31185: LIST
31186: LIST
31187: LIST
31188: LIST
31189: PPUSH
31190: CALL_OW 72
31194: ST_TO_ADDR
// if tmp then
31195: LD_VAR 0 5
31199: IFFALSE 31255
// begin k := NearestUnitToUnit ( tmp , j ) ;
31201: LD_ADDR_VAR 0 4
31205: PUSH
31206: LD_VAR 0 5
31210: PPUSH
31211: LD_VAR 0 3
31215: PPUSH
31216: CALL_OW 74
31220: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
31221: LD_VAR 0 3
31225: PPUSH
31226: LD_VAR 0 4
31230: PPUSH
31231: CALL_OW 296
31235: PUSH
31236: LD_INT 5
31238: GREATER
31239: IFFALSE 31255
// ComMoveToNearbyEntrance ( j , k ) ;
31241: LD_VAR 0 3
31245: PPUSH
31246: LD_VAR 0 4
31250: PPUSH
31251: CALL 91482 0 2
// end ; end ;
31255: GO 31110
31257: POP
31258: POP
// if not need_heal_1 and not need_heal_2 then
31259: LD_VAR 0 6
31263: NOT
31264: PUSH
31265: LD_VAR 0 7
31269: NOT
31270: AND
31271: IFFALSE 31275
// continue ;
31273: GO 30739
// end ;
31275: GO 30739
31277: POP
31278: POP
// RaiseSailEvent ( 102 ) ;
31279: LD_INT 102
31281: PPUSH
31282: CALL_OW 427
// end ;
31286: LD_VAR 0 1
31290: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
31291: LD_INT 0
31293: PPUSH
31294: PPUSH
31295: PPUSH
31296: PPUSH
31297: PPUSH
31298: PPUSH
31299: PPUSH
31300: PPUSH
// if not mc_bases then
31301: LD_EXP 78
31305: NOT
31306: IFFALSE 31310
// exit ;
31308: GO 32221
// for i = 1 to mc_bases do
31310: LD_ADDR_VAR 0 2
31314: PUSH
31315: DOUBLE
31316: LD_INT 1
31318: DEC
31319: ST_TO_ADDR
31320: LD_EXP 78
31324: PUSH
31325: FOR_TO
31326: IFFALSE 32219
// begin if not mc_building_need_repair [ i ] then
31328: LD_EXP 79
31332: PUSH
31333: LD_VAR 0 2
31337: ARRAY
31338: NOT
31339: IFFALSE 31524
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
31341: LD_ADDR_VAR 0 6
31345: PUSH
31346: LD_EXP 97
31350: PUSH
31351: LD_VAR 0 2
31355: ARRAY
31356: PPUSH
31357: LD_INT 3
31359: PUSH
31360: LD_INT 24
31362: PUSH
31363: LD_INT 1000
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: LD_INT 34
31379: PUSH
31380: LD_INT 13
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 34
31389: PUSH
31390: LD_INT 52
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 34
31399: PUSH
31400: LD_INT 88
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: EMPTY
31408: LIST
31409: LIST
31410: LIST
31411: LIST
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PPUSH
31417: CALL_OW 72
31421: ST_TO_ADDR
// if cranes then
31422: LD_VAR 0 6
31426: IFFALSE 31488
// for j in cranes do
31428: LD_ADDR_VAR 0 3
31432: PUSH
31433: LD_VAR 0 6
31437: PUSH
31438: FOR_IN
31439: IFFALSE 31486
// if not IsInArea ( j , mc_parking [ i ] ) then
31441: LD_VAR 0 3
31445: PPUSH
31446: LD_EXP 102
31450: PUSH
31451: LD_VAR 0 2
31455: ARRAY
31456: PPUSH
31457: CALL_OW 308
31461: NOT
31462: IFFALSE 31484
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31464: LD_VAR 0 3
31468: PPUSH
31469: LD_EXP 102
31473: PUSH
31474: LD_VAR 0 2
31478: ARRAY
31479: PPUSH
31480: CALL_OW 113
31484: GO 31438
31486: POP
31487: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
31488: LD_ADDR_EXP 80
31492: PUSH
31493: LD_EXP 80
31497: PPUSH
31498: LD_VAR 0 2
31502: PPUSH
31503: EMPTY
31504: PPUSH
31505: CALL_OW 1
31509: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
31510: LD_VAR 0 2
31514: PPUSH
31515: LD_INT 101
31517: PPUSH
31518: CALL 26364 0 2
// continue ;
31522: GO 31325
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
31524: LD_ADDR_EXP 84
31528: PUSH
31529: LD_EXP 84
31533: PPUSH
31534: LD_VAR 0 2
31538: PPUSH
31539: EMPTY
31540: PPUSH
31541: CALL_OW 1
31545: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31546: LD_VAR 0 2
31550: PPUSH
31551: LD_INT 103
31553: PPUSH
31554: CALL 26364 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
31558: LD_ADDR_VAR 0 5
31562: PUSH
31563: LD_EXP 78
31567: PUSH
31568: LD_VAR 0 2
31572: ARRAY
31573: PUSH
31574: LD_EXP 107
31578: PUSH
31579: LD_VAR 0 2
31583: ARRAY
31584: UNION
31585: PPUSH
31586: LD_INT 2
31588: PUSH
31589: LD_INT 25
31591: PUSH
31592: LD_INT 2
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PUSH
31599: LD_INT 25
31601: PUSH
31602: LD_INT 16
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: LIST
31613: PUSH
31614: EMPTY
31615: LIST
31616: PPUSH
31617: CALL_OW 72
31621: ST_TO_ADDR
// if mc_need_heal [ i ] then
31622: LD_EXP 81
31626: PUSH
31627: LD_VAR 0 2
31631: ARRAY
31632: IFFALSE 31676
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
31634: LD_ADDR_VAR 0 5
31638: PUSH
31639: LD_VAR 0 5
31643: PUSH
31644: LD_EXP 81
31648: PUSH
31649: LD_VAR 0 2
31653: ARRAY
31654: PUSH
31655: LD_INT 1
31657: ARRAY
31658: PUSH
31659: LD_EXP 81
31663: PUSH
31664: LD_VAR 0 2
31668: ARRAY
31669: PUSH
31670: LD_INT 2
31672: ARRAY
31673: UNION
31674: DIFF
31675: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
31676: LD_ADDR_VAR 0 6
31680: PUSH
31681: LD_EXP 97
31685: PUSH
31686: LD_VAR 0 2
31690: ARRAY
31691: PPUSH
31692: LD_INT 2
31694: PUSH
31695: LD_INT 34
31697: PUSH
31698: LD_INT 13
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 34
31707: PUSH
31708: LD_INT 52
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 34
31717: PUSH
31718: LD_INT 88
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: EMPTY
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: PPUSH
31731: CALL_OW 72
31735: ST_TO_ADDR
// if cranes then
31736: LD_VAR 0 6
31740: IFFALSE 31908
// begin for j in cranes do
31742: LD_ADDR_VAR 0 3
31746: PUSH
31747: LD_VAR 0 6
31751: PUSH
31752: FOR_IN
31753: IFFALSE 31906
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
31755: LD_VAR 0 3
31759: PPUSH
31760: CALL_OW 256
31764: PUSH
31765: LD_INT 1000
31767: EQUAL
31768: PUSH
31769: LD_VAR 0 3
31773: PPUSH
31774: CALL_OW 314
31778: NOT
31779: AND
31780: IFFALSE 31846
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
31782: LD_ADDR_VAR 0 8
31786: PUSH
31787: LD_EXP 79
31791: PUSH
31792: LD_VAR 0 2
31796: ARRAY
31797: PPUSH
31798: LD_VAR 0 3
31802: PPUSH
31803: CALL_OW 74
31807: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31808: LD_VAR 0 8
31812: PPUSH
31813: LD_INT 16
31815: PPUSH
31816: CALL 60830 0 2
31820: PUSH
31821: LD_INT 4
31823: ARRAY
31824: PUSH
31825: LD_INT 10
31827: LESS
31828: IFFALSE 31844
// ComRepairBuilding ( j , to_repair ) ;
31830: LD_VAR 0 3
31834: PPUSH
31835: LD_VAR 0 8
31839: PPUSH
31840: CALL_OW 130
// end else
31844: GO 31904
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
31846: LD_VAR 0 3
31850: PPUSH
31851: CALL_OW 256
31855: PUSH
31856: LD_INT 500
31858: LESS
31859: PUSH
31860: LD_VAR 0 3
31864: PPUSH
31865: LD_EXP 102
31869: PUSH
31870: LD_VAR 0 2
31874: ARRAY
31875: PPUSH
31876: CALL_OW 308
31880: NOT
31881: AND
31882: IFFALSE 31904
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31884: LD_VAR 0 3
31888: PPUSH
31889: LD_EXP 102
31893: PUSH
31894: LD_VAR 0 2
31898: ARRAY
31899: PPUSH
31900: CALL_OW 113
// end ;
31904: GO 31752
31906: POP
31907: POP
// end ; if tmp > 3 then
31908: LD_VAR 0 5
31912: PUSH
31913: LD_INT 3
31915: GREATER
31916: IFFALSE 31936
// tmp := ShrinkArray ( tmp , 4 ) ;
31918: LD_ADDR_VAR 0 5
31922: PUSH
31923: LD_VAR 0 5
31927: PPUSH
31928: LD_INT 4
31930: PPUSH
31931: CALL 90920 0 2
31935: ST_TO_ADDR
// if not tmp then
31936: LD_VAR 0 5
31940: NOT
31941: IFFALSE 31945
// continue ;
31943: GO 31325
// for j in tmp do
31945: LD_ADDR_VAR 0 3
31949: PUSH
31950: LD_VAR 0 5
31954: PUSH
31955: FOR_IN
31956: IFFALSE 32215
// begin if IsInUnit ( j ) then
31958: LD_VAR 0 3
31962: PPUSH
31963: CALL_OW 310
31967: IFFALSE 31978
// ComExitBuilding ( j ) ;
31969: LD_VAR 0 3
31973: PPUSH
31974: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31978: LD_VAR 0 3
31982: PUSH
31983: LD_EXP 80
31987: PUSH
31988: LD_VAR 0 2
31992: ARRAY
31993: IN
31994: NOT
31995: IFFALSE 32053
// begin SetTag ( j , 101 ) ;
31997: LD_VAR 0 3
32001: PPUSH
32002: LD_INT 101
32004: PPUSH
32005: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
32009: LD_ADDR_EXP 80
32013: PUSH
32014: LD_EXP 80
32018: PPUSH
32019: LD_VAR 0 2
32023: PUSH
32024: LD_EXP 80
32028: PUSH
32029: LD_VAR 0 2
32033: ARRAY
32034: PUSH
32035: LD_INT 1
32037: PLUS
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: PPUSH
32043: LD_VAR 0 3
32047: PPUSH
32048: CALL 57865 0 3
32052: ST_TO_ADDR
// end ; wait ( 1 ) ;
32053: LD_INT 1
32055: PPUSH
32056: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
32060: LD_ADDR_VAR 0 7
32064: PUSH
32065: LD_EXP 79
32069: PUSH
32070: LD_VAR 0 2
32074: ARRAY
32075: ST_TO_ADDR
// if mc_scan [ i ] then
32076: LD_EXP 101
32080: PUSH
32081: LD_VAR 0 2
32085: ARRAY
32086: IFFALSE 32148
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
32088: LD_ADDR_VAR 0 7
32092: PUSH
32093: LD_EXP 79
32097: PUSH
32098: LD_VAR 0 2
32102: ARRAY
32103: PPUSH
32104: LD_INT 3
32106: PUSH
32107: LD_INT 30
32109: PUSH
32110: LD_INT 32
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 30
32119: PUSH
32120: LD_INT 33
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 30
32129: PUSH
32130: LD_INT 31
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: LIST
32141: LIST
32142: PPUSH
32143: CALL_OW 72
32147: ST_TO_ADDR
// if not to_repair_tmp then
32148: LD_VAR 0 7
32152: NOT
32153: IFFALSE 32157
// continue ;
32155: GO 31955
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32157: LD_ADDR_VAR 0 8
32161: PUSH
32162: LD_VAR 0 7
32166: PPUSH
32167: LD_VAR 0 3
32171: PPUSH
32172: CALL_OW 74
32176: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
32177: LD_VAR 0 8
32181: PPUSH
32182: LD_INT 16
32184: PPUSH
32185: CALL 60830 0 2
32189: PUSH
32190: LD_INT 4
32192: ARRAY
32193: PUSH
32194: LD_INT 14
32196: LESS
32197: IFFALSE 32213
// ComRepairBuilding ( j , to_repair ) ;
32199: LD_VAR 0 3
32203: PPUSH
32204: LD_VAR 0 8
32208: PPUSH
32209: CALL_OW 130
// end ;
32213: GO 31955
32215: POP
32216: POP
// end ;
32217: GO 31325
32219: POP
32220: POP
// end ;
32221: LD_VAR 0 1
32225: RET
// export function MC_Heal ; var i , j , tmp ; begin
32226: LD_INT 0
32228: PPUSH
32229: PPUSH
32230: PPUSH
32231: PPUSH
// if not mc_bases then
32232: LD_EXP 78
32236: NOT
32237: IFFALSE 32241
// exit ;
32239: GO 32643
// for i = 1 to mc_bases do
32241: LD_ADDR_VAR 0 2
32245: PUSH
32246: DOUBLE
32247: LD_INT 1
32249: DEC
32250: ST_TO_ADDR
32251: LD_EXP 78
32255: PUSH
32256: FOR_TO
32257: IFFALSE 32641
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
32259: LD_EXP 81
32263: PUSH
32264: LD_VAR 0 2
32268: ARRAY
32269: PUSH
32270: LD_INT 1
32272: ARRAY
32273: NOT
32274: PUSH
32275: LD_EXP 81
32279: PUSH
32280: LD_VAR 0 2
32284: ARRAY
32285: PUSH
32286: LD_INT 2
32288: ARRAY
32289: NOT
32290: AND
32291: IFFALSE 32329
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
32293: LD_ADDR_EXP 82
32297: PUSH
32298: LD_EXP 82
32302: PPUSH
32303: LD_VAR 0 2
32307: PPUSH
32308: EMPTY
32309: PPUSH
32310: CALL_OW 1
32314: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
32315: LD_VAR 0 2
32319: PPUSH
32320: LD_INT 102
32322: PPUSH
32323: CALL 26364 0 2
// continue ;
32327: GO 32256
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
32329: LD_ADDR_VAR 0 4
32333: PUSH
32334: LD_EXP 78
32338: PUSH
32339: LD_VAR 0 2
32343: ARRAY
32344: PPUSH
32345: LD_INT 25
32347: PUSH
32348: LD_INT 4
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PPUSH
32355: CALL_OW 72
32359: ST_TO_ADDR
// if not tmp then
32360: LD_VAR 0 4
32364: NOT
32365: IFFALSE 32369
// continue ;
32367: GO 32256
// if mc_taming [ i ] then
32369: LD_EXP 109
32373: PUSH
32374: LD_VAR 0 2
32378: ARRAY
32379: IFFALSE 32403
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
32381: LD_ADDR_EXP 109
32385: PUSH
32386: LD_EXP 109
32390: PPUSH
32391: LD_VAR 0 2
32395: PPUSH
32396: EMPTY
32397: PPUSH
32398: CALL_OW 1
32402: ST_TO_ADDR
// for j in tmp do
32403: LD_ADDR_VAR 0 3
32407: PUSH
32408: LD_VAR 0 4
32412: PUSH
32413: FOR_IN
32414: IFFALSE 32637
// begin if IsInUnit ( j ) then
32416: LD_VAR 0 3
32420: PPUSH
32421: CALL_OW 310
32425: IFFALSE 32436
// ComExitBuilding ( j ) ;
32427: LD_VAR 0 3
32431: PPUSH
32432: CALL_OW 122
// if not j in mc_healers [ i ] then
32436: LD_VAR 0 3
32440: PUSH
32441: LD_EXP 82
32445: PUSH
32446: LD_VAR 0 2
32450: ARRAY
32451: IN
32452: NOT
32453: IFFALSE 32499
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
32455: LD_ADDR_EXP 82
32459: PUSH
32460: LD_EXP 82
32464: PPUSH
32465: LD_VAR 0 2
32469: PUSH
32470: LD_EXP 82
32474: PUSH
32475: LD_VAR 0 2
32479: ARRAY
32480: PUSH
32481: LD_INT 1
32483: PLUS
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PPUSH
32489: LD_VAR 0 3
32493: PPUSH
32494: CALL 57865 0 3
32498: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
32499: LD_VAR 0 3
32503: PPUSH
32504: CALL_OW 110
32508: PUSH
32509: LD_INT 102
32511: NONEQUAL
32512: IFFALSE 32526
// SetTag ( j , 102 ) ;
32514: LD_VAR 0 3
32518: PPUSH
32519: LD_INT 102
32521: PPUSH
32522: CALL_OW 109
// Wait ( 3 ) ;
32526: LD_INT 3
32528: PPUSH
32529: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
32533: LD_EXP 81
32537: PUSH
32538: LD_VAR 0 2
32542: ARRAY
32543: PUSH
32544: LD_INT 1
32546: ARRAY
32547: IFFALSE 32579
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
32549: LD_VAR 0 3
32553: PPUSH
32554: LD_EXP 81
32558: PUSH
32559: LD_VAR 0 2
32563: ARRAY
32564: PUSH
32565: LD_INT 1
32567: ARRAY
32568: PUSH
32569: LD_INT 1
32571: ARRAY
32572: PPUSH
32573: CALL_OW 128
32577: GO 32635
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
32579: LD_VAR 0 3
32583: PPUSH
32584: CALL_OW 314
32588: NOT
32589: PUSH
32590: LD_EXP 81
32594: PUSH
32595: LD_VAR 0 2
32599: ARRAY
32600: PUSH
32601: LD_INT 2
32603: ARRAY
32604: AND
32605: IFFALSE 32635
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
32607: LD_VAR 0 3
32611: PPUSH
32612: LD_EXP 81
32616: PUSH
32617: LD_VAR 0 2
32621: ARRAY
32622: PUSH
32623: LD_INT 2
32625: ARRAY
32626: PUSH
32627: LD_INT 1
32629: ARRAY
32630: PPUSH
32631: CALL_OW 128
// end ;
32635: GO 32413
32637: POP
32638: POP
// end ;
32639: GO 32256
32641: POP
32642: POP
// end ;
32643: LD_VAR 0 1
32647: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
32648: LD_INT 0
32650: PPUSH
32651: PPUSH
32652: PPUSH
32653: PPUSH
32654: PPUSH
32655: PPUSH
// if not mc_bases then
32656: LD_EXP 78
32660: NOT
32661: IFFALSE 32665
// exit ;
32663: GO 33828
// for i = 1 to mc_bases do
32665: LD_ADDR_VAR 0 2
32669: PUSH
32670: DOUBLE
32671: LD_INT 1
32673: DEC
32674: ST_TO_ADDR
32675: LD_EXP 78
32679: PUSH
32680: FOR_TO
32681: IFFALSE 33826
// begin if mc_scan [ i ] then
32683: LD_EXP 101
32687: PUSH
32688: LD_VAR 0 2
32692: ARRAY
32693: IFFALSE 32697
// continue ;
32695: GO 32680
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
32697: LD_EXP 83
32701: PUSH
32702: LD_VAR 0 2
32706: ARRAY
32707: NOT
32708: PUSH
32709: LD_EXP 85
32713: PUSH
32714: LD_VAR 0 2
32718: ARRAY
32719: NOT
32720: AND
32721: PUSH
32722: LD_EXP 84
32726: PUSH
32727: LD_VAR 0 2
32731: ARRAY
32732: AND
32733: IFFALSE 32771
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
32735: LD_ADDR_EXP 84
32739: PUSH
32740: LD_EXP 84
32744: PPUSH
32745: LD_VAR 0 2
32749: PPUSH
32750: EMPTY
32751: PPUSH
32752: CALL_OW 1
32756: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32757: LD_VAR 0 2
32761: PPUSH
32762: LD_INT 103
32764: PPUSH
32765: CALL 26364 0 2
// continue ;
32769: GO 32680
// end ; if mc_construct_list [ i ] then
32771: LD_EXP 85
32775: PUSH
32776: LD_VAR 0 2
32780: ARRAY
32781: IFFALSE 33001
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32783: LD_ADDR_VAR 0 5
32787: PUSH
32788: LD_EXP 78
32792: PUSH
32793: LD_VAR 0 2
32797: ARRAY
32798: PPUSH
32799: LD_INT 25
32801: PUSH
32802: LD_INT 2
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PPUSH
32809: CALL_OW 72
32813: PUSH
32814: LD_EXP 80
32818: PUSH
32819: LD_VAR 0 2
32823: ARRAY
32824: DIFF
32825: ST_TO_ADDR
// if not tmp then
32826: LD_VAR 0 5
32830: NOT
32831: IFFALSE 32835
// continue ;
32833: GO 32680
// for j in tmp do
32835: LD_ADDR_VAR 0 3
32839: PUSH
32840: LD_VAR 0 5
32844: PUSH
32845: FOR_IN
32846: IFFALSE 32997
// begin if not mc_builders [ i ] then
32848: LD_EXP 84
32852: PUSH
32853: LD_VAR 0 2
32857: ARRAY
32858: NOT
32859: IFFALSE 32917
// begin SetTag ( j , 103 ) ;
32861: LD_VAR 0 3
32865: PPUSH
32866: LD_INT 103
32868: PPUSH
32869: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32873: LD_ADDR_EXP 84
32877: PUSH
32878: LD_EXP 84
32882: PPUSH
32883: LD_VAR 0 2
32887: PUSH
32888: LD_EXP 84
32892: PUSH
32893: LD_VAR 0 2
32897: ARRAY
32898: PUSH
32899: LD_INT 1
32901: PLUS
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: PPUSH
32907: LD_VAR 0 3
32911: PPUSH
32912: CALL 57865 0 3
32916: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32917: LD_VAR 0 3
32921: PPUSH
32922: CALL_OW 310
32926: IFFALSE 32937
// ComExitBuilding ( j ) ;
32928: LD_VAR 0 3
32932: PPUSH
32933: CALL_OW 122
// wait ( 3 ) ;
32937: LD_INT 3
32939: PPUSH
32940: CALL_OW 67
// if not mc_construct_list [ i ] then
32944: LD_EXP 85
32948: PUSH
32949: LD_VAR 0 2
32953: ARRAY
32954: NOT
32955: IFFALSE 32959
// break ;
32957: GO 32997
// if not HasTask ( j ) then
32959: LD_VAR 0 3
32963: PPUSH
32964: CALL_OW 314
32968: NOT
32969: IFFALSE 32995
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32971: LD_VAR 0 3
32975: PPUSH
32976: LD_EXP 85
32980: PUSH
32981: LD_VAR 0 2
32985: ARRAY
32986: PUSH
32987: LD_INT 1
32989: ARRAY
32990: PPUSH
32991: CALL 61103 0 2
// end ;
32995: GO 32845
32997: POP
32998: POP
// end else
32999: GO 33824
// if mc_build_list [ i ] then
33001: LD_EXP 83
33005: PUSH
33006: LD_VAR 0 2
33010: ARRAY
33011: IFFALSE 33824
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
33013: LD_EXP 83
33017: PUSH
33018: LD_VAR 0 2
33022: ARRAY
33023: PUSH
33024: LD_INT 1
33026: ARRAY
33027: PUSH
33028: LD_INT 1
33030: ARRAY
33031: PPUSH
33032: CALL 60927 0 1
33036: PUSH
33037: LD_EXP 78
33041: PUSH
33042: LD_VAR 0 2
33046: ARRAY
33047: PPUSH
33048: LD_INT 2
33050: PUSH
33051: LD_INT 30
33053: PUSH
33054: LD_INT 2
33056: PUSH
33057: EMPTY
33058: LIST
33059: LIST
33060: PUSH
33061: LD_INT 30
33063: PUSH
33064: LD_INT 3
33066: PUSH
33067: EMPTY
33068: LIST
33069: LIST
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: LIST
33075: PPUSH
33076: CALL_OW 72
33080: NOT
33081: AND
33082: IFFALSE 33187
// begin for j = 1 to mc_build_list [ i ] do
33084: LD_ADDR_VAR 0 3
33088: PUSH
33089: DOUBLE
33090: LD_INT 1
33092: DEC
33093: ST_TO_ADDR
33094: LD_EXP 83
33098: PUSH
33099: LD_VAR 0 2
33103: ARRAY
33104: PUSH
33105: FOR_TO
33106: IFFALSE 33185
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33108: LD_EXP 83
33112: PUSH
33113: LD_VAR 0 2
33117: ARRAY
33118: PUSH
33119: LD_VAR 0 3
33123: ARRAY
33124: PUSH
33125: LD_INT 1
33127: ARRAY
33128: PUSH
33129: LD_INT 2
33131: EQUAL
33132: IFFALSE 33183
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33134: LD_ADDR_EXP 83
33138: PUSH
33139: LD_EXP 83
33143: PPUSH
33144: LD_VAR 0 2
33148: PPUSH
33149: LD_EXP 83
33153: PUSH
33154: LD_VAR 0 2
33158: ARRAY
33159: PPUSH
33160: LD_VAR 0 3
33164: PPUSH
33165: LD_INT 1
33167: PPUSH
33168: LD_INT 0
33170: PPUSH
33171: CALL 57283 0 4
33175: PPUSH
33176: CALL_OW 1
33180: ST_TO_ADDR
// break ;
33181: GO 33185
// end ;
33183: GO 33105
33185: POP
33186: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33187: LD_ADDR_VAR 0 6
33191: PUSH
33192: LD_EXP 78
33196: PUSH
33197: LD_VAR 0 2
33201: ARRAY
33202: PPUSH
33203: LD_INT 2
33205: PUSH
33206: LD_INT 30
33208: PUSH
33209: LD_INT 0
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: LD_INT 30
33218: PUSH
33219: LD_INT 1
33221: PUSH
33222: EMPTY
33223: LIST
33224: LIST
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: LIST
33230: PPUSH
33231: CALL_OW 72
33235: ST_TO_ADDR
// for k := 1 to depot do
33236: LD_ADDR_VAR 0 4
33240: PUSH
33241: DOUBLE
33242: LD_INT 1
33244: DEC
33245: ST_TO_ADDR
33246: LD_VAR 0 6
33250: PUSH
33251: FOR_TO
33252: IFFALSE 33822
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
33254: LD_EXP 83
33258: PUSH
33259: LD_VAR 0 2
33263: ARRAY
33264: PUSH
33265: LD_INT 1
33267: ARRAY
33268: PUSH
33269: LD_INT 1
33271: ARRAY
33272: PUSH
33273: LD_INT 0
33275: EQUAL
33276: PUSH
33277: LD_VAR 0 6
33281: PUSH
33282: LD_VAR 0 4
33286: ARRAY
33287: PPUSH
33288: LD_EXP 83
33292: PUSH
33293: LD_VAR 0 2
33297: ARRAY
33298: PUSH
33299: LD_INT 1
33301: ARRAY
33302: PUSH
33303: LD_INT 1
33305: ARRAY
33306: PPUSH
33307: LD_EXP 83
33311: PUSH
33312: LD_VAR 0 2
33316: ARRAY
33317: PUSH
33318: LD_INT 1
33320: ARRAY
33321: PUSH
33322: LD_INT 2
33324: ARRAY
33325: PPUSH
33326: LD_EXP 83
33330: PUSH
33331: LD_VAR 0 2
33335: ARRAY
33336: PUSH
33337: LD_INT 1
33339: ARRAY
33340: PUSH
33341: LD_INT 3
33343: ARRAY
33344: PPUSH
33345: LD_EXP 83
33349: PUSH
33350: LD_VAR 0 2
33354: ARRAY
33355: PUSH
33356: LD_INT 1
33358: ARRAY
33359: PUSH
33360: LD_INT 4
33362: ARRAY
33363: PPUSH
33364: CALL 66339 0 5
33368: OR
33369: IFFALSE 33650
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33371: LD_ADDR_VAR 0 5
33375: PUSH
33376: LD_EXP 78
33380: PUSH
33381: LD_VAR 0 2
33385: ARRAY
33386: PPUSH
33387: LD_INT 25
33389: PUSH
33390: LD_INT 2
33392: PUSH
33393: EMPTY
33394: LIST
33395: LIST
33396: PPUSH
33397: CALL_OW 72
33401: PUSH
33402: LD_EXP 80
33406: PUSH
33407: LD_VAR 0 2
33411: ARRAY
33412: DIFF
33413: ST_TO_ADDR
// if not tmp then
33414: LD_VAR 0 5
33418: NOT
33419: IFFALSE 33423
// continue ;
33421: GO 33251
// for j in tmp do
33423: LD_ADDR_VAR 0 3
33427: PUSH
33428: LD_VAR 0 5
33432: PUSH
33433: FOR_IN
33434: IFFALSE 33646
// begin if not mc_builders [ i ] then
33436: LD_EXP 84
33440: PUSH
33441: LD_VAR 0 2
33445: ARRAY
33446: NOT
33447: IFFALSE 33505
// begin SetTag ( j , 103 ) ;
33449: LD_VAR 0 3
33453: PPUSH
33454: LD_INT 103
33456: PPUSH
33457: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33461: LD_ADDR_EXP 84
33465: PUSH
33466: LD_EXP 84
33470: PPUSH
33471: LD_VAR 0 2
33475: PUSH
33476: LD_EXP 84
33480: PUSH
33481: LD_VAR 0 2
33485: ARRAY
33486: PUSH
33487: LD_INT 1
33489: PLUS
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PPUSH
33495: LD_VAR 0 3
33499: PPUSH
33500: CALL 57865 0 3
33504: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33505: LD_VAR 0 3
33509: PPUSH
33510: CALL_OW 310
33514: IFFALSE 33525
// ComExitBuilding ( j ) ;
33516: LD_VAR 0 3
33520: PPUSH
33521: CALL_OW 122
// wait ( 3 ) ;
33525: LD_INT 3
33527: PPUSH
33528: CALL_OW 67
// if not mc_build_list [ i ] then
33532: LD_EXP 83
33536: PUSH
33537: LD_VAR 0 2
33541: ARRAY
33542: NOT
33543: IFFALSE 33547
// break ;
33545: GO 33646
// if not HasTask ( j ) then
33547: LD_VAR 0 3
33551: PPUSH
33552: CALL_OW 314
33556: NOT
33557: IFFALSE 33644
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
33559: LD_VAR 0 3
33563: PPUSH
33564: LD_EXP 83
33568: PUSH
33569: LD_VAR 0 2
33573: ARRAY
33574: PUSH
33575: LD_INT 1
33577: ARRAY
33578: PUSH
33579: LD_INT 1
33581: ARRAY
33582: PPUSH
33583: LD_EXP 83
33587: PUSH
33588: LD_VAR 0 2
33592: ARRAY
33593: PUSH
33594: LD_INT 1
33596: ARRAY
33597: PUSH
33598: LD_INT 2
33600: ARRAY
33601: PPUSH
33602: LD_EXP 83
33606: PUSH
33607: LD_VAR 0 2
33611: ARRAY
33612: PUSH
33613: LD_INT 1
33615: ARRAY
33616: PUSH
33617: LD_INT 3
33619: ARRAY
33620: PPUSH
33621: LD_EXP 83
33625: PUSH
33626: LD_VAR 0 2
33630: ARRAY
33631: PUSH
33632: LD_INT 1
33634: ARRAY
33635: PUSH
33636: LD_INT 4
33638: ARRAY
33639: PPUSH
33640: CALL_OW 145
// end ;
33644: GO 33433
33646: POP
33647: POP
// end else
33648: GO 33820
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
33650: LD_EXP 78
33654: PUSH
33655: LD_VAR 0 2
33659: ARRAY
33660: PPUSH
33661: LD_EXP 83
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: PUSH
33672: LD_INT 1
33674: ARRAY
33675: PUSH
33676: LD_INT 1
33678: ARRAY
33679: PPUSH
33680: LD_EXP 83
33684: PUSH
33685: LD_VAR 0 2
33689: ARRAY
33690: PUSH
33691: LD_INT 1
33693: ARRAY
33694: PUSH
33695: LD_INT 2
33697: ARRAY
33698: PPUSH
33699: LD_EXP 83
33703: PUSH
33704: LD_VAR 0 2
33708: ARRAY
33709: PUSH
33710: LD_INT 1
33712: ARRAY
33713: PUSH
33714: LD_INT 3
33716: ARRAY
33717: PPUSH
33718: LD_EXP 83
33722: PUSH
33723: LD_VAR 0 2
33727: ARRAY
33728: PUSH
33729: LD_INT 1
33731: ARRAY
33732: PUSH
33733: LD_INT 4
33735: ARRAY
33736: PPUSH
33737: LD_EXP 78
33741: PUSH
33742: LD_VAR 0 2
33746: ARRAY
33747: PPUSH
33748: LD_INT 21
33750: PUSH
33751: LD_INT 3
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PPUSH
33758: CALL_OW 72
33762: PPUSH
33763: EMPTY
33764: PPUSH
33765: CALL 65093 0 7
33769: NOT
33770: IFFALSE 33820
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
33772: LD_ADDR_EXP 83
33776: PUSH
33777: LD_EXP 83
33781: PPUSH
33782: LD_VAR 0 2
33786: PPUSH
33787: LD_EXP 83
33791: PUSH
33792: LD_VAR 0 2
33796: ARRAY
33797: PPUSH
33798: LD_INT 1
33800: PPUSH
33801: LD_INT 1
33803: NEG
33804: PPUSH
33805: LD_INT 0
33807: PPUSH
33808: CALL 57283 0 4
33812: PPUSH
33813: CALL_OW 1
33817: ST_TO_ADDR
// continue ;
33818: GO 33251
// end ; end ;
33820: GO 33251
33822: POP
33823: POP
// end ; end ;
33824: GO 32680
33826: POP
33827: POP
// end ;
33828: LD_VAR 0 1
33832: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
33833: LD_INT 0
33835: PPUSH
33836: PPUSH
33837: PPUSH
33838: PPUSH
33839: PPUSH
33840: PPUSH
// if not mc_bases then
33841: LD_EXP 78
33845: NOT
33846: IFFALSE 33850
// exit ;
33848: GO 34277
// for i = 1 to mc_bases do
33850: LD_ADDR_VAR 0 2
33854: PUSH
33855: DOUBLE
33856: LD_INT 1
33858: DEC
33859: ST_TO_ADDR
33860: LD_EXP 78
33864: PUSH
33865: FOR_TO
33866: IFFALSE 34275
// begin tmp := mc_build_upgrade [ i ] ;
33868: LD_ADDR_VAR 0 4
33872: PUSH
33873: LD_EXP 110
33877: PUSH
33878: LD_VAR 0 2
33882: ARRAY
33883: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33884: LD_ADDR_VAR 0 6
33888: PUSH
33889: LD_EXP 111
33893: PUSH
33894: LD_VAR 0 2
33898: ARRAY
33899: PPUSH
33900: LD_INT 2
33902: PUSH
33903: LD_INT 30
33905: PUSH
33906: LD_INT 6
33908: PUSH
33909: EMPTY
33910: LIST
33911: LIST
33912: PUSH
33913: LD_INT 30
33915: PUSH
33916: LD_INT 7
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: LIST
33927: PPUSH
33928: CALL_OW 72
33932: ST_TO_ADDR
// if not tmp and not lab then
33933: LD_VAR 0 4
33937: NOT
33938: PUSH
33939: LD_VAR 0 6
33943: NOT
33944: AND
33945: IFFALSE 33949
// continue ;
33947: GO 33865
// if tmp then
33949: LD_VAR 0 4
33953: IFFALSE 34073
// for j in tmp do
33955: LD_ADDR_VAR 0 3
33959: PUSH
33960: LD_VAR 0 4
33964: PUSH
33965: FOR_IN
33966: IFFALSE 34071
// begin if UpgradeCost ( j ) then
33968: LD_VAR 0 3
33972: PPUSH
33973: CALL 64753 0 1
33977: IFFALSE 34069
// begin ComUpgrade ( j ) ;
33979: LD_VAR 0 3
33983: PPUSH
33984: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33988: LD_ADDR_EXP 110
33992: PUSH
33993: LD_EXP 110
33997: PPUSH
33998: LD_VAR 0 2
34002: PPUSH
34003: LD_EXP 110
34007: PUSH
34008: LD_VAR 0 2
34012: ARRAY
34013: PUSH
34014: LD_VAR 0 3
34018: DIFF
34019: PPUSH
34020: CALL_OW 1
34024: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34025: LD_ADDR_EXP 85
34029: PUSH
34030: LD_EXP 85
34034: PPUSH
34035: LD_VAR 0 2
34039: PUSH
34040: LD_EXP 85
34044: PUSH
34045: LD_VAR 0 2
34049: ARRAY
34050: PUSH
34051: LD_INT 1
34053: PLUS
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PPUSH
34059: LD_VAR 0 3
34063: PPUSH
34064: CALL 57865 0 3
34068: ST_TO_ADDR
// end ; end ;
34069: GO 33965
34071: POP
34072: POP
// if not lab or not mc_lab_upgrade [ i ] then
34073: LD_VAR 0 6
34077: NOT
34078: PUSH
34079: LD_EXP 112
34083: PUSH
34084: LD_VAR 0 2
34088: ARRAY
34089: NOT
34090: OR
34091: IFFALSE 34095
// continue ;
34093: GO 33865
// for j in lab do
34095: LD_ADDR_VAR 0 3
34099: PUSH
34100: LD_VAR 0 6
34104: PUSH
34105: FOR_IN
34106: IFFALSE 34271
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34108: LD_VAR 0 3
34112: PPUSH
34113: CALL_OW 266
34117: PUSH
34118: LD_INT 6
34120: PUSH
34121: LD_INT 7
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: IN
34128: PUSH
34129: LD_VAR 0 3
34133: PPUSH
34134: CALL_OW 461
34138: PUSH
34139: LD_INT 1
34141: NONEQUAL
34142: AND
34143: IFFALSE 34269
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34145: LD_VAR 0 3
34149: PPUSH
34150: LD_EXP 112
34154: PUSH
34155: LD_VAR 0 2
34159: ARRAY
34160: PUSH
34161: LD_INT 1
34163: ARRAY
34164: PPUSH
34165: CALL 64958 0 2
34169: IFFALSE 34269
// begin ComCancel ( j ) ;
34171: LD_VAR 0 3
34175: PPUSH
34176: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
34180: LD_VAR 0 3
34184: PPUSH
34185: LD_EXP 112
34189: PUSH
34190: LD_VAR 0 2
34194: ARRAY
34195: PUSH
34196: LD_INT 1
34198: ARRAY
34199: PPUSH
34200: CALL_OW 207
// if not j in mc_construct_list [ i ] then
34204: LD_VAR 0 3
34208: PUSH
34209: LD_EXP 85
34213: PUSH
34214: LD_VAR 0 2
34218: ARRAY
34219: IN
34220: NOT
34221: IFFALSE 34267
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34223: LD_ADDR_EXP 85
34227: PUSH
34228: LD_EXP 85
34232: PPUSH
34233: LD_VAR 0 2
34237: PUSH
34238: LD_EXP 85
34242: PUSH
34243: LD_VAR 0 2
34247: ARRAY
34248: PUSH
34249: LD_INT 1
34251: PLUS
34252: PUSH
34253: EMPTY
34254: LIST
34255: LIST
34256: PPUSH
34257: LD_VAR 0 3
34261: PPUSH
34262: CALL 57865 0 3
34266: ST_TO_ADDR
// break ;
34267: GO 34271
// end ; end ; end ;
34269: GO 34105
34271: POP
34272: POP
// end ;
34273: GO 33865
34275: POP
34276: POP
// end ;
34277: LD_VAR 0 1
34281: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
34282: LD_INT 0
34284: PPUSH
34285: PPUSH
34286: PPUSH
34287: PPUSH
34288: PPUSH
34289: PPUSH
34290: PPUSH
34291: PPUSH
34292: PPUSH
// if not mc_bases then
34293: LD_EXP 78
34297: NOT
34298: IFFALSE 34302
// exit ;
34300: GO 34707
// for i = 1 to mc_bases do
34302: LD_ADDR_VAR 0 2
34306: PUSH
34307: DOUBLE
34308: LD_INT 1
34310: DEC
34311: ST_TO_ADDR
34312: LD_EXP 78
34316: PUSH
34317: FOR_TO
34318: IFFALSE 34705
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
34320: LD_EXP 86
34324: PUSH
34325: LD_VAR 0 2
34329: ARRAY
34330: NOT
34331: PUSH
34332: LD_EXP 78
34336: PUSH
34337: LD_VAR 0 2
34341: ARRAY
34342: PPUSH
34343: LD_INT 30
34345: PUSH
34346: LD_INT 3
34348: PUSH
34349: EMPTY
34350: LIST
34351: LIST
34352: PPUSH
34353: CALL_OW 72
34357: NOT
34358: OR
34359: IFFALSE 34363
// continue ;
34361: GO 34317
// busy := false ;
34363: LD_ADDR_VAR 0 8
34367: PUSH
34368: LD_INT 0
34370: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34371: LD_ADDR_VAR 0 4
34375: PUSH
34376: LD_EXP 78
34380: PUSH
34381: LD_VAR 0 2
34385: ARRAY
34386: PPUSH
34387: LD_INT 30
34389: PUSH
34390: LD_INT 3
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PPUSH
34397: CALL_OW 72
34401: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
34402: LD_ADDR_VAR 0 6
34406: PUSH
34407: LD_EXP 86
34411: PUSH
34412: LD_VAR 0 2
34416: ARRAY
34417: PPUSH
34418: LD_INT 2
34420: PUSH
34421: LD_INT 30
34423: PUSH
34424: LD_INT 32
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 30
34433: PUSH
34434: LD_INT 33
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: LIST
34445: PPUSH
34446: CALL_OW 72
34450: ST_TO_ADDR
// if not t then
34451: LD_VAR 0 6
34455: NOT
34456: IFFALSE 34460
// continue ;
34458: GO 34317
// for j in tmp do
34460: LD_ADDR_VAR 0 3
34464: PUSH
34465: LD_VAR 0 4
34469: PUSH
34470: FOR_IN
34471: IFFALSE 34501
// if not BuildingStatus ( j ) = bs_idle then
34473: LD_VAR 0 3
34477: PPUSH
34478: CALL_OW 461
34482: PUSH
34483: LD_INT 2
34485: EQUAL
34486: NOT
34487: IFFALSE 34499
// begin busy := true ;
34489: LD_ADDR_VAR 0 8
34493: PUSH
34494: LD_INT 1
34496: ST_TO_ADDR
// break ;
34497: GO 34501
// end ;
34499: GO 34470
34501: POP
34502: POP
// if busy then
34503: LD_VAR 0 8
34507: IFFALSE 34511
// continue ;
34509: GO 34317
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
34511: LD_ADDR_VAR 0 7
34515: PUSH
34516: LD_VAR 0 6
34520: PPUSH
34521: LD_INT 35
34523: PUSH
34524: LD_INT 0
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PPUSH
34531: CALL_OW 72
34535: ST_TO_ADDR
// if tw then
34536: LD_VAR 0 7
34540: IFFALSE 34617
// begin tw := tw [ 1 ] ;
34542: LD_ADDR_VAR 0 7
34546: PUSH
34547: LD_VAR 0 7
34551: PUSH
34552: LD_INT 1
34554: ARRAY
34555: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
34556: LD_ADDR_VAR 0 9
34560: PUSH
34561: LD_VAR 0 7
34565: PPUSH
34566: LD_EXP 103
34570: PUSH
34571: LD_VAR 0 2
34575: ARRAY
34576: PPUSH
34577: CALL 63250 0 2
34581: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
34582: LD_EXP 117
34586: PUSH
34587: LD_VAR 0 2
34591: ARRAY
34592: IFFALSE 34615
// if not weapon in mc_allowed_tower_weapons [ i ] then
34594: LD_VAR 0 9
34598: PUSH
34599: LD_EXP 117
34603: PUSH
34604: LD_VAR 0 2
34608: ARRAY
34609: IN
34610: NOT
34611: IFFALSE 34615
// continue ;
34613: GO 34317
// end else
34615: GO 34680
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
34617: LD_ADDR_VAR 0 5
34621: PUSH
34622: LD_EXP 86
34626: PUSH
34627: LD_VAR 0 2
34631: ARRAY
34632: PPUSH
34633: LD_VAR 0 4
34637: PPUSH
34638: CALL 90153 0 2
34642: ST_TO_ADDR
// if not tmp2 then
34643: LD_VAR 0 5
34647: NOT
34648: IFFALSE 34652
// continue ;
34650: GO 34317
// tw := tmp2 [ 1 ] ;
34652: LD_ADDR_VAR 0 7
34656: PUSH
34657: LD_VAR 0 5
34661: PUSH
34662: LD_INT 1
34664: ARRAY
34665: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
34666: LD_ADDR_VAR 0 9
34670: PUSH
34671: LD_VAR 0 5
34675: PUSH
34676: LD_INT 2
34678: ARRAY
34679: ST_TO_ADDR
// end ; if not weapon then
34680: LD_VAR 0 9
34684: NOT
34685: IFFALSE 34689
// continue ;
34687: GO 34317
// ComPlaceWeapon ( tw , weapon ) ;
34689: LD_VAR 0 7
34693: PPUSH
34694: LD_VAR 0 9
34698: PPUSH
34699: CALL_OW 148
// end ;
34703: GO 34317
34705: POP
34706: POP
// end ;
34707: LD_VAR 0 1
34711: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
34712: LD_INT 0
34714: PPUSH
34715: PPUSH
34716: PPUSH
34717: PPUSH
34718: PPUSH
34719: PPUSH
34720: PPUSH
// if not mc_bases then
34721: LD_EXP 78
34725: NOT
34726: IFFALSE 34730
// exit ;
34728: GO 35505
// for i = 1 to mc_bases do
34730: LD_ADDR_VAR 0 2
34734: PUSH
34735: DOUBLE
34736: LD_INT 1
34738: DEC
34739: ST_TO_ADDR
34740: LD_EXP 78
34744: PUSH
34745: FOR_TO
34746: IFFALSE 35503
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
34748: LD_EXP 91
34752: PUSH
34753: LD_VAR 0 2
34757: ARRAY
34758: NOT
34759: PUSH
34760: LD_EXP 91
34764: PUSH
34765: LD_VAR 0 2
34769: ARRAY
34770: PUSH
34771: LD_EXP 92
34775: PUSH
34776: LD_VAR 0 2
34780: ARRAY
34781: EQUAL
34782: OR
34783: PUSH
34784: LD_EXP 101
34788: PUSH
34789: LD_VAR 0 2
34793: ARRAY
34794: OR
34795: IFFALSE 34799
// continue ;
34797: GO 34745
// if mc_miners [ i ] then
34799: LD_EXP 92
34803: PUSH
34804: LD_VAR 0 2
34808: ARRAY
34809: IFFALSE 35190
// begin for j = mc_miners [ i ] downto 1 do
34811: LD_ADDR_VAR 0 3
34815: PUSH
34816: DOUBLE
34817: LD_EXP 92
34821: PUSH
34822: LD_VAR 0 2
34826: ARRAY
34827: INC
34828: ST_TO_ADDR
34829: LD_INT 1
34831: PUSH
34832: FOR_DOWNTO
34833: IFFALSE 35188
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
34835: LD_EXP 92
34839: PUSH
34840: LD_VAR 0 2
34844: ARRAY
34845: PUSH
34846: LD_VAR 0 3
34850: ARRAY
34851: PPUSH
34852: CALL_OW 301
34856: PUSH
34857: LD_EXP 92
34861: PUSH
34862: LD_VAR 0 2
34866: ARRAY
34867: PUSH
34868: LD_VAR 0 3
34872: ARRAY
34873: PPUSH
34874: CALL_OW 257
34878: PUSH
34879: LD_INT 1
34881: NONEQUAL
34882: OR
34883: IFFALSE 34946
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34885: LD_ADDR_VAR 0 5
34889: PUSH
34890: LD_EXP 92
34894: PUSH
34895: LD_VAR 0 2
34899: ARRAY
34900: PUSH
34901: LD_EXP 92
34905: PUSH
34906: LD_VAR 0 2
34910: ARRAY
34911: PUSH
34912: LD_VAR 0 3
34916: ARRAY
34917: DIFF
34918: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34919: LD_ADDR_EXP 92
34923: PUSH
34924: LD_EXP 92
34928: PPUSH
34929: LD_VAR 0 2
34933: PPUSH
34934: LD_VAR 0 5
34938: PPUSH
34939: CALL_OW 1
34943: ST_TO_ADDR
// continue ;
34944: GO 34832
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34946: LD_EXP 92
34950: PUSH
34951: LD_VAR 0 2
34955: ARRAY
34956: PUSH
34957: LD_VAR 0 3
34961: ARRAY
34962: PPUSH
34963: CALL_OW 257
34967: PUSH
34968: LD_INT 1
34970: EQUAL
34971: PUSH
34972: LD_EXP 92
34976: PUSH
34977: LD_VAR 0 2
34981: ARRAY
34982: PUSH
34983: LD_VAR 0 3
34987: ARRAY
34988: PPUSH
34989: CALL_OW 459
34993: NOT
34994: AND
34995: PUSH
34996: LD_EXP 92
35000: PUSH
35001: LD_VAR 0 2
35005: ARRAY
35006: PUSH
35007: LD_VAR 0 3
35011: ARRAY
35012: PPUSH
35013: CALL_OW 314
35017: NOT
35018: AND
35019: IFFALSE 35186
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
35021: LD_EXP 92
35025: PUSH
35026: LD_VAR 0 2
35030: ARRAY
35031: PUSH
35032: LD_VAR 0 3
35036: ARRAY
35037: PPUSH
35038: CALL_OW 310
35042: IFFALSE 35065
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
35044: LD_EXP 92
35048: PUSH
35049: LD_VAR 0 2
35053: ARRAY
35054: PUSH
35055: LD_VAR 0 3
35059: ARRAY
35060: PPUSH
35061: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
35065: LD_EXP 92
35069: PUSH
35070: LD_VAR 0 2
35074: ARRAY
35075: PUSH
35076: LD_VAR 0 3
35080: ARRAY
35081: PPUSH
35082: CALL_OW 314
35086: NOT
35087: IFFALSE 35186
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
35089: LD_ADDR_VAR 0 7
35093: PUSH
35094: LD_VAR 0 3
35098: PUSH
35099: LD_EXP 91
35103: PUSH
35104: LD_VAR 0 2
35108: ARRAY
35109: PPUSH
35110: CALL 55005 0 1
35114: MOD
35115: PUSH
35116: LD_INT 1
35118: PLUS
35119: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35120: LD_EXP 92
35124: PUSH
35125: LD_VAR 0 2
35129: ARRAY
35130: PUSH
35131: LD_VAR 0 3
35135: ARRAY
35136: PPUSH
35137: LD_EXP 91
35141: PUSH
35142: LD_VAR 0 2
35146: ARRAY
35147: PUSH
35148: LD_VAR 0 7
35152: ARRAY
35153: PUSH
35154: LD_INT 1
35156: ARRAY
35157: PPUSH
35158: LD_EXP 91
35162: PUSH
35163: LD_VAR 0 2
35167: ARRAY
35168: PUSH
35169: LD_VAR 0 7
35173: ARRAY
35174: PUSH
35175: LD_INT 2
35177: ARRAY
35178: PPUSH
35179: LD_INT 0
35181: PPUSH
35182: CALL_OW 193
// end ; end ; end ;
35186: GO 34832
35188: POP
35189: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
35190: LD_ADDR_VAR 0 5
35194: PUSH
35195: LD_EXP 78
35199: PUSH
35200: LD_VAR 0 2
35204: ARRAY
35205: PPUSH
35206: LD_INT 2
35208: PUSH
35209: LD_INT 30
35211: PUSH
35212: LD_INT 4
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 30
35221: PUSH
35222: LD_INT 5
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 30
35231: PUSH
35232: LD_INT 32
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: LIST
35243: LIST
35244: PPUSH
35245: CALL_OW 72
35249: ST_TO_ADDR
// if not tmp then
35250: LD_VAR 0 5
35254: NOT
35255: IFFALSE 35259
// continue ;
35257: GO 34745
// list := [ ] ;
35259: LD_ADDR_VAR 0 6
35263: PUSH
35264: EMPTY
35265: ST_TO_ADDR
// for j in tmp do
35266: LD_ADDR_VAR 0 3
35270: PUSH
35271: LD_VAR 0 5
35275: PUSH
35276: FOR_IN
35277: IFFALSE 35346
// begin for k in UnitsInside ( j ) do
35279: LD_ADDR_VAR 0 4
35283: PUSH
35284: LD_VAR 0 3
35288: PPUSH
35289: CALL_OW 313
35293: PUSH
35294: FOR_IN
35295: IFFALSE 35342
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
35297: LD_VAR 0 4
35301: PPUSH
35302: CALL_OW 257
35306: PUSH
35307: LD_INT 1
35309: EQUAL
35310: PUSH
35311: LD_VAR 0 4
35315: PPUSH
35316: CALL_OW 459
35320: NOT
35321: AND
35322: IFFALSE 35340
// list := list ^ k ;
35324: LD_ADDR_VAR 0 6
35328: PUSH
35329: LD_VAR 0 6
35333: PUSH
35334: LD_VAR 0 4
35338: ADD
35339: ST_TO_ADDR
35340: GO 35294
35342: POP
35343: POP
// end ;
35344: GO 35276
35346: POP
35347: POP
// list := list diff mc_miners [ i ] ;
35348: LD_ADDR_VAR 0 6
35352: PUSH
35353: LD_VAR 0 6
35357: PUSH
35358: LD_EXP 92
35362: PUSH
35363: LD_VAR 0 2
35367: ARRAY
35368: DIFF
35369: ST_TO_ADDR
// if not list then
35370: LD_VAR 0 6
35374: NOT
35375: IFFALSE 35379
// continue ;
35377: GO 34745
// k := mc_mines [ i ] - mc_miners [ i ] ;
35379: LD_ADDR_VAR 0 4
35383: PUSH
35384: LD_EXP 91
35388: PUSH
35389: LD_VAR 0 2
35393: ARRAY
35394: PUSH
35395: LD_EXP 92
35399: PUSH
35400: LD_VAR 0 2
35404: ARRAY
35405: MINUS
35406: ST_TO_ADDR
// if k > list then
35407: LD_VAR 0 4
35411: PUSH
35412: LD_VAR 0 6
35416: GREATER
35417: IFFALSE 35429
// k := list ;
35419: LD_ADDR_VAR 0 4
35423: PUSH
35424: LD_VAR 0 6
35428: ST_TO_ADDR
// for j = 1 to k do
35429: LD_ADDR_VAR 0 3
35433: PUSH
35434: DOUBLE
35435: LD_INT 1
35437: DEC
35438: ST_TO_ADDR
35439: LD_VAR 0 4
35443: PUSH
35444: FOR_TO
35445: IFFALSE 35499
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
35447: LD_ADDR_EXP 92
35451: PUSH
35452: LD_EXP 92
35456: PPUSH
35457: LD_VAR 0 2
35461: PUSH
35462: LD_EXP 92
35466: PUSH
35467: LD_VAR 0 2
35471: ARRAY
35472: PUSH
35473: LD_INT 1
35475: PLUS
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PPUSH
35481: LD_VAR 0 6
35485: PUSH
35486: LD_VAR 0 3
35490: ARRAY
35491: PPUSH
35492: CALL 57865 0 3
35496: ST_TO_ADDR
35497: GO 35444
35499: POP
35500: POP
// end ;
35501: GO 34745
35503: POP
35504: POP
// end ;
35505: LD_VAR 0 1
35509: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
35510: LD_INT 0
35512: PPUSH
35513: PPUSH
35514: PPUSH
35515: PPUSH
35516: PPUSH
35517: PPUSH
35518: PPUSH
35519: PPUSH
35520: PPUSH
35521: PPUSH
35522: PPUSH
// if not mc_bases then
35523: LD_EXP 78
35527: NOT
35528: IFFALSE 35532
// exit ;
35530: GO 37355
// for i = 1 to mc_bases do
35532: LD_ADDR_VAR 0 2
35536: PUSH
35537: DOUBLE
35538: LD_INT 1
35540: DEC
35541: ST_TO_ADDR
35542: LD_EXP 78
35546: PUSH
35547: FOR_TO
35548: IFFALSE 37353
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
35550: LD_EXP 78
35554: PUSH
35555: LD_VAR 0 2
35559: ARRAY
35560: NOT
35561: PUSH
35562: LD_EXP 85
35566: PUSH
35567: LD_VAR 0 2
35571: ARRAY
35572: OR
35573: IFFALSE 35577
// continue ;
35575: GO 35547
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
35577: LD_EXP 94
35581: PUSH
35582: LD_VAR 0 2
35586: ARRAY
35587: NOT
35588: PUSH
35589: LD_EXP 95
35593: PUSH
35594: LD_VAR 0 2
35598: ARRAY
35599: AND
35600: IFFALSE 35638
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
35602: LD_ADDR_EXP 95
35606: PUSH
35607: LD_EXP 95
35611: PPUSH
35612: LD_VAR 0 2
35616: PPUSH
35617: EMPTY
35618: PPUSH
35619: CALL_OW 1
35623: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
35624: LD_VAR 0 2
35628: PPUSH
35629: LD_INT 107
35631: PPUSH
35632: CALL 26364 0 2
// continue ;
35636: GO 35547
// end ; target := [ ] ;
35638: LD_ADDR_VAR 0 7
35642: PUSH
35643: EMPTY
35644: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35645: LD_ADDR_VAR 0 6
35649: PUSH
35650: LD_EXP 78
35654: PUSH
35655: LD_VAR 0 2
35659: ARRAY
35660: PUSH
35661: LD_INT 1
35663: ARRAY
35664: PPUSH
35665: CALL_OW 255
35669: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35670: LD_ADDR_VAR 0 9
35674: PUSH
35675: LD_EXP 78
35679: PUSH
35680: LD_VAR 0 2
35684: ARRAY
35685: PPUSH
35686: LD_INT 2
35688: PUSH
35689: LD_INT 30
35691: PUSH
35692: LD_INT 0
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 30
35701: PUSH
35702: LD_INT 1
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: LIST
35713: PPUSH
35714: CALL_OW 72
35718: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
35719: LD_ADDR_VAR 0 3
35723: PUSH
35724: DOUBLE
35725: LD_EXP 94
35729: PUSH
35730: LD_VAR 0 2
35734: ARRAY
35735: INC
35736: ST_TO_ADDR
35737: LD_INT 1
35739: PUSH
35740: FOR_DOWNTO
35741: IFFALSE 35986
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
35743: LD_EXP 94
35747: PUSH
35748: LD_VAR 0 2
35752: ARRAY
35753: PUSH
35754: LD_VAR 0 3
35758: ARRAY
35759: PUSH
35760: LD_INT 2
35762: ARRAY
35763: PPUSH
35764: LD_EXP 94
35768: PUSH
35769: LD_VAR 0 2
35773: ARRAY
35774: PUSH
35775: LD_VAR 0 3
35779: ARRAY
35780: PUSH
35781: LD_INT 3
35783: ARRAY
35784: PPUSH
35785: CALL_OW 488
35789: PUSH
35790: LD_EXP 94
35794: PUSH
35795: LD_VAR 0 2
35799: ARRAY
35800: PUSH
35801: LD_VAR 0 3
35805: ARRAY
35806: PUSH
35807: LD_INT 2
35809: ARRAY
35810: PPUSH
35811: LD_EXP 94
35815: PUSH
35816: LD_VAR 0 2
35820: ARRAY
35821: PUSH
35822: LD_VAR 0 3
35826: ARRAY
35827: PUSH
35828: LD_INT 3
35830: ARRAY
35831: PPUSH
35832: CALL_OW 284
35836: PUSH
35837: LD_INT 0
35839: EQUAL
35840: AND
35841: IFFALSE 35896
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
35843: LD_ADDR_VAR 0 5
35847: PUSH
35848: LD_EXP 94
35852: PUSH
35853: LD_VAR 0 2
35857: ARRAY
35858: PPUSH
35859: LD_VAR 0 3
35863: PPUSH
35864: CALL_OW 3
35868: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35869: LD_ADDR_EXP 94
35873: PUSH
35874: LD_EXP 94
35878: PPUSH
35879: LD_VAR 0 2
35883: PPUSH
35884: LD_VAR 0 5
35888: PPUSH
35889: CALL_OW 1
35893: ST_TO_ADDR
// continue ;
35894: GO 35740
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35896: LD_VAR 0 6
35900: PPUSH
35901: LD_EXP 94
35905: PUSH
35906: LD_VAR 0 2
35910: ARRAY
35911: PUSH
35912: LD_VAR 0 3
35916: ARRAY
35917: PUSH
35918: LD_INT 2
35920: ARRAY
35921: PPUSH
35922: LD_EXP 94
35926: PUSH
35927: LD_VAR 0 2
35931: ARRAY
35932: PUSH
35933: LD_VAR 0 3
35937: ARRAY
35938: PUSH
35939: LD_INT 3
35941: ARRAY
35942: PPUSH
35943: LD_INT 30
35945: PPUSH
35946: CALL 59129 0 4
35950: PUSH
35951: LD_INT 4
35953: ARRAY
35954: PUSH
35955: LD_INT 0
35957: EQUAL
35958: IFFALSE 35984
// begin target := mc_crates [ i ] [ j ] ;
35960: LD_ADDR_VAR 0 7
35964: PUSH
35965: LD_EXP 94
35969: PUSH
35970: LD_VAR 0 2
35974: ARRAY
35975: PUSH
35976: LD_VAR 0 3
35980: ARRAY
35981: ST_TO_ADDR
// break ;
35982: GO 35986
// end ; end ;
35984: GO 35740
35986: POP
35987: POP
// if not target then
35988: LD_VAR 0 7
35992: NOT
35993: IFFALSE 35997
// continue ;
35995: GO 35547
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35997: LD_ADDR_VAR 0 8
36001: PUSH
36002: LD_EXP 97
36006: PUSH
36007: LD_VAR 0 2
36011: ARRAY
36012: PPUSH
36013: LD_INT 2
36015: PUSH
36016: LD_INT 3
36018: PUSH
36019: LD_INT 58
36021: PUSH
36022: EMPTY
36023: LIST
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 61
36031: PUSH
36032: EMPTY
36033: LIST
36034: PUSH
36035: LD_INT 33
36037: PUSH
36038: LD_INT 5
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: PUSH
36045: LD_INT 33
36047: PUSH
36048: LD_INT 3
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: LIST
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 2
36064: PUSH
36065: LD_INT 34
36067: PUSH
36068: LD_INT 32
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 34
36077: PUSH
36078: LD_INT 51
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 34
36087: PUSH
36088: LD_INT 12
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: LIST
36099: LIST
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: PPUSH
36105: CALL_OW 72
36109: ST_TO_ADDR
// if not cargo then
36110: LD_VAR 0 8
36114: NOT
36115: IFFALSE 36821
// begin if mc_crates_collector [ i ] < 5 then
36117: LD_EXP 95
36121: PUSH
36122: LD_VAR 0 2
36126: ARRAY
36127: PUSH
36128: LD_INT 5
36130: LESS
36131: IFFALSE 36497
// begin if mc_ape [ i ] then
36133: LD_EXP 107
36137: PUSH
36138: LD_VAR 0 2
36142: ARRAY
36143: IFFALSE 36190
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36145: LD_ADDR_VAR 0 5
36149: PUSH
36150: LD_EXP 107
36154: PUSH
36155: LD_VAR 0 2
36159: ARRAY
36160: PPUSH
36161: LD_INT 25
36163: PUSH
36164: LD_INT 16
36166: PUSH
36167: EMPTY
36168: LIST
36169: LIST
36170: PUSH
36171: LD_INT 24
36173: PUSH
36174: LD_INT 750
36176: PUSH
36177: EMPTY
36178: LIST
36179: LIST
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PPUSH
36185: CALL_OW 72
36189: ST_TO_ADDR
// if not tmp then
36190: LD_VAR 0 5
36194: NOT
36195: IFFALSE 36242
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
36197: LD_ADDR_VAR 0 5
36201: PUSH
36202: LD_EXP 78
36206: PUSH
36207: LD_VAR 0 2
36211: ARRAY
36212: PPUSH
36213: LD_INT 25
36215: PUSH
36216: LD_INT 2
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 24
36225: PUSH
36226: LD_INT 750
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PPUSH
36237: CALL_OW 72
36241: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
36242: LD_EXP 107
36246: PUSH
36247: LD_VAR 0 2
36251: ARRAY
36252: PUSH
36253: LD_EXP 78
36257: PUSH
36258: LD_VAR 0 2
36262: ARRAY
36263: PPUSH
36264: LD_INT 25
36266: PUSH
36267: LD_INT 2
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 24
36276: PUSH
36277: LD_INT 750
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: PPUSH
36288: CALL_OW 72
36292: AND
36293: PUSH
36294: LD_VAR 0 5
36298: PUSH
36299: LD_INT 5
36301: LESS
36302: AND
36303: IFFALSE 36385
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
36305: LD_ADDR_VAR 0 3
36309: PUSH
36310: LD_EXP 78
36314: PUSH
36315: LD_VAR 0 2
36319: ARRAY
36320: PPUSH
36321: LD_INT 25
36323: PUSH
36324: LD_INT 2
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 24
36333: PUSH
36334: LD_INT 750
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PPUSH
36345: CALL_OW 72
36349: PUSH
36350: FOR_IN
36351: IFFALSE 36383
// begin tmp := tmp union j ;
36353: LD_ADDR_VAR 0 5
36357: PUSH
36358: LD_VAR 0 5
36362: PUSH
36363: LD_VAR 0 3
36367: UNION
36368: ST_TO_ADDR
// if tmp >= 5 then
36369: LD_VAR 0 5
36373: PUSH
36374: LD_INT 5
36376: GREATEREQUAL
36377: IFFALSE 36381
// break ;
36379: GO 36383
// end ;
36381: GO 36350
36383: POP
36384: POP
// end ; if not tmp then
36385: LD_VAR 0 5
36389: NOT
36390: IFFALSE 36394
// continue ;
36392: GO 35547
// for j in tmp do
36394: LD_ADDR_VAR 0 3
36398: PUSH
36399: LD_VAR 0 5
36403: PUSH
36404: FOR_IN
36405: IFFALSE 36495
// if not GetTag ( j ) then
36407: LD_VAR 0 3
36411: PPUSH
36412: CALL_OW 110
36416: NOT
36417: IFFALSE 36493
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
36419: LD_ADDR_EXP 95
36423: PUSH
36424: LD_EXP 95
36428: PPUSH
36429: LD_VAR 0 2
36433: PUSH
36434: LD_EXP 95
36438: PUSH
36439: LD_VAR 0 2
36443: ARRAY
36444: PUSH
36445: LD_INT 1
36447: PLUS
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PPUSH
36453: LD_VAR 0 3
36457: PPUSH
36458: CALL 57865 0 3
36462: ST_TO_ADDR
// SetTag ( j , 107 ) ;
36463: LD_VAR 0 3
36467: PPUSH
36468: LD_INT 107
36470: PPUSH
36471: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
36475: LD_EXP 95
36479: PUSH
36480: LD_VAR 0 2
36484: ARRAY
36485: PUSH
36486: LD_INT 5
36488: GREATEREQUAL
36489: IFFALSE 36493
// break ;
36491: GO 36495
// end ;
36493: GO 36404
36495: POP
36496: POP
// end ; if mc_crates_collector [ i ] and target then
36497: LD_EXP 95
36501: PUSH
36502: LD_VAR 0 2
36506: ARRAY
36507: PUSH
36508: LD_VAR 0 7
36512: AND
36513: IFFALSE 36819
// begin if mc_crates_collector [ i ] < target [ 1 ] then
36515: LD_EXP 95
36519: PUSH
36520: LD_VAR 0 2
36524: ARRAY
36525: PUSH
36526: LD_VAR 0 7
36530: PUSH
36531: LD_INT 1
36533: ARRAY
36534: LESS
36535: IFFALSE 36555
// tmp := mc_crates_collector [ i ] else
36537: LD_ADDR_VAR 0 5
36541: PUSH
36542: LD_EXP 95
36546: PUSH
36547: LD_VAR 0 2
36551: ARRAY
36552: ST_TO_ADDR
36553: GO 36569
// tmp := target [ 1 ] ;
36555: LD_ADDR_VAR 0 5
36559: PUSH
36560: LD_VAR 0 7
36564: PUSH
36565: LD_INT 1
36567: ARRAY
36568: ST_TO_ADDR
// k := 0 ;
36569: LD_ADDR_VAR 0 4
36573: PUSH
36574: LD_INT 0
36576: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
36577: LD_ADDR_VAR 0 3
36581: PUSH
36582: LD_EXP 95
36586: PUSH
36587: LD_VAR 0 2
36591: ARRAY
36592: PUSH
36593: FOR_IN
36594: IFFALSE 36817
// begin k := k + 1 ;
36596: LD_ADDR_VAR 0 4
36600: PUSH
36601: LD_VAR 0 4
36605: PUSH
36606: LD_INT 1
36608: PLUS
36609: ST_TO_ADDR
// if k > tmp then
36610: LD_VAR 0 4
36614: PUSH
36615: LD_VAR 0 5
36619: GREATER
36620: IFFALSE 36624
// break ;
36622: GO 36817
// if not GetClass ( j ) in [ 2 , 16 ] then
36624: LD_VAR 0 3
36628: PPUSH
36629: CALL_OW 257
36633: PUSH
36634: LD_INT 2
36636: PUSH
36637: LD_INT 16
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: IN
36644: NOT
36645: IFFALSE 36698
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
36647: LD_ADDR_EXP 95
36651: PUSH
36652: LD_EXP 95
36656: PPUSH
36657: LD_VAR 0 2
36661: PPUSH
36662: LD_EXP 95
36666: PUSH
36667: LD_VAR 0 2
36671: ARRAY
36672: PUSH
36673: LD_VAR 0 3
36677: DIFF
36678: PPUSH
36679: CALL_OW 1
36683: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36684: LD_VAR 0 3
36688: PPUSH
36689: LD_INT 0
36691: PPUSH
36692: CALL_OW 109
// continue ;
36696: GO 36593
// end ; if IsInUnit ( j ) then
36698: LD_VAR 0 3
36702: PPUSH
36703: CALL_OW 310
36707: IFFALSE 36718
// ComExitBuilding ( j ) ;
36709: LD_VAR 0 3
36713: PPUSH
36714: CALL_OW 122
// wait ( 3 ) ;
36718: LD_INT 3
36720: PPUSH
36721: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
36725: LD_VAR 0 3
36729: PPUSH
36730: CALL_OW 314
36734: PUSH
36735: LD_VAR 0 6
36739: PPUSH
36740: LD_VAR 0 7
36744: PUSH
36745: LD_INT 2
36747: ARRAY
36748: PPUSH
36749: LD_VAR 0 7
36753: PUSH
36754: LD_INT 3
36756: ARRAY
36757: PPUSH
36758: LD_INT 30
36760: PPUSH
36761: CALL 59129 0 4
36765: PUSH
36766: LD_INT 4
36768: ARRAY
36769: AND
36770: IFFALSE 36788
// ComStandNearbyBuilding ( j , depot ) else
36772: LD_VAR 0 3
36776: PPUSH
36777: LD_VAR 0 9
36781: PPUSH
36782: CALL 54467 0 2
36786: GO 36815
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36788: LD_VAR 0 3
36792: PPUSH
36793: LD_VAR 0 7
36797: PUSH
36798: LD_INT 2
36800: ARRAY
36801: PPUSH
36802: LD_VAR 0 7
36806: PUSH
36807: LD_INT 3
36809: ARRAY
36810: PPUSH
36811: CALL_OW 117
// end ;
36815: GO 36593
36817: POP
36818: POP
// end ; end else
36819: GO 37351
// begin for j in cargo do
36821: LD_ADDR_VAR 0 3
36825: PUSH
36826: LD_VAR 0 8
36830: PUSH
36831: FOR_IN
36832: IFFALSE 37349
// begin if GetTag ( j ) <> 0 then
36834: LD_VAR 0 3
36838: PPUSH
36839: CALL_OW 110
36843: PUSH
36844: LD_INT 0
36846: NONEQUAL
36847: IFFALSE 36851
// continue ;
36849: GO 36831
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
36851: LD_VAR 0 3
36855: PPUSH
36856: CALL_OW 256
36860: PUSH
36861: LD_INT 1000
36863: LESS
36864: PUSH
36865: LD_VAR 0 3
36869: PPUSH
36870: LD_EXP 102
36874: PUSH
36875: LD_VAR 0 2
36879: ARRAY
36880: PPUSH
36881: CALL_OW 308
36885: NOT
36886: AND
36887: IFFALSE 36909
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36889: LD_VAR 0 3
36893: PPUSH
36894: LD_EXP 102
36898: PUSH
36899: LD_VAR 0 2
36903: ARRAY
36904: PPUSH
36905: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36909: LD_VAR 0 3
36913: PPUSH
36914: CALL_OW 256
36918: PUSH
36919: LD_INT 1000
36921: LESS
36922: PUSH
36923: LD_VAR 0 3
36927: PPUSH
36928: LD_EXP 102
36932: PUSH
36933: LD_VAR 0 2
36937: ARRAY
36938: PPUSH
36939: CALL_OW 308
36943: AND
36944: IFFALSE 36948
// continue ;
36946: GO 36831
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36948: LD_VAR 0 3
36952: PPUSH
36953: CALL_OW 262
36957: PUSH
36958: LD_INT 2
36960: EQUAL
36961: PUSH
36962: LD_VAR 0 3
36966: PPUSH
36967: CALL_OW 261
36971: PUSH
36972: LD_INT 15
36974: LESS
36975: AND
36976: IFFALSE 36980
// continue ;
36978: GO 36831
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36980: LD_VAR 0 3
36984: PPUSH
36985: CALL_OW 262
36989: PUSH
36990: LD_INT 1
36992: EQUAL
36993: PUSH
36994: LD_VAR 0 3
36998: PPUSH
36999: CALL_OW 261
37003: PUSH
37004: LD_INT 10
37006: LESS
37007: AND
37008: IFFALSE 37288
// begin if not depot then
37010: LD_VAR 0 9
37014: NOT
37015: IFFALSE 37019
// continue ;
37017: GO 36831
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
37019: LD_VAR 0 3
37023: PPUSH
37024: LD_VAR 0 9
37028: PPUSH
37029: LD_VAR 0 3
37033: PPUSH
37034: CALL_OW 74
37038: PPUSH
37039: CALL_OW 296
37043: PUSH
37044: LD_INT 6
37046: LESS
37047: IFFALSE 37063
// SetFuel ( j , 100 ) else
37049: LD_VAR 0 3
37053: PPUSH
37054: LD_INT 100
37056: PPUSH
37057: CALL_OW 240
37061: GO 37288
// if GetFuel ( j ) = 0 then
37063: LD_VAR 0 3
37067: PPUSH
37068: CALL_OW 261
37072: PUSH
37073: LD_INT 0
37075: EQUAL
37076: IFFALSE 37288
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
37078: LD_ADDR_EXP 97
37082: PUSH
37083: LD_EXP 97
37087: PPUSH
37088: LD_VAR 0 2
37092: PPUSH
37093: LD_EXP 97
37097: PUSH
37098: LD_VAR 0 2
37102: ARRAY
37103: PUSH
37104: LD_VAR 0 3
37108: DIFF
37109: PPUSH
37110: CALL_OW 1
37114: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37115: LD_VAR 0 3
37119: PPUSH
37120: CALL_OW 263
37124: PUSH
37125: LD_INT 1
37127: EQUAL
37128: IFFALSE 37144
// ComExitVehicle ( IsInUnit ( j ) ) ;
37130: LD_VAR 0 3
37134: PPUSH
37135: CALL_OW 310
37139: PPUSH
37140: CALL_OW 121
// if GetControl ( j ) = control_remote then
37144: LD_VAR 0 3
37148: PPUSH
37149: CALL_OW 263
37153: PUSH
37154: LD_INT 2
37156: EQUAL
37157: IFFALSE 37168
// ComUnlink ( j ) ;
37159: LD_VAR 0 3
37163: PPUSH
37164: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37168: LD_ADDR_VAR 0 10
37172: PUSH
37173: LD_VAR 0 2
37177: PPUSH
37178: LD_INT 3
37180: PPUSH
37181: CALL 46932 0 2
37185: ST_TO_ADDR
// if fac then
37186: LD_VAR 0 10
37190: IFFALSE 37286
// begin for k in fac do
37192: LD_ADDR_VAR 0 4
37196: PUSH
37197: LD_VAR 0 10
37201: PUSH
37202: FOR_IN
37203: IFFALSE 37284
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
37205: LD_ADDR_VAR 0 11
37209: PUSH
37210: LD_VAR 0 10
37214: PPUSH
37215: LD_VAR 0 3
37219: PPUSH
37220: CALL_OW 265
37224: PPUSH
37225: LD_VAR 0 3
37229: PPUSH
37230: CALL_OW 262
37234: PPUSH
37235: LD_VAR 0 3
37239: PPUSH
37240: CALL_OW 263
37244: PPUSH
37245: LD_VAR 0 3
37249: PPUSH
37250: CALL_OW 264
37254: PPUSH
37255: CALL 55363 0 5
37259: ST_TO_ADDR
// if components then
37260: LD_VAR 0 11
37264: IFFALSE 37282
// begin MC_InsertProduceList ( i , components ) ;
37266: LD_VAR 0 2
37270: PPUSH
37271: LD_VAR 0 11
37275: PPUSH
37276: CALL 46477 0 2
// break ;
37280: GO 37284
// end ; end ;
37282: GO 37202
37284: POP
37285: POP
// end ; continue ;
37286: GO 36831
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
37288: LD_VAR 0 3
37292: PPUSH
37293: LD_INT 1
37295: PPUSH
37296: CALL_OW 289
37300: PUSH
37301: LD_INT 100
37303: LESS
37304: PUSH
37305: LD_VAR 0 3
37309: PPUSH
37310: CALL_OW 314
37314: NOT
37315: AND
37316: IFFALSE 37345
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37318: LD_VAR 0 3
37322: PPUSH
37323: LD_VAR 0 7
37327: PUSH
37328: LD_INT 2
37330: ARRAY
37331: PPUSH
37332: LD_VAR 0 7
37336: PUSH
37337: LD_INT 3
37339: ARRAY
37340: PPUSH
37341: CALL_OW 117
// break ;
37345: GO 37349
// end ;
37347: GO 36831
37349: POP
37350: POP
// end ; end ;
37351: GO 35547
37353: POP
37354: POP
// end ;
37355: LD_VAR 0 1
37359: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
37360: LD_INT 0
37362: PPUSH
37363: PPUSH
37364: PPUSH
37365: PPUSH
// if not mc_bases then
37366: LD_EXP 78
37370: NOT
37371: IFFALSE 37375
// exit ;
37373: GO 37536
// for i = 1 to mc_bases do
37375: LD_ADDR_VAR 0 2
37379: PUSH
37380: DOUBLE
37381: LD_INT 1
37383: DEC
37384: ST_TO_ADDR
37385: LD_EXP 78
37389: PUSH
37390: FOR_TO
37391: IFFALSE 37534
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
37393: LD_ADDR_VAR 0 4
37397: PUSH
37398: LD_EXP 97
37402: PUSH
37403: LD_VAR 0 2
37407: ARRAY
37408: PUSH
37409: LD_EXP 100
37413: PUSH
37414: LD_VAR 0 2
37418: ARRAY
37419: UNION
37420: PPUSH
37421: LD_INT 33
37423: PUSH
37424: LD_INT 2
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PPUSH
37431: CALL_OW 72
37435: ST_TO_ADDR
// if tmp then
37436: LD_VAR 0 4
37440: IFFALSE 37532
// for j in tmp do
37442: LD_ADDR_VAR 0 3
37446: PUSH
37447: LD_VAR 0 4
37451: PUSH
37452: FOR_IN
37453: IFFALSE 37530
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
37455: LD_VAR 0 3
37459: PPUSH
37460: CALL_OW 312
37464: NOT
37465: PUSH
37466: LD_VAR 0 3
37470: PPUSH
37471: CALL_OW 256
37475: PUSH
37476: LD_INT 250
37478: GREATEREQUAL
37479: AND
37480: IFFALSE 37493
// Connect ( j ) else
37482: LD_VAR 0 3
37486: PPUSH
37487: CALL 61211 0 1
37491: GO 37528
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
37493: LD_VAR 0 3
37497: PPUSH
37498: CALL_OW 256
37502: PUSH
37503: LD_INT 250
37505: LESS
37506: PUSH
37507: LD_VAR 0 3
37511: PPUSH
37512: CALL_OW 312
37516: AND
37517: IFFALSE 37528
// ComUnlink ( j ) ;
37519: LD_VAR 0 3
37523: PPUSH
37524: CALL_OW 136
37528: GO 37452
37530: POP
37531: POP
// end ;
37532: GO 37390
37534: POP
37535: POP
// end ;
37536: LD_VAR 0 1
37540: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
37541: LD_INT 0
37543: PPUSH
37544: PPUSH
37545: PPUSH
37546: PPUSH
37547: PPUSH
// if not mc_bases then
37548: LD_EXP 78
37552: NOT
37553: IFFALSE 37557
// exit ;
37555: GO 38002
// for i = 1 to mc_bases do
37557: LD_ADDR_VAR 0 2
37561: PUSH
37562: DOUBLE
37563: LD_INT 1
37565: DEC
37566: ST_TO_ADDR
37567: LD_EXP 78
37571: PUSH
37572: FOR_TO
37573: IFFALSE 38000
// begin if not mc_produce [ i ] then
37575: LD_EXP 99
37579: PUSH
37580: LD_VAR 0 2
37584: ARRAY
37585: NOT
37586: IFFALSE 37590
// continue ;
37588: GO 37572
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37590: LD_ADDR_VAR 0 5
37594: PUSH
37595: LD_EXP 78
37599: PUSH
37600: LD_VAR 0 2
37604: ARRAY
37605: PPUSH
37606: LD_INT 30
37608: PUSH
37609: LD_INT 3
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PPUSH
37616: CALL_OW 72
37620: ST_TO_ADDR
// if not fac then
37621: LD_VAR 0 5
37625: NOT
37626: IFFALSE 37630
// continue ;
37628: GO 37572
// for j in fac do
37630: LD_ADDR_VAR 0 3
37634: PUSH
37635: LD_VAR 0 5
37639: PUSH
37640: FOR_IN
37641: IFFALSE 37996
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
37643: LD_VAR 0 3
37647: PPUSH
37648: CALL_OW 461
37652: PUSH
37653: LD_INT 2
37655: NONEQUAL
37656: PUSH
37657: LD_VAR 0 3
37661: PPUSH
37662: LD_INT 15
37664: PPUSH
37665: CALL 60830 0 2
37669: PUSH
37670: LD_INT 4
37672: ARRAY
37673: OR
37674: IFFALSE 37678
// continue ;
37676: GO 37640
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
37678: LD_VAR 0 3
37682: PPUSH
37683: LD_EXP 99
37687: PUSH
37688: LD_VAR 0 2
37692: ARRAY
37693: PUSH
37694: LD_INT 1
37696: ARRAY
37697: PUSH
37698: LD_INT 1
37700: ARRAY
37701: PPUSH
37702: LD_EXP 99
37706: PUSH
37707: LD_VAR 0 2
37711: ARRAY
37712: PUSH
37713: LD_INT 1
37715: ARRAY
37716: PUSH
37717: LD_INT 2
37719: ARRAY
37720: PPUSH
37721: LD_EXP 99
37725: PUSH
37726: LD_VAR 0 2
37730: ARRAY
37731: PUSH
37732: LD_INT 1
37734: ARRAY
37735: PUSH
37736: LD_INT 3
37738: ARRAY
37739: PPUSH
37740: LD_EXP 99
37744: PUSH
37745: LD_VAR 0 2
37749: ARRAY
37750: PUSH
37751: LD_INT 1
37753: ARRAY
37754: PUSH
37755: LD_INT 4
37757: ARRAY
37758: PPUSH
37759: CALL_OW 448
37763: PUSH
37764: LD_VAR 0 3
37768: PPUSH
37769: LD_EXP 99
37773: PUSH
37774: LD_VAR 0 2
37778: ARRAY
37779: PUSH
37780: LD_INT 1
37782: ARRAY
37783: PUSH
37784: LD_INT 1
37786: ARRAY
37787: PUSH
37788: LD_EXP 99
37792: PUSH
37793: LD_VAR 0 2
37797: ARRAY
37798: PUSH
37799: LD_INT 1
37801: ARRAY
37802: PUSH
37803: LD_INT 2
37805: ARRAY
37806: PUSH
37807: LD_EXP 99
37811: PUSH
37812: LD_VAR 0 2
37816: ARRAY
37817: PUSH
37818: LD_INT 1
37820: ARRAY
37821: PUSH
37822: LD_INT 3
37824: ARRAY
37825: PUSH
37826: LD_EXP 99
37830: PUSH
37831: LD_VAR 0 2
37835: ARRAY
37836: PUSH
37837: LD_INT 1
37839: ARRAY
37840: PUSH
37841: LD_INT 4
37843: ARRAY
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: LIST
37849: LIST
37850: PPUSH
37851: CALL 64606 0 2
37855: AND
37856: IFFALSE 37994
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37858: LD_VAR 0 3
37862: PPUSH
37863: LD_EXP 99
37867: PUSH
37868: LD_VAR 0 2
37872: ARRAY
37873: PUSH
37874: LD_INT 1
37876: ARRAY
37877: PUSH
37878: LD_INT 1
37880: ARRAY
37881: PPUSH
37882: LD_EXP 99
37886: PUSH
37887: LD_VAR 0 2
37891: ARRAY
37892: PUSH
37893: LD_INT 1
37895: ARRAY
37896: PUSH
37897: LD_INT 2
37899: ARRAY
37900: PPUSH
37901: LD_EXP 99
37905: PUSH
37906: LD_VAR 0 2
37910: ARRAY
37911: PUSH
37912: LD_INT 1
37914: ARRAY
37915: PUSH
37916: LD_INT 3
37918: ARRAY
37919: PPUSH
37920: LD_EXP 99
37924: PUSH
37925: LD_VAR 0 2
37929: ARRAY
37930: PUSH
37931: LD_INT 1
37933: ARRAY
37934: PUSH
37935: LD_INT 4
37937: ARRAY
37938: PPUSH
37939: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37943: LD_ADDR_VAR 0 4
37947: PUSH
37948: LD_EXP 99
37952: PUSH
37953: LD_VAR 0 2
37957: ARRAY
37958: PPUSH
37959: LD_INT 1
37961: PPUSH
37962: CALL_OW 3
37966: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37967: LD_ADDR_EXP 99
37971: PUSH
37972: LD_EXP 99
37976: PPUSH
37977: LD_VAR 0 2
37981: PPUSH
37982: LD_VAR 0 4
37986: PPUSH
37987: CALL_OW 1
37991: ST_TO_ADDR
// break ;
37992: GO 37996
// end ; end ;
37994: GO 37640
37996: POP
37997: POP
// end ;
37998: GO 37572
38000: POP
38001: POP
// end ;
38002: LD_VAR 0 1
38006: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
38007: LD_INT 0
38009: PPUSH
38010: PPUSH
38011: PPUSH
// if not mc_bases then
38012: LD_EXP 78
38016: NOT
38017: IFFALSE 38021
// exit ;
38019: GO 38110
// for i = 1 to mc_bases do
38021: LD_ADDR_VAR 0 2
38025: PUSH
38026: DOUBLE
38027: LD_INT 1
38029: DEC
38030: ST_TO_ADDR
38031: LD_EXP 78
38035: PUSH
38036: FOR_TO
38037: IFFALSE 38108
// begin if mc_attack [ i ] then
38039: LD_EXP 98
38043: PUSH
38044: LD_VAR 0 2
38048: ARRAY
38049: IFFALSE 38106
// begin tmp := mc_attack [ i ] [ 1 ] ;
38051: LD_ADDR_VAR 0 3
38055: PUSH
38056: LD_EXP 98
38060: PUSH
38061: LD_VAR 0 2
38065: ARRAY
38066: PUSH
38067: LD_INT 1
38069: ARRAY
38070: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38071: LD_ADDR_EXP 98
38075: PUSH
38076: LD_EXP 98
38080: PPUSH
38081: LD_VAR 0 2
38085: PPUSH
38086: EMPTY
38087: PPUSH
38088: CALL_OW 1
38092: ST_TO_ADDR
// Attack ( tmp ) ;
38093: LD_VAR 0 3
38097: PPUSH
38098: CALL 115598 0 1
// exit ;
38102: POP
38103: POP
38104: GO 38110
// end ; end ;
38106: GO 38036
38108: POP
38109: POP
// end ;
38110: LD_VAR 0 1
38114: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38115: LD_INT 0
38117: PPUSH
38118: PPUSH
38119: PPUSH
38120: PPUSH
38121: PPUSH
38122: PPUSH
38123: PPUSH
// if not mc_bases then
38124: LD_EXP 78
38128: NOT
38129: IFFALSE 38133
// exit ;
38131: GO 38990
// for i = 1 to mc_bases do
38133: LD_ADDR_VAR 0 2
38137: PUSH
38138: DOUBLE
38139: LD_INT 1
38141: DEC
38142: ST_TO_ADDR
38143: LD_EXP 78
38147: PUSH
38148: FOR_TO
38149: IFFALSE 38988
// begin if not mc_bases [ i ] then
38151: LD_EXP 78
38155: PUSH
38156: LD_VAR 0 2
38160: ARRAY
38161: NOT
38162: IFFALSE 38166
// continue ;
38164: GO 38148
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38166: LD_ADDR_VAR 0 7
38170: PUSH
38171: LD_EXP 78
38175: PUSH
38176: LD_VAR 0 2
38180: ARRAY
38181: PUSH
38182: LD_INT 1
38184: ARRAY
38185: PPUSH
38186: CALL 54689 0 1
38190: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
38191: LD_ADDR_EXP 101
38195: PUSH
38196: LD_EXP 101
38200: PPUSH
38201: LD_VAR 0 2
38205: PPUSH
38206: LD_EXP 78
38210: PUSH
38211: LD_VAR 0 2
38215: ARRAY
38216: PUSH
38217: LD_INT 1
38219: ARRAY
38220: PPUSH
38221: CALL_OW 255
38225: PPUSH
38226: LD_EXP 103
38230: PUSH
38231: LD_VAR 0 2
38235: ARRAY
38236: PPUSH
38237: CALL 54654 0 2
38241: PPUSH
38242: CALL_OW 1
38246: ST_TO_ADDR
// if not mc_scan [ i ] then
38247: LD_EXP 101
38251: PUSH
38252: LD_VAR 0 2
38256: ARRAY
38257: NOT
38258: IFFALSE 38436
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38260: LD_ADDR_EXP 121
38264: PUSH
38265: LD_EXP 121
38269: PPUSH
38270: LD_VAR 0 2
38274: PPUSH
38275: LD_INT 0
38277: PPUSH
38278: CALL_OW 1
38282: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38283: LD_ADDR_VAR 0 4
38287: PUSH
38288: LD_EXP 78
38292: PUSH
38293: LD_VAR 0 2
38297: ARRAY
38298: PPUSH
38299: LD_INT 2
38301: PUSH
38302: LD_INT 25
38304: PUSH
38305: LD_INT 5
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: LD_INT 25
38314: PUSH
38315: LD_INT 8
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: LD_INT 25
38324: PUSH
38325: LD_INT 9
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: PPUSH
38338: CALL_OW 72
38342: ST_TO_ADDR
// if not tmp then
38343: LD_VAR 0 4
38347: NOT
38348: IFFALSE 38352
// continue ;
38350: GO 38148
// for j in tmp do
38352: LD_ADDR_VAR 0 3
38356: PUSH
38357: LD_VAR 0 4
38361: PUSH
38362: FOR_IN
38363: IFFALSE 38434
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
38365: LD_VAR 0 3
38369: PPUSH
38370: CALL_OW 310
38374: PPUSH
38375: CALL_OW 266
38379: PUSH
38380: LD_INT 5
38382: EQUAL
38383: PUSH
38384: LD_VAR 0 3
38388: PPUSH
38389: CALL_OW 257
38393: PUSH
38394: LD_INT 1
38396: EQUAL
38397: AND
38398: PUSH
38399: LD_VAR 0 3
38403: PPUSH
38404: CALL_OW 459
38408: NOT
38409: AND
38410: PUSH
38411: LD_VAR 0 7
38415: AND
38416: IFFALSE 38432
// ComChangeProfession ( j , class ) ;
38418: LD_VAR 0 3
38422: PPUSH
38423: LD_VAR 0 7
38427: PPUSH
38428: CALL_OW 123
38432: GO 38362
38434: POP
38435: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
38436: LD_EXP 101
38440: PUSH
38441: LD_VAR 0 2
38445: ARRAY
38446: PUSH
38447: LD_EXP 121
38451: PUSH
38452: LD_VAR 0 2
38456: ARRAY
38457: NOT
38458: AND
38459: PUSH
38460: LD_EXP 100
38464: PUSH
38465: LD_VAR 0 2
38469: ARRAY
38470: NOT
38471: AND
38472: PUSH
38473: LD_EXP 78
38477: PUSH
38478: LD_VAR 0 2
38482: ARRAY
38483: PPUSH
38484: LD_INT 50
38486: PUSH
38487: EMPTY
38488: LIST
38489: PUSH
38490: LD_INT 2
38492: PUSH
38493: LD_INT 30
38495: PUSH
38496: LD_INT 32
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 30
38505: PUSH
38506: LD_INT 33
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 30
38515: PUSH
38516: LD_INT 4
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 30
38525: PUSH
38526: LD_INT 5
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: PUSH
38540: EMPTY
38541: LIST
38542: LIST
38543: PPUSH
38544: CALL_OW 72
38548: PUSH
38549: LD_INT 4
38551: LESS
38552: PUSH
38553: LD_EXP 78
38557: PUSH
38558: LD_VAR 0 2
38562: ARRAY
38563: PPUSH
38564: LD_INT 3
38566: PUSH
38567: LD_INT 24
38569: PUSH
38570: LD_INT 1000
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: PUSH
38581: LD_INT 2
38583: PUSH
38584: LD_INT 30
38586: PUSH
38587: LD_INT 0
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 30
38596: PUSH
38597: LD_INT 1
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: EMPTY
38605: LIST
38606: LIST
38607: LIST
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: PPUSH
38613: CALL_OW 72
38617: OR
38618: AND
38619: IFFALSE 38870
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38621: LD_ADDR_EXP 121
38625: PUSH
38626: LD_EXP 121
38630: PPUSH
38631: LD_VAR 0 2
38635: PPUSH
38636: LD_INT 1
38638: PPUSH
38639: CALL_OW 1
38643: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38644: LD_ADDR_VAR 0 4
38648: PUSH
38649: LD_EXP 78
38653: PUSH
38654: LD_VAR 0 2
38658: ARRAY
38659: PPUSH
38660: LD_INT 2
38662: PUSH
38663: LD_INT 25
38665: PUSH
38666: LD_INT 1
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: LD_INT 25
38675: PUSH
38676: LD_INT 5
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 25
38685: PUSH
38686: LD_INT 8
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: LD_INT 25
38695: PUSH
38696: LD_INT 9
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: LIST
38707: LIST
38708: LIST
38709: PPUSH
38710: CALL_OW 72
38714: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
38715: LD_ADDR_VAR 0 4
38719: PUSH
38720: LD_VAR 0 4
38724: PUSH
38725: LD_VAR 0 4
38729: PPUSH
38730: LD_INT 18
38732: PPUSH
38733: CALL 88174 0 2
38737: DIFF
38738: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
38739: LD_VAR 0 4
38743: NOT
38744: PUSH
38745: LD_EXP 78
38749: PUSH
38750: LD_VAR 0 2
38754: ARRAY
38755: PPUSH
38756: LD_INT 2
38758: PUSH
38759: LD_INT 30
38761: PUSH
38762: LD_INT 4
38764: PUSH
38765: EMPTY
38766: LIST
38767: LIST
38768: PUSH
38769: LD_INT 30
38771: PUSH
38772: LD_INT 5
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: LIST
38783: PPUSH
38784: CALL_OW 72
38788: NOT
38789: AND
38790: IFFALSE 38852
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
38792: LD_ADDR_VAR 0 4
38796: PUSH
38797: LD_EXP 78
38801: PUSH
38802: LD_VAR 0 2
38806: ARRAY
38807: PPUSH
38808: LD_INT 2
38810: PUSH
38811: LD_INT 25
38813: PUSH
38814: LD_INT 2
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: LD_INT 25
38823: PUSH
38824: LD_INT 3
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 25
38833: PUSH
38834: LD_INT 4
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: LIST
38845: LIST
38846: PPUSH
38847: CALL_OW 72
38851: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38852: LD_VAR 0 2
38856: PPUSH
38857: LD_VAR 0 4
38861: PPUSH
38862: CALL 120307 0 2
// exit ;
38866: POP
38867: POP
38868: GO 38990
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38870: LD_EXP 101
38874: PUSH
38875: LD_VAR 0 2
38879: ARRAY
38880: PUSH
38881: LD_EXP 121
38885: PUSH
38886: LD_VAR 0 2
38890: ARRAY
38891: NOT
38892: AND
38893: PUSH
38894: LD_EXP 100
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: AND
38905: IFFALSE 38986
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38907: LD_ADDR_EXP 121
38911: PUSH
38912: LD_EXP 121
38916: PPUSH
38917: LD_VAR 0 2
38921: PPUSH
38922: LD_INT 1
38924: PPUSH
38925: CALL_OW 1
38929: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38930: LD_ADDR_VAR 0 4
38934: PUSH
38935: LD_EXP 100
38939: PUSH
38940: LD_VAR 0 2
38944: ARRAY
38945: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38946: LD_ADDR_EXP 100
38950: PUSH
38951: LD_EXP 100
38955: PPUSH
38956: LD_VAR 0 2
38960: PPUSH
38961: EMPTY
38962: PPUSH
38963: CALL_OW 1
38967: ST_TO_ADDR
// Defend ( i , tmp ) ;
38968: LD_VAR 0 2
38972: PPUSH
38973: LD_VAR 0 4
38977: PPUSH
38978: CALL 120903 0 2
// exit ;
38982: POP
38983: POP
38984: GO 38990
// end ; end ;
38986: GO 38148
38988: POP
38989: POP
// end ;
38990: LD_VAR 0 1
38994: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38995: LD_INT 0
38997: PPUSH
38998: PPUSH
38999: PPUSH
39000: PPUSH
39001: PPUSH
39002: PPUSH
39003: PPUSH
39004: PPUSH
39005: PPUSH
39006: PPUSH
39007: PPUSH
// if not mc_bases then
39008: LD_EXP 78
39012: NOT
39013: IFFALSE 39017
// exit ;
39015: GO 40104
// for i = 1 to mc_bases do
39017: LD_ADDR_VAR 0 2
39021: PUSH
39022: DOUBLE
39023: LD_INT 1
39025: DEC
39026: ST_TO_ADDR
39027: LD_EXP 78
39031: PUSH
39032: FOR_TO
39033: IFFALSE 40102
// begin tmp := mc_lab [ i ] ;
39035: LD_ADDR_VAR 0 6
39039: PUSH
39040: LD_EXP 111
39044: PUSH
39045: LD_VAR 0 2
39049: ARRAY
39050: ST_TO_ADDR
// if not tmp then
39051: LD_VAR 0 6
39055: NOT
39056: IFFALSE 39060
// continue ;
39058: GO 39032
// idle_lab := 0 ;
39060: LD_ADDR_VAR 0 11
39064: PUSH
39065: LD_INT 0
39067: ST_TO_ADDR
// for j in tmp do
39068: LD_ADDR_VAR 0 3
39072: PUSH
39073: LD_VAR 0 6
39077: PUSH
39078: FOR_IN
39079: IFFALSE 40098
// begin researching := false ;
39081: LD_ADDR_VAR 0 10
39085: PUSH
39086: LD_INT 0
39088: ST_TO_ADDR
// side := GetSide ( j ) ;
39089: LD_ADDR_VAR 0 4
39093: PUSH
39094: LD_VAR 0 3
39098: PPUSH
39099: CALL_OW 255
39103: ST_TO_ADDR
// if not mc_tech [ side ] then
39104: LD_EXP 105
39108: PUSH
39109: LD_VAR 0 4
39113: ARRAY
39114: NOT
39115: IFFALSE 39119
// continue ;
39117: GO 39078
// if BuildingStatus ( j ) = bs_idle then
39119: LD_VAR 0 3
39123: PPUSH
39124: CALL_OW 461
39128: PUSH
39129: LD_INT 2
39131: EQUAL
39132: IFFALSE 39320
// begin if idle_lab and UnitsInside ( j ) < 6 then
39134: LD_VAR 0 11
39138: PUSH
39139: LD_VAR 0 3
39143: PPUSH
39144: CALL_OW 313
39148: PUSH
39149: LD_INT 6
39151: LESS
39152: AND
39153: IFFALSE 39224
// begin tmp2 := UnitsInside ( idle_lab ) ;
39155: LD_ADDR_VAR 0 9
39159: PUSH
39160: LD_VAR 0 11
39164: PPUSH
39165: CALL_OW 313
39169: ST_TO_ADDR
// if tmp2 then
39170: LD_VAR 0 9
39174: IFFALSE 39216
// for x in tmp2 do
39176: LD_ADDR_VAR 0 7
39180: PUSH
39181: LD_VAR 0 9
39185: PUSH
39186: FOR_IN
39187: IFFALSE 39214
// begin ComExitBuilding ( x ) ;
39189: LD_VAR 0 7
39193: PPUSH
39194: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39198: LD_VAR 0 7
39202: PPUSH
39203: LD_VAR 0 3
39207: PPUSH
39208: CALL_OW 180
// end ;
39212: GO 39186
39214: POP
39215: POP
// idle_lab := 0 ;
39216: LD_ADDR_VAR 0 11
39220: PUSH
39221: LD_INT 0
39223: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
39224: LD_ADDR_VAR 0 5
39228: PUSH
39229: LD_EXP 105
39233: PUSH
39234: LD_VAR 0 4
39238: ARRAY
39239: PUSH
39240: FOR_IN
39241: IFFALSE 39301
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
39243: LD_VAR 0 3
39247: PPUSH
39248: LD_VAR 0 5
39252: PPUSH
39253: CALL_OW 430
39257: PUSH
39258: LD_VAR 0 4
39262: PPUSH
39263: LD_VAR 0 5
39267: PPUSH
39268: CALL 53759 0 2
39272: AND
39273: IFFALSE 39299
// begin researching := true ;
39275: LD_ADDR_VAR 0 10
39279: PUSH
39280: LD_INT 1
39282: ST_TO_ADDR
// ComResearch ( j , t ) ;
39283: LD_VAR 0 3
39287: PPUSH
39288: LD_VAR 0 5
39292: PPUSH
39293: CALL_OW 124
// break ;
39297: GO 39301
// end ;
39299: GO 39240
39301: POP
39302: POP
// if not researching then
39303: LD_VAR 0 10
39307: NOT
39308: IFFALSE 39320
// idle_lab := j ;
39310: LD_ADDR_VAR 0 11
39314: PUSH
39315: LD_VAR 0 3
39319: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
39320: LD_VAR 0 3
39324: PPUSH
39325: CALL_OW 461
39329: PUSH
39330: LD_INT 10
39332: EQUAL
39333: IFFALSE 39921
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
39335: LD_EXP 107
39339: PUSH
39340: LD_VAR 0 2
39344: ARRAY
39345: NOT
39346: PUSH
39347: LD_EXP 108
39351: PUSH
39352: LD_VAR 0 2
39356: ARRAY
39357: NOT
39358: AND
39359: PUSH
39360: LD_EXP 105
39364: PUSH
39365: LD_VAR 0 4
39369: ARRAY
39370: PUSH
39371: LD_INT 1
39373: GREATER
39374: AND
39375: IFFALSE 39506
// begin ComCancel ( j ) ;
39377: LD_VAR 0 3
39381: PPUSH
39382: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
39386: LD_ADDR_EXP 105
39390: PUSH
39391: LD_EXP 105
39395: PPUSH
39396: LD_VAR 0 4
39400: PPUSH
39401: LD_EXP 105
39405: PUSH
39406: LD_VAR 0 4
39410: ARRAY
39411: PPUSH
39412: LD_EXP 105
39416: PUSH
39417: LD_VAR 0 4
39421: ARRAY
39422: PUSH
39423: LD_INT 1
39425: MINUS
39426: PPUSH
39427: LD_EXP 105
39431: PUSH
39432: LD_VAR 0 4
39436: ARRAY
39437: PPUSH
39438: LD_INT 0
39440: PPUSH
39441: CALL 57283 0 4
39445: PPUSH
39446: CALL_OW 1
39450: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
39451: LD_ADDR_EXP 105
39455: PUSH
39456: LD_EXP 105
39460: PPUSH
39461: LD_VAR 0 4
39465: PPUSH
39466: LD_EXP 105
39470: PUSH
39471: LD_VAR 0 4
39475: ARRAY
39476: PPUSH
39477: LD_EXP 105
39481: PUSH
39482: LD_VAR 0 4
39486: ARRAY
39487: PPUSH
39488: LD_INT 1
39490: PPUSH
39491: LD_INT 0
39493: PPUSH
39494: CALL 57283 0 4
39498: PPUSH
39499: CALL_OW 1
39503: ST_TO_ADDR
// continue ;
39504: GO 39078
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
39506: LD_EXP 107
39510: PUSH
39511: LD_VAR 0 2
39515: ARRAY
39516: PUSH
39517: LD_EXP 108
39521: PUSH
39522: LD_VAR 0 2
39526: ARRAY
39527: NOT
39528: AND
39529: IFFALSE 39656
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
39531: LD_ADDR_EXP 108
39535: PUSH
39536: LD_EXP 108
39540: PPUSH
39541: LD_VAR 0 2
39545: PUSH
39546: LD_EXP 108
39550: PUSH
39551: LD_VAR 0 2
39555: ARRAY
39556: PUSH
39557: LD_INT 1
39559: PLUS
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PPUSH
39565: LD_EXP 107
39569: PUSH
39570: LD_VAR 0 2
39574: ARRAY
39575: PUSH
39576: LD_INT 1
39578: ARRAY
39579: PPUSH
39580: CALL 57865 0 3
39584: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
39585: LD_EXP 107
39589: PUSH
39590: LD_VAR 0 2
39594: ARRAY
39595: PUSH
39596: LD_INT 1
39598: ARRAY
39599: PPUSH
39600: LD_INT 112
39602: PPUSH
39603: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
39607: LD_ADDR_VAR 0 9
39611: PUSH
39612: LD_EXP 107
39616: PUSH
39617: LD_VAR 0 2
39621: ARRAY
39622: PPUSH
39623: LD_INT 1
39625: PPUSH
39626: CALL_OW 3
39630: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
39631: LD_ADDR_EXP 107
39635: PUSH
39636: LD_EXP 107
39640: PPUSH
39641: LD_VAR 0 2
39645: PPUSH
39646: LD_VAR 0 9
39650: PPUSH
39651: CALL_OW 1
39655: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
39656: LD_EXP 107
39660: PUSH
39661: LD_VAR 0 2
39665: ARRAY
39666: PUSH
39667: LD_EXP 108
39671: PUSH
39672: LD_VAR 0 2
39676: ARRAY
39677: AND
39678: PUSH
39679: LD_EXP 108
39683: PUSH
39684: LD_VAR 0 2
39688: ARRAY
39689: PUSH
39690: LD_INT 1
39692: ARRAY
39693: PPUSH
39694: CALL_OW 310
39698: NOT
39699: AND
39700: PUSH
39701: LD_VAR 0 3
39705: PPUSH
39706: CALL_OW 313
39710: PUSH
39711: LD_INT 6
39713: EQUAL
39714: AND
39715: IFFALSE 39771
// begin tmp2 := UnitsInside ( j ) ;
39717: LD_ADDR_VAR 0 9
39721: PUSH
39722: LD_VAR 0 3
39726: PPUSH
39727: CALL_OW 313
39731: ST_TO_ADDR
// if tmp2 = 6 then
39732: LD_VAR 0 9
39736: PUSH
39737: LD_INT 6
39739: EQUAL
39740: IFFALSE 39771
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
39742: LD_VAR 0 9
39746: PUSH
39747: LD_INT 1
39749: ARRAY
39750: PPUSH
39751: LD_INT 112
39753: PPUSH
39754: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
39758: LD_VAR 0 9
39762: PUSH
39763: LD_INT 1
39765: ARRAY
39766: PPUSH
39767: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
39771: LD_EXP 108
39775: PUSH
39776: LD_VAR 0 2
39780: ARRAY
39781: PUSH
39782: LD_EXP 108
39786: PUSH
39787: LD_VAR 0 2
39791: ARRAY
39792: PUSH
39793: LD_INT 1
39795: ARRAY
39796: PPUSH
39797: CALL_OW 314
39801: NOT
39802: AND
39803: PUSH
39804: LD_EXP 108
39808: PUSH
39809: LD_VAR 0 2
39813: ARRAY
39814: PUSH
39815: LD_INT 1
39817: ARRAY
39818: PPUSH
39819: CALL_OW 310
39823: NOT
39824: AND
39825: IFFALSE 39851
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
39827: LD_EXP 108
39831: PUSH
39832: LD_VAR 0 2
39836: ARRAY
39837: PUSH
39838: LD_INT 1
39840: ARRAY
39841: PPUSH
39842: LD_VAR 0 3
39846: PPUSH
39847: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
39851: LD_EXP 108
39855: PUSH
39856: LD_VAR 0 2
39860: ARRAY
39861: PUSH
39862: LD_INT 1
39864: ARRAY
39865: PPUSH
39866: CALL_OW 310
39870: PUSH
39871: LD_EXP 108
39875: PUSH
39876: LD_VAR 0 2
39880: ARRAY
39881: PUSH
39882: LD_INT 1
39884: ARRAY
39885: PPUSH
39886: CALL_OW 310
39890: PPUSH
39891: CALL_OW 461
39895: PUSH
39896: LD_INT 3
39898: NONEQUAL
39899: AND
39900: IFFALSE 39921
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39902: LD_EXP 108
39906: PUSH
39907: LD_VAR 0 2
39911: ARRAY
39912: PUSH
39913: LD_INT 1
39915: ARRAY
39916: PPUSH
39917: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39921: LD_VAR 0 3
39925: PPUSH
39926: CALL_OW 461
39930: PUSH
39931: LD_INT 6
39933: EQUAL
39934: PUSH
39935: LD_VAR 0 6
39939: PUSH
39940: LD_INT 1
39942: GREATER
39943: AND
39944: IFFALSE 40096
// begin sci := [ ] ;
39946: LD_ADDR_VAR 0 8
39950: PUSH
39951: EMPTY
39952: ST_TO_ADDR
// for x in ( tmp diff j ) do
39953: LD_ADDR_VAR 0 7
39957: PUSH
39958: LD_VAR 0 6
39962: PUSH
39963: LD_VAR 0 3
39967: DIFF
39968: PUSH
39969: FOR_IN
39970: IFFALSE 40022
// begin if sci = 6 then
39972: LD_VAR 0 8
39976: PUSH
39977: LD_INT 6
39979: EQUAL
39980: IFFALSE 39984
// break ;
39982: GO 40022
// if BuildingStatus ( x ) = bs_idle then
39984: LD_VAR 0 7
39988: PPUSH
39989: CALL_OW 461
39993: PUSH
39994: LD_INT 2
39996: EQUAL
39997: IFFALSE 40020
// sci := sci ^ UnitsInside ( x ) ;
39999: LD_ADDR_VAR 0 8
40003: PUSH
40004: LD_VAR 0 8
40008: PUSH
40009: LD_VAR 0 7
40013: PPUSH
40014: CALL_OW 313
40018: ADD
40019: ST_TO_ADDR
// end ;
40020: GO 39969
40022: POP
40023: POP
// if not sci then
40024: LD_VAR 0 8
40028: NOT
40029: IFFALSE 40033
// continue ;
40031: GO 39078
// for x in sci do
40033: LD_ADDR_VAR 0 7
40037: PUSH
40038: LD_VAR 0 8
40042: PUSH
40043: FOR_IN
40044: IFFALSE 40094
// if IsInUnit ( x ) and not HasTask ( x ) then
40046: LD_VAR 0 7
40050: PPUSH
40051: CALL_OW 310
40055: PUSH
40056: LD_VAR 0 7
40060: PPUSH
40061: CALL_OW 314
40065: NOT
40066: AND
40067: IFFALSE 40092
// begin ComExitBuilding ( x ) ;
40069: LD_VAR 0 7
40073: PPUSH
40074: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40078: LD_VAR 0 7
40082: PPUSH
40083: LD_VAR 0 3
40087: PPUSH
40088: CALL_OW 180
// end ;
40092: GO 40043
40094: POP
40095: POP
// end ; end ;
40096: GO 39078
40098: POP
40099: POP
// end ;
40100: GO 39032
40102: POP
40103: POP
// end ;
40104: LD_VAR 0 1
40108: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40109: LD_INT 0
40111: PPUSH
40112: PPUSH
// if not mc_bases then
40113: LD_EXP 78
40117: NOT
40118: IFFALSE 40122
// exit ;
40120: GO 40203
// for i = 1 to mc_bases do
40122: LD_ADDR_VAR 0 2
40126: PUSH
40127: DOUBLE
40128: LD_INT 1
40130: DEC
40131: ST_TO_ADDR
40132: LD_EXP 78
40136: PUSH
40137: FOR_TO
40138: IFFALSE 40201
// if mc_mines [ i ] and mc_miners [ i ] then
40140: LD_EXP 91
40144: PUSH
40145: LD_VAR 0 2
40149: ARRAY
40150: PUSH
40151: LD_EXP 92
40155: PUSH
40156: LD_VAR 0 2
40160: ARRAY
40161: AND
40162: IFFALSE 40199
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40164: LD_EXP 92
40168: PUSH
40169: LD_VAR 0 2
40173: ARRAY
40174: PUSH
40175: LD_INT 1
40177: ARRAY
40178: PPUSH
40179: CALL_OW 255
40183: PPUSH
40184: LD_EXP 91
40188: PUSH
40189: LD_VAR 0 2
40193: ARRAY
40194: PPUSH
40195: CALL 54842 0 2
40199: GO 40137
40201: POP
40202: POP
// end ;
40203: LD_VAR 0 1
40207: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
40208: LD_INT 0
40210: PPUSH
40211: PPUSH
40212: PPUSH
40213: PPUSH
40214: PPUSH
40215: PPUSH
40216: PPUSH
40217: PPUSH
// if not mc_bases or not mc_parking then
40218: LD_EXP 78
40222: NOT
40223: PUSH
40224: LD_EXP 102
40228: NOT
40229: OR
40230: IFFALSE 40234
// exit ;
40232: GO 40972
// for i = 1 to mc_bases do
40234: LD_ADDR_VAR 0 2
40238: PUSH
40239: DOUBLE
40240: LD_INT 1
40242: DEC
40243: ST_TO_ADDR
40244: LD_EXP 78
40248: PUSH
40249: FOR_TO
40250: IFFALSE 40970
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
40252: LD_EXP 78
40256: PUSH
40257: LD_VAR 0 2
40261: ARRAY
40262: NOT
40263: PUSH
40264: LD_EXP 102
40268: PUSH
40269: LD_VAR 0 2
40273: ARRAY
40274: NOT
40275: OR
40276: IFFALSE 40280
// continue ;
40278: GO 40249
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
40280: LD_ADDR_VAR 0 5
40284: PUSH
40285: LD_EXP 78
40289: PUSH
40290: LD_VAR 0 2
40294: ARRAY
40295: PUSH
40296: LD_INT 1
40298: ARRAY
40299: PPUSH
40300: CALL_OW 255
40304: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40305: LD_ADDR_VAR 0 6
40309: PUSH
40310: LD_EXP 78
40314: PUSH
40315: LD_VAR 0 2
40319: ARRAY
40320: PPUSH
40321: LD_INT 30
40323: PUSH
40324: LD_INT 3
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PPUSH
40331: CALL_OW 72
40335: ST_TO_ADDR
// if not fac then
40336: LD_VAR 0 6
40340: NOT
40341: IFFALSE 40392
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40343: LD_ADDR_VAR 0 6
40347: PUSH
40348: LD_EXP 78
40352: PUSH
40353: LD_VAR 0 2
40357: ARRAY
40358: PPUSH
40359: LD_INT 2
40361: PUSH
40362: LD_INT 30
40364: PUSH
40365: LD_INT 0
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 30
40374: PUSH
40375: LD_INT 1
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: LIST
40386: PPUSH
40387: CALL_OW 72
40391: ST_TO_ADDR
// if not fac then
40392: LD_VAR 0 6
40396: NOT
40397: IFFALSE 40401
// continue ;
40399: GO 40249
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40401: LD_ADDR_VAR 0 7
40405: PUSH
40406: LD_EXP 102
40410: PUSH
40411: LD_VAR 0 2
40415: ARRAY
40416: PPUSH
40417: LD_INT 22
40419: PUSH
40420: LD_VAR 0 5
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: LD_INT 21
40431: PUSH
40432: LD_INT 2
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: PUSH
40439: LD_INT 3
40441: PUSH
40442: LD_INT 60
40444: PUSH
40445: EMPTY
40446: LIST
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 3
40454: PUSH
40455: LD_INT 24
40457: PUSH
40458: LD_INT 1000
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: LIST
40473: LIST
40474: PPUSH
40475: CALL_OW 70
40479: ST_TO_ADDR
// for j in fac do
40480: LD_ADDR_VAR 0 3
40484: PUSH
40485: LD_VAR 0 6
40489: PUSH
40490: FOR_IN
40491: IFFALSE 40586
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40493: LD_ADDR_VAR 0 7
40497: PUSH
40498: LD_VAR 0 7
40502: PUSH
40503: LD_INT 22
40505: PUSH
40506: LD_VAR 0 5
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 91
40517: PUSH
40518: LD_VAR 0 3
40522: PUSH
40523: LD_INT 15
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 21
40533: PUSH
40534: LD_INT 2
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: PUSH
40541: LD_INT 3
40543: PUSH
40544: LD_INT 60
40546: PUSH
40547: EMPTY
40548: LIST
40549: PUSH
40550: EMPTY
40551: LIST
40552: LIST
40553: PUSH
40554: LD_INT 3
40556: PUSH
40557: LD_INT 24
40559: PUSH
40560: LD_INT 1000
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: EMPTY
40568: LIST
40569: LIST
40570: PUSH
40571: EMPTY
40572: LIST
40573: LIST
40574: LIST
40575: LIST
40576: LIST
40577: PPUSH
40578: CALL_OW 69
40582: UNION
40583: ST_TO_ADDR
40584: GO 40490
40586: POP
40587: POP
// if not vehs then
40588: LD_VAR 0 7
40592: NOT
40593: IFFALSE 40619
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
40595: LD_ADDR_EXP 90
40599: PUSH
40600: LD_EXP 90
40604: PPUSH
40605: LD_VAR 0 2
40609: PPUSH
40610: EMPTY
40611: PPUSH
40612: CALL_OW 1
40616: ST_TO_ADDR
// continue ;
40617: GO 40249
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40619: LD_ADDR_VAR 0 8
40623: PUSH
40624: LD_EXP 78
40628: PUSH
40629: LD_VAR 0 2
40633: ARRAY
40634: PPUSH
40635: LD_INT 30
40637: PUSH
40638: LD_INT 3
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PPUSH
40645: CALL_OW 72
40649: ST_TO_ADDR
// if tmp then
40650: LD_VAR 0 8
40654: IFFALSE 40757
// begin for j in tmp do
40656: LD_ADDR_VAR 0 3
40660: PUSH
40661: LD_VAR 0 8
40665: PUSH
40666: FOR_IN
40667: IFFALSE 40755
// for k in UnitsInside ( j ) do
40669: LD_ADDR_VAR 0 4
40673: PUSH
40674: LD_VAR 0 3
40678: PPUSH
40679: CALL_OW 313
40683: PUSH
40684: FOR_IN
40685: IFFALSE 40751
// if k then
40687: LD_VAR 0 4
40691: IFFALSE 40749
// if not k in mc_repair_vehicle [ i ] then
40693: LD_VAR 0 4
40697: PUSH
40698: LD_EXP 90
40702: PUSH
40703: LD_VAR 0 2
40707: ARRAY
40708: IN
40709: NOT
40710: IFFALSE 40749
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
40712: LD_ADDR_EXP 90
40716: PUSH
40717: LD_EXP 90
40721: PPUSH
40722: LD_VAR 0 2
40726: PPUSH
40727: LD_EXP 90
40731: PUSH
40732: LD_VAR 0 2
40736: ARRAY
40737: PUSH
40738: LD_VAR 0 4
40742: UNION
40743: PPUSH
40744: CALL_OW 1
40748: ST_TO_ADDR
40749: GO 40684
40751: POP
40752: POP
40753: GO 40666
40755: POP
40756: POP
// end ; if not mc_repair_vehicle [ i ] then
40757: LD_EXP 90
40761: PUSH
40762: LD_VAR 0 2
40766: ARRAY
40767: NOT
40768: IFFALSE 40772
// continue ;
40770: GO 40249
// for j in mc_repair_vehicle [ i ] do
40772: LD_ADDR_VAR 0 3
40776: PUSH
40777: LD_EXP 90
40781: PUSH
40782: LD_VAR 0 2
40786: ARRAY
40787: PUSH
40788: FOR_IN
40789: IFFALSE 40966
// begin if GetClass ( j ) <> 3 then
40791: LD_VAR 0 3
40795: PPUSH
40796: CALL_OW 257
40800: PUSH
40801: LD_INT 3
40803: NONEQUAL
40804: IFFALSE 40845
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
40806: LD_ADDR_EXP 90
40810: PUSH
40811: LD_EXP 90
40815: PPUSH
40816: LD_VAR 0 2
40820: PPUSH
40821: LD_EXP 90
40825: PUSH
40826: LD_VAR 0 2
40830: ARRAY
40831: PUSH
40832: LD_VAR 0 3
40836: DIFF
40837: PPUSH
40838: CALL_OW 1
40842: ST_TO_ADDR
// continue ;
40843: GO 40788
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40845: LD_VAR 0 3
40849: PPUSH
40850: CALL_OW 311
40854: NOT
40855: PUSH
40856: LD_VAR 0 3
40860: PUSH
40861: LD_EXP 81
40865: PUSH
40866: LD_VAR 0 2
40870: ARRAY
40871: PUSH
40872: LD_INT 1
40874: ARRAY
40875: IN
40876: NOT
40877: AND
40878: PUSH
40879: LD_VAR 0 3
40883: PUSH
40884: LD_EXP 81
40888: PUSH
40889: LD_VAR 0 2
40893: ARRAY
40894: PUSH
40895: LD_INT 2
40897: ARRAY
40898: IN
40899: NOT
40900: AND
40901: IFFALSE 40964
// begin if IsInUnit ( j ) then
40903: LD_VAR 0 3
40907: PPUSH
40908: CALL_OW 310
40912: IFFALSE 40925
// ComExitBuilding ( j ) else
40914: LD_VAR 0 3
40918: PPUSH
40919: CALL_OW 122
40923: GO 40964
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40925: LD_VAR 0 3
40929: PPUSH
40930: LD_VAR 0 7
40934: PUSH
40935: LD_INT 1
40937: ARRAY
40938: PPUSH
40939: CALL 92670 0 2
40943: NOT
40944: IFFALSE 40964
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40946: LD_VAR 0 3
40950: PPUSH
40951: LD_VAR 0 7
40955: PUSH
40956: LD_INT 1
40958: ARRAY
40959: PPUSH
40960: CALL_OW 129
// end ; end ;
40964: GO 40788
40966: POP
40967: POP
// end ;
40968: GO 40249
40970: POP
40971: POP
// end ;
40972: LD_VAR 0 1
40976: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40977: LD_INT 0
40979: PPUSH
40980: PPUSH
40981: PPUSH
40982: PPUSH
40983: PPUSH
40984: PPUSH
40985: PPUSH
40986: PPUSH
40987: PPUSH
40988: PPUSH
40989: PPUSH
// if not mc_bases then
40990: LD_EXP 78
40994: NOT
40995: IFFALSE 40999
// exit ;
40997: GO 41801
// for i = 1 to mc_bases do
40999: LD_ADDR_VAR 0 2
41003: PUSH
41004: DOUBLE
41005: LD_INT 1
41007: DEC
41008: ST_TO_ADDR
41009: LD_EXP 78
41013: PUSH
41014: FOR_TO
41015: IFFALSE 41799
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
41017: LD_EXP 106
41021: PUSH
41022: LD_VAR 0 2
41026: ARRAY
41027: NOT
41028: PUSH
41029: LD_EXP 81
41033: PUSH
41034: LD_VAR 0 2
41038: ARRAY
41039: PUSH
41040: LD_INT 1
41042: ARRAY
41043: OR
41044: PUSH
41045: LD_EXP 81
41049: PUSH
41050: LD_VAR 0 2
41054: ARRAY
41055: PUSH
41056: LD_INT 2
41058: ARRAY
41059: OR
41060: PUSH
41061: LD_EXP 104
41065: PUSH
41066: LD_VAR 0 2
41070: ARRAY
41071: PPUSH
41072: LD_INT 1
41074: PPUSH
41075: CALL_OW 325
41079: NOT
41080: OR
41081: PUSH
41082: LD_EXP 101
41086: PUSH
41087: LD_VAR 0 2
41091: ARRAY
41092: OR
41093: IFFALSE 41097
// continue ;
41095: GO 41014
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41097: LD_ADDR_VAR 0 8
41101: PUSH
41102: LD_EXP 78
41106: PUSH
41107: LD_VAR 0 2
41111: ARRAY
41112: PPUSH
41113: LD_INT 25
41115: PUSH
41116: LD_INT 4
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: LD_INT 50
41125: PUSH
41126: EMPTY
41127: LIST
41128: PUSH
41129: LD_INT 3
41131: PUSH
41132: LD_INT 60
41134: PUSH
41135: EMPTY
41136: LIST
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: EMPTY
41143: LIST
41144: LIST
41145: LIST
41146: PPUSH
41147: CALL_OW 72
41151: PUSH
41152: LD_EXP 82
41156: PUSH
41157: LD_VAR 0 2
41161: ARRAY
41162: DIFF
41163: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41164: LD_ADDR_VAR 0 9
41168: PUSH
41169: LD_EXP 78
41173: PUSH
41174: LD_VAR 0 2
41178: ARRAY
41179: PPUSH
41180: LD_INT 2
41182: PUSH
41183: LD_INT 30
41185: PUSH
41186: LD_INT 0
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: PUSH
41193: LD_INT 30
41195: PUSH
41196: LD_INT 1
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: LIST
41207: PPUSH
41208: CALL_OW 72
41212: ST_TO_ADDR
// if not tmp or not dep then
41213: LD_VAR 0 8
41217: NOT
41218: PUSH
41219: LD_VAR 0 9
41223: NOT
41224: OR
41225: IFFALSE 41229
// continue ;
41227: GO 41014
// side := GetSide ( tmp [ 1 ] ) ;
41229: LD_ADDR_VAR 0 11
41233: PUSH
41234: LD_VAR 0 8
41238: PUSH
41239: LD_INT 1
41241: ARRAY
41242: PPUSH
41243: CALL_OW 255
41247: ST_TO_ADDR
// dep := dep [ 1 ] ;
41248: LD_ADDR_VAR 0 9
41252: PUSH
41253: LD_VAR 0 9
41257: PUSH
41258: LD_INT 1
41260: ARRAY
41261: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
41262: LD_ADDR_VAR 0 7
41266: PUSH
41267: LD_EXP 106
41271: PUSH
41272: LD_VAR 0 2
41276: ARRAY
41277: PPUSH
41278: LD_INT 22
41280: PUSH
41281: LD_INT 0
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PUSH
41288: LD_INT 25
41290: PUSH
41291: LD_INT 12
41293: PUSH
41294: EMPTY
41295: LIST
41296: LIST
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PPUSH
41302: CALL_OW 70
41306: PUSH
41307: LD_INT 22
41309: PUSH
41310: LD_INT 0
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 25
41319: PUSH
41320: LD_INT 12
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 91
41329: PUSH
41330: LD_VAR 0 9
41334: PUSH
41335: LD_INT 20
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: LIST
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: LIST
41347: PPUSH
41348: CALL_OW 69
41352: UNION
41353: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
41354: LD_ADDR_VAR 0 10
41358: PUSH
41359: LD_EXP 106
41363: PUSH
41364: LD_VAR 0 2
41368: ARRAY
41369: PPUSH
41370: LD_INT 81
41372: PUSH
41373: LD_VAR 0 11
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: PPUSH
41382: CALL_OW 70
41386: ST_TO_ADDR
// if not apes or danger_at_area then
41387: LD_VAR 0 7
41391: NOT
41392: PUSH
41393: LD_VAR 0 10
41397: OR
41398: IFFALSE 41448
// begin if mc_taming [ i ] then
41400: LD_EXP 109
41404: PUSH
41405: LD_VAR 0 2
41409: ARRAY
41410: IFFALSE 41446
// begin MC_Reset ( i , 121 ) ;
41412: LD_VAR 0 2
41416: PPUSH
41417: LD_INT 121
41419: PPUSH
41420: CALL 26364 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41424: LD_ADDR_EXP 109
41428: PUSH
41429: LD_EXP 109
41433: PPUSH
41434: LD_VAR 0 2
41438: PPUSH
41439: EMPTY
41440: PPUSH
41441: CALL_OW 1
41445: ST_TO_ADDR
// end ; continue ;
41446: GO 41014
// end ; for j in tmp do
41448: LD_ADDR_VAR 0 3
41452: PUSH
41453: LD_VAR 0 8
41457: PUSH
41458: FOR_IN
41459: IFFALSE 41795
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
41461: LD_VAR 0 3
41465: PUSH
41466: LD_EXP 109
41470: PUSH
41471: LD_VAR 0 2
41475: ARRAY
41476: IN
41477: NOT
41478: PUSH
41479: LD_EXP 109
41483: PUSH
41484: LD_VAR 0 2
41488: ARRAY
41489: PUSH
41490: LD_INT 3
41492: LESS
41493: AND
41494: IFFALSE 41552
// begin SetTag ( j , 121 ) ;
41496: LD_VAR 0 3
41500: PPUSH
41501: LD_INT 121
41503: PPUSH
41504: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
41508: LD_ADDR_EXP 109
41512: PUSH
41513: LD_EXP 109
41517: PPUSH
41518: LD_VAR 0 2
41522: PUSH
41523: LD_EXP 109
41527: PUSH
41528: LD_VAR 0 2
41532: ARRAY
41533: PUSH
41534: LD_INT 1
41536: PLUS
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PPUSH
41542: LD_VAR 0 3
41546: PPUSH
41547: CALL 57865 0 3
41551: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
41552: LD_VAR 0 3
41556: PUSH
41557: LD_EXP 109
41561: PUSH
41562: LD_VAR 0 2
41566: ARRAY
41567: IN
41568: IFFALSE 41793
// begin if GetClass ( j ) <> 4 then
41570: LD_VAR 0 3
41574: PPUSH
41575: CALL_OW 257
41579: PUSH
41580: LD_INT 4
41582: NONEQUAL
41583: IFFALSE 41636
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
41585: LD_ADDR_EXP 109
41589: PUSH
41590: LD_EXP 109
41594: PPUSH
41595: LD_VAR 0 2
41599: PPUSH
41600: LD_EXP 109
41604: PUSH
41605: LD_VAR 0 2
41609: ARRAY
41610: PUSH
41611: LD_VAR 0 3
41615: DIFF
41616: PPUSH
41617: CALL_OW 1
41621: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41622: LD_VAR 0 3
41626: PPUSH
41627: LD_INT 0
41629: PPUSH
41630: CALL_OW 109
// continue ;
41634: GO 41458
// end ; if IsInUnit ( j ) then
41636: LD_VAR 0 3
41640: PPUSH
41641: CALL_OW 310
41645: IFFALSE 41656
// ComExitBuilding ( j ) ;
41647: LD_VAR 0 3
41651: PPUSH
41652: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
41656: LD_ADDR_VAR 0 6
41660: PUSH
41661: LD_VAR 0 7
41665: PPUSH
41666: LD_VAR 0 3
41670: PPUSH
41671: CALL_OW 74
41675: ST_TO_ADDR
// if not ape then
41676: LD_VAR 0 6
41680: NOT
41681: IFFALSE 41685
// break ;
41683: GO 41795
// x := GetX ( ape ) ;
41685: LD_ADDR_VAR 0 4
41689: PUSH
41690: LD_VAR 0 6
41694: PPUSH
41695: CALL_OW 250
41699: ST_TO_ADDR
// y := GetY ( ape ) ;
41700: LD_ADDR_VAR 0 5
41704: PUSH
41705: LD_VAR 0 6
41709: PPUSH
41710: CALL_OW 251
41714: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
41715: LD_VAR 0 4
41719: PPUSH
41720: LD_VAR 0 5
41724: PPUSH
41725: CALL_OW 488
41729: NOT
41730: PUSH
41731: LD_VAR 0 11
41735: PPUSH
41736: LD_VAR 0 4
41740: PPUSH
41741: LD_VAR 0 5
41745: PPUSH
41746: LD_INT 20
41748: PPUSH
41749: CALL 59129 0 4
41753: PUSH
41754: LD_INT 4
41756: ARRAY
41757: OR
41758: IFFALSE 41762
// break ;
41760: GO 41795
// if not HasTask ( j ) then
41762: LD_VAR 0 3
41766: PPUSH
41767: CALL_OW 314
41771: NOT
41772: IFFALSE 41793
// ComTameXY ( j , x , y ) ;
41774: LD_VAR 0 3
41778: PPUSH
41779: LD_VAR 0 4
41783: PPUSH
41784: LD_VAR 0 5
41788: PPUSH
41789: CALL_OW 131
// end ; end ;
41793: GO 41458
41795: POP
41796: POP
// end ;
41797: GO 41014
41799: POP
41800: POP
// end ;
41801: LD_VAR 0 1
41805: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
41806: LD_INT 0
41808: PPUSH
41809: PPUSH
41810: PPUSH
41811: PPUSH
41812: PPUSH
41813: PPUSH
41814: PPUSH
41815: PPUSH
// if not mc_bases then
41816: LD_EXP 78
41820: NOT
41821: IFFALSE 41825
// exit ;
41823: GO 42451
// for i = 1 to mc_bases do
41825: LD_ADDR_VAR 0 2
41829: PUSH
41830: DOUBLE
41831: LD_INT 1
41833: DEC
41834: ST_TO_ADDR
41835: LD_EXP 78
41839: PUSH
41840: FOR_TO
41841: IFFALSE 42449
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
41843: LD_EXP 107
41847: PUSH
41848: LD_VAR 0 2
41852: ARRAY
41853: NOT
41854: PUSH
41855: LD_EXP 107
41859: PUSH
41860: LD_VAR 0 2
41864: ARRAY
41865: PPUSH
41866: LD_INT 25
41868: PUSH
41869: LD_INT 12
41871: PUSH
41872: EMPTY
41873: LIST
41874: LIST
41875: PPUSH
41876: CALL_OW 72
41880: NOT
41881: OR
41882: IFFALSE 41886
// continue ;
41884: GO 41840
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41886: LD_ADDR_VAR 0 5
41890: PUSH
41891: LD_EXP 107
41895: PUSH
41896: LD_VAR 0 2
41900: ARRAY
41901: PUSH
41902: LD_INT 1
41904: ARRAY
41905: PPUSH
41906: CALL_OW 255
41910: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41911: LD_VAR 0 5
41915: PPUSH
41916: LD_INT 2
41918: PPUSH
41919: CALL_OW 325
41923: IFFALSE 42176
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41925: LD_ADDR_VAR 0 4
41929: PUSH
41930: LD_EXP 107
41934: PUSH
41935: LD_VAR 0 2
41939: ARRAY
41940: PPUSH
41941: LD_INT 25
41943: PUSH
41944: LD_INT 16
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PPUSH
41951: CALL_OW 72
41955: ST_TO_ADDR
// if tmp < 6 then
41956: LD_VAR 0 4
41960: PUSH
41961: LD_INT 6
41963: LESS
41964: IFFALSE 42176
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41966: LD_ADDR_VAR 0 6
41970: PUSH
41971: LD_EXP 78
41975: PUSH
41976: LD_VAR 0 2
41980: ARRAY
41981: PPUSH
41982: LD_INT 2
41984: PUSH
41985: LD_INT 30
41987: PUSH
41988: LD_INT 0
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: PUSH
41995: LD_INT 30
41997: PUSH
41998: LD_INT 1
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: LIST
42009: PPUSH
42010: CALL_OW 72
42014: ST_TO_ADDR
// if depot then
42015: LD_VAR 0 6
42019: IFFALSE 42176
// begin selected := 0 ;
42021: LD_ADDR_VAR 0 7
42025: PUSH
42026: LD_INT 0
42028: ST_TO_ADDR
// for j in depot do
42029: LD_ADDR_VAR 0 3
42033: PUSH
42034: LD_VAR 0 6
42038: PUSH
42039: FOR_IN
42040: IFFALSE 42071
// begin if UnitsInside ( j ) < 6 then
42042: LD_VAR 0 3
42046: PPUSH
42047: CALL_OW 313
42051: PUSH
42052: LD_INT 6
42054: LESS
42055: IFFALSE 42069
// begin selected := j ;
42057: LD_ADDR_VAR 0 7
42061: PUSH
42062: LD_VAR 0 3
42066: ST_TO_ADDR
// break ;
42067: GO 42071
// end ; end ;
42069: GO 42039
42071: POP
42072: POP
// if selected then
42073: LD_VAR 0 7
42077: IFFALSE 42176
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42079: LD_ADDR_VAR 0 3
42083: PUSH
42084: LD_EXP 107
42088: PUSH
42089: LD_VAR 0 2
42093: ARRAY
42094: PPUSH
42095: LD_INT 25
42097: PUSH
42098: LD_INT 12
42100: PUSH
42101: EMPTY
42102: LIST
42103: LIST
42104: PPUSH
42105: CALL_OW 72
42109: PUSH
42110: FOR_IN
42111: IFFALSE 42174
// if not HasTask ( j ) then
42113: LD_VAR 0 3
42117: PPUSH
42118: CALL_OW 314
42122: NOT
42123: IFFALSE 42172
// begin if not IsInUnit ( j ) then
42125: LD_VAR 0 3
42129: PPUSH
42130: CALL_OW 310
42134: NOT
42135: IFFALSE 42151
// ComEnterUnit ( j , selected ) ;
42137: LD_VAR 0 3
42141: PPUSH
42142: LD_VAR 0 7
42146: PPUSH
42147: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42151: LD_VAR 0 3
42155: PPUSH
42156: LD_INT 16
42158: PPUSH
42159: CALL_OW 183
// AddComExitBuilding ( j ) ;
42163: LD_VAR 0 3
42167: PPUSH
42168: CALL_OW 182
// end ;
42172: GO 42110
42174: POP
42175: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
42176: LD_VAR 0 5
42180: PPUSH
42181: LD_INT 11
42183: PPUSH
42184: CALL_OW 325
42188: IFFALSE 42447
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42190: LD_ADDR_VAR 0 4
42194: PUSH
42195: LD_EXP 107
42199: PUSH
42200: LD_VAR 0 2
42204: ARRAY
42205: PPUSH
42206: LD_INT 25
42208: PUSH
42209: LD_INT 16
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PPUSH
42216: CALL_OW 72
42220: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
42221: LD_VAR 0 4
42225: PUSH
42226: LD_INT 6
42228: GREATEREQUAL
42229: PUSH
42230: LD_VAR 0 5
42234: PPUSH
42235: LD_INT 2
42237: PPUSH
42238: CALL_OW 325
42242: NOT
42243: OR
42244: IFFALSE 42447
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42246: LD_ADDR_VAR 0 8
42250: PUSH
42251: LD_EXP 78
42255: PUSH
42256: LD_VAR 0 2
42260: ARRAY
42261: PPUSH
42262: LD_INT 2
42264: PUSH
42265: LD_INT 30
42267: PUSH
42268: LD_INT 4
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 30
42277: PUSH
42278: LD_INT 5
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: LIST
42289: PPUSH
42290: CALL_OW 72
42294: ST_TO_ADDR
// if barracks then
42295: LD_VAR 0 8
42299: IFFALSE 42447
// begin selected := 0 ;
42301: LD_ADDR_VAR 0 7
42305: PUSH
42306: LD_INT 0
42308: ST_TO_ADDR
// for j in barracks do
42309: LD_ADDR_VAR 0 3
42313: PUSH
42314: LD_VAR 0 8
42318: PUSH
42319: FOR_IN
42320: IFFALSE 42351
// begin if UnitsInside ( j ) < 6 then
42322: LD_VAR 0 3
42326: PPUSH
42327: CALL_OW 313
42331: PUSH
42332: LD_INT 6
42334: LESS
42335: IFFALSE 42349
// begin selected := j ;
42337: LD_ADDR_VAR 0 7
42341: PUSH
42342: LD_VAR 0 3
42346: ST_TO_ADDR
// break ;
42347: GO 42351
// end ; end ;
42349: GO 42319
42351: POP
42352: POP
// if selected then
42353: LD_VAR 0 7
42357: IFFALSE 42447
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42359: LD_ADDR_VAR 0 3
42363: PUSH
42364: LD_EXP 107
42368: PUSH
42369: LD_VAR 0 2
42373: ARRAY
42374: PPUSH
42375: LD_INT 25
42377: PUSH
42378: LD_INT 12
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PPUSH
42385: CALL_OW 72
42389: PUSH
42390: FOR_IN
42391: IFFALSE 42445
// if not IsInUnit ( j ) and not HasTask ( j ) then
42393: LD_VAR 0 3
42397: PPUSH
42398: CALL_OW 310
42402: NOT
42403: PUSH
42404: LD_VAR 0 3
42408: PPUSH
42409: CALL_OW 314
42413: NOT
42414: AND
42415: IFFALSE 42443
// begin ComEnterUnit ( j , selected ) ;
42417: LD_VAR 0 3
42421: PPUSH
42422: LD_VAR 0 7
42426: PPUSH
42427: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
42431: LD_VAR 0 3
42435: PPUSH
42436: LD_INT 15
42438: PPUSH
42439: CALL_OW 183
// end ;
42443: GO 42390
42445: POP
42446: POP
// end ; end ; end ; end ; end ;
42447: GO 41840
42449: POP
42450: POP
// end ;
42451: LD_VAR 0 1
42455: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
42456: LD_INT 0
42458: PPUSH
42459: PPUSH
42460: PPUSH
42461: PPUSH
// if not mc_bases then
42462: LD_EXP 78
42466: NOT
42467: IFFALSE 42471
// exit ;
42469: GO 42649
// for i = 1 to mc_bases do
42471: LD_ADDR_VAR 0 2
42475: PUSH
42476: DOUBLE
42477: LD_INT 1
42479: DEC
42480: ST_TO_ADDR
42481: LD_EXP 78
42485: PUSH
42486: FOR_TO
42487: IFFALSE 42647
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
42489: LD_ADDR_VAR 0 4
42493: PUSH
42494: LD_EXP 78
42498: PUSH
42499: LD_VAR 0 2
42503: ARRAY
42504: PPUSH
42505: LD_INT 25
42507: PUSH
42508: LD_INT 9
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PPUSH
42515: CALL_OW 72
42519: ST_TO_ADDR
// if not tmp then
42520: LD_VAR 0 4
42524: NOT
42525: IFFALSE 42529
// continue ;
42527: GO 42486
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
42529: LD_EXP 104
42533: PUSH
42534: LD_VAR 0 2
42538: ARRAY
42539: PPUSH
42540: LD_INT 29
42542: PPUSH
42543: CALL_OW 325
42547: NOT
42548: PUSH
42549: LD_EXP 104
42553: PUSH
42554: LD_VAR 0 2
42558: ARRAY
42559: PPUSH
42560: LD_INT 28
42562: PPUSH
42563: CALL_OW 325
42567: NOT
42568: AND
42569: IFFALSE 42573
// continue ;
42571: GO 42486
// for j in tmp do
42573: LD_ADDR_VAR 0 3
42577: PUSH
42578: LD_VAR 0 4
42582: PUSH
42583: FOR_IN
42584: IFFALSE 42643
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
42586: LD_VAR 0 3
42590: PUSH
42591: LD_EXP 81
42595: PUSH
42596: LD_VAR 0 2
42600: ARRAY
42601: PUSH
42602: LD_INT 1
42604: ARRAY
42605: IN
42606: NOT
42607: PUSH
42608: LD_VAR 0 3
42612: PUSH
42613: LD_EXP 81
42617: PUSH
42618: LD_VAR 0 2
42622: ARRAY
42623: PUSH
42624: LD_INT 2
42626: ARRAY
42627: IN
42628: NOT
42629: AND
42630: IFFALSE 42641
// ComSpaceTimeShoot ( j ) ;
42632: LD_VAR 0 3
42636: PPUSH
42637: CALL 53850 0 1
42641: GO 42583
42643: POP
42644: POP
// end ;
42645: GO 42486
42647: POP
42648: POP
// end ;
42649: LD_VAR 0 1
42653: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
42654: LD_INT 0
42656: PPUSH
42657: PPUSH
42658: PPUSH
42659: PPUSH
42660: PPUSH
42661: PPUSH
42662: PPUSH
42663: PPUSH
42664: PPUSH
// if not mc_bases then
42665: LD_EXP 78
42669: NOT
42670: IFFALSE 42674
// exit ;
42672: GO 43296
// for i = 1 to mc_bases do
42674: LD_ADDR_VAR 0 2
42678: PUSH
42679: DOUBLE
42680: LD_INT 1
42682: DEC
42683: ST_TO_ADDR
42684: LD_EXP 78
42688: PUSH
42689: FOR_TO
42690: IFFALSE 43294
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
42692: LD_EXP 113
42696: PUSH
42697: LD_VAR 0 2
42701: ARRAY
42702: NOT
42703: PUSH
42704: LD_INT 38
42706: PPUSH
42707: LD_EXP 104
42711: PUSH
42712: LD_VAR 0 2
42716: ARRAY
42717: PPUSH
42718: CALL_OW 321
42722: PUSH
42723: LD_INT 2
42725: NONEQUAL
42726: OR
42727: IFFALSE 42731
// continue ;
42729: GO 42689
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
42731: LD_ADDR_VAR 0 8
42735: PUSH
42736: LD_EXP 78
42740: PUSH
42741: LD_VAR 0 2
42745: ARRAY
42746: PPUSH
42747: LD_INT 30
42749: PUSH
42750: LD_INT 34
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PPUSH
42757: CALL_OW 72
42761: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
42762: LD_ADDR_VAR 0 9
42766: PUSH
42767: LD_EXP 78
42771: PUSH
42772: LD_VAR 0 2
42776: ARRAY
42777: PPUSH
42778: LD_INT 25
42780: PUSH
42781: LD_INT 4
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PPUSH
42788: CALL_OW 72
42792: PPUSH
42793: LD_INT 0
42795: PPUSH
42796: CALL 88174 0 2
42800: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
42801: LD_VAR 0 9
42805: NOT
42806: PUSH
42807: LD_VAR 0 8
42811: NOT
42812: OR
42813: PUSH
42814: LD_EXP 78
42818: PUSH
42819: LD_VAR 0 2
42823: ARRAY
42824: PPUSH
42825: LD_INT 124
42827: PPUSH
42828: CALL 88174 0 2
42832: OR
42833: IFFALSE 42837
// continue ;
42835: GO 42689
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
42837: LD_EXP 114
42841: PUSH
42842: LD_VAR 0 2
42846: ARRAY
42847: PUSH
42848: LD_EXP 113
42852: PUSH
42853: LD_VAR 0 2
42857: ARRAY
42858: LESS
42859: PUSH
42860: LD_EXP 114
42864: PUSH
42865: LD_VAR 0 2
42869: ARRAY
42870: PUSH
42871: LD_VAR 0 8
42875: LESS
42876: AND
42877: IFFALSE 43292
// begin tmp := sci [ 1 ] ;
42879: LD_ADDR_VAR 0 7
42883: PUSH
42884: LD_VAR 0 9
42888: PUSH
42889: LD_INT 1
42891: ARRAY
42892: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42893: LD_VAR 0 7
42897: PPUSH
42898: LD_INT 124
42900: PPUSH
42901: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42905: LD_ADDR_VAR 0 3
42909: PUSH
42910: DOUBLE
42911: LD_EXP 113
42915: PUSH
42916: LD_VAR 0 2
42920: ARRAY
42921: INC
42922: ST_TO_ADDR
42923: LD_EXP 113
42927: PUSH
42928: LD_VAR 0 2
42932: ARRAY
42933: PUSH
42934: FOR_DOWNTO
42935: IFFALSE 43278
// begin if IsInUnit ( tmp ) then
42937: LD_VAR 0 7
42941: PPUSH
42942: CALL_OW 310
42946: IFFALSE 42957
// ComExitBuilding ( tmp ) ;
42948: LD_VAR 0 7
42952: PPUSH
42953: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42957: LD_INT 35
42959: PPUSH
42960: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42964: LD_VAR 0 7
42968: PPUSH
42969: CALL_OW 310
42973: NOT
42974: PUSH
42975: LD_VAR 0 7
42979: PPUSH
42980: CALL_OW 314
42984: NOT
42985: AND
42986: IFFALSE 42957
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42988: LD_ADDR_VAR 0 6
42992: PUSH
42993: LD_VAR 0 7
42997: PPUSH
42998: CALL_OW 250
43002: PUSH
43003: LD_VAR 0 7
43007: PPUSH
43008: CALL_OW 251
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
43017: LD_INT 35
43019: PPUSH
43020: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
43024: LD_ADDR_VAR 0 4
43028: PUSH
43029: LD_EXP 113
43033: PUSH
43034: LD_VAR 0 2
43038: ARRAY
43039: PUSH
43040: LD_VAR 0 3
43044: ARRAY
43045: PUSH
43046: LD_INT 1
43048: ARRAY
43049: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
43050: LD_ADDR_VAR 0 5
43054: PUSH
43055: LD_EXP 113
43059: PUSH
43060: LD_VAR 0 2
43064: ARRAY
43065: PUSH
43066: LD_VAR 0 3
43070: ARRAY
43071: PUSH
43072: LD_INT 2
43074: ARRAY
43075: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
43076: LD_VAR 0 7
43080: PPUSH
43081: LD_INT 10
43083: PPUSH
43084: CALL 60830 0 2
43088: PUSH
43089: LD_INT 4
43091: ARRAY
43092: IFFALSE 43130
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43094: LD_VAR 0 7
43098: PPUSH
43099: LD_VAR 0 6
43103: PUSH
43104: LD_INT 1
43106: ARRAY
43107: PPUSH
43108: LD_VAR 0 6
43112: PUSH
43113: LD_INT 2
43115: ARRAY
43116: PPUSH
43117: CALL_OW 111
// wait ( 0 0$10 ) ;
43121: LD_INT 350
43123: PPUSH
43124: CALL_OW 67
// end else
43128: GO 43156
// begin ComMoveXY ( tmp , x , y ) ;
43130: LD_VAR 0 7
43134: PPUSH
43135: LD_VAR 0 4
43139: PPUSH
43140: LD_VAR 0 5
43144: PPUSH
43145: CALL_OW 111
// wait ( 0 0$3 ) ;
43149: LD_INT 105
43151: PPUSH
43152: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43156: LD_VAR 0 7
43160: PPUSH
43161: LD_VAR 0 4
43165: PPUSH
43166: LD_VAR 0 5
43170: PPUSH
43171: CALL_OW 307
43175: IFFALSE 43017
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
43177: LD_VAR 0 7
43181: PPUSH
43182: LD_VAR 0 4
43186: PPUSH
43187: LD_VAR 0 5
43191: PPUSH
43192: LD_VAR 0 8
43196: PUSH
43197: LD_VAR 0 3
43201: ARRAY
43202: PPUSH
43203: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
43207: LD_INT 35
43209: PPUSH
43210: CALL_OW 67
// until not HasTask ( tmp ) ;
43214: LD_VAR 0 7
43218: PPUSH
43219: CALL_OW 314
43223: NOT
43224: IFFALSE 43207
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
43226: LD_ADDR_EXP 114
43230: PUSH
43231: LD_EXP 114
43235: PPUSH
43236: LD_VAR 0 2
43240: PUSH
43241: LD_EXP 114
43245: PUSH
43246: LD_VAR 0 2
43250: ARRAY
43251: PUSH
43252: LD_INT 1
43254: PLUS
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PPUSH
43260: LD_VAR 0 8
43264: PUSH
43265: LD_VAR 0 3
43269: ARRAY
43270: PPUSH
43271: CALL 57865 0 3
43275: ST_TO_ADDR
// end ;
43276: GO 42934
43278: POP
43279: POP
// MC_Reset ( i , 124 ) ;
43280: LD_VAR 0 2
43284: PPUSH
43285: LD_INT 124
43287: PPUSH
43288: CALL 26364 0 2
// end ; end ;
43292: GO 42689
43294: POP
43295: POP
// end ;
43296: LD_VAR 0 1
43300: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
43301: LD_INT 0
43303: PPUSH
43304: PPUSH
43305: PPUSH
// if not mc_bases then
43306: LD_EXP 78
43310: NOT
43311: IFFALSE 43315
// exit ;
43313: GO 43921
// for i = 1 to mc_bases do
43315: LD_ADDR_VAR 0 2
43319: PUSH
43320: DOUBLE
43321: LD_INT 1
43323: DEC
43324: ST_TO_ADDR
43325: LD_EXP 78
43329: PUSH
43330: FOR_TO
43331: IFFALSE 43919
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43333: LD_ADDR_VAR 0 3
43337: PUSH
43338: LD_EXP 78
43342: PUSH
43343: LD_VAR 0 2
43347: ARRAY
43348: PPUSH
43349: LD_INT 25
43351: PUSH
43352: LD_INT 4
43354: PUSH
43355: EMPTY
43356: LIST
43357: LIST
43358: PPUSH
43359: CALL_OW 72
43363: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43364: LD_VAR 0 3
43368: NOT
43369: PUSH
43370: LD_EXP 115
43374: PUSH
43375: LD_VAR 0 2
43379: ARRAY
43380: NOT
43381: OR
43382: PUSH
43383: LD_EXP 78
43387: PUSH
43388: LD_VAR 0 2
43392: ARRAY
43393: PPUSH
43394: LD_INT 2
43396: PUSH
43397: LD_INT 30
43399: PUSH
43400: LD_INT 0
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: LD_INT 30
43409: PUSH
43410: LD_INT 1
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: LIST
43421: PPUSH
43422: CALL_OW 72
43426: NOT
43427: OR
43428: IFFALSE 43478
// begin if mc_deposits_finder [ i ] then
43430: LD_EXP 116
43434: PUSH
43435: LD_VAR 0 2
43439: ARRAY
43440: IFFALSE 43476
// begin MC_Reset ( i , 125 ) ;
43442: LD_VAR 0 2
43446: PPUSH
43447: LD_INT 125
43449: PPUSH
43450: CALL 26364 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43454: LD_ADDR_EXP 116
43458: PUSH
43459: LD_EXP 116
43463: PPUSH
43464: LD_VAR 0 2
43468: PPUSH
43469: EMPTY
43470: PPUSH
43471: CALL_OW 1
43475: ST_TO_ADDR
// end ; continue ;
43476: GO 43330
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
43478: LD_EXP 115
43482: PUSH
43483: LD_VAR 0 2
43487: ARRAY
43488: PUSH
43489: LD_INT 1
43491: ARRAY
43492: PUSH
43493: LD_INT 3
43495: ARRAY
43496: PUSH
43497: LD_INT 1
43499: EQUAL
43500: PUSH
43501: LD_INT 20
43503: PPUSH
43504: LD_EXP 104
43508: PUSH
43509: LD_VAR 0 2
43513: ARRAY
43514: PPUSH
43515: CALL_OW 321
43519: PUSH
43520: LD_INT 2
43522: NONEQUAL
43523: AND
43524: IFFALSE 43574
// begin if mc_deposits_finder [ i ] then
43526: LD_EXP 116
43530: PUSH
43531: LD_VAR 0 2
43535: ARRAY
43536: IFFALSE 43572
// begin MC_Reset ( i , 125 ) ;
43538: LD_VAR 0 2
43542: PPUSH
43543: LD_INT 125
43545: PPUSH
43546: CALL 26364 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43550: LD_ADDR_EXP 116
43554: PUSH
43555: LD_EXP 116
43559: PPUSH
43560: LD_VAR 0 2
43564: PPUSH
43565: EMPTY
43566: PPUSH
43567: CALL_OW 1
43571: ST_TO_ADDR
// end ; continue ;
43572: GO 43330
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
43574: LD_EXP 115
43578: PUSH
43579: LD_VAR 0 2
43583: ARRAY
43584: PUSH
43585: LD_INT 1
43587: ARRAY
43588: PUSH
43589: LD_INT 1
43591: ARRAY
43592: PPUSH
43593: LD_EXP 115
43597: PUSH
43598: LD_VAR 0 2
43602: ARRAY
43603: PUSH
43604: LD_INT 1
43606: ARRAY
43607: PUSH
43608: LD_INT 2
43610: ARRAY
43611: PPUSH
43612: LD_EXP 104
43616: PUSH
43617: LD_VAR 0 2
43621: ARRAY
43622: PPUSH
43623: CALL_OW 440
43627: IFFALSE 43670
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
43629: LD_ADDR_EXP 115
43633: PUSH
43634: LD_EXP 115
43638: PPUSH
43639: LD_VAR 0 2
43643: PPUSH
43644: LD_EXP 115
43648: PUSH
43649: LD_VAR 0 2
43653: ARRAY
43654: PPUSH
43655: LD_INT 1
43657: PPUSH
43658: CALL_OW 3
43662: PPUSH
43663: CALL_OW 1
43667: ST_TO_ADDR
43668: GO 43917
// begin if not mc_deposits_finder [ i ] then
43670: LD_EXP 116
43674: PUSH
43675: LD_VAR 0 2
43679: ARRAY
43680: NOT
43681: IFFALSE 43733
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
43683: LD_ADDR_EXP 116
43687: PUSH
43688: LD_EXP 116
43692: PPUSH
43693: LD_VAR 0 2
43697: PPUSH
43698: LD_VAR 0 3
43702: PUSH
43703: LD_INT 1
43705: ARRAY
43706: PUSH
43707: EMPTY
43708: LIST
43709: PPUSH
43710: CALL_OW 1
43714: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
43715: LD_VAR 0 3
43719: PUSH
43720: LD_INT 1
43722: ARRAY
43723: PPUSH
43724: LD_INT 125
43726: PPUSH
43727: CALL_OW 109
// end else
43731: GO 43917
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
43733: LD_EXP 116
43737: PUSH
43738: LD_VAR 0 2
43742: ARRAY
43743: PUSH
43744: LD_INT 1
43746: ARRAY
43747: PPUSH
43748: CALL_OW 310
43752: IFFALSE 43775
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
43754: LD_EXP 116
43758: PUSH
43759: LD_VAR 0 2
43763: ARRAY
43764: PUSH
43765: LD_INT 1
43767: ARRAY
43768: PPUSH
43769: CALL_OW 122
43773: GO 43917
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
43775: LD_EXP 116
43779: PUSH
43780: LD_VAR 0 2
43784: ARRAY
43785: PUSH
43786: LD_INT 1
43788: ARRAY
43789: PPUSH
43790: CALL_OW 314
43794: NOT
43795: PUSH
43796: LD_EXP 116
43800: PUSH
43801: LD_VAR 0 2
43805: ARRAY
43806: PUSH
43807: LD_INT 1
43809: ARRAY
43810: PPUSH
43811: LD_EXP 115
43815: PUSH
43816: LD_VAR 0 2
43820: ARRAY
43821: PUSH
43822: LD_INT 1
43824: ARRAY
43825: PUSH
43826: LD_INT 1
43828: ARRAY
43829: PPUSH
43830: LD_EXP 115
43834: PUSH
43835: LD_VAR 0 2
43839: ARRAY
43840: PUSH
43841: LD_INT 1
43843: ARRAY
43844: PUSH
43845: LD_INT 2
43847: ARRAY
43848: PPUSH
43849: CALL_OW 297
43853: PUSH
43854: LD_INT 6
43856: GREATER
43857: AND
43858: IFFALSE 43917
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
43860: LD_EXP 116
43864: PUSH
43865: LD_VAR 0 2
43869: ARRAY
43870: PUSH
43871: LD_INT 1
43873: ARRAY
43874: PPUSH
43875: LD_EXP 115
43879: PUSH
43880: LD_VAR 0 2
43884: ARRAY
43885: PUSH
43886: LD_INT 1
43888: ARRAY
43889: PUSH
43890: LD_INT 1
43892: ARRAY
43893: PPUSH
43894: LD_EXP 115
43898: PUSH
43899: LD_VAR 0 2
43903: ARRAY
43904: PUSH
43905: LD_INT 1
43907: ARRAY
43908: PUSH
43909: LD_INT 2
43911: ARRAY
43912: PPUSH
43913: CALL_OW 111
// end ; end ; end ;
43917: GO 43330
43919: POP
43920: POP
// end ;
43921: LD_VAR 0 1
43925: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43926: LD_INT 0
43928: PPUSH
43929: PPUSH
43930: PPUSH
43931: PPUSH
43932: PPUSH
43933: PPUSH
43934: PPUSH
43935: PPUSH
43936: PPUSH
43937: PPUSH
43938: PPUSH
// if not mc_bases then
43939: LD_EXP 78
43943: NOT
43944: IFFALSE 43948
// exit ;
43946: GO 44888
// for i = 1 to mc_bases do
43948: LD_ADDR_VAR 0 2
43952: PUSH
43953: DOUBLE
43954: LD_INT 1
43956: DEC
43957: ST_TO_ADDR
43958: LD_EXP 78
43962: PUSH
43963: FOR_TO
43964: IFFALSE 44886
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43966: LD_EXP 78
43970: PUSH
43971: LD_VAR 0 2
43975: ARRAY
43976: NOT
43977: PUSH
43978: LD_EXP 101
43982: PUSH
43983: LD_VAR 0 2
43987: ARRAY
43988: OR
43989: IFFALSE 43993
// continue ;
43991: GO 43963
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43993: LD_ADDR_VAR 0 7
43997: PUSH
43998: LD_EXP 78
44002: PUSH
44003: LD_VAR 0 2
44007: ARRAY
44008: PUSH
44009: LD_INT 1
44011: ARRAY
44012: PPUSH
44013: CALL_OW 248
44017: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
44018: LD_VAR 0 7
44022: PUSH
44023: LD_INT 3
44025: EQUAL
44026: PUSH
44027: LD_EXP 97
44031: PUSH
44032: LD_VAR 0 2
44036: ARRAY
44037: PUSH
44038: LD_EXP 100
44042: PUSH
44043: LD_VAR 0 2
44047: ARRAY
44048: UNION
44049: PPUSH
44050: LD_INT 33
44052: PUSH
44053: LD_INT 2
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PPUSH
44060: CALL_OW 72
44064: NOT
44065: OR
44066: IFFALSE 44070
// continue ;
44068: GO 43963
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
44070: LD_ADDR_VAR 0 9
44074: PUSH
44075: LD_EXP 78
44079: PUSH
44080: LD_VAR 0 2
44084: ARRAY
44085: PPUSH
44086: LD_INT 30
44088: PUSH
44089: LD_INT 36
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PPUSH
44096: CALL_OW 72
44100: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44101: LD_ADDR_VAR 0 10
44105: PUSH
44106: LD_EXP 97
44110: PUSH
44111: LD_VAR 0 2
44115: ARRAY
44116: PPUSH
44117: LD_INT 34
44119: PUSH
44120: LD_INT 31
44122: PUSH
44123: EMPTY
44124: LIST
44125: LIST
44126: PPUSH
44127: CALL_OW 72
44131: ST_TO_ADDR
// if not cts and not mcts then
44132: LD_VAR 0 9
44136: NOT
44137: PUSH
44138: LD_VAR 0 10
44142: NOT
44143: AND
44144: IFFALSE 44148
// continue ;
44146: GO 43963
// x := cts ;
44148: LD_ADDR_VAR 0 11
44152: PUSH
44153: LD_VAR 0 9
44157: ST_TO_ADDR
// if not x then
44158: LD_VAR 0 11
44162: NOT
44163: IFFALSE 44175
// x := mcts ;
44165: LD_ADDR_VAR 0 11
44169: PUSH
44170: LD_VAR 0 10
44174: ST_TO_ADDR
// if not x then
44175: LD_VAR 0 11
44179: NOT
44180: IFFALSE 44184
// continue ;
44182: GO 43963
// if mc_remote_driver [ i ] then
44184: LD_EXP 118
44188: PUSH
44189: LD_VAR 0 2
44193: ARRAY
44194: IFFALSE 44581
// for j in mc_remote_driver [ i ] do
44196: LD_ADDR_VAR 0 3
44200: PUSH
44201: LD_EXP 118
44205: PUSH
44206: LD_VAR 0 2
44210: ARRAY
44211: PUSH
44212: FOR_IN
44213: IFFALSE 44579
// begin if GetClass ( j ) <> 3 then
44215: LD_VAR 0 3
44219: PPUSH
44220: CALL_OW 257
44224: PUSH
44225: LD_INT 3
44227: NONEQUAL
44228: IFFALSE 44281
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
44230: LD_ADDR_EXP 118
44234: PUSH
44235: LD_EXP 118
44239: PPUSH
44240: LD_VAR 0 2
44244: PPUSH
44245: LD_EXP 118
44249: PUSH
44250: LD_VAR 0 2
44254: ARRAY
44255: PUSH
44256: LD_VAR 0 3
44260: DIFF
44261: PPUSH
44262: CALL_OW 1
44266: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44267: LD_VAR 0 3
44271: PPUSH
44272: LD_INT 0
44274: PPUSH
44275: CALL_OW 109
// continue ;
44279: GO 44212
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
44281: LD_EXP 97
44285: PUSH
44286: LD_VAR 0 2
44290: ARRAY
44291: PPUSH
44292: LD_INT 34
44294: PUSH
44295: LD_INT 31
44297: PUSH
44298: EMPTY
44299: LIST
44300: LIST
44301: PUSH
44302: LD_INT 58
44304: PUSH
44305: EMPTY
44306: LIST
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PPUSH
44312: CALL_OW 72
44316: PUSH
44317: LD_VAR 0 3
44321: PPUSH
44322: CALL 88209 0 1
44326: NOT
44327: AND
44328: IFFALSE 44399
// begin if IsInUnit ( j ) then
44330: LD_VAR 0 3
44334: PPUSH
44335: CALL_OW 310
44339: IFFALSE 44350
// ComExitBuilding ( j ) ;
44341: LD_VAR 0 3
44345: PPUSH
44346: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
44350: LD_VAR 0 3
44354: PPUSH
44355: LD_EXP 97
44359: PUSH
44360: LD_VAR 0 2
44364: ARRAY
44365: PPUSH
44366: LD_INT 34
44368: PUSH
44369: LD_INT 31
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: PUSH
44376: LD_INT 58
44378: PUSH
44379: EMPTY
44380: LIST
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PPUSH
44386: CALL_OW 72
44390: PUSH
44391: LD_INT 1
44393: ARRAY
44394: PPUSH
44395: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
44399: LD_VAR 0 3
44403: PPUSH
44404: CALL_OW 310
44408: NOT
44409: PUSH
44410: LD_VAR 0 3
44414: PPUSH
44415: CALL_OW 310
44419: PPUSH
44420: CALL_OW 266
44424: PUSH
44425: LD_INT 36
44427: NONEQUAL
44428: PUSH
44429: LD_VAR 0 3
44433: PPUSH
44434: CALL 88209 0 1
44438: NOT
44439: AND
44440: OR
44441: IFFALSE 44577
// begin if IsInUnit ( j ) then
44443: LD_VAR 0 3
44447: PPUSH
44448: CALL_OW 310
44452: IFFALSE 44463
// ComExitBuilding ( j ) ;
44454: LD_VAR 0 3
44458: PPUSH
44459: CALL_OW 122
// ct := 0 ;
44463: LD_ADDR_VAR 0 8
44467: PUSH
44468: LD_INT 0
44470: ST_TO_ADDR
// for k in x do
44471: LD_ADDR_VAR 0 4
44475: PUSH
44476: LD_VAR 0 11
44480: PUSH
44481: FOR_IN
44482: IFFALSE 44555
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
44484: LD_VAR 0 4
44488: PPUSH
44489: CALL_OW 264
44493: PUSH
44494: LD_INT 31
44496: EQUAL
44497: PUSH
44498: LD_VAR 0 4
44502: PPUSH
44503: CALL_OW 311
44507: NOT
44508: AND
44509: PUSH
44510: LD_VAR 0 4
44514: PPUSH
44515: CALL_OW 266
44519: PUSH
44520: LD_INT 36
44522: EQUAL
44523: PUSH
44524: LD_VAR 0 4
44528: PPUSH
44529: CALL_OW 313
44533: PUSH
44534: LD_INT 3
44536: LESS
44537: AND
44538: OR
44539: IFFALSE 44553
// begin ct := k ;
44541: LD_ADDR_VAR 0 8
44545: PUSH
44546: LD_VAR 0 4
44550: ST_TO_ADDR
// break ;
44551: GO 44555
// end ;
44553: GO 44481
44555: POP
44556: POP
// if ct then
44557: LD_VAR 0 8
44561: IFFALSE 44577
// ComEnterUnit ( j , ct ) ;
44563: LD_VAR 0 3
44567: PPUSH
44568: LD_VAR 0 8
44572: PPUSH
44573: CALL_OW 120
// end ; end ;
44577: GO 44212
44579: POP
44580: POP
// places := 0 ;
44581: LD_ADDR_VAR 0 5
44585: PUSH
44586: LD_INT 0
44588: ST_TO_ADDR
// for j = 1 to x do
44589: LD_ADDR_VAR 0 3
44593: PUSH
44594: DOUBLE
44595: LD_INT 1
44597: DEC
44598: ST_TO_ADDR
44599: LD_VAR 0 11
44603: PUSH
44604: FOR_TO
44605: IFFALSE 44681
// if GetWeapon ( x [ j ] ) = ar_control_tower then
44607: LD_VAR 0 11
44611: PUSH
44612: LD_VAR 0 3
44616: ARRAY
44617: PPUSH
44618: CALL_OW 264
44622: PUSH
44623: LD_INT 31
44625: EQUAL
44626: IFFALSE 44644
// places := places + 1 else
44628: LD_ADDR_VAR 0 5
44632: PUSH
44633: LD_VAR 0 5
44637: PUSH
44638: LD_INT 1
44640: PLUS
44641: ST_TO_ADDR
44642: GO 44679
// if GetBType ( x [ j ] ) = b_control_tower then
44644: LD_VAR 0 11
44648: PUSH
44649: LD_VAR 0 3
44653: ARRAY
44654: PPUSH
44655: CALL_OW 266
44659: PUSH
44660: LD_INT 36
44662: EQUAL
44663: IFFALSE 44679
// places := places + 3 ;
44665: LD_ADDR_VAR 0 5
44669: PUSH
44670: LD_VAR 0 5
44674: PUSH
44675: LD_INT 3
44677: PLUS
44678: ST_TO_ADDR
44679: GO 44604
44681: POP
44682: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
44683: LD_VAR 0 5
44687: PUSH
44688: LD_INT 0
44690: EQUAL
44691: PUSH
44692: LD_VAR 0 5
44696: PUSH
44697: LD_EXP 118
44701: PUSH
44702: LD_VAR 0 2
44706: ARRAY
44707: LESSEQUAL
44708: OR
44709: IFFALSE 44713
// continue ;
44711: GO 43963
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
44713: LD_ADDR_VAR 0 6
44717: PUSH
44718: LD_EXP 78
44722: PUSH
44723: LD_VAR 0 2
44727: ARRAY
44728: PPUSH
44729: LD_INT 25
44731: PUSH
44732: LD_INT 3
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PPUSH
44739: CALL_OW 72
44743: PUSH
44744: LD_EXP 118
44748: PUSH
44749: LD_VAR 0 2
44753: ARRAY
44754: DIFF
44755: PPUSH
44756: LD_INT 3
44758: PPUSH
44759: CALL 89109 0 2
44763: ST_TO_ADDR
// for j in tmp do
44764: LD_ADDR_VAR 0 3
44768: PUSH
44769: LD_VAR 0 6
44773: PUSH
44774: FOR_IN
44775: IFFALSE 44810
// if GetTag ( j ) > 0 then
44777: LD_VAR 0 3
44781: PPUSH
44782: CALL_OW 110
44786: PUSH
44787: LD_INT 0
44789: GREATER
44790: IFFALSE 44808
// tmp := tmp diff j ;
44792: LD_ADDR_VAR 0 6
44796: PUSH
44797: LD_VAR 0 6
44801: PUSH
44802: LD_VAR 0 3
44806: DIFF
44807: ST_TO_ADDR
44808: GO 44774
44810: POP
44811: POP
// if not tmp then
44812: LD_VAR 0 6
44816: NOT
44817: IFFALSE 44821
// continue ;
44819: GO 43963
// if places then
44821: LD_VAR 0 5
44825: IFFALSE 44884
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
44827: LD_ADDR_EXP 118
44831: PUSH
44832: LD_EXP 118
44836: PPUSH
44837: LD_VAR 0 2
44841: PPUSH
44842: LD_EXP 118
44846: PUSH
44847: LD_VAR 0 2
44851: ARRAY
44852: PUSH
44853: LD_VAR 0 6
44857: PUSH
44858: LD_INT 1
44860: ARRAY
44861: UNION
44862: PPUSH
44863: CALL_OW 1
44867: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
44868: LD_VAR 0 6
44872: PUSH
44873: LD_INT 1
44875: ARRAY
44876: PPUSH
44877: LD_INT 126
44879: PPUSH
44880: CALL_OW 109
// end ; end ;
44884: GO 43963
44886: POP
44887: POP
// end ;
44888: LD_VAR 0 1
44892: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44893: LD_INT 0
44895: PPUSH
44896: PPUSH
44897: PPUSH
44898: PPUSH
44899: PPUSH
44900: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44901: LD_VAR 0 1
44905: NOT
44906: PUSH
44907: LD_VAR 0 2
44911: NOT
44912: OR
44913: PUSH
44914: LD_VAR 0 3
44918: NOT
44919: OR
44920: PUSH
44921: LD_VAR 0 4
44925: PUSH
44926: LD_INT 1
44928: PUSH
44929: LD_INT 2
44931: PUSH
44932: LD_INT 3
44934: PUSH
44935: LD_INT 4
44937: PUSH
44938: LD_INT 5
44940: PUSH
44941: LD_INT 8
44943: PUSH
44944: LD_INT 9
44946: PUSH
44947: LD_INT 15
44949: PUSH
44950: LD_INT 16
44952: PUSH
44953: EMPTY
44954: LIST
44955: LIST
44956: LIST
44957: LIST
44958: LIST
44959: LIST
44960: LIST
44961: LIST
44962: LIST
44963: IN
44964: NOT
44965: OR
44966: IFFALSE 44970
// exit ;
44968: GO 45828
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44970: LD_ADDR_VAR 0 2
44974: PUSH
44975: LD_VAR 0 2
44979: PPUSH
44980: LD_INT 21
44982: PUSH
44983: LD_INT 3
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 24
44992: PUSH
44993: LD_INT 250
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: PPUSH
45004: CALL_OW 72
45008: ST_TO_ADDR
// case class of 1 , 15 :
45009: LD_VAR 0 4
45013: PUSH
45014: LD_INT 1
45016: DOUBLE
45017: EQUAL
45018: IFTRUE 45028
45020: LD_INT 15
45022: DOUBLE
45023: EQUAL
45024: IFTRUE 45028
45026: GO 45113
45028: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
45029: LD_ADDR_VAR 0 8
45033: PUSH
45034: LD_VAR 0 2
45038: PPUSH
45039: LD_INT 2
45041: PUSH
45042: LD_INT 30
45044: PUSH
45045: LD_INT 32
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 30
45054: PUSH
45055: LD_INT 31
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: LIST
45066: PPUSH
45067: CALL_OW 72
45071: PUSH
45072: LD_VAR 0 2
45076: PPUSH
45077: LD_INT 2
45079: PUSH
45080: LD_INT 30
45082: PUSH
45083: LD_INT 4
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PUSH
45090: LD_INT 30
45092: PUSH
45093: LD_INT 5
45095: PUSH
45096: EMPTY
45097: LIST
45098: LIST
45099: PUSH
45100: EMPTY
45101: LIST
45102: LIST
45103: LIST
45104: PPUSH
45105: CALL_OW 72
45109: ADD
45110: ST_TO_ADDR
45111: GO 45359
45113: LD_INT 2
45115: DOUBLE
45116: EQUAL
45117: IFTRUE 45127
45119: LD_INT 16
45121: DOUBLE
45122: EQUAL
45123: IFTRUE 45127
45125: GO 45173
45127: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45128: LD_ADDR_VAR 0 8
45132: PUSH
45133: LD_VAR 0 2
45137: PPUSH
45138: LD_INT 2
45140: PUSH
45141: LD_INT 30
45143: PUSH
45144: LD_INT 0
45146: PUSH
45147: EMPTY
45148: LIST
45149: LIST
45150: PUSH
45151: LD_INT 30
45153: PUSH
45154: LD_INT 1
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: PUSH
45161: EMPTY
45162: LIST
45163: LIST
45164: LIST
45165: PPUSH
45166: CALL_OW 72
45170: ST_TO_ADDR
45171: GO 45359
45173: LD_INT 3
45175: DOUBLE
45176: EQUAL
45177: IFTRUE 45181
45179: GO 45227
45181: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
45182: LD_ADDR_VAR 0 8
45186: PUSH
45187: LD_VAR 0 2
45191: PPUSH
45192: LD_INT 2
45194: PUSH
45195: LD_INT 30
45197: PUSH
45198: LD_INT 2
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: PUSH
45205: LD_INT 30
45207: PUSH
45208: LD_INT 3
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: LIST
45219: PPUSH
45220: CALL_OW 72
45224: ST_TO_ADDR
45225: GO 45359
45227: LD_INT 4
45229: DOUBLE
45230: EQUAL
45231: IFTRUE 45235
45233: GO 45292
45235: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
45236: LD_ADDR_VAR 0 8
45240: PUSH
45241: LD_VAR 0 2
45245: PPUSH
45246: LD_INT 2
45248: PUSH
45249: LD_INT 30
45251: PUSH
45252: LD_INT 6
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PUSH
45259: LD_INT 30
45261: PUSH
45262: LD_INT 7
45264: PUSH
45265: EMPTY
45266: LIST
45267: LIST
45268: PUSH
45269: LD_INT 30
45271: PUSH
45272: LD_INT 8
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: LIST
45283: LIST
45284: PPUSH
45285: CALL_OW 72
45289: ST_TO_ADDR
45290: GO 45359
45292: LD_INT 5
45294: DOUBLE
45295: EQUAL
45296: IFTRUE 45312
45298: LD_INT 8
45300: DOUBLE
45301: EQUAL
45302: IFTRUE 45312
45304: LD_INT 9
45306: DOUBLE
45307: EQUAL
45308: IFTRUE 45312
45310: GO 45358
45312: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
45313: LD_ADDR_VAR 0 8
45317: PUSH
45318: LD_VAR 0 2
45322: PPUSH
45323: LD_INT 2
45325: PUSH
45326: LD_INT 30
45328: PUSH
45329: LD_INT 4
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 30
45338: PUSH
45339: LD_INT 5
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: PUSH
45346: EMPTY
45347: LIST
45348: LIST
45349: LIST
45350: PPUSH
45351: CALL_OW 72
45355: ST_TO_ADDR
45356: GO 45359
45358: POP
// if not tmp then
45359: LD_VAR 0 8
45363: NOT
45364: IFFALSE 45368
// exit ;
45366: GO 45828
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
45368: LD_VAR 0 4
45372: PUSH
45373: LD_INT 1
45375: PUSH
45376: LD_INT 15
45378: PUSH
45379: EMPTY
45380: LIST
45381: LIST
45382: IN
45383: PUSH
45384: LD_EXP 87
45388: PUSH
45389: LD_VAR 0 1
45393: ARRAY
45394: AND
45395: IFFALSE 45551
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
45397: LD_ADDR_VAR 0 9
45401: PUSH
45402: LD_EXP 87
45406: PUSH
45407: LD_VAR 0 1
45411: ARRAY
45412: PUSH
45413: LD_INT 1
45415: ARRAY
45416: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
45417: LD_VAR 0 9
45421: PUSH
45422: LD_EXP 88
45426: PUSH
45427: LD_VAR 0 1
45431: ARRAY
45432: IN
45433: NOT
45434: IFFALSE 45549
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
45436: LD_ADDR_EXP 88
45440: PUSH
45441: LD_EXP 88
45445: PPUSH
45446: LD_VAR 0 1
45450: PUSH
45451: LD_EXP 88
45455: PUSH
45456: LD_VAR 0 1
45460: ARRAY
45461: PUSH
45462: LD_INT 1
45464: PLUS
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: PPUSH
45470: LD_VAR 0 9
45474: PPUSH
45475: CALL 57865 0 3
45479: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
45480: LD_ADDR_EXP 87
45484: PUSH
45485: LD_EXP 87
45489: PPUSH
45490: LD_VAR 0 1
45494: PPUSH
45495: LD_EXP 87
45499: PUSH
45500: LD_VAR 0 1
45504: ARRAY
45505: PUSH
45506: LD_VAR 0 9
45510: DIFF
45511: PPUSH
45512: CALL_OW 1
45516: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
45517: LD_VAR 0 3
45521: PPUSH
45522: LD_EXP 88
45526: PUSH
45527: LD_VAR 0 1
45531: ARRAY
45532: PUSH
45533: LD_EXP 88
45537: PUSH
45538: LD_VAR 0 1
45542: ARRAY
45543: ARRAY
45544: PPUSH
45545: CALL_OW 120
// end ; exit ;
45549: GO 45828
// end ; if tmp > 1 then
45551: LD_VAR 0 8
45555: PUSH
45556: LD_INT 1
45558: GREATER
45559: IFFALSE 45663
// for i = 2 to tmp do
45561: LD_ADDR_VAR 0 6
45565: PUSH
45566: DOUBLE
45567: LD_INT 2
45569: DEC
45570: ST_TO_ADDR
45571: LD_VAR 0 8
45575: PUSH
45576: FOR_TO
45577: IFFALSE 45661
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
45579: LD_VAR 0 8
45583: PUSH
45584: LD_VAR 0 6
45588: ARRAY
45589: PPUSH
45590: CALL_OW 461
45594: PUSH
45595: LD_INT 6
45597: EQUAL
45598: IFFALSE 45659
// begin x := tmp [ i ] ;
45600: LD_ADDR_VAR 0 9
45604: PUSH
45605: LD_VAR 0 8
45609: PUSH
45610: LD_VAR 0 6
45614: ARRAY
45615: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
45616: LD_ADDR_VAR 0 8
45620: PUSH
45621: LD_VAR 0 8
45625: PPUSH
45626: LD_VAR 0 6
45630: PPUSH
45631: CALL_OW 3
45635: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
45636: LD_ADDR_VAR 0 8
45640: PUSH
45641: LD_VAR 0 8
45645: PPUSH
45646: LD_INT 1
45648: PPUSH
45649: LD_VAR 0 9
45653: PPUSH
45654: CALL_OW 2
45658: ST_TO_ADDR
// end ;
45659: GO 45576
45661: POP
45662: POP
// for i in tmp do
45663: LD_ADDR_VAR 0 6
45667: PUSH
45668: LD_VAR 0 8
45672: PUSH
45673: FOR_IN
45674: IFFALSE 45701
// begin if IsNotFull ( i ) then
45676: LD_VAR 0 6
45680: PPUSH
45681: CALL 55087 0 1
45685: IFFALSE 45699
// begin j := i ;
45687: LD_ADDR_VAR 0 7
45691: PUSH
45692: LD_VAR 0 6
45696: ST_TO_ADDR
// break ;
45697: GO 45701
// end ; end ;
45699: GO 45673
45701: POP
45702: POP
// if j then
45703: LD_VAR 0 7
45707: IFFALSE 45725
// ComEnterUnit ( unit , j ) else
45709: LD_VAR 0 3
45713: PPUSH
45714: LD_VAR 0 7
45718: PPUSH
45719: CALL_OW 120
45723: GO 45828
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45725: LD_ADDR_VAR 0 10
45729: PUSH
45730: LD_VAR 0 2
45734: PPUSH
45735: LD_INT 2
45737: PUSH
45738: LD_INT 30
45740: PUSH
45741: LD_INT 0
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: PUSH
45748: LD_INT 30
45750: PUSH
45751: LD_INT 1
45753: PUSH
45754: EMPTY
45755: LIST
45756: LIST
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: LIST
45762: PPUSH
45763: CALL_OW 72
45767: ST_TO_ADDR
// if depot then
45768: LD_VAR 0 10
45772: IFFALSE 45828
// begin depot := NearestUnitToUnit ( depot , unit ) ;
45774: LD_ADDR_VAR 0 10
45778: PUSH
45779: LD_VAR 0 10
45783: PPUSH
45784: LD_VAR 0 3
45788: PPUSH
45789: CALL_OW 74
45793: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
45794: LD_VAR 0 3
45798: PPUSH
45799: LD_VAR 0 10
45803: PPUSH
45804: CALL_OW 296
45808: PUSH
45809: LD_INT 10
45811: GREATER
45812: IFFALSE 45828
// ComStandNearbyBuilding ( unit , depot ) ;
45814: LD_VAR 0 3
45818: PPUSH
45819: LD_VAR 0 10
45823: PPUSH
45824: CALL 54467 0 2
// end ; end ; end ;
45828: LD_VAR 0 5
45832: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
45833: LD_INT 0
45835: PPUSH
45836: PPUSH
45837: PPUSH
45838: PPUSH
// if not mc_bases then
45839: LD_EXP 78
45843: NOT
45844: IFFALSE 45848
// exit ;
45846: GO 46087
// for i = 1 to mc_bases do
45848: LD_ADDR_VAR 0 2
45852: PUSH
45853: DOUBLE
45854: LD_INT 1
45856: DEC
45857: ST_TO_ADDR
45858: LD_EXP 78
45862: PUSH
45863: FOR_TO
45864: IFFALSE 46085
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45866: LD_ADDR_VAR 0 4
45870: PUSH
45871: LD_EXP 78
45875: PUSH
45876: LD_VAR 0 2
45880: ARRAY
45881: PPUSH
45882: LD_INT 21
45884: PUSH
45885: LD_INT 1
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: PPUSH
45892: CALL_OW 72
45896: PUSH
45897: LD_EXP 107
45901: PUSH
45902: LD_VAR 0 2
45906: ARRAY
45907: UNION
45908: ST_TO_ADDR
// if not tmp then
45909: LD_VAR 0 4
45913: NOT
45914: IFFALSE 45918
// continue ;
45916: GO 45863
// for j in tmp do
45918: LD_ADDR_VAR 0 3
45922: PUSH
45923: LD_VAR 0 4
45927: PUSH
45928: FOR_IN
45929: IFFALSE 46081
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45931: LD_VAR 0 3
45935: PPUSH
45936: CALL_OW 110
45940: NOT
45941: PUSH
45942: LD_VAR 0 3
45946: PPUSH
45947: CALL_OW 314
45951: NOT
45952: AND
45953: PUSH
45954: LD_VAR 0 3
45958: PPUSH
45959: CALL_OW 311
45963: NOT
45964: AND
45965: PUSH
45966: LD_VAR 0 3
45970: PPUSH
45971: CALL_OW 310
45975: NOT
45976: AND
45977: PUSH
45978: LD_VAR 0 3
45982: PUSH
45983: LD_EXP 81
45987: PUSH
45988: LD_VAR 0 2
45992: ARRAY
45993: PUSH
45994: LD_INT 1
45996: ARRAY
45997: IN
45998: NOT
45999: AND
46000: PUSH
46001: LD_VAR 0 3
46005: PUSH
46006: LD_EXP 81
46010: PUSH
46011: LD_VAR 0 2
46015: ARRAY
46016: PUSH
46017: LD_INT 2
46019: ARRAY
46020: IN
46021: NOT
46022: AND
46023: PUSH
46024: LD_VAR 0 3
46028: PUSH
46029: LD_EXP 90
46033: PUSH
46034: LD_VAR 0 2
46038: ARRAY
46039: IN
46040: NOT
46041: AND
46042: IFFALSE 46079
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
46044: LD_VAR 0 2
46048: PPUSH
46049: LD_EXP 78
46053: PUSH
46054: LD_VAR 0 2
46058: ARRAY
46059: PPUSH
46060: LD_VAR 0 3
46064: PPUSH
46065: LD_VAR 0 3
46069: PPUSH
46070: CALL_OW 257
46074: PPUSH
46075: CALL 44893 0 4
// end ;
46079: GO 45928
46081: POP
46082: POP
// end ;
46083: GO 45863
46085: POP
46086: POP
// end ;
46087: LD_VAR 0 1
46091: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46092: LD_INT 0
46094: PPUSH
46095: PPUSH
46096: PPUSH
46097: PPUSH
46098: PPUSH
46099: PPUSH
// if not mc_bases [ base ] then
46100: LD_EXP 78
46104: PUSH
46105: LD_VAR 0 1
46109: ARRAY
46110: NOT
46111: IFFALSE 46115
// exit ;
46113: GO 46316
// tmp := [ ] ;
46115: LD_ADDR_VAR 0 6
46119: PUSH
46120: EMPTY
46121: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46122: LD_ADDR_VAR 0 7
46126: PUSH
46127: LD_VAR 0 3
46131: PPUSH
46132: LD_INT 0
46134: PPUSH
46135: CALL_OW 517
46139: ST_TO_ADDR
// if not list then
46140: LD_VAR 0 7
46144: NOT
46145: IFFALSE 46149
// exit ;
46147: GO 46316
// c := Count ( list [ 1 ] ) ;
46149: LD_ADDR_VAR 0 9
46153: PUSH
46154: LD_VAR 0 7
46158: PUSH
46159: LD_INT 1
46161: ARRAY
46162: PPUSH
46163: CALL 55005 0 1
46167: ST_TO_ADDR
// if amount > c then
46168: LD_VAR 0 2
46172: PUSH
46173: LD_VAR 0 9
46177: GREATER
46178: IFFALSE 46190
// amount := c ;
46180: LD_ADDR_VAR 0 2
46184: PUSH
46185: LD_VAR 0 9
46189: ST_TO_ADDR
// for i := 1 to amount do
46190: LD_ADDR_VAR 0 5
46194: PUSH
46195: DOUBLE
46196: LD_INT 1
46198: DEC
46199: ST_TO_ADDR
46200: LD_VAR 0 2
46204: PUSH
46205: FOR_TO
46206: IFFALSE 46264
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
46208: LD_ADDR_VAR 0 6
46212: PUSH
46213: LD_VAR 0 6
46217: PPUSH
46218: LD_VAR 0 5
46222: PPUSH
46223: LD_VAR 0 7
46227: PUSH
46228: LD_INT 1
46230: ARRAY
46231: PUSH
46232: LD_VAR 0 5
46236: ARRAY
46237: PUSH
46238: LD_VAR 0 7
46242: PUSH
46243: LD_INT 2
46245: ARRAY
46246: PUSH
46247: LD_VAR 0 5
46251: ARRAY
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PPUSH
46257: CALL_OW 1
46261: ST_TO_ADDR
46262: GO 46205
46264: POP
46265: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
46266: LD_ADDR_EXP 91
46270: PUSH
46271: LD_EXP 91
46275: PPUSH
46276: LD_VAR 0 1
46280: PPUSH
46281: LD_VAR 0 6
46285: PPUSH
46286: CALL_OW 1
46290: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
46291: LD_ADDR_EXP 93
46295: PUSH
46296: LD_EXP 93
46300: PPUSH
46301: LD_VAR 0 1
46305: PPUSH
46306: LD_VAR 0 3
46310: PPUSH
46311: CALL_OW 1
46315: ST_TO_ADDR
// end ;
46316: LD_VAR 0 4
46320: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
46321: LD_INT 0
46323: PPUSH
// if not mc_bases [ base ] then
46324: LD_EXP 78
46328: PUSH
46329: LD_VAR 0 1
46333: ARRAY
46334: NOT
46335: IFFALSE 46339
// exit ;
46337: GO 46364
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
46339: LD_ADDR_EXP 83
46343: PUSH
46344: LD_EXP 83
46348: PPUSH
46349: LD_VAR 0 1
46353: PPUSH
46354: LD_VAR 0 2
46358: PPUSH
46359: CALL_OW 1
46363: ST_TO_ADDR
// end ;
46364: LD_VAR 0 3
46368: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
46369: LD_INT 0
46371: PPUSH
// if not mc_bases [ base ] then
46372: LD_EXP 78
46376: PUSH
46377: LD_VAR 0 1
46381: ARRAY
46382: NOT
46383: IFFALSE 46387
// exit ;
46385: GO 46424
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
46387: LD_ADDR_EXP 83
46391: PUSH
46392: LD_EXP 83
46396: PPUSH
46397: LD_VAR 0 1
46401: PPUSH
46402: LD_EXP 83
46406: PUSH
46407: LD_VAR 0 1
46411: ARRAY
46412: PUSH
46413: LD_VAR 0 2
46417: UNION
46418: PPUSH
46419: CALL_OW 1
46423: ST_TO_ADDR
// end ;
46424: LD_VAR 0 3
46428: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
46429: LD_INT 0
46431: PPUSH
// if not mc_bases [ base ] then
46432: LD_EXP 78
46436: PUSH
46437: LD_VAR 0 1
46441: ARRAY
46442: NOT
46443: IFFALSE 46447
// exit ;
46445: GO 46472
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
46447: LD_ADDR_EXP 99
46451: PUSH
46452: LD_EXP 99
46456: PPUSH
46457: LD_VAR 0 1
46461: PPUSH
46462: LD_VAR 0 2
46466: PPUSH
46467: CALL_OW 1
46471: ST_TO_ADDR
// end ;
46472: LD_VAR 0 3
46476: RET
// export function MC_InsertProduceList ( base , components ) ; begin
46477: LD_INT 0
46479: PPUSH
// if not mc_bases [ base ] then
46480: LD_EXP 78
46484: PUSH
46485: LD_VAR 0 1
46489: ARRAY
46490: NOT
46491: IFFALSE 46495
// exit ;
46493: GO 46532
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
46495: LD_ADDR_EXP 99
46499: PUSH
46500: LD_EXP 99
46504: PPUSH
46505: LD_VAR 0 1
46509: PPUSH
46510: LD_EXP 99
46514: PUSH
46515: LD_VAR 0 1
46519: ARRAY
46520: PUSH
46521: LD_VAR 0 2
46525: ADD
46526: PPUSH
46527: CALL_OW 1
46531: ST_TO_ADDR
// end ;
46532: LD_VAR 0 3
46536: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
46537: LD_INT 0
46539: PPUSH
// if not mc_bases [ base ] then
46540: LD_EXP 78
46544: PUSH
46545: LD_VAR 0 1
46549: ARRAY
46550: NOT
46551: IFFALSE 46555
// exit ;
46553: GO 46609
// mc_defender := Replace ( mc_defender , base , deflist ) ;
46555: LD_ADDR_EXP 100
46559: PUSH
46560: LD_EXP 100
46564: PPUSH
46565: LD_VAR 0 1
46569: PPUSH
46570: LD_VAR 0 2
46574: PPUSH
46575: CALL_OW 1
46579: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
46580: LD_ADDR_EXP 89
46584: PUSH
46585: LD_EXP 89
46589: PPUSH
46590: LD_VAR 0 1
46594: PPUSH
46595: LD_VAR 0 2
46599: PUSH
46600: LD_INT 0
46602: PLUS
46603: PPUSH
46604: CALL_OW 1
46608: ST_TO_ADDR
// end ;
46609: LD_VAR 0 3
46613: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
46614: LD_INT 0
46616: PPUSH
// if not mc_bases [ base ] then
46617: LD_EXP 78
46621: PUSH
46622: LD_VAR 0 1
46626: ARRAY
46627: NOT
46628: IFFALSE 46632
// exit ;
46630: GO 46657
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
46632: LD_ADDR_EXP 89
46636: PUSH
46637: LD_EXP 89
46641: PPUSH
46642: LD_VAR 0 1
46646: PPUSH
46647: LD_VAR 0 2
46651: PPUSH
46652: CALL_OW 1
46656: ST_TO_ADDR
// end ;
46657: LD_VAR 0 3
46661: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
46662: LD_INT 0
46664: PPUSH
46665: PPUSH
46666: PPUSH
46667: PPUSH
// if not mc_bases [ base ] then
46668: LD_EXP 78
46672: PUSH
46673: LD_VAR 0 1
46677: ARRAY
46678: NOT
46679: IFFALSE 46683
// exit ;
46681: GO 46748
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
46683: LD_ADDR_EXP 98
46687: PUSH
46688: LD_EXP 98
46692: PPUSH
46693: LD_VAR 0 1
46697: PUSH
46698: LD_EXP 98
46702: PUSH
46703: LD_VAR 0 1
46707: ARRAY
46708: PUSH
46709: LD_INT 1
46711: PLUS
46712: PUSH
46713: EMPTY
46714: LIST
46715: LIST
46716: PPUSH
46717: LD_VAR 0 1
46721: PUSH
46722: LD_VAR 0 2
46726: PUSH
46727: LD_VAR 0 3
46731: PUSH
46732: LD_VAR 0 4
46736: PUSH
46737: EMPTY
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: PPUSH
46743: CALL 57865 0 3
46747: ST_TO_ADDR
// end ;
46748: LD_VAR 0 5
46752: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
46753: LD_INT 0
46755: PPUSH
// if not mc_bases [ base ] then
46756: LD_EXP 78
46760: PUSH
46761: LD_VAR 0 1
46765: ARRAY
46766: NOT
46767: IFFALSE 46771
// exit ;
46769: GO 46796
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
46771: LD_ADDR_EXP 115
46775: PUSH
46776: LD_EXP 115
46780: PPUSH
46781: LD_VAR 0 1
46785: PPUSH
46786: LD_VAR 0 2
46790: PPUSH
46791: CALL_OW 1
46795: ST_TO_ADDR
// end ;
46796: LD_VAR 0 3
46800: RET
// export function MC_GetMinesField ( base ) ; begin
46801: LD_INT 0
46803: PPUSH
// result := mc_mines [ base ] ;
46804: LD_ADDR_VAR 0 2
46808: PUSH
46809: LD_EXP 91
46813: PUSH
46814: LD_VAR 0 1
46818: ARRAY
46819: ST_TO_ADDR
// end ;
46820: LD_VAR 0 2
46824: RET
// export function MC_GetProduceList ( base ) ; begin
46825: LD_INT 0
46827: PPUSH
// result := mc_produce [ base ] ;
46828: LD_ADDR_VAR 0 2
46832: PUSH
46833: LD_EXP 99
46837: PUSH
46838: LD_VAR 0 1
46842: ARRAY
46843: ST_TO_ADDR
// end ;
46844: LD_VAR 0 2
46848: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
46849: LD_INT 0
46851: PPUSH
46852: PPUSH
// if not mc_bases then
46853: LD_EXP 78
46857: NOT
46858: IFFALSE 46862
// exit ;
46860: GO 46927
// if mc_bases [ base ] then
46862: LD_EXP 78
46866: PUSH
46867: LD_VAR 0 1
46871: ARRAY
46872: IFFALSE 46927
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46874: LD_ADDR_VAR 0 3
46878: PUSH
46879: LD_EXP 78
46883: PUSH
46884: LD_VAR 0 1
46888: ARRAY
46889: PPUSH
46890: LD_INT 30
46892: PUSH
46893: LD_VAR 0 2
46897: PUSH
46898: EMPTY
46899: LIST
46900: LIST
46901: PPUSH
46902: CALL_OW 72
46906: ST_TO_ADDR
// if result then
46907: LD_VAR 0 3
46911: IFFALSE 46927
// result := result [ 1 ] ;
46913: LD_ADDR_VAR 0 3
46917: PUSH
46918: LD_VAR 0 3
46922: PUSH
46923: LD_INT 1
46925: ARRAY
46926: ST_TO_ADDR
// end ; end ;
46927: LD_VAR 0 3
46931: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46932: LD_INT 0
46934: PPUSH
46935: PPUSH
// if not mc_bases then
46936: LD_EXP 78
46940: NOT
46941: IFFALSE 46945
// exit ;
46943: GO 46990
// if mc_bases [ base ] then
46945: LD_EXP 78
46949: PUSH
46950: LD_VAR 0 1
46954: ARRAY
46955: IFFALSE 46990
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46957: LD_ADDR_VAR 0 3
46961: PUSH
46962: LD_EXP 78
46966: PUSH
46967: LD_VAR 0 1
46971: ARRAY
46972: PPUSH
46973: LD_INT 30
46975: PUSH
46976: LD_VAR 0 2
46980: PUSH
46981: EMPTY
46982: LIST
46983: LIST
46984: PPUSH
46985: CALL_OW 72
46989: ST_TO_ADDR
// end ;
46990: LD_VAR 0 3
46994: RET
// export function MC_SetTame ( base , area ) ; begin
46995: LD_INT 0
46997: PPUSH
// if not mc_bases or not base then
46998: LD_EXP 78
47002: NOT
47003: PUSH
47004: LD_VAR 0 1
47008: NOT
47009: OR
47010: IFFALSE 47014
// exit ;
47012: GO 47039
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
47014: LD_ADDR_EXP 106
47018: PUSH
47019: LD_EXP 106
47023: PPUSH
47024: LD_VAR 0 1
47028: PPUSH
47029: LD_VAR 0 2
47033: PPUSH
47034: CALL_OW 1
47038: ST_TO_ADDR
// end ;
47039: LD_VAR 0 3
47043: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
47044: LD_INT 0
47046: PPUSH
47047: PPUSH
// if not mc_bases or not base then
47048: LD_EXP 78
47052: NOT
47053: PUSH
47054: LD_VAR 0 1
47058: NOT
47059: OR
47060: IFFALSE 47064
// exit ;
47062: GO 47166
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47064: LD_ADDR_VAR 0 4
47068: PUSH
47069: LD_EXP 78
47073: PUSH
47074: LD_VAR 0 1
47078: ARRAY
47079: PPUSH
47080: LD_INT 30
47082: PUSH
47083: LD_VAR 0 2
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: PPUSH
47092: CALL_OW 72
47096: ST_TO_ADDR
// if not tmp then
47097: LD_VAR 0 4
47101: NOT
47102: IFFALSE 47106
// exit ;
47104: GO 47166
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47106: LD_ADDR_EXP 110
47110: PUSH
47111: LD_EXP 110
47115: PPUSH
47116: LD_VAR 0 1
47120: PPUSH
47121: LD_EXP 110
47125: PUSH
47126: LD_VAR 0 1
47130: ARRAY
47131: PPUSH
47132: LD_EXP 110
47136: PUSH
47137: LD_VAR 0 1
47141: ARRAY
47142: PUSH
47143: LD_INT 1
47145: PLUS
47146: PPUSH
47147: LD_VAR 0 4
47151: PUSH
47152: LD_INT 1
47154: ARRAY
47155: PPUSH
47156: CALL_OW 2
47160: PPUSH
47161: CALL_OW 1
47165: ST_TO_ADDR
// end ;
47166: LD_VAR 0 3
47170: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47171: LD_INT 0
47173: PPUSH
47174: PPUSH
// if not mc_bases or not base or not kinds then
47175: LD_EXP 78
47179: NOT
47180: PUSH
47181: LD_VAR 0 1
47185: NOT
47186: OR
47187: PUSH
47188: LD_VAR 0 2
47192: NOT
47193: OR
47194: IFFALSE 47198
// exit ;
47196: GO 47259
// for i in kinds do
47198: LD_ADDR_VAR 0 4
47202: PUSH
47203: LD_VAR 0 2
47207: PUSH
47208: FOR_IN
47209: IFFALSE 47257
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
47211: LD_ADDR_EXP 112
47215: PUSH
47216: LD_EXP 112
47220: PPUSH
47221: LD_VAR 0 1
47225: PUSH
47226: LD_EXP 112
47230: PUSH
47231: LD_VAR 0 1
47235: ARRAY
47236: PUSH
47237: LD_INT 1
47239: PLUS
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: PPUSH
47245: LD_VAR 0 4
47249: PPUSH
47250: CALL 57865 0 3
47254: ST_TO_ADDR
47255: GO 47208
47257: POP
47258: POP
// end ;
47259: LD_VAR 0 3
47263: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
47264: LD_INT 0
47266: PPUSH
// if not mc_bases or not base or not areas then
47267: LD_EXP 78
47271: NOT
47272: PUSH
47273: LD_VAR 0 1
47277: NOT
47278: OR
47279: PUSH
47280: LD_VAR 0 2
47284: NOT
47285: OR
47286: IFFALSE 47290
// exit ;
47288: GO 47315
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
47290: LD_ADDR_EXP 96
47294: PUSH
47295: LD_EXP 96
47299: PPUSH
47300: LD_VAR 0 1
47304: PPUSH
47305: LD_VAR 0 2
47309: PPUSH
47310: CALL_OW 1
47314: ST_TO_ADDR
// end ;
47315: LD_VAR 0 3
47319: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
47320: LD_INT 0
47322: PPUSH
// if not mc_bases or not base or not teleports_exit then
47323: LD_EXP 78
47327: NOT
47328: PUSH
47329: LD_VAR 0 1
47333: NOT
47334: OR
47335: PUSH
47336: LD_VAR 0 2
47340: NOT
47341: OR
47342: IFFALSE 47346
// exit ;
47344: GO 47371
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
47346: LD_ADDR_EXP 113
47350: PUSH
47351: LD_EXP 113
47355: PPUSH
47356: LD_VAR 0 1
47360: PPUSH
47361: LD_VAR 0 2
47365: PPUSH
47366: CALL_OW 1
47370: ST_TO_ADDR
// end ;
47371: LD_VAR 0 3
47375: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
47376: LD_INT 0
47378: PPUSH
47379: PPUSH
47380: PPUSH
// if not mc_bases or not base or not ext_list then
47381: LD_EXP 78
47385: NOT
47386: PUSH
47387: LD_VAR 0 1
47391: NOT
47392: OR
47393: PUSH
47394: LD_VAR 0 5
47398: NOT
47399: OR
47400: IFFALSE 47404
// exit ;
47402: GO 47577
// tmp := GetFacExtXYD ( x , y , d ) ;
47404: LD_ADDR_VAR 0 8
47408: PUSH
47409: LD_VAR 0 2
47413: PPUSH
47414: LD_VAR 0 3
47418: PPUSH
47419: LD_VAR 0 4
47423: PPUSH
47424: CALL 88239 0 3
47428: ST_TO_ADDR
// if not tmp then
47429: LD_VAR 0 8
47433: NOT
47434: IFFALSE 47438
// exit ;
47436: GO 47577
// for i in tmp do
47438: LD_ADDR_VAR 0 7
47442: PUSH
47443: LD_VAR 0 8
47447: PUSH
47448: FOR_IN
47449: IFFALSE 47575
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
47451: LD_ADDR_EXP 83
47455: PUSH
47456: LD_EXP 83
47460: PPUSH
47461: LD_VAR 0 1
47465: PPUSH
47466: LD_EXP 83
47470: PUSH
47471: LD_VAR 0 1
47475: ARRAY
47476: PPUSH
47477: LD_EXP 83
47481: PUSH
47482: LD_VAR 0 1
47486: ARRAY
47487: PUSH
47488: LD_INT 1
47490: PLUS
47491: PPUSH
47492: LD_VAR 0 5
47496: PUSH
47497: LD_INT 1
47499: ARRAY
47500: PUSH
47501: LD_VAR 0 7
47505: PUSH
47506: LD_INT 1
47508: ARRAY
47509: PUSH
47510: LD_VAR 0 7
47514: PUSH
47515: LD_INT 2
47517: ARRAY
47518: PUSH
47519: LD_VAR 0 7
47523: PUSH
47524: LD_INT 3
47526: ARRAY
47527: PUSH
47528: EMPTY
47529: LIST
47530: LIST
47531: LIST
47532: LIST
47533: PPUSH
47534: CALL_OW 2
47538: PPUSH
47539: CALL_OW 1
47543: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
47544: LD_ADDR_VAR 0 5
47548: PUSH
47549: LD_VAR 0 5
47553: PPUSH
47554: LD_INT 1
47556: PPUSH
47557: CALL_OW 3
47561: ST_TO_ADDR
// if not ext_list then
47562: LD_VAR 0 5
47566: NOT
47567: IFFALSE 47573
// exit ;
47569: POP
47570: POP
47571: GO 47577
// end ;
47573: GO 47448
47575: POP
47576: POP
// end ;
47577: LD_VAR 0 6
47581: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
47582: LD_INT 0
47584: PPUSH
// if not mc_bases or not base or not weapon_list then
47585: LD_EXP 78
47589: NOT
47590: PUSH
47591: LD_VAR 0 1
47595: NOT
47596: OR
47597: PUSH
47598: LD_VAR 0 2
47602: NOT
47603: OR
47604: IFFALSE 47608
// exit ;
47606: GO 47633
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
47608: LD_ADDR_EXP 117
47612: PUSH
47613: LD_EXP 117
47617: PPUSH
47618: LD_VAR 0 1
47622: PPUSH
47623: LD_VAR 0 2
47627: PPUSH
47628: CALL_OW 1
47632: ST_TO_ADDR
// end ;
47633: LD_VAR 0 3
47637: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
47638: LD_INT 0
47640: PPUSH
// if not mc_bases or not base or not tech_list then
47641: LD_EXP 78
47645: NOT
47646: PUSH
47647: LD_VAR 0 1
47651: NOT
47652: OR
47653: PUSH
47654: LD_VAR 0 2
47658: NOT
47659: OR
47660: IFFALSE 47664
// exit ;
47662: GO 47689
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
47664: LD_ADDR_EXP 105
47668: PUSH
47669: LD_EXP 105
47673: PPUSH
47674: LD_VAR 0 1
47678: PPUSH
47679: LD_VAR 0 2
47683: PPUSH
47684: CALL_OW 1
47688: ST_TO_ADDR
// end ;
47689: LD_VAR 0 3
47693: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
47694: LD_INT 0
47696: PPUSH
// if not mc_bases or not parking_area or not base then
47697: LD_EXP 78
47701: NOT
47702: PUSH
47703: LD_VAR 0 2
47707: NOT
47708: OR
47709: PUSH
47710: LD_VAR 0 1
47714: NOT
47715: OR
47716: IFFALSE 47720
// exit ;
47718: GO 47745
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
47720: LD_ADDR_EXP 102
47724: PUSH
47725: LD_EXP 102
47729: PPUSH
47730: LD_VAR 0 1
47734: PPUSH
47735: LD_VAR 0 2
47739: PPUSH
47740: CALL_OW 1
47744: ST_TO_ADDR
// end ;
47745: LD_VAR 0 3
47749: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
47750: LD_INT 0
47752: PPUSH
// if not mc_bases or not base or not scan_area then
47753: LD_EXP 78
47757: NOT
47758: PUSH
47759: LD_VAR 0 1
47763: NOT
47764: OR
47765: PUSH
47766: LD_VAR 0 2
47770: NOT
47771: OR
47772: IFFALSE 47776
// exit ;
47774: GO 47801
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
47776: LD_ADDR_EXP 103
47780: PUSH
47781: LD_EXP 103
47785: PPUSH
47786: LD_VAR 0 1
47790: PPUSH
47791: LD_VAR 0 2
47795: PPUSH
47796: CALL_OW 1
47800: ST_TO_ADDR
// end ;
47801: LD_VAR 0 3
47805: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
47806: LD_INT 0
47808: PPUSH
47809: PPUSH
// if not mc_bases or not base then
47810: LD_EXP 78
47814: NOT
47815: PUSH
47816: LD_VAR 0 1
47820: NOT
47821: OR
47822: IFFALSE 47826
// exit ;
47824: GO 47890
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
47826: LD_ADDR_VAR 0 3
47830: PUSH
47831: LD_INT 1
47833: PUSH
47834: LD_INT 2
47836: PUSH
47837: LD_INT 3
47839: PUSH
47840: LD_INT 4
47842: PUSH
47843: LD_INT 11
47845: PUSH
47846: EMPTY
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
47853: LD_ADDR_EXP 105
47857: PUSH
47858: LD_EXP 105
47862: PPUSH
47863: LD_VAR 0 1
47867: PPUSH
47868: LD_EXP 105
47872: PUSH
47873: LD_VAR 0 1
47877: ARRAY
47878: PUSH
47879: LD_VAR 0 3
47883: DIFF
47884: PPUSH
47885: CALL_OW 1
47889: ST_TO_ADDR
// end ;
47890: LD_VAR 0 2
47894: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47895: LD_INT 0
47897: PPUSH
// result := mc_vehicles [ base ] ;
47898: LD_ADDR_VAR 0 3
47902: PUSH
47903: LD_EXP 97
47907: PUSH
47908: LD_VAR 0 1
47912: ARRAY
47913: ST_TO_ADDR
// if onlyCombat then
47914: LD_VAR 0 2
47918: IFFALSE 48090
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47920: LD_ADDR_VAR 0 3
47924: PUSH
47925: LD_VAR 0 3
47929: PUSH
47930: LD_VAR 0 3
47934: PPUSH
47935: LD_INT 2
47937: PUSH
47938: LD_INT 34
47940: PUSH
47941: LD_INT 12
47943: PUSH
47944: EMPTY
47945: LIST
47946: LIST
47947: PUSH
47948: LD_INT 34
47950: PUSH
47951: LD_INT 51
47953: PUSH
47954: EMPTY
47955: LIST
47956: LIST
47957: PUSH
47958: LD_INT 34
47960: PUSH
47961: LD_INT 89
47963: PUSH
47964: EMPTY
47965: LIST
47966: LIST
47967: PUSH
47968: LD_INT 34
47970: PUSH
47971: LD_INT 32
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PUSH
47978: LD_INT 34
47980: PUSH
47981: LD_INT 13
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: PUSH
47988: LD_INT 34
47990: PUSH
47991: LD_INT 52
47993: PUSH
47994: EMPTY
47995: LIST
47996: LIST
47997: PUSH
47998: LD_INT 34
48000: PUSH
48001: LD_INT 88
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: PUSH
48008: LD_INT 34
48010: PUSH
48011: LD_INT 14
48013: PUSH
48014: EMPTY
48015: LIST
48016: LIST
48017: PUSH
48018: LD_INT 34
48020: PUSH
48021: LD_INT 53
48023: PUSH
48024: EMPTY
48025: LIST
48026: LIST
48027: PUSH
48028: LD_INT 34
48030: PUSH
48031: LD_INT 98
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: LD_INT 34
48040: PUSH
48041: LD_INT 31
48043: PUSH
48044: EMPTY
48045: LIST
48046: LIST
48047: PUSH
48048: LD_INT 34
48050: PUSH
48051: LD_INT 48
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: PUSH
48058: LD_INT 34
48060: PUSH
48061: LD_INT 8
48063: PUSH
48064: EMPTY
48065: LIST
48066: LIST
48067: PUSH
48068: EMPTY
48069: LIST
48070: LIST
48071: LIST
48072: LIST
48073: LIST
48074: LIST
48075: LIST
48076: LIST
48077: LIST
48078: LIST
48079: LIST
48080: LIST
48081: LIST
48082: LIST
48083: PPUSH
48084: CALL_OW 72
48088: DIFF
48089: ST_TO_ADDR
// end ; end_of_file
48090: LD_VAR 0 3
48094: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48095: LD_INT 0
48097: PPUSH
48098: PPUSH
48099: PPUSH
// if not mc_bases or not skirmish then
48100: LD_EXP 78
48104: NOT
48105: PUSH
48106: LD_EXP 76
48110: NOT
48111: OR
48112: IFFALSE 48116
// exit ;
48114: GO 48281
// for i = 1 to mc_bases do
48116: LD_ADDR_VAR 0 4
48120: PUSH
48121: DOUBLE
48122: LD_INT 1
48124: DEC
48125: ST_TO_ADDR
48126: LD_EXP 78
48130: PUSH
48131: FOR_TO
48132: IFFALSE 48279
// begin if sci in mc_bases [ i ] then
48134: LD_VAR 0 2
48138: PUSH
48139: LD_EXP 78
48143: PUSH
48144: LD_VAR 0 4
48148: ARRAY
48149: IN
48150: IFFALSE 48277
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48152: LD_ADDR_EXP 107
48156: PUSH
48157: LD_EXP 107
48161: PPUSH
48162: LD_VAR 0 4
48166: PUSH
48167: LD_EXP 107
48171: PUSH
48172: LD_VAR 0 4
48176: ARRAY
48177: PUSH
48178: LD_INT 1
48180: PLUS
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: PPUSH
48186: LD_VAR 0 1
48190: PPUSH
48191: CALL 57865 0 3
48195: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
48196: LD_ADDR_VAR 0 5
48200: PUSH
48201: LD_EXP 78
48205: PUSH
48206: LD_VAR 0 4
48210: ARRAY
48211: PPUSH
48212: LD_INT 2
48214: PUSH
48215: LD_INT 30
48217: PUSH
48218: LD_INT 0
48220: PUSH
48221: EMPTY
48222: LIST
48223: LIST
48224: PUSH
48225: LD_INT 30
48227: PUSH
48228: LD_INT 1
48230: PUSH
48231: EMPTY
48232: LIST
48233: LIST
48234: PUSH
48235: EMPTY
48236: LIST
48237: LIST
48238: LIST
48239: PPUSH
48240: CALL_OW 72
48244: PPUSH
48245: LD_VAR 0 1
48249: PPUSH
48250: CALL_OW 74
48254: ST_TO_ADDR
// if tmp then
48255: LD_VAR 0 5
48259: IFFALSE 48275
// ComStandNearbyBuilding ( ape , tmp ) ;
48261: LD_VAR 0 1
48265: PPUSH
48266: LD_VAR 0 5
48270: PPUSH
48271: CALL 54467 0 2
// break ;
48275: GO 48279
// end ; end ;
48277: GO 48131
48279: POP
48280: POP
// end ;
48281: LD_VAR 0 3
48285: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
48286: LD_INT 0
48288: PPUSH
48289: PPUSH
48290: PPUSH
// if not mc_bases or not skirmish then
48291: LD_EXP 78
48295: NOT
48296: PUSH
48297: LD_EXP 76
48301: NOT
48302: OR
48303: IFFALSE 48307
// exit ;
48305: GO 48396
// for i = 1 to mc_bases do
48307: LD_ADDR_VAR 0 4
48311: PUSH
48312: DOUBLE
48313: LD_INT 1
48315: DEC
48316: ST_TO_ADDR
48317: LD_EXP 78
48321: PUSH
48322: FOR_TO
48323: IFFALSE 48394
// begin if building in mc_busy_turret_list [ i ] then
48325: LD_VAR 0 1
48329: PUSH
48330: LD_EXP 88
48334: PUSH
48335: LD_VAR 0 4
48339: ARRAY
48340: IN
48341: IFFALSE 48392
// begin tmp := mc_busy_turret_list [ i ] diff building ;
48343: LD_ADDR_VAR 0 5
48347: PUSH
48348: LD_EXP 88
48352: PUSH
48353: LD_VAR 0 4
48357: ARRAY
48358: PUSH
48359: LD_VAR 0 1
48363: DIFF
48364: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
48365: LD_ADDR_EXP 88
48369: PUSH
48370: LD_EXP 88
48374: PPUSH
48375: LD_VAR 0 4
48379: PPUSH
48380: LD_VAR 0 5
48384: PPUSH
48385: CALL_OW 1
48389: ST_TO_ADDR
// break ;
48390: GO 48394
// end ; end ;
48392: GO 48322
48394: POP
48395: POP
// end ;
48396: LD_VAR 0 3
48400: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
48401: LD_INT 0
48403: PPUSH
48404: PPUSH
48405: PPUSH
// if not mc_bases or not skirmish then
48406: LD_EXP 78
48410: NOT
48411: PUSH
48412: LD_EXP 76
48416: NOT
48417: OR
48418: IFFALSE 48422
// exit ;
48420: GO 48621
// for i = 1 to mc_bases do
48422: LD_ADDR_VAR 0 5
48426: PUSH
48427: DOUBLE
48428: LD_INT 1
48430: DEC
48431: ST_TO_ADDR
48432: LD_EXP 78
48436: PUSH
48437: FOR_TO
48438: IFFALSE 48619
// if building in mc_bases [ i ] then
48440: LD_VAR 0 1
48444: PUSH
48445: LD_EXP 78
48449: PUSH
48450: LD_VAR 0 5
48454: ARRAY
48455: IN
48456: IFFALSE 48617
// begin tmp := mc_bases [ i ] diff building ;
48458: LD_ADDR_VAR 0 6
48462: PUSH
48463: LD_EXP 78
48467: PUSH
48468: LD_VAR 0 5
48472: ARRAY
48473: PUSH
48474: LD_VAR 0 1
48478: DIFF
48479: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
48480: LD_ADDR_EXP 78
48484: PUSH
48485: LD_EXP 78
48489: PPUSH
48490: LD_VAR 0 5
48494: PPUSH
48495: LD_VAR 0 6
48499: PPUSH
48500: CALL_OW 1
48504: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
48505: LD_VAR 0 1
48509: PUSH
48510: LD_EXP 86
48514: PUSH
48515: LD_VAR 0 5
48519: ARRAY
48520: IN
48521: IFFALSE 48560
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
48523: LD_ADDR_EXP 86
48527: PUSH
48528: LD_EXP 86
48532: PPUSH
48533: LD_VAR 0 5
48537: PPUSH
48538: LD_EXP 86
48542: PUSH
48543: LD_VAR 0 5
48547: ARRAY
48548: PUSH
48549: LD_VAR 0 1
48553: DIFF
48554: PPUSH
48555: CALL_OW 1
48559: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
48560: LD_VAR 0 1
48564: PUSH
48565: LD_EXP 87
48569: PUSH
48570: LD_VAR 0 5
48574: ARRAY
48575: IN
48576: IFFALSE 48615
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
48578: LD_ADDR_EXP 87
48582: PUSH
48583: LD_EXP 87
48587: PPUSH
48588: LD_VAR 0 5
48592: PPUSH
48593: LD_EXP 87
48597: PUSH
48598: LD_VAR 0 5
48602: ARRAY
48603: PUSH
48604: LD_VAR 0 1
48608: DIFF
48609: PPUSH
48610: CALL_OW 1
48614: ST_TO_ADDR
// break ;
48615: GO 48619
// end ;
48617: GO 48437
48619: POP
48620: POP
// end ;
48621: LD_VAR 0 4
48625: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
48626: LD_INT 0
48628: PPUSH
48629: PPUSH
48630: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
48631: LD_EXP 78
48635: NOT
48636: PUSH
48637: LD_EXP 76
48641: NOT
48642: OR
48643: PUSH
48644: LD_VAR 0 3
48648: PUSH
48649: LD_EXP 104
48653: IN
48654: NOT
48655: OR
48656: IFFALSE 48660
// exit ;
48658: GO 48783
// for i = 1 to mc_vehicles do
48660: LD_ADDR_VAR 0 6
48664: PUSH
48665: DOUBLE
48666: LD_INT 1
48668: DEC
48669: ST_TO_ADDR
48670: LD_EXP 97
48674: PUSH
48675: FOR_TO
48676: IFFALSE 48781
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
48678: LD_VAR 0 2
48682: PUSH
48683: LD_EXP 97
48687: PUSH
48688: LD_VAR 0 6
48692: ARRAY
48693: IN
48694: PUSH
48695: LD_VAR 0 1
48699: PUSH
48700: LD_EXP 97
48704: PUSH
48705: LD_VAR 0 6
48709: ARRAY
48710: IN
48711: OR
48712: IFFALSE 48779
// begin tmp := mc_vehicles [ i ] diff old ;
48714: LD_ADDR_VAR 0 7
48718: PUSH
48719: LD_EXP 97
48723: PUSH
48724: LD_VAR 0 6
48728: ARRAY
48729: PUSH
48730: LD_VAR 0 2
48734: DIFF
48735: ST_TO_ADDR
// tmp := tmp diff new ;
48736: LD_ADDR_VAR 0 7
48740: PUSH
48741: LD_VAR 0 7
48745: PUSH
48746: LD_VAR 0 1
48750: DIFF
48751: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
48752: LD_ADDR_EXP 97
48756: PUSH
48757: LD_EXP 97
48761: PPUSH
48762: LD_VAR 0 6
48766: PPUSH
48767: LD_VAR 0 7
48771: PPUSH
48772: CALL_OW 1
48776: ST_TO_ADDR
// break ;
48777: GO 48781
// end ;
48779: GO 48675
48781: POP
48782: POP
// end ;
48783: LD_VAR 0 5
48787: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
48788: LD_INT 0
48790: PPUSH
48791: PPUSH
48792: PPUSH
48793: PPUSH
// if not mc_bases or not skirmish then
48794: LD_EXP 78
48798: NOT
48799: PUSH
48800: LD_EXP 76
48804: NOT
48805: OR
48806: IFFALSE 48810
// exit ;
48808: GO 49230
// repeat wait ( 0 0$1 ) ;
48810: LD_INT 35
48812: PPUSH
48813: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
48817: LD_EXP 122
48821: NOT
48822: IFFALSE 48810
// mc_block_vehicle_constructed_thread := true ;
48824: LD_ADDR_EXP 122
48828: PUSH
48829: LD_INT 1
48831: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
48832: LD_ADDR_VAR 0 5
48836: PUSH
48837: LD_VAR 0 1
48841: PPUSH
48842: CALL_OW 255
48846: ST_TO_ADDR
// for i = 1 to mc_bases do
48847: LD_ADDR_VAR 0 4
48851: PUSH
48852: DOUBLE
48853: LD_INT 1
48855: DEC
48856: ST_TO_ADDR
48857: LD_EXP 78
48861: PUSH
48862: FOR_TO
48863: IFFALSE 49220
// begin if factory in mc_bases [ i ] then
48865: LD_VAR 0 2
48869: PUSH
48870: LD_EXP 78
48874: PUSH
48875: LD_VAR 0 4
48879: ARRAY
48880: IN
48881: IFFALSE 49218
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48883: LD_EXP 100
48887: PUSH
48888: LD_VAR 0 4
48892: ARRAY
48893: PUSH
48894: LD_EXP 89
48898: PUSH
48899: LD_VAR 0 4
48903: ARRAY
48904: LESS
48905: PUSH
48906: LD_VAR 0 1
48910: PPUSH
48911: CALL_OW 264
48915: PUSH
48916: LD_INT 31
48918: PUSH
48919: LD_INT 32
48921: PUSH
48922: LD_INT 51
48924: PUSH
48925: LD_INT 89
48927: PUSH
48928: LD_INT 12
48930: PUSH
48931: LD_INT 30
48933: PUSH
48934: LD_INT 98
48936: PUSH
48937: LD_INT 11
48939: PUSH
48940: LD_INT 53
48942: PUSH
48943: LD_INT 14
48945: PUSH
48946: LD_INT 91
48948: PUSH
48949: LD_INT 29
48951: PUSH
48952: LD_INT 99
48954: PUSH
48955: LD_INT 13
48957: PUSH
48958: LD_INT 52
48960: PUSH
48961: LD_INT 88
48963: PUSH
48964: LD_INT 48
48966: PUSH
48967: LD_INT 8
48969: PUSH
48970: EMPTY
48971: LIST
48972: LIST
48973: LIST
48974: LIST
48975: LIST
48976: LIST
48977: LIST
48978: LIST
48979: LIST
48980: LIST
48981: LIST
48982: LIST
48983: LIST
48984: LIST
48985: LIST
48986: LIST
48987: LIST
48988: LIST
48989: IN
48990: NOT
48991: AND
48992: IFFALSE 49040
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48994: LD_ADDR_EXP 100
48998: PUSH
48999: LD_EXP 100
49003: PPUSH
49004: LD_VAR 0 4
49008: PUSH
49009: LD_EXP 100
49013: PUSH
49014: LD_VAR 0 4
49018: ARRAY
49019: PUSH
49020: LD_INT 1
49022: PLUS
49023: PUSH
49024: EMPTY
49025: LIST
49026: LIST
49027: PPUSH
49028: LD_VAR 0 1
49032: PPUSH
49033: CALL 57865 0 3
49037: ST_TO_ADDR
49038: GO 49084
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
49040: LD_ADDR_EXP 97
49044: PUSH
49045: LD_EXP 97
49049: PPUSH
49050: LD_VAR 0 4
49054: PUSH
49055: LD_EXP 97
49059: PUSH
49060: LD_VAR 0 4
49064: ARRAY
49065: PUSH
49066: LD_INT 1
49068: PLUS
49069: PUSH
49070: EMPTY
49071: LIST
49072: LIST
49073: PPUSH
49074: LD_VAR 0 1
49078: PPUSH
49079: CALL 57865 0 3
49083: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
49084: LD_ADDR_EXP 122
49088: PUSH
49089: LD_INT 0
49091: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49092: LD_VAR 0 1
49096: PPUSH
49097: CALL_OW 263
49101: PUSH
49102: LD_INT 2
49104: EQUAL
49105: IFFALSE 49134
// begin repeat wait ( 0 0$3 ) ;
49107: LD_INT 105
49109: PPUSH
49110: CALL_OW 67
// Connect ( vehicle ) ;
49114: LD_VAR 0 1
49118: PPUSH
49119: CALL 61211 0 1
// until IsControledBy ( vehicle ) ;
49123: LD_VAR 0 1
49127: PPUSH
49128: CALL_OW 312
49132: IFFALSE 49107
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49134: LD_VAR 0 1
49138: PPUSH
49139: LD_EXP 102
49143: PUSH
49144: LD_VAR 0 4
49148: ARRAY
49149: PPUSH
49150: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49154: LD_VAR 0 1
49158: PPUSH
49159: CALL_OW 263
49163: PUSH
49164: LD_INT 1
49166: NONEQUAL
49167: IFFALSE 49171
// break ;
49169: GO 49220
// repeat wait ( 0 0$1 ) ;
49171: LD_INT 35
49173: PPUSH
49174: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
49178: LD_VAR 0 1
49182: PPUSH
49183: LD_EXP 102
49187: PUSH
49188: LD_VAR 0 4
49192: ARRAY
49193: PPUSH
49194: CALL_OW 308
49198: IFFALSE 49171
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
49200: LD_VAR 0 1
49204: PPUSH
49205: CALL_OW 311
49209: PPUSH
49210: CALL_OW 121
// exit ;
49214: POP
49215: POP
49216: GO 49230
// end ; end ;
49218: GO 48862
49220: POP
49221: POP
// mc_block_vehicle_constructed_thread := false ;
49222: LD_ADDR_EXP 122
49226: PUSH
49227: LD_INT 0
49229: ST_TO_ADDR
// end ;
49230: LD_VAR 0 3
49234: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
49235: LD_INT 0
49237: PPUSH
49238: PPUSH
49239: PPUSH
49240: PPUSH
// if not mc_bases or not skirmish then
49241: LD_EXP 78
49245: NOT
49246: PUSH
49247: LD_EXP 76
49251: NOT
49252: OR
49253: IFFALSE 49257
// exit ;
49255: GO 49610
// repeat wait ( 0 0$1 ) ;
49257: LD_INT 35
49259: PPUSH
49260: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
49264: LD_VAR 0 2
49268: PPUSH
49269: LD_VAR 0 3
49273: PPUSH
49274: CALL_OW 284
49278: IFFALSE 49257
// if GetResourceTypeXY ( x , y ) = mat_artefact then
49280: LD_VAR 0 2
49284: PPUSH
49285: LD_VAR 0 3
49289: PPUSH
49290: CALL_OW 283
49294: PUSH
49295: LD_INT 4
49297: EQUAL
49298: IFFALSE 49302
// exit ;
49300: GO 49610
// for i = 1 to mc_bases do
49302: LD_ADDR_VAR 0 7
49306: PUSH
49307: DOUBLE
49308: LD_INT 1
49310: DEC
49311: ST_TO_ADDR
49312: LD_EXP 78
49316: PUSH
49317: FOR_TO
49318: IFFALSE 49608
// begin if mc_crates_area [ i ] then
49320: LD_EXP 96
49324: PUSH
49325: LD_VAR 0 7
49329: ARRAY
49330: IFFALSE 49441
// for j in mc_crates_area [ i ] do
49332: LD_ADDR_VAR 0 8
49336: PUSH
49337: LD_EXP 96
49341: PUSH
49342: LD_VAR 0 7
49346: ARRAY
49347: PUSH
49348: FOR_IN
49349: IFFALSE 49439
// if InArea ( x , y , j ) then
49351: LD_VAR 0 2
49355: PPUSH
49356: LD_VAR 0 3
49360: PPUSH
49361: LD_VAR 0 8
49365: PPUSH
49366: CALL_OW 309
49370: IFFALSE 49437
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49372: LD_ADDR_EXP 94
49376: PUSH
49377: LD_EXP 94
49381: PPUSH
49382: LD_VAR 0 7
49386: PUSH
49387: LD_EXP 94
49391: PUSH
49392: LD_VAR 0 7
49396: ARRAY
49397: PUSH
49398: LD_INT 1
49400: PLUS
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: PPUSH
49406: LD_VAR 0 4
49410: PUSH
49411: LD_VAR 0 2
49415: PUSH
49416: LD_VAR 0 3
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: LIST
49425: PPUSH
49426: CALL 57865 0 3
49430: ST_TO_ADDR
// exit ;
49431: POP
49432: POP
49433: POP
49434: POP
49435: GO 49610
// end ;
49437: GO 49348
49439: POP
49440: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49441: LD_ADDR_VAR 0 9
49445: PUSH
49446: LD_EXP 78
49450: PUSH
49451: LD_VAR 0 7
49455: ARRAY
49456: PPUSH
49457: LD_INT 2
49459: PUSH
49460: LD_INT 30
49462: PUSH
49463: LD_INT 0
49465: PUSH
49466: EMPTY
49467: LIST
49468: LIST
49469: PUSH
49470: LD_INT 30
49472: PUSH
49473: LD_INT 1
49475: PUSH
49476: EMPTY
49477: LIST
49478: LIST
49479: PUSH
49480: EMPTY
49481: LIST
49482: LIST
49483: LIST
49484: PPUSH
49485: CALL_OW 72
49489: ST_TO_ADDR
// if not depot then
49490: LD_VAR 0 9
49494: NOT
49495: IFFALSE 49499
// continue ;
49497: GO 49317
// for j in depot do
49499: LD_ADDR_VAR 0 8
49503: PUSH
49504: LD_VAR 0 9
49508: PUSH
49509: FOR_IN
49510: IFFALSE 49604
// if GetDistUnitXY ( j , x , y ) < 30 then
49512: LD_VAR 0 8
49516: PPUSH
49517: LD_VAR 0 2
49521: PPUSH
49522: LD_VAR 0 3
49526: PPUSH
49527: CALL_OW 297
49531: PUSH
49532: LD_INT 30
49534: LESS
49535: IFFALSE 49602
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49537: LD_ADDR_EXP 94
49541: PUSH
49542: LD_EXP 94
49546: PPUSH
49547: LD_VAR 0 7
49551: PUSH
49552: LD_EXP 94
49556: PUSH
49557: LD_VAR 0 7
49561: ARRAY
49562: PUSH
49563: LD_INT 1
49565: PLUS
49566: PUSH
49567: EMPTY
49568: LIST
49569: LIST
49570: PPUSH
49571: LD_VAR 0 4
49575: PUSH
49576: LD_VAR 0 2
49580: PUSH
49581: LD_VAR 0 3
49585: PUSH
49586: EMPTY
49587: LIST
49588: LIST
49589: LIST
49590: PPUSH
49591: CALL 57865 0 3
49595: ST_TO_ADDR
// exit ;
49596: POP
49597: POP
49598: POP
49599: POP
49600: GO 49610
// end ;
49602: GO 49509
49604: POP
49605: POP
// end ;
49606: GO 49317
49608: POP
49609: POP
// end ;
49610: LD_VAR 0 6
49614: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
49615: LD_INT 0
49617: PPUSH
49618: PPUSH
49619: PPUSH
49620: PPUSH
// if not mc_bases or not skirmish then
49621: LD_EXP 78
49625: NOT
49626: PUSH
49627: LD_EXP 76
49631: NOT
49632: OR
49633: IFFALSE 49637
// exit ;
49635: GO 49914
// side := GetSide ( lab ) ;
49637: LD_ADDR_VAR 0 4
49641: PUSH
49642: LD_VAR 0 2
49646: PPUSH
49647: CALL_OW 255
49651: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
49652: LD_VAR 0 4
49656: PUSH
49657: LD_EXP 104
49661: IN
49662: NOT
49663: PUSH
49664: LD_EXP 105
49668: NOT
49669: OR
49670: PUSH
49671: LD_EXP 78
49675: NOT
49676: OR
49677: IFFALSE 49681
// exit ;
49679: GO 49914
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
49681: LD_ADDR_EXP 105
49685: PUSH
49686: LD_EXP 105
49690: PPUSH
49691: LD_VAR 0 4
49695: PPUSH
49696: LD_EXP 105
49700: PUSH
49701: LD_VAR 0 4
49705: ARRAY
49706: PUSH
49707: LD_VAR 0 1
49711: DIFF
49712: PPUSH
49713: CALL_OW 1
49717: ST_TO_ADDR
// for i = 1 to mc_bases do
49718: LD_ADDR_VAR 0 5
49722: PUSH
49723: DOUBLE
49724: LD_INT 1
49726: DEC
49727: ST_TO_ADDR
49728: LD_EXP 78
49732: PUSH
49733: FOR_TO
49734: IFFALSE 49912
// begin if lab in mc_bases [ i ] then
49736: LD_VAR 0 2
49740: PUSH
49741: LD_EXP 78
49745: PUSH
49746: LD_VAR 0 5
49750: ARRAY
49751: IN
49752: IFFALSE 49910
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
49754: LD_VAR 0 1
49758: PUSH
49759: LD_INT 11
49761: PUSH
49762: LD_INT 4
49764: PUSH
49765: LD_INT 3
49767: PUSH
49768: LD_INT 2
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: LIST
49775: LIST
49776: IN
49777: PUSH
49778: LD_EXP 108
49782: PUSH
49783: LD_VAR 0 5
49787: ARRAY
49788: AND
49789: IFFALSE 49910
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
49791: LD_ADDR_VAR 0 6
49795: PUSH
49796: LD_EXP 108
49800: PUSH
49801: LD_VAR 0 5
49805: ARRAY
49806: PUSH
49807: LD_INT 1
49809: ARRAY
49810: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49811: LD_ADDR_EXP 108
49815: PUSH
49816: LD_EXP 108
49820: PPUSH
49821: LD_VAR 0 5
49825: PPUSH
49826: EMPTY
49827: PPUSH
49828: CALL_OW 1
49832: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
49833: LD_VAR 0 6
49837: PPUSH
49838: LD_INT 0
49840: PPUSH
49841: CALL_OW 109
// ComExitBuilding ( tmp ) ;
49845: LD_VAR 0 6
49849: PPUSH
49850: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
49854: LD_ADDR_EXP 107
49858: PUSH
49859: LD_EXP 107
49863: PPUSH
49864: LD_VAR 0 5
49868: PPUSH
49869: LD_EXP 107
49873: PUSH
49874: LD_VAR 0 5
49878: ARRAY
49879: PPUSH
49880: LD_INT 1
49882: PPUSH
49883: LD_VAR 0 6
49887: PPUSH
49888: CALL_OW 2
49892: PPUSH
49893: CALL_OW 1
49897: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49898: LD_VAR 0 5
49902: PPUSH
49903: LD_INT 112
49905: PPUSH
49906: CALL 26364 0 2
// end ; end ; end ;
49910: GO 49733
49912: POP
49913: POP
// end ;
49914: LD_VAR 0 3
49918: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49919: LD_INT 0
49921: PPUSH
49922: PPUSH
49923: PPUSH
49924: PPUSH
49925: PPUSH
49926: PPUSH
49927: PPUSH
49928: PPUSH
// if not mc_bases or not skirmish then
49929: LD_EXP 78
49933: NOT
49934: PUSH
49935: LD_EXP 76
49939: NOT
49940: OR
49941: IFFALSE 49945
// exit ;
49943: GO 51314
// for i = 1 to mc_bases do
49945: LD_ADDR_VAR 0 3
49949: PUSH
49950: DOUBLE
49951: LD_INT 1
49953: DEC
49954: ST_TO_ADDR
49955: LD_EXP 78
49959: PUSH
49960: FOR_TO
49961: IFFALSE 51312
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49963: LD_VAR 0 1
49967: PUSH
49968: LD_EXP 78
49972: PUSH
49973: LD_VAR 0 3
49977: ARRAY
49978: IN
49979: PUSH
49980: LD_VAR 0 1
49984: PUSH
49985: LD_EXP 85
49989: PUSH
49990: LD_VAR 0 3
49994: ARRAY
49995: IN
49996: OR
49997: PUSH
49998: LD_VAR 0 1
50002: PUSH
50003: LD_EXP 100
50007: PUSH
50008: LD_VAR 0 3
50012: ARRAY
50013: IN
50014: OR
50015: PUSH
50016: LD_VAR 0 1
50020: PUSH
50021: LD_EXP 97
50025: PUSH
50026: LD_VAR 0 3
50030: ARRAY
50031: IN
50032: OR
50033: PUSH
50034: LD_VAR 0 1
50038: PUSH
50039: LD_EXP 107
50043: PUSH
50044: LD_VAR 0 3
50048: ARRAY
50049: IN
50050: OR
50051: PUSH
50052: LD_VAR 0 1
50056: PUSH
50057: LD_EXP 108
50061: PUSH
50062: LD_VAR 0 3
50066: ARRAY
50067: IN
50068: OR
50069: IFFALSE 51310
// begin if un in mc_ape [ i ] then
50071: LD_VAR 0 1
50075: PUSH
50076: LD_EXP 107
50080: PUSH
50081: LD_VAR 0 3
50085: ARRAY
50086: IN
50087: IFFALSE 50126
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
50089: LD_ADDR_EXP 107
50093: PUSH
50094: LD_EXP 107
50098: PPUSH
50099: LD_VAR 0 3
50103: PPUSH
50104: LD_EXP 107
50108: PUSH
50109: LD_VAR 0 3
50113: ARRAY
50114: PUSH
50115: LD_VAR 0 1
50119: DIFF
50120: PPUSH
50121: CALL_OW 1
50125: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50126: LD_VAR 0 1
50130: PUSH
50131: LD_EXP 108
50135: PUSH
50136: LD_VAR 0 3
50140: ARRAY
50141: IN
50142: IFFALSE 50166
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50144: LD_ADDR_EXP 108
50148: PUSH
50149: LD_EXP 108
50153: PPUSH
50154: LD_VAR 0 3
50158: PPUSH
50159: EMPTY
50160: PPUSH
50161: CALL_OW 1
50165: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50166: LD_VAR 0 1
50170: PPUSH
50171: CALL_OW 247
50175: PUSH
50176: LD_INT 2
50178: EQUAL
50179: PUSH
50180: LD_VAR 0 1
50184: PPUSH
50185: CALL_OW 110
50189: PUSH
50190: LD_INT 20
50192: EQUAL
50193: PUSH
50194: LD_VAR 0 1
50198: PUSH
50199: LD_EXP 100
50203: PUSH
50204: LD_VAR 0 3
50208: ARRAY
50209: IN
50210: OR
50211: PUSH
50212: LD_VAR 0 1
50216: PPUSH
50217: CALL_OW 264
50221: PUSH
50222: LD_INT 12
50224: PUSH
50225: LD_INT 51
50227: PUSH
50228: LD_INT 89
50230: PUSH
50231: LD_INT 32
50233: PUSH
50234: LD_INT 13
50236: PUSH
50237: LD_INT 52
50239: PUSH
50240: LD_INT 31
50242: PUSH
50243: EMPTY
50244: LIST
50245: LIST
50246: LIST
50247: LIST
50248: LIST
50249: LIST
50250: LIST
50251: IN
50252: OR
50253: AND
50254: IFFALSE 50562
// begin if un in mc_defender [ i ] then
50256: LD_VAR 0 1
50260: PUSH
50261: LD_EXP 100
50265: PUSH
50266: LD_VAR 0 3
50270: ARRAY
50271: IN
50272: IFFALSE 50311
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50274: LD_ADDR_EXP 100
50278: PUSH
50279: LD_EXP 100
50283: PPUSH
50284: LD_VAR 0 3
50288: PPUSH
50289: LD_EXP 100
50293: PUSH
50294: LD_VAR 0 3
50298: ARRAY
50299: PUSH
50300: LD_VAR 0 1
50304: DIFF
50305: PPUSH
50306: CALL_OW 1
50310: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
50311: LD_ADDR_VAR 0 8
50315: PUSH
50316: LD_VAR 0 3
50320: PPUSH
50321: LD_INT 3
50323: PPUSH
50324: CALL 46932 0 2
50328: ST_TO_ADDR
// if fac then
50329: LD_VAR 0 8
50333: IFFALSE 50562
// begin for j in fac do
50335: LD_ADDR_VAR 0 4
50339: PUSH
50340: LD_VAR 0 8
50344: PUSH
50345: FOR_IN
50346: IFFALSE 50560
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
50348: LD_ADDR_VAR 0 9
50352: PUSH
50353: LD_VAR 0 8
50357: PPUSH
50358: LD_VAR 0 1
50362: PPUSH
50363: CALL_OW 265
50367: PPUSH
50368: LD_VAR 0 1
50372: PPUSH
50373: CALL_OW 262
50377: PPUSH
50378: LD_VAR 0 1
50382: PPUSH
50383: CALL_OW 263
50387: PPUSH
50388: LD_VAR 0 1
50392: PPUSH
50393: CALL_OW 264
50397: PPUSH
50398: CALL 55363 0 5
50402: ST_TO_ADDR
// if components then
50403: LD_VAR 0 9
50407: IFFALSE 50558
// begin if GetWeapon ( un ) = ar_control_tower then
50409: LD_VAR 0 1
50413: PPUSH
50414: CALL_OW 264
50418: PUSH
50419: LD_INT 31
50421: EQUAL
50422: IFFALSE 50539
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
50424: LD_VAR 0 1
50428: PPUSH
50429: CALL_OW 311
50433: PPUSH
50434: LD_INT 0
50436: PPUSH
50437: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
50441: LD_ADDR_EXP 118
50445: PUSH
50446: LD_EXP 118
50450: PPUSH
50451: LD_VAR 0 3
50455: PPUSH
50456: LD_EXP 118
50460: PUSH
50461: LD_VAR 0 3
50465: ARRAY
50466: PUSH
50467: LD_VAR 0 1
50471: PPUSH
50472: CALL_OW 311
50476: DIFF
50477: PPUSH
50478: CALL_OW 1
50482: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
50483: LD_ADDR_VAR 0 7
50487: PUSH
50488: LD_EXP 99
50492: PUSH
50493: LD_VAR 0 3
50497: ARRAY
50498: PPUSH
50499: LD_INT 1
50501: PPUSH
50502: LD_VAR 0 9
50506: PPUSH
50507: CALL_OW 2
50511: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50512: LD_ADDR_EXP 99
50516: PUSH
50517: LD_EXP 99
50521: PPUSH
50522: LD_VAR 0 3
50526: PPUSH
50527: LD_VAR 0 7
50531: PPUSH
50532: CALL_OW 1
50536: ST_TO_ADDR
// end else
50537: GO 50556
// MC_InsertProduceList ( i , [ components ] ) ;
50539: LD_VAR 0 3
50543: PPUSH
50544: LD_VAR 0 9
50548: PUSH
50549: EMPTY
50550: LIST
50551: PPUSH
50552: CALL 46477 0 2
// break ;
50556: GO 50560
// end ; end ;
50558: GO 50345
50560: POP
50561: POP
// end ; end ; if GetType ( un ) = unit_building then
50562: LD_VAR 0 1
50566: PPUSH
50567: CALL_OW 247
50571: PUSH
50572: LD_INT 3
50574: EQUAL
50575: IFFALSE 50978
// begin btype := GetBType ( un ) ;
50577: LD_ADDR_VAR 0 5
50581: PUSH
50582: LD_VAR 0 1
50586: PPUSH
50587: CALL_OW 266
50591: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
50592: LD_VAR 0 5
50596: PUSH
50597: LD_INT 29
50599: PUSH
50600: LD_INT 30
50602: PUSH
50603: EMPTY
50604: LIST
50605: LIST
50606: IN
50607: IFFALSE 50680
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
50609: LD_VAR 0 1
50613: PPUSH
50614: CALL_OW 250
50618: PPUSH
50619: LD_VAR 0 1
50623: PPUSH
50624: CALL_OW 251
50628: PPUSH
50629: LD_VAR 0 1
50633: PPUSH
50634: CALL_OW 255
50638: PPUSH
50639: CALL_OW 440
50643: NOT
50644: IFFALSE 50680
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
50646: LD_VAR 0 1
50650: PPUSH
50651: CALL_OW 250
50655: PPUSH
50656: LD_VAR 0 1
50660: PPUSH
50661: CALL_OW 251
50665: PPUSH
50666: LD_VAR 0 1
50670: PPUSH
50671: CALL_OW 255
50675: PPUSH
50676: CALL_OW 441
// end ; if btype = b_warehouse then
50680: LD_VAR 0 5
50684: PUSH
50685: LD_INT 1
50687: EQUAL
50688: IFFALSE 50706
// begin btype := b_depot ;
50690: LD_ADDR_VAR 0 5
50694: PUSH
50695: LD_INT 0
50697: ST_TO_ADDR
// pos := 1 ;
50698: LD_ADDR_VAR 0 6
50702: PUSH
50703: LD_INT 1
50705: ST_TO_ADDR
// end ; if btype = b_factory then
50706: LD_VAR 0 5
50710: PUSH
50711: LD_INT 3
50713: EQUAL
50714: IFFALSE 50732
// begin btype := b_workshop ;
50716: LD_ADDR_VAR 0 5
50720: PUSH
50721: LD_INT 2
50723: ST_TO_ADDR
// pos := 1 ;
50724: LD_ADDR_VAR 0 6
50728: PUSH
50729: LD_INT 1
50731: ST_TO_ADDR
// end ; if btype = b_barracks then
50732: LD_VAR 0 5
50736: PUSH
50737: LD_INT 5
50739: EQUAL
50740: IFFALSE 50750
// btype := b_armoury ;
50742: LD_ADDR_VAR 0 5
50746: PUSH
50747: LD_INT 4
50749: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
50750: LD_VAR 0 5
50754: PUSH
50755: LD_INT 7
50757: PUSH
50758: LD_INT 8
50760: PUSH
50761: EMPTY
50762: LIST
50763: LIST
50764: IN
50765: IFFALSE 50775
// btype := b_lab ;
50767: LD_ADDR_VAR 0 5
50771: PUSH
50772: LD_INT 6
50774: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
50775: LD_ADDR_EXP 83
50779: PUSH
50780: LD_EXP 83
50784: PPUSH
50785: LD_VAR 0 3
50789: PUSH
50790: LD_EXP 83
50794: PUSH
50795: LD_VAR 0 3
50799: ARRAY
50800: PUSH
50801: LD_INT 1
50803: PLUS
50804: PUSH
50805: EMPTY
50806: LIST
50807: LIST
50808: PPUSH
50809: LD_VAR 0 5
50813: PUSH
50814: LD_VAR 0 1
50818: PPUSH
50819: CALL_OW 250
50823: PUSH
50824: LD_VAR 0 1
50828: PPUSH
50829: CALL_OW 251
50833: PUSH
50834: LD_VAR 0 1
50838: PPUSH
50839: CALL_OW 254
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: LIST
50848: LIST
50849: PPUSH
50850: CALL 57865 0 3
50854: ST_TO_ADDR
// if pos = 1 then
50855: LD_VAR 0 6
50859: PUSH
50860: LD_INT 1
50862: EQUAL
50863: IFFALSE 50978
// begin tmp := mc_build_list [ i ] ;
50865: LD_ADDR_VAR 0 7
50869: PUSH
50870: LD_EXP 83
50874: PUSH
50875: LD_VAR 0 3
50879: ARRAY
50880: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50881: LD_VAR 0 7
50885: PPUSH
50886: LD_INT 2
50888: PUSH
50889: LD_INT 30
50891: PUSH
50892: LD_INT 0
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: PUSH
50899: LD_INT 30
50901: PUSH
50902: LD_INT 1
50904: PUSH
50905: EMPTY
50906: LIST
50907: LIST
50908: PUSH
50909: EMPTY
50910: LIST
50911: LIST
50912: LIST
50913: PPUSH
50914: CALL_OW 72
50918: IFFALSE 50928
// pos := 2 ;
50920: LD_ADDR_VAR 0 6
50924: PUSH
50925: LD_INT 2
50927: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50928: LD_ADDR_VAR 0 7
50932: PUSH
50933: LD_VAR 0 7
50937: PPUSH
50938: LD_VAR 0 6
50942: PPUSH
50943: LD_VAR 0 7
50947: PPUSH
50948: CALL 58191 0 3
50952: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50953: LD_ADDR_EXP 83
50957: PUSH
50958: LD_EXP 83
50962: PPUSH
50963: LD_VAR 0 3
50967: PPUSH
50968: LD_VAR 0 7
50972: PPUSH
50973: CALL_OW 1
50977: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50978: LD_VAR 0 1
50982: PUSH
50983: LD_EXP 78
50987: PUSH
50988: LD_VAR 0 3
50992: ARRAY
50993: IN
50994: IFFALSE 51033
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50996: LD_ADDR_EXP 78
51000: PUSH
51001: LD_EXP 78
51005: PPUSH
51006: LD_VAR 0 3
51010: PPUSH
51011: LD_EXP 78
51015: PUSH
51016: LD_VAR 0 3
51020: ARRAY
51021: PUSH
51022: LD_VAR 0 1
51026: DIFF
51027: PPUSH
51028: CALL_OW 1
51032: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
51033: LD_VAR 0 1
51037: PUSH
51038: LD_EXP 85
51042: PUSH
51043: LD_VAR 0 3
51047: ARRAY
51048: IN
51049: IFFALSE 51088
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
51051: LD_ADDR_EXP 85
51055: PUSH
51056: LD_EXP 85
51060: PPUSH
51061: LD_VAR 0 3
51065: PPUSH
51066: LD_EXP 85
51070: PUSH
51071: LD_VAR 0 3
51075: ARRAY
51076: PUSH
51077: LD_VAR 0 1
51081: DIFF
51082: PPUSH
51083: CALL_OW 1
51087: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
51088: LD_VAR 0 1
51092: PUSH
51093: LD_EXP 97
51097: PUSH
51098: LD_VAR 0 3
51102: ARRAY
51103: IN
51104: IFFALSE 51143
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51106: LD_ADDR_EXP 97
51110: PUSH
51111: LD_EXP 97
51115: PPUSH
51116: LD_VAR 0 3
51120: PPUSH
51121: LD_EXP 97
51125: PUSH
51126: LD_VAR 0 3
51130: ARRAY
51131: PUSH
51132: LD_VAR 0 1
51136: DIFF
51137: PPUSH
51138: CALL_OW 1
51142: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51143: LD_VAR 0 1
51147: PUSH
51148: LD_EXP 100
51152: PUSH
51153: LD_VAR 0 3
51157: ARRAY
51158: IN
51159: IFFALSE 51198
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51161: LD_ADDR_EXP 100
51165: PUSH
51166: LD_EXP 100
51170: PPUSH
51171: LD_VAR 0 3
51175: PPUSH
51176: LD_EXP 100
51180: PUSH
51181: LD_VAR 0 3
51185: ARRAY
51186: PUSH
51187: LD_VAR 0 1
51191: DIFF
51192: PPUSH
51193: CALL_OW 1
51197: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
51198: LD_VAR 0 1
51202: PUSH
51203: LD_EXP 87
51207: PUSH
51208: LD_VAR 0 3
51212: ARRAY
51213: IN
51214: IFFALSE 51253
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
51216: LD_ADDR_EXP 87
51220: PUSH
51221: LD_EXP 87
51225: PPUSH
51226: LD_VAR 0 3
51230: PPUSH
51231: LD_EXP 87
51235: PUSH
51236: LD_VAR 0 3
51240: ARRAY
51241: PUSH
51242: LD_VAR 0 1
51246: DIFF
51247: PPUSH
51248: CALL_OW 1
51252: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
51253: LD_VAR 0 1
51257: PUSH
51258: LD_EXP 86
51262: PUSH
51263: LD_VAR 0 3
51267: ARRAY
51268: IN
51269: IFFALSE 51308
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
51271: LD_ADDR_EXP 86
51275: PUSH
51276: LD_EXP 86
51280: PPUSH
51281: LD_VAR 0 3
51285: PPUSH
51286: LD_EXP 86
51290: PUSH
51291: LD_VAR 0 3
51295: ARRAY
51296: PUSH
51297: LD_VAR 0 1
51301: DIFF
51302: PPUSH
51303: CALL_OW 1
51307: ST_TO_ADDR
// end ; break ;
51308: GO 51312
// end ;
51310: GO 49960
51312: POP
51313: POP
// end ;
51314: LD_VAR 0 2
51318: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
51319: LD_INT 0
51321: PPUSH
51322: PPUSH
51323: PPUSH
// if not mc_bases or not skirmish then
51324: LD_EXP 78
51328: NOT
51329: PUSH
51330: LD_EXP 76
51334: NOT
51335: OR
51336: IFFALSE 51340
// exit ;
51338: GO 51555
// for i = 1 to mc_bases do
51340: LD_ADDR_VAR 0 3
51344: PUSH
51345: DOUBLE
51346: LD_INT 1
51348: DEC
51349: ST_TO_ADDR
51350: LD_EXP 78
51354: PUSH
51355: FOR_TO
51356: IFFALSE 51553
// begin if building in mc_construct_list [ i ] then
51358: LD_VAR 0 1
51362: PUSH
51363: LD_EXP 85
51367: PUSH
51368: LD_VAR 0 3
51372: ARRAY
51373: IN
51374: IFFALSE 51551
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51376: LD_ADDR_EXP 85
51380: PUSH
51381: LD_EXP 85
51385: PPUSH
51386: LD_VAR 0 3
51390: PPUSH
51391: LD_EXP 85
51395: PUSH
51396: LD_VAR 0 3
51400: ARRAY
51401: PUSH
51402: LD_VAR 0 1
51406: DIFF
51407: PPUSH
51408: CALL_OW 1
51412: ST_TO_ADDR
// if building in mc_lab [ i ] then
51413: LD_VAR 0 1
51417: PUSH
51418: LD_EXP 111
51422: PUSH
51423: LD_VAR 0 3
51427: ARRAY
51428: IN
51429: IFFALSE 51484
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
51431: LD_ADDR_EXP 112
51435: PUSH
51436: LD_EXP 112
51440: PPUSH
51441: LD_VAR 0 3
51445: PPUSH
51446: LD_EXP 112
51450: PUSH
51451: LD_VAR 0 3
51455: ARRAY
51456: PPUSH
51457: LD_INT 1
51459: PPUSH
51460: LD_EXP 112
51464: PUSH
51465: LD_VAR 0 3
51469: ARRAY
51470: PPUSH
51471: LD_INT 0
51473: PPUSH
51474: CALL 57283 0 4
51478: PPUSH
51479: CALL_OW 1
51483: ST_TO_ADDR
// if not building in mc_bases [ i ] then
51484: LD_VAR 0 1
51488: PUSH
51489: LD_EXP 78
51493: PUSH
51494: LD_VAR 0 3
51498: ARRAY
51499: IN
51500: NOT
51501: IFFALSE 51547
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51503: LD_ADDR_EXP 78
51507: PUSH
51508: LD_EXP 78
51512: PPUSH
51513: LD_VAR 0 3
51517: PUSH
51518: LD_EXP 78
51522: PUSH
51523: LD_VAR 0 3
51527: ARRAY
51528: PUSH
51529: LD_INT 1
51531: PLUS
51532: PUSH
51533: EMPTY
51534: LIST
51535: LIST
51536: PPUSH
51537: LD_VAR 0 1
51541: PPUSH
51542: CALL 57865 0 3
51546: ST_TO_ADDR
// exit ;
51547: POP
51548: POP
51549: GO 51555
// end ; end ;
51551: GO 51355
51553: POP
51554: POP
// end ;
51555: LD_VAR 0 2
51559: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
51560: LD_INT 0
51562: PPUSH
51563: PPUSH
51564: PPUSH
51565: PPUSH
51566: PPUSH
51567: PPUSH
51568: PPUSH
// if not mc_bases or not skirmish then
51569: LD_EXP 78
51573: NOT
51574: PUSH
51575: LD_EXP 76
51579: NOT
51580: OR
51581: IFFALSE 51585
// exit ;
51583: GO 52246
// for i = 1 to mc_bases do
51585: LD_ADDR_VAR 0 3
51589: PUSH
51590: DOUBLE
51591: LD_INT 1
51593: DEC
51594: ST_TO_ADDR
51595: LD_EXP 78
51599: PUSH
51600: FOR_TO
51601: IFFALSE 52244
// begin if building in mc_construct_list [ i ] then
51603: LD_VAR 0 1
51607: PUSH
51608: LD_EXP 85
51612: PUSH
51613: LD_VAR 0 3
51617: ARRAY
51618: IN
51619: IFFALSE 52242
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51621: LD_ADDR_EXP 85
51625: PUSH
51626: LD_EXP 85
51630: PPUSH
51631: LD_VAR 0 3
51635: PPUSH
51636: LD_EXP 85
51640: PUSH
51641: LD_VAR 0 3
51645: ARRAY
51646: PUSH
51647: LD_VAR 0 1
51651: DIFF
51652: PPUSH
51653: CALL_OW 1
51657: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51658: LD_ADDR_EXP 78
51662: PUSH
51663: LD_EXP 78
51667: PPUSH
51668: LD_VAR 0 3
51672: PUSH
51673: LD_EXP 78
51677: PUSH
51678: LD_VAR 0 3
51682: ARRAY
51683: PUSH
51684: LD_INT 1
51686: PLUS
51687: PUSH
51688: EMPTY
51689: LIST
51690: LIST
51691: PPUSH
51692: LD_VAR 0 1
51696: PPUSH
51697: CALL 57865 0 3
51701: ST_TO_ADDR
// btype := GetBType ( building ) ;
51702: LD_ADDR_VAR 0 5
51706: PUSH
51707: LD_VAR 0 1
51711: PPUSH
51712: CALL_OW 266
51716: ST_TO_ADDR
// side := GetSide ( building ) ;
51717: LD_ADDR_VAR 0 8
51721: PUSH
51722: LD_VAR 0 1
51726: PPUSH
51727: CALL_OW 255
51731: ST_TO_ADDR
// if btype = b_lab then
51732: LD_VAR 0 5
51736: PUSH
51737: LD_INT 6
51739: EQUAL
51740: IFFALSE 51790
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
51742: LD_ADDR_EXP 111
51746: PUSH
51747: LD_EXP 111
51751: PPUSH
51752: LD_VAR 0 3
51756: PUSH
51757: LD_EXP 111
51761: PUSH
51762: LD_VAR 0 3
51766: ARRAY
51767: PUSH
51768: LD_INT 1
51770: PLUS
51771: PUSH
51772: EMPTY
51773: LIST
51774: LIST
51775: PPUSH
51776: LD_VAR 0 1
51780: PPUSH
51781: CALL 57865 0 3
51785: ST_TO_ADDR
// exit ;
51786: POP
51787: POP
51788: GO 52246
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
51790: LD_VAR 0 5
51794: PUSH
51795: LD_INT 0
51797: PUSH
51798: LD_INT 2
51800: PUSH
51801: LD_INT 4
51803: PUSH
51804: EMPTY
51805: LIST
51806: LIST
51807: LIST
51808: IN
51809: IFFALSE 51933
// begin if btype = b_armoury then
51811: LD_VAR 0 5
51815: PUSH
51816: LD_INT 4
51818: EQUAL
51819: IFFALSE 51829
// btype := b_barracks ;
51821: LD_ADDR_VAR 0 5
51825: PUSH
51826: LD_INT 5
51828: ST_TO_ADDR
// if btype = b_depot then
51829: LD_VAR 0 5
51833: PUSH
51834: LD_INT 0
51836: EQUAL
51837: IFFALSE 51847
// btype := b_warehouse ;
51839: LD_ADDR_VAR 0 5
51843: PUSH
51844: LD_INT 1
51846: ST_TO_ADDR
// if btype = b_workshop then
51847: LD_VAR 0 5
51851: PUSH
51852: LD_INT 2
51854: EQUAL
51855: IFFALSE 51865
// btype := b_factory ;
51857: LD_ADDR_VAR 0 5
51861: PUSH
51862: LD_INT 3
51864: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
51865: LD_VAR 0 5
51869: PPUSH
51870: LD_VAR 0 8
51874: PPUSH
51875: CALL_OW 323
51879: PUSH
51880: LD_INT 1
51882: EQUAL
51883: IFFALSE 51929
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51885: LD_ADDR_EXP 110
51889: PUSH
51890: LD_EXP 110
51894: PPUSH
51895: LD_VAR 0 3
51899: PUSH
51900: LD_EXP 110
51904: PUSH
51905: LD_VAR 0 3
51909: ARRAY
51910: PUSH
51911: LD_INT 1
51913: PLUS
51914: PUSH
51915: EMPTY
51916: LIST
51917: LIST
51918: PPUSH
51919: LD_VAR 0 1
51923: PPUSH
51924: CALL 57865 0 3
51928: ST_TO_ADDR
// exit ;
51929: POP
51930: POP
51931: GO 52246
// end ; if btype in [ b_bunker , b_turret ] then
51933: LD_VAR 0 5
51937: PUSH
51938: LD_INT 32
51940: PUSH
51941: LD_INT 33
51943: PUSH
51944: EMPTY
51945: LIST
51946: LIST
51947: IN
51948: IFFALSE 52238
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51950: LD_ADDR_EXP 86
51954: PUSH
51955: LD_EXP 86
51959: PPUSH
51960: LD_VAR 0 3
51964: PUSH
51965: LD_EXP 86
51969: PUSH
51970: LD_VAR 0 3
51974: ARRAY
51975: PUSH
51976: LD_INT 1
51978: PLUS
51979: PUSH
51980: EMPTY
51981: LIST
51982: LIST
51983: PPUSH
51984: LD_VAR 0 1
51988: PPUSH
51989: CALL 57865 0 3
51993: ST_TO_ADDR
// if btype = b_bunker then
51994: LD_VAR 0 5
51998: PUSH
51999: LD_INT 32
52001: EQUAL
52002: IFFALSE 52238
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52004: LD_ADDR_EXP 87
52008: PUSH
52009: LD_EXP 87
52013: PPUSH
52014: LD_VAR 0 3
52018: PUSH
52019: LD_EXP 87
52023: PUSH
52024: LD_VAR 0 3
52028: ARRAY
52029: PUSH
52030: LD_INT 1
52032: PLUS
52033: PUSH
52034: EMPTY
52035: LIST
52036: LIST
52037: PPUSH
52038: LD_VAR 0 1
52042: PPUSH
52043: CALL 57865 0 3
52047: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
52048: LD_ADDR_VAR 0 6
52052: PUSH
52053: LD_EXP 78
52057: PUSH
52058: LD_VAR 0 3
52062: ARRAY
52063: PPUSH
52064: LD_INT 25
52066: PUSH
52067: LD_INT 1
52069: PUSH
52070: EMPTY
52071: LIST
52072: LIST
52073: PUSH
52074: LD_INT 3
52076: PUSH
52077: LD_INT 54
52079: PUSH
52080: EMPTY
52081: LIST
52082: PUSH
52083: EMPTY
52084: LIST
52085: LIST
52086: PUSH
52087: EMPTY
52088: LIST
52089: LIST
52090: PPUSH
52091: CALL_OW 72
52095: ST_TO_ADDR
// if tmp then
52096: LD_VAR 0 6
52100: IFFALSE 52106
// exit ;
52102: POP
52103: POP
52104: GO 52246
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52106: LD_ADDR_VAR 0 6
52110: PUSH
52111: LD_EXP 78
52115: PUSH
52116: LD_VAR 0 3
52120: ARRAY
52121: PPUSH
52122: LD_INT 2
52124: PUSH
52125: LD_INT 30
52127: PUSH
52128: LD_INT 4
52130: PUSH
52131: EMPTY
52132: LIST
52133: LIST
52134: PUSH
52135: LD_INT 30
52137: PUSH
52138: LD_INT 5
52140: PUSH
52141: EMPTY
52142: LIST
52143: LIST
52144: PUSH
52145: EMPTY
52146: LIST
52147: LIST
52148: LIST
52149: PPUSH
52150: CALL_OW 72
52154: ST_TO_ADDR
// if not tmp then
52155: LD_VAR 0 6
52159: NOT
52160: IFFALSE 52166
// exit ;
52162: POP
52163: POP
52164: GO 52246
// for j in tmp do
52166: LD_ADDR_VAR 0 4
52170: PUSH
52171: LD_VAR 0 6
52175: PUSH
52176: FOR_IN
52177: IFFALSE 52236
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
52179: LD_ADDR_VAR 0 7
52183: PUSH
52184: LD_VAR 0 4
52188: PPUSH
52189: CALL_OW 313
52193: PPUSH
52194: LD_INT 25
52196: PUSH
52197: LD_INT 1
52199: PUSH
52200: EMPTY
52201: LIST
52202: LIST
52203: PPUSH
52204: CALL_OW 72
52208: ST_TO_ADDR
// if units then
52209: LD_VAR 0 7
52213: IFFALSE 52234
// begin ComExitBuilding ( units [ 1 ] ) ;
52215: LD_VAR 0 7
52219: PUSH
52220: LD_INT 1
52222: ARRAY
52223: PPUSH
52224: CALL_OW 122
// exit ;
52228: POP
52229: POP
52230: POP
52231: POP
52232: GO 52246
// end ; end ;
52234: GO 52176
52236: POP
52237: POP
// end ; end ; exit ;
52238: POP
52239: POP
52240: GO 52246
// end ; end ;
52242: GO 51600
52244: POP
52245: POP
// end ;
52246: LD_VAR 0 2
52250: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
52251: LD_INT 0
52253: PPUSH
52254: PPUSH
52255: PPUSH
52256: PPUSH
52257: PPUSH
52258: PPUSH
52259: PPUSH
// if not mc_bases or not skirmish then
52260: LD_EXP 78
52264: NOT
52265: PUSH
52266: LD_EXP 76
52270: NOT
52271: OR
52272: IFFALSE 52276
// exit ;
52274: GO 52541
// btype := GetBType ( building ) ;
52276: LD_ADDR_VAR 0 6
52280: PUSH
52281: LD_VAR 0 1
52285: PPUSH
52286: CALL_OW 266
52290: ST_TO_ADDR
// x := GetX ( building ) ;
52291: LD_ADDR_VAR 0 7
52295: PUSH
52296: LD_VAR 0 1
52300: PPUSH
52301: CALL_OW 250
52305: ST_TO_ADDR
// y := GetY ( building ) ;
52306: LD_ADDR_VAR 0 8
52310: PUSH
52311: LD_VAR 0 1
52315: PPUSH
52316: CALL_OW 251
52320: ST_TO_ADDR
// d := GetDir ( building ) ;
52321: LD_ADDR_VAR 0 9
52325: PUSH
52326: LD_VAR 0 1
52330: PPUSH
52331: CALL_OW 254
52335: ST_TO_ADDR
// for i = 1 to mc_bases do
52336: LD_ADDR_VAR 0 4
52340: PUSH
52341: DOUBLE
52342: LD_INT 1
52344: DEC
52345: ST_TO_ADDR
52346: LD_EXP 78
52350: PUSH
52351: FOR_TO
52352: IFFALSE 52539
// begin if not mc_build_list [ i ] then
52354: LD_EXP 83
52358: PUSH
52359: LD_VAR 0 4
52363: ARRAY
52364: NOT
52365: IFFALSE 52369
// continue ;
52367: GO 52351
// for j := 1 to mc_build_list [ i ] do
52369: LD_ADDR_VAR 0 5
52373: PUSH
52374: DOUBLE
52375: LD_INT 1
52377: DEC
52378: ST_TO_ADDR
52379: LD_EXP 83
52383: PUSH
52384: LD_VAR 0 4
52388: ARRAY
52389: PUSH
52390: FOR_TO
52391: IFFALSE 52535
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
52393: LD_VAR 0 6
52397: PUSH
52398: LD_VAR 0 7
52402: PUSH
52403: LD_VAR 0 8
52407: PUSH
52408: LD_VAR 0 9
52412: PUSH
52413: EMPTY
52414: LIST
52415: LIST
52416: LIST
52417: LIST
52418: PPUSH
52419: LD_EXP 83
52423: PUSH
52424: LD_VAR 0 4
52428: ARRAY
52429: PUSH
52430: LD_VAR 0 5
52434: ARRAY
52435: PPUSH
52436: CALL 64422 0 2
52440: IFFALSE 52533
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
52442: LD_ADDR_EXP 83
52446: PUSH
52447: LD_EXP 83
52451: PPUSH
52452: LD_VAR 0 4
52456: PPUSH
52457: LD_EXP 83
52461: PUSH
52462: LD_VAR 0 4
52466: ARRAY
52467: PPUSH
52468: LD_VAR 0 5
52472: PPUSH
52473: CALL_OW 3
52477: PPUSH
52478: CALL_OW 1
52482: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
52483: LD_ADDR_EXP 85
52487: PUSH
52488: LD_EXP 85
52492: PPUSH
52493: LD_VAR 0 4
52497: PUSH
52498: LD_EXP 85
52502: PUSH
52503: LD_VAR 0 4
52507: ARRAY
52508: PUSH
52509: LD_INT 1
52511: PLUS
52512: PUSH
52513: EMPTY
52514: LIST
52515: LIST
52516: PPUSH
52517: LD_VAR 0 1
52521: PPUSH
52522: CALL 57865 0 3
52526: ST_TO_ADDR
// exit ;
52527: POP
52528: POP
52529: POP
52530: POP
52531: GO 52541
// end ;
52533: GO 52390
52535: POP
52536: POP
// end ;
52537: GO 52351
52539: POP
52540: POP
// end ;
52541: LD_VAR 0 3
52545: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
52546: LD_INT 0
52548: PPUSH
52549: PPUSH
52550: PPUSH
// if not mc_bases or not skirmish then
52551: LD_EXP 78
52555: NOT
52556: PUSH
52557: LD_EXP 76
52561: NOT
52562: OR
52563: IFFALSE 52567
// exit ;
52565: GO 52757
// for i = 1 to mc_bases do
52567: LD_ADDR_VAR 0 4
52571: PUSH
52572: DOUBLE
52573: LD_INT 1
52575: DEC
52576: ST_TO_ADDR
52577: LD_EXP 78
52581: PUSH
52582: FOR_TO
52583: IFFALSE 52670
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
52585: LD_VAR 0 1
52589: PUSH
52590: LD_EXP 86
52594: PUSH
52595: LD_VAR 0 4
52599: ARRAY
52600: IN
52601: PUSH
52602: LD_VAR 0 1
52606: PUSH
52607: LD_EXP 87
52611: PUSH
52612: LD_VAR 0 4
52616: ARRAY
52617: IN
52618: NOT
52619: AND
52620: IFFALSE 52668
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52622: LD_ADDR_EXP 87
52626: PUSH
52627: LD_EXP 87
52631: PPUSH
52632: LD_VAR 0 4
52636: PUSH
52637: LD_EXP 87
52641: PUSH
52642: LD_VAR 0 4
52646: ARRAY
52647: PUSH
52648: LD_INT 1
52650: PLUS
52651: PUSH
52652: EMPTY
52653: LIST
52654: LIST
52655: PPUSH
52656: LD_VAR 0 1
52660: PPUSH
52661: CALL 57865 0 3
52665: ST_TO_ADDR
// break ;
52666: GO 52670
// end ; end ;
52668: GO 52582
52670: POP
52671: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
52672: LD_VAR 0 1
52676: PPUSH
52677: CALL_OW 257
52681: PUSH
52682: LD_EXP 104
52686: IN
52687: PUSH
52688: LD_VAR 0 1
52692: PPUSH
52693: CALL_OW 266
52697: PUSH
52698: LD_INT 5
52700: EQUAL
52701: AND
52702: PUSH
52703: LD_VAR 0 2
52707: PPUSH
52708: CALL_OW 110
52712: PUSH
52713: LD_INT 18
52715: NONEQUAL
52716: AND
52717: IFFALSE 52757
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
52719: LD_VAR 0 2
52723: PPUSH
52724: CALL_OW 257
52728: PUSH
52729: LD_INT 5
52731: PUSH
52732: LD_INT 8
52734: PUSH
52735: LD_INT 9
52737: PUSH
52738: EMPTY
52739: LIST
52740: LIST
52741: LIST
52742: IN
52743: IFFALSE 52757
// SetClass ( unit , 1 ) ;
52745: LD_VAR 0 2
52749: PPUSH
52750: LD_INT 1
52752: PPUSH
52753: CALL_OW 336
// end ;
52757: LD_VAR 0 3
52761: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
52762: LD_INT 0
52764: PPUSH
52765: PPUSH
// if not mc_bases or not skirmish then
52766: LD_EXP 78
52770: NOT
52771: PUSH
52772: LD_EXP 76
52776: NOT
52777: OR
52778: IFFALSE 52782
// exit ;
52780: GO 52898
// if GetLives ( abandoned_vehicle ) > 250 then
52782: LD_VAR 0 2
52786: PPUSH
52787: CALL_OW 256
52791: PUSH
52792: LD_INT 250
52794: GREATER
52795: IFFALSE 52799
// exit ;
52797: GO 52898
// for i = 1 to mc_bases do
52799: LD_ADDR_VAR 0 6
52803: PUSH
52804: DOUBLE
52805: LD_INT 1
52807: DEC
52808: ST_TO_ADDR
52809: LD_EXP 78
52813: PUSH
52814: FOR_TO
52815: IFFALSE 52896
// begin if driver in mc_bases [ i ] then
52817: LD_VAR 0 1
52821: PUSH
52822: LD_EXP 78
52826: PUSH
52827: LD_VAR 0 6
52831: ARRAY
52832: IN
52833: IFFALSE 52894
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
52835: LD_VAR 0 1
52839: PPUSH
52840: LD_EXP 78
52844: PUSH
52845: LD_VAR 0 6
52849: ARRAY
52850: PPUSH
52851: LD_INT 2
52853: PUSH
52854: LD_INT 30
52856: PUSH
52857: LD_INT 0
52859: PUSH
52860: EMPTY
52861: LIST
52862: LIST
52863: PUSH
52864: LD_INT 30
52866: PUSH
52867: LD_INT 1
52869: PUSH
52870: EMPTY
52871: LIST
52872: LIST
52873: PUSH
52874: EMPTY
52875: LIST
52876: LIST
52877: LIST
52878: PPUSH
52879: CALL_OW 72
52883: PUSH
52884: LD_INT 1
52886: ARRAY
52887: PPUSH
52888: CALL 91482 0 2
// break ;
52892: GO 52896
// end ; end ;
52894: GO 52814
52896: POP
52897: POP
// end ; end_of_file
52898: LD_VAR 0 5
52902: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52903: LD_INT 0
52905: PPUSH
52906: PPUSH
// if exist_mode then
52907: LD_VAR 0 2
52911: IFFALSE 52936
// unit := CreateCharacter ( prefix & ident ) else
52913: LD_ADDR_VAR 0 5
52917: PUSH
52918: LD_VAR 0 3
52922: PUSH
52923: LD_VAR 0 1
52927: STR
52928: PPUSH
52929: CALL_OW 34
52933: ST_TO_ADDR
52934: GO 52951
// unit := NewCharacter ( ident ) ;
52936: LD_ADDR_VAR 0 5
52940: PUSH
52941: LD_VAR 0 1
52945: PPUSH
52946: CALL_OW 25
52950: ST_TO_ADDR
// result := unit ;
52951: LD_ADDR_VAR 0 4
52955: PUSH
52956: LD_VAR 0 5
52960: ST_TO_ADDR
// end ;
52961: LD_VAR 0 4
52965: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52966: LD_INT 0
52968: PPUSH
52969: PPUSH
// if not side or not nation then
52970: LD_VAR 0 1
52974: NOT
52975: PUSH
52976: LD_VAR 0 2
52980: NOT
52981: OR
52982: IFFALSE 52986
// exit ;
52984: GO 53754
// case nation of nation_american :
52986: LD_VAR 0 2
52990: PUSH
52991: LD_INT 1
52993: DOUBLE
52994: EQUAL
52995: IFTRUE 52999
52997: GO 53213
52999: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
53000: LD_ADDR_VAR 0 4
53004: PUSH
53005: LD_INT 35
53007: PUSH
53008: LD_INT 45
53010: PUSH
53011: LD_INT 46
53013: PUSH
53014: LD_INT 47
53016: PUSH
53017: LD_INT 82
53019: PUSH
53020: LD_INT 83
53022: PUSH
53023: LD_INT 84
53025: PUSH
53026: LD_INT 85
53028: PUSH
53029: LD_INT 86
53031: PUSH
53032: LD_INT 1
53034: PUSH
53035: LD_INT 2
53037: PUSH
53038: LD_INT 6
53040: PUSH
53041: LD_INT 15
53043: PUSH
53044: LD_INT 16
53046: PUSH
53047: LD_INT 7
53049: PUSH
53050: LD_INT 12
53052: PUSH
53053: LD_INT 13
53055: PUSH
53056: LD_INT 10
53058: PUSH
53059: LD_INT 14
53061: PUSH
53062: LD_INT 20
53064: PUSH
53065: LD_INT 21
53067: PUSH
53068: LD_INT 22
53070: PUSH
53071: LD_INT 25
53073: PUSH
53074: LD_INT 32
53076: PUSH
53077: LD_INT 27
53079: PUSH
53080: LD_INT 36
53082: PUSH
53083: LD_INT 69
53085: PUSH
53086: LD_INT 39
53088: PUSH
53089: LD_INT 34
53091: PUSH
53092: LD_INT 40
53094: PUSH
53095: LD_INT 48
53097: PUSH
53098: LD_INT 49
53100: PUSH
53101: LD_INT 50
53103: PUSH
53104: LD_INT 51
53106: PUSH
53107: LD_INT 52
53109: PUSH
53110: LD_INT 53
53112: PUSH
53113: LD_INT 54
53115: PUSH
53116: LD_INT 55
53118: PUSH
53119: LD_INT 56
53121: PUSH
53122: LD_INT 57
53124: PUSH
53125: LD_INT 58
53127: PUSH
53128: LD_INT 59
53130: PUSH
53131: LD_INT 60
53133: PUSH
53134: LD_INT 61
53136: PUSH
53137: LD_INT 62
53139: PUSH
53140: LD_INT 80
53142: PUSH
53143: LD_INT 82
53145: PUSH
53146: LD_INT 83
53148: PUSH
53149: LD_INT 84
53151: PUSH
53152: LD_INT 85
53154: PUSH
53155: LD_INT 86
53157: PUSH
53158: EMPTY
53159: LIST
53160: LIST
53161: LIST
53162: LIST
53163: LIST
53164: LIST
53165: LIST
53166: LIST
53167: LIST
53168: LIST
53169: LIST
53170: LIST
53171: LIST
53172: LIST
53173: LIST
53174: LIST
53175: LIST
53176: LIST
53177: LIST
53178: LIST
53179: LIST
53180: LIST
53181: LIST
53182: LIST
53183: LIST
53184: LIST
53185: LIST
53186: LIST
53187: LIST
53188: LIST
53189: LIST
53190: LIST
53191: LIST
53192: LIST
53193: LIST
53194: LIST
53195: LIST
53196: LIST
53197: LIST
53198: LIST
53199: LIST
53200: LIST
53201: LIST
53202: LIST
53203: LIST
53204: LIST
53205: LIST
53206: LIST
53207: LIST
53208: LIST
53209: LIST
53210: ST_TO_ADDR
53211: GO 53678
53213: LD_INT 2
53215: DOUBLE
53216: EQUAL
53217: IFTRUE 53221
53219: GO 53447
53221: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
53222: LD_ADDR_VAR 0 4
53226: PUSH
53227: LD_INT 35
53229: PUSH
53230: LD_INT 45
53232: PUSH
53233: LD_INT 46
53235: PUSH
53236: LD_INT 47
53238: PUSH
53239: LD_INT 82
53241: PUSH
53242: LD_INT 83
53244: PUSH
53245: LD_INT 84
53247: PUSH
53248: LD_INT 85
53250: PUSH
53251: LD_INT 87
53253: PUSH
53254: LD_INT 70
53256: PUSH
53257: LD_INT 1
53259: PUSH
53260: LD_INT 11
53262: PUSH
53263: LD_INT 3
53265: PUSH
53266: LD_INT 4
53268: PUSH
53269: LD_INT 5
53271: PUSH
53272: LD_INT 6
53274: PUSH
53275: LD_INT 15
53277: PUSH
53278: LD_INT 18
53280: PUSH
53281: LD_INT 7
53283: PUSH
53284: LD_INT 17
53286: PUSH
53287: LD_INT 8
53289: PUSH
53290: LD_INT 20
53292: PUSH
53293: LD_INT 21
53295: PUSH
53296: LD_INT 22
53298: PUSH
53299: LD_INT 72
53301: PUSH
53302: LD_INT 26
53304: PUSH
53305: LD_INT 69
53307: PUSH
53308: LD_INT 39
53310: PUSH
53311: LD_INT 40
53313: PUSH
53314: LD_INT 41
53316: PUSH
53317: LD_INT 42
53319: PUSH
53320: LD_INT 43
53322: PUSH
53323: LD_INT 48
53325: PUSH
53326: LD_INT 49
53328: PUSH
53329: LD_INT 50
53331: PUSH
53332: LD_INT 51
53334: PUSH
53335: LD_INT 52
53337: PUSH
53338: LD_INT 53
53340: PUSH
53341: LD_INT 54
53343: PUSH
53344: LD_INT 55
53346: PUSH
53347: LD_INT 56
53349: PUSH
53350: LD_INT 60
53352: PUSH
53353: LD_INT 61
53355: PUSH
53356: LD_INT 62
53358: PUSH
53359: LD_INT 66
53361: PUSH
53362: LD_INT 67
53364: PUSH
53365: LD_INT 68
53367: PUSH
53368: LD_INT 81
53370: PUSH
53371: LD_INT 82
53373: PUSH
53374: LD_INT 83
53376: PUSH
53377: LD_INT 84
53379: PUSH
53380: LD_INT 85
53382: PUSH
53383: LD_INT 87
53385: PUSH
53386: LD_INT 88
53388: PUSH
53389: EMPTY
53390: LIST
53391: LIST
53392: LIST
53393: LIST
53394: LIST
53395: LIST
53396: LIST
53397: LIST
53398: LIST
53399: LIST
53400: LIST
53401: LIST
53402: LIST
53403: LIST
53404: LIST
53405: LIST
53406: LIST
53407: LIST
53408: LIST
53409: LIST
53410: LIST
53411: LIST
53412: LIST
53413: LIST
53414: LIST
53415: LIST
53416: LIST
53417: LIST
53418: LIST
53419: LIST
53420: LIST
53421: LIST
53422: LIST
53423: LIST
53424: LIST
53425: LIST
53426: LIST
53427: LIST
53428: LIST
53429: LIST
53430: LIST
53431: LIST
53432: LIST
53433: LIST
53434: LIST
53435: LIST
53436: LIST
53437: LIST
53438: LIST
53439: LIST
53440: LIST
53441: LIST
53442: LIST
53443: LIST
53444: ST_TO_ADDR
53445: GO 53678
53447: LD_INT 3
53449: DOUBLE
53450: EQUAL
53451: IFTRUE 53455
53453: GO 53677
53455: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
53456: LD_ADDR_VAR 0 4
53460: PUSH
53461: LD_INT 46
53463: PUSH
53464: LD_INT 47
53466: PUSH
53467: LD_INT 1
53469: PUSH
53470: LD_INT 2
53472: PUSH
53473: LD_INT 82
53475: PUSH
53476: LD_INT 83
53478: PUSH
53479: LD_INT 84
53481: PUSH
53482: LD_INT 85
53484: PUSH
53485: LD_INT 86
53487: PUSH
53488: LD_INT 11
53490: PUSH
53491: LD_INT 9
53493: PUSH
53494: LD_INT 20
53496: PUSH
53497: LD_INT 19
53499: PUSH
53500: LD_INT 21
53502: PUSH
53503: LD_INT 24
53505: PUSH
53506: LD_INT 22
53508: PUSH
53509: LD_INT 25
53511: PUSH
53512: LD_INT 28
53514: PUSH
53515: LD_INT 29
53517: PUSH
53518: LD_INT 30
53520: PUSH
53521: LD_INT 31
53523: PUSH
53524: LD_INT 37
53526: PUSH
53527: LD_INT 38
53529: PUSH
53530: LD_INT 32
53532: PUSH
53533: LD_INT 27
53535: PUSH
53536: LD_INT 33
53538: PUSH
53539: LD_INT 69
53541: PUSH
53542: LD_INT 39
53544: PUSH
53545: LD_INT 34
53547: PUSH
53548: LD_INT 40
53550: PUSH
53551: LD_INT 71
53553: PUSH
53554: LD_INT 23
53556: PUSH
53557: LD_INT 44
53559: PUSH
53560: LD_INT 48
53562: PUSH
53563: LD_INT 49
53565: PUSH
53566: LD_INT 50
53568: PUSH
53569: LD_INT 51
53571: PUSH
53572: LD_INT 52
53574: PUSH
53575: LD_INT 53
53577: PUSH
53578: LD_INT 54
53580: PUSH
53581: LD_INT 55
53583: PUSH
53584: LD_INT 56
53586: PUSH
53587: LD_INT 57
53589: PUSH
53590: LD_INT 58
53592: PUSH
53593: LD_INT 59
53595: PUSH
53596: LD_INT 63
53598: PUSH
53599: LD_INT 64
53601: PUSH
53602: LD_INT 65
53604: PUSH
53605: LD_INT 82
53607: PUSH
53608: LD_INT 83
53610: PUSH
53611: LD_INT 84
53613: PUSH
53614: LD_INT 85
53616: PUSH
53617: LD_INT 86
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: LIST
53624: LIST
53625: LIST
53626: LIST
53627: LIST
53628: LIST
53629: LIST
53630: LIST
53631: LIST
53632: LIST
53633: LIST
53634: LIST
53635: LIST
53636: LIST
53637: LIST
53638: LIST
53639: LIST
53640: LIST
53641: LIST
53642: LIST
53643: LIST
53644: LIST
53645: LIST
53646: LIST
53647: LIST
53648: LIST
53649: LIST
53650: LIST
53651: LIST
53652: LIST
53653: LIST
53654: LIST
53655: LIST
53656: LIST
53657: LIST
53658: LIST
53659: LIST
53660: LIST
53661: LIST
53662: LIST
53663: LIST
53664: LIST
53665: LIST
53666: LIST
53667: LIST
53668: LIST
53669: LIST
53670: LIST
53671: LIST
53672: LIST
53673: LIST
53674: ST_TO_ADDR
53675: GO 53678
53677: POP
// if state > - 1 and state < 3 then
53678: LD_VAR 0 3
53682: PUSH
53683: LD_INT 1
53685: NEG
53686: GREATER
53687: PUSH
53688: LD_VAR 0 3
53692: PUSH
53693: LD_INT 3
53695: LESS
53696: AND
53697: IFFALSE 53754
// for i in result do
53699: LD_ADDR_VAR 0 5
53703: PUSH
53704: LD_VAR 0 4
53708: PUSH
53709: FOR_IN
53710: IFFALSE 53752
// if GetTech ( i , side ) <> state then
53712: LD_VAR 0 5
53716: PPUSH
53717: LD_VAR 0 1
53721: PPUSH
53722: CALL_OW 321
53726: PUSH
53727: LD_VAR 0 3
53731: NONEQUAL
53732: IFFALSE 53750
// result := result diff i ;
53734: LD_ADDR_VAR 0 4
53738: PUSH
53739: LD_VAR 0 4
53743: PUSH
53744: LD_VAR 0 5
53748: DIFF
53749: ST_TO_ADDR
53750: GO 53709
53752: POP
53753: POP
// end ;
53754: LD_VAR 0 4
53758: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
53759: LD_INT 0
53761: PPUSH
53762: PPUSH
53763: PPUSH
// result := true ;
53764: LD_ADDR_VAR 0 3
53768: PUSH
53769: LD_INT 1
53771: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
53772: LD_ADDR_VAR 0 5
53776: PUSH
53777: LD_VAR 0 2
53781: PPUSH
53782: CALL_OW 480
53786: ST_TO_ADDR
// if not tmp then
53787: LD_VAR 0 5
53791: NOT
53792: IFFALSE 53796
// exit ;
53794: GO 53845
// for i in tmp do
53796: LD_ADDR_VAR 0 4
53800: PUSH
53801: LD_VAR 0 5
53805: PUSH
53806: FOR_IN
53807: IFFALSE 53843
// if GetTech ( i , side ) <> state_researched then
53809: LD_VAR 0 4
53813: PPUSH
53814: LD_VAR 0 1
53818: PPUSH
53819: CALL_OW 321
53823: PUSH
53824: LD_INT 2
53826: NONEQUAL
53827: IFFALSE 53841
// begin result := false ;
53829: LD_ADDR_VAR 0 3
53833: PUSH
53834: LD_INT 0
53836: ST_TO_ADDR
// exit ;
53837: POP
53838: POP
53839: GO 53845
// end ;
53841: GO 53806
53843: POP
53844: POP
// end ;
53845: LD_VAR 0 3
53849: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
53850: LD_INT 0
53852: PPUSH
53853: PPUSH
53854: PPUSH
53855: PPUSH
53856: PPUSH
53857: PPUSH
53858: PPUSH
53859: PPUSH
53860: PPUSH
53861: PPUSH
53862: PPUSH
53863: PPUSH
53864: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
53865: LD_VAR 0 1
53869: NOT
53870: PUSH
53871: LD_VAR 0 1
53875: PPUSH
53876: CALL_OW 257
53880: PUSH
53881: LD_INT 9
53883: NONEQUAL
53884: OR
53885: IFFALSE 53889
// exit ;
53887: GO 54462
// side := GetSide ( unit ) ;
53889: LD_ADDR_VAR 0 9
53893: PUSH
53894: LD_VAR 0 1
53898: PPUSH
53899: CALL_OW 255
53903: ST_TO_ADDR
// tech_space := tech_spacanom ;
53904: LD_ADDR_VAR 0 12
53908: PUSH
53909: LD_INT 29
53911: ST_TO_ADDR
// tech_time := tech_taurad ;
53912: LD_ADDR_VAR 0 13
53916: PUSH
53917: LD_INT 28
53919: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53920: LD_ADDR_VAR 0 11
53924: PUSH
53925: LD_VAR 0 1
53929: PPUSH
53930: CALL_OW 310
53934: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53935: LD_VAR 0 11
53939: PPUSH
53940: CALL_OW 247
53944: PUSH
53945: LD_INT 2
53947: EQUAL
53948: IFFALSE 53952
// exit ;
53950: GO 54462
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53952: LD_ADDR_VAR 0 8
53956: PUSH
53957: LD_INT 81
53959: PUSH
53960: LD_VAR 0 9
53964: PUSH
53965: EMPTY
53966: LIST
53967: LIST
53968: PUSH
53969: LD_INT 3
53971: PUSH
53972: LD_INT 21
53974: PUSH
53975: LD_INT 3
53977: PUSH
53978: EMPTY
53979: LIST
53980: LIST
53981: PUSH
53982: EMPTY
53983: LIST
53984: LIST
53985: PUSH
53986: EMPTY
53987: LIST
53988: LIST
53989: PPUSH
53990: CALL_OW 69
53994: ST_TO_ADDR
// if not tmp then
53995: LD_VAR 0 8
53999: NOT
54000: IFFALSE 54004
// exit ;
54002: GO 54462
// if in_unit then
54004: LD_VAR 0 11
54008: IFFALSE 54032
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
54010: LD_ADDR_VAR 0 10
54014: PUSH
54015: LD_VAR 0 8
54019: PPUSH
54020: LD_VAR 0 11
54024: PPUSH
54025: CALL_OW 74
54029: ST_TO_ADDR
54030: GO 54052
// enemy := NearestUnitToUnit ( tmp , unit ) ;
54032: LD_ADDR_VAR 0 10
54036: PUSH
54037: LD_VAR 0 8
54041: PPUSH
54042: LD_VAR 0 1
54046: PPUSH
54047: CALL_OW 74
54051: ST_TO_ADDR
// if not enemy then
54052: LD_VAR 0 10
54056: NOT
54057: IFFALSE 54061
// exit ;
54059: GO 54462
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54061: LD_VAR 0 11
54065: PUSH
54066: LD_VAR 0 11
54070: PPUSH
54071: LD_VAR 0 10
54075: PPUSH
54076: CALL_OW 296
54080: PUSH
54081: LD_INT 13
54083: GREATER
54084: AND
54085: PUSH
54086: LD_VAR 0 1
54090: PPUSH
54091: LD_VAR 0 10
54095: PPUSH
54096: CALL_OW 296
54100: PUSH
54101: LD_INT 12
54103: GREATER
54104: OR
54105: IFFALSE 54109
// exit ;
54107: GO 54462
// missile := [ 1 ] ;
54109: LD_ADDR_VAR 0 14
54113: PUSH
54114: LD_INT 1
54116: PUSH
54117: EMPTY
54118: LIST
54119: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54120: LD_VAR 0 9
54124: PPUSH
54125: LD_VAR 0 12
54129: PPUSH
54130: CALL_OW 325
54134: IFFALSE 54163
// missile := Replace ( missile , missile + 1 , 2 ) ;
54136: LD_ADDR_VAR 0 14
54140: PUSH
54141: LD_VAR 0 14
54145: PPUSH
54146: LD_VAR 0 14
54150: PUSH
54151: LD_INT 1
54153: PLUS
54154: PPUSH
54155: LD_INT 2
54157: PPUSH
54158: CALL_OW 1
54162: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54163: LD_VAR 0 9
54167: PPUSH
54168: LD_VAR 0 13
54172: PPUSH
54173: CALL_OW 325
54177: PUSH
54178: LD_VAR 0 10
54182: PPUSH
54183: CALL_OW 255
54187: PPUSH
54188: LD_VAR 0 13
54192: PPUSH
54193: CALL_OW 325
54197: NOT
54198: AND
54199: IFFALSE 54228
// missile := Replace ( missile , missile + 1 , 3 ) ;
54201: LD_ADDR_VAR 0 14
54205: PUSH
54206: LD_VAR 0 14
54210: PPUSH
54211: LD_VAR 0 14
54215: PUSH
54216: LD_INT 1
54218: PLUS
54219: PPUSH
54220: LD_INT 3
54222: PPUSH
54223: CALL_OW 1
54227: ST_TO_ADDR
// if missile < 2 then
54228: LD_VAR 0 14
54232: PUSH
54233: LD_INT 2
54235: LESS
54236: IFFALSE 54240
// exit ;
54238: GO 54462
// x := GetX ( enemy ) ;
54240: LD_ADDR_VAR 0 4
54244: PUSH
54245: LD_VAR 0 10
54249: PPUSH
54250: CALL_OW 250
54254: ST_TO_ADDR
// y := GetY ( enemy ) ;
54255: LD_ADDR_VAR 0 5
54259: PUSH
54260: LD_VAR 0 10
54264: PPUSH
54265: CALL_OW 251
54269: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
54270: LD_ADDR_VAR 0 6
54274: PUSH
54275: LD_VAR 0 4
54279: PUSH
54280: LD_INT 1
54282: NEG
54283: PPUSH
54284: LD_INT 1
54286: PPUSH
54287: CALL_OW 12
54291: PLUS
54292: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
54293: LD_ADDR_VAR 0 7
54297: PUSH
54298: LD_VAR 0 5
54302: PUSH
54303: LD_INT 1
54305: NEG
54306: PPUSH
54307: LD_INT 1
54309: PPUSH
54310: CALL_OW 12
54314: PLUS
54315: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54316: LD_VAR 0 6
54320: PPUSH
54321: LD_VAR 0 7
54325: PPUSH
54326: CALL_OW 488
54330: NOT
54331: IFFALSE 54353
// begin _x := x ;
54333: LD_ADDR_VAR 0 6
54337: PUSH
54338: LD_VAR 0 4
54342: ST_TO_ADDR
// _y := y ;
54343: LD_ADDR_VAR 0 7
54347: PUSH
54348: LD_VAR 0 5
54352: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
54353: LD_ADDR_VAR 0 3
54357: PUSH
54358: LD_INT 1
54360: PPUSH
54361: LD_VAR 0 14
54365: PPUSH
54366: CALL_OW 12
54370: ST_TO_ADDR
// case i of 1 :
54371: LD_VAR 0 3
54375: PUSH
54376: LD_INT 1
54378: DOUBLE
54379: EQUAL
54380: IFTRUE 54384
54382: GO 54401
54384: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
54385: LD_VAR 0 1
54389: PPUSH
54390: LD_VAR 0 10
54394: PPUSH
54395: CALL_OW 115
54399: GO 54462
54401: LD_INT 2
54403: DOUBLE
54404: EQUAL
54405: IFTRUE 54409
54407: GO 54431
54409: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
54410: LD_VAR 0 1
54414: PPUSH
54415: LD_VAR 0 6
54419: PPUSH
54420: LD_VAR 0 7
54424: PPUSH
54425: CALL_OW 153
54429: GO 54462
54431: LD_INT 3
54433: DOUBLE
54434: EQUAL
54435: IFTRUE 54439
54437: GO 54461
54439: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
54440: LD_VAR 0 1
54444: PPUSH
54445: LD_VAR 0 6
54449: PPUSH
54450: LD_VAR 0 7
54454: PPUSH
54455: CALL_OW 154
54459: GO 54462
54461: POP
// end ;
54462: LD_VAR 0 2
54466: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
54467: LD_INT 0
54469: PPUSH
54470: PPUSH
54471: PPUSH
54472: PPUSH
54473: PPUSH
54474: PPUSH
// if not unit or not building then
54475: LD_VAR 0 1
54479: NOT
54480: PUSH
54481: LD_VAR 0 2
54485: NOT
54486: OR
54487: IFFALSE 54491
// exit ;
54489: GO 54649
// x := GetX ( building ) ;
54491: LD_ADDR_VAR 0 5
54495: PUSH
54496: LD_VAR 0 2
54500: PPUSH
54501: CALL_OW 250
54505: ST_TO_ADDR
// y := GetY ( building ) ;
54506: LD_ADDR_VAR 0 6
54510: PUSH
54511: LD_VAR 0 2
54515: PPUSH
54516: CALL_OW 251
54520: ST_TO_ADDR
// for i = 0 to 5 do
54521: LD_ADDR_VAR 0 4
54525: PUSH
54526: DOUBLE
54527: LD_INT 0
54529: DEC
54530: ST_TO_ADDR
54531: LD_INT 5
54533: PUSH
54534: FOR_TO
54535: IFFALSE 54647
// begin _x := ShiftX ( x , i , 3 ) ;
54537: LD_ADDR_VAR 0 7
54541: PUSH
54542: LD_VAR 0 5
54546: PPUSH
54547: LD_VAR 0 4
54551: PPUSH
54552: LD_INT 3
54554: PPUSH
54555: CALL_OW 272
54559: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
54560: LD_ADDR_VAR 0 8
54564: PUSH
54565: LD_VAR 0 6
54569: PPUSH
54570: LD_VAR 0 4
54574: PPUSH
54575: LD_INT 3
54577: PPUSH
54578: CALL_OW 273
54582: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54583: LD_VAR 0 7
54587: PPUSH
54588: LD_VAR 0 8
54592: PPUSH
54593: CALL_OW 488
54597: NOT
54598: IFFALSE 54602
// continue ;
54600: GO 54534
// if HexInfo ( _x , _y ) = 0 then
54602: LD_VAR 0 7
54606: PPUSH
54607: LD_VAR 0 8
54611: PPUSH
54612: CALL_OW 428
54616: PUSH
54617: LD_INT 0
54619: EQUAL
54620: IFFALSE 54645
// begin ComMoveXY ( unit , _x , _y ) ;
54622: LD_VAR 0 1
54626: PPUSH
54627: LD_VAR 0 7
54631: PPUSH
54632: LD_VAR 0 8
54636: PPUSH
54637: CALL_OW 111
// exit ;
54641: POP
54642: POP
54643: GO 54649
// end ; end ;
54645: GO 54534
54647: POP
54648: POP
// end ;
54649: LD_VAR 0 3
54653: RET
// export function ScanBase ( side , base_area ) ; begin
54654: LD_INT 0
54656: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
54657: LD_ADDR_VAR 0 3
54661: PUSH
54662: LD_VAR 0 2
54666: PPUSH
54667: LD_INT 81
54669: PUSH
54670: LD_VAR 0 1
54674: PUSH
54675: EMPTY
54676: LIST
54677: LIST
54678: PPUSH
54679: CALL_OW 70
54683: ST_TO_ADDR
// end ;
54684: LD_VAR 0 3
54688: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54689: LD_INT 0
54691: PPUSH
54692: PPUSH
54693: PPUSH
54694: PPUSH
// result := false ;
54695: LD_ADDR_VAR 0 2
54699: PUSH
54700: LD_INT 0
54702: ST_TO_ADDR
// side := GetSide ( unit ) ;
54703: LD_ADDR_VAR 0 3
54707: PUSH
54708: LD_VAR 0 1
54712: PPUSH
54713: CALL_OW 255
54717: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54718: LD_ADDR_VAR 0 4
54722: PUSH
54723: LD_VAR 0 1
54727: PPUSH
54728: CALL_OW 248
54732: ST_TO_ADDR
// case nat of 1 :
54733: LD_VAR 0 4
54737: PUSH
54738: LD_INT 1
54740: DOUBLE
54741: EQUAL
54742: IFTRUE 54746
54744: GO 54757
54746: POP
// tech := tech_lassight ; 2 :
54747: LD_ADDR_VAR 0 5
54751: PUSH
54752: LD_INT 12
54754: ST_TO_ADDR
54755: GO 54796
54757: LD_INT 2
54759: DOUBLE
54760: EQUAL
54761: IFTRUE 54765
54763: GO 54776
54765: POP
// tech := tech_mortar ; 3 :
54766: LD_ADDR_VAR 0 5
54770: PUSH
54771: LD_INT 41
54773: ST_TO_ADDR
54774: GO 54796
54776: LD_INT 3
54778: DOUBLE
54779: EQUAL
54780: IFTRUE 54784
54782: GO 54795
54784: POP
// tech := tech_bazooka ; end ;
54785: LD_ADDR_VAR 0 5
54789: PUSH
54790: LD_INT 44
54792: ST_TO_ADDR
54793: GO 54796
54795: POP
// if Researched ( side , tech ) then
54796: LD_VAR 0 3
54800: PPUSH
54801: LD_VAR 0 5
54805: PPUSH
54806: CALL_OW 325
54810: IFFALSE 54837
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54812: LD_ADDR_VAR 0 2
54816: PUSH
54817: LD_INT 5
54819: PUSH
54820: LD_INT 8
54822: PUSH
54823: LD_INT 9
54825: PUSH
54826: EMPTY
54827: LIST
54828: LIST
54829: LIST
54830: PUSH
54831: LD_VAR 0 4
54835: ARRAY
54836: ST_TO_ADDR
// end ;
54837: LD_VAR 0 2
54841: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54842: LD_INT 0
54844: PPUSH
54845: PPUSH
54846: PPUSH
// if not mines then
54847: LD_VAR 0 2
54851: NOT
54852: IFFALSE 54856
// exit ;
54854: GO 55000
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54856: LD_ADDR_VAR 0 5
54860: PUSH
54861: LD_INT 81
54863: PUSH
54864: LD_VAR 0 1
54868: PUSH
54869: EMPTY
54870: LIST
54871: LIST
54872: PUSH
54873: LD_INT 3
54875: PUSH
54876: LD_INT 21
54878: PUSH
54879: LD_INT 3
54881: PUSH
54882: EMPTY
54883: LIST
54884: LIST
54885: PUSH
54886: EMPTY
54887: LIST
54888: LIST
54889: PUSH
54890: EMPTY
54891: LIST
54892: LIST
54893: PPUSH
54894: CALL_OW 69
54898: ST_TO_ADDR
// for i in mines do
54899: LD_ADDR_VAR 0 4
54903: PUSH
54904: LD_VAR 0 2
54908: PUSH
54909: FOR_IN
54910: IFFALSE 54998
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54912: LD_VAR 0 4
54916: PUSH
54917: LD_INT 1
54919: ARRAY
54920: PPUSH
54921: LD_VAR 0 4
54925: PUSH
54926: LD_INT 2
54928: ARRAY
54929: PPUSH
54930: CALL_OW 458
54934: NOT
54935: IFFALSE 54939
// continue ;
54937: GO 54909
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54939: LD_VAR 0 4
54943: PUSH
54944: LD_INT 1
54946: ARRAY
54947: PPUSH
54948: LD_VAR 0 4
54952: PUSH
54953: LD_INT 2
54955: ARRAY
54956: PPUSH
54957: CALL_OW 428
54961: PUSH
54962: LD_VAR 0 5
54966: IN
54967: IFFALSE 54996
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54969: LD_VAR 0 4
54973: PUSH
54974: LD_INT 1
54976: ARRAY
54977: PPUSH
54978: LD_VAR 0 4
54982: PUSH
54983: LD_INT 2
54985: ARRAY
54986: PPUSH
54987: LD_VAR 0 1
54991: PPUSH
54992: CALL_OW 456
// end ;
54996: GO 54909
54998: POP
54999: POP
// end ;
55000: LD_VAR 0 3
55004: RET
// export function Count ( array ) ; begin
55005: LD_INT 0
55007: PPUSH
// result := array + 0 ;
55008: LD_ADDR_VAR 0 2
55012: PUSH
55013: LD_VAR 0 1
55017: PUSH
55018: LD_INT 0
55020: PLUS
55021: ST_TO_ADDR
// end ;
55022: LD_VAR 0 2
55026: RET
// export function IsEmpty ( building ) ; begin
55027: LD_INT 0
55029: PPUSH
// if not building then
55030: LD_VAR 0 1
55034: NOT
55035: IFFALSE 55039
// exit ;
55037: GO 55082
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
55039: LD_ADDR_VAR 0 2
55043: PUSH
55044: LD_VAR 0 1
55048: PUSH
55049: LD_INT 22
55051: PUSH
55052: LD_VAR 0 1
55056: PPUSH
55057: CALL_OW 255
55061: PUSH
55062: EMPTY
55063: LIST
55064: LIST
55065: PUSH
55066: LD_INT 58
55068: PUSH
55069: EMPTY
55070: LIST
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: PPUSH
55076: CALL_OW 69
55080: IN
55081: ST_TO_ADDR
// end ;
55082: LD_VAR 0 2
55086: RET
// export function IsNotFull ( building ) ; var places ; begin
55087: LD_INT 0
55089: PPUSH
55090: PPUSH
// if not building then
55091: LD_VAR 0 1
55095: NOT
55096: IFFALSE 55100
// exit ;
55098: GO 55128
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
55100: LD_ADDR_VAR 0 2
55104: PUSH
55105: LD_VAR 0 1
55109: PPUSH
55110: LD_INT 3
55112: PUSH
55113: LD_INT 62
55115: PUSH
55116: EMPTY
55117: LIST
55118: PUSH
55119: EMPTY
55120: LIST
55121: LIST
55122: PPUSH
55123: CALL_OW 72
55127: ST_TO_ADDR
// end ;
55128: LD_VAR 0 2
55132: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55133: LD_INT 0
55135: PPUSH
55136: PPUSH
55137: PPUSH
55138: PPUSH
// tmp := [ ] ;
55139: LD_ADDR_VAR 0 3
55143: PUSH
55144: EMPTY
55145: ST_TO_ADDR
// list := [ ] ;
55146: LD_ADDR_VAR 0 5
55150: PUSH
55151: EMPTY
55152: ST_TO_ADDR
// for i = 16 to 25 do
55153: LD_ADDR_VAR 0 4
55157: PUSH
55158: DOUBLE
55159: LD_INT 16
55161: DEC
55162: ST_TO_ADDR
55163: LD_INT 25
55165: PUSH
55166: FOR_TO
55167: IFFALSE 55240
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55169: LD_ADDR_VAR 0 3
55173: PUSH
55174: LD_VAR 0 3
55178: PUSH
55179: LD_INT 22
55181: PUSH
55182: LD_VAR 0 1
55186: PPUSH
55187: CALL_OW 255
55191: PUSH
55192: EMPTY
55193: LIST
55194: LIST
55195: PUSH
55196: LD_INT 91
55198: PUSH
55199: LD_VAR 0 1
55203: PUSH
55204: LD_INT 6
55206: PUSH
55207: EMPTY
55208: LIST
55209: LIST
55210: LIST
55211: PUSH
55212: LD_INT 30
55214: PUSH
55215: LD_VAR 0 4
55219: PUSH
55220: EMPTY
55221: LIST
55222: LIST
55223: PUSH
55224: EMPTY
55225: LIST
55226: LIST
55227: LIST
55228: PUSH
55229: EMPTY
55230: LIST
55231: PPUSH
55232: CALL_OW 69
55236: ADD
55237: ST_TO_ADDR
55238: GO 55166
55240: POP
55241: POP
// for i = 1 to tmp do
55242: LD_ADDR_VAR 0 4
55246: PUSH
55247: DOUBLE
55248: LD_INT 1
55250: DEC
55251: ST_TO_ADDR
55252: LD_VAR 0 3
55256: PUSH
55257: FOR_TO
55258: IFFALSE 55346
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55260: LD_ADDR_VAR 0 5
55264: PUSH
55265: LD_VAR 0 5
55269: PUSH
55270: LD_VAR 0 3
55274: PUSH
55275: LD_VAR 0 4
55279: ARRAY
55280: PPUSH
55281: CALL_OW 266
55285: PUSH
55286: LD_VAR 0 3
55290: PUSH
55291: LD_VAR 0 4
55295: ARRAY
55296: PPUSH
55297: CALL_OW 250
55301: PUSH
55302: LD_VAR 0 3
55306: PUSH
55307: LD_VAR 0 4
55311: ARRAY
55312: PPUSH
55313: CALL_OW 251
55317: PUSH
55318: LD_VAR 0 3
55322: PUSH
55323: LD_VAR 0 4
55327: ARRAY
55328: PPUSH
55329: CALL_OW 254
55333: PUSH
55334: EMPTY
55335: LIST
55336: LIST
55337: LIST
55338: LIST
55339: PUSH
55340: EMPTY
55341: LIST
55342: ADD
55343: ST_TO_ADDR
55344: GO 55257
55346: POP
55347: POP
// result := list ;
55348: LD_ADDR_VAR 0 2
55352: PUSH
55353: LD_VAR 0 5
55357: ST_TO_ADDR
// end ;
55358: LD_VAR 0 2
55362: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55363: LD_INT 0
55365: PPUSH
55366: PPUSH
55367: PPUSH
55368: PPUSH
55369: PPUSH
55370: PPUSH
55371: PPUSH
// if not factory then
55372: LD_VAR 0 1
55376: NOT
55377: IFFALSE 55381
// exit ;
55379: GO 55974
// if control = control_apeman then
55381: LD_VAR 0 4
55385: PUSH
55386: LD_INT 5
55388: EQUAL
55389: IFFALSE 55498
// begin tmp := UnitsInside ( factory ) ;
55391: LD_ADDR_VAR 0 8
55395: PUSH
55396: LD_VAR 0 1
55400: PPUSH
55401: CALL_OW 313
55405: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55406: LD_VAR 0 8
55410: PPUSH
55411: LD_INT 25
55413: PUSH
55414: LD_INT 12
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: PPUSH
55421: CALL_OW 72
55425: NOT
55426: IFFALSE 55436
// control := control_manual ;
55428: LD_ADDR_VAR 0 4
55432: PUSH
55433: LD_INT 1
55435: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55436: LD_ADDR_VAR 0 8
55440: PUSH
55441: LD_VAR 0 1
55445: PPUSH
55446: CALL 55133 0 1
55450: ST_TO_ADDR
// if tmp then
55451: LD_VAR 0 8
55455: IFFALSE 55498
// begin for i in tmp do
55457: LD_ADDR_VAR 0 7
55461: PUSH
55462: LD_VAR 0 8
55466: PUSH
55467: FOR_IN
55468: IFFALSE 55496
// if i [ 1 ] = b_ext_radio then
55470: LD_VAR 0 7
55474: PUSH
55475: LD_INT 1
55477: ARRAY
55478: PUSH
55479: LD_INT 22
55481: EQUAL
55482: IFFALSE 55494
// begin control := control_remote ;
55484: LD_ADDR_VAR 0 4
55488: PUSH
55489: LD_INT 2
55491: ST_TO_ADDR
// break ;
55492: GO 55496
// end ;
55494: GO 55467
55496: POP
55497: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55498: LD_VAR 0 1
55502: PPUSH
55503: LD_VAR 0 2
55507: PPUSH
55508: LD_VAR 0 3
55512: PPUSH
55513: LD_VAR 0 4
55517: PPUSH
55518: LD_VAR 0 5
55522: PPUSH
55523: CALL_OW 448
55527: IFFALSE 55562
// begin result := [ chassis , engine , control , weapon ] ;
55529: LD_ADDR_VAR 0 6
55533: PUSH
55534: LD_VAR 0 2
55538: PUSH
55539: LD_VAR 0 3
55543: PUSH
55544: LD_VAR 0 4
55548: PUSH
55549: LD_VAR 0 5
55553: PUSH
55554: EMPTY
55555: LIST
55556: LIST
55557: LIST
55558: LIST
55559: ST_TO_ADDR
// exit ;
55560: GO 55974
// end ; _chassis := AvailableChassisList ( factory ) ;
55562: LD_ADDR_VAR 0 9
55566: PUSH
55567: LD_VAR 0 1
55571: PPUSH
55572: CALL_OW 475
55576: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55577: LD_ADDR_VAR 0 11
55581: PUSH
55582: LD_VAR 0 1
55586: PPUSH
55587: CALL_OW 476
55591: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55592: LD_ADDR_VAR 0 12
55596: PUSH
55597: LD_VAR 0 1
55601: PPUSH
55602: CALL_OW 477
55606: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55607: LD_ADDR_VAR 0 10
55611: PUSH
55612: LD_VAR 0 1
55616: PPUSH
55617: CALL_OW 478
55621: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55622: LD_VAR 0 9
55626: NOT
55627: PUSH
55628: LD_VAR 0 11
55632: NOT
55633: OR
55634: PUSH
55635: LD_VAR 0 12
55639: NOT
55640: OR
55641: PUSH
55642: LD_VAR 0 10
55646: NOT
55647: OR
55648: IFFALSE 55683
// begin result := [ chassis , engine , control , weapon ] ;
55650: LD_ADDR_VAR 0 6
55654: PUSH
55655: LD_VAR 0 2
55659: PUSH
55660: LD_VAR 0 3
55664: PUSH
55665: LD_VAR 0 4
55669: PUSH
55670: LD_VAR 0 5
55674: PUSH
55675: EMPTY
55676: LIST
55677: LIST
55678: LIST
55679: LIST
55680: ST_TO_ADDR
// exit ;
55681: GO 55974
// end ; if not chassis in _chassis then
55683: LD_VAR 0 2
55687: PUSH
55688: LD_VAR 0 9
55692: IN
55693: NOT
55694: IFFALSE 55720
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55696: LD_ADDR_VAR 0 2
55700: PUSH
55701: LD_VAR 0 9
55705: PUSH
55706: LD_INT 1
55708: PPUSH
55709: LD_VAR 0 9
55713: PPUSH
55714: CALL_OW 12
55718: ARRAY
55719: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55720: LD_VAR 0 2
55724: PPUSH
55725: LD_VAR 0 3
55729: PPUSH
55730: CALL 55979 0 2
55734: NOT
55735: IFFALSE 55794
// repeat engine := _engine [ 1 ] ;
55737: LD_ADDR_VAR 0 3
55741: PUSH
55742: LD_VAR 0 11
55746: PUSH
55747: LD_INT 1
55749: ARRAY
55750: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55751: LD_ADDR_VAR 0 11
55755: PUSH
55756: LD_VAR 0 11
55760: PPUSH
55761: LD_INT 1
55763: PPUSH
55764: CALL_OW 3
55768: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55769: LD_VAR 0 2
55773: PPUSH
55774: LD_VAR 0 3
55778: PPUSH
55779: CALL 55979 0 2
55783: PUSH
55784: LD_VAR 0 11
55788: PUSH
55789: EMPTY
55790: EQUAL
55791: OR
55792: IFFALSE 55737
// if not control in _control then
55794: LD_VAR 0 4
55798: PUSH
55799: LD_VAR 0 12
55803: IN
55804: NOT
55805: IFFALSE 55831
// control := _control [ rand ( 1 , _control ) ] ;
55807: LD_ADDR_VAR 0 4
55811: PUSH
55812: LD_VAR 0 12
55816: PUSH
55817: LD_INT 1
55819: PPUSH
55820: LD_VAR 0 12
55824: PPUSH
55825: CALL_OW 12
55829: ARRAY
55830: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55831: LD_VAR 0 2
55835: PPUSH
55836: LD_VAR 0 5
55840: PPUSH
55841: CALL 56199 0 2
55845: NOT
55846: IFFALSE 55905
// repeat weapon := _weapon [ 1 ] ;
55848: LD_ADDR_VAR 0 5
55852: PUSH
55853: LD_VAR 0 10
55857: PUSH
55858: LD_INT 1
55860: ARRAY
55861: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55862: LD_ADDR_VAR 0 10
55866: PUSH
55867: LD_VAR 0 10
55871: PPUSH
55872: LD_INT 1
55874: PPUSH
55875: CALL_OW 3
55879: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55880: LD_VAR 0 2
55884: PPUSH
55885: LD_VAR 0 5
55889: PPUSH
55890: CALL 56199 0 2
55894: PUSH
55895: LD_VAR 0 10
55899: PUSH
55900: EMPTY
55901: EQUAL
55902: OR
55903: IFFALSE 55848
// result := [ ] ;
55905: LD_ADDR_VAR 0 6
55909: PUSH
55910: EMPTY
55911: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55912: LD_VAR 0 1
55916: PPUSH
55917: LD_VAR 0 2
55921: PPUSH
55922: LD_VAR 0 3
55926: PPUSH
55927: LD_VAR 0 4
55931: PPUSH
55932: LD_VAR 0 5
55936: PPUSH
55937: CALL_OW 448
55941: IFFALSE 55974
// result := [ chassis , engine , control , weapon ] ;
55943: LD_ADDR_VAR 0 6
55947: PUSH
55948: LD_VAR 0 2
55952: PUSH
55953: LD_VAR 0 3
55957: PUSH
55958: LD_VAR 0 4
55962: PUSH
55963: LD_VAR 0 5
55967: PUSH
55968: EMPTY
55969: LIST
55970: LIST
55971: LIST
55972: LIST
55973: ST_TO_ADDR
// end ;
55974: LD_VAR 0 6
55978: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55979: LD_INT 0
55981: PPUSH
// if not chassis or not engine then
55982: LD_VAR 0 1
55986: NOT
55987: PUSH
55988: LD_VAR 0 2
55992: NOT
55993: OR
55994: IFFALSE 55998
// exit ;
55996: GO 56194
// case engine of engine_solar :
55998: LD_VAR 0 2
56002: PUSH
56003: LD_INT 2
56005: DOUBLE
56006: EQUAL
56007: IFTRUE 56011
56009: GO 56049
56011: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
56012: LD_ADDR_VAR 0 3
56016: PUSH
56017: LD_INT 11
56019: PUSH
56020: LD_INT 12
56022: PUSH
56023: LD_INT 13
56025: PUSH
56026: LD_INT 14
56028: PUSH
56029: LD_INT 1
56031: PUSH
56032: LD_INT 2
56034: PUSH
56035: LD_INT 3
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: LIST
56042: LIST
56043: LIST
56044: LIST
56045: LIST
56046: ST_TO_ADDR
56047: GO 56178
56049: LD_INT 1
56051: DOUBLE
56052: EQUAL
56053: IFTRUE 56057
56055: GO 56119
56057: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56058: LD_ADDR_VAR 0 3
56062: PUSH
56063: LD_INT 11
56065: PUSH
56066: LD_INT 12
56068: PUSH
56069: LD_INT 13
56071: PUSH
56072: LD_INT 14
56074: PUSH
56075: LD_INT 1
56077: PUSH
56078: LD_INT 2
56080: PUSH
56081: LD_INT 3
56083: PUSH
56084: LD_INT 4
56086: PUSH
56087: LD_INT 5
56089: PUSH
56090: LD_INT 21
56092: PUSH
56093: LD_INT 23
56095: PUSH
56096: LD_INT 22
56098: PUSH
56099: LD_INT 24
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: LIST
56106: LIST
56107: LIST
56108: LIST
56109: LIST
56110: LIST
56111: LIST
56112: LIST
56113: LIST
56114: LIST
56115: LIST
56116: ST_TO_ADDR
56117: GO 56178
56119: LD_INT 3
56121: DOUBLE
56122: EQUAL
56123: IFTRUE 56127
56125: GO 56177
56127: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56128: LD_ADDR_VAR 0 3
56132: PUSH
56133: LD_INT 13
56135: PUSH
56136: LD_INT 14
56138: PUSH
56139: LD_INT 2
56141: PUSH
56142: LD_INT 3
56144: PUSH
56145: LD_INT 4
56147: PUSH
56148: LD_INT 5
56150: PUSH
56151: LD_INT 21
56153: PUSH
56154: LD_INT 22
56156: PUSH
56157: LD_INT 23
56159: PUSH
56160: LD_INT 24
56162: PUSH
56163: EMPTY
56164: LIST
56165: LIST
56166: LIST
56167: LIST
56168: LIST
56169: LIST
56170: LIST
56171: LIST
56172: LIST
56173: LIST
56174: ST_TO_ADDR
56175: GO 56178
56177: POP
// result := ( chassis in result ) ;
56178: LD_ADDR_VAR 0 3
56182: PUSH
56183: LD_VAR 0 1
56187: PUSH
56188: LD_VAR 0 3
56192: IN
56193: ST_TO_ADDR
// end ;
56194: LD_VAR 0 3
56198: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56199: LD_INT 0
56201: PPUSH
// if not chassis or not weapon then
56202: LD_VAR 0 1
56206: NOT
56207: PUSH
56208: LD_VAR 0 2
56212: NOT
56213: OR
56214: IFFALSE 56218
// exit ;
56216: GO 57278
// case weapon of us_machine_gun :
56218: LD_VAR 0 2
56222: PUSH
56223: LD_INT 2
56225: DOUBLE
56226: EQUAL
56227: IFTRUE 56231
56229: GO 56261
56231: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56232: LD_ADDR_VAR 0 3
56236: PUSH
56237: LD_INT 1
56239: PUSH
56240: LD_INT 2
56242: PUSH
56243: LD_INT 3
56245: PUSH
56246: LD_INT 4
56248: PUSH
56249: LD_INT 5
56251: PUSH
56252: EMPTY
56253: LIST
56254: LIST
56255: LIST
56256: LIST
56257: LIST
56258: ST_TO_ADDR
56259: GO 57262
56261: LD_INT 3
56263: DOUBLE
56264: EQUAL
56265: IFTRUE 56269
56267: GO 56299
56269: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56270: LD_ADDR_VAR 0 3
56274: PUSH
56275: LD_INT 1
56277: PUSH
56278: LD_INT 2
56280: PUSH
56281: LD_INT 3
56283: PUSH
56284: LD_INT 4
56286: PUSH
56287: LD_INT 5
56289: PUSH
56290: EMPTY
56291: LIST
56292: LIST
56293: LIST
56294: LIST
56295: LIST
56296: ST_TO_ADDR
56297: GO 57262
56299: LD_INT 11
56301: DOUBLE
56302: EQUAL
56303: IFTRUE 56307
56305: GO 56337
56307: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56308: LD_ADDR_VAR 0 3
56312: PUSH
56313: LD_INT 1
56315: PUSH
56316: LD_INT 2
56318: PUSH
56319: LD_INT 3
56321: PUSH
56322: LD_INT 4
56324: PUSH
56325: LD_INT 5
56327: PUSH
56328: EMPTY
56329: LIST
56330: LIST
56331: LIST
56332: LIST
56333: LIST
56334: ST_TO_ADDR
56335: GO 57262
56337: LD_INT 4
56339: DOUBLE
56340: EQUAL
56341: IFTRUE 56345
56343: GO 56371
56345: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56346: LD_ADDR_VAR 0 3
56350: PUSH
56351: LD_INT 2
56353: PUSH
56354: LD_INT 3
56356: PUSH
56357: LD_INT 4
56359: PUSH
56360: LD_INT 5
56362: PUSH
56363: EMPTY
56364: LIST
56365: LIST
56366: LIST
56367: LIST
56368: ST_TO_ADDR
56369: GO 57262
56371: LD_INT 5
56373: DOUBLE
56374: EQUAL
56375: IFTRUE 56379
56377: GO 56405
56379: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56380: LD_ADDR_VAR 0 3
56384: PUSH
56385: LD_INT 2
56387: PUSH
56388: LD_INT 3
56390: PUSH
56391: LD_INT 4
56393: PUSH
56394: LD_INT 5
56396: PUSH
56397: EMPTY
56398: LIST
56399: LIST
56400: LIST
56401: LIST
56402: ST_TO_ADDR
56403: GO 57262
56405: LD_INT 9
56407: DOUBLE
56408: EQUAL
56409: IFTRUE 56413
56411: GO 56439
56413: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56414: LD_ADDR_VAR 0 3
56418: PUSH
56419: LD_INT 2
56421: PUSH
56422: LD_INT 3
56424: PUSH
56425: LD_INT 4
56427: PUSH
56428: LD_INT 5
56430: PUSH
56431: EMPTY
56432: LIST
56433: LIST
56434: LIST
56435: LIST
56436: ST_TO_ADDR
56437: GO 57262
56439: LD_INT 7
56441: DOUBLE
56442: EQUAL
56443: IFTRUE 56447
56445: GO 56473
56447: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56448: LD_ADDR_VAR 0 3
56452: PUSH
56453: LD_INT 2
56455: PUSH
56456: LD_INT 3
56458: PUSH
56459: LD_INT 4
56461: PUSH
56462: LD_INT 5
56464: PUSH
56465: EMPTY
56466: LIST
56467: LIST
56468: LIST
56469: LIST
56470: ST_TO_ADDR
56471: GO 57262
56473: LD_INT 12
56475: DOUBLE
56476: EQUAL
56477: IFTRUE 56481
56479: GO 56507
56481: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56482: LD_ADDR_VAR 0 3
56486: PUSH
56487: LD_INT 2
56489: PUSH
56490: LD_INT 3
56492: PUSH
56493: LD_INT 4
56495: PUSH
56496: LD_INT 5
56498: PUSH
56499: EMPTY
56500: LIST
56501: LIST
56502: LIST
56503: LIST
56504: ST_TO_ADDR
56505: GO 57262
56507: LD_INT 13
56509: DOUBLE
56510: EQUAL
56511: IFTRUE 56515
56513: GO 56541
56515: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56516: LD_ADDR_VAR 0 3
56520: PUSH
56521: LD_INT 2
56523: PUSH
56524: LD_INT 3
56526: PUSH
56527: LD_INT 4
56529: PUSH
56530: LD_INT 5
56532: PUSH
56533: EMPTY
56534: LIST
56535: LIST
56536: LIST
56537: LIST
56538: ST_TO_ADDR
56539: GO 57262
56541: LD_INT 14
56543: DOUBLE
56544: EQUAL
56545: IFTRUE 56549
56547: GO 56567
56549: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56550: LD_ADDR_VAR 0 3
56554: PUSH
56555: LD_INT 4
56557: PUSH
56558: LD_INT 5
56560: PUSH
56561: EMPTY
56562: LIST
56563: LIST
56564: ST_TO_ADDR
56565: GO 57262
56567: LD_INT 6
56569: DOUBLE
56570: EQUAL
56571: IFTRUE 56575
56573: GO 56593
56575: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56576: LD_ADDR_VAR 0 3
56580: PUSH
56581: LD_INT 4
56583: PUSH
56584: LD_INT 5
56586: PUSH
56587: EMPTY
56588: LIST
56589: LIST
56590: ST_TO_ADDR
56591: GO 57262
56593: LD_INT 10
56595: DOUBLE
56596: EQUAL
56597: IFTRUE 56601
56599: GO 56619
56601: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56602: LD_ADDR_VAR 0 3
56606: PUSH
56607: LD_INT 4
56609: PUSH
56610: LD_INT 5
56612: PUSH
56613: EMPTY
56614: LIST
56615: LIST
56616: ST_TO_ADDR
56617: GO 57262
56619: LD_INT 22
56621: DOUBLE
56622: EQUAL
56623: IFTRUE 56627
56625: GO 56653
56627: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56628: LD_ADDR_VAR 0 3
56632: PUSH
56633: LD_INT 11
56635: PUSH
56636: LD_INT 12
56638: PUSH
56639: LD_INT 13
56641: PUSH
56642: LD_INT 14
56644: PUSH
56645: EMPTY
56646: LIST
56647: LIST
56648: LIST
56649: LIST
56650: ST_TO_ADDR
56651: GO 57262
56653: LD_INT 23
56655: DOUBLE
56656: EQUAL
56657: IFTRUE 56661
56659: GO 56687
56661: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56662: LD_ADDR_VAR 0 3
56666: PUSH
56667: LD_INT 11
56669: PUSH
56670: LD_INT 12
56672: PUSH
56673: LD_INT 13
56675: PUSH
56676: LD_INT 14
56678: PUSH
56679: EMPTY
56680: LIST
56681: LIST
56682: LIST
56683: LIST
56684: ST_TO_ADDR
56685: GO 57262
56687: LD_INT 24
56689: DOUBLE
56690: EQUAL
56691: IFTRUE 56695
56693: GO 56721
56695: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56696: LD_ADDR_VAR 0 3
56700: PUSH
56701: LD_INT 11
56703: PUSH
56704: LD_INT 12
56706: PUSH
56707: LD_INT 13
56709: PUSH
56710: LD_INT 14
56712: PUSH
56713: EMPTY
56714: LIST
56715: LIST
56716: LIST
56717: LIST
56718: ST_TO_ADDR
56719: GO 57262
56721: LD_INT 30
56723: DOUBLE
56724: EQUAL
56725: IFTRUE 56729
56727: GO 56755
56729: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56730: LD_ADDR_VAR 0 3
56734: PUSH
56735: LD_INT 11
56737: PUSH
56738: LD_INT 12
56740: PUSH
56741: LD_INT 13
56743: PUSH
56744: LD_INT 14
56746: PUSH
56747: EMPTY
56748: LIST
56749: LIST
56750: LIST
56751: LIST
56752: ST_TO_ADDR
56753: GO 57262
56755: LD_INT 25
56757: DOUBLE
56758: EQUAL
56759: IFTRUE 56763
56761: GO 56781
56763: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56764: LD_ADDR_VAR 0 3
56768: PUSH
56769: LD_INT 13
56771: PUSH
56772: LD_INT 14
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: ST_TO_ADDR
56779: GO 57262
56781: LD_INT 27
56783: DOUBLE
56784: EQUAL
56785: IFTRUE 56789
56787: GO 56807
56789: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
56790: LD_ADDR_VAR 0 3
56794: PUSH
56795: LD_INT 13
56797: PUSH
56798: LD_INT 14
56800: PUSH
56801: EMPTY
56802: LIST
56803: LIST
56804: ST_TO_ADDR
56805: GO 57262
56807: LD_INT 92
56809: DOUBLE
56810: EQUAL
56811: IFTRUE 56815
56813: GO 56841
56815: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56816: LD_ADDR_VAR 0 3
56820: PUSH
56821: LD_INT 11
56823: PUSH
56824: LD_INT 12
56826: PUSH
56827: LD_INT 13
56829: PUSH
56830: LD_INT 14
56832: PUSH
56833: EMPTY
56834: LIST
56835: LIST
56836: LIST
56837: LIST
56838: ST_TO_ADDR
56839: GO 57262
56841: LD_INT 28
56843: DOUBLE
56844: EQUAL
56845: IFTRUE 56849
56847: GO 56867
56849: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56850: LD_ADDR_VAR 0 3
56854: PUSH
56855: LD_INT 13
56857: PUSH
56858: LD_INT 14
56860: PUSH
56861: EMPTY
56862: LIST
56863: LIST
56864: ST_TO_ADDR
56865: GO 57262
56867: LD_INT 29
56869: DOUBLE
56870: EQUAL
56871: IFTRUE 56875
56873: GO 56893
56875: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56876: LD_ADDR_VAR 0 3
56880: PUSH
56881: LD_INT 13
56883: PUSH
56884: LD_INT 14
56886: PUSH
56887: EMPTY
56888: LIST
56889: LIST
56890: ST_TO_ADDR
56891: GO 57262
56893: LD_INT 31
56895: DOUBLE
56896: EQUAL
56897: IFTRUE 56901
56899: GO 56919
56901: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56902: LD_ADDR_VAR 0 3
56906: PUSH
56907: LD_INT 13
56909: PUSH
56910: LD_INT 14
56912: PUSH
56913: EMPTY
56914: LIST
56915: LIST
56916: ST_TO_ADDR
56917: GO 57262
56919: LD_INT 26
56921: DOUBLE
56922: EQUAL
56923: IFTRUE 56927
56925: GO 56945
56927: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56928: LD_ADDR_VAR 0 3
56932: PUSH
56933: LD_INT 13
56935: PUSH
56936: LD_INT 14
56938: PUSH
56939: EMPTY
56940: LIST
56941: LIST
56942: ST_TO_ADDR
56943: GO 57262
56945: LD_INT 42
56947: DOUBLE
56948: EQUAL
56949: IFTRUE 56953
56951: GO 56979
56953: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56954: LD_ADDR_VAR 0 3
56958: PUSH
56959: LD_INT 21
56961: PUSH
56962: LD_INT 22
56964: PUSH
56965: LD_INT 23
56967: PUSH
56968: LD_INT 24
56970: PUSH
56971: EMPTY
56972: LIST
56973: LIST
56974: LIST
56975: LIST
56976: ST_TO_ADDR
56977: GO 57262
56979: LD_INT 43
56981: DOUBLE
56982: EQUAL
56983: IFTRUE 56987
56985: GO 57013
56987: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56988: LD_ADDR_VAR 0 3
56992: PUSH
56993: LD_INT 21
56995: PUSH
56996: LD_INT 22
56998: PUSH
56999: LD_INT 23
57001: PUSH
57002: LD_INT 24
57004: PUSH
57005: EMPTY
57006: LIST
57007: LIST
57008: LIST
57009: LIST
57010: ST_TO_ADDR
57011: GO 57262
57013: LD_INT 44
57015: DOUBLE
57016: EQUAL
57017: IFTRUE 57021
57019: GO 57047
57021: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
57022: LD_ADDR_VAR 0 3
57026: PUSH
57027: LD_INT 21
57029: PUSH
57030: LD_INT 22
57032: PUSH
57033: LD_INT 23
57035: PUSH
57036: LD_INT 24
57038: PUSH
57039: EMPTY
57040: LIST
57041: LIST
57042: LIST
57043: LIST
57044: ST_TO_ADDR
57045: GO 57262
57047: LD_INT 45
57049: DOUBLE
57050: EQUAL
57051: IFTRUE 57055
57053: GO 57081
57055: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57056: LD_ADDR_VAR 0 3
57060: PUSH
57061: LD_INT 21
57063: PUSH
57064: LD_INT 22
57066: PUSH
57067: LD_INT 23
57069: PUSH
57070: LD_INT 24
57072: PUSH
57073: EMPTY
57074: LIST
57075: LIST
57076: LIST
57077: LIST
57078: ST_TO_ADDR
57079: GO 57262
57081: LD_INT 49
57083: DOUBLE
57084: EQUAL
57085: IFTRUE 57089
57087: GO 57115
57089: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57090: LD_ADDR_VAR 0 3
57094: PUSH
57095: LD_INT 21
57097: PUSH
57098: LD_INT 22
57100: PUSH
57101: LD_INT 23
57103: PUSH
57104: LD_INT 24
57106: PUSH
57107: EMPTY
57108: LIST
57109: LIST
57110: LIST
57111: LIST
57112: ST_TO_ADDR
57113: GO 57262
57115: LD_INT 51
57117: DOUBLE
57118: EQUAL
57119: IFTRUE 57123
57121: GO 57149
57123: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57124: LD_ADDR_VAR 0 3
57128: PUSH
57129: LD_INT 21
57131: PUSH
57132: LD_INT 22
57134: PUSH
57135: LD_INT 23
57137: PUSH
57138: LD_INT 24
57140: PUSH
57141: EMPTY
57142: LIST
57143: LIST
57144: LIST
57145: LIST
57146: ST_TO_ADDR
57147: GO 57262
57149: LD_INT 52
57151: DOUBLE
57152: EQUAL
57153: IFTRUE 57157
57155: GO 57183
57157: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57158: LD_ADDR_VAR 0 3
57162: PUSH
57163: LD_INT 21
57165: PUSH
57166: LD_INT 22
57168: PUSH
57169: LD_INT 23
57171: PUSH
57172: LD_INT 24
57174: PUSH
57175: EMPTY
57176: LIST
57177: LIST
57178: LIST
57179: LIST
57180: ST_TO_ADDR
57181: GO 57262
57183: LD_INT 53
57185: DOUBLE
57186: EQUAL
57187: IFTRUE 57191
57189: GO 57209
57191: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57192: LD_ADDR_VAR 0 3
57196: PUSH
57197: LD_INT 23
57199: PUSH
57200: LD_INT 24
57202: PUSH
57203: EMPTY
57204: LIST
57205: LIST
57206: ST_TO_ADDR
57207: GO 57262
57209: LD_INT 46
57211: DOUBLE
57212: EQUAL
57213: IFTRUE 57217
57215: GO 57235
57217: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57218: LD_ADDR_VAR 0 3
57222: PUSH
57223: LD_INT 23
57225: PUSH
57226: LD_INT 24
57228: PUSH
57229: EMPTY
57230: LIST
57231: LIST
57232: ST_TO_ADDR
57233: GO 57262
57235: LD_INT 47
57237: DOUBLE
57238: EQUAL
57239: IFTRUE 57243
57241: GO 57261
57243: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57244: LD_ADDR_VAR 0 3
57248: PUSH
57249: LD_INT 23
57251: PUSH
57252: LD_INT 24
57254: PUSH
57255: EMPTY
57256: LIST
57257: LIST
57258: ST_TO_ADDR
57259: GO 57262
57261: POP
// result := ( chassis in result ) ;
57262: LD_ADDR_VAR 0 3
57266: PUSH
57267: LD_VAR 0 1
57271: PUSH
57272: LD_VAR 0 3
57276: IN
57277: ST_TO_ADDR
// end ;
57278: LD_VAR 0 3
57282: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57283: LD_INT 0
57285: PPUSH
57286: PPUSH
57287: PPUSH
57288: PPUSH
57289: PPUSH
57290: PPUSH
57291: PPUSH
// result := array ;
57292: LD_ADDR_VAR 0 5
57296: PUSH
57297: LD_VAR 0 1
57301: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57302: LD_VAR 0 1
57306: NOT
57307: PUSH
57308: LD_VAR 0 2
57312: NOT
57313: OR
57314: PUSH
57315: LD_VAR 0 3
57319: NOT
57320: OR
57321: PUSH
57322: LD_VAR 0 2
57326: PUSH
57327: LD_VAR 0 1
57331: GREATER
57332: OR
57333: PUSH
57334: LD_VAR 0 3
57338: PUSH
57339: LD_VAR 0 1
57343: GREATER
57344: OR
57345: IFFALSE 57349
// exit ;
57347: GO 57645
// if direction then
57349: LD_VAR 0 4
57353: IFFALSE 57417
// begin d := 1 ;
57355: LD_ADDR_VAR 0 9
57359: PUSH
57360: LD_INT 1
57362: ST_TO_ADDR
// if i_from > i_to then
57363: LD_VAR 0 2
57367: PUSH
57368: LD_VAR 0 3
57372: GREATER
57373: IFFALSE 57399
// length := ( array - i_from ) + i_to else
57375: LD_ADDR_VAR 0 11
57379: PUSH
57380: LD_VAR 0 1
57384: PUSH
57385: LD_VAR 0 2
57389: MINUS
57390: PUSH
57391: LD_VAR 0 3
57395: PLUS
57396: ST_TO_ADDR
57397: GO 57415
// length := i_to - i_from ;
57399: LD_ADDR_VAR 0 11
57403: PUSH
57404: LD_VAR 0 3
57408: PUSH
57409: LD_VAR 0 2
57413: MINUS
57414: ST_TO_ADDR
// end else
57415: GO 57478
// begin d := - 1 ;
57417: LD_ADDR_VAR 0 9
57421: PUSH
57422: LD_INT 1
57424: NEG
57425: ST_TO_ADDR
// if i_from > i_to then
57426: LD_VAR 0 2
57430: PUSH
57431: LD_VAR 0 3
57435: GREATER
57436: IFFALSE 57456
// length := i_from - i_to else
57438: LD_ADDR_VAR 0 11
57442: PUSH
57443: LD_VAR 0 2
57447: PUSH
57448: LD_VAR 0 3
57452: MINUS
57453: ST_TO_ADDR
57454: GO 57478
// length := ( array - i_to ) + i_from ;
57456: LD_ADDR_VAR 0 11
57460: PUSH
57461: LD_VAR 0 1
57465: PUSH
57466: LD_VAR 0 3
57470: MINUS
57471: PUSH
57472: LD_VAR 0 2
57476: PLUS
57477: ST_TO_ADDR
// end ; if not length then
57478: LD_VAR 0 11
57482: NOT
57483: IFFALSE 57487
// exit ;
57485: GO 57645
// tmp := array ;
57487: LD_ADDR_VAR 0 10
57491: PUSH
57492: LD_VAR 0 1
57496: ST_TO_ADDR
// for i = 1 to length do
57497: LD_ADDR_VAR 0 6
57501: PUSH
57502: DOUBLE
57503: LD_INT 1
57505: DEC
57506: ST_TO_ADDR
57507: LD_VAR 0 11
57511: PUSH
57512: FOR_TO
57513: IFFALSE 57633
// begin for j = 1 to array do
57515: LD_ADDR_VAR 0 7
57519: PUSH
57520: DOUBLE
57521: LD_INT 1
57523: DEC
57524: ST_TO_ADDR
57525: LD_VAR 0 1
57529: PUSH
57530: FOR_TO
57531: IFFALSE 57619
// begin k := j + d ;
57533: LD_ADDR_VAR 0 8
57537: PUSH
57538: LD_VAR 0 7
57542: PUSH
57543: LD_VAR 0 9
57547: PLUS
57548: ST_TO_ADDR
// if k > array then
57549: LD_VAR 0 8
57553: PUSH
57554: LD_VAR 0 1
57558: GREATER
57559: IFFALSE 57569
// k := 1 ;
57561: LD_ADDR_VAR 0 8
57565: PUSH
57566: LD_INT 1
57568: ST_TO_ADDR
// if not k then
57569: LD_VAR 0 8
57573: NOT
57574: IFFALSE 57586
// k := array ;
57576: LD_ADDR_VAR 0 8
57580: PUSH
57581: LD_VAR 0 1
57585: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57586: LD_ADDR_VAR 0 10
57590: PUSH
57591: LD_VAR 0 10
57595: PPUSH
57596: LD_VAR 0 8
57600: PPUSH
57601: LD_VAR 0 1
57605: PUSH
57606: LD_VAR 0 7
57610: ARRAY
57611: PPUSH
57612: CALL_OW 1
57616: ST_TO_ADDR
// end ;
57617: GO 57530
57619: POP
57620: POP
// array := tmp ;
57621: LD_ADDR_VAR 0 1
57625: PUSH
57626: LD_VAR 0 10
57630: ST_TO_ADDR
// end ;
57631: GO 57512
57633: POP
57634: POP
// result := array ;
57635: LD_ADDR_VAR 0 5
57639: PUSH
57640: LD_VAR 0 1
57644: ST_TO_ADDR
// end ;
57645: LD_VAR 0 5
57649: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57650: LD_INT 0
57652: PPUSH
57653: PPUSH
// result := 0 ;
57654: LD_ADDR_VAR 0 3
57658: PUSH
57659: LD_INT 0
57661: ST_TO_ADDR
// if not array or not value in array then
57662: LD_VAR 0 1
57666: NOT
57667: PUSH
57668: LD_VAR 0 2
57672: PUSH
57673: LD_VAR 0 1
57677: IN
57678: NOT
57679: OR
57680: IFFALSE 57684
// exit ;
57682: GO 57738
// for i = 1 to array do
57684: LD_ADDR_VAR 0 4
57688: PUSH
57689: DOUBLE
57690: LD_INT 1
57692: DEC
57693: ST_TO_ADDR
57694: LD_VAR 0 1
57698: PUSH
57699: FOR_TO
57700: IFFALSE 57736
// if value = array [ i ] then
57702: LD_VAR 0 2
57706: PUSH
57707: LD_VAR 0 1
57711: PUSH
57712: LD_VAR 0 4
57716: ARRAY
57717: EQUAL
57718: IFFALSE 57734
// begin result := i ;
57720: LD_ADDR_VAR 0 3
57724: PUSH
57725: LD_VAR 0 4
57729: ST_TO_ADDR
// exit ;
57730: POP
57731: POP
57732: GO 57738
// end ;
57734: GO 57699
57736: POP
57737: POP
// end ;
57738: LD_VAR 0 3
57742: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57743: LD_INT 0
57745: PPUSH
// vc_chassis := chassis ;
57746: LD_ADDR_OWVAR 37
57750: PUSH
57751: LD_VAR 0 1
57755: ST_TO_ADDR
// vc_engine := engine ;
57756: LD_ADDR_OWVAR 39
57760: PUSH
57761: LD_VAR 0 2
57765: ST_TO_ADDR
// vc_control := control ;
57766: LD_ADDR_OWVAR 38
57770: PUSH
57771: LD_VAR 0 3
57775: ST_TO_ADDR
// vc_weapon := weapon ;
57776: LD_ADDR_OWVAR 40
57780: PUSH
57781: LD_VAR 0 4
57785: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57786: LD_ADDR_OWVAR 41
57790: PUSH
57791: LD_VAR 0 5
57795: ST_TO_ADDR
// end ;
57796: LD_VAR 0 6
57800: RET
// export function WantPlant ( unit ) ; var task ; begin
57801: LD_INT 0
57803: PPUSH
57804: PPUSH
// result := false ;
57805: LD_ADDR_VAR 0 2
57809: PUSH
57810: LD_INT 0
57812: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57813: LD_ADDR_VAR 0 3
57817: PUSH
57818: LD_VAR 0 1
57822: PPUSH
57823: CALL_OW 437
57827: ST_TO_ADDR
// if task then
57828: LD_VAR 0 3
57832: IFFALSE 57860
// if task [ 1 ] [ 1 ] = p then
57834: LD_VAR 0 3
57838: PUSH
57839: LD_INT 1
57841: ARRAY
57842: PUSH
57843: LD_INT 1
57845: ARRAY
57846: PUSH
57847: LD_STRING p
57849: EQUAL
57850: IFFALSE 57860
// result := true ;
57852: LD_ADDR_VAR 0 2
57856: PUSH
57857: LD_INT 1
57859: ST_TO_ADDR
// end ;
57860: LD_VAR 0 2
57864: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57865: LD_INT 0
57867: PPUSH
57868: PPUSH
57869: PPUSH
57870: PPUSH
// if pos < 1 then
57871: LD_VAR 0 2
57875: PUSH
57876: LD_INT 1
57878: LESS
57879: IFFALSE 57883
// exit ;
57881: GO 58186
// if pos = 1 then
57883: LD_VAR 0 2
57887: PUSH
57888: LD_INT 1
57890: EQUAL
57891: IFFALSE 57924
// result := Replace ( arr , pos [ 1 ] , value ) else
57893: LD_ADDR_VAR 0 4
57897: PUSH
57898: LD_VAR 0 1
57902: PPUSH
57903: LD_VAR 0 2
57907: PUSH
57908: LD_INT 1
57910: ARRAY
57911: PPUSH
57912: LD_VAR 0 3
57916: PPUSH
57917: CALL_OW 1
57921: ST_TO_ADDR
57922: GO 58186
// begin tmp := arr ;
57924: LD_ADDR_VAR 0 6
57928: PUSH
57929: LD_VAR 0 1
57933: ST_TO_ADDR
// s_arr := [ tmp ] ;
57934: LD_ADDR_VAR 0 7
57938: PUSH
57939: LD_VAR 0 6
57943: PUSH
57944: EMPTY
57945: LIST
57946: ST_TO_ADDR
// for i = 1 to pos - 1 do
57947: LD_ADDR_VAR 0 5
57951: PUSH
57952: DOUBLE
57953: LD_INT 1
57955: DEC
57956: ST_TO_ADDR
57957: LD_VAR 0 2
57961: PUSH
57962: LD_INT 1
57964: MINUS
57965: PUSH
57966: FOR_TO
57967: IFFALSE 58012
// begin tmp := tmp [ pos [ i ] ] ;
57969: LD_ADDR_VAR 0 6
57973: PUSH
57974: LD_VAR 0 6
57978: PUSH
57979: LD_VAR 0 2
57983: PUSH
57984: LD_VAR 0 5
57988: ARRAY
57989: ARRAY
57990: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57991: LD_ADDR_VAR 0 7
57995: PUSH
57996: LD_VAR 0 7
58000: PUSH
58001: LD_VAR 0 6
58005: PUSH
58006: EMPTY
58007: LIST
58008: ADD
58009: ST_TO_ADDR
// end ;
58010: GO 57966
58012: POP
58013: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
58014: LD_ADDR_VAR 0 6
58018: PUSH
58019: LD_VAR 0 6
58023: PPUSH
58024: LD_VAR 0 2
58028: PUSH
58029: LD_VAR 0 2
58033: ARRAY
58034: PPUSH
58035: LD_VAR 0 3
58039: PPUSH
58040: CALL_OW 1
58044: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
58045: LD_ADDR_VAR 0 7
58049: PUSH
58050: LD_VAR 0 7
58054: PPUSH
58055: LD_VAR 0 7
58059: PPUSH
58060: LD_VAR 0 6
58064: PPUSH
58065: CALL_OW 1
58069: ST_TO_ADDR
// for i = s_arr downto 2 do
58070: LD_ADDR_VAR 0 5
58074: PUSH
58075: DOUBLE
58076: LD_VAR 0 7
58080: INC
58081: ST_TO_ADDR
58082: LD_INT 2
58084: PUSH
58085: FOR_DOWNTO
58086: IFFALSE 58170
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58088: LD_ADDR_VAR 0 6
58092: PUSH
58093: LD_VAR 0 7
58097: PUSH
58098: LD_VAR 0 5
58102: PUSH
58103: LD_INT 1
58105: MINUS
58106: ARRAY
58107: PPUSH
58108: LD_VAR 0 2
58112: PUSH
58113: LD_VAR 0 5
58117: PUSH
58118: LD_INT 1
58120: MINUS
58121: ARRAY
58122: PPUSH
58123: LD_VAR 0 7
58127: PUSH
58128: LD_VAR 0 5
58132: ARRAY
58133: PPUSH
58134: CALL_OW 1
58138: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58139: LD_ADDR_VAR 0 7
58143: PUSH
58144: LD_VAR 0 7
58148: PPUSH
58149: LD_VAR 0 5
58153: PUSH
58154: LD_INT 1
58156: MINUS
58157: PPUSH
58158: LD_VAR 0 6
58162: PPUSH
58163: CALL_OW 1
58167: ST_TO_ADDR
// end ;
58168: GO 58085
58170: POP
58171: POP
// result := s_arr [ 1 ] ;
58172: LD_ADDR_VAR 0 4
58176: PUSH
58177: LD_VAR 0 7
58181: PUSH
58182: LD_INT 1
58184: ARRAY
58185: ST_TO_ADDR
// end ; end ;
58186: LD_VAR 0 4
58190: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58191: LD_INT 0
58193: PPUSH
58194: PPUSH
// if not list then
58195: LD_VAR 0 1
58199: NOT
58200: IFFALSE 58204
// exit ;
58202: GO 58295
// i := list [ pos1 ] ;
58204: LD_ADDR_VAR 0 5
58208: PUSH
58209: LD_VAR 0 1
58213: PUSH
58214: LD_VAR 0 2
58218: ARRAY
58219: ST_TO_ADDR
// if not i then
58220: LD_VAR 0 5
58224: NOT
58225: IFFALSE 58229
// exit ;
58227: GO 58295
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58229: LD_ADDR_VAR 0 1
58233: PUSH
58234: LD_VAR 0 1
58238: PPUSH
58239: LD_VAR 0 2
58243: PPUSH
58244: LD_VAR 0 1
58248: PUSH
58249: LD_VAR 0 3
58253: ARRAY
58254: PPUSH
58255: CALL_OW 1
58259: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58260: LD_ADDR_VAR 0 1
58264: PUSH
58265: LD_VAR 0 1
58269: PPUSH
58270: LD_VAR 0 3
58274: PPUSH
58275: LD_VAR 0 5
58279: PPUSH
58280: CALL_OW 1
58284: ST_TO_ADDR
// result := list ;
58285: LD_ADDR_VAR 0 4
58289: PUSH
58290: LD_VAR 0 1
58294: ST_TO_ADDR
// end ;
58295: LD_VAR 0 4
58299: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58300: LD_INT 0
58302: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58303: LD_ADDR_VAR 0 5
58307: PUSH
58308: LD_VAR 0 1
58312: PPUSH
58313: CALL_OW 250
58317: PPUSH
58318: LD_VAR 0 1
58322: PPUSH
58323: CALL_OW 251
58327: PPUSH
58328: LD_VAR 0 2
58332: PPUSH
58333: LD_VAR 0 3
58337: PPUSH
58338: LD_VAR 0 4
58342: PPUSH
58343: CALL 58721 0 5
58347: ST_TO_ADDR
// end ;
58348: LD_VAR 0 5
58352: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
58353: LD_INT 0
58355: PPUSH
58356: PPUSH
58357: PPUSH
58358: PPUSH
// if not list or not unit then
58359: LD_VAR 0 2
58363: NOT
58364: PUSH
58365: LD_VAR 0 1
58369: NOT
58370: OR
58371: IFFALSE 58375
// exit ;
58373: GO 58716
// result := [ ] ;
58375: LD_ADDR_VAR 0 5
58379: PUSH
58380: EMPTY
58381: ST_TO_ADDR
// for i in list do
58382: LD_ADDR_VAR 0 6
58386: PUSH
58387: LD_VAR 0 2
58391: PUSH
58392: FOR_IN
58393: IFFALSE 58611
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
58395: LD_ADDR_VAR 0 8
58399: PUSH
58400: LD_VAR 0 1
58404: PPUSH
58405: LD_VAR 0 6
58409: PUSH
58410: LD_INT 1
58412: ARRAY
58413: PPUSH
58414: LD_VAR 0 6
58418: PUSH
58419: LD_INT 2
58421: ARRAY
58422: PPUSH
58423: CALL_OW 297
58427: ST_TO_ADDR
// if not Count ( result ) then
58428: LD_VAR 0 5
58432: PPUSH
58433: CALL 55005 0 1
58437: NOT
58438: IFFALSE 58471
// begin result := Join ( result , [ i , tmp ] ) ;
58440: LD_ADDR_VAR 0 5
58444: PUSH
58445: LD_VAR 0 5
58449: PPUSH
58450: LD_VAR 0 6
58454: PUSH
58455: LD_VAR 0 8
58459: PUSH
58460: EMPTY
58461: LIST
58462: LIST
58463: PPUSH
58464: CALL 90605 0 2
58468: ST_TO_ADDR
// continue ;
58469: GO 58392
// end ; if result [ result ] [ 2 ] <= tmp then
58471: LD_VAR 0 5
58475: PUSH
58476: LD_VAR 0 5
58480: ARRAY
58481: PUSH
58482: LD_INT 2
58484: ARRAY
58485: PUSH
58486: LD_VAR 0 8
58490: LESSEQUAL
58491: IFFALSE 58524
// result := Join ( result , [ i , tmp ] ) else
58493: LD_ADDR_VAR 0 5
58497: PUSH
58498: LD_VAR 0 5
58502: PPUSH
58503: LD_VAR 0 6
58507: PUSH
58508: LD_VAR 0 8
58512: PUSH
58513: EMPTY
58514: LIST
58515: LIST
58516: PPUSH
58517: CALL 90605 0 2
58521: ST_TO_ADDR
58522: GO 58609
// begin for j := 1 to Count ( result ) do
58524: LD_ADDR_VAR 0 7
58528: PUSH
58529: DOUBLE
58530: LD_INT 1
58532: DEC
58533: ST_TO_ADDR
58534: LD_VAR 0 5
58538: PPUSH
58539: CALL 55005 0 1
58543: PUSH
58544: FOR_TO
58545: IFFALSE 58607
// begin if tmp < result [ j ] [ 2 ] then
58547: LD_VAR 0 8
58551: PUSH
58552: LD_VAR 0 5
58556: PUSH
58557: LD_VAR 0 7
58561: ARRAY
58562: PUSH
58563: LD_INT 2
58565: ARRAY
58566: LESS
58567: IFFALSE 58605
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58569: LD_ADDR_VAR 0 5
58573: PUSH
58574: LD_VAR 0 5
58578: PPUSH
58579: LD_VAR 0 7
58583: PPUSH
58584: LD_VAR 0 6
58588: PUSH
58589: LD_VAR 0 8
58593: PUSH
58594: EMPTY
58595: LIST
58596: LIST
58597: PPUSH
58598: CALL_OW 2
58602: ST_TO_ADDR
// break ;
58603: GO 58607
// end ; end ;
58605: GO 58544
58607: POP
58608: POP
// end ; end ;
58609: GO 58392
58611: POP
58612: POP
// if result and not asc then
58613: LD_VAR 0 5
58617: PUSH
58618: LD_VAR 0 3
58622: NOT
58623: AND
58624: IFFALSE 58641
// result := ReverseArray ( result ) ;
58626: LD_ADDR_VAR 0 5
58630: PUSH
58631: LD_VAR 0 5
58635: PPUSH
58636: CALL 85881 0 1
58640: ST_TO_ADDR
// tmp := [ ] ;
58641: LD_ADDR_VAR 0 8
58645: PUSH
58646: EMPTY
58647: ST_TO_ADDR
// if mode then
58648: LD_VAR 0 4
58652: IFFALSE 58716
// begin for i := 1 to result do
58654: LD_ADDR_VAR 0 6
58658: PUSH
58659: DOUBLE
58660: LD_INT 1
58662: DEC
58663: ST_TO_ADDR
58664: LD_VAR 0 5
58668: PUSH
58669: FOR_TO
58670: IFFALSE 58704
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
58672: LD_ADDR_VAR 0 8
58676: PUSH
58677: LD_VAR 0 8
58681: PPUSH
58682: LD_VAR 0 5
58686: PUSH
58687: LD_VAR 0 6
58691: ARRAY
58692: PUSH
58693: LD_INT 1
58695: ARRAY
58696: PPUSH
58697: CALL 90605 0 2
58701: ST_TO_ADDR
58702: GO 58669
58704: POP
58705: POP
// result := tmp ;
58706: LD_ADDR_VAR 0 5
58710: PUSH
58711: LD_VAR 0 8
58715: ST_TO_ADDR
// end ; end ;
58716: LD_VAR 0 5
58720: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58721: LD_INT 0
58723: PPUSH
58724: PPUSH
58725: PPUSH
58726: PPUSH
// if not list then
58727: LD_VAR 0 3
58731: NOT
58732: IFFALSE 58736
// exit ;
58734: GO 59124
// result := [ ] ;
58736: LD_ADDR_VAR 0 6
58740: PUSH
58741: EMPTY
58742: ST_TO_ADDR
// for i in list do
58743: LD_ADDR_VAR 0 7
58747: PUSH
58748: LD_VAR 0 3
58752: PUSH
58753: FOR_IN
58754: IFFALSE 58956
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58756: LD_ADDR_VAR 0 9
58760: PUSH
58761: LD_VAR 0 7
58765: PPUSH
58766: LD_VAR 0 1
58770: PPUSH
58771: LD_VAR 0 2
58775: PPUSH
58776: CALL_OW 297
58780: ST_TO_ADDR
// if not result then
58781: LD_VAR 0 6
58785: NOT
58786: IFFALSE 58812
// result := [ [ i , tmp ] ] else
58788: LD_ADDR_VAR 0 6
58792: PUSH
58793: LD_VAR 0 7
58797: PUSH
58798: LD_VAR 0 9
58802: PUSH
58803: EMPTY
58804: LIST
58805: LIST
58806: PUSH
58807: EMPTY
58808: LIST
58809: ST_TO_ADDR
58810: GO 58954
// begin if result [ result ] [ 2 ] < tmp then
58812: LD_VAR 0 6
58816: PUSH
58817: LD_VAR 0 6
58821: ARRAY
58822: PUSH
58823: LD_INT 2
58825: ARRAY
58826: PUSH
58827: LD_VAR 0 9
58831: LESS
58832: IFFALSE 58874
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58834: LD_ADDR_VAR 0 6
58838: PUSH
58839: LD_VAR 0 6
58843: PPUSH
58844: LD_VAR 0 6
58848: PUSH
58849: LD_INT 1
58851: PLUS
58852: PPUSH
58853: LD_VAR 0 7
58857: PUSH
58858: LD_VAR 0 9
58862: PUSH
58863: EMPTY
58864: LIST
58865: LIST
58866: PPUSH
58867: CALL_OW 2
58871: ST_TO_ADDR
58872: GO 58954
// for j = 1 to result do
58874: LD_ADDR_VAR 0 8
58878: PUSH
58879: DOUBLE
58880: LD_INT 1
58882: DEC
58883: ST_TO_ADDR
58884: LD_VAR 0 6
58888: PUSH
58889: FOR_TO
58890: IFFALSE 58952
// begin if tmp < result [ j ] [ 2 ] then
58892: LD_VAR 0 9
58896: PUSH
58897: LD_VAR 0 6
58901: PUSH
58902: LD_VAR 0 8
58906: ARRAY
58907: PUSH
58908: LD_INT 2
58910: ARRAY
58911: LESS
58912: IFFALSE 58950
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58914: LD_ADDR_VAR 0 6
58918: PUSH
58919: LD_VAR 0 6
58923: PPUSH
58924: LD_VAR 0 8
58928: PPUSH
58929: LD_VAR 0 7
58933: PUSH
58934: LD_VAR 0 9
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: PPUSH
58943: CALL_OW 2
58947: ST_TO_ADDR
// break ;
58948: GO 58952
// end ; end ;
58950: GO 58889
58952: POP
58953: POP
// end ; end ;
58954: GO 58753
58956: POP
58957: POP
// if result and not asc then
58958: LD_VAR 0 6
58962: PUSH
58963: LD_VAR 0 4
58967: NOT
58968: AND
58969: IFFALSE 59044
// begin tmp := result ;
58971: LD_ADDR_VAR 0 9
58975: PUSH
58976: LD_VAR 0 6
58980: ST_TO_ADDR
// for i = tmp downto 1 do
58981: LD_ADDR_VAR 0 7
58985: PUSH
58986: DOUBLE
58987: LD_VAR 0 9
58991: INC
58992: ST_TO_ADDR
58993: LD_INT 1
58995: PUSH
58996: FOR_DOWNTO
58997: IFFALSE 59042
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58999: LD_ADDR_VAR 0 6
59003: PUSH
59004: LD_VAR 0 6
59008: PPUSH
59009: LD_VAR 0 9
59013: PUSH
59014: LD_VAR 0 7
59018: MINUS
59019: PUSH
59020: LD_INT 1
59022: PLUS
59023: PPUSH
59024: LD_VAR 0 9
59028: PUSH
59029: LD_VAR 0 7
59033: ARRAY
59034: PPUSH
59035: CALL_OW 1
59039: ST_TO_ADDR
59040: GO 58996
59042: POP
59043: POP
// end ; tmp := [ ] ;
59044: LD_ADDR_VAR 0 9
59048: PUSH
59049: EMPTY
59050: ST_TO_ADDR
// if mode then
59051: LD_VAR 0 5
59055: IFFALSE 59124
// begin for i = 1 to result do
59057: LD_ADDR_VAR 0 7
59061: PUSH
59062: DOUBLE
59063: LD_INT 1
59065: DEC
59066: ST_TO_ADDR
59067: LD_VAR 0 6
59071: PUSH
59072: FOR_TO
59073: IFFALSE 59112
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
59075: LD_ADDR_VAR 0 9
59079: PUSH
59080: LD_VAR 0 9
59084: PPUSH
59085: LD_VAR 0 7
59089: PPUSH
59090: LD_VAR 0 6
59094: PUSH
59095: LD_VAR 0 7
59099: ARRAY
59100: PUSH
59101: LD_INT 1
59103: ARRAY
59104: PPUSH
59105: CALL_OW 1
59109: ST_TO_ADDR
59110: GO 59072
59112: POP
59113: POP
// result := tmp ;
59114: LD_ADDR_VAR 0 6
59118: PUSH
59119: LD_VAR 0 9
59123: ST_TO_ADDR
// end ; end ;
59124: LD_VAR 0 6
59128: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
59129: LD_INT 0
59131: PPUSH
59132: PPUSH
59133: PPUSH
59134: PPUSH
59135: PPUSH
59136: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
59137: LD_ADDR_VAR 0 5
59141: PUSH
59142: LD_INT 0
59144: PUSH
59145: LD_INT 0
59147: PUSH
59148: LD_INT 0
59150: PUSH
59151: EMPTY
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: LIST
59157: LIST
59158: ST_TO_ADDR
// if not x or not y then
59159: LD_VAR 0 2
59163: NOT
59164: PUSH
59165: LD_VAR 0 3
59169: NOT
59170: OR
59171: IFFALSE 59175
// exit ;
59173: GO 60825
// if not range then
59175: LD_VAR 0 4
59179: NOT
59180: IFFALSE 59190
// range := 10 ;
59182: LD_ADDR_VAR 0 4
59186: PUSH
59187: LD_INT 10
59189: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
59190: LD_ADDR_VAR 0 8
59194: PUSH
59195: LD_INT 81
59197: PUSH
59198: LD_VAR 0 1
59202: PUSH
59203: EMPTY
59204: LIST
59205: LIST
59206: PUSH
59207: LD_INT 92
59209: PUSH
59210: LD_VAR 0 2
59214: PUSH
59215: LD_VAR 0 3
59219: PUSH
59220: LD_VAR 0 4
59224: PUSH
59225: EMPTY
59226: LIST
59227: LIST
59228: LIST
59229: LIST
59230: PUSH
59231: LD_INT 3
59233: PUSH
59234: LD_INT 21
59236: PUSH
59237: LD_INT 3
59239: PUSH
59240: EMPTY
59241: LIST
59242: LIST
59243: PUSH
59244: EMPTY
59245: LIST
59246: LIST
59247: PUSH
59248: EMPTY
59249: LIST
59250: LIST
59251: LIST
59252: PPUSH
59253: CALL_OW 69
59257: ST_TO_ADDR
// if not tmp then
59258: LD_VAR 0 8
59262: NOT
59263: IFFALSE 59267
// exit ;
59265: GO 60825
// for i in tmp do
59267: LD_ADDR_VAR 0 6
59271: PUSH
59272: LD_VAR 0 8
59276: PUSH
59277: FOR_IN
59278: IFFALSE 60800
// begin points := [ 0 , 0 , 0 ] ;
59280: LD_ADDR_VAR 0 9
59284: PUSH
59285: LD_INT 0
59287: PUSH
59288: LD_INT 0
59290: PUSH
59291: LD_INT 0
59293: PUSH
59294: EMPTY
59295: LIST
59296: LIST
59297: LIST
59298: ST_TO_ADDR
// bpoints := 1 ;
59299: LD_ADDR_VAR 0 10
59303: PUSH
59304: LD_INT 1
59306: ST_TO_ADDR
// case GetType ( i ) of unit_human :
59307: LD_VAR 0 6
59311: PPUSH
59312: CALL_OW 247
59316: PUSH
59317: LD_INT 1
59319: DOUBLE
59320: EQUAL
59321: IFTRUE 59325
59323: GO 59903
59325: POP
// begin if GetClass ( i ) = 1 then
59326: LD_VAR 0 6
59330: PPUSH
59331: CALL_OW 257
59335: PUSH
59336: LD_INT 1
59338: EQUAL
59339: IFFALSE 59360
// points := [ 10 , 5 , 3 ] ;
59341: LD_ADDR_VAR 0 9
59345: PUSH
59346: LD_INT 10
59348: PUSH
59349: LD_INT 5
59351: PUSH
59352: LD_INT 3
59354: PUSH
59355: EMPTY
59356: LIST
59357: LIST
59358: LIST
59359: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
59360: LD_VAR 0 6
59364: PPUSH
59365: CALL_OW 257
59369: PUSH
59370: LD_INT 2
59372: PUSH
59373: LD_INT 3
59375: PUSH
59376: LD_INT 4
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: LIST
59383: IN
59384: IFFALSE 59405
// points := [ 3 , 2 , 1 ] ;
59386: LD_ADDR_VAR 0 9
59390: PUSH
59391: LD_INT 3
59393: PUSH
59394: LD_INT 2
59396: PUSH
59397: LD_INT 1
59399: PUSH
59400: EMPTY
59401: LIST
59402: LIST
59403: LIST
59404: ST_TO_ADDR
// if GetClass ( i ) = 5 then
59405: LD_VAR 0 6
59409: PPUSH
59410: CALL_OW 257
59414: PUSH
59415: LD_INT 5
59417: EQUAL
59418: IFFALSE 59439
// points := [ 130 , 5 , 2 ] ;
59420: LD_ADDR_VAR 0 9
59424: PUSH
59425: LD_INT 130
59427: PUSH
59428: LD_INT 5
59430: PUSH
59431: LD_INT 2
59433: PUSH
59434: EMPTY
59435: LIST
59436: LIST
59437: LIST
59438: ST_TO_ADDR
// if GetClass ( i ) = 8 then
59439: LD_VAR 0 6
59443: PPUSH
59444: CALL_OW 257
59448: PUSH
59449: LD_INT 8
59451: EQUAL
59452: IFFALSE 59473
// points := [ 35 , 35 , 30 ] ;
59454: LD_ADDR_VAR 0 9
59458: PUSH
59459: LD_INT 35
59461: PUSH
59462: LD_INT 35
59464: PUSH
59465: LD_INT 30
59467: PUSH
59468: EMPTY
59469: LIST
59470: LIST
59471: LIST
59472: ST_TO_ADDR
// if GetClass ( i ) = 9 then
59473: LD_VAR 0 6
59477: PPUSH
59478: CALL_OW 257
59482: PUSH
59483: LD_INT 9
59485: EQUAL
59486: IFFALSE 59507
// points := [ 20 , 55 , 40 ] ;
59488: LD_ADDR_VAR 0 9
59492: PUSH
59493: LD_INT 20
59495: PUSH
59496: LD_INT 55
59498: PUSH
59499: LD_INT 40
59501: PUSH
59502: EMPTY
59503: LIST
59504: LIST
59505: LIST
59506: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59507: LD_VAR 0 6
59511: PPUSH
59512: CALL_OW 257
59516: PUSH
59517: LD_INT 12
59519: PUSH
59520: LD_INT 16
59522: PUSH
59523: EMPTY
59524: LIST
59525: LIST
59526: IN
59527: IFFALSE 59548
// points := [ 5 , 3 , 2 ] ;
59529: LD_ADDR_VAR 0 9
59533: PUSH
59534: LD_INT 5
59536: PUSH
59537: LD_INT 3
59539: PUSH
59540: LD_INT 2
59542: PUSH
59543: EMPTY
59544: LIST
59545: LIST
59546: LIST
59547: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59548: LD_VAR 0 6
59552: PPUSH
59553: CALL_OW 257
59557: PUSH
59558: LD_INT 17
59560: EQUAL
59561: IFFALSE 59582
// points := [ 100 , 50 , 75 ] ;
59563: LD_ADDR_VAR 0 9
59567: PUSH
59568: LD_INT 100
59570: PUSH
59571: LD_INT 50
59573: PUSH
59574: LD_INT 75
59576: PUSH
59577: EMPTY
59578: LIST
59579: LIST
59580: LIST
59581: ST_TO_ADDR
// if GetClass ( i ) = 15 then
59582: LD_VAR 0 6
59586: PPUSH
59587: CALL_OW 257
59591: PUSH
59592: LD_INT 15
59594: EQUAL
59595: IFFALSE 59616
// points := [ 10 , 5 , 3 ] ;
59597: LD_ADDR_VAR 0 9
59601: PUSH
59602: LD_INT 10
59604: PUSH
59605: LD_INT 5
59607: PUSH
59608: LD_INT 3
59610: PUSH
59611: EMPTY
59612: LIST
59613: LIST
59614: LIST
59615: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59616: LD_VAR 0 6
59620: PPUSH
59621: CALL_OW 257
59625: PUSH
59626: LD_INT 14
59628: EQUAL
59629: IFFALSE 59650
// points := [ 10 , 0 , 0 ] ;
59631: LD_ADDR_VAR 0 9
59635: PUSH
59636: LD_INT 10
59638: PUSH
59639: LD_INT 0
59641: PUSH
59642: LD_INT 0
59644: PUSH
59645: EMPTY
59646: LIST
59647: LIST
59648: LIST
59649: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59650: LD_VAR 0 6
59654: PPUSH
59655: CALL_OW 257
59659: PUSH
59660: LD_INT 11
59662: EQUAL
59663: IFFALSE 59684
// points := [ 30 , 10 , 5 ] ;
59665: LD_ADDR_VAR 0 9
59669: PUSH
59670: LD_INT 30
59672: PUSH
59673: LD_INT 10
59675: PUSH
59676: LD_INT 5
59678: PUSH
59679: EMPTY
59680: LIST
59681: LIST
59682: LIST
59683: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59684: LD_VAR 0 1
59688: PPUSH
59689: LD_INT 5
59691: PPUSH
59692: CALL_OW 321
59696: PUSH
59697: LD_INT 2
59699: EQUAL
59700: IFFALSE 59717
// bpoints := bpoints * 1.8 ;
59702: LD_ADDR_VAR 0 10
59706: PUSH
59707: LD_VAR 0 10
59711: PUSH
59712: LD_REAL  1.80000000000000E+0000
59715: MUL
59716: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59717: LD_VAR 0 6
59721: PPUSH
59722: CALL_OW 257
59726: PUSH
59727: LD_INT 1
59729: PUSH
59730: LD_INT 2
59732: PUSH
59733: LD_INT 3
59735: PUSH
59736: LD_INT 4
59738: PUSH
59739: EMPTY
59740: LIST
59741: LIST
59742: LIST
59743: LIST
59744: IN
59745: PUSH
59746: LD_VAR 0 1
59750: PPUSH
59751: LD_INT 51
59753: PPUSH
59754: CALL_OW 321
59758: PUSH
59759: LD_INT 2
59761: EQUAL
59762: AND
59763: IFFALSE 59780
// bpoints := bpoints * 1.2 ;
59765: LD_ADDR_VAR 0 10
59769: PUSH
59770: LD_VAR 0 10
59774: PUSH
59775: LD_REAL  1.20000000000000E+0000
59778: MUL
59779: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59780: LD_VAR 0 6
59784: PPUSH
59785: CALL_OW 257
59789: PUSH
59790: LD_INT 5
59792: PUSH
59793: LD_INT 7
59795: PUSH
59796: LD_INT 9
59798: PUSH
59799: EMPTY
59800: LIST
59801: LIST
59802: LIST
59803: IN
59804: PUSH
59805: LD_VAR 0 1
59809: PPUSH
59810: LD_INT 52
59812: PPUSH
59813: CALL_OW 321
59817: PUSH
59818: LD_INT 2
59820: EQUAL
59821: AND
59822: IFFALSE 59839
// bpoints := bpoints * 1.5 ;
59824: LD_ADDR_VAR 0 10
59828: PUSH
59829: LD_VAR 0 10
59833: PUSH
59834: LD_REAL  1.50000000000000E+0000
59837: MUL
59838: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59839: LD_VAR 0 1
59843: PPUSH
59844: LD_INT 66
59846: PPUSH
59847: CALL_OW 321
59851: PUSH
59852: LD_INT 2
59854: EQUAL
59855: IFFALSE 59872
// bpoints := bpoints * 1.1 ;
59857: LD_ADDR_VAR 0 10
59861: PUSH
59862: LD_VAR 0 10
59866: PUSH
59867: LD_REAL  1.10000000000000E+0000
59870: MUL
59871: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59872: LD_ADDR_VAR 0 10
59876: PUSH
59877: LD_VAR 0 10
59881: PUSH
59882: LD_VAR 0 6
59886: PPUSH
59887: LD_INT 1
59889: PPUSH
59890: CALL_OW 259
59894: PUSH
59895: LD_REAL  1.15000000000000E+0000
59898: MUL
59899: MUL
59900: ST_TO_ADDR
// end ; unit_vehicle :
59901: GO 60729
59903: LD_INT 2
59905: DOUBLE
59906: EQUAL
59907: IFTRUE 59911
59909: GO 60717
59911: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59912: LD_VAR 0 6
59916: PPUSH
59917: CALL_OW 264
59921: PUSH
59922: LD_INT 2
59924: PUSH
59925: LD_INT 42
59927: PUSH
59928: LD_INT 24
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: LIST
59935: IN
59936: IFFALSE 59957
// points := [ 25 , 5 , 3 ] ;
59938: LD_ADDR_VAR 0 9
59942: PUSH
59943: LD_INT 25
59945: PUSH
59946: LD_INT 5
59948: PUSH
59949: LD_INT 3
59951: PUSH
59952: EMPTY
59953: LIST
59954: LIST
59955: LIST
59956: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59957: LD_VAR 0 6
59961: PPUSH
59962: CALL_OW 264
59966: PUSH
59967: LD_INT 4
59969: PUSH
59970: LD_INT 43
59972: PUSH
59973: LD_INT 25
59975: PUSH
59976: EMPTY
59977: LIST
59978: LIST
59979: LIST
59980: IN
59981: IFFALSE 60002
// points := [ 40 , 15 , 5 ] ;
59983: LD_ADDR_VAR 0 9
59987: PUSH
59988: LD_INT 40
59990: PUSH
59991: LD_INT 15
59993: PUSH
59994: LD_INT 5
59996: PUSH
59997: EMPTY
59998: LIST
59999: LIST
60000: LIST
60001: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
60002: LD_VAR 0 6
60006: PPUSH
60007: CALL_OW 264
60011: PUSH
60012: LD_INT 3
60014: PUSH
60015: LD_INT 23
60017: PUSH
60018: EMPTY
60019: LIST
60020: LIST
60021: IN
60022: IFFALSE 60043
// points := [ 7 , 25 , 8 ] ;
60024: LD_ADDR_VAR 0 9
60028: PUSH
60029: LD_INT 7
60031: PUSH
60032: LD_INT 25
60034: PUSH
60035: LD_INT 8
60037: PUSH
60038: EMPTY
60039: LIST
60040: LIST
60041: LIST
60042: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
60043: LD_VAR 0 6
60047: PPUSH
60048: CALL_OW 264
60052: PUSH
60053: LD_INT 5
60055: PUSH
60056: LD_INT 27
60058: PUSH
60059: LD_INT 44
60061: PUSH
60062: EMPTY
60063: LIST
60064: LIST
60065: LIST
60066: IN
60067: IFFALSE 60088
// points := [ 14 , 50 , 16 ] ;
60069: LD_ADDR_VAR 0 9
60073: PUSH
60074: LD_INT 14
60076: PUSH
60077: LD_INT 50
60079: PUSH
60080: LD_INT 16
60082: PUSH
60083: EMPTY
60084: LIST
60085: LIST
60086: LIST
60087: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
60088: LD_VAR 0 6
60092: PPUSH
60093: CALL_OW 264
60097: PUSH
60098: LD_INT 6
60100: PUSH
60101: LD_INT 46
60103: PUSH
60104: EMPTY
60105: LIST
60106: LIST
60107: IN
60108: IFFALSE 60129
// points := [ 32 , 120 , 70 ] ;
60110: LD_ADDR_VAR 0 9
60114: PUSH
60115: LD_INT 32
60117: PUSH
60118: LD_INT 120
60120: PUSH
60121: LD_INT 70
60123: PUSH
60124: EMPTY
60125: LIST
60126: LIST
60127: LIST
60128: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
60129: LD_VAR 0 6
60133: PPUSH
60134: CALL_OW 264
60138: PUSH
60139: LD_INT 7
60141: PUSH
60142: LD_INT 28
60144: PUSH
60145: LD_INT 45
60147: PUSH
60148: LD_INT 92
60150: PUSH
60151: EMPTY
60152: LIST
60153: LIST
60154: LIST
60155: LIST
60156: IN
60157: IFFALSE 60178
// points := [ 35 , 20 , 45 ] ;
60159: LD_ADDR_VAR 0 9
60163: PUSH
60164: LD_INT 35
60166: PUSH
60167: LD_INT 20
60169: PUSH
60170: LD_INT 45
60172: PUSH
60173: EMPTY
60174: LIST
60175: LIST
60176: LIST
60177: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
60178: LD_VAR 0 6
60182: PPUSH
60183: CALL_OW 264
60187: PUSH
60188: LD_INT 47
60190: PUSH
60191: EMPTY
60192: LIST
60193: IN
60194: IFFALSE 60215
// points := [ 67 , 45 , 75 ] ;
60196: LD_ADDR_VAR 0 9
60200: PUSH
60201: LD_INT 67
60203: PUSH
60204: LD_INT 45
60206: PUSH
60207: LD_INT 75
60209: PUSH
60210: EMPTY
60211: LIST
60212: LIST
60213: LIST
60214: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
60215: LD_VAR 0 6
60219: PPUSH
60220: CALL_OW 264
60224: PUSH
60225: LD_INT 26
60227: PUSH
60228: EMPTY
60229: LIST
60230: IN
60231: IFFALSE 60252
// points := [ 120 , 30 , 80 ] ;
60233: LD_ADDR_VAR 0 9
60237: PUSH
60238: LD_INT 120
60240: PUSH
60241: LD_INT 30
60243: PUSH
60244: LD_INT 80
60246: PUSH
60247: EMPTY
60248: LIST
60249: LIST
60250: LIST
60251: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
60252: LD_VAR 0 6
60256: PPUSH
60257: CALL_OW 264
60261: PUSH
60262: LD_INT 22
60264: PUSH
60265: EMPTY
60266: LIST
60267: IN
60268: IFFALSE 60289
// points := [ 40 , 1 , 1 ] ;
60270: LD_ADDR_VAR 0 9
60274: PUSH
60275: LD_INT 40
60277: PUSH
60278: LD_INT 1
60280: PUSH
60281: LD_INT 1
60283: PUSH
60284: EMPTY
60285: LIST
60286: LIST
60287: LIST
60288: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
60289: LD_VAR 0 6
60293: PPUSH
60294: CALL_OW 264
60298: PUSH
60299: LD_INT 29
60301: PUSH
60302: EMPTY
60303: LIST
60304: IN
60305: IFFALSE 60326
// points := [ 70 , 200 , 400 ] ;
60307: LD_ADDR_VAR 0 9
60311: PUSH
60312: LD_INT 70
60314: PUSH
60315: LD_INT 200
60317: PUSH
60318: LD_INT 400
60320: PUSH
60321: EMPTY
60322: LIST
60323: LIST
60324: LIST
60325: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
60326: LD_VAR 0 6
60330: PPUSH
60331: CALL_OW 264
60335: PUSH
60336: LD_INT 14
60338: PUSH
60339: LD_INT 53
60341: PUSH
60342: EMPTY
60343: LIST
60344: LIST
60345: IN
60346: IFFALSE 60367
// points := [ 40 , 10 , 20 ] ;
60348: LD_ADDR_VAR 0 9
60352: PUSH
60353: LD_INT 40
60355: PUSH
60356: LD_INT 10
60358: PUSH
60359: LD_INT 20
60361: PUSH
60362: EMPTY
60363: LIST
60364: LIST
60365: LIST
60366: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
60367: LD_VAR 0 6
60371: PPUSH
60372: CALL_OW 264
60376: PUSH
60377: LD_INT 9
60379: PUSH
60380: EMPTY
60381: LIST
60382: IN
60383: IFFALSE 60404
// points := [ 5 , 70 , 20 ] ;
60385: LD_ADDR_VAR 0 9
60389: PUSH
60390: LD_INT 5
60392: PUSH
60393: LD_INT 70
60395: PUSH
60396: LD_INT 20
60398: PUSH
60399: EMPTY
60400: LIST
60401: LIST
60402: LIST
60403: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
60404: LD_VAR 0 6
60408: PPUSH
60409: CALL_OW 264
60413: PUSH
60414: LD_INT 10
60416: PUSH
60417: EMPTY
60418: LIST
60419: IN
60420: IFFALSE 60441
// points := [ 35 , 110 , 70 ] ;
60422: LD_ADDR_VAR 0 9
60426: PUSH
60427: LD_INT 35
60429: PUSH
60430: LD_INT 110
60432: PUSH
60433: LD_INT 70
60435: PUSH
60436: EMPTY
60437: LIST
60438: LIST
60439: LIST
60440: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
60441: LD_VAR 0 6
60445: PPUSH
60446: CALL_OW 265
60450: PUSH
60451: LD_INT 25
60453: EQUAL
60454: IFFALSE 60475
// points := [ 80 , 65 , 100 ] ;
60456: LD_ADDR_VAR 0 9
60460: PUSH
60461: LD_INT 80
60463: PUSH
60464: LD_INT 65
60466: PUSH
60467: LD_INT 100
60469: PUSH
60470: EMPTY
60471: LIST
60472: LIST
60473: LIST
60474: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
60475: LD_VAR 0 6
60479: PPUSH
60480: CALL_OW 263
60484: PUSH
60485: LD_INT 1
60487: EQUAL
60488: IFFALSE 60523
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
60490: LD_ADDR_VAR 0 10
60494: PUSH
60495: LD_VAR 0 10
60499: PUSH
60500: LD_VAR 0 6
60504: PPUSH
60505: CALL_OW 311
60509: PPUSH
60510: LD_INT 3
60512: PPUSH
60513: CALL_OW 259
60517: PUSH
60518: LD_INT 4
60520: MUL
60521: MUL
60522: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60523: LD_VAR 0 6
60527: PPUSH
60528: CALL_OW 263
60532: PUSH
60533: LD_INT 2
60535: EQUAL
60536: IFFALSE 60587
// begin j := IsControledBy ( i ) ;
60538: LD_ADDR_VAR 0 7
60542: PUSH
60543: LD_VAR 0 6
60547: PPUSH
60548: CALL_OW 312
60552: ST_TO_ADDR
// if j then
60553: LD_VAR 0 7
60557: IFFALSE 60587
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60559: LD_ADDR_VAR 0 10
60563: PUSH
60564: LD_VAR 0 10
60568: PUSH
60569: LD_VAR 0 7
60573: PPUSH
60574: LD_INT 3
60576: PPUSH
60577: CALL_OW 259
60581: PUSH
60582: LD_INT 3
60584: MUL
60585: MUL
60586: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
60587: LD_VAR 0 6
60591: PPUSH
60592: CALL_OW 264
60596: PUSH
60597: LD_INT 5
60599: PUSH
60600: LD_INT 6
60602: PUSH
60603: LD_INT 46
60605: PUSH
60606: LD_INT 44
60608: PUSH
60609: LD_INT 47
60611: PUSH
60612: LD_INT 45
60614: PUSH
60615: LD_INT 28
60617: PUSH
60618: LD_INT 7
60620: PUSH
60621: LD_INT 27
60623: PUSH
60624: LD_INT 29
60626: PUSH
60627: EMPTY
60628: LIST
60629: LIST
60630: LIST
60631: LIST
60632: LIST
60633: LIST
60634: LIST
60635: LIST
60636: LIST
60637: LIST
60638: IN
60639: PUSH
60640: LD_VAR 0 1
60644: PPUSH
60645: LD_INT 52
60647: PPUSH
60648: CALL_OW 321
60652: PUSH
60653: LD_INT 2
60655: EQUAL
60656: AND
60657: IFFALSE 60674
// bpoints := bpoints * 1.2 ;
60659: LD_ADDR_VAR 0 10
60663: PUSH
60664: LD_VAR 0 10
60668: PUSH
60669: LD_REAL  1.20000000000000E+0000
60672: MUL
60673: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60674: LD_VAR 0 6
60678: PPUSH
60679: CALL_OW 264
60683: PUSH
60684: LD_INT 6
60686: PUSH
60687: LD_INT 46
60689: PUSH
60690: LD_INT 47
60692: PUSH
60693: EMPTY
60694: LIST
60695: LIST
60696: LIST
60697: IN
60698: IFFALSE 60715
// bpoints := bpoints * 1.2 ;
60700: LD_ADDR_VAR 0 10
60704: PUSH
60705: LD_VAR 0 10
60709: PUSH
60710: LD_REAL  1.20000000000000E+0000
60713: MUL
60714: ST_TO_ADDR
// end ; unit_building :
60715: GO 60729
60717: LD_INT 3
60719: DOUBLE
60720: EQUAL
60721: IFTRUE 60725
60723: GO 60728
60725: POP
// ; end ;
60726: GO 60729
60728: POP
// for j = 1 to 3 do
60729: LD_ADDR_VAR 0 7
60733: PUSH
60734: DOUBLE
60735: LD_INT 1
60737: DEC
60738: ST_TO_ADDR
60739: LD_INT 3
60741: PUSH
60742: FOR_TO
60743: IFFALSE 60796
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60745: LD_ADDR_VAR 0 5
60749: PUSH
60750: LD_VAR 0 5
60754: PPUSH
60755: LD_VAR 0 7
60759: PPUSH
60760: LD_VAR 0 5
60764: PUSH
60765: LD_VAR 0 7
60769: ARRAY
60770: PUSH
60771: LD_VAR 0 9
60775: PUSH
60776: LD_VAR 0 7
60780: ARRAY
60781: PUSH
60782: LD_VAR 0 10
60786: MUL
60787: PLUS
60788: PPUSH
60789: CALL_OW 1
60793: ST_TO_ADDR
60794: GO 60742
60796: POP
60797: POP
// end ;
60798: GO 59277
60800: POP
60801: POP
// result := Replace ( result , 4 , tmp ) ;
60802: LD_ADDR_VAR 0 5
60806: PUSH
60807: LD_VAR 0 5
60811: PPUSH
60812: LD_INT 4
60814: PPUSH
60815: LD_VAR 0 8
60819: PPUSH
60820: CALL_OW 1
60824: ST_TO_ADDR
// end ;
60825: LD_VAR 0 5
60829: RET
// export function DangerAtRange ( unit , range ) ; begin
60830: LD_INT 0
60832: PPUSH
// if not unit then
60833: LD_VAR 0 1
60837: NOT
60838: IFFALSE 60842
// exit ;
60840: GO 60887
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60842: LD_ADDR_VAR 0 3
60846: PUSH
60847: LD_VAR 0 1
60851: PPUSH
60852: CALL_OW 255
60856: PPUSH
60857: LD_VAR 0 1
60861: PPUSH
60862: CALL_OW 250
60866: PPUSH
60867: LD_VAR 0 1
60871: PPUSH
60872: CALL_OW 251
60876: PPUSH
60877: LD_VAR 0 2
60881: PPUSH
60882: CALL 59129 0 4
60886: ST_TO_ADDR
// end ;
60887: LD_VAR 0 3
60891: RET
// export function DangerInArea ( side , area ) ; begin
60892: LD_INT 0
60894: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60895: LD_ADDR_VAR 0 3
60899: PUSH
60900: LD_VAR 0 2
60904: PPUSH
60905: LD_INT 81
60907: PUSH
60908: LD_VAR 0 1
60912: PUSH
60913: EMPTY
60914: LIST
60915: LIST
60916: PPUSH
60917: CALL_OW 70
60921: ST_TO_ADDR
// end ;
60922: LD_VAR 0 3
60926: RET
// export function IsExtension ( b ) ; begin
60927: LD_INT 0
60929: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60930: LD_ADDR_VAR 0 2
60934: PUSH
60935: LD_VAR 0 1
60939: PUSH
60940: LD_INT 23
60942: PUSH
60943: LD_INT 20
60945: PUSH
60946: LD_INT 22
60948: PUSH
60949: LD_INT 17
60951: PUSH
60952: LD_INT 24
60954: PUSH
60955: LD_INT 21
60957: PUSH
60958: LD_INT 19
60960: PUSH
60961: LD_INT 16
60963: PUSH
60964: LD_INT 25
60966: PUSH
60967: LD_INT 18
60969: PUSH
60970: EMPTY
60971: LIST
60972: LIST
60973: LIST
60974: LIST
60975: LIST
60976: LIST
60977: LIST
60978: LIST
60979: LIST
60980: LIST
60981: IN
60982: ST_TO_ADDR
// end ;
60983: LD_VAR 0 2
60987: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
60988: LD_INT 0
60990: PPUSH
60991: PPUSH
60992: PPUSH
// result := [ ] ;
60993: LD_ADDR_VAR 0 4
60997: PUSH
60998: EMPTY
60999: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
61000: LD_ADDR_VAR 0 5
61004: PUSH
61005: LD_VAR 0 2
61009: PPUSH
61010: LD_INT 21
61012: PUSH
61013: LD_INT 3
61015: PUSH
61016: EMPTY
61017: LIST
61018: LIST
61019: PPUSH
61020: CALL_OW 70
61024: ST_TO_ADDR
// if not tmp then
61025: LD_VAR 0 5
61029: NOT
61030: IFFALSE 61034
// exit ;
61032: GO 61098
// if checkLink then
61034: LD_VAR 0 3
61038: IFFALSE 61088
// begin for i in tmp do
61040: LD_ADDR_VAR 0 6
61044: PUSH
61045: LD_VAR 0 5
61049: PUSH
61050: FOR_IN
61051: IFFALSE 61086
// if GetBase ( i ) <> base then
61053: LD_VAR 0 6
61057: PPUSH
61058: CALL_OW 274
61062: PUSH
61063: LD_VAR 0 1
61067: NONEQUAL
61068: IFFALSE 61084
// ComLinkToBase ( base , i ) ;
61070: LD_VAR 0 1
61074: PPUSH
61075: LD_VAR 0 6
61079: PPUSH
61080: CALL_OW 169
61084: GO 61050
61086: POP
61087: POP
// end ; result := tmp ;
61088: LD_ADDR_VAR 0 4
61092: PUSH
61093: LD_VAR 0 5
61097: ST_TO_ADDR
// end ;
61098: LD_VAR 0 4
61102: RET
// export function ComComplete ( units , b ) ; var i ; begin
61103: LD_INT 0
61105: PPUSH
61106: PPUSH
// if not units then
61107: LD_VAR 0 1
61111: NOT
61112: IFFALSE 61116
// exit ;
61114: GO 61206
// for i in units do
61116: LD_ADDR_VAR 0 4
61120: PUSH
61121: LD_VAR 0 1
61125: PUSH
61126: FOR_IN
61127: IFFALSE 61204
// if BuildingStatus ( b ) = bs_build then
61129: LD_VAR 0 2
61133: PPUSH
61134: CALL_OW 461
61138: PUSH
61139: LD_INT 1
61141: EQUAL
61142: IFFALSE 61202
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
61144: LD_VAR 0 4
61148: PPUSH
61149: LD_STRING h
61151: PUSH
61152: LD_VAR 0 2
61156: PPUSH
61157: CALL_OW 250
61161: PUSH
61162: LD_VAR 0 2
61166: PPUSH
61167: CALL_OW 251
61171: PUSH
61172: LD_VAR 0 2
61176: PUSH
61177: LD_INT 0
61179: PUSH
61180: LD_INT 0
61182: PUSH
61183: LD_INT 0
61185: PUSH
61186: EMPTY
61187: LIST
61188: LIST
61189: LIST
61190: LIST
61191: LIST
61192: LIST
61193: LIST
61194: PUSH
61195: EMPTY
61196: LIST
61197: PPUSH
61198: CALL_OW 446
61202: GO 61126
61204: POP
61205: POP
// end ;
61206: LD_VAR 0 3
61210: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
61211: LD_INT 0
61213: PPUSH
61214: PPUSH
61215: PPUSH
61216: PPUSH
61217: PPUSH
61218: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
61219: LD_VAR 0 1
61223: NOT
61224: PUSH
61225: LD_VAR 0 1
61229: PPUSH
61230: CALL_OW 263
61234: PUSH
61235: LD_INT 2
61237: NONEQUAL
61238: OR
61239: IFFALSE 61243
// exit ;
61241: GO 61559
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
61243: LD_ADDR_VAR 0 6
61247: PUSH
61248: LD_INT 22
61250: PUSH
61251: LD_VAR 0 1
61255: PPUSH
61256: CALL_OW 255
61260: PUSH
61261: EMPTY
61262: LIST
61263: LIST
61264: PUSH
61265: LD_INT 2
61267: PUSH
61268: LD_INT 30
61270: PUSH
61271: LD_INT 36
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: PUSH
61278: LD_INT 34
61280: PUSH
61281: LD_INT 31
61283: PUSH
61284: EMPTY
61285: LIST
61286: LIST
61287: PUSH
61288: EMPTY
61289: LIST
61290: LIST
61291: LIST
61292: PUSH
61293: EMPTY
61294: LIST
61295: LIST
61296: PPUSH
61297: CALL_OW 69
61301: ST_TO_ADDR
// if not tmp then
61302: LD_VAR 0 6
61306: NOT
61307: IFFALSE 61311
// exit ;
61309: GO 61559
// result := [ ] ;
61311: LD_ADDR_VAR 0 2
61315: PUSH
61316: EMPTY
61317: ST_TO_ADDR
// for i in tmp do
61318: LD_ADDR_VAR 0 3
61322: PUSH
61323: LD_VAR 0 6
61327: PUSH
61328: FOR_IN
61329: IFFALSE 61400
// begin t := UnitsInside ( i ) ;
61331: LD_ADDR_VAR 0 4
61335: PUSH
61336: LD_VAR 0 3
61340: PPUSH
61341: CALL_OW 313
61345: ST_TO_ADDR
// if t then
61346: LD_VAR 0 4
61350: IFFALSE 61398
// for j in t do
61352: LD_ADDR_VAR 0 7
61356: PUSH
61357: LD_VAR 0 4
61361: PUSH
61362: FOR_IN
61363: IFFALSE 61396
// result := Replace ( result , result + 1 , j ) ;
61365: LD_ADDR_VAR 0 2
61369: PUSH
61370: LD_VAR 0 2
61374: PPUSH
61375: LD_VAR 0 2
61379: PUSH
61380: LD_INT 1
61382: PLUS
61383: PPUSH
61384: LD_VAR 0 7
61388: PPUSH
61389: CALL_OW 1
61393: ST_TO_ADDR
61394: GO 61362
61396: POP
61397: POP
// end ;
61398: GO 61328
61400: POP
61401: POP
// if not result then
61402: LD_VAR 0 2
61406: NOT
61407: IFFALSE 61411
// exit ;
61409: GO 61559
// mech := result [ 1 ] ;
61411: LD_ADDR_VAR 0 5
61415: PUSH
61416: LD_VAR 0 2
61420: PUSH
61421: LD_INT 1
61423: ARRAY
61424: ST_TO_ADDR
// if result > 1 then
61425: LD_VAR 0 2
61429: PUSH
61430: LD_INT 1
61432: GREATER
61433: IFFALSE 61545
// begin for i = 2 to result do
61435: LD_ADDR_VAR 0 3
61439: PUSH
61440: DOUBLE
61441: LD_INT 2
61443: DEC
61444: ST_TO_ADDR
61445: LD_VAR 0 2
61449: PUSH
61450: FOR_TO
61451: IFFALSE 61543
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
61453: LD_ADDR_VAR 0 4
61457: PUSH
61458: LD_VAR 0 2
61462: PUSH
61463: LD_VAR 0 3
61467: ARRAY
61468: PPUSH
61469: LD_INT 3
61471: PPUSH
61472: CALL_OW 259
61476: PUSH
61477: LD_VAR 0 2
61481: PUSH
61482: LD_VAR 0 3
61486: ARRAY
61487: PPUSH
61488: CALL_OW 432
61492: MINUS
61493: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
61494: LD_VAR 0 4
61498: PUSH
61499: LD_VAR 0 5
61503: PPUSH
61504: LD_INT 3
61506: PPUSH
61507: CALL_OW 259
61511: PUSH
61512: LD_VAR 0 5
61516: PPUSH
61517: CALL_OW 432
61521: MINUS
61522: GREATEREQUAL
61523: IFFALSE 61541
// mech := result [ i ] ;
61525: LD_ADDR_VAR 0 5
61529: PUSH
61530: LD_VAR 0 2
61534: PUSH
61535: LD_VAR 0 3
61539: ARRAY
61540: ST_TO_ADDR
// end ;
61541: GO 61450
61543: POP
61544: POP
// end ; ComLinkTo ( vehicle , mech ) ;
61545: LD_VAR 0 1
61549: PPUSH
61550: LD_VAR 0 5
61554: PPUSH
61555: CALL_OW 135
// end ;
61559: LD_VAR 0 2
61563: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61564: LD_INT 0
61566: PPUSH
61567: PPUSH
61568: PPUSH
61569: PPUSH
61570: PPUSH
61571: PPUSH
61572: PPUSH
61573: PPUSH
61574: PPUSH
61575: PPUSH
61576: PPUSH
61577: PPUSH
61578: PPUSH
// result := [ ] ;
61579: LD_ADDR_VAR 0 7
61583: PUSH
61584: EMPTY
61585: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
61586: LD_VAR 0 1
61590: PPUSH
61591: CALL_OW 266
61595: PUSH
61596: LD_INT 0
61598: PUSH
61599: LD_INT 1
61601: PUSH
61602: EMPTY
61603: LIST
61604: LIST
61605: IN
61606: NOT
61607: IFFALSE 61611
// exit ;
61609: GO 63245
// if name then
61611: LD_VAR 0 3
61615: IFFALSE 61631
// SetBName ( base_dep , name ) ;
61617: LD_VAR 0 1
61621: PPUSH
61622: LD_VAR 0 3
61626: PPUSH
61627: CALL_OW 500
// base := GetBase ( base_dep ) ;
61631: LD_ADDR_VAR 0 15
61635: PUSH
61636: LD_VAR 0 1
61640: PPUSH
61641: CALL_OW 274
61645: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61646: LD_ADDR_VAR 0 16
61650: PUSH
61651: LD_VAR 0 1
61655: PPUSH
61656: CALL_OW 255
61660: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61661: LD_ADDR_VAR 0 17
61665: PUSH
61666: LD_VAR 0 1
61670: PPUSH
61671: CALL_OW 248
61675: ST_TO_ADDR
// if sources then
61676: LD_VAR 0 5
61680: IFFALSE 61727
// for i = 1 to 3 do
61682: LD_ADDR_VAR 0 8
61686: PUSH
61687: DOUBLE
61688: LD_INT 1
61690: DEC
61691: ST_TO_ADDR
61692: LD_INT 3
61694: PUSH
61695: FOR_TO
61696: IFFALSE 61725
// AddResourceType ( base , i , sources [ i ] ) ;
61698: LD_VAR 0 15
61702: PPUSH
61703: LD_VAR 0 8
61707: PPUSH
61708: LD_VAR 0 5
61712: PUSH
61713: LD_VAR 0 8
61717: ARRAY
61718: PPUSH
61719: CALL_OW 276
61723: GO 61695
61725: POP
61726: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
61727: LD_ADDR_VAR 0 18
61731: PUSH
61732: LD_VAR 0 15
61736: PPUSH
61737: LD_VAR 0 2
61741: PPUSH
61742: LD_INT 1
61744: PPUSH
61745: CALL 60988 0 3
61749: ST_TO_ADDR
// InitHc ;
61750: CALL_OW 19
// InitUc ;
61754: CALL_OW 18
// uc_side := side ;
61758: LD_ADDR_OWVAR 20
61762: PUSH
61763: LD_VAR 0 16
61767: ST_TO_ADDR
// uc_nation := nation ;
61768: LD_ADDR_OWVAR 21
61772: PUSH
61773: LD_VAR 0 17
61777: ST_TO_ADDR
// if buildings then
61778: LD_VAR 0 18
61782: IFFALSE 63104
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61784: LD_ADDR_VAR 0 19
61788: PUSH
61789: LD_VAR 0 18
61793: PPUSH
61794: LD_INT 2
61796: PUSH
61797: LD_INT 30
61799: PUSH
61800: LD_INT 29
61802: PUSH
61803: EMPTY
61804: LIST
61805: LIST
61806: PUSH
61807: LD_INT 30
61809: PUSH
61810: LD_INT 30
61812: PUSH
61813: EMPTY
61814: LIST
61815: LIST
61816: PUSH
61817: EMPTY
61818: LIST
61819: LIST
61820: LIST
61821: PPUSH
61822: CALL_OW 72
61826: ST_TO_ADDR
// if tmp then
61827: LD_VAR 0 19
61831: IFFALSE 61879
// for i in tmp do
61833: LD_ADDR_VAR 0 8
61837: PUSH
61838: LD_VAR 0 19
61842: PUSH
61843: FOR_IN
61844: IFFALSE 61877
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61846: LD_VAR 0 8
61850: PPUSH
61851: CALL_OW 250
61855: PPUSH
61856: LD_VAR 0 8
61860: PPUSH
61861: CALL_OW 251
61865: PPUSH
61866: LD_VAR 0 16
61870: PPUSH
61871: CALL_OW 441
61875: GO 61843
61877: POP
61878: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61879: LD_VAR 0 18
61883: PPUSH
61884: LD_INT 2
61886: PUSH
61887: LD_INT 30
61889: PUSH
61890: LD_INT 32
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: PUSH
61897: LD_INT 30
61899: PUSH
61900: LD_INT 33
61902: PUSH
61903: EMPTY
61904: LIST
61905: LIST
61906: PUSH
61907: EMPTY
61908: LIST
61909: LIST
61910: LIST
61911: PPUSH
61912: CALL_OW 72
61916: IFFALSE 62004
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61918: LD_ADDR_VAR 0 8
61922: PUSH
61923: LD_VAR 0 18
61927: PPUSH
61928: LD_INT 2
61930: PUSH
61931: LD_INT 30
61933: PUSH
61934: LD_INT 32
61936: PUSH
61937: EMPTY
61938: LIST
61939: LIST
61940: PUSH
61941: LD_INT 30
61943: PUSH
61944: LD_INT 33
61946: PUSH
61947: EMPTY
61948: LIST
61949: LIST
61950: PUSH
61951: EMPTY
61952: LIST
61953: LIST
61954: LIST
61955: PPUSH
61956: CALL_OW 72
61960: PUSH
61961: FOR_IN
61962: IFFALSE 62002
// begin if not GetBWeapon ( i ) then
61964: LD_VAR 0 8
61968: PPUSH
61969: CALL_OW 269
61973: NOT
61974: IFFALSE 62000
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61976: LD_VAR 0 8
61980: PPUSH
61981: LD_VAR 0 8
61985: PPUSH
61986: LD_VAR 0 2
61990: PPUSH
61991: CALL 63250 0 2
61995: PPUSH
61996: CALL_OW 431
// end ;
62000: GO 61961
62002: POP
62003: POP
// end ; for i = 1 to personel do
62004: LD_ADDR_VAR 0 8
62008: PUSH
62009: DOUBLE
62010: LD_INT 1
62012: DEC
62013: ST_TO_ADDR
62014: LD_VAR 0 6
62018: PUSH
62019: FOR_TO
62020: IFFALSE 63084
// begin if i > 4 then
62022: LD_VAR 0 8
62026: PUSH
62027: LD_INT 4
62029: GREATER
62030: IFFALSE 62034
// break ;
62032: GO 63084
// case i of 1 :
62034: LD_VAR 0 8
62038: PUSH
62039: LD_INT 1
62041: DOUBLE
62042: EQUAL
62043: IFTRUE 62047
62045: GO 62127
62047: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
62048: LD_ADDR_VAR 0 12
62052: PUSH
62053: LD_VAR 0 18
62057: PPUSH
62058: LD_INT 22
62060: PUSH
62061: LD_VAR 0 16
62065: PUSH
62066: EMPTY
62067: LIST
62068: LIST
62069: PUSH
62070: LD_INT 58
62072: PUSH
62073: EMPTY
62074: LIST
62075: PUSH
62076: LD_INT 2
62078: PUSH
62079: LD_INT 30
62081: PUSH
62082: LD_INT 32
62084: PUSH
62085: EMPTY
62086: LIST
62087: LIST
62088: PUSH
62089: LD_INT 30
62091: PUSH
62092: LD_INT 4
62094: PUSH
62095: EMPTY
62096: LIST
62097: LIST
62098: PUSH
62099: LD_INT 30
62101: PUSH
62102: LD_INT 5
62104: PUSH
62105: EMPTY
62106: LIST
62107: LIST
62108: PUSH
62109: EMPTY
62110: LIST
62111: LIST
62112: LIST
62113: LIST
62114: PUSH
62115: EMPTY
62116: LIST
62117: LIST
62118: LIST
62119: PPUSH
62120: CALL_OW 72
62124: ST_TO_ADDR
62125: GO 62349
62127: LD_INT 2
62129: DOUBLE
62130: EQUAL
62131: IFTRUE 62135
62133: GO 62197
62135: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
62136: LD_ADDR_VAR 0 12
62140: PUSH
62141: LD_VAR 0 18
62145: PPUSH
62146: LD_INT 22
62148: PUSH
62149: LD_VAR 0 16
62153: PUSH
62154: EMPTY
62155: LIST
62156: LIST
62157: PUSH
62158: LD_INT 2
62160: PUSH
62161: LD_INT 30
62163: PUSH
62164: LD_INT 0
62166: PUSH
62167: EMPTY
62168: LIST
62169: LIST
62170: PUSH
62171: LD_INT 30
62173: PUSH
62174: LD_INT 1
62176: PUSH
62177: EMPTY
62178: LIST
62179: LIST
62180: PUSH
62181: EMPTY
62182: LIST
62183: LIST
62184: LIST
62185: PUSH
62186: EMPTY
62187: LIST
62188: LIST
62189: PPUSH
62190: CALL_OW 72
62194: ST_TO_ADDR
62195: GO 62349
62197: LD_INT 3
62199: DOUBLE
62200: EQUAL
62201: IFTRUE 62205
62203: GO 62267
62205: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
62206: LD_ADDR_VAR 0 12
62210: PUSH
62211: LD_VAR 0 18
62215: PPUSH
62216: LD_INT 22
62218: PUSH
62219: LD_VAR 0 16
62223: PUSH
62224: EMPTY
62225: LIST
62226: LIST
62227: PUSH
62228: LD_INT 2
62230: PUSH
62231: LD_INT 30
62233: PUSH
62234: LD_INT 2
62236: PUSH
62237: EMPTY
62238: LIST
62239: LIST
62240: PUSH
62241: LD_INT 30
62243: PUSH
62244: LD_INT 3
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: PUSH
62251: EMPTY
62252: LIST
62253: LIST
62254: LIST
62255: PUSH
62256: EMPTY
62257: LIST
62258: LIST
62259: PPUSH
62260: CALL_OW 72
62264: ST_TO_ADDR
62265: GO 62349
62267: LD_INT 4
62269: DOUBLE
62270: EQUAL
62271: IFTRUE 62275
62273: GO 62348
62275: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
62276: LD_ADDR_VAR 0 12
62280: PUSH
62281: LD_VAR 0 18
62285: PPUSH
62286: LD_INT 22
62288: PUSH
62289: LD_VAR 0 16
62293: PUSH
62294: EMPTY
62295: LIST
62296: LIST
62297: PUSH
62298: LD_INT 2
62300: PUSH
62301: LD_INT 30
62303: PUSH
62304: LD_INT 6
62306: PUSH
62307: EMPTY
62308: LIST
62309: LIST
62310: PUSH
62311: LD_INT 30
62313: PUSH
62314: LD_INT 7
62316: PUSH
62317: EMPTY
62318: LIST
62319: LIST
62320: PUSH
62321: LD_INT 30
62323: PUSH
62324: LD_INT 8
62326: PUSH
62327: EMPTY
62328: LIST
62329: LIST
62330: PUSH
62331: EMPTY
62332: LIST
62333: LIST
62334: LIST
62335: LIST
62336: PUSH
62337: EMPTY
62338: LIST
62339: LIST
62340: PPUSH
62341: CALL_OW 72
62345: ST_TO_ADDR
62346: GO 62349
62348: POP
// if i = 1 then
62349: LD_VAR 0 8
62353: PUSH
62354: LD_INT 1
62356: EQUAL
62357: IFFALSE 62468
// begin tmp := [ ] ;
62359: LD_ADDR_VAR 0 19
62363: PUSH
62364: EMPTY
62365: ST_TO_ADDR
// for j in f do
62366: LD_ADDR_VAR 0 9
62370: PUSH
62371: LD_VAR 0 12
62375: PUSH
62376: FOR_IN
62377: IFFALSE 62450
// if GetBType ( j ) = b_bunker then
62379: LD_VAR 0 9
62383: PPUSH
62384: CALL_OW 266
62388: PUSH
62389: LD_INT 32
62391: EQUAL
62392: IFFALSE 62419
// tmp := Insert ( tmp , 1 , j ) else
62394: LD_ADDR_VAR 0 19
62398: PUSH
62399: LD_VAR 0 19
62403: PPUSH
62404: LD_INT 1
62406: PPUSH
62407: LD_VAR 0 9
62411: PPUSH
62412: CALL_OW 2
62416: ST_TO_ADDR
62417: GO 62448
// tmp := Insert ( tmp , tmp + 1 , j ) ;
62419: LD_ADDR_VAR 0 19
62423: PUSH
62424: LD_VAR 0 19
62428: PPUSH
62429: LD_VAR 0 19
62433: PUSH
62434: LD_INT 1
62436: PLUS
62437: PPUSH
62438: LD_VAR 0 9
62442: PPUSH
62443: CALL_OW 2
62447: ST_TO_ADDR
62448: GO 62376
62450: POP
62451: POP
// if tmp then
62452: LD_VAR 0 19
62456: IFFALSE 62468
// f := tmp ;
62458: LD_ADDR_VAR 0 12
62462: PUSH
62463: LD_VAR 0 19
62467: ST_TO_ADDR
// end ; x := personel [ i ] ;
62468: LD_ADDR_VAR 0 13
62472: PUSH
62473: LD_VAR 0 6
62477: PUSH
62478: LD_VAR 0 8
62482: ARRAY
62483: ST_TO_ADDR
// if x = - 1 then
62484: LD_VAR 0 13
62488: PUSH
62489: LD_INT 1
62491: NEG
62492: EQUAL
62493: IFFALSE 62702
// begin for j in f do
62495: LD_ADDR_VAR 0 9
62499: PUSH
62500: LD_VAR 0 12
62504: PUSH
62505: FOR_IN
62506: IFFALSE 62698
// repeat InitHc ;
62508: CALL_OW 19
// if GetBType ( j ) = b_barracks then
62512: LD_VAR 0 9
62516: PPUSH
62517: CALL_OW 266
62521: PUSH
62522: LD_INT 5
62524: EQUAL
62525: IFFALSE 62595
// begin if UnitsInside ( j ) < 3 then
62527: LD_VAR 0 9
62531: PPUSH
62532: CALL_OW 313
62536: PUSH
62537: LD_INT 3
62539: LESS
62540: IFFALSE 62576
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62542: LD_INT 0
62544: PPUSH
62545: LD_INT 5
62547: PUSH
62548: LD_INT 8
62550: PUSH
62551: LD_INT 9
62553: PUSH
62554: EMPTY
62555: LIST
62556: LIST
62557: LIST
62558: PUSH
62559: LD_VAR 0 17
62563: ARRAY
62564: PPUSH
62565: LD_VAR 0 4
62569: PPUSH
62570: CALL_OW 380
62574: GO 62593
// PrepareHuman ( false , i , skill ) ;
62576: LD_INT 0
62578: PPUSH
62579: LD_VAR 0 8
62583: PPUSH
62584: LD_VAR 0 4
62588: PPUSH
62589: CALL_OW 380
// end else
62593: GO 62612
// PrepareHuman ( false , i , skill ) ;
62595: LD_INT 0
62597: PPUSH
62598: LD_VAR 0 8
62602: PPUSH
62603: LD_VAR 0 4
62607: PPUSH
62608: CALL_OW 380
// un := CreateHuman ;
62612: LD_ADDR_VAR 0 14
62616: PUSH
62617: CALL_OW 44
62621: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62622: LD_ADDR_VAR 0 7
62626: PUSH
62627: LD_VAR 0 7
62631: PPUSH
62632: LD_INT 1
62634: PPUSH
62635: LD_VAR 0 14
62639: PPUSH
62640: CALL_OW 2
62644: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62645: LD_VAR 0 14
62649: PPUSH
62650: LD_VAR 0 9
62654: PPUSH
62655: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62659: LD_VAR 0 9
62663: PPUSH
62664: CALL_OW 313
62668: PUSH
62669: LD_INT 6
62671: EQUAL
62672: PUSH
62673: LD_VAR 0 9
62677: PPUSH
62678: CALL_OW 266
62682: PUSH
62683: LD_INT 32
62685: PUSH
62686: LD_INT 31
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: IN
62693: OR
62694: IFFALSE 62508
62696: GO 62505
62698: POP
62699: POP
// end else
62700: GO 63082
// for j = 1 to x do
62702: LD_ADDR_VAR 0 9
62706: PUSH
62707: DOUBLE
62708: LD_INT 1
62710: DEC
62711: ST_TO_ADDR
62712: LD_VAR 0 13
62716: PUSH
62717: FOR_TO
62718: IFFALSE 63080
// begin InitHc ;
62720: CALL_OW 19
// if not f then
62724: LD_VAR 0 12
62728: NOT
62729: IFFALSE 62818
// begin PrepareHuman ( false , i , skill ) ;
62731: LD_INT 0
62733: PPUSH
62734: LD_VAR 0 8
62738: PPUSH
62739: LD_VAR 0 4
62743: PPUSH
62744: CALL_OW 380
// un := CreateHuman ;
62748: LD_ADDR_VAR 0 14
62752: PUSH
62753: CALL_OW 44
62757: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62758: LD_ADDR_VAR 0 7
62762: PUSH
62763: LD_VAR 0 7
62767: PPUSH
62768: LD_INT 1
62770: PPUSH
62771: LD_VAR 0 14
62775: PPUSH
62776: CALL_OW 2
62780: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62781: LD_VAR 0 14
62785: PPUSH
62786: LD_VAR 0 1
62790: PPUSH
62791: CALL_OW 250
62795: PPUSH
62796: LD_VAR 0 1
62800: PPUSH
62801: CALL_OW 251
62805: PPUSH
62806: LD_INT 10
62808: PPUSH
62809: LD_INT 0
62811: PPUSH
62812: CALL_OW 50
// continue ;
62816: GO 62717
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62818: LD_VAR 0 12
62822: PUSH
62823: LD_INT 1
62825: ARRAY
62826: PPUSH
62827: CALL_OW 313
62831: PUSH
62832: LD_VAR 0 12
62836: PUSH
62837: LD_INT 1
62839: ARRAY
62840: PPUSH
62841: CALL_OW 266
62845: PUSH
62846: LD_INT 32
62848: PUSH
62849: LD_INT 31
62851: PUSH
62852: EMPTY
62853: LIST
62854: LIST
62855: IN
62856: AND
62857: PUSH
62858: LD_VAR 0 12
62862: PUSH
62863: LD_INT 1
62865: ARRAY
62866: PPUSH
62867: CALL_OW 313
62871: PUSH
62872: LD_INT 6
62874: EQUAL
62875: OR
62876: IFFALSE 62896
// f := Delete ( f , 1 ) ;
62878: LD_ADDR_VAR 0 12
62882: PUSH
62883: LD_VAR 0 12
62887: PPUSH
62888: LD_INT 1
62890: PPUSH
62891: CALL_OW 3
62895: ST_TO_ADDR
// if not f then
62896: LD_VAR 0 12
62900: NOT
62901: IFFALSE 62919
// begin x := x + 2 ;
62903: LD_ADDR_VAR 0 13
62907: PUSH
62908: LD_VAR 0 13
62912: PUSH
62913: LD_INT 2
62915: PLUS
62916: ST_TO_ADDR
// continue ;
62917: GO 62717
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62919: LD_VAR 0 12
62923: PUSH
62924: LD_INT 1
62926: ARRAY
62927: PPUSH
62928: CALL_OW 266
62932: PUSH
62933: LD_INT 5
62935: EQUAL
62936: IFFALSE 63010
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62938: LD_VAR 0 12
62942: PUSH
62943: LD_INT 1
62945: ARRAY
62946: PPUSH
62947: CALL_OW 313
62951: PUSH
62952: LD_INT 3
62954: LESS
62955: IFFALSE 62991
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62957: LD_INT 0
62959: PPUSH
62960: LD_INT 5
62962: PUSH
62963: LD_INT 8
62965: PUSH
62966: LD_INT 9
62968: PUSH
62969: EMPTY
62970: LIST
62971: LIST
62972: LIST
62973: PUSH
62974: LD_VAR 0 17
62978: ARRAY
62979: PPUSH
62980: LD_VAR 0 4
62984: PPUSH
62985: CALL_OW 380
62989: GO 63008
// PrepareHuman ( false , i , skill ) ;
62991: LD_INT 0
62993: PPUSH
62994: LD_VAR 0 8
62998: PPUSH
62999: LD_VAR 0 4
63003: PPUSH
63004: CALL_OW 380
// end else
63008: GO 63027
// PrepareHuman ( false , i , skill ) ;
63010: LD_INT 0
63012: PPUSH
63013: LD_VAR 0 8
63017: PPUSH
63018: LD_VAR 0 4
63022: PPUSH
63023: CALL_OW 380
// un := CreateHuman ;
63027: LD_ADDR_VAR 0 14
63031: PUSH
63032: CALL_OW 44
63036: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63037: LD_ADDR_VAR 0 7
63041: PUSH
63042: LD_VAR 0 7
63046: PPUSH
63047: LD_INT 1
63049: PPUSH
63050: LD_VAR 0 14
63054: PPUSH
63055: CALL_OW 2
63059: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
63060: LD_VAR 0 14
63064: PPUSH
63065: LD_VAR 0 12
63069: PUSH
63070: LD_INT 1
63072: ARRAY
63073: PPUSH
63074: CALL_OW 52
// end ;
63078: GO 62717
63080: POP
63081: POP
// end ;
63082: GO 62019
63084: POP
63085: POP
// result := result ^ buildings ;
63086: LD_ADDR_VAR 0 7
63090: PUSH
63091: LD_VAR 0 7
63095: PUSH
63096: LD_VAR 0 18
63100: ADD
63101: ST_TO_ADDR
// end else
63102: GO 63245
// begin for i = 1 to personel do
63104: LD_ADDR_VAR 0 8
63108: PUSH
63109: DOUBLE
63110: LD_INT 1
63112: DEC
63113: ST_TO_ADDR
63114: LD_VAR 0 6
63118: PUSH
63119: FOR_TO
63120: IFFALSE 63243
// begin if i > 4 then
63122: LD_VAR 0 8
63126: PUSH
63127: LD_INT 4
63129: GREATER
63130: IFFALSE 63134
// break ;
63132: GO 63243
// x := personel [ i ] ;
63134: LD_ADDR_VAR 0 13
63138: PUSH
63139: LD_VAR 0 6
63143: PUSH
63144: LD_VAR 0 8
63148: ARRAY
63149: ST_TO_ADDR
// if x = - 1 then
63150: LD_VAR 0 13
63154: PUSH
63155: LD_INT 1
63157: NEG
63158: EQUAL
63159: IFFALSE 63163
// continue ;
63161: GO 63119
// PrepareHuman ( false , i , skill ) ;
63163: LD_INT 0
63165: PPUSH
63166: LD_VAR 0 8
63170: PPUSH
63171: LD_VAR 0 4
63175: PPUSH
63176: CALL_OW 380
// un := CreateHuman ;
63180: LD_ADDR_VAR 0 14
63184: PUSH
63185: CALL_OW 44
63189: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63190: LD_VAR 0 14
63194: PPUSH
63195: LD_VAR 0 1
63199: PPUSH
63200: CALL_OW 250
63204: PPUSH
63205: LD_VAR 0 1
63209: PPUSH
63210: CALL_OW 251
63214: PPUSH
63215: LD_INT 10
63217: PPUSH
63218: LD_INT 0
63220: PPUSH
63221: CALL_OW 50
// result := result ^ un ;
63225: LD_ADDR_VAR 0 7
63229: PUSH
63230: LD_VAR 0 7
63234: PUSH
63235: LD_VAR 0 14
63239: ADD
63240: ST_TO_ADDR
// end ;
63241: GO 63119
63243: POP
63244: POP
// end ; end ;
63245: LD_VAR 0 7
63249: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
63250: LD_INT 0
63252: PPUSH
63253: PPUSH
63254: PPUSH
63255: PPUSH
63256: PPUSH
63257: PPUSH
63258: PPUSH
63259: PPUSH
63260: PPUSH
63261: PPUSH
63262: PPUSH
63263: PPUSH
63264: PPUSH
63265: PPUSH
63266: PPUSH
63267: PPUSH
// result := false ;
63268: LD_ADDR_VAR 0 3
63272: PUSH
63273: LD_INT 0
63275: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
63276: LD_VAR 0 1
63280: NOT
63281: PUSH
63282: LD_VAR 0 1
63286: PPUSH
63287: CALL_OW 266
63291: PUSH
63292: LD_INT 32
63294: PUSH
63295: LD_INT 33
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: IN
63302: NOT
63303: OR
63304: IFFALSE 63308
// exit ;
63306: GO 64417
// nat := GetNation ( tower ) ;
63308: LD_ADDR_VAR 0 12
63312: PUSH
63313: LD_VAR 0 1
63317: PPUSH
63318: CALL_OW 248
63322: ST_TO_ADDR
// side := GetSide ( tower ) ;
63323: LD_ADDR_VAR 0 16
63327: PUSH
63328: LD_VAR 0 1
63332: PPUSH
63333: CALL_OW 255
63337: ST_TO_ADDR
// x := GetX ( tower ) ;
63338: LD_ADDR_VAR 0 10
63342: PUSH
63343: LD_VAR 0 1
63347: PPUSH
63348: CALL_OW 250
63352: ST_TO_ADDR
// y := GetY ( tower ) ;
63353: LD_ADDR_VAR 0 11
63357: PUSH
63358: LD_VAR 0 1
63362: PPUSH
63363: CALL_OW 251
63367: ST_TO_ADDR
// if not x or not y then
63368: LD_VAR 0 10
63372: NOT
63373: PUSH
63374: LD_VAR 0 11
63378: NOT
63379: OR
63380: IFFALSE 63384
// exit ;
63382: GO 64417
// weapon := 0 ;
63384: LD_ADDR_VAR 0 18
63388: PUSH
63389: LD_INT 0
63391: ST_TO_ADDR
// fac_list := [ ] ;
63392: LD_ADDR_VAR 0 17
63396: PUSH
63397: EMPTY
63398: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
63399: LD_ADDR_VAR 0 6
63403: PUSH
63404: LD_VAR 0 1
63408: PPUSH
63409: CALL_OW 274
63413: PPUSH
63414: LD_VAR 0 2
63418: PPUSH
63419: LD_INT 0
63421: PPUSH
63422: CALL 60988 0 3
63426: PPUSH
63427: LD_INT 30
63429: PUSH
63430: LD_INT 3
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PPUSH
63437: CALL_OW 72
63441: ST_TO_ADDR
// if not factories then
63442: LD_VAR 0 6
63446: NOT
63447: IFFALSE 63451
// exit ;
63449: GO 64417
// for i in factories do
63451: LD_ADDR_VAR 0 8
63455: PUSH
63456: LD_VAR 0 6
63460: PUSH
63461: FOR_IN
63462: IFFALSE 63487
// fac_list := fac_list union AvailableWeaponList ( i ) ;
63464: LD_ADDR_VAR 0 17
63468: PUSH
63469: LD_VAR 0 17
63473: PUSH
63474: LD_VAR 0 8
63478: PPUSH
63479: CALL_OW 478
63483: UNION
63484: ST_TO_ADDR
63485: GO 63461
63487: POP
63488: POP
// if not fac_list then
63489: LD_VAR 0 17
63493: NOT
63494: IFFALSE 63498
// exit ;
63496: GO 64417
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
63498: LD_ADDR_VAR 0 5
63502: PUSH
63503: LD_INT 4
63505: PUSH
63506: LD_INT 5
63508: PUSH
63509: LD_INT 9
63511: PUSH
63512: LD_INT 10
63514: PUSH
63515: LD_INT 6
63517: PUSH
63518: LD_INT 7
63520: PUSH
63521: LD_INT 11
63523: PUSH
63524: EMPTY
63525: LIST
63526: LIST
63527: LIST
63528: LIST
63529: LIST
63530: LIST
63531: LIST
63532: PUSH
63533: LD_INT 27
63535: PUSH
63536: LD_INT 28
63538: PUSH
63539: LD_INT 26
63541: PUSH
63542: LD_INT 30
63544: PUSH
63545: EMPTY
63546: LIST
63547: LIST
63548: LIST
63549: LIST
63550: PUSH
63551: LD_INT 43
63553: PUSH
63554: LD_INT 44
63556: PUSH
63557: LD_INT 46
63559: PUSH
63560: LD_INT 45
63562: PUSH
63563: LD_INT 47
63565: PUSH
63566: LD_INT 49
63568: PUSH
63569: EMPTY
63570: LIST
63571: LIST
63572: LIST
63573: LIST
63574: LIST
63575: LIST
63576: PUSH
63577: EMPTY
63578: LIST
63579: LIST
63580: LIST
63581: PUSH
63582: LD_VAR 0 12
63586: ARRAY
63587: ST_TO_ADDR
// list := list isect fac_list ;
63588: LD_ADDR_VAR 0 5
63592: PUSH
63593: LD_VAR 0 5
63597: PUSH
63598: LD_VAR 0 17
63602: ISECT
63603: ST_TO_ADDR
// if not list then
63604: LD_VAR 0 5
63608: NOT
63609: IFFALSE 63613
// exit ;
63611: GO 64417
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63613: LD_VAR 0 12
63617: PUSH
63618: LD_INT 3
63620: EQUAL
63621: PUSH
63622: LD_INT 49
63624: PUSH
63625: LD_VAR 0 5
63629: IN
63630: AND
63631: PUSH
63632: LD_INT 31
63634: PPUSH
63635: LD_VAR 0 16
63639: PPUSH
63640: CALL_OW 321
63644: PUSH
63645: LD_INT 2
63647: EQUAL
63648: AND
63649: IFFALSE 63709
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63651: LD_INT 22
63653: PUSH
63654: LD_VAR 0 16
63658: PUSH
63659: EMPTY
63660: LIST
63661: LIST
63662: PUSH
63663: LD_INT 35
63665: PUSH
63666: LD_INT 49
63668: PUSH
63669: EMPTY
63670: LIST
63671: LIST
63672: PUSH
63673: LD_INT 91
63675: PUSH
63676: LD_VAR 0 1
63680: PUSH
63681: LD_INT 10
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: LIST
63688: PUSH
63689: EMPTY
63690: LIST
63691: LIST
63692: LIST
63693: PPUSH
63694: CALL_OW 69
63698: NOT
63699: IFFALSE 63709
// weapon := ru_time_lapser ;
63701: LD_ADDR_VAR 0 18
63705: PUSH
63706: LD_INT 49
63708: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63709: LD_VAR 0 12
63713: PUSH
63714: LD_INT 1
63716: PUSH
63717: LD_INT 2
63719: PUSH
63720: EMPTY
63721: LIST
63722: LIST
63723: IN
63724: PUSH
63725: LD_INT 11
63727: PUSH
63728: LD_VAR 0 5
63732: IN
63733: PUSH
63734: LD_INT 30
63736: PUSH
63737: LD_VAR 0 5
63741: IN
63742: OR
63743: AND
63744: PUSH
63745: LD_INT 6
63747: PPUSH
63748: LD_VAR 0 16
63752: PPUSH
63753: CALL_OW 321
63757: PUSH
63758: LD_INT 2
63760: EQUAL
63761: AND
63762: IFFALSE 63927
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63764: LD_INT 22
63766: PUSH
63767: LD_VAR 0 16
63771: PUSH
63772: EMPTY
63773: LIST
63774: LIST
63775: PUSH
63776: LD_INT 2
63778: PUSH
63779: LD_INT 35
63781: PUSH
63782: LD_INT 11
63784: PUSH
63785: EMPTY
63786: LIST
63787: LIST
63788: PUSH
63789: LD_INT 35
63791: PUSH
63792: LD_INT 30
63794: PUSH
63795: EMPTY
63796: LIST
63797: LIST
63798: PUSH
63799: EMPTY
63800: LIST
63801: LIST
63802: LIST
63803: PUSH
63804: LD_INT 91
63806: PUSH
63807: LD_VAR 0 1
63811: PUSH
63812: LD_INT 18
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: LIST
63819: PUSH
63820: EMPTY
63821: LIST
63822: LIST
63823: LIST
63824: PPUSH
63825: CALL_OW 69
63829: NOT
63830: PUSH
63831: LD_INT 22
63833: PUSH
63834: LD_VAR 0 16
63838: PUSH
63839: EMPTY
63840: LIST
63841: LIST
63842: PUSH
63843: LD_INT 2
63845: PUSH
63846: LD_INT 30
63848: PUSH
63849: LD_INT 32
63851: PUSH
63852: EMPTY
63853: LIST
63854: LIST
63855: PUSH
63856: LD_INT 30
63858: PUSH
63859: LD_INT 33
63861: PUSH
63862: EMPTY
63863: LIST
63864: LIST
63865: PUSH
63866: EMPTY
63867: LIST
63868: LIST
63869: LIST
63870: PUSH
63871: LD_INT 91
63873: PUSH
63874: LD_VAR 0 1
63878: PUSH
63879: LD_INT 12
63881: PUSH
63882: EMPTY
63883: LIST
63884: LIST
63885: LIST
63886: PUSH
63887: EMPTY
63888: LIST
63889: LIST
63890: LIST
63891: PUSH
63892: EMPTY
63893: LIST
63894: PPUSH
63895: CALL_OW 69
63899: PUSH
63900: LD_INT 2
63902: GREATER
63903: AND
63904: IFFALSE 63927
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63906: LD_ADDR_VAR 0 18
63910: PUSH
63911: LD_INT 11
63913: PUSH
63914: LD_INT 30
63916: PUSH
63917: EMPTY
63918: LIST
63919: LIST
63920: PUSH
63921: LD_VAR 0 12
63925: ARRAY
63926: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63927: LD_VAR 0 18
63931: NOT
63932: PUSH
63933: LD_INT 40
63935: PPUSH
63936: LD_VAR 0 16
63940: PPUSH
63941: CALL_OW 321
63945: PUSH
63946: LD_INT 2
63948: EQUAL
63949: AND
63950: PUSH
63951: LD_INT 7
63953: PUSH
63954: LD_VAR 0 5
63958: IN
63959: PUSH
63960: LD_INT 28
63962: PUSH
63963: LD_VAR 0 5
63967: IN
63968: OR
63969: PUSH
63970: LD_INT 45
63972: PUSH
63973: LD_VAR 0 5
63977: IN
63978: OR
63979: AND
63980: IFFALSE 64234
// begin hex := GetHexInfo ( x , y ) ;
63982: LD_ADDR_VAR 0 4
63986: PUSH
63987: LD_VAR 0 10
63991: PPUSH
63992: LD_VAR 0 11
63996: PPUSH
63997: CALL_OW 546
64001: ST_TO_ADDR
// if hex [ 1 ] then
64002: LD_VAR 0 4
64006: PUSH
64007: LD_INT 1
64009: ARRAY
64010: IFFALSE 64014
// exit ;
64012: GO 64417
// height := hex [ 2 ] ;
64014: LD_ADDR_VAR 0 15
64018: PUSH
64019: LD_VAR 0 4
64023: PUSH
64024: LD_INT 2
64026: ARRAY
64027: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
64028: LD_ADDR_VAR 0 14
64032: PUSH
64033: LD_INT 0
64035: PUSH
64036: LD_INT 2
64038: PUSH
64039: LD_INT 3
64041: PUSH
64042: LD_INT 5
64044: PUSH
64045: EMPTY
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: ST_TO_ADDR
// for i in tmp do
64051: LD_ADDR_VAR 0 8
64055: PUSH
64056: LD_VAR 0 14
64060: PUSH
64061: FOR_IN
64062: IFFALSE 64232
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
64064: LD_ADDR_VAR 0 9
64068: PUSH
64069: LD_VAR 0 10
64073: PPUSH
64074: LD_VAR 0 8
64078: PPUSH
64079: LD_INT 5
64081: PPUSH
64082: CALL_OW 272
64086: PUSH
64087: LD_VAR 0 11
64091: PPUSH
64092: LD_VAR 0 8
64096: PPUSH
64097: LD_INT 5
64099: PPUSH
64100: CALL_OW 273
64104: PUSH
64105: EMPTY
64106: LIST
64107: LIST
64108: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
64109: LD_VAR 0 9
64113: PUSH
64114: LD_INT 1
64116: ARRAY
64117: PPUSH
64118: LD_VAR 0 9
64122: PUSH
64123: LD_INT 2
64125: ARRAY
64126: PPUSH
64127: CALL_OW 488
64131: IFFALSE 64230
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
64133: LD_ADDR_VAR 0 4
64137: PUSH
64138: LD_VAR 0 9
64142: PUSH
64143: LD_INT 1
64145: ARRAY
64146: PPUSH
64147: LD_VAR 0 9
64151: PUSH
64152: LD_INT 2
64154: ARRAY
64155: PPUSH
64156: CALL_OW 546
64160: ST_TO_ADDR
// if hex [ 1 ] then
64161: LD_VAR 0 4
64165: PUSH
64166: LD_INT 1
64168: ARRAY
64169: IFFALSE 64173
// continue ;
64171: GO 64061
// h := hex [ 2 ] ;
64173: LD_ADDR_VAR 0 13
64177: PUSH
64178: LD_VAR 0 4
64182: PUSH
64183: LD_INT 2
64185: ARRAY
64186: ST_TO_ADDR
// if h + 7 < height then
64187: LD_VAR 0 13
64191: PUSH
64192: LD_INT 7
64194: PLUS
64195: PUSH
64196: LD_VAR 0 15
64200: LESS
64201: IFFALSE 64230
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
64203: LD_ADDR_VAR 0 18
64207: PUSH
64208: LD_INT 7
64210: PUSH
64211: LD_INT 28
64213: PUSH
64214: LD_INT 45
64216: PUSH
64217: EMPTY
64218: LIST
64219: LIST
64220: LIST
64221: PUSH
64222: LD_VAR 0 12
64226: ARRAY
64227: ST_TO_ADDR
// break ;
64228: GO 64232
// end ; end ; end ;
64230: GO 64061
64232: POP
64233: POP
// end ; if not weapon then
64234: LD_VAR 0 18
64238: NOT
64239: IFFALSE 64299
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
64241: LD_ADDR_VAR 0 5
64245: PUSH
64246: LD_VAR 0 5
64250: PUSH
64251: LD_INT 11
64253: PUSH
64254: LD_INT 30
64256: PUSH
64257: LD_INT 49
64259: PUSH
64260: EMPTY
64261: LIST
64262: LIST
64263: LIST
64264: DIFF
64265: ST_TO_ADDR
// if not list then
64266: LD_VAR 0 5
64270: NOT
64271: IFFALSE 64275
// exit ;
64273: GO 64417
// weapon := list [ rand ( 1 , list ) ] ;
64275: LD_ADDR_VAR 0 18
64279: PUSH
64280: LD_VAR 0 5
64284: PUSH
64285: LD_INT 1
64287: PPUSH
64288: LD_VAR 0 5
64292: PPUSH
64293: CALL_OW 12
64297: ARRAY
64298: ST_TO_ADDR
// end ; if weapon then
64299: LD_VAR 0 18
64303: IFFALSE 64417
// begin tmp := CostOfWeapon ( weapon ) ;
64305: LD_ADDR_VAR 0 14
64309: PUSH
64310: LD_VAR 0 18
64314: PPUSH
64315: CALL_OW 451
64319: ST_TO_ADDR
// j := GetBase ( tower ) ;
64320: LD_ADDR_VAR 0 9
64324: PUSH
64325: LD_VAR 0 1
64329: PPUSH
64330: CALL_OW 274
64334: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
64335: LD_VAR 0 9
64339: PPUSH
64340: LD_INT 1
64342: PPUSH
64343: CALL_OW 275
64347: PUSH
64348: LD_VAR 0 14
64352: PUSH
64353: LD_INT 1
64355: ARRAY
64356: GREATEREQUAL
64357: PUSH
64358: LD_VAR 0 9
64362: PPUSH
64363: LD_INT 2
64365: PPUSH
64366: CALL_OW 275
64370: PUSH
64371: LD_VAR 0 14
64375: PUSH
64376: LD_INT 2
64378: ARRAY
64379: GREATEREQUAL
64380: AND
64381: PUSH
64382: LD_VAR 0 9
64386: PPUSH
64387: LD_INT 3
64389: PPUSH
64390: CALL_OW 275
64394: PUSH
64395: LD_VAR 0 14
64399: PUSH
64400: LD_INT 3
64402: ARRAY
64403: GREATEREQUAL
64404: AND
64405: IFFALSE 64417
// result := weapon ;
64407: LD_ADDR_VAR 0 3
64411: PUSH
64412: LD_VAR 0 18
64416: ST_TO_ADDR
// end ; end ;
64417: LD_VAR 0 3
64421: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
64422: LD_INT 0
64424: PPUSH
64425: PPUSH
// result := true ;
64426: LD_ADDR_VAR 0 3
64430: PUSH
64431: LD_INT 1
64433: ST_TO_ADDR
// if array1 = array2 then
64434: LD_VAR 0 1
64438: PUSH
64439: LD_VAR 0 2
64443: EQUAL
64444: IFFALSE 64504
// begin for i = 1 to array1 do
64446: LD_ADDR_VAR 0 4
64450: PUSH
64451: DOUBLE
64452: LD_INT 1
64454: DEC
64455: ST_TO_ADDR
64456: LD_VAR 0 1
64460: PUSH
64461: FOR_TO
64462: IFFALSE 64500
// if array1 [ i ] <> array2 [ i ] then
64464: LD_VAR 0 1
64468: PUSH
64469: LD_VAR 0 4
64473: ARRAY
64474: PUSH
64475: LD_VAR 0 2
64479: PUSH
64480: LD_VAR 0 4
64484: ARRAY
64485: NONEQUAL
64486: IFFALSE 64498
// begin result := false ;
64488: LD_ADDR_VAR 0 3
64492: PUSH
64493: LD_INT 0
64495: ST_TO_ADDR
// break ;
64496: GO 64500
// end ;
64498: GO 64461
64500: POP
64501: POP
// end else
64502: GO 64512
// result := false ;
64504: LD_ADDR_VAR 0 3
64508: PUSH
64509: LD_INT 0
64511: ST_TO_ADDR
// end ;
64512: LD_VAR 0 3
64516: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
64517: LD_INT 0
64519: PPUSH
64520: PPUSH
// if not array1 or not array2 then
64521: LD_VAR 0 1
64525: NOT
64526: PUSH
64527: LD_VAR 0 2
64531: NOT
64532: OR
64533: IFFALSE 64537
// exit ;
64535: GO 64601
// result := true ;
64537: LD_ADDR_VAR 0 3
64541: PUSH
64542: LD_INT 1
64544: ST_TO_ADDR
// for i = 1 to array1 do
64545: LD_ADDR_VAR 0 4
64549: PUSH
64550: DOUBLE
64551: LD_INT 1
64553: DEC
64554: ST_TO_ADDR
64555: LD_VAR 0 1
64559: PUSH
64560: FOR_TO
64561: IFFALSE 64599
// if array1 [ i ] <> array2 [ i ] then
64563: LD_VAR 0 1
64567: PUSH
64568: LD_VAR 0 4
64572: ARRAY
64573: PUSH
64574: LD_VAR 0 2
64578: PUSH
64579: LD_VAR 0 4
64583: ARRAY
64584: NONEQUAL
64585: IFFALSE 64597
// begin result := false ;
64587: LD_ADDR_VAR 0 3
64591: PUSH
64592: LD_INT 0
64594: ST_TO_ADDR
// break ;
64595: GO 64599
// end ;
64597: GO 64560
64599: POP
64600: POP
// end ;
64601: LD_VAR 0 3
64605: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
64606: LD_INT 0
64608: PPUSH
64609: PPUSH
64610: PPUSH
// pom := GetBase ( fac ) ;
64611: LD_ADDR_VAR 0 5
64615: PUSH
64616: LD_VAR 0 1
64620: PPUSH
64621: CALL_OW 274
64625: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
64626: LD_ADDR_VAR 0 4
64630: PUSH
64631: LD_VAR 0 2
64635: PUSH
64636: LD_INT 1
64638: ARRAY
64639: PPUSH
64640: LD_VAR 0 2
64644: PUSH
64645: LD_INT 2
64647: ARRAY
64648: PPUSH
64649: LD_VAR 0 2
64653: PUSH
64654: LD_INT 3
64656: ARRAY
64657: PPUSH
64658: LD_VAR 0 2
64662: PUSH
64663: LD_INT 4
64665: ARRAY
64666: PPUSH
64667: CALL_OW 449
64671: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64672: LD_ADDR_VAR 0 3
64676: PUSH
64677: LD_VAR 0 5
64681: PPUSH
64682: LD_INT 1
64684: PPUSH
64685: CALL_OW 275
64689: PUSH
64690: LD_VAR 0 4
64694: PUSH
64695: LD_INT 1
64697: ARRAY
64698: GREATEREQUAL
64699: PUSH
64700: LD_VAR 0 5
64704: PPUSH
64705: LD_INT 2
64707: PPUSH
64708: CALL_OW 275
64712: PUSH
64713: LD_VAR 0 4
64717: PUSH
64718: LD_INT 2
64720: ARRAY
64721: GREATEREQUAL
64722: AND
64723: PUSH
64724: LD_VAR 0 5
64728: PPUSH
64729: LD_INT 3
64731: PPUSH
64732: CALL_OW 275
64736: PUSH
64737: LD_VAR 0 4
64741: PUSH
64742: LD_INT 3
64744: ARRAY
64745: GREATEREQUAL
64746: AND
64747: ST_TO_ADDR
// end ;
64748: LD_VAR 0 3
64752: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64753: LD_INT 0
64755: PPUSH
64756: PPUSH
64757: PPUSH
64758: PPUSH
// pom := GetBase ( building ) ;
64759: LD_ADDR_VAR 0 3
64763: PUSH
64764: LD_VAR 0 1
64768: PPUSH
64769: CALL_OW 274
64773: ST_TO_ADDR
// if not pom then
64774: LD_VAR 0 3
64778: NOT
64779: IFFALSE 64783
// exit ;
64781: GO 64953
// btype := GetBType ( building ) ;
64783: LD_ADDR_VAR 0 5
64787: PUSH
64788: LD_VAR 0 1
64792: PPUSH
64793: CALL_OW 266
64797: ST_TO_ADDR
// if btype = b_armoury then
64798: LD_VAR 0 5
64802: PUSH
64803: LD_INT 4
64805: EQUAL
64806: IFFALSE 64816
// btype := b_barracks ;
64808: LD_ADDR_VAR 0 5
64812: PUSH
64813: LD_INT 5
64815: ST_TO_ADDR
// if btype = b_depot then
64816: LD_VAR 0 5
64820: PUSH
64821: LD_INT 0
64823: EQUAL
64824: IFFALSE 64834
// btype := b_warehouse ;
64826: LD_ADDR_VAR 0 5
64830: PUSH
64831: LD_INT 1
64833: ST_TO_ADDR
// if btype = b_workshop then
64834: LD_VAR 0 5
64838: PUSH
64839: LD_INT 2
64841: EQUAL
64842: IFFALSE 64852
// btype := b_factory ;
64844: LD_ADDR_VAR 0 5
64848: PUSH
64849: LD_INT 3
64851: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64852: LD_ADDR_VAR 0 4
64856: PUSH
64857: LD_VAR 0 5
64861: PPUSH
64862: LD_VAR 0 1
64866: PPUSH
64867: CALL_OW 248
64871: PPUSH
64872: CALL_OW 450
64876: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64877: LD_ADDR_VAR 0 2
64881: PUSH
64882: LD_VAR 0 3
64886: PPUSH
64887: LD_INT 1
64889: PPUSH
64890: CALL_OW 275
64894: PUSH
64895: LD_VAR 0 4
64899: PUSH
64900: LD_INT 1
64902: ARRAY
64903: GREATEREQUAL
64904: PUSH
64905: LD_VAR 0 3
64909: PPUSH
64910: LD_INT 2
64912: PPUSH
64913: CALL_OW 275
64917: PUSH
64918: LD_VAR 0 4
64922: PUSH
64923: LD_INT 2
64925: ARRAY
64926: GREATEREQUAL
64927: AND
64928: PUSH
64929: LD_VAR 0 3
64933: PPUSH
64934: LD_INT 3
64936: PPUSH
64937: CALL_OW 275
64941: PUSH
64942: LD_VAR 0 4
64946: PUSH
64947: LD_INT 3
64949: ARRAY
64950: GREATEREQUAL
64951: AND
64952: ST_TO_ADDR
// end ;
64953: LD_VAR 0 2
64957: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64958: LD_INT 0
64960: PPUSH
64961: PPUSH
64962: PPUSH
// pom := GetBase ( building ) ;
64963: LD_ADDR_VAR 0 4
64967: PUSH
64968: LD_VAR 0 1
64972: PPUSH
64973: CALL_OW 274
64977: ST_TO_ADDR
// if not pom then
64978: LD_VAR 0 4
64982: NOT
64983: IFFALSE 64987
// exit ;
64985: GO 65088
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64987: LD_ADDR_VAR 0 5
64991: PUSH
64992: LD_VAR 0 2
64996: PPUSH
64997: LD_VAR 0 1
65001: PPUSH
65002: CALL_OW 248
65006: PPUSH
65007: CALL_OW 450
65011: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65012: LD_ADDR_VAR 0 3
65016: PUSH
65017: LD_VAR 0 4
65021: PPUSH
65022: LD_INT 1
65024: PPUSH
65025: CALL_OW 275
65029: PUSH
65030: LD_VAR 0 5
65034: PUSH
65035: LD_INT 1
65037: ARRAY
65038: GREATEREQUAL
65039: PUSH
65040: LD_VAR 0 4
65044: PPUSH
65045: LD_INT 2
65047: PPUSH
65048: CALL_OW 275
65052: PUSH
65053: LD_VAR 0 5
65057: PUSH
65058: LD_INT 2
65060: ARRAY
65061: GREATEREQUAL
65062: AND
65063: PUSH
65064: LD_VAR 0 4
65068: PPUSH
65069: LD_INT 3
65071: PPUSH
65072: CALL_OW 275
65076: PUSH
65077: LD_VAR 0 5
65081: PUSH
65082: LD_INT 3
65084: ARRAY
65085: GREATEREQUAL
65086: AND
65087: ST_TO_ADDR
// end ;
65088: LD_VAR 0 3
65092: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
65093: LD_INT 0
65095: PPUSH
65096: PPUSH
65097: PPUSH
65098: PPUSH
65099: PPUSH
65100: PPUSH
65101: PPUSH
65102: PPUSH
65103: PPUSH
65104: PPUSH
65105: PPUSH
// result := false ;
65106: LD_ADDR_VAR 0 8
65110: PUSH
65111: LD_INT 0
65113: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
65114: LD_VAR 0 5
65118: NOT
65119: PUSH
65120: LD_VAR 0 1
65124: NOT
65125: OR
65126: PUSH
65127: LD_VAR 0 2
65131: NOT
65132: OR
65133: PUSH
65134: LD_VAR 0 3
65138: NOT
65139: OR
65140: IFFALSE 65144
// exit ;
65142: GO 65958
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
65144: LD_ADDR_VAR 0 14
65148: PUSH
65149: LD_VAR 0 1
65153: PPUSH
65154: LD_VAR 0 2
65158: PPUSH
65159: LD_VAR 0 3
65163: PPUSH
65164: LD_VAR 0 4
65168: PPUSH
65169: LD_VAR 0 5
65173: PUSH
65174: LD_INT 1
65176: ARRAY
65177: PPUSH
65178: CALL_OW 248
65182: PPUSH
65183: LD_INT 0
65185: PPUSH
65186: CALL 67211 0 6
65190: ST_TO_ADDR
// if not hexes then
65191: LD_VAR 0 14
65195: NOT
65196: IFFALSE 65200
// exit ;
65198: GO 65958
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
65200: LD_ADDR_VAR 0 17
65204: PUSH
65205: LD_VAR 0 5
65209: PPUSH
65210: LD_INT 22
65212: PUSH
65213: LD_VAR 0 13
65217: PPUSH
65218: CALL_OW 255
65222: PUSH
65223: EMPTY
65224: LIST
65225: LIST
65226: PUSH
65227: LD_INT 2
65229: PUSH
65230: LD_INT 30
65232: PUSH
65233: LD_INT 0
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: PUSH
65240: LD_INT 30
65242: PUSH
65243: LD_INT 1
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: LIST
65254: PUSH
65255: EMPTY
65256: LIST
65257: LIST
65258: PPUSH
65259: CALL_OW 72
65263: ST_TO_ADDR
// for i = 1 to hexes do
65264: LD_ADDR_VAR 0 9
65268: PUSH
65269: DOUBLE
65270: LD_INT 1
65272: DEC
65273: ST_TO_ADDR
65274: LD_VAR 0 14
65278: PUSH
65279: FOR_TO
65280: IFFALSE 65956
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65282: LD_ADDR_VAR 0 13
65286: PUSH
65287: LD_VAR 0 14
65291: PUSH
65292: LD_VAR 0 9
65296: ARRAY
65297: PUSH
65298: LD_INT 1
65300: ARRAY
65301: PPUSH
65302: LD_VAR 0 14
65306: PUSH
65307: LD_VAR 0 9
65311: ARRAY
65312: PUSH
65313: LD_INT 2
65315: ARRAY
65316: PPUSH
65317: CALL_OW 428
65321: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
65322: LD_VAR 0 14
65326: PUSH
65327: LD_VAR 0 9
65331: ARRAY
65332: PUSH
65333: LD_INT 1
65335: ARRAY
65336: PPUSH
65337: LD_VAR 0 14
65341: PUSH
65342: LD_VAR 0 9
65346: ARRAY
65347: PUSH
65348: LD_INT 2
65350: ARRAY
65351: PPUSH
65352: CALL_OW 351
65356: PUSH
65357: LD_VAR 0 14
65361: PUSH
65362: LD_VAR 0 9
65366: ARRAY
65367: PUSH
65368: LD_INT 1
65370: ARRAY
65371: PPUSH
65372: LD_VAR 0 14
65376: PUSH
65377: LD_VAR 0 9
65381: ARRAY
65382: PUSH
65383: LD_INT 2
65385: ARRAY
65386: PPUSH
65387: CALL_OW 488
65391: NOT
65392: OR
65393: PUSH
65394: LD_VAR 0 13
65398: PPUSH
65399: CALL_OW 247
65403: PUSH
65404: LD_INT 3
65406: EQUAL
65407: OR
65408: IFFALSE 65414
// exit ;
65410: POP
65411: POP
65412: GO 65958
// if not tmp then
65414: LD_VAR 0 13
65418: NOT
65419: IFFALSE 65423
// continue ;
65421: GO 65279
// result := true ;
65423: LD_ADDR_VAR 0 8
65427: PUSH
65428: LD_INT 1
65430: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
65431: LD_VAR 0 6
65435: PUSH
65436: LD_VAR 0 13
65440: PPUSH
65441: CALL_OW 247
65445: PUSH
65446: LD_INT 2
65448: EQUAL
65449: AND
65450: PUSH
65451: LD_VAR 0 13
65455: PPUSH
65456: CALL_OW 263
65460: PUSH
65461: LD_INT 1
65463: EQUAL
65464: AND
65465: IFFALSE 65629
// begin if IsDrivenBy ( tmp ) then
65467: LD_VAR 0 13
65471: PPUSH
65472: CALL_OW 311
65476: IFFALSE 65480
// continue ;
65478: GO 65279
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
65480: LD_VAR 0 6
65484: PPUSH
65485: LD_INT 3
65487: PUSH
65488: LD_INT 60
65490: PUSH
65491: EMPTY
65492: LIST
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: PUSH
65498: LD_INT 3
65500: PUSH
65501: LD_INT 55
65503: PUSH
65504: EMPTY
65505: LIST
65506: PUSH
65507: EMPTY
65508: LIST
65509: LIST
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PPUSH
65515: CALL_OW 72
65519: IFFALSE 65627
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
65521: LD_ADDR_VAR 0 18
65525: PUSH
65526: LD_VAR 0 6
65530: PPUSH
65531: LD_INT 3
65533: PUSH
65534: LD_INT 60
65536: PUSH
65537: EMPTY
65538: LIST
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: PUSH
65544: LD_INT 3
65546: PUSH
65547: LD_INT 55
65549: PUSH
65550: EMPTY
65551: LIST
65552: PUSH
65553: EMPTY
65554: LIST
65555: LIST
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PPUSH
65561: CALL_OW 72
65565: PUSH
65566: LD_INT 1
65568: ARRAY
65569: ST_TO_ADDR
// if IsInUnit ( driver ) then
65570: LD_VAR 0 18
65574: PPUSH
65575: CALL_OW 310
65579: IFFALSE 65590
// ComExit ( driver ) ;
65581: LD_VAR 0 18
65585: PPUSH
65586: CALL 91003 0 1
// AddComEnterUnit ( driver , tmp ) ;
65590: LD_VAR 0 18
65594: PPUSH
65595: LD_VAR 0 13
65599: PPUSH
65600: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
65604: LD_VAR 0 18
65608: PPUSH
65609: LD_VAR 0 7
65613: PPUSH
65614: CALL_OW 173
// AddComExitVehicle ( driver ) ;
65618: LD_VAR 0 18
65622: PPUSH
65623: CALL_OW 181
// end ; continue ;
65627: GO 65279
// end ; if not cleaners or not tmp in cleaners then
65629: LD_VAR 0 6
65633: NOT
65634: PUSH
65635: LD_VAR 0 13
65639: PUSH
65640: LD_VAR 0 6
65644: IN
65645: NOT
65646: OR
65647: IFFALSE 65954
// begin if dep then
65649: LD_VAR 0 17
65653: IFFALSE 65789
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
65655: LD_ADDR_VAR 0 16
65659: PUSH
65660: LD_VAR 0 17
65664: PUSH
65665: LD_INT 1
65667: ARRAY
65668: PPUSH
65669: CALL_OW 250
65673: PPUSH
65674: LD_VAR 0 17
65678: PUSH
65679: LD_INT 1
65681: ARRAY
65682: PPUSH
65683: CALL_OW 254
65687: PPUSH
65688: LD_INT 5
65690: PPUSH
65691: CALL_OW 272
65695: PUSH
65696: LD_VAR 0 17
65700: PUSH
65701: LD_INT 1
65703: ARRAY
65704: PPUSH
65705: CALL_OW 251
65709: PPUSH
65710: LD_VAR 0 17
65714: PUSH
65715: LD_INT 1
65717: ARRAY
65718: PPUSH
65719: CALL_OW 254
65723: PPUSH
65724: LD_INT 5
65726: PPUSH
65727: CALL_OW 273
65731: PUSH
65732: EMPTY
65733: LIST
65734: LIST
65735: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
65736: LD_VAR 0 16
65740: PUSH
65741: LD_INT 1
65743: ARRAY
65744: PPUSH
65745: LD_VAR 0 16
65749: PUSH
65750: LD_INT 2
65752: ARRAY
65753: PPUSH
65754: CALL_OW 488
65758: IFFALSE 65789
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
65760: LD_VAR 0 13
65764: PPUSH
65765: LD_VAR 0 16
65769: PUSH
65770: LD_INT 1
65772: ARRAY
65773: PPUSH
65774: LD_VAR 0 16
65778: PUSH
65779: LD_INT 2
65781: ARRAY
65782: PPUSH
65783: CALL_OW 111
// continue ;
65787: GO 65279
// end ; end ; r := GetDir ( tmp ) ;
65789: LD_ADDR_VAR 0 15
65793: PUSH
65794: LD_VAR 0 13
65798: PPUSH
65799: CALL_OW 254
65803: ST_TO_ADDR
// if r = 5 then
65804: LD_VAR 0 15
65808: PUSH
65809: LD_INT 5
65811: EQUAL
65812: IFFALSE 65822
// r := 0 ;
65814: LD_ADDR_VAR 0 15
65818: PUSH
65819: LD_INT 0
65821: ST_TO_ADDR
// for j = r to 5 do
65822: LD_ADDR_VAR 0 10
65826: PUSH
65827: DOUBLE
65828: LD_VAR 0 15
65832: DEC
65833: ST_TO_ADDR
65834: LD_INT 5
65836: PUSH
65837: FOR_TO
65838: IFFALSE 65952
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
65840: LD_ADDR_VAR 0 11
65844: PUSH
65845: LD_VAR 0 13
65849: PPUSH
65850: CALL_OW 250
65854: PPUSH
65855: LD_VAR 0 10
65859: PPUSH
65860: LD_INT 2
65862: PPUSH
65863: CALL_OW 272
65867: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
65868: LD_ADDR_VAR 0 12
65872: PUSH
65873: LD_VAR 0 13
65877: PPUSH
65878: CALL_OW 251
65882: PPUSH
65883: LD_VAR 0 10
65887: PPUSH
65888: LD_INT 2
65890: PPUSH
65891: CALL_OW 273
65895: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
65896: LD_VAR 0 11
65900: PPUSH
65901: LD_VAR 0 12
65905: PPUSH
65906: CALL_OW 488
65910: PUSH
65911: LD_VAR 0 11
65915: PPUSH
65916: LD_VAR 0 12
65920: PPUSH
65921: CALL_OW 428
65925: NOT
65926: AND
65927: IFFALSE 65950
// begin ComMoveXY ( tmp , _x , _y ) ;
65929: LD_VAR 0 13
65933: PPUSH
65934: LD_VAR 0 11
65938: PPUSH
65939: LD_VAR 0 12
65943: PPUSH
65944: CALL_OW 111
// break ;
65948: GO 65952
// end ; end ;
65950: GO 65837
65952: POP
65953: POP
// end ; end ;
65954: GO 65279
65956: POP
65957: POP
// end ;
65958: LD_VAR 0 8
65962: RET
// export function BuildingTechInvented ( side , btype ) ; begin
65963: LD_INT 0
65965: PPUSH
// result := true ;
65966: LD_ADDR_VAR 0 3
65970: PUSH
65971: LD_INT 1
65973: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
65974: LD_VAR 0 2
65978: PUSH
65979: LD_INT 24
65981: DOUBLE
65982: EQUAL
65983: IFTRUE 65993
65985: LD_INT 33
65987: DOUBLE
65988: EQUAL
65989: IFTRUE 65993
65991: GO 66018
65993: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
65994: LD_ADDR_VAR 0 3
65998: PUSH
65999: LD_INT 32
66001: PPUSH
66002: LD_VAR 0 1
66006: PPUSH
66007: CALL_OW 321
66011: PUSH
66012: LD_INT 2
66014: EQUAL
66015: ST_TO_ADDR
66016: GO 66334
66018: LD_INT 20
66020: DOUBLE
66021: EQUAL
66022: IFTRUE 66026
66024: GO 66051
66026: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
66027: LD_ADDR_VAR 0 3
66031: PUSH
66032: LD_INT 6
66034: PPUSH
66035: LD_VAR 0 1
66039: PPUSH
66040: CALL_OW 321
66044: PUSH
66045: LD_INT 2
66047: EQUAL
66048: ST_TO_ADDR
66049: GO 66334
66051: LD_INT 22
66053: DOUBLE
66054: EQUAL
66055: IFTRUE 66065
66057: LD_INT 36
66059: DOUBLE
66060: EQUAL
66061: IFTRUE 66065
66063: GO 66090
66065: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
66066: LD_ADDR_VAR 0 3
66070: PUSH
66071: LD_INT 15
66073: PPUSH
66074: LD_VAR 0 1
66078: PPUSH
66079: CALL_OW 321
66083: PUSH
66084: LD_INT 2
66086: EQUAL
66087: ST_TO_ADDR
66088: GO 66334
66090: LD_INT 30
66092: DOUBLE
66093: EQUAL
66094: IFTRUE 66098
66096: GO 66123
66098: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
66099: LD_ADDR_VAR 0 3
66103: PUSH
66104: LD_INT 20
66106: PPUSH
66107: LD_VAR 0 1
66111: PPUSH
66112: CALL_OW 321
66116: PUSH
66117: LD_INT 2
66119: EQUAL
66120: ST_TO_ADDR
66121: GO 66334
66123: LD_INT 28
66125: DOUBLE
66126: EQUAL
66127: IFTRUE 66137
66129: LD_INT 21
66131: DOUBLE
66132: EQUAL
66133: IFTRUE 66137
66135: GO 66162
66137: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
66138: LD_ADDR_VAR 0 3
66142: PUSH
66143: LD_INT 21
66145: PPUSH
66146: LD_VAR 0 1
66150: PPUSH
66151: CALL_OW 321
66155: PUSH
66156: LD_INT 2
66158: EQUAL
66159: ST_TO_ADDR
66160: GO 66334
66162: LD_INT 16
66164: DOUBLE
66165: EQUAL
66166: IFTRUE 66170
66168: GO 66195
66170: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
66171: LD_ADDR_VAR 0 3
66175: PUSH
66176: LD_INT 84
66178: PPUSH
66179: LD_VAR 0 1
66183: PPUSH
66184: CALL_OW 321
66188: PUSH
66189: LD_INT 2
66191: EQUAL
66192: ST_TO_ADDR
66193: GO 66334
66195: LD_INT 19
66197: DOUBLE
66198: EQUAL
66199: IFTRUE 66209
66201: LD_INT 23
66203: DOUBLE
66204: EQUAL
66205: IFTRUE 66209
66207: GO 66234
66209: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
66210: LD_ADDR_VAR 0 3
66214: PUSH
66215: LD_INT 83
66217: PPUSH
66218: LD_VAR 0 1
66222: PPUSH
66223: CALL_OW 321
66227: PUSH
66228: LD_INT 2
66230: EQUAL
66231: ST_TO_ADDR
66232: GO 66334
66234: LD_INT 17
66236: DOUBLE
66237: EQUAL
66238: IFTRUE 66242
66240: GO 66267
66242: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
66243: LD_ADDR_VAR 0 3
66247: PUSH
66248: LD_INT 39
66250: PPUSH
66251: LD_VAR 0 1
66255: PPUSH
66256: CALL_OW 321
66260: PUSH
66261: LD_INT 2
66263: EQUAL
66264: ST_TO_ADDR
66265: GO 66334
66267: LD_INT 18
66269: DOUBLE
66270: EQUAL
66271: IFTRUE 66275
66273: GO 66300
66275: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
66276: LD_ADDR_VAR 0 3
66280: PUSH
66281: LD_INT 40
66283: PPUSH
66284: LD_VAR 0 1
66288: PPUSH
66289: CALL_OW 321
66293: PUSH
66294: LD_INT 2
66296: EQUAL
66297: ST_TO_ADDR
66298: GO 66334
66300: LD_INT 27
66302: DOUBLE
66303: EQUAL
66304: IFTRUE 66308
66306: GO 66333
66308: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
66309: LD_ADDR_VAR 0 3
66313: PUSH
66314: LD_INT 35
66316: PPUSH
66317: LD_VAR 0 1
66321: PPUSH
66322: CALL_OW 321
66326: PUSH
66327: LD_INT 2
66329: EQUAL
66330: ST_TO_ADDR
66331: GO 66334
66333: POP
// end ;
66334: LD_VAR 0 3
66338: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
66339: LD_INT 0
66341: PPUSH
66342: PPUSH
66343: PPUSH
66344: PPUSH
66345: PPUSH
66346: PPUSH
66347: PPUSH
66348: PPUSH
66349: PPUSH
66350: PPUSH
66351: PPUSH
// result := false ;
66352: LD_ADDR_VAR 0 6
66356: PUSH
66357: LD_INT 0
66359: ST_TO_ADDR
// if btype = b_depot then
66360: LD_VAR 0 2
66364: PUSH
66365: LD_INT 0
66367: EQUAL
66368: IFFALSE 66380
// begin result := true ;
66370: LD_ADDR_VAR 0 6
66374: PUSH
66375: LD_INT 1
66377: ST_TO_ADDR
// exit ;
66378: GO 67206
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
66380: LD_VAR 0 1
66384: NOT
66385: PUSH
66386: LD_VAR 0 1
66390: PPUSH
66391: CALL_OW 266
66395: PUSH
66396: LD_INT 0
66398: PUSH
66399: LD_INT 1
66401: PUSH
66402: EMPTY
66403: LIST
66404: LIST
66405: IN
66406: NOT
66407: OR
66408: PUSH
66409: LD_VAR 0 2
66413: NOT
66414: OR
66415: PUSH
66416: LD_VAR 0 5
66420: PUSH
66421: LD_INT 0
66423: PUSH
66424: LD_INT 1
66426: PUSH
66427: LD_INT 2
66429: PUSH
66430: LD_INT 3
66432: PUSH
66433: LD_INT 4
66435: PUSH
66436: LD_INT 5
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: IN
66447: NOT
66448: OR
66449: PUSH
66450: LD_VAR 0 3
66454: PPUSH
66455: LD_VAR 0 4
66459: PPUSH
66460: CALL_OW 488
66464: NOT
66465: OR
66466: IFFALSE 66470
// exit ;
66468: GO 67206
// side := GetSide ( depot ) ;
66470: LD_ADDR_VAR 0 9
66474: PUSH
66475: LD_VAR 0 1
66479: PPUSH
66480: CALL_OW 255
66484: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
66485: LD_VAR 0 9
66489: PPUSH
66490: LD_VAR 0 2
66494: PPUSH
66495: CALL 65963 0 2
66499: NOT
66500: IFFALSE 66504
// exit ;
66502: GO 67206
// pom := GetBase ( depot ) ;
66504: LD_ADDR_VAR 0 10
66508: PUSH
66509: LD_VAR 0 1
66513: PPUSH
66514: CALL_OW 274
66518: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
66519: LD_ADDR_VAR 0 11
66523: PUSH
66524: LD_VAR 0 2
66528: PPUSH
66529: LD_VAR 0 1
66533: PPUSH
66534: CALL_OW 248
66538: PPUSH
66539: CALL_OW 450
66543: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
66544: LD_VAR 0 10
66548: PPUSH
66549: LD_INT 1
66551: PPUSH
66552: CALL_OW 275
66556: PUSH
66557: LD_VAR 0 11
66561: PUSH
66562: LD_INT 1
66564: ARRAY
66565: GREATEREQUAL
66566: PUSH
66567: LD_VAR 0 10
66571: PPUSH
66572: LD_INT 2
66574: PPUSH
66575: CALL_OW 275
66579: PUSH
66580: LD_VAR 0 11
66584: PUSH
66585: LD_INT 2
66587: ARRAY
66588: GREATEREQUAL
66589: AND
66590: PUSH
66591: LD_VAR 0 10
66595: PPUSH
66596: LD_INT 3
66598: PPUSH
66599: CALL_OW 275
66603: PUSH
66604: LD_VAR 0 11
66608: PUSH
66609: LD_INT 3
66611: ARRAY
66612: GREATEREQUAL
66613: AND
66614: NOT
66615: IFFALSE 66619
// exit ;
66617: GO 67206
// if GetBType ( depot ) = b_depot then
66619: LD_VAR 0 1
66623: PPUSH
66624: CALL_OW 266
66628: PUSH
66629: LD_INT 0
66631: EQUAL
66632: IFFALSE 66644
// dist := 28 else
66634: LD_ADDR_VAR 0 14
66638: PUSH
66639: LD_INT 28
66641: ST_TO_ADDR
66642: GO 66652
// dist := 36 ;
66644: LD_ADDR_VAR 0 14
66648: PUSH
66649: LD_INT 36
66651: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
66652: LD_VAR 0 1
66656: PPUSH
66657: LD_VAR 0 3
66661: PPUSH
66662: LD_VAR 0 4
66666: PPUSH
66667: CALL_OW 297
66671: PUSH
66672: LD_VAR 0 14
66676: GREATER
66677: IFFALSE 66681
// exit ;
66679: GO 67206
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
66681: LD_ADDR_VAR 0 12
66685: PUSH
66686: LD_VAR 0 2
66690: PPUSH
66691: LD_VAR 0 3
66695: PPUSH
66696: LD_VAR 0 4
66700: PPUSH
66701: LD_VAR 0 5
66705: PPUSH
66706: LD_VAR 0 1
66710: PPUSH
66711: CALL_OW 248
66715: PPUSH
66716: LD_INT 0
66718: PPUSH
66719: CALL 67211 0 6
66723: ST_TO_ADDR
// if not hexes then
66724: LD_VAR 0 12
66728: NOT
66729: IFFALSE 66733
// exit ;
66731: GO 67206
// hex := GetHexInfo ( x , y ) ;
66733: LD_ADDR_VAR 0 15
66737: PUSH
66738: LD_VAR 0 3
66742: PPUSH
66743: LD_VAR 0 4
66747: PPUSH
66748: CALL_OW 546
66752: ST_TO_ADDR
// if hex [ 1 ] then
66753: LD_VAR 0 15
66757: PUSH
66758: LD_INT 1
66760: ARRAY
66761: IFFALSE 66765
// exit ;
66763: GO 67206
// height := hex [ 2 ] ;
66765: LD_ADDR_VAR 0 13
66769: PUSH
66770: LD_VAR 0 15
66774: PUSH
66775: LD_INT 2
66777: ARRAY
66778: ST_TO_ADDR
// for i = 1 to hexes do
66779: LD_ADDR_VAR 0 7
66783: PUSH
66784: DOUBLE
66785: LD_INT 1
66787: DEC
66788: ST_TO_ADDR
66789: LD_VAR 0 12
66793: PUSH
66794: FOR_TO
66795: IFFALSE 67125
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
66797: LD_VAR 0 12
66801: PUSH
66802: LD_VAR 0 7
66806: ARRAY
66807: PUSH
66808: LD_INT 1
66810: ARRAY
66811: PPUSH
66812: LD_VAR 0 12
66816: PUSH
66817: LD_VAR 0 7
66821: ARRAY
66822: PUSH
66823: LD_INT 2
66825: ARRAY
66826: PPUSH
66827: CALL_OW 488
66831: NOT
66832: PUSH
66833: LD_VAR 0 12
66837: PUSH
66838: LD_VAR 0 7
66842: ARRAY
66843: PUSH
66844: LD_INT 1
66846: ARRAY
66847: PPUSH
66848: LD_VAR 0 12
66852: PUSH
66853: LD_VAR 0 7
66857: ARRAY
66858: PUSH
66859: LD_INT 2
66861: ARRAY
66862: PPUSH
66863: CALL_OW 428
66867: PUSH
66868: LD_INT 0
66870: GREATER
66871: OR
66872: PUSH
66873: LD_VAR 0 12
66877: PUSH
66878: LD_VAR 0 7
66882: ARRAY
66883: PUSH
66884: LD_INT 1
66886: ARRAY
66887: PPUSH
66888: LD_VAR 0 12
66892: PUSH
66893: LD_VAR 0 7
66897: ARRAY
66898: PUSH
66899: LD_INT 2
66901: ARRAY
66902: PPUSH
66903: CALL_OW 351
66907: OR
66908: IFFALSE 66914
// exit ;
66910: POP
66911: POP
66912: GO 67206
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
66914: LD_ADDR_VAR 0 8
66918: PUSH
66919: LD_VAR 0 12
66923: PUSH
66924: LD_VAR 0 7
66928: ARRAY
66929: PUSH
66930: LD_INT 1
66932: ARRAY
66933: PPUSH
66934: LD_VAR 0 12
66938: PUSH
66939: LD_VAR 0 7
66943: ARRAY
66944: PUSH
66945: LD_INT 2
66947: ARRAY
66948: PPUSH
66949: CALL_OW 546
66953: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
66954: LD_VAR 0 8
66958: PUSH
66959: LD_INT 1
66961: ARRAY
66962: PUSH
66963: LD_VAR 0 8
66967: PUSH
66968: LD_INT 2
66970: ARRAY
66971: PUSH
66972: LD_VAR 0 13
66976: PUSH
66977: LD_INT 2
66979: PLUS
66980: GREATER
66981: OR
66982: PUSH
66983: LD_VAR 0 8
66987: PUSH
66988: LD_INT 2
66990: ARRAY
66991: PUSH
66992: LD_VAR 0 13
66996: PUSH
66997: LD_INT 2
66999: MINUS
67000: LESS
67001: OR
67002: PUSH
67003: LD_VAR 0 8
67007: PUSH
67008: LD_INT 3
67010: ARRAY
67011: PUSH
67012: LD_INT 0
67014: PUSH
67015: LD_INT 8
67017: PUSH
67018: LD_INT 9
67020: PUSH
67021: LD_INT 10
67023: PUSH
67024: LD_INT 11
67026: PUSH
67027: LD_INT 12
67029: PUSH
67030: LD_INT 13
67032: PUSH
67033: LD_INT 16
67035: PUSH
67036: LD_INT 17
67038: PUSH
67039: LD_INT 18
67041: PUSH
67042: LD_INT 19
67044: PUSH
67045: LD_INT 20
67047: PUSH
67048: LD_INT 21
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: IN
67066: NOT
67067: OR
67068: PUSH
67069: LD_VAR 0 8
67073: PUSH
67074: LD_INT 5
67076: ARRAY
67077: NOT
67078: OR
67079: PUSH
67080: LD_VAR 0 8
67084: PUSH
67085: LD_INT 6
67087: ARRAY
67088: PUSH
67089: LD_INT 1
67091: PUSH
67092: LD_INT 2
67094: PUSH
67095: LD_INT 7
67097: PUSH
67098: LD_INT 9
67100: PUSH
67101: LD_INT 10
67103: PUSH
67104: LD_INT 11
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: LIST
67111: LIST
67112: LIST
67113: LIST
67114: IN
67115: NOT
67116: OR
67117: IFFALSE 67123
// exit ;
67119: POP
67120: POP
67121: GO 67206
// end ;
67123: GO 66794
67125: POP
67126: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
67127: LD_VAR 0 9
67131: PPUSH
67132: LD_VAR 0 3
67136: PPUSH
67137: LD_VAR 0 4
67141: PPUSH
67142: LD_INT 20
67144: PPUSH
67145: CALL 59129 0 4
67149: PUSH
67150: LD_INT 4
67152: ARRAY
67153: IFFALSE 67157
// exit ;
67155: GO 67206
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
67157: LD_VAR 0 2
67161: PUSH
67162: LD_INT 29
67164: PUSH
67165: LD_INT 30
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: IN
67172: PUSH
67173: LD_VAR 0 3
67177: PPUSH
67178: LD_VAR 0 4
67182: PPUSH
67183: LD_VAR 0 9
67187: PPUSH
67188: CALL_OW 440
67192: NOT
67193: AND
67194: IFFALSE 67198
// exit ;
67196: GO 67206
// result := true ;
67198: LD_ADDR_VAR 0 6
67202: PUSH
67203: LD_INT 1
67205: ST_TO_ADDR
// end ;
67206: LD_VAR 0 6
67210: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
67211: LD_INT 0
67213: PPUSH
67214: PPUSH
67215: PPUSH
67216: PPUSH
67217: PPUSH
67218: PPUSH
67219: PPUSH
67220: PPUSH
67221: PPUSH
67222: PPUSH
67223: PPUSH
67224: PPUSH
67225: PPUSH
67226: PPUSH
67227: PPUSH
67228: PPUSH
67229: PPUSH
67230: PPUSH
67231: PPUSH
67232: PPUSH
67233: PPUSH
67234: PPUSH
67235: PPUSH
67236: PPUSH
67237: PPUSH
67238: PPUSH
67239: PPUSH
67240: PPUSH
67241: PPUSH
67242: PPUSH
67243: PPUSH
67244: PPUSH
67245: PPUSH
67246: PPUSH
67247: PPUSH
67248: PPUSH
67249: PPUSH
67250: PPUSH
67251: PPUSH
67252: PPUSH
67253: PPUSH
67254: PPUSH
67255: PPUSH
67256: PPUSH
67257: PPUSH
67258: PPUSH
67259: PPUSH
67260: PPUSH
67261: PPUSH
67262: PPUSH
67263: PPUSH
67264: PPUSH
67265: PPUSH
67266: PPUSH
67267: PPUSH
67268: PPUSH
67269: PPUSH
67270: PPUSH
// result = [ ] ;
67271: LD_ADDR_VAR 0 7
67275: PUSH
67276: EMPTY
67277: ST_TO_ADDR
// temp_list = [ ] ;
67278: LD_ADDR_VAR 0 9
67282: PUSH
67283: EMPTY
67284: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
67285: LD_VAR 0 4
67289: PUSH
67290: LD_INT 0
67292: PUSH
67293: LD_INT 1
67295: PUSH
67296: LD_INT 2
67298: PUSH
67299: LD_INT 3
67301: PUSH
67302: LD_INT 4
67304: PUSH
67305: LD_INT 5
67307: PUSH
67308: EMPTY
67309: LIST
67310: LIST
67311: LIST
67312: LIST
67313: LIST
67314: LIST
67315: IN
67316: NOT
67317: PUSH
67318: LD_VAR 0 1
67322: PUSH
67323: LD_INT 0
67325: PUSH
67326: LD_INT 1
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: IN
67333: PUSH
67334: LD_VAR 0 5
67338: PUSH
67339: LD_INT 1
67341: PUSH
67342: LD_INT 2
67344: PUSH
67345: LD_INT 3
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: LIST
67352: IN
67353: NOT
67354: AND
67355: OR
67356: IFFALSE 67360
// exit ;
67358: GO 85751
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
67360: LD_VAR 0 1
67364: PUSH
67365: LD_INT 6
67367: PUSH
67368: LD_INT 7
67370: PUSH
67371: LD_INT 8
67373: PUSH
67374: LD_INT 13
67376: PUSH
67377: LD_INT 12
67379: PUSH
67380: LD_INT 15
67382: PUSH
67383: LD_INT 11
67385: PUSH
67386: LD_INT 14
67388: PUSH
67389: LD_INT 10
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: LIST
67396: LIST
67397: LIST
67398: LIST
67399: LIST
67400: LIST
67401: LIST
67402: IN
67403: IFFALSE 67413
// btype = b_lab ;
67405: LD_ADDR_VAR 0 1
67409: PUSH
67410: LD_INT 6
67412: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
67413: LD_VAR 0 6
67417: PUSH
67418: LD_INT 0
67420: PUSH
67421: LD_INT 1
67423: PUSH
67424: LD_INT 2
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: LIST
67431: IN
67432: NOT
67433: PUSH
67434: LD_VAR 0 1
67438: PUSH
67439: LD_INT 0
67441: PUSH
67442: LD_INT 1
67444: PUSH
67445: LD_INT 2
67447: PUSH
67448: LD_INT 3
67450: PUSH
67451: LD_INT 6
67453: PUSH
67454: LD_INT 36
67456: PUSH
67457: LD_INT 4
67459: PUSH
67460: LD_INT 5
67462: PUSH
67463: LD_INT 31
67465: PUSH
67466: LD_INT 32
67468: PUSH
67469: LD_INT 33
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: LIST
67483: LIST
67484: IN
67485: NOT
67486: PUSH
67487: LD_VAR 0 6
67491: PUSH
67492: LD_INT 1
67494: EQUAL
67495: AND
67496: OR
67497: PUSH
67498: LD_VAR 0 1
67502: PUSH
67503: LD_INT 2
67505: PUSH
67506: LD_INT 3
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: IN
67513: NOT
67514: PUSH
67515: LD_VAR 0 6
67519: PUSH
67520: LD_INT 2
67522: EQUAL
67523: AND
67524: OR
67525: IFFALSE 67535
// mode = 0 ;
67527: LD_ADDR_VAR 0 6
67531: PUSH
67532: LD_INT 0
67534: ST_TO_ADDR
// case mode of 0 :
67535: LD_VAR 0 6
67539: PUSH
67540: LD_INT 0
67542: DOUBLE
67543: EQUAL
67544: IFTRUE 67548
67546: GO 79001
67548: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67549: LD_ADDR_VAR 0 11
67553: PUSH
67554: LD_INT 0
67556: PUSH
67557: LD_INT 0
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 0
67566: PUSH
67567: LD_INT 1
67569: NEG
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 1
67577: PUSH
67578: LD_INT 0
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 1
67587: PUSH
67588: LD_INT 1
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 0
67597: PUSH
67598: LD_INT 1
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 1
67607: NEG
67608: PUSH
67609: LD_INT 0
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PUSH
67616: LD_INT 1
67618: NEG
67619: PUSH
67620: LD_INT 1
67622: NEG
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 1
67630: NEG
67631: PUSH
67632: LD_INT 2
67634: NEG
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 0
67642: PUSH
67643: LD_INT 2
67645: NEG
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: LD_INT 1
67653: PUSH
67654: LD_INT 1
67656: NEG
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 1
67664: PUSH
67665: LD_INT 2
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 0
67674: PUSH
67675: LD_INT 2
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 1
67684: NEG
67685: PUSH
67686: LD_INT 1
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 1
67695: PUSH
67696: LD_INT 3
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 0
67705: PUSH
67706: LD_INT 3
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: PUSH
67713: LD_INT 1
67715: NEG
67716: PUSH
67717: LD_INT 2
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67742: LD_ADDR_VAR 0 12
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: LD_INT 0
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: PUSH
67757: LD_INT 0
67759: PUSH
67760: LD_INT 1
67762: NEG
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 1
67770: PUSH
67771: LD_INT 0
67773: PUSH
67774: EMPTY
67775: LIST
67776: LIST
67777: PUSH
67778: LD_INT 1
67780: PUSH
67781: LD_INT 1
67783: PUSH
67784: EMPTY
67785: LIST
67786: LIST
67787: PUSH
67788: LD_INT 0
67790: PUSH
67791: LD_INT 1
67793: PUSH
67794: EMPTY
67795: LIST
67796: LIST
67797: PUSH
67798: LD_INT 1
67800: NEG
67801: PUSH
67802: LD_INT 0
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: PUSH
67809: LD_INT 1
67811: NEG
67812: PUSH
67813: LD_INT 1
67815: NEG
67816: PUSH
67817: EMPTY
67818: LIST
67819: LIST
67820: PUSH
67821: LD_INT 1
67823: PUSH
67824: LD_INT 1
67826: NEG
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 2
67834: PUSH
67835: LD_INT 0
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: LD_INT 2
67844: PUSH
67845: LD_INT 1
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: PUSH
67852: LD_INT 1
67854: NEG
67855: PUSH
67856: LD_INT 1
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: LD_INT 2
67865: NEG
67866: PUSH
67867: LD_INT 0
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 2
67876: NEG
67877: PUSH
67878: LD_INT 1
67880: NEG
67881: PUSH
67882: EMPTY
67883: LIST
67884: LIST
67885: PUSH
67886: LD_INT 2
67888: NEG
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PUSH
67897: LD_INT 3
67899: NEG
67900: PUSH
67901: LD_INT 0
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 3
67910: NEG
67911: PUSH
67912: LD_INT 1
67914: NEG
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: PUSH
67920: EMPTY
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67938: LD_ADDR_VAR 0 13
67942: PUSH
67943: LD_INT 0
67945: PUSH
67946: LD_INT 0
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 0
67955: PUSH
67956: LD_INT 1
67958: NEG
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 1
67966: PUSH
67967: LD_INT 0
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 1
67976: PUSH
67977: LD_INT 1
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 0
67986: PUSH
67987: LD_INT 1
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 1
67996: NEG
67997: PUSH
67998: LD_INT 0
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 1
68007: NEG
68008: PUSH
68009: LD_INT 1
68011: NEG
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 1
68019: NEG
68020: PUSH
68021: LD_INT 2
68023: NEG
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 2
68031: PUSH
68032: LD_INT 1
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: LD_INT 2
68041: PUSH
68042: LD_INT 2
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: PUSH
68049: LD_INT 1
68051: PUSH
68052: LD_INT 2
68054: PUSH
68055: EMPTY
68056: LIST
68057: LIST
68058: PUSH
68059: LD_INT 2
68061: NEG
68062: PUSH
68063: LD_INT 1
68065: NEG
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 2
68073: NEG
68074: PUSH
68075: LD_INT 2
68077: NEG
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 2
68085: NEG
68086: PUSH
68087: LD_INT 3
68089: NEG
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: LD_INT 3
68097: NEG
68098: PUSH
68099: LD_INT 2
68101: NEG
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PUSH
68107: LD_INT 3
68109: NEG
68110: PUSH
68111: LD_INT 3
68113: NEG
68114: PUSH
68115: EMPTY
68116: LIST
68117: LIST
68118: PUSH
68119: EMPTY
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: LIST
68129: LIST
68130: LIST
68131: LIST
68132: LIST
68133: LIST
68134: LIST
68135: LIST
68136: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
68137: LD_ADDR_VAR 0 14
68141: PUSH
68142: LD_INT 0
68144: PUSH
68145: LD_INT 0
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PUSH
68152: LD_INT 0
68154: PUSH
68155: LD_INT 1
68157: NEG
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: LD_INT 1
68165: PUSH
68166: LD_INT 0
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: PUSH
68173: LD_INT 1
68175: PUSH
68176: LD_INT 1
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 0
68185: PUSH
68186: LD_INT 1
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 1
68195: NEG
68196: PUSH
68197: LD_INT 0
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 1
68206: NEG
68207: PUSH
68208: LD_INT 1
68210: NEG
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 1
68218: NEG
68219: PUSH
68220: LD_INT 2
68222: NEG
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: LD_INT 0
68230: PUSH
68231: LD_INT 2
68233: NEG
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 1
68241: PUSH
68242: LD_INT 1
68244: NEG
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 1
68252: PUSH
68253: LD_INT 2
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 0
68262: PUSH
68263: LD_INT 2
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 1
68272: NEG
68273: PUSH
68274: LD_INT 1
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: PUSH
68281: LD_INT 1
68283: NEG
68284: PUSH
68285: LD_INT 3
68287: NEG
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 0
68295: PUSH
68296: LD_INT 3
68298: NEG
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: PUSH
68304: LD_INT 1
68306: PUSH
68307: LD_INT 2
68309: NEG
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: EMPTY
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: LIST
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
68333: LD_ADDR_VAR 0 15
68337: PUSH
68338: LD_INT 0
68340: PUSH
68341: LD_INT 0
68343: PUSH
68344: EMPTY
68345: LIST
68346: LIST
68347: PUSH
68348: LD_INT 0
68350: PUSH
68351: LD_INT 1
68353: NEG
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PUSH
68359: LD_INT 1
68361: PUSH
68362: LD_INT 0
68364: PUSH
68365: EMPTY
68366: LIST
68367: LIST
68368: PUSH
68369: LD_INT 1
68371: PUSH
68372: LD_INT 1
68374: PUSH
68375: EMPTY
68376: LIST
68377: LIST
68378: PUSH
68379: LD_INT 0
68381: PUSH
68382: LD_INT 1
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: PUSH
68389: LD_INT 1
68391: NEG
68392: PUSH
68393: LD_INT 0
68395: PUSH
68396: EMPTY
68397: LIST
68398: LIST
68399: PUSH
68400: LD_INT 1
68402: NEG
68403: PUSH
68404: LD_INT 1
68406: NEG
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 1
68414: PUSH
68415: LD_INT 1
68417: NEG
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 2
68425: PUSH
68426: LD_INT 0
68428: PUSH
68429: EMPTY
68430: LIST
68431: LIST
68432: PUSH
68433: LD_INT 2
68435: PUSH
68436: LD_INT 1
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 1
68445: NEG
68446: PUSH
68447: LD_INT 1
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: LD_INT 2
68456: NEG
68457: PUSH
68458: LD_INT 0
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 2
68467: NEG
68468: PUSH
68469: LD_INT 1
68471: NEG
68472: PUSH
68473: EMPTY
68474: LIST
68475: LIST
68476: PUSH
68477: LD_INT 2
68479: PUSH
68480: LD_INT 1
68482: NEG
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: PUSH
68488: LD_INT 3
68490: PUSH
68491: LD_INT 0
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PUSH
68498: LD_INT 3
68500: PUSH
68501: LD_INT 1
68503: PUSH
68504: EMPTY
68505: LIST
68506: LIST
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: LIST
68512: LIST
68513: LIST
68514: LIST
68515: LIST
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
68526: LD_ADDR_VAR 0 16
68530: PUSH
68531: LD_INT 0
68533: PUSH
68534: LD_INT 0
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 0
68543: PUSH
68544: LD_INT 1
68546: NEG
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 1
68554: PUSH
68555: LD_INT 0
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: LD_INT 1
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 0
68574: PUSH
68575: LD_INT 1
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PUSH
68582: LD_INT 1
68584: NEG
68585: PUSH
68586: LD_INT 0
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 1
68595: NEG
68596: PUSH
68597: LD_INT 1
68599: NEG
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: LD_INT 1
68607: NEG
68608: PUSH
68609: LD_INT 2
68611: NEG
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: LD_INT 2
68619: PUSH
68620: LD_INT 1
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: LD_INT 2
68629: PUSH
68630: LD_INT 2
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: LD_INT 1
68639: PUSH
68640: LD_INT 2
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: LD_INT 2
68649: NEG
68650: PUSH
68651: LD_INT 1
68653: NEG
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: PUSH
68659: LD_INT 2
68661: NEG
68662: PUSH
68663: LD_INT 2
68665: NEG
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 3
68673: PUSH
68674: LD_INT 2
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 3
68683: PUSH
68684: LD_INT 3
68686: PUSH
68687: EMPTY
68688: LIST
68689: LIST
68690: PUSH
68691: LD_INT 2
68693: PUSH
68694: LD_INT 3
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: EMPTY
68702: LIST
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68719: LD_ADDR_VAR 0 17
68723: PUSH
68724: LD_INT 0
68726: PUSH
68727: LD_INT 0
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 0
68736: PUSH
68737: LD_INT 1
68739: NEG
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 1
68747: PUSH
68748: LD_INT 0
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PUSH
68755: LD_INT 1
68757: PUSH
68758: LD_INT 1
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 0
68767: PUSH
68768: LD_INT 1
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: LD_INT 1
68777: NEG
68778: PUSH
68779: LD_INT 0
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: PUSH
68786: LD_INT 1
68788: NEG
68789: PUSH
68790: LD_INT 1
68792: NEG
68793: PUSH
68794: EMPTY
68795: LIST
68796: LIST
68797: PUSH
68798: LD_INT 1
68800: NEG
68801: PUSH
68802: LD_INT 2
68804: NEG
68805: PUSH
68806: EMPTY
68807: LIST
68808: LIST
68809: PUSH
68810: LD_INT 0
68812: PUSH
68813: LD_INT 2
68815: NEG
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 1
68823: PUSH
68824: LD_INT 1
68826: NEG
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PUSH
68832: LD_INT 2
68834: PUSH
68835: LD_INT 0
68837: PUSH
68838: EMPTY
68839: LIST
68840: LIST
68841: PUSH
68842: LD_INT 2
68844: PUSH
68845: LD_INT 1
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 2
68854: PUSH
68855: LD_INT 2
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: LD_INT 1
68864: PUSH
68865: LD_INT 2
68867: PUSH
68868: EMPTY
68869: LIST
68870: LIST
68871: PUSH
68872: LD_INT 0
68874: PUSH
68875: LD_INT 2
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PUSH
68882: LD_INT 1
68884: NEG
68885: PUSH
68886: LD_INT 1
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 2
68895: NEG
68896: PUSH
68897: LD_INT 0
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: PUSH
68904: LD_INT 2
68906: NEG
68907: PUSH
68908: LD_INT 1
68910: NEG
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: PUSH
68916: LD_INT 2
68918: NEG
68919: PUSH
68920: LD_INT 2
68922: NEG
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: LIST
68932: LIST
68933: LIST
68934: LIST
68935: LIST
68936: LIST
68937: LIST
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68949: LD_ADDR_VAR 0 18
68953: PUSH
68954: LD_INT 0
68956: PUSH
68957: LD_INT 0
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PUSH
68964: LD_INT 0
68966: PUSH
68967: LD_INT 1
68969: NEG
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 1
68977: PUSH
68978: LD_INT 0
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: PUSH
68985: LD_INT 1
68987: PUSH
68988: LD_INT 1
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 0
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: LD_INT 1
69007: NEG
69008: PUSH
69009: LD_INT 0
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: PUSH
69016: LD_INT 1
69018: NEG
69019: PUSH
69020: LD_INT 1
69022: NEG
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: LD_INT 1
69030: NEG
69031: PUSH
69032: LD_INT 2
69034: NEG
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PUSH
69040: LD_INT 0
69042: PUSH
69043: LD_INT 2
69045: NEG
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 1
69053: PUSH
69054: LD_INT 1
69056: NEG
69057: PUSH
69058: EMPTY
69059: LIST
69060: LIST
69061: PUSH
69062: LD_INT 2
69064: PUSH
69065: LD_INT 0
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 2
69074: PUSH
69075: LD_INT 1
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: LD_INT 2
69084: PUSH
69085: LD_INT 2
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 1
69094: PUSH
69095: LD_INT 2
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 0
69104: PUSH
69105: LD_INT 2
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 1
69114: NEG
69115: PUSH
69116: LD_INT 1
69118: PUSH
69119: EMPTY
69120: LIST
69121: LIST
69122: PUSH
69123: LD_INT 2
69125: NEG
69126: PUSH
69127: LD_INT 0
69129: PUSH
69130: EMPTY
69131: LIST
69132: LIST
69133: PUSH
69134: LD_INT 2
69136: NEG
69137: PUSH
69138: LD_INT 1
69140: NEG
69141: PUSH
69142: EMPTY
69143: LIST
69144: LIST
69145: PUSH
69146: LD_INT 2
69148: NEG
69149: PUSH
69150: LD_INT 2
69152: NEG
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: LIST
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69179: LD_ADDR_VAR 0 19
69183: PUSH
69184: LD_INT 0
69186: PUSH
69187: LD_INT 0
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 0
69196: PUSH
69197: LD_INT 1
69199: NEG
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 1
69207: PUSH
69208: LD_INT 0
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 1
69217: PUSH
69218: LD_INT 1
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: LD_INT 0
69227: PUSH
69228: LD_INT 1
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: PUSH
69235: LD_INT 1
69237: NEG
69238: PUSH
69239: LD_INT 0
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PUSH
69246: LD_INT 1
69248: NEG
69249: PUSH
69250: LD_INT 1
69252: NEG
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 1
69260: NEG
69261: PUSH
69262: LD_INT 2
69264: NEG
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 0
69272: PUSH
69273: LD_INT 2
69275: NEG
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 1
69283: PUSH
69284: LD_INT 1
69286: NEG
69287: PUSH
69288: EMPTY
69289: LIST
69290: LIST
69291: PUSH
69292: LD_INT 2
69294: PUSH
69295: LD_INT 0
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 2
69304: PUSH
69305: LD_INT 1
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PUSH
69312: LD_INT 2
69314: PUSH
69315: LD_INT 2
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 1
69324: PUSH
69325: LD_INT 2
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 0
69334: PUSH
69335: LD_INT 2
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PUSH
69342: LD_INT 1
69344: NEG
69345: PUSH
69346: LD_INT 1
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PUSH
69353: LD_INT 2
69355: NEG
69356: PUSH
69357: LD_INT 0
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: PUSH
69364: LD_INT 2
69366: NEG
69367: PUSH
69368: LD_INT 1
69370: NEG
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 2
69378: NEG
69379: PUSH
69380: LD_INT 2
69382: NEG
69383: PUSH
69384: EMPTY
69385: LIST
69386: LIST
69387: PUSH
69388: EMPTY
69389: LIST
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: LIST
69395: LIST
69396: LIST
69397: LIST
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69409: LD_ADDR_VAR 0 20
69413: PUSH
69414: LD_INT 0
69416: PUSH
69417: LD_INT 0
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: LD_INT 0
69426: PUSH
69427: LD_INT 1
69429: NEG
69430: PUSH
69431: EMPTY
69432: LIST
69433: LIST
69434: PUSH
69435: LD_INT 1
69437: PUSH
69438: LD_INT 0
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: PUSH
69445: LD_INT 1
69447: PUSH
69448: LD_INT 1
69450: PUSH
69451: EMPTY
69452: LIST
69453: LIST
69454: PUSH
69455: LD_INT 0
69457: PUSH
69458: LD_INT 1
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: PUSH
69465: LD_INT 1
69467: NEG
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 1
69478: NEG
69479: PUSH
69480: LD_INT 1
69482: NEG
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 1
69490: NEG
69491: PUSH
69492: LD_INT 2
69494: NEG
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: LD_INT 0
69502: PUSH
69503: LD_INT 2
69505: NEG
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PUSH
69511: LD_INT 1
69513: PUSH
69514: LD_INT 1
69516: NEG
69517: PUSH
69518: EMPTY
69519: LIST
69520: LIST
69521: PUSH
69522: LD_INT 2
69524: PUSH
69525: LD_INT 0
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 2
69534: PUSH
69535: LD_INT 1
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 2
69544: PUSH
69545: LD_INT 2
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 1
69554: PUSH
69555: LD_INT 2
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: LD_INT 0
69564: PUSH
69565: LD_INT 2
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 1
69574: NEG
69575: PUSH
69576: LD_INT 1
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PUSH
69583: LD_INT 2
69585: NEG
69586: PUSH
69587: LD_INT 0
69589: PUSH
69590: EMPTY
69591: LIST
69592: LIST
69593: PUSH
69594: LD_INT 2
69596: NEG
69597: PUSH
69598: LD_INT 1
69600: NEG
69601: PUSH
69602: EMPTY
69603: LIST
69604: LIST
69605: PUSH
69606: LD_INT 2
69608: NEG
69609: PUSH
69610: LD_INT 2
69612: NEG
69613: PUSH
69614: EMPTY
69615: LIST
69616: LIST
69617: PUSH
69618: EMPTY
69619: LIST
69620: LIST
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69639: LD_ADDR_VAR 0 21
69643: PUSH
69644: LD_INT 0
69646: PUSH
69647: LD_INT 0
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 0
69656: PUSH
69657: LD_INT 1
69659: NEG
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 1
69667: PUSH
69668: LD_INT 0
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: PUSH
69675: LD_INT 1
69677: PUSH
69678: LD_INT 1
69680: PUSH
69681: EMPTY
69682: LIST
69683: LIST
69684: PUSH
69685: LD_INT 0
69687: PUSH
69688: LD_INT 1
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: PUSH
69695: LD_INT 1
69697: NEG
69698: PUSH
69699: LD_INT 0
69701: PUSH
69702: EMPTY
69703: LIST
69704: LIST
69705: PUSH
69706: LD_INT 1
69708: NEG
69709: PUSH
69710: LD_INT 1
69712: NEG
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 1
69720: NEG
69721: PUSH
69722: LD_INT 2
69724: NEG
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: LD_INT 0
69732: PUSH
69733: LD_INT 2
69735: NEG
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 1
69743: PUSH
69744: LD_INT 1
69746: NEG
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 2
69754: PUSH
69755: LD_INT 0
69757: PUSH
69758: EMPTY
69759: LIST
69760: LIST
69761: PUSH
69762: LD_INT 2
69764: PUSH
69765: LD_INT 1
69767: PUSH
69768: EMPTY
69769: LIST
69770: LIST
69771: PUSH
69772: LD_INT 2
69774: PUSH
69775: LD_INT 2
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 1
69784: PUSH
69785: LD_INT 2
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 0
69794: PUSH
69795: LD_INT 2
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 1
69804: NEG
69805: PUSH
69806: LD_INT 1
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 2
69815: NEG
69816: PUSH
69817: LD_INT 0
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 2
69826: NEG
69827: PUSH
69828: LD_INT 1
69830: NEG
69831: PUSH
69832: EMPTY
69833: LIST
69834: LIST
69835: PUSH
69836: LD_INT 2
69838: NEG
69839: PUSH
69840: LD_INT 2
69842: NEG
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69869: LD_ADDR_VAR 0 22
69873: PUSH
69874: LD_INT 0
69876: PUSH
69877: LD_INT 0
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 0
69886: PUSH
69887: LD_INT 1
69889: NEG
69890: PUSH
69891: EMPTY
69892: LIST
69893: LIST
69894: PUSH
69895: LD_INT 1
69897: PUSH
69898: LD_INT 0
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: LD_INT 1
69907: PUSH
69908: LD_INT 1
69910: PUSH
69911: EMPTY
69912: LIST
69913: LIST
69914: PUSH
69915: LD_INT 0
69917: PUSH
69918: LD_INT 1
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: LD_INT 1
69927: NEG
69928: PUSH
69929: LD_INT 0
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: PUSH
69936: LD_INT 1
69938: NEG
69939: PUSH
69940: LD_INT 1
69942: NEG
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: PUSH
69948: LD_INT 1
69950: NEG
69951: PUSH
69952: LD_INT 2
69954: NEG
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 0
69962: PUSH
69963: LD_INT 2
69965: NEG
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: LD_INT 1
69976: NEG
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: PUSH
69982: LD_INT 2
69984: PUSH
69985: LD_INT 0
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 2
69994: PUSH
69995: LD_INT 1
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: LD_INT 2
70004: PUSH
70005: LD_INT 2
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 1
70014: PUSH
70015: LD_INT 2
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: LD_INT 0
70024: PUSH
70025: LD_INT 2
70027: PUSH
70028: EMPTY
70029: LIST
70030: LIST
70031: PUSH
70032: LD_INT 1
70034: NEG
70035: PUSH
70036: LD_INT 1
70038: PUSH
70039: EMPTY
70040: LIST
70041: LIST
70042: PUSH
70043: LD_INT 2
70045: NEG
70046: PUSH
70047: LD_INT 0
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: PUSH
70054: LD_INT 2
70056: NEG
70057: PUSH
70058: LD_INT 1
70060: NEG
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: PUSH
70066: LD_INT 2
70068: NEG
70069: PUSH
70070: LD_INT 2
70072: NEG
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: LIST
70089: LIST
70090: LIST
70091: LIST
70092: LIST
70093: LIST
70094: LIST
70095: LIST
70096: LIST
70097: LIST
70098: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
70099: LD_ADDR_VAR 0 23
70103: PUSH
70104: LD_INT 0
70106: PUSH
70107: LD_INT 0
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 0
70116: PUSH
70117: LD_INT 1
70119: NEG
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 1
70127: PUSH
70128: LD_INT 0
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 1
70137: PUSH
70138: LD_INT 1
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 0
70147: PUSH
70148: LD_INT 1
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PUSH
70155: LD_INT 1
70157: NEG
70158: PUSH
70159: LD_INT 0
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: LD_INT 1
70168: NEG
70169: PUSH
70170: LD_INT 1
70172: NEG
70173: PUSH
70174: EMPTY
70175: LIST
70176: LIST
70177: PUSH
70178: LD_INT 1
70180: NEG
70181: PUSH
70182: LD_INT 2
70184: NEG
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 0
70192: PUSH
70193: LD_INT 2
70195: NEG
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 1
70203: PUSH
70204: LD_INT 1
70206: NEG
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: PUSH
70212: LD_INT 2
70214: PUSH
70215: LD_INT 0
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 2
70224: PUSH
70225: LD_INT 1
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 2
70234: PUSH
70235: LD_INT 2
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 1
70244: PUSH
70245: LD_INT 2
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 0
70254: PUSH
70255: LD_INT 2
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PUSH
70262: LD_INT 1
70264: NEG
70265: PUSH
70266: LD_INT 1
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: PUSH
70273: LD_INT 2
70275: NEG
70276: PUSH
70277: LD_INT 0
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: LD_INT 2
70286: NEG
70287: PUSH
70288: LD_INT 1
70290: NEG
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PUSH
70296: LD_INT 2
70298: NEG
70299: PUSH
70300: LD_INT 2
70302: NEG
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PUSH
70308: LD_INT 2
70310: NEG
70311: PUSH
70312: LD_INT 3
70314: NEG
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: LD_INT 3
70326: NEG
70327: PUSH
70328: EMPTY
70329: LIST
70330: LIST
70331: PUSH
70332: LD_INT 1
70334: PUSH
70335: LD_INT 2
70337: NEG
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: LD_INT 2
70345: PUSH
70346: LD_INT 1
70348: NEG
70349: PUSH
70350: EMPTY
70351: LIST
70352: LIST
70353: PUSH
70354: EMPTY
70355: LIST
70356: LIST
70357: LIST
70358: LIST
70359: LIST
70360: LIST
70361: LIST
70362: LIST
70363: LIST
70364: LIST
70365: LIST
70366: LIST
70367: LIST
70368: LIST
70369: LIST
70370: LIST
70371: LIST
70372: LIST
70373: LIST
70374: LIST
70375: LIST
70376: LIST
70377: LIST
70378: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
70379: LD_ADDR_VAR 0 24
70383: PUSH
70384: LD_INT 0
70386: PUSH
70387: LD_INT 0
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 0
70396: PUSH
70397: LD_INT 1
70399: NEG
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 1
70407: PUSH
70408: LD_INT 0
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 1
70417: PUSH
70418: LD_INT 1
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 0
70427: PUSH
70428: LD_INT 1
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: PUSH
70435: LD_INT 1
70437: NEG
70438: PUSH
70439: LD_INT 0
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: LD_INT 1
70448: NEG
70449: PUSH
70450: LD_INT 1
70452: NEG
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 1
70460: NEG
70461: PUSH
70462: LD_INT 2
70464: NEG
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 0
70472: PUSH
70473: LD_INT 2
70475: NEG
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PUSH
70481: LD_INT 1
70483: PUSH
70484: LD_INT 1
70486: NEG
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PUSH
70492: LD_INT 2
70494: PUSH
70495: LD_INT 0
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: PUSH
70502: LD_INT 2
70504: PUSH
70505: LD_INT 1
70507: PUSH
70508: EMPTY
70509: LIST
70510: LIST
70511: PUSH
70512: LD_INT 2
70514: PUSH
70515: LD_INT 2
70517: PUSH
70518: EMPTY
70519: LIST
70520: LIST
70521: PUSH
70522: LD_INT 1
70524: PUSH
70525: LD_INT 2
70527: PUSH
70528: EMPTY
70529: LIST
70530: LIST
70531: PUSH
70532: LD_INT 0
70534: PUSH
70535: LD_INT 2
70537: PUSH
70538: EMPTY
70539: LIST
70540: LIST
70541: PUSH
70542: LD_INT 1
70544: NEG
70545: PUSH
70546: LD_INT 1
70548: PUSH
70549: EMPTY
70550: LIST
70551: LIST
70552: PUSH
70553: LD_INT 2
70555: NEG
70556: PUSH
70557: LD_INT 0
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 2
70566: NEG
70567: PUSH
70568: LD_INT 1
70570: NEG
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 2
70578: NEG
70579: PUSH
70580: LD_INT 2
70582: NEG
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: PUSH
70588: LD_INT 1
70590: PUSH
70591: LD_INT 2
70593: NEG
70594: PUSH
70595: EMPTY
70596: LIST
70597: LIST
70598: PUSH
70599: LD_INT 2
70601: PUSH
70602: LD_INT 1
70604: NEG
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 3
70612: PUSH
70613: LD_INT 1
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 3
70622: PUSH
70623: LD_INT 2
70625: PUSH
70626: EMPTY
70627: LIST
70628: LIST
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: LIST
70647: LIST
70648: LIST
70649: LIST
70650: LIST
70651: LIST
70652: LIST
70653: LIST
70654: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
70655: LD_ADDR_VAR 0 25
70659: PUSH
70660: LD_INT 0
70662: PUSH
70663: LD_INT 0
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 0
70672: PUSH
70673: LD_INT 1
70675: NEG
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 1
70683: PUSH
70684: LD_INT 0
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: PUSH
70691: LD_INT 1
70693: PUSH
70694: LD_INT 1
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 0
70703: PUSH
70704: LD_INT 1
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PUSH
70711: LD_INT 1
70713: NEG
70714: PUSH
70715: LD_INT 0
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: LD_INT 1
70724: NEG
70725: PUSH
70726: LD_INT 1
70728: NEG
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 1
70736: NEG
70737: PUSH
70738: LD_INT 2
70740: NEG
70741: PUSH
70742: EMPTY
70743: LIST
70744: LIST
70745: PUSH
70746: LD_INT 0
70748: PUSH
70749: LD_INT 2
70751: NEG
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: PUSH
70757: LD_INT 1
70759: PUSH
70760: LD_INT 1
70762: NEG
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: PUSH
70768: LD_INT 2
70770: PUSH
70771: LD_INT 0
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: PUSH
70778: LD_INT 2
70780: PUSH
70781: LD_INT 1
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 2
70790: PUSH
70791: LD_INT 2
70793: PUSH
70794: EMPTY
70795: LIST
70796: LIST
70797: PUSH
70798: LD_INT 1
70800: PUSH
70801: LD_INT 2
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: PUSH
70808: LD_INT 0
70810: PUSH
70811: LD_INT 2
70813: PUSH
70814: EMPTY
70815: LIST
70816: LIST
70817: PUSH
70818: LD_INT 1
70820: NEG
70821: PUSH
70822: LD_INT 1
70824: PUSH
70825: EMPTY
70826: LIST
70827: LIST
70828: PUSH
70829: LD_INT 2
70831: NEG
70832: PUSH
70833: LD_INT 0
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 2
70842: NEG
70843: PUSH
70844: LD_INT 1
70846: NEG
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PUSH
70852: LD_INT 2
70854: NEG
70855: PUSH
70856: LD_INT 2
70858: NEG
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: PUSH
70864: LD_INT 3
70866: PUSH
70867: LD_INT 1
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 3
70876: PUSH
70877: LD_INT 2
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: LD_INT 2
70886: PUSH
70887: LD_INT 3
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: PUSH
70894: LD_INT 1
70896: PUSH
70897: LD_INT 3
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: LIST
70928: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
70929: LD_ADDR_VAR 0 26
70933: PUSH
70934: LD_INT 0
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: LD_INT 0
70946: PUSH
70947: LD_INT 1
70949: NEG
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 1
70957: PUSH
70958: LD_INT 0
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: LD_INT 1
70967: PUSH
70968: LD_INT 1
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PUSH
70975: LD_INT 0
70977: PUSH
70978: LD_INT 1
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: LD_INT 1
70987: NEG
70988: PUSH
70989: LD_INT 0
70991: PUSH
70992: EMPTY
70993: LIST
70994: LIST
70995: PUSH
70996: LD_INT 1
70998: NEG
70999: PUSH
71000: LD_INT 1
71002: NEG
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 1
71010: NEG
71011: PUSH
71012: LD_INT 2
71014: NEG
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: PUSH
71020: LD_INT 0
71022: PUSH
71023: LD_INT 2
71025: NEG
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: PUSH
71031: LD_INT 1
71033: PUSH
71034: LD_INT 1
71036: NEG
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: PUSH
71042: LD_INT 2
71044: PUSH
71045: LD_INT 0
71047: PUSH
71048: EMPTY
71049: LIST
71050: LIST
71051: PUSH
71052: LD_INT 2
71054: PUSH
71055: LD_INT 1
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 2
71064: PUSH
71065: LD_INT 2
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 1
71074: PUSH
71075: LD_INT 2
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: LD_INT 0
71084: PUSH
71085: LD_INT 2
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 1
71094: NEG
71095: PUSH
71096: LD_INT 1
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 2
71105: NEG
71106: PUSH
71107: LD_INT 0
71109: PUSH
71110: EMPTY
71111: LIST
71112: LIST
71113: PUSH
71114: LD_INT 2
71116: NEG
71117: PUSH
71118: LD_INT 1
71120: NEG
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 2
71128: NEG
71129: PUSH
71130: LD_INT 2
71132: NEG
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 2
71140: PUSH
71141: LD_INT 3
71143: PUSH
71144: EMPTY
71145: LIST
71146: LIST
71147: PUSH
71148: LD_INT 1
71150: PUSH
71151: LD_INT 3
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: PUSH
71158: LD_INT 1
71160: NEG
71161: PUSH
71162: LD_INT 2
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 2
71171: NEG
71172: PUSH
71173: LD_INT 1
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: LIST
71184: LIST
71185: LIST
71186: LIST
71187: LIST
71188: LIST
71189: LIST
71190: LIST
71191: LIST
71192: LIST
71193: LIST
71194: LIST
71195: LIST
71196: LIST
71197: LIST
71198: LIST
71199: LIST
71200: LIST
71201: LIST
71202: LIST
71203: LIST
71204: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71205: LD_ADDR_VAR 0 27
71209: PUSH
71210: LD_INT 0
71212: PUSH
71213: LD_INT 0
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 0
71222: PUSH
71223: LD_INT 1
71225: NEG
71226: PUSH
71227: EMPTY
71228: LIST
71229: LIST
71230: PUSH
71231: LD_INT 1
71233: PUSH
71234: LD_INT 0
71236: PUSH
71237: EMPTY
71238: LIST
71239: LIST
71240: PUSH
71241: LD_INT 1
71243: PUSH
71244: LD_INT 1
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 0
71253: PUSH
71254: LD_INT 1
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 1
71263: NEG
71264: PUSH
71265: LD_INT 0
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: PUSH
71272: LD_INT 1
71274: NEG
71275: PUSH
71276: LD_INT 1
71278: NEG
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: PUSH
71284: LD_INT 1
71286: NEG
71287: PUSH
71288: LD_INT 2
71290: NEG
71291: PUSH
71292: EMPTY
71293: LIST
71294: LIST
71295: PUSH
71296: LD_INT 0
71298: PUSH
71299: LD_INT 2
71301: NEG
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 1
71309: PUSH
71310: LD_INT 1
71312: NEG
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 2
71320: PUSH
71321: LD_INT 0
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: LD_INT 2
71330: PUSH
71331: LD_INT 1
71333: PUSH
71334: EMPTY
71335: LIST
71336: LIST
71337: PUSH
71338: LD_INT 2
71340: PUSH
71341: LD_INT 2
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: PUSH
71348: LD_INT 1
71350: PUSH
71351: LD_INT 2
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: PUSH
71358: LD_INT 0
71360: PUSH
71361: LD_INT 2
71363: PUSH
71364: EMPTY
71365: LIST
71366: LIST
71367: PUSH
71368: LD_INT 1
71370: NEG
71371: PUSH
71372: LD_INT 1
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: LD_INT 2
71381: NEG
71382: PUSH
71383: LD_INT 0
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 2
71392: NEG
71393: PUSH
71394: LD_INT 1
71396: NEG
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: LD_INT 2
71404: NEG
71405: PUSH
71406: LD_INT 2
71408: NEG
71409: PUSH
71410: EMPTY
71411: LIST
71412: LIST
71413: PUSH
71414: LD_INT 1
71416: NEG
71417: PUSH
71418: LD_INT 2
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: LD_INT 2
71427: NEG
71428: PUSH
71429: LD_INT 1
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: PUSH
71436: LD_INT 3
71438: NEG
71439: PUSH
71440: LD_INT 1
71442: NEG
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: PUSH
71448: LD_INT 3
71450: NEG
71451: PUSH
71452: LD_INT 2
71454: NEG
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: LIST
71464: LIST
71465: LIST
71466: LIST
71467: LIST
71468: LIST
71469: LIST
71470: LIST
71471: LIST
71472: LIST
71473: LIST
71474: LIST
71475: LIST
71476: LIST
71477: LIST
71478: LIST
71479: LIST
71480: LIST
71481: LIST
71482: LIST
71483: LIST
71484: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71485: LD_ADDR_VAR 0 28
71489: PUSH
71490: LD_INT 0
71492: PUSH
71493: LD_INT 0
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 0
71502: PUSH
71503: LD_INT 1
71505: NEG
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 1
71513: PUSH
71514: LD_INT 0
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: PUSH
71521: LD_INT 1
71523: PUSH
71524: LD_INT 1
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 0
71533: PUSH
71534: LD_INT 1
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 1
71543: NEG
71544: PUSH
71545: LD_INT 0
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PUSH
71552: LD_INT 1
71554: NEG
71555: PUSH
71556: LD_INT 1
71558: NEG
71559: PUSH
71560: EMPTY
71561: LIST
71562: LIST
71563: PUSH
71564: LD_INT 1
71566: NEG
71567: PUSH
71568: LD_INT 2
71570: NEG
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: LD_INT 0
71578: PUSH
71579: LD_INT 2
71581: NEG
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 1
71589: PUSH
71590: LD_INT 1
71592: NEG
71593: PUSH
71594: EMPTY
71595: LIST
71596: LIST
71597: PUSH
71598: LD_INT 2
71600: PUSH
71601: LD_INT 0
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: PUSH
71608: LD_INT 2
71610: PUSH
71611: LD_INT 1
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 2
71620: PUSH
71621: LD_INT 2
71623: PUSH
71624: EMPTY
71625: LIST
71626: LIST
71627: PUSH
71628: LD_INT 1
71630: PUSH
71631: LD_INT 2
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: LD_INT 0
71640: PUSH
71641: LD_INT 2
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 1
71650: NEG
71651: PUSH
71652: LD_INT 1
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: PUSH
71659: LD_INT 2
71661: NEG
71662: PUSH
71663: LD_INT 0
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 2
71672: NEG
71673: PUSH
71674: LD_INT 1
71676: NEG
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 2
71684: NEG
71685: PUSH
71686: LD_INT 2
71688: NEG
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: LD_INT 2
71696: NEG
71697: PUSH
71698: LD_INT 3
71700: NEG
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: PUSH
71706: LD_INT 1
71708: NEG
71709: PUSH
71710: LD_INT 3
71712: NEG
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PUSH
71718: LD_INT 3
71720: NEG
71721: PUSH
71722: LD_INT 1
71724: NEG
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 3
71732: NEG
71733: PUSH
71734: LD_INT 2
71736: NEG
71737: PUSH
71738: EMPTY
71739: LIST
71740: LIST
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: LIST
71746: LIST
71747: LIST
71748: LIST
71749: LIST
71750: LIST
71751: LIST
71752: LIST
71753: LIST
71754: LIST
71755: LIST
71756: LIST
71757: LIST
71758: LIST
71759: LIST
71760: LIST
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71767: LD_ADDR_VAR 0 29
71771: PUSH
71772: LD_INT 0
71774: PUSH
71775: LD_INT 0
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 0
71784: PUSH
71785: LD_INT 1
71787: NEG
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: LD_INT 1
71795: PUSH
71796: LD_INT 0
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: PUSH
71803: LD_INT 1
71805: PUSH
71806: LD_INT 1
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 0
71815: PUSH
71816: LD_INT 1
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: PUSH
71823: LD_INT 1
71825: NEG
71826: PUSH
71827: LD_INT 0
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: PUSH
71834: LD_INT 1
71836: NEG
71837: PUSH
71838: LD_INT 1
71840: NEG
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 1
71848: NEG
71849: PUSH
71850: LD_INT 2
71852: NEG
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: PUSH
71858: LD_INT 0
71860: PUSH
71861: LD_INT 2
71863: NEG
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 1
71871: PUSH
71872: LD_INT 1
71874: NEG
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 2
71882: PUSH
71883: LD_INT 0
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PUSH
71890: LD_INT 2
71892: PUSH
71893: LD_INT 1
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 1
71902: PUSH
71903: LD_INT 2
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: PUSH
71910: LD_INT 0
71912: PUSH
71913: LD_INT 2
71915: PUSH
71916: EMPTY
71917: LIST
71918: LIST
71919: PUSH
71920: LD_INT 1
71922: NEG
71923: PUSH
71924: LD_INT 1
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: PUSH
71931: LD_INT 2
71933: NEG
71934: PUSH
71935: LD_INT 1
71937: NEG
71938: PUSH
71939: EMPTY
71940: LIST
71941: LIST
71942: PUSH
71943: LD_INT 2
71945: NEG
71946: PUSH
71947: LD_INT 2
71949: NEG
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 2
71957: NEG
71958: PUSH
71959: LD_INT 3
71961: NEG
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 2
71969: PUSH
71970: LD_INT 1
71972: NEG
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: PUSH
71978: LD_INT 3
71980: PUSH
71981: LD_INT 1
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 1
71990: PUSH
71991: LD_INT 3
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 1
72000: NEG
72001: PUSH
72002: LD_INT 2
72004: PUSH
72005: EMPTY
72006: LIST
72007: LIST
72008: PUSH
72009: LD_INT 3
72011: NEG
72012: PUSH
72013: LD_INT 2
72015: NEG
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: LIST
72025: LIST
72026: LIST
72027: LIST
72028: LIST
72029: LIST
72030: LIST
72031: LIST
72032: LIST
72033: LIST
72034: LIST
72035: LIST
72036: LIST
72037: LIST
72038: LIST
72039: LIST
72040: LIST
72041: LIST
72042: LIST
72043: LIST
72044: LIST
72045: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72046: LD_ADDR_VAR 0 30
72050: PUSH
72051: LD_INT 0
72053: PUSH
72054: LD_INT 0
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 0
72063: PUSH
72064: LD_INT 1
72066: NEG
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: LD_INT 1
72074: PUSH
72075: LD_INT 0
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: LD_INT 1
72084: PUSH
72085: LD_INT 1
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: PUSH
72092: LD_INT 0
72094: PUSH
72095: LD_INT 1
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: PUSH
72102: LD_INT 1
72104: NEG
72105: PUSH
72106: LD_INT 0
72108: PUSH
72109: EMPTY
72110: LIST
72111: LIST
72112: PUSH
72113: LD_INT 1
72115: NEG
72116: PUSH
72117: LD_INT 1
72119: NEG
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: PUSH
72125: LD_INT 1
72127: NEG
72128: PUSH
72129: LD_INT 2
72131: NEG
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 0
72139: PUSH
72140: LD_INT 2
72142: NEG
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 1
72150: PUSH
72151: LD_INT 1
72153: NEG
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: PUSH
72159: LD_INT 2
72161: PUSH
72162: LD_INT 0
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 2
72171: PUSH
72172: LD_INT 1
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PUSH
72179: LD_INT 2
72181: PUSH
72182: LD_INT 2
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 1
72191: PUSH
72192: LD_INT 2
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: LD_INT 1
72201: NEG
72202: PUSH
72203: LD_INT 1
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 2
72212: NEG
72213: PUSH
72214: LD_INT 0
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: PUSH
72221: LD_INT 2
72223: NEG
72224: PUSH
72225: LD_INT 1
72227: NEG
72228: PUSH
72229: EMPTY
72230: LIST
72231: LIST
72232: PUSH
72233: LD_INT 1
72235: NEG
72236: PUSH
72237: LD_INT 3
72239: NEG
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 1
72247: PUSH
72248: LD_INT 2
72250: NEG
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: PUSH
72256: LD_INT 3
72258: PUSH
72259: LD_INT 2
72261: PUSH
72262: EMPTY
72263: LIST
72264: LIST
72265: PUSH
72266: LD_INT 2
72268: PUSH
72269: LD_INT 3
72271: PUSH
72272: EMPTY
72273: LIST
72274: LIST
72275: PUSH
72276: LD_INT 2
72278: NEG
72279: PUSH
72280: LD_INT 1
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 3
72289: NEG
72290: PUSH
72291: LD_INT 1
72293: NEG
72294: PUSH
72295: EMPTY
72296: LIST
72297: LIST
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: LIST
72303: LIST
72304: LIST
72305: LIST
72306: LIST
72307: LIST
72308: LIST
72309: LIST
72310: LIST
72311: LIST
72312: LIST
72313: LIST
72314: LIST
72315: LIST
72316: LIST
72317: LIST
72318: LIST
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72324: LD_ADDR_VAR 0 31
72328: PUSH
72329: LD_INT 0
72331: PUSH
72332: LD_INT 0
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 0
72341: PUSH
72342: LD_INT 1
72344: NEG
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 1
72352: PUSH
72353: LD_INT 0
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: LD_INT 1
72362: PUSH
72363: LD_INT 1
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: LD_INT 0
72372: PUSH
72373: LD_INT 1
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: LD_INT 1
72382: NEG
72383: PUSH
72384: LD_INT 0
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 1
72393: NEG
72394: PUSH
72395: LD_INT 1
72397: NEG
72398: PUSH
72399: EMPTY
72400: LIST
72401: LIST
72402: PUSH
72403: LD_INT 1
72405: NEG
72406: PUSH
72407: LD_INT 2
72409: NEG
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PUSH
72415: LD_INT 1
72417: PUSH
72418: LD_INT 1
72420: NEG
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 2
72428: PUSH
72429: LD_INT 0
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: LD_INT 2
72438: PUSH
72439: LD_INT 1
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 2
72448: PUSH
72449: LD_INT 2
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 1
72458: PUSH
72459: LD_INT 2
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: PUSH
72466: LD_INT 0
72468: PUSH
72469: LD_INT 2
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 1
72478: NEG
72479: PUSH
72480: LD_INT 1
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: PUSH
72487: LD_INT 2
72489: NEG
72490: PUSH
72491: LD_INT 1
72493: NEG
72494: PUSH
72495: EMPTY
72496: LIST
72497: LIST
72498: PUSH
72499: LD_INT 2
72501: NEG
72502: PUSH
72503: LD_INT 2
72505: NEG
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: LD_INT 2
72513: NEG
72514: PUSH
72515: LD_INT 3
72517: NEG
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 2
72525: PUSH
72526: LD_INT 1
72528: NEG
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 3
72536: PUSH
72537: LD_INT 1
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 1
72546: PUSH
72547: LD_INT 3
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 1
72556: NEG
72557: PUSH
72558: LD_INT 2
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: LD_INT 3
72567: NEG
72568: PUSH
72569: LD_INT 2
72571: NEG
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: LIST
72581: LIST
72582: LIST
72583: LIST
72584: LIST
72585: LIST
72586: LIST
72587: LIST
72588: LIST
72589: LIST
72590: LIST
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: LIST
72600: LIST
72601: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72602: LD_ADDR_VAR 0 32
72606: PUSH
72607: LD_INT 0
72609: PUSH
72610: LD_INT 0
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PUSH
72617: LD_INT 0
72619: PUSH
72620: LD_INT 1
72622: NEG
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: LD_INT 1
72630: PUSH
72631: LD_INT 0
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: LD_INT 1
72640: PUSH
72641: LD_INT 1
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: PUSH
72648: LD_INT 0
72650: PUSH
72651: LD_INT 1
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: LD_INT 1
72660: NEG
72661: PUSH
72662: LD_INT 0
72664: PUSH
72665: EMPTY
72666: LIST
72667: LIST
72668: PUSH
72669: LD_INT 1
72671: NEG
72672: PUSH
72673: LD_INT 1
72675: NEG
72676: PUSH
72677: EMPTY
72678: LIST
72679: LIST
72680: PUSH
72681: LD_INT 1
72683: NEG
72684: PUSH
72685: LD_INT 2
72687: NEG
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PUSH
72693: LD_INT 0
72695: PUSH
72696: LD_INT 2
72698: NEG
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 1
72706: PUSH
72707: LD_INT 1
72709: NEG
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 2
72717: PUSH
72718: LD_INT 1
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 2
72727: PUSH
72728: LD_INT 2
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PUSH
72735: LD_INT 1
72737: PUSH
72738: LD_INT 2
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: LD_INT 0
72747: PUSH
72748: LD_INT 2
72750: PUSH
72751: EMPTY
72752: LIST
72753: LIST
72754: PUSH
72755: LD_INT 1
72757: NEG
72758: PUSH
72759: LD_INT 1
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: PUSH
72766: LD_INT 2
72768: NEG
72769: PUSH
72770: LD_INT 0
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: PUSH
72777: LD_INT 2
72779: NEG
72780: PUSH
72781: LD_INT 1
72783: NEG
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: LD_INT 1
72791: NEG
72792: PUSH
72793: LD_INT 3
72795: NEG
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 1
72803: PUSH
72804: LD_INT 2
72806: NEG
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: PUSH
72812: LD_INT 3
72814: PUSH
72815: LD_INT 2
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 2
72824: PUSH
72825: LD_INT 3
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 2
72834: NEG
72835: PUSH
72836: LD_INT 1
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: PUSH
72843: LD_INT 3
72845: NEG
72846: PUSH
72847: LD_INT 1
72849: NEG
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: EMPTY
72856: LIST
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: LIST
72863: LIST
72864: LIST
72865: LIST
72866: LIST
72867: LIST
72868: LIST
72869: LIST
72870: LIST
72871: LIST
72872: LIST
72873: LIST
72874: LIST
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72880: LD_ADDR_VAR 0 33
72884: PUSH
72885: LD_INT 0
72887: PUSH
72888: LD_INT 0
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PUSH
72895: LD_INT 0
72897: PUSH
72898: LD_INT 1
72900: NEG
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 1
72908: PUSH
72909: LD_INT 0
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 1
72918: PUSH
72919: LD_INT 1
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 0
72928: PUSH
72929: LD_INT 1
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 1
72938: NEG
72939: PUSH
72940: LD_INT 0
72942: PUSH
72943: EMPTY
72944: LIST
72945: LIST
72946: PUSH
72947: LD_INT 1
72949: NEG
72950: PUSH
72951: LD_INT 1
72953: NEG
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 1
72961: NEG
72962: PUSH
72963: LD_INT 2
72965: NEG
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 1
72973: PUSH
72974: LD_INT 1
72976: NEG
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 2
72984: PUSH
72985: LD_INT 0
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 2
72994: PUSH
72995: LD_INT 1
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: PUSH
73002: LD_INT 1
73004: PUSH
73005: LD_INT 2
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: PUSH
73012: LD_INT 0
73014: PUSH
73015: LD_INT 2
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PUSH
73022: LD_INT 1
73024: NEG
73025: PUSH
73026: LD_INT 1
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 2
73035: NEG
73036: PUSH
73037: LD_INT 0
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: LD_INT 2
73046: NEG
73047: PUSH
73048: LD_INT 1
73050: NEG
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: PUSH
73056: LD_INT 2
73058: NEG
73059: PUSH
73060: LD_INT 2
73062: NEG
73063: PUSH
73064: EMPTY
73065: LIST
73066: LIST
73067: PUSH
73068: LD_INT 2
73070: NEG
73071: PUSH
73072: LD_INT 3
73074: NEG
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: PUSH
73080: LD_INT 2
73082: PUSH
73083: LD_INT 1
73085: NEG
73086: PUSH
73087: EMPTY
73088: LIST
73089: LIST
73090: PUSH
73091: LD_INT 3
73093: PUSH
73094: LD_INT 1
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: LD_INT 1
73103: PUSH
73104: LD_INT 3
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: PUSH
73111: LD_INT 1
73113: NEG
73114: PUSH
73115: LD_INT 2
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 3
73124: NEG
73125: PUSH
73126: LD_INT 2
73128: NEG
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: LIST
73142: LIST
73143: LIST
73144: LIST
73145: LIST
73146: LIST
73147: LIST
73148: LIST
73149: LIST
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: LIST
73155: LIST
73156: LIST
73157: LIST
73158: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73159: LD_ADDR_VAR 0 34
73163: PUSH
73164: LD_INT 0
73166: PUSH
73167: LD_INT 0
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: LD_INT 0
73176: PUSH
73177: LD_INT 1
73179: NEG
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 1
73187: PUSH
73188: LD_INT 0
73190: PUSH
73191: EMPTY
73192: LIST
73193: LIST
73194: PUSH
73195: LD_INT 1
73197: PUSH
73198: LD_INT 1
73200: PUSH
73201: EMPTY
73202: LIST
73203: LIST
73204: PUSH
73205: LD_INT 0
73207: PUSH
73208: LD_INT 1
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: PUSH
73215: LD_INT 1
73217: NEG
73218: PUSH
73219: LD_INT 0
73221: PUSH
73222: EMPTY
73223: LIST
73224: LIST
73225: PUSH
73226: LD_INT 1
73228: NEG
73229: PUSH
73230: LD_INT 1
73232: NEG
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PUSH
73238: LD_INT 1
73240: NEG
73241: PUSH
73242: LD_INT 2
73244: NEG
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 0
73252: PUSH
73253: LD_INT 2
73255: NEG
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 1
73263: PUSH
73264: LD_INT 1
73266: NEG
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: LD_INT 2
73274: PUSH
73275: LD_INT 1
73277: PUSH
73278: EMPTY
73279: LIST
73280: LIST
73281: PUSH
73282: LD_INT 2
73284: PUSH
73285: LD_INT 2
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: PUSH
73292: LD_INT 1
73294: PUSH
73295: LD_INT 2
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 1
73304: NEG
73305: PUSH
73306: LD_INT 1
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 2
73315: NEG
73316: PUSH
73317: LD_INT 0
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: PUSH
73324: LD_INT 2
73326: NEG
73327: PUSH
73328: LD_INT 1
73330: NEG
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: PUSH
73336: LD_INT 2
73338: NEG
73339: PUSH
73340: LD_INT 2
73342: NEG
73343: PUSH
73344: EMPTY
73345: LIST
73346: LIST
73347: PUSH
73348: LD_INT 1
73350: NEG
73351: PUSH
73352: LD_INT 3
73354: NEG
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 1
73362: PUSH
73363: LD_INT 2
73365: NEG
73366: PUSH
73367: EMPTY
73368: LIST
73369: LIST
73370: PUSH
73371: LD_INT 3
73373: PUSH
73374: LD_INT 2
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PUSH
73381: LD_INT 2
73383: PUSH
73384: LD_INT 3
73386: PUSH
73387: EMPTY
73388: LIST
73389: LIST
73390: PUSH
73391: LD_INT 2
73393: NEG
73394: PUSH
73395: LD_INT 1
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: LD_INT 3
73404: NEG
73405: PUSH
73406: LD_INT 1
73408: NEG
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: LIST
73418: LIST
73419: LIST
73420: LIST
73421: LIST
73422: LIST
73423: LIST
73424: LIST
73425: LIST
73426: LIST
73427: LIST
73428: LIST
73429: LIST
73430: LIST
73431: LIST
73432: LIST
73433: LIST
73434: LIST
73435: LIST
73436: LIST
73437: LIST
73438: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
73439: LD_ADDR_VAR 0 35
73443: PUSH
73444: LD_INT 0
73446: PUSH
73447: LD_INT 0
73449: PUSH
73450: EMPTY
73451: LIST
73452: LIST
73453: PUSH
73454: LD_INT 0
73456: PUSH
73457: LD_INT 1
73459: NEG
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 1
73467: PUSH
73468: LD_INT 0
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: LD_INT 1
73477: PUSH
73478: LD_INT 1
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PUSH
73485: LD_INT 0
73487: PUSH
73488: LD_INT 1
73490: PUSH
73491: EMPTY
73492: LIST
73493: LIST
73494: PUSH
73495: LD_INT 1
73497: NEG
73498: PUSH
73499: LD_INT 0
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PUSH
73506: LD_INT 1
73508: NEG
73509: PUSH
73510: LD_INT 1
73512: NEG
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: LD_INT 2
73520: PUSH
73521: LD_INT 1
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 2
73530: NEG
73531: PUSH
73532: LD_INT 1
73534: NEG
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: LIST
73550: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73551: LD_ADDR_VAR 0 36
73555: PUSH
73556: LD_INT 0
73558: PUSH
73559: LD_INT 0
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 0
73568: PUSH
73569: LD_INT 1
73571: NEG
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 1
73579: PUSH
73580: LD_INT 0
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 1
73589: PUSH
73590: LD_INT 1
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 0
73599: PUSH
73600: LD_INT 1
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: PUSH
73607: LD_INT 1
73609: NEG
73610: PUSH
73611: LD_INT 0
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 1
73620: NEG
73621: PUSH
73622: LD_INT 1
73624: NEG
73625: PUSH
73626: EMPTY
73627: LIST
73628: LIST
73629: PUSH
73630: LD_INT 1
73632: NEG
73633: PUSH
73634: LD_INT 2
73636: NEG
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: PUSH
73642: LD_INT 1
73644: PUSH
73645: LD_INT 2
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: LIST
73656: LIST
73657: LIST
73658: LIST
73659: LIST
73660: LIST
73661: LIST
73662: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73663: LD_ADDR_VAR 0 37
73667: PUSH
73668: LD_INT 0
73670: PUSH
73671: LD_INT 0
73673: PUSH
73674: EMPTY
73675: LIST
73676: LIST
73677: PUSH
73678: LD_INT 0
73680: PUSH
73681: LD_INT 1
73683: NEG
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 1
73691: PUSH
73692: LD_INT 0
73694: PUSH
73695: EMPTY
73696: LIST
73697: LIST
73698: PUSH
73699: LD_INT 1
73701: PUSH
73702: LD_INT 1
73704: PUSH
73705: EMPTY
73706: LIST
73707: LIST
73708: PUSH
73709: LD_INT 0
73711: PUSH
73712: LD_INT 1
73714: PUSH
73715: EMPTY
73716: LIST
73717: LIST
73718: PUSH
73719: LD_INT 1
73721: NEG
73722: PUSH
73723: LD_INT 0
73725: PUSH
73726: EMPTY
73727: LIST
73728: LIST
73729: PUSH
73730: LD_INT 1
73732: NEG
73733: PUSH
73734: LD_INT 1
73736: NEG
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 1
73744: PUSH
73745: LD_INT 1
73747: NEG
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 1
73755: NEG
73756: PUSH
73757: LD_INT 1
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
73775: LD_ADDR_VAR 0 38
73779: PUSH
73780: LD_INT 0
73782: PUSH
73783: LD_INT 0
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 0
73792: PUSH
73793: LD_INT 1
73795: NEG
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: PUSH
73801: LD_INT 1
73803: PUSH
73804: LD_INT 0
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 1
73813: PUSH
73814: LD_INT 1
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: PUSH
73821: LD_INT 0
73823: PUSH
73824: LD_INT 1
73826: PUSH
73827: EMPTY
73828: LIST
73829: LIST
73830: PUSH
73831: LD_INT 1
73833: NEG
73834: PUSH
73835: LD_INT 0
73837: PUSH
73838: EMPTY
73839: LIST
73840: LIST
73841: PUSH
73842: LD_INT 1
73844: NEG
73845: PUSH
73846: LD_INT 1
73848: NEG
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: PUSH
73854: LD_INT 2
73856: PUSH
73857: LD_INT 1
73859: PUSH
73860: EMPTY
73861: LIST
73862: LIST
73863: PUSH
73864: LD_INT 2
73866: NEG
73867: PUSH
73868: LD_INT 1
73870: NEG
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: LIST
73880: LIST
73881: LIST
73882: LIST
73883: LIST
73884: LIST
73885: LIST
73886: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73887: LD_ADDR_VAR 0 39
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: LD_INT 0
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 0
73904: PUSH
73905: LD_INT 1
73907: NEG
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 1
73915: PUSH
73916: LD_INT 0
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 1
73925: PUSH
73926: LD_INT 1
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 0
73935: PUSH
73936: LD_INT 1
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: LD_INT 1
73945: NEG
73946: PUSH
73947: LD_INT 0
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: PUSH
73954: LD_INT 1
73956: NEG
73957: PUSH
73958: LD_INT 1
73960: NEG
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 1
73968: NEG
73969: PUSH
73970: LD_INT 2
73972: NEG
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 1
73980: PUSH
73981: LD_INT 2
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: LIST
73998: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73999: LD_ADDR_VAR 0 40
74003: PUSH
74004: LD_INT 0
74006: PUSH
74007: LD_INT 0
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PUSH
74014: LD_INT 0
74016: PUSH
74017: LD_INT 1
74019: NEG
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: PUSH
74025: LD_INT 1
74027: PUSH
74028: LD_INT 0
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: PUSH
74035: LD_INT 1
74037: PUSH
74038: LD_INT 1
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: PUSH
74045: LD_INT 0
74047: PUSH
74048: LD_INT 1
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: PUSH
74055: LD_INT 1
74057: NEG
74058: PUSH
74059: LD_INT 0
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: LD_INT 1
74068: NEG
74069: PUSH
74070: LD_INT 1
74072: NEG
74073: PUSH
74074: EMPTY
74075: LIST
74076: LIST
74077: PUSH
74078: LD_INT 1
74080: PUSH
74081: LD_INT 1
74083: NEG
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PUSH
74089: LD_INT 1
74091: NEG
74092: PUSH
74093: LD_INT 1
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: LIST
74104: LIST
74105: LIST
74106: LIST
74107: LIST
74108: LIST
74109: LIST
74110: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74111: LD_ADDR_VAR 0 41
74115: PUSH
74116: LD_INT 0
74118: PUSH
74119: LD_INT 0
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 0
74128: PUSH
74129: LD_INT 1
74131: NEG
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: PUSH
74137: LD_INT 1
74139: PUSH
74140: LD_INT 0
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: PUSH
74147: LD_INT 1
74149: PUSH
74150: LD_INT 1
74152: PUSH
74153: EMPTY
74154: LIST
74155: LIST
74156: PUSH
74157: LD_INT 0
74159: PUSH
74160: LD_INT 1
74162: PUSH
74163: EMPTY
74164: LIST
74165: LIST
74166: PUSH
74167: LD_INT 1
74169: NEG
74170: PUSH
74171: LD_INT 0
74173: PUSH
74174: EMPTY
74175: LIST
74176: LIST
74177: PUSH
74178: LD_INT 1
74180: NEG
74181: PUSH
74182: LD_INT 1
74184: NEG
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: LD_INT 1
74192: NEG
74193: PUSH
74194: LD_INT 2
74196: NEG
74197: PUSH
74198: EMPTY
74199: LIST
74200: LIST
74201: PUSH
74202: LD_INT 1
74204: PUSH
74205: LD_INT 1
74207: NEG
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 2
74215: PUSH
74216: LD_INT 0
74218: PUSH
74219: EMPTY
74220: LIST
74221: LIST
74222: PUSH
74223: LD_INT 2
74225: PUSH
74226: LD_INT 1
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: PUSH
74233: LD_INT 2
74235: PUSH
74236: LD_INT 2
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: PUSH
74243: LD_INT 1
74245: PUSH
74246: LD_INT 2
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 1
74255: NEG
74256: PUSH
74257: LD_INT 1
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 2
74266: NEG
74267: PUSH
74268: LD_INT 0
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 2
74277: NEG
74278: PUSH
74279: LD_INT 1
74281: NEG
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: PUSH
74287: LD_INT 2
74289: NEG
74290: PUSH
74291: LD_INT 2
74293: NEG
74294: PUSH
74295: EMPTY
74296: LIST
74297: LIST
74298: PUSH
74299: LD_INT 2
74301: NEG
74302: PUSH
74303: LD_INT 3
74305: NEG
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 2
74313: PUSH
74314: LD_INT 1
74316: NEG
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: PUSH
74322: LD_INT 3
74324: PUSH
74325: LD_INT 0
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: PUSH
74332: LD_INT 3
74334: PUSH
74335: LD_INT 1
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: PUSH
74342: LD_INT 3
74344: PUSH
74345: LD_INT 2
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: PUSH
74352: LD_INT 3
74354: PUSH
74355: LD_INT 3
74357: PUSH
74358: EMPTY
74359: LIST
74360: LIST
74361: PUSH
74362: LD_INT 2
74364: PUSH
74365: LD_INT 3
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 2
74374: NEG
74375: PUSH
74376: LD_INT 1
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: LD_INT 3
74385: NEG
74386: PUSH
74387: LD_INT 0
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: LD_INT 3
74396: NEG
74397: PUSH
74398: LD_INT 1
74400: NEG
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 3
74408: NEG
74409: PUSH
74410: LD_INT 2
74412: NEG
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: LD_INT 3
74420: NEG
74421: PUSH
74422: LD_INT 3
74424: NEG
74425: PUSH
74426: EMPTY
74427: LIST
74428: LIST
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: LIST
74434: LIST
74435: LIST
74436: LIST
74437: LIST
74438: LIST
74439: LIST
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: LIST
74445: LIST
74446: LIST
74447: LIST
74448: LIST
74449: LIST
74450: LIST
74451: LIST
74452: LIST
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: LIST
74458: LIST
74459: LIST
74460: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74461: LD_ADDR_VAR 0 42
74465: PUSH
74466: LD_INT 0
74468: PUSH
74469: LD_INT 0
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 0
74478: PUSH
74479: LD_INT 1
74481: NEG
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PUSH
74487: LD_INT 1
74489: PUSH
74490: LD_INT 0
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: PUSH
74497: LD_INT 1
74499: PUSH
74500: LD_INT 1
74502: PUSH
74503: EMPTY
74504: LIST
74505: LIST
74506: PUSH
74507: LD_INT 0
74509: PUSH
74510: LD_INT 1
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 1
74519: NEG
74520: PUSH
74521: LD_INT 0
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 1
74530: NEG
74531: PUSH
74532: LD_INT 1
74534: NEG
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 1
74542: NEG
74543: PUSH
74544: LD_INT 2
74546: NEG
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: PUSH
74552: LD_INT 0
74554: PUSH
74555: LD_INT 2
74557: NEG
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: LD_INT 1
74565: PUSH
74566: LD_INT 1
74568: NEG
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: LD_INT 2
74576: PUSH
74577: LD_INT 1
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 2
74586: PUSH
74587: LD_INT 2
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: PUSH
74594: LD_INT 1
74596: PUSH
74597: LD_INT 2
74599: PUSH
74600: EMPTY
74601: LIST
74602: LIST
74603: PUSH
74604: LD_INT 0
74606: PUSH
74607: LD_INT 2
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: LD_INT 1
74616: NEG
74617: PUSH
74618: LD_INT 1
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 2
74627: NEG
74628: PUSH
74629: LD_INT 1
74631: NEG
74632: PUSH
74633: EMPTY
74634: LIST
74635: LIST
74636: PUSH
74637: LD_INT 2
74639: NEG
74640: PUSH
74641: LD_INT 2
74643: NEG
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PUSH
74649: LD_INT 2
74651: NEG
74652: PUSH
74653: LD_INT 3
74655: NEG
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 1
74663: NEG
74664: PUSH
74665: LD_INT 3
74667: NEG
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: PUSH
74673: LD_INT 0
74675: PUSH
74676: LD_INT 3
74678: NEG
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 1
74686: PUSH
74687: LD_INT 2
74689: NEG
74690: PUSH
74691: EMPTY
74692: LIST
74693: LIST
74694: PUSH
74695: LD_INT 3
74697: PUSH
74698: LD_INT 2
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: PUSH
74705: LD_INT 3
74707: PUSH
74708: LD_INT 3
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 2
74717: PUSH
74718: LD_INT 3
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 1
74727: PUSH
74728: LD_INT 3
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: LD_INT 0
74737: PUSH
74738: LD_INT 3
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: LD_INT 1
74747: NEG
74748: PUSH
74749: LD_INT 2
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 3
74758: NEG
74759: PUSH
74760: LD_INT 2
74762: NEG
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: LD_INT 3
74770: NEG
74771: PUSH
74772: LD_INT 3
74774: NEG
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: LIST
74784: LIST
74785: LIST
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: LIST
74792: LIST
74793: LIST
74794: LIST
74795: LIST
74796: LIST
74797: LIST
74798: LIST
74799: LIST
74800: LIST
74801: LIST
74802: LIST
74803: LIST
74804: LIST
74805: LIST
74806: LIST
74807: LIST
74808: LIST
74809: LIST
74810: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74811: LD_ADDR_VAR 0 43
74815: PUSH
74816: LD_INT 0
74818: PUSH
74819: LD_INT 0
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: PUSH
74826: LD_INT 0
74828: PUSH
74829: LD_INT 1
74831: NEG
74832: PUSH
74833: EMPTY
74834: LIST
74835: LIST
74836: PUSH
74837: LD_INT 1
74839: PUSH
74840: LD_INT 0
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: LD_INT 1
74849: PUSH
74850: LD_INT 1
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: PUSH
74857: LD_INT 0
74859: PUSH
74860: LD_INT 1
74862: PUSH
74863: EMPTY
74864: LIST
74865: LIST
74866: PUSH
74867: LD_INT 1
74869: NEG
74870: PUSH
74871: LD_INT 0
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: LD_INT 1
74880: NEG
74881: PUSH
74882: LD_INT 1
74884: NEG
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: PUSH
74890: LD_INT 1
74892: NEG
74893: PUSH
74894: LD_INT 2
74896: NEG
74897: PUSH
74898: EMPTY
74899: LIST
74900: LIST
74901: PUSH
74902: LD_INT 0
74904: PUSH
74905: LD_INT 2
74907: NEG
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 1
74915: PUSH
74916: LD_INT 1
74918: NEG
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: PUSH
74924: LD_INT 2
74926: PUSH
74927: LD_INT 0
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 2
74936: PUSH
74937: LD_INT 1
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 1
74946: PUSH
74947: LD_INT 2
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 0
74956: PUSH
74957: LD_INT 2
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: LD_INT 1
74966: NEG
74967: PUSH
74968: LD_INT 1
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 2
74977: NEG
74978: PUSH
74979: LD_INT 0
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 2
74988: NEG
74989: PUSH
74990: LD_INT 1
74992: NEG
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: LD_INT 1
75000: NEG
75001: PUSH
75002: LD_INT 3
75004: NEG
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: LD_INT 0
75012: PUSH
75013: LD_INT 3
75015: NEG
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 1
75023: PUSH
75024: LD_INT 2
75026: NEG
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 2
75034: PUSH
75035: LD_INT 1
75037: NEG
75038: PUSH
75039: EMPTY
75040: LIST
75041: LIST
75042: PUSH
75043: LD_INT 3
75045: PUSH
75046: LD_INT 0
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 3
75055: PUSH
75056: LD_INT 1
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: LD_INT 1
75065: PUSH
75066: LD_INT 3
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: LD_INT 0
75075: PUSH
75076: LD_INT 3
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 1
75085: NEG
75086: PUSH
75087: LD_INT 2
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: LD_INT 2
75096: NEG
75097: PUSH
75098: LD_INT 1
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: LD_INT 3
75107: NEG
75108: PUSH
75109: LD_INT 0
75111: PUSH
75112: EMPTY
75113: LIST
75114: LIST
75115: PUSH
75116: LD_INT 3
75118: NEG
75119: PUSH
75120: LD_INT 1
75122: NEG
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: LIST
75134: LIST
75135: LIST
75136: LIST
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: LIST
75142: LIST
75143: LIST
75144: LIST
75145: LIST
75146: LIST
75147: LIST
75148: LIST
75149: LIST
75150: LIST
75151: LIST
75152: LIST
75153: LIST
75154: LIST
75155: LIST
75156: LIST
75157: LIST
75158: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75159: LD_ADDR_VAR 0 44
75163: PUSH
75164: LD_INT 0
75166: PUSH
75167: LD_INT 0
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: PUSH
75174: LD_INT 0
75176: PUSH
75177: LD_INT 1
75179: NEG
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: PUSH
75185: LD_INT 1
75187: PUSH
75188: LD_INT 0
75190: PUSH
75191: EMPTY
75192: LIST
75193: LIST
75194: PUSH
75195: LD_INT 1
75197: PUSH
75198: LD_INT 1
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: LD_INT 0
75207: PUSH
75208: LD_INT 1
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: PUSH
75215: LD_INT 1
75217: NEG
75218: PUSH
75219: LD_INT 0
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PUSH
75226: LD_INT 1
75228: NEG
75229: PUSH
75230: LD_INT 1
75232: NEG
75233: PUSH
75234: EMPTY
75235: LIST
75236: LIST
75237: PUSH
75238: LD_INT 1
75240: NEG
75241: PUSH
75242: LD_INT 2
75244: NEG
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 1
75252: PUSH
75253: LD_INT 1
75255: NEG
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 2
75263: PUSH
75264: LD_INT 0
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: PUSH
75271: LD_INT 2
75273: PUSH
75274: LD_INT 1
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: LD_INT 2
75283: PUSH
75284: LD_INT 2
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 1
75293: PUSH
75294: LD_INT 2
75296: PUSH
75297: EMPTY
75298: LIST
75299: LIST
75300: PUSH
75301: LD_INT 1
75303: NEG
75304: PUSH
75305: LD_INT 1
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 2
75314: NEG
75315: PUSH
75316: LD_INT 0
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 2
75325: NEG
75326: PUSH
75327: LD_INT 1
75329: NEG
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 2
75337: NEG
75338: PUSH
75339: LD_INT 2
75341: NEG
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 2
75349: NEG
75350: PUSH
75351: LD_INT 3
75353: NEG
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 2
75361: PUSH
75362: LD_INT 1
75364: NEG
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: LD_INT 3
75372: PUSH
75373: LD_INT 0
75375: PUSH
75376: EMPTY
75377: LIST
75378: LIST
75379: PUSH
75380: LD_INT 3
75382: PUSH
75383: LD_INT 1
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 3
75392: PUSH
75393: LD_INT 2
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 3
75402: PUSH
75403: LD_INT 3
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 2
75412: PUSH
75413: LD_INT 3
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 2
75422: NEG
75423: PUSH
75424: LD_INT 1
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 3
75433: NEG
75434: PUSH
75435: LD_INT 0
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 3
75444: NEG
75445: PUSH
75446: LD_INT 1
75448: NEG
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 3
75456: NEG
75457: PUSH
75458: LD_INT 2
75460: NEG
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 3
75468: NEG
75469: PUSH
75470: LD_INT 3
75472: NEG
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: LIST
75482: LIST
75483: LIST
75484: LIST
75485: LIST
75486: LIST
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: LIST
75500: LIST
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: LIST
75506: LIST
75507: LIST
75508: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75509: LD_ADDR_VAR 0 45
75513: PUSH
75514: LD_INT 0
75516: PUSH
75517: LD_INT 0
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 0
75526: PUSH
75527: LD_INT 1
75529: NEG
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 1
75537: PUSH
75538: LD_INT 0
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PUSH
75545: LD_INT 1
75547: PUSH
75548: LD_INT 1
75550: PUSH
75551: EMPTY
75552: LIST
75553: LIST
75554: PUSH
75555: LD_INT 0
75557: PUSH
75558: LD_INT 1
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: PUSH
75565: LD_INT 1
75567: NEG
75568: PUSH
75569: LD_INT 0
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: LD_INT 1
75578: NEG
75579: PUSH
75580: LD_INT 1
75582: NEG
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: LD_INT 1
75590: NEG
75591: PUSH
75592: LD_INT 2
75594: NEG
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 0
75602: PUSH
75603: LD_INT 2
75605: NEG
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 1
75613: PUSH
75614: LD_INT 1
75616: NEG
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: LD_INT 2
75624: PUSH
75625: LD_INT 1
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 2
75634: PUSH
75635: LD_INT 2
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PUSH
75642: LD_INT 1
75644: PUSH
75645: LD_INT 2
75647: PUSH
75648: EMPTY
75649: LIST
75650: LIST
75651: PUSH
75652: LD_INT 0
75654: PUSH
75655: LD_INT 2
75657: PUSH
75658: EMPTY
75659: LIST
75660: LIST
75661: PUSH
75662: LD_INT 1
75664: NEG
75665: PUSH
75666: LD_INT 1
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 2
75675: NEG
75676: PUSH
75677: LD_INT 1
75679: NEG
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 2
75687: NEG
75688: PUSH
75689: LD_INT 2
75691: NEG
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 2
75699: NEG
75700: PUSH
75701: LD_INT 3
75703: NEG
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 1
75711: NEG
75712: PUSH
75713: LD_INT 3
75715: NEG
75716: PUSH
75717: EMPTY
75718: LIST
75719: LIST
75720: PUSH
75721: LD_INT 0
75723: PUSH
75724: LD_INT 3
75726: NEG
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 1
75734: PUSH
75735: LD_INT 2
75737: NEG
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: PUSH
75743: LD_INT 3
75745: PUSH
75746: LD_INT 2
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: LD_INT 3
75755: PUSH
75756: LD_INT 3
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 2
75765: PUSH
75766: LD_INT 3
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PUSH
75773: LD_INT 1
75775: PUSH
75776: LD_INT 3
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 0
75785: PUSH
75786: LD_INT 3
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: PUSH
75793: LD_INT 1
75795: NEG
75796: PUSH
75797: LD_INT 2
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: LD_INT 3
75806: NEG
75807: PUSH
75808: LD_INT 2
75810: NEG
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: PUSH
75816: LD_INT 3
75818: NEG
75819: PUSH
75820: LD_INT 3
75822: NEG
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: LIST
75832: LIST
75833: LIST
75834: LIST
75835: LIST
75836: LIST
75837: LIST
75838: LIST
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: LIST
75848: LIST
75849: LIST
75850: LIST
75851: LIST
75852: LIST
75853: LIST
75854: LIST
75855: LIST
75856: LIST
75857: LIST
75858: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75859: LD_ADDR_VAR 0 46
75863: PUSH
75864: LD_INT 0
75866: PUSH
75867: LD_INT 0
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 0
75876: PUSH
75877: LD_INT 1
75879: NEG
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PUSH
75885: LD_INT 1
75887: PUSH
75888: LD_INT 0
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: PUSH
75895: LD_INT 1
75897: PUSH
75898: LD_INT 1
75900: PUSH
75901: EMPTY
75902: LIST
75903: LIST
75904: PUSH
75905: LD_INT 0
75907: PUSH
75908: LD_INT 1
75910: PUSH
75911: EMPTY
75912: LIST
75913: LIST
75914: PUSH
75915: LD_INT 1
75917: NEG
75918: PUSH
75919: LD_INT 0
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: PUSH
75926: LD_INT 1
75928: NEG
75929: PUSH
75930: LD_INT 1
75932: NEG
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 1
75940: NEG
75941: PUSH
75942: LD_INT 2
75944: NEG
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: PUSH
75950: LD_INT 0
75952: PUSH
75953: LD_INT 2
75955: NEG
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: LD_INT 1
75963: PUSH
75964: LD_INT 1
75966: NEG
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: LD_INT 2
75974: PUSH
75975: LD_INT 0
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: PUSH
75982: LD_INT 2
75984: PUSH
75985: LD_INT 1
75987: PUSH
75988: EMPTY
75989: LIST
75990: LIST
75991: PUSH
75992: LD_INT 1
75994: PUSH
75995: LD_INT 2
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: LD_INT 0
76004: PUSH
76005: LD_INT 2
76007: PUSH
76008: EMPTY
76009: LIST
76010: LIST
76011: PUSH
76012: LD_INT 1
76014: NEG
76015: PUSH
76016: LD_INT 1
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 2
76025: NEG
76026: PUSH
76027: LD_INT 0
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: LD_INT 2
76036: NEG
76037: PUSH
76038: LD_INT 1
76040: NEG
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: PUSH
76046: LD_INT 1
76048: NEG
76049: PUSH
76050: LD_INT 3
76052: NEG
76053: PUSH
76054: EMPTY
76055: LIST
76056: LIST
76057: PUSH
76058: LD_INT 0
76060: PUSH
76061: LD_INT 3
76063: NEG
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: PUSH
76069: LD_INT 1
76071: PUSH
76072: LD_INT 2
76074: NEG
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PUSH
76080: LD_INT 2
76082: PUSH
76083: LD_INT 1
76085: NEG
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: PUSH
76091: LD_INT 3
76093: PUSH
76094: LD_INT 0
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 3
76103: PUSH
76104: LD_INT 1
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: LD_INT 1
76113: PUSH
76114: LD_INT 3
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: LD_INT 0
76123: PUSH
76124: LD_INT 3
76126: PUSH
76127: EMPTY
76128: LIST
76129: LIST
76130: PUSH
76131: LD_INT 1
76133: NEG
76134: PUSH
76135: LD_INT 2
76137: PUSH
76138: EMPTY
76139: LIST
76140: LIST
76141: PUSH
76142: LD_INT 2
76144: NEG
76145: PUSH
76146: LD_INT 1
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 3
76155: NEG
76156: PUSH
76157: LD_INT 0
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 3
76166: NEG
76167: PUSH
76168: LD_INT 1
76170: NEG
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: LIST
76180: LIST
76181: LIST
76182: LIST
76183: LIST
76184: LIST
76185: LIST
76186: LIST
76187: LIST
76188: LIST
76189: LIST
76190: LIST
76191: LIST
76192: LIST
76193: LIST
76194: LIST
76195: LIST
76196: LIST
76197: LIST
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76207: LD_ADDR_VAR 0 47
76211: PUSH
76212: LD_INT 0
76214: PUSH
76215: LD_INT 0
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: PUSH
76222: LD_INT 0
76224: PUSH
76225: LD_INT 1
76227: NEG
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PUSH
76233: LD_INT 1
76235: PUSH
76236: LD_INT 0
76238: PUSH
76239: EMPTY
76240: LIST
76241: LIST
76242: PUSH
76243: LD_INT 1
76245: PUSH
76246: LD_INT 1
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: LD_INT 0
76255: PUSH
76256: LD_INT 1
76258: PUSH
76259: EMPTY
76260: LIST
76261: LIST
76262: PUSH
76263: LD_INT 1
76265: NEG
76266: PUSH
76267: LD_INT 0
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 1
76276: NEG
76277: PUSH
76278: LD_INT 1
76280: NEG
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: LD_INT 1
76288: NEG
76289: PUSH
76290: LD_INT 2
76292: NEG
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: LD_INT 0
76300: PUSH
76301: LD_INT 2
76303: NEG
76304: PUSH
76305: EMPTY
76306: LIST
76307: LIST
76308: PUSH
76309: LD_INT 1
76311: PUSH
76312: LD_INT 1
76314: NEG
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PUSH
76320: LD_INT 2
76322: NEG
76323: PUSH
76324: LD_INT 1
76326: NEG
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: PUSH
76332: LD_INT 2
76334: NEG
76335: PUSH
76336: LD_INT 2
76338: NEG
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: LIST
76348: LIST
76349: LIST
76350: LIST
76351: LIST
76352: LIST
76353: LIST
76354: LIST
76355: LIST
76356: LIST
76357: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76358: LD_ADDR_VAR 0 48
76362: PUSH
76363: LD_INT 0
76365: PUSH
76366: LD_INT 0
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 0
76375: PUSH
76376: LD_INT 1
76378: NEG
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: LD_INT 1
76386: PUSH
76387: LD_INT 0
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: PUSH
76394: LD_INT 1
76396: PUSH
76397: LD_INT 1
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 0
76406: PUSH
76407: LD_INT 1
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: LD_INT 1
76416: NEG
76417: PUSH
76418: LD_INT 0
76420: PUSH
76421: EMPTY
76422: LIST
76423: LIST
76424: PUSH
76425: LD_INT 1
76427: NEG
76428: PUSH
76429: LD_INT 1
76431: NEG
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 1
76439: NEG
76440: PUSH
76441: LD_INT 2
76443: NEG
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 0
76451: PUSH
76452: LD_INT 2
76454: NEG
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 1
76462: PUSH
76463: LD_INT 1
76465: NEG
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 2
76473: PUSH
76474: LD_INT 0
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: PUSH
76481: LD_INT 2
76483: PUSH
76484: LD_INT 1
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: PUSH
76491: EMPTY
76492: LIST
76493: LIST
76494: LIST
76495: LIST
76496: LIST
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: LIST
76502: LIST
76503: LIST
76504: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76505: LD_ADDR_VAR 0 49
76509: PUSH
76510: LD_INT 0
76512: PUSH
76513: LD_INT 0
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 0
76522: PUSH
76523: LD_INT 1
76525: NEG
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PUSH
76531: LD_INT 1
76533: PUSH
76534: LD_INT 0
76536: PUSH
76537: EMPTY
76538: LIST
76539: LIST
76540: PUSH
76541: LD_INT 1
76543: PUSH
76544: LD_INT 1
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: LD_INT 0
76553: PUSH
76554: LD_INT 1
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: PUSH
76561: LD_INT 1
76563: NEG
76564: PUSH
76565: LD_INT 0
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 1
76574: NEG
76575: PUSH
76576: LD_INT 1
76578: NEG
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: PUSH
76584: LD_INT 1
76586: PUSH
76587: LD_INT 1
76589: NEG
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PUSH
76595: LD_INT 2
76597: PUSH
76598: LD_INT 0
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: PUSH
76605: LD_INT 2
76607: PUSH
76608: LD_INT 1
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: PUSH
76615: LD_INT 2
76617: PUSH
76618: LD_INT 2
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 1
76627: PUSH
76628: LD_INT 2
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: LIST
76639: LIST
76640: LIST
76641: LIST
76642: LIST
76643: LIST
76644: LIST
76645: LIST
76646: LIST
76647: LIST
76648: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76649: LD_ADDR_VAR 0 50
76653: PUSH
76654: LD_INT 0
76656: PUSH
76657: LD_INT 0
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PUSH
76664: LD_INT 0
76666: PUSH
76667: LD_INT 1
76669: NEG
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: PUSH
76675: LD_INT 1
76677: PUSH
76678: LD_INT 0
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PUSH
76685: LD_INT 1
76687: PUSH
76688: LD_INT 1
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PUSH
76695: LD_INT 0
76697: PUSH
76698: LD_INT 1
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 1
76707: NEG
76708: PUSH
76709: LD_INT 0
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: PUSH
76716: LD_INT 1
76718: NEG
76719: PUSH
76720: LD_INT 1
76722: NEG
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 2
76730: PUSH
76731: LD_INT 1
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: PUSH
76738: LD_INT 2
76740: PUSH
76741: LD_INT 2
76743: PUSH
76744: EMPTY
76745: LIST
76746: LIST
76747: PUSH
76748: LD_INT 1
76750: PUSH
76751: LD_INT 2
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 0
76760: PUSH
76761: LD_INT 2
76763: PUSH
76764: EMPTY
76765: LIST
76766: LIST
76767: PUSH
76768: LD_INT 1
76770: NEG
76771: PUSH
76772: LD_INT 1
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: LIST
76783: LIST
76784: LIST
76785: LIST
76786: LIST
76787: LIST
76788: LIST
76789: LIST
76790: LIST
76791: LIST
76792: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76793: LD_ADDR_VAR 0 51
76797: PUSH
76798: LD_INT 0
76800: PUSH
76801: LD_INT 0
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 0
76810: PUSH
76811: LD_INT 1
76813: NEG
76814: PUSH
76815: EMPTY
76816: LIST
76817: LIST
76818: PUSH
76819: LD_INT 1
76821: PUSH
76822: LD_INT 0
76824: PUSH
76825: EMPTY
76826: LIST
76827: LIST
76828: PUSH
76829: LD_INT 1
76831: PUSH
76832: LD_INT 1
76834: PUSH
76835: EMPTY
76836: LIST
76837: LIST
76838: PUSH
76839: LD_INT 0
76841: PUSH
76842: LD_INT 1
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 1
76851: NEG
76852: PUSH
76853: LD_INT 0
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: LD_INT 1
76862: NEG
76863: PUSH
76864: LD_INT 1
76866: NEG
76867: PUSH
76868: EMPTY
76869: LIST
76870: LIST
76871: PUSH
76872: LD_INT 1
76874: PUSH
76875: LD_INT 2
76877: PUSH
76878: EMPTY
76879: LIST
76880: LIST
76881: PUSH
76882: LD_INT 0
76884: PUSH
76885: LD_INT 2
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 1
76894: NEG
76895: PUSH
76896: LD_INT 1
76898: PUSH
76899: EMPTY
76900: LIST
76901: LIST
76902: PUSH
76903: LD_INT 2
76905: NEG
76906: PUSH
76907: LD_INT 0
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 2
76916: NEG
76917: PUSH
76918: LD_INT 1
76920: NEG
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: LIST
76930: LIST
76931: LIST
76932: LIST
76933: LIST
76934: LIST
76935: LIST
76936: LIST
76937: LIST
76938: LIST
76939: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76940: LD_ADDR_VAR 0 52
76944: PUSH
76945: LD_INT 0
76947: PUSH
76948: LD_INT 0
76950: PUSH
76951: EMPTY
76952: LIST
76953: LIST
76954: PUSH
76955: LD_INT 0
76957: PUSH
76958: LD_INT 1
76960: NEG
76961: PUSH
76962: EMPTY
76963: LIST
76964: LIST
76965: PUSH
76966: LD_INT 1
76968: PUSH
76969: LD_INT 0
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: LD_INT 1
76978: PUSH
76979: LD_INT 1
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: PUSH
76986: LD_INT 0
76988: PUSH
76989: LD_INT 1
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PUSH
76996: LD_INT 1
76998: NEG
76999: PUSH
77000: LD_INT 0
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: PUSH
77007: LD_INT 1
77009: NEG
77010: PUSH
77011: LD_INT 1
77013: NEG
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 1
77021: NEG
77022: PUSH
77023: LD_INT 2
77025: NEG
77026: PUSH
77027: EMPTY
77028: LIST
77029: LIST
77030: PUSH
77031: LD_INT 1
77033: NEG
77034: PUSH
77035: LD_INT 1
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: PUSH
77042: LD_INT 2
77044: NEG
77045: PUSH
77046: LD_INT 0
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: LD_INT 2
77055: NEG
77056: PUSH
77057: LD_INT 1
77059: NEG
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: LD_INT 2
77067: NEG
77068: PUSH
77069: LD_INT 2
77071: NEG
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: LIST
77081: LIST
77082: LIST
77083: LIST
77084: LIST
77085: LIST
77086: LIST
77087: LIST
77088: LIST
77089: LIST
77090: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77091: LD_ADDR_VAR 0 53
77095: PUSH
77096: LD_INT 0
77098: PUSH
77099: LD_INT 0
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 0
77108: PUSH
77109: LD_INT 1
77111: NEG
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 1
77119: PUSH
77120: LD_INT 0
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 1
77129: PUSH
77130: LD_INT 1
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 0
77139: PUSH
77140: LD_INT 1
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: PUSH
77147: LD_INT 1
77149: NEG
77150: PUSH
77151: LD_INT 0
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: LD_INT 1
77160: NEG
77161: PUSH
77162: LD_INT 1
77164: NEG
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: PUSH
77170: LD_INT 1
77172: NEG
77173: PUSH
77174: LD_INT 2
77176: NEG
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: LD_INT 0
77184: PUSH
77185: LD_INT 2
77187: NEG
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: PUSH
77193: LD_INT 1
77195: PUSH
77196: LD_INT 1
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 2
77206: PUSH
77207: LD_INT 0
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: LD_INT 2
77216: PUSH
77217: LD_INT 1
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PUSH
77224: LD_INT 2
77226: PUSH
77227: LD_INT 2
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 1
77236: PUSH
77237: LD_INT 2
77239: PUSH
77240: EMPTY
77241: LIST
77242: LIST
77243: PUSH
77244: LD_INT 0
77246: PUSH
77247: LD_INT 2
77249: PUSH
77250: EMPTY
77251: LIST
77252: LIST
77253: PUSH
77254: LD_INT 1
77256: NEG
77257: PUSH
77258: LD_INT 1
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 2
77267: NEG
77268: PUSH
77269: LD_INT 0
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 2
77278: NEG
77279: PUSH
77280: LD_INT 1
77282: NEG
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: LD_INT 2
77290: NEG
77291: PUSH
77292: LD_INT 2
77294: NEG
77295: PUSH
77296: EMPTY
77297: LIST
77298: LIST
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: LIST
77304: LIST
77305: LIST
77306: LIST
77307: LIST
77308: LIST
77309: LIST
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: LIST
77319: LIST
77320: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77321: LD_ADDR_VAR 0 54
77325: PUSH
77326: LD_INT 0
77328: PUSH
77329: LD_INT 0
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: LD_INT 0
77338: PUSH
77339: LD_INT 1
77341: NEG
77342: PUSH
77343: EMPTY
77344: LIST
77345: LIST
77346: PUSH
77347: LD_INT 1
77349: PUSH
77350: LD_INT 0
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: LD_INT 1
77359: PUSH
77360: LD_INT 1
77362: PUSH
77363: EMPTY
77364: LIST
77365: LIST
77366: PUSH
77367: LD_INT 0
77369: PUSH
77370: LD_INT 1
77372: PUSH
77373: EMPTY
77374: LIST
77375: LIST
77376: PUSH
77377: LD_INT 1
77379: NEG
77380: PUSH
77381: LD_INT 0
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: PUSH
77388: LD_INT 1
77390: NEG
77391: PUSH
77392: LD_INT 1
77394: NEG
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: PUSH
77400: LD_INT 1
77402: NEG
77403: PUSH
77404: LD_INT 2
77406: NEG
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 0
77414: PUSH
77415: LD_INT 2
77417: NEG
77418: PUSH
77419: EMPTY
77420: LIST
77421: LIST
77422: PUSH
77423: LD_INT 1
77425: PUSH
77426: LD_INT 1
77428: NEG
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: PUSH
77434: LD_INT 2
77436: PUSH
77437: LD_INT 0
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: LD_INT 2
77446: PUSH
77447: LD_INT 1
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: PUSH
77454: LD_INT 2
77456: PUSH
77457: LD_INT 2
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: LD_INT 1
77466: PUSH
77467: LD_INT 2
77469: PUSH
77470: EMPTY
77471: LIST
77472: LIST
77473: PUSH
77474: LD_INT 0
77476: PUSH
77477: LD_INT 2
77479: PUSH
77480: EMPTY
77481: LIST
77482: LIST
77483: PUSH
77484: LD_INT 1
77486: NEG
77487: PUSH
77488: LD_INT 1
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 2
77497: NEG
77498: PUSH
77499: LD_INT 0
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: LD_INT 2
77508: NEG
77509: PUSH
77510: LD_INT 1
77512: NEG
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: LD_INT 2
77520: NEG
77521: PUSH
77522: LD_INT 2
77524: NEG
77525: PUSH
77526: EMPTY
77527: LIST
77528: LIST
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: LIST
77534: LIST
77535: LIST
77536: LIST
77537: LIST
77538: LIST
77539: LIST
77540: LIST
77541: LIST
77542: LIST
77543: LIST
77544: LIST
77545: LIST
77546: LIST
77547: LIST
77548: LIST
77549: LIST
77550: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77551: LD_ADDR_VAR 0 55
77555: PUSH
77556: LD_INT 0
77558: PUSH
77559: LD_INT 0
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: PUSH
77566: LD_INT 0
77568: PUSH
77569: LD_INT 1
77571: NEG
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: PUSH
77577: LD_INT 1
77579: PUSH
77580: LD_INT 0
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 1
77589: PUSH
77590: LD_INT 1
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: PUSH
77597: LD_INT 0
77599: PUSH
77600: LD_INT 1
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 1
77609: NEG
77610: PUSH
77611: LD_INT 0
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: LD_INT 1
77620: NEG
77621: PUSH
77622: LD_INT 1
77624: NEG
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PUSH
77630: LD_INT 1
77632: NEG
77633: PUSH
77634: LD_INT 2
77636: NEG
77637: PUSH
77638: EMPTY
77639: LIST
77640: LIST
77641: PUSH
77642: LD_INT 0
77644: PUSH
77645: LD_INT 2
77647: NEG
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: PUSH
77653: LD_INT 1
77655: PUSH
77656: LD_INT 1
77658: NEG
77659: PUSH
77660: EMPTY
77661: LIST
77662: LIST
77663: PUSH
77664: LD_INT 2
77666: PUSH
77667: LD_INT 0
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: PUSH
77674: LD_INT 2
77676: PUSH
77677: LD_INT 1
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PUSH
77684: LD_INT 2
77686: PUSH
77687: LD_INT 2
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PUSH
77694: LD_INT 1
77696: PUSH
77697: LD_INT 2
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: PUSH
77704: LD_INT 0
77706: PUSH
77707: LD_INT 2
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: PUSH
77714: LD_INT 1
77716: NEG
77717: PUSH
77718: LD_INT 1
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: PUSH
77725: LD_INT 2
77727: NEG
77728: PUSH
77729: LD_INT 0
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: PUSH
77736: LD_INT 2
77738: NEG
77739: PUSH
77740: LD_INT 1
77742: NEG
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: PUSH
77748: LD_INT 2
77750: NEG
77751: PUSH
77752: LD_INT 2
77754: NEG
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: LIST
77764: LIST
77765: LIST
77766: LIST
77767: LIST
77768: LIST
77769: LIST
77770: LIST
77771: LIST
77772: LIST
77773: LIST
77774: LIST
77775: LIST
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77781: LD_ADDR_VAR 0 56
77785: PUSH
77786: LD_INT 0
77788: PUSH
77789: LD_INT 0
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: PUSH
77796: LD_INT 0
77798: PUSH
77799: LD_INT 1
77801: NEG
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 1
77809: PUSH
77810: LD_INT 0
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 1
77819: PUSH
77820: LD_INT 1
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PUSH
77827: LD_INT 0
77829: PUSH
77830: LD_INT 1
77832: PUSH
77833: EMPTY
77834: LIST
77835: LIST
77836: PUSH
77837: LD_INT 1
77839: NEG
77840: PUSH
77841: LD_INT 0
77843: PUSH
77844: EMPTY
77845: LIST
77846: LIST
77847: PUSH
77848: LD_INT 1
77850: NEG
77851: PUSH
77852: LD_INT 1
77854: NEG
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PUSH
77860: LD_INT 1
77862: NEG
77863: PUSH
77864: LD_INT 2
77866: NEG
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: PUSH
77872: LD_INT 0
77874: PUSH
77875: LD_INT 2
77877: NEG
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 1
77885: PUSH
77886: LD_INT 1
77888: NEG
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 2
77896: PUSH
77897: LD_INT 0
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PUSH
77904: LD_INT 2
77906: PUSH
77907: LD_INT 1
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: PUSH
77914: LD_INT 2
77916: PUSH
77917: LD_INT 2
77919: PUSH
77920: EMPTY
77921: LIST
77922: LIST
77923: PUSH
77924: LD_INT 1
77926: PUSH
77927: LD_INT 2
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: PUSH
77934: LD_INT 0
77936: PUSH
77937: LD_INT 2
77939: PUSH
77940: EMPTY
77941: LIST
77942: LIST
77943: PUSH
77944: LD_INT 1
77946: NEG
77947: PUSH
77948: LD_INT 1
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: PUSH
77955: LD_INT 2
77957: NEG
77958: PUSH
77959: LD_INT 0
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: PUSH
77966: LD_INT 2
77968: NEG
77969: PUSH
77970: LD_INT 1
77972: NEG
77973: PUSH
77974: EMPTY
77975: LIST
77976: LIST
77977: PUSH
77978: LD_INT 2
77980: NEG
77981: PUSH
77982: LD_INT 2
77984: NEG
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78011: LD_ADDR_VAR 0 57
78015: PUSH
78016: LD_INT 0
78018: PUSH
78019: LD_INT 0
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 0
78028: PUSH
78029: LD_INT 1
78031: NEG
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: PUSH
78037: LD_INT 1
78039: PUSH
78040: LD_INT 0
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 1
78049: PUSH
78050: LD_INT 1
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 0
78059: PUSH
78060: LD_INT 1
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 1
78069: NEG
78070: PUSH
78071: LD_INT 0
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 1
78080: NEG
78081: PUSH
78082: LD_INT 1
78084: NEG
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 1
78092: NEG
78093: PUSH
78094: LD_INT 2
78096: NEG
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: LD_INT 0
78104: PUSH
78105: LD_INT 2
78107: NEG
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 1
78115: PUSH
78116: LD_INT 1
78118: NEG
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 2
78126: PUSH
78127: LD_INT 0
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 2
78136: PUSH
78137: LD_INT 1
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 2
78146: PUSH
78147: LD_INT 2
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 1
78156: PUSH
78157: LD_INT 2
78159: PUSH
78160: EMPTY
78161: LIST
78162: LIST
78163: PUSH
78164: LD_INT 0
78166: PUSH
78167: LD_INT 2
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: LD_INT 1
78176: NEG
78177: PUSH
78178: LD_INT 1
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: LD_INT 2
78187: NEG
78188: PUSH
78189: LD_INT 0
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: LD_INT 2
78198: NEG
78199: PUSH
78200: LD_INT 1
78202: NEG
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: PUSH
78208: LD_INT 2
78210: NEG
78211: PUSH
78212: LD_INT 2
78214: NEG
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78241: LD_ADDR_VAR 0 58
78245: PUSH
78246: LD_INT 0
78248: PUSH
78249: LD_INT 0
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 0
78258: PUSH
78259: LD_INT 1
78261: NEG
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: PUSH
78267: LD_INT 1
78269: PUSH
78270: LD_INT 0
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: PUSH
78277: LD_INT 1
78279: PUSH
78280: LD_INT 1
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: PUSH
78287: LD_INT 0
78289: PUSH
78290: LD_INT 1
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 1
78299: NEG
78300: PUSH
78301: LD_INT 0
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: LD_INT 1
78310: NEG
78311: PUSH
78312: LD_INT 1
78314: NEG
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: PUSH
78320: LD_INT 1
78322: NEG
78323: PUSH
78324: LD_INT 2
78326: NEG
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 0
78334: PUSH
78335: LD_INT 2
78337: NEG
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: LD_INT 1
78345: PUSH
78346: LD_INT 1
78348: NEG
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: LD_INT 2
78356: PUSH
78357: LD_INT 0
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: LD_INT 2
78366: PUSH
78367: LD_INT 1
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 2
78376: PUSH
78377: LD_INT 2
78379: PUSH
78380: EMPTY
78381: LIST
78382: LIST
78383: PUSH
78384: LD_INT 1
78386: PUSH
78387: LD_INT 2
78389: PUSH
78390: EMPTY
78391: LIST
78392: LIST
78393: PUSH
78394: LD_INT 0
78396: PUSH
78397: LD_INT 2
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 1
78406: NEG
78407: PUSH
78408: LD_INT 1
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: LD_INT 2
78417: NEG
78418: PUSH
78419: LD_INT 0
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 2
78428: NEG
78429: PUSH
78430: LD_INT 1
78432: NEG
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 2
78440: NEG
78441: PUSH
78442: LD_INT 2
78444: NEG
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: LIST
78458: LIST
78459: LIST
78460: LIST
78461: LIST
78462: LIST
78463: LIST
78464: LIST
78465: LIST
78466: LIST
78467: LIST
78468: LIST
78469: LIST
78470: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78471: LD_ADDR_VAR 0 59
78475: PUSH
78476: LD_INT 0
78478: PUSH
78479: LD_INT 0
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 0
78488: PUSH
78489: LD_INT 1
78491: NEG
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 1
78499: PUSH
78500: LD_INT 0
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: LD_INT 1
78509: PUSH
78510: LD_INT 1
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 0
78519: PUSH
78520: LD_INT 1
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 1
78529: NEG
78530: PUSH
78531: LD_INT 0
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: PUSH
78538: LD_INT 1
78540: NEG
78541: PUSH
78542: LD_INT 1
78544: NEG
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78559: LD_ADDR_VAR 0 60
78563: PUSH
78564: LD_INT 0
78566: PUSH
78567: LD_INT 0
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 0
78576: PUSH
78577: LD_INT 1
78579: NEG
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 1
78587: PUSH
78588: LD_INT 0
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 1
78597: PUSH
78598: LD_INT 1
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: LD_INT 0
78607: PUSH
78608: LD_INT 1
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_INT 1
78617: NEG
78618: PUSH
78619: LD_INT 0
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 1
78628: NEG
78629: PUSH
78630: LD_INT 1
78632: NEG
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: LIST
78642: LIST
78643: LIST
78644: LIST
78645: LIST
78646: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78647: LD_ADDR_VAR 0 61
78651: PUSH
78652: LD_INT 0
78654: PUSH
78655: LD_INT 0
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: PUSH
78662: LD_INT 0
78664: PUSH
78665: LD_INT 1
78667: NEG
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 1
78675: PUSH
78676: LD_INT 0
78678: PUSH
78679: EMPTY
78680: LIST
78681: LIST
78682: PUSH
78683: LD_INT 1
78685: PUSH
78686: LD_INT 1
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: PUSH
78693: LD_INT 0
78695: PUSH
78696: LD_INT 1
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 1
78705: NEG
78706: PUSH
78707: LD_INT 0
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 1
78716: NEG
78717: PUSH
78718: LD_INT 1
78720: NEG
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: LIST
78730: LIST
78731: LIST
78732: LIST
78733: LIST
78734: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78735: LD_ADDR_VAR 0 62
78739: PUSH
78740: LD_INT 0
78742: PUSH
78743: LD_INT 0
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 0
78752: PUSH
78753: LD_INT 1
78755: NEG
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 1
78763: PUSH
78764: LD_INT 0
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: LD_INT 1
78773: PUSH
78774: LD_INT 1
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: PUSH
78781: LD_INT 0
78783: PUSH
78784: LD_INT 1
78786: PUSH
78787: EMPTY
78788: LIST
78789: LIST
78790: PUSH
78791: LD_INT 1
78793: NEG
78794: PUSH
78795: LD_INT 0
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: PUSH
78802: LD_INT 1
78804: NEG
78805: PUSH
78806: LD_INT 1
78808: NEG
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: LIST
78822: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78823: LD_ADDR_VAR 0 63
78827: PUSH
78828: LD_INT 0
78830: PUSH
78831: LD_INT 0
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 0
78840: PUSH
78841: LD_INT 1
78843: NEG
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PUSH
78849: LD_INT 1
78851: PUSH
78852: LD_INT 0
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 1
78861: PUSH
78862: LD_INT 1
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 0
78871: PUSH
78872: LD_INT 1
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 1
78881: NEG
78882: PUSH
78883: LD_INT 0
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 1
78892: NEG
78893: PUSH
78894: LD_INT 1
78896: NEG
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: LIST
78906: LIST
78907: LIST
78908: LIST
78909: LIST
78910: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78911: LD_ADDR_VAR 0 64
78915: PUSH
78916: LD_INT 0
78918: PUSH
78919: LD_INT 0
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 0
78928: PUSH
78929: LD_INT 1
78931: NEG
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 1
78939: PUSH
78940: LD_INT 0
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 1
78949: PUSH
78950: LD_INT 1
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PUSH
78957: LD_INT 0
78959: PUSH
78960: LD_INT 1
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: PUSH
78967: LD_INT 1
78969: NEG
78970: PUSH
78971: LD_INT 0
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: PUSH
78978: LD_INT 1
78980: NEG
78981: PUSH
78982: LD_INT 1
78984: NEG
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: ST_TO_ADDR
// end ; 1 :
78999: GO 84896
79001: LD_INT 1
79003: DOUBLE
79004: EQUAL
79005: IFTRUE 79009
79007: GO 81632
79009: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79010: LD_ADDR_VAR 0 11
79014: PUSH
79015: LD_INT 1
79017: NEG
79018: PUSH
79019: LD_INT 3
79021: NEG
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 0
79029: PUSH
79030: LD_INT 3
79032: NEG
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 1
79040: PUSH
79041: LD_INT 2
79043: NEG
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: LIST
79053: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79054: LD_ADDR_VAR 0 12
79058: PUSH
79059: LD_INT 2
79061: PUSH
79062: LD_INT 1
79064: NEG
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: LD_INT 3
79072: PUSH
79073: LD_INT 0
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: PUSH
79080: LD_INT 3
79082: PUSH
79083: LD_INT 1
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: LIST
79094: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79095: LD_ADDR_VAR 0 13
79099: PUSH
79100: LD_INT 3
79102: PUSH
79103: LD_INT 2
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: PUSH
79110: LD_INT 3
79112: PUSH
79113: LD_INT 3
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 2
79122: PUSH
79123: LD_INT 3
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: LIST
79134: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79135: LD_ADDR_VAR 0 14
79139: PUSH
79140: LD_INT 1
79142: PUSH
79143: LD_INT 3
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: LD_INT 0
79152: PUSH
79153: LD_INT 3
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 1
79162: NEG
79163: PUSH
79164: LD_INT 2
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: LIST
79175: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79176: LD_ADDR_VAR 0 15
79180: PUSH
79181: LD_INT 2
79183: NEG
79184: PUSH
79185: LD_INT 1
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: LD_INT 3
79194: NEG
79195: PUSH
79196: LD_INT 0
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 3
79205: NEG
79206: PUSH
79207: LD_INT 1
79209: NEG
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: EMPTY
79216: LIST
79217: LIST
79218: LIST
79219: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79220: LD_ADDR_VAR 0 16
79224: PUSH
79225: LD_INT 2
79227: NEG
79228: PUSH
79229: LD_INT 3
79231: NEG
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 3
79239: NEG
79240: PUSH
79241: LD_INT 2
79243: NEG
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: LD_INT 3
79251: NEG
79252: PUSH
79253: LD_INT 3
79255: NEG
79256: PUSH
79257: EMPTY
79258: LIST
79259: LIST
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: LIST
79265: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79266: LD_ADDR_VAR 0 17
79270: PUSH
79271: LD_INT 1
79273: NEG
79274: PUSH
79275: LD_INT 3
79277: NEG
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 0
79285: PUSH
79286: LD_INT 3
79288: NEG
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 1
79296: PUSH
79297: LD_INT 2
79299: NEG
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: LIST
79309: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79310: LD_ADDR_VAR 0 18
79314: PUSH
79315: LD_INT 2
79317: PUSH
79318: LD_INT 1
79320: NEG
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: LD_INT 3
79328: PUSH
79329: LD_INT 0
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 3
79338: PUSH
79339: LD_INT 1
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: LIST
79350: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79351: LD_ADDR_VAR 0 19
79355: PUSH
79356: LD_INT 3
79358: PUSH
79359: LD_INT 2
79361: PUSH
79362: EMPTY
79363: LIST
79364: LIST
79365: PUSH
79366: LD_INT 3
79368: PUSH
79369: LD_INT 3
79371: PUSH
79372: EMPTY
79373: LIST
79374: LIST
79375: PUSH
79376: LD_INT 2
79378: PUSH
79379: LD_INT 3
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: LIST
79390: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79391: LD_ADDR_VAR 0 20
79395: PUSH
79396: LD_INT 1
79398: PUSH
79399: LD_INT 3
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 0
79408: PUSH
79409: LD_INT 3
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 1
79418: NEG
79419: PUSH
79420: LD_INT 2
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: LIST
79431: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79432: LD_ADDR_VAR 0 21
79436: PUSH
79437: LD_INT 2
79439: NEG
79440: PUSH
79441: LD_INT 1
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 3
79450: NEG
79451: PUSH
79452: LD_INT 0
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 3
79461: NEG
79462: PUSH
79463: LD_INT 1
79465: NEG
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: LIST
79475: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79476: LD_ADDR_VAR 0 22
79480: PUSH
79481: LD_INT 2
79483: NEG
79484: PUSH
79485: LD_INT 3
79487: NEG
79488: PUSH
79489: EMPTY
79490: LIST
79491: LIST
79492: PUSH
79493: LD_INT 3
79495: NEG
79496: PUSH
79497: LD_INT 2
79499: NEG
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: LD_INT 3
79507: NEG
79508: PUSH
79509: LD_INT 3
79511: NEG
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: LIST
79521: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
79522: LD_ADDR_VAR 0 23
79526: PUSH
79527: LD_INT 0
79529: PUSH
79530: LD_INT 3
79532: NEG
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 1
79540: NEG
79541: PUSH
79542: LD_INT 4
79544: NEG
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 1
79552: PUSH
79553: LD_INT 3
79555: NEG
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: LIST
79565: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
79566: LD_ADDR_VAR 0 24
79570: PUSH
79571: LD_INT 3
79573: PUSH
79574: LD_INT 0
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: LD_INT 3
79583: PUSH
79584: LD_INT 1
79586: NEG
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: LD_INT 4
79594: PUSH
79595: LD_INT 1
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: LIST
79606: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
79607: LD_ADDR_VAR 0 25
79611: PUSH
79612: LD_INT 3
79614: PUSH
79615: LD_INT 3
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: LD_INT 4
79624: PUSH
79625: LD_INT 3
79627: PUSH
79628: EMPTY
79629: LIST
79630: LIST
79631: PUSH
79632: LD_INT 3
79634: PUSH
79635: LD_INT 4
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: LIST
79646: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
79647: LD_ADDR_VAR 0 26
79651: PUSH
79652: LD_INT 0
79654: PUSH
79655: LD_INT 3
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 1
79664: PUSH
79665: LD_INT 4
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 1
79674: NEG
79675: PUSH
79676: LD_INT 3
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: LIST
79687: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
79688: LD_ADDR_VAR 0 27
79692: PUSH
79693: LD_INT 3
79695: NEG
79696: PUSH
79697: LD_INT 0
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 3
79706: NEG
79707: PUSH
79708: LD_INT 1
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: PUSH
79715: LD_INT 4
79717: NEG
79718: PUSH
79719: LD_INT 1
79721: NEG
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: LIST
79731: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
79732: LD_ADDR_VAR 0 28
79736: PUSH
79737: LD_INT 3
79739: NEG
79740: PUSH
79741: LD_INT 3
79743: NEG
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 3
79751: NEG
79752: PUSH
79753: LD_INT 4
79755: NEG
79756: PUSH
79757: EMPTY
79758: LIST
79759: LIST
79760: PUSH
79761: LD_INT 4
79763: NEG
79764: PUSH
79765: LD_INT 3
79767: NEG
79768: PUSH
79769: EMPTY
79770: LIST
79771: LIST
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: LIST
79777: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
79778: LD_ADDR_VAR 0 29
79782: PUSH
79783: LD_INT 1
79785: NEG
79786: PUSH
79787: LD_INT 3
79789: NEG
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 0
79797: PUSH
79798: LD_INT 3
79800: NEG
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: LD_INT 1
79808: PUSH
79809: LD_INT 2
79811: NEG
79812: PUSH
79813: EMPTY
79814: LIST
79815: LIST
79816: PUSH
79817: LD_INT 1
79819: NEG
79820: PUSH
79821: LD_INT 4
79823: NEG
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: LD_INT 0
79831: PUSH
79832: LD_INT 4
79834: NEG
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 1
79842: PUSH
79843: LD_INT 3
79845: NEG
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: PUSH
79851: LD_INT 1
79853: NEG
79854: PUSH
79855: LD_INT 5
79857: NEG
79858: PUSH
79859: EMPTY
79860: LIST
79861: LIST
79862: PUSH
79863: LD_INT 0
79865: PUSH
79866: LD_INT 5
79868: NEG
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 1
79876: PUSH
79877: LD_INT 4
79879: NEG
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 1
79887: NEG
79888: PUSH
79889: LD_INT 6
79891: NEG
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: LD_INT 0
79899: PUSH
79900: LD_INT 6
79902: NEG
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 1
79910: PUSH
79911: LD_INT 5
79913: NEG
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: LIST
79923: LIST
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: LIST
79931: LIST
79932: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
79933: LD_ADDR_VAR 0 30
79937: PUSH
79938: LD_INT 2
79940: PUSH
79941: LD_INT 1
79943: NEG
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 3
79951: PUSH
79952: LD_INT 0
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 3
79961: PUSH
79962: LD_INT 1
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PUSH
79969: LD_INT 3
79971: PUSH
79972: LD_INT 1
79974: NEG
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 4
79982: PUSH
79983: LD_INT 0
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 4
79992: PUSH
79993: LD_INT 1
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: PUSH
80000: LD_INT 4
80002: PUSH
80003: LD_INT 1
80005: NEG
80006: PUSH
80007: EMPTY
80008: LIST
80009: LIST
80010: PUSH
80011: LD_INT 5
80013: PUSH
80014: LD_INT 0
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: LD_INT 5
80023: PUSH
80024: LD_INT 1
80026: PUSH
80027: EMPTY
80028: LIST
80029: LIST
80030: PUSH
80031: LD_INT 5
80033: PUSH
80034: LD_INT 1
80036: NEG
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 6
80044: PUSH
80045: LD_INT 0
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 6
80054: PUSH
80055: LD_INT 1
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
80076: LD_ADDR_VAR 0 31
80080: PUSH
80081: LD_INT 3
80083: PUSH
80084: LD_INT 2
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: PUSH
80091: LD_INT 3
80093: PUSH
80094: LD_INT 3
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 2
80103: PUSH
80104: LD_INT 3
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PUSH
80111: LD_INT 4
80113: PUSH
80114: LD_INT 3
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: LD_INT 4
80123: PUSH
80124: LD_INT 4
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 3
80133: PUSH
80134: LD_INT 4
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: PUSH
80141: LD_INT 5
80143: PUSH
80144: LD_INT 4
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: PUSH
80151: LD_INT 5
80153: PUSH
80154: LD_INT 5
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 4
80163: PUSH
80164: LD_INT 5
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 6
80173: PUSH
80174: LD_INT 5
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 6
80183: PUSH
80184: LD_INT 6
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: LD_INT 5
80193: PUSH
80194: LD_INT 6
80196: PUSH
80197: EMPTY
80198: LIST
80199: LIST
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: LIST
80205: LIST
80206: LIST
80207: LIST
80208: LIST
80209: LIST
80210: LIST
80211: LIST
80212: LIST
80213: LIST
80214: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
80215: LD_ADDR_VAR 0 32
80219: PUSH
80220: LD_INT 1
80222: PUSH
80223: LD_INT 3
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: LD_INT 0
80232: PUSH
80233: LD_INT 3
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: LD_INT 2
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: LD_INT 1
80253: PUSH
80254: LD_INT 4
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 0
80263: PUSH
80264: LD_INT 4
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 1
80273: NEG
80274: PUSH
80275: LD_INT 3
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 1
80284: PUSH
80285: LD_INT 5
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PUSH
80292: LD_INT 0
80294: PUSH
80295: LD_INT 5
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 1
80304: NEG
80305: PUSH
80306: LD_INT 4
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 1
80315: PUSH
80316: LD_INT 6
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 0
80325: PUSH
80326: LD_INT 6
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 1
80335: NEG
80336: PUSH
80337: LD_INT 5
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: LIST
80357: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
80358: LD_ADDR_VAR 0 33
80362: PUSH
80363: LD_INT 2
80365: NEG
80366: PUSH
80367: LD_INT 1
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 3
80376: NEG
80377: PUSH
80378: LD_INT 0
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 3
80387: NEG
80388: PUSH
80389: LD_INT 1
80391: NEG
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 3
80399: NEG
80400: PUSH
80401: LD_INT 1
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 4
80410: NEG
80411: PUSH
80412: LD_INT 0
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: PUSH
80419: LD_INT 4
80421: NEG
80422: PUSH
80423: LD_INT 1
80425: NEG
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 4
80433: NEG
80434: PUSH
80435: LD_INT 1
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 5
80444: NEG
80445: PUSH
80446: LD_INT 0
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 5
80455: NEG
80456: PUSH
80457: LD_INT 1
80459: NEG
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PUSH
80465: LD_INT 5
80467: NEG
80468: PUSH
80469: LD_INT 1
80471: PUSH
80472: EMPTY
80473: LIST
80474: LIST
80475: PUSH
80476: LD_INT 6
80478: NEG
80479: PUSH
80480: LD_INT 0
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 6
80489: NEG
80490: PUSH
80491: LD_INT 1
80493: NEG
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: LIST
80503: LIST
80504: LIST
80505: LIST
80506: LIST
80507: LIST
80508: LIST
80509: LIST
80510: LIST
80511: LIST
80512: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
80513: LD_ADDR_VAR 0 34
80517: PUSH
80518: LD_INT 2
80520: NEG
80521: PUSH
80522: LD_INT 3
80524: NEG
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 3
80532: NEG
80533: PUSH
80534: LD_INT 2
80536: NEG
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 3
80544: NEG
80545: PUSH
80546: LD_INT 3
80548: NEG
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 3
80556: NEG
80557: PUSH
80558: LD_INT 4
80560: NEG
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: LD_INT 4
80568: NEG
80569: PUSH
80570: LD_INT 3
80572: NEG
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 4
80580: NEG
80581: PUSH
80582: LD_INT 4
80584: NEG
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 4
80592: NEG
80593: PUSH
80594: LD_INT 5
80596: NEG
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 5
80604: NEG
80605: PUSH
80606: LD_INT 4
80608: NEG
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: LD_INT 5
80616: NEG
80617: PUSH
80618: LD_INT 5
80620: NEG
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: LD_INT 5
80628: NEG
80629: PUSH
80630: LD_INT 6
80632: NEG
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 6
80640: NEG
80641: PUSH
80642: LD_INT 5
80644: NEG
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: PUSH
80650: LD_INT 6
80652: NEG
80653: PUSH
80654: LD_INT 6
80656: NEG
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: LIST
80666: LIST
80667: LIST
80668: LIST
80669: LIST
80670: LIST
80671: LIST
80672: LIST
80673: LIST
80674: LIST
80675: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
80676: LD_ADDR_VAR 0 41
80680: PUSH
80681: LD_INT 0
80683: PUSH
80684: LD_INT 2
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 1
80694: NEG
80695: PUSH
80696: LD_INT 3
80698: NEG
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 1
80706: PUSH
80707: LD_INT 2
80709: NEG
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: LIST
80719: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
80720: LD_ADDR_VAR 0 42
80724: PUSH
80725: LD_INT 2
80727: PUSH
80728: LD_INT 0
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 2
80737: PUSH
80738: LD_INT 1
80740: NEG
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: LD_INT 3
80748: PUSH
80749: LD_INT 1
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: EMPTY
80757: LIST
80758: LIST
80759: LIST
80760: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
80761: LD_ADDR_VAR 0 43
80765: PUSH
80766: LD_INT 2
80768: PUSH
80769: LD_INT 2
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 3
80778: PUSH
80779: LD_INT 2
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 2
80788: PUSH
80789: LD_INT 3
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: LIST
80800: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
80801: LD_ADDR_VAR 0 44
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 2
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 1
80818: PUSH
80819: LD_INT 3
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: PUSH
80826: LD_INT 1
80828: NEG
80829: PUSH
80830: LD_INT 2
80832: PUSH
80833: EMPTY
80834: LIST
80835: LIST
80836: PUSH
80837: EMPTY
80838: LIST
80839: LIST
80840: LIST
80841: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80842: LD_ADDR_VAR 0 45
80846: PUSH
80847: LD_INT 2
80849: NEG
80850: PUSH
80851: LD_INT 0
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 2
80860: NEG
80861: PUSH
80862: LD_INT 1
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 3
80871: NEG
80872: PUSH
80873: LD_INT 1
80875: NEG
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: LIST
80885: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
80886: LD_ADDR_VAR 0 46
80890: PUSH
80891: LD_INT 2
80893: NEG
80894: PUSH
80895: LD_INT 2
80897: NEG
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 2
80905: NEG
80906: PUSH
80907: LD_INT 3
80909: NEG
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 3
80917: NEG
80918: PUSH
80919: LD_INT 2
80921: NEG
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: EMPTY
80928: LIST
80929: LIST
80930: LIST
80931: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
80932: LD_ADDR_VAR 0 47
80936: PUSH
80937: LD_INT 2
80939: NEG
80940: PUSH
80941: LD_INT 3
80943: NEG
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 1
80951: NEG
80952: PUSH
80953: LD_INT 3
80955: NEG
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80965: LD_ADDR_VAR 0 48
80969: PUSH
80970: LD_INT 1
80972: PUSH
80973: LD_INT 2
80975: NEG
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 2
80983: PUSH
80984: LD_INT 1
80986: NEG
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
80996: LD_ADDR_VAR 0 49
81000: PUSH
81001: LD_INT 3
81003: PUSH
81004: LD_INT 1
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 3
81013: PUSH
81014: LD_INT 2
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
81025: LD_ADDR_VAR 0 50
81029: PUSH
81030: LD_INT 2
81032: PUSH
81033: LD_INT 3
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 1
81042: PUSH
81043: LD_INT 3
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: EMPTY
81051: LIST
81052: LIST
81053: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81054: LD_ADDR_VAR 0 51
81058: PUSH
81059: LD_INT 1
81061: NEG
81062: PUSH
81063: LD_INT 2
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 2
81072: NEG
81073: PUSH
81074: LD_INT 1
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81085: LD_ADDR_VAR 0 52
81089: PUSH
81090: LD_INT 3
81092: NEG
81093: PUSH
81094: LD_INT 1
81096: NEG
81097: PUSH
81098: EMPTY
81099: LIST
81100: LIST
81101: PUSH
81102: LD_INT 3
81104: NEG
81105: PUSH
81106: LD_INT 2
81108: NEG
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81118: LD_ADDR_VAR 0 53
81122: PUSH
81123: LD_INT 1
81125: NEG
81126: PUSH
81127: LD_INT 3
81129: NEG
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 0
81137: PUSH
81138: LD_INT 3
81140: NEG
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 1
81148: PUSH
81149: LD_INT 2
81151: NEG
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: LIST
81161: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81162: LD_ADDR_VAR 0 54
81166: PUSH
81167: LD_INT 2
81169: PUSH
81170: LD_INT 1
81172: NEG
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: LD_INT 3
81180: PUSH
81181: LD_INT 0
81183: PUSH
81184: EMPTY
81185: LIST
81186: LIST
81187: PUSH
81188: LD_INT 3
81190: PUSH
81191: LD_INT 1
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: LIST
81202: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81203: LD_ADDR_VAR 0 55
81207: PUSH
81208: LD_INT 3
81210: PUSH
81211: LD_INT 2
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 3
81220: PUSH
81221: LD_INT 3
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 2
81230: PUSH
81231: LD_INT 3
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: LIST
81242: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81243: LD_ADDR_VAR 0 56
81247: PUSH
81248: LD_INT 1
81250: PUSH
81251: LD_INT 3
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 0
81260: PUSH
81261: LD_INT 3
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 1
81270: NEG
81271: PUSH
81272: LD_INT 2
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: LIST
81283: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81284: LD_ADDR_VAR 0 57
81288: PUSH
81289: LD_INT 2
81291: NEG
81292: PUSH
81293: LD_INT 1
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 3
81302: NEG
81303: PUSH
81304: LD_INT 0
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: LD_INT 3
81313: NEG
81314: PUSH
81315: LD_INT 1
81317: NEG
81318: PUSH
81319: EMPTY
81320: LIST
81321: LIST
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: LIST
81327: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81328: LD_ADDR_VAR 0 58
81332: PUSH
81333: LD_INT 2
81335: NEG
81336: PUSH
81337: LD_INT 3
81339: NEG
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 3
81347: NEG
81348: PUSH
81349: LD_INT 2
81351: NEG
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 3
81359: NEG
81360: PUSH
81361: LD_INT 3
81363: NEG
81364: PUSH
81365: EMPTY
81366: LIST
81367: LIST
81368: PUSH
81369: EMPTY
81370: LIST
81371: LIST
81372: LIST
81373: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
81374: LD_ADDR_VAR 0 59
81378: PUSH
81379: LD_INT 1
81381: NEG
81382: PUSH
81383: LD_INT 2
81385: NEG
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 0
81393: PUSH
81394: LD_INT 2
81396: NEG
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 1
81404: PUSH
81405: LD_INT 1
81407: NEG
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: LIST
81417: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
81418: LD_ADDR_VAR 0 60
81422: PUSH
81423: LD_INT 1
81425: PUSH
81426: LD_INT 1
81428: NEG
81429: PUSH
81430: EMPTY
81431: LIST
81432: LIST
81433: PUSH
81434: LD_INT 2
81436: PUSH
81437: LD_INT 0
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: PUSH
81444: LD_INT 2
81446: PUSH
81447: LD_INT 1
81449: PUSH
81450: EMPTY
81451: LIST
81452: LIST
81453: PUSH
81454: EMPTY
81455: LIST
81456: LIST
81457: LIST
81458: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
81459: LD_ADDR_VAR 0 61
81463: PUSH
81464: LD_INT 2
81466: PUSH
81467: LD_INT 1
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 2
81476: PUSH
81477: LD_INT 2
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 1
81486: PUSH
81487: LD_INT 2
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: LIST
81498: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
81499: LD_ADDR_VAR 0 62
81503: PUSH
81504: LD_INT 1
81506: PUSH
81507: LD_INT 2
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: LD_INT 0
81516: PUSH
81517: LD_INT 2
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 1
81526: NEG
81527: PUSH
81528: LD_INT 1
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: LIST
81539: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
81540: LD_ADDR_VAR 0 63
81544: PUSH
81545: LD_INT 1
81547: NEG
81548: PUSH
81549: LD_INT 1
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 2
81558: NEG
81559: PUSH
81560: LD_INT 0
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 2
81569: NEG
81570: PUSH
81571: LD_INT 1
81573: NEG
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: LIST
81583: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81584: LD_ADDR_VAR 0 64
81588: PUSH
81589: LD_INT 1
81591: NEG
81592: PUSH
81593: LD_INT 2
81595: NEG
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 2
81603: NEG
81604: PUSH
81605: LD_INT 1
81607: NEG
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 2
81615: NEG
81616: PUSH
81617: LD_INT 2
81619: NEG
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: LIST
81629: ST_TO_ADDR
// end ; 2 :
81630: GO 84896
81632: LD_INT 2
81634: DOUBLE
81635: EQUAL
81636: IFTRUE 81640
81638: GO 84895
81640: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
81641: LD_ADDR_VAR 0 29
81645: PUSH
81646: LD_INT 4
81648: PUSH
81649: LD_INT 0
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 4
81658: PUSH
81659: LD_INT 1
81661: NEG
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: PUSH
81667: LD_INT 5
81669: PUSH
81670: LD_INT 0
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: LD_INT 5
81679: PUSH
81680: LD_INT 1
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 4
81689: PUSH
81690: LD_INT 1
81692: PUSH
81693: EMPTY
81694: LIST
81695: LIST
81696: PUSH
81697: LD_INT 3
81699: PUSH
81700: LD_INT 0
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 3
81709: PUSH
81710: LD_INT 1
81712: NEG
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 3
81720: PUSH
81721: LD_INT 2
81723: NEG
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 5
81731: PUSH
81732: LD_INT 2
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 3
81741: PUSH
81742: LD_INT 3
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 3
81751: PUSH
81752: LD_INT 2
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 4
81761: PUSH
81762: LD_INT 3
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 4
81771: PUSH
81772: LD_INT 4
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 3
81781: PUSH
81782: LD_INT 4
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 2
81791: PUSH
81792: LD_INT 3
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 2
81801: PUSH
81802: LD_INT 2
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 4
81811: PUSH
81812: LD_INT 2
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PUSH
81819: LD_INT 2
81821: PUSH
81822: LD_INT 4
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: LD_INT 4
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PUSH
81839: LD_INT 0
81841: PUSH
81842: LD_INT 3
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PUSH
81849: LD_INT 1
81851: PUSH
81852: LD_INT 4
81854: PUSH
81855: EMPTY
81856: LIST
81857: LIST
81858: PUSH
81859: LD_INT 1
81861: PUSH
81862: LD_INT 5
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PUSH
81869: LD_INT 0
81871: PUSH
81872: LD_INT 5
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: PUSH
81879: LD_INT 1
81881: NEG
81882: PUSH
81883: LD_INT 4
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 1
81892: NEG
81893: PUSH
81894: LD_INT 3
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_INT 2
81903: PUSH
81904: LD_INT 5
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 2
81913: NEG
81914: PUSH
81915: LD_INT 3
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 3
81924: NEG
81925: PUSH
81926: LD_INT 0
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: LD_INT 3
81935: NEG
81936: PUSH
81937: LD_INT 1
81939: NEG
81940: PUSH
81941: EMPTY
81942: LIST
81943: LIST
81944: PUSH
81945: LD_INT 2
81947: NEG
81948: PUSH
81949: LD_INT 0
81951: PUSH
81952: EMPTY
81953: LIST
81954: LIST
81955: PUSH
81956: LD_INT 2
81958: NEG
81959: PUSH
81960: LD_INT 1
81962: PUSH
81963: EMPTY
81964: LIST
81965: LIST
81966: PUSH
81967: LD_INT 3
81969: NEG
81970: PUSH
81971: LD_INT 1
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 4
81980: NEG
81981: PUSH
81982: LD_INT 0
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: LD_INT 4
81991: NEG
81992: PUSH
81993: LD_INT 1
81995: NEG
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 4
82003: NEG
82004: PUSH
82005: LD_INT 2
82007: NEG
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 2
82015: NEG
82016: PUSH
82017: LD_INT 2
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PUSH
82024: LD_INT 4
82026: NEG
82027: PUSH
82028: LD_INT 4
82030: NEG
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 4
82038: NEG
82039: PUSH
82040: LD_INT 5
82042: NEG
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 3
82050: NEG
82051: PUSH
82052: LD_INT 4
82054: NEG
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 3
82062: NEG
82063: PUSH
82064: LD_INT 3
82066: NEG
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: PUSH
82072: LD_INT 4
82074: NEG
82075: PUSH
82076: LD_INT 3
82078: NEG
82079: PUSH
82080: EMPTY
82081: LIST
82082: LIST
82083: PUSH
82084: LD_INT 5
82086: NEG
82087: PUSH
82088: LD_INT 4
82090: NEG
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: PUSH
82096: LD_INT 5
82098: NEG
82099: PUSH
82100: LD_INT 5
82102: NEG
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 3
82110: NEG
82111: PUSH
82112: LD_INT 5
82114: NEG
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 5
82122: NEG
82123: PUSH
82124: LD_INT 3
82126: NEG
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: EMPTY
82133: LIST
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
82179: LD_ADDR_VAR 0 30
82183: PUSH
82184: LD_INT 4
82186: PUSH
82187: LD_INT 4
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 4
82196: PUSH
82197: LD_INT 3
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 5
82206: PUSH
82207: LD_INT 4
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 5
82216: PUSH
82217: LD_INT 5
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 4
82226: PUSH
82227: LD_INT 5
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 3
82236: PUSH
82237: LD_INT 4
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 3
82246: PUSH
82247: LD_INT 3
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 5
82256: PUSH
82257: LD_INT 3
82259: PUSH
82260: EMPTY
82261: LIST
82262: LIST
82263: PUSH
82264: LD_INT 3
82266: PUSH
82267: LD_INT 5
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 0
82276: PUSH
82277: LD_INT 3
82279: PUSH
82280: EMPTY
82281: LIST
82282: LIST
82283: PUSH
82284: LD_INT 0
82286: PUSH
82287: LD_INT 2
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: PUSH
82294: LD_INT 1
82296: PUSH
82297: LD_INT 3
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: PUSH
82304: LD_INT 1
82306: PUSH
82307: LD_INT 4
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: LD_INT 4
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: PUSH
82324: LD_INT 1
82326: NEG
82327: PUSH
82328: LD_INT 3
82330: PUSH
82331: EMPTY
82332: LIST
82333: LIST
82334: PUSH
82335: LD_INT 1
82337: NEG
82338: PUSH
82339: LD_INT 2
82341: PUSH
82342: EMPTY
82343: LIST
82344: LIST
82345: PUSH
82346: LD_INT 2
82348: PUSH
82349: LD_INT 4
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 2
82358: NEG
82359: PUSH
82360: LD_INT 2
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 4
82369: NEG
82370: PUSH
82371: LD_INT 0
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: LD_INT 4
82380: NEG
82381: PUSH
82382: LD_INT 1
82384: NEG
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 3
82392: NEG
82393: PUSH
82394: LD_INT 0
82396: PUSH
82397: EMPTY
82398: LIST
82399: LIST
82400: PUSH
82401: LD_INT 3
82403: NEG
82404: PUSH
82405: LD_INT 1
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PUSH
82412: LD_INT 4
82414: NEG
82415: PUSH
82416: LD_INT 1
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: LD_INT 5
82425: NEG
82426: PUSH
82427: LD_INT 0
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 5
82436: NEG
82437: PUSH
82438: LD_INT 1
82440: NEG
82441: PUSH
82442: EMPTY
82443: LIST
82444: LIST
82445: PUSH
82446: LD_INT 5
82448: NEG
82449: PUSH
82450: LD_INT 2
82452: NEG
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PUSH
82458: LD_INT 3
82460: NEG
82461: PUSH
82462: LD_INT 2
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 3
82471: NEG
82472: PUSH
82473: LD_INT 3
82475: NEG
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PUSH
82481: LD_INT 3
82483: NEG
82484: PUSH
82485: LD_INT 4
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 2
82495: NEG
82496: PUSH
82497: LD_INT 3
82499: NEG
82500: PUSH
82501: EMPTY
82502: LIST
82503: LIST
82504: PUSH
82505: LD_INT 2
82507: NEG
82508: PUSH
82509: LD_INT 2
82511: NEG
82512: PUSH
82513: EMPTY
82514: LIST
82515: LIST
82516: PUSH
82517: LD_INT 3
82519: NEG
82520: PUSH
82521: LD_INT 2
82523: NEG
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 4
82531: NEG
82532: PUSH
82533: LD_INT 3
82535: NEG
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 4
82543: NEG
82544: PUSH
82545: LD_INT 4
82547: NEG
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 2
82555: NEG
82556: PUSH
82557: LD_INT 4
82559: NEG
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 4
82567: NEG
82568: PUSH
82569: LD_INT 2
82571: NEG
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: LD_INT 0
82579: PUSH
82580: LD_INT 4
82582: NEG
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: PUSH
82588: LD_INT 0
82590: PUSH
82591: LD_INT 5
82593: NEG
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 1
82601: PUSH
82602: LD_INT 4
82604: NEG
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: PUSH
82610: LD_INT 1
82612: PUSH
82613: LD_INT 3
82615: NEG
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: PUSH
82621: LD_INT 0
82623: PUSH
82624: LD_INT 3
82626: NEG
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: LD_INT 1
82634: NEG
82635: PUSH
82636: LD_INT 4
82638: NEG
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PUSH
82644: LD_INT 1
82646: NEG
82647: PUSH
82648: LD_INT 5
82650: NEG
82651: PUSH
82652: EMPTY
82653: LIST
82654: LIST
82655: PUSH
82656: LD_INT 2
82658: PUSH
82659: LD_INT 3
82661: NEG
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: PUSH
82667: LD_INT 2
82669: NEG
82670: PUSH
82671: LD_INT 5
82673: NEG
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: LIST
82683: LIST
82684: LIST
82685: LIST
82686: LIST
82687: LIST
82688: LIST
82689: LIST
82690: LIST
82691: LIST
82692: LIST
82693: LIST
82694: LIST
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
82726: LD_ADDR_VAR 0 31
82730: PUSH
82731: LD_INT 0
82733: PUSH
82734: LD_INT 4
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 0
82743: PUSH
82744: LD_INT 3
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 1
82753: PUSH
82754: LD_INT 4
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 1
82763: PUSH
82764: LD_INT 5
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 0
82773: PUSH
82774: LD_INT 5
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 1
82783: NEG
82784: PUSH
82785: LD_INT 4
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 1
82794: NEG
82795: PUSH
82796: LD_INT 3
82798: PUSH
82799: EMPTY
82800: LIST
82801: LIST
82802: PUSH
82803: LD_INT 2
82805: PUSH
82806: LD_INT 5
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: PUSH
82813: LD_INT 2
82815: NEG
82816: PUSH
82817: LD_INT 3
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: PUSH
82824: LD_INT 3
82826: NEG
82827: PUSH
82828: LD_INT 0
82830: PUSH
82831: EMPTY
82832: LIST
82833: LIST
82834: PUSH
82835: LD_INT 3
82837: NEG
82838: PUSH
82839: LD_INT 1
82841: NEG
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: PUSH
82847: LD_INT 2
82849: NEG
82850: PUSH
82851: LD_INT 0
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: PUSH
82858: LD_INT 2
82860: NEG
82861: PUSH
82862: LD_INT 1
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 3
82871: NEG
82872: PUSH
82873: LD_INT 1
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 4
82882: NEG
82883: PUSH
82884: LD_INT 0
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 4
82893: NEG
82894: PUSH
82895: LD_INT 1
82897: NEG
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 4
82905: NEG
82906: PUSH
82907: LD_INT 2
82909: NEG
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 2
82917: NEG
82918: PUSH
82919: LD_INT 2
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 4
82928: NEG
82929: PUSH
82930: LD_INT 4
82932: NEG
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 4
82940: NEG
82941: PUSH
82942: LD_INT 5
82944: NEG
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 3
82952: NEG
82953: PUSH
82954: LD_INT 4
82956: NEG
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 3
82964: NEG
82965: PUSH
82966: LD_INT 3
82968: NEG
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 4
82976: NEG
82977: PUSH
82978: LD_INT 3
82980: NEG
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: LD_INT 5
82988: NEG
82989: PUSH
82990: LD_INT 4
82992: NEG
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 5
83000: NEG
83001: PUSH
83002: LD_INT 5
83004: NEG
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 3
83012: NEG
83013: PUSH
83014: LD_INT 5
83016: NEG
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 5
83024: NEG
83025: PUSH
83026: LD_INT 3
83028: NEG
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: PUSH
83034: LD_INT 0
83036: PUSH
83037: LD_INT 3
83039: NEG
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 0
83047: PUSH
83048: LD_INT 4
83050: NEG
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 1
83058: PUSH
83059: LD_INT 3
83061: NEG
83062: PUSH
83063: EMPTY
83064: LIST
83065: LIST
83066: PUSH
83067: LD_INT 1
83069: PUSH
83070: LD_INT 2
83072: NEG
83073: PUSH
83074: EMPTY
83075: LIST
83076: LIST
83077: PUSH
83078: LD_INT 0
83080: PUSH
83081: LD_INT 2
83083: NEG
83084: PUSH
83085: EMPTY
83086: LIST
83087: LIST
83088: PUSH
83089: LD_INT 1
83091: NEG
83092: PUSH
83093: LD_INT 3
83095: NEG
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: PUSH
83101: LD_INT 1
83103: NEG
83104: PUSH
83105: LD_INT 4
83107: NEG
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: PUSH
83113: LD_INT 2
83115: PUSH
83116: LD_INT 2
83118: NEG
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PUSH
83124: LD_INT 2
83126: NEG
83127: PUSH
83128: LD_INT 4
83130: NEG
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 4
83138: PUSH
83139: LD_INT 0
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 4
83148: PUSH
83149: LD_INT 1
83151: NEG
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 5
83159: PUSH
83160: LD_INT 0
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PUSH
83167: LD_INT 5
83169: PUSH
83170: LD_INT 1
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PUSH
83177: LD_INT 4
83179: PUSH
83180: LD_INT 1
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: PUSH
83187: LD_INT 3
83189: PUSH
83190: LD_INT 0
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: LD_INT 3
83199: PUSH
83200: LD_INT 1
83202: NEG
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: PUSH
83208: LD_INT 3
83210: PUSH
83211: LD_INT 2
83213: NEG
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: LD_INT 5
83221: PUSH
83222: LD_INT 2
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
83276: LD_ADDR_VAR 0 32
83280: PUSH
83281: LD_INT 4
83283: NEG
83284: PUSH
83285: LD_INT 0
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 4
83294: NEG
83295: PUSH
83296: LD_INT 1
83298: NEG
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: LD_INT 3
83306: NEG
83307: PUSH
83308: LD_INT 0
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 3
83317: NEG
83318: PUSH
83319: LD_INT 1
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: PUSH
83326: LD_INT 4
83328: NEG
83329: PUSH
83330: LD_INT 1
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 5
83339: NEG
83340: PUSH
83341: LD_INT 0
83343: PUSH
83344: EMPTY
83345: LIST
83346: LIST
83347: PUSH
83348: LD_INT 5
83350: NEG
83351: PUSH
83352: LD_INT 1
83354: NEG
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 5
83362: NEG
83363: PUSH
83364: LD_INT 2
83366: NEG
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 3
83374: NEG
83375: PUSH
83376: LD_INT 2
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 3
83385: NEG
83386: PUSH
83387: LD_INT 3
83389: NEG
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 3
83397: NEG
83398: PUSH
83399: LD_INT 4
83401: NEG
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 2
83409: NEG
83410: PUSH
83411: LD_INT 3
83413: NEG
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 2
83421: NEG
83422: PUSH
83423: LD_INT 2
83425: NEG
83426: PUSH
83427: EMPTY
83428: LIST
83429: LIST
83430: PUSH
83431: LD_INT 3
83433: NEG
83434: PUSH
83435: LD_INT 2
83437: NEG
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 4
83445: NEG
83446: PUSH
83447: LD_INT 3
83449: NEG
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 4
83457: NEG
83458: PUSH
83459: LD_INT 4
83461: NEG
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 2
83469: NEG
83470: PUSH
83471: LD_INT 4
83473: NEG
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 4
83481: NEG
83482: PUSH
83483: LD_INT 2
83485: NEG
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 0
83493: PUSH
83494: LD_INT 4
83496: NEG
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: LD_INT 0
83504: PUSH
83505: LD_INT 5
83507: NEG
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: LD_INT 1
83515: PUSH
83516: LD_INT 4
83518: NEG
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: PUSH
83524: LD_INT 1
83526: PUSH
83527: LD_INT 3
83529: NEG
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: PUSH
83535: LD_INT 0
83537: PUSH
83538: LD_INT 3
83540: NEG
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 1
83548: NEG
83549: PUSH
83550: LD_INT 4
83552: NEG
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 1
83560: NEG
83561: PUSH
83562: LD_INT 5
83564: NEG
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 2
83572: PUSH
83573: LD_INT 3
83575: NEG
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 2
83583: NEG
83584: PUSH
83585: LD_INT 5
83587: NEG
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 3
83595: PUSH
83596: LD_INT 0
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 3
83605: PUSH
83606: LD_INT 1
83608: NEG
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: PUSH
83614: LD_INT 4
83616: PUSH
83617: LD_INT 0
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 4
83626: PUSH
83627: LD_INT 1
83629: PUSH
83630: EMPTY
83631: LIST
83632: LIST
83633: PUSH
83634: LD_INT 3
83636: PUSH
83637: LD_INT 1
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: PUSH
83644: LD_INT 2
83646: PUSH
83647: LD_INT 0
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: PUSH
83654: LD_INT 2
83656: PUSH
83657: LD_INT 1
83659: NEG
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 2
83667: PUSH
83668: LD_INT 2
83670: NEG
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 4
83678: PUSH
83679: LD_INT 2
83681: PUSH
83682: EMPTY
83683: LIST
83684: LIST
83685: PUSH
83686: LD_INT 4
83688: PUSH
83689: LD_INT 4
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: PUSH
83696: LD_INT 4
83698: PUSH
83699: LD_INT 3
83701: PUSH
83702: EMPTY
83703: LIST
83704: LIST
83705: PUSH
83706: LD_INT 5
83708: PUSH
83709: LD_INT 4
83711: PUSH
83712: EMPTY
83713: LIST
83714: LIST
83715: PUSH
83716: LD_INT 5
83718: PUSH
83719: LD_INT 5
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 4
83728: PUSH
83729: LD_INT 5
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 3
83738: PUSH
83739: LD_INT 4
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: LD_INT 3
83748: PUSH
83749: LD_INT 3
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 5
83758: PUSH
83759: LD_INT 3
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 3
83768: PUSH
83769: LD_INT 5
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: EMPTY
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
83823: LD_ADDR_VAR 0 33
83827: PUSH
83828: LD_INT 4
83830: NEG
83831: PUSH
83832: LD_INT 4
83834: NEG
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: PUSH
83840: LD_INT 4
83842: NEG
83843: PUSH
83844: LD_INT 5
83846: NEG
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: PUSH
83852: LD_INT 3
83854: NEG
83855: PUSH
83856: LD_INT 4
83858: NEG
83859: PUSH
83860: EMPTY
83861: LIST
83862: LIST
83863: PUSH
83864: LD_INT 3
83866: NEG
83867: PUSH
83868: LD_INT 3
83870: NEG
83871: PUSH
83872: EMPTY
83873: LIST
83874: LIST
83875: PUSH
83876: LD_INT 4
83878: NEG
83879: PUSH
83880: LD_INT 3
83882: NEG
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: PUSH
83888: LD_INT 5
83890: NEG
83891: PUSH
83892: LD_INT 4
83894: NEG
83895: PUSH
83896: EMPTY
83897: LIST
83898: LIST
83899: PUSH
83900: LD_INT 5
83902: NEG
83903: PUSH
83904: LD_INT 5
83906: NEG
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PUSH
83912: LD_INT 3
83914: NEG
83915: PUSH
83916: LD_INT 5
83918: NEG
83919: PUSH
83920: EMPTY
83921: LIST
83922: LIST
83923: PUSH
83924: LD_INT 5
83926: NEG
83927: PUSH
83928: LD_INT 3
83930: NEG
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 0
83938: PUSH
83939: LD_INT 3
83941: NEG
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: PUSH
83947: LD_INT 0
83949: PUSH
83950: LD_INT 4
83952: NEG
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: PUSH
83958: LD_INT 1
83960: PUSH
83961: LD_INT 3
83963: NEG
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PUSH
83969: LD_INT 1
83971: PUSH
83972: LD_INT 2
83974: NEG
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: PUSH
83980: LD_INT 0
83982: PUSH
83983: LD_INT 2
83985: NEG
83986: PUSH
83987: EMPTY
83988: LIST
83989: LIST
83990: PUSH
83991: LD_INT 1
83993: NEG
83994: PUSH
83995: LD_INT 3
83997: NEG
83998: PUSH
83999: EMPTY
84000: LIST
84001: LIST
84002: PUSH
84003: LD_INT 1
84005: NEG
84006: PUSH
84007: LD_INT 4
84009: NEG
84010: PUSH
84011: EMPTY
84012: LIST
84013: LIST
84014: PUSH
84015: LD_INT 2
84017: PUSH
84018: LD_INT 2
84020: NEG
84021: PUSH
84022: EMPTY
84023: LIST
84024: LIST
84025: PUSH
84026: LD_INT 2
84028: NEG
84029: PUSH
84030: LD_INT 4
84032: NEG
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: PUSH
84038: LD_INT 4
84040: PUSH
84041: LD_INT 0
84043: PUSH
84044: EMPTY
84045: LIST
84046: LIST
84047: PUSH
84048: LD_INT 4
84050: PUSH
84051: LD_INT 1
84053: NEG
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: PUSH
84059: LD_INT 5
84061: PUSH
84062: LD_INT 0
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: PUSH
84069: LD_INT 5
84071: PUSH
84072: LD_INT 1
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: PUSH
84079: LD_INT 4
84081: PUSH
84082: LD_INT 1
84084: PUSH
84085: EMPTY
84086: LIST
84087: LIST
84088: PUSH
84089: LD_INT 3
84091: PUSH
84092: LD_INT 0
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PUSH
84099: LD_INT 3
84101: PUSH
84102: LD_INT 1
84104: NEG
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 3
84112: PUSH
84113: LD_INT 2
84115: NEG
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: PUSH
84121: LD_INT 5
84123: PUSH
84124: LD_INT 2
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: LD_INT 3
84133: PUSH
84134: LD_INT 3
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PUSH
84141: LD_INT 3
84143: PUSH
84144: LD_INT 2
84146: PUSH
84147: EMPTY
84148: LIST
84149: LIST
84150: PUSH
84151: LD_INT 4
84153: PUSH
84154: LD_INT 3
84156: PUSH
84157: EMPTY
84158: LIST
84159: LIST
84160: PUSH
84161: LD_INT 4
84163: PUSH
84164: LD_INT 4
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 3
84173: PUSH
84174: LD_INT 4
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 2
84183: PUSH
84184: LD_INT 3
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 2
84193: PUSH
84194: LD_INT 2
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: PUSH
84201: LD_INT 4
84203: PUSH
84204: LD_INT 2
84206: PUSH
84207: EMPTY
84208: LIST
84209: LIST
84210: PUSH
84211: LD_INT 2
84213: PUSH
84214: LD_INT 4
84216: PUSH
84217: EMPTY
84218: LIST
84219: LIST
84220: PUSH
84221: LD_INT 0
84223: PUSH
84224: LD_INT 4
84226: PUSH
84227: EMPTY
84228: LIST
84229: LIST
84230: PUSH
84231: LD_INT 0
84233: PUSH
84234: LD_INT 3
84236: PUSH
84237: EMPTY
84238: LIST
84239: LIST
84240: PUSH
84241: LD_INT 1
84243: PUSH
84244: LD_INT 4
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 1
84253: PUSH
84254: LD_INT 5
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: PUSH
84261: LD_INT 0
84263: PUSH
84264: LD_INT 5
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 1
84273: NEG
84274: PUSH
84275: LD_INT 4
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 1
84284: NEG
84285: PUSH
84286: LD_INT 3
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 2
84295: PUSH
84296: LD_INT 5
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 2
84305: NEG
84306: PUSH
84307: LD_INT 3
84309: PUSH
84310: EMPTY
84311: LIST
84312: LIST
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: LIST
84340: LIST
84341: LIST
84342: LIST
84343: LIST
84344: LIST
84345: LIST
84346: LIST
84347: LIST
84348: LIST
84349: LIST
84350: LIST
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: LIST
84356: LIST
84357: LIST
84358: LIST
84359: LIST
84360: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
84361: LD_ADDR_VAR 0 34
84365: PUSH
84366: LD_INT 0
84368: PUSH
84369: LD_INT 4
84371: NEG
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: PUSH
84377: LD_INT 0
84379: PUSH
84380: LD_INT 5
84382: NEG
84383: PUSH
84384: EMPTY
84385: LIST
84386: LIST
84387: PUSH
84388: LD_INT 1
84390: PUSH
84391: LD_INT 4
84393: NEG
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: PUSH
84399: LD_INT 1
84401: PUSH
84402: LD_INT 3
84404: NEG
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: PUSH
84410: LD_INT 0
84412: PUSH
84413: LD_INT 3
84415: NEG
84416: PUSH
84417: EMPTY
84418: LIST
84419: LIST
84420: PUSH
84421: LD_INT 1
84423: NEG
84424: PUSH
84425: LD_INT 4
84427: NEG
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: PUSH
84433: LD_INT 1
84435: NEG
84436: PUSH
84437: LD_INT 5
84439: NEG
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 2
84447: PUSH
84448: LD_INT 3
84450: NEG
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 2
84458: NEG
84459: PUSH
84460: LD_INT 5
84462: NEG
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 3
84470: PUSH
84471: LD_INT 0
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: PUSH
84478: LD_INT 3
84480: PUSH
84481: LD_INT 1
84483: NEG
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: LD_INT 4
84491: PUSH
84492: LD_INT 0
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 4
84501: PUSH
84502: LD_INT 1
84504: PUSH
84505: EMPTY
84506: LIST
84507: LIST
84508: PUSH
84509: LD_INT 3
84511: PUSH
84512: LD_INT 1
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: PUSH
84519: LD_INT 2
84521: PUSH
84522: LD_INT 0
84524: PUSH
84525: EMPTY
84526: LIST
84527: LIST
84528: PUSH
84529: LD_INT 2
84531: PUSH
84532: LD_INT 1
84534: NEG
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 2
84542: PUSH
84543: LD_INT 2
84545: NEG
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: LD_INT 4
84553: PUSH
84554: LD_INT 2
84556: PUSH
84557: EMPTY
84558: LIST
84559: LIST
84560: PUSH
84561: LD_INT 4
84563: PUSH
84564: LD_INT 4
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 4
84573: PUSH
84574: LD_INT 3
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: PUSH
84581: LD_INT 5
84583: PUSH
84584: LD_INT 4
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: PUSH
84591: LD_INT 5
84593: PUSH
84594: LD_INT 5
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 4
84603: PUSH
84604: LD_INT 5
84606: PUSH
84607: EMPTY
84608: LIST
84609: LIST
84610: PUSH
84611: LD_INT 3
84613: PUSH
84614: LD_INT 4
84616: PUSH
84617: EMPTY
84618: LIST
84619: LIST
84620: PUSH
84621: LD_INT 3
84623: PUSH
84624: LD_INT 3
84626: PUSH
84627: EMPTY
84628: LIST
84629: LIST
84630: PUSH
84631: LD_INT 5
84633: PUSH
84634: LD_INT 3
84636: PUSH
84637: EMPTY
84638: LIST
84639: LIST
84640: PUSH
84641: LD_INT 3
84643: PUSH
84644: LD_INT 5
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 0
84653: PUSH
84654: LD_INT 3
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 0
84663: PUSH
84664: LD_INT 2
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 1
84673: PUSH
84674: LD_INT 3
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 1
84683: PUSH
84684: LD_INT 4
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 0
84693: PUSH
84694: LD_INT 4
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 1
84703: NEG
84704: PUSH
84705: LD_INT 3
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: LD_INT 1
84714: NEG
84715: PUSH
84716: LD_INT 2
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: PUSH
84723: LD_INT 2
84725: PUSH
84726: LD_INT 4
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 2
84735: NEG
84736: PUSH
84737: LD_INT 2
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 4
84746: NEG
84747: PUSH
84748: LD_INT 0
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 4
84757: NEG
84758: PUSH
84759: LD_INT 1
84761: NEG
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 3
84769: NEG
84770: PUSH
84771: LD_INT 0
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: PUSH
84778: LD_INT 3
84780: NEG
84781: PUSH
84782: LD_INT 1
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 4
84791: NEG
84792: PUSH
84793: LD_INT 1
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 5
84802: NEG
84803: PUSH
84804: LD_INT 0
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: LD_INT 5
84813: NEG
84814: PUSH
84815: LD_INT 1
84817: NEG
84818: PUSH
84819: EMPTY
84820: LIST
84821: LIST
84822: PUSH
84823: LD_INT 5
84825: NEG
84826: PUSH
84827: LD_INT 2
84829: NEG
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 3
84837: NEG
84838: PUSH
84839: LD_INT 2
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: EMPTY
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: ST_TO_ADDR
// end ; end ;
84893: GO 84896
84895: POP
// case btype of b_depot , b_warehouse :
84896: LD_VAR 0 1
84900: PUSH
84901: LD_INT 0
84903: DOUBLE
84904: EQUAL
84905: IFTRUE 84915
84907: LD_INT 1
84909: DOUBLE
84910: EQUAL
84911: IFTRUE 84915
84913: GO 85116
84915: POP
// case nation of nation_american :
84916: LD_VAR 0 5
84920: PUSH
84921: LD_INT 1
84923: DOUBLE
84924: EQUAL
84925: IFTRUE 84929
84927: GO 84985
84929: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
84930: LD_ADDR_VAR 0 9
84934: PUSH
84935: LD_VAR 0 11
84939: PUSH
84940: LD_VAR 0 12
84944: PUSH
84945: LD_VAR 0 13
84949: PUSH
84950: LD_VAR 0 14
84954: PUSH
84955: LD_VAR 0 15
84959: PUSH
84960: LD_VAR 0 16
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: PUSH
84973: LD_VAR 0 4
84977: PUSH
84978: LD_INT 1
84980: PLUS
84981: ARRAY
84982: ST_TO_ADDR
84983: GO 85114
84985: LD_INT 2
84987: DOUBLE
84988: EQUAL
84989: IFTRUE 84993
84991: GO 85049
84993: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
84994: LD_ADDR_VAR 0 9
84998: PUSH
84999: LD_VAR 0 17
85003: PUSH
85004: LD_VAR 0 18
85008: PUSH
85009: LD_VAR 0 19
85013: PUSH
85014: LD_VAR 0 20
85018: PUSH
85019: LD_VAR 0 21
85023: PUSH
85024: LD_VAR 0 22
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: PUSH
85037: LD_VAR 0 4
85041: PUSH
85042: LD_INT 1
85044: PLUS
85045: ARRAY
85046: ST_TO_ADDR
85047: GO 85114
85049: LD_INT 3
85051: DOUBLE
85052: EQUAL
85053: IFTRUE 85057
85055: GO 85113
85057: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
85058: LD_ADDR_VAR 0 9
85062: PUSH
85063: LD_VAR 0 23
85067: PUSH
85068: LD_VAR 0 24
85072: PUSH
85073: LD_VAR 0 25
85077: PUSH
85078: LD_VAR 0 26
85082: PUSH
85083: LD_VAR 0 27
85087: PUSH
85088: LD_VAR 0 28
85092: PUSH
85093: EMPTY
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: PUSH
85101: LD_VAR 0 4
85105: PUSH
85106: LD_INT 1
85108: PLUS
85109: ARRAY
85110: ST_TO_ADDR
85111: GO 85114
85113: POP
85114: GO 85669
85116: LD_INT 2
85118: DOUBLE
85119: EQUAL
85120: IFTRUE 85130
85122: LD_INT 3
85124: DOUBLE
85125: EQUAL
85126: IFTRUE 85130
85128: GO 85186
85130: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
85131: LD_ADDR_VAR 0 9
85135: PUSH
85136: LD_VAR 0 29
85140: PUSH
85141: LD_VAR 0 30
85145: PUSH
85146: LD_VAR 0 31
85150: PUSH
85151: LD_VAR 0 32
85155: PUSH
85156: LD_VAR 0 33
85160: PUSH
85161: LD_VAR 0 34
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: LIST
85170: LIST
85171: LIST
85172: LIST
85173: PUSH
85174: LD_VAR 0 4
85178: PUSH
85179: LD_INT 1
85181: PLUS
85182: ARRAY
85183: ST_TO_ADDR
85184: GO 85669
85186: LD_INT 16
85188: DOUBLE
85189: EQUAL
85190: IFTRUE 85248
85192: LD_INT 17
85194: DOUBLE
85195: EQUAL
85196: IFTRUE 85248
85198: LD_INT 18
85200: DOUBLE
85201: EQUAL
85202: IFTRUE 85248
85204: LD_INT 19
85206: DOUBLE
85207: EQUAL
85208: IFTRUE 85248
85210: LD_INT 22
85212: DOUBLE
85213: EQUAL
85214: IFTRUE 85248
85216: LD_INT 20
85218: DOUBLE
85219: EQUAL
85220: IFTRUE 85248
85222: LD_INT 21
85224: DOUBLE
85225: EQUAL
85226: IFTRUE 85248
85228: LD_INT 23
85230: DOUBLE
85231: EQUAL
85232: IFTRUE 85248
85234: LD_INT 24
85236: DOUBLE
85237: EQUAL
85238: IFTRUE 85248
85240: LD_INT 25
85242: DOUBLE
85243: EQUAL
85244: IFTRUE 85248
85246: GO 85304
85248: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
85249: LD_ADDR_VAR 0 9
85253: PUSH
85254: LD_VAR 0 35
85258: PUSH
85259: LD_VAR 0 36
85263: PUSH
85264: LD_VAR 0 37
85268: PUSH
85269: LD_VAR 0 38
85273: PUSH
85274: LD_VAR 0 39
85278: PUSH
85279: LD_VAR 0 40
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: PUSH
85292: LD_VAR 0 4
85296: PUSH
85297: LD_INT 1
85299: PLUS
85300: ARRAY
85301: ST_TO_ADDR
85302: GO 85669
85304: LD_INT 6
85306: DOUBLE
85307: EQUAL
85308: IFTRUE 85360
85310: LD_INT 7
85312: DOUBLE
85313: EQUAL
85314: IFTRUE 85360
85316: LD_INT 8
85318: DOUBLE
85319: EQUAL
85320: IFTRUE 85360
85322: LD_INT 13
85324: DOUBLE
85325: EQUAL
85326: IFTRUE 85360
85328: LD_INT 12
85330: DOUBLE
85331: EQUAL
85332: IFTRUE 85360
85334: LD_INT 15
85336: DOUBLE
85337: EQUAL
85338: IFTRUE 85360
85340: LD_INT 11
85342: DOUBLE
85343: EQUAL
85344: IFTRUE 85360
85346: LD_INT 14
85348: DOUBLE
85349: EQUAL
85350: IFTRUE 85360
85352: LD_INT 10
85354: DOUBLE
85355: EQUAL
85356: IFTRUE 85360
85358: GO 85416
85360: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
85361: LD_ADDR_VAR 0 9
85365: PUSH
85366: LD_VAR 0 41
85370: PUSH
85371: LD_VAR 0 42
85375: PUSH
85376: LD_VAR 0 43
85380: PUSH
85381: LD_VAR 0 44
85385: PUSH
85386: LD_VAR 0 45
85390: PUSH
85391: LD_VAR 0 46
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: PUSH
85404: LD_VAR 0 4
85408: PUSH
85409: LD_INT 1
85411: PLUS
85412: ARRAY
85413: ST_TO_ADDR
85414: GO 85669
85416: LD_INT 36
85418: DOUBLE
85419: EQUAL
85420: IFTRUE 85424
85422: GO 85480
85424: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
85425: LD_ADDR_VAR 0 9
85429: PUSH
85430: LD_VAR 0 47
85434: PUSH
85435: LD_VAR 0 48
85439: PUSH
85440: LD_VAR 0 49
85444: PUSH
85445: LD_VAR 0 50
85449: PUSH
85450: LD_VAR 0 51
85454: PUSH
85455: LD_VAR 0 52
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: LIST
85464: LIST
85465: LIST
85466: LIST
85467: PUSH
85468: LD_VAR 0 4
85472: PUSH
85473: LD_INT 1
85475: PLUS
85476: ARRAY
85477: ST_TO_ADDR
85478: GO 85669
85480: LD_INT 4
85482: DOUBLE
85483: EQUAL
85484: IFTRUE 85506
85486: LD_INT 5
85488: DOUBLE
85489: EQUAL
85490: IFTRUE 85506
85492: LD_INT 34
85494: DOUBLE
85495: EQUAL
85496: IFTRUE 85506
85498: LD_INT 37
85500: DOUBLE
85501: EQUAL
85502: IFTRUE 85506
85504: GO 85562
85506: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
85507: LD_ADDR_VAR 0 9
85511: PUSH
85512: LD_VAR 0 53
85516: PUSH
85517: LD_VAR 0 54
85521: PUSH
85522: LD_VAR 0 55
85526: PUSH
85527: LD_VAR 0 56
85531: PUSH
85532: LD_VAR 0 57
85536: PUSH
85537: LD_VAR 0 58
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: PUSH
85550: LD_VAR 0 4
85554: PUSH
85555: LD_INT 1
85557: PLUS
85558: ARRAY
85559: ST_TO_ADDR
85560: GO 85669
85562: LD_INT 31
85564: DOUBLE
85565: EQUAL
85566: IFTRUE 85612
85568: LD_INT 32
85570: DOUBLE
85571: EQUAL
85572: IFTRUE 85612
85574: LD_INT 33
85576: DOUBLE
85577: EQUAL
85578: IFTRUE 85612
85580: LD_INT 27
85582: DOUBLE
85583: EQUAL
85584: IFTRUE 85612
85586: LD_INT 26
85588: DOUBLE
85589: EQUAL
85590: IFTRUE 85612
85592: LD_INT 28
85594: DOUBLE
85595: EQUAL
85596: IFTRUE 85612
85598: LD_INT 29
85600: DOUBLE
85601: EQUAL
85602: IFTRUE 85612
85604: LD_INT 30
85606: DOUBLE
85607: EQUAL
85608: IFTRUE 85612
85610: GO 85668
85612: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
85613: LD_ADDR_VAR 0 9
85617: PUSH
85618: LD_VAR 0 59
85622: PUSH
85623: LD_VAR 0 60
85627: PUSH
85628: LD_VAR 0 61
85632: PUSH
85633: LD_VAR 0 62
85637: PUSH
85638: LD_VAR 0 63
85642: PUSH
85643: LD_VAR 0 64
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: LIST
85652: LIST
85653: LIST
85654: LIST
85655: PUSH
85656: LD_VAR 0 4
85660: PUSH
85661: LD_INT 1
85663: PLUS
85664: ARRAY
85665: ST_TO_ADDR
85666: GO 85669
85668: POP
// temp_list2 = [ ] ;
85669: LD_ADDR_VAR 0 10
85673: PUSH
85674: EMPTY
85675: ST_TO_ADDR
// for i in temp_list do
85676: LD_ADDR_VAR 0 8
85680: PUSH
85681: LD_VAR 0 9
85685: PUSH
85686: FOR_IN
85687: IFFALSE 85739
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
85689: LD_ADDR_VAR 0 10
85693: PUSH
85694: LD_VAR 0 10
85698: PUSH
85699: LD_VAR 0 8
85703: PUSH
85704: LD_INT 1
85706: ARRAY
85707: PUSH
85708: LD_VAR 0 2
85712: PLUS
85713: PUSH
85714: LD_VAR 0 8
85718: PUSH
85719: LD_INT 2
85721: ARRAY
85722: PUSH
85723: LD_VAR 0 3
85727: PLUS
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: PUSH
85733: EMPTY
85734: LIST
85735: ADD
85736: ST_TO_ADDR
85737: GO 85686
85739: POP
85740: POP
// result = temp_list2 ;
85741: LD_ADDR_VAR 0 7
85745: PUSH
85746: LD_VAR 0 10
85750: ST_TO_ADDR
// end ;
85751: LD_VAR 0 7
85755: RET
// export function EnemyInRange ( unit , dist ) ; begin
85756: LD_INT 0
85758: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
85759: LD_ADDR_VAR 0 3
85763: PUSH
85764: LD_VAR 0 1
85768: PPUSH
85769: CALL_OW 255
85773: PPUSH
85774: LD_VAR 0 1
85778: PPUSH
85779: CALL_OW 250
85783: PPUSH
85784: LD_VAR 0 1
85788: PPUSH
85789: CALL_OW 251
85793: PPUSH
85794: LD_VAR 0 2
85798: PPUSH
85799: CALL 59129 0 4
85803: PUSH
85804: LD_INT 4
85806: ARRAY
85807: ST_TO_ADDR
// end ;
85808: LD_VAR 0 3
85812: RET
// export function PlayerSeeMe ( unit ) ; begin
85813: LD_INT 0
85815: PPUSH
// result := See ( your_side , unit ) ;
85816: LD_ADDR_VAR 0 2
85820: PUSH
85821: LD_OWVAR 2
85825: PPUSH
85826: LD_VAR 0 1
85830: PPUSH
85831: CALL_OW 292
85835: ST_TO_ADDR
// end ;
85836: LD_VAR 0 2
85840: RET
// export function ReverseDir ( unit ) ; begin
85841: LD_INT 0
85843: PPUSH
// if not unit then
85844: LD_VAR 0 1
85848: NOT
85849: IFFALSE 85853
// exit ;
85851: GO 85876
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
85853: LD_ADDR_VAR 0 2
85857: PUSH
85858: LD_VAR 0 1
85862: PPUSH
85863: CALL_OW 254
85867: PUSH
85868: LD_INT 3
85870: PLUS
85871: PUSH
85872: LD_INT 6
85874: MOD
85875: ST_TO_ADDR
// end ;
85876: LD_VAR 0 2
85880: RET
// export function ReverseArray ( array ) ; var i ; begin
85881: LD_INT 0
85883: PPUSH
85884: PPUSH
// if not array then
85885: LD_VAR 0 1
85889: NOT
85890: IFFALSE 85894
// exit ;
85892: GO 85949
// result := [ ] ;
85894: LD_ADDR_VAR 0 2
85898: PUSH
85899: EMPTY
85900: ST_TO_ADDR
// for i := array downto 1 do
85901: LD_ADDR_VAR 0 3
85905: PUSH
85906: DOUBLE
85907: LD_VAR 0 1
85911: INC
85912: ST_TO_ADDR
85913: LD_INT 1
85915: PUSH
85916: FOR_DOWNTO
85917: IFFALSE 85947
// result := Join ( result , array [ i ] ) ;
85919: LD_ADDR_VAR 0 2
85923: PUSH
85924: LD_VAR 0 2
85928: PPUSH
85929: LD_VAR 0 1
85933: PUSH
85934: LD_VAR 0 3
85938: ARRAY
85939: PPUSH
85940: CALL 90605 0 2
85944: ST_TO_ADDR
85945: GO 85916
85947: POP
85948: POP
// end ;
85949: LD_VAR 0 2
85953: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
85954: LD_INT 0
85956: PPUSH
85957: PPUSH
85958: PPUSH
85959: PPUSH
85960: PPUSH
85961: PPUSH
// if not unit or not hexes then
85962: LD_VAR 0 1
85966: NOT
85967: PUSH
85968: LD_VAR 0 2
85972: NOT
85973: OR
85974: IFFALSE 85978
// exit ;
85976: GO 86101
// dist := 9999 ;
85978: LD_ADDR_VAR 0 5
85982: PUSH
85983: LD_INT 9999
85985: ST_TO_ADDR
// for i = 1 to hexes do
85986: LD_ADDR_VAR 0 4
85990: PUSH
85991: DOUBLE
85992: LD_INT 1
85994: DEC
85995: ST_TO_ADDR
85996: LD_VAR 0 2
86000: PUSH
86001: FOR_TO
86002: IFFALSE 86089
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
86004: LD_ADDR_VAR 0 6
86008: PUSH
86009: LD_VAR 0 1
86013: PPUSH
86014: LD_VAR 0 2
86018: PUSH
86019: LD_VAR 0 4
86023: ARRAY
86024: PUSH
86025: LD_INT 1
86027: ARRAY
86028: PPUSH
86029: LD_VAR 0 2
86033: PUSH
86034: LD_VAR 0 4
86038: ARRAY
86039: PUSH
86040: LD_INT 2
86042: ARRAY
86043: PPUSH
86044: CALL_OW 297
86048: ST_TO_ADDR
// if tdist < dist then
86049: LD_VAR 0 6
86053: PUSH
86054: LD_VAR 0 5
86058: LESS
86059: IFFALSE 86087
// begin hex := hexes [ i ] ;
86061: LD_ADDR_VAR 0 8
86065: PUSH
86066: LD_VAR 0 2
86070: PUSH
86071: LD_VAR 0 4
86075: ARRAY
86076: ST_TO_ADDR
// dist := tdist ;
86077: LD_ADDR_VAR 0 5
86081: PUSH
86082: LD_VAR 0 6
86086: ST_TO_ADDR
// end ; end ;
86087: GO 86001
86089: POP
86090: POP
// result := hex ;
86091: LD_ADDR_VAR 0 3
86095: PUSH
86096: LD_VAR 0 8
86100: ST_TO_ADDR
// end ;
86101: LD_VAR 0 3
86105: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
86106: LD_INT 0
86108: PPUSH
86109: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86110: LD_VAR 0 1
86114: NOT
86115: PUSH
86116: LD_VAR 0 1
86120: PUSH
86121: LD_INT 21
86123: PUSH
86124: LD_INT 2
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 23
86133: PUSH
86134: LD_INT 2
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: EMPTY
86142: LIST
86143: LIST
86144: PPUSH
86145: CALL_OW 69
86149: IN
86150: NOT
86151: OR
86152: IFFALSE 86156
// exit ;
86154: GO 86203
// for i = 1 to 3 do
86156: LD_ADDR_VAR 0 3
86160: PUSH
86161: DOUBLE
86162: LD_INT 1
86164: DEC
86165: ST_TO_ADDR
86166: LD_INT 3
86168: PUSH
86169: FOR_TO
86170: IFFALSE 86201
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
86172: LD_VAR 0 1
86176: PPUSH
86177: CALL_OW 250
86181: PPUSH
86182: LD_VAR 0 1
86186: PPUSH
86187: CALL_OW 251
86191: PPUSH
86192: LD_INT 1
86194: PPUSH
86195: CALL_OW 453
86199: GO 86169
86201: POP
86202: POP
// end ;
86203: LD_VAR 0 2
86207: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
86208: LD_INT 0
86210: PPUSH
86211: PPUSH
86212: PPUSH
86213: PPUSH
86214: PPUSH
86215: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
86216: LD_VAR 0 1
86220: NOT
86221: PUSH
86222: LD_VAR 0 2
86226: NOT
86227: OR
86228: PUSH
86229: LD_VAR 0 1
86233: PPUSH
86234: CALL_OW 314
86238: OR
86239: IFFALSE 86243
// exit ;
86241: GO 86710
// if GetLives ( i ) < 250 then
86243: LD_VAR 0 4
86247: PPUSH
86248: CALL_OW 256
86252: PUSH
86253: LD_INT 250
86255: LESS
86256: IFFALSE 86269
// begin ComAutodestruct ( i ) ;
86258: LD_VAR 0 4
86262: PPUSH
86263: CALL 86106 0 1
// exit ;
86267: GO 86710
// end ; x := GetX ( enemy_unit ) ;
86269: LD_ADDR_VAR 0 7
86273: PUSH
86274: LD_VAR 0 2
86278: PPUSH
86279: CALL_OW 250
86283: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
86284: LD_ADDR_VAR 0 8
86288: PUSH
86289: LD_VAR 0 2
86293: PPUSH
86294: CALL_OW 251
86298: ST_TO_ADDR
// if not x or not y then
86299: LD_VAR 0 7
86303: NOT
86304: PUSH
86305: LD_VAR 0 8
86309: NOT
86310: OR
86311: IFFALSE 86315
// exit ;
86313: GO 86710
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
86315: LD_ADDR_VAR 0 6
86319: PUSH
86320: LD_VAR 0 7
86324: PPUSH
86325: LD_INT 0
86327: PPUSH
86328: LD_INT 4
86330: PPUSH
86331: CALL_OW 272
86335: PUSH
86336: LD_VAR 0 8
86340: PPUSH
86341: LD_INT 0
86343: PPUSH
86344: LD_INT 4
86346: PPUSH
86347: CALL_OW 273
86351: PUSH
86352: EMPTY
86353: LIST
86354: LIST
86355: PUSH
86356: LD_VAR 0 7
86360: PPUSH
86361: LD_INT 1
86363: PPUSH
86364: LD_INT 4
86366: PPUSH
86367: CALL_OW 272
86371: PUSH
86372: LD_VAR 0 8
86376: PPUSH
86377: LD_INT 1
86379: PPUSH
86380: LD_INT 4
86382: PPUSH
86383: CALL_OW 273
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: PUSH
86392: LD_VAR 0 7
86396: PPUSH
86397: LD_INT 2
86399: PPUSH
86400: LD_INT 4
86402: PPUSH
86403: CALL_OW 272
86407: PUSH
86408: LD_VAR 0 8
86412: PPUSH
86413: LD_INT 2
86415: PPUSH
86416: LD_INT 4
86418: PPUSH
86419: CALL_OW 273
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_VAR 0 7
86432: PPUSH
86433: LD_INT 3
86435: PPUSH
86436: LD_INT 4
86438: PPUSH
86439: CALL_OW 272
86443: PUSH
86444: LD_VAR 0 8
86448: PPUSH
86449: LD_INT 3
86451: PPUSH
86452: LD_INT 4
86454: PPUSH
86455: CALL_OW 273
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_VAR 0 7
86468: PPUSH
86469: LD_INT 4
86471: PPUSH
86472: LD_INT 4
86474: PPUSH
86475: CALL_OW 272
86479: PUSH
86480: LD_VAR 0 8
86484: PPUSH
86485: LD_INT 4
86487: PPUSH
86488: LD_INT 4
86490: PPUSH
86491: CALL_OW 273
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_VAR 0 7
86504: PPUSH
86505: LD_INT 5
86507: PPUSH
86508: LD_INT 4
86510: PPUSH
86511: CALL_OW 272
86515: PUSH
86516: LD_VAR 0 8
86520: PPUSH
86521: LD_INT 5
86523: PPUSH
86524: LD_INT 4
86526: PPUSH
86527: CALL_OW 273
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: ST_TO_ADDR
// for i = tmp downto 1 do
86544: LD_ADDR_VAR 0 4
86548: PUSH
86549: DOUBLE
86550: LD_VAR 0 6
86554: INC
86555: ST_TO_ADDR
86556: LD_INT 1
86558: PUSH
86559: FOR_DOWNTO
86560: IFFALSE 86661
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
86562: LD_VAR 0 6
86566: PUSH
86567: LD_VAR 0 4
86571: ARRAY
86572: PUSH
86573: LD_INT 1
86575: ARRAY
86576: PPUSH
86577: LD_VAR 0 6
86581: PUSH
86582: LD_VAR 0 4
86586: ARRAY
86587: PUSH
86588: LD_INT 2
86590: ARRAY
86591: PPUSH
86592: CALL_OW 488
86596: NOT
86597: PUSH
86598: LD_VAR 0 6
86602: PUSH
86603: LD_VAR 0 4
86607: ARRAY
86608: PUSH
86609: LD_INT 1
86611: ARRAY
86612: PPUSH
86613: LD_VAR 0 6
86617: PUSH
86618: LD_VAR 0 4
86622: ARRAY
86623: PUSH
86624: LD_INT 2
86626: ARRAY
86627: PPUSH
86628: CALL_OW 428
86632: PUSH
86633: LD_INT 0
86635: NONEQUAL
86636: OR
86637: IFFALSE 86659
// tmp := Delete ( tmp , i ) ;
86639: LD_ADDR_VAR 0 6
86643: PUSH
86644: LD_VAR 0 6
86648: PPUSH
86649: LD_VAR 0 4
86653: PPUSH
86654: CALL_OW 3
86658: ST_TO_ADDR
86659: GO 86559
86661: POP
86662: POP
// j := GetClosestHex ( unit , tmp ) ;
86663: LD_ADDR_VAR 0 5
86667: PUSH
86668: LD_VAR 0 1
86672: PPUSH
86673: LD_VAR 0 6
86677: PPUSH
86678: CALL 85954 0 2
86682: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
86683: LD_VAR 0 1
86687: PPUSH
86688: LD_VAR 0 5
86692: PUSH
86693: LD_INT 1
86695: ARRAY
86696: PPUSH
86697: LD_VAR 0 5
86701: PUSH
86702: LD_INT 2
86704: ARRAY
86705: PPUSH
86706: CALL_OW 111
// end ;
86710: LD_VAR 0 3
86714: RET
// export function PrepareApemanSoldier ( ) ; begin
86715: LD_INT 0
86717: PPUSH
// uc_nation := 0 ;
86718: LD_ADDR_OWVAR 21
86722: PUSH
86723: LD_INT 0
86725: ST_TO_ADDR
// hc_sex := sex_male ;
86726: LD_ADDR_OWVAR 27
86730: PUSH
86731: LD_INT 1
86733: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
86734: LD_ADDR_OWVAR 28
86738: PUSH
86739: LD_INT 15
86741: ST_TO_ADDR
// hc_gallery :=  ;
86742: LD_ADDR_OWVAR 33
86746: PUSH
86747: LD_STRING 
86749: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86750: LD_ADDR_OWVAR 31
86754: PUSH
86755: LD_INT 0
86757: PPUSH
86758: LD_INT 3
86760: PPUSH
86761: CALL_OW 12
86765: PUSH
86766: LD_INT 0
86768: PPUSH
86769: LD_INT 3
86771: PPUSH
86772: CALL_OW 12
86776: PUSH
86777: LD_INT 0
86779: PUSH
86780: LD_INT 0
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: ST_TO_ADDR
// end ;
86789: LD_VAR 0 1
86793: RET
// export function PrepareApemanEngineer ( ) ; begin
86794: LD_INT 0
86796: PPUSH
// uc_nation := 0 ;
86797: LD_ADDR_OWVAR 21
86801: PUSH
86802: LD_INT 0
86804: ST_TO_ADDR
// hc_sex := sex_male ;
86805: LD_ADDR_OWVAR 27
86809: PUSH
86810: LD_INT 1
86812: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
86813: LD_ADDR_OWVAR 28
86817: PUSH
86818: LD_INT 16
86820: ST_TO_ADDR
// hc_gallery :=  ;
86821: LD_ADDR_OWVAR 33
86825: PUSH
86826: LD_STRING 
86828: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86829: LD_ADDR_OWVAR 31
86833: PUSH
86834: LD_INT 0
86836: PPUSH
86837: LD_INT 3
86839: PPUSH
86840: CALL_OW 12
86844: PUSH
86845: LD_INT 0
86847: PPUSH
86848: LD_INT 3
86850: PPUSH
86851: CALL_OW 12
86855: PUSH
86856: LD_INT 0
86858: PUSH
86859: LD_INT 0
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: ST_TO_ADDR
// end ;
86868: LD_VAR 0 1
86872: RET
// export function PrepareApeman ( agressivity ) ; begin
86873: LD_INT 0
86875: PPUSH
// uc_side := 0 ;
86876: LD_ADDR_OWVAR 20
86880: PUSH
86881: LD_INT 0
86883: ST_TO_ADDR
// uc_nation := 0 ;
86884: LD_ADDR_OWVAR 21
86888: PUSH
86889: LD_INT 0
86891: ST_TO_ADDR
// hc_sex := sex_male ;
86892: LD_ADDR_OWVAR 27
86896: PUSH
86897: LD_INT 1
86899: ST_TO_ADDR
// hc_class := class_apeman ;
86900: LD_ADDR_OWVAR 28
86904: PUSH
86905: LD_INT 12
86907: ST_TO_ADDR
// hc_gallery :=  ;
86908: LD_ADDR_OWVAR 33
86912: PUSH
86913: LD_STRING 
86915: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
86916: LD_ADDR_OWVAR 35
86920: PUSH
86921: LD_VAR 0 1
86925: NEG
86926: PPUSH
86927: LD_VAR 0 1
86931: PPUSH
86932: CALL_OW 12
86936: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86937: LD_ADDR_OWVAR 31
86941: PUSH
86942: LD_INT 0
86944: PPUSH
86945: LD_INT 3
86947: PPUSH
86948: CALL_OW 12
86952: PUSH
86953: LD_INT 0
86955: PPUSH
86956: LD_INT 3
86958: PPUSH
86959: CALL_OW 12
86963: PUSH
86964: LD_INT 0
86966: PUSH
86967: LD_INT 0
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: ST_TO_ADDR
// end ;
86976: LD_VAR 0 2
86980: RET
// export function PrepareTiger ( agressivity ) ; begin
86981: LD_INT 0
86983: PPUSH
// uc_side := 0 ;
86984: LD_ADDR_OWVAR 20
86988: PUSH
86989: LD_INT 0
86991: ST_TO_ADDR
// uc_nation := 0 ;
86992: LD_ADDR_OWVAR 21
86996: PUSH
86997: LD_INT 0
86999: ST_TO_ADDR
// hc_class := class_tiger ;
87000: LD_ADDR_OWVAR 28
87004: PUSH
87005: LD_INT 14
87007: ST_TO_ADDR
// hc_gallery :=  ;
87008: LD_ADDR_OWVAR 33
87012: PUSH
87013: LD_STRING 
87015: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87016: LD_ADDR_OWVAR 35
87020: PUSH
87021: LD_VAR 0 1
87025: NEG
87026: PPUSH
87027: LD_VAR 0 1
87031: PPUSH
87032: CALL_OW 12
87036: ST_TO_ADDR
// end ;
87037: LD_VAR 0 2
87041: RET
// export function PrepareEnchidna ( ) ; begin
87042: LD_INT 0
87044: PPUSH
// uc_side := 0 ;
87045: LD_ADDR_OWVAR 20
87049: PUSH
87050: LD_INT 0
87052: ST_TO_ADDR
// uc_nation := 0 ;
87053: LD_ADDR_OWVAR 21
87057: PUSH
87058: LD_INT 0
87060: ST_TO_ADDR
// hc_class := class_baggie ;
87061: LD_ADDR_OWVAR 28
87065: PUSH
87066: LD_INT 13
87068: ST_TO_ADDR
// hc_gallery :=  ;
87069: LD_ADDR_OWVAR 33
87073: PUSH
87074: LD_STRING 
87076: ST_TO_ADDR
// end ;
87077: LD_VAR 0 1
87081: RET
// export function PrepareFrog ( ) ; begin
87082: LD_INT 0
87084: PPUSH
// uc_side := 0 ;
87085: LD_ADDR_OWVAR 20
87089: PUSH
87090: LD_INT 0
87092: ST_TO_ADDR
// uc_nation := 0 ;
87093: LD_ADDR_OWVAR 21
87097: PUSH
87098: LD_INT 0
87100: ST_TO_ADDR
// hc_class := class_frog ;
87101: LD_ADDR_OWVAR 28
87105: PUSH
87106: LD_INT 19
87108: ST_TO_ADDR
// hc_gallery :=  ;
87109: LD_ADDR_OWVAR 33
87113: PUSH
87114: LD_STRING 
87116: ST_TO_ADDR
// end ;
87117: LD_VAR 0 1
87121: RET
// export function PrepareFish ( ) ; begin
87122: LD_INT 0
87124: PPUSH
// uc_side := 0 ;
87125: LD_ADDR_OWVAR 20
87129: PUSH
87130: LD_INT 0
87132: ST_TO_ADDR
// uc_nation := 0 ;
87133: LD_ADDR_OWVAR 21
87137: PUSH
87138: LD_INT 0
87140: ST_TO_ADDR
// hc_class := class_fish ;
87141: LD_ADDR_OWVAR 28
87145: PUSH
87146: LD_INT 20
87148: ST_TO_ADDR
// hc_gallery :=  ;
87149: LD_ADDR_OWVAR 33
87153: PUSH
87154: LD_STRING 
87156: ST_TO_ADDR
// end ;
87157: LD_VAR 0 1
87161: RET
// export function PrepareBird ( ) ; begin
87162: LD_INT 0
87164: PPUSH
// uc_side := 0 ;
87165: LD_ADDR_OWVAR 20
87169: PUSH
87170: LD_INT 0
87172: ST_TO_ADDR
// uc_nation := 0 ;
87173: LD_ADDR_OWVAR 21
87177: PUSH
87178: LD_INT 0
87180: ST_TO_ADDR
// hc_class := class_phororhacos ;
87181: LD_ADDR_OWVAR 28
87185: PUSH
87186: LD_INT 18
87188: ST_TO_ADDR
// hc_gallery :=  ;
87189: LD_ADDR_OWVAR 33
87193: PUSH
87194: LD_STRING 
87196: ST_TO_ADDR
// end ;
87197: LD_VAR 0 1
87201: RET
// export function PrepareHorse ( ) ; begin
87202: LD_INT 0
87204: PPUSH
// uc_side := 0 ;
87205: LD_ADDR_OWVAR 20
87209: PUSH
87210: LD_INT 0
87212: ST_TO_ADDR
// uc_nation := 0 ;
87213: LD_ADDR_OWVAR 21
87217: PUSH
87218: LD_INT 0
87220: ST_TO_ADDR
// hc_class := class_horse ;
87221: LD_ADDR_OWVAR 28
87225: PUSH
87226: LD_INT 21
87228: ST_TO_ADDR
// hc_gallery :=  ;
87229: LD_ADDR_OWVAR 33
87233: PUSH
87234: LD_STRING 
87236: ST_TO_ADDR
// end ;
87237: LD_VAR 0 1
87241: RET
// export function PrepareMastodont ( ) ; begin
87242: LD_INT 0
87244: PPUSH
// uc_side := 0 ;
87245: LD_ADDR_OWVAR 20
87249: PUSH
87250: LD_INT 0
87252: ST_TO_ADDR
// uc_nation := 0 ;
87253: LD_ADDR_OWVAR 21
87257: PUSH
87258: LD_INT 0
87260: ST_TO_ADDR
// vc_chassis := class_mastodont ;
87261: LD_ADDR_OWVAR 37
87265: PUSH
87266: LD_INT 31
87268: ST_TO_ADDR
// vc_control := control_rider ;
87269: LD_ADDR_OWVAR 38
87273: PUSH
87274: LD_INT 4
87276: ST_TO_ADDR
// end ;
87277: LD_VAR 0 1
87281: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
87282: LD_INT 0
87284: PPUSH
87285: PPUSH
87286: PPUSH
// uc_side = 0 ;
87287: LD_ADDR_OWVAR 20
87291: PUSH
87292: LD_INT 0
87294: ST_TO_ADDR
// uc_nation = 0 ;
87295: LD_ADDR_OWVAR 21
87299: PUSH
87300: LD_INT 0
87302: ST_TO_ADDR
// InitHc_All ( ) ;
87303: CALL_OW 584
// InitVc ;
87307: CALL_OW 20
// if mastodonts then
87311: LD_VAR 0 6
87315: IFFALSE 87382
// for i = 1 to mastodonts do
87317: LD_ADDR_VAR 0 11
87321: PUSH
87322: DOUBLE
87323: LD_INT 1
87325: DEC
87326: ST_TO_ADDR
87327: LD_VAR 0 6
87331: PUSH
87332: FOR_TO
87333: IFFALSE 87380
// begin vc_chassis := 31 ;
87335: LD_ADDR_OWVAR 37
87339: PUSH
87340: LD_INT 31
87342: ST_TO_ADDR
// vc_control := control_rider ;
87343: LD_ADDR_OWVAR 38
87347: PUSH
87348: LD_INT 4
87350: ST_TO_ADDR
// animal := CreateVehicle ;
87351: LD_ADDR_VAR 0 12
87355: PUSH
87356: CALL_OW 45
87360: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87361: LD_VAR 0 12
87365: PPUSH
87366: LD_VAR 0 8
87370: PPUSH
87371: LD_INT 0
87373: PPUSH
87374: CALL 89510 0 3
// end ;
87378: GO 87332
87380: POP
87381: POP
// if horses then
87382: LD_VAR 0 5
87386: IFFALSE 87453
// for i = 1 to horses do
87388: LD_ADDR_VAR 0 11
87392: PUSH
87393: DOUBLE
87394: LD_INT 1
87396: DEC
87397: ST_TO_ADDR
87398: LD_VAR 0 5
87402: PUSH
87403: FOR_TO
87404: IFFALSE 87451
// begin hc_class := 21 ;
87406: LD_ADDR_OWVAR 28
87410: PUSH
87411: LD_INT 21
87413: ST_TO_ADDR
// hc_gallery :=  ;
87414: LD_ADDR_OWVAR 33
87418: PUSH
87419: LD_STRING 
87421: ST_TO_ADDR
// animal := CreateHuman ;
87422: LD_ADDR_VAR 0 12
87426: PUSH
87427: CALL_OW 44
87431: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87432: LD_VAR 0 12
87436: PPUSH
87437: LD_VAR 0 8
87441: PPUSH
87442: LD_INT 0
87444: PPUSH
87445: CALL 89510 0 3
// end ;
87449: GO 87403
87451: POP
87452: POP
// if birds then
87453: LD_VAR 0 1
87457: IFFALSE 87524
// for i = 1 to birds do
87459: LD_ADDR_VAR 0 11
87463: PUSH
87464: DOUBLE
87465: LD_INT 1
87467: DEC
87468: ST_TO_ADDR
87469: LD_VAR 0 1
87473: PUSH
87474: FOR_TO
87475: IFFALSE 87522
// begin hc_class := 18 ;
87477: LD_ADDR_OWVAR 28
87481: PUSH
87482: LD_INT 18
87484: ST_TO_ADDR
// hc_gallery =  ;
87485: LD_ADDR_OWVAR 33
87489: PUSH
87490: LD_STRING 
87492: ST_TO_ADDR
// animal := CreateHuman ;
87493: LD_ADDR_VAR 0 12
87497: PUSH
87498: CALL_OW 44
87502: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87503: LD_VAR 0 12
87507: PPUSH
87508: LD_VAR 0 8
87512: PPUSH
87513: LD_INT 0
87515: PPUSH
87516: CALL 89510 0 3
// end ;
87520: GO 87474
87522: POP
87523: POP
// if tigers then
87524: LD_VAR 0 2
87528: IFFALSE 87612
// for i = 1 to tigers do
87530: LD_ADDR_VAR 0 11
87534: PUSH
87535: DOUBLE
87536: LD_INT 1
87538: DEC
87539: ST_TO_ADDR
87540: LD_VAR 0 2
87544: PUSH
87545: FOR_TO
87546: IFFALSE 87610
// begin hc_class = class_tiger ;
87548: LD_ADDR_OWVAR 28
87552: PUSH
87553: LD_INT 14
87555: ST_TO_ADDR
// hc_gallery =  ;
87556: LD_ADDR_OWVAR 33
87560: PUSH
87561: LD_STRING 
87563: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
87564: LD_ADDR_OWVAR 35
87568: PUSH
87569: LD_INT 7
87571: NEG
87572: PPUSH
87573: LD_INT 7
87575: PPUSH
87576: CALL_OW 12
87580: ST_TO_ADDR
// animal := CreateHuman ;
87581: LD_ADDR_VAR 0 12
87585: PUSH
87586: CALL_OW 44
87590: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87591: LD_VAR 0 12
87595: PPUSH
87596: LD_VAR 0 8
87600: PPUSH
87601: LD_INT 0
87603: PPUSH
87604: CALL 89510 0 3
// end ;
87608: GO 87545
87610: POP
87611: POP
// if apemans then
87612: LD_VAR 0 3
87616: IFFALSE 87739
// for i = 1 to apemans do
87618: LD_ADDR_VAR 0 11
87622: PUSH
87623: DOUBLE
87624: LD_INT 1
87626: DEC
87627: ST_TO_ADDR
87628: LD_VAR 0 3
87632: PUSH
87633: FOR_TO
87634: IFFALSE 87737
// begin hc_class = class_apeman ;
87636: LD_ADDR_OWVAR 28
87640: PUSH
87641: LD_INT 12
87643: ST_TO_ADDR
// hc_gallery =  ;
87644: LD_ADDR_OWVAR 33
87648: PUSH
87649: LD_STRING 
87651: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
87652: LD_ADDR_OWVAR 35
87656: PUSH
87657: LD_INT 2
87659: NEG
87660: PPUSH
87661: LD_INT 2
87663: PPUSH
87664: CALL_OW 12
87668: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
87669: LD_ADDR_OWVAR 31
87673: PUSH
87674: LD_INT 1
87676: PPUSH
87677: LD_INT 3
87679: PPUSH
87680: CALL_OW 12
87684: PUSH
87685: LD_INT 1
87687: PPUSH
87688: LD_INT 3
87690: PPUSH
87691: CALL_OW 12
87695: PUSH
87696: LD_INT 0
87698: PUSH
87699: LD_INT 0
87701: PUSH
87702: EMPTY
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: ST_TO_ADDR
// animal := CreateHuman ;
87708: LD_ADDR_VAR 0 12
87712: PUSH
87713: CALL_OW 44
87717: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87718: LD_VAR 0 12
87722: PPUSH
87723: LD_VAR 0 8
87727: PPUSH
87728: LD_INT 0
87730: PPUSH
87731: CALL 89510 0 3
// end ;
87735: GO 87633
87737: POP
87738: POP
// if enchidnas then
87739: LD_VAR 0 4
87743: IFFALSE 87810
// for i = 1 to enchidnas do
87745: LD_ADDR_VAR 0 11
87749: PUSH
87750: DOUBLE
87751: LD_INT 1
87753: DEC
87754: ST_TO_ADDR
87755: LD_VAR 0 4
87759: PUSH
87760: FOR_TO
87761: IFFALSE 87808
// begin hc_class = 13 ;
87763: LD_ADDR_OWVAR 28
87767: PUSH
87768: LD_INT 13
87770: ST_TO_ADDR
// hc_gallery =  ;
87771: LD_ADDR_OWVAR 33
87775: PUSH
87776: LD_STRING 
87778: ST_TO_ADDR
// animal := CreateHuman ;
87779: LD_ADDR_VAR 0 12
87783: PUSH
87784: CALL_OW 44
87788: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87789: LD_VAR 0 12
87793: PPUSH
87794: LD_VAR 0 8
87798: PPUSH
87799: LD_INT 0
87801: PPUSH
87802: CALL 89510 0 3
// end ;
87806: GO 87760
87808: POP
87809: POP
// if fishes then
87810: LD_VAR 0 7
87814: IFFALSE 87881
// for i = 1 to fishes do
87816: LD_ADDR_VAR 0 11
87820: PUSH
87821: DOUBLE
87822: LD_INT 1
87824: DEC
87825: ST_TO_ADDR
87826: LD_VAR 0 7
87830: PUSH
87831: FOR_TO
87832: IFFALSE 87879
// begin hc_class = 20 ;
87834: LD_ADDR_OWVAR 28
87838: PUSH
87839: LD_INT 20
87841: ST_TO_ADDR
// hc_gallery =  ;
87842: LD_ADDR_OWVAR 33
87846: PUSH
87847: LD_STRING 
87849: ST_TO_ADDR
// animal := CreateHuman ;
87850: LD_ADDR_VAR 0 12
87854: PUSH
87855: CALL_OW 44
87859: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
87860: LD_VAR 0 12
87864: PPUSH
87865: LD_VAR 0 9
87869: PPUSH
87870: LD_INT 0
87872: PPUSH
87873: CALL 89510 0 3
// end ;
87877: GO 87831
87879: POP
87880: POP
// end ;
87881: LD_VAR 0 10
87885: RET
// export function WantHeal ( sci , unit ) ; begin
87886: LD_INT 0
87888: PPUSH
// if GetTaskList ( sci ) > 0 then
87889: LD_VAR 0 1
87893: PPUSH
87894: CALL_OW 437
87898: PUSH
87899: LD_INT 0
87901: GREATER
87902: IFFALSE 87972
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
87904: LD_VAR 0 1
87908: PPUSH
87909: CALL_OW 437
87913: PUSH
87914: LD_INT 1
87916: ARRAY
87917: PUSH
87918: LD_INT 1
87920: ARRAY
87921: PUSH
87922: LD_STRING l
87924: EQUAL
87925: PUSH
87926: LD_VAR 0 1
87930: PPUSH
87931: CALL_OW 437
87935: PUSH
87936: LD_INT 1
87938: ARRAY
87939: PUSH
87940: LD_INT 4
87942: ARRAY
87943: PUSH
87944: LD_VAR 0 2
87948: EQUAL
87949: AND
87950: IFFALSE 87962
// result := true else
87952: LD_ADDR_VAR 0 3
87956: PUSH
87957: LD_INT 1
87959: ST_TO_ADDR
87960: GO 87970
// result := false ;
87962: LD_ADDR_VAR 0 3
87966: PUSH
87967: LD_INT 0
87969: ST_TO_ADDR
// end else
87970: GO 87980
// result := false ;
87972: LD_ADDR_VAR 0 3
87976: PUSH
87977: LD_INT 0
87979: ST_TO_ADDR
// end ;
87980: LD_VAR 0 3
87984: RET
// export function HealTarget ( sci ) ; begin
87985: LD_INT 0
87987: PPUSH
// if not sci then
87988: LD_VAR 0 1
87992: NOT
87993: IFFALSE 87997
// exit ;
87995: GO 88062
// result := 0 ;
87997: LD_ADDR_VAR 0 2
88001: PUSH
88002: LD_INT 0
88004: ST_TO_ADDR
// if GetTaskList ( sci ) then
88005: LD_VAR 0 1
88009: PPUSH
88010: CALL_OW 437
88014: IFFALSE 88062
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
88016: LD_VAR 0 1
88020: PPUSH
88021: CALL_OW 437
88025: PUSH
88026: LD_INT 1
88028: ARRAY
88029: PUSH
88030: LD_INT 1
88032: ARRAY
88033: PUSH
88034: LD_STRING l
88036: EQUAL
88037: IFFALSE 88062
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
88039: LD_ADDR_VAR 0 2
88043: PUSH
88044: LD_VAR 0 1
88048: PPUSH
88049: CALL_OW 437
88053: PUSH
88054: LD_INT 1
88056: ARRAY
88057: PUSH
88058: LD_INT 4
88060: ARRAY
88061: ST_TO_ADDR
// end ;
88062: LD_VAR 0 2
88066: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
88067: LD_INT 0
88069: PPUSH
88070: PPUSH
88071: PPUSH
88072: PPUSH
// if not base_units then
88073: LD_VAR 0 1
88077: NOT
88078: IFFALSE 88082
// exit ;
88080: GO 88169
// result := false ;
88082: LD_ADDR_VAR 0 2
88086: PUSH
88087: LD_INT 0
88089: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
88090: LD_ADDR_VAR 0 5
88094: PUSH
88095: LD_VAR 0 1
88099: PPUSH
88100: LD_INT 21
88102: PUSH
88103: LD_INT 3
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PPUSH
88110: CALL_OW 72
88114: ST_TO_ADDR
// if not tmp then
88115: LD_VAR 0 5
88119: NOT
88120: IFFALSE 88124
// exit ;
88122: GO 88169
// for i in tmp do
88124: LD_ADDR_VAR 0 3
88128: PUSH
88129: LD_VAR 0 5
88133: PUSH
88134: FOR_IN
88135: IFFALSE 88167
// begin result := EnemyInRange ( i , 22 ) ;
88137: LD_ADDR_VAR 0 2
88141: PUSH
88142: LD_VAR 0 3
88146: PPUSH
88147: LD_INT 22
88149: PPUSH
88150: CALL 85756 0 2
88154: ST_TO_ADDR
// if result then
88155: LD_VAR 0 2
88159: IFFALSE 88165
// exit ;
88161: POP
88162: POP
88163: GO 88169
// end ;
88165: GO 88134
88167: POP
88168: POP
// end ;
88169: LD_VAR 0 2
88173: RET
// export function FilterByTag ( units , tag ) ; begin
88174: LD_INT 0
88176: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
88177: LD_ADDR_VAR 0 3
88181: PUSH
88182: LD_VAR 0 1
88186: PPUSH
88187: LD_INT 120
88189: PUSH
88190: LD_VAR 0 2
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PPUSH
88199: CALL_OW 72
88203: ST_TO_ADDR
// end ;
88204: LD_VAR 0 3
88208: RET
// export function IsDriver ( un ) ; begin
88209: LD_INT 0
88211: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
88212: LD_ADDR_VAR 0 2
88216: PUSH
88217: LD_VAR 0 1
88221: PUSH
88222: LD_INT 55
88224: PUSH
88225: EMPTY
88226: LIST
88227: PPUSH
88228: CALL_OW 69
88232: IN
88233: ST_TO_ADDR
// end ;
88234: LD_VAR 0 2
88238: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
88239: LD_INT 0
88241: PPUSH
88242: PPUSH
// list := [ ] ;
88243: LD_ADDR_VAR 0 5
88247: PUSH
88248: EMPTY
88249: ST_TO_ADDR
// case d of 0 :
88250: LD_VAR 0 3
88254: PUSH
88255: LD_INT 0
88257: DOUBLE
88258: EQUAL
88259: IFTRUE 88263
88261: GO 88396
88263: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
88264: LD_ADDR_VAR 0 5
88268: PUSH
88269: LD_VAR 0 1
88273: PUSH
88274: LD_INT 4
88276: MINUS
88277: PUSH
88278: LD_VAR 0 2
88282: PUSH
88283: LD_INT 4
88285: MINUS
88286: PUSH
88287: LD_INT 2
88289: PUSH
88290: EMPTY
88291: LIST
88292: LIST
88293: LIST
88294: PUSH
88295: LD_VAR 0 1
88299: PUSH
88300: LD_INT 3
88302: MINUS
88303: PUSH
88304: LD_VAR 0 2
88308: PUSH
88309: LD_INT 1
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: LIST
88316: PUSH
88317: LD_VAR 0 1
88321: PUSH
88322: LD_INT 4
88324: PLUS
88325: PUSH
88326: LD_VAR 0 2
88330: PUSH
88331: LD_INT 4
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: LIST
88338: PUSH
88339: LD_VAR 0 1
88343: PUSH
88344: LD_INT 3
88346: PLUS
88347: PUSH
88348: LD_VAR 0 2
88352: PUSH
88353: LD_INT 3
88355: PLUS
88356: PUSH
88357: LD_INT 5
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: LIST
88364: PUSH
88365: LD_VAR 0 1
88369: PUSH
88370: LD_VAR 0 2
88374: PUSH
88375: LD_INT 4
88377: PLUS
88378: PUSH
88379: LD_INT 0
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: LIST
88386: PUSH
88387: EMPTY
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: ST_TO_ADDR
// end ; 1 :
88394: GO 89094
88396: LD_INT 1
88398: DOUBLE
88399: EQUAL
88400: IFTRUE 88404
88402: GO 88537
88404: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
88405: LD_ADDR_VAR 0 5
88409: PUSH
88410: LD_VAR 0 1
88414: PUSH
88415: LD_VAR 0 2
88419: PUSH
88420: LD_INT 4
88422: MINUS
88423: PUSH
88424: LD_INT 3
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: LIST
88431: PUSH
88432: LD_VAR 0 1
88436: PUSH
88437: LD_INT 3
88439: MINUS
88440: PUSH
88441: LD_VAR 0 2
88445: PUSH
88446: LD_INT 3
88448: MINUS
88449: PUSH
88450: LD_INT 2
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: LIST
88457: PUSH
88458: LD_VAR 0 1
88462: PUSH
88463: LD_INT 4
88465: MINUS
88466: PUSH
88467: LD_VAR 0 2
88471: PUSH
88472: LD_INT 1
88474: PUSH
88475: EMPTY
88476: LIST
88477: LIST
88478: LIST
88479: PUSH
88480: LD_VAR 0 1
88484: PUSH
88485: LD_VAR 0 2
88489: PUSH
88490: LD_INT 3
88492: PLUS
88493: PUSH
88494: LD_INT 0
88496: PUSH
88497: EMPTY
88498: LIST
88499: LIST
88500: LIST
88501: PUSH
88502: LD_VAR 0 1
88506: PUSH
88507: LD_INT 4
88509: PLUS
88510: PUSH
88511: LD_VAR 0 2
88515: PUSH
88516: LD_INT 4
88518: PLUS
88519: PUSH
88520: LD_INT 5
88522: PUSH
88523: EMPTY
88524: LIST
88525: LIST
88526: LIST
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: LIST
88532: LIST
88533: LIST
88534: ST_TO_ADDR
// end ; 2 :
88535: GO 89094
88537: LD_INT 2
88539: DOUBLE
88540: EQUAL
88541: IFTRUE 88545
88543: GO 88674
88545: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88546: LD_ADDR_VAR 0 5
88550: PUSH
88551: LD_VAR 0 1
88555: PUSH
88556: LD_VAR 0 2
88560: PUSH
88561: LD_INT 3
88563: MINUS
88564: PUSH
88565: LD_INT 3
88567: PUSH
88568: EMPTY
88569: LIST
88570: LIST
88571: LIST
88572: PUSH
88573: LD_VAR 0 1
88577: PUSH
88578: LD_INT 4
88580: PLUS
88581: PUSH
88582: LD_VAR 0 2
88586: PUSH
88587: LD_INT 4
88589: PUSH
88590: EMPTY
88591: LIST
88592: LIST
88593: LIST
88594: PUSH
88595: LD_VAR 0 1
88599: PUSH
88600: LD_VAR 0 2
88604: PUSH
88605: LD_INT 4
88607: PLUS
88608: PUSH
88609: LD_INT 0
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: LIST
88616: PUSH
88617: LD_VAR 0 1
88621: PUSH
88622: LD_INT 3
88624: MINUS
88625: PUSH
88626: LD_VAR 0 2
88630: PUSH
88631: LD_INT 1
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: LIST
88638: PUSH
88639: LD_VAR 0 1
88643: PUSH
88644: LD_INT 4
88646: MINUS
88647: PUSH
88648: LD_VAR 0 2
88652: PUSH
88653: LD_INT 4
88655: MINUS
88656: PUSH
88657: LD_INT 2
88659: PUSH
88660: EMPTY
88661: LIST
88662: LIST
88663: LIST
88664: PUSH
88665: EMPTY
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: ST_TO_ADDR
// end ; 3 :
88672: GO 89094
88674: LD_INT 3
88676: DOUBLE
88677: EQUAL
88678: IFTRUE 88682
88680: GO 88815
88682: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
88683: LD_ADDR_VAR 0 5
88687: PUSH
88688: LD_VAR 0 1
88692: PUSH
88693: LD_INT 3
88695: PLUS
88696: PUSH
88697: LD_VAR 0 2
88701: PUSH
88702: LD_INT 4
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: LIST
88709: PUSH
88710: LD_VAR 0 1
88714: PUSH
88715: LD_INT 4
88717: PLUS
88718: PUSH
88719: LD_VAR 0 2
88723: PUSH
88724: LD_INT 4
88726: PLUS
88727: PUSH
88728: LD_INT 5
88730: PUSH
88731: EMPTY
88732: LIST
88733: LIST
88734: LIST
88735: PUSH
88736: LD_VAR 0 1
88740: PUSH
88741: LD_INT 4
88743: MINUS
88744: PUSH
88745: LD_VAR 0 2
88749: PUSH
88750: LD_INT 1
88752: PUSH
88753: EMPTY
88754: LIST
88755: LIST
88756: LIST
88757: PUSH
88758: LD_VAR 0 1
88762: PUSH
88763: LD_VAR 0 2
88767: PUSH
88768: LD_INT 4
88770: MINUS
88771: PUSH
88772: LD_INT 3
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: LIST
88779: PUSH
88780: LD_VAR 0 1
88784: PUSH
88785: LD_INT 3
88787: MINUS
88788: PUSH
88789: LD_VAR 0 2
88793: PUSH
88794: LD_INT 3
88796: MINUS
88797: PUSH
88798: LD_INT 2
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: LIST
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: ST_TO_ADDR
// end ; 4 :
88813: GO 89094
88815: LD_INT 4
88817: DOUBLE
88818: EQUAL
88819: IFTRUE 88823
88821: GO 88956
88823: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88824: LD_ADDR_VAR 0 5
88828: PUSH
88829: LD_VAR 0 1
88833: PUSH
88834: LD_VAR 0 2
88838: PUSH
88839: LD_INT 4
88841: PLUS
88842: PUSH
88843: LD_INT 0
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: LIST
88850: PUSH
88851: LD_VAR 0 1
88855: PUSH
88856: LD_INT 3
88858: PLUS
88859: PUSH
88860: LD_VAR 0 2
88864: PUSH
88865: LD_INT 3
88867: PLUS
88868: PUSH
88869: LD_INT 5
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: LIST
88876: PUSH
88877: LD_VAR 0 1
88881: PUSH
88882: LD_INT 4
88884: PLUS
88885: PUSH
88886: LD_VAR 0 2
88890: PUSH
88891: LD_INT 4
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: LIST
88898: PUSH
88899: LD_VAR 0 1
88903: PUSH
88904: LD_VAR 0 2
88908: PUSH
88909: LD_INT 3
88911: MINUS
88912: PUSH
88913: LD_INT 3
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: LIST
88920: PUSH
88921: LD_VAR 0 1
88925: PUSH
88926: LD_INT 4
88928: MINUS
88929: PUSH
88930: LD_VAR 0 2
88934: PUSH
88935: LD_INT 4
88937: MINUS
88938: PUSH
88939: LD_INT 2
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: LIST
88946: PUSH
88947: EMPTY
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: ST_TO_ADDR
// end ; 5 :
88954: GO 89094
88956: LD_INT 5
88958: DOUBLE
88959: EQUAL
88960: IFTRUE 88964
88962: GO 89093
88964: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88965: LD_ADDR_VAR 0 5
88969: PUSH
88970: LD_VAR 0 1
88974: PUSH
88975: LD_INT 4
88977: MINUS
88978: PUSH
88979: LD_VAR 0 2
88983: PUSH
88984: LD_INT 1
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: LIST
88991: PUSH
88992: LD_VAR 0 1
88996: PUSH
88997: LD_VAR 0 2
89001: PUSH
89002: LD_INT 4
89004: MINUS
89005: PUSH
89006: LD_INT 3
89008: PUSH
89009: EMPTY
89010: LIST
89011: LIST
89012: LIST
89013: PUSH
89014: LD_VAR 0 1
89018: PUSH
89019: LD_INT 4
89021: PLUS
89022: PUSH
89023: LD_VAR 0 2
89027: PUSH
89028: LD_INT 4
89030: PLUS
89031: PUSH
89032: LD_INT 5
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: LIST
89039: PUSH
89040: LD_VAR 0 1
89044: PUSH
89045: LD_INT 3
89047: PLUS
89048: PUSH
89049: LD_VAR 0 2
89053: PUSH
89054: LD_INT 4
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: LIST
89061: PUSH
89062: LD_VAR 0 1
89066: PUSH
89067: LD_VAR 0 2
89071: PUSH
89072: LD_INT 3
89074: PLUS
89075: PUSH
89076: LD_INT 0
89078: PUSH
89079: EMPTY
89080: LIST
89081: LIST
89082: LIST
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: ST_TO_ADDR
// end ; end ;
89091: GO 89094
89093: POP
// result := list ;
89094: LD_ADDR_VAR 0 4
89098: PUSH
89099: LD_VAR 0 5
89103: ST_TO_ADDR
// end ;
89104: LD_VAR 0 4
89108: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
89109: LD_INT 0
89111: PPUSH
89112: PPUSH
89113: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
89114: LD_VAR 0 1
89118: NOT
89119: PUSH
89120: LD_VAR 0 2
89124: PUSH
89125: LD_INT 1
89127: PUSH
89128: LD_INT 2
89130: PUSH
89131: LD_INT 3
89133: PUSH
89134: LD_INT 4
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: IN
89143: NOT
89144: OR
89145: IFFALSE 89149
// exit ;
89147: GO 89232
// tmp := [ ] ;
89149: LD_ADDR_VAR 0 5
89153: PUSH
89154: EMPTY
89155: ST_TO_ADDR
// for i in units do
89156: LD_ADDR_VAR 0 4
89160: PUSH
89161: LD_VAR 0 1
89165: PUSH
89166: FOR_IN
89167: IFFALSE 89201
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
89169: LD_ADDR_VAR 0 5
89173: PUSH
89174: LD_VAR 0 5
89178: PPUSH
89179: LD_VAR 0 4
89183: PPUSH
89184: LD_VAR 0 2
89188: PPUSH
89189: CALL_OW 259
89193: PPUSH
89194: CALL 90605 0 2
89198: ST_TO_ADDR
89199: GO 89166
89201: POP
89202: POP
// if not tmp then
89203: LD_VAR 0 5
89207: NOT
89208: IFFALSE 89212
// exit ;
89210: GO 89232
// result := SortListByListDesc ( units , tmp ) ;
89212: LD_ADDR_VAR 0 3
89216: PUSH
89217: LD_VAR 0 1
89221: PPUSH
89222: LD_VAR 0 5
89226: PPUSH
89227: CALL_OW 77
89231: ST_TO_ADDR
// end ;
89232: LD_VAR 0 3
89236: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
89237: LD_INT 0
89239: PPUSH
89240: PPUSH
89241: PPUSH
// result := false ;
89242: LD_ADDR_VAR 0 3
89246: PUSH
89247: LD_INT 0
89249: ST_TO_ADDR
// if not building then
89250: LD_VAR 0 2
89254: NOT
89255: IFFALSE 89259
// exit ;
89257: GO 89397
// x := GetX ( building ) ;
89259: LD_ADDR_VAR 0 4
89263: PUSH
89264: LD_VAR 0 2
89268: PPUSH
89269: CALL_OW 250
89273: ST_TO_ADDR
// y := GetY ( building ) ;
89274: LD_ADDR_VAR 0 5
89278: PUSH
89279: LD_VAR 0 2
89283: PPUSH
89284: CALL_OW 251
89288: ST_TO_ADDR
// if not x or not y then
89289: LD_VAR 0 4
89293: NOT
89294: PUSH
89295: LD_VAR 0 5
89299: NOT
89300: OR
89301: IFFALSE 89305
// exit ;
89303: GO 89397
// if GetTaskList ( unit ) then
89305: LD_VAR 0 1
89309: PPUSH
89310: CALL_OW 437
89314: IFFALSE 89397
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89316: LD_STRING e
89318: PUSH
89319: LD_VAR 0 1
89323: PPUSH
89324: CALL_OW 437
89328: PUSH
89329: LD_INT 1
89331: ARRAY
89332: PUSH
89333: LD_INT 1
89335: ARRAY
89336: EQUAL
89337: PUSH
89338: LD_VAR 0 4
89342: PUSH
89343: LD_VAR 0 1
89347: PPUSH
89348: CALL_OW 437
89352: PUSH
89353: LD_INT 1
89355: ARRAY
89356: PUSH
89357: LD_INT 2
89359: ARRAY
89360: EQUAL
89361: AND
89362: PUSH
89363: LD_VAR 0 5
89367: PUSH
89368: LD_VAR 0 1
89372: PPUSH
89373: CALL_OW 437
89377: PUSH
89378: LD_INT 1
89380: ARRAY
89381: PUSH
89382: LD_INT 3
89384: ARRAY
89385: EQUAL
89386: AND
89387: IFFALSE 89397
// result := true end ;
89389: LD_ADDR_VAR 0 3
89393: PUSH
89394: LD_INT 1
89396: ST_TO_ADDR
// end ;
89397: LD_VAR 0 3
89401: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
89402: LD_INT 0
89404: PPUSH
// result := false ;
89405: LD_ADDR_VAR 0 4
89409: PUSH
89410: LD_INT 0
89412: ST_TO_ADDR
// if GetTaskList ( unit ) then
89413: LD_VAR 0 1
89417: PPUSH
89418: CALL_OW 437
89422: IFFALSE 89505
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89424: LD_STRING M
89426: PUSH
89427: LD_VAR 0 1
89431: PPUSH
89432: CALL_OW 437
89436: PUSH
89437: LD_INT 1
89439: ARRAY
89440: PUSH
89441: LD_INT 1
89443: ARRAY
89444: EQUAL
89445: PUSH
89446: LD_VAR 0 2
89450: PUSH
89451: LD_VAR 0 1
89455: PPUSH
89456: CALL_OW 437
89460: PUSH
89461: LD_INT 1
89463: ARRAY
89464: PUSH
89465: LD_INT 2
89467: ARRAY
89468: EQUAL
89469: AND
89470: PUSH
89471: LD_VAR 0 3
89475: PUSH
89476: LD_VAR 0 1
89480: PPUSH
89481: CALL_OW 437
89485: PUSH
89486: LD_INT 1
89488: ARRAY
89489: PUSH
89490: LD_INT 3
89492: ARRAY
89493: EQUAL
89494: AND
89495: IFFALSE 89505
// result := true ;
89497: LD_ADDR_VAR 0 4
89501: PUSH
89502: LD_INT 1
89504: ST_TO_ADDR
// end ; end ;
89505: LD_VAR 0 4
89509: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89510: LD_INT 0
89512: PPUSH
89513: PPUSH
89514: PPUSH
89515: PPUSH
// if not unit or not area then
89516: LD_VAR 0 1
89520: NOT
89521: PUSH
89522: LD_VAR 0 2
89526: NOT
89527: OR
89528: IFFALSE 89532
// exit ;
89530: GO 89708
// tmp := AreaToList ( area , i ) ;
89532: LD_ADDR_VAR 0 6
89536: PUSH
89537: LD_VAR 0 2
89541: PPUSH
89542: LD_VAR 0 5
89546: PPUSH
89547: CALL_OW 517
89551: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89552: LD_ADDR_VAR 0 5
89556: PUSH
89557: DOUBLE
89558: LD_INT 1
89560: DEC
89561: ST_TO_ADDR
89562: LD_VAR 0 6
89566: PUSH
89567: LD_INT 1
89569: ARRAY
89570: PUSH
89571: FOR_TO
89572: IFFALSE 89706
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89574: LD_ADDR_VAR 0 7
89578: PUSH
89579: LD_VAR 0 6
89583: PUSH
89584: LD_INT 1
89586: ARRAY
89587: PUSH
89588: LD_VAR 0 5
89592: ARRAY
89593: PUSH
89594: LD_VAR 0 6
89598: PUSH
89599: LD_INT 2
89601: ARRAY
89602: PUSH
89603: LD_VAR 0 5
89607: ARRAY
89608: PUSH
89609: EMPTY
89610: LIST
89611: LIST
89612: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
89613: LD_INT 92
89615: PUSH
89616: LD_VAR 0 7
89620: PUSH
89621: LD_INT 1
89623: ARRAY
89624: PUSH
89625: LD_VAR 0 7
89629: PUSH
89630: LD_INT 2
89632: ARRAY
89633: PUSH
89634: LD_INT 2
89636: PUSH
89637: EMPTY
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: PPUSH
89643: CALL_OW 69
89647: PUSH
89648: LD_INT 0
89650: EQUAL
89651: IFFALSE 89704
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
89653: LD_VAR 0 1
89657: PPUSH
89658: LD_VAR 0 7
89662: PUSH
89663: LD_INT 1
89665: ARRAY
89666: PPUSH
89667: LD_VAR 0 7
89671: PUSH
89672: LD_INT 2
89674: ARRAY
89675: PPUSH
89676: LD_VAR 0 3
89680: PPUSH
89681: CALL_OW 48
// result := IsPlaced ( unit ) ;
89685: LD_ADDR_VAR 0 4
89689: PUSH
89690: LD_VAR 0 1
89694: PPUSH
89695: CALL_OW 305
89699: ST_TO_ADDR
// exit ;
89700: POP
89701: POP
89702: GO 89708
// end ; end ;
89704: GO 89571
89706: POP
89707: POP
// end ;
89708: LD_VAR 0 4
89712: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
89713: LD_INT 0
89715: PPUSH
89716: PPUSH
89717: PPUSH
// if not side or side > 8 then
89718: LD_VAR 0 1
89722: NOT
89723: PUSH
89724: LD_VAR 0 1
89728: PUSH
89729: LD_INT 8
89731: GREATER
89732: OR
89733: IFFALSE 89737
// exit ;
89735: GO 89924
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
89737: LD_ADDR_VAR 0 4
89741: PUSH
89742: LD_INT 22
89744: PUSH
89745: LD_VAR 0 1
89749: PUSH
89750: EMPTY
89751: LIST
89752: LIST
89753: PUSH
89754: LD_INT 21
89756: PUSH
89757: LD_INT 3
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: PPUSH
89768: CALL_OW 69
89772: ST_TO_ADDR
// if not tmp then
89773: LD_VAR 0 4
89777: NOT
89778: IFFALSE 89782
// exit ;
89780: GO 89924
// enable_addtolog := true ;
89782: LD_ADDR_OWVAR 81
89786: PUSH
89787: LD_INT 1
89789: ST_TO_ADDR
// AddToLog ( [ ) ;
89790: LD_STRING [
89792: PPUSH
89793: CALL_OW 561
// for i in tmp do
89797: LD_ADDR_VAR 0 3
89801: PUSH
89802: LD_VAR 0 4
89806: PUSH
89807: FOR_IN
89808: IFFALSE 89915
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
89810: LD_STRING [
89812: PUSH
89813: LD_VAR 0 3
89817: PPUSH
89818: CALL_OW 266
89822: STR
89823: PUSH
89824: LD_STRING , 
89826: STR
89827: PUSH
89828: LD_VAR 0 3
89832: PPUSH
89833: CALL_OW 250
89837: STR
89838: PUSH
89839: LD_STRING , 
89841: STR
89842: PUSH
89843: LD_VAR 0 3
89847: PPUSH
89848: CALL_OW 251
89852: STR
89853: PUSH
89854: LD_STRING , 
89856: STR
89857: PUSH
89858: LD_VAR 0 3
89862: PPUSH
89863: CALL_OW 254
89867: STR
89868: PUSH
89869: LD_STRING , 
89871: STR
89872: PUSH
89873: LD_VAR 0 3
89877: PPUSH
89878: LD_INT 1
89880: PPUSH
89881: CALL_OW 268
89885: STR
89886: PUSH
89887: LD_STRING , 
89889: STR
89890: PUSH
89891: LD_VAR 0 3
89895: PPUSH
89896: LD_INT 2
89898: PPUSH
89899: CALL_OW 268
89903: STR
89904: PUSH
89905: LD_STRING ],
89907: STR
89908: PPUSH
89909: CALL_OW 561
// end ;
89913: GO 89807
89915: POP
89916: POP
// AddToLog ( ]; ) ;
89917: LD_STRING ];
89919: PPUSH
89920: CALL_OW 561
// end ;
89924: LD_VAR 0 2
89928: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89929: LD_INT 0
89931: PPUSH
89932: PPUSH
89933: PPUSH
89934: PPUSH
89935: PPUSH
// if not area or not rate or not max then
89936: LD_VAR 0 1
89940: NOT
89941: PUSH
89942: LD_VAR 0 2
89946: NOT
89947: OR
89948: PUSH
89949: LD_VAR 0 4
89953: NOT
89954: OR
89955: IFFALSE 89959
// exit ;
89957: GO 90148
// while 1 do
89959: LD_INT 1
89961: IFFALSE 90148
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89963: LD_ADDR_VAR 0 9
89967: PUSH
89968: LD_VAR 0 1
89972: PPUSH
89973: LD_INT 1
89975: PPUSH
89976: CALL_OW 287
89980: PUSH
89981: LD_INT 10
89983: MUL
89984: ST_TO_ADDR
// r := rate / 10 ;
89985: LD_ADDR_VAR 0 7
89989: PUSH
89990: LD_VAR 0 2
89994: PUSH
89995: LD_INT 10
89997: DIVREAL
89998: ST_TO_ADDR
// time := 1 1$00 ;
89999: LD_ADDR_VAR 0 8
90003: PUSH
90004: LD_INT 2100
90006: ST_TO_ADDR
// if amount < min then
90007: LD_VAR 0 9
90011: PUSH
90012: LD_VAR 0 3
90016: LESS
90017: IFFALSE 90035
// r := r * 2 else
90019: LD_ADDR_VAR 0 7
90023: PUSH
90024: LD_VAR 0 7
90028: PUSH
90029: LD_INT 2
90031: MUL
90032: ST_TO_ADDR
90033: GO 90061
// if amount > max then
90035: LD_VAR 0 9
90039: PUSH
90040: LD_VAR 0 4
90044: GREATER
90045: IFFALSE 90061
// r := r / 2 ;
90047: LD_ADDR_VAR 0 7
90051: PUSH
90052: LD_VAR 0 7
90056: PUSH
90057: LD_INT 2
90059: DIVREAL
90060: ST_TO_ADDR
// time := time / r ;
90061: LD_ADDR_VAR 0 8
90065: PUSH
90066: LD_VAR 0 8
90070: PUSH
90071: LD_VAR 0 7
90075: DIVREAL
90076: ST_TO_ADDR
// if time < 0 then
90077: LD_VAR 0 8
90081: PUSH
90082: LD_INT 0
90084: LESS
90085: IFFALSE 90102
// time := time * - 1 ;
90087: LD_ADDR_VAR 0 8
90091: PUSH
90092: LD_VAR 0 8
90096: PUSH
90097: LD_INT 1
90099: NEG
90100: MUL
90101: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
90102: LD_VAR 0 8
90106: PUSH
90107: LD_INT 35
90109: PPUSH
90110: LD_INT 875
90112: PPUSH
90113: CALL_OW 12
90117: PLUS
90118: PPUSH
90119: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
90123: LD_INT 1
90125: PPUSH
90126: LD_INT 5
90128: PPUSH
90129: CALL_OW 12
90133: PPUSH
90134: LD_VAR 0 1
90138: PPUSH
90139: LD_INT 1
90141: PPUSH
90142: CALL_OW 55
// end ;
90146: GO 89959
// end ;
90148: LD_VAR 0 5
90152: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
90153: LD_INT 0
90155: PPUSH
90156: PPUSH
90157: PPUSH
90158: PPUSH
90159: PPUSH
90160: PPUSH
90161: PPUSH
90162: PPUSH
// if not turrets or not factories then
90163: LD_VAR 0 1
90167: NOT
90168: PUSH
90169: LD_VAR 0 2
90173: NOT
90174: OR
90175: IFFALSE 90179
// exit ;
90177: GO 90486
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
90179: LD_ADDR_VAR 0 10
90183: PUSH
90184: LD_INT 5
90186: PUSH
90187: LD_INT 6
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 2
90196: PUSH
90197: LD_INT 4
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 3
90206: PUSH
90207: LD_INT 5
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: LIST
90218: PUSH
90219: LD_INT 24
90221: PUSH
90222: LD_INT 25
90224: PUSH
90225: EMPTY
90226: LIST
90227: LIST
90228: PUSH
90229: LD_INT 23
90231: PUSH
90232: LD_INT 27
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 42
90245: PUSH
90246: LD_INT 43
90248: PUSH
90249: EMPTY
90250: LIST
90251: LIST
90252: PUSH
90253: LD_INT 44
90255: PUSH
90256: LD_INT 46
90258: PUSH
90259: EMPTY
90260: LIST
90261: LIST
90262: PUSH
90263: LD_INT 45
90265: PUSH
90266: LD_INT 47
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: PUSH
90273: EMPTY
90274: LIST
90275: LIST
90276: LIST
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: LIST
90282: ST_TO_ADDR
// result := [ ] ;
90283: LD_ADDR_VAR 0 3
90287: PUSH
90288: EMPTY
90289: ST_TO_ADDR
// for i in turrets do
90290: LD_ADDR_VAR 0 4
90294: PUSH
90295: LD_VAR 0 1
90299: PUSH
90300: FOR_IN
90301: IFFALSE 90484
// begin nat := GetNation ( i ) ;
90303: LD_ADDR_VAR 0 7
90307: PUSH
90308: LD_VAR 0 4
90312: PPUSH
90313: CALL_OW 248
90317: ST_TO_ADDR
// weapon := 0 ;
90318: LD_ADDR_VAR 0 8
90322: PUSH
90323: LD_INT 0
90325: ST_TO_ADDR
// if not nat then
90326: LD_VAR 0 7
90330: NOT
90331: IFFALSE 90335
// continue ;
90333: GO 90300
// for j in list [ nat ] do
90335: LD_ADDR_VAR 0 5
90339: PUSH
90340: LD_VAR 0 10
90344: PUSH
90345: LD_VAR 0 7
90349: ARRAY
90350: PUSH
90351: FOR_IN
90352: IFFALSE 90393
// if GetBWeapon ( i ) = j [ 1 ] then
90354: LD_VAR 0 4
90358: PPUSH
90359: CALL_OW 269
90363: PUSH
90364: LD_VAR 0 5
90368: PUSH
90369: LD_INT 1
90371: ARRAY
90372: EQUAL
90373: IFFALSE 90391
// begin weapon := j [ 2 ] ;
90375: LD_ADDR_VAR 0 8
90379: PUSH
90380: LD_VAR 0 5
90384: PUSH
90385: LD_INT 2
90387: ARRAY
90388: ST_TO_ADDR
// break ;
90389: GO 90393
// end ;
90391: GO 90351
90393: POP
90394: POP
// if not weapon then
90395: LD_VAR 0 8
90399: NOT
90400: IFFALSE 90404
// continue ;
90402: GO 90300
// for k in factories do
90404: LD_ADDR_VAR 0 6
90408: PUSH
90409: LD_VAR 0 2
90413: PUSH
90414: FOR_IN
90415: IFFALSE 90480
// begin weapons := AvailableWeaponList ( k ) ;
90417: LD_ADDR_VAR 0 9
90421: PUSH
90422: LD_VAR 0 6
90426: PPUSH
90427: CALL_OW 478
90431: ST_TO_ADDR
// if not weapons then
90432: LD_VAR 0 9
90436: NOT
90437: IFFALSE 90441
// continue ;
90439: GO 90414
// if weapon in weapons then
90441: LD_VAR 0 8
90445: PUSH
90446: LD_VAR 0 9
90450: IN
90451: IFFALSE 90478
// begin result := [ i , weapon ] ;
90453: LD_ADDR_VAR 0 3
90457: PUSH
90458: LD_VAR 0 4
90462: PUSH
90463: LD_VAR 0 8
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: ST_TO_ADDR
// exit ;
90472: POP
90473: POP
90474: POP
90475: POP
90476: GO 90486
// end ; end ;
90478: GO 90414
90480: POP
90481: POP
// end ;
90482: GO 90300
90484: POP
90485: POP
// end ;
90486: LD_VAR 0 3
90490: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
90491: LD_INT 0
90493: PPUSH
// if not side or side > 8 then
90494: LD_VAR 0 3
90498: NOT
90499: PUSH
90500: LD_VAR 0 3
90504: PUSH
90505: LD_INT 8
90507: GREATER
90508: OR
90509: IFFALSE 90513
// exit ;
90511: GO 90572
// if not range then
90513: LD_VAR 0 4
90517: NOT
90518: IFFALSE 90529
// range := - 12 ;
90520: LD_ADDR_VAR 0 4
90524: PUSH
90525: LD_INT 12
90527: NEG
90528: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90529: LD_VAR 0 1
90533: PPUSH
90534: LD_VAR 0 2
90538: PPUSH
90539: LD_VAR 0 3
90543: PPUSH
90544: LD_VAR 0 4
90548: PPUSH
90549: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90553: LD_VAR 0 1
90557: PPUSH
90558: LD_VAR 0 2
90562: PPUSH
90563: LD_VAR 0 3
90567: PPUSH
90568: CALL_OW 331
// end ;
90572: LD_VAR 0 5
90576: RET
// export function Video ( mode ) ; begin
90577: LD_INT 0
90579: PPUSH
// ingame_video = mode ;
90580: LD_ADDR_OWVAR 52
90584: PUSH
90585: LD_VAR 0 1
90589: ST_TO_ADDR
// interface_hidden = mode ;
90590: LD_ADDR_OWVAR 54
90594: PUSH
90595: LD_VAR 0 1
90599: ST_TO_ADDR
// end ;
90600: LD_VAR 0 2
90604: RET
// export function Join ( array , element ) ; begin
90605: LD_INT 0
90607: PPUSH
// result := Replace ( array , array + 1 , element ) ;
90608: LD_ADDR_VAR 0 3
90612: PUSH
90613: LD_VAR 0 1
90617: PPUSH
90618: LD_VAR 0 1
90622: PUSH
90623: LD_INT 1
90625: PLUS
90626: PPUSH
90627: LD_VAR 0 2
90631: PPUSH
90632: CALL_OW 1
90636: ST_TO_ADDR
// end ;
90637: LD_VAR 0 3
90641: RET
// export function JoinUnion ( array , element ) ; begin
90642: LD_INT 0
90644: PPUSH
// result := array union element ;
90645: LD_ADDR_VAR 0 3
90649: PUSH
90650: LD_VAR 0 1
90654: PUSH
90655: LD_VAR 0 2
90659: UNION
90660: ST_TO_ADDR
// end ;
90661: LD_VAR 0 3
90665: RET
// export function GetBehemoths ( side ) ; begin
90666: LD_INT 0
90668: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
90669: LD_ADDR_VAR 0 2
90673: PUSH
90674: LD_INT 22
90676: PUSH
90677: LD_VAR 0 1
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 31
90688: PUSH
90689: LD_INT 25
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PPUSH
90700: CALL_OW 69
90704: ST_TO_ADDR
// end ;
90705: LD_VAR 0 2
90709: RET
// export function Shuffle ( array ) ; var i , index ; begin
90710: LD_INT 0
90712: PPUSH
90713: PPUSH
90714: PPUSH
// result := [ ] ;
90715: LD_ADDR_VAR 0 2
90719: PUSH
90720: EMPTY
90721: ST_TO_ADDR
// if not array then
90722: LD_VAR 0 1
90726: NOT
90727: IFFALSE 90731
// exit ;
90729: GO 90830
// Randomize ;
90731: CALL_OW 10
// for i = array downto 1 do
90735: LD_ADDR_VAR 0 3
90739: PUSH
90740: DOUBLE
90741: LD_VAR 0 1
90745: INC
90746: ST_TO_ADDR
90747: LD_INT 1
90749: PUSH
90750: FOR_DOWNTO
90751: IFFALSE 90828
// begin index := rand ( 1 , array ) ;
90753: LD_ADDR_VAR 0 4
90757: PUSH
90758: LD_INT 1
90760: PPUSH
90761: LD_VAR 0 1
90765: PPUSH
90766: CALL_OW 12
90770: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
90771: LD_ADDR_VAR 0 2
90775: PUSH
90776: LD_VAR 0 2
90780: PPUSH
90781: LD_VAR 0 2
90785: PUSH
90786: LD_INT 1
90788: PLUS
90789: PPUSH
90790: LD_VAR 0 1
90794: PUSH
90795: LD_VAR 0 4
90799: ARRAY
90800: PPUSH
90801: CALL_OW 2
90805: ST_TO_ADDR
// array := Delete ( array , index ) ;
90806: LD_ADDR_VAR 0 1
90810: PUSH
90811: LD_VAR 0 1
90815: PPUSH
90816: LD_VAR 0 4
90820: PPUSH
90821: CALL_OW 3
90825: ST_TO_ADDR
// end ;
90826: GO 90750
90828: POP
90829: POP
// end ;
90830: LD_VAR 0 2
90834: RET
// export function GetBaseMaterials ( base ) ; begin
90835: LD_INT 0
90837: PPUSH
// result := [ 0 , 0 , 0 ] ;
90838: LD_ADDR_VAR 0 2
90842: PUSH
90843: LD_INT 0
90845: PUSH
90846: LD_INT 0
90848: PUSH
90849: LD_INT 0
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: LIST
90856: ST_TO_ADDR
// if not base then
90857: LD_VAR 0 1
90861: NOT
90862: IFFALSE 90866
// exit ;
90864: GO 90915
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
90866: LD_ADDR_VAR 0 2
90870: PUSH
90871: LD_VAR 0 1
90875: PPUSH
90876: LD_INT 1
90878: PPUSH
90879: CALL_OW 275
90883: PUSH
90884: LD_VAR 0 1
90888: PPUSH
90889: LD_INT 2
90891: PPUSH
90892: CALL_OW 275
90896: PUSH
90897: LD_VAR 0 1
90901: PPUSH
90902: LD_INT 3
90904: PPUSH
90905: CALL_OW 275
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: LIST
90914: ST_TO_ADDR
// end ;
90915: LD_VAR 0 2
90919: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
90920: LD_INT 0
90922: PPUSH
90923: PPUSH
// result := array ;
90924: LD_ADDR_VAR 0 3
90928: PUSH
90929: LD_VAR 0 1
90933: ST_TO_ADDR
// if size >= result then
90934: LD_VAR 0 2
90938: PUSH
90939: LD_VAR 0 3
90943: GREATEREQUAL
90944: IFFALSE 90948
// exit ;
90946: GO 90998
// if size then
90948: LD_VAR 0 2
90952: IFFALSE 90998
// for i := array downto size do
90954: LD_ADDR_VAR 0 4
90958: PUSH
90959: DOUBLE
90960: LD_VAR 0 1
90964: INC
90965: ST_TO_ADDR
90966: LD_VAR 0 2
90970: PUSH
90971: FOR_DOWNTO
90972: IFFALSE 90996
// result := Delete ( result , result ) ;
90974: LD_ADDR_VAR 0 3
90978: PUSH
90979: LD_VAR 0 3
90983: PPUSH
90984: LD_VAR 0 3
90988: PPUSH
90989: CALL_OW 3
90993: ST_TO_ADDR
90994: GO 90971
90996: POP
90997: POP
// end ;
90998: LD_VAR 0 3
91002: RET
// export function ComExit ( unit ) ; var tmp ; begin
91003: LD_INT 0
91005: PPUSH
91006: PPUSH
// if not IsInUnit ( unit ) then
91007: LD_VAR 0 1
91011: PPUSH
91012: CALL_OW 310
91016: NOT
91017: IFFALSE 91021
// exit ;
91019: GO 91081
// tmp := IsInUnit ( unit ) ;
91021: LD_ADDR_VAR 0 3
91025: PUSH
91026: LD_VAR 0 1
91030: PPUSH
91031: CALL_OW 310
91035: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
91036: LD_VAR 0 3
91040: PPUSH
91041: CALL_OW 247
91045: PUSH
91046: LD_INT 2
91048: EQUAL
91049: IFFALSE 91062
// ComExitVehicle ( unit ) else
91051: LD_VAR 0 1
91055: PPUSH
91056: CALL_OW 121
91060: GO 91071
// ComExitBuilding ( unit ) ;
91062: LD_VAR 0 1
91066: PPUSH
91067: CALL_OW 122
// result := tmp ;
91071: LD_ADDR_VAR 0 2
91075: PUSH
91076: LD_VAR 0 3
91080: ST_TO_ADDR
// end ;
91081: LD_VAR 0 2
91085: RET
// export function ComExitAll ( units ) ; var i ; begin
91086: LD_INT 0
91088: PPUSH
91089: PPUSH
// if not units then
91090: LD_VAR 0 1
91094: NOT
91095: IFFALSE 91099
// exit ;
91097: GO 91125
// for i in units do
91099: LD_ADDR_VAR 0 3
91103: PUSH
91104: LD_VAR 0 1
91108: PUSH
91109: FOR_IN
91110: IFFALSE 91123
// ComExit ( i ) ;
91112: LD_VAR 0 3
91116: PPUSH
91117: CALL 91003 0 1
91121: GO 91109
91123: POP
91124: POP
// end ;
91125: LD_VAR 0 2
91129: RET
// export function ResetHc ; begin
91130: LD_INT 0
91132: PPUSH
// InitHc ;
91133: CALL_OW 19
// hc_importance := 0 ;
91137: LD_ADDR_OWVAR 32
91141: PUSH
91142: LD_INT 0
91144: ST_TO_ADDR
// end ;
91145: LD_VAR 0 1
91149: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
91150: LD_INT 0
91152: PPUSH
91153: PPUSH
91154: PPUSH
// _x := ( x1 + x2 ) div 2 ;
91155: LD_ADDR_VAR 0 6
91159: PUSH
91160: LD_VAR 0 1
91164: PUSH
91165: LD_VAR 0 3
91169: PLUS
91170: PUSH
91171: LD_INT 2
91173: DIV
91174: ST_TO_ADDR
// if _x < 0 then
91175: LD_VAR 0 6
91179: PUSH
91180: LD_INT 0
91182: LESS
91183: IFFALSE 91200
// _x := _x * - 1 ;
91185: LD_ADDR_VAR 0 6
91189: PUSH
91190: LD_VAR 0 6
91194: PUSH
91195: LD_INT 1
91197: NEG
91198: MUL
91199: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
91200: LD_ADDR_VAR 0 7
91204: PUSH
91205: LD_VAR 0 2
91209: PUSH
91210: LD_VAR 0 4
91214: PLUS
91215: PUSH
91216: LD_INT 2
91218: DIV
91219: ST_TO_ADDR
// if _y < 0 then
91220: LD_VAR 0 7
91224: PUSH
91225: LD_INT 0
91227: LESS
91228: IFFALSE 91245
// _y := _y * - 1 ;
91230: LD_ADDR_VAR 0 7
91234: PUSH
91235: LD_VAR 0 7
91239: PUSH
91240: LD_INT 1
91242: NEG
91243: MUL
91244: ST_TO_ADDR
// result := [ _x , _y ] ;
91245: LD_ADDR_VAR 0 5
91249: PUSH
91250: LD_VAR 0 6
91254: PUSH
91255: LD_VAR 0 7
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: ST_TO_ADDR
// end ;
91264: LD_VAR 0 5
91268: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
91269: LD_INT 0
91271: PPUSH
91272: PPUSH
91273: PPUSH
91274: PPUSH
// task := GetTaskList ( unit ) ;
91275: LD_ADDR_VAR 0 7
91279: PUSH
91280: LD_VAR 0 1
91284: PPUSH
91285: CALL_OW 437
91289: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
91290: LD_VAR 0 7
91294: NOT
91295: PUSH
91296: LD_VAR 0 1
91300: PPUSH
91301: LD_VAR 0 2
91305: PPUSH
91306: CALL_OW 308
91310: NOT
91311: AND
91312: IFFALSE 91316
// exit ;
91314: GO 91434
// if IsInArea ( unit , area ) then
91316: LD_VAR 0 1
91320: PPUSH
91321: LD_VAR 0 2
91325: PPUSH
91326: CALL_OW 308
91330: IFFALSE 91348
// begin ComMoveToArea ( unit , goAway ) ;
91332: LD_VAR 0 1
91336: PPUSH
91337: LD_VAR 0 3
91341: PPUSH
91342: CALL_OW 113
// exit ;
91346: GO 91434
// end ; if task [ 1 ] [ 1 ] <> M then
91348: LD_VAR 0 7
91352: PUSH
91353: LD_INT 1
91355: ARRAY
91356: PUSH
91357: LD_INT 1
91359: ARRAY
91360: PUSH
91361: LD_STRING M
91363: NONEQUAL
91364: IFFALSE 91368
// exit ;
91366: GO 91434
// x := task [ 1 ] [ 2 ] ;
91368: LD_ADDR_VAR 0 5
91372: PUSH
91373: LD_VAR 0 7
91377: PUSH
91378: LD_INT 1
91380: ARRAY
91381: PUSH
91382: LD_INT 2
91384: ARRAY
91385: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
91386: LD_ADDR_VAR 0 6
91390: PUSH
91391: LD_VAR 0 7
91395: PUSH
91396: LD_INT 1
91398: ARRAY
91399: PUSH
91400: LD_INT 3
91402: ARRAY
91403: ST_TO_ADDR
// if InArea ( x , y , area ) then
91404: LD_VAR 0 5
91408: PPUSH
91409: LD_VAR 0 6
91413: PPUSH
91414: LD_VAR 0 2
91418: PPUSH
91419: CALL_OW 309
91423: IFFALSE 91434
// ComStop ( unit ) ;
91425: LD_VAR 0 1
91429: PPUSH
91430: CALL_OW 141
// end ;
91434: LD_VAR 0 4
91438: RET
// export function Abs ( value ) ; begin
91439: LD_INT 0
91441: PPUSH
// result := value ;
91442: LD_ADDR_VAR 0 2
91446: PUSH
91447: LD_VAR 0 1
91451: ST_TO_ADDR
// if value < 0 then
91452: LD_VAR 0 1
91456: PUSH
91457: LD_INT 0
91459: LESS
91460: IFFALSE 91477
// result := value * - 1 ;
91462: LD_ADDR_VAR 0 2
91466: PUSH
91467: LD_VAR 0 1
91471: PUSH
91472: LD_INT 1
91474: NEG
91475: MUL
91476: ST_TO_ADDR
// end ;
91477: LD_VAR 0 2
91481: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
91482: LD_INT 0
91484: PPUSH
91485: PPUSH
91486: PPUSH
91487: PPUSH
91488: PPUSH
91489: PPUSH
91490: PPUSH
91491: PPUSH
// if not unit or not building then
91492: LD_VAR 0 1
91496: NOT
91497: PUSH
91498: LD_VAR 0 2
91502: NOT
91503: OR
91504: IFFALSE 91508
// exit ;
91506: GO 91734
// x := GetX ( building ) ;
91508: LD_ADDR_VAR 0 4
91512: PUSH
91513: LD_VAR 0 2
91517: PPUSH
91518: CALL_OW 250
91522: ST_TO_ADDR
// y := GetY ( building ) ;
91523: LD_ADDR_VAR 0 6
91527: PUSH
91528: LD_VAR 0 2
91532: PPUSH
91533: CALL_OW 251
91537: ST_TO_ADDR
// d := GetDir ( building ) ;
91538: LD_ADDR_VAR 0 8
91542: PUSH
91543: LD_VAR 0 2
91547: PPUSH
91548: CALL_OW 254
91552: ST_TO_ADDR
// r := 4 ;
91553: LD_ADDR_VAR 0 9
91557: PUSH
91558: LD_INT 4
91560: ST_TO_ADDR
// for i := 1 to 5 do
91561: LD_ADDR_VAR 0 10
91565: PUSH
91566: DOUBLE
91567: LD_INT 1
91569: DEC
91570: ST_TO_ADDR
91571: LD_INT 5
91573: PUSH
91574: FOR_TO
91575: IFFALSE 91732
// begin _x := ShiftX ( x , d , r + i ) ;
91577: LD_ADDR_VAR 0 5
91581: PUSH
91582: LD_VAR 0 4
91586: PPUSH
91587: LD_VAR 0 8
91591: PPUSH
91592: LD_VAR 0 9
91596: PUSH
91597: LD_VAR 0 10
91601: PLUS
91602: PPUSH
91603: CALL_OW 272
91607: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
91608: LD_ADDR_VAR 0 7
91612: PUSH
91613: LD_VAR 0 6
91617: PPUSH
91618: LD_VAR 0 8
91622: PPUSH
91623: LD_VAR 0 9
91627: PUSH
91628: LD_VAR 0 10
91632: PLUS
91633: PPUSH
91634: CALL_OW 273
91638: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
91639: LD_VAR 0 5
91643: PPUSH
91644: LD_VAR 0 7
91648: PPUSH
91649: CALL_OW 488
91653: PUSH
91654: LD_VAR 0 5
91658: PPUSH
91659: LD_VAR 0 7
91663: PPUSH
91664: CALL_OW 428
91668: PPUSH
91669: CALL_OW 247
91673: PUSH
91674: LD_INT 3
91676: PUSH
91677: LD_INT 2
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: IN
91684: NOT
91685: AND
91686: IFFALSE 91730
// begin ComMoveXY ( unit , _x , _y ) ;
91688: LD_VAR 0 1
91692: PPUSH
91693: LD_VAR 0 5
91697: PPUSH
91698: LD_VAR 0 7
91702: PPUSH
91703: CALL_OW 111
// result := [ _x , _y ] ;
91707: LD_ADDR_VAR 0 3
91711: PUSH
91712: LD_VAR 0 5
91716: PUSH
91717: LD_VAR 0 7
91721: PUSH
91722: EMPTY
91723: LIST
91724: LIST
91725: ST_TO_ADDR
// exit ;
91726: POP
91727: POP
91728: GO 91734
// end ; end ;
91730: GO 91574
91732: POP
91733: POP
// end ;
91734: LD_VAR 0 3
91738: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
91739: LD_INT 0
91741: PPUSH
91742: PPUSH
91743: PPUSH
// result := 0 ;
91744: LD_ADDR_VAR 0 3
91748: PUSH
91749: LD_INT 0
91751: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
91752: LD_VAR 0 1
91756: PUSH
91757: LD_INT 0
91759: LESS
91760: PUSH
91761: LD_VAR 0 1
91765: PUSH
91766: LD_INT 8
91768: GREATER
91769: OR
91770: PUSH
91771: LD_VAR 0 2
91775: PUSH
91776: LD_INT 0
91778: LESS
91779: OR
91780: PUSH
91781: LD_VAR 0 2
91785: PUSH
91786: LD_INT 8
91788: GREATER
91789: OR
91790: IFFALSE 91794
// exit ;
91792: GO 91869
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
91794: LD_ADDR_VAR 0 4
91798: PUSH
91799: LD_INT 22
91801: PUSH
91802: LD_VAR 0 2
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PPUSH
91811: CALL_OW 69
91815: PUSH
91816: FOR_IN
91817: IFFALSE 91867
// begin un := UnitShoot ( i ) ;
91819: LD_ADDR_VAR 0 5
91823: PUSH
91824: LD_VAR 0 4
91828: PPUSH
91829: CALL_OW 504
91833: ST_TO_ADDR
// if GetSide ( un ) = side1 then
91834: LD_VAR 0 5
91838: PPUSH
91839: CALL_OW 255
91843: PUSH
91844: LD_VAR 0 1
91848: EQUAL
91849: IFFALSE 91865
// begin result := un ;
91851: LD_ADDR_VAR 0 3
91855: PUSH
91856: LD_VAR 0 5
91860: ST_TO_ADDR
// exit ;
91861: POP
91862: POP
91863: GO 91869
// end ; end ;
91865: GO 91816
91867: POP
91868: POP
// end ;
91869: LD_VAR 0 3
91873: RET
// export function GetCargoBay ( units ) ; begin
91874: LD_INT 0
91876: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
91877: LD_ADDR_VAR 0 2
91881: PUSH
91882: LD_VAR 0 1
91886: PPUSH
91887: LD_INT 2
91889: PUSH
91890: LD_INT 34
91892: PUSH
91893: LD_INT 12
91895: PUSH
91896: EMPTY
91897: LIST
91898: LIST
91899: PUSH
91900: LD_INT 34
91902: PUSH
91903: LD_INT 51
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: PUSH
91910: LD_INT 34
91912: PUSH
91913: LD_INT 32
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: LD_INT 34
91922: PUSH
91923: LD_INT 89
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: PUSH
91930: EMPTY
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: PPUSH
91937: CALL_OW 72
91941: ST_TO_ADDR
// end ;
91942: LD_VAR 0 2
91946: RET
// export function Negate ( value ) ; begin
91947: LD_INT 0
91949: PPUSH
// result := not value ;
91950: LD_ADDR_VAR 0 2
91954: PUSH
91955: LD_VAR 0 1
91959: NOT
91960: ST_TO_ADDR
// end ;
91961: LD_VAR 0 2
91965: RET
// export function Inc ( value ) ; begin
91966: LD_INT 0
91968: PPUSH
// result := value + 1 ;
91969: LD_ADDR_VAR 0 2
91973: PUSH
91974: LD_VAR 0 1
91978: PUSH
91979: LD_INT 1
91981: PLUS
91982: ST_TO_ADDR
// end ;
91983: LD_VAR 0 2
91987: RET
// export function Dec ( value ) ; begin
91988: LD_INT 0
91990: PPUSH
// result := value - 1 ;
91991: LD_ADDR_VAR 0 2
91995: PUSH
91996: LD_VAR 0 1
92000: PUSH
92001: LD_INT 1
92003: MINUS
92004: ST_TO_ADDR
// end ;
92005: LD_VAR 0 2
92009: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
92010: LD_INT 0
92012: PPUSH
92013: PPUSH
92014: PPUSH
92015: PPUSH
92016: PPUSH
92017: PPUSH
92018: PPUSH
92019: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
92020: LD_VAR 0 1
92024: PPUSH
92025: LD_VAR 0 2
92029: PPUSH
92030: CALL_OW 488
92034: NOT
92035: PUSH
92036: LD_VAR 0 3
92040: PPUSH
92041: LD_VAR 0 4
92045: PPUSH
92046: CALL_OW 488
92050: NOT
92051: OR
92052: IFFALSE 92065
// begin result := - 1 ;
92054: LD_ADDR_VAR 0 5
92058: PUSH
92059: LD_INT 1
92061: NEG
92062: ST_TO_ADDR
// exit ;
92063: GO 92300
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
92065: LD_ADDR_VAR 0 12
92069: PUSH
92070: LD_VAR 0 1
92074: PPUSH
92075: LD_VAR 0 2
92079: PPUSH
92080: LD_VAR 0 3
92084: PPUSH
92085: LD_VAR 0 4
92089: PPUSH
92090: CALL 91150 0 4
92094: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
92095: LD_ADDR_VAR 0 11
92099: PUSH
92100: LD_VAR 0 1
92104: PPUSH
92105: LD_VAR 0 2
92109: PPUSH
92110: LD_VAR 0 12
92114: PUSH
92115: LD_INT 1
92117: ARRAY
92118: PPUSH
92119: LD_VAR 0 12
92123: PUSH
92124: LD_INT 2
92126: ARRAY
92127: PPUSH
92128: CALL_OW 298
92132: ST_TO_ADDR
// distance := 9999 ;
92133: LD_ADDR_VAR 0 10
92137: PUSH
92138: LD_INT 9999
92140: ST_TO_ADDR
// for i := 0 to 5 do
92141: LD_ADDR_VAR 0 6
92145: PUSH
92146: DOUBLE
92147: LD_INT 0
92149: DEC
92150: ST_TO_ADDR
92151: LD_INT 5
92153: PUSH
92154: FOR_TO
92155: IFFALSE 92298
// begin _x := ShiftX ( x1 , i , centerDist ) ;
92157: LD_ADDR_VAR 0 7
92161: PUSH
92162: LD_VAR 0 1
92166: PPUSH
92167: LD_VAR 0 6
92171: PPUSH
92172: LD_VAR 0 11
92176: PPUSH
92177: CALL_OW 272
92181: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
92182: LD_ADDR_VAR 0 8
92186: PUSH
92187: LD_VAR 0 2
92191: PPUSH
92192: LD_VAR 0 6
92196: PPUSH
92197: LD_VAR 0 11
92201: PPUSH
92202: CALL_OW 273
92206: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
92207: LD_VAR 0 7
92211: PPUSH
92212: LD_VAR 0 8
92216: PPUSH
92217: CALL_OW 488
92221: NOT
92222: IFFALSE 92226
// continue ;
92224: GO 92154
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
92226: LD_ADDR_VAR 0 9
92230: PUSH
92231: LD_VAR 0 12
92235: PUSH
92236: LD_INT 1
92238: ARRAY
92239: PPUSH
92240: LD_VAR 0 12
92244: PUSH
92245: LD_INT 2
92247: ARRAY
92248: PPUSH
92249: LD_VAR 0 7
92253: PPUSH
92254: LD_VAR 0 8
92258: PPUSH
92259: CALL_OW 298
92263: ST_TO_ADDR
// if tmp < distance then
92264: LD_VAR 0 9
92268: PUSH
92269: LD_VAR 0 10
92273: LESS
92274: IFFALSE 92296
// begin result := i ;
92276: LD_ADDR_VAR 0 5
92280: PUSH
92281: LD_VAR 0 6
92285: ST_TO_ADDR
// distance := tmp ;
92286: LD_ADDR_VAR 0 10
92290: PUSH
92291: LD_VAR 0 9
92295: ST_TO_ADDR
// end ; end ;
92296: GO 92154
92298: POP
92299: POP
// end ;
92300: LD_VAR 0 5
92304: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92305: LD_INT 0
92307: PPUSH
92308: PPUSH
// if not driver or not IsInUnit ( driver ) then
92309: LD_VAR 0 1
92313: NOT
92314: PUSH
92315: LD_VAR 0 1
92319: PPUSH
92320: CALL_OW 310
92324: NOT
92325: OR
92326: IFFALSE 92330
// exit ;
92328: GO 92420
// vehicle := IsInUnit ( driver ) ;
92330: LD_ADDR_VAR 0 3
92334: PUSH
92335: LD_VAR 0 1
92339: PPUSH
92340: CALL_OW 310
92344: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92345: LD_VAR 0 1
92349: PPUSH
92350: LD_STRING \
92352: PUSH
92353: LD_INT 0
92355: PUSH
92356: LD_INT 0
92358: PUSH
92359: LD_INT 0
92361: PUSH
92362: LD_INT 0
92364: PUSH
92365: LD_INT 0
92367: PUSH
92368: LD_INT 0
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: PUSH
92380: LD_STRING E
92382: PUSH
92383: LD_INT 0
92385: PUSH
92386: LD_INT 0
92388: PUSH
92389: LD_VAR 0 3
92393: PUSH
92394: LD_INT 0
92396: PUSH
92397: LD_INT 0
92399: PUSH
92400: LD_INT 0
92402: PUSH
92403: EMPTY
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PPUSH
92416: CALL_OW 446
// end ;
92420: LD_VAR 0 2
92424: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92425: LD_INT 0
92427: PPUSH
92428: PPUSH
// if not driver or not IsInUnit ( driver ) then
92429: LD_VAR 0 1
92433: NOT
92434: PUSH
92435: LD_VAR 0 1
92439: PPUSH
92440: CALL_OW 310
92444: NOT
92445: OR
92446: IFFALSE 92450
// exit ;
92448: GO 92540
// vehicle := IsInUnit ( driver ) ;
92450: LD_ADDR_VAR 0 3
92454: PUSH
92455: LD_VAR 0 1
92459: PPUSH
92460: CALL_OW 310
92464: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92465: LD_VAR 0 1
92469: PPUSH
92470: LD_STRING \
92472: PUSH
92473: LD_INT 0
92475: PUSH
92476: LD_INT 0
92478: PUSH
92479: LD_INT 0
92481: PUSH
92482: LD_INT 0
92484: PUSH
92485: LD_INT 0
92487: PUSH
92488: LD_INT 0
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: PUSH
92500: LD_STRING E
92502: PUSH
92503: LD_INT 0
92505: PUSH
92506: LD_INT 0
92508: PUSH
92509: LD_VAR 0 3
92513: PUSH
92514: LD_INT 0
92516: PUSH
92517: LD_INT 0
92519: PUSH
92520: LD_INT 0
92522: PUSH
92523: EMPTY
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: PPUSH
92536: CALL_OW 447
// end ;
92540: LD_VAR 0 2
92544: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
92545: LD_INT 0
92547: PPUSH
92548: PPUSH
92549: PPUSH
// tmp := [ ] ;
92550: LD_ADDR_VAR 0 5
92554: PUSH
92555: EMPTY
92556: ST_TO_ADDR
// for i in units do
92557: LD_ADDR_VAR 0 4
92561: PUSH
92562: LD_VAR 0 1
92566: PUSH
92567: FOR_IN
92568: IFFALSE 92606
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
92570: LD_ADDR_VAR 0 5
92574: PUSH
92575: LD_VAR 0 5
92579: PPUSH
92580: LD_VAR 0 5
92584: PUSH
92585: LD_INT 1
92587: PLUS
92588: PPUSH
92589: LD_VAR 0 4
92593: PPUSH
92594: CALL_OW 256
92598: PPUSH
92599: CALL_OW 2
92603: ST_TO_ADDR
92604: GO 92567
92606: POP
92607: POP
// if not tmp then
92608: LD_VAR 0 5
92612: NOT
92613: IFFALSE 92617
// exit ;
92615: GO 92665
// if asc then
92617: LD_VAR 0 2
92621: IFFALSE 92645
// result := SortListByListAsc ( units , tmp ) else
92623: LD_ADDR_VAR 0 3
92627: PUSH
92628: LD_VAR 0 1
92632: PPUSH
92633: LD_VAR 0 5
92637: PPUSH
92638: CALL_OW 76
92642: ST_TO_ADDR
92643: GO 92665
// result := SortListByListDesc ( units , tmp ) ;
92645: LD_ADDR_VAR 0 3
92649: PUSH
92650: LD_VAR 0 1
92654: PPUSH
92655: LD_VAR 0 5
92659: PPUSH
92660: CALL_OW 77
92664: ST_TO_ADDR
// end ;
92665: LD_VAR 0 3
92669: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
92670: LD_INT 0
92672: PPUSH
92673: PPUSH
// task := GetTaskList ( mech ) ;
92674: LD_ADDR_VAR 0 4
92678: PUSH
92679: LD_VAR 0 1
92683: PPUSH
92684: CALL_OW 437
92688: ST_TO_ADDR
// if not task then
92689: LD_VAR 0 4
92693: NOT
92694: IFFALSE 92698
// exit ;
92696: GO 92740
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
92698: LD_ADDR_VAR 0 3
92702: PUSH
92703: LD_VAR 0 4
92707: PUSH
92708: LD_INT 1
92710: ARRAY
92711: PUSH
92712: LD_INT 1
92714: ARRAY
92715: PUSH
92716: LD_STRING r
92718: EQUAL
92719: PUSH
92720: LD_VAR 0 4
92724: PUSH
92725: LD_INT 1
92727: ARRAY
92728: PUSH
92729: LD_INT 4
92731: ARRAY
92732: PUSH
92733: LD_VAR 0 2
92737: EQUAL
92738: AND
92739: ST_TO_ADDR
// end ;
92740: LD_VAR 0 3
92744: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
92745: LD_INT 0
92747: PPUSH
// SetDir ( unit , d ) ;
92748: LD_VAR 0 1
92752: PPUSH
92753: LD_VAR 0 4
92757: PPUSH
92758: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
92762: LD_VAR 0 1
92766: PPUSH
92767: LD_VAR 0 2
92771: PPUSH
92772: LD_VAR 0 3
92776: PPUSH
92777: LD_VAR 0 5
92781: PPUSH
92782: CALL_OW 48
// end ;
92786: LD_VAR 0 6
92790: RET
// export function ToNaturalNumber ( number ) ; begin
92791: LD_INT 0
92793: PPUSH
// result := number div 1 ;
92794: LD_ADDR_VAR 0 2
92798: PUSH
92799: LD_VAR 0 1
92803: PUSH
92804: LD_INT 1
92806: DIV
92807: ST_TO_ADDR
// if number < 0 then
92808: LD_VAR 0 1
92812: PUSH
92813: LD_INT 0
92815: LESS
92816: IFFALSE 92826
// result := 0 ;
92818: LD_ADDR_VAR 0 2
92822: PUSH
92823: LD_INT 0
92825: ST_TO_ADDR
// end ;
92826: LD_VAR 0 2
92830: RET
// export function SortByClass ( units , class ) ; var un ; begin
92831: LD_INT 0
92833: PPUSH
92834: PPUSH
// if not units or not class then
92835: LD_VAR 0 1
92839: NOT
92840: PUSH
92841: LD_VAR 0 2
92845: NOT
92846: OR
92847: IFFALSE 92851
// exit ;
92849: GO 92946
// result := [ ] ;
92851: LD_ADDR_VAR 0 3
92855: PUSH
92856: EMPTY
92857: ST_TO_ADDR
// for un in units do
92858: LD_ADDR_VAR 0 4
92862: PUSH
92863: LD_VAR 0 1
92867: PUSH
92868: FOR_IN
92869: IFFALSE 92944
// if GetClass ( un ) = class then
92871: LD_VAR 0 4
92875: PPUSH
92876: CALL_OW 257
92880: PUSH
92881: LD_VAR 0 2
92885: EQUAL
92886: IFFALSE 92913
// result := Insert ( result , 1 , un ) else
92888: LD_ADDR_VAR 0 3
92892: PUSH
92893: LD_VAR 0 3
92897: PPUSH
92898: LD_INT 1
92900: PPUSH
92901: LD_VAR 0 4
92905: PPUSH
92906: CALL_OW 2
92910: ST_TO_ADDR
92911: GO 92942
// result := Replace ( result , result + 1 , un ) ;
92913: LD_ADDR_VAR 0 3
92917: PUSH
92918: LD_VAR 0 3
92922: PPUSH
92923: LD_VAR 0 3
92927: PUSH
92928: LD_INT 1
92930: PLUS
92931: PPUSH
92932: LD_VAR 0 4
92936: PPUSH
92937: CALL_OW 1
92941: ST_TO_ADDR
92942: GO 92868
92944: POP
92945: POP
// end ;
92946: LD_VAR 0 3
92950: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
92951: LD_INT 0
92953: PPUSH
92954: PPUSH
92955: PPUSH
92956: PPUSH
92957: PPUSH
92958: PPUSH
92959: PPUSH
// result := [ ] ;
92960: LD_ADDR_VAR 0 4
92964: PUSH
92965: EMPTY
92966: ST_TO_ADDR
// if x - r < 0 then
92967: LD_VAR 0 1
92971: PUSH
92972: LD_VAR 0 3
92976: MINUS
92977: PUSH
92978: LD_INT 0
92980: LESS
92981: IFFALSE 92993
// min_x := 0 else
92983: LD_ADDR_VAR 0 8
92987: PUSH
92988: LD_INT 0
92990: ST_TO_ADDR
92991: GO 93009
// min_x := x - r ;
92993: LD_ADDR_VAR 0 8
92997: PUSH
92998: LD_VAR 0 1
93002: PUSH
93003: LD_VAR 0 3
93007: MINUS
93008: ST_TO_ADDR
// if y - r < 0 then
93009: LD_VAR 0 2
93013: PUSH
93014: LD_VAR 0 3
93018: MINUS
93019: PUSH
93020: LD_INT 0
93022: LESS
93023: IFFALSE 93035
// min_y := 0 else
93025: LD_ADDR_VAR 0 7
93029: PUSH
93030: LD_INT 0
93032: ST_TO_ADDR
93033: GO 93051
// min_y := y - r ;
93035: LD_ADDR_VAR 0 7
93039: PUSH
93040: LD_VAR 0 2
93044: PUSH
93045: LD_VAR 0 3
93049: MINUS
93050: ST_TO_ADDR
// max_x := x + r ;
93051: LD_ADDR_VAR 0 9
93055: PUSH
93056: LD_VAR 0 1
93060: PUSH
93061: LD_VAR 0 3
93065: PLUS
93066: ST_TO_ADDR
// max_y := y + r ;
93067: LD_ADDR_VAR 0 10
93071: PUSH
93072: LD_VAR 0 2
93076: PUSH
93077: LD_VAR 0 3
93081: PLUS
93082: ST_TO_ADDR
// for _x = min_x to max_x do
93083: LD_ADDR_VAR 0 5
93087: PUSH
93088: DOUBLE
93089: LD_VAR 0 8
93093: DEC
93094: ST_TO_ADDR
93095: LD_VAR 0 9
93099: PUSH
93100: FOR_TO
93101: IFFALSE 93202
// for _y = min_y to max_y do
93103: LD_ADDR_VAR 0 6
93107: PUSH
93108: DOUBLE
93109: LD_VAR 0 7
93113: DEC
93114: ST_TO_ADDR
93115: LD_VAR 0 10
93119: PUSH
93120: FOR_TO
93121: IFFALSE 93198
// begin if not ValidHex ( _x , _y ) then
93123: LD_VAR 0 5
93127: PPUSH
93128: LD_VAR 0 6
93132: PPUSH
93133: CALL_OW 488
93137: NOT
93138: IFFALSE 93142
// continue ;
93140: GO 93120
// if GetResourceTypeXY ( _x , _y ) then
93142: LD_VAR 0 5
93146: PPUSH
93147: LD_VAR 0 6
93151: PPUSH
93152: CALL_OW 283
93156: IFFALSE 93196
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
93158: LD_ADDR_VAR 0 4
93162: PUSH
93163: LD_VAR 0 4
93167: PPUSH
93168: LD_VAR 0 4
93172: PUSH
93173: LD_INT 1
93175: PLUS
93176: PPUSH
93177: LD_VAR 0 5
93181: PUSH
93182: LD_VAR 0 6
93186: PUSH
93187: EMPTY
93188: LIST
93189: LIST
93190: PPUSH
93191: CALL_OW 1
93195: ST_TO_ADDR
// end ;
93196: GO 93120
93198: POP
93199: POP
93200: GO 93100
93202: POP
93203: POP
// end ;
93204: LD_VAR 0 4
93208: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
93209: LD_INT 0
93211: PPUSH
93212: PPUSH
93213: PPUSH
93214: PPUSH
93215: PPUSH
93216: PPUSH
93217: PPUSH
93218: PPUSH
// if not units then
93219: LD_VAR 0 1
93223: NOT
93224: IFFALSE 93228
// exit ;
93226: GO 93752
// result := UnitFilter ( units , [ f_ok ] ) ;
93228: LD_ADDR_VAR 0 3
93232: PUSH
93233: LD_VAR 0 1
93237: PPUSH
93238: LD_INT 50
93240: PUSH
93241: EMPTY
93242: LIST
93243: PPUSH
93244: CALL_OW 72
93248: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
93249: LD_ADDR_VAR 0 8
93253: PUSH
93254: LD_VAR 0 1
93258: PUSH
93259: LD_INT 1
93261: ARRAY
93262: PPUSH
93263: CALL_OW 255
93267: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
93268: LD_ADDR_VAR 0 10
93272: PUSH
93273: LD_INT 29
93275: PUSH
93276: LD_INT 91
93278: PUSH
93279: LD_INT 49
93281: PUSH
93282: EMPTY
93283: LIST
93284: LIST
93285: LIST
93286: ST_TO_ADDR
// if not result then
93287: LD_VAR 0 3
93291: NOT
93292: IFFALSE 93296
// exit ;
93294: GO 93752
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
93296: LD_ADDR_VAR 0 5
93300: PUSH
93301: LD_INT 81
93303: PUSH
93304: LD_VAR 0 8
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PPUSH
93313: CALL_OW 69
93317: ST_TO_ADDR
// for i in result do
93318: LD_ADDR_VAR 0 4
93322: PUSH
93323: LD_VAR 0 3
93327: PUSH
93328: FOR_IN
93329: IFFALSE 93750
// begin tag := GetTag ( i ) + 1 ;
93331: LD_ADDR_VAR 0 9
93335: PUSH
93336: LD_VAR 0 4
93340: PPUSH
93341: CALL_OW 110
93345: PUSH
93346: LD_INT 1
93348: PLUS
93349: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
93350: LD_ADDR_VAR 0 7
93354: PUSH
93355: LD_VAR 0 4
93359: PPUSH
93360: CALL_OW 250
93364: PPUSH
93365: LD_VAR 0 4
93369: PPUSH
93370: CALL_OW 251
93374: PPUSH
93375: LD_INT 6
93377: PPUSH
93378: CALL 92951 0 3
93382: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
93383: LD_VAR 0 4
93387: PPUSH
93388: CALL_OW 247
93392: PUSH
93393: LD_INT 2
93395: EQUAL
93396: PUSH
93397: LD_VAR 0 7
93401: AND
93402: PUSH
93403: LD_VAR 0 4
93407: PPUSH
93408: CALL_OW 264
93412: PUSH
93413: LD_VAR 0 10
93417: IN
93418: NOT
93419: AND
93420: IFFALSE 93459
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
93422: LD_VAR 0 4
93426: PPUSH
93427: LD_VAR 0 7
93431: PUSH
93432: LD_INT 1
93434: ARRAY
93435: PUSH
93436: LD_INT 1
93438: ARRAY
93439: PPUSH
93440: LD_VAR 0 7
93444: PUSH
93445: LD_INT 1
93447: ARRAY
93448: PUSH
93449: LD_INT 2
93451: ARRAY
93452: PPUSH
93453: CALL_OW 116
93457: GO 93748
// if path > tag then
93459: LD_VAR 0 2
93463: PUSH
93464: LD_VAR 0 9
93468: GREATER
93469: IFFALSE 93677
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
93471: LD_ADDR_VAR 0 6
93475: PUSH
93476: LD_VAR 0 5
93480: PPUSH
93481: LD_INT 91
93483: PUSH
93484: LD_VAR 0 4
93488: PUSH
93489: LD_INT 8
93491: PUSH
93492: EMPTY
93493: LIST
93494: LIST
93495: LIST
93496: PPUSH
93497: CALL_OW 72
93501: ST_TO_ADDR
// if nearEnemy then
93502: LD_VAR 0 6
93506: IFFALSE 93575
// begin if GetWeapon ( i ) = ru_time_lapser then
93508: LD_VAR 0 4
93512: PPUSH
93513: CALL_OW 264
93517: PUSH
93518: LD_INT 49
93520: EQUAL
93521: IFFALSE 93549
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
93523: LD_VAR 0 4
93527: PPUSH
93528: LD_VAR 0 6
93532: PPUSH
93533: LD_VAR 0 4
93537: PPUSH
93538: CALL_OW 74
93542: PPUSH
93543: CALL_OW 112
93547: GO 93573
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
93549: LD_VAR 0 4
93553: PPUSH
93554: LD_VAR 0 6
93558: PPUSH
93559: LD_VAR 0 4
93563: PPUSH
93564: CALL_OW 74
93568: PPUSH
93569: CALL 94677 0 2
// end else
93573: GO 93675
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
93575: LD_VAR 0 4
93579: PPUSH
93580: LD_VAR 0 2
93584: PUSH
93585: LD_VAR 0 9
93589: ARRAY
93590: PUSH
93591: LD_INT 1
93593: ARRAY
93594: PPUSH
93595: LD_VAR 0 2
93599: PUSH
93600: LD_VAR 0 9
93604: ARRAY
93605: PUSH
93606: LD_INT 2
93608: ARRAY
93609: PPUSH
93610: CALL_OW 297
93614: PUSH
93615: LD_INT 6
93617: GREATER
93618: IFFALSE 93661
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
93620: LD_VAR 0 4
93624: PPUSH
93625: LD_VAR 0 2
93629: PUSH
93630: LD_VAR 0 9
93634: ARRAY
93635: PUSH
93636: LD_INT 1
93638: ARRAY
93639: PPUSH
93640: LD_VAR 0 2
93644: PUSH
93645: LD_VAR 0 9
93649: ARRAY
93650: PUSH
93651: LD_INT 2
93653: ARRAY
93654: PPUSH
93655: CALL_OW 114
93659: GO 93675
// SetTag ( i , tag ) ;
93661: LD_VAR 0 4
93665: PPUSH
93666: LD_VAR 0 9
93670: PPUSH
93671: CALL_OW 109
// end else
93675: GO 93748
// if enemy then
93677: LD_VAR 0 5
93681: IFFALSE 93748
// begin if GetWeapon ( i ) = ru_time_lapser then
93683: LD_VAR 0 4
93687: PPUSH
93688: CALL_OW 264
93692: PUSH
93693: LD_INT 49
93695: EQUAL
93696: IFFALSE 93724
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
93698: LD_VAR 0 4
93702: PPUSH
93703: LD_VAR 0 5
93707: PPUSH
93708: LD_VAR 0 4
93712: PPUSH
93713: CALL_OW 74
93717: PPUSH
93718: CALL_OW 112
93722: GO 93748
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
93724: LD_VAR 0 4
93728: PPUSH
93729: LD_VAR 0 5
93733: PPUSH
93734: LD_VAR 0 4
93738: PPUSH
93739: CALL_OW 74
93743: PPUSH
93744: CALL 94677 0 2
// end ; end ;
93748: GO 93328
93750: POP
93751: POP
// end ;
93752: LD_VAR 0 3
93756: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
93757: LD_INT 0
93759: PPUSH
93760: PPUSH
93761: PPUSH
// if not unit or IsInUnit ( unit ) then
93762: LD_VAR 0 1
93766: NOT
93767: PUSH
93768: LD_VAR 0 1
93772: PPUSH
93773: CALL_OW 310
93777: OR
93778: IFFALSE 93782
// exit ;
93780: GO 93873
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
93782: LD_ADDR_VAR 0 4
93786: PUSH
93787: LD_VAR 0 1
93791: PPUSH
93792: CALL_OW 250
93796: PPUSH
93797: LD_VAR 0 2
93801: PPUSH
93802: LD_INT 1
93804: PPUSH
93805: CALL_OW 272
93809: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
93810: LD_ADDR_VAR 0 5
93814: PUSH
93815: LD_VAR 0 1
93819: PPUSH
93820: CALL_OW 251
93824: PPUSH
93825: LD_VAR 0 2
93829: PPUSH
93830: LD_INT 1
93832: PPUSH
93833: CALL_OW 273
93837: ST_TO_ADDR
// if ValidHex ( x , y ) then
93838: LD_VAR 0 4
93842: PPUSH
93843: LD_VAR 0 5
93847: PPUSH
93848: CALL_OW 488
93852: IFFALSE 93873
// ComTurnXY ( unit , x , y ) ;
93854: LD_VAR 0 1
93858: PPUSH
93859: LD_VAR 0 4
93863: PPUSH
93864: LD_VAR 0 5
93868: PPUSH
93869: CALL_OW 118
// end ;
93873: LD_VAR 0 3
93877: RET
// export function SeeUnits ( side , units ) ; var i ; begin
93878: LD_INT 0
93880: PPUSH
93881: PPUSH
// result := false ;
93882: LD_ADDR_VAR 0 3
93886: PUSH
93887: LD_INT 0
93889: ST_TO_ADDR
// if not units then
93890: LD_VAR 0 2
93894: NOT
93895: IFFALSE 93899
// exit ;
93897: GO 93944
// for i in units do
93899: LD_ADDR_VAR 0 4
93903: PUSH
93904: LD_VAR 0 2
93908: PUSH
93909: FOR_IN
93910: IFFALSE 93942
// if See ( side , i ) then
93912: LD_VAR 0 1
93916: PPUSH
93917: LD_VAR 0 4
93921: PPUSH
93922: CALL_OW 292
93926: IFFALSE 93940
// begin result := true ;
93928: LD_ADDR_VAR 0 3
93932: PUSH
93933: LD_INT 1
93935: ST_TO_ADDR
// exit ;
93936: POP
93937: POP
93938: GO 93944
// end ;
93940: GO 93909
93942: POP
93943: POP
// end ;
93944: LD_VAR 0 3
93948: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
93949: LD_INT 0
93951: PPUSH
93952: PPUSH
93953: PPUSH
93954: PPUSH
// if not unit or not points then
93955: LD_VAR 0 1
93959: NOT
93960: PUSH
93961: LD_VAR 0 2
93965: NOT
93966: OR
93967: IFFALSE 93971
// exit ;
93969: GO 94061
// dist := 99999 ;
93971: LD_ADDR_VAR 0 5
93975: PUSH
93976: LD_INT 99999
93978: ST_TO_ADDR
// for i in points do
93979: LD_ADDR_VAR 0 4
93983: PUSH
93984: LD_VAR 0 2
93988: PUSH
93989: FOR_IN
93990: IFFALSE 94059
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
93992: LD_ADDR_VAR 0 6
93996: PUSH
93997: LD_VAR 0 1
94001: PPUSH
94002: LD_VAR 0 4
94006: PUSH
94007: LD_INT 1
94009: ARRAY
94010: PPUSH
94011: LD_VAR 0 4
94015: PUSH
94016: LD_INT 2
94018: ARRAY
94019: PPUSH
94020: CALL_OW 297
94024: ST_TO_ADDR
// if tmpDist < dist then
94025: LD_VAR 0 6
94029: PUSH
94030: LD_VAR 0 5
94034: LESS
94035: IFFALSE 94057
// begin result := i ;
94037: LD_ADDR_VAR 0 3
94041: PUSH
94042: LD_VAR 0 4
94046: ST_TO_ADDR
// dist := tmpDist ;
94047: LD_ADDR_VAR 0 5
94051: PUSH
94052: LD_VAR 0 6
94056: ST_TO_ADDR
// end ; end ;
94057: GO 93989
94059: POP
94060: POP
// end ;
94061: LD_VAR 0 3
94065: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
94066: LD_INT 0
94068: PPUSH
// uc_side := side ;
94069: LD_ADDR_OWVAR 20
94073: PUSH
94074: LD_VAR 0 1
94078: ST_TO_ADDR
// uc_nation := 3 ;
94079: LD_ADDR_OWVAR 21
94083: PUSH
94084: LD_INT 3
94086: ST_TO_ADDR
// vc_chassis := 25 ;
94087: LD_ADDR_OWVAR 37
94091: PUSH
94092: LD_INT 25
94094: ST_TO_ADDR
// vc_engine := engine_siberite ;
94095: LD_ADDR_OWVAR 39
94099: PUSH
94100: LD_INT 3
94102: ST_TO_ADDR
// vc_control := control_computer ;
94103: LD_ADDR_OWVAR 38
94107: PUSH
94108: LD_INT 3
94110: ST_TO_ADDR
// vc_weapon := 59 ;
94111: LD_ADDR_OWVAR 40
94115: PUSH
94116: LD_INT 59
94118: ST_TO_ADDR
// result := CreateVehicle ;
94119: LD_ADDR_VAR 0 5
94123: PUSH
94124: CALL_OW 45
94128: ST_TO_ADDR
// SetDir ( result , d ) ;
94129: LD_VAR 0 5
94133: PPUSH
94134: LD_VAR 0 4
94138: PPUSH
94139: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
94143: LD_VAR 0 5
94147: PPUSH
94148: LD_VAR 0 2
94152: PPUSH
94153: LD_VAR 0 3
94157: PPUSH
94158: LD_INT 0
94160: PPUSH
94161: CALL_OW 48
// end ;
94165: LD_VAR 0 5
94169: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
94170: LD_INT 0
94172: PPUSH
94173: PPUSH
94174: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
94175: LD_ADDR_VAR 0 2
94179: PUSH
94180: LD_INT 0
94182: PUSH
94183: LD_INT 0
94185: PUSH
94186: LD_INT 0
94188: PUSH
94189: LD_INT 0
94191: PUSH
94192: EMPTY
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
94198: LD_VAR 0 1
94202: NOT
94203: PUSH
94204: LD_VAR 0 1
94208: PPUSH
94209: CALL_OW 264
94213: PUSH
94214: LD_INT 12
94216: PUSH
94217: LD_INT 51
94219: PUSH
94220: LD_INT 32
94222: PUSH
94223: LD_INT 89
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: IN
94232: NOT
94233: OR
94234: IFFALSE 94238
// exit ;
94236: GO 94336
// for i := 1 to 3 do
94238: LD_ADDR_VAR 0 3
94242: PUSH
94243: DOUBLE
94244: LD_INT 1
94246: DEC
94247: ST_TO_ADDR
94248: LD_INT 3
94250: PUSH
94251: FOR_TO
94252: IFFALSE 94334
// begin tmp := GetCargo ( cargo , i ) ;
94254: LD_ADDR_VAR 0 4
94258: PUSH
94259: LD_VAR 0 1
94263: PPUSH
94264: LD_VAR 0 3
94268: PPUSH
94269: CALL_OW 289
94273: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
94274: LD_ADDR_VAR 0 2
94278: PUSH
94279: LD_VAR 0 2
94283: PPUSH
94284: LD_VAR 0 3
94288: PPUSH
94289: LD_VAR 0 4
94293: PPUSH
94294: CALL_OW 1
94298: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
94299: LD_ADDR_VAR 0 2
94303: PUSH
94304: LD_VAR 0 2
94308: PPUSH
94309: LD_INT 4
94311: PPUSH
94312: LD_VAR 0 2
94316: PUSH
94317: LD_INT 4
94319: ARRAY
94320: PUSH
94321: LD_VAR 0 4
94325: PLUS
94326: PPUSH
94327: CALL_OW 1
94331: ST_TO_ADDR
// end ;
94332: GO 94251
94334: POP
94335: POP
// end ;
94336: LD_VAR 0 2
94340: RET
// export function Length ( array ) ; begin
94341: LD_INT 0
94343: PPUSH
// result := array + 0 ;
94344: LD_ADDR_VAR 0 2
94348: PUSH
94349: LD_VAR 0 1
94353: PUSH
94354: LD_INT 0
94356: PLUS
94357: ST_TO_ADDR
// end ;
94358: LD_VAR 0 2
94362: RET
// export function PrepareArray ( array ) ; begin
94363: LD_INT 0
94365: PPUSH
// result := array diff 0 ;
94366: LD_ADDR_VAR 0 2
94370: PUSH
94371: LD_VAR 0 1
94375: PUSH
94376: LD_INT 0
94378: DIFF
94379: ST_TO_ADDR
// if not result [ 1 ] then
94380: LD_VAR 0 2
94384: PUSH
94385: LD_INT 1
94387: ARRAY
94388: NOT
94389: IFFALSE 94409
// result := Delete ( result , 1 ) ;
94391: LD_ADDR_VAR 0 2
94395: PUSH
94396: LD_VAR 0 2
94400: PPUSH
94401: LD_INT 1
94403: PPUSH
94404: CALL_OW 3
94408: ST_TO_ADDR
// end ;
94409: LD_VAR 0 2
94413: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
94414: LD_INT 0
94416: PPUSH
94417: PPUSH
94418: PPUSH
94419: PPUSH
// sibRocketRange := 25 ;
94420: LD_ADDR_VAR 0 6
94424: PUSH
94425: LD_INT 25
94427: ST_TO_ADDR
// result := false ;
94428: LD_ADDR_VAR 0 4
94432: PUSH
94433: LD_INT 0
94435: ST_TO_ADDR
// for i := 0 to 5 do
94436: LD_ADDR_VAR 0 5
94440: PUSH
94441: DOUBLE
94442: LD_INT 0
94444: DEC
94445: ST_TO_ADDR
94446: LD_INT 5
94448: PUSH
94449: FOR_TO
94450: IFFALSE 94517
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
94452: LD_VAR 0 1
94456: PPUSH
94457: LD_VAR 0 5
94461: PPUSH
94462: LD_VAR 0 6
94466: PPUSH
94467: CALL_OW 272
94471: PPUSH
94472: LD_VAR 0 2
94476: PPUSH
94477: LD_VAR 0 5
94481: PPUSH
94482: LD_VAR 0 6
94486: PPUSH
94487: CALL_OW 273
94491: PPUSH
94492: LD_VAR 0 3
94496: PPUSH
94497: CALL_OW 309
94501: IFFALSE 94515
// begin result := true ;
94503: LD_ADDR_VAR 0 4
94507: PUSH
94508: LD_INT 1
94510: ST_TO_ADDR
// exit ;
94511: POP
94512: POP
94513: GO 94519
// end ;
94515: GO 94449
94517: POP
94518: POP
// end ;
94519: LD_VAR 0 4
94523: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
94524: LD_INT 0
94526: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
94527: LD_VAR 0 1
94531: PPUSH
94532: LD_VAR 0 2
94536: PPUSH
94537: LD_INT 0
94539: PPUSH
94540: LD_INT 0
94542: PPUSH
94543: LD_INT 1
94545: PPUSH
94546: LD_INT 0
94548: PPUSH
94549: CALL_OW 587
// end ;
94553: LD_VAR 0 3
94557: RET
// export function CenterOnNow ( unit ) ; begin
94558: LD_INT 0
94560: PPUSH
// result := IsInUnit ( unit ) ;
94561: LD_ADDR_VAR 0 2
94565: PUSH
94566: LD_VAR 0 1
94570: PPUSH
94571: CALL_OW 310
94575: ST_TO_ADDR
// if not result then
94576: LD_VAR 0 2
94580: NOT
94581: IFFALSE 94593
// result := unit ;
94583: LD_ADDR_VAR 0 2
94587: PUSH
94588: LD_VAR 0 1
94592: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
94593: LD_VAR 0 1
94597: PPUSH
94598: CALL_OW 87
// end ;
94602: LD_VAR 0 2
94606: RET
// export function ComMoveHex ( unit , hex ) ; begin
94607: LD_INT 0
94609: PPUSH
// if not hex then
94610: LD_VAR 0 2
94614: NOT
94615: IFFALSE 94619
// exit ;
94617: GO 94672
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
94619: LD_VAR 0 2
94623: PUSH
94624: LD_INT 1
94626: ARRAY
94627: PPUSH
94628: LD_VAR 0 2
94632: PUSH
94633: LD_INT 2
94635: ARRAY
94636: PPUSH
94637: CALL_OW 428
94641: IFFALSE 94645
// exit ;
94643: GO 94672
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
94645: LD_VAR 0 1
94649: PPUSH
94650: LD_VAR 0 2
94654: PUSH
94655: LD_INT 1
94657: ARRAY
94658: PPUSH
94659: LD_VAR 0 2
94663: PUSH
94664: LD_INT 2
94666: ARRAY
94667: PPUSH
94668: CALL_OW 111
// end ;
94672: LD_VAR 0 3
94676: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
94677: LD_INT 0
94679: PPUSH
94680: PPUSH
94681: PPUSH
// if not unit or not enemy then
94682: LD_VAR 0 1
94686: NOT
94687: PUSH
94688: LD_VAR 0 2
94692: NOT
94693: OR
94694: IFFALSE 94698
// exit ;
94696: GO 94822
// x := GetX ( enemy ) ;
94698: LD_ADDR_VAR 0 4
94702: PUSH
94703: LD_VAR 0 2
94707: PPUSH
94708: CALL_OW 250
94712: ST_TO_ADDR
// y := GetY ( enemy ) ;
94713: LD_ADDR_VAR 0 5
94717: PUSH
94718: LD_VAR 0 2
94722: PPUSH
94723: CALL_OW 251
94727: ST_TO_ADDR
// if ValidHex ( x , y ) then
94728: LD_VAR 0 4
94732: PPUSH
94733: LD_VAR 0 5
94737: PPUSH
94738: CALL_OW 488
94742: IFFALSE 94822
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
94744: LD_VAR 0 2
94748: PPUSH
94749: CALL_OW 247
94753: PUSH
94754: LD_INT 3
94756: PUSH
94757: LD_INT 2
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: IN
94764: PUSH
94765: LD_VAR 0 1
94769: PPUSH
94770: CALL_OW 255
94774: PPUSH
94775: LD_VAR 0 2
94779: PPUSH
94780: CALL_OW 292
94784: AND
94785: IFFALSE 94803
// ComAttackUnit ( unit , enemy ) else
94787: LD_VAR 0 1
94791: PPUSH
94792: LD_VAR 0 2
94796: PPUSH
94797: CALL_OW 115
94801: GO 94822
// ComAgressiveMove ( unit , x , y ) ;
94803: LD_VAR 0 1
94807: PPUSH
94808: LD_VAR 0 4
94812: PPUSH
94813: LD_VAR 0 5
94817: PPUSH
94818: CALL_OW 114
// end ;
94822: LD_VAR 0 3
94826: RET
// function GetSourcesFromArea ( area , all ) ; var i , list ; begin
94827: LD_INT 0
94829: PPUSH
94830: PPUSH
94831: PPUSH
// list := AreaToList ( area , 0 ) ;
94832: LD_ADDR_VAR 0 5
94836: PUSH
94837: LD_VAR 0 1
94841: PPUSH
94842: LD_INT 0
94844: PPUSH
94845: CALL_OW 517
94849: ST_TO_ADDR
// if not list then
94850: LD_VAR 0 5
94854: NOT
94855: IFFALSE 94859
// exit ;
94857: GO 94986
// if all then
94859: LD_VAR 0 2
94863: IFFALSE 94951
// begin for i := 1 to list [ 1 ] do
94865: LD_ADDR_VAR 0 4
94869: PUSH
94870: DOUBLE
94871: LD_INT 1
94873: DEC
94874: ST_TO_ADDR
94875: LD_VAR 0 5
94879: PUSH
94880: LD_INT 1
94882: ARRAY
94883: PUSH
94884: FOR_TO
94885: IFFALSE 94947
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
94887: LD_ADDR_VAR 0 3
94891: PUSH
94892: LD_VAR 0 3
94896: PPUSH
94897: LD_VAR 0 3
94901: PUSH
94902: LD_INT 1
94904: PLUS
94905: PPUSH
94906: LD_VAR 0 5
94910: PUSH
94911: LD_INT 1
94913: ARRAY
94914: PUSH
94915: LD_VAR 0 4
94919: ARRAY
94920: PUSH
94921: LD_VAR 0 5
94925: PUSH
94926: LD_INT 2
94928: ARRAY
94929: PUSH
94930: LD_VAR 0 4
94934: ARRAY
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: PPUSH
94940: CALL_OW 1
94944: ST_TO_ADDR
94945: GO 94884
94947: POP
94948: POP
// exit ;
94949: GO 94986
// end ; result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ;
94951: LD_ADDR_VAR 0 3
94955: PUSH
94956: LD_VAR 0 5
94960: PUSH
94961: LD_INT 1
94963: ARRAY
94964: PUSH
94965: LD_INT 1
94967: ARRAY
94968: PUSH
94969: LD_VAR 0 5
94973: PUSH
94974: LD_INT 2
94976: ARRAY
94977: PUSH
94978: LD_INT 1
94980: ARRAY
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: ST_TO_ADDR
// end ;
94986: LD_VAR 0 3
94990: RET
// function GetBuildingFromArea ( area , direction ) ; var list ; begin
94991: LD_INT 0
94993: PPUSH
94994: PPUSH
// list := AreaToList ( area , 0 ) ;
94995: LD_ADDR_VAR 0 4
94999: PUSH
95000: LD_VAR 0 1
95004: PPUSH
95005: LD_INT 0
95007: PPUSH
95008: CALL_OW 517
95012: ST_TO_ADDR
// if not list then
95013: LD_VAR 0 4
95017: NOT
95018: IFFALSE 95022
// exit ;
95020: GO 95063
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
95022: LD_ADDR_VAR 0 3
95026: PUSH
95027: LD_VAR 0 4
95031: PUSH
95032: LD_INT 1
95034: ARRAY
95035: PUSH
95036: LD_INT 1
95038: ARRAY
95039: PUSH
95040: LD_VAR 0 4
95044: PUSH
95045: LD_INT 2
95047: ARRAY
95048: PUSH
95049: LD_INT 1
95051: ARRAY
95052: PUSH
95053: LD_VAR 0 2
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: LIST
95062: ST_TO_ADDR
// end ; end_of_file end_of_file
95063: LD_VAR 0 3
95067: RET
// export globalGameSaveCounter ; every 0 0$1 do
95068: GO 95070
95070: DISABLE
// begin enable ;
95071: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
95072: LD_STRING updateTimer(
95074: PUSH
95075: LD_OWVAR 1
95079: STR
95080: PUSH
95081: LD_STRING );
95083: STR
95084: PPUSH
95085: CALL_OW 559
// end ;
95089: END
// every 0 0$1 do
95090: GO 95092
95092: DISABLE
// begin globalGameSaveCounter := 0 ;
95093: LD_ADDR_EXP 123
95097: PUSH
95098: LD_INT 0
95100: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
95101: LD_STRING setGameSaveCounter(0)
95103: PPUSH
95104: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
95108: LD_STRING initStreamRollete();
95110: PPUSH
95111: CALL_OW 559
// InitStreamMode ;
95115: CALL 96441 0 0
// DefineStreamItems ( false ) ;
95119: LD_INT 0
95121: PPUSH
95122: CALL 96905 0 1
// end ;
95126: END
// export function SOS_MapStart ( ) ; begin
95127: LD_INT 0
95129: PPUSH
// if streamModeActive then
95130: LD_EXP 124
95134: IFFALSE 95143
// DefineStreamItems ( true ) ;
95136: LD_INT 1
95138: PPUSH
95139: CALL 96905 0 1
// UpdateLuaVariables ( ) ;
95143: CALL 95160 0 0
// UpdateFactoryWaypoints ( ) ;
95147: CALL 109774 0 0
// UpdateWarehouseGatheringPoints ( ) ;
95151: CALL 110031 0 0
// end ;
95155: LD_VAR 0 1
95159: RET
// function UpdateLuaVariables ( ) ; begin
95160: LD_INT 0
95162: PPUSH
// if globalGameSaveCounter then
95163: LD_EXP 123
95167: IFFALSE 95201
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
95169: LD_ADDR_EXP 123
95173: PUSH
95174: LD_EXP 123
95178: PPUSH
95179: CALL 91966 0 1
95183: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95184: LD_STRING setGameSaveCounter(
95186: PUSH
95187: LD_EXP 123
95191: STR
95192: PUSH
95193: LD_STRING )
95195: STR
95196: PPUSH
95197: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
95201: LD_STRING setGameDifficulty(
95203: PUSH
95204: LD_OWVAR 67
95208: STR
95209: PUSH
95210: LD_STRING )
95212: STR
95213: PPUSH
95214: CALL_OW 559
// end ;
95218: LD_VAR 0 1
95222: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
95223: LD_INT 0
95225: PPUSH
// if p2 = stream_mode then
95226: LD_VAR 0 2
95230: PUSH
95231: LD_INT 100
95233: EQUAL
95234: IFFALSE 96237
// begin if not StreamModeActive then
95236: LD_EXP 124
95240: NOT
95241: IFFALSE 95251
// StreamModeActive := true ;
95243: LD_ADDR_EXP 124
95247: PUSH
95248: LD_INT 1
95250: ST_TO_ADDR
// if p3 = 0 then
95251: LD_VAR 0 3
95255: PUSH
95256: LD_INT 0
95258: EQUAL
95259: IFFALSE 95265
// InitStreamMode ;
95261: CALL 96441 0 0
// if p3 = 1 then
95265: LD_VAR 0 3
95269: PUSH
95270: LD_INT 1
95272: EQUAL
95273: IFFALSE 95283
// sRocket := true ;
95275: LD_ADDR_EXP 129
95279: PUSH
95280: LD_INT 1
95282: ST_TO_ADDR
// if p3 = 2 then
95283: LD_VAR 0 3
95287: PUSH
95288: LD_INT 2
95290: EQUAL
95291: IFFALSE 95301
// sSpeed := true ;
95293: LD_ADDR_EXP 128
95297: PUSH
95298: LD_INT 1
95300: ST_TO_ADDR
// if p3 = 3 then
95301: LD_VAR 0 3
95305: PUSH
95306: LD_INT 3
95308: EQUAL
95309: IFFALSE 95319
// sEngine := true ;
95311: LD_ADDR_EXP 130
95315: PUSH
95316: LD_INT 1
95318: ST_TO_ADDR
// if p3 = 4 then
95319: LD_VAR 0 3
95323: PUSH
95324: LD_INT 4
95326: EQUAL
95327: IFFALSE 95337
// sSpec := true ;
95329: LD_ADDR_EXP 127
95333: PUSH
95334: LD_INT 1
95336: ST_TO_ADDR
// if p3 = 5 then
95337: LD_VAR 0 3
95341: PUSH
95342: LD_INT 5
95344: EQUAL
95345: IFFALSE 95355
// sLevel := true ;
95347: LD_ADDR_EXP 131
95351: PUSH
95352: LD_INT 1
95354: ST_TO_ADDR
// if p3 = 6 then
95355: LD_VAR 0 3
95359: PUSH
95360: LD_INT 6
95362: EQUAL
95363: IFFALSE 95373
// sArmoury := true ;
95365: LD_ADDR_EXP 132
95369: PUSH
95370: LD_INT 1
95372: ST_TO_ADDR
// if p3 = 7 then
95373: LD_VAR 0 3
95377: PUSH
95378: LD_INT 7
95380: EQUAL
95381: IFFALSE 95391
// sRadar := true ;
95383: LD_ADDR_EXP 133
95387: PUSH
95388: LD_INT 1
95390: ST_TO_ADDR
// if p3 = 8 then
95391: LD_VAR 0 3
95395: PUSH
95396: LD_INT 8
95398: EQUAL
95399: IFFALSE 95409
// sBunker := true ;
95401: LD_ADDR_EXP 134
95405: PUSH
95406: LD_INT 1
95408: ST_TO_ADDR
// if p3 = 9 then
95409: LD_VAR 0 3
95413: PUSH
95414: LD_INT 9
95416: EQUAL
95417: IFFALSE 95427
// sHack := true ;
95419: LD_ADDR_EXP 135
95423: PUSH
95424: LD_INT 1
95426: ST_TO_ADDR
// if p3 = 10 then
95427: LD_VAR 0 3
95431: PUSH
95432: LD_INT 10
95434: EQUAL
95435: IFFALSE 95445
// sFire := true ;
95437: LD_ADDR_EXP 136
95441: PUSH
95442: LD_INT 1
95444: ST_TO_ADDR
// if p3 = 11 then
95445: LD_VAR 0 3
95449: PUSH
95450: LD_INT 11
95452: EQUAL
95453: IFFALSE 95463
// sRefresh := true ;
95455: LD_ADDR_EXP 137
95459: PUSH
95460: LD_INT 1
95462: ST_TO_ADDR
// if p3 = 12 then
95463: LD_VAR 0 3
95467: PUSH
95468: LD_INT 12
95470: EQUAL
95471: IFFALSE 95481
// sExp := true ;
95473: LD_ADDR_EXP 138
95477: PUSH
95478: LD_INT 1
95480: ST_TO_ADDR
// if p3 = 13 then
95481: LD_VAR 0 3
95485: PUSH
95486: LD_INT 13
95488: EQUAL
95489: IFFALSE 95499
// sDepot := true ;
95491: LD_ADDR_EXP 139
95495: PUSH
95496: LD_INT 1
95498: ST_TO_ADDR
// if p3 = 14 then
95499: LD_VAR 0 3
95503: PUSH
95504: LD_INT 14
95506: EQUAL
95507: IFFALSE 95517
// sFlag := true ;
95509: LD_ADDR_EXP 140
95513: PUSH
95514: LD_INT 1
95516: ST_TO_ADDR
// if p3 = 15 then
95517: LD_VAR 0 3
95521: PUSH
95522: LD_INT 15
95524: EQUAL
95525: IFFALSE 95535
// sKamikadze := true ;
95527: LD_ADDR_EXP 148
95531: PUSH
95532: LD_INT 1
95534: ST_TO_ADDR
// if p3 = 16 then
95535: LD_VAR 0 3
95539: PUSH
95540: LD_INT 16
95542: EQUAL
95543: IFFALSE 95553
// sTroll := true ;
95545: LD_ADDR_EXP 149
95549: PUSH
95550: LD_INT 1
95552: ST_TO_ADDR
// if p3 = 17 then
95553: LD_VAR 0 3
95557: PUSH
95558: LD_INT 17
95560: EQUAL
95561: IFFALSE 95571
// sSlow := true ;
95563: LD_ADDR_EXP 150
95567: PUSH
95568: LD_INT 1
95570: ST_TO_ADDR
// if p3 = 18 then
95571: LD_VAR 0 3
95575: PUSH
95576: LD_INT 18
95578: EQUAL
95579: IFFALSE 95589
// sLack := true ;
95581: LD_ADDR_EXP 151
95585: PUSH
95586: LD_INT 1
95588: ST_TO_ADDR
// if p3 = 19 then
95589: LD_VAR 0 3
95593: PUSH
95594: LD_INT 19
95596: EQUAL
95597: IFFALSE 95607
// sTank := true ;
95599: LD_ADDR_EXP 153
95603: PUSH
95604: LD_INT 1
95606: ST_TO_ADDR
// if p3 = 20 then
95607: LD_VAR 0 3
95611: PUSH
95612: LD_INT 20
95614: EQUAL
95615: IFFALSE 95625
// sRemote := true ;
95617: LD_ADDR_EXP 154
95621: PUSH
95622: LD_INT 1
95624: ST_TO_ADDR
// if p3 = 21 then
95625: LD_VAR 0 3
95629: PUSH
95630: LD_INT 21
95632: EQUAL
95633: IFFALSE 95643
// sPowell := true ;
95635: LD_ADDR_EXP 155
95639: PUSH
95640: LD_INT 1
95642: ST_TO_ADDR
// if p3 = 22 then
95643: LD_VAR 0 3
95647: PUSH
95648: LD_INT 22
95650: EQUAL
95651: IFFALSE 95661
// sTeleport := true ;
95653: LD_ADDR_EXP 158
95657: PUSH
95658: LD_INT 1
95660: ST_TO_ADDR
// if p3 = 23 then
95661: LD_VAR 0 3
95665: PUSH
95666: LD_INT 23
95668: EQUAL
95669: IFFALSE 95679
// sOilTower := true ;
95671: LD_ADDR_EXP 160
95675: PUSH
95676: LD_INT 1
95678: ST_TO_ADDR
// if p3 = 24 then
95679: LD_VAR 0 3
95683: PUSH
95684: LD_INT 24
95686: EQUAL
95687: IFFALSE 95697
// sShovel := true ;
95689: LD_ADDR_EXP 161
95693: PUSH
95694: LD_INT 1
95696: ST_TO_ADDR
// if p3 = 25 then
95697: LD_VAR 0 3
95701: PUSH
95702: LD_INT 25
95704: EQUAL
95705: IFFALSE 95715
// sSheik := true ;
95707: LD_ADDR_EXP 162
95711: PUSH
95712: LD_INT 1
95714: ST_TO_ADDR
// if p3 = 26 then
95715: LD_VAR 0 3
95719: PUSH
95720: LD_INT 26
95722: EQUAL
95723: IFFALSE 95733
// sEarthquake := true ;
95725: LD_ADDR_EXP 164
95729: PUSH
95730: LD_INT 1
95732: ST_TO_ADDR
// if p3 = 27 then
95733: LD_VAR 0 3
95737: PUSH
95738: LD_INT 27
95740: EQUAL
95741: IFFALSE 95751
// sAI := true ;
95743: LD_ADDR_EXP 165
95747: PUSH
95748: LD_INT 1
95750: ST_TO_ADDR
// if p3 = 28 then
95751: LD_VAR 0 3
95755: PUSH
95756: LD_INT 28
95758: EQUAL
95759: IFFALSE 95769
// sCargo := true ;
95761: LD_ADDR_EXP 168
95765: PUSH
95766: LD_INT 1
95768: ST_TO_ADDR
// if p3 = 29 then
95769: LD_VAR 0 3
95773: PUSH
95774: LD_INT 29
95776: EQUAL
95777: IFFALSE 95787
// sDLaser := true ;
95779: LD_ADDR_EXP 169
95783: PUSH
95784: LD_INT 1
95786: ST_TO_ADDR
// if p3 = 30 then
95787: LD_VAR 0 3
95791: PUSH
95792: LD_INT 30
95794: EQUAL
95795: IFFALSE 95805
// sExchange := true ;
95797: LD_ADDR_EXP 170
95801: PUSH
95802: LD_INT 1
95804: ST_TO_ADDR
// if p3 = 31 then
95805: LD_VAR 0 3
95809: PUSH
95810: LD_INT 31
95812: EQUAL
95813: IFFALSE 95823
// sFac := true ;
95815: LD_ADDR_EXP 171
95819: PUSH
95820: LD_INT 1
95822: ST_TO_ADDR
// if p3 = 32 then
95823: LD_VAR 0 3
95827: PUSH
95828: LD_INT 32
95830: EQUAL
95831: IFFALSE 95841
// sPower := true ;
95833: LD_ADDR_EXP 172
95837: PUSH
95838: LD_INT 1
95840: ST_TO_ADDR
// if p3 = 33 then
95841: LD_VAR 0 3
95845: PUSH
95846: LD_INT 33
95848: EQUAL
95849: IFFALSE 95859
// sRandom := true ;
95851: LD_ADDR_EXP 173
95855: PUSH
95856: LD_INT 1
95858: ST_TO_ADDR
// if p3 = 34 then
95859: LD_VAR 0 3
95863: PUSH
95864: LD_INT 34
95866: EQUAL
95867: IFFALSE 95877
// sShield := true ;
95869: LD_ADDR_EXP 174
95873: PUSH
95874: LD_INT 1
95876: ST_TO_ADDR
// if p3 = 35 then
95877: LD_VAR 0 3
95881: PUSH
95882: LD_INT 35
95884: EQUAL
95885: IFFALSE 95895
// sTime := true ;
95887: LD_ADDR_EXP 175
95891: PUSH
95892: LD_INT 1
95894: ST_TO_ADDR
// if p3 = 36 then
95895: LD_VAR 0 3
95899: PUSH
95900: LD_INT 36
95902: EQUAL
95903: IFFALSE 95913
// sTools := true ;
95905: LD_ADDR_EXP 176
95909: PUSH
95910: LD_INT 1
95912: ST_TO_ADDR
// if p3 = 101 then
95913: LD_VAR 0 3
95917: PUSH
95918: LD_INT 101
95920: EQUAL
95921: IFFALSE 95931
// sSold := true ;
95923: LD_ADDR_EXP 141
95927: PUSH
95928: LD_INT 1
95930: ST_TO_ADDR
// if p3 = 102 then
95931: LD_VAR 0 3
95935: PUSH
95936: LD_INT 102
95938: EQUAL
95939: IFFALSE 95949
// sDiff := true ;
95941: LD_ADDR_EXP 142
95945: PUSH
95946: LD_INT 1
95948: ST_TO_ADDR
// if p3 = 103 then
95949: LD_VAR 0 3
95953: PUSH
95954: LD_INT 103
95956: EQUAL
95957: IFFALSE 95967
// sFog := true ;
95959: LD_ADDR_EXP 145
95963: PUSH
95964: LD_INT 1
95966: ST_TO_ADDR
// if p3 = 104 then
95967: LD_VAR 0 3
95971: PUSH
95972: LD_INT 104
95974: EQUAL
95975: IFFALSE 95985
// sReset := true ;
95977: LD_ADDR_EXP 146
95981: PUSH
95982: LD_INT 1
95984: ST_TO_ADDR
// if p3 = 105 then
95985: LD_VAR 0 3
95989: PUSH
95990: LD_INT 105
95992: EQUAL
95993: IFFALSE 96003
// sSun := true ;
95995: LD_ADDR_EXP 147
95999: PUSH
96000: LD_INT 1
96002: ST_TO_ADDR
// if p3 = 106 then
96003: LD_VAR 0 3
96007: PUSH
96008: LD_INT 106
96010: EQUAL
96011: IFFALSE 96021
// sTiger := true ;
96013: LD_ADDR_EXP 143
96017: PUSH
96018: LD_INT 1
96020: ST_TO_ADDR
// if p3 = 107 then
96021: LD_VAR 0 3
96025: PUSH
96026: LD_INT 107
96028: EQUAL
96029: IFFALSE 96039
// sBomb := true ;
96031: LD_ADDR_EXP 144
96035: PUSH
96036: LD_INT 1
96038: ST_TO_ADDR
// if p3 = 108 then
96039: LD_VAR 0 3
96043: PUSH
96044: LD_INT 108
96046: EQUAL
96047: IFFALSE 96057
// sWound := true ;
96049: LD_ADDR_EXP 152
96053: PUSH
96054: LD_INT 1
96056: ST_TO_ADDR
// if p3 = 109 then
96057: LD_VAR 0 3
96061: PUSH
96062: LD_INT 109
96064: EQUAL
96065: IFFALSE 96075
// sBetray := true ;
96067: LD_ADDR_EXP 156
96071: PUSH
96072: LD_INT 1
96074: ST_TO_ADDR
// if p3 = 110 then
96075: LD_VAR 0 3
96079: PUSH
96080: LD_INT 110
96082: EQUAL
96083: IFFALSE 96093
// sContamin := true ;
96085: LD_ADDR_EXP 157
96089: PUSH
96090: LD_INT 1
96092: ST_TO_ADDR
// if p3 = 111 then
96093: LD_VAR 0 3
96097: PUSH
96098: LD_INT 111
96100: EQUAL
96101: IFFALSE 96111
// sOil := true ;
96103: LD_ADDR_EXP 159
96107: PUSH
96108: LD_INT 1
96110: ST_TO_ADDR
// if p3 = 112 then
96111: LD_VAR 0 3
96115: PUSH
96116: LD_INT 112
96118: EQUAL
96119: IFFALSE 96129
// sStu := true ;
96121: LD_ADDR_EXP 163
96125: PUSH
96126: LD_INT 1
96128: ST_TO_ADDR
// if p3 = 113 then
96129: LD_VAR 0 3
96133: PUSH
96134: LD_INT 113
96136: EQUAL
96137: IFFALSE 96147
// sBazooka := true ;
96139: LD_ADDR_EXP 166
96143: PUSH
96144: LD_INT 1
96146: ST_TO_ADDR
// if p3 = 114 then
96147: LD_VAR 0 3
96151: PUSH
96152: LD_INT 114
96154: EQUAL
96155: IFFALSE 96165
// sMortar := true ;
96157: LD_ADDR_EXP 167
96161: PUSH
96162: LD_INT 1
96164: ST_TO_ADDR
// if p3 = 115 then
96165: LD_VAR 0 3
96169: PUSH
96170: LD_INT 115
96172: EQUAL
96173: IFFALSE 96183
// sRanger := true ;
96175: LD_ADDR_EXP 177
96179: PUSH
96180: LD_INT 1
96182: ST_TO_ADDR
// if p3 = 116 then
96183: LD_VAR 0 3
96187: PUSH
96188: LD_INT 116
96190: EQUAL
96191: IFFALSE 96201
// sComputer := true ;
96193: LD_ADDR_EXP 178
96197: PUSH
96198: LD_INT 1
96200: ST_TO_ADDR
// if p3 = 117 then
96201: LD_VAR 0 3
96205: PUSH
96206: LD_INT 117
96208: EQUAL
96209: IFFALSE 96219
// s30 := true ;
96211: LD_ADDR_EXP 179
96215: PUSH
96216: LD_INT 1
96218: ST_TO_ADDR
// if p3 = 118 then
96219: LD_VAR 0 3
96223: PUSH
96224: LD_INT 118
96226: EQUAL
96227: IFFALSE 96237
// s60 := true ;
96229: LD_ADDR_EXP 180
96233: PUSH
96234: LD_INT 1
96236: ST_TO_ADDR
// end ; if p2 = hack_mode then
96237: LD_VAR 0 2
96241: PUSH
96242: LD_INT 101
96244: EQUAL
96245: IFFALSE 96373
// begin case p3 of 1 :
96247: LD_VAR 0 3
96251: PUSH
96252: LD_INT 1
96254: DOUBLE
96255: EQUAL
96256: IFTRUE 96260
96258: GO 96267
96260: POP
// hHackUnlimitedResources ; 2 :
96261: CALL 108520 0 0
96265: GO 96373
96267: LD_INT 2
96269: DOUBLE
96270: EQUAL
96271: IFTRUE 96275
96273: GO 96282
96275: POP
// hHackSetLevel10 ; 3 :
96276: CALL 108653 0 0
96280: GO 96373
96282: LD_INT 3
96284: DOUBLE
96285: EQUAL
96286: IFTRUE 96290
96288: GO 96297
96290: POP
// hHackSetLevel10YourUnits ; 4 :
96291: CALL 108738 0 0
96295: GO 96373
96297: LD_INT 4
96299: DOUBLE
96300: EQUAL
96301: IFTRUE 96305
96303: GO 96312
96305: POP
// hHackInvincible ; 5 :
96306: CALL 109186 0 0
96310: GO 96373
96312: LD_INT 5
96314: DOUBLE
96315: EQUAL
96316: IFTRUE 96320
96318: GO 96327
96320: POP
// hHackInvisible ; 6 :
96321: CALL 109297 0 0
96325: GO 96373
96327: LD_INT 6
96329: DOUBLE
96330: EQUAL
96331: IFTRUE 96335
96333: GO 96342
96335: POP
// hHackChangeYourSide ; 7 :
96336: CALL 109354 0 0
96340: GO 96373
96342: LD_INT 7
96344: DOUBLE
96345: EQUAL
96346: IFTRUE 96350
96348: GO 96357
96350: POP
// hHackChangeUnitSide ; 8 :
96351: CALL 109396 0 0
96355: GO 96373
96357: LD_INT 8
96359: DOUBLE
96360: EQUAL
96361: IFTRUE 96365
96363: GO 96372
96365: POP
// hHackFog ; end ;
96366: CALL 109497 0 0
96370: GO 96373
96372: POP
// end ; if p2 = game_save_mode then
96373: LD_VAR 0 2
96377: PUSH
96378: LD_INT 102
96380: EQUAL
96381: IFFALSE 96436
// begin if p3 = 1 then
96383: LD_VAR 0 3
96387: PUSH
96388: LD_INT 1
96390: EQUAL
96391: IFFALSE 96403
// globalGameSaveCounter := p4 ;
96393: LD_ADDR_EXP 123
96397: PUSH
96398: LD_VAR 0 4
96402: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
96403: LD_VAR 0 3
96407: PUSH
96408: LD_INT 2
96410: EQUAL
96411: PUSH
96412: LD_EXP 123
96416: AND
96417: IFFALSE 96436
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96419: LD_STRING setGameSaveCounter(
96421: PUSH
96422: LD_EXP 123
96426: STR
96427: PUSH
96428: LD_STRING )
96430: STR
96431: PPUSH
96432: CALL_OW 559
// end ; end ;
96436: LD_VAR 0 7
96440: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
96441: LD_INT 0
96443: PPUSH
// streamModeActive := false ;
96444: LD_ADDR_EXP 124
96448: PUSH
96449: LD_INT 0
96451: ST_TO_ADDR
// normalCounter := 36 ;
96452: LD_ADDR_EXP 125
96456: PUSH
96457: LD_INT 36
96459: ST_TO_ADDR
// hardcoreCounter := 18 ;
96460: LD_ADDR_EXP 126
96464: PUSH
96465: LD_INT 18
96467: ST_TO_ADDR
// sRocket := false ;
96468: LD_ADDR_EXP 129
96472: PUSH
96473: LD_INT 0
96475: ST_TO_ADDR
// sSpeed := false ;
96476: LD_ADDR_EXP 128
96480: PUSH
96481: LD_INT 0
96483: ST_TO_ADDR
// sEngine := false ;
96484: LD_ADDR_EXP 130
96488: PUSH
96489: LD_INT 0
96491: ST_TO_ADDR
// sSpec := false ;
96492: LD_ADDR_EXP 127
96496: PUSH
96497: LD_INT 0
96499: ST_TO_ADDR
// sLevel := false ;
96500: LD_ADDR_EXP 131
96504: PUSH
96505: LD_INT 0
96507: ST_TO_ADDR
// sArmoury := false ;
96508: LD_ADDR_EXP 132
96512: PUSH
96513: LD_INT 0
96515: ST_TO_ADDR
// sRadar := false ;
96516: LD_ADDR_EXP 133
96520: PUSH
96521: LD_INT 0
96523: ST_TO_ADDR
// sBunker := false ;
96524: LD_ADDR_EXP 134
96528: PUSH
96529: LD_INT 0
96531: ST_TO_ADDR
// sHack := false ;
96532: LD_ADDR_EXP 135
96536: PUSH
96537: LD_INT 0
96539: ST_TO_ADDR
// sFire := false ;
96540: LD_ADDR_EXP 136
96544: PUSH
96545: LD_INT 0
96547: ST_TO_ADDR
// sRefresh := false ;
96548: LD_ADDR_EXP 137
96552: PUSH
96553: LD_INT 0
96555: ST_TO_ADDR
// sExp := false ;
96556: LD_ADDR_EXP 138
96560: PUSH
96561: LD_INT 0
96563: ST_TO_ADDR
// sDepot := false ;
96564: LD_ADDR_EXP 139
96568: PUSH
96569: LD_INT 0
96571: ST_TO_ADDR
// sFlag := false ;
96572: LD_ADDR_EXP 140
96576: PUSH
96577: LD_INT 0
96579: ST_TO_ADDR
// sKamikadze := false ;
96580: LD_ADDR_EXP 148
96584: PUSH
96585: LD_INT 0
96587: ST_TO_ADDR
// sTroll := false ;
96588: LD_ADDR_EXP 149
96592: PUSH
96593: LD_INT 0
96595: ST_TO_ADDR
// sSlow := false ;
96596: LD_ADDR_EXP 150
96600: PUSH
96601: LD_INT 0
96603: ST_TO_ADDR
// sLack := false ;
96604: LD_ADDR_EXP 151
96608: PUSH
96609: LD_INT 0
96611: ST_TO_ADDR
// sTank := false ;
96612: LD_ADDR_EXP 153
96616: PUSH
96617: LD_INT 0
96619: ST_TO_ADDR
// sRemote := false ;
96620: LD_ADDR_EXP 154
96624: PUSH
96625: LD_INT 0
96627: ST_TO_ADDR
// sPowell := false ;
96628: LD_ADDR_EXP 155
96632: PUSH
96633: LD_INT 0
96635: ST_TO_ADDR
// sTeleport := false ;
96636: LD_ADDR_EXP 158
96640: PUSH
96641: LD_INT 0
96643: ST_TO_ADDR
// sOilTower := false ;
96644: LD_ADDR_EXP 160
96648: PUSH
96649: LD_INT 0
96651: ST_TO_ADDR
// sShovel := false ;
96652: LD_ADDR_EXP 161
96656: PUSH
96657: LD_INT 0
96659: ST_TO_ADDR
// sSheik := false ;
96660: LD_ADDR_EXP 162
96664: PUSH
96665: LD_INT 0
96667: ST_TO_ADDR
// sEarthquake := false ;
96668: LD_ADDR_EXP 164
96672: PUSH
96673: LD_INT 0
96675: ST_TO_ADDR
// sAI := false ;
96676: LD_ADDR_EXP 165
96680: PUSH
96681: LD_INT 0
96683: ST_TO_ADDR
// sCargo := false ;
96684: LD_ADDR_EXP 168
96688: PUSH
96689: LD_INT 0
96691: ST_TO_ADDR
// sDLaser := false ;
96692: LD_ADDR_EXP 169
96696: PUSH
96697: LD_INT 0
96699: ST_TO_ADDR
// sExchange := false ;
96700: LD_ADDR_EXP 170
96704: PUSH
96705: LD_INT 0
96707: ST_TO_ADDR
// sFac := false ;
96708: LD_ADDR_EXP 171
96712: PUSH
96713: LD_INT 0
96715: ST_TO_ADDR
// sPower := false ;
96716: LD_ADDR_EXP 172
96720: PUSH
96721: LD_INT 0
96723: ST_TO_ADDR
// sRandom := false ;
96724: LD_ADDR_EXP 173
96728: PUSH
96729: LD_INT 0
96731: ST_TO_ADDR
// sShield := false ;
96732: LD_ADDR_EXP 174
96736: PUSH
96737: LD_INT 0
96739: ST_TO_ADDR
// sTime := false ;
96740: LD_ADDR_EXP 175
96744: PUSH
96745: LD_INT 0
96747: ST_TO_ADDR
// sTools := false ;
96748: LD_ADDR_EXP 176
96752: PUSH
96753: LD_INT 0
96755: ST_TO_ADDR
// sSold := false ;
96756: LD_ADDR_EXP 141
96760: PUSH
96761: LD_INT 0
96763: ST_TO_ADDR
// sDiff := false ;
96764: LD_ADDR_EXP 142
96768: PUSH
96769: LD_INT 0
96771: ST_TO_ADDR
// sFog := false ;
96772: LD_ADDR_EXP 145
96776: PUSH
96777: LD_INT 0
96779: ST_TO_ADDR
// sReset := false ;
96780: LD_ADDR_EXP 146
96784: PUSH
96785: LD_INT 0
96787: ST_TO_ADDR
// sSun := false ;
96788: LD_ADDR_EXP 147
96792: PUSH
96793: LD_INT 0
96795: ST_TO_ADDR
// sTiger := false ;
96796: LD_ADDR_EXP 143
96800: PUSH
96801: LD_INT 0
96803: ST_TO_ADDR
// sBomb := false ;
96804: LD_ADDR_EXP 144
96808: PUSH
96809: LD_INT 0
96811: ST_TO_ADDR
// sWound := false ;
96812: LD_ADDR_EXP 152
96816: PUSH
96817: LD_INT 0
96819: ST_TO_ADDR
// sBetray := false ;
96820: LD_ADDR_EXP 156
96824: PUSH
96825: LD_INT 0
96827: ST_TO_ADDR
// sContamin := false ;
96828: LD_ADDR_EXP 157
96832: PUSH
96833: LD_INT 0
96835: ST_TO_ADDR
// sOil := false ;
96836: LD_ADDR_EXP 159
96840: PUSH
96841: LD_INT 0
96843: ST_TO_ADDR
// sStu := false ;
96844: LD_ADDR_EXP 163
96848: PUSH
96849: LD_INT 0
96851: ST_TO_ADDR
// sBazooka := false ;
96852: LD_ADDR_EXP 166
96856: PUSH
96857: LD_INT 0
96859: ST_TO_ADDR
// sMortar := false ;
96860: LD_ADDR_EXP 167
96864: PUSH
96865: LD_INT 0
96867: ST_TO_ADDR
// sRanger := false ;
96868: LD_ADDR_EXP 177
96872: PUSH
96873: LD_INT 0
96875: ST_TO_ADDR
// sComputer := false ;
96876: LD_ADDR_EXP 178
96880: PUSH
96881: LD_INT 0
96883: ST_TO_ADDR
// s30 := false ;
96884: LD_ADDR_EXP 179
96888: PUSH
96889: LD_INT 0
96891: ST_TO_ADDR
// s60 := false ;
96892: LD_ADDR_EXP 180
96896: PUSH
96897: LD_INT 0
96899: ST_TO_ADDR
// end ;
96900: LD_VAR 0 1
96904: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96905: LD_INT 0
96907: PPUSH
96908: PPUSH
96909: PPUSH
96910: PPUSH
96911: PPUSH
96912: PPUSH
96913: PPUSH
// result := [ ] ;
96914: LD_ADDR_VAR 0 2
96918: PUSH
96919: EMPTY
96920: ST_TO_ADDR
// if campaign_id = 1 then
96921: LD_OWVAR 69
96925: PUSH
96926: LD_INT 1
96928: EQUAL
96929: IFFALSE 100095
// begin case mission_number of 1 :
96931: LD_OWVAR 70
96935: PUSH
96936: LD_INT 1
96938: DOUBLE
96939: EQUAL
96940: IFTRUE 96944
96942: GO 97020
96944: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96945: LD_ADDR_VAR 0 2
96949: PUSH
96950: LD_INT 2
96952: PUSH
96953: LD_INT 4
96955: PUSH
96956: LD_INT 11
96958: PUSH
96959: LD_INT 12
96961: PUSH
96962: LD_INT 15
96964: PUSH
96965: LD_INT 16
96967: PUSH
96968: LD_INT 22
96970: PUSH
96971: LD_INT 23
96973: PUSH
96974: LD_INT 26
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: PUSH
96988: LD_INT 101
96990: PUSH
96991: LD_INT 102
96993: PUSH
96994: LD_INT 106
96996: PUSH
96997: LD_INT 116
96999: PUSH
97000: LD_INT 117
97002: PUSH
97003: LD_INT 118
97005: PUSH
97006: EMPTY
97007: LIST
97008: LIST
97009: LIST
97010: LIST
97011: LIST
97012: LIST
97013: PUSH
97014: EMPTY
97015: LIST
97016: LIST
97017: ST_TO_ADDR
97018: GO 100093
97020: LD_INT 2
97022: DOUBLE
97023: EQUAL
97024: IFTRUE 97028
97026: GO 97112
97028: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
97029: LD_ADDR_VAR 0 2
97033: PUSH
97034: LD_INT 2
97036: PUSH
97037: LD_INT 4
97039: PUSH
97040: LD_INT 11
97042: PUSH
97043: LD_INT 12
97045: PUSH
97046: LD_INT 15
97048: PUSH
97049: LD_INT 16
97051: PUSH
97052: LD_INT 22
97054: PUSH
97055: LD_INT 23
97057: PUSH
97058: LD_INT 26
97060: PUSH
97061: EMPTY
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: PUSH
97072: LD_INT 101
97074: PUSH
97075: LD_INT 102
97077: PUSH
97078: LD_INT 105
97080: PUSH
97081: LD_INT 106
97083: PUSH
97084: LD_INT 108
97086: PUSH
97087: LD_INT 116
97089: PUSH
97090: LD_INT 117
97092: PUSH
97093: LD_INT 118
97095: PUSH
97096: EMPTY
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: PUSH
97106: EMPTY
97107: LIST
97108: LIST
97109: ST_TO_ADDR
97110: GO 100093
97112: LD_INT 3
97114: DOUBLE
97115: EQUAL
97116: IFTRUE 97120
97118: GO 97208
97120: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
97121: LD_ADDR_VAR 0 2
97125: PUSH
97126: LD_INT 2
97128: PUSH
97129: LD_INT 4
97131: PUSH
97132: LD_INT 5
97134: PUSH
97135: LD_INT 11
97137: PUSH
97138: LD_INT 12
97140: PUSH
97141: LD_INT 15
97143: PUSH
97144: LD_INT 16
97146: PUSH
97147: LD_INT 22
97149: PUSH
97150: LD_INT 26
97152: PUSH
97153: LD_INT 36
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: PUSH
97168: LD_INT 101
97170: PUSH
97171: LD_INT 102
97173: PUSH
97174: LD_INT 105
97176: PUSH
97177: LD_INT 106
97179: PUSH
97180: LD_INT 108
97182: PUSH
97183: LD_INT 116
97185: PUSH
97186: LD_INT 117
97188: PUSH
97189: LD_INT 118
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: LIST
97196: LIST
97197: LIST
97198: LIST
97199: LIST
97200: LIST
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: ST_TO_ADDR
97206: GO 100093
97208: LD_INT 4
97210: DOUBLE
97211: EQUAL
97212: IFTRUE 97216
97214: GO 97312
97216: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
97217: LD_ADDR_VAR 0 2
97221: PUSH
97222: LD_INT 2
97224: PUSH
97225: LD_INT 4
97227: PUSH
97228: LD_INT 5
97230: PUSH
97231: LD_INT 8
97233: PUSH
97234: LD_INT 11
97236: PUSH
97237: LD_INT 12
97239: PUSH
97240: LD_INT 15
97242: PUSH
97243: LD_INT 16
97245: PUSH
97246: LD_INT 22
97248: PUSH
97249: LD_INT 23
97251: PUSH
97252: LD_INT 26
97254: PUSH
97255: LD_INT 36
97257: PUSH
97258: EMPTY
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: PUSH
97272: LD_INT 101
97274: PUSH
97275: LD_INT 102
97277: PUSH
97278: LD_INT 105
97280: PUSH
97281: LD_INT 106
97283: PUSH
97284: LD_INT 108
97286: PUSH
97287: LD_INT 116
97289: PUSH
97290: LD_INT 117
97292: PUSH
97293: LD_INT 118
97295: PUSH
97296: EMPTY
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: PUSH
97306: EMPTY
97307: LIST
97308: LIST
97309: ST_TO_ADDR
97310: GO 100093
97312: LD_INT 5
97314: DOUBLE
97315: EQUAL
97316: IFTRUE 97320
97318: GO 97432
97320: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
97321: LD_ADDR_VAR 0 2
97325: PUSH
97326: LD_INT 2
97328: PUSH
97329: LD_INT 4
97331: PUSH
97332: LD_INT 5
97334: PUSH
97335: LD_INT 6
97337: PUSH
97338: LD_INT 8
97340: PUSH
97341: LD_INT 11
97343: PUSH
97344: LD_INT 12
97346: PUSH
97347: LD_INT 15
97349: PUSH
97350: LD_INT 16
97352: PUSH
97353: LD_INT 22
97355: PUSH
97356: LD_INT 23
97358: PUSH
97359: LD_INT 25
97361: PUSH
97362: LD_INT 26
97364: PUSH
97365: LD_INT 36
97367: PUSH
97368: EMPTY
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: PUSH
97384: LD_INT 101
97386: PUSH
97387: LD_INT 102
97389: PUSH
97390: LD_INT 105
97392: PUSH
97393: LD_INT 106
97395: PUSH
97396: LD_INT 108
97398: PUSH
97399: LD_INT 109
97401: PUSH
97402: LD_INT 112
97404: PUSH
97405: LD_INT 116
97407: PUSH
97408: LD_INT 117
97410: PUSH
97411: LD_INT 118
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: PUSH
97426: EMPTY
97427: LIST
97428: LIST
97429: ST_TO_ADDR
97430: GO 100093
97432: LD_INT 6
97434: DOUBLE
97435: EQUAL
97436: IFTRUE 97440
97438: GO 97572
97440: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
97441: LD_ADDR_VAR 0 2
97445: PUSH
97446: LD_INT 2
97448: PUSH
97449: LD_INT 4
97451: PUSH
97452: LD_INT 5
97454: PUSH
97455: LD_INT 6
97457: PUSH
97458: LD_INT 8
97460: PUSH
97461: LD_INT 11
97463: PUSH
97464: LD_INT 12
97466: PUSH
97467: LD_INT 15
97469: PUSH
97470: LD_INT 16
97472: PUSH
97473: LD_INT 20
97475: PUSH
97476: LD_INT 21
97478: PUSH
97479: LD_INT 22
97481: PUSH
97482: LD_INT 23
97484: PUSH
97485: LD_INT 25
97487: PUSH
97488: LD_INT 26
97490: PUSH
97491: LD_INT 30
97493: PUSH
97494: LD_INT 31
97496: PUSH
97497: LD_INT 32
97499: PUSH
97500: LD_INT 36
97502: PUSH
97503: EMPTY
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: PUSH
97524: LD_INT 101
97526: PUSH
97527: LD_INT 102
97529: PUSH
97530: LD_INT 105
97532: PUSH
97533: LD_INT 106
97535: PUSH
97536: LD_INT 108
97538: PUSH
97539: LD_INT 109
97541: PUSH
97542: LD_INT 112
97544: PUSH
97545: LD_INT 116
97547: PUSH
97548: LD_INT 117
97550: PUSH
97551: LD_INT 118
97553: PUSH
97554: EMPTY
97555: LIST
97556: LIST
97557: LIST
97558: LIST
97559: LIST
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: ST_TO_ADDR
97570: GO 100093
97572: LD_INT 7
97574: DOUBLE
97575: EQUAL
97576: IFTRUE 97580
97578: GO 97692
97580: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97581: LD_ADDR_VAR 0 2
97585: PUSH
97586: LD_INT 2
97588: PUSH
97589: LD_INT 4
97591: PUSH
97592: LD_INT 5
97594: PUSH
97595: LD_INT 7
97597: PUSH
97598: LD_INT 11
97600: PUSH
97601: LD_INT 12
97603: PUSH
97604: LD_INT 15
97606: PUSH
97607: LD_INT 16
97609: PUSH
97610: LD_INT 20
97612: PUSH
97613: LD_INT 21
97615: PUSH
97616: LD_INT 22
97618: PUSH
97619: LD_INT 23
97621: PUSH
97622: LD_INT 25
97624: PUSH
97625: LD_INT 26
97627: PUSH
97628: EMPTY
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: PUSH
97644: LD_INT 101
97646: PUSH
97647: LD_INT 102
97649: PUSH
97650: LD_INT 103
97652: PUSH
97653: LD_INT 105
97655: PUSH
97656: LD_INT 106
97658: PUSH
97659: LD_INT 108
97661: PUSH
97662: LD_INT 112
97664: PUSH
97665: LD_INT 116
97667: PUSH
97668: LD_INT 117
97670: PUSH
97671: LD_INT 118
97673: PUSH
97674: EMPTY
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: PUSH
97686: EMPTY
97687: LIST
97688: LIST
97689: ST_TO_ADDR
97690: GO 100093
97692: LD_INT 8
97694: DOUBLE
97695: EQUAL
97696: IFTRUE 97700
97698: GO 97840
97700: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97701: LD_ADDR_VAR 0 2
97705: PUSH
97706: LD_INT 2
97708: PUSH
97709: LD_INT 4
97711: PUSH
97712: LD_INT 5
97714: PUSH
97715: LD_INT 6
97717: PUSH
97718: LD_INT 7
97720: PUSH
97721: LD_INT 8
97723: PUSH
97724: LD_INT 11
97726: PUSH
97727: LD_INT 12
97729: PUSH
97730: LD_INT 15
97732: PUSH
97733: LD_INT 16
97735: PUSH
97736: LD_INT 20
97738: PUSH
97739: LD_INT 21
97741: PUSH
97742: LD_INT 22
97744: PUSH
97745: LD_INT 23
97747: PUSH
97748: LD_INT 25
97750: PUSH
97751: LD_INT 26
97753: PUSH
97754: LD_INT 30
97756: PUSH
97757: LD_INT 31
97759: PUSH
97760: LD_INT 32
97762: PUSH
97763: LD_INT 36
97765: PUSH
97766: EMPTY
97767: LIST
97768: LIST
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: PUSH
97788: LD_INT 101
97790: PUSH
97791: LD_INT 102
97793: PUSH
97794: LD_INT 103
97796: PUSH
97797: LD_INT 105
97799: PUSH
97800: LD_INT 106
97802: PUSH
97803: LD_INT 108
97805: PUSH
97806: LD_INT 109
97808: PUSH
97809: LD_INT 112
97811: PUSH
97812: LD_INT 116
97814: PUSH
97815: LD_INT 117
97817: PUSH
97818: LD_INT 118
97820: PUSH
97821: EMPTY
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: PUSH
97834: EMPTY
97835: LIST
97836: LIST
97837: ST_TO_ADDR
97838: GO 100093
97840: LD_INT 9
97842: DOUBLE
97843: EQUAL
97844: IFTRUE 97848
97846: GO 97996
97848: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97849: LD_ADDR_VAR 0 2
97853: PUSH
97854: LD_INT 2
97856: PUSH
97857: LD_INT 4
97859: PUSH
97860: LD_INT 5
97862: PUSH
97863: LD_INT 6
97865: PUSH
97866: LD_INT 7
97868: PUSH
97869: LD_INT 8
97871: PUSH
97872: LD_INT 11
97874: PUSH
97875: LD_INT 12
97877: PUSH
97878: LD_INT 15
97880: PUSH
97881: LD_INT 16
97883: PUSH
97884: LD_INT 20
97886: PUSH
97887: LD_INT 21
97889: PUSH
97890: LD_INT 22
97892: PUSH
97893: LD_INT 23
97895: PUSH
97896: LD_INT 25
97898: PUSH
97899: LD_INT 26
97901: PUSH
97902: LD_INT 28
97904: PUSH
97905: LD_INT 30
97907: PUSH
97908: LD_INT 31
97910: PUSH
97911: LD_INT 32
97913: PUSH
97914: LD_INT 36
97916: PUSH
97917: EMPTY
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: PUSH
97940: LD_INT 101
97942: PUSH
97943: LD_INT 102
97945: PUSH
97946: LD_INT 103
97948: PUSH
97949: LD_INT 105
97951: PUSH
97952: LD_INT 106
97954: PUSH
97955: LD_INT 108
97957: PUSH
97958: LD_INT 109
97960: PUSH
97961: LD_INT 112
97963: PUSH
97964: LD_INT 114
97966: PUSH
97967: LD_INT 116
97969: PUSH
97970: LD_INT 117
97972: PUSH
97973: LD_INT 118
97975: PUSH
97976: EMPTY
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: LIST
97988: LIST
97989: PUSH
97990: EMPTY
97991: LIST
97992: LIST
97993: ST_TO_ADDR
97994: GO 100093
97996: LD_INT 10
97998: DOUBLE
97999: EQUAL
98000: IFTRUE 98004
98002: GO 98200
98004: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
98005: LD_ADDR_VAR 0 2
98009: PUSH
98010: LD_INT 2
98012: PUSH
98013: LD_INT 4
98015: PUSH
98016: LD_INT 5
98018: PUSH
98019: LD_INT 6
98021: PUSH
98022: LD_INT 7
98024: PUSH
98025: LD_INT 8
98027: PUSH
98028: LD_INT 9
98030: PUSH
98031: LD_INT 10
98033: PUSH
98034: LD_INT 11
98036: PUSH
98037: LD_INT 12
98039: PUSH
98040: LD_INT 13
98042: PUSH
98043: LD_INT 14
98045: PUSH
98046: LD_INT 15
98048: PUSH
98049: LD_INT 16
98051: PUSH
98052: LD_INT 17
98054: PUSH
98055: LD_INT 18
98057: PUSH
98058: LD_INT 19
98060: PUSH
98061: LD_INT 20
98063: PUSH
98064: LD_INT 21
98066: PUSH
98067: LD_INT 22
98069: PUSH
98070: LD_INT 23
98072: PUSH
98073: LD_INT 24
98075: PUSH
98076: LD_INT 25
98078: PUSH
98079: LD_INT 26
98081: PUSH
98082: LD_INT 28
98084: PUSH
98085: LD_INT 30
98087: PUSH
98088: LD_INT 31
98090: PUSH
98091: LD_INT 32
98093: PUSH
98094: LD_INT 36
98096: PUSH
98097: EMPTY
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: PUSH
98128: LD_INT 101
98130: PUSH
98131: LD_INT 102
98133: PUSH
98134: LD_INT 103
98136: PUSH
98137: LD_INT 104
98139: PUSH
98140: LD_INT 105
98142: PUSH
98143: LD_INT 106
98145: PUSH
98146: LD_INT 107
98148: PUSH
98149: LD_INT 108
98151: PUSH
98152: LD_INT 109
98154: PUSH
98155: LD_INT 110
98157: PUSH
98158: LD_INT 111
98160: PUSH
98161: LD_INT 112
98163: PUSH
98164: LD_INT 114
98166: PUSH
98167: LD_INT 116
98169: PUSH
98170: LD_INT 117
98172: PUSH
98173: LD_INT 118
98175: PUSH
98176: EMPTY
98177: LIST
98178: LIST
98179: LIST
98180: LIST
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: PUSH
98194: EMPTY
98195: LIST
98196: LIST
98197: ST_TO_ADDR
98198: GO 100093
98200: LD_INT 11
98202: DOUBLE
98203: EQUAL
98204: IFTRUE 98208
98206: GO 98412
98208: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
98209: LD_ADDR_VAR 0 2
98213: PUSH
98214: LD_INT 2
98216: PUSH
98217: LD_INT 3
98219: PUSH
98220: LD_INT 4
98222: PUSH
98223: LD_INT 5
98225: PUSH
98226: LD_INT 6
98228: PUSH
98229: LD_INT 7
98231: PUSH
98232: LD_INT 8
98234: PUSH
98235: LD_INT 9
98237: PUSH
98238: LD_INT 10
98240: PUSH
98241: LD_INT 11
98243: PUSH
98244: LD_INT 12
98246: PUSH
98247: LD_INT 13
98249: PUSH
98250: LD_INT 14
98252: PUSH
98253: LD_INT 15
98255: PUSH
98256: LD_INT 16
98258: PUSH
98259: LD_INT 17
98261: PUSH
98262: LD_INT 18
98264: PUSH
98265: LD_INT 19
98267: PUSH
98268: LD_INT 20
98270: PUSH
98271: LD_INT 21
98273: PUSH
98274: LD_INT 22
98276: PUSH
98277: LD_INT 23
98279: PUSH
98280: LD_INT 24
98282: PUSH
98283: LD_INT 25
98285: PUSH
98286: LD_INT 26
98288: PUSH
98289: LD_INT 28
98291: PUSH
98292: LD_INT 30
98294: PUSH
98295: LD_INT 31
98297: PUSH
98298: LD_INT 32
98300: PUSH
98301: LD_INT 34
98303: PUSH
98304: LD_INT 36
98306: PUSH
98307: EMPTY
98308: LIST
98309: LIST
98310: LIST
98311: LIST
98312: LIST
98313: LIST
98314: LIST
98315: LIST
98316: LIST
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: PUSH
98340: LD_INT 101
98342: PUSH
98343: LD_INT 102
98345: PUSH
98346: LD_INT 103
98348: PUSH
98349: LD_INT 104
98351: PUSH
98352: LD_INT 105
98354: PUSH
98355: LD_INT 106
98357: PUSH
98358: LD_INT 107
98360: PUSH
98361: LD_INT 108
98363: PUSH
98364: LD_INT 109
98366: PUSH
98367: LD_INT 110
98369: PUSH
98370: LD_INT 111
98372: PUSH
98373: LD_INT 112
98375: PUSH
98376: LD_INT 114
98378: PUSH
98379: LD_INT 116
98381: PUSH
98382: LD_INT 117
98384: PUSH
98385: LD_INT 118
98387: PUSH
98388: EMPTY
98389: LIST
98390: LIST
98391: LIST
98392: LIST
98393: LIST
98394: LIST
98395: LIST
98396: LIST
98397: LIST
98398: LIST
98399: LIST
98400: LIST
98401: LIST
98402: LIST
98403: LIST
98404: LIST
98405: PUSH
98406: EMPTY
98407: LIST
98408: LIST
98409: ST_TO_ADDR
98410: GO 100093
98412: LD_INT 12
98414: DOUBLE
98415: EQUAL
98416: IFTRUE 98420
98418: GO 98640
98420: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
98421: LD_ADDR_VAR 0 2
98425: PUSH
98426: LD_INT 1
98428: PUSH
98429: LD_INT 2
98431: PUSH
98432: LD_INT 3
98434: PUSH
98435: LD_INT 4
98437: PUSH
98438: LD_INT 5
98440: PUSH
98441: LD_INT 6
98443: PUSH
98444: LD_INT 7
98446: PUSH
98447: LD_INT 8
98449: PUSH
98450: LD_INT 9
98452: PUSH
98453: LD_INT 10
98455: PUSH
98456: LD_INT 11
98458: PUSH
98459: LD_INT 12
98461: PUSH
98462: LD_INT 13
98464: PUSH
98465: LD_INT 14
98467: PUSH
98468: LD_INT 15
98470: PUSH
98471: LD_INT 16
98473: PUSH
98474: LD_INT 17
98476: PUSH
98477: LD_INT 18
98479: PUSH
98480: LD_INT 19
98482: PUSH
98483: LD_INT 20
98485: PUSH
98486: LD_INT 21
98488: PUSH
98489: LD_INT 22
98491: PUSH
98492: LD_INT 23
98494: PUSH
98495: LD_INT 24
98497: PUSH
98498: LD_INT 25
98500: PUSH
98501: LD_INT 26
98503: PUSH
98504: LD_INT 27
98506: PUSH
98507: LD_INT 28
98509: PUSH
98510: LD_INT 30
98512: PUSH
98513: LD_INT 31
98515: PUSH
98516: LD_INT 32
98518: PUSH
98519: LD_INT 33
98521: PUSH
98522: LD_INT 34
98524: PUSH
98525: LD_INT 36
98527: PUSH
98528: EMPTY
98529: LIST
98530: LIST
98531: LIST
98532: LIST
98533: LIST
98534: LIST
98535: LIST
98536: LIST
98537: LIST
98538: LIST
98539: LIST
98540: LIST
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: PUSH
98564: LD_INT 101
98566: PUSH
98567: LD_INT 102
98569: PUSH
98570: LD_INT 103
98572: PUSH
98573: LD_INT 104
98575: PUSH
98576: LD_INT 105
98578: PUSH
98579: LD_INT 106
98581: PUSH
98582: LD_INT 107
98584: PUSH
98585: LD_INT 108
98587: PUSH
98588: LD_INT 109
98590: PUSH
98591: LD_INT 110
98593: PUSH
98594: LD_INT 111
98596: PUSH
98597: LD_INT 112
98599: PUSH
98600: LD_INT 113
98602: PUSH
98603: LD_INT 114
98605: PUSH
98606: LD_INT 116
98608: PUSH
98609: LD_INT 117
98611: PUSH
98612: LD_INT 118
98614: PUSH
98615: EMPTY
98616: LIST
98617: LIST
98618: LIST
98619: LIST
98620: LIST
98621: LIST
98622: LIST
98623: LIST
98624: LIST
98625: LIST
98626: LIST
98627: LIST
98628: LIST
98629: LIST
98630: LIST
98631: LIST
98632: LIST
98633: PUSH
98634: EMPTY
98635: LIST
98636: LIST
98637: ST_TO_ADDR
98638: GO 100093
98640: LD_INT 13
98642: DOUBLE
98643: EQUAL
98644: IFTRUE 98648
98646: GO 98856
98648: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98649: LD_ADDR_VAR 0 2
98653: PUSH
98654: LD_INT 1
98656: PUSH
98657: LD_INT 2
98659: PUSH
98660: LD_INT 3
98662: PUSH
98663: LD_INT 4
98665: PUSH
98666: LD_INT 5
98668: PUSH
98669: LD_INT 8
98671: PUSH
98672: LD_INT 9
98674: PUSH
98675: LD_INT 10
98677: PUSH
98678: LD_INT 11
98680: PUSH
98681: LD_INT 12
98683: PUSH
98684: LD_INT 14
98686: PUSH
98687: LD_INT 15
98689: PUSH
98690: LD_INT 16
98692: PUSH
98693: LD_INT 17
98695: PUSH
98696: LD_INT 18
98698: PUSH
98699: LD_INT 19
98701: PUSH
98702: LD_INT 20
98704: PUSH
98705: LD_INT 21
98707: PUSH
98708: LD_INT 22
98710: PUSH
98711: LD_INT 23
98713: PUSH
98714: LD_INT 24
98716: PUSH
98717: LD_INT 25
98719: PUSH
98720: LD_INT 26
98722: PUSH
98723: LD_INT 27
98725: PUSH
98726: LD_INT 28
98728: PUSH
98729: LD_INT 30
98731: PUSH
98732: LD_INT 31
98734: PUSH
98735: LD_INT 32
98737: PUSH
98738: LD_INT 33
98740: PUSH
98741: LD_INT 34
98743: PUSH
98744: LD_INT 36
98746: PUSH
98747: EMPTY
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: LIST
98762: LIST
98763: LIST
98764: LIST
98765: LIST
98766: LIST
98767: LIST
98768: LIST
98769: LIST
98770: LIST
98771: LIST
98772: LIST
98773: LIST
98774: LIST
98775: LIST
98776: LIST
98777: LIST
98778: LIST
98779: PUSH
98780: LD_INT 101
98782: PUSH
98783: LD_INT 102
98785: PUSH
98786: LD_INT 103
98788: PUSH
98789: LD_INT 104
98791: PUSH
98792: LD_INT 105
98794: PUSH
98795: LD_INT 106
98797: PUSH
98798: LD_INT 107
98800: PUSH
98801: LD_INT 108
98803: PUSH
98804: LD_INT 109
98806: PUSH
98807: LD_INT 110
98809: PUSH
98810: LD_INT 111
98812: PUSH
98813: LD_INT 112
98815: PUSH
98816: LD_INT 113
98818: PUSH
98819: LD_INT 114
98821: PUSH
98822: LD_INT 116
98824: PUSH
98825: LD_INT 117
98827: PUSH
98828: LD_INT 118
98830: PUSH
98831: EMPTY
98832: LIST
98833: LIST
98834: LIST
98835: LIST
98836: LIST
98837: LIST
98838: LIST
98839: LIST
98840: LIST
98841: LIST
98842: LIST
98843: LIST
98844: LIST
98845: LIST
98846: LIST
98847: LIST
98848: LIST
98849: PUSH
98850: EMPTY
98851: LIST
98852: LIST
98853: ST_TO_ADDR
98854: GO 100093
98856: LD_INT 14
98858: DOUBLE
98859: EQUAL
98860: IFTRUE 98864
98862: GO 99088
98864: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98865: LD_ADDR_VAR 0 2
98869: PUSH
98870: LD_INT 1
98872: PUSH
98873: LD_INT 2
98875: PUSH
98876: LD_INT 3
98878: PUSH
98879: LD_INT 4
98881: PUSH
98882: LD_INT 5
98884: PUSH
98885: LD_INT 6
98887: PUSH
98888: LD_INT 7
98890: PUSH
98891: LD_INT 8
98893: PUSH
98894: LD_INT 9
98896: PUSH
98897: LD_INT 10
98899: PUSH
98900: LD_INT 11
98902: PUSH
98903: LD_INT 12
98905: PUSH
98906: LD_INT 13
98908: PUSH
98909: LD_INT 14
98911: PUSH
98912: LD_INT 15
98914: PUSH
98915: LD_INT 16
98917: PUSH
98918: LD_INT 17
98920: PUSH
98921: LD_INT 18
98923: PUSH
98924: LD_INT 19
98926: PUSH
98927: LD_INT 20
98929: PUSH
98930: LD_INT 21
98932: PUSH
98933: LD_INT 22
98935: PUSH
98936: LD_INT 23
98938: PUSH
98939: LD_INT 24
98941: PUSH
98942: LD_INT 25
98944: PUSH
98945: LD_INT 26
98947: PUSH
98948: LD_INT 27
98950: PUSH
98951: LD_INT 28
98953: PUSH
98954: LD_INT 29
98956: PUSH
98957: LD_INT 30
98959: PUSH
98960: LD_INT 31
98962: PUSH
98963: LD_INT 32
98965: PUSH
98966: LD_INT 33
98968: PUSH
98969: LD_INT 34
98971: PUSH
98972: LD_INT 36
98974: PUSH
98975: EMPTY
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: LIST
98990: LIST
98991: LIST
98992: LIST
98993: LIST
98994: LIST
98995: LIST
98996: LIST
98997: LIST
98998: LIST
98999: LIST
99000: LIST
99001: LIST
99002: LIST
99003: LIST
99004: LIST
99005: LIST
99006: LIST
99007: LIST
99008: LIST
99009: LIST
99010: LIST
99011: PUSH
99012: LD_INT 101
99014: PUSH
99015: LD_INT 102
99017: PUSH
99018: LD_INT 103
99020: PUSH
99021: LD_INT 104
99023: PUSH
99024: LD_INT 105
99026: PUSH
99027: LD_INT 106
99029: PUSH
99030: LD_INT 107
99032: PUSH
99033: LD_INT 108
99035: PUSH
99036: LD_INT 109
99038: PUSH
99039: LD_INT 110
99041: PUSH
99042: LD_INT 111
99044: PUSH
99045: LD_INT 112
99047: PUSH
99048: LD_INT 113
99050: PUSH
99051: LD_INT 114
99053: PUSH
99054: LD_INT 116
99056: PUSH
99057: LD_INT 117
99059: PUSH
99060: LD_INT 118
99062: PUSH
99063: EMPTY
99064: LIST
99065: LIST
99066: LIST
99067: LIST
99068: LIST
99069: LIST
99070: LIST
99071: LIST
99072: LIST
99073: LIST
99074: LIST
99075: LIST
99076: LIST
99077: LIST
99078: LIST
99079: LIST
99080: LIST
99081: PUSH
99082: EMPTY
99083: LIST
99084: LIST
99085: ST_TO_ADDR
99086: GO 100093
99088: LD_INT 15
99090: DOUBLE
99091: EQUAL
99092: IFTRUE 99096
99094: GO 99320
99096: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
99097: LD_ADDR_VAR 0 2
99101: PUSH
99102: LD_INT 1
99104: PUSH
99105: LD_INT 2
99107: PUSH
99108: LD_INT 3
99110: PUSH
99111: LD_INT 4
99113: PUSH
99114: LD_INT 5
99116: PUSH
99117: LD_INT 6
99119: PUSH
99120: LD_INT 7
99122: PUSH
99123: LD_INT 8
99125: PUSH
99126: LD_INT 9
99128: PUSH
99129: LD_INT 10
99131: PUSH
99132: LD_INT 11
99134: PUSH
99135: LD_INT 12
99137: PUSH
99138: LD_INT 13
99140: PUSH
99141: LD_INT 14
99143: PUSH
99144: LD_INT 15
99146: PUSH
99147: LD_INT 16
99149: PUSH
99150: LD_INT 17
99152: PUSH
99153: LD_INT 18
99155: PUSH
99156: LD_INT 19
99158: PUSH
99159: LD_INT 20
99161: PUSH
99162: LD_INT 21
99164: PUSH
99165: LD_INT 22
99167: PUSH
99168: LD_INT 23
99170: PUSH
99171: LD_INT 24
99173: PUSH
99174: LD_INT 25
99176: PUSH
99177: LD_INT 26
99179: PUSH
99180: LD_INT 27
99182: PUSH
99183: LD_INT 28
99185: PUSH
99186: LD_INT 29
99188: PUSH
99189: LD_INT 30
99191: PUSH
99192: LD_INT 31
99194: PUSH
99195: LD_INT 32
99197: PUSH
99198: LD_INT 33
99200: PUSH
99201: LD_INT 34
99203: PUSH
99204: LD_INT 36
99206: PUSH
99207: EMPTY
99208: LIST
99209: LIST
99210: LIST
99211: LIST
99212: LIST
99213: LIST
99214: LIST
99215: LIST
99216: LIST
99217: LIST
99218: LIST
99219: LIST
99220: LIST
99221: LIST
99222: LIST
99223: LIST
99224: LIST
99225: LIST
99226: LIST
99227: LIST
99228: LIST
99229: LIST
99230: LIST
99231: LIST
99232: LIST
99233: LIST
99234: LIST
99235: LIST
99236: LIST
99237: LIST
99238: LIST
99239: LIST
99240: LIST
99241: LIST
99242: LIST
99243: PUSH
99244: LD_INT 101
99246: PUSH
99247: LD_INT 102
99249: PUSH
99250: LD_INT 103
99252: PUSH
99253: LD_INT 104
99255: PUSH
99256: LD_INT 105
99258: PUSH
99259: LD_INT 106
99261: PUSH
99262: LD_INT 107
99264: PUSH
99265: LD_INT 108
99267: PUSH
99268: LD_INT 109
99270: PUSH
99271: LD_INT 110
99273: PUSH
99274: LD_INT 111
99276: PUSH
99277: LD_INT 112
99279: PUSH
99280: LD_INT 113
99282: PUSH
99283: LD_INT 114
99285: PUSH
99286: LD_INT 116
99288: PUSH
99289: LD_INT 117
99291: PUSH
99292: LD_INT 118
99294: PUSH
99295: EMPTY
99296: LIST
99297: LIST
99298: LIST
99299: LIST
99300: LIST
99301: LIST
99302: LIST
99303: LIST
99304: LIST
99305: LIST
99306: LIST
99307: LIST
99308: LIST
99309: LIST
99310: LIST
99311: LIST
99312: LIST
99313: PUSH
99314: EMPTY
99315: LIST
99316: LIST
99317: ST_TO_ADDR
99318: GO 100093
99320: LD_INT 16
99322: DOUBLE
99323: EQUAL
99324: IFTRUE 99328
99326: GO 99464
99328: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
99329: LD_ADDR_VAR 0 2
99333: PUSH
99334: LD_INT 2
99336: PUSH
99337: LD_INT 4
99339: PUSH
99340: LD_INT 5
99342: PUSH
99343: LD_INT 7
99345: PUSH
99346: LD_INT 11
99348: PUSH
99349: LD_INT 12
99351: PUSH
99352: LD_INT 15
99354: PUSH
99355: LD_INT 16
99357: PUSH
99358: LD_INT 20
99360: PUSH
99361: LD_INT 21
99363: PUSH
99364: LD_INT 22
99366: PUSH
99367: LD_INT 23
99369: PUSH
99370: LD_INT 25
99372: PUSH
99373: LD_INT 26
99375: PUSH
99376: LD_INT 30
99378: PUSH
99379: LD_INT 31
99381: PUSH
99382: LD_INT 32
99384: PUSH
99385: LD_INT 33
99387: PUSH
99388: LD_INT 34
99390: PUSH
99391: EMPTY
99392: LIST
99393: LIST
99394: LIST
99395: LIST
99396: LIST
99397: LIST
99398: LIST
99399: LIST
99400: LIST
99401: LIST
99402: LIST
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: PUSH
99412: LD_INT 101
99414: PUSH
99415: LD_INT 102
99417: PUSH
99418: LD_INT 103
99420: PUSH
99421: LD_INT 106
99423: PUSH
99424: LD_INT 108
99426: PUSH
99427: LD_INT 112
99429: PUSH
99430: LD_INT 113
99432: PUSH
99433: LD_INT 114
99435: PUSH
99436: LD_INT 116
99438: PUSH
99439: LD_INT 117
99441: PUSH
99442: LD_INT 118
99444: PUSH
99445: EMPTY
99446: LIST
99447: LIST
99448: LIST
99449: LIST
99450: LIST
99451: LIST
99452: LIST
99453: LIST
99454: LIST
99455: LIST
99456: LIST
99457: PUSH
99458: EMPTY
99459: LIST
99460: LIST
99461: ST_TO_ADDR
99462: GO 100093
99464: LD_INT 17
99466: DOUBLE
99467: EQUAL
99468: IFTRUE 99472
99470: GO 99696
99472: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99473: LD_ADDR_VAR 0 2
99477: PUSH
99478: LD_INT 1
99480: PUSH
99481: LD_INT 2
99483: PUSH
99484: LD_INT 3
99486: PUSH
99487: LD_INT 4
99489: PUSH
99490: LD_INT 5
99492: PUSH
99493: LD_INT 6
99495: PUSH
99496: LD_INT 7
99498: PUSH
99499: LD_INT 8
99501: PUSH
99502: LD_INT 9
99504: PUSH
99505: LD_INT 10
99507: PUSH
99508: LD_INT 11
99510: PUSH
99511: LD_INT 12
99513: PUSH
99514: LD_INT 13
99516: PUSH
99517: LD_INT 14
99519: PUSH
99520: LD_INT 15
99522: PUSH
99523: LD_INT 16
99525: PUSH
99526: LD_INT 17
99528: PUSH
99529: LD_INT 18
99531: PUSH
99532: LD_INT 19
99534: PUSH
99535: LD_INT 20
99537: PUSH
99538: LD_INT 21
99540: PUSH
99541: LD_INT 22
99543: PUSH
99544: LD_INT 23
99546: PUSH
99547: LD_INT 24
99549: PUSH
99550: LD_INT 25
99552: PUSH
99553: LD_INT 26
99555: PUSH
99556: LD_INT 27
99558: PUSH
99559: LD_INT 28
99561: PUSH
99562: LD_INT 29
99564: PUSH
99565: LD_INT 30
99567: PUSH
99568: LD_INT 31
99570: PUSH
99571: LD_INT 32
99573: PUSH
99574: LD_INT 33
99576: PUSH
99577: LD_INT 34
99579: PUSH
99580: LD_INT 36
99582: PUSH
99583: EMPTY
99584: LIST
99585: LIST
99586: LIST
99587: LIST
99588: LIST
99589: LIST
99590: LIST
99591: LIST
99592: LIST
99593: LIST
99594: LIST
99595: LIST
99596: LIST
99597: LIST
99598: LIST
99599: LIST
99600: LIST
99601: LIST
99602: LIST
99603: LIST
99604: LIST
99605: LIST
99606: LIST
99607: LIST
99608: LIST
99609: LIST
99610: LIST
99611: LIST
99612: LIST
99613: LIST
99614: LIST
99615: LIST
99616: LIST
99617: LIST
99618: LIST
99619: PUSH
99620: LD_INT 101
99622: PUSH
99623: LD_INT 102
99625: PUSH
99626: LD_INT 103
99628: PUSH
99629: LD_INT 104
99631: PUSH
99632: LD_INT 105
99634: PUSH
99635: LD_INT 106
99637: PUSH
99638: LD_INT 107
99640: PUSH
99641: LD_INT 108
99643: PUSH
99644: LD_INT 109
99646: PUSH
99647: LD_INT 110
99649: PUSH
99650: LD_INT 111
99652: PUSH
99653: LD_INT 112
99655: PUSH
99656: LD_INT 113
99658: PUSH
99659: LD_INT 114
99661: PUSH
99662: LD_INT 116
99664: PUSH
99665: LD_INT 117
99667: PUSH
99668: LD_INT 118
99670: PUSH
99671: EMPTY
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: LIST
99677: LIST
99678: LIST
99679: LIST
99680: LIST
99681: LIST
99682: LIST
99683: LIST
99684: LIST
99685: LIST
99686: LIST
99687: LIST
99688: LIST
99689: PUSH
99690: EMPTY
99691: LIST
99692: LIST
99693: ST_TO_ADDR
99694: GO 100093
99696: LD_INT 18
99698: DOUBLE
99699: EQUAL
99700: IFTRUE 99704
99702: GO 99852
99704: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99705: LD_ADDR_VAR 0 2
99709: PUSH
99710: LD_INT 2
99712: PUSH
99713: LD_INT 4
99715: PUSH
99716: LD_INT 5
99718: PUSH
99719: LD_INT 7
99721: PUSH
99722: LD_INT 11
99724: PUSH
99725: LD_INT 12
99727: PUSH
99728: LD_INT 15
99730: PUSH
99731: LD_INT 16
99733: PUSH
99734: LD_INT 20
99736: PUSH
99737: LD_INT 21
99739: PUSH
99740: LD_INT 22
99742: PUSH
99743: LD_INT 23
99745: PUSH
99746: LD_INT 25
99748: PUSH
99749: LD_INT 26
99751: PUSH
99752: LD_INT 30
99754: PUSH
99755: LD_INT 31
99757: PUSH
99758: LD_INT 32
99760: PUSH
99761: LD_INT 33
99763: PUSH
99764: LD_INT 34
99766: PUSH
99767: LD_INT 35
99769: PUSH
99770: LD_INT 36
99772: PUSH
99773: EMPTY
99774: LIST
99775: LIST
99776: LIST
99777: LIST
99778: LIST
99779: LIST
99780: LIST
99781: LIST
99782: LIST
99783: LIST
99784: LIST
99785: LIST
99786: LIST
99787: LIST
99788: LIST
99789: LIST
99790: LIST
99791: LIST
99792: LIST
99793: LIST
99794: LIST
99795: PUSH
99796: LD_INT 101
99798: PUSH
99799: LD_INT 102
99801: PUSH
99802: LD_INT 103
99804: PUSH
99805: LD_INT 106
99807: PUSH
99808: LD_INT 108
99810: PUSH
99811: LD_INT 112
99813: PUSH
99814: LD_INT 113
99816: PUSH
99817: LD_INT 114
99819: PUSH
99820: LD_INT 115
99822: PUSH
99823: LD_INT 116
99825: PUSH
99826: LD_INT 117
99828: PUSH
99829: LD_INT 118
99831: PUSH
99832: EMPTY
99833: LIST
99834: LIST
99835: LIST
99836: LIST
99837: LIST
99838: LIST
99839: LIST
99840: LIST
99841: LIST
99842: LIST
99843: LIST
99844: LIST
99845: PUSH
99846: EMPTY
99847: LIST
99848: LIST
99849: ST_TO_ADDR
99850: GO 100093
99852: LD_INT 19
99854: DOUBLE
99855: EQUAL
99856: IFTRUE 99860
99858: GO 100092
99860: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99861: LD_ADDR_VAR 0 2
99865: PUSH
99866: LD_INT 1
99868: PUSH
99869: LD_INT 2
99871: PUSH
99872: LD_INT 3
99874: PUSH
99875: LD_INT 4
99877: PUSH
99878: LD_INT 5
99880: PUSH
99881: LD_INT 6
99883: PUSH
99884: LD_INT 7
99886: PUSH
99887: LD_INT 8
99889: PUSH
99890: LD_INT 9
99892: PUSH
99893: LD_INT 10
99895: PUSH
99896: LD_INT 11
99898: PUSH
99899: LD_INT 12
99901: PUSH
99902: LD_INT 13
99904: PUSH
99905: LD_INT 14
99907: PUSH
99908: LD_INT 15
99910: PUSH
99911: LD_INT 16
99913: PUSH
99914: LD_INT 17
99916: PUSH
99917: LD_INT 18
99919: PUSH
99920: LD_INT 19
99922: PUSH
99923: LD_INT 20
99925: PUSH
99926: LD_INT 21
99928: PUSH
99929: LD_INT 22
99931: PUSH
99932: LD_INT 23
99934: PUSH
99935: LD_INT 24
99937: PUSH
99938: LD_INT 25
99940: PUSH
99941: LD_INT 26
99943: PUSH
99944: LD_INT 27
99946: PUSH
99947: LD_INT 28
99949: PUSH
99950: LD_INT 29
99952: PUSH
99953: LD_INT 30
99955: PUSH
99956: LD_INT 31
99958: PUSH
99959: LD_INT 32
99961: PUSH
99962: LD_INT 33
99964: PUSH
99965: LD_INT 34
99967: PUSH
99968: LD_INT 35
99970: PUSH
99971: LD_INT 36
99973: PUSH
99974: EMPTY
99975: LIST
99976: LIST
99977: LIST
99978: LIST
99979: LIST
99980: LIST
99981: LIST
99982: LIST
99983: LIST
99984: LIST
99985: LIST
99986: LIST
99987: LIST
99988: LIST
99989: LIST
99990: LIST
99991: LIST
99992: LIST
99993: LIST
99994: LIST
99995: LIST
99996: LIST
99997: LIST
99998: LIST
99999: LIST
100000: LIST
100001: LIST
100002: LIST
100003: LIST
100004: LIST
100005: LIST
100006: LIST
100007: LIST
100008: LIST
100009: LIST
100010: LIST
100011: PUSH
100012: LD_INT 101
100014: PUSH
100015: LD_INT 102
100017: PUSH
100018: LD_INT 103
100020: PUSH
100021: LD_INT 104
100023: PUSH
100024: LD_INT 105
100026: PUSH
100027: LD_INT 106
100029: PUSH
100030: LD_INT 107
100032: PUSH
100033: LD_INT 108
100035: PUSH
100036: LD_INT 109
100038: PUSH
100039: LD_INT 110
100041: PUSH
100042: LD_INT 111
100044: PUSH
100045: LD_INT 112
100047: PUSH
100048: LD_INT 113
100050: PUSH
100051: LD_INT 114
100053: PUSH
100054: LD_INT 115
100056: PUSH
100057: LD_INT 116
100059: PUSH
100060: LD_INT 117
100062: PUSH
100063: LD_INT 118
100065: PUSH
100066: EMPTY
100067: LIST
100068: LIST
100069: LIST
100070: LIST
100071: LIST
100072: LIST
100073: LIST
100074: LIST
100075: LIST
100076: LIST
100077: LIST
100078: LIST
100079: LIST
100080: LIST
100081: LIST
100082: LIST
100083: LIST
100084: LIST
100085: PUSH
100086: EMPTY
100087: LIST
100088: LIST
100089: ST_TO_ADDR
100090: GO 100093
100092: POP
// end else
100093: GO 100324
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
100095: LD_ADDR_VAR 0 2
100099: PUSH
100100: LD_INT 1
100102: PUSH
100103: LD_INT 2
100105: PUSH
100106: LD_INT 3
100108: PUSH
100109: LD_INT 4
100111: PUSH
100112: LD_INT 5
100114: PUSH
100115: LD_INT 6
100117: PUSH
100118: LD_INT 7
100120: PUSH
100121: LD_INT 8
100123: PUSH
100124: LD_INT 9
100126: PUSH
100127: LD_INT 10
100129: PUSH
100130: LD_INT 11
100132: PUSH
100133: LD_INT 12
100135: PUSH
100136: LD_INT 13
100138: PUSH
100139: LD_INT 14
100141: PUSH
100142: LD_INT 15
100144: PUSH
100145: LD_INT 16
100147: PUSH
100148: LD_INT 17
100150: PUSH
100151: LD_INT 18
100153: PUSH
100154: LD_INT 19
100156: PUSH
100157: LD_INT 20
100159: PUSH
100160: LD_INT 21
100162: PUSH
100163: LD_INT 22
100165: PUSH
100166: LD_INT 23
100168: PUSH
100169: LD_INT 24
100171: PUSH
100172: LD_INT 25
100174: PUSH
100175: LD_INT 26
100177: PUSH
100178: LD_INT 27
100180: PUSH
100181: LD_INT 28
100183: PUSH
100184: LD_INT 29
100186: PUSH
100187: LD_INT 30
100189: PUSH
100190: LD_INT 31
100192: PUSH
100193: LD_INT 32
100195: PUSH
100196: LD_INT 33
100198: PUSH
100199: LD_INT 34
100201: PUSH
100202: LD_INT 35
100204: PUSH
100205: LD_INT 36
100207: PUSH
100208: EMPTY
100209: LIST
100210: LIST
100211: LIST
100212: LIST
100213: LIST
100214: LIST
100215: LIST
100216: LIST
100217: LIST
100218: LIST
100219: LIST
100220: LIST
100221: LIST
100222: LIST
100223: LIST
100224: LIST
100225: LIST
100226: LIST
100227: LIST
100228: LIST
100229: LIST
100230: LIST
100231: LIST
100232: LIST
100233: LIST
100234: LIST
100235: LIST
100236: LIST
100237: LIST
100238: LIST
100239: LIST
100240: LIST
100241: LIST
100242: LIST
100243: LIST
100244: LIST
100245: PUSH
100246: LD_INT 101
100248: PUSH
100249: LD_INT 102
100251: PUSH
100252: LD_INT 103
100254: PUSH
100255: LD_INT 104
100257: PUSH
100258: LD_INT 105
100260: PUSH
100261: LD_INT 106
100263: PUSH
100264: LD_INT 107
100266: PUSH
100267: LD_INT 108
100269: PUSH
100270: LD_INT 109
100272: PUSH
100273: LD_INT 110
100275: PUSH
100276: LD_INT 111
100278: PUSH
100279: LD_INT 112
100281: PUSH
100282: LD_INT 113
100284: PUSH
100285: LD_INT 114
100287: PUSH
100288: LD_INT 115
100290: PUSH
100291: LD_INT 116
100293: PUSH
100294: LD_INT 117
100296: PUSH
100297: LD_INT 118
100299: PUSH
100300: EMPTY
100301: LIST
100302: LIST
100303: LIST
100304: LIST
100305: LIST
100306: LIST
100307: LIST
100308: LIST
100309: LIST
100310: LIST
100311: LIST
100312: LIST
100313: LIST
100314: LIST
100315: LIST
100316: LIST
100317: LIST
100318: LIST
100319: PUSH
100320: EMPTY
100321: LIST
100322: LIST
100323: ST_TO_ADDR
// if result then
100324: LD_VAR 0 2
100328: IFFALSE 101114
// begin normal :=  ;
100330: LD_ADDR_VAR 0 5
100334: PUSH
100335: LD_STRING 
100337: ST_TO_ADDR
// hardcore :=  ;
100338: LD_ADDR_VAR 0 6
100342: PUSH
100343: LD_STRING 
100345: ST_TO_ADDR
// active :=  ;
100346: LD_ADDR_VAR 0 7
100350: PUSH
100351: LD_STRING 
100353: ST_TO_ADDR
// for i = 1 to normalCounter do
100354: LD_ADDR_VAR 0 8
100358: PUSH
100359: DOUBLE
100360: LD_INT 1
100362: DEC
100363: ST_TO_ADDR
100364: LD_EXP 125
100368: PUSH
100369: FOR_TO
100370: IFFALSE 100471
// begin tmp := 0 ;
100372: LD_ADDR_VAR 0 3
100376: PUSH
100377: LD_STRING 0
100379: ST_TO_ADDR
// if result [ 1 ] then
100380: LD_VAR 0 2
100384: PUSH
100385: LD_INT 1
100387: ARRAY
100388: IFFALSE 100453
// if result [ 1 ] [ 1 ] = i then
100390: LD_VAR 0 2
100394: PUSH
100395: LD_INT 1
100397: ARRAY
100398: PUSH
100399: LD_INT 1
100401: ARRAY
100402: PUSH
100403: LD_VAR 0 8
100407: EQUAL
100408: IFFALSE 100453
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
100410: LD_ADDR_VAR 0 2
100414: PUSH
100415: LD_VAR 0 2
100419: PPUSH
100420: LD_INT 1
100422: PPUSH
100423: LD_VAR 0 2
100427: PUSH
100428: LD_INT 1
100430: ARRAY
100431: PPUSH
100432: LD_INT 1
100434: PPUSH
100435: CALL_OW 3
100439: PPUSH
100440: CALL_OW 1
100444: ST_TO_ADDR
// tmp := 1 ;
100445: LD_ADDR_VAR 0 3
100449: PUSH
100450: LD_STRING 1
100452: ST_TO_ADDR
// end ; normal := normal & tmp ;
100453: LD_ADDR_VAR 0 5
100457: PUSH
100458: LD_VAR 0 5
100462: PUSH
100463: LD_VAR 0 3
100467: STR
100468: ST_TO_ADDR
// end ;
100469: GO 100369
100471: POP
100472: POP
// for i = 1 to hardcoreCounter do
100473: LD_ADDR_VAR 0 8
100477: PUSH
100478: DOUBLE
100479: LD_INT 1
100481: DEC
100482: ST_TO_ADDR
100483: LD_EXP 126
100487: PUSH
100488: FOR_TO
100489: IFFALSE 100594
// begin tmp := 0 ;
100491: LD_ADDR_VAR 0 3
100495: PUSH
100496: LD_STRING 0
100498: ST_TO_ADDR
// if result [ 2 ] then
100499: LD_VAR 0 2
100503: PUSH
100504: LD_INT 2
100506: ARRAY
100507: IFFALSE 100576
// if result [ 2 ] [ 1 ] = 100 + i then
100509: LD_VAR 0 2
100513: PUSH
100514: LD_INT 2
100516: ARRAY
100517: PUSH
100518: LD_INT 1
100520: ARRAY
100521: PUSH
100522: LD_INT 100
100524: PUSH
100525: LD_VAR 0 8
100529: PLUS
100530: EQUAL
100531: IFFALSE 100576
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100533: LD_ADDR_VAR 0 2
100537: PUSH
100538: LD_VAR 0 2
100542: PPUSH
100543: LD_INT 2
100545: PPUSH
100546: LD_VAR 0 2
100550: PUSH
100551: LD_INT 2
100553: ARRAY
100554: PPUSH
100555: LD_INT 1
100557: PPUSH
100558: CALL_OW 3
100562: PPUSH
100563: CALL_OW 1
100567: ST_TO_ADDR
// tmp := 1 ;
100568: LD_ADDR_VAR 0 3
100572: PUSH
100573: LD_STRING 1
100575: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100576: LD_ADDR_VAR 0 6
100580: PUSH
100581: LD_VAR 0 6
100585: PUSH
100586: LD_VAR 0 3
100590: STR
100591: ST_TO_ADDR
// end ;
100592: GO 100488
100594: POP
100595: POP
// if isGameLoad then
100596: LD_VAR 0 1
100600: IFFALSE 101075
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100602: LD_ADDR_VAR 0 4
100606: PUSH
100607: LD_EXP 129
100611: PUSH
100612: LD_EXP 128
100616: PUSH
100617: LD_EXP 130
100621: PUSH
100622: LD_EXP 127
100626: PUSH
100627: LD_EXP 131
100631: PUSH
100632: LD_EXP 132
100636: PUSH
100637: LD_EXP 133
100641: PUSH
100642: LD_EXP 134
100646: PUSH
100647: LD_EXP 135
100651: PUSH
100652: LD_EXP 136
100656: PUSH
100657: LD_EXP 137
100661: PUSH
100662: LD_EXP 138
100666: PUSH
100667: LD_EXP 139
100671: PUSH
100672: LD_EXP 140
100676: PUSH
100677: LD_EXP 148
100681: PUSH
100682: LD_EXP 149
100686: PUSH
100687: LD_EXP 150
100691: PUSH
100692: LD_EXP 151
100696: PUSH
100697: LD_EXP 153
100701: PUSH
100702: LD_EXP 154
100706: PUSH
100707: LD_EXP 155
100711: PUSH
100712: LD_EXP 158
100716: PUSH
100717: LD_EXP 160
100721: PUSH
100722: LD_EXP 161
100726: PUSH
100727: LD_EXP 162
100731: PUSH
100732: LD_EXP 164
100736: PUSH
100737: LD_EXP 165
100741: PUSH
100742: LD_EXP 168
100746: PUSH
100747: LD_EXP 169
100751: PUSH
100752: LD_EXP 170
100756: PUSH
100757: LD_EXP 171
100761: PUSH
100762: LD_EXP 172
100766: PUSH
100767: LD_EXP 173
100771: PUSH
100772: LD_EXP 174
100776: PUSH
100777: LD_EXP 175
100781: PUSH
100782: LD_EXP 176
100786: PUSH
100787: LD_EXP 141
100791: PUSH
100792: LD_EXP 142
100796: PUSH
100797: LD_EXP 145
100801: PUSH
100802: LD_EXP 146
100806: PUSH
100807: LD_EXP 147
100811: PUSH
100812: LD_EXP 143
100816: PUSH
100817: LD_EXP 144
100821: PUSH
100822: LD_EXP 152
100826: PUSH
100827: LD_EXP 156
100831: PUSH
100832: LD_EXP 157
100836: PUSH
100837: LD_EXP 159
100841: PUSH
100842: LD_EXP 163
100846: PUSH
100847: LD_EXP 166
100851: PUSH
100852: LD_EXP 167
100856: PUSH
100857: LD_EXP 177
100861: PUSH
100862: LD_EXP 178
100866: PUSH
100867: LD_EXP 179
100871: PUSH
100872: LD_EXP 180
100876: PUSH
100877: EMPTY
100878: LIST
100879: LIST
100880: LIST
100881: LIST
100882: LIST
100883: LIST
100884: LIST
100885: LIST
100886: LIST
100887: LIST
100888: LIST
100889: LIST
100890: LIST
100891: LIST
100892: LIST
100893: LIST
100894: LIST
100895: LIST
100896: LIST
100897: LIST
100898: LIST
100899: LIST
100900: LIST
100901: LIST
100902: LIST
100903: LIST
100904: LIST
100905: LIST
100906: LIST
100907: LIST
100908: LIST
100909: LIST
100910: LIST
100911: LIST
100912: LIST
100913: LIST
100914: LIST
100915: LIST
100916: LIST
100917: LIST
100918: LIST
100919: LIST
100920: LIST
100921: LIST
100922: LIST
100923: LIST
100924: LIST
100925: LIST
100926: LIST
100927: LIST
100928: LIST
100929: LIST
100930: LIST
100931: LIST
100932: ST_TO_ADDR
// tmp :=  ;
100933: LD_ADDR_VAR 0 3
100937: PUSH
100938: LD_STRING 
100940: ST_TO_ADDR
// for i = 1 to normalCounter do
100941: LD_ADDR_VAR 0 8
100945: PUSH
100946: DOUBLE
100947: LD_INT 1
100949: DEC
100950: ST_TO_ADDR
100951: LD_EXP 125
100955: PUSH
100956: FOR_TO
100957: IFFALSE 100993
// begin if flags [ i ] then
100959: LD_VAR 0 4
100963: PUSH
100964: LD_VAR 0 8
100968: ARRAY
100969: IFFALSE 100991
// tmp := tmp & i & ; ;
100971: LD_ADDR_VAR 0 3
100975: PUSH
100976: LD_VAR 0 3
100980: PUSH
100981: LD_VAR 0 8
100985: STR
100986: PUSH
100987: LD_STRING ;
100989: STR
100990: ST_TO_ADDR
// end ;
100991: GO 100956
100993: POP
100994: POP
// for i = 1 to hardcoreCounter do
100995: LD_ADDR_VAR 0 8
100999: PUSH
101000: DOUBLE
101001: LD_INT 1
101003: DEC
101004: ST_TO_ADDR
101005: LD_EXP 126
101009: PUSH
101010: FOR_TO
101011: IFFALSE 101057
// begin if flags [ normalCounter + i ] then
101013: LD_VAR 0 4
101017: PUSH
101018: LD_EXP 125
101022: PUSH
101023: LD_VAR 0 8
101027: PLUS
101028: ARRAY
101029: IFFALSE 101055
// tmp := tmp & ( 100 + i ) & ; ;
101031: LD_ADDR_VAR 0 3
101035: PUSH
101036: LD_VAR 0 3
101040: PUSH
101041: LD_INT 100
101043: PUSH
101044: LD_VAR 0 8
101048: PLUS
101049: STR
101050: PUSH
101051: LD_STRING ;
101053: STR
101054: ST_TO_ADDR
// end ;
101055: GO 101010
101057: POP
101058: POP
// if tmp then
101059: LD_VAR 0 3
101063: IFFALSE 101075
// active := tmp ;
101065: LD_ADDR_VAR 0 7
101069: PUSH
101070: LD_VAR 0 3
101074: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
101075: LD_STRING getStreamItemsFromMission("
101077: PUSH
101078: LD_VAR 0 5
101082: STR
101083: PUSH
101084: LD_STRING ","
101086: STR
101087: PUSH
101088: LD_VAR 0 6
101092: STR
101093: PUSH
101094: LD_STRING ","
101096: STR
101097: PUSH
101098: LD_VAR 0 7
101102: STR
101103: PUSH
101104: LD_STRING ")
101106: STR
101107: PPUSH
101108: CALL_OW 559
// end else
101112: GO 101121
// ToLua ( getStreamItemsFromMission("","","") ) ;
101114: LD_STRING getStreamItemsFromMission("","","")
101116: PPUSH
101117: CALL_OW 559
// end ;
101121: LD_VAR 0 2
101125: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
101126: LD_EXP 124
101130: PUSH
101131: LD_EXP 129
101135: AND
101136: IFFALSE 101260
101138: GO 101140
101140: DISABLE
101141: LD_INT 0
101143: PPUSH
101144: PPUSH
// begin enable ;
101145: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
101146: LD_ADDR_VAR 0 2
101150: PUSH
101151: LD_INT 22
101153: PUSH
101154: LD_OWVAR 2
101158: PUSH
101159: EMPTY
101160: LIST
101161: LIST
101162: PUSH
101163: LD_INT 2
101165: PUSH
101166: LD_INT 34
101168: PUSH
101169: LD_INT 7
101171: PUSH
101172: EMPTY
101173: LIST
101174: LIST
101175: PUSH
101176: LD_INT 34
101178: PUSH
101179: LD_INT 45
101181: PUSH
101182: EMPTY
101183: LIST
101184: LIST
101185: PUSH
101186: LD_INT 34
101188: PUSH
101189: LD_INT 28
101191: PUSH
101192: EMPTY
101193: LIST
101194: LIST
101195: PUSH
101196: LD_INT 34
101198: PUSH
101199: LD_INT 47
101201: PUSH
101202: EMPTY
101203: LIST
101204: LIST
101205: PUSH
101206: EMPTY
101207: LIST
101208: LIST
101209: LIST
101210: LIST
101211: LIST
101212: PUSH
101213: EMPTY
101214: LIST
101215: LIST
101216: PPUSH
101217: CALL_OW 69
101221: ST_TO_ADDR
// if not tmp then
101222: LD_VAR 0 2
101226: NOT
101227: IFFALSE 101231
// exit ;
101229: GO 101260
// for i in tmp do
101231: LD_ADDR_VAR 0 1
101235: PUSH
101236: LD_VAR 0 2
101240: PUSH
101241: FOR_IN
101242: IFFALSE 101258
// begin SetLives ( i , 0 ) ;
101244: LD_VAR 0 1
101248: PPUSH
101249: LD_INT 0
101251: PPUSH
101252: CALL_OW 234
// end ;
101256: GO 101241
101258: POP
101259: POP
// end ;
101260: PPOPN 2
101262: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
101263: LD_EXP 124
101267: PUSH
101268: LD_EXP 130
101272: AND
101273: IFFALSE 101357
101275: GO 101277
101277: DISABLE
101278: LD_INT 0
101280: PPUSH
101281: PPUSH
// begin enable ;
101282: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
101283: LD_ADDR_VAR 0 2
101287: PUSH
101288: LD_INT 22
101290: PUSH
101291: LD_OWVAR 2
101295: PUSH
101296: EMPTY
101297: LIST
101298: LIST
101299: PUSH
101300: LD_INT 32
101302: PUSH
101303: LD_INT 3
101305: PUSH
101306: EMPTY
101307: LIST
101308: LIST
101309: PUSH
101310: EMPTY
101311: LIST
101312: LIST
101313: PPUSH
101314: CALL_OW 69
101318: ST_TO_ADDR
// if not tmp then
101319: LD_VAR 0 2
101323: NOT
101324: IFFALSE 101328
// exit ;
101326: GO 101357
// for i in tmp do
101328: LD_ADDR_VAR 0 1
101332: PUSH
101333: LD_VAR 0 2
101337: PUSH
101338: FOR_IN
101339: IFFALSE 101355
// begin SetLives ( i , 0 ) ;
101341: LD_VAR 0 1
101345: PPUSH
101346: LD_INT 0
101348: PPUSH
101349: CALL_OW 234
// end ;
101353: GO 101338
101355: POP
101356: POP
// end ;
101357: PPOPN 2
101359: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
101360: LD_EXP 124
101364: PUSH
101365: LD_EXP 127
101369: AND
101370: IFFALSE 101463
101372: GO 101374
101374: DISABLE
101375: LD_INT 0
101377: PPUSH
// begin enable ;
101378: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
101379: LD_ADDR_VAR 0 1
101383: PUSH
101384: LD_INT 22
101386: PUSH
101387: LD_OWVAR 2
101391: PUSH
101392: EMPTY
101393: LIST
101394: LIST
101395: PUSH
101396: LD_INT 2
101398: PUSH
101399: LD_INT 25
101401: PUSH
101402: LD_INT 5
101404: PUSH
101405: EMPTY
101406: LIST
101407: LIST
101408: PUSH
101409: LD_INT 25
101411: PUSH
101412: LD_INT 9
101414: PUSH
101415: EMPTY
101416: LIST
101417: LIST
101418: PUSH
101419: LD_INT 25
101421: PUSH
101422: LD_INT 8
101424: PUSH
101425: EMPTY
101426: LIST
101427: LIST
101428: PUSH
101429: EMPTY
101430: LIST
101431: LIST
101432: LIST
101433: LIST
101434: PUSH
101435: EMPTY
101436: LIST
101437: LIST
101438: PPUSH
101439: CALL_OW 69
101443: PUSH
101444: FOR_IN
101445: IFFALSE 101461
// begin SetClass ( i , 1 ) ;
101447: LD_VAR 0 1
101451: PPUSH
101452: LD_INT 1
101454: PPUSH
101455: CALL_OW 336
// end ;
101459: GO 101444
101461: POP
101462: POP
// end ;
101463: PPOPN 1
101465: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101466: LD_EXP 124
101470: PUSH
101471: LD_EXP 128
101475: AND
101476: PUSH
101477: LD_OWVAR 65
101481: PUSH
101482: LD_INT 7
101484: LESS
101485: AND
101486: IFFALSE 101500
101488: GO 101490
101490: DISABLE
// begin enable ;
101491: ENABLE
// game_speed := 7 ;
101492: LD_ADDR_OWVAR 65
101496: PUSH
101497: LD_INT 7
101499: ST_TO_ADDR
// end ;
101500: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101501: LD_EXP 124
101505: PUSH
101506: LD_EXP 131
101510: AND
101511: IFFALSE 101713
101513: GO 101515
101515: DISABLE
101516: LD_INT 0
101518: PPUSH
101519: PPUSH
101520: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101521: LD_ADDR_VAR 0 3
101525: PUSH
101526: LD_INT 81
101528: PUSH
101529: LD_OWVAR 2
101533: PUSH
101534: EMPTY
101535: LIST
101536: LIST
101537: PUSH
101538: LD_INT 21
101540: PUSH
101541: LD_INT 1
101543: PUSH
101544: EMPTY
101545: LIST
101546: LIST
101547: PUSH
101548: EMPTY
101549: LIST
101550: LIST
101551: PPUSH
101552: CALL_OW 69
101556: ST_TO_ADDR
// if not tmp then
101557: LD_VAR 0 3
101561: NOT
101562: IFFALSE 101566
// exit ;
101564: GO 101713
// if tmp > 5 then
101566: LD_VAR 0 3
101570: PUSH
101571: LD_INT 5
101573: GREATER
101574: IFFALSE 101586
// k := 5 else
101576: LD_ADDR_VAR 0 2
101580: PUSH
101581: LD_INT 5
101583: ST_TO_ADDR
101584: GO 101596
// k := tmp ;
101586: LD_ADDR_VAR 0 2
101590: PUSH
101591: LD_VAR 0 3
101595: ST_TO_ADDR
// for i := 1 to k do
101596: LD_ADDR_VAR 0 1
101600: PUSH
101601: DOUBLE
101602: LD_INT 1
101604: DEC
101605: ST_TO_ADDR
101606: LD_VAR 0 2
101610: PUSH
101611: FOR_TO
101612: IFFALSE 101711
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101614: LD_VAR 0 3
101618: PUSH
101619: LD_VAR 0 1
101623: ARRAY
101624: PPUSH
101625: LD_VAR 0 1
101629: PUSH
101630: LD_INT 4
101632: MOD
101633: PUSH
101634: LD_INT 1
101636: PLUS
101637: PPUSH
101638: CALL_OW 259
101642: PUSH
101643: LD_INT 10
101645: LESS
101646: IFFALSE 101709
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101648: LD_VAR 0 3
101652: PUSH
101653: LD_VAR 0 1
101657: ARRAY
101658: PPUSH
101659: LD_VAR 0 1
101663: PUSH
101664: LD_INT 4
101666: MOD
101667: PUSH
101668: LD_INT 1
101670: PLUS
101671: PPUSH
101672: LD_VAR 0 3
101676: PUSH
101677: LD_VAR 0 1
101681: ARRAY
101682: PPUSH
101683: LD_VAR 0 1
101687: PUSH
101688: LD_INT 4
101690: MOD
101691: PUSH
101692: LD_INT 1
101694: PLUS
101695: PPUSH
101696: CALL_OW 259
101700: PUSH
101701: LD_INT 1
101703: PLUS
101704: PPUSH
101705: CALL_OW 237
101709: GO 101611
101711: POP
101712: POP
// end ;
101713: PPOPN 3
101715: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101716: LD_EXP 124
101720: PUSH
101721: LD_EXP 132
101725: AND
101726: IFFALSE 101746
101728: GO 101730
101730: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101731: LD_INT 4
101733: PPUSH
101734: LD_OWVAR 2
101738: PPUSH
101739: LD_INT 0
101741: PPUSH
101742: CALL_OW 324
101746: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101747: LD_EXP 124
101751: PUSH
101752: LD_EXP 161
101756: AND
101757: IFFALSE 101777
101759: GO 101761
101761: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101762: LD_INT 19
101764: PPUSH
101765: LD_OWVAR 2
101769: PPUSH
101770: LD_INT 0
101772: PPUSH
101773: CALL_OW 324
101777: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101778: LD_EXP 124
101782: PUSH
101783: LD_EXP 133
101787: AND
101788: IFFALSE 101890
101790: GO 101792
101792: DISABLE
101793: LD_INT 0
101795: PPUSH
101796: PPUSH
// begin enable ;
101797: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101798: LD_ADDR_VAR 0 2
101802: PUSH
101803: LD_INT 22
101805: PUSH
101806: LD_OWVAR 2
101810: PUSH
101811: EMPTY
101812: LIST
101813: LIST
101814: PUSH
101815: LD_INT 2
101817: PUSH
101818: LD_INT 34
101820: PUSH
101821: LD_INT 11
101823: PUSH
101824: EMPTY
101825: LIST
101826: LIST
101827: PUSH
101828: LD_INT 34
101830: PUSH
101831: LD_INT 30
101833: PUSH
101834: EMPTY
101835: LIST
101836: LIST
101837: PUSH
101838: EMPTY
101839: LIST
101840: LIST
101841: LIST
101842: PUSH
101843: EMPTY
101844: LIST
101845: LIST
101846: PPUSH
101847: CALL_OW 69
101851: ST_TO_ADDR
// if not tmp then
101852: LD_VAR 0 2
101856: NOT
101857: IFFALSE 101861
// exit ;
101859: GO 101890
// for i in tmp do
101861: LD_ADDR_VAR 0 1
101865: PUSH
101866: LD_VAR 0 2
101870: PUSH
101871: FOR_IN
101872: IFFALSE 101888
// begin SetLives ( i , 0 ) ;
101874: LD_VAR 0 1
101878: PPUSH
101879: LD_INT 0
101881: PPUSH
101882: CALL_OW 234
// end ;
101886: GO 101871
101888: POP
101889: POP
// end ;
101890: PPOPN 2
101892: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101893: LD_EXP 124
101897: PUSH
101898: LD_EXP 134
101902: AND
101903: IFFALSE 101923
101905: GO 101907
101907: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101908: LD_INT 32
101910: PPUSH
101911: LD_OWVAR 2
101915: PPUSH
101916: LD_INT 0
101918: PPUSH
101919: CALL_OW 324
101923: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101924: LD_EXP 124
101928: PUSH
101929: LD_EXP 135
101933: AND
101934: IFFALSE 102115
101936: GO 101938
101938: DISABLE
101939: LD_INT 0
101941: PPUSH
101942: PPUSH
101943: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101944: LD_ADDR_VAR 0 2
101948: PUSH
101949: LD_INT 22
101951: PUSH
101952: LD_OWVAR 2
101956: PUSH
101957: EMPTY
101958: LIST
101959: LIST
101960: PUSH
101961: LD_INT 33
101963: PUSH
101964: LD_INT 3
101966: PUSH
101967: EMPTY
101968: LIST
101969: LIST
101970: PUSH
101971: EMPTY
101972: LIST
101973: LIST
101974: PPUSH
101975: CALL_OW 69
101979: ST_TO_ADDR
// if not tmp then
101980: LD_VAR 0 2
101984: NOT
101985: IFFALSE 101989
// exit ;
101987: GO 102115
// side := 0 ;
101989: LD_ADDR_VAR 0 3
101993: PUSH
101994: LD_INT 0
101996: ST_TO_ADDR
// for i := 1 to 8 do
101997: LD_ADDR_VAR 0 1
102001: PUSH
102002: DOUBLE
102003: LD_INT 1
102005: DEC
102006: ST_TO_ADDR
102007: LD_INT 8
102009: PUSH
102010: FOR_TO
102011: IFFALSE 102059
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
102013: LD_OWVAR 2
102017: PUSH
102018: LD_VAR 0 1
102022: NONEQUAL
102023: PUSH
102024: LD_OWVAR 2
102028: PPUSH
102029: LD_VAR 0 1
102033: PPUSH
102034: CALL_OW 81
102038: PUSH
102039: LD_INT 2
102041: EQUAL
102042: AND
102043: IFFALSE 102057
// begin side := i ;
102045: LD_ADDR_VAR 0 3
102049: PUSH
102050: LD_VAR 0 1
102054: ST_TO_ADDR
// break ;
102055: GO 102059
// end ;
102057: GO 102010
102059: POP
102060: POP
// if not side then
102061: LD_VAR 0 3
102065: NOT
102066: IFFALSE 102070
// exit ;
102068: GO 102115
// for i := 1 to tmp do
102070: LD_ADDR_VAR 0 1
102074: PUSH
102075: DOUBLE
102076: LD_INT 1
102078: DEC
102079: ST_TO_ADDR
102080: LD_VAR 0 2
102084: PUSH
102085: FOR_TO
102086: IFFALSE 102113
// if Prob ( 60 ) then
102088: LD_INT 60
102090: PPUSH
102091: CALL_OW 13
102095: IFFALSE 102111
// SetSide ( i , side ) ;
102097: LD_VAR 0 1
102101: PPUSH
102102: LD_VAR 0 3
102106: PPUSH
102107: CALL_OW 235
102111: GO 102085
102113: POP
102114: POP
// end ;
102115: PPOPN 3
102117: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
102118: LD_EXP 124
102122: PUSH
102123: LD_EXP 137
102127: AND
102128: IFFALSE 102247
102130: GO 102132
102132: DISABLE
102133: LD_INT 0
102135: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
102136: LD_ADDR_VAR 0 1
102140: PUSH
102141: LD_INT 22
102143: PUSH
102144: LD_OWVAR 2
102148: PUSH
102149: EMPTY
102150: LIST
102151: LIST
102152: PUSH
102153: LD_INT 21
102155: PUSH
102156: LD_INT 1
102158: PUSH
102159: EMPTY
102160: LIST
102161: LIST
102162: PUSH
102163: LD_INT 3
102165: PUSH
102166: LD_INT 23
102168: PUSH
102169: LD_INT 0
102171: PUSH
102172: EMPTY
102173: LIST
102174: LIST
102175: PUSH
102176: EMPTY
102177: LIST
102178: LIST
102179: PUSH
102180: EMPTY
102181: LIST
102182: LIST
102183: LIST
102184: PPUSH
102185: CALL_OW 69
102189: PUSH
102190: FOR_IN
102191: IFFALSE 102245
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
102193: LD_VAR 0 1
102197: PPUSH
102198: CALL_OW 257
102202: PUSH
102203: LD_INT 1
102205: PUSH
102206: LD_INT 2
102208: PUSH
102209: LD_INT 3
102211: PUSH
102212: LD_INT 4
102214: PUSH
102215: EMPTY
102216: LIST
102217: LIST
102218: LIST
102219: LIST
102220: IN
102221: IFFALSE 102243
// SetClass ( un , rand ( 1 , 4 ) ) ;
102223: LD_VAR 0 1
102227: PPUSH
102228: LD_INT 1
102230: PPUSH
102231: LD_INT 4
102233: PPUSH
102234: CALL_OW 12
102238: PPUSH
102239: CALL_OW 336
102243: GO 102190
102245: POP
102246: POP
// end ;
102247: PPOPN 1
102249: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
102250: LD_EXP 124
102254: PUSH
102255: LD_EXP 136
102259: AND
102260: IFFALSE 102339
102262: GO 102264
102264: DISABLE
102265: LD_INT 0
102267: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102268: LD_ADDR_VAR 0 1
102272: PUSH
102273: LD_INT 22
102275: PUSH
102276: LD_OWVAR 2
102280: PUSH
102281: EMPTY
102282: LIST
102283: LIST
102284: PUSH
102285: LD_INT 21
102287: PUSH
102288: LD_INT 3
102290: PUSH
102291: EMPTY
102292: LIST
102293: LIST
102294: PUSH
102295: EMPTY
102296: LIST
102297: LIST
102298: PPUSH
102299: CALL_OW 69
102303: ST_TO_ADDR
// if not tmp then
102304: LD_VAR 0 1
102308: NOT
102309: IFFALSE 102313
// exit ;
102311: GO 102339
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
102313: LD_VAR 0 1
102317: PUSH
102318: LD_INT 1
102320: PPUSH
102321: LD_VAR 0 1
102325: PPUSH
102326: CALL_OW 12
102330: ARRAY
102331: PPUSH
102332: LD_INT 100
102334: PPUSH
102335: CALL_OW 234
// end ;
102339: PPOPN 1
102341: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
102342: LD_EXP 124
102346: PUSH
102347: LD_EXP 138
102351: AND
102352: IFFALSE 102450
102354: GO 102356
102356: DISABLE
102357: LD_INT 0
102359: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102360: LD_ADDR_VAR 0 1
102364: PUSH
102365: LD_INT 22
102367: PUSH
102368: LD_OWVAR 2
102372: PUSH
102373: EMPTY
102374: LIST
102375: LIST
102376: PUSH
102377: LD_INT 21
102379: PUSH
102380: LD_INT 1
102382: PUSH
102383: EMPTY
102384: LIST
102385: LIST
102386: PUSH
102387: EMPTY
102388: LIST
102389: LIST
102390: PPUSH
102391: CALL_OW 69
102395: ST_TO_ADDR
// if not tmp then
102396: LD_VAR 0 1
102400: NOT
102401: IFFALSE 102405
// exit ;
102403: GO 102450
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
102405: LD_VAR 0 1
102409: PUSH
102410: LD_INT 1
102412: PPUSH
102413: LD_VAR 0 1
102417: PPUSH
102418: CALL_OW 12
102422: ARRAY
102423: PPUSH
102424: LD_INT 1
102426: PPUSH
102427: LD_INT 4
102429: PPUSH
102430: CALL_OW 12
102434: PPUSH
102435: LD_INT 3000
102437: PPUSH
102438: LD_INT 9000
102440: PPUSH
102441: CALL_OW 12
102445: PPUSH
102446: CALL_OW 492
// end ;
102450: PPOPN 1
102452: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102453: LD_EXP 124
102457: PUSH
102458: LD_EXP 139
102462: AND
102463: IFFALSE 102483
102465: GO 102467
102467: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102468: LD_INT 1
102470: PPUSH
102471: LD_OWVAR 2
102475: PPUSH
102476: LD_INT 0
102478: PPUSH
102479: CALL_OW 324
102483: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102484: LD_EXP 124
102488: PUSH
102489: LD_EXP 140
102493: AND
102494: IFFALSE 102577
102496: GO 102498
102498: DISABLE
102499: LD_INT 0
102501: PPUSH
102502: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102503: LD_ADDR_VAR 0 2
102507: PUSH
102508: LD_INT 22
102510: PUSH
102511: LD_OWVAR 2
102515: PUSH
102516: EMPTY
102517: LIST
102518: LIST
102519: PUSH
102520: LD_INT 21
102522: PUSH
102523: LD_INT 3
102525: PUSH
102526: EMPTY
102527: LIST
102528: LIST
102529: PUSH
102530: EMPTY
102531: LIST
102532: LIST
102533: PPUSH
102534: CALL_OW 69
102538: ST_TO_ADDR
// if not tmp then
102539: LD_VAR 0 2
102543: NOT
102544: IFFALSE 102548
// exit ;
102546: GO 102577
// for i in tmp do
102548: LD_ADDR_VAR 0 1
102552: PUSH
102553: LD_VAR 0 2
102557: PUSH
102558: FOR_IN
102559: IFFALSE 102575
// SetBLevel ( i , 10 ) ;
102561: LD_VAR 0 1
102565: PPUSH
102566: LD_INT 10
102568: PPUSH
102569: CALL_OW 241
102573: GO 102558
102575: POP
102576: POP
// end ;
102577: PPOPN 2
102579: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102580: LD_EXP 124
102584: PUSH
102585: LD_EXP 141
102589: AND
102590: IFFALSE 102701
102592: GO 102594
102594: DISABLE
102595: LD_INT 0
102597: PPUSH
102598: PPUSH
102599: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102600: LD_ADDR_VAR 0 3
102604: PUSH
102605: LD_INT 22
102607: PUSH
102608: LD_OWVAR 2
102612: PUSH
102613: EMPTY
102614: LIST
102615: LIST
102616: PUSH
102617: LD_INT 25
102619: PUSH
102620: LD_INT 1
102622: PUSH
102623: EMPTY
102624: LIST
102625: LIST
102626: PUSH
102627: EMPTY
102628: LIST
102629: LIST
102630: PPUSH
102631: CALL_OW 69
102635: ST_TO_ADDR
// if not tmp then
102636: LD_VAR 0 3
102640: NOT
102641: IFFALSE 102645
// exit ;
102643: GO 102701
// un := tmp [ rand ( 1 , tmp ) ] ;
102645: LD_ADDR_VAR 0 2
102649: PUSH
102650: LD_VAR 0 3
102654: PUSH
102655: LD_INT 1
102657: PPUSH
102658: LD_VAR 0 3
102662: PPUSH
102663: CALL_OW 12
102667: ARRAY
102668: ST_TO_ADDR
// if Crawls ( un ) then
102669: LD_VAR 0 2
102673: PPUSH
102674: CALL_OW 318
102678: IFFALSE 102689
// ComWalk ( un ) ;
102680: LD_VAR 0 2
102684: PPUSH
102685: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102689: LD_VAR 0 2
102693: PPUSH
102694: LD_INT 5
102696: PPUSH
102697: CALL_OW 336
// end ;
102701: PPOPN 3
102703: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102704: LD_EXP 124
102708: PUSH
102709: LD_EXP 142
102713: AND
102714: PUSH
102715: LD_OWVAR 67
102719: PUSH
102720: LD_INT 4
102722: LESS
102723: AND
102724: IFFALSE 102743
102726: GO 102728
102728: DISABLE
// begin Difficulty := Difficulty + 1 ;
102729: LD_ADDR_OWVAR 67
102733: PUSH
102734: LD_OWVAR 67
102738: PUSH
102739: LD_INT 1
102741: PLUS
102742: ST_TO_ADDR
// end ;
102743: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102744: LD_EXP 124
102748: PUSH
102749: LD_EXP 143
102753: AND
102754: IFFALSE 102857
102756: GO 102758
102758: DISABLE
102759: LD_INT 0
102761: PPUSH
// begin for i := 1 to 5 do
102762: LD_ADDR_VAR 0 1
102766: PUSH
102767: DOUBLE
102768: LD_INT 1
102770: DEC
102771: ST_TO_ADDR
102772: LD_INT 5
102774: PUSH
102775: FOR_TO
102776: IFFALSE 102855
// begin uc_nation := nation_nature ;
102778: LD_ADDR_OWVAR 21
102782: PUSH
102783: LD_INT 0
102785: ST_TO_ADDR
// uc_side := 0 ;
102786: LD_ADDR_OWVAR 20
102790: PUSH
102791: LD_INT 0
102793: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102794: LD_ADDR_OWVAR 29
102798: PUSH
102799: LD_INT 12
102801: PUSH
102802: LD_INT 12
102804: PUSH
102805: EMPTY
102806: LIST
102807: LIST
102808: ST_TO_ADDR
// hc_agressivity := 20 ;
102809: LD_ADDR_OWVAR 35
102813: PUSH
102814: LD_INT 20
102816: ST_TO_ADDR
// hc_class := class_tiger ;
102817: LD_ADDR_OWVAR 28
102821: PUSH
102822: LD_INT 14
102824: ST_TO_ADDR
// hc_gallery :=  ;
102825: LD_ADDR_OWVAR 33
102829: PUSH
102830: LD_STRING 
102832: ST_TO_ADDR
// hc_name :=  ;
102833: LD_ADDR_OWVAR 26
102837: PUSH
102838: LD_STRING 
102840: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102841: CALL_OW 44
102845: PPUSH
102846: LD_INT 0
102848: PPUSH
102849: CALL_OW 51
// end ;
102853: GO 102775
102855: POP
102856: POP
// end ;
102857: PPOPN 1
102859: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102860: LD_EXP 124
102864: PUSH
102865: LD_EXP 144
102869: AND
102870: IFFALSE 102879
102872: GO 102874
102874: DISABLE
// StreamSibBomb ;
102875: CALL 102880 0 0
102879: END
// export function StreamSibBomb ; var i , x , y ; begin
102880: LD_INT 0
102882: PPUSH
102883: PPUSH
102884: PPUSH
102885: PPUSH
// result := false ;
102886: LD_ADDR_VAR 0 1
102890: PUSH
102891: LD_INT 0
102893: ST_TO_ADDR
// for i := 1 to 16 do
102894: LD_ADDR_VAR 0 2
102898: PUSH
102899: DOUBLE
102900: LD_INT 1
102902: DEC
102903: ST_TO_ADDR
102904: LD_INT 16
102906: PUSH
102907: FOR_TO
102908: IFFALSE 103107
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102910: LD_ADDR_VAR 0 3
102914: PUSH
102915: LD_INT 10
102917: PUSH
102918: LD_INT 20
102920: PUSH
102921: LD_INT 30
102923: PUSH
102924: LD_INT 40
102926: PUSH
102927: LD_INT 50
102929: PUSH
102930: LD_INT 60
102932: PUSH
102933: LD_INT 70
102935: PUSH
102936: LD_INT 80
102938: PUSH
102939: LD_INT 90
102941: PUSH
102942: LD_INT 100
102944: PUSH
102945: LD_INT 110
102947: PUSH
102948: LD_INT 120
102950: PUSH
102951: LD_INT 130
102953: PUSH
102954: LD_INT 140
102956: PUSH
102957: LD_INT 150
102959: PUSH
102960: EMPTY
102961: LIST
102962: LIST
102963: LIST
102964: LIST
102965: LIST
102966: LIST
102967: LIST
102968: LIST
102969: LIST
102970: LIST
102971: LIST
102972: LIST
102973: LIST
102974: LIST
102975: LIST
102976: PUSH
102977: LD_INT 1
102979: PPUSH
102980: LD_INT 15
102982: PPUSH
102983: CALL_OW 12
102987: ARRAY
102988: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102989: LD_ADDR_VAR 0 4
102993: PUSH
102994: LD_INT 10
102996: PUSH
102997: LD_INT 20
102999: PUSH
103000: LD_INT 30
103002: PUSH
103003: LD_INT 40
103005: PUSH
103006: LD_INT 50
103008: PUSH
103009: LD_INT 60
103011: PUSH
103012: LD_INT 70
103014: PUSH
103015: LD_INT 80
103017: PUSH
103018: LD_INT 90
103020: PUSH
103021: LD_INT 100
103023: PUSH
103024: LD_INT 110
103026: PUSH
103027: LD_INT 120
103029: PUSH
103030: LD_INT 130
103032: PUSH
103033: LD_INT 140
103035: PUSH
103036: LD_INT 150
103038: PUSH
103039: EMPTY
103040: LIST
103041: LIST
103042: LIST
103043: LIST
103044: LIST
103045: LIST
103046: LIST
103047: LIST
103048: LIST
103049: LIST
103050: LIST
103051: LIST
103052: LIST
103053: LIST
103054: LIST
103055: PUSH
103056: LD_INT 1
103058: PPUSH
103059: LD_INT 15
103061: PPUSH
103062: CALL_OW 12
103066: ARRAY
103067: ST_TO_ADDR
// if ValidHex ( x , y ) then
103068: LD_VAR 0 3
103072: PPUSH
103073: LD_VAR 0 4
103077: PPUSH
103078: CALL_OW 488
103082: IFFALSE 103105
// begin result := [ x , y ] ;
103084: LD_ADDR_VAR 0 1
103088: PUSH
103089: LD_VAR 0 3
103093: PUSH
103094: LD_VAR 0 4
103098: PUSH
103099: EMPTY
103100: LIST
103101: LIST
103102: ST_TO_ADDR
// break ;
103103: GO 103107
// end ; end ;
103105: GO 102907
103107: POP
103108: POP
// if result then
103109: LD_VAR 0 1
103113: IFFALSE 103173
// begin ToLua ( playSibBomb() ) ;
103115: LD_STRING playSibBomb()
103117: PPUSH
103118: CALL_OW 559
// wait ( 0 0$14 ) ;
103122: LD_INT 490
103124: PPUSH
103125: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
103129: LD_VAR 0 1
103133: PUSH
103134: LD_INT 1
103136: ARRAY
103137: PPUSH
103138: LD_VAR 0 1
103142: PUSH
103143: LD_INT 2
103145: ARRAY
103146: PPUSH
103147: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
103151: LD_VAR 0 1
103155: PUSH
103156: LD_INT 1
103158: ARRAY
103159: PPUSH
103160: LD_VAR 0 1
103164: PUSH
103165: LD_INT 2
103167: ARRAY
103168: PPUSH
103169: CALL_OW 429
// end ; end ;
103173: LD_VAR 0 1
103177: RET
// every 0 0$1 trigger StreamModeActive and sReset do
103178: LD_EXP 124
103182: PUSH
103183: LD_EXP 146
103187: AND
103188: IFFALSE 103200
103190: GO 103192
103192: DISABLE
// YouLost (  ) ;
103193: LD_STRING 
103195: PPUSH
103196: CALL_OW 104
103200: END
// every 0 0$1 trigger StreamModeActive and sFog do
103201: LD_EXP 124
103205: PUSH
103206: LD_EXP 145
103210: AND
103211: IFFALSE 103225
103213: GO 103215
103215: DISABLE
// FogOff ( your_side ) ;
103216: LD_OWVAR 2
103220: PPUSH
103221: CALL_OW 344
103225: END
// every 0 0$1 trigger StreamModeActive and sSun do
103226: LD_EXP 124
103230: PUSH
103231: LD_EXP 147
103235: AND
103236: IFFALSE 103264
103238: GO 103240
103240: DISABLE
// begin solar_recharge_percent := 0 ;
103241: LD_ADDR_OWVAR 79
103245: PUSH
103246: LD_INT 0
103248: ST_TO_ADDR
// wait ( 5 5$00 ) ;
103249: LD_INT 10500
103251: PPUSH
103252: CALL_OW 67
// solar_recharge_percent := 100 ;
103256: LD_ADDR_OWVAR 79
103260: PUSH
103261: LD_INT 100
103263: ST_TO_ADDR
// end ;
103264: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
103265: LD_EXP 124
103269: PUSH
103270: LD_EXP 148
103274: AND
103275: IFFALSE 103514
103277: GO 103279
103279: DISABLE
103280: LD_INT 0
103282: PPUSH
103283: PPUSH
103284: PPUSH
// begin tmp := [ ] ;
103285: LD_ADDR_VAR 0 3
103289: PUSH
103290: EMPTY
103291: ST_TO_ADDR
// for i := 1 to 6 do
103292: LD_ADDR_VAR 0 1
103296: PUSH
103297: DOUBLE
103298: LD_INT 1
103300: DEC
103301: ST_TO_ADDR
103302: LD_INT 6
103304: PUSH
103305: FOR_TO
103306: IFFALSE 103411
// begin uc_nation := nation_nature ;
103308: LD_ADDR_OWVAR 21
103312: PUSH
103313: LD_INT 0
103315: ST_TO_ADDR
// uc_side := 0 ;
103316: LD_ADDR_OWVAR 20
103320: PUSH
103321: LD_INT 0
103323: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
103324: LD_ADDR_OWVAR 29
103328: PUSH
103329: LD_INT 12
103331: PUSH
103332: LD_INT 12
103334: PUSH
103335: EMPTY
103336: LIST
103337: LIST
103338: ST_TO_ADDR
// hc_agressivity := 20 ;
103339: LD_ADDR_OWVAR 35
103343: PUSH
103344: LD_INT 20
103346: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
103347: LD_ADDR_OWVAR 28
103351: PUSH
103352: LD_INT 17
103354: ST_TO_ADDR
// hc_gallery :=  ;
103355: LD_ADDR_OWVAR 33
103359: PUSH
103360: LD_STRING 
103362: ST_TO_ADDR
// hc_name :=  ;
103363: LD_ADDR_OWVAR 26
103367: PUSH
103368: LD_STRING 
103370: ST_TO_ADDR
// un := CreateHuman ;
103371: LD_ADDR_VAR 0 2
103375: PUSH
103376: CALL_OW 44
103380: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
103381: LD_VAR 0 2
103385: PPUSH
103386: LD_INT 1
103388: PPUSH
103389: CALL_OW 51
// tmp := tmp ^ un ;
103393: LD_ADDR_VAR 0 3
103397: PUSH
103398: LD_VAR 0 3
103402: PUSH
103403: LD_VAR 0 2
103407: ADD
103408: ST_TO_ADDR
// end ;
103409: GO 103305
103411: POP
103412: POP
// repeat wait ( 0 0$1 ) ;
103413: LD_INT 35
103415: PPUSH
103416: CALL_OW 67
// for un in tmp do
103420: LD_ADDR_VAR 0 2
103424: PUSH
103425: LD_VAR 0 3
103429: PUSH
103430: FOR_IN
103431: IFFALSE 103505
// begin if IsDead ( un ) then
103433: LD_VAR 0 2
103437: PPUSH
103438: CALL_OW 301
103442: IFFALSE 103462
// begin tmp := tmp diff un ;
103444: LD_ADDR_VAR 0 3
103448: PUSH
103449: LD_VAR 0 3
103453: PUSH
103454: LD_VAR 0 2
103458: DIFF
103459: ST_TO_ADDR
// continue ;
103460: GO 103430
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103462: LD_VAR 0 2
103466: PPUSH
103467: LD_INT 3
103469: PUSH
103470: LD_INT 22
103472: PUSH
103473: LD_INT 0
103475: PUSH
103476: EMPTY
103477: LIST
103478: LIST
103479: PUSH
103480: EMPTY
103481: LIST
103482: LIST
103483: PPUSH
103484: CALL_OW 69
103488: PPUSH
103489: LD_VAR 0 2
103493: PPUSH
103494: CALL_OW 74
103498: PPUSH
103499: CALL_OW 115
// end ;
103503: GO 103430
103505: POP
103506: POP
// until not tmp ;
103507: LD_VAR 0 3
103511: NOT
103512: IFFALSE 103413
// end ;
103514: PPOPN 3
103516: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103517: LD_EXP 124
103521: PUSH
103522: LD_EXP 149
103526: AND
103527: IFFALSE 103581
103529: GO 103531
103531: DISABLE
// begin ToLua ( displayTroll(); ) ;
103532: LD_STRING displayTroll();
103534: PPUSH
103535: CALL_OW 559
// wait ( 3 3$00 ) ;
103539: LD_INT 6300
103541: PPUSH
103542: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103546: LD_STRING hideTroll();
103548: PPUSH
103549: CALL_OW 559
// wait ( 1 1$00 ) ;
103553: LD_INT 2100
103555: PPUSH
103556: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103560: LD_STRING displayTroll();
103562: PPUSH
103563: CALL_OW 559
// wait ( 1 1$00 ) ;
103567: LD_INT 2100
103569: PPUSH
103570: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103574: LD_STRING hideTroll();
103576: PPUSH
103577: CALL_OW 559
// end ;
103581: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103582: LD_EXP 124
103586: PUSH
103587: LD_EXP 150
103591: AND
103592: IFFALSE 103655
103594: GO 103596
103596: DISABLE
103597: LD_INT 0
103599: PPUSH
// begin p := 0 ;
103600: LD_ADDR_VAR 0 1
103604: PUSH
103605: LD_INT 0
103607: ST_TO_ADDR
// repeat game_speed := 1 ;
103608: LD_ADDR_OWVAR 65
103612: PUSH
103613: LD_INT 1
103615: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103616: LD_INT 35
103618: PPUSH
103619: CALL_OW 67
// p := p + 1 ;
103623: LD_ADDR_VAR 0 1
103627: PUSH
103628: LD_VAR 0 1
103632: PUSH
103633: LD_INT 1
103635: PLUS
103636: ST_TO_ADDR
// until p >= 60 ;
103637: LD_VAR 0 1
103641: PUSH
103642: LD_INT 60
103644: GREATEREQUAL
103645: IFFALSE 103608
// game_speed := 4 ;
103647: LD_ADDR_OWVAR 65
103651: PUSH
103652: LD_INT 4
103654: ST_TO_ADDR
// end ;
103655: PPOPN 1
103657: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103658: LD_EXP 124
103662: PUSH
103663: LD_EXP 151
103667: AND
103668: IFFALSE 103814
103670: GO 103672
103672: DISABLE
103673: LD_INT 0
103675: PPUSH
103676: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103677: LD_ADDR_VAR 0 1
103681: PUSH
103682: LD_INT 22
103684: PUSH
103685: LD_OWVAR 2
103689: PUSH
103690: EMPTY
103691: LIST
103692: LIST
103693: PUSH
103694: LD_INT 2
103696: PUSH
103697: LD_INT 30
103699: PUSH
103700: LD_INT 0
103702: PUSH
103703: EMPTY
103704: LIST
103705: LIST
103706: PUSH
103707: LD_INT 30
103709: PUSH
103710: LD_INT 1
103712: PUSH
103713: EMPTY
103714: LIST
103715: LIST
103716: PUSH
103717: EMPTY
103718: LIST
103719: LIST
103720: LIST
103721: PUSH
103722: EMPTY
103723: LIST
103724: LIST
103725: PPUSH
103726: CALL_OW 69
103730: ST_TO_ADDR
// if not depot then
103731: LD_VAR 0 1
103735: NOT
103736: IFFALSE 103740
// exit ;
103738: GO 103814
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103740: LD_ADDR_VAR 0 2
103744: PUSH
103745: LD_VAR 0 1
103749: PUSH
103750: LD_INT 1
103752: PPUSH
103753: LD_VAR 0 1
103757: PPUSH
103758: CALL_OW 12
103762: ARRAY
103763: PPUSH
103764: CALL_OW 274
103768: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103769: LD_VAR 0 2
103773: PPUSH
103774: LD_INT 1
103776: PPUSH
103777: LD_INT 0
103779: PPUSH
103780: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103784: LD_VAR 0 2
103788: PPUSH
103789: LD_INT 2
103791: PPUSH
103792: LD_INT 0
103794: PPUSH
103795: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103799: LD_VAR 0 2
103803: PPUSH
103804: LD_INT 3
103806: PPUSH
103807: LD_INT 0
103809: PPUSH
103810: CALL_OW 277
// end ;
103814: PPOPN 2
103816: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103817: LD_EXP 124
103821: PUSH
103822: LD_EXP 152
103826: AND
103827: IFFALSE 103924
103829: GO 103831
103831: DISABLE
103832: LD_INT 0
103834: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103835: LD_ADDR_VAR 0 1
103839: PUSH
103840: LD_INT 22
103842: PUSH
103843: LD_OWVAR 2
103847: PUSH
103848: EMPTY
103849: LIST
103850: LIST
103851: PUSH
103852: LD_INT 21
103854: PUSH
103855: LD_INT 1
103857: PUSH
103858: EMPTY
103859: LIST
103860: LIST
103861: PUSH
103862: LD_INT 3
103864: PUSH
103865: LD_INT 23
103867: PUSH
103868: LD_INT 0
103870: PUSH
103871: EMPTY
103872: LIST
103873: LIST
103874: PUSH
103875: EMPTY
103876: LIST
103877: LIST
103878: PUSH
103879: EMPTY
103880: LIST
103881: LIST
103882: LIST
103883: PPUSH
103884: CALL_OW 69
103888: ST_TO_ADDR
// if not tmp then
103889: LD_VAR 0 1
103893: NOT
103894: IFFALSE 103898
// exit ;
103896: GO 103924
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103898: LD_VAR 0 1
103902: PUSH
103903: LD_INT 1
103905: PPUSH
103906: LD_VAR 0 1
103910: PPUSH
103911: CALL_OW 12
103915: ARRAY
103916: PPUSH
103917: LD_INT 200
103919: PPUSH
103920: CALL_OW 234
// end ;
103924: PPOPN 1
103926: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103927: LD_EXP 124
103931: PUSH
103932: LD_EXP 153
103936: AND
103937: IFFALSE 104016
103939: GO 103941
103941: DISABLE
103942: LD_INT 0
103944: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103945: LD_ADDR_VAR 0 1
103949: PUSH
103950: LD_INT 22
103952: PUSH
103953: LD_OWVAR 2
103957: PUSH
103958: EMPTY
103959: LIST
103960: LIST
103961: PUSH
103962: LD_INT 21
103964: PUSH
103965: LD_INT 2
103967: PUSH
103968: EMPTY
103969: LIST
103970: LIST
103971: PUSH
103972: EMPTY
103973: LIST
103974: LIST
103975: PPUSH
103976: CALL_OW 69
103980: ST_TO_ADDR
// if not tmp then
103981: LD_VAR 0 1
103985: NOT
103986: IFFALSE 103990
// exit ;
103988: GO 104016
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103990: LD_VAR 0 1
103994: PUSH
103995: LD_INT 1
103997: PPUSH
103998: LD_VAR 0 1
104002: PPUSH
104003: CALL_OW 12
104007: ARRAY
104008: PPUSH
104009: LD_INT 60
104011: PPUSH
104012: CALL_OW 234
// end ;
104016: PPOPN 1
104018: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
104019: LD_EXP 124
104023: PUSH
104024: LD_EXP 154
104028: AND
104029: IFFALSE 104128
104031: GO 104033
104033: DISABLE
104034: LD_INT 0
104036: PPUSH
104037: PPUSH
// begin enable ;
104038: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
104039: LD_ADDR_VAR 0 1
104043: PUSH
104044: LD_INT 22
104046: PUSH
104047: LD_OWVAR 2
104051: PUSH
104052: EMPTY
104053: LIST
104054: LIST
104055: PUSH
104056: LD_INT 61
104058: PUSH
104059: EMPTY
104060: LIST
104061: PUSH
104062: LD_INT 33
104064: PUSH
104065: LD_INT 2
104067: PUSH
104068: EMPTY
104069: LIST
104070: LIST
104071: PUSH
104072: EMPTY
104073: LIST
104074: LIST
104075: LIST
104076: PPUSH
104077: CALL_OW 69
104081: ST_TO_ADDR
// if not tmp then
104082: LD_VAR 0 1
104086: NOT
104087: IFFALSE 104091
// exit ;
104089: GO 104128
// for i in tmp do
104091: LD_ADDR_VAR 0 2
104095: PUSH
104096: LD_VAR 0 1
104100: PUSH
104101: FOR_IN
104102: IFFALSE 104126
// if IsControledBy ( i ) then
104104: LD_VAR 0 2
104108: PPUSH
104109: CALL_OW 312
104113: IFFALSE 104124
// ComUnlink ( i ) ;
104115: LD_VAR 0 2
104119: PPUSH
104120: CALL_OW 136
104124: GO 104101
104126: POP
104127: POP
// end ;
104128: PPOPN 2
104130: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
104131: LD_EXP 124
104135: PUSH
104136: LD_EXP 155
104140: AND
104141: IFFALSE 104281
104143: GO 104145
104145: DISABLE
104146: LD_INT 0
104148: PPUSH
104149: PPUSH
// begin ToLua ( displayPowell(); ) ;
104150: LD_STRING displayPowell();
104152: PPUSH
104153: CALL_OW 559
// uc_side := 0 ;
104157: LD_ADDR_OWVAR 20
104161: PUSH
104162: LD_INT 0
104164: ST_TO_ADDR
// uc_nation := 2 ;
104165: LD_ADDR_OWVAR 21
104169: PUSH
104170: LD_INT 2
104172: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
104173: LD_ADDR_OWVAR 37
104177: PUSH
104178: LD_INT 14
104180: ST_TO_ADDR
// vc_engine := engine_siberite ;
104181: LD_ADDR_OWVAR 39
104185: PUSH
104186: LD_INT 3
104188: ST_TO_ADDR
// vc_control := control_apeman ;
104189: LD_ADDR_OWVAR 38
104193: PUSH
104194: LD_INT 5
104196: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
104197: LD_ADDR_OWVAR 40
104201: PUSH
104202: LD_INT 29
104204: ST_TO_ADDR
// un := CreateVehicle ;
104205: LD_ADDR_VAR 0 2
104209: PUSH
104210: CALL_OW 45
104214: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104215: LD_VAR 0 2
104219: PPUSH
104220: LD_INT 1
104222: PPUSH
104223: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104227: LD_INT 35
104229: PPUSH
104230: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104234: LD_VAR 0 2
104238: PPUSH
104239: LD_INT 22
104241: PUSH
104242: LD_OWVAR 2
104246: PUSH
104247: EMPTY
104248: LIST
104249: LIST
104250: PPUSH
104251: CALL_OW 69
104255: PPUSH
104256: LD_VAR 0 2
104260: PPUSH
104261: CALL_OW 74
104265: PPUSH
104266: CALL_OW 115
// until IsDead ( un ) ;
104270: LD_VAR 0 2
104274: PPUSH
104275: CALL_OW 301
104279: IFFALSE 104227
// end ;
104281: PPOPN 2
104283: END
// every 0 0$1 trigger StreamModeActive and sStu do
104284: LD_EXP 124
104288: PUSH
104289: LD_EXP 163
104293: AND
104294: IFFALSE 104310
104296: GO 104298
104298: DISABLE
// begin ToLua ( displayStucuk(); ) ;
104299: LD_STRING displayStucuk();
104301: PPUSH
104302: CALL_OW 559
// ResetFog ;
104306: CALL_OW 335
// end ;
104310: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
104311: LD_EXP 124
104315: PUSH
104316: LD_EXP 156
104320: AND
104321: IFFALSE 104462
104323: GO 104325
104325: DISABLE
104326: LD_INT 0
104328: PPUSH
104329: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104330: LD_ADDR_VAR 0 2
104334: PUSH
104335: LD_INT 22
104337: PUSH
104338: LD_OWVAR 2
104342: PUSH
104343: EMPTY
104344: LIST
104345: LIST
104346: PUSH
104347: LD_INT 21
104349: PUSH
104350: LD_INT 1
104352: PUSH
104353: EMPTY
104354: LIST
104355: LIST
104356: PUSH
104357: EMPTY
104358: LIST
104359: LIST
104360: PPUSH
104361: CALL_OW 69
104365: ST_TO_ADDR
// if not tmp then
104366: LD_VAR 0 2
104370: NOT
104371: IFFALSE 104375
// exit ;
104373: GO 104462
// un := tmp [ rand ( 1 , tmp ) ] ;
104375: LD_ADDR_VAR 0 1
104379: PUSH
104380: LD_VAR 0 2
104384: PUSH
104385: LD_INT 1
104387: PPUSH
104388: LD_VAR 0 2
104392: PPUSH
104393: CALL_OW 12
104397: ARRAY
104398: ST_TO_ADDR
// SetSide ( un , 0 ) ;
104399: LD_VAR 0 1
104403: PPUSH
104404: LD_INT 0
104406: PPUSH
104407: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
104411: LD_VAR 0 1
104415: PPUSH
104416: LD_OWVAR 3
104420: PUSH
104421: LD_VAR 0 1
104425: DIFF
104426: PPUSH
104427: LD_VAR 0 1
104431: PPUSH
104432: CALL_OW 74
104436: PPUSH
104437: CALL_OW 115
// wait ( 0 0$20 ) ;
104441: LD_INT 700
104443: PPUSH
104444: CALL_OW 67
// SetSide ( un , your_side ) ;
104448: LD_VAR 0 1
104452: PPUSH
104453: LD_OWVAR 2
104457: PPUSH
104458: CALL_OW 235
// end ;
104462: PPOPN 2
104464: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104465: LD_EXP 124
104469: PUSH
104470: LD_EXP 157
104474: AND
104475: IFFALSE 104581
104477: GO 104479
104479: DISABLE
104480: LD_INT 0
104482: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104483: LD_ADDR_VAR 0 1
104487: PUSH
104488: LD_INT 22
104490: PUSH
104491: LD_OWVAR 2
104495: PUSH
104496: EMPTY
104497: LIST
104498: LIST
104499: PUSH
104500: LD_INT 2
104502: PUSH
104503: LD_INT 30
104505: PUSH
104506: LD_INT 0
104508: PUSH
104509: EMPTY
104510: LIST
104511: LIST
104512: PUSH
104513: LD_INT 30
104515: PUSH
104516: LD_INT 1
104518: PUSH
104519: EMPTY
104520: LIST
104521: LIST
104522: PUSH
104523: EMPTY
104524: LIST
104525: LIST
104526: LIST
104527: PUSH
104528: EMPTY
104529: LIST
104530: LIST
104531: PPUSH
104532: CALL_OW 69
104536: ST_TO_ADDR
// if not depot then
104537: LD_VAR 0 1
104541: NOT
104542: IFFALSE 104546
// exit ;
104544: GO 104581
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104546: LD_VAR 0 1
104550: PUSH
104551: LD_INT 1
104553: ARRAY
104554: PPUSH
104555: CALL_OW 250
104559: PPUSH
104560: LD_VAR 0 1
104564: PUSH
104565: LD_INT 1
104567: ARRAY
104568: PPUSH
104569: CALL_OW 251
104573: PPUSH
104574: LD_INT 70
104576: PPUSH
104577: CALL_OW 495
// end ;
104581: PPOPN 1
104583: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104584: LD_EXP 124
104588: PUSH
104589: LD_EXP 158
104593: AND
104594: IFFALSE 104805
104596: GO 104598
104598: DISABLE
104599: LD_INT 0
104601: PPUSH
104602: PPUSH
104603: PPUSH
104604: PPUSH
104605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104606: LD_ADDR_VAR 0 5
104610: PUSH
104611: LD_INT 22
104613: PUSH
104614: LD_OWVAR 2
104618: PUSH
104619: EMPTY
104620: LIST
104621: LIST
104622: PUSH
104623: LD_INT 21
104625: PUSH
104626: LD_INT 1
104628: PUSH
104629: EMPTY
104630: LIST
104631: LIST
104632: PUSH
104633: EMPTY
104634: LIST
104635: LIST
104636: PPUSH
104637: CALL_OW 69
104641: ST_TO_ADDR
// if not tmp then
104642: LD_VAR 0 5
104646: NOT
104647: IFFALSE 104651
// exit ;
104649: GO 104805
// for i in tmp do
104651: LD_ADDR_VAR 0 1
104655: PUSH
104656: LD_VAR 0 5
104660: PUSH
104661: FOR_IN
104662: IFFALSE 104803
// begin d := rand ( 0 , 5 ) ;
104664: LD_ADDR_VAR 0 4
104668: PUSH
104669: LD_INT 0
104671: PPUSH
104672: LD_INT 5
104674: PPUSH
104675: CALL_OW 12
104679: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104680: LD_ADDR_VAR 0 2
104684: PUSH
104685: LD_VAR 0 1
104689: PPUSH
104690: CALL_OW 250
104694: PPUSH
104695: LD_VAR 0 4
104699: PPUSH
104700: LD_INT 3
104702: PPUSH
104703: LD_INT 12
104705: PPUSH
104706: CALL_OW 12
104710: PPUSH
104711: CALL_OW 272
104715: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104716: LD_ADDR_VAR 0 3
104720: PUSH
104721: LD_VAR 0 1
104725: PPUSH
104726: CALL_OW 251
104730: PPUSH
104731: LD_VAR 0 4
104735: PPUSH
104736: LD_INT 3
104738: PPUSH
104739: LD_INT 12
104741: PPUSH
104742: CALL_OW 12
104746: PPUSH
104747: CALL_OW 273
104751: ST_TO_ADDR
// if ValidHex ( x , y ) then
104752: LD_VAR 0 2
104756: PPUSH
104757: LD_VAR 0 3
104761: PPUSH
104762: CALL_OW 488
104766: IFFALSE 104801
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104768: LD_VAR 0 1
104772: PPUSH
104773: LD_VAR 0 2
104777: PPUSH
104778: LD_VAR 0 3
104782: PPUSH
104783: LD_INT 3
104785: PPUSH
104786: LD_INT 6
104788: PPUSH
104789: CALL_OW 12
104793: PPUSH
104794: LD_INT 1
104796: PPUSH
104797: CALL_OW 483
// end ;
104801: GO 104661
104803: POP
104804: POP
// end ;
104805: PPOPN 5
104807: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104808: LD_EXP 124
104812: PUSH
104813: LD_EXP 159
104817: AND
104818: IFFALSE 104912
104820: GO 104822
104822: DISABLE
104823: LD_INT 0
104825: PPUSH
104826: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104827: LD_ADDR_VAR 0 2
104831: PUSH
104832: LD_INT 22
104834: PUSH
104835: LD_OWVAR 2
104839: PUSH
104840: EMPTY
104841: LIST
104842: LIST
104843: PUSH
104844: LD_INT 32
104846: PUSH
104847: LD_INT 1
104849: PUSH
104850: EMPTY
104851: LIST
104852: LIST
104853: PUSH
104854: LD_INT 21
104856: PUSH
104857: LD_INT 2
104859: PUSH
104860: EMPTY
104861: LIST
104862: LIST
104863: PUSH
104864: EMPTY
104865: LIST
104866: LIST
104867: LIST
104868: PPUSH
104869: CALL_OW 69
104873: ST_TO_ADDR
// if not tmp then
104874: LD_VAR 0 2
104878: NOT
104879: IFFALSE 104883
// exit ;
104881: GO 104912
// for i in tmp do
104883: LD_ADDR_VAR 0 1
104887: PUSH
104888: LD_VAR 0 2
104892: PUSH
104893: FOR_IN
104894: IFFALSE 104910
// SetFuel ( i , 0 ) ;
104896: LD_VAR 0 1
104900: PPUSH
104901: LD_INT 0
104903: PPUSH
104904: CALL_OW 240
104908: GO 104893
104910: POP
104911: POP
// end ;
104912: PPOPN 2
104914: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104915: LD_EXP 124
104919: PUSH
104920: LD_EXP 160
104924: AND
104925: IFFALSE 104991
104927: GO 104929
104929: DISABLE
104930: LD_INT 0
104932: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104933: LD_ADDR_VAR 0 1
104937: PUSH
104938: LD_INT 22
104940: PUSH
104941: LD_OWVAR 2
104945: PUSH
104946: EMPTY
104947: LIST
104948: LIST
104949: PUSH
104950: LD_INT 30
104952: PUSH
104953: LD_INT 29
104955: PUSH
104956: EMPTY
104957: LIST
104958: LIST
104959: PUSH
104960: EMPTY
104961: LIST
104962: LIST
104963: PPUSH
104964: CALL_OW 69
104968: ST_TO_ADDR
// if not tmp then
104969: LD_VAR 0 1
104973: NOT
104974: IFFALSE 104978
// exit ;
104976: GO 104991
// DestroyUnit ( tmp [ 1 ] ) ;
104978: LD_VAR 0 1
104982: PUSH
104983: LD_INT 1
104985: ARRAY
104986: PPUSH
104987: CALL_OW 65
// end ;
104991: PPOPN 1
104993: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104994: LD_EXP 124
104998: PUSH
104999: LD_EXP 162
105003: AND
105004: IFFALSE 105133
105006: GO 105008
105008: DISABLE
105009: LD_INT 0
105011: PPUSH
// begin uc_side := 0 ;
105012: LD_ADDR_OWVAR 20
105016: PUSH
105017: LD_INT 0
105019: ST_TO_ADDR
// uc_nation := nation_arabian ;
105020: LD_ADDR_OWVAR 21
105024: PUSH
105025: LD_INT 2
105027: ST_TO_ADDR
// hc_gallery :=  ;
105028: LD_ADDR_OWVAR 33
105032: PUSH
105033: LD_STRING 
105035: ST_TO_ADDR
// hc_name :=  ;
105036: LD_ADDR_OWVAR 26
105040: PUSH
105041: LD_STRING 
105043: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
105044: LD_INT 1
105046: PPUSH
105047: LD_INT 11
105049: PPUSH
105050: LD_INT 10
105052: PPUSH
105053: CALL_OW 380
// un := CreateHuman ;
105057: LD_ADDR_VAR 0 1
105061: PUSH
105062: CALL_OW 44
105066: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105067: LD_VAR 0 1
105071: PPUSH
105072: LD_INT 1
105074: PPUSH
105075: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105079: LD_INT 35
105081: PPUSH
105082: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105086: LD_VAR 0 1
105090: PPUSH
105091: LD_INT 22
105093: PUSH
105094: LD_OWVAR 2
105098: PUSH
105099: EMPTY
105100: LIST
105101: LIST
105102: PPUSH
105103: CALL_OW 69
105107: PPUSH
105108: LD_VAR 0 1
105112: PPUSH
105113: CALL_OW 74
105117: PPUSH
105118: CALL_OW 115
// until IsDead ( un ) ;
105122: LD_VAR 0 1
105126: PPUSH
105127: CALL_OW 301
105131: IFFALSE 105079
// end ;
105133: PPOPN 1
105135: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
105136: LD_EXP 124
105140: PUSH
105141: LD_EXP 164
105145: AND
105146: IFFALSE 105158
105148: GO 105150
105150: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
105151: LD_STRING earthquake(getX(game), 0, 32)
105153: PPUSH
105154: CALL_OW 559
105158: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
105159: LD_EXP 124
105163: PUSH
105164: LD_EXP 165
105168: AND
105169: IFFALSE 105260
105171: GO 105173
105173: DISABLE
105174: LD_INT 0
105176: PPUSH
// begin enable ;
105177: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
105178: LD_ADDR_VAR 0 1
105182: PUSH
105183: LD_INT 22
105185: PUSH
105186: LD_OWVAR 2
105190: PUSH
105191: EMPTY
105192: LIST
105193: LIST
105194: PUSH
105195: LD_INT 21
105197: PUSH
105198: LD_INT 2
105200: PUSH
105201: EMPTY
105202: LIST
105203: LIST
105204: PUSH
105205: LD_INT 33
105207: PUSH
105208: LD_INT 3
105210: PUSH
105211: EMPTY
105212: LIST
105213: LIST
105214: PUSH
105215: EMPTY
105216: LIST
105217: LIST
105218: LIST
105219: PPUSH
105220: CALL_OW 69
105224: ST_TO_ADDR
// if not tmp then
105225: LD_VAR 0 1
105229: NOT
105230: IFFALSE 105234
// exit ;
105232: GO 105260
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105234: LD_VAR 0 1
105238: PUSH
105239: LD_INT 1
105241: PPUSH
105242: LD_VAR 0 1
105246: PPUSH
105247: CALL_OW 12
105251: ARRAY
105252: PPUSH
105253: LD_INT 1
105255: PPUSH
105256: CALL_OW 234
// end ;
105260: PPOPN 1
105262: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
105263: LD_EXP 124
105267: PUSH
105268: LD_EXP 166
105272: AND
105273: IFFALSE 105414
105275: GO 105277
105277: DISABLE
105278: LD_INT 0
105280: PPUSH
105281: PPUSH
105282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105283: LD_ADDR_VAR 0 3
105287: PUSH
105288: LD_INT 22
105290: PUSH
105291: LD_OWVAR 2
105295: PUSH
105296: EMPTY
105297: LIST
105298: LIST
105299: PUSH
105300: LD_INT 25
105302: PUSH
105303: LD_INT 1
105305: PUSH
105306: EMPTY
105307: LIST
105308: LIST
105309: PUSH
105310: EMPTY
105311: LIST
105312: LIST
105313: PPUSH
105314: CALL_OW 69
105318: ST_TO_ADDR
// if not tmp then
105319: LD_VAR 0 3
105323: NOT
105324: IFFALSE 105328
// exit ;
105326: GO 105414
// un := tmp [ rand ( 1 , tmp ) ] ;
105328: LD_ADDR_VAR 0 2
105332: PUSH
105333: LD_VAR 0 3
105337: PUSH
105338: LD_INT 1
105340: PPUSH
105341: LD_VAR 0 3
105345: PPUSH
105346: CALL_OW 12
105350: ARRAY
105351: ST_TO_ADDR
// if Crawls ( un ) then
105352: LD_VAR 0 2
105356: PPUSH
105357: CALL_OW 318
105361: IFFALSE 105372
// ComWalk ( un ) ;
105363: LD_VAR 0 2
105367: PPUSH
105368: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
105372: LD_VAR 0 2
105376: PPUSH
105377: LD_INT 9
105379: PPUSH
105380: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
105384: LD_INT 28
105386: PPUSH
105387: LD_OWVAR 2
105391: PPUSH
105392: LD_INT 2
105394: PPUSH
105395: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
105399: LD_INT 29
105401: PPUSH
105402: LD_OWVAR 2
105406: PPUSH
105407: LD_INT 2
105409: PPUSH
105410: CALL_OW 322
// end ;
105414: PPOPN 3
105416: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
105417: LD_EXP 124
105421: PUSH
105422: LD_EXP 167
105426: AND
105427: IFFALSE 105538
105429: GO 105431
105431: DISABLE
105432: LD_INT 0
105434: PPUSH
105435: PPUSH
105436: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105437: LD_ADDR_VAR 0 3
105441: PUSH
105442: LD_INT 22
105444: PUSH
105445: LD_OWVAR 2
105449: PUSH
105450: EMPTY
105451: LIST
105452: LIST
105453: PUSH
105454: LD_INT 25
105456: PUSH
105457: LD_INT 1
105459: PUSH
105460: EMPTY
105461: LIST
105462: LIST
105463: PUSH
105464: EMPTY
105465: LIST
105466: LIST
105467: PPUSH
105468: CALL_OW 69
105472: ST_TO_ADDR
// if not tmp then
105473: LD_VAR 0 3
105477: NOT
105478: IFFALSE 105482
// exit ;
105480: GO 105538
// un := tmp [ rand ( 1 , tmp ) ] ;
105482: LD_ADDR_VAR 0 2
105486: PUSH
105487: LD_VAR 0 3
105491: PUSH
105492: LD_INT 1
105494: PPUSH
105495: LD_VAR 0 3
105499: PPUSH
105500: CALL_OW 12
105504: ARRAY
105505: ST_TO_ADDR
// if Crawls ( un ) then
105506: LD_VAR 0 2
105510: PPUSH
105511: CALL_OW 318
105515: IFFALSE 105526
// ComWalk ( un ) ;
105517: LD_VAR 0 2
105521: PPUSH
105522: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105526: LD_VAR 0 2
105530: PPUSH
105531: LD_INT 8
105533: PPUSH
105534: CALL_OW 336
// end ;
105538: PPOPN 3
105540: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105541: LD_EXP 124
105545: PUSH
105546: LD_EXP 168
105550: AND
105551: IFFALSE 105695
105553: GO 105555
105555: DISABLE
105556: LD_INT 0
105558: PPUSH
105559: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105560: LD_ADDR_VAR 0 2
105564: PUSH
105565: LD_INT 22
105567: PUSH
105568: LD_OWVAR 2
105572: PUSH
105573: EMPTY
105574: LIST
105575: LIST
105576: PUSH
105577: LD_INT 21
105579: PUSH
105580: LD_INT 2
105582: PUSH
105583: EMPTY
105584: LIST
105585: LIST
105586: PUSH
105587: LD_INT 2
105589: PUSH
105590: LD_INT 34
105592: PUSH
105593: LD_INT 12
105595: PUSH
105596: EMPTY
105597: LIST
105598: LIST
105599: PUSH
105600: LD_INT 34
105602: PUSH
105603: LD_INT 51
105605: PUSH
105606: EMPTY
105607: LIST
105608: LIST
105609: PUSH
105610: LD_INT 34
105612: PUSH
105613: LD_INT 32
105615: PUSH
105616: EMPTY
105617: LIST
105618: LIST
105619: PUSH
105620: EMPTY
105621: LIST
105622: LIST
105623: LIST
105624: LIST
105625: PUSH
105626: EMPTY
105627: LIST
105628: LIST
105629: LIST
105630: PPUSH
105631: CALL_OW 69
105635: ST_TO_ADDR
// if not tmp then
105636: LD_VAR 0 2
105640: NOT
105641: IFFALSE 105645
// exit ;
105643: GO 105695
// for i in tmp do
105645: LD_ADDR_VAR 0 1
105649: PUSH
105650: LD_VAR 0 2
105654: PUSH
105655: FOR_IN
105656: IFFALSE 105693
// if GetCargo ( i , mat_artifact ) = 0 then
105658: LD_VAR 0 1
105662: PPUSH
105663: LD_INT 4
105665: PPUSH
105666: CALL_OW 289
105670: PUSH
105671: LD_INT 0
105673: EQUAL
105674: IFFALSE 105691
// SetCargo ( i , mat_siberit , 100 ) ;
105676: LD_VAR 0 1
105680: PPUSH
105681: LD_INT 3
105683: PPUSH
105684: LD_INT 100
105686: PPUSH
105687: CALL_OW 290
105691: GO 105655
105693: POP
105694: POP
// end ;
105695: PPOPN 2
105697: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105698: LD_EXP 124
105702: PUSH
105703: LD_EXP 169
105707: AND
105708: IFFALSE 105891
105710: GO 105712
105712: DISABLE
105713: LD_INT 0
105715: PPUSH
105716: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105717: LD_ADDR_VAR 0 2
105721: PUSH
105722: LD_INT 22
105724: PUSH
105725: LD_OWVAR 2
105729: PUSH
105730: EMPTY
105731: LIST
105732: LIST
105733: PPUSH
105734: CALL_OW 69
105738: ST_TO_ADDR
// if not tmp then
105739: LD_VAR 0 2
105743: NOT
105744: IFFALSE 105748
// exit ;
105746: GO 105891
// for i := 1 to 2 do
105748: LD_ADDR_VAR 0 1
105752: PUSH
105753: DOUBLE
105754: LD_INT 1
105756: DEC
105757: ST_TO_ADDR
105758: LD_INT 2
105760: PUSH
105761: FOR_TO
105762: IFFALSE 105889
// begin uc_side := your_side ;
105764: LD_ADDR_OWVAR 20
105768: PUSH
105769: LD_OWVAR 2
105773: ST_TO_ADDR
// uc_nation := nation_american ;
105774: LD_ADDR_OWVAR 21
105778: PUSH
105779: LD_INT 1
105781: ST_TO_ADDR
// vc_chassis := us_morphling ;
105782: LD_ADDR_OWVAR 37
105786: PUSH
105787: LD_INT 5
105789: ST_TO_ADDR
// vc_engine := engine_siberite ;
105790: LD_ADDR_OWVAR 39
105794: PUSH
105795: LD_INT 3
105797: ST_TO_ADDR
// vc_control := control_computer ;
105798: LD_ADDR_OWVAR 38
105802: PUSH
105803: LD_INT 3
105805: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105806: LD_ADDR_OWVAR 40
105810: PUSH
105811: LD_INT 10
105813: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105814: LD_VAR 0 2
105818: PUSH
105819: LD_INT 1
105821: ARRAY
105822: PPUSH
105823: CALL_OW 310
105827: NOT
105828: IFFALSE 105875
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105830: CALL_OW 45
105834: PPUSH
105835: LD_VAR 0 2
105839: PUSH
105840: LD_INT 1
105842: ARRAY
105843: PPUSH
105844: CALL_OW 250
105848: PPUSH
105849: LD_VAR 0 2
105853: PUSH
105854: LD_INT 1
105856: ARRAY
105857: PPUSH
105858: CALL_OW 251
105862: PPUSH
105863: LD_INT 12
105865: PPUSH
105866: LD_INT 1
105868: PPUSH
105869: CALL_OW 50
105873: GO 105887
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105875: CALL_OW 45
105879: PPUSH
105880: LD_INT 1
105882: PPUSH
105883: CALL_OW 51
// end ;
105887: GO 105761
105889: POP
105890: POP
// end ;
105891: PPOPN 2
105893: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105894: LD_EXP 124
105898: PUSH
105899: LD_EXP 170
105903: AND
105904: IFFALSE 106126
105906: GO 105908
105908: DISABLE
105909: LD_INT 0
105911: PPUSH
105912: PPUSH
105913: PPUSH
105914: PPUSH
105915: PPUSH
105916: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105917: LD_ADDR_VAR 0 6
105921: PUSH
105922: LD_INT 22
105924: PUSH
105925: LD_OWVAR 2
105929: PUSH
105930: EMPTY
105931: LIST
105932: LIST
105933: PUSH
105934: LD_INT 21
105936: PUSH
105937: LD_INT 1
105939: PUSH
105940: EMPTY
105941: LIST
105942: LIST
105943: PUSH
105944: LD_INT 3
105946: PUSH
105947: LD_INT 23
105949: PUSH
105950: LD_INT 0
105952: PUSH
105953: EMPTY
105954: LIST
105955: LIST
105956: PUSH
105957: EMPTY
105958: LIST
105959: LIST
105960: PUSH
105961: EMPTY
105962: LIST
105963: LIST
105964: LIST
105965: PPUSH
105966: CALL_OW 69
105970: ST_TO_ADDR
// if not tmp then
105971: LD_VAR 0 6
105975: NOT
105976: IFFALSE 105980
// exit ;
105978: GO 106126
// s1 := rand ( 1 , 4 ) ;
105980: LD_ADDR_VAR 0 2
105984: PUSH
105985: LD_INT 1
105987: PPUSH
105988: LD_INT 4
105990: PPUSH
105991: CALL_OW 12
105995: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105996: LD_ADDR_VAR 0 4
106000: PUSH
106001: LD_VAR 0 6
106005: PUSH
106006: LD_INT 1
106008: ARRAY
106009: PPUSH
106010: LD_VAR 0 2
106014: PPUSH
106015: CALL_OW 259
106019: ST_TO_ADDR
// if s1 = 1 then
106020: LD_VAR 0 2
106024: PUSH
106025: LD_INT 1
106027: EQUAL
106028: IFFALSE 106048
// s2 := rand ( 2 , 4 ) else
106030: LD_ADDR_VAR 0 3
106034: PUSH
106035: LD_INT 2
106037: PPUSH
106038: LD_INT 4
106040: PPUSH
106041: CALL_OW 12
106045: ST_TO_ADDR
106046: GO 106056
// s2 := 1 ;
106048: LD_ADDR_VAR 0 3
106052: PUSH
106053: LD_INT 1
106055: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
106056: LD_ADDR_VAR 0 5
106060: PUSH
106061: LD_VAR 0 6
106065: PUSH
106066: LD_INT 1
106068: ARRAY
106069: PPUSH
106070: LD_VAR 0 3
106074: PPUSH
106075: CALL_OW 259
106079: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
106080: LD_VAR 0 6
106084: PUSH
106085: LD_INT 1
106087: ARRAY
106088: PPUSH
106089: LD_VAR 0 2
106093: PPUSH
106094: LD_VAR 0 5
106098: PPUSH
106099: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
106103: LD_VAR 0 6
106107: PUSH
106108: LD_INT 1
106110: ARRAY
106111: PPUSH
106112: LD_VAR 0 3
106116: PPUSH
106117: LD_VAR 0 4
106121: PPUSH
106122: CALL_OW 237
// end ;
106126: PPOPN 6
106128: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
106129: LD_EXP 124
106133: PUSH
106134: LD_EXP 171
106138: AND
106139: IFFALSE 106218
106141: GO 106143
106143: DISABLE
106144: LD_INT 0
106146: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
106147: LD_ADDR_VAR 0 1
106151: PUSH
106152: LD_INT 22
106154: PUSH
106155: LD_OWVAR 2
106159: PUSH
106160: EMPTY
106161: LIST
106162: LIST
106163: PUSH
106164: LD_INT 30
106166: PUSH
106167: LD_INT 3
106169: PUSH
106170: EMPTY
106171: LIST
106172: LIST
106173: PUSH
106174: EMPTY
106175: LIST
106176: LIST
106177: PPUSH
106178: CALL_OW 69
106182: ST_TO_ADDR
// if not tmp then
106183: LD_VAR 0 1
106187: NOT
106188: IFFALSE 106192
// exit ;
106190: GO 106218
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
106192: LD_VAR 0 1
106196: PUSH
106197: LD_INT 1
106199: PPUSH
106200: LD_VAR 0 1
106204: PPUSH
106205: CALL_OW 12
106209: ARRAY
106210: PPUSH
106211: LD_INT 1
106213: PPUSH
106214: CALL_OW 234
// end ;
106218: PPOPN 1
106220: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
106221: LD_EXP 124
106225: PUSH
106226: LD_EXP 172
106230: AND
106231: IFFALSE 106343
106233: GO 106235
106235: DISABLE
106236: LD_INT 0
106238: PPUSH
106239: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
106240: LD_ADDR_VAR 0 2
106244: PUSH
106245: LD_INT 22
106247: PUSH
106248: LD_OWVAR 2
106252: PUSH
106253: EMPTY
106254: LIST
106255: LIST
106256: PUSH
106257: LD_INT 2
106259: PUSH
106260: LD_INT 30
106262: PUSH
106263: LD_INT 27
106265: PUSH
106266: EMPTY
106267: LIST
106268: LIST
106269: PUSH
106270: LD_INT 30
106272: PUSH
106273: LD_INT 26
106275: PUSH
106276: EMPTY
106277: LIST
106278: LIST
106279: PUSH
106280: LD_INT 30
106282: PUSH
106283: LD_INT 28
106285: PUSH
106286: EMPTY
106287: LIST
106288: LIST
106289: PUSH
106290: EMPTY
106291: LIST
106292: LIST
106293: LIST
106294: LIST
106295: PUSH
106296: EMPTY
106297: LIST
106298: LIST
106299: PPUSH
106300: CALL_OW 69
106304: ST_TO_ADDR
// if not tmp then
106305: LD_VAR 0 2
106309: NOT
106310: IFFALSE 106314
// exit ;
106312: GO 106343
// for i in tmp do
106314: LD_ADDR_VAR 0 1
106318: PUSH
106319: LD_VAR 0 2
106323: PUSH
106324: FOR_IN
106325: IFFALSE 106341
// SetLives ( i , 1 ) ;
106327: LD_VAR 0 1
106331: PPUSH
106332: LD_INT 1
106334: PPUSH
106335: CALL_OW 234
106339: GO 106324
106341: POP
106342: POP
// end ;
106343: PPOPN 2
106345: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
106346: LD_EXP 124
106350: PUSH
106351: LD_EXP 173
106355: AND
106356: IFFALSE 106643
106358: GO 106360
106360: DISABLE
106361: LD_INT 0
106363: PPUSH
106364: PPUSH
106365: PPUSH
// begin i := rand ( 1 , 7 ) ;
106366: LD_ADDR_VAR 0 1
106370: PUSH
106371: LD_INT 1
106373: PPUSH
106374: LD_INT 7
106376: PPUSH
106377: CALL_OW 12
106381: ST_TO_ADDR
// case i of 1 :
106382: LD_VAR 0 1
106386: PUSH
106387: LD_INT 1
106389: DOUBLE
106390: EQUAL
106391: IFTRUE 106395
106393: GO 106405
106395: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
106396: LD_STRING earthquake(getX(game), 0, 32)
106398: PPUSH
106399: CALL_OW 559
106403: GO 106643
106405: LD_INT 2
106407: DOUBLE
106408: EQUAL
106409: IFTRUE 106413
106411: GO 106427
106413: POP
// begin ToLua ( displayStucuk(); ) ;
106414: LD_STRING displayStucuk();
106416: PPUSH
106417: CALL_OW 559
// ResetFog ;
106421: CALL_OW 335
// end ; 3 :
106425: GO 106643
106427: LD_INT 3
106429: DOUBLE
106430: EQUAL
106431: IFTRUE 106435
106433: GO 106539
106435: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106436: LD_ADDR_VAR 0 2
106440: PUSH
106441: LD_INT 22
106443: PUSH
106444: LD_OWVAR 2
106448: PUSH
106449: EMPTY
106450: LIST
106451: LIST
106452: PUSH
106453: LD_INT 25
106455: PUSH
106456: LD_INT 1
106458: PUSH
106459: EMPTY
106460: LIST
106461: LIST
106462: PUSH
106463: EMPTY
106464: LIST
106465: LIST
106466: PPUSH
106467: CALL_OW 69
106471: ST_TO_ADDR
// if not tmp then
106472: LD_VAR 0 2
106476: NOT
106477: IFFALSE 106481
// exit ;
106479: GO 106643
// un := tmp [ rand ( 1 , tmp ) ] ;
106481: LD_ADDR_VAR 0 3
106485: PUSH
106486: LD_VAR 0 2
106490: PUSH
106491: LD_INT 1
106493: PPUSH
106494: LD_VAR 0 2
106498: PPUSH
106499: CALL_OW 12
106503: ARRAY
106504: ST_TO_ADDR
// if Crawls ( un ) then
106505: LD_VAR 0 3
106509: PPUSH
106510: CALL_OW 318
106514: IFFALSE 106525
// ComWalk ( un ) ;
106516: LD_VAR 0 3
106520: PPUSH
106521: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106525: LD_VAR 0 3
106529: PPUSH
106530: LD_INT 8
106532: PPUSH
106533: CALL_OW 336
// end ; 4 :
106537: GO 106643
106539: LD_INT 4
106541: DOUBLE
106542: EQUAL
106543: IFTRUE 106547
106545: GO 106621
106547: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106548: LD_ADDR_VAR 0 2
106552: PUSH
106553: LD_INT 22
106555: PUSH
106556: LD_OWVAR 2
106560: PUSH
106561: EMPTY
106562: LIST
106563: LIST
106564: PUSH
106565: LD_INT 30
106567: PUSH
106568: LD_INT 29
106570: PUSH
106571: EMPTY
106572: LIST
106573: LIST
106574: PUSH
106575: EMPTY
106576: LIST
106577: LIST
106578: PPUSH
106579: CALL_OW 69
106583: ST_TO_ADDR
// if not tmp then
106584: LD_VAR 0 2
106588: NOT
106589: IFFALSE 106593
// exit ;
106591: GO 106643
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106593: LD_VAR 0 2
106597: PUSH
106598: LD_INT 1
106600: ARRAY
106601: PPUSH
106602: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106606: LD_VAR 0 2
106610: PUSH
106611: LD_INT 1
106613: ARRAY
106614: PPUSH
106615: CALL_OW 65
// end ; 5 .. 7 :
106619: GO 106643
106621: LD_INT 5
106623: DOUBLE
106624: GREATEREQUAL
106625: IFFALSE 106633
106627: LD_INT 7
106629: DOUBLE
106630: LESSEQUAL
106631: IFTRUE 106635
106633: GO 106642
106635: POP
// StreamSibBomb ; end ;
106636: CALL 102880 0 0
106640: GO 106643
106642: POP
// end ;
106643: PPOPN 3
106645: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106646: LD_EXP 124
106650: PUSH
106651: LD_EXP 174
106655: AND
106656: IFFALSE 106812
106658: GO 106660
106660: DISABLE
106661: LD_INT 0
106663: PPUSH
106664: PPUSH
106665: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106666: LD_ADDR_VAR 0 2
106670: PUSH
106671: LD_INT 81
106673: PUSH
106674: LD_OWVAR 2
106678: PUSH
106679: EMPTY
106680: LIST
106681: LIST
106682: PUSH
106683: LD_INT 2
106685: PUSH
106686: LD_INT 21
106688: PUSH
106689: LD_INT 1
106691: PUSH
106692: EMPTY
106693: LIST
106694: LIST
106695: PUSH
106696: LD_INT 21
106698: PUSH
106699: LD_INT 2
106701: PUSH
106702: EMPTY
106703: LIST
106704: LIST
106705: PUSH
106706: EMPTY
106707: LIST
106708: LIST
106709: LIST
106710: PUSH
106711: EMPTY
106712: LIST
106713: LIST
106714: PPUSH
106715: CALL_OW 69
106719: ST_TO_ADDR
// if not tmp then
106720: LD_VAR 0 2
106724: NOT
106725: IFFALSE 106729
// exit ;
106727: GO 106812
// p := 0 ;
106729: LD_ADDR_VAR 0 3
106733: PUSH
106734: LD_INT 0
106736: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106737: LD_INT 35
106739: PPUSH
106740: CALL_OW 67
// p := p + 1 ;
106744: LD_ADDR_VAR 0 3
106748: PUSH
106749: LD_VAR 0 3
106753: PUSH
106754: LD_INT 1
106756: PLUS
106757: ST_TO_ADDR
// for i in tmp do
106758: LD_ADDR_VAR 0 1
106762: PUSH
106763: LD_VAR 0 2
106767: PUSH
106768: FOR_IN
106769: IFFALSE 106800
// if GetLives ( i ) < 1000 then
106771: LD_VAR 0 1
106775: PPUSH
106776: CALL_OW 256
106780: PUSH
106781: LD_INT 1000
106783: LESS
106784: IFFALSE 106798
// SetLives ( i , 1000 ) ;
106786: LD_VAR 0 1
106790: PPUSH
106791: LD_INT 1000
106793: PPUSH
106794: CALL_OW 234
106798: GO 106768
106800: POP
106801: POP
// until p > 20 ;
106802: LD_VAR 0 3
106806: PUSH
106807: LD_INT 20
106809: GREATER
106810: IFFALSE 106737
// end ;
106812: PPOPN 3
106814: END
// every 0 0$1 trigger StreamModeActive and sTime do
106815: LD_EXP 124
106819: PUSH
106820: LD_EXP 175
106824: AND
106825: IFFALSE 106860
106827: GO 106829
106829: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106830: LD_INT 28
106832: PPUSH
106833: LD_OWVAR 2
106837: PPUSH
106838: LD_INT 2
106840: PPUSH
106841: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106845: LD_INT 30
106847: PPUSH
106848: LD_OWVAR 2
106852: PPUSH
106853: LD_INT 2
106855: PPUSH
106856: CALL_OW 322
// end ;
106860: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106861: LD_EXP 124
106865: PUSH
106866: LD_EXP 176
106870: AND
106871: IFFALSE 106992
106873: GO 106875
106875: DISABLE
106876: LD_INT 0
106878: PPUSH
106879: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106880: LD_ADDR_VAR 0 2
106884: PUSH
106885: LD_INT 22
106887: PUSH
106888: LD_OWVAR 2
106892: PUSH
106893: EMPTY
106894: LIST
106895: LIST
106896: PUSH
106897: LD_INT 21
106899: PUSH
106900: LD_INT 1
106902: PUSH
106903: EMPTY
106904: LIST
106905: LIST
106906: PUSH
106907: LD_INT 3
106909: PUSH
106910: LD_INT 23
106912: PUSH
106913: LD_INT 0
106915: PUSH
106916: EMPTY
106917: LIST
106918: LIST
106919: PUSH
106920: EMPTY
106921: LIST
106922: LIST
106923: PUSH
106924: EMPTY
106925: LIST
106926: LIST
106927: LIST
106928: PPUSH
106929: CALL_OW 69
106933: ST_TO_ADDR
// if not tmp then
106934: LD_VAR 0 2
106938: NOT
106939: IFFALSE 106943
// exit ;
106941: GO 106992
// for i in tmp do
106943: LD_ADDR_VAR 0 1
106947: PUSH
106948: LD_VAR 0 2
106952: PUSH
106953: FOR_IN
106954: IFFALSE 106990
// begin if Crawls ( i ) then
106956: LD_VAR 0 1
106960: PPUSH
106961: CALL_OW 318
106965: IFFALSE 106976
// ComWalk ( i ) ;
106967: LD_VAR 0 1
106971: PPUSH
106972: CALL_OW 138
// SetClass ( i , 2 ) ;
106976: LD_VAR 0 1
106980: PPUSH
106981: LD_INT 2
106983: PPUSH
106984: CALL_OW 336
// end ;
106988: GO 106953
106990: POP
106991: POP
// end ;
106992: PPOPN 2
106994: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106995: LD_EXP 124
106999: PUSH
107000: LD_EXP 177
107004: AND
107005: IFFALSE 107293
107007: GO 107009
107009: DISABLE
107010: LD_INT 0
107012: PPUSH
107013: PPUSH
107014: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
107015: LD_OWVAR 2
107019: PPUSH
107020: LD_INT 9
107022: PPUSH
107023: LD_INT 1
107025: PPUSH
107026: LD_INT 1
107028: PPUSH
107029: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
107033: LD_INT 9
107035: PPUSH
107036: LD_OWVAR 2
107040: PPUSH
107041: CALL_OW 343
// uc_side := 9 ;
107045: LD_ADDR_OWVAR 20
107049: PUSH
107050: LD_INT 9
107052: ST_TO_ADDR
// uc_nation := 2 ;
107053: LD_ADDR_OWVAR 21
107057: PUSH
107058: LD_INT 2
107060: ST_TO_ADDR
// hc_name := Dark Warrior ;
107061: LD_ADDR_OWVAR 26
107065: PUSH
107066: LD_STRING Dark Warrior
107068: ST_TO_ADDR
// hc_gallery :=  ;
107069: LD_ADDR_OWVAR 33
107073: PUSH
107074: LD_STRING 
107076: ST_TO_ADDR
// hc_noskilllimit := true ;
107077: LD_ADDR_OWVAR 76
107081: PUSH
107082: LD_INT 1
107084: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
107085: LD_ADDR_OWVAR 31
107089: PUSH
107090: LD_INT 30
107092: PUSH
107093: LD_INT 30
107095: PUSH
107096: LD_INT 30
107098: PUSH
107099: LD_INT 30
107101: PUSH
107102: EMPTY
107103: LIST
107104: LIST
107105: LIST
107106: LIST
107107: ST_TO_ADDR
// un := CreateHuman ;
107108: LD_ADDR_VAR 0 3
107112: PUSH
107113: CALL_OW 44
107117: ST_TO_ADDR
// hc_noskilllimit := false ;
107118: LD_ADDR_OWVAR 76
107122: PUSH
107123: LD_INT 0
107125: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
107126: LD_VAR 0 3
107130: PPUSH
107131: LD_INT 1
107133: PPUSH
107134: CALL_OW 51
// ToLua ( playRanger() ) ;
107138: LD_STRING playRanger()
107140: PPUSH
107141: CALL_OW 559
// p := 0 ;
107145: LD_ADDR_VAR 0 2
107149: PUSH
107150: LD_INT 0
107152: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
107153: LD_INT 35
107155: PPUSH
107156: CALL_OW 67
// p := p + 1 ;
107160: LD_ADDR_VAR 0 2
107164: PUSH
107165: LD_VAR 0 2
107169: PUSH
107170: LD_INT 1
107172: PLUS
107173: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
107174: LD_VAR 0 3
107178: PPUSH
107179: CALL_OW 256
107183: PUSH
107184: LD_INT 1000
107186: LESS
107187: IFFALSE 107201
// SetLives ( un , 1000 ) ;
107189: LD_VAR 0 3
107193: PPUSH
107194: LD_INT 1000
107196: PPUSH
107197: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
107201: LD_VAR 0 3
107205: PPUSH
107206: LD_INT 81
107208: PUSH
107209: LD_OWVAR 2
107213: PUSH
107214: EMPTY
107215: LIST
107216: LIST
107217: PUSH
107218: LD_INT 91
107220: PUSH
107221: LD_VAR 0 3
107225: PUSH
107226: LD_INT 30
107228: PUSH
107229: EMPTY
107230: LIST
107231: LIST
107232: LIST
107233: PUSH
107234: EMPTY
107235: LIST
107236: LIST
107237: PPUSH
107238: CALL_OW 69
107242: PPUSH
107243: LD_VAR 0 3
107247: PPUSH
107248: CALL_OW 74
107252: PPUSH
107253: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
107257: LD_VAR 0 2
107261: PUSH
107262: LD_INT 80
107264: GREATER
107265: PUSH
107266: LD_VAR 0 3
107270: PPUSH
107271: CALL_OW 301
107275: OR
107276: IFFALSE 107153
// if un then
107278: LD_VAR 0 3
107282: IFFALSE 107293
// RemoveUnit ( un ) ;
107284: LD_VAR 0 3
107288: PPUSH
107289: CALL_OW 64
// end ;
107293: PPOPN 3
107295: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
107296: LD_EXP 178
107300: IFFALSE 107416
107302: GO 107304
107304: DISABLE
107305: LD_INT 0
107307: PPUSH
107308: PPUSH
107309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107310: LD_ADDR_VAR 0 2
107314: PUSH
107315: LD_INT 81
107317: PUSH
107318: LD_OWVAR 2
107322: PUSH
107323: EMPTY
107324: LIST
107325: LIST
107326: PUSH
107327: LD_INT 21
107329: PUSH
107330: LD_INT 1
107332: PUSH
107333: EMPTY
107334: LIST
107335: LIST
107336: PUSH
107337: EMPTY
107338: LIST
107339: LIST
107340: PPUSH
107341: CALL_OW 69
107345: ST_TO_ADDR
// ToLua ( playComputer() ) ;
107346: LD_STRING playComputer()
107348: PPUSH
107349: CALL_OW 559
// if not tmp then
107353: LD_VAR 0 2
107357: NOT
107358: IFFALSE 107362
// exit ;
107360: GO 107416
// for i in tmp do
107362: LD_ADDR_VAR 0 1
107366: PUSH
107367: LD_VAR 0 2
107371: PUSH
107372: FOR_IN
107373: IFFALSE 107414
// for j := 1 to 4 do
107375: LD_ADDR_VAR 0 3
107379: PUSH
107380: DOUBLE
107381: LD_INT 1
107383: DEC
107384: ST_TO_ADDR
107385: LD_INT 4
107387: PUSH
107388: FOR_TO
107389: IFFALSE 107410
// SetSkill ( i , j , 10 ) ;
107391: LD_VAR 0 1
107395: PPUSH
107396: LD_VAR 0 3
107400: PPUSH
107401: LD_INT 10
107403: PPUSH
107404: CALL_OW 237
107408: GO 107388
107410: POP
107411: POP
107412: GO 107372
107414: POP
107415: POP
// end ;
107416: PPOPN 3
107418: END
// every 0 0$1 trigger s30 do var i , tmp ;
107419: LD_EXP 179
107423: IFFALSE 107492
107425: GO 107427
107427: DISABLE
107428: LD_INT 0
107430: PPUSH
107431: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107432: LD_ADDR_VAR 0 2
107436: PUSH
107437: LD_INT 22
107439: PUSH
107440: LD_OWVAR 2
107444: PUSH
107445: EMPTY
107446: LIST
107447: LIST
107448: PPUSH
107449: CALL_OW 69
107453: ST_TO_ADDR
// if not tmp then
107454: LD_VAR 0 2
107458: NOT
107459: IFFALSE 107463
// exit ;
107461: GO 107492
// for i in tmp do
107463: LD_ADDR_VAR 0 1
107467: PUSH
107468: LD_VAR 0 2
107472: PUSH
107473: FOR_IN
107474: IFFALSE 107490
// SetLives ( i , 300 ) ;
107476: LD_VAR 0 1
107480: PPUSH
107481: LD_INT 300
107483: PPUSH
107484: CALL_OW 234
107488: GO 107473
107490: POP
107491: POP
// end ;
107492: PPOPN 2
107494: END
// every 0 0$1 trigger s60 do var i , tmp ;
107495: LD_EXP 180
107499: IFFALSE 107568
107501: GO 107503
107503: DISABLE
107504: LD_INT 0
107506: PPUSH
107507: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107508: LD_ADDR_VAR 0 2
107512: PUSH
107513: LD_INT 22
107515: PUSH
107516: LD_OWVAR 2
107520: PUSH
107521: EMPTY
107522: LIST
107523: LIST
107524: PPUSH
107525: CALL_OW 69
107529: ST_TO_ADDR
// if not tmp then
107530: LD_VAR 0 2
107534: NOT
107535: IFFALSE 107539
// exit ;
107537: GO 107568
// for i in tmp do
107539: LD_ADDR_VAR 0 1
107543: PUSH
107544: LD_VAR 0 2
107548: PUSH
107549: FOR_IN
107550: IFFALSE 107566
// SetLives ( i , 600 ) ;
107552: LD_VAR 0 1
107556: PPUSH
107557: LD_INT 600
107559: PPUSH
107560: CALL_OW 234
107564: GO 107549
107566: POP
107567: POP
// end ;
107568: PPOPN 2
107570: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107571: LD_INT 0
107573: PPUSH
// case cmd of 301 :
107574: LD_VAR 0 1
107578: PUSH
107579: LD_INT 301
107581: DOUBLE
107582: EQUAL
107583: IFTRUE 107587
107585: GO 107619
107587: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107588: LD_VAR 0 6
107592: PPUSH
107593: LD_VAR 0 7
107597: PPUSH
107598: LD_VAR 0 8
107602: PPUSH
107603: LD_VAR 0 4
107607: PPUSH
107608: LD_VAR 0 5
107612: PPUSH
107613: CALL 108828 0 5
107617: GO 107740
107619: LD_INT 302
107621: DOUBLE
107622: EQUAL
107623: IFTRUE 107627
107625: GO 107664
107627: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107628: LD_VAR 0 6
107632: PPUSH
107633: LD_VAR 0 7
107637: PPUSH
107638: LD_VAR 0 8
107642: PPUSH
107643: LD_VAR 0 9
107647: PPUSH
107648: LD_VAR 0 4
107652: PPUSH
107653: LD_VAR 0 5
107657: PPUSH
107658: CALL 108919 0 6
107662: GO 107740
107664: LD_INT 303
107666: DOUBLE
107667: EQUAL
107668: IFTRUE 107672
107670: GO 107709
107672: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107673: LD_VAR 0 6
107677: PPUSH
107678: LD_VAR 0 7
107682: PPUSH
107683: LD_VAR 0 8
107687: PPUSH
107688: LD_VAR 0 9
107692: PPUSH
107693: LD_VAR 0 4
107697: PPUSH
107698: LD_VAR 0 5
107702: PPUSH
107703: CALL 107745 0 6
107707: GO 107740
107709: LD_INT 304
107711: DOUBLE
107712: EQUAL
107713: IFTRUE 107717
107715: GO 107739
107717: POP
// hHackTeleport ( unit , x , y ) ; end ;
107718: LD_VAR 0 2
107722: PPUSH
107723: LD_VAR 0 4
107727: PPUSH
107728: LD_VAR 0 5
107732: PPUSH
107733: CALL 109512 0 3
107737: GO 107740
107739: POP
// end ;
107740: LD_VAR 0 12
107744: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107745: LD_INT 0
107747: PPUSH
107748: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107749: LD_VAR 0 1
107753: PUSH
107754: LD_INT 1
107756: LESS
107757: PUSH
107758: LD_VAR 0 1
107762: PUSH
107763: LD_INT 3
107765: GREATER
107766: OR
107767: PUSH
107768: LD_VAR 0 5
107772: PPUSH
107773: LD_VAR 0 6
107777: PPUSH
107778: CALL_OW 428
107782: OR
107783: IFFALSE 107787
// exit ;
107785: GO 108515
// uc_side := your_side ;
107787: LD_ADDR_OWVAR 20
107791: PUSH
107792: LD_OWVAR 2
107796: ST_TO_ADDR
// uc_nation := nation ;
107797: LD_ADDR_OWVAR 21
107801: PUSH
107802: LD_VAR 0 1
107806: ST_TO_ADDR
// bc_level = 1 ;
107807: LD_ADDR_OWVAR 43
107811: PUSH
107812: LD_INT 1
107814: ST_TO_ADDR
// case btype of 1 :
107815: LD_VAR 0 2
107819: PUSH
107820: LD_INT 1
107822: DOUBLE
107823: EQUAL
107824: IFTRUE 107828
107826: GO 107839
107828: POP
// bc_type := b_depot ; 2 :
107829: LD_ADDR_OWVAR 42
107833: PUSH
107834: LD_INT 0
107836: ST_TO_ADDR
107837: GO 108459
107839: LD_INT 2
107841: DOUBLE
107842: EQUAL
107843: IFTRUE 107847
107845: GO 107858
107847: POP
// bc_type := b_warehouse ; 3 :
107848: LD_ADDR_OWVAR 42
107852: PUSH
107853: LD_INT 1
107855: ST_TO_ADDR
107856: GO 108459
107858: LD_INT 3
107860: DOUBLE
107861: EQUAL
107862: IFTRUE 107866
107864: GO 107877
107866: POP
// bc_type := b_lab ; 4 .. 9 :
107867: LD_ADDR_OWVAR 42
107871: PUSH
107872: LD_INT 6
107874: ST_TO_ADDR
107875: GO 108459
107877: LD_INT 4
107879: DOUBLE
107880: GREATEREQUAL
107881: IFFALSE 107889
107883: LD_INT 9
107885: DOUBLE
107886: LESSEQUAL
107887: IFTRUE 107891
107889: GO 107951
107891: POP
// begin bc_type := b_lab_half ;
107892: LD_ADDR_OWVAR 42
107896: PUSH
107897: LD_INT 7
107899: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107900: LD_ADDR_OWVAR 44
107904: PUSH
107905: LD_INT 10
107907: PUSH
107908: LD_INT 11
107910: PUSH
107911: LD_INT 12
107913: PUSH
107914: LD_INT 15
107916: PUSH
107917: LD_INT 14
107919: PUSH
107920: LD_INT 13
107922: PUSH
107923: EMPTY
107924: LIST
107925: LIST
107926: LIST
107927: LIST
107928: LIST
107929: LIST
107930: PUSH
107931: LD_VAR 0 2
107935: PUSH
107936: LD_INT 3
107938: MINUS
107939: ARRAY
107940: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
107941: LD_ADDR_OWVAR 45
107945: PUSH
107946: LD_INT 9
107948: ST_TO_ADDR
// end ; 10 .. 13 :
107949: GO 108459
107951: LD_INT 10
107953: DOUBLE
107954: GREATEREQUAL
107955: IFFALSE 107963
107957: LD_INT 13
107959: DOUBLE
107960: LESSEQUAL
107961: IFTRUE 107965
107963: GO 108042
107965: POP
// begin bc_type := b_lab_full ;
107966: LD_ADDR_OWVAR 42
107970: PUSH
107971: LD_INT 8
107973: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107974: LD_ADDR_OWVAR 44
107978: PUSH
107979: LD_INT 10
107981: PUSH
107982: LD_INT 12
107984: PUSH
107985: LD_INT 14
107987: PUSH
107988: LD_INT 13
107990: PUSH
107991: EMPTY
107992: LIST
107993: LIST
107994: LIST
107995: LIST
107996: PUSH
107997: LD_VAR 0 2
108001: PUSH
108002: LD_INT 9
108004: MINUS
108005: ARRAY
108006: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
108007: LD_ADDR_OWVAR 45
108011: PUSH
108012: LD_INT 11
108014: PUSH
108015: LD_INT 15
108017: PUSH
108018: LD_INT 12
108020: PUSH
108021: LD_INT 15
108023: PUSH
108024: EMPTY
108025: LIST
108026: LIST
108027: LIST
108028: LIST
108029: PUSH
108030: LD_VAR 0 2
108034: PUSH
108035: LD_INT 9
108037: MINUS
108038: ARRAY
108039: ST_TO_ADDR
// end ; 14 :
108040: GO 108459
108042: LD_INT 14
108044: DOUBLE
108045: EQUAL
108046: IFTRUE 108050
108048: GO 108061
108050: POP
// bc_type := b_workshop ; 15 :
108051: LD_ADDR_OWVAR 42
108055: PUSH
108056: LD_INT 2
108058: ST_TO_ADDR
108059: GO 108459
108061: LD_INT 15
108063: DOUBLE
108064: EQUAL
108065: IFTRUE 108069
108067: GO 108080
108069: POP
// bc_type := b_factory ; 16 :
108070: LD_ADDR_OWVAR 42
108074: PUSH
108075: LD_INT 3
108077: ST_TO_ADDR
108078: GO 108459
108080: LD_INT 16
108082: DOUBLE
108083: EQUAL
108084: IFTRUE 108088
108086: GO 108099
108088: POP
// bc_type := b_ext_gun ; 17 :
108089: LD_ADDR_OWVAR 42
108093: PUSH
108094: LD_INT 17
108096: ST_TO_ADDR
108097: GO 108459
108099: LD_INT 17
108101: DOUBLE
108102: EQUAL
108103: IFTRUE 108107
108105: GO 108135
108107: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
108108: LD_ADDR_OWVAR 42
108112: PUSH
108113: LD_INT 19
108115: PUSH
108116: LD_INT 23
108118: PUSH
108119: LD_INT 19
108121: PUSH
108122: EMPTY
108123: LIST
108124: LIST
108125: LIST
108126: PUSH
108127: LD_VAR 0 1
108131: ARRAY
108132: ST_TO_ADDR
108133: GO 108459
108135: LD_INT 18
108137: DOUBLE
108138: EQUAL
108139: IFTRUE 108143
108141: GO 108154
108143: POP
// bc_type := b_ext_radar ; 19 :
108144: LD_ADDR_OWVAR 42
108148: PUSH
108149: LD_INT 20
108151: ST_TO_ADDR
108152: GO 108459
108154: LD_INT 19
108156: DOUBLE
108157: EQUAL
108158: IFTRUE 108162
108160: GO 108173
108162: POP
// bc_type := b_ext_radio ; 20 :
108163: LD_ADDR_OWVAR 42
108167: PUSH
108168: LD_INT 22
108170: ST_TO_ADDR
108171: GO 108459
108173: LD_INT 20
108175: DOUBLE
108176: EQUAL
108177: IFTRUE 108181
108179: GO 108192
108181: POP
// bc_type := b_ext_siberium ; 21 :
108182: LD_ADDR_OWVAR 42
108186: PUSH
108187: LD_INT 21
108189: ST_TO_ADDR
108190: GO 108459
108192: LD_INT 21
108194: DOUBLE
108195: EQUAL
108196: IFTRUE 108200
108198: GO 108211
108200: POP
// bc_type := b_ext_computer ; 22 :
108201: LD_ADDR_OWVAR 42
108205: PUSH
108206: LD_INT 24
108208: ST_TO_ADDR
108209: GO 108459
108211: LD_INT 22
108213: DOUBLE
108214: EQUAL
108215: IFTRUE 108219
108217: GO 108230
108219: POP
// bc_type := b_ext_track ; 23 :
108220: LD_ADDR_OWVAR 42
108224: PUSH
108225: LD_INT 16
108227: ST_TO_ADDR
108228: GO 108459
108230: LD_INT 23
108232: DOUBLE
108233: EQUAL
108234: IFTRUE 108238
108236: GO 108249
108238: POP
// bc_type := b_ext_laser ; 24 :
108239: LD_ADDR_OWVAR 42
108243: PUSH
108244: LD_INT 25
108246: ST_TO_ADDR
108247: GO 108459
108249: LD_INT 24
108251: DOUBLE
108252: EQUAL
108253: IFTRUE 108257
108255: GO 108268
108257: POP
// bc_type := b_control_tower ; 25 :
108258: LD_ADDR_OWVAR 42
108262: PUSH
108263: LD_INT 36
108265: ST_TO_ADDR
108266: GO 108459
108268: LD_INT 25
108270: DOUBLE
108271: EQUAL
108272: IFTRUE 108276
108274: GO 108287
108276: POP
// bc_type := b_breastwork ; 26 :
108277: LD_ADDR_OWVAR 42
108281: PUSH
108282: LD_INT 31
108284: ST_TO_ADDR
108285: GO 108459
108287: LD_INT 26
108289: DOUBLE
108290: EQUAL
108291: IFTRUE 108295
108293: GO 108306
108295: POP
// bc_type := b_bunker ; 27 :
108296: LD_ADDR_OWVAR 42
108300: PUSH
108301: LD_INT 32
108303: ST_TO_ADDR
108304: GO 108459
108306: LD_INT 27
108308: DOUBLE
108309: EQUAL
108310: IFTRUE 108314
108312: GO 108325
108314: POP
// bc_type := b_turret ; 28 :
108315: LD_ADDR_OWVAR 42
108319: PUSH
108320: LD_INT 33
108322: ST_TO_ADDR
108323: GO 108459
108325: LD_INT 28
108327: DOUBLE
108328: EQUAL
108329: IFTRUE 108333
108331: GO 108344
108333: POP
// bc_type := b_armoury ; 29 :
108334: LD_ADDR_OWVAR 42
108338: PUSH
108339: LD_INT 4
108341: ST_TO_ADDR
108342: GO 108459
108344: LD_INT 29
108346: DOUBLE
108347: EQUAL
108348: IFTRUE 108352
108350: GO 108363
108352: POP
// bc_type := b_barracks ; 30 :
108353: LD_ADDR_OWVAR 42
108357: PUSH
108358: LD_INT 5
108360: ST_TO_ADDR
108361: GO 108459
108363: LD_INT 30
108365: DOUBLE
108366: EQUAL
108367: IFTRUE 108371
108369: GO 108382
108371: POP
// bc_type := b_solar_power ; 31 :
108372: LD_ADDR_OWVAR 42
108376: PUSH
108377: LD_INT 27
108379: ST_TO_ADDR
108380: GO 108459
108382: LD_INT 31
108384: DOUBLE
108385: EQUAL
108386: IFTRUE 108390
108388: GO 108401
108390: POP
// bc_type := b_oil_power ; 32 :
108391: LD_ADDR_OWVAR 42
108395: PUSH
108396: LD_INT 26
108398: ST_TO_ADDR
108399: GO 108459
108401: LD_INT 32
108403: DOUBLE
108404: EQUAL
108405: IFTRUE 108409
108407: GO 108420
108409: POP
// bc_type := b_siberite_power ; 33 :
108410: LD_ADDR_OWVAR 42
108414: PUSH
108415: LD_INT 28
108417: ST_TO_ADDR
108418: GO 108459
108420: LD_INT 33
108422: DOUBLE
108423: EQUAL
108424: IFTRUE 108428
108426: GO 108439
108428: POP
// bc_type := b_oil_mine ; 34 :
108429: LD_ADDR_OWVAR 42
108433: PUSH
108434: LD_INT 29
108436: ST_TO_ADDR
108437: GO 108459
108439: LD_INT 34
108441: DOUBLE
108442: EQUAL
108443: IFTRUE 108447
108445: GO 108458
108447: POP
// bc_type := b_siberite_mine ; end ;
108448: LD_ADDR_OWVAR 42
108452: PUSH
108453: LD_INT 30
108455: ST_TO_ADDR
108456: GO 108459
108458: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108459: LD_ADDR_VAR 0 8
108463: PUSH
108464: LD_VAR 0 5
108468: PPUSH
108469: LD_VAR 0 6
108473: PPUSH
108474: LD_VAR 0 3
108478: PPUSH
108479: CALL_OW 47
108483: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108484: LD_OWVAR 42
108488: PUSH
108489: LD_INT 32
108491: PUSH
108492: LD_INT 33
108494: PUSH
108495: EMPTY
108496: LIST
108497: LIST
108498: IN
108499: IFFALSE 108515
// PlaceWeaponTurret ( b , weapon ) ;
108501: LD_VAR 0 8
108505: PPUSH
108506: LD_VAR 0 4
108510: PPUSH
108511: CALL_OW 431
// end ;
108515: LD_VAR 0 7
108519: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108520: LD_INT 0
108522: PPUSH
108523: PPUSH
108524: PPUSH
108525: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108526: LD_ADDR_VAR 0 4
108530: PUSH
108531: LD_INT 22
108533: PUSH
108534: LD_OWVAR 2
108538: PUSH
108539: EMPTY
108540: LIST
108541: LIST
108542: PUSH
108543: LD_INT 2
108545: PUSH
108546: LD_INT 30
108548: PUSH
108549: LD_INT 0
108551: PUSH
108552: EMPTY
108553: LIST
108554: LIST
108555: PUSH
108556: LD_INT 30
108558: PUSH
108559: LD_INT 1
108561: PUSH
108562: EMPTY
108563: LIST
108564: LIST
108565: PUSH
108566: EMPTY
108567: LIST
108568: LIST
108569: LIST
108570: PUSH
108571: EMPTY
108572: LIST
108573: LIST
108574: PPUSH
108575: CALL_OW 69
108579: ST_TO_ADDR
// if not tmp then
108580: LD_VAR 0 4
108584: NOT
108585: IFFALSE 108589
// exit ;
108587: GO 108648
// for i in tmp do
108589: LD_ADDR_VAR 0 2
108593: PUSH
108594: LD_VAR 0 4
108598: PUSH
108599: FOR_IN
108600: IFFALSE 108646
// for j = 1 to 3 do
108602: LD_ADDR_VAR 0 3
108606: PUSH
108607: DOUBLE
108608: LD_INT 1
108610: DEC
108611: ST_TO_ADDR
108612: LD_INT 3
108614: PUSH
108615: FOR_TO
108616: IFFALSE 108642
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108618: LD_VAR 0 2
108622: PPUSH
108623: CALL_OW 274
108627: PPUSH
108628: LD_VAR 0 3
108632: PPUSH
108633: LD_INT 99999
108635: PPUSH
108636: CALL_OW 277
108640: GO 108615
108642: POP
108643: POP
108644: GO 108599
108646: POP
108647: POP
// end ;
108648: LD_VAR 0 1
108652: RET
// export function hHackSetLevel10 ; var i , j ; begin
108653: LD_INT 0
108655: PPUSH
108656: PPUSH
108657: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108658: LD_ADDR_VAR 0 2
108662: PUSH
108663: LD_INT 21
108665: PUSH
108666: LD_INT 1
108668: PUSH
108669: EMPTY
108670: LIST
108671: LIST
108672: PPUSH
108673: CALL_OW 69
108677: PUSH
108678: FOR_IN
108679: IFFALSE 108731
// if IsSelected ( i ) then
108681: LD_VAR 0 2
108685: PPUSH
108686: CALL_OW 306
108690: IFFALSE 108729
// begin for j := 1 to 4 do
108692: LD_ADDR_VAR 0 3
108696: PUSH
108697: DOUBLE
108698: LD_INT 1
108700: DEC
108701: ST_TO_ADDR
108702: LD_INT 4
108704: PUSH
108705: FOR_TO
108706: IFFALSE 108727
// SetSkill ( i , j , 10 ) ;
108708: LD_VAR 0 2
108712: PPUSH
108713: LD_VAR 0 3
108717: PPUSH
108718: LD_INT 10
108720: PPUSH
108721: CALL_OW 237
108725: GO 108705
108727: POP
108728: POP
// end ;
108729: GO 108678
108731: POP
108732: POP
// end ;
108733: LD_VAR 0 1
108737: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108738: LD_INT 0
108740: PPUSH
108741: PPUSH
108742: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108743: LD_ADDR_VAR 0 2
108747: PUSH
108748: LD_INT 22
108750: PUSH
108751: LD_OWVAR 2
108755: PUSH
108756: EMPTY
108757: LIST
108758: LIST
108759: PUSH
108760: LD_INT 21
108762: PUSH
108763: LD_INT 1
108765: PUSH
108766: EMPTY
108767: LIST
108768: LIST
108769: PUSH
108770: EMPTY
108771: LIST
108772: LIST
108773: PPUSH
108774: CALL_OW 69
108778: PUSH
108779: FOR_IN
108780: IFFALSE 108821
// begin for j := 1 to 4 do
108782: LD_ADDR_VAR 0 3
108786: PUSH
108787: DOUBLE
108788: LD_INT 1
108790: DEC
108791: ST_TO_ADDR
108792: LD_INT 4
108794: PUSH
108795: FOR_TO
108796: IFFALSE 108817
// SetSkill ( i , j , 10 ) ;
108798: LD_VAR 0 2
108802: PPUSH
108803: LD_VAR 0 3
108807: PPUSH
108808: LD_INT 10
108810: PPUSH
108811: CALL_OW 237
108815: GO 108795
108817: POP
108818: POP
// end ;
108819: GO 108779
108821: POP
108822: POP
// end ;
108823: LD_VAR 0 1
108827: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108828: LD_INT 0
108830: PPUSH
// uc_side := your_side ;
108831: LD_ADDR_OWVAR 20
108835: PUSH
108836: LD_OWVAR 2
108840: ST_TO_ADDR
// uc_nation := nation ;
108841: LD_ADDR_OWVAR 21
108845: PUSH
108846: LD_VAR 0 1
108850: ST_TO_ADDR
// InitHc ;
108851: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108855: LD_INT 0
108857: PPUSH
108858: LD_VAR 0 2
108862: PPUSH
108863: LD_VAR 0 3
108867: PPUSH
108868: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108872: LD_VAR 0 4
108876: PPUSH
108877: LD_VAR 0 5
108881: PPUSH
108882: CALL_OW 428
108886: PUSH
108887: LD_INT 0
108889: EQUAL
108890: IFFALSE 108914
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108892: CALL_OW 44
108896: PPUSH
108897: LD_VAR 0 4
108901: PPUSH
108902: LD_VAR 0 5
108906: PPUSH
108907: LD_INT 1
108909: PPUSH
108910: CALL_OW 48
// end ;
108914: LD_VAR 0 6
108918: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108919: LD_INT 0
108921: PPUSH
108922: PPUSH
// uc_side := your_side ;
108923: LD_ADDR_OWVAR 20
108927: PUSH
108928: LD_OWVAR 2
108932: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108933: LD_VAR 0 1
108937: PUSH
108938: LD_INT 1
108940: PUSH
108941: LD_INT 2
108943: PUSH
108944: LD_INT 3
108946: PUSH
108947: LD_INT 4
108949: PUSH
108950: LD_INT 5
108952: PUSH
108953: EMPTY
108954: LIST
108955: LIST
108956: LIST
108957: LIST
108958: LIST
108959: IN
108960: IFFALSE 108972
// uc_nation := nation_american else
108962: LD_ADDR_OWVAR 21
108966: PUSH
108967: LD_INT 1
108969: ST_TO_ADDR
108970: GO 109015
// if chassis in [ 11 , 12 , 13 , 14 ] then
108972: LD_VAR 0 1
108976: PUSH
108977: LD_INT 11
108979: PUSH
108980: LD_INT 12
108982: PUSH
108983: LD_INT 13
108985: PUSH
108986: LD_INT 14
108988: PUSH
108989: EMPTY
108990: LIST
108991: LIST
108992: LIST
108993: LIST
108994: IN
108995: IFFALSE 109007
// uc_nation := nation_arabian else
108997: LD_ADDR_OWVAR 21
109001: PUSH
109002: LD_INT 2
109004: ST_TO_ADDR
109005: GO 109015
// uc_nation := nation_russian ;
109007: LD_ADDR_OWVAR 21
109011: PUSH
109012: LD_INT 3
109014: ST_TO_ADDR
// vc_chassis := chassis ;
109015: LD_ADDR_OWVAR 37
109019: PUSH
109020: LD_VAR 0 1
109024: ST_TO_ADDR
// vc_engine := engine ;
109025: LD_ADDR_OWVAR 39
109029: PUSH
109030: LD_VAR 0 2
109034: ST_TO_ADDR
// vc_control := control ;
109035: LD_ADDR_OWVAR 38
109039: PUSH
109040: LD_VAR 0 3
109044: ST_TO_ADDR
// vc_weapon := weapon ;
109045: LD_ADDR_OWVAR 40
109049: PUSH
109050: LD_VAR 0 4
109054: ST_TO_ADDR
// un := CreateVehicle ;
109055: LD_ADDR_VAR 0 8
109059: PUSH
109060: CALL_OW 45
109064: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
109065: LD_VAR 0 8
109069: PPUSH
109070: LD_INT 0
109072: PPUSH
109073: LD_INT 5
109075: PPUSH
109076: CALL_OW 12
109080: PPUSH
109081: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
109085: LD_VAR 0 8
109089: PPUSH
109090: LD_VAR 0 5
109094: PPUSH
109095: LD_VAR 0 6
109099: PPUSH
109100: LD_INT 1
109102: PPUSH
109103: CALL_OW 48
// end ;
109107: LD_VAR 0 7
109111: RET
// export hInvincible ; every 1 do
109112: GO 109114
109114: DISABLE
// hInvincible := [ ] ;
109115: LD_ADDR_EXP 181
109119: PUSH
109120: EMPTY
109121: ST_TO_ADDR
109122: END
// every 10 do var i ;
109123: GO 109125
109125: DISABLE
109126: LD_INT 0
109128: PPUSH
// begin enable ;
109129: ENABLE
// if not hInvincible then
109130: LD_EXP 181
109134: NOT
109135: IFFALSE 109139
// exit ;
109137: GO 109183
// for i in hInvincible do
109139: LD_ADDR_VAR 0 1
109143: PUSH
109144: LD_EXP 181
109148: PUSH
109149: FOR_IN
109150: IFFALSE 109181
// if GetLives ( i ) < 1000 then
109152: LD_VAR 0 1
109156: PPUSH
109157: CALL_OW 256
109161: PUSH
109162: LD_INT 1000
109164: LESS
109165: IFFALSE 109179
// SetLives ( i , 1000 ) ;
109167: LD_VAR 0 1
109171: PPUSH
109172: LD_INT 1000
109174: PPUSH
109175: CALL_OW 234
109179: GO 109149
109181: POP
109182: POP
// end ;
109183: PPOPN 1
109185: END
// export function hHackInvincible ; var i ; begin
109186: LD_INT 0
109188: PPUSH
109189: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
109190: LD_ADDR_VAR 0 2
109194: PUSH
109195: LD_INT 2
109197: PUSH
109198: LD_INT 21
109200: PUSH
109201: LD_INT 1
109203: PUSH
109204: EMPTY
109205: LIST
109206: LIST
109207: PUSH
109208: LD_INT 21
109210: PUSH
109211: LD_INT 2
109213: PUSH
109214: EMPTY
109215: LIST
109216: LIST
109217: PUSH
109218: EMPTY
109219: LIST
109220: LIST
109221: LIST
109222: PPUSH
109223: CALL_OW 69
109227: PUSH
109228: FOR_IN
109229: IFFALSE 109290
// if IsSelected ( i ) then
109231: LD_VAR 0 2
109235: PPUSH
109236: CALL_OW 306
109240: IFFALSE 109288
// begin if i in hInvincible then
109242: LD_VAR 0 2
109246: PUSH
109247: LD_EXP 181
109251: IN
109252: IFFALSE 109272
// hInvincible := hInvincible diff i else
109254: LD_ADDR_EXP 181
109258: PUSH
109259: LD_EXP 181
109263: PUSH
109264: LD_VAR 0 2
109268: DIFF
109269: ST_TO_ADDR
109270: GO 109288
// hInvincible := hInvincible union i ;
109272: LD_ADDR_EXP 181
109276: PUSH
109277: LD_EXP 181
109281: PUSH
109282: LD_VAR 0 2
109286: UNION
109287: ST_TO_ADDR
// end ;
109288: GO 109228
109290: POP
109291: POP
// end ;
109292: LD_VAR 0 1
109296: RET
// export function hHackInvisible ; var i , j ; begin
109297: LD_INT 0
109299: PPUSH
109300: PPUSH
109301: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109302: LD_ADDR_VAR 0 2
109306: PUSH
109307: LD_INT 21
109309: PUSH
109310: LD_INT 1
109312: PUSH
109313: EMPTY
109314: LIST
109315: LIST
109316: PPUSH
109317: CALL_OW 69
109321: PUSH
109322: FOR_IN
109323: IFFALSE 109347
// if IsSelected ( i ) then
109325: LD_VAR 0 2
109329: PPUSH
109330: CALL_OW 306
109334: IFFALSE 109345
// ComForceInvisible ( i ) ;
109336: LD_VAR 0 2
109340: PPUSH
109341: CALL_OW 496
109345: GO 109322
109347: POP
109348: POP
// end ;
109349: LD_VAR 0 1
109353: RET
// export function hHackChangeYourSide ; begin
109354: LD_INT 0
109356: PPUSH
// if your_side = 8 then
109357: LD_OWVAR 2
109361: PUSH
109362: LD_INT 8
109364: EQUAL
109365: IFFALSE 109377
// your_side := 0 else
109367: LD_ADDR_OWVAR 2
109371: PUSH
109372: LD_INT 0
109374: ST_TO_ADDR
109375: GO 109391
// your_side := your_side + 1 ;
109377: LD_ADDR_OWVAR 2
109381: PUSH
109382: LD_OWVAR 2
109386: PUSH
109387: LD_INT 1
109389: PLUS
109390: ST_TO_ADDR
// end ;
109391: LD_VAR 0 1
109395: RET
// export function hHackChangeUnitSide ; var i , j ; begin
109396: LD_INT 0
109398: PPUSH
109399: PPUSH
109400: PPUSH
// for i in all_units do
109401: LD_ADDR_VAR 0 2
109405: PUSH
109406: LD_OWVAR 3
109410: PUSH
109411: FOR_IN
109412: IFFALSE 109490
// if IsSelected ( i ) then
109414: LD_VAR 0 2
109418: PPUSH
109419: CALL_OW 306
109423: IFFALSE 109488
// begin j := GetSide ( i ) ;
109425: LD_ADDR_VAR 0 3
109429: PUSH
109430: LD_VAR 0 2
109434: PPUSH
109435: CALL_OW 255
109439: ST_TO_ADDR
// if j = 8 then
109440: LD_VAR 0 3
109444: PUSH
109445: LD_INT 8
109447: EQUAL
109448: IFFALSE 109460
// j := 0 else
109450: LD_ADDR_VAR 0 3
109454: PUSH
109455: LD_INT 0
109457: ST_TO_ADDR
109458: GO 109474
// j := j + 1 ;
109460: LD_ADDR_VAR 0 3
109464: PUSH
109465: LD_VAR 0 3
109469: PUSH
109470: LD_INT 1
109472: PLUS
109473: ST_TO_ADDR
// SetSide ( i , j ) ;
109474: LD_VAR 0 2
109478: PPUSH
109479: LD_VAR 0 3
109483: PPUSH
109484: CALL_OW 235
// end ;
109488: GO 109411
109490: POP
109491: POP
// end ;
109492: LD_VAR 0 1
109496: RET
// export function hHackFog ; begin
109497: LD_INT 0
109499: PPUSH
// FogOff ( true ) ;
109500: LD_INT 1
109502: PPUSH
109503: CALL_OW 344
// end ;
109507: LD_VAR 0 1
109511: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109512: LD_INT 0
109514: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109515: LD_VAR 0 1
109519: PPUSH
109520: LD_VAR 0 2
109524: PPUSH
109525: LD_VAR 0 3
109529: PPUSH
109530: LD_INT 1
109532: PPUSH
109533: LD_INT 1
109535: PPUSH
109536: CALL_OW 483
// CenterOnXY ( x , y ) ;
109540: LD_VAR 0 2
109544: PPUSH
109545: LD_VAR 0 3
109549: PPUSH
109550: CALL_OW 84
// end ;
109554: LD_VAR 0 4
109558: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109559: LD_INT 0
109561: PPUSH
109562: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109563: LD_VAR 0 1
109567: NOT
109568: PUSH
109569: LD_VAR 0 2
109573: PPUSH
109574: LD_VAR 0 3
109578: PPUSH
109579: CALL_OW 488
109583: NOT
109584: OR
109585: PUSH
109586: LD_VAR 0 1
109590: PPUSH
109591: CALL_OW 266
109595: PUSH
109596: LD_INT 3
109598: NONEQUAL
109599: PUSH
109600: LD_VAR 0 1
109604: PPUSH
109605: CALL_OW 247
109609: PUSH
109610: LD_INT 1
109612: EQUAL
109613: NOT
109614: AND
109615: OR
109616: IFFALSE 109620
// exit ;
109618: GO 109769
// if GetType ( factory ) = unit_human then
109620: LD_VAR 0 1
109624: PPUSH
109625: CALL_OW 247
109629: PUSH
109630: LD_INT 1
109632: EQUAL
109633: IFFALSE 109650
// factory := IsInUnit ( factory ) ;
109635: LD_ADDR_VAR 0 1
109639: PUSH
109640: LD_VAR 0 1
109644: PPUSH
109645: CALL_OW 310
109649: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109650: LD_VAR 0 1
109654: PPUSH
109655: CALL_OW 266
109659: PUSH
109660: LD_INT 3
109662: NONEQUAL
109663: IFFALSE 109667
// exit ;
109665: GO 109769
// if HexInfo ( x , y ) = factory then
109667: LD_VAR 0 2
109671: PPUSH
109672: LD_VAR 0 3
109676: PPUSH
109677: CALL_OW 428
109681: PUSH
109682: LD_VAR 0 1
109686: EQUAL
109687: IFFALSE 109714
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109689: LD_ADDR_EXP 182
109693: PUSH
109694: LD_EXP 182
109698: PPUSH
109699: LD_VAR 0 1
109703: PPUSH
109704: LD_INT 0
109706: PPUSH
109707: CALL_OW 1
109711: ST_TO_ADDR
109712: GO 109765
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109714: LD_ADDR_EXP 182
109718: PUSH
109719: LD_EXP 182
109723: PPUSH
109724: LD_VAR 0 1
109728: PPUSH
109729: LD_VAR 0 1
109733: PPUSH
109734: CALL_OW 255
109738: PUSH
109739: LD_VAR 0 1
109743: PUSH
109744: LD_VAR 0 2
109748: PUSH
109749: LD_VAR 0 3
109753: PUSH
109754: EMPTY
109755: LIST
109756: LIST
109757: LIST
109758: LIST
109759: PPUSH
109760: CALL_OW 1
109764: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109765: CALL 109774 0 0
// end ;
109769: LD_VAR 0 4
109773: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109774: LD_INT 0
109776: PPUSH
109777: PPUSH
109778: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109779: LD_STRING resetFactoryWaypoint();
109781: PPUSH
109782: CALL_OW 559
// if factoryWaypoints then
109786: LD_EXP 182
109790: IFFALSE 109916
// begin list := PrepareArray ( factoryWaypoints ) ;
109792: LD_ADDR_VAR 0 3
109796: PUSH
109797: LD_EXP 182
109801: PPUSH
109802: CALL 94363 0 1
109806: ST_TO_ADDR
// for i := 1 to list do
109807: LD_ADDR_VAR 0 2
109811: PUSH
109812: DOUBLE
109813: LD_INT 1
109815: DEC
109816: ST_TO_ADDR
109817: LD_VAR 0 3
109821: PUSH
109822: FOR_TO
109823: IFFALSE 109914
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109825: LD_STRING setFactoryWaypointXY(
109827: PUSH
109828: LD_VAR 0 3
109832: PUSH
109833: LD_VAR 0 2
109837: ARRAY
109838: PUSH
109839: LD_INT 1
109841: ARRAY
109842: STR
109843: PUSH
109844: LD_STRING ,
109846: STR
109847: PUSH
109848: LD_VAR 0 3
109852: PUSH
109853: LD_VAR 0 2
109857: ARRAY
109858: PUSH
109859: LD_INT 2
109861: ARRAY
109862: STR
109863: PUSH
109864: LD_STRING ,
109866: STR
109867: PUSH
109868: LD_VAR 0 3
109872: PUSH
109873: LD_VAR 0 2
109877: ARRAY
109878: PUSH
109879: LD_INT 3
109881: ARRAY
109882: STR
109883: PUSH
109884: LD_STRING ,
109886: STR
109887: PUSH
109888: LD_VAR 0 3
109892: PUSH
109893: LD_VAR 0 2
109897: ARRAY
109898: PUSH
109899: LD_INT 4
109901: ARRAY
109902: STR
109903: PUSH
109904: LD_STRING )
109906: STR
109907: PPUSH
109908: CALL_OW 559
109912: GO 109822
109914: POP
109915: POP
// end ; end ;
109916: LD_VAR 0 1
109920: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109921: LD_INT 0
109923: PPUSH
// if HexInfo ( x , y ) = warehouse then
109924: LD_VAR 0 2
109928: PPUSH
109929: LD_VAR 0 3
109933: PPUSH
109934: CALL_OW 428
109938: PUSH
109939: LD_VAR 0 1
109943: EQUAL
109944: IFFALSE 109971
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109946: LD_ADDR_EXP 183
109950: PUSH
109951: LD_EXP 183
109955: PPUSH
109956: LD_VAR 0 1
109960: PPUSH
109961: LD_INT 0
109963: PPUSH
109964: CALL_OW 1
109968: ST_TO_ADDR
109969: GO 110022
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109971: LD_ADDR_EXP 183
109975: PUSH
109976: LD_EXP 183
109980: PPUSH
109981: LD_VAR 0 1
109985: PPUSH
109986: LD_VAR 0 1
109990: PPUSH
109991: CALL_OW 255
109995: PUSH
109996: LD_VAR 0 1
110000: PUSH
110001: LD_VAR 0 2
110005: PUSH
110006: LD_VAR 0 3
110010: PUSH
110011: EMPTY
110012: LIST
110013: LIST
110014: LIST
110015: LIST
110016: PPUSH
110017: CALL_OW 1
110021: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
110022: CALL 110031 0 0
// end ;
110026: LD_VAR 0 4
110030: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
110031: LD_INT 0
110033: PPUSH
110034: PPUSH
110035: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
110036: LD_STRING resetWarehouseGatheringPoints();
110038: PPUSH
110039: CALL_OW 559
// if warehouseGatheringPoints then
110043: LD_EXP 183
110047: IFFALSE 110173
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
110049: LD_ADDR_VAR 0 3
110053: PUSH
110054: LD_EXP 183
110058: PPUSH
110059: CALL 94363 0 1
110063: ST_TO_ADDR
// for i := 1 to list do
110064: LD_ADDR_VAR 0 2
110068: PUSH
110069: DOUBLE
110070: LD_INT 1
110072: DEC
110073: ST_TO_ADDR
110074: LD_VAR 0 3
110078: PUSH
110079: FOR_TO
110080: IFFALSE 110171
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
110082: LD_STRING setWarehouseGatheringPointXY(
110084: PUSH
110085: LD_VAR 0 3
110089: PUSH
110090: LD_VAR 0 2
110094: ARRAY
110095: PUSH
110096: LD_INT 1
110098: ARRAY
110099: STR
110100: PUSH
110101: LD_STRING ,
110103: STR
110104: PUSH
110105: LD_VAR 0 3
110109: PUSH
110110: LD_VAR 0 2
110114: ARRAY
110115: PUSH
110116: LD_INT 2
110118: ARRAY
110119: STR
110120: PUSH
110121: LD_STRING ,
110123: STR
110124: PUSH
110125: LD_VAR 0 3
110129: PUSH
110130: LD_VAR 0 2
110134: ARRAY
110135: PUSH
110136: LD_INT 3
110138: ARRAY
110139: STR
110140: PUSH
110141: LD_STRING ,
110143: STR
110144: PUSH
110145: LD_VAR 0 3
110149: PUSH
110150: LD_VAR 0 2
110154: ARRAY
110155: PUSH
110156: LD_INT 4
110158: ARRAY
110159: STR
110160: PUSH
110161: LD_STRING )
110163: STR
110164: PPUSH
110165: CALL_OW 559
110169: GO 110079
110171: POP
110172: POP
// end ; end ;
110173: LD_VAR 0 1
110177: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
110178: LD_EXP 183
110182: IFFALSE 110867
110184: GO 110186
110186: DISABLE
110187: LD_INT 0
110189: PPUSH
110190: PPUSH
110191: PPUSH
110192: PPUSH
110193: PPUSH
110194: PPUSH
110195: PPUSH
110196: PPUSH
110197: PPUSH
// begin enable ;
110198: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
110199: LD_ADDR_VAR 0 3
110203: PUSH
110204: LD_EXP 183
110208: PPUSH
110209: CALL 94363 0 1
110213: ST_TO_ADDR
// if not list then
110214: LD_VAR 0 3
110218: NOT
110219: IFFALSE 110223
// exit ;
110221: GO 110867
// for i := 1 to list do
110223: LD_ADDR_VAR 0 1
110227: PUSH
110228: DOUBLE
110229: LD_INT 1
110231: DEC
110232: ST_TO_ADDR
110233: LD_VAR 0 3
110237: PUSH
110238: FOR_TO
110239: IFFALSE 110865
// begin depot := list [ i ] [ 2 ] ;
110241: LD_ADDR_VAR 0 8
110245: PUSH
110246: LD_VAR 0 3
110250: PUSH
110251: LD_VAR 0 1
110255: ARRAY
110256: PUSH
110257: LD_INT 2
110259: ARRAY
110260: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
110261: LD_ADDR_VAR 0 5
110265: PUSH
110266: LD_VAR 0 3
110270: PUSH
110271: LD_VAR 0 1
110275: ARRAY
110276: PUSH
110277: LD_INT 1
110279: ARRAY
110280: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
110281: LD_VAR 0 8
110285: PPUSH
110286: CALL_OW 301
110290: PUSH
110291: LD_VAR 0 5
110295: PUSH
110296: LD_VAR 0 8
110300: PPUSH
110301: CALL_OW 255
110305: NONEQUAL
110306: OR
110307: IFFALSE 110336
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
110309: LD_ADDR_EXP 183
110313: PUSH
110314: LD_EXP 183
110318: PPUSH
110319: LD_VAR 0 8
110323: PPUSH
110324: LD_INT 0
110326: PPUSH
110327: CALL_OW 1
110331: ST_TO_ADDR
// exit ;
110332: POP
110333: POP
110334: GO 110867
// end ; x := list [ i ] [ 3 ] ;
110336: LD_ADDR_VAR 0 6
110340: PUSH
110341: LD_VAR 0 3
110345: PUSH
110346: LD_VAR 0 1
110350: ARRAY
110351: PUSH
110352: LD_INT 3
110354: ARRAY
110355: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
110356: LD_ADDR_VAR 0 7
110360: PUSH
110361: LD_VAR 0 3
110365: PUSH
110366: LD_VAR 0 1
110370: ARRAY
110371: PUSH
110372: LD_INT 4
110374: ARRAY
110375: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
110376: LD_ADDR_VAR 0 9
110380: PUSH
110381: LD_VAR 0 6
110385: PPUSH
110386: LD_VAR 0 7
110390: PPUSH
110391: LD_INT 16
110393: PPUSH
110394: CALL 92951 0 3
110398: ST_TO_ADDR
// if not cratesNearbyPoint then
110399: LD_VAR 0 9
110403: NOT
110404: IFFALSE 110410
// exit ;
110406: POP
110407: POP
110408: GO 110867
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
110410: LD_ADDR_VAR 0 4
110414: PUSH
110415: LD_INT 22
110417: PUSH
110418: LD_VAR 0 5
110422: PUSH
110423: EMPTY
110424: LIST
110425: LIST
110426: PUSH
110427: LD_INT 3
110429: PUSH
110430: LD_INT 60
110432: PUSH
110433: EMPTY
110434: LIST
110435: PUSH
110436: EMPTY
110437: LIST
110438: LIST
110439: PUSH
110440: LD_INT 91
110442: PUSH
110443: LD_VAR 0 8
110447: PUSH
110448: LD_INT 6
110450: PUSH
110451: EMPTY
110452: LIST
110453: LIST
110454: LIST
110455: PUSH
110456: LD_INT 2
110458: PUSH
110459: LD_INT 25
110461: PUSH
110462: LD_INT 2
110464: PUSH
110465: EMPTY
110466: LIST
110467: LIST
110468: PUSH
110469: LD_INT 25
110471: PUSH
110472: LD_INT 16
110474: PUSH
110475: EMPTY
110476: LIST
110477: LIST
110478: PUSH
110479: EMPTY
110480: LIST
110481: LIST
110482: LIST
110483: PUSH
110484: EMPTY
110485: LIST
110486: LIST
110487: LIST
110488: LIST
110489: PPUSH
110490: CALL_OW 69
110494: PUSH
110495: LD_VAR 0 8
110499: PPUSH
110500: CALL_OW 313
110504: PPUSH
110505: LD_INT 3
110507: PUSH
110508: LD_INT 60
110510: PUSH
110511: EMPTY
110512: LIST
110513: PUSH
110514: EMPTY
110515: LIST
110516: LIST
110517: PUSH
110518: LD_INT 2
110520: PUSH
110521: LD_INT 25
110523: PUSH
110524: LD_INT 2
110526: PUSH
110527: EMPTY
110528: LIST
110529: LIST
110530: PUSH
110531: LD_INT 25
110533: PUSH
110534: LD_INT 16
110536: PUSH
110537: EMPTY
110538: LIST
110539: LIST
110540: PUSH
110541: EMPTY
110542: LIST
110543: LIST
110544: LIST
110545: PUSH
110546: EMPTY
110547: LIST
110548: LIST
110549: PPUSH
110550: CALL_OW 72
110554: UNION
110555: ST_TO_ADDR
// if tmp then
110556: LD_VAR 0 4
110560: IFFALSE 110640
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110562: LD_ADDR_VAR 0 4
110566: PUSH
110567: LD_VAR 0 4
110571: PPUSH
110572: LD_INT 3
110574: PPUSH
110575: CALL 90920 0 2
110579: ST_TO_ADDR
// for j in tmp do
110580: LD_ADDR_VAR 0 2
110584: PUSH
110585: LD_VAR 0 4
110589: PUSH
110590: FOR_IN
110591: IFFALSE 110634
// begin if IsInUnit ( j ) then
110593: LD_VAR 0 2
110597: PPUSH
110598: CALL_OW 310
110602: IFFALSE 110613
// ComExit ( j ) ;
110604: LD_VAR 0 2
110608: PPUSH
110609: CALL 91003 0 1
// AddComCollect ( j , x , y ) ;
110613: LD_VAR 0 2
110617: PPUSH
110618: LD_VAR 0 6
110622: PPUSH
110623: LD_VAR 0 7
110627: PPUSH
110628: CALL_OW 177
// end ;
110632: GO 110590
110634: POP
110635: POP
// exit ;
110636: POP
110637: POP
110638: GO 110867
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110640: LD_ADDR_VAR 0 4
110644: PUSH
110645: LD_INT 22
110647: PUSH
110648: LD_VAR 0 5
110652: PUSH
110653: EMPTY
110654: LIST
110655: LIST
110656: PUSH
110657: LD_INT 91
110659: PUSH
110660: LD_VAR 0 8
110664: PUSH
110665: LD_INT 8
110667: PUSH
110668: EMPTY
110669: LIST
110670: LIST
110671: LIST
110672: PUSH
110673: LD_INT 2
110675: PUSH
110676: LD_INT 34
110678: PUSH
110679: LD_INT 12
110681: PUSH
110682: EMPTY
110683: LIST
110684: LIST
110685: PUSH
110686: LD_INT 34
110688: PUSH
110689: LD_INT 51
110691: PUSH
110692: EMPTY
110693: LIST
110694: LIST
110695: PUSH
110696: LD_INT 34
110698: PUSH
110699: LD_INT 32
110701: PUSH
110702: EMPTY
110703: LIST
110704: LIST
110705: PUSH
110706: LD_INT 34
110708: PUSH
110709: LD_INT 89
110711: PUSH
110712: EMPTY
110713: LIST
110714: LIST
110715: PUSH
110716: EMPTY
110717: LIST
110718: LIST
110719: LIST
110720: LIST
110721: LIST
110722: PUSH
110723: EMPTY
110724: LIST
110725: LIST
110726: LIST
110727: PPUSH
110728: CALL_OW 69
110732: ST_TO_ADDR
// if tmp then
110733: LD_VAR 0 4
110737: IFFALSE 110863
// begin for j in tmp do
110739: LD_ADDR_VAR 0 2
110743: PUSH
110744: LD_VAR 0 4
110748: PUSH
110749: FOR_IN
110750: IFFALSE 110861
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110752: LD_VAR 0 2
110756: PPUSH
110757: CALL_OW 262
110761: PUSH
110762: LD_INT 3
110764: EQUAL
110765: PUSH
110766: LD_VAR 0 2
110770: PPUSH
110771: CALL_OW 261
110775: PUSH
110776: LD_INT 20
110778: GREATER
110779: OR
110780: PUSH
110781: LD_VAR 0 2
110785: PPUSH
110786: CALL_OW 314
110790: NOT
110791: AND
110792: PUSH
110793: LD_VAR 0 2
110797: PPUSH
110798: CALL_OW 263
110802: PUSH
110803: LD_INT 1
110805: NONEQUAL
110806: PUSH
110807: LD_VAR 0 2
110811: PPUSH
110812: CALL_OW 311
110816: OR
110817: AND
110818: IFFALSE 110859
// begin ComCollect ( j , x , y ) ;
110820: LD_VAR 0 2
110824: PPUSH
110825: LD_VAR 0 6
110829: PPUSH
110830: LD_VAR 0 7
110834: PPUSH
110835: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110839: LD_VAR 0 2
110843: PPUSH
110844: LD_VAR 0 8
110848: PPUSH
110849: CALL_OW 172
// exit ;
110853: POP
110854: POP
110855: POP
110856: POP
110857: GO 110867
// end ;
110859: GO 110749
110861: POP
110862: POP
// end ; end ;
110863: GO 110238
110865: POP
110866: POP
// end ; end_of_file
110867: PPOPN 9
110869: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
110870: LD_INT 0
110872: PPUSH
110873: PPUSH
110874: PPUSH
110875: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
110876: LD_VAR 0 1
110880: PPUSH
110881: CALL_OW 264
110885: PUSH
110886: LD_INT 91
110888: EQUAL
110889: IFFALSE 110961
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
110891: LD_INT 68
110893: PPUSH
110894: LD_VAR 0 1
110898: PPUSH
110899: CALL_OW 255
110903: PPUSH
110904: CALL_OW 321
110908: PUSH
110909: LD_INT 2
110911: EQUAL
110912: IFFALSE 110924
// eff := 70 else
110914: LD_ADDR_VAR 0 4
110918: PUSH
110919: LD_INT 70
110921: ST_TO_ADDR
110922: GO 110932
// eff := 30 ;
110924: LD_ADDR_VAR 0 4
110928: PUSH
110929: LD_INT 30
110931: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
110932: LD_VAR 0 1
110936: PPUSH
110937: CALL_OW 250
110941: PPUSH
110942: LD_VAR 0 1
110946: PPUSH
110947: CALL_OW 251
110951: PPUSH
110952: LD_VAR 0 4
110956: PPUSH
110957: CALL_OW 495
// end ; end ;
110961: LD_VAR 0 2
110965: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
110966: LD_INT 0
110968: PPUSH
// end ;
110969: LD_VAR 0 4
110973: RET
// export function SOS_Command ( cmd ) ; begin
110974: LD_INT 0
110976: PPUSH
// end ;
110977: LD_VAR 0 2
110981: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
110982: LD_INT 0
110984: PPUSH
// end ;
110985: LD_VAR 0 6
110989: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
110990: LD_INT 0
110992: PPUSH
110993: PPUSH
// if not vehicle or not factory then
110994: LD_VAR 0 1
110998: NOT
110999: PUSH
111000: LD_VAR 0 2
111004: NOT
111005: OR
111006: IFFALSE 111010
// exit ;
111008: GO 111241
// if factoryWaypoints >= factory then
111010: LD_EXP 182
111014: PUSH
111015: LD_VAR 0 2
111019: GREATEREQUAL
111020: IFFALSE 111241
// if factoryWaypoints [ factory ] then
111022: LD_EXP 182
111026: PUSH
111027: LD_VAR 0 2
111031: ARRAY
111032: IFFALSE 111241
// begin if GetControl ( vehicle ) = control_manual then
111034: LD_VAR 0 1
111038: PPUSH
111039: CALL_OW 263
111043: PUSH
111044: LD_INT 1
111046: EQUAL
111047: IFFALSE 111128
// begin driver := IsDrivenBy ( vehicle ) ;
111049: LD_ADDR_VAR 0 4
111053: PUSH
111054: LD_VAR 0 1
111058: PPUSH
111059: CALL_OW 311
111063: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
111064: LD_VAR 0 4
111068: PPUSH
111069: LD_EXP 182
111073: PUSH
111074: LD_VAR 0 2
111078: ARRAY
111079: PUSH
111080: LD_INT 3
111082: ARRAY
111083: PPUSH
111084: LD_EXP 182
111088: PUSH
111089: LD_VAR 0 2
111093: ARRAY
111094: PUSH
111095: LD_INT 4
111097: ARRAY
111098: PPUSH
111099: CALL_OW 171
// AddComExitVehicle ( driver ) ;
111103: LD_VAR 0 4
111107: PPUSH
111108: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
111112: LD_VAR 0 4
111116: PPUSH
111117: LD_VAR 0 2
111121: PPUSH
111122: CALL_OW 180
// end else
111126: GO 111241
// if GetControl ( vehicle ) = control_remote then
111128: LD_VAR 0 1
111132: PPUSH
111133: CALL_OW 263
111137: PUSH
111138: LD_INT 2
111140: EQUAL
111141: IFFALSE 111202
// begin wait ( 0 0$2 ) ;
111143: LD_INT 70
111145: PPUSH
111146: CALL_OW 67
// if Connect ( vehicle ) then
111150: LD_VAR 0 1
111154: PPUSH
111155: CALL 61211 0 1
111159: IFFALSE 111200
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
111161: LD_VAR 0 1
111165: PPUSH
111166: LD_EXP 182
111170: PUSH
111171: LD_VAR 0 2
111175: ARRAY
111176: PUSH
111177: LD_INT 3
111179: ARRAY
111180: PPUSH
111181: LD_EXP 182
111185: PUSH
111186: LD_VAR 0 2
111190: ARRAY
111191: PUSH
111192: LD_INT 4
111194: ARRAY
111195: PPUSH
111196: CALL_OW 171
// end else
111200: GO 111241
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
111202: LD_VAR 0 1
111206: PPUSH
111207: LD_EXP 182
111211: PUSH
111212: LD_VAR 0 2
111216: ARRAY
111217: PUSH
111218: LD_INT 3
111220: ARRAY
111221: PPUSH
111222: LD_EXP 182
111226: PUSH
111227: LD_VAR 0 2
111231: ARRAY
111232: PUSH
111233: LD_INT 4
111235: ARRAY
111236: PPUSH
111237: CALL_OW 171
// end ; end ;
111241: LD_VAR 0 3
111245: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
111246: LD_INT 0
111248: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
111249: LD_VAR 0 1
111253: PUSH
111254: LD_INT 250
111256: EQUAL
111257: PUSH
111258: LD_VAR 0 2
111262: PPUSH
111263: CALL_OW 264
111267: PUSH
111268: LD_INT 81
111270: EQUAL
111271: AND
111272: IFFALSE 111293
// MinerPlaceMine ( unit , x , y ) ;
111274: LD_VAR 0 2
111278: PPUSH
111279: LD_VAR 0 4
111283: PPUSH
111284: LD_VAR 0 5
111288: PPUSH
111289: CALL 114117 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
111293: LD_VAR 0 1
111297: PUSH
111298: LD_INT 251
111300: EQUAL
111301: PUSH
111302: LD_VAR 0 2
111306: PPUSH
111307: CALL_OW 264
111311: PUSH
111312: LD_INT 81
111314: EQUAL
111315: AND
111316: IFFALSE 111337
// MinerDetonateMine ( unit , x , y ) ;
111318: LD_VAR 0 2
111322: PPUSH
111323: LD_VAR 0 4
111327: PPUSH
111328: LD_VAR 0 5
111332: PPUSH
111333: CALL 114392 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
111337: LD_VAR 0 1
111341: PUSH
111342: LD_INT 252
111344: EQUAL
111345: PUSH
111346: LD_VAR 0 2
111350: PPUSH
111351: CALL_OW 264
111355: PUSH
111356: LD_INT 81
111358: EQUAL
111359: AND
111360: IFFALSE 111381
// MinerCreateMinefield ( unit , x , y ) ;
111362: LD_VAR 0 2
111366: PPUSH
111367: LD_VAR 0 4
111371: PPUSH
111372: LD_VAR 0 5
111376: PPUSH
111377: CALL 114809 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
111381: LD_VAR 0 1
111385: PUSH
111386: LD_INT 253
111388: EQUAL
111389: PUSH
111390: LD_VAR 0 2
111394: PPUSH
111395: CALL_OW 257
111399: PUSH
111400: LD_INT 5
111402: EQUAL
111403: AND
111404: IFFALSE 111425
// ComBinocular ( unit , x , y ) ;
111406: LD_VAR 0 2
111410: PPUSH
111411: LD_VAR 0 4
111415: PPUSH
111416: LD_VAR 0 5
111420: PPUSH
111421: CALL 115178 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
111425: LD_VAR 0 1
111429: PUSH
111430: LD_INT 254
111432: EQUAL
111433: PUSH
111434: LD_VAR 0 2
111438: PPUSH
111439: CALL_OW 264
111443: PUSH
111444: LD_INT 99
111446: EQUAL
111447: AND
111448: PUSH
111449: LD_VAR 0 3
111453: PPUSH
111454: CALL_OW 263
111458: PUSH
111459: LD_INT 3
111461: EQUAL
111462: AND
111463: IFFALSE 111479
// HackDestroyVehicle ( unit , selectedUnit ) ;
111465: LD_VAR 0 2
111469: PPUSH
111470: LD_VAR 0 3
111474: PPUSH
111475: CALL 113481 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
111479: LD_VAR 0 1
111483: PUSH
111484: LD_INT 255
111486: EQUAL
111487: PUSH
111488: LD_VAR 0 2
111492: PPUSH
111493: CALL_OW 264
111497: PUSH
111498: LD_INT 14
111500: PUSH
111501: LD_INT 53
111503: PUSH
111504: EMPTY
111505: LIST
111506: LIST
111507: IN
111508: AND
111509: PUSH
111510: LD_VAR 0 4
111514: PPUSH
111515: LD_VAR 0 5
111519: PPUSH
111520: CALL_OW 488
111524: AND
111525: IFFALSE 111549
// CutTreeXYR ( unit , x , y , 12 ) ;
111527: LD_VAR 0 2
111531: PPUSH
111532: LD_VAR 0 4
111536: PPUSH
111537: LD_VAR 0 5
111541: PPUSH
111542: LD_INT 12
111544: PPUSH
111545: CALL 111644 0 4
// if cmd = 256 then
111549: LD_VAR 0 1
111553: PUSH
111554: LD_INT 256
111556: EQUAL
111557: IFFALSE 111578
// SetFactoryWaypoint ( unit , x , y ) ;
111559: LD_VAR 0 2
111563: PPUSH
111564: LD_VAR 0 4
111568: PPUSH
111569: LD_VAR 0 5
111573: PPUSH
111574: CALL 109559 0 3
// if cmd = 257 then
111578: LD_VAR 0 1
111582: PUSH
111583: LD_INT 257
111585: EQUAL
111586: IFFALSE 111607
// SetWarehouseGatheringPoint ( unit , x , y ) ;
111588: LD_VAR 0 2
111592: PPUSH
111593: LD_VAR 0 4
111597: PPUSH
111598: LD_VAR 0 5
111602: PPUSH
111603: CALL 109921 0 3
// if cmd = 258 then
111607: LD_VAR 0 1
111611: PUSH
111612: LD_INT 258
111614: EQUAL
111615: IFFALSE 111639
// BurnTreeXYR ( unit , x , y , 8 ) ;
111617: LD_VAR 0 2
111621: PPUSH
111622: LD_VAR 0 4
111626: PPUSH
111627: LD_VAR 0 5
111631: PPUSH
111632: LD_INT 8
111634: PPUSH
111635: CALL 112038 0 4
// end ;
111639: LD_VAR 0 6
111643: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
111644: LD_INT 0
111646: PPUSH
111647: PPUSH
111648: PPUSH
111649: PPUSH
111650: PPUSH
111651: PPUSH
111652: PPUSH
111653: PPUSH
111654: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
111655: LD_VAR 0 1
111659: PPUSH
111660: CALL_OW 302
111664: NOT
111665: PUSH
111666: LD_VAR 0 2
111670: PPUSH
111671: LD_VAR 0 3
111675: PPUSH
111676: CALL_OW 488
111680: NOT
111681: OR
111682: PUSH
111683: LD_VAR 0 4
111687: NOT
111688: OR
111689: IFFALSE 111693
// exit ;
111691: GO 112033
// list := [ ] ;
111693: LD_ADDR_VAR 0 13
111697: PUSH
111698: EMPTY
111699: ST_TO_ADDR
// if x - r < 0 then
111700: LD_VAR 0 2
111704: PUSH
111705: LD_VAR 0 4
111709: MINUS
111710: PUSH
111711: LD_INT 0
111713: LESS
111714: IFFALSE 111726
// min_x := 0 else
111716: LD_ADDR_VAR 0 7
111720: PUSH
111721: LD_INT 0
111723: ST_TO_ADDR
111724: GO 111742
// min_x := x - r ;
111726: LD_ADDR_VAR 0 7
111730: PUSH
111731: LD_VAR 0 2
111735: PUSH
111736: LD_VAR 0 4
111740: MINUS
111741: ST_TO_ADDR
// if y - r < 0 then
111742: LD_VAR 0 3
111746: PUSH
111747: LD_VAR 0 4
111751: MINUS
111752: PUSH
111753: LD_INT 0
111755: LESS
111756: IFFALSE 111768
// min_y := 0 else
111758: LD_ADDR_VAR 0 8
111762: PUSH
111763: LD_INT 0
111765: ST_TO_ADDR
111766: GO 111784
// min_y := y - r ;
111768: LD_ADDR_VAR 0 8
111772: PUSH
111773: LD_VAR 0 3
111777: PUSH
111778: LD_VAR 0 4
111782: MINUS
111783: ST_TO_ADDR
// max_x := x + r ;
111784: LD_ADDR_VAR 0 9
111788: PUSH
111789: LD_VAR 0 2
111793: PUSH
111794: LD_VAR 0 4
111798: PLUS
111799: ST_TO_ADDR
// max_y := y + r ;
111800: LD_ADDR_VAR 0 10
111804: PUSH
111805: LD_VAR 0 3
111809: PUSH
111810: LD_VAR 0 4
111814: PLUS
111815: ST_TO_ADDR
// for _x = min_x to max_x do
111816: LD_ADDR_VAR 0 11
111820: PUSH
111821: DOUBLE
111822: LD_VAR 0 7
111826: DEC
111827: ST_TO_ADDR
111828: LD_VAR 0 9
111832: PUSH
111833: FOR_TO
111834: IFFALSE 111951
// for _y = min_y to max_y do
111836: LD_ADDR_VAR 0 12
111840: PUSH
111841: DOUBLE
111842: LD_VAR 0 8
111846: DEC
111847: ST_TO_ADDR
111848: LD_VAR 0 10
111852: PUSH
111853: FOR_TO
111854: IFFALSE 111947
// begin if not ValidHex ( _x , _y ) then
111856: LD_VAR 0 11
111860: PPUSH
111861: LD_VAR 0 12
111865: PPUSH
111866: CALL_OW 488
111870: NOT
111871: IFFALSE 111875
// continue ;
111873: GO 111853
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
111875: LD_VAR 0 11
111879: PPUSH
111880: LD_VAR 0 12
111884: PPUSH
111885: CALL_OW 351
111889: PUSH
111890: LD_VAR 0 11
111894: PPUSH
111895: LD_VAR 0 12
111899: PPUSH
111900: CALL_OW 554
111904: AND
111905: IFFALSE 111945
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
111907: LD_ADDR_VAR 0 13
111911: PUSH
111912: LD_VAR 0 13
111916: PPUSH
111917: LD_VAR 0 13
111921: PUSH
111922: LD_INT 1
111924: PLUS
111925: PPUSH
111926: LD_VAR 0 11
111930: PUSH
111931: LD_VAR 0 12
111935: PUSH
111936: EMPTY
111937: LIST
111938: LIST
111939: PPUSH
111940: CALL_OW 2
111944: ST_TO_ADDR
// end ;
111945: GO 111853
111947: POP
111948: POP
111949: GO 111833
111951: POP
111952: POP
// if not list then
111953: LD_VAR 0 13
111957: NOT
111958: IFFALSE 111962
// exit ;
111960: GO 112033
// for i in list do
111962: LD_ADDR_VAR 0 6
111966: PUSH
111967: LD_VAR 0 13
111971: PUSH
111972: FOR_IN
111973: IFFALSE 112031
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
111975: LD_VAR 0 1
111979: PPUSH
111980: LD_STRING M
111982: PUSH
111983: LD_VAR 0 6
111987: PUSH
111988: LD_INT 1
111990: ARRAY
111991: PUSH
111992: LD_VAR 0 6
111996: PUSH
111997: LD_INT 2
111999: ARRAY
112000: PUSH
112001: LD_INT 0
112003: PUSH
112004: LD_INT 0
112006: PUSH
112007: LD_INT 0
112009: PUSH
112010: LD_INT 0
112012: PUSH
112013: EMPTY
112014: LIST
112015: LIST
112016: LIST
112017: LIST
112018: LIST
112019: LIST
112020: LIST
112021: PUSH
112022: EMPTY
112023: LIST
112024: PPUSH
112025: CALL_OW 447
112029: GO 111972
112031: POP
112032: POP
// end ;
112033: LD_VAR 0 5
112037: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
112038: LD_INT 0
112040: PPUSH
112041: PPUSH
112042: PPUSH
112043: PPUSH
112044: PPUSH
112045: PPUSH
112046: PPUSH
112047: PPUSH
112048: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
112049: LD_VAR 0 1
112053: PPUSH
112054: CALL_OW 302
112058: NOT
112059: PUSH
112060: LD_VAR 0 2
112064: PPUSH
112065: LD_VAR 0 3
112069: PPUSH
112070: CALL_OW 488
112074: NOT
112075: OR
112076: PUSH
112077: LD_VAR 0 4
112081: NOT
112082: OR
112083: IFFALSE 112087
// exit ;
112085: GO 112435
// list := [ ] ;
112087: LD_ADDR_VAR 0 13
112091: PUSH
112092: EMPTY
112093: ST_TO_ADDR
// if x - r < 0 then
112094: LD_VAR 0 2
112098: PUSH
112099: LD_VAR 0 4
112103: MINUS
112104: PUSH
112105: LD_INT 0
112107: LESS
112108: IFFALSE 112120
// min_x := 0 else
112110: LD_ADDR_VAR 0 7
112114: PUSH
112115: LD_INT 0
112117: ST_TO_ADDR
112118: GO 112136
// min_x := x - r ;
112120: LD_ADDR_VAR 0 7
112124: PUSH
112125: LD_VAR 0 2
112129: PUSH
112130: LD_VAR 0 4
112134: MINUS
112135: ST_TO_ADDR
// if y - r < 0 then
112136: LD_VAR 0 3
112140: PUSH
112141: LD_VAR 0 4
112145: MINUS
112146: PUSH
112147: LD_INT 0
112149: LESS
112150: IFFALSE 112162
// min_y := 0 else
112152: LD_ADDR_VAR 0 8
112156: PUSH
112157: LD_INT 0
112159: ST_TO_ADDR
112160: GO 112178
// min_y := y - r ;
112162: LD_ADDR_VAR 0 8
112166: PUSH
112167: LD_VAR 0 3
112171: PUSH
112172: LD_VAR 0 4
112176: MINUS
112177: ST_TO_ADDR
// max_x := x + r ;
112178: LD_ADDR_VAR 0 9
112182: PUSH
112183: LD_VAR 0 2
112187: PUSH
112188: LD_VAR 0 4
112192: PLUS
112193: ST_TO_ADDR
// max_y := y + r ;
112194: LD_ADDR_VAR 0 10
112198: PUSH
112199: LD_VAR 0 3
112203: PUSH
112204: LD_VAR 0 4
112208: PLUS
112209: ST_TO_ADDR
// for _x = min_x to max_x do
112210: LD_ADDR_VAR 0 11
112214: PUSH
112215: DOUBLE
112216: LD_VAR 0 7
112220: DEC
112221: ST_TO_ADDR
112222: LD_VAR 0 9
112226: PUSH
112227: FOR_TO
112228: IFFALSE 112345
// for _y = min_y to max_y do
112230: LD_ADDR_VAR 0 12
112234: PUSH
112235: DOUBLE
112236: LD_VAR 0 8
112240: DEC
112241: ST_TO_ADDR
112242: LD_VAR 0 10
112246: PUSH
112247: FOR_TO
112248: IFFALSE 112341
// begin if not ValidHex ( _x , _y ) then
112250: LD_VAR 0 11
112254: PPUSH
112255: LD_VAR 0 12
112259: PPUSH
112260: CALL_OW 488
112264: NOT
112265: IFFALSE 112269
// continue ;
112267: GO 112247
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
112269: LD_VAR 0 11
112273: PPUSH
112274: LD_VAR 0 12
112278: PPUSH
112279: CALL_OW 351
112283: PUSH
112284: LD_VAR 0 11
112288: PPUSH
112289: LD_VAR 0 12
112293: PPUSH
112294: CALL_OW 554
112298: AND
112299: IFFALSE 112339
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
112301: LD_ADDR_VAR 0 13
112305: PUSH
112306: LD_VAR 0 13
112310: PPUSH
112311: LD_VAR 0 13
112315: PUSH
112316: LD_INT 1
112318: PLUS
112319: PPUSH
112320: LD_VAR 0 11
112324: PUSH
112325: LD_VAR 0 12
112329: PUSH
112330: EMPTY
112331: LIST
112332: LIST
112333: PPUSH
112334: CALL_OW 2
112338: ST_TO_ADDR
// end ;
112339: GO 112247
112341: POP
112342: POP
112343: GO 112227
112345: POP
112346: POP
// if not list then
112347: LD_VAR 0 13
112351: NOT
112352: IFFALSE 112356
// exit ;
112354: GO 112435
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
112356: LD_ADDR_VAR 0 13
112360: PUSH
112361: LD_VAR 0 1
112365: PPUSH
112366: LD_VAR 0 13
112370: PPUSH
112371: LD_INT 1
112373: PPUSH
112374: LD_INT 1
112376: PPUSH
112377: CALL 58353 0 4
112381: ST_TO_ADDR
// ComStop ( flame ) ;
112382: LD_VAR 0 1
112386: PPUSH
112387: CALL_OW 141
// for i in list do
112391: LD_ADDR_VAR 0 6
112395: PUSH
112396: LD_VAR 0 13
112400: PUSH
112401: FOR_IN
112402: IFFALSE 112433
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
112404: LD_VAR 0 1
112408: PPUSH
112409: LD_VAR 0 6
112413: PUSH
112414: LD_INT 1
112416: ARRAY
112417: PPUSH
112418: LD_VAR 0 6
112422: PUSH
112423: LD_INT 2
112425: ARRAY
112426: PPUSH
112427: CALL_OW 176
112431: GO 112401
112433: POP
112434: POP
// end ;
112435: LD_VAR 0 5
112439: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
112440: LD_EXP 185
112444: NOT
112445: IFFALSE 112495
112447: GO 112449
112449: DISABLE
// begin initHack := true ;
112450: LD_ADDR_EXP 185
112454: PUSH
112455: LD_INT 1
112457: ST_TO_ADDR
// hackTanks := [ ] ;
112458: LD_ADDR_EXP 186
112462: PUSH
112463: EMPTY
112464: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
112465: LD_ADDR_EXP 187
112469: PUSH
112470: EMPTY
112471: ST_TO_ADDR
// hackLimit := 3 ;
112472: LD_ADDR_EXP 188
112476: PUSH
112477: LD_INT 3
112479: ST_TO_ADDR
// hackDist := 12 ;
112480: LD_ADDR_EXP 189
112484: PUSH
112485: LD_INT 12
112487: ST_TO_ADDR
// hackCounter := [ ] ;
112488: LD_ADDR_EXP 190
112492: PUSH
112493: EMPTY
112494: ST_TO_ADDR
// end ;
112495: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
112496: LD_EXP 185
112500: PUSH
112501: LD_INT 34
112503: PUSH
112504: LD_INT 99
112506: PUSH
112507: EMPTY
112508: LIST
112509: LIST
112510: PPUSH
112511: CALL_OW 69
112515: AND
112516: IFFALSE 112769
112518: GO 112520
112520: DISABLE
112521: LD_INT 0
112523: PPUSH
112524: PPUSH
// begin enable ;
112525: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
112526: LD_ADDR_VAR 0 1
112530: PUSH
112531: LD_INT 34
112533: PUSH
112534: LD_INT 99
112536: PUSH
112537: EMPTY
112538: LIST
112539: LIST
112540: PPUSH
112541: CALL_OW 69
112545: PUSH
112546: FOR_IN
112547: IFFALSE 112767
// begin if not i in hackTanks then
112549: LD_VAR 0 1
112553: PUSH
112554: LD_EXP 186
112558: IN
112559: NOT
112560: IFFALSE 112643
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
112562: LD_ADDR_EXP 186
112566: PUSH
112567: LD_EXP 186
112571: PPUSH
112572: LD_EXP 186
112576: PUSH
112577: LD_INT 1
112579: PLUS
112580: PPUSH
112581: LD_VAR 0 1
112585: PPUSH
112586: CALL_OW 1
112590: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
112591: LD_ADDR_EXP 187
112595: PUSH
112596: LD_EXP 187
112600: PPUSH
112601: LD_EXP 187
112605: PUSH
112606: LD_INT 1
112608: PLUS
112609: PPUSH
112610: EMPTY
112611: PPUSH
112612: CALL_OW 1
112616: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
112617: LD_ADDR_EXP 190
112621: PUSH
112622: LD_EXP 190
112626: PPUSH
112627: LD_EXP 190
112631: PUSH
112632: LD_INT 1
112634: PLUS
112635: PPUSH
112636: EMPTY
112637: PPUSH
112638: CALL_OW 1
112642: ST_TO_ADDR
// end ; if not IsOk ( i ) then
112643: LD_VAR 0 1
112647: PPUSH
112648: CALL_OW 302
112652: NOT
112653: IFFALSE 112666
// begin HackUnlinkAll ( i ) ;
112655: LD_VAR 0 1
112659: PPUSH
112660: CALL 112772 0 1
// continue ;
112664: GO 112546
// end ; HackCheckCapturedStatus ( i ) ;
112666: LD_VAR 0 1
112670: PPUSH
112671: CALL 113215 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
112675: LD_ADDR_VAR 0 2
112679: PUSH
112680: LD_INT 81
112682: PUSH
112683: LD_VAR 0 1
112687: PPUSH
112688: CALL_OW 255
112692: PUSH
112693: EMPTY
112694: LIST
112695: LIST
112696: PUSH
112697: LD_INT 33
112699: PUSH
112700: LD_INT 3
112702: PUSH
112703: EMPTY
112704: LIST
112705: LIST
112706: PUSH
112707: LD_INT 91
112709: PUSH
112710: LD_VAR 0 1
112714: PUSH
112715: LD_EXP 189
112719: PUSH
112720: EMPTY
112721: LIST
112722: LIST
112723: LIST
112724: PUSH
112725: LD_INT 50
112727: PUSH
112728: EMPTY
112729: LIST
112730: PUSH
112731: EMPTY
112732: LIST
112733: LIST
112734: LIST
112735: LIST
112736: PPUSH
112737: CALL_OW 69
112741: ST_TO_ADDR
// if not tmp then
112742: LD_VAR 0 2
112746: NOT
112747: IFFALSE 112751
// continue ;
112749: GO 112546
// HackLink ( i , tmp ) ;
112751: LD_VAR 0 1
112755: PPUSH
112756: LD_VAR 0 2
112760: PPUSH
112761: CALL 112908 0 2
// end ;
112765: GO 112546
112767: POP
112768: POP
// end ;
112769: PPOPN 2
112771: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
112772: LD_INT 0
112774: PPUSH
112775: PPUSH
112776: PPUSH
// if not hack in hackTanks then
112777: LD_VAR 0 1
112781: PUSH
112782: LD_EXP 186
112786: IN
112787: NOT
112788: IFFALSE 112792
// exit ;
112790: GO 112903
// index := GetElementIndex ( hackTanks , hack ) ;
112792: LD_ADDR_VAR 0 4
112796: PUSH
112797: LD_EXP 186
112801: PPUSH
112802: LD_VAR 0 1
112806: PPUSH
112807: CALL 57650 0 2
112811: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
112812: LD_EXP 187
112816: PUSH
112817: LD_VAR 0 4
112821: ARRAY
112822: IFFALSE 112903
// begin for i in hackTanksCaptured [ index ] do
112824: LD_ADDR_VAR 0 3
112828: PUSH
112829: LD_EXP 187
112833: PUSH
112834: LD_VAR 0 4
112838: ARRAY
112839: PUSH
112840: FOR_IN
112841: IFFALSE 112867
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
112843: LD_VAR 0 3
112847: PUSH
112848: LD_INT 1
112850: ARRAY
112851: PPUSH
112852: LD_VAR 0 3
112856: PUSH
112857: LD_INT 2
112859: ARRAY
112860: PPUSH
112861: CALL_OW 235
112865: GO 112840
112867: POP
112868: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
112869: LD_ADDR_EXP 187
112873: PUSH
112874: LD_EXP 187
112878: PPUSH
112879: LD_VAR 0 4
112883: PPUSH
112884: EMPTY
112885: PPUSH
112886: CALL_OW 1
112890: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
112891: LD_VAR 0 1
112895: PPUSH
112896: LD_INT 0
112898: PPUSH
112899: CALL_OW 505
// end ; end ;
112903: LD_VAR 0 2
112907: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
112908: LD_INT 0
112910: PPUSH
112911: PPUSH
112912: PPUSH
// if not hack in hackTanks or not vehicles then
112913: LD_VAR 0 1
112917: PUSH
112918: LD_EXP 186
112922: IN
112923: NOT
112924: PUSH
112925: LD_VAR 0 2
112929: NOT
112930: OR
112931: IFFALSE 112935
// exit ;
112933: GO 113210
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
112935: LD_ADDR_VAR 0 2
112939: PUSH
112940: LD_VAR 0 1
112944: PPUSH
112945: LD_VAR 0 2
112949: PPUSH
112950: LD_INT 1
112952: PPUSH
112953: LD_INT 1
112955: PPUSH
112956: CALL 58300 0 4
112960: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
112961: LD_ADDR_VAR 0 5
112965: PUSH
112966: LD_EXP 186
112970: PPUSH
112971: LD_VAR 0 1
112975: PPUSH
112976: CALL 57650 0 2
112980: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
112981: LD_EXP 187
112985: PUSH
112986: LD_VAR 0 5
112990: ARRAY
112991: PUSH
112992: LD_EXP 188
112996: LESS
112997: IFFALSE 113186
// begin for i := 1 to vehicles do
112999: LD_ADDR_VAR 0 4
113003: PUSH
113004: DOUBLE
113005: LD_INT 1
113007: DEC
113008: ST_TO_ADDR
113009: LD_VAR 0 2
113013: PUSH
113014: FOR_TO
113015: IFFALSE 113184
// begin if hackTanksCaptured [ index ] = hackLimit then
113017: LD_EXP 187
113021: PUSH
113022: LD_VAR 0 5
113026: ARRAY
113027: PUSH
113028: LD_EXP 188
113032: EQUAL
113033: IFFALSE 113037
// break ;
113035: GO 113184
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
113037: LD_ADDR_EXP 190
113041: PUSH
113042: LD_EXP 190
113046: PPUSH
113047: LD_VAR 0 5
113051: PPUSH
113052: LD_EXP 190
113056: PUSH
113057: LD_VAR 0 5
113061: ARRAY
113062: PUSH
113063: LD_INT 1
113065: PLUS
113066: PPUSH
113067: CALL_OW 1
113071: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
113072: LD_ADDR_EXP 187
113076: PUSH
113077: LD_EXP 187
113081: PPUSH
113082: LD_VAR 0 5
113086: PUSH
113087: LD_EXP 187
113091: PUSH
113092: LD_VAR 0 5
113096: ARRAY
113097: PUSH
113098: LD_INT 1
113100: PLUS
113101: PUSH
113102: EMPTY
113103: LIST
113104: LIST
113105: PPUSH
113106: LD_VAR 0 2
113110: PUSH
113111: LD_VAR 0 4
113115: ARRAY
113116: PUSH
113117: LD_VAR 0 2
113121: PUSH
113122: LD_VAR 0 4
113126: ARRAY
113127: PPUSH
113128: CALL_OW 255
113132: PUSH
113133: EMPTY
113134: LIST
113135: LIST
113136: PPUSH
113137: CALL 57865 0 3
113141: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
113142: LD_VAR 0 2
113146: PUSH
113147: LD_VAR 0 4
113151: ARRAY
113152: PPUSH
113153: LD_VAR 0 1
113157: PPUSH
113158: CALL_OW 255
113162: PPUSH
113163: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
113167: LD_VAR 0 2
113171: PUSH
113172: LD_VAR 0 4
113176: ARRAY
113177: PPUSH
113178: CALL_OW 141
// end ;
113182: GO 113014
113184: POP
113185: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
113186: LD_VAR 0 1
113190: PPUSH
113191: LD_EXP 187
113195: PUSH
113196: LD_VAR 0 5
113200: ARRAY
113201: PUSH
113202: LD_INT 0
113204: PLUS
113205: PPUSH
113206: CALL_OW 505
// end ;
113210: LD_VAR 0 3
113214: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
113215: LD_INT 0
113217: PPUSH
113218: PPUSH
113219: PPUSH
113220: PPUSH
// if not hack in hackTanks then
113221: LD_VAR 0 1
113225: PUSH
113226: LD_EXP 186
113230: IN
113231: NOT
113232: IFFALSE 113236
// exit ;
113234: GO 113476
// index := GetElementIndex ( hackTanks , hack ) ;
113236: LD_ADDR_VAR 0 4
113240: PUSH
113241: LD_EXP 186
113245: PPUSH
113246: LD_VAR 0 1
113250: PPUSH
113251: CALL 57650 0 2
113255: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
113256: LD_ADDR_VAR 0 3
113260: PUSH
113261: DOUBLE
113262: LD_EXP 187
113266: PUSH
113267: LD_VAR 0 4
113271: ARRAY
113272: INC
113273: ST_TO_ADDR
113274: LD_INT 1
113276: PUSH
113277: FOR_DOWNTO
113278: IFFALSE 113450
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
113280: LD_ADDR_VAR 0 5
113284: PUSH
113285: LD_EXP 187
113289: PUSH
113290: LD_VAR 0 4
113294: ARRAY
113295: PUSH
113296: LD_VAR 0 3
113300: ARRAY
113301: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
113302: LD_VAR 0 5
113306: PUSH
113307: LD_INT 1
113309: ARRAY
113310: PPUSH
113311: CALL_OW 302
113315: NOT
113316: PUSH
113317: LD_VAR 0 5
113321: PUSH
113322: LD_INT 1
113324: ARRAY
113325: PPUSH
113326: CALL_OW 255
113330: PUSH
113331: LD_VAR 0 1
113335: PPUSH
113336: CALL_OW 255
113340: NONEQUAL
113341: OR
113342: IFFALSE 113448
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
113344: LD_VAR 0 5
113348: PUSH
113349: LD_INT 1
113351: ARRAY
113352: PPUSH
113353: CALL_OW 305
113357: PUSH
113358: LD_VAR 0 5
113362: PUSH
113363: LD_INT 1
113365: ARRAY
113366: PPUSH
113367: CALL_OW 255
113371: PUSH
113372: LD_VAR 0 1
113376: PPUSH
113377: CALL_OW 255
113381: EQUAL
113382: AND
113383: IFFALSE 113407
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
113385: LD_VAR 0 5
113389: PUSH
113390: LD_INT 1
113392: ARRAY
113393: PPUSH
113394: LD_VAR 0 5
113398: PUSH
113399: LD_INT 2
113401: ARRAY
113402: PPUSH
113403: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
113407: LD_ADDR_EXP 187
113411: PUSH
113412: LD_EXP 187
113416: PPUSH
113417: LD_VAR 0 4
113421: PPUSH
113422: LD_EXP 187
113426: PUSH
113427: LD_VAR 0 4
113431: ARRAY
113432: PPUSH
113433: LD_VAR 0 3
113437: PPUSH
113438: CALL_OW 3
113442: PPUSH
113443: CALL_OW 1
113447: ST_TO_ADDR
// end ; end ;
113448: GO 113277
113450: POP
113451: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
113452: LD_VAR 0 1
113456: PPUSH
113457: LD_EXP 187
113461: PUSH
113462: LD_VAR 0 4
113466: ARRAY
113467: PUSH
113468: LD_INT 0
113470: PLUS
113471: PPUSH
113472: CALL_OW 505
// end ;
113476: LD_VAR 0 2
113480: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
113481: LD_INT 0
113483: PPUSH
113484: PPUSH
113485: PPUSH
113486: PPUSH
// if not hack in hackTanks then
113487: LD_VAR 0 1
113491: PUSH
113492: LD_EXP 186
113496: IN
113497: NOT
113498: IFFALSE 113502
// exit ;
113500: GO 113587
// index := GetElementIndex ( hackTanks , hack ) ;
113502: LD_ADDR_VAR 0 5
113506: PUSH
113507: LD_EXP 186
113511: PPUSH
113512: LD_VAR 0 1
113516: PPUSH
113517: CALL 57650 0 2
113521: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
113522: LD_ADDR_VAR 0 4
113526: PUSH
113527: DOUBLE
113528: LD_INT 1
113530: DEC
113531: ST_TO_ADDR
113532: LD_EXP 187
113536: PUSH
113537: LD_VAR 0 5
113541: ARRAY
113542: PUSH
113543: FOR_TO
113544: IFFALSE 113585
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
113546: LD_EXP 187
113550: PUSH
113551: LD_VAR 0 5
113555: ARRAY
113556: PUSH
113557: LD_VAR 0 4
113561: ARRAY
113562: PUSH
113563: LD_INT 1
113565: ARRAY
113566: PUSH
113567: LD_VAR 0 2
113571: EQUAL
113572: IFFALSE 113583
// KillUnit ( vehicle ) ;
113574: LD_VAR 0 2
113578: PPUSH
113579: CALL_OW 66
113583: GO 113543
113585: POP
113586: POP
// end ;
113587: LD_VAR 0 3
113591: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
113592: LD_EXP 191
113596: NOT
113597: IFFALSE 113632
113599: GO 113601
113601: DISABLE
// begin initMiner := true ;
113602: LD_ADDR_EXP 191
113606: PUSH
113607: LD_INT 1
113609: ST_TO_ADDR
// minersList := [ ] ;
113610: LD_ADDR_EXP 192
113614: PUSH
113615: EMPTY
113616: ST_TO_ADDR
// minerMinesList := [ ] ;
113617: LD_ADDR_EXP 193
113621: PUSH
113622: EMPTY
113623: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
113624: LD_ADDR_EXP 194
113628: PUSH
113629: LD_INT 5
113631: ST_TO_ADDR
// end ;
113632: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
113633: LD_EXP 191
113637: PUSH
113638: LD_INT 34
113640: PUSH
113641: LD_INT 81
113643: PUSH
113644: EMPTY
113645: LIST
113646: LIST
113647: PPUSH
113648: CALL_OW 69
113652: AND
113653: IFFALSE 114114
113655: GO 113657
113657: DISABLE
113658: LD_INT 0
113660: PPUSH
113661: PPUSH
113662: PPUSH
113663: PPUSH
// begin enable ;
113664: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
113665: LD_ADDR_VAR 0 1
113669: PUSH
113670: LD_INT 34
113672: PUSH
113673: LD_INT 81
113675: PUSH
113676: EMPTY
113677: LIST
113678: LIST
113679: PPUSH
113680: CALL_OW 69
113684: PUSH
113685: FOR_IN
113686: IFFALSE 113758
// begin if not i in minersList then
113688: LD_VAR 0 1
113692: PUSH
113693: LD_EXP 192
113697: IN
113698: NOT
113699: IFFALSE 113756
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
113701: LD_ADDR_EXP 192
113705: PUSH
113706: LD_EXP 192
113710: PPUSH
113711: LD_EXP 192
113715: PUSH
113716: LD_INT 1
113718: PLUS
113719: PPUSH
113720: LD_VAR 0 1
113724: PPUSH
113725: CALL_OW 1
113729: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
113730: LD_ADDR_EXP 193
113734: PUSH
113735: LD_EXP 193
113739: PPUSH
113740: LD_EXP 193
113744: PUSH
113745: LD_INT 1
113747: PLUS
113748: PPUSH
113749: EMPTY
113750: PPUSH
113751: CALL_OW 1
113755: ST_TO_ADDR
// end end ;
113756: GO 113685
113758: POP
113759: POP
// for i := minerMinesList downto 1 do
113760: LD_ADDR_VAR 0 1
113764: PUSH
113765: DOUBLE
113766: LD_EXP 193
113770: INC
113771: ST_TO_ADDR
113772: LD_INT 1
113774: PUSH
113775: FOR_DOWNTO
113776: IFFALSE 114112
// begin if IsLive ( minersList [ i ] ) then
113778: LD_EXP 192
113782: PUSH
113783: LD_VAR 0 1
113787: ARRAY
113788: PPUSH
113789: CALL_OW 300
113793: IFFALSE 113821
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
113795: LD_EXP 192
113799: PUSH
113800: LD_VAR 0 1
113804: ARRAY
113805: PPUSH
113806: LD_EXP 193
113810: PUSH
113811: LD_VAR 0 1
113815: ARRAY
113816: PPUSH
113817: CALL_OW 505
// if not minerMinesList [ i ] then
113821: LD_EXP 193
113825: PUSH
113826: LD_VAR 0 1
113830: ARRAY
113831: NOT
113832: IFFALSE 113836
// continue ;
113834: GO 113775
// for j := minerMinesList [ i ] downto 1 do
113836: LD_ADDR_VAR 0 2
113840: PUSH
113841: DOUBLE
113842: LD_EXP 193
113846: PUSH
113847: LD_VAR 0 1
113851: ARRAY
113852: INC
113853: ST_TO_ADDR
113854: LD_INT 1
113856: PUSH
113857: FOR_DOWNTO
113858: IFFALSE 114108
// begin side := GetSide ( minersList [ i ] ) ;
113860: LD_ADDR_VAR 0 3
113864: PUSH
113865: LD_EXP 192
113869: PUSH
113870: LD_VAR 0 1
113874: ARRAY
113875: PPUSH
113876: CALL_OW 255
113880: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
113881: LD_ADDR_VAR 0 4
113885: PUSH
113886: LD_EXP 193
113890: PUSH
113891: LD_VAR 0 1
113895: ARRAY
113896: PUSH
113897: LD_VAR 0 2
113901: ARRAY
113902: PUSH
113903: LD_INT 1
113905: ARRAY
113906: PPUSH
113907: LD_EXP 193
113911: PUSH
113912: LD_VAR 0 1
113916: ARRAY
113917: PUSH
113918: LD_VAR 0 2
113922: ARRAY
113923: PUSH
113924: LD_INT 2
113926: ARRAY
113927: PPUSH
113928: CALL_OW 428
113932: ST_TO_ADDR
// if not tmp then
113933: LD_VAR 0 4
113937: NOT
113938: IFFALSE 113942
// continue ;
113940: GO 113857
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
113942: LD_VAR 0 4
113946: PUSH
113947: LD_INT 81
113949: PUSH
113950: LD_VAR 0 3
113954: PUSH
113955: EMPTY
113956: LIST
113957: LIST
113958: PPUSH
113959: CALL_OW 69
113963: IN
113964: PUSH
113965: LD_EXP 193
113969: PUSH
113970: LD_VAR 0 1
113974: ARRAY
113975: PUSH
113976: LD_VAR 0 2
113980: ARRAY
113981: PUSH
113982: LD_INT 1
113984: ARRAY
113985: PPUSH
113986: LD_EXP 193
113990: PUSH
113991: LD_VAR 0 1
113995: ARRAY
113996: PUSH
113997: LD_VAR 0 2
114001: ARRAY
114002: PUSH
114003: LD_INT 2
114005: ARRAY
114006: PPUSH
114007: CALL_OW 458
114011: AND
114012: IFFALSE 114106
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
114014: LD_EXP 193
114018: PUSH
114019: LD_VAR 0 1
114023: ARRAY
114024: PUSH
114025: LD_VAR 0 2
114029: ARRAY
114030: PUSH
114031: LD_INT 1
114033: ARRAY
114034: PPUSH
114035: LD_EXP 193
114039: PUSH
114040: LD_VAR 0 1
114044: ARRAY
114045: PUSH
114046: LD_VAR 0 2
114050: ARRAY
114051: PUSH
114052: LD_INT 2
114054: ARRAY
114055: PPUSH
114056: LD_VAR 0 3
114060: PPUSH
114061: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
114065: LD_ADDR_EXP 193
114069: PUSH
114070: LD_EXP 193
114074: PPUSH
114075: LD_VAR 0 1
114079: PPUSH
114080: LD_EXP 193
114084: PUSH
114085: LD_VAR 0 1
114089: ARRAY
114090: PPUSH
114091: LD_VAR 0 2
114095: PPUSH
114096: CALL_OW 3
114100: PPUSH
114101: CALL_OW 1
114105: ST_TO_ADDR
// end ; end ;
114106: GO 113857
114108: POP
114109: POP
// end ;
114110: GO 113775
114112: POP
114113: POP
// end ;
114114: PPOPN 4
114116: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
114117: LD_INT 0
114119: PPUSH
114120: PPUSH
// result := false ;
114121: LD_ADDR_VAR 0 4
114125: PUSH
114126: LD_INT 0
114128: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
114129: LD_VAR 0 1
114133: PPUSH
114134: CALL_OW 264
114138: PUSH
114139: LD_INT 81
114141: EQUAL
114142: NOT
114143: IFFALSE 114147
// exit ;
114145: GO 114387
// index := GetElementIndex ( minersList , unit ) ;
114147: LD_ADDR_VAR 0 5
114151: PUSH
114152: LD_EXP 192
114156: PPUSH
114157: LD_VAR 0 1
114161: PPUSH
114162: CALL 57650 0 2
114166: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
114167: LD_EXP 193
114171: PUSH
114172: LD_VAR 0 5
114176: ARRAY
114177: PUSH
114178: LD_EXP 194
114182: GREATEREQUAL
114183: IFFALSE 114187
// exit ;
114185: GO 114387
// ComMoveXY ( unit , x , y ) ;
114187: LD_VAR 0 1
114191: PPUSH
114192: LD_VAR 0 2
114196: PPUSH
114197: LD_VAR 0 3
114201: PPUSH
114202: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
114206: LD_INT 35
114208: PPUSH
114209: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
114213: LD_VAR 0 1
114217: PPUSH
114218: LD_VAR 0 2
114222: PPUSH
114223: LD_VAR 0 3
114227: PPUSH
114228: CALL 89402 0 3
114232: NOT
114233: PUSH
114234: LD_VAR 0 1
114238: PPUSH
114239: CALL_OW 314
114243: AND
114244: IFFALSE 114248
// exit ;
114246: GO 114387
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
114248: LD_VAR 0 2
114252: PPUSH
114253: LD_VAR 0 3
114257: PPUSH
114258: CALL_OW 428
114262: PUSH
114263: LD_VAR 0 1
114267: EQUAL
114268: PUSH
114269: LD_VAR 0 1
114273: PPUSH
114274: CALL_OW 314
114278: NOT
114279: AND
114280: IFFALSE 114206
// PlaySoundXY ( x , y , PlantMine ) ;
114282: LD_VAR 0 2
114286: PPUSH
114287: LD_VAR 0 3
114291: PPUSH
114292: LD_STRING PlantMine
114294: PPUSH
114295: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
114299: LD_VAR 0 2
114303: PPUSH
114304: LD_VAR 0 3
114308: PPUSH
114309: LD_VAR 0 1
114313: PPUSH
114314: CALL_OW 255
114318: PPUSH
114319: LD_INT 0
114321: PPUSH
114322: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
114326: LD_ADDR_EXP 193
114330: PUSH
114331: LD_EXP 193
114335: PPUSH
114336: LD_VAR 0 5
114340: PUSH
114341: LD_EXP 193
114345: PUSH
114346: LD_VAR 0 5
114350: ARRAY
114351: PUSH
114352: LD_INT 1
114354: PLUS
114355: PUSH
114356: EMPTY
114357: LIST
114358: LIST
114359: PPUSH
114360: LD_VAR 0 2
114364: PUSH
114365: LD_VAR 0 3
114369: PUSH
114370: EMPTY
114371: LIST
114372: LIST
114373: PPUSH
114374: CALL 57865 0 3
114378: ST_TO_ADDR
// result := true ;
114379: LD_ADDR_VAR 0 4
114383: PUSH
114384: LD_INT 1
114386: ST_TO_ADDR
// end ;
114387: LD_VAR 0 4
114391: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
114392: LD_INT 0
114394: PPUSH
114395: PPUSH
114396: PPUSH
// if not unit in minersList then
114397: LD_VAR 0 1
114401: PUSH
114402: LD_EXP 192
114406: IN
114407: NOT
114408: IFFALSE 114412
// exit ;
114410: GO 114804
// index := GetElementIndex ( minersList , unit ) ;
114412: LD_ADDR_VAR 0 6
114416: PUSH
114417: LD_EXP 192
114421: PPUSH
114422: LD_VAR 0 1
114426: PPUSH
114427: CALL 57650 0 2
114431: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
114432: LD_ADDR_VAR 0 5
114436: PUSH
114437: DOUBLE
114438: LD_EXP 193
114442: PUSH
114443: LD_VAR 0 6
114447: ARRAY
114448: INC
114449: ST_TO_ADDR
114450: LD_INT 1
114452: PUSH
114453: FOR_DOWNTO
114454: IFFALSE 114615
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
114456: LD_EXP 193
114460: PUSH
114461: LD_VAR 0 6
114465: ARRAY
114466: PUSH
114467: LD_VAR 0 5
114471: ARRAY
114472: PUSH
114473: LD_INT 1
114475: ARRAY
114476: PUSH
114477: LD_VAR 0 2
114481: EQUAL
114482: PUSH
114483: LD_EXP 193
114487: PUSH
114488: LD_VAR 0 6
114492: ARRAY
114493: PUSH
114494: LD_VAR 0 5
114498: ARRAY
114499: PUSH
114500: LD_INT 2
114502: ARRAY
114503: PUSH
114504: LD_VAR 0 3
114508: EQUAL
114509: AND
114510: IFFALSE 114613
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
114512: LD_EXP 193
114516: PUSH
114517: LD_VAR 0 6
114521: ARRAY
114522: PUSH
114523: LD_VAR 0 5
114527: ARRAY
114528: PUSH
114529: LD_INT 1
114531: ARRAY
114532: PPUSH
114533: LD_EXP 193
114537: PUSH
114538: LD_VAR 0 6
114542: ARRAY
114543: PUSH
114544: LD_VAR 0 5
114548: ARRAY
114549: PUSH
114550: LD_INT 2
114552: ARRAY
114553: PPUSH
114554: LD_VAR 0 1
114558: PPUSH
114559: CALL_OW 255
114563: PPUSH
114564: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
114568: LD_ADDR_EXP 193
114572: PUSH
114573: LD_EXP 193
114577: PPUSH
114578: LD_VAR 0 6
114582: PPUSH
114583: LD_EXP 193
114587: PUSH
114588: LD_VAR 0 6
114592: ARRAY
114593: PPUSH
114594: LD_VAR 0 5
114598: PPUSH
114599: CALL_OW 3
114603: PPUSH
114604: CALL_OW 1
114608: ST_TO_ADDR
// exit ;
114609: POP
114610: POP
114611: GO 114804
// end ; end ;
114613: GO 114453
114615: POP
114616: POP
// for i := minerMinesList [ index ] downto 1 do
114617: LD_ADDR_VAR 0 5
114621: PUSH
114622: DOUBLE
114623: LD_EXP 193
114627: PUSH
114628: LD_VAR 0 6
114632: ARRAY
114633: INC
114634: ST_TO_ADDR
114635: LD_INT 1
114637: PUSH
114638: FOR_DOWNTO
114639: IFFALSE 114802
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
114641: LD_EXP 193
114645: PUSH
114646: LD_VAR 0 6
114650: ARRAY
114651: PUSH
114652: LD_VAR 0 5
114656: ARRAY
114657: PUSH
114658: LD_INT 1
114660: ARRAY
114661: PPUSH
114662: LD_EXP 193
114666: PUSH
114667: LD_VAR 0 6
114671: ARRAY
114672: PUSH
114673: LD_VAR 0 5
114677: ARRAY
114678: PUSH
114679: LD_INT 2
114681: ARRAY
114682: PPUSH
114683: LD_VAR 0 2
114687: PPUSH
114688: LD_VAR 0 3
114692: PPUSH
114693: CALL_OW 298
114697: PUSH
114698: LD_INT 6
114700: LESS
114701: IFFALSE 114800
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
114703: LD_EXP 193
114707: PUSH
114708: LD_VAR 0 6
114712: ARRAY
114713: PUSH
114714: LD_VAR 0 5
114718: ARRAY
114719: PUSH
114720: LD_INT 1
114722: ARRAY
114723: PPUSH
114724: LD_EXP 193
114728: PUSH
114729: LD_VAR 0 6
114733: ARRAY
114734: PUSH
114735: LD_VAR 0 5
114739: ARRAY
114740: PUSH
114741: LD_INT 2
114743: ARRAY
114744: PPUSH
114745: LD_VAR 0 1
114749: PPUSH
114750: CALL_OW 255
114754: PPUSH
114755: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
114759: LD_ADDR_EXP 193
114763: PUSH
114764: LD_EXP 193
114768: PPUSH
114769: LD_VAR 0 6
114773: PPUSH
114774: LD_EXP 193
114778: PUSH
114779: LD_VAR 0 6
114783: ARRAY
114784: PPUSH
114785: LD_VAR 0 5
114789: PPUSH
114790: CALL_OW 3
114794: PPUSH
114795: CALL_OW 1
114799: ST_TO_ADDR
// end ; end ;
114800: GO 114638
114802: POP
114803: POP
// end ;
114804: LD_VAR 0 4
114808: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
114809: LD_INT 0
114811: PPUSH
114812: PPUSH
114813: PPUSH
114814: PPUSH
114815: PPUSH
114816: PPUSH
114817: PPUSH
114818: PPUSH
114819: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
114820: LD_VAR 0 1
114824: PPUSH
114825: CALL_OW 264
114829: PUSH
114830: LD_INT 81
114832: EQUAL
114833: NOT
114834: PUSH
114835: LD_VAR 0 1
114839: PUSH
114840: LD_EXP 192
114844: IN
114845: NOT
114846: OR
114847: IFFALSE 114851
// exit ;
114849: GO 115173
// index := GetElementIndex ( minersList , unit ) ;
114851: LD_ADDR_VAR 0 6
114855: PUSH
114856: LD_EXP 192
114860: PPUSH
114861: LD_VAR 0 1
114865: PPUSH
114866: CALL 57650 0 2
114870: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
114871: LD_ADDR_VAR 0 8
114875: PUSH
114876: LD_EXP 194
114880: PUSH
114881: LD_EXP 193
114885: PUSH
114886: LD_VAR 0 6
114890: ARRAY
114891: MINUS
114892: ST_TO_ADDR
// if not minesFreeAmount then
114893: LD_VAR 0 8
114897: NOT
114898: IFFALSE 114902
// exit ;
114900: GO 115173
// tmp := [ ] ;
114902: LD_ADDR_VAR 0 7
114906: PUSH
114907: EMPTY
114908: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
114909: LD_ADDR_VAR 0 5
114913: PUSH
114914: DOUBLE
114915: LD_INT 1
114917: DEC
114918: ST_TO_ADDR
114919: LD_VAR 0 8
114923: PUSH
114924: FOR_TO
114925: IFFALSE 115120
// begin _d := rand ( 0 , 5 ) ;
114927: LD_ADDR_VAR 0 11
114931: PUSH
114932: LD_INT 0
114934: PPUSH
114935: LD_INT 5
114937: PPUSH
114938: CALL_OW 12
114942: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
114943: LD_ADDR_VAR 0 12
114947: PUSH
114948: LD_INT 2
114950: PPUSH
114951: LD_INT 6
114953: PPUSH
114954: CALL_OW 12
114958: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
114959: LD_ADDR_VAR 0 9
114963: PUSH
114964: LD_VAR 0 2
114968: PPUSH
114969: LD_VAR 0 11
114973: PPUSH
114974: LD_VAR 0 12
114978: PPUSH
114979: CALL_OW 272
114983: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
114984: LD_ADDR_VAR 0 10
114988: PUSH
114989: LD_VAR 0 3
114993: PPUSH
114994: LD_VAR 0 11
114998: PPUSH
114999: LD_VAR 0 12
115003: PPUSH
115004: CALL_OW 273
115008: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
115009: LD_VAR 0 9
115013: PPUSH
115014: LD_VAR 0 10
115018: PPUSH
115019: CALL_OW 488
115023: PUSH
115024: LD_VAR 0 9
115028: PUSH
115029: LD_VAR 0 10
115033: PUSH
115034: EMPTY
115035: LIST
115036: LIST
115037: PUSH
115038: LD_VAR 0 7
115042: IN
115043: NOT
115044: AND
115045: PUSH
115046: LD_VAR 0 9
115050: PPUSH
115051: LD_VAR 0 10
115055: PPUSH
115056: CALL_OW 458
115060: NOT
115061: AND
115062: IFFALSE 115104
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
115064: LD_ADDR_VAR 0 7
115068: PUSH
115069: LD_VAR 0 7
115073: PPUSH
115074: LD_VAR 0 7
115078: PUSH
115079: LD_INT 1
115081: PLUS
115082: PPUSH
115083: LD_VAR 0 9
115087: PUSH
115088: LD_VAR 0 10
115092: PUSH
115093: EMPTY
115094: LIST
115095: LIST
115096: PPUSH
115097: CALL_OW 1
115101: ST_TO_ADDR
115102: GO 115118
// i := i - 1 ;
115104: LD_ADDR_VAR 0 5
115108: PUSH
115109: LD_VAR 0 5
115113: PUSH
115114: LD_INT 1
115116: MINUS
115117: ST_TO_ADDR
// end ;
115118: GO 114924
115120: POP
115121: POP
// for i in tmp do
115122: LD_ADDR_VAR 0 5
115126: PUSH
115127: LD_VAR 0 7
115131: PUSH
115132: FOR_IN
115133: IFFALSE 115171
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
115135: LD_VAR 0 1
115139: PPUSH
115140: LD_VAR 0 5
115144: PUSH
115145: LD_INT 1
115147: ARRAY
115148: PPUSH
115149: LD_VAR 0 5
115153: PUSH
115154: LD_INT 2
115156: ARRAY
115157: PPUSH
115158: CALL 114117 0 3
115162: NOT
115163: IFFALSE 115169
// exit ;
115165: POP
115166: POP
115167: GO 115173
115169: GO 115132
115171: POP
115172: POP
// end ;
115173: LD_VAR 0 4
115177: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
115178: LD_INT 0
115180: PPUSH
115181: PPUSH
115182: PPUSH
115183: PPUSH
115184: PPUSH
115185: PPUSH
115186: PPUSH
// if not GetClass ( unit ) = class_sniper then
115187: LD_VAR 0 1
115191: PPUSH
115192: CALL_OW 257
115196: PUSH
115197: LD_INT 5
115199: EQUAL
115200: NOT
115201: IFFALSE 115205
// exit ;
115203: GO 115593
// dist := 8 ;
115205: LD_ADDR_VAR 0 5
115209: PUSH
115210: LD_INT 8
115212: ST_TO_ADDR
// viewRange := 12 ;
115213: LD_ADDR_VAR 0 7
115217: PUSH
115218: LD_INT 12
115220: ST_TO_ADDR
// side := GetSide ( unit ) ;
115221: LD_ADDR_VAR 0 6
115225: PUSH
115226: LD_VAR 0 1
115230: PPUSH
115231: CALL_OW 255
115235: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
115236: LD_INT 61
115238: PPUSH
115239: LD_VAR 0 6
115243: PPUSH
115244: CALL_OW 321
115248: PUSH
115249: LD_INT 2
115251: EQUAL
115252: IFFALSE 115262
// viewRange := 16 ;
115254: LD_ADDR_VAR 0 7
115258: PUSH
115259: LD_INT 16
115261: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
115262: LD_VAR 0 1
115266: PPUSH
115267: LD_VAR 0 2
115271: PPUSH
115272: LD_VAR 0 3
115276: PPUSH
115277: CALL_OW 297
115281: PUSH
115282: LD_VAR 0 5
115286: GREATER
115287: IFFALSE 115366
// begin ComMoveXY ( unit , x , y ) ;
115289: LD_VAR 0 1
115293: PPUSH
115294: LD_VAR 0 2
115298: PPUSH
115299: LD_VAR 0 3
115303: PPUSH
115304: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
115308: LD_INT 35
115310: PPUSH
115311: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
115315: LD_VAR 0 1
115319: PPUSH
115320: LD_VAR 0 2
115324: PPUSH
115325: LD_VAR 0 3
115329: PPUSH
115330: CALL 89402 0 3
115334: NOT
115335: IFFALSE 115339
// exit ;
115337: GO 115593
// until GetDistUnitXY ( unit , x , y ) < dist ;
115339: LD_VAR 0 1
115343: PPUSH
115344: LD_VAR 0 2
115348: PPUSH
115349: LD_VAR 0 3
115353: PPUSH
115354: CALL_OW 297
115358: PUSH
115359: LD_VAR 0 5
115363: LESS
115364: IFFALSE 115308
// end ; ComTurnXY ( unit , x , y ) ;
115366: LD_VAR 0 1
115370: PPUSH
115371: LD_VAR 0 2
115375: PPUSH
115376: LD_VAR 0 3
115380: PPUSH
115381: CALL_OW 118
// wait ( 5 ) ;
115385: LD_INT 5
115387: PPUSH
115388: CALL_OW 67
// _d := GetDir ( unit ) ;
115392: LD_ADDR_VAR 0 10
115396: PUSH
115397: LD_VAR 0 1
115401: PPUSH
115402: CALL_OW 254
115406: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
115407: LD_ADDR_VAR 0 8
115411: PUSH
115412: LD_VAR 0 1
115416: PPUSH
115417: CALL_OW 250
115421: PPUSH
115422: LD_VAR 0 10
115426: PPUSH
115427: LD_VAR 0 5
115431: PPUSH
115432: CALL_OW 272
115436: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
115437: LD_ADDR_VAR 0 9
115441: PUSH
115442: LD_VAR 0 1
115446: PPUSH
115447: CALL_OW 251
115451: PPUSH
115452: LD_VAR 0 10
115456: PPUSH
115457: LD_VAR 0 5
115461: PPUSH
115462: CALL_OW 273
115466: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
115467: LD_VAR 0 8
115471: PPUSH
115472: LD_VAR 0 9
115476: PPUSH
115477: CALL_OW 488
115481: NOT
115482: IFFALSE 115486
// exit ;
115484: GO 115593
// ComAnimCustom ( unit , 1 ) ;
115486: LD_VAR 0 1
115490: PPUSH
115491: LD_INT 1
115493: PPUSH
115494: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
115498: LD_VAR 0 8
115502: PPUSH
115503: LD_VAR 0 9
115507: PPUSH
115508: LD_VAR 0 6
115512: PPUSH
115513: LD_VAR 0 7
115517: PPUSH
115518: CALL_OW 330
// repeat wait ( 1 ) ;
115522: LD_INT 1
115524: PPUSH
115525: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
115529: LD_VAR 0 1
115533: PPUSH
115534: CALL_OW 316
115538: PUSH
115539: LD_VAR 0 1
115543: PPUSH
115544: CALL_OW 314
115548: OR
115549: PUSH
115550: LD_VAR 0 1
115554: PPUSH
115555: CALL_OW 302
115559: NOT
115560: OR
115561: PUSH
115562: LD_VAR 0 1
115566: PPUSH
115567: CALL_OW 301
115571: OR
115572: IFFALSE 115522
// RemoveSeeing ( _x , _y , side ) ;
115574: LD_VAR 0 8
115578: PPUSH
115579: LD_VAR 0 9
115583: PPUSH
115584: LD_VAR 0 6
115588: PPUSH
115589: CALL_OW 331
// end ; end_of_file
115593: LD_VAR 0 4
115597: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
115598: LD_INT 0
115600: PPUSH
115601: PPUSH
115602: PPUSH
115603: PPUSH
115604: PPUSH
115605: PPUSH
115606: PPUSH
115607: PPUSH
115608: PPUSH
115609: PPUSH
115610: PPUSH
115611: PPUSH
115612: PPUSH
115613: PPUSH
115614: PPUSH
115615: PPUSH
115616: PPUSH
115617: PPUSH
115618: PPUSH
115619: PPUSH
115620: PPUSH
115621: PPUSH
115622: PPUSH
115623: PPUSH
115624: PPUSH
115625: PPUSH
115626: PPUSH
115627: PPUSH
115628: PPUSH
115629: PPUSH
115630: PPUSH
115631: PPUSH
115632: PPUSH
115633: PPUSH
// if not list then
115634: LD_VAR 0 1
115638: NOT
115639: IFFALSE 115643
// exit ;
115641: GO 120302
// base := list [ 1 ] ;
115643: LD_ADDR_VAR 0 3
115647: PUSH
115648: LD_VAR 0 1
115652: PUSH
115653: LD_INT 1
115655: ARRAY
115656: ST_TO_ADDR
// group := list [ 2 ] ;
115657: LD_ADDR_VAR 0 4
115661: PUSH
115662: LD_VAR 0 1
115666: PUSH
115667: LD_INT 2
115669: ARRAY
115670: ST_TO_ADDR
// path := list [ 3 ] ;
115671: LD_ADDR_VAR 0 5
115675: PUSH
115676: LD_VAR 0 1
115680: PUSH
115681: LD_INT 3
115683: ARRAY
115684: ST_TO_ADDR
// flags := list [ 4 ] ;
115685: LD_ADDR_VAR 0 6
115689: PUSH
115690: LD_VAR 0 1
115694: PUSH
115695: LD_INT 4
115697: ARRAY
115698: ST_TO_ADDR
// mined := [ ] ;
115699: LD_ADDR_VAR 0 27
115703: PUSH
115704: EMPTY
115705: ST_TO_ADDR
// bombed := [ ] ;
115706: LD_ADDR_VAR 0 28
115710: PUSH
115711: EMPTY
115712: ST_TO_ADDR
// healers := [ ] ;
115713: LD_ADDR_VAR 0 31
115717: PUSH
115718: EMPTY
115719: ST_TO_ADDR
// to_heal := [ ] ;
115720: LD_ADDR_VAR 0 30
115724: PUSH
115725: EMPTY
115726: ST_TO_ADDR
// repairs := [ ] ;
115727: LD_ADDR_VAR 0 33
115731: PUSH
115732: EMPTY
115733: ST_TO_ADDR
// to_repair := [ ] ;
115734: LD_ADDR_VAR 0 32
115738: PUSH
115739: EMPTY
115740: ST_TO_ADDR
// if not group or not path then
115741: LD_VAR 0 4
115745: NOT
115746: PUSH
115747: LD_VAR 0 5
115751: NOT
115752: OR
115753: IFFALSE 115757
// exit ;
115755: GO 120302
// side := GetSide ( group [ 1 ] ) ;
115757: LD_ADDR_VAR 0 35
115761: PUSH
115762: LD_VAR 0 4
115766: PUSH
115767: LD_INT 1
115769: ARRAY
115770: PPUSH
115771: CALL_OW 255
115775: ST_TO_ADDR
// if flags then
115776: LD_VAR 0 6
115780: IFFALSE 115924
// begin f_ignore_area := flags [ 1 ] ;
115782: LD_ADDR_VAR 0 17
115786: PUSH
115787: LD_VAR 0 6
115791: PUSH
115792: LD_INT 1
115794: ARRAY
115795: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
115796: LD_ADDR_VAR 0 18
115800: PUSH
115801: LD_VAR 0 6
115805: PUSH
115806: LD_INT 2
115808: ARRAY
115809: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
115810: LD_ADDR_VAR 0 19
115814: PUSH
115815: LD_VAR 0 6
115819: PUSH
115820: LD_INT 3
115822: ARRAY
115823: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
115824: LD_ADDR_VAR 0 20
115828: PUSH
115829: LD_VAR 0 6
115833: PUSH
115834: LD_INT 4
115836: ARRAY
115837: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
115838: LD_ADDR_VAR 0 21
115842: PUSH
115843: LD_VAR 0 6
115847: PUSH
115848: LD_INT 5
115850: ARRAY
115851: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
115852: LD_ADDR_VAR 0 22
115856: PUSH
115857: LD_VAR 0 6
115861: PUSH
115862: LD_INT 6
115864: ARRAY
115865: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
115866: LD_ADDR_VAR 0 23
115870: PUSH
115871: LD_VAR 0 6
115875: PUSH
115876: LD_INT 7
115878: ARRAY
115879: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
115880: LD_ADDR_VAR 0 24
115884: PUSH
115885: LD_VAR 0 6
115889: PUSH
115890: LD_INT 8
115892: ARRAY
115893: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
115894: LD_ADDR_VAR 0 25
115898: PUSH
115899: LD_VAR 0 6
115903: PUSH
115904: LD_INT 9
115906: ARRAY
115907: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
115908: LD_ADDR_VAR 0 26
115912: PUSH
115913: LD_VAR 0 6
115917: PUSH
115918: LD_INT 10
115920: ARRAY
115921: ST_TO_ADDR
// end else
115922: GO 116004
// begin f_ignore_area := false ;
115924: LD_ADDR_VAR 0 17
115928: PUSH
115929: LD_INT 0
115931: ST_TO_ADDR
// f_capture := false ;
115932: LD_ADDR_VAR 0 18
115936: PUSH
115937: LD_INT 0
115939: ST_TO_ADDR
// f_ignore_civ := false ;
115940: LD_ADDR_VAR 0 19
115944: PUSH
115945: LD_INT 0
115947: ST_TO_ADDR
// f_murder := false ;
115948: LD_ADDR_VAR 0 20
115952: PUSH
115953: LD_INT 0
115955: ST_TO_ADDR
// f_mines := false ;
115956: LD_ADDR_VAR 0 21
115960: PUSH
115961: LD_INT 0
115963: ST_TO_ADDR
// f_repair := false ;
115964: LD_ADDR_VAR 0 22
115968: PUSH
115969: LD_INT 0
115971: ST_TO_ADDR
// f_heal := false ;
115972: LD_ADDR_VAR 0 23
115976: PUSH
115977: LD_INT 0
115979: ST_TO_ADDR
// f_spacetime := false ;
115980: LD_ADDR_VAR 0 24
115984: PUSH
115985: LD_INT 0
115987: ST_TO_ADDR
// f_attack_depot := false ;
115988: LD_ADDR_VAR 0 25
115992: PUSH
115993: LD_INT 0
115995: ST_TO_ADDR
// f_crawl := false ;
115996: LD_ADDR_VAR 0 26
116000: PUSH
116001: LD_INT 0
116003: ST_TO_ADDR
// end ; if f_heal then
116004: LD_VAR 0 23
116008: IFFALSE 116035
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
116010: LD_ADDR_VAR 0 31
116014: PUSH
116015: LD_VAR 0 4
116019: PPUSH
116020: LD_INT 25
116022: PUSH
116023: LD_INT 4
116025: PUSH
116026: EMPTY
116027: LIST
116028: LIST
116029: PPUSH
116030: CALL_OW 72
116034: ST_TO_ADDR
// if f_repair then
116035: LD_VAR 0 22
116039: IFFALSE 116066
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
116041: LD_ADDR_VAR 0 33
116045: PUSH
116046: LD_VAR 0 4
116050: PPUSH
116051: LD_INT 25
116053: PUSH
116054: LD_INT 3
116056: PUSH
116057: EMPTY
116058: LIST
116059: LIST
116060: PPUSH
116061: CALL_OW 72
116065: ST_TO_ADDR
// units_path := [ ] ;
116066: LD_ADDR_VAR 0 16
116070: PUSH
116071: EMPTY
116072: ST_TO_ADDR
// for i = 1 to group do
116073: LD_ADDR_VAR 0 7
116077: PUSH
116078: DOUBLE
116079: LD_INT 1
116081: DEC
116082: ST_TO_ADDR
116083: LD_VAR 0 4
116087: PUSH
116088: FOR_TO
116089: IFFALSE 116118
// units_path := Replace ( units_path , i , path ) ;
116091: LD_ADDR_VAR 0 16
116095: PUSH
116096: LD_VAR 0 16
116100: PPUSH
116101: LD_VAR 0 7
116105: PPUSH
116106: LD_VAR 0 5
116110: PPUSH
116111: CALL_OW 1
116115: ST_TO_ADDR
116116: GO 116088
116118: POP
116119: POP
// repeat for i = group downto 1 do
116120: LD_ADDR_VAR 0 7
116124: PUSH
116125: DOUBLE
116126: LD_VAR 0 4
116130: INC
116131: ST_TO_ADDR
116132: LD_INT 1
116134: PUSH
116135: FOR_DOWNTO
116136: IFFALSE 120258
// begin wait ( 5 ) ;
116138: LD_INT 5
116140: PPUSH
116141: CALL_OW 67
// tmp := [ ] ;
116145: LD_ADDR_VAR 0 14
116149: PUSH
116150: EMPTY
116151: ST_TO_ADDR
// attacking := false ;
116152: LD_ADDR_VAR 0 29
116156: PUSH
116157: LD_INT 0
116159: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
116160: LD_VAR 0 4
116164: PUSH
116165: LD_VAR 0 7
116169: ARRAY
116170: PPUSH
116171: CALL_OW 301
116175: PUSH
116176: LD_VAR 0 4
116180: PUSH
116181: LD_VAR 0 7
116185: ARRAY
116186: NOT
116187: OR
116188: IFFALSE 116297
// begin if GetType ( group [ i ] ) = unit_human then
116190: LD_VAR 0 4
116194: PUSH
116195: LD_VAR 0 7
116199: ARRAY
116200: PPUSH
116201: CALL_OW 247
116205: PUSH
116206: LD_INT 1
116208: EQUAL
116209: IFFALSE 116255
// begin to_heal := to_heal diff group [ i ] ;
116211: LD_ADDR_VAR 0 30
116215: PUSH
116216: LD_VAR 0 30
116220: PUSH
116221: LD_VAR 0 4
116225: PUSH
116226: LD_VAR 0 7
116230: ARRAY
116231: DIFF
116232: ST_TO_ADDR
// healers := healers diff group [ i ] ;
116233: LD_ADDR_VAR 0 31
116237: PUSH
116238: LD_VAR 0 31
116242: PUSH
116243: LD_VAR 0 4
116247: PUSH
116248: LD_VAR 0 7
116252: ARRAY
116253: DIFF
116254: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
116255: LD_ADDR_VAR 0 4
116259: PUSH
116260: LD_VAR 0 4
116264: PPUSH
116265: LD_VAR 0 7
116269: PPUSH
116270: CALL_OW 3
116274: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
116275: LD_ADDR_VAR 0 16
116279: PUSH
116280: LD_VAR 0 16
116284: PPUSH
116285: LD_VAR 0 7
116289: PPUSH
116290: CALL_OW 3
116294: ST_TO_ADDR
// continue ;
116295: GO 116135
// end ; if f_repair then
116297: LD_VAR 0 22
116301: IFFALSE 116790
// begin if GetType ( group [ i ] ) = unit_vehicle then
116303: LD_VAR 0 4
116307: PUSH
116308: LD_VAR 0 7
116312: ARRAY
116313: PPUSH
116314: CALL_OW 247
116318: PUSH
116319: LD_INT 2
116321: EQUAL
116322: IFFALSE 116512
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
116324: LD_VAR 0 4
116328: PUSH
116329: LD_VAR 0 7
116333: ARRAY
116334: PPUSH
116335: CALL_OW 256
116339: PUSH
116340: LD_INT 700
116342: LESS
116343: PUSH
116344: LD_VAR 0 4
116348: PUSH
116349: LD_VAR 0 7
116353: ARRAY
116354: PUSH
116355: LD_VAR 0 32
116359: IN
116360: NOT
116361: AND
116362: IFFALSE 116386
// to_repair := to_repair union group [ i ] ;
116364: LD_ADDR_VAR 0 32
116368: PUSH
116369: LD_VAR 0 32
116373: PUSH
116374: LD_VAR 0 4
116378: PUSH
116379: LD_VAR 0 7
116383: ARRAY
116384: UNION
116385: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
116386: LD_VAR 0 4
116390: PUSH
116391: LD_VAR 0 7
116395: ARRAY
116396: PPUSH
116397: CALL_OW 256
116401: PUSH
116402: LD_INT 1000
116404: EQUAL
116405: PUSH
116406: LD_VAR 0 4
116410: PUSH
116411: LD_VAR 0 7
116415: ARRAY
116416: PUSH
116417: LD_VAR 0 32
116421: IN
116422: AND
116423: IFFALSE 116447
// to_repair := to_repair diff group [ i ] ;
116425: LD_ADDR_VAR 0 32
116429: PUSH
116430: LD_VAR 0 32
116434: PUSH
116435: LD_VAR 0 4
116439: PUSH
116440: LD_VAR 0 7
116444: ARRAY
116445: DIFF
116446: ST_TO_ADDR
// if group [ i ] in to_repair then
116447: LD_VAR 0 4
116451: PUSH
116452: LD_VAR 0 7
116456: ARRAY
116457: PUSH
116458: LD_VAR 0 32
116462: IN
116463: IFFALSE 116510
// begin if not IsInArea ( group [ i ] , f_repair ) then
116465: LD_VAR 0 4
116469: PUSH
116470: LD_VAR 0 7
116474: ARRAY
116475: PPUSH
116476: LD_VAR 0 22
116480: PPUSH
116481: CALL_OW 308
116485: NOT
116486: IFFALSE 116508
// ComMoveToArea ( group [ i ] , f_repair ) ;
116488: LD_VAR 0 4
116492: PUSH
116493: LD_VAR 0 7
116497: ARRAY
116498: PPUSH
116499: LD_VAR 0 22
116503: PPUSH
116504: CALL_OW 113
// continue ;
116508: GO 116135
// end ; end else
116510: GO 116790
// if group [ i ] in repairs then
116512: LD_VAR 0 4
116516: PUSH
116517: LD_VAR 0 7
116521: ARRAY
116522: PUSH
116523: LD_VAR 0 33
116527: IN
116528: IFFALSE 116790
// begin if IsInUnit ( group [ i ] ) then
116530: LD_VAR 0 4
116534: PUSH
116535: LD_VAR 0 7
116539: ARRAY
116540: PPUSH
116541: CALL_OW 310
116545: IFFALSE 116613
// begin z := IsInUnit ( group [ i ] ) ;
116547: LD_ADDR_VAR 0 13
116551: PUSH
116552: LD_VAR 0 4
116556: PUSH
116557: LD_VAR 0 7
116561: ARRAY
116562: PPUSH
116563: CALL_OW 310
116567: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
116568: LD_VAR 0 13
116572: PUSH
116573: LD_VAR 0 32
116577: IN
116578: PUSH
116579: LD_VAR 0 13
116583: PPUSH
116584: LD_VAR 0 22
116588: PPUSH
116589: CALL_OW 308
116593: AND
116594: IFFALSE 116611
// ComExitVehicle ( group [ i ] ) ;
116596: LD_VAR 0 4
116600: PUSH
116601: LD_VAR 0 7
116605: ARRAY
116606: PPUSH
116607: CALL_OW 121
// end else
116611: GO 116790
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
116613: LD_ADDR_VAR 0 13
116617: PUSH
116618: LD_VAR 0 4
116622: PPUSH
116623: LD_INT 95
116625: PUSH
116626: LD_VAR 0 22
116630: PUSH
116631: EMPTY
116632: LIST
116633: LIST
116634: PUSH
116635: LD_INT 58
116637: PUSH
116638: EMPTY
116639: LIST
116640: PUSH
116641: EMPTY
116642: LIST
116643: LIST
116644: PPUSH
116645: CALL_OW 72
116649: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
116650: LD_VAR 0 4
116654: PUSH
116655: LD_VAR 0 7
116659: ARRAY
116660: PPUSH
116661: CALL_OW 314
116665: NOT
116666: IFFALSE 116788
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
116668: LD_ADDR_VAR 0 10
116672: PUSH
116673: LD_VAR 0 13
116677: PPUSH
116678: LD_VAR 0 4
116682: PUSH
116683: LD_VAR 0 7
116687: ARRAY
116688: PPUSH
116689: CALL_OW 74
116693: ST_TO_ADDR
// if not x then
116694: LD_VAR 0 10
116698: NOT
116699: IFFALSE 116703
// continue ;
116701: GO 116135
// if GetLives ( x ) < 1000 then
116703: LD_VAR 0 10
116707: PPUSH
116708: CALL_OW 256
116712: PUSH
116713: LD_INT 1000
116715: LESS
116716: IFFALSE 116740
// ComRepairVehicle ( group [ i ] , x ) else
116718: LD_VAR 0 4
116722: PUSH
116723: LD_VAR 0 7
116727: ARRAY
116728: PPUSH
116729: LD_VAR 0 10
116733: PPUSH
116734: CALL_OW 129
116738: GO 116788
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
116740: LD_VAR 0 23
116744: PUSH
116745: LD_VAR 0 4
116749: PUSH
116750: LD_VAR 0 7
116754: ARRAY
116755: PPUSH
116756: CALL_OW 256
116760: PUSH
116761: LD_INT 1000
116763: LESS
116764: AND
116765: NOT
116766: IFFALSE 116788
// ComEnterUnit ( group [ i ] , x ) ;
116768: LD_VAR 0 4
116772: PUSH
116773: LD_VAR 0 7
116777: ARRAY
116778: PPUSH
116779: LD_VAR 0 10
116783: PPUSH
116784: CALL_OW 120
// end ; continue ;
116788: GO 116135
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
116790: LD_VAR 0 23
116794: PUSH
116795: LD_VAR 0 4
116799: PUSH
116800: LD_VAR 0 7
116804: ARRAY
116805: PPUSH
116806: CALL_OW 247
116810: PUSH
116811: LD_INT 1
116813: EQUAL
116814: AND
116815: IFFALSE 117293
// begin if group [ i ] in healers then
116817: LD_VAR 0 4
116821: PUSH
116822: LD_VAR 0 7
116826: ARRAY
116827: PUSH
116828: LD_VAR 0 31
116832: IN
116833: IFFALSE 117106
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
116835: LD_VAR 0 4
116839: PUSH
116840: LD_VAR 0 7
116844: ARRAY
116845: PPUSH
116846: LD_VAR 0 23
116850: PPUSH
116851: CALL_OW 308
116855: NOT
116856: PUSH
116857: LD_VAR 0 4
116861: PUSH
116862: LD_VAR 0 7
116866: ARRAY
116867: PPUSH
116868: CALL_OW 314
116872: NOT
116873: AND
116874: IFFALSE 116898
// ComMoveToArea ( group [ i ] , f_heal ) else
116876: LD_VAR 0 4
116880: PUSH
116881: LD_VAR 0 7
116885: ARRAY
116886: PPUSH
116887: LD_VAR 0 23
116891: PPUSH
116892: CALL_OW 113
116896: GO 117104
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
116898: LD_VAR 0 4
116902: PUSH
116903: LD_VAR 0 7
116907: ARRAY
116908: PPUSH
116909: CALL 87985 0 1
116913: PPUSH
116914: CALL_OW 256
116918: PUSH
116919: LD_INT 1000
116921: EQUAL
116922: IFFALSE 116941
// ComStop ( group [ i ] ) else
116924: LD_VAR 0 4
116928: PUSH
116929: LD_VAR 0 7
116933: ARRAY
116934: PPUSH
116935: CALL_OW 141
116939: GO 117104
// if not HasTask ( group [ i ] ) and to_heal then
116941: LD_VAR 0 4
116945: PUSH
116946: LD_VAR 0 7
116950: ARRAY
116951: PPUSH
116952: CALL_OW 314
116956: NOT
116957: PUSH
116958: LD_VAR 0 30
116962: AND
116963: IFFALSE 117104
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
116965: LD_ADDR_VAR 0 13
116969: PUSH
116970: LD_VAR 0 30
116974: PPUSH
116975: LD_INT 3
116977: PUSH
116978: LD_INT 54
116980: PUSH
116981: EMPTY
116982: LIST
116983: PUSH
116984: EMPTY
116985: LIST
116986: LIST
116987: PPUSH
116988: CALL_OW 72
116992: PPUSH
116993: LD_VAR 0 4
116997: PUSH
116998: LD_VAR 0 7
117002: ARRAY
117003: PPUSH
117004: CALL_OW 74
117008: ST_TO_ADDR
// if z then
117009: LD_VAR 0 13
117013: IFFALSE 117104
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
117015: LD_INT 91
117017: PUSH
117018: LD_VAR 0 13
117022: PUSH
117023: LD_INT 10
117025: PUSH
117026: EMPTY
117027: LIST
117028: LIST
117029: LIST
117030: PUSH
117031: LD_INT 81
117033: PUSH
117034: LD_VAR 0 13
117038: PPUSH
117039: CALL_OW 255
117043: PUSH
117044: EMPTY
117045: LIST
117046: LIST
117047: PUSH
117048: EMPTY
117049: LIST
117050: LIST
117051: PPUSH
117052: CALL_OW 69
117056: PUSH
117057: LD_INT 0
117059: EQUAL
117060: IFFALSE 117084
// ComHeal ( group [ i ] , z ) else
117062: LD_VAR 0 4
117066: PUSH
117067: LD_VAR 0 7
117071: ARRAY
117072: PPUSH
117073: LD_VAR 0 13
117077: PPUSH
117078: CALL_OW 128
117082: GO 117104
// ComMoveToArea ( group [ i ] , f_heal ) ;
117084: LD_VAR 0 4
117088: PUSH
117089: LD_VAR 0 7
117093: ARRAY
117094: PPUSH
117095: LD_VAR 0 23
117099: PPUSH
117100: CALL_OW 113
// end ; continue ;
117104: GO 116135
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
117106: LD_VAR 0 4
117110: PUSH
117111: LD_VAR 0 7
117115: ARRAY
117116: PPUSH
117117: CALL_OW 256
117121: PUSH
117122: LD_INT 700
117124: LESS
117125: PUSH
117126: LD_VAR 0 4
117130: PUSH
117131: LD_VAR 0 7
117135: ARRAY
117136: PUSH
117137: LD_VAR 0 30
117141: IN
117142: NOT
117143: AND
117144: IFFALSE 117168
// to_heal := to_heal union group [ i ] ;
117146: LD_ADDR_VAR 0 30
117150: PUSH
117151: LD_VAR 0 30
117155: PUSH
117156: LD_VAR 0 4
117160: PUSH
117161: LD_VAR 0 7
117165: ARRAY
117166: UNION
117167: ST_TO_ADDR
// if group [ i ] in to_heal then
117168: LD_VAR 0 4
117172: PUSH
117173: LD_VAR 0 7
117177: ARRAY
117178: PUSH
117179: LD_VAR 0 30
117183: IN
117184: IFFALSE 117293
// begin if GetLives ( group [ i ] ) = 1000 then
117186: LD_VAR 0 4
117190: PUSH
117191: LD_VAR 0 7
117195: ARRAY
117196: PPUSH
117197: CALL_OW 256
117201: PUSH
117202: LD_INT 1000
117204: EQUAL
117205: IFFALSE 117231
// to_heal := to_heal diff group [ i ] else
117207: LD_ADDR_VAR 0 30
117211: PUSH
117212: LD_VAR 0 30
117216: PUSH
117217: LD_VAR 0 4
117221: PUSH
117222: LD_VAR 0 7
117226: ARRAY
117227: DIFF
117228: ST_TO_ADDR
117229: GO 117293
// begin if not IsInArea ( group [ i ] , to_heal ) then
117231: LD_VAR 0 4
117235: PUSH
117236: LD_VAR 0 7
117240: ARRAY
117241: PPUSH
117242: LD_VAR 0 30
117246: PPUSH
117247: CALL_OW 308
117251: NOT
117252: IFFALSE 117276
// ComMoveToArea ( group [ i ] , f_heal ) else
117254: LD_VAR 0 4
117258: PUSH
117259: LD_VAR 0 7
117263: ARRAY
117264: PPUSH
117265: LD_VAR 0 23
117269: PPUSH
117270: CALL_OW 113
117274: GO 117291
// ComHold ( group [ i ] ) ;
117276: LD_VAR 0 4
117280: PUSH
117281: LD_VAR 0 7
117285: ARRAY
117286: PPUSH
117287: CALL_OW 140
// continue ;
117291: GO 116135
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
117293: LD_VAR 0 4
117297: PUSH
117298: LD_VAR 0 7
117302: ARRAY
117303: PPUSH
117304: LD_INT 10
117306: PPUSH
117307: CALL 85756 0 2
117311: NOT
117312: PUSH
117313: LD_VAR 0 16
117317: PUSH
117318: LD_VAR 0 7
117322: ARRAY
117323: PUSH
117324: EMPTY
117325: EQUAL
117326: NOT
117327: AND
117328: IFFALSE 117594
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
117330: LD_VAR 0 4
117334: PUSH
117335: LD_VAR 0 7
117339: ARRAY
117340: PPUSH
117341: CALL_OW 262
117345: PUSH
117346: LD_INT 1
117348: PUSH
117349: LD_INT 2
117351: PUSH
117352: EMPTY
117353: LIST
117354: LIST
117355: IN
117356: IFFALSE 117397
// if GetFuel ( group [ i ] ) < 10 then
117358: LD_VAR 0 4
117362: PUSH
117363: LD_VAR 0 7
117367: ARRAY
117368: PPUSH
117369: CALL_OW 261
117373: PUSH
117374: LD_INT 10
117376: LESS
117377: IFFALSE 117397
// SetFuel ( group [ i ] , 12 ) ;
117379: LD_VAR 0 4
117383: PUSH
117384: LD_VAR 0 7
117388: ARRAY
117389: PPUSH
117390: LD_INT 12
117392: PPUSH
117393: CALL_OW 240
// if units_path [ i ] then
117397: LD_VAR 0 16
117401: PUSH
117402: LD_VAR 0 7
117406: ARRAY
117407: IFFALSE 117592
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
117409: LD_VAR 0 4
117413: PUSH
117414: LD_VAR 0 7
117418: ARRAY
117419: PPUSH
117420: LD_VAR 0 16
117424: PUSH
117425: LD_VAR 0 7
117429: ARRAY
117430: PUSH
117431: LD_INT 1
117433: ARRAY
117434: PUSH
117435: LD_INT 1
117437: ARRAY
117438: PPUSH
117439: LD_VAR 0 16
117443: PUSH
117444: LD_VAR 0 7
117448: ARRAY
117449: PUSH
117450: LD_INT 1
117452: ARRAY
117453: PUSH
117454: LD_INT 2
117456: ARRAY
117457: PPUSH
117458: CALL_OW 297
117462: PUSH
117463: LD_INT 6
117465: GREATER
117466: IFFALSE 117541
// begin if not HasTask ( group [ i ] ) then
117468: LD_VAR 0 4
117472: PUSH
117473: LD_VAR 0 7
117477: ARRAY
117478: PPUSH
117479: CALL_OW 314
117483: NOT
117484: IFFALSE 117539
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
117486: LD_VAR 0 4
117490: PUSH
117491: LD_VAR 0 7
117495: ARRAY
117496: PPUSH
117497: LD_VAR 0 16
117501: PUSH
117502: LD_VAR 0 7
117506: ARRAY
117507: PUSH
117508: LD_INT 1
117510: ARRAY
117511: PUSH
117512: LD_INT 1
117514: ARRAY
117515: PPUSH
117516: LD_VAR 0 16
117520: PUSH
117521: LD_VAR 0 7
117525: ARRAY
117526: PUSH
117527: LD_INT 1
117529: ARRAY
117530: PUSH
117531: LD_INT 2
117533: ARRAY
117534: PPUSH
117535: CALL_OW 114
// end else
117539: GO 117592
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
117541: LD_ADDR_VAR 0 15
117545: PUSH
117546: LD_VAR 0 16
117550: PUSH
117551: LD_VAR 0 7
117555: ARRAY
117556: PPUSH
117557: LD_INT 1
117559: PPUSH
117560: CALL_OW 3
117564: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
117565: LD_ADDR_VAR 0 16
117569: PUSH
117570: LD_VAR 0 16
117574: PPUSH
117575: LD_VAR 0 7
117579: PPUSH
117580: LD_VAR 0 15
117584: PPUSH
117585: CALL_OW 1
117589: ST_TO_ADDR
// continue ;
117590: GO 116135
// end ; end ; end else
117592: GO 120256
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
117594: LD_ADDR_VAR 0 14
117598: PUSH
117599: LD_INT 81
117601: PUSH
117602: LD_VAR 0 4
117606: PUSH
117607: LD_VAR 0 7
117611: ARRAY
117612: PPUSH
117613: CALL_OW 255
117617: PUSH
117618: EMPTY
117619: LIST
117620: LIST
117621: PPUSH
117622: CALL_OW 69
117626: ST_TO_ADDR
// if not tmp then
117627: LD_VAR 0 14
117631: NOT
117632: IFFALSE 117636
// continue ;
117634: GO 116135
// if f_ignore_area then
117636: LD_VAR 0 17
117640: IFFALSE 117728
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
117642: LD_ADDR_VAR 0 15
117646: PUSH
117647: LD_VAR 0 14
117651: PPUSH
117652: LD_INT 3
117654: PUSH
117655: LD_INT 92
117657: PUSH
117658: LD_VAR 0 17
117662: PUSH
117663: LD_INT 1
117665: ARRAY
117666: PUSH
117667: LD_VAR 0 17
117671: PUSH
117672: LD_INT 2
117674: ARRAY
117675: PUSH
117676: LD_VAR 0 17
117680: PUSH
117681: LD_INT 3
117683: ARRAY
117684: PUSH
117685: EMPTY
117686: LIST
117687: LIST
117688: LIST
117689: LIST
117690: PUSH
117691: EMPTY
117692: LIST
117693: LIST
117694: PPUSH
117695: CALL_OW 72
117699: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
117700: LD_VAR 0 14
117704: PUSH
117705: LD_VAR 0 15
117709: DIFF
117710: IFFALSE 117728
// tmp := tmp diff tmp2 ;
117712: LD_ADDR_VAR 0 14
117716: PUSH
117717: LD_VAR 0 14
117721: PUSH
117722: LD_VAR 0 15
117726: DIFF
117727: ST_TO_ADDR
// end ; if not f_murder then
117728: LD_VAR 0 20
117732: NOT
117733: IFFALSE 117791
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
117735: LD_ADDR_VAR 0 15
117739: PUSH
117740: LD_VAR 0 14
117744: PPUSH
117745: LD_INT 3
117747: PUSH
117748: LD_INT 50
117750: PUSH
117751: EMPTY
117752: LIST
117753: PUSH
117754: EMPTY
117755: LIST
117756: LIST
117757: PPUSH
117758: CALL_OW 72
117762: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
117763: LD_VAR 0 14
117767: PUSH
117768: LD_VAR 0 15
117772: DIFF
117773: IFFALSE 117791
// tmp := tmp diff tmp2 ;
117775: LD_ADDR_VAR 0 14
117779: PUSH
117780: LD_VAR 0 14
117784: PUSH
117785: LD_VAR 0 15
117789: DIFF
117790: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
117791: LD_ADDR_VAR 0 14
117795: PUSH
117796: LD_VAR 0 4
117800: PUSH
117801: LD_VAR 0 7
117805: ARRAY
117806: PPUSH
117807: LD_VAR 0 14
117811: PPUSH
117812: LD_INT 1
117814: PPUSH
117815: LD_INT 1
117817: PPUSH
117818: CALL 58300 0 4
117822: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
117823: LD_VAR 0 4
117827: PUSH
117828: LD_VAR 0 7
117832: ARRAY
117833: PPUSH
117834: CALL_OW 257
117838: PUSH
117839: LD_INT 1
117841: EQUAL
117842: IFFALSE 118290
// begin if WantPlant ( group [ i ] ) then
117844: LD_VAR 0 4
117848: PUSH
117849: LD_VAR 0 7
117853: ARRAY
117854: PPUSH
117855: CALL 57801 0 1
117859: IFFALSE 117863
// continue ;
117861: GO 116135
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
117863: LD_VAR 0 18
117867: PUSH
117868: LD_VAR 0 4
117872: PUSH
117873: LD_VAR 0 7
117877: ARRAY
117878: PPUSH
117879: CALL_OW 310
117883: NOT
117884: AND
117885: PUSH
117886: LD_VAR 0 14
117890: PUSH
117891: LD_INT 1
117893: ARRAY
117894: PUSH
117895: LD_VAR 0 14
117899: PPUSH
117900: LD_INT 21
117902: PUSH
117903: LD_INT 2
117905: PUSH
117906: EMPTY
117907: LIST
117908: LIST
117909: PUSH
117910: LD_INT 58
117912: PUSH
117913: EMPTY
117914: LIST
117915: PUSH
117916: EMPTY
117917: LIST
117918: LIST
117919: PPUSH
117920: CALL_OW 72
117924: IN
117925: AND
117926: IFFALSE 117962
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
117928: LD_VAR 0 4
117932: PUSH
117933: LD_VAR 0 7
117937: ARRAY
117938: PPUSH
117939: LD_VAR 0 14
117943: PUSH
117944: LD_INT 1
117946: ARRAY
117947: PPUSH
117948: CALL_OW 120
// attacking := true ;
117952: LD_ADDR_VAR 0 29
117956: PUSH
117957: LD_INT 1
117959: ST_TO_ADDR
// continue ;
117960: GO 116135
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
117962: LD_VAR 0 26
117966: PUSH
117967: LD_VAR 0 4
117971: PUSH
117972: LD_VAR 0 7
117976: ARRAY
117977: PPUSH
117978: CALL_OW 257
117982: PUSH
117983: LD_INT 1
117985: EQUAL
117986: AND
117987: PUSH
117988: LD_VAR 0 4
117992: PUSH
117993: LD_VAR 0 7
117997: ARRAY
117998: PPUSH
117999: CALL_OW 256
118003: PUSH
118004: LD_INT 800
118006: LESS
118007: AND
118008: PUSH
118009: LD_VAR 0 4
118013: PUSH
118014: LD_VAR 0 7
118018: ARRAY
118019: PPUSH
118020: CALL_OW 318
118024: NOT
118025: AND
118026: IFFALSE 118043
// ComCrawl ( group [ i ] ) ;
118028: LD_VAR 0 4
118032: PUSH
118033: LD_VAR 0 7
118037: ARRAY
118038: PPUSH
118039: CALL_OW 137
// if f_mines then
118043: LD_VAR 0 21
118047: IFFALSE 118290
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
118049: LD_VAR 0 14
118053: PUSH
118054: LD_INT 1
118056: ARRAY
118057: PPUSH
118058: CALL_OW 247
118062: PUSH
118063: LD_INT 3
118065: EQUAL
118066: PUSH
118067: LD_VAR 0 14
118071: PUSH
118072: LD_INT 1
118074: ARRAY
118075: PUSH
118076: LD_VAR 0 27
118080: IN
118081: NOT
118082: AND
118083: IFFALSE 118290
// begin x := GetX ( tmp [ 1 ] ) ;
118085: LD_ADDR_VAR 0 10
118089: PUSH
118090: LD_VAR 0 14
118094: PUSH
118095: LD_INT 1
118097: ARRAY
118098: PPUSH
118099: CALL_OW 250
118103: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
118104: LD_ADDR_VAR 0 11
118108: PUSH
118109: LD_VAR 0 14
118113: PUSH
118114: LD_INT 1
118116: ARRAY
118117: PPUSH
118118: CALL_OW 251
118122: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
118123: LD_ADDR_VAR 0 12
118127: PUSH
118128: LD_VAR 0 4
118132: PUSH
118133: LD_VAR 0 7
118137: ARRAY
118138: PPUSH
118139: CALL 85841 0 1
118143: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
118144: LD_VAR 0 4
118148: PUSH
118149: LD_VAR 0 7
118153: ARRAY
118154: PPUSH
118155: LD_VAR 0 10
118159: PPUSH
118160: LD_VAR 0 11
118164: PPUSH
118165: LD_VAR 0 14
118169: PUSH
118170: LD_INT 1
118172: ARRAY
118173: PPUSH
118174: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
118178: LD_VAR 0 4
118182: PUSH
118183: LD_VAR 0 7
118187: ARRAY
118188: PPUSH
118189: LD_VAR 0 10
118193: PPUSH
118194: LD_VAR 0 12
118198: PPUSH
118199: LD_INT 7
118201: PPUSH
118202: CALL_OW 272
118206: PPUSH
118207: LD_VAR 0 11
118211: PPUSH
118212: LD_VAR 0 12
118216: PPUSH
118217: LD_INT 7
118219: PPUSH
118220: CALL_OW 273
118224: PPUSH
118225: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
118229: LD_VAR 0 4
118233: PUSH
118234: LD_VAR 0 7
118238: ARRAY
118239: PPUSH
118240: LD_INT 71
118242: PPUSH
118243: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
118247: LD_ADDR_VAR 0 27
118251: PUSH
118252: LD_VAR 0 27
118256: PPUSH
118257: LD_VAR 0 27
118261: PUSH
118262: LD_INT 1
118264: PLUS
118265: PPUSH
118266: LD_VAR 0 14
118270: PUSH
118271: LD_INT 1
118273: ARRAY
118274: PPUSH
118275: CALL_OW 1
118279: ST_TO_ADDR
// attacking := true ;
118280: LD_ADDR_VAR 0 29
118284: PUSH
118285: LD_INT 1
118287: ST_TO_ADDR
// continue ;
118288: GO 116135
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
118290: LD_VAR 0 4
118294: PUSH
118295: LD_VAR 0 7
118299: ARRAY
118300: PPUSH
118301: CALL_OW 257
118305: PUSH
118306: LD_INT 17
118308: EQUAL
118309: PUSH
118310: LD_VAR 0 4
118314: PUSH
118315: LD_VAR 0 7
118319: ARRAY
118320: PPUSH
118321: CALL_OW 110
118325: PUSH
118326: LD_INT 71
118328: EQUAL
118329: NOT
118330: AND
118331: IFFALSE 118477
// begin attacking := false ;
118333: LD_ADDR_VAR 0 29
118337: PUSH
118338: LD_INT 0
118340: ST_TO_ADDR
// k := 5 ;
118341: LD_ADDR_VAR 0 9
118345: PUSH
118346: LD_INT 5
118348: ST_TO_ADDR
// if tmp < k then
118349: LD_VAR 0 14
118353: PUSH
118354: LD_VAR 0 9
118358: LESS
118359: IFFALSE 118371
// k := tmp ;
118361: LD_ADDR_VAR 0 9
118365: PUSH
118366: LD_VAR 0 14
118370: ST_TO_ADDR
// for j = 1 to k do
118371: LD_ADDR_VAR 0 8
118375: PUSH
118376: DOUBLE
118377: LD_INT 1
118379: DEC
118380: ST_TO_ADDR
118381: LD_VAR 0 9
118385: PUSH
118386: FOR_TO
118387: IFFALSE 118475
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
118389: LD_VAR 0 14
118393: PUSH
118394: LD_VAR 0 8
118398: ARRAY
118399: PUSH
118400: LD_VAR 0 14
118404: PPUSH
118405: LD_INT 58
118407: PUSH
118408: EMPTY
118409: LIST
118410: PPUSH
118411: CALL_OW 72
118415: IN
118416: NOT
118417: IFFALSE 118473
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118419: LD_VAR 0 4
118423: PUSH
118424: LD_VAR 0 7
118428: ARRAY
118429: PPUSH
118430: LD_VAR 0 14
118434: PUSH
118435: LD_VAR 0 8
118439: ARRAY
118440: PPUSH
118441: CALL_OW 115
// attacking := true ;
118445: LD_ADDR_VAR 0 29
118449: PUSH
118450: LD_INT 1
118452: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
118453: LD_VAR 0 4
118457: PUSH
118458: LD_VAR 0 7
118462: ARRAY
118463: PPUSH
118464: LD_INT 71
118466: PPUSH
118467: CALL_OW 109
// continue ;
118471: GO 118386
// end ; end ;
118473: GO 118386
118475: POP
118476: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
118477: LD_VAR 0 4
118481: PUSH
118482: LD_VAR 0 7
118486: ARRAY
118487: PPUSH
118488: CALL_OW 257
118492: PUSH
118493: LD_INT 8
118495: EQUAL
118496: PUSH
118497: LD_VAR 0 4
118501: PUSH
118502: LD_VAR 0 7
118506: ARRAY
118507: PPUSH
118508: CALL_OW 264
118512: PUSH
118513: LD_INT 28
118515: PUSH
118516: LD_INT 45
118518: PUSH
118519: LD_INT 7
118521: PUSH
118522: LD_INT 47
118524: PUSH
118525: EMPTY
118526: LIST
118527: LIST
118528: LIST
118529: LIST
118530: IN
118531: OR
118532: IFFALSE 118788
// begin attacking := false ;
118534: LD_ADDR_VAR 0 29
118538: PUSH
118539: LD_INT 0
118541: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
118542: LD_VAR 0 14
118546: PUSH
118547: LD_INT 1
118549: ARRAY
118550: PPUSH
118551: CALL_OW 266
118555: PUSH
118556: LD_INT 32
118558: PUSH
118559: LD_INT 31
118561: PUSH
118562: LD_INT 33
118564: PUSH
118565: LD_INT 4
118567: PUSH
118568: LD_INT 5
118570: PUSH
118571: EMPTY
118572: LIST
118573: LIST
118574: LIST
118575: LIST
118576: LIST
118577: IN
118578: IFFALSE 118764
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
118580: LD_ADDR_VAR 0 9
118584: PUSH
118585: LD_VAR 0 14
118589: PUSH
118590: LD_INT 1
118592: ARRAY
118593: PPUSH
118594: CALL_OW 266
118598: PPUSH
118599: LD_VAR 0 14
118603: PUSH
118604: LD_INT 1
118606: ARRAY
118607: PPUSH
118608: CALL_OW 250
118612: PPUSH
118613: LD_VAR 0 14
118617: PUSH
118618: LD_INT 1
118620: ARRAY
118621: PPUSH
118622: CALL_OW 251
118626: PPUSH
118627: LD_VAR 0 14
118631: PUSH
118632: LD_INT 1
118634: ARRAY
118635: PPUSH
118636: CALL_OW 254
118640: PPUSH
118641: LD_VAR 0 14
118645: PUSH
118646: LD_INT 1
118648: ARRAY
118649: PPUSH
118650: CALL_OW 248
118654: PPUSH
118655: LD_INT 0
118657: PPUSH
118658: CALL 67211 0 6
118662: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
118663: LD_ADDR_VAR 0 8
118667: PUSH
118668: LD_VAR 0 4
118672: PUSH
118673: LD_VAR 0 7
118677: ARRAY
118678: PPUSH
118679: LD_VAR 0 9
118683: PPUSH
118684: CALL 85954 0 2
118688: ST_TO_ADDR
// if j then
118689: LD_VAR 0 8
118693: IFFALSE 118762
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
118695: LD_VAR 0 8
118699: PUSH
118700: LD_INT 1
118702: ARRAY
118703: PPUSH
118704: LD_VAR 0 8
118708: PUSH
118709: LD_INT 2
118711: ARRAY
118712: PPUSH
118713: CALL_OW 488
118717: IFFALSE 118762
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
118719: LD_VAR 0 4
118723: PUSH
118724: LD_VAR 0 7
118728: ARRAY
118729: PPUSH
118730: LD_VAR 0 8
118734: PUSH
118735: LD_INT 1
118737: ARRAY
118738: PPUSH
118739: LD_VAR 0 8
118743: PUSH
118744: LD_INT 2
118746: ARRAY
118747: PPUSH
118748: CALL_OW 116
// attacking := true ;
118752: LD_ADDR_VAR 0 29
118756: PUSH
118757: LD_INT 1
118759: ST_TO_ADDR
// continue ;
118760: GO 116135
// end ; end else
118762: GO 118788
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118764: LD_VAR 0 4
118768: PUSH
118769: LD_VAR 0 7
118773: ARRAY
118774: PPUSH
118775: LD_VAR 0 14
118779: PUSH
118780: LD_INT 1
118782: ARRAY
118783: PPUSH
118784: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
118788: LD_VAR 0 4
118792: PUSH
118793: LD_VAR 0 7
118797: ARRAY
118798: PPUSH
118799: CALL_OW 265
118803: PUSH
118804: LD_INT 11
118806: EQUAL
118807: IFFALSE 119085
// begin k := 10 ;
118809: LD_ADDR_VAR 0 9
118813: PUSH
118814: LD_INT 10
118816: ST_TO_ADDR
// x := 0 ;
118817: LD_ADDR_VAR 0 10
118821: PUSH
118822: LD_INT 0
118824: ST_TO_ADDR
// if tmp < k then
118825: LD_VAR 0 14
118829: PUSH
118830: LD_VAR 0 9
118834: LESS
118835: IFFALSE 118847
// k := tmp ;
118837: LD_ADDR_VAR 0 9
118841: PUSH
118842: LD_VAR 0 14
118846: ST_TO_ADDR
// for j = k downto 1 do
118847: LD_ADDR_VAR 0 8
118851: PUSH
118852: DOUBLE
118853: LD_VAR 0 9
118857: INC
118858: ST_TO_ADDR
118859: LD_INT 1
118861: PUSH
118862: FOR_DOWNTO
118863: IFFALSE 118938
// begin if GetType ( tmp [ j ] ) = unit_human then
118865: LD_VAR 0 14
118869: PUSH
118870: LD_VAR 0 8
118874: ARRAY
118875: PPUSH
118876: CALL_OW 247
118880: PUSH
118881: LD_INT 1
118883: EQUAL
118884: IFFALSE 118936
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
118886: LD_VAR 0 4
118890: PUSH
118891: LD_VAR 0 7
118895: ARRAY
118896: PPUSH
118897: LD_VAR 0 14
118901: PUSH
118902: LD_VAR 0 8
118906: ARRAY
118907: PPUSH
118908: CALL 86208 0 2
// x := tmp [ j ] ;
118912: LD_ADDR_VAR 0 10
118916: PUSH
118917: LD_VAR 0 14
118921: PUSH
118922: LD_VAR 0 8
118926: ARRAY
118927: ST_TO_ADDR
// attacking := true ;
118928: LD_ADDR_VAR 0 29
118932: PUSH
118933: LD_INT 1
118935: ST_TO_ADDR
// end ; end ;
118936: GO 118862
118938: POP
118939: POP
// if not x then
118940: LD_VAR 0 10
118944: NOT
118945: IFFALSE 119085
// begin attacking := true ;
118947: LD_ADDR_VAR 0 29
118951: PUSH
118952: LD_INT 1
118954: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
118955: LD_VAR 0 4
118959: PUSH
118960: LD_VAR 0 7
118964: ARRAY
118965: PPUSH
118966: CALL_OW 250
118970: PPUSH
118971: LD_VAR 0 4
118975: PUSH
118976: LD_VAR 0 7
118980: ARRAY
118981: PPUSH
118982: CALL_OW 251
118986: PPUSH
118987: CALL_OW 546
118991: PUSH
118992: LD_INT 2
118994: ARRAY
118995: PUSH
118996: LD_VAR 0 14
119000: PUSH
119001: LD_INT 1
119003: ARRAY
119004: PPUSH
119005: CALL_OW 250
119009: PPUSH
119010: LD_VAR 0 14
119014: PUSH
119015: LD_INT 1
119017: ARRAY
119018: PPUSH
119019: CALL_OW 251
119023: PPUSH
119024: CALL_OW 546
119028: PUSH
119029: LD_INT 2
119031: ARRAY
119032: EQUAL
119033: IFFALSE 119061
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
119035: LD_VAR 0 4
119039: PUSH
119040: LD_VAR 0 7
119044: ARRAY
119045: PPUSH
119046: LD_VAR 0 14
119050: PUSH
119051: LD_INT 1
119053: ARRAY
119054: PPUSH
119055: CALL 86208 0 2
119059: GO 119085
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119061: LD_VAR 0 4
119065: PUSH
119066: LD_VAR 0 7
119070: ARRAY
119071: PPUSH
119072: LD_VAR 0 14
119076: PUSH
119077: LD_INT 1
119079: ARRAY
119080: PPUSH
119081: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
119085: LD_VAR 0 4
119089: PUSH
119090: LD_VAR 0 7
119094: ARRAY
119095: PPUSH
119096: CALL_OW 264
119100: PUSH
119101: LD_INT 29
119103: EQUAL
119104: IFFALSE 119470
// begin if WantsToAttack ( group [ i ] ) in bombed then
119106: LD_VAR 0 4
119110: PUSH
119111: LD_VAR 0 7
119115: ARRAY
119116: PPUSH
119117: CALL_OW 319
119121: PUSH
119122: LD_VAR 0 28
119126: IN
119127: IFFALSE 119131
// continue ;
119129: GO 116135
// k := 8 ;
119131: LD_ADDR_VAR 0 9
119135: PUSH
119136: LD_INT 8
119138: ST_TO_ADDR
// x := 0 ;
119139: LD_ADDR_VAR 0 10
119143: PUSH
119144: LD_INT 0
119146: ST_TO_ADDR
// if tmp < k then
119147: LD_VAR 0 14
119151: PUSH
119152: LD_VAR 0 9
119156: LESS
119157: IFFALSE 119169
// k := tmp ;
119159: LD_ADDR_VAR 0 9
119163: PUSH
119164: LD_VAR 0 14
119168: ST_TO_ADDR
// for j = 1 to k do
119169: LD_ADDR_VAR 0 8
119173: PUSH
119174: DOUBLE
119175: LD_INT 1
119177: DEC
119178: ST_TO_ADDR
119179: LD_VAR 0 9
119183: PUSH
119184: FOR_TO
119185: IFFALSE 119317
// begin if GetType ( tmp [ j ] ) = unit_building then
119187: LD_VAR 0 14
119191: PUSH
119192: LD_VAR 0 8
119196: ARRAY
119197: PPUSH
119198: CALL_OW 247
119202: PUSH
119203: LD_INT 3
119205: EQUAL
119206: IFFALSE 119315
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
119208: LD_VAR 0 14
119212: PUSH
119213: LD_VAR 0 8
119217: ARRAY
119218: PUSH
119219: LD_VAR 0 28
119223: IN
119224: NOT
119225: PUSH
119226: LD_VAR 0 14
119230: PUSH
119231: LD_VAR 0 8
119235: ARRAY
119236: PPUSH
119237: CALL_OW 313
119241: AND
119242: IFFALSE 119315
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119244: LD_VAR 0 4
119248: PUSH
119249: LD_VAR 0 7
119253: ARRAY
119254: PPUSH
119255: LD_VAR 0 14
119259: PUSH
119260: LD_VAR 0 8
119264: ARRAY
119265: PPUSH
119266: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
119270: LD_ADDR_VAR 0 28
119274: PUSH
119275: LD_VAR 0 28
119279: PPUSH
119280: LD_VAR 0 28
119284: PUSH
119285: LD_INT 1
119287: PLUS
119288: PPUSH
119289: LD_VAR 0 14
119293: PUSH
119294: LD_VAR 0 8
119298: ARRAY
119299: PPUSH
119300: CALL_OW 1
119304: ST_TO_ADDR
// attacking := true ;
119305: LD_ADDR_VAR 0 29
119309: PUSH
119310: LD_INT 1
119312: ST_TO_ADDR
// break ;
119313: GO 119317
// end ; end ;
119315: GO 119184
119317: POP
119318: POP
// if not attacking and f_attack_depot then
119319: LD_VAR 0 29
119323: NOT
119324: PUSH
119325: LD_VAR 0 25
119329: AND
119330: IFFALSE 119425
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119332: LD_ADDR_VAR 0 13
119336: PUSH
119337: LD_VAR 0 14
119341: PPUSH
119342: LD_INT 2
119344: PUSH
119345: LD_INT 30
119347: PUSH
119348: LD_INT 0
119350: PUSH
119351: EMPTY
119352: LIST
119353: LIST
119354: PUSH
119355: LD_INT 30
119357: PUSH
119358: LD_INT 1
119360: PUSH
119361: EMPTY
119362: LIST
119363: LIST
119364: PUSH
119365: EMPTY
119366: LIST
119367: LIST
119368: LIST
119369: PPUSH
119370: CALL_OW 72
119374: ST_TO_ADDR
// if z then
119375: LD_VAR 0 13
119379: IFFALSE 119425
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
119381: LD_VAR 0 4
119385: PUSH
119386: LD_VAR 0 7
119390: ARRAY
119391: PPUSH
119392: LD_VAR 0 13
119396: PPUSH
119397: LD_VAR 0 4
119401: PUSH
119402: LD_VAR 0 7
119406: ARRAY
119407: PPUSH
119408: CALL_OW 74
119412: PPUSH
119413: CALL_OW 115
// attacking := true ;
119417: LD_ADDR_VAR 0 29
119421: PUSH
119422: LD_INT 1
119424: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
119425: LD_VAR 0 4
119429: PUSH
119430: LD_VAR 0 7
119434: ARRAY
119435: PPUSH
119436: CALL_OW 256
119440: PUSH
119441: LD_INT 500
119443: LESS
119444: IFFALSE 119470
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119446: LD_VAR 0 4
119450: PUSH
119451: LD_VAR 0 7
119455: ARRAY
119456: PPUSH
119457: LD_VAR 0 14
119461: PUSH
119462: LD_INT 1
119464: ARRAY
119465: PPUSH
119466: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
119470: LD_VAR 0 4
119474: PUSH
119475: LD_VAR 0 7
119479: ARRAY
119480: PPUSH
119481: CALL_OW 264
119485: PUSH
119486: LD_INT 49
119488: EQUAL
119489: IFFALSE 119610
// begin if not HasTask ( group [ i ] ) then
119491: LD_VAR 0 4
119495: PUSH
119496: LD_VAR 0 7
119500: ARRAY
119501: PPUSH
119502: CALL_OW 314
119506: NOT
119507: IFFALSE 119610
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
119509: LD_ADDR_VAR 0 9
119513: PUSH
119514: LD_INT 81
119516: PUSH
119517: LD_VAR 0 4
119521: PUSH
119522: LD_VAR 0 7
119526: ARRAY
119527: PPUSH
119528: CALL_OW 255
119532: PUSH
119533: EMPTY
119534: LIST
119535: LIST
119536: PPUSH
119537: CALL_OW 69
119541: PPUSH
119542: LD_VAR 0 4
119546: PUSH
119547: LD_VAR 0 7
119551: ARRAY
119552: PPUSH
119553: CALL_OW 74
119557: ST_TO_ADDR
// if k then
119558: LD_VAR 0 9
119562: IFFALSE 119610
// if GetDistUnits ( group [ i ] , k ) > 10 then
119564: LD_VAR 0 4
119568: PUSH
119569: LD_VAR 0 7
119573: ARRAY
119574: PPUSH
119575: LD_VAR 0 9
119579: PPUSH
119580: CALL_OW 296
119584: PUSH
119585: LD_INT 10
119587: GREATER
119588: IFFALSE 119610
// ComMoveUnit ( group [ i ] , k ) ;
119590: LD_VAR 0 4
119594: PUSH
119595: LD_VAR 0 7
119599: ARRAY
119600: PPUSH
119601: LD_VAR 0 9
119605: PPUSH
119606: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
119610: LD_VAR 0 4
119614: PUSH
119615: LD_VAR 0 7
119619: ARRAY
119620: PPUSH
119621: CALL_OW 256
119625: PUSH
119626: LD_INT 250
119628: LESS
119629: PUSH
119630: LD_VAR 0 4
119634: PUSH
119635: LD_VAR 0 7
119639: ARRAY
119640: PUSH
119641: LD_INT 21
119643: PUSH
119644: LD_INT 2
119646: PUSH
119647: EMPTY
119648: LIST
119649: LIST
119650: PUSH
119651: LD_INT 23
119653: PUSH
119654: LD_INT 2
119656: PUSH
119657: EMPTY
119658: LIST
119659: LIST
119660: PUSH
119661: EMPTY
119662: LIST
119663: LIST
119664: PPUSH
119665: CALL_OW 69
119669: IN
119670: AND
119671: IFFALSE 119796
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
119673: LD_ADDR_VAR 0 9
119677: PUSH
119678: LD_OWVAR 3
119682: PUSH
119683: LD_VAR 0 4
119687: PUSH
119688: LD_VAR 0 7
119692: ARRAY
119693: DIFF
119694: PPUSH
119695: LD_VAR 0 4
119699: PUSH
119700: LD_VAR 0 7
119704: ARRAY
119705: PPUSH
119706: CALL_OW 74
119710: ST_TO_ADDR
// if not k then
119711: LD_VAR 0 9
119715: NOT
119716: IFFALSE 119720
// continue ;
119718: GO 116135
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
119720: LD_VAR 0 9
119724: PUSH
119725: LD_INT 81
119727: PUSH
119728: LD_VAR 0 4
119732: PUSH
119733: LD_VAR 0 7
119737: ARRAY
119738: PPUSH
119739: CALL_OW 255
119743: PUSH
119744: EMPTY
119745: LIST
119746: LIST
119747: PPUSH
119748: CALL_OW 69
119752: IN
119753: PUSH
119754: LD_VAR 0 9
119758: PPUSH
119759: LD_VAR 0 4
119763: PUSH
119764: LD_VAR 0 7
119768: ARRAY
119769: PPUSH
119770: CALL_OW 296
119774: PUSH
119775: LD_INT 5
119777: LESS
119778: AND
119779: IFFALSE 119796
// ComAutodestruct ( group [ i ] ) ;
119781: LD_VAR 0 4
119785: PUSH
119786: LD_VAR 0 7
119790: ARRAY
119791: PPUSH
119792: CALL 86106 0 1
// end ; if f_attack_depot then
119796: LD_VAR 0 25
119800: IFFALSE 119912
// begin k := 6 ;
119802: LD_ADDR_VAR 0 9
119806: PUSH
119807: LD_INT 6
119809: ST_TO_ADDR
// if tmp < k then
119810: LD_VAR 0 14
119814: PUSH
119815: LD_VAR 0 9
119819: LESS
119820: IFFALSE 119832
// k := tmp ;
119822: LD_ADDR_VAR 0 9
119826: PUSH
119827: LD_VAR 0 14
119831: ST_TO_ADDR
// for j = 1 to k do
119832: LD_ADDR_VAR 0 8
119836: PUSH
119837: DOUBLE
119838: LD_INT 1
119840: DEC
119841: ST_TO_ADDR
119842: LD_VAR 0 9
119846: PUSH
119847: FOR_TO
119848: IFFALSE 119910
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
119850: LD_VAR 0 8
119854: PPUSH
119855: CALL_OW 266
119859: PUSH
119860: LD_INT 0
119862: PUSH
119863: LD_INT 1
119865: PUSH
119866: EMPTY
119867: LIST
119868: LIST
119869: IN
119870: IFFALSE 119908
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119872: LD_VAR 0 4
119876: PUSH
119877: LD_VAR 0 7
119881: ARRAY
119882: PPUSH
119883: LD_VAR 0 14
119887: PUSH
119888: LD_VAR 0 8
119892: ARRAY
119893: PPUSH
119894: CALL_OW 115
// attacking := true ;
119898: LD_ADDR_VAR 0 29
119902: PUSH
119903: LD_INT 1
119905: ST_TO_ADDR
// break ;
119906: GO 119910
// end ;
119908: GO 119847
119910: POP
119911: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
119912: LD_VAR 0 4
119916: PUSH
119917: LD_VAR 0 7
119921: ARRAY
119922: PPUSH
119923: CALL_OW 302
119927: PUSH
119928: LD_VAR 0 29
119932: NOT
119933: AND
119934: IFFALSE 120256
// begin if GetTag ( group [ i ] ) = 71 then
119936: LD_VAR 0 4
119940: PUSH
119941: LD_VAR 0 7
119945: ARRAY
119946: PPUSH
119947: CALL_OW 110
119951: PUSH
119952: LD_INT 71
119954: EQUAL
119955: IFFALSE 119996
// begin if HasTask ( group [ i ] ) then
119957: LD_VAR 0 4
119961: PUSH
119962: LD_VAR 0 7
119966: ARRAY
119967: PPUSH
119968: CALL_OW 314
119972: IFFALSE 119978
// continue else
119974: GO 116135
119976: GO 119996
// SetTag ( group [ i ] , 0 ) ;
119978: LD_VAR 0 4
119982: PUSH
119983: LD_VAR 0 7
119987: ARRAY
119988: PPUSH
119989: LD_INT 0
119991: PPUSH
119992: CALL_OW 109
// end ; k := 8 ;
119996: LD_ADDR_VAR 0 9
120000: PUSH
120001: LD_INT 8
120003: ST_TO_ADDR
// x := 0 ;
120004: LD_ADDR_VAR 0 10
120008: PUSH
120009: LD_INT 0
120011: ST_TO_ADDR
// if tmp < k then
120012: LD_VAR 0 14
120016: PUSH
120017: LD_VAR 0 9
120021: LESS
120022: IFFALSE 120034
// k := tmp ;
120024: LD_ADDR_VAR 0 9
120028: PUSH
120029: LD_VAR 0 14
120033: ST_TO_ADDR
// for j = 1 to k do
120034: LD_ADDR_VAR 0 8
120038: PUSH
120039: DOUBLE
120040: LD_INT 1
120042: DEC
120043: ST_TO_ADDR
120044: LD_VAR 0 9
120048: PUSH
120049: FOR_TO
120050: IFFALSE 120148
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
120052: LD_VAR 0 14
120056: PUSH
120057: LD_VAR 0 8
120061: ARRAY
120062: PPUSH
120063: CALL_OW 247
120067: PUSH
120068: LD_INT 1
120070: EQUAL
120071: PUSH
120072: LD_VAR 0 14
120076: PUSH
120077: LD_VAR 0 8
120081: ARRAY
120082: PPUSH
120083: CALL_OW 256
120087: PUSH
120088: LD_INT 250
120090: LESS
120091: PUSH
120092: LD_VAR 0 20
120096: AND
120097: PUSH
120098: LD_VAR 0 20
120102: NOT
120103: PUSH
120104: LD_VAR 0 14
120108: PUSH
120109: LD_VAR 0 8
120113: ARRAY
120114: PPUSH
120115: CALL_OW 256
120119: PUSH
120120: LD_INT 250
120122: GREATEREQUAL
120123: AND
120124: OR
120125: AND
120126: IFFALSE 120146
// begin x := tmp [ j ] ;
120128: LD_ADDR_VAR 0 10
120132: PUSH
120133: LD_VAR 0 14
120137: PUSH
120138: LD_VAR 0 8
120142: ARRAY
120143: ST_TO_ADDR
// break ;
120144: GO 120148
// end ;
120146: GO 120049
120148: POP
120149: POP
// if x then
120150: LD_VAR 0 10
120154: IFFALSE 120178
// ComAttackUnit ( group [ i ] , x ) else
120156: LD_VAR 0 4
120160: PUSH
120161: LD_VAR 0 7
120165: ARRAY
120166: PPUSH
120167: LD_VAR 0 10
120171: PPUSH
120172: CALL_OW 115
120176: GO 120202
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120178: LD_VAR 0 4
120182: PUSH
120183: LD_VAR 0 7
120187: ARRAY
120188: PPUSH
120189: LD_VAR 0 14
120193: PUSH
120194: LD_INT 1
120196: ARRAY
120197: PPUSH
120198: CALL_OW 115
// if not HasTask ( group [ i ] ) then
120202: LD_VAR 0 4
120206: PUSH
120207: LD_VAR 0 7
120211: ARRAY
120212: PPUSH
120213: CALL_OW 314
120217: NOT
120218: IFFALSE 120256
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
120220: LD_VAR 0 4
120224: PUSH
120225: LD_VAR 0 7
120229: ARRAY
120230: PPUSH
120231: LD_VAR 0 14
120235: PPUSH
120236: LD_VAR 0 4
120240: PUSH
120241: LD_VAR 0 7
120245: ARRAY
120246: PPUSH
120247: CALL_OW 74
120251: PPUSH
120252: CALL_OW 115
// end ; end ; end ;
120256: GO 116135
120258: POP
120259: POP
// wait ( 0 0$2 ) ;
120260: LD_INT 70
120262: PPUSH
120263: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
120267: LD_VAR 0 4
120271: NOT
120272: PUSH
120273: LD_VAR 0 4
120277: PUSH
120278: EMPTY
120279: EQUAL
120280: OR
120281: PUSH
120282: LD_INT 81
120284: PUSH
120285: LD_VAR 0 35
120289: PUSH
120290: EMPTY
120291: LIST
120292: LIST
120293: PPUSH
120294: CALL_OW 69
120298: NOT
120299: OR
120300: IFFALSE 116120
// end ;
120302: LD_VAR 0 2
120306: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
120307: LD_INT 0
120309: PPUSH
120310: PPUSH
120311: PPUSH
120312: PPUSH
120313: PPUSH
120314: PPUSH
// if not base or not mc_bases [ base ] or not solds then
120315: LD_VAR 0 1
120319: NOT
120320: PUSH
120321: LD_EXP 78
120325: PUSH
120326: LD_VAR 0 1
120330: ARRAY
120331: NOT
120332: OR
120333: PUSH
120334: LD_VAR 0 2
120338: NOT
120339: OR
120340: IFFALSE 120344
// exit ;
120342: GO 120898
// side := mc_sides [ base ] ;
120344: LD_ADDR_VAR 0 6
120348: PUSH
120349: LD_EXP 104
120353: PUSH
120354: LD_VAR 0 1
120358: ARRAY
120359: ST_TO_ADDR
// if not side then
120360: LD_VAR 0 6
120364: NOT
120365: IFFALSE 120369
// exit ;
120367: GO 120898
// for i in solds do
120369: LD_ADDR_VAR 0 7
120373: PUSH
120374: LD_VAR 0 2
120378: PUSH
120379: FOR_IN
120380: IFFALSE 120441
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
120382: LD_VAR 0 7
120386: PPUSH
120387: CALL_OW 310
120391: PPUSH
120392: CALL_OW 266
120396: PUSH
120397: LD_INT 32
120399: PUSH
120400: LD_INT 31
120402: PUSH
120403: EMPTY
120404: LIST
120405: LIST
120406: IN
120407: IFFALSE 120427
// solds := solds diff i else
120409: LD_ADDR_VAR 0 2
120413: PUSH
120414: LD_VAR 0 2
120418: PUSH
120419: LD_VAR 0 7
120423: DIFF
120424: ST_TO_ADDR
120425: GO 120439
// SetTag ( i , 18 ) ;
120427: LD_VAR 0 7
120431: PPUSH
120432: LD_INT 18
120434: PPUSH
120435: CALL_OW 109
120439: GO 120379
120441: POP
120442: POP
// if not solds then
120443: LD_VAR 0 2
120447: NOT
120448: IFFALSE 120452
// exit ;
120450: GO 120898
// repeat wait ( 0 0$2 ) ;
120452: LD_INT 70
120454: PPUSH
120455: CALL_OW 67
// enemy := mc_scan [ base ] ;
120459: LD_ADDR_VAR 0 4
120463: PUSH
120464: LD_EXP 101
120468: PUSH
120469: LD_VAR 0 1
120473: ARRAY
120474: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120475: LD_EXP 78
120479: PUSH
120480: LD_VAR 0 1
120484: ARRAY
120485: NOT
120486: PUSH
120487: LD_EXP 78
120491: PUSH
120492: LD_VAR 0 1
120496: ARRAY
120497: PUSH
120498: EMPTY
120499: EQUAL
120500: OR
120501: IFFALSE 120538
// begin for i in solds do
120503: LD_ADDR_VAR 0 7
120507: PUSH
120508: LD_VAR 0 2
120512: PUSH
120513: FOR_IN
120514: IFFALSE 120527
// ComStop ( i ) ;
120516: LD_VAR 0 7
120520: PPUSH
120521: CALL_OW 141
120525: GO 120513
120527: POP
120528: POP
// solds := [ ] ;
120529: LD_ADDR_VAR 0 2
120533: PUSH
120534: EMPTY
120535: ST_TO_ADDR
// exit ;
120536: GO 120898
// end ; for i in solds do
120538: LD_ADDR_VAR 0 7
120542: PUSH
120543: LD_VAR 0 2
120547: PUSH
120548: FOR_IN
120549: IFFALSE 120870
// begin if IsInUnit ( i ) then
120551: LD_VAR 0 7
120555: PPUSH
120556: CALL_OW 310
120560: IFFALSE 120571
// ComExitBuilding ( i ) ;
120562: LD_VAR 0 7
120566: PPUSH
120567: CALL_OW 122
// if GetLives ( i ) > 500 then
120571: LD_VAR 0 7
120575: PPUSH
120576: CALL_OW 256
120580: PUSH
120581: LD_INT 500
120583: GREATER
120584: IFFALSE 120637
// begin e := NearestUnitToUnit ( enemy , i ) ;
120586: LD_ADDR_VAR 0 5
120590: PUSH
120591: LD_VAR 0 4
120595: PPUSH
120596: LD_VAR 0 7
120600: PPUSH
120601: CALL_OW 74
120605: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
120606: LD_VAR 0 7
120610: PPUSH
120611: LD_VAR 0 5
120615: PPUSH
120616: CALL_OW 250
120620: PPUSH
120621: LD_VAR 0 5
120625: PPUSH
120626: CALL_OW 251
120630: PPUSH
120631: CALL_OW 114
// end else
120635: GO 120868
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
120637: LD_VAR 0 7
120641: PPUSH
120642: LD_EXP 78
120646: PUSH
120647: LD_VAR 0 1
120651: ARRAY
120652: PPUSH
120653: LD_INT 2
120655: PUSH
120656: LD_INT 30
120658: PUSH
120659: LD_INT 0
120661: PUSH
120662: EMPTY
120663: LIST
120664: LIST
120665: PUSH
120666: LD_INT 30
120668: PUSH
120669: LD_INT 1
120671: PUSH
120672: EMPTY
120673: LIST
120674: LIST
120675: PUSH
120676: LD_INT 30
120678: PUSH
120679: LD_INT 6
120681: PUSH
120682: EMPTY
120683: LIST
120684: LIST
120685: PUSH
120686: EMPTY
120687: LIST
120688: LIST
120689: LIST
120690: LIST
120691: PPUSH
120692: CALL_OW 72
120696: PPUSH
120697: LD_VAR 0 7
120701: PPUSH
120702: CALL_OW 74
120706: PPUSH
120707: CALL_OW 296
120711: PUSH
120712: LD_INT 10
120714: GREATER
120715: IFFALSE 120868
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
120717: LD_ADDR_VAR 0 8
120721: PUSH
120722: LD_EXP 78
120726: PUSH
120727: LD_VAR 0 1
120731: ARRAY
120732: PPUSH
120733: LD_INT 2
120735: PUSH
120736: LD_INT 30
120738: PUSH
120739: LD_INT 0
120741: PUSH
120742: EMPTY
120743: LIST
120744: LIST
120745: PUSH
120746: LD_INT 30
120748: PUSH
120749: LD_INT 1
120751: PUSH
120752: EMPTY
120753: LIST
120754: LIST
120755: PUSH
120756: LD_INT 30
120758: PUSH
120759: LD_INT 6
120761: PUSH
120762: EMPTY
120763: LIST
120764: LIST
120765: PUSH
120766: EMPTY
120767: LIST
120768: LIST
120769: LIST
120770: LIST
120771: PPUSH
120772: CALL_OW 72
120776: PPUSH
120777: LD_VAR 0 7
120781: PPUSH
120782: CALL_OW 74
120786: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
120787: LD_VAR 0 7
120791: PPUSH
120792: LD_VAR 0 8
120796: PPUSH
120797: CALL_OW 250
120801: PPUSH
120802: LD_INT 3
120804: PPUSH
120805: LD_INT 5
120807: PPUSH
120808: CALL_OW 272
120812: PPUSH
120813: LD_VAR 0 8
120817: PPUSH
120818: CALL_OW 251
120822: PPUSH
120823: LD_INT 3
120825: PPUSH
120826: LD_INT 5
120828: PPUSH
120829: CALL_OW 273
120833: PPUSH
120834: CALL_OW 111
// SetTag ( i , 0 ) ;
120838: LD_VAR 0 7
120842: PPUSH
120843: LD_INT 0
120845: PPUSH
120846: CALL_OW 109
// solds := solds diff i ;
120850: LD_ADDR_VAR 0 2
120854: PUSH
120855: LD_VAR 0 2
120859: PUSH
120860: LD_VAR 0 7
120864: DIFF
120865: ST_TO_ADDR
// continue ;
120866: GO 120548
// end ; end ;
120868: GO 120548
120870: POP
120871: POP
// until not solds or not enemy ;
120872: LD_VAR 0 2
120876: NOT
120877: PUSH
120878: LD_VAR 0 4
120882: NOT
120883: OR
120884: IFFALSE 120452
// MC_Reset ( base , 18 ) ;
120886: LD_VAR 0 1
120890: PPUSH
120891: LD_INT 18
120893: PPUSH
120894: CALL 26364 0 2
// end ;
120898: LD_VAR 0 3
120902: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
120903: LD_INT 0
120905: PPUSH
120906: PPUSH
120907: PPUSH
120908: PPUSH
120909: PPUSH
120910: PPUSH
120911: PPUSH
120912: PPUSH
120913: PPUSH
120914: PPUSH
120915: PPUSH
120916: PPUSH
120917: PPUSH
120918: PPUSH
120919: PPUSH
120920: PPUSH
120921: PPUSH
120922: PPUSH
120923: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
120924: LD_ADDR_VAR 0 12
120928: PUSH
120929: LD_EXP 78
120933: PUSH
120934: LD_VAR 0 1
120938: ARRAY
120939: PPUSH
120940: LD_INT 25
120942: PUSH
120943: LD_INT 3
120945: PUSH
120946: EMPTY
120947: LIST
120948: LIST
120949: PPUSH
120950: CALL_OW 72
120954: ST_TO_ADDR
// if mc_remote_driver [ base ] then
120955: LD_EXP 118
120959: PUSH
120960: LD_VAR 0 1
120964: ARRAY
120965: IFFALSE 120989
// mechs := mechs diff mc_remote_driver [ base ] ;
120967: LD_ADDR_VAR 0 12
120971: PUSH
120972: LD_VAR 0 12
120976: PUSH
120977: LD_EXP 118
120981: PUSH
120982: LD_VAR 0 1
120986: ARRAY
120987: DIFF
120988: ST_TO_ADDR
// for i in mechs do
120989: LD_ADDR_VAR 0 4
120993: PUSH
120994: LD_VAR 0 12
120998: PUSH
120999: FOR_IN
121000: IFFALSE 121035
// if GetTag ( i ) > 0 then
121002: LD_VAR 0 4
121006: PPUSH
121007: CALL_OW 110
121011: PUSH
121012: LD_INT 0
121014: GREATER
121015: IFFALSE 121033
// mechs := mechs diff i ;
121017: LD_ADDR_VAR 0 12
121021: PUSH
121022: LD_VAR 0 12
121026: PUSH
121027: LD_VAR 0 4
121031: DIFF
121032: ST_TO_ADDR
121033: GO 120999
121035: POP
121036: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
121037: LD_ADDR_VAR 0 8
121041: PUSH
121042: LD_EXP 78
121046: PUSH
121047: LD_VAR 0 1
121051: ARRAY
121052: PPUSH
121053: LD_INT 2
121055: PUSH
121056: LD_INT 25
121058: PUSH
121059: LD_INT 1
121061: PUSH
121062: EMPTY
121063: LIST
121064: LIST
121065: PUSH
121066: LD_INT 25
121068: PUSH
121069: LD_INT 5
121071: PUSH
121072: EMPTY
121073: LIST
121074: LIST
121075: PUSH
121076: LD_INT 25
121078: PUSH
121079: LD_INT 8
121081: PUSH
121082: EMPTY
121083: LIST
121084: LIST
121085: PUSH
121086: LD_INT 25
121088: PUSH
121089: LD_INT 9
121091: PUSH
121092: EMPTY
121093: LIST
121094: LIST
121095: PUSH
121096: EMPTY
121097: LIST
121098: LIST
121099: LIST
121100: LIST
121101: LIST
121102: PPUSH
121103: CALL_OW 72
121107: ST_TO_ADDR
// if not defenders and not solds then
121108: LD_VAR 0 2
121112: NOT
121113: PUSH
121114: LD_VAR 0 8
121118: NOT
121119: AND
121120: IFFALSE 121124
// exit ;
121122: GO 122894
// depot_under_attack := false ;
121124: LD_ADDR_VAR 0 16
121128: PUSH
121129: LD_INT 0
121131: ST_TO_ADDR
// sold_defenders := [ ] ;
121132: LD_ADDR_VAR 0 17
121136: PUSH
121137: EMPTY
121138: ST_TO_ADDR
// if mechs then
121139: LD_VAR 0 12
121143: IFFALSE 121296
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
121145: LD_ADDR_VAR 0 4
121149: PUSH
121150: LD_VAR 0 2
121154: PPUSH
121155: LD_INT 21
121157: PUSH
121158: LD_INT 2
121160: PUSH
121161: EMPTY
121162: LIST
121163: LIST
121164: PPUSH
121165: CALL_OW 72
121169: PUSH
121170: FOR_IN
121171: IFFALSE 121294
// begin if GetTag ( i ) <> 20 then
121173: LD_VAR 0 4
121177: PPUSH
121178: CALL_OW 110
121182: PUSH
121183: LD_INT 20
121185: NONEQUAL
121186: IFFALSE 121200
// SetTag ( i , 20 ) ;
121188: LD_VAR 0 4
121192: PPUSH
121193: LD_INT 20
121195: PPUSH
121196: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
121200: LD_VAR 0 4
121204: PPUSH
121205: CALL_OW 263
121209: PUSH
121210: LD_INT 1
121212: EQUAL
121213: PUSH
121214: LD_VAR 0 4
121218: PPUSH
121219: CALL_OW 311
121223: NOT
121224: AND
121225: IFFALSE 121292
// begin un := mechs [ 1 ] ;
121227: LD_ADDR_VAR 0 10
121231: PUSH
121232: LD_VAR 0 12
121236: PUSH
121237: LD_INT 1
121239: ARRAY
121240: ST_TO_ADDR
// ComExit ( un ) ;
121241: LD_VAR 0 10
121245: PPUSH
121246: CALL 91003 0 1
// AddComEnterUnit ( un , i ) ;
121250: LD_VAR 0 10
121254: PPUSH
121255: LD_VAR 0 4
121259: PPUSH
121260: CALL_OW 180
// SetTag ( un , 19 ) ;
121264: LD_VAR 0 10
121268: PPUSH
121269: LD_INT 19
121271: PPUSH
121272: CALL_OW 109
// mechs := mechs diff un ;
121276: LD_ADDR_VAR 0 12
121280: PUSH
121281: LD_VAR 0 12
121285: PUSH
121286: LD_VAR 0 10
121290: DIFF
121291: ST_TO_ADDR
// end ; end ;
121292: GO 121170
121294: POP
121295: POP
// if solds then
121296: LD_VAR 0 8
121300: IFFALSE 121359
// for i in solds do
121302: LD_ADDR_VAR 0 4
121306: PUSH
121307: LD_VAR 0 8
121311: PUSH
121312: FOR_IN
121313: IFFALSE 121357
// if not GetTag ( i ) then
121315: LD_VAR 0 4
121319: PPUSH
121320: CALL_OW 110
121324: NOT
121325: IFFALSE 121355
// begin defenders := defenders union i ;
121327: LD_ADDR_VAR 0 2
121331: PUSH
121332: LD_VAR 0 2
121336: PUSH
121337: LD_VAR 0 4
121341: UNION
121342: ST_TO_ADDR
// SetTag ( i , 18 ) ;
121343: LD_VAR 0 4
121347: PPUSH
121348: LD_INT 18
121350: PPUSH
121351: CALL_OW 109
// end ;
121355: GO 121312
121357: POP
121358: POP
// repeat wait ( 0 0$2 ) ;
121359: LD_INT 70
121361: PPUSH
121362: CALL_OW 67
// enemy := mc_scan [ base ] ;
121366: LD_ADDR_VAR 0 21
121370: PUSH
121371: LD_EXP 101
121375: PUSH
121376: LD_VAR 0 1
121380: ARRAY
121381: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121382: LD_EXP 78
121386: PUSH
121387: LD_VAR 0 1
121391: ARRAY
121392: NOT
121393: PUSH
121394: LD_EXP 78
121398: PUSH
121399: LD_VAR 0 1
121403: ARRAY
121404: PUSH
121405: EMPTY
121406: EQUAL
121407: OR
121408: IFFALSE 121445
// begin for i in defenders do
121410: LD_ADDR_VAR 0 4
121414: PUSH
121415: LD_VAR 0 2
121419: PUSH
121420: FOR_IN
121421: IFFALSE 121434
// ComStop ( i ) ;
121423: LD_VAR 0 4
121427: PPUSH
121428: CALL_OW 141
121432: GO 121420
121434: POP
121435: POP
// defenders := [ ] ;
121436: LD_ADDR_VAR 0 2
121440: PUSH
121441: EMPTY
121442: ST_TO_ADDR
// exit ;
121443: GO 122894
// end ; for i in defenders do
121445: LD_ADDR_VAR 0 4
121449: PUSH
121450: LD_VAR 0 2
121454: PUSH
121455: FOR_IN
121456: IFFALSE 122354
// begin e := NearestUnitToUnit ( enemy , i ) ;
121458: LD_ADDR_VAR 0 13
121462: PUSH
121463: LD_VAR 0 21
121467: PPUSH
121468: LD_VAR 0 4
121472: PPUSH
121473: CALL_OW 74
121477: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
121478: LD_ADDR_VAR 0 7
121482: PUSH
121483: LD_EXP 78
121487: PUSH
121488: LD_VAR 0 1
121492: ARRAY
121493: PPUSH
121494: LD_INT 2
121496: PUSH
121497: LD_INT 30
121499: PUSH
121500: LD_INT 0
121502: PUSH
121503: EMPTY
121504: LIST
121505: LIST
121506: PUSH
121507: LD_INT 30
121509: PUSH
121510: LD_INT 1
121512: PUSH
121513: EMPTY
121514: LIST
121515: LIST
121516: PUSH
121517: EMPTY
121518: LIST
121519: LIST
121520: LIST
121521: PPUSH
121522: CALL_OW 72
121526: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
121527: LD_ADDR_VAR 0 16
121531: PUSH
121532: LD_VAR 0 7
121536: NOT
121537: PUSH
121538: LD_VAR 0 7
121542: PPUSH
121543: LD_INT 3
121545: PUSH
121546: LD_INT 24
121548: PUSH
121549: LD_INT 600
121551: PUSH
121552: EMPTY
121553: LIST
121554: LIST
121555: PUSH
121556: EMPTY
121557: LIST
121558: LIST
121559: PPUSH
121560: CALL_OW 72
121564: OR
121565: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
121566: LD_VAR 0 4
121570: PPUSH
121571: CALL_OW 247
121575: PUSH
121576: LD_INT 2
121578: DOUBLE
121579: EQUAL
121580: IFTRUE 121584
121582: GO 121980
121584: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
121585: LD_VAR 0 4
121589: PPUSH
121590: CALL_OW 256
121594: PUSH
121595: LD_INT 1000
121597: EQUAL
121598: PUSH
121599: LD_VAR 0 4
121603: PPUSH
121604: LD_VAR 0 13
121608: PPUSH
121609: CALL_OW 296
121613: PUSH
121614: LD_INT 40
121616: LESS
121617: PUSH
121618: LD_VAR 0 13
121622: PPUSH
121623: LD_EXP 103
121627: PUSH
121628: LD_VAR 0 1
121632: ARRAY
121633: PPUSH
121634: CALL_OW 308
121638: OR
121639: AND
121640: IFFALSE 121762
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
121642: LD_VAR 0 4
121646: PPUSH
121647: CALL_OW 262
121651: PUSH
121652: LD_INT 1
121654: EQUAL
121655: PUSH
121656: LD_VAR 0 4
121660: PPUSH
121661: CALL_OW 261
121665: PUSH
121666: LD_INT 30
121668: LESS
121669: AND
121670: PUSH
121671: LD_VAR 0 7
121675: AND
121676: IFFALSE 121746
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
121678: LD_VAR 0 4
121682: PPUSH
121683: LD_VAR 0 7
121687: PPUSH
121688: LD_VAR 0 4
121692: PPUSH
121693: CALL_OW 74
121697: PPUSH
121698: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
121702: LD_VAR 0 4
121706: PPUSH
121707: LD_VAR 0 7
121711: PPUSH
121712: LD_VAR 0 4
121716: PPUSH
121717: CALL_OW 74
121721: PPUSH
121722: CALL_OW 296
121726: PUSH
121727: LD_INT 6
121729: LESS
121730: IFFALSE 121744
// SetFuel ( i , 100 ) ;
121732: LD_VAR 0 4
121736: PPUSH
121737: LD_INT 100
121739: PPUSH
121740: CALL_OW 240
// end else
121744: GO 121760
// ComAttackUnit ( i , e ) ;
121746: LD_VAR 0 4
121750: PPUSH
121751: LD_VAR 0 13
121755: PPUSH
121756: CALL_OW 115
// end else
121760: GO 121863
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
121762: LD_VAR 0 13
121766: PPUSH
121767: LD_EXP 103
121771: PUSH
121772: LD_VAR 0 1
121776: ARRAY
121777: PPUSH
121778: CALL_OW 308
121782: NOT
121783: PUSH
121784: LD_VAR 0 4
121788: PPUSH
121789: LD_VAR 0 13
121793: PPUSH
121794: CALL_OW 296
121798: PUSH
121799: LD_INT 40
121801: GREATEREQUAL
121802: AND
121803: PUSH
121804: LD_VAR 0 4
121808: PPUSH
121809: CALL_OW 256
121813: PUSH
121814: LD_INT 650
121816: LESSEQUAL
121817: OR
121818: PUSH
121819: LD_VAR 0 4
121823: PPUSH
121824: LD_EXP 102
121828: PUSH
121829: LD_VAR 0 1
121833: ARRAY
121834: PPUSH
121835: CALL_OW 308
121839: NOT
121840: AND
121841: IFFALSE 121863
// ComMoveToArea ( i , mc_parking [ base ] ) ;
121843: LD_VAR 0 4
121847: PPUSH
121848: LD_EXP 102
121852: PUSH
121853: LD_VAR 0 1
121857: ARRAY
121858: PPUSH
121859: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
121863: LD_VAR 0 4
121867: PPUSH
121868: CALL_OW 256
121872: PUSH
121873: LD_INT 1000
121875: LESS
121876: PUSH
121877: LD_VAR 0 4
121881: PPUSH
121882: CALL_OW 263
121886: PUSH
121887: LD_INT 1
121889: EQUAL
121890: AND
121891: PUSH
121892: LD_VAR 0 4
121896: PPUSH
121897: CALL_OW 311
121901: AND
121902: PUSH
121903: LD_VAR 0 4
121907: PPUSH
121908: LD_EXP 102
121912: PUSH
121913: LD_VAR 0 1
121917: ARRAY
121918: PPUSH
121919: CALL_OW 308
121923: AND
121924: IFFALSE 121978
// begin mech := IsDrivenBy ( i ) ;
121926: LD_ADDR_VAR 0 9
121930: PUSH
121931: LD_VAR 0 4
121935: PPUSH
121936: CALL_OW 311
121940: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
121941: LD_VAR 0 9
121945: PPUSH
121946: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
121950: LD_VAR 0 9
121954: PPUSH
121955: LD_VAR 0 4
121959: PPUSH
121960: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
121964: LD_VAR 0 9
121968: PPUSH
121969: LD_VAR 0 4
121973: PPUSH
121974: CALL_OW 180
// end ; end ; unit_human :
121978: GO 122325
121980: LD_INT 1
121982: DOUBLE
121983: EQUAL
121984: IFTRUE 121988
121986: GO 122324
121988: POP
// begin b := IsInUnit ( i ) ;
121989: LD_ADDR_VAR 0 18
121993: PUSH
121994: LD_VAR 0 4
121998: PPUSH
121999: CALL_OW 310
122003: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
122004: LD_ADDR_VAR 0 19
122008: PUSH
122009: LD_VAR 0 18
122013: NOT
122014: PUSH
122015: LD_VAR 0 18
122019: PPUSH
122020: CALL_OW 266
122024: PUSH
122025: LD_INT 32
122027: PUSH
122028: LD_INT 31
122030: PUSH
122031: EMPTY
122032: LIST
122033: LIST
122034: IN
122035: OR
122036: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
122037: LD_VAR 0 18
122041: PPUSH
122042: CALL_OW 266
122046: PUSH
122047: LD_INT 5
122049: EQUAL
122050: PUSH
122051: LD_VAR 0 4
122055: PPUSH
122056: CALL_OW 257
122060: PUSH
122061: LD_INT 1
122063: PUSH
122064: LD_INT 2
122066: PUSH
122067: LD_INT 3
122069: PUSH
122070: LD_INT 4
122072: PUSH
122073: EMPTY
122074: LIST
122075: LIST
122076: LIST
122077: LIST
122078: IN
122079: AND
122080: IFFALSE 122117
// begin class := AllowSpecClass ( i ) ;
122082: LD_ADDR_VAR 0 20
122086: PUSH
122087: LD_VAR 0 4
122091: PPUSH
122092: CALL 54689 0 1
122096: ST_TO_ADDR
// if class then
122097: LD_VAR 0 20
122101: IFFALSE 122117
// ComChangeProfession ( i , class ) ;
122103: LD_VAR 0 4
122107: PPUSH
122108: LD_VAR 0 20
122112: PPUSH
122113: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
122117: LD_VAR 0 16
122121: PUSH
122122: LD_VAR 0 2
122126: PPUSH
122127: LD_INT 21
122129: PUSH
122130: LD_INT 2
122132: PUSH
122133: EMPTY
122134: LIST
122135: LIST
122136: PPUSH
122137: CALL_OW 72
122141: PUSH
122142: LD_INT 1
122144: LESSEQUAL
122145: OR
122146: PUSH
122147: LD_VAR 0 19
122151: AND
122152: PUSH
122153: LD_VAR 0 4
122157: PUSH
122158: LD_VAR 0 17
122162: IN
122163: NOT
122164: AND
122165: IFFALSE 122258
// begin if b then
122167: LD_VAR 0 18
122171: IFFALSE 122220
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
122173: LD_VAR 0 18
122177: PPUSH
122178: LD_VAR 0 21
122182: PPUSH
122183: LD_VAR 0 18
122187: PPUSH
122188: CALL_OW 74
122192: PPUSH
122193: CALL_OW 296
122197: PUSH
122198: LD_INT 10
122200: LESS
122201: PUSH
122202: LD_VAR 0 18
122206: PPUSH
122207: CALL_OW 461
122211: PUSH
122212: LD_INT 7
122214: NONEQUAL
122215: AND
122216: IFFALSE 122220
// continue ;
122218: GO 121455
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
122220: LD_ADDR_VAR 0 17
122224: PUSH
122225: LD_VAR 0 17
122229: PPUSH
122230: LD_VAR 0 17
122234: PUSH
122235: LD_INT 1
122237: PLUS
122238: PPUSH
122239: LD_VAR 0 4
122243: PPUSH
122244: CALL_OW 1
122248: ST_TO_ADDR
// ComExitBuilding ( i ) ;
122249: LD_VAR 0 4
122253: PPUSH
122254: CALL_OW 122
// end ; if sold_defenders then
122258: LD_VAR 0 17
122262: IFFALSE 122322
// if i in sold_defenders then
122264: LD_VAR 0 4
122268: PUSH
122269: LD_VAR 0 17
122273: IN
122274: IFFALSE 122322
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
122276: LD_VAR 0 4
122280: PPUSH
122281: CALL_OW 314
122285: NOT
122286: PUSH
122287: LD_VAR 0 4
122291: PPUSH
122292: LD_VAR 0 13
122296: PPUSH
122297: CALL_OW 296
122301: PUSH
122302: LD_INT 30
122304: LESS
122305: AND
122306: IFFALSE 122322
// ComAttackUnit ( i , e ) ;
122308: LD_VAR 0 4
122312: PPUSH
122313: LD_VAR 0 13
122317: PPUSH
122318: CALL_OW 115
// end ; end ; end ;
122322: GO 122325
122324: POP
// if IsDead ( i ) then
122325: LD_VAR 0 4
122329: PPUSH
122330: CALL_OW 301
122334: IFFALSE 122352
// defenders := defenders diff i ;
122336: LD_ADDR_VAR 0 2
122340: PUSH
122341: LD_VAR 0 2
122345: PUSH
122346: LD_VAR 0 4
122350: DIFF
122351: ST_TO_ADDR
// end ;
122352: GO 121455
122354: POP
122355: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
122356: LD_VAR 0 21
122360: NOT
122361: PUSH
122362: LD_VAR 0 2
122366: NOT
122367: OR
122368: PUSH
122369: LD_EXP 78
122373: PUSH
122374: LD_VAR 0 1
122378: ARRAY
122379: NOT
122380: OR
122381: IFFALSE 121359
// MC_Reset ( base , 18 ) ;
122383: LD_VAR 0 1
122387: PPUSH
122388: LD_INT 18
122390: PPUSH
122391: CALL 26364 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
122395: LD_ADDR_VAR 0 2
122399: PUSH
122400: LD_VAR 0 2
122404: PUSH
122405: LD_VAR 0 2
122409: PPUSH
122410: LD_INT 2
122412: PUSH
122413: LD_INT 25
122415: PUSH
122416: LD_INT 1
122418: PUSH
122419: EMPTY
122420: LIST
122421: LIST
122422: PUSH
122423: LD_INT 25
122425: PUSH
122426: LD_INT 5
122428: PUSH
122429: EMPTY
122430: LIST
122431: LIST
122432: PUSH
122433: LD_INT 25
122435: PUSH
122436: LD_INT 8
122438: PUSH
122439: EMPTY
122440: LIST
122441: LIST
122442: PUSH
122443: LD_INT 25
122445: PUSH
122446: LD_INT 9
122448: PUSH
122449: EMPTY
122450: LIST
122451: LIST
122452: PUSH
122453: EMPTY
122454: LIST
122455: LIST
122456: LIST
122457: LIST
122458: LIST
122459: PPUSH
122460: CALL_OW 72
122464: DIFF
122465: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
122466: LD_VAR 0 21
122470: NOT
122471: PUSH
122472: LD_VAR 0 2
122476: PPUSH
122477: LD_INT 21
122479: PUSH
122480: LD_INT 2
122482: PUSH
122483: EMPTY
122484: LIST
122485: LIST
122486: PPUSH
122487: CALL_OW 72
122491: AND
122492: IFFALSE 122830
// begin tmp := FilterByTag ( defenders , 19 ) ;
122494: LD_ADDR_VAR 0 11
122498: PUSH
122499: LD_VAR 0 2
122503: PPUSH
122504: LD_INT 19
122506: PPUSH
122507: CALL 88174 0 2
122511: ST_TO_ADDR
// if tmp then
122512: LD_VAR 0 11
122516: IFFALSE 122586
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
122518: LD_ADDR_VAR 0 11
122522: PUSH
122523: LD_VAR 0 11
122527: PPUSH
122528: LD_INT 25
122530: PUSH
122531: LD_INT 3
122533: PUSH
122534: EMPTY
122535: LIST
122536: LIST
122537: PPUSH
122538: CALL_OW 72
122542: ST_TO_ADDR
// if tmp then
122543: LD_VAR 0 11
122547: IFFALSE 122586
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
122549: LD_ADDR_EXP 90
122553: PUSH
122554: LD_EXP 90
122558: PPUSH
122559: LD_VAR 0 1
122563: PPUSH
122564: LD_EXP 90
122568: PUSH
122569: LD_VAR 0 1
122573: ARRAY
122574: PUSH
122575: LD_VAR 0 11
122579: UNION
122580: PPUSH
122581: CALL_OW 1
122585: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
122586: LD_VAR 0 1
122590: PPUSH
122591: LD_INT 19
122593: PPUSH
122594: CALL 26364 0 2
// repeat wait ( 0 0$1 ) ;
122598: LD_INT 35
122600: PPUSH
122601: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122605: LD_EXP 78
122609: PUSH
122610: LD_VAR 0 1
122614: ARRAY
122615: NOT
122616: PUSH
122617: LD_EXP 78
122621: PUSH
122622: LD_VAR 0 1
122626: ARRAY
122627: PUSH
122628: EMPTY
122629: EQUAL
122630: OR
122631: IFFALSE 122668
// begin for i in defenders do
122633: LD_ADDR_VAR 0 4
122637: PUSH
122638: LD_VAR 0 2
122642: PUSH
122643: FOR_IN
122644: IFFALSE 122657
// ComStop ( i ) ;
122646: LD_VAR 0 4
122650: PPUSH
122651: CALL_OW 141
122655: GO 122643
122657: POP
122658: POP
// defenders := [ ] ;
122659: LD_ADDR_VAR 0 2
122663: PUSH
122664: EMPTY
122665: ST_TO_ADDR
// exit ;
122666: GO 122894
// end ; for i in defenders do
122668: LD_ADDR_VAR 0 4
122672: PUSH
122673: LD_VAR 0 2
122677: PUSH
122678: FOR_IN
122679: IFFALSE 122768
// begin if not IsInArea ( i , mc_parking [ base ] ) then
122681: LD_VAR 0 4
122685: PPUSH
122686: LD_EXP 102
122690: PUSH
122691: LD_VAR 0 1
122695: ARRAY
122696: PPUSH
122697: CALL_OW 308
122701: NOT
122702: IFFALSE 122726
// ComMoveToArea ( i , mc_parking [ base ] ) else
122704: LD_VAR 0 4
122708: PPUSH
122709: LD_EXP 102
122713: PUSH
122714: LD_VAR 0 1
122718: ARRAY
122719: PPUSH
122720: CALL_OW 113
122724: GO 122766
// if GetControl ( i ) = control_manual then
122726: LD_VAR 0 4
122730: PPUSH
122731: CALL_OW 263
122735: PUSH
122736: LD_INT 1
122738: EQUAL
122739: IFFALSE 122766
// if IsDrivenBy ( i ) then
122741: LD_VAR 0 4
122745: PPUSH
122746: CALL_OW 311
122750: IFFALSE 122766
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
122752: LD_VAR 0 4
122756: PPUSH
122757: CALL_OW 311
122761: PPUSH
122762: CALL_OW 121
// end ;
122766: GO 122678
122768: POP
122769: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
122770: LD_VAR 0 2
122774: PPUSH
122775: LD_INT 95
122777: PUSH
122778: LD_EXP 102
122782: PUSH
122783: LD_VAR 0 1
122787: ARRAY
122788: PUSH
122789: EMPTY
122790: LIST
122791: LIST
122792: PPUSH
122793: CALL_OW 72
122797: PUSH
122798: LD_VAR 0 2
122802: EQUAL
122803: PUSH
122804: LD_EXP 101
122808: PUSH
122809: LD_VAR 0 1
122813: ARRAY
122814: OR
122815: PUSH
122816: LD_EXP 78
122820: PUSH
122821: LD_VAR 0 1
122825: ARRAY
122826: NOT
122827: OR
122828: IFFALSE 122598
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
122830: LD_ADDR_EXP 100
122834: PUSH
122835: LD_EXP 100
122839: PPUSH
122840: LD_VAR 0 1
122844: PPUSH
122845: LD_VAR 0 2
122849: PPUSH
122850: LD_INT 21
122852: PUSH
122853: LD_INT 2
122855: PUSH
122856: EMPTY
122857: LIST
122858: LIST
122859: PPUSH
122860: CALL_OW 72
122864: PPUSH
122865: CALL_OW 1
122869: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
122870: LD_VAR 0 1
122874: PPUSH
122875: LD_INT 19
122877: PPUSH
122878: CALL 26364 0 2
// MC_Reset ( base , 20 ) ;
122882: LD_VAR 0 1
122886: PPUSH
122887: LD_INT 20
122889: PPUSH
122890: CALL 26364 0 2
// end ; end_of_file
122894: LD_VAR 0 3
122898: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
122899: LD_VAR 0 1
122903: PUSH
122904: LD_INT 200
122906: DOUBLE
122907: GREATEREQUAL
122908: IFFALSE 122916
122910: LD_INT 299
122912: DOUBLE
122913: LESSEQUAL
122914: IFTRUE 122918
122916: GO 122950
122918: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
122919: LD_VAR 0 1
122923: PPUSH
122924: LD_VAR 0 2
122928: PPUSH
122929: LD_VAR 0 3
122933: PPUSH
122934: LD_VAR 0 4
122938: PPUSH
122939: LD_VAR 0 5
122943: PPUSH
122944: CALL 111246 0 5
122948: GO 123027
122950: LD_INT 300
122952: DOUBLE
122953: GREATEREQUAL
122954: IFFALSE 122962
122956: LD_INT 399
122958: DOUBLE
122959: LESSEQUAL
122960: IFTRUE 122964
122962: GO 123026
122964: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
122965: LD_VAR 0 1
122969: PPUSH
122970: LD_VAR 0 2
122974: PPUSH
122975: LD_VAR 0 3
122979: PPUSH
122980: LD_VAR 0 4
122984: PPUSH
122985: LD_VAR 0 5
122989: PPUSH
122990: LD_VAR 0 6
122994: PPUSH
122995: LD_VAR 0 7
122999: PPUSH
123000: LD_VAR 0 8
123004: PPUSH
123005: LD_VAR 0 9
123009: PPUSH
123010: LD_VAR 0 10
123014: PPUSH
123015: LD_VAR 0 11
123019: PPUSH
123020: CALL 107571 0 11
123024: GO 123027
123026: POP
// end ;
123027: PPOPN 11
123029: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
123030: LD_VAR 0 1
123034: PPUSH
123035: LD_VAR 0 2
123039: PPUSH
123040: LD_VAR 0 3
123044: PPUSH
123045: LD_VAR 0 4
123049: PPUSH
123050: LD_VAR 0 5
123054: PPUSH
123055: CALL 110982 0 5
// end ; end_of_file
123059: PPOPN 5
123061: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
123062: LD_VAR 0 1
123066: PPUSH
123067: LD_VAR 0 2
123071: PPUSH
123072: LD_VAR 0 3
123076: PPUSH
123077: LD_VAR 0 4
123081: PPUSH
123082: LD_VAR 0 5
123086: PPUSH
123087: LD_VAR 0 6
123091: PPUSH
123092: CALL 95223 0 6
// end ;
123096: PPOPN 6
123098: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
123099: LD_INT 0
123101: PPUSH
// begin if not units then
123102: LD_VAR 0 1
123106: NOT
123107: IFFALSE 123111
// exit ;
123109: GO 123111
// end ;
123111: PPOPN 7
123113: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
123114: CALL 95127 0 0
// end ;
123118: PPOPN 1
123120: END
