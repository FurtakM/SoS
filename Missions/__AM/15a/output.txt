// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20648 0 0
// InitNature ;
  19: CALL 17182 0 0
// InitArtifact ;
  23: CALL 17795 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4579 0 0
// PrepareAlliance ;
  44: CALL 1375 0 0
// PrepareArabian ;
  48: CALL 6347 0 0
// PrepareRussian ;
  52: CALL 8332 0 0
// PrepareLegion ;
  56: CALL 6775 0 0
// Action ;
  60: CALL 10885 0 0
// MC_Start ( ) ;
  64: CALL 22760 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// end ;
 208: LD_VAR 0 1
 212: RET
// export function CustomInitMacro ( ) ; begin
 213: LD_INT 0
 215: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 216: LD_ADDR_EXP 113
 220: PUSH
 221: LD_INT 26
 223: PUSH
 224: LD_INT 1
 226: PUSH
 227: LD_INT 4
 229: PUSH
 230: LD_INT 8
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 239: LD_ADDR_EXP 114
 243: PUSH
 244: LD_INT 27
 246: PUSH
 247: LD_INT 2
 249: PUSH
 250: LD_INT 3
 252: PUSH
 253: LD_INT 7
 255: PUSH
 256: EMPTY
 257: LIST
 258: LIST
 259: LIST
 260: LIST
 261: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 262: LD_INT 1
 264: PPUSH
 265: LD_INT 6
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: LD_INT 9
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: PPUSH
 285: LD_INT 28
 287: PPUSH
 288: CALL 43961 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 10
 297: PUSH
 298: LD_INT 11
 300: PUSH
 301: LD_INT 13
 303: PUSH
 304: LD_INT 15
 306: PUSH
 307: EMPTY
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: PPUSH
 313: CALL 45021 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 317: LD_INT 1
 319: PPUSH
 320: LD_INT 29
 322: PUSH
 323: EMPTY
 324: LIST
 325: PPUSH
 326: CALL 45114 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 330: LD_ADDR_EXP 118
 334: PUSH
 335: LD_EXP 118
 339: PPUSH
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 22
 345: PUSH
 346: LD_INT 2
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: PUSH
 353: LD_INT 25
 355: PUSH
 356: LD_INT 15
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PPUSH
 367: CALL_OW 69
 371: PPUSH
 372: CALL_OW 1
 376: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 377: LD_INT 1
 379: PPUSH
 380: LD_INT 13
 382: PUSH
 383: LD_INT 2
 385: PUSH
 386: LD_INT 1
 388: PUSH
 389: LD_INT 31
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: PUSH
 398: LD_INT 13
 400: PUSH
 401: LD_INT 2
 403: PUSH
 404: LD_INT 1
 406: PUSH
 407: LD_INT 31
 409: PUSH
 410: EMPTY
 411: LIST
 412: LIST
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 13
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 1
 424: PUSH
 425: LD_INT 28
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PUSH
 434: LD_INT 13
 436: PUSH
 437: LD_INT 1
 439: PUSH
 440: LD_INT 1
 442: PUSH
 443: LD_INT 28
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: PUSH
 452: LD_INT 13
 454: PUSH
 455: LD_INT 1
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: LD_INT 28
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: PUSH
 470: LD_INT 13
 472: PUSH
 473: LD_INT 1
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: LD_INT 28
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: LIST
 486: LIST
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PPUSH
 496: CALL 44279 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 500: LD_INT 1
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL 44464 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 510: LD_INT 2
 512: PPUSH
 513: LD_INT 10
 515: PUSH
 516: LD_INT 11
 518: PUSH
 519: LD_INT 12
 521: PUSH
 522: LD_INT 14
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PPUSH
 531: CALL 45021 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 14
 540: PUSH
 541: EMPTY
 542: LIST
 543: PPUSH
 544: CALL 45114 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 21
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 51
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 22
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 52
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 22
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 3
 595: PUSH
 596: LD_INT 52
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 3
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: LD_INT 24
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 3
 631: PUSH
 632: LD_INT 47
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: PUSH
 641: LD_INT 24
 643: PUSH
 644: LD_INT 3
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 47
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 24
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 47
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 24
 679: PUSH
 680: LD_INT 3
 682: PUSH
 683: LD_INT 3
 685: PUSH
 686: LD_INT 47
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: EMPTY
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: LIST
 703: LIST
 704: PPUSH
 705: CALL 44279 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 709: LD_INT 2
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL 44464 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 719: LD_INT 2
 721: PPUSH
 722: LD_INT 0
 724: PPUSH
 725: CALL 44894 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 729: LD_INT 3
 731: PPUSH
 732: LD_INT 10
 734: PUSH
 735: LD_INT 12
 737: PUSH
 738: LD_INT 15
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_OWVAR 67
 750: ARRAY
 751: PPUSH
 752: LD_INT 24
 754: PPUSH
 755: CALL 43961 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 759: LD_INT 3
 761: PPUSH
 762: LD_INT 10
 764: PUSH
 765: LD_INT 11
 767: PUSH
 768: LD_INT 13
 770: PUSH
 771: LD_INT 15
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: LIST
 779: PPUSH
 780: CALL 45021 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 13
 789: PUSH
 790: EMPTY
 791: LIST
 792: PPUSH
 793: CALL 45114 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 797: LD_ADDR_EXP 118
 801: PUSH
 802: LD_EXP 118
 806: PPUSH
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 22
 812: PUSH
 813: LD_INT 8
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: PUSH
 820: LD_INT 25
 822: PUSH
 823: LD_INT 15
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: CALL_OW 1
 843: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 844: LD_INT 3
 846: PPUSH
 847: LD_INT 13
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: LD_INT 31
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: LD_INT 13
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 1
 873: PUSH
 874: LD_INT 31
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 13
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 2
 891: PUSH
 892: LD_INT 32
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PUSH
 901: LD_INT 14
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: LD_INT 28
 912: PUSH
 913: EMPTY
 914: LIST
 915: LIST
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 14
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: LD_INT 1
 927: PUSH
 928: LD_INT 28
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 14
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 1
 945: PUSH
 946: LD_INT 28
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 14
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 28
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PPUSH
 982: CALL 44279 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 986: LD_INT 3
 988: PPUSH
 989: LD_INT 4
 991: PPUSH
 992: CALL 44464 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: LD_INT 11
1007: PUSH
1008: LD_INT 15
1010: PUSH
1011: EMPTY
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL 45021 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1021: LD_INT 4
1023: PPUSH
1024: LD_INT 33
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL 45114 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1034: LD_INT 4
1036: PPUSH
1037: LD_INT 5
1039: PUSH
1040: LD_INT 6
1042: PUSH
1043: LD_INT 7
1045: PUSH
1046: LD_INT 9
1048: PUSH
1049: LD_INT 10
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PPUSH
1059: CALL 45432 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1063: LD_INT 4
1065: PPUSH
1066: LD_INT 54
1068: PPUSH
1069: LD_INT 85
1071: PPUSH
1072: LD_INT 2
1074: PPUSH
1075: LD_INT 25
1077: PUSH
1078: LD_INT 16
1080: PUSH
1081: LD_INT 17
1083: PUSH
1084: LD_INT 18
1086: PUSH
1087: LD_INT 22
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: LIST
1096: PPUSH
1097: CALL 45226 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1101: LD_INT 4
1103: PPUSH
1104: LD_INT 5
1106: PUSH
1107: LD_INT 1
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: LD_INT 7
1115: PUSH
1116: EMPTY
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 1
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: LD_INT 6
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 5
1142: PUSH
1143: LD_INT 1
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: LD_INT 7
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 6
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 3
1184: PUSH
1185: LD_INT 12
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 3
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 3
1202: PUSH
1203: LD_INT 13
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PPUSH
1220: CALL 44279 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1224: LD_INT 4
1226: PPUSH
1227: LD_INT 4
1229: PPUSH
1230: CALL 44464 0 2
// MC_SetTame ( 4 , powellApe ) ;
1234: LD_INT 4
1236: PPUSH
1237: LD_INT 11
1239: PPUSH
1240: CALL 44845 0 2
// end ;
1244: LD_VAR 0 1
1248: RET
// every 0 0$1 trigger debug do var i ;
1249: LD_EXP 1
1253: IFFALSE 1351
1255: GO 1257
1257: DISABLE
1258: LD_INT 0
1260: PPUSH
// begin enable ;
1261: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1262: LD_ADDR_VAR 0 1
1266: PUSH
1267: LD_INT 22
1269: PUSH
1270: LD_INT 7
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 2
1279: PUSH
1280: LD_INT 21
1282: PUSH
1283: LD_INT 1
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 2
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 3
1307: PUSH
1308: LD_INT 24
1310: PUSH
1311: LD_INT 1000
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL_OW 69
1331: PUSH
1332: FOR_IN
1333: IFFALSE 1349
// SetLives ( i , 1000 ) ;
1335: LD_VAR 0 1
1339: PPUSH
1340: LD_INT 1000
1342: PPUSH
1343: CALL_OW 234
1347: GO 1332
1349: POP
1350: POP
// end ;
1351: PPOPN 1
1353: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1354: LD_EXP 16
1358: PUSH
1359: LD_INT 5
1361: GREATEREQUAL
1362: IFFALSE 1374
1364: GO 1366
1366: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1367: LD_STRING ACH_ARTIFACT
1369: PPUSH
1370: CALL_OW 543
1374: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1375: LD_INT 0
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// uc_side := 7 ;
1382: LD_ADDR_OWVAR 20
1386: PUSH
1387: LD_INT 7
1389: ST_TO_ADDR
// tmp := [ ] ;
1390: LD_ADDR_VAR 0 5
1394: PUSH
1395: EMPTY
1396: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1397: LD_ADDR_EXP 17
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: LD_STRING 14a_
1413: PPUSH
1414: CALL 50671 0 3
1418: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1419: LD_ADDR_EXP 49
1423: PUSH
1424: LD_STRING Burlak
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: LD_STRING 14a_
1435: PPUSH
1436: CALL 50671 0 3
1440: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1441: LD_ADDR_EXP 32
1445: PUSH
1446: LD_STRING Joan
1448: PPUSH
1449: LD_EXP 1
1453: NOT
1454: PPUSH
1455: LD_STRING 13a_
1457: PPUSH
1458: CALL 50671 0 3
1462: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1463: LD_ADDR_EXP 18
1467: PUSH
1468: LD_STRING Roth
1470: PPUSH
1471: LD_EXP 1
1475: NOT
1476: PPUSH
1477: LD_STRING 13a_
1479: PPUSH
1480: CALL 50671 0 3
1484: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1485: LD_ADDR_EXP 35
1489: PUSH
1490: LD_STRING Gossudarov
1492: PPUSH
1493: LD_EXP 1
1497: NOT
1498: PPUSH
1499: LD_STRING 13a_
1501: PPUSH
1502: CALL 50671 0 3
1506: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1507: LD_ADDR_EXP 23
1511: PUSH
1512: LD_STRING Denis
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: LD_STRING 13a_
1523: PPUSH
1524: CALL 50671 0 3
1528: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1529: LD_ADDR_EXP 33
1533: PUSH
1534: LD_STRING DeltaDoctor
1536: PPUSH
1537: LD_EXP 1
1541: NOT
1542: PPUSH
1543: LD_STRING 13a_
1545: PPUSH
1546: CALL 50671 0 3
1550: ST_TO_ADDR
// if DeltaDoctor then
1551: LD_EXP 33
1555: IFFALSE 1573
// tmp := tmp ^ DeltaDoctor ;
1557: LD_ADDR_VAR 0 5
1561: PUSH
1562: LD_VAR 0 5
1566: PUSH
1567: LD_EXP 33
1571: ADD
1572: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1573: LD_ADDR_EXP 31
1577: PUSH
1578: LD_STRING Simms
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 13a_
1589: PPUSH
1590: CALL 50671 0 3
1594: ST_TO_ADDR
// if Simms then
1595: LD_EXP 31
1599: IFFALSE 1617
// tmp := tmp ^ Simms ;
1601: LD_ADDR_VAR 0 5
1605: PUSH
1606: LD_VAR 0 5
1610: PUSH
1611: LD_EXP 31
1615: ADD
1616: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1617: LD_ADDR_EXP 29
1621: PUSH
1622: LD_STRING Frank
1624: PPUSH
1625: LD_EXP 1
1629: NOT
1630: PPUSH
1631: LD_STRING 13a_
1633: PPUSH
1634: CALL 50671 0 3
1638: ST_TO_ADDR
// if Frank then
1639: LD_EXP 29
1643: IFFALSE 1661
// tmp := tmp ^ Frank ;
1645: LD_ADDR_VAR 0 5
1649: PUSH
1650: LD_VAR 0 5
1654: PUSH
1655: LD_EXP 29
1659: ADD
1660: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1661: LD_ADDR_EXP 36
1665: PUSH
1666: LD_STRING Kirilenkova
1668: PPUSH
1669: LD_EXP 1
1673: NOT
1674: PPUSH
1675: LD_STRING 13a_
1677: PPUSH
1678: CALL 50671 0 3
1682: ST_TO_ADDR
// if Kirilenkova then
1683: LD_EXP 36
1687: IFFALSE 1705
// tmp := tmp ^ Kirilenkova ;
1689: LD_ADDR_VAR 0 5
1693: PUSH
1694: LD_VAR 0 5
1698: PUSH
1699: LD_EXP 36
1703: ADD
1704: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1705: LD_ADDR_EXP 37
1709: PUSH
1710: LD_STRING Titov
1712: PPUSH
1713: LD_EXP 1
1717: NOT
1718: PPUSH
1719: LD_STRING 13a_
1721: PPUSH
1722: CALL 50671 0 3
1726: ST_TO_ADDR
// if Titov then
1727: LD_EXP 37
1731: IFFALSE 1749
// tmp := tmp ^ Titov ;
1733: LD_ADDR_VAR 0 5
1737: PUSH
1738: LD_VAR 0 5
1742: PUSH
1743: LD_EXP 37
1747: ADD
1748: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Fadeev
1756: PPUSH
1757: LD_EXP 1
1761: NOT
1762: PPUSH
1763: LD_STRING 13a_
1765: PPUSH
1766: CALL 50671 0 3
1770: ST_TO_ADDR
// if Fadeev then
1771: LD_EXP 38
1775: IFFALSE 1793
// tmp := tmp ^ Fadeev ;
1777: LD_ADDR_VAR 0 5
1781: PUSH
1782: LD_VAR 0 5
1786: PUSH
1787: LD_EXP 38
1791: ADD
1792: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1793: LD_ADDR_EXP 39
1797: PUSH
1798: LD_STRING Dolgov
1800: PPUSH
1801: LD_EXP 1
1805: NOT
1806: PPUSH
1807: LD_STRING 13a_
1809: PPUSH
1810: CALL 50671 0 3
1814: ST_TO_ADDR
// if Dolgov then
1815: LD_EXP 39
1819: IFFALSE 1837
// tmp := tmp ^ Dolgov ;
1821: LD_ADDR_VAR 0 5
1825: PUSH
1826: LD_VAR 0 5
1830: PUSH
1831: LD_EXP 39
1835: ADD
1836: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING Petrosyan
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 13a_
1853: PPUSH
1854: CALL 50671 0 3
1858: ST_TO_ADDR
// if Petrosyan then
1859: LD_EXP 40
1863: IFFALSE 1881
// tmp := tmp ^ Petrosyan ;
1865: LD_ADDR_VAR 0 5
1869: PUSH
1870: LD_VAR 0 5
1874: PUSH
1875: LD_EXP 40
1879: ADD
1880: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1881: LD_ADDR_EXP 41
1885: PUSH
1886: LD_STRING Scholtze
1888: PPUSH
1889: LD_EXP 1
1893: NOT
1894: PPUSH
1895: LD_STRING 13a_
1897: PPUSH
1898: CALL 50671 0 3
1902: ST_TO_ADDR
// if Scholtze then
1903: LD_EXP 41
1907: IFFALSE 1925
// tmp := tmp ^ Scholtze ;
1909: LD_ADDR_VAR 0 5
1913: PUSH
1914: LD_VAR 0 5
1918: PUSH
1919: LD_EXP 41
1923: ADD
1924: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1925: LD_ADDR_EXP 42
1929: PUSH
1930: LD_STRING Oblukov
1932: PPUSH
1933: LD_EXP 1
1937: NOT
1938: PPUSH
1939: LD_STRING 13a_
1941: PPUSH
1942: CALL 50671 0 3
1946: ST_TO_ADDR
// if Oblukov then
1947: LD_EXP 42
1951: IFFALSE 1969
// tmp := tmp ^ Oblukov ;
1953: LD_ADDR_VAR 0 5
1957: PUSH
1958: LD_VAR 0 5
1962: PUSH
1963: LD_EXP 42
1967: ADD
1968: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1969: LD_ADDR_EXP 43
1973: PUSH
1974: LD_STRING Kapitsova
1976: PPUSH
1977: LD_EXP 1
1981: NOT
1982: PPUSH
1983: LD_STRING 13a_
1985: PPUSH
1986: CALL 50671 0 3
1990: ST_TO_ADDR
// if Kapitsova then
1991: LD_EXP 43
1995: IFFALSE 2013
// tmp := tmp ^ Kapitsova ;
1997: LD_ADDR_VAR 0 5
2001: PUSH
2002: LD_VAR 0 5
2006: PUSH
2007: LD_EXP 43
2011: ADD
2012: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2013: LD_ADDR_EXP 44
2017: PUSH
2018: LD_STRING Lipshchin
2020: PPUSH
2021: LD_EXP 1
2025: NOT
2026: PPUSH
2027: LD_STRING 13a_
2029: PPUSH
2030: CALL 50671 0 3
2034: ST_TO_ADDR
// if Lipshchin then
2035: LD_EXP 44
2039: IFFALSE 2057
// tmp := tmp ^ Lipshchin ;
2041: LD_ADDR_VAR 0 5
2045: PUSH
2046: LD_VAR 0 5
2050: PUSH
2051: LD_EXP 44
2055: ADD
2056: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2057: LD_ADDR_EXP 45
2061: PUSH
2062: LD_STRING Petrovova
2064: PPUSH
2065: LD_EXP 1
2069: NOT
2070: PPUSH
2071: LD_STRING 13a_
2073: PPUSH
2074: CALL 50671 0 3
2078: ST_TO_ADDR
// if Petrovova then
2079: LD_EXP 45
2083: IFFALSE 2101
// tmp := tmp ^ Petrovova ;
2085: LD_ADDR_VAR 0 5
2089: PUSH
2090: LD_VAR 0 5
2094: PUSH
2095: LD_EXP 45
2099: ADD
2100: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2101: LD_ADDR_EXP 46
2105: PUSH
2106: LD_STRING Kovalyuk
2108: PPUSH
2109: LD_EXP 1
2113: NOT
2114: PPUSH
2115: LD_STRING 13a_
2117: PPUSH
2118: CALL 50671 0 3
2122: ST_TO_ADDR
// if Kovalyuk then
2123: LD_EXP 46
2127: IFFALSE 2145
// tmp := tmp ^ Kovalyuk ;
2129: LD_ADDR_VAR 0 5
2133: PUSH
2134: LD_VAR 0 5
2138: PUSH
2139: LD_EXP 46
2143: ADD
2144: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2145: LD_ADDR_EXP 47
2149: PUSH
2150: LD_STRING Kuzmov
2152: PPUSH
2153: LD_EXP 1
2157: NOT
2158: PPUSH
2159: LD_STRING 13a_
2161: PPUSH
2162: CALL 50671 0 3
2166: ST_TO_ADDR
// if Kuzmov then
2167: LD_EXP 47
2171: IFFALSE 2189
// tmp := tmp ^ Kuzmov ;
2173: LD_ADDR_VAR 0 5
2177: PUSH
2178: LD_VAR 0 5
2182: PUSH
2183: LD_EXP 47
2187: ADD
2188: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2189: LD_ADDR_EXP 48
2193: PUSH
2194: LD_STRING Karamazov
2196: PPUSH
2197: LD_EXP 1
2201: NOT
2202: PPUSH
2203: LD_STRING 13a_
2205: PPUSH
2206: CALL 50671 0 3
2210: ST_TO_ADDR
// if Karamazov then
2211: LD_EXP 48
2215: IFFALSE 2233
// tmp := tmp ^ Karamazov ;
2217: LD_ADDR_VAR 0 5
2221: PUSH
2222: LD_VAR 0 5
2226: PUSH
2227: LD_EXP 48
2231: ADD
2232: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2233: LD_ADDR_EXP 50
2237: PUSH
2238: LD_STRING Belkov
2240: PPUSH
2241: LD_EXP 1
2245: NOT
2246: PPUSH
2247: LD_STRING 13a_
2249: PPUSH
2250: CALL 50671 0 3
2254: ST_TO_ADDR
// if Belkov then
2255: LD_EXP 50
2259: IFFALSE 2277
// tmp := tmp ^ Belkov ;
2261: LD_ADDR_VAR 0 5
2265: PUSH
2266: LD_VAR 0 5
2270: PUSH
2271: LD_EXP 50
2275: ADD
2276: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2277: LD_ADDR_EXP 51
2281: PUSH
2282: LD_STRING Gnyevko
2284: PPUSH
2285: LD_EXP 1
2289: NOT
2290: PPUSH
2291: LD_STRING 13a_
2293: PPUSH
2294: CALL 50671 0 3
2298: ST_TO_ADDR
// if Gnyevko then
2299: LD_EXP 51
2303: IFFALSE 2321
// tmp := tmp ^ Gnyevko ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PUSH
2315: LD_EXP 51
2319: ADD
2320: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2321: LD_ADDR_EXP 34
2325: PUSH
2326: LD_STRING Coonie
2328: PPUSH
2329: CALL_OW 25
2333: ST_TO_ADDR
// if not Lisa then
2334: LD_EXP 19
2338: NOT
2339: IFFALSE 2385
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2341: LD_ADDR_EXP 19
2345: PUSH
2346: LD_STRING Lisa
2348: PPUSH
2349: LD_EXP 1
2353: NOT
2354: PPUSH
2355: LD_STRING 13a_
2357: PPUSH
2358: CALL 50671 0 3
2362: ST_TO_ADDR
// if Lisa then
2363: LD_EXP 19
2367: IFFALSE 2385
// tmp := tmp ^ Lisa ;
2369: LD_ADDR_VAR 0 5
2373: PUSH
2374: LD_VAR 0 5
2378: PUSH
2379: LD_EXP 19
2383: ADD
2384: ST_TO_ADDR
// end ; if not Donaldson then
2385: LD_EXP 20
2389: NOT
2390: IFFALSE 2436
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2392: LD_ADDR_EXP 20
2396: PUSH
2397: LD_STRING Donaldson
2399: PPUSH
2400: LD_EXP 1
2404: NOT
2405: PPUSH
2406: LD_STRING 13a_
2408: PPUSH
2409: CALL 50671 0 3
2413: ST_TO_ADDR
// if Donaldson then
2414: LD_EXP 20
2418: IFFALSE 2436
// tmp := tmp ^ Donaldson ;
2420: LD_ADDR_VAR 0 5
2424: PUSH
2425: LD_VAR 0 5
2429: PUSH
2430: LD_EXP 20
2434: ADD
2435: ST_TO_ADDR
// end ; if not Bobby then
2436: LD_EXP 21
2440: NOT
2441: IFFALSE 2487
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2443: LD_ADDR_EXP 21
2447: PUSH
2448: LD_STRING Bobby
2450: PPUSH
2451: LD_EXP 1
2455: NOT
2456: PPUSH
2457: LD_STRING 13a_
2459: PPUSH
2460: CALL 50671 0 3
2464: ST_TO_ADDR
// if Bobby then
2465: LD_EXP 21
2469: IFFALSE 2487
// tmp := tmp ^ Bobby ;
2471: LD_ADDR_VAR 0 5
2475: PUSH
2476: LD_VAR 0 5
2480: PUSH
2481: LD_EXP 21
2485: ADD
2486: ST_TO_ADDR
// end ; if not Cyrus then
2487: LD_EXP 22
2491: NOT
2492: IFFALSE 2538
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2494: LD_ADDR_EXP 22
2498: PUSH
2499: LD_STRING Cyrus
2501: PPUSH
2502: LD_EXP 1
2506: NOT
2507: PPUSH
2508: LD_STRING 13a_
2510: PPUSH
2511: CALL 50671 0 3
2515: ST_TO_ADDR
// if Cyrus then
2516: LD_EXP 22
2520: IFFALSE 2538
// tmp := tmp ^ Cyrus ;
2522: LD_ADDR_VAR 0 5
2526: PUSH
2527: LD_VAR 0 5
2531: PUSH
2532: LD_EXP 22
2536: ADD
2537: ST_TO_ADDR
// end ; if not Brown then
2538: LD_EXP 24
2542: NOT
2543: IFFALSE 2589
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2545: LD_ADDR_EXP 24
2549: PUSH
2550: LD_STRING Brown
2552: PPUSH
2553: LD_EXP 1
2557: NOT
2558: PPUSH
2559: LD_STRING 13a_
2561: PPUSH
2562: CALL 50671 0 3
2566: ST_TO_ADDR
// if Brown then
2567: LD_EXP 24
2571: IFFALSE 2589
// tmp := tmp ^ Brown ;
2573: LD_ADDR_VAR 0 5
2577: PUSH
2578: LD_VAR 0 5
2582: PUSH
2583: LD_EXP 24
2587: ADD
2588: ST_TO_ADDR
// end ; if not Gladstone then
2589: LD_EXP 25
2593: NOT
2594: IFFALSE 2640
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2596: LD_ADDR_EXP 25
2600: PUSH
2601: LD_STRING Gladstone
2603: PPUSH
2604: LD_EXP 1
2608: NOT
2609: PPUSH
2610: LD_STRING 13a_
2612: PPUSH
2613: CALL 50671 0 3
2617: ST_TO_ADDR
// if Gladstone then
2618: LD_EXP 25
2622: IFFALSE 2640
// tmp := tmp ^ Gladstone ;
2624: LD_ADDR_VAR 0 5
2628: PUSH
2629: LD_VAR 0 5
2633: PUSH
2634: LD_EXP 25
2638: ADD
2639: ST_TO_ADDR
// end ; if not Cornel then
2640: LD_EXP 27
2644: NOT
2645: IFFALSE 2691
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2647: LD_ADDR_EXP 27
2651: PUSH
2652: LD_STRING Cornel
2654: PPUSH
2655: LD_EXP 1
2659: NOT
2660: PPUSH
2661: LD_STRING 13a_
2663: PPUSH
2664: CALL 50671 0 3
2668: ST_TO_ADDR
// if Cornel then
2669: LD_EXP 27
2673: IFFALSE 2691
// tmp := tmp ^ Cornel ;
2675: LD_ADDR_VAR 0 5
2679: PUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_EXP 27
2689: ADD
2690: ST_TO_ADDR
// end ; if not Houten then
2691: LD_EXP 26
2695: NOT
2696: IFFALSE 2742
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2698: LD_ADDR_EXP 26
2702: PUSH
2703: LD_STRING Houten
2705: PPUSH
2706: LD_EXP 1
2710: NOT
2711: PPUSH
2712: LD_STRING 13a_
2714: PPUSH
2715: CALL 50671 0 3
2719: ST_TO_ADDR
// if Houten then
2720: LD_EXP 26
2724: IFFALSE 2742
// tmp := tmp ^ Houten ;
2726: LD_ADDR_VAR 0 5
2730: PUSH
2731: LD_VAR 0 5
2735: PUSH
2736: LD_EXP 26
2740: ADD
2741: ST_TO_ADDR
// end ; if not Gary then
2742: LD_EXP 28
2746: NOT
2747: IFFALSE 2793
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2749: LD_ADDR_EXP 28
2753: PUSH
2754: LD_STRING Gary
2756: PPUSH
2757: LD_EXP 1
2761: NOT
2762: PPUSH
2763: LD_STRING 13a_
2765: PPUSH
2766: CALL 50671 0 3
2770: ST_TO_ADDR
// if Gary then
2771: LD_EXP 28
2775: IFFALSE 2793
// tmp := tmp ^ Gary ;
2777: LD_ADDR_VAR 0 5
2781: PUSH
2782: LD_VAR 0 5
2786: PUSH
2787: LD_EXP 28
2791: ADD
2792: ST_TO_ADDR
// end ; if not Kikuchi then
2793: LD_EXP 30
2797: NOT
2798: IFFALSE 2844
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2800: LD_ADDR_EXP 30
2804: PUSH
2805: LD_STRING Kikuchi
2807: PPUSH
2808: LD_EXP 1
2812: NOT
2813: PPUSH
2814: LD_STRING 13a_
2816: PPUSH
2817: CALL 50671 0 3
2821: ST_TO_ADDR
// if Kikuchi then
2822: LD_EXP 30
2826: IFFALSE 2844
// tmp := tmp ^ Kikuchi ;
2828: LD_ADDR_VAR 0 5
2832: PUSH
2833: LD_VAR 0 5
2837: PUSH
2838: LD_EXP 30
2842: ADD
2843: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_VAR 0 5
2853: PUSH
2854: LD_STRING 13a_others
2856: PPUSH
2857: CALL_OW 31
2861: UNION
2862: ST_TO_ADDR
// tmp := tmp diff 0 ;
2863: LD_ADDR_VAR 0 5
2867: PUSH
2868: LD_VAR 0 5
2872: PUSH
2873: LD_INT 0
2875: DIFF
2876: ST_TO_ADDR
// if tmp < 15 then
2877: LD_VAR 0 5
2881: PUSH
2882: LD_INT 15
2884: LESS
2885: IFFALSE 2973
// for i = 15 downto tmp do
2887: LD_ADDR_VAR 0 2
2891: PUSH
2892: DOUBLE
2893: LD_INT 15
2895: INC
2896: ST_TO_ADDR
2897: LD_VAR 0 5
2901: PUSH
2902: FOR_DOWNTO
2903: IFFALSE 2971
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2905: LD_ADDR_OWVAR 21
2909: PUSH
2910: LD_INT 1
2912: PUSH
2913: LD_INT 3
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 1
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: CALL_OW 12
2930: ARRAY
2931: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2932: LD_INT 0
2934: PPUSH
2935: LD_INT 1
2937: PPUSH
2938: LD_INT 4
2940: PPUSH
2941: CALL_OW 12
2945: PPUSH
2946: LD_INT 8
2948: PPUSH
2949: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2953: LD_ADDR_VAR 0 5
2957: PUSH
2958: LD_VAR 0 5
2962: PUSH
2963: CALL_OW 44
2967: ADD
2968: ST_TO_ADDR
// end ;
2969: GO 2902
2971: POP
2972: POP
// if not debug then
2973: LD_EXP 1
2977: NOT
2978: IFFALSE 3150
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2980: LD_ADDR_VAR 0 4
2984: PUSH
2985: LD_STRING 
2987: PPUSH
2988: LD_INT 15
2990: PUSH
2991: LD_INT 14
2993: PUSH
2994: LD_INT 13
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: LIST
3001: PUSH
3002: LD_OWVAR 67
3006: ARRAY
3007: PPUSH
3008: LD_INT 15
3010: PUSH
3011: LD_INT 14
3013: PUSH
3014: LD_INT 13
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: LIST
3021: PUSH
3022: LD_OWVAR 67
3026: ARRAY
3027: PPUSH
3028: LD_INT -6
3030: PUSH
3031: LD_EXP 17
3035: PUSH
3036: LD_EXP 49
3040: PUSH
3041: LD_EXP 18
3045: PUSH
3046: LD_EXP 32
3050: PUSH
3051: LD_EXP 23
3055: PUSH
3056: LD_EXP 35
3060: PUSH
3061: LD_INT -2
3063: PUSH
3064: LD_INT -3
3066: PUSH
3067: LD_INT -5
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PUSH
3082: LD_VAR 0 5
3086: ADD
3087: PPUSH
3088: LD_INT 1
3090: PUSH
3091: LD_INT 4
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: LD_INT 1
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 3
3106: PUSH
3107: LD_INT 5
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 9
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 3
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PPUSH
3143: CALL_OW 42
3147: ST_TO_ADDR
3148: GO 3229
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3150: LD_ADDR_VAR 0 4
3154: PUSH
3155: LD_EXP 37
3159: PUSH
3160: LD_EXP 38
3164: PUSH
3165: LD_EXP 39
3169: PUSH
3170: LD_EXP 40
3174: PUSH
3175: LD_EXP 41
3179: PUSH
3180: LD_EXP 42
3184: PUSH
3185: LD_EXP 43
3189: PUSH
3190: LD_EXP 44
3194: PUSH
3195: LD_EXP 45
3199: PUSH
3200: LD_EXP 46
3204: PUSH
3205: LD_EXP 47
3209: PUSH
3210: LD_EXP 48
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: ST_TO_ADDR
// uc_nation := 1 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 1
3236: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3237: LD_INT 5
3239: PPUSH
3240: LD_INT 3
3242: PPUSH
3243: LD_INT 1
3245: PPUSH
3246: LD_INT 6
3248: PPUSH
3249: LD_INT 100
3251: PPUSH
3252: CALL 55495 0 5
// veh := CreateVehicle ;
3256: LD_ADDR_VAR 0 3
3260: PUSH
3261: CALL_OW 45
3265: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3266: LD_VAR 0 3
3270: PPUSH
3271: LD_INT 7
3273: NEG
3274: PPUSH
3275: CALL_OW 242
// SetDir ( veh , 3 ) ;
3279: LD_VAR 0 3
3283: PPUSH
3284: LD_INT 3
3286: PPUSH
3287: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3291: LD_VAR 0 3
3295: PPUSH
3296: LD_INT 31
3298: PPUSH
3299: LD_INT 0
3301: PPUSH
3302: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3306: LD_EXP 17
3310: PPUSH
3311: LD_VAR 0 3
3315: PPUSH
3316: CALL_OW 52
// if Joan then
3320: LD_EXP 32
3324: IFFALSE 3396
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3326: LD_INT 3
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: LD_INT 1
3334: PPUSH
3335: LD_INT 11
3337: PPUSH
3338: LD_INT 100
3340: PPUSH
3341: CALL 55495 0 5
// veh := CreateVehicle ;
3345: LD_ADDR_VAR 0 3
3349: PUSH
3350: CALL_OW 45
3354: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3355: LD_VAR 0 3
3359: PPUSH
3360: LD_INT 3
3362: PPUSH
3363: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3367: LD_VAR 0 3
3371: PPUSH
3372: LD_INT 30
3374: PPUSH
3375: LD_INT 0
3377: PPUSH
3378: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3382: LD_EXP 32
3386: PPUSH
3387: LD_VAR 0 3
3391: PPUSH
3392: CALL_OW 52
// end ; if Roth then
3396: LD_EXP 18
3400: IFFALSE 3472
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3402: LD_INT 3
3404: PPUSH
3405: LD_INT 3
3407: PPUSH
3408: LD_INT 1
3410: PPUSH
3411: LD_INT 11
3413: PPUSH
3414: LD_INT 100
3416: PPUSH
3417: CALL 55495 0 5
// veh := CreateVehicle ;
3421: LD_ADDR_VAR 0 3
3425: PUSH
3426: CALL_OW 45
3430: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3431: LD_VAR 0 3
3435: PPUSH
3436: LD_INT 3
3438: PPUSH
3439: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3443: LD_VAR 0 3
3447: PPUSH
3448: LD_INT 30
3450: PPUSH
3451: LD_INT 0
3453: PPUSH
3454: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3458: LD_EXP 18
3462: PPUSH
3463: LD_VAR 0 3
3467: PPUSH
3468: CALL_OW 52
// end ; if Denis then
3472: LD_EXP 23
3476: IFFALSE 3548
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3478: LD_INT 5
3480: PPUSH
3481: LD_INT 3
3483: PPUSH
3484: LD_INT 1
3486: PPUSH
3487: LD_INT 9
3489: PPUSH
3490: LD_INT 100
3492: PPUSH
3493: CALL 55495 0 5
// veh := CreateVehicle ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: CALL_OW 45
3506: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3507: LD_VAR 0 3
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3519: LD_VAR 0 3
3523: PPUSH
3524: LD_INT 30
3526: PPUSH
3527: LD_INT 0
3529: PPUSH
3530: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3534: LD_EXP 23
3538: PPUSH
3539: LD_VAR 0 3
3543: PPUSH
3544: CALL_OW 52
// end ; uc_nation := 3 ;
3548: LD_ADDR_OWVAR 21
3552: PUSH
3553: LD_INT 3
3555: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3556: LD_INT 22
3558: PPUSH
3559: LD_INT 3
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: LD_INT 45
3567: PPUSH
3568: LD_INT 100
3570: PPUSH
3571: CALL 55495 0 5
// veh := CreateVehicle ;
3575: LD_ADDR_VAR 0 3
3579: PUSH
3580: CALL_OW 45
3584: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3585: LD_VAR 0 3
3589: PPUSH
3590: LD_INT 7
3592: NEG
3593: PPUSH
3594: CALL_OW 242
// SetDir ( veh , 3 ) ;
3598: LD_VAR 0 3
3602: PPUSH
3603: LD_INT 3
3605: PPUSH
3606: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3610: LD_VAR 0 3
3614: PPUSH
3615: LD_INT 31
3617: PPUSH
3618: LD_INT 0
3620: PPUSH
3621: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3625: LD_EXP 49
3629: PPUSH
3630: LD_VAR 0 3
3634: PPUSH
3635: CALL_OW 52
// if Gossudarov then
3639: LD_EXP 35
3643: IFFALSE 3730
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3645: LD_INT 22
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: LD_INT 1
3653: PPUSH
3654: LD_INT 51
3656: PPUSH
3657: LD_INT 100
3659: PPUSH
3660: CALL 55495 0 5
// veh := CreateVehicle ;
3664: LD_ADDR_VAR 0 3
3668: PUSH
3669: CALL_OW 45
3673: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3674: LD_VAR 0 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3686: LD_VAR 0 3
3690: PPUSH
3691: LD_INT 30
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3701: LD_EXP 35
3705: PPUSH
3706: LD_VAR 0 3
3710: PPUSH
3711: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3715: LD_VAR 0 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_INT 100
3725: PPUSH
3726: CALL_OW 290
// end ; for i in selected do
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: LD_VAR 0 4
3739: PUSH
3740: FOR_IN
3741: IFFALSE 4299
// begin uc_nation := GetNation ( i ) ;
3743: LD_ADDR_OWVAR 21
3747: PUSH
3748: LD_VAR 0 2
3752: PPUSH
3753: CALL_OW 248
3757: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3758: LD_VAR 0 2
3762: PUSH
3763: LD_EXP 19
3767: PUSH
3768: LD_EXP 20
3772: PUSH
3773: LD_EXP 22
3777: PUSH
3778: LD_EXP 21
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: LIST
3788: IN
3789: IFFALSE 3812
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3791: LD_INT 5
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 6
3802: PPUSH
3803: LD_INT 100
3805: PPUSH
3806: CALL 55495 0 5
3810: GO 4246
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3812: LD_VAR 0 2
3816: PUSH
3817: LD_EXP 42
3821: PUSH
3822: LD_EXP 47
3826: PUSH
3827: LD_EXP 45
3831: PUSH
3832: LD_EXP 37
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: IN
3843: IFFALSE 3874
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3845: LD_INT 24
3847: PPUSH
3848: LD_INT 1
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 46
3856: PPUSH
3857: LD_INT 65
3859: PPUSH
3860: LD_INT 75
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL 55495 0 5
3872: GO 4246
// if i = Karamazov then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 48
3883: EQUAL
3884: IFFALSE 3907
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3886: LD_INT 22
3888: PPUSH
3889: LD_INT 3
3891: PPUSH
3892: LD_INT 1
3894: PPUSH
3895: LD_INT 52
3897: PPUSH
3898: LD_INT 100
3900: PPUSH
3901: CALL 55495 0 5
3905: GO 4246
// if i = Brown then
3907: LD_VAR 0 2
3911: PUSH
3912: LD_EXP 24
3916: EQUAL
3917: IFFALSE 3940
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3919: LD_INT 3
3921: PPUSH
3922: LD_INT 3
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 13
3930: PPUSH
3931: LD_INT 100
3933: PPUSH
3934: CALL 55495 0 5
3938: GO 4246
// if uc_nation = nation_american then
3940: LD_OWVAR 21
3944: PUSH
3945: LD_INT 1
3947: EQUAL
3948: IFFALSE 4099
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3950: LD_INT 3
3952: PUSH
3953: LD_INT 5
3955: PUSH
3956: LD_INT 5
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 21
3968: PUSH
3969: LD_INT 3
3971: MOD
3972: PUSH
3973: LD_INT 1
3975: PLUS
3976: ARRAY
3977: PPUSH
3978: LD_INT 1
3980: PUSH
3981: LD_INT 3
3983: PUSH
3984: LD_INT 1
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: LIST
3991: PUSH
3992: LD_OWVAR 21
3996: PUSH
3997: LD_INT 3
3999: MOD
4000: PUSH
4001: LD_INT 1
4003: PLUS
4004: ARRAY
4005: PPUSH
4006: LD_INT 1
4008: PPUSH
4009: LD_INT 11
4011: PUSH
4012: LD_INT 4
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: LIST
4022: PUSH
4023: LD_INT 6
4025: PUSH
4026: LD_INT 7
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 6
4039: PUSH
4040: LD_INT 9
4042: PUSH
4043: LD_INT 12
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_OWVAR 21
4060: PUSH
4061: LD_INT 3
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 3
4075: PPUSH
4076: CALL_OW 12
4080: ARRAY
4081: PPUSH
4082: LD_INT 65
4084: PPUSH
4085: LD_INT 75
4087: PPUSH
4088: CALL_OW 12
4092: PPUSH
4093: CALL 55495 0 5
// end else
4097: GO 4246
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4099: LD_INT 22
4101: PUSH
4102: LD_INT 23
4104: PUSH
4105: LD_INT 23
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_OWVAR 21
4117: PUSH
4118: LD_INT 3
4120: MOD
4121: PUSH
4122: LD_INT 1
4124: PLUS
4125: ARRAY
4126: PPUSH
4127: LD_INT 1
4129: PUSH
4130: LD_INT 3
4132: PUSH
4133: LD_INT 1
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: LIST
4140: PUSH
4141: LD_OWVAR 21
4145: PUSH
4146: LD_INT 3
4148: MOD
4149: PUSH
4150: LD_INT 1
4152: PLUS
4153: ARRAY
4154: PPUSH
4155: LD_INT 1
4157: PPUSH
4158: LD_INT 45
4160: PUSH
4161: LD_INT 43
4163: PUSH
4164: LD_INT 44
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 46
4174: PUSH
4175: LD_INT 45
4177: PUSH
4178: LD_INT 44
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 46
4188: PUSH
4189: LD_INT 43
4191: PUSH
4192: LD_INT 45
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: LIST
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: LIST
4204: PUSH
4205: LD_OWVAR 21
4209: PUSH
4210: LD_INT 3
4212: MOD
4213: PUSH
4214: LD_INT 1
4216: PLUS
4217: ARRAY
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 65
4233: PPUSH
4234: LD_INT 75
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 55495 0 5
// end ; veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 3
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4256: LD_VAR 0 3
4260: PPUSH
4261: LD_INT 3
4263: PPUSH
4264: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4268: LD_VAR 0 3
4272: PPUSH
4273: LD_INT 30
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_VAR 0 3
4292: PPUSH
4293: CALL_OW 52
// end ;
4297: GO 3740
4299: POP
4300: POP
// if artifactArCaptured then
4301: LD_EXP 9
4305: IFFALSE 4391
// begin uc_nation := nation_american ;
4307: LD_ADDR_OWVAR 21
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4315: LD_INT 3
4317: PPUSH
4318: LD_INT 3
4320: PPUSH
4321: LD_INT 3
4323: PPUSH
4324: LD_INT 12
4326: PPUSH
4327: LD_INT 100
4329: PPUSH
4330: CALL 55495 0 5
// veh := CreateVehicle ;
4334: LD_ADDR_VAR 0 3
4338: PUSH
4339: CALL_OW 45
4343: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4344: LD_VAR 0 3
4348: PPUSH
4349: LD_INT 3
4351: PPUSH
4352: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4356: LD_VAR 0 3
4360: PPUSH
4361: LD_INT 198
4363: PPUSH
4364: LD_INT 22
4366: PPUSH
4367: LD_INT 0
4369: PPUSH
4370: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4374: LD_VAR 0 3
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: LD_INT 50
4384: PPUSH
4385: CALL_OW 290
// end else
4389: GO 4410
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4391: LD_INT 4
4393: PPUSH
4394: LD_INT 267
4396: PPUSH
4397: LD_INT 226
4399: PPUSH
4400: LD_INT 5
4402: PPUSH
4403: LD_INT 0
4405: PPUSH
4406: CALL_OW 58
// end ; uc_nation := nation_american ;
4410: LD_ADDR_OWVAR 21
4414: PUSH
4415: LD_INT 1
4417: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4418: LD_INT 3
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: LD_INT 3
4426: PPUSH
4427: LD_INT 12
4429: PPUSH
4430: LD_INT 100
4432: PPUSH
4433: CALL 55495 0 5
// veh := CreateVehicle ;
4437: LD_ADDR_VAR 0 3
4441: PUSH
4442: CALL_OW 45
4446: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4447: LD_VAR 0 3
4451: PPUSH
4452: LD_INT 3
4454: PPUSH
4455: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4459: LD_VAR 0 3
4463: PPUSH
4464: LD_INT 218
4466: PPUSH
4467: LD_INT 23
4469: PPUSH
4470: LD_INT 0
4472: PPUSH
4473: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4477: LD_VAR 0 3
4481: PPUSH
4482: LD_INT 4
4484: PPUSH
4485: LD_INT 30
4487: PPUSH
4488: CALL_OW 290
// uc_nation := nation_russian ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4500: LD_INT 22
4502: PPUSH
4503: LD_INT 3
4505: PPUSH
4506: LD_INT 3
4508: PPUSH
4509: LD_INT 51
4511: PPUSH
4512: LD_INT 100
4514: PPUSH
4515: CALL 55495 0 5
// veh := CreateVehicle ;
4519: LD_ADDR_VAR 0 3
4523: PUSH
4524: CALL_OW 45
4528: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4529: LD_VAR 0 3
4533: PPUSH
4534: LD_INT 3
4536: PPUSH
4537: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4541: LD_VAR 0 3
4545: PPUSH
4546: LD_INT 214
4548: PPUSH
4549: LD_INT 20
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4559: LD_VAR 0 3
4563: PPUSH
4564: LD_INT 4
4566: PPUSH
4567: LD_INT 40
4569: PPUSH
4570: CALL_OW 290
// end ; end_of_file
4574: LD_VAR 0 1
4578: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4579: LD_INT 0
4581: PPUSH
4582: PPUSH
4583: PPUSH
4584: PPUSH
4585: PPUSH
4586: PPUSH
4587: PPUSH
4588: PPUSH
4589: PPUSH
4590: PPUSH
// InitHc ;
4591: CALL_OW 19
// uc_side := 1 ;
4595: LD_ADDR_OWVAR 20
4599: PUSH
4600: LD_INT 1
4602: ST_TO_ADDR
// uc_nation := 1 ;
4603: LD_ADDR_OWVAR 21
4607: PUSH
4608: LD_INT 1
4610: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4611: LD_ADDR_VAR 0 2
4615: PUSH
4616: LD_INT 22
4618: PUSH
4619: LD_INT 1
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PUSH
4626: LD_INT 21
4628: PUSH
4629: LD_INT 3
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 69
4644: PUSH
4645: FOR_IN
4646: IFFALSE 4662
// SetBLevel ( i , 10 ) ;
4648: LD_VAR 0 2
4652: PPUSH
4653: LD_INT 10
4655: PPUSH
4656: CALL_OW 241
4660: GO 4645
4662: POP
4663: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4664: LD_INT 387
4666: PPUSH
4667: CALL_OW 274
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: LD_INT 7500
4677: PPUSH
4678: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4682: LD_INT 387
4684: PPUSH
4685: CALL_OW 274
4689: PPUSH
4690: LD_INT 2
4692: PPUSH
4693: LD_INT 4000
4695: PPUSH
4696: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4700: LD_INT 387
4702: PPUSH
4703: CALL_OW 274
4707: PPUSH
4708: LD_INT 3
4710: PPUSH
4711: LD_INT 50
4713: PPUSH
4714: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4718: LD_INT 476
4720: PPUSH
4721: CALL_OW 274
4725: PPUSH
4726: LD_INT 1
4728: PPUSH
4729: LD_INT 5500
4731: PPUSH
4732: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4736: LD_INT 476
4738: PPUSH
4739: CALL_OW 274
4743: PPUSH
4744: LD_INT 2
4746: PPUSH
4747: LD_INT 4000
4749: PPUSH
4750: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4754: LD_INT 476
4756: PPUSH
4757: CALL_OW 274
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4772: LD_ADDR_EXP 52
4776: PUSH
4777: LD_STRING Powell
4779: PPUSH
4780: CALL_OW 25
4784: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4785: LD_EXP 52
4789: PPUSH
4790: LD_INT 387
4792: PPUSH
4793: CALL_OW 52
// tmp := [ ] ;
4797: LD_ADDR_VAR 0 6
4801: PUSH
4802: EMPTY
4803: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4804: LD_ADDR_EXP 19
4808: PUSH
4809: LD_STRING Lisa
4811: PPUSH
4812: LD_EXP 1
4816: NOT
4817: PPUSH
4818: LD_STRING 12p_
4820: PPUSH
4821: CALL 50671 0 3
4825: ST_TO_ADDR
// if Lisa then
4826: LD_EXP 19
4830: IFFALSE 4848
// tmp := tmp ^ Lisa ;
4832: LD_ADDR_VAR 0 6
4836: PUSH
4837: LD_VAR 0 6
4841: PUSH
4842: LD_EXP 19
4846: ADD
4847: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4848: LD_ADDR_EXP 20
4852: PUSH
4853: LD_STRING Donaldson
4855: PPUSH
4856: LD_EXP 1
4860: NOT
4861: PPUSH
4862: LD_STRING 12p_
4864: PPUSH
4865: CALL 50671 0 3
4869: ST_TO_ADDR
// if Donaldson then
4870: LD_EXP 20
4874: IFFALSE 4892
// tmp := tmp ^ Donaldson ;
4876: LD_ADDR_VAR 0 6
4880: PUSH
4881: LD_VAR 0 6
4885: PUSH
4886: LD_EXP 20
4890: ADD
4891: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4892: LD_ADDR_EXP 21
4896: PUSH
4897: LD_STRING Bobby
4899: PPUSH
4900: LD_EXP 1
4904: NOT
4905: PPUSH
4906: LD_STRING 12p_
4908: PPUSH
4909: CALL 50671 0 3
4913: ST_TO_ADDR
// if Bobby then
4914: LD_EXP 21
4918: IFFALSE 4936
// tmp := tmp ^ Bobby ;
4920: LD_ADDR_VAR 0 6
4924: PUSH
4925: LD_VAR 0 6
4929: PUSH
4930: LD_EXP 21
4934: ADD
4935: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4936: LD_ADDR_EXP 22
4940: PUSH
4941: LD_STRING Cyrus
4943: PPUSH
4944: LD_EXP 1
4948: NOT
4949: PPUSH
4950: LD_STRING 12p_
4952: PPUSH
4953: CALL 50671 0 3
4957: ST_TO_ADDR
// if Cyrus then
4958: LD_EXP 22
4962: IFFALSE 4980
// tmp := tmp ^ Cyrus ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_VAR 0 6
4973: PUSH
4974: LD_EXP 22
4978: ADD
4979: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4980: LD_ADDR_EXP 24
4984: PUSH
4985: LD_STRING Brown
4987: PPUSH
4988: LD_EXP 1
4992: NOT
4993: PPUSH
4994: LD_STRING 12p_
4996: PPUSH
4997: CALL 50671 0 3
5001: ST_TO_ADDR
// if Brown then
5002: LD_EXP 24
5006: IFFALSE 5024
// tmp := tmp ^ Brown ;
5008: LD_ADDR_VAR 0 6
5012: PUSH
5013: LD_VAR 0 6
5017: PUSH
5018: LD_EXP 24
5022: ADD
5023: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5024: LD_ADDR_EXP 25
5028: PUSH
5029: LD_STRING Gladstone
5031: PPUSH
5032: LD_EXP 1
5036: NOT
5037: PPUSH
5038: LD_STRING 12p_
5040: PPUSH
5041: CALL 50671 0 3
5045: ST_TO_ADDR
// if Gladstone then
5046: LD_EXP 25
5050: IFFALSE 5068
// tmp := tmp ^ Gladstone ;
5052: LD_ADDR_VAR 0 6
5056: PUSH
5057: LD_VAR 0 6
5061: PUSH
5062: LD_EXP 25
5066: ADD
5067: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5068: LD_ADDR_EXP 26
5072: PUSH
5073: LD_STRING Houten
5075: PPUSH
5076: LD_EXP 1
5080: NOT
5081: PPUSH
5082: LD_STRING 12p_
5084: PPUSH
5085: CALL 50671 0 3
5089: ST_TO_ADDR
// if Houten then
5090: LD_EXP 26
5094: IFFALSE 5112
// tmp := tmp ^ Houten ;
5096: LD_ADDR_VAR 0 6
5100: PUSH
5101: LD_VAR 0 6
5105: PUSH
5106: LD_EXP 26
5110: ADD
5111: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5112: LD_ADDR_EXP 27
5116: PUSH
5117: LD_STRING Cornel
5119: PPUSH
5120: LD_EXP 1
5124: NOT
5125: PPUSH
5126: LD_STRING 12p_
5128: PPUSH
5129: CALL 50671 0 3
5133: ST_TO_ADDR
// if Cornel then
5134: LD_EXP 27
5138: IFFALSE 5156
// tmp := tmp ^ Cornel ;
5140: LD_ADDR_VAR 0 6
5144: PUSH
5145: LD_VAR 0 6
5149: PUSH
5150: LD_EXP 27
5154: ADD
5155: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5156: LD_ADDR_EXP 28
5160: PUSH
5161: LD_STRING Gary
5163: PPUSH
5164: LD_EXP 1
5168: NOT
5169: PPUSH
5170: LD_STRING 12p_
5172: PPUSH
5173: CALL 50671 0 3
5177: ST_TO_ADDR
// if Gary then
5178: LD_EXP 28
5182: IFFALSE 5200
// tmp := tmp ^ Gary ;
5184: LD_ADDR_VAR 0 6
5188: PUSH
5189: LD_VAR 0 6
5193: PUSH
5194: LD_EXP 28
5198: ADD
5199: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5200: LD_ADDR_EXP 30
5204: PUSH
5205: LD_STRING Kikuchi
5207: PPUSH
5208: LD_EXP 1
5212: NOT
5213: PPUSH
5214: LD_STRING 12p_
5216: PPUSH
5217: CALL 50671 0 3
5221: ST_TO_ADDR
// if Kikuchi then
5222: LD_EXP 30
5226: IFFALSE 5244
// tmp := tmp ^ Kikuchi ;
5228: LD_ADDR_VAR 0 6
5232: PUSH
5233: LD_VAR 0 6
5237: PUSH
5238: LD_EXP 30
5242: ADD
5243: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5244: LD_ADDR_VAR 0 6
5248: PUSH
5249: LD_VAR 0 6
5253: PUSH
5254: LD_STRING 12p_others
5256: PPUSH
5257: CALL_OW 31
5261: UNION
5262: ST_TO_ADDR
// if tmp < 36 then
5263: LD_VAR 0 6
5267: PUSH
5268: LD_INT 36
5270: LESS
5271: IFFALSE 5338
// for i = 1 to 36 - tmp do
5273: LD_ADDR_VAR 0 2
5277: PUSH
5278: DOUBLE
5279: LD_INT 1
5281: DEC
5282: ST_TO_ADDR
5283: LD_INT 36
5285: PUSH
5286: LD_VAR 0 6
5290: MINUS
5291: PUSH
5292: FOR_TO
5293: IFFALSE 5336
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5295: LD_INT 1
5297: PPUSH
5298: LD_VAR 0 2
5302: PUSH
5303: LD_INT 4
5305: MOD
5306: PUSH
5307: LD_INT 1
5309: PLUS
5310: PPUSH
5311: LD_INT 10
5313: PPUSH
5314: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5318: LD_ADDR_VAR 0 6
5322: PUSH
5323: LD_VAR 0 6
5327: PUSH
5328: CALL_OW 44
5332: ADD
5333: ST_TO_ADDR
// end ;
5334: GO 5292
5336: POP
5337: POP
// for i in tmp do
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: LD_VAR 0 6
5347: PUSH
5348: FOR_IN
5349: IFFALSE 5374
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5351: LD_VAR 0 2
5355: PPUSH
5356: LD_INT 62
5358: PPUSH
5359: LD_INT 93
5361: PPUSH
5362: LD_INT 9
5364: PPUSH
5365: LD_INT 0
5367: PPUSH
5368: CALL_OW 50
5372: GO 5348
5374: POP
5375: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5376: LD_ADDR_EXP 89
5380: PUSH
5381: LD_EXP 89
5385: PPUSH
5386: LD_INT 4
5388: PPUSH
5389: LD_INT 22
5391: PUSH
5392: LD_INT 1
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PPUSH
5399: CALL_OW 69
5403: PUSH
5404: LD_EXP 52
5408: DIFF
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// uc_side := 0 ;
5415: LD_ADDR_OWVAR 20
5419: PUSH
5420: LD_INT 0
5422: ST_TO_ADDR
// uc_nation := 0 ;
5423: LD_ADDR_OWVAR 21
5427: PUSH
5428: LD_INT 0
5430: ST_TO_ADDR
// for i = 1 to 4 do
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: DOUBLE
5437: LD_INT 1
5439: DEC
5440: ST_TO_ADDR
5441: LD_INT 4
5443: PUSH
5444: FOR_TO
5445: IFFALSE 5476
// begin InitHc ;
5447: CALL_OW 19
// hc_class := class_apeman ;
5451: LD_ADDR_OWVAR 28
5455: PUSH
5456: LD_INT 12
5458: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5459: CALL_OW 44
5463: PPUSH
5464: LD_INT 11
5466: PPUSH
5467: LD_INT 0
5469: PPUSH
5470: CALL_OW 49
// end ;
5474: GO 5444
5476: POP
5477: POP
// end ;
5478: LD_VAR 0 1
5482: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5483: LD_EXP 4
5487: NOT
5488: PUSH
5489: LD_INT 4
5491: PPUSH
5492: LD_INT 1
5494: PPUSH
5495: CALL 45745 0 2
5499: NOT
5500: AND
5501: IFFALSE 6273
5503: GO 5505
5505: DISABLE
5506: LD_INT 0
5508: PPUSH
5509: PPUSH
5510: PPUSH
// begin enable ;
5511: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5512: LD_INT 22
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 23
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: PUSH
5532: LD_INT 30
5534: PUSH
5535: LD_INT 3
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: LIST
5546: PPUSH
5547: CALL_OW 69
5551: NOT
5552: IFFALSE 5556
// exit ;
5554: GO 6273
// if Prob ( 40 ) then
5556: LD_INT 40
5558: PPUSH
5559: CALL_OW 13
5563: IFFALSE 5690
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5565: LD_INT 4
5567: PPUSH
5568: LD_INT 5
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: LD_INT 2
5576: PUSH
5577: LD_INT 7
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 5
5588: PUSH
5589: LD_INT 1
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: LD_INT 7
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 7
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 5
5624: PUSH
5625: LD_INT 1
5627: PUSH
5628: LD_INT 2
5630: PUSH
5631: LD_INT 6
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_INT 5
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 2
5648: PUSH
5649: LD_INT 6
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: PUSH
5658: LD_INT 5
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 2
5666: PUSH
5667: LD_INT 6
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PPUSH
5684: CALL 44327 0 2
// end else
5688: GO 5813
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5690: LD_INT 4
5692: PPUSH
5693: LD_INT 5
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: LD_INT 7
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 5
5713: PUSH
5714: LD_INT 1
5716: PUSH
5717: LD_INT 2
5719: PUSH
5720: LD_INT 9
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 5
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 9
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 5
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 6
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 5
5767: PUSH
5768: LD_INT 1
5770: PUSH
5771: LD_INT 2
5773: PUSH
5774: LD_INT 6
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 5
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 6
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: LIST
5799: LIST
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PPUSH
5809: CALL 44327 0 2
// end ; repeat wait ( 0 0$1 ) ;
5813: LD_INT 35
5815: PPUSH
5816: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5820: LD_INT 4
5822: PPUSH
5823: LD_INT 1
5825: PPUSH
5826: CALL 45745 0 2
5830: PUSH
5831: LD_INT 6
5833: GREATEREQUAL
5834: IFFALSE 5813
// wait ( 0 0$30 ) ;
5836: LD_INT 1050
5838: PPUSH
5839: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 4
5850: PPUSH
5851: LD_INT 1
5853: PPUSH
5854: CALL 45745 0 2
5858: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5859: LD_ADDR_EXP 108
5863: PUSH
5864: LD_EXP 108
5868: PPUSH
5869: LD_INT 4
5871: PPUSH
5872: LD_EXP 108
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: LD_VAR 0 2
5885: DIFF
5886: PPUSH
5887: CALL_OW 1
5891: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5892: LD_ADDR_VAR 0 3
5896: PUSH
5897: LD_INT 0
5899: PPUSH
5900: LD_INT 2
5902: PPUSH
5903: CALL_OW 12
5907: ST_TO_ADDR
// if target then
5908: LD_VAR 0 3
5912: IFFALSE 6040
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5914: LD_ADDR_VAR 0 2
5918: PUSH
5919: LD_VAR 0 2
5923: PPUSH
5924: LD_INT 24
5926: PUSH
5927: LD_INT 250
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PPUSH
5934: CALL_OW 72
5938: ST_TO_ADDR
// for i in tmp do
5939: LD_ADDR_VAR 0 1
5943: PUSH
5944: LD_VAR 0 2
5948: PUSH
5949: FOR_IN
5950: IFFALSE 5990
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5952: LD_VAR 0 1
5956: PPUSH
5957: LD_INT 114
5959: PPUSH
5960: LD_INT 108
5962: PPUSH
5963: CALL_OW 297
5967: PUSH
5968: LD_INT 9
5970: GREATER
5971: IFFALSE 5988
// ComMoveXY ( i , 114 , 108 ) ;
5973: LD_VAR 0 1
5977: PPUSH
5978: LD_INT 114
5980: PPUSH
5981: LD_INT 108
5983: PPUSH
5984: CALL_OW 111
5988: GO 5949
5990: POP
5991: POP
// wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5999: LD_VAR 0 2
6003: PPUSH
6004: LD_INT 92
6006: PUSH
6007: LD_INT 114
6009: PUSH
6010: LD_INT 108
6012: PUSH
6013: LD_INT 9
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PPUSH
6022: CALL_OW 72
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: LD_INT 1
6034: MINUS
6035: GREATEREQUAL
6036: IFFALSE 5914
// end else
6038: GO 6164
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6040: LD_ADDR_VAR 0 2
6044: PUSH
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 24
6052: PUSH
6053: LD_INT 250
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL_OW 72
6064: ST_TO_ADDR
// for i in tmp do
6065: LD_ADDR_VAR 0 1
6069: PUSH
6070: LD_VAR 0 2
6074: PUSH
6075: FOR_IN
6076: IFFALSE 6116
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 129
6085: PPUSH
6086: LD_INT 139
6088: PPUSH
6089: CALL_OW 297
6093: PUSH
6094: LD_INT 9
6096: GREATER
6097: IFFALSE 6114
// ComMoveXY ( i , 129 , 139 ) ;
6099: LD_VAR 0 1
6103: PPUSH
6104: LD_INT 129
6106: PPUSH
6107: LD_INT 139
6109: PPUSH
6110: CALL_OW 111
6114: GO 6075
6116: POP
6117: POP
// wait ( 0 0$1 ) ;
6118: LD_INT 35
6120: PPUSH
6121: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6125: LD_VAR 0 2
6129: PPUSH
6130: LD_INT 92
6132: PUSH
6133: LD_INT 129
6135: PUSH
6136: LD_INT 139
6138: PUSH
6139: LD_INT 9
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PPUSH
6148: CALL_OW 72
6152: PUSH
6153: LD_VAR 0 2
6157: PUSH
6158: LD_INT 1
6160: MINUS
6161: GREATEREQUAL
6162: IFFALSE 6040
// end ; repeat wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// for i in tmp do
6171: LD_ADDR_VAR 0 1
6175: PUSH
6176: LD_VAR 0 2
6180: PUSH
6181: FOR_IN
6182: IFFALSE 6264
// begin if GetLives ( i ) > 251 then
6184: LD_VAR 0 1
6188: PPUSH
6189: CALL_OW 256
6193: PUSH
6194: LD_INT 251
6196: GREATER
6197: IFFALSE 6235
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6199: LD_VAR 0 1
6203: PPUSH
6204: LD_INT 81
6206: PUSH
6207: LD_INT 1
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: PPUSH
6214: CALL_OW 69
6218: PPUSH
6219: LD_VAR 0 1
6223: PPUSH
6224: CALL_OW 74
6228: PPUSH
6229: CALL_OW 115
6233: GO 6262
// if IsDead ( i ) then
6235: LD_VAR 0 1
6239: PPUSH
6240: CALL_OW 301
6244: IFFALSE 6262
// tmp := tmp diff i ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PUSH
6256: LD_VAR 0 1
6260: DIFF
6261: ST_TO_ADDR
// end ;
6262: GO 6181
6264: POP
6265: POP
// until not tmp ;
6266: LD_VAR 0 2
6270: NOT
6271: IFFALSE 6164
// end ;
6273: PPOPN 3
6275: END
// every 30 30$00 trigger not americanDestroyed do
6276: LD_EXP 4
6280: NOT
6281: IFFALSE 6346
6283: GO 6285
6285: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6286: LD_INT 63000
6288: PUSH
6289: LD_INT 42000
6291: PUSH
6292: LD_INT 21000
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PPUSH
6306: CALL_OW 67
// if americanDestroyed then
6310: LD_EXP 4
6314: IFFALSE 6318
// exit ;
6316: GO 6346
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6318: LD_INT 4
6320: PPUSH
6321: LD_INT 5
6323: PUSH
6324: LD_INT 3
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: LD_INT 8
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: EMPTY
6340: LIST
6341: PPUSH
6342: CALL 44327 0 2
// end ; end_of_file
6346: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6347: LD_INT 0
6349: PPUSH
6350: PPUSH
6351: PPUSH
6352: PPUSH
6353: PPUSH
// side := 2 ;
6354: LD_ADDR_VAR 0 5
6358: PUSH
6359: LD_INT 2
6361: ST_TO_ADDR
// InitHc ;
6362: CALL_OW 19
// uc_side := side ;
6366: LD_ADDR_OWVAR 20
6370: PUSH
6371: LD_VAR 0 5
6375: ST_TO_ADDR
// uc_nation := 2 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 2
6383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_INT 2
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 21
6401: PUSH
6402: LD_INT 3
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6435
// SetBLevel ( i , 10 ) ;
6421: LD_VAR 0 2
6425: PPUSH
6426: LD_INT 10
6428: PPUSH
6429: CALL_OW 241
6433: GO 6418
6435: POP
6436: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6437: LD_ADDR_VAR 0 4
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_VAR 0 5
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 30
6456: PUSH
6457: LD_INT 32
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 58
6466: PUSH
6467: EMPTY
6468: LIST
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: LIST
6474: PPUSH
6475: CALL_OW 69
6479: ST_TO_ADDR
// for i = 1 to 10 do
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: DOUBLE
6486: LD_INT 1
6488: DEC
6489: ST_TO_ADDR
6490: LD_INT 10
6492: PUSH
6493: FOR_TO
6494: IFFALSE 6566
// begin uc_nation := nation_nature ;
6496: LD_ADDR_OWVAR 21
6500: PUSH
6501: LD_INT 0
6503: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6504: LD_ADDR_OWVAR 28
6508: PUSH
6509: LD_INT 15
6511: ST_TO_ADDR
// hc_gallery :=  ;
6512: LD_ADDR_OWVAR 33
6516: PUSH
6517: LD_STRING 
6519: ST_TO_ADDR
// hc_name :=  ;
6520: LD_ADDR_OWVAR 26
6524: PUSH
6525: LD_STRING 
6527: ST_TO_ADDR
// un := CreateHuman ;
6528: LD_ADDR_VAR 0 3
6532: PUSH
6533: CALL_OW 44
6537: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6538: LD_VAR 0 3
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_VAR 0 4
6552: PUSH
6553: LD_VAR 0 2
6557: MINUS
6558: ARRAY
6559: PPUSH
6560: CALL_OW 52
// end ;
6564: GO 6493
6566: POP
6567: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6568: LD_INT 503
6570: PPUSH
6571: LD_INT 27
6573: PPUSH
6574: LD_STRING 
6576: PPUSH
6577: LD_INT 8
6579: PUSH
6580: LD_INT 9
6582: PUSH
6583: LD_INT 10
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: PUSH
6591: LD_OWVAR 67
6595: ARRAY
6596: PPUSH
6597: LD_INT 3000
6599: PUSH
6600: LD_INT 500
6602: PUSH
6603: LD_INT 150
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: PPUSH
6611: LD_INT 16
6613: PUSH
6614: LD_INT 6
6616: PUSH
6617: LD_INT 6
6619: PUSH
6620: LD_INT 6
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PPUSH
6629: CALL 58904 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6633: LD_ADDR_EXP 89
6637: PUSH
6638: LD_EXP 89
6642: PPUSH
6643: LD_INT 1
6645: PPUSH
6646: LD_INT 22
6648: PUSH
6649: LD_VAR 0 5
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PUSH
6658: LD_INT 23
6660: PUSH
6661: LD_INT 2
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 3
6670: PUSH
6671: LD_INT 21
6673: PUSH
6674: LD_INT 2
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: LIST
6689: PPUSH
6690: CALL_OW 69
6694: PPUSH
6695: CALL_OW 1
6699: ST_TO_ADDR
// end ;
6700: LD_VAR 0 1
6704: RET
// export Omar ; export function PrepareOmarAli ; begin
6705: LD_INT 0
6707: PPUSH
// uc_side := 5 ;
6708: LD_ADDR_OWVAR 20
6712: PUSH
6713: LD_INT 5
6715: ST_TO_ADDR
// uc_nation := 2 ;
6716: LD_ADDR_OWVAR 21
6720: PUSH
6721: LD_INT 2
6723: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6724: LD_ADDR_EXP 53
6728: PUSH
6729: LD_STRING Omar
6731: PPUSH
6732: CALL_OW 25
6736: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6737: LD_EXP 53
6741: PPUSH
6742: LD_INT 330
6744: PPUSH
6745: LD_INT 244
6747: PPUSH
6748: LD_INT 0
6750: PPUSH
6751: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6755: LD_EXP 53
6759: PPUSH
6760: LD_INT 252
6762: PPUSH
6763: LD_INT 220
6765: PPUSH
6766: CALL_OW 111
// end ; end_of_file
6770: LD_VAR 0 1
6774: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6775: LD_INT 0
6777: PPUSH
6778: PPUSH
6779: PPUSH
6780: PPUSH
6781: PPUSH
// side := 8 ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_INT 8
6789: ST_TO_ADDR
// InitHc ;
6790: CALL_OW 19
// uc_side := side ;
6794: LD_ADDR_OWVAR 20
6798: PUSH
6799: LD_VAR 0 3
6803: ST_TO_ADDR
// uc_nation := 2 ;
6804: LD_ADDR_OWVAR 21
6808: PUSH
6809: LD_INT 2
6811: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 21
6831: PUSH
6832: LD_INT 3
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PPUSH
6843: CALL_OW 69
6847: PUSH
6848: FOR_IN
6849: IFFALSE 6865
// SetBLevel ( i , 10 ) ;
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_INT 10
6858: PPUSH
6859: CALL_OW 241
6863: GO 6848
6865: POP
6866: POP
// Schulz := NewCharacter ( Schulz ) ;
6867: LD_ADDR_EXP 54
6871: PUSH
6872: LD_STRING Schulz
6874: PPUSH
6875: CALL_OW 25
6879: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6880: LD_ADDR_EXP 55
6884: PUSH
6885: LD_STRING Kozlov
6887: PPUSH
6888: LD_INT 0
6890: PPUSH
6891: LD_STRING 
6893: PPUSH
6894: CALL 50671 0 3
6898: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6899: LD_EXP 55
6903: PPUSH
6904: LD_INT 22
6906: PUSH
6907: LD_INT 8
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PUSH
6914: LD_INT 23
6916: PUSH
6917: LD_INT 3
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 30
6926: PUSH
6927: LD_INT 8
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: PPUSH
6939: CALL_OW 69
6943: PUSH
6944: LD_INT 1
6946: ARRAY
6947: PPUSH
6948: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6952: LD_EXP 55
6956: PPUSH
6957: LD_INT 3
6959: PPUSH
6960: LD_INT 10
6962: PPUSH
6963: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6967: LD_ADDR_VAR 0 5
6971: PUSH
6972: LD_INT 22
6974: PUSH
6975: LD_VAR 0 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 30
6986: PUSH
6987: LD_INT 32
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 58
6996: PUSH
6997: EMPTY
6998: LIST
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: LIST
7004: PPUSH
7005: CALL_OW 69
7009: ST_TO_ADDR
// for i = 1 to 10 do
7010: LD_ADDR_VAR 0 2
7014: PUSH
7015: DOUBLE
7016: LD_INT 1
7018: DEC
7019: ST_TO_ADDR
7020: LD_INT 10
7022: PUSH
7023: FOR_TO
7024: IFFALSE 7096
// begin uc_nation := nation_nature ;
7026: LD_ADDR_OWVAR 21
7030: PUSH
7031: LD_INT 0
7033: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7034: LD_ADDR_OWVAR 28
7038: PUSH
7039: LD_INT 15
7041: ST_TO_ADDR
// hc_gallery :=  ;
7042: LD_ADDR_OWVAR 33
7046: PUSH
7047: LD_STRING 
7049: ST_TO_ADDR
// hc_name :=  ;
7050: LD_ADDR_OWVAR 26
7054: PUSH
7055: LD_STRING 
7057: ST_TO_ADDR
// un := CreateHuman ;
7058: LD_ADDR_VAR 0 4
7062: PUSH
7063: CALL_OW 44
7067: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7068: LD_VAR 0 4
7072: PPUSH
7073: LD_VAR 0 5
7077: PUSH
7078: LD_VAR 0 5
7082: PUSH
7083: LD_VAR 0 2
7087: MINUS
7088: ARRAY
7089: PPUSH
7090: CALL_OW 52
// end ;
7094: GO 7023
7096: POP
7097: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7098: LD_INT 324
7100: PPUSH
7101: LD_INT 3
7103: PPUSH
7104: LD_STRING 
7106: PPUSH
7107: LD_INT 8
7109: PUSH
7110: LD_INT 9
7112: PUSH
7113: LD_INT 10
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: PUSH
7121: LD_OWVAR 67
7125: ARRAY
7126: PPUSH
7127: LD_INT 3000
7129: PUSH
7130: LD_INT 500
7132: PUSH
7133: LD_INT 150
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PPUSH
7141: LD_INT 16
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 6
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: PPUSH
7159: CALL 58904 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7163: LD_ADDR_EXP 89
7167: PUSH
7168: LD_EXP 89
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: LD_INT 22
7178: PUSH
7179: LD_VAR 0 3
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: LD_INT 23
7190: PUSH
7191: LD_INT 2
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: LD_INT 3
7200: PUSH
7201: LD_INT 21
7203: PUSH
7204: LD_INT 2
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: CALL_OW 69
7224: PUSH
7225: LD_EXP 54
7229: DIFF
7230: PPUSH
7231: CALL_OW 1
7235: ST_TO_ADDR
// end ;
7236: LD_VAR 0 1
7240: RET
// export function BuildKozlovBomb ; begin
7241: LD_INT 0
7243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7244: LD_INT 332
7246: PPUSH
7247: CALL_OW 302
7251: NOT
7252: PUSH
7253: LD_INT 336
7255: PPUSH
7256: CALL_OW 302
7260: NOT
7261: OR
7262: IFFALSE 7266
// exit ;
7264: GO 7363
// ComChangeProfession ( Kozlov , 4 ) ;
7266: LD_EXP 55
7270: PPUSH
7271: LD_INT 4
7273: PPUSH
7274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7278: LD_INT 336
7280: PPUSH
7281: LD_INT 25
7283: PPUSH
7284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7288: LD_INT 35
7290: PPUSH
7291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7295: LD_INT 25
7297: PPUSH
7298: LD_INT 8
7300: PPUSH
7301: CALL_OW 321
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7288
// ComExitBuilding ( Kozlov ) ;
7311: LD_EXP 55
7315: PPUSH
7316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7320: LD_EXP 55
7324: PPUSH
7325: LD_INT 332
7327: PPUSH
7328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7332: LD_EXP 55
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7344: LD_INT 332
7346: PPUSH
7347: LD_INT 23
7349: PPUSH
7350: LD_INT 3
7352: PPUSH
7353: LD_INT 1
7355: PPUSH
7356: LD_INT 48
7358: PPUSH
7359: CALL_OW 125
// end ;
7363: LD_VAR 0 1
7367: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7368: LD_EXP 3
7372: NOT
7373: PUSH
7374: LD_INT 3
7376: PPUSH
7377: LD_INT 1
7379: PPUSH
7380: CALL 45745 0 2
7384: NOT
7385: AND
7386: IFFALSE 8226
7388: GO 7390
7390: DISABLE
7391: LD_INT 0
7393: PPUSH
7394: PPUSH
7395: PPUSH
// begin enable ;
7396: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7397: LD_INT 22
7399: PUSH
7400: LD_INT 8
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PUSH
7407: LD_INT 23
7409: PUSH
7410: LD_INT 2
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 30
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: PPUSH
7432: CALL_OW 69
7436: NOT
7437: IFFALSE 7441
// exit ;
7439: GO 8226
// if Prob ( 40 ) then
7441: LD_INT 40
7443: PPUSH
7444: CALL_OW 13
7448: IFFALSE 7575
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7450: LD_INT 3
7452: PPUSH
7453: LD_INT 14
7455: PUSH
7456: LD_INT 1
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: LD_INT 28
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PUSH
7471: LD_INT 14
7473: PUSH
7474: LD_INT 1
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 28
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 14
7491: PUSH
7492: LD_INT 1
7494: PUSH
7495: LD_INT 2
7497: PUSH
7498: LD_INT 28
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 14
7509: PUSH
7510: LD_INT 1
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 28
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: LD_INT 14
7527: PUSH
7528: LD_INT 1
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: LD_INT 28
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: LD_INT 14
7545: PUSH
7546: LD_INT 1
7548: PUSH
7549: LD_INT 2
7551: PUSH
7552: LD_INT 26
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: PPUSH
7569: CALL 44327 0 2
// end else
7573: GO 7766
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7575: LD_INT 3
7577: PPUSH
7578: LD_INT 14
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 2
7586: PUSH
7587: LD_INT 27
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: LD_INT 26
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: PUSH
7601: LD_OWVAR 67
7605: ARRAY
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 14
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: LD_INT 2
7621: PUSH
7622: LD_INT 27
7624: PUSH
7625: LD_INT 26
7627: PUSH
7628: LD_INT 26
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: LD_OWVAR 67
7640: ARRAY
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: LIST
7647: PUSH
7648: LD_INT 14
7650: PUSH
7651: LD_INT 1
7653: PUSH
7654: LD_INT 2
7656: PUSH
7657: LD_INT 26
7659: PUSH
7660: LD_INT 26
7662: PUSH
7663: LD_INT 29
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_OWVAR 67
7675: ARRAY
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 13
7685: PUSH
7686: LD_INT 1
7688: PUSH
7689: LD_INT 2
7691: PUSH
7692: LD_INT 26
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: LD_INT 29
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: PUSH
7706: LD_OWVAR 67
7710: ARRAY
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 13
7720: PUSH
7721: LD_INT 1
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: LD_INT 29
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 14
7738: PUSH
7739: LD_INT 1
7741: PUSH
7742: LD_INT 2
7744: PUSH
7745: LD_INT 26
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PPUSH
7762: CALL 44327 0 2
// end ; repeat wait ( 0 0$1 ) ;
7766: LD_INT 35
7768: PPUSH
7769: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7773: LD_INT 3
7775: PPUSH
7776: LD_INT 1
7778: PPUSH
7779: CALL 45745 0 2
7783: PUSH
7784: LD_INT 6
7786: GREATEREQUAL
7787: IFFALSE 7766
// wait ( 0 0$30 ) ;
7789: LD_INT 1050
7791: PPUSH
7792: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7796: LD_ADDR_VAR 0 2
7800: PUSH
7801: LD_INT 3
7803: PPUSH
7804: LD_INT 1
7806: PPUSH
7807: CALL 45745 0 2
7811: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7812: LD_ADDR_EXP 108
7816: PUSH
7817: LD_EXP 108
7821: PPUSH
7822: LD_INT 3
7824: PPUSH
7825: LD_EXP 108
7829: PUSH
7830: LD_INT 3
7832: ARRAY
7833: PUSH
7834: LD_VAR 0 2
7838: DIFF
7839: PPUSH
7840: CALL_OW 1
7844: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7845: LD_ADDR_VAR 0 3
7849: PUSH
7850: LD_INT 0
7852: PPUSH
7853: LD_INT 2
7855: PPUSH
7856: CALL_OW 12
7860: ST_TO_ADDR
// if target then
7861: LD_VAR 0 3
7865: IFFALSE 7993
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7867: LD_ADDR_VAR 0 2
7871: PUSH
7872: LD_VAR 0 2
7876: PPUSH
7877: LD_INT 24
7879: PUSH
7880: LD_INT 250
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 72
7891: ST_TO_ADDR
// for i in tmp do
7892: LD_ADDR_VAR 0 1
7896: PUSH
7897: LD_VAR 0 2
7901: PUSH
7902: FOR_IN
7903: IFFALSE 7943
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7905: LD_VAR 0 1
7909: PPUSH
7910: LD_INT 89
7912: PPUSH
7913: LD_INT 71
7915: PPUSH
7916: CALL_OW 297
7920: PUSH
7921: LD_INT 9
7923: GREATER
7924: IFFALSE 7941
// ComMoveXY ( i , 89 , 71 ) ;
7926: LD_VAR 0 1
7930: PPUSH
7931: LD_INT 89
7933: PPUSH
7934: LD_INT 71
7936: PPUSH
7937: CALL_OW 111
7941: GO 7902
7943: POP
7944: POP
// wait ( 0 0$1 ) ;
7945: LD_INT 35
7947: PPUSH
7948: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7952: LD_VAR 0 2
7956: PPUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 89
7962: PUSH
7963: LD_INT 71
7965: PUSH
7966: LD_INT 9
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PPUSH
7975: CALL_OW 72
7979: PUSH
7980: LD_VAR 0 2
7984: PUSH
7985: LD_INT 1
7987: MINUS
7988: GREATEREQUAL
7989: IFFALSE 7867
// end else
7991: GO 8117
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7993: LD_ADDR_VAR 0 2
7997: PUSH
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 24
8005: PUSH
8006: LD_INT 250
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// for i in tmp do
8018: LD_ADDR_VAR 0 1
8022: PUSH
8023: LD_VAR 0 2
8027: PUSH
8028: FOR_IN
8029: IFFALSE 8069
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8031: LD_VAR 0 1
8035: PPUSH
8036: LD_INT 147
8038: PPUSH
8039: LD_INT 4
8041: PPUSH
8042: CALL_OW 297
8046: PUSH
8047: LD_INT 9
8049: GREATER
8050: IFFALSE 8067
// ComMoveXY ( i , 147 , 4 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 147
8059: PPUSH
8060: LD_INT 4
8062: PPUSH
8063: CALL_OW 111
8067: GO 8028
8069: POP
8070: POP
// wait ( 0 0$1 ) ;
8071: LD_INT 35
8073: PPUSH
8074: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8078: LD_VAR 0 2
8082: PPUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 147
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 9
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 72
8105: PUSH
8106: LD_VAR 0 2
8110: PUSH
8111: LD_INT 1
8113: MINUS
8114: GREATEREQUAL
8115: IFFALSE 7993
// end ; repeat wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// for i in tmp do
8124: LD_ADDR_VAR 0 1
8128: PUSH
8129: LD_VAR 0 2
8133: PUSH
8134: FOR_IN
8135: IFFALSE 8217
// begin if GetLives ( i ) > 251 then
8137: LD_VAR 0 1
8141: PPUSH
8142: CALL_OW 256
8146: PUSH
8147: LD_INT 251
8149: GREATER
8150: IFFALSE 8188
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8152: LD_VAR 0 1
8156: PPUSH
8157: LD_INT 81
8159: PUSH
8160: LD_INT 8
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: PPUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: CALL_OW 74
8181: PPUSH
8182: CALL_OW 115
8186: GO 8215
// if IsDead ( i ) then
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 301
8197: IFFALSE 8215
// tmp := tmp diff i ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_VAR 0 2
8208: PUSH
8209: LD_VAR 0 1
8213: DIFF
8214: ST_TO_ADDR
// end ;
8215: GO 8134
8217: POP
8218: POP
// until not tmp ;
8219: LD_VAR 0 2
8223: NOT
8224: IFFALSE 8117
// end ;
8226: PPOPN 3
8228: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8229: LD_EXP 55
8233: PPUSH
8234: CALL_OW 302
8238: PUSH
8239: LD_EXP 3
8243: NOT
8244: AND
8245: IFFALSE 8254
8247: GO 8249
8249: DISABLE
// BuildKozlovBomb ;
8250: CALL 7241 0 0
8254: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8255: LD_INT 22
8257: PUSH
8258: LD_INT 8
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 34
8267: PUSH
8268: LD_INT 48
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PPUSH
8279: CALL_OW 69
8283: IFFALSE 8331
8285: GO 8287
8287: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8288: LD_INT 22
8290: PUSH
8291: LD_INT 8
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: LD_INT 34
8300: PUSH
8301: LD_INT 48
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 69
8316: PUSH
8317: LD_INT 1
8319: ARRAY
8320: PPUSH
8321: LD_INT 173
8323: PPUSH
8324: LD_INT 96
8326: PPUSH
8327: CALL_OW 116
// end ; end_of_file
8331: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8332: LD_INT 0
8334: PPUSH
8335: PPUSH
8336: PPUSH
8337: PPUSH
8338: PPUSH
8339: PPUSH
8340: PPUSH
8341: PPUSH
8342: PPUSH
// side := 3 ;
8343: LD_ADDR_VAR 0 6
8347: PUSH
8348: LD_INT 3
8350: ST_TO_ADDR
// InitHc ;
8351: CALL_OW 19
// uc_side := side ;
8355: LD_ADDR_OWVAR 20
8359: PUSH
8360: LD_VAR 0 6
8364: ST_TO_ADDR
// uc_nation := 3 ;
8365: LD_ADDR_OWVAR 21
8369: PUSH
8370: LD_INT 3
8372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_VAR 0 6
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 21
8392: PUSH
8393: LD_INT 3
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PPUSH
8404: CALL_OW 69
8408: PUSH
8409: FOR_IN
8410: IFFALSE 8426
// SetBLevel ( i , 10 ) ;
8412: LD_VAR 0 2
8416: PPUSH
8417: LD_INT 10
8419: PPUSH
8420: CALL_OW 241
8424: GO 8409
8426: POP
8427: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8428: LD_ADDR_VAR 0 9
8432: PUSH
8433: LD_INT 22
8435: PUSH
8436: LD_VAR 0 6
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: PUSH
8445: LD_INT 30
8447: PUSH
8448: LD_INT 34
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: PPUSH
8459: CALL_OW 69
8463: ST_TO_ADDR
// if teleport then
8464: LD_VAR 0 9
8468: IFFALSE 8489
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8470: LD_VAR 0 9
8474: PUSH
8475: LD_INT 1
8477: ARRAY
8478: PPUSH
8479: LD_INT 123
8481: PPUSH
8482: LD_INT 122
8484: PPUSH
8485: CALL_OW 243
// hc_importance := 0 ;
8489: LD_ADDR_OWVAR 32
8493: PUSH
8494: LD_INT 0
8496: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8497: LD_ADDR_EXP 56
8501: PUSH
8502: LD_STRING Platonov
8504: PPUSH
8505: CALL_OW 25
8509: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8510: LD_ADDR_EXP 57
8514: PUSH
8515: LD_STRING Yakotich
8517: PPUSH
8518: CALL_OW 25
8522: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8523: LD_ADDR_EXP 58
8527: PUSH
8528: LD_STRING Gleb
8530: PPUSH
8531: CALL_OW 25
8535: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8536: LD_STRING 03_Cornel
8538: PPUSH
8539: CALL_OW 28
8543: IFFALSE 8591
// begin Bierezov := NewCharacter ( Mikhail ) ;
8545: LD_ADDR_EXP 59
8549: PUSH
8550: LD_STRING Mikhail
8552: PPUSH
8553: CALL_OW 25
8557: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8558: LD_EXP 59
8562: PPUSH
8563: LD_INT 197
8565: PPUSH
8566: LD_INT 111
8568: PPUSH
8569: LD_INT 9
8571: PPUSH
8572: LD_INT 0
8574: PPUSH
8575: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8579: LD_EXP 59
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8591: LD_EXP 56
8595: PPUSH
8596: LD_INT 126
8598: PPUSH
8599: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8603: LD_EXP 57
8607: PPUSH
8608: LD_INT 197
8610: PPUSH
8611: LD_INT 111
8613: PPUSH
8614: LD_INT 9
8616: PPUSH
8617: LD_INT 0
8619: PPUSH
8620: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8624: LD_EXP 58
8628: PPUSH
8629: LD_INT 197
8631: PPUSH
8632: LD_INT 111
8634: PPUSH
8635: LD_INT 9
8637: PPUSH
8638: LD_INT 0
8640: PPUSH
8641: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8645: LD_ADDR_VAR 0 5
8649: PUSH
8650: LD_INT 126
8652: PPUSH
8653: LD_INT 2
8655: PPUSH
8656: LD_STRING zhukov
8658: PPUSH
8659: LD_INT 9
8661: PUSH
8662: LD_INT 10
8664: PUSH
8665: LD_INT 10
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_OWVAR 67
8677: ARRAY
8678: PPUSH
8679: LD_INT 9000
8681: PUSH
8682: LD_INT 1000
8684: PUSH
8685: LD_INT 300
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: LD_INT 21
8695: PUSH
8696: LD_INT 8
8698: PUSH
8699: LD_INT 13
8701: PUSH
8702: LD_INT 8
8704: PUSH
8705: EMPTY
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL 58904 0 6
8715: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8716: LD_ADDR_VAR 0 4
8720: PUSH
8721: LD_INT 267
8723: PPUSH
8724: CALL_OW 274
8728: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8729: LD_VAR 0 4
8733: PPUSH
8734: LD_INT 1
8736: PPUSH
8737: LD_INT 5000
8739: PPUSH
8740: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8744: LD_VAR 0 4
8748: PPUSH
8749: LD_INT 2
8751: PPUSH
8752: LD_INT 200
8754: PPUSH
8755: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8759: LD_VAR 0 4
8763: PPUSH
8764: LD_INT 3
8766: PPUSH
8767: LD_INT 200
8769: PPUSH
8770: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8774: LD_ADDR_EXP 89
8778: PUSH
8779: LD_EXP 89
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: LD_VAR 0 5
8791: PUSH
8792: LD_INT 22
8794: PUSH
8795: LD_VAR 0 6
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 2
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PPUSH
8825: CALL_OW 69
8829: UNION
8830: PUSH
8831: LD_EXP 56
8835: DIFF
8836: PPUSH
8837: CALL_OW 1
8841: ST_TO_ADDR
// behemoths := [ ] ;
8842: LD_ADDR_EXP 60
8846: PUSH
8847: EMPTY
8848: ST_TO_ADDR
// behemothBuilders := [ ] ;
8849: LD_ADDR_EXP 61
8853: PUSH
8854: EMPTY
8855: ST_TO_ADDR
// j := 3 ;
8856: LD_ADDR_VAR 0 3
8860: PUSH
8861: LD_INT 3
8863: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8864: LD_ADDR_VAR 0 2
8868: PUSH
8869: LD_INT 22
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 25
8881: PUSH
8882: LD_INT 3
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PPUSH
8893: CALL_OW 69
8897: PUSH
8898: FOR_IN
8899: IFFALSE 8949
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8901: LD_ADDR_EXP 61
8905: PUSH
8906: LD_EXP 61
8910: PPUSH
8911: LD_VAR 0 2
8915: PPUSH
8916: CALL 86541 0 2
8920: ST_TO_ADDR
// j := j - 1 ;
8921: LD_ADDR_VAR 0 3
8925: PUSH
8926: LD_VAR 0 3
8930: PUSH
8931: LD_INT 1
8933: MINUS
8934: ST_TO_ADDR
// if j = 0 then
8935: LD_VAR 0 3
8939: PUSH
8940: LD_INT 0
8942: EQUAL
8943: IFFALSE 8947
// break ;
8945: GO 8949
// end ;
8947: GO 8898
8949: POP
8950: POP
// end ;
8951: LD_VAR 0 1
8955: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8956: LD_INT 0
8958: PPUSH
8959: PPUSH
8960: PPUSH
8961: PPUSH
8962: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8963: LD_ADDR_VAR 0 4
8967: PUSH
8968: LD_INT 209
8970: PUSH
8971: LD_INT 149
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PUSH
8978: LD_INT 219
8980: PUSH
8981: LD_INT 154
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: PUSH
8988: LD_INT 223
8990: PUSH
8991: LD_INT 149
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: PUSH
8998: LD_INT 232
9000: PUSH
9001: LD_INT 155
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: ST_TO_ADDR
// if not behemothBuilders then
9014: LD_EXP 61
9018: NOT
9019: IFFALSE 9023
// exit ;
9021: GO 9127
// j := 1 ;
9023: LD_ADDR_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ST_TO_ADDR
// for i in behemothBuilders do
9031: LD_ADDR_VAR 0 2
9035: PUSH
9036: LD_EXP 61
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9125
// begin if IsInUnit ( i ) then
9044: LD_VAR 0 2
9048: PPUSH
9049: CALL_OW 310
9053: IFFALSE 9064
// ComExitBuilding ( i ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9064: LD_VAR 0 2
9068: PPUSH
9069: LD_INT 37
9071: PPUSH
9072: LD_VAR 0 4
9076: PUSH
9077: LD_VAR 0 3
9081: ARRAY
9082: PUSH
9083: LD_INT 1
9085: ARRAY
9086: PPUSH
9087: LD_VAR 0 4
9091: PUSH
9092: LD_VAR 0 3
9096: ARRAY
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_INT 0
9104: PPUSH
9105: CALL_OW 230
// j := j + 1 ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_VAR 0 3
9118: PUSH
9119: LD_INT 1
9121: PLUS
9122: ST_TO_ADDR
// end ;
9123: GO 9041
9125: POP
9126: POP
// end ;
9127: LD_VAR 0 1
9131: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9132: LD_INT 3
9134: PPUSH
9135: CALL 86602 0 1
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 30
9152: PUSH
9153: LD_INT 37
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: NOT
9169: AND
9170: IFFALSE 9356
9172: GO 9174
9174: DISABLE
9175: LD_INT 0
9177: PPUSH
9178: PPUSH
// begin enable ;
9179: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9180: LD_ADDR_VAR 0 2
9184: PUSH
9185: LD_INT 3
9187: PPUSH
9188: CALL 86602 0 1
9192: ST_TO_ADDR
// for i in tmp do
9193: LD_ADDR_VAR 0 1
9197: PUSH
9198: LD_VAR 0 2
9202: PUSH
9203: FOR_IN
9204: IFFALSE 9354
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_INT 7
9213: PPUSH
9214: CALL_OW 308
9218: PUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: CALL_OW 110
9228: PUSH
9229: LD_INT 2
9231: EQUAL
9232: NOT
9233: AND
9234: IFFALSE 9248
// SetTag ( i , 2 ) ;
9236: LD_VAR 0 1
9240: PPUSH
9241: LD_INT 2
9243: PPUSH
9244: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9248: LD_INT 81
9250: PUSH
9251: LD_INT 3
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: LD_INT 91
9260: PUSH
9261: LD_VAR 0 1
9265: PUSH
9266: LD_INT 12
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 69
9282: NOT
9283: PUSH
9284: LD_VAR 0 1
9288: PPUSH
9289: CALL_OW 110
9293: PUSH
9294: LD_INT 2
9296: EQUAL
9297: NOT
9298: AND
9299: IFFALSE 9318
// ComAgressiveMove ( i , 64 , 93 ) else
9301: LD_VAR 0 1
9305: PPUSH
9306: LD_INT 64
9308: PPUSH
9309: LD_INT 93
9311: PPUSH
9312: CALL_OW 114
9316: GO 9352
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_INT 81
9325: PUSH
9326: LD_INT 3
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: PPUSH
9333: CALL_OW 69
9337: PPUSH
9338: LD_VAR 0 1
9342: PPUSH
9343: CALL_OW 74
9347: PPUSH
9348: CALL_OW 115
// end ;
9352: GO 9203
9354: POP
9355: POP
// end ;
9356: PPOPN 2
9358: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9359: LD_EXP 2
9363: NOT
9364: PUSH
9365: LD_INT 2
9367: PPUSH
9368: LD_INT 1
9370: PPUSH
9371: CALL 45745 0 2
9375: NOT
9376: AND
9377: IFFALSE 10297
9379: GO 9381
9381: DISABLE
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// begin enable ;
9388: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 30
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: NOT
9418: IFFALSE 9422
// exit ;
9420: GO 10297
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9422: LD_ADDR_VAR 0 4
9426: PUSH
9427: LD_INT 22
9429: PUSH
9430: LD_INT 3
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PUSH
9437: LD_INT 30
9439: PUSH
9440: LD_INT 34
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: ST_TO_ADDR
// if Prob ( 40 ) then
9456: LD_INT 40
9458: PPUSH
9459: CALL_OW 13
9463: IFFALSE 9590
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9465: LD_INT 2
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: LD_INT 49
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 22
9488: PUSH
9489: LD_INT 3
9491: PUSH
9492: LD_INT 3
9494: PUSH
9495: LD_INT 49
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: PUSH
9504: LD_INT 22
9506: PUSH
9507: LD_INT 3
9509: PUSH
9510: LD_INT 3
9512: PUSH
9513: LD_INT 49
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: PUSH
9522: LD_INT 24
9524: PUSH
9525: LD_INT 3
9527: PUSH
9528: LD_INT 3
9530: PUSH
9531: LD_INT 46
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 24
9542: PUSH
9543: LD_INT 3
9545: PUSH
9546: LD_INT 3
9548: PUSH
9549: LD_INT 46
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 24
9560: PUSH
9561: LD_INT 3
9563: PUSH
9564: LD_INT 3
9566: PUSH
9567: LD_INT 46
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: PPUSH
9584: CALL 44327 0 2
// end else
9588: GO 9713
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9590: LD_INT 2
9592: PPUSH
9593: LD_INT 24
9595: PUSH
9596: LD_INT 3
9598: PUSH
9599: LD_INT 3
9601: PUSH
9602: LD_INT 47
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: PUSH
9611: LD_INT 24
9613: PUSH
9614: LD_INT 3
9616: PUSH
9617: LD_INT 3
9619: PUSH
9620: LD_INT 47
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_INT 24
9631: PUSH
9632: LD_INT 3
9634: PUSH
9635: LD_INT 3
9637: PUSH
9638: LD_INT 47
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 24
9649: PUSH
9650: LD_INT 3
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: LD_INT 46
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 24
9667: PUSH
9668: LD_INT 3
9670: PUSH
9671: LD_INT 3
9673: PUSH
9674: LD_INT 46
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: PUSH
9683: LD_INT 24
9685: PUSH
9686: LD_INT 3
9688: PUSH
9689: LD_INT 3
9691: PUSH
9692: LD_INT 46
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: PPUSH
9709: CALL 44327 0 2
// end ; if Difficulty > 1 then
9713: LD_OWVAR 67
9717: PUSH
9718: LD_INT 1
9720: GREATER
9721: IFFALSE 9751
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9723: LD_INT 2
9725: PPUSH
9726: LD_INT 24
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 47
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: PPUSH
9747: CALL 44327 0 2
// repeat wait ( 0 0$1 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9758: LD_INT 2
9760: PPUSH
9761: LD_INT 1
9763: PPUSH
9764: CALL 45745 0 2
9768: PUSH
9769: LD_INT 6
9771: PUSH
9772: LD_INT 7
9774: PUSH
9775: LD_INT 7
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_OWVAR 67
9787: ARRAY
9788: GREATEREQUAL
9789: IFFALSE 9751
// wait ( 0 0$30 ) ;
9791: LD_INT 1050
9793: PPUSH
9794: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 2
9805: PPUSH
9806: LD_INT 1
9808: PPUSH
9809: CALL 45745 0 2
9813: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9814: LD_ADDR_EXP 108
9818: PUSH
9819: LD_EXP 108
9823: PPUSH
9824: LD_INT 2
9826: PPUSH
9827: LD_EXP 108
9831: PUSH
9832: LD_INT 2
9834: ARRAY
9835: PUSH
9836: LD_VAR 0 2
9840: DIFF
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9847: LD_ADDR_VAR 0 3
9851: PUSH
9852: LD_INT 0
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL_OW 12
9862: ST_TO_ADDR
// if target then
9863: LD_VAR 0 3
9867: IFFALSE 9995
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9869: LD_ADDR_VAR 0 2
9873: PUSH
9874: LD_VAR 0 2
9878: PPUSH
9879: LD_INT 24
9881: PUSH
9882: LD_INT 250
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: CALL_OW 72
9893: ST_TO_ADDR
// for i in tmp do
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_VAR 0 2
9903: PUSH
9904: FOR_IN
9905: IFFALSE 9945
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 139
9914: PPUSH
9915: LD_INT 89
9917: PPUSH
9918: CALL_OW 297
9922: PUSH
9923: LD_INT 9
9925: GREATER
9926: IFFALSE 9943
// ComMoveXY ( i , 139 , 89 ) ;
9928: LD_VAR 0 1
9932: PPUSH
9933: LD_INT 139
9935: PPUSH
9936: LD_INT 89
9938: PPUSH
9939: CALL_OW 111
9943: GO 9904
9945: POP
9946: POP
// wait ( 0 0$1 ) ;
9947: LD_INT 35
9949: PPUSH
9950: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9954: LD_VAR 0 2
9958: PPUSH
9959: LD_INT 92
9961: PUSH
9962: LD_INT 139
9964: PUSH
9965: LD_INT 89
9967: PUSH
9968: LD_INT 9
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: PPUSH
9977: CALL_OW 72
9981: PUSH
9982: LD_VAR 0 2
9986: PUSH
9987: LD_INT 1
9989: MINUS
9990: GREATEREQUAL
9991: IFFALSE 9869
// end else
9993: GO 10137
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9995: LD_VAR 0 2
9999: PPUSH
10000: LD_VAR 0 4
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PPUSH
10009: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10013: LD_ADDR_VAR 0 2
10017: PUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: LD_INT 24
10025: PUSH
10026: LD_INT 250
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PPUSH
10033: CALL_OW 72
10037: ST_TO_ADDR
// for i in tmp do
10038: LD_ADDR_VAR 0 1
10042: PUSH
10043: LD_VAR 0 2
10047: PUSH
10048: FOR_IN
10049: IFFALSE 10089
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10051: LD_VAR 0 1
10055: PPUSH
10056: LD_INT 124
10058: PPUSH
10059: LD_INT 139
10061: PPUSH
10062: CALL_OW 297
10066: PUSH
10067: LD_INT 9
10069: GREATER
10070: IFFALSE 10087
// ComMoveXY ( i , 124 , 139 ) ;
10072: LD_VAR 0 1
10076: PPUSH
10077: LD_INT 124
10079: PPUSH
10080: LD_INT 139
10082: PPUSH
10083: CALL_OW 111
10087: GO 10048
10089: POP
10090: POP
// wait ( 0 0$1 ) ;
10091: LD_INT 35
10093: PPUSH
10094: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10098: LD_VAR 0 2
10102: PPUSH
10103: LD_INT 92
10105: PUSH
10106: LD_INT 124
10108: PUSH
10109: LD_INT 139
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 72
10125: PUSH
10126: LD_VAR 0 2
10130: PUSH
10131: LD_INT 1
10133: MINUS
10134: GREATEREQUAL
10135: IFFALSE 10013
// end ; repeat wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// for i in tmp do
10144: LD_ADDR_VAR 0 1
10148: PUSH
10149: LD_VAR 0 2
10153: PUSH
10154: FOR_IN
10155: IFFALSE 10288
// begin if GetLives ( i ) > 251 then
10157: LD_VAR 0 1
10161: PPUSH
10162: CALL_OW 256
10166: PUSH
10167: LD_INT 251
10169: GREATER
10170: IFFALSE 10259
// begin if GetWeapon ( i ) = ru_time_lapser then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 264
10181: PUSH
10182: LD_INT 49
10184: EQUAL
10185: IFFALSE 10223
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10187: LD_VAR 0 1
10191: PPUSH
10192: LD_INT 81
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PPUSH
10202: CALL_OW 69
10206: PPUSH
10207: LD_VAR 0 1
10211: PPUSH
10212: CALL_OW 74
10216: PPUSH
10217: CALL_OW 112
10221: GO 10257
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 81
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PPUSH
10238: CALL_OW 69
10242: PPUSH
10243: LD_VAR 0 1
10247: PPUSH
10248: CALL_OW 74
10252: PPUSH
10253: CALL_OW 115
// end else
10257: GO 10286
// if IsDead ( i ) then
10259: LD_VAR 0 1
10263: PPUSH
10264: CALL_OW 301
10268: IFFALSE 10286
// tmp := tmp diff i ;
10270: LD_ADDR_VAR 0 2
10274: PUSH
10275: LD_VAR 0 2
10279: PUSH
10280: LD_VAR 0 1
10284: DIFF
10285: ST_TO_ADDR
// end ;
10286: GO 10154
10288: POP
10289: POP
// until not tmp ;
10290: LD_VAR 0 2
10294: NOT
10295: IFFALSE 10137
// end ;
10297: PPOPN 4
10299: END
// every 30 30$00 trigger not russianDestroyed do
10300: LD_EXP 2
10304: NOT
10305: IFFALSE 10370
10307: GO 10309
10309: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10310: LD_INT 105000
10312: PUSH
10313: LD_INT 84000
10315: PUSH
10316: LD_INT 63000
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: PUSH
10324: LD_OWVAR 67
10328: ARRAY
10329: PPUSH
10330: CALL_OW 67
// if russianDestroyed then
10334: LD_EXP 2
10338: IFFALSE 10342
// exit ;
10340: GO 10370
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 23
10347: PUSH
10348: LD_INT 3
10350: PUSH
10351: LD_INT 1
10353: PUSH
10354: LD_INT 48
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PUSH
10363: EMPTY
10364: LIST
10365: PPUSH
10366: CALL 44327 0 2
// end ; end_of_file
10370: END
// export function CustomEvent ( event ) ; begin
10371: LD_INT 0
10373: PPUSH
// end ;
10374: LD_VAR 0 2
10378: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10379: LD_VAR 0 2
10383: PPUSH
10384: LD_VAR 0 3
10388: PPUSH
10389: LD_INT 15
10391: PPUSH
10392: CALL_OW 309
10396: IFFALSE 10405
// YouLost ( MothContaminate ) ;
10398: LD_STRING MothContaminate
10400: PPUSH
10401: CALL_OW 104
// end ;
10405: PPOPN 3
10407: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10408: LD_VAR 0 2
10412: PPUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 15
10420: PPUSH
10421: CALL_OW 309
10425: IFFALSE 10441
// begin wait ( 0 0$6 ) ;
10427: LD_INT 210
10429: PPUSH
10430: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10434: LD_STRING MothContaminateBomb
10436: PPUSH
10437: CALL_OW 104
// end ; end ;
10441: PPOPN 3
10443: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10444: LD_VAR 0 1
10448: PUSH
10449: LD_EXP 17
10453: EQUAL
10454: IFFALSE 10465
// begin YouLost ( JMM ) ;
10456: LD_STRING JMM
10458: PPUSH
10459: CALL_OW 104
// exit ;
10463: GO 10564
// end ; if un = Powell then
10465: LD_VAR 0 1
10469: PUSH
10470: LD_EXP 52
10474: EQUAL
10475: IFFALSE 10485
// americanDestroyed := true ;
10477: LD_ADDR_EXP 4
10481: PUSH
10482: LD_INT 1
10484: ST_TO_ADDR
// if un = Platonov then
10485: LD_VAR 0 1
10489: PUSH
10490: LD_EXP 56
10494: EQUAL
10495: IFFALSE 10505
// russianDestroyed := true ;
10497: LD_ADDR_EXP 2
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10505: LD_VAR 0 1
10509: PUSH
10510: LD_INT 22
10512: PUSH
10513: LD_INT 7
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 21
10522: PUSH
10523: LD_INT 2
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IN
10539: IFFALSE 10555
// vehicleLostCounter := vehicleLostCounter + 1 ;
10541: LD_ADDR_EXP 15
10545: PUSH
10546: LD_EXP 15
10550: PUSH
10551: LD_INT 1
10553: PLUS
10554: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL 47719 0 1
// end ;
10564: PPOPN 1
10566: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10567: LD_VAR 0 1
10571: PPUSH
10572: LD_VAR 0 2
10576: PPUSH
10577: CALL 50053 0 2
// end ;
10581: PPOPN 2
10583: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10584: LD_VAR 0 1
10588: PPUSH
10589: CALL 49121 0 1
// end ;
10593: PPOPN 1
10595: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10596: LD_VAR 0 1
10600: PUSH
10601: LD_INT 22
10603: PUSH
10604: LD_INT 8
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 30
10613: PUSH
10614: LD_INT 2
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 23
10623: PUSH
10624: LD_INT 3
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10668
// begin ComUpgrade ( building ) ;
10643: LD_VAR 0 1
10647: PPUSH
10648: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10652: LD_EXP 55
10656: PPUSH
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 58468 0 2
// exit ;
10666: GO 10677
// end ; MCE_BuildingComplete ( building ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 49362 0 1
// end ;
10677: PPOPN 1
10679: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10680: LD_VAR 0 1
10684: PPUSH
10685: LD_VAR 0 2
10689: PPUSH
10690: CALL 47415 0 2
// end ;
10694: PPOPN 2
10696: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_VAR 0 2
10706: PPUSH
10707: LD_VAR 0 3
10711: PPUSH
10712: LD_VAR 0 4
10716: PPUSH
10717: LD_VAR 0 5
10721: PPUSH
10722: CALL 47035 0 5
// end ;
10726: PPOPN 5
10728: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10729: LD_VAR 0 1
10733: PPUSH
10734: LD_VAR 0 2
10738: PPUSH
10739: CALL 46631 0 2
// end ;
10743: PPOPN 2
10745: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10746: LD_VAR 0 1
10750: PPUSH
10751: LD_VAR 0 2
10755: PPUSH
10756: LD_VAR 0 3
10760: PPUSH
10761: LD_VAR 0 4
10765: PPUSH
10766: CALL 46469 0 4
// end ;
10770: PPOPN 4
10772: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10773: LD_VAR 0 1
10777: PPUSH
10778: LD_VAR 0 2
10782: PPUSH
10783: LD_VAR 0 3
10787: PPUSH
10788: CALL 46244 0 3
// end ;
10792: PPOPN 3
10794: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10795: LD_VAR 0 1
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: CALL 46129 0 2
// end ;
10809: PPOPN 2
10811: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_VAR 0 2
10821: PPUSH
10822: CALL 50314 0 2
// end ;
10826: PPOPN 2
10828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10829: LD_VAR 0 1
10833: PPUSH
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_VAR 0 3
10843: PPUSH
10844: LD_VAR 0 4
10848: PPUSH
10849: CALL 50530 0 4
// end ;
10853: PPOPN 4
10855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: LD_VAR 0 2
10865: PPUSH
10866: CALL 45938 0 2
// end ;
10870: PPOPN 2
10872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10873: LD_VAR 0 1
10877: PPUSH
10878: CALL 99796 0 1
// end ; end_of_file
10882: PPOPN 1
10884: END
// export function Action ; begin
10885: LD_INT 0
10887: PPUSH
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10892: LD_INT 206
10894: PPUSH
10895: LD_INT 11
10897: PPUSH
10898: CALL_OW 86
// wait ( 0 0$1 ) ;
10902: LD_INT 35
10904: PPUSH
10905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10909: LD_EXP 17
10913: PPUSH
10914: LD_STRING DStart-JMM-JMM-1
10916: PPUSH
10917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10921: LD_EXP 49
10925: PPUSH
10926: LD_STRING DStart-JMM-Bur-1
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10933: LD_EXP 17
10937: PPUSH
10938: LD_STRING DStart-JMM-JMM-2
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10945: LD_EXP 49
10949: PPUSH
10950: LD_STRING DStart-JMM-Bur-2
10952: PPUSH
10953: CALL_OW 88
// InGameOff ;
10957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10961: LD_STRING MStart
10963: PPUSH
10964: CALL_OW 337
// SaveForQuickRestart ;
10968: CALL_OW 22
// end ;
10972: LD_VAR 0 1
10976: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10977: LD_INT 7
10979: PPUSH
10980: LD_INT 255
10982: PPUSH
10983: LD_INT 219
10985: PPUSH
10986: CALL_OW 293
10990: IFFALSE 11599
10992: GO 10994
10994: DISABLE
10995: LD_INT 0
10997: PPUSH
// begin wait ( 0 0$3 ) ;
10998: LD_INT 105
11000: PPUSH
11001: CALL_OW 67
// alienSpotted := true ;
11005: LD_ADDR_EXP 10
11009: PUSH
11010: LD_INT 1
11012: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11013: LD_ADDR_VAR 0 1
11017: PUSH
11018: LD_INT 22
11020: PUSH
11021: LD_INT 7
11023: PUSH
11024: EMPTY
11025: LIST
11026: LIST
11027: PUSH
11028: LD_INT 23
11030: PUSH
11031: LD_INT 3
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PUSH
11038: LD_INT 21
11040: PUSH
11041: LD_INT 1
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PUSH
11048: LD_INT 26
11050: PUSH
11051: LD_INT 1
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: LIST
11062: LIST
11063: PPUSH
11064: CALL_OW 69
11068: PUSH
11069: LD_EXP 49
11073: PUSH
11074: LD_EXP 37
11078: PUSH
11079: LD_EXP 39
11083: PUSH
11084: LD_EXP 40
11088: PUSH
11089: LD_EXP 47
11093: PUSH
11094: LD_EXP 46
11098: PUSH
11099: LD_EXP 41
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: DIFF
11113: ST_TO_ADDR
// DialogueOn ;
11114: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11118: LD_INT 255
11120: PPUSH
11121: LD_INT 219
11123: PPUSH
11124: LD_INT 7
11126: PPUSH
11127: LD_INT 20
11129: NEG
11130: PPUSH
11131: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11135: LD_INT 255
11137: PPUSH
11138: LD_INT 219
11140: PPUSH
11141: CALL_OW 86
// if speaker then
11145: LD_VAR 0 1
11149: IFFALSE 11167
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11151: LD_VAR 0 1
11155: PUSH
11156: LD_INT 1
11158: ARRAY
11159: PPUSH
11160: LD_STRING DAlienBase-RSol1-1
11162: PPUSH
11163: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11167: LD_EXP 17
11171: PPUSH
11172: LD_STRING DAlienBase-JMM-1
11174: PPUSH
11175: CALL_OW 88
// if IsOk ( Burlak ) then
11179: LD_EXP 49
11183: PPUSH
11184: CALL_OW 302
11188: IFFALSE 11209
// begin dwait ( 0 0$1 ) ;
11190: LD_INT 35
11192: PPUSH
11193: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11197: LD_EXP 49
11201: PPUSH
11202: LD_STRING DAlienBase-Bur-1
11204: PPUSH
11205: CALL_OW 88
// end ; if IsOk ( Roth ) then
11209: LD_EXP 18
11213: PPUSH
11214: CALL_OW 302
11218: IFFALSE 11232
// Say ( Roth , DAlienBase-Roth-1 ) ;
11220: LD_EXP 18
11224: PPUSH
11225: LD_STRING DAlienBase-Roth-1
11227: PPUSH
11228: CALL_OW 88
// if IsOk ( Gossudarov ) then
11232: LD_EXP 35
11236: PPUSH
11237: CALL_OW 302
11241: IFFALSE 11257
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11243: LD_EXP 35
11247: PPUSH
11248: LD_STRING DAlienBase-Gos-1
11250: PPUSH
11251: CALL_OW 88
11255: GO 11374
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11257: LD_ADDR_VAR 0 1
11261: PUSH
11262: LD_INT 22
11264: PUSH
11265: LD_INT 7
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: PUSH
11272: LD_INT 25
11274: PUSH
11275: LD_INT 4
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: PUSH
11282: LD_INT 21
11284: PUSH
11285: LD_INT 1
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PUSH
11292: LD_INT 26
11294: PUSH
11295: LD_INT 1
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: PPUSH
11308: CALL_OW 69
11312: PUSH
11313: LD_EXP 18
11317: PUSH
11318: LD_EXP 17
11322: PUSH
11323: LD_EXP 49
11327: PUSH
11328: LD_EXP 37
11332: PUSH
11333: LD_EXP 47
11337: PUSH
11338: LD_EXP 46
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: LIST
11347: LIST
11348: LIST
11349: LIST
11350: DIFF
11351: ST_TO_ADDR
// if speaker then
11352: LD_VAR 0 1
11356: IFFALSE 11374
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11358: LD_VAR 0 1
11362: PUSH
11363: LD_INT 1
11365: ARRAY
11366: PPUSH
11367: LD_STRING DAlienBase-Sci1-1
11369: PPUSH
11370: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11374: LD_INT 255
11376: PPUSH
11377: LD_INT 219
11379: PPUSH
11380: LD_INT 7
11382: PPUSH
11383: CALL_OW 331
// DialogueOff ;
11387: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// until IsSelected ( alien ) ;
11398: LD_INT 1
11400: PPUSH
11401: CALL_OW 306
11405: IFFALSE 11391
// if not artifactIResearched or not artifactIIResearched then
11407: LD_EXP 12
11411: NOT
11412: PUSH
11413: LD_EXP 13
11417: NOT
11418: OR
11419: IFFALSE 11599
// begin if IsOk ( Roth ) then
11421: LD_EXP 18
11425: PPUSH
11426: CALL_OW 302
11430: IFFALSE 11446
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11432: LD_EXP 18
11436: PPUSH
11437: LD_STRING DAlieBaseNotReady-Roth-1
11439: PPUSH
11440: CALL_OW 88
11444: GO 11599
// if IsOk ( Gossudarov ) then
11446: LD_EXP 35
11450: PPUSH
11451: CALL_OW 302
11455: IFFALSE 11471
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11457: LD_EXP 35
11461: PPUSH
11462: LD_STRING DAlieBaseNotReady-Gos-1
11464: PPUSH
11465: CALL_OW 88
11469: GO 11599
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11471: LD_ADDR_VAR 0 1
11475: PUSH
11476: LD_INT 22
11478: PUSH
11479: LD_INT 7
11481: PUSH
11482: EMPTY
11483: LIST
11484: LIST
11485: PUSH
11486: LD_INT 23
11488: PUSH
11489: LD_INT 3
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: PUSH
11496: LD_INT 25
11498: PUSH
11499: LD_INT 4
11501: PUSH
11502: EMPTY
11503: LIST
11504: LIST
11505: PUSH
11506: LD_INT 21
11508: PUSH
11509: LD_INT 1
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: PUSH
11516: LD_INT 26
11518: PUSH
11519: LD_INT 1
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: PUSH
11526: EMPTY
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: PPUSH
11533: CALL_OW 69
11537: PUSH
11538: LD_EXP 18
11542: PUSH
11543: LD_EXP 17
11547: PUSH
11548: LD_EXP 49
11552: PUSH
11553: LD_EXP 37
11557: PUSH
11558: LD_EXP 47
11562: PUSH
11563: LD_EXP 46
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: LIST
11572: LIST
11573: LIST
11574: LIST
11575: DIFF
11576: ST_TO_ADDR
// if speaker then
11577: LD_VAR 0 1
11581: IFFALSE 11599
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11583: LD_VAR 0 1
11587: PUSH
11588: LD_INT 1
11590: ARRAY
11591: PPUSH
11592: LD_STRING DAlieBaseNotReady-RSci1-1
11594: PPUSH
11595: CALL_OW 88
// end ; end ; end ;
11599: PPOPN 1
11601: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11602: LD_INT 24
11604: PPUSH
11605: LD_INT 7
11607: PPUSH
11608: CALL_OW 321
11612: PUSH
11613: LD_INT 2
11615: EQUAL
11616: IFFALSE 12307
11618: GO 11620
11620: DISABLE
11621: LD_INT 0
11623: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11624: LD_ADDR_VAR 0 1
11628: PUSH
11629: LD_INT 22
11631: PUSH
11632: LD_INT 7
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: PUSH
11639: LD_INT 23
11641: PUSH
11642: LD_INT 3
11644: PUSH
11645: EMPTY
11646: LIST
11647: LIST
11648: PUSH
11649: LD_INT 25
11651: PUSH
11652: LD_INT 4
11654: PUSH
11655: EMPTY
11656: LIST
11657: LIST
11658: PUSH
11659: LD_INT 21
11661: PUSH
11662: LD_INT 1
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: PUSH
11669: LD_INT 26
11671: PUSH
11672: LD_INT 1
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: PPUSH
11686: CALL_OW 69
11690: PUSH
11691: LD_EXP 18
11695: PUSH
11696: LD_EXP 17
11700: PUSH
11701: LD_EXP 49
11705: PUSH
11706: LD_EXP 37
11710: PUSH
11711: LD_EXP 47
11715: PUSH
11716: LD_EXP 46
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: DIFF
11729: ST_TO_ADDR
// if not speaker then
11730: LD_VAR 0 1
11734: NOT
11735: IFFALSE 11739
// exit ;
11737: GO 12307
// DialogueOn ;
11739: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11743: LD_VAR 0 1
11747: PUSH
11748: LD_INT 1
11750: ARRAY
11751: PPUSH
11752: LD_STRING DArtefTechnology-RSci1-1
11754: PPUSH
11755: CALL_OW 88
// if IsOk ( Burlak ) then
11759: LD_EXP 49
11763: PPUSH
11764: CALL_OW 302
11768: IFFALSE 11782
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11770: LD_EXP 49
11774: PPUSH
11775: LD_STRING DArtefTechnology-Bur-1
11777: PPUSH
11778: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11782: LD_VAR 0 1
11786: PUSH
11787: LD_INT 1
11789: ARRAY
11790: PPUSH
11791: LD_STRING DArtefTechnology-RSci1-2
11793: PPUSH
11794: CALL_OW 88
// if Denis then
11798: LD_EXP 23
11802: IFFALSE 11819
// speaker := [ Denis ] else
11804: LD_ADDR_VAR 0 1
11808: PUSH
11809: LD_EXP 23
11813: PUSH
11814: EMPTY
11815: LIST
11816: ST_TO_ADDR
11817: GO 11925
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11819: LD_ADDR_VAR 0 1
11823: PUSH
11824: LD_INT 22
11826: PUSH
11827: LD_INT 7
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: LD_INT 23
11836: PUSH
11837: LD_INT 1
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: PUSH
11844: LD_INT 25
11846: PUSH
11847: LD_INT 4
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: LD_INT 21
11856: PUSH
11857: LD_INT 1
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PUSH
11864: LD_INT 26
11866: PUSH
11867: LD_INT 1
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: PPUSH
11881: CALL_OW 69
11885: PUSH
11886: LD_EXP 18
11890: PUSH
11891: LD_EXP 17
11895: PUSH
11896: LD_EXP 49
11900: PUSH
11901: LD_EXP 37
11905: PUSH
11906: LD_EXP 47
11910: PUSH
11911: LD_EXP 46
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: LIST
11920: LIST
11921: LIST
11922: LIST
11923: DIFF
11924: ST_TO_ADDR
// if speaker then
11925: LD_VAR 0 1
11929: IFFALSE 11947
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11931: LD_VAR 0 1
11935: PUSH
11936: LD_INT 1
11938: ARRAY
11939: PPUSH
11940: LD_STRING DArtefTechnology-Sci1-2
11942: PPUSH
11943: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11947: LD_ADDR_VAR 0 1
11951: PUSH
11952: LD_INT 22
11954: PUSH
11955: LD_INT 7
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: PUSH
11962: LD_INT 23
11964: PUSH
11965: LD_INT 3
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 25
11974: PUSH
11975: LD_INT 4
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_INT 21
11984: PUSH
11985: LD_INT 1
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PUSH
11992: LD_INT 26
11994: PUSH
11995: LD_INT 1
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: PPUSH
12009: CALL_OW 69
12013: PUSH
12014: LD_EXP 18
12018: PUSH
12019: LD_EXP 17
12023: PUSH
12024: LD_EXP 49
12028: PUSH
12029: LD_EXP 37
12033: PUSH
12034: LD_EXP 47
12038: PUSH
12039: LD_EXP 46
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: LIST
12048: LIST
12049: LIST
12050: LIST
12051: DIFF
12052: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12053: LD_VAR 0 1
12057: PUSH
12058: LD_EXP 9
12062: PUSH
12063: LD_EXP 5
12067: OR
12068: AND
12069: IFFALSE 12303
// begin if arabianDestroyed and IsOk ( Burlak ) then
12071: LD_EXP 5
12075: PUSH
12076: LD_EXP 49
12080: PPUSH
12081: CALL_OW 302
12085: AND
12086: IFFALSE 12102
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12088: LD_EXP 49
12092: PPUSH
12093: LD_STRING DArtefTechnology-Bur-2
12095: PPUSH
12096: CALL_OW 88
12100: GO 12114
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12102: LD_EXP 17
12106: PPUSH
12107: LD_STRING DArtefTechnology-JMM-2
12109: PPUSH
12110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12114: LD_VAR 0 1
12118: PUSH
12119: LD_INT 1
12121: ARRAY
12122: PPUSH
12123: LD_STRING DArtefTechnology-RSci1-3
12125: PPUSH
12126: CALL_OW 88
// if Denis then
12130: LD_EXP 23
12134: IFFALSE 12151
// speaker := [ Denis ] else
12136: LD_ADDR_VAR 0 1
12140: PUSH
12141: LD_EXP 23
12145: PUSH
12146: EMPTY
12147: LIST
12148: ST_TO_ADDR
12149: GO 12257
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12151: LD_ADDR_VAR 0 1
12155: PUSH
12156: LD_INT 22
12158: PUSH
12159: LD_INT 7
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PUSH
12166: LD_INT 23
12168: PUSH
12169: LD_INT 1
12171: PUSH
12172: EMPTY
12173: LIST
12174: LIST
12175: PUSH
12176: LD_INT 25
12178: PUSH
12179: LD_INT 4
12181: PUSH
12182: EMPTY
12183: LIST
12184: LIST
12185: PUSH
12186: LD_INT 21
12188: PUSH
12189: LD_INT 1
12191: PUSH
12192: EMPTY
12193: LIST
12194: LIST
12195: PUSH
12196: LD_INT 26
12198: PUSH
12199: LD_INT 1
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: LIST
12210: LIST
12211: LIST
12212: PPUSH
12213: CALL_OW 69
12217: PUSH
12218: LD_EXP 18
12222: PUSH
12223: LD_EXP 17
12227: PUSH
12228: LD_EXP 49
12232: PUSH
12233: LD_EXP 37
12237: PUSH
12238: LD_EXP 47
12242: PUSH
12243: LD_EXP 46
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: DIFF
12256: ST_TO_ADDR
// if speaker then
12257: LD_VAR 0 1
12261: IFFALSE 12303
// if alienSpotted then
12263: LD_EXP 10
12267: IFFALSE 12287
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12269: LD_VAR 0 1
12273: PUSH
12274: LD_INT 1
12276: ARRAY
12277: PPUSH
12278: LD_STRING DArtefTechnology-Sci1-3
12280: PPUSH
12281: CALL_OW 88
12285: GO 12303
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12287: LD_VAR 0 1
12291: PUSH
12292: LD_INT 1
12294: ARRAY
12295: PPUSH
12296: LD_STRING DArtefTechnology-Sci1-3a
12298: PPUSH
12299: CALL_OW 88
// end ; DialogueOff ;
12303: CALL_OW 7
// end ;
12307: PPOPN 1
12309: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12310: LD_EXP 12
12314: IFFALSE 12509
12316: GO 12318
12318: DISABLE
12319: LD_INT 0
12321: PPUSH
// begin if Denis then
12322: LD_EXP 23
12326: IFFALSE 12343
// speaker := [ Denis ] else
12328: LD_ADDR_VAR 0 1
12332: PUSH
12333: LD_EXP 23
12337: PUSH
12338: EMPTY
12339: LIST
12340: ST_TO_ADDR
12341: GO 12449
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12343: LD_ADDR_VAR 0 1
12347: PUSH
12348: LD_INT 22
12350: PUSH
12351: LD_INT 7
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_INT 23
12360: PUSH
12361: LD_INT 1
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: LD_INT 25
12370: PUSH
12371: LD_INT 4
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PUSH
12378: LD_INT 21
12380: PUSH
12381: LD_INT 1
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: PUSH
12388: LD_INT 26
12390: PUSH
12391: LD_INT 1
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: PPUSH
12405: CALL_OW 69
12409: PUSH
12410: LD_EXP 18
12414: PUSH
12415: LD_EXP 17
12419: PUSH
12420: LD_EXP 49
12424: PUSH
12425: LD_EXP 37
12429: PUSH
12430: LD_EXP 47
12434: PUSH
12435: LD_EXP 46
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: DIFF
12448: ST_TO_ADDR
// if not speaker then
12449: LD_VAR 0 1
12453: NOT
12454: IFFALSE 12458
// exit ;
12456: GO 12509
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12458: LD_VAR 0 1
12462: PUSH
12463: LD_INT 1
12465: ARRAY
12466: PPUSH
12467: LD_STRING DArtefTechnologyAm-Sci1-1
12469: PPUSH
12470: CALL_OW 88
// if IsOk ( Burlak ) then
12474: LD_EXP 49
12478: PPUSH
12479: CALL_OW 302
12483: IFFALSE 12497
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12485: LD_EXP 49
12489: PPUSH
12490: LD_STRING DArtefTechnologyAm-Bur-1
12492: PPUSH
12493: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12497: LD_EXP 17
12501: PPUSH
12502: LD_STRING DArtefTechnologyAm-JMM-1
12504: PPUSH
12505: CALL_OW 88
// end ;
12509: PPOPN 1
12511: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12512: LD_EXP 13
12516: IFFALSE 12706
12518: GO 12520
12520: DISABLE
12521: LD_INT 0
12523: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12524: LD_ADDR_VAR 0 1
12528: PUSH
12529: LD_INT 22
12531: PUSH
12532: LD_INT 7
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 23
12541: PUSH
12542: LD_INT 3
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 4
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 21
12561: PUSH
12562: LD_INT 1
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 26
12571: PUSH
12572: LD_INT 1
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: PPUSH
12586: CALL_OW 69
12590: PUSH
12591: LD_EXP 18
12595: PUSH
12596: LD_EXP 17
12600: PUSH
12601: LD_EXP 49
12605: PUSH
12606: LD_EXP 37
12610: PUSH
12611: LD_EXP 47
12615: PUSH
12616: LD_EXP 46
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: LIST
12625: LIST
12626: LIST
12627: LIST
12628: DIFF
12629: ST_TO_ADDR
// if not speaker then
12630: LD_VAR 0 1
12634: NOT
12635: IFFALSE 12639
// exit ;
12637: GO 12706
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12639: LD_VAR 0 1
12643: PUSH
12644: LD_INT 1
12646: ARRAY
12647: PPUSH
12648: LD_STRING DArtefTechnologyRu-RSci1-1
12650: PPUSH
12651: CALL_OW 88
// if IsOk ( Burlak ) then
12655: LD_EXP 49
12659: PPUSH
12660: CALL_OW 302
12664: IFFALSE 12678
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12666: LD_EXP 49
12670: PPUSH
12671: LD_STRING DArtefTechnologyRu-Bur-1
12673: PPUSH
12674: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12678: LD_VAR 0 1
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_STRING DArtefTechnologyRu-RSci1-2
12689: PPUSH
12690: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12694: LD_EXP 17
12698: PPUSH
12699: LD_STRING DArtefTechnologyRu-JMM-1
12701: PPUSH
12702: CALL_OW 88
// end ;
12706: PPOPN 1
12708: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12709: LD_INT 24
12711: PPUSH
12712: LD_INT 7
12714: PPUSH
12715: CALL_OW 321
12719: PUSH
12720: LD_INT 2
12722: EQUAL
12723: PUSH
12724: LD_INT 1
12726: PPUSH
12727: CALL_OW 255
12731: PUSH
12732: LD_INT 7
12734: EQUAL
12735: AND
12736: IFFALSE 12896
12738: GO 12740
12740: DISABLE
12741: LD_INT 0
12743: PPUSH
// begin if Denis then
12744: LD_EXP 23
12748: IFFALSE 12765
// speaker := [ Denis ] else
12750: LD_ADDR_VAR 0 1
12754: PUSH
12755: LD_EXP 23
12759: PUSH
12760: EMPTY
12761: LIST
12762: ST_TO_ADDR
12763: GO 12871
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12765: LD_ADDR_VAR 0 1
12769: PUSH
12770: LD_INT 22
12772: PUSH
12773: LD_INT 7
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: LD_INT 23
12782: PUSH
12783: LD_INT 1
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 25
12792: PUSH
12793: LD_INT 4
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 21
12802: PUSH
12803: LD_INT 1
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 26
12812: PUSH
12813: LD_INT 1
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: PPUSH
12827: CALL_OW 69
12831: PUSH
12832: LD_EXP 18
12836: PUSH
12837: LD_EXP 17
12841: PUSH
12842: LD_EXP 49
12846: PUSH
12847: LD_EXP 37
12851: PUSH
12852: LD_EXP 47
12856: PUSH
12857: LD_EXP 46
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: DIFF
12870: ST_TO_ADDR
// if not speaker then
12871: LD_VAR 0 1
12875: NOT
12876: IFFALSE 12880
// exit ;
12878: GO 12896
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12880: LD_VAR 0 1
12884: PUSH
12885: LD_INT 1
12887: ARRAY
12888: PPUSH
12889: LD_STRING DArtefTechnologyArStart-Sci1-1
12891: PPUSH
12892: CALL_OW 88
// end ;
12896: PPOPN 1
12898: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12899: LD_EXP 14
12903: IFFALSE 13184
12905: GO 12907
12907: DISABLE
12908: LD_INT 0
12910: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12911: LD_ADDR_VAR 0 1
12915: PUSH
12916: LD_INT 22
12918: PUSH
12919: LD_INT 7
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 23
12928: PUSH
12929: LD_INT 3
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: PUSH
12936: LD_INT 25
12938: PUSH
12939: LD_INT 4
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 21
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: LD_INT 26
12958: PUSH
12959: LD_INT 1
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PPUSH
12973: CALL_OW 69
12977: PUSH
12978: LD_EXP 18
12982: PUSH
12983: LD_EXP 17
12987: PUSH
12988: LD_EXP 49
12992: PUSH
12993: LD_EXP 37
12997: PUSH
12998: LD_EXP 47
13002: PUSH
13003: LD_EXP 46
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: DIFF
13016: ST_TO_ADDR
// if not speaker then
13017: LD_VAR 0 1
13021: NOT
13022: IFFALSE 13026
// exit ;
13024: GO 13184
// DialogueOn ;
13026: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13030: LD_VAR 0 1
13034: PUSH
13035: LD_INT 1
13037: ARRAY
13038: PPUSH
13039: LD_STRING DArtefTechnologyAr-RSci1-1
13041: PPUSH
13042: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13046: LD_EXP 17
13050: PPUSH
13051: LD_STRING DArtefTechnologyAr-JMM-1
13053: PPUSH
13054: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13058: LD_VAR 0 1
13062: PUSH
13063: LD_INT 1
13065: ARRAY
13066: PPUSH
13067: LD_STRING DArtefTechnologyAr-RSci1-2
13069: PPUSH
13070: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13074: LD_EXP 17
13078: PPUSH
13079: LD_STRING DArtefTechnologyAr-JMM-2
13081: PPUSH
13082: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13086: LD_VAR 0 1
13090: PUSH
13091: LD_INT 1
13093: ARRAY
13094: PPUSH
13095: LD_STRING DArtefTechnologyAr-RSci1-3
13097: PPUSH
13098: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13102: LD_EXP 17
13106: PPUSH
13107: LD_STRING DArtefTechnologyAr-JMM-3
13109: PPUSH
13110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13114: LD_VAR 0 1
13118: PUSH
13119: LD_INT 1
13121: ARRAY
13122: PPUSH
13123: LD_STRING DArtefTechnologyAr-RSci1-4
13125: PPUSH
13126: CALL_OW 88
// if IsOk ( Burlak ) then
13130: LD_EXP 49
13134: PPUSH
13135: CALL_OW 302
13139: IFFALSE 13153
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13141: LD_EXP 49
13145: PPUSH
13146: LD_STRING DArtefTechnologyAr-Bur-4
13148: PPUSH
13149: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13153: LD_EXP 17
13157: PPUSH
13158: LD_STRING DArtefTechnologyAr-JMM-4
13160: PPUSH
13161: CALL_OW 88
// DialogueOff ;
13165: CALL_OW 7
// wait ( 0 0$45 ) ;
13169: LD_INT 1575
13171: PPUSH
13172: CALL_OW 67
// spawnOmar := true ;
13176: LD_ADDR_EXP 11
13180: PUSH
13181: LD_INT 1
13183: ST_TO_ADDR
// end ;
13184: PPOPN 1
13186: END
// every 0 0$1 trigger spawnOmar do
13187: LD_EXP 11
13191: IFFALSE 13571
13193: GO 13195
13195: DISABLE
// begin PrepareOmarAli ;
13196: CALL 6705 0 0
// if not HasTask ( Omar ) then
13200: LD_EXP 53
13204: PPUSH
13205: CALL_OW 314
13209: NOT
13210: IFFALSE 13227
// ComMoveXY ( Omar , 252 , 220 ) ;
13212: LD_EXP 53
13216: PPUSH
13217: LD_INT 252
13219: PPUSH
13220: LD_INT 220
13222: PPUSH
13223: CALL_OW 111
// if not Omar then
13227: LD_EXP 53
13231: NOT
13232: IFFALSE 13236
// exit ;
13234: GO 13571
// repeat wait ( 0 0$1 ) ;
13236: LD_INT 35
13238: PPUSH
13239: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13243: LD_EXP 53
13247: PPUSH
13248: CALL_OW 314
13252: NOT
13253: PUSH
13254: LD_EXP 53
13258: PPUSH
13259: LD_INT 252
13261: PPUSH
13262: LD_INT 220
13264: PPUSH
13265: CALL_OW 297
13269: PUSH
13270: LD_INT 6
13272: GREATER
13273: AND
13274: IFFALSE 13291
// ComMoveXY ( Omar , 252 , 220 ) ;
13276: LD_EXP 53
13280: PPUSH
13281: LD_INT 252
13283: PPUSH
13284: LD_INT 220
13286: PPUSH
13287: CALL_OW 111
// until See ( 7 , Omar ) ;
13291: LD_INT 7
13293: PPUSH
13294: LD_EXP 53
13298: PPUSH
13299: CALL_OW 292
13303: IFFALSE 13236
// CenterNowOnUnits ( Omar ) ;
13305: LD_EXP 53
13309: PPUSH
13310: CALL_OW 87
// DialogueOn ;
13314: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13318: LD_EXP 53
13322: PPUSH
13323: LD_STRING DOmar-Omar-1
13325: PPUSH
13326: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13330: LD_EXP 17
13334: PPUSH
13335: LD_STRING DOmar-JMM-1
13337: PPUSH
13338: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13342: LD_EXP 53
13346: PPUSH
13347: LD_STRING DOmar-Omar-2
13349: PPUSH
13350: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13354: LD_EXP 17
13358: PPUSH
13359: LD_STRING DOmar-JMM-2
13361: PPUSH
13362: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13366: LD_EXP 53
13370: PPUSH
13371: LD_STRING DOmar-Omar-3
13373: PPUSH
13374: CALL_OW 88
// if IsOk ( Burlak ) then
13378: LD_EXP 49
13382: PPUSH
13383: CALL_OW 302
13387: IFFALSE 13403
// Say ( Burlak , DOmar-Bur-3 ) else
13389: LD_EXP 49
13393: PPUSH
13394: LD_STRING DOmar-Bur-3
13396: PPUSH
13397: CALL_OW 88
13401: GO 13415
// Say ( JMM , DOmar-JMM-3 ) ;
13403: LD_EXP 17
13407: PPUSH
13408: LD_STRING DOmar-JMM-3
13410: PPUSH
13411: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13415: LD_EXP 53
13419: PPUSH
13420: LD_STRING DOmar-Omar-4
13422: PPUSH
13423: CALL_OW 88
// case Query ( QAccept ) of 1 :
13427: LD_STRING QAccept
13429: PPUSH
13430: CALL_OW 97
13434: PUSH
13435: LD_INT 1
13437: DOUBLE
13438: EQUAL
13439: IFTRUE 13443
13441: GO 13479
13443: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13444: LD_EXP 17
13448: PPUSH
13449: LD_STRING DQrAccept#1-JMM-1
13451: PPUSH
13452: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13456: LD_EXP 53
13460: PPUSH
13461: LD_INT 7
13463: PPUSH
13464: CALL_OW 235
// ComStop ( Omar ) ;
13468: LD_EXP 53
13472: PPUSH
13473: CALL_OW 141
// end ; 2 :
13477: GO 13528
13479: LD_INT 2
13481: DOUBLE
13482: EQUAL
13483: IFTRUE 13487
13485: GO 13527
13487: POP
// begin if IsOk ( Burlak ) then
13488: LD_EXP 49
13492: PPUSH
13493: CALL_OW 302
13497: IFFALSE 13513
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13499: LD_EXP 49
13503: PPUSH
13504: LD_STRING DQrAccept#2-Bur-1
13506: PPUSH
13507: CALL_OW 88
13511: GO 13525
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13513: LD_EXP 17
13517: PPUSH
13518: LD_STRING DQrAccept#2-JMM-1
13520: PPUSH
13521: CALL_OW 88
// end ; end ;
13525: GO 13528
13527: POP
// DialogueOff ;
13528: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13532: LD_EXP 53
13536: PPUSH
13537: CALL_OW 255
13541: PUSH
13542: LD_INT 7
13544: EQUAL
13545: IFFALSE 13556
// begin SetAchievement ( ACH_OMAR ) ;
13547: LD_STRING ACH_OMAR
13549: PPUSH
13550: CALL_OW 543
// exit ;
13554: GO 13571
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13556: LD_EXP 53
13560: PPUSH
13561: LD_INT 202
13563: PPUSH
13564: LD_INT 115
13566: PPUSH
13567: CALL_OW 111
// end ;
13571: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13572: LD_EXP 53
13576: PPUSH
13577: LD_INT 200
13579: PPUSH
13580: LD_INT 98
13582: PPUSH
13583: CALL_OW 297
13587: PUSH
13588: LD_INT 40
13590: LESS
13591: PUSH
13592: LD_EXP 2
13596: AND
13597: IFFALSE 13815
13599: GO 13601
13601: DISABLE
// begin SetSide ( Omar , 5 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 5
13609: PPUSH
13610: CALL_OW 235
// if IsInUnit ( Omar ) then
13614: LD_EXP 53
13618: PPUSH
13619: CALL_OW 310
13623: IFFALSE 13634
// ComExitVehicle ( Omar ) ;
13625: LD_EXP 53
13629: PPUSH
13630: CALL_OW 121
// if IsInUnit ( Omar ) then
13634: LD_EXP 53
13638: PPUSH
13639: CALL_OW 310
13643: IFFALSE 13654
// ComExitBuilding ( Omar ) ;
13645: LD_EXP 53
13649: PPUSH
13650: CALL_OW 122
// wait ( 0 0$1 ) ;
13654: LD_INT 35
13656: PPUSH
13657: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13661: LD_EXP 53
13665: PPUSH
13666: LD_INT 203
13668: PPUSH
13669: LD_INT 120
13671: PPUSH
13672: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13676: LD_INT 35
13678: PPUSH
13679: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13683: LD_EXP 53
13687: PPUSH
13688: CALL_OW 306
13692: PUSH
13693: LD_EXP 53
13697: PPUSH
13698: LD_INT 203
13700: PPUSH
13701: LD_INT 120
13703: PPUSH
13704: CALL_OW 297
13708: PUSH
13709: LD_INT 6
13711: LESS
13712: OR
13713: IFFALSE 13676
// CenterNowOnUnits ( Omar ) ;
13715: LD_EXP 53
13719: PPUSH
13720: CALL_OW 87
// DialogueOn ;
13724: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13728: LD_EXP 17
13732: PPUSH
13733: LD_STRING DOmarContam-JMM-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13740: LD_EXP 53
13744: PPUSH
13745: LD_STRING DOmarContam-Omar-1
13747: PPUSH
13748: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13752: LD_EXP 17
13756: PPUSH
13757: LD_STRING DOmarContam-JMM-2
13759: PPUSH
13760: CALL_OW 88
// DialogueOff ;
13764: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13768: LD_INT 5
13770: PPUSH
13771: LD_INT 7
13773: PPUSH
13774: LD_INT 2
13776: PPUSH
13777: LD_INT 1
13779: PPUSH
13780: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13784: LD_INT 105
13786: PPUSH
13787: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13791: LD_EXP 53
13795: PPUSH
13796: LD_INT 203
13798: PPUSH
13799: LD_INT 120
13801: PPUSH
13802: CALL_OW 307
13806: IFFALSE 13784
// YouLost ( MothContaminate ) ;
13808: LD_STRING MothContaminate
13810: PPUSH
13811: CALL_OW 104
// end ;
13815: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13816: LD_EXP 4
13820: NOT
13821: PUSH
13822: LD_INT 22
13824: PUSH
13825: LD_INT 1
13827: PUSH
13828: EMPTY
13829: LIST
13830: LIST
13831: PUSH
13832: LD_INT 34
13834: PUSH
13835: LD_INT 8
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: PPUSH
13846: CALL_OW 69
13850: AND
13851: IFFALSE 13932
13853: GO 13855
13855: DISABLE
// begin if not IsOk ( Powell ) then
13856: LD_EXP 52
13860: PPUSH
13861: CALL_OW 302
13865: NOT
13866: IFFALSE 13870
// exit ;
13868: GO 13932
// DialogueOn ;
13870: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13874: LD_EXP 52
13878: PPUSH
13879: LD_STRING DWinAmericans-Pow-1
13881: PPUSH
13882: CALL_OW 94
// if IsOk ( Burlak ) then
13886: LD_EXP 49
13890: PPUSH
13891: CALL_OW 302
13895: IFFALSE 13909
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13897: LD_EXP 49
13901: PPUSH
13902: LD_STRING DWinAmericans-Bur-1
13904: PPUSH
13905: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13909: LD_EXP 17
13913: PPUSH
13914: LD_STRING DWinAmericans-JMM-1
13916: PPUSH
13917: CALL_OW 88
// DialogueOff ;
13921: CALL_OW 7
// YouLost ( AmBomb ) ;
13925: LD_STRING AmBomb
13927: PPUSH
13928: CALL_OW 104
// end ;
13932: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13933: LD_EXP 2
13937: NOT
13938: PUSH
13939: LD_INT 22
13941: PUSH
13942: LD_INT 3
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: PUSH
13949: LD_INT 34
13951: PUSH
13952: LD_INT 48
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: EMPTY
13960: LIST
13961: LIST
13962: PPUSH
13963: CALL_OW 69
13967: AND
13968: IFFALSE 14049
13970: GO 13972
13972: DISABLE
// begin if not IsOk ( Platonov ) then
13973: LD_EXP 56
13977: PPUSH
13978: CALL_OW 302
13982: NOT
13983: IFFALSE 13987
// exit ;
13985: GO 14049
// DialogueOn ;
13987: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13991: LD_EXP 56
13995: PPUSH
13996: LD_STRING DWinRussians-Pla-1
13998: PPUSH
13999: CALL_OW 94
// if IsOk ( Burlak ) then
14003: LD_EXP 49
14007: PPUSH
14008: CALL_OW 302
14012: IFFALSE 14026
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14014: LD_EXP 49
14018: PPUSH
14019: LD_STRING DWinRussians-Bur-1
14021: PPUSH
14022: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14026: LD_EXP 17
14030: PPUSH
14031: LD_STRING DWinRussians-JMM-1
14033: PPUSH
14034: CALL_OW 88
// DialogueOff ;
14038: CALL_OW 7
// YouLost ( RuBomb ) ;
14042: LD_STRING RuBomb
14044: PPUSH
14045: CALL_OW 104
// end ;
14049: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14050: LD_INT 7
14052: PPUSH
14053: LD_INT 22
14055: PUSH
14056: LD_INT 7
14058: PUSH
14059: EMPTY
14060: LIST
14061: LIST
14062: PPUSH
14063: CALL_OW 70
14067: PUSH
14068: LD_EXP 4
14072: NOT
14073: AND
14074: IFFALSE 14103
14076: GO 14078
14078: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14079: LD_EXP 52
14083: PPUSH
14084: LD_STRING DSurrenderAmericans-Pow-1
14086: PPUSH
14087: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14091: LD_EXP 17
14095: PPUSH
14096: LD_STRING DSurrenderAmericans-JMM-1
14098: PPUSH
14099: CALL_OW 88
// end ;
14103: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14104: LD_INT 2
14106: PPUSH
14107: LD_INT 22
14109: PUSH
14110: LD_INT 7
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: PPUSH
14117: CALL_OW 70
14121: PUSH
14122: LD_EXP 2
14126: NOT
14127: AND
14128: PUSH
14129: LD_EXP 49
14133: AND
14134: IFFALSE 14163
14136: GO 14138
14138: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14139: LD_EXP 56
14143: PPUSH
14144: LD_STRING DSurrenderRussians-Pla-1
14146: PPUSH
14147: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14151: LD_EXP 49
14155: PPUSH
14156: LD_STRING DSurrenderRussians-Bur-1
14158: PPUSH
14159: CALL_OW 88
// end ;
14163: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14164: LD_EXP 4
14168: IFFALSE 14551
14170: GO 14172
14172: DISABLE
14173: LD_INT 0
14175: PPUSH
14176: PPUSH
14177: PPUSH
// begin MC_Kill ( 4 ) ;
14178: LD_INT 4
14180: PPUSH
14181: CALL 20883 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14185: LD_INT 1
14187: PPUSH
14188: LD_INT 7
14190: PPUSH
14191: LD_INT 1
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14201: LD_ADDR_VAR 0 3
14205: PUSH
14206: LD_INT 22
14208: PUSH
14209: LD_INT 1
14211: PUSH
14212: EMPTY
14213: LIST
14214: LIST
14215: PUSH
14216: LD_INT 26
14218: PUSH
14219: LD_INT 1
14221: PUSH
14222: EMPTY
14223: LIST
14224: LIST
14225: PUSH
14226: LD_INT 23
14228: PUSH
14229: LD_INT 1
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PUSH
14236: EMPTY
14237: LIST
14238: LIST
14239: LIST
14240: PPUSH
14241: CALL_OW 69
14245: PUSH
14246: LD_EXP 52
14250: PUSH
14251: LD_EXP 25
14255: PUSH
14256: LD_EXP 22
14260: PUSH
14261: LD_EXP 21
14265: PUSH
14266: LD_EXP 28
14270: PUSH
14271: LD_EXP 26
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: LIST
14280: LIST
14281: LIST
14282: LIST
14283: DIFF
14284: ST_TO_ADDR
// if speaker then
14285: LD_VAR 0 3
14289: IFFALSE 14315
// begin DialogueOn ;
14291: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14295: LD_VAR 0 3
14299: PUSH
14300: LD_INT 1
14302: ARRAY
14303: PPUSH
14304: LD_STRING DSurrenderAmericans-Sol1-1a
14306: PPUSH
14307: CALL_OW 94
// DialogueOff ;
14311: CALL_OW 7
// end ; americanCapitulated := true ;
14315: LD_ADDR_EXP 6
14319: PUSH
14320: LD_INT 1
14322: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14323: LD_ADDR_VAR 0 2
14327: PUSH
14328: LD_INT 22
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: LD_INT 21
14340: PUSH
14341: LD_INT 1
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PPUSH
14352: CALL_OW 69
14356: PUSH
14357: LD_INT 22
14359: PUSH
14360: LD_INT 1
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: PUSH
14367: LD_INT 21
14369: PUSH
14370: LD_INT 2
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: PUSH
14377: LD_INT 1
14379: PUSH
14380: EMPTY
14381: LIST
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: LIST
14387: PPUSH
14388: CALL_OW 69
14392: ADD
14393: ST_TO_ADDR
// if tmp then
14394: LD_VAR 0 2
14398: IFFALSE 14551
// repeat wait ( 0 0$1 ) ;
14400: LD_INT 35
14402: PPUSH
14403: CALL_OW 67
// for i in tmp do
14407: LD_ADDR_VAR 0 1
14411: PUSH
14412: LD_VAR 0 2
14416: PUSH
14417: FOR_IN
14418: IFFALSE 14500
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14420: LD_VAR 0 1
14424: PPUSH
14425: CALL_OW 310
14429: PUSH
14430: LD_VAR 0 1
14434: PPUSH
14435: CALL_OW 310
14439: PPUSH
14440: CALL_OW 247
14444: PUSH
14445: LD_INT 3
14447: EQUAL
14448: AND
14449: IFFALSE 14460
// ComExitBuilding ( i ) ;
14451: LD_VAR 0 1
14455: PPUSH
14456: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14460: LD_VAR 0 1
14464: PPUSH
14465: LD_INT 122
14467: PPUSH
14468: LD_INT 242
14470: PPUSH
14471: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14475: LD_VAR 0 1
14479: PPUSH
14480: LD_INT 35
14482: PPUSH
14483: CALL_OW 308
14487: IFFALSE 14498
// RemoveUnit ( i ) ;
14489: LD_VAR 0 1
14493: PPUSH
14494: CALL_OW 64
// end ;
14498: GO 14417
14500: POP
14501: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14502: LD_INT 22
14504: PUSH
14505: LD_INT 1
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: PUSH
14512: LD_INT 2
14514: PUSH
14515: LD_INT 21
14517: PUSH
14518: LD_INT 1
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PUSH
14525: LD_INT 33
14527: PUSH
14528: LD_INT 1
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: PUSH
14535: EMPTY
14536: LIST
14537: LIST
14538: LIST
14539: PUSH
14540: EMPTY
14541: LIST
14542: LIST
14543: PPUSH
14544: CALL_OW 69
14548: NOT
14549: IFFALSE 14400
// end ;
14551: PPOPN 3
14553: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14554: LD_EXP 2
14558: IFFALSE 14959
14560: GO 14562
14562: DISABLE
14563: LD_INT 0
14565: PPUSH
14566: PPUSH
14567: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14568: LD_INT 35
14570: PPUSH
14571: CALL_OW 67
// until IsDead ( Yakotich ) ;
14575: LD_EXP 57
14579: PPUSH
14580: CALL_OW 301
14584: IFFALSE 14568
// MC_Kill ( 2 ) ;
14586: LD_INT 2
14588: PPUSH
14589: CALL 20883 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14593: LD_INT 3
14595: PPUSH
14596: LD_INT 7
14598: PPUSH
14599: LD_INT 1
14601: PPUSH
14602: LD_INT 1
14604: PPUSH
14605: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14609: LD_ADDR_VAR 0 3
14613: PUSH
14614: LD_INT 22
14616: PUSH
14617: LD_INT 3
14619: PUSH
14620: EMPTY
14621: LIST
14622: LIST
14623: PUSH
14624: LD_INT 26
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 23
14636: PUSH
14637: LD_INT 3
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PUSH
14644: EMPTY
14645: LIST
14646: LIST
14647: LIST
14648: PPUSH
14649: CALL_OW 69
14653: PUSH
14654: LD_EXP 56
14658: PUSH
14659: LD_EXP 57
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: DIFF
14668: ST_TO_ADDR
// if speaker then
14669: LD_VAR 0 3
14673: IFFALSE 14723
// begin DialogueOn ;
14675: CALL_OW 6
// if Burlak then
14679: LD_EXP 49
14683: IFFALSE 14703
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14685: LD_VAR 0 3
14689: PUSH
14690: LD_INT 1
14692: ARRAY
14693: PPUSH
14694: LD_STRING DSurrenderRussians-RSol1-1
14696: PPUSH
14697: CALL_OW 94
14701: GO 14719
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14703: LD_VAR 0 3
14707: PUSH
14708: LD_INT 1
14710: ARRAY
14711: PPUSH
14712: LD_STRING DSurrenderRussians-RSol1-1a
14714: PPUSH
14715: CALL_OW 94
// DialogueOff ;
14719: CALL_OW 7
// end ; russianCapitulated := true ;
14723: LD_ADDR_EXP 7
14727: PUSH
14728: LD_INT 1
14730: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14731: LD_ADDR_VAR 0 2
14735: PUSH
14736: LD_INT 22
14738: PUSH
14739: LD_INT 3
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 21
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: EMPTY
14757: LIST
14758: LIST
14759: PPUSH
14760: CALL_OW 69
14764: PUSH
14765: LD_INT 22
14767: PUSH
14768: LD_INT 3
14770: PUSH
14771: EMPTY
14772: LIST
14773: LIST
14774: PUSH
14775: LD_INT 21
14777: PUSH
14778: LD_INT 2
14780: PUSH
14781: EMPTY
14782: LIST
14783: LIST
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: PUSH
14791: EMPTY
14792: LIST
14793: LIST
14794: LIST
14795: PPUSH
14796: CALL_OW 69
14800: ADD
14801: ST_TO_ADDR
// if tmp then
14802: LD_VAR 0 2
14806: IFFALSE 14959
// repeat wait ( 0 0$1 ) ;
14808: LD_INT 35
14810: PPUSH
14811: CALL_OW 67
// for i in tmp do
14815: LD_ADDR_VAR 0 1
14819: PUSH
14820: LD_VAR 0 2
14824: PUSH
14825: FOR_IN
14826: IFFALSE 14908
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14828: LD_VAR 0 1
14832: PPUSH
14833: CALL_OW 310
14837: PUSH
14838: LD_VAR 0 1
14842: PPUSH
14843: CALL_OW 310
14847: PPUSH
14848: CALL_OW 247
14852: PUSH
14853: LD_INT 3
14855: EQUAL
14856: AND
14857: IFFALSE 14868
// ComExitBuilding ( i ) ;
14859: LD_VAR 0 1
14863: PPUSH
14864: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14868: LD_VAR 0 1
14872: PPUSH
14873: LD_INT 154
14875: PPUSH
14876: LD_INT 1
14878: PPUSH
14879: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14883: LD_VAR 0 1
14887: PPUSH
14888: LD_INT 36
14890: PPUSH
14891: CALL_OW 308
14895: IFFALSE 14906
// RemoveUnit ( i ) ;
14897: LD_VAR 0 1
14901: PPUSH
14902: CALL_OW 64
// end ;
14906: GO 14825
14908: POP
14909: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14910: LD_INT 22
14912: PUSH
14913: LD_INT 3
14915: PUSH
14916: EMPTY
14917: LIST
14918: LIST
14919: PUSH
14920: LD_INT 2
14922: PUSH
14923: LD_INT 21
14925: PUSH
14926: LD_INT 1
14928: PUSH
14929: EMPTY
14930: LIST
14931: LIST
14932: PUSH
14933: LD_INT 33
14935: PUSH
14936: LD_INT 1
14938: PUSH
14939: EMPTY
14940: LIST
14941: LIST
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: LIST
14947: PUSH
14948: EMPTY
14949: LIST
14950: LIST
14951: PPUSH
14952: CALL_OW 69
14956: NOT
14957: IFFALSE 14808
// end ;
14959: PPOPN 3
14961: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14962: LD_INT 22
14964: PUSH
14965: LD_INT 8
14967: PUSH
14968: EMPTY
14969: LIST
14970: LIST
14971: PUSH
14972: LD_INT 21
14974: PUSH
14975: LD_INT 1
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: PUSH
14982: LD_INT 23
14984: PUSH
14985: LD_INT 2
14987: PUSH
14988: EMPTY
14989: LIST
14990: LIST
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: LIST
14996: PPUSH
14997: CALL_OW 69
15001: PUSH
15002: LD_INT 18
15004: LESS
15005: PUSH
15006: LD_EXP 55
15010: PPUSH
15011: CALL_OW 301
15015: OR
15016: PUSH
15017: LD_INT 324
15019: PPUSH
15020: CALL_OW 255
15024: PUSH
15025: LD_INT 7
15027: EQUAL
15028: OR
15029: IFFALSE 15042
15031: GO 15033
15033: DISABLE
// legionDestroyed := true ;
15034: LD_ADDR_EXP 3
15038: PUSH
15039: LD_INT 1
15041: ST_TO_ADDR
15042: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15043: LD_INT 22
15045: PUSH
15046: LD_INT 2
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PUSH
15053: LD_INT 21
15055: PUSH
15056: LD_INT 1
15058: PUSH
15059: EMPTY
15060: LIST
15061: LIST
15062: PUSH
15063: LD_INT 23
15065: PUSH
15066: LD_INT 2
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: LIST
15077: PPUSH
15078: CALL_OW 69
15082: PUSH
15083: LD_INT 9
15085: LESS
15086: IFFALSE 15099
15088: GO 15090
15090: DISABLE
// arabianDestroyed := true ;
15091: LD_ADDR_EXP 5
15095: PUSH
15096: LD_INT 1
15098: ST_TO_ADDR
15099: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15100: LD_EXP 5
15104: IFFALSE 15348
15106: GO 15108
15108: DISABLE
15109: LD_INT 0
15111: PPUSH
15112: PPUSH
// begin MC_Kill ( 1 ) ;
15113: LD_INT 1
15115: PPUSH
15116: CALL 20883 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15120: LD_ADDR_VAR 0 2
15124: PUSH
15125: LD_INT 22
15127: PUSH
15128: LD_INT 2
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: LD_INT 21
15137: PUSH
15138: LD_INT 1
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PPUSH
15149: CALL_OW 69
15153: PUSH
15154: LD_INT 22
15156: PUSH
15157: LD_INT 8
15159: PUSH
15160: EMPTY
15161: LIST
15162: LIST
15163: PUSH
15164: LD_INT 21
15166: PUSH
15167: LD_INT 2
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: PUSH
15174: LD_INT 1
15176: PUSH
15177: EMPTY
15178: LIST
15179: PUSH
15180: EMPTY
15181: LIST
15182: LIST
15183: LIST
15184: PPUSH
15185: CALL_OW 69
15189: ADD
15190: ST_TO_ADDR
// if tmp then
15191: LD_VAR 0 2
15195: IFFALSE 15348
// repeat wait ( 0 0$1 ) ;
15197: LD_INT 35
15199: PPUSH
15200: CALL_OW 67
// for i in tmp do
15204: LD_ADDR_VAR 0 1
15208: PUSH
15209: LD_VAR 0 2
15213: PUSH
15214: FOR_IN
15215: IFFALSE 15297
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15217: LD_VAR 0 1
15221: PPUSH
15222: CALL_OW 310
15226: PUSH
15227: LD_VAR 0 1
15231: PPUSH
15232: CALL_OW 310
15236: PPUSH
15237: CALL_OW 247
15241: PUSH
15242: LD_INT 3
15244: EQUAL
15245: AND
15246: IFFALSE 15257
// ComExitBuilding ( i ) ;
15248: LD_VAR 0 1
15252: PPUSH
15253: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15257: LD_VAR 0 1
15261: PPUSH
15262: LD_INT 254
15264: PPUSH
15265: LD_INT 268
15267: PPUSH
15268: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15272: LD_VAR 0 1
15276: PPUSH
15277: LD_INT 34
15279: PPUSH
15280: CALL_OW 308
15284: IFFALSE 15295
// RemoveUnit ( i ) ;
15286: LD_VAR 0 1
15290: PPUSH
15291: CALL_OW 64
// end ;
15295: GO 15214
15297: POP
15298: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15299: LD_INT 22
15301: PUSH
15302: LD_INT 2
15304: PUSH
15305: EMPTY
15306: LIST
15307: LIST
15308: PUSH
15309: LD_INT 2
15311: PUSH
15312: LD_INT 21
15314: PUSH
15315: LD_INT 1
15317: PUSH
15318: EMPTY
15319: LIST
15320: LIST
15321: PUSH
15322: LD_INT 33
15324: PUSH
15325: LD_INT 1
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: LIST
15336: PUSH
15337: EMPTY
15338: LIST
15339: LIST
15340: PPUSH
15341: CALL_OW 69
15345: NOT
15346: IFFALSE 15197
// end ;
15348: PPOPN 2
15350: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15351: LD_EXP 3
15355: IFFALSE 15707
15357: GO 15359
15359: DISABLE
15360: LD_INT 0
15362: PPUSH
15363: PPUSH
// begin MC_Kill ( 3 ) ;
15364: LD_INT 3
15366: PPUSH
15367: CALL 20883 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15371: LD_INT 8
15373: PPUSH
15374: LD_INT 7
15376: PPUSH
15377: LD_INT 1
15379: PPUSH
15380: LD_INT 1
15382: PPUSH
15383: CALL_OW 80
// DialogueOn ;
15387: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15391: LD_EXP 54
15395: PPUSH
15396: LD_STRING D15-Szulc-1
15398: PPUSH
15399: CALL_OW 94
// DialogueOff ;
15403: CALL_OW 7
// legionCapitulated := true ;
15407: LD_ADDR_EXP 8
15411: PUSH
15412: LD_INT 1
15414: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15415: LD_ADDR_VAR 0 1
15419: PUSH
15420: LD_INT 22
15422: PUSH
15423: LD_INT 8
15425: PUSH
15426: EMPTY
15427: LIST
15428: LIST
15429: PUSH
15430: LD_INT 21
15432: PUSH
15433: LD_INT 3
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: PUSH
15440: LD_INT 23
15442: PUSH
15443: LD_INT 3
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: LIST
15454: PPUSH
15455: CALL_OW 69
15459: PUSH
15460: FOR_IN
15461: IFFALSE 15477
// SetLives ( i , 3 ) ;
15463: LD_VAR 0 1
15467: PPUSH
15468: LD_INT 3
15470: PPUSH
15471: CALL_OW 234
15475: GO 15460
15477: POP
15478: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15479: LD_ADDR_VAR 0 2
15483: PUSH
15484: LD_INT 22
15486: PUSH
15487: LD_INT 8
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: PUSH
15494: LD_INT 21
15496: PUSH
15497: LD_INT 1
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: PPUSH
15508: CALL_OW 69
15512: PUSH
15513: LD_INT 22
15515: PUSH
15516: LD_INT 8
15518: PUSH
15519: EMPTY
15520: LIST
15521: LIST
15522: PUSH
15523: LD_INT 21
15525: PUSH
15526: LD_INT 2
15528: PUSH
15529: EMPTY
15530: LIST
15531: LIST
15532: PUSH
15533: LD_INT 1
15535: PUSH
15536: EMPTY
15537: LIST
15538: PUSH
15539: EMPTY
15540: LIST
15541: LIST
15542: LIST
15543: PPUSH
15544: CALL_OW 69
15548: ADD
15549: ST_TO_ADDR
// if tmp then
15550: LD_VAR 0 2
15554: IFFALSE 15707
// repeat wait ( 0 0$1 ) ;
15556: LD_INT 35
15558: PPUSH
15559: CALL_OW 67
// for i in tmp do
15563: LD_ADDR_VAR 0 1
15567: PUSH
15568: LD_VAR 0 2
15572: PUSH
15573: FOR_IN
15574: IFFALSE 15656
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15576: LD_VAR 0 1
15580: PPUSH
15581: CALL_OW 310
15585: PUSH
15586: LD_VAR 0 1
15590: PPUSH
15591: CALL_OW 310
15595: PPUSH
15596: CALL_OW 247
15600: PUSH
15601: LD_INT 3
15603: EQUAL
15604: AND
15605: IFFALSE 15616
// ComExitBuilding ( i ) ;
15607: LD_VAR 0 1
15611: PPUSH
15612: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15616: LD_VAR 0 1
15620: PPUSH
15621: LD_INT 10
15623: PPUSH
15624: LD_INT 1
15626: PPUSH
15627: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15631: LD_VAR 0 1
15635: PPUSH
15636: LD_INT 32
15638: PPUSH
15639: CALL_OW 308
15643: IFFALSE 15654
// RemoveUnit ( i ) ;
15645: LD_VAR 0 1
15649: PPUSH
15650: CALL_OW 64
// end ;
15654: GO 15573
15656: POP
15657: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15658: LD_INT 22
15660: PUSH
15661: LD_INT 8
15663: PUSH
15664: EMPTY
15665: LIST
15666: LIST
15667: PUSH
15668: LD_INT 2
15670: PUSH
15671: LD_INT 21
15673: PUSH
15674: LD_INT 1
15676: PUSH
15677: EMPTY
15678: LIST
15679: LIST
15680: PUSH
15681: LD_INT 33
15683: PUSH
15684: LD_INT 1
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: PUSH
15691: EMPTY
15692: LIST
15693: LIST
15694: LIST
15695: PUSH
15696: EMPTY
15697: LIST
15698: LIST
15699: PPUSH
15700: CALL_OW 69
15704: NOT
15705: IFFALSE 15556
// end ;
15707: PPOPN 2
15709: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15710: LD_EXP 4
15714: PUSH
15715: LD_EXP 2
15719: AND
15720: PUSH
15721: LD_EXP 3
15725: AND
15726: PUSH
15727: LD_EXP 5
15731: AND
15732: PUSH
15733: LD_EXP 6
15737: AND
15738: PUSH
15739: LD_EXP 7
15743: AND
15744: PUSH
15745: LD_EXP 8
15749: AND
15750: PUSH
15751: LD_EXP 53
15755: PPUSH
15756: CALL_OW 255
15760: PUSH
15761: LD_INT 5
15763: NONEQUAL
15764: PUSH
15765: LD_EXP 53
15769: PPUSH
15770: CALL_OW 301
15774: OR
15775: PUSH
15776: LD_EXP 53
15780: PPUSH
15781: CALL_OW 305
15785: NOT
15786: OR
15787: AND
15788: IFFALSE 17179
15790: GO 15792
15792: DISABLE
15793: LD_INT 0
15795: PPUSH
15796: PPUSH
// begin wait ( 0 0$5 ) ;
15797: LD_INT 175
15799: PPUSH
15800: CALL_OW 67
// music_class := 5 ;
15804: LD_ADDR_OWVAR 72
15808: PUSH
15809: LD_INT 5
15811: ST_TO_ADDR
// music_nat := 5 ;
15812: LD_ADDR_OWVAR 71
15816: PUSH
15817: LD_INT 5
15819: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15820: LD_EXP 15
15824: PUSH
15825: LD_INT 3
15827: LESS
15828: IFFALSE 15837
// SetAchievement ( ACH_ECONOMY ) ;
15830: LD_STRING ACH_ECONOMY
15832: PPUSH
15833: CALL_OW 543
// if tick < 60 60$00 then
15837: LD_OWVAR 1
15841: PUSH
15842: LD_INT 126000
15844: LESS
15845: IFFALSE 15861
// begin wait ( 3 ) ;
15847: LD_INT 3
15849: PPUSH
15850: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15854: LD_STRING ACH_ASPEED_19
15856: PPUSH
15857: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15861: LD_EXP 17
15865: PPUSH
15866: CALL_OW 87
// InGameOn ;
15870: CALL_OW 8
// DialogueOn ;
15874: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15878: LD_EXP 17
15882: PPUSH
15883: LD_STRING DEnd-JMM-JMM-1
15885: PPUSH
15886: CALL_OW 88
// if Joan then
15890: LD_EXP 32
15894: IFFALSE 15910
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15896: LD_EXP 32
15900: PPUSH
15901: LD_STRING DEnd-JMM-Joan-1
15903: PPUSH
15904: CALL_OW 88
15908: GO 15954
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15910: LD_EXP 19
15914: PUSH
15915: LD_EXP 19
15919: PPUSH
15920: CALL_OW 255
15924: PUSH
15925: LD_INT 7
15927: EQUAL
15928: AND
15929: PUSH
15930: LD_EXP 19
15934: PPUSH
15935: CALL_OW 305
15939: AND
15940: IFFALSE 15954
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15942: LD_EXP 19
15946: PPUSH
15947: LD_STRING DEnd-JMM-Lisa-1
15949: PPUSH
15950: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15954: LD_EXP 29
15958: PUSH
15959: LD_EXP 29
15963: PPUSH
15964: CALL_OW 305
15968: AND
15969: IFFALSE 15983
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15971: LD_EXP 29
15975: PPUSH
15976: LD_STRING DEnd-JMM-Frank-1
15978: PPUSH
15979: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15983: LD_EXP 22
15987: PUSH
15988: LD_EXP 22
15992: PPUSH
15993: CALL_OW 255
15997: PUSH
15998: LD_INT 7
16000: EQUAL
16001: AND
16002: PUSH
16003: LD_EXP 22
16007: PPUSH
16008: CALL_OW 305
16012: AND
16013: IFFALSE 16027
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16015: LD_EXP 22
16019: PPUSH
16020: LD_STRING DEnd-JMM-Cyrus-1
16022: PPUSH
16023: CALL_OW 88
// if Burlak then
16027: LD_EXP 49
16031: IFFALSE 16045
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16033: LD_EXP 49
16037: PPUSH
16038: LD_STRING DEnd-JMM-Bur-1
16040: PPUSH
16041: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16045: LD_EXP 32
16049: PUSH
16050: LD_EXP 19
16054: AND
16055: PUSH
16056: LD_EXP 19
16060: PPUSH
16061: CALL_OW 255
16065: PUSH
16066: LD_INT 7
16068: EQUAL
16069: AND
16070: PUSH
16071: LD_EXP 19
16075: PPUSH
16076: CALL_OW 305
16080: AND
16081: IFFALSE 16095
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16083: LD_EXP 19
16087: PPUSH
16088: LD_STRING DEnd-Burlak-Lisa-1
16090: PPUSH
16091: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16095: LD_EXP 50
16099: PUSH
16100: LD_EXP 50
16104: PPUSH
16105: CALL_OW 305
16109: AND
16110: IFFALSE 16124
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16112: LD_EXP 50
16116: PPUSH
16117: LD_STRING DEnd-JMM-Bel-1
16119: PPUSH
16120: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16124: LD_EXP 51
16128: PUSH
16129: LD_EXP 51
16133: PPUSH
16134: CALL_OW 305
16138: AND
16139: IFFALSE 16153
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16141: LD_EXP 51
16145: PPUSH
16146: LD_STRING DEnd-JMM-Gny-1
16148: PPUSH
16149: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16153: LD_EXP 27
16157: PUSH
16158: LD_EXP 27
16162: PPUSH
16163: CALL_OW 255
16167: PUSH
16168: LD_INT 7
16170: EQUAL
16171: AND
16172: PUSH
16173: LD_EXP 27
16177: PPUSH
16178: CALL_OW 305
16182: AND
16183: IFFALSE 16197
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16185: LD_EXP 27
16189: PPUSH
16190: LD_STRING DEnd-JMM-Corn-1
16192: PPUSH
16193: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16197: LD_EXP 20
16201: PUSH
16202: LD_EXP 20
16206: PPUSH
16207: CALL_OW 255
16211: PUSH
16212: LD_INT 7
16214: EQUAL
16215: AND
16216: PUSH
16217: LD_EXP 20
16221: PPUSH
16222: CALL_OW 305
16226: AND
16227: IFFALSE 16241
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16229: LD_EXP 20
16233: PPUSH
16234: LD_STRING DEnd-JMM-Don-1
16236: PPUSH
16237: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16241: LD_EXP 21
16245: PUSH
16246: LD_EXP 21
16250: PPUSH
16251: CALL_OW 255
16255: PUSH
16256: LD_INT 7
16258: EQUAL
16259: AND
16260: PUSH
16261: LD_EXP 21
16265: PPUSH
16266: CALL_OW 305
16270: AND
16271: IFFALSE 16285
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16273: LD_EXP 21
16277: PPUSH
16278: LD_STRING DEnd-JMM-Bobby-1
16280: PPUSH
16281: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16285: LD_EXP 23
16289: PUSH
16290: LD_EXP 23
16294: PPUSH
16295: CALL_OW 255
16299: PUSH
16300: LD_INT 7
16302: EQUAL
16303: AND
16304: PUSH
16305: LD_EXP 23
16309: PPUSH
16310: CALL_OW 305
16314: AND
16315: IFFALSE 16329
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16317: LD_EXP 23
16321: PPUSH
16322: LD_STRING DEnd-JMM-Den-1
16324: PPUSH
16325: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16329: LD_EXP 25
16333: PUSH
16334: LD_EXP 25
16338: PPUSH
16339: CALL_OW 255
16343: PUSH
16344: LD_INT 7
16346: EQUAL
16347: AND
16348: PUSH
16349: LD_EXP 25
16353: PPUSH
16354: CALL_OW 305
16358: AND
16359: IFFALSE 16373
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16361: LD_EXP 25
16365: PPUSH
16366: LD_STRING DEnd-JMM-Glad-1
16368: PPUSH
16369: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16373: LD_EXP 30
16377: PUSH
16378: LD_EXP 30
16382: PPUSH
16383: CALL_OW 255
16387: PUSH
16388: LD_INT 7
16390: EQUAL
16391: AND
16392: PUSH
16393: LD_EXP 30
16397: PPUSH
16398: CALL_OW 305
16402: AND
16403: IFFALSE 16417
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16405: LD_EXP 30
16409: PPUSH
16410: LD_STRING DEnd-JMM-Yam-1
16412: PPUSH
16413: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16417: LD_EXP 24
16421: PUSH
16422: LD_EXP 24
16426: PPUSH
16427: CALL_OW 255
16431: PUSH
16432: LD_INT 7
16434: EQUAL
16435: AND
16436: PUSH
16437: LD_EXP 24
16441: PPUSH
16442: CALL_OW 305
16446: AND
16447: IFFALSE 16461
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16449: LD_EXP 24
16453: PPUSH
16454: LD_STRING DEnd-JMM-Brown-1
16456: PPUSH
16457: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16461: LD_EXP 34
16465: PUSH
16466: LD_EXP 34
16470: PPUSH
16471: CALL_OW 255
16475: PUSH
16476: LD_INT 7
16478: EQUAL
16479: AND
16480: PUSH
16481: LD_EXP 34
16485: PPUSH
16486: CALL_OW 305
16490: AND
16491: IFFALSE 16505
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16493: LD_EXP 34
16497: PPUSH
16498: LD_STRING DEnd-JMM-Con-1
16500: PPUSH
16501: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16505: LD_EXP 28
16509: PUSH
16510: LD_EXP 28
16514: PPUSH
16515: CALL_OW 255
16519: PUSH
16520: LD_INT 7
16522: EQUAL
16523: AND
16524: PUSH
16525: LD_EXP 28
16529: PPUSH
16530: CALL_OW 305
16534: AND
16535: IFFALSE 16549
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16537: LD_EXP 28
16541: PPUSH
16542: LD_STRING DEnd-JMM-Gary-1
16544: PPUSH
16545: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16549: LD_EXP 31
16553: PUSH
16554: LD_EXP 18
16558: AND
16559: PUSH
16560: LD_EXP 31
16564: PPUSH
16565: CALL_OW 305
16569: AND
16570: IFFALSE 16584
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16572: LD_EXP 31
16576: PPUSH
16577: LD_STRING DEnd-JMM-Sim-1
16579: PPUSH
16580: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16584: LD_EXP 26
16588: PUSH
16589: LD_EXP 26
16593: PPUSH
16594: CALL_OW 255
16598: PUSH
16599: LD_INT 7
16601: EQUAL
16602: AND
16603: PUSH
16604: LD_EXP 26
16608: PPUSH
16609: CALL_OW 305
16613: AND
16614: IFFALSE 16628
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16616: LD_EXP 26
16620: PPUSH
16621: LD_STRING DEnd-JMM-VanH-1
16623: PPUSH
16624: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16628: LD_EXP 39
16632: PUSH
16633: LD_EXP 39
16637: PPUSH
16638: CALL_OW 305
16642: AND
16643: IFFALSE 16657
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16645: LD_EXP 39
16649: PPUSH
16650: LD_STRING DEnd-JMM-Dol-1
16652: PPUSH
16653: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16657: LD_EXP 43
16661: PUSH
16662: LD_EXP 43
16666: PPUSH
16667: CALL_OW 305
16671: AND
16672: IFFALSE 16686
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16674: LD_EXP 43
16678: PPUSH
16679: LD_STRING DEnd-JMM-Kap-1
16681: PPUSH
16682: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16686: LD_EXP 46
16690: PUSH
16691: LD_EXP 46
16695: PPUSH
16696: CALL_OW 305
16700: AND
16701: IFFALSE 16715
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16703: LD_EXP 46
16707: PPUSH
16708: LD_STRING DEnd-JMM-Kov-1
16710: PPUSH
16711: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16715: LD_EXP 41
16719: PUSH
16720: LD_EXP 41
16724: PPUSH
16725: CALL_OW 305
16729: AND
16730: IFFALSE 16744
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16732: LD_EXP 41
16736: PPUSH
16737: LD_STRING DEnd-JMM-Sch-1
16739: PPUSH
16740: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16744: LD_EXP 37
16748: PUSH
16749: LD_EXP 37
16753: PPUSH
16754: CALL_OW 305
16758: AND
16759: IFFALSE 16773
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16761: LD_EXP 37
16765: PPUSH
16766: LD_STRING DEnd-JMM-Tit-1
16768: PPUSH
16769: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16773: LD_EXP 42
16777: PUSH
16778: LD_EXP 42
16782: PPUSH
16783: CALL_OW 305
16787: AND
16788: IFFALSE 16802
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16790: LD_EXP 42
16794: PPUSH
16795: LD_STRING DEnd-JMM-Obl-1
16797: PPUSH
16798: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16802: LD_EXP 44
16806: PUSH
16807: LD_EXP 44
16811: PPUSH
16812: CALL_OW 305
16816: AND
16817: IFFALSE 16831
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16819: LD_EXP 44
16823: PPUSH
16824: LD_STRING DEnd-JMM-Lip-1
16826: PPUSH
16827: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16831: LD_EXP 38
16835: PUSH
16836: LD_EXP 38
16840: PPUSH
16841: CALL_OW 305
16845: AND
16846: PUSH
16847: LD_EXP 49
16851: AND
16852: IFFALSE 16866
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16854: LD_EXP 38
16858: PPUSH
16859: LD_STRING DEnd-Burlak-Fad-1
16861: PPUSH
16862: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16866: LD_EXP 45
16870: PUSH
16871: LD_EXP 45
16875: PPUSH
16876: CALL_OW 305
16880: AND
16881: IFFALSE 16895
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16883: LD_EXP 45
16887: PPUSH
16888: LD_STRING DEnd-Burlak-Ptr-1
16890: PPUSH
16891: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16895: LD_EXP 47
16899: PUSH
16900: LD_EXP 47
16904: PPUSH
16905: CALL_OW 305
16909: AND
16910: IFFALSE 16924
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16912: LD_EXP 47
16916: PPUSH
16917: LD_STRING DEnd-Burlak-Kuz-1
16919: PPUSH
16920: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16924: LD_EXP 36
16928: PUSH
16929: LD_EXP 36
16933: PPUSH
16934: CALL_OW 305
16938: AND
16939: PUSH
16940: LD_EXP 49
16944: AND
16945: IFFALSE 16959
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16947: LD_EXP 36
16951: PPUSH
16952: LD_STRING DEnd-Burlak-Kir-1
16954: PPUSH
16955: CALL_OW 88
// if Burlak then
16959: LD_EXP 49
16963: IFFALSE 16977
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16965: LD_EXP 17
16969: PPUSH
16970: LD_STRING DEnd-Burlak-JMM-1
16972: PPUSH
16973: CALL_OW 88
// dwait ( 0 0$2 ) ;
16977: LD_INT 70
16979: PPUSH
16980: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16984: LD_EXP 54
16988: PPUSH
16989: LD_STRING DEnd-Szulc
16991: PPUSH
16992: CALL_OW 94
// dwait ( 0 0$1 ) ;
16996: LD_INT 35
16998: PPUSH
16999: CALL_OW 68
// if IsLive ( Burlak ) then
17003: LD_EXP 49
17007: PPUSH
17008: CALL_OW 300
17012: IFFALSE 17024
// med1 := 1 else
17014: LD_ADDR_VAR 0 1
17018: PUSH
17019: LD_INT 1
17021: ST_TO_ADDR
17022: GO 17033
// med1 := - 1 ;
17024: LD_ADDR_VAR 0 1
17028: PUSH
17029: LD_INT 1
17031: NEG
17032: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17033: LD_EXP 12
17037: PUSH
17038: LD_EXP 13
17042: AND
17043: PUSH
17044: LD_EXP 14
17048: AND
17049: IFFALSE 17061
// med2 := 1 else
17051: LD_ADDR_VAR 0 2
17055: PUSH
17056: LD_INT 1
17058: ST_TO_ADDR
17059: GO 17070
// med2 := - 1 ;
17061: LD_ADDR_VAR 0 2
17065: PUSH
17066: LD_INT 1
17068: NEG
17069: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17070: LD_STRING Hero
17072: PPUSH
17073: LD_INT 1
17075: PPUSH
17076: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17080: LD_STRING Artefact
17082: PPUSH
17083: LD_VAR 0 2
17087: PPUSH
17088: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17092: LD_STRING ReconcileBurlak
17094: PPUSH
17095: LD_VAR 0 1
17099: PPUSH
17100: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17104: LD_OWVAR 67
17108: PUSH
17109: LD_INT 3
17111: EQUAL
17112: PUSH
17113: LD_VAR 0 1
17117: PUSH
17118: LD_INT 1
17120: EQUAL
17121: AND
17122: PUSH
17123: LD_VAR 0 2
17127: PUSH
17128: LD_INT 1
17130: EQUAL
17131: AND
17132: IFFALSE 17144
// SetAchievementEX ( ACH_AMER , 19 ) ;
17134: LD_STRING ACH_AMER
17136: PPUSH
17137: LD_INT 19
17139: PPUSH
17140: CALL_OW 564
// GiveMedals ( MAIN ) ;
17144: LD_STRING MAIN
17146: PPUSH
17147: CALL_OW 102
// InGameOff ;
17151: CALL_OW 9
// DialogueOff ;
17155: CALL_OW 7
// music_nat := 1 ;
17159: LD_ADDR_OWVAR 71
17163: PUSH
17164: LD_INT 1
17166: ST_TO_ADDR
// music_class := 4 ;
17167: LD_ADDR_OWVAR 72
17171: PUSH
17172: LD_INT 4
17174: ST_TO_ADDR
// YouWin ;
17175: CALL_OW 103
// end ; end_of_file
17179: PPOPN 2
17181: END
// export function InitNature ; begin
17182: LD_INT 0
17184: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17185: LD_INT 3
17187: PPUSH
17188: LD_INT 3
17190: PPUSH
17191: LD_INT 2
17193: PPUSH
17194: LD_INT 1
17196: PPUSH
17197: LD_INT 1
17199: PPUSH
17200: LD_INT 0
17202: PPUSH
17203: LD_INT 0
17205: PPUSH
17206: LD_INT 17
17208: PPUSH
17209: LD_INT 0
17211: PPUSH
17212: CALL 83286 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17216: LD_INT 2
17218: PPUSH
17219: LD_INT 1
17221: PPUSH
17222: LD_INT 1
17224: PPUSH
17225: LD_INT 1
17227: PPUSH
17228: LD_INT 1
17230: PPUSH
17231: LD_INT 0
17233: PPUSH
17234: LD_INT 0
17236: PPUSH
17237: LD_INT 18
17239: PPUSH
17240: LD_INT 0
17242: PPUSH
17243: CALL 83286 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17247: LD_INT 4
17249: PPUSH
17250: LD_INT 1
17252: PPUSH
17253: LD_INT 2
17255: PPUSH
17256: LD_INT 4
17258: PPUSH
17259: LD_INT 2
17261: PPUSH
17262: LD_INT 1
17264: PPUSH
17265: LD_INT 0
17267: PPUSH
17268: LD_INT 19
17270: PPUSH
17271: LD_INT 0
17273: PPUSH
17274: CALL 83286 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17278: LD_INT 0
17280: PPUSH
17281: LD_INT 0
17283: PPUSH
17284: LD_INT 0
17286: PPUSH
17287: LD_INT 0
17289: PPUSH
17290: LD_INT 0
17292: PPUSH
17293: LD_INT 0
17295: PPUSH
17296: LD_INT 9
17298: PPUSH
17299: LD_INT 0
17301: PPUSH
17302: LD_INT 20
17304: PPUSH
17305: CALL 83286 0 9
// end ; end_of_file
17309: LD_VAR 0 1
17313: RET
// every 0 0$30 do var time ;
17314: GO 17316
17316: DISABLE
17317: LD_INT 0
17319: PPUSH
// begin time := 0 0$50 ;
17320: LD_ADDR_VAR 0 1
17324: PUSH
17325: LD_INT 1750
17327: ST_TO_ADDR
// repeat wait ( time ) ;
17328: LD_VAR 0 1
17332: PPUSH
17333: CALL_OW 67
// if Prob ( 50 ) then
17337: LD_INT 50
17339: PPUSH
17340: CALL_OW 13
17344: IFFALSE 17373
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17346: LD_INT 1
17348: PPUSH
17349: LD_INT 5
17351: PPUSH
17352: CALL_OW 12
17356: PPUSH
17357: LD_INT 106
17359: PPUSH
17360: LD_INT 89
17362: PPUSH
17363: LD_INT 45
17365: PPUSH
17366: LD_INT 1
17368: PPUSH
17369: CALL_OW 56
// time := time + 0 0$3 ;
17373: LD_ADDR_VAR 0 1
17377: PUSH
17378: LD_VAR 0 1
17382: PUSH
17383: LD_INT 105
17385: PLUS
17386: ST_TO_ADDR
// if Prob ( 30 ) then
17387: LD_INT 30
17389: PPUSH
17390: CALL_OW 13
17394: IFFALSE 17440
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17396: LD_INT 525
17398: PPUSH
17399: LD_INT 735
17401: PPUSH
17402: CALL_OW 12
17406: PPUSH
17407: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17411: LD_INT 1
17413: PPUSH
17414: LD_INT 5
17416: PPUSH
17417: CALL_OW 12
17421: PPUSH
17422: LD_INT 21
17424: PPUSH
17425: LD_INT 26
17427: PPUSH
17428: LD_INT 12
17430: PPUSH
17431: LD_INT 1
17433: PPUSH
17434: CALL_OW 56
// end else
17438: GO 17476
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17440: LD_INT 700
17442: PPUSH
17443: LD_INT 1225
17445: PPUSH
17446: CALL_OW 12
17450: PPUSH
17451: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17455: LD_INT 1
17457: PPUSH
17458: LD_INT 5
17460: PPUSH
17461: CALL_OW 12
17465: PPUSH
17466: LD_INT 14
17468: PPUSH
17469: LD_INT 1
17471: PPUSH
17472: CALL_OW 55
// end ; if Prob ( 50 ) then
17476: LD_INT 50
17478: PPUSH
17479: CALL_OW 13
17483: IFFALSE 17529
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17485: LD_INT 700
17487: PPUSH
17488: LD_INT 1050
17490: PPUSH
17491: CALL_OW 12
17495: PPUSH
17496: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17500: LD_INT 1
17502: PPUSH
17503: LD_INT 5
17505: PPUSH
17506: CALL_OW 12
17510: PPUSH
17511: LD_INT 181
17513: PPUSH
17514: LD_INT 218
17516: PPUSH
17517: LD_INT 16
17519: PPUSH
17520: LD_INT 1
17522: PPUSH
17523: CALL_OW 56
// end else
17527: GO 17601
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17529: LD_INT 350
17531: PPUSH
17532: LD_INT 525
17534: PPUSH
17535: CALL_OW 12
17539: PPUSH
17540: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17544: LD_INT 1
17546: PPUSH
17547: LD_INT 5
17549: PPUSH
17550: CALL_OW 12
17554: PPUSH
17555: LD_INT 13
17557: PPUSH
17558: LD_INT 1
17560: PPUSH
17561: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17565: LD_INT 350
17567: PPUSH
17568: LD_INT 700
17570: PPUSH
17571: CALL_OW 12
17575: PPUSH
17576: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17580: LD_INT 1
17582: PPUSH
17583: LD_INT 5
17585: PPUSH
17586: CALL_OW 12
17590: PPUSH
17591: LD_INT 33
17593: PPUSH
17594: LD_INT 1
17596: PPUSH
17597: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17601: LD_INT 65
17603: PUSH
17604: LD_INT 62
17606: PUSH
17607: LD_INT 55
17609: PUSH
17610: EMPTY
17611: LIST
17612: LIST
17613: LIST
17614: PUSH
17615: LD_OWVAR 67
17619: ARRAY
17620: PPUSH
17621: CALL_OW 13
17625: IFFALSE 17671
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17627: LD_INT 525
17629: PPUSH
17630: LD_INT 875
17632: PPUSH
17633: CALL_OW 12
17637: PPUSH
17638: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17642: LD_INT 1
17644: PPUSH
17645: LD_INT 5
17647: PPUSH
17648: CALL_OW 12
17652: PPUSH
17653: LD_INT 294
17655: PPUSH
17656: LD_INT 211
17658: PPUSH
17659: LD_INT 30
17661: PPUSH
17662: LD_INT 1
17664: PPUSH
17665: CALL_OW 56
// end else
17669: GO 17713
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17671: LD_INT 420
17673: PPUSH
17674: LD_INT 770
17676: PPUSH
17677: CALL_OW 12
17681: PPUSH
17682: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17686: LD_INT 1
17688: PPUSH
17689: LD_INT 5
17691: PPUSH
17692: CALL_OW 12
17696: PPUSH
17697: LD_INT 294
17699: PPUSH
17700: LD_INT 211
17702: PPUSH
17703: LD_INT 30
17705: PPUSH
17706: LD_INT 1
17708: PPUSH
17709: CALL_OW 56
// end ; if time > 2 2$20 then
17713: LD_VAR 0 1
17717: PUSH
17718: LD_INT 4900
17720: GREATER
17721: IFFALSE 17731
// time := 0 0$50 ;
17723: LD_ADDR_VAR 0 1
17727: PUSH
17728: LD_INT 1750
17730: ST_TO_ADDR
// until false ;
17731: LD_INT 0
17733: IFFALSE 17328
// end ;
17735: PPOPN 1
17737: END
// every 0 0$45 trigger tick < 10 10$00 do
17738: LD_OWVAR 1
17742: PUSH
17743: LD_INT 21000
17745: LESS
17746: IFFALSE 17794
17748: GO 17750
17750: DISABLE
// begin enable ;
17751: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17752: LD_INT 350
17754: PPUSH
17755: LD_INT 700
17757: PPUSH
17758: CALL_OW 12
17762: PPUSH
17763: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17767: LD_INT 3
17769: PPUSH
17770: LD_INT 5
17772: PPUSH
17773: CALL_OW 12
17777: PPUSH
17778: LD_INT 181
17780: PPUSH
17781: LD_INT 13
17783: PPUSH
17784: LD_INT 20
17786: PPUSH
17787: LD_INT 1
17789: PPUSH
17790: CALL_OW 56
// end ; end_of_file
17794: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17795: LD_INT 0
17797: PPUSH
// SetArtifactRes ( 7 , true ) ;
17798: LD_INT 7
17800: PPUSH
17801: LD_INT 1
17803: PPUSH
17804: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17808: LD_ADDR_EXP 62
17812: PUSH
17813: EMPTY
17814: PUSH
17815: EMPTY
17816: PUSH
17817: EMPTY
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17824: LD_ADDR_EXP 63
17828: PUSH
17829: LD_INT 1050
17831: PUSH
17832: LD_OWVAR 67
17836: MUL
17837: PUSH
17838: LD_INT 2800
17840: PUSH
17841: LD_OWVAR 67
17845: MUL
17846: PUSH
17847: LD_INT 1
17849: NEG
17850: PUSH
17851: EMPTY
17852: LIST
17853: LIST
17854: LIST
17855: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17856: LD_ADDR_EXP 64
17860: PUSH
17861: LD_INT 10
17863: PUSH
17864: LD_INT 35
17866: PUSH
17867: LD_INT 100
17869: PUSH
17870: EMPTY
17871: LIST
17872: LIST
17873: LIST
17874: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17875: LD_ADDR_EXP 65
17879: PUSH
17880: LD_INT 0
17882: PUSH
17883: LD_INT 0
17885: PUSH
17886: LD_INT 0
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: LIST
17893: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17894: LD_ADDR_EXP 67
17898: PUSH
17899: LD_INT 300
17901: PUSH
17902: LD_INT 500
17904: PUSH
17905: LD_INT 800
17907: PUSH
17908: EMPTY
17909: LIST
17910: LIST
17911: LIST
17912: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17913: LD_ADDR_EXP 68
17917: PUSH
17918: LD_INT 0
17920: PUSH
17921: LD_INT 0
17923: PUSH
17924: LD_INT 0
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: LIST
17931: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17932: LD_ADDR_EXP 69
17936: PUSH
17937: LD_INT 0
17939: PUSH
17940: LD_INT 0
17942: PUSH
17943: LD_INT 0
17945: PUSH
17946: EMPTY
17947: LIST
17948: LIST
17949: LIST
17950: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17951: LD_ADDR_EXP 66
17955: PUSH
17956: LD_INT 0
17958: PUSH
17959: LD_INT 0
17961: PUSH
17962: LD_INT 0
17964: PUSH
17965: EMPTY
17966: LIST
17967: LIST
17968: LIST
17969: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17970: LD_ADDR_EXP 70
17974: PUSH
17975: LD_INT 4
17977: PUSH
17978: LD_INT 3
17980: PUSH
17981: LD_INT 1
17983: PUSH
17984: EMPTY
17985: LIST
17986: LIST
17987: LIST
17988: PUSH
17989: LD_INT 5
17991: PUSH
17992: LD_INT 4
17994: PUSH
17995: LD_INT 2
17997: PUSH
17998: EMPTY
17999: LIST
18000: LIST
18001: LIST
18002: PUSH
18003: LD_INT 6
18005: PUSH
18006: LD_INT 3
18008: PUSH
18009: LD_INT 3
18011: PUSH
18012: EMPTY
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18022: LD_ADDR_EXP 71
18026: PUSH
18027: LD_INT 0
18029: PUSH
18030: LD_INT 0
18032: PUSH
18033: LD_INT 0
18035: PUSH
18036: EMPTY
18037: LIST
18038: LIST
18039: LIST
18040: ST_TO_ADDR
// end ;
18041: LD_VAR 0 1
18045: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18046: LD_INT 24
18048: PPUSH
18049: LD_INT 7
18051: PPUSH
18052: CALL_OW 321
18056: PUSH
18057: LD_INT 2
18059: EQUAL
18060: IFFALSE 18986
18062: GO 18064
18064: DISABLE
18065: LD_INT 0
18067: PPUSH
18068: PPUSH
18069: PPUSH
18070: PPUSH
18071: PPUSH
// begin enable ;
18072: ENABLE
// for i = 1 to 3 do
18073: LD_ADDR_VAR 0 1
18077: PUSH
18078: DOUBLE
18079: LD_INT 1
18081: DEC
18082: ST_TO_ADDR
18083: LD_INT 3
18085: PUSH
18086: FOR_TO
18087: IFFALSE 18984
// begin pos := FindArtifact ( i + 2 ) ;
18089: LD_ADDR_VAR 0 2
18093: PUSH
18094: LD_VAR 0 1
18098: PUSH
18099: LD_INT 2
18101: PLUS
18102: PPUSH
18103: CALL_OW 469
18107: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18108: LD_ADDR_EXP 62
18112: PUSH
18113: LD_EXP 62
18117: PPUSH
18118: LD_VAR 0 1
18122: PPUSH
18123: LD_VAR 0 2
18127: PPUSH
18128: CALL_OW 1
18132: ST_TO_ADDR
// if pos then
18133: LD_VAR 0 2
18137: IFFALSE 18845
// begin case i of 1 :
18139: LD_VAR 0 1
18143: PUSH
18144: LD_INT 1
18146: DOUBLE
18147: EQUAL
18148: IFTRUE 18152
18150: GO 18229
18152: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18153: LD_ADDR_VAR 0 4
18157: PUSH
18158: LD_INT 22
18160: PUSH
18161: LD_INT 7
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: PUSH
18168: LD_INT 23
18170: PUSH
18171: LD_INT 1
18173: PUSH
18174: EMPTY
18175: LIST
18176: LIST
18177: PUSH
18178: LD_INT 2
18180: PUSH
18181: LD_INT 30
18183: PUSH
18184: LD_INT 8
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: PUSH
18191: LD_INT 30
18193: PUSH
18194: LD_INT 7
18196: PUSH
18197: EMPTY
18198: LIST
18199: LIST
18200: PUSH
18201: LD_INT 30
18203: PUSH
18204: LD_INT 11
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PUSH
18211: EMPTY
18212: LIST
18213: LIST
18214: LIST
18215: LIST
18216: PUSH
18217: EMPTY
18218: LIST
18219: LIST
18220: LIST
18221: PPUSH
18222: CALL_OW 69
18226: ST_TO_ADDR
18227: GO 18337
18229: LD_INT 2
18231: DOUBLE
18232: EQUAL
18233: IFTRUE 18237
18235: GO 18314
18237: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18238: LD_ADDR_VAR 0 4
18242: PUSH
18243: LD_INT 22
18245: PUSH
18246: LD_INT 7
18248: PUSH
18249: EMPTY
18250: LIST
18251: LIST
18252: PUSH
18253: LD_INT 23
18255: PUSH
18256: LD_INT 3
18258: PUSH
18259: EMPTY
18260: LIST
18261: LIST
18262: PUSH
18263: LD_INT 2
18265: PUSH
18266: LD_INT 30
18268: PUSH
18269: LD_INT 8
18271: PUSH
18272: EMPTY
18273: LIST
18274: LIST
18275: PUSH
18276: LD_INT 30
18278: PUSH
18279: LD_INT 7
18281: PUSH
18282: EMPTY
18283: LIST
18284: LIST
18285: PUSH
18286: LD_INT 30
18288: PUSH
18289: LD_INT 11
18291: PUSH
18292: EMPTY
18293: LIST
18294: LIST
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: LIST
18300: LIST
18301: PUSH
18302: EMPTY
18303: LIST
18304: LIST
18305: LIST
18306: PPUSH
18307: CALL_OW 69
18311: ST_TO_ADDR
18312: GO 18337
18314: LD_INT 3
18316: DOUBLE
18317: EQUAL
18318: IFTRUE 18322
18320: GO 18336
18322: POP
// labs := [ alien ] ; end ;
18323: LD_ADDR_VAR 0 4
18327: PUSH
18328: LD_INT 1
18330: PUSH
18331: EMPTY
18332: LIST
18333: ST_TO_ADDR
18334: GO 18337
18336: POP
// if not labs then
18337: LD_VAR 0 4
18341: NOT
18342: IFFALSE 18346
// continue ;
18344: GO 18086
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18346: LD_ADDR_VAR 0 5
18350: PUSH
18351: LD_VAR 0 4
18355: PPUSH
18356: LD_EXP 62
18360: PUSH
18361: LD_VAR 0 1
18365: ARRAY
18366: PUSH
18367: LD_INT 1
18369: ARRAY
18370: PPUSH
18371: LD_EXP 62
18375: PUSH
18376: LD_VAR 0 1
18380: ARRAY
18381: PUSH
18382: LD_INT 2
18384: ARRAY
18385: PPUSH
18386: CALL_OW 73
18390: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18391: LD_VAR 0 5
18395: NOT
18396: PUSH
18397: LD_VAR 0 5
18401: PUSH
18402: LD_EXP 69
18406: PUSH
18407: LD_VAR 0 1
18411: ARRAY
18412: NONEQUAL
18413: OR
18414: IFFALSE 18519
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18416: LD_INT 7
18418: PPUSH
18419: LD_EXP 70
18423: PUSH
18424: LD_VAR 0 1
18428: ARRAY
18429: PUSH
18430: LD_INT 3
18432: ARRAY
18433: PPUSH
18434: LD_INT 0
18436: PPUSH
18437: LD_EXP 69
18441: PUSH
18442: LD_VAR 0 1
18446: ARRAY
18447: PPUSH
18448: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18452: LD_INT 7
18454: PPUSH
18455: LD_EXP 70
18459: PUSH
18460: LD_VAR 0 1
18464: ARRAY
18465: PUSH
18466: LD_INT 1
18468: ARRAY
18469: PPUSH
18470: LD_INT 0
18472: PPUSH
18473: LD_EXP 69
18477: PUSH
18478: LD_VAR 0 1
18482: ARRAY
18483: PPUSH
18484: CALL_OW 468
// if nearestLab then
18488: LD_VAR 0 5
18492: IFFALSE 18519
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18494: LD_ADDR_EXP 69
18498: PUSH
18499: LD_EXP 69
18503: PPUSH
18504: LD_VAR 0 1
18508: PPUSH
18509: LD_VAR 0 5
18513: PPUSH
18514: CALL_OW 1
18518: ST_TO_ADDR
// end ; if not nearestLab then
18519: LD_VAR 0 5
18523: NOT
18524: IFFALSE 18528
// continue ;
18526: GO 18086
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18528: LD_VAR 0 5
18532: PPUSH
18533: LD_EXP 62
18537: PUSH
18538: LD_VAR 0 1
18542: ARRAY
18543: PUSH
18544: LD_INT 1
18546: ARRAY
18547: PPUSH
18548: LD_EXP 62
18552: PUSH
18553: LD_VAR 0 1
18557: ARRAY
18558: PUSH
18559: LD_INT 2
18561: ARRAY
18562: PPUSH
18563: CALL_OW 297
18567: PUSH
18568: LD_INT 8
18570: LESS
18571: IFFALSE 18768
// begin if not artifactsResearched [ i ] then
18573: LD_EXP 65
18577: PUSH
18578: LD_VAR 0 1
18582: ARRAY
18583: NOT
18584: IFFALSE 18665
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18586: LD_VAR 0 5
18590: PPUSH
18591: CALL_OW 461
18595: PUSH
18596: LD_INT 2
18598: EQUAL
18599: IFFALSE 18633
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18601: LD_INT 7
18603: PPUSH
18604: LD_EXP 70
18608: PUSH
18609: LD_VAR 0 1
18613: ARRAY
18614: PUSH
18615: LD_INT 3
18617: ARRAY
18618: PPUSH
18619: LD_INT 2
18621: PPUSH
18622: LD_VAR 0 5
18626: PPUSH
18627: CALL_OW 468
18631: GO 18663
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18633: LD_INT 7
18635: PPUSH
18636: LD_EXP 70
18640: PUSH
18641: LD_VAR 0 1
18645: ARRAY
18646: PUSH
18647: LD_INT 3
18649: ARRAY
18650: PPUSH
18651: LD_INT 1
18653: PPUSH
18654: LD_VAR 0 5
18658: PPUSH
18659: CALL_OW 468
// end else
18663: GO 18766
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18665: LD_VAR 0 5
18669: PPUSH
18670: CALL_OW 461
18674: PUSH
18675: LD_INT 2
18677: EQUAL
18678: PUSH
18679: LD_EXP 71
18683: PUSH
18684: LD_VAR 0 1
18688: ARRAY
18689: AND
18690: IFFALSE 18736
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18692: LD_INT 7
18694: PPUSH
18695: LD_EXP 70
18699: PUSH
18700: LD_VAR 0 1
18704: ARRAY
18705: PUSH
18706: LD_INT 1
18708: ARRAY
18709: PPUSH
18710: LD_EXP 70
18714: PUSH
18715: LD_VAR 0 1
18719: ARRAY
18720: PUSH
18721: LD_INT 2
18723: ARRAY
18724: PPUSH
18725: LD_VAR 0 5
18729: PPUSH
18730: CALL_OW 468
18734: GO 18766
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18736: LD_INT 7
18738: PPUSH
18739: LD_EXP 70
18743: PUSH
18744: LD_VAR 0 1
18748: ARRAY
18749: PUSH
18750: LD_INT 1
18752: ARRAY
18753: PPUSH
18754: LD_INT 1
18756: PPUSH
18757: LD_VAR 0 5
18761: PPUSH
18762: CALL_OW 468
// end else
18766: GO 18843
// begin if not artifactsResearched [ i ] then
18768: LD_EXP 65
18772: PUSH
18773: LD_VAR 0 1
18777: ARRAY
18778: NOT
18779: IFFALSE 18813
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18781: LD_INT 7
18783: PPUSH
18784: LD_EXP 70
18788: PUSH
18789: LD_VAR 0 1
18793: ARRAY
18794: PUSH
18795: LD_INT 3
18797: ARRAY
18798: PPUSH
18799: LD_INT 0
18801: PPUSH
18802: LD_VAR 0 5
18806: PPUSH
18807: CALL_OW 468
18811: GO 18843
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18813: LD_INT 7
18815: PPUSH
18816: LD_EXP 70
18820: PUSH
18821: LD_VAR 0 1
18825: ARRAY
18826: PUSH
18827: LD_INT 1
18829: ARRAY
18830: PPUSH
18831: LD_INT 0
18833: PPUSH
18834: LD_VAR 0 5
18838: PPUSH
18839: CALL_OW 468
// end ; end else
18843: GO 18982
// begin if not artifactsLabs [ i ] then
18845: LD_EXP 69
18849: PUSH
18850: LD_VAR 0 1
18854: ARRAY
18855: NOT
18856: IFFALSE 18860
// continue ;
18858: GO 18086
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18860: LD_INT 7
18862: PPUSH
18863: LD_EXP 70
18867: PUSH
18868: LD_VAR 0 1
18872: ARRAY
18873: PUSH
18874: LD_INT 3
18876: ARRAY
18877: PPUSH
18878: LD_INT 0
18880: PPUSH
18881: LD_EXP 69
18885: PUSH
18886: LD_VAR 0 1
18890: ARRAY
18891: PPUSH
18892: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18896: LD_INT 7
18898: PPUSH
18899: LD_EXP 70
18903: PUSH
18904: LD_VAR 0 1
18908: ARRAY
18909: PUSH
18910: LD_INT 1
18912: ARRAY
18913: PPUSH
18914: LD_INT 0
18916: PPUSH
18917: LD_EXP 69
18921: PUSH
18922: LD_VAR 0 1
18926: ARRAY
18927: PPUSH
18928: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18932: LD_EXP 66
18936: PUSH
18937: LD_VAR 0 1
18941: ARRAY
18942: IFFALSE 18982
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18944: LD_ADDR_EXP 66
18948: PUSH
18949: LD_EXP 66
18953: PPUSH
18954: LD_VAR 0 1
18958: PPUSH
18959: LD_INT 0
18961: PPUSH
18962: CALL_OW 1
18966: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18967: LD_EXP 69
18971: PUSH
18972: LD_VAR 0 1
18976: ARRAY
18977: PPUSH
18978: CALL_OW 127
// end ; end ; end ;
18982: GO 18086
18984: POP
18985: POP
// end ;
18986: PPOPN 5
18988: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18989: LD_INT 0
18991: PPUSH
18992: PPUSH
18993: PPUSH
18994: PPUSH
18995: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18996: LD_VAR 0 2
19000: PUSH
19001: LD_EXP 70
19005: PUSH
19006: LD_INT 1
19008: ARRAY
19009: PUSH
19010: LD_INT 3
19012: ARRAY
19013: EQUAL
19014: IFFALSE 19137
// begin lab := artifactsLabs [ 1 ] ;
19016: LD_ADDR_VAR 0 6
19020: PUSH
19021: LD_EXP 69
19025: PUSH
19026: LD_INT 1
19028: ARRAY
19029: ST_TO_ADDR
// if not lab then
19030: LD_VAR 0 6
19034: NOT
19035: IFFALSE 19039
// exit ;
19037: GO 20117
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19039: LD_VAR 0 6
19043: PPUSH
19044: LD_EXP 67
19048: PUSH
19049: LD_INT 1
19051: ARRAY
19052: PPUSH
19053: LD_INT 1
19055: PPUSH
19056: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19060: LD_EXP 68
19064: PUSH
19065: LD_INT 1
19067: ARRAY
19068: IFFALSE 19088
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19070: LD_VAR 0 6
19074: PPUSH
19075: LD_EXP 68
19079: PUSH
19080: LD_INT 1
19082: ARRAY
19083: PPUSH
19084: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19088: LD_ADDR_EXP 66
19092: PUSH
19093: LD_EXP 66
19097: PPUSH
19098: LD_INT 1
19100: PPUSH
19101: LD_INT 1
19103: PPUSH
19104: CALL_OW 1
19108: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19109: LD_INT 7
19111: PPUSH
19112: LD_EXP 70
19116: PUSH
19117: LD_INT 1
19119: ARRAY
19120: PUSH
19121: LD_INT 3
19123: ARRAY
19124: PPUSH
19125: LD_INT 0
19127: PPUSH
19128: LD_VAR 0 6
19132: PPUSH
19133: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19137: LD_VAR 0 2
19141: PUSH
19142: LD_EXP 70
19146: PUSH
19147: LD_INT 2
19149: ARRAY
19150: PUSH
19151: LD_INT 3
19153: ARRAY
19154: EQUAL
19155: IFFALSE 19278
// begin lab := artifactsLabs [ 2 ] ;
19157: LD_ADDR_VAR 0 6
19161: PUSH
19162: LD_EXP 69
19166: PUSH
19167: LD_INT 2
19169: ARRAY
19170: ST_TO_ADDR
// if not lab then
19171: LD_VAR 0 6
19175: NOT
19176: IFFALSE 19180
// exit ;
19178: GO 20117
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19180: LD_VAR 0 6
19184: PPUSH
19185: LD_EXP 67
19189: PUSH
19190: LD_INT 2
19192: ARRAY
19193: PPUSH
19194: LD_INT 1
19196: PPUSH
19197: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19201: LD_EXP 68
19205: PUSH
19206: LD_INT 2
19208: ARRAY
19209: IFFALSE 19229
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19211: LD_VAR 0 6
19215: PPUSH
19216: LD_EXP 68
19220: PUSH
19221: LD_INT 2
19223: ARRAY
19224: PPUSH
19225: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19229: LD_ADDR_EXP 66
19233: PUSH
19234: LD_EXP 66
19238: PPUSH
19239: LD_INT 2
19241: PPUSH
19242: LD_INT 1
19244: PPUSH
19245: CALL_OW 1
19249: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19250: LD_INT 7
19252: PPUSH
19253: LD_EXP 70
19257: PUSH
19258: LD_INT 2
19260: ARRAY
19261: PUSH
19262: LD_INT 3
19264: ARRAY
19265: PPUSH
19266: LD_INT 0
19268: PPUSH
19269: LD_VAR 0 6
19273: PPUSH
19274: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19278: LD_VAR 0 2
19282: PUSH
19283: LD_EXP 70
19287: PUSH
19288: LD_INT 3
19290: ARRAY
19291: PUSH
19292: LD_INT 3
19294: ARRAY
19295: EQUAL
19296: IFFALSE 19419
// begin lab := artifactsLabs [ 3 ] ;
19298: LD_ADDR_VAR 0 6
19302: PUSH
19303: LD_EXP 69
19307: PUSH
19308: LD_INT 3
19310: ARRAY
19311: ST_TO_ADDR
// if not lab then
19312: LD_VAR 0 6
19316: NOT
19317: IFFALSE 19321
// exit ;
19319: GO 20117
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19321: LD_VAR 0 6
19325: PPUSH
19326: LD_EXP 67
19330: PUSH
19331: LD_INT 3
19333: ARRAY
19334: PPUSH
19335: LD_INT 1
19337: PPUSH
19338: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19342: LD_EXP 68
19346: PUSH
19347: LD_INT 3
19349: ARRAY
19350: IFFALSE 19370
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19352: LD_VAR 0 6
19356: PPUSH
19357: LD_EXP 68
19361: PUSH
19362: LD_INT 3
19364: ARRAY
19365: PPUSH
19366: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19370: LD_ADDR_EXP 66
19374: PUSH
19375: LD_EXP 66
19379: PPUSH
19380: LD_INT 3
19382: PPUSH
19383: LD_INT 1
19385: PPUSH
19386: CALL_OW 1
19390: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19391: LD_INT 7
19393: PPUSH
19394: LD_EXP 70
19398: PUSH
19399: LD_INT 3
19401: ARRAY
19402: PUSH
19403: LD_INT 3
19405: ARRAY
19406: PPUSH
19407: LD_INT 0
19409: PPUSH
19410: LD_VAR 0 6
19414: PPUSH
19415: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19419: LD_VAR 0 2
19423: PUSH
19424: LD_EXP 70
19428: PUSH
19429: LD_INT 1
19431: ARRAY
19432: PUSH
19433: LD_INT 1
19435: ARRAY
19436: EQUAL
19437: IFFALSE 19595
// begin lab := artifactsLabs [ 1 ] ;
19439: LD_ADDR_VAR 0 6
19443: PUSH
19444: LD_EXP 69
19448: PUSH
19449: LD_INT 1
19451: ARRAY
19452: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19453: LD_VAR 0 6
19457: PPUSH
19458: CALL_OW 274
19462: PPUSH
19463: CALL 86771 0 1
19467: PUSH
19468: LD_INT 3
19470: ARRAY
19471: PUSH
19472: LD_EXP 64
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: LESS
19481: IFFALSE 19495
// begin HintSpec ( ArtifactCost , 2 ) ;
19483: LD_STRING ArtifactCost
19485: PPUSH
19486: LD_INT 2
19488: PPUSH
19489: CALL_OW 338
// exit ;
19493: GO 20117
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19495: LD_ADDR_EXP 71
19499: PUSH
19500: LD_EXP 71
19504: PPUSH
19505: LD_INT 1
19507: PPUSH
19508: LD_INT 0
19510: PPUSH
19511: CALL_OW 1
19515: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19516: LD_VAR 0 3
19520: PPUSH
19521: LD_VAR 0 4
19525: PPUSH
19526: LD_INT 7
19528: PPUSH
19529: LD_INT 12
19531: NEG
19532: PPUSH
19533: CALL_OW 330
// wait ( 0 0$30 ) ;
19537: LD_INT 1050
19539: PPUSH
19540: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19544: LD_VAR 0 3
19548: PPUSH
19549: LD_VAR 0 4
19553: PPUSH
19554: LD_INT 7
19556: PPUSH
19557: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19561: LD_EXP 63
19565: PUSH
19566: LD_INT 1
19568: ARRAY
19569: PPUSH
19570: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19574: LD_ADDR_EXP 71
19578: PUSH
19579: LD_EXP 71
19583: PPUSH
19584: LD_INT 1
19586: PPUSH
19587: LD_INT 1
19589: PPUSH
19590: CALL_OW 1
19594: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19595: LD_VAR 0 2
19599: PUSH
19600: LD_EXP 70
19604: PUSH
19605: LD_INT 2
19607: ARRAY
19608: PUSH
19609: LD_INT 1
19611: ARRAY
19612: EQUAL
19613: IFFALSE 19850
// begin lab := artifactsLabs [ 2 ] ;
19615: LD_ADDR_VAR 0 6
19619: PUSH
19620: LD_EXP 69
19624: PUSH
19625: LD_INT 2
19627: ARRAY
19628: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19629: LD_VAR 0 3
19633: PUSH
19634: LD_INT 81
19636: PUSH
19637: LD_INT 7
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: PUSH
19644: LD_INT 2
19646: PUSH
19647: LD_INT 32
19649: PUSH
19650: LD_INT 3
19652: PUSH
19653: EMPTY
19654: LIST
19655: LIST
19656: PUSH
19657: LD_INT 30
19659: PUSH
19660: LD_INT 28
19662: PUSH
19663: EMPTY
19664: LIST
19665: LIST
19666: PUSH
19667: LD_INT 30
19669: PUSH
19670: LD_INT 30
19672: PUSH
19673: EMPTY
19674: LIST
19675: LIST
19676: PUSH
19677: LD_INT 35
19679: PUSH
19680: LD_INT 49
19682: PUSH
19683: EMPTY
19684: LIST
19685: LIST
19686: PUSH
19687: LD_INT 34
19689: PUSH
19690: LD_INT 49
19692: PUSH
19693: EMPTY
19694: LIST
19695: LIST
19696: PUSH
19697: LD_INT 30
19699: PUSH
19700: LD_INT 21
19702: PUSH
19703: EMPTY
19704: LIST
19705: LIST
19706: PUSH
19707: EMPTY
19708: LIST
19709: LIST
19710: LIST
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: PUSH
19716: EMPTY
19717: LIST
19718: LIST
19719: PPUSH
19720: CALL_OW 69
19724: IN
19725: NOT
19726: IFFALSE 19730
// exit ;
19728: GO 20117
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19730: LD_VAR 0 6
19734: PPUSH
19735: CALL_OW 274
19739: PPUSH
19740: CALL 86771 0 1
19744: PUSH
19745: LD_INT 3
19747: ARRAY
19748: PUSH
19749: LD_EXP 64
19753: PUSH
19754: LD_INT 2
19756: ARRAY
19757: LESS
19758: IFFALSE 19772
// begin HintSpec ( ArtifactCost , 2 ) ;
19760: LD_STRING ArtifactCost
19762: PPUSH
19763: LD_INT 2
19765: PPUSH
19766: CALL_OW 338
// exit ;
19770: GO 20117
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19772: LD_ADDR_EXP 71
19776: PUSH
19777: LD_EXP 71
19781: PPUSH
19782: LD_INT 2
19784: PPUSH
19785: LD_INT 0
19787: PPUSH
19788: CALL_OW 1
19792: ST_TO_ADDR
// KillUnit ( x ) ;
19793: LD_VAR 0 3
19797: PPUSH
19798: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19802: LD_ADDR_EXP 16
19806: PUSH
19807: LD_EXP 16
19811: PUSH
19812: LD_INT 1
19814: PLUS
19815: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19816: LD_EXP 63
19820: PUSH
19821: LD_INT 2
19823: ARRAY
19824: PPUSH
19825: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19829: LD_ADDR_EXP 71
19833: PUSH
19834: LD_EXP 71
19838: PPUSH
19839: LD_INT 2
19841: PPUSH
19842: LD_INT 1
19844: PPUSH
19845: CALL_OW 1
19849: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19850: LD_VAR 0 2
19854: PUSH
19855: LD_EXP 70
19859: PUSH
19860: LD_INT 3
19862: ARRAY
19863: PUSH
19864: LD_INT 1
19866: ARRAY
19867: EQUAL
19868: IFFALSE 20117
// begin lab := artifactsLabs [ 3 ] ;
19870: LD_ADDR_VAR 0 6
19874: PUSH
19875: LD_EXP 69
19879: PUSH
19880: LD_INT 3
19882: ARRAY
19883: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19884: LD_VAR 0 6
19888: PPUSH
19889: CALL_OW 274
19893: PPUSH
19894: CALL 86771 0 1
19898: PUSH
19899: LD_INT 3
19901: ARRAY
19902: PUSH
19903: LD_EXP 64
19907: PUSH
19908: LD_INT 3
19910: ARRAY
19911: LESS
19912: IFFALSE 19926
// begin HintSpec ( ArtifactCost , 2 ) ;
19914: LD_STRING ArtifactCost
19916: PPUSH
19917: LD_INT 2
19919: PPUSH
19920: CALL_OW 338
// exit ;
19924: GO 20117
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19926: LD_INT 37
19928: PPUSH
19929: LD_INT 1
19931: PPUSH
19932: CALL_OW 424
// time := 0 0$30 ;
19936: LD_ADDR_VAR 0 7
19940: PUSH
19941: LD_INT 1050
19943: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
19944: LD_ADDR_EXP 71
19948: PUSH
19949: LD_EXP 71
19953: PPUSH
19954: LD_INT 3
19956: PPUSH
19957: LD_INT 0
19959: PPUSH
19960: CALL_OW 1
19964: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
19965: LD_ADDR_OWVAR 47
19969: PUSH
19970: LD_STRING #Am15a-1
19972: PUSH
19973: LD_VAR 0 7
19977: PUSH
19978: EMPTY
19979: LIST
19980: LIST
19981: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19982: LD_INT 35
19984: PPUSH
19985: CALL_OW 67
// time := time - 0 0$1 ;
19989: LD_ADDR_VAR 0 7
19993: PUSH
19994: LD_VAR 0 7
19998: PUSH
19999: LD_INT 35
20001: MINUS
20002: ST_TO_ADDR
// until time = 0 0$00 ;
20003: LD_VAR 0 7
20007: PUSH
20008: LD_INT 0
20010: EQUAL
20011: IFFALSE 19965
// display_strings :=  ;
20013: LD_ADDR_OWVAR 47
20017: PUSH
20018: LD_STRING 
20020: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20021: LD_INT 37
20023: PPUSH
20024: LD_INT 0
20026: PPUSH
20027: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20031: LD_ADDR_VAR 0 8
20035: PUSH
20036: LD_INT 37
20038: PPUSH
20039: LD_INT 3
20041: PUSH
20042: LD_INT 21
20044: PUSH
20045: LD_INT 3
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: PUSH
20052: EMPTY
20053: LIST
20054: LIST
20055: PPUSH
20056: CALL_OW 70
20060: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20061: LD_VAR 0 3
20065: PPUSH
20066: LD_VAR 0 4
20070: PPUSH
20071: CALL_OW 84
// for un in list do
20075: LD_ADDR_VAR 0 9
20079: PUSH
20080: LD_VAR 0 8
20084: PUSH
20085: FOR_IN
20086: IFFALSE 20115
// TeleportUnit ( un , x , y , 12 , true ) ;
20088: LD_VAR 0 9
20092: PPUSH
20093: LD_VAR 0 3
20097: PPUSH
20098: LD_VAR 0 4
20102: PPUSH
20103: LD_INT 12
20105: PPUSH
20106: LD_INT 1
20108: PPUSH
20109: CALL_OW 483
20113: GO 20085
20115: POP
20116: POP
// end ; end ;
20117: PPOPN 9
20119: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20120: LD_INT 0
20122: PPUSH
20123: PPUSH
// begin labNum := 0 ;
20124: LD_ADDR_VAR 0 4
20128: PUSH
20129: LD_INT 0
20131: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20132: LD_ADDR_VAR 0 3
20136: PUSH
20137: DOUBLE
20138: LD_INT 1
20140: DEC
20141: ST_TO_ADDR
20142: LD_EXP 69
20146: PUSH
20147: FOR_TO
20148: IFFALSE 20182
// if artifactsLabs [ i ] = lab then
20150: LD_EXP 69
20154: PUSH
20155: LD_VAR 0 3
20159: ARRAY
20160: PUSH
20161: LD_VAR 0 1
20165: EQUAL
20166: IFFALSE 20180
// begin labNum := i ;
20168: LD_ADDR_VAR 0 4
20172: PUSH
20173: LD_VAR 0 3
20177: ST_TO_ADDR
// break ;
20178: GO 20182
// end ;
20180: GO 20147
20182: POP
20183: POP
// if not labNum then
20184: LD_VAR 0 4
20188: NOT
20189: IFFALSE 20193
// exit ;
20191: GO 20271
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20193: LD_INT 7
20195: PPUSH
20196: LD_EXP 70
20200: PUSH
20201: LD_VAR 0 4
20205: ARRAY
20206: PUSH
20207: LD_INT 3
20209: ARRAY
20210: PPUSH
20211: LD_INT 2
20213: PPUSH
20214: LD_VAR 0 1
20218: PPUSH
20219: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20223: LD_ADDR_EXP 68
20227: PUSH
20228: LD_EXP 68
20232: PPUSH
20233: LD_VAR 0 4
20237: PPUSH
20238: LD_VAR 0 2
20242: PPUSH
20243: CALL_OW 1
20247: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20248: LD_ADDR_EXP 66
20252: PUSH
20253: LD_EXP 66
20257: PPUSH
20258: LD_VAR 0 4
20262: PPUSH
20263: LD_INT 0
20265: PPUSH
20266: CALL_OW 1
20270: ST_TO_ADDR
// end ;
20271: PPOPN 4
20273: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20274: LD_INT 0
20276: PPUSH
20277: PPUSH
// begin labNum := 0 ;
20278: LD_ADDR_VAR 0 3
20282: PUSH
20283: LD_INT 0
20285: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20286: LD_ADDR_VAR 0 2
20290: PUSH
20291: DOUBLE
20292: LD_INT 1
20294: DEC
20295: ST_TO_ADDR
20296: LD_EXP 69
20300: PUSH
20301: FOR_TO
20302: IFFALSE 20336
// if artifactsLabs [ i ] = lab then
20304: LD_EXP 69
20308: PUSH
20309: LD_VAR 0 2
20313: ARRAY
20314: PUSH
20315: LD_VAR 0 1
20319: EQUAL
20320: IFFALSE 20334
// begin labNum := i ;
20322: LD_ADDR_VAR 0 3
20326: PUSH
20327: LD_VAR 0 2
20331: ST_TO_ADDR
// break ;
20332: GO 20336
// end ;
20334: GO 20301
20336: POP
20337: POP
// if not labNum then
20338: LD_VAR 0 3
20342: NOT
20343: IFFALSE 20347
// exit ;
20345: GO 20509
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20347: LD_INT 7
20349: PPUSH
20350: LD_EXP 70
20354: PUSH
20355: LD_VAR 0 3
20359: ARRAY
20360: PUSH
20361: LD_INT 3
20363: ARRAY
20364: PPUSH
20365: LD_INT 0
20367: PPUSH
20368: LD_VAR 0 1
20372: PPUSH
20373: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20377: LD_ADDR_EXP 65
20381: PUSH
20382: LD_EXP 65
20386: PPUSH
20387: LD_VAR 0 3
20391: PPUSH
20392: LD_INT 1
20394: PPUSH
20395: CALL_OW 1
20399: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20400: LD_ADDR_EXP 71
20404: PUSH
20405: LD_EXP 71
20409: PPUSH
20410: LD_VAR 0 3
20414: PPUSH
20415: LD_INT 1
20417: PPUSH
20418: CALL_OW 1
20422: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20423: LD_ADDR_EXP 66
20427: PUSH
20428: LD_EXP 66
20432: PPUSH
20433: LD_VAR 0 3
20437: PPUSH
20438: LD_INT 0
20440: PPUSH
20441: CALL_OW 1
20445: ST_TO_ADDR
// case labNum of 1 :
20446: LD_VAR 0 3
20450: PUSH
20451: LD_INT 1
20453: DOUBLE
20454: EQUAL
20455: IFTRUE 20459
20457: GO 20470
20459: POP
// artifactIResearched := true ; 2 :
20460: LD_ADDR_EXP 12
20464: PUSH
20465: LD_INT 1
20467: ST_TO_ADDR
20468: GO 20509
20470: LD_INT 2
20472: DOUBLE
20473: EQUAL
20474: IFTRUE 20478
20476: GO 20489
20478: POP
// artifactIIResearched := true ; 3 :
20479: LD_ADDR_EXP 13
20483: PUSH
20484: LD_INT 1
20486: ST_TO_ADDR
20487: GO 20509
20489: LD_INT 3
20491: DOUBLE
20492: EQUAL
20493: IFTRUE 20497
20495: GO 20508
20497: POP
// artifactIIIResearched := true ; end ;
20498: LD_ADDR_EXP 14
20502: PUSH
20503: LD_INT 1
20505: ST_TO_ADDR
20506: GO 20509
20508: POP
// end ; end_of_file
20509: PPOPN 3
20511: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
20512: LD_INT 0
20514: PPUSH
// ar_crane := 88 ;
20515: LD_ADDR_EXP 78
20519: PUSH
20520: LD_INT 88
20522: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20523: LD_ADDR_EXP 73
20527: PUSH
20528: LD_INT 89
20530: ST_TO_ADDR
// us_hack := 99 ;
20531: LD_ADDR_EXP 74
20535: PUSH
20536: LD_INT 99
20538: ST_TO_ADDR
// us_artillery := 97 ;
20539: LD_ADDR_EXP 75
20543: PUSH
20544: LD_INT 97
20546: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20547: LD_ADDR_EXP 76
20551: PUSH
20552: LD_INT 91
20554: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
20555: LD_ADDR_EXP 77
20559: PUSH
20560: LD_INT 92
20562: ST_TO_ADDR
// ru_radar := 98 ;
20563: LD_ADDR_EXP 72
20567: PUSH
20568: LD_INT 98
20570: ST_TO_ADDR
// tech_Artillery := 80 ;
20571: LD_ADDR_EXP 79
20575: PUSH
20576: LD_INT 80
20578: ST_TO_ADDR
// tech_RadMat := 81 ;
20579: LD_ADDR_EXP 80
20583: PUSH
20584: LD_INT 81
20586: ST_TO_ADDR
// tech_BasicTools := 82 ;
20587: LD_ADDR_EXP 81
20591: PUSH
20592: LD_INT 82
20594: ST_TO_ADDR
// tech_Cargo := 83 ;
20595: LD_ADDR_EXP 82
20599: PUSH
20600: LD_INT 83
20602: ST_TO_ADDR
// tech_Track := 84 ;
20603: LD_ADDR_EXP 83
20607: PUSH
20608: LD_INT 84
20610: ST_TO_ADDR
// tech_Crane := 85 ;
20611: LD_ADDR_EXP 84
20615: PUSH
20616: LD_INT 85
20618: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20619: LD_ADDR_EXP 85
20623: PUSH
20624: LD_INT 86
20626: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20627: LD_ADDR_EXP 86
20631: PUSH
20632: LD_INT 87
20634: ST_TO_ADDR
// end ;
20635: LD_VAR 0 1
20639: RET
// every 1 do
20640: GO 20642
20642: DISABLE
// InitGlobalVariables ; end_of_file
20643: CALL 20512 0 0
20647: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20648: LD_INT 0
20650: PPUSH
20651: PPUSH
// skirmish := false ;
20652: LD_ADDR_EXP 87
20656: PUSH
20657: LD_INT 0
20659: ST_TO_ADDR
// debug_mc := false ;
20660: LD_ADDR_EXP 88
20664: PUSH
20665: LD_INT 0
20667: ST_TO_ADDR
// mc_bases := [ ] ;
20668: LD_ADDR_EXP 89
20672: PUSH
20673: EMPTY
20674: ST_TO_ADDR
// mc_sides := [ ] ;
20675: LD_ADDR_EXP 115
20679: PUSH
20680: EMPTY
20681: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20682: LD_ADDR_EXP 90
20686: PUSH
20687: EMPTY
20688: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20689: LD_ADDR_EXP 91
20693: PUSH
20694: EMPTY
20695: ST_TO_ADDR
// mc_need_heal := [ ] ;
20696: LD_ADDR_EXP 92
20700: PUSH
20701: EMPTY
20702: ST_TO_ADDR
// mc_healers := [ ] ;
20703: LD_ADDR_EXP 93
20707: PUSH
20708: EMPTY
20709: ST_TO_ADDR
// mc_build_list := [ ] ;
20710: LD_ADDR_EXP 94
20714: PUSH
20715: EMPTY
20716: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20717: LD_ADDR_EXP 121
20721: PUSH
20722: EMPTY
20723: ST_TO_ADDR
// mc_builders := [ ] ;
20724: LD_ADDR_EXP 95
20728: PUSH
20729: EMPTY
20730: ST_TO_ADDR
// mc_construct_list := [ ] ;
20731: LD_ADDR_EXP 96
20735: PUSH
20736: EMPTY
20737: ST_TO_ADDR
// mc_turret_list := [ ] ;
20738: LD_ADDR_EXP 97
20742: PUSH
20743: EMPTY
20744: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20745: LD_ADDR_EXP 98
20749: PUSH
20750: EMPTY
20751: ST_TO_ADDR
// mc_miners := [ ] ;
20752: LD_ADDR_EXP 103
20756: PUSH
20757: EMPTY
20758: ST_TO_ADDR
// mc_mines := [ ] ;
20759: LD_ADDR_EXP 102
20763: PUSH
20764: EMPTY
20765: ST_TO_ADDR
// mc_minefields := [ ] ;
20766: LD_ADDR_EXP 104
20770: PUSH
20771: EMPTY
20772: ST_TO_ADDR
// mc_crates := [ ] ;
20773: LD_ADDR_EXP 105
20777: PUSH
20778: EMPTY
20779: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20780: LD_ADDR_EXP 106
20784: PUSH
20785: EMPTY
20786: ST_TO_ADDR
// mc_crates_area := [ ] ;
20787: LD_ADDR_EXP 107
20791: PUSH
20792: EMPTY
20793: ST_TO_ADDR
// mc_vehicles := [ ] ;
20794: LD_ADDR_EXP 108
20798: PUSH
20799: EMPTY
20800: ST_TO_ADDR
// mc_attack := [ ] ;
20801: LD_ADDR_EXP 109
20805: PUSH
20806: EMPTY
20807: ST_TO_ADDR
// mc_produce := [ ] ;
20808: LD_ADDR_EXP 110
20812: PUSH
20813: EMPTY
20814: ST_TO_ADDR
// mc_defender := [ ] ;
20815: LD_ADDR_EXP 111
20819: PUSH
20820: EMPTY
20821: ST_TO_ADDR
// mc_parking := [ ] ;
20822: LD_ADDR_EXP 113
20826: PUSH
20827: EMPTY
20828: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20829: LD_ADDR_EXP 99
20833: PUSH
20834: EMPTY
20835: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20836: LD_ADDR_EXP 101
20840: PUSH
20841: EMPTY
20842: ST_TO_ADDR
// mc_scan := [ ] ;
20843: LD_ADDR_EXP 112
20847: PUSH
20848: EMPTY
20849: ST_TO_ADDR
// mc_scan_area := [ ] ;
20850: LD_ADDR_EXP 114
20854: PUSH
20855: EMPTY
20856: ST_TO_ADDR
// mc_tech := [ ] ;
20857: LD_ADDR_EXP 116
20861: PUSH
20862: EMPTY
20863: ST_TO_ADDR
// mc_class := [ ] ;
20864: LD_ADDR_EXP 130
20868: PUSH
20869: EMPTY
20870: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20871: LD_ADDR_EXP 131
20875: PUSH
20876: EMPTY
20877: ST_TO_ADDR
// end ;
20878: LD_VAR 0 1
20882: RET
// export function MC_Kill ( base ) ; begin
20883: LD_INT 0
20885: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20886: LD_ADDR_EXP 89
20890: PUSH
20891: LD_EXP 89
20895: PPUSH
20896: LD_VAR 0 1
20900: PPUSH
20901: EMPTY
20902: PPUSH
20903: CALL_OW 1
20907: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20908: LD_ADDR_EXP 90
20912: PUSH
20913: LD_EXP 90
20917: PPUSH
20918: LD_VAR 0 1
20922: PPUSH
20923: EMPTY
20924: PPUSH
20925: CALL_OW 1
20929: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20930: LD_ADDR_EXP 91
20934: PUSH
20935: LD_EXP 91
20939: PPUSH
20940: LD_VAR 0 1
20944: PPUSH
20945: EMPTY
20946: PPUSH
20947: CALL_OW 1
20951: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20952: LD_ADDR_EXP 92
20956: PUSH
20957: LD_EXP 92
20961: PPUSH
20962: LD_VAR 0 1
20966: PPUSH
20967: EMPTY
20968: PPUSH
20969: CALL_OW 1
20973: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20974: LD_ADDR_EXP 93
20978: PUSH
20979: LD_EXP 93
20983: PPUSH
20984: LD_VAR 0 1
20988: PPUSH
20989: EMPTY
20990: PPUSH
20991: CALL_OW 1
20995: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20996: LD_ADDR_EXP 94
21000: PUSH
21001: LD_EXP 94
21005: PPUSH
21006: LD_VAR 0 1
21010: PPUSH
21011: EMPTY
21012: PPUSH
21013: CALL_OW 1
21017: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21018: LD_ADDR_EXP 95
21022: PUSH
21023: LD_EXP 95
21027: PPUSH
21028: LD_VAR 0 1
21032: PPUSH
21033: EMPTY
21034: PPUSH
21035: CALL_OW 1
21039: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21040: LD_ADDR_EXP 96
21044: PUSH
21045: LD_EXP 96
21049: PPUSH
21050: LD_VAR 0 1
21054: PPUSH
21055: EMPTY
21056: PPUSH
21057: CALL_OW 1
21061: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21062: LD_ADDR_EXP 97
21066: PUSH
21067: LD_EXP 97
21071: PPUSH
21072: LD_VAR 0 1
21076: PPUSH
21077: EMPTY
21078: PPUSH
21079: CALL_OW 1
21083: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21084: LD_ADDR_EXP 98
21088: PUSH
21089: LD_EXP 98
21093: PPUSH
21094: LD_VAR 0 1
21098: PPUSH
21099: EMPTY
21100: PPUSH
21101: CALL_OW 1
21105: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21106: LD_ADDR_EXP 99
21110: PUSH
21111: LD_EXP 99
21115: PPUSH
21116: LD_VAR 0 1
21120: PPUSH
21121: EMPTY
21122: PPUSH
21123: CALL_OW 1
21127: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21128: LD_ADDR_EXP 100
21132: PUSH
21133: LD_EXP 100
21137: PPUSH
21138: LD_VAR 0 1
21142: PPUSH
21143: LD_INT 0
21145: PPUSH
21146: CALL_OW 1
21150: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21151: LD_ADDR_EXP 101
21155: PUSH
21156: LD_EXP 101
21160: PPUSH
21161: LD_VAR 0 1
21165: PPUSH
21166: EMPTY
21167: PPUSH
21168: CALL_OW 1
21172: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21173: LD_ADDR_EXP 102
21177: PUSH
21178: LD_EXP 102
21182: PPUSH
21183: LD_VAR 0 1
21187: PPUSH
21188: EMPTY
21189: PPUSH
21190: CALL_OW 1
21194: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21195: LD_ADDR_EXP 103
21199: PUSH
21200: LD_EXP 103
21204: PPUSH
21205: LD_VAR 0 1
21209: PPUSH
21210: EMPTY
21211: PPUSH
21212: CALL_OW 1
21216: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21217: LD_ADDR_EXP 104
21221: PUSH
21222: LD_EXP 104
21226: PPUSH
21227: LD_VAR 0 1
21231: PPUSH
21232: EMPTY
21233: PPUSH
21234: CALL_OW 1
21238: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21239: LD_ADDR_EXP 105
21243: PUSH
21244: LD_EXP 105
21248: PPUSH
21249: LD_VAR 0 1
21253: PPUSH
21254: EMPTY
21255: PPUSH
21256: CALL_OW 1
21260: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21261: LD_ADDR_EXP 106
21265: PUSH
21266: LD_EXP 106
21270: PPUSH
21271: LD_VAR 0 1
21275: PPUSH
21276: EMPTY
21277: PPUSH
21278: CALL_OW 1
21282: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21283: LD_ADDR_EXP 107
21287: PUSH
21288: LD_EXP 107
21292: PPUSH
21293: LD_VAR 0 1
21297: PPUSH
21298: EMPTY
21299: PPUSH
21300: CALL_OW 1
21304: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21305: LD_ADDR_EXP 108
21309: PUSH
21310: LD_EXP 108
21314: PPUSH
21315: LD_VAR 0 1
21319: PPUSH
21320: EMPTY
21321: PPUSH
21322: CALL_OW 1
21326: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21327: LD_ADDR_EXP 109
21331: PUSH
21332: LD_EXP 109
21336: PPUSH
21337: LD_VAR 0 1
21341: PPUSH
21342: EMPTY
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21349: LD_ADDR_EXP 110
21353: PUSH
21354: LD_EXP 110
21358: PPUSH
21359: LD_VAR 0 1
21363: PPUSH
21364: EMPTY
21365: PPUSH
21366: CALL_OW 1
21370: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21371: LD_ADDR_EXP 111
21375: PUSH
21376: LD_EXP 111
21380: PPUSH
21381: LD_VAR 0 1
21385: PPUSH
21386: EMPTY
21387: PPUSH
21388: CALL_OW 1
21392: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21393: LD_ADDR_EXP 112
21397: PUSH
21398: LD_EXP 112
21402: PPUSH
21403: LD_VAR 0 1
21407: PPUSH
21408: EMPTY
21409: PPUSH
21410: CALL_OW 1
21414: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21415: LD_ADDR_EXP 113
21419: PUSH
21420: LD_EXP 113
21424: PPUSH
21425: LD_VAR 0 1
21429: PPUSH
21430: EMPTY
21431: PPUSH
21432: CALL_OW 1
21436: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21437: LD_ADDR_EXP 114
21441: PUSH
21442: LD_EXP 114
21446: PPUSH
21447: LD_VAR 0 1
21451: PPUSH
21452: EMPTY
21453: PPUSH
21454: CALL_OW 1
21458: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21459: LD_ADDR_EXP 116
21463: PUSH
21464: LD_EXP 116
21468: PPUSH
21469: LD_VAR 0 1
21473: PPUSH
21474: EMPTY
21475: PPUSH
21476: CALL_OW 1
21480: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21481: LD_ADDR_EXP 118
21485: PUSH
21486: LD_EXP 118
21490: PPUSH
21491: LD_VAR 0 1
21495: PPUSH
21496: EMPTY
21497: PPUSH
21498: CALL_OW 1
21502: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21503: LD_ADDR_EXP 119
21507: PUSH
21508: LD_EXP 119
21512: PPUSH
21513: LD_VAR 0 1
21517: PPUSH
21518: EMPTY
21519: PPUSH
21520: CALL_OW 1
21524: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21525: LD_ADDR_EXP 120
21529: PUSH
21530: LD_EXP 120
21534: PPUSH
21535: LD_VAR 0 1
21539: PPUSH
21540: EMPTY
21541: PPUSH
21542: CALL_OW 1
21546: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21547: LD_ADDR_EXP 121
21551: PUSH
21552: LD_EXP 121
21556: PPUSH
21557: LD_VAR 0 1
21561: PPUSH
21562: EMPTY
21563: PPUSH
21564: CALL_OW 1
21568: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21569: LD_ADDR_EXP 122
21573: PUSH
21574: LD_EXP 122
21578: PPUSH
21579: LD_VAR 0 1
21583: PPUSH
21584: EMPTY
21585: PPUSH
21586: CALL_OW 1
21590: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21591: LD_ADDR_EXP 123
21595: PUSH
21596: LD_EXP 123
21600: PPUSH
21601: LD_VAR 0 1
21605: PPUSH
21606: EMPTY
21607: PPUSH
21608: CALL_OW 1
21612: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21613: LD_ADDR_EXP 124
21617: PUSH
21618: LD_EXP 124
21622: PPUSH
21623: LD_VAR 0 1
21627: PPUSH
21628: EMPTY
21629: PPUSH
21630: CALL_OW 1
21634: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21635: LD_ADDR_EXP 125
21639: PUSH
21640: LD_EXP 125
21644: PPUSH
21645: LD_VAR 0 1
21649: PPUSH
21650: EMPTY
21651: PPUSH
21652: CALL_OW 1
21656: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21657: LD_ADDR_EXP 126
21661: PUSH
21662: LD_EXP 126
21666: PPUSH
21667: LD_VAR 0 1
21671: PPUSH
21672: EMPTY
21673: PPUSH
21674: CALL_OW 1
21678: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21679: LD_ADDR_EXP 127
21683: PUSH
21684: LD_EXP 127
21688: PPUSH
21689: LD_VAR 0 1
21693: PPUSH
21694: EMPTY
21695: PPUSH
21696: CALL_OW 1
21700: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21701: LD_ADDR_EXP 128
21705: PUSH
21706: LD_EXP 128
21710: PPUSH
21711: LD_VAR 0 1
21715: PPUSH
21716: EMPTY
21717: PPUSH
21718: CALL_OW 1
21722: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21723: LD_ADDR_EXP 129
21727: PUSH
21728: LD_EXP 129
21732: PPUSH
21733: LD_VAR 0 1
21737: PPUSH
21738: EMPTY
21739: PPUSH
21740: CALL_OW 1
21744: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21745: LD_ADDR_EXP 130
21749: PUSH
21750: LD_EXP 130
21754: PPUSH
21755: LD_VAR 0 1
21759: PPUSH
21760: EMPTY
21761: PPUSH
21762: CALL_OW 1
21766: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21767: LD_ADDR_EXP 131
21771: PUSH
21772: LD_EXP 131
21776: PPUSH
21777: LD_VAR 0 1
21781: PPUSH
21782: LD_INT 0
21784: PPUSH
21785: CALL_OW 1
21789: ST_TO_ADDR
// end ;
21790: LD_VAR 0 2
21794: RET
// export function MC_Add ( side , units ) ; var base ; begin
21795: LD_INT 0
21797: PPUSH
21798: PPUSH
// base := mc_bases + 1 ;
21799: LD_ADDR_VAR 0 4
21803: PUSH
21804: LD_EXP 89
21808: PUSH
21809: LD_INT 1
21811: PLUS
21812: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21813: LD_ADDR_EXP 115
21817: PUSH
21818: LD_EXP 115
21822: PPUSH
21823: LD_VAR 0 4
21827: PPUSH
21828: LD_VAR 0 1
21832: PPUSH
21833: CALL_OW 1
21837: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21838: LD_ADDR_EXP 89
21842: PUSH
21843: LD_EXP 89
21847: PPUSH
21848: LD_VAR 0 4
21852: PPUSH
21853: LD_VAR 0 2
21857: PPUSH
21858: CALL_OW 1
21862: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21863: LD_ADDR_EXP 90
21867: PUSH
21868: LD_EXP 90
21872: PPUSH
21873: LD_VAR 0 4
21877: PPUSH
21878: EMPTY
21879: PPUSH
21880: CALL_OW 1
21884: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21885: LD_ADDR_EXP 91
21889: PUSH
21890: LD_EXP 91
21894: PPUSH
21895: LD_VAR 0 4
21899: PPUSH
21900: EMPTY
21901: PPUSH
21902: CALL_OW 1
21906: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21907: LD_ADDR_EXP 92
21911: PUSH
21912: LD_EXP 92
21916: PPUSH
21917: LD_VAR 0 4
21921: PPUSH
21922: EMPTY
21923: PPUSH
21924: CALL_OW 1
21928: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21929: LD_ADDR_EXP 93
21933: PUSH
21934: LD_EXP 93
21938: PPUSH
21939: LD_VAR 0 4
21943: PPUSH
21944: EMPTY
21945: PPUSH
21946: CALL_OW 1
21950: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21951: LD_ADDR_EXP 94
21955: PUSH
21956: LD_EXP 94
21960: PPUSH
21961: LD_VAR 0 4
21965: PPUSH
21966: EMPTY
21967: PPUSH
21968: CALL_OW 1
21972: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21973: LD_ADDR_EXP 95
21977: PUSH
21978: LD_EXP 95
21982: PPUSH
21983: LD_VAR 0 4
21987: PPUSH
21988: EMPTY
21989: PPUSH
21990: CALL_OW 1
21994: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21995: LD_ADDR_EXP 96
21999: PUSH
22000: LD_EXP 96
22004: PPUSH
22005: LD_VAR 0 4
22009: PPUSH
22010: EMPTY
22011: PPUSH
22012: CALL_OW 1
22016: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22017: LD_ADDR_EXP 97
22021: PUSH
22022: LD_EXP 97
22026: PPUSH
22027: LD_VAR 0 4
22031: PPUSH
22032: EMPTY
22033: PPUSH
22034: CALL_OW 1
22038: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22039: LD_ADDR_EXP 98
22043: PUSH
22044: LD_EXP 98
22048: PPUSH
22049: LD_VAR 0 4
22053: PPUSH
22054: EMPTY
22055: PPUSH
22056: CALL_OW 1
22060: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22061: LD_ADDR_EXP 99
22065: PUSH
22066: LD_EXP 99
22070: PPUSH
22071: LD_VAR 0 4
22075: PPUSH
22076: EMPTY
22077: PPUSH
22078: CALL_OW 1
22082: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22083: LD_ADDR_EXP 100
22087: PUSH
22088: LD_EXP 100
22092: PPUSH
22093: LD_VAR 0 4
22097: PPUSH
22098: LD_INT 0
22100: PPUSH
22101: CALL_OW 1
22105: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22106: LD_ADDR_EXP 101
22110: PUSH
22111: LD_EXP 101
22115: PPUSH
22116: LD_VAR 0 4
22120: PPUSH
22121: EMPTY
22122: PPUSH
22123: CALL_OW 1
22127: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22128: LD_ADDR_EXP 102
22132: PUSH
22133: LD_EXP 102
22137: PPUSH
22138: LD_VAR 0 4
22142: PPUSH
22143: EMPTY
22144: PPUSH
22145: CALL_OW 1
22149: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22150: LD_ADDR_EXP 103
22154: PUSH
22155: LD_EXP 103
22159: PPUSH
22160: LD_VAR 0 4
22164: PPUSH
22165: EMPTY
22166: PPUSH
22167: CALL_OW 1
22171: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22172: LD_ADDR_EXP 104
22176: PUSH
22177: LD_EXP 104
22181: PPUSH
22182: LD_VAR 0 4
22186: PPUSH
22187: EMPTY
22188: PPUSH
22189: CALL_OW 1
22193: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22194: LD_ADDR_EXP 105
22198: PUSH
22199: LD_EXP 105
22203: PPUSH
22204: LD_VAR 0 4
22208: PPUSH
22209: EMPTY
22210: PPUSH
22211: CALL_OW 1
22215: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22216: LD_ADDR_EXP 106
22220: PUSH
22221: LD_EXP 106
22225: PPUSH
22226: LD_VAR 0 4
22230: PPUSH
22231: EMPTY
22232: PPUSH
22233: CALL_OW 1
22237: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22238: LD_ADDR_EXP 107
22242: PUSH
22243: LD_EXP 107
22247: PPUSH
22248: LD_VAR 0 4
22252: PPUSH
22253: EMPTY
22254: PPUSH
22255: CALL_OW 1
22259: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22260: LD_ADDR_EXP 108
22264: PUSH
22265: LD_EXP 108
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: EMPTY
22276: PPUSH
22277: CALL_OW 1
22281: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22282: LD_ADDR_EXP 109
22286: PUSH
22287: LD_EXP 109
22291: PPUSH
22292: LD_VAR 0 4
22296: PPUSH
22297: EMPTY
22298: PPUSH
22299: CALL_OW 1
22303: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22304: LD_ADDR_EXP 110
22308: PUSH
22309: LD_EXP 110
22313: PPUSH
22314: LD_VAR 0 4
22318: PPUSH
22319: EMPTY
22320: PPUSH
22321: CALL_OW 1
22325: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22326: LD_ADDR_EXP 111
22330: PUSH
22331: LD_EXP 111
22335: PPUSH
22336: LD_VAR 0 4
22340: PPUSH
22341: EMPTY
22342: PPUSH
22343: CALL_OW 1
22347: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22348: LD_ADDR_EXP 112
22352: PUSH
22353: LD_EXP 112
22357: PPUSH
22358: LD_VAR 0 4
22362: PPUSH
22363: EMPTY
22364: PPUSH
22365: CALL_OW 1
22369: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22370: LD_ADDR_EXP 113
22374: PUSH
22375: LD_EXP 113
22379: PPUSH
22380: LD_VAR 0 4
22384: PPUSH
22385: EMPTY
22386: PPUSH
22387: CALL_OW 1
22391: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22392: LD_ADDR_EXP 114
22396: PUSH
22397: LD_EXP 114
22401: PPUSH
22402: LD_VAR 0 4
22406: PPUSH
22407: EMPTY
22408: PPUSH
22409: CALL_OW 1
22413: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22414: LD_ADDR_EXP 116
22418: PUSH
22419: LD_EXP 116
22423: PPUSH
22424: LD_VAR 0 4
22428: PPUSH
22429: EMPTY
22430: PPUSH
22431: CALL_OW 1
22435: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22436: LD_ADDR_EXP 118
22440: PUSH
22441: LD_EXP 118
22445: PPUSH
22446: LD_VAR 0 4
22450: PPUSH
22451: EMPTY
22452: PPUSH
22453: CALL_OW 1
22457: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22458: LD_ADDR_EXP 119
22462: PUSH
22463: LD_EXP 119
22467: PPUSH
22468: LD_VAR 0 4
22472: PPUSH
22473: EMPTY
22474: PPUSH
22475: CALL_OW 1
22479: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22480: LD_ADDR_EXP 120
22484: PUSH
22485: LD_EXP 120
22489: PPUSH
22490: LD_VAR 0 4
22494: PPUSH
22495: EMPTY
22496: PPUSH
22497: CALL_OW 1
22501: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22502: LD_ADDR_EXP 121
22506: PUSH
22507: LD_EXP 121
22511: PPUSH
22512: LD_VAR 0 4
22516: PPUSH
22517: EMPTY
22518: PPUSH
22519: CALL_OW 1
22523: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22524: LD_ADDR_EXP 122
22528: PUSH
22529: LD_EXP 122
22533: PPUSH
22534: LD_VAR 0 4
22538: PPUSH
22539: EMPTY
22540: PPUSH
22541: CALL_OW 1
22545: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22546: LD_ADDR_EXP 123
22550: PUSH
22551: LD_EXP 123
22555: PPUSH
22556: LD_VAR 0 4
22560: PPUSH
22561: EMPTY
22562: PPUSH
22563: CALL_OW 1
22567: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22568: LD_ADDR_EXP 124
22572: PUSH
22573: LD_EXP 124
22577: PPUSH
22578: LD_VAR 0 4
22582: PPUSH
22583: EMPTY
22584: PPUSH
22585: CALL_OW 1
22589: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22590: LD_ADDR_EXP 125
22594: PUSH
22595: LD_EXP 125
22599: PPUSH
22600: LD_VAR 0 4
22604: PPUSH
22605: EMPTY
22606: PPUSH
22607: CALL_OW 1
22611: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22612: LD_ADDR_EXP 126
22616: PUSH
22617: LD_EXP 126
22621: PPUSH
22622: LD_VAR 0 4
22626: PPUSH
22627: EMPTY
22628: PPUSH
22629: CALL_OW 1
22633: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22634: LD_ADDR_EXP 127
22638: PUSH
22639: LD_EXP 127
22643: PPUSH
22644: LD_VAR 0 4
22648: PPUSH
22649: EMPTY
22650: PPUSH
22651: CALL_OW 1
22655: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22656: LD_ADDR_EXP 128
22660: PUSH
22661: LD_EXP 128
22665: PPUSH
22666: LD_VAR 0 4
22670: PPUSH
22671: EMPTY
22672: PPUSH
22673: CALL_OW 1
22677: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22678: LD_ADDR_EXP 129
22682: PUSH
22683: LD_EXP 129
22687: PPUSH
22688: LD_VAR 0 4
22692: PPUSH
22693: EMPTY
22694: PPUSH
22695: CALL_OW 1
22699: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22700: LD_ADDR_EXP 130
22704: PUSH
22705: LD_EXP 130
22709: PPUSH
22710: LD_VAR 0 4
22714: PPUSH
22715: EMPTY
22716: PPUSH
22717: CALL_OW 1
22721: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22722: LD_ADDR_EXP 131
22726: PUSH
22727: LD_EXP 131
22731: PPUSH
22732: LD_VAR 0 4
22736: PPUSH
22737: LD_INT 0
22739: PPUSH
22740: CALL_OW 1
22744: ST_TO_ADDR
// result := base ;
22745: LD_ADDR_VAR 0 3
22749: PUSH
22750: LD_VAR 0 4
22754: ST_TO_ADDR
// end ;
22755: LD_VAR 0 3
22759: RET
// export function MC_Start ( ) ; var i ; begin
22760: LD_INT 0
22762: PPUSH
22763: PPUSH
// for i = 1 to mc_bases do
22764: LD_ADDR_VAR 0 2
22768: PUSH
22769: DOUBLE
22770: LD_INT 1
22772: DEC
22773: ST_TO_ADDR
22774: LD_EXP 89
22778: PUSH
22779: FOR_TO
22780: IFFALSE 23857
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22782: LD_ADDR_EXP 89
22786: PUSH
22787: LD_EXP 89
22791: PPUSH
22792: LD_VAR 0 2
22796: PPUSH
22797: LD_EXP 89
22801: PUSH
22802: LD_VAR 0 2
22806: ARRAY
22807: PUSH
22808: LD_INT 0
22810: DIFF
22811: PPUSH
22812: CALL_OW 1
22816: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22817: LD_ADDR_EXP 90
22821: PUSH
22822: LD_EXP 90
22826: PPUSH
22827: LD_VAR 0 2
22831: PPUSH
22832: EMPTY
22833: PPUSH
22834: CALL_OW 1
22838: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22839: LD_ADDR_EXP 91
22843: PUSH
22844: LD_EXP 91
22848: PPUSH
22849: LD_VAR 0 2
22853: PPUSH
22854: EMPTY
22855: PPUSH
22856: CALL_OW 1
22860: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22861: LD_ADDR_EXP 92
22865: PUSH
22866: LD_EXP 92
22870: PPUSH
22871: LD_VAR 0 2
22875: PPUSH
22876: EMPTY
22877: PPUSH
22878: CALL_OW 1
22882: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22883: LD_ADDR_EXP 93
22887: PUSH
22888: LD_EXP 93
22892: PPUSH
22893: LD_VAR 0 2
22897: PPUSH
22898: EMPTY
22899: PUSH
22900: EMPTY
22901: PUSH
22902: EMPTY
22903: LIST
22904: LIST
22905: PPUSH
22906: CALL_OW 1
22910: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22911: LD_ADDR_EXP 94
22915: PUSH
22916: LD_EXP 94
22920: PPUSH
22921: LD_VAR 0 2
22925: PPUSH
22926: EMPTY
22927: PPUSH
22928: CALL_OW 1
22932: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22933: LD_ADDR_EXP 121
22937: PUSH
22938: LD_EXP 121
22942: PPUSH
22943: LD_VAR 0 2
22947: PPUSH
22948: EMPTY
22949: PPUSH
22950: CALL_OW 1
22954: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22955: LD_ADDR_EXP 95
22959: PUSH
22960: LD_EXP 95
22964: PPUSH
22965: LD_VAR 0 2
22969: PPUSH
22970: EMPTY
22971: PPUSH
22972: CALL_OW 1
22976: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22977: LD_ADDR_EXP 96
22981: PUSH
22982: LD_EXP 96
22986: PPUSH
22987: LD_VAR 0 2
22991: PPUSH
22992: EMPTY
22993: PPUSH
22994: CALL_OW 1
22998: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22999: LD_ADDR_EXP 97
23003: PUSH
23004: LD_EXP 97
23008: PPUSH
23009: LD_VAR 0 2
23013: PPUSH
23014: LD_EXP 89
23018: PUSH
23019: LD_VAR 0 2
23023: ARRAY
23024: PPUSH
23025: LD_INT 2
23027: PUSH
23028: LD_INT 30
23030: PUSH
23031: LD_INT 32
23033: PUSH
23034: EMPTY
23035: LIST
23036: LIST
23037: PUSH
23038: LD_INT 30
23040: PUSH
23041: LD_INT 33
23043: PUSH
23044: EMPTY
23045: LIST
23046: LIST
23047: PUSH
23048: EMPTY
23049: LIST
23050: LIST
23051: LIST
23052: PPUSH
23053: CALL_OW 72
23057: PPUSH
23058: CALL_OW 1
23062: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23063: LD_ADDR_EXP 98
23067: PUSH
23068: LD_EXP 98
23072: PPUSH
23073: LD_VAR 0 2
23077: PPUSH
23078: LD_EXP 89
23082: PUSH
23083: LD_VAR 0 2
23087: ARRAY
23088: PPUSH
23089: LD_INT 2
23091: PUSH
23092: LD_INT 30
23094: PUSH
23095: LD_INT 32
23097: PUSH
23098: EMPTY
23099: LIST
23100: LIST
23101: PUSH
23102: LD_INT 30
23104: PUSH
23105: LD_INT 31
23107: PUSH
23108: EMPTY
23109: LIST
23110: LIST
23111: PUSH
23112: EMPTY
23113: LIST
23114: LIST
23115: LIST
23116: PUSH
23117: LD_INT 58
23119: PUSH
23120: EMPTY
23121: LIST
23122: PUSH
23123: EMPTY
23124: LIST
23125: LIST
23126: PPUSH
23127: CALL_OW 72
23131: PPUSH
23132: CALL_OW 1
23136: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23137: LD_ADDR_EXP 99
23141: PUSH
23142: LD_EXP 99
23146: PPUSH
23147: LD_VAR 0 2
23151: PPUSH
23152: EMPTY
23153: PPUSH
23154: CALL_OW 1
23158: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23159: LD_ADDR_EXP 103
23163: PUSH
23164: LD_EXP 103
23168: PPUSH
23169: LD_VAR 0 2
23173: PPUSH
23174: EMPTY
23175: PPUSH
23176: CALL_OW 1
23180: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23181: LD_ADDR_EXP 102
23185: PUSH
23186: LD_EXP 102
23190: PPUSH
23191: LD_VAR 0 2
23195: PPUSH
23196: EMPTY
23197: PPUSH
23198: CALL_OW 1
23202: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23203: LD_ADDR_EXP 104
23207: PUSH
23208: LD_EXP 104
23212: PPUSH
23213: LD_VAR 0 2
23217: PPUSH
23218: EMPTY
23219: PPUSH
23220: CALL_OW 1
23224: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23225: LD_ADDR_EXP 105
23229: PUSH
23230: LD_EXP 105
23234: PPUSH
23235: LD_VAR 0 2
23239: PPUSH
23240: EMPTY
23241: PPUSH
23242: CALL_OW 1
23246: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23247: LD_ADDR_EXP 106
23251: PUSH
23252: LD_EXP 106
23256: PPUSH
23257: LD_VAR 0 2
23261: PPUSH
23262: EMPTY
23263: PPUSH
23264: CALL_OW 1
23268: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23269: LD_ADDR_EXP 107
23273: PUSH
23274: LD_EXP 107
23278: PPUSH
23279: LD_VAR 0 2
23283: PPUSH
23284: EMPTY
23285: PPUSH
23286: CALL_OW 1
23290: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23291: LD_ADDR_EXP 108
23295: PUSH
23296: LD_EXP 108
23300: PPUSH
23301: LD_VAR 0 2
23305: PPUSH
23306: EMPTY
23307: PPUSH
23308: CALL_OW 1
23312: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23313: LD_ADDR_EXP 109
23317: PUSH
23318: LD_EXP 109
23322: PPUSH
23323: LD_VAR 0 2
23327: PPUSH
23328: EMPTY
23329: PPUSH
23330: CALL_OW 1
23334: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23335: LD_ADDR_EXP 110
23339: PUSH
23340: LD_EXP 110
23344: PPUSH
23345: LD_VAR 0 2
23349: PPUSH
23350: EMPTY
23351: PPUSH
23352: CALL_OW 1
23356: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23357: LD_ADDR_EXP 111
23361: PUSH
23362: LD_EXP 111
23366: PPUSH
23367: LD_VAR 0 2
23371: PPUSH
23372: EMPTY
23373: PPUSH
23374: CALL_OW 1
23378: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23379: LD_ADDR_EXP 100
23383: PUSH
23384: LD_EXP 100
23388: PPUSH
23389: LD_VAR 0 2
23393: PPUSH
23394: LD_INT 0
23396: PPUSH
23397: CALL_OW 1
23401: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23402: LD_ADDR_EXP 113
23406: PUSH
23407: LD_EXP 113
23411: PPUSH
23412: LD_VAR 0 2
23416: PPUSH
23417: LD_INT 0
23419: PPUSH
23420: CALL_OW 1
23424: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23425: LD_ADDR_EXP 101
23429: PUSH
23430: LD_EXP 101
23434: PPUSH
23435: LD_VAR 0 2
23439: PPUSH
23440: EMPTY
23441: PPUSH
23442: CALL_OW 1
23446: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23447: LD_ADDR_EXP 112
23451: PUSH
23452: LD_EXP 112
23456: PPUSH
23457: LD_VAR 0 2
23461: PPUSH
23462: LD_INT 0
23464: PPUSH
23465: CALL_OW 1
23469: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23470: LD_ADDR_EXP 114
23474: PUSH
23475: LD_EXP 114
23479: PPUSH
23480: LD_VAR 0 2
23484: PPUSH
23485: EMPTY
23486: PPUSH
23487: CALL_OW 1
23491: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23492: LD_ADDR_EXP 117
23496: PUSH
23497: LD_EXP 117
23501: PPUSH
23502: LD_VAR 0 2
23506: PPUSH
23507: LD_INT 0
23509: PPUSH
23510: CALL_OW 1
23514: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23515: LD_ADDR_EXP 118
23519: PUSH
23520: LD_EXP 118
23524: PPUSH
23525: LD_VAR 0 2
23529: PPUSH
23530: EMPTY
23531: PPUSH
23532: CALL_OW 1
23536: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23537: LD_ADDR_EXP 119
23541: PUSH
23542: LD_EXP 119
23546: PPUSH
23547: LD_VAR 0 2
23551: PPUSH
23552: EMPTY
23553: PPUSH
23554: CALL_OW 1
23558: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23559: LD_ADDR_EXP 120
23563: PUSH
23564: LD_EXP 120
23568: PPUSH
23569: LD_VAR 0 2
23573: PPUSH
23574: EMPTY
23575: PPUSH
23576: CALL_OW 1
23580: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23581: LD_ADDR_EXP 122
23585: PUSH
23586: LD_EXP 122
23590: PPUSH
23591: LD_VAR 0 2
23595: PPUSH
23596: LD_EXP 89
23600: PUSH
23601: LD_VAR 0 2
23605: ARRAY
23606: PPUSH
23607: LD_INT 2
23609: PUSH
23610: LD_INT 30
23612: PUSH
23613: LD_INT 6
23615: PUSH
23616: EMPTY
23617: LIST
23618: LIST
23619: PUSH
23620: LD_INT 30
23622: PUSH
23623: LD_INT 7
23625: PUSH
23626: EMPTY
23627: LIST
23628: LIST
23629: PUSH
23630: LD_INT 30
23632: PUSH
23633: LD_INT 8
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: PUSH
23640: EMPTY
23641: LIST
23642: LIST
23643: LIST
23644: LIST
23645: PPUSH
23646: CALL_OW 72
23650: PPUSH
23651: CALL_OW 1
23655: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23656: LD_ADDR_EXP 123
23660: PUSH
23661: LD_EXP 123
23665: PPUSH
23666: LD_VAR 0 2
23670: PPUSH
23671: EMPTY
23672: PPUSH
23673: CALL_OW 1
23677: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23678: LD_ADDR_EXP 124
23682: PUSH
23683: LD_EXP 124
23687: PPUSH
23688: LD_VAR 0 2
23692: PPUSH
23693: EMPTY
23694: PPUSH
23695: CALL_OW 1
23699: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23700: LD_ADDR_EXP 125
23704: PUSH
23705: LD_EXP 125
23709: PPUSH
23710: LD_VAR 0 2
23714: PPUSH
23715: EMPTY
23716: PPUSH
23717: CALL_OW 1
23721: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23722: LD_ADDR_EXP 126
23726: PUSH
23727: LD_EXP 126
23731: PPUSH
23732: LD_VAR 0 2
23736: PPUSH
23737: EMPTY
23738: PPUSH
23739: CALL_OW 1
23743: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23744: LD_ADDR_EXP 127
23748: PUSH
23749: LD_EXP 127
23753: PPUSH
23754: LD_VAR 0 2
23758: PPUSH
23759: EMPTY
23760: PPUSH
23761: CALL_OW 1
23765: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23766: LD_ADDR_EXP 128
23770: PUSH
23771: LD_EXP 128
23775: PPUSH
23776: LD_VAR 0 2
23780: PPUSH
23781: EMPTY
23782: PPUSH
23783: CALL_OW 1
23787: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23788: LD_ADDR_EXP 129
23792: PUSH
23793: LD_EXP 129
23797: PPUSH
23798: LD_VAR 0 2
23802: PPUSH
23803: EMPTY
23804: PPUSH
23805: CALL_OW 1
23809: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23810: LD_ADDR_EXP 130
23814: PUSH
23815: LD_EXP 130
23819: PPUSH
23820: LD_VAR 0 2
23824: PPUSH
23825: EMPTY
23826: PPUSH
23827: CALL_OW 1
23831: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23832: LD_ADDR_EXP 131
23836: PUSH
23837: LD_EXP 131
23841: PPUSH
23842: LD_VAR 0 2
23846: PPUSH
23847: LD_INT 0
23849: PPUSH
23850: CALL_OW 1
23854: ST_TO_ADDR
// end ;
23855: GO 22779
23857: POP
23858: POP
// MC_InitSides ( ) ;
23859: CALL 24145 0 0
// MC_InitResearch ( ) ;
23863: CALL 23884 0 0
// CustomInitMacro ( ) ;
23867: CALL 213 0 0
// skirmish := true ;
23871: LD_ADDR_EXP 87
23875: PUSH
23876: LD_INT 1
23878: ST_TO_ADDR
// end ;
23879: LD_VAR 0 1
23883: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23884: LD_INT 0
23886: PPUSH
23887: PPUSH
23888: PPUSH
23889: PPUSH
23890: PPUSH
23891: PPUSH
// if not mc_bases then
23892: LD_EXP 89
23896: NOT
23897: IFFALSE 23901
// exit ;
23899: GO 24140
// for i = 1 to 8 do
23901: LD_ADDR_VAR 0 2
23905: PUSH
23906: DOUBLE
23907: LD_INT 1
23909: DEC
23910: ST_TO_ADDR
23911: LD_INT 8
23913: PUSH
23914: FOR_TO
23915: IFFALSE 23941
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23917: LD_ADDR_EXP 116
23921: PUSH
23922: LD_EXP 116
23926: PPUSH
23927: LD_VAR 0 2
23931: PPUSH
23932: EMPTY
23933: PPUSH
23934: CALL_OW 1
23938: ST_TO_ADDR
23939: GO 23914
23941: POP
23942: POP
// tmp := [ ] ;
23943: LD_ADDR_VAR 0 5
23947: PUSH
23948: EMPTY
23949: ST_TO_ADDR
// for i = 1 to mc_sides do
23950: LD_ADDR_VAR 0 2
23954: PUSH
23955: DOUBLE
23956: LD_INT 1
23958: DEC
23959: ST_TO_ADDR
23960: LD_EXP 115
23964: PUSH
23965: FOR_TO
23966: IFFALSE 24024
// if not mc_sides [ i ] in tmp then
23968: LD_EXP 115
23972: PUSH
23973: LD_VAR 0 2
23977: ARRAY
23978: PUSH
23979: LD_VAR 0 5
23983: IN
23984: NOT
23985: IFFALSE 24022
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23987: LD_ADDR_VAR 0 5
23991: PUSH
23992: LD_VAR 0 5
23996: PPUSH
23997: LD_VAR 0 5
24001: PUSH
24002: LD_INT 1
24004: PLUS
24005: PPUSH
24006: LD_EXP 115
24010: PUSH
24011: LD_VAR 0 2
24015: ARRAY
24016: PPUSH
24017: CALL_OW 2
24021: ST_TO_ADDR
24022: GO 23965
24024: POP
24025: POP
// if not tmp then
24026: LD_VAR 0 5
24030: NOT
24031: IFFALSE 24035
// exit ;
24033: GO 24140
// for j in tmp do
24035: LD_ADDR_VAR 0 3
24039: PUSH
24040: LD_VAR 0 5
24044: PUSH
24045: FOR_IN
24046: IFFALSE 24138
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24048: LD_ADDR_VAR 0 6
24052: PUSH
24053: LD_INT 22
24055: PUSH
24056: LD_VAR 0 3
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PPUSH
24065: CALL_OW 69
24069: ST_TO_ADDR
// if not un then
24070: LD_VAR 0 6
24074: NOT
24075: IFFALSE 24079
// continue ;
24077: GO 24045
// nation := GetNation ( un [ 1 ] ) ;
24079: LD_ADDR_VAR 0 4
24083: PUSH
24084: LD_VAR 0 6
24088: PUSH
24089: LD_INT 1
24091: ARRAY
24092: PPUSH
24093: CALL_OW 248
24097: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24098: LD_ADDR_EXP 116
24102: PUSH
24103: LD_EXP 116
24107: PPUSH
24108: LD_VAR 0 3
24112: PPUSH
24113: LD_VAR 0 3
24117: PPUSH
24118: LD_VAR 0 4
24122: PPUSH
24123: LD_INT 1
24125: PPUSH
24126: CALL 50734 0 3
24130: PPUSH
24131: CALL_OW 1
24135: ST_TO_ADDR
// end ;
24136: GO 24045
24138: POP
24139: POP
// end ;
24140: LD_VAR 0 1
24144: RET
// export function MC_InitSides ( ) ; var i ; begin
24145: LD_INT 0
24147: PPUSH
24148: PPUSH
// if not mc_bases then
24149: LD_EXP 89
24153: NOT
24154: IFFALSE 24158
// exit ;
24156: GO 24232
// for i = 1 to mc_bases do
24158: LD_ADDR_VAR 0 2
24162: PUSH
24163: DOUBLE
24164: LD_INT 1
24166: DEC
24167: ST_TO_ADDR
24168: LD_EXP 89
24172: PUSH
24173: FOR_TO
24174: IFFALSE 24230
// if mc_bases [ i ] then
24176: LD_EXP 89
24180: PUSH
24181: LD_VAR 0 2
24185: ARRAY
24186: IFFALSE 24228
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24188: LD_ADDR_EXP 115
24192: PUSH
24193: LD_EXP 115
24197: PPUSH
24198: LD_VAR 0 2
24202: PPUSH
24203: LD_EXP 89
24207: PUSH
24208: LD_VAR 0 2
24212: ARRAY
24213: PUSH
24214: LD_INT 1
24216: ARRAY
24217: PPUSH
24218: CALL_OW 255
24222: PPUSH
24223: CALL_OW 1
24227: ST_TO_ADDR
24228: GO 24173
24230: POP
24231: POP
// end ;
24232: LD_VAR 0 1
24236: RET
// every 0 0$01 trigger skirmish do
24237: LD_EXP 87
24241: IFFALSE 24395
24243: GO 24245
24245: DISABLE
// begin enable ;
24246: ENABLE
// MC_CheckBuildings ( ) ;
24247: CALL 28893 0 0
// MC_CheckPeopleLife ( ) ;
24251: CALL 29018 0 0
// RaiseSailEvent ( 100 ) ;
24255: LD_INT 100
24257: PPUSH
24258: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24262: LD_INT 103
24264: PPUSH
24265: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24269: LD_INT 104
24271: PPUSH
24272: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24276: LD_INT 105
24278: PPUSH
24279: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24283: LD_INT 106
24285: PPUSH
24286: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24290: LD_INT 107
24292: PPUSH
24293: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24297: LD_INT 108
24299: PPUSH
24300: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24304: LD_INT 109
24306: PPUSH
24307: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24311: LD_INT 110
24313: PPUSH
24314: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24318: LD_INT 111
24320: PPUSH
24321: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24325: LD_INT 112
24327: PPUSH
24328: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24332: LD_INT 113
24334: PPUSH
24335: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24339: LD_INT 120
24341: PPUSH
24342: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24346: LD_INT 121
24348: PPUSH
24349: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24353: LD_INT 122
24355: PPUSH
24356: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24360: LD_INT 123
24362: PPUSH
24363: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24367: LD_INT 124
24369: PPUSH
24370: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24374: LD_INT 125
24376: PPUSH
24377: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24381: LD_INT 126
24383: PPUSH
24384: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24388: LD_INT 200
24390: PPUSH
24391: CALL_OW 427
// end ;
24395: END
// on SailEvent ( event ) do begin if event < 100 then
24396: LD_VAR 0 1
24400: PUSH
24401: LD_INT 100
24403: LESS
24404: IFFALSE 24415
// CustomEvent ( event ) ;
24406: LD_VAR 0 1
24410: PPUSH
24411: CALL 10371 0 1
// if event = 100 then
24415: LD_VAR 0 1
24419: PUSH
24420: LD_INT 100
24422: EQUAL
24423: IFFALSE 24429
// MC_ClassManager ( ) ;
24425: CALL 24821 0 0
// if event = 101 then
24429: LD_VAR 0 1
24433: PUSH
24434: LD_INT 101
24436: EQUAL
24437: IFFALSE 24443
// MC_RepairBuildings ( ) ;
24439: CALL 29603 0 0
// if event = 102 then
24443: LD_VAR 0 1
24447: PUSH
24448: LD_INT 102
24450: EQUAL
24451: IFFALSE 24457
// MC_Heal ( ) ;
24453: CALL 30462 0 0
// if event = 103 then
24457: LD_VAR 0 1
24461: PUSH
24462: LD_INT 103
24464: EQUAL
24465: IFFALSE 24471
// MC_Build ( ) ;
24467: CALL 30884 0 0
// if event = 104 then
24471: LD_VAR 0 1
24475: PUSH
24476: LD_INT 104
24478: EQUAL
24479: IFFALSE 24485
// MC_TurretWeapon ( ) ;
24481: CALL 32497 0 0
// if event = 105 then
24485: LD_VAR 0 1
24489: PUSH
24490: LD_INT 105
24492: EQUAL
24493: IFFALSE 24499
// MC_BuildUpgrade ( ) ;
24495: CALL 32048 0 0
// if event = 106 then
24499: LD_VAR 0 1
24503: PUSH
24504: LD_INT 106
24506: EQUAL
24507: IFFALSE 24513
// MC_PlantMines ( ) ;
24509: CALL 32927 0 0
// if event = 107 then
24513: LD_VAR 0 1
24517: PUSH
24518: LD_INT 107
24520: EQUAL
24521: IFFALSE 24527
// MC_CollectCrates ( ) ;
24523: CALL 33725 0 0
// if event = 108 then
24527: LD_VAR 0 1
24531: PUSH
24532: LD_INT 108
24534: EQUAL
24535: IFFALSE 24541
// MC_LinkRemoteControl ( ) ;
24537: CALL 35501 0 0
// if event = 109 then
24541: LD_VAR 0 1
24545: PUSH
24546: LD_INT 109
24548: EQUAL
24549: IFFALSE 24555
// MC_ProduceVehicle ( ) ;
24551: CALL 35682 0 0
// if event = 110 then
24555: LD_VAR 0 1
24559: PUSH
24560: LD_INT 110
24562: EQUAL
24563: IFFALSE 24569
// MC_SendAttack ( ) ;
24565: CALL 36148 0 0
// if event = 111 then
24569: LD_VAR 0 1
24573: PUSH
24574: LD_INT 111
24576: EQUAL
24577: IFFALSE 24583
// MC_Defend ( ) ;
24579: CALL 36256 0 0
// if event = 112 then
24583: LD_VAR 0 1
24587: PUSH
24588: LD_INT 112
24590: EQUAL
24591: IFFALSE 24597
// MC_Research ( ) ;
24593: CALL 36861 0 0
// if event = 113 then
24597: LD_VAR 0 1
24601: PUSH
24602: LD_INT 113
24604: EQUAL
24605: IFFALSE 24611
// MC_MinesTrigger ( ) ;
24607: CALL 37975 0 0
// if event = 120 then
24611: LD_VAR 0 1
24615: PUSH
24616: LD_INT 120
24618: EQUAL
24619: IFFALSE 24625
// MC_RepairVehicle ( ) ;
24621: CALL 38074 0 0
// if event = 121 then
24625: LD_VAR 0 1
24629: PUSH
24630: LD_INT 121
24632: EQUAL
24633: IFFALSE 24639
// MC_TameApe ( ) ;
24635: CALL 38804 0 0
// if event = 122 then
24639: LD_VAR 0 1
24643: PUSH
24644: LD_INT 122
24646: EQUAL
24647: IFFALSE 24653
// MC_ChangeApeClass ( ) ;
24649: CALL 39633 0 0
// if event = 123 then
24653: LD_VAR 0 1
24657: PUSH
24658: LD_INT 123
24660: EQUAL
24661: IFFALSE 24667
// MC_Bazooka ( ) ;
24663: CALL 40283 0 0
// if event = 124 then
24667: LD_VAR 0 1
24671: PUSH
24672: LD_INT 124
24674: EQUAL
24675: IFFALSE 24681
// MC_TeleportExit ( ) ;
24677: CALL 40481 0 0
// if event = 125 then
24681: LD_VAR 0 1
24685: PUSH
24686: LD_INT 125
24688: EQUAL
24689: IFFALSE 24695
// MC_Deposits ( ) ;
24691: CALL 41128 0 0
// if event = 126 then
24695: LD_VAR 0 1
24699: PUSH
24700: LD_INT 126
24702: EQUAL
24703: IFFALSE 24709
// MC_RemoteDriver ( ) ;
24705: CALL 41753 0 0
// if event = 200 then
24709: LD_VAR 0 1
24713: PUSH
24714: LD_INT 200
24716: EQUAL
24717: IFFALSE 24723
// MC_Idle ( ) ;
24719: CALL 43702 0 0
// end ;
24723: PPOPN 1
24725: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24726: LD_INT 0
24728: PPUSH
24729: PPUSH
// if not mc_bases [ base ] or not tag then
24730: LD_EXP 89
24734: PUSH
24735: LD_VAR 0 1
24739: ARRAY
24740: NOT
24741: PUSH
24742: LD_VAR 0 2
24746: NOT
24747: OR
24748: IFFALSE 24752
// exit ;
24750: GO 24816
// for i in mc_bases [ base ] union mc_ape [ base ] do
24752: LD_ADDR_VAR 0 4
24756: PUSH
24757: LD_EXP 89
24761: PUSH
24762: LD_VAR 0 1
24766: ARRAY
24767: PUSH
24768: LD_EXP 118
24772: PUSH
24773: LD_VAR 0 1
24777: ARRAY
24778: UNION
24779: PUSH
24780: FOR_IN
24781: IFFALSE 24814
// if GetTag ( i ) = tag then
24783: LD_VAR 0 4
24787: PPUSH
24788: CALL_OW 110
24792: PUSH
24793: LD_VAR 0 2
24797: EQUAL
24798: IFFALSE 24812
// SetTag ( i , 0 ) ;
24800: LD_VAR 0 4
24804: PPUSH
24805: LD_INT 0
24807: PPUSH
24808: CALL_OW 109
24812: GO 24780
24814: POP
24815: POP
// end ;
24816: LD_VAR 0 3
24820: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24821: LD_INT 0
24823: PPUSH
24824: PPUSH
24825: PPUSH
24826: PPUSH
24827: PPUSH
24828: PPUSH
24829: PPUSH
24830: PPUSH
// if not mc_bases then
24831: LD_EXP 89
24835: NOT
24836: IFFALSE 24840
// exit ;
24838: GO 25298
// for i = 1 to mc_bases do
24840: LD_ADDR_VAR 0 2
24844: PUSH
24845: DOUBLE
24846: LD_INT 1
24848: DEC
24849: ST_TO_ADDR
24850: LD_EXP 89
24854: PUSH
24855: FOR_TO
24856: IFFALSE 25296
// begin tmp := MC_ClassCheckReq ( i ) ;
24858: LD_ADDR_VAR 0 4
24862: PUSH
24863: LD_VAR 0 2
24867: PPUSH
24868: CALL 25303 0 1
24872: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24873: LD_ADDR_EXP 130
24877: PUSH
24878: LD_EXP 130
24882: PPUSH
24883: LD_VAR 0 2
24887: PPUSH
24888: LD_VAR 0 4
24892: PPUSH
24893: CALL_OW 1
24897: ST_TO_ADDR
// if not tmp then
24898: LD_VAR 0 4
24902: NOT
24903: IFFALSE 24907
// continue ;
24905: GO 24855
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24907: LD_ADDR_VAR 0 6
24911: PUSH
24912: LD_EXP 89
24916: PUSH
24917: LD_VAR 0 2
24921: ARRAY
24922: PPUSH
24923: LD_INT 2
24925: PUSH
24926: LD_INT 30
24928: PUSH
24929: LD_INT 4
24931: PUSH
24932: EMPTY
24933: LIST
24934: LIST
24935: PUSH
24936: LD_INT 30
24938: PUSH
24939: LD_INT 5
24941: PUSH
24942: EMPTY
24943: LIST
24944: LIST
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: LIST
24950: PPUSH
24951: CALL_OW 72
24955: PUSH
24956: LD_EXP 89
24960: PUSH
24961: LD_VAR 0 2
24965: ARRAY
24966: PPUSH
24967: LD_INT 2
24969: PUSH
24970: LD_INT 30
24972: PUSH
24973: LD_INT 0
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: LD_INT 30
24982: PUSH
24983: LD_INT 1
24985: PUSH
24986: EMPTY
24987: LIST
24988: LIST
24989: PUSH
24990: EMPTY
24991: LIST
24992: LIST
24993: LIST
24994: PPUSH
24995: CALL_OW 72
24999: PUSH
25000: LD_EXP 89
25004: PUSH
25005: LD_VAR 0 2
25009: ARRAY
25010: PPUSH
25011: LD_INT 30
25013: PUSH
25014: LD_INT 3
25016: PUSH
25017: EMPTY
25018: LIST
25019: LIST
25020: PPUSH
25021: CALL_OW 72
25025: PUSH
25026: LD_EXP 89
25030: PUSH
25031: LD_VAR 0 2
25035: ARRAY
25036: PPUSH
25037: LD_INT 2
25039: PUSH
25040: LD_INT 30
25042: PUSH
25043: LD_INT 6
25045: PUSH
25046: EMPTY
25047: LIST
25048: LIST
25049: PUSH
25050: LD_INT 30
25052: PUSH
25053: LD_INT 7
25055: PUSH
25056: EMPTY
25057: LIST
25058: LIST
25059: PUSH
25060: LD_INT 30
25062: PUSH
25063: LD_INT 8
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: LIST
25074: LIST
25075: PPUSH
25076: CALL_OW 72
25080: PUSH
25081: EMPTY
25082: LIST
25083: LIST
25084: LIST
25085: LIST
25086: ST_TO_ADDR
// for j = 1 to 4 do
25087: LD_ADDR_VAR 0 3
25091: PUSH
25092: DOUBLE
25093: LD_INT 1
25095: DEC
25096: ST_TO_ADDR
25097: LD_INT 4
25099: PUSH
25100: FOR_TO
25101: IFFALSE 25292
// begin if not tmp [ j ] then
25103: LD_VAR 0 4
25107: PUSH
25108: LD_VAR 0 3
25112: ARRAY
25113: NOT
25114: IFFALSE 25118
// continue ;
25116: GO 25100
// for p in tmp [ j ] do
25118: LD_ADDR_VAR 0 5
25122: PUSH
25123: LD_VAR 0 4
25127: PUSH
25128: LD_VAR 0 3
25132: ARRAY
25133: PUSH
25134: FOR_IN
25135: IFFALSE 25288
// begin if not b [ j ] then
25137: LD_VAR 0 6
25141: PUSH
25142: LD_VAR 0 3
25146: ARRAY
25147: NOT
25148: IFFALSE 25152
// break ;
25150: GO 25288
// e := 0 ;
25152: LD_ADDR_VAR 0 7
25156: PUSH
25157: LD_INT 0
25159: ST_TO_ADDR
// for k in b [ j ] do
25160: LD_ADDR_VAR 0 8
25164: PUSH
25165: LD_VAR 0 6
25169: PUSH
25170: LD_VAR 0 3
25174: ARRAY
25175: PUSH
25176: FOR_IN
25177: IFFALSE 25204
// if IsNotFull ( k ) then
25179: LD_VAR 0 8
25183: PPUSH
25184: CALL 52883 0 1
25188: IFFALSE 25202
// begin e := k ;
25190: LD_ADDR_VAR 0 7
25194: PUSH
25195: LD_VAR 0 8
25199: ST_TO_ADDR
// break ;
25200: GO 25204
// end ;
25202: GO 25176
25204: POP
25205: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25206: LD_VAR 0 7
25210: PUSH
25211: LD_VAR 0 5
25215: PPUSH
25216: LD_VAR 0 7
25220: PPUSH
25221: CALL 85303 0 2
25225: NOT
25226: AND
25227: IFFALSE 25286
// begin if IsInUnit ( p ) then
25229: LD_VAR 0 5
25233: PPUSH
25234: CALL_OW 310
25238: IFFALSE 25249
// ComExitBuilding ( p ) ;
25240: LD_VAR 0 5
25244: PPUSH
25245: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25249: LD_VAR 0 5
25253: PPUSH
25254: LD_VAR 0 7
25258: PPUSH
25259: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25263: LD_VAR 0 5
25267: PPUSH
25268: LD_VAR 0 3
25272: PPUSH
25273: CALL_OW 183
// AddComExitBuilding ( p ) ;
25277: LD_VAR 0 5
25281: PPUSH
25282: CALL_OW 182
// end ; end ;
25286: GO 25134
25288: POP
25289: POP
// end ;
25290: GO 25100
25292: POP
25293: POP
// end ;
25294: GO 24855
25296: POP
25297: POP
// end ;
25298: LD_VAR 0 1
25302: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25303: LD_INT 0
25305: PPUSH
25306: PPUSH
25307: PPUSH
25308: PPUSH
25309: PPUSH
25310: PPUSH
25311: PPUSH
25312: PPUSH
25313: PPUSH
25314: PPUSH
25315: PPUSH
25316: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25317: LD_VAR 0 1
25321: NOT
25322: PUSH
25323: LD_EXP 89
25327: PUSH
25328: LD_VAR 0 1
25332: ARRAY
25333: NOT
25334: OR
25335: PUSH
25336: LD_EXP 89
25340: PUSH
25341: LD_VAR 0 1
25345: ARRAY
25346: PPUSH
25347: LD_INT 2
25349: PUSH
25350: LD_INT 30
25352: PUSH
25353: LD_INT 0
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: PUSH
25360: LD_INT 30
25362: PUSH
25363: LD_INT 1
25365: PUSH
25366: EMPTY
25367: LIST
25368: LIST
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: LIST
25374: PPUSH
25375: CALL_OW 72
25379: NOT
25380: OR
25381: IFFALSE 25385
// exit ;
25383: GO 28888
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25385: LD_ADDR_VAR 0 4
25389: PUSH
25390: LD_EXP 89
25394: PUSH
25395: LD_VAR 0 1
25399: ARRAY
25400: PPUSH
25401: LD_INT 2
25403: PUSH
25404: LD_INT 25
25406: PUSH
25407: LD_INT 1
25409: PUSH
25410: EMPTY
25411: LIST
25412: LIST
25413: PUSH
25414: LD_INT 25
25416: PUSH
25417: LD_INT 2
25419: PUSH
25420: EMPTY
25421: LIST
25422: LIST
25423: PUSH
25424: LD_INT 25
25426: PUSH
25427: LD_INT 3
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: PUSH
25434: LD_INT 25
25436: PUSH
25437: LD_INT 4
25439: PUSH
25440: EMPTY
25441: LIST
25442: LIST
25443: PUSH
25444: LD_INT 25
25446: PUSH
25447: LD_INT 5
25449: PUSH
25450: EMPTY
25451: LIST
25452: LIST
25453: PUSH
25454: LD_INT 25
25456: PUSH
25457: LD_INT 8
25459: PUSH
25460: EMPTY
25461: LIST
25462: LIST
25463: PUSH
25464: LD_INT 25
25466: PUSH
25467: LD_INT 9
25469: PUSH
25470: EMPTY
25471: LIST
25472: LIST
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: LIST
25478: LIST
25479: LIST
25480: LIST
25481: LIST
25482: LIST
25483: PPUSH
25484: CALL_OW 72
25488: ST_TO_ADDR
// if not tmp then
25489: LD_VAR 0 4
25493: NOT
25494: IFFALSE 25498
// exit ;
25496: GO 28888
// for i in tmp do
25498: LD_ADDR_VAR 0 3
25502: PUSH
25503: LD_VAR 0 4
25507: PUSH
25508: FOR_IN
25509: IFFALSE 25540
// if GetTag ( i ) then
25511: LD_VAR 0 3
25515: PPUSH
25516: CALL_OW 110
25520: IFFALSE 25538
// tmp := tmp diff i ;
25522: LD_ADDR_VAR 0 4
25526: PUSH
25527: LD_VAR 0 4
25531: PUSH
25532: LD_VAR 0 3
25536: DIFF
25537: ST_TO_ADDR
25538: GO 25508
25540: POP
25541: POP
// if not tmp then
25542: LD_VAR 0 4
25546: NOT
25547: IFFALSE 25551
// exit ;
25549: GO 28888
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25551: LD_ADDR_VAR 0 5
25555: PUSH
25556: LD_EXP 89
25560: PUSH
25561: LD_VAR 0 1
25565: ARRAY
25566: PPUSH
25567: LD_INT 2
25569: PUSH
25570: LD_INT 25
25572: PUSH
25573: LD_INT 1
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: PUSH
25580: LD_INT 25
25582: PUSH
25583: LD_INT 5
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 25
25592: PUSH
25593: LD_INT 8
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: PUSH
25600: LD_INT 25
25602: PUSH
25603: LD_INT 9
25605: PUSH
25606: EMPTY
25607: LIST
25608: LIST
25609: PUSH
25610: EMPTY
25611: LIST
25612: LIST
25613: LIST
25614: LIST
25615: LIST
25616: PPUSH
25617: CALL_OW 72
25621: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25622: LD_ADDR_VAR 0 6
25626: PUSH
25627: LD_EXP 89
25631: PUSH
25632: LD_VAR 0 1
25636: ARRAY
25637: PPUSH
25638: LD_INT 25
25640: PUSH
25641: LD_INT 2
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PPUSH
25648: CALL_OW 72
25652: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25653: LD_ADDR_VAR 0 7
25657: PUSH
25658: LD_EXP 89
25662: PUSH
25663: LD_VAR 0 1
25667: ARRAY
25668: PPUSH
25669: LD_INT 25
25671: PUSH
25672: LD_INT 3
25674: PUSH
25675: EMPTY
25676: LIST
25677: LIST
25678: PPUSH
25679: CALL_OW 72
25683: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25684: LD_ADDR_VAR 0 8
25688: PUSH
25689: LD_EXP 89
25693: PUSH
25694: LD_VAR 0 1
25698: ARRAY
25699: PPUSH
25700: LD_INT 25
25702: PUSH
25703: LD_INT 4
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: PUSH
25710: LD_INT 24
25712: PUSH
25713: LD_INT 251
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: PUSH
25720: EMPTY
25721: LIST
25722: LIST
25723: PPUSH
25724: CALL_OW 72
25728: ST_TO_ADDR
// if mc_scan [ base ] then
25729: LD_EXP 112
25733: PUSH
25734: LD_VAR 0 1
25738: ARRAY
25739: IFFALSE 26200
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25741: LD_ADDR_EXP 131
25745: PUSH
25746: LD_EXP 131
25750: PPUSH
25751: LD_VAR 0 1
25755: PPUSH
25756: LD_INT 4
25758: PPUSH
25759: CALL_OW 1
25763: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25764: LD_ADDR_VAR 0 12
25768: PUSH
25769: LD_EXP 89
25773: PUSH
25774: LD_VAR 0 1
25778: ARRAY
25779: PPUSH
25780: LD_INT 2
25782: PUSH
25783: LD_INT 30
25785: PUSH
25786: LD_INT 4
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 30
25795: PUSH
25796: LD_INT 5
25798: PUSH
25799: EMPTY
25800: LIST
25801: LIST
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: LIST
25807: PPUSH
25808: CALL_OW 72
25812: ST_TO_ADDR
// if not b then
25813: LD_VAR 0 12
25817: NOT
25818: IFFALSE 25822
// exit ;
25820: GO 28888
// p := [ ] ;
25822: LD_ADDR_VAR 0 11
25826: PUSH
25827: EMPTY
25828: ST_TO_ADDR
// if sci >= 2 then
25829: LD_VAR 0 8
25833: PUSH
25834: LD_INT 2
25836: GREATEREQUAL
25837: IFFALSE 25868
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25839: LD_ADDR_VAR 0 8
25843: PUSH
25844: LD_VAR 0 8
25848: PUSH
25849: LD_INT 1
25851: ARRAY
25852: PUSH
25853: LD_VAR 0 8
25857: PUSH
25858: LD_INT 2
25860: ARRAY
25861: PUSH
25862: EMPTY
25863: LIST
25864: LIST
25865: ST_TO_ADDR
25866: GO 25929
// if sci = 1 then
25868: LD_VAR 0 8
25872: PUSH
25873: LD_INT 1
25875: EQUAL
25876: IFFALSE 25897
// sci := [ sci [ 1 ] ] else
25878: LD_ADDR_VAR 0 8
25882: PUSH
25883: LD_VAR 0 8
25887: PUSH
25888: LD_INT 1
25890: ARRAY
25891: PUSH
25892: EMPTY
25893: LIST
25894: ST_TO_ADDR
25895: GO 25929
// if sci = 0 then
25897: LD_VAR 0 8
25901: PUSH
25902: LD_INT 0
25904: EQUAL
25905: IFFALSE 25929
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25907: LD_ADDR_VAR 0 11
25911: PUSH
25912: LD_VAR 0 4
25916: PPUSH
25917: LD_INT 4
25919: PPUSH
25920: CALL 85166 0 2
25924: PUSH
25925: LD_INT 1
25927: ARRAY
25928: ST_TO_ADDR
// if eng > 4 then
25929: LD_VAR 0 6
25933: PUSH
25934: LD_INT 4
25936: GREATER
25937: IFFALSE 25983
// for i = eng downto 4 do
25939: LD_ADDR_VAR 0 3
25943: PUSH
25944: DOUBLE
25945: LD_VAR 0 6
25949: INC
25950: ST_TO_ADDR
25951: LD_INT 4
25953: PUSH
25954: FOR_DOWNTO
25955: IFFALSE 25981
// eng := eng diff eng [ i ] ;
25957: LD_ADDR_VAR 0 6
25961: PUSH
25962: LD_VAR 0 6
25966: PUSH
25967: LD_VAR 0 6
25971: PUSH
25972: LD_VAR 0 3
25976: ARRAY
25977: DIFF
25978: ST_TO_ADDR
25979: GO 25954
25981: POP
25982: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25983: LD_ADDR_VAR 0 4
25987: PUSH
25988: LD_VAR 0 4
25992: PUSH
25993: LD_VAR 0 5
25997: PUSH
25998: LD_VAR 0 6
26002: UNION
26003: PUSH
26004: LD_VAR 0 7
26008: UNION
26009: PUSH
26010: LD_VAR 0 8
26014: UNION
26015: DIFF
26016: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26017: LD_ADDR_VAR 0 13
26021: PUSH
26022: LD_EXP 89
26026: PUSH
26027: LD_VAR 0 1
26031: ARRAY
26032: PPUSH
26033: LD_INT 2
26035: PUSH
26036: LD_INT 30
26038: PUSH
26039: LD_INT 32
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 30
26048: PUSH
26049: LD_INT 31
26051: PUSH
26052: EMPTY
26053: LIST
26054: LIST
26055: PUSH
26056: EMPTY
26057: LIST
26058: LIST
26059: LIST
26060: PPUSH
26061: CALL_OW 72
26065: PUSH
26066: LD_EXP 89
26070: PUSH
26071: LD_VAR 0 1
26075: ARRAY
26076: PPUSH
26077: LD_INT 2
26079: PUSH
26080: LD_INT 30
26082: PUSH
26083: LD_INT 4
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: PUSH
26090: LD_INT 30
26092: PUSH
26093: LD_INT 5
26095: PUSH
26096: EMPTY
26097: LIST
26098: LIST
26099: PUSH
26100: EMPTY
26101: LIST
26102: LIST
26103: LIST
26104: PPUSH
26105: CALL_OW 72
26109: PUSH
26110: LD_INT 6
26112: MUL
26113: PLUS
26114: ST_TO_ADDR
// if bcount < tmp then
26115: LD_VAR 0 13
26119: PUSH
26120: LD_VAR 0 4
26124: LESS
26125: IFFALSE 26171
// for i = tmp downto bcount do
26127: LD_ADDR_VAR 0 3
26131: PUSH
26132: DOUBLE
26133: LD_VAR 0 4
26137: INC
26138: ST_TO_ADDR
26139: LD_VAR 0 13
26143: PUSH
26144: FOR_DOWNTO
26145: IFFALSE 26169
// tmp := Delete ( tmp , tmp ) ;
26147: LD_ADDR_VAR 0 4
26151: PUSH
26152: LD_VAR 0 4
26156: PPUSH
26157: LD_VAR 0 4
26161: PPUSH
26162: CALL_OW 3
26166: ST_TO_ADDR
26167: GO 26144
26169: POP
26170: POP
// result := [ tmp , 0 , 0 , p ] ;
26171: LD_ADDR_VAR 0 2
26175: PUSH
26176: LD_VAR 0 4
26180: PUSH
26181: LD_INT 0
26183: PUSH
26184: LD_INT 0
26186: PUSH
26187: LD_VAR 0 11
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: LIST
26196: LIST
26197: ST_TO_ADDR
// exit ;
26198: GO 28888
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26200: LD_EXP 89
26204: PUSH
26205: LD_VAR 0 1
26209: ARRAY
26210: PPUSH
26211: LD_INT 2
26213: PUSH
26214: LD_INT 30
26216: PUSH
26217: LD_INT 6
26219: PUSH
26220: EMPTY
26221: LIST
26222: LIST
26223: PUSH
26224: LD_INT 30
26226: PUSH
26227: LD_INT 7
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 30
26236: PUSH
26237: LD_INT 8
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: PPUSH
26250: CALL_OW 72
26254: NOT
26255: PUSH
26256: LD_EXP 89
26260: PUSH
26261: LD_VAR 0 1
26265: ARRAY
26266: PPUSH
26267: LD_INT 30
26269: PUSH
26270: LD_INT 3
26272: PUSH
26273: EMPTY
26274: LIST
26275: LIST
26276: PPUSH
26277: CALL_OW 72
26281: NOT
26282: AND
26283: IFFALSE 26355
// begin if eng = tmp then
26285: LD_VAR 0 6
26289: PUSH
26290: LD_VAR 0 4
26294: EQUAL
26295: IFFALSE 26299
// exit ;
26297: GO 28888
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26299: LD_ADDR_EXP 131
26303: PUSH
26304: LD_EXP 131
26308: PPUSH
26309: LD_VAR 0 1
26313: PPUSH
26314: LD_INT 1
26316: PPUSH
26317: CALL_OW 1
26321: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26322: LD_ADDR_VAR 0 2
26326: PUSH
26327: LD_INT 0
26329: PUSH
26330: LD_VAR 0 4
26334: PUSH
26335: LD_VAR 0 6
26339: DIFF
26340: PUSH
26341: LD_INT 0
26343: PUSH
26344: LD_INT 0
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: LIST
26351: LIST
26352: ST_TO_ADDR
// exit ;
26353: GO 28888
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26355: LD_EXP 116
26359: PUSH
26360: LD_EXP 115
26364: PUSH
26365: LD_VAR 0 1
26369: ARRAY
26370: ARRAY
26371: PUSH
26372: LD_EXP 89
26376: PUSH
26377: LD_VAR 0 1
26381: ARRAY
26382: PPUSH
26383: LD_INT 2
26385: PUSH
26386: LD_INT 30
26388: PUSH
26389: LD_INT 6
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PUSH
26396: LD_INT 30
26398: PUSH
26399: LD_INT 7
26401: PUSH
26402: EMPTY
26403: LIST
26404: LIST
26405: PUSH
26406: LD_INT 30
26408: PUSH
26409: LD_INT 8
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: LIST
26420: LIST
26421: PPUSH
26422: CALL_OW 72
26426: AND
26427: PUSH
26428: LD_EXP 89
26432: PUSH
26433: LD_VAR 0 1
26437: ARRAY
26438: PPUSH
26439: LD_INT 30
26441: PUSH
26442: LD_INT 3
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: PPUSH
26449: CALL_OW 72
26453: NOT
26454: AND
26455: IFFALSE 26669
// begin if sci >= 6 then
26457: LD_VAR 0 8
26461: PUSH
26462: LD_INT 6
26464: GREATEREQUAL
26465: IFFALSE 26469
// exit ;
26467: GO 28888
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26469: LD_ADDR_EXP 131
26473: PUSH
26474: LD_EXP 131
26478: PPUSH
26479: LD_VAR 0 1
26483: PPUSH
26484: LD_INT 2
26486: PPUSH
26487: CALL_OW 1
26491: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26492: LD_ADDR_VAR 0 9
26496: PUSH
26497: LD_VAR 0 4
26501: PUSH
26502: LD_VAR 0 8
26506: DIFF
26507: PPUSH
26508: LD_INT 4
26510: PPUSH
26511: CALL 85166 0 2
26515: ST_TO_ADDR
// p := [ ] ;
26516: LD_ADDR_VAR 0 11
26520: PUSH
26521: EMPTY
26522: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26523: LD_VAR 0 8
26527: PUSH
26528: LD_INT 6
26530: LESS
26531: PUSH
26532: LD_VAR 0 9
26536: PUSH
26537: LD_INT 6
26539: GREATER
26540: AND
26541: IFFALSE 26622
// begin for i = 1 to 6 - sci do
26543: LD_ADDR_VAR 0 3
26547: PUSH
26548: DOUBLE
26549: LD_INT 1
26551: DEC
26552: ST_TO_ADDR
26553: LD_INT 6
26555: PUSH
26556: LD_VAR 0 8
26560: MINUS
26561: PUSH
26562: FOR_TO
26563: IFFALSE 26618
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26565: LD_ADDR_VAR 0 11
26569: PUSH
26570: LD_VAR 0 11
26574: PPUSH
26575: LD_VAR 0 11
26579: PUSH
26580: LD_INT 1
26582: PLUS
26583: PPUSH
26584: LD_VAR 0 9
26588: PUSH
26589: LD_INT 1
26591: ARRAY
26592: PPUSH
26593: CALL_OW 2
26597: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26598: LD_ADDR_VAR 0 9
26602: PUSH
26603: LD_VAR 0 9
26607: PPUSH
26608: LD_INT 1
26610: PPUSH
26611: CALL_OW 3
26615: ST_TO_ADDR
// end ;
26616: GO 26562
26618: POP
26619: POP
// end else
26620: GO 26642
// if sort then
26622: LD_VAR 0 9
26626: IFFALSE 26642
// p := sort [ 1 ] ;
26628: LD_ADDR_VAR 0 11
26632: PUSH
26633: LD_VAR 0 9
26637: PUSH
26638: LD_INT 1
26640: ARRAY
26641: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26642: LD_ADDR_VAR 0 2
26646: PUSH
26647: LD_INT 0
26649: PUSH
26650: LD_INT 0
26652: PUSH
26653: LD_INT 0
26655: PUSH
26656: LD_VAR 0 11
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: ST_TO_ADDR
// exit ;
26667: GO 28888
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26669: LD_EXP 116
26673: PUSH
26674: LD_EXP 115
26678: PUSH
26679: LD_VAR 0 1
26683: ARRAY
26684: ARRAY
26685: PUSH
26686: LD_EXP 89
26690: PUSH
26691: LD_VAR 0 1
26695: ARRAY
26696: PPUSH
26697: LD_INT 2
26699: PUSH
26700: LD_INT 30
26702: PUSH
26703: LD_INT 6
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: PUSH
26710: LD_INT 30
26712: PUSH
26713: LD_INT 7
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: PUSH
26720: LD_INT 30
26722: PUSH
26723: LD_INT 8
26725: PUSH
26726: EMPTY
26727: LIST
26728: LIST
26729: PUSH
26730: EMPTY
26731: LIST
26732: LIST
26733: LIST
26734: LIST
26735: PPUSH
26736: CALL_OW 72
26740: AND
26741: PUSH
26742: LD_EXP 89
26746: PUSH
26747: LD_VAR 0 1
26751: ARRAY
26752: PPUSH
26753: LD_INT 30
26755: PUSH
26756: LD_INT 3
26758: PUSH
26759: EMPTY
26760: LIST
26761: LIST
26762: PPUSH
26763: CALL_OW 72
26767: AND
26768: IFFALSE 27502
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26770: LD_ADDR_EXP 131
26774: PUSH
26775: LD_EXP 131
26779: PPUSH
26780: LD_VAR 0 1
26784: PPUSH
26785: LD_INT 3
26787: PPUSH
26788: CALL_OW 1
26792: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26793: LD_ADDR_VAR 0 2
26797: PUSH
26798: LD_INT 0
26800: PUSH
26801: LD_INT 0
26803: PUSH
26804: LD_INT 0
26806: PUSH
26807: LD_INT 0
26809: PUSH
26810: EMPTY
26811: LIST
26812: LIST
26813: LIST
26814: LIST
26815: ST_TO_ADDR
// if not eng then
26816: LD_VAR 0 6
26820: NOT
26821: IFFALSE 26884
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26823: LD_ADDR_VAR 0 11
26827: PUSH
26828: LD_VAR 0 4
26832: PPUSH
26833: LD_INT 2
26835: PPUSH
26836: CALL 85166 0 2
26840: PUSH
26841: LD_INT 1
26843: ARRAY
26844: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26845: LD_ADDR_VAR 0 2
26849: PUSH
26850: LD_VAR 0 2
26854: PPUSH
26855: LD_INT 2
26857: PPUSH
26858: LD_VAR 0 11
26862: PPUSH
26863: CALL_OW 1
26867: ST_TO_ADDR
// tmp := tmp diff p ;
26868: LD_ADDR_VAR 0 4
26872: PUSH
26873: LD_VAR 0 4
26877: PUSH
26878: LD_VAR 0 11
26882: DIFF
26883: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26884: LD_VAR 0 4
26888: PUSH
26889: LD_VAR 0 8
26893: PUSH
26894: LD_INT 6
26896: LESS
26897: AND
26898: IFFALSE 27086
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26900: LD_ADDR_VAR 0 9
26904: PUSH
26905: LD_VAR 0 4
26909: PUSH
26910: LD_VAR 0 8
26914: PUSH
26915: LD_VAR 0 7
26919: UNION
26920: DIFF
26921: PPUSH
26922: LD_INT 4
26924: PPUSH
26925: CALL 85166 0 2
26929: ST_TO_ADDR
// p := [ ] ;
26930: LD_ADDR_VAR 0 11
26934: PUSH
26935: EMPTY
26936: ST_TO_ADDR
// if sort then
26937: LD_VAR 0 9
26941: IFFALSE 27057
// for i = 1 to 6 - sci do
26943: LD_ADDR_VAR 0 3
26947: PUSH
26948: DOUBLE
26949: LD_INT 1
26951: DEC
26952: ST_TO_ADDR
26953: LD_INT 6
26955: PUSH
26956: LD_VAR 0 8
26960: MINUS
26961: PUSH
26962: FOR_TO
26963: IFFALSE 27055
// begin if i = sort then
26965: LD_VAR 0 3
26969: PUSH
26970: LD_VAR 0 9
26974: EQUAL
26975: IFFALSE 26979
// break ;
26977: GO 27055
// if GetClass ( i ) = 4 then
26979: LD_VAR 0 3
26983: PPUSH
26984: CALL_OW 257
26988: PUSH
26989: LD_INT 4
26991: EQUAL
26992: IFFALSE 26996
// continue ;
26994: GO 26962
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26996: LD_ADDR_VAR 0 11
27000: PUSH
27001: LD_VAR 0 11
27005: PPUSH
27006: LD_VAR 0 11
27010: PUSH
27011: LD_INT 1
27013: PLUS
27014: PPUSH
27015: LD_VAR 0 9
27019: PUSH
27020: LD_VAR 0 3
27024: ARRAY
27025: PPUSH
27026: CALL_OW 2
27030: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27031: LD_ADDR_VAR 0 4
27035: PUSH
27036: LD_VAR 0 4
27040: PUSH
27041: LD_VAR 0 9
27045: PUSH
27046: LD_VAR 0 3
27050: ARRAY
27051: DIFF
27052: ST_TO_ADDR
// end ;
27053: GO 26962
27055: POP
27056: POP
// if p then
27057: LD_VAR 0 11
27061: IFFALSE 27086
// result := Replace ( result , 4 , p ) ;
27063: LD_ADDR_VAR 0 2
27067: PUSH
27068: LD_VAR 0 2
27072: PPUSH
27073: LD_INT 4
27075: PPUSH
27076: LD_VAR 0 11
27080: PPUSH
27081: CALL_OW 1
27085: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27086: LD_VAR 0 4
27090: PUSH
27091: LD_VAR 0 7
27095: PUSH
27096: LD_INT 6
27098: LESS
27099: AND
27100: IFFALSE 27288
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27102: LD_ADDR_VAR 0 9
27106: PUSH
27107: LD_VAR 0 4
27111: PUSH
27112: LD_VAR 0 8
27116: PUSH
27117: LD_VAR 0 7
27121: UNION
27122: DIFF
27123: PPUSH
27124: LD_INT 3
27126: PPUSH
27127: CALL 85166 0 2
27131: ST_TO_ADDR
// p := [ ] ;
27132: LD_ADDR_VAR 0 11
27136: PUSH
27137: EMPTY
27138: ST_TO_ADDR
// if sort then
27139: LD_VAR 0 9
27143: IFFALSE 27259
// for i = 1 to 6 - mech do
27145: LD_ADDR_VAR 0 3
27149: PUSH
27150: DOUBLE
27151: LD_INT 1
27153: DEC
27154: ST_TO_ADDR
27155: LD_INT 6
27157: PUSH
27158: LD_VAR 0 7
27162: MINUS
27163: PUSH
27164: FOR_TO
27165: IFFALSE 27257
// begin if i = sort then
27167: LD_VAR 0 3
27171: PUSH
27172: LD_VAR 0 9
27176: EQUAL
27177: IFFALSE 27181
// break ;
27179: GO 27257
// if GetClass ( i ) = 3 then
27181: LD_VAR 0 3
27185: PPUSH
27186: CALL_OW 257
27190: PUSH
27191: LD_INT 3
27193: EQUAL
27194: IFFALSE 27198
// continue ;
27196: GO 27164
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27198: LD_ADDR_VAR 0 11
27202: PUSH
27203: LD_VAR 0 11
27207: PPUSH
27208: LD_VAR 0 11
27212: PUSH
27213: LD_INT 1
27215: PLUS
27216: PPUSH
27217: LD_VAR 0 9
27221: PUSH
27222: LD_VAR 0 3
27226: ARRAY
27227: PPUSH
27228: CALL_OW 2
27232: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27233: LD_ADDR_VAR 0 4
27237: PUSH
27238: LD_VAR 0 4
27242: PUSH
27243: LD_VAR 0 9
27247: PUSH
27248: LD_VAR 0 3
27252: ARRAY
27253: DIFF
27254: ST_TO_ADDR
// end ;
27255: GO 27164
27257: POP
27258: POP
// if p then
27259: LD_VAR 0 11
27263: IFFALSE 27288
// result := Replace ( result , 3 , p ) ;
27265: LD_ADDR_VAR 0 2
27269: PUSH
27270: LD_VAR 0 2
27274: PPUSH
27275: LD_INT 3
27277: PPUSH
27278: LD_VAR 0 11
27282: PPUSH
27283: CALL_OW 1
27287: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27288: LD_VAR 0 4
27292: PUSH
27293: LD_INT 6
27295: GREATER
27296: PUSH
27297: LD_VAR 0 6
27301: PUSH
27302: LD_INT 6
27304: LESS
27305: AND
27306: IFFALSE 27500
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27308: LD_ADDR_VAR 0 9
27312: PUSH
27313: LD_VAR 0 4
27317: PUSH
27318: LD_VAR 0 8
27322: PUSH
27323: LD_VAR 0 7
27327: UNION
27328: PUSH
27329: LD_VAR 0 6
27333: UNION
27334: DIFF
27335: PPUSH
27336: LD_INT 2
27338: PPUSH
27339: CALL 85166 0 2
27343: ST_TO_ADDR
// p := [ ] ;
27344: LD_ADDR_VAR 0 11
27348: PUSH
27349: EMPTY
27350: ST_TO_ADDR
// if sort then
27351: LD_VAR 0 9
27355: IFFALSE 27471
// for i = 1 to 6 - eng do
27357: LD_ADDR_VAR 0 3
27361: PUSH
27362: DOUBLE
27363: LD_INT 1
27365: DEC
27366: ST_TO_ADDR
27367: LD_INT 6
27369: PUSH
27370: LD_VAR 0 6
27374: MINUS
27375: PUSH
27376: FOR_TO
27377: IFFALSE 27469
// begin if i = sort then
27379: LD_VAR 0 3
27383: PUSH
27384: LD_VAR 0 9
27388: EQUAL
27389: IFFALSE 27393
// break ;
27391: GO 27469
// if GetClass ( i ) = 2 then
27393: LD_VAR 0 3
27397: PPUSH
27398: CALL_OW 257
27402: PUSH
27403: LD_INT 2
27405: EQUAL
27406: IFFALSE 27410
// continue ;
27408: GO 27376
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27410: LD_ADDR_VAR 0 11
27414: PUSH
27415: LD_VAR 0 11
27419: PPUSH
27420: LD_VAR 0 11
27424: PUSH
27425: LD_INT 1
27427: PLUS
27428: PPUSH
27429: LD_VAR 0 9
27433: PUSH
27434: LD_VAR 0 3
27438: ARRAY
27439: PPUSH
27440: CALL_OW 2
27444: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27445: LD_ADDR_VAR 0 4
27449: PUSH
27450: LD_VAR 0 4
27454: PUSH
27455: LD_VAR 0 9
27459: PUSH
27460: LD_VAR 0 3
27464: ARRAY
27465: DIFF
27466: ST_TO_ADDR
// end ;
27467: GO 27376
27469: POP
27470: POP
// if p then
27471: LD_VAR 0 11
27475: IFFALSE 27500
// result := Replace ( result , 2 , p ) ;
27477: LD_ADDR_VAR 0 2
27481: PUSH
27482: LD_VAR 0 2
27486: PPUSH
27487: LD_INT 2
27489: PPUSH
27490: LD_VAR 0 11
27494: PPUSH
27495: CALL_OW 1
27499: ST_TO_ADDR
// end ; exit ;
27500: GO 28888
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27502: LD_EXP 116
27506: PUSH
27507: LD_EXP 115
27511: PUSH
27512: LD_VAR 0 1
27516: ARRAY
27517: ARRAY
27518: NOT
27519: PUSH
27520: LD_EXP 89
27524: PUSH
27525: LD_VAR 0 1
27529: ARRAY
27530: PPUSH
27531: LD_INT 30
27533: PUSH
27534: LD_INT 3
27536: PUSH
27537: EMPTY
27538: LIST
27539: LIST
27540: PPUSH
27541: CALL_OW 72
27545: AND
27546: PUSH
27547: LD_EXP 94
27551: PUSH
27552: LD_VAR 0 1
27556: ARRAY
27557: AND
27558: IFFALSE 28166
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27560: LD_ADDR_EXP 131
27564: PUSH
27565: LD_EXP 131
27569: PPUSH
27570: LD_VAR 0 1
27574: PPUSH
27575: LD_INT 5
27577: PPUSH
27578: CALL_OW 1
27582: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27583: LD_ADDR_VAR 0 2
27587: PUSH
27588: LD_INT 0
27590: PUSH
27591: LD_INT 0
27593: PUSH
27594: LD_INT 0
27596: PUSH
27597: LD_INT 0
27599: PUSH
27600: EMPTY
27601: LIST
27602: LIST
27603: LIST
27604: LIST
27605: ST_TO_ADDR
// if sci > 1 then
27606: LD_VAR 0 8
27610: PUSH
27611: LD_INT 1
27613: GREATER
27614: IFFALSE 27642
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27616: LD_ADDR_VAR 0 4
27620: PUSH
27621: LD_VAR 0 4
27625: PUSH
27626: LD_VAR 0 8
27630: PUSH
27631: LD_VAR 0 8
27635: PUSH
27636: LD_INT 1
27638: ARRAY
27639: DIFF
27640: DIFF
27641: ST_TO_ADDR
// if tmp and not sci then
27642: LD_VAR 0 4
27646: PUSH
27647: LD_VAR 0 8
27651: NOT
27652: AND
27653: IFFALSE 27722
// begin sort := SortBySkill ( tmp , 4 ) ;
27655: LD_ADDR_VAR 0 9
27659: PUSH
27660: LD_VAR 0 4
27664: PPUSH
27665: LD_INT 4
27667: PPUSH
27668: CALL 85166 0 2
27672: ST_TO_ADDR
// if sort then
27673: LD_VAR 0 9
27677: IFFALSE 27693
// p := sort [ 1 ] ;
27679: LD_ADDR_VAR 0 11
27683: PUSH
27684: LD_VAR 0 9
27688: PUSH
27689: LD_INT 1
27691: ARRAY
27692: ST_TO_ADDR
// if p then
27693: LD_VAR 0 11
27697: IFFALSE 27722
// result := Replace ( result , 4 , p ) ;
27699: LD_ADDR_VAR 0 2
27703: PUSH
27704: LD_VAR 0 2
27708: PPUSH
27709: LD_INT 4
27711: PPUSH
27712: LD_VAR 0 11
27716: PPUSH
27717: CALL_OW 1
27721: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27722: LD_ADDR_VAR 0 4
27726: PUSH
27727: LD_VAR 0 4
27731: PUSH
27732: LD_VAR 0 7
27736: DIFF
27737: ST_TO_ADDR
// if tmp and mech < 6 then
27738: LD_VAR 0 4
27742: PUSH
27743: LD_VAR 0 7
27747: PUSH
27748: LD_INT 6
27750: LESS
27751: AND
27752: IFFALSE 27940
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27754: LD_ADDR_VAR 0 9
27758: PUSH
27759: LD_VAR 0 4
27763: PUSH
27764: LD_VAR 0 8
27768: PUSH
27769: LD_VAR 0 7
27773: UNION
27774: DIFF
27775: PPUSH
27776: LD_INT 3
27778: PPUSH
27779: CALL 85166 0 2
27783: ST_TO_ADDR
// p := [ ] ;
27784: LD_ADDR_VAR 0 11
27788: PUSH
27789: EMPTY
27790: ST_TO_ADDR
// if sort then
27791: LD_VAR 0 9
27795: IFFALSE 27911
// for i = 1 to 6 - mech do
27797: LD_ADDR_VAR 0 3
27801: PUSH
27802: DOUBLE
27803: LD_INT 1
27805: DEC
27806: ST_TO_ADDR
27807: LD_INT 6
27809: PUSH
27810: LD_VAR 0 7
27814: MINUS
27815: PUSH
27816: FOR_TO
27817: IFFALSE 27909
// begin if i = sort then
27819: LD_VAR 0 3
27823: PUSH
27824: LD_VAR 0 9
27828: EQUAL
27829: IFFALSE 27833
// break ;
27831: GO 27909
// if GetClass ( i ) = 3 then
27833: LD_VAR 0 3
27837: PPUSH
27838: CALL_OW 257
27842: PUSH
27843: LD_INT 3
27845: EQUAL
27846: IFFALSE 27850
// continue ;
27848: GO 27816
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27850: LD_ADDR_VAR 0 11
27854: PUSH
27855: LD_VAR 0 11
27859: PPUSH
27860: LD_VAR 0 11
27864: PUSH
27865: LD_INT 1
27867: PLUS
27868: PPUSH
27869: LD_VAR 0 9
27873: PUSH
27874: LD_VAR 0 3
27878: ARRAY
27879: PPUSH
27880: CALL_OW 2
27884: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27885: LD_ADDR_VAR 0 4
27889: PUSH
27890: LD_VAR 0 4
27894: PUSH
27895: LD_VAR 0 9
27899: PUSH
27900: LD_VAR 0 3
27904: ARRAY
27905: DIFF
27906: ST_TO_ADDR
// end ;
27907: GO 27816
27909: POP
27910: POP
// if p then
27911: LD_VAR 0 11
27915: IFFALSE 27940
// result := Replace ( result , 3 , p ) ;
27917: LD_ADDR_VAR 0 2
27921: PUSH
27922: LD_VAR 0 2
27926: PPUSH
27927: LD_INT 3
27929: PPUSH
27930: LD_VAR 0 11
27934: PPUSH
27935: CALL_OW 1
27939: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27940: LD_ADDR_VAR 0 4
27944: PUSH
27945: LD_VAR 0 4
27949: PUSH
27950: LD_VAR 0 6
27954: DIFF
27955: ST_TO_ADDR
// if tmp and eng < 6 then
27956: LD_VAR 0 4
27960: PUSH
27961: LD_VAR 0 6
27965: PUSH
27966: LD_INT 6
27968: LESS
27969: AND
27970: IFFALSE 28164
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27972: LD_ADDR_VAR 0 9
27976: PUSH
27977: LD_VAR 0 4
27981: PUSH
27982: LD_VAR 0 8
27986: PUSH
27987: LD_VAR 0 7
27991: UNION
27992: PUSH
27993: LD_VAR 0 6
27997: UNION
27998: DIFF
27999: PPUSH
28000: LD_INT 2
28002: PPUSH
28003: CALL 85166 0 2
28007: ST_TO_ADDR
// p := [ ] ;
28008: LD_ADDR_VAR 0 11
28012: PUSH
28013: EMPTY
28014: ST_TO_ADDR
// if sort then
28015: LD_VAR 0 9
28019: IFFALSE 28135
// for i = 1 to 6 - eng do
28021: LD_ADDR_VAR 0 3
28025: PUSH
28026: DOUBLE
28027: LD_INT 1
28029: DEC
28030: ST_TO_ADDR
28031: LD_INT 6
28033: PUSH
28034: LD_VAR 0 6
28038: MINUS
28039: PUSH
28040: FOR_TO
28041: IFFALSE 28133
// begin if i = sort then
28043: LD_VAR 0 3
28047: PUSH
28048: LD_VAR 0 9
28052: EQUAL
28053: IFFALSE 28057
// break ;
28055: GO 28133
// if GetClass ( i ) = 2 then
28057: LD_VAR 0 3
28061: PPUSH
28062: CALL_OW 257
28066: PUSH
28067: LD_INT 2
28069: EQUAL
28070: IFFALSE 28074
// continue ;
28072: GO 28040
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28074: LD_ADDR_VAR 0 11
28078: PUSH
28079: LD_VAR 0 11
28083: PPUSH
28084: LD_VAR 0 11
28088: PUSH
28089: LD_INT 1
28091: PLUS
28092: PPUSH
28093: LD_VAR 0 9
28097: PUSH
28098: LD_VAR 0 3
28102: ARRAY
28103: PPUSH
28104: CALL_OW 2
28108: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28109: LD_ADDR_VAR 0 4
28113: PUSH
28114: LD_VAR 0 4
28118: PUSH
28119: LD_VAR 0 9
28123: PUSH
28124: LD_VAR 0 3
28128: ARRAY
28129: DIFF
28130: ST_TO_ADDR
// end ;
28131: GO 28040
28133: POP
28134: POP
// if p then
28135: LD_VAR 0 11
28139: IFFALSE 28164
// result := Replace ( result , 2 , p ) ;
28141: LD_ADDR_VAR 0 2
28145: PUSH
28146: LD_VAR 0 2
28150: PPUSH
28151: LD_INT 2
28153: PPUSH
28154: LD_VAR 0 11
28158: PPUSH
28159: CALL_OW 1
28163: ST_TO_ADDR
// end ; exit ;
28164: GO 28888
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28166: LD_EXP 116
28170: PUSH
28171: LD_EXP 115
28175: PUSH
28176: LD_VAR 0 1
28180: ARRAY
28181: ARRAY
28182: NOT
28183: PUSH
28184: LD_EXP 89
28188: PUSH
28189: LD_VAR 0 1
28193: ARRAY
28194: PPUSH
28195: LD_INT 30
28197: PUSH
28198: LD_INT 3
28200: PUSH
28201: EMPTY
28202: LIST
28203: LIST
28204: PPUSH
28205: CALL_OW 72
28209: AND
28210: PUSH
28211: LD_EXP 94
28215: PUSH
28216: LD_VAR 0 1
28220: ARRAY
28221: NOT
28222: AND
28223: IFFALSE 28888
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28225: LD_ADDR_EXP 131
28229: PUSH
28230: LD_EXP 131
28234: PPUSH
28235: LD_VAR 0 1
28239: PPUSH
28240: LD_INT 6
28242: PPUSH
28243: CALL_OW 1
28247: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28248: LD_ADDR_VAR 0 2
28252: PUSH
28253: LD_INT 0
28255: PUSH
28256: LD_INT 0
28258: PUSH
28259: LD_INT 0
28261: PUSH
28262: LD_INT 0
28264: PUSH
28265: EMPTY
28266: LIST
28267: LIST
28268: LIST
28269: LIST
28270: ST_TO_ADDR
// if sci >= 1 then
28271: LD_VAR 0 8
28275: PUSH
28276: LD_INT 1
28278: GREATEREQUAL
28279: IFFALSE 28301
// tmp := tmp diff sci [ 1 ] ;
28281: LD_ADDR_VAR 0 4
28285: PUSH
28286: LD_VAR 0 4
28290: PUSH
28291: LD_VAR 0 8
28295: PUSH
28296: LD_INT 1
28298: ARRAY
28299: DIFF
28300: ST_TO_ADDR
// if tmp and not sci then
28301: LD_VAR 0 4
28305: PUSH
28306: LD_VAR 0 8
28310: NOT
28311: AND
28312: IFFALSE 28381
// begin sort := SortBySkill ( tmp , 4 ) ;
28314: LD_ADDR_VAR 0 9
28318: PUSH
28319: LD_VAR 0 4
28323: PPUSH
28324: LD_INT 4
28326: PPUSH
28327: CALL 85166 0 2
28331: ST_TO_ADDR
// if sort then
28332: LD_VAR 0 9
28336: IFFALSE 28352
// p := sort [ 1 ] ;
28338: LD_ADDR_VAR 0 11
28342: PUSH
28343: LD_VAR 0 9
28347: PUSH
28348: LD_INT 1
28350: ARRAY
28351: ST_TO_ADDR
// if p then
28352: LD_VAR 0 11
28356: IFFALSE 28381
// result := Replace ( result , 4 , p ) ;
28358: LD_ADDR_VAR 0 2
28362: PUSH
28363: LD_VAR 0 2
28367: PPUSH
28368: LD_INT 4
28370: PPUSH
28371: LD_VAR 0 11
28375: PPUSH
28376: CALL_OW 1
28380: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28381: LD_ADDR_VAR 0 4
28385: PUSH
28386: LD_VAR 0 4
28390: PUSH
28391: LD_VAR 0 7
28395: DIFF
28396: ST_TO_ADDR
// if tmp and mech < 6 then
28397: LD_VAR 0 4
28401: PUSH
28402: LD_VAR 0 7
28406: PUSH
28407: LD_INT 6
28409: LESS
28410: AND
28411: IFFALSE 28593
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28413: LD_ADDR_VAR 0 9
28417: PUSH
28418: LD_VAR 0 4
28422: PUSH
28423: LD_VAR 0 7
28427: DIFF
28428: PPUSH
28429: LD_INT 3
28431: PPUSH
28432: CALL 85166 0 2
28436: ST_TO_ADDR
// p := [ ] ;
28437: LD_ADDR_VAR 0 11
28441: PUSH
28442: EMPTY
28443: ST_TO_ADDR
// if sort then
28444: LD_VAR 0 9
28448: IFFALSE 28564
// for i = 1 to 6 - mech do
28450: LD_ADDR_VAR 0 3
28454: PUSH
28455: DOUBLE
28456: LD_INT 1
28458: DEC
28459: ST_TO_ADDR
28460: LD_INT 6
28462: PUSH
28463: LD_VAR 0 7
28467: MINUS
28468: PUSH
28469: FOR_TO
28470: IFFALSE 28562
// begin if i = sort then
28472: LD_VAR 0 3
28476: PUSH
28477: LD_VAR 0 9
28481: EQUAL
28482: IFFALSE 28486
// break ;
28484: GO 28562
// if GetClass ( i ) = 3 then
28486: LD_VAR 0 3
28490: PPUSH
28491: CALL_OW 257
28495: PUSH
28496: LD_INT 3
28498: EQUAL
28499: IFFALSE 28503
// continue ;
28501: GO 28469
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28503: LD_ADDR_VAR 0 11
28507: PUSH
28508: LD_VAR 0 11
28512: PPUSH
28513: LD_VAR 0 11
28517: PUSH
28518: LD_INT 1
28520: PLUS
28521: PPUSH
28522: LD_VAR 0 9
28526: PUSH
28527: LD_VAR 0 3
28531: ARRAY
28532: PPUSH
28533: CALL_OW 2
28537: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28538: LD_ADDR_VAR 0 4
28542: PUSH
28543: LD_VAR 0 4
28547: PUSH
28548: LD_VAR 0 9
28552: PUSH
28553: LD_VAR 0 3
28557: ARRAY
28558: DIFF
28559: ST_TO_ADDR
// end ;
28560: GO 28469
28562: POP
28563: POP
// if p then
28564: LD_VAR 0 11
28568: IFFALSE 28593
// result := Replace ( result , 3 , p ) ;
28570: LD_ADDR_VAR 0 2
28574: PUSH
28575: LD_VAR 0 2
28579: PPUSH
28580: LD_INT 3
28582: PPUSH
28583: LD_VAR 0 11
28587: PPUSH
28588: CALL_OW 1
28592: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28593: LD_ADDR_VAR 0 4
28597: PUSH
28598: LD_VAR 0 4
28602: PUSH
28603: LD_VAR 0 6
28607: DIFF
28608: ST_TO_ADDR
// if tmp and eng < 4 then
28609: LD_VAR 0 4
28613: PUSH
28614: LD_VAR 0 6
28618: PUSH
28619: LD_INT 4
28621: LESS
28622: AND
28623: IFFALSE 28813
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28625: LD_ADDR_VAR 0 9
28629: PUSH
28630: LD_VAR 0 4
28634: PUSH
28635: LD_VAR 0 7
28639: PUSH
28640: LD_VAR 0 6
28644: UNION
28645: DIFF
28646: PPUSH
28647: LD_INT 2
28649: PPUSH
28650: CALL 85166 0 2
28654: ST_TO_ADDR
// p := [ ] ;
28655: LD_ADDR_VAR 0 11
28659: PUSH
28660: EMPTY
28661: ST_TO_ADDR
// if sort then
28662: LD_VAR 0 9
28666: IFFALSE 28782
// for i = 1 to 4 - eng do
28668: LD_ADDR_VAR 0 3
28672: PUSH
28673: DOUBLE
28674: LD_INT 1
28676: DEC
28677: ST_TO_ADDR
28678: LD_INT 4
28680: PUSH
28681: LD_VAR 0 6
28685: MINUS
28686: PUSH
28687: FOR_TO
28688: IFFALSE 28780
// begin if i = sort then
28690: LD_VAR 0 3
28694: PUSH
28695: LD_VAR 0 9
28699: EQUAL
28700: IFFALSE 28704
// break ;
28702: GO 28780
// if GetClass ( i ) = 2 then
28704: LD_VAR 0 3
28708: PPUSH
28709: CALL_OW 257
28713: PUSH
28714: LD_INT 2
28716: EQUAL
28717: IFFALSE 28721
// continue ;
28719: GO 28687
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28721: LD_ADDR_VAR 0 11
28725: PUSH
28726: LD_VAR 0 11
28730: PPUSH
28731: LD_VAR 0 11
28735: PUSH
28736: LD_INT 1
28738: PLUS
28739: PPUSH
28740: LD_VAR 0 9
28744: PUSH
28745: LD_VAR 0 3
28749: ARRAY
28750: PPUSH
28751: CALL_OW 2
28755: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28756: LD_ADDR_VAR 0 4
28760: PUSH
28761: LD_VAR 0 4
28765: PUSH
28766: LD_VAR 0 9
28770: PUSH
28771: LD_VAR 0 3
28775: ARRAY
28776: DIFF
28777: ST_TO_ADDR
// end ;
28778: GO 28687
28780: POP
28781: POP
// if p then
28782: LD_VAR 0 11
28786: IFFALSE 28811
// result := Replace ( result , 2 , p ) ;
28788: LD_ADDR_VAR 0 2
28792: PUSH
28793: LD_VAR 0 2
28797: PPUSH
28798: LD_INT 2
28800: PPUSH
28801: LD_VAR 0 11
28805: PPUSH
28806: CALL_OW 1
28810: ST_TO_ADDR
// end else
28811: GO 28857
// for i = eng downto 5 do
28813: LD_ADDR_VAR 0 3
28817: PUSH
28818: DOUBLE
28819: LD_VAR 0 6
28823: INC
28824: ST_TO_ADDR
28825: LD_INT 5
28827: PUSH
28828: FOR_DOWNTO
28829: IFFALSE 28855
// tmp := tmp union eng [ i ] ;
28831: LD_ADDR_VAR 0 4
28835: PUSH
28836: LD_VAR 0 4
28840: PUSH
28841: LD_VAR 0 6
28845: PUSH
28846: LD_VAR 0 3
28850: ARRAY
28851: UNION
28852: ST_TO_ADDR
28853: GO 28828
28855: POP
28856: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28857: LD_ADDR_VAR 0 2
28861: PUSH
28862: LD_VAR 0 2
28866: PPUSH
28867: LD_INT 1
28869: PPUSH
28870: LD_VAR 0 4
28874: PUSH
28875: LD_VAR 0 5
28879: DIFF
28880: PPUSH
28881: CALL_OW 1
28885: ST_TO_ADDR
// exit ;
28886: GO 28888
// end ; end ;
28888: LD_VAR 0 2
28892: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28893: LD_INT 0
28895: PPUSH
28896: PPUSH
28897: PPUSH
// if not mc_bases then
28898: LD_EXP 89
28902: NOT
28903: IFFALSE 28907
// exit ;
28905: GO 29013
// for i = 1 to mc_bases do
28907: LD_ADDR_VAR 0 2
28911: PUSH
28912: DOUBLE
28913: LD_INT 1
28915: DEC
28916: ST_TO_ADDR
28917: LD_EXP 89
28921: PUSH
28922: FOR_TO
28923: IFFALSE 29004
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28925: LD_ADDR_VAR 0 3
28929: PUSH
28930: LD_EXP 89
28934: PUSH
28935: LD_VAR 0 2
28939: ARRAY
28940: PPUSH
28941: LD_INT 21
28943: PUSH
28944: LD_INT 3
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 3
28953: PUSH
28954: LD_INT 24
28956: PUSH
28957: LD_INT 1000
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: PUSH
28964: EMPTY
28965: LIST
28966: LIST
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PPUSH
28972: CALL_OW 72
28976: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28977: LD_ADDR_EXP 90
28981: PUSH
28982: LD_EXP 90
28986: PPUSH
28987: LD_VAR 0 2
28991: PPUSH
28992: LD_VAR 0 3
28996: PPUSH
28997: CALL_OW 1
29001: ST_TO_ADDR
// end ;
29002: GO 28922
29004: POP
29005: POP
// RaiseSailEvent ( 101 ) ;
29006: LD_INT 101
29008: PPUSH
29009: CALL_OW 427
// end ;
29013: LD_VAR 0 1
29017: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29018: LD_INT 0
29020: PPUSH
29021: PPUSH
29022: PPUSH
29023: PPUSH
29024: PPUSH
29025: PPUSH
29026: PPUSH
// if not mc_bases then
29027: LD_EXP 89
29031: NOT
29032: IFFALSE 29036
// exit ;
29034: GO 29598
// for i = 1 to mc_bases do
29036: LD_ADDR_VAR 0 2
29040: PUSH
29041: DOUBLE
29042: LD_INT 1
29044: DEC
29045: ST_TO_ADDR
29046: LD_EXP 89
29050: PUSH
29051: FOR_TO
29052: IFFALSE 29589
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
29054: LD_ADDR_VAR 0 5
29058: PUSH
29059: LD_EXP 89
29063: PUSH
29064: LD_VAR 0 2
29068: ARRAY
29069: PUSH
29070: LD_EXP 118
29074: PUSH
29075: LD_VAR 0 2
29079: ARRAY
29080: UNION
29081: PPUSH
29082: LD_INT 21
29084: PUSH
29085: LD_INT 1
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 1
29094: PUSH
29095: LD_INT 3
29097: PUSH
29098: LD_INT 54
29100: PUSH
29101: EMPTY
29102: LIST
29103: PUSH
29104: EMPTY
29105: LIST
29106: LIST
29107: PUSH
29108: LD_INT 3
29110: PUSH
29111: LD_INT 24
29113: PUSH
29114: LD_INT 800
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: EMPTY
29126: LIST
29127: LIST
29128: LIST
29129: PUSH
29130: EMPTY
29131: LIST
29132: LIST
29133: PPUSH
29134: CALL_OW 72
29138: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29139: LD_ADDR_VAR 0 6
29143: PUSH
29144: LD_EXP 89
29148: PUSH
29149: LD_VAR 0 2
29153: ARRAY
29154: PPUSH
29155: LD_INT 21
29157: PUSH
29158: LD_INT 1
29160: PUSH
29161: EMPTY
29162: LIST
29163: LIST
29164: PUSH
29165: LD_INT 1
29167: PUSH
29168: LD_INT 3
29170: PUSH
29171: LD_INT 54
29173: PUSH
29174: EMPTY
29175: LIST
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 3
29183: PUSH
29184: LD_INT 24
29186: PUSH
29187: LD_INT 250
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: LIST
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PPUSH
29207: CALL_OW 72
29211: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29212: LD_ADDR_VAR 0 7
29216: PUSH
29217: LD_VAR 0 5
29221: PUSH
29222: LD_VAR 0 6
29226: DIFF
29227: ST_TO_ADDR
// if not need_heal_1 then
29228: LD_VAR 0 6
29232: NOT
29233: IFFALSE 29266
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29235: LD_ADDR_EXP 92
29239: PUSH
29240: LD_EXP 92
29244: PPUSH
29245: LD_VAR 0 2
29249: PUSH
29250: LD_INT 1
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PPUSH
29257: EMPTY
29258: PPUSH
29259: CALL 55617 0 3
29263: ST_TO_ADDR
29264: GO 29336
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29266: LD_ADDR_EXP 92
29270: PUSH
29271: LD_EXP 92
29275: PPUSH
29276: LD_VAR 0 2
29280: PUSH
29281: LD_INT 1
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PPUSH
29288: LD_EXP 92
29292: PUSH
29293: LD_VAR 0 2
29297: ARRAY
29298: PUSH
29299: LD_INT 1
29301: ARRAY
29302: PPUSH
29303: LD_INT 3
29305: PUSH
29306: LD_INT 24
29308: PUSH
29309: LD_INT 1000
29311: PUSH
29312: EMPTY
29313: LIST
29314: LIST
29315: PUSH
29316: EMPTY
29317: LIST
29318: LIST
29319: PPUSH
29320: CALL_OW 72
29324: PUSH
29325: LD_VAR 0 6
29329: UNION
29330: PPUSH
29331: CALL 55617 0 3
29335: ST_TO_ADDR
// if not need_heal_2 then
29336: LD_VAR 0 7
29340: NOT
29341: IFFALSE 29374
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29343: LD_ADDR_EXP 92
29347: PUSH
29348: LD_EXP 92
29352: PPUSH
29353: LD_VAR 0 2
29357: PUSH
29358: LD_INT 2
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PPUSH
29365: EMPTY
29366: PPUSH
29367: CALL 55617 0 3
29371: ST_TO_ADDR
29372: GO 29406
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29374: LD_ADDR_EXP 92
29378: PUSH
29379: LD_EXP 92
29383: PPUSH
29384: LD_VAR 0 2
29388: PUSH
29389: LD_INT 2
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PPUSH
29396: LD_VAR 0 7
29400: PPUSH
29401: CALL 55617 0 3
29405: ST_TO_ADDR
// if need_heal_2 then
29406: LD_VAR 0 7
29410: IFFALSE 29571
// for j in need_heal_2 do
29412: LD_ADDR_VAR 0 3
29416: PUSH
29417: LD_VAR 0 7
29421: PUSH
29422: FOR_IN
29423: IFFALSE 29569
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29425: LD_ADDR_VAR 0 5
29429: PUSH
29430: LD_EXP 89
29434: PUSH
29435: LD_VAR 0 2
29439: ARRAY
29440: PPUSH
29441: LD_INT 2
29443: PUSH
29444: LD_INT 30
29446: PUSH
29447: LD_INT 6
29449: PUSH
29450: EMPTY
29451: LIST
29452: LIST
29453: PUSH
29454: LD_INT 30
29456: PUSH
29457: LD_INT 7
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: LD_INT 30
29466: PUSH
29467: LD_INT 8
29469: PUSH
29470: EMPTY
29471: LIST
29472: LIST
29473: PUSH
29474: LD_INT 30
29476: PUSH
29477: LD_INT 0
29479: PUSH
29480: EMPTY
29481: LIST
29482: LIST
29483: PUSH
29484: LD_INT 30
29486: PUSH
29487: LD_INT 1
29489: PUSH
29490: EMPTY
29491: LIST
29492: LIST
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: PPUSH
29502: CALL_OW 72
29506: ST_TO_ADDR
// if tmp then
29507: LD_VAR 0 5
29511: IFFALSE 29567
// begin k := NearestUnitToUnit ( tmp , j ) ;
29513: LD_ADDR_VAR 0 4
29517: PUSH
29518: LD_VAR 0 5
29522: PPUSH
29523: LD_VAR 0 3
29527: PPUSH
29528: CALL_OW 74
29532: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29533: LD_VAR 0 3
29537: PPUSH
29538: LD_VAR 0 4
29542: PPUSH
29543: CALL_OW 296
29547: PUSH
29548: LD_INT 5
29550: GREATER
29551: IFFALSE 29567
// ComMoveUnit ( j , k ) ;
29553: LD_VAR 0 3
29557: PPUSH
29558: LD_VAR 0 4
29562: PPUSH
29563: CALL_OW 112
// end ; end ;
29567: GO 29422
29569: POP
29570: POP
// if not need_heal_1 and not need_heal_2 then
29571: LD_VAR 0 6
29575: NOT
29576: PUSH
29577: LD_VAR 0 7
29581: NOT
29582: AND
29583: IFFALSE 29587
// continue ;
29585: GO 29051
// end ;
29587: GO 29051
29589: POP
29590: POP
// RaiseSailEvent ( 102 ) ;
29591: LD_INT 102
29593: PPUSH
29594: CALL_OW 427
// end ;
29598: LD_VAR 0 1
29602: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29603: LD_INT 0
29605: PPUSH
29606: PPUSH
29607: PPUSH
29608: PPUSH
29609: PPUSH
29610: PPUSH
29611: PPUSH
29612: PPUSH
// if not mc_bases then
29613: LD_EXP 89
29617: NOT
29618: IFFALSE 29622
// exit ;
29620: GO 30457
// for i = 1 to mc_bases do
29622: LD_ADDR_VAR 0 2
29626: PUSH
29627: DOUBLE
29628: LD_INT 1
29630: DEC
29631: ST_TO_ADDR
29632: LD_EXP 89
29636: PUSH
29637: FOR_TO
29638: IFFALSE 30455
// begin if not mc_building_need_repair [ i ] then
29640: LD_EXP 90
29644: PUSH
29645: LD_VAR 0 2
29649: ARRAY
29650: NOT
29651: IFFALSE 29825
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29653: LD_ADDR_VAR 0 6
29657: PUSH
29658: LD_EXP 108
29662: PUSH
29663: LD_VAR 0 2
29667: ARRAY
29668: PPUSH
29669: LD_INT 3
29671: PUSH
29672: LD_INT 24
29674: PUSH
29675: LD_INT 1000
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: LD_INT 2
29688: PUSH
29689: LD_INT 34
29691: PUSH
29692: LD_INT 13
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 34
29701: PUSH
29702: LD_INT 52
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: LIST
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: PPUSH
29718: CALL_OW 72
29722: ST_TO_ADDR
// if cranes then
29723: LD_VAR 0 6
29727: IFFALSE 29789
// for j in cranes do
29729: LD_ADDR_VAR 0 3
29733: PUSH
29734: LD_VAR 0 6
29738: PUSH
29739: FOR_IN
29740: IFFALSE 29787
// if not IsInArea ( j , mc_parking [ i ] ) then
29742: LD_VAR 0 3
29746: PPUSH
29747: LD_EXP 113
29751: PUSH
29752: LD_VAR 0 2
29756: ARRAY
29757: PPUSH
29758: CALL_OW 308
29762: NOT
29763: IFFALSE 29785
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29765: LD_VAR 0 3
29769: PPUSH
29770: LD_EXP 113
29774: PUSH
29775: LD_VAR 0 2
29779: ARRAY
29780: PPUSH
29781: CALL_OW 113
29785: GO 29739
29787: POP
29788: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29789: LD_ADDR_EXP 91
29793: PUSH
29794: LD_EXP 91
29798: PPUSH
29799: LD_VAR 0 2
29803: PPUSH
29804: EMPTY
29805: PPUSH
29806: CALL_OW 1
29810: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29811: LD_VAR 0 2
29815: PPUSH
29816: LD_INT 101
29818: PPUSH
29819: CALL 24726 0 2
// continue ;
29823: GO 29637
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29825: LD_ADDR_EXP 95
29829: PUSH
29830: LD_EXP 95
29834: PPUSH
29835: LD_VAR 0 2
29839: PPUSH
29840: EMPTY
29841: PPUSH
29842: CALL_OW 1
29846: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29847: LD_VAR 0 2
29851: PPUSH
29852: LD_INT 103
29854: PPUSH
29855: CALL 24726 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
29859: LD_ADDR_VAR 0 5
29863: PUSH
29864: LD_EXP 89
29868: PUSH
29869: LD_VAR 0 2
29873: ARRAY
29874: PUSH
29875: LD_EXP 118
29879: PUSH
29880: LD_VAR 0 2
29884: ARRAY
29885: UNION
29886: PPUSH
29887: LD_INT 2
29889: PUSH
29890: LD_INT 25
29892: PUSH
29893: LD_INT 2
29895: PUSH
29896: EMPTY
29897: LIST
29898: LIST
29899: PUSH
29900: LD_INT 25
29902: PUSH
29903: LD_INT 16
29905: PUSH
29906: EMPTY
29907: LIST
29908: LIST
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: LIST
29914: PUSH
29915: EMPTY
29916: LIST
29917: PPUSH
29918: CALL_OW 72
29922: PUSH
29923: LD_EXP 92
29927: PUSH
29928: LD_VAR 0 2
29932: ARRAY
29933: PUSH
29934: LD_INT 1
29936: ARRAY
29937: PUSH
29938: LD_EXP 92
29942: PUSH
29943: LD_VAR 0 2
29947: ARRAY
29948: PUSH
29949: LD_INT 2
29951: ARRAY
29952: UNION
29953: DIFF
29954: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29955: LD_ADDR_VAR 0 6
29959: PUSH
29960: LD_EXP 108
29964: PUSH
29965: LD_VAR 0 2
29969: ARRAY
29970: PPUSH
29971: LD_INT 2
29973: PUSH
29974: LD_INT 34
29976: PUSH
29977: LD_INT 13
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: PUSH
29984: LD_INT 34
29986: PUSH
29987: LD_INT 52
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: LIST
29998: PPUSH
29999: CALL_OW 72
30003: ST_TO_ADDR
// if cranes then
30004: LD_VAR 0 6
30008: IFFALSE 30144
// begin for j in cranes do
30010: LD_ADDR_VAR 0 3
30014: PUSH
30015: LD_VAR 0 6
30019: PUSH
30020: FOR_IN
30021: IFFALSE 30142
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
30023: LD_VAR 0 3
30027: PPUSH
30028: CALL_OW 256
30032: PUSH
30033: LD_INT 500
30035: GREATEREQUAL
30036: PUSH
30037: LD_VAR 0 3
30041: PPUSH
30042: CALL_OW 314
30046: NOT
30047: AND
30048: IFFALSE 30082
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30050: LD_VAR 0 3
30054: PPUSH
30055: LD_EXP 90
30059: PUSH
30060: LD_VAR 0 2
30064: ARRAY
30065: PPUSH
30066: LD_VAR 0 3
30070: PPUSH
30071: CALL_OW 74
30075: PPUSH
30076: CALL_OW 130
30080: GO 30140
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30082: LD_VAR 0 3
30086: PPUSH
30087: CALL_OW 256
30091: PUSH
30092: LD_INT 500
30094: LESS
30095: PUSH
30096: LD_VAR 0 3
30100: PPUSH
30101: LD_EXP 113
30105: PUSH
30106: LD_VAR 0 2
30110: ARRAY
30111: PPUSH
30112: CALL_OW 308
30116: NOT
30117: AND
30118: IFFALSE 30140
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30120: LD_VAR 0 3
30124: PPUSH
30125: LD_EXP 113
30129: PUSH
30130: LD_VAR 0 2
30134: ARRAY
30135: PPUSH
30136: CALL_OW 113
30140: GO 30020
30142: POP
30143: POP
// end ; if tmp > 3 then
30144: LD_VAR 0 5
30148: PUSH
30149: LD_INT 3
30151: GREATER
30152: IFFALSE 30172
// tmp := ShrinkArray ( tmp , 4 ) ;
30154: LD_ADDR_VAR 0 5
30158: PUSH
30159: LD_VAR 0 5
30163: PPUSH
30164: LD_INT 4
30166: PPUSH
30167: CALL 86856 0 2
30171: ST_TO_ADDR
// if not tmp then
30172: LD_VAR 0 5
30176: NOT
30177: IFFALSE 30181
// continue ;
30179: GO 29637
// for j in tmp do
30181: LD_ADDR_VAR 0 3
30185: PUSH
30186: LD_VAR 0 5
30190: PUSH
30191: FOR_IN
30192: IFFALSE 30451
// begin if IsInUnit ( j ) then
30194: LD_VAR 0 3
30198: PPUSH
30199: CALL_OW 310
30203: IFFALSE 30214
// ComExitBuilding ( j ) ;
30205: LD_VAR 0 3
30209: PPUSH
30210: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30214: LD_VAR 0 3
30218: PUSH
30219: LD_EXP 91
30223: PUSH
30224: LD_VAR 0 2
30228: ARRAY
30229: IN
30230: NOT
30231: IFFALSE 30289
// begin SetTag ( j , 101 ) ;
30233: LD_VAR 0 3
30237: PPUSH
30238: LD_INT 101
30240: PPUSH
30241: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30245: LD_ADDR_EXP 91
30249: PUSH
30250: LD_EXP 91
30254: PPUSH
30255: LD_VAR 0 2
30259: PUSH
30260: LD_EXP 91
30264: PUSH
30265: LD_VAR 0 2
30269: ARRAY
30270: PUSH
30271: LD_INT 1
30273: PLUS
30274: PUSH
30275: EMPTY
30276: LIST
30277: LIST
30278: PPUSH
30279: LD_VAR 0 3
30283: PPUSH
30284: CALL 55617 0 3
30288: ST_TO_ADDR
// end ; wait ( 1 ) ;
30289: LD_INT 1
30291: PPUSH
30292: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30296: LD_ADDR_VAR 0 7
30300: PUSH
30301: LD_EXP 90
30305: PUSH
30306: LD_VAR 0 2
30310: ARRAY
30311: ST_TO_ADDR
// if mc_scan [ i ] then
30312: LD_EXP 112
30316: PUSH
30317: LD_VAR 0 2
30321: ARRAY
30322: IFFALSE 30384
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30324: LD_ADDR_VAR 0 7
30328: PUSH
30329: LD_EXP 90
30333: PUSH
30334: LD_VAR 0 2
30338: ARRAY
30339: PPUSH
30340: LD_INT 3
30342: PUSH
30343: LD_INT 30
30345: PUSH
30346: LD_INT 32
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: LD_INT 30
30355: PUSH
30356: LD_INT 33
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: LD_INT 30
30365: PUSH
30366: LD_INT 31
30368: PUSH
30369: EMPTY
30370: LIST
30371: LIST
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: LIST
30377: LIST
30378: PPUSH
30379: CALL_OW 72
30383: ST_TO_ADDR
// if not to_repair_tmp then
30384: LD_VAR 0 7
30388: NOT
30389: IFFALSE 30393
// continue ;
30391: GO 30191
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30393: LD_ADDR_VAR 0 8
30397: PUSH
30398: LD_VAR 0 7
30402: PPUSH
30403: LD_VAR 0 3
30407: PPUSH
30408: CALL_OW 74
30412: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
30413: LD_VAR 0 8
30417: PPUSH
30418: LD_INT 16
30420: PPUSH
30421: CALL 58210 0 2
30425: PUSH
30426: LD_INT 4
30428: ARRAY
30429: PUSH
30430: LD_INT 5
30432: LESS
30433: IFFALSE 30449
// ComRepairBuilding ( j , to_repair ) ;
30435: LD_VAR 0 3
30439: PPUSH
30440: LD_VAR 0 8
30444: PPUSH
30445: CALL_OW 130
// end ;
30449: GO 30191
30451: POP
30452: POP
// end ;
30453: GO 29637
30455: POP
30456: POP
// end ;
30457: LD_VAR 0 1
30461: RET
// export function MC_Heal ; var i , j , tmp ; begin
30462: LD_INT 0
30464: PPUSH
30465: PPUSH
30466: PPUSH
30467: PPUSH
// if not mc_bases then
30468: LD_EXP 89
30472: NOT
30473: IFFALSE 30477
// exit ;
30475: GO 30879
// for i = 1 to mc_bases do
30477: LD_ADDR_VAR 0 2
30481: PUSH
30482: DOUBLE
30483: LD_INT 1
30485: DEC
30486: ST_TO_ADDR
30487: LD_EXP 89
30491: PUSH
30492: FOR_TO
30493: IFFALSE 30877
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30495: LD_EXP 92
30499: PUSH
30500: LD_VAR 0 2
30504: ARRAY
30505: PUSH
30506: LD_INT 1
30508: ARRAY
30509: NOT
30510: PUSH
30511: LD_EXP 92
30515: PUSH
30516: LD_VAR 0 2
30520: ARRAY
30521: PUSH
30522: LD_INT 2
30524: ARRAY
30525: NOT
30526: AND
30527: IFFALSE 30565
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30529: LD_ADDR_EXP 93
30533: PUSH
30534: LD_EXP 93
30538: PPUSH
30539: LD_VAR 0 2
30543: PPUSH
30544: EMPTY
30545: PPUSH
30546: CALL_OW 1
30550: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30551: LD_VAR 0 2
30555: PPUSH
30556: LD_INT 102
30558: PPUSH
30559: CALL 24726 0 2
// continue ;
30563: GO 30492
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30565: LD_ADDR_VAR 0 4
30569: PUSH
30570: LD_EXP 89
30574: PUSH
30575: LD_VAR 0 2
30579: ARRAY
30580: PPUSH
30581: LD_INT 25
30583: PUSH
30584: LD_INT 4
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PPUSH
30591: CALL_OW 72
30595: ST_TO_ADDR
// if not tmp then
30596: LD_VAR 0 4
30600: NOT
30601: IFFALSE 30605
// continue ;
30603: GO 30492
// if mc_taming [ i ] then
30605: LD_EXP 120
30609: PUSH
30610: LD_VAR 0 2
30614: ARRAY
30615: IFFALSE 30639
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30617: LD_ADDR_EXP 120
30621: PUSH
30622: LD_EXP 120
30626: PPUSH
30627: LD_VAR 0 2
30631: PPUSH
30632: EMPTY
30633: PPUSH
30634: CALL_OW 1
30638: ST_TO_ADDR
// for j in tmp do
30639: LD_ADDR_VAR 0 3
30643: PUSH
30644: LD_VAR 0 4
30648: PUSH
30649: FOR_IN
30650: IFFALSE 30873
// begin if IsInUnit ( j ) then
30652: LD_VAR 0 3
30656: PPUSH
30657: CALL_OW 310
30661: IFFALSE 30672
// ComExitBuilding ( j ) ;
30663: LD_VAR 0 3
30667: PPUSH
30668: CALL_OW 122
// if not j in mc_healers [ i ] then
30672: LD_VAR 0 3
30676: PUSH
30677: LD_EXP 93
30681: PUSH
30682: LD_VAR 0 2
30686: ARRAY
30687: IN
30688: NOT
30689: IFFALSE 30735
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30691: LD_ADDR_EXP 93
30695: PUSH
30696: LD_EXP 93
30700: PPUSH
30701: LD_VAR 0 2
30705: PUSH
30706: LD_EXP 93
30710: PUSH
30711: LD_VAR 0 2
30715: ARRAY
30716: PUSH
30717: LD_INT 1
30719: PLUS
30720: PUSH
30721: EMPTY
30722: LIST
30723: LIST
30724: PPUSH
30725: LD_VAR 0 3
30729: PPUSH
30730: CALL 55617 0 3
30734: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30735: LD_VAR 0 3
30739: PPUSH
30740: CALL_OW 110
30744: PUSH
30745: LD_INT 102
30747: NONEQUAL
30748: IFFALSE 30762
// SetTag ( j , 102 ) ;
30750: LD_VAR 0 3
30754: PPUSH
30755: LD_INT 102
30757: PPUSH
30758: CALL_OW 109
// Wait ( 3 ) ;
30762: LD_INT 3
30764: PPUSH
30765: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30769: LD_EXP 92
30773: PUSH
30774: LD_VAR 0 2
30778: ARRAY
30779: PUSH
30780: LD_INT 1
30782: ARRAY
30783: IFFALSE 30815
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30785: LD_VAR 0 3
30789: PPUSH
30790: LD_EXP 92
30794: PUSH
30795: LD_VAR 0 2
30799: ARRAY
30800: PUSH
30801: LD_INT 1
30803: ARRAY
30804: PUSH
30805: LD_INT 1
30807: ARRAY
30808: PPUSH
30809: CALL_OW 128
30813: GO 30871
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30815: LD_VAR 0 3
30819: PPUSH
30820: CALL_OW 314
30824: NOT
30825: PUSH
30826: LD_EXP 92
30830: PUSH
30831: LD_VAR 0 2
30835: ARRAY
30836: PUSH
30837: LD_INT 2
30839: ARRAY
30840: AND
30841: IFFALSE 30871
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30843: LD_VAR 0 3
30847: PPUSH
30848: LD_EXP 92
30852: PUSH
30853: LD_VAR 0 2
30857: ARRAY
30858: PUSH
30859: LD_INT 2
30861: ARRAY
30862: PUSH
30863: LD_INT 1
30865: ARRAY
30866: PPUSH
30867: CALL_OW 128
// end ;
30871: GO 30649
30873: POP
30874: POP
// end ;
30875: GO 30492
30877: POP
30878: POP
// end ;
30879: LD_VAR 0 1
30883: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30884: LD_INT 0
30886: PPUSH
30887: PPUSH
30888: PPUSH
30889: PPUSH
30890: PPUSH
// if not mc_bases then
30891: LD_EXP 89
30895: NOT
30896: IFFALSE 30900
// exit ;
30898: GO 32043
// for i = 1 to mc_bases do
30900: LD_ADDR_VAR 0 2
30904: PUSH
30905: DOUBLE
30906: LD_INT 1
30908: DEC
30909: ST_TO_ADDR
30910: LD_EXP 89
30914: PUSH
30915: FOR_TO
30916: IFFALSE 32041
// begin if mc_scan [ i ] then
30918: LD_EXP 112
30922: PUSH
30923: LD_VAR 0 2
30927: ARRAY
30928: IFFALSE 30932
// continue ;
30930: GO 30915
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30932: LD_EXP 94
30936: PUSH
30937: LD_VAR 0 2
30941: ARRAY
30942: NOT
30943: PUSH
30944: LD_EXP 96
30948: PUSH
30949: LD_VAR 0 2
30953: ARRAY
30954: NOT
30955: AND
30956: PUSH
30957: LD_EXP 95
30961: PUSH
30962: LD_VAR 0 2
30966: ARRAY
30967: AND
30968: IFFALSE 31006
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30970: LD_ADDR_EXP 95
30974: PUSH
30975: LD_EXP 95
30979: PPUSH
30980: LD_VAR 0 2
30984: PPUSH
30985: EMPTY
30986: PPUSH
30987: CALL_OW 1
30991: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30992: LD_VAR 0 2
30996: PPUSH
30997: LD_INT 103
30999: PPUSH
31000: CALL 24726 0 2
// continue ;
31004: GO 30915
// end ; if mc_construct_list [ i ] then
31006: LD_EXP 96
31010: PUSH
31011: LD_VAR 0 2
31015: ARRAY
31016: IFFALSE 31236
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31018: LD_ADDR_VAR 0 4
31022: PUSH
31023: LD_EXP 89
31027: PUSH
31028: LD_VAR 0 2
31032: ARRAY
31033: PPUSH
31034: LD_INT 25
31036: PUSH
31037: LD_INT 2
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PPUSH
31044: CALL_OW 72
31048: PUSH
31049: LD_EXP 91
31053: PUSH
31054: LD_VAR 0 2
31058: ARRAY
31059: DIFF
31060: ST_TO_ADDR
// if not tmp then
31061: LD_VAR 0 4
31065: NOT
31066: IFFALSE 31070
// continue ;
31068: GO 30915
// for j in tmp do
31070: LD_ADDR_VAR 0 3
31074: PUSH
31075: LD_VAR 0 4
31079: PUSH
31080: FOR_IN
31081: IFFALSE 31232
// begin if not mc_builders [ i ] then
31083: LD_EXP 95
31087: PUSH
31088: LD_VAR 0 2
31092: ARRAY
31093: NOT
31094: IFFALSE 31152
// begin SetTag ( j , 103 ) ;
31096: LD_VAR 0 3
31100: PPUSH
31101: LD_INT 103
31103: PPUSH
31104: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31108: LD_ADDR_EXP 95
31112: PUSH
31113: LD_EXP 95
31117: PPUSH
31118: LD_VAR 0 2
31122: PUSH
31123: LD_EXP 95
31127: PUSH
31128: LD_VAR 0 2
31132: ARRAY
31133: PUSH
31134: LD_INT 1
31136: PLUS
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PPUSH
31142: LD_VAR 0 3
31146: PPUSH
31147: CALL 55617 0 3
31151: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31152: LD_VAR 0 3
31156: PPUSH
31157: CALL_OW 310
31161: IFFALSE 31172
// ComExitBuilding ( j ) ;
31163: LD_VAR 0 3
31167: PPUSH
31168: CALL_OW 122
// wait ( 3 ) ;
31172: LD_INT 3
31174: PPUSH
31175: CALL_OW 67
// if not mc_construct_list [ i ] then
31179: LD_EXP 96
31183: PUSH
31184: LD_VAR 0 2
31188: ARRAY
31189: NOT
31190: IFFALSE 31194
// break ;
31192: GO 31232
// if not HasTask ( j ) then
31194: LD_VAR 0 3
31198: PPUSH
31199: CALL_OW 314
31203: NOT
31204: IFFALSE 31230
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31206: LD_VAR 0 3
31210: PPUSH
31211: LD_EXP 96
31215: PUSH
31216: LD_VAR 0 2
31220: ARRAY
31221: PUSH
31222: LD_INT 1
31224: ARRAY
31225: PPUSH
31226: CALL 58468 0 2
// end ;
31230: GO 31080
31232: POP
31233: POP
// end else
31234: GO 32039
// if mc_build_list [ i ] then
31236: LD_EXP 94
31240: PUSH
31241: LD_VAR 0 2
31245: ARRAY
31246: IFFALSE 32039
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31248: LD_ADDR_VAR 0 5
31252: PUSH
31253: LD_EXP 89
31257: PUSH
31258: LD_VAR 0 2
31262: ARRAY
31263: PPUSH
31264: LD_INT 2
31266: PUSH
31267: LD_INT 30
31269: PUSH
31270: LD_INT 0
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 30
31279: PUSH
31280: LD_INT 1
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: LIST
31291: PPUSH
31292: CALL_OW 72
31296: ST_TO_ADDR
// if depot then
31297: LD_VAR 0 5
31301: IFFALSE 31319
// depot := depot [ 1 ] else
31303: LD_ADDR_VAR 0 5
31307: PUSH
31308: LD_VAR 0 5
31312: PUSH
31313: LD_INT 1
31315: ARRAY
31316: ST_TO_ADDR
31317: GO 31327
// depot := 0 ;
31319: LD_ADDR_VAR 0 5
31323: PUSH
31324: LD_INT 0
31326: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31327: LD_EXP 94
31331: PUSH
31332: LD_VAR 0 2
31336: ARRAY
31337: PUSH
31338: LD_INT 1
31340: ARRAY
31341: PUSH
31342: LD_INT 1
31344: ARRAY
31345: PPUSH
31346: CALL 58298 0 1
31350: PUSH
31351: LD_EXP 89
31355: PUSH
31356: LD_VAR 0 2
31360: ARRAY
31361: PPUSH
31362: LD_INT 2
31364: PUSH
31365: LD_INT 30
31367: PUSH
31368: LD_INT 2
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 30
31377: PUSH
31378: LD_INT 3
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: LIST
31389: PPUSH
31390: CALL_OW 72
31394: NOT
31395: AND
31396: IFFALSE 31501
// begin for j = 1 to mc_build_list [ i ] do
31398: LD_ADDR_VAR 0 3
31402: PUSH
31403: DOUBLE
31404: LD_INT 1
31406: DEC
31407: ST_TO_ADDR
31408: LD_EXP 94
31412: PUSH
31413: LD_VAR 0 2
31417: ARRAY
31418: PUSH
31419: FOR_TO
31420: IFFALSE 31499
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31422: LD_EXP 94
31426: PUSH
31427: LD_VAR 0 2
31431: ARRAY
31432: PUSH
31433: LD_VAR 0 3
31437: ARRAY
31438: PUSH
31439: LD_INT 1
31441: ARRAY
31442: PUSH
31443: LD_INT 2
31445: EQUAL
31446: IFFALSE 31497
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31448: LD_ADDR_EXP 94
31452: PUSH
31453: LD_EXP 94
31457: PPUSH
31458: LD_VAR 0 2
31462: PPUSH
31463: LD_EXP 94
31467: PUSH
31468: LD_VAR 0 2
31472: ARRAY
31473: PPUSH
31474: LD_VAR 0 3
31478: PPUSH
31479: LD_INT 1
31481: PPUSH
31482: LD_INT 0
31484: PPUSH
31485: CALL 55035 0 4
31489: PPUSH
31490: CALL_OW 1
31494: ST_TO_ADDR
// break ;
31495: GO 31499
// end ;
31497: GO 31419
31499: POP
31500: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31501: LD_EXP 94
31505: PUSH
31506: LD_VAR 0 2
31510: ARRAY
31511: PUSH
31512: LD_INT 1
31514: ARRAY
31515: PUSH
31516: LD_INT 1
31518: ARRAY
31519: PUSH
31520: LD_INT 0
31522: EQUAL
31523: PUSH
31524: LD_VAR 0 5
31528: PUSH
31529: LD_VAR 0 5
31533: PPUSH
31534: LD_EXP 94
31538: PUSH
31539: LD_VAR 0 2
31543: ARRAY
31544: PUSH
31545: LD_INT 1
31547: ARRAY
31548: PUSH
31549: LD_INT 1
31551: ARRAY
31552: PPUSH
31553: LD_EXP 94
31557: PUSH
31558: LD_VAR 0 2
31562: ARRAY
31563: PUSH
31564: LD_INT 1
31566: ARRAY
31567: PUSH
31568: LD_INT 2
31570: ARRAY
31571: PPUSH
31572: LD_EXP 94
31576: PUSH
31577: LD_VAR 0 2
31581: ARRAY
31582: PUSH
31583: LD_INT 1
31585: ARRAY
31586: PUSH
31587: LD_INT 3
31589: ARRAY
31590: PPUSH
31591: LD_EXP 94
31595: PUSH
31596: LD_VAR 0 2
31600: ARRAY
31601: PUSH
31602: LD_INT 1
31604: ARRAY
31605: PUSH
31606: LD_INT 4
31608: ARRAY
31609: PPUSH
31610: CALL 63032 0 5
31614: AND
31615: OR
31616: IFFALSE 31897
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31618: LD_ADDR_VAR 0 4
31622: PUSH
31623: LD_EXP 89
31627: PUSH
31628: LD_VAR 0 2
31632: ARRAY
31633: PPUSH
31634: LD_INT 25
31636: PUSH
31637: LD_INT 2
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PPUSH
31644: CALL_OW 72
31648: PUSH
31649: LD_EXP 91
31653: PUSH
31654: LD_VAR 0 2
31658: ARRAY
31659: DIFF
31660: ST_TO_ADDR
// if not tmp then
31661: LD_VAR 0 4
31665: NOT
31666: IFFALSE 31670
// continue ;
31668: GO 30915
// for j in tmp do
31670: LD_ADDR_VAR 0 3
31674: PUSH
31675: LD_VAR 0 4
31679: PUSH
31680: FOR_IN
31681: IFFALSE 31893
// begin if not mc_builders [ i ] then
31683: LD_EXP 95
31687: PUSH
31688: LD_VAR 0 2
31692: ARRAY
31693: NOT
31694: IFFALSE 31752
// begin SetTag ( j , 103 ) ;
31696: LD_VAR 0 3
31700: PPUSH
31701: LD_INT 103
31703: PPUSH
31704: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31708: LD_ADDR_EXP 95
31712: PUSH
31713: LD_EXP 95
31717: PPUSH
31718: LD_VAR 0 2
31722: PUSH
31723: LD_EXP 95
31727: PUSH
31728: LD_VAR 0 2
31732: ARRAY
31733: PUSH
31734: LD_INT 1
31736: PLUS
31737: PUSH
31738: EMPTY
31739: LIST
31740: LIST
31741: PPUSH
31742: LD_VAR 0 3
31746: PPUSH
31747: CALL 55617 0 3
31751: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31752: LD_VAR 0 3
31756: PPUSH
31757: CALL_OW 310
31761: IFFALSE 31772
// ComExitBuilding ( j ) ;
31763: LD_VAR 0 3
31767: PPUSH
31768: CALL_OW 122
// wait ( 3 ) ;
31772: LD_INT 3
31774: PPUSH
31775: CALL_OW 67
// if not mc_build_list [ i ] then
31779: LD_EXP 94
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: NOT
31790: IFFALSE 31794
// break ;
31792: GO 31893
// if not HasTask ( j ) then
31794: LD_VAR 0 3
31798: PPUSH
31799: CALL_OW 314
31803: NOT
31804: IFFALSE 31891
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31806: LD_VAR 0 3
31810: PPUSH
31811: LD_EXP 94
31815: PUSH
31816: LD_VAR 0 2
31820: ARRAY
31821: PUSH
31822: LD_INT 1
31824: ARRAY
31825: PUSH
31826: LD_INT 1
31828: ARRAY
31829: PPUSH
31830: LD_EXP 94
31834: PUSH
31835: LD_VAR 0 2
31839: ARRAY
31840: PUSH
31841: LD_INT 1
31843: ARRAY
31844: PUSH
31845: LD_INT 2
31847: ARRAY
31848: PPUSH
31849: LD_EXP 94
31853: PUSH
31854: LD_VAR 0 2
31858: ARRAY
31859: PUSH
31860: LD_INT 1
31862: ARRAY
31863: PUSH
31864: LD_INT 3
31866: ARRAY
31867: PPUSH
31868: LD_EXP 94
31872: PUSH
31873: LD_VAR 0 2
31877: ARRAY
31878: PUSH
31879: LD_INT 1
31881: ARRAY
31882: PUSH
31883: LD_INT 4
31885: ARRAY
31886: PPUSH
31887: CALL_OW 145
// end ;
31891: GO 31680
31893: POP
31894: POP
// end else
31895: GO 32039
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31897: LD_EXP 89
31901: PUSH
31902: LD_VAR 0 2
31906: ARRAY
31907: PPUSH
31908: LD_EXP 94
31912: PUSH
31913: LD_VAR 0 2
31917: ARRAY
31918: PUSH
31919: LD_INT 1
31921: ARRAY
31922: PUSH
31923: LD_INT 1
31925: ARRAY
31926: PPUSH
31927: LD_EXP 94
31931: PUSH
31932: LD_VAR 0 2
31936: ARRAY
31937: PUSH
31938: LD_INT 1
31940: ARRAY
31941: PUSH
31942: LD_INT 2
31944: ARRAY
31945: PPUSH
31946: LD_EXP 94
31950: PUSH
31951: LD_VAR 0 2
31955: ARRAY
31956: PUSH
31957: LD_INT 1
31959: ARRAY
31960: PUSH
31961: LD_INT 3
31963: ARRAY
31964: PPUSH
31965: LD_EXP 94
31969: PUSH
31970: LD_VAR 0 2
31974: ARRAY
31975: PUSH
31976: LD_INT 1
31978: ARRAY
31979: PUSH
31980: LD_INT 4
31982: ARRAY
31983: PPUSH
31984: CALL 62368 0 5
31988: NOT
31989: IFFALSE 32039
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31991: LD_ADDR_EXP 94
31995: PUSH
31996: LD_EXP 94
32000: PPUSH
32001: LD_VAR 0 2
32005: PPUSH
32006: LD_EXP 94
32010: PUSH
32011: LD_VAR 0 2
32015: ARRAY
32016: PPUSH
32017: LD_INT 1
32019: PPUSH
32020: LD_INT 1
32022: NEG
32023: PPUSH
32024: LD_INT 0
32026: PPUSH
32027: CALL 55035 0 4
32031: PPUSH
32032: CALL_OW 1
32036: ST_TO_ADDR
// continue ;
32037: GO 30915
// end ; end ; end ;
32039: GO 30915
32041: POP
32042: POP
// end ;
32043: LD_VAR 0 1
32047: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32048: LD_INT 0
32050: PPUSH
32051: PPUSH
32052: PPUSH
32053: PPUSH
32054: PPUSH
32055: PPUSH
// if not mc_bases then
32056: LD_EXP 89
32060: NOT
32061: IFFALSE 32065
// exit ;
32063: GO 32492
// for i = 1 to mc_bases do
32065: LD_ADDR_VAR 0 2
32069: PUSH
32070: DOUBLE
32071: LD_INT 1
32073: DEC
32074: ST_TO_ADDR
32075: LD_EXP 89
32079: PUSH
32080: FOR_TO
32081: IFFALSE 32490
// begin tmp := mc_build_upgrade [ i ] ;
32083: LD_ADDR_VAR 0 4
32087: PUSH
32088: LD_EXP 121
32092: PUSH
32093: LD_VAR 0 2
32097: ARRAY
32098: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32099: LD_ADDR_VAR 0 6
32103: PUSH
32104: LD_EXP 122
32108: PUSH
32109: LD_VAR 0 2
32113: ARRAY
32114: PPUSH
32115: LD_INT 2
32117: PUSH
32118: LD_INT 30
32120: PUSH
32121: LD_INT 6
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 30
32130: PUSH
32131: LD_INT 7
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: LIST
32142: PPUSH
32143: CALL_OW 72
32147: ST_TO_ADDR
// if not tmp and not lab then
32148: LD_VAR 0 4
32152: NOT
32153: PUSH
32154: LD_VAR 0 6
32158: NOT
32159: AND
32160: IFFALSE 32164
// continue ;
32162: GO 32080
// if tmp then
32164: LD_VAR 0 4
32168: IFFALSE 32288
// for j in tmp do
32170: LD_ADDR_VAR 0 3
32174: PUSH
32175: LD_VAR 0 4
32179: PUSH
32180: FOR_IN
32181: IFFALSE 32286
// begin if UpgradeCost ( j ) then
32183: LD_VAR 0 3
32187: PPUSH
32188: CALL 62028 0 1
32192: IFFALSE 32284
// begin ComUpgrade ( j ) ;
32194: LD_VAR 0 3
32198: PPUSH
32199: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32203: LD_ADDR_EXP 121
32207: PUSH
32208: LD_EXP 121
32212: PPUSH
32213: LD_VAR 0 2
32217: PPUSH
32218: LD_EXP 121
32222: PUSH
32223: LD_VAR 0 2
32227: ARRAY
32228: PUSH
32229: LD_VAR 0 3
32233: DIFF
32234: PPUSH
32235: CALL_OW 1
32239: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32240: LD_ADDR_EXP 96
32244: PUSH
32245: LD_EXP 96
32249: PPUSH
32250: LD_VAR 0 2
32254: PUSH
32255: LD_EXP 96
32259: PUSH
32260: LD_VAR 0 2
32264: ARRAY
32265: PUSH
32266: LD_INT 1
32268: PLUS
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PPUSH
32274: LD_VAR 0 3
32278: PPUSH
32279: CALL 55617 0 3
32283: ST_TO_ADDR
// end ; end ;
32284: GO 32180
32286: POP
32287: POP
// if not lab or not mc_lab_upgrade [ i ] then
32288: LD_VAR 0 6
32292: NOT
32293: PUSH
32294: LD_EXP 123
32298: PUSH
32299: LD_VAR 0 2
32303: ARRAY
32304: NOT
32305: OR
32306: IFFALSE 32310
// continue ;
32308: GO 32080
// for j in lab do
32310: LD_ADDR_VAR 0 3
32314: PUSH
32315: LD_VAR 0 6
32319: PUSH
32320: FOR_IN
32321: IFFALSE 32486
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32323: LD_VAR 0 3
32327: PPUSH
32328: CALL_OW 266
32332: PUSH
32333: LD_INT 6
32335: PUSH
32336: LD_INT 7
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: IN
32343: PUSH
32344: LD_VAR 0 3
32348: PPUSH
32349: CALL_OW 461
32353: PUSH
32354: LD_INT 1
32356: NONEQUAL
32357: AND
32358: IFFALSE 32484
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32360: LD_VAR 0 3
32364: PPUSH
32365: LD_EXP 123
32369: PUSH
32370: LD_VAR 0 2
32374: ARRAY
32375: PUSH
32376: LD_INT 1
32378: ARRAY
32379: PPUSH
32380: CALL 62233 0 2
32384: IFFALSE 32484
// begin ComCancel ( j ) ;
32386: LD_VAR 0 3
32390: PPUSH
32391: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32395: LD_VAR 0 3
32399: PPUSH
32400: LD_EXP 123
32404: PUSH
32405: LD_VAR 0 2
32409: ARRAY
32410: PUSH
32411: LD_INT 1
32413: ARRAY
32414: PPUSH
32415: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32419: LD_VAR 0 3
32423: PUSH
32424: LD_EXP 96
32428: PUSH
32429: LD_VAR 0 2
32433: ARRAY
32434: IN
32435: NOT
32436: IFFALSE 32482
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32438: LD_ADDR_EXP 96
32442: PUSH
32443: LD_EXP 96
32447: PPUSH
32448: LD_VAR 0 2
32452: PUSH
32453: LD_EXP 96
32457: PUSH
32458: LD_VAR 0 2
32462: ARRAY
32463: PUSH
32464: LD_INT 1
32466: PLUS
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: PPUSH
32472: LD_VAR 0 3
32476: PPUSH
32477: CALL 55617 0 3
32481: ST_TO_ADDR
// break ;
32482: GO 32486
// end ; end ; end ;
32484: GO 32320
32486: POP
32487: POP
// end ;
32488: GO 32080
32490: POP
32491: POP
// end ;
32492: LD_VAR 0 1
32496: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32497: LD_INT 0
32499: PPUSH
32500: PPUSH
32501: PPUSH
32502: PPUSH
32503: PPUSH
32504: PPUSH
32505: PPUSH
32506: PPUSH
32507: PPUSH
// if not mc_bases then
32508: LD_EXP 89
32512: NOT
32513: IFFALSE 32517
// exit ;
32515: GO 32922
// for i = 1 to mc_bases do
32517: LD_ADDR_VAR 0 2
32521: PUSH
32522: DOUBLE
32523: LD_INT 1
32525: DEC
32526: ST_TO_ADDR
32527: LD_EXP 89
32531: PUSH
32532: FOR_TO
32533: IFFALSE 32920
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32535: LD_EXP 97
32539: PUSH
32540: LD_VAR 0 2
32544: ARRAY
32545: NOT
32546: PUSH
32547: LD_EXP 89
32551: PUSH
32552: LD_VAR 0 2
32556: ARRAY
32557: PPUSH
32558: LD_INT 30
32560: PUSH
32561: LD_INT 3
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: PPUSH
32568: CALL_OW 72
32572: NOT
32573: OR
32574: IFFALSE 32578
// continue ;
32576: GO 32532
// busy := false ;
32578: LD_ADDR_VAR 0 8
32582: PUSH
32583: LD_INT 0
32585: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32586: LD_ADDR_VAR 0 4
32590: PUSH
32591: LD_EXP 89
32595: PUSH
32596: LD_VAR 0 2
32600: ARRAY
32601: PPUSH
32602: LD_INT 30
32604: PUSH
32605: LD_INT 3
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PPUSH
32612: CALL_OW 72
32616: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32617: LD_ADDR_VAR 0 6
32621: PUSH
32622: LD_EXP 97
32626: PUSH
32627: LD_VAR 0 2
32631: ARRAY
32632: PPUSH
32633: LD_INT 2
32635: PUSH
32636: LD_INT 30
32638: PUSH
32639: LD_INT 32
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: PUSH
32646: LD_INT 30
32648: PUSH
32649: LD_INT 33
32651: PUSH
32652: EMPTY
32653: LIST
32654: LIST
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: LIST
32660: PPUSH
32661: CALL_OW 72
32665: ST_TO_ADDR
// if not t then
32666: LD_VAR 0 6
32670: NOT
32671: IFFALSE 32675
// continue ;
32673: GO 32532
// for j in tmp do
32675: LD_ADDR_VAR 0 3
32679: PUSH
32680: LD_VAR 0 4
32684: PUSH
32685: FOR_IN
32686: IFFALSE 32716
// if not BuildingStatus ( j ) = bs_idle then
32688: LD_VAR 0 3
32692: PPUSH
32693: CALL_OW 461
32697: PUSH
32698: LD_INT 2
32700: EQUAL
32701: NOT
32702: IFFALSE 32714
// begin busy := true ;
32704: LD_ADDR_VAR 0 8
32708: PUSH
32709: LD_INT 1
32711: ST_TO_ADDR
// break ;
32712: GO 32716
// end ;
32714: GO 32685
32716: POP
32717: POP
// if busy then
32718: LD_VAR 0 8
32722: IFFALSE 32726
// continue ;
32724: GO 32532
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32726: LD_ADDR_VAR 0 7
32730: PUSH
32731: LD_VAR 0 6
32735: PPUSH
32736: LD_INT 35
32738: PUSH
32739: LD_INT 0
32741: PUSH
32742: EMPTY
32743: LIST
32744: LIST
32745: PPUSH
32746: CALL_OW 72
32750: ST_TO_ADDR
// if tw then
32751: LD_VAR 0 7
32755: IFFALSE 32832
// begin tw := tw [ 1 ] ;
32757: LD_ADDR_VAR 0 7
32761: PUSH
32762: LD_VAR 0 7
32766: PUSH
32767: LD_INT 1
32769: ARRAY
32770: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32771: LD_ADDR_VAR 0 9
32775: PUSH
32776: LD_VAR 0 7
32780: PPUSH
32781: LD_EXP 114
32785: PUSH
32786: LD_VAR 0 2
32790: ARRAY
32791: PPUSH
32792: CALL 60587 0 2
32796: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32797: LD_EXP 128
32801: PUSH
32802: LD_VAR 0 2
32806: ARRAY
32807: IFFALSE 32830
// if not weapon in mc_allowed_tower_weapons [ i ] then
32809: LD_VAR 0 9
32813: PUSH
32814: LD_EXP 128
32818: PUSH
32819: LD_VAR 0 2
32823: ARRAY
32824: IN
32825: NOT
32826: IFFALSE 32830
// continue ;
32828: GO 32532
// end else
32830: GO 32895
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32832: LD_ADDR_VAR 0 5
32836: PUSH
32837: LD_EXP 97
32841: PUSH
32842: LD_VAR 0 2
32846: ARRAY
32847: PPUSH
32848: LD_VAR 0 4
32852: PPUSH
32853: CALL 86089 0 2
32857: ST_TO_ADDR
// if not tmp2 then
32858: LD_VAR 0 5
32862: NOT
32863: IFFALSE 32867
// continue ;
32865: GO 32532
// tw := tmp2 [ 1 ] ;
32867: LD_ADDR_VAR 0 7
32871: PUSH
32872: LD_VAR 0 5
32876: PUSH
32877: LD_INT 1
32879: ARRAY
32880: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32881: LD_ADDR_VAR 0 9
32885: PUSH
32886: LD_VAR 0 5
32890: PUSH
32891: LD_INT 2
32893: ARRAY
32894: ST_TO_ADDR
// end ; if not weapon then
32895: LD_VAR 0 9
32899: NOT
32900: IFFALSE 32904
// continue ;
32902: GO 32532
// ComPlaceWeapon ( tw , weapon ) ;
32904: LD_VAR 0 7
32908: PPUSH
32909: LD_VAR 0 9
32913: PPUSH
32914: CALL_OW 148
// end ;
32918: GO 32532
32920: POP
32921: POP
// end ;
32922: LD_VAR 0 1
32926: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32927: LD_INT 0
32929: PPUSH
32930: PPUSH
32931: PPUSH
32932: PPUSH
32933: PPUSH
32934: PPUSH
// if not mc_bases then
32935: LD_EXP 89
32939: NOT
32940: IFFALSE 32944
// exit ;
32942: GO 33720
// for i = 1 to mc_bases do
32944: LD_ADDR_VAR 0 2
32948: PUSH
32949: DOUBLE
32950: LD_INT 1
32952: DEC
32953: ST_TO_ADDR
32954: LD_EXP 89
32958: PUSH
32959: FOR_TO
32960: IFFALSE 33718
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
32962: LD_EXP 102
32966: PUSH
32967: LD_VAR 0 2
32971: ARRAY
32972: NOT
32973: PUSH
32974: LD_EXP 102
32978: PUSH
32979: LD_VAR 0 2
32983: ARRAY
32984: PUSH
32985: LD_EXP 103
32989: PUSH
32990: LD_VAR 0 2
32994: ARRAY
32995: EQUAL
32996: OR
32997: PUSH
32998: LD_EXP 112
33002: PUSH
33003: LD_VAR 0 2
33007: ARRAY
33008: OR
33009: IFFALSE 33013
// continue ;
33011: GO 32959
// if mc_miners [ i ] then
33013: LD_EXP 103
33017: PUSH
33018: LD_VAR 0 2
33022: ARRAY
33023: IFFALSE 33405
// begin for j = mc_miners [ i ] downto 1 do
33025: LD_ADDR_VAR 0 3
33029: PUSH
33030: DOUBLE
33031: LD_EXP 103
33035: PUSH
33036: LD_VAR 0 2
33040: ARRAY
33041: INC
33042: ST_TO_ADDR
33043: LD_INT 1
33045: PUSH
33046: FOR_DOWNTO
33047: IFFALSE 33403
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33049: LD_EXP 103
33053: PUSH
33054: LD_VAR 0 2
33058: ARRAY
33059: PUSH
33060: LD_VAR 0 3
33064: ARRAY
33065: PPUSH
33066: CALL_OW 301
33070: PUSH
33071: LD_EXP 103
33075: PUSH
33076: LD_VAR 0 2
33080: ARRAY
33081: PUSH
33082: LD_VAR 0 3
33086: ARRAY
33087: PPUSH
33088: CALL_OW 257
33092: PUSH
33093: LD_INT 1
33095: NONEQUAL
33096: OR
33097: IFFALSE 33160
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33099: LD_ADDR_VAR 0 5
33103: PUSH
33104: LD_EXP 103
33108: PUSH
33109: LD_VAR 0 2
33113: ARRAY
33114: PUSH
33115: LD_EXP 103
33119: PUSH
33120: LD_VAR 0 2
33124: ARRAY
33125: PUSH
33126: LD_VAR 0 3
33130: ARRAY
33131: DIFF
33132: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33133: LD_ADDR_EXP 103
33137: PUSH
33138: LD_EXP 103
33142: PPUSH
33143: LD_VAR 0 2
33147: PPUSH
33148: LD_VAR 0 5
33152: PPUSH
33153: CALL_OW 1
33157: ST_TO_ADDR
// continue ;
33158: GO 33046
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33160: LD_EXP 103
33164: PUSH
33165: LD_VAR 0 2
33169: ARRAY
33170: PUSH
33171: LD_VAR 0 3
33175: ARRAY
33176: PPUSH
33177: CALL_OW 257
33181: PUSH
33182: LD_INT 1
33184: EQUAL
33185: PUSH
33186: LD_EXP 103
33190: PUSH
33191: LD_VAR 0 2
33195: ARRAY
33196: PUSH
33197: LD_VAR 0 3
33201: ARRAY
33202: PPUSH
33203: CALL_OW 459
33207: NOT
33208: AND
33209: PUSH
33210: LD_EXP 103
33214: PUSH
33215: LD_VAR 0 2
33219: ARRAY
33220: PUSH
33221: LD_VAR 0 3
33225: ARRAY
33226: PPUSH
33227: CALL_OW 314
33231: NOT
33232: AND
33233: IFFALSE 33401
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33235: LD_EXP 103
33239: PUSH
33240: LD_VAR 0 2
33244: ARRAY
33245: PUSH
33246: LD_VAR 0 3
33250: ARRAY
33251: PPUSH
33252: CALL_OW 310
33256: IFFALSE 33279
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33258: LD_EXP 103
33262: PUSH
33263: LD_VAR 0 2
33267: ARRAY
33268: PUSH
33269: LD_VAR 0 3
33273: ARRAY
33274: PPUSH
33275: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33279: LD_EXP 103
33283: PUSH
33284: LD_VAR 0 2
33288: ARRAY
33289: PUSH
33290: LD_VAR 0 3
33294: ARRAY
33295: PPUSH
33296: CALL_OW 314
33300: NOT
33301: IFFALSE 33401
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33303: LD_EXP 103
33307: PUSH
33308: LD_VAR 0 2
33312: ARRAY
33313: PUSH
33314: LD_VAR 0 3
33318: ARRAY
33319: PPUSH
33320: LD_EXP 102
33324: PUSH
33325: LD_VAR 0 2
33329: ARRAY
33330: PUSH
33331: LD_VAR 0 3
33335: PUSH
33336: LD_EXP 102
33340: PUSH
33341: LD_VAR 0 2
33345: ARRAY
33346: MOD
33347: PUSH
33348: LD_INT 1
33350: PLUS
33351: ARRAY
33352: PUSH
33353: LD_INT 1
33355: ARRAY
33356: PPUSH
33357: LD_EXP 102
33361: PUSH
33362: LD_VAR 0 2
33366: ARRAY
33367: PUSH
33368: LD_VAR 0 3
33372: PUSH
33373: LD_EXP 102
33377: PUSH
33378: LD_VAR 0 2
33382: ARRAY
33383: MOD
33384: PUSH
33385: LD_INT 1
33387: PLUS
33388: ARRAY
33389: PUSH
33390: LD_INT 2
33392: ARRAY
33393: PPUSH
33394: LD_INT 0
33396: PPUSH
33397: CALL_OW 193
// end ; end ;
33401: GO 33046
33403: POP
33404: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33405: LD_ADDR_VAR 0 5
33409: PUSH
33410: LD_EXP 89
33414: PUSH
33415: LD_VAR 0 2
33419: ARRAY
33420: PPUSH
33421: LD_INT 2
33423: PUSH
33424: LD_INT 30
33426: PUSH
33427: LD_INT 4
33429: PUSH
33430: EMPTY
33431: LIST
33432: LIST
33433: PUSH
33434: LD_INT 30
33436: PUSH
33437: LD_INT 5
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 30
33446: PUSH
33447: LD_INT 32
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: LIST
33458: LIST
33459: PPUSH
33460: CALL_OW 72
33464: ST_TO_ADDR
// if not tmp then
33465: LD_VAR 0 5
33469: NOT
33470: IFFALSE 33474
// continue ;
33472: GO 32959
// list := [ ] ;
33474: LD_ADDR_VAR 0 6
33478: PUSH
33479: EMPTY
33480: ST_TO_ADDR
// for j in tmp do
33481: LD_ADDR_VAR 0 3
33485: PUSH
33486: LD_VAR 0 5
33490: PUSH
33491: FOR_IN
33492: IFFALSE 33561
// begin for k in UnitsInside ( j ) do
33494: LD_ADDR_VAR 0 4
33498: PUSH
33499: LD_VAR 0 3
33503: PPUSH
33504: CALL_OW 313
33508: PUSH
33509: FOR_IN
33510: IFFALSE 33557
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33512: LD_VAR 0 4
33516: PPUSH
33517: CALL_OW 257
33521: PUSH
33522: LD_INT 1
33524: EQUAL
33525: PUSH
33526: LD_VAR 0 4
33530: PPUSH
33531: CALL_OW 459
33535: NOT
33536: AND
33537: IFFALSE 33555
// list := list ^ k ;
33539: LD_ADDR_VAR 0 6
33543: PUSH
33544: LD_VAR 0 6
33548: PUSH
33549: LD_VAR 0 4
33553: ADD
33554: ST_TO_ADDR
33555: GO 33509
33557: POP
33558: POP
// end ;
33559: GO 33491
33561: POP
33562: POP
// list := list diff mc_miners [ i ] ;
33563: LD_ADDR_VAR 0 6
33567: PUSH
33568: LD_VAR 0 6
33572: PUSH
33573: LD_EXP 103
33577: PUSH
33578: LD_VAR 0 2
33582: ARRAY
33583: DIFF
33584: ST_TO_ADDR
// if not list then
33585: LD_VAR 0 6
33589: NOT
33590: IFFALSE 33594
// continue ;
33592: GO 32959
// k := mc_mines [ i ] - mc_miners [ i ] ;
33594: LD_ADDR_VAR 0 4
33598: PUSH
33599: LD_EXP 102
33603: PUSH
33604: LD_VAR 0 2
33608: ARRAY
33609: PUSH
33610: LD_EXP 103
33614: PUSH
33615: LD_VAR 0 2
33619: ARRAY
33620: MINUS
33621: ST_TO_ADDR
// if k > list then
33622: LD_VAR 0 4
33626: PUSH
33627: LD_VAR 0 6
33631: GREATER
33632: IFFALSE 33644
// k := list ;
33634: LD_ADDR_VAR 0 4
33638: PUSH
33639: LD_VAR 0 6
33643: ST_TO_ADDR
// for j = 1 to k do
33644: LD_ADDR_VAR 0 3
33648: PUSH
33649: DOUBLE
33650: LD_INT 1
33652: DEC
33653: ST_TO_ADDR
33654: LD_VAR 0 4
33658: PUSH
33659: FOR_TO
33660: IFFALSE 33714
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33662: LD_ADDR_EXP 103
33666: PUSH
33667: LD_EXP 103
33671: PPUSH
33672: LD_VAR 0 2
33676: PUSH
33677: LD_EXP 103
33681: PUSH
33682: LD_VAR 0 2
33686: ARRAY
33687: PUSH
33688: LD_INT 1
33690: PLUS
33691: PUSH
33692: EMPTY
33693: LIST
33694: LIST
33695: PPUSH
33696: LD_VAR 0 6
33700: PUSH
33701: LD_VAR 0 3
33705: ARRAY
33706: PPUSH
33707: CALL 55617 0 3
33711: ST_TO_ADDR
33712: GO 33659
33714: POP
33715: POP
// end ;
33716: GO 32959
33718: POP
33719: POP
// end ;
33720: LD_VAR 0 1
33724: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33725: LD_INT 0
33727: PPUSH
33728: PPUSH
33729: PPUSH
33730: PPUSH
33731: PPUSH
33732: PPUSH
33733: PPUSH
33734: PPUSH
33735: PPUSH
33736: PPUSH
// if not mc_bases then
33737: LD_EXP 89
33741: NOT
33742: IFFALSE 33746
// exit ;
33744: GO 35496
// for i = 1 to mc_bases do
33746: LD_ADDR_VAR 0 2
33750: PUSH
33751: DOUBLE
33752: LD_INT 1
33754: DEC
33755: ST_TO_ADDR
33756: LD_EXP 89
33760: PUSH
33761: FOR_TO
33762: IFFALSE 35494
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33764: LD_EXP 89
33768: PUSH
33769: LD_VAR 0 2
33773: ARRAY
33774: NOT
33775: PUSH
33776: LD_EXP 96
33780: PUSH
33781: LD_VAR 0 2
33785: ARRAY
33786: OR
33787: IFFALSE 33791
// continue ;
33789: GO 33761
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33791: LD_EXP 105
33795: PUSH
33796: LD_VAR 0 2
33800: ARRAY
33801: NOT
33802: PUSH
33803: LD_EXP 106
33807: PUSH
33808: LD_VAR 0 2
33812: ARRAY
33813: AND
33814: IFFALSE 33852
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33816: LD_ADDR_EXP 106
33820: PUSH
33821: LD_EXP 106
33825: PPUSH
33826: LD_VAR 0 2
33830: PPUSH
33831: EMPTY
33832: PPUSH
33833: CALL_OW 1
33837: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33838: LD_VAR 0 2
33842: PPUSH
33843: LD_INT 107
33845: PPUSH
33846: CALL 24726 0 2
// continue ;
33850: GO 33761
// end ; target := [ ] ;
33852: LD_ADDR_VAR 0 6
33856: PUSH
33857: EMPTY
33858: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33859: LD_ADDR_VAR 0 3
33863: PUSH
33864: DOUBLE
33865: LD_EXP 105
33869: PUSH
33870: LD_VAR 0 2
33874: ARRAY
33875: INC
33876: ST_TO_ADDR
33877: LD_INT 1
33879: PUSH
33880: FOR_DOWNTO
33881: IFFALSE 34141
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33883: LD_EXP 105
33887: PUSH
33888: LD_VAR 0 2
33892: ARRAY
33893: PUSH
33894: LD_VAR 0 3
33898: ARRAY
33899: PUSH
33900: LD_INT 2
33902: ARRAY
33903: PPUSH
33904: LD_EXP 105
33908: PUSH
33909: LD_VAR 0 2
33913: ARRAY
33914: PUSH
33915: LD_VAR 0 3
33919: ARRAY
33920: PUSH
33921: LD_INT 3
33923: ARRAY
33924: PPUSH
33925: CALL_OW 488
33929: PUSH
33930: LD_EXP 105
33934: PUSH
33935: LD_VAR 0 2
33939: ARRAY
33940: PUSH
33941: LD_VAR 0 3
33945: ARRAY
33946: PUSH
33947: LD_INT 2
33949: ARRAY
33950: PPUSH
33951: LD_EXP 105
33955: PUSH
33956: LD_VAR 0 2
33960: ARRAY
33961: PUSH
33962: LD_VAR 0 3
33966: ARRAY
33967: PUSH
33968: LD_INT 3
33970: ARRAY
33971: PPUSH
33972: CALL_OW 284
33976: PUSH
33977: LD_INT 0
33979: EQUAL
33980: AND
33981: IFFALSE 34036
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33983: LD_ADDR_VAR 0 5
33987: PUSH
33988: LD_EXP 105
33992: PUSH
33993: LD_VAR 0 2
33997: ARRAY
33998: PPUSH
33999: LD_VAR 0 3
34003: PPUSH
34004: CALL_OW 3
34008: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34009: LD_ADDR_EXP 105
34013: PUSH
34014: LD_EXP 105
34018: PPUSH
34019: LD_VAR 0 2
34023: PPUSH
34024: LD_VAR 0 5
34028: PPUSH
34029: CALL_OW 1
34033: ST_TO_ADDR
// continue ;
34034: GO 33880
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34036: LD_EXP 89
34040: PUSH
34041: LD_VAR 0 2
34045: ARRAY
34046: PUSH
34047: LD_INT 1
34049: ARRAY
34050: PPUSH
34051: CALL_OW 255
34055: PPUSH
34056: LD_EXP 105
34060: PUSH
34061: LD_VAR 0 2
34065: ARRAY
34066: PUSH
34067: LD_VAR 0 3
34071: ARRAY
34072: PUSH
34073: LD_INT 2
34075: ARRAY
34076: PPUSH
34077: LD_EXP 105
34081: PUSH
34082: LD_VAR 0 2
34086: ARRAY
34087: PUSH
34088: LD_VAR 0 3
34092: ARRAY
34093: PUSH
34094: LD_INT 3
34096: ARRAY
34097: PPUSH
34098: LD_INT 30
34100: PPUSH
34101: CALL 56513 0 4
34105: PUSH
34106: LD_INT 4
34108: ARRAY
34109: PUSH
34110: LD_INT 0
34112: EQUAL
34113: IFFALSE 34139
// begin target := mc_crates [ i ] [ j ] ;
34115: LD_ADDR_VAR 0 6
34119: PUSH
34120: LD_EXP 105
34124: PUSH
34125: LD_VAR 0 2
34129: ARRAY
34130: PUSH
34131: LD_VAR 0 3
34135: ARRAY
34136: ST_TO_ADDR
// break ;
34137: GO 34141
// end ; end ;
34139: GO 33880
34141: POP
34142: POP
// if not target then
34143: LD_VAR 0 6
34147: NOT
34148: IFFALSE 34152
// continue ;
34150: GO 33761
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34152: LD_ADDR_VAR 0 7
34156: PUSH
34157: LD_EXP 108
34161: PUSH
34162: LD_VAR 0 2
34166: ARRAY
34167: PPUSH
34168: LD_INT 2
34170: PUSH
34171: LD_INT 3
34173: PUSH
34174: LD_INT 58
34176: PUSH
34177: EMPTY
34178: LIST
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 61
34186: PUSH
34187: EMPTY
34188: LIST
34189: PUSH
34190: LD_INT 33
34192: PUSH
34193: LD_INT 5
34195: PUSH
34196: EMPTY
34197: LIST
34198: LIST
34199: PUSH
34200: LD_INT 33
34202: PUSH
34203: LD_INT 3
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: LIST
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 2
34219: PUSH
34220: LD_INT 34
34222: PUSH
34223: LD_INT 32
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: PUSH
34230: LD_INT 34
34232: PUSH
34233: LD_INT 51
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 34
34242: PUSH
34243: LD_INT 12
34245: PUSH
34246: EMPTY
34247: LIST
34248: LIST
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: LIST
34254: LIST
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PPUSH
34260: CALL_OW 72
34264: ST_TO_ADDR
// if not cargo then
34265: LD_VAR 0 7
34269: NOT
34270: IFFALSE 34913
// begin if mc_crates_collector [ i ] < 5 then
34272: LD_EXP 106
34276: PUSH
34277: LD_VAR 0 2
34281: ARRAY
34282: PUSH
34283: LD_INT 5
34285: LESS
34286: IFFALSE 34652
// begin if mc_ape [ i ] then
34288: LD_EXP 118
34292: PUSH
34293: LD_VAR 0 2
34297: ARRAY
34298: IFFALSE 34345
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34300: LD_ADDR_VAR 0 5
34304: PUSH
34305: LD_EXP 118
34309: PUSH
34310: LD_VAR 0 2
34314: ARRAY
34315: PPUSH
34316: LD_INT 25
34318: PUSH
34319: LD_INT 16
34321: PUSH
34322: EMPTY
34323: LIST
34324: LIST
34325: PUSH
34326: LD_INT 24
34328: PUSH
34329: LD_INT 750
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PPUSH
34340: CALL_OW 72
34344: ST_TO_ADDR
// if not tmp then
34345: LD_VAR 0 5
34349: NOT
34350: IFFALSE 34397
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34352: LD_ADDR_VAR 0 5
34356: PUSH
34357: LD_EXP 89
34361: PUSH
34362: LD_VAR 0 2
34366: ARRAY
34367: PPUSH
34368: LD_INT 25
34370: PUSH
34371: LD_INT 2
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: PUSH
34378: LD_INT 24
34380: PUSH
34381: LD_INT 750
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: EMPTY
34389: LIST
34390: LIST
34391: PPUSH
34392: CALL_OW 72
34396: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34397: LD_EXP 118
34401: PUSH
34402: LD_VAR 0 2
34406: ARRAY
34407: PUSH
34408: LD_EXP 89
34412: PUSH
34413: LD_VAR 0 2
34417: ARRAY
34418: PPUSH
34419: LD_INT 25
34421: PUSH
34422: LD_INT 2
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 24
34431: PUSH
34432: LD_INT 750
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PPUSH
34443: CALL_OW 72
34447: AND
34448: PUSH
34449: LD_VAR 0 5
34453: PUSH
34454: LD_INT 5
34456: LESS
34457: AND
34458: IFFALSE 34540
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34460: LD_ADDR_VAR 0 3
34464: PUSH
34465: LD_EXP 89
34469: PUSH
34470: LD_VAR 0 2
34474: ARRAY
34475: PPUSH
34476: LD_INT 25
34478: PUSH
34479: LD_INT 2
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 24
34488: PUSH
34489: LD_INT 750
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: PPUSH
34500: CALL_OW 72
34504: PUSH
34505: FOR_IN
34506: IFFALSE 34538
// begin tmp := tmp union j ;
34508: LD_ADDR_VAR 0 5
34512: PUSH
34513: LD_VAR 0 5
34517: PUSH
34518: LD_VAR 0 3
34522: UNION
34523: ST_TO_ADDR
// if tmp >= 5 then
34524: LD_VAR 0 5
34528: PUSH
34529: LD_INT 5
34531: GREATEREQUAL
34532: IFFALSE 34536
// break ;
34534: GO 34538
// end ;
34536: GO 34505
34538: POP
34539: POP
// end ; if not tmp then
34540: LD_VAR 0 5
34544: NOT
34545: IFFALSE 34549
// continue ;
34547: GO 33761
// for j in tmp do
34549: LD_ADDR_VAR 0 3
34553: PUSH
34554: LD_VAR 0 5
34558: PUSH
34559: FOR_IN
34560: IFFALSE 34650
// if not GetTag ( j ) then
34562: LD_VAR 0 3
34566: PPUSH
34567: CALL_OW 110
34571: NOT
34572: IFFALSE 34648
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34574: LD_ADDR_EXP 106
34578: PUSH
34579: LD_EXP 106
34583: PPUSH
34584: LD_VAR 0 2
34588: PUSH
34589: LD_EXP 106
34593: PUSH
34594: LD_VAR 0 2
34598: ARRAY
34599: PUSH
34600: LD_INT 1
34602: PLUS
34603: PUSH
34604: EMPTY
34605: LIST
34606: LIST
34607: PPUSH
34608: LD_VAR 0 3
34612: PPUSH
34613: CALL 55617 0 3
34617: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34618: LD_VAR 0 3
34622: PPUSH
34623: LD_INT 107
34625: PPUSH
34626: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34630: LD_EXP 106
34634: PUSH
34635: LD_VAR 0 2
34639: ARRAY
34640: PUSH
34641: LD_INT 5
34643: GREATEREQUAL
34644: IFFALSE 34648
// break ;
34646: GO 34650
// end ;
34648: GO 34559
34650: POP
34651: POP
// end ; if mc_crates_collector [ i ] and target then
34652: LD_EXP 106
34656: PUSH
34657: LD_VAR 0 2
34661: ARRAY
34662: PUSH
34663: LD_VAR 0 6
34667: AND
34668: IFFALSE 34911
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34670: LD_EXP 106
34674: PUSH
34675: LD_VAR 0 2
34679: ARRAY
34680: PUSH
34681: LD_VAR 0 6
34685: PUSH
34686: LD_INT 1
34688: ARRAY
34689: LESS
34690: IFFALSE 34710
// tmp := mc_crates_collector [ i ] else
34692: LD_ADDR_VAR 0 5
34696: PUSH
34697: LD_EXP 106
34701: PUSH
34702: LD_VAR 0 2
34706: ARRAY
34707: ST_TO_ADDR
34708: GO 34724
// tmp := target [ 1 ] ;
34710: LD_ADDR_VAR 0 5
34714: PUSH
34715: LD_VAR 0 6
34719: PUSH
34720: LD_INT 1
34722: ARRAY
34723: ST_TO_ADDR
// k := 0 ;
34724: LD_ADDR_VAR 0 4
34728: PUSH
34729: LD_INT 0
34731: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34732: LD_ADDR_VAR 0 3
34736: PUSH
34737: LD_EXP 106
34741: PUSH
34742: LD_VAR 0 2
34746: ARRAY
34747: PUSH
34748: FOR_IN
34749: IFFALSE 34909
// begin k := k + 1 ;
34751: LD_ADDR_VAR 0 4
34755: PUSH
34756: LD_VAR 0 4
34760: PUSH
34761: LD_INT 1
34763: PLUS
34764: ST_TO_ADDR
// if k > tmp then
34765: LD_VAR 0 4
34769: PUSH
34770: LD_VAR 0 5
34774: GREATER
34775: IFFALSE 34779
// break ;
34777: GO 34909
// if not GetClass ( j ) in [ 2 , 16 ] then
34779: LD_VAR 0 3
34783: PPUSH
34784: CALL_OW 257
34788: PUSH
34789: LD_INT 2
34791: PUSH
34792: LD_INT 16
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: IN
34799: NOT
34800: IFFALSE 34853
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34802: LD_ADDR_EXP 106
34806: PUSH
34807: LD_EXP 106
34811: PPUSH
34812: LD_VAR 0 2
34816: PPUSH
34817: LD_EXP 106
34821: PUSH
34822: LD_VAR 0 2
34826: ARRAY
34827: PUSH
34828: LD_VAR 0 3
34832: DIFF
34833: PPUSH
34834: CALL_OW 1
34838: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34839: LD_VAR 0 3
34843: PPUSH
34844: LD_INT 0
34846: PPUSH
34847: CALL_OW 109
// continue ;
34851: GO 34748
// end ; if IsInUnit ( j ) then
34853: LD_VAR 0 3
34857: PPUSH
34858: CALL_OW 310
34862: IFFALSE 34873
// ComExitBuilding ( j ) ;
34864: LD_VAR 0 3
34868: PPUSH
34869: CALL_OW 122
// wait ( 3 ) ;
34873: LD_INT 3
34875: PPUSH
34876: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34880: LD_VAR 0 3
34884: PPUSH
34885: LD_VAR 0 6
34889: PUSH
34890: LD_INT 2
34892: ARRAY
34893: PPUSH
34894: LD_VAR 0 6
34898: PUSH
34899: LD_INT 3
34901: ARRAY
34902: PPUSH
34903: CALL_OW 117
// end ;
34907: GO 34748
34909: POP
34910: POP
// end ; end else
34911: GO 35492
// begin for j in cargo do
34913: LD_ADDR_VAR 0 3
34917: PUSH
34918: LD_VAR 0 7
34922: PUSH
34923: FOR_IN
34924: IFFALSE 35490
// begin if GetTag ( j ) <> 0 then
34926: LD_VAR 0 3
34930: PPUSH
34931: CALL_OW 110
34935: PUSH
34936: LD_INT 0
34938: NONEQUAL
34939: IFFALSE 34943
// continue ;
34941: GO 34923
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34943: LD_VAR 0 3
34947: PPUSH
34948: CALL_OW 256
34952: PUSH
34953: LD_INT 1000
34955: LESS
34956: PUSH
34957: LD_VAR 0 3
34961: PPUSH
34962: LD_EXP 113
34966: PUSH
34967: LD_VAR 0 2
34971: ARRAY
34972: PPUSH
34973: CALL_OW 308
34977: NOT
34978: AND
34979: IFFALSE 35001
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34981: LD_VAR 0 3
34985: PPUSH
34986: LD_EXP 113
34990: PUSH
34991: LD_VAR 0 2
34995: ARRAY
34996: PPUSH
34997: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35001: LD_VAR 0 3
35005: PPUSH
35006: CALL_OW 256
35010: PUSH
35011: LD_INT 1000
35013: LESS
35014: PUSH
35015: LD_VAR 0 3
35019: PPUSH
35020: LD_EXP 113
35024: PUSH
35025: LD_VAR 0 2
35029: ARRAY
35030: PPUSH
35031: CALL_OW 308
35035: AND
35036: IFFALSE 35040
// continue ;
35038: GO 34923
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35040: LD_VAR 0 3
35044: PPUSH
35045: CALL_OW 262
35049: PUSH
35050: LD_INT 2
35052: EQUAL
35053: PUSH
35054: LD_VAR 0 3
35058: PPUSH
35059: CALL_OW 261
35063: PUSH
35064: LD_INT 15
35066: LESS
35067: AND
35068: IFFALSE 35072
// continue ;
35070: GO 34923
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35072: LD_VAR 0 3
35076: PPUSH
35077: CALL_OW 262
35081: PUSH
35082: LD_INT 1
35084: EQUAL
35085: PUSH
35086: LD_VAR 0 3
35090: PPUSH
35091: CALL_OW 261
35095: PUSH
35096: LD_INT 10
35098: LESS
35099: AND
35100: IFFALSE 35429
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35102: LD_ADDR_VAR 0 8
35106: PUSH
35107: LD_EXP 89
35111: PUSH
35112: LD_VAR 0 2
35116: ARRAY
35117: PPUSH
35118: LD_INT 2
35120: PUSH
35121: LD_INT 30
35123: PUSH
35124: LD_INT 0
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 30
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: EMPTY
35142: LIST
35143: LIST
35144: LIST
35145: PPUSH
35146: CALL_OW 72
35150: ST_TO_ADDR
// if not depot then
35151: LD_VAR 0 8
35155: NOT
35156: IFFALSE 35160
// continue ;
35158: GO 34923
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35160: LD_VAR 0 3
35164: PPUSH
35165: LD_VAR 0 8
35169: PPUSH
35170: LD_VAR 0 3
35174: PPUSH
35175: CALL_OW 74
35179: PPUSH
35180: CALL_OW 296
35184: PUSH
35185: LD_INT 6
35187: LESS
35188: IFFALSE 35204
// SetFuel ( j , 100 ) else
35190: LD_VAR 0 3
35194: PPUSH
35195: LD_INT 100
35197: PPUSH
35198: CALL_OW 240
35202: GO 35429
// if GetFuel ( j ) = 0 then
35204: LD_VAR 0 3
35208: PPUSH
35209: CALL_OW 261
35213: PUSH
35214: LD_INT 0
35216: EQUAL
35217: IFFALSE 35429
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35219: LD_ADDR_EXP 108
35223: PUSH
35224: LD_EXP 108
35228: PPUSH
35229: LD_VAR 0 2
35233: PPUSH
35234: LD_EXP 108
35238: PUSH
35239: LD_VAR 0 2
35243: ARRAY
35244: PUSH
35245: LD_VAR 0 3
35249: DIFF
35250: PPUSH
35251: CALL_OW 1
35255: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35256: LD_VAR 0 3
35260: PPUSH
35261: CALL_OW 263
35265: PUSH
35266: LD_INT 1
35268: EQUAL
35269: IFFALSE 35285
// ComExitVehicle ( IsInUnit ( j ) ) ;
35271: LD_VAR 0 3
35275: PPUSH
35276: CALL_OW 310
35280: PPUSH
35281: CALL_OW 121
// if GetControl ( j ) = control_remote then
35285: LD_VAR 0 3
35289: PPUSH
35290: CALL_OW 263
35294: PUSH
35295: LD_INT 2
35297: EQUAL
35298: IFFALSE 35309
// ComUnlink ( j ) ;
35300: LD_VAR 0 3
35304: PPUSH
35305: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35309: LD_ADDR_VAR 0 9
35313: PUSH
35314: LD_VAR 0 2
35318: PPUSH
35319: LD_INT 3
35321: PPUSH
35322: CALL 44782 0 2
35326: ST_TO_ADDR
// if fac then
35327: LD_VAR 0 9
35331: IFFALSE 35427
// begin for k in fac do
35333: LD_ADDR_VAR 0 4
35337: PUSH
35338: LD_VAR 0 9
35342: PUSH
35343: FOR_IN
35344: IFFALSE 35425
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35346: LD_ADDR_VAR 0 10
35350: PUSH
35351: LD_VAR 0 9
35355: PPUSH
35356: LD_VAR 0 3
35360: PPUSH
35361: CALL_OW 265
35365: PPUSH
35366: LD_VAR 0 3
35370: PPUSH
35371: CALL_OW 262
35375: PPUSH
35376: LD_VAR 0 3
35380: PPUSH
35381: CALL_OW 263
35385: PPUSH
35386: LD_VAR 0 3
35390: PPUSH
35391: CALL_OW 264
35395: PPUSH
35396: CALL 53149 0 5
35400: ST_TO_ADDR
// if components then
35401: LD_VAR 0 10
35405: IFFALSE 35423
// begin MC_InsertProduceList ( i , components ) ;
35407: LD_VAR 0 2
35411: PPUSH
35412: LD_VAR 0 10
35416: PPUSH
35417: CALL 44327 0 2
// break ;
35421: GO 35425
// end ; end ;
35423: GO 35343
35425: POP
35426: POP
// end ; continue ;
35427: GO 34923
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35429: LD_VAR 0 3
35433: PPUSH
35434: LD_INT 1
35436: PPUSH
35437: CALL_OW 289
35441: PUSH
35442: LD_INT 100
35444: LESS
35445: PUSH
35446: LD_VAR 0 3
35450: PPUSH
35451: CALL_OW 314
35455: NOT
35456: AND
35457: IFFALSE 35486
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35459: LD_VAR 0 3
35463: PPUSH
35464: LD_VAR 0 6
35468: PUSH
35469: LD_INT 2
35471: ARRAY
35472: PPUSH
35473: LD_VAR 0 6
35477: PUSH
35478: LD_INT 3
35480: ARRAY
35481: PPUSH
35482: CALL_OW 117
// break ;
35486: GO 35490
// end ;
35488: GO 34923
35490: POP
35491: POP
// end ; end ;
35492: GO 33761
35494: POP
35495: POP
// end ;
35496: LD_VAR 0 1
35500: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35501: LD_INT 0
35503: PPUSH
35504: PPUSH
35505: PPUSH
35506: PPUSH
// if not mc_bases then
35507: LD_EXP 89
35511: NOT
35512: IFFALSE 35516
// exit ;
35514: GO 35677
// for i = 1 to mc_bases do
35516: LD_ADDR_VAR 0 2
35520: PUSH
35521: DOUBLE
35522: LD_INT 1
35524: DEC
35525: ST_TO_ADDR
35526: LD_EXP 89
35530: PUSH
35531: FOR_TO
35532: IFFALSE 35675
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35534: LD_ADDR_VAR 0 4
35538: PUSH
35539: LD_EXP 108
35543: PUSH
35544: LD_VAR 0 2
35548: ARRAY
35549: PUSH
35550: LD_EXP 111
35554: PUSH
35555: LD_VAR 0 2
35559: ARRAY
35560: UNION
35561: PPUSH
35562: LD_INT 33
35564: PUSH
35565: LD_INT 2
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PPUSH
35572: CALL_OW 72
35576: ST_TO_ADDR
// if tmp then
35577: LD_VAR 0 4
35581: IFFALSE 35673
// for j in tmp do
35583: LD_ADDR_VAR 0 3
35587: PUSH
35588: LD_VAR 0 4
35592: PUSH
35593: FOR_IN
35594: IFFALSE 35671
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35596: LD_VAR 0 3
35600: PPUSH
35601: CALL_OW 312
35605: NOT
35606: PUSH
35607: LD_VAR 0 3
35611: PPUSH
35612: CALL_OW 256
35616: PUSH
35617: LD_INT 250
35619: GREATEREQUAL
35620: AND
35621: IFFALSE 35634
// Connect ( j ) else
35623: LD_VAR 0 3
35627: PPUSH
35628: CALL 58550 0 1
35632: GO 35669
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35634: LD_VAR 0 3
35638: PPUSH
35639: CALL_OW 256
35643: PUSH
35644: LD_INT 250
35646: LESS
35647: PUSH
35648: LD_VAR 0 3
35652: PPUSH
35653: CALL_OW 312
35657: AND
35658: IFFALSE 35669
// ComUnlink ( j ) ;
35660: LD_VAR 0 3
35664: PPUSH
35665: CALL_OW 136
35669: GO 35593
35671: POP
35672: POP
// end ;
35673: GO 35531
35675: POP
35676: POP
// end ;
35677: LD_VAR 0 1
35681: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35682: LD_INT 0
35684: PPUSH
35685: PPUSH
35686: PPUSH
35687: PPUSH
35688: PPUSH
// if not mc_bases then
35689: LD_EXP 89
35693: NOT
35694: IFFALSE 35698
// exit ;
35696: GO 36143
// for i = 1 to mc_bases do
35698: LD_ADDR_VAR 0 2
35702: PUSH
35703: DOUBLE
35704: LD_INT 1
35706: DEC
35707: ST_TO_ADDR
35708: LD_EXP 89
35712: PUSH
35713: FOR_TO
35714: IFFALSE 36141
// begin if not mc_produce [ i ] then
35716: LD_EXP 110
35720: PUSH
35721: LD_VAR 0 2
35725: ARRAY
35726: NOT
35727: IFFALSE 35731
// continue ;
35729: GO 35713
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35731: LD_ADDR_VAR 0 5
35735: PUSH
35736: LD_EXP 89
35740: PUSH
35741: LD_VAR 0 2
35745: ARRAY
35746: PPUSH
35747: LD_INT 30
35749: PUSH
35750: LD_INT 3
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: PPUSH
35757: CALL_OW 72
35761: ST_TO_ADDR
// if not fac then
35762: LD_VAR 0 5
35766: NOT
35767: IFFALSE 35771
// continue ;
35769: GO 35713
// for j in fac do
35771: LD_ADDR_VAR 0 3
35775: PUSH
35776: LD_VAR 0 5
35780: PUSH
35781: FOR_IN
35782: IFFALSE 36137
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35784: LD_VAR 0 3
35788: PPUSH
35789: CALL_OW 461
35793: PUSH
35794: LD_INT 2
35796: NONEQUAL
35797: PUSH
35798: LD_VAR 0 3
35802: PPUSH
35803: LD_INT 15
35805: PPUSH
35806: CALL 58210 0 2
35810: PUSH
35811: LD_INT 4
35813: ARRAY
35814: OR
35815: IFFALSE 35819
// continue ;
35817: GO 35781
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35819: LD_VAR 0 3
35823: PPUSH
35824: LD_EXP 110
35828: PUSH
35829: LD_VAR 0 2
35833: ARRAY
35834: PUSH
35835: LD_INT 1
35837: ARRAY
35838: PUSH
35839: LD_INT 1
35841: ARRAY
35842: PPUSH
35843: LD_EXP 110
35847: PUSH
35848: LD_VAR 0 2
35852: ARRAY
35853: PUSH
35854: LD_INT 1
35856: ARRAY
35857: PUSH
35858: LD_INT 2
35860: ARRAY
35861: PPUSH
35862: LD_EXP 110
35866: PUSH
35867: LD_VAR 0 2
35871: ARRAY
35872: PUSH
35873: LD_INT 1
35875: ARRAY
35876: PUSH
35877: LD_INT 3
35879: ARRAY
35880: PPUSH
35881: LD_EXP 110
35885: PUSH
35886: LD_VAR 0 2
35890: ARRAY
35891: PUSH
35892: LD_INT 1
35894: ARRAY
35895: PUSH
35896: LD_INT 4
35898: ARRAY
35899: PPUSH
35900: CALL_OW 448
35904: PUSH
35905: LD_VAR 0 3
35909: PPUSH
35910: LD_EXP 110
35914: PUSH
35915: LD_VAR 0 2
35919: ARRAY
35920: PUSH
35921: LD_INT 1
35923: ARRAY
35924: PUSH
35925: LD_INT 1
35927: ARRAY
35928: PUSH
35929: LD_EXP 110
35933: PUSH
35934: LD_VAR 0 2
35938: ARRAY
35939: PUSH
35940: LD_INT 1
35942: ARRAY
35943: PUSH
35944: LD_INT 2
35946: ARRAY
35947: PUSH
35948: LD_EXP 110
35952: PUSH
35953: LD_VAR 0 2
35957: ARRAY
35958: PUSH
35959: LD_INT 1
35961: ARRAY
35962: PUSH
35963: LD_INT 3
35965: ARRAY
35966: PUSH
35967: LD_EXP 110
35971: PUSH
35972: LD_VAR 0 2
35976: ARRAY
35977: PUSH
35978: LD_INT 1
35980: ARRAY
35981: PUSH
35982: LD_INT 4
35984: ARRAY
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: PPUSH
35992: CALL 61881 0 2
35996: AND
35997: IFFALSE 36135
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35999: LD_VAR 0 3
36003: PPUSH
36004: LD_EXP 110
36008: PUSH
36009: LD_VAR 0 2
36013: ARRAY
36014: PUSH
36015: LD_INT 1
36017: ARRAY
36018: PUSH
36019: LD_INT 1
36021: ARRAY
36022: PPUSH
36023: LD_EXP 110
36027: PUSH
36028: LD_VAR 0 2
36032: ARRAY
36033: PUSH
36034: LD_INT 1
36036: ARRAY
36037: PUSH
36038: LD_INT 2
36040: ARRAY
36041: PPUSH
36042: LD_EXP 110
36046: PUSH
36047: LD_VAR 0 2
36051: ARRAY
36052: PUSH
36053: LD_INT 1
36055: ARRAY
36056: PUSH
36057: LD_INT 3
36059: ARRAY
36060: PPUSH
36061: LD_EXP 110
36065: PUSH
36066: LD_VAR 0 2
36070: ARRAY
36071: PUSH
36072: LD_INT 1
36074: ARRAY
36075: PUSH
36076: LD_INT 4
36078: ARRAY
36079: PPUSH
36080: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36084: LD_ADDR_VAR 0 4
36088: PUSH
36089: LD_EXP 110
36093: PUSH
36094: LD_VAR 0 2
36098: ARRAY
36099: PPUSH
36100: LD_INT 1
36102: PPUSH
36103: CALL_OW 3
36107: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36108: LD_ADDR_EXP 110
36112: PUSH
36113: LD_EXP 110
36117: PPUSH
36118: LD_VAR 0 2
36122: PPUSH
36123: LD_VAR 0 4
36127: PPUSH
36128: CALL_OW 1
36132: ST_TO_ADDR
// break ;
36133: GO 36137
// end ; end ;
36135: GO 35781
36137: POP
36138: POP
// end ;
36139: GO 35713
36141: POP
36142: POP
// end ;
36143: LD_VAR 0 1
36147: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36148: LD_INT 0
36150: PPUSH
36151: PPUSH
36152: PPUSH
// if not mc_bases then
36153: LD_EXP 89
36157: NOT
36158: IFFALSE 36162
// exit ;
36160: GO 36251
// for i = 1 to mc_bases do
36162: LD_ADDR_VAR 0 2
36166: PUSH
36167: DOUBLE
36168: LD_INT 1
36170: DEC
36171: ST_TO_ADDR
36172: LD_EXP 89
36176: PUSH
36177: FOR_TO
36178: IFFALSE 36249
// begin if mc_attack [ i ] then
36180: LD_EXP 109
36184: PUSH
36185: LD_VAR 0 2
36189: ARRAY
36190: IFFALSE 36247
// begin tmp := mc_attack [ i ] [ 1 ] ;
36192: LD_ADDR_VAR 0 3
36196: PUSH
36197: LD_EXP 109
36201: PUSH
36202: LD_VAR 0 2
36206: ARRAY
36207: PUSH
36208: LD_INT 1
36210: ARRAY
36211: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36212: LD_ADDR_EXP 109
36216: PUSH
36217: LD_EXP 109
36221: PPUSH
36222: LD_VAR 0 2
36226: PPUSH
36227: EMPTY
36228: PPUSH
36229: CALL_OW 1
36233: ST_TO_ADDR
// Attack ( tmp ) ;
36234: LD_VAR 0 3
36238: PPUSH
36239: CALL 101478 0 1
// exit ;
36243: POP
36244: POP
36245: GO 36251
// end ; end ;
36247: GO 36177
36249: POP
36250: POP
// end ;
36251: LD_VAR 0 1
36255: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36256: LD_INT 0
36258: PPUSH
36259: PPUSH
36260: PPUSH
36261: PPUSH
36262: PPUSH
36263: PPUSH
36264: PPUSH
// if not mc_bases then
36265: LD_EXP 89
36269: NOT
36270: IFFALSE 36274
// exit ;
36272: GO 36856
// for i = 1 to mc_bases do
36274: LD_ADDR_VAR 0 2
36278: PUSH
36279: DOUBLE
36280: LD_INT 1
36282: DEC
36283: ST_TO_ADDR
36284: LD_EXP 89
36288: PUSH
36289: FOR_TO
36290: IFFALSE 36854
// begin if not mc_bases [ i ] then
36292: LD_EXP 89
36296: PUSH
36297: LD_VAR 0 2
36301: ARRAY
36302: NOT
36303: IFFALSE 36307
// continue ;
36305: GO 36289
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36307: LD_ADDR_VAR 0 7
36311: PUSH
36312: LD_EXP 89
36316: PUSH
36317: LD_VAR 0 2
36321: ARRAY
36322: PUSH
36323: LD_INT 1
36325: ARRAY
36326: PPUSH
36327: CALL 52453 0 1
36331: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36332: LD_ADDR_EXP 112
36336: PUSH
36337: LD_EXP 112
36341: PPUSH
36342: LD_VAR 0 2
36346: PPUSH
36347: LD_EXP 89
36351: PUSH
36352: LD_VAR 0 2
36356: ARRAY
36357: PUSH
36358: LD_INT 1
36360: ARRAY
36361: PPUSH
36362: CALL_OW 255
36366: PPUSH
36367: LD_EXP 114
36371: PUSH
36372: LD_VAR 0 2
36376: ARRAY
36377: PPUSH
36378: CALL 52418 0 2
36382: PPUSH
36383: CALL_OW 1
36387: ST_TO_ADDR
// if not mc_scan [ i ] then
36388: LD_EXP 112
36392: PUSH
36393: LD_VAR 0 2
36397: ARRAY
36398: NOT
36399: IFFALSE 36554
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36401: LD_ADDR_VAR 0 4
36405: PUSH
36406: LD_EXP 89
36410: PUSH
36411: LD_VAR 0 2
36415: ARRAY
36416: PPUSH
36417: LD_INT 2
36419: PUSH
36420: LD_INT 25
36422: PUSH
36423: LD_INT 5
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 25
36432: PUSH
36433: LD_INT 8
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: LD_INT 25
36442: PUSH
36443: LD_INT 9
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: PPUSH
36456: CALL_OW 72
36460: ST_TO_ADDR
// if not tmp then
36461: LD_VAR 0 4
36465: NOT
36466: IFFALSE 36470
// continue ;
36468: GO 36289
// for j in tmp do
36470: LD_ADDR_VAR 0 3
36474: PUSH
36475: LD_VAR 0 4
36479: PUSH
36480: FOR_IN
36481: IFFALSE 36552
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36483: LD_VAR 0 3
36487: PPUSH
36488: CALL_OW 310
36492: PPUSH
36493: CALL_OW 266
36497: PUSH
36498: LD_INT 5
36500: EQUAL
36501: PUSH
36502: LD_VAR 0 3
36506: PPUSH
36507: CALL_OW 257
36511: PUSH
36512: LD_INT 1
36514: EQUAL
36515: AND
36516: PUSH
36517: LD_VAR 0 3
36521: PPUSH
36522: CALL_OW 459
36526: NOT
36527: AND
36528: PUSH
36529: LD_VAR 0 7
36533: AND
36534: IFFALSE 36550
// ComChangeProfession ( j , class ) ;
36536: LD_VAR 0 3
36540: PPUSH
36541: LD_VAR 0 7
36545: PPUSH
36546: CALL_OW 123
36550: GO 36480
36552: POP
36553: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36554: LD_EXP 112
36558: PUSH
36559: LD_VAR 0 2
36563: ARRAY
36564: PUSH
36565: LD_EXP 111
36569: PUSH
36570: LD_VAR 0 2
36574: ARRAY
36575: NOT
36576: AND
36577: PUSH
36578: LD_EXP 89
36582: PUSH
36583: LD_VAR 0 2
36587: ARRAY
36588: PPUSH
36589: LD_INT 30
36591: PUSH
36592: LD_INT 32
36594: PUSH
36595: EMPTY
36596: LIST
36597: LIST
36598: PPUSH
36599: CALL_OW 72
36603: NOT
36604: AND
36605: PUSH
36606: LD_EXP 89
36610: PUSH
36611: LD_VAR 0 2
36615: ARRAY
36616: PPUSH
36617: LD_INT 2
36619: PUSH
36620: LD_INT 30
36622: PUSH
36623: LD_INT 4
36625: PUSH
36626: EMPTY
36627: LIST
36628: LIST
36629: PUSH
36630: LD_INT 30
36632: PUSH
36633: LD_INT 5
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: LIST
36644: PPUSH
36645: CALL_OW 72
36649: NOT
36650: AND
36651: IFFALSE 36783
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36653: LD_ADDR_VAR 0 4
36657: PUSH
36658: LD_EXP 89
36662: PUSH
36663: LD_VAR 0 2
36667: ARRAY
36668: PPUSH
36669: LD_INT 2
36671: PUSH
36672: LD_INT 25
36674: PUSH
36675: LD_INT 1
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: LD_INT 25
36684: PUSH
36685: LD_INT 5
36687: PUSH
36688: EMPTY
36689: LIST
36690: LIST
36691: PUSH
36692: LD_INT 25
36694: PUSH
36695: LD_INT 8
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 25
36704: PUSH
36705: LD_INT 9
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: LIST
36716: LIST
36717: LIST
36718: PPUSH
36719: CALL_OW 72
36723: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36724: LD_ADDR_VAR 0 4
36728: PUSH
36729: LD_VAR 0 4
36733: PUSH
36734: LD_VAR 0 4
36738: PPUSH
36739: LD_INT 18
36741: PPUSH
36742: CALL 84178 0 2
36746: DIFF
36747: ST_TO_ADDR
// if tmp then
36748: LD_VAR 0 4
36752: IFFALSE 36783
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36754: LD_VAR 0 2
36758: PPUSH
36759: LD_VAR 0 4
36763: PPUSH
36764: LD_EXP 114
36768: PUSH
36769: LD_VAR 0 2
36773: ARRAY
36774: PPUSH
36775: CALL 106187 0 3
// exit ;
36779: POP
36780: POP
36781: GO 36856
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36783: LD_EXP 112
36787: PUSH
36788: LD_VAR 0 2
36792: ARRAY
36793: PUSH
36794: LD_EXP 111
36798: PUSH
36799: LD_VAR 0 2
36803: ARRAY
36804: AND
36805: IFFALSE 36852
// begin tmp := mc_defender [ i ] ;
36807: LD_ADDR_VAR 0 4
36811: PUSH
36812: LD_EXP 111
36816: PUSH
36817: LD_VAR 0 2
36821: ARRAY
36822: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36823: LD_VAR 0 2
36827: PPUSH
36828: LD_VAR 0 4
36832: PPUSH
36833: LD_EXP 112
36837: PUSH
36838: LD_VAR 0 2
36842: ARRAY
36843: PPUSH
36844: CALL 106748 0 3
// exit ;
36848: POP
36849: POP
36850: GO 36856
// end ; end ;
36852: GO 36289
36854: POP
36855: POP
// end ;
36856: LD_VAR 0 1
36860: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36861: LD_INT 0
36863: PPUSH
36864: PPUSH
36865: PPUSH
36866: PPUSH
36867: PPUSH
36868: PPUSH
36869: PPUSH
36870: PPUSH
36871: PPUSH
36872: PPUSH
36873: PPUSH
// if not mc_bases then
36874: LD_EXP 89
36878: NOT
36879: IFFALSE 36883
// exit ;
36881: GO 37970
// for i = 1 to mc_bases do
36883: LD_ADDR_VAR 0 2
36887: PUSH
36888: DOUBLE
36889: LD_INT 1
36891: DEC
36892: ST_TO_ADDR
36893: LD_EXP 89
36897: PUSH
36898: FOR_TO
36899: IFFALSE 37968
// begin tmp := mc_lab [ i ] ;
36901: LD_ADDR_VAR 0 6
36905: PUSH
36906: LD_EXP 122
36910: PUSH
36911: LD_VAR 0 2
36915: ARRAY
36916: ST_TO_ADDR
// if not tmp then
36917: LD_VAR 0 6
36921: NOT
36922: IFFALSE 36926
// continue ;
36924: GO 36898
// idle_lab := 0 ;
36926: LD_ADDR_VAR 0 11
36930: PUSH
36931: LD_INT 0
36933: ST_TO_ADDR
// for j in tmp do
36934: LD_ADDR_VAR 0 3
36938: PUSH
36939: LD_VAR 0 6
36943: PUSH
36944: FOR_IN
36945: IFFALSE 37964
// begin researching := false ;
36947: LD_ADDR_VAR 0 10
36951: PUSH
36952: LD_INT 0
36954: ST_TO_ADDR
// side := GetSide ( j ) ;
36955: LD_ADDR_VAR 0 4
36959: PUSH
36960: LD_VAR 0 3
36964: PPUSH
36965: CALL_OW 255
36969: ST_TO_ADDR
// if not mc_tech [ side ] then
36970: LD_EXP 116
36974: PUSH
36975: LD_VAR 0 4
36979: ARRAY
36980: NOT
36981: IFFALSE 36985
// continue ;
36983: GO 36944
// if BuildingStatus ( j ) = bs_idle then
36985: LD_VAR 0 3
36989: PPUSH
36990: CALL_OW 461
36994: PUSH
36995: LD_INT 2
36997: EQUAL
36998: IFFALSE 37186
// begin if idle_lab and UnitsInside ( j ) < 6 then
37000: LD_VAR 0 11
37004: PUSH
37005: LD_VAR 0 3
37009: PPUSH
37010: CALL_OW 313
37014: PUSH
37015: LD_INT 6
37017: LESS
37018: AND
37019: IFFALSE 37090
// begin tmp2 := UnitsInside ( idle_lab ) ;
37021: LD_ADDR_VAR 0 9
37025: PUSH
37026: LD_VAR 0 11
37030: PPUSH
37031: CALL_OW 313
37035: ST_TO_ADDR
// if tmp2 then
37036: LD_VAR 0 9
37040: IFFALSE 37082
// for x in tmp2 do
37042: LD_ADDR_VAR 0 7
37046: PUSH
37047: LD_VAR 0 9
37051: PUSH
37052: FOR_IN
37053: IFFALSE 37080
// begin ComExitBuilding ( x ) ;
37055: LD_VAR 0 7
37059: PPUSH
37060: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37064: LD_VAR 0 7
37068: PPUSH
37069: LD_VAR 0 3
37073: PPUSH
37074: CALL_OW 180
// end ;
37078: GO 37052
37080: POP
37081: POP
// idle_lab := 0 ;
37082: LD_ADDR_VAR 0 11
37086: PUSH
37087: LD_INT 0
37089: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37090: LD_ADDR_VAR 0 5
37094: PUSH
37095: LD_EXP 116
37099: PUSH
37100: LD_VAR 0 4
37104: ARRAY
37105: PUSH
37106: FOR_IN
37107: IFFALSE 37167
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37109: LD_VAR 0 3
37113: PPUSH
37114: LD_VAR 0 5
37118: PPUSH
37119: CALL_OW 430
37123: PUSH
37124: LD_VAR 0 4
37128: PPUSH
37129: LD_VAR 0 5
37133: PPUSH
37134: CALL 51523 0 2
37138: AND
37139: IFFALSE 37165
// begin researching := true ;
37141: LD_ADDR_VAR 0 10
37145: PUSH
37146: LD_INT 1
37148: ST_TO_ADDR
// ComResearch ( j , t ) ;
37149: LD_VAR 0 3
37153: PPUSH
37154: LD_VAR 0 5
37158: PPUSH
37159: CALL_OW 124
// break ;
37163: GO 37167
// end ;
37165: GO 37106
37167: POP
37168: POP
// if not researching then
37169: LD_VAR 0 10
37173: NOT
37174: IFFALSE 37186
// idle_lab := j ;
37176: LD_ADDR_VAR 0 11
37180: PUSH
37181: LD_VAR 0 3
37185: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37186: LD_VAR 0 3
37190: PPUSH
37191: CALL_OW 461
37195: PUSH
37196: LD_INT 10
37198: EQUAL
37199: IFFALSE 37787
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37201: LD_EXP 118
37205: PUSH
37206: LD_VAR 0 2
37210: ARRAY
37211: NOT
37212: PUSH
37213: LD_EXP 119
37217: PUSH
37218: LD_VAR 0 2
37222: ARRAY
37223: NOT
37224: AND
37225: PUSH
37226: LD_EXP 116
37230: PUSH
37231: LD_VAR 0 4
37235: ARRAY
37236: PUSH
37237: LD_INT 1
37239: GREATER
37240: AND
37241: IFFALSE 37372
// begin ComCancel ( j ) ;
37243: LD_VAR 0 3
37247: PPUSH
37248: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37252: LD_ADDR_EXP 116
37256: PUSH
37257: LD_EXP 116
37261: PPUSH
37262: LD_VAR 0 4
37266: PPUSH
37267: LD_EXP 116
37271: PUSH
37272: LD_VAR 0 4
37276: ARRAY
37277: PPUSH
37278: LD_EXP 116
37282: PUSH
37283: LD_VAR 0 4
37287: ARRAY
37288: PUSH
37289: LD_INT 1
37291: MINUS
37292: PPUSH
37293: LD_EXP 116
37297: PUSH
37298: LD_VAR 0 4
37302: ARRAY
37303: PPUSH
37304: LD_INT 0
37306: PPUSH
37307: CALL 55035 0 4
37311: PPUSH
37312: CALL_OW 1
37316: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37317: LD_ADDR_EXP 116
37321: PUSH
37322: LD_EXP 116
37326: PPUSH
37327: LD_VAR 0 4
37331: PPUSH
37332: LD_EXP 116
37336: PUSH
37337: LD_VAR 0 4
37341: ARRAY
37342: PPUSH
37343: LD_EXP 116
37347: PUSH
37348: LD_VAR 0 4
37352: ARRAY
37353: PPUSH
37354: LD_INT 1
37356: PPUSH
37357: LD_INT 0
37359: PPUSH
37360: CALL 55035 0 4
37364: PPUSH
37365: CALL_OW 1
37369: ST_TO_ADDR
// continue ;
37370: GO 36944
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37372: LD_EXP 118
37376: PUSH
37377: LD_VAR 0 2
37381: ARRAY
37382: PUSH
37383: LD_EXP 119
37387: PUSH
37388: LD_VAR 0 2
37392: ARRAY
37393: NOT
37394: AND
37395: IFFALSE 37522
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37397: LD_ADDR_EXP 119
37401: PUSH
37402: LD_EXP 119
37406: PPUSH
37407: LD_VAR 0 2
37411: PUSH
37412: LD_EXP 119
37416: PUSH
37417: LD_VAR 0 2
37421: ARRAY
37422: PUSH
37423: LD_INT 1
37425: PLUS
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PPUSH
37431: LD_EXP 118
37435: PUSH
37436: LD_VAR 0 2
37440: ARRAY
37441: PUSH
37442: LD_INT 1
37444: ARRAY
37445: PPUSH
37446: CALL 55617 0 3
37450: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37451: LD_EXP 118
37455: PUSH
37456: LD_VAR 0 2
37460: ARRAY
37461: PUSH
37462: LD_INT 1
37464: ARRAY
37465: PPUSH
37466: LD_INT 112
37468: PPUSH
37469: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37473: LD_ADDR_VAR 0 9
37477: PUSH
37478: LD_EXP 118
37482: PUSH
37483: LD_VAR 0 2
37487: ARRAY
37488: PPUSH
37489: LD_INT 1
37491: PPUSH
37492: CALL_OW 3
37496: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37497: LD_ADDR_EXP 118
37501: PUSH
37502: LD_EXP 118
37506: PPUSH
37507: LD_VAR 0 2
37511: PPUSH
37512: LD_VAR 0 9
37516: PPUSH
37517: CALL_OW 1
37521: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37522: LD_EXP 118
37526: PUSH
37527: LD_VAR 0 2
37531: ARRAY
37532: PUSH
37533: LD_EXP 119
37537: PUSH
37538: LD_VAR 0 2
37542: ARRAY
37543: AND
37544: PUSH
37545: LD_EXP 119
37549: PUSH
37550: LD_VAR 0 2
37554: ARRAY
37555: PUSH
37556: LD_INT 1
37558: ARRAY
37559: PPUSH
37560: CALL_OW 310
37564: NOT
37565: AND
37566: PUSH
37567: LD_VAR 0 3
37571: PPUSH
37572: CALL_OW 313
37576: PUSH
37577: LD_INT 6
37579: EQUAL
37580: AND
37581: IFFALSE 37637
// begin tmp2 := UnitsInside ( j ) ;
37583: LD_ADDR_VAR 0 9
37587: PUSH
37588: LD_VAR 0 3
37592: PPUSH
37593: CALL_OW 313
37597: ST_TO_ADDR
// if tmp2 = 6 then
37598: LD_VAR 0 9
37602: PUSH
37603: LD_INT 6
37605: EQUAL
37606: IFFALSE 37637
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37608: LD_VAR 0 9
37612: PUSH
37613: LD_INT 1
37615: ARRAY
37616: PPUSH
37617: LD_INT 112
37619: PPUSH
37620: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37624: LD_VAR 0 9
37628: PUSH
37629: LD_INT 1
37631: ARRAY
37632: PPUSH
37633: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37637: LD_EXP 119
37641: PUSH
37642: LD_VAR 0 2
37646: ARRAY
37647: PUSH
37648: LD_EXP 119
37652: PUSH
37653: LD_VAR 0 2
37657: ARRAY
37658: PUSH
37659: LD_INT 1
37661: ARRAY
37662: PPUSH
37663: CALL_OW 314
37667: NOT
37668: AND
37669: PUSH
37670: LD_EXP 119
37674: PUSH
37675: LD_VAR 0 2
37679: ARRAY
37680: PUSH
37681: LD_INT 1
37683: ARRAY
37684: PPUSH
37685: CALL_OW 310
37689: NOT
37690: AND
37691: IFFALSE 37717
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37693: LD_EXP 119
37697: PUSH
37698: LD_VAR 0 2
37702: ARRAY
37703: PUSH
37704: LD_INT 1
37706: ARRAY
37707: PPUSH
37708: LD_VAR 0 3
37712: PPUSH
37713: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37717: LD_EXP 119
37721: PUSH
37722: LD_VAR 0 2
37726: ARRAY
37727: PUSH
37728: LD_INT 1
37730: ARRAY
37731: PPUSH
37732: CALL_OW 310
37736: PUSH
37737: LD_EXP 119
37741: PUSH
37742: LD_VAR 0 2
37746: ARRAY
37747: PUSH
37748: LD_INT 1
37750: ARRAY
37751: PPUSH
37752: CALL_OW 310
37756: PPUSH
37757: CALL_OW 461
37761: PUSH
37762: LD_INT 3
37764: NONEQUAL
37765: AND
37766: IFFALSE 37787
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37768: LD_EXP 119
37772: PUSH
37773: LD_VAR 0 2
37777: ARRAY
37778: PUSH
37779: LD_INT 1
37781: ARRAY
37782: PPUSH
37783: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37787: LD_VAR 0 3
37791: PPUSH
37792: CALL_OW 461
37796: PUSH
37797: LD_INT 6
37799: EQUAL
37800: PUSH
37801: LD_VAR 0 6
37805: PUSH
37806: LD_INT 1
37808: GREATER
37809: AND
37810: IFFALSE 37962
// begin sci := [ ] ;
37812: LD_ADDR_VAR 0 8
37816: PUSH
37817: EMPTY
37818: ST_TO_ADDR
// for x in ( tmp diff j ) do
37819: LD_ADDR_VAR 0 7
37823: PUSH
37824: LD_VAR 0 6
37828: PUSH
37829: LD_VAR 0 3
37833: DIFF
37834: PUSH
37835: FOR_IN
37836: IFFALSE 37888
// begin if sci = 6 then
37838: LD_VAR 0 8
37842: PUSH
37843: LD_INT 6
37845: EQUAL
37846: IFFALSE 37850
// break ;
37848: GO 37888
// if BuildingStatus ( x ) = bs_idle then
37850: LD_VAR 0 7
37854: PPUSH
37855: CALL_OW 461
37859: PUSH
37860: LD_INT 2
37862: EQUAL
37863: IFFALSE 37886
// sci := sci ^ UnitsInside ( x ) ;
37865: LD_ADDR_VAR 0 8
37869: PUSH
37870: LD_VAR 0 8
37874: PUSH
37875: LD_VAR 0 7
37879: PPUSH
37880: CALL_OW 313
37884: ADD
37885: ST_TO_ADDR
// end ;
37886: GO 37835
37888: POP
37889: POP
// if not sci then
37890: LD_VAR 0 8
37894: NOT
37895: IFFALSE 37899
// continue ;
37897: GO 36944
// for x in sci do
37899: LD_ADDR_VAR 0 7
37903: PUSH
37904: LD_VAR 0 8
37908: PUSH
37909: FOR_IN
37910: IFFALSE 37960
// if IsInUnit ( x ) and not HasTask ( x ) then
37912: LD_VAR 0 7
37916: PPUSH
37917: CALL_OW 310
37921: PUSH
37922: LD_VAR 0 7
37926: PPUSH
37927: CALL_OW 314
37931: NOT
37932: AND
37933: IFFALSE 37958
// begin ComExitBuilding ( x ) ;
37935: LD_VAR 0 7
37939: PPUSH
37940: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37944: LD_VAR 0 7
37948: PPUSH
37949: LD_VAR 0 3
37953: PPUSH
37954: CALL_OW 180
// end ;
37958: GO 37909
37960: POP
37961: POP
// end ; end ;
37962: GO 36944
37964: POP
37965: POP
// end ;
37966: GO 36898
37968: POP
37969: POP
// end ;
37970: LD_VAR 0 1
37974: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37975: LD_INT 0
37977: PPUSH
37978: PPUSH
// if not mc_bases then
37979: LD_EXP 89
37983: NOT
37984: IFFALSE 37988
// exit ;
37986: GO 38069
// for i = 1 to mc_bases do
37988: LD_ADDR_VAR 0 2
37992: PUSH
37993: DOUBLE
37994: LD_INT 1
37996: DEC
37997: ST_TO_ADDR
37998: LD_EXP 89
38002: PUSH
38003: FOR_TO
38004: IFFALSE 38067
// if mc_mines [ i ] and mc_miners [ i ] then
38006: LD_EXP 102
38010: PUSH
38011: LD_VAR 0 2
38015: ARRAY
38016: PUSH
38017: LD_EXP 103
38021: PUSH
38022: LD_VAR 0 2
38026: ARRAY
38027: AND
38028: IFFALSE 38065
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38030: LD_EXP 103
38034: PUSH
38035: LD_VAR 0 2
38039: ARRAY
38040: PUSH
38041: LD_INT 1
38043: ARRAY
38044: PPUSH
38045: CALL_OW 255
38049: PPUSH
38050: LD_EXP 102
38054: PUSH
38055: LD_VAR 0 2
38059: ARRAY
38060: PPUSH
38061: CALL 52606 0 2
38065: GO 38003
38067: POP
38068: POP
// end ;
38069: LD_VAR 0 1
38073: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38074: LD_INT 0
38076: PPUSH
38077: PPUSH
38078: PPUSH
38079: PPUSH
38080: PPUSH
38081: PPUSH
38082: PPUSH
38083: PPUSH
// if not mc_bases or not mc_parking then
38084: LD_EXP 89
38088: NOT
38089: PUSH
38090: LD_EXP 113
38094: NOT
38095: OR
38096: IFFALSE 38100
// exit ;
38098: GO 38799
// for i = 1 to mc_bases do
38100: LD_ADDR_VAR 0 2
38104: PUSH
38105: DOUBLE
38106: LD_INT 1
38108: DEC
38109: ST_TO_ADDR
38110: LD_EXP 89
38114: PUSH
38115: FOR_TO
38116: IFFALSE 38797
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38118: LD_EXP 89
38122: PUSH
38123: LD_VAR 0 2
38127: ARRAY
38128: NOT
38129: PUSH
38130: LD_EXP 113
38134: PUSH
38135: LD_VAR 0 2
38139: ARRAY
38140: NOT
38141: OR
38142: IFFALSE 38146
// continue ;
38144: GO 38115
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38146: LD_ADDR_VAR 0 5
38150: PUSH
38151: LD_EXP 89
38155: PUSH
38156: LD_VAR 0 2
38160: ARRAY
38161: PUSH
38162: LD_INT 1
38164: ARRAY
38165: PPUSH
38166: CALL_OW 255
38170: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38171: LD_ADDR_VAR 0 6
38175: PUSH
38176: LD_EXP 89
38180: PUSH
38181: LD_VAR 0 2
38185: ARRAY
38186: PPUSH
38187: LD_INT 30
38189: PUSH
38190: LD_INT 3
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PPUSH
38197: CALL_OW 72
38201: ST_TO_ADDR
// if not fac then
38202: LD_VAR 0 6
38206: NOT
38207: IFFALSE 38258
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38209: LD_ADDR_VAR 0 6
38213: PUSH
38214: LD_EXP 89
38218: PUSH
38219: LD_VAR 0 2
38223: ARRAY
38224: PPUSH
38225: LD_INT 2
38227: PUSH
38228: LD_INT 30
38230: PUSH
38231: LD_INT 0
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 30
38240: PUSH
38241: LD_INT 1
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: LIST
38252: PPUSH
38253: CALL_OW 72
38257: ST_TO_ADDR
// if not fac then
38258: LD_VAR 0 6
38262: NOT
38263: IFFALSE 38267
// continue ;
38265: GO 38115
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38267: LD_ADDR_VAR 0 7
38271: PUSH
38272: LD_EXP 113
38276: PUSH
38277: LD_VAR 0 2
38281: ARRAY
38282: PPUSH
38283: LD_INT 22
38285: PUSH
38286: LD_VAR 0 5
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 21
38297: PUSH
38298: LD_INT 2
38300: PUSH
38301: EMPTY
38302: LIST
38303: LIST
38304: PUSH
38305: LD_INT 3
38307: PUSH
38308: LD_INT 24
38310: PUSH
38311: LD_INT 1000
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: LIST
38326: PPUSH
38327: CALL_OW 70
38331: ST_TO_ADDR
// for j in fac do
38332: LD_ADDR_VAR 0 3
38336: PUSH
38337: LD_VAR 0 6
38341: PUSH
38342: FOR_IN
38343: IFFALSE 38424
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38345: LD_ADDR_VAR 0 7
38349: PUSH
38350: LD_VAR 0 7
38354: PUSH
38355: LD_INT 22
38357: PUSH
38358: LD_VAR 0 5
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: PUSH
38367: LD_INT 91
38369: PUSH
38370: LD_VAR 0 3
38374: PUSH
38375: LD_INT 15
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 21
38385: PUSH
38386: LD_INT 2
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 3
38395: PUSH
38396: LD_INT 24
38398: PUSH
38399: LD_INT 1000
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: PPUSH
38416: CALL_OW 69
38420: UNION
38421: ST_TO_ADDR
38422: GO 38342
38424: POP
38425: POP
// if not vehs then
38426: LD_VAR 0 7
38430: NOT
38431: IFFALSE 38457
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38433: LD_ADDR_EXP 101
38437: PUSH
38438: LD_EXP 101
38442: PPUSH
38443: LD_VAR 0 2
38447: PPUSH
38448: EMPTY
38449: PPUSH
38450: CALL_OW 1
38454: ST_TO_ADDR
// continue ;
38455: GO 38115
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38457: LD_ADDR_VAR 0 8
38461: PUSH
38462: LD_EXP 89
38466: PUSH
38467: LD_VAR 0 2
38471: ARRAY
38472: PPUSH
38473: LD_INT 30
38475: PUSH
38476: LD_INT 3
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PPUSH
38483: CALL_OW 72
38487: ST_TO_ADDR
// if tmp then
38488: LD_VAR 0 8
38492: IFFALSE 38595
// begin for j in tmp do
38494: LD_ADDR_VAR 0 3
38498: PUSH
38499: LD_VAR 0 8
38503: PUSH
38504: FOR_IN
38505: IFFALSE 38593
// for k in UnitsInside ( j ) do
38507: LD_ADDR_VAR 0 4
38511: PUSH
38512: LD_VAR 0 3
38516: PPUSH
38517: CALL_OW 313
38521: PUSH
38522: FOR_IN
38523: IFFALSE 38589
// if k then
38525: LD_VAR 0 4
38529: IFFALSE 38587
// if not k in mc_repair_vehicle [ i ] then
38531: LD_VAR 0 4
38535: PUSH
38536: LD_EXP 101
38540: PUSH
38541: LD_VAR 0 2
38545: ARRAY
38546: IN
38547: NOT
38548: IFFALSE 38587
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38550: LD_ADDR_EXP 101
38554: PUSH
38555: LD_EXP 101
38559: PPUSH
38560: LD_VAR 0 2
38564: PPUSH
38565: LD_EXP 101
38569: PUSH
38570: LD_VAR 0 2
38574: ARRAY
38575: PUSH
38576: LD_VAR 0 4
38580: UNION
38581: PPUSH
38582: CALL_OW 1
38586: ST_TO_ADDR
38587: GO 38522
38589: POP
38590: POP
38591: GO 38504
38593: POP
38594: POP
// end ; if not mc_repair_vehicle [ i ] then
38595: LD_EXP 101
38599: PUSH
38600: LD_VAR 0 2
38604: ARRAY
38605: NOT
38606: IFFALSE 38610
// continue ;
38608: GO 38115
// for j in mc_repair_vehicle [ i ] do
38610: LD_ADDR_VAR 0 3
38614: PUSH
38615: LD_EXP 101
38619: PUSH
38620: LD_VAR 0 2
38624: ARRAY
38625: PUSH
38626: FOR_IN
38627: IFFALSE 38793
// begin if GetClass ( j ) <> 3 then
38629: LD_VAR 0 3
38633: PPUSH
38634: CALL_OW 257
38638: PUSH
38639: LD_INT 3
38641: NONEQUAL
38642: IFFALSE 38683
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38644: LD_ADDR_EXP 101
38648: PUSH
38649: LD_EXP 101
38653: PPUSH
38654: LD_VAR 0 2
38658: PPUSH
38659: LD_EXP 101
38663: PUSH
38664: LD_VAR 0 2
38668: ARRAY
38669: PUSH
38670: LD_VAR 0 3
38674: DIFF
38675: PPUSH
38676: CALL_OW 1
38680: ST_TO_ADDR
// continue ;
38681: GO 38626
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38683: LD_VAR 0 3
38687: PPUSH
38688: CALL_OW 311
38692: NOT
38693: PUSH
38694: LD_VAR 0 3
38698: PUSH
38699: LD_EXP 92
38703: PUSH
38704: LD_VAR 0 2
38708: ARRAY
38709: PUSH
38710: LD_INT 1
38712: ARRAY
38713: IN
38714: NOT
38715: AND
38716: PUSH
38717: LD_VAR 0 3
38721: PUSH
38722: LD_EXP 92
38726: PUSH
38727: LD_VAR 0 2
38731: ARRAY
38732: PUSH
38733: LD_INT 2
38735: ARRAY
38736: IN
38737: NOT
38738: AND
38739: IFFALSE 38791
// begin if IsInUnit ( j ) then
38741: LD_VAR 0 3
38745: PPUSH
38746: CALL_OW 310
38750: IFFALSE 38761
// ComExitBuilding ( j ) ;
38752: LD_VAR 0 3
38756: PPUSH
38757: CALL_OW 122
// if not HasTask ( j ) then
38761: LD_VAR 0 3
38765: PPUSH
38766: CALL_OW 314
38770: NOT
38771: IFFALSE 38791
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38773: LD_VAR 0 3
38777: PPUSH
38778: LD_VAR 0 7
38782: PUSH
38783: LD_INT 1
38785: ARRAY
38786: PPUSH
38787: CALL_OW 189
// end ; end ;
38791: GO 38626
38793: POP
38794: POP
// end ;
38795: GO 38115
38797: POP
38798: POP
// end ;
38799: LD_VAR 0 1
38803: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38804: LD_INT 0
38806: PPUSH
38807: PPUSH
38808: PPUSH
38809: PPUSH
38810: PPUSH
38811: PPUSH
38812: PPUSH
38813: PPUSH
38814: PPUSH
38815: PPUSH
38816: PPUSH
// if not mc_bases then
38817: LD_EXP 89
38821: NOT
38822: IFFALSE 38826
// exit ;
38824: GO 39628
// for i = 1 to mc_bases do
38826: LD_ADDR_VAR 0 2
38830: PUSH
38831: DOUBLE
38832: LD_INT 1
38834: DEC
38835: ST_TO_ADDR
38836: LD_EXP 89
38840: PUSH
38841: FOR_TO
38842: IFFALSE 39626
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38844: LD_EXP 117
38848: PUSH
38849: LD_VAR 0 2
38853: ARRAY
38854: NOT
38855: PUSH
38856: LD_EXP 92
38860: PUSH
38861: LD_VAR 0 2
38865: ARRAY
38866: PUSH
38867: LD_INT 1
38869: ARRAY
38870: OR
38871: PUSH
38872: LD_EXP 92
38876: PUSH
38877: LD_VAR 0 2
38881: ARRAY
38882: PUSH
38883: LD_INT 2
38885: ARRAY
38886: OR
38887: PUSH
38888: LD_EXP 115
38892: PUSH
38893: LD_VAR 0 2
38897: ARRAY
38898: PPUSH
38899: LD_INT 1
38901: PPUSH
38902: CALL_OW 325
38906: NOT
38907: OR
38908: PUSH
38909: LD_EXP 112
38913: PUSH
38914: LD_VAR 0 2
38918: ARRAY
38919: OR
38920: IFFALSE 38924
// continue ;
38922: GO 38841
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38924: LD_ADDR_VAR 0 8
38928: PUSH
38929: LD_EXP 89
38933: PUSH
38934: LD_VAR 0 2
38938: ARRAY
38939: PPUSH
38940: LD_INT 25
38942: PUSH
38943: LD_INT 4
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 50
38952: PUSH
38953: EMPTY
38954: LIST
38955: PUSH
38956: LD_INT 3
38958: PUSH
38959: LD_INT 60
38961: PUSH
38962: EMPTY
38963: LIST
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: LIST
38973: PPUSH
38974: CALL_OW 72
38978: PUSH
38979: LD_EXP 93
38983: PUSH
38984: LD_VAR 0 2
38988: ARRAY
38989: DIFF
38990: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38991: LD_ADDR_VAR 0 9
38995: PUSH
38996: LD_EXP 89
39000: PUSH
39001: LD_VAR 0 2
39005: ARRAY
39006: PPUSH
39007: LD_INT 2
39009: PUSH
39010: LD_INT 30
39012: PUSH
39013: LD_INT 0
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: LD_INT 30
39022: PUSH
39023: LD_INT 1
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: LIST
39034: PPUSH
39035: CALL_OW 72
39039: ST_TO_ADDR
// if not tmp or not dep then
39040: LD_VAR 0 8
39044: NOT
39045: PUSH
39046: LD_VAR 0 9
39050: NOT
39051: OR
39052: IFFALSE 39056
// continue ;
39054: GO 38841
// side := GetSide ( tmp [ 1 ] ) ;
39056: LD_ADDR_VAR 0 11
39060: PUSH
39061: LD_VAR 0 8
39065: PUSH
39066: LD_INT 1
39068: ARRAY
39069: PPUSH
39070: CALL_OW 255
39074: ST_TO_ADDR
// dep := dep [ 1 ] ;
39075: LD_ADDR_VAR 0 9
39079: PUSH
39080: LD_VAR 0 9
39084: PUSH
39085: LD_INT 1
39087: ARRAY
39088: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39089: LD_ADDR_VAR 0 7
39093: PUSH
39094: LD_EXP 117
39098: PUSH
39099: LD_VAR 0 2
39103: ARRAY
39104: PPUSH
39105: LD_INT 22
39107: PUSH
39108: LD_INT 0
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 25
39117: PUSH
39118: LD_INT 12
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PPUSH
39129: CALL_OW 70
39133: PUSH
39134: LD_INT 22
39136: PUSH
39137: LD_INT 0
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: LD_INT 25
39146: PUSH
39147: LD_INT 12
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 91
39156: PUSH
39157: LD_VAR 0 9
39161: PUSH
39162: LD_INT 20
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: LIST
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: LIST
39174: PPUSH
39175: CALL_OW 69
39179: UNION
39180: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39181: LD_ADDR_VAR 0 10
39185: PUSH
39186: LD_EXP 117
39190: PUSH
39191: LD_VAR 0 2
39195: ARRAY
39196: PPUSH
39197: LD_INT 81
39199: PUSH
39200: LD_VAR 0 11
39204: PUSH
39205: EMPTY
39206: LIST
39207: LIST
39208: PPUSH
39209: CALL_OW 70
39213: ST_TO_ADDR
// if not apes or danger_at_area then
39214: LD_VAR 0 7
39218: NOT
39219: PUSH
39220: LD_VAR 0 10
39224: OR
39225: IFFALSE 39275
// begin if mc_taming [ i ] then
39227: LD_EXP 120
39231: PUSH
39232: LD_VAR 0 2
39236: ARRAY
39237: IFFALSE 39273
// begin MC_Reset ( i , 121 ) ;
39239: LD_VAR 0 2
39243: PPUSH
39244: LD_INT 121
39246: PPUSH
39247: CALL 24726 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39251: LD_ADDR_EXP 120
39255: PUSH
39256: LD_EXP 120
39260: PPUSH
39261: LD_VAR 0 2
39265: PPUSH
39266: EMPTY
39267: PPUSH
39268: CALL_OW 1
39272: ST_TO_ADDR
// end ; continue ;
39273: GO 38841
// end ; for j in tmp do
39275: LD_ADDR_VAR 0 3
39279: PUSH
39280: LD_VAR 0 8
39284: PUSH
39285: FOR_IN
39286: IFFALSE 39622
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39288: LD_VAR 0 3
39292: PUSH
39293: LD_EXP 120
39297: PUSH
39298: LD_VAR 0 2
39302: ARRAY
39303: IN
39304: NOT
39305: PUSH
39306: LD_EXP 120
39310: PUSH
39311: LD_VAR 0 2
39315: ARRAY
39316: PUSH
39317: LD_INT 3
39319: LESS
39320: AND
39321: IFFALSE 39379
// begin SetTag ( j , 121 ) ;
39323: LD_VAR 0 3
39327: PPUSH
39328: LD_INT 121
39330: PPUSH
39331: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39335: LD_ADDR_EXP 120
39339: PUSH
39340: LD_EXP 120
39344: PPUSH
39345: LD_VAR 0 2
39349: PUSH
39350: LD_EXP 120
39354: PUSH
39355: LD_VAR 0 2
39359: ARRAY
39360: PUSH
39361: LD_INT 1
39363: PLUS
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PPUSH
39369: LD_VAR 0 3
39373: PPUSH
39374: CALL 55617 0 3
39378: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39379: LD_VAR 0 3
39383: PUSH
39384: LD_EXP 120
39388: PUSH
39389: LD_VAR 0 2
39393: ARRAY
39394: IN
39395: IFFALSE 39620
// begin if GetClass ( j ) <> 4 then
39397: LD_VAR 0 3
39401: PPUSH
39402: CALL_OW 257
39406: PUSH
39407: LD_INT 4
39409: NONEQUAL
39410: IFFALSE 39463
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39412: LD_ADDR_EXP 120
39416: PUSH
39417: LD_EXP 120
39421: PPUSH
39422: LD_VAR 0 2
39426: PPUSH
39427: LD_EXP 120
39431: PUSH
39432: LD_VAR 0 2
39436: ARRAY
39437: PUSH
39438: LD_VAR 0 3
39442: DIFF
39443: PPUSH
39444: CALL_OW 1
39448: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39449: LD_VAR 0 3
39453: PPUSH
39454: LD_INT 0
39456: PPUSH
39457: CALL_OW 109
// continue ;
39461: GO 39285
// end ; if IsInUnit ( j ) then
39463: LD_VAR 0 3
39467: PPUSH
39468: CALL_OW 310
39472: IFFALSE 39483
// ComExitBuilding ( j ) ;
39474: LD_VAR 0 3
39478: PPUSH
39479: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39483: LD_ADDR_VAR 0 6
39487: PUSH
39488: LD_VAR 0 7
39492: PPUSH
39493: LD_VAR 0 3
39497: PPUSH
39498: CALL_OW 74
39502: ST_TO_ADDR
// if not ape then
39503: LD_VAR 0 6
39507: NOT
39508: IFFALSE 39512
// break ;
39510: GO 39622
// x := GetX ( ape ) ;
39512: LD_ADDR_VAR 0 4
39516: PUSH
39517: LD_VAR 0 6
39521: PPUSH
39522: CALL_OW 250
39526: ST_TO_ADDR
// y := GetY ( ape ) ;
39527: LD_ADDR_VAR 0 5
39531: PUSH
39532: LD_VAR 0 6
39536: PPUSH
39537: CALL_OW 251
39541: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39542: LD_VAR 0 4
39546: PPUSH
39547: LD_VAR 0 5
39551: PPUSH
39552: CALL_OW 488
39556: NOT
39557: PUSH
39558: LD_VAR 0 11
39562: PPUSH
39563: LD_VAR 0 4
39567: PPUSH
39568: LD_VAR 0 5
39572: PPUSH
39573: LD_INT 20
39575: PPUSH
39576: CALL 56513 0 4
39580: PUSH
39581: LD_INT 4
39583: ARRAY
39584: OR
39585: IFFALSE 39589
// break ;
39587: GO 39622
// if not HasTask ( j ) then
39589: LD_VAR 0 3
39593: PPUSH
39594: CALL_OW 314
39598: NOT
39599: IFFALSE 39620
// ComTameXY ( j , x , y ) ;
39601: LD_VAR 0 3
39605: PPUSH
39606: LD_VAR 0 4
39610: PPUSH
39611: LD_VAR 0 5
39615: PPUSH
39616: CALL_OW 131
// end ; end ;
39620: GO 39285
39622: POP
39623: POP
// end ;
39624: GO 38841
39626: POP
39627: POP
// end ;
39628: LD_VAR 0 1
39632: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39633: LD_INT 0
39635: PPUSH
39636: PPUSH
39637: PPUSH
39638: PPUSH
39639: PPUSH
39640: PPUSH
39641: PPUSH
39642: PPUSH
// if not mc_bases then
39643: LD_EXP 89
39647: NOT
39648: IFFALSE 39652
// exit ;
39650: GO 40278
// for i = 1 to mc_bases do
39652: LD_ADDR_VAR 0 2
39656: PUSH
39657: DOUBLE
39658: LD_INT 1
39660: DEC
39661: ST_TO_ADDR
39662: LD_EXP 89
39666: PUSH
39667: FOR_TO
39668: IFFALSE 40276
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39670: LD_EXP 118
39674: PUSH
39675: LD_VAR 0 2
39679: ARRAY
39680: NOT
39681: PUSH
39682: LD_EXP 118
39686: PUSH
39687: LD_VAR 0 2
39691: ARRAY
39692: PPUSH
39693: LD_INT 25
39695: PUSH
39696: LD_INT 12
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PPUSH
39703: CALL_OW 72
39707: NOT
39708: OR
39709: IFFALSE 39713
// continue ;
39711: GO 39667
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39713: LD_ADDR_VAR 0 5
39717: PUSH
39718: LD_EXP 118
39722: PUSH
39723: LD_VAR 0 2
39727: ARRAY
39728: PUSH
39729: LD_INT 1
39731: ARRAY
39732: PPUSH
39733: CALL_OW 255
39737: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39738: LD_VAR 0 5
39742: PPUSH
39743: LD_INT 2
39745: PPUSH
39746: CALL_OW 325
39750: IFFALSE 40003
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39752: LD_ADDR_VAR 0 4
39756: PUSH
39757: LD_EXP 118
39761: PUSH
39762: LD_VAR 0 2
39766: ARRAY
39767: PPUSH
39768: LD_INT 25
39770: PUSH
39771: LD_INT 16
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PPUSH
39778: CALL_OW 72
39782: ST_TO_ADDR
// if tmp < 6 then
39783: LD_VAR 0 4
39787: PUSH
39788: LD_INT 6
39790: LESS
39791: IFFALSE 40003
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39793: LD_ADDR_VAR 0 6
39797: PUSH
39798: LD_EXP 89
39802: PUSH
39803: LD_VAR 0 2
39807: ARRAY
39808: PPUSH
39809: LD_INT 2
39811: PUSH
39812: LD_INT 30
39814: PUSH
39815: LD_INT 0
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 30
39824: PUSH
39825: LD_INT 1
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: LIST
39836: PPUSH
39837: CALL_OW 72
39841: ST_TO_ADDR
// if depot then
39842: LD_VAR 0 6
39846: IFFALSE 40003
// begin selected := 0 ;
39848: LD_ADDR_VAR 0 7
39852: PUSH
39853: LD_INT 0
39855: ST_TO_ADDR
// for j in depot do
39856: LD_ADDR_VAR 0 3
39860: PUSH
39861: LD_VAR 0 6
39865: PUSH
39866: FOR_IN
39867: IFFALSE 39898
// begin if UnitsInside ( j ) < 6 then
39869: LD_VAR 0 3
39873: PPUSH
39874: CALL_OW 313
39878: PUSH
39879: LD_INT 6
39881: LESS
39882: IFFALSE 39896
// begin selected := j ;
39884: LD_ADDR_VAR 0 7
39888: PUSH
39889: LD_VAR 0 3
39893: ST_TO_ADDR
// break ;
39894: GO 39898
// end ; end ;
39896: GO 39866
39898: POP
39899: POP
// if selected then
39900: LD_VAR 0 7
39904: IFFALSE 40003
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39906: LD_ADDR_VAR 0 3
39910: PUSH
39911: LD_EXP 118
39915: PUSH
39916: LD_VAR 0 2
39920: ARRAY
39921: PPUSH
39922: LD_INT 25
39924: PUSH
39925: LD_INT 12
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PPUSH
39932: CALL_OW 72
39936: PUSH
39937: FOR_IN
39938: IFFALSE 40001
// if not HasTask ( j ) then
39940: LD_VAR 0 3
39944: PPUSH
39945: CALL_OW 314
39949: NOT
39950: IFFALSE 39999
// begin if not IsInUnit ( j ) then
39952: LD_VAR 0 3
39956: PPUSH
39957: CALL_OW 310
39961: NOT
39962: IFFALSE 39978
// ComEnterUnit ( j , selected ) ;
39964: LD_VAR 0 3
39968: PPUSH
39969: LD_VAR 0 7
39973: PPUSH
39974: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39978: LD_VAR 0 3
39982: PPUSH
39983: LD_INT 16
39985: PPUSH
39986: CALL_OW 183
// AddComExitBuilding ( j ) ;
39990: LD_VAR 0 3
39994: PPUSH
39995: CALL_OW 182
// end ;
39999: GO 39937
40001: POP
40002: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40003: LD_VAR 0 5
40007: PPUSH
40008: LD_INT 11
40010: PPUSH
40011: CALL_OW 325
40015: IFFALSE 40274
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40017: LD_ADDR_VAR 0 4
40021: PUSH
40022: LD_EXP 118
40026: PUSH
40027: LD_VAR 0 2
40031: ARRAY
40032: PPUSH
40033: LD_INT 25
40035: PUSH
40036: LD_INT 16
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PPUSH
40043: CALL_OW 72
40047: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40048: LD_VAR 0 4
40052: PUSH
40053: LD_INT 6
40055: GREATEREQUAL
40056: PUSH
40057: LD_VAR 0 5
40061: PPUSH
40062: LD_INT 2
40064: PPUSH
40065: CALL_OW 325
40069: NOT
40070: OR
40071: IFFALSE 40274
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40073: LD_ADDR_VAR 0 8
40077: PUSH
40078: LD_EXP 89
40082: PUSH
40083: LD_VAR 0 2
40087: ARRAY
40088: PPUSH
40089: LD_INT 2
40091: PUSH
40092: LD_INT 30
40094: PUSH
40095: LD_INT 4
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 30
40104: PUSH
40105: LD_INT 5
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: LIST
40116: PPUSH
40117: CALL_OW 72
40121: ST_TO_ADDR
// if barracks then
40122: LD_VAR 0 8
40126: IFFALSE 40274
// begin selected := 0 ;
40128: LD_ADDR_VAR 0 7
40132: PUSH
40133: LD_INT 0
40135: ST_TO_ADDR
// for j in barracks do
40136: LD_ADDR_VAR 0 3
40140: PUSH
40141: LD_VAR 0 8
40145: PUSH
40146: FOR_IN
40147: IFFALSE 40178
// begin if UnitsInside ( j ) < 6 then
40149: LD_VAR 0 3
40153: PPUSH
40154: CALL_OW 313
40158: PUSH
40159: LD_INT 6
40161: LESS
40162: IFFALSE 40176
// begin selected := j ;
40164: LD_ADDR_VAR 0 7
40168: PUSH
40169: LD_VAR 0 3
40173: ST_TO_ADDR
// break ;
40174: GO 40178
// end ; end ;
40176: GO 40146
40178: POP
40179: POP
// if selected then
40180: LD_VAR 0 7
40184: IFFALSE 40274
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40186: LD_ADDR_VAR 0 3
40190: PUSH
40191: LD_EXP 118
40195: PUSH
40196: LD_VAR 0 2
40200: ARRAY
40201: PPUSH
40202: LD_INT 25
40204: PUSH
40205: LD_INT 12
40207: PUSH
40208: EMPTY
40209: LIST
40210: LIST
40211: PPUSH
40212: CALL_OW 72
40216: PUSH
40217: FOR_IN
40218: IFFALSE 40272
// if not IsInUnit ( j ) and not HasTask ( j ) then
40220: LD_VAR 0 3
40224: PPUSH
40225: CALL_OW 310
40229: NOT
40230: PUSH
40231: LD_VAR 0 3
40235: PPUSH
40236: CALL_OW 314
40240: NOT
40241: AND
40242: IFFALSE 40270
// begin ComEnterUnit ( j , selected ) ;
40244: LD_VAR 0 3
40248: PPUSH
40249: LD_VAR 0 7
40253: PPUSH
40254: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40258: LD_VAR 0 3
40262: PPUSH
40263: LD_INT 15
40265: PPUSH
40266: CALL_OW 183
// end ;
40270: GO 40217
40272: POP
40273: POP
// end ; end ; end ; end ; end ;
40274: GO 39667
40276: POP
40277: POP
// end ;
40278: LD_VAR 0 1
40282: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40283: LD_INT 0
40285: PPUSH
40286: PPUSH
40287: PPUSH
40288: PPUSH
// if not mc_bases then
40289: LD_EXP 89
40293: NOT
40294: IFFALSE 40298
// exit ;
40296: GO 40476
// for i = 1 to mc_bases do
40298: LD_ADDR_VAR 0 2
40302: PUSH
40303: DOUBLE
40304: LD_INT 1
40306: DEC
40307: ST_TO_ADDR
40308: LD_EXP 89
40312: PUSH
40313: FOR_TO
40314: IFFALSE 40474
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40316: LD_ADDR_VAR 0 4
40320: PUSH
40321: LD_EXP 89
40325: PUSH
40326: LD_VAR 0 2
40330: ARRAY
40331: PPUSH
40332: LD_INT 25
40334: PUSH
40335: LD_INT 9
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PPUSH
40342: CALL_OW 72
40346: ST_TO_ADDR
// if not tmp then
40347: LD_VAR 0 4
40351: NOT
40352: IFFALSE 40356
// continue ;
40354: GO 40313
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40356: LD_EXP 115
40360: PUSH
40361: LD_VAR 0 2
40365: ARRAY
40366: PPUSH
40367: LD_INT 29
40369: PPUSH
40370: CALL_OW 325
40374: NOT
40375: PUSH
40376: LD_EXP 115
40380: PUSH
40381: LD_VAR 0 2
40385: ARRAY
40386: PPUSH
40387: LD_INT 28
40389: PPUSH
40390: CALL_OW 325
40394: NOT
40395: AND
40396: IFFALSE 40400
// continue ;
40398: GO 40313
// for j in tmp do
40400: LD_ADDR_VAR 0 3
40404: PUSH
40405: LD_VAR 0 4
40409: PUSH
40410: FOR_IN
40411: IFFALSE 40470
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40413: LD_VAR 0 3
40417: PUSH
40418: LD_EXP 92
40422: PUSH
40423: LD_VAR 0 2
40427: ARRAY
40428: PUSH
40429: LD_INT 1
40431: ARRAY
40432: IN
40433: NOT
40434: PUSH
40435: LD_VAR 0 3
40439: PUSH
40440: LD_EXP 92
40444: PUSH
40445: LD_VAR 0 2
40449: ARRAY
40450: PUSH
40451: LD_INT 2
40453: ARRAY
40454: IN
40455: NOT
40456: AND
40457: IFFALSE 40468
// ComSpaceTimeShoot ( j ) ;
40459: LD_VAR 0 3
40463: PPUSH
40464: CALL 51614 0 1
40468: GO 40410
40470: POP
40471: POP
// end ;
40472: GO 40313
40474: POP
40475: POP
// end ;
40476: LD_VAR 0 1
40480: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40481: LD_INT 0
40483: PPUSH
40484: PPUSH
40485: PPUSH
40486: PPUSH
40487: PPUSH
40488: PPUSH
40489: PPUSH
40490: PPUSH
40491: PPUSH
// if not mc_bases then
40492: LD_EXP 89
40496: NOT
40497: IFFALSE 40501
// exit ;
40499: GO 41123
// for i = 1 to mc_bases do
40501: LD_ADDR_VAR 0 2
40505: PUSH
40506: DOUBLE
40507: LD_INT 1
40509: DEC
40510: ST_TO_ADDR
40511: LD_EXP 89
40515: PUSH
40516: FOR_TO
40517: IFFALSE 41121
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40519: LD_EXP 124
40523: PUSH
40524: LD_VAR 0 2
40528: ARRAY
40529: NOT
40530: PUSH
40531: LD_INT 38
40533: PPUSH
40534: LD_EXP 115
40538: PUSH
40539: LD_VAR 0 2
40543: ARRAY
40544: PPUSH
40545: CALL_OW 321
40549: PUSH
40550: LD_INT 2
40552: NONEQUAL
40553: OR
40554: IFFALSE 40558
// continue ;
40556: GO 40516
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40558: LD_ADDR_VAR 0 8
40562: PUSH
40563: LD_EXP 89
40567: PUSH
40568: LD_VAR 0 2
40572: ARRAY
40573: PPUSH
40574: LD_INT 30
40576: PUSH
40577: LD_INT 34
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PPUSH
40584: CALL_OW 72
40588: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40589: LD_ADDR_VAR 0 9
40593: PUSH
40594: LD_EXP 89
40598: PUSH
40599: LD_VAR 0 2
40603: ARRAY
40604: PPUSH
40605: LD_INT 25
40607: PUSH
40608: LD_INT 4
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PPUSH
40615: CALL_OW 72
40619: PPUSH
40620: LD_INT 0
40622: PPUSH
40623: CALL 84178 0 2
40627: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40628: LD_VAR 0 9
40632: NOT
40633: PUSH
40634: LD_VAR 0 8
40638: NOT
40639: OR
40640: PUSH
40641: LD_EXP 89
40645: PUSH
40646: LD_VAR 0 2
40650: ARRAY
40651: PPUSH
40652: LD_INT 124
40654: PPUSH
40655: CALL 84178 0 2
40659: OR
40660: IFFALSE 40664
// continue ;
40662: GO 40516
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40664: LD_EXP 125
40668: PUSH
40669: LD_VAR 0 2
40673: ARRAY
40674: PUSH
40675: LD_EXP 124
40679: PUSH
40680: LD_VAR 0 2
40684: ARRAY
40685: LESS
40686: PUSH
40687: LD_EXP 125
40691: PUSH
40692: LD_VAR 0 2
40696: ARRAY
40697: PUSH
40698: LD_VAR 0 8
40702: LESS
40703: AND
40704: IFFALSE 41119
// begin tmp := sci [ 1 ] ;
40706: LD_ADDR_VAR 0 7
40710: PUSH
40711: LD_VAR 0 9
40715: PUSH
40716: LD_INT 1
40718: ARRAY
40719: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40720: LD_VAR 0 7
40724: PPUSH
40725: LD_INT 124
40727: PPUSH
40728: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40732: LD_ADDR_VAR 0 3
40736: PUSH
40737: DOUBLE
40738: LD_EXP 124
40742: PUSH
40743: LD_VAR 0 2
40747: ARRAY
40748: INC
40749: ST_TO_ADDR
40750: LD_EXP 124
40754: PUSH
40755: LD_VAR 0 2
40759: ARRAY
40760: PUSH
40761: FOR_DOWNTO
40762: IFFALSE 41105
// begin if IsInUnit ( tmp ) then
40764: LD_VAR 0 7
40768: PPUSH
40769: CALL_OW 310
40773: IFFALSE 40784
// ComExitBuilding ( tmp ) ;
40775: LD_VAR 0 7
40779: PPUSH
40780: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40784: LD_INT 35
40786: PPUSH
40787: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40791: LD_VAR 0 7
40795: PPUSH
40796: CALL_OW 310
40800: NOT
40801: PUSH
40802: LD_VAR 0 7
40806: PPUSH
40807: CALL_OW 314
40811: NOT
40812: AND
40813: IFFALSE 40784
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40815: LD_ADDR_VAR 0 6
40819: PUSH
40820: LD_VAR 0 7
40824: PPUSH
40825: CALL_OW 250
40829: PUSH
40830: LD_VAR 0 7
40834: PPUSH
40835: CALL_OW 251
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40844: LD_INT 35
40846: PPUSH
40847: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40851: LD_ADDR_VAR 0 4
40855: PUSH
40856: LD_EXP 124
40860: PUSH
40861: LD_VAR 0 2
40865: ARRAY
40866: PUSH
40867: LD_VAR 0 3
40871: ARRAY
40872: PUSH
40873: LD_INT 1
40875: ARRAY
40876: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40877: LD_ADDR_VAR 0 5
40881: PUSH
40882: LD_EXP 124
40886: PUSH
40887: LD_VAR 0 2
40891: ARRAY
40892: PUSH
40893: LD_VAR 0 3
40897: ARRAY
40898: PUSH
40899: LD_INT 2
40901: ARRAY
40902: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40903: LD_VAR 0 7
40907: PPUSH
40908: LD_INT 10
40910: PPUSH
40911: CALL 58210 0 2
40915: PUSH
40916: LD_INT 4
40918: ARRAY
40919: IFFALSE 40957
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40921: LD_VAR 0 7
40925: PPUSH
40926: LD_VAR 0 6
40930: PUSH
40931: LD_INT 1
40933: ARRAY
40934: PPUSH
40935: LD_VAR 0 6
40939: PUSH
40940: LD_INT 2
40942: ARRAY
40943: PPUSH
40944: CALL_OW 111
// wait ( 0 0$10 ) ;
40948: LD_INT 350
40950: PPUSH
40951: CALL_OW 67
// end else
40955: GO 40983
// begin ComMoveXY ( tmp , x , y ) ;
40957: LD_VAR 0 7
40961: PPUSH
40962: LD_VAR 0 4
40966: PPUSH
40967: LD_VAR 0 5
40971: PPUSH
40972: CALL_OW 111
// wait ( 0 0$3 ) ;
40976: LD_INT 105
40978: PPUSH
40979: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40983: LD_VAR 0 7
40987: PPUSH
40988: LD_VAR 0 4
40992: PPUSH
40993: LD_VAR 0 5
40997: PPUSH
40998: CALL_OW 307
41002: IFFALSE 40844
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41004: LD_VAR 0 7
41008: PPUSH
41009: LD_VAR 0 4
41013: PPUSH
41014: LD_VAR 0 5
41018: PPUSH
41019: LD_VAR 0 8
41023: PUSH
41024: LD_VAR 0 3
41028: ARRAY
41029: PPUSH
41030: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41034: LD_INT 35
41036: PPUSH
41037: CALL_OW 67
// until not HasTask ( tmp ) ;
41041: LD_VAR 0 7
41045: PPUSH
41046: CALL_OW 314
41050: NOT
41051: IFFALSE 41034
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41053: LD_ADDR_EXP 125
41057: PUSH
41058: LD_EXP 125
41062: PPUSH
41063: LD_VAR 0 2
41067: PUSH
41068: LD_EXP 125
41072: PUSH
41073: LD_VAR 0 2
41077: ARRAY
41078: PUSH
41079: LD_INT 1
41081: PLUS
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PPUSH
41087: LD_VAR 0 8
41091: PUSH
41092: LD_VAR 0 3
41096: ARRAY
41097: PPUSH
41098: CALL 55617 0 3
41102: ST_TO_ADDR
// end ;
41103: GO 40761
41105: POP
41106: POP
// MC_Reset ( i , 124 ) ;
41107: LD_VAR 0 2
41111: PPUSH
41112: LD_INT 124
41114: PPUSH
41115: CALL 24726 0 2
// end ; end ;
41119: GO 40516
41121: POP
41122: POP
// end ;
41123: LD_VAR 0 1
41127: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41128: LD_INT 0
41130: PPUSH
41131: PPUSH
41132: PPUSH
// if not mc_bases then
41133: LD_EXP 89
41137: NOT
41138: IFFALSE 41142
// exit ;
41140: GO 41748
// for i = 1 to mc_bases do
41142: LD_ADDR_VAR 0 2
41146: PUSH
41147: DOUBLE
41148: LD_INT 1
41150: DEC
41151: ST_TO_ADDR
41152: LD_EXP 89
41156: PUSH
41157: FOR_TO
41158: IFFALSE 41746
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41160: LD_ADDR_VAR 0 3
41164: PUSH
41165: LD_EXP 89
41169: PUSH
41170: LD_VAR 0 2
41174: ARRAY
41175: PPUSH
41176: LD_INT 25
41178: PUSH
41179: LD_INT 4
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PPUSH
41186: CALL_OW 72
41190: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41191: LD_VAR 0 3
41195: NOT
41196: PUSH
41197: LD_EXP 126
41201: PUSH
41202: LD_VAR 0 2
41206: ARRAY
41207: NOT
41208: OR
41209: PUSH
41210: LD_EXP 89
41214: PUSH
41215: LD_VAR 0 2
41219: ARRAY
41220: PPUSH
41221: LD_INT 2
41223: PUSH
41224: LD_INT 30
41226: PUSH
41227: LD_INT 0
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PUSH
41234: LD_INT 30
41236: PUSH
41237: LD_INT 1
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: LIST
41248: PPUSH
41249: CALL_OW 72
41253: NOT
41254: OR
41255: IFFALSE 41305
// begin if mc_deposits_finder [ i ] then
41257: LD_EXP 127
41261: PUSH
41262: LD_VAR 0 2
41266: ARRAY
41267: IFFALSE 41303
// begin MC_Reset ( i , 125 ) ;
41269: LD_VAR 0 2
41273: PPUSH
41274: LD_INT 125
41276: PPUSH
41277: CALL 24726 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41281: LD_ADDR_EXP 127
41285: PUSH
41286: LD_EXP 127
41290: PPUSH
41291: LD_VAR 0 2
41295: PPUSH
41296: EMPTY
41297: PPUSH
41298: CALL_OW 1
41302: ST_TO_ADDR
// end ; continue ;
41303: GO 41157
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41305: LD_EXP 126
41309: PUSH
41310: LD_VAR 0 2
41314: ARRAY
41315: PUSH
41316: LD_INT 1
41318: ARRAY
41319: PUSH
41320: LD_INT 3
41322: ARRAY
41323: PUSH
41324: LD_INT 1
41326: EQUAL
41327: PUSH
41328: LD_INT 20
41330: PPUSH
41331: LD_EXP 115
41335: PUSH
41336: LD_VAR 0 2
41340: ARRAY
41341: PPUSH
41342: CALL_OW 321
41346: PUSH
41347: LD_INT 2
41349: NONEQUAL
41350: AND
41351: IFFALSE 41401
// begin if mc_deposits_finder [ i ] then
41353: LD_EXP 127
41357: PUSH
41358: LD_VAR 0 2
41362: ARRAY
41363: IFFALSE 41399
// begin MC_Reset ( i , 125 ) ;
41365: LD_VAR 0 2
41369: PPUSH
41370: LD_INT 125
41372: PPUSH
41373: CALL 24726 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41377: LD_ADDR_EXP 127
41381: PUSH
41382: LD_EXP 127
41386: PPUSH
41387: LD_VAR 0 2
41391: PPUSH
41392: EMPTY
41393: PPUSH
41394: CALL_OW 1
41398: ST_TO_ADDR
// end ; continue ;
41399: GO 41157
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41401: LD_EXP 126
41405: PUSH
41406: LD_VAR 0 2
41410: ARRAY
41411: PUSH
41412: LD_INT 1
41414: ARRAY
41415: PUSH
41416: LD_INT 1
41418: ARRAY
41419: PPUSH
41420: LD_EXP 126
41424: PUSH
41425: LD_VAR 0 2
41429: ARRAY
41430: PUSH
41431: LD_INT 1
41433: ARRAY
41434: PUSH
41435: LD_INT 2
41437: ARRAY
41438: PPUSH
41439: LD_EXP 115
41443: PUSH
41444: LD_VAR 0 2
41448: ARRAY
41449: PPUSH
41450: CALL_OW 440
41454: IFFALSE 41497
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41456: LD_ADDR_EXP 126
41460: PUSH
41461: LD_EXP 126
41465: PPUSH
41466: LD_VAR 0 2
41470: PPUSH
41471: LD_EXP 126
41475: PUSH
41476: LD_VAR 0 2
41480: ARRAY
41481: PPUSH
41482: LD_INT 1
41484: PPUSH
41485: CALL_OW 3
41489: PPUSH
41490: CALL_OW 1
41494: ST_TO_ADDR
41495: GO 41744
// begin if not mc_deposits_finder [ i ] then
41497: LD_EXP 127
41501: PUSH
41502: LD_VAR 0 2
41506: ARRAY
41507: NOT
41508: IFFALSE 41560
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41510: LD_ADDR_EXP 127
41514: PUSH
41515: LD_EXP 127
41519: PPUSH
41520: LD_VAR 0 2
41524: PPUSH
41525: LD_VAR 0 3
41529: PUSH
41530: LD_INT 1
41532: ARRAY
41533: PUSH
41534: EMPTY
41535: LIST
41536: PPUSH
41537: CALL_OW 1
41541: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41542: LD_VAR 0 3
41546: PUSH
41547: LD_INT 1
41549: ARRAY
41550: PPUSH
41551: LD_INT 125
41553: PPUSH
41554: CALL_OW 109
// end else
41558: GO 41744
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41560: LD_EXP 127
41564: PUSH
41565: LD_VAR 0 2
41569: ARRAY
41570: PUSH
41571: LD_INT 1
41573: ARRAY
41574: PPUSH
41575: CALL_OW 310
41579: IFFALSE 41602
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41581: LD_EXP 127
41585: PUSH
41586: LD_VAR 0 2
41590: ARRAY
41591: PUSH
41592: LD_INT 1
41594: ARRAY
41595: PPUSH
41596: CALL_OW 122
41600: GO 41744
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41602: LD_EXP 127
41606: PUSH
41607: LD_VAR 0 2
41611: ARRAY
41612: PUSH
41613: LD_INT 1
41615: ARRAY
41616: PPUSH
41617: CALL_OW 314
41621: NOT
41622: PUSH
41623: LD_EXP 127
41627: PUSH
41628: LD_VAR 0 2
41632: ARRAY
41633: PUSH
41634: LD_INT 1
41636: ARRAY
41637: PPUSH
41638: LD_EXP 126
41642: PUSH
41643: LD_VAR 0 2
41647: ARRAY
41648: PUSH
41649: LD_INT 1
41651: ARRAY
41652: PUSH
41653: LD_INT 1
41655: ARRAY
41656: PPUSH
41657: LD_EXP 126
41661: PUSH
41662: LD_VAR 0 2
41666: ARRAY
41667: PUSH
41668: LD_INT 1
41670: ARRAY
41671: PUSH
41672: LD_INT 2
41674: ARRAY
41675: PPUSH
41676: CALL_OW 297
41680: PUSH
41681: LD_INT 6
41683: GREATER
41684: AND
41685: IFFALSE 41744
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41687: LD_EXP 127
41691: PUSH
41692: LD_VAR 0 2
41696: ARRAY
41697: PUSH
41698: LD_INT 1
41700: ARRAY
41701: PPUSH
41702: LD_EXP 126
41706: PUSH
41707: LD_VAR 0 2
41711: ARRAY
41712: PUSH
41713: LD_INT 1
41715: ARRAY
41716: PUSH
41717: LD_INT 1
41719: ARRAY
41720: PPUSH
41721: LD_EXP 126
41725: PUSH
41726: LD_VAR 0 2
41730: ARRAY
41731: PUSH
41732: LD_INT 1
41734: ARRAY
41735: PUSH
41736: LD_INT 2
41738: ARRAY
41739: PPUSH
41740: CALL_OW 111
// end ; end ; end ;
41744: GO 41157
41746: POP
41747: POP
// end ;
41748: LD_VAR 0 1
41752: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41753: LD_INT 0
41755: PPUSH
41756: PPUSH
41757: PPUSH
41758: PPUSH
41759: PPUSH
41760: PPUSH
41761: PPUSH
41762: PPUSH
41763: PPUSH
41764: PPUSH
41765: PPUSH
// if not mc_bases then
41766: LD_EXP 89
41770: NOT
41771: IFFALSE 41775
// exit ;
41773: GO 42715
// for i = 1 to mc_bases do
41775: LD_ADDR_VAR 0 2
41779: PUSH
41780: DOUBLE
41781: LD_INT 1
41783: DEC
41784: ST_TO_ADDR
41785: LD_EXP 89
41789: PUSH
41790: FOR_TO
41791: IFFALSE 42713
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41793: LD_EXP 89
41797: PUSH
41798: LD_VAR 0 2
41802: ARRAY
41803: NOT
41804: PUSH
41805: LD_EXP 112
41809: PUSH
41810: LD_VAR 0 2
41814: ARRAY
41815: OR
41816: IFFALSE 41820
// continue ;
41818: GO 41790
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41820: LD_ADDR_VAR 0 7
41824: PUSH
41825: LD_EXP 89
41829: PUSH
41830: LD_VAR 0 2
41834: ARRAY
41835: PUSH
41836: LD_INT 1
41838: ARRAY
41839: PPUSH
41840: CALL_OW 248
41844: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41845: LD_VAR 0 7
41849: PUSH
41850: LD_INT 3
41852: EQUAL
41853: PUSH
41854: LD_EXP 108
41858: PUSH
41859: LD_VAR 0 2
41863: ARRAY
41864: PUSH
41865: LD_EXP 111
41869: PUSH
41870: LD_VAR 0 2
41874: ARRAY
41875: UNION
41876: PPUSH
41877: LD_INT 33
41879: PUSH
41880: LD_INT 2
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PPUSH
41887: CALL_OW 72
41891: NOT
41892: OR
41893: IFFALSE 41897
// continue ;
41895: GO 41790
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41897: LD_ADDR_VAR 0 9
41901: PUSH
41902: LD_EXP 89
41906: PUSH
41907: LD_VAR 0 2
41911: ARRAY
41912: PPUSH
41913: LD_INT 30
41915: PUSH
41916: LD_INT 36
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PPUSH
41923: CALL_OW 72
41927: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41928: LD_ADDR_VAR 0 10
41932: PUSH
41933: LD_EXP 108
41937: PUSH
41938: LD_VAR 0 2
41942: ARRAY
41943: PPUSH
41944: LD_INT 34
41946: PUSH
41947: LD_INT 31
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PPUSH
41954: CALL_OW 72
41958: ST_TO_ADDR
// if not cts and not mcts then
41959: LD_VAR 0 9
41963: NOT
41964: PUSH
41965: LD_VAR 0 10
41969: NOT
41970: AND
41971: IFFALSE 41975
// continue ;
41973: GO 41790
// x := cts ;
41975: LD_ADDR_VAR 0 11
41979: PUSH
41980: LD_VAR 0 9
41984: ST_TO_ADDR
// if not x then
41985: LD_VAR 0 11
41989: NOT
41990: IFFALSE 42002
// x := mcts ;
41992: LD_ADDR_VAR 0 11
41996: PUSH
41997: LD_VAR 0 10
42001: ST_TO_ADDR
// if not x then
42002: LD_VAR 0 11
42006: NOT
42007: IFFALSE 42011
// continue ;
42009: GO 41790
// if mc_remote_driver [ i ] then
42011: LD_EXP 129
42015: PUSH
42016: LD_VAR 0 2
42020: ARRAY
42021: IFFALSE 42408
// for j in mc_remote_driver [ i ] do
42023: LD_ADDR_VAR 0 3
42027: PUSH
42028: LD_EXP 129
42032: PUSH
42033: LD_VAR 0 2
42037: ARRAY
42038: PUSH
42039: FOR_IN
42040: IFFALSE 42406
// begin if GetClass ( j ) <> 3 then
42042: LD_VAR 0 3
42046: PPUSH
42047: CALL_OW 257
42051: PUSH
42052: LD_INT 3
42054: NONEQUAL
42055: IFFALSE 42108
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42057: LD_ADDR_EXP 129
42061: PUSH
42062: LD_EXP 129
42066: PPUSH
42067: LD_VAR 0 2
42071: PPUSH
42072: LD_EXP 129
42076: PUSH
42077: LD_VAR 0 2
42081: ARRAY
42082: PUSH
42083: LD_VAR 0 3
42087: DIFF
42088: PPUSH
42089: CALL_OW 1
42093: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42094: LD_VAR 0 3
42098: PPUSH
42099: LD_INT 0
42101: PPUSH
42102: CALL_OW 109
// continue ;
42106: GO 42039
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42108: LD_EXP 108
42112: PUSH
42113: LD_VAR 0 2
42117: ARRAY
42118: PPUSH
42119: LD_INT 34
42121: PUSH
42122: LD_INT 31
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 58
42131: PUSH
42132: EMPTY
42133: LIST
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PPUSH
42139: CALL_OW 72
42143: PUSH
42144: LD_VAR 0 3
42148: PPUSH
42149: CALL 84266 0 1
42153: NOT
42154: AND
42155: IFFALSE 42226
// begin if IsInUnit ( j ) then
42157: LD_VAR 0 3
42161: PPUSH
42162: CALL_OW 310
42166: IFFALSE 42177
// ComExitBuilding ( j ) ;
42168: LD_VAR 0 3
42172: PPUSH
42173: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42177: LD_VAR 0 3
42181: PPUSH
42182: LD_EXP 108
42186: PUSH
42187: LD_VAR 0 2
42191: ARRAY
42192: PPUSH
42193: LD_INT 34
42195: PUSH
42196: LD_INT 31
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 58
42205: PUSH
42206: EMPTY
42207: LIST
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PPUSH
42213: CALL_OW 72
42217: PUSH
42218: LD_INT 1
42220: ARRAY
42221: PPUSH
42222: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42226: LD_VAR 0 3
42230: PPUSH
42231: CALL_OW 310
42235: NOT
42236: PUSH
42237: LD_VAR 0 3
42241: PPUSH
42242: CALL_OW 310
42246: PPUSH
42247: CALL_OW 266
42251: PUSH
42252: LD_INT 36
42254: NONEQUAL
42255: PUSH
42256: LD_VAR 0 3
42260: PPUSH
42261: CALL 84266 0 1
42265: NOT
42266: AND
42267: OR
42268: IFFALSE 42404
// begin if IsInUnit ( j ) then
42270: LD_VAR 0 3
42274: PPUSH
42275: CALL_OW 310
42279: IFFALSE 42290
// ComExitBuilding ( j ) ;
42281: LD_VAR 0 3
42285: PPUSH
42286: CALL_OW 122
// ct := 0 ;
42290: LD_ADDR_VAR 0 8
42294: PUSH
42295: LD_INT 0
42297: ST_TO_ADDR
// for k in x do
42298: LD_ADDR_VAR 0 4
42302: PUSH
42303: LD_VAR 0 11
42307: PUSH
42308: FOR_IN
42309: IFFALSE 42382
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42311: LD_VAR 0 4
42315: PPUSH
42316: CALL_OW 264
42320: PUSH
42321: LD_INT 31
42323: EQUAL
42324: PUSH
42325: LD_VAR 0 4
42329: PPUSH
42330: CALL_OW 311
42334: NOT
42335: AND
42336: PUSH
42337: LD_VAR 0 4
42341: PPUSH
42342: CALL_OW 266
42346: PUSH
42347: LD_INT 36
42349: EQUAL
42350: PUSH
42351: LD_VAR 0 4
42355: PPUSH
42356: CALL_OW 313
42360: PUSH
42361: LD_INT 3
42363: LESS
42364: AND
42365: OR
42366: IFFALSE 42380
// begin ct := k ;
42368: LD_ADDR_VAR 0 8
42372: PUSH
42373: LD_VAR 0 4
42377: ST_TO_ADDR
// break ;
42378: GO 42382
// end ;
42380: GO 42308
42382: POP
42383: POP
// if ct then
42384: LD_VAR 0 8
42388: IFFALSE 42404
// ComEnterUnit ( j , ct ) ;
42390: LD_VAR 0 3
42394: PPUSH
42395: LD_VAR 0 8
42399: PPUSH
42400: CALL_OW 120
// end ; end ;
42404: GO 42039
42406: POP
42407: POP
// places := 0 ;
42408: LD_ADDR_VAR 0 5
42412: PUSH
42413: LD_INT 0
42415: ST_TO_ADDR
// for j = 1 to x do
42416: LD_ADDR_VAR 0 3
42420: PUSH
42421: DOUBLE
42422: LD_INT 1
42424: DEC
42425: ST_TO_ADDR
42426: LD_VAR 0 11
42430: PUSH
42431: FOR_TO
42432: IFFALSE 42508
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42434: LD_VAR 0 11
42438: PUSH
42439: LD_VAR 0 3
42443: ARRAY
42444: PPUSH
42445: CALL_OW 264
42449: PUSH
42450: LD_INT 31
42452: EQUAL
42453: IFFALSE 42471
// places := places + 1 else
42455: LD_ADDR_VAR 0 5
42459: PUSH
42460: LD_VAR 0 5
42464: PUSH
42465: LD_INT 1
42467: PLUS
42468: ST_TO_ADDR
42469: GO 42506
// if GetBType ( x [ j ] ) = b_control_tower then
42471: LD_VAR 0 11
42475: PUSH
42476: LD_VAR 0 3
42480: ARRAY
42481: PPUSH
42482: CALL_OW 266
42486: PUSH
42487: LD_INT 36
42489: EQUAL
42490: IFFALSE 42506
// places := places + 3 ;
42492: LD_ADDR_VAR 0 5
42496: PUSH
42497: LD_VAR 0 5
42501: PUSH
42502: LD_INT 3
42504: PLUS
42505: ST_TO_ADDR
42506: GO 42431
42508: POP
42509: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42510: LD_VAR 0 5
42514: PUSH
42515: LD_INT 0
42517: EQUAL
42518: PUSH
42519: LD_VAR 0 5
42523: PUSH
42524: LD_EXP 129
42528: PUSH
42529: LD_VAR 0 2
42533: ARRAY
42534: LESSEQUAL
42535: OR
42536: IFFALSE 42540
// continue ;
42538: GO 41790
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42540: LD_ADDR_VAR 0 6
42544: PUSH
42545: LD_EXP 89
42549: PUSH
42550: LD_VAR 0 2
42554: ARRAY
42555: PPUSH
42556: LD_INT 25
42558: PUSH
42559: LD_INT 3
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PPUSH
42566: CALL_OW 72
42570: PUSH
42571: LD_EXP 129
42575: PUSH
42576: LD_VAR 0 2
42580: ARRAY
42581: DIFF
42582: PPUSH
42583: LD_INT 3
42585: PPUSH
42586: CALL 85166 0 2
42590: ST_TO_ADDR
// for j in tmp do
42591: LD_ADDR_VAR 0 3
42595: PUSH
42596: LD_VAR 0 6
42600: PUSH
42601: FOR_IN
42602: IFFALSE 42637
// if GetTag ( j ) > 0 then
42604: LD_VAR 0 3
42608: PPUSH
42609: CALL_OW 110
42613: PUSH
42614: LD_INT 0
42616: GREATER
42617: IFFALSE 42635
// tmp := tmp diff j ;
42619: LD_ADDR_VAR 0 6
42623: PUSH
42624: LD_VAR 0 6
42628: PUSH
42629: LD_VAR 0 3
42633: DIFF
42634: ST_TO_ADDR
42635: GO 42601
42637: POP
42638: POP
// if not tmp then
42639: LD_VAR 0 6
42643: NOT
42644: IFFALSE 42648
// continue ;
42646: GO 41790
// if places then
42648: LD_VAR 0 5
42652: IFFALSE 42711
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42654: LD_ADDR_EXP 129
42658: PUSH
42659: LD_EXP 129
42663: PPUSH
42664: LD_VAR 0 2
42668: PPUSH
42669: LD_EXP 129
42673: PUSH
42674: LD_VAR 0 2
42678: ARRAY
42679: PUSH
42680: LD_VAR 0 6
42684: PUSH
42685: LD_INT 1
42687: ARRAY
42688: UNION
42689: PPUSH
42690: CALL_OW 1
42694: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42695: LD_VAR 0 6
42699: PUSH
42700: LD_INT 1
42702: ARRAY
42703: PPUSH
42704: LD_INT 126
42706: PPUSH
42707: CALL_OW 109
// end ; end ;
42711: GO 41790
42713: POP
42714: POP
// end ;
42715: LD_VAR 0 1
42719: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42720: LD_INT 0
42722: PPUSH
42723: PPUSH
42724: PPUSH
42725: PPUSH
42726: PPUSH
42727: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42728: LD_VAR 0 1
42732: NOT
42733: PUSH
42734: LD_VAR 0 2
42738: NOT
42739: OR
42740: PUSH
42741: LD_VAR 0 3
42745: NOT
42746: OR
42747: PUSH
42748: LD_VAR 0 4
42752: PUSH
42753: LD_INT 1
42755: PUSH
42756: LD_INT 2
42758: PUSH
42759: LD_INT 3
42761: PUSH
42762: LD_INT 4
42764: PUSH
42765: LD_INT 5
42767: PUSH
42768: LD_INT 8
42770: PUSH
42771: LD_INT 9
42773: PUSH
42774: LD_INT 15
42776: PUSH
42777: LD_INT 16
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: LIST
42786: LIST
42787: LIST
42788: LIST
42789: LIST
42790: IN
42791: NOT
42792: OR
42793: IFFALSE 42797
// exit ;
42795: GO 43697
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42797: LD_ADDR_VAR 0 2
42801: PUSH
42802: LD_VAR 0 2
42806: PPUSH
42807: LD_INT 21
42809: PUSH
42810: LD_INT 3
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 24
42819: PUSH
42820: LD_INT 250
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: PPUSH
42831: CALL_OW 72
42835: ST_TO_ADDR
// case class of 1 , 15 :
42836: LD_VAR 0 4
42840: PUSH
42841: LD_INT 1
42843: DOUBLE
42844: EQUAL
42845: IFTRUE 42855
42847: LD_INT 15
42849: DOUBLE
42850: EQUAL
42851: IFTRUE 42855
42853: GO 42940
42855: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42856: LD_ADDR_VAR 0 8
42860: PUSH
42861: LD_VAR 0 2
42865: PPUSH
42866: LD_INT 2
42868: PUSH
42869: LD_INT 30
42871: PUSH
42872: LD_INT 32
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PUSH
42879: LD_INT 30
42881: PUSH
42882: LD_INT 31
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: LIST
42893: PPUSH
42894: CALL_OW 72
42898: PUSH
42899: LD_VAR 0 2
42903: PPUSH
42904: LD_INT 2
42906: PUSH
42907: LD_INT 30
42909: PUSH
42910: LD_INT 4
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 30
42919: PUSH
42920: LD_INT 5
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: LIST
42931: PPUSH
42932: CALL_OW 72
42936: ADD
42937: ST_TO_ADDR
42938: GO 43186
42940: LD_INT 2
42942: DOUBLE
42943: EQUAL
42944: IFTRUE 42954
42946: LD_INT 16
42948: DOUBLE
42949: EQUAL
42950: IFTRUE 42954
42952: GO 43000
42954: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42955: LD_ADDR_VAR 0 8
42959: PUSH
42960: LD_VAR 0 2
42964: PPUSH
42965: LD_INT 2
42967: PUSH
42968: LD_INT 30
42970: PUSH
42971: LD_INT 0
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: LD_INT 30
42980: PUSH
42981: LD_INT 1
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: LIST
42992: PPUSH
42993: CALL_OW 72
42997: ST_TO_ADDR
42998: GO 43186
43000: LD_INT 3
43002: DOUBLE
43003: EQUAL
43004: IFTRUE 43008
43006: GO 43054
43008: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43009: LD_ADDR_VAR 0 8
43013: PUSH
43014: LD_VAR 0 2
43018: PPUSH
43019: LD_INT 2
43021: PUSH
43022: LD_INT 30
43024: PUSH
43025: LD_INT 2
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: PUSH
43032: LD_INT 30
43034: PUSH
43035: LD_INT 3
43037: PUSH
43038: EMPTY
43039: LIST
43040: LIST
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: LIST
43046: PPUSH
43047: CALL_OW 72
43051: ST_TO_ADDR
43052: GO 43186
43054: LD_INT 4
43056: DOUBLE
43057: EQUAL
43058: IFTRUE 43062
43060: GO 43119
43062: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43063: LD_ADDR_VAR 0 8
43067: PUSH
43068: LD_VAR 0 2
43072: PPUSH
43073: LD_INT 2
43075: PUSH
43076: LD_INT 30
43078: PUSH
43079: LD_INT 6
43081: PUSH
43082: EMPTY
43083: LIST
43084: LIST
43085: PUSH
43086: LD_INT 30
43088: PUSH
43089: LD_INT 7
43091: PUSH
43092: EMPTY
43093: LIST
43094: LIST
43095: PUSH
43096: LD_INT 30
43098: PUSH
43099: LD_INT 8
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: LIST
43110: LIST
43111: PPUSH
43112: CALL_OW 72
43116: ST_TO_ADDR
43117: GO 43186
43119: LD_INT 5
43121: DOUBLE
43122: EQUAL
43123: IFTRUE 43139
43125: LD_INT 8
43127: DOUBLE
43128: EQUAL
43129: IFTRUE 43139
43131: LD_INT 9
43133: DOUBLE
43134: EQUAL
43135: IFTRUE 43139
43137: GO 43185
43139: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43140: LD_ADDR_VAR 0 8
43144: PUSH
43145: LD_VAR 0 2
43149: PPUSH
43150: LD_INT 2
43152: PUSH
43153: LD_INT 30
43155: PUSH
43156: LD_INT 4
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: PUSH
43163: LD_INT 30
43165: PUSH
43166: LD_INT 5
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: LIST
43177: PPUSH
43178: CALL_OW 72
43182: ST_TO_ADDR
43183: GO 43186
43185: POP
// if not tmp then
43186: LD_VAR 0 8
43190: NOT
43191: IFFALSE 43195
// exit ;
43193: GO 43697
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43195: LD_VAR 0 4
43199: PUSH
43200: LD_INT 1
43202: PUSH
43203: LD_INT 15
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: IN
43210: PUSH
43211: LD_EXP 98
43215: PUSH
43216: LD_VAR 0 1
43220: ARRAY
43221: AND
43222: IFFALSE 43378
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43224: LD_ADDR_VAR 0 9
43228: PUSH
43229: LD_EXP 98
43233: PUSH
43234: LD_VAR 0 1
43238: ARRAY
43239: PUSH
43240: LD_INT 1
43242: ARRAY
43243: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43244: LD_VAR 0 9
43248: PUSH
43249: LD_EXP 99
43253: PUSH
43254: LD_VAR 0 1
43258: ARRAY
43259: IN
43260: NOT
43261: IFFALSE 43376
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43263: LD_ADDR_EXP 99
43267: PUSH
43268: LD_EXP 99
43272: PPUSH
43273: LD_VAR 0 1
43277: PUSH
43278: LD_EXP 99
43282: PUSH
43283: LD_VAR 0 1
43287: ARRAY
43288: PUSH
43289: LD_INT 1
43291: PLUS
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PPUSH
43297: LD_VAR 0 9
43301: PPUSH
43302: CALL 55617 0 3
43306: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43307: LD_ADDR_EXP 98
43311: PUSH
43312: LD_EXP 98
43316: PPUSH
43317: LD_VAR 0 1
43321: PPUSH
43322: LD_EXP 98
43326: PUSH
43327: LD_VAR 0 1
43331: ARRAY
43332: PUSH
43333: LD_VAR 0 9
43337: DIFF
43338: PPUSH
43339: CALL_OW 1
43343: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43344: LD_VAR 0 3
43348: PPUSH
43349: LD_EXP 99
43353: PUSH
43354: LD_VAR 0 1
43358: ARRAY
43359: PUSH
43360: LD_EXP 99
43364: PUSH
43365: LD_VAR 0 1
43369: ARRAY
43370: ARRAY
43371: PPUSH
43372: CALL_OW 120
// end ; exit ;
43376: GO 43697
// end ; if tmp > 1 then
43378: LD_VAR 0 8
43382: PUSH
43383: LD_INT 1
43385: GREATER
43386: IFFALSE 43490
// for i = 2 to tmp do
43388: LD_ADDR_VAR 0 6
43392: PUSH
43393: DOUBLE
43394: LD_INT 2
43396: DEC
43397: ST_TO_ADDR
43398: LD_VAR 0 8
43402: PUSH
43403: FOR_TO
43404: IFFALSE 43488
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43406: LD_VAR 0 8
43410: PUSH
43411: LD_VAR 0 6
43415: ARRAY
43416: PPUSH
43417: CALL_OW 461
43421: PUSH
43422: LD_INT 6
43424: EQUAL
43425: IFFALSE 43486
// begin x := tmp [ i ] ;
43427: LD_ADDR_VAR 0 9
43431: PUSH
43432: LD_VAR 0 8
43436: PUSH
43437: LD_VAR 0 6
43441: ARRAY
43442: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43443: LD_ADDR_VAR 0 8
43447: PUSH
43448: LD_VAR 0 8
43452: PPUSH
43453: LD_VAR 0 6
43457: PPUSH
43458: CALL_OW 3
43462: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43463: LD_ADDR_VAR 0 8
43467: PUSH
43468: LD_VAR 0 8
43472: PPUSH
43473: LD_INT 1
43475: PPUSH
43476: LD_VAR 0 9
43480: PPUSH
43481: CALL_OW 2
43485: ST_TO_ADDR
// end ;
43486: GO 43403
43488: POP
43489: POP
// for i in tmp do
43490: LD_ADDR_VAR 0 6
43494: PUSH
43495: LD_VAR 0 8
43499: PUSH
43500: FOR_IN
43501: IFFALSE 43570
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43503: LD_VAR 0 6
43507: PPUSH
43508: CALL_OW 313
43512: PUSH
43513: LD_INT 6
43515: LESS
43516: PUSH
43517: LD_VAR 0 6
43521: PPUSH
43522: CALL_OW 266
43526: PUSH
43527: LD_INT 31
43529: PUSH
43530: LD_INT 32
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: IN
43537: NOT
43538: AND
43539: PUSH
43540: LD_VAR 0 6
43544: PPUSH
43545: CALL_OW 313
43549: PUSH
43550: LD_INT 0
43552: EQUAL
43553: OR
43554: IFFALSE 43568
// begin j := i ;
43556: LD_ADDR_VAR 0 7
43560: PUSH
43561: LD_VAR 0 6
43565: ST_TO_ADDR
// break ;
43566: GO 43570
// end ; end ;
43568: GO 43500
43570: POP
43571: POP
// if j then
43572: LD_VAR 0 7
43576: IFFALSE 43594
// ComEnterUnit ( unit , j ) else
43578: LD_VAR 0 3
43582: PPUSH
43583: LD_VAR 0 7
43587: PPUSH
43588: CALL_OW 120
43592: GO 43697
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43594: LD_ADDR_VAR 0 10
43598: PUSH
43599: LD_VAR 0 2
43603: PPUSH
43604: LD_INT 2
43606: PUSH
43607: LD_INT 30
43609: PUSH
43610: LD_INT 0
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 30
43619: PUSH
43620: LD_INT 1
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: LIST
43631: PPUSH
43632: CALL_OW 72
43636: ST_TO_ADDR
// if depot then
43637: LD_VAR 0 10
43641: IFFALSE 43697
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43643: LD_ADDR_VAR 0 10
43647: PUSH
43648: LD_VAR 0 10
43652: PPUSH
43653: LD_VAR 0 3
43657: PPUSH
43658: CALL_OW 74
43662: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43663: LD_VAR 0 3
43667: PPUSH
43668: LD_VAR 0 10
43672: PPUSH
43673: CALL_OW 296
43677: PUSH
43678: LD_INT 10
43680: GREATER
43681: IFFALSE 43697
// ComStandNearbyBuilding ( unit , depot ) ;
43683: LD_VAR 0 3
43687: PPUSH
43688: LD_VAR 0 10
43692: PPUSH
43693: CALL 52231 0 2
// end ; end ; end ;
43697: LD_VAR 0 5
43701: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43702: LD_INT 0
43704: PPUSH
43705: PPUSH
43706: PPUSH
43707: PPUSH
// if not mc_bases then
43708: LD_EXP 89
43712: NOT
43713: IFFALSE 43717
// exit ;
43715: GO 43956
// for i = 1 to mc_bases do
43717: LD_ADDR_VAR 0 2
43721: PUSH
43722: DOUBLE
43723: LD_INT 1
43725: DEC
43726: ST_TO_ADDR
43727: LD_EXP 89
43731: PUSH
43732: FOR_TO
43733: IFFALSE 43954
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43735: LD_ADDR_VAR 0 4
43739: PUSH
43740: LD_EXP 89
43744: PUSH
43745: LD_VAR 0 2
43749: ARRAY
43750: PPUSH
43751: LD_INT 21
43753: PUSH
43754: LD_INT 1
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PPUSH
43761: CALL_OW 72
43765: PUSH
43766: LD_EXP 118
43770: PUSH
43771: LD_VAR 0 2
43775: ARRAY
43776: UNION
43777: ST_TO_ADDR
// if not tmp then
43778: LD_VAR 0 4
43782: NOT
43783: IFFALSE 43787
// continue ;
43785: GO 43732
// for j in tmp do
43787: LD_ADDR_VAR 0 3
43791: PUSH
43792: LD_VAR 0 4
43796: PUSH
43797: FOR_IN
43798: IFFALSE 43950
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43800: LD_VAR 0 3
43804: PPUSH
43805: CALL_OW 110
43809: NOT
43810: PUSH
43811: LD_VAR 0 3
43815: PPUSH
43816: CALL_OW 314
43820: NOT
43821: AND
43822: PUSH
43823: LD_VAR 0 3
43827: PPUSH
43828: CALL_OW 311
43832: NOT
43833: AND
43834: PUSH
43835: LD_VAR 0 3
43839: PPUSH
43840: CALL_OW 310
43844: NOT
43845: AND
43846: PUSH
43847: LD_VAR 0 3
43851: PUSH
43852: LD_EXP 92
43856: PUSH
43857: LD_VAR 0 2
43861: ARRAY
43862: PUSH
43863: LD_INT 1
43865: ARRAY
43866: IN
43867: NOT
43868: AND
43869: PUSH
43870: LD_VAR 0 3
43874: PUSH
43875: LD_EXP 92
43879: PUSH
43880: LD_VAR 0 2
43884: ARRAY
43885: PUSH
43886: LD_INT 2
43888: ARRAY
43889: IN
43890: NOT
43891: AND
43892: PUSH
43893: LD_VAR 0 3
43897: PUSH
43898: LD_EXP 101
43902: PUSH
43903: LD_VAR 0 2
43907: ARRAY
43908: IN
43909: NOT
43910: AND
43911: IFFALSE 43948
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43913: LD_VAR 0 2
43917: PPUSH
43918: LD_EXP 89
43922: PUSH
43923: LD_VAR 0 2
43927: ARRAY
43928: PPUSH
43929: LD_VAR 0 3
43933: PPUSH
43934: LD_VAR 0 3
43938: PPUSH
43939: CALL_OW 257
43943: PPUSH
43944: CALL 42720 0 4
// end ;
43948: GO 43797
43950: POP
43951: POP
// end ;
43952: GO 43732
43954: POP
43955: POP
// end ;
43956: LD_VAR 0 1
43960: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43961: LD_INT 0
43963: PPUSH
43964: PPUSH
43965: PPUSH
43966: PPUSH
43967: PPUSH
43968: PPUSH
// if not mc_bases [ base ] then
43969: LD_EXP 89
43973: PUSH
43974: LD_VAR 0 1
43978: ARRAY
43979: NOT
43980: IFFALSE 43984
// exit ;
43982: GO 44166
// tmp := [ ] ;
43984: LD_ADDR_VAR 0 6
43988: PUSH
43989: EMPTY
43990: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43991: LD_ADDR_VAR 0 7
43995: PUSH
43996: LD_VAR 0 3
44000: PPUSH
44001: LD_INT 0
44003: PPUSH
44004: CALL_OW 517
44008: ST_TO_ADDR
// if not list then
44009: LD_VAR 0 7
44013: NOT
44014: IFFALSE 44018
// exit ;
44016: GO 44166
// for i = 1 to amount do
44018: LD_ADDR_VAR 0 5
44022: PUSH
44023: DOUBLE
44024: LD_INT 1
44026: DEC
44027: ST_TO_ADDR
44028: LD_VAR 0 2
44032: PUSH
44033: FOR_TO
44034: IFFALSE 44114
// begin x := rand ( 1 , list [ 1 ] ) ;
44036: LD_ADDR_VAR 0 8
44040: PUSH
44041: LD_INT 1
44043: PPUSH
44044: LD_VAR 0 7
44048: PUSH
44049: LD_INT 1
44051: ARRAY
44052: PPUSH
44053: CALL_OW 12
44057: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44058: LD_ADDR_VAR 0 6
44062: PUSH
44063: LD_VAR 0 6
44067: PPUSH
44068: LD_VAR 0 5
44072: PPUSH
44073: LD_VAR 0 7
44077: PUSH
44078: LD_INT 1
44080: ARRAY
44081: PUSH
44082: LD_VAR 0 8
44086: ARRAY
44087: PUSH
44088: LD_VAR 0 7
44092: PUSH
44093: LD_INT 2
44095: ARRAY
44096: PUSH
44097: LD_VAR 0 8
44101: ARRAY
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: PPUSH
44107: CALL_OW 1
44111: ST_TO_ADDR
// end ;
44112: GO 44033
44114: POP
44115: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44116: LD_ADDR_EXP 102
44120: PUSH
44121: LD_EXP 102
44125: PPUSH
44126: LD_VAR 0 1
44130: PPUSH
44131: LD_VAR 0 6
44135: PPUSH
44136: CALL_OW 1
44140: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44141: LD_ADDR_EXP 104
44145: PUSH
44146: LD_EXP 104
44150: PPUSH
44151: LD_VAR 0 1
44155: PPUSH
44156: LD_VAR 0 3
44160: PPUSH
44161: CALL_OW 1
44165: ST_TO_ADDR
// end ;
44166: LD_VAR 0 4
44170: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44171: LD_INT 0
44173: PPUSH
// if not mc_bases [ base ] then
44174: LD_EXP 89
44178: PUSH
44179: LD_VAR 0 1
44183: ARRAY
44184: NOT
44185: IFFALSE 44189
// exit ;
44187: GO 44214
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44189: LD_ADDR_EXP 94
44193: PUSH
44194: LD_EXP 94
44198: PPUSH
44199: LD_VAR 0 1
44203: PPUSH
44204: LD_VAR 0 2
44208: PPUSH
44209: CALL_OW 1
44213: ST_TO_ADDR
// end ;
44214: LD_VAR 0 3
44218: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44219: LD_INT 0
44221: PPUSH
// if not mc_bases [ base ] then
44222: LD_EXP 89
44226: PUSH
44227: LD_VAR 0 1
44231: ARRAY
44232: NOT
44233: IFFALSE 44237
// exit ;
44235: GO 44274
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44237: LD_ADDR_EXP 94
44241: PUSH
44242: LD_EXP 94
44246: PPUSH
44247: LD_VAR 0 1
44251: PPUSH
44252: LD_EXP 94
44256: PUSH
44257: LD_VAR 0 1
44261: ARRAY
44262: PUSH
44263: LD_VAR 0 2
44267: UNION
44268: PPUSH
44269: CALL_OW 1
44273: ST_TO_ADDR
// end ;
44274: LD_VAR 0 3
44278: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44279: LD_INT 0
44281: PPUSH
// if not mc_bases [ base ] then
44282: LD_EXP 89
44286: PUSH
44287: LD_VAR 0 1
44291: ARRAY
44292: NOT
44293: IFFALSE 44297
// exit ;
44295: GO 44322
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44297: LD_ADDR_EXP 110
44301: PUSH
44302: LD_EXP 110
44306: PPUSH
44307: LD_VAR 0 1
44311: PPUSH
44312: LD_VAR 0 2
44316: PPUSH
44317: CALL_OW 1
44321: ST_TO_ADDR
// end ;
44322: LD_VAR 0 3
44326: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44327: LD_INT 0
44329: PPUSH
// if not mc_bases [ base ] then
44330: LD_EXP 89
44334: PUSH
44335: LD_VAR 0 1
44339: ARRAY
44340: NOT
44341: IFFALSE 44345
// exit ;
44343: GO 44382
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44345: LD_ADDR_EXP 110
44349: PUSH
44350: LD_EXP 110
44354: PPUSH
44355: LD_VAR 0 1
44359: PPUSH
44360: LD_EXP 110
44364: PUSH
44365: LD_VAR 0 1
44369: ARRAY
44370: PUSH
44371: LD_VAR 0 2
44375: ADD
44376: PPUSH
44377: CALL_OW 1
44381: ST_TO_ADDR
// end ;
44382: LD_VAR 0 3
44386: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44387: LD_INT 0
44389: PPUSH
// if not mc_bases [ base ] then
44390: LD_EXP 89
44394: PUSH
44395: LD_VAR 0 1
44399: ARRAY
44400: NOT
44401: IFFALSE 44405
// exit ;
44403: GO 44459
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44405: LD_ADDR_EXP 111
44409: PUSH
44410: LD_EXP 111
44414: PPUSH
44415: LD_VAR 0 1
44419: PPUSH
44420: LD_VAR 0 2
44424: PPUSH
44425: CALL_OW 1
44429: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44430: LD_ADDR_EXP 100
44434: PUSH
44435: LD_EXP 100
44439: PPUSH
44440: LD_VAR 0 1
44444: PPUSH
44445: LD_VAR 0 2
44449: PUSH
44450: LD_INT 0
44452: PLUS
44453: PPUSH
44454: CALL_OW 1
44458: ST_TO_ADDR
// end ;
44459: LD_VAR 0 3
44463: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44464: LD_INT 0
44466: PPUSH
// if not mc_bases [ base ] then
44467: LD_EXP 89
44471: PUSH
44472: LD_VAR 0 1
44476: ARRAY
44477: NOT
44478: IFFALSE 44482
// exit ;
44480: GO 44507
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44482: LD_ADDR_EXP 100
44486: PUSH
44487: LD_EXP 100
44491: PPUSH
44492: LD_VAR 0 1
44496: PPUSH
44497: LD_VAR 0 2
44501: PPUSH
44502: CALL_OW 1
44506: ST_TO_ADDR
// end ;
44507: LD_VAR 0 3
44511: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44512: LD_INT 0
44514: PPUSH
44515: PPUSH
44516: PPUSH
44517: PPUSH
// if not mc_bases [ base ] then
44518: LD_EXP 89
44522: PUSH
44523: LD_VAR 0 1
44527: ARRAY
44528: NOT
44529: IFFALSE 44533
// exit ;
44531: GO 44598
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44533: LD_ADDR_EXP 109
44537: PUSH
44538: LD_EXP 109
44542: PPUSH
44543: LD_VAR 0 1
44547: PUSH
44548: LD_EXP 109
44552: PUSH
44553: LD_VAR 0 1
44557: ARRAY
44558: PUSH
44559: LD_INT 1
44561: PLUS
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: PPUSH
44567: LD_VAR 0 1
44571: PUSH
44572: LD_VAR 0 2
44576: PUSH
44577: LD_VAR 0 3
44581: PUSH
44582: LD_VAR 0 4
44586: PUSH
44587: EMPTY
44588: LIST
44589: LIST
44590: LIST
44591: LIST
44592: PPUSH
44593: CALL 55617 0 3
44597: ST_TO_ADDR
// end ;
44598: LD_VAR 0 5
44602: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44603: LD_INT 0
44605: PPUSH
// if not mc_bases [ base ] then
44606: LD_EXP 89
44610: PUSH
44611: LD_VAR 0 1
44615: ARRAY
44616: NOT
44617: IFFALSE 44621
// exit ;
44619: GO 44646
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44621: LD_ADDR_EXP 126
44625: PUSH
44626: LD_EXP 126
44630: PPUSH
44631: LD_VAR 0 1
44635: PPUSH
44636: LD_VAR 0 2
44640: PPUSH
44641: CALL_OW 1
44645: ST_TO_ADDR
// end ;
44646: LD_VAR 0 3
44650: RET
// export function MC_GetMinesField ( base ) ; begin
44651: LD_INT 0
44653: PPUSH
// result := mc_mines [ base ] ;
44654: LD_ADDR_VAR 0 2
44658: PUSH
44659: LD_EXP 102
44663: PUSH
44664: LD_VAR 0 1
44668: ARRAY
44669: ST_TO_ADDR
// end ;
44670: LD_VAR 0 2
44674: RET
// export function MC_GetProduceList ( base ) ; begin
44675: LD_INT 0
44677: PPUSH
// result := mc_produce [ base ] ;
44678: LD_ADDR_VAR 0 2
44682: PUSH
44683: LD_EXP 110
44687: PUSH
44688: LD_VAR 0 1
44692: ARRAY
44693: ST_TO_ADDR
// end ;
44694: LD_VAR 0 2
44698: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44699: LD_INT 0
44701: PPUSH
44702: PPUSH
// if not mc_bases then
44703: LD_EXP 89
44707: NOT
44708: IFFALSE 44712
// exit ;
44710: GO 44777
// if mc_bases [ base ] then
44712: LD_EXP 89
44716: PUSH
44717: LD_VAR 0 1
44721: ARRAY
44722: IFFALSE 44777
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44724: LD_ADDR_VAR 0 3
44728: PUSH
44729: LD_EXP 89
44733: PUSH
44734: LD_VAR 0 1
44738: ARRAY
44739: PPUSH
44740: LD_INT 30
44742: PUSH
44743: LD_VAR 0 2
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PPUSH
44752: CALL_OW 72
44756: ST_TO_ADDR
// if result then
44757: LD_VAR 0 3
44761: IFFALSE 44777
// result := result [ 1 ] ;
44763: LD_ADDR_VAR 0 3
44767: PUSH
44768: LD_VAR 0 3
44772: PUSH
44773: LD_INT 1
44775: ARRAY
44776: ST_TO_ADDR
// end ; end ;
44777: LD_VAR 0 3
44781: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44782: LD_INT 0
44784: PPUSH
44785: PPUSH
// if not mc_bases then
44786: LD_EXP 89
44790: NOT
44791: IFFALSE 44795
// exit ;
44793: GO 44840
// if mc_bases [ base ] then
44795: LD_EXP 89
44799: PUSH
44800: LD_VAR 0 1
44804: ARRAY
44805: IFFALSE 44840
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44807: LD_ADDR_VAR 0 3
44811: PUSH
44812: LD_EXP 89
44816: PUSH
44817: LD_VAR 0 1
44821: ARRAY
44822: PPUSH
44823: LD_INT 30
44825: PUSH
44826: LD_VAR 0 2
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PPUSH
44835: CALL_OW 72
44839: ST_TO_ADDR
// end ;
44840: LD_VAR 0 3
44844: RET
// export function MC_SetTame ( base , area ) ; begin
44845: LD_INT 0
44847: PPUSH
// if not mc_bases or not base then
44848: LD_EXP 89
44852: NOT
44853: PUSH
44854: LD_VAR 0 1
44858: NOT
44859: OR
44860: IFFALSE 44864
// exit ;
44862: GO 44889
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44864: LD_ADDR_EXP 117
44868: PUSH
44869: LD_EXP 117
44873: PPUSH
44874: LD_VAR 0 1
44878: PPUSH
44879: LD_VAR 0 2
44883: PPUSH
44884: CALL_OW 1
44888: ST_TO_ADDR
// end ;
44889: LD_VAR 0 3
44893: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44894: LD_INT 0
44896: PPUSH
44897: PPUSH
// if not mc_bases or not base then
44898: LD_EXP 89
44902: NOT
44903: PUSH
44904: LD_VAR 0 1
44908: NOT
44909: OR
44910: IFFALSE 44914
// exit ;
44912: GO 45016
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44914: LD_ADDR_VAR 0 4
44918: PUSH
44919: LD_EXP 89
44923: PUSH
44924: LD_VAR 0 1
44928: ARRAY
44929: PPUSH
44930: LD_INT 30
44932: PUSH
44933: LD_VAR 0 2
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PPUSH
44942: CALL_OW 72
44946: ST_TO_ADDR
// if not tmp then
44947: LD_VAR 0 4
44951: NOT
44952: IFFALSE 44956
// exit ;
44954: GO 45016
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44956: LD_ADDR_EXP 121
44960: PUSH
44961: LD_EXP 121
44965: PPUSH
44966: LD_VAR 0 1
44970: PPUSH
44971: LD_EXP 121
44975: PUSH
44976: LD_VAR 0 1
44980: ARRAY
44981: PPUSH
44982: LD_EXP 121
44986: PUSH
44987: LD_VAR 0 1
44991: ARRAY
44992: PUSH
44993: LD_INT 1
44995: PLUS
44996: PPUSH
44997: LD_VAR 0 4
45001: PUSH
45002: LD_INT 1
45004: ARRAY
45005: PPUSH
45006: CALL_OW 2
45010: PPUSH
45011: CALL_OW 1
45015: ST_TO_ADDR
// end ;
45016: LD_VAR 0 3
45020: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45021: LD_INT 0
45023: PPUSH
45024: PPUSH
// if not mc_bases or not base or not kinds then
45025: LD_EXP 89
45029: NOT
45030: PUSH
45031: LD_VAR 0 1
45035: NOT
45036: OR
45037: PUSH
45038: LD_VAR 0 2
45042: NOT
45043: OR
45044: IFFALSE 45048
// exit ;
45046: GO 45109
// for i in kinds do
45048: LD_ADDR_VAR 0 4
45052: PUSH
45053: LD_VAR 0 2
45057: PUSH
45058: FOR_IN
45059: IFFALSE 45107
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45061: LD_ADDR_EXP 123
45065: PUSH
45066: LD_EXP 123
45070: PPUSH
45071: LD_VAR 0 1
45075: PUSH
45076: LD_EXP 123
45080: PUSH
45081: LD_VAR 0 1
45085: ARRAY
45086: PUSH
45087: LD_INT 1
45089: PLUS
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: PPUSH
45095: LD_VAR 0 4
45099: PPUSH
45100: CALL 55617 0 3
45104: ST_TO_ADDR
45105: GO 45058
45107: POP
45108: POP
// end ;
45109: LD_VAR 0 3
45113: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45114: LD_INT 0
45116: PPUSH
// if not mc_bases or not base or not areas then
45117: LD_EXP 89
45121: NOT
45122: PUSH
45123: LD_VAR 0 1
45127: NOT
45128: OR
45129: PUSH
45130: LD_VAR 0 2
45134: NOT
45135: OR
45136: IFFALSE 45140
// exit ;
45138: GO 45165
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45140: LD_ADDR_EXP 107
45144: PUSH
45145: LD_EXP 107
45149: PPUSH
45150: LD_VAR 0 1
45154: PPUSH
45155: LD_VAR 0 2
45159: PPUSH
45160: CALL_OW 1
45164: ST_TO_ADDR
// end ;
45165: LD_VAR 0 3
45169: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45170: LD_INT 0
45172: PPUSH
// if not mc_bases or not base or not teleports_exit then
45173: LD_EXP 89
45177: NOT
45178: PUSH
45179: LD_VAR 0 1
45183: NOT
45184: OR
45185: PUSH
45186: LD_VAR 0 2
45190: NOT
45191: OR
45192: IFFALSE 45196
// exit ;
45194: GO 45221
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45196: LD_ADDR_EXP 124
45200: PUSH
45201: LD_EXP 124
45205: PPUSH
45206: LD_VAR 0 1
45210: PPUSH
45211: LD_VAR 0 2
45215: PPUSH
45216: CALL_OW 1
45220: ST_TO_ADDR
// end ;
45221: LD_VAR 0 3
45225: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45226: LD_INT 0
45228: PPUSH
45229: PPUSH
45230: PPUSH
// if not mc_bases or not base or not ext_list then
45231: LD_EXP 89
45235: NOT
45236: PUSH
45237: LD_VAR 0 1
45241: NOT
45242: OR
45243: PUSH
45244: LD_VAR 0 5
45248: NOT
45249: OR
45250: IFFALSE 45254
// exit ;
45252: GO 45427
// tmp := GetFacExtXYD ( x , y , d ) ;
45254: LD_ADDR_VAR 0 8
45258: PUSH
45259: LD_VAR 0 2
45263: PPUSH
45264: LD_VAR 0 3
45268: PPUSH
45269: LD_VAR 0 4
45273: PPUSH
45274: CALL 84296 0 3
45278: ST_TO_ADDR
// if not tmp then
45279: LD_VAR 0 8
45283: NOT
45284: IFFALSE 45288
// exit ;
45286: GO 45427
// for i in tmp do
45288: LD_ADDR_VAR 0 7
45292: PUSH
45293: LD_VAR 0 8
45297: PUSH
45298: FOR_IN
45299: IFFALSE 45425
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45301: LD_ADDR_EXP 94
45305: PUSH
45306: LD_EXP 94
45310: PPUSH
45311: LD_VAR 0 1
45315: PPUSH
45316: LD_EXP 94
45320: PUSH
45321: LD_VAR 0 1
45325: ARRAY
45326: PPUSH
45327: LD_EXP 94
45331: PUSH
45332: LD_VAR 0 1
45336: ARRAY
45337: PUSH
45338: LD_INT 1
45340: PLUS
45341: PPUSH
45342: LD_VAR 0 5
45346: PUSH
45347: LD_INT 1
45349: ARRAY
45350: PUSH
45351: LD_VAR 0 7
45355: PUSH
45356: LD_INT 1
45358: ARRAY
45359: PUSH
45360: LD_VAR 0 7
45364: PUSH
45365: LD_INT 2
45367: ARRAY
45368: PUSH
45369: LD_VAR 0 7
45373: PUSH
45374: LD_INT 3
45376: ARRAY
45377: PUSH
45378: EMPTY
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: PPUSH
45384: CALL_OW 2
45388: PPUSH
45389: CALL_OW 1
45393: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45394: LD_ADDR_VAR 0 5
45398: PUSH
45399: LD_VAR 0 5
45403: PPUSH
45404: LD_INT 1
45406: PPUSH
45407: CALL_OW 3
45411: ST_TO_ADDR
// if not ext_list then
45412: LD_VAR 0 5
45416: NOT
45417: IFFALSE 45423
// exit ;
45419: POP
45420: POP
45421: GO 45427
// end ;
45423: GO 45298
45425: POP
45426: POP
// end ;
45427: LD_VAR 0 6
45431: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45432: LD_INT 0
45434: PPUSH
// if not mc_bases or not base or not weapon_list then
45435: LD_EXP 89
45439: NOT
45440: PUSH
45441: LD_VAR 0 1
45445: NOT
45446: OR
45447: PUSH
45448: LD_VAR 0 2
45452: NOT
45453: OR
45454: IFFALSE 45458
// exit ;
45456: GO 45483
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45458: LD_ADDR_EXP 128
45462: PUSH
45463: LD_EXP 128
45467: PPUSH
45468: LD_VAR 0 1
45472: PPUSH
45473: LD_VAR 0 2
45477: PPUSH
45478: CALL_OW 1
45482: ST_TO_ADDR
// end ;
45483: LD_VAR 0 3
45487: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45488: LD_INT 0
45490: PPUSH
// if not mc_bases or not base or not tech_list then
45491: LD_EXP 89
45495: NOT
45496: PUSH
45497: LD_VAR 0 1
45501: NOT
45502: OR
45503: PUSH
45504: LD_VAR 0 2
45508: NOT
45509: OR
45510: IFFALSE 45514
// exit ;
45512: GO 45539
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45514: LD_ADDR_EXP 116
45518: PUSH
45519: LD_EXP 116
45523: PPUSH
45524: LD_VAR 0 1
45528: PPUSH
45529: LD_VAR 0 2
45533: PPUSH
45534: CALL_OW 1
45538: ST_TO_ADDR
// end ;
45539: LD_VAR 0 3
45543: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45544: LD_INT 0
45546: PPUSH
// if not mc_bases or not parking_area or not base then
45547: LD_EXP 89
45551: NOT
45552: PUSH
45553: LD_VAR 0 2
45557: NOT
45558: OR
45559: PUSH
45560: LD_VAR 0 1
45564: NOT
45565: OR
45566: IFFALSE 45570
// exit ;
45568: GO 45595
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45570: LD_ADDR_EXP 113
45574: PUSH
45575: LD_EXP 113
45579: PPUSH
45580: LD_VAR 0 1
45584: PPUSH
45585: LD_VAR 0 2
45589: PPUSH
45590: CALL_OW 1
45594: ST_TO_ADDR
// end ;
45595: LD_VAR 0 3
45599: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45600: LD_INT 0
45602: PPUSH
// if not mc_bases or not base or not scan_area then
45603: LD_EXP 89
45607: NOT
45608: PUSH
45609: LD_VAR 0 1
45613: NOT
45614: OR
45615: PUSH
45616: LD_VAR 0 2
45620: NOT
45621: OR
45622: IFFALSE 45626
// exit ;
45624: GO 45651
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45626: LD_ADDR_EXP 114
45630: PUSH
45631: LD_EXP 114
45635: PPUSH
45636: LD_VAR 0 1
45640: PPUSH
45641: LD_VAR 0 2
45645: PPUSH
45646: CALL_OW 1
45650: ST_TO_ADDR
// end ;
45651: LD_VAR 0 3
45655: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45656: LD_INT 0
45658: PPUSH
45659: PPUSH
// if not mc_bases or not base then
45660: LD_EXP 89
45664: NOT
45665: PUSH
45666: LD_VAR 0 1
45670: NOT
45671: OR
45672: IFFALSE 45676
// exit ;
45674: GO 45740
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45676: LD_ADDR_VAR 0 3
45680: PUSH
45681: LD_INT 1
45683: PUSH
45684: LD_INT 2
45686: PUSH
45687: LD_INT 3
45689: PUSH
45690: LD_INT 4
45692: PUSH
45693: LD_INT 11
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45703: LD_ADDR_EXP 116
45707: PUSH
45708: LD_EXP 116
45712: PPUSH
45713: LD_VAR 0 1
45717: PPUSH
45718: LD_EXP 116
45722: PUSH
45723: LD_VAR 0 1
45727: ARRAY
45728: PUSH
45729: LD_VAR 0 3
45733: DIFF
45734: PPUSH
45735: CALL_OW 1
45739: ST_TO_ADDR
// end ;
45740: LD_VAR 0 2
45744: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45745: LD_INT 0
45747: PPUSH
// result := mc_vehicles [ base ] ;
45748: LD_ADDR_VAR 0 3
45752: PUSH
45753: LD_EXP 108
45757: PUSH
45758: LD_VAR 0 1
45762: ARRAY
45763: ST_TO_ADDR
// if onlyCombat then
45764: LD_VAR 0 2
45768: IFFALSE 45933
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45770: LD_ADDR_VAR 0 3
45774: PUSH
45775: LD_VAR 0 3
45779: PUSH
45780: LD_VAR 0 3
45784: PPUSH
45785: LD_INT 2
45787: PUSH
45788: LD_INT 34
45790: PUSH
45791: LD_INT 12
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: PUSH
45798: LD_INT 34
45800: PUSH
45801: LD_INT 51
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: PUSH
45808: LD_INT 34
45810: PUSH
45811: LD_EXP 73
45815: PUSH
45816: EMPTY
45817: LIST
45818: LIST
45819: PUSH
45820: LD_INT 34
45822: PUSH
45823: LD_INT 32
45825: PUSH
45826: EMPTY
45827: LIST
45828: LIST
45829: PUSH
45830: LD_INT 34
45832: PUSH
45833: LD_INT 13
45835: PUSH
45836: EMPTY
45837: LIST
45838: LIST
45839: PUSH
45840: LD_INT 34
45842: PUSH
45843: LD_INT 52
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PUSH
45850: LD_INT 34
45852: PUSH
45853: LD_INT 14
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: PUSH
45860: LD_INT 34
45862: PUSH
45863: LD_INT 53
45865: PUSH
45866: EMPTY
45867: LIST
45868: LIST
45869: PUSH
45870: LD_INT 34
45872: PUSH
45873: LD_EXP 72
45877: PUSH
45878: EMPTY
45879: LIST
45880: LIST
45881: PUSH
45882: LD_INT 34
45884: PUSH
45885: LD_INT 31
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: PUSH
45892: LD_INT 34
45894: PUSH
45895: LD_INT 48
45897: PUSH
45898: EMPTY
45899: LIST
45900: LIST
45901: PUSH
45902: LD_INT 34
45904: PUSH
45905: LD_INT 8
45907: PUSH
45908: EMPTY
45909: LIST
45910: LIST
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: LIST
45916: LIST
45917: LIST
45918: LIST
45919: LIST
45920: LIST
45921: LIST
45922: LIST
45923: LIST
45924: LIST
45925: LIST
45926: PPUSH
45927: CALL_OW 72
45931: DIFF
45932: ST_TO_ADDR
// end ; end_of_file
45933: LD_VAR 0 3
45937: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45938: LD_INT 0
45940: PPUSH
45941: PPUSH
45942: PPUSH
// if not mc_bases or not skirmish then
45943: LD_EXP 89
45947: NOT
45948: PUSH
45949: LD_EXP 87
45953: NOT
45954: OR
45955: IFFALSE 45959
// exit ;
45957: GO 46124
// for i = 1 to mc_bases do
45959: LD_ADDR_VAR 0 4
45963: PUSH
45964: DOUBLE
45965: LD_INT 1
45967: DEC
45968: ST_TO_ADDR
45969: LD_EXP 89
45973: PUSH
45974: FOR_TO
45975: IFFALSE 46122
// begin if sci in mc_bases [ i ] then
45977: LD_VAR 0 2
45981: PUSH
45982: LD_EXP 89
45986: PUSH
45987: LD_VAR 0 4
45991: ARRAY
45992: IN
45993: IFFALSE 46120
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45995: LD_ADDR_EXP 118
45999: PUSH
46000: LD_EXP 118
46004: PPUSH
46005: LD_VAR 0 4
46009: PUSH
46010: LD_EXP 118
46014: PUSH
46015: LD_VAR 0 4
46019: ARRAY
46020: PUSH
46021: LD_INT 1
46023: PLUS
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PPUSH
46029: LD_VAR 0 1
46033: PPUSH
46034: CALL 55617 0 3
46038: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46039: LD_ADDR_VAR 0 5
46043: PUSH
46044: LD_EXP 89
46048: PUSH
46049: LD_VAR 0 4
46053: ARRAY
46054: PPUSH
46055: LD_INT 2
46057: PUSH
46058: LD_INT 30
46060: PUSH
46061: LD_INT 0
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: PUSH
46068: LD_INT 30
46070: PUSH
46071: LD_INT 1
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: LIST
46082: PPUSH
46083: CALL_OW 72
46087: PPUSH
46088: LD_VAR 0 1
46092: PPUSH
46093: CALL_OW 74
46097: ST_TO_ADDR
// if tmp then
46098: LD_VAR 0 5
46102: IFFALSE 46118
// ComStandNearbyBuilding ( ape , tmp ) ;
46104: LD_VAR 0 1
46108: PPUSH
46109: LD_VAR 0 5
46113: PPUSH
46114: CALL 52231 0 2
// break ;
46118: GO 46122
// end ; end ;
46120: GO 45974
46122: POP
46123: POP
// end ;
46124: LD_VAR 0 3
46128: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46129: LD_INT 0
46131: PPUSH
46132: PPUSH
46133: PPUSH
// if not mc_bases or not skirmish then
46134: LD_EXP 89
46138: NOT
46139: PUSH
46140: LD_EXP 87
46144: NOT
46145: OR
46146: IFFALSE 46150
// exit ;
46148: GO 46239
// for i = 1 to mc_bases do
46150: LD_ADDR_VAR 0 4
46154: PUSH
46155: DOUBLE
46156: LD_INT 1
46158: DEC
46159: ST_TO_ADDR
46160: LD_EXP 89
46164: PUSH
46165: FOR_TO
46166: IFFALSE 46237
// begin if building in mc_busy_turret_list [ i ] then
46168: LD_VAR 0 1
46172: PUSH
46173: LD_EXP 99
46177: PUSH
46178: LD_VAR 0 4
46182: ARRAY
46183: IN
46184: IFFALSE 46235
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46186: LD_ADDR_VAR 0 5
46190: PUSH
46191: LD_EXP 99
46195: PUSH
46196: LD_VAR 0 4
46200: ARRAY
46201: PUSH
46202: LD_VAR 0 1
46206: DIFF
46207: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46208: LD_ADDR_EXP 99
46212: PUSH
46213: LD_EXP 99
46217: PPUSH
46218: LD_VAR 0 4
46222: PPUSH
46223: LD_VAR 0 5
46227: PPUSH
46228: CALL_OW 1
46232: ST_TO_ADDR
// break ;
46233: GO 46237
// end ; end ;
46235: GO 46165
46237: POP
46238: POP
// end ;
46239: LD_VAR 0 3
46243: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46244: LD_INT 0
46246: PPUSH
46247: PPUSH
46248: PPUSH
// if not mc_bases or not skirmish then
46249: LD_EXP 89
46253: NOT
46254: PUSH
46255: LD_EXP 87
46259: NOT
46260: OR
46261: IFFALSE 46265
// exit ;
46263: GO 46464
// for i = 1 to mc_bases do
46265: LD_ADDR_VAR 0 5
46269: PUSH
46270: DOUBLE
46271: LD_INT 1
46273: DEC
46274: ST_TO_ADDR
46275: LD_EXP 89
46279: PUSH
46280: FOR_TO
46281: IFFALSE 46462
// if building in mc_bases [ i ] then
46283: LD_VAR 0 1
46287: PUSH
46288: LD_EXP 89
46292: PUSH
46293: LD_VAR 0 5
46297: ARRAY
46298: IN
46299: IFFALSE 46460
// begin tmp := mc_bases [ i ] diff building ;
46301: LD_ADDR_VAR 0 6
46305: PUSH
46306: LD_EXP 89
46310: PUSH
46311: LD_VAR 0 5
46315: ARRAY
46316: PUSH
46317: LD_VAR 0 1
46321: DIFF
46322: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46323: LD_ADDR_EXP 89
46327: PUSH
46328: LD_EXP 89
46332: PPUSH
46333: LD_VAR 0 5
46337: PPUSH
46338: LD_VAR 0 6
46342: PPUSH
46343: CALL_OW 1
46347: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46348: LD_VAR 0 1
46352: PUSH
46353: LD_EXP 97
46357: PUSH
46358: LD_VAR 0 5
46362: ARRAY
46363: IN
46364: IFFALSE 46403
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46366: LD_ADDR_EXP 97
46370: PUSH
46371: LD_EXP 97
46375: PPUSH
46376: LD_VAR 0 5
46380: PPUSH
46381: LD_EXP 97
46385: PUSH
46386: LD_VAR 0 5
46390: ARRAY
46391: PUSH
46392: LD_VAR 0 1
46396: DIFF
46397: PPUSH
46398: CALL_OW 1
46402: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46403: LD_VAR 0 1
46407: PUSH
46408: LD_EXP 98
46412: PUSH
46413: LD_VAR 0 5
46417: ARRAY
46418: IN
46419: IFFALSE 46458
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46421: LD_ADDR_EXP 98
46425: PUSH
46426: LD_EXP 98
46430: PPUSH
46431: LD_VAR 0 5
46435: PPUSH
46436: LD_EXP 98
46440: PUSH
46441: LD_VAR 0 5
46445: ARRAY
46446: PUSH
46447: LD_VAR 0 1
46451: DIFF
46452: PPUSH
46453: CALL_OW 1
46457: ST_TO_ADDR
// break ;
46458: GO 46462
// end ;
46460: GO 46280
46462: POP
46463: POP
// end ;
46464: LD_VAR 0 4
46468: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46469: LD_INT 0
46471: PPUSH
46472: PPUSH
46473: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46474: LD_EXP 89
46478: NOT
46479: PUSH
46480: LD_EXP 87
46484: NOT
46485: OR
46486: PUSH
46487: LD_VAR 0 3
46491: PUSH
46492: LD_EXP 115
46496: IN
46497: NOT
46498: OR
46499: IFFALSE 46503
// exit ;
46501: GO 46626
// for i = 1 to mc_vehicles do
46503: LD_ADDR_VAR 0 6
46507: PUSH
46508: DOUBLE
46509: LD_INT 1
46511: DEC
46512: ST_TO_ADDR
46513: LD_EXP 108
46517: PUSH
46518: FOR_TO
46519: IFFALSE 46624
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46521: LD_VAR 0 2
46525: PUSH
46526: LD_EXP 108
46530: PUSH
46531: LD_VAR 0 6
46535: ARRAY
46536: IN
46537: PUSH
46538: LD_VAR 0 1
46542: PUSH
46543: LD_EXP 108
46547: PUSH
46548: LD_VAR 0 6
46552: ARRAY
46553: IN
46554: OR
46555: IFFALSE 46622
// begin tmp := mc_vehicles [ i ] diff old ;
46557: LD_ADDR_VAR 0 7
46561: PUSH
46562: LD_EXP 108
46566: PUSH
46567: LD_VAR 0 6
46571: ARRAY
46572: PUSH
46573: LD_VAR 0 2
46577: DIFF
46578: ST_TO_ADDR
// tmp := tmp diff new ;
46579: LD_ADDR_VAR 0 7
46583: PUSH
46584: LD_VAR 0 7
46588: PUSH
46589: LD_VAR 0 1
46593: DIFF
46594: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46595: LD_ADDR_EXP 108
46599: PUSH
46600: LD_EXP 108
46604: PPUSH
46605: LD_VAR 0 6
46609: PPUSH
46610: LD_VAR 0 7
46614: PPUSH
46615: CALL_OW 1
46619: ST_TO_ADDR
// break ;
46620: GO 46624
// end ;
46622: GO 46518
46624: POP
46625: POP
// end ;
46626: LD_VAR 0 5
46630: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46631: LD_INT 0
46633: PPUSH
46634: PPUSH
46635: PPUSH
46636: PPUSH
// if not mc_bases or not skirmish then
46637: LD_EXP 89
46641: NOT
46642: PUSH
46643: LD_EXP 87
46647: NOT
46648: OR
46649: IFFALSE 46653
// exit ;
46651: GO 47030
// side := GetSide ( vehicle ) ;
46653: LD_ADDR_VAR 0 5
46657: PUSH
46658: LD_VAR 0 1
46662: PPUSH
46663: CALL_OW 255
46667: ST_TO_ADDR
// for i = 1 to mc_bases do
46668: LD_ADDR_VAR 0 4
46672: PUSH
46673: DOUBLE
46674: LD_INT 1
46676: DEC
46677: ST_TO_ADDR
46678: LD_EXP 89
46682: PUSH
46683: FOR_TO
46684: IFFALSE 47028
// begin if factory in mc_bases [ i ] then
46686: LD_VAR 0 2
46690: PUSH
46691: LD_EXP 89
46695: PUSH
46696: LD_VAR 0 4
46700: ARRAY
46701: IN
46702: IFFALSE 47026
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46704: LD_EXP 111
46708: PUSH
46709: LD_VAR 0 4
46713: ARRAY
46714: PUSH
46715: LD_EXP 100
46719: PUSH
46720: LD_VAR 0 4
46724: ARRAY
46725: LESS
46726: PUSH
46727: LD_VAR 0 1
46731: PPUSH
46732: CALL_OW 264
46736: PUSH
46737: LD_INT 31
46739: PUSH
46740: LD_INT 32
46742: PUSH
46743: LD_INT 51
46745: PUSH
46746: LD_EXP 73
46750: PUSH
46751: LD_INT 12
46753: PUSH
46754: LD_INT 30
46756: PUSH
46757: LD_EXP 72
46761: PUSH
46762: LD_INT 11
46764: PUSH
46765: LD_INT 53
46767: PUSH
46768: LD_INT 14
46770: PUSH
46771: LD_EXP 76
46775: PUSH
46776: LD_INT 29
46778: PUSH
46779: LD_EXP 74
46783: PUSH
46784: LD_INT 13
46786: PUSH
46787: LD_INT 52
46789: PUSH
46790: LD_INT 48
46792: PUSH
46793: LD_INT 8
46795: PUSH
46796: EMPTY
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: LIST
46808: LIST
46809: LIST
46810: LIST
46811: LIST
46812: LIST
46813: LIST
46814: IN
46815: NOT
46816: AND
46817: IFFALSE 46865
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46819: LD_ADDR_EXP 111
46823: PUSH
46824: LD_EXP 111
46828: PPUSH
46829: LD_VAR 0 4
46833: PUSH
46834: LD_EXP 111
46838: PUSH
46839: LD_VAR 0 4
46843: ARRAY
46844: PUSH
46845: LD_INT 1
46847: PLUS
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PPUSH
46853: LD_VAR 0 1
46857: PPUSH
46858: CALL 55617 0 3
46862: ST_TO_ADDR
46863: GO 46909
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46865: LD_ADDR_EXP 108
46869: PUSH
46870: LD_EXP 108
46874: PPUSH
46875: LD_VAR 0 4
46879: PUSH
46880: LD_EXP 108
46884: PUSH
46885: LD_VAR 0 4
46889: ARRAY
46890: PUSH
46891: LD_INT 1
46893: PLUS
46894: PUSH
46895: EMPTY
46896: LIST
46897: LIST
46898: PPUSH
46899: LD_VAR 0 1
46903: PPUSH
46904: CALL 55617 0 3
46908: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46909: LD_VAR 0 1
46913: PPUSH
46914: CALL_OW 263
46918: PUSH
46919: LD_INT 2
46921: EQUAL
46922: IFFALSE 46942
// begin repeat wait ( 0 0$1 ) ;
46924: LD_INT 35
46926: PPUSH
46927: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46931: LD_VAR 0 1
46935: PPUSH
46936: CALL_OW 312
46940: IFFALSE 46924
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46942: LD_VAR 0 1
46946: PPUSH
46947: LD_EXP 113
46951: PUSH
46952: LD_VAR 0 4
46956: ARRAY
46957: PPUSH
46958: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46962: LD_VAR 0 1
46966: PPUSH
46967: CALL_OW 263
46971: PUSH
46972: LD_INT 1
46974: NONEQUAL
46975: IFFALSE 46979
// break ;
46977: GO 47028
// repeat wait ( 0 0$1 ) ;
46979: LD_INT 35
46981: PPUSH
46982: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46986: LD_VAR 0 1
46990: PPUSH
46991: LD_EXP 113
46995: PUSH
46996: LD_VAR 0 4
47000: ARRAY
47001: PPUSH
47002: CALL_OW 308
47006: IFFALSE 46979
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47008: LD_VAR 0 1
47012: PPUSH
47013: CALL_OW 311
47017: PPUSH
47018: CALL_OW 121
// exit ;
47022: POP
47023: POP
47024: GO 47030
// end ; end ;
47026: GO 46683
47028: POP
47029: POP
// end ;
47030: LD_VAR 0 3
47034: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47035: LD_INT 0
47037: PPUSH
47038: PPUSH
47039: PPUSH
47040: PPUSH
// if not mc_bases or not skirmish then
47041: LD_EXP 89
47045: NOT
47046: PUSH
47047: LD_EXP 87
47051: NOT
47052: OR
47053: IFFALSE 47057
// exit ;
47055: GO 47410
// repeat wait ( 0 0$1 ) ;
47057: LD_INT 35
47059: PPUSH
47060: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47064: LD_VAR 0 2
47068: PPUSH
47069: LD_VAR 0 3
47073: PPUSH
47074: CALL_OW 284
47078: IFFALSE 47057
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47080: LD_VAR 0 2
47084: PPUSH
47085: LD_VAR 0 3
47089: PPUSH
47090: CALL_OW 283
47094: PUSH
47095: LD_INT 4
47097: EQUAL
47098: IFFALSE 47102
// exit ;
47100: GO 47410
// for i = 1 to mc_bases do
47102: LD_ADDR_VAR 0 7
47106: PUSH
47107: DOUBLE
47108: LD_INT 1
47110: DEC
47111: ST_TO_ADDR
47112: LD_EXP 89
47116: PUSH
47117: FOR_TO
47118: IFFALSE 47408
// begin if mc_crates_area [ i ] then
47120: LD_EXP 107
47124: PUSH
47125: LD_VAR 0 7
47129: ARRAY
47130: IFFALSE 47241
// for j in mc_crates_area [ i ] do
47132: LD_ADDR_VAR 0 8
47136: PUSH
47137: LD_EXP 107
47141: PUSH
47142: LD_VAR 0 7
47146: ARRAY
47147: PUSH
47148: FOR_IN
47149: IFFALSE 47239
// if InArea ( x , y , j ) then
47151: LD_VAR 0 2
47155: PPUSH
47156: LD_VAR 0 3
47160: PPUSH
47161: LD_VAR 0 8
47165: PPUSH
47166: CALL_OW 309
47170: IFFALSE 47237
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47172: LD_ADDR_EXP 105
47176: PUSH
47177: LD_EXP 105
47181: PPUSH
47182: LD_VAR 0 7
47186: PUSH
47187: LD_EXP 105
47191: PUSH
47192: LD_VAR 0 7
47196: ARRAY
47197: PUSH
47198: LD_INT 1
47200: PLUS
47201: PUSH
47202: EMPTY
47203: LIST
47204: LIST
47205: PPUSH
47206: LD_VAR 0 4
47210: PUSH
47211: LD_VAR 0 2
47215: PUSH
47216: LD_VAR 0 3
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: LIST
47225: PPUSH
47226: CALL 55617 0 3
47230: ST_TO_ADDR
// exit ;
47231: POP
47232: POP
47233: POP
47234: POP
47235: GO 47410
// end ;
47237: GO 47148
47239: POP
47240: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47241: LD_ADDR_VAR 0 9
47245: PUSH
47246: LD_EXP 89
47250: PUSH
47251: LD_VAR 0 7
47255: ARRAY
47256: PPUSH
47257: LD_INT 2
47259: PUSH
47260: LD_INT 30
47262: PUSH
47263: LD_INT 0
47265: PUSH
47266: EMPTY
47267: LIST
47268: LIST
47269: PUSH
47270: LD_INT 30
47272: PUSH
47273: LD_INT 1
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: PUSH
47280: EMPTY
47281: LIST
47282: LIST
47283: LIST
47284: PPUSH
47285: CALL_OW 72
47289: ST_TO_ADDR
// if not depot then
47290: LD_VAR 0 9
47294: NOT
47295: IFFALSE 47299
// continue ;
47297: GO 47117
// for j in depot do
47299: LD_ADDR_VAR 0 8
47303: PUSH
47304: LD_VAR 0 9
47308: PUSH
47309: FOR_IN
47310: IFFALSE 47404
// if GetDistUnitXY ( j , x , y ) < 30 then
47312: LD_VAR 0 8
47316: PPUSH
47317: LD_VAR 0 2
47321: PPUSH
47322: LD_VAR 0 3
47326: PPUSH
47327: CALL_OW 297
47331: PUSH
47332: LD_INT 30
47334: LESS
47335: IFFALSE 47402
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47337: LD_ADDR_EXP 105
47341: PUSH
47342: LD_EXP 105
47346: PPUSH
47347: LD_VAR 0 7
47351: PUSH
47352: LD_EXP 105
47356: PUSH
47357: LD_VAR 0 7
47361: ARRAY
47362: PUSH
47363: LD_INT 1
47365: PLUS
47366: PUSH
47367: EMPTY
47368: LIST
47369: LIST
47370: PPUSH
47371: LD_VAR 0 4
47375: PUSH
47376: LD_VAR 0 2
47380: PUSH
47381: LD_VAR 0 3
47385: PUSH
47386: EMPTY
47387: LIST
47388: LIST
47389: LIST
47390: PPUSH
47391: CALL 55617 0 3
47395: ST_TO_ADDR
// exit ;
47396: POP
47397: POP
47398: POP
47399: POP
47400: GO 47410
// end ;
47402: GO 47309
47404: POP
47405: POP
// end ;
47406: GO 47117
47408: POP
47409: POP
// end ;
47410: LD_VAR 0 6
47414: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47415: LD_INT 0
47417: PPUSH
47418: PPUSH
47419: PPUSH
47420: PPUSH
// if not mc_bases or not skirmish then
47421: LD_EXP 89
47425: NOT
47426: PUSH
47427: LD_EXP 87
47431: NOT
47432: OR
47433: IFFALSE 47437
// exit ;
47435: GO 47714
// side := GetSide ( lab ) ;
47437: LD_ADDR_VAR 0 4
47441: PUSH
47442: LD_VAR 0 2
47446: PPUSH
47447: CALL_OW 255
47451: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47452: LD_VAR 0 4
47456: PUSH
47457: LD_EXP 115
47461: IN
47462: NOT
47463: PUSH
47464: LD_EXP 116
47468: NOT
47469: OR
47470: PUSH
47471: LD_EXP 89
47475: NOT
47476: OR
47477: IFFALSE 47481
// exit ;
47479: GO 47714
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47481: LD_ADDR_EXP 116
47485: PUSH
47486: LD_EXP 116
47490: PPUSH
47491: LD_VAR 0 4
47495: PPUSH
47496: LD_EXP 116
47500: PUSH
47501: LD_VAR 0 4
47505: ARRAY
47506: PUSH
47507: LD_VAR 0 1
47511: DIFF
47512: PPUSH
47513: CALL_OW 1
47517: ST_TO_ADDR
// for i = 1 to mc_bases do
47518: LD_ADDR_VAR 0 5
47522: PUSH
47523: DOUBLE
47524: LD_INT 1
47526: DEC
47527: ST_TO_ADDR
47528: LD_EXP 89
47532: PUSH
47533: FOR_TO
47534: IFFALSE 47712
// begin if lab in mc_bases [ i ] then
47536: LD_VAR 0 2
47540: PUSH
47541: LD_EXP 89
47545: PUSH
47546: LD_VAR 0 5
47550: ARRAY
47551: IN
47552: IFFALSE 47710
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47554: LD_VAR 0 1
47558: PUSH
47559: LD_INT 11
47561: PUSH
47562: LD_INT 4
47564: PUSH
47565: LD_INT 3
47567: PUSH
47568: LD_INT 2
47570: PUSH
47571: EMPTY
47572: LIST
47573: LIST
47574: LIST
47575: LIST
47576: IN
47577: PUSH
47578: LD_EXP 119
47582: PUSH
47583: LD_VAR 0 5
47587: ARRAY
47588: AND
47589: IFFALSE 47710
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47591: LD_ADDR_VAR 0 6
47595: PUSH
47596: LD_EXP 119
47600: PUSH
47601: LD_VAR 0 5
47605: ARRAY
47606: PUSH
47607: LD_INT 1
47609: ARRAY
47610: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47611: LD_ADDR_EXP 119
47615: PUSH
47616: LD_EXP 119
47620: PPUSH
47621: LD_VAR 0 5
47625: PPUSH
47626: EMPTY
47627: PPUSH
47628: CALL_OW 1
47632: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47633: LD_VAR 0 6
47637: PPUSH
47638: LD_INT 0
47640: PPUSH
47641: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47645: LD_VAR 0 6
47649: PPUSH
47650: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47654: LD_ADDR_EXP 118
47658: PUSH
47659: LD_EXP 118
47663: PPUSH
47664: LD_VAR 0 5
47668: PPUSH
47669: LD_EXP 118
47673: PUSH
47674: LD_VAR 0 5
47678: ARRAY
47679: PPUSH
47680: LD_INT 1
47682: PPUSH
47683: LD_VAR 0 6
47687: PPUSH
47688: CALL_OW 2
47692: PPUSH
47693: CALL_OW 1
47697: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47698: LD_VAR 0 5
47702: PPUSH
47703: LD_INT 112
47705: PPUSH
47706: CALL 24726 0 2
// end ; end ; end ;
47710: GO 47533
47712: POP
47713: POP
// end ;
47714: LD_VAR 0 3
47718: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47719: LD_INT 0
47721: PPUSH
47722: PPUSH
47723: PPUSH
47724: PPUSH
47725: PPUSH
47726: PPUSH
47727: PPUSH
47728: PPUSH
// if not mc_bases or not skirmish then
47729: LD_EXP 89
47733: NOT
47734: PUSH
47735: LD_EXP 87
47739: NOT
47740: OR
47741: IFFALSE 47745
// exit ;
47743: GO 49116
// for i = 1 to mc_bases do
47745: LD_ADDR_VAR 0 3
47749: PUSH
47750: DOUBLE
47751: LD_INT 1
47753: DEC
47754: ST_TO_ADDR
47755: LD_EXP 89
47759: PUSH
47760: FOR_TO
47761: IFFALSE 49114
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47763: LD_VAR 0 1
47767: PUSH
47768: LD_EXP 89
47772: PUSH
47773: LD_VAR 0 3
47777: ARRAY
47778: IN
47779: PUSH
47780: LD_VAR 0 1
47784: PUSH
47785: LD_EXP 96
47789: PUSH
47790: LD_VAR 0 3
47794: ARRAY
47795: IN
47796: OR
47797: PUSH
47798: LD_VAR 0 1
47802: PUSH
47803: LD_EXP 111
47807: PUSH
47808: LD_VAR 0 3
47812: ARRAY
47813: IN
47814: OR
47815: PUSH
47816: LD_VAR 0 1
47820: PUSH
47821: LD_EXP 108
47825: PUSH
47826: LD_VAR 0 3
47830: ARRAY
47831: IN
47832: OR
47833: PUSH
47834: LD_VAR 0 1
47838: PUSH
47839: LD_EXP 118
47843: PUSH
47844: LD_VAR 0 3
47848: ARRAY
47849: IN
47850: OR
47851: PUSH
47852: LD_VAR 0 1
47856: PUSH
47857: LD_EXP 119
47861: PUSH
47862: LD_VAR 0 3
47866: ARRAY
47867: IN
47868: OR
47869: IFFALSE 49112
// begin if un in mc_ape [ i ] then
47871: LD_VAR 0 1
47875: PUSH
47876: LD_EXP 118
47880: PUSH
47881: LD_VAR 0 3
47885: ARRAY
47886: IN
47887: IFFALSE 47926
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47889: LD_ADDR_EXP 118
47893: PUSH
47894: LD_EXP 118
47898: PPUSH
47899: LD_VAR 0 3
47903: PPUSH
47904: LD_EXP 118
47908: PUSH
47909: LD_VAR 0 3
47913: ARRAY
47914: PUSH
47915: LD_VAR 0 1
47919: DIFF
47920: PPUSH
47921: CALL_OW 1
47925: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47926: LD_VAR 0 1
47930: PUSH
47931: LD_EXP 119
47935: PUSH
47936: LD_VAR 0 3
47940: ARRAY
47941: IN
47942: IFFALSE 47966
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47944: LD_ADDR_EXP 119
47948: PUSH
47949: LD_EXP 119
47953: PPUSH
47954: LD_VAR 0 3
47958: PPUSH
47959: EMPTY
47960: PPUSH
47961: CALL_OW 1
47965: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47966: LD_VAR 0 1
47970: PPUSH
47971: CALL_OW 247
47975: PUSH
47976: LD_INT 2
47978: EQUAL
47979: PUSH
47980: LD_VAR 0 1
47984: PPUSH
47985: CALL_OW 110
47989: PUSH
47990: LD_INT 20
47992: EQUAL
47993: PUSH
47994: LD_VAR 0 1
47998: PUSH
47999: LD_EXP 111
48003: PUSH
48004: LD_VAR 0 3
48008: ARRAY
48009: IN
48010: OR
48011: PUSH
48012: LD_VAR 0 1
48016: PPUSH
48017: CALL_OW 264
48021: PUSH
48022: LD_INT 12
48024: PUSH
48025: LD_INT 51
48027: PUSH
48028: LD_EXP 73
48032: PUSH
48033: LD_INT 32
48035: PUSH
48036: LD_INT 13
48038: PUSH
48039: LD_INT 52
48041: PUSH
48042: LD_INT 31
48044: PUSH
48045: EMPTY
48046: LIST
48047: LIST
48048: LIST
48049: LIST
48050: LIST
48051: LIST
48052: LIST
48053: IN
48054: OR
48055: AND
48056: IFFALSE 48364
// begin if un in mc_defender [ i ] then
48058: LD_VAR 0 1
48062: PUSH
48063: LD_EXP 111
48067: PUSH
48068: LD_VAR 0 3
48072: ARRAY
48073: IN
48074: IFFALSE 48113
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48076: LD_ADDR_EXP 111
48080: PUSH
48081: LD_EXP 111
48085: PPUSH
48086: LD_VAR 0 3
48090: PPUSH
48091: LD_EXP 111
48095: PUSH
48096: LD_VAR 0 3
48100: ARRAY
48101: PUSH
48102: LD_VAR 0 1
48106: DIFF
48107: PPUSH
48108: CALL_OW 1
48112: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48113: LD_ADDR_VAR 0 8
48117: PUSH
48118: LD_VAR 0 3
48122: PPUSH
48123: LD_INT 3
48125: PPUSH
48126: CALL 44782 0 2
48130: ST_TO_ADDR
// if fac then
48131: LD_VAR 0 8
48135: IFFALSE 48364
// begin for j in fac do
48137: LD_ADDR_VAR 0 4
48141: PUSH
48142: LD_VAR 0 8
48146: PUSH
48147: FOR_IN
48148: IFFALSE 48362
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48150: LD_ADDR_VAR 0 9
48154: PUSH
48155: LD_VAR 0 8
48159: PPUSH
48160: LD_VAR 0 1
48164: PPUSH
48165: CALL_OW 265
48169: PPUSH
48170: LD_VAR 0 1
48174: PPUSH
48175: CALL_OW 262
48179: PPUSH
48180: LD_VAR 0 1
48184: PPUSH
48185: CALL_OW 263
48189: PPUSH
48190: LD_VAR 0 1
48194: PPUSH
48195: CALL_OW 264
48199: PPUSH
48200: CALL 53149 0 5
48204: ST_TO_ADDR
// if components then
48205: LD_VAR 0 9
48209: IFFALSE 48360
// begin if GetWeapon ( un ) = ar_control_tower then
48211: LD_VAR 0 1
48215: PPUSH
48216: CALL_OW 264
48220: PUSH
48221: LD_INT 31
48223: EQUAL
48224: IFFALSE 48341
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48226: LD_VAR 0 1
48230: PPUSH
48231: CALL_OW 311
48235: PPUSH
48236: LD_INT 0
48238: PPUSH
48239: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48243: LD_ADDR_EXP 129
48247: PUSH
48248: LD_EXP 129
48252: PPUSH
48253: LD_VAR 0 3
48257: PPUSH
48258: LD_EXP 129
48262: PUSH
48263: LD_VAR 0 3
48267: ARRAY
48268: PUSH
48269: LD_VAR 0 1
48273: PPUSH
48274: CALL_OW 311
48278: DIFF
48279: PPUSH
48280: CALL_OW 1
48284: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48285: LD_ADDR_VAR 0 7
48289: PUSH
48290: LD_EXP 110
48294: PUSH
48295: LD_VAR 0 3
48299: ARRAY
48300: PPUSH
48301: LD_INT 1
48303: PPUSH
48304: LD_VAR 0 9
48308: PPUSH
48309: CALL_OW 2
48313: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48314: LD_ADDR_EXP 110
48318: PUSH
48319: LD_EXP 110
48323: PPUSH
48324: LD_VAR 0 3
48328: PPUSH
48329: LD_VAR 0 7
48333: PPUSH
48334: CALL_OW 1
48338: ST_TO_ADDR
// end else
48339: GO 48358
// MC_InsertProduceList ( i , [ components ] ) ;
48341: LD_VAR 0 3
48345: PPUSH
48346: LD_VAR 0 9
48350: PUSH
48351: EMPTY
48352: LIST
48353: PPUSH
48354: CALL 44327 0 2
// break ;
48358: GO 48362
// end ; end ;
48360: GO 48147
48362: POP
48363: POP
// end ; end ; if GetType ( un ) = unit_building then
48364: LD_VAR 0 1
48368: PPUSH
48369: CALL_OW 247
48373: PUSH
48374: LD_INT 3
48376: EQUAL
48377: IFFALSE 48780
// begin btype := GetBType ( un ) ;
48379: LD_ADDR_VAR 0 5
48383: PUSH
48384: LD_VAR 0 1
48388: PPUSH
48389: CALL_OW 266
48393: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48394: LD_VAR 0 5
48398: PUSH
48399: LD_INT 29
48401: PUSH
48402: LD_INT 30
48404: PUSH
48405: EMPTY
48406: LIST
48407: LIST
48408: IN
48409: IFFALSE 48482
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48411: LD_VAR 0 1
48415: PPUSH
48416: CALL_OW 250
48420: PPUSH
48421: LD_VAR 0 1
48425: PPUSH
48426: CALL_OW 251
48430: PPUSH
48431: LD_VAR 0 1
48435: PPUSH
48436: CALL_OW 255
48440: PPUSH
48441: CALL_OW 440
48445: NOT
48446: IFFALSE 48482
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48448: LD_VAR 0 1
48452: PPUSH
48453: CALL_OW 250
48457: PPUSH
48458: LD_VAR 0 1
48462: PPUSH
48463: CALL_OW 251
48467: PPUSH
48468: LD_VAR 0 1
48472: PPUSH
48473: CALL_OW 255
48477: PPUSH
48478: CALL_OW 441
// end ; if btype = b_warehouse then
48482: LD_VAR 0 5
48486: PUSH
48487: LD_INT 1
48489: EQUAL
48490: IFFALSE 48508
// begin btype := b_depot ;
48492: LD_ADDR_VAR 0 5
48496: PUSH
48497: LD_INT 0
48499: ST_TO_ADDR
// pos := 1 ;
48500: LD_ADDR_VAR 0 6
48504: PUSH
48505: LD_INT 1
48507: ST_TO_ADDR
// end ; if btype = b_factory then
48508: LD_VAR 0 5
48512: PUSH
48513: LD_INT 3
48515: EQUAL
48516: IFFALSE 48534
// begin btype := b_workshop ;
48518: LD_ADDR_VAR 0 5
48522: PUSH
48523: LD_INT 2
48525: ST_TO_ADDR
// pos := 1 ;
48526: LD_ADDR_VAR 0 6
48530: PUSH
48531: LD_INT 1
48533: ST_TO_ADDR
// end ; if btype = b_barracks then
48534: LD_VAR 0 5
48538: PUSH
48539: LD_INT 5
48541: EQUAL
48542: IFFALSE 48552
// btype := b_armoury ;
48544: LD_ADDR_VAR 0 5
48548: PUSH
48549: LD_INT 4
48551: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48552: LD_VAR 0 5
48556: PUSH
48557: LD_INT 7
48559: PUSH
48560: LD_INT 8
48562: PUSH
48563: EMPTY
48564: LIST
48565: LIST
48566: IN
48567: IFFALSE 48577
// btype := b_lab ;
48569: LD_ADDR_VAR 0 5
48573: PUSH
48574: LD_INT 6
48576: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48577: LD_ADDR_EXP 94
48581: PUSH
48582: LD_EXP 94
48586: PPUSH
48587: LD_VAR 0 3
48591: PUSH
48592: LD_EXP 94
48596: PUSH
48597: LD_VAR 0 3
48601: ARRAY
48602: PUSH
48603: LD_INT 1
48605: PLUS
48606: PUSH
48607: EMPTY
48608: LIST
48609: LIST
48610: PPUSH
48611: LD_VAR 0 5
48615: PUSH
48616: LD_VAR 0 1
48620: PPUSH
48621: CALL_OW 250
48625: PUSH
48626: LD_VAR 0 1
48630: PPUSH
48631: CALL_OW 251
48635: PUSH
48636: LD_VAR 0 1
48640: PPUSH
48641: CALL_OW 254
48645: PUSH
48646: EMPTY
48647: LIST
48648: LIST
48649: LIST
48650: LIST
48651: PPUSH
48652: CALL 55617 0 3
48656: ST_TO_ADDR
// if pos = 1 then
48657: LD_VAR 0 6
48661: PUSH
48662: LD_INT 1
48664: EQUAL
48665: IFFALSE 48780
// begin tmp := mc_build_list [ i ] ;
48667: LD_ADDR_VAR 0 7
48671: PUSH
48672: LD_EXP 94
48676: PUSH
48677: LD_VAR 0 3
48681: ARRAY
48682: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48683: LD_VAR 0 7
48687: PPUSH
48688: LD_INT 2
48690: PUSH
48691: LD_INT 30
48693: PUSH
48694: LD_INT 0
48696: PUSH
48697: EMPTY
48698: LIST
48699: LIST
48700: PUSH
48701: LD_INT 30
48703: PUSH
48704: LD_INT 1
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: LIST
48715: PPUSH
48716: CALL_OW 72
48720: IFFALSE 48730
// pos := 2 ;
48722: LD_ADDR_VAR 0 6
48726: PUSH
48727: LD_INT 2
48729: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48730: LD_ADDR_VAR 0 7
48734: PUSH
48735: LD_VAR 0 7
48739: PPUSH
48740: LD_VAR 0 6
48744: PPUSH
48745: LD_VAR 0 7
48749: PPUSH
48750: CALL 55943 0 3
48754: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48755: LD_ADDR_EXP 94
48759: PUSH
48760: LD_EXP 94
48764: PPUSH
48765: LD_VAR 0 3
48769: PPUSH
48770: LD_VAR 0 7
48774: PPUSH
48775: CALL_OW 1
48779: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48780: LD_VAR 0 1
48784: PUSH
48785: LD_EXP 89
48789: PUSH
48790: LD_VAR 0 3
48794: ARRAY
48795: IN
48796: IFFALSE 48835
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48798: LD_ADDR_EXP 89
48802: PUSH
48803: LD_EXP 89
48807: PPUSH
48808: LD_VAR 0 3
48812: PPUSH
48813: LD_EXP 89
48817: PUSH
48818: LD_VAR 0 3
48822: ARRAY
48823: PUSH
48824: LD_VAR 0 1
48828: DIFF
48829: PPUSH
48830: CALL_OW 1
48834: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48835: LD_VAR 0 1
48839: PUSH
48840: LD_EXP 96
48844: PUSH
48845: LD_VAR 0 3
48849: ARRAY
48850: IN
48851: IFFALSE 48890
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48853: LD_ADDR_EXP 96
48857: PUSH
48858: LD_EXP 96
48862: PPUSH
48863: LD_VAR 0 3
48867: PPUSH
48868: LD_EXP 96
48872: PUSH
48873: LD_VAR 0 3
48877: ARRAY
48878: PUSH
48879: LD_VAR 0 1
48883: DIFF
48884: PPUSH
48885: CALL_OW 1
48889: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48890: LD_VAR 0 1
48894: PUSH
48895: LD_EXP 108
48899: PUSH
48900: LD_VAR 0 3
48904: ARRAY
48905: IN
48906: IFFALSE 48945
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48908: LD_ADDR_EXP 108
48912: PUSH
48913: LD_EXP 108
48917: PPUSH
48918: LD_VAR 0 3
48922: PPUSH
48923: LD_EXP 108
48927: PUSH
48928: LD_VAR 0 3
48932: ARRAY
48933: PUSH
48934: LD_VAR 0 1
48938: DIFF
48939: PPUSH
48940: CALL_OW 1
48944: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48945: LD_VAR 0 1
48949: PUSH
48950: LD_EXP 111
48954: PUSH
48955: LD_VAR 0 3
48959: ARRAY
48960: IN
48961: IFFALSE 49000
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48963: LD_ADDR_EXP 111
48967: PUSH
48968: LD_EXP 111
48972: PPUSH
48973: LD_VAR 0 3
48977: PPUSH
48978: LD_EXP 111
48982: PUSH
48983: LD_VAR 0 3
48987: ARRAY
48988: PUSH
48989: LD_VAR 0 1
48993: DIFF
48994: PPUSH
48995: CALL_OW 1
48999: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49000: LD_VAR 0 1
49004: PUSH
49005: LD_EXP 98
49009: PUSH
49010: LD_VAR 0 3
49014: ARRAY
49015: IN
49016: IFFALSE 49055
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49018: LD_ADDR_EXP 98
49022: PUSH
49023: LD_EXP 98
49027: PPUSH
49028: LD_VAR 0 3
49032: PPUSH
49033: LD_EXP 98
49037: PUSH
49038: LD_VAR 0 3
49042: ARRAY
49043: PUSH
49044: LD_VAR 0 1
49048: DIFF
49049: PPUSH
49050: CALL_OW 1
49054: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49055: LD_VAR 0 1
49059: PUSH
49060: LD_EXP 97
49064: PUSH
49065: LD_VAR 0 3
49069: ARRAY
49070: IN
49071: IFFALSE 49110
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49073: LD_ADDR_EXP 97
49077: PUSH
49078: LD_EXP 97
49082: PPUSH
49083: LD_VAR 0 3
49087: PPUSH
49088: LD_EXP 97
49092: PUSH
49093: LD_VAR 0 3
49097: ARRAY
49098: PUSH
49099: LD_VAR 0 1
49103: DIFF
49104: PPUSH
49105: CALL_OW 1
49109: ST_TO_ADDR
// end ; break ;
49110: GO 49114
// end ;
49112: GO 47760
49114: POP
49115: POP
// end ;
49116: LD_VAR 0 2
49120: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49121: LD_INT 0
49123: PPUSH
49124: PPUSH
49125: PPUSH
// if not mc_bases or not skirmish then
49126: LD_EXP 89
49130: NOT
49131: PUSH
49132: LD_EXP 87
49136: NOT
49137: OR
49138: IFFALSE 49142
// exit ;
49140: GO 49357
// for i = 1 to mc_bases do
49142: LD_ADDR_VAR 0 3
49146: PUSH
49147: DOUBLE
49148: LD_INT 1
49150: DEC
49151: ST_TO_ADDR
49152: LD_EXP 89
49156: PUSH
49157: FOR_TO
49158: IFFALSE 49355
// begin if building in mc_construct_list [ i ] then
49160: LD_VAR 0 1
49164: PUSH
49165: LD_EXP 96
49169: PUSH
49170: LD_VAR 0 3
49174: ARRAY
49175: IN
49176: IFFALSE 49353
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49178: LD_ADDR_EXP 96
49182: PUSH
49183: LD_EXP 96
49187: PPUSH
49188: LD_VAR 0 3
49192: PPUSH
49193: LD_EXP 96
49197: PUSH
49198: LD_VAR 0 3
49202: ARRAY
49203: PUSH
49204: LD_VAR 0 1
49208: DIFF
49209: PPUSH
49210: CALL_OW 1
49214: ST_TO_ADDR
// if building in mc_lab [ i ] then
49215: LD_VAR 0 1
49219: PUSH
49220: LD_EXP 122
49224: PUSH
49225: LD_VAR 0 3
49229: ARRAY
49230: IN
49231: IFFALSE 49286
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49233: LD_ADDR_EXP 123
49237: PUSH
49238: LD_EXP 123
49242: PPUSH
49243: LD_VAR 0 3
49247: PPUSH
49248: LD_EXP 123
49252: PUSH
49253: LD_VAR 0 3
49257: ARRAY
49258: PPUSH
49259: LD_INT 1
49261: PPUSH
49262: LD_EXP 123
49266: PUSH
49267: LD_VAR 0 3
49271: ARRAY
49272: PPUSH
49273: LD_INT 0
49275: PPUSH
49276: CALL 55035 0 4
49280: PPUSH
49281: CALL_OW 1
49285: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49286: LD_VAR 0 1
49290: PUSH
49291: LD_EXP 89
49295: PUSH
49296: LD_VAR 0 3
49300: ARRAY
49301: IN
49302: NOT
49303: IFFALSE 49349
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49305: LD_ADDR_EXP 89
49309: PUSH
49310: LD_EXP 89
49314: PPUSH
49315: LD_VAR 0 3
49319: PUSH
49320: LD_EXP 89
49324: PUSH
49325: LD_VAR 0 3
49329: ARRAY
49330: PUSH
49331: LD_INT 1
49333: PLUS
49334: PUSH
49335: EMPTY
49336: LIST
49337: LIST
49338: PPUSH
49339: LD_VAR 0 1
49343: PPUSH
49344: CALL 55617 0 3
49348: ST_TO_ADDR
// exit ;
49349: POP
49350: POP
49351: GO 49357
// end ; end ;
49353: GO 49157
49355: POP
49356: POP
// end ;
49357: LD_VAR 0 2
49361: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49362: LD_INT 0
49364: PPUSH
49365: PPUSH
49366: PPUSH
49367: PPUSH
49368: PPUSH
49369: PPUSH
49370: PPUSH
// if not mc_bases or not skirmish then
49371: LD_EXP 89
49375: NOT
49376: PUSH
49377: LD_EXP 87
49381: NOT
49382: OR
49383: IFFALSE 49387
// exit ;
49385: GO 50048
// for i = 1 to mc_bases do
49387: LD_ADDR_VAR 0 3
49391: PUSH
49392: DOUBLE
49393: LD_INT 1
49395: DEC
49396: ST_TO_ADDR
49397: LD_EXP 89
49401: PUSH
49402: FOR_TO
49403: IFFALSE 50046
// begin if building in mc_construct_list [ i ] then
49405: LD_VAR 0 1
49409: PUSH
49410: LD_EXP 96
49414: PUSH
49415: LD_VAR 0 3
49419: ARRAY
49420: IN
49421: IFFALSE 50044
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49423: LD_ADDR_EXP 96
49427: PUSH
49428: LD_EXP 96
49432: PPUSH
49433: LD_VAR 0 3
49437: PPUSH
49438: LD_EXP 96
49442: PUSH
49443: LD_VAR 0 3
49447: ARRAY
49448: PUSH
49449: LD_VAR 0 1
49453: DIFF
49454: PPUSH
49455: CALL_OW 1
49459: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49460: LD_ADDR_EXP 89
49464: PUSH
49465: LD_EXP 89
49469: PPUSH
49470: LD_VAR 0 3
49474: PUSH
49475: LD_EXP 89
49479: PUSH
49480: LD_VAR 0 3
49484: ARRAY
49485: PUSH
49486: LD_INT 1
49488: PLUS
49489: PUSH
49490: EMPTY
49491: LIST
49492: LIST
49493: PPUSH
49494: LD_VAR 0 1
49498: PPUSH
49499: CALL 55617 0 3
49503: ST_TO_ADDR
// btype := GetBType ( building ) ;
49504: LD_ADDR_VAR 0 5
49508: PUSH
49509: LD_VAR 0 1
49513: PPUSH
49514: CALL_OW 266
49518: ST_TO_ADDR
// side := GetSide ( building ) ;
49519: LD_ADDR_VAR 0 8
49523: PUSH
49524: LD_VAR 0 1
49528: PPUSH
49529: CALL_OW 255
49533: ST_TO_ADDR
// if btype = b_lab then
49534: LD_VAR 0 5
49538: PUSH
49539: LD_INT 6
49541: EQUAL
49542: IFFALSE 49592
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49544: LD_ADDR_EXP 122
49548: PUSH
49549: LD_EXP 122
49553: PPUSH
49554: LD_VAR 0 3
49558: PUSH
49559: LD_EXP 122
49563: PUSH
49564: LD_VAR 0 3
49568: ARRAY
49569: PUSH
49570: LD_INT 1
49572: PLUS
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PPUSH
49578: LD_VAR 0 1
49582: PPUSH
49583: CALL 55617 0 3
49587: ST_TO_ADDR
// exit ;
49588: POP
49589: POP
49590: GO 50048
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49592: LD_VAR 0 5
49596: PUSH
49597: LD_INT 0
49599: PUSH
49600: LD_INT 2
49602: PUSH
49603: LD_INT 4
49605: PUSH
49606: EMPTY
49607: LIST
49608: LIST
49609: LIST
49610: IN
49611: IFFALSE 49735
// begin if btype = b_armoury then
49613: LD_VAR 0 5
49617: PUSH
49618: LD_INT 4
49620: EQUAL
49621: IFFALSE 49631
// btype := b_barracks ;
49623: LD_ADDR_VAR 0 5
49627: PUSH
49628: LD_INT 5
49630: ST_TO_ADDR
// if btype = b_depot then
49631: LD_VAR 0 5
49635: PUSH
49636: LD_INT 0
49638: EQUAL
49639: IFFALSE 49649
// btype := b_warehouse ;
49641: LD_ADDR_VAR 0 5
49645: PUSH
49646: LD_INT 1
49648: ST_TO_ADDR
// if btype = b_workshop then
49649: LD_VAR 0 5
49653: PUSH
49654: LD_INT 2
49656: EQUAL
49657: IFFALSE 49667
// btype := b_factory ;
49659: LD_ADDR_VAR 0 5
49663: PUSH
49664: LD_INT 3
49666: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49667: LD_VAR 0 5
49671: PPUSH
49672: LD_VAR 0 8
49676: PPUSH
49677: CALL_OW 323
49681: PUSH
49682: LD_INT 1
49684: EQUAL
49685: IFFALSE 49731
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49687: LD_ADDR_EXP 121
49691: PUSH
49692: LD_EXP 121
49696: PPUSH
49697: LD_VAR 0 3
49701: PUSH
49702: LD_EXP 121
49706: PUSH
49707: LD_VAR 0 3
49711: ARRAY
49712: PUSH
49713: LD_INT 1
49715: PLUS
49716: PUSH
49717: EMPTY
49718: LIST
49719: LIST
49720: PPUSH
49721: LD_VAR 0 1
49725: PPUSH
49726: CALL 55617 0 3
49730: ST_TO_ADDR
// exit ;
49731: POP
49732: POP
49733: GO 50048
// end ; if btype in [ b_bunker , b_turret ] then
49735: LD_VAR 0 5
49739: PUSH
49740: LD_INT 32
49742: PUSH
49743: LD_INT 33
49745: PUSH
49746: EMPTY
49747: LIST
49748: LIST
49749: IN
49750: IFFALSE 50040
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49752: LD_ADDR_EXP 97
49756: PUSH
49757: LD_EXP 97
49761: PPUSH
49762: LD_VAR 0 3
49766: PUSH
49767: LD_EXP 97
49771: PUSH
49772: LD_VAR 0 3
49776: ARRAY
49777: PUSH
49778: LD_INT 1
49780: PLUS
49781: PUSH
49782: EMPTY
49783: LIST
49784: LIST
49785: PPUSH
49786: LD_VAR 0 1
49790: PPUSH
49791: CALL 55617 0 3
49795: ST_TO_ADDR
// if btype = b_bunker then
49796: LD_VAR 0 5
49800: PUSH
49801: LD_INT 32
49803: EQUAL
49804: IFFALSE 50040
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49806: LD_ADDR_EXP 98
49810: PUSH
49811: LD_EXP 98
49815: PPUSH
49816: LD_VAR 0 3
49820: PUSH
49821: LD_EXP 98
49825: PUSH
49826: LD_VAR 0 3
49830: ARRAY
49831: PUSH
49832: LD_INT 1
49834: PLUS
49835: PUSH
49836: EMPTY
49837: LIST
49838: LIST
49839: PPUSH
49840: LD_VAR 0 1
49844: PPUSH
49845: CALL 55617 0 3
49849: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49850: LD_ADDR_VAR 0 6
49854: PUSH
49855: LD_EXP 89
49859: PUSH
49860: LD_VAR 0 3
49864: ARRAY
49865: PPUSH
49866: LD_INT 25
49868: PUSH
49869: LD_INT 1
49871: PUSH
49872: EMPTY
49873: LIST
49874: LIST
49875: PUSH
49876: LD_INT 3
49878: PUSH
49879: LD_INT 54
49881: PUSH
49882: EMPTY
49883: LIST
49884: PUSH
49885: EMPTY
49886: LIST
49887: LIST
49888: PUSH
49889: EMPTY
49890: LIST
49891: LIST
49892: PPUSH
49893: CALL_OW 72
49897: ST_TO_ADDR
// if tmp then
49898: LD_VAR 0 6
49902: IFFALSE 49908
// exit ;
49904: POP
49905: POP
49906: GO 50048
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49908: LD_ADDR_VAR 0 6
49912: PUSH
49913: LD_EXP 89
49917: PUSH
49918: LD_VAR 0 3
49922: ARRAY
49923: PPUSH
49924: LD_INT 2
49926: PUSH
49927: LD_INT 30
49929: PUSH
49930: LD_INT 4
49932: PUSH
49933: EMPTY
49934: LIST
49935: LIST
49936: PUSH
49937: LD_INT 30
49939: PUSH
49940: LD_INT 5
49942: PUSH
49943: EMPTY
49944: LIST
49945: LIST
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: LIST
49951: PPUSH
49952: CALL_OW 72
49956: ST_TO_ADDR
// if not tmp then
49957: LD_VAR 0 6
49961: NOT
49962: IFFALSE 49968
// exit ;
49964: POP
49965: POP
49966: GO 50048
// for j in tmp do
49968: LD_ADDR_VAR 0 4
49972: PUSH
49973: LD_VAR 0 6
49977: PUSH
49978: FOR_IN
49979: IFFALSE 50038
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49981: LD_ADDR_VAR 0 7
49985: PUSH
49986: LD_VAR 0 4
49990: PPUSH
49991: CALL_OW 313
49995: PPUSH
49996: LD_INT 25
49998: PUSH
49999: LD_INT 1
50001: PUSH
50002: EMPTY
50003: LIST
50004: LIST
50005: PPUSH
50006: CALL_OW 72
50010: ST_TO_ADDR
// if units then
50011: LD_VAR 0 7
50015: IFFALSE 50036
// begin ComExitBuilding ( units [ 1 ] ) ;
50017: LD_VAR 0 7
50021: PUSH
50022: LD_INT 1
50024: ARRAY
50025: PPUSH
50026: CALL_OW 122
// exit ;
50030: POP
50031: POP
50032: POP
50033: POP
50034: GO 50048
// end ; end ;
50036: GO 49978
50038: POP
50039: POP
// end ; end ; exit ;
50040: POP
50041: POP
50042: GO 50048
// end ; end ;
50044: GO 49402
50046: POP
50047: POP
// end ;
50048: LD_VAR 0 2
50052: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50053: LD_INT 0
50055: PPUSH
50056: PPUSH
50057: PPUSH
50058: PPUSH
50059: PPUSH
50060: PPUSH
50061: PPUSH
// if not mc_bases or not skirmish then
50062: LD_EXP 89
50066: NOT
50067: PUSH
50068: LD_EXP 87
50072: NOT
50073: OR
50074: IFFALSE 50078
// exit ;
50076: GO 50309
// btype := GetBType ( building ) ;
50078: LD_ADDR_VAR 0 6
50082: PUSH
50083: LD_VAR 0 1
50087: PPUSH
50088: CALL_OW 266
50092: ST_TO_ADDR
// x := GetX ( building ) ;
50093: LD_ADDR_VAR 0 7
50097: PUSH
50098: LD_VAR 0 1
50102: PPUSH
50103: CALL_OW 250
50107: ST_TO_ADDR
// y := GetY ( building ) ;
50108: LD_ADDR_VAR 0 8
50112: PUSH
50113: LD_VAR 0 1
50117: PPUSH
50118: CALL_OW 251
50122: ST_TO_ADDR
// d := GetDir ( building ) ;
50123: LD_ADDR_VAR 0 9
50127: PUSH
50128: LD_VAR 0 1
50132: PPUSH
50133: CALL_OW 254
50137: ST_TO_ADDR
// for i = 1 to mc_bases do
50138: LD_ADDR_VAR 0 4
50142: PUSH
50143: DOUBLE
50144: LD_INT 1
50146: DEC
50147: ST_TO_ADDR
50148: LD_EXP 89
50152: PUSH
50153: FOR_TO
50154: IFFALSE 50307
// begin if not mc_build_list [ i ] then
50156: LD_EXP 94
50160: PUSH
50161: LD_VAR 0 4
50165: ARRAY
50166: NOT
50167: IFFALSE 50171
// continue ;
50169: GO 50153
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50171: LD_VAR 0 6
50175: PUSH
50176: LD_VAR 0 7
50180: PUSH
50181: LD_VAR 0 8
50185: PUSH
50186: LD_VAR 0 9
50190: PUSH
50191: EMPTY
50192: LIST
50193: LIST
50194: LIST
50195: LIST
50196: PPUSH
50197: LD_EXP 94
50201: PUSH
50202: LD_VAR 0 4
50206: ARRAY
50207: PUSH
50208: LD_INT 1
50210: ARRAY
50211: PPUSH
50212: CALL 61786 0 2
50216: IFFALSE 50305
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50218: LD_ADDR_EXP 94
50222: PUSH
50223: LD_EXP 94
50227: PPUSH
50228: LD_VAR 0 4
50232: PPUSH
50233: LD_EXP 94
50237: PUSH
50238: LD_VAR 0 4
50242: ARRAY
50243: PPUSH
50244: LD_INT 1
50246: PPUSH
50247: CALL_OW 3
50251: PPUSH
50252: CALL_OW 1
50256: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50257: LD_ADDR_EXP 96
50261: PUSH
50262: LD_EXP 96
50266: PPUSH
50267: LD_VAR 0 4
50271: PUSH
50272: LD_EXP 96
50276: PUSH
50277: LD_VAR 0 4
50281: ARRAY
50282: PUSH
50283: LD_INT 1
50285: PLUS
50286: PUSH
50287: EMPTY
50288: LIST
50289: LIST
50290: PPUSH
50291: LD_VAR 0 1
50295: PPUSH
50296: CALL 55617 0 3
50300: ST_TO_ADDR
// exit ;
50301: POP
50302: POP
50303: GO 50309
// end ; end ;
50305: GO 50153
50307: POP
50308: POP
// end ;
50309: LD_VAR 0 3
50313: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50314: LD_INT 0
50316: PPUSH
50317: PPUSH
50318: PPUSH
// if not mc_bases or not skirmish then
50319: LD_EXP 89
50323: NOT
50324: PUSH
50325: LD_EXP 87
50329: NOT
50330: OR
50331: IFFALSE 50335
// exit ;
50333: GO 50525
// for i = 1 to mc_bases do
50335: LD_ADDR_VAR 0 4
50339: PUSH
50340: DOUBLE
50341: LD_INT 1
50343: DEC
50344: ST_TO_ADDR
50345: LD_EXP 89
50349: PUSH
50350: FOR_TO
50351: IFFALSE 50438
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50353: LD_VAR 0 1
50357: PUSH
50358: LD_EXP 97
50362: PUSH
50363: LD_VAR 0 4
50367: ARRAY
50368: IN
50369: PUSH
50370: LD_VAR 0 1
50374: PUSH
50375: LD_EXP 98
50379: PUSH
50380: LD_VAR 0 4
50384: ARRAY
50385: IN
50386: NOT
50387: AND
50388: IFFALSE 50436
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50390: LD_ADDR_EXP 98
50394: PUSH
50395: LD_EXP 98
50399: PPUSH
50400: LD_VAR 0 4
50404: PUSH
50405: LD_EXP 98
50409: PUSH
50410: LD_VAR 0 4
50414: ARRAY
50415: PUSH
50416: LD_INT 1
50418: PLUS
50419: PUSH
50420: EMPTY
50421: LIST
50422: LIST
50423: PPUSH
50424: LD_VAR 0 1
50428: PPUSH
50429: CALL 55617 0 3
50433: ST_TO_ADDR
// break ;
50434: GO 50438
// end ; end ;
50436: GO 50350
50438: POP
50439: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50440: LD_VAR 0 1
50444: PPUSH
50445: CALL_OW 257
50449: PUSH
50450: LD_EXP 115
50454: IN
50455: PUSH
50456: LD_VAR 0 1
50460: PPUSH
50461: CALL_OW 266
50465: PUSH
50466: LD_INT 5
50468: EQUAL
50469: AND
50470: PUSH
50471: LD_VAR 0 2
50475: PPUSH
50476: CALL_OW 110
50480: PUSH
50481: LD_INT 18
50483: NONEQUAL
50484: AND
50485: IFFALSE 50525
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50487: LD_VAR 0 2
50491: PPUSH
50492: CALL_OW 257
50496: PUSH
50497: LD_INT 5
50499: PUSH
50500: LD_INT 8
50502: PUSH
50503: LD_INT 9
50505: PUSH
50506: EMPTY
50507: LIST
50508: LIST
50509: LIST
50510: IN
50511: IFFALSE 50525
// SetClass ( unit , 1 ) ;
50513: LD_VAR 0 2
50517: PPUSH
50518: LD_INT 1
50520: PPUSH
50521: CALL_OW 336
// end ;
50525: LD_VAR 0 3
50529: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50530: LD_INT 0
50532: PPUSH
50533: PPUSH
// if not mc_bases or not skirmish then
50534: LD_EXP 89
50538: NOT
50539: PUSH
50540: LD_EXP 87
50544: NOT
50545: OR
50546: IFFALSE 50550
// exit ;
50548: GO 50666
// if GetLives ( abandoned_vehicle ) > 250 then
50550: LD_VAR 0 2
50554: PPUSH
50555: CALL_OW 256
50559: PUSH
50560: LD_INT 250
50562: GREATER
50563: IFFALSE 50567
// exit ;
50565: GO 50666
// for i = 1 to mc_bases do
50567: LD_ADDR_VAR 0 6
50571: PUSH
50572: DOUBLE
50573: LD_INT 1
50575: DEC
50576: ST_TO_ADDR
50577: LD_EXP 89
50581: PUSH
50582: FOR_TO
50583: IFFALSE 50664
// begin if driver in mc_bases [ i ] then
50585: LD_VAR 0 1
50589: PUSH
50590: LD_EXP 89
50594: PUSH
50595: LD_VAR 0 6
50599: ARRAY
50600: IN
50601: IFFALSE 50662
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50603: LD_VAR 0 1
50607: PPUSH
50608: LD_EXP 89
50612: PUSH
50613: LD_VAR 0 6
50617: ARRAY
50618: PPUSH
50619: LD_INT 2
50621: PUSH
50622: LD_INT 30
50624: PUSH
50625: LD_INT 0
50627: PUSH
50628: EMPTY
50629: LIST
50630: LIST
50631: PUSH
50632: LD_INT 30
50634: PUSH
50635: LD_INT 1
50637: PUSH
50638: EMPTY
50639: LIST
50640: LIST
50641: PUSH
50642: EMPTY
50643: LIST
50644: LIST
50645: LIST
50646: PPUSH
50647: CALL_OW 72
50651: PUSH
50652: LD_INT 1
50654: ARRAY
50655: PPUSH
50656: CALL_OW 112
// break ;
50660: GO 50664
// end ; end ;
50662: GO 50582
50664: POP
50665: POP
// end ; end_of_file
50666: LD_VAR 0 5
50670: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50671: LD_INT 0
50673: PPUSH
50674: PPUSH
// if exist_mode then
50675: LD_VAR 0 2
50679: IFFALSE 50704
// unit := CreateCharacter ( prefix & ident ) else
50681: LD_ADDR_VAR 0 5
50685: PUSH
50686: LD_VAR 0 3
50690: PUSH
50691: LD_VAR 0 1
50695: STR
50696: PPUSH
50697: CALL_OW 34
50701: ST_TO_ADDR
50702: GO 50719
// unit := NewCharacter ( ident ) ;
50704: LD_ADDR_VAR 0 5
50708: PUSH
50709: LD_VAR 0 1
50713: PPUSH
50714: CALL_OW 25
50718: ST_TO_ADDR
// result := unit ;
50719: LD_ADDR_VAR 0 4
50723: PUSH
50724: LD_VAR 0 5
50728: ST_TO_ADDR
// end ;
50729: LD_VAR 0 4
50733: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50734: LD_INT 0
50736: PPUSH
50737: PPUSH
// if not side or not nation then
50738: LD_VAR 0 1
50742: NOT
50743: PUSH
50744: LD_VAR 0 2
50748: NOT
50749: OR
50750: IFFALSE 50754
// exit ;
50752: GO 51518
// case nation of nation_american :
50754: LD_VAR 0 2
50758: PUSH
50759: LD_INT 1
50761: DOUBLE
50762: EQUAL
50763: IFTRUE 50767
50765: GO 50981
50767: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
50768: LD_ADDR_VAR 0 4
50772: PUSH
50773: LD_INT 35
50775: PUSH
50776: LD_INT 45
50778: PUSH
50779: LD_INT 46
50781: PUSH
50782: LD_INT 47
50784: PUSH
50785: LD_INT 82
50787: PUSH
50788: LD_INT 83
50790: PUSH
50791: LD_INT 84
50793: PUSH
50794: LD_INT 85
50796: PUSH
50797: LD_INT 86
50799: PUSH
50800: LD_INT 1
50802: PUSH
50803: LD_INT 2
50805: PUSH
50806: LD_INT 6
50808: PUSH
50809: LD_INT 15
50811: PUSH
50812: LD_INT 16
50814: PUSH
50815: LD_INT 7
50817: PUSH
50818: LD_INT 12
50820: PUSH
50821: LD_INT 13
50823: PUSH
50824: LD_INT 10
50826: PUSH
50827: LD_INT 14
50829: PUSH
50830: LD_INT 20
50832: PUSH
50833: LD_INT 21
50835: PUSH
50836: LD_INT 22
50838: PUSH
50839: LD_INT 25
50841: PUSH
50842: LD_INT 32
50844: PUSH
50845: LD_INT 27
50847: PUSH
50848: LD_INT 36
50850: PUSH
50851: LD_INT 69
50853: PUSH
50854: LD_INT 39
50856: PUSH
50857: LD_INT 34
50859: PUSH
50860: LD_INT 40
50862: PUSH
50863: LD_INT 48
50865: PUSH
50866: LD_INT 49
50868: PUSH
50869: LD_INT 50
50871: PUSH
50872: LD_INT 51
50874: PUSH
50875: LD_INT 52
50877: PUSH
50878: LD_INT 53
50880: PUSH
50881: LD_INT 54
50883: PUSH
50884: LD_INT 55
50886: PUSH
50887: LD_INT 56
50889: PUSH
50890: LD_INT 57
50892: PUSH
50893: LD_INT 58
50895: PUSH
50896: LD_INT 59
50898: PUSH
50899: LD_INT 60
50901: PUSH
50902: LD_INT 61
50904: PUSH
50905: LD_INT 62
50907: PUSH
50908: LD_INT 80
50910: PUSH
50911: LD_INT 82
50913: PUSH
50914: LD_INT 83
50916: PUSH
50917: LD_INT 84
50919: PUSH
50920: LD_INT 85
50922: PUSH
50923: LD_INT 86
50925: PUSH
50926: EMPTY
50927: LIST
50928: LIST
50929: LIST
50930: LIST
50931: LIST
50932: LIST
50933: LIST
50934: LIST
50935: LIST
50936: LIST
50937: LIST
50938: LIST
50939: LIST
50940: LIST
50941: LIST
50942: LIST
50943: LIST
50944: LIST
50945: LIST
50946: LIST
50947: LIST
50948: LIST
50949: LIST
50950: LIST
50951: LIST
50952: LIST
50953: LIST
50954: LIST
50955: LIST
50956: LIST
50957: LIST
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: LIST
50963: LIST
50964: LIST
50965: LIST
50966: LIST
50967: LIST
50968: LIST
50969: LIST
50970: LIST
50971: LIST
50972: LIST
50973: LIST
50974: LIST
50975: LIST
50976: LIST
50977: LIST
50978: ST_TO_ADDR
50979: GO 51442
50981: LD_INT 2
50983: DOUBLE
50984: EQUAL
50985: IFTRUE 50989
50987: GO 51211
50989: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
50990: LD_ADDR_VAR 0 4
50994: PUSH
50995: LD_INT 35
50997: PUSH
50998: LD_INT 45
51000: PUSH
51001: LD_INT 46
51003: PUSH
51004: LD_INT 47
51006: PUSH
51007: LD_INT 82
51009: PUSH
51010: LD_INT 83
51012: PUSH
51013: LD_INT 84
51015: PUSH
51016: LD_INT 85
51018: PUSH
51019: LD_INT 87
51021: PUSH
51022: LD_INT 70
51024: PUSH
51025: LD_INT 1
51027: PUSH
51028: LD_INT 11
51030: PUSH
51031: LD_INT 3
51033: PUSH
51034: LD_INT 4
51036: PUSH
51037: LD_INT 5
51039: PUSH
51040: LD_INT 6
51042: PUSH
51043: LD_INT 15
51045: PUSH
51046: LD_INT 18
51048: PUSH
51049: LD_INT 7
51051: PUSH
51052: LD_INT 17
51054: PUSH
51055: LD_INT 8
51057: PUSH
51058: LD_INT 20
51060: PUSH
51061: LD_INT 21
51063: PUSH
51064: LD_INT 22
51066: PUSH
51067: LD_INT 72
51069: PUSH
51070: LD_INT 26
51072: PUSH
51073: LD_INT 69
51075: PUSH
51076: LD_INT 39
51078: PUSH
51079: LD_INT 40
51081: PUSH
51082: LD_INT 41
51084: PUSH
51085: LD_INT 42
51087: PUSH
51088: LD_INT 43
51090: PUSH
51091: LD_INT 48
51093: PUSH
51094: LD_INT 49
51096: PUSH
51097: LD_INT 50
51099: PUSH
51100: LD_INT 51
51102: PUSH
51103: LD_INT 52
51105: PUSH
51106: LD_INT 53
51108: PUSH
51109: LD_INT 54
51111: PUSH
51112: LD_INT 55
51114: PUSH
51115: LD_INT 56
51117: PUSH
51118: LD_INT 60
51120: PUSH
51121: LD_INT 61
51123: PUSH
51124: LD_INT 62
51126: PUSH
51127: LD_INT 66
51129: PUSH
51130: LD_INT 67
51132: PUSH
51133: LD_INT 68
51135: PUSH
51136: LD_INT 81
51138: PUSH
51139: LD_INT 82
51141: PUSH
51142: LD_INT 83
51144: PUSH
51145: LD_INT 84
51147: PUSH
51148: LD_INT 85
51150: PUSH
51151: LD_INT 87
51153: PUSH
51154: EMPTY
51155: LIST
51156: LIST
51157: LIST
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: LIST
51173: LIST
51174: LIST
51175: LIST
51176: LIST
51177: LIST
51178: LIST
51179: LIST
51180: LIST
51181: LIST
51182: LIST
51183: LIST
51184: LIST
51185: LIST
51186: LIST
51187: LIST
51188: LIST
51189: LIST
51190: LIST
51191: LIST
51192: LIST
51193: LIST
51194: LIST
51195: LIST
51196: LIST
51197: LIST
51198: LIST
51199: LIST
51200: LIST
51201: LIST
51202: LIST
51203: LIST
51204: LIST
51205: LIST
51206: LIST
51207: LIST
51208: ST_TO_ADDR
51209: GO 51442
51211: LD_INT 3
51213: DOUBLE
51214: EQUAL
51215: IFTRUE 51219
51217: GO 51441
51219: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51220: LD_ADDR_VAR 0 4
51224: PUSH
51225: LD_INT 46
51227: PUSH
51228: LD_INT 47
51230: PUSH
51231: LD_INT 1
51233: PUSH
51234: LD_INT 2
51236: PUSH
51237: LD_INT 82
51239: PUSH
51240: LD_INT 83
51242: PUSH
51243: LD_INT 84
51245: PUSH
51246: LD_INT 85
51248: PUSH
51249: LD_INT 86
51251: PUSH
51252: LD_INT 11
51254: PUSH
51255: LD_INT 9
51257: PUSH
51258: LD_INT 20
51260: PUSH
51261: LD_INT 19
51263: PUSH
51264: LD_INT 21
51266: PUSH
51267: LD_INT 24
51269: PUSH
51270: LD_INT 22
51272: PUSH
51273: LD_INT 25
51275: PUSH
51276: LD_INT 28
51278: PUSH
51279: LD_INT 29
51281: PUSH
51282: LD_INT 30
51284: PUSH
51285: LD_INT 31
51287: PUSH
51288: LD_INT 37
51290: PUSH
51291: LD_INT 38
51293: PUSH
51294: LD_INT 32
51296: PUSH
51297: LD_INT 27
51299: PUSH
51300: LD_INT 33
51302: PUSH
51303: LD_INT 69
51305: PUSH
51306: LD_INT 39
51308: PUSH
51309: LD_INT 34
51311: PUSH
51312: LD_INT 40
51314: PUSH
51315: LD_INT 71
51317: PUSH
51318: LD_INT 23
51320: PUSH
51321: LD_INT 44
51323: PUSH
51324: LD_INT 48
51326: PUSH
51327: LD_INT 49
51329: PUSH
51330: LD_INT 50
51332: PUSH
51333: LD_INT 51
51335: PUSH
51336: LD_INT 52
51338: PUSH
51339: LD_INT 53
51341: PUSH
51342: LD_INT 54
51344: PUSH
51345: LD_INT 55
51347: PUSH
51348: LD_INT 56
51350: PUSH
51351: LD_INT 57
51353: PUSH
51354: LD_INT 58
51356: PUSH
51357: LD_INT 59
51359: PUSH
51360: LD_INT 63
51362: PUSH
51363: LD_INT 64
51365: PUSH
51366: LD_INT 65
51368: PUSH
51369: LD_INT 82
51371: PUSH
51372: LD_INT 83
51374: PUSH
51375: LD_INT 84
51377: PUSH
51378: LD_INT 85
51380: PUSH
51381: LD_INT 86
51383: PUSH
51384: EMPTY
51385: LIST
51386: LIST
51387: LIST
51388: LIST
51389: LIST
51390: LIST
51391: LIST
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: LIST
51397: LIST
51398: LIST
51399: LIST
51400: LIST
51401: LIST
51402: LIST
51403: LIST
51404: LIST
51405: LIST
51406: LIST
51407: LIST
51408: LIST
51409: LIST
51410: LIST
51411: LIST
51412: LIST
51413: LIST
51414: LIST
51415: LIST
51416: LIST
51417: LIST
51418: LIST
51419: LIST
51420: LIST
51421: LIST
51422: LIST
51423: LIST
51424: LIST
51425: LIST
51426: LIST
51427: LIST
51428: LIST
51429: LIST
51430: LIST
51431: LIST
51432: LIST
51433: LIST
51434: LIST
51435: LIST
51436: LIST
51437: LIST
51438: ST_TO_ADDR
51439: GO 51442
51441: POP
// if state > - 1 and state < 3 then
51442: LD_VAR 0 3
51446: PUSH
51447: LD_INT 1
51449: NEG
51450: GREATER
51451: PUSH
51452: LD_VAR 0 3
51456: PUSH
51457: LD_INT 3
51459: LESS
51460: AND
51461: IFFALSE 51518
// for i in result do
51463: LD_ADDR_VAR 0 5
51467: PUSH
51468: LD_VAR 0 4
51472: PUSH
51473: FOR_IN
51474: IFFALSE 51516
// if GetTech ( i , side ) <> state then
51476: LD_VAR 0 5
51480: PPUSH
51481: LD_VAR 0 1
51485: PPUSH
51486: CALL_OW 321
51490: PUSH
51491: LD_VAR 0 3
51495: NONEQUAL
51496: IFFALSE 51514
// result := result diff i ;
51498: LD_ADDR_VAR 0 4
51502: PUSH
51503: LD_VAR 0 4
51507: PUSH
51508: LD_VAR 0 5
51512: DIFF
51513: ST_TO_ADDR
51514: GO 51473
51516: POP
51517: POP
// end ;
51518: LD_VAR 0 4
51522: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51523: LD_INT 0
51525: PPUSH
51526: PPUSH
51527: PPUSH
// result := true ;
51528: LD_ADDR_VAR 0 3
51532: PUSH
51533: LD_INT 1
51535: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51536: LD_ADDR_VAR 0 5
51540: PUSH
51541: LD_VAR 0 2
51545: PPUSH
51546: CALL_OW 480
51550: ST_TO_ADDR
// if not tmp then
51551: LD_VAR 0 5
51555: NOT
51556: IFFALSE 51560
// exit ;
51558: GO 51609
// for i in tmp do
51560: LD_ADDR_VAR 0 4
51564: PUSH
51565: LD_VAR 0 5
51569: PUSH
51570: FOR_IN
51571: IFFALSE 51607
// if GetTech ( i , side ) <> state_researched then
51573: LD_VAR 0 4
51577: PPUSH
51578: LD_VAR 0 1
51582: PPUSH
51583: CALL_OW 321
51587: PUSH
51588: LD_INT 2
51590: NONEQUAL
51591: IFFALSE 51605
// begin result := false ;
51593: LD_ADDR_VAR 0 3
51597: PUSH
51598: LD_INT 0
51600: ST_TO_ADDR
// exit ;
51601: POP
51602: POP
51603: GO 51609
// end ;
51605: GO 51570
51607: POP
51608: POP
// end ;
51609: LD_VAR 0 3
51613: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51614: LD_INT 0
51616: PPUSH
51617: PPUSH
51618: PPUSH
51619: PPUSH
51620: PPUSH
51621: PPUSH
51622: PPUSH
51623: PPUSH
51624: PPUSH
51625: PPUSH
51626: PPUSH
51627: PPUSH
51628: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51629: LD_VAR 0 1
51633: NOT
51634: PUSH
51635: LD_VAR 0 1
51639: PPUSH
51640: CALL_OW 257
51644: PUSH
51645: LD_INT 9
51647: NONEQUAL
51648: OR
51649: IFFALSE 51653
// exit ;
51651: GO 52226
// side := GetSide ( unit ) ;
51653: LD_ADDR_VAR 0 9
51657: PUSH
51658: LD_VAR 0 1
51662: PPUSH
51663: CALL_OW 255
51667: ST_TO_ADDR
// tech_space := tech_spacanom ;
51668: LD_ADDR_VAR 0 12
51672: PUSH
51673: LD_INT 29
51675: ST_TO_ADDR
// tech_time := tech_taurad ;
51676: LD_ADDR_VAR 0 13
51680: PUSH
51681: LD_INT 28
51683: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51684: LD_ADDR_VAR 0 11
51688: PUSH
51689: LD_VAR 0 1
51693: PPUSH
51694: CALL_OW 310
51698: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51699: LD_VAR 0 11
51703: PPUSH
51704: CALL_OW 247
51708: PUSH
51709: LD_INT 2
51711: EQUAL
51712: IFFALSE 51716
// exit ;
51714: GO 52226
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51716: LD_ADDR_VAR 0 8
51720: PUSH
51721: LD_INT 81
51723: PUSH
51724: LD_VAR 0 9
51728: PUSH
51729: EMPTY
51730: LIST
51731: LIST
51732: PUSH
51733: LD_INT 3
51735: PUSH
51736: LD_INT 21
51738: PUSH
51739: LD_INT 3
51741: PUSH
51742: EMPTY
51743: LIST
51744: LIST
51745: PUSH
51746: EMPTY
51747: LIST
51748: LIST
51749: PUSH
51750: EMPTY
51751: LIST
51752: LIST
51753: PPUSH
51754: CALL_OW 69
51758: ST_TO_ADDR
// if not tmp then
51759: LD_VAR 0 8
51763: NOT
51764: IFFALSE 51768
// exit ;
51766: GO 52226
// if in_unit then
51768: LD_VAR 0 11
51772: IFFALSE 51796
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51774: LD_ADDR_VAR 0 10
51778: PUSH
51779: LD_VAR 0 8
51783: PPUSH
51784: LD_VAR 0 11
51788: PPUSH
51789: CALL_OW 74
51793: ST_TO_ADDR
51794: GO 51816
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51796: LD_ADDR_VAR 0 10
51800: PUSH
51801: LD_VAR 0 8
51805: PPUSH
51806: LD_VAR 0 1
51810: PPUSH
51811: CALL_OW 74
51815: ST_TO_ADDR
// if not enemy then
51816: LD_VAR 0 10
51820: NOT
51821: IFFALSE 51825
// exit ;
51823: GO 52226
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51825: LD_VAR 0 11
51829: PUSH
51830: LD_VAR 0 11
51834: PPUSH
51835: LD_VAR 0 10
51839: PPUSH
51840: CALL_OW 296
51844: PUSH
51845: LD_INT 13
51847: GREATER
51848: AND
51849: PUSH
51850: LD_VAR 0 1
51854: PPUSH
51855: LD_VAR 0 10
51859: PPUSH
51860: CALL_OW 296
51864: PUSH
51865: LD_INT 12
51867: GREATER
51868: OR
51869: IFFALSE 51873
// exit ;
51871: GO 52226
// missile := [ 1 ] ;
51873: LD_ADDR_VAR 0 14
51877: PUSH
51878: LD_INT 1
51880: PUSH
51881: EMPTY
51882: LIST
51883: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51884: LD_VAR 0 9
51888: PPUSH
51889: LD_VAR 0 12
51893: PPUSH
51894: CALL_OW 325
51898: IFFALSE 51927
// missile := Insert ( missile , missile + 1 , 2 ) ;
51900: LD_ADDR_VAR 0 14
51904: PUSH
51905: LD_VAR 0 14
51909: PPUSH
51910: LD_VAR 0 14
51914: PUSH
51915: LD_INT 1
51917: PLUS
51918: PPUSH
51919: LD_INT 2
51921: PPUSH
51922: CALL_OW 2
51926: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51927: LD_VAR 0 9
51931: PPUSH
51932: LD_VAR 0 13
51936: PPUSH
51937: CALL_OW 325
51941: PUSH
51942: LD_VAR 0 10
51946: PPUSH
51947: CALL_OW 255
51951: PPUSH
51952: LD_VAR 0 13
51956: PPUSH
51957: CALL_OW 325
51961: NOT
51962: AND
51963: IFFALSE 51992
// missile := Insert ( missile , missile + 1 , 3 ) ;
51965: LD_ADDR_VAR 0 14
51969: PUSH
51970: LD_VAR 0 14
51974: PPUSH
51975: LD_VAR 0 14
51979: PUSH
51980: LD_INT 1
51982: PLUS
51983: PPUSH
51984: LD_INT 3
51986: PPUSH
51987: CALL_OW 2
51991: ST_TO_ADDR
// if missile < 2 then
51992: LD_VAR 0 14
51996: PUSH
51997: LD_INT 2
51999: LESS
52000: IFFALSE 52004
// exit ;
52002: GO 52226
// x := GetX ( enemy ) ;
52004: LD_ADDR_VAR 0 4
52008: PUSH
52009: LD_VAR 0 10
52013: PPUSH
52014: CALL_OW 250
52018: ST_TO_ADDR
// y := GetY ( enemy ) ;
52019: LD_ADDR_VAR 0 5
52023: PUSH
52024: LD_VAR 0 10
52028: PPUSH
52029: CALL_OW 251
52033: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52034: LD_ADDR_VAR 0 6
52038: PUSH
52039: LD_VAR 0 4
52043: PUSH
52044: LD_INT 1
52046: NEG
52047: PPUSH
52048: LD_INT 1
52050: PPUSH
52051: CALL_OW 12
52055: PLUS
52056: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52057: LD_ADDR_VAR 0 7
52061: PUSH
52062: LD_VAR 0 5
52066: PUSH
52067: LD_INT 1
52069: NEG
52070: PPUSH
52071: LD_INT 1
52073: PPUSH
52074: CALL_OW 12
52078: PLUS
52079: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52080: LD_VAR 0 6
52084: PPUSH
52085: LD_VAR 0 7
52089: PPUSH
52090: CALL_OW 488
52094: NOT
52095: IFFALSE 52117
// begin _x := x ;
52097: LD_ADDR_VAR 0 6
52101: PUSH
52102: LD_VAR 0 4
52106: ST_TO_ADDR
// _y := y ;
52107: LD_ADDR_VAR 0 7
52111: PUSH
52112: LD_VAR 0 5
52116: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52117: LD_ADDR_VAR 0 3
52121: PUSH
52122: LD_INT 1
52124: PPUSH
52125: LD_VAR 0 14
52129: PPUSH
52130: CALL_OW 12
52134: ST_TO_ADDR
// case i of 1 :
52135: LD_VAR 0 3
52139: PUSH
52140: LD_INT 1
52142: DOUBLE
52143: EQUAL
52144: IFTRUE 52148
52146: GO 52165
52148: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52149: LD_VAR 0 1
52153: PPUSH
52154: LD_VAR 0 10
52158: PPUSH
52159: CALL_OW 115
52163: GO 52226
52165: LD_INT 2
52167: DOUBLE
52168: EQUAL
52169: IFTRUE 52173
52171: GO 52195
52173: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52174: LD_VAR 0 1
52178: PPUSH
52179: LD_VAR 0 6
52183: PPUSH
52184: LD_VAR 0 7
52188: PPUSH
52189: CALL_OW 153
52193: GO 52226
52195: LD_INT 3
52197: DOUBLE
52198: EQUAL
52199: IFTRUE 52203
52201: GO 52225
52203: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52204: LD_VAR 0 1
52208: PPUSH
52209: LD_VAR 0 6
52213: PPUSH
52214: LD_VAR 0 7
52218: PPUSH
52219: CALL_OW 154
52223: GO 52226
52225: POP
// end ;
52226: LD_VAR 0 2
52230: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52231: LD_INT 0
52233: PPUSH
52234: PPUSH
52235: PPUSH
52236: PPUSH
52237: PPUSH
52238: PPUSH
// if not unit or not building then
52239: LD_VAR 0 1
52243: NOT
52244: PUSH
52245: LD_VAR 0 2
52249: NOT
52250: OR
52251: IFFALSE 52255
// exit ;
52253: GO 52413
// x := GetX ( building ) ;
52255: LD_ADDR_VAR 0 5
52259: PUSH
52260: LD_VAR 0 2
52264: PPUSH
52265: CALL_OW 250
52269: ST_TO_ADDR
// y := GetY ( building ) ;
52270: LD_ADDR_VAR 0 6
52274: PUSH
52275: LD_VAR 0 2
52279: PPUSH
52280: CALL_OW 251
52284: ST_TO_ADDR
// for i = 0 to 5 do
52285: LD_ADDR_VAR 0 4
52289: PUSH
52290: DOUBLE
52291: LD_INT 0
52293: DEC
52294: ST_TO_ADDR
52295: LD_INT 5
52297: PUSH
52298: FOR_TO
52299: IFFALSE 52411
// begin _x := ShiftX ( x , i , 3 ) ;
52301: LD_ADDR_VAR 0 7
52305: PUSH
52306: LD_VAR 0 5
52310: PPUSH
52311: LD_VAR 0 4
52315: PPUSH
52316: LD_INT 3
52318: PPUSH
52319: CALL_OW 272
52323: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52324: LD_ADDR_VAR 0 8
52328: PUSH
52329: LD_VAR 0 6
52333: PPUSH
52334: LD_VAR 0 4
52338: PPUSH
52339: LD_INT 3
52341: PPUSH
52342: CALL_OW 273
52346: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52347: LD_VAR 0 7
52351: PPUSH
52352: LD_VAR 0 8
52356: PPUSH
52357: CALL_OW 488
52361: NOT
52362: IFFALSE 52366
// continue ;
52364: GO 52298
// if HexInfo ( _x , _y ) = 0 then
52366: LD_VAR 0 7
52370: PPUSH
52371: LD_VAR 0 8
52375: PPUSH
52376: CALL_OW 428
52380: PUSH
52381: LD_INT 0
52383: EQUAL
52384: IFFALSE 52409
// begin ComMoveXY ( unit , _x , _y ) ;
52386: LD_VAR 0 1
52390: PPUSH
52391: LD_VAR 0 7
52395: PPUSH
52396: LD_VAR 0 8
52400: PPUSH
52401: CALL_OW 111
// exit ;
52405: POP
52406: POP
52407: GO 52413
// end ; end ;
52409: GO 52298
52411: POP
52412: POP
// end ;
52413: LD_VAR 0 3
52417: RET
// export function ScanBase ( side , base_area ) ; begin
52418: LD_INT 0
52420: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52421: LD_ADDR_VAR 0 3
52425: PUSH
52426: LD_VAR 0 2
52430: PPUSH
52431: LD_INT 81
52433: PUSH
52434: LD_VAR 0 1
52438: PUSH
52439: EMPTY
52440: LIST
52441: LIST
52442: PPUSH
52443: CALL_OW 70
52447: ST_TO_ADDR
// end ;
52448: LD_VAR 0 3
52452: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52453: LD_INT 0
52455: PPUSH
52456: PPUSH
52457: PPUSH
52458: PPUSH
// result := false ;
52459: LD_ADDR_VAR 0 2
52463: PUSH
52464: LD_INT 0
52466: ST_TO_ADDR
// side := GetSide ( unit ) ;
52467: LD_ADDR_VAR 0 3
52471: PUSH
52472: LD_VAR 0 1
52476: PPUSH
52477: CALL_OW 255
52481: ST_TO_ADDR
// nat := GetNation ( unit ) ;
52482: LD_ADDR_VAR 0 4
52486: PUSH
52487: LD_VAR 0 1
52491: PPUSH
52492: CALL_OW 248
52496: ST_TO_ADDR
// case nat of 1 :
52497: LD_VAR 0 4
52501: PUSH
52502: LD_INT 1
52504: DOUBLE
52505: EQUAL
52506: IFTRUE 52510
52508: GO 52521
52510: POP
// tech := tech_lassight ; 2 :
52511: LD_ADDR_VAR 0 5
52515: PUSH
52516: LD_INT 12
52518: ST_TO_ADDR
52519: GO 52560
52521: LD_INT 2
52523: DOUBLE
52524: EQUAL
52525: IFTRUE 52529
52527: GO 52540
52529: POP
// tech := tech_mortar ; 3 :
52530: LD_ADDR_VAR 0 5
52534: PUSH
52535: LD_INT 41
52537: ST_TO_ADDR
52538: GO 52560
52540: LD_INT 3
52542: DOUBLE
52543: EQUAL
52544: IFTRUE 52548
52546: GO 52559
52548: POP
// tech := tech_bazooka ; end ;
52549: LD_ADDR_VAR 0 5
52553: PUSH
52554: LD_INT 44
52556: ST_TO_ADDR
52557: GO 52560
52559: POP
// if Researched ( side , tech ) then
52560: LD_VAR 0 3
52564: PPUSH
52565: LD_VAR 0 5
52569: PPUSH
52570: CALL_OW 325
52574: IFFALSE 52601
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
52576: LD_ADDR_VAR 0 2
52580: PUSH
52581: LD_INT 5
52583: PUSH
52584: LD_INT 8
52586: PUSH
52587: LD_INT 9
52589: PUSH
52590: EMPTY
52591: LIST
52592: LIST
52593: LIST
52594: PUSH
52595: LD_VAR 0 4
52599: ARRAY
52600: ST_TO_ADDR
// end ;
52601: LD_VAR 0 2
52605: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
52606: LD_INT 0
52608: PPUSH
52609: PPUSH
52610: PPUSH
// if not mines then
52611: LD_VAR 0 2
52615: NOT
52616: IFFALSE 52620
// exit ;
52618: GO 52764
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52620: LD_ADDR_VAR 0 5
52624: PUSH
52625: LD_INT 81
52627: PUSH
52628: LD_VAR 0 1
52632: PUSH
52633: EMPTY
52634: LIST
52635: LIST
52636: PUSH
52637: LD_INT 3
52639: PUSH
52640: LD_INT 21
52642: PUSH
52643: LD_INT 3
52645: PUSH
52646: EMPTY
52647: LIST
52648: LIST
52649: PUSH
52650: EMPTY
52651: LIST
52652: LIST
52653: PUSH
52654: EMPTY
52655: LIST
52656: LIST
52657: PPUSH
52658: CALL_OW 69
52662: ST_TO_ADDR
// for i in mines do
52663: LD_ADDR_VAR 0 4
52667: PUSH
52668: LD_VAR 0 2
52672: PUSH
52673: FOR_IN
52674: IFFALSE 52762
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
52676: LD_VAR 0 4
52680: PUSH
52681: LD_INT 1
52683: ARRAY
52684: PPUSH
52685: LD_VAR 0 4
52689: PUSH
52690: LD_INT 2
52692: ARRAY
52693: PPUSH
52694: CALL_OW 458
52698: NOT
52699: IFFALSE 52703
// continue ;
52701: GO 52673
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
52703: LD_VAR 0 4
52707: PUSH
52708: LD_INT 1
52710: ARRAY
52711: PPUSH
52712: LD_VAR 0 4
52716: PUSH
52717: LD_INT 2
52719: ARRAY
52720: PPUSH
52721: CALL_OW 428
52725: PUSH
52726: LD_VAR 0 5
52730: IN
52731: IFFALSE 52760
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
52733: LD_VAR 0 4
52737: PUSH
52738: LD_INT 1
52740: ARRAY
52741: PPUSH
52742: LD_VAR 0 4
52746: PUSH
52747: LD_INT 2
52749: ARRAY
52750: PPUSH
52751: LD_VAR 0 1
52755: PPUSH
52756: CALL_OW 456
// end ;
52760: GO 52673
52762: POP
52763: POP
// end ;
52764: LD_VAR 0 3
52768: RET
// export function Count ( array ) ; var i ; begin
52769: LD_INT 0
52771: PPUSH
52772: PPUSH
// result := 0 ;
52773: LD_ADDR_VAR 0 2
52777: PUSH
52778: LD_INT 0
52780: ST_TO_ADDR
// for i in array do
52781: LD_ADDR_VAR 0 3
52785: PUSH
52786: LD_VAR 0 1
52790: PUSH
52791: FOR_IN
52792: IFFALSE 52816
// if i then
52794: LD_VAR 0 3
52798: IFFALSE 52814
// result := result + 1 ;
52800: LD_ADDR_VAR 0 2
52804: PUSH
52805: LD_VAR 0 2
52809: PUSH
52810: LD_INT 1
52812: PLUS
52813: ST_TO_ADDR
52814: GO 52791
52816: POP
52817: POP
// end ;
52818: LD_VAR 0 2
52822: RET
// export function IsEmpty ( building ) ; begin
52823: LD_INT 0
52825: PPUSH
// if not building then
52826: LD_VAR 0 1
52830: NOT
52831: IFFALSE 52835
// exit ;
52833: GO 52878
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
52835: LD_ADDR_VAR 0 2
52839: PUSH
52840: LD_VAR 0 1
52844: PUSH
52845: LD_INT 22
52847: PUSH
52848: LD_VAR 0 1
52852: PPUSH
52853: CALL_OW 255
52857: PUSH
52858: EMPTY
52859: LIST
52860: LIST
52861: PUSH
52862: LD_INT 58
52864: PUSH
52865: EMPTY
52866: LIST
52867: PUSH
52868: EMPTY
52869: LIST
52870: LIST
52871: PPUSH
52872: CALL_OW 69
52876: IN
52877: ST_TO_ADDR
// end ;
52878: LD_VAR 0 2
52882: RET
// export function IsNotFull ( building ) ; begin
52883: LD_INT 0
52885: PPUSH
// if not building then
52886: LD_VAR 0 1
52890: NOT
52891: IFFALSE 52895
// exit ;
52893: GO 52914
// result := UnitsInside ( building ) < 6 ;
52895: LD_ADDR_VAR 0 2
52899: PUSH
52900: LD_VAR 0 1
52904: PPUSH
52905: CALL_OW 313
52909: PUSH
52910: LD_INT 6
52912: LESS
52913: ST_TO_ADDR
// end ;
52914: LD_VAR 0 2
52918: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
52919: LD_INT 0
52921: PPUSH
52922: PPUSH
52923: PPUSH
52924: PPUSH
// tmp := [ ] ;
52925: LD_ADDR_VAR 0 3
52929: PUSH
52930: EMPTY
52931: ST_TO_ADDR
// list := [ ] ;
52932: LD_ADDR_VAR 0 5
52936: PUSH
52937: EMPTY
52938: ST_TO_ADDR
// for i = 16 to 25 do
52939: LD_ADDR_VAR 0 4
52943: PUSH
52944: DOUBLE
52945: LD_INT 16
52947: DEC
52948: ST_TO_ADDR
52949: LD_INT 25
52951: PUSH
52952: FOR_TO
52953: IFFALSE 53026
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
52955: LD_ADDR_VAR 0 3
52959: PUSH
52960: LD_VAR 0 3
52964: PUSH
52965: LD_INT 22
52967: PUSH
52968: LD_VAR 0 1
52972: PPUSH
52973: CALL_OW 255
52977: PUSH
52978: EMPTY
52979: LIST
52980: LIST
52981: PUSH
52982: LD_INT 91
52984: PUSH
52985: LD_VAR 0 1
52989: PUSH
52990: LD_INT 6
52992: PUSH
52993: EMPTY
52994: LIST
52995: LIST
52996: LIST
52997: PUSH
52998: LD_INT 30
53000: PUSH
53001: LD_VAR 0 4
53005: PUSH
53006: EMPTY
53007: LIST
53008: LIST
53009: PUSH
53010: EMPTY
53011: LIST
53012: LIST
53013: LIST
53014: PUSH
53015: EMPTY
53016: LIST
53017: PPUSH
53018: CALL_OW 69
53022: ADD
53023: ST_TO_ADDR
53024: GO 52952
53026: POP
53027: POP
// for i = 1 to tmp do
53028: LD_ADDR_VAR 0 4
53032: PUSH
53033: DOUBLE
53034: LD_INT 1
53036: DEC
53037: ST_TO_ADDR
53038: LD_VAR 0 3
53042: PUSH
53043: FOR_TO
53044: IFFALSE 53132
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53046: LD_ADDR_VAR 0 5
53050: PUSH
53051: LD_VAR 0 5
53055: PUSH
53056: LD_VAR 0 3
53060: PUSH
53061: LD_VAR 0 4
53065: ARRAY
53066: PPUSH
53067: CALL_OW 266
53071: PUSH
53072: LD_VAR 0 3
53076: PUSH
53077: LD_VAR 0 4
53081: ARRAY
53082: PPUSH
53083: CALL_OW 250
53087: PUSH
53088: LD_VAR 0 3
53092: PUSH
53093: LD_VAR 0 4
53097: ARRAY
53098: PPUSH
53099: CALL_OW 251
53103: PUSH
53104: LD_VAR 0 3
53108: PUSH
53109: LD_VAR 0 4
53113: ARRAY
53114: PPUSH
53115: CALL_OW 254
53119: PUSH
53120: EMPTY
53121: LIST
53122: LIST
53123: LIST
53124: LIST
53125: PUSH
53126: EMPTY
53127: LIST
53128: ADD
53129: ST_TO_ADDR
53130: GO 53043
53132: POP
53133: POP
// result := list ;
53134: LD_ADDR_VAR 0 2
53138: PUSH
53139: LD_VAR 0 5
53143: ST_TO_ADDR
// end ;
53144: LD_VAR 0 2
53148: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53149: LD_INT 0
53151: PPUSH
53152: PPUSH
53153: PPUSH
53154: PPUSH
53155: PPUSH
53156: PPUSH
53157: PPUSH
// if not factory then
53158: LD_VAR 0 1
53162: NOT
53163: IFFALSE 53167
// exit ;
53165: GO 53760
// if control = control_apeman then
53167: LD_VAR 0 4
53171: PUSH
53172: LD_INT 5
53174: EQUAL
53175: IFFALSE 53284
// begin tmp := UnitsInside ( factory ) ;
53177: LD_ADDR_VAR 0 8
53181: PUSH
53182: LD_VAR 0 1
53186: PPUSH
53187: CALL_OW 313
53191: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53192: LD_VAR 0 8
53196: PPUSH
53197: LD_INT 25
53199: PUSH
53200: LD_INT 12
53202: PUSH
53203: EMPTY
53204: LIST
53205: LIST
53206: PPUSH
53207: CALL_OW 72
53211: NOT
53212: IFFALSE 53222
// control := control_manual ;
53214: LD_ADDR_VAR 0 4
53218: PUSH
53219: LD_INT 1
53221: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53222: LD_ADDR_VAR 0 8
53226: PUSH
53227: LD_VAR 0 1
53231: PPUSH
53232: CALL 52919 0 1
53236: ST_TO_ADDR
// if tmp then
53237: LD_VAR 0 8
53241: IFFALSE 53284
// begin for i in tmp do
53243: LD_ADDR_VAR 0 7
53247: PUSH
53248: LD_VAR 0 8
53252: PUSH
53253: FOR_IN
53254: IFFALSE 53282
// if i [ 1 ] = b_ext_radio then
53256: LD_VAR 0 7
53260: PUSH
53261: LD_INT 1
53263: ARRAY
53264: PUSH
53265: LD_INT 22
53267: EQUAL
53268: IFFALSE 53280
// begin control := control_remote ;
53270: LD_ADDR_VAR 0 4
53274: PUSH
53275: LD_INT 2
53277: ST_TO_ADDR
// break ;
53278: GO 53282
// end ;
53280: GO 53253
53282: POP
53283: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53284: LD_VAR 0 1
53288: PPUSH
53289: LD_VAR 0 2
53293: PPUSH
53294: LD_VAR 0 3
53298: PPUSH
53299: LD_VAR 0 4
53303: PPUSH
53304: LD_VAR 0 5
53308: PPUSH
53309: CALL_OW 448
53313: IFFALSE 53348
// begin result := [ chassis , engine , control , weapon ] ;
53315: LD_ADDR_VAR 0 6
53319: PUSH
53320: LD_VAR 0 2
53324: PUSH
53325: LD_VAR 0 3
53329: PUSH
53330: LD_VAR 0 4
53334: PUSH
53335: LD_VAR 0 5
53339: PUSH
53340: EMPTY
53341: LIST
53342: LIST
53343: LIST
53344: LIST
53345: ST_TO_ADDR
// exit ;
53346: GO 53760
// end ; _chassis := AvailableChassisList ( factory ) ;
53348: LD_ADDR_VAR 0 9
53352: PUSH
53353: LD_VAR 0 1
53357: PPUSH
53358: CALL_OW 475
53362: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53363: LD_ADDR_VAR 0 11
53367: PUSH
53368: LD_VAR 0 1
53372: PPUSH
53373: CALL_OW 476
53377: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53378: LD_ADDR_VAR 0 12
53382: PUSH
53383: LD_VAR 0 1
53387: PPUSH
53388: CALL_OW 477
53392: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53393: LD_ADDR_VAR 0 10
53397: PUSH
53398: LD_VAR 0 1
53402: PPUSH
53403: CALL_OW 478
53407: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53408: LD_VAR 0 9
53412: NOT
53413: PUSH
53414: LD_VAR 0 11
53418: NOT
53419: OR
53420: PUSH
53421: LD_VAR 0 12
53425: NOT
53426: OR
53427: PUSH
53428: LD_VAR 0 10
53432: NOT
53433: OR
53434: IFFALSE 53469
// begin result := [ chassis , engine , control , weapon ] ;
53436: LD_ADDR_VAR 0 6
53440: PUSH
53441: LD_VAR 0 2
53445: PUSH
53446: LD_VAR 0 3
53450: PUSH
53451: LD_VAR 0 4
53455: PUSH
53456: LD_VAR 0 5
53460: PUSH
53461: EMPTY
53462: LIST
53463: LIST
53464: LIST
53465: LIST
53466: ST_TO_ADDR
// exit ;
53467: GO 53760
// end ; if not chassis in _chassis then
53469: LD_VAR 0 2
53473: PUSH
53474: LD_VAR 0 9
53478: IN
53479: NOT
53480: IFFALSE 53506
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
53482: LD_ADDR_VAR 0 2
53486: PUSH
53487: LD_VAR 0 9
53491: PUSH
53492: LD_INT 1
53494: PPUSH
53495: LD_VAR 0 9
53499: PPUSH
53500: CALL_OW 12
53504: ARRAY
53505: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
53506: LD_VAR 0 2
53510: PPUSH
53511: LD_VAR 0 3
53515: PPUSH
53516: CALL 53765 0 2
53520: NOT
53521: IFFALSE 53580
// repeat engine := _engine [ 1 ] ;
53523: LD_ADDR_VAR 0 3
53527: PUSH
53528: LD_VAR 0 11
53532: PUSH
53533: LD_INT 1
53535: ARRAY
53536: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
53537: LD_ADDR_VAR 0 11
53541: PUSH
53542: LD_VAR 0 11
53546: PPUSH
53547: LD_INT 1
53549: PPUSH
53550: CALL_OW 3
53554: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
53555: LD_VAR 0 2
53559: PPUSH
53560: LD_VAR 0 3
53564: PPUSH
53565: CALL 53765 0 2
53569: PUSH
53570: LD_VAR 0 11
53574: PUSH
53575: EMPTY
53576: EQUAL
53577: OR
53578: IFFALSE 53523
// if not control in _control then
53580: LD_VAR 0 4
53584: PUSH
53585: LD_VAR 0 12
53589: IN
53590: NOT
53591: IFFALSE 53617
// control := _control [ rand ( 1 , _control ) ] ;
53593: LD_ADDR_VAR 0 4
53597: PUSH
53598: LD_VAR 0 12
53602: PUSH
53603: LD_INT 1
53605: PPUSH
53606: LD_VAR 0 12
53610: PPUSH
53611: CALL_OW 12
53615: ARRAY
53616: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
53617: LD_VAR 0 2
53621: PPUSH
53622: LD_VAR 0 5
53626: PPUSH
53627: CALL 53985 0 2
53631: NOT
53632: IFFALSE 53691
// repeat weapon := _weapon [ 1 ] ;
53634: LD_ADDR_VAR 0 5
53638: PUSH
53639: LD_VAR 0 10
53643: PUSH
53644: LD_INT 1
53646: ARRAY
53647: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
53648: LD_ADDR_VAR 0 10
53652: PUSH
53653: LD_VAR 0 10
53657: PPUSH
53658: LD_INT 1
53660: PPUSH
53661: CALL_OW 3
53665: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
53666: LD_VAR 0 2
53670: PPUSH
53671: LD_VAR 0 5
53675: PPUSH
53676: CALL 53985 0 2
53680: PUSH
53681: LD_VAR 0 10
53685: PUSH
53686: EMPTY
53687: EQUAL
53688: OR
53689: IFFALSE 53634
// result := [ ] ;
53691: LD_ADDR_VAR 0 6
53695: PUSH
53696: EMPTY
53697: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53698: LD_VAR 0 1
53702: PPUSH
53703: LD_VAR 0 2
53707: PPUSH
53708: LD_VAR 0 3
53712: PPUSH
53713: LD_VAR 0 4
53717: PPUSH
53718: LD_VAR 0 5
53722: PPUSH
53723: CALL_OW 448
53727: IFFALSE 53760
// result := [ chassis , engine , control , weapon ] ;
53729: LD_ADDR_VAR 0 6
53733: PUSH
53734: LD_VAR 0 2
53738: PUSH
53739: LD_VAR 0 3
53743: PUSH
53744: LD_VAR 0 4
53748: PUSH
53749: LD_VAR 0 5
53753: PUSH
53754: EMPTY
53755: LIST
53756: LIST
53757: LIST
53758: LIST
53759: ST_TO_ADDR
// end ;
53760: LD_VAR 0 6
53764: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
53765: LD_INT 0
53767: PPUSH
// if not chassis or not engine then
53768: LD_VAR 0 1
53772: NOT
53773: PUSH
53774: LD_VAR 0 2
53778: NOT
53779: OR
53780: IFFALSE 53784
// exit ;
53782: GO 53980
// case engine of engine_solar :
53784: LD_VAR 0 2
53788: PUSH
53789: LD_INT 2
53791: DOUBLE
53792: EQUAL
53793: IFTRUE 53797
53795: GO 53835
53797: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
53798: LD_ADDR_VAR 0 3
53802: PUSH
53803: LD_INT 11
53805: PUSH
53806: LD_INT 12
53808: PUSH
53809: LD_INT 13
53811: PUSH
53812: LD_INT 14
53814: PUSH
53815: LD_INT 1
53817: PUSH
53818: LD_INT 2
53820: PUSH
53821: LD_INT 3
53823: PUSH
53824: EMPTY
53825: LIST
53826: LIST
53827: LIST
53828: LIST
53829: LIST
53830: LIST
53831: LIST
53832: ST_TO_ADDR
53833: GO 53964
53835: LD_INT 1
53837: DOUBLE
53838: EQUAL
53839: IFTRUE 53843
53841: GO 53905
53843: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
53844: LD_ADDR_VAR 0 3
53848: PUSH
53849: LD_INT 11
53851: PUSH
53852: LD_INT 12
53854: PUSH
53855: LD_INT 13
53857: PUSH
53858: LD_INT 14
53860: PUSH
53861: LD_INT 1
53863: PUSH
53864: LD_INT 2
53866: PUSH
53867: LD_INT 3
53869: PUSH
53870: LD_INT 4
53872: PUSH
53873: LD_INT 5
53875: PUSH
53876: LD_INT 21
53878: PUSH
53879: LD_INT 23
53881: PUSH
53882: LD_INT 22
53884: PUSH
53885: LD_INT 24
53887: PUSH
53888: EMPTY
53889: LIST
53890: LIST
53891: LIST
53892: LIST
53893: LIST
53894: LIST
53895: LIST
53896: LIST
53897: LIST
53898: LIST
53899: LIST
53900: LIST
53901: LIST
53902: ST_TO_ADDR
53903: GO 53964
53905: LD_INT 3
53907: DOUBLE
53908: EQUAL
53909: IFTRUE 53913
53911: GO 53963
53913: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53914: LD_ADDR_VAR 0 3
53918: PUSH
53919: LD_INT 13
53921: PUSH
53922: LD_INT 14
53924: PUSH
53925: LD_INT 2
53927: PUSH
53928: LD_INT 3
53930: PUSH
53931: LD_INT 4
53933: PUSH
53934: LD_INT 5
53936: PUSH
53937: LD_INT 21
53939: PUSH
53940: LD_INT 22
53942: PUSH
53943: LD_INT 23
53945: PUSH
53946: LD_INT 24
53948: PUSH
53949: EMPTY
53950: LIST
53951: LIST
53952: LIST
53953: LIST
53954: LIST
53955: LIST
53956: LIST
53957: LIST
53958: LIST
53959: LIST
53960: ST_TO_ADDR
53961: GO 53964
53963: POP
// result := ( chassis in result ) ;
53964: LD_ADDR_VAR 0 3
53968: PUSH
53969: LD_VAR 0 1
53973: PUSH
53974: LD_VAR 0 3
53978: IN
53979: ST_TO_ADDR
// end ;
53980: LD_VAR 0 3
53984: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
53985: LD_INT 0
53987: PPUSH
// if not chassis or not weapon then
53988: LD_VAR 0 1
53992: NOT
53993: PUSH
53994: LD_VAR 0 2
53998: NOT
53999: OR
54000: IFFALSE 54004
// exit ;
54002: GO 55030
// case weapon of us_machine_gun :
54004: LD_VAR 0 2
54008: PUSH
54009: LD_INT 2
54011: DOUBLE
54012: EQUAL
54013: IFTRUE 54017
54015: GO 54047
54017: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54018: LD_ADDR_VAR 0 3
54022: PUSH
54023: LD_INT 1
54025: PUSH
54026: LD_INT 2
54028: PUSH
54029: LD_INT 3
54031: PUSH
54032: LD_INT 4
54034: PUSH
54035: LD_INT 5
54037: PUSH
54038: EMPTY
54039: LIST
54040: LIST
54041: LIST
54042: LIST
54043: LIST
54044: ST_TO_ADDR
54045: GO 55014
54047: LD_INT 3
54049: DOUBLE
54050: EQUAL
54051: IFTRUE 54055
54053: GO 54085
54055: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54056: LD_ADDR_VAR 0 3
54060: PUSH
54061: LD_INT 1
54063: PUSH
54064: LD_INT 2
54066: PUSH
54067: LD_INT 3
54069: PUSH
54070: LD_INT 4
54072: PUSH
54073: LD_INT 5
54075: PUSH
54076: EMPTY
54077: LIST
54078: LIST
54079: LIST
54080: LIST
54081: LIST
54082: ST_TO_ADDR
54083: GO 55014
54085: LD_INT 11
54087: DOUBLE
54088: EQUAL
54089: IFTRUE 54093
54091: GO 54123
54093: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54094: LD_ADDR_VAR 0 3
54098: PUSH
54099: LD_INT 1
54101: PUSH
54102: LD_INT 2
54104: PUSH
54105: LD_INT 3
54107: PUSH
54108: LD_INT 4
54110: PUSH
54111: LD_INT 5
54113: PUSH
54114: EMPTY
54115: LIST
54116: LIST
54117: LIST
54118: LIST
54119: LIST
54120: ST_TO_ADDR
54121: GO 55014
54123: LD_INT 4
54125: DOUBLE
54126: EQUAL
54127: IFTRUE 54131
54129: GO 54157
54131: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54132: LD_ADDR_VAR 0 3
54136: PUSH
54137: LD_INT 2
54139: PUSH
54140: LD_INT 3
54142: PUSH
54143: LD_INT 4
54145: PUSH
54146: LD_INT 5
54148: PUSH
54149: EMPTY
54150: LIST
54151: LIST
54152: LIST
54153: LIST
54154: ST_TO_ADDR
54155: GO 55014
54157: LD_INT 5
54159: DOUBLE
54160: EQUAL
54161: IFTRUE 54165
54163: GO 54191
54165: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54166: LD_ADDR_VAR 0 3
54170: PUSH
54171: LD_INT 2
54173: PUSH
54174: LD_INT 3
54176: PUSH
54177: LD_INT 4
54179: PUSH
54180: LD_INT 5
54182: PUSH
54183: EMPTY
54184: LIST
54185: LIST
54186: LIST
54187: LIST
54188: ST_TO_ADDR
54189: GO 55014
54191: LD_INT 9
54193: DOUBLE
54194: EQUAL
54195: IFTRUE 54199
54197: GO 54225
54199: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54200: LD_ADDR_VAR 0 3
54204: PUSH
54205: LD_INT 2
54207: PUSH
54208: LD_INT 3
54210: PUSH
54211: LD_INT 4
54213: PUSH
54214: LD_INT 5
54216: PUSH
54217: EMPTY
54218: LIST
54219: LIST
54220: LIST
54221: LIST
54222: ST_TO_ADDR
54223: GO 55014
54225: LD_INT 7
54227: DOUBLE
54228: EQUAL
54229: IFTRUE 54233
54231: GO 54259
54233: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54234: LD_ADDR_VAR 0 3
54238: PUSH
54239: LD_INT 2
54241: PUSH
54242: LD_INT 3
54244: PUSH
54245: LD_INT 4
54247: PUSH
54248: LD_INT 5
54250: PUSH
54251: EMPTY
54252: LIST
54253: LIST
54254: LIST
54255: LIST
54256: ST_TO_ADDR
54257: GO 55014
54259: LD_INT 12
54261: DOUBLE
54262: EQUAL
54263: IFTRUE 54267
54265: GO 54293
54267: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54268: LD_ADDR_VAR 0 3
54272: PUSH
54273: LD_INT 2
54275: PUSH
54276: LD_INT 3
54278: PUSH
54279: LD_INT 4
54281: PUSH
54282: LD_INT 5
54284: PUSH
54285: EMPTY
54286: LIST
54287: LIST
54288: LIST
54289: LIST
54290: ST_TO_ADDR
54291: GO 55014
54293: LD_INT 13
54295: DOUBLE
54296: EQUAL
54297: IFTRUE 54301
54299: GO 54327
54301: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54302: LD_ADDR_VAR 0 3
54306: PUSH
54307: LD_INT 2
54309: PUSH
54310: LD_INT 3
54312: PUSH
54313: LD_INT 4
54315: PUSH
54316: LD_INT 5
54318: PUSH
54319: EMPTY
54320: LIST
54321: LIST
54322: LIST
54323: LIST
54324: ST_TO_ADDR
54325: GO 55014
54327: LD_INT 14
54329: DOUBLE
54330: EQUAL
54331: IFTRUE 54335
54333: GO 54353
54335: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54336: LD_ADDR_VAR 0 3
54340: PUSH
54341: LD_INT 4
54343: PUSH
54344: LD_INT 5
54346: PUSH
54347: EMPTY
54348: LIST
54349: LIST
54350: ST_TO_ADDR
54351: GO 55014
54353: LD_INT 6
54355: DOUBLE
54356: EQUAL
54357: IFTRUE 54361
54359: GO 54379
54361: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54362: LD_ADDR_VAR 0 3
54366: PUSH
54367: LD_INT 4
54369: PUSH
54370: LD_INT 5
54372: PUSH
54373: EMPTY
54374: LIST
54375: LIST
54376: ST_TO_ADDR
54377: GO 55014
54379: LD_INT 10
54381: DOUBLE
54382: EQUAL
54383: IFTRUE 54387
54385: GO 54405
54387: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54388: LD_ADDR_VAR 0 3
54392: PUSH
54393: LD_INT 4
54395: PUSH
54396: LD_INT 5
54398: PUSH
54399: EMPTY
54400: LIST
54401: LIST
54402: ST_TO_ADDR
54403: GO 55014
54405: LD_INT 22
54407: DOUBLE
54408: EQUAL
54409: IFTRUE 54413
54411: GO 54439
54413: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54414: LD_ADDR_VAR 0 3
54418: PUSH
54419: LD_INT 11
54421: PUSH
54422: LD_INT 12
54424: PUSH
54425: LD_INT 13
54427: PUSH
54428: LD_INT 14
54430: PUSH
54431: EMPTY
54432: LIST
54433: LIST
54434: LIST
54435: LIST
54436: ST_TO_ADDR
54437: GO 55014
54439: LD_INT 23
54441: DOUBLE
54442: EQUAL
54443: IFTRUE 54447
54445: GO 54473
54447: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54448: LD_ADDR_VAR 0 3
54452: PUSH
54453: LD_INT 11
54455: PUSH
54456: LD_INT 12
54458: PUSH
54459: LD_INT 13
54461: PUSH
54462: LD_INT 14
54464: PUSH
54465: EMPTY
54466: LIST
54467: LIST
54468: LIST
54469: LIST
54470: ST_TO_ADDR
54471: GO 55014
54473: LD_INT 24
54475: DOUBLE
54476: EQUAL
54477: IFTRUE 54481
54479: GO 54507
54481: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
54482: LD_ADDR_VAR 0 3
54486: PUSH
54487: LD_INT 11
54489: PUSH
54490: LD_INT 12
54492: PUSH
54493: LD_INT 13
54495: PUSH
54496: LD_INT 14
54498: PUSH
54499: EMPTY
54500: LIST
54501: LIST
54502: LIST
54503: LIST
54504: ST_TO_ADDR
54505: GO 55014
54507: LD_INT 30
54509: DOUBLE
54510: EQUAL
54511: IFTRUE 54515
54513: GO 54541
54515: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
54516: LD_ADDR_VAR 0 3
54520: PUSH
54521: LD_INT 11
54523: PUSH
54524: LD_INT 12
54526: PUSH
54527: LD_INT 13
54529: PUSH
54530: LD_INT 14
54532: PUSH
54533: EMPTY
54534: LIST
54535: LIST
54536: LIST
54537: LIST
54538: ST_TO_ADDR
54539: GO 55014
54541: LD_INT 25
54543: DOUBLE
54544: EQUAL
54545: IFTRUE 54549
54547: GO 54567
54549: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
54550: LD_ADDR_VAR 0 3
54554: PUSH
54555: LD_INT 13
54557: PUSH
54558: LD_INT 14
54560: PUSH
54561: EMPTY
54562: LIST
54563: LIST
54564: ST_TO_ADDR
54565: GO 55014
54567: LD_INT 27
54569: DOUBLE
54570: EQUAL
54571: IFTRUE 54575
54573: GO 54593
54575: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
54576: LD_ADDR_VAR 0 3
54580: PUSH
54581: LD_INT 13
54583: PUSH
54584: LD_INT 14
54586: PUSH
54587: EMPTY
54588: LIST
54589: LIST
54590: ST_TO_ADDR
54591: GO 55014
54593: LD_INT 28
54595: DOUBLE
54596: EQUAL
54597: IFTRUE 54601
54599: GO 54619
54601: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
54602: LD_ADDR_VAR 0 3
54606: PUSH
54607: LD_INT 13
54609: PUSH
54610: LD_INT 14
54612: PUSH
54613: EMPTY
54614: LIST
54615: LIST
54616: ST_TO_ADDR
54617: GO 55014
54619: LD_INT 29
54621: DOUBLE
54622: EQUAL
54623: IFTRUE 54627
54625: GO 54645
54627: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
54628: LD_ADDR_VAR 0 3
54632: PUSH
54633: LD_INT 13
54635: PUSH
54636: LD_INT 14
54638: PUSH
54639: EMPTY
54640: LIST
54641: LIST
54642: ST_TO_ADDR
54643: GO 55014
54645: LD_INT 31
54647: DOUBLE
54648: EQUAL
54649: IFTRUE 54653
54651: GO 54671
54653: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
54654: LD_ADDR_VAR 0 3
54658: PUSH
54659: LD_INT 13
54661: PUSH
54662: LD_INT 14
54664: PUSH
54665: EMPTY
54666: LIST
54667: LIST
54668: ST_TO_ADDR
54669: GO 55014
54671: LD_INT 26
54673: DOUBLE
54674: EQUAL
54675: IFTRUE 54679
54677: GO 54697
54679: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
54680: LD_ADDR_VAR 0 3
54684: PUSH
54685: LD_INT 13
54687: PUSH
54688: LD_INT 14
54690: PUSH
54691: EMPTY
54692: LIST
54693: LIST
54694: ST_TO_ADDR
54695: GO 55014
54697: LD_INT 42
54699: DOUBLE
54700: EQUAL
54701: IFTRUE 54705
54703: GO 54731
54705: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
54706: LD_ADDR_VAR 0 3
54710: PUSH
54711: LD_INT 21
54713: PUSH
54714: LD_INT 22
54716: PUSH
54717: LD_INT 23
54719: PUSH
54720: LD_INT 24
54722: PUSH
54723: EMPTY
54724: LIST
54725: LIST
54726: LIST
54727: LIST
54728: ST_TO_ADDR
54729: GO 55014
54731: LD_INT 43
54733: DOUBLE
54734: EQUAL
54735: IFTRUE 54739
54737: GO 54765
54739: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
54740: LD_ADDR_VAR 0 3
54744: PUSH
54745: LD_INT 21
54747: PUSH
54748: LD_INT 22
54750: PUSH
54751: LD_INT 23
54753: PUSH
54754: LD_INT 24
54756: PUSH
54757: EMPTY
54758: LIST
54759: LIST
54760: LIST
54761: LIST
54762: ST_TO_ADDR
54763: GO 55014
54765: LD_INT 44
54767: DOUBLE
54768: EQUAL
54769: IFTRUE 54773
54771: GO 54799
54773: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
54774: LD_ADDR_VAR 0 3
54778: PUSH
54779: LD_INT 21
54781: PUSH
54782: LD_INT 22
54784: PUSH
54785: LD_INT 23
54787: PUSH
54788: LD_INT 24
54790: PUSH
54791: EMPTY
54792: LIST
54793: LIST
54794: LIST
54795: LIST
54796: ST_TO_ADDR
54797: GO 55014
54799: LD_INT 45
54801: DOUBLE
54802: EQUAL
54803: IFTRUE 54807
54805: GO 54833
54807: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
54808: LD_ADDR_VAR 0 3
54812: PUSH
54813: LD_INT 21
54815: PUSH
54816: LD_INT 22
54818: PUSH
54819: LD_INT 23
54821: PUSH
54822: LD_INT 24
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: LIST
54829: LIST
54830: ST_TO_ADDR
54831: GO 55014
54833: LD_INT 49
54835: DOUBLE
54836: EQUAL
54837: IFTRUE 54841
54839: GO 54867
54841: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
54842: LD_ADDR_VAR 0 3
54846: PUSH
54847: LD_INT 21
54849: PUSH
54850: LD_INT 22
54852: PUSH
54853: LD_INT 23
54855: PUSH
54856: LD_INT 24
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: LIST
54863: LIST
54864: ST_TO_ADDR
54865: GO 55014
54867: LD_INT 51
54869: DOUBLE
54870: EQUAL
54871: IFTRUE 54875
54873: GO 54901
54875: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
54876: LD_ADDR_VAR 0 3
54880: PUSH
54881: LD_INT 21
54883: PUSH
54884: LD_INT 22
54886: PUSH
54887: LD_INT 23
54889: PUSH
54890: LD_INT 24
54892: PUSH
54893: EMPTY
54894: LIST
54895: LIST
54896: LIST
54897: LIST
54898: ST_TO_ADDR
54899: GO 55014
54901: LD_INT 52
54903: DOUBLE
54904: EQUAL
54905: IFTRUE 54909
54907: GO 54935
54909: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
54910: LD_ADDR_VAR 0 3
54914: PUSH
54915: LD_INT 21
54917: PUSH
54918: LD_INT 22
54920: PUSH
54921: LD_INT 23
54923: PUSH
54924: LD_INT 24
54926: PUSH
54927: EMPTY
54928: LIST
54929: LIST
54930: LIST
54931: LIST
54932: ST_TO_ADDR
54933: GO 55014
54935: LD_INT 53
54937: DOUBLE
54938: EQUAL
54939: IFTRUE 54943
54941: GO 54961
54943: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
54944: LD_ADDR_VAR 0 3
54948: PUSH
54949: LD_INT 23
54951: PUSH
54952: LD_INT 24
54954: PUSH
54955: EMPTY
54956: LIST
54957: LIST
54958: ST_TO_ADDR
54959: GO 55014
54961: LD_INT 46
54963: DOUBLE
54964: EQUAL
54965: IFTRUE 54969
54967: GO 54987
54969: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
54970: LD_ADDR_VAR 0 3
54974: PUSH
54975: LD_INT 23
54977: PUSH
54978: LD_INT 24
54980: PUSH
54981: EMPTY
54982: LIST
54983: LIST
54984: ST_TO_ADDR
54985: GO 55014
54987: LD_INT 47
54989: DOUBLE
54990: EQUAL
54991: IFTRUE 54995
54993: GO 55013
54995: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54996: LD_ADDR_VAR 0 3
55000: PUSH
55001: LD_INT 23
55003: PUSH
55004: LD_INT 24
55006: PUSH
55007: EMPTY
55008: LIST
55009: LIST
55010: ST_TO_ADDR
55011: GO 55014
55013: POP
// result := ( chassis in result ) ;
55014: LD_ADDR_VAR 0 3
55018: PUSH
55019: LD_VAR 0 1
55023: PUSH
55024: LD_VAR 0 3
55028: IN
55029: ST_TO_ADDR
// end ;
55030: LD_VAR 0 3
55034: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55035: LD_INT 0
55037: PPUSH
55038: PPUSH
55039: PPUSH
55040: PPUSH
55041: PPUSH
55042: PPUSH
55043: PPUSH
// result := array ;
55044: LD_ADDR_VAR 0 5
55048: PUSH
55049: LD_VAR 0 1
55053: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55054: LD_VAR 0 1
55058: NOT
55059: PUSH
55060: LD_VAR 0 2
55064: NOT
55065: OR
55066: PUSH
55067: LD_VAR 0 3
55071: NOT
55072: OR
55073: PUSH
55074: LD_VAR 0 2
55078: PUSH
55079: LD_VAR 0 1
55083: GREATER
55084: OR
55085: PUSH
55086: LD_VAR 0 3
55090: PUSH
55091: LD_VAR 0 1
55095: GREATER
55096: OR
55097: IFFALSE 55101
// exit ;
55099: GO 55397
// if direction then
55101: LD_VAR 0 4
55105: IFFALSE 55169
// begin d := 1 ;
55107: LD_ADDR_VAR 0 9
55111: PUSH
55112: LD_INT 1
55114: ST_TO_ADDR
// if i_from > i_to then
55115: LD_VAR 0 2
55119: PUSH
55120: LD_VAR 0 3
55124: GREATER
55125: IFFALSE 55151
// length := ( array - i_from ) + i_to else
55127: LD_ADDR_VAR 0 11
55131: PUSH
55132: LD_VAR 0 1
55136: PUSH
55137: LD_VAR 0 2
55141: MINUS
55142: PUSH
55143: LD_VAR 0 3
55147: PLUS
55148: ST_TO_ADDR
55149: GO 55167
// length := i_to - i_from ;
55151: LD_ADDR_VAR 0 11
55155: PUSH
55156: LD_VAR 0 3
55160: PUSH
55161: LD_VAR 0 2
55165: MINUS
55166: ST_TO_ADDR
// end else
55167: GO 55230
// begin d := - 1 ;
55169: LD_ADDR_VAR 0 9
55173: PUSH
55174: LD_INT 1
55176: NEG
55177: ST_TO_ADDR
// if i_from > i_to then
55178: LD_VAR 0 2
55182: PUSH
55183: LD_VAR 0 3
55187: GREATER
55188: IFFALSE 55208
// length := i_from - i_to else
55190: LD_ADDR_VAR 0 11
55194: PUSH
55195: LD_VAR 0 2
55199: PUSH
55200: LD_VAR 0 3
55204: MINUS
55205: ST_TO_ADDR
55206: GO 55230
// length := ( array - i_to ) + i_from ;
55208: LD_ADDR_VAR 0 11
55212: PUSH
55213: LD_VAR 0 1
55217: PUSH
55218: LD_VAR 0 3
55222: MINUS
55223: PUSH
55224: LD_VAR 0 2
55228: PLUS
55229: ST_TO_ADDR
// end ; if not length then
55230: LD_VAR 0 11
55234: NOT
55235: IFFALSE 55239
// exit ;
55237: GO 55397
// tmp := array ;
55239: LD_ADDR_VAR 0 10
55243: PUSH
55244: LD_VAR 0 1
55248: ST_TO_ADDR
// for i = 1 to length do
55249: LD_ADDR_VAR 0 6
55253: PUSH
55254: DOUBLE
55255: LD_INT 1
55257: DEC
55258: ST_TO_ADDR
55259: LD_VAR 0 11
55263: PUSH
55264: FOR_TO
55265: IFFALSE 55385
// begin for j = 1 to array do
55267: LD_ADDR_VAR 0 7
55271: PUSH
55272: DOUBLE
55273: LD_INT 1
55275: DEC
55276: ST_TO_ADDR
55277: LD_VAR 0 1
55281: PUSH
55282: FOR_TO
55283: IFFALSE 55371
// begin k := j + d ;
55285: LD_ADDR_VAR 0 8
55289: PUSH
55290: LD_VAR 0 7
55294: PUSH
55295: LD_VAR 0 9
55299: PLUS
55300: ST_TO_ADDR
// if k > array then
55301: LD_VAR 0 8
55305: PUSH
55306: LD_VAR 0 1
55310: GREATER
55311: IFFALSE 55321
// k := 1 ;
55313: LD_ADDR_VAR 0 8
55317: PUSH
55318: LD_INT 1
55320: ST_TO_ADDR
// if not k then
55321: LD_VAR 0 8
55325: NOT
55326: IFFALSE 55338
// k := array ;
55328: LD_ADDR_VAR 0 8
55332: PUSH
55333: LD_VAR 0 1
55337: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55338: LD_ADDR_VAR 0 10
55342: PUSH
55343: LD_VAR 0 10
55347: PPUSH
55348: LD_VAR 0 8
55352: PPUSH
55353: LD_VAR 0 1
55357: PUSH
55358: LD_VAR 0 7
55362: ARRAY
55363: PPUSH
55364: CALL_OW 1
55368: ST_TO_ADDR
// end ;
55369: GO 55282
55371: POP
55372: POP
// array := tmp ;
55373: LD_ADDR_VAR 0 1
55377: PUSH
55378: LD_VAR 0 10
55382: ST_TO_ADDR
// end ;
55383: GO 55264
55385: POP
55386: POP
// result := array ;
55387: LD_ADDR_VAR 0 5
55391: PUSH
55392: LD_VAR 0 1
55396: ST_TO_ADDR
// end ;
55397: LD_VAR 0 5
55401: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55402: LD_INT 0
55404: PPUSH
55405: PPUSH
// result := 0 ;
55406: LD_ADDR_VAR 0 3
55410: PUSH
55411: LD_INT 0
55413: ST_TO_ADDR
// if not array or not value in array then
55414: LD_VAR 0 1
55418: NOT
55419: PUSH
55420: LD_VAR 0 2
55424: PUSH
55425: LD_VAR 0 1
55429: IN
55430: NOT
55431: OR
55432: IFFALSE 55436
// exit ;
55434: GO 55490
// for i = 1 to array do
55436: LD_ADDR_VAR 0 4
55440: PUSH
55441: DOUBLE
55442: LD_INT 1
55444: DEC
55445: ST_TO_ADDR
55446: LD_VAR 0 1
55450: PUSH
55451: FOR_TO
55452: IFFALSE 55488
// if value = array [ i ] then
55454: LD_VAR 0 2
55458: PUSH
55459: LD_VAR 0 1
55463: PUSH
55464: LD_VAR 0 4
55468: ARRAY
55469: EQUAL
55470: IFFALSE 55486
// begin result := i ;
55472: LD_ADDR_VAR 0 3
55476: PUSH
55477: LD_VAR 0 4
55481: ST_TO_ADDR
// exit ;
55482: POP
55483: POP
55484: GO 55490
// end ;
55486: GO 55451
55488: POP
55489: POP
// end ;
55490: LD_VAR 0 3
55494: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
55495: LD_INT 0
55497: PPUSH
// vc_chassis := chassis ;
55498: LD_ADDR_OWVAR 37
55502: PUSH
55503: LD_VAR 0 1
55507: ST_TO_ADDR
// vc_engine := engine ;
55508: LD_ADDR_OWVAR 39
55512: PUSH
55513: LD_VAR 0 2
55517: ST_TO_ADDR
// vc_control := control ;
55518: LD_ADDR_OWVAR 38
55522: PUSH
55523: LD_VAR 0 3
55527: ST_TO_ADDR
// vc_weapon := weapon ;
55528: LD_ADDR_OWVAR 40
55532: PUSH
55533: LD_VAR 0 4
55537: ST_TO_ADDR
// vc_fuel_battery := fuel ;
55538: LD_ADDR_OWVAR 41
55542: PUSH
55543: LD_VAR 0 5
55547: ST_TO_ADDR
// end ;
55548: LD_VAR 0 6
55552: RET
// export function WantPlant ( unit ) ; var task ; begin
55553: LD_INT 0
55555: PPUSH
55556: PPUSH
// result := false ;
55557: LD_ADDR_VAR 0 2
55561: PUSH
55562: LD_INT 0
55564: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
55565: LD_ADDR_VAR 0 3
55569: PUSH
55570: LD_VAR 0 1
55574: PPUSH
55575: CALL_OW 437
55579: ST_TO_ADDR
// if task then
55580: LD_VAR 0 3
55584: IFFALSE 55612
// if task [ 1 ] [ 1 ] = p then
55586: LD_VAR 0 3
55590: PUSH
55591: LD_INT 1
55593: ARRAY
55594: PUSH
55595: LD_INT 1
55597: ARRAY
55598: PUSH
55599: LD_STRING p
55601: EQUAL
55602: IFFALSE 55612
// result := true ;
55604: LD_ADDR_VAR 0 2
55608: PUSH
55609: LD_INT 1
55611: ST_TO_ADDR
// end ;
55612: LD_VAR 0 2
55616: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
55617: LD_INT 0
55619: PPUSH
55620: PPUSH
55621: PPUSH
55622: PPUSH
// if pos < 1 then
55623: LD_VAR 0 2
55627: PUSH
55628: LD_INT 1
55630: LESS
55631: IFFALSE 55635
// exit ;
55633: GO 55938
// if pos = 1 then
55635: LD_VAR 0 2
55639: PUSH
55640: LD_INT 1
55642: EQUAL
55643: IFFALSE 55676
// result := Replace ( arr , pos [ 1 ] , value ) else
55645: LD_ADDR_VAR 0 4
55649: PUSH
55650: LD_VAR 0 1
55654: PPUSH
55655: LD_VAR 0 2
55659: PUSH
55660: LD_INT 1
55662: ARRAY
55663: PPUSH
55664: LD_VAR 0 3
55668: PPUSH
55669: CALL_OW 1
55673: ST_TO_ADDR
55674: GO 55938
// begin tmp := arr ;
55676: LD_ADDR_VAR 0 6
55680: PUSH
55681: LD_VAR 0 1
55685: ST_TO_ADDR
// s_arr := [ tmp ] ;
55686: LD_ADDR_VAR 0 7
55690: PUSH
55691: LD_VAR 0 6
55695: PUSH
55696: EMPTY
55697: LIST
55698: ST_TO_ADDR
// for i = 1 to pos - 1 do
55699: LD_ADDR_VAR 0 5
55703: PUSH
55704: DOUBLE
55705: LD_INT 1
55707: DEC
55708: ST_TO_ADDR
55709: LD_VAR 0 2
55713: PUSH
55714: LD_INT 1
55716: MINUS
55717: PUSH
55718: FOR_TO
55719: IFFALSE 55764
// begin tmp := tmp [ pos [ i ] ] ;
55721: LD_ADDR_VAR 0 6
55725: PUSH
55726: LD_VAR 0 6
55730: PUSH
55731: LD_VAR 0 2
55735: PUSH
55736: LD_VAR 0 5
55740: ARRAY
55741: ARRAY
55742: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
55743: LD_ADDR_VAR 0 7
55747: PUSH
55748: LD_VAR 0 7
55752: PUSH
55753: LD_VAR 0 6
55757: PUSH
55758: EMPTY
55759: LIST
55760: ADD
55761: ST_TO_ADDR
// end ;
55762: GO 55718
55764: POP
55765: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
55766: LD_ADDR_VAR 0 6
55770: PUSH
55771: LD_VAR 0 6
55775: PPUSH
55776: LD_VAR 0 2
55780: PUSH
55781: LD_VAR 0 2
55785: ARRAY
55786: PPUSH
55787: LD_VAR 0 3
55791: PPUSH
55792: CALL_OW 1
55796: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
55797: LD_ADDR_VAR 0 7
55801: PUSH
55802: LD_VAR 0 7
55806: PPUSH
55807: LD_VAR 0 7
55811: PPUSH
55812: LD_VAR 0 6
55816: PPUSH
55817: CALL_OW 1
55821: ST_TO_ADDR
// for i = s_arr downto 2 do
55822: LD_ADDR_VAR 0 5
55826: PUSH
55827: DOUBLE
55828: LD_VAR 0 7
55832: INC
55833: ST_TO_ADDR
55834: LD_INT 2
55836: PUSH
55837: FOR_DOWNTO
55838: IFFALSE 55922
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
55840: LD_ADDR_VAR 0 6
55844: PUSH
55845: LD_VAR 0 7
55849: PUSH
55850: LD_VAR 0 5
55854: PUSH
55855: LD_INT 1
55857: MINUS
55858: ARRAY
55859: PPUSH
55860: LD_VAR 0 2
55864: PUSH
55865: LD_VAR 0 5
55869: PUSH
55870: LD_INT 1
55872: MINUS
55873: ARRAY
55874: PPUSH
55875: LD_VAR 0 7
55879: PUSH
55880: LD_VAR 0 5
55884: ARRAY
55885: PPUSH
55886: CALL_OW 1
55890: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
55891: LD_ADDR_VAR 0 7
55895: PUSH
55896: LD_VAR 0 7
55900: PPUSH
55901: LD_VAR 0 5
55905: PUSH
55906: LD_INT 1
55908: MINUS
55909: PPUSH
55910: LD_VAR 0 6
55914: PPUSH
55915: CALL_OW 1
55919: ST_TO_ADDR
// end ;
55920: GO 55837
55922: POP
55923: POP
// result := s_arr [ 1 ] ;
55924: LD_ADDR_VAR 0 4
55928: PUSH
55929: LD_VAR 0 7
55933: PUSH
55934: LD_INT 1
55936: ARRAY
55937: ST_TO_ADDR
// end ; end ;
55938: LD_VAR 0 4
55942: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
55943: LD_INT 0
55945: PPUSH
55946: PPUSH
// if not list then
55947: LD_VAR 0 1
55951: NOT
55952: IFFALSE 55956
// exit ;
55954: GO 56047
// i := list [ pos1 ] ;
55956: LD_ADDR_VAR 0 5
55960: PUSH
55961: LD_VAR 0 1
55965: PUSH
55966: LD_VAR 0 2
55970: ARRAY
55971: ST_TO_ADDR
// if not i then
55972: LD_VAR 0 5
55976: NOT
55977: IFFALSE 55981
// exit ;
55979: GO 56047
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
55981: LD_ADDR_VAR 0 1
55985: PUSH
55986: LD_VAR 0 1
55990: PPUSH
55991: LD_VAR 0 2
55995: PPUSH
55996: LD_VAR 0 1
56000: PUSH
56001: LD_VAR 0 3
56005: ARRAY
56006: PPUSH
56007: CALL_OW 1
56011: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56012: LD_ADDR_VAR 0 1
56016: PUSH
56017: LD_VAR 0 1
56021: PPUSH
56022: LD_VAR 0 3
56026: PPUSH
56027: LD_VAR 0 5
56031: PPUSH
56032: CALL_OW 1
56036: ST_TO_ADDR
// result := list ;
56037: LD_ADDR_VAR 0 4
56041: PUSH
56042: LD_VAR 0 1
56046: ST_TO_ADDR
// end ;
56047: LD_VAR 0 4
56051: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56052: LD_INT 0
56054: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56055: LD_ADDR_VAR 0 5
56059: PUSH
56060: LD_VAR 0 1
56064: PPUSH
56065: CALL_OW 250
56069: PPUSH
56070: LD_VAR 0 1
56074: PPUSH
56075: CALL_OW 251
56079: PPUSH
56080: LD_VAR 0 2
56084: PPUSH
56085: LD_VAR 0 3
56089: PPUSH
56090: LD_VAR 0 4
56094: PPUSH
56095: CALL 56105 0 5
56099: ST_TO_ADDR
// end ;
56100: LD_VAR 0 5
56104: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56105: LD_INT 0
56107: PPUSH
56108: PPUSH
56109: PPUSH
56110: PPUSH
// if not list then
56111: LD_VAR 0 3
56115: NOT
56116: IFFALSE 56120
// exit ;
56118: GO 56508
// result := [ ] ;
56120: LD_ADDR_VAR 0 6
56124: PUSH
56125: EMPTY
56126: ST_TO_ADDR
// for i in list do
56127: LD_ADDR_VAR 0 7
56131: PUSH
56132: LD_VAR 0 3
56136: PUSH
56137: FOR_IN
56138: IFFALSE 56340
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56140: LD_ADDR_VAR 0 9
56144: PUSH
56145: LD_VAR 0 7
56149: PPUSH
56150: LD_VAR 0 1
56154: PPUSH
56155: LD_VAR 0 2
56159: PPUSH
56160: CALL_OW 297
56164: ST_TO_ADDR
// if not result then
56165: LD_VAR 0 6
56169: NOT
56170: IFFALSE 56196
// result := [ [ i , tmp ] ] else
56172: LD_ADDR_VAR 0 6
56176: PUSH
56177: LD_VAR 0 7
56181: PUSH
56182: LD_VAR 0 9
56186: PUSH
56187: EMPTY
56188: LIST
56189: LIST
56190: PUSH
56191: EMPTY
56192: LIST
56193: ST_TO_ADDR
56194: GO 56338
// begin if result [ result ] [ 2 ] < tmp then
56196: LD_VAR 0 6
56200: PUSH
56201: LD_VAR 0 6
56205: ARRAY
56206: PUSH
56207: LD_INT 2
56209: ARRAY
56210: PUSH
56211: LD_VAR 0 9
56215: LESS
56216: IFFALSE 56258
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56218: LD_ADDR_VAR 0 6
56222: PUSH
56223: LD_VAR 0 6
56227: PPUSH
56228: LD_VAR 0 6
56232: PUSH
56233: LD_INT 1
56235: PLUS
56236: PPUSH
56237: LD_VAR 0 7
56241: PUSH
56242: LD_VAR 0 9
56246: PUSH
56247: EMPTY
56248: LIST
56249: LIST
56250: PPUSH
56251: CALL_OW 2
56255: ST_TO_ADDR
56256: GO 56338
// for j = 1 to result do
56258: LD_ADDR_VAR 0 8
56262: PUSH
56263: DOUBLE
56264: LD_INT 1
56266: DEC
56267: ST_TO_ADDR
56268: LD_VAR 0 6
56272: PUSH
56273: FOR_TO
56274: IFFALSE 56336
// begin if tmp < result [ j ] [ 2 ] then
56276: LD_VAR 0 9
56280: PUSH
56281: LD_VAR 0 6
56285: PUSH
56286: LD_VAR 0 8
56290: ARRAY
56291: PUSH
56292: LD_INT 2
56294: ARRAY
56295: LESS
56296: IFFALSE 56334
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56298: LD_ADDR_VAR 0 6
56302: PUSH
56303: LD_VAR 0 6
56307: PPUSH
56308: LD_VAR 0 8
56312: PPUSH
56313: LD_VAR 0 7
56317: PUSH
56318: LD_VAR 0 9
56322: PUSH
56323: EMPTY
56324: LIST
56325: LIST
56326: PPUSH
56327: CALL_OW 2
56331: ST_TO_ADDR
// break ;
56332: GO 56336
// end ; end ;
56334: GO 56273
56336: POP
56337: POP
// end ; end ;
56338: GO 56137
56340: POP
56341: POP
// if result and not asc then
56342: LD_VAR 0 6
56346: PUSH
56347: LD_VAR 0 4
56351: NOT
56352: AND
56353: IFFALSE 56428
// begin tmp := result ;
56355: LD_ADDR_VAR 0 9
56359: PUSH
56360: LD_VAR 0 6
56364: ST_TO_ADDR
// for i = tmp downto 1 do
56365: LD_ADDR_VAR 0 7
56369: PUSH
56370: DOUBLE
56371: LD_VAR 0 9
56375: INC
56376: ST_TO_ADDR
56377: LD_INT 1
56379: PUSH
56380: FOR_DOWNTO
56381: IFFALSE 56426
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56383: LD_ADDR_VAR 0 6
56387: PUSH
56388: LD_VAR 0 6
56392: PPUSH
56393: LD_VAR 0 9
56397: PUSH
56398: LD_VAR 0 7
56402: MINUS
56403: PUSH
56404: LD_INT 1
56406: PLUS
56407: PPUSH
56408: LD_VAR 0 9
56412: PUSH
56413: LD_VAR 0 7
56417: ARRAY
56418: PPUSH
56419: CALL_OW 1
56423: ST_TO_ADDR
56424: GO 56380
56426: POP
56427: POP
// end ; tmp := [ ] ;
56428: LD_ADDR_VAR 0 9
56432: PUSH
56433: EMPTY
56434: ST_TO_ADDR
// if mode then
56435: LD_VAR 0 5
56439: IFFALSE 56508
// begin for i = 1 to result do
56441: LD_ADDR_VAR 0 7
56445: PUSH
56446: DOUBLE
56447: LD_INT 1
56449: DEC
56450: ST_TO_ADDR
56451: LD_VAR 0 6
56455: PUSH
56456: FOR_TO
56457: IFFALSE 56496
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56459: LD_ADDR_VAR 0 9
56463: PUSH
56464: LD_VAR 0 9
56468: PPUSH
56469: LD_VAR 0 7
56473: PPUSH
56474: LD_VAR 0 6
56478: PUSH
56479: LD_VAR 0 7
56483: ARRAY
56484: PUSH
56485: LD_INT 1
56487: ARRAY
56488: PPUSH
56489: CALL_OW 1
56493: ST_TO_ADDR
56494: GO 56456
56496: POP
56497: POP
// result := tmp ;
56498: LD_ADDR_VAR 0 6
56502: PUSH
56503: LD_VAR 0 9
56507: ST_TO_ADDR
// end ; end ;
56508: LD_VAR 0 6
56512: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
56513: LD_INT 0
56515: PPUSH
56516: PPUSH
56517: PPUSH
56518: PPUSH
56519: PPUSH
56520: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
56521: LD_ADDR_VAR 0 5
56525: PUSH
56526: LD_INT 0
56528: PUSH
56529: LD_INT 0
56531: PUSH
56532: LD_INT 0
56534: PUSH
56535: EMPTY
56536: PUSH
56537: EMPTY
56538: LIST
56539: LIST
56540: LIST
56541: LIST
56542: ST_TO_ADDR
// if not x or not y then
56543: LD_VAR 0 2
56547: NOT
56548: PUSH
56549: LD_VAR 0 3
56553: NOT
56554: OR
56555: IFFALSE 56559
// exit ;
56557: GO 58205
// if not range then
56559: LD_VAR 0 4
56563: NOT
56564: IFFALSE 56574
// range := 10 ;
56566: LD_ADDR_VAR 0 4
56570: PUSH
56571: LD_INT 10
56573: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56574: LD_ADDR_VAR 0 8
56578: PUSH
56579: LD_INT 81
56581: PUSH
56582: LD_VAR 0 1
56586: PUSH
56587: EMPTY
56588: LIST
56589: LIST
56590: PUSH
56591: LD_INT 92
56593: PUSH
56594: LD_VAR 0 2
56598: PUSH
56599: LD_VAR 0 3
56603: PUSH
56604: LD_VAR 0 4
56608: PUSH
56609: EMPTY
56610: LIST
56611: LIST
56612: LIST
56613: LIST
56614: PUSH
56615: LD_INT 3
56617: PUSH
56618: LD_INT 21
56620: PUSH
56621: LD_INT 3
56623: PUSH
56624: EMPTY
56625: LIST
56626: LIST
56627: PUSH
56628: EMPTY
56629: LIST
56630: LIST
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: LIST
56636: PPUSH
56637: CALL_OW 69
56641: ST_TO_ADDR
// if not tmp then
56642: LD_VAR 0 8
56646: NOT
56647: IFFALSE 56651
// exit ;
56649: GO 58205
// for i in tmp do
56651: LD_ADDR_VAR 0 6
56655: PUSH
56656: LD_VAR 0 8
56660: PUSH
56661: FOR_IN
56662: IFFALSE 58180
// begin points := [ 0 , 0 , 0 ] ;
56664: LD_ADDR_VAR 0 9
56668: PUSH
56669: LD_INT 0
56671: PUSH
56672: LD_INT 0
56674: PUSH
56675: LD_INT 0
56677: PUSH
56678: EMPTY
56679: LIST
56680: LIST
56681: LIST
56682: ST_TO_ADDR
// bpoints := 1 ;
56683: LD_ADDR_VAR 0 10
56687: PUSH
56688: LD_INT 1
56690: ST_TO_ADDR
// case GetType ( i ) of unit_human :
56691: LD_VAR 0 6
56695: PPUSH
56696: CALL_OW 247
56700: PUSH
56701: LD_INT 1
56703: DOUBLE
56704: EQUAL
56705: IFTRUE 56709
56707: GO 57287
56709: POP
// begin if GetClass ( i ) = 1 then
56710: LD_VAR 0 6
56714: PPUSH
56715: CALL_OW 257
56719: PUSH
56720: LD_INT 1
56722: EQUAL
56723: IFFALSE 56744
// points := [ 10 , 5 , 3 ] ;
56725: LD_ADDR_VAR 0 9
56729: PUSH
56730: LD_INT 10
56732: PUSH
56733: LD_INT 5
56735: PUSH
56736: LD_INT 3
56738: PUSH
56739: EMPTY
56740: LIST
56741: LIST
56742: LIST
56743: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
56744: LD_VAR 0 6
56748: PPUSH
56749: CALL_OW 257
56753: PUSH
56754: LD_INT 2
56756: PUSH
56757: LD_INT 3
56759: PUSH
56760: LD_INT 4
56762: PUSH
56763: EMPTY
56764: LIST
56765: LIST
56766: LIST
56767: IN
56768: IFFALSE 56789
// points := [ 3 , 2 , 1 ] ;
56770: LD_ADDR_VAR 0 9
56774: PUSH
56775: LD_INT 3
56777: PUSH
56778: LD_INT 2
56780: PUSH
56781: LD_INT 1
56783: PUSH
56784: EMPTY
56785: LIST
56786: LIST
56787: LIST
56788: ST_TO_ADDR
// if GetClass ( i ) = 5 then
56789: LD_VAR 0 6
56793: PPUSH
56794: CALL_OW 257
56798: PUSH
56799: LD_INT 5
56801: EQUAL
56802: IFFALSE 56823
// points := [ 130 , 5 , 2 ] ;
56804: LD_ADDR_VAR 0 9
56808: PUSH
56809: LD_INT 130
56811: PUSH
56812: LD_INT 5
56814: PUSH
56815: LD_INT 2
56817: PUSH
56818: EMPTY
56819: LIST
56820: LIST
56821: LIST
56822: ST_TO_ADDR
// if GetClass ( i ) = 8 then
56823: LD_VAR 0 6
56827: PPUSH
56828: CALL_OW 257
56832: PUSH
56833: LD_INT 8
56835: EQUAL
56836: IFFALSE 56857
// points := [ 35 , 35 , 30 ] ;
56838: LD_ADDR_VAR 0 9
56842: PUSH
56843: LD_INT 35
56845: PUSH
56846: LD_INT 35
56848: PUSH
56849: LD_INT 30
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: LIST
56856: ST_TO_ADDR
// if GetClass ( i ) = 9 then
56857: LD_VAR 0 6
56861: PPUSH
56862: CALL_OW 257
56866: PUSH
56867: LD_INT 9
56869: EQUAL
56870: IFFALSE 56891
// points := [ 20 , 55 , 40 ] ;
56872: LD_ADDR_VAR 0 9
56876: PUSH
56877: LD_INT 20
56879: PUSH
56880: LD_INT 55
56882: PUSH
56883: LD_INT 40
56885: PUSH
56886: EMPTY
56887: LIST
56888: LIST
56889: LIST
56890: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
56891: LD_VAR 0 6
56895: PPUSH
56896: CALL_OW 257
56900: PUSH
56901: LD_INT 12
56903: PUSH
56904: LD_INT 16
56906: PUSH
56907: EMPTY
56908: LIST
56909: LIST
56910: IN
56911: IFFALSE 56932
// points := [ 5 , 3 , 2 ] ;
56913: LD_ADDR_VAR 0 9
56917: PUSH
56918: LD_INT 5
56920: PUSH
56921: LD_INT 3
56923: PUSH
56924: LD_INT 2
56926: PUSH
56927: EMPTY
56928: LIST
56929: LIST
56930: LIST
56931: ST_TO_ADDR
// if GetClass ( i ) = 17 then
56932: LD_VAR 0 6
56936: PPUSH
56937: CALL_OW 257
56941: PUSH
56942: LD_INT 17
56944: EQUAL
56945: IFFALSE 56966
// points := [ 100 , 50 , 75 ] ;
56947: LD_ADDR_VAR 0 9
56951: PUSH
56952: LD_INT 100
56954: PUSH
56955: LD_INT 50
56957: PUSH
56958: LD_INT 75
56960: PUSH
56961: EMPTY
56962: LIST
56963: LIST
56964: LIST
56965: ST_TO_ADDR
// if GetClass ( i ) = 15 then
56966: LD_VAR 0 6
56970: PPUSH
56971: CALL_OW 257
56975: PUSH
56976: LD_INT 15
56978: EQUAL
56979: IFFALSE 57000
// points := [ 10 , 5 , 3 ] ;
56981: LD_ADDR_VAR 0 9
56985: PUSH
56986: LD_INT 10
56988: PUSH
56989: LD_INT 5
56991: PUSH
56992: LD_INT 3
56994: PUSH
56995: EMPTY
56996: LIST
56997: LIST
56998: LIST
56999: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57000: LD_VAR 0 6
57004: PPUSH
57005: CALL_OW 257
57009: PUSH
57010: LD_INT 14
57012: EQUAL
57013: IFFALSE 57034
// points := [ 10 , 0 , 0 ] ;
57015: LD_ADDR_VAR 0 9
57019: PUSH
57020: LD_INT 10
57022: PUSH
57023: LD_INT 0
57025: PUSH
57026: LD_INT 0
57028: PUSH
57029: EMPTY
57030: LIST
57031: LIST
57032: LIST
57033: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57034: LD_VAR 0 6
57038: PPUSH
57039: CALL_OW 257
57043: PUSH
57044: LD_INT 11
57046: EQUAL
57047: IFFALSE 57068
// points := [ 30 , 10 , 5 ] ;
57049: LD_ADDR_VAR 0 9
57053: PUSH
57054: LD_INT 30
57056: PUSH
57057: LD_INT 10
57059: PUSH
57060: LD_INT 5
57062: PUSH
57063: EMPTY
57064: LIST
57065: LIST
57066: LIST
57067: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57068: LD_VAR 0 1
57072: PPUSH
57073: LD_INT 5
57075: PPUSH
57076: CALL_OW 321
57080: PUSH
57081: LD_INT 2
57083: EQUAL
57084: IFFALSE 57101
// bpoints := bpoints * 1.8 ;
57086: LD_ADDR_VAR 0 10
57090: PUSH
57091: LD_VAR 0 10
57095: PUSH
57096: LD_REAL  1.80000000000000E+0000
57099: MUL
57100: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57101: LD_VAR 0 6
57105: PPUSH
57106: CALL_OW 257
57110: PUSH
57111: LD_INT 1
57113: PUSH
57114: LD_INT 2
57116: PUSH
57117: LD_INT 3
57119: PUSH
57120: LD_INT 4
57122: PUSH
57123: EMPTY
57124: LIST
57125: LIST
57126: LIST
57127: LIST
57128: IN
57129: PUSH
57130: LD_VAR 0 1
57134: PPUSH
57135: LD_INT 51
57137: PPUSH
57138: CALL_OW 321
57142: PUSH
57143: LD_INT 2
57145: EQUAL
57146: AND
57147: IFFALSE 57164
// bpoints := bpoints * 1.2 ;
57149: LD_ADDR_VAR 0 10
57153: PUSH
57154: LD_VAR 0 10
57158: PUSH
57159: LD_REAL  1.20000000000000E+0000
57162: MUL
57163: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57164: LD_VAR 0 6
57168: PPUSH
57169: CALL_OW 257
57173: PUSH
57174: LD_INT 5
57176: PUSH
57177: LD_INT 7
57179: PUSH
57180: LD_INT 9
57182: PUSH
57183: EMPTY
57184: LIST
57185: LIST
57186: LIST
57187: IN
57188: PUSH
57189: LD_VAR 0 1
57193: PPUSH
57194: LD_INT 52
57196: PPUSH
57197: CALL_OW 321
57201: PUSH
57202: LD_INT 2
57204: EQUAL
57205: AND
57206: IFFALSE 57223
// bpoints := bpoints * 1.5 ;
57208: LD_ADDR_VAR 0 10
57212: PUSH
57213: LD_VAR 0 10
57217: PUSH
57218: LD_REAL  1.50000000000000E+0000
57221: MUL
57222: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57223: LD_VAR 0 1
57227: PPUSH
57228: LD_INT 66
57230: PPUSH
57231: CALL_OW 321
57235: PUSH
57236: LD_INT 2
57238: EQUAL
57239: IFFALSE 57256
// bpoints := bpoints * 1.1 ;
57241: LD_ADDR_VAR 0 10
57245: PUSH
57246: LD_VAR 0 10
57250: PUSH
57251: LD_REAL  1.10000000000000E+0000
57254: MUL
57255: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57256: LD_ADDR_VAR 0 10
57260: PUSH
57261: LD_VAR 0 10
57265: PUSH
57266: LD_VAR 0 6
57270: PPUSH
57271: LD_INT 1
57273: PPUSH
57274: CALL_OW 259
57278: PUSH
57279: LD_REAL  1.15000000000000E+0000
57282: MUL
57283: MUL
57284: ST_TO_ADDR
// end ; unit_vehicle :
57285: GO 58109
57287: LD_INT 2
57289: DOUBLE
57290: EQUAL
57291: IFTRUE 57295
57293: GO 58097
57295: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57296: LD_VAR 0 6
57300: PPUSH
57301: CALL_OW 264
57305: PUSH
57306: LD_INT 2
57308: PUSH
57309: LD_INT 42
57311: PUSH
57312: LD_INT 24
57314: PUSH
57315: EMPTY
57316: LIST
57317: LIST
57318: LIST
57319: IN
57320: IFFALSE 57341
// points := [ 25 , 5 , 3 ] ;
57322: LD_ADDR_VAR 0 9
57326: PUSH
57327: LD_INT 25
57329: PUSH
57330: LD_INT 5
57332: PUSH
57333: LD_INT 3
57335: PUSH
57336: EMPTY
57337: LIST
57338: LIST
57339: LIST
57340: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57341: LD_VAR 0 6
57345: PPUSH
57346: CALL_OW 264
57350: PUSH
57351: LD_INT 4
57353: PUSH
57354: LD_INT 43
57356: PUSH
57357: LD_INT 25
57359: PUSH
57360: EMPTY
57361: LIST
57362: LIST
57363: LIST
57364: IN
57365: IFFALSE 57386
// points := [ 40 , 15 , 5 ] ;
57367: LD_ADDR_VAR 0 9
57371: PUSH
57372: LD_INT 40
57374: PUSH
57375: LD_INT 15
57377: PUSH
57378: LD_INT 5
57380: PUSH
57381: EMPTY
57382: LIST
57383: LIST
57384: LIST
57385: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57386: LD_VAR 0 6
57390: PPUSH
57391: CALL_OW 264
57395: PUSH
57396: LD_INT 3
57398: PUSH
57399: LD_INT 23
57401: PUSH
57402: EMPTY
57403: LIST
57404: LIST
57405: IN
57406: IFFALSE 57427
// points := [ 7 , 25 , 8 ] ;
57408: LD_ADDR_VAR 0 9
57412: PUSH
57413: LD_INT 7
57415: PUSH
57416: LD_INT 25
57418: PUSH
57419: LD_INT 8
57421: PUSH
57422: EMPTY
57423: LIST
57424: LIST
57425: LIST
57426: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57427: LD_VAR 0 6
57431: PPUSH
57432: CALL_OW 264
57436: PUSH
57437: LD_INT 5
57439: PUSH
57440: LD_INT 27
57442: PUSH
57443: LD_INT 44
57445: PUSH
57446: EMPTY
57447: LIST
57448: LIST
57449: LIST
57450: IN
57451: IFFALSE 57472
// points := [ 14 , 50 , 16 ] ;
57453: LD_ADDR_VAR 0 9
57457: PUSH
57458: LD_INT 14
57460: PUSH
57461: LD_INT 50
57463: PUSH
57464: LD_INT 16
57466: PUSH
57467: EMPTY
57468: LIST
57469: LIST
57470: LIST
57471: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57472: LD_VAR 0 6
57476: PPUSH
57477: CALL_OW 264
57481: PUSH
57482: LD_INT 6
57484: PUSH
57485: LD_INT 46
57487: PUSH
57488: EMPTY
57489: LIST
57490: LIST
57491: IN
57492: IFFALSE 57513
// points := [ 32 , 120 , 70 ] ;
57494: LD_ADDR_VAR 0 9
57498: PUSH
57499: LD_INT 32
57501: PUSH
57502: LD_INT 120
57504: PUSH
57505: LD_INT 70
57507: PUSH
57508: EMPTY
57509: LIST
57510: LIST
57511: LIST
57512: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
57513: LD_VAR 0 6
57517: PPUSH
57518: CALL_OW 264
57522: PUSH
57523: LD_INT 7
57525: PUSH
57526: LD_INT 28
57528: PUSH
57529: LD_INT 45
57531: PUSH
57532: EMPTY
57533: LIST
57534: LIST
57535: LIST
57536: IN
57537: IFFALSE 57558
// points := [ 35 , 20 , 45 ] ;
57539: LD_ADDR_VAR 0 9
57543: PUSH
57544: LD_INT 35
57546: PUSH
57547: LD_INT 20
57549: PUSH
57550: LD_INT 45
57552: PUSH
57553: EMPTY
57554: LIST
57555: LIST
57556: LIST
57557: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
57558: LD_VAR 0 6
57562: PPUSH
57563: CALL_OW 264
57567: PUSH
57568: LD_INT 47
57570: PUSH
57571: EMPTY
57572: LIST
57573: IN
57574: IFFALSE 57595
// points := [ 67 , 45 , 75 ] ;
57576: LD_ADDR_VAR 0 9
57580: PUSH
57581: LD_INT 67
57583: PUSH
57584: LD_INT 45
57586: PUSH
57587: LD_INT 75
57589: PUSH
57590: EMPTY
57591: LIST
57592: LIST
57593: LIST
57594: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
57595: LD_VAR 0 6
57599: PPUSH
57600: CALL_OW 264
57604: PUSH
57605: LD_INT 26
57607: PUSH
57608: EMPTY
57609: LIST
57610: IN
57611: IFFALSE 57632
// points := [ 120 , 30 , 80 ] ;
57613: LD_ADDR_VAR 0 9
57617: PUSH
57618: LD_INT 120
57620: PUSH
57621: LD_INT 30
57623: PUSH
57624: LD_INT 80
57626: PUSH
57627: EMPTY
57628: LIST
57629: LIST
57630: LIST
57631: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
57632: LD_VAR 0 6
57636: PPUSH
57637: CALL_OW 264
57641: PUSH
57642: LD_INT 22
57644: PUSH
57645: EMPTY
57646: LIST
57647: IN
57648: IFFALSE 57669
// points := [ 40 , 1 , 1 ] ;
57650: LD_ADDR_VAR 0 9
57654: PUSH
57655: LD_INT 40
57657: PUSH
57658: LD_INT 1
57660: PUSH
57661: LD_INT 1
57663: PUSH
57664: EMPTY
57665: LIST
57666: LIST
57667: LIST
57668: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
57669: LD_VAR 0 6
57673: PPUSH
57674: CALL_OW 264
57678: PUSH
57679: LD_INT 29
57681: PUSH
57682: EMPTY
57683: LIST
57684: IN
57685: IFFALSE 57706
// points := [ 70 , 200 , 400 ] ;
57687: LD_ADDR_VAR 0 9
57691: PUSH
57692: LD_INT 70
57694: PUSH
57695: LD_INT 200
57697: PUSH
57698: LD_INT 400
57700: PUSH
57701: EMPTY
57702: LIST
57703: LIST
57704: LIST
57705: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
57706: LD_VAR 0 6
57710: PPUSH
57711: CALL_OW 264
57715: PUSH
57716: LD_INT 14
57718: PUSH
57719: LD_INT 53
57721: PUSH
57722: EMPTY
57723: LIST
57724: LIST
57725: IN
57726: IFFALSE 57747
// points := [ 40 , 10 , 20 ] ;
57728: LD_ADDR_VAR 0 9
57732: PUSH
57733: LD_INT 40
57735: PUSH
57736: LD_INT 10
57738: PUSH
57739: LD_INT 20
57741: PUSH
57742: EMPTY
57743: LIST
57744: LIST
57745: LIST
57746: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
57747: LD_VAR 0 6
57751: PPUSH
57752: CALL_OW 264
57756: PUSH
57757: LD_INT 9
57759: PUSH
57760: EMPTY
57761: LIST
57762: IN
57763: IFFALSE 57784
// points := [ 5 , 70 , 20 ] ;
57765: LD_ADDR_VAR 0 9
57769: PUSH
57770: LD_INT 5
57772: PUSH
57773: LD_INT 70
57775: PUSH
57776: LD_INT 20
57778: PUSH
57779: EMPTY
57780: LIST
57781: LIST
57782: LIST
57783: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
57784: LD_VAR 0 6
57788: PPUSH
57789: CALL_OW 264
57793: PUSH
57794: LD_INT 10
57796: PUSH
57797: EMPTY
57798: LIST
57799: IN
57800: IFFALSE 57821
// points := [ 35 , 110 , 70 ] ;
57802: LD_ADDR_VAR 0 9
57806: PUSH
57807: LD_INT 35
57809: PUSH
57810: LD_INT 110
57812: PUSH
57813: LD_INT 70
57815: PUSH
57816: EMPTY
57817: LIST
57818: LIST
57819: LIST
57820: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
57821: LD_VAR 0 6
57825: PPUSH
57826: CALL_OW 265
57830: PUSH
57831: LD_INT 25
57833: EQUAL
57834: IFFALSE 57855
// points := [ 80 , 65 , 100 ] ;
57836: LD_ADDR_VAR 0 9
57840: PUSH
57841: LD_INT 80
57843: PUSH
57844: LD_INT 65
57846: PUSH
57847: LD_INT 100
57849: PUSH
57850: EMPTY
57851: LIST
57852: LIST
57853: LIST
57854: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
57855: LD_VAR 0 6
57859: PPUSH
57860: CALL_OW 263
57864: PUSH
57865: LD_INT 1
57867: EQUAL
57868: IFFALSE 57903
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
57870: LD_ADDR_VAR 0 10
57874: PUSH
57875: LD_VAR 0 10
57879: PUSH
57880: LD_VAR 0 6
57884: PPUSH
57885: CALL_OW 311
57889: PPUSH
57890: LD_INT 3
57892: PPUSH
57893: CALL_OW 259
57897: PUSH
57898: LD_INT 4
57900: MUL
57901: MUL
57902: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
57903: LD_VAR 0 6
57907: PPUSH
57908: CALL_OW 263
57912: PUSH
57913: LD_INT 2
57915: EQUAL
57916: IFFALSE 57967
// begin j := IsControledBy ( i ) ;
57918: LD_ADDR_VAR 0 7
57922: PUSH
57923: LD_VAR 0 6
57927: PPUSH
57928: CALL_OW 312
57932: ST_TO_ADDR
// if j then
57933: LD_VAR 0 7
57937: IFFALSE 57967
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
57939: LD_ADDR_VAR 0 10
57943: PUSH
57944: LD_VAR 0 10
57948: PUSH
57949: LD_VAR 0 7
57953: PPUSH
57954: LD_INT 3
57956: PPUSH
57957: CALL_OW 259
57961: PUSH
57962: LD_INT 3
57964: MUL
57965: MUL
57966: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
57967: LD_VAR 0 6
57971: PPUSH
57972: CALL_OW 264
57976: PUSH
57977: LD_INT 5
57979: PUSH
57980: LD_INT 6
57982: PUSH
57983: LD_INT 46
57985: PUSH
57986: LD_INT 44
57988: PUSH
57989: LD_INT 47
57991: PUSH
57992: LD_INT 45
57994: PUSH
57995: LD_INT 28
57997: PUSH
57998: LD_INT 7
58000: PUSH
58001: LD_INT 27
58003: PUSH
58004: LD_INT 29
58006: PUSH
58007: EMPTY
58008: LIST
58009: LIST
58010: LIST
58011: LIST
58012: LIST
58013: LIST
58014: LIST
58015: LIST
58016: LIST
58017: LIST
58018: IN
58019: PUSH
58020: LD_VAR 0 1
58024: PPUSH
58025: LD_INT 52
58027: PPUSH
58028: CALL_OW 321
58032: PUSH
58033: LD_INT 2
58035: EQUAL
58036: AND
58037: IFFALSE 58054
// bpoints := bpoints * 1.2 ;
58039: LD_ADDR_VAR 0 10
58043: PUSH
58044: LD_VAR 0 10
58048: PUSH
58049: LD_REAL  1.20000000000000E+0000
58052: MUL
58053: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58054: LD_VAR 0 6
58058: PPUSH
58059: CALL_OW 264
58063: PUSH
58064: LD_INT 6
58066: PUSH
58067: LD_INT 46
58069: PUSH
58070: LD_INT 47
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: LIST
58077: IN
58078: IFFALSE 58095
// bpoints := bpoints * 1.2 ;
58080: LD_ADDR_VAR 0 10
58084: PUSH
58085: LD_VAR 0 10
58089: PUSH
58090: LD_REAL  1.20000000000000E+0000
58093: MUL
58094: ST_TO_ADDR
// end ; unit_building :
58095: GO 58109
58097: LD_INT 3
58099: DOUBLE
58100: EQUAL
58101: IFTRUE 58105
58103: GO 58108
58105: POP
// ; end ;
58106: GO 58109
58108: POP
// for j = 1 to 3 do
58109: LD_ADDR_VAR 0 7
58113: PUSH
58114: DOUBLE
58115: LD_INT 1
58117: DEC
58118: ST_TO_ADDR
58119: LD_INT 3
58121: PUSH
58122: FOR_TO
58123: IFFALSE 58176
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58125: LD_ADDR_VAR 0 5
58129: PUSH
58130: LD_VAR 0 5
58134: PPUSH
58135: LD_VAR 0 7
58139: PPUSH
58140: LD_VAR 0 5
58144: PUSH
58145: LD_VAR 0 7
58149: ARRAY
58150: PUSH
58151: LD_VAR 0 9
58155: PUSH
58156: LD_VAR 0 7
58160: ARRAY
58161: PUSH
58162: LD_VAR 0 10
58166: MUL
58167: PLUS
58168: PPUSH
58169: CALL_OW 1
58173: ST_TO_ADDR
58174: GO 58122
58176: POP
58177: POP
// end ;
58178: GO 56661
58180: POP
58181: POP
// result := Replace ( result , 4 , tmp ) ;
58182: LD_ADDR_VAR 0 5
58186: PUSH
58187: LD_VAR 0 5
58191: PPUSH
58192: LD_INT 4
58194: PPUSH
58195: LD_VAR 0 8
58199: PPUSH
58200: CALL_OW 1
58204: ST_TO_ADDR
// end ;
58205: LD_VAR 0 5
58209: RET
// export function DangerAtRange ( unit , range ) ; begin
58210: LD_INT 0
58212: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58213: LD_ADDR_VAR 0 3
58217: PUSH
58218: LD_VAR 0 1
58222: PPUSH
58223: CALL_OW 255
58227: PPUSH
58228: LD_VAR 0 1
58232: PPUSH
58233: CALL_OW 250
58237: PPUSH
58238: LD_VAR 0 1
58242: PPUSH
58243: CALL_OW 251
58247: PPUSH
58248: LD_VAR 0 2
58252: PPUSH
58253: CALL 56513 0 4
58257: ST_TO_ADDR
// end ;
58258: LD_VAR 0 3
58262: RET
// export function DangerInArea ( side , area ) ; begin
58263: LD_INT 0
58265: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58266: LD_ADDR_VAR 0 3
58270: PUSH
58271: LD_VAR 0 2
58275: PPUSH
58276: LD_INT 81
58278: PUSH
58279: LD_VAR 0 1
58283: PUSH
58284: EMPTY
58285: LIST
58286: LIST
58287: PPUSH
58288: CALL_OW 70
58292: ST_TO_ADDR
// end ;
58293: LD_VAR 0 3
58297: RET
// export function IsExtension ( b ) ; begin
58298: LD_INT 0
58300: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58301: LD_ADDR_VAR 0 2
58305: PUSH
58306: LD_VAR 0 1
58310: PUSH
58311: LD_INT 23
58313: PUSH
58314: LD_INT 20
58316: PUSH
58317: LD_INT 22
58319: PUSH
58320: LD_INT 17
58322: PUSH
58323: LD_INT 24
58325: PUSH
58326: LD_INT 21
58328: PUSH
58329: LD_INT 19
58331: PUSH
58332: LD_INT 16
58334: PUSH
58335: LD_INT 25
58337: PUSH
58338: LD_INT 18
58340: PUSH
58341: EMPTY
58342: LIST
58343: LIST
58344: LIST
58345: LIST
58346: LIST
58347: LIST
58348: LIST
58349: LIST
58350: LIST
58351: LIST
58352: IN
58353: ST_TO_ADDR
// end ;
58354: LD_VAR 0 2
58358: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
58359: LD_INT 0
58361: PPUSH
58362: PPUSH
58363: PPUSH
// result := [ ] ;
58364: LD_ADDR_VAR 0 3
58368: PUSH
58369: EMPTY
58370: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58371: LD_ADDR_VAR 0 4
58375: PUSH
58376: LD_VAR 0 2
58380: PPUSH
58381: LD_INT 21
58383: PUSH
58384: LD_INT 3
58386: PUSH
58387: EMPTY
58388: LIST
58389: LIST
58390: PPUSH
58391: CALL_OW 70
58395: ST_TO_ADDR
// if not tmp then
58396: LD_VAR 0 4
58400: NOT
58401: IFFALSE 58405
// exit ;
58403: GO 58463
// for i in tmp do
58405: LD_ADDR_VAR 0 5
58409: PUSH
58410: LD_VAR 0 4
58414: PUSH
58415: FOR_IN
58416: IFFALSE 58451
// if GetBase ( i ) <> base then
58418: LD_VAR 0 5
58422: PPUSH
58423: CALL_OW 274
58427: PUSH
58428: LD_VAR 0 1
58432: NONEQUAL
58433: IFFALSE 58449
// ComLinkToBase ( base , i ) ;
58435: LD_VAR 0 1
58439: PPUSH
58440: LD_VAR 0 5
58444: PPUSH
58445: CALL_OW 169
58449: GO 58415
58451: POP
58452: POP
// result := tmp ;
58453: LD_ADDR_VAR 0 3
58457: PUSH
58458: LD_VAR 0 4
58462: ST_TO_ADDR
// end ;
58463: LD_VAR 0 3
58467: RET
// export function ComComplete ( unit , b ) ; var i ; begin
58468: LD_INT 0
58470: PPUSH
58471: PPUSH
// if BuildingStatus ( b ) = bs_build then
58472: LD_VAR 0 2
58476: PPUSH
58477: CALL_OW 461
58481: PUSH
58482: LD_INT 1
58484: EQUAL
58485: IFFALSE 58545
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
58487: LD_VAR 0 1
58491: PPUSH
58492: LD_STRING h
58494: PUSH
58495: LD_VAR 0 2
58499: PPUSH
58500: CALL_OW 250
58504: PUSH
58505: LD_VAR 0 2
58509: PPUSH
58510: CALL_OW 251
58514: PUSH
58515: LD_VAR 0 2
58519: PUSH
58520: LD_INT 0
58522: PUSH
58523: LD_INT 0
58525: PUSH
58526: LD_INT 0
58528: PUSH
58529: EMPTY
58530: LIST
58531: LIST
58532: LIST
58533: LIST
58534: LIST
58535: LIST
58536: LIST
58537: PUSH
58538: EMPTY
58539: LIST
58540: PPUSH
58541: CALL_OW 446
// end ;
58545: LD_VAR 0 3
58549: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
58550: LD_INT 0
58552: PPUSH
58553: PPUSH
58554: PPUSH
58555: PPUSH
58556: PPUSH
58557: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
58558: LD_VAR 0 1
58562: NOT
58563: PUSH
58564: LD_VAR 0 1
58568: PPUSH
58569: CALL_OW 263
58573: PUSH
58574: LD_INT 2
58576: EQUAL
58577: NOT
58578: OR
58579: IFFALSE 58583
// exit ;
58581: GO 58899
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
58583: LD_ADDR_VAR 0 6
58587: PUSH
58588: LD_INT 22
58590: PUSH
58591: LD_VAR 0 1
58595: PPUSH
58596: CALL_OW 255
58600: PUSH
58601: EMPTY
58602: LIST
58603: LIST
58604: PUSH
58605: LD_INT 2
58607: PUSH
58608: LD_INT 30
58610: PUSH
58611: LD_INT 36
58613: PUSH
58614: EMPTY
58615: LIST
58616: LIST
58617: PUSH
58618: LD_INT 34
58620: PUSH
58621: LD_INT 31
58623: PUSH
58624: EMPTY
58625: LIST
58626: LIST
58627: PUSH
58628: EMPTY
58629: LIST
58630: LIST
58631: LIST
58632: PUSH
58633: EMPTY
58634: LIST
58635: LIST
58636: PPUSH
58637: CALL_OW 69
58641: ST_TO_ADDR
// if not tmp then
58642: LD_VAR 0 6
58646: NOT
58647: IFFALSE 58651
// exit ;
58649: GO 58899
// result := [ ] ;
58651: LD_ADDR_VAR 0 2
58655: PUSH
58656: EMPTY
58657: ST_TO_ADDR
// for i in tmp do
58658: LD_ADDR_VAR 0 3
58662: PUSH
58663: LD_VAR 0 6
58667: PUSH
58668: FOR_IN
58669: IFFALSE 58740
// begin t := UnitsInside ( i ) ;
58671: LD_ADDR_VAR 0 4
58675: PUSH
58676: LD_VAR 0 3
58680: PPUSH
58681: CALL_OW 313
58685: ST_TO_ADDR
// if t then
58686: LD_VAR 0 4
58690: IFFALSE 58738
// for j in t do
58692: LD_ADDR_VAR 0 7
58696: PUSH
58697: LD_VAR 0 4
58701: PUSH
58702: FOR_IN
58703: IFFALSE 58736
// result := Insert ( result , result + 1 , j ) ;
58705: LD_ADDR_VAR 0 2
58709: PUSH
58710: LD_VAR 0 2
58714: PPUSH
58715: LD_VAR 0 2
58719: PUSH
58720: LD_INT 1
58722: PLUS
58723: PPUSH
58724: LD_VAR 0 7
58728: PPUSH
58729: CALL_OW 2
58733: ST_TO_ADDR
58734: GO 58702
58736: POP
58737: POP
// end ;
58738: GO 58668
58740: POP
58741: POP
// if not result then
58742: LD_VAR 0 2
58746: NOT
58747: IFFALSE 58751
// exit ;
58749: GO 58899
// mech := result [ 1 ] ;
58751: LD_ADDR_VAR 0 5
58755: PUSH
58756: LD_VAR 0 2
58760: PUSH
58761: LD_INT 1
58763: ARRAY
58764: ST_TO_ADDR
// if result > 1 then
58765: LD_VAR 0 2
58769: PUSH
58770: LD_INT 1
58772: GREATER
58773: IFFALSE 58885
// for i = 2 to result do
58775: LD_ADDR_VAR 0 3
58779: PUSH
58780: DOUBLE
58781: LD_INT 2
58783: DEC
58784: ST_TO_ADDR
58785: LD_VAR 0 2
58789: PUSH
58790: FOR_TO
58791: IFFALSE 58883
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
58793: LD_ADDR_VAR 0 4
58797: PUSH
58798: LD_VAR 0 2
58802: PUSH
58803: LD_VAR 0 3
58807: ARRAY
58808: PPUSH
58809: LD_INT 3
58811: PPUSH
58812: CALL_OW 259
58816: PUSH
58817: LD_VAR 0 2
58821: PUSH
58822: LD_VAR 0 3
58826: ARRAY
58827: PPUSH
58828: CALL_OW 432
58832: MINUS
58833: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
58834: LD_VAR 0 4
58838: PUSH
58839: LD_VAR 0 5
58843: PPUSH
58844: LD_INT 3
58846: PPUSH
58847: CALL_OW 259
58851: PUSH
58852: LD_VAR 0 5
58856: PPUSH
58857: CALL_OW 432
58861: MINUS
58862: GREATEREQUAL
58863: IFFALSE 58881
// mech := result [ i ] ;
58865: LD_ADDR_VAR 0 5
58869: PUSH
58870: LD_VAR 0 2
58874: PUSH
58875: LD_VAR 0 3
58879: ARRAY
58880: ST_TO_ADDR
// end ;
58881: GO 58790
58883: POP
58884: POP
// ComLinkTo ( vehicle , mech ) ;
58885: LD_VAR 0 1
58889: PPUSH
58890: LD_VAR 0 5
58894: PPUSH
58895: CALL_OW 135
// end ;
58899: LD_VAR 0 2
58903: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
58904: LD_INT 0
58906: PPUSH
58907: PPUSH
58908: PPUSH
58909: PPUSH
58910: PPUSH
58911: PPUSH
58912: PPUSH
58913: PPUSH
58914: PPUSH
58915: PPUSH
58916: PPUSH
58917: PPUSH
58918: PPUSH
// result := [ ] ;
58919: LD_ADDR_VAR 0 7
58923: PUSH
58924: EMPTY
58925: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
58926: LD_VAR 0 1
58930: PPUSH
58931: CALL_OW 266
58935: PUSH
58936: LD_INT 0
58938: PUSH
58939: LD_INT 1
58941: PUSH
58942: EMPTY
58943: LIST
58944: LIST
58945: IN
58946: NOT
58947: IFFALSE 58951
// exit ;
58949: GO 60582
// if name then
58951: LD_VAR 0 3
58955: IFFALSE 58971
// SetBName ( base_dep , name ) ;
58957: LD_VAR 0 1
58961: PPUSH
58962: LD_VAR 0 3
58966: PPUSH
58967: CALL_OW 500
// base := GetBase ( base_dep ) ;
58971: LD_ADDR_VAR 0 15
58975: PUSH
58976: LD_VAR 0 1
58980: PPUSH
58981: CALL_OW 274
58985: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
58986: LD_ADDR_VAR 0 16
58990: PUSH
58991: LD_VAR 0 1
58995: PPUSH
58996: CALL_OW 255
59000: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59001: LD_ADDR_VAR 0 17
59005: PUSH
59006: LD_VAR 0 1
59010: PPUSH
59011: CALL_OW 248
59015: ST_TO_ADDR
// if sources then
59016: LD_VAR 0 5
59020: IFFALSE 59067
// for i = 1 to 3 do
59022: LD_ADDR_VAR 0 8
59026: PUSH
59027: DOUBLE
59028: LD_INT 1
59030: DEC
59031: ST_TO_ADDR
59032: LD_INT 3
59034: PUSH
59035: FOR_TO
59036: IFFALSE 59065
// AddResourceType ( base , i , sources [ i ] ) ;
59038: LD_VAR 0 15
59042: PPUSH
59043: LD_VAR 0 8
59047: PPUSH
59048: LD_VAR 0 5
59052: PUSH
59053: LD_VAR 0 8
59057: ARRAY
59058: PPUSH
59059: CALL_OW 276
59063: GO 59035
59065: POP
59066: POP
// buildings := GetBaseBuildings ( base , area ) ;
59067: LD_ADDR_VAR 0 18
59071: PUSH
59072: LD_VAR 0 15
59076: PPUSH
59077: LD_VAR 0 2
59081: PPUSH
59082: CALL 58359 0 2
59086: ST_TO_ADDR
// InitHc ;
59087: CALL_OW 19
// InitUc ;
59091: CALL_OW 18
// uc_side := side ;
59095: LD_ADDR_OWVAR 20
59099: PUSH
59100: LD_VAR 0 16
59104: ST_TO_ADDR
// uc_nation := nation ;
59105: LD_ADDR_OWVAR 21
59109: PUSH
59110: LD_VAR 0 17
59114: ST_TO_ADDR
// if buildings then
59115: LD_VAR 0 18
59119: IFFALSE 60441
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59121: LD_ADDR_VAR 0 19
59125: PUSH
59126: LD_VAR 0 18
59130: PPUSH
59131: LD_INT 2
59133: PUSH
59134: LD_INT 30
59136: PUSH
59137: LD_INT 29
59139: PUSH
59140: EMPTY
59141: LIST
59142: LIST
59143: PUSH
59144: LD_INT 30
59146: PUSH
59147: LD_INT 30
59149: PUSH
59150: EMPTY
59151: LIST
59152: LIST
59153: PUSH
59154: EMPTY
59155: LIST
59156: LIST
59157: LIST
59158: PPUSH
59159: CALL_OW 72
59163: ST_TO_ADDR
// if tmp then
59164: LD_VAR 0 19
59168: IFFALSE 59216
// for i in tmp do
59170: LD_ADDR_VAR 0 8
59174: PUSH
59175: LD_VAR 0 19
59179: PUSH
59180: FOR_IN
59181: IFFALSE 59214
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59183: LD_VAR 0 8
59187: PPUSH
59188: CALL_OW 250
59192: PPUSH
59193: LD_VAR 0 8
59197: PPUSH
59198: CALL_OW 251
59202: PPUSH
59203: LD_VAR 0 16
59207: PPUSH
59208: CALL_OW 441
59212: GO 59180
59214: POP
59215: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59216: LD_VAR 0 18
59220: PPUSH
59221: LD_INT 2
59223: PUSH
59224: LD_INT 30
59226: PUSH
59227: LD_INT 32
59229: PUSH
59230: EMPTY
59231: LIST
59232: LIST
59233: PUSH
59234: LD_INT 30
59236: PUSH
59237: LD_INT 33
59239: PUSH
59240: EMPTY
59241: LIST
59242: LIST
59243: PUSH
59244: EMPTY
59245: LIST
59246: LIST
59247: LIST
59248: PPUSH
59249: CALL_OW 72
59253: IFFALSE 59341
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59255: LD_ADDR_VAR 0 8
59259: PUSH
59260: LD_VAR 0 18
59264: PPUSH
59265: LD_INT 2
59267: PUSH
59268: LD_INT 30
59270: PUSH
59271: LD_INT 32
59273: PUSH
59274: EMPTY
59275: LIST
59276: LIST
59277: PUSH
59278: LD_INT 30
59280: PUSH
59281: LD_INT 33
59283: PUSH
59284: EMPTY
59285: LIST
59286: LIST
59287: PUSH
59288: EMPTY
59289: LIST
59290: LIST
59291: LIST
59292: PPUSH
59293: CALL_OW 72
59297: PUSH
59298: FOR_IN
59299: IFFALSE 59339
// begin if not GetBWeapon ( i ) then
59301: LD_VAR 0 8
59305: PPUSH
59306: CALL_OW 269
59310: NOT
59311: IFFALSE 59337
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59313: LD_VAR 0 8
59317: PPUSH
59318: LD_VAR 0 8
59322: PPUSH
59323: LD_VAR 0 2
59327: PPUSH
59328: CALL 60587 0 2
59332: PPUSH
59333: CALL_OW 431
// end ;
59337: GO 59298
59339: POP
59340: POP
// end ; for i = 1 to personel do
59341: LD_ADDR_VAR 0 8
59345: PUSH
59346: DOUBLE
59347: LD_INT 1
59349: DEC
59350: ST_TO_ADDR
59351: LD_VAR 0 6
59355: PUSH
59356: FOR_TO
59357: IFFALSE 60421
// begin if i > 4 then
59359: LD_VAR 0 8
59363: PUSH
59364: LD_INT 4
59366: GREATER
59367: IFFALSE 59371
// break ;
59369: GO 60421
// case i of 1 :
59371: LD_VAR 0 8
59375: PUSH
59376: LD_INT 1
59378: DOUBLE
59379: EQUAL
59380: IFTRUE 59384
59382: GO 59464
59384: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59385: LD_ADDR_VAR 0 12
59389: PUSH
59390: LD_VAR 0 18
59394: PPUSH
59395: LD_INT 22
59397: PUSH
59398: LD_VAR 0 16
59402: PUSH
59403: EMPTY
59404: LIST
59405: LIST
59406: PUSH
59407: LD_INT 58
59409: PUSH
59410: EMPTY
59411: LIST
59412: PUSH
59413: LD_INT 2
59415: PUSH
59416: LD_INT 30
59418: PUSH
59419: LD_INT 32
59421: PUSH
59422: EMPTY
59423: LIST
59424: LIST
59425: PUSH
59426: LD_INT 30
59428: PUSH
59429: LD_INT 4
59431: PUSH
59432: EMPTY
59433: LIST
59434: LIST
59435: PUSH
59436: LD_INT 30
59438: PUSH
59439: LD_INT 5
59441: PUSH
59442: EMPTY
59443: LIST
59444: LIST
59445: PUSH
59446: EMPTY
59447: LIST
59448: LIST
59449: LIST
59450: LIST
59451: PUSH
59452: EMPTY
59453: LIST
59454: LIST
59455: LIST
59456: PPUSH
59457: CALL_OW 72
59461: ST_TO_ADDR
59462: GO 59686
59464: LD_INT 2
59466: DOUBLE
59467: EQUAL
59468: IFTRUE 59472
59470: GO 59534
59472: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
59473: LD_ADDR_VAR 0 12
59477: PUSH
59478: LD_VAR 0 18
59482: PPUSH
59483: LD_INT 22
59485: PUSH
59486: LD_VAR 0 16
59490: PUSH
59491: EMPTY
59492: LIST
59493: LIST
59494: PUSH
59495: LD_INT 2
59497: PUSH
59498: LD_INT 30
59500: PUSH
59501: LD_INT 0
59503: PUSH
59504: EMPTY
59505: LIST
59506: LIST
59507: PUSH
59508: LD_INT 30
59510: PUSH
59511: LD_INT 1
59513: PUSH
59514: EMPTY
59515: LIST
59516: LIST
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: LIST
59522: PUSH
59523: EMPTY
59524: LIST
59525: LIST
59526: PPUSH
59527: CALL_OW 72
59531: ST_TO_ADDR
59532: GO 59686
59534: LD_INT 3
59536: DOUBLE
59537: EQUAL
59538: IFTRUE 59542
59540: GO 59604
59542: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
59543: LD_ADDR_VAR 0 12
59547: PUSH
59548: LD_VAR 0 18
59552: PPUSH
59553: LD_INT 22
59555: PUSH
59556: LD_VAR 0 16
59560: PUSH
59561: EMPTY
59562: LIST
59563: LIST
59564: PUSH
59565: LD_INT 2
59567: PUSH
59568: LD_INT 30
59570: PUSH
59571: LD_INT 2
59573: PUSH
59574: EMPTY
59575: LIST
59576: LIST
59577: PUSH
59578: LD_INT 30
59580: PUSH
59581: LD_INT 3
59583: PUSH
59584: EMPTY
59585: LIST
59586: LIST
59587: PUSH
59588: EMPTY
59589: LIST
59590: LIST
59591: LIST
59592: PUSH
59593: EMPTY
59594: LIST
59595: LIST
59596: PPUSH
59597: CALL_OW 72
59601: ST_TO_ADDR
59602: GO 59686
59604: LD_INT 4
59606: DOUBLE
59607: EQUAL
59608: IFTRUE 59612
59610: GO 59685
59612: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
59613: LD_ADDR_VAR 0 12
59617: PUSH
59618: LD_VAR 0 18
59622: PPUSH
59623: LD_INT 22
59625: PUSH
59626: LD_VAR 0 16
59630: PUSH
59631: EMPTY
59632: LIST
59633: LIST
59634: PUSH
59635: LD_INT 2
59637: PUSH
59638: LD_INT 30
59640: PUSH
59641: LD_INT 6
59643: PUSH
59644: EMPTY
59645: LIST
59646: LIST
59647: PUSH
59648: LD_INT 30
59650: PUSH
59651: LD_INT 7
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: PUSH
59658: LD_INT 30
59660: PUSH
59661: LD_INT 8
59663: PUSH
59664: EMPTY
59665: LIST
59666: LIST
59667: PUSH
59668: EMPTY
59669: LIST
59670: LIST
59671: LIST
59672: LIST
59673: PUSH
59674: EMPTY
59675: LIST
59676: LIST
59677: PPUSH
59678: CALL_OW 72
59682: ST_TO_ADDR
59683: GO 59686
59685: POP
// if i = 1 then
59686: LD_VAR 0 8
59690: PUSH
59691: LD_INT 1
59693: EQUAL
59694: IFFALSE 59805
// begin tmp := [ ] ;
59696: LD_ADDR_VAR 0 19
59700: PUSH
59701: EMPTY
59702: ST_TO_ADDR
// for j in f do
59703: LD_ADDR_VAR 0 9
59707: PUSH
59708: LD_VAR 0 12
59712: PUSH
59713: FOR_IN
59714: IFFALSE 59787
// if GetBType ( j ) = b_bunker then
59716: LD_VAR 0 9
59720: PPUSH
59721: CALL_OW 266
59725: PUSH
59726: LD_INT 32
59728: EQUAL
59729: IFFALSE 59756
// tmp := Insert ( tmp , 1 , j ) else
59731: LD_ADDR_VAR 0 19
59735: PUSH
59736: LD_VAR 0 19
59740: PPUSH
59741: LD_INT 1
59743: PPUSH
59744: LD_VAR 0 9
59748: PPUSH
59749: CALL_OW 2
59753: ST_TO_ADDR
59754: GO 59785
// tmp := Insert ( tmp , tmp + 1 , j ) ;
59756: LD_ADDR_VAR 0 19
59760: PUSH
59761: LD_VAR 0 19
59765: PPUSH
59766: LD_VAR 0 19
59770: PUSH
59771: LD_INT 1
59773: PLUS
59774: PPUSH
59775: LD_VAR 0 9
59779: PPUSH
59780: CALL_OW 2
59784: ST_TO_ADDR
59785: GO 59713
59787: POP
59788: POP
// if tmp then
59789: LD_VAR 0 19
59793: IFFALSE 59805
// f := tmp ;
59795: LD_ADDR_VAR 0 12
59799: PUSH
59800: LD_VAR 0 19
59804: ST_TO_ADDR
// end ; x := personel [ i ] ;
59805: LD_ADDR_VAR 0 13
59809: PUSH
59810: LD_VAR 0 6
59814: PUSH
59815: LD_VAR 0 8
59819: ARRAY
59820: ST_TO_ADDR
// if x = - 1 then
59821: LD_VAR 0 13
59825: PUSH
59826: LD_INT 1
59828: NEG
59829: EQUAL
59830: IFFALSE 60039
// begin for j in f do
59832: LD_ADDR_VAR 0 9
59836: PUSH
59837: LD_VAR 0 12
59841: PUSH
59842: FOR_IN
59843: IFFALSE 60035
// repeat InitHc ;
59845: CALL_OW 19
// if GetBType ( j ) = b_barracks then
59849: LD_VAR 0 9
59853: PPUSH
59854: CALL_OW 266
59858: PUSH
59859: LD_INT 5
59861: EQUAL
59862: IFFALSE 59932
// begin if UnitsInside ( j ) < 3 then
59864: LD_VAR 0 9
59868: PPUSH
59869: CALL_OW 313
59873: PUSH
59874: LD_INT 3
59876: LESS
59877: IFFALSE 59913
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59879: LD_INT 0
59881: PPUSH
59882: LD_INT 5
59884: PUSH
59885: LD_INT 8
59887: PUSH
59888: LD_INT 9
59890: PUSH
59891: EMPTY
59892: LIST
59893: LIST
59894: LIST
59895: PUSH
59896: LD_VAR 0 17
59900: ARRAY
59901: PPUSH
59902: LD_VAR 0 4
59906: PPUSH
59907: CALL_OW 380
59911: GO 59930
// PrepareHuman ( false , i , skill ) ;
59913: LD_INT 0
59915: PPUSH
59916: LD_VAR 0 8
59920: PPUSH
59921: LD_VAR 0 4
59925: PPUSH
59926: CALL_OW 380
// end else
59930: GO 59949
// PrepareHuman ( false , i , skill ) ;
59932: LD_INT 0
59934: PPUSH
59935: LD_VAR 0 8
59939: PPUSH
59940: LD_VAR 0 4
59944: PPUSH
59945: CALL_OW 380
// un := CreateHuman ;
59949: LD_ADDR_VAR 0 14
59953: PUSH
59954: CALL_OW 44
59958: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59959: LD_ADDR_VAR 0 7
59963: PUSH
59964: LD_VAR 0 7
59968: PPUSH
59969: LD_INT 1
59971: PPUSH
59972: LD_VAR 0 14
59976: PPUSH
59977: CALL_OW 2
59981: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
59982: LD_VAR 0 14
59986: PPUSH
59987: LD_VAR 0 9
59991: PPUSH
59992: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
59996: LD_VAR 0 9
60000: PPUSH
60001: CALL_OW 313
60005: PUSH
60006: LD_INT 6
60008: EQUAL
60009: PUSH
60010: LD_VAR 0 9
60014: PPUSH
60015: CALL_OW 266
60019: PUSH
60020: LD_INT 32
60022: PUSH
60023: LD_INT 31
60025: PUSH
60026: EMPTY
60027: LIST
60028: LIST
60029: IN
60030: OR
60031: IFFALSE 59845
60033: GO 59842
60035: POP
60036: POP
// end else
60037: GO 60419
// for j = 1 to x do
60039: LD_ADDR_VAR 0 9
60043: PUSH
60044: DOUBLE
60045: LD_INT 1
60047: DEC
60048: ST_TO_ADDR
60049: LD_VAR 0 13
60053: PUSH
60054: FOR_TO
60055: IFFALSE 60417
// begin InitHc ;
60057: CALL_OW 19
// if not f then
60061: LD_VAR 0 12
60065: NOT
60066: IFFALSE 60155
// begin PrepareHuman ( false , i , skill ) ;
60068: LD_INT 0
60070: PPUSH
60071: LD_VAR 0 8
60075: PPUSH
60076: LD_VAR 0 4
60080: PPUSH
60081: CALL_OW 380
// un := CreateHuman ;
60085: LD_ADDR_VAR 0 14
60089: PUSH
60090: CALL_OW 44
60094: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60095: LD_ADDR_VAR 0 7
60099: PUSH
60100: LD_VAR 0 7
60104: PPUSH
60105: LD_INT 1
60107: PPUSH
60108: LD_VAR 0 14
60112: PPUSH
60113: CALL_OW 2
60117: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60118: LD_VAR 0 14
60122: PPUSH
60123: LD_VAR 0 1
60127: PPUSH
60128: CALL_OW 250
60132: PPUSH
60133: LD_VAR 0 1
60137: PPUSH
60138: CALL_OW 251
60142: PPUSH
60143: LD_INT 10
60145: PPUSH
60146: LD_INT 0
60148: PPUSH
60149: CALL_OW 50
// continue ;
60153: GO 60054
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60155: LD_VAR 0 12
60159: PUSH
60160: LD_INT 1
60162: ARRAY
60163: PPUSH
60164: CALL_OW 313
60168: PUSH
60169: LD_VAR 0 12
60173: PUSH
60174: LD_INT 1
60176: ARRAY
60177: PPUSH
60178: CALL_OW 266
60182: PUSH
60183: LD_INT 32
60185: PUSH
60186: LD_INT 31
60188: PUSH
60189: EMPTY
60190: LIST
60191: LIST
60192: IN
60193: AND
60194: PUSH
60195: LD_VAR 0 12
60199: PUSH
60200: LD_INT 1
60202: ARRAY
60203: PPUSH
60204: CALL_OW 313
60208: PUSH
60209: LD_INT 6
60211: EQUAL
60212: OR
60213: IFFALSE 60233
// f := Delete ( f , 1 ) ;
60215: LD_ADDR_VAR 0 12
60219: PUSH
60220: LD_VAR 0 12
60224: PPUSH
60225: LD_INT 1
60227: PPUSH
60228: CALL_OW 3
60232: ST_TO_ADDR
// if not f then
60233: LD_VAR 0 12
60237: NOT
60238: IFFALSE 60256
// begin x := x + 2 ;
60240: LD_ADDR_VAR 0 13
60244: PUSH
60245: LD_VAR 0 13
60249: PUSH
60250: LD_INT 2
60252: PLUS
60253: ST_TO_ADDR
// continue ;
60254: GO 60054
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60256: LD_VAR 0 12
60260: PUSH
60261: LD_INT 1
60263: ARRAY
60264: PPUSH
60265: CALL_OW 266
60269: PUSH
60270: LD_INT 5
60272: EQUAL
60273: IFFALSE 60347
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60275: LD_VAR 0 12
60279: PUSH
60280: LD_INT 1
60282: ARRAY
60283: PPUSH
60284: CALL_OW 313
60288: PUSH
60289: LD_INT 3
60291: LESS
60292: IFFALSE 60328
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60294: LD_INT 0
60296: PPUSH
60297: LD_INT 5
60299: PUSH
60300: LD_INT 8
60302: PUSH
60303: LD_INT 9
60305: PUSH
60306: EMPTY
60307: LIST
60308: LIST
60309: LIST
60310: PUSH
60311: LD_VAR 0 17
60315: ARRAY
60316: PPUSH
60317: LD_VAR 0 4
60321: PPUSH
60322: CALL_OW 380
60326: GO 60345
// PrepareHuman ( false , i , skill ) ;
60328: LD_INT 0
60330: PPUSH
60331: LD_VAR 0 8
60335: PPUSH
60336: LD_VAR 0 4
60340: PPUSH
60341: CALL_OW 380
// end else
60345: GO 60364
// PrepareHuman ( false , i , skill ) ;
60347: LD_INT 0
60349: PPUSH
60350: LD_VAR 0 8
60354: PPUSH
60355: LD_VAR 0 4
60359: PPUSH
60360: CALL_OW 380
// un := CreateHuman ;
60364: LD_ADDR_VAR 0 14
60368: PUSH
60369: CALL_OW 44
60373: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60374: LD_ADDR_VAR 0 7
60378: PUSH
60379: LD_VAR 0 7
60383: PPUSH
60384: LD_INT 1
60386: PPUSH
60387: LD_VAR 0 14
60391: PPUSH
60392: CALL_OW 2
60396: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60397: LD_VAR 0 14
60401: PPUSH
60402: LD_VAR 0 12
60406: PUSH
60407: LD_INT 1
60409: ARRAY
60410: PPUSH
60411: CALL_OW 52
// end ;
60415: GO 60054
60417: POP
60418: POP
// end ;
60419: GO 59356
60421: POP
60422: POP
// result := result ^ buildings ;
60423: LD_ADDR_VAR 0 7
60427: PUSH
60428: LD_VAR 0 7
60432: PUSH
60433: LD_VAR 0 18
60437: ADD
60438: ST_TO_ADDR
// end else
60439: GO 60582
// begin for i = 1 to personel do
60441: LD_ADDR_VAR 0 8
60445: PUSH
60446: DOUBLE
60447: LD_INT 1
60449: DEC
60450: ST_TO_ADDR
60451: LD_VAR 0 6
60455: PUSH
60456: FOR_TO
60457: IFFALSE 60580
// begin if i > 4 then
60459: LD_VAR 0 8
60463: PUSH
60464: LD_INT 4
60466: GREATER
60467: IFFALSE 60471
// break ;
60469: GO 60580
// x := personel [ i ] ;
60471: LD_ADDR_VAR 0 13
60475: PUSH
60476: LD_VAR 0 6
60480: PUSH
60481: LD_VAR 0 8
60485: ARRAY
60486: ST_TO_ADDR
// if x = - 1 then
60487: LD_VAR 0 13
60491: PUSH
60492: LD_INT 1
60494: NEG
60495: EQUAL
60496: IFFALSE 60500
// continue ;
60498: GO 60456
// PrepareHuman ( false , i , skill ) ;
60500: LD_INT 0
60502: PPUSH
60503: LD_VAR 0 8
60507: PPUSH
60508: LD_VAR 0 4
60512: PPUSH
60513: CALL_OW 380
// un := CreateHuman ;
60517: LD_ADDR_VAR 0 14
60521: PUSH
60522: CALL_OW 44
60526: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60527: LD_VAR 0 14
60531: PPUSH
60532: LD_VAR 0 1
60536: PPUSH
60537: CALL_OW 250
60541: PPUSH
60542: LD_VAR 0 1
60546: PPUSH
60547: CALL_OW 251
60551: PPUSH
60552: LD_INT 10
60554: PPUSH
60555: LD_INT 0
60557: PPUSH
60558: CALL_OW 50
// result := result ^ un ;
60562: LD_ADDR_VAR 0 7
60566: PUSH
60567: LD_VAR 0 7
60571: PUSH
60572: LD_VAR 0 14
60576: ADD
60577: ST_TO_ADDR
// end ;
60578: GO 60456
60580: POP
60581: POP
// end ; end ;
60582: LD_VAR 0 7
60586: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
60587: LD_INT 0
60589: PPUSH
60590: PPUSH
60591: PPUSH
60592: PPUSH
60593: PPUSH
60594: PPUSH
60595: PPUSH
60596: PPUSH
60597: PPUSH
60598: PPUSH
60599: PPUSH
60600: PPUSH
60601: PPUSH
60602: PPUSH
60603: PPUSH
60604: PPUSH
// result := false ;
60605: LD_ADDR_VAR 0 3
60609: PUSH
60610: LD_INT 0
60612: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
60613: LD_VAR 0 1
60617: NOT
60618: PUSH
60619: LD_VAR 0 1
60623: PPUSH
60624: CALL_OW 266
60628: PUSH
60629: LD_INT 32
60631: PUSH
60632: LD_INT 33
60634: PUSH
60635: EMPTY
60636: LIST
60637: LIST
60638: IN
60639: NOT
60640: OR
60641: IFFALSE 60645
// exit ;
60643: GO 61781
// nat := GetNation ( tower ) ;
60645: LD_ADDR_VAR 0 12
60649: PUSH
60650: LD_VAR 0 1
60654: PPUSH
60655: CALL_OW 248
60659: ST_TO_ADDR
// side := GetSide ( tower ) ;
60660: LD_ADDR_VAR 0 16
60664: PUSH
60665: LD_VAR 0 1
60669: PPUSH
60670: CALL_OW 255
60674: ST_TO_ADDR
// x := GetX ( tower ) ;
60675: LD_ADDR_VAR 0 10
60679: PUSH
60680: LD_VAR 0 1
60684: PPUSH
60685: CALL_OW 250
60689: ST_TO_ADDR
// y := GetY ( tower ) ;
60690: LD_ADDR_VAR 0 11
60694: PUSH
60695: LD_VAR 0 1
60699: PPUSH
60700: CALL_OW 251
60704: ST_TO_ADDR
// if not x or not y then
60705: LD_VAR 0 10
60709: NOT
60710: PUSH
60711: LD_VAR 0 11
60715: NOT
60716: OR
60717: IFFALSE 60721
// exit ;
60719: GO 61781
// weapon := 0 ;
60721: LD_ADDR_VAR 0 18
60725: PUSH
60726: LD_INT 0
60728: ST_TO_ADDR
// fac_list := [ ] ;
60729: LD_ADDR_VAR 0 17
60733: PUSH
60734: EMPTY
60735: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
60736: LD_ADDR_VAR 0 6
60740: PUSH
60741: LD_VAR 0 1
60745: PPUSH
60746: CALL_OW 274
60750: PPUSH
60751: LD_VAR 0 2
60755: PPUSH
60756: CALL 58359 0 2
60760: PPUSH
60761: LD_INT 30
60763: PUSH
60764: LD_INT 3
60766: PUSH
60767: EMPTY
60768: LIST
60769: LIST
60770: PPUSH
60771: CALL_OW 72
60775: ST_TO_ADDR
// if not factories then
60776: LD_VAR 0 6
60780: NOT
60781: IFFALSE 60785
// exit ;
60783: GO 61781
// for i in factories do
60785: LD_ADDR_VAR 0 8
60789: PUSH
60790: LD_VAR 0 6
60794: PUSH
60795: FOR_IN
60796: IFFALSE 60821
// fac_list := fac_list union AvailableWeaponList ( i ) ;
60798: LD_ADDR_VAR 0 17
60802: PUSH
60803: LD_VAR 0 17
60807: PUSH
60808: LD_VAR 0 8
60812: PPUSH
60813: CALL_OW 478
60817: UNION
60818: ST_TO_ADDR
60819: GO 60795
60821: POP
60822: POP
// if not fac_list then
60823: LD_VAR 0 17
60827: NOT
60828: IFFALSE 60832
// exit ;
60830: GO 61781
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
60832: LD_ADDR_VAR 0 5
60836: PUSH
60837: LD_INT 4
60839: PUSH
60840: LD_INT 5
60842: PUSH
60843: LD_INT 9
60845: PUSH
60846: LD_INT 10
60848: PUSH
60849: LD_INT 6
60851: PUSH
60852: LD_INT 7
60854: PUSH
60855: LD_INT 11
60857: PUSH
60858: EMPTY
60859: LIST
60860: LIST
60861: LIST
60862: LIST
60863: LIST
60864: LIST
60865: LIST
60866: PUSH
60867: LD_INT 27
60869: PUSH
60870: LD_INT 28
60872: PUSH
60873: LD_INT 26
60875: PUSH
60876: LD_INT 30
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: LIST
60883: LIST
60884: PUSH
60885: LD_INT 43
60887: PUSH
60888: LD_INT 44
60890: PUSH
60891: LD_INT 46
60893: PUSH
60894: LD_INT 45
60896: PUSH
60897: LD_INT 47
60899: PUSH
60900: LD_INT 49
60902: PUSH
60903: EMPTY
60904: LIST
60905: LIST
60906: LIST
60907: LIST
60908: LIST
60909: LIST
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: LIST
60915: PUSH
60916: LD_VAR 0 12
60920: ARRAY
60921: ST_TO_ADDR
// for i in list do
60922: LD_ADDR_VAR 0 8
60926: PUSH
60927: LD_VAR 0 5
60931: PUSH
60932: FOR_IN
60933: IFFALSE 60966
// if not i in fac_list then
60935: LD_VAR 0 8
60939: PUSH
60940: LD_VAR 0 17
60944: IN
60945: NOT
60946: IFFALSE 60964
// list := list diff i ;
60948: LD_ADDR_VAR 0 5
60952: PUSH
60953: LD_VAR 0 5
60957: PUSH
60958: LD_VAR 0 8
60962: DIFF
60963: ST_TO_ADDR
60964: GO 60932
60966: POP
60967: POP
// if not list then
60968: LD_VAR 0 5
60972: NOT
60973: IFFALSE 60977
// exit ;
60975: GO 61781
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
60977: LD_VAR 0 12
60981: PUSH
60982: LD_INT 3
60984: EQUAL
60985: PUSH
60986: LD_INT 49
60988: PUSH
60989: LD_VAR 0 5
60993: IN
60994: AND
60995: PUSH
60996: LD_INT 31
60998: PPUSH
60999: LD_VAR 0 16
61003: PPUSH
61004: CALL_OW 321
61008: PUSH
61009: LD_INT 2
61011: EQUAL
61012: AND
61013: IFFALSE 61073
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61015: LD_INT 22
61017: PUSH
61018: LD_VAR 0 16
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: PUSH
61027: LD_INT 35
61029: PUSH
61030: LD_INT 49
61032: PUSH
61033: EMPTY
61034: LIST
61035: LIST
61036: PUSH
61037: LD_INT 91
61039: PUSH
61040: LD_VAR 0 1
61044: PUSH
61045: LD_INT 10
61047: PUSH
61048: EMPTY
61049: LIST
61050: LIST
61051: LIST
61052: PUSH
61053: EMPTY
61054: LIST
61055: LIST
61056: LIST
61057: PPUSH
61058: CALL_OW 69
61062: NOT
61063: IFFALSE 61073
// weapon := ru_time_lapser ;
61065: LD_ADDR_VAR 0 18
61069: PUSH
61070: LD_INT 49
61072: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61073: LD_VAR 0 12
61077: PUSH
61078: LD_INT 1
61080: PUSH
61081: LD_INT 2
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: IN
61088: PUSH
61089: LD_INT 11
61091: PUSH
61092: LD_VAR 0 5
61096: IN
61097: PUSH
61098: LD_INT 30
61100: PUSH
61101: LD_VAR 0 5
61105: IN
61106: OR
61107: AND
61108: PUSH
61109: LD_INT 6
61111: PPUSH
61112: LD_VAR 0 16
61116: PPUSH
61117: CALL_OW 321
61121: PUSH
61122: LD_INT 2
61124: EQUAL
61125: AND
61126: IFFALSE 61291
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61128: LD_INT 22
61130: PUSH
61131: LD_VAR 0 16
61135: PUSH
61136: EMPTY
61137: LIST
61138: LIST
61139: PUSH
61140: LD_INT 2
61142: PUSH
61143: LD_INT 35
61145: PUSH
61146: LD_INT 11
61148: PUSH
61149: EMPTY
61150: LIST
61151: LIST
61152: PUSH
61153: LD_INT 35
61155: PUSH
61156: LD_INT 30
61158: PUSH
61159: EMPTY
61160: LIST
61161: LIST
61162: PUSH
61163: EMPTY
61164: LIST
61165: LIST
61166: LIST
61167: PUSH
61168: LD_INT 91
61170: PUSH
61171: LD_VAR 0 1
61175: PUSH
61176: LD_INT 18
61178: PUSH
61179: EMPTY
61180: LIST
61181: LIST
61182: LIST
61183: PUSH
61184: EMPTY
61185: LIST
61186: LIST
61187: LIST
61188: PPUSH
61189: CALL_OW 69
61193: NOT
61194: PUSH
61195: LD_INT 22
61197: PUSH
61198: LD_VAR 0 16
61202: PUSH
61203: EMPTY
61204: LIST
61205: LIST
61206: PUSH
61207: LD_INT 2
61209: PUSH
61210: LD_INT 30
61212: PUSH
61213: LD_INT 32
61215: PUSH
61216: EMPTY
61217: LIST
61218: LIST
61219: PUSH
61220: LD_INT 30
61222: PUSH
61223: LD_INT 33
61225: PUSH
61226: EMPTY
61227: LIST
61228: LIST
61229: PUSH
61230: EMPTY
61231: LIST
61232: LIST
61233: LIST
61234: PUSH
61235: LD_INT 91
61237: PUSH
61238: LD_VAR 0 1
61242: PUSH
61243: LD_INT 12
61245: PUSH
61246: EMPTY
61247: LIST
61248: LIST
61249: LIST
61250: PUSH
61251: EMPTY
61252: LIST
61253: LIST
61254: LIST
61255: PUSH
61256: EMPTY
61257: LIST
61258: PPUSH
61259: CALL_OW 69
61263: PUSH
61264: LD_INT 2
61266: GREATER
61267: AND
61268: IFFALSE 61291
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61270: LD_ADDR_VAR 0 18
61274: PUSH
61275: LD_INT 11
61277: PUSH
61278: LD_INT 30
61280: PUSH
61281: EMPTY
61282: LIST
61283: LIST
61284: PUSH
61285: LD_VAR 0 12
61289: ARRAY
61290: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61291: LD_VAR 0 18
61295: NOT
61296: PUSH
61297: LD_INT 40
61299: PPUSH
61300: LD_VAR 0 16
61304: PPUSH
61305: CALL_OW 321
61309: PUSH
61310: LD_INT 2
61312: EQUAL
61313: AND
61314: PUSH
61315: LD_INT 7
61317: PUSH
61318: LD_VAR 0 5
61322: IN
61323: PUSH
61324: LD_INT 28
61326: PUSH
61327: LD_VAR 0 5
61331: IN
61332: OR
61333: PUSH
61334: LD_INT 45
61336: PUSH
61337: LD_VAR 0 5
61341: IN
61342: OR
61343: AND
61344: IFFALSE 61598
// begin hex := GetHexInfo ( x , y ) ;
61346: LD_ADDR_VAR 0 4
61350: PUSH
61351: LD_VAR 0 10
61355: PPUSH
61356: LD_VAR 0 11
61360: PPUSH
61361: CALL_OW 546
61365: ST_TO_ADDR
// if hex [ 1 ] then
61366: LD_VAR 0 4
61370: PUSH
61371: LD_INT 1
61373: ARRAY
61374: IFFALSE 61378
// exit ;
61376: GO 61781
// height := hex [ 2 ] ;
61378: LD_ADDR_VAR 0 15
61382: PUSH
61383: LD_VAR 0 4
61387: PUSH
61388: LD_INT 2
61390: ARRAY
61391: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61392: LD_ADDR_VAR 0 14
61396: PUSH
61397: LD_INT 0
61399: PUSH
61400: LD_INT 2
61402: PUSH
61403: LD_INT 3
61405: PUSH
61406: LD_INT 5
61408: PUSH
61409: EMPTY
61410: LIST
61411: LIST
61412: LIST
61413: LIST
61414: ST_TO_ADDR
// for i in tmp do
61415: LD_ADDR_VAR 0 8
61419: PUSH
61420: LD_VAR 0 14
61424: PUSH
61425: FOR_IN
61426: IFFALSE 61596
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61428: LD_ADDR_VAR 0 9
61432: PUSH
61433: LD_VAR 0 10
61437: PPUSH
61438: LD_VAR 0 8
61442: PPUSH
61443: LD_INT 5
61445: PPUSH
61446: CALL_OW 272
61450: PUSH
61451: LD_VAR 0 11
61455: PPUSH
61456: LD_VAR 0 8
61460: PPUSH
61461: LD_INT 5
61463: PPUSH
61464: CALL_OW 273
61468: PUSH
61469: EMPTY
61470: LIST
61471: LIST
61472: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61473: LD_VAR 0 9
61477: PUSH
61478: LD_INT 1
61480: ARRAY
61481: PPUSH
61482: LD_VAR 0 9
61486: PUSH
61487: LD_INT 2
61489: ARRAY
61490: PPUSH
61491: CALL_OW 488
61495: IFFALSE 61594
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61497: LD_ADDR_VAR 0 4
61501: PUSH
61502: LD_VAR 0 9
61506: PUSH
61507: LD_INT 1
61509: ARRAY
61510: PPUSH
61511: LD_VAR 0 9
61515: PUSH
61516: LD_INT 2
61518: ARRAY
61519: PPUSH
61520: CALL_OW 546
61524: ST_TO_ADDR
// if hex [ 1 ] then
61525: LD_VAR 0 4
61529: PUSH
61530: LD_INT 1
61532: ARRAY
61533: IFFALSE 61537
// continue ;
61535: GO 61425
// h := hex [ 2 ] ;
61537: LD_ADDR_VAR 0 13
61541: PUSH
61542: LD_VAR 0 4
61546: PUSH
61547: LD_INT 2
61549: ARRAY
61550: ST_TO_ADDR
// if h + 7 < height then
61551: LD_VAR 0 13
61555: PUSH
61556: LD_INT 7
61558: PLUS
61559: PUSH
61560: LD_VAR 0 15
61564: LESS
61565: IFFALSE 61594
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
61567: LD_ADDR_VAR 0 18
61571: PUSH
61572: LD_INT 7
61574: PUSH
61575: LD_INT 28
61577: PUSH
61578: LD_INT 45
61580: PUSH
61581: EMPTY
61582: LIST
61583: LIST
61584: LIST
61585: PUSH
61586: LD_VAR 0 12
61590: ARRAY
61591: ST_TO_ADDR
// break ;
61592: GO 61596
// end ; end ; end ;
61594: GO 61425
61596: POP
61597: POP
// end ; if not weapon then
61598: LD_VAR 0 18
61602: NOT
61603: IFFALSE 61663
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
61605: LD_ADDR_VAR 0 5
61609: PUSH
61610: LD_VAR 0 5
61614: PUSH
61615: LD_INT 11
61617: PUSH
61618: LD_INT 30
61620: PUSH
61621: LD_INT 49
61623: PUSH
61624: EMPTY
61625: LIST
61626: LIST
61627: LIST
61628: DIFF
61629: ST_TO_ADDR
// if not list then
61630: LD_VAR 0 5
61634: NOT
61635: IFFALSE 61639
// exit ;
61637: GO 61781
// weapon := list [ rand ( 1 , list ) ] ;
61639: LD_ADDR_VAR 0 18
61643: PUSH
61644: LD_VAR 0 5
61648: PUSH
61649: LD_INT 1
61651: PPUSH
61652: LD_VAR 0 5
61656: PPUSH
61657: CALL_OW 12
61661: ARRAY
61662: ST_TO_ADDR
// end ; if weapon then
61663: LD_VAR 0 18
61667: IFFALSE 61781
// begin tmp := CostOfWeapon ( weapon ) ;
61669: LD_ADDR_VAR 0 14
61673: PUSH
61674: LD_VAR 0 18
61678: PPUSH
61679: CALL_OW 451
61683: ST_TO_ADDR
// j := GetBase ( tower ) ;
61684: LD_ADDR_VAR 0 9
61688: PUSH
61689: LD_VAR 0 1
61693: PPUSH
61694: CALL_OW 274
61698: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
61699: LD_VAR 0 9
61703: PPUSH
61704: LD_INT 1
61706: PPUSH
61707: CALL_OW 275
61711: PUSH
61712: LD_VAR 0 14
61716: PUSH
61717: LD_INT 1
61719: ARRAY
61720: GREATEREQUAL
61721: PUSH
61722: LD_VAR 0 9
61726: PPUSH
61727: LD_INT 2
61729: PPUSH
61730: CALL_OW 275
61734: PUSH
61735: LD_VAR 0 14
61739: PUSH
61740: LD_INT 2
61742: ARRAY
61743: GREATEREQUAL
61744: AND
61745: PUSH
61746: LD_VAR 0 9
61750: PPUSH
61751: LD_INT 3
61753: PPUSH
61754: CALL_OW 275
61758: PUSH
61759: LD_VAR 0 14
61763: PUSH
61764: LD_INT 3
61766: ARRAY
61767: GREATEREQUAL
61768: AND
61769: IFFALSE 61781
// result := weapon ;
61771: LD_ADDR_VAR 0 3
61775: PUSH
61776: LD_VAR 0 18
61780: ST_TO_ADDR
// end ; end ;
61781: LD_VAR 0 3
61785: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
61786: LD_INT 0
61788: PPUSH
61789: PPUSH
// result := true ;
61790: LD_ADDR_VAR 0 3
61794: PUSH
61795: LD_INT 1
61797: ST_TO_ADDR
// if array1 = array2 then
61798: LD_VAR 0 1
61802: PUSH
61803: LD_VAR 0 2
61807: EQUAL
61808: IFFALSE 61868
// begin for i = 1 to array1 do
61810: LD_ADDR_VAR 0 4
61814: PUSH
61815: DOUBLE
61816: LD_INT 1
61818: DEC
61819: ST_TO_ADDR
61820: LD_VAR 0 1
61824: PUSH
61825: FOR_TO
61826: IFFALSE 61864
// if array1 [ i ] <> array2 [ i ] then
61828: LD_VAR 0 1
61832: PUSH
61833: LD_VAR 0 4
61837: ARRAY
61838: PUSH
61839: LD_VAR 0 2
61843: PUSH
61844: LD_VAR 0 4
61848: ARRAY
61849: NONEQUAL
61850: IFFALSE 61862
// begin result := false ;
61852: LD_ADDR_VAR 0 3
61856: PUSH
61857: LD_INT 0
61859: ST_TO_ADDR
// break ;
61860: GO 61864
// end ;
61862: GO 61825
61864: POP
61865: POP
// end else
61866: GO 61876
// result := false ;
61868: LD_ADDR_VAR 0 3
61872: PUSH
61873: LD_INT 0
61875: ST_TO_ADDR
// end ;
61876: LD_VAR 0 3
61880: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
61881: LD_INT 0
61883: PPUSH
61884: PPUSH
61885: PPUSH
// pom := GetBase ( fac ) ;
61886: LD_ADDR_VAR 0 5
61890: PUSH
61891: LD_VAR 0 1
61895: PPUSH
61896: CALL_OW 274
61900: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
61901: LD_ADDR_VAR 0 4
61905: PUSH
61906: LD_VAR 0 2
61910: PUSH
61911: LD_INT 1
61913: ARRAY
61914: PPUSH
61915: LD_VAR 0 2
61919: PUSH
61920: LD_INT 2
61922: ARRAY
61923: PPUSH
61924: LD_VAR 0 2
61928: PUSH
61929: LD_INT 3
61931: ARRAY
61932: PPUSH
61933: LD_VAR 0 2
61937: PUSH
61938: LD_INT 4
61940: ARRAY
61941: PPUSH
61942: CALL_OW 449
61946: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61947: LD_ADDR_VAR 0 3
61951: PUSH
61952: LD_VAR 0 5
61956: PPUSH
61957: LD_INT 1
61959: PPUSH
61960: CALL_OW 275
61964: PUSH
61965: LD_VAR 0 4
61969: PUSH
61970: LD_INT 1
61972: ARRAY
61973: GREATEREQUAL
61974: PUSH
61975: LD_VAR 0 5
61979: PPUSH
61980: LD_INT 2
61982: PPUSH
61983: CALL_OW 275
61987: PUSH
61988: LD_VAR 0 4
61992: PUSH
61993: LD_INT 2
61995: ARRAY
61996: GREATEREQUAL
61997: AND
61998: PUSH
61999: LD_VAR 0 5
62003: PPUSH
62004: LD_INT 3
62006: PPUSH
62007: CALL_OW 275
62011: PUSH
62012: LD_VAR 0 4
62016: PUSH
62017: LD_INT 3
62019: ARRAY
62020: GREATEREQUAL
62021: AND
62022: ST_TO_ADDR
// end ;
62023: LD_VAR 0 3
62027: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62028: LD_INT 0
62030: PPUSH
62031: PPUSH
62032: PPUSH
62033: PPUSH
// pom := GetBase ( building ) ;
62034: LD_ADDR_VAR 0 3
62038: PUSH
62039: LD_VAR 0 1
62043: PPUSH
62044: CALL_OW 274
62048: ST_TO_ADDR
// if not pom then
62049: LD_VAR 0 3
62053: NOT
62054: IFFALSE 62058
// exit ;
62056: GO 62228
// btype := GetBType ( building ) ;
62058: LD_ADDR_VAR 0 5
62062: PUSH
62063: LD_VAR 0 1
62067: PPUSH
62068: CALL_OW 266
62072: ST_TO_ADDR
// if btype = b_armoury then
62073: LD_VAR 0 5
62077: PUSH
62078: LD_INT 4
62080: EQUAL
62081: IFFALSE 62091
// btype := b_barracks ;
62083: LD_ADDR_VAR 0 5
62087: PUSH
62088: LD_INT 5
62090: ST_TO_ADDR
// if btype = b_depot then
62091: LD_VAR 0 5
62095: PUSH
62096: LD_INT 0
62098: EQUAL
62099: IFFALSE 62109
// btype := b_warehouse ;
62101: LD_ADDR_VAR 0 5
62105: PUSH
62106: LD_INT 1
62108: ST_TO_ADDR
// if btype = b_workshop then
62109: LD_VAR 0 5
62113: PUSH
62114: LD_INT 2
62116: EQUAL
62117: IFFALSE 62127
// btype := b_factory ;
62119: LD_ADDR_VAR 0 5
62123: PUSH
62124: LD_INT 3
62126: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62127: LD_ADDR_VAR 0 4
62131: PUSH
62132: LD_VAR 0 5
62136: PPUSH
62137: LD_VAR 0 1
62141: PPUSH
62142: CALL_OW 248
62146: PPUSH
62147: CALL_OW 450
62151: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62152: LD_ADDR_VAR 0 2
62156: PUSH
62157: LD_VAR 0 3
62161: PPUSH
62162: LD_INT 1
62164: PPUSH
62165: CALL_OW 275
62169: PUSH
62170: LD_VAR 0 4
62174: PUSH
62175: LD_INT 1
62177: ARRAY
62178: GREATEREQUAL
62179: PUSH
62180: LD_VAR 0 3
62184: PPUSH
62185: LD_INT 2
62187: PPUSH
62188: CALL_OW 275
62192: PUSH
62193: LD_VAR 0 4
62197: PUSH
62198: LD_INT 2
62200: ARRAY
62201: GREATEREQUAL
62202: AND
62203: PUSH
62204: LD_VAR 0 3
62208: PPUSH
62209: LD_INT 3
62211: PPUSH
62212: CALL_OW 275
62216: PUSH
62217: LD_VAR 0 4
62221: PUSH
62222: LD_INT 3
62224: ARRAY
62225: GREATEREQUAL
62226: AND
62227: ST_TO_ADDR
// end ;
62228: LD_VAR 0 2
62232: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62233: LD_INT 0
62235: PPUSH
62236: PPUSH
62237: PPUSH
// pom := GetBase ( building ) ;
62238: LD_ADDR_VAR 0 4
62242: PUSH
62243: LD_VAR 0 1
62247: PPUSH
62248: CALL_OW 274
62252: ST_TO_ADDR
// if not pom then
62253: LD_VAR 0 4
62257: NOT
62258: IFFALSE 62262
// exit ;
62260: GO 62363
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62262: LD_ADDR_VAR 0 5
62266: PUSH
62267: LD_VAR 0 2
62271: PPUSH
62272: LD_VAR 0 1
62276: PPUSH
62277: CALL_OW 248
62281: PPUSH
62282: CALL_OW 450
62286: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62287: LD_ADDR_VAR 0 3
62291: PUSH
62292: LD_VAR 0 4
62296: PPUSH
62297: LD_INT 1
62299: PPUSH
62300: CALL_OW 275
62304: PUSH
62305: LD_VAR 0 5
62309: PUSH
62310: LD_INT 1
62312: ARRAY
62313: GREATEREQUAL
62314: PUSH
62315: LD_VAR 0 4
62319: PPUSH
62320: LD_INT 2
62322: PPUSH
62323: CALL_OW 275
62327: PUSH
62328: LD_VAR 0 5
62332: PUSH
62333: LD_INT 2
62335: ARRAY
62336: GREATEREQUAL
62337: AND
62338: PUSH
62339: LD_VAR 0 4
62343: PPUSH
62344: LD_INT 3
62346: PPUSH
62347: CALL_OW 275
62351: PUSH
62352: LD_VAR 0 5
62356: PUSH
62357: LD_INT 3
62359: ARRAY
62360: GREATEREQUAL
62361: AND
62362: ST_TO_ADDR
// end ;
62363: LD_VAR 0 3
62367: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
62368: LD_INT 0
62370: PPUSH
62371: PPUSH
62372: PPUSH
62373: PPUSH
62374: PPUSH
62375: PPUSH
62376: PPUSH
62377: PPUSH
62378: PPUSH
62379: PPUSH
// result := false ;
62380: LD_ADDR_VAR 0 6
62384: PUSH
62385: LD_INT 0
62387: ST_TO_ADDR
// if not base or not btype or not x or not y then
62388: LD_VAR 0 1
62392: NOT
62393: PUSH
62394: LD_VAR 0 2
62398: NOT
62399: OR
62400: PUSH
62401: LD_VAR 0 3
62405: NOT
62406: OR
62407: PUSH
62408: LD_VAR 0 4
62412: NOT
62413: OR
62414: IFFALSE 62418
// exit ;
62416: GO 63027
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
62418: LD_ADDR_VAR 0 12
62422: PUSH
62423: LD_VAR 0 2
62427: PPUSH
62428: LD_VAR 0 3
62432: PPUSH
62433: LD_VAR 0 4
62437: PPUSH
62438: LD_VAR 0 5
62442: PPUSH
62443: LD_VAR 0 1
62447: PUSH
62448: LD_INT 1
62450: ARRAY
62451: PPUSH
62452: CALL_OW 248
62456: PPUSH
62457: LD_INT 0
62459: PPUSH
62460: CALL 63864 0 6
62464: ST_TO_ADDR
// if not hexes then
62465: LD_VAR 0 12
62469: NOT
62470: IFFALSE 62474
// exit ;
62472: GO 63027
// for i = 1 to hexes do
62474: LD_ADDR_VAR 0 7
62478: PUSH
62479: DOUBLE
62480: LD_INT 1
62482: DEC
62483: ST_TO_ADDR
62484: LD_VAR 0 12
62488: PUSH
62489: FOR_TO
62490: IFFALSE 63025
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62492: LD_ADDR_VAR 0 11
62496: PUSH
62497: LD_VAR 0 12
62501: PUSH
62502: LD_VAR 0 7
62506: ARRAY
62507: PUSH
62508: LD_INT 1
62510: ARRAY
62511: PPUSH
62512: LD_VAR 0 12
62516: PUSH
62517: LD_VAR 0 7
62521: ARRAY
62522: PUSH
62523: LD_INT 2
62525: ARRAY
62526: PPUSH
62527: CALL_OW 428
62531: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
62532: LD_VAR 0 12
62536: PUSH
62537: LD_VAR 0 7
62541: ARRAY
62542: PUSH
62543: LD_INT 1
62545: ARRAY
62546: PPUSH
62547: LD_VAR 0 12
62551: PUSH
62552: LD_VAR 0 7
62556: ARRAY
62557: PUSH
62558: LD_INT 2
62560: ARRAY
62561: PPUSH
62562: CALL_OW 351
62566: PUSH
62567: LD_VAR 0 12
62571: PUSH
62572: LD_VAR 0 7
62576: ARRAY
62577: PUSH
62578: LD_INT 1
62580: ARRAY
62581: PPUSH
62582: LD_VAR 0 12
62586: PUSH
62587: LD_VAR 0 7
62591: ARRAY
62592: PUSH
62593: LD_INT 2
62595: ARRAY
62596: PPUSH
62597: CALL_OW 488
62601: NOT
62602: OR
62603: PUSH
62604: LD_VAR 0 11
62608: PPUSH
62609: CALL_OW 247
62613: PUSH
62614: LD_INT 3
62616: EQUAL
62617: OR
62618: IFFALSE 62624
// exit ;
62620: POP
62621: POP
62622: GO 63027
// if not tmp or not tmp in base then
62624: LD_VAR 0 11
62628: NOT
62629: PUSH
62630: LD_VAR 0 11
62634: PUSH
62635: LD_VAR 0 1
62639: IN
62640: NOT
62641: OR
62642: IFFALSE 62646
// continue ;
62644: GO 62489
// result := true ;
62646: LD_ADDR_VAR 0 6
62650: PUSH
62651: LD_INT 1
62653: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
62654: LD_ADDR_VAR 0 15
62658: PUSH
62659: LD_VAR 0 1
62663: PPUSH
62664: LD_INT 22
62666: PUSH
62667: LD_VAR 0 11
62671: PPUSH
62672: CALL_OW 255
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: PUSH
62681: LD_INT 2
62683: PUSH
62684: LD_INT 30
62686: PUSH
62687: LD_INT 0
62689: PUSH
62690: EMPTY
62691: LIST
62692: LIST
62693: PUSH
62694: LD_INT 30
62696: PUSH
62697: LD_INT 1
62699: PUSH
62700: EMPTY
62701: LIST
62702: LIST
62703: PUSH
62704: EMPTY
62705: LIST
62706: LIST
62707: LIST
62708: PUSH
62709: EMPTY
62710: LIST
62711: LIST
62712: PPUSH
62713: CALL_OW 72
62717: ST_TO_ADDR
// if dep then
62718: LD_VAR 0 15
62722: IFFALSE 62858
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
62724: LD_ADDR_VAR 0 14
62728: PUSH
62729: LD_VAR 0 15
62733: PUSH
62734: LD_INT 1
62736: ARRAY
62737: PPUSH
62738: CALL_OW 250
62742: PPUSH
62743: LD_VAR 0 15
62747: PUSH
62748: LD_INT 1
62750: ARRAY
62751: PPUSH
62752: CALL_OW 254
62756: PPUSH
62757: LD_INT 5
62759: PPUSH
62760: CALL_OW 272
62764: PUSH
62765: LD_VAR 0 15
62769: PUSH
62770: LD_INT 1
62772: ARRAY
62773: PPUSH
62774: CALL_OW 251
62778: PPUSH
62779: LD_VAR 0 15
62783: PUSH
62784: LD_INT 1
62786: ARRAY
62787: PPUSH
62788: CALL_OW 254
62792: PPUSH
62793: LD_INT 5
62795: PPUSH
62796: CALL_OW 273
62800: PUSH
62801: EMPTY
62802: LIST
62803: LIST
62804: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
62805: LD_VAR 0 14
62809: PUSH
62810: LD_INT 1
62812: ARRAY
62813: PPUSH
62814: LD_VAR 0 14
62818: PUSH
62819: LD_INT 2
62821: ARRAY
62822: PPUSH
62823: CALL_OW 488
62827: IFFALSE 62858
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
62829: LD_VAR 0 11
62833: PPUSH
62834: LD_VAR 0 14
62838: PUSH
62839: LD_INT 1
62841: ARRAY
62842: PPUSH
62843: LD_VAR 0 14
62847: PUSH
62848: LD_INT 2
62850: ARRAY
62851: PPUSH
62852: CALL_OW 111
// continue ;
62856: GO 62489
// end ; end ; r := GetDir ( tmp ) ;
62858: LD_ADDR_VAR 0 13
62862: PUSH
62863: LD_VAR 0 11
62867: PPUSH
62868: CALL_OW 254
62872: ST_TO_ADDR
// if r = 5 then
62873: LD_VAR 0 13
62877: PUSH
62878: LD_INT 5
62880: EQUAL
62881: IFFALSE 62891
// r := 0 ;
62883: LD_ADDR_VAR 0 13
62887: PUSH
62888: LD_INT 0
62890: ST_TO_ADDR
// for j = r to 5 do
62891: LD_ADDR_VAR 0 8
62895: PUSH
62896: DOUBLE
62897: LD_VAR 0 13
62901: DEC
62902: ST_TO_ADDR
62903: LD_INT 5
62905: PUSH
62906: FOR_TO
62907: IFFALSE 63021
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62909: LD_ADDR_VAR 0 9
62913: PUSH
62914: LD_VAR 0 11
62918: PPUSH
62919: CALL_OW 250
62923: PPUSH
62924: LD_VAR 0 8
62928: PPUSH
62929: LD_INT 2
62931: PPUSH
62932: CALL_OW 272
62936: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62937: LD_ADDR_VAR 0 10
62941: PUSH
62942: LD_VAR 0 11
62946: PPUSH
62947: CALL_OW 251
62951: PPUSH
62952: LD_VAR 0 8
62956: PPUSH
62957: LD_INT 2
62959: PPUSH
62960: CALL_OW 273
62964: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
62965: LD_VAR 0 9
62969: PPUSH
62970: LD_VAR 0 10
62974: PPUSH
62975: CALL_OW 488
62979: PUSH
62980: LD_VAR 0 9
62984: PPUSH
62985: LD_VAR 0 10
62989: PPUSH
62990: CALL_OW 428
62994: NOT
62995: AND
62996: IFFALSE 63019
// begin ComMoveXY ( tmp , _x , _y ) ;
62998: LD_VAR 0 11
63002: PPUSH
63003: LD_VAR 0 9
63007: PPUSH
63008: LD_VAR 0 10
63012: PPUSH
63013: CALL_OW 111
// break ;
63017: GO 63021
// end ; end ;
63019: GO 62906
63021: POP
63022: POP
// end ;
63023: GO 62489
63025: POP
63026: POP
// end ;
63027: LD_VAR 0 6
63031: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
63032: LD_INT 0
63034: PPUSH
63035: PPUSH
63036: PPUSH
63037: PPUSH
63038: PPUSH
63039: PPUSH
63040: PPUSH
63041: PPUSH
63042: PPUSH
63043: PPUSH
// result := false ;
63044: LD_ADDR_VAR 0 6
63048: PUSH
63049: LD_INT 0
63051: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63052: LD_VAR 0 1
63056: NOT
63057: PUSH
63058: LD_VAR 0 1
63062: PPUSH
63063: CALL_OW 266
63067: PUSH
63068: LD_INT 0
63070: PUSH
63071: LD_INT 1
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: IN
63078: NOT
63079: OR
63080: PUSH
63081: LD_VAR 0 2
63085: NOT
63086: OR
63087: PUSH
63088: LD_VAR 0 5
63092: PUSH
63093: LD_INT 0
63095: PUSH
63096: LD_INT 1
63098: PUSH
63099: LD_INT 2
63101: PUSH
63102: LD_INT 3
63104: PUSH
63105: LD_INT 4
63107: PUSH
63108: LD_INT 5
63110: PUSH
63111: EMPTY
63112: LIST
63113: LIST
63114: LIST
63115: LIST
63116: LIST
63117: LIST
63118: IN
63119: NOT
63120: OR
63121: PUSH
63122: LD_VAR 0 3
63126: PPUSH
63127: LD_VAR 0 4
63131: PPUSH
63132: CALL_OW 488
63136: NOT
63137: OR
63138: IFFALSE 63142
// exit ;
63140: GO 63859
// pom := GetBase ( depot ) ;
63142: LD_ADDR_VAR 0 10
63146: PUSH
63147: LD_VAR 0 1
63151: PPUSH
63152: CALL_OW 274
63156: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63157: LD_ADDR_VAR 0 11
63161: PUSH
63162: LD_VAR 0 2
63166: PPUSH
63167: LD_VAR 0 1
63171: PPUSH
63172: CALL_OW 248
63176: PPUSH
63177: CALL_OW 450
63181: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63182: LD_VAR 0 10
63186: PPUSH
63187: LD_INT 1
63189: PPUSH
63190: CALL_OW 275
63194: PUSH
63195: LD_VAR 0 11
63199: PUSH
63200: LD_INT 1
63202: ARRAY
63203: GREATEREQUAL
63204: PUSH
63205: LD_VAR 0 10
63209: PPUSH
63210: LD_INT 2
63212: PPUSH
63213: CALL_OW 275
63217: PUSH
63218: LD_VAR 0 11
63222: PUSH
63223: LD_INT 2
63225: ARRAY
63226: GREATEREQUAL
63227: AND
63228: PUSH
63229: LD_VAR 0 10
63233: PPUSH
63234: LD_INT 3
63236: PPUSH
63237: CALL_OW 275
63241: PUSH
63242: LD_VAR 0 11
63246: PUSH
63247: LD_INT 3
63249: ARRAY
63250: GREATEREQUAL
63251: AND
63252: NOT
63253: IFFALSE 63257
// exit ;
63255: GO 63859
// if GetBType ( depot ) = b_depot then
63257: LD_VAR 0 1
63261: PPUSH
63262: CALL_OW 266
63266: PUSH
63267: LD_INT 0
63269: EQUAL
63270: IFFALSE 63282
// dist := 28 else
63272: LD_ADDR_VAR 0 14
63276: PUSH
63277: LD_INT 28
63279: ST_TO_ADDR
63280: GO 63290
// dist := 36 ;
63282: LD_ADDR_VAR 0 14
63286: PUSH
63287: LD_INT 36
63289: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63290: LD_VAR 0 1
63294: PPUSH
63295: LD_VAR 0 3
63299: PPUSH
63300: LD_VAR 0 4
63304: PPUSH
63305: CALL_OW 297
63309: PUSH
63310: LD_VAR 0 14
63314: GREATER
63315: IFFALSE 63319
// exit ;
63317: GO 63859
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63319: LD_ADDR_VAR 0 12
63323: PUSH
63324: LD_VAR 0 2
63328: PPUSH
63329: LD_VAR 0 3
63333: PPUSH
63334: LD_VAR 0 4
63338: PPUSH
63339: LD_VAR 0 5
63343: PPUSH
63344: LD_VAR 0 1
63348: PPUSH
63349: CALL_OW 248
63353: PPUSH
63354: LD_INT 0
63356: PPUSH
63357: CALL 63864 0 6
63361: ST_TO_ADDR
// if not hexes then
63362: LD_VAR 0 12
63366: NOT
63367: IFFALSE 63371
// exit ;
63369: GO 63859
// hex := GetHexInfo ( x , y ) ;
63371: LD_ADDR_VAR 0 15
63375: PUSH
63376: LD_VAR 0 3
63380: PPUSH
63381: LD_VAR 0 4
63385: PPUSH
63386: CALL_OW 546
63390: ST_TO_ADDR
// if hex [ 1 ] then
63391: LD_VAR 0 15
63395: PUSH
63396: LD_INT 1
63398: ARRAY
63399: IFFALSE 63403
// exit ;
63401: GO 63859
// height := hex [ 2 ] ;
63403: LD_ADDR_VAR 0 13
63407: PUSH
63408: LD_VAR 0 15
63412: PUSH
63413: LD_INT 2
63415: ARRAY
63416: ST_TO_ADDR
// for i = 1 to hexes do
63417: LD_ADDR_VAR 0 7
63421: PUSH
63422: DOUBLE
63423: LD_INT 1
63425: DEC
63426: ST_TO_ADDR
63427: LD_VAR 0 12
63431: PUSH
63432: FOR_TO
63433: IFFALSE 63763
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63435: LD_VAR 0 12
63439: PUSH
63440: LD_VAR 0 7
63444: ARRAY
63445: PUSH
63446: LD_INT 1
63448: ARRAY
63449: PPUSH
63450: LD_VAR 0 12
63454: PUSH
63455: LD_VAR 0 7
63459: ARRAY
63460: PUSH
63461: LD_INT 2
63463: ARRAY
63464: PPUSH
63465: CALL_OW 488
63469: NOT
63470: PUSH
63471: LD_VAR 0 12
63475: PUSH
63476: LD_VAR 0 7
63480: ARRAY
63481: PUSH
63482: LD_INT 1
63484: ARRAY
63485: PPUSH
63486: LD_VAR 0 12
63490: PUSH
63491: LD_VAR 0 7
63495: ARRAY
63496: PUSH
63497: LD_INT 2
63499: ARRAY
63500: PPUSH
63501: CALL_OW 428
63505: PUSH
63506: LD_INT 0
63508: GREATER
63509: OR
63510: PUSH
63511: LD_VAR 0 12
63515: PUSH
63516: LD_VAR 0 7
63520: ARRAY
63521: PUSH
63522: LD_INT 1
63524: ARRAY
63525: PPUSH
63526: LD_VAR 0 12
63530: PUSH
63531: LD_VAR 0 7
63535: ARRAY
63536: PUSH
63537: LD_INT 2
63539: ARRAY
63540: PPUSH
63541: CALL_OW 351
63545: OR
63546: IFFALSE 63552
// exit ;
63548: POP
63549: POP
63550: GO 63859
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63552: LD_ADDR_VAR 0 8
63556: PUSH
63557: LD_VAR 0 12
63561: PUSH
63562: LD_VAR 0 7
63566: ARRAY
63567: PUSH
63568: LD_INT 1
63570: ARRAY
63571: PPUSH
63572: LD_VAR 0 12
63576: PUSH
63577: LD_VAR 0 7
63581: ARRAY
63582: PUSH
63583: LD_INT 2
63585: ARRAY
63586: PPUSH
63587: CALL_OW 546
63591: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63592: LD_VAR 0 8
63596: PUSH
63597: LD_INT 1
63599: ARRAY
63600: PUSH
63601: LD_VAR 0 8
63605: PUSH
63606: LD_INT 2
63608: ARRAY
63609: PUSH
63610: LD_VAR 0 13
63614: PUSH
63615: LD_INT 2
63617: PLUS
63618: GREATER
63619: OR
63620: PUSH
63621: LD_VAR 0 8
63625: PUSH
63626: LD_INT 2
63628: ARRAY
63629: PUSH
63630: LD_VAR 0 13
63634: PUSH
63635: LD_INT 2
63637: MINUS
63638: LESS
63639: OR
63640: PUSH
63641: LD_VAR 0 8
63645: PUSH
63646: LD_INT 3
63648: ARRAY
63649: PUSH
63650: LD_INT 0
63652: PUSH
63653: LD_INT 8
63655: PUSH
63656: LD_INT 9
63658: PUSH
63659: LD_INT 10
63661: PUSH
63662: LD_INT 11
63664: PUSH
63665: LD_INT 12
63667: PUSH
63668: LD_INT 13
63670: PUSH
63671: LD_INT 16
63673: PUSH
63674: LD_INT 17
63676: PUSH
63677: LD_INT 18
63679: PUSH
63680: LD_INT 19
63682: PUSH
63683: LD_INT 20
63685: PUSH
63686: LD_INT 21
63688: PUSH
63689: EMPTY
63690: LIST
63691: LIST
63692: LIST
63693: LIST
63694: LIST
63695: LIST
63696: LIST
63697: LIST
63698: LIST
63699: LIST
63700: LIST
63701: LIST
63702: LIST
63703: IN
63704: NOT
63705: OR
63706: PUSH
63707: LD_VAR 0 8
63711: PUSH
63712: LD_INT 5
63714: ARRAY
63715: NOT
63716: OR
63717: PUSH
63718: LD_VAR 0 8
63722: PUSH
63723: LD_INT 6
63725: ARRAY
63726: PUSH
63727: LD_INT 1
63729: PUSH
63730: LD_INT 2
63732: PUSH
63733: LD_INT 7
63735: PUSH
63736: LD_INT 9
63738: PUSH
63739: LD_INT 10
63741: PUSH
63742: LD_INT 11
63744: PUSH
63745: EMPTY
63746: LIST
63747: LIST
63748: LIST
63749: LIST
63750: LIST
63751: LIST
63752: IN
63753: NOT
63754: OR
63755: IFFALSE 63761
// exit ;
63757: POP
63758: POP
63759: GO 63859
// end ;
63761: GO 63432
63763: POP
63764: POP
// side := GetSide ( depot ) ;
63765: LD_ADDR_VAR 0 9
63769: PUSH
63770: LD_VAR 0 1
63774: PPUSH
63775: CALL_OW 255
63779: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63780: LD_VAR 0 9
63784: PPUSH
63785: LD_VAR 0 3
63789: PPUSH
63790: LD_VAR 0 4
63794: PPUSH
63795: LD_INT 20
63797: PPUSH
63798: CALL 56513 0 4
63802: PUSH
63803: LD_INT 4
63805: ARRAY
63806: IFFALSE 63810
// exit ;
63808: GO 63859
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63810: LD_VAR 0 2
63814: PUSH
63815: LD_INT 29
63817: PUSH
63818: LD_INT 30
63820: PUSH
63821: EMPTY
63822: LIST
63823: LIST
63824: IN
63825: PUSH
63826: LD_VAR 0 3
63830: PPUSH
63831: LD_VAR 0 4
63835: PPUSH
63836: LD_VAR 0 9
63840: PPUSH
63841: CALL_OW 440
63845: NOT
63846: AND
63847: IFFALSE 63851
// exit ;
63849: GO 63859
// result := true ;
63851: LD_ADDR_VAR 0 6
63855: PUSH
63856: LD_INT 1
63858: ST_TO_ADDR
// end ;
63859: LD_VAR 0 6
63863: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
63864: LD_INT 0
63866: PPUSH
63867: PPUSH
63868: PPUSH
63869: PPUSH
63870: PPUSH
63871: PPUSH
63872: PPUSH
63873: PPUSH
63874: PPUSH
63875: PPUSH
63876: PPUSH
63877: PPUSH
63878: PPUSH
63879: PPUSH
63880: PPUSH
63881: PPUSH
63882: PPUSH
63883: PPUSH
63884: PPUSH
63885: PPUSH
63886: PPUSH
63887: PPUSH
63888: PPUSH
63889: PPUSH
63890: PPUSH
63891: PPUSH
63892: PPUSH
63893: PPUSH
63894: PPUSH
63895: PPUSH
63896: PPUSH
63897: PPUSH
63898: PPUSH
63899: PPUSH
63900: PPUSH
63901: PPUSH
63902: PPUSH
63903: PPUSH
63904: PPUSH
63905: PPUSH
63906: PPUSH
63907: PPUSH
63908: PPUSH
63909: PPUSH
63910: PPUSH
63911: PPUSH
63912: PPUSH
63913: PPUSH
63914: PPUSH
63915: PPUSH
63916: PPUSH
63917: PPUSH
63918: PPUSH
63919: PPUSH
63920: PPUSH
63921: PPUSH
63922: PPUSH
63923: PPUSH
// result = [ ] ;
63924: LD_ADDR_VAR 0 7
63928: PUSH
63929: EMPTY
63930: ST_TO_ADDR
// temp_list = [ ] ;
63931: LD_ADDR_VAR 0 9
63935: PUSH
63936: EMPTY
63937: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63938: LD_VAR 0 4
63942: PUSH
63943: LD_INT 0
63945: PUSH
63946: LD_INT 1
63948: PUSH
63949: LD_INT 2
63951: PUSH
63952: LD_INT 3
63954: PUSH
63955: LD_INT 4
63957: PUSH
63958: LD_INT 5
63960: PUSH
63961: EMPTY
63962: LIST
63963: LIST
63964: LIST
63965: LIST
63966: LIST
63967: LIST
63968: IN
63969: NOT
63970: PUSH
63971: LD_VAR 0 1
63975: PUSH
63976: LD_INT 0
63978: PUSH
63979: LD_INT 1
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: IN
63986: PUSH
63987: LD_VAR 0 5
63991: PUSH
63992: LD_INT 1
63994: PUSH
63995: LD_INT 2
63997: PUSH
63998: LD_INT 3
64000: PUSH
64001: EMPTY
64002: LIST
64003: LIST
64004: LIST
64005: IN
64006: NOT
64007: AND
64008: OR
64009: IFFALSE 64013
// exit ;
64011: GO 82404
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64013: LD_VAR 0 1
64017: PUSH
64018: LD_INT 6
64020: PUSH
64021: LD_INT 7
64023: PUSH
64024: LD_INT 8
64026: PUSH
64027: LD_INT 13
64029: PUSH
64030: LD_INT 12
64032: PUSH
64033: LD_INT 15
64035: PUSH
64036: LD_INT 11
64038: PUSH
64039: LD_INT 14
64041: PUSH
64042: LD_INT 10
64044: PUSH
64045: EMPTY
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: IN
64056: IFFALSE 64066
// btype = b_lab ;
64058: LD_ADDR_VAR 0 1
64062: PUSH
64063: LD_INT 6
64065: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64066: LD_VAR 0 6
64070: PUSH
64071: LD_INT 0
64073: PUSH
64074: LD_INT 1
64076: PUSH
64077: LD_INT 2
64079: PUSH
64080: EMPTY
64081: LIST
64082: LIST
64083: LIST
64084: IN
64085: NOT
64086: PUSH
64087: LD_VAR 0 1
64091: PUSH
64092: LD_INT 0
64094: PUSH
64095: LD_INT 1
64097: PUSH
64098: LD_INT 2
64100: PUSH
64101: LD_INT 3
64103: PUSH
64104: LD_INT 6
64106: PUSH
64107: LD_INT 36
64109: PUSH
64110: LD_INT 4
64112: PUSH
64113: LD_INT 5
64115: PUSH
64116: LD_INT 31
64118: PUSH
64119: LD_INT 32
64121: PUSH
64122: LD_INT 33
64124: PUSH
64125: EMPTY
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: IN
64138: NOT
64139: PUSH
64140: LD_VAR 0 6
64144: PUSH
64145: LD_INT 1
64147: EQUAL
64148: AND
64149: OR
64150: PUSH
64151: LD_VAR 0 1
64155: PUSH
64156: LD_INT 2
64158: PUSH
64159: LD_INT 3
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: IN
64166: NOT
64167: PUSH
64168: LD_VAR 0 6
64172: PUSH
64173: LD_INT 2
64175: EQUAL
64176: AND
64177: OR
64178: IFFALSE 64188
// mode = 0 ;
64180: LD_ADDR_VAR 0 6
64184: PUSH
64185: LD_INT 0
64187: ST_TO_ADDR
// case mode of 0 :
64188: LD_VAR 0 6
64192: PUSH
64193: LD_INT 0
64195: DOUBLE
64196: EQUAL
64197: IFTRUE 64201
64199: GO 75654
64201: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64202: LD_ADDR_VAR 0 11
64206: PUSH
64207: LD_INT 0
64209: PUSH
64210: LD_INT 0
64212: PUSH
64213: EMPTY
64214: LIST
64215: LIST
64216: PUSH
64217: LD_INT 0
64219: PUSH
64220: LD_INT 1
64222: NEG
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: PUSH
64228: LD_INT 1
64230: PUSH
64231: LD_INT 0
64233: PUSH
64234: EMPTY
64235: LIST
64236: LIST
64237: PUSH
64238: LD_INT 1
64240: PUSH
64241: LD_INT 1
64243: PUSH
64244: EMPTY
64245: LIST
64246: LIST
64247: PUSH
64248: LD_INT 0
64250: PUSH
64251: LD_INT 1
64253: PUSH
64254: EMPTY
64255: LIST
64256: LIST
64257: PUSH
64258: LD_INT 1
64260: NEG
64261: PUSH
64262: LD_INT 0
64264: PUSH
64265: EMPTY
64266: LIST
64267: LIST
64268: PUSH
64269: LD_INT 1
64271: NEG
64272: PUSH
64273: LD_INT 1
64275: NEG
64276: PUSH
64277: EMPTY
64278: LIST
64279: LIST
64280: PUSH
64281: LD_INT 1
64283: NEG
64284: PUSH
64285: LD_INT 2
64287: NEG
64288: PUSH
64289: EMPTY
64290: LIST
64291: LIST
64292: PUSH
64293: LD_INT 0
64295: PUSH
64296: LD_INT 2
64298: NEG
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: LD_INT 1
64306: PUSH
64307: LD_INT 1
64309: NEG
64310: PUSH
64311: EMPTY
64312: LIST
64313: LIST
64314: PUSH
64315: LD_INT 1
64317: PUSH
64318: LD_INT 2
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 0
64327: PUSH
64328: LD_INT 2
64330: PUSH
64331: EMPTY
64332: LIST
64333: LIST
64334: PUSH
64335: LD_INT 1
64337: NEG
64338: PUSH
64339: LD_INT 1
64341: PUSH
64342: EMPTY
64343: LIST
64344: LIST
64345: PUSH
64346: LD_INT 1
64348: PUSH
64349: LD_INT 3
64351: PUSH
64352: EMPTY
64353: LIST
64354: LIST
64355: PUSH
64356: LD_INT 0
64358: PUSH
64359: LD_INT 3
64361: PUSH
64362: EMPTY
64363: LIST
64364: LIST
64365: PUSH
64366: LD_INT 1
64368: NEG
64369: PUSH
64370: LD_INT 2
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: EMPTY
64378: LIST
64379: LIST
64380: LIST
64381: LIST
64382: LIST
64383: LIST
64384: LIST
64385: LIST
64386: LIST
64387: LIST
64388: LIST
64389: LIST
64390: LIST
64391: LIST
64392: LIST
64393: LIST
64394: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64395: LD_ADDR_VAR 0 12
64399: PUSH
64400: LD_INT 0
64402: PUSH
64403: LD_INT 0
64405: PUSH
64406: EMPTY
64407: LIST
64408: LIST
64409: PUSH
64410: LD_INT 0
64412: PUSH
64413: LD_INT 1
64415: NEG
64416: PUSH
64417: EMPTY
64418: LIST
64419: LIST
64420: PUSH
64421: LD_INT 1
64423: PUSH
64424: LD_INT 0
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: LD_INT 1
64433: PUSH
64434: LD_INT 1
64436: PUSH
64437: EMPTY
64438: LIST
64439: LIST
64440: PUSH
64441: LD_INT 0
64443: PUSH
64444: LD_INT 1
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: PUSH
64451: LD_INT 1
64453: NEG
64454: PUSH
64455: LD_INT 0
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: PUSH
64462: LD_INT 1
64464: NEG
64465: PUSH
64466: LD_INT 1
64468: NEG
64469: PUSH
64470: EMPTY
64471: LIST
64472: LIST
64473: PUSH
64474: LD_INT 1
64476: PUSH
64477: LD_INT 1
64479: NEG
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: PUSH
64485: LD_INT 2
64487: PUSH
64488: LD_INT 0
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: PUSH
64495: LD_INT 2
64497: PUSH
64498: LD_INT 1
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PUSH
64505: LD_INT 1
64507: NEG
64508: PUSH
64509: LD_INT 1
64511: PUSH
64512: EMPTY
64513: LIST
64514: LIST
64515: PUSH
64516: LD_INT 2
64518: NEG
64519: PUSH
64520: LD_INT 0
64522: PUSH
64523: EMPTY
64524: LIST
64525: LIST
64526: PUSH
64527: LD_INT 2
64529: NEG
64530: PUSH
64531: LD_INT 1
64533: NEG
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: PUSH
64539: LD_INT 2
64541: NEG
64542: PUSH
64543: LD_INT 1
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 3
64552: NEG
64553: PUSH
64554: LD_INT 0
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: LD_INT 3
64563: NEG
64564: PUSH
64565: LD_INT 1
64567: NEG
64568: PUSH
64569: EMPTY
64570: LIST
64571: LIST
64572: PUSH
64573: EMPTY
64574: LIST
64575: LIST
64576: LIST
64577: LIST
64578: LIST
64579: LIST
64580: LIST
64581: LIST
64582: LIST
64583: LIST
64584: LIST
64585: LIST
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64591: LD_ADDR_VAR 0 13
64595: PUSH
64596: LD_INT 0
64598: PUSH
64599: LD_INT 0
64601: PUSH
64602: EMPTY
64603: LIST
64604: LIST
64605: PUSH
64606: LD_INT 0
64608: PUSH
64609: LD_INT 1
64611: NEG
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: PUSH
64617: LD_INT 1
64619: PUSH
64620: LD_INT 0
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PUSH
64627: LD_INT 1
64629: PUSH
64630: LD_INT 1
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: PUSH
64637: LD_INT 0
64639: PUSH
64640: LD_INT 1
64642: PUSH
64643: EMPTY
64644: LIST
64645: LIST
64646: PUSH
64647: LD_INT 1
64649: NEG
64650: PUSH
64651: LD_INT 0
64653: PUSH
64654: EMPTY
64655: LIST
64656: LIST
64657: PUSH
64658: LD_INT 1
64660: NEG
64661: PUSH
64662: LD_INT 1
64664: NEG
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: PUSH
64670: LD_INT 1
64672: NEG
64673: PUSH
64674: LD_INT 2
64676: NEG
64677: PUSH
64678: EMPTY
64679: LIST
64680: LIST
64681: PUSH
64682: LD_INT 2
64684: PUSH
64685: LD_INT 1
64687: PUSH
64688: EMPTY
64689: LIST
64690: LIST
64691: PUSH
64692: LD_INT 2
64694: PUSH
64695: LD_INT 2
64697: PUSH
64698: EMPTY
64699: LIST
64700: LIST
64701: PUSH
64702: LD_INT 1
64704: PUSH
64705: LD_INT 2
64707: PUSH
64708: EMPTY
64709: LIST
64710: LIST
64711: PUSH
64712: LD_INT 2
64714: NEG
64715: PUSH
64716: LD_INT 1
64718: NEG
64719: PUSH
64720: EMPTY
64721: LIST
64722: LIST
64723: PUSH
64724: LD_INT 2
64726: NEG
64727: PUSH
64728: LD_INT 2
64730: NEG
64731: PUSH
64732: EMPTY
64733: LIST
64734: LIST
64735: PUSH
64736: LD_INT 2
64738: NEG
64739: PUSH
64740: LD_INT 3
64742: NEG
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: PUSH
64748: LD_INT 3
64750: NEG
64751: PUSH
64752: LD_INT 2
64754: NEG
64755: PUSH
64756: EMPTY
64757: LIST
64758: LIST
64759: PUSH
64760: LD_INT 3
64762: NEG
64763: PUSH
64764: LD_INT 3
64766: NEG
64767: PUSH
64768: EMPTY
64769: LIST
64770: LIST
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: LIST
64782: LIST
64783: LIST
64784: LIST
64785: LIST
64786: LIST
64787: LIST
64788: LIST
64789: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64790: LD_ADDR_VAR 0 14
64794: PUSH
64795: LD_INT 0
64797: PUSH
64798: LD_INT 0
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PUSH
64805: LD_INT 0
64807: PUSH
64808: LD_INT 1
64810: NEG
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: PUSH
64816: LD_INT 1
64818: PUSH
64819: LD_INT 0
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: PUSH
64826: LD_INT 1
64828: PUSH
64829: LD_INT 1
64831: PUSH
64832: EMPTY
64833: LIST
64834: LIST
64835: PUSH
64836: LD_INT 0
64838: PUSH
64839: LD_INT 1
64841: PUSH
64842: EMPTY
64843: LIST
64844: LIST
64845: PUSH
64846: LD_INT 1
64848: NEG
64849: PUSH
64850: LD_INT 0
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PUSH
64857: LD_INT 1
64859: NEG
64860: PUSH
64861: LD_INT 1
64863: NEG
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: PUSH
64869: LD_INT 1
64871: NEG
64872: PUSH
64873: LD_INT 2
64875: NEG
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PUSH
64881: LD_INT 0
64883: PUSH
64884: LD_INT 2
64886: NEG
64887: PUSH
64888: EMPTY
64889: LIST
64890: LIST
64891: PUSH
64892: LD_INT 1
64894: PUSH
64895: LD_INT 1
64897: NEG
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 1
64905: PUSH
64906: LD_INT 2
64908: PUSH
64909: EMPTY
64910: LIST
64911: LIST
64912: PUSH
64913: LD_INT 0
64915: PUSH
64916: LD_INT 2
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: LD_INT 1
64925: NEG
64926: PUSH
64927: LD_INT 1
64929: PUSH
64930: EMPTY
64931: LIST
64932: LIST
64933: PUSH
64934: LD_INT 1
64936: NEG
64937: PUSH
64938: LD_INT 3
64940: NEG
64941: PUSH
64942: EMPTY
64943: LIST
64944: LIST
64945: PUSH
64946: LD_INT 0
64948: PUSH
64949: LD_INT 3
64951: NEG
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 1
64959: PUSH
64960: LD_INT 2
64962: NEG
64963: PUSH
64964: EMPTY
64965: LIST
64966: LIST
64967: PUSH
64968: EMPTY
64969: LIST
64970: LIST
64971: LIST
64972: LIST
64973: LIST
64974: LIST
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: LIST
64985: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64986: LD_ADDR_VAR 0 15
64990: PUSH
64991: LD_INT 0
64993: PUSH
64994: LD_INT 0
64996: PUSH
64997: EMPTY
64998: LIST
64999: LIST
65000: PUSH
65001: LD_INT 0
65003: PUSH
65004: LD_INT 1
65006: NEG
65007: PUSH
65008: EMPTY
65009: LIST
65010: LIST
65011: PUSH
65012: LD_INT 1
65014: PUSH
65015: LD_INT 0
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: PUSH
65022: LD_INT 1
65024: PUSH
65025: LD_INT 1
65027: PUSH
65028: EMPTY
65029: LIST
65030: LIST
65031: PUSH
65032: LD_INT 0
65034: PUSH
65035: LD_INT 1
65037: PUSH
65038: EMPTY
65039: LIST
65040: LIST
65041: PUSH
65042: LD_INT 1
65044: NEG
65045: PUSH
65046: LD_INT 0
65048: PUSH
65049: EMPTY
65050: LIST
65051: LIST
65052: PUSH
65053: LD_INT 1
65055: NEG
65056: PUSH
65057: LD_INT 1
65059: NEG
65060: PUSH
65061: EMPTY
65062: LIST
65063: LIST
65064: PUSH
65065: LD_INT 1
65067: PUSH
65068: LD_INT 1
65070: NEG
65071: PUSH
65072: EMPTY
65073: LIST
65074: LIST
65075: PUSH
65076: LD_INT 2
65078: PUSH
65079: LD_INT 0
65081: PUSH
65082: EMPTY
65083: LIST
65084: LIST
65085: PUSH
65086: LD_INT 2
65088: PUSH
65089: LD_INT 1
65091: PUSH
65092: EMPTY
65093: LIST
65094: LIST
65095: PUSH
65096: LD_INT 1
65098: NEG
65099: PUSH
65100: LD_INT 1
65102: PUSH
65103: EMPTY
65104: LIST
65105: LIST
65106: PUSH
65107: LD_INT 2
65109: NEG
65110: PUSH
65111: LD_INT 0
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 2
65120: NEG
65121: PUSH
65122: LD_INT 1
65124: NEG
65125: PUSH
65126: EMPTY
65127: LIST
65128: LIST
65129: PUSH
65130: LD_INT 2
65132: PUSH
65133: LD_INT 1
65135: NEG
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: LD_INT 3
65143: PUSH
65144: LD_INT 0
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: PUSH
65151: LD_INT 3
65153: PUSH
65154: LD_INT 1
65156: PUSH
65157: EMPTY
65158: LIST
65159: LIST
65160: PUSH
65161: EMPTY
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: LIST
65178: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65179: LD_ADDR_VAR 0 16
65183: PUSH
65184: LD_INT 0
65186: PUSH
65187: LD_INT 0
65189: PUSH
65190: EMPTY
65191: LIST
65192: LIST
65193: PUSH
65194: LD_INT 0
65196: PUSH
65197: LD_INT 1
65199: NEG
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: PUSH
65205: LD_INT 1
65207: PUSH
65208: LD_INT 0
65210: PUSH
65211: EMPTY
65212: LIST
65213: LIST
65214: PUSH
65215: LD_INT 1
65217: PUSH
65218: LD_INT 1
65220: PUSH
65221: EMPTY
65222: LIST
65223: LIST
65224: PUSH
65225: LD_INT 0
65227: PUSH
65228: LD_INT 1
65230: PUSH
65231: EMPTY
65232: LIST
65233: LIST
65234: PUSH
65235: LD_INT 1
65237: NEG
65238: PUSH
65239: LD_INT 0
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: PUSH
65246: LD_INT 1
65248: NEG
65249: PUSH
65250: LD_INT 1
65252: NEG
65253: PUSH
65254: EMPTY
65255: LIST
65256: LIST
65257: PUSH
65258: LD_INT 1
65260: NEG
65261: PUSH
65262: LD_INT 2
65264: NEG
65265: PUSH
65266: EMPTY
65267: LIST
65268: LIST
65269: PUSH
65270: LD_INT 2
65272: PUSH
65273: LD_INT 1
65275: PUSH
65276: EMPTY
65277: LIST
65278: LIST
65279: PUSH
65280: LD_INT 2
65282: PUSH
65283: LD_INT 2
65285: PUSH
65286: EMPTY
65287: LIST
65288: LIST
65289: PUSH
65290: LD_INT 1
65292: PUSH
65293: LD_INT 2
65295: PUSH
65296: EMPTY
65297: LIST
65298: LIST
65299: PUSH
65300: LD_INT 2
65302: NEG
65303: PUSH
65304: LD_INT 1
65306: NEG
65307: PUSH
65308: EMPTY
65309: LIST
65310: LIST
65311: PUSH
65312: LD_INT 2
65314: NEG
65315: PUSH
65316: LD_INT 2
65318: NEG
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: LD_INT 3
65326: PUSH
65327: LD_INT 2
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: LD_INT 3
65336: PUSH
65337: LD_INT 3
65339: PUSH
65340: EMPTY
65341: LIST
65342: LIST
65343: PUSH
65344: LD_INT 2
65346: PUSH
65347: LD_INT 3
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: EMPTY
65355: LIST
65356: LIST
65357: LIST
65358: LIST
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65372: LD_ADDR_VAR 0 17
65376: PUSH
65377: LD_INT 0
65379: PUSH
65380: LD_INT 0
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: PUSH
65387: LD_INT 0
65389: PUSH
65390: LD_INT 1
65392: NEG
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: PUSH
65398: LD_INT 1
65400: PUSH
65401: LD_INT 0
65403: PUSH
65404: EMPTY
65405: LIST
65406: LIST
65407: PUSH
65408: LD_INT 1
65410: PUSH
65411: LD_INT 1
65413: PUSH
65414: EMPTY
65415: LIST
65416: LIST
65417: PUSH
65418: LD_INT 0
65420: PUSH
65421: LD_INT 1
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 1
65430: NEG
65431: PUSH
65432: LD_INT 0
65434: PUSH
65435: EMPTY
65436: LIST
65437: LIST
65438: PUSH
65439: LD_INT 1
65441: NEG
65442: PUSH
65443: LD_INT 1
65445: NEG
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: PUSH
65451: LD_INT 1
65453: NEG
65454: PUSH
65455: LD_INT 2
65457: NEG
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PUSH
65463: LD_INT 0
65465: PUSH
65466: LD_INT 2
65468: NEG
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: LD_INT 1
65476: PUSH
65477: LD_INT 1
65479: NEG
65480: PUSH
65481: EMPTY
65482: LIST
65483: LIST
65484: PUSH
65485: LD_INT 2
65487: PUSH
65488: LD_INT 0
65490: PUSH
65491: EMPTY
65492: LIST
65493: LIST
65494: PUSH
65495: LD_INT 2
65497: PUSH
65498: LD_INT 1
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PUSH
65505: LD_INT 2
65507: PUSH
65508: LD_INT 2
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PUSH
65515: LD_INT 1
65517: PUSH
65518: LD_INT 2
65520: PUSH
65521: EMPTY
65522: LIST
65523: LIST
65524: PUSH
65525: LD_INT 0
65527: PUSH
65528: LD_INT 2
65530: PUSH
65531: EMPTY
65532: LIST
65533: LIST
65534: PUSH
65535: LD_INT 1
65537: NEG
65538: PUSH
65539: LD_INT 1
65541: PUSH
65542: EMPTY
65543: LIST
65544: LIST
65545: PUSH
65546: LD_INT 2
65548: NEG
65549: PUSH
65550: LD_INT 0
65552: PUSH
65553: EMPTY
65554: LIST
65555: LIST
65556: PUSH
65557: LD_INT 2
65559: NEG
65560: PUSH
65561: LD_INT 1
65563: NEG
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 2
65571: NEG
65572: PUSH
65573: LD_INT 2
65575: NEG
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: EMPTY
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65602: LD_ADDR_VAR 0 18
65606: PUSH
65607: LD_INT 0
65609: PUSH
65610: LD_INT 0
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: PUSH
65617: LD_INT 0
65619: PUSH
65620: LD_INT 1
65622: NEG
65623: PUSH
65624: EMPTY
65625: LIST
65626: LIST
65627: PUSH
65628: LD_INT 1
65630: PUSH
65631: LD_INT 0
65633: PUSH
65634: EMPTY
65635: LIST
65636: LIST
65637: PUSH
65638: LD_INT 1
65640: PUSH
65641: LD_INT 1
65643: PUSH
65644: EMPTY
65645: LIST
65646: LIST
65647: PUSH
65648: LD_INT 0
65650: PUSH
65651: LD_INT 1
65653: PUSH
65654: EMPTY
65655: LIST
65656: LIST
65657: PUSH
65658: LD_INT 1
65660: NEG
65661: PUSH
65662: LD_INT 0
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: PUSH
65669: LD_INT 1
65671: NEG
65672: PUSH
65673: LD_INT 1
65675: NEG
65676: PUSH
65677: EMPTY
65678: LIST
65679: LIST
65680: PUSH
65681: LD_INT 1
65683: NEG
65684: PUSH
65685: LD_INT 2
65687: NEG
65688: PUSH
65689: EMPTY
65690: LIST
65691: LIST
65692: PUSH
65693: LD_INT 0
65695: PUSH
65696: LD_INT 2
65698: NEG
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: LD_INT 1
65706: PUSH
65707: LD_INT 1
65709: NEG
65710: PUSH
65711: EMPTY
65712: LIST
65713: LIST
65714: PUSH
65715: LD_INT 2
65717: PUSH
65718: LD_INT 0
65720: PUSH
65721: EMPTY
65722: LIST
65723: LIST
65724: PUSH
65725: LD_INT 2
65727: PUSH
65728: LD_INT 1
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: LD_INT 2
65737: PUSH
65738: LD_INT 2
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: PUSH
65745: LD_INT 1
65747: PUSH
65748: LD_INT 2
65750: PUSH
65751: EMPTY
65752: LIST
65753: LIST
65754: PUSH
65755: LD_INT 0
65757: PUSH
65758: LD_INT 2
65760: PUSH
65761: EMPTY
65762: LIST
65763: LIST
65764: PUSH
65765: LD_INT 1
65767: NEG
65768: PUSH
65769: LD_INT 1
65771: PUSH
65772: EMPTY
65773: LIST
65774: LIST
65775: PUSH
65776: LD_INT 2
65778: NEG
65779: PUSH
65780: LD_INT 0
65782: PUSH
65783: EMPTY
65784: LIST
65785: LIST
65786: PUSH
65787: LD_INT 2
65789: NEG
65790: PUSH
65791: LD_INT 1
65793: NEG
65794: PUSH
65795: EMPTY
65796: LIST
65797: LIST
65798: PUSH
65799: LD_INT 2
65801: NEG
65802: PUSH
65803: LD_INT 2
65805: NEG
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65832: LD_ADDR_VAR 0 19
65836: PUSH
65837: LD_INT 0
65839: PUSH
65840: LD_INT 0
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: PUSH
65847: LD_INT 0
65849: PUSH
65850: LD_INT 1
65852: NEG
65853: PUSH
65854: EMPTY
65855: LIST
65856: LIST
65857: PUSH
65858: LD_INT 1
65860: PUSH
65861: LD_INT 0
65863: PUSH
65864: EMPTY
65865: LIST
65866: LIST
65867: PUSH
65868: LD_INT 1
65870: PUSH
65871: LD_INT 1
65873: PUSH
65874: EMPTY
65875: LIST
65876: LIST
65877: PUSH
65878: LD_INT 0
65880: PUSH
65881: LD_INT 1
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: PUSH
65888: LD_INT 1
65890: NEG
65891: PUSH
65892: LD_INT 0
65894: PUSH
65895: EMPTY
65896: LIST
65897: LIST
65898: PUSH
65899: LD_INT 1
65901: NEG
65902: PUSH
65903: LD_INT 1
65905: NEG
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 1
65913: NEG
65914: PUSH
65915: LD_INT 2
65917: NEG
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: LD_INT 0
65925: PUSH
65926: LD_INT 2
65928: NEG
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 1
65936: PUSH
65937: LD_INT 1
65939: NEG
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: LD_INT 2
65947: PUSH
65948: LD_INT 0
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 2
65957: PUSH
65958: LD_INT 1
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: LD_INT 2
65967: PUSH
65968: LD_INT 2
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 1
65977: PUSH
65978: LD_INT 2
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 0
65987: PUSH
65988: LD_INT 2
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: LD_INT 1
65997: NEG
65998: PUSH
65999: LD_INT 1
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PUSH
66006: LD_INT 2
66008: NEG
66009: PUSH
66010: LD_INT 0
66012: PUSH
66013: EMPTY
66014: LIST
66015: LIST
66016: PUSH
66017: LD_INT 2
66019: NEG
66020: PUSH
66021: LD_INT 1
66023: NEG
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: PUSH
66029: LD_INT 2
66031: NEG
66032: PUSH
66033: LD_INT 2
66035: NEG
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: LIST
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66062: LD_ADDR_VAR 0 20
66066: PUSH
66067: LD_INT 0
66069: PUSH
66070: LD_INT 0
66072: PUSH
66073: EMPTY
66074: LIST
66075: LIST
66076: PUSH
66077: LD_INT 0
66079: PUSH
66080: LD_INT 1
66082: NEG
66083: PUSH
66084: EMPTY
66085: LIST
66086: LIST
66087: PUSH
66088: LD_INT 1
66090: PUSH
66091: LD_INT 0
66093: PUSH
66094: EMPTY
66095: LIST
66096: LIST
66097: PUSH
66098: LD_INT 1
66100: PUSH
66101: LD_INT 1
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: PUSH
66108: LD_INT 0
66110: PUSH
66111: LD_INT 1
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: LD_INT 1
66120: NEG
66121: PUSH
66122: LD_INT 0
66124: PUSH
66125: EMPTY
66126: LIST
66127: LIST
66128: PUSH
66129: LD_INT 1
66131: NEG
66132: PUSH
66133: LD_INT 1
66135: NEG
66136: PUSH
66137: EMPTY
66138: LIST
66139: LIST
66140: PUSH
66141: LD_INT 1
66143: NEG
66144: PUSH
66145: LD_INT 2
66147: NEG
66148: PUSH
66149: EMPTY
66150: LIST
66151: LIST
66152: PUSH
66153: LD_INT 0
66155: PUSH
66156: LD_INT 2
66158: NEG
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PUSH
66164: LD_INT 1
66166: PUSH
66167: LD_INT 1
66169: NEG
66170: PUSH
66171: EMPTY
66172: LIST
66173: LIST
66174: PUSH
66175: LD_INT 2
66177: PUSH
66178: LD_INT 0
66180: PUSH
66181: EMPTY
66182: LIST
66183: LIST
66184: PUSH
66185: LD_INT 2
66187: PUSH
66188: LD_INT 1
66190: PUSH
66191: EMPTY
66192: LIST
66193: LIST
66194: PUSH
66195: LD_INT 2
66197: PUSH
66198: LD_INT 2
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PUSH
66205: LD_INT 1
66207: PUSH
66208: LD_INT 2
66210: PUSH
66211: EMPTY
66212: LIST
66213: LIST
66214: PUSH
66215: LD_INT 0
66217: PUSH
66218: LD_INT 2
66220: PUSH
66221: EMPTY
66222: LIST
66223: LIST
66224: PUSH
66225: LD_INT 1
66227: NEG
66228: PUSH
66229: LD_INT 1
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: PUSH
66236: LD_INT 2
66238: NEG
66239: PUSH
66240: LD_INT 0
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: PUSH
66247: LD_INT 2
66249: NEG
66250: PUSH
66251: LD_INT 1
66253: NEG
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: PUSH
66259: LD_INT 2
66261: NEG
66262: PUSH
66263: LD_INT 2
66265: NEG
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: LIST
66275: LIST
66276: LIST
66277: LIST
66278: LIST
66279: LIST
66280: LIST
66281: LIST
66282: LIST
66283: LIST
66284: LIST
66285: LIST
66286: LIST
66287: LIST
66288: LIST
66289: LIST
66290: LIST
66291: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66292: LD_ADDR_VAR 0 21
66296: PUSH
66297: LD_INT 0
66299: PUSH
66300: LD_INT 0
66302: PUSH
66303: EMPTY
66304: LIST
66305: LIST
66306: PUSH
66307: LD_INT 0
66309: PUSH
66310: LD_INT 1
66312: NEG
66313: PUSH
66314: EMPTY
66315: LIST
66316: LIST
66317: PUSH
66318: LD_INT 1
66320: PUSH
66321: LD_INT 0
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PUSH
66328: LD_INT 1
66330: PUSH
66331: LD_INT 1
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PUSH
66338: LD_INT 0
66340: PUSH
66341: LD_INT 1
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 1
66350: NEG
66351: PUSH
66352: LD_INT 0
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: PUSH
66359: LD_INT 1
66361: NEG
66362: PUSH
66363: LD_INT 1
66365: NEG
66366: PUSH
66367: EMPTY
66368: LIST
66369: LIST
66370: PUSH
66371: LD_INT 1
66373: NEG
66374: PUSH
66375: LD_INT 2
66377: NEG
66378: PUSH
66379: EMPTY
66380: LIST
66381: LIST
66382: PUSH
66383: LD_INT 0
66385: PUSH
66386: LD_INT 2
66388: NEG
66389: PUSH
66390: EMPTY
66391: LIST
66392: LIST
66393: PUSH
66394: LD_INT 1
66396: PUSH
66397: LD_INT 1
66399: NEG
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: LD_INT 2
66407: PUSH
66408: LD_INT 0
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: PUSH
66415: LD_INT 2
66417: PUSH
66418: LD_INT 1
66420: PUSH
66421: EMPTY
66422: LIST
66423: LIST
66424: PUSH
66425: LD_INT 2
66427: PUSH
66428: LD_INT 2
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: PUSH
66435: LD_INT 1
66437: PUSH
66438: LD_INT 2
66440: PUSH
66441: EMPTY
66442: LIST
66443: LIST
66444: PUSH
66445: LD_INT 0
66447: PUSH
66448: LD_INT 2
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PUSH
66455: LD_INT 1
66457: NEG
66458: PUSH
66459: LD_INT 1
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 2
66468: NEG
66469: PUSH
66470: LD_INT 0
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: PUSH
66477: LD_INT 2
66479: NEG
66480: PUSH
66481: LD_INT 1
66483: NEG
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: PUSH
66489: LD_INT 2
66491: NEG
66492: PUSH
66493: LD_INT 2
66495: NEG
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66522: LD_ADDR_VAR 0 22
66526: PUSH
66527: LD_INT 0
66529: PUSH
66530: LD_INT 0
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: PUSH
66537: LD_INT 0
66539: PUSH
66540: LD_INT 1
66542: NEG
66543: PUSH
66544: EMPTY
66545: LIST
66546: LIST
66547: PUSH
66548: LD_INT 1
66550: PUSH
66551: LD_INT 0
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: PUSH
66558: LD_INT 1
66560: PUSH
66561: LD_INT 1
66563: PUSH
66564: EMPTY
66565: LIST
66566: LIST
66567: PUSH
66568: LD_INT 0
66570: PUSH
66571: LD_INT 1
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: PUSH
66578: LD_INT 1
66580: NEG
66581: PUSH
66582: LD_INT 0
66584: PUSH
66585: EMPTY
66586: LIST
66587: LIST
66588: PUSH
66589: LD_INT 1
66591: NEG
66592: PUSH
66593: LD_INT 1
66595: NEG
66596: PUSH
66597: EMPTY
66598: LIST
66599: LIST
66600: PUSH
66601: LD_INT 1
66603: NEG
66604: PUSH
66605: LD_INT 2
66607: NEG
66608: PUSH
66609: EMPTY
66610: LIST
66611: LIST
66612: PUSH
66613: LD_INT 0
66615: PUSH
66616: LD_INT 2
66618: NEG
66619: PUSH
66620: EMPTY
66621: LIST
66622: LIST
66623: PUSH
66624: LD_INT 1
66626: PUSH
66627: LD_INT 1
66629: NEG
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: PUSH
66635: LD_INT 2
66637: PUSH
66638: LD_INT 0
66640: PUSH
66641: EMPTY
66642: LIST
66643: LIST
66644: PUSH
66645: LD_INT 2
66647: PUSH
66648: LD_INT 1
66650: PUSH
66651: EMPTY
66652: LIST
66653: LIST
66654: PUSH
66655: LD_INT 2
66657: PUSH
66658: LD_INT 2
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 1
66667: PUSH
66668: LD_INT 2
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 0
66677: PUSH
66678: LD_INT 2
66680: PUSH
66681: EMPTY
66682: LIST
66683: LIST
66684: PUSH
66685: LD_INT 1
66687: NEG
66688: PUSH
66689: LD_INT 1
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: LD_INT 2
66698: NEG
66699: PUSH
66700: LD_INT 0
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PUSH
66707: LD_INT 2
66709: NEG
66710: PUSH
66711: LD_INT 1
66713: NEG
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: PUSH
66719: LD_INT 2
66721: NEG
66722: PUSH
66723: LD_INT 2
66725: NEG
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: PUSH
66731: EMPTY
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66752: LD_ADDR_VAR 0 23
66756: PUSH
66757: LD_INT 0
66759: PUSH
66760: LD_INT 0
66762: PUSH
66763: EMPTY
66764: LIST
66765: LIST
66766: PUSH
66767: LD_INT 0
66769: PUSH
66770: LD_INT 1
66772: NEG
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 1
66780: PUSH
66781: LD_INT 0
66783: PUSH
66784: EMPTY
66785: LIST
66786: LIST
66787: PUSH
66788: LD_INT 1
66790: PUSH
66791: LD_INT 1
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 0
66800: PUSH
66801: LD_INT 1
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: PUSH
66808: LD_INT 1
66810: NEG
66811: PUSH
66812: LD_INT 0
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: PUSH
66819: LD_INT 1
66821: NEG
66822: PUSH
66823: LD_INT 1
66825: NEG
66826: PUSH
66827: EMPTY
66828: LIST
66829: LIST
66830: PUSH
66831: LD_INT 1
66833: NEG
66834: PUSH
66835: LD_INT 2
66837: NEG
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: PUSH
66843: LD_INT 0
66845: PUSH
66846: LD_INT 2
66848: NEG
66849: PUSH
66850: EMPTY
66851: LIST
66852: LIST
66853: PUSH
66854: LD_INT 1
66856: PUSH
66857: LD_INT 1
66859: NEG
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 2
66867: PUSH
66868: LD_INT 0
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 2
66877: PUSH
66878: LD_INT 1
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 2
66887: PUSH
66888: LD_INT 2
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 1
66897: PUSH
66898: LD_INT 2
66900: PUSH
66901: EMPTY
66902: LIST
66903: LIST
66904: PUSH
66905: LD_INT 0
66907: PUSH
66908: LD_INT 2
66910: PUSH
66911: EMPTY
66912: LIST
66913: LIST
66914: PUSH
66915: LD_INT 1
66917: NEG
66918: PUSH
66919: LD_INT 1
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: PUSH
66926: LD_INT 2
66928: NEG
66929: PUSH
66930: LD_INT 0
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 2
66939: NEG
66940: PUSH
66941: LD_INT 1
66943: NEG
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PUSH
66949: LD_INT 2
66951: NEG
66952: PUSH
66953: LD_INT 2
66955: NEG
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: PUSH
66961: LD_INT 2
66963: NEG
66964: PUSH
66965: LD_INT 3
66967: NEG
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 1
66975: NEG
66976: PUSH
66977: LD_INT 3
66979: NEG
66980: PUSH
66981: EMPTY
66982: LIST
66983: LIST
66984: PUSH
66985: LD_INT 1
66987: PUSH
66988: LD_INT 2
66990: NEG
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: PUSH
66996: LD_INT 2
66998: PUSH
66999: LD_INT 1
67001: NEG
67002: PUSH
67003: EMPTY
67004: LIST
67005: LIST
67006: PUSH
67007: EMPTY
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: LIST
67024: LIST
67025: LIST
67026: LIST
67027: LIST
67028: LIST
67029: LIST
67030: LIST
67031: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67032: LD_ADDR_VAR 0 24
67036: PUSH
67037: LD_INT 0
67039: PUSH
67040: LD_INT 0
67042: PUSH
67043: EMPTY
67044: LIST
67045: LIST
67046: PUSH
67047: LD_INT 0
67049: PUSH
67050: LD_INT 1
67052: NEG
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: LD_INT 1
67060: PUSH
67061: LD_INT 0
67063: PUSH
67064: EMPTY
67065: LIST
67066: LIST
67067: PUSH
67068: LD_INT 1
67070: PUSH
67071: LD_INT 1
67073: PUSH
67074: EMPTY
67075: LIST
67076: LIST
67077: PUSH
67078: LD_INT 0
67080: PUSH
67081: LD_INT 1
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: PUSH
67088: LD_INT 1
67090: NEG
67091: PUSH
67092: LD_INT 0
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: PUSH
67099: LD_INT 1
67101: NEG
67102: PUSH
67103: LD_INT 1
67105: NEG
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 1
67113: NEG
67114: PUSH
67115: LD_INT 2
67117: NEG
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: LD_INT 0
67125: PUSH
67126: LD_INT 2
67128: NEG
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 1
67136: PUSH
67137: LD_INT 1
67139: NEG
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 2
67147: PUSH
67148: LD_INT 0
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: LD_INT 2
67157: PUSH
67158: LD_INT 1
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: LD_INT 2
67167: PUSH
67168: LD_INT 2
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 1
67177: PUSH
67178: LD_INT 2
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: PUSH
67185: LD_INT 0
67187: PUSH
67188: LD_INT 2
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 1
67197: NEG
67198: PUSH
67199: LD_INT 1
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PUSH
67206: LD_INT 2
67208: NEG
67209: PUSH
67210: LD_INT 0
67212: PUSH
67213: EMPTY
67214: LIST
67215: LIST
67216: PUSH
67217: LD_INT 2
67219: NEG
67220: PUSH
67221: LD_INT 1
67223: NEG
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 2
67231: NEG
67232: PUSH
67233: LD_INT 2
67235: NEG
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 1
67243: PUSH
67244: LD_INT 2
67246: NEG
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 2
67254: PUSH
67255: LD_INT 1
67257: NEG
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 3
67265: PUSH
67266: LD_INT 1
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 3
67275: PUSH
67276: LD_INT 2
67278: PUSH
67279: EMPTY
67280: LIST
67281: LIST
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: LIST
67306: LIST
67307: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67308: LD_ADDR_VAR 0 25
67312: PUSH
67313: LD_INT 0
67315: PUSH
67316: LD_INT 0
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 0
67325: PUSH
67326: LD_INT 1
67328: NEG
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: PUSH
67334: LD_INT 1
67336: PUSH
67337: LD_INT 0
67339: PUSH
67340: EMPTY
67341: LIST
67342: LIST
67343: PUSH
67344: LD_INT 1
67346: PUSH
67347: LD_INT 1
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: LD_INT 0
67356: PUSH
67357: LD_INT 1
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 1
67366: NEG
67367: PUSH
67368: LD_INT 0
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: LD_INT 1
67377: NEG
67378: PUSH
67379: LD_INT 1
67381: NEG
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: PUSH
67387: LD_INT 1
67389: NEG
67390: PUSH
67391: LD_INT 2
67393: NEG
67394: PUSH
67395: EMPTY
67396: LIST
67397: LIST
67398: PUSH
67399: LD_INT 0
67401: PUSH
67402: LD_INT 2
67404: NEG
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 1
67412: PUSH
67413: LD_INT 1
67415: NEG
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: PUSH
67421: LD_INT 2
67423: PUSH
67424: LD_INT 0
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: PUSH
67431: LD_INT 2
67433: PUSH
67434: LD_INT 1
67436: PUSH
67437: EMPTY
67438: LIST
67439: LIST
67440: PUSH
67441: LD_INT 2
67443: PUSH
67444: LD_INT 2
67446: PUSH
67447: EMPTY
67448: LIST
67449: LIST
67450: PUSH
67451: LD_INT 1
67453: PUSH
67454: LD_INT 2
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: PUSH
67461: LD_INT 0
67463: PUSH
67464: LD_INT 2
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: PUSH
67471: LD_INT 1
67473: NEG
67474: PUSH
67475: LD_INT 1
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 2
67484: NEG
67485: PUSH
67486: LD_INT 0
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 2
67495: NEG
67496: PUSH
67497: LD_INT 1
67499: NEG
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: PUSH
67505: LD_INT 2
67507: NEG
67508: PUSH
67509: LD_INT 2
67511: NEG
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 3
67519: PUSH
67520: LD_INT 1
67522: PUSH
67523: EMPTY
67524: LIST
67525: LIST
67526: PUSH
67527: LD_INT 3
67529: PUSH
67530: LD_INT 2
67532: PUSH
67533: EMPTY
67534: LIST
67535: LIST
67536: PUSH
67537: LD_INT 2
67539: PUSH
67540: LD_INT 3
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 1
67549: PUSH
67550: LD_INT 3
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: LIST
67579: LIST
67580: LIST
67581: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67582: LD_ADDR_VAR 0 26
67586: PUSH
67587: LD_INT 0
67589: PUSH
67590: LD_INT 0
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: PUSH
67597: LD_INT 0
67599: PUSH
67600: LD_INT 1
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 1
67610: PUSH
67611: LD_INT 0
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 1
67620: PUSH
67621: LD_INT 1
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 0
67630: PUSH
67631: LD_INT 1
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 1
67640: NEG
67641: PUSH
67642: LD_INT 0
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 1
67651: NEG
67652: PUSH
67653: LD_INT 1
67655: NEG
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 1
67663: NEG
67664: PUSH
67665: LD_INT 2
67667: NEG
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 0
67675: PUSH
67676: LD_INT 2
67678: NEG
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: LD_INT 1
67686: PUSH
67687: LD_INT 1
67689: NEG
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: PUSH
67695: LD_INT 2
67697: PUSH
67698: LD_INT 0
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PUSH
67705: LD_INT 2
67707: PUSH
67708: LD_INT 1
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: LD_INT 2
67717: PUSH
67718: LD_INT 2
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: LD_INT 1
67727: PUSH
67728: LD_INT 2
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 0
67737: PUSH
67738: LD_INT 2
67740: PUSH
67741: EMPTY
67742: LIST
67743: LIST
67744: PUSH
67745: LD_INT 1
67747: NEG
67748: PUSH
67749: LD_INT 1
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PUSH
67756: LD_INT 2
67758: NEG
67759: PUSH
67760: LD_INT 0
67762: PUSH
67763: EMPTY
67764: LIST
67765: LIST
67766: PUSH
67767: LD_INT 2
67769: NEG
67770: PUSH
67771: LD_INT 1
67773: NEG
67774: PUSH
67775: EMPTY
67776: LIST
67777: LIST
67778: PUSH
67779: LD_INT 2
67781: NEG
67782: PUSH
67783: LD_INT 2
67785: NEG
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PUSH
67791: LD_INT 2
67793: PUSH
67794: LD_INT 3
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 1
67803: PUSH
67804: LD_INT 3
67806: PUSH
67807: EMPTY
67808: LIST
67809: LIST
67810: PUSH
67811: LD_INT 1
67813: NEG
67814: PUSH
67815: LD_INT 2
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: LD_INT 2
67824: NEG
67825: PUSH
67826: LD_INT 1
67828: PUSH
67829: EMPTY
67830: LIST
67831: LIST
67832: PUSH
67833: EMPTY
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67858: LD_ADDR_VAR 0 27
67862: PUSH
67863: LD_INT 0
67865: PUSH
67866: LD_INT 0
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 0
67875: PUSH
67876: LD_INT 1
67878: NEG
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 1
67886: PUSH
67887: LD_INT 0
67889: PUSH
67890: EMPTY
67891: LIST
67892: LIST
67893: PUSH
67894: LD_INT 1
67896: PUSH
67897: LD_INT 1
67899: PUSH
67900: EMPTY
67901: LIST
67902: LIST
67903: PUSH
67904: LD_INT 0
67906: PUSH
67907: LD_INT 1
67909: PUSH
67910: EMPTY
67911: LIST
67912: LIST
67913: PUSH
67914: LD_INT 1
67916: NEG
67917: PUSH
67918: LD_INT 0
67920: PUSH
67921: EMPTY
67922: LIST
67923: LIST
67924: PUSH
67925: LD_INT 1
67927: NEG
67928: PUSH
67929: LD_INT 1
67931: NEG
67932: PUSH
67933: EMPTY
67934: LIST
67935: LIST
67936: PUSH
67937: LD_INT 1
67939: NEG
67940: PUSH
67941: LD_INT 2
67943: NEG
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 0
67951: PUSH
67952: LD_INT 2
67954: NEG
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 1
67962: PUSH
67963: LD_INT 1
67965: NEG
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 2
67973: PUSH
67974: LD_INT 0
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 2
67983: PUSH
67984: LD_INT 1
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PUSH
67991: LD_INT 2
67993: PUSH
67994: LD_INT 2
67996: PUSH
67997: EMPTY
67998: LIST
67999: LIST
68000: PUSH
68001: LD_INT 1
68003: PUSH
68004: LD_INT 2
68006: PUSH
68007: EMPTY
68008: LIST
68009: LIST
68010: PUSH
68011: LD_INT 0
68013: PUSH
68014: LD_INT 2
68016: PUSH
68017: EMPTY
68018: LIST
68019: LIST
68020: PUSH
68021: LD_INT 1
68023: NEG
68024: PUSH
68025: LD_INT 1
68027: PUSH
68028: EMPTY
68029: LIST
68030: LIST
68031: PUSH
68032: LD_INT 2
68034: NEG
68035: PUSH
68036: LD_INT 0
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: PUSH
68043: LD_INT 2
68045: NEG
68046: PUSH
68047: LD_INT 1
68049: NEG
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: PUSH
68055: LD_INT 2
68057: NEG
68058: PUSH
68059: LD_INT 2
68061: NEG
68062: PUSH
68063: EMPTY
68064: LIST
68065: LIST
68066: PUSH
68067: LD_INT 1
68069: NEG
68070: PUSH
68071: LD_INT 2
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: PUSH
68078: LD_INT 2
68080: NEG
68081: PUSH
68082: LD_INT 1
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: PUSH
68089: LD_INT 3
68091: NEG
68092: PUSH
68093: LD_INT 1
68095: NEG
68096: PUSH
68097: EMPTY
68098: LIST
68099: LIST
68100: PUSH
68101: LD_INT 3
68103: NEG
68104: PUSH
68105: LD_INT 2
68107: NEG
68108: PUSH
68109: EMPTY
68110: LIST
68111: LIST
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: LIST
68129: LIST
68130: LIST
68131: LIST
68132: LIST
68133: LIST
68134: LIST
68135: LIST
68136: LIST
68137: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68138: LD_ADDR_VAR 0 28
68142: PUSH
68143: LD_INT 0
68145: PUSH
68146: LD_INT 0
68148: PUSH
68149: EMPTY
68150: LIST
68151: LIST
68152: PUSH
68153: LD_INT 0
68155: PUSH
68156: LD_INT 1
68158: NEG
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: PUSH
68164: LD_INT 1
68166: PUSH
68167: LD_INT 0
68169: PUSH
68170: EMPTY
68171: LIST
68172: LIST
68173: PUSH
68174: LD_INT 1
68176: PUSH
68177: LD_INT 1
68179: PUSH
68180: EMPTY
68181: LIST
68182: LIST
68183: PUSH
68184: LD_INT 0
68186: PUSH
68187: LD_INT 1
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: LD_INT 1
68196: NEG
68197: PUSH
68198: LD_INT 0
68200: PUSH
68201: EMPTY
68202: LIST
68203: LIST
68204: PUSH
68205: LD_INT 1
68207: NEG
68208: PUSH
68209: LD_INT 1
68211: NEG
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: PUSH
68217: LD_INT 1
68219: NEG
68220: PUSH
68221: LD_INT 2
68223: NEG
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 0
68231: PUSH
68232: LD_INT 2
68234: NEG
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 1
68242: PUSH
68243: LD_INT 1
68245: NEG
68246: PUSH
68247: EMPTY
68248: LIST
68249: LIST
68250: PUSH
68251: LD_INT 2
68253: PUSH
68254: LD_INT 0
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 2
68263: PUSH
68264: LD_INT 1
68266: PUSH
68267: EMPTY
68268: LIST
68269: LIST
68270: PUSH
68271: LD_INT 2
68273: PUSH
68274: LD_INT 2
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: PUSH
68281: LD_INT 1
68283: PUSH
68284: LD_INT 2
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 0
68293: PUSH
68294: LD_INT 2
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 1
68303: NEG
68304: PUSH
68305: LD_INT 1
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: PUSH
68312: LD_INT 2
68314: NEG
68315: PUSH
68316: LD_INT 0
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: LD_INT 2
68325: NEG
68326: PUSH
68327: LD_INT 1
68329: NEG
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: LD_INT 2
68337: NEG
68338: PUSH
68339: LD_INT 2
68341: NEG
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: PUSH
68347: LD_INT 2
68349: NEG
68350: PUSH
68351: LD_INT 3
68353: NEG
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PUSH
68359: LD_INT 1
68361: NEG
68362: PUSH
68363: LD_INT 3
68365: NEG
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 3
68373: NEG
68374: PUSH
68375: LD_INT 1
68377: NEG
68378: PUSH
68379: EMPTY
68380: LIST
68381: LIST
68382: PUSH
68383: LD_INT 3
68385: NEG
68386: PUSH
68387: LD_INT 2
68389: NEG
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: LIST
68417: LIST
68418: LIST
68419: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68420: LD_ADDR_VAR 0 29
68424: PUSH
68425: LD_INT 0
68427: PUSH
68428: LD_INT 0
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 0
68437: PUSH
68438: LD_INT 1
68440: NEG
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: LD_INT 1
68448: PUSH
68449: LD_INT 0
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PUSH
68456: LD_INT 1
68458: PUSH
68459: LD_INT 1
68461: PUSH
68462: EMPTY
68463: LIST
68464: LIST
68465: PUSH
68466: LD_INT 0
68468: PUSH
68469: LD_INT 1
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: LD_INT 1
68478: NEG
68479: PUSH
68480: LD_INT 0
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: PUSH
68487: LD_INT 1
68489: NEG
68490: PUSH
68491: LD_INT 1
68493: NEG
68494: PUSH
68495: EMPTY
68496: LIST
68497: LIST
68498: PUSH
68499: LD_INT 1
68501: NEG
68502: PUSH
68503: LD_INT 2
68505: NEG
68506: PUSH
68507: EMPTY
68508: LIST
68509: LIST
68510: PUSH
68511: LD_INT 0
68513: PUSH
68514: LD_INT 2
68516: NEG
68517: PUSH
68518: EMPTY
68519: LIST
68520: LIST
68521: PUSH
68522: LD_INT 1
68524: PUSH
68525: LD_INT 1
68527: NEG
68528: PUSH
68529: EMPTY
68530: LIST
68531: LIST
68532: PUSH
68533: LD_INT 2
68535: PUSH
68536: LD_INT 0
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: LD_INT 2
68545: PUSH
68546: LD_INT 1
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: LD_INT 1
68555: PUSH
68556: LD_INT 2
68558: PUSH
68559: EMPTY
68560: LIST
68561: LIST
68562: PUSH
68563: LD_INT 0
68565: PUSH
68566: LD_INT 2
68568: PUSH
68569: EMPTY
68570: LIST
68571: LIST
68572: PUSH
68573: LD_INT 1
68575: NEG
68576: PUSH
68577: LD_INT 1
68579: PUSH
68580: EMPTY
68581: LIST
68582: LIST
68583: PUSH
68584: LD_INT 2
68586: NEG
68587: PUSH
68588: LD_INT 1
68590: NEG
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PUSH
68596: LD_INT 2
68598: NEG
68599: PUSH
68600: LD_INT 2
68602: NEG
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: PUSH
68608: LD_INT 2
68610: NEG
68611: PUSH
68612: LD_INT 3
68614: NEG
68615: PUSH
68616: EMPTY
68617: LIST
68618: LIST
68619: PUSH
68620: LD_INT 2
68622: PUSH
68623: LD_INT 1
68625: NEG
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: LD_INT 3
68633: PUSH
68634: LD_INT 1
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PUSH
68641: LD_INT 1
68643: PUSH
68644: LD_INT 3
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: LD_INT 1
68653: NEG
68654: PUSH
68655: LD_INT 2
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: PUSH
68662: LD_INT 3
68664: NEG
68665: PUSH
68666: LD_INT 2
68668: NEG
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: LIST
68689: LIST
68690: LIST
68691: LIST
68692: LIST
68693: LIST
68694: LIST
68695: LIST
68696: LIST
68697: LIST
68698: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68699: LD_ADDR_VAR 0 30
68703: PUSH
68704: LD_INT 0
68706: PUSH
68707: LD_INT 0
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: PUSH
68714: LD_INT 0
68716: PUSH
68717: LD_INT 1
68719: NEG
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 1
68727: PUSH
68728: LD_INT 0
68730: PUSH
68731: EMPTY
68732: LIST
68733: LIST
68734: PUSH
68735: LD_INT 1
68737: PUSH
68738: LD_INT 1
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 0
68747: PUSH
68748: LD_INT 1
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PUSH
68755: LD_INT 1
68757: NEG
68758: PUSH
68759: LD_INT 0
68761: PUSH
68762: EMPTY
68763: LIST
68764: LIST
68765: PUSH
68766: LD_INT 1
68768: NEG
68769: PUSH
68770: LD_INT 1
68772: NEG
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: PUSH
68778: LD_INT 1
68780: NEG
68781: PUSH
68782: LD_INT 2
68784: NEG
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: LD_INT 0
68792: PUSH
68793: LD_INT 2
68795: NEG
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PUSH
68801: LD_INT 1
68803: PUSH
68804: LD_INT 1
68806: NEG
68807: PUSH
68808: EMPTY
68809: LIST
68810: LIST
68811: PUSH
68812: LD_INT 2
68814: PUSH
68815: LD_INT 0
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: PUSH
68822: LD_INT 2
68824: PUSH
68825: LD_INT 1
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PUSH
68832: LD_INT 2
68834: PUSH
68835: LD_INT 2
68837: PUSH
68838: EMPTY
68839: LIST
68840: LIST
68841: PUSH
68842: LD_INT 1
68844: PUSH
68845: LD_INT 2
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 1
68854: NEG
68855: PUSH
68856: LD_INT 1
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: LD_INT 0
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: PUSH
68874: LD_INT 2
68876: NEG
68877: PUSH
68878: LD_INT 1
68880: NEG
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: LD_INT 1
68888: NEG
68889: PUSH
68890: LD_INT 3
68892: NEG
68893: PUSH
68894: EMPTY
68895: LIST
68896: LIST
68897: PUSH
68898: LD_INT 1
68900: PUSH
68901: LD_INT 2
68903: NEG
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PUSH
68909: LD_INT 3
68911: PUSH
68912: LD_INT 2
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 2
68921: PUSH
68922: LD_INT 3
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: LD_INT 2
68931: NEG
68932: PUSH
68933: LD_INT 1
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PUSH
68940: LD_INT 3
68942: NEG
68943: PUSH
68944: LD_INT 1
68946: NEG
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: LIST
68974: LIST
68975: LIST
68976: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68977: LD_ADDR_VAR 0 31
68981: PUSH
68982: LD_INT 0
68984: PUSH
68985: LD_INT 0
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 0
68994: PUSH
68995: LD_INT 1
68997: NEG
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 1
69005: PUSH
69006: LD_INT 0
69008: PUSH
69009: EMPTY
69010: LIST
69011: LIST
69012: PUSH
69013: LD_INT 1
69015: PUSH
69016: LD_INT 1
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: PUSH
69023: LD_INT 0
69025: PUSH
69026: LD_INT 1
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: PUSH
69033: LD_INT 1
69035: NEG
69036: PUSH
69037: LD_INT 0
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PUSH
69044: LD_INT 1
69046: NEG
69047: PUSH
69048: LD_INT 1
69050: NEG
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: LD_INT 1
69058: NEG
69059: PUSH
69060: LD_INT 2
69062: NEG
69063: PUSH
69064: EMPTY
69065: LIST
69066: LIST
69067: PUSH
69068: LD_INT 1
69070: PUSH
69071: LD_INT 1
69073: NEG
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: LD_INT 2
69081: PUSH
69082: LD_INT 0
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: PUSH
69089: LD_INT 2
69091: PUSH
69092: LD_INT 1
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 2
69101: PUSH
69102: LD_INT 2
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: PUSH
69109: LD_INT 1
69111: PUSH
69112: LD_INT 2
69114: PUSH
69115: EMPTY
69116: LIST
69117: LIST
69118: PUSH
69119: LD_INT 0
69121: PUSH
69122: LD_INT 2
69124: PUSH
69125: EMPTY
69126: LIST
69127: LIST
69128: PUSH
69129: LD_INT 1
69131: NEG
69132: PUSH
69133: LD_INT 1
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: LD_INT 2
69142: NEG
69143: PUSH
69144: LD_INT 1
69146: NEG
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: PUSH
69152: LD_INT 2
69154: NEG
69155: PUSH
69156: LD_INT 2
69158: NEG
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: LD_INT 2
69166: NEG
69167: PUSH
69168: LD_INT 3
69170: NEG
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: PUSH
69176: LD_INT 2
69178: PUSH
69179: LD_INT 1
69181: NEG
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 3
69189: PUSH
69190: LD_INT 1
69192: PUSH
69193: EMPTY
69194: LIST
69195: LIST
69196: PUSH
69197: LD_INT 1
69199: PUSH
69200: LD_INT 3
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PUSH
69207: LD_INT 1
69209: NEG
69210: PUSH
69211: LD_INT 2
69213: PUSH
69214: EMPTY
69215: LIST
69216: LIST
69217: PUSH
69218: LD_INT 3
69220: NEG
69221: PUSH
69222: LD_INT 2
69224: NEG
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: LIST
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: LIST
69239: LIST
69240: LIST
69241: LIST
69242: LIST
69243: LIST
69244: LIST
69245: LIST
69246: LIST
69247: LIST
69248: LIST
69249: LIST
69250: LIST
69251: LIST
69252: LIST
69253: LIST
69254: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69255: LD_ADDR_VAR 0 32
69259: PUSH
69260: LD_INT 0
69262: PUSH
69263: LD_INT 0
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 0
69272: PUSH
69273: LD_INT 1
69275: NEG
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 1
69283: PUSH
69284: LD_INT 0
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 1
69293: PUSH
69294: LD_INT 1
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: PUSH
69301: LD_INT 0
69303: PUSH
69304: LD_INT 1
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 1
69313: NEG
69314: PUSH
69315: LD_INT 0
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 1
69324: NEG
69325: PUSH
69326: LD_INT 1
69328: NEG
69329: PUSH
69330: EMPTY
69331: LIST
69332: LIST
69333: PUSH
69334: LD_INT 1
69336: NEG
69337: PUSH
69338: LD_INT 2
69340: NEG
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 0
69348: PUSH
69349: LD_INT 2
69351: NEG
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 1
69359: PUSH
69360: LD_INT 1
69362: NEG
69363: PUSH
69364: EMPTY
69365: LIST
69366: LIST
69367: PUSH
69368: LD_INT 2
69370: PUSH
69371: LD_INT 1
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: PUSH
69378: LD_INT 2
69380: PUSH
69381: LD_INT 2
69383: PUSH
69384: EMPTY
69385: LIST
69386: LIST
69387: PUSH
69388: LD_INT 1
69390: PUSH
69391: LD_INT 2
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: PUSH
69398: LD_INT 0
69400: PUSH
69401: LD_INT 2
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: PUSH
69408: LD_INT 1
69410: NEG
69411: PUSH
69412: LD_INT 1
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: PUSH
69419: LD_INT 2
69421: NEG
69422: PUSH
69423: LD_INT 0
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: PUSH
69430: LD_INT 2
69432: NEG
69433: PUSH
69434: LD_INT 1
69436: NEG
69437: PUSH
69438: EMPTY
69439: LIST
69440: LIST
69441: PUSH
69442: LD_INT 1
69444: NEG
69445: PUSH
69446: LD_INT 3
69448: NEG
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 1
69456: PUSH
69457: LD_INT 2
69459: NEG
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: PUSH
69465: LD_INT 3
69467: PUSH
69468: LD_INT 2
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 2
69477: PUSH
69478: LD_INT 3
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: PUSH
69485: LD_INT 2
69487: NEG
69488: PUSH
69489: LD_INT 1
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 3
69498: NEG
69499: PUSH
69500: LD_INT 1
69502: NEG
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: EMPTY
69509: LIST
69510: LIST
69511: LIST
69512: LIST
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: LIST
69526: LIST
69527: LIST
69528: LIST
69529: LIST
69530: LIST
69531: LIST
69532: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69533: LD_ADDR_VAR 0 33
69537: PUSH
69538: LD_INT 0
69540: PUSH
69541: LD_INT 0
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: LD_INT 0
69550: PUSH
69551: LD_INT 1
69553: NEG
69554: PUSH
69555: EMPTY
69556: LIST
69557: LIST
69558: PUSH
69559: LD_INT 1
69561: PUSH
69562: LD_INT 0
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: LD_INT 1
69571: PUSH
69572: LD_INT 1
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: PUSH
69579: LD_INT 0
69581: PUSH
69582: LD_INT 1
69584: PUSH
69585: EMPTY
69586: LIST
69587: LIST
69588: PUSH
69589: LD_INT 1
69591: NEG
69592: PUSH
69593: LD_INT 0
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: PUSH
69600: LD_INT 1
69602: NEG
69603: PUSH
69604: LD_INT 1
69606: NEG
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 1
69614: NEG
69615: PUSH
69616: LD_INT 2
69618: NEG
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 1
69626: PUSH
69627: LD_INT 1
69629: NEG
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 2
69637: PUSH
69638: LD_INT 0
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 2
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 1
69657: PUSH
69658: LD_INT 2
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 0
69667: PUSH
69668: LD_INT 2
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: PUSH
69675: LD_INT 1
69677: NEG
69678: PUSH
69679: LD_INT 1
69681: PUSH
69682: EMPTY
69683: LIST
69684: LIST
69685: PUSH
69686: LD_INT 2
69688: NEG
69689: PUSH
69690: LD_INT 0
69692: PUSH
69693: EMPTY
69694: LIST
69695: LIST
69696: PUSH
69697: LD_INT 2
69699: NEG
69700: PUSH
69701: LD_INT 1
69703: NEG
69704: PUSH
69705: EMPTY
69706: LIST
69707: LIST
69708: PUSH
69709: LD_INT 2
69711: NEG
69712: PUSH
69713: LD_INT 2
69715: NEG
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: PUSH
69721: LD_INT 2
69723: NEG
69724: PUSH
69725: LD_INT 3
69727: NEG
69728: PUSH
69729: EMPTY
69730: LIST
69731: LIST
69732: PUSH
69733: LD_INT 2
69735: PUSH
69736: LD_INT 1
69738: NEG
69739: PUSH
69740: EMPTY
69741: LIST
69742: LIST
69743: PUSH
69744: LD_INT 3
69746: PUSH
69747: LD_INT 1
69749: PUSH
69750: EMPTY
69751: LIST
69752: LIST
69753: PUSH
69754: LD_INT 1
69756: PUSH
69757: LD_INT 3
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 1
69766: NEG
69767: PUSH
69768: LD_INT 2
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: PUSH
69775: LD_INT 3
69777: NEG
69778: PUSH
69779: LD_INT 2
69781: NEG
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: EMPTY
69788: LIST
69789: LIST
69790: LIST
69791: LIST
69792: LIST
69793: LIST
69794: LIST
69795: LIST
69796: LIST
69797: LIST
69798: LIST
69799: LIST
69800: LIST
69801: LIST
69802: LIST
69803: LIST
69804: LIST
69805: LIST
69806: LIST
69807: LIST
69808: LIST
69809: LIST
69810: LIST
69811: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69812: LD_ADDR_VAR 0 34
69816: PUSH
69817: LD_INT 0
69819: PUSH
69820: LD_INT 0
69822: PUSH
69823: EMPTY
69824: LIST
69825: LIST
69826: PUSH
69827: LD_INT 0
69829: PUSH
69830: LD_INT 1
69832: NEG
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 1
69840: PUSH
69841: LD_INT 0
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 1
69850: PUSH
69851: LD_INT 1
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: LD_INT 0
69860: PUSH
69861: LD_INT 1
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: LD_INT 1
69870: NEG
69871: PUSH
69872: LD_INT 0
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 1
69881: NEG
69882: PUSH
69883: LD_INT 1
69885: NEG
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 1
69893: NEG
69894: PUSH
69895: LD_INT 2
69897: NEG
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: PUSH
69903: LD_INT 0
69905: PUSH
69906: LD_INT 2
69908: NEG
69909: PUSH
69910: EMPTY
69911: LIST
69912: LIST
69913: PUSH
69914: LD_INT 1
69916: PUSH
69917: LD_INT 1
69919: NEG
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: LD_INT 2
69927: PUSH
69928: LD_INT 1
69930: PUSH
69931: EMPTY
69932: LIST
69933: LIST
69934: PUSH
69935: LD_INT 2
69937: PUSH
69938: LD_INT 2
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 1
69947: PUSH
69948: LD_INT 2
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 1
69957: NEG
69958: PUSH
69959: LD_INT 1
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: PUSH
69966: LD_INT 2
69968: NEG
69969: PUSH
69970: LD_INT 0
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: LD_INT 2
69979: NEG
69980: PUSH
69981: LD_INT 1
69983: NEG
69984: PUSH
69985: EMPTY
69986: LIST
69987: LIST
69988: PUSH
69989: LD_INT 2
69991: NEG
69992: PUSH
69993: LD_INT 2
69995: NEG
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: PUSH
70001: LD_INT 1
70003: NEG
70004: PUSH
70005: LD_INT 3
70007: NEG
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: PUSH
70013: LD_INT 1
70015: PUSH
70016: LD_INT 2
70018: NEG
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 3
70026: PUSH
70027: LD_INT 2
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 2
70036: PUSH
70037: LD_INT 3
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 2
70046: NEG
70047: PUSH
70048: LD_INT 1
70050: PUSH
70051: EMPTY
70052: LIST
70053: LIST
70054: PUSH
70055: LD_INT 3
70057: NEG
70058: PUSH
70059: LD_INT 1
70061: NEG
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: EMPTY
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: LIST
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: LIST
70089: LIST
70090: LIST
70091: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70092: LD_ADDR_VAR 0 35
70096: PUSH
70097: LD_INT 0
70099: PUSH
70100: LD_INT 0
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: PUSH
70107: LD_INT 0
70109: PUSH
70110: LD_INT 1
70112: NEG
70113: PUSH
70114: EMPTY
70115: LIST
70116: LIST
70117: PUSH
70118: LD_INT 1
70120: PUSH
70121: LD_INT 0
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: PUSH
70128: LD_INT 1
70130: PUSH
70131: LD_INT 1
70133: PUSH
70134: EMPTY
70135: LIST
70136: LIST
70137: PUSH
70138: LD_INT 0
70140: PUSH
70141: LD_INT 1
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 1
70150: NEG
70151: PUSH
70152: LD_INT 0
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 1
70161: NEG
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 2
70173: PUSH
70174: LD_INT 1
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 2
70183: NEG
70184: PUSH
70185: LD_INT 1
70187: NEG
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70204: LD_ADDR_VAR 0 36
70208: PUSH
70209: LD_INT 0
70211: PUSH
70212: LD_INT 0
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 0
70221: PUSH
70222: LD_INT 1
70224: NEG
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 1
70232: PUSH
70233: LD_INT 0
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 1
70242: PUSH
70243: LD_INT 1
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: LD_INT 0
70252: PUSH
70253: LD_INT 1
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 1
70262: NEG
70263: PUSH
70264: LD_INT 0
70266: PUSH
70267: EMPTY
70268: LIST
70269: LIST
70270: PUSH
70271: LD_INT 1
70273: NEG
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 1
70285: NEG
70286: PUSH
70287: LD_INT 2
70289: NEG
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 1
70297: PUSH
70298: LD_INT 2
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: EMPTY
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70316: LD_ADDR_VAR 0 37
70320: PUSH
70321: LD_INT 0
70323: PUSH
70324: LD_INT 0
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: PUSH
70331: LD_INT 0
70333: PUSH
70334: LD_INT 1
70336: NEG
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PUSH
70342: LD_INT 1
70344: PUSH
70345: LD_INT 0
70347: PUSH
70348: EMPTY
70349: LIST
70350: LIST
70351: PUSH
70352: LD_INT 1
70354: PUSH
70355: LD_INT 1
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: PUSH
70362: LD_INT 0
70364: PUSH
70365: LD_INT 1
70367: PUSH
70368: EMPTY
70369: LIST
70370: LIST
70371: PUSH
70372: LD_INT 1
70374: NEG
70375: PUSH
70376: LD_INT 0
70378: PUSH
70379: EMPTY
70380: LIST
70381: LIST
70382: PUSH
70383: LD_INT 1
70385: NEG
70386: PUSH
70387: LD_INT 1
70389: NEG
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: PUSH
70395: LD_INT 1
70397: PUSH
70398: LD_INT 1
70400: NEG
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 1
70408: NEG
70409: PUSH
70410: LD_INT 1
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: EMPTY
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: LIST
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70428: LD_ADDR_VAR 0 38
70432: PUSH
70433: LD_INT 0
70435: PUSH
70436: LD_INT 0
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 0
70445: PUSH
70446: LD_INT 1
70448: NEG
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: LD_INT 1
70456: PUSH
70457: LD_INT 0
70459: PUSH
70460: EMPTY
70461: LIST
70462: LIST
70463: PUSH
70464: LD_INT 1
70466: PUSH
70467: LD_INT 1
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: LD_INT 0
70476: PUSH
70477: LD_INT 1
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: PUSH
70484: LD_INT 1
70486: NEG
70487: PUSH
70488: LD_INT 0
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: LD_INT 1
70497: NEG
70498: PUSH
70499: LD_INT 1
70501: NEG
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: PUSH
70507: LD_INT 2
70509: PUSH
70510: LD_INT 1
70512: PUSH
70513: EMPTY
70514: LIST
70515: LIST
70516: PUSH
70517: LD_INT 2
70519: NEG
70520: PUSH
70521: LD_INT 1
70523: NEG
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70540: LD_ADDR_VAR 0 39
70544: PUSH
70545: LD_INT 0
70547: PUSH
70548: LD_INT 0
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 0
70557: PUSH
70558: LD_INT 1
70560: NEG
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 1
70568: PUSH
70569: LD_INT 0
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 1
70578: PUSH
70579: LD_INT 1
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PUSH
70586: LD_INT 0
70588: PUSH
70589: LD_INT 1
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 1
70598: NEG
70599: PUSH
70600: LD_INT 0
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 1
70609: NEG
70610: PUSH
70611: LD_INT 1
70613: NEG
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 1
70621: NEG
70622: PUSH
70623: LD_INT 2
70625: NEG
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 1
70633: PUSH
70634: LD_INT 2
70636: PUSH
70637: EMPTY
70638: LIST
70639: LIST
70640: PUSH
70641: EMPTY
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: LIST
70647: LIST
70648: LIST
70649: LIST
70650: LIST
70651: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70652: LD_ADDR_VAR 0 40
70656: PUSH
70657: LD_INT 0
70659: PUSH
70660: LD_INT 0
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: PUSH
70667: LD_INT 0
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 1
70680: PUSH
70681: LD_INT 0
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: LD_INT 1
70690: PUSH
70691: LD_INT 1
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 0
70700: PUSH
70701: LD_INT 1
70703: PUSH
70704: EMPTY
70705: LIST
70706: LIST
70707: PUSH
70708: LD_INT 1
70710: NEG
70711: PUSH
70712: LD_INT 0
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 1
70721: NEG
70722: PUSH
70723: LD_INT 1
70725: NEG
70726: PUSH
70727: EMPTY
70728: LIST
70729: LIST
70730: PUSH
70731: LD_INT 1
70733: PUSH
70734: LD_INT 1
70736: NEG
70737: PUSH
70738: EMPTY
70739: LIST
70740: LIST
70741: PUSH
70742: LD_INT 1
70744: NEG
70745: PUSH
70746: LD_INT 1
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70764: LD_ADDR_VAR 0 41
70768: PUSH
70769: LD_INT 0
70771: PUSH
70772: LD_INT 0
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 0
70781: PUSH
70782: LD_INT 1
70784: NEG
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 1
70792: PUSH
70793: LD_INT 0
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: LD_INT 1
70802: PUSH
70803: LD_INT 1
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PUSH
70810: LD_INT 0
70812: PUSH
70813: LD_INT 1
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 1
70822: NEG
70823: PUSH
70824: LD_INT 0
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 1
70833: NEG
70834: PUSH
70835: LD_INT 1
70837: NEG
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 1
70845: NEG
70846: PUSH
70847: LD_INT 2
70849: NEG
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 1
70857: PUSH
70858: LD_INT 1
70860: NEG
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 2
70868: PUSH
70869: LD_INT 0
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: LD_INT 2
70878: PUSH
70879: LD_INT 1
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: LD_INT 2
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: LD_INT 2
70901: PUSH
70902: EMPTY
70903: LIST
70904: LIST
70905: PUSH
70906: LD_INT 1
70908: NEG
70909: PUSH
70910: LD_INT 1
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 2
70919: NEG
70920: PUSH
70921: LD_INT 0
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 2
70930: NEG
70931: PUSH
70932: LD_INT 1
70934: NEG
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 2
70942: NEG
70943: PUSH
70944: LD_INT 2
70946: NEG
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: PUSH
70952: LD_INT 2
70954: NEG
70955: PUSH
70956: LD_INT 3
70958: NEG
70959: PUSH
70960: EMPTY
70961: LIST
70962: LIST
70963: PUSH
70964: LD_INT 2
70966: PUSH
70967: LD_INT 1
70969: NEG
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PUSH
70975: LD_INT 3
70977: PUSH
70978: LD_INT 0
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: LD_INT 3
70987: PUSH
70988: LD_INT 1
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: PUSH
70995: LD_INT 3
70997: PUSH
70998: LD_INT 2
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 3
71007: PUSH
71008: LD_INT 3
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: PUSH
71015: LD_INT 2
71017: PUSH
71018: LD_INT 3
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: PUSH
71025: LD_INT 2
71027: NEG
71028: PUSH
71029: LD_INT 1
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: PUSH
71036: LD_INT 3
71038: NEG
71039: PUSH
71040: LD_INT 0
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: PUSH
71047: LD_INT 3
71049: NEG
71050: PUSH
71051: LD_INT 1
71053: NEG
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 3
71061: NEG
71062: PUSH
71063: LD_INT 2
71065: NEG
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 3
71073: NEG
71074: PUSH
71075: LD_INT 3
71077: NEG
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: LIST
71098: LIST
71099: LIST
71100: LIST
71101: LIST
71102: LIST
71103: LIST
71104: LIST
71105: LIST
71106: LIST
71107: LIST
71108: LIST
71109: LIST
71110: LIST
71111: LIST
71112: LIST
71113: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71114: LD_ADDR_VAR 0 42
71118: PUSH
71119: LD_INT 0
71121: PUSH
71122: LD_INT 0
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: PUSH
71129: LD_INT 0
71131: PUSH
71132: LD_INT 1
71134: NEG
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: PUSH
71140: LD_INT 1
71142: PUSH
71143: LD_INT 0
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: PUSH
71150: LD_INT 1
71152: PUSH
71153: LD_INT 1
71155: PUSH
71156: EMPTY
71157: LIST
71158: LIST
71159: PUSH
71160: LD_INT 0
71162: PUSH
71163: LD_INT 1
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 1
71172: NEG
71173: PUSH
71174: LD_INT 0
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: LD_INT 1
71183: NEG
71184: PUSH
71185: LD_INT 1
71187: NEG
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 1
71195: NEG
71196: PUSH
71197: LD_INT 2
71199: NEG
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 0
71207: PUSH
71208: LD_INT 2
71210: NEG
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 1
71218: PUSH
71219: LD_INT 1
71221: NEG
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 2
71229: PUSH
71230: LD_INT 1
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PUSH
71237: LD_INT 2
71239: PUSH
71240: LD_INT 2
71242: PUSH
71243: EMPTY
71244: LIST
71245: LIST
71246: PUSH
71247: LD_INT 1
71249: PUSH
71250: LD_INT 2
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 0
71259: PUSH
71260: LD_INT 2
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 1
71269: NEG
71270: PUSH
71271: LD_INT 1
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 2
71280: NEG
71281: PUSH
71282: LD_INT 1
71284: NEG
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 2
71292: NEG
71293: PUSH
71294: LD_INT 2
71296: NEG
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PUSH
71302: LD_INT 2
71304: NEG
71305: PUSH
71306: LD_INT 3
71308: NEG
71309: PUSH
71310: EMPTY
71311: LIST
71312: LIST
71313: PUSH
71314: LD_INT 1
71316: NEG
71317: PUSH
71318: LD_INT 3
71320: NEG
71321: PUSH
71322: EMPTY
71323: LIST
71324: LIST
71325: PUSH
71326: LD_INT 0
71328: PUSH
71329: LD_INT 3
71331: NEG
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 1
71339: PUSH
71340: LD_INT 2
71342: NEG
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: PUSH
71348: LD_INT 3
71350: PUSH
71351: LD_INT 2
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: PUSH
71358: LD_INT 3
71360: PUSH
71361: LD_INT 3
71363: PUSH
71364: EMPTY
71365: LIST
71366: LIST
71367: PUSH
71368: LD_INT 2
71370: PUSH
71371: LD_INT 3
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 1
71380: PUSH
71381: LD_INT 3
71383: PUSH
71384: EMPTY
71385: LIST
71386: LIST
71387: PUSH
71388: LD_INT 0
71390: PUSH
71391: LD_INT 3
71393: PUSH
71394: EMPTY
71395: LIST
71396: LIST
71397: PUSH
71398: LD_INT 1
71400: NEG
71401: PUSH
71402: LD_INT 2
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 3
71411: NEG
71412: PUSH
71413: LD_INT 2
71415: NEG
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PUSH
71421: LD_INT 3
71423: NEG
71424: PUSH
71425: LD_INT 3
71427: NEG
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: LIST
71445: LIST
71446: LIST
71447: LIST
71448: LIST
71449: LIST
71450: LIST
71451: LIST
71452: LIST
71453: LIST
71454: LIST
71455: LIST
71456: LIST
71457: LIST
71458: LIST
71459: LIST
71460: LIST
71461: LIST
71462: LIST
71463: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71464: LD_ADDR_VAR 0 43
71468: PUSH
71469: LD_INT 0
71471: PUSH
71472: LD_INT 0
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 0
71481: PUSH
71482: LD_INT 1
71484: NEG
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: PUSH
71490: LD_INT 1
71492: PUSH
71493: LD_INT 0
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 1
71502: PUSH
71503: LD_INT 1
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: PUSH
71510: LD_INT 0
71512: PUSH
71513: LD_INT 1
71515: PUSH
71516: EMPTY
71517: LIST
71518: LIST
71519: PUSH
71520: LD_INT 1
71522: NEG
71523: PUSH
71524: LD_INT 0
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 1
71533: NEG
71534: PUSH
71535: LD_INT 1
71537: NEG
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: PUSH
71543: LD_INT 1
71545: NEG
71546: PUSH
71547: LD_INT 2
71549: NEG
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: PUSH
71555: LD_INT 0
71557: PUSH
71558: LD_INT 2
71560: NEG
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 1
71568: PUSH
71569: LD_INT 1
71571: NEG
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 2
71579: PUSH
71580: LD_INT 0
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 2
71589: PUSH
71590: LD_INT 1
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: LD_INT 1
71599: PUSH
71600: LD_INT 2
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 0
71609: PUSH
71610: LD_INT 2
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: LD_INT 1
71619: NEG
71620: PUSH
71621: LD_INT 1
71623: PUSH
71624: EMPTY
71625: LIST
71626: LIST
71627: PUSH
71628: LD_INT 2
71630: NEG
71631: PUSH
71632: LD_INT 0
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 2
71641: NEG
71642: PUSH
71643: LD_INT 1
71645: NEG
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: LD_INT 1
71653: NEG
71654: PUSH
71655: LD_INT 3
71657: NEG
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: PUSH
71663: LD_INT 0
71665: PUSH
71666: LD_INT 3
71668: NEG
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: PUSH
71674: LD_INT 1
71676: PUSH
71677: LD_INT 2
71679: NEG
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: PUSH
71685: LD_INT 2
71687: PUSH
71688: LD_INT 1
71690: NEG
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PUSH
71696: LD_INT 3
71698: PUSH
71699: LD_INT 0
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: PUSH
71706: LD_INT 3
71708: PUSH
71709: LD_INT 1
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: PUSH
71716: LD_INT 1
71718: PUSH
71719: LD_INT 3
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: PUSH
71726: LD_INT 0
71728: PUSH
71729: LD_INT 3
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 1
71738: NEG
71739: PUSH
71740: LD_INT 2
71742: PUSH
71743: EMPTY
71744: LIST
71745: LIST
71746: PUSH
71747: LD_INT 2
71749: NEG
71750: PUSH
71751: LD_INT 1
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 3
71760: NEG
71761: PUSH
71762: LD_INT 0
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 3
71771: NEG
71772: PUSH
71773: LD_INT 1
71775: NEG
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: EMPTY
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: LIST
71797: LIST
71798: LIST
71799: LIST
71800: LIST
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: LIST
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71812: LD_ADDR_VAR 0 44
71816: PUSH
71817: LD_INT 0
71819: PUSH
71820: LD_INT 0
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 0
71829: PUSH
71830: LD_INT 1
71832: NEG
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 1
71840: PUSH
71841: LD_INT 0
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 1
71850: PUSH
71851: LD_INT 1
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: PUSH
71858: LD_INT 0
71860: PUSH
71861: LD_INT 1
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PUSH
71868: LD_INT 1
71870: NEG
71871: PUSH
71872: LD_INT 0
71874: PUSH
71875: EMPTY
71876: LIST
71877: LIST
71878: PUSH
71879: LD_INT 1
71881: NEG
71882: PUSH
71883: LD_INT 1
71885: NEG
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: PUSH
71891: LD_INT 1
71893: NEG
71894: PUSH
71895: LD_INT 2
71897: NEG
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 1
71905: PUSH
71906: LD_INT 1
71908: NEG
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 2
71916: PUSH
71917: LD_INT 0
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: LD_INT 2
71926: PUSH
71927: LD_INT 1
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 2
71936: PUSH
71937: LD_INT 2
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: LD_INT 1
71946: PUSH
71947: LD_INT 2
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: PUSH
71954: LD_INT 1
71956: NEG
71957: PUSH
71958: LD_INT 1
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 2
71967: NEG
71968: PUSH
71969: LD_INT 0
71971: PUSH
71972: EMPTY
71973: LIST
71974: LIST
71975: PUSH
71976: LD_INT 2
71978: NEG
71979: PUSH
71980: LD_INT 1
71982: NEG
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 2
71990: NEG
71991: PUSH
71992: LD_INT 2
71994: NEG
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 2
72002: NEG
72003: PUSH
72004: LD_INT 3
72006: NEG
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: PUSH
72012: LD_INT 2
72014: PUSH
72015: LD_INT 1
72017: NEG
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 3
72025: PUSH
72026: LD_INT 0
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 3
72035: PUSH
72036: LD_INT 1
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 3
72045: PUSH
72046: LD_INT 2
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 3
72055: PUSH
72056: LD_INT 3
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: LD_INT 2
72065: PUSH
72066: LD_INT 3
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: PUSH
72073: LD_INT 2
72075: NEG
72076: PUSH
72077: LD_INT 1
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: LD_INT 3
72086: NEG
72087: PUSH
72088: LD_INT 0
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: PUSH
72095: LD_INT 3
72097: NEG
72098: PUSH
72099: LD_INT 1
72101: NEG
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 3
72109: NEG
72110: PUSH
72111: LD_INT 2
72113: NEG
72114: PUSH
72115: EMPTY
72116: LIST
72117: LIST
72118: PUSH
72119: LD_INT 3
72121: NEG
72122: PUSH
72123: LD_INT 3
72125: NEG
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: EMPTY
72132: LIST
72133: LIST
72134: LIST
72135: LIST
72136: LIST
72137: LIST
72138: LIST
72139: LIST
72140: LIST
72141: LIST
72142: LIST
72143: LIST
72144: LIST
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: LIST
72150: LIST
72151: LIST
72152: LIST
72153: LIST
72154: LIST
72155: LIST
72156: LIST
72157: LIST
72158: LIST
72159: LIST
72160: LIST
72161: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72162: LD_ADDR_VAR 0 45
72166: PUSH
72167: LD_INT 0
72169: PUSH
72170: LD_INT 0
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 0
72179: PUSH
72180: LD_INT 1
72182: NEG
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PUSH
72188: LD_INT 1
72190: PUSH
72191: LD_INT 0
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: LD_INT 1
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 0
72210: PUSH
72211: LD_INT 1
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 1
72220: NEG
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 1
72231: NEG
72232: PUSH
72233: LD_INT 1
72235: NEG
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 1
72243: NEG
72244: PUSH
72245: LD_INT 2
72247: NEG
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 0
72255: PUSH
72256: LD_INT 2
72258: NEG
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 1
72266: PUSH
72267: LD_INT 1
72269: NEG
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 2
72277: PUSH
72278: LD_INT 1
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 2
72287: PUSH
72288: LD_INT 2
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 1
72297: PUSH
72298: LD_INT 2
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 0
72307: PUSH
72308: LD_INT 2
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 1
72317: NEG
72318: PUSH
72319: LD_INT 1
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: LD_INT 2
72328: NEG
72329: PUSH
72330: LD_INT 1
72332: NEG
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: LD_INT 2
72340: NEG
72341: PUSH
72342: LD_INT 2
72344: NEG
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 2
72352: NEG
72353: PUSH
72354: LD_INT 3
72356: NEG
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: LD_INT 1
72364: NEG
72365: PUSH
72366: LD_INT 3
72368: NEG
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: PUSH
72374: LD_INT 0
72376: PUSH
72377: LD_INT 3
72379: NEG
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 1
72387: PUSH
72388: LD_INT 2
72390: NEG
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: PUSH
72396: LD_INT 3
72398: PUSH
72399: LD_INT 2
72401: PUSH
72402: EMPTY
72403: LIST
72404: LIST
72405: PUSH
72406: LD_INT 3
72408: PUSH
72409: LD_INT 3
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: LD_INT 2
72418: PUSH
72419: LD_INT 3
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 1
72428: PUSH
72429: LD_INT 3
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: LD_INT 0
72438: PUSH
72439: LD_INT 3
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 1
72448: NEG
72449: PUSH
72450: LD_INT 2
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: PUSH
72457: LD_INT 3
72459: NEG
72460: PUSH
72461: LD_INT 2
72463: NEG
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: PUSH
72469: LD_INT 3
72471: NEG
72472: PUSH
72473: LD_INT 3
72475: NEG
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: LIST
72493: LIST
72494: LIST
72495: LIST
72496: LIST
72497: LIST
72498: LIST
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: LIST
72510: LIST
72511: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72512: LD_ADDR_VAR 0 46
72516: PUSH
72517: LD_INT 0
72519: PUSH
72520: LD_INT 0
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PUSH
72527: LD_INT 0
72529: PUSH
72530: LD_INT 1
72532: NEG
72533: PUSH
72534: EMPTY
72535: LIST
72536: LIST
72537: PUSH
72538: LD_INT 1
72540: PUSH
72541: LD_INT 0
72543: PUSH
72544: EMPTY
72545: LIST
72546: LIST
72547: PUSH
72548: LD_INT 1
72550: PUSH
72551: LD_INT 1
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: PUSH
72558: LD_INT 0
72560: PUSH
72561: LD_INT 1
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 1
72570: NEG
72571: PUSH
72572: LD_INT 0
72574: PUSH
72575: EMPTY
72576: LIST
72577: LIST
72578: PUSH
72579: LD_INT 1
72581: NEG
72582: PUSH
72583: LD_INT 1
72585: NEG
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: PUSH
72591: LD_INT 1
72593: NEG
72594: PUSH
72595: LD_INT 2
72597: NEG
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 0
72605: PUSH
72606: LD_INT 2
72608: NEG
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: LD_INT 1
72616: PUSH
72617: LD_INT 1
72619: NEG
72620: PUSH
72621: EMPTY
72622: LIST
72623: LIST
72624: PUSH
72625: LD_INT 2
72627: PUSH
72628: LD_INT 0
72630: PUSH
72631: EMPTY
72632: LIST
72633: LIST
72634: PUSH
72635: LD_INT 2
72637: PUSH
72638: LD_INT 1
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 1
72647: PUSH
72648: LD_INT 2
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: LD_INT 0
72657: PUSH
72658: LD_INT 2
72660: PUSH
72661: EMPTY
72662: LIST
72663: LIST
72664: PUSH
72665: LD_INT 1
72667: NEG
72668: PUSH
72669: LD_INT 1
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 2
72678: NEG
72679: PUSH
72680: LD_INT 0
72682: PUSH
72683: EMPTY
72684: LIST
72685: LIST
72686: PUSH
72687: LD_INT 2
72689: NEG
72690: PUSH
72691: LD_INT 1
72693: NEG
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: PUSH
72699: LD_INT 1
72701: NEG
72702: PUSH
72703: LD_INT 3
72705: NEG
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: PUSH
72711: LD_INT 0
72713: PUSH
72714: LD_INT 3
72716: NEG
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 1
72724: PUSH
72725: LD_INT 2
72727: NEG
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 2
72735: PUSH
72736: LD_INT 1
72738: NEG
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: PUSH
72744: LD_INT 3
72746: PUSH
72747: LD_INT 0
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PUSH
72754: LD_INT 3
72756: PUSH
72757: LD_INT 1
72759: PUSH
72760: EMPTY
72761: LIST
72762: LIST
72763: PUSH
72764: LD_INT 1
72766: PUSH
72767: LD_INT 3
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 0
72776: PUSH
72777: LD_INT 3
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: PUSH
72784: LD_INT 1
72786: NEG
72787: PUSH
72788: LD_INT 2
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: PUSH
72795: LD_INT 2
72797: NEG
72798: PUSH
72799: LD_INT 1
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 3
72808: NEG
72809: PUSH
72810: LD_INT 0
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: LD_INT 3
72819: NEG
72820: PUSH
72821: LD_INT 1
72823: NEG
72824: PUSH
72825: EMPTY
72826: LIST
72827: LIST
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: LIST
72848: LIST
72849: LIST
72850: LIST
72851: LIST
72852: LIST
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72860: LD_ADDR_VAR 0 47
72864: PUSH
72865: LD_INT 0
72867: PUSH
72868: LD_INT 0
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 0
72877: PUSH
72878: LD_INT 1
72880: NEG
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: PUSH
72886: LD_INT 1
72888: PUSH
72889: LD_INT 0
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 1
72898: PUSH
72899: LD_INT 1
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 0
72908: PUSH
72909: LD_INT 1
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 1
72918: NEG
72919: PUSH
72920: LD_INT 0
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 1
72929: NEG
72930: PUSH
72931: LD_INT 1
72933: NEG
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: PUSH
72939: LD_INT 1
72941: NEG
72942: PUSH
72943: LD_INT 2
72945: NEG
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 0
72953: PUSH
72954: LD_INT 2
72956: NEG
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 1
72964: PUSH
72965: LD_INT 1
72967: NEG
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: LD_INT 2
72975: NEG
72976: PUSH
72977: LD_INT 1
72979: NEG
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: PUSH
72985: LD_INT 2
72987: NEG
72988: PUSH
72989: LD_INT 2
72991: NEG
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73011: LD_ADDR_VAR 0 48
73015: PUSH
73016: LD_INT 0
73018: PUSH
73019: LD_INT 0
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: LD_INT 0
73028: PUSH
73029: LD_INT 1
73031: NEG
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: LD_INT 1
73039: PUSH
73040: LD_INT 0
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: PUSH
73047: LD_INT 1
73049: PUSH
73050: LD_INT 1
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: LD_INT 0
73059: PUSH
73060: LD_INT 1
73062: PUSH
73063: EMPTY
73064: LIST
73065: LIST
73066: PUSH
73067: LD_INT 1
73069: NEG
73070: PUSH
73071: LD_INT 0
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 1
73080: NEG
73081: PUSH
73082: LD_INT 1
73084: NEG
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 1
73092: NEG
73093: PUSH
73094: LD_INT 2
73096: NEG
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: LD_INT 0
73104: PUSH
73105: LD_INT 2
73107: NEG
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: PUSH
73113: LD_INT 1
73115: PUSH
73116: LD_INT 1
73118: NEG
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: LD_INT 2
73126: PUSH
73127: LD_INT 0
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 2
73136: PUSH
73137: LD_INT 1
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: LIST
73148: LIST
73149: LIST
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: LIST
73155: LIST
73156: LIST
73157: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73158: LD_ADDR_VAR 0 49
73162: PUSH
73163: LD_INT 0
73165: PUSH
73166: LD_INT 0
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PUSH
73173: LD_INT 0
73175: PUSH
73176: LD_INT 1
73178: NEG
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 1
73186: PUSH
73187: LD_INT 0
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: LD_INT 1
73196: PUSH
73197: LD_INT 1
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: PUSH
73204: LD_INT 0
73206: PUSH
73207: LD_INT 1
73209: PUSH
73210: EMPTY
73211: LIST
73212: LIST
73213: PUSH
73214: LD_INT 1
73216: NEG
73217: PUSH
73218: LD_INT 0
73220: PUSH
73221: EMPTY
73222: LIST
73223: LIST
73224: PUSH
73225: LD_INT 1
73227: NEG
73228: PUSH
73229: LD_INT 1
73231: NEG
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: LD_INT 1
73239: PUSH
73240: LD_INT 1
73242: NEG
73243: PUSH
73244: EMPTY
73245: LIST
73246: LIST
73247: PUSH
73248: LD_INT 2
73250: PUSH
73251: LD_INT 0
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 2
73260: PUSH
73261: LD_INT 1
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: PUSH
73268: LD_INT 2
73270: PUSH
73271: LD_INT 2
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 1
73280: PUSH
73281: LD_INT 2
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: LIST
73296: LIST
73297: LIST
73298: LIST
73299: LIST
73300: LIST
73301: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73302: LD_ADDR_VAR 0 50
73306: PUSH
73307: LD_INT 0
73309: PUSH
73310: LD_INT 0
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: PUSH
73317: LD_INT 0
73319: PUSH
73320: LD_INT 1
73322: NEG
73323: PUSH
73324: EMPTY
73325: LIST
73326: LIST
73327: PUSH
73328: LD_INT 1
73330: PUSH
73331: LD_INT 0
73333: PUSH
73334: EMPTY
73335: LIST
73336: LIST
73337: PUSH
73338: LD_INT 1
73340: PUSH
73341: LD_INT 1
73343: PUSH
73344: EMPTY
73345: LIST
73346: LIST
73347: PUSH
73348: LD_INT 0
73350: PUSH
73351: LD_INT 1
73353: PUSH
73354: EMPTY
73355: LIST
73356: LIST
73357: PUSH
73358: LD_INT 1
73360: NEG
73361: PUSH
73362: LD_INT 0
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: PUSH
73369: LD_INT 1
73371: NEG
73372: PUSH
73373: LD_INT 1
73375: NEG
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PUSH
73381: LD_INT 2
73383: PUSH
73384: LD_INT 1
73386: PUSH
73387: EMPTY
73388: LIST
73389: LIST
73390: PUSH
73391: LD_INT 2
73393: PUSH
73394: LD_INT 2
73396: PUSH
73397: EMPTY
73398: LIST
73399: LIST
73400: PUSH
73401: LD_INT 1
73403: PUSH
73404: LD_INT 2
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 0
73413: PUSH
73414: LD_INT 2
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: LD_INT 1
73423: NEG
73424: PUSH
73425: LD_INT 1
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: LIST
73436: LIST
73437: LIST
73438: LIST
73439: LIST
73440: LIST
73441: LIST
73442: LIST
73443: LIST
73444: LIST
73445: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73446: LD_ADDR_VAR 0 51
73450: PUSH
73451: LD_INT 0
73453: PUSH
73454: LD_INT 0
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 0
73463: PUSH
73464: LD_INT 1
73466: NEG
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: PUSH
73472: LD_INT 1
73474: PUSH
73475: LD_INT 0
73477: PUSH
73478: EMPTY
73479: LIST
73480: LIST
73481: PUSH
73482: LD_INT 1
73484: PUSH
73485: LD_INT 1
73487: PUSH
73488: EMPTY
73489: LIST
73490: LIST
73491: PUSH
73492: LD_INT 0
73494: PUSH
73495: LD_INT 1
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: LD_INT 1
73504: NEG
73505: PUSH
73506: LD_INT 0
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 1
73515: NEG
73516: PUSH
73517: LD_INT 1
73519: NEG
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: LD_INT 1
73527: PUSH
73528: LD_INT 2
73530: PUSH
73531: EMPTY
73532: LIST
73533: LIST
73534: PUSH
73535: LD_INT 0
73537: PUSH
73538: LD_INT 2
73540: PUSH
73541: EMPTY
73542: LIST
73543: LIST
73544: PUSH
73545: LD_INT 1
73547: NEG
73548: PUSH
73549: LD_INT 1
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: LD_INT 2
73558: NEG
73559: PUSH
73560: LD_INT 0
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PUSH
73567: LD_INT 2
73569: NEG
73570: PUSH
73571: LD_INT 1
73573: NEG
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: LIST
73590: LIST
73591: LIST
73592: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73593: LD_ADDR_VAR 0 52
73597: PUSH
73598: LD_INT 0
73600: PUSH
73601: LD_INT 0
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 0
73610: PUSH
73611: LD_INT 1
73613: NEG
73614: PUSH
73615: EMPTY
73616: LIST
73617: LIST
73618: PUSH
73619: LD_INT 1
73621: PUSH
73622: LD_INT 0
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 1
73631: PUSH
73632: LD_INT 1
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 0
73641: PUSH
73642: LD_INT 1
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 1
73651: NEG
73652: PUSH
73653: LD_INT 0
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: PUSH
73660: LD_INT 1
73662: NEG
73663: PUSH
73664: LD_INT 1
73666: NEG
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 1
73674: NEG
73675: PUSH
73676: LD_INT 2
73678: NEG
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 1
73686: NEG
73687: PUSH
73688: LD_INT 1
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: LD_INT 2
73697: NEG
73698: PUSH
73699: LD_INT 0
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: PUSH
73706: LD_INT 2
73708: NEG
73709: PUSH
73710: LD_INT 1
73712: NEG
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: PUSH
73718: LD_INT 2
73720: NEG
73721: PUSH
73722: LD_INT 2
73724: NEG
73725: PUSH
73726: EMPTY
73727: LIST
73728: LIST
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: LIST
73734: LIST
73735: LIST
73736: LIST
73737: LIST
73738: LIST
73739: LIST
73740: LIST
73741: LIST
73742: LIST
73743: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73744: LD_ADDR_VAR 0 53
73748: PUSH
73749: LD_INT 0
73751: PUSH
73752: LD_INT 0
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: LD_INT 0
73761: PUSH
73762: LD_INT 1
73764: NEG
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: LD_INT 1
73772: PUSH
73773: LD_INT 0
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: PUSH
73780: LD_INT 1
73782: PUSH
73783: LD_INT 1
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 0
73792: PUSH
73793: LD_INT 1
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: LD_INT 1
73802: NEG
73803: PUSH
73804: LD_INT 0
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 1
73813: NEG
73814: PUSH
73815: LD_INT 1
73817: NEG
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 1
73825: NEG
73826: PUSH
73827: LD_INT 2
73829: NEG
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 0
73837: PUSH
73838: LD_INT 2
73840: NEG
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 1
73848: PUSH
73849: LD_INT 1
73851: NEG
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: PUSH
73857: LD_INT 2
73859: PUSH
73860: LD_INT 0
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: PUSH
73867: LD_INT 2
73869: PUSH
73870: LD_INT 1
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 2
73879: PUSH
73880: LD_INT 2
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: LD_INT 1
73889: PUSH
73890: LD_INT 2
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: PUSH
73897: LD_INT 0
73899: PUSH
73900: LD_INT 2
73902: PUSH
73903: EMPTY
73904: LIST
73905: LIST
73906: PUSH
73907: LD_INT 1
73909: NEG
73910: PUSH
73911: LD_INT 1
73913: PUSH
73914: EMPTY
73915: LIST
73916: LIST
73917: PUSH
73918: LD_INT 2
73920: NEG
73921: PUSH
73922: LD_INT 0
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: PUSH
73929: LD_INT 2
73931: NEG
73932: PUSH
73933: LD_INT 1
73935: NEG
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 2
73943: NEG
73944: PUSH
73945: LD_INT 2
73947: NEG
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: LIST
73957: LIST
73958: LIST
73959: LIST
73960: LIST
73961: LIST
73962: LIST
73963: LIST
73964: LIST
73965: LIST
73966: LIST
73967: LIST
73968: LIST
73969: LIST
73970: LIST
73971: LIST
73972: LIST
73973: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73974: LD_ADDR_VAR 0 54
73978: PUSH
73979: LD_INT 0
73981: PUSH
73982: LD_INT 0
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 0
73991: PUSH
73992: LD_INT 1
73994: NEG
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: PUSH
74000: LD_INT 1
74002: PUSH
74003: LD_INT 0
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: LD_INT 1
74012: PUSH
74013: LD_INT 1
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: PUSH
74020: LD_INT 0
74022: PUSH
74023: LD_INT 1
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: PUSH
74030: LD_INT 1
74032: NEG
74033: PUSH
74034: LD_INT 0
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 1
74043: NEG
74044: PUSH
74045: LD_INT 1
74047: NEG
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 1
74055: NEG
74056: PUSH
74057: LD_INT 2
74059: NEG
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: LD_INT 0
74067: PUSH
74068: LD_INT 2
74070: NEG
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 1
74078: PUSH
74079: LD_INT 1
74081: NEG
74082: PUSH
74083: EMPTY
74084: LIST
74085: LIST
74086: PUSH
74087: LD_INT 2
74089: PUSH
74090: LD_INT 0
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: PUSH
74097: LD_INT 2
74099: PUSH
74100: LD_INT 1
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 2
74109: PUSH
74110: LD_INT 2
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: PUSH
74117: LD_INT 1
74119: PUSH
74120: LD_INT 2
74122: PUSH
74123: EMPTY
74124: LIST
74125: LIST
74126: PUSH
74127: LD_INT 0
74129: PUSH
74130: LD_INT 2
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: PUSH
74137: LD_INT 1
74139: NEG
74140: PUSH
74141: LD_INT 1
74143: PUSH
74144: EMPTY
74145: LIST
74146: LIST
74147: PUSH
74148: LD_INT 2
74150: NEG
74151: PUSH
74152: LD_INT 0
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PUSH
74159: LD_INT 2
74161: NEG
74162: PUSH
74163: LD_INT 1
74165: NEG
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 2
74173: NEG
74174: PUSH
74175: LD_INT 2
74177: NEG
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: LIST
74187: LIST
74188: LIST
74189: LIST
74190: LIST
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: LIST
74196: LIST
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74204: LD_ADDR_VAR 0 55
74208: PUSH
74209: LD_INT 0
74211: PUSH
74212: LD_INT 0
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: PUSH
74219: LD_INT 0
74221: PUSH
74222: LD_INT 1
74224: NEG
74225: PUSH
74226: EMPTY
74227: LIST
74228: LIST
74229: PUSH
74230: LD_INT 1
74232: PUSH
74233: LD_INT 0
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: PUSH
74240: LD_INT 1
74242: PUSH
74243: LD_INT 1
74245: PUSH
74246: EMPTY
74247: LIST
74248: LIST
74249: PUSH
74250: LD_INT 0
74252: PUSH
74253: LD_INT 1
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 1
74262: NEG
74263: PUSH
74264: LD_INT 0
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: PUSH
74271: LD_INT 1
74273: NEG
74274: PUSH
74275: LD_INT 1
74277: NEG
74278: PUSH
74279: EMPTY
74280: LIST
74281: LIST
74282: PUSH
74283: LD_INT 1
74285: NEG
74286: PUSH
74287: LD_INT 2
74289: NEG
74290: PUSH
74291: EMPTY
74292: LIST
74293: LIST
74294: PUSH
74295: LD_INT 0
74297: PUSH
74298: LD_INT 2
74300: NEG
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 1
74308: PUSH
74309: LD_INT 1
74311: NEG
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PUSH
74317: LD_INT 2
74319: PUSH
74320: LD_INT 0
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: LD_INT 2
74329: PUSH
74330: LD_INT 1
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 2
74339: PUSH
74340: LD_INT 2
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 1
74349: PUSH
74350: LD_INT 2
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: PUSH
74357: LD_INT 0
74359: PUSH
74360: LD_INT 2
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: PUSH
74367: LD_INT 1
74369: NEG
74370: PUSH
74371: LD_INT 1
74373: PUSH
74374: EMPTY
74375: LIST
74376: LIST
74377: PUSH
74378: LD_INT 2
74380: NEG
74381: PUSH
74382: LD_INT 0
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: LD_INT 2
74391: NEG
74392: PUSH
74393: LD_INT 1
74395: NEG
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: PUSH
74401: LD_INT 2
74403: NEG
74404: PUSH
74405: LD_INT 2
74407: NEG
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: LIST
74425: LIST
74426: LIST
74427: LIST
74428: LIST
74429: LIST
74430: LIST
74431: LIST
74432: LIST
74433: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74434: LD_ADDR_VAR 0 56
74438: PUSH
74439: LD_INT 0
74441: PUSH
74442: LD_INT 0
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: LD_INT 0
74451: PUSH
74452: LD_INT 1
74454: NEG
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_INT 1
74462: PUSH
74463: LD_INT 0
74465: PUSH
74466: EMPTY
74467: LIST
74468: LIST
74469: PUSH
74470: LD_INT 1
74472: PUSH
74473: LD_INT 1
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: PUSH
74480: LD_INT 0
74482: PUSH
74483: LD_INT 1
74485: PUSH
74486: EMPTY
74487: LIST
74488: LIST
74489: PUSH
74490: LD_INT 1
74492: NEG
74493: PUSH
74494: LD_INT 0
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: PUSH
74501: LD_INT 1
74503: NEG
74504: PUSH
74505: LD_INT 1
74507: NEG
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: PUSH
74513: LD_INT 1
74515: NEG
74516: PUSH
74517: LD_INT 2
74519: NEG
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_INT 0
74527: PUSH
74528: LD_INT 2
74530: NEG
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: PUSH
74536: LD_INT 1
74538: PUSH
74539: LD_INT 1
74541: NEG
74542: PUSH
74543: EMPTY
74544: LIST
74545: LIST
74546: PUSH
74547: LD_INT 2
74549: PUSH
74550: LD_INT 0
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: PUSH
74557: LD_INT 2
74559: PUSH
74560: LD_INT 1
74562: PUSH
74563: EMPTY
74564: LIST
74565: LIST
74566: PUSH
74567: LD_INT 2
74569: PUSH
74570: LD_INT 2
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 1
74579: PUSH
74580: LD_INT 2
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: LD_INT 0
74589: PUSH
74590: LD_INT 2
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 1
74599: NEG
74600: PUSH
74601: LD_INT 1
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 2
74610: NEG
74611: PUSH
74612: LD_INT 0
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: PUSH
74619: LD_INT 2
74621: NEG
74622: PUSH
74623: LD_INT 1
74625: NEG
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 2
74633: NEG
74634: PUSH
74635: LD_INT 2
74637: NEG
74638: PUSH
74639: EMPTY
74640: LIST
74641: LIST
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: LIST
74647: LIST
74648: LIST
74649: LIST
74650: LIST
74651: LIST
74652: LIST
74653: LIST
74654: LIST
74655: LIST
74656: LIST
74657: LIST
74658: LIST
74659: LIST
74660: LIST
74661: LIST
74662: LIST
74663: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74664: LD_ADDR_VAR 0 57
74668: PUSH
74669: LD_INT 0
74671: PUSH
74672: LD_INT 0
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: PUSH
74679: LD_INT 0
74681: PUSH
74682: LD_INT 1
74684: NEG
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: LD_INT 1
74692: PUSH
74693: LD_INT 0
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: LD_INT 1
74702: PUSH
74703: LD_INT 1
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 0
74712: PUSH
74713: LD_INT 1
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 1
74722: NEG
74723: PUSH
74724: LD_INT 0
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PUSH
74731: LD_INT 1
74733: NEG
74734: PUSH
74735: LD_INT 1
74737: NEG
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: PUSH
74743: LD_INT 1
74745: NEG
74746: PUSH
74747: LD_INT 2
74749: NEG
74750: PUSH
74751: EMPTY
74752: LIST
74753: LIST
74754: PUSH
74755: LD_INT 0
74757: PUSH
74758: LD_INT 2
74760: NEG
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: LD_INT 1
74768: PUSH
74769: LD_INT 1
74771: NEG
74772: PUSH
74773: EMPTY
74774: LIST
74775: LIST
74776: PUSH
74777: LD_INT 2
74779: PUSH
74780: LD_INT 0
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: PUSH
74787: LD_INT 2
74789: PUSH
74790: LD_INT 1
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 2
74799: PUSH
74800: LD_INT 2
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 1
74809: PUSH
74810: LD_INT 2
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 0
74819: PUSH
74820: LD_INT 2
74822: PUSH
74823: EMPTY
74824: LIST
74825: LIST
74826: PUSH
74827: LD_INT 1
74829: NEG
74830: PUSH
74831: LD_INT 1
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 2
74840: NEG
74841: PUSH
74842: LD_INT 0
74844: PUSH
74845: EMPTY
74846: LIST
74847: LIST
74848: PUSH
74849: LD_INT 2
74851: NEG
74852: PUSH
74853: LD_INT 1
74855: NEG
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 2
74863: NEG
74864: PUSH
74865: LD_INT 2
74867: NEG
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: LIST
74877: LIST
74878: LIST
74879: LIST
74880: LIST
74881: LIST
74882: LIST
74883: LIST
74884: LIST
74885: LIST
74886: LIST
74887: LIST
74888: LIST
74889: LIST
74890: LIST
74891: LIST
74892: LIST
74893: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74894: LD_ADDR_VAR 0 58
74898: PUSH
74899: LD_INT 0
74901: PUSH
74902: LD_INT 0
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 0
74911: PUSH
74912: LD_INT 1
74914: NEG
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: PUSH
74920: LD_INT 1
74922: PUSH
74923: LD_INT 0
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: LD_INT 1
74932: PUSH
74933: LD_INT 1
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: LD_INT 0
74942: PUSH
74943: LD_INT 1
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: LD_INT 1
74952: NEG
74953: PUSH
74954: LD_INT 0
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: PUSH
74961: LD_INT 1
74963: NEG
74964: PUSH
74965: LD_INT 1
74967: NEG
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 1
74975: NEG
74976: PUSH
74977: LD_INT 2
74979: NEG
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 0
74987: PUSH
74988: LD_INT 2
74990: NEG
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: LD_INT 1
74998: PUSH
74999: LD_INT 1
75001: NEG
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 2
75009: PUSH
75010: LD_INT 0
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 2
75019: PUSH
75020: LD_INT 1
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: PUSH
75027: LD_INT 2
75029: PUSH
75030: LD_INT 2
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 1
75039: PUSH
75040: LD_INT 2
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 0
75049: PUSH
75050: LD_INT 2
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 1
75059: NEG
75060: PUSH
75061: LD_INT 1
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: PUSH
75068: LD_INT 2
75070: NEG
75071: PUSH
75072: LD_INT 0
75074: PUSH
75075: EMPTY
75076: LIST
75077: LIST
75078: PUSH
75079: LD_INT 2
75081: NEG
75082: PUSH
75083: LD_INT 1
75085: NEG
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: LD_INT 2
75093: NEG
75094: PUSH
75095: LD_INT 2
75097: NEG
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: LIST
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: LIST
75119: LIST
75120: LIST
75121: LIST
75122: LIST
75123: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75124: LD_ADDR_VAR 0 59
75128: PUSH
75129: LD_INT 0
75131: PUSH
75132: LD_INT 0
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 0
75141: PUSH
75142: LD_INT 1
75144: NEG
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: LD_INT 1
75152: PUSH
75153: LD_INT 0
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 1
75162: PUSH
75163: LD_INT 1
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 0
75172: PUSH
75173: LD_INT 1
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: LD_INT 1
75182: NEG
75183: PUSH
75184: LD_INT 0
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: PUSH
75191: LD_INT 1
75193: NEG
75194: PUSH
75195: LD_INT 1
75197: NEG
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75212: LD_ADDR_VAR 0 60
75216: PUSH
75217: LD_INT 0
75219: PUSH
75220: LD_INT 0
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 0
75229: PUSH
75230: LD_INT 1
75232: NEG
75233: PUSH
75234: EMPTY
75235: LIST
75236: LIST
75237: PUSH
75238: LD_INT 1
75240: PUSH
75241: LD_INT 0
75243: PUSH
75244: EMPTY
75245: LIST
75246: LIST
75247: PUSH
75248: LD_INT 1
75250: PUSH
75251: LD_INT 1
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: PUSH
75258: LD_INT 0
75260: PUSH
75261: LD_INT 1
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: LD_INT 1
75270: NEG
75271: PUSH
75272: LD_INT 0
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 1
75281: NEG
75282: PUSH
75283: LD_INT 1
75285: NEG
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: LIST
75295: LIST
75296: LIST
75297: LIST
75298: LIST
75299: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75300: LD_ADDR_VAR 0 61
75304: PUSH
75305: LD_INT 0
75307: PUSH
75308: LD_INT 0
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 0
75317: PUSH
75318: LD_INT 1
75320: NEG
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 1
75328: PUSH
75329: LD_INT 0
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 1
75338: PUSH
75339: LD_INT 1
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 0
75348: PUSH
75349: LD_INT 1
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: LD_INT 1
75358: NEG
75359: PUSH
75360: LD_INT 0
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 1
75369: NEG
75370: PUSH
75371: LD_INT 1
75373: NEG
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: PUSH
75379: EMPTY
75380: LIST
75381: LIST
75382: LIST
75383: LIST
75384: LIST
75385: LIST
75386: LIST
75387: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75388: LD_ADDR_VAR 0 62
75392: PUSH
75393: LD_INT 0
75395: PUSH
75396: LD_INT 0
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: LD_INT 0
75405: PUSH
75406: LD_INT 1
75408: NEG
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: PUSH
75414: LD_INT 1
75416: PUSH
75417: LD_INT 0
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: LD_INT 1
75426: PUSH
75427: LD_INT 1
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: PUSH
75434: LD_INT 0
75436: PUSH
75437: LD_INT 1
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: LD_INT 1
75446: NEG
75447: PUSH
75448: LD_INT 0
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: PUSH
75455: LD_INT 1
75457: NEG
75458: PUSH
75459: LD_INT 1
75461: NEG
75462: PUSH
75463: EMPTY
75464: LIST
75465: LIST
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: LIST
75471: LIST
75472: LIST
75473: LIST
75474: LIST
75475: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75476: LD_ADDR_VAR 0 63
75480: PUSH
75481: LD_INT 0
75483: PUSH
75484: LD_INT 0
75486: PUSH
75487: EMPTY
75488: LIST
75489: LIST
75490: PUSH
75491: LD_INT 0
75493: PUSH
75494: LD_INT 1
75496: NEG
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: PUSH
75502: LD_INT 1
75504: PUSH
75505: LD_INT 0
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: PUSH
75512: LD_INT 1
75514: PUSH
75515: LD_INT 1
75517: PUSH
75518: EMPTY
75519: LIST
75520: LIST
75521: PUSH
75522: LD_INT 0
75524: PUSH
75525: LD_INT 1
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: PUSH
75532: LD_INT 1
75534: NEG
75535: PUSH
75536: LD_INT 0
75538: PUSH
75539: EMPTY
75540: LIST
75541: LIST
75542: PUSH
75543: LD_INT 1
75545: NEG
75546: PUSH
75547: LD_INT 1
75549: NEG
75550: PUSH
75551: EMPTY
75552: LIST
75553: LIST
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75564: LD_ADDR_VAR 0 64
75568: PUSH
75569: LD_INT 0
75571: PUSH
75572: LD_INT 0
75574: PUSH
75575: EMPTY
75576: LIST
75577: LIST
75578: PUSH
75579: LD_INT 0
75581: PUSH
75582: LD_INT 1
75584: NEG
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: PUSH
75590: LD_INT 1
75592: PUSH
75593: LD_INT 0
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 1
75602: PUSH
75603: LD_INT 1
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: PUSH
75610: LD_INT 0
75612: PUSH
75613: LD_INT 1
75615: PUSH
75616: EMPTY
75617: LIST
75618: LIST
75619: PUSH
75620: LD_INT 1
75622: NEG
75623: PUSH
75624: LD_INT 0
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 1
75633: NEG
75634: PUSH
75635: LD_INT 1
75637: NEG
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: LIST
75647: LIST
75648: LIST
75649: LIST
75650: LIST
75651: ST_TO_ADDR
// end ; 1 :
75652: GO 81549
75654: LD_INT 1
75656: DOUBLE
75657: EQUAL
75658: IFTRUE 75662
75660: GO 78285
75662: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75663: LD_ADDR_VAR 0 11
75667: PUSH
75668: LD_INT 1
75670: NEG
75671: PUSH
75672: LD_INT 3
75674: NEG
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 0
75682: PUSH
75683: LD_INT 3
75685: NEG
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 1
75693: PUSH
75694: LD_INT 2
75696: NEG
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: LIST
75706: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75707: LD_ADDR_VAR 0 12
75711: PUSH
75712: LD_INT 2
75714: PUSH
75715: LD_INT 1
75717: NEG
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: PUSH
75723: LD_INT 3
75725: PUSH
75726: LD_INT 0
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 3
75735: PUSH
75736: LD_INT 1
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: PUSH
75743: EMPTY
75744: LIST
75745: LIST
75746: LIST
75747: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75748: LD_ADDR_VAR 0 13
75752: PUSH
75753: LD_INT 3
75755: PUSH
75756: LD_INT 2
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 3
75765: PUSH
75766: LD_INT 3
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PUSH
75773: LD_INT 2
75775: PUSH
75776: LD_INT 3
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: LIST
75787: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75788: LD_ADDR_VAR 0 14
75792: PUSH
75793: LD_INT 1
75795: PUSH
75796: LD_INT 3
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PUSH
75803: LD_INT 0
75805: PUSH
75806: LD_INT 3
75808: PUSH
75809: EMPTY
75810: LIST
75811: LIST
75812: PUSH
75813: LD_INT 1
75815: NEG
75816: PUSH
75817: LD_INT 2
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: LIST
75828: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75829: LD_ADDR_VAR 0 15
75833: PUSH
75834: LD_INT 2
75836: NEG
75837: PUSH
75838: LD_INT 1
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 3
75847: NEG
75848: PUSH
75849: LD_INT 0
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: PUSH
75856: LD_INT 3
75858: NEG
75859: PUSH
75860: LD_INT 1
75862: NEG
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PUSH
75868: EMPTY
75869: LIST
75870: LIST
75871: LIST
75872: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75873: LD_ADDR_VAR 0 16
75877: PUSH
75878: LD_INT 2
75880: NEG
75881: PUSH
75882: LD_INT 3
75884: NEG
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: LD_INT 3
75892: NEG
75893: PUSH
75894: LD_INT 2
75896: NEG
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PUSH
75902: LD_INT 3
75904: NEG
75905: PUSH
75906: LD_INT 3
75908: NEG
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: PUSH
75914: EMPTY
75915: LIST
75916: LIST
75917: LIST
75918: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75919: LD_ADDR_VAR 0 17
75923: PUSH
75924: LD_INT 1
75926: NEG
75927: PUSH
75928: LD_INT 3
75930: NEG
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: PUSH
75936: LD_INT 0
75938: PUSH
75939: LD_INT 3
75941: NEG
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 1
75949: PUSH
75950: LD_INT 2
75952: NEG
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: LIST
75962: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75963: LD_ADDR_VAR 0 18
75967: PUSH
75968: LD_INT 2
75970: PUSH
75971: LD_INT 1
75973: NEG
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: LD_INT 3
75981: PUSH
75982: LD_INT 0
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: LD_INT 3
75991: PUSH
75992: LD_INT 1
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: LIST
76003: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76004: LD_ADDR_VAR 0 19
76008: PUSH
76009: LD_INT 3
76011: PUSH
76012: LD_INT 2
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 3
76021: PUSH
76022: LD_INT 3
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 2
76031: PUSH
76032: LD_INT 3
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: LIST
76043: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76044: LD_ADDR_VAR 0 20
76048: PUSH
76049: LD_INT 1
76051: PUSH
76052: LD_INT 3
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PUSH
76059: LD_INT 0
76061: PUSH
76062: LD_INT 3
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: PUSH
76069: LD_INT 1
76071: NEG
76072: PUSH
76073: LD_INT 2
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: LIST
76084: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76085: LD_ADDR_VAR 0 21
76089: PUSH
76090: LD_INT 2
76092: NEG
76093: PUSH
76094: LD_INT 1
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 3
76103: NEG
76104: PUSH
76105: LD_INT 0
76107: PUSH
76108: EMPTY
76109: LIST
76110: LIST
76111: PUSH
76112: LD_INT 3
76114: NEG
76115: PUSH
76116: LD_INT 1
76118: NEG
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: LIST
76128: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76129: LD_ADDR_VAR 0 22
76133: PUSH
76134: LD_INT 2
76136: NEG
76137: PUSH
76138: LD_INT 3
76140: NEG
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 3
76148: NEG
76149: PUSH
76150: LD_INT 2
76152: NEG
76153: PUSH
76154: EMPTY
76155: LIST
76156: LIST
76157: PUSH
76158: LD_INT 3
76160: NEG
76161: PUSH
76162: LD_INT 3
76164: NEG
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: LIST
76174: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76175: LD_ADDR_VAR 0 23
76179: PUSH
76180: LD_INT 0
76182: PUSH
76183: LD_INT 3
76185: NEG
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: PUSH
76191: LD_INT 1
76193: NEG
76194: PUSH
76195: LD_INT 4
76197: NEG
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: PUSH
76203: LD_INT 1
76205: PUSH
76206: LD_INT 3
76208: NEG
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: EMPTY
76215: LIST
76216: LIST
76217: LIST
76218: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76219: LD_ADDR_VAR 0 24
76223: PUSH
76224: LD_INT 3
76226: PUSH
76227: LD_INT 0
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 3
76236: PUSH
76237: LD_INT 1
76239: NEG
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: LD_INT 4
76247: PUSH
76248: LD_INT 1
76250: PUSH
76251: EMPTY
76252: LIST
76253: LIST
76254: PUSH
76255: EMPTY
76256: LIST
76257: LIST
76258: LIST
76259: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76260: LD_ADDR_VAR 0 25
76264: PUSH
76265: LD_INT 3
76267: PUSH
76268: LD_INT 3
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: PUSH
76275: LD_INT 4
76277: PUSH
76278: LD_INT 3
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 3
76287: PUSH
76288: LD_INT 4
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: LIST
76299: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76300: LD_ADDR_VAR 0 26
76304: PUSH
76305: LD_INT 0
76307: PUSH
76308: LD_INT 3
76310: PUSH
76311: EMPTY
76312: LIST
76313: LIST
76314: PUSH
76315: LD_INT 1
76317: PUSH
76318: LD_INT 4
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 1
76327: NEG
76328: PUSH
76329: LD_INT 3
76331: PUSH
76332: EMPTY
76333: LIST
76334: LIST
76335: PUSH
76336: EMPTY
76337: LIST
76338: LIST
76339: LIST
76340: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76341: LD_ADDR_VAR 0 27
76345: PUSH
76346: LD_INT 3
76348: NEG
76349: PUSH
76350: LD_INT 0
76352: PUSH
76353: EMPTY
76354: LIST
76355: LIST
76356: PUSH
76357: LD_INT 3
76359: NEG
76360: PUSH
76361: LD_INT 1
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 4
76370: NEG
76371: PUSH
76372: LD_INT 1
76374: NEG
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: LIST
76384: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76385: LD_ADDR_VAR 0 28
76389: PUSH
76390: LD_INT 3
76392: NEG
76393: PUSH
76394: LD_INT 3
76396: NEG
76397: PUSH
76398: EMPTY
76399: LIST
76400: LIST
76401: PUSH
76402: LD_INT 3
76404: NEG
76405: PUSH
76406: LD_INT 4
76408: NEG
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: LD_INT 4
76416: NEG
76417: PUSH
76418: LD_INT 3
76420: NEG
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: LIST
76430: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76431: LD_ADDR_VAR 0 29
76435: PUSH
76436: LD_INT 1
76438: NEG
76439: PUSH
76440: LD_INT 3
76442: NEG
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PUSH
76448: LD_INT 0
76450: PUSH
76451: LD_INT 3
76453: NEG
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PUSH
76459: LD_INT 1
76461: PUSH
76462: LD_INT 2
76464: NEG
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: LD_INT 1
76472: NEG
76473: PUSH
76474: LD_INT 4
76476: NEG
76477: PUSH
76478: EMPTY
76479: LIST
76480: LIST
76481: PUSH
76482: LD_INT 0
76484: PUSH
76485: LD_INT 4
76487: NEG
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: PUSH
76493: LD_INT 1
76495: PUSH
76496: LD_INT 3
76498: NEG
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 1
76506: NEG
76507: PUSH
76508: LD_INT 5
76510: NEG
76511: PUSH
76512: EMPTY
76513: LIST
76514: LIST
76515: PUSH
76516: LD_INT 0
76518: PUSH
76519: LD_INT 5
76521: NEG
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: PUSH
76527: LD_INT 1
76529: PUSH
76530: LD_INT 4
76532: NEG
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 1
76540: NEG
76541: PUSH
76542: LD_INT 6
76544: NEG
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: PUSH
76550: LD_INT 0
76552: PUSH
76553: LD_INT 6
76555: NEG
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: PUSH
76561: LD_INT 1
76563: PUSH
76564: LD_INT 5
76566: NEG
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: LIST
76576: LIST
76577: LIST
76578: LIST
76579: LIST
76580: LIST
76581: LIST
76582: LIST
76583: LIST
76584: LIST
76585: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76586: LD_ADDR_VAR 0 30
76590: PUSH
76591: LD_INT 2
76593: PUSH
76594: LD_INT 1
76596: NEG
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 3
76604: PUSH
76605: LD_INT 0
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: LD_INT 3
76614: PUSH
76615: LD_INT 1
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 3
76624: PUSH
76625: LD_INT 1
76627: NEG
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 4
76635: PUSH
76636: LD_INT 0
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: PUSH
76643: LD_INT 4
76645: PUSH
76646: LD_INT 1
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PUSH
76653: LD_INT 4
76655: PUSH
76656: LD_INT 1
76658: NEG
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PUSH
76664: LD_INT 5
76666: PUSH
76667: LD_INT 0
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: PUSH
76674: LD_INT 5
76676: PUSH
76677: LD_INT 1
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 5
76686: PUSH
76687: LD_INT 1
76689: NEG
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PUSH
76695: LD_INT 6
76697: PUSH
76698: LD_INT 0
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 6
76707: PUSH
76708: LD_INT 1
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: LIST
76719: LIST
76720: LIST
76721: LIST
76722: LIST
76723: LIST
76724: LIST
76725: LIST
76726: LIST
76727: LIST
76728: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76729: LD_ADDR_VAR 0 31
76733: PUSH
76734: LD_INT 3
76736: PUSH
76737: LD_INT 2
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 3
76746: PUSH
76747: LD_INT 3
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 2
76756: PUSH
76757: LD_INT 3
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 4
76766: PUSH
76767: LD_INT 3
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 4
76776: PUSH
76777: LD_INT 4
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: LD_INT 3
76786: PUSH
76787: LD_INT 4
76789: PUSH
76790: EMPTY
76791: LIST
76792: LIST
76793: PUSH
76794: LD_INT 5
76796: PUSH
76797: LD_INT 4
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: PUSH
76804: LD_INT 5
76806: PUSH
76807: LD_INT 5
76809: PUSH
76810: EMPTY
76811: LIST
76812: LIST
76813: PUSH
76814: LD_INT 4
76816: PUSH
76817: LD_INT 5
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 6
76826: PUSH
76827: LD_INT 5
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 6
76836: PUSH
76837: LD_INT 6
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: PUSH
76844: LD_INT 5
76846: PUSH
76847: LD_INT 6
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: LIST
76858: LIST
76859: LIST
76860: LIST
76861: LIST
76862: LIST
76863: LIST
76864: LIST
76865: LIST
76866: LIST
76867: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76868: LD_ADDR_VAR 0 32
76872: PUSH
76873: LD_INT 1
76875: PUSH
76876: LD_INT 3
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: LD_INT 3
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: PUSH
76893: LD_INT 1
76895: NEG
76896: PUSH
76897: LD_INT 2
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: LD_INT 1
76906: PUSH
76907: LD_INT 4
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 0
76916: PUSH
76917: LD_INT 4
76919: PUSH
76920: EMPTY
76921: LIST
76922: LIST
76923: PUSH
76924: LD_INT 1
76926: NEG
76927: PUSH
76928: LD_INT 3
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PUSH
76935: LD_INT 1
76937: PUSH
76938: LD_INT 5
76940: PUSH
76941: EMPTY
76942: LIST
76943: LIST
76944: PUSH
76945: LD_INT 0
76947: PUSH
76948: LD_INT 5
76950: PUSH
76951: EMPTY
76952: LIST
76953: LIST
76954: PUSH
76955: LD_INT 1
76957: NEG
76958: PUSH
76959: LD_INT 4
76961: PUSH
76962: EMPTY
76963: LIST
76964: LIST
76965: PUSH
76966: LD_INT 1
76968: PUSH
76969: LD_INT 6
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: LD_INT 0
76978: PUSH
76979: LD_INT 6
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: PUSH
76986: LD_INT 1
76988: NEG
76989: PUSH
76990: LD_INT 5
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: LIST
77001: LIST
77002: LIST
77003: LIST
77004: LIST
77005: LIST
77006: LIST
77007: LIST
77008: LIST
77009: LIST
77010: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77011: LD_ADDR_VAR 0 33
77015: PUSH
77016: LD_INT 2
77018: NEG
77019: PUSH
77020: LD_INT 1
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 3
77029: NEG
77030: PUSH
77031: LD_INT 0
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 3
77040: NEG
77041: PUSH
77042: LD_INT 1
77044: NEG
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: PUSH
77050: LD_INT 3
77052: NEG
77053: PUSH
77054: LD_INT 1
77056: PUSH
77057: EMPTY
77058: LIST
77059: LIST
77060: PUSH
77061: LD_INT 4
77063: NEG
77064: PUSH
77065: LD_INT 0
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PUSH
77072: LD_INT 4
77074: NEG
77075: PUSH
77076: LD_INT 1
77078: NEG
77079: PUSH
77080: EMPTY
77081: LIST
77082: LIST
77083: PUSH
77084: LD_INT 4
77086: NEG
77087: PUSH
77088: LD_INT 1
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PUSH
77095: LD_INT 5
77097: NEG
77098: PUSH
77099: LD_INT 0
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 5
77108: NEG
77109: PUSH
77110: LD_INT 1
77112: NEG
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: LD_INT 5
77120: NEG
77121: PUSH
77122: LD_INT 1
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: PUSH
77129: LD_INT 6
77131: NEG
77132: PUSH
77133: LD_INT 0
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: LD_INT 6
77142: NEG
77143: PUSH
77144: LD_INT 1
77146: NEG
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: PUSH
77152: EMPTY
77153: LIST
77154: LIST
77155: LIST
77156: LIST
77157: LIST
77158: LIST
77159: LIST
77160: LIST
77161: LIST
77162: LIST
77163: LIST
77164: LIST
77165: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77166: LD_ADDR_VAR 0 34
77170: PUSH
77171: LD_INT 2
77173: NEG
77174: PUSH
77175: LD_INT 3
77177: NEG
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 3
77185: NEG
77186: PUSH
77187: LD_INT 2
77189: NEG
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: PUSH
77195: LD_INT 3
77197: NEG
77198: PUSH
77199: LD_INT 3
77201: NEG
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: LD_INT 3
77209: NEG
77210: PUSH
77211: LD_INT 4
77213: NEG
77214: PUSH
77215: EMPTY
77216: LIST
77217: LIST
77218: PUSH
77219: LD_INT 4
77221: NEG
77222: PUSH
77223: LD_INT 3
77225: NEG
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PUSH
77231: LD_INT 4
77233: NEG
77234: PUSH
77235: LD_INT 4
77237: NEG
77238: PUSH
77239: EMPTY
77240: LIST
77241: LIST
77242: PUSH
77243: LD_INT 4
77245: NEG
77246: PUSH
77247: LD_INT 5
77249: NEG
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: PUSH
77255: LD_INT 5
77257: NEG
77258: PUSH
77259: LD_INT 4
77261: NEG
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: LD_INT 5
77269: NEG
77270: PUSH
77271: LD_INT 5
77273: NEG
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: PUSH
77279: LD_INT 5
77281: NEG
77282: PUSH
77283: LD_INT 6
77285: NEG
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 6
77293: NEG
77294: PUSH
77295: LD_INT 5
77297: NEG
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 6
77305: NEG
77306: PUSH
77307: LD_INT 6
77309: NEG
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: LIST
77319: LIST
77320: LIST
77321: LIST
77322: LIST
77323: LIST
77324: LIST
77325: LIST
77326: LIST
77327: LIST
77328: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77329: LD_ADDR_VAR 0 41
77333: PUSH
77334: LD_INT 0
77336: PUSH
77337: LD_INT 2
77339: NEG
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 1
77347: NEG
77348: PUSH
77349: LD_INT 3
77351: NEG
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: LD_INT 1
77359: PUSH
77360: LD_INT 2
77362: NEG
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: LIST
77372: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77373: LD_ADDR_VAR 0 42
77377: PUSH
77378: LD_INT 2
77380: PUSH
77381: LD_INT 0
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: PUSH
77388: LD_INT 2
77390: PUSH
77391: LD_INT 1
77393: NEG
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: PUSH
77399: LD_INT 3
77401: PUSH
77402: LD_INT 1
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: LIST
77413: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77414: LD_ADDR_VAR 0 43
77418: PUSH
77419: LD_INT 2
77421: PUSH
77422: LD_INT 2
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 3
77431: PUSH
77432: LD_INT 2
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: PUSH
77439: LD_INT 2
77441: PUSH
77442: LD_INT 3
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: LIST
77453: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77454: LD_ADDR_VAR 0 44
77458: PUSH
77459: LD_INT 0
77461: PUSH
77462: LD_INT 2
77464: PUSH
77465: EMPTY
77466: LIST
77467: LIST
77468: PUSH
77469: LD_INT 1
77471: PUSH
77472: LD_INT 3
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 1
77481: NEG
77482: PUSH
77483: LD_INT 2
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: LIST
77494: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77495: LD_ADDR_VAR 0 45
77499: PUSH
77500: LD_INT 2
77502: NEG
77503: PUSH
77504: LD_INT 0
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 2
77513: NEG
77514: PUSH
77515: LD_INT 1
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 3
77524: NEG
77525: PUSH
77526: LD_INT 1
77528: NEG
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: LIST
77538: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77539: LD_ADDR_VAR 0 46
77543: PUSH
77544: LD_INT 2
77546: NEG
77547: PUSH
77548: LD_INT 2
77550: NEG
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: PUSH
77556: LD_INT 2
77558: NEG
77559: PUSH
77560: LD_INT 3
77562: NEG
77563: PUSH
77564: EMPTY
77565: LIST
77566: LIST
77567: PUSH
77568: LD_INT 3
77570: NEG
77571: PUSH
77572: LD_INT 2
77574: NEG
77575: PUSH
77576: EMPTY
77577: LIST
77578: LIST
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: LIST
77584: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77585: LD_ADDR_VAR 0 47
77589: PUSH
77590: LD_INT 2
77592: NEG
77593: PUSH
77594: LD_INT 3
77596: NEG
77597: PUSH
77598: EMPTY
77599: LIST
77600: LIST
77601: PUSH
77602: LD_INT 1
77604: NEG
77605: PUSH
77606: LD_INT 3
77608: NEG
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77618: LD_ADDR_VAR 0 48
77622: PUSH
77623: LD_INT 1
77625: PUSH
77626: LD_INT 2
77628: NEG
77629: PUSH
77630: EMPTY
77631: LIST
77632: LIST
77633: PUSH
77634: LD_INT 2
77636: PUSH
77637: LD_INT 1
77639: NEG
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77649: LD_ADDR_VAR 0 49
77653: PUSH
77654: LD_INT 3
77656: PUSH
77657: LD_INT 1
77659: PUSH
77660: EMPTY
77661: LIST
77662: LIST
77663: PUSH
77664: LD_INT 3
77666: PUSH
77667: LD_INT 2
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77678: LD_ADDR_VAR 0 50
77682: PUSH
77683: LD_INT 2
77685: PUSH
77686: LD_INT 3
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 1
77695: PUSH
77696: LD_INT 3
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77707: LD_ADDR_VAR 0 51
77711: PUSH
77712: LD_INT 1
77714: NEG
77715: PUSH
77716: LD_INT 2
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PUSH
77723: LD_INT 2
77725: NEG
77726: PUSH
77727: LD_INT 1
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77738: LD_ADDR_VAR 0 52
77742: PUSH
77743: LD_INT 3
77745: NEG
77746: PUSH
77747: LD_INT 1
77749: NEG
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: LD_INT 3
77757: NEG
77758: PUSH
77759: LD_INT 2
77761: NEG
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77771: LD_ADDR_VAR 0 53
77775: PUSH
77776: LD_INT 1
77778: NEG
77779: PUSH
77780: LD_INT 3
77782: NEG
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: PUSH
77788: LD_INT 0
77790: PUSH
77791: LD_INT 3
77793: NEG
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 1
77801: PUSH
77802: LD_INT 2
77804: NEG
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: LIST
77814: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77815: LD_ADDR_VAR 0 54
77819: PUSH
77820: LD_INT 2
77822: PUSH
77823: LD_INT 1
77825: NEG
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 3
77833: PUSH
77834: LD_INT 0
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 3
77843: PUSH
77844: LD_INT 1
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: LIST
77855: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77856: LD_ADDR_VAR 0 55
77860: PUSH
77861: LD_INT 3
77863: PUSH
77864: LD_INT 2
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: LD_INT 3
77873: PUSH
77874: LD_INT 3
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: LD_INT 2
77883: PUSH
77884: LD_INT 3
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: LIST
77895: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77896: LD_ADDR_VAR 0 56
77900: PUSH
77901: LD_INT 1
77903: PUSH
77904: LD_INT 3
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PUSH
77911: LD_INT 0
77913: PUSH
77914: LD_INT 3
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 1
77923: NEG
77924: PUSH
77925: LD_INT 2
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: LIST
77936: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77937: LD_ADDR_VAR 0 57
77941: PUSH
77942: LD_INT 2
77944: NEG
77945: PUSH
77946: LD_INT 1
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: PUSH
77953: LD_INT 3
77955: NEG
77956: PUSH
77957: LD_INT 0
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 3
77966: NEG
77967: PUSH
77968: LD_INT 1
77970: NEG
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: LIST
77980: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77981: LD_ADDR_VAR 0 58
77985: PUSH
77986: LD_INT 2
77988: NEG
77989: PUSH
77990: LD_INT 3
77992: NEG
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 3
78000: NEG
78001: PUSH
78002: LD_INT 2
78004: NEG
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 3
78012: NEG
78013: PUSH
78014: LD_INT 3
78016: NEG
78017: PUSH
78018: EMPTY
78019: LIST
78020: LIST
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: LIST
78026: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78027: LD_ADDR_VAR 0 59
78031: PUSH
78032: LD_INT 1
78034: NEG
78035: PUSH
78036: LD_INT 2
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 0
78046: PUSH
78047: LD_INT 2
78049: NEG
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: PUSH
78055: LD_INT 1
78057: PUSH
78058: LD_INT 1
78060: NEG
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: LIST
78070: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78071: LD_ADDR_VAR 0 60
78075: PUSH
78076: LD_INT 1
78078: PUSH
78079: LD_INT 1
78081: NEG
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: PUSH
78087: LD_INT 2
78089: PUSH
78090: LD_INT 0
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 2
78099: PUSH
78100: LD_INT 1
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: LIST
78111: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78112: LD_ADDR_VAR 0 61
78116: PUSH
78117: LD_INT 2
78119: PUSH
78120: LD_INT 1
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: LD_INT 2
78129: PUSH
78130: LD_INT 2
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: PUSH
78137: LD_INT 1
78139: PUSH
78140: LD_INT 2
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: LIST
78151: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78152: LD_ADDR_VAR 0 62
78156: PUSH
78157: LD_INT 1
78159: PUSH
78160: LD_INT 2
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 0
78169: PUSH
78170: LD_INT 2
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 1
78179: NEG
78180: PUSH
78181: LD_INT 1
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: LIST
78192: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78193: LD_ADDR_VAR 0 63
78197: PUSH
78198: LD_INT 1
78200: NEG
78201: PUSH
78202: LD_INT 1
78204: PUSH
78205: EMPTY
78206: LIST
78207: LIST
78208: PUSH
78209: LD_INT 2
78211: NEG
78212: PUSH
78213: LD_INT 0
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PUSH
78220: LD_INT 2
78222: NEG
78223: PUSH
78224: LD_INT 1
78226: NEG
78227: PUSH
78228: EMPTY
78229: LIST
78230: LIST
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: LIST
78236: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78237: LD_ADDR_VAR 0 64
78241: PUSH
78242: LD_INT 1
78244: NEG
78245: PUSH
78246: LD_INT 2
78248: NEG
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: PUSH
78254: LD_INT 2
78256: NEG
78257: PUSH
78258: LD_INT 1
78260: NEG
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 2
78268: NEG
78269: PUSH
78270: LD_INT 2
78272: NEG
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: LIST
78282: ST_TO_ADDR
// end ; 2 :
78283: GO 81549
78285: LD_INT 2
78287: DOUBLE
78288: EQUAL
78289: IFTRUE 78293
78291: GO 81548
78293: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78294: LD_ADDR_VAR 0 29
78298: PUSH
78299: LD_INT 4
78301: PUSH
78302: LD_INT 0
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: LD_INT 4
78311: PUSH
78312: LD_INT 1
78314: NEG
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: PUSH
78320: LD_INT 5
78322: PUSH
78323: LD_INT 0
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 5
78332: PUSH
78333: LD_INT 1
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: PUSH
78340: LD_INT 4
78342: PUSH
78343: LD_INT 1
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 3
78352: PUSH
78353: LD_INT 0
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: LD_INT 3
78362: PUSH
78363: LD_INT 1
78365: NEG
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: PUSH
78371: LD_INT 3
78373: PUSH
78374: LD_INT 2
78376: NEG
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 5
78384: PUSH
78385: LD_INT 2
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: LD_INT 3
78394: PUSH
78395: LD_INT 3
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: PUSH
78402: LD_INT 3
78404: PUSH
78405: LD_INT 2
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: LD_INT 4
78414: PUSH
78415: LD_INT 3
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 4
78424: PUSH
78425: LD_INT 4
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: PUSH
78432: LD_INT 3
78434: PUSH
78435: LD_INT 4
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 2
78444: PUSH
78445: LD_INT 3
78447: PUSH
78448: EMPTY
78449: LIST
78450: LIST
78451: PUSH
78452: LD_INT 2
78454: PUSH
78455: LD_INT 2
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 4
78464: PUSH
78465: LD_INT 2
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 2
78474: PUSH
78475: LD_INT 4
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 0
78484: PUSH
78485: LD_INT 4
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 0
78494: PUSH
78495: LD_INT 3
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: LD_INT 1
78504: PUSH
78505: LD_INT 4
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: LD_INT 1
78514: PUSH
78515: LD_INT 5
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PUSH
78522: LD_INT 0
78524: PUSH
78525: LD_INT 5
78527: PUSH
78528: EMPTY
78529: LIST
78530: LIST
78531: PUSH
78532: LD_INT 1
78534: NEG
78535: PUSH
78536: LD_INT 4
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: PUSH
78543: LD_INT 1
78545: NEG
78546: PUSH
78547: LD_INT 3
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: LD_INT 2
78556: PUSH
78557: LD_INT 5
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: LD_INT 2
78566: NEG
78567: PUSH
78568: LD_INT 3
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 3
78577: NEG
78578: PUSH
78579: LD_INT 0
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 3
78588: NEG
78589: PUSH
78590: LD_INT 1
78592: NEG
78593: PUSH
78594: EMPTY
78595: LIST
78596: LIST
78597: PUSH
78598: LD_INT 2
78600: NEG
78601: PUSH
78602: LD_INT 0
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: PUSH
78609: LD_INT 2
78611: NEG
78612: PUSH
78613: LD_INT 1
78615: PUSH
78616: EMPTY
78617: LIST
78618: LIST
78619: PUSH
78620: LD_INT 3
78622: NEG
78623: PUSH
78624: LD_INT 1
78626: PUSH
78627: EMPTY
78628: LIST
78629: LIST
78630: PUSH
78631: LD_INT 4
78633: NEG
78634: PUSH
78635: LD_INT 0
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PUSH
78642: LD_INT 4
78644: NEG
78645: PUSH
78646: LD_INT 1
78648: NEG
78649: PUSH
78650: EMPTY
78651: LIST
78652: LIST
78653: PUSH
78654: LD_INT 4
78656: NEG
78657: PUSH
78658: LD_INT 2
78660: NEG
78661: PUSH
78662: EMPTY
78663: LIST
78664: LIST
78665: PUSH
78666: LD_INT 2
78668: NEG
78669: PUSH
78670: LD_INT 2
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: PUSH
78677: LD_INT 4
78679: NEG
78680: PUSH
78681: LD_INT 4
78683: NEG
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: LD_INT 4
78691: NEG
78692: PUSH
78693: LD_INT 5
78695: NEG
78696: PUSH
78697: EMPTY
78698: LIST
78699: LIST
78700: PUSH
78701: LD_INT 3
78703: NEG
78704: PUSH
78705: LD_INT 4
78707: NEG
78708: PUSH
78709: EMPTY
78710: LIST
78711: LIST
78712: PUSH
78713: LD_INT 3
78715: NEG
78716: PUSH
78717: LD_INT 3
78719: NEG
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: LD_INT 4
78727: NEG
78728: PUSH
78729: LD_INT 3
78731: NEG
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 5
78739: NEG
78740: PUSH
78741: LD_INT 4
78743: NEG
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 5
78751: NEG
78752: PUSH
78753: LD_INT 5
78755: NEG
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 3
78763: NEG
78764: PUSH
78765: LD_INT 5
78767: NEG
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: LD_INT 5
78775: NEG
78776: PUSH
78777: LD_INT 3
78779: NEG
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: EMPTY
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: LIST
78812: LIST
78813: LIST
78814: LIST
78815: LIST
78816: LIST
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78832: LD_ADDR_VAR 0 30
78836: PUSH
78837: LD_INT 4
78839: PUSH
78840: LD_INT 4
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 4
78849: PUSH
78850: LD_INT 3
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 5
78859: PUSH
78860: LD_INT 4
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: LD_INT 5
78869: PUSH
78870: LD_INT 5
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: PUSH
78877: LD_INT 4
78879: PUSH
78880: LD_INT 5
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 3
78889: PUSH
78890: LD_INT 4
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: PUSH
78897: LD_INT 3
78899: PUSH
78900: LD_INT 3
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 5
78909: PUSH
78910: LD_INT 3
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 3
78919: PUSH
78920: LD_INT 5
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: PUSH
78927: LD_INT 0
78929: PUSH
78930: LD_INT 3
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 0
78939: PUSH
78940: LD_INT 2
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 1
78949: PUSH
78950: LD_INT 3
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PUSH
78957: LD_INT 1
78959: PUSH
78960: LD_INT 4
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: PUSH
78967: LD_INT 0
78969: PUSH
78970: LD_INT 4
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: PUSH
78977: LD_INT 1
78979: NEG
78980: PUSH
78981: LD_INT 3
78983: PUSH
78984: EMPTY
78985: LIST
78986: LIST
78987: PUSH
78988: LD_INT 1
78990: NEG
78991: PUSH
78992: LD_INT 2
78994: PUSH
78995: EMPTY
78996: LIST
78997: LIST
78998: PUSH
78999: LD_INT 2
79001: PUSH
79002: LD_INT 4
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: PUSH
79009: LD_INT 2
79011: NEG
79012: PUSH
79013: LD_INT 2
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: LD_INT 4
79022: NEG
79023: PUSH
79024: LD_INT 0
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PUSH
79031: LD_INT 4
79033: NEG
79034: PUSH
79035: LD_INT 1
79037: NEG
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 3
79045: NEG
79046: PUSH
79047: LD_INT 0
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 3
79056: NEG
79057: PUSH
79058: LD_INT 1
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 4
79067: NEG
79068: PUSH
79069: LD_INT 1
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 5
79078: NEG
79079: PUSH
79080: LD_INT 0
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: LD_INT 5
79089: NEG
79090: PUSH
79091: LD_INT 1
79093: NEG
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: LD_INT 5
79101: NEG
79102: PUSH
79103: LD_INT 2
79105: NEG
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 3
79113: NEG
79114: PUSH
79115: LD_INT 2
79117: PUSH
79118: EMPTY
79119: LIST
79120: LIST
79121: PUSH
79122: LD_INT 3
79124: NEG
79125: PUSH
79126: LD_INT 3
79128: NEG
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 3
79136: NEG
79137: PUSH
79138: LD_INT 4
79140: NEG
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: LD_INT 2
79148: NEG
79149: PUSH
79150: LD_INT 3
79152: NEG
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: PUSH
79158: LD_INT 2
79160: NEG
79161: PUSH
79162: LD_INT 2
79164: NEG
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: PUSH
79170: LD_INT 3
79172: NEG
79173: PUSH
79174: LD_INT 2
79176: NEG
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 4
79184: NEG
79185: PUSH
79186: LD_INT 3
79188: NEG
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 4
79196: NEG
79197: PUSH
79198: LD_INT 4
79200: NEG
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 2
79208: NEG
79209: PUSH
79210: LD_INT 4
79212: NEG
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 4
79220: NEG
79221: PUSH
79222: LD_INT 2
79224: NEG
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: LD_INT 0
79232: PUSH
79233: LD_INT 4
79235: NEG
79236: PUSH
79237: EMPTY
79238: LIST
79239: LIST
79240: PUSH
79241: LD_INT 0
79243: PUSH
79244: LD_INT 5
79246: NEG
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: LD_INT 1
79254: PUSH
79255: LD_INT 4
79257: NEG
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 1
79265: PUSH
79266: LD_INT 3
79268: NEG
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 0
79276: PUSH
79277: LD_INT 3
79279: NEG
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 1
79287: NEG
79288: PUSH
79289: LD_INT 4
79291: NEG
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 1
79299: NEG
79300: PUSH
79301: LD_INT 5
79303: NEG
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 2
79311: PUSH
79312: LD_INT 3
79314: NEG
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 2
79322: NEG
79323: PUSH
79324: LD_INT 5
79326: NEG
79327: PUSH
79328: EMPTY
79329: LIST
79330: LIST
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: LIST
79356: LIST
79357: LIST
79358: LIST
79359: LIST
79360: LIST
79361: LIST
79362: LIST
79363: LIST
79364: LIST
79365: LIST
79366: LIST
79367: LIST
79368: LIST
79369: LIST
79370: LIST
79371: LIST
79372: LIST
79373: LIST
79374: LIST
79375: LIST
79376: LIST
79377: LIST
79378: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79379: LD_ADDR_VAR 0 31
79383: PUSH
79384: LD_INT 0
79386: PUSH
79387: LD_INT 4
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 0
79396: PUSH
79397: LD_INT 3
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 1
79406: PUSH
79407: LD_INT 4
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 1
79416: PUSH
79417: LD_INT 5
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 0
79426: PUSH
79427: LD_INT 5
79429: PUSH
79430: EMPTY
79431: LIST
79432: LIST
79433: PUSH
79434: LD_INT 1
79436: NEG
79437: PUSH
79438: LD_INT 4
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 1
79447: NEG
79448: PUSH
79449: LD_INT 3
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: LD_INT 2
79458: PUSH
79459: LD_INT 5
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: LD_INT 2
79468: NEG
79469: PUSH
79470: LD_INT 3
79472: PUSH
79473: EMPTY
79474: LIST
79475: LIST
79476: PUSH
79477: LD_INT 3
79479: NEG
79480: PUSH
79481: LD_INT 0
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 3
79490: NEG
79491: PUSH
79492: LD_INT 1
79494: NEG
79495: PUSH
79496: EMPTY
79497: LIST
79498: LIST
79499: PUSH
79500: LD_INT 2
79502: NEG
79503: PUSH
79504: LD_INT 0
79506: PUSH
79507: EMPTY
79508: LIST
79509: LIST
79510: PUSH
79511: LD_INT 2
79513: NEG
79514: PUSH
79515: LD_INT 1
79517: PUSH
79518: EMPTY
79519: LIST
79520: LIST
79521: PUSH
79522: LD_INT 3
79524: NEG
79525: PUSH
79526: LD_INT 1
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 4
79535: NEG
79536: PUSH
79537: LD_INT 0
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: LD_INT 4
79546: NEG
79547: PUSH
79548: LD_INT 1
79550: NEG
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: PUSH
79556: LD_INT 4
79558: NEG
79559: PUSH
79560: LD_INT 2
79562: NEG
79563: PUSH
79564: EMPTY
79565: LIST
79566: LIST
79567: PUSH
79568: LD_INT 2
79570: NEG
79571: PUSH
79572: LD_INT 2
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 4
79581: NEG
79582: PUSH
79583: LD_INT 4
79585: NEG
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PUSH
79591: LD_INT 4
79593: NEG
79594: PUSH
79595: LD_INT 5
79597: NEG
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: PUSH
79603: LD_INT 3
79605: NEG
79606: PUSH
79607: LD_INT 4
79609: NEG
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: PUSH
79615: LD_INT 3
79617: NEG
79618: PUSH
79619: LD_INT 3
79621: NEG
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 4
79629: NEG
79630: PUSH
79631: LD_INT 3
79633: NEG
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 5
79641: NEG
79642: PUSH
79643: LD_INT 4
79645: NEG
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: LD_INT 5
79653: NEG
79654: PUSH
79655: LD_INT 5
79657: NEG
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 3
79665: NEG
79666: PUSH
79667: LD_INT 5
79669: NEG
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PUSH
79675: LD_INT 5
79677: NEG
79678: PUSH
79679: LD_INT 3
79681: NEG
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: PUSH
79687: LD_INT 0
79689: PUSH
79690: LD_INT 3
79692: NEG
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 0
79700: PUSH
79701: LD_INT 4
79703: NEG
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 1
79711: PUSH
79712: LD_INT 3
79714: NEG
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: PUSH
79720: LD_INT 1
79722: PUSH
79723: LD_INT 2
79725: NEG
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PUSH
79731: LD_INT 0
79733: PUSH
79734: LD_INT 2
79736: NEG
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 1
79744: NEG
79745: PUSH
79746: LD_INT 3
79748: NEG
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 1
79756: NEG
79757: PUSH
79758: LD_INT 4
79760: NEG
79761: PUSH
79762: EMPTY
79763: LIST
79764: LIST
79765: PUSH
79766: LD_INT 2
79768: PUSH
79769: LD_INT 2
79771: NEG
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: PUSH
79777: LD_INT 2
79779: NEG
79780: PUSH
79781: LD_INT 4
79783: NEG
79784: PUSH
79785: EMPTY
79786: LIST
79787: LIST
79788: PUSH
79789: LD_INT 4
79791: PUSH
79792: LD_INT 0
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 4
79801: PUSH
79802: LD_INT 1
79804: NEG
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 5
79812: PUSH
79813: LD_INT 0
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 5
79822: PUSH
79823: LD_INT 1
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 4
79832: PUSH
79833: LD_INT 1
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 3
79842: PUSH
79843: LD_INT 0
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 3
79852: PUSH
79853: LD_INT 1
79855: NEG
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 3
79863: PUSH
79864: LD_INT 2
79866: NEG
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 5
79874: PUSH
79875: LD_INT 2
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: LIST
79890: LIST
79891: LIST
79892: LIST
79893: LIST
79894: LIST
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: LIST
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: LIST
79923: LIST
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79929: LD_ADDR_VAR 0 32
79933: PUSH
79934: LD_INT 4
79936: NEG
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 4
79947: NEG
79948: PUSH
79949: LD_INT 1
79951: NEG
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 3
79959: NEG
79960: PUSH
79961: LD_INT 0
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 3
79970: NEG
79971: PUSH
79972: LD_INT 1
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 4
79981: NEG
79982: PUSH
79983: LD_INT 1
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 5
79992: NEG
79993: PUSH
79994: LD_INT 0
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 5
80003: NEG
80004: PUSH
80005: LD_INT 1
80007: NEG
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 5
80015: NEG
80016: PUSH
80017: LD_INT 2
80019: NEG
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 3
80027: NEG
80028: PUSH
80029: LD_INT 2
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 3
80038: NEG
80039: PUSH
80040: LD_INT 3
80042: NEG
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 3
80050: NEG
80051: PUSH
80052: LD_INT 4
80054: NEG
80055: PUSH
80056: EMPTY
80057: LIST
80058: LIST
80059: PUSH
80060: LD_INT 2
80062: NEG
80063: PUSH
80064: LD_INT 3
80066: NEG
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: PUSH
80072: LD_INT 2
80074: NEG
80075: PUSH
80076: LD_INT 2
80078: NEG
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PUSH
80084: LD_INT 3
80086: NEG
80087: PUSH
80088: LD_INT 2
80090: NEG
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: LD_INT 4
80098: NEG
80099: PUSH
80100: LD_INT 3
80102: NEG
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 4
80110: NEG
80111: PUSH
80112: LD_INT 4
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 2
80122: NEG
80123: PUSH
80124: LD_INT 4
80126: NEG
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: PUSH
80132: LD_INT 4
80134: NEG
80135: PUSH
80136: LD_INT 2
80138: NEG
80139: PUSH
80140: EMPTY
80141: LIST
80142: LIST
80143: PUSH
80144: LD_INT 0
80146: PUSH
80147: LD_INT 4
80149: NEG
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: LD_INT 0
80157: PUSH
80158: LD_INT 5
80160: NEG
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: PUSH
80166: LD_INT 1
80168: PUSH
80169: LD_INT 4
80171: NEG
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: LD_INT 1
80179: PUSH
80180: LD_INT 3
80182: NEG
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 3
80193: NEG
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PUSH
80199: LD_INT 1
80201: NEG
80202: PUSH
80203: LD_INT 4
80205: NEG
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: PUSH
80211: LD_INT 1
80213: NEG
80214: PUSH
80215: LD_INT 5
80217: NEG
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 2
80225: PUSH
80226: LD_INT 3
80228: NEG
80229: PUSH
80230: EMPTY
80231: LIST
80232: LIST
80233: PUSH
80234: LD_INT 2
80236: NEG
80237: PUSH
80238: LD_INT 5
80240: NEG
80241: PUSH
80242: EMPTY
80243: LIST
80244: LIST
80245: PUSH
80246: LD_INT 3
80248: PUSH
80249: LD_INT 0
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: LD_INT 3
80258: PUSH
80259: LD_INT 1
80261: NEG
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 4
80269: PUSH
80270: LD_INT 0
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: LD_INT 4
80279: PUSH
80280: LD_INT 1
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 3
80289: PUSH
80290: LD_INT 1
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 2
80299: PUSH
80300: LD_INT 0
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 2
80309: PUSH
80310: LD_INT 1
80312: NEG
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 2
80320: PUSH
80321: LD_INT 2
80323: NEG
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: PUSH
80329: LD_INT 4
80331: PUSH
80332: LD_INT 2
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 4
80341: PUSH
80342: LD_INT 4
80344: PUSH
80345: EMPTY
80346: LIST
80347: LIST
80348: PUSH
80349: LD_INT 4
80351: PUSH
80352: LD_INT 3
80354: PUSH
80355: EMPTY
80356: LIST
80357: LIST
80358: PUSH
80359: LD_INT 5
80361: PUSH
80362: LD_INT 4
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 5
80371: PUSH
80372: LD_INT 5
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 4
80381: PUSH
80382: LD_INT 5
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 3
80391: PUSH
80392: LD_INT 4
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: PUSH
80399: LD_INT 3
80401: PUSH
80402: LD_INT 3
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: PUSH
80409: LD_INT 5
80411: PUSH
80412: LD_INT 3
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: PUSH
80419: LD_INT 3
80421: PUSH
80422: LD_INT 5
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: LIST
80433: LIST
80434: LIST
80435: LIST
80436: LIST
80437: LIST
80438: LIST
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: LIST
80472: LIST
80473: LIST
80474: LIST
80475: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80476: LD_ADDR_VAR 0 33
80480: PUSH
80481: LD_INT 4
80483: NEG
80484: PUSH
80485: LD_INT 4
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 4
80495: NEG
80496: PUSH
80497: LD_INT 5
80499: NEG
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 3
80507: NEG
80508: PUSH
80509: LD_INT 4
80511: NEG
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: LD_INT 3
80519: NEG
80520: PUSH
80521: LD_INT 3
80523: NEG
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: LD_INT 4
80531: NEG
80532: PUSH
80533: LD_INT 3
80535: NEG
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 5
80543: NEG
80544: PUSH
80545: LD_INT 4
80547: NEG
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 5
80555: NEG
80556: PUSH
80557: LD_INT 5
80559: NEG
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 3
80567: NEG
80568: PUSH
80569: LD_INT 5
80571: NEG
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PUSH
80577: LD_INT 5
80579: NEG
80580: PUSH
80581: LD_INT 3
80583: NEG
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 0
80591: PUSH
80592: LD_INT 3
80594: NEG
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: PUSH
80600: LD_INT 0
80602: PUSH
80603: LD_INT 4
80605: NEG
80606: PUSH
80607: EMPTY
80608: LIST
80609: LIST
80610: PUSH
80611: LD_INT 1
80613: PUSH
80614: LD_INT 3
80616: NEG
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: LD_INT 1
80624: PUSH
80625: LD_INT 2
80627: NEG
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 0
80635: PUSH
80636: LD_INT 2
80638: NEG
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 1
80646: NEG
80647: PUSH
80648: LD_INT 3
80650: NEG
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 1
80658: NEG
80659: PUSH
80660: LD_INT 4
80662: NEG
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 2
80670: PUSH
80671: LD_INT 2
80673: NEG
80674: PUSH
80675: EMPTY
80676: LIST
80677: LIST
80678: PUSH
80679: LD_INT 2
80681: NEG
80682: PUSH
80683: LD_INT 4
80685: NEG
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 4
80693: PUSH
80694: LD_INT 0
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 4
80703: PUSH
80704: LD_INT 1
80706: NEG
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 5
80714: PUSH
80715: LD_INT 0
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: LD_INT 5
80724: PUSH
80725: LD_INT 1
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 4
80734: PUSH
80735: LD_INT 1
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 3
80744: PUSH
80745: LD_INT 0
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 3
80754: PUSH
80755: LD_INT 1
80757: NEG
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 3
80765: PUSH
80766: LD_INT 2
80768: NEG
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 5
80776: PUSH
80777: LD_INT 2
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 3
80786: PUSH
80787: LD_INT 3
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: PUSH
80794: LD_INT 3
80796: PUSH
80797: LD_INT 2
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 4
80806: PUSH
80807: LD_INT 3
80809: PUSH
80810: EMPTY
80811: LIST
80812: LIST
80813: PUSH
80814: LD_INT 4
80816: PUSH
80817: LD_INT 4
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: LD_INT 3
80826: PUSH
80827: LD_INT 4
80829: PUSH
80830: EMPTY
80831: LIST
80832: LIST
80833: PUSH
80834: LD_INT 2
80836: PUSH
80837: LD_INT 3
80839: PUSH
80840: EMPTY
80841: LIST
80842: LIST
80843: PUSH
80844: LD_INT 2
80846: PUSH
80847: LD_INT 2
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: LD_INT 4
80856: PUSH
80857: LD_INT 2
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: PUSH
80864: LD_INT 2
80866: PUSH
80867: LD_INT 4
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 0
80876: PUSH
80877: LD_INT 4
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: PUSH
80884: LD_INT 0
80886: PUSH
80887: LD_INT 3
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 1
80896: PUSH
80897: LD_INT 4
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 1
80906: PUSH
80907: LD_INT 5
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 0
80916: PUSH
80917: LD_INT 5
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 1
80926: NEG
80927: PUSH
80928: LD_INT 4
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 1
80937: NEG
80938: PUSH
80939: LD_INT 3
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 2
80948: PUSH
80949: LD_INT 5
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 2
80958: NEG
80959: PUSH
80960: LD_INT 3
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: LIST
80980: LIST
80981: LIST
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: LIST
81007: LIST
81008: LIST
81009: LIST
81010: LIST
81011: LIST
81012: LIST
81013: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81014: LD_ADDR_VAR 0 34
81018: PUSH
81019: LD_INT 0
81021: PUSH
81022: LD_INT 4
81024: NEG
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 0
81032: PUSH
81033: LD_INT 5
81035: NEG
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: PUSH
81041: LD_INT 1
81043: PUSH
81044: LD_INT 4
81046: NEG
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: PUSH
81052: LD_INT 1
81054: PUSH
81055: LD_INT 3
81057: NEG
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: LD_INT 0
81065: PUSH
81066: LD_INT 3
81068: NEG
81069: PUSH
81070: EMPTY
81071: LIST
81072: LIST
81073: PUSH
81074: LD_INT 1
81076: NEG
81077: PUSH
81078: LD_INT 4
81080: NEG
81081: PUSH
81082: EMPTY
81083: LIST
81084: LIST
81085: PUSH
81086: LD_INT 1
81088: NEG
81089: PUSH
81090: LD_INT 5
81092: NEG
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 2
81100: PUSH
81101: LD_INT 3
81103: NEG
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: PUSH
81109: LD_INT 2
81111: NEG
81112: PUSH
81113: LD_INT 5
81115: NEG
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 3
81123: PUSH
81124: LD_INT 0
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 3
81133: PUSH
81134: LD_INT 1
81136: NEG
81137: PUSH
81138: EMPTY
81139: LIST
81140: LIST
81141: PUSH
81142: LD_INT 4
81144: PUSH
81145: LD_INT 0
81147: PUSH
81148: EMPTY
81149: LIST
81150: LIST
81151: PUSH
81152: LD_INT 4
81154: PUSH
81155: LD_INT 1
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 3
81164: PUSH
81165: LD_INT 1
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: LD_INT 2
81174: PUSH
81175: LD_INT 0
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: PUSH
81182: LD_INT 2
81184: PUSH
81185: LD_INT 1
81187: NEG
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: PUSH
81193: LD_INT 2
81195: PUSH
81196: LD_INT 2
81198: NEG
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 4
81206: PUSH
81207: LD_INT 2
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: PUSH
81214: LD_INT 4
81216: PUSH
81217: LD_INT 4
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 4
81226: PUSH
81227: LD_INT 3
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: PUSH
81234: LD_INT 5
81236: PUSH
81237: LD_INT 4
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 5
81246: PUSH
81247: LD_INT 5
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 4
81256: PUSH
81257: LD_INT 5
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 3
81266: PUSH
81267: LD_INT 4
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 3
81276: PUSH
81277: LD_INT 3
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 5
81286: PUSH
81287: LD_INT 3
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 3
81296: PUSH
81297: LD_INT 5
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 0
81306: PUSH
81307: LD_INT 3
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_INT 0
81316: PUSH
81317: LD_INT 2
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 1
81326: PUSH
81327: LD_INT 3
81329: PUSH
81330: EMPTY
81331: LIST
81332: LIST
81333: PUSH
81334: LD_INT 1
81336: PUSH
81337: LD_INT 4
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 0
81346: PUSH
81347: LD_INT 4
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 1
81356: NEG
81357: PUSH
81358: LD_INT 3
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 1
81367: NEG
81368: PUSH
81369: LD_INT 2
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: LD_INT 2
81378: PUSH
81379: LD_INT 4
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 2
81388: NEG
81389: PUSH
81390: LD_INT 2
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 4
81399: NEG
81400: PUSH
81401: LD_INT 0
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 4
81410: NEG
81411: PUSH
81412: LD_INT 1
81414: NEG
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 3
81422: NEG
81423: PUSH
81424: LD_INT 0
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 3
81433: NEG
81434: PUSH
81435: LD_INT 1
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 4
81444: NEG
81445: PUSH
81446: LD_INT 1
81448: PUSH
81449: EMPTY
81450: LIST
81451: LIST
81452: PUSH
81453: LD_INT 5
81455: NEG
81456: PUSH
81457: LD_INT 0
81459: PUSH
81460: EMPTY
81461: LIST
81462: LIST
81463: PUSH
81464: LD_INT 5
81466: NEG
81467: PUSH
81468: LD_INT 1
81470: NEG
81471: PUSH
81472: EMPTY
81473: LIST
81474: LIST
81475: PUSH
81476: LD_INT 5
81478: NEG
81479: PUSH
81480: LD_INT 2
81482: NEG
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: PUSH
81488: LD_INT 3
81490: NEG
81491: PUSH
81492: LD_INT 2
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: EMPTY
81500: LIST
81501: LIST
81502: LIST
81503: LIST
81504: LIST
81505: LIST
81506: LIST
81507: LIST
81508: LIST
81509: LIST
81510: LIST
81511: LIST
81512: LIST
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: LIST
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: LIST
81529: LIST
81530: LIST
81531: LIST
81532: LIST
81533: LIST
81534: LIST
81535: LIST
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: ST_TO_ADDR
// end ; end ;
81546: GO 81549
81548: POP
// case btype of b_depot , b_warehouse :
81549: LD_VAR 0 1
81553: PUSH
81554: LD_INT 0
81556: DOUBLE
81557: EQUAL
81558: IFTRUE 81568
81560: LD_INT 1
81562: DOUBLE
81563: EQUAL
81564: IFTRUE 81568
81566: GO 81769
81568: POP
// case nation of nation_american :
81569: LD_VAR 0 5
81573: PUSH
81574: LD_INT 1
81576: DOUBLE
81577: EQUAL
81578: IFTRUE 81582
81580: GO 81638
81582: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
81583: LD_ADDR_VAR 0 9
81587: PUSH
81588: LD_VAR 0 11
81592: PUSH
81593: LD_VAR 0 12
81597: PUSH
81598: LD_VAR 0 13
81602: PUSH
81603: LD_VAR 0 14
81607: PUSH
81608: LD_VAR 0 15
81612: PUSH
81613: LD_VAR 0 16
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: PUSH
81626: LD_VAR 0 4
81630: PUSH
81631: LD_INT 1
81633: PLUS
81634: ARRAY
81635: ST_TO_ADDR
81636: GO 81767
81638: LD_INT 2
81640: DOUBLE
81641: EQUAL
81642: IFTRUE 81646
81644: GO 81702
81646: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
81647: LD_ADDR_VAR 0 9
81651: PUSH
81652: LD_VAR 0 17
81656: PUSH
81657: LD_VAR 0 18
81661: PUSH
81662: LD_VAR 0 19
81666: PUSH
81667: LD_VAR 0 20
81671: PUSH
81672: LD_VAR 0 21
81676: PUSH
81677: LD_VAR 0 22
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: PUSH
81690: LD_VAR 0 4
81694: PUSH
81695: LD_INT 1
81697: PLUS
81698: ARRAY
81699: ST_TO_ADDR
81700: GO 81767
81702: LD_INT 3
81704: DOUBLE
81705: EQUAL
81706: IFTRUE 81710
81708: GO 81766
81710: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81711: LD_ADDR_VAR 0 9
81715: PUSH
81716: LD_VAR 0 23
81720: PUSH
81721: LD_VAR 0 24
81725: PUSH
81726: LD_VAR 0 25
81730: PUSH
81731: LD_VAR 0 26
81735: PUSH
81736: LD_VAR 0 27
81740: PUSH
81741: LD_VAR 0 28
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: LIST
81752: LIST
81753: PUSH
81754: LD_VAR 0 4
81758: PUSH
81759: LD_INT 1
81761: PLUS
81762: ARRAY
81763: ST_TO_ADDR
81764: GO 81767
81766: POP
81767: GO 82322
81769: LD_INT 2
81771: DOUBLE
81772: EQUAL
81773: IFTRUE 81783
81775: LD_INT 3
81777: DOUBLE
81778: EQUAL
81779: IFTRUE 81783
81781: GO 81839
81783: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81784: LD_ADDR_VAR 0 9
81788: PUSH
81789: LD_VAR 0 29
81793: PUSH
81794: LD_VAR 0 30
81798: PUSH
81799: LD_VAR 0 31
81803: PUSH
81804: LD_VAR 0 32
81808: PUSH
81809: LD_VAR 0 33
81813: PUSH
81814: LD_VAR 0 34
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: LIST
81823: LIST
81824: LIST
81825: LIST
81826: PUSH
81827: LD_VAR 0 4
81831: PUSH
81832: LD_INT 1
81834: PLUS
81835: ARRAY
81836: ST_TO_ADDR
81837: GO 82322
81839: LD_INT 16
81841: DOUBLE
81842: EQUAL
81843: IFTRUE 81901
81845: LD_INT 17
81847: DOUBLE
81848: EQUAL
81849: IFTRUE 81901
81851: LD_INT 18
81853: DOUBLE
81854: EQUAL
81855: IFTRUE 81901
81857: LD_INT 19
81859: DOUBLE
81860: EQUAL
81861: IFTRUE 81901
81863: LD_INT 22
81865: DOUBLE
81866: EQUAL
81867: IFTRUE 81901
81869: LD_INT 20
81871: DOUBLE
81872: EQUAL
81873: IFTRUE 81901
81875: LD_INT 21
81877: DOUBLE
81878: EQUAL
81879: IFTRUE 81901
81881: LD_INT 23
81883: DOUBLE
81884: EQUAL
81885: IFTRUE 81901
81887: LD_INT 24
81889: DOUBLE
81890: EQUAL
81891: IFTRUE 81901
81893: LD_INT 25
81895: DOUBLE
81896: EQUAL
81897: IFTRUE 81901
81899: GO 81957
81901: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81902: LD_ADDR_VAR 0 9
81906: PUSH
81907: LD_VAR 0 35
81911: PUSH
81912: LD_VAR 0 36
81916: PUSH
81917: LD_VAR 0 37
81921: PUSH
81922: LD_VAR 0 38
81926: PUSH
81927: LD_VAR 0 39
81931: PUSH
81932: LD_VAR 0 40
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: PUSH
81945: LD_VAR 0 4
81949: PUSH
81950: LD_INT 1
81952: PLUS
81953: ARRAY
81954: ST_TO_ADDR
81955: GO 82322
81957: LD_INT 6
81959: DOUBLE
81960: EQUAL
81961: IFTRUE 82013
81963: LD_INT 7
81965: DOUBLE
81966: EQUAL
81967: IFTRUE 82013
81969: LD_INT 8
81971: DOUBLE
81972: EQUAL
81973: IFTRUE 82013
81975: LD_INT 13
81977: DOUBLE
81978: EQUAL
81979: IFTRUE 82013
81981: LD_INT 12
81983: DOUBLE
81984: EQUAL
81985: IFTRUE 82013
81987: LD_INT 15
81989: DOUBLE
81990: EQUAL
81991: IFTRUE 82013
81993: LD_INT 11
81995: DOUBLE
81996: EQUAL
81997: IFTRUE 82013
81999: LD_INT 14
82001: DOUBLE
82002: EQUAL
82003: IFTRUE 82013
82005: LD_INT 10
82007: DOUBLE
82008: EQUAL
82009: IFTRUE 82013
82011: GO 82069
82013: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
82014: LD_ADDR_VAR 0 9
82018: PUSH
82019: LD_VAR 0 41
82023: PUSH
82024: LD_VAR 0 42
82028: PUSH
82029: LD_VAR 0 43
82033: PUSH
82034: LD_VAR 0 44
82038: PUSH
82039: LD_VAR 0 45
82043: PUSH
82044: LD_VAR 0 46
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: LIST
82053: LIST
82054: LIST
82055: LIST
82056: PUSH
82057: LD_VAR 0 4
82061: PUSH
82062: LD_INT 1
82064: PLUS
82065: ARRAY
82066: ST_TO_ADDR
82067: GO 82322
82069: LD_INT 36
82071: DOUBLE
82072: EQUAL
82073: IFTRUE 82077
82075: GO 82133
82077: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82078: LD_ADDR_VAR 0 9
82082: PUSH
82083: LD_VAR 0 47
82087: PUSH
82088: LD_VAR 0 48
82092: PUSH
82093: LD_VAR 0 49
82097: PUSH
82098: LD_VAR 0 50
82102: PUSH
82103: LD_VAR 0 51
82107: PUSH
82108: LD_VAR 0 52
82112: PUSH
82113: EMPTY
82114: LIST
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: PUSH
82121: LD_VAR 0 4
82125: PUSH
82126: LD_INT 1
82128: PLUS
82129: ARRAY
82130: ST_TO_ADDR
82131: GO 82322
82133: LD_INT 4
82135: DOUBLE
82136: EQUAL
82137: IFTRUE 82159
82139: LD_INT 5
82141: DOUBLE
82142: EQUAL
82143: IFTRUE 82159
82145: LD_INT 34
82147: DOUBLE
82148: EQUAL
82149: IFTRUE 82159
82151: LD_INT 37
82153: DOUBLE
82154: EQUAL
82155: IFTRUE 82159
82157: GO 82215
82159: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82160: LD_ADDR_VAR 0 9
82164: PUSH
82165: LD_VAR 0 53
82169: PUSH
82170: LD_VAR 0 54
82174: PUSH
82175: LD_VAR 0 55
82179: PUSH
82180: LD_VAR 0 56
82184: PUSH
82185: LD_VAR 0 57
82189: PUSH
82190: LD_VAR 0 58
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: PUSH
82203: LD_VAR 0 4
82207: PUSH
82208: LD_INT 1
82210: PLUS
82211: ARRAY
82212: ST_TO_ADDR
82213: GO 82322
82215: LD_INT 31
82217: DOUBLE
82218: EQUAL
82219: IFTRUE 82265
82221: LD_INT 32
82223: DOUBLE
82224: EQUAL
82225: IFTRUE 82265
82227: LD_INT 33
82229: DOUBLE
82230: EQUAL
82231: IFTRUE 82265
82233: LD_INT 27
82235: DOUBLE
82236: EQUAL
82237: IFTRUE 82265
82239: LD_INT 26
82241: DOUBLE
82242: EQUAL
82243: IFTRUE 82265
82245: LD_INT 28
82247: DOUBLE
82248: EQUAL
82249: IFTRUE 82265
82251: LD_INT 29
82253: DOUBLE
82254: EQUAL
82255: IFTRUE 82265
82257: LD_INT 30
82259: DOUBLE
82260: EQUAL
82261: IFTRUE 82265
82263: GO 82321
82265: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
82266: LD_ADDR_VAR 0 9
82270: PUSH
82271: LD_VAR 0 59
82275: PUSH
82276: LD_VAR 0 60
82280: PUSH
82281: LD_VAR 0 61
82285: PUSH
82286: LD_VAR 0 62
82290: PUSH
82291: LD_VAR 0 63
82295: PUSH
82296: LD_VAR 0 64
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: PUSH
82309: LD_VAR 0 4
82313: PUSH
82314: LD_INT 1
82316: PLUS
82317: ARRAY
82318: ST_TO_ADDR
82319: GO 82322
82321: POP
// temp_list2 = [ ] ;
82322: LD_ADDR_VAR 0 10
82326: PUSH
82327: EMPTY
82328: ST_TO_ADDR
// for i in temp_list do
82329: LD_ADDR_VAR 0 8
82333: PUSH
82334: LD_VAR 0 9
82338: PUSH
82339: FOR_IN
82340: IFFALSE 82392
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82342: LD_ADDR_VAR 0 10
82346: PUSH
82347: LD_VAR 0 10
82351: PUSH
82352: LD_VAR 0 8
82356: PUSH
82357: LD_INT 1
82359: ARRAY
82360: PUSH
82361: LD_VAR 0 2
82365: PLUS
82366: PUSH
82367: LD_VAR 0 8
82371: PUSH
82372: LD_INT 2
82374: ARRAY
82375: PUSH
82376: LD_VAR 0 3
82380: PLUS
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: EMPTY
82387: LIST
82388: ADD
82389: ST_TO_ADDR
82390: GO 82339
82392: POP
82393: POP
// result = temp_list2 ;
82394: LD_ADDR_VAR 0 7
82398: PUSH
82399: LD_VAR 0 10
82403: ST_TO_ADDR
// end ;
82404: LD_VAR 0 7
82408: RET
// export function EnemyInRange ( unit , dist ) ; begin
82409: LD_INT 0
82411: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82412: LD_ADDR_VAR 0 3
82416: PUSH
82417: LD_VAR 0 1
82421: PPUSH
82422: CALL_OW 255
82426: PPUSH
82427: LD_VAR 0 1
82431: PPUSH
82432: CALL_OW 250
82436: PPUSH
82437: LD_VAR 0 1
82441: PPUSH
82442: CALL_OW 251
82446: PPUSH
82447: LD_VAR 0 2
82451: PPUSH
82452: CALL 56513 0 4
82456: PUSH
82457: LD_INT 4
82459: ARRAY
82460: ST_TO_ADDR
// end ;
82461: LD_VAR 0 3
82465: RET
// export function PlayerSeeMe ( unit ) ; begin
82466: LD_INT 0
82468: PPUSH
// result := See ( your_side , unit ) ;
82469: LD_ADDR_VAR 0 2
82473: PUSH
82474: LD_OWVAR 2
82478: PPUSH
82479: LD_VAR 0 1
82483: PPUSH
82484: CALL_OW 292
82488: ST_TO_ADDR
// end ;
82489: LD_VAR 0 2
82493: RET
// export function ReverseDir ( unit ) ; begin
82494: LD_INT 0
82496: PPUSH
// if not unit then
82497: LD_VAR 0 1
82501: NOT
82502: IFFALSE 82506
// exit ;
82504: GO 82529
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82506: LD_ADDR_VAR 0 2
82510: PUSH
82511: LD_VAR 0 1
82515: PPUSH
82516: CALL_OW 254
82520: PUSH
82521: LD_INT 3
82523: PLUS
82524: PUSH
82525: LD_INT 6
82527: MOD
82528: ST_TO_ADDR
// end ;
82529: LD_VAR 0 2
82533: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
82534: LD_INT 0
82536: PPUSH
82537: PPUSH
82538: PPUSH
82539: PPUSH
82540: PPUSH
// if not hexes then
82541: LD_VAR 0 2
82545: NOT
82546: IFFALSE 82550
// exit ;
82548: GO 82698
// dist := 9999 ;
82550: LD_ADDR_VAR 0 5
82554: PUSH
82555: LD_INT 9999
82557: ST_TO_ADDR
// for i = 1 to hexes do
82558: LD_ADDR_VAR 0 4
82562: PUSH
82563: DOUBLE
82564: LD_INT 1
82566: DEC
82567: ST_TO_ADDR
82568: LD_VAR 0 2
82572: PUSH
82573: FOR_TO
82574: IFFALSE 82686
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
82576: LD_VAR 0 1
82580: PPUSH
82581: LD_VAR 0 2
82585: PUSH
82586: LD_VAR 0 4
82590: ARRAY
82591: PUSH
82592: LD_INT 1
82594: ARRAY
82595: PPUSH
82596: LD_VAR 0 2
82600: PUSH
82601: LD_VAR 0 4
82605: ARRAY
82606: PUSH
82607: LD_INT 2
82609: ARRAY
82610: PPUSH
82611: CALL_OW 297
82615: PUSH
82616: LD_VAR 0 5
82620: LESS
82621: IFFALSE 82684
// begin hex := hexes [ i ] ;
82623: LD_ADDR_VAR 0 7
82627: PUSH
82628: LD_VAR 0 2
82632: PUSH
82633: LD_VAR 0 4
82637: ARRAY
82638: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82639: LD_ADDR_VAR 0 5
82643: PUSH
82644: LD_VAR 0 1
82648: PPUSH
82649: LD_VAR 0 2
82653: PUSH
82654: LD_VAR 0 4
82658: ARRAY
82659: PUSH
82660: LD_INT 1
82662: ARRAY
82663: PPUSH
82664: LD_VAR 0 2
82668: PUSH
82669: LD_VAR 0 4
82673: ARRAY
82674: PUSH
82675: LD_INT 2
82677: ARRAY
82678: PPUSH
82679: CALL_OW 297
82683: ST_TO_ADDR
// end ; end ;
82684: GO 82573
82686: POP
82687: POP
// result := hex ;
82688: LD_ADDR_VAR 0 3
82692: PUSH
82693: LD_VAR 0 7
82697: ST_TO_ADDR
// end ;
82698: LD_VAR 0 3
82702: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82703: LD_INT 0
82705: PPUSH
82706: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82707: LD_VAR 0 1
82711: NOT
82712: PUSH
82713: LD_VAR 0 1
82717: PUSH
82718: LD_INT 21
82720: PUSH
82721: LD_INT 2
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: PUSH
82728: LD_INT 23
82730: PUSH
82731: LD_INT 2
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PPUSH
82742: CALL_OW 69
82746: IN
82747: NOT
82748: OR
82749: IFFALSE 82753
// exit ;
82751: GO 82800
// for i = 1 to 3 do
82753: LD_ADDR_VAR 0 3
82757: PUSH
82758: DOUBLE
82759: LD_INT 1
82761: DEC
82762: ST_TO_ADDR
82763: LD_INT 3
82765: PUSH
82766: FOR_TO
82767: IFFALSE 82798
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82769: LD_VAR 0 1
82773: PPUSH
82774: CALL_OW 250
82778: PPUSH
82779: LD_VAR 0 1
82783: PPUSH
82784: CALL_OW 251
82788: PPUSH
82789: LD_INT 1
82791: PPUSH
82792: CALL_OW 453
82796: GO 82766
82798: POP
82799: POP
// end ;
82800: LD_VAR 0 2
82804: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82805: LD_INT 0
82807: PPUSH
82808: PPUSH
82809: PPUSH
82810: PPUSH
82811: PPUSH
82812: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82813: LD_VAR 0 1
82817: NOT
82818: PUSH
82819: LD_VAR 0 2
82823: NOT
82824: OR
82825: PUSH
82826: LD_VAR 0 1
82830: PPUSH
82831: CALL_OW 314
82835: OR
82836: IFFALSE 82840
// exit ;
82838: GO 83281
// x := GetX ( enemy_unit ) ;
82840: LD_ADDR_VAR 0 7
82844: PUSH
82845: LD_VAR 0 2
82849: PPUSH
82850: CALL_OW 250
82854: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82855: LD_ADDR_VAR 0 8
82859: PUSH
82860: LD_VAR 0 2
82864: PPUSH
82865: CALL_OW 251
82869: ST_TO_ADDR
// if not x or not y then
82870: LD_VAR 0 7
82874: NOT
82875: PUSH
82876: LD_VAR 0 8
82880: NOT
82881: OR
82882: IFFALSE 82886
// exit ;
82884: GO 83281
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82886: LD_ADDR_VAR 0 6
82890: PUSH
82891: LD_VAR 0 7
82895: PPUSH
82896: LD_INT 0
82898: PPUSH
82899: LD_INT 4
82901: PPUSH
82902: CALL_OW 272
82906: PUSH
82907: LD_VAR 0 8
82911: PPUSH
82912: LD_INT 0
82914: PPUSH
82915: LD_INT 4
82917: PPUSH
82918: CALL_OW 273
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_VAR 0 7
82931: PPUSH
82932: LD_INT 1
82934: PPUSH
82935: LD_INT 4
82937: PPUSH
82938: CALL_OW 272
82942: PUSH
82943: LD_VAR 0 8
82947: PPUSH
82948: LD_INT 1
82950: PPUSH
82951: LD_INT 4
82953: PPUSH
82954: CALL_OW 273
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_VAR 0 7
82967: PPUSH
82968: LD_INT 2
82970: PPUSH
82971: LD_INT 4
82973: PPUSH
82974: CALL_OW 272
82978: PUSH
82979: LD_VAR 0 8
82983: PPUSH
82984: LD_INT 2
82986: PPUSH
82987: LD_INT 4
82989: PPUSH
82990: CALL_OW 273
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: LD_VAR 0 7
83003: PPUSH
83004: LD_INT 3
83006: PPUSH
83007: LD_INT 4
83009: PPUSH
83010: CALL_OW 272
83014: PUSH
83015: LD_VAR 0 8
83019: PPUSH
83020: LD_INT 3
83022: PPUSH
83023: LD_INT 4
83025: PPUSH
83026: CALL_OW 273
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_VAR 0 7
83039: PPUSH
83040: LD_INT 4
83042: PPUSH
83043: LD_INT 4
83045: PPUSH
83046: CALL_OW 272
83050: PUSH
83051: LD_VAR 0 8
83055: PPUSH
83056: LD_INT 4
83058: PPUSH
83059: LD_INT 4
83061: PPUSH
83062: CALL_OW 273
83066: PUSH
83067: EMPTY
83068: LIST
83069: LIST
83070: PUSH
83071: LD_VAR 0 7
83075: PPUSH
83076: LD_INT 5
83078: PPUSH
83079: LD_INT 4
83081: PPUSH
83082: CALL_OW 272
83086: PUSH
83087: LD_VAR 0 8
83091: PPUSH
83092: LD_INT 5
83094: PPUSH
83095: LD_INT 4
83097: PPUSH
83098: CALL_OW 273
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: ST_TO_ADDR
// for i = tmp downto 1 do
83115: LD_ADDR_VAR 0 4
83119: PUSH
83120: DOUBLE
83121: LD_VAR 0 6
83125: INC
83126: ST_TO_ADDR
83127: LD_INT 1
83129: PUSH
83130: FOR_DOWNTO
83131: IFFALSE 83232
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83133: LD_VAR 0 6
83137: PUSH
83138: LD_VAR 0 4
83142: ARRAY
83143: PUSH
83144: LD_INT 1
83146: ARRAY
83147: PPUSH
83148: LD_VAR 0 6
83152: PUSH
83153: LD_VAR 0 4
83157: ARRAY
83158: PUSH
83159: LD_INT 2
83161: ARRAY
83162: PPUSH
83163: CALL_OW 488
83167: NOT
83168: PUSH
83169: LD_VAR 0 6
83173: PUSH
83174: LD_VAR 0 4
83178: ARRAY
83179: PUSH
83180: LD_INT 1
83182: ARRAY
83183: PPUSH
83184: LD_VAR 0 6
83188: PUSH
83189: LD_VAR 0 4
83193: ARRAY
83194: PUSH
83195: LD_INT 2
83197: ARRAY
83198: PPUSH
83199: CALL_OW 428
83203: PUSH
83204: LD_INT 0
83206: NONEQUAL
83207: OR
83208: IFFALSE 83230
// tmp := Delete ( tmp , i ) ;
83210: LD_ADDR_VAR 0 6
83214: PUSH
83215: LD_VAR 0 6
83219: PPUSH
83220: LD_VAR 0 4
83224: PPUSH
83225: CALL_OW 3
83229: ST_TO_ADDR
83230: GO 83130
83232: POP
83233: POP
// j := GetClosestHex ( unit , tmp ) ;
83234: LD_ADDR_VAR 0 5
83238: PUSH
83239: LD_VAR 0 1
83243: PPUSH
83244: LD_VAR 0 6
83248: PPUSH
83249: CALL 82534 0 2
83253: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83254: LD_VAR 0 1
83258: PPUSH
83259: LD_VAR 0 5
83263: PUSH
83264: LD_INT 1
83266: ARRAY
83267: PPUSH
83268: LD_VAR 0 5
83272: PUSH
83273: LD_INT 2
83275: ARRAY
83276: PPUSH
83277: CALL_OW 111
// end ;
83281: LD_VAR 0 3
83285: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83286: LD_INT 0
83288: PPUSH
83289: PPUSH
83290: PPUSH
// uc_side = 0 ;
83291: LD_ADDR_OWVAR 20
83295: PUSH
83296: LD_INT 0
83298: ST_TO_ADDR
// uc_nation = 0 ;
83299: LD_ADDR_OWVAR 21
83303: PUSH
83304: LD_INT 0
83306: ST_TO_ADDR
// InitHc ;
83307: CALL_OW 19
// InitVc ;
83311: CALL_OW 20
// if mastodonts then
83315: LD_VAR 0 6
83319: IFFALSE 83386
// for i = 1 to mastodonts do
83321: LD_ADDR_VAR 0 11
83325: PUSH
83326: DOUBLE
83327: LD_INT 1
83329: DEC
83330: ST_TO_ADDR
83331: LD_VAR 0 6
83335: PUSH
83336: FOR_TO
83337: IFFALSE 83384
// begin vc_chassis := 31 ;
83339: LD_ADDR_OWVAR 37
83343: PUSH
83344: LD_INT 31
83346: ST_TO_ADDR
// vc_control := control_rider ;
83347: LD_ADDR_OWVAR 38
83351: PUSH
83352: LD_INT 4
83354: ST_TO_ADDR
// animal := CreateVehicle ;
83355: LD_ADDR_VAR 0 12
83359: PUSH
83360: CALL_OW 45
83364: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83365: LD_VAR 0 12
83369: PPUSH
83370: LD_VAR 0 8
83374: PPUSH
83375: LD_INT 0
83377: PPUSH
83378: CALL 85455 0 3
// end ;
83382: GO 83336
83384: POP
83385: POP
// if horses then
83386: LD_VAR 0 5
83390: IFFALSE 83457
// for i = 1 to horses do
83392: LD_ADDR_VAR 0 11
83396: PUSH
83397: DOUBLE
83398: LD_INT 1
83400: DEC
83401: ST_TO_ADDR
83402: LD_VAR 0 5
83406: PUSH
83407: FOR_TO
83408: IFFALSE 83455
// begin hc_class := 21 ;
83410: LD_ADDR_OWVAR 28
83414: PUSH
83415: LD_INT 21
83417: ST_TO_ADDR
// hc_gallery :=  ;
83418: LD_ADDR_OWVAR 33
83422: PUSH
83423: LD_STRING 
83425: ST_TO_ADDR
// animal := CreateHuman ;
83426: LD_ADDR_VAR 0 12
83430: PUSH
83431: CALL_OW 44
83435: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83436: LD_VAR 0 12
83440: PPUSH
83441: LD_VAR 0 8
83445: PPUSH
83446: LD_INT 0
83448: PPUSH
83449: CALL 85455 0 3
// end ;
83453: GO 83407
83455: POP
83456: POP
// if birds then
83457: LD_VAR 0 1
83461: IFFALSE 83528
// for i = 1 to birds do
83463: LD_ADDR_VAR 0 11
83467: PUSH
83468: DOUBLE
83469: LD_INT 1
83471: DEC
83472: ST_TO_ADDR
83473: LD_VAR 0 1
83477: PUSH
83478: FOR_TO
83479: IFFALSE 83526
// begin hc_class = 18 ;
83481: LD_ADDR_OWVAR 28
83485: PUSH
83486: LD_INT 18
83488: ST_TO_ADDR
// hc_gallery =  ;
83489: LD_ADDR_OWVAR 33
83493: PUSH
83494: LD_STRING 
83496: ST_TO_ADDR
// animal := CreateHuman ;
83497: LD_ADDR_VAR 0 12
83501: PUSH
83502: CALL_OW 44
83506: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83507: LD_VAR 0 12
83511: PPUSH
83512: LD_VAR 0 8
83516: PPUSH
83517: LD_INT 0
83519: PPUSH
83520: CALL 85455 0 3
// end ;
83524: GO 83478
83526: POP
83527: POP
// if tigers then
83528: LD_VAR 0 2
83532: IFFALSE 83616
// for i = 1 to tigers do
83534: LD_ADDR_VAR 0 11
83538: PUSH
83539: DOUBLE
83540: LD_INT 1
83542: DEC
83543: ST_TO_ADDR
83544: LD_VAR 0 2
83548: PUSH
83549: FOR_TO
83550: IFFALSE 83614
// begin hc_class = class_tiger ;
83552: LD_ADDR_OWVAR 28
83556: PUSH
83557: LD_INT 14
83559: ST_TO_ADDR
// hc_gallery =  ;
83560: LD_ADDR_OWVAR 33
83564: PUSH
83565: LD_STRING 
83567: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83568: LD_ADDR_OWVAR 35
83572: PUSH
83573: LD_INT 7
83575: NEG
83576: PPUSH
83577: LD_INT 7
83579: PPUSH
83580: CALL_OW 12
83584: ST_TO_ADDR
// animal := CreateHuman ;
83585: LD_ADDR_VAR 0 12
83589: PUSH
83590: CALL_OW 44
83594: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83595: LD_VAR 0 12
83599: PPUSH
83600: LD_VAR 0 8
83604: PPUSH
83605: LD_INT 0
83607: PPUSH
83608: CALL 85455 0 3
// end ;
83612: GO 83549
83614: POP
83615: POP
// if apemans then
83616: LD_VAR 0 3
83620: IFFALSE 83743
// for i = 1 to apemans do
83622: LD_ADDR_VAR 0 11
83626: PUSH
83627: DOUBLE
83628: LD_INT 1
83630: DEC
83631: ST_TO_ADDR
83632: LD_VAR 0 3
83636: PUSH
83637: FOR_TO
83638: IFFALSE 83741
// begin hc_class = class_apeman ;
83640: LD_ADDR_OWVAR 28
83644: PUSH
83645: LD_INT 12
83647: ST_TO_ADDR
// hc_gallery =  ;
83648: LD_ADDR_OWVAR 33
83652: PUSH
83653: LD_STRING 
83655: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
83656: LD_ADDR_OWVAR 35
83660: PUSH
83661: LD_INT 5
83663: NEG
83664: PPUSH
83665: LD_INT 5
83667: PPUSH
83668: CALL_OW 12
83672: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83673: LD_ADDR_OWVAR 31
83677: PUSH
83678: LD_INT 1
83680: PPUSH
83681: LD_INT 3
83683: PPUSH
83684: CALL_OW 12
83688: PUSH
83689: LD_INT 1
83691: PPUSH
83692: LD_INT 3
83694: PPUSH
83695: CALL_OW 12
83699: PUSH
83700: LD_INT 0
83702: PUSH
83703: LD_INT 0
83705: PUSH
83706: EMPTY
83707: LIST
83708: LIST
83709: LIST
83710: LIST
83711: ST_TO_ADDR
// animal := CreateHuman ;
83712: LD_ADDR_VAR 0 12
83716: PUSH
83717: CALL_OW 44
83721: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83722: LD_VAR 0 12
83726: PPUSH
83727: LD_VAR 0 8
83731: PPUSH
83732: LD_INT 0
83734: PPUSH
83735: CALL 85455 0 3
// end ;
83739: GO 83637
83741: POP
83742: POP
// if enchidnas then
83743: LD_VAR 0 4
83747: IFFALSE 83814
// for i = 1 to enchidnas do
83749: LD_ADDR_VAR 0 11
83753: PUSH
83754: DOUBLE
83755: LD_INT 1
83757: DEC
83758: ST_TO_ADDR
83759: LD_VAR 0 4
83763: PUSH
83764: FOR_TO
83765: IFFALSE 83812
// begin hc_class = 13 ;
83767: LD_ADDR_OWVAR 28
83771: PUSH
83772: LD_INT 13
83774: ST_TO_ADDR
// hc_gallery =  ;
83775: LD_ADDR_OWVAR 33
83779: PUSH
83780: LD_STRING 
83782: ST_TO_ADDR
// animal := CreateHuman ;
83783: LD_ADDR_VAR 0 12
83787: PUSH
83788: CALL_OW 44
83792: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83793: LD_VAR 0 12
83797: PPUSH
83798: LD_VAR 0 8
83802: PPUSH
83803: LD_INT 0
83805: PPUSH
83806: CALL 85455 0 3
// end ;
83810: GO 83764
83812: POP
83813: POP
// if fishes then
83814: LD_VAR 0 7
83818: IFFALSE 83885
// for i = 1 to fishes do
83820: LD_ADDR_VAR 0 11
83824: PUSH
83825: DOUBLE
83826: LD_INT 1
83828: DEC
83829: ST_TO_ADDR
83830: LD_VAR 0 7
83834: PUSH
83835: FOR_TO
83836: IFFALSE 83883
// begin hc_class = 20 ;
83838: LD_ADDR_OWVAR 28
83842: PUSH
83843: LD_INT 20
83845: ST_TO_ADDR
// hc_gallery =  ;
83846: LD_ADDR_OWVAR 33
83850: PUSH
83851: LD_STRING 
83853: ST_TO_ADDR
// animal := CreateHuman ;
83854: LD_ADDR_VAR 0 12
83858: PUSH
83859: CALL_OW 44
83863: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83864: LD_VAR 0 12
83868: PPUSH
83869: LD_VAR 0 9
83873: PPUSH
83874: LD_INT 0
83876: PPUSH
83877: CALL 85455 0 3
// end ;
83881: GO 83835
83883: POP
83884: POP
// end ;
83885: LD_VAR 0 10
83889: RET
// export function WantHeal ( sci , unit ) ; begin
83890: LD_INT 0
83892: PPUSH
// if GetTaskList ( sci ) > 0 then
83893: LD_VAR 0 1
83897: PPUSH
83898: CALL_OW 437
83902: PUSH
83903: LD_INT 0
83905: GREATER
83906: IFFALSE 83976
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83908: LD_VAR 0 1
83912: PPUSH
83913: CALL_OW 437
83917: PUSH
83918: LD_INT 1
83920: ARRAY
83921: PUSH
83922: LD_INT 1
83924: ARRAY
83925: PUSH
83926: LD_STRING l
83928: EQUAL
83929: PUSH
83930: LD_VAR 0 1
83934: PPUSH
83935: CALL_OW 437
83939: PUSH
83940: LD_INT 1
83942: ARRAY
83943: PUSH
83944: LD_INT 4
83946: ARRAY
83947: PUSH
83948: LD_VAR 0 2
83952: EQUAL
83953: AND
83954: IFFALSE 83966
// result := true else
83956: LD_ADDR_VAR 0 3
83960: PUSH
83961: LD_INT 1
83963: ST_TO_ADDR
83964: GO 83974
// result := false ;
83966: LD_ADDR_VAR 0 3
83970: PUSH
83971: LD_INT 0
83973: ST_TO_ADDR
// end else
83974: GO 83984
// result := false ;
83976: LD_ADDR_VAR 0 3
83980: PUSH
83981: LD_INT 0
83983: ST_TO_ADDR
// end ;
83984: LD_VAR 0 3
83988: RET
// export function HealTarget ( sci ) ; begin
83989: LD_INT 0
83991: PPUSH
// if not sci then
83992: LD_VAR 0 1
83996: NOT
83997: IFFALSE 84001
// exit ;
83999: GO 84066
// result := 0 ;
84001: LD_ADDR_VAR 0 2
84005: PUSH
84006: LD_INT 0
84008: ST_TO_ADDR
// if GetTaskList ( sci ) then
84009: LD_VAR 0 1
84013: PPUSH
84014: CALL_OW 437
84018: IFFALSE 84066
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84020: LD_VAR 0 1
84024: PPUSH
84025: CALL_OW 437
84029: PUSH
84030: LD_INT 1
84032: ARRAY
84033: PUSH
84034: LD_INT 1
84036: ARRAY
84037: PUSH
84038: LD_STRING l
84040: EQUAL
84041: IFFALSE 84066
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84043: LD_ADDR_VAR 0 2
84047: PUSH
84048: LD_VAR 0 1
84052: PPUSH
84053: CALL_OW 437
84057: PUSH
84058: LD_INT 1
84060: ARRAY
84061: PUSH
84062: LD_INT 4
84064: ARRAY
84065: ST_TO_ADDR
// end ;
84066: LD_VAR 0 2
84070: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84071: LD_INT 0
84073: PPUSH
84074: PPUSH
84075: PPUSH
84076: PPUSH
// if not base_units then
84077: LD_VAR 0 1
84081: NOT
84082: IFFALSE 84086
// exit ;
84084: GO 84173
// result := false ;
84086: LD_ADDR_VAR 0 2
84090: PUSH
84091: LD_INT 0
84093: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84094: LD_ADDR_VAR 0 5
84098: PUSH
84099: LD_VAR 0 1
84103: PPUSH
84104: LD_INT 21
84106: PUSH
84107: LD_INT 3
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PPUSH
84114: CALL_OW 72
84118: ST_TO_ADDR
// if not tmp then
84119: LD_VAR 0 5
84123: NOT
84124: IFFALSE 84128
// exit ;
84126: GO 84173
// for i in tmp do
84128: LD_ADDR_VAR 0 3
84132: PUSH
84133: LD_VAR 0 5
84137: PUSH
84138: FOR_IN
84139: IFFALSE 84171
// begin result := EnemyInRange ( i , 22 ) ;
84141: LD_ADDR_VAR 0 2
84145: PUSH
84146: LD_VAR 0 3
84150: PPUSH
84151: LD_INT 22
84153: PPUSH
84154: CALL 82409 0 2
84158: ST_TO_ADDR
// if result then
84159: LD_VAR 0 2
84163: IFFALSE 84169
// exit ;
84165: POP
84166: POP
84167: GO 84173
// end ;
84169: GO 84138
84171: POP
84172: POP
// end ;
84173: LD_VAR 0 2
84177: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84178: LD_INT 0
84180: PPUSH
84181: PPUSH
// if not units then
84182: LD_VAR 0 1
84186: NOT
84187: IFFALSE 84191
// exit ;
84189: GO 84261
// result := [ ] ;
84191: LD_ADDR_VAR 0 3
84195: PUSH
84196: EMPTY
84197: ST_TO_ADDR
// for i in units do
84198: LD_ADDR_VAR 0 4
84202: PUSH
84203: LD_VAR 0 1
84207: PUSH
84208: FOR_IN
84209: IFFALSE 84259
// if GetTag ( i ) = tag then
84211: LD_VAR 0 4
84215: PPUSH
84216: CALL_OW 110
84220: PUSH
84221: LD_VAR 0 2
84225: EQUAL
84226: IFFALSE 84257
// result := Insert ( result , result + 1 , i ) ;
84228: LD_ADDR_VAR 0 3
84232: PUSH
84233: LD_VAR 0 3
84237: PPUSH
84238: LD_VAR 0 3
84242: PUSH
84243: LD_INT 1
84245: PLUS
84246: PPUSH
84247: LD_VAR 0 4
84251: PPUSH
84252: CALL_OW 2
84256: ST_TO_ADDR
84257: GO 84208
84259: POP
84260: POP
// end ;
84261: LD_VAR 0 3
84265: RET
// export function IsDriver ( un ) ; begin
84266: LD_INT 0
84268: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84269: LD_ADDR_VAR 0 2
84273: PUSH
84274: LD_VAR 0 1
84278: PUSH
84279: LD_INT 55
84281: PUSH
84282: EMPTY
84283: LIST
84284: PPUSH
84285: CALL_OW 69
84289: IN
84290: ST_TO_ADDR
// end ;
84291: LD_VAR 0 2
84295: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84296: LD_INT 0
84298: PPUSH
84299: PPUSH
// list := [ ] ;
84300: LD_ADDR_VAR 0 5
84304: PUSH
84305: EMPTY
84306: ST_TO_ADDR
// case d of 0 :
84307: LD_VAR 0 3
84311: PUSH
84312: LD_INT 0
84314: DOUBLE
84315: EQUAL
84316: IFTRUE 84320
84318: GO 84453
84320: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84321: LD_ADDR_VAR 0 5
84325: PUSH
84326: LD_VAR 0 1
84330: PUSH
84331: LD_INT 4
84333: MINUS
84334: PUSH
84335: LD_VAR 0 2
84339: PUSH
84340: LD_INT 4
84342: MINUS
84343: PUSH
84344: LD_INT 2
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: LIST
84351: PUSH
84352: LD_VAR 0 1
84356: PUSH
84357: LD_INT 3
84359: MINUS
84360: PUSH
84361: LD_VAR 0 2
84365: PUSH
84366: LD_INT 1
84368: PUSH
84369: EMPTY
84370: LIST
84371: LIST
84372: LIST
84373: PUSH
84374: LD_VAR 0 1
84378: PUSH
84379: LD_INT 4
84381: PLUS
84382: PUSH
84383: LD_VAR 0 2
84387: PUSH
84388: LD_INT 4
84390: PUSH
84391: EMPTY
84392: LIST
84393: LIST
84394: LIST
84395: PUSH
84396: LD_VAR 0 1
84400: PUSH
84401: LD_INT 3
84403: PLUS
84404: PUSH
84405: LD_VAR 0 2
84409: PUSH
84410: LD_INT 3
84412: PLUS
84413: PUSH
84414: LD_INT 5
84416: PUSH
84417: EMPTY
84418: LIST
84419: LIST
84420: LIST
84421: PUSH
84422: LD_VAR 0 1
84426: PUSH
84427: LD_VAR 0 2
84431: PUSH
84432: LD_INT 4
84434: PLUS
84435: PUSH
84436: LD_INT 0
84438: PUSH
84439: EMPTY
84440: LIST
84441: LIST
84442: LIST
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: LIST
84448: LIST
84449: LIST
84450: ST_TO_ADDR
// end ; 1 :
84451: GO 85151
84453: LD_INT 1
84455: DOUBLE
84456: EQUAL
84457: IFTRUE 84461
84459: GO 84594
84461: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84462: LD_ADDR_VAR 0 5
84466: PUSH
84467: LD_VAR 0 1
84471: PUSH
84472: LD_VAR 0 2
84476: PUSH
84477: LD_INT 4
84479: MINUS
84480: PUSH
84481: LD_INT 3
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: LIST
84488: PUSH
84489: LD_VAR 0 1
84493: PUSH
84494: LD_INT 3
84496: MINUS
84497: PUSH
84498: LD_VAR 0 2
84502: PUSH
84503: LD_INT 3
84505: MINUS
84506: PUSH
84507: LD_INT 2
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: LIST
84514: PUSH
84515: LD_VAR 0 1
84519: PUSH
84520: LD_INT 4
84522: MINUS
84523: PUSH
84524: LD_VAR 0 2
84528: PUSH
84529: LD_INT 1
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: LIST
84536: PUSH
84537: LD_VAR 0 1
84541: PUSH
84542: LD_VAR 0 2
84546: PUSH
84547: LD_INT 3
84549: PLUS
84550: PUSH
84551: LD_INT 0
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: LIST
84558: PUSH
84559: LD_VAR 0 1
84563: PUSH
84564: LD_INT 4
84566: PLUS
84567: PUSH
84568: LD_VAR 0 2
84572: PUSH
84573: LD_INT 4
84575: PLUS
84576: PUSH
84577: LD_INT 5
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: LIST
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: ST_TO_ADDR
// end ; 2 :
84592: GO 85151
84594: LD_INT 2
84596: DOUBLE
84597: EQUAL
84598: IFTRUE 84602
84600: GO 84731
84602: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84603: LD_ADDR_VAR 0 5
84607: PUSH
84608: LD_VAR 0 1
84612: PUSH
84613: LD_VAR 0 2
84617: PUSH
84618: LD_INT 3
84620: MINUS
84621: PUSH
84622: LD_INT 3
84624: PUSH
84625: EMPTY
84626: LIST
84627: LIST
84628: LIST
84629: PUSH
84630: LD_VAR 0 1
84634: PUSH
84635: LD_INT 4
84637: PLUS
84638: PUSH
84639: LD_VAR 0 2
84643: PUSH
84644: LD_INT 4
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: LIST
84651: PUSH
84652: LD_VAR 0 1
84656: PUSH
84657: LD_VAR 0 2
84661: PUSH
84662: LD_INT 4
84664: PLUS
84665: PUSH
84666: LD_INT 0
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: LIST
84673: PUSH
84674: LD_VAR 0 1
84678: PUSH
84679: LD_INT 3
84681: MINUS
84682: PUSH
84683: LD_VAR 0 2
84687: PUSH
84688: LD_INT 1
84690: PUSH
84691: EMPTY
84692: LIST
84693: LIST
84694: LIST
84695: PUSH
84696: LD_VAR 0 1
84700: PUSH
84701: LD_INT 4
84703: MINUS
84704: PUSH
84705: LD_VAR 0 2
84709: PUSH
84710: LD_INT 4
84712: MINUS
84713: PUSH
84714: LD_INT 2
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: LIST
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: LIST
84726: LIST
84727: LIST
84728: ST_TO_ADDR
// end ; 3 :
84729: GO 85151
84731: LD_INT 3
84733: DOUBLE
84734: EQUAL
84735: IFTRUE 84739
84737: GO 84872
84739: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84740: LD_ADDR_VAR 0 5
84744: PUSH
84745: LD_VAR 0 1
84749: PUSH
84750: LD_INT 3
84752: PLUS
84753: PUSH
84754: LD_VAR 0 2
84758: PUSH
84759: LD_INT 4
84761: PUSH
84762: EMPTY
84763: LIST
84764: LIST
84765: LIST
84766: PUSH
84767: LD_VAR 0 1
84771: PUSH
84772: LD_INT 4
84774: PLUS
84775: PUSH
84776: LD_VAR 0 2
84780: PUSH
84781: LD_INT 4
84783: PLUS
84784: PUSH
84785: LD_INT 5
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: LIST
84792: PUSH
84793: LD_VAR 0 1
84797: PUSH
84798: LD_INT 4
84800: MINUS
84801: PUSH
84802: LD_VAR 0 2
84806: PUSH
84807: LD_INT 1
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: LIST
84814: PUSH
84815: LD_VAR 0 1
84819: PUSH
84820: LD_VAR 0 2
84824: PUSH
84825: LD_INT 4
84827: MINUS
84828: PUSH
84829: LD_INT 3
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: LIST
84836: PUSH
84837: LD_VAR 0 1
84841: PUSH
84842: LD_INT 3
84844: MINUS
84845: PUSH
84846: LD_VAR 0 2
84850: PUSH
84851: LD_INT 3
84853: MINUS
84854: PUSH
84855: LD_INT 2
84857: PUSH
84858: EMPTY
84859: LIST
84860: LIST
84861: LIST
84862: PUSH
84863: EMPTY
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: ST_TO_ADDR
// end ; 4 :
84870: GO 85151
84872: LD_INT 4
84874: DOUBLE
84875: EQUAL
84876: IFTRUE 84880
84878: GO 85013
84880: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84881: LD_ADDR_VAR 0 5
84885: PUSH
84886: LD_VAR 0 1
84890: PUSH
84891: LD_VAR 0 2
84895: PUSH
84896: LD_INT 4
84898: PLUS
84899: PUSH
84900: LD_INT 0
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: LIST
84907: PUSH
84908: LD_VAR 0 1
84912: PUSH
84913: LD_INT 3
84915: PLUS
84916: PUSH
84917: LD_VAR 0 2
84921: PUSH
84922: LD_INT 3
84924: PLUS
84925: PUSH
84926: LD_INT 5
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: LIST
84933: PUSH
84934: LD_VAR 0 1
84938: PUSH
84939: LD_INT 4
84941: PLUS
84942: PUSH
84943: LD_VAR 0 2
84947: PUSH
84948: LD_INT 4
84950: PUSH
84951: EMPTY
84952: LIST
84953: LIST
84954: LIST
84955: PUSH
84956: LD_VAR 0 1
84960: PUSH
84961: LD_VAR 0 2
84965: PUSH
84966: LD_INT 3
84968: MINUS
84969: PUSH
84970: LD_INT 3
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: LIST
84977: PUSH
84978: LD_VAR 0 1
84982: PUSH
84983: LD_INT 4
84985: MINUS
84986: PUSH
84987: LD_VAR 0 2
84991: PUSH
84992: LD_INT 4
84994: MINUS
84995: PUSH
84996: LD_INT 2
84998: PUSH
84999: EMPTY
85000: LIST
85001: LIST
85002: LIST
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: LIST
85008: LIST
85009: LIST
85010: ST_TO_ADDR
// end ; 5 :
85011: GO 85151
85013: LD_INT 5
85015: DOUBLE
85016: EQUAL
85017: IFTRUE 85021
85019: GO 85150
85021: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85022: LD_ADDR_VAR 0 5
85026: PUSH
85027: LD_VAR 0 1
85031: PUSH
85032: LD_INT 4
85034: MINUS
85035: PUSH
85036: LD_VAR 0 2
85040: PUSH
85041: LD_INT 1
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: LIST
85048: PUSH
85049: LD_VAR 0 1
85053: PUSH
85054: LD_VAR 0 2
85058: PUSH
85059: LD_INT 4
85061: MINUS
85062: PUSH
85063: LD_INT 3
85065: PUSH
85066: EMPTY
85067: LIST
85068: LIST
85069: LIST
85070: PUSH
85071: LD_VAR 0 1
85075: PUSH
85076: LD_INT 4
85078: PLUS
85079: PUSH
85080: LD_VAR 0 2
85084: PUSH
85085: LD_INT 4
85087: PLUS
85088: PUSH
85089: LD_INT 5
85091: PUSH
85092: EMPTY
85093: LIST
85094: LIST
85095: LIST
85096: PUSH
85097: LD_VAR 0 1
85101: PUSH
85102: LD_INT 3
85104: PLUS
85105: PUSH
85106: LD_VAR 0 2
85110: PUSH
85111: LD_INT 4
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: LIST
85118: PUSH
85119: LD_VAR 0 1
85123: PUSH
85124: LD_VAR 0 2
85128: PUSH
85129: LD_INT 3
85131: PLUS
85132: PUSH
85133: LD_INT 0
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: LIST
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: LIST
85145: LIST
85146: LIST
85147: ST_TO_ADDR
// end ; end ;
85148: GO 85151
85150: POP
// result := list ;
85151: LD_ADDR_VAR 0 4
85155: PUSH
85156: LD_VAR 0 5
85160: ST_TO_ADDR
// end ;
85161: LD_VAR 0 4
85165: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85166: LD_INT 0
85168: PPUSH
85169: PPUSH
85170: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85171: LD_VAR 0 1
85175: NOT
85176: PUSH
85177: LD_VAR 0 2
85181: PUSH
85182: LD_INT 1
85184: PUSH
85185: LD_INT 2
85187: PUSH
85188: LD_INT 3
85190: PUSH
85191: LD_INT 4
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: IN
85200: NOT
85201: OR
85202: IFFALSE 85206
// exit ;
85204: GO 85298
// tmp := [ ] ;
85206: LD_ADDR_VAR 0 5
85210: PUSH
85211: EMPTY
85212: ST_TO_ADDR
// for i in units do
85213: LD_ADDR_VAR 0 4
85217: PUSH
85218: LD_VAR 0 1
85222: PUSH
85223: FOR_IN
85224: IFFALSE 85267
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85226: LD_ADDR_VAR 0 5
85230: PUSH
85231: LD_VAR 0 5
85235: PPUSH
85236: LD_VAR 0 5
85240: PUSH
85241: LD_INT 1
85243: PLUS
85244: PPUSH
85245: LD_VAR 0 4
85249: PPUSH
85250: LD_VAR 0 2
85254: PPUSH
85255: CALL_OW 259
85259: PPUSH
85260: CALL_OW 2
85264: ST_TO_ADDR
85265: GO 85223
85267: POP
85268: POP
// if not tmp then
85269: LD_VAR 0 5
85273: NOT
85274: IFFALSE 85278
// exit ;
85276: GO 85298
// result := SortListByListDesc ( units , tmp ) ;
85278: LD_ADDR_VAR 0 3
85282: PUSH
85283: LD_VAR 0 1
85287: PPUSH
85288: LD_VAR 0 5
85292: PPUSH
85293: CALL_OW 77
85297: ST_TO_ADDR
// end ;
85298: LD_VAR 0 3
85302: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85303: LD_INT 0
85305: PPUSH
85306: PPUSH
85307: PPUSH
// x := GetX ( building ) ;
85308: LD_ADDR_VAR 0 4
85312: PUSH
85313: LD_VAR 0 2
85317: PPUSH
85318: CALL_OW 250
85322: ST_TO_ADDR
// y := GetY ( building ) ;
85323: LD_ADDR_VAR 0 5
85327: PUSH
85328: LD_VAR 0 2
85332: PPUSH
85333: CALL_OW 251
85337: ST_TO_ADDR
// if GetTaskList ( unit ) then
85338: LD_VAR 0 1
85342: PPUSH
85343: CALL_OW 437
85347: IFFALSE 85442
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85349: LD_STRING e
85351: PUSH
85352: LD_VAR 0 1
85356: PPUSH
85357: CALL_OW 437
85361: PUSH
85362: LD_INT 1
85364: ARRAY
85365: PUSH
85366: LD_INT 1
85368: ARRAY
85369: EQUAL
85370: PUSH
85371: LD_VAR 0 4
85375: PUSH
85376: LD_VAR 0 1
85380: PPUSH
85381: CALL_OW 437
85385: PUSH
85386: LD_INT 1
85388: ARRAY
85389: PUSH
85390: LD_INT 2
85392: ARRAY
85393: EQUAL
85394: AND
85395: PUSH
85396: LD_VAR 0 5
85400: PUSH
85401: LD_VAR 0 1
85405: PPUSH
85406: CALL_OW 437
85410: PUSH
85411: LD_INT 1
85413: ARRAY
85414: PUSH
85415: LD_INT 3
85417: ARRAY
85418: EQUAL
85419: AND
85420: IFFALSE 85432
// result := true else
85422: LD_ADDR_VAR 0 3
85426: PUSH
85427: LD_INT 1
85429: ST_TO_ADDR
85430: GO 85440
// result := false ;
85432: LD_ADDR_VAR 0 3
85436: PUSH
85437: LD_INT 0
85439: ST_TO_ADDR
// end else
85440: GO 85450
// result := false ;
85442: LD_ADDR_VAR 0 3
85446: PUSH
85447: LD_INT 0
85449: ST_TO_ADDR
// end ;
85450: LD_VAR 0 3
85454: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85455: LD_INT 0
85457: PPUSH
85458: PPUSH
85459: PPUSH
85460: PPUSH
// if not unit or not area then
85461: LD_VAR 0 1
85465: NOT
85466: PUSH
85467: LD_VAR 0 2
85471: NOT
85472: OR
85473: IFFALSE 85477
// exit ;
85475: GO 85641
// tmp := AreaToList ( area , i ) ;
85477: LD_ADDR_VAR 0 6
85481: PUSH
85482: LD_VAR 0 2
85486: PPUSH
85487: LD_VAR 0 5
85491: PPUSH
85492: CALL_OW 517
85496: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85497: LD_ADDR_VAR 0 5
85501: PUSH
85502: DOUBLE
85503: LD_INT 1
85505: DEC
85506: ST_TO_ADDR
85507: LD_VAR 0 6
85511: PUSH
85512: LD_INT 1
85514: ARRAY
85515: PUSH
85516: FOR_TO
85517: IFFALSE 85639
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85519: LD_ADDR_VAR 0 7
85523: PUSH
85524: LD_VAR 0 6
85528: PUSH
85529: LD_INT 1
85531: ARRAY
85532: PUSH
85533: LD_VAR 0 5
85537: ARRAY
85538: PUSH
85539: LD_VAR 0 6
85543: PUSH
85544: LD_INT 2
85546: ARRAY
85547: PUSH
85548: LD_VAR 0 5
85552: ARRAY
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85558: LD_VAR 0 7
85562: PUSH
85563: LD_INT 1
85565: ARRAY
85566: PPUSH
85567: LD_VAR 0 7
85571: PUSH
85572: LD_INT 2
85574: ARRAY
85575: PPUSH
85576: CALL_OW 428
85580: PUSH
85581: LD_INT 0
85583: EQUAL
85584: IFFALSE 85637
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85586: LD_VAR 0 1
85590: PPUSH
85591: LD_VAR 0 7
85595: PUSH
85596: LD_INT 1
85598: ARRAY
85599: PPUSH
85600: LD_VAR 0 7
85604: PUSH
85605: LD_INT 2
85607: ARRAY
85608: PPUSH
85609: LD_VAR 0 3
85613: PPUSH
85614: CALL_OW 48
// result := IsPlaced ( unit ) ;
85618: LD_ADDR_VAR 0 4
85622: PUSH
85623: LD_VAR 0 1
85627: PPUSH
85628: CALL_OW 305
85632: ST_TO_ADDR
// exit ;
85633: POP
85634: POP
85635: GO 85641
// end ; end ;
85637: GO 85516
85639: POP
85640: POP
// end ;
85641: LD_VAR 0 4
85645: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85646: LD_INT 0
85648: PPUSH
85649: PPUSH
85650: PPUSH
// if not side or side > 8 then
85651: LD_VAR 0 1
85655: NOT
85656: PUSH
85657: LD_VAR 0 1
85661: PUSH
85662: LD_INT 8
85664: GREATER
85665: OR
85666: IFFALSE 85670
// exit ;
85668: GO 85857
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85670: LD_ADDR_VAR 0 4
85674: PUSH
85675: LD_INT 22
85677: PUSH
85678: LD_VAR 0 1
85682: PUSH
85683: EMPTY
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 21
85689: PUSH
85690: LD_INT 3
85692: PUSH
85693: EMPTY
85694: LIST
85695: LIST
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: PPUSH
85701: CALL_OW 69
85705: ST_TO_ADDR
// if not tmp then
85706: LD_VAR 0 4
85710: NOT
85711: IFFALSE 85715
// exit ;
85713: GO 85857
// enable_addtolog := true ;
85715: LD_ADDR_OWVAR 81
85719: PUSH
85720: LD_INT 1
85722: ST_TO_ADDR
// AddToLog ( [ ) ;
85723: LD_STRING [
85725: PPUSH
85726: CALL_OW 561
// for i in tmp do
85730: LD_ADDR_VAR 0 3
85734: PUSH
85735: LD_VAR 0 4
85739: PUSH
85740: FOR_IN
85741: IFFALSE 85848
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85743: LD_STRING [
85745: PUSH
85746: LD_VAR 0 3
85750: PPUSH
85751: CALL_OW 266
85755: STR
85756: PUSH
85757: LD_STRING , 
85759: STR
85760: PUSH
85761: LD_VAR 0 3
85765: PPUSH
85766: CALL_OW 250
85770: STR
85771: PUSH
85772: LD_STRING , 
85774: STR
85775: PUSH
85776: LD_VAR 0 3
85780: PPUSH
85781: CALL_OW 251
85785: STR
85786: PUSH
85787: LD_STRING , 
85789: STR
85790: PUSH
85791: LD_VAR 0 3
85795: PPUSH
85796: CALL_OW 254
85800: STR
85801: PUSH
85802: LD_STRING , 
85804: STR
85805: PUSH
85806: LD_VAR 0 3
85810: PPUSH
85811: LD_INT 1
85813: PPUSH
85814: CALL_OW 268
85818: STR
85819: PUSH
85820: LD_STRING , 
85822: STR
85823: PUSH
85824: LD_VAR 0 3
85828: PPUSH
85829: LD_INT 2
85831: PPUSH
85832: CALL_OW 268
85836: STR
85837: PUSH
85838: LD_STRING ],
85840: STR
85841: PPUSH
85842: CALL_OW 561
// end ;
85846: GO 85740
85848: POP
85849: POP
// AddToLog ( ]; ) ;
85850: LD_STRING ];
85852: PPUSH
85853: CALL_OW 561
// end ;
85857: LD_VAR 0 2
85861: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85862: LD_INT 0
85864: PPUSH
85865: PPUSH
85866: PPUSH
85867: PPUSH
85868: PPUSH
// if not area or not rate or not max then
85869: LD_VAR 0 1
85873: NOT
85874: PUSH
85875: LD_VAR 0 2
85879: NOT
85880: OR
85881: PUSH
85882: LD_VAR 0 4
85886: NOT
85887: OR
85888: IFFALSE 85892
// exit ;
85890: GO 86084
// while 1 do
85892: LD_INT 1
85894: IFFALSE 86084
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85896: LD_ADDR_VAR 0 9
85900: PUSH
85901: LD_VAR 0 1
85905: PPUSH
85906: LD_INT 1
85908: PPUSH
85909: CALL_OW 287
85913: PUSH
85914: LD_INT 10
85916: MUL
85917: ST_TO_ADDR
// r := rate / 10 ;
85918: LD_ADDR_VAR 0 7
85922: PUSH
85923: LD_VAR 0 2
85927: PUSH
85928: LD_INT 10
85930: DIVREAL
85931: ST_TO_ADDR
// time := 1 1$00 ;
85932: LD_ADDR_VAR 0 8
85936: PUSH
85937: LD_INT 2100
85939: ST_TO_ADDR
// if amount < min then
85940: LD_VAR 0 9
85944: PUSH
85945: LD_VAR 0 3
85949: LESS
85950: IFFALSE 85968
// r := r * 2 else
85952: LD_ADDR_VAR 0 7
85956: PUSH
85957: LD_VAR 0 7
85961: PUSH
85962: LD_INT 2
85964: MUL
85965: ST_TO_ADDR
85966: GO 85994
// if amount > max then
85968: LD_VAR 0 9
85972: PUSH
85973: LD_VAR 0 4
85977: GREATER
85978: IFFALSE 85994
// r := r / 2 ;
85980: LD_ADDR_VAR 0 7
85984: PUSH
85985: LD_VAR 0 7
85989: PUSH
85990: LD_INT 2
85992: DIVREAL
85993: ST_TO_ADDR
// time := time / r ;
85994: LD_ADDR_VAR 0 8
85998: PUSH
85999: LD_VAR 0 8
86003: PUSH
86004: LD_VAR 0 7
86008: DIVREAL
86009: ST_TO_ADDR
// if time < 0 then
86010: LD_VAR 0 8
86014: PUSH
86015: LD_INT 0
86017: LESS
86018: IFFALSE 86035
// time := time * - 1 ;
86020: LD_ADDR_VAR 0 8
86024: PUSH
86025: LD_VAR 0 8
86029: PUSH
86030: LD_INT 1
86032: NEG
86033: MUL
86034: ST_TO_ADDR
// wait ( time ) ;
86035: LD_VAR 0 8
86039: PPUSH
86040: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
86044: LD_INT 35
86046: PPUSH
86047: LD_INT 875
86049: PPUSH
86050: CALL_OW 12
86054: PPUSH
86055: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86059: LD_INT 1
86061: PPUSH
86062: LD_INT 5
86064: PPUSH
86065: CALL_OW 12
86069: PPUSH
86070: LD_VAR 0 1
86074: PPUSH
86075: LD_INT 1
86077: PPUSH
86078: CALL_OW 55
// end ;
86082: GO 85892
// end ;
86084: LD_VAR 0 5
86088: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86089: LD_INT 0
86091: PPUSH
86092: PPUSH
86093: PPUSH
86094: PPUSH
86095: PPUSH
86096: PPUSH
86097: PPUSH
86098: PPUSH
// if not turrets or not factories then
86099: LD_VAR 0 1
86103: NOT
86104: PUSH
86105: LD_VAR 0 2
86109: NOT
86110: OR
86111: IFFALSE 86115
// exit ;
86113: GO 86422
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86115: LD_ADDR_VAR 0 10
86119: PUSH
86120: LD_INT 5
86122: PUSH
86123: LD_INT 6
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 2
86132: PUSH
86133: LD_INT 4
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: PUSH
86140: LD_INT 3
86142: PUSH
86143: LD_INT 5
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: LIST
86154: PUSH
86155: LD_INT 24
86157: PUSH
86158: LD_INT 25
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 23
86167: PUSH
86168: LD_INT 27
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PUSH
86179: LD_INT 42
86181: PUSH
86182: LD_INT 43
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: PUSH
86189: LD_INT 44
86191: PUSH
86192: LD_INT 46
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: PUSH
86199: LD_INT 45
86201: PUSH
86202: LD_INT 47
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: EMPTY
86210: LIST
86211: LIST
86212: LIST
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: LIST
86218: ST_TO_ADDR
// result := [ ] ;
86219: LD_ADDR_VAR 0 3
86223: PUSH
86224: EMPTY
86225: ST_TO_ADDR
// for i in turrets do
86226: LD_ADDR_VAR 0 4
86230: PUSH
86231: LD_VAR 0 1
86235: PUSH
86236: FOR_IN
86237: IFFALSE 86420
// begin nat := GetNation ( i ) ;
86239: LD_ADDR_VAR 0 7
86243: PUSH
86244: LD_VAR 0 4
86248: PPUSH
86249: CALL_OW 248
86253: ST_TO_ADDR
// weapon := 0 ;
86254: LD_ADDR_VAR 0 8
86258: PUSH
86259: LD_INT 0
86261: ST_TO_ADDR
// if not nat then
86262: LD_VAR 0 7
86266: NOT
86267: IFFALSE 86271
// continue ;
86269: GO 86236
// for j in list [ nat ] do
86271: LD_ADDR_VAR 0 5
86275: PUSH
86276: LD_VAR 0 10
86280: PUSH
86281: LD_VAR 0 7
86285: ARRAY
86286: PUSH
86287: FOR_IN
86288: IFFALSE 86329
// if GetBWeapon ( i ) = j [ 1 ] then
86290: LD_VAR 0 4
86294: PPUSH
86295: CALL_OW 269
86299: PUSH
86300: LD_VAR 0 5
86304: PUSH
86305: LD_INT 1
86307: ARRAY
86308: EQUAL
86309: IFFALSE 86327
// begin weapon := j [ 2 ] ;
86311: LD_ADDR_VAR 0 8
86315: PUSH
86316: LD_VAR 0 5
86320: PUSH
86321: LD_INT 2
86323: ARRAY
86324: ST_TO_ADDR
// break ;
86325: GO 86329
// end ;
86327: GO 86287
86329: POP
86330: POP
// if not weapon then
86331: LD_VAR 0 8
86335: NOT
86336: IFFALSE 86340
// continue ;
86338: GO 86236
// for k in factories do
86340: LD_ADDR_VAR 0 6
86344: PUSH
86345: LD_VAR 0 2
86349: PUSH
86350: FOR_IN
86351: IFFALSE 86416
// begin weapons := AvailableWeaponList ( k ) ;
86353: LD_ADDR_VAR 0 9
86357: PUSH
86358: LD_VAR 0 6
86362: PPUSH
86363: CALL_OW 478
86367: ST_TO_ADDR
// if not weapons then
86368: LD_VAR 0 9
86372: NOT
86373: IFFALSE 86377
// continue ;
86375: GO 86350
// if weapon in weapons then
86377: LD_VAR 0 8
86381: PUSH
86382: LD_VAR 0 9
86386: IN
86387: IFFALSE 86414
// begin result := [ i , weapon ] ;
86389: LD_ADDR_VAR 0 3
86393: PUSH
86394: LD_VAR 0 4
86398: PUSH
86399: LD_VAR 0 8
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: ST_TO_ADDR
// exit ;
86408: POP
86409: POP
86410: POP
86411: POP
86412: GO 86422
// end ; end ;
86414: GO 86350
86416: POP
86417: POP
// end ;
86418: GO 86236
86420: POP
86421: POP
// end ;
86422: LD_VAR 0 3
86426: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86427: LD_INT 0
86429: PPUSH
// if not side or side > 8 then
86430: LD_VAR 0 3
86434: NOT
86435: PUSH
86436: LD_VAR 0 3
86440: PUSH
86441: LD_INT 8
86443: GREATER
86444: OR
86445: IFFALSE 86449
// exit ;
86447: GO 86508
// if not range then
86449: LD_VAR 0 4
86453: NOT
86454: IFFALSE 86465
// range := - 12 ;
86456: LD_ADDR_VAR 0 4
86460: PUSH
86461: LD_INT 12
86463: NEG
86464: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86465: LD_VAR 0 1
86469: PPUSH
86470: LD_VAR 0 2
86474: PPUSH
86475: LD_VAR 0 3
86479: PPUSH
86480: LD_VAR 0 4
86484: PPUSH
86485: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86489: LD_VAR 0 1
86493: PPUSH
86494: LD_VAR 0 2
86498: PPUSH
86499: LD_VAR 0 3
86503: PPUSH
86504: CALL_OW 331
// end ;
86508: LD_VAR 0 5
86512: RET
// export function Video ( mode ) ; begin
86513: LD_INT 0
86515: PPUSH
// ingame_video = mode ;
86516: LD_ADDR_OWVAR 52
86520: PUSH
86521: LD_VAR 0 1
86525: ST_TO_ADDR
// interface_hidden = mode ;
86526: LD_ADDR_OWVAR 54
86530: PUSH
86531: LD_VAR 0 1
86535: ST_TO_ADDR
// end ;
86536: LD_VAR 0 2
86540: RET
// export function Join ( array , element ) ; begin
86541: LD_INT 0
86543: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86544: LD_ADDR_VAR 0 3
86548: PUSH
86549: LD_VAR 0 1
86553: PPUSH
86554: LD_VAR 0 1
86558: PUSH
86559: LD_INT 1
86561: PLUS
86562: PPUSH
86563: LD_VAR 0 2
86567: PPUSH
86568: CALL_OW 1
86572: ST_TO_ADDR
// end ;
86573: LD_VAR 0 3
86577: RET
// export function JoinUnion ( array , element ) ; begin
86578: LD_INT 0
86580: PPUSH
// result := array union element ;
86581: LD_ADDR_VAR 0 3
86585: PUSH
86586: LD_VAR 0 1
86590: PUSH
86591: LD_VAR 0 2
86595: UNION
86596: ST_TO_ADDR
// end ;
86597: LD_VAR 0 3
86601: RET
// export function GetBehemoths ( side ) ; begin
86602: LD_INT 0
86604: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
86605: LD_ADDR_VAR 0 2
86609: PUSH
86610: LD_INT 22
86612: PUSH
86613: LD_VAR 0 1
86617: PUSH
86618: EMPTY
86619: LIST
86620: LIST
86621: PUSH
86622: LD_INT 31
86624: PUSH
86625: LD_INT 25
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PPUSH
86636: CALL_OW 69
86640: ST_TO_ADDR
// end ;
86641: LD_VAR 0 2
86645: RET
// export function Shuffle ( array ) ; var i , index ; begin
86646: LD_INT 0
86648: PPUSH
86649: PPUSH
86650: PPUSH
// result := [ ] ;
86651: LD_ADDR_VAR 0 2
86655: PUSH
86656: EMPTY
86657: ST_TO_ADDR
// if not array then
86658: LD_VAR 0 1
86662: NOT
86663: IFFALSE 86667
// exit ;
86665: GO 86766
// Randomize ;
86667: CALL_OW 10
// for i = array downto 1 do
86671: LD_ADDR_VAR 0 3
86675: PUSH
86676: DOUBLE
86677: LD_VAR 0 1
86681: INC
86682: ST_TO_ADDR
86683: LD_INT 1
86685: PUSH
86686: FOR_DOWNTO
86687: IFFALSE 86764
// begin index := rand ( 1 , array ) ;
86689: LD_ADDR_VAR 0 4
86693: PUSH
86694: LD_INT 1
86696: PPUSH
86697: LD_VAR 0 1
86701: PPUSH
86702: CALL_OW 12
86706: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86707: LD_ADDR_VAR 0 2
86711: PUSH
86712: LD_VAR 0 2
86716: PPUSH
86717: LD_VAR 0 2
86721: PUSH
86722: LD_INT 1
86724: PLUS
86725: PPUSH
86726: LD_VAR 0 1
86730: PUSH
86731: LD_VAR 0 4
86735: ARRAY
86736: PPUSH
86737: CALL_OW 2
86741: ST_TO_ADDR
// array := Delete ( array , index ) ;
86742: LD_ADDR_VAR 0 1
86746: PUSH
86747: LD_VAR 0 1
86751: PPUSH
86752: LD_VAR 0 4
86756: PPUSH
86757: CALL_OW 3
86761: ST_TO_ADDR
// end ;
86762: GO 86686
86764: POP
86765: POP
// end ;
86766: LD_VAR 0 2
86770: RET
// export function GetBaseMaterials ( base ) ; begin
86771: LD_INT 0
86773: PPUSH
// result := [ 0 , 0 , 0 ] ;
86774: LD_ADDR_VAR 0 2
86778: PUSH
86779: LD_INT 0
86781: PUSH
86782: LD_INT 0
86784: PUSH
86785: LD_INT 0
86787: PUSH
86788: EMPTY
86789: LIST
86790: LIST
86791: LIST
86792: ST_TO_ADDR
// if not base then
86793: LD_VAR 0 1
86797: NOT
86798: IFFALSE 86802
// exit ;
86800: GO 86851
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86802: LD_ADDR_VAR 0 2
86806: PUSH
86807: LD_VAR 0 1
86811: PPUSH
86812: LD_INT 1
86814: PPUSH
86815: CALL_OW 275
86819: PUSH
86820: LD_VAR 0 1
86824: PPUSH
86825: LD_INT 2
86827: PPUSH
86828: CALL_OW 275
86832: PUSH
86833: LD_VAR 0 1
86837: PPUSH
86838: LD_INT 3
86840: PPUSH
86841: CALL_OW 275
86845: PUSH
86846: EMPTY
86847: LIST
86848: LIST
86849: LIST
86850: ST_TO_ADDR
// end ;
86851: LD_VAR 0 2
86855: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86856: LD_INT 0
86858: PPUSH
86859: PPUSH
// result := array ;
86860: LD_ADDR_VAR 0 3
86864: PUSH
86865: LD_VAR 0 1
86869: ST_TO_ADDR
// if size > 0 then
86870: LD_VAR 0 2
86874: PUSH
86875: LD_INT 0
86877: GREATER
86878: IFFALSE 86924
// for i := array downto size do
86880: LD_ADDR_VAR 0 4
86884: PUSH
86885: DOUBLE
86886: LD_VAR 0 1
86890: INC
86891: ST_TO_ADDR
86892: LD_VAR 0 2
86896: PUSH
86897: FOR_DOWNTO
86898: IFFALSE 86922
// result := Delete ( result , result ) ;
86900: LD_ADDR_VAR 0 3
86904: PUSH
86905: LD_VAR 0 3
86909: PPUSH
86910: LD_VAR 0 3
86914: PPUSH
86915: CALL_OW 3
86919: ST_TO_ADDR
86920: GO 86897
86922: POP
86923: POP
// end ;
86924: LD_VAR 0 3
86928: RET
// export function ComExit ( unit ) ; var tmp ; begin
86929: LD_INT 0
86931: PPUSH
86932: PPUSH
// if not IsInUnit ( unit ) then
86933: LD_VAR 0 1
86937: PPUSH
86938: CALL_OW 310
86942: NOT
86943: IFFALSE 86947
// exit ;
86945: GO 87007
// tmp := IsInUnit ( unit ) ;
86947: LD_ADDR_VAR 0 3
86951: PUSH
86952: LD_VAR 0 1
86956: PPUSH
86957: CALL_OW 310
86961: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86962: LD_VAR 0 3
86966: PPUSH
86967: CALL_OW 247
86971: PUSH
86972: LD_INT 2
86974: EQUAL
86975: IFFALSE 86988
// ComExitVehicle ( unit ) else
86977: LD_VAR 0 1
86981: PPUSH
86982: CALL_OW 121
86986: GO 86997
// ComExitBuilding ( unit ) ;
86988: LD_VAR 0 1
86992: PPUSH
86993: CALL_OW 122
// result := tmp ;
86997: LD_ADDR_VAR 0 2
87001: PUSH
87002: LD_VAR 0 3
87006: ST_TO_ADDR
// end ;
87007: LD_VAR 0 2
87011: RET
// export function ResetHc ; begin
87012: LD_INT 0
87014: PPUSH
// InitHc ;
87015: CALL_OW 19
// hc_importance := 0 ;
87019: LD_ADDR_OWVAR 32
87023: PUSH
87024: LD_INT 0
87026: ST_TO_ADDR
// end ; end_of_file end_of_file
87027: LD_VAR 0 1
87031: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
87032: LD_VAR 0 2
87036: PUSH
87037: LD_INT 100
87039: EQUAL
87040: IFFALSE 87989
// begin if not StreamModeActive then
87042: LD_EXP 132
87046: NOT
87047: IFFALSE 87057
// StreamModeActive := true ;
87049: LD_ADDR_EXP 132
87053: PUSH
87054: LD_INT 1
87056: ST_TO_ADDR
// if p3 = 0 then
87057: LD_VAR 0 3
87061: PUSH
87062: LD_INT 0
87064: EQUAL
87065: IFFALSE 87071
// InitStreamMode ;
87067: CALL 88222 0 0
// if p3 = 1 then
87071: LD_VAR 0 3
87075: PUSH
87076: LD_INT 1
87078: EQUAL
87079: IFFALSE 87089
// sRocket := true ;
87081: LD_ADDR_EXP 137
87085: PUSH
87086: LD_INT 1
87088: ST_TO_ADDR
// if p3 = 2 then
87089: LD_VAR 0 3
87093: PUSH
87094: LD_INT 2
87096: EQUAL
87097: IFFALSE 87107
// sSpeed := true ;
87099: LD_ADDR_EXP 136
87103: PUSH
87104: LD_INT 1
87106: ST_TO_ADDR
// if p3 = 3 then
87107: LD_VAR 0 3
87111: PUSH
87112: LD_INT 3
87114: EQUAL
87115: IFFALSE 87125
// sEngine := true ;
87117: LD_ADDR_EXP 138
87121: PUSH
87122: LD_INT 1
87124: ST_TO_ADDR
// if p3 = 4 then
87125: LD_VAR 0 3
87129: PUSH
87130: LD_INT 4
87132: EQUAL
87133: IFFALSE 87143
// sSpec := true ;
87135: LD_ADDR_EXP 135
87139: PUSH
87140: LD_INT 1
87142: ST_TO_ADDR
// if p3 = 5 then
87143: LD_VAR 0 3
87147: PUSH
87148: LD_INT 5
87150: EQUAL
87151: IFFALSE 87161
// sLevel := true ;
87153: LD_ADDR_EXP 139
87157: PUSH
87158: LD_INT 1
87160: ST_TO_ADDR
// if p3 = 6 then
87161: LD_VAR 0 3
87165: PUSH
87166: LD_INT 6
87168: EQUAL
87169: IFFALSE 87179
// sArmoury := true ;
87171: LD_ADDR_EXP 140
87175: PUSH
87176: LD_INT 1
87178: ST_TO_ADDR
// if p3 = 7 then
87179: LD_VAR 0 3
87183: PUSH
87184: LD_INT 7
87186: EQUAL
87187: IFFALSE 87197
// sRadar := true ;
87189: LD_ADDR_EXP 141
87193: PUSH
87194: LD_INT 1
87196: ST_TO_ADDR
// if p3 = 8 then
87197: LD_VAR 0 3
87201: PUSH
87202: LD_INT 8
87204: EQUAL
87205: IFFALSE 87215
// sBunker := true ;
87207: LD_ADDR_EXP 142
87211: PUSH
87212: LD_INT 1
87214: ST_TO_ADDR
// if p3 = 9 then
87215: LD_VAR 0 3
87219: PUSH
87220: LD_INT 9
87222: EQUAL
87223: IFFALSE 87233
// sHack := true ;
87225: LD_ADDR_EXP 143
87229: PUSH
87230: LD_INT 1
87232: ST_TO_ADDR
// if p3 = 10 then
87233: LD_VAR 0 3
87237: PUSH
87238: LD_INT 10
87240: EQUAL
87241: IFFALSE 87251
// sFire := true ;
87243: LD_ADDR_EXP 144
87247: PUSH
87248: LD_INT 1
87250: ST_TO_ADDR
// if p3 = 11 then
87251: LD_VAR 0 3
87255: PUSH
87256: LD_INT 11
87258: EQUAL
87259: IFFALSE 87269
// sRefresh := true ;
87261: LD_ADDR_EXP 145
87265: PUSH
87266: LD_INT 1
87268: ST_TO_ADDR
// if p3 = 12 then
87269: LD_VAR 0 3
87273: PUSH
87274: LD_INT 12
87276: EQUAL
87277: IFFALSE 87287
// sExp := true ;
87279: LD_ADDR_EXP 146
87283: PUSH
87284: LD_INT 1
87286: ST_TO_ADDR
// if p3 = 13 then
87287: LD_VAR 0 3
87291: PUSH
87292: LD_INT 13
87294: EQUAL
87295: IFFALSE 87305
// sDepot := true ;
87297: LD_ADDR_EXP 147
87301: PUSH
87302: LD_INT 1
87304: ST_TO_ADDR
// if p3 = 14 then
87305: LD_VAR 0 3
87309: PUSH
87310: LD_INT 14
87312: EQUAL
87313: IFFALSE 87323
// sFlag := true ;
87315: LD_ADDR_EXP 148
87319: PUSH
87320: LD_INT 1
87322: ST_TO_ADDR
// if p3 = 15 then
87323: LD_VAR 0 3
87327: PUSH
87328: LD_INT 15
87330: EQUAL
87331: IFFALSE 87341
// sKamikadze := true ;
87333: LD_ADDR_EXP 156
87337: PUSH
87338: LD_INT 1
87340: ST_TO_ADDR
// if p3 = 16 then
87341: LD_VAR 0 3
87345: PUSH
87346: LD_INT 16
87348: EQUAL
87349: IFFALSE 87359
// sTroll := true ;
87351: LD_ADDR_EXP 157
87355: PUSH
87356: LD_INT 1
87358: ST_TO_ADDR
// if p3 = 17 then
87359: LD_VAR 0 3
87363: PUSH
87364: LD_INT 17
87366: EQUAL
87367: IFFALSE 87377
// sSlow := true ;
87369: LD_ADDR_EXP 158
87373: PUSH
87374: LD_INT 1
87376: ST_TO_ADDR
// if p3 = 18 then
87377: LD_VAR 0 3
87381: PUSH
87382: LD_INT 18
87384: EQUAL
87385: IFFALSE 87395
// sLack := true ;
87387: LD_ADDR_EXP 159
87391: PUSH
87392: LD_INT 1
87394: ST_TO_ADDR
// if p3 = 19 then
87395: LD_VAR 0 3
87399: PUSH
87400: LD_INT 19
87402: EQUAL
87403: IFFALSE 87413
// sTank := true ;
87405: LD_ADDR_EXP 161
87409: PUSH
87410: LD_INT 1
87412: ST_TO_ADDR
// if p3 = 20 then
87413: LD_VAR 0 3
87417: PUSH
87418: LD_INT 20
87420: EQUAL
87421: IFFALSE 87431
// sRemote := true ;
87423: LD_ADDR_EXP 162
87427: PUSH
87428: LD_INT 1
87430: ST_TO_ADDR
// if p3 = 21 then
87431: LD_VAR 0 3
87435: PUSH
87436: LD_INT 21
87438: EQUAL
87439: IFFALSE 87449
// sPowell := true ;
87441: LD_ADDR_EXP 163
87445: PUSH
87446: LD_INT 1
87448: ST_TO_ADDR
// if p3 = 22 then
87449: LD_VAR 0 3
87453: PUSH
87454: LD_INT 22
87456: EQUAL
87457: IFFALSE 87467
// sTeleport := true ;
87459: LD_ADDR_EXP 166
87463: PUSH
87464: LD_INT 1
87466: ST_TO_ADDR
// if p3 = 23 then
87467: LD_VAR 0 3
87471: PUSH
87472: LD_INT 23
87474: EQUAL
87475: IFFALSE 87485
// sOilTower := true ;
87477: LD_ADDR_EXP 168
87481: PUSH
87482: LD_INT 1
87484: ST_TO_ADDR
// if p3 = 24 then
87485: LD_VAR 0 3
87489: PUSH
87490: LD_INT 24
87492: EQUAL
87493: IFFALSE 87503
// sShovel := true ;
87495: LD_ADDR_EXP 169
87499: PUSH
87500: LD_INT 1
87502: ST_TO_ADDR
// if p3 = 25 then
87503: LD_VAR 0 3
87507: PUSH
87508: LD_INT 25
87510: EQUAL
87511: IFFALSE 87521
// sSheik := true ;
87513: LD_ADDR_EXP 170
87517: PUSH
87518: LD_INT 1
87520: ST_TO_ADDR
// if p3 = 26 then
87521: LD_VAR 0 3
87525: PUSH
87526: LD_INT 26
87528: EQUAL
87529: IFFALSE 87539
// sEarthquake := true ;
87531: LD_ADDR_EXP 172
87535: PUSH
87536: LD_INT 1
87538: ST_TO_ADDR
// if p3 = 27 then
87539: LD_VAR 0 3
87543: PUSH
87544: LD_INT 27
87546: EQUAL
87547: IFFALSE 87557
// sAI := true ;
87549: LD_ADDR_EXP 173
87553: PUSH
87554: LD_INT 1
87556: ST_TO_ADDR
// if p3 = 28 then
87557: LD_VAR 0 3
87561: PUSH
87562: LD_INT 28
87564: EQUAL
87565: IFFALSE 87575
// sCargo := true ;
87567: LD_ADDR_EXP 176
87571: PUSH
87572: LD_INT 1
87574: ST_TO_ADDR
// if p3 = 29 then
87575: LD_VAR 0 3
87579: PUSH
87580: LD_INT 29
87582: EQUAL
87583: IFFALSE 87593
// sDLaser := true ;
87585: LD_ADDR_EXP 177
87589: PUSH
87590: LD_INT 1
87592: ST_TO_ADDR
// if p3 = 30 then
87593: LD_VAR 0 3
87597: PUSH
87598: LD_INT 30
87600: EQUAL
87601: IFFALSE 87611
// sExchange := true ;
87603: LD_ADDR_EXP 178
87607: PUSH
87608: LD_INT 1
87610: ST_TO_ADDR
// if p3 = 31 then
87611: LD_VAR 0 3
87615: PUSH
87616: LD_INT 31
87618: EQUAL
87619: IFFALSE 87629
// sFac := true ;
87621: LD_ADDR_EXP 179
87625: PUSH
87626: LD_INT 1
87628: ST_TO_ADDR
// if p3 = 32 then
87629: LD_VAR 0 3
87633: PUSH
87634: LD_INT 32
87636: EQUAL
87637: IFFALSE 87647
// sPower := true ;
87639: LD_ADDR_EXP 180
87643: PUSH
87644: LD_INT 1
87646: ST_TO_ADDR
// if p3 = 33 then
87647: LD_VAR 0 3
87651: PUSH
87652: LD_INT 33
87654: EQUAL
87655: IFFALSE 87665
// sRandom := true ;
87657: LD_ADDR_EXP 181
87661: PUSH
87662: LD_INT 1
87664: ST_TO_ADDR
// if p3 = 34 then
87665: LD_VAR 0 3
87669: PUSH
87670: LD_INT 34
87672: EQUAL
87673: IFFALSE 87683
// sShield := true ;
87675: LD_ADDR_EXP 182
87679: PUSH
87680: LD_INT 1
87682: ST_TO_ADDR
// if p3 = 35 then
87683: LD_VAR 0 3
87687: PUSH
87688: LD_INT 35
87690: EQUAL
87691: IFFALSE 87701
// sTime := true ;
87693: LD_ADDR_EXP 183
87697: PUSH
87698: LD_INT 1
87700: ST_TO_ADDR
// if p3 = 36 then
87701: LD_VAR 0 3
87705: PUSH
87706: LD_INT 36
87708: EQUAL
87709: IFFALSE 87719
// sTools := true ;
87711: LD_ADDR_EXP 184
87715: PUSH
87716: LD_INT 1
87718: ST_TO_ADDR
// if p3 = 101 then
87719: LD_VAR 0 3
87723: PUSH
87724: LD_INT 101
87726: EQUAL
87727: IFFALSE 87737
// sSold := true ;
87729: LD_ADDR_EXP 149
87733: PUSH
87734: LD_INT 1
87736: ST_TO_ADDR
// if p3 = 102 then
87737: LD_VAR 0 3
87741: PUSH
87742: LD_INT 102
87744: EQUAL
87745: IFFALSE 87755
// sDiff := true ;
87747: LD_ADDR_EXP 150
87751: PUSH
87752: LD_INT 1
87754: ST_TO_ADDR
// if p3 = 103 then
87755: LD_VAR 0 3
87759: PUSH
87760: LD_INT 103
87762: EQUAL
87763: IFFALSE 87773
// sFog := true ;
87765: LD_ADDR_EXP 153
87769: PUSH
87770: LD_INT 1
87772: ST_TO_ADDR
// if p3 = 104 then
87773: LD_VAR 0 3
87777: PUSH
87778: LD_INT 104
87780: EQUAL
87781: IFFALSE 87791
// sReset := true ;
87783: LD_ADDR_EXP 154
87787: PUSH
87788: LD_INT 1
87790: ST_TO_ADDR
// if p3 = 105 then
87791: LD_VAR 0 3
87795: PUSH
87796: LD_INT 105
87798: EQUAL
87799: IFFALSE 87809
// sSun := true ;
87801: LD_ADDR_EXP 155
87805: PUSH
87806: LD_INT 1
87808: ST_TO_ADDR
// if p3 = 106 then
87809: LD_VAR 0 3
87813: PUSH
87814: LD_INT 106
87816: EQUAL
87817: IFFALSE 87827
// sTiger := true ;
87819: LD_ADDR_EXP 151
87823: PUSH
87824: LD_INT 1
87826: ST_TO_ADDR
// if p3 = 107 then
87827: LD_VAR 0 3
87831: PUSH
87832: LD_INT 107
87834: EQUAL
87835: IFFALSE 87845
// sBomb := true ;
87837: LD_ADDR_EXP 152
87841: PUSH
87842: LD_INT 1
87844: ST_TO_ADDR
// if p3 = 108 then
87845: LD_VAR 0 3
87849: PUSH
87850: LD_INT 108
87852: EQUAL
87853: IFFALSE 87863
// sWound := true ;
87855: LD_ADDR_EXP 160
87859: PUSH
87860: LD_INT 1
87862: ST_TO_ADDR
// if p3 = 109 then
87863: LD_VAR 0 3
87867: PUSH
87868: LD_INT 109
87870: EQUAL
87871: IFFALSE 87881
// sBetray := true ;
87873: LD_ADDR_EXP 164
87877: PUSH
87878: LD_INT 1
87880: ST_TO_ADDR
// if p3 = 110 then
87881: LD_VAR 0 3
87885: PUSH
87886: LD_INT 110
87888: EQUAL
87889: IFFALSE 87899
// sContamin := true ;
87891: LD_ADDR_EXP 165
87895: PUSH
87896: LD_INT 1
87898: ST_TO_ADDR
// if p3 = 111 then
87899: LD_VAR 0 3
87903: PUSH
87904: LD_INT 111
87906: EQUAL
87907: IFFALSE 87917
// sOil := true ;
87909: LD_ADDR_EXP 167
87913: PUSH
87914: LD_INT 1
87916: ST_TO_ADDR
// if p3 = 112 then
87917: LD_VAR 0 3
87921: PUSH
87922: LD_INT 112
87924: EQUAL
87925: IFFALSE 87935
// sStu := true ;
87927: LD_ADDR_EXP 171
87931: PUSH
87932: LD_INT 1
87934: ST_TO_ADDR
// if p3 = 113 then
87935: LD_VAR 0 3
87939: PUSH
87940: LD_INT 113
87942: EQUAL
87943: IFFALSE 87953
// sBazooka := true ;
87945: LD_ADDR_EXP 174
87949: PUSH
87950: LD_INT 1
87952: ST_TO_ADDR
// if p3 = 114 then
87953: LD_VAR 0 3
87957: PUSH
87958: LD_INT 114
87960: EQUAL
87961: IFFALSE 87971
// sMortar := true ;
87963: LD_ADDR_EXP 175
87967: PUSH
87968: LD_INT 1
87970: ST_TO_ADDR
// if p3 = 115 then
87971: LD_VAR 0 3
87975: PUSH
87976: LD_INT 115
87978: EQUAL
87979: IFFALSE 87989
// sRanger := true ;
87981: LD_ADDR_EXP 185
87985: PUSH
87986: LD_INT 1
87988: ST_TO_ADDR
// end ; if p2 = 101 then
87989: LD_VAR 0 2
87993: PUSH
87994: LD_INT 101
87996: EQUAL
87997: IFFALSE 88200
// begin case p3 of 1 :
87999: LD_VAR 0 3
88003: PUSH
88004: LD_INT 1
88006: DOUBLE
88007: EQUAL
88008: IFTRUE 88012
88010: GO 88019
88012: POP
// hHackUnlimitedResources ; 2 :
88013: CALL 98294 0 0
88017: GO 88200
88019: LD_INT 2
88021: DOUBLE
88022: EQUAL
88023: IFTRUE 88027
88025: GO 88034
88027: POP
// hHackSetLevel10 ; 3 :
88028: CALL 98427 0 0
88032: GO 88200
88034: LD_INT 3
88036: DOUBLE
88037: EQUAL
88038: IFTRUE 88042
88040: GO 88049
88042: POP
// hHackSetLevel10YourUnits ; 4 :
88043: CALL 98512 0 0
88047: GO 88200
88049: LD_INT 4
88051: DOUBLE
88052: EQUAL
88053: IFTRUE 88057
88055: GO 88079
88057: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
88058: LD_VAR 0 4
88062: PPUSH
88063: LD_VAR 0 5
88067: PPUSH
88068: LD_VAR 0 6
88072: PPUSH
88073: CALL 98602 0 3
88077: GO 88200
88079: LD_INT 5
88081: DOUBLE
88082: EQUAL
88083: IFTRUE 88087
88085: GO 88094
88087: POP
// hHackSpawnVehicle ; 6 :
88088: CALL 98663 0 0
88092: GO 88200
88094: LD_INT 6
88096: DOUBLE
88097: EQUAL
88098: IFTRUE 88102
88100: GO 88109
88102: POP
// hHackInvincible ; 7 :
88103: CALL 99209 0 0
88107: GO 88200
88109: LD_INT 7
88111: DOUBLE
88112: EQUAL
88113: IFTRUE 88117
88115: GO 88124
88117: POP
// hHackInvisible ; 8 :
88118: CALL 99320 0 0
88122: GO 88200
88124: LD_INT 8
88126: DOUBLE
88127: EQUAL
88128: IFTRUE 88132
88130: GO 88139
88132: POP
// hHackChangeYourSide ; 9 :
88133: CALL 99377 0 0
88137: GO 88200
88139: LD_INT 9
88141: DOUBLE
88142: EQUAL
88143: IFTRUE 88147
88145: GO 88154
88147: POP
// hHackChangeUnitSide ; 10 :
88148: CALL 99419 0 0
88152: GO 88200
88154: LD_INT 10
88156: DOUBLE
88157: EQUAL
88158: IFTRUE 88162
88160: GO 88169
88162: POP
// hHackFog ; 11 :
88163: CALL 99520 0 0
88167: GO 88200
88169: LD_INT 11
88171: DOUBLE
88172: EQUAL
88173: IFTRUE 88177
88175: GO 88184
88177: POP
// hHackApeman ; 12 :
88178: CALL 99535 0 0
88182: GO 88200
88184: LD_INT 12
88186: DOUBLE
88187: EQUAL
88188: IFTRUE 88192
88190: GO 88199
88192: POP
// hHackBoom ; end ;
88193: CALL 99620 0 0
88197: GO 88200
88199: POP
// end ; end ;
88200: PPOPN 6
88202: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
88203: GO 88205
88205: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
88206: LD_STRING initStreamRollete();
88208: PPUSH
88209: CALL_OW 559
// InitStreamMode ;
88213: CALL 88222 0 0
// DefineStreamItems ( ) ;
88217: CALL 88662 0 0
// end ;
88221: END
// function InitStreamMode ; begin
88222: LD_INT 0
88224: PPUSH
// streamModeActive := false ;
88225: LD_ADDR_EXP 132
88229: PUSH
88230: LD_INT 0
88232: ST_TO_ADDR
// normalCounter := 36 ;
88233: LD_ADDR_EXP 133
88237: PUSH
88238: LD_INT 36
88240: ST_TO_ADDR
// hardcoreCounter := 16 ;
88241: LD_ADDR_EXP 134
88245: PUSH
88246: LD_INT 16
88248: ST_TO_ADDR
// sRocket := false ;
88249: LD_ADDR_EXP 137
88253: PUSH
88254: LD_INT 0
88256: ST_TO_ADDR
// sSpeed := false ;
88257: LD_ADDR_EXP 136
88261: PUSH
88262: LD_INT 0
88264: ST_TO_ADDR
// sEngine := false ;
88265: LD_ADDR_EXP 138
88269: PUSH
88270: LD_INT 0
88272: ST_TO_ADDR
// sSpec := false ;
88273: LD_ADDR_EXP 135
88277: PUSH
88278: LD_INT 0
88280: ST_TO_ADDR
// sLevel := false ;
88281: LD_ADDR_EXP 139
88285: PUSH
88286: LD_INT 0
88288: ST_TO_ADDR
// sArmoury := false ;
88289: LD_ADDR_EXP 140
88293: PUSH
88294: LD_INT 0
88296: ST_TO_ADDR
// sRadar := false ;
88297: LD_ADDR_EXP 141
88301: PUSH
88302: LD_INT 0
88304: ST_TO_ADDR
// sBunker := false ;
88305: LD_ADDR_EXP 142
88309: PUSH
88310: LD_INT 0
88312: ST_TO_ADDR
// sHack := false ;
88313: LD_ADDR_EXP 143
88317: PUSH
88318: LD_INT 0
88320: ST_TO_ADDR
// sFire := false ;
88321: LD_ADDR_EXP 144
88325: PUSH
88326: LD_INT 0
88328: ST_TO_ADDR
// sRefresh := false ;
88329: LD_ADDR_EXP 145
88333: PUSH
88334: LD_INT 0
88336: ST_TO_ADDR
// sExp := false ;
88337: LD_ADDR_EXP 146
88341: PUSH
88342: LD_INT 0
88344: ST_TO_ADDR
// sDepot := false ;
88345: LD_ADDR_EXP 147
88349: PUSH
88350: LD_INT 0
88352: ST_TO_ADDR
// sFlag := false ;
88353: LD_ADDR_EXP 148
88357: PUSH
88358: LD_INT 0
88360: ST_TO_ADDR
// sKamikadze := false ;
88361: LD_ADDR_EXP 156
88365: PUSH
88366: LD_INT 0
88368: ST_TO_ADDR
// sTroll := false ;
88369: LD_ADDR_EXP 157
88373: PUSH
88374: LD_INT 0
88376: ST_TO_ADDR
// sSlow := false ;
88377: LD_ADDR_EXP 158
88381: PUSH
88382: LD_INT 0
88384: ST_TO_ADDR
// sLack := false ;
88385: LD_ADDR_EXP 159
88389: PUSH
88390: LD_INT 0
88392: ST_TO_ADDR
// sTank := false ;
88393: LD_ADDR_EXP 161
88397: PUSH
88398: LD_INT 0
88400: ST_TO_ADDR
// sRemote := false ;
88401: LD_ADDR_EXP 162
88405: PUSH
88406: LD_INT 0
88408: ST_TO_ADDR
// sPowell := false ;
88409: LD_ADDR_EXP 163
88413: PUSH
88414: LD_INT 0
88416: ST_TO_ADDR
// sTeleport := false ;
88417: LD_ADDR_EXP 166
88421: PUSH
88422: LD_INT 0
88424: ST_TO_ADDR
// sOilTower := false ;
88425: LD_ADDR_EXP 168
88429: PUSH
88430: LD_INT 0
88432: ST_TO_ADDR
// sShovel := false ;
88433: LD_ADDR_EXP 169
88437: PUSH
88438: LD_INT 0
88440: ST_TO_ADDR
// sSheik := false ;
88441: LD_ADDR_EXP 170
88445: PUSH
88446: LD_INT 0
88448: ST_TO_ADDR
// sEarthquake := false ;
88449: LD_ADDR_EXP 172
88453: PUSH
88454: LD_INT 0
88456: ST_TO_ADDR
// sAI := false ;
88457: LD_ADDR_EXP 173
88461: PUSH
88462: LD_INT 0
88464: ST_TO_ADDR
// sCargo := false ;
88465: LD_ADDR_EXP 176
88469: PUSH
88470: LD_INT 0
88472: ST_TO_ADDR
// sDLaser := false ;
88473: LD_ADDR_EXP 177
88477: PUSH
88478: LD_INT 0
88480: ST_TO_ADDR
// sExchange := false ;
88481: LD_ADDR_EXP 178
88485: PUSH
88486: LD_INT 0
88488: ST_TO_ADDR
// sFac := false ;
88489: LD_ADDR_EXP 179
88493: PUSH
88494: LD_INT 0
88496: ST_TO_ADDR
// sPower := false ;
88497: LD_ADDR_EXP 180
88501: PUSH
88502: LD_INT 0
88504: ST_TO_ADDR
// sRandom := false ;
88505: LD_ADDR_EXP 181
88509: PUSH
88510: LD_INT 0
88512: ST_TO_ADDR
// sShield := false ;
88513: LD_ADDR_EXP 182
88517: PUSH
88518: LD_INT 0
88520: ST_TO_ADDR
// sTime := false ;
88521: LD_ADDR_EXP 183
88525: PUSH
88526: LD_INT 0
88528: ST_TO_ADDR
// sTools := false ;
88529: LD_ADDR_EXP 184
88533: PUSH
88534: LD_INT 0
88536: ST_TO_ADDR
// sSold := false ;
88537: LD_ADDR_EXP 149
88541: PUSH
88542: LD_INT 0
88544: ST_TO_ADDR
// sDiff := false ;
88545: LD_ADDR_EXP 150
88549: PUSH
88550: LD_INT 0
88552: ST_TO_ADDR
// sFog := false ;
88553: LD_ADDR_EXP 153
88557: PUSH
88558: LD_INT 0
88560: ST_TO_ADDR
// sReset := false ;
88561: LD_ADDR_EXP 154
88565: PUSH
88566: LD_INT 0
88568: ST_TO_ADDR
// sSun := false ;
88569: LD_ADDR_EXP 155
88573: PUSH
88574: LD_INT 0
88576: ST_TO_ADDR
// sTiger := false ;
88577: LD_ADDR_EXP 151
88581: PUSH
88582: LD_INT 0
88584: ST_TO_ADDR
// sBomb := false ;
88585: LD_ADDR_EXP 152
88589: PUSH
88590: LD_INT 0
88592: ST_TO_ADDR
// sWound := false ;
88593: LD_ADDR_EXP 160
88597: PUSH
88598: LD_INT 0
88600: ST_TO_ADDR
// sBetray := false ;
88601: LD_ADDR_EXP 164
88605: PUSH
88606: LD_INT 0
88608: ST_TO_ADDR
// sContamin := false ;
88609: LD_ADDR_EXP 165
88613: PUSH
88614: LD_INT 0
88616: ST_TO_ADDR
// sOil := false ;
88617: LD_ADDR_EXP 167
88621: PUSH
88622: LD_INT 0
88624: ST_TO_ADDR
// sStu := false ;
88625: LD_ADDR_EXP 171
88629: PUSH
88630: LD_INT 0
88632: ST_TO_ADDR
// sBazooka := false ;
88633: LD_ADDR_EXP 174
88637: PUSH
88638: LD_INT 0
88640: ST_TO_ADDR
// sMortar := false ;
88641: LD_ADDR_EXP 175
88645: PUSH
88646: LD_INT 0
88648: ST_TO_ADDR
// sRanger := false ;
88649: LD_ADDR_EXP 185
88653: PUSH
88654: LD_INT 0
88656: ST_TO_ADDR
// end ;
88657: LD_VAR 0 1
88661: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
88662: LD_INT 0
88664: PPUSH
88665: PPUSH
88666: PPUSH
88667: PPUSH
88668: PPUSH
// result := [ ] ;
88669: LD_ADDR_VAR 0 1
88673: PUSH
88674: EMPTY
88675: ST_TO_ADDR
// if campaign_id = 1 then
88676: LD_OWVAR 69
88680: PUSH
88681: LD_INT 1
88683: EQUAL
88684: IFFALSE 91622
// begin case mission_number of 1 :
88686: LD_OWVAR 70
88690: PUSH
88691: LD_INT 1
88693: DOUBLE
88694: EQUAL
88695: IFTRUE 88699
88697: GO 88763
88699: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
88700: LD_ADDR_VAR 0 1
88704: PUSH
88705: LD_INT 2
88707: PUSH
88708: LD_INT 4
88710: PUSH
88711: LD_INT 11
88713: PUSH
88714: LD_INT 12
88716: PUSH
88717: LD_INT 15
88719: PUSH
88720: LD_INT 16
88722: PUSH
88723: LD_INT 22
88725: PUSH
88726: LD_INT 23
88728: PUSH
88729: LD_INT 26
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 101
88745: PUSH
88746: LD_INT 102
88748: PUSH
88749: LD_INT 106
88751: PUSH
88752: EMPTY
88753: LIST
88754: LIST
88755: LIST
88756: PUSH
88757: EMPTY
88758: LIST
88759: LIST
88760: ST_TO_ADDR
88761: GO 91620
88763: LD_INT 2
88765: DOUBLE
88766: EQUAL
88767: IFTRUE 88771
88769: GO 88843
88771: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
88772: LD_ADDR_VAR 0 1
88776: PUSH
88777: LD_INT 2
88779: PUSH
88780: LD_INT 4
88782: PUSH
88783: LD_INT 11
88785: PUSH
88786: LD_INT 12
88788: PUSH
88789: LD_INT 15
88791: PUSH
88792: LD_INT 16
88794: PUSH
88795: LD_INT 22
88797: PUSH
88798: LD_INT 23
88800: PUSH
88801: LD_INT 26
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 101
88817: PUSH
88818: LD_INT 102
88820: PUSH
88821: LD_INT 105
88823: PUSH
88824: LD_INT 106
88826: PUSH
88827: LD_INT 108
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: ST_TO_ADDR
88841: GO 91620
88843: LD_INT 3
88845: DOUBLE
88846: EQUAL
88847: IFTRUE 88851
88849: GO 88927
88851: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
88852: LD_ADDR_VAR 0 1
88856: PUSH
88857: LD_INT 2
88859: PUSH
88860: LD_INT 4
88862: PUSH
88863: LD_INT 5
88865: PUSH
88866: LD_INT 11
88868: PUSH
88869: LD_INT 12
88871: PUSH
88872: LD_INT 15
88874: PUSH
88875: LD_INT 16
88877: PUSH
88878: LD_INT 22
88880: PUSH
88881: LD_INT 26
88883: PUSH
88884: LD_INT 36
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: LIST
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 101
88901: PUSH
88902: LD_INT 102
88904: PUSH
88905: LD_INT 105
88907: PUSH
88908: LD_INT 106
88910: PUSH
88911: LD_INT 108
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: ST_TO_ADDR
88925: GO 91620
88927: LD_INT 4
88929: DOUBLE
88930: EQUAL
88931: IFTRUE 88935
88933: GO 89019
88935: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
88936: LD_ADDR_VAR 0 1
88940: PUSH
88941: LD_INT 2
88943: PUSH
88944: LD_INT 4
88946: PUSH
88947: LD_INT 5
88949: PUSH
88950: LD_INT 8
88952: PUSH
88953: LD_INT 11
88955: PUSH
88956: LD_INT 12
88958: PUSH
88959: LD_INT 15
88961: PUSH
88962: LD_INT 16
88964: PUSH
88965: LD_INT 22
88967: PUSH
88968: LD_INT 23
88970: PUSH
88971: LD_INT 26
88973: PUSH
88974: LD_INT 36
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: PUSH
88991: LD_INT 101
88993: PUSH
88994: LD_INT 102
88996: PUSH
88997: LD_INT 105
88999: PUSH
89000: LD_INT 106
89002: PUSH
89003: LD_INT 108
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: LIST
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: ST_TO_ADDR
89017: GO 91620
89019: LD_INT 5
89021: DOUBLE
89022: EQUAL
89023: IFTRUE 89027
89025: GO 89127
89027: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
89028: LD_ADDR_VAR 0 1
89032: PUSH
89033: LD_INT 2
89035: PUSH
89036: LD_INT 4
89038: PUSH
89039: LD_INT 5
89041: PUSH
89042: LD_INT 6
89044: PUSH
89045: LD_INT 8
89047: PUSH
89048: LD_INT 11
89050: PUSH
89051: LD_INT 12
89053: PUSH
89054: LD_INT 15
89056: PUSH
89057: LD_INT 16
89059: PUSH
89060: LD_INT 22
89062: PUSH
89063: LD_INT 23
89065: PUSH
89066: LD_INT 25
89068: PUSH
89069: LD_INT 26
89071: PUSH
89072: LD_INT 36
89074: PUSH
89075: EMPTY
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 101
89093: PUSH
89094: LD_INT 102
89096: PUSH
89097: LD_INT 105
89099: PUSH
89100: LD_INT 106
89102: PUSH
89103: LD_INT 108
89105: PUSH
89106: LD_INT 109
89108: PUSH
89109: LD_INT 112
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: ST_TO_ADDR
89125: GO 91620
89127: LD_INT 6
89129: DOUBLE
89130: EQUAL
89131: IFTRUE 89135
89133: GO 89255
89135: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
89136: LD_ADDR_VAR 0 1
89140: PUSH
89141: LD_INT 2
89143: PUSH
89144: LD_INT 4
89146: PUSH
89147: LD_INT 5
89149: PUSH
89150: LD_INT 6
89152: PUSH
89153: LD_INT 8
89155: PUSH
89156: LD_INT 11
89158: PUSH
89159: LD_INT 12
89161: PUSH
89162: LD_INT 15
89164: PUSH
89165: LD_INT 16
89167: PUSH
89168: LD_INT 20
89170: PUSH
89171: LD_INT 21
89173: PUSH
89174: LD_INT 22
89176: PUSH
89177: LD_INT 23
89179: PUSH
89180: LD_INT 25
89182: PUSH
89183: LD_INT 26
89185: PUSH
89186: LD_INT 30
89188: PUSH
89189: LD_INT 31
89191: PUSH
89192: LD_INT 32
89194: PUSH
89195: LD_INT 36
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: PUSH
89219: LD_INT 101
89221: PUSH
89222: LD_INT 102
89224: PUSH
89225: LD_INT 105
89227: PUSH
89228: LD_INT 106
89230: PUSH
89231: LD_INT 108
89233: PUSH
89234: LD_INT 109
89236: PUSH
89237: LD_INT 112
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: ST_TO_ADDR
89253: GO 91620
89255: LD_INT 7
89257: DOUBLE
89258: EQUAL
89259: IFTRUE 89263
89261: GO 89363
89263: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
89264: LD_ADDR_VAR 0 1
89268: PUSH
89269: LD_INT 2
89271: PUSH
89272: LD_INT 4
89274: PUSH
89275: LD_INT 5
89277: PUSH
89278: LD_INT 7
89280: PUSH
89281: LD_INT 11
89283: PUSH
89284: LD_INT 12
89286: PUSH
89287: LD_INT 15
89289: PUSH
89290: LD_INT 16
89292: PUSH
89293: LD_INT 20
89295: PUSH
89296: LD_INT 21
89298: PUSH
89299: LD_INT 22
89301: PUSH
89302: LD_INT 23
89304: PUSH
89305: LD_INT 25
89307: PUSH
89308: LD_INT 26
89310: PUSH
89311: EMPTY
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: LIST
89326: PUSH
89327: LD_INT 101
89329: PUSH
89330: LD_INT 102
89332: PUSH
89333: LD_INT 103
89335: PUSH
89336: LD_INT 105
89338: PUSH
89339: LD_INT 106
89341: PUSH
89342: LD_INT 108
89344: PUSH
89345: LD_INT 112
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: ST_TO_ADDR
89361: GO 91620
89363: LD_INT 8
89365: DOUBLE
89366: EQUAL
89367: IFTRUE 89371
89369: GO 89499
89371: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
89372: LD_ADDR_VAR 0 1
89376: PUSH
89377: LD_INT 2
89379: PUSH
89380: LD_INT 4
89382: PUSH
89383: LD_INT 5
89385: PUSH
89386: LD_INT 6
89388: PUSH
89389: LD_INT 7
89391: PUSH
89392: LD_INT 8
89394: PUSH
89395: LD_INT 11
89397: PUSH
89398: LD_INT 12
89400: PUSH
89401: LD_INT 15
89403: PUSH
89404: LD_INT 16
89406: PUSH
89407: LD_INT 20
89409: PUSH
89410: LD_INT 21
89412: PUSH
89413: LD_INT 22
89415: PUSH
89416: LD_INT 23
89418: PUSH
89419: LD_INT 25
89421: PUSH
89422: LD_INT 26
89424: PUSH
89425: LD_INT 30
89427: PUSH
89428: LD_INT 31
89430: PUSH
89431: LD_INT 32
89433: PUSH
89434: LD_INT 36
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: LIST
89441: LIST
89442: LIST
89443: LIST
89444: LIST
89445: LIST
89446: LIST
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: LIST
89455: LIST
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 101
89461: PUSH
89462: LD_INT 102
89464: PUSH
89465: LD_INT 103
89467: PUSH
89468: LD_INT 105
89470: PUSH
89471: LD_INT 106
89473: PUSH
89474: LD_INT 108
89476: PUSH
89477: LD_INT 109
89479: PUSH
89480: LD_INT 112
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: PUSH
89493: EMPTY
89494: LIST
89495: LIST
89496: ST_TO_ADDR
89497: GO 91620
89499: LD_INT 9
89501: DOUBLE
89502: EQUAL
89503: IFTRUE 89507
89505: GO 89643
89507: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
89508: LD_ADDR_VAR 0 1
89512: PUSH
89513: LD_INT 2
89515: PUSH
89516: LD_INT 4
89518: PUSH
89519: LD_INT 5
89521: PUSH
89522: LD_INT 6
89524: PUSH
89525: LD_INT 7
89527: PUSH
89528: LD_INT 8
89530: PUSH
89531: LD_INT 11
89533: PUSH
89534: LD_INT 12
89536: PUSH
89537: LD_INT 15
89539: PUSH
89540: LD_INT 16
89542: PUSH
89543: LD_INT 20
89545: PUSH
89546: LD_INT 21
89548: PUSH
89549: LD_INT 22
89551: PUSH
89552: LD_INT 23
89554: PUSH
89555: LD_INT 25
89557: PUSH
89558: LD_INT 26
89560: PUSH
89561: LD_INT 28
89563: PUSH
89564: LD_INT 30
89566: PUSH
89567: LD_INT 31
89569: PUSH
89570: LD_INT 32
89572: PUSH
89573: LD_INT 36
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 101
89601: PUSH
89602: LD_INT 102
89604: PUSH
89605: LD_INT 103
89607: PUSH
89608: LD_INT 105
89610: PUSH
89611: LD_INT 106
89613: PUSH
89614: LD_INT 108
89616: PUSH
89617: LD_INT 109
89619: PUSH
89620: LD_INT 112
89622: PUSH
89623: LD_INT 114
89625: PUSH
89626: EMPTY
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: PUSH
89637: EMPTY
89638: LIST
89639: LIST
89640: ST_TO_ADDR
89641: GO 91620
89643: LD_INT 10
89645: DOUBLE
89646: EQUAL
89647: IFTRUE 89651
89649: GO 89835
89651: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
89652: LD_ADDR_VAR 0 1
89656: PUSH
89657: LD_INT 2
89659: PUSH
89660: LD_INT 4
89662: PUSH
89663: LD_INT 5
89665: PUSH
89666: LD_INT 6
89668: PUSH
89669: LD_INT 7
89671: PUSH
89672: LD_INT 8
89674: PUSH
89675: LD_INT 9
89677: PUSH
89678: LD_INT 10
89680: PUSH
89681: LD_INT 11
89683: PUSH
89684: LD_INT 12
89686: PUSH
89687: LD_INT 13
89689: PUSH
89690: LD_INT 14
89692: PUSH
89693: LD_INT 15
89695: PUSH
89696: LD_INT 16
89698: PUSH
89699: LD_INT 17
89701: PUSH
89702: LD_INT 18
89704: PUSH
89705: LD_INT 19
89707: PUSH
89708: LD_INT 20
89710: PUSH
89711: LD_INT 21
89713: PUSH
89714: LD_INT 22
89716: PUSH
89717: LD_INT 23
89719: PUSH
89720: LD_INT 24
89722: PUSH
89723: LD_INT 25
89725: PUSH
89726: LD_INT 26
89728: PUSH
89729: LD_INT 28
89731: PUSH
89732: LD_INT 30
89734: PUSH
89735: LD_INT 31
89737: PUSH
89738: LD_INT 32
89740: PUSH
89741: LD_INT 36
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: LIST
89751: LIST
89752: LIST
89753: LIST
89754: LIST
89755: LIST
89756: LIST
89757: LIST
89758: LIST
89759: LIST
89760: LIST
89761: LIST
89762: LIST
89763: LIST
89764: LIST
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: PUSH
89775: LD_INT 101
89777: PUSH
89778: LD_INT 102
89780: PUSH
89781: LD_INT 103
89783: PUSH
89784: LD_INT 104
89786: PUSH
89787: LD_INT 105
89789: PUSH
89790: LD_INT 106
89792: PUSH
89793: LD_INT 107
89795: PUSH
89796: LD_INT 108
89798: PUSH
89799: LD_INT 109
89801: PUSH
89802: LD_INT 110
89804: PUSH
89805: LD_INT 111
89807: PUSH
89808: LD_INT 112
89810: PUSH
89811: LD_INT 114
89813: PUSH
89814: EMPTY
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: LIST
89823: LIST
89824: LIST
89825: LIST
89826: LIST
89827: LIST
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: ST_TO_ADDR
89833: GO 91620
89835: LD_INT 11
89837: DOUBLE
89838: EQUAL
89839: IFTRUE 89843
89841: GO 90035
89843: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
89844: LD_ADDR_VAR 0 1
89848: PUSH
89849: LD_INT 2
89851: PUSH
89852: LD_INT 3
89854: PUSH
89855: LD_INT 4
89857: PUSH
89858: LD_INT 5
89860: PUSH
89861: LD_INT 6
89863: PUSH
89864: LD_INT 7
89866: PUSH
89867: LD_INT 8
89869: PUSH
89870: LD_INT 9
89872: PUSH
89873: LD_INT 10
89875: PUSH
89876: LD_INT 11
89878: PUSH
89879: LD_INT 12
89881: PUSH
89882: LD_INT 13
89884: PUSH
89885: LD_INT 14
89887: PUSH
89888: LD_INT 15
89890: PUSH
89891: LD_INT 16
89893: PUSH
89894: LD_INT 17
89896: PUSH
89897: LD_INT 18
89899: PUSH
89900: LD_INT 19
89902: PUSH
89903: LD_INT 20
89905: PUSH
89906: LD_INT 21
89908: PUSH
89909: LD_INT 22
89911: PUSH
89912: LD_INT 23
89914: PUSH
89915: LD_INT 24
89917: PUSH
89918: LD_INT 25
89920: PUSH
89921: LD_INT 26
89923: PUSH
89924: LD_INT 28
89926: PUSH
89927: LD_INT 30
89929: PUSH
89930: LD_INT 31
89932: PUSH
89933: LD_INT 32
89935: PUSH
89936: LD_INT 34
89938: PUSH
89939: LD_INT 36
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: PUSH
89975: LD_INT 101
89977: PUSH
89978: LD_INT 102
89980: PUSH
89981: LD_INT 103
89983: PUSH
89984: LD_INT 104
89986: PUSH
89987: LD_INT 105
89989: PUSH
89990: LD_INT 106
89992: PUSH
89993: LD_INT 107
89995: PUSH
89996: LD_INT 108
89998: PUSH
89999: LD_INT 109
90001: PUSH
90002: LD_INT 110
90004: PUSH
90005: LD_INT 111
90007: PUSH
90008: LD_INT 112
90010: PUSH
90011: LD_INT 114
90013: PUSH
90014: EMPTY
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: LIST
90026: LIST
90027: LIST
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: ST_TO_ADDR
90033: GO 91620
90035: LD_INT 12
90037: DOUBLE
90038: EQUAL
90039: IFTRUE 90043
90041: GO 90251
90043: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
90044: LD_ADDR_VAR 0 1
90048: PUSH
90049: LD_INT 1
90051: PUSH
90052: LD_INT 2
90054: PUSH
90055: LD_INT 3
90057: PUSH
90058: LD_INT 4
90060: PUSH
90061: LD_INT 5
90063: PUSH
90064: LD_INT 6
90066: PUSH
90067: LD_INT 7
90069: PUSH
90070: LD_INT 8
90072: PUSH
90073: LD_INT 9
90075: PUSH
90076: LD_INT 10
90078: PUSH
90079: LD_INT 11
90081: PUSH
90082: LD_INT 12
90084: PUSH
90085: LD_INT 13
90087: PUSH
90088: LD_INT 14
90090: PUSH
90091: LD_INT 15
90093: PUSH
90094: LD_INT 16
90096: PUSH
90097: LD_INT 17
90099: PUSH
90100: LD_INT 18
90102: PUSH
90103: LD_INT 19
90105: PUSH
90106: LD_INT 20
90108: PUSH
90109: LD_INT 21
90111: PUSH
90112: LD_INT 22
90114: PUSH
90115: LD_INT 23
90117: PUSH
90118: LD_INT 24
90120: PUSH
90121: LD_INT 25
90123: PUSH
90124: LD_INT 26
90126: PUSH
90127: LD_INT 27
90129: PUSH
90130: LD_INT 28
90132: PUSH
90133: LD_INT 30
90135: PUSH
90136: LD_INT 31
90138: PUSH
90139: LD_INT 32
90141: PUSH
90142: LD_INT 33
90144: PUSH
90145: LD_INT 34
90147: PUSH
90148: LD_INT 36
90150: PUSH
90151: EMPTY
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: LIST
90168: LIST
90169: LIST
90170: LIST
90171: LIST
90172: LIST
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: PUSH
90187: LD_INT 101
90189: PUSH
90190: LD_INT 102
90192: PUSH
90193: LD_INT 103
90195: PUSH
90196: LD_INT 104
90198: PUSH
90199: LD_INT 105
90201: PUSH
90202: LD_INT 106
90204: PUSH
90205: LD_INT 107
90207: PUSH
90208: LD_INT 108
90210: PUSH
90211: LD_INT 109
90213: PUSH
90214: LD_INT 110
90216: PUSH
90217: LD_INT 111
90219: PUSH
90220: LD_INT 112
90222: PUSH
90223: LD_INT 113
90225: PUSH
90226: LD_INT 114
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: PUSH
90245: EMPTY
90246: LIST
90247: LIST
90248: ST_TO_ADDR
90249: GO 91620
90251: LD_INT 13
90253: DOUBLE
90254: EQUAL
90255: IFTRUE 90259
90257: GO 90455
90259: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
90260: LD_ADDR_VAR 0 1
90264: PUSH
90265: LD_INT 1
90267: PUSH
90268: LD_INT 2
90270: PUSH
90271: LD_INT 3
90273: PUSH
90274: LD_INT 4
90276: PUSH
90277: LD_INT 5
90279: PUSH
90280: LD_INT 8
90282: PUSH
90283: LD_INT 9
90285: PUSH
90286: LD_INT 10
90288: PUSH
90289: LD_INT 11
90291: PUSH
90292: LD_INT 12
90294: PUSH
90295: LD_INT 14
90297: PUSH
90298: LD_INT 15
90300: PUSH
90301: LD_INT 16
90303: PUSH
90304: LD_INT 17
90306: PUSH
90307: LD_INT 18
90309: PUSH
90310: LD_INT 19
90312: PUSH
90313: LD_INT 20
90315: PUSH
90316: LD_INT 21
90318: PUSH
90319: LD_INT 22
90321: PUSH
90322: LD_INT 23
90324: PUSH
90325: LD_INT 24
90327: PUSH
90328: LD_INT 25
90330: PUSH
90331: LD_INT 26
90333: PUSH
90334: LD_INT 27
90336: PUSH
90337: LD_INT 28
90339: PUSH
90340: LD_INT 30
90342: PUSH
90343: LD_INT 31
90345: PUSH
90346: LD_INT 32
90348: PUSH
90349: LD_INT 33
90351: PUSH
90352: LD_INT 34
90354: PUSH
90355: LD_INT 36
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: LIST
90370: LIST
90371: LIST
90372: LIST
90373: LIST
90374: LIST
90375: LIST
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: PUSH
90391: LD_INT 101
90393: PUSH
90394: LD_INT 102
90396: PUSH
90397: LD_INT 103
90399: PUSH
90400: LD_INT 104
90402: PUSH
90403: LD_INT 105
90405: PUSH
90406: LD_INT 106
90408: PUSH
90409: LD_INT 107
90411: PUSH
90412: LD_INT 108
90414: PUSH
90415: LD_INT 109
90417: PUSH
90418: LD_INT 110
90420: PUSH
90421: LD_INT 111
90423: PUSH
90424: LD_INT 112
90426: PUSH
90427: LD_INT 113
90429: PUSH
90430: LD_INT 114
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: LIST
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: ST_TO_ADDR
90453: GO 91620
90455: LD_INT 14
90457: DOUBLE
90458: EQUAL
90459: IFTRUE 90463
90461: GO 90675
90463: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
90464: LD_ADDR_VAR 0 1
90468: PUSH
90469: LD_INT 1
90471: PUSH
90472: LD_INT 2
90474: PUSH
90475: LD_INT 3
90477: PUSH
90478: LD_INT 4
90480: PUSH
90481: LD_INT 5
90483: PUSH
90484: LD_INT 6
90486: PUSH
90487: LD_INT 7
90489: PUSH
90490: LD_INT 8
90492: PUSH
90493: LD_INT 9
90495: PUSH
90496: LD_INT 10
90498: PUSH
90499: LD_INT 11
90501: PUSH
90502: LD_INT 12
90504: PUSH
90505: LD_INT 13
90507: PUSH
90508: LD_INT 14
90510: PUSH
90511: LD_INT 15
90513: PUSH
90514: LD_INT 16
90516: PUSH
90517: LD_INT 17
90519: PUSH
90520: LD_INT 18
90522: PUSH
90523: LD_INT 19
90525: PUSH
90526: LD_INT 20
90528: PUSH
90529: LD_INT 21
90531: PUSH
90532: LD_INT 22
90534: PUSH
90535: LD_INT 23
90537: PUSH
90538: LD_INT 24
90540: PUSH
90541: LD_INT 25
90543: PUSH
90544: LD_INT 26
90546: PUSH
90547: LD_INT 27
90549: PUSH
90550: LD_INT 28
90552: PUSH
90553: LD_INT 29
90555: PUSH
90556: LD_INT 30
90558: PUSH
90559: LD_INT 31
90561: PUSH
90562: LD_INT 32
90564: PUSH
90565: LD_INT 33
90567: PUSH
90568: LD_INT 34
90570: PUSH
90571: LD_INT 36
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: PUSH
90611: LD_INT 101
90613: PUSH
90614: LD_INT 102
90616: PUSH
90617: LD_INT 103
90619: PUSH
90620: LD_INT 104
90622: PUSH
90623: LD_INT 105
90625: PUSH
90626: LD_INT 106
90628: PUSH
90629: LD_INT 107
90631: PUSH
90632: LD_INT 108
90634: PUSH
90635: LD_INT 109
90637: PUSH
90638: LD_INT 110
90640: PUSH
90641: LD_INT 111
90643: PUSH
90644: LD_INT 112
90646: PUSH
90647: LD_INT 113
90649: PUSH
90650: LD_INT 114
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: PUSH
90669: EMPTY
90670: LIST
90671: LIST
90672: ST_TO_ADDR
90673: GO 91620
90675: LD_INT 15
90677: DOUBLE
90678: EQUAL
90679: IFTRUE 90683
90681: GO 90895
90683: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
90684: LD_ADDR_VAR 0 1
90688: PUSH
90689: LD_INT 1
90691: PUSH
90692: LD_INT 2
90694: PUSH
90695: LD_INT 3
90697: PUSH
90698: LD_INT 4
90700: PUSH
90701: LD_INT 5
90703: PUSH
90704: LD_INT 6
90706: PUSH
90707: LD_INT 7
90709: PUSH
90710: LD_INT 8
90712: PUSH
90713: LD_INT 9
90715: PUSH
90716: LD_INT 10
90718: PUSH
90719: LD_INT 11
90721: PUSH
90722: LD_INT 12
90724: PUSH
90725: LD_INT 13
90727: PUSH
90728: LD_INT 14
90730: PUSH
90731: LD_INT 15
90733: PUSH
90734: LD_INT 16
90736: PUSH
90737: LD_INT 17
90739: PUSH
90740: LD_INT 18
90742: PUSH
90743: LD_INT 19
90745: PUSH
90746: LD_INT 20
90748: PUSH
90749: LD_INT 21
90751: PUSH
90752: LD_INT 22
90754: PUSH
90755: LD_INT 23
90757: PUSH
90758: LD_INT 24
90760: PUSH
90761: LD_INT 25
90763: PUSH
90764: LD_INT 26
90766: PUSH
90767: LD_INT 27
90769: PUSH
90770: LD_INT 28
90772: PUSH
90773: LD_INT 29
90775: PUSH
90776: LD_INT 30
90778: PUSH
90779: LD_INT 31
90781: PUSH
90782: LD_INT 32
90784: PUSH
90785: LD_INT 33
90787: PUSH
90788: LD_INT 34
90790: PUSH
90791: LD_INT 36
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: LIST
90814: LIST
90815: LIST
90816: LIST
90817: LIST
90818: LIST
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: LIST
90828: LIST
90829: LIST
90830: PUSH
90831: LD_INT 101
90833: PUSH
90834: LD_INT 102
90836: PUSH
90837: LD_INT 103
90839: PUSH
90840: LD_INT 104
90842: PUSH
90843: LD_INT 105
90845: PUSH
90846: LD_INT 106
90848: PUSH
90849: LD_INT 107
90851: PUSH
90852: LD_INT 108
90854: PUSH
90855: LD_INT 109
90857: PUSH
90858: LD_INT 110
90860: PUSH
90861: LD_INT 111
90863: PUSH
90864: LD_INT 112
90866: PUSH
90867: LD_INT 113
90869: PUSH
90870: LD_INT 114
90872: PUSH
90873: EMPTY
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: LIST
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: ST_TO_ADDR
90893: GO 91620
90895: LD_INT 16
90897: DOUBLE
90898: EQUAL
90899: IFTRUE 90903
90901: GO 91027
90903: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
90904: LD_ADDR_VAR 0 1
90908: PUSH
90909: LD_INT 2
90911: PUSH
90912: LD_INT 4
90914: PUSH
90915: LD_INT 5
90917: PUSH
90918: LD_INT 7
90920: PUSH
90921: LD_INT 11
90923: PUSH
90924: LD_INT 12
90926: PUSH
90927: LD_INT 15
90929: PUSH
90930: LD_INT 16
90932: PUSH
90933: LD_INT 20
90935: PUSH
90936: LD_INT 21
90938: PUSH
90939: LD_INT 22
90941: PUSH
90942: LD_INT 23
90944: PUSH
90945: LD_INT 25
90947: PUSH
90948: LD_INT 26
90950: PUSH
90951: LD_INT 30
90953: PUSH
90954: LD_INT 31
90956: PUSH
90957: LD_INT 32
90959: PUSH
90960: LD_INT 33
90962: PUSH
90963: LD_INT 34
90965: PUSH
90966: EMPTY
90967: LIST
90968: LIST
90969: LIST
90970: LIST
90971: LIST
90972: LIST
90973: LIST
90974: LIST
90975: LIST
90976: LIST
90977: LIST
90978: LIST
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: PUSH
90987: LD_INT 101
90989: PUSH
90990: LD_INT 102
90992: PUSH
90993: LD_INT 103
90995: PUSH
90996: LD_INT 106
90998: PUSH
90999: LD_INT 108
91001: PUSH
91002: LD_INT 112
91004: PUSH
91005: LD_INT 113
91007: PUSH
91008: LD_INT 114
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: PUSH
91021: EMPTY
91022: LIST
91023: LIST
91024: ST_TO_ADDR
91025: GO 91620
91027: LD_INT 17
91029: DOUBLE
91030: EQUAL
91031: IFTRUE 91035
91033: GO 91247
91035: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
91036: LD_ADDR_VAR 0 1
91040: PUSH
91041: LD_INT 1
91043: PUSH
91044: LD_INT 2
91046: PUSH
91047: LD_INT 3
91049: PUSH
91050: LD_INT 4
91052: PUSH
91053: LD_INT 5
91055: PUSH
91056: LD_INT 6
91058: PUSH
91059: LD_INT 7
91061: PUSH
91062: LD_INT 8
91064: PUSH
91065: LD_INT 9
91067: PUSH
91068: LD_INT 10
91070: PUSH
91071: LD_INT 11
91073: PUSH
91074: LD_INT 12
91076: PUSH
91077: LD_INT 13
91079: PUSH
91080: LD_INT 14
91082: PUSH
91083: LD_INT 15
91085: PUSH
91086: LD_INT 16
91088: PUSH
91089: LD_INT 17
91091: PUSH
91092: LD_INT 18
91094: PUSH
91095: LD_INT 19
91097: PUSH
91098: LD_INT 20
91100: PUSH
91101: LD_INT 21
91103: PUSH
91104: LD_INT 22
91106: PUSH
91107: LD_INT 23
91109: PUSH
91110: LD_INT 24
91112: PUSH
91113: LD_INT 25
91115: PUSH
91116: LD_INT 26
91118: PUSH
91119: LD_INT 27
91121: PUSH
91122: LD_INT 28
91124: PUSH
91125: LD_INT 29
91127: PUSH
91128: LD_INT 30
91130: PUSH
91131: LD_INT 31
91133: PUSH
91134: LD_INT 32
91136: PUSH
91137: LD_INT 33
91139: PUSH
91140: LD_INT 34
91142: PUSH
91143: LD_INT 36
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: PUSH
91183: LD_INT 101
91185: PUSH
91186: LD_INT 102
91188: PUSH
91189: LD_INT 103
91191: PUSH
91192: LD_INT 104
91194: PUSH
91195: LD_INT 105
91197: PUSH
91198: LD_INT 106
91200: PUSH
91201: LD_INT 107
91203: PUSH
91204: LD_INT 108
91206: PUSH
91207: LD_INT 109
91209: PUSH
91210: LD_INT 110
91212: PUSH
91213: LD_INT 111
91215: PUSH
91216: LD_INT 112
91218: PUSH
91219: LD_INT 113
91221: PUSH
91222: LD_INT 114
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: ST_TO_ADDR
91245: GO 91620
91247: LD_INT 18
91249: DOUBLE
91250: EQUAL
91251: IFTRUE 91255
91253: GO 91391
91255: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
91256: LD_ADDR_VAR 0 1
91260: PUSH
91261: LD_INT 2
91263: PUSH
91264: LD_INT 4
91266: PUSH
91267: LD_INT 5
91269: PUSH
91270: LD_INT 7
91272: PUSH
91273: LD_INT 11
91275: PUSH
91276: LD_INT 12
91278: PUSH
91279: LD_INT 15
91281: PUSH
91282: LD_INT 16
91284: PUSH
91285: LD_INT 20
91287: PUSH
91288: LD_INT 21
91290: PUSH
91291: LD_INT 22
91293: PUSH
91294: LD_INT 23
91296: PUSH
91297: LD_INT 25
91299: PUSH
91300: LD_INT 26
91302: PUSH
91303: LD_INT 30
91305: PUSH
91306: LD_INT 31
91308: PUSH
91309: LD_INT 32
91311: PUSH
91312: LD_INT 33
91314: PUSH
91315: LD_INT 34
91317: PUSH
91318: LD_INT 35
91320: PUSH
91321: LD_INT 36
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: LIST
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: PUSH
91347: LD_INT 101
91349: PUSH
91350: LD_INT 102
91352: PUSH
91353: LD_INT 103
91355: PUSH
91356: LD_INT 106
91358: PUSH
91359: LD_INT 108
91361: PUSH
91362: LD_INT 112
91364: PUSH
91365: LD_INT 113
91367: PUSH
91368: LD_INT 114
91370: PUSH
91371: LD_INT 115
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: LIST
91380: LIST
91381: LIST
91382: LIST
91383: LIST
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: ST_TO_ADDR
91389: GO 91620
91391: LD_INT 19
91393: DOUBLE
91394: EQUAL
91395: IFTRUE 91399
91397: GO 91619
91399: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
91400: LD_ADDR_VAR 0 1
91404: PUSH
91405: LD_INT 1
91407: PUSH
91408: LD_INT 2
91410: PUSH
91411: LD_INT 3
91413: PUSH
91414: LD_INT 4
91416: PUSH
91417: LD_INT 5
91419: PUSH
91420: LD_INT 6
91422: PUSH
91423: LD_INT 7
91425: PUSH
91426: LD_INT 8
91428: PUSH
91429: LD_INT 9
91431: PUSH
91432: LD_INT 10
91434: PUSH
91435: LD_INT 11
91437: PUSH
91438: LD_INT 12
91440: PUSH
91441: LD_INT 13
91443: PUSH
91444: LD_INT 14
91446: PUSH
91447: LD_INT 15
91449: PUSH
91450: LD_INT 16
91452: PUSH
91453: LD_INT 17
91455: PUSH
91456: LD_INT 18
91458: PUSH
91459: LD_INT 19
91461: PUSH
91462: LD_INT 20
91464: PUSH
91465: LD_INT 21
91467: PUSH
91468: LD_INT 22
91470: PUSH
91471: LD_INT 23
91473: PUSH
91474: LD_INT 24
91476: PUSH
91477: LD_INT 25
91479: PUSH
91480: LD_INT 26
91482: PUSH
91483: LD_INT 27
91485: PUSH
91486: LD_INT 28
91488: PUSH
91489: LD_INT 29
91491: PUSH
91492: LD_INT 30
91494: PUSH
91495: LD_INT 31
91497: PUSH
91498: LD_INT 32
91500: PUSH
91501: LD_INT 33
91503: PUSH
91504: LD_INT 34
91506: PUSH
91507: LD_INT 35
91509: PUSH
91510: LD_INT 36
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: LIST
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: LIST
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: LIST
91531: LIST
91532: LIST
91533: LIST
91534: LIST
91535: LIST
91536: LIST
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: LIST
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 101
91553: PUSH
91554: LD_INT 102
91556: PUSH
91557: LD_INT 103
91559: PUSH
91560: LD_INT 104
91562: PUSH
91563: LD_INT 105
91565: PUSH
91566: LD_INT 106
91568: PUSH
91569: LD_INT 107
91571: PUSH
91572: LD_INT 108
91574: PUSH
91575: LD_INT 109
91577: PUSH
91578: LD_INT 110
91580: PUSH
91581: LD_INT 111
91583: PUSH
91584: LD_INT 112
91586: PUSH
91587: LD_INT 113
91589: PUSH
91590: LD_INT 114
91592: PUSH
91593: LD_INT 115
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: ST_TO_ADDR
91617: GO 91620
91619: POP
// end else
91620: GO 91839
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
91622: LD_ADDR_VAR 0 1
91626: PUSH
91627: LD_INT 1
91629: PUSH
91630: LD_INT 2
91632: PUSH
91633: LD_INT 3
91635: PUSH
91636: LD_INT 4
91638: PUSH
91639: LD_INT 5
91641: PUSH
91642: LD_INT 6
91644: PUSH
91645: LD_INT 7
91647: PUSH
91648: LD_INT 8
91650: PUSH
91651: LD_INT 9
91653: PUSH
91654: LD_INT 10
91656: PUSH
91657: LD_INT 11
91659: PUSH
91660: LD_INT 12
91662: PUSH
91663: LD_INT 13
91665: PUSH
91666: LD_INT 14
91668: PUSH
91669: LD_INT 15
91671: PUSH
91672: LD_INT 16
91674: PUSH
91675: LD_INT 17
91677: PUSH
91678: LD_INT 18
91680: PUSH
91681: LD_INT 19
91683: PUSH
91684: LD_INT 20
91686: PUSH
91687: LD_INT 21
91689: PUSH
91690: LD_INT 22
91692: PUSH
91693: LD_INT 23
91695: PUSH
91696: LD_INT 24
91698: PUSH
91699: LD_INT 25
91701: PUSH
91702: LD_INT 26
91704: PUSH
91705: LD_INT 27
91707: PUSH
91708: LD_INT 28
91710: PUSH
91711: LD_INT 29
91713: PUSH
91714: LD_INT 30
91716: PUSH
91717: LD_INT 31
91719: PUSH
91720: LD_INT 32
91722: PUSH
91723: LD_INT 33
91725: PUSH
91726: LD_INT 34
91728: PUSH
91729: LD_INT 35
91731: PUSH
91732: LD_INT 36
91734: PUSH
91735: EMPTY
91736: LIST
91737: LIST
91738: LIST
91739: LIST
91740: LIST
91741: LIST
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: LIST
91772: PUSH
91773: LD_INT 101
91775: PUSH
91776: LD_INT 102
91778: PUSH
91779: LD_INT 103
91781: PUSH
91782: LD_INT 104
91784: PUSH
91785: LD_INT 105
91787: PUSH
91788: LD_INT 106
91790: PUSH
91791: LD_INT 107
91793: PUSH
91794: LD_INT 108
91796: PUSH
91797: LD_INT 109
91799: PUSH
91800: LD_INT 110
91802: PUSH
91803: LD_INT 111
91805: PUSH
91806: LD_INT 112
91808: PUSH
91809: LD_INT 113
91811: PUSH
91812: LD_INT 114
91814: PUSH
91815: LD_INT 115
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: PUSH
91835: EMPTY
91836: LIST
91837: LIST
91838: ST_TO_ADDR
// if result then
91839: LD_VAR 0 1
91843: IFFALSE 92132
// begin normal :=  ;
91845: LD_ADDR_VAR 0 3
91849: PUSH
91850: LD_STRING 
91852: ST_TO_ADDR
// hardcore :=  ;
91853: LD_ADDR_VAR 0 4
91857: PUSH
91858: LD_STRING 
91860: ST_TO_ADDR
// for i = 1 to normalCounter do
91861: LD_ADDR_VAR 0 5
91865: PUSH
91866: DOUBLE
91867: LD_INT 1
91869: DEC
91870: ST_TO_ADDR
91871: LD_EXP 133
91875: PUSH
91876: FOR_TO
91877: IFFALSE 91978
// begin tmp := 0 ;
91879: LD_ADDR_VAR 0 2
91883: PUSH
91884: LD_STRING 0
91886: ST_TO_ADDR
// if result [ 1 ] then
91887: LD_VAR 0 1
91891: PUSH
91892: LD_INT 1
91894: ARRAY
91895: IFFALSE 91960
// if result [ 1 ] [ 1 ] = i then
91897: LD_VAR 0 1
91901: PUSH
91902: LD_INT 1
91904: ARRAY
91905: PUSH
91906: LD_INT 1
91908: ARRAY
91909: PUSH
91910: LD_VAR 0 5
91914: EQUAL
91915: IFFALSE 91960
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
91917: LD_ADDR_VAR 0 1
91921: PUSH
91922: LD_VAR 0 1
91926: PPUSH
91927: LD_INT 1
91929: PPUSH
91930: LD_VAR 0 1
91934: PUSH
91935: LD_INT 1
91937: ARRAY
91938: PPUSH
91939: LD_INT 1
91941: PPUSH
91942: CALL_OW 3
91946: PPUSH
91947: CALL_OW 1
91951: ST_TO_ADDR
// tmp := 1 ;
91952: LD_ADDR_VAR 0 2
91956: PUSH
91957: LD_STRING 1
91959: ST_TO_ADDR
// end ; normal := normal & tmp ;
91960: LD_ADDR_VAR 0 3
91964: PUSH
91965: LD_VAR 0 3
91969: PUSH
91970: LD_VAR 0 2
91974: STR
91975: ST_TO_ADDR
// end ;
91976: GO 91876
91978: POP
91979: POP
// for i = 1 to hardcoreCounter do
91980: LD_ADDR_VAR 0 5
91984: PUSH
91985: DOUBLE
91986: LD_INT 1
91988: DEC
91989: ST_TO_ADDR
91990: LD_EXP 134
91994: PUSH
91995: FOR_TO
91996: IFFALSE 92101
// begin tmp := 0 ;
91998: LD_ADDR_VAR 0 2
92002: PUSH
92003: LD_STRING 0
92005: ST_TO_ADDR
// if result [ 2 ] then
92006: LD_VAR 0 1
92010: PUSH
92011: LD_INT 2
92013: ARRAY
92014: IFFALSE 92083
// if result [ 2 ] [ 1 ] = 100 + i then
92016: LD_VAR 0 1
92020: PUSH
92021: LD_INT 2
92023: ARRAY
92024: PUSH
92025: LD_INT 1
92027: ARRAY
92028: PUSH
92029: LD_INT 100
92031: PUSH
92032: LD_VAR 0 5
92036: PLUS
92037: EQUAL
92038: IFFALSE 92083
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92040: LD_ADDR_VAR 0 1
92044: PUSH
92045: LD_VAR 0 1
92049: PPUSH
92050: LD_INT 2
92052: PPUSH
92053: LD_VAR 0 1
92057: PUSH
92058: LD_INT 2
92060: ARRAY
92061: PPUSH
92062: LD_INT 1
92064: PPUSH
92065: CALL_OW 3
92069: PPUSH
92070: CALL_OW 1
92074: ST_TO_ADDR
// tmp := 1 ;
92075: LD_ADDR_VAR 0 2
92079: PUSH
92080: LD_STRING 1
92082: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92083: LD_ADDR_VAR 0 4
92087: PUSH
92088: LD_VAR 0 4
92092: PUSH
92093: LD_VAR 0 2
92097: STR
92098: ST_TO_ADDR
// end ;
92099: GO 91995
92101: POP
92102: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
92103: LD_STRING getStreamItemsFromMission("
92105: PUSH
92106: LD_VAR 0 3
92110: STR
92111: PUSH
92112: LD_STRING ","
92114: STR
92115: PUSH
92116: LD_VAR 0 4
92120: STR
92121: PUSH
92122: LD_STRING ")
92124: STR
92125: PPUSH
92126: CALL_OW 559
// end else
92130: GO 92139
// ToLua ( getStreamItemsFromMission("","") ) ;
92132: LD_STRING getStreamItemsFromMission("","")
92134: PPUSH
92135: CALL_OW 559
// end ;
92139: LD_VAR 0 1
92143: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92144: LD_EXP 132
92148: PUSH
92149: LD_EXP 137
92153: AND
92154: IFFALSE 92278
92156: GO 92158
92158: DISABLE
92159: LD_INT 0
92161: PPUSH
92162: PPUSH
// begin enable ;
92163: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92164: LD_ADDR_VAR 0 2
92168: PUSH
92169: LD_INT 22
92171: PUSH
92172: LD_OWVAR 2
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: LD_INT 2
92183: PUSH
92184: LD_INT 34
92186: PUSH
92187: LD_INT 7
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PUSH
92194: LD_INT 34
92196: PUSH
92197: LD_INT 45
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: LD_INT 34
92206: PUSH
92207: LD_INT 28
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: LD_INT 34
92216: PUSH
92217: LD_INT 47
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PPUSH
92235: CALL_OW 69
92239: ST_TO_ADDR
// if not tmp then
92240: LD_VAR 0 2
92244: NOT
92245: IFFALSE 92249
// exit ;
92247: GO 92278
// for i in tmp do
92249: LD_ADDR_VAR 0 1
92253: PUSH
92254: LD_VAR 0 2
92258: PUSH
92259: FOR_IN
92260: IFFALSE 92276
// begin SetLives ( i , 0 ) ;
92262: LD_VAR 0 1
92266: PPUSH
92267: LD_INT 0
92269: PPUSH
92270: CALL_OW 234
// end ;
92274: GO 92259
92276: POP
92277: POP
// end ;
92278: PPOPN 2
92280: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92281: LD_EXP 132
92285: PUSH
92286: LD_EXP 138
92290: AND
92291: IFFALSE 92375
92293: GO 92295
92295: DISABLE
92296: LD_INT 0
92298: PPUSH
92299: PPUSH
// begin enable ;
92300: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92301: LD_ADDR_VAR 0 2
92305: PUSH
92306: LD_INT 22
92308: PUSH
92309: LD_OWVAR 2
92313: PUSH
92314: EMPTY
92315: LIST
92316: LIST
92317: PUSH
92318: LD_INT 32
92320: PUSH
92321: LD_INT 3
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PPUSH
92332: CALL_OW 69
92336: ST_TO_ADDR
// if not tmp then
92337: LD_VAR 0 2
92341: NOT
92342: IFFALSE 92346
// exit ;
92344: GO 92375
// for i in tmp do
92346: LD_ADDR_VAR 0 1
92350: PUSH
92351: LD_VAR 0 2
92355: PUSH
92356: FOR_IN
92357: IFFALSE 92373
// begin SetLives ( i , 0 ) ;
92359: LD_VAR 0 1
92363: PPUSH
92364: LD_INT 0
92366: PPUSH
92367: CALL_OW 234
// end ;
92371: GO 92356
92373: POP
92374: POP
// end ;
92375: PPOPN 2
92377: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92378: LD_EXP 132
92382: PUSH
92383: LD_EXP 135
92387: AND
92388: IFFALSE 92481
92390: GO 92392
92392: DISABLE
92393: LD_INT 0
92395: PPUSH
// begin enable ;
92396: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92397: LD_ADDR_VAR 0 1
92401: PUSH
92402: LD_INT 22
92404: PUSH
92405: LD_OWVAR 2
92409: PUSH
92410: EMPTY
92411: LIST
92412: LIST
92413: PUSH
92414: LD_INT 2
92416: PUSH
92417: LD_INT 25
92419: PUSH
92420: LD_INT 5
92422: PUSH
92423: EMPTY
92424: LIST
92425: LIST
92426: PUSH
92427: LD_INT 25
92429: PUSH
92430: LD_INT 9
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: LD_INT 25
92439: PUSH
92440: LD_INT 8
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: PUSH
92453: EMPTY
92454: LIST
92455: LIST
92456: PPUSH
92457: CALL_OW 69
92461: PUSH
92462: FOR_IN
92463: IFFALSE 92479
// begin SetClass ( i , 1 ) ;
92465: LD_VAR 0 1
92469: PPUSH
92470: LD_INT 1
92472: PPUSH
92473: CALL_OW 336
// end ;
92477: GO 92462
92479: POP
92480: POP
// end ;
92481: PPOPN 1
92483: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92484: LD_EXP 132
92488: PUSH
92489: LD_EXP 136
92493: AND
92494: PUSH
92495: LD_OWVAR 65
92499: PUSH
92500: LD_INT 7
92502: LESS
92503: AND
92504: IFFALSE 92518
92506: GO 92508
92508: DISABLE
// begin enable ;
92509: ENABLE
// game_speed := 7 ;
92510: LD_ADDR_OWVAR 65
92514: PUSH
92515: LD_INT 7
92517: ST_TO_ADDR
// end ;
92518: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92519: LD_EXP 132
92523: PUSH
92524: LD_EXP 139
92528: AND
92529: IFFALSE 92731
92531: GO 92533
92533: DISABLE
92534: LD_INT 0
92536: PPUSH
92537: PPUSH
92538: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92539: LD_ADDR_VAR 0 3
92543: PUSH
92544: LD_INT 81
92546: PUSH
92547: LD_OWVAR 2
92551: PUSH
92552: EMPTY
92553: LIST
92554: LIST
92555: PUSH
92556: LD_INT 21
92558: PUSH
92559: LD_INT 1
92561: PUSH
92562: EMPTY
92563: LIST
92564: LIST
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PPUSH
92570: CALL_OW 69
92574: ST_TO_ADDR
// if not tmp then
92575: LD_VAR 0 3
92579: NOT
92580: IFFALSE 92584
// exit ;
92582: GO 92731
// if tmp > 5 then
92584: LD_VAR 0 3
92588: PUSH
92589: LD_INT 5
92591: GREATER
92592: IFFALSE 92604
// k := 5 else
92594: LD_ADDR_VAR 0 2
92598: PUSH
92599: LD_INT 5
92601: ST_TO_ADDR
92602: GO 92614
// k := tmp ;
92604: LD_ADDR_VAR 0 2
92608: PUSH
92609: LD_VAR 0 3
92613: ST_TO_ADDR
// for i := 1 to k do
92614: LD_ADDR_VAR 0 1
92618: PUSH
92619: DOUBLE
92620: LD_INT 1
92622: DEC
92623: ST_TO_ADDR
92624: LD_VAR 0 2
92628: PUSH
92629: FOR_TO
92630: IFFALSE 92729
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92632: LD_VAR 0 3
92636: PUSH
92637: LD_VAR 0 1
92641: ARRAY
92642: PPUSH
92643: LD_VAR 0 1
92647: PUSH
92648: LD_INT 4
92650: MOD
92651: PUSH
92652: LD_INT 1
92654: PLUS
92655: PPUSH
92656: CALL_OW 259
92660: PUSH
92661: LD_INT 10
92663: LESS
92664: IFFALSE 92727
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92666: LD_VAR 0 3
92670: PUSH
92671: LD_VAR 0 1
92675: ARRAY
92676: PPUSH
92677: LD_VAR 0 1
92681: PUSH
92682: LD_INT 4
92684: MOD
92685: PUSH
92686: LD_INT 1
92688: PLUS
92689: PPUSH
92690: LD_VAR 0 3
92694: PUSH
92695: LD_VAR 0 1
92699: ARRAY
92700: PPUSH
92701: LD_VAR 0 1
92705: PUSH
92706: LD_INT 4
92708: MOD
92709: PUSH
92710: LD_INT 1
92712: PLUS
92713: PPUSH
92714: CALL_OW 259
92718: PUSH
92719: LD_INT 1
92721: PLUS
92722: PPUSH
92723: CALL_OW 237
92727: GO 92629
92729: POP
92730: POP
// end ;
92731: PPOPN 3
92733: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92734: LD_EXP 132
92738: PUSH
92739: LD_EXP 140
92743: AND
92744: IFFALSE 92764
92746: GO 92748
92748: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92749: LD_INT 4
92751: PPUSH
92752: LD_OWVAR 2
92756: PPUSH
92757: LD_INT 0
92759: PPUSH
92760: CALL_OW 324
92764: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92765: LD_EXP 132
92769: PUSH
92770: LD_EXP 169
92774: AND
92775: IFFALSE 92795
92777: GO 92779
92779: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92780: LD_INT 19
92782: PPUSH
92783: LD_OWVAR 2
92787: PPUSH
92788: LD_INT 0
92790: PPUSH
92791: CALL_OW 324
92795: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92796: LD_EXP 132
92800: PUSH
92801: LD_EXP 141
92805: AND
92806: IFFALSE 92908
92808: GO 92810
92810: DISABLE
92811: LD_INT 0
92813: PPUSH
92814: PPUSH
// begin enable ;
92815: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92816: LD_ADDR_VAR 0 2
92820: PUSH
92821: LD_INT 22
92823: PUSH
92824: LD_OWVAR 2
92828: PUSH
92829: EMPTY
92830: LIST
92831: LIST
92832: PUSH
92833: LD_INT 2
92835: PUSH
92836: LD_INT 34
92838: PUSH
92839: LD_INT 11
92841: PUSH
92842: EMPTY
92843: LIST
92844: LIST
92845: PUSH
92846: LD_INT 34
92848: PUSH
92849: LD_INT 30
92851: PUSH
92852: EMPTY
92853: LIST
92854: LIST
92855: PUSH
92856: EMPTY
92857: LIST
92858: LIST
92859: LIST
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PPUSH
92865: CALL_OW 69
92869: ST_TO_ADDR
// if not tmp then
92870: LD_VAR 0 2
92874: NOT
92875: IFFALSE 92879
// exit ;
92877: GO 92908
// for i in tmp do
92879: LD_ADDR_VAR 0 1
92883: PUSH
92884: LD_VAR 0 2
92888: PUSH
92889: FOR_IN
92890: IFFALSE 92906
// begin SetLives ( i , 0 ) ;
92892: LD_VAR 0 1
92896: PPUSH
92897: LD_INT 0
92899: PPUSH
92900: CALL_OW 234
// end ;
92904: GO 92889
92906: POP
92907: POP
// end ;
92908: PPOPN 2
92910: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92911: LD_EXP 132
92915: PUSH
92916: LD_EXP 142
92920: AND
92921: IFFALSE 92941
92923: GO 92925
92925: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92926: LD_INT 32
92928: PPUSH
92929: LD_OWVAR 2
92933: PPUSH
92934: LD_INT 0
92936: PPUSH
92937: CALL_OW 324
92941: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92942: LD_EXP 132
92946: PUSH
92947: LD_EXP 143
92951: AND
92952: IFFALSE 93133
92954: GO 92956
92956: DISABLE
92957: LD_INT 0
92959: PPUSH
92960: PPUSH
92961: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92962: LD_ADDR_VAR 0 2
92966: PUSH
92967: LD_INT 22
92969: PUSH
92970: LD_OWVAR 2
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: PUSH
92979: LD_INT 33
92981: PUSH
92982: LD_INT 3
92984: PUSH
92985: EMPTY
92986: LIST
92987: LIST
92988: PUSH
92989: EMPTY
92990: LIST
92991: LIST
92992: PPUSH
92993: CALL_OW 69
92997: ST_TO_ADDR
// if not tmp then
92998: LD_VAR 0 2
93002: NOT
93003: IFFALSE 93007
// exit ;
93005: GO 93133
// side := 0 ;
93007: LD_ADDR_VAR 0 3
93011: PUSH
93012: LD_INT 0
93014: ST_TO_ADDR
// for i := 1 to 8 do
93015: LD_ADDR_VAR 0 1
93019: PUSH
93020: DOUBLE
93021: LD_INT 1
93023: DEC
93024: ST_TO_ADDR
93025: LD_INT 8
93027: PUSH
93028: FOR_TO
93029: IFFALSE 93077
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93031: LD_OWVAR 2
93035: PUSH
93036: LD_VAR 0 1
93040: NONEQUAL
93041: PUSH
93042: LD_OWVAR 2
93046: PPUSH
93047: LD_VAR 0 1
93051: PPUSH
93052: CALL_OW 81
93056: PUSH
93057: LD_INT 2
93059: EQUAL
93060: AND
93061: IFFALSE 93075
// begin side := i ;
93063: LD_ADDR_VAR 0 3
93067: PUSH
93068: LD_VAR 0 1
93072: ST_TO_ADDR
// break ;
93073: GO 93077
// end ;
93075: GO 93028
93077: POP
93078: POP
// if not side then
93079: LD_VAR 0 3
93083: NOT
93084: IFFALSE 93088
// exit ;
93086: GO 93133
// for i := 1 to tmp do
93088: LD_ADDR_VAR 0 1
93092: PUSH
93093: DOUBLE
93094: LD_INT 1
93096: DEC
93097: ST_TO_ADDR
93098: LD_VAR 0 2
93102: PUSH
93103: FOR_TO
93104: IFFALSE 93131
// if Prob ( 60 ) then
93106: LD_INT 60
93108: PPUSH
93109: CALL_OW 13
93113: IFFALSE 93129
// SetSide ( i , side ) ;
93115: LD_VAR 0 1
93119: PPUSH
93120: LD_VAR 0 3
93124: PPUSH
93125: CALL_OW 235
93129: GO 93103
93131: POP
93132: POP
// end ;
93133: PPOPN 3
93135: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93136: LD_EXP 132
93140: PUSH
93141: LD_EXP 145
93145: AND
93146: IFFALSE 93265
93148: GO 93150
93150: DISABLE
93151: LD_INT 0
93153: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93154: LD_ADDR_VAR 0 1
93158: PUSH
93159: LD_INT 22
93161: PUSH
93162: LD_OWVAR 2
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 21
93173: PUSH
93174: LD_INT 1
93176: PUSH
93177: EMPTY
93178: LIST
93179: LIST
93180: PUSH
93181: LD_INT 3
93183: PUSH
93184: LD_INT 23
93186: PUSH
93187: LD_INT 0
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: EMPTY
93195: LIST
93196: LIST
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: LIST
93202: PPUSH
93203: CALL_OW 69
93207: PUSH
93208: FOR_IN
93209: IFFALSE 93263
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93211: LD_VAR 0 1
93215: PPUSH
93216: CALL_OW 257
93220: PUSH
93221: LD_INT 1
93223: PUSH
93224: LD_INT 2
93226: PUSH
93227: LD_INT 3
93229: PUSH
93230: LD_INT 4
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: IN
93239: IFFALSE 93261
// SetClass ( un , rand ( 1 , 4 ) ) ;
93241: LD_VAR 0 1
93245: PPUSH
93246: LD_INT 1
93248: PPUSH
93249: LD_INT 4
93251: PPUSH
93252: CALL_OW 12
93256: PPUSH
93257: CALL_OW 336
93261: GO 93208
93263: POP
93264: POP
// end ;
93265: PPOPN 1
93267: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93268: LD_EXP 132
93272: PUSH
93273: LD_EXP 144
93277: AND
93278: IFFALSE 93357
93280: GO 93282
93282: DISABLE
93283: LD_INT 0
93285: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93286: LD_ADDR_VAR 0 1
93290: PUSH
93291: LD_INT 22
93293: PUSH
93294: LD_OWVAR 2
93298: PUSH
93299: EMPTY
93300: LIST
93301: LIST
93302: PUSH
93303: LD_INT 21
93305: PUSH
93306: LD_INT 3
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PPUSH
93317: CALL_OW 69
93321: ST_TO_ADDR
// if not tmp then
93322: LD_VAR 0 1
93326: NOT
93327: IFFALSE 93331
// exit ;
93329: GO 93357
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93331: LD_VAR 0 1
93335: PUSH
93336: LD_INT 1
93338: PPUSH
93339: LD_VAR 0 1
93343: PPUSH
93344: CALL_OW 12
93348: ARRAY
93349: PPUSH
93350: LD_INT 100
93352: PPUSH
93353: CALL_OW 234
// end ;
93357: PPOPN 1
93359: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93360: LD_EXP 132
93364: PUSH
93365: LD_EXP 146
93369: AND
93370: IFFALSE 93468
93372: GO 93374
93374: DISABLE
93375: LD_INT 0
93377: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93378: LD_ADDR_VAR 0 1
93382: PUSH
93383: LD_INT 22
93385: PUSH
93386: LD_OWVAR 2
93390: PUSH
93391: EMPTY
93392: LIST
93393: LIST
93394: PUSH
93395: LD_INT 21
93397: PUSH
93398: LD_INT 1
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: PPUSH
93409: CALL_OW 69
93413: ST_TO_ADDR
// if not tmp then
93414: LD_VAR 0 1
93418: NOT
93419: IFFALSE 93423
// exit ;
93421: GO 93468
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93423: LD_VAR 0 1
93427: PUSH
93428: LD_INT 1
93430: PPUSH
93431: LD_VAR 0 1
93435: PPUSH
93436: CALL_OW 12
93440: ARRAY
93441: PPUSH
93442: LD_INT 1
93444: PPUSH
93445: LD_INT 4
93447: PPUSH
93448: CALL_OW 12
93452: PPUSH
93453: LD_INT 3000
93455: PPUSH
93456: LD_INT 9000
93458: PPUSH
93459: CALL_OW 12
93463: PPUSH
93464: CALL_OW 492
// end ;
93468: PPOPN 1
93470: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93471: LD_EXP 132
93475: PUSH
93476: LD_EXP 147
93480: AND
93481: IFFALSE 93501
93483: GO 93485
93485: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93486: LD_INT 1
93488: PPUSH
93489: LD_OWVAR 2
93493: PPUSH
93494: LD_INT 0
93496: PPUSH
93497: CALL_OW 324
93501: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93502: LD_EXP 132
93506: PUSH
93507: LD_EXP 148
93511: AND
93512: IFFALSE 93595
93514: GO 93516
93516: DISABLE
93517: LD_INT 0
93519: PPUSH
93520: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93521: LD_ADDR_VAR 0 2
93525: PUSH
93526: LD_INT 22
93528: PUSH
93529: LD_OWVAR 2
93533: PUSH
93534: EMPTY
93535: LIST
93536: LIST
93537: PUSH
93538: LD_INT 21
93540: PUSH
93541: LD_INT 3
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: EMPTY
93549: LIST
93550: LIST
93551: PPUSH
93552: CALL_OW 69
93556: ST_TO_ADDR
// if not tmp then
93557: LD_VAR 0 2
93561: NOT
93562: IFFALSE 93566
// exit ;
93564: GO 93595
// for i in tmp do
93566: LD_ADDR_VAR 0 1
93570: PUSH
93571: LD_VAR 0 2
93575: PUSH
93576: FOR_IN
93577: IFFALSE 93593
// SetBLevel ( i , 10 ) ;
93579: LD_VAR 0 1
93583: PPUSH
93584: LD_INT 10
93586: PPUSH
93587: CALL_OW 241
93591: GO 93576
93593: POP
93594: POP
// end ;
93595: PPOPN 2
93597: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93598: LD_EXP 132
93602: PUSH
93603: LD_EXP 149
93607: AND
93608: IFFALSE 93719
93610: GO 93612
93612: DISABLE
93613: LD_INT 0
93615: PPUSH
93616: PPUSH
93617: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93618: LD_ADDR_VAR 0 3
93622: PUSH
93623: LD_INT 22
93625: PUSH
93626: LD_OWVAR 2
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 25
93637: PUSH
93638: LD_INT 1
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PPUSH
93649: CALL_OW 69
93653: ST_TO_ADDR
// if not tmp then
93654: LD_VAR 0 3
93658: NOT
93659: IFFALSE 93663
// exit ;
93661: GO 93719
// un := tmp [ rand ( 1 , tmp ) ] ;
93663: LD_ADDR_VAR 0 2
93667: PUSH
93668: LD_VAR 0 3
93672: PUSH
93673: LD_INT 1
93675: PPUSH
93676: LD_VAR 0 3
93680: PPUSH
93681: CALL_OW 12
93685: ARRAY
93686: ST_TO_ADDR
// if Crawls ( un ) then
93687: LD_VAR 0 2
93691: PPUSH
93692: CALL_OW 318
93696: IFFALSE 93707
// ComWalk ( un ) ;
93698: LD_VAR 0 2
93702: PPUSH
93703: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93707: LD_VAR 0 2
93711: PPUSH
93712: LD_INT 5
93714: PPUSH
93715: CALL_OW 336
// end ;
93719: PPOPN 3
93721: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
93722: LD_EXP 132
93726: PUSH
93727: LD_EXP 150
93731: AND
93732: PUSH
93733: LD_OWVAR 67
93737: PUSH
93738: LD_INT 3
93740: LESS
93741: AND
93742: IFFALSE 93761
93744: GO 93746
93746: DISABLE
// Difficulty := Difficulty + 1 ;
93747: LD_ADDR_OWVAR 67
93751: PUSH
93752: LD_OWVAR 67
93756: PUSH
93757: LD_INT 1
93759: PLUS
93760: ST_TO_ADDR
93761: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93762: LD_EXP 132
93766: PUSH
93767: LD_EXP 151
93771: AND
93772: IFFALSE 93875
93774: GO 93776
93776: DISABLE
93777: LD_INT 0
93779: PPUSH
// begin for i := 1 to 5 do
93780: LD_ADDR_VAR 0 1
93784: PUSH
93785: DOUBLE
93786: LD_INT 1
93788: DEC
93789: ST_TO_ADDR
93790: LD_INT 5
93792: PUSH
93793: FOR_TO
93794: IFFALSE 93873
// begin uc_nation := nation_nature ;
93796: LD_ADDR_OWVAR 21
93800: PUSH
93801: LD_INT 0
93803: ST_TO_ADDR
// uc_side := 0 ;
93804: LD_ADDR_OWVAR 20
93808: PUSH
93809: LD_INT 0
93811: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93812: LD_ADDR_OWVAR 29
93816: PUSH
93817: LD_INT 12
93819: PUSH
93820: LD_INT 12
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: ST_TO_ADDR
// hc_agressivity := 20 ;
93827: LD_ADDR_OWVAR 35
93831: PUSH
93832: LD_INT 20
93834: ST_TO_ADDR
// hc_class := class_tiger ;
93835: LD_ADDR_OWVAR 28
93839: PUSH
93840: LD_INT 14
93842: ST_TO_ADDR
// hc_gallery :=  ;
93843: LD_ADDR_OWVAR 33
93847: PUSH
93848: LD_STRING 
93850: ST_TO_ADDR
// hc_name :=  ;
93851: LD_ADDR_OWVAR 26
93855: PUSH
93856: LD_STRING 
93858: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93859: CALL_OW 44
93863: PPUSH
93864: LD_INT 0
93866: PPUSH
93867: CALL_OW 51
// end ;
93871: GO 93793
93873: POP
93874: POP
// end ;
93875: PPOPN 1
93877: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93878: LD_EXP 132
93882: PUSH
93883: LD_EXP 152
93887: AND
93888: IFFALSE 93897
93890: GO 93892
93892: DISABLE
// StreamSibBomb ;
93893: CALL 93898 0 0
93897: END
// export function StreamSibBomb ; var i , x , y ; begin
93898: LD_INT 0
93900: PPUSH
93901: PPUSH
93902: PPUSH
93903: PPUSH
// result := false ;
93904: LD_ADDR_VAR 0 1
93908: PUSH
93909: LD_INT 0
93911: ST_TO_ADDR
// for i := 1 to 16 do
93912: LD_ADDR_VAR 0 2
93916: PUSH
93917: DOUBLE
93918: LD_INT 1
93920: DEC
93921: ST_TO_ADDR
93922: LD_INT 16
93924: PUSH
93925: FOR_TO
93926: IFFALSE 94125
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93928: LD_ADDR_VAR 0 3
93932: PUSH
93933: LD_INT 10
93935: PUSH
93936: LD_INT 20
93938: PUSH
93939: LD_INT 30
93941: PUSH
93942: LD_INT 40
93944: PUSH
93945: LD_INT 50
93947: PUSH
93948: LD_INT 60
93950: PUSH
93951: LD_INT 70
93953: PUSH
93954: LD_INT 80
93956: PUSH
93957: LD_INT 90
93959: PUSH
93960: LD_INT 100
93962: PUSH
93963: LD_INT 110
93965: PUSH
93966: LD_INT 120
93968: PUSH
93969: LD_INT 130
93971: PUSH
93972: LD_INT 140
93974: PUSH
93975: LD_INT 150
93977: PUSH
93978: EMPTY
93979: LIST
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: PUSH
93995: LD_INT 1
93997: PPUSH
93998: LD_INT 15
94000: PPUSH
94001: CALL_OW 12
94005: ARRAY
94006: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94007: LD_ADDR_VAR 0 4
94011: PUSH
94012: LD_INT 10
94014: PUSH
94015: LD_INT 20
94017: PUSH
94018: LD_INT 30
94020: PUSH
94021: LD_INT 40
94023: PUSH
94024: LD_INT 50
94026: PUSH
94027: LD_INT 60
94029: PUSH
94030: LD_INT 70
94032: PUSH
94033: LD_INT 80
94035: PUSH
94036: LD_INT 90
94038: PUSH
94039: LD_INT 100
94041: PUSH
94042: LD_INT 110
94044: PUSH
94045: LD_INT 120
94047: PUSH
94048: LD_INT 130
94050: PUSH
94051: LD_INT 140
94053: PUSH
94054: LD_INT 150
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: PUSH
94074: LD_INT 1
94076: PPUSH
94077: LD_INT 15
94079: PPUSH
94080: CALL_OW 12
94084: ARRAY
94085: ST_TO_ADDR
// if ValidHex ( x , y ) then
94086: LD_VAR 0 3
94090: PPUSH
94091: LD_VAR 0 4
94095: PPUSH
94096: CALL_OW 488
94100: IFFALSE 94123
// begin result := [ x , y ] ;
94102: LD_ADDR_VAR 0 1
94106: PUSH
94107: LD_VAR 0 3
94111: PUSH
94112: LD_VAR 0 4
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: ST_TO_ADDR
// break ;
94121: GO 94125
// end ; end ;
94123: GO 93925
94125: POP
94126: POP
// if result then
94127: LD_VAR 0 1
94131: IFFALSE 94191
// begin ToLua ( playSibBomb() ) ;
94133: LD_STRING playSibBomb()
94135: PPUSH
94136: CALL_OW 559
// wait ( 0 0$14 ) ;
94140: LD_INT 490
94142: PPUSH
94143: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94147: LD_VAR 0 1
94151: PUSH
94152: LD_INT 1
94154: ARRAY
94155: PPUSH
94156: LD_VAR 0 1
94160: PUSH
94161: LD_INT 2
94163: ARRAY
94164: PPUSH
94165: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94169: LD_VAR 0 1
94173: PUSH
94174: LD_INT 1
94176: ARRAY
94177: PPUSH
94178: LD_VAR 0 1
94182: PUSH
94183: LD_INT 2
94185: ARRAY
94186: PPUSH
94187: CALL_OW 429
// end ; end ;
94191: LD_VAR 0 1
94195: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94196: LD_EXP 132
94200: PUSH
94201: LD_EXP 154
94205: AND
94206: IFFALSE 94218
94208: GO 94210
94210: DISABLE
// YouLost (  ) ;
94211: LD_STRING 
94213: PPUSH
94214: CALL_OW 104
94218: END
// every 0 0$1 trigger StreamModeActive and sFog do
94219: LD_EXP 132
94223: PUSH
94224: LD_EXP 153
94228: AND
94229: IFFALSE 94243
94231: GO 94233
94233: DISABLE
// FogOff ( your_side ) ;
94234: LD_OWVAR 2
94238: PPUSH
94239: CALL_OW 344
94243: END
// every 0 0$1 trigger StreamModeActive and sSun do
94244: LD_EXP 132
94248: PUSH
94249: LD_EXP 155
94253: AND
94254: IFFALSE 94282
94256: GO 94258
94258: DISABLE
// begin solar_recharge_percent := 0 ;
94259: LD_ADDR_OWVAR 79
94263: PUSH
94264: LD_INT 0
94266: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94267: LD_INT 10500
94269: PPUSH
94270: CALL_OW 67
// solar_recharge_percent := 100 ;
94274: LD_ADDR_OWVAR 79
94278: PUSH
94279: LD_INT 100
94281: ST_TO_ADDR
// end ;
94282: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94283: LD_EXP 132
94287: PUSH
94288: LD_EXP 156
94292: AND
94293: IFFALSE 94532
94295: GO 94297
94297: DISABLE
94298: LD_INT 0
94300: PPUSH
94301: PPUSH
94302: PPUSH
// begin tmp := [ ] ;
94303: LD_ADDR_VAR 0 3
94307: PUSH
94308: EMPTY
94309: ST_TO_ADDR
// for i := 1 to 6 do
94310: LD_ADDR_VAR 0 1
94314: PUSH
94315: DOUBLE
94316: LD_INT 1
94318: DEC
94319: ST_TO_ADDR
94320: LD_INT 6
94322: PUSH
94323: FOR_TO
94324: IFFALSE 94429
// begin uc_nation := nation_nature ;
94326: LD_ADDR_OWVAR 21
94330: PUSH
94331: LD_INT 0
94333: ST_TO_ADDR
// uc_side := 0 ;
94334: LD_ADDR_OWVAR 20
94338: PUSH
94339: LD_INT 0
94341: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94342: LD_ADDR_OWVAR 29
94346: PUSH
94347: LD_INT 12
94349: PUSH
94350: LD_INT 12
94352: PUSH
94353: EMPTY
94354: LIST
94355: LIST
94356: ST_TO_ADDR
// hc_agressivity := 20 ;
94357: LD_ADDR_OWVAR 35
94361: PUSH
94362: LD_INT 20
94364: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94365: LD_ADDR_OWVAR 28
94369: PUSH
94370: LD_INT 17
94372: ST_TO_ADDR
// hc_gallery :=  ;
94373: LD_ADDR_OWVAR 33
94377: PUSH
94378: LD_STRING 
94380: ST_TO_ADDR
// hc_name :=  ;
94381: LD_ADDR_OWVAR 26
94385: PUSH
94386: LD_STRING 
94388: ST_TO_ADDR
// un := CreateHuman ;
94389: LD_ADDR_VAR 0 2
94393: PUSH
94394: CALL_OW 44
94398: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94399: LD_VAR 0 2
94403: PPUSH
94404: LD_INT 1
94406: PPUSH
94407: CALL_OW 51
// tmp := tmp ^ un ;
94411: LD_ADDR_VAR 0 3
94415: PUSH
94416: LD_VAR 0 3
94420: PUSH
94421: LD_VAR 0 2
94425: ADD
94426: ST_TO_ADDR
// end ;
94427: GO 94323
94429: POP
94430: POP
// repeat wait ( 0 0$1 ) ;
94431: LD_INT 35
94433: PPUSH
94434: CALL_OW 67
// for un in tmp do
94438: LD_ADDR_VAR 0 2
94442: PUSH
94443: LD_VAR 0 3
94447: PUSH
94448: FOR_IN
94449: IFFALSE 94523
// begin if IsDead ( un ) then
94451: LD_VAR 0 2
94455: PPUSH
94456: CALL_OW 301
94460: IFFALSE 94480
// begin tmp := tmp diff un ;
94462: LD_ADDR_VAR 0 3
94466: PUSH
94467: LD_VAR 0 3
94471: PUSH
94472: LD_VAR 0 2
94476: DIFF
94477: ST_TO_ADDR
// continue ;
94478: GO 94448
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94480: LD_VAR 0 2
94484: PPUSH
94485: LD_INT 3
94487: PUSH
94488: LD_INT 22
94490: PUSH
94491: LD_INT 0
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: PUSH
94498: EMPTY
94499: LIST
94500: LIST
94501: PPUSH
94502: CALL_OW 69
94506: PPUSH
94507: LD_VAR 0 2
94511: PPUSH
94512: CALL_OW 74
94516: PPUSH
94517: CALL_OW 115
// end ;
94521: GO 94448
94523: POP
94524: POP
// until not tmp ;
94525: LD_VAR 0 3
94529: NOT
94530: IFFALSE 94431
// end ;
94532: PPOPN 3
94534: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94535: LD_EXP 132
94539: PUSH
94540: LD_EXP 157
94544: AND
94545: IFFALSE 94599
94547: GO 94549
94549: DISABLE
// begin ToLua ( displayTroll(); ) ;
94550: LD_STRING displayTroll();
94552: PPUSH
94553: CALL_OW 559
// wait ( 3 3$00 ) ;
94557: LD_INT 6300
94559: PPUSH
94560: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94564: LD_STRING hideTroll();
94566: PPUSH
94567: CALL_OW 559
// wait ( 1 1$00 ) ;
94571: LD_INT 2100
94573: PPUSH
94574: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94578: LD_STRING displayTroll();
94580: PPUSH
94581: CALL_OW 559
// wait ( 1 1$00 ) ;
94585: LD_INT 2100
94587: PPUSH
94588: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94592: LD_STRING hideTroll();
94594: PPUSH
94595: CALL_OW 559
// end ;
94599: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94600: LD_EXP 132
94604: PUSH
94605: LD_EXP 158
94609: AND
94610: IFFALSE 94673
94612: GO 94614
94614: DISABLE
94615: LD_INT 0
94617: PPUSH
// begin p := 0 ;
94618: LD_ADDR_VAR 0 1
94622: PUSH
94623: LD_INT 0
94625: ST_TO_ADDR
// repeat game_speed := 1 ;
94626: LD_ADDR_OWVAR 65
94630: PUSH
94631: LD_INT 1
94633: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94634: LD_INT 35
94636: PPUSH
94637: CALL_OW 67
// p := p + 1 ;
94641: LD_ADDR_VAR 0 1
94645: PUSH
94646: LD_VAR 0 1
94650: PUSH
94651: LD_INT 1
94653: PLUS
94654: ST_TO_ADDR
// until p >= 60 ;
94655: LD_VAR 0 1
94659: PUSH
94660: LD_INT 60
94662: GREATEREQUAL
94663: IFFALSE 94626
// game_speed := 4 ;
94665: LD_ADDR_OWVAR 65
94669: PUSH
94670: LD_INT 4
94672: ST_TO_ADDR
// end ;
94673: PPOPN 1
94675: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94676: LD_EXP 132
94680: PUSH
94681: LD_EXP 159
94685: AND
94686: IFFALSE 94832
94688: GO 94690
94690: DISABLE
94691: LD_INT 0
94693: PPUSH
94694: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94695: LD_ADDR_VAR 0 1
94699: PUSH
94700: LD_INT 22
94702: PUSH
94703: LD_OWVAR 2
94707: PUSH
94708: EMPTY
94709: LIST
94710: LIST
94711: PUSH
94712: LD_INT 2
94714: PUSH
94715: LD_INT 30
94717: PUSH
94718: LD_INT 0
94720: PUSH
94721: EMPTY
94722: LIST
94723: LIST
94724: PUSH
94725: LD_INT 30
94727: PUSH
94728: LD_INT 1
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: PUSH
94735: EMPTY
94736: LIST
94737: LIST
94738: LIST
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PPUSH
94744: CALL_OW 69
94748: ST_TO_ADDR
// if not depot then
94749: LD_VAR 0 1
94753: NOT
94754: IFFALSE 94758
// exit ;
94756: GO 94832
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94758: LD_ADDR_VAR 0 2
94762: PUSH
94763: LD_VAR 0 1
94767: PUSH
94768: LD_INT 1
94770: PPUSH
94771: LD_VAR 0 1
94775: PPUSH
94776: CALL_OW 12
94780: ARRAY
94781: PPUSH
94782: CALL_OW 274
94786: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94787: LD_VAR 0 2
94791: PPUSH
94792: LD_INT 1
94794: PPUSH
94795: LD_INT 0
94797: PPUSH
94798: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94802: LD_VAR 0 2
94806: PPUSH
94807: LD_INT 2
94809: PPUSH
94810: LD_INT 0
94812: PPUSH
94813: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94817: LD_VAR 0 2
94821: PPUSH
94822: LD_INT 3
94824: PPUSH
94825: LD_INT 0
94827: PPUSH
94828: CALL_OW 277
// end ;
94832: PPOPN 2
94834: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94835: LD_EXP 132
94839: PUSH
94840: LD_EXP 160
94844: AND
94845: IFFALSE 94942
94847: GO 94849
94849: DISABLE
94850: LD_INT 0
94852: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94853: LD_ADDR_VAR 0 1
94857: PUSH
94858: LD_INT 22
94860: PUSH
94861: LD_OWVAR 2
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: PUSH
94870: LD_INT 21
94872: PUSH
94873: LD_INT 1
94875: PUSH
94876: EMPTY
94877: LIST
94878: LIST
94879: PUSH
94880: LD_INT 3
94882: PUSH
94883: LD_INT 23
94885: PUSH
94886: LD_INT 0
94888: PUSH
94889: EMPTY
94890: LIST
94891: LIST
94892: PUSH
94893: EMPTY
94894: LIST
94895: LIST
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: LIST
94901: PPUSH
94902: CALL_OW 69
94906: ST_TO_ADDR
// if not tmp then
94907: LD_VAR 0 1
94911: NOT
94912: IFFALSE 94916
// exit ;
94914: GO 94942
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94916: LD_VAR 0 1
94920: PUSH
94921: LD_INT 1
94923: PPUSH
94924: LD_VAR 0 1
94928: PPUSH
94929: CALL_OW 12
94933: ARRAY
94934: PPUSH
94935: LD_INT 200
94937: PPUSH
94938: CALL_OW 234
// end ;
94942: PPOPN 1
94944: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94945: LD_EXP 132
94949: PUSH
94950: LD_EXP 161
94954: AND
94955: IFFALSE 95034
94957: GO 94959
94959: DISABLE
94960: LD_INT 0
94962: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94963: LD_ADDR_VAR 0 1
94967: PUSH
94968: LD_INT 22
94970: PUSH
94971: LD_OWVAR 2
94975: PUSH
94976: EMPTY
94977: LIST
94978: LIST
94979: PUSH
94980: LD_INT 21
94982: PUSH
94983: LD_INT 2
94985: PUSH
94986: EMPTY
94987: LIST
94988: LIST
94989: PUSH
94990: EMPTY
94991: LIST
94992: LIST
94993: PPUSH
94994: CALL_OW 69
94998: ST_TO_ADDR
// if not tmp then
94999: LD_VAR 0 1
95003: NOT
95004: IFFALSE 95008
// exit ;
95006: GO 95034
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95008: LD_VAR 0 1
95012: PUSH
95013: LD_INT 1
95015: PPUSH
95016: LD_VAR 0 1
95020: PPUSH
95021: CALL_OW 12
95025: ARRAY
95026: PPUSH
95027: LD_INT 60
95029: PPUSH
95030: CALL_OW 234
// end ;
95034: PPOPN 1
95036: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95037: LD_EXP 132
95041: PUSH
95042: LD_EXP 162
95046: AND
95047: IFFALSE 95146
95049: GO 95051
95051: DISABLE
95052: LD_INT 0
95054: PPUSH
95055: PPUSH
// begin enable ;
95056: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95057: LD_ADDR_VAR 0 1
95061: PUSH
95062: LD_INT 22
95064: PUSH
95065: LD_OWVAR 2
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: LD_INT 61
95076: PUSH
95077: EMPTY
95078: LIST
95079: PUSH
95080: LD_INT 33
95082: PUSH
95083: LD_INT 2
95085: PUSH
95086: EMPTY
95087: LIST
95088: LIST
95089: PUSH
95090: EMPTY
95091: LIST
95092: LIST
95093: LIST
95094: PPUSH
95095: CALL_OW 69
95099: ST_TO_ADDR
// if not tmp then
95100: LD_VAR 0 1
95104: NOT
95105: IFFALSE 95109
// exit ;
95107: GO 95146
// for i in tmp do
95109: LD_ADDR_VAR 0 2
95113: PUSH
95114: LD_VAR 0 1
95118: PUSH
95119: FOR_IN
95120: IFFALSE 95144
// if IsControledBy ( i ) then
95122: LD_VAR 0 2
95126: PPUSH
95127: CALL_OW 312
95131: IFFALSE 95142
// ComUnlink ( i ) ;
95133: LD_VAR 0 2
95137: PPUSH
95138: CALL_OW 136
95142: GO 95119
95144: POP
95145: POP
// end ;
95146: PPOPN 2
95148: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95149: LD_EXP 132
95153: PUSH
95154: LD_EXP 163
95158: AND
95159: IFFALSE 95299
95161: GO 95163
95163: DISABLE
95164: LD_INT 0
95166: PPUSH
95167: PPUSH
// begin ToLua ( displayPowell(); ) ;
95168: LD_STRING displayPowell();
95170: PPUSH
95171: CALL_OW 559
// uc_side := 0 ;
95175: LD_ADDR_OWVAR 20
95179: PUSH
95180: LD_INT 0
95182: ST_TO_ADDR
// uc_nation := 2 ;
95183: LD_ADDR_OWVAR 21
95187: PUSH
95188: LD_INT 2
95190: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95191: LD_ADDR_OWVAR 37
95195: PUSH
95196: LD_INT 14
95198: ST_TO_ADDR
// vc_engine := engine_siberite ;
95199: LD_ADDR_OWVAR 39
95203: PUSH
95204: LD_INT 3
95206: ST_TO_ADDR
// vc_control := control_apeman ;
95207: LD_ADDR_OWVAR 38
95211: PUSH
95212: LD_INT 5
95214: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95215: LD_ADDR_OWVAR 40
95219: PUSH
95220: LD_INT 29
95222: ST_TO_ADDR
// un := CreateVehicle ;
95223: LD_ADDR_VAR 0 2
95227: PUSH
95228: CALL_OW 45
95232: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95233: LD_VAR 0 2
95237: PPUSH
95238: LD_INT 1
95240: PPUSH
95241: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95245: LD_INT 35
95247: PPUSH
95248: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95252: LD_VAR 0 2
95256: PPUSH
95257: LD_INT 22
95259: PUSH
95260: LD_OWVAR 2
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: PPUSH
95269: CALL_OW 69
95273: PPUSH
95274: LD_VAR 0 2
95278: PPUSH
95279: CALL_OW 74
95283: PPUSH
95284: CALL_OW 115
// until IsDead ( un ) ;
95288: LD_VAR 0 2
95292: PPUSH
95293: CALL_OW 301
95297: IFFALSE 95245
// end ;
95299: PPOPN 2
95301: END
// every 0 0$1 trigger StreamModeActive and sStu do
95302: LD_EXP 132
95306: PUSH
95307: LD_EXP 171
95311: AND
95312: IFFALSE 95328
95314: GO 95316
95316: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95317: LD_STRING displayStucuk();
95319: PPUSH
95320: CALL_OW 559
// ResetFog ;
95324: CALL_OW 335
// end ;
95328: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95329: LD_EXP 132
95333: PUSH
95334: LD_EXP 164
95338: AND
95339: IFFALSE 95480
95341: GO 95343
95343: DISABLE
95344: LD_INT 0
95346: PPUSH
95347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95348: LD_ADDR_VAR 0 2
95352: PUSH
95353: LD_INT 22
95355: PUSH
95356: LD_OWVAR 2
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: PUSH
95365: LD_INT 21
95367: PUSH
95368: LD_INT 1
95370: PUSH
95371: EMPTY
95372: LIST
95373: LIST
95374: PUSH
95375: EMPTY
95376: LIST
95377: LIST
95378: PPUSH
95379: CALL_OW 69
95383: ST_TO_ADDR
// if not tmp then
95384: LD_VAR 0 2
95388: NOT
95389: IFFALSE 95393
// exit ;
95391: GO 95480
// un := tmp [ rand ( 1 , tmp ) ] ;
95393: LD_ADDR_VAR 0 1
95397: PUSH
95398: LD_VAR 0 2
95402: PUSH
95403: LD_INT 1
95405: PPUSH
95406: LD_VAR 0 2
95410: PPUSH
95411: CALL_OW 12
95415: ARRAY
95416: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95417: LD_VAR 0 1
95421: PPUSH
95422: LD_INT 0
95424: PPUSH
95425: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95429: LD_VAR 0 1
95433: PPUSH
95434: LD_OWVAR 3
95438: PUSH
95439: LD_VAR 0 1
95443: DIFF
95444: PPUSH
95445: LD_VAR 0 1
95449: PPUSH
95450: CALL_OW 74
95454: PPUSH
95455: CALL_OW 115
// wait ( 0 0$20 ) ;
95459: LD_INT 700
95461: PPUSH
95462: CALL_OW 67
// SetSide ( un , your_side ) ;
95466: LD_VAR 0 1
95470: PPUSH
95471: LD_OWVAR 2
95475: PPUSH
95476: CALL_OW 235
// end ;
95480: PPOPN 2
95482: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95483: LD_EXP 132
95487: PUSH
95488: LD_EXP 165
95492: AND
95493: IFFALSE 95599
95495: GO 95497
95497: DISABLE
95498: LD_INT 0
95500: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95501: LD_ADDR_VAR 0 1
95505: PUSH
95506: LD_INT 22
95508: PUSH
95509: LD_OWVAR 2
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 2
95520: PUSH
95521: LD_INT 30
95523: PUSH
95524: LD_INT 0
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: LD_INT 30
95533: PUSH
95534: LD_INT 1
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: LIST
95545: PUSH
95546: EMPTY
95547: LIST
95548: LIST
95549: PPUSH
95550: CALL_OW 69
95554: ST_TO_ADDR
// if not depot then
95555: LD_VAR 0 1
95559: NOT
95560: IFFALSE 95564
// exit ;
95562: GO 95599
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95564: LD_VAR 0 1
95568: PUSH
95569: LD_INT 1
95571: ARRAY
95572: PPUSH
95573: CALL_OW 250
95577: PPUSH
95578: LD_VAR 0 1
95582: PUSH
95583: LD_INT 1
95585: ARRAY
95586: PPUSH
95587: CALL_OW 251
95591: PPUSH
95592: LD_INT 70
95594: PPUSH
95595: CALL_OW 495
// end ;
95599: PPOPN 1
95601: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95602: LD_EXP 132
95606: PUSH
95607: LD_EXP 166
95611: AND
95612: IFFALSE 95823
95614: GO 95616
95616: DISABLE
95617: LD_INT 0
95619: PPUSH
95620: PPUSH
95621: PPUSH
95622: PPUSH
95623: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95624: LD_ADDR_VAR 0 5
95628: PUSH
95629: LD_INT 22
95631: PUSH
95632: LD_OWVAR 2
95636: PUSH
95637: EMPTY
95638: LIST
95639: LIST
95640: PUSH
95641: LD_INT 21
95643: PUSH
95644: LD_INT 1
95646: PUSH
95647: EMPTY
95648: LIST
95649: LIST
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: PPUSH
95655: CALL_OW 69
95659: ST_TO_ADDR
// if not tmp then
95660: LD_VAR 0 5
95664: NOT
95665: IFFALSE 95669
// exit ;
95667: GO 95823
// for i in tmp do
95669: LD_ADDR_VAR 0 1
95673: PUSH
95674: LD_VAR 0 5
95678: PUSH
95679: FOR_IN
95680: IFFALSE 95821
// begin d := rand ( 0 , 5 ) ;
95682: LD_ADDR_VAR 0 4
95686: PUSH
95687: LD_INT 0
95689: PPUSH
95690: LD_INT 5
95692: PPUSH
95693: CALL_OW 12
95697: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95698: LD_ADDR_VAR 0 2
95702: PUSH
95703: LD_VAR 0 1
95707: PPUSH
95708: CALL_OW 250
95712: PPUSH
95713: LD_VAR 0 4
95717: PPUSH
95718: LD_INT 3
95720: PPUSH
95721: LD_INT 12
95723: PPUSH
95724: CALL_OW 12
95728: PPUSH
95729: CALL_OW 272
95733: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95734: LD_ADDR_VAR 0 3
95738: PUSH
95739: LD_VAR 0 1
95743: PPUSH
95744: CALL_OW 251
95748: PPUSH
95749: LD_VAR 0 4
95753: PPUSH
95754: LD_INT 3
95756: PPUSH
95757: LD_INT 12
95759: PPUSH
95760: CALL_OW 12
95764: PPUSH
95765: CALL_OW 273
95769: ST_TO_ADDR
// if ValidHex ( x , y ) then
95770: LD_VAR 0 2
95774: PPUSH
95775: LD_VAR 0 3
95779: PPUSH
95780: CALL_OW 488
95784: IFFALSE 95819
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95786: LD_VAR 0 1
95790: PPUSH
95791: LD_VAR 0 2
95795: PPUSH
95796: LD_VAR 0 3
95800: PPUSH
95801: LD_INT 3
95803: PPUSH
95804: LD_INT 6
95806: PPUSH
95807: CALL_OW 12
95811: PPUSH
95812: LD_INT 1
95814: PPUSH
95815: CALL_OW 483
// end ;
95819: GO 95679
95821: POP
95822: POP
// end ;
95823: PPOPN 5
95825: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95826: LD_EXP 132
95830: PUSH
95831: LD_EXP 167
95835: AND
95836: IFFALSE 95930
95838: GO 95840
95840: DISABLE
95841: LD_INT 0
95843: PPUSH
95844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95845: LD_ADDR_VAR 0 2
95849: PUSH
95850: LD_INT 22
95852: PUSH
95853: LD_OWVAR 2
95857: PUSH
95858: EMPTY
95859: LIST
95860: LIST
95861: PUSH
95862: LD_INT 32
95864: PUSH
95865: LD_INT 1
95867: PUSH
95868: EMPTY
95869: LIST
95870: LIST
95871: PUSH
95872: LD_INT 21
95874: PUSH
95875: LD_INT 2
95877: PUSH
95878: EMPTY
95879: LIST
95880: LIST
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: LIST
95886: PPUSH
95887: CALL_OW 69
95891: ST_TO_ADDR
// if not tmp then
95892: LD_VAR 0 2
95896: NOT
95897: IFFALSE 95901
// exit ;
95899: GO 95930
// for i in tmp do
95901: LD_ADDR_VAR 0 1
95905: PUSH
95906: LD_VAR 0 2
95910: PUSH
95911: FOR_IN
95912: IFFALSE 95928
// SetFuel ( i , 0 ) ;
95914: LD_VAR 0 1
95918: PPUSH
95919: LD_INT 0
95921: PPUSH
95922: CALL_OW 240
95926: GO 95911
95928: POP
95929: POP
// end ;
95930: PPOPN 2
95932: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95933: LD_EXP 132
95937: PUSH
95938: LD_EXP 168
95942: AND
95943: IFFALSE 96009
95945: GO 95947
95947: DISABLE
95948: LD_INT 0
95950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95951: LD_ADDR_VAR 0 1
95955: PUSH
95956: LD_INT 22
95958: PUSH
95959: LD_OWVAR 2
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: PUSH
95968: LD_INT 30
95970: PUSH
95971: LD_INT 29
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: EMPTY
95979: LIST
95980: LIST
95981: PPUSH
95982: CALL_OW 69
95986: ST_TO_ADDR
// if not tmp then
95987: LD_VAR 0 1
95991: NOT
95992: IFFALSE 95996
// exit ;
95994: GO 96009
// DestroyUnit ( tmp [ 1 ] ) ;
95996: LD_VAR 0 1
96000: PUSH
96001: LD_INT 1
96003: ARRAY
96004: PPUSH
96005: CALL_OW 65
// end ;
96009: PPOPN 1
96011: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96012: LD_EXP 132
96016: PUSH
96017: LD_EXP 170
96021: AND
96022: IFFALSE 96151
96024: GO 96026
96026: DISABLE
96027: LD_INT 0
96029: PPUSH
// begin uc_side := 0 ;
96030: LD_ADDR_OWVAR 20
96034: PUSH
96035: LD_INT 0
96037: ST_TO_ADDR
// uc_nation := nation_arabian ;
96038: LD_ADDR_OWVAR 21
96042: PUSH
96043: LD_INT 2
96045: ST_TO_ADDR
// hc_gallery :=  ;
96046: LD_ADDR_OWVAR 33
96050: PUSH
96051: LD_STRING 
96053: ST_TO_ADDR
// hc_name :=  ;
96054: LD_ADDR_OWVAR 26
96058: PUSH
96059: LD_STRING 
96061: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96062: LD_INT 1
96064: PPUSH
96065: LD_INT 11
96067: PPUSH
96068: LD_INT 10
96070: PPUSH
96071: CALL_OW 380
// un := CreateHuman ;
96075: LD_ADDR_VAR 0 1
96079: PUSH
96080: CALL_OW 44
96084: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96085: LD_VAR 0 1
96089: PPUSH
96090: LD_INT 1
96092: PPUSH
96093: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96097: LD_INT 35
96099: PPUSH
96100: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96104: LD_VAR 0 1
96108: PPUSH
96109: LD_INT 22
96111: PUSH
96112: LD_OWVAR 2
96116: PUSH
96117: EMPTY
96118: LIST
96119: LIST
96120: PPUSH
96121: CALL_OW 69
96125: PPUSH
96126: LD_VAR 0 1
96130: PPUSH
96131: CALL_OW 74
96135: PPUSH
96136: CALL_OW 115
// until IsDead ( un ) ;
96140: LD_VAR 0 1
96144: PPUSH
96145: CALL_OW 301
96149: IFFALSE 96097
// end ;
96151: PPOPN 1
96153: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96154: LD_EXP 132
96158: PUSH
96159: LD_EXP 172
96163: AND
96164: IFFALSE 96176
96166: GO 96168
96168: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96169: LD_STRING earthquake(getX(game), 0, 32)
96171: PPUSH
96172: CALL_OW 559
96176: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96177: LD_EXP 132
96181: PUSH
96182: LD_EXP 173
96186: AND
96187: IFFALSE 96278
96189: GO 96191
96191: DISABLE
96192: LD_INT 0
96194: PPUSH
// begin enable ;
96195: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96196: LD_ADDR_VAR 0 1
96200: PUSH
96201: LD_INT 22
96203: PUSH
96204: LD_OWVAR 2
96208: PUSH
96209: EMPTY
96210: LIST
96211: LIST
96212: PUSH
96213: LD_INT 21
96215: PUSH
96216: LD_INT 2
96218: PUSH
96219: EMPTY
96220: LIST
96221: LIST
96222: PUSH
96223: LD_INT 33
96225: PUSH
96226: LD_INT 3
96228: PUSH
96229: EMPTY
96230: LIST
96231: LIST
96232: PUSH
96233: EMPTY
96234: LIST
96235: LIST
96236: LIST
96237: PPUSH
96238: CALL_OW 69
96242: ST_TO_ADDR
// if not tmp then
96243: LD_VAR 0 1
96247: NOT
96248: IFFALSE 96252
// exit ;
96250: GO 96278
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96252: LD_VAR 0 1
96256: PUSH
96257: LD_INT 1
96259: PPUSH
96260: LD_VAR 0 1
96264: PPUSH
96265: CALL_OW 12
96269: ARRAY
96270: PPUSH
96271: LD_INT 1
96273: PPUSH
96274: CALL_OW 234
// end ;
96278: PPOPN 1
96280: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96281: LD_EXP 132
96285: PUSH
96286: LD_EXP 174
96290: AND
96291: IFFALSE 96432
96293: GO 96295
96295: DISABLE
96296: LD_INT 0
96298: PPUSH
96299: PPUSH
96300: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96301: LD_ADDR_VAR 0 3
96305: PUSH
96306: LD_INT 22
96308: PUSH
96309: LD_OWVAR 2
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: PUSH
96318: LD_INT 25
96320: PUSH
96321: LD_INT 1
96323: PUSH
96324: EMPTY
96325: LIST
96326: LIST
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PPUSH
96332: CALL_OW 69
96336: ST_TO_ADDR
// if not tmp then
96337: LD_VAR 0 3
96341: NOT
96342: IFFALSE 96346
// exit ;
96344: GO 96432
// un := tmp [ rand ( 1 , tmp ) ] ;
96346: LD_ADDR_VAR 0 2
96350: PUSH
96351: LD_VAR 0 3
96355: PUSH
96356: LD_INT 1
96358: PPUSH
96359: LD_VAR 0 3
96363: PPUSH
96364: CALL_OW 12
96368: ARRAY
96369: ST_TO_ADDR
// if Crawls ( un ) then
96370: LD_VAR 0 2
96374: PPUSH
96375: CALL_OW 318
96379: IFFALSE 96390
// ComWalk ( un ) ;
96381: LD_VAR 0 2
96385: PPUSH
96386: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96390: LD_VAR 0 2
96394: PPUSH
96395: LD_INT 9
96397: PPUSH
96398: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96402: LD_INT 28
96404: PPUSH
96405: LD_OWVAR 2
96409: PPUSH
96410: LD_INT 2
96412: PPUSH
96413: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96417: LD_INT 29
96419: PPUSH
96420: LD_OWVAR 2
96424: PPUSH
96425: LD_INT 2
96427: PPUSH
96428: CALL_OW 322
// end ;
96432: PPOPN 3
96434: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96435: LD_EXP 132
96439: PUSH
96440: LD_EXP 175
96444: AND
96445: IFFALSE 96556
96447: GO 96449
96449: DISABLE
96450: LD_INT 0
96452: PPUSH
96453: PPUSH
96454: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96455: LD_ADDR_VAR 0 3
96459: PUSH
96460: LD_INT 22
96462: PUSH
96463: LD_OWVAR 2
96467: PUSH
96468: EMPTY
96469: LIST
96470: LIST
96471: PUSH
96472: LD_INT 25
96474: PUSH
96475: LD_INT 1
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: PPUSH
96486: CALL_OW 69
96490: ST_TO_ADDR
// if not tmp then
96491: LD_VAR 0 3
96495: NOT
96496: IFFALSE 96500
// exit ;
96498: GO 96556
// un := tmp [ rand ( 1 , tmp ) ] ;
96500: LD_ADDR_VAR 0 2
96504: PUSH
96505: LD_VAR 0 3
96509: PUSH
96510: LD_INT 1
96512: PPUSH
96513: LD_VAR 0 3
96517: PPUSH
96518: CALL_OW 12
96522: ARRAY
96523: ST_TO_ADDR
// if Crawls ( un ) then
96524: LD_VAR 0 2
96528: PPUSH
96529: CALL_OW 318
96533: IFFALSE 96544
// ComWalk ( un ) ;
96535: LD_VAR 0 2
96539: PPUSH
96540: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96544: LD_VAR 0 2
96548: PPUSH
96549: LD_INT 8
96551: PPUSH
96552: CALL_OW 336
// end ;
96556: PPOPN 3
96558: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96559: LD_EXP 132
96563: PUSH
96564: LD_EXP 176
96568: AND
96569: IFFALSE 96713
96571: GO 96573
96573: DISABLE
96574: LD_INT 0
96576: PPUSH
96577: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96578: LD_ADDR_VAR 0 2
96582: PUSH
96583: LD_INT 22
96585: PUSH
96586: LD_OWVAR 2
96590: PUSH
96591: EMPTY
96592: LIST
96593: LIST
96594: PUSH
96595: LD_INT 21
96597: PUSH
96598: LD_INT 2
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: PUSH
96605: LD_INT 2
96607: PUSH
96608: LD_INT 34
96610: PUSH
96611: LD_INT 12
96613: PUSH
96614: EMPTY
96615: LIST
96616: LIST
96617: PUSH
96618: LD_INT 34
96620: PUSH
96621: LD_INT 51
96623: PUSH
96624: EMPTY
96625: LIST
96626: LIST
96627: PUSH
96628: LD_INT 34
96630: PUSH
96631: LD_INT 32
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: PUSH
96638: EMPTY
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: LIST
96648: PPUSH
96649: CALL_OW 69
96653: ST_TO_ADDR
// if not tmp then
96654: LD_VAR 0 2
96658: NOT
96659: IFFALSE 96663
// exit ;
96661: GO 96713
// for i in tmp do
96663: LD_ADDR_VAR 0 1
96667: PUSH
96668: LD_VAR 0 2
96672: PUSH
96673: FOR_IN
96674: IFFALSE 96711
// if GetCargo ( i , mat_artifact ) = 0 then
96676: LD_VAR 0 1
96680: PPUSH
96681: LD_INT 4
96683: PPUSH
96684: CALL_OW 289
96688: PUSH
96689: LD_INT 0
96691: EQUAL
96692: IFFALSE 96709
// SetCargo ( i , mat_siberit , 100 ) ;
96694: LD_VAR 0 1
96698: PPUSH
96699: LD_INT 3
96701: PPUSH
96702: LD_INT 100
96704: PPUSH
96705: CALL_OW 290
96709: GO 96673
96711: POP
96712: POP
// end ;
96713: PPOPN 2
96715: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96716: LD_EXP 132
96720: PUSH
96721: LD_EXP 177
96725: AND
96726: IFFALSE 96909
96728: GO 96730
96730: DISABLE
96731: LD_INT 0
96733: PPUSH
96734: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96735: LD_ADDR_VAR 0 2
96739: PUSH
96740: LD_INT 22
96742: PUSH
96743: LD_OWVAR 2
96747: PUSH
96748: EMPTY
96749: LIST
96750: LIST
96751: PPUSH
96752: CALL_OW 69
96756: ST_TO_ADDR
// if not tmp then
96757: LD_VAR 0 2
96761: NOT
96762: IFFALSE 96766
// exit ;
96764: GO 96909
// for i := 1 to 2 do
96766: LD_ADDR_VAR 0 1
96770: PUSH
96771: DOUBLE
96772: LD_INT 1
96774: DEC
96775: ST_TO_ADDR
96776: LD_INT 2
96778: PUSH
96779: FOR_TO
96780: IFFALSE 96907
// begin uc_side := your_side ;
96782: LD_ADDR_OWVAR 20
96786: PUSH
96787: LD_OWVAR 2
96791: ST_TO_ADDR
// uc_nation := nation_american ;
96792: LD_ADDR_OWVAR 21
96796: PUSH
96797: LD_INT 1
96799: ST_TO_ADDR
// vc_chassis := us_morphling ;
96800: LD_ADDR_OWVAR 37
96804: PUSH
96805: LD_INT 5
96807: ST_TO_ADDR
// vc_engine := engine_siberite ;
96808: LD_ADDR_OWVAR 39
96812: PUSH
96813: LD_INT 3
96815: ST_TO_ADDR
// vc_control := control_computer ;
96816: LD_ADDR_OWVAR 38
96820: PUSH
96821: LD_INT 3
96823: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96824: LD_ADDR_OWVAR 40
96828: PUSH
96829: LD_INT 10
96831: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96832: LD_VAR 0 2
96836: PUSH
96837: LD_INT 1
96839: ARRAY
96840: PPUSH
96841: CALL_OW 310
96845: NOT
96846: IFFALSE 96893
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96848: CALL_OW 45
96852: PPUSH
96853: LD_VAR 0 2
96857: PUSH
96858: LD_INT 1
96860: ARRAY
96861: PPUSH
96862: CALL_OW 250
96866: PPUSH
96867: LD_VAR 0 2
96871: PUSH
96872: LD_INT 1
96874: ARRAY
96875: PPUSH
96876: CALL_OW 251
96880: PPUSH
96881: LD_INT 12
96883: PPUSH
96884: LD_INT 1
96886: PPUSH
96887: CALL_OW 50
96891: GO 96905
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96893: CALL_OW 45
96897: PPUSH
96898: LD_INT 1
96900: PPUSH
96901: CALL_OW 51
// end ;
96905: GO 96779
96907: POP
96908: POP
// end ;
96909: PPOPN 2
96911: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96912: LD_EXP 132
96916: PUSH
96917: LD_EXP 178
96921: AND
96922: IFFALSE 97144
96924: GO 96926
96926: DISABLE
96927: LD_INT 0
96929: PPUSH
96930: PPUSH
96931: PPUSH
96932: PPUSH
96933: PPUSH
96934: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96935: LD_ADDR_VAR 0 6
96939: PUSH
96940: LD_INT 22
96942: PUSH
96943: LD_OWVAR 2
96947: PUSH
96948: EMPTY
96949: LIST
96950: LIST
96951: PUSH
96952: LD_INT 21
96954: PUSH
96955: LD_INT 1
96957: PUSH
96958: EMPTY
96959: LIST
96960: LIST
96961: PUSH
96962: LD_INT 3
96964: PUSH
96965: LD_INT 23
96967: PUSH
96968: LD_INT 0
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: LIST
96983: PPUSH
96984: CALL_OW 69
96988: ST_TO_ADDR
// if not tmp then
96989: LD_VAR 0 6
96993: NOT
96994: IFFALSE 96998
// exit ;
96996: GO 97144
// s1 := rand ( 1 , 4 ) ;
96998: LD_ADDR_VAR 0 2
97002: PUSH
97003: LD_INT 1
97005: PPUSH
97006: LD_INT 4
97008: PPUSH
97009: CALL_OW 12
97013: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97014: LD_ADDR_VAR 0 4
97018: PUSH
97019: LD_VAR 0 6
97023: PUSH
97024: LD_INT 1
97026: ARRAY
97027: PPUSH
97028: LD_VAR 0 2
97032: PPUSH
97033: CALL_OW 259
97037: ST_TO_ADDR
// if s1 = 1 then
97038: LD_VAR 0 2
97042: PUSH
97043: LD_INT 1
97045: EQUAL
97046: IFFALSE 97066
// s2 := rand ( 2 , 4 ) else
97048: LD_ADDR_VAR 0 3
97052: PUSH
97053: LD_INT 2
97055: PPUSH
97056: LD_INT 4
97058: PPUSH
97059: CALL_OW 12
97063: ST_TO_ADDR
97064: GO 97074
// s2 := 1 ;
97066: LD_ADDR_VAR 0 3
97070: PUSH
97071: LD_INT 1
97073: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97074: LD_ADDR_VAR 0 5
97078: PUSH
97079: LD_VAR 0 6
97083: PUSH
97084: LD_INT 1
97086: ARRAY
97087: PPUSH
97088: LD_VAR 0 3
97092: PPUSH
97093: CALL_OW 259
97097: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97098: LD_VAR 0 6
97102: PUSH
97103: LD_INT 1
97105: ARRAY
97106: PPUSH
97107: LD_VAR 0 2
97111: PPUSH
97112: LD_VAR 0 5
97116: PPUSH
97117: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97121: LD_VAR 0 6
97125: PUSH
97126: LD_INT 1
97128: ARRAY
97129: PPUSH
97130: LD_VAR 0 3
97134: PPUSH
97135: LD_VAR 0 4
97139: PPUSH
97140: CALL_OW 237
// end ;
97144: PPOPN 6
97146: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97147: LD_EXP 132
97151: PUSH
97152: LD_EXP 179
97156: AND
97157: IFFALSE 97236
97159: GO 97161
97161: DISABLE
97162: LD_INT 0
97164: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97165: LD_ADDR_VAR 0 1
97169: PUSH
97170: LD_INT 22
97172: PUSH
97173: LD_OWVAR 2
97177: PUSH
97178: EMPTY
97179: LIST
97180: LIST
97181: PUSH
97182: LD_INT 30
97184: PUSH
97185: LD_INT 3
97187: PUSH
97188: EMPTY
97189: LIST
97190: LIST
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PPUSH
97196: CALL_OW 69
97200: ST_TO_ADDR
// if not tmp then
97201: LD_VAR 0 1
97205: NOT
97206: IFFALSE 97210
// exit ;
97208: GO 97236
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97210: LD_VAR 0 1
97214: PUSH
97215: LD_INT 1
97217: PPUSH
97218: LD_VAR 0 1
97222: PPUSH
97223: CALL_OW 12
97227: ARRAY
97228: PPUSH
97229: LD_INT 1
97231: PPUSH
97232: CALL_OW 234
// end ;
97236: PPOPN 1
97238: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97239: LD_EXP 132
97243: PUSH
97244: LD_EXP 180
97248: AND
97249: IFFALSE 97361
97251: GO 97253
97253: DISABLE
97254: LD_INT 0
97256: PPUSH
97257: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97258: LD_ADDR_VAR 0 2
97262: PUSH
97263: LD_INT 22
97265: PUSH
97266: LD_OWVAR 2
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PUSH
97275: LD_INT 2
97277: PUSH
97278: LD_INT 30
97280: PUSH
97281: LD_INT 27
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: PUSH
97288: LD_INT 30
97290: PUSH
97291: LD_INT 26
97293: PUSH
97294: EMPTY
97295: LIST
97296: LIST
97297: PUSH
97298: LD_INT 30
97300: PUSH
97301: LD_INT 28
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: PUSH
97308: EMPTY
97309: LIST
97310: LIST
97311: LIST
97312: LIST
97313: PUSH
97314: EMPTY
97315: LIST
97316: LIST
97317: PPUSH
97318: CALL_OW 69
97322: ST_TO_ADDR
// if not tmp then
97323: LD_VAR 0 2
97327: NOT
97328: IFFALSE 97332
// exit ;
97330: GO 97361
// for i in tmp do
97332: LD_ADDR_VAR 0 1
97336: PUSH
97337: LD_VAR 0 2
97341: PUSH
97342: FOR_IN
97343: IFFALSE 97359
// SetLives ( i , 1 ) ;
97345: LD_VAR 0 1
97349: PPUSH
97350: LD_INT 1
97352: PPUSH
97353: CALL_OW 234
97357: GO 97342
97359: POP
97360: POP
// end ;
97361: PPOPN 2
97363: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97364: LD_EXP 132
97368: PUSH
97369: LD_EXP 181
97373: AND
97374: IFFALSE 97648
97376: GO 97378
97378: DISABLE
97379: LD_INT 0
97381: PPUSH
97382: PPUSH
97383: PPUSH
// begin i := rand ( 1 , 7 ) ;
97384: LD_ADDR_VAR 0 1
97388: PUSH
97389: LD_INT 1
97391: PPUSH
97392: LD_INT 7
97394: PPUSH
97395: CALL_OW 12
97399: ST_TO_ADDR
// case i of 1 :
97400: LD_VAR 0 1
97404: PUSH
97405: LD_INT 1
97407: DOUBLE
97408: EQUAL
97409: IFTRUE 97413
97411: GO 97423
97413: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97414: LD_STRING earthquake(getX(game), 0, 32)
97416: PPUSH
97417: CALL_OW 559
97421: GO 97648
97423: LD_INT 2
97425: DOUBLE
97426: EQUAL
97427: IFTRUE 97431
97429: GO 97445
97431: POP
// begin ToLua ( displayStucuk(); ) ;
97432: LD_STRING displayStucuk();
97434: PPUSH
97435: CALL_OW 559
// ResetFog ;
97439: CALL_OW 335
// end ; 3 :
97443: GO 97648
97445: LD_INT 3
97447: DOUBLE
97448: EQUAL
97449: IFTRUE 97453
97451: GO 97557
97453: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97454: LD_ADDR_VAR 0 2
97458: PUSH
97459: LD_INT 22
97461: PUSH
97462: LD_OWVAR 2
97466: PUSH
97467: EMPTY
97468: LIST
97469: LIST
97470: PUSH
97471: LD_INT 25
97473: PUSH
97474: LD_INT 1
97476: PUSH
97477: EMPTY
97478: LIST
97479: LIST
97480: PUSH
97481: EMPTY
97482: LIST
97483: LIST
97484: PPUSH
97485: CALL_OW 69
97489: ST_TO_ADDR
// if not tmp then
97490: LD_VAR 0 2
97494: NOT
97495: IFFALSE 97499
// exit ;
97497: GO 97648
// un := tmp [ rand ( 1 , tmp ) ] ;
97499: LD_ADDR_VAR 0 3
97503: PUSH
97504: LD_VAR 0 2
97508: PUSH
97509: LD_INT 1
97511: PPUSH
97512: LD_VAR 0 2
97516: PPUSH
97517: CALL_OW 12
97521: ARRAY
97522: ST_TO_ADDR
// if Crawls ( un ) then
97523: LD_VAR 0 3
97527: PPUSH
97528: CALL_OW 318
97532: IFFALSE 97543
// ComWalk ( un ) ;
97534: LD_VAR 0 3
97538: PPUSH
97539: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97543: LD_VAR 0 3
97547: PPUSH
97548: LD_INT 8
97550: PPUSH
97551: CALL_OW 336
// end ; 4 :
97555: GO 97648
97557: LD_INT 4
97559: DOUBLE
97560: EQUAL
97561: IFTRUE 97565
97563: GO 97626
97565: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97566: LD_ADDR_VAR 0 2
97570: PUSH
97571: LD_INT 22
97573: PUSH
97574: LD_OWVAR 2
97578: PUSH
97579: EMPTY
97580: LIST
97581: LIST
97582: PUSH
97583: LD_INT 30
97585: PUSH
97586: LD_INT 29
97588: PUSH
97589: EMPTY
97590: LIST
97591: LIST
97592: PUSH
97593: EMPTY
97594: LIST
97595: LIST
97596: PPUSH
97597: CALL_OW 69
97601: ST_TO_ADDR
// if not tmp then
97602: LD_VAR 0 2
97606: NOT
97607: IFFALSE 97611
// exit ;
97609: GO 97648
// DestroyUnit ( tmp [ 1 ] ) ;
97611: LD_VAR 0 2
97615: PUSH
97616: LD_INT 1
97618: ARRAY
97619: PPUSH
97620: CALL_OW 65
// end ; 5 .. 7 :
97624: GO 97648
97626: LD_INT 5
97628: DOUBLE
97629: GREATEREQUAL
97630: IFFALSE 97638
97632: LD_INT 7
97634: DOUBLE
97635: LESSEQUAL
97636: IFTRUE 97640
97638: GO 97647
97640: POP
// StreamSibBomb ; end ;
97641: CALL 93898 0 0
97645: GO 97648
97647: POP
// end ;
97648: PPOPN 3
97650: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97651: LD_EXP 132
97655: PUSH
97656: LD_EXP 182
97660: AND
97661: IFFALSE 97817
97663: GO 97665
97665: DISABLE
97666: LD_INT 0
97668: PPUSH
97669: PPUSH
97670: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97671: LD_ADDR_VAR 0 2
97675: PUSH
97676: LD_INT 81
97678: PUSH
97679: LD_OWVAR 2
97683: PUSH
97684: EMPTY
97685: LIST
97686: LIST
97687: PUSH
97688: LD_INT 2
97690: PUSH
97691: LD_INT 21
97693: PUSH
97694: LD_INT 1
97696: PUSH
97697: EMPTY
97698: LIST
97699: LIST
97700: PUSH
97701: LD_INT 21
97703: PUSH
97704: LD_INT 2
97706: PUSH
97707: EMPTY
97708: LIST
97709: LIST
97710: PUSH
97711: EMPTY
97712: LIST
97713: LIST
97714: LIST
97715: PUSH
97716: EMPTY
97717: LIST
97718: LIST
97719: PPUSH
97720: CALL_OW 69
97724: ST_TO_ADDR
// if not tmp then
97725: LD_VAR 0 2
97729: NOT
97730: IFFALSE 97734
// exit ;
97732: GO 97817
// p := 0 ;
97734: LD_ADDR_VAR 0 3
97738: PUSH
97739: LD_INT 0
97741: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97742: LD_INT 35
97744: PPUSH
97745: CALL_OW 67
// p := p + 1 ;
97749: LD_ADDR_VAR 0 3
97753: PUSH
97754: LD_VAR 0 3
97758: PUSH
97759: LD_INT 1
97761: PLUS
97762: ST_TO_ADDR
// for i in tmp do
97763: LD_ADDR_VAR 0 1
97767: PUSH
97768: LD_VAR 0 2
97772: PUSH
97773: FOR_IN
97774: IFFALSE 97805
// if GetLives ( i ) < 1000 then
97776: LD_VAR 0 1
97780: PPUSH
97781: CALL_OW 256
97785: PUSH
97786: LD_INT 1000
97788: LESS
97789: IFFALSE 97803
// SetLives ( i , 1000 ) ;
97791: LD_VAR 0 1
97795: PPUSH
97796: LD_INT 1000
97798: PPUSH
97799: CALL_OW 234
97803: GO 97773
97805: POP
97806: POP
// until p > 20 ;
97807: LD_VAR 0 3
97811: PUSH
97812: LD_INT 20
97814: GREATER
97815: IFFALSE 97742
// end ;
97817: PPOPN 3
97819: END
// every 0 0$1 trigger StreamModeActive and sTime do
97820: LD_EXP 132
97824: PUSH
97825: LD_EXP 183
97829: AND
97830: IFFALSE 97865
97832: GO 97834
97834: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97835: LD_INT 28
97837: PPUSH
97838: LD_OWVAR 2
97842: PPUSH
97843: LD_INT 2
97845: PPUSH
97846: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97850: LD_INT 30
97852: PPUSH
97853: LD_OWVAR 2
97857: PPUSH
97858: LD_INT 2
97860: PPUSH
97861: CALL_OW 322
// end ;
97865: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97866: LD_EXP 132
97870: PUSH
97871: LD_EXP 184
97875: AND
97876: IFFALSE 97997
97878: GO 97880
97880: DISABLE
97881: LD_INT 0
97883: PPUSH
97884: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97885: LD_ADDR_VAR 0 2
97889: PUSH
97890: LD_INT 22
97892: PUSH
97893: LD_OWVAR 2
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: PUSH
97902: LD_INT 21
97904: PUSH
97905: LD_INT 1
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: PUSH
97912: LD_INT 3
97914: PUSH
97915: LD_INT 23
97917: PUSH
97918: LD_INT 0
97920: PUSH
97921: EMPTY
97922: LIST
97923: LIST
97924: PUSH
97925: EMPTY
97926: LIST
97927: LIST
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: LIST
97933: PPUSH
97934: CALL_OW 69
97938: ST_TO_ADDR
// if not tmp then
97939: LD_VAR 0 2
97943: NOT
97944: IFFALSE 97948
// exit ;
97946: GO 97997
// for i in tmp do
97948: LD_ADDR_VAR 0 1
97952: PUSH
97953: LD_VAR 0 2
97957: PUSH
97958: FOR_IN
97959: IFFALSE 97995
// begin if Crawls ( i ) then
97961: LD_VAR 0 1
97965: PPUSH
97966: CALL_OW 318
97970: IFFALSE 97981
// ComWalk ( i ) ;
97972: LD_VAR 0 1
97976: PPUSH
97977: CALL_OW 138
// SetClass ( i , 2 ) ;
97981: LD_VAR 0 1
97985: PPUSH
97986: LD_INT 2
97988: PPUSH
97989: CALL_OW 336
// end ;
97993: GO 97958
97995: POP
97996: POP
// end ;
97997: PPOPN 2
97999: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98000: LD_EXP 132
98004: PUSH
98005: LD_EXP 185
98009: AND
98010: IFFALSE 98291
98012: GO 98014
98014: DISABLE
98015: LD_INT 0
98017: PPUSH
98018: PPUSH
98019: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98020: LD_OWVAR 2
98024: PPUSH
98025: LD_INT 9
98027: PPUSH
98028: LD_INT 1
98030: PPUSH
98031: LD_INT 1
98033: PPUSH
98034: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98038: LD_INT 9
98040: PPUSH
98041: LD_OWVAR 2
98045: PPUSH
98046: CALL_OW 343
// uc_side := 9 ;
98050: LD_ADDR_OWVAR 20
98054: PUSH
98055: LD_INT 9
98057: ST_TO_ADDR
// uc_nation := 2 ;
98058: LD_ADDR_OWVAR 21
98062: PUSH
98063: LD_INT 2
98065: ST_TO_ADDR
// hc_name := Dark Warrior ;
98066: LD_ADDR_OWVAR 26
98070: PUSH
98071: LD_STRING Dark Warrior
98073: ST_TO_ADDR
// hc_gallery :=  ;
98074: LD_ADDR_OWVAR 33
98078: PUSH
98079: LD_STRING 
98081: ST_TO_ADDR
// hc_noskilllimit := true ;
98082: LD_ADDR_OWVAR 76
98086: PUSH
98087: LD_INT 1
98089: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98090: LD_ADDR_OWVAR 31
98094: PUSH
98095: LD_INT 30
98097: PUSH
98098: LD_INT 30
98100: PUSH
98101: LD_INT 30
98103: PUSH
98104: LD_INT 30
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: ST_TO_ADDR
// un := CreateHuman ;
98113: LD_ADDR_VAR 0 3
98117: PUSH
98118: CALL_OW 44
98122: ST_TO_ADDR
// hc_noskilllimit := false ;
98123: LD_ADDR_OWVAR 76
98127: PUSH
98128: LD_INT 0
98130: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98131: LD_VAR 0 3
98135: PPUSH
98136: LD_INT 1
98138: PPUSH
98139: CALL_OW 51
// p := 0 ;
98143: LD_ADDR_VAR 0 2
98147: PUSH
98148: LD_INT 0
98150: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98151: LD_INT 35
98153: PPUSH
98154: CALL_OW 67
// p := p + 1 ;
98158: LD_ADDR_VAR 0 2
98162: PUSH
98163: LD_VAR 0 2
98167: PUSH
98168: LD_INT 1
98170: PLUS
98171: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98172: LD_VAR 0 3
98176: PPUSH
98177: CALL_OW 256
98181: PUSH
98182: LD_INT 1000
98184: LESS
98185: IFFALSE 98199
// SetLives ( un , 1000 ) ;
98187: LD_VAR 0 3
98191: PPUSH
98192: LD_INT 1000
98194: PPUSH
98195: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
98199: LD_VAR 0 3
98203: PPUSH
98204: LD_INT 81
98206: PUSH
98207: LD_OWVAR 2
98211: PUSH
98212: EMPTY
98213: LIST
98214: LIST
98215: PUSH
98216: LD_INT 91
98218: PUSH
98219: LD_VAR 0 3
98223: PUSH
98224: LD_INT 30
98226: PUSH
98227: EMPTY
98228: LIST
98229: LIST
98230: LIST
98231: PUSH
98232: EMPTY
98233: LIST
98234: LIST
98235: PPUSH
98236: CALL_OW 69
98240: PPUSH
98241: LD_VAR 0 3
98245: PPUSH
98246: CALL_OW 74
98250: PPUSH
98251: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
98255: LD_VAR 0 2
98259: PUSH
98260: LD_INT 60
98262: GREATER
98263: PUSH
98264: LD_VAR 0 3
98268: PPUSH
98269: CALL_OW 301
98273: OR
98274: IFFALSE 98151
// if un then
98276: LD_VAR 0 3
98280: IFFALSE 98291
// RemoveUnit ( un ) ;
98282: LD_VAR 0 3
98286: PPUSH
98287: CALL_OW 64
// end ;
98291: PPOPN 3
98293: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
98294: LD_INT 0
98296: PPUSH
98297: PPUSH
98298: PPUSH
98299: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98300: LD_ADDR_VAR 0 4
98304: PUSH
98305: LD_INT 22
98307: PUSH
98308: LD_OWVAR 2
98312: PUSH
98313: EMPTY
98314: LIST
98315: LIST
98316: PUSH
98317: LD_INT 2
98319: PUSH
98320: LD_INT 30
98322: PUSH
98323: LD_INT 0
98325: PUSH
98326: EMPTY
98327: LIST
98328: LIST
98329: PUSH
98330: LD_INT 30
98332: PUSH
98333: LD_INT 1
98335: PUSH
98336: EMPTY
98337: LIST
98338: LIST
98339: PUSH
98340: EMPTY
98341: LIST
98342: LIST
98343: LIST
98344: PUSH
98345: EMPTY
98346: LIST
98347: LIST
98348: PPUSH
98349: CALL_OW 69
98353: ST_TO_ADDR
// if not tmp then
98354: LD_VAR 0 4
98358: NOT
98359: IFFALSE 98363
// exit ;
98361: GO 98422
// for i in tmp do
98363: LD_ADDR_VAR 0 2
98367: PUSH
98368: LD_VAR 0 4
98372: PUSH
98373: FOR_IN
98374: IFFALSE 98420
// for j = 1 to 3 do
98376: LD_ADDR_VAR 0 3
98380: PUSH
98381: DOUBLE
98382: LD_INT 1
98384: DEC
98385: ST_TO_ADDR
98386: LD_INT 3
98388: PUSH
98389: FOR_TO
98390: IFFALSE 98416
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
98392: LD_VAR 0 2
98396: PPUSH
98397: CALL_OW 274
98401: PPUSH
98402: LD_VAR 0 3
98406: PPUSH
98407: LD_INT 99999
98409: PPUSH
98410: CALL_OW 277
98414: GO 98389
98416: POP
98417: POP
98418: GO 98373
98420: POP
98421: POP
// end ;
98422: LD_VAR 0 1
98426: RET
// export function hHackSetLevel10 ; var i , j ; begin
98427: LD_INT 0
98429: PPUSH
98430: PPUSH
98431: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98432: LD_ADDR_VAR 0 2
98436: PUSH
98437: LD_INT 21
98439: PUSH
98440: LD_INT 1
98442: PUSH
98443: EMPTY
98444: LIST
98445: LIST
98446: PPUSH
98447: CALL_OW 69
98451: PUSH
98452: FOR_IN
98453: IFFALSE 98505
// if IsSelected ( i ) then
98455: LD_VAR 0 2
98459: PPUSH
98460: CALL_OW 306
98464: IFFALSE 98503
// begin for j := 1 to 4 do
98466: LD_ADDR_VAR 0 3
98470: PUSH
98471: DOUBLE
98472: LD_INT 1
98474: DEC
98475: ST_TO_ADDR
98476: LD_INT 4
98478: PUSH
98479: FOR_TO
98480: IFFALSE 98501
// SetSkill ( i , j , 10 ) ;
98482: LD_VAR 0 2
98486: PPUSH
98487: LD_VAR 0 3
98491: PPUSH
98492: LD_INT 10
98494: PPUSH
98495: CALL_OW 237
98499: GO 98479
98501: POP
98502: POP
// end ;
98503: GO 98452
98505: POP
98506: POP
// end ;
98507: LD_VAR 0 1
98511: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
98512: LD_INT 0
98514: PPUSH
98515: PPUSH
98516: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
98517: LD_ADDR_VAR 0 2
98521: PUSH
98522: LD_INT 22
98524: PUSH
98525: LD_OWVAR 2
98529: PUSH
98530: EMPTY
98531: LIST
98532: LIST
98533: PUSH
98534: LD_INT 21
98536: PUSH
98537: LD_INT 1
98539: PUSH
98540: EMPTY
98541: LIST
98542: LIST
98543: PUSH
98544: EMPTY
98545: LIST
98546: LIST
98547: PPUSH
98548: CALL_OW 69
98552: PUSH
98553: FOR_IN
98554: IFFALSE 98595
// begin for j := 1 to 4 do
98556: LD_ADDR_VAR 0 3
98560: PUSH
98561: DOUBLE
98562: LD_INT 1
98564: DEC
98565: ST_TO_ADDR
98566: LD_INT 4
98568: PUSH
98569: FOR_TO
98570: IFFALSE 98591
// SetSkill ( i , j , 10 ) ;
98572: LD_VAR 0 2
98576: PPUSH
98577: LD_VAR 0 3
98581: PPUSH
98582: LD_INT 10
98584: PPUSH
98585: CALL_OW 237
98589: GO 98569
98591: POP
98592: POP
// end ;
98593: GO 98553
98595: POP
98596: POP
// end ;
98597: LD_VAR 0 1
98601: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
98602: LD_INT 0
98604: PPUSH
// uc_side := your_side ;
98605: LD_ADDR_OWVAR 20
98609: PUSH
98610: LD_OWVAR 2
98614: ST_TO_ADDR
// uc_nation := nation ;
98615: LD_ADDR_OWVAR 21
98619: PUSH
98620: LD_VAR 0 1
98624: ST_TO_ADDR
// InitHc ;
98625: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
98629: LD_INT 0
98631: PPUSH
98632: LD_VAR 0 2
98636: PPUSH
98637: LD_VAR 0 3
98641: PPUSH
98642: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
98646: CALL_OW 44
98650: PPUSH
98651: LD_INT 1
98653: PPUSH
98654: CALL_OW 51
// end ;
98658: LD_VAR 0 4
98662: RET
// export function hHackSpawnVehicle ; begin
98663: LD_INT 0
98665: PPUSH
// uc_side := your_side ;
98666: LD_ADDR_OWVAR 20
98670: PUSH
98671: LD_OWVAR 2
98675: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
98676: LD_ADDR_OWVAR 21
98680: PUSH
98681: LD_INT 1
98683: PPUSH
98684: LD_INT 3
98686: PPUSH
98687: CALL_OW 12
98691: ST_TO_ADDR
// InitVc ;
98692: CALL_OW 20
// case uc_nation of 1 :
98696: LD_OWVAR 21
98700: PUSH
98701: LD_INT 1
98703: DOUBLE
98704: EQUAL
98705: IFTRUE 98709
98707: GO 98853
98709: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
98710: LD_ADDR_OWVAR 37
98714: PUSH
98715: LD_INT 1
98717: PUSH
98718: LD_INT 2
98720: PUSH
98721: LD_INT 3
98723: PUSH
98724: LD_INT 4
98726: PUSH
98727: LD_INT 5
98729: PUSH
98730: EMPTY
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: PUSH
98737: LD_INT 1
98739: PPUSH
98740: LD_INT 5
98742: PPUSH
98743: CALL_OW 12
98747: ARRAY
98748: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
98749: LD_ADDR_OWVAR 39
98753: PUSH
98754: LD_INT 1
98756: PPUSH
98757: LD_INT 3
98759: PPUSH
98760: CALL_OW 12
98764: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
98765: LD_ADDR_OWVAR 38
98769: PUSH
98770: LD_INT 1
98772: PUSH
98773: LD_INT 2
98775: PUSH
98776: LD_INT 3
98778: PUSH
98779: EMPTY
98780: LIST
98781: LIST
98782: LIST
98783: PUSH
98784: LD_INT 1
98786: PPUSH
98787: LD_INT 3
98789: PPUSH
98790: CALL_OW 12
98794: ARRAY
98795: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
98796: LD_ADDR_OWVAR 40
98800: PUSH
98801: LD_INT 2
98803: PUSH
98804: LD_INT 4
98806: PUSH
98807: LD_INT 5
98809: PUSH
98810: LD_INT 3
98812: PUSH
98813: LD_INT 7
98815: PUSH
98816: LD_INT 8
98818: PUSH
98819: LD_INT 9
98821: PUSH
98822: LD_INT 10
98824: PUSH
98825: LD_INT 6
98827: PUSH
98828: EMPTY
98829: LIST
98830: LIST
98831: LIST
98832: LIST
98833: LIST
98834: LIST
98835: LIST
98836: LIST
98837: LIST
98838: PUSH
98839: LD_INT 1
98841: PPUSH
98842: LD_INT 9
98844: PPUSH
98845: CALL_OW 12
98849: ARRAY
98850: ST_TO_ADDR
// end ; 2 :
98851: GO 99118
98853: LD_INT 2
98855: DOUBLE
98856: EQUAL
98857: IFTRUE 98861
98859: GO 98985
98861: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
98862: LD_ADDR_OWVAR 37
98866: PUSH
98867: LD_INT 11
98869: PUSH
98870: LD_INT 12
98872: PUSH
98873: LD_INT 13
98875: PUSH
98876: LD_INT 14
98878: PUSH
98879: EMPTY
98880: LIST
98881: LIST
98882: LIST
98883: LIST
98884: PUSH
98885: LD_INT 1
98887: PPUSH
98888: LD_INT 4
98890: PPUSH
98891: CALL_OW 12
98895: ARRAY
98896: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
98897: LD_ADDR_OWVAR 39
98901: PUSH
98902: LD_INT 1
98904: PPUSH
98905: LD_INT 3
98907: PPUSH
98908: CALL_OW 12
98912: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
98913: LD_ADDR_OWVAR 38
98917: PUSH
98918: LD_INT 1
98920: PUSH
98921: LD_INT 2
98923: PUSH
98924: LD_INT 5
98926: PUSH
98927: EMPTY
98928: LIST
98929: LIST
98930: LIST
98931: PUSH
98932: LD_INT 1
98934: PPUSH
98935: LD_INT 3
98937: PPUSH
98938: CALL_OW 12
98942: ARRAY
98943: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
98944: LD_ADDR_OWVAR 40
98948: PUSH
98949: LD_INT 24
98951: PUSH
98952: LD_INT 26
98954: PUSH
98955: LD_INT 27
98957: PUSH
98958: LD_INT 28
98960: PUSH
98961: LD_INT 29
98963: PUSH
98964: EMPTY
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: PUSH
98971: LD_INT 1
98973: PPUSH
98974: LD_INT 5
98976: PPUSH
98977: CALL_OW 12
98981: ARRAY
98982: ST_TO_ADDR
// end ; 3 :
98983: GO 99118
98985: LD_INT 3
98987: DOUBLE
98988: EQUAL
98989: IFTRUE 98993
98991: GO 99117
98993: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
98994: LD_ADDR_OWVAR 37
98998: PUSH
98999: LD_INT 21
99001: PUSH
99002: LD_INT 23
99004: PUSH
99005: LD_INT 22
99007: PUSH
99008: LD_INT 24
99010: PUSH
99011: EMPTY
99012: LIST
99013: LIST
99014: LIST
99015: LIST
99016: PUSH
99017: LD_INT 1
99019: PPUSH
99020: LD_INT 4
99022: PPUSH
99023: CALL_OW 12
99027: ARRAY
99028: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
99029: LD_ADDR_OWVAR 39
99033: PUSH
99034: LD_INT 1
99036: PPUSH
99037: LD_INT 3
99039: PPUSH
99040: CALL_OW 12
99044: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
99045: LD_ADDR_OWVAR 38
99049: PUSH
99050: LD_INT 1
99052: PUSH
99053: LD_INT 3
99055: PUSH
99056: EMPTY
99057: LIST
99058: LIST
99059: PUSH
99060: LD_INT 1
99062: PPUSH
99063: LD_INT 2
99065: PPUSH
99066: CALL_OW 12
99070: ARRAY
99071: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
99072: LD_ADDR_OWVAR 40
99076: PUSH
99077: LD_INT 42
99079: PUSH
99080: LD_INT 43
99082: PUSH
99083: LD_INT 44
99085: PUSH
99086: LD_INT 46
99088: PUSH
99089: LD_INT 48
99091: PUSH
99092: LD_INT 47
99094: PUSH
99095: EMPTY
99096: LIST
99097: LIST
99098: LIST
99099: LIST
99100: LIST
99101: LIST
99102: PUSH
99103: LD_INT 1
99105: PPUSH
99106: LD_INT 6
99108: PPUSH
99109: CALL_OW 12
99113: ARRAY
99114: ST_TO_ADDR
// end ; end ;
99115: GO 99118
99117: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99118: CALL_OW 45
99122: PPUSH
99123: LD_INT 1
99125: PPUSH
99126: CALL_OW 51
// end ;
99130: LD_VAR 0 1
99134: RET
// export hInvincible ; every 1 do
99135: GO 99137
99137: DISABLE
// hInvincible := [ ] ;
99138: LD_ADDR_EXP 186
99142: PUSH
99143: EMPTY
99144: ST_TO_ADDR
99145: END
// every 10 do var i ;
99146: GO 99148
99148: DISABLE
99149: LD_INT 0
99151: PPUSH
// begin enable ;
99152: ENABLE
// if not hInvincible then
99153: LD_EXP 186
99157: NOT
99158: IFFALSE 99162
// exit ;
99160: GO 99206
// for i in hInvincible do
99162: LD_ADDR_VAR 0 1
99166: PUSH
99167: LD_EXP 186
99171: PUSH
99172: FOR_IN
99173: IFFALSE 99204
// if GetLives ( i ) < 1000 then
99175: LD_VAR 0 1
99179: PPUSH
99180: CALL_OW 256
99184: PUSH
99185: LD_INT 1000
99187: LESS
99188: IFFALSE 99202
// SetLives ( i , 1000 ) ;
99190: LD_VAR 0 1
99194: PPUSH
99195: LD_INT 1000
99197: PPUSH
99198: CALL_OW 234
99202: GO 99172
99204: POP
99205: POP
// end ;
99206: PPOPN 1
99208: END
// export function hHackInvincible ; var i ; begin
99209: LD_INT 0
99211: PPUSH
99212: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
99213: LD_ADDR_VAR 0 2
99217: PUSH
99218: LD_INT 2
99220: PUSH
99221: LD_INT 21
99223: PUSH
99224: LD_INT 1
99226: PUSH
99227: EMPTY
99228: LIST
99229: LIST
99230: PUSH
99231: LD_INT 21
99233: PUSH
99234: LD_INT 2
99236: PUSH
99237: EMPTY
99238: LIST
99239: LIST
99240: PUSH
99241: EMPTY
99242: LIST
99243: LIST
99244: LIST
99245: PPUSH
99246: CALL_OW 69
99250: PUSH
99251: FOR_IN
99252: IFFALSE 99313
// if IsSelected ( i ) then
99254: LD_VAR 0 2
99258: PPUSH
99259: CALL_OW 306
99263: IFFALSE 99311
// begin if i in hInvincible then
99265: LD_VAR 0 2
99269: PUSH
99270: LD_EXP 186
99274: IN
99275: IFFALSE 99295
// hInvincible := hInvincible diff i else
99277: LD_ADDR_EXP 186
99281: PUSH
99282: LD_EXP 186
99286: PUSH
99287: LD_VAR 0 2
99291: DIFF
99292: ST_TO_ADDR
99293: GO 99311
// hInvincible := hInvincible union i ;
99295: LD_ADDR_EXP 186
99299: PUSH
99300: LD_EXP 186
99304: PUSH
99305: LD_VAR 0 2
99309: UNION
99310: ST_TO_ADDR
// end ;
99311: GO 99251
99313: POP
99314: POP
// end ;
99315: LD_VAR 0 1
99319: RET
// export function hHackInvisible ; var i , j ; begin
99320: LD_INT 0
99322: PPUSH
99323: PPUSH
99324: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99325: LD_ADDR_VAR 0 2
99329: PUSH
99330: LD_INT 21
99332: PUSH
99333: LD_INT 1
99335: PUSH
99336: EMPTY
99337: LIST
99338: LIST
99339: PPUSH
99340: CALL_OW 69
99344: PUSH
99345: FOR_IN
99346: IFFALSE 99370
// if IsSelected ( i ) then
99348: LD_VAR 0 2
99352: PPUSH
99353: CALL_OW 306
99357: IFFALSE 99368
// ComForceInvisible ( i ) ;
99359: LD_VAR 0 2
99363: PPUSH
99364: CALL_OW 496
99368: GO 99345
99370: POP
99371: POP
// end ;
99372: LD_VAR 0 1
99376: RET
// export function hHackChangeYourSide ; begin
99377: LD_INT 0
99379: PPUSH
// if your_side = 8 then
99380: LD_OWVAR 2
99384: PUSH
99385: LD_INT 8
99387: EQUAL
99388: IFFALSE 99400
// your_side := 0 else
99390: LD_ADDR_OWVAR 2
99394: PUSH
99395: LD_INT 0
99397: ST_TO_ADDR
99398: GO 99414
// your_side := your_side + 1 ;
99400: LD_ADDR_OWVAR 2
99404: PUSH
99405: LD_OWVAR 2
99409: PUSH
99410: LD_INT 1
99412: PLUS
99413: ST_TO_ADDR
// end ;
99414: LD_VAR 0 1
99418: RET
// export function hHackChangeUnitSide ; var i , j ; begin
99419: LD_INT 0
99421: PPUSH
99422: PPUSH
99423: PPUSH
// for i in all_units do
99424: LD_ADDR_VAR 0 2
99428: PUSH
99429: LD_OWVAR 3
99433: PUSH
99434: FOR_IN
99435: IFFALSE 99513
// if IsSelected ( i ) then
99437: LD_VAR 0 2
99441: PPUSH
99442: CALL_OW 306
99446: IFFALSE 99511
// begin j := GetSide ( i ) ;
99448: LD_ADDR_VAR 0 3
99452: PUSH
99453: LD_VAR 0 2
99457: PPUSH
99458: CALL_OW 255
99462: ST_TO_ADDR
// if j = 8 then
99463: LD_VAR 0 3
99467: PUSH
99468: LD_INT 8
99470: EQUAL
99471: IFFALSE 99483
// j := 0 else
99473: LD_ADDR_VAR 0 3
99477: PUSH
99478: LD_INT 0
99480: ST_TO_ADDR
99481: GO 99497
// j := j + 1 ;
99483: LD_ADDR_VAR 0 3
99487: PUSH
99488: LD_VAR 0 3
99492: PUSH
99493: LD_INT 1
99495: PLUS
99496: ST_TO_ADDR
// SetSide ( i , j ) ;
99497: LD_VAR 0 2
99501: PPUSH
99502: LD_VAR 0 3
99506: PPUSH
99507: CALL_OW 235
// end ;
99511: GO 99434
99513: POP
99514: POP
// end ;
99515: LD_VAR 0 1
99519: RET
// export function hHackFog ; begin
99520: LD_INT 0
99522: PPUSH
// FogOff ( true ) ;
99523: LD_INT 1
99525: PPUSH
99526: CALL_OW 344
// end ;
99530: LD_VAR 0 1
99534: RET
// export function hHackApeman ; begin
99535: LD_INT 0
99537: PPUSH
// uc_side := your_side ;
99538: LD_ADDR_OWVAR 20
99542: PUSH
99543: LD_OWVAR 2
99547: ST_TO_ADDR
// uc_nation := 0 ;
99548: LD_ADDR_OWVAR 21
99552: PUSH
99553: LD_INT 0
99555: ST_TO_ADDR
// hc_name :=  ;
99556: LD_ADDR_OWVAR 26
99560: PUSH
99561: LD_STRING 
99563: ST_TO_ADDR
// hc_gallery :=  ;
99564: LD_ADDR_OWVAR 33
99568: PUSH
99569: LD_STRING 
99571: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
99572: LD_ADDR_OWVAR 31
99576: PUSH
99577: LD_INT 0
99579: PUSH
99580: LD_INT 0
99582: PUSH
99583: LD_INT 0
99585: PUSH
99586: LD_INT 0
99588: PUSH
99589: EMPTY
99590: LIST
99591: LIST
99592: LIST
99593: LIST
99594: ST_TO_ADDR
// hc_class := class_apeman ;
99595: LD_ADDR_OWVAR 28
99599: PUSH
99600: LD_INT 12
99602: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
99603: CALL_OW 44
99607: PPUSH
99608: LD_INT 1
99610: PPUSH
99611: CALL_OW 51
// end ;
99615: LD_VAR 0 1
99619: RET
// export function hHackBoom ; begin
99620: LD_INT 0
99622: PPUSH
// uc_side := your_side ;
99623: LD_ADDR_OWVAR 20
99627: PUSH
99628: LD_OWVAR 2
99632: ST_TO_ADDR
// uc_nation := 1 ;
99633: LD_ADDR_OWVAR 21
99637: PUSH
99638: LD_INT 1
99640: ST_TO_ADDR
// vc_chassis := us_morphling ;
99641: LD_ADDR_OWVAR 37
99645: PUSH
99646: LD_INT 5
99648: ST_TO_ADDR
// vc_engine := engine_siberite ;
99649: LD_ADDR_OWVAR 39
99653: PUSH
99654: LD_INT 3
99656: ST_TO_ADDR
// vc_control := control_computer ;
99657: LD_ADDR_OWVAR 38
99661: PUSH
99662: LD_INT 3
99664: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
99665: LD_ADDR_OWVAR 40
99669: PUSH
99670: LD_INT 8
99672: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99673: CALL_OW 45
99677: PPUSH
99678: LD_INT 1
99680: PPUSH
99681: CALL_OW 51
// end ; end_of_file
99685: LD_VAR 0 1
99689: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
99690: LD_INT 0
99692: PPUSH
99693: PPUSH
99694: PPUSH
99695: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
99696: LD_VAR 0 1
99700: PPUSH
99701: CALL_OW 264
99705: PUSH
99706: LD_EXP 76
99710: EQUAL
99711: IFFALSE 99783
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
99713: LD_INT 68
99715: PPUSH
99716: LD_VAR 0 1
99720: PPUSH
99721: CALL_OW 255
99725: PPUSH
99726: CALL_OW 321
99730: PUSH
99731: LD_INT 2
99733: EQUAL
99734: IFFALSE 99746
// eff := 70 else
99736: LD_ADDR_VAR 0 4
99740: PUSH
99741: LD_INT 70
99743: ST_TO_ADDR
99744: GO 99754
// eff := 30 ;
99746: LD_ADDR_VAR 0 4
99750: PUSH
99751: LD_INT 30
99753: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
99754: LD_VAR 0 1
99758: PPUSH
99759: CALL_OW 250
99763: PPUSH
99764: LD_VAR 0 1
99768: PPUSH
99769: CALL_OW 251
99773: PPUSH
99774: LD_VAR 0 4
99778: PPUSH
99779: CALL_OW 495
// end ; end ;
99783: LD_VAR 0 2
99787: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
99788: LD_INT 0
99790: PPUSH
// end ;
99791: LD_VAR 0 4
99795: RET
// export function SOS_Command ( cmd ) ; begin
99796: LD_INT 0
99798: PPUSH
// end ;
99799: LD_VAR 0 2
99803: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y ) do begin if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
99804: LD_VAR 0 1
99808: PUSH
99809: LD_INT 254
99811: EQUAL
99812: PUSH
99813: LD_VAR 0 2
99817: PPUSH
99818: CALL_OW 264
99822: PUSH
99823: LD_EXP 74
99827: EQUAL
99828: AND
99829: PUSH
99830: LD_VAR 0 3
99834: PPUSH
99835: CALL_OW 263
99839: PUSH
99840: LD_INT 3
99842: EQUAL
99843: AND
99844: IFFALSE 99860
// HackDestroyVehicle ( unit , selectedUnit ) ;
99846: LD_VAR 0 2
99850: PPUSH
99851: LD_VAR 0 3
99855: PPUSH
99856: CALL 101367 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
99860: LD_VAR 0 1
99864: PUSH
99865: LD_INT 255
99867: EQUAL
99868: PUSH
99869: LD_VAR 0 2
99873: PPUSH
99874: CALL_OW 264
99878: PUSH
99879: LD_INT 14
99881: PUSH
99882: LD_INT 53
99884: PUSH
99885: EMPTY
99886: LIST
99887: LIST
99888: IN
99889: AND
99890: PUSH
99891: LD_VAR 0 4
99895: PPUSH
99896: LD_VAR 0 5
99900: PPUSH
99901: CALL_OW 488
99905: AND
99906: IFFALSE 99930
// CutTreeXYR ( unit , x , y , 12 ) ;
99908: LD_VAR 0 2
99912: PPUSH
99913: LD_VAR 0 4
99917: PPUSH
99918: LD_VAR 0 5
99922: PPUSH
99923: LD_INT 12
99925: PPUSH
99926: CALL 99933 0 4
// end ;
99930: PPOPN 5
99932: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
99933: LD_INT 0
99935: PPUSH
99936: PPUSH
99937: PPUSH
99938: PPUSH
99939: PPUSH
99940: PPUSH
99941: PPUSH
99942: PPUSH
99943: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
99944: LD_VAR 0 1
99948: NOT
99949: PUSH
99950: LD_VAR 0 2
99954: PPUSH
99955: LD_VAR 0 3
99959: PPUSH
99960: CALL_OW 488
99964: NOT
99965: OR
99966: PUSH
99967: LD_VAR 0 4
99971: NOT
99972: OR
99973: IFFALSE 99977
// exit ;
99975: GO 100317
// list := [ ] ;
99977: LD_ADDR_VAR 0 13
99981: PUSH
99982: EMPTY
99983: ST_TO_ADDR
// if x - r < 0 then
99984: LD_VAR 0 2
99988: PUSH
99989: LD_VAR 0 4
99993: MINUS
99994: PUSH
99995: LD_INT 0
99997: LESS
99998: IFFALSE 100010
// min_x := 0 else
100000: LD_ADDR_VAR 0 7
100004: PUSH
100005: LD_INT 0
100007: ST_TO_ADDR
100008: GO 100026
// min_x := x - r ;
100010: LD_ADDR_VAR 0 7
100014: PUSH
100015: LD_VAR 0 2
100019: PUSH
100020: LD_VAR 0 4
100024: MINUS
100025: ST_TO_ADDR
// if y - r < 0 then
100026: LD_VAR 0 3
100030: PUSH
100031: LD_VAR 0 4
100035: MINUS
100036: PUSH
100037: LD_INT 0
100039: LESS
100040: IFFALSE 100052
// min_y := 0 else
100042: LD_ADDR_VAR 0 8
100046: PUSH
100047: LD_INT 0
100049: ST_TO_ADDR
100050: GO 100068
// min_y := y - r ;
100052: LD_ADDR_VAR 0 8
100056: PUSH
100057: LD_VAR 0 3
100061: PUSH
100062: LD_VAR 0 4
100066: MINUS
100067: ST_TO_ADDR
// max_x := x + r ;
100068: LD_ADDR_VAR 0 9
100072: PUSH
100073: LD_VAR 0 2
100077: PUSH
100078: LD_VAR 0 4
100082: PLUS
100083: ST_TO_ADDR
// max_y := y + r ;
100084: LD_ADDR_VAR 0 10
100088: PUSH
100089: LD_VAR 0 3
100093: PUSH
100094: LD_VAR 0 4
100098: PLUS
100099: ST_TO_ADDR
// for _x = min_x to max_x do
100100: LD_ADDR_VAR 0 11
100104: PUSH
100105: DOUBLE
100106: LD_VAR 0 7
100110: DEC
100111: ST_TO_ADDR
100112: LD_VAR 0 9
100116: PUSH
100117: FOR_TO
100118: IFFALSE 100235
// for _y = min_y to max_y do
100120: LD_ADDR_VAR 0 12
100124: PUSH
100125: DOUBLE
100126: LD_VAR 0 8
100130: DEC
100131: ST_TO_ADDR
100132: LD_VAR 0 10
100136: PUSH
100137: FOR_TO
100138: IFFALSE 100231
// begin if not ValidHex ( _x , _y ) then
100140: LD_VAR 0 11
100144: PPUSH
100145: LD_VAR 0 12
100149: PPUSH
100150: CALL_OW 488
100154: NOT
100155: IFFALSE 100159
// continue ;
100157: GO 100137
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
100159: LD_VAR 0 11
100163: PPUSH
100164: LD_VAR 0 12
100168: PPUSH
100169: CALL_OW 351
100173: PUSH
100174: LD_VAR 0 11
100178: PPUSH
100179: LD_VAR 0 12
100183: PPUSH
100184: CALL_OW 554
100188: AND
100189: IFFALSE 100229
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
100191: LD_ADDR_VAR 0 13
100195: PUSH
100196: LD_VAR 0 13
100200: PPUSH
100201: LD_VAR 0 13
100205: PUSH
100206: LD_INT 1
100208: PLUS
100209: PPUSH
100210: LD_VAR 0 11
100214: PUSH
100215: LD_VAR 0 12
100219: PUSH
100220: EMPTY
100221: LIST
100222: LIST
100223: PPUSH
100224: CALL_OW 2
100228: ST_TO_ADDR
// end ;
100229: GO 100137
100231: POP
100232: POP
100233: GO 100117
100235: POP
100236: POP
// if not list then
100237: LD_VAR 0 13
100241: NOT
100242: IFFALSE 100246
// exit ;
100244: GO 100317
// for i in list do
100246: LD_ADDR_VAR 0 6
100250: PUSH
100251: LD_VAR 0 13
100255: PUSH
100256: FOR_IN
100257: IFFALSE 100315
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
100259: LD_VAR 0 1
100263: PPUSH
100264: LD_STRING M
100266: PUSH
100267: LD_VAR 0 6
100271: PUSH
100272: LD_INT 1
100274: ARRAY
100275: PUSH
100276: LD_VAR 0 6
100280: PUSH
100281: LD_INT 2
100283: ARRAY
100284: PUSH
100285: LD_INT 0
100287: PUSH
100288: LD_INT 0
100290: PUSH
100291: LD_INT 0
100293: PUSH
100294: LD_INT 0
100296: PUSH
100297: EMPTY
100298: LIST
100299: LIST
100300: LIST
100301: LIST
100302: LIST
100303: LIST
100304: LIST
100305: PUSH
100306: EMPTY
100307: LIST
100308: PPUSH
100309: CALL_OW 447
100313: GO 100256
100315: POP
100316: POP
// end ;
100317: LD_VAR 0 5
100321: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
100322: LD_EXP 187
100326: NOT
100327: IFFALSE 100377
100329: GO 100331
100331: DISABLE
// begin initHack := true ;
100332: LD_ADDR_EXP 187
100336: PUSH
100337: LD_INT 1
100339: ST_TO_ADDR
// hackTanks := [ ] ;
100340: LD_ADDR_EXP 188
100344: PUSH
100345: EMPTY
100346: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
100347: LD_ADDR_EXP 189
100351: PUSH
100352: EMPTY
100353: ST_TO_ADDR
// hackLimit := 3 ;
100354: LD_ADDR_EXP 190
100358: PUSH
100359: LD_INT 3
100361: ST_TO_ADDR
// hackDist := 12 ;
100362: LD_ADDR_EXP 191
100366: PUSH
100367: LD_INT 12
100369: ST_TO_ADDR
// hackCounter := [ ] ;
100370: LD_ADDR_EXP 192
100374: PUSH
100375: EMPTY
100376: ST_TO_ADDR
// end ;
100377: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
100378: LD_EXP 187
100382: PUSH
100383: LD_INT 34
100385: PUSH
100386: LD_EXP 74
100390: PUSH
100391: EMPTY
100392: LIST
100393: LIST
100394: PPUSH
100395: CALL_OW 69
100399: AND
100400: IFFALSE 100655
100402: GO 100404
100404: DISABLE
100405: LD_INT 0
100407: PPUSH
100408: PPUSH
// begin enable ;
100409: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
100410: LD_ADDR_VAR 0 1
100414: PUSH
100415: LD_INT 34
100417: PUSH
100418: LD_EXP 74
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: PPUSH
100427: CALL_OW 69
100431: PUSH
100432: FOR_IN
100433: IFFALSE 100653
// begin if not i in hackTanks then
100435: LD_VAR 0 1
100439: PUSH
100440: LD_EXP 188
100444: IN
100445: NOT
100446: IFFALSE 100529
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
100448: LD_ADDR_EXP 188
100452: PUSH
100453: LD_EXP 188
100457: PPUSH
100458: LD_EXP 188
100462: PUSH
100463: LD_INT 1
100465: PLUS
100466: PPUSH
100467: LD_VAR 0 1
100471: PPUSH
100472: CALL_OW 1
100476: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
100477: LD_ADDR_EXP 189
100481: PUSH
100482: LD_EXP 189
100486: PPUSH
100487: LD_EXP 189
100491: PUSH
100492: LD_INT 1
100494: PLUS
100495: PPUSH
100496: EMPTY
100497: PPUSH
100498: CALL_OW 1
100502: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
100503: LD_ADDR_EXP 192
100507: PUSH
100508: LD_EXP 192
100512: PPUSH
100513: LD_EXP 192
100517: PUSH
100518: LD_INT 1
100520: PLUS
100521: PPUSH
100522: EMPTY
100523: PPUSH
100524: CALL_OW 1
100528: ST_TO_ADDR
// end ; if not IsOk ( i ) then
100529: LD_VAR 0 1
100533: PPUSH
100534: CALL_OW 302
100538: NOT
100539: IFFALSE 100552
// begin HackUnlinkAll ( i ) ;
100541: LD_VAR 0 1
100545: PPUSH
100546: CALL 100658 0 1
// continue ;
100550: GO 100432
// end ; HackCheckCapturedStatus ( i ) ;
100552: LD_VAR 0 1
100556: PPUSH
100557: CALL 101101 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
100561: LD_ADDR_VAR 0 2
100565: PUSH
100566: LD_INT 81
100568: PUSH
100569: LD_VAR 0 1
100573: PPUSH
100574: CALL_OW 255
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: PUSH
100583: LD_INT 33
100585: PUSH
100586: LD_INT 3
100588: PUSH
100589: EMPTY
100590: LIST
100591: LIST
100592: PUSH
100593: LD_INT 91
100595: PUSH
100596: LD_VAR 0 1
100600: PUSH
100601: LD_EXP 191
100605: PUSH
100606: EMPTY
100607: LIST
100608: LIST
100609: LIST
100610: PUSH
100611: LD_INT 50
100613: PUSH
100614: EMPTY
100615: LIST
100616: PUSH
100617: EMPTY
100618: LIST
100619: LIST
100620: LIST
100621: LIST
100622: PPUSH
100623: CALL_OW 69
100627: ST_TO_ADDR
// if not tmp then
100628: LD_VAR 0 2
100632: NOT
100633: IFFALSE 100637
// continue ;
100635: GO 100432
// HackLink ( i , tmp ) ;
100637: LD_VAR 0 1
100641: PPUSH
100642: LD_VAR 0 2
100646: PPUSH
100647: CALL 100794 0 2
// end ;
100651: GO 100432
100653: POP
100654: POP
// end ;
100655: PPOPN 2
100657: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
100658: LD_INT 0
100660: PPUSH
100661: PPUSH
100662: PPUSH
// if not hack in hackTanks then
100663: LD_VAR 0 1
100667: PUSH
100668: LD_EXP 188
100672: IN
100673: NOT
100674: IFFALSE 100678
// exit ;
100676: GO 100789
// index := GetElementIndex ( hackTanks , hack ) ;
100678: LD_ADDR_VAR 0 4
100682: PUSH
100683: LD_EXP 188
100687: PPUSH
100688: LD_VAR 0 1
100692: PPUSH
100693: CALL 55402 0 2
100697: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
100698: LD_EXP 189
100702: PUSH
100703: LD_VAR 0 4
100707: ARRAY
100708: IFFALSE 100789
// begin for i in hackTanksCaptured [ index ] do
100710: LD_ADDR_VAR 0 3
100714: PUSH
100715: LD_EXP 189
100719: PUSH
100720: LD_VAR 0 4
100724: ARRAY
100725: PUSH
100726: FOR_IN
100727: IFFALSE 100753
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
100729: LD_VAR 0 3
100733: PUSH
100734: LD_INT 1
100736: ARRAY
100737: PPUSH
100738: LD_VAR 0 3
100742: PUSH
100743: LD_INT 2
100745: ARRAY
100746: PPUSH
100747: CALL_OW 235
100751: GO 100726
100753: POP
100754: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
100755: LD_ADDR_EXP 189
100759: PUSH
100760: LD_EXP 189
100764: PPUSH
100765: LD_VAR 0 4
100769: PPUSH
100770: EMPTY
100771: PPUSH
100772: CALL_OW 1
100776: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
100777: LD_VAR 0 1
100781: PPUSH
100782: LD_INT 0
100784: PPUSH
100785: CALL_OW 505
// end ; end ;
100789: LD_VAR 0 2
100793: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
100794: LD_INT 0
100796: PPUSH
100797: PPUSH
100798: PPUSH
// if not hack in hackTanks or not vehicles then
100799: LD_VAR 0 1
100803: PUSH
100804: LD_EXP 188
100808: IN
100809: NOT
100810: PUSH
100811: LD_VAR 0 2
100815: NOT
100816: OR
100817: IFFALSE 100821
// exit ;
100819: GO 101096
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
100821: LD_ADDR_VAR 0 2
100825: PUSH
100826: LD_VAR 0 1
100830: PPUSH
100831: LD_VAR 0 2
100835: PPUSH
100836: LD_INT 1
100838: PPUSH
100839: LD_INT 1
100841: PPUSH
100842: CALL 56052 0 4
100846: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
100847: LD_ADDR_VAR 0 5
100851: PUSH
100852: LD_EXP 188
100856: PPUSH
100857: LD_VAR 0 1
100861: PPUSH
100862: CALL 55402 0 2
100866: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
100867: LD_EXP 189
100871: PUSH
100872: LD_VAR 0 5
100876: ARRAY
100877: PUSH
100878: LD_EXP 190
100882: LESS
100883: IFFALSE 101072
// begin for i := 1 to vehicles do
100885: LD_ADDR_VAR 0 4
100889: PUSH
100890: DOUBLE
100891: LD_INT 1
100893: DEC
100894: ST_TO_ADDR
100895: LD_VAR 0 2
100899: PUSH
100900: FOR_TO
100901: IFFALSE 101070
// begin if hackTanksCaptured [ index ] = hackLimit then
100903: LD_EXP 189
100907: PUSH
100908: LD_VAR 0 5
100912: ARRAY
100913: PUSH
100914: LD_EXP 190
100918: EQUAL
100919: IFFALSE 100923
// break ;
100921: GO 101070
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
100923: LD_ADDR_EXP 192
100927: PUSH
100928: LD_EXP 192
100932: PPUSH
100933: LD_VAR 0 5
100937: PPUSH
100938: LD_EXP 192
100942: PUSH
100943: LD_VAR 0 5
100947: ARRAY
100948: PUSH
100949: LD_INT 1
100951: PLUS
100952: PPUSH
100953: CALL_OW 1
100957: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
100958: LD_ADDR_EXP 189
100962: PUSH
100963: LD_EXP 189
100967: PPUSH
100968: LD_VAR 0 5
100972: PUSH
100973: LD_EXP 189
100977: PUSH
100978: LD_VAR 0 5
100982: ARRAY
100983: PUSH
100984: LD_INT 1
100986: PLUS
100987: PUSH
100988: EMPTY
100989: LIST
100990: LIST
100991: PPUSH
100992: LD_VAR 0 2
100996: PUSH
100997: LD_VAR 0 4
101001: ARRAY
101002: PUSH
101003: LD_VAR 0 2
101007: PUSH
101008: LD_VAR 0 4
101012: ARRAY
101013: PPUSH
101014: CALL_OW 255
101018: PUSH
101019: EMPTY
101020: LIST
101021: LIST
101022: PPUSH
101023: CALL 55617 0 3
101027: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
101028: LD_VAR 0 2
101032: PUSH
101033: LD_VAR 0 4
101037: ARRAY
101038: PPUSH
101039: LD_VAR 0 1
101043: PPUSH
101044: CALL_OW 255
101048: PPUSH
101049: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
101053: LD_VAR 0 2
101057: PUSH
101058: LD_VAR 0 4
101062: ARRAY
101063: PPUSH
101064: CALL_OW 141
// end ;
101068: GO 100900
101070: POP
101071: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
101072: LD_VAR 0 1
101076: PPUSH
101077: LD_EXP 189
101081: PUSH
101082: LD_VAR 0 5
101086: ARRAY
101087: PUSH
101088: LD_INT 0
101090: PLUS
101091: PPUSH
101092: CALL_OW 505
// end ;
101096: LD_VAR 0 3
101100: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
101101: LD_INT 0
101103: PPUSH
101104: PPUSH
101105: PPUSH
101106: PPUSH
// if not hack in hackTanks then
101107: LD_VAR 0 1
101111: PUSH
101112: LD_EXP 188
101116: IN
101117: NOT
101118: IFFALSE 101122
// exit ;
101120: GO 101362
// index := GetElementIndex ( hackTanks , hack ) ;
101122: LD_ADDR_VAR 0 4
101126: PUSH
101127: LD_EXP 188
101131: PPUSH
101132: LD_VAR 0 1
101136: PPUSH
101137: CALL 55402 0 2
101141: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
101142: LD_ADDR_VAR 0 3
101146: PUSH
101147: DOUBLE
101148: LD_EXP 189
101152: PUSH
101153: LD_VAR 0 4
101157: ARRAY
101158: INC
101159: ST_TO_ADDR
101160: LD_INT 1
101162: PUSH
101163: FOR_DOWNTO
101164: IFFALSE 101336
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
101166: LD_ADDR_VAR 0 5
101170: PUSH
101171: LD_EXP 189
101175: PUSH
101176: LD_VAR 0 4
101180: ARRAY
101181: PUSH
101182: LD_VAR 0 3
101186: ARRAY
101187: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
101188: LD_VAR 0 5
101192: PUSH
101193: LD_INT 1
101195: ARRAY
101196: PPUSH
101197: CALL_OW 302
101201: NOT
101202: PUSH
101203: LD_VAR 0 5
101207: PUSH
101208: LD_INT 1
101210: ARRAY
101211: PPUSH
101212: CALL_OW 255
101216: PUSH
101217: LD_VAR 0 1
101221: PPUSH
101222: CALL_OW 255
101226: NONEQUAL
101227: OR
101228: IFFALSE 101334
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
101230: LD_VAR 0 5
101234: PUSH
101235: LD_INT 1
101237: ARRAY
101238: PPUSH
101239: CALL_OW 305
101243: PUSH
101244: LD_VAR 0 5
101248: PUSH
101249: LD_INT 1
101251: ARRAY
101252: PPUSH
101253: CALL_OW 255
101257: PUSH
101258: LD_VAR 0 1
101262: PPUSH
101263: CALL_OW 255
101267: EQUAL
101268: AND
101269: IFFALSE 101293
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
101271: LD_VAR 0 5
101275: PUSH
101276: LD_INT 1
101278: ARRAY
101279: PPUSH
101280: LD_VAR 0 5
101284: PUSH
101285: LD_INT 2
101287: ARRAY
101288: PPUSH
101289: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
101293: LD_ADDR_EXP 189
101297: PUSH
101298: LD_EXP 189
101302: PPUSH
101303: LD_VAR 0 4
101307: PPUSH
101308: LD_EXP 189
101312: PUSH
101313: LD_VAR 0 4
101317: ARRAY
101318: PPUSH
101319: LD_VAR 0 3
101323: PPUSH
101324: CALL_OW 3
101328: PPUSH
101329: CALL_OW 1
101333: ST_TO_ADDR
// end ; end ;
101334: GO 101163
101336: POP
101337: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
101338: LD_VAR 0 1
101342: PPUSH
101343: LD_EXP 189
101347: PUSH
101348: LD_VAR 0 4
101352: ARRAY
101353: PUSH
101354: LD_INT 0
101356: PLUS
101357: PPUSH
101358: CALL_OW 505
// end ;
101362: LD_VAR 0 2
101366: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
101367: LD_INT 0
101369: PPUSH
101370: PPUSH
101371: PPUSH
101372: PPUSH
// if not hack in hackTanks then
101373: LD_VAR 0 1
101377: PUSH
101378: LD_EXP 188
101382: IN
101383: NOT
101384: IFFALSE 101388
// exit ;
101386: GO 101473
// index := GetElementIndex ( hackTanks , hack ) ;
101388: LD_ADDR_VAR 0 5
101392: PUSH
101393: LD_EXP 188
101397: PPUSH
101398: LD_VAR 0 1
101402: PPUSH
101403: CALL 55402 0 2
101407: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
101408: LD_ADDR_VAR 0 4
101412: PUSH
101413: DOUBLE
101414: LD_INT 1
101416: DEC
101417: ST_TO_ADDR
101418: LD_EXP 189
101422: PUSH
101423: LD_VAR 0 5
101427: ARRAY
101428: PUSH
101429: FOR_TO
101430: IFFALSE 101471
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
101432: LD_EXP 189
101436: PUSH
101437: LD_VAR 0 5
101441: ARRAY
101442: PUSH
101443: LD_VAR 0 4
101447: ARRAY
101448: PUSH
101449: LD_INT 1
101451: ARRAY
101452: PUSH
101453: LD_VAR 0 2
101457: EQUAL
101458: IFFALSE 101469
// KillUnit ( vehicle ) ;
101460: LD_VAR 0 2
101464: PPUSH
101465: CALL_OW 66
101469: GO 101429
101471: POP
101472: POP
// end ; end_of_file
101473: LD_VAR 0 3
101477: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
101478: LD_INT 0
101480: PPUSH
101481: PPUSH
101482: PPUSH
101483: PPUSH
101484: PPUSH
101485: PPUSH
101486: PPUSH
101487: PPUSH
101488: PPUSH
101489: PPUSH
101490: PPUSH
101491: PPUSH
101492: PPUSH
101493: PPUSH
101494: PPUSH
101495: PPUSH
101496: PPUSH
101497: PPUSH
101498: PPUSH
101499: PPUSH
101500: PPUSH
101501: PPUSH
101502: PPUSH
101503: PPUSH
101504: PPUSH
101505: PPUSH
101506: PPUSH
101507: PPUSH
101508: PPUSH
101509: PPUSH
101510: PPUSH
101511: PPUSH
101512: PPUSH
101513: PPUSH
// if not list then
101514: LD_VAR 0 1
101518: NOT
101519: IFFALSE 101523
// exit ;
101521: GO 106182
// base := list [ 1 ] ;
101523: LD_ADDR_VAR 0 3
101527: PUSH
101528: LD_VAR 0 1
101532: PUSH
101533: LD_INT 1
101535: ARRAY
101536: ST_TO_ADDR
// group := list [ 2 ] ;
101537: LD_ADDR_VAR 0 4
101541: PUSH
101542: LD_VAR 0 1
101546: PUSH
101547: LD_INT 2
101549: ARRAY
101550: ST_TO_ADDR
// path := list [ 3 ] ;
101551: LD_ADDR_VAR 0 5
101555: PUSH
101556: LD_VAR 0 1
101560: PUSH
101561: LD_INT 3
101563: ARRAY
101564: ST_TO_ADDR
// flags := list [ 4 ] ;
101565: LD_ADDR_VAR 0 6
101569: PUSH
101570: LD_VAR 0 1
101574: PUSH
101575: LD_INT 4
101577: ARRAY
101578: ST_TO_ADDR
// mined := [ ] ;
101579: LD_ADDR_VAR 0 27
101583: PUSH
101584: EMPTY
101585: ST_TO_ADDR
// bombed := [ ] ;
101586: LD_ADDR_VAR 0 28
101590: PUSH
101591: EMPTY
101592: ST_TO_ADDR
// healers := [ ] ;
101593: LD_ADDR_VAR 0 31
101597: PUSH
101598: EMPTY
101599: ST_TO_ADDR
// to_heal := [ ] ;
101600: LD_ADDR_VAR 0 30
101604: PUSH
101605: EMPTY
101606: ST_TO_ADDR
// repairs := [ ] ;
101607: LD_ADDR_VAR 0 33
101611: PUSH
101612: EMPTY
101613: ST_TO_ADDR
// to_repair := [ ] ;
101614: LD_ADDR_VAR 0 32
101618: PUSH
101619: EMPTY
101620: ST_TO_ADDR
// if not group or not path then
101621: LD_VAR 0 4
101625: NOT
101626: PUSH
101627: LD_VAR 0 5
101631: NOT
101632: OR
101633: IFFALSE 101637
// exit ;
101635: GO 106182
// side := GetSide ( group [ 1 ] ) ;
101637: LD_ADDR_VAR 0 35
101641: PUSH
101642: LD_VAR 0 4
101646: PUSH
101647: LD_INT 1
101649: ARRAY
101650: PPUSH
101651: CALL_OW 255
101655: ST_TO_ADDR
// if flags then
101656: LD_VAR 0 6
101660: IFFALSE 101804
// begin f_ignore_area := flags [ 1 ] ;
101662: LD_ADDR_VAR 0 17
101666: PUSH
101667: LD_VAR 0 6
101671: PUSH
101672: LD_INT 1
101674: ARRAY
101675: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
101676: LD_ADDR_VAR 0 18
101680: PUSH
101681: LD_VAR 0 6
101685: PUSH
101686: LD_INT 2
101688: ARRAY
101689: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
101690: LD_ADDR_VAR 0 19
101694: PUSH
101695: LD_VAR 0 6
101699: PUSH
101700: LD_INT 3
101702: ARRAY
101703: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
101704: LD_ADDR_VAR 0 20
101708: PUSH
101709: LD_VAR 0 6
101713: PUSH
101714: LD_INT 4
101716: ARRAY
101717: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
101718: LD_ADDR_VAR 0 21
101722: PUSH
101723: LD_VAR 0 6
101727: PUSH
101728: LD_INT 5
101730: ARRAY
101731: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
101732: LD_ADDR_VAR 0 22
101736: PUSH
101737: LD_VAR 0 6
101741: PUSH
101742: LD_INT 6
101744: ARRAY
101745: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
101746: LD_ADDR_VAR 0 23
101750: PUSH
101751: LD_VAR 0 6
101755: PUSH
101756: LD_INT 7
101758: ARRAY
101759: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
101760: LD_ADDR_VAR 0 24
101764: PUSH
101765: LD_VAR 0 6
101769: PUSH
101770: LD_INT 8
101772: ARRAY
101773: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
101774: LD_ADDR_VAR 0 25
101778: PUSH
101779: LD_VAR 0 6
101783: PUSH
101784: LD_INT 9
101786: ARRAY
101787: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
101788: LD_ADDR_VAR 0 26
101792: PUSH
101793: LD_VAR 0 6
101797: PUSH
101798: LD_INT 10
101800: ARRAY
101801: ST_TO_ADDR
// end else
101802: GO 101884
// begin f_ignore_area := false ;
101804: LD_ADDR_VAR 0 17
101808: PUSH
101809: LD_INT 0
101811: ST_TO_ADDR
// f_capture := false ;
101812: LD_ADDR_VAR 0 18
101816: PUSH
101817: LD_INT 0
101819: ST_TO_ADDR
// f_ignore_civ := false ;
101820: LD_ADDR_VAR 0 19
101824: PUSH
101825: LD_INT 0
101827: ST_TO_ADDR
// f_murder := false ;
101828: LD_ADDR_VAR 0 20
101832: PUSH
101833: LD_INT 0
101835: ST_TO_ADDR
// f_mines := false ;
101836: LD_ADDR_VAR 0 21
101840: PUSH
101841: LD_INT 0
101843: ST_TO_ADDR
// f_repair := false ;
101844: LD_ADDR_VAR 0 22
101848: PUSH
101849: LD_INT 0
101851: ST_TO_ADDR
// f_heal := false ;
101852: LD_ADDR_VAR 0 23
101856: PUSH
101857: LD_INT 0
101859: ST_TO_ADDR
// f_spacetime := false ;
101860: LD_ADDR_VAR 0 24
101864: PUSH
101865: LD_INT 0
101867: ST_TO_ADDR
// f_attack_depot := false ;
101868: LD_ADDR_VAR 0 25
101872: PUSH
101873: LD_INT 0
101875: ST_TO_ADDR
// f_crawl := false ;
101876: LD_ADDR_VAR 0 26
101880: PUSH
101881: LD_INT 0
101883: ST_TO_ADDR
// end ; if f_heal then
101884: LD_VAR 0 23
101888: IFFALSE 101915
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
101890: LD_ADDR_VAR 0 31
101894: PUSH
101895: LD_VAR 0 4
101899: PPUSH
101900: LD_INT 25
101902: PUSH
101903: LD_INT 4
101905: PUSH
101906: EMPTY
101907: LIST
101908: LIST
101909: PPUSH
101910: CALL_OW 72
101914: ST_TO_ADDR
// if f_repair then
101915: LD_VAR 0 22
101919: IFFALSE 101946
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
101921: LD_ADDR_VAR 0 33
101925: PUSH
101926: LD_VAR 0 4
101930: PPUSH
101931: LD_INT 25
101933: PUSH
101934: LD_INT 3
101936: PUSH
101937: EMPTY
101938: LIST
101939: LIST
101940: PPUSH
101941: CALL_OW 72
101945: ST_TO_ADDR
// units_path := [ ] ;
101946: LD_ADDR_VAR 0 16
101950: PUSH
101951: EMPTY
101952: ST_TO_ADDR
// for i = 1 to group do
101953: LD_ADDR_VAR 0 7
101957: PUSH
101958: DOUBLE
101959: LD_INT 1
101961: DEC
101962: ST_TO_ADDR
101963: LD_VAR 0 4
101967: PUSH
101968: FOR_TO
101969: IFFALSE 101998
// units_path := Replace ( units_path , i , path ) ;
101971: LD_ADDR_VAR 0 16
101975: PUSH
101976: LD_VAR 0 16
101980: PPUSH
101981: LD_VAR 0 7
101985: PPUSH
101986: LD_VAR 0 5
101990: PPUSH
101991: CALL_OW 1
101995: ST_TO_ADDR
101996: GO 101968
101998: POP
101999: POP
// repeat for i = group downto 1 do
102000: LD_ADDR_VAR 0 7
102004: PUSH
102005: DOUBLE
102006: LD_VAR 0 4
102010: INC
102011: ST_TO_ADDR
102012: LD_INT 1
102014: PUSH
102015: FOR_DOWNTO
102016: IFFALSE 106138
// begin wait ( 5 ) ;
102018: LD_INT 5
102020: PPUSH
102021: CALL_OW 67
// tmp := [ ] ;
102025: LD_ADDR_VAR 0 14
102029: PUSH
102030: EMPTY
102031: ST_TO_ADDR
// attacking := false ;
102032: LD_ADDR_VAR 0 29
102036: PUSH
102037: LD_INT 0
102039: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
102040: LD_VAR 0 4
102044: PUSH
102045: LD_VAR 0 7
102049: ARRAY
102050: PPUSH
102051: CALL_OW 301
102055: PUSH
102056: LD_VAR 0 4
102060: PUSH
102061: LD_VAR 0 7
102065: ARRAY
102066: NOT
102067: OR
102068: IFFALSE 102177
// begin if GetType ( group [ i ] ) = unit_human then
102070: LD_VAR 0 4
102074: PUSH
102075: LD_VAR 0 7
102079: ARRAY
102080: PPUSH
102081: CALL_OW 247
102085: PUSH
102086: LD_INT 1
102088: EQUAL
102089: IFFALSE 102135
// begin to_heal := to_heal diff group [ i ] ;
102091: LD_ADDR_VAR 0 30
102095: PUSH
102096: LD_VAR 0 30
102100: PUSH
102101: LD_VAR 0 4
102105: PUSH
102106: LD_VAR 0 7
102110: ARRAY
102111: DIFF
102112: ST_TO_ADDR
// healers := healers diff group [ i ] ;
102113: LD_ADDR_VAR 0 31
102117: PUSH
102118: LD_VAR 0 31
102122: PUSH
102123: LD_VAR 0 4
102127: PUSH
102128: LD_VAR 0 7
102132: ARRAY
102133: DIFF
102134: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
102135: LD_ADDR_VAR 0 4
102139: PUSH
102140: LD_VAR 0 4
102144: PPUSH
102145: LD_VAR 0 7
102149: PPUSH
102150: CALL_OW 3
102154: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
102155: LD_ADDR_VAR 0 16
102159: PUSH
102160: LD_VAR 0 16
102164: PPUSH
102165: LD_VAR 0 7
102169: PPUSH
102170: CALL_OW 3
102174: ST_TO_ADDR
// continue ;
102175: GO 102015
// end ; if f_repair then
102177: LD_VAR 0 22
102181: IFFALSE 102670
// begin if GetType ( group [ i ] ) = unit_vehicle then
102183: LD_VAR 0 4
102187: PUSH
102188: LD_VAR 0 7
102192: ARRAY
102193: PPUSH
102194: CALL_OW 247
102198: PUSH
102199: LD_INT 2
102201: EQUAL
102202: IFFALSE 102392
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
102204: LD_VAR 0 4
102208: PUSH
102209: LD_VAR 0 7
102213: ARRAY
102214: PPUSH
102215: CALL_OW 256
102219: PUSH
102220: LD_INT 700
102222: LESS
102223: PUSH
102224: LD_VAR 0 4
102228: PUSH
102229: LD_VAR 0 7
102233: ARRAY
102234: PUSH
102235: LD_VAR 0 32
102239: IN
102240: NOT
102241: AND
102242: IFFALSE 102266
// to_repair := to_repair union group [ i ] ;
102244: LD_ADDR_VAR 0 32
102248: PUSH
102249: LD_VAR 0 32
102253: PUSH
102254: LD_VAR 0 4
102258: PUSH
102259: LD_VAR 0 7
102263: ARRAY
102264: UNION
102265: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
102266: LD_VAR 0 4
102270: PUSH
102271: LD_VAR 0 7
102275: ARRAY
102276: PPUSH
102277: CALL_OW 256
102281: PUSH
102282: LD_INT 1000
102284: EQUAL
102285: PUSH
102286: LD_VAR 0 4
102290: PUSH
102291: LD_VAR 0 7
102295: ARRAY
102296: PUSH
102297: LD_VAR 0 32
102301: IN
102302: AND
102303: IFFALSE 102327
// to_repair := to_repair diff group [ i ] ;
102305: LD_ADDR_VAR 0 32
102309: PUSH
102310: LD_VAR 0 32
102314: PUSH
102315: LD_VAR 0 4
102319: PUSH
102320: LD_VAR 0 7
102324: ARRAY
102325: DIFF
102326: ST_TO_ADDR
// if group [ i ] in to_repair then
102327: LD_VAR 0 4
102331: PUSH
102332: LD_VAR 0 7
102336: ARRAY
102337: PUSH
102338: LD_VAR 0 32
102342: IN
102343: IFFALSE 102390
// begin if not IsInArea ( group [ i ] , f_repair ) then
102345: LD_VAR 0 4
102349: PUSH
102350: LD_VAR 0 7
102354: ARRAY
102355: PPUSH
102356: LD_VAR 0 22
102360: PPUSH
102361: CALL_OW 308
102365: NOT
102366: IFFALSE 102388
// ComMoveToArea ( group [ i ] , f_repair ) ;
102368: LD_VAR 0 4
102372: PUSH
102373: LD_VAR 0 7
102377: ARRAY
102378: PPUSH
102379: LD_VAR 0 22
102383: PPUSH
102384: CALL_OW 113
// continue ;
102388: GO 102015
// end ; end else
102390: GO 102670
// if group [ i ] in repairs then
102392: LD_VAR 0 4
102396: PUSH
102397: LD_VAR 0 7
102401: ARRAY
102402: PUSH
102403: LD_VAR 0 33
102407: IN
102408: IFFALSE 102670
// begin if IsInUnit ( group [ i ] ) then
102410: LD_VAR 0 4
102414: PUSH
102415: LD_VAR 0 7
102419: ARRAY
102420: PPUSH
102421: CALL_OW 310
102425: IFFALSE 102493
// begin z := IsInUnit ( group [ i ] ) ;
102427: LD_ADDR_VAR 0 13
102431: PUSH
102432: LD_VAR 0 4
102436: PUSH
102437: LD_VAR 0 7
102441: ARRAY
102442: PPUSH
102443: CALL_OW 310
102447: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
102448: LD_VAR 0 13
102452: PUSH
102453: LD_VAR 0 32
102457: IN
102458: PUSH
102459: LD_VAR 0 13
102463: PPUSH
102464: LD_VAR 0 22
102468: PPUSH
102469: CALL_OW 308
102473: AND
102474: IFFALSE 102491
// ComExitVehicle ( group [ i ] ) ;
102476: LD_VAR 0 4
102480: PUSH
102481: LD_VAR 0 7
102485: ARRAY
102486: PPUSH
102487: CALL_OW 121
// end else
102491: GO 102670
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
102493: LD_ADDR_VAR 0 13
102497: PUSH
102498: LD_VAR 0 4
102502: PPUSH
102503: LD_INT 95
102505: PUSH
102506: LD_VAR 0 22
102510: PUSH
102511: EMPTY
102512: LIST
102513: LIST
102514: PUSH
102515: LD_INT 58
102517: PUSH
102518: EMPTY
102519: LIST
102520: PUSH
102521: EMPTY
102522: LIST
102523: LIST
102524: PPUSH
102525: CALL_OW 72
102529: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
102530: LD_VAR 0 4
102534: PUSH
102535: LD_VAR 0 7
102539: ARRAY
102540: PPUSH
102541: CALL_OW 314
102545: NOT
102546: IFFALSE 102668
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
102548: LD_ADDR_VAR 0 10
102552: PUSH
102553: LD_VAR 0 13
102557: PPUSH
102558: LD_VAR 0 4
102562: PUSH
102563: LD_VAR 0 7
102567: ARRAY
102568: PPUSH
102569: CALL_OW 74
102573: ST_TO_ADDR
// if not x then
102574: LD_VAR 0 10
102578: NOT
102579: IFFALSE 102583
// continue ;
102581: GO 102015
// if GetLives ( x ) < 1000 then
102583: LD_VAR 0 10
102587: PPUSH
102588: CALL_OW 256
102592: PUSH
102593: LD_INT 1000
102595: LESS
102596: IFFALSE 102620
// ComRepairVehicle ( group [ i ] , x ) else
102598: LD_VAR 0 4
102602: PUSH
102603: LD_VAR 0 7
102607: ARRAY
102608: PPUSH
102609: LD_VAR 0 10
102613: PPUSH
102614: CALL_OW 129
102618: GO 102668
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
102620: LD_VAR 0 23
102624: PUSH
102625: LD_VAR 0 4
102629: PUSH
102630: LD_VAR 0 7
102634: ARRAY
102635: PPUSH
102636: CALL_OW 256
102640: PUSH
102641: LD_INT 1000
102643: LESS
102644: AND
102645: NOT
102646: IFFALSE 102668
// ComEnterUnit ( group [ i ] , x ) ;
102648: LD_VAR 0 4
102652: PUSH
102653: LD_VAR 0 7
102657: ARRAY
102658: PPUSH
102659: LD_VAR 0 10
102663: PPUSH
102664: CALL_OW 120
// end ; continue ;
102668: GO 102015
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
102670: LD_VAR 0 23
102674: PUSH
102675: LD_VAR 0 4
102679: PUSH
102680: LD_VAR 0 7
102684: ARRAY
102685: PPUSH
102686: CALL_OW 247
102690: PUSH
102691: LD_INT 1
102693: EQUAL
102694: AND
102695: IFFALSE 103173
// begin if group [ i ] in healers then
102697: LD_VAR 0 4
102701: PUSH
102702: LD_VAR 0 7
102706: ARRAY
102707: PUSH
102708: LD_VAR 0 31
102712: IN
102713: IFFALSE 102986
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
102715: LD_VAR 0 4
102719: PUSH
102720: LD_VAR 0 7
102724: ARRAY
102725: PPUSH
102726: LD_VAR 0 23
102730: PPUSH
102731: CALL_OW 308
102735: NOT
102736: PUSH
102737: LD_VAR 0 4
102741: PUSH
102742: LD_VAR 0 7
102746: ARRAY
102747: PPUSH
102748: CALL_OW 314
102752: NOT
102753: AND
102754: IFFALSE 102778
// ComMoveToArea ( group [ i ] , f_heal ) else
102756: LD_VAR 0 4
102760: PUSH
102761: LD_VAR 0 7
102765: ARRAY
102766: PPUSH
102767: LD_VAR 0 23
102771: PPUSH
102772: CALL_OW 113
102776: GO 102984
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
102778: LD_VAR 0 4
102782: PUSH
102783: LD_VAR 0 7
102787: ARRAY
102788: PPUSH
102789: CALL 83989 0 1
102793: PPUSH
102794: CALL_OW 256
102798: PUSH
102799: LD_INT 1000
102801: EQUAL
102802: IFFALSE 102821
// ComStop ( group [ i ] ) else
102804: LD_VAR 0 4
102808: PUSH
102809: LD_VAR 0 7
102813: ARRAY
102814: PPUSH
102815: CALL_OW 141
102819: GO 102984
// if not HasTask ( group [ i ] ) and to_heal then
102821: LD_VAR 0 4
102825: PUSH
102826: LD_VAR 0 7
102830: ARRAY
102831: PPUSH
102832: CALL_OW 314
102836: NOT
102837: PUSH
102838: LD_VAR 0 30
102842: AND
102843: IFFALSE 102984
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
102845: LD_ADDR_VAR 0 13
102849: PUSH
102850: LD_VAR 0 30
102854: PPUSH
102855: LD_INT 3
102857: PUSH
102858: LD_INT 54
102860: PUSH
102861: EMPTY
102862: LIST
102863: PUSH
102864: EMPTY
102865: LIST
102866: LIST
102867: PPUSH
102868: CALL_OW 72
102872: PPUSH
102873: LD_VAR 0 4
102877: PUSH
102878: LD_VAR 0 7
102882: ARRAY
102883: PPUSH
102884: CALL_OW 74
102888: ST_TO_ADDR
// if z then
102889: LD_VAR 0 13
102893: IFFALSE 102984
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
102895: LD_INT 91
102897: PUSH
102898: LD_VAR 0 13
102902: PUSH
102903: LD_INT 10
102905: PUSH
102906: EMPTY
102907: LIST
102908: LIST
102909: LIST
102910: PUSH
102911: LD_INT 81
102913: PUSH
102914: LD_VAR 0 13
102918: PPUSH
102919: CALL_OW 255
102923: PUSH
102924: EMPTY
102925: LIST
102926: LIST
102927: PUSH
102928: EMPTY
102929: LIST
102930: LIST
102931: PPUSH
102932: CALL_OW 69
102936: PUSH
102937: LD_INT 0
102939: EQUAL
102940: IFFALSE 102964
// ComHeal ( group [ i ] , z ) else
102942: LD_VAR 0 4
102946: PUSH
102947: LD_VAR 0 7
102951: ARRAY
102952: PPUSH
102953: LD_VAR 0 13
102957: PPUSH
102958: CALL_OW 128
102962: GO 102984
// ComMoveToArea ( group [ i ] , f_heal ) ;
102964: LD_VAR 0 4
102968: PUSH
102969: LD_VAR 0 7
102973: ARRAY
102974: PPUSH
102975: LD_VAR 0 23
102979: PPUSH
102980: CALL_OW 113
// end ; continue ;
102984: GO 102015
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
102986: LD_VAR 0 4
102990: PUSH
102991: LD_VAR 0 7
102995: ARRAY
102996: PPUSH
102997: CALL_OW 256
103001: PUSH
103002: LD_INT 700
103004: LESS
103005: PUSH
103006: LD_VAR 0 4
103010: PUSH
103011: LD_VAR 0 7
103015: ARRAY
103016: PUSH
103017: LD_VAR 0 30
103021: IN
103022: NOT
103023: AND
103024: IFFALSE 103048
// to_heal := to_heal union group [ i ] ;
103026: LD_ADDR_VAR 0 30
103030: PUSH
103031: LD_VAR 0 30
103035: PUSH
103036: LD_VAR 0 4
103040: PUSH
103041: LD_VAR 0 7
103045: ARRAY
103046: UNION
103047: ST_TO_ADDR
// if group [ i ] in to_heal then
103048: LD_VAR 0 4
103052: PUSH
103053: LD_VAR 0 7
103057: ARRAY
103058: PUSH
103059: LD_VAR 0 30
103063: IN
103064: IFFALSE 103173
// begin if GetLives ( group [ i ] ) = 1000 then
103066: LD_VAR 0 4
103070: PUSH
103071: LD_VAR 0 7
103075: ARRAY
103076: PPUSH
103077: CALL_OW 256
103081: PUSH
103082: LD_INT 1000
103084: EQUAL
103085: IFFALSE 103111
// to_heal := to_heal diff group [ i ] else
103087: LD_ADDR_VAR 0 30
103091: PUSH
103092: LD_VAR 0 30
103096: PUSH
103097: LD_VAR 0 4
103101: PUSH
103102: LD_VAR 0 7
103106: ARRAY
103107: DIFF
103108: ST_TO_ADDR
103109: GO 103173
// begin if not IsInArea ( group [ i ] , to_heal ) then
103111: LD_VAR 0 4
103115: PUSH
103116: LD_VAR 0 7
103120: ARRAY
103121: PPUSH
103122: LD_VAR 0 30
103126: PPUSH
103127: CALL_OW 308
103131: NOT
103132: IFFALSE 103156
// ComMoveToArea ( group [ i ] , f_heal ) else
103134: LD_VAR 0 4
103138: PUSH
103139: LD_VAR 0 7
103143: ARRAY
103144: PPUSH
103145: LD_VAR 0 23
103149: PPUSH
103150: CALL_OW 113
103154: GO 103171
// ComHold ( group [ i ] ) ;
103156: LD_VAR 0 4
103160: PUSH
103161: LD_VAR 0 7
103165: ARRAY
103166: PPUSH
103167: CALL_OW 140
// continue ;
103171: GO 102015
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
103173: LD_VAR 0 4
103177: PUSH
103178: LD_VAR 0 7
103182: ARRAY
103183: PPUSH
103184: LD_INT 10
103186: PPUSH
103187: CALL 82409 0 2
103191: NOT
103192: PUSH
103193: LD_VAR 0 16
103197: PUSH
103198: LD_VAR 0 7
103202: ARRAY
103203: PUSH
103204: EMPTY
103205: EQUAL
103206: NOT
103207: AND
103208: IFFALSE 103474
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
103210: LD_VAR 0 4
103214: PUSH
103215: LD_VAR 0 7
103219: ARRAY
103220: PPUSH
103221: CALL_OW 262
103225: PUSH
103226: LD_INT 1
103228: PUSH
103229: LD_INT 2
103231: PUSH
103232: EMPTY
103233: LIST
103234: LIST
103235: IN
103236: IFFALSE 103277
// if GetFuel ( group [ i ] ) < 10 then
103238: LD_VAR 0 4
103242: PUSH
103243: LD_VAR 0 7
103247: ARRAY
103248: PPUSH
103249: CALL_OW 261
103253: PUSH
103254: LD_INT 10
103256: LESS
103257: IFFALSE 103277
// SetFuel ( group [ i ] , 12 ) ;
103259: LD_VAR 0 4
103263: PUSH
103264: LD_VAR 0 7
103268: ARRAY
103269: PPUSH
103270: LD_INT 12
103272: PPUSH
103273: CALL_OW 240
// if units_path [ i ] then
103277: LD_VAR 0 16
103281: PUSH
103282: LD_VAR 0 7
103286: ARRAY
103287: IFFALSE 103472
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
103289: LD_VAR 0 4
103293: PUSH
103294: LD_VAR 0 7
103298: ARRAY
103299: PPUSH
103300: LD_VAR 0 16
103304: PUSH
103305: LD_VAR 0 7
103309: ARRAY
103310: PUSH
103311: LD_INT 1
103313: ARRAY
103314: PUSH
103315: LD_INT 1
103317: ARRAY
103318: PPUSH
103319: LD_VAR 0 16
103323: PUSH
103324: LD_VAR 0 7
103328: ARRAY
103329: PUSH
103330: LD_INT 1
103332: ARRAY
103333: PUSH
103334: LD_INT 2
103336: ARRAY
103337: PPUSH
103338: CALL_OW 297
103342: PUSH
103343: LD_INT 6
103345: GREATER
103346: IFFALSE 103421
// begin if not HasTask ( group [ i ] ) then
103348: LD_VAR 0 4
103352: PUSH
103353: LD_VAR 0 7
103357: ARRAY
103358: PPUSH
103359: CALL_OW 314
103363: NOT
103364: IFFALSE 103419
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
103366: LD_VAR 0 4
103370: PUSH
103371: LD_VAR 0 7
103375: ARRAY
103376: PPUSH
103377: LD_VAR 0 16
103381: PUSH
103382: LD_VAR 0 7
103386: ARRAY
103387: PUSH
103388: LD_INT 1
103390: ARRAY
103391: PUSH
103392: LD_INT 1
103394: ARRAY
103395: PPUSH
103396: LD_VAR 0 16
103400: PUSH
103401: LD_VAR 0 7
103405: ARRAY
103406: PUSH
103407: LD_INT 1
103409: ARRAY
103410: PUSH
103411: LD_INT 2
103413: ARRAY
103414: PPUSH
103415: CALL_OW 114
// end else
103419: GO 103472
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
103421: LD_ADDR_VAR 0 15
103425: PUSH
103426: LD_VAR 0 16
103430: PUSH
103431: LD_VAR 0 7
103435: ARRAY
103436: PPUSH
103437: LD_INT 1
103439: PPUSH
103440: CALL_OW 3
103444: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
103445: LD_ADDR_VAR 0 16
103449: PUSH
103450: LD_VAR 0 16
103454: PPUSH
103455: LD_VAR 0 7
103459: PPUSH
103460: LD_VAR 0 15
103464: PPUSH
103465: CALL_OW 1
103469: ST_TO_ADDR
// continue ;
103470: GO 102015
// end ; end ; end else
103472: GO 106136
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
103474: LD_ADDR_VAR 0 14
103478: PUSH
103479: LD_INT 81
103481: PUSH
103482: LD_VAR 0 4
103486: PUSH
103487: LD_VAR 0 7
103491: ARRAY
103492: PPUSH
103493: CALL_OW 255
103497: PUSH
103498: EMPTY
103499: LIST
103500: LIST
103501: PPUSH
103502: CALL_OW 69
103506: ST_TO_ADDR
// if not tmp then
103507: LD_VAR 0 14
103511: NOT
103512: IFFALSE 103516
// continue ;
103514: GO 102015
// if f_ignore_area then
103516: LD_VAR 0 17
103520: IFFALSE 103608
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
103522: LD_ADDR_VAR 0 15
103526: PUSH
103527: LD_VAR 0 14
103531: PPUSH
103532: LD_INT 3
103534: PUSH
103535: LD_INT 92
103537: PUSH
103538: LD_VAR 0 17
103542: PUSH
103543: LD_INT 1
103545: ARRAY
103546: PUSH
103547: LD_VAR 0 17
103551: PUSH
103552: LD_INT 2
103554: ARRAY
103555: PUSH
103556: LD_VAR 0 17
103560: PUSH
103561: LD_INT 3
103563: ARRAY
103564: PUSH
103565: EMPTY
103566: LIST
103567: LIST
103568: LIST
103569: LIST
103570: PUSH
103571: EMPTY
103572: LIST
103573: LIST
103574: PPUSH
103575: CALL_OW 72
103579: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103580: LD_VAR 0 14
103584: PUSH
103585: LD_VAR 0 15
103589: DIFF
103590: IFFALSE 103608
// tmp := tmp diff tmp2 ;
103592: LD_ADDR_VAR 0 14
103596: PUSH
103597: LD_VAR 0 14
103601: PUSH
103602: LD_VAR 0 15
103606: DIFF
103607: ST_TO_ADDR
// end ; if not f_murder then
103608: LD_VAR 0 20
103612: NOT
103613: IFFALSE 103671
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
103615: LD_ADDR_VAR 0 15
103619: PUSH
103620: LD_VAR 0 14
103624: PPUSH
103625: LD_INT 3
103627: PUSH
103628: LD_INT 50
103630: PUSH
103631: EMPTY
103632: LIST
103633: PUSH
103634: EMPTY
103635: LIST
103636: LIST
103637: PPUSH
103638: CALL_OW 72
103642: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103643: LD_VAR 0 14
103647: PUSH
103648: LD_VAR 0 15
103652: DIFF
103653: IFFALSE 103671
// tmp := tmp diff tmp2 ;
103655: LD_ADDR_VAR 0 14
103659: PUSH
103660: LD_VAR 0 14
103664: PUSH
103665: LD_VAR 0 15
103669: DIFF
103670: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
103671: LD_ADDR_VAR 0 14
103675: PUSH
103676: LD_VAR 0 4
103680: PUSH
103681: LD_VAR 0 7
103685: ARRAY
103686: PPUSH
103687: LD_VAR 0 14
103691: PPUSH
103692: LD_INT 1
103694: PPUSH
103695: LD_INT 1
103697: PPUSH
103698: CALL 56052 0 4
103702: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
103703: LD_VAR 0 4
103707: PUSH
103708: LD_VAR 0 7
103712: ARRAY
103713: PPUSH
103714: CALL_OW 257
103718: PUSH
103719: LD_INT 1
103721: EQUAL
103722: IFFALSE 104170
// begin if WantPlant ( group [ i ] ) then
103724: LD_VAR 0 4
103728: PUSH
103729: LD_VAR 0 7
103733: ARRAY
103734: PPUSH
103735: CALL 55553 0 1
103739: IFFALSE 103743
// continue ;
103741: GO 102015
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
103743: LD_VAR 0 18
103747: PUSH
103748: LD_VAR 0 4
103752: PUSH
103753: LD_VAR 0 7
103757: ARRAY
103758: PPUSH
103759: CALL_OW 310
103763: NOT
103764: AND
103765: PUSH
103766: LD_VAR 0 14
103770: PUSH
103771: LD_INT 1
103773: ARRAY
103774: PUSH
103775: LD_VAR 0 14
103779: PPUSH
103780: LD_INT 21
103782: PUSH
103783: LD_INT 2
103785: PUSH
103786: EMPTY
103787: LIST
103788: LIST
103789: PUSH
103790: LD_INT 58
103792: PUSH
103793: EMPTY
103794: LIST
103795: PUSH
103796: EMPTY
103797: LIST
103798: LIST
103799: PPUSH
103800: CALL_OW 72
103804: IN
103805: AND
103806: IFFALSE 103842
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
103808: LD_VAR 0 4
103812: PUSH
103813: LD_VAR 0 7
103817: ARRAY
103818: PPUSH
103819: LD_VAR 0 14
103823: PUSH
103824: LD_INT 1
103826: ARRAY
103827: PPUSH
103828: CALL_OW 120
// attacking := true ;
103832: LD_ADDR_VAR 0 29
103836: PUSH
103837: LD_INT 1
103839: ST_TO_ADDR
// continue ;
103840: GO 102015
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
103842: LD_VAR 0 26
103846: PUSH
103847: LD_VAR 0 4
103851: PUSH
103852: LD_VAR 0 7
103856: ARRAY
103857: PPUSH
103858: CALL_OW 257
103862: PUSH
103863: LD_INT 1
103865: EQUAL
103866: AND
103867: PUSH
103868: LD_VAR 0 4
103872: PUSH
103873: LD_VAR 0 7
103877: ARRAY
103878: PPUSH
103879: CALL_OW 256
103883: PUSH
103884: LD_INT 800
103886: LESS
103887: AND
103888: PUSH
103889: LD_VAR 0 4
103893: PUSH
103894: LD_VAR 0 7
103898: ARRAY
103899: PPUSH
103900: CALL_OW 318
103904: NOT
103905: AND
103906: IFFALSE 103923
// ComCrawl ( group [ i ] ) ;
103908: LD_VAR 0 4
103912: PUSH
103913: LD_VAR 0 7
103917: ARRAY
103918: PPUSH
103919: CALL_OW 137
// if f_mines then
103923: LD_VAR 0 21
103927: IFFALSE 104170
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
103929: LD_VAR 0 14
103933: PUSH
103934: LD_INT 1
103936: ARRAY
103937: PPUSH
103938: CALL_OW 247
103942: PUSH
103943: LD_INT 3
103945: EQUAL
103946: PUSH
103947: LD_VAR 0 14
103951: PUSH
103952: LD_INT 1
103954: ARRAY
103955: PUSH
103956: LD_VAR 0 27
103960: IN
103961: NOT
103962: AND
103963: IFFALSE 104170
// begin x := GetX ( tmp [ 1 ] ) ;
103965: LD_ADDR_VAR 0 10
103969: PUSH
103970: LD_VAR 0 14
103974: PUSH
103975: LD_INT 1
103977: ARRAY
103978: PPUSH
103979: CALL_OW 250
103983: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
103984: LD_ADDR_VAR 0 11
103988: PUSH
103989: LD_VAR 0 14
103993: PUSH
103994: LD_INT 1
103996: ARRAY
103997: PPUSH
103998: CALL_OW 251
104002: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
104003: LD_ADDR_VAR 0 12
104007: PUSH
104008: LD_VAR 0 4
104012: PUSH
104013: LD_VAR 0 7
104017: ARRAY
104018: PPUSH
104019: CALL 82494 0 1
104023: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
104024: LD_VAR 0 4
104028: PUSH
104029: LD_VAR 0 7
104033: ARRAY
104034: PPUSH
104035: LD_VAR 0 10
104039: PPUSH
104040: LD_VAR 0 11
104044: PPUSH
104045: LD_VAR 0 14
104049: PUSH
104050: LD_INT 1
104052: ARRAY
104053: PPUSH
104054: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
104058: LD_VAR 0 4
104062: PUSH
104063: LD_VAR 0 7
104067: ARRAY
104068: PPUSH
104069: LD_VAR 0 10
104073: PPUSH
104074: LD_VAR 0 12
104078: PPUSH
104079: LD_INT 7
104081: PPUSH
104082: CALL_OW 272
104086: PPUSH
104087: LD_VAR 0 11
104091: PPUSH
104092: LD_VAR 0 12
104096: PPUSH
104097: LD_INT 7
104099: PPUSH
104100: CALL_OW 273
104104: PPUSH
104105: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
104109: LD_VAR 0 4
104113: PUSH
104114: LD_VAR 0 7
104118: ARRAY
104119: PPUSH
104120: LD_INT 71
104122: PPUSH
104123: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
104127: LD_ADDR_VAR 0 27
104131: PUSH
104132: LD_VAR 0 27
104136: PPUSH
104137: LD_VAR 0 27
104141: PUSH
104142: LD_INT 1
104144: PLUS
104145: PPUSH
104146: LD_VAR 0 14
104150: PUSH
104151: LD_INT 1
104153: ARRAY
104154: PPUSH
104155: CALL_OW 1
104159: ST_TO_ADDR
// attacking := true ;
104160: LD_ADDR_VAR 0 29
104164: PUSH
104165: LD_INT 1
104167: ST_TO_ADDR
// continue ;
104168: GO 102015
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
104170: LD_VAR 0 4
104174: PUSH
104175: LD_VAR 0 7
104179: ARRAY
104180: PPUSH
104181: CALL_OW 257
104185: PUSH
104186: LD_INT 17
104188: EQUAL
104189: PUSH
104190: LD_VAR 0 4
104194: PUSH
104195: LD_VAR 0 7
104199: ARRAY
104200: PPUSH
104201: CALL_OW 110
104205: PUSH
104206: LD_INT 71
104208: EQUAL
104209: NOT
104210: AND
104211: IFFALSE 104357
// begin attacking := false ;
104213: LD_ADDR_VAR 0 29
104217: PUSH
104218: LD_INT 0
104220: ST_TO_ADDR
// k := 5 ;
104221: LD_ADDR_VAR 0 9
104225: PUSH
104226: LD_INT 5
104228: ST_TO_ADDR
// if tmp < k then
104229: LD_VAR 0 14
104233: PUSH
104234: LD_VAR 0 9
104238: LESS
104239: IFFALSE 104251
// k := tmp ;
104241: LD_ADDR_VAR 0 9
104245: PUSH
104246: LD_VAR 0 14
104250: ST_TO_ADDR
// for j = 1 to k do
104251: LD_ADDR_VAR 0 8
104255: PUSH
104256: DOUBLE
104257: LD_INT 1
104259: DEC
104260: ST_TO_ADDR
104261: LD_VAR 0 9
104265: PUSH
104266: FOR_TO
104267: IFFALSE 104355
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
104269: LD_VAR 0 14
104273: PUSH
104274: LD_VAR 0 8
104278: ARRAY
104279: PUSH
104280: LD_VAR 0 14
104284: PPUSH
104285: LD_INT 58
104287: PUSH
104288: EMPTY
104289: LIST
104290: PPUSH
104291: CALL_OW 72
104295: IN
104296: NOT
104297: IFFALSE 104353
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104299: LD_VAR 0 4
104303: PUSH
104304: LD_VAR 0 7
104308: ARRAY
104309: PPUSH
104310: LD_VAR 0 14
104314: PUSH
104315: LD_VAR 0 8
104319: ARRAY
104320: PPUSH
104321: CALL_OW 115
// attacking := true ;
104325: LD_ADDR_VAR 0 29
104329: PUSH
104330: LD_INT 1
104332: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
104333: LD_VAR 0 4
104337: PUSH
104338: LD_VAR 0 7
104342: ARRAY
104343: PPUSH
104344: LD_INT 71
104346: PPUSH
104347: CALL_OW 109
// continue ;
104351: GO 104266
// end ; end ;
104353: GO 104266
104355: POP
104356: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
104357: LD_VAR 0 4
104361: PUSH
104362: LD_VAR 0 7
104366: ARRAY
104367: PPUSH
104368: CALL_OW 257
104372: PUSH
104373: LD_INT 8
104375: EQUAL
104376: PUSH
104377: LD_VAR 0 4
104381: PUSH
104382: LD_VAR 0 7
104386: ARRAY
104387: PPUSH
104388: CALL_OW 264
104392: PUSH
104393: LD_INT 28
104395: PUSH
104396: LD_INT 45
104398: PUSH
104399: LD_INT 7
104401: PUSH
104402: LD_INT 47
104404: PUSH
104405: EMPTY
104406: LIST
104407: LIST
104408: LIST
104409: LIST
104410: IN
104411: OR
104412: IFFALSE 104668
// begin attacking := false ;
104414: LD_ADDR_VAR 0 29
104418: PUSH
104419: LD_INT 0
104421: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
104422: LD_VAR 0 14
104426: PUSH
104427: LD_INT 1
104429: ARRAY
104430: PPUSH
104431: CALL_OW 266
104435: PUSH
104436: LD_INT 32
104438: PUSH
104439: LD_INT 31
104441: PUSH
104442: LD_INT 33
104444: PUSH
104445: LD_INT 4
104447: PUSH
104448: LD_INT 5
104450: PUSH
104451: EMPTY
104452: LIST
104453: LIST
104454: LIST
104455: LIST
104456: LIST
104457: IN
104458: IFFALSE 104644
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
104460: LD_ADDR_VAR 0 9
104464: PUSH
104465: LD_VAR 0 14
104469: PUSH
104470: LD_INT 1
104472: ARRAY
104473: PPUSH
104474: CALL_OW 266
104478: PPUSH
104479: LD_VAR 0 14
104483: PUSH
104484: LD_INT 1
104486: ARRAY
104487: PPUSH
104488: CALL_OW 250
104492: PPUSH
104493: LD_VAR 0 14
104497: PUSH
104498: LD_INT 1
104500: ARRAY
104501: PPUSH
104502: CALL_OW 251
104506: PPUSH
104507: LD_VAR 0 14
104511: PUSH
104512: LD_INT 1
104514: ARRAY
104515: PPUSH
104516: CALL_OW 254
104520: PPUSH
104521: LD_VAR 0 14
104525: PUSH
104526: LD_INT 1
104528: ARRAY
104529: PPUSH
104530: CALL_OW 248
104534: PPUSH
104535: LD_INT 0
104537: PPUSH
104538: CALL 63864 0 6
104542: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
104543: LD_ADDR_VAR 0 8
104547: PUSH
104548: LD_VAR 0 4
104552: PUSH
104553: LD_VAR 0 7
104557: ARRAY
104558: PPUSH
104559: LD_VAR 0 9
104563: PPUSH
104564: CALL 82534 0 2
104568: ST_TO_ADDR
// if j then
104569: LD_VAR 0 8
104573: IFFALSE 104642
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
104575: LD_VAR 0 8
104579: PUSH
104580: LD_INT 1
104582: ARRAY
104583: PPUSH
104584: LD_VAR 0 8
104588: PUSH
104589: LD_INT 2
104591: ARRAY
104592: PPUSH
104593: CALL_OW 488
104597: IFFALSE 104642
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
104599: LD_VAR 0 4
104603: PUSH
104604: LD_VAR 0 7
104608: ARRAY
104609: PPUSH
104610: LD_VAR 0 8
104614: PUSH
104615: LD_INT 1
104617: ARRAY
104618: PPUSH
104619: LD_VAR 0 8
104623: PUSH
104624: LD_INT 2
104626: ARRAY
104627: PPUSH
104628: CALL_OW 116
// attacking := true ;
104632: LD_ADDR_VAR 0 29
104636: PUSH
104637: LD_INT 1
104639: ST_TO_ADDR
// continue ;
104640: GO 102015
// end ; end else
104642: GO 104668
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104644: LD_VAR 0 4
104648: PUSH
104649: LD_VAR 0 7
104653: ARRAY
104654: PPUSH
104655: LD_VAR 0 14
104659: PUSH
104660: LD_INT 1
104662: ARRAY
104663: PPUSH
104664: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
104668: LD_VAR 0 4
104672: PUSH
104673: LD_VAR 0 7
104677: ARRAY
104678: PPUSH
104679: CALL_OW 265
104683: PUSH
104684: LD_INT 11
104686: EQUAL
104687: IFFALSE 104965
// begin k := 10 ;
104689: LD_ADDR_VAR 0 9
104693: PUSH
104694: LD_INT 10
104696: ST_TO_ADDR
// x := 0 ;
104697: LD_ADDR_VAR 0 10
104701: PUSH
104702: LD_INT 0
104704: ST_TO_ADDR
// if tmp < k then
104705: LD_VAR 0 14
104709: PUSH
104710: LD_VAR 0 9
104714: LESS
104715: IFFALSE 104727
// k := tmp ;
104717: LD_ADDR_VAR 0 9
104721: PUSH
104722: LD_VAR 0 14
104726: ST_TO_ADDR
// for j = k downto 1 do
104727: LD_ADDR_VAR 0 8
104731: PUSH
104732: DOUBLE
104733: LD_VAR 0 9
104737: INC
104738: ST_TO_ADDR
104739: LD_INT 1
104741: PUSH
104742: FOR_DOWNTO
104743: IFFALSE 104818
// begin if GetType ( tmp [ j ] ) = unit_human then
104745: LD_VAR 0 14
104749: PUSH
104750: LD_VAR 0 8
104754: ARRAY
104755: PPUSH
104756: CALL_OW 247
104760: PUSH
104761: LD_INT 1
104763: EQUAL
104764: IFFALSE 104816
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
104766: LD_VAR 0 4
104770: PUSH
104771: LD_VAR 0 7
104775: ARRAY
104776: PPUSH
104777: LD_VAR 0 14
104781: PUSH
104782: LD_VAR 0 8
104786: ARRAY
104787: PPUSH
104788: CALL 82805 0 2
// x := tmp [ j ] ;
104792: LD_ADDR_VAR 0 10
104796: PUSH
104797: LD_VAR 0 14
104801: PUSH
104802: LD_VAR 0 8
104806: ARRAY
104807: ST_TO_ADDR
// attacking := true ;
104808: LD_ADDR_VAR 0 29
104812: PUSH
104813: LD_INT 1
104815: ST_TO_ADDR
// end ; end ;
104816: GO 104742
104818: POP
104819: POP
// if not x then
104820: LD_VAR 0 10
104824: NOT
104825: IFFALSE 104965
// begin attacking := true ;
104827: LD_ADDR_VAR 0 29
104831: PUSH
104832: LD_INT 1
104834: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
104835: LD_VAR 0 4
104839: PUSH
104840: LD_VAR 0 7
104844: ARRAY
104845: PPUSH
104846: CALL_OW 250
104850: PPUSH
104851: LD_VAR 0 4
104855: PUSH
104856: LD_VAR 0 7
104860: ARRAY
104861: PPUSH
104862: CALL_OW 251
104866: PPUSH
104867: CALL_OW 546
104871: PUSH
104872: LD_INT 2
104874: ARRAY
104875: PUSH
104876: LD_VAR 0 14
104880: PUSH
104881: LD_INT 1
104883: ARRAY
104884: PPUSH
104885: CALL_OW 250
104889: PPUSH
104890: LD_VAR 0 14
104894: PUSH
104895: LD_INT 1
104897: ARRAY
104898: PPUSH
104899: CALL_OW 251
104903: PPUSH
104904: CALL_OW 546
104908: PUSH
104909: LD_INT 2
104911: ARRAY
104912: EQUAL
104913: IFFALSE 104941
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
104915: LD_VAR 0 4
104919: PUSH
104920: LD_VAR 0 7
104924: ARRAY
104925: PPUSH
104926: LD_VAR 0 14
104930: PUSH
104931: LD_INT 1
104933: ARRAY
104934: PPUSH
104935: CALL 82805 0 2
104939: GO 104965
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104941: LD_VAR 0 4
104945: PUSH
104946: LD_VAR 0 7
104950: ARRAY
104951: PPUSH
104952: LD_VAR 0 14
104956: PUSH
104957: LD_INT 1
104959: ARRAY
104960: PPUSH
104961: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
104965: LD_VAR 0 4
104969: PUSH
104970: LD_VAR 0 7
104974: ARRAY
104975: PPUSH
104976: CALL_OW 264
104980: PUSH
104981: LD_INT 29
104983: EQUAL
104984: IFFALSE 105350
// begin if WantsToAttack ( group [ i ] ) in bombed then
104986: LD_VAR 0 4
104990: PUSH
104991: LD_VAR 0 7
104995: ARRAY
104996: PPUSH
104997: CALL_OW 319
105001: PUSH
105002: LD_VAR 0 28
105006: IN
105007: IFFALSE 105011
// continue ;
105009: GO 102015
// k := 8 ;
105011: LD_ADDR_VAR 0 9
105015: PUSH
105016: LD_INT 8
105018: ST_TO_ADDR
// x := 0 ;
105019: LD_ADDR_VAR 0 10
105023: PUSH
105024: LD_INT 0
105026: ST_TO_ADDR
// if tmp < k then
105027: LD_VAR 0 14
105031: PUSH
105032: LD_VAR 0 9
105036: LESS
105037: IFFALSE 105049
// k := tmp ;
105039: LD_ADDR_VAR 0 9
105043: PUSH
105044: LD_VAR 0 14
105048: ST_TO_ADDR
// for j = 1 to k do
105049: LD_ADDR_VAR 0 8
105053: PUSH
105054: DOUBLE
105055: LD_INT 1
105057: DEC
105058: ST_TO_ADDR
105059: LD_VAR 0 9
105063: PUSH
105064: FOR_TO
105065: IFFALSE 105197
// begin if GetType ( tmp [ j ] ) = unit_building then
105067: LD_VAR 0 14
105071: PUSH
105072: LD_VAR 0 8
105076: ARRAY
105077: PPUSH
105078: CALL_OW 247
105082: PUSH
105083: LD_INT 3
105085: EQUAL
105086: IFFALSE 105195
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
105088: LD_VAR 0 14
105092: PUSH
105093: LD_VAR 0 8
105097: ARRAY
105098: PUSH
105099: LD_VAR 0 28
105103: IN
105104: NOT
105105: PUSH
105106: LD_VAR 0 14
105110: PUSH
105111: LD_VAR 0 8
105115: ARRAY
105116: PPUSH
105117: CALL_OW 313
105121: AND
105122: IFFALSE 105195
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105124: LD_VAR 0 4
105128: PUSH
105129: LD_VAR 0 7
105133: ARRAY
105134: PPUSH
105135: LD_VAR 0 14
105139: PUSH
105140: LD_VAR 0 8
105144: ARRAY
105145: PPUSH
105146: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
105150: LD_ADDR_VAR 0 28
105154: PUSH
105155: LD_VAR 0 28
105159: PPUSH
105160: LD_VAR 0 28
105164: PUSH
105165: LD_INT 1
105167: PLUS
105168: PPUSH
105169: LD_VAR 0 14
105173: PUSH
105174: LD_VAR 0 8
105178: ARRAY
105179: PPUSH
105180: CALL_OW 1
105184: ST_TO_ADDR
// attacking := true ;
105185: LD_ADDR_VAR 0 29
105189: PUSH
105190: LD_INT 1
105192: ST_TO_ADDR
// break ;
105193: GO 105197
// end ; end ;
105195: GO 105064
105197: POP
105198: POP
// if not attacking and f_attack_depot then
105199: LD_VAR 0 29
105203: NOT
105204: PUSH
105205: LD_VAR 0 25
105209: AND
105210: IFFALSE 105305
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105212: LD_ADDR_VAR 0 13
105216: PUSH
105217: LD_VAR 0 14
105221: PPUSH
105222: LD_INT 2
105224: PUSH
105225: LD_INT 30
105227: PUSH
105228: LD_INT 0
105230: PUSH
105231: EMPTY
105232: LIST
105233: LIST
105234: PUSH
105235: LD_INT 30
105237: PUSH
105238: LD_INT 1
105240: PUSH
105241: EMPTY
105242: LIST
105243: LIST
105244: PUSH
105245: EMPTY
105246: LIST
105247: LIST
105248: LIST
105249: PPUSH
105250: CALL_OW 72
105254: ST_TO_ADDR
// if z then
105255: LD_VAR 0 13
105259: IFFALSE 105305
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
105261: LD_VAR 0 4
105265: PUSH
105266: LD_VAR 0 7
105270: ARRAY
105271: PPUSH
105272: LD_VAR 0 13
105276: PPUSH
105277: LD_VAR 0 4
105281: PUSH
105282: LD_VAR 0 7
105286: ARRAY
105287: PPUSH
105288: CALL_OW 74
105292: PPUSH
105293: CALL_OW 115
// attacking := true ;
105297: LD_ADDR_VAR 0 29
105301: PUSH
105302: LD_INT 1
105304: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
105305: LD_VAR 0 4
105309: PUSH
105310: LD_VAR 0 7
105314: ARRAY
105315: PPUSH
105316: CALL_OW 256
105320: PUSH
105321: LD_INT 500
105323: LESS
105324: IFFALSE 105350
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105326: LD_VAR 0 4
105330: PUSH
105331: LD_VAR 0 7
105335: ARRAY
105336: PPUSH
105337: LD_VAR 0 14
105341: PUSH
105342: LD_INT 1
105344: ARRAY
105345: PPUSH
105346: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
105350: LD_VAR 0 4
105354: PUSH
105355: LD_VAR 0 7
105359: ARRAY
105360: PPUSH
105361: CALL_OW 264
105365: PUSH
105366: LD_INT 49
105368: EQUAL
105369: IFFALSE 105490
// begin if not HasTask ( group [ i ] ) then
105371: LD_VAR 0 4
105375: PUSH
105376: LD_VAR 0 7
105380: ARRAY
105381: PPUSH
105382: CALL_OW 314
105386: NOT
105387: IFFALSE 105490
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
105389: LD_ADDR_VAR 0 9
105393: PUSH
105394: LD_INT 81
105396: PUSH
105397: LD_VAR 0 4
105401: PUSH
105402: LD_VAR 0 7
105406: ARRAY
105407: PPUSH
105408: CALL_OW 255
105412: PUSH
105413: EMPTY
105414: LIST
105415: LIST
105416: PPUSH
105417: CALL_OW 69
105421: PPUSH
105422: LD_VAR 0 4
105426: PUSH
105427: LD_VAR 0 7
105431: ARRAY
105432: PPUSH
105433: CALL_OW 74
105437: ST_TO_ADDR
// if k then
105438: LD_VAR 0 9
105442: IFFALSE 105490
// if GetDistUnits ( group [ i ] , k ) > 10 then
105444: LD_VAR 0 4
105448: PUSH
105449: LD_VAR 0 7
105453: ARRAY
105454: PPUSH
105455: LD_VAR 0 9
105459: PPUSH
105460: CALL_OW 296
105464: PUSH
105465: LD_INT 10
105467: GREATER
105468: IFFALSE 105490
// ComMoveUnit ( group [ i ] , k ) ;
105470: LD_VAR 0 4
105474: PUSH
105475: LD_VAR 0 7
105479: ARRAY
105480: PPUSH
105481: LD_VAR 0 9
105485: PPUSH
105486: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
105490: LD_VAR 0 4
105494: PUSH
105495: LD_VAR 0 7
105499: ARRAY
105500: PPUSH
105501: CALL_OW 256
105505: PUSH
105506: LD_INT 250
105508: LESS
105509: PUSH
105510: LD_VAR 0 4
105514: PUSH
105515: LD_VAR 0 7
105519: ARRAY
105520: PUSH
105521: LD_INT 21
105523: PUSH
105524: LD_INT 2
105526: PUSH
105527: EMPTY
105528: LIST
105529: LIST
105530: PUSH
105531: LD_INT 23
105533: PUSH
105534: LD_INT 2
105536: PUSH
105537: EMPTY
105538: LIST
105539: LIST
105540: PUSH
105541: EMPTY
105542: LIST
105543: LIST
105544: PPUSH
105545: CALL_OW 69
105549: IN
105550: AND
105551: IFFALSE 105676
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
105553: LD_ADDR_VAR 0 9
105557: PUSH
105558: LD_OWVAR 3
105562: PUSH
105563: LD_VAR 0 4
105567: PUSH
105568: LD_VAR 0 7
105572: ARRAY
105573: DIFF
105574: PPUSH
105575: LD_VAR 0 4
105579: PUSH
105580: LD_VAR 0 7
105584: ARRAY
105585: PPUSH
105586: CALL_OW 74
105590: ST_TO_ADDR
// if not k then
105591: LD_VAR 0 9
105595: NOT
105596: IFFALSE 105600
// continue ;
105598: GO 102015
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
105600: LD_VAR 0 9
105604: PUSH
105605: LD_INT 81
105607: PUSH
105608: LD_VAR 0 4
105612: PUSH
105613: LD_VAR 0 7
105617: ARRAY
105618: PPUSH
105619: CALL_OW 255
105623: PUSH
105624: EMPTY
105625: LIST
105626: LIST
105627: PPUSH
105628: CALL_OW 69
105632: IN
105633: PUSH
105634: LD_VAR 0 9
105638: PPUSH
105639: LD_VAR 0 4
105643: PUSH
105644: LD_VAR 0 7
105648: ARRAY
105649: PPUSH
105650: CALL_OW 296
105654: PUSH
105655: LD_INT 5
105657: LESS
105658: AND
105659: IFFALSE 105676
// ComAutodestruct ( group [ i ] ) ;
105661: LD_VAR 0 4
105665: PUSH
105666: LD_VAR 0 7
105670: ARRAY
105671: PPUSH
105672: CALL 82703 0 1
// end ; if f_attack_depot then
105676: LD_VAR 0 25
105680: IFFALSE 105792
// begin k := 6 ;
105682: LD_ADDR_VAR 0 9
105686: PUSH
105687: LD_INT 6
105689: ST_TO_ADDR
// if tmp < k then
105690: LD_VAR 0 14
105694: PUSH
105695: LD_VAR 0 9
105699: LESS
105700: IFFALSE 105712
// k := tmp ;
105702: LD_ADDR_VAR 0 9
105706: PUSH
105707: LD_VAR 0 14
105711: ST_TO_ADDR
// for j = 1 to k do
105712: LD_ADDR_VAR 0 8
105716: PUSH
105717: DOUBLE
105718: LD_INT 1
105720: DEC
105721: ST_TO_ADDR
105722: LD_VAR 0 9
105726: PUSH
105727: FOR_TO
105728: IFFALSE 105790
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
105730: LD_VAR 0 8
105734: PPUSH
105735: CALL_OW 266
105739: PUSH
105740: LD_INT 0
105742: PUSH
105743: LD_INT 1
105745: PUSH
105746: EMPTY
105747: LIST
105748: LIST
105749: IN
105750: IFFALSE 105788
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105752: LD_VAR 0 4
105756: PUSH
105757: LD_VAR 0 7
105761: ARRAY
105762: PPUSH
105763: LD_VAR 0 14
105767: PUSH
105768: LD_VAR 0 8
105772: ARRAY
105773: PPUSH
105774: CALL_OW 115
// attacking := true ;
105778: LD_ADDR_VAR 0 29
105782: PUSH
105783: LD_INT 1
105785: ST_TO_ADDR
// break ;
105786: GO 105790
// end ;
105788: GO 105727
105790: POP
105791: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
105792: LD_VAR 0 4
105796: PUSH
105797: LD_VAR 0 7
105801: ARRAY
105802: PPUSH
105803: CALL_OW 302
105807: PUSH
105808: LD_VAR 0 29
105812: NOT
105813: AND
105814: IFFALSE 106136
// begin if GetTag ( group [ i ] ) = 71 then
105816: LD_VAR 0 4
105820: PUSH
105821: LD_VAR 0 7
105825: ARRAY
105826: PPUSH
105827: CALL_OW 110
105831: PUSH
105832: LD_INT 71
105834: EQUAL
105835: IFFALSE 105876
// begin if HasTask ( group [ i ] ) then
105837: LD_VAR 0 4
105841: PUSH
105842: LD_VAR 0 7
105846: ARRAY
105847: PPUSH
105848: CALL_OW 314
105852: IFFALSE 105858
// continue else
105854: GO 102015
105856: GO 105876
// SetTag ( group [ i ] , 0 ) ;
105858: LD_VAR 0 4
105862: PUSH
105863: LD_VAR 0 7
105867: ARRAY
105868: PPUSH
105869: LD_INT 0
105871: PPUSH
105872: CALL_OW 109
// end ; k := 8 ;
105876: LD_ADDR_VAR 0 9
105880: PUSH
105881: LD_INT 8
105883: ST_TO_ADDR
// x := 0 ;
105884: LD_ADDR_VAR 0 10
105888: PUSH
105889: LD_INT 0
105891: ST_TO_ADDR
// if tmp < k then
105892: LD_VAR 0 14
105896: PUSH
105897: LD_VAR 0 9
105901: LESS
105902: IFFALSE 105914
// k := tmp ;
105904: LD_ADDR_VAR 0 9
105908: PUSH
105909: LD_VAR 0 14
105913: ST_TO_ADDR
// for j = 1 to k do
105914: LD_ADDR_VAR 0 8
105918: PUSH
105919: DOUBLE
105920: LD_INT 1
105922: DEC
105923: ST_TO_ADDR
105924: LD_VAR 0 9
105928: PUSH
105929: FOR_TO
105930: IFFALSE 106028
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
105932: LD_VAR 0 14
105936: PUSH
105937: LD_VAR 0 8
105941: ARRAY
105942: PPUSH
105943: CALL_OW 247
105947: PUSH
105948: LD_INT 1
105950: EQUAL
105951: PUSH
105952: LD_VAR 0 14
105956: PUSH
105957: LD_VAR 0 8
105961: ARRAY
105962: PPUSH
105963: CALL_OW 256
105967: PUSH
105968: LD_INT 250
105970: LESS
105971: PUSH
105972: LD_VAR 0 20
105976: AND
105977: PUSH
105978: LD_VAR 0 20
105982: NOT
105983: PUSH
105984: LD_VAR 0 14
105988: PUSH
105989: LD_VAR 0 8
105993: ARRAY
105994: PPUSH
105995: CALL_OW 256
105999: PUSH
106000: LD_INT 250
106002: GREATEREQUAL
106003: AND
106004: OR
106005: AND
106006: IFFALSE 106026
// begin x := tmp [ j ] ;
106008: LD_ADDR_VAR 0 10
106012: PUSH
106013: LD_VAR 0 14
106017: PUSH
106018: LD_VAR 0 8
106022: ARRAY
106023: ST_TO_ADDR
// break ;
106024: GO 106028
// end ;
106026: GO 105929
106028: POP
106029: POP
// if x then
106030: LD_VAR 0 10
106034: IFFALSE 106058
// ComAttackUnit ( group [ i ] , x ) else
106036: LD_VAR 0 4
106040: PUSH
106041: LD_VAR 0 7
106045: ARRAY
106046: PPUSH
106047: LD_VAR 0 10
106051: PPUSH
106052: CALL_OW 115
106056: GO 106082
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106058: LD_VAR 0 4
106062: PUSH
106063: LD_VAR 0 7
106067: ARRAY
106068: PPUSH
106069: LD_VAR 0 14
106073: PUSH
106074: LD_INT 1
106076: ARRAY
106077: PPUSH
106078: CALL_OW 115
// if not HasTask ( group [ i ] ) then
106082: LD_VAR 0 4
106086: PUSH
106087: LD_VAR 0 7
106091: ARRAY
106092: PPUSH
106093: CALL_OW 314
106097: NOT
106098: IFFALSE 106136
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
106100: LD_VAR 0 4
106104: PUSH
106105: LD_VAR 0 7
106109: ARRAY
106110: PPUSH
106111: LD_VAR 0 14
106115: PPUSH
106116: LD_VAR 0 4
106120: PUSH
106121: LD_VAR 0 7
106125: ARRAY
106126: PPUSH
106127: CALL_OW 74
106131: PPUSH
106132: CALL_OW 115
// end ; end ; end ;
106136: GO 102015
106138: POP
106139: POP
// wait ( 0 0$2 ) ;
106140: LD_INT 70
106142: PPUSH
106143: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
106147: LD_VAR 0 4
106151: NOT
106152: PUSH
106153: LD_VAR 0 4
106157: PUSH
106158: EMPTY
106159: EQUAL
106160: OR
106161: PUSH
106162: LD_INT 81
106164: PUSH
106165: LD_VAR 0 35
106169: PUSH
106170: EMPTY
106171: LIST
106172: LIST
106173: PPUSH
106174: CALL_OW 69
106178: NOT
106179: OR
106180: IFFALSE 102000
// end ;
106182: LD_VAR 0 2
106186: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
106187: LD_INT 0
106189: PPUSH
106190: PPUSH
106191: PPUSH
106192: PPUSH
106193: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
106194: LD_VAR 0 1
106198: NOT
106199: PUSH
106200: LD_EXP 89
106204: PUSH
106205: LD_VAR 0 1
106209: ARRAY
106210: NOT
106211: OR
106212: PUSH
106213: LD_VAR 0 2
106217: NOT
106218: OR
106219: PUSH
106220: LD_VAR 0 3
106224: NOT
106225: OR
106226: IFFALSE 106230
// exit ;
106228: GO 106743
// side := mc_sides [ base ] ;
106230: LD_ADDR_VAR 0 6
106234: PUSH
106235: LD_EXP 115
106239: PUSH
106240: LD_VAR 0 1
106244: ARRAY
106245: ST_TO_ADDR
// if not side then
106246: LD_VAR 0 6
106250: NOT
106251: IFFALSE 106255
// exit ;
106253: GO 106743
// for i in solds do
106255: LD_ADDR_VAR 0 7
106259: PUSH
106260: LD_VAR 0 2
106264: PUSH
106265: FOR_IN
106266: IFFALSE 106327
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
106268: LD_VAR 0 7
106272: PPUSH
106273: CALL_OW 310
106277: PPUSH
106278: CALL_OW 266
106282: PUSH
106283: LD_INT 32
106285: PUSH
106286: LD_INT 31
106288: PUSH
106289: EMPTY
106290: LIST
106291: LIST
106292: IN
106293: IFFALSE 106313
// solds := solds diff i else
106295: LD_ADDR_VAR 0 2
106299: PUSH
106300: LD_VAR 0 2
106304: PUSH
106305: LD_VAR 0 7
106309: DIFF
106310: ST_TO_ADDR
106311: GO 106325
// SetTag ( i , 18 ) ;
106313: LD_VAR 0 7
106317: PPUSH
106318: LD_INT 18
106320: PPUSH
106321: CALL_OW 109
106325: GO 106265
106327: POP
106328: POP
// if not solds then
106329: LD_VAR 0 2
106333: NOT
106334: IFFALSE 106338
// exit ;
106336: GO 106743
// repeat wait ( 0 0$1 ) ;
106338: LD_INT 35
106340: PPUSH
106341: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
106345: LD_ADDR_VAR 0 5
106349: PUSH
106350: LD_VAR 0 6
106354: PPUSH
106355: LD_VAR 0 3
106359: PPUSH
106360: CALL 52418 0 2
106364: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106365: LD_EXP 89
106369: PUSH
106370: LD_VAR 0 1
106374: ARRAY
106375: NOT
106376: PUSH
106377: LD_EXP 89
106381: PUSH
106382: LD_VAR 0 1
106386: ARRAY
106387: PUSH
106388: EMPTY
106389: EQUAL
106390: OR
106391: IFFALSE 106428
// begin for i in solds do
106393: LD_ADDR_VAR 0 7
106397: PUSH
106398: LD_VAR 0 2
106402: PUSH
106403: FOR_IN
106404: IFFALSE 106417
// ComStop ( i ) ;
106406: LD_VAR 0 7
106410: PPUSH
106411: CALL_OW 141
106415: GO 106403
106417: POP
106418: POP
// solds := [ ] ;
106419: LD_ADDR_VAR 0 2
106423: PUSH
106424: EMPTY
106425: ST_TO_ADDR
// exit ;
106426: GO 106743
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
106428: LD_VAR 0 5
106432: NOT
106433: PUSH
106434: LD_VAR 0 5
106438: PUSH
106439: LD_INT 3
106441: GREATER
106442: OR
106443: PUSH
106444: LD_EXP 111
106448: PUSH
106449: LD_VAR 0 1
106453: ARRAY
106454: OR
106455: IFFALSE 106496
// begin for i in solds do
106457: LD_ADDR_VAR 0 7
106461: PUSH
106462: LD_VAR 0 2
106466: PUSH
106467: FOR_IN
106468: IFFALSE 106492
// if HasTask ( i ) then
106470: LD_VAR 0 7
106474: PPUSH
106475: CALL_OW 314
106479: IFFALSE 106490
// ComStop ( i ) ;
106481: LD_VAR 0 7
106485: PPUSH
106486: CALL_OW 141
106490: GO 106467
106492: POP
106493: POP
// break ;
106494: GO 106731
// end ; for i in solds do
106496: LD_ADDR_VAR 0 7
106500: PUSH
106501: LD_VAR 0 2
106505: PUSH
106506: FOR_IN
106507: IFFALSE 106723
// begin if IsInUnit ( i ) then
106509: LD_VAR 0 7
106513: PPUSH
106514: CALL_OW 310
106518: IFFALSE 106529
// ComExitBuilding ( i ) ;
106520: LD_VAR 0 7
106524: PPUSH
106525: CALL_OW 122
// if GetLives ( i ) > 333 then
106529: LD_VAR 0 7
106533: PPUSH
106534: CALL_OW 256
106538: PUSH
106539: LD_INT 333
106541: GREATER
106542: IFFALSE 106570
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
106544: LD_VAR 0 7
106548: PPUSH
106549: LD_VAR 0 5
106553: PPUSH
106554: LD_VAR 0 7
106558: PPUSH
106559: CALL_OW 74
106563: PPUSH
106564: CALL_OW 115
106568: GO 106721
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
106570: LD_ADDR_VAR 0 8
106574: PUSH
106575: LD_EXP 89
106579: PUSH
106580: LD_VAR 0 1
106584: ARRAY
106585: PPUSH
106586: LD_INT 2
106588: PUSH
106589: LD_INT 30
106591: PUSH
106592: LD_INT 0
106594: PUSH
106595: EMPTY
106596: LIST
106597: LIST
106598: PUSH
106599: LD_INT 30
106601: PUSH
106602: LD_INT 1
106604: PUSH
106605: EMPTY
106606: LIST
106607: LIST
106608: PUSH
106609: LD_INT 30
106611: PUSH
106612: LD_INT 6
106614: PUSH
106615: EMPTY
106616: LIST
106617: LIST
106618: PUSH
106619: EMPTY
106620: LIST
106621: LIST
106622: LIST
106623: LIST
106624: PPUSH
106625: CALL_OW 72
106629: PPUSH
106630: LD_VAR 0 7
106634: PPUSH
106635: CALL_OW 74
106639: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
106640: LD_VAR 0 7
106644: PPUSH
106645: LD_VAR 0 8
106649: PPUSH
106650: CALL_OW 250
106654: PPUSH
106655: LD_INT 3
106657: PPUSH
106658: LD_INT 5
106660: PPUSH
106661: CALL_OW 272
106665: PPUSH
106666: LD_VAR 0 8
106670: PPUSH
106671: CALL_OW 251
106675: PPUSH
106676: LD_INT 3
106678: PPUSH
106679: LD_INT 5
106681: PPUSH
106682: CALL_OW 273
106686: PPUSH
106687: CALL_OW 111
// SetTag ( i , 0 ) ;
106691: LD_VAR 0 7
106695: PPUSH
106696: LD_INT 0
106698: PPUSH
106699: CALL_OW 109
// solds := solds diff i ;
106703: LD_ADDR_VAR 0 2
106707: PUSH
106708: LD_VAR 0 2
106712: PUSH
106713: LD_VAR 0 7
106717: DIFF
106718: ST_TO_ADDR
// continue ;
106719: GO 106506
// end ; end ;
106721: GO 106506
106723: POP
106724: POP
// until solds ;
106725: LD_VAR 0 2
106729: IFFALSE 106338
// MC_Reset ( base , 18 ) ;
106731: LD_VAR 0 1
106735: PPUSH
106736: LD_INT 18
106738: PPUSH
106739: CALL 24726 0 2
// end ;
106743: LD_VAR 0 4
106747: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
106748: LD_INT 0
106750: PPUSH
106751: PPUSH
106752: PPUSH
106753: PPUSH
106754: PPUSH
106755: PPUSH
106756: PPUSH
106757: PPUSH
106758: PPUSH
106759: PPUSH
106760: PPUSH
106761: PPUSH
106762: PPUSH
106763: PPUSH
106764: PPUSH
106765: PPUSH
106766: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
106767: LD_ADDR_VAR 0 13
106771: PUSH
106772: LD_EXP 89
106776: PUSH
106777: LD_VAR 0 1
106781: ARRAY
106782: PPUSH
106783: LD_INT 25
106785: PUSH
106786: LD_INT 3
106788: PUSH
106789: EMPTY
106790: LIST
106791: LIST
106792: PPUSH
106793: CALL_OW 72
106797: ST_TO_ADDR
// if mc_remote_driver [ base ] then
106798: LD_EXP 129
106802: PUSH
106803: LD_VAR 0 1
106807: ARRAY
106808: IFFALSE 106832
// mechs := mechs diff mc_remote_driver [ base ] ;
106810: LD_ADDR_VAR 0 13
106814: PUSH
106815: LD_VAR 0 13
106819: PUSH
106820: LD_EXP 129
106824: PUSH
106825: LD_VAR 0 1
106829: ARRAY
106830: DIFF
106831: ST_TO_ADDR
// for i in mechs do
106832: LD_ADDR_VAR 0 5
106836: PUSH
106837: LD_VAR 0 13
106841: PUSH
106842: FOR_IN
106843: IFFALSE 106878
// if GetTag ( i ) > 0 then
106845: LD_VAR 0 5
106849: PPUSH
106850: CALL_OW 110
106854: PUSH
106855: LD_INT 0
106857: GREATER
106858: IFFALSE 106876
// mechs := mechs diff i ;
106860: LD_ADDR_VAR 0 13
106864: PUSH
106865: LD_VAR 0 13
106869: PUSH
106870: LD_VAR 0 5
106874: DIFF
106875: ST_TO_ADDR
106876: GO 106842
106878: POP
106879: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
106880: LD_ADDR_VAR 0 9
106884: PUSH
106885: LD_EXP 89
106889: PUSH
106890: LD_VAR 0 1
106894: ARRAY
106895: PPUSH
106896: LD_INT 2
106898: PUSH
106899: LD_INT 25
106901: PUSH
106902: LD_INT 1
106904: PUSH
106905: EMPTY
106906: LIST
106907: LIST
106908: PUSH
106909: LD_INT 25
106911: PUSH
106912: LD_INT 5
106914: PUSH
106915: EMPTY
106916: LIST
106917: LIST
106918: PUSH
106919: LD_INT 25
106921: PUSH
106922: LD_INT 8
106924: PUSH
106925: EMPTY
106926: LIST
106927: LIST
106928: PUSH
106929: LD_INT 25
106931: PUSH
106932: LD_INT 9
106934: PUSH
106935: EMPTY
106936: LIST
106937: LIST
106938: PUSH
106939: EMPTY
106940: LIST
106941: LIST
106942: LIST
106943: LIST
106944: LIST
106945: PPUSH
106946: CALL_OW 72
106950: ST_TO_ADDR
// if not defenders and not solds then
106951: LD_VAR 0 2
106955: NOT
106956: PUSH
106957: LD_VAR 0 9
106961: NOT
106962: AND
106963: IFFALSE 106967
// exit ;
106965: GO 108593
// depot_under_attack := false ;
106967: LD_ADDR_VAR 0 17
106971: PUSH
106972: LD_INT 0
106974: ST_TO_ADDR
// sold_defenders := [ ] ;
106975: LD_ADDR_VAR 0 18
106979: PUSH
106980: EMPTY
106981: ST_TO_ADDR
// if mechs then
106982: LD_VAR 0 13
106986: IFFALSE 107115
// for i in defenders do
106988: LD_ADDR_VAR 0 5
106992: PUSH
106993: LD_VAR 0 2
106997: PUSH
106998: FOR_IN
106999: IFFALSE 107113
// begin SetTag ( i , 20 ) ;
107001: LD_VAR 0 5
107005: PPUSH
107006: LD_INT 20
107008: PPUSH
107009: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
107013: LD_VAR 0 5
107017: PPUSH
107018: CALL_OW 263
107022: PUSH
107023: LD_INT 1
107025: EQUAL
107026: PUSH
107027: LD_VAR 0 5
107031: PPUSH
107032: CALL_OW 311
107036: NOT
107037: AND
107038: PUSH
107039: LD_VAR 0 13
107043: AND
107044: IFFALSE 107111
// begin un := mechs [ 1 ] ;
107046: LD_ADDR_VAR 0 11
107050: PUSH
107051: LD_VAR 0 13
107055: PUSH
107056: LD_INT 1
107058: ARRAY
107059: ST_TO_ADDR
// ComExitBuilding ( un ) ;
107060: LD_VAR 0 11
107064: PPUSH
107065: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
107069: LD_VAR 0 11
107073: PPUSH
107074: LD_VAR 0 5
107078: PPUSH
107079: CALL_OW 180
// SetTag ( un , 19 ) ;
107083: LD_VAR 0 11
107087: PPUSH
107088: LD_INT 19
107090: PPUSH
107091: CALL_OW 109
// mechs := mechs diff un ;
107095: LD_ADDR_VAR 0 13
107099: PUSH
107100: LD_VAR 0 13
107104: PUSH
107105: LD_VAR 0 11
107109: DIFF
107110: ST_TO_ADDR
// end ; end ;
107111: GO 106998
107113: POP
107114: POP
// if solds then
107115: LD_VAR 0 9
107119: IFFALSE 107178
// for i in solds do
107121: LD_ADDR_VAR 0 5
107125: PUSH
107126: LD_VAR 0 9
107130: PUSH
107131: FOR_IN
107132: IFFALSE 107176
// if not GetTag ( i ) then
107134: LD_VAR 0 5
107138: PPUSH
107139: CALL_OW 110
107143: NOT
107144: IFFALSE 107174
// begin defenders := defenders union i ;
107146: LD_ADDR_VAR 0 2
107150: PUSH
107151: LD_VAR 0 2
107155: PUSH
107156: LD_VAR 0 5
107160: UNION
107161: ST_TO_ADDR
// SetTag ( i , 18 ) ;
107162: LD_VAR 0 5
107166: PPUSH
107167: LD_INT 18
107169: PPUSH
107170: CALL_OW 109
// end ;
107174: GO 107131
107176: POP
107177: POP
// repeat wait ( 0 0$1 ) ;
107178: LD_INT 35
107180: PPUSH
107181: CALL_OW 67
// enemy := mc_scan [ base ] ;
107185: LD_ADDR_VAR 0 3
107189: PUSH
107190: LD_EXP 112
107194: PUSH
107195: LD_VAR 0 1
107199: ARRAY
107200: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107201: LD_EXP 89
107205: PUSH
107206: LD_VAR 0 1
107210: ARRAY
107211: NOT
107212: PUSH
107213: LD_EXP 89
107217: PUSH
107218: LD_VAR 0 1
107222: ARRAY
107223: PUSH
107224: EMPTY
107225: EQUAL
107226: OR
107227: IFFALSE 107264
// begin for i in defenders do
107229: LD_ADDR_VAR 0 5
107233: PUSH
107234: LD_VAR 0 2
107238: PUSH
107239: FOR_IN
107240: IFFALSE 107253
// ComStop ( i ) ;
107242: LD_VAR 0 5
107246: PPUSH
107247: CALL_OW 141
107251: GO 107239
107253: POP
107254: POP
// defenders := [ ] ;
107255: LD_ADDR_VAR 0 2
107259: PUSH
107260: EMPTY
107261: ST_TO_ADDR
// exit ;
107262: GO 108593
// end ; for i in defenders do
107264: LD_ADDR_VAR 0 5
107268: PUSH
107269: LD_VAR 0 2
107273: PUSH
107274: FOR_IN
107275: IFFALSE 108093
// begin e := NearestUnitToUnit ( enemy , i ) ;
107277: LD_ADDR_VAR 0 14
107281: PUSH
107282: LD_VAR 0 3
107286: PPUSH
107287: LD_VAR 0 5
107291: PPUSH
107292: CALL_OW 74
107296: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107297: LD_ADDR_VAR 0 8
107301: PUSH
107302: LD_EXP 89
107306: PUSH
107307: LD_VAR 0 1
107311: ARRAY
107312: PPUSH
107313: LD_INT 2
107315: PUSH
107316: LD_INT 30
107318: PUSH
107319: LD_INT 0
107321: PUSH
107322: EMPTY
107323: LIST
107324: LIST
107325: PUSH
107326: LD_INT 30
107328: PUSH
107329: LD_INT 1
107331: PUSH
107332: EMPTY
107333: LIST
107334: LIST
107335: PUSH
107336: EMPTY
107337: LIST
107338: LIST
107339: LIST
107340: PPUSH
107341: CALL_OW 72
107345: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
107346: LD_ADDR_VAR 0 17
107350: PUSH
107351: LD_VAR 0 8
107355: NOT
107356: PUSH
107357: LD_VAR 0 8
107361: PPUSH
107362: LD_INT 3
107364: PUSH
107365: LD_INT 24
107367: PUSH
107368: LD_INT 600
107370: PUSH
107371: EMPTY
107372: LIST
107373: LIST
107374: PUSH
107375: EMPTY
107376: LIST
107377: LIST
107378: PPUSH
107379: CALL_OW 72
107383: OR
107384: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
107385: LD_VAR 0 5
107389: PPUSH
107390: CALL_OW 247
107394: PUSH
107395: LD_INT 2
107397: DOUBLE
107398: EQUAL
107399: IFTRUE 107403
107401: GO 107799
107403: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
107404: LD_VAR 0 5
107408: PPUSH
107409: CALL_OW 256
107413: PUSH
107414: LD_INT 650
107416: GREATER
107417: PUSH
107418: LD_VAR 0 5
107422: PPUSH
107423: LD_VAR 0 14
107427: PPUSH
107428: CALL_OW 296
107432: PUSH
107433: LD_INT 40
107435: LESS
107436: PUSH
107437: LD_VAR 0 14
107441: PPUSH
107442: LD_EXP 114
107446: PUSH
107447: LD_VAR 0 1
107451: ARRAY
107452: PPUSH
107453: CALL_OW 308
107457: OR
107458: AND
107459: IFFALSE 107581
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
107461: LD_VAR 0 5
107465: PPUSH
107466: CALL_OW 262
107470: PUSH
107471: LD_INT 1
107473: EQUAL
107474: PUSH
107475: LD_VAR 0 5
107479: PPUSH
107480: CALL_OW 261
107484: PUSH
107485: LD_INT 30
107487: LESS
107488: AND
107489: PUSH
107490: LD_VAR 0 8
107494: AND
107495: IFFALSE 107565
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
107497: LD_VAR 0 5
107501: PPUSH
107502: LD_VAR 0 8
107506: PPUSH
107507: LD_VAR 0 5
107511: PPUSH
107512: CALL_OW 74
107516: PPUSH
107517: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
107521: LD_VAR 0 5
107525: PPUSH
107526: LD_VAR 0 8
107530: PPUSH
107531: LD_VAR 0 5
107535: PPUSH
107536: CALL_OW 74
107540: PPUSH
107541: CALL_OW 296
107545: PUSH
107546: LD_INT 6
107548: LESS
107549: IFFALSE 107563
// SetFuel ( i , 100 ) ;
107551: LD_VAR 0 5
107555: PPUSH
107556: LD_INT 100
107558: PPUSH
107559: CALL_OW 240
// end else
107563: GO 107579
// ComAttackUnit ( i , e ) ;
107565: LD_VAR 0 5
107569: PPUSH
107570: LD_VAR 0 14
107574: PPUSH
107575: CALL_OW 115
// end else
107579: GO 107682
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
107581: LD_VAR 0 14
107585: PPUSH
107586: LD_EXP 114
107590: PUSH
107591: LD_VAR 0 1
107595: ARRAY
107596: PPUSH
107597: CALL_OW 308
107601: NOT
107602: PUSH
107603: LD_VAR 0 5
107607: PPUSH
107608: LD_VAR 0 14
107612: PPUSH
107613: CALL_OW 296
107617: PUSH
107618: LD_INT 40
107620: GREATEREQUAL
107621: AND
107622: PUSH
107623: LD_VAR 0 5
107627: PPUSH
107628: CALL_OW 256
107632: PUSH
107633: LD_INT 650
107635: LESSEQUAL
107636: OR
107637: PUSH
107638: LD_VAR 0 5
107642: PPUSH
107643: LD_EXP 113
107647: PUSH
107648: LD_VAR 0 1
107652: ARRAY
107653: PPUSH
107654: CALL_OW 308
107658: NOT
107659: AND
107660: IFFALSE 107682
// ComMoveToArea ( i , mc_parking [ base ] ) ;
107662: LD_VAR 0 5
107666: PPUSH
107667: LD_EXP 113
107671: PUSH
107672: LD_VAR 0 1
107676: ARRAY
107677: PPUSH
107678: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
107682: LD_VAR 0 5
107686: PPUSH
107687: CALL_OW 256
107691: PUSH
107692: LD_INT 998
107694: LESS
107695: PUSH
107696: LD_VAR 0 5
107700: PPUSH
107701: CALL_OW 263
107705: PUSH
107706: LD_INT 1
107708: EQUAL
107709: AND
107710: PUSH
107711: LD_VAR 0 5
107715: PPUSH
107716: CALL_OW 311
107720: AND
107721: PUSH
107722: LD_VAR 0 5
107726: PPUSH
107727: LD_EXP 113
107731: PUSH
107732: LD_VAR 0 1
107736: ARRAY
107737: PPUSH
107738: CALL_OW 308
107742: AND
107743: IFFALSE 107797
// begin mech := IsDrivenBy ( i ) ;
107745: LD_ADDR_VAR 0 10
107749: PUSH
107750: LD_VAR 0 5
107754: PPUSH
107755: CALL_OW 311
107759: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
107760: LD_VAR 0 10
107764: PPUSH
107765: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
107769: LD_VAR 0 10
107773: PPUSH
107774: LD_VAR 0 5
107778: PPUSH
107779: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
107783: LD_VAR 0 10
107787: PPUSH
107788: LD_VAR 0 5
107792: PPUSH
107793: CALL_OW 180
// end ; end ; unit_human :
107797: GO 108064
107799: LD_INT 1
107801: DOUBLE
107802: EQUAL
107803: IFTRUE 107807
107805: GO 108063
107807: POP
// begin b := IsInUnit ( i ) ;
107808: LD_ADDR_VAR 0 19
107812: PUSH
107813: LD_VAR 0 5
107817: PPUSH
107818: CALL_OW 310
107822: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
107823: LD_ADDR_VAR 0 20
107827: PUSH
107828: LD_VAR 0 19
107832: NOT
107833: PUSH
107834: LD_VAR 0 19
107838: PPUSH
107839: CALL_OW 266
107843: PUSH
107844: LD_INT 32
107846: PUSH
107847: LD_INT 31
107849: PUSH
107850: EMPTY
107851: LIST
107852: LIST
107853: IN
107854: OR
107855: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
107856: LD_VAR 0 17
107860: PUSH
107861: LD_VAR 0 2
107865: PPUSH
107866: LD_INT 21
107868: PUSH
107869: LD_INT 2
107871: PUSH
107872: EMPTY
107873: LIST
107874: LIST
107875: PPUSH
107876: CALL_OW 72
107880: PUSH
107881: LD_INT 1
107883: LESSEQUAL
107884: OR
107885: PUSH
107886: LD_VAR 0 20
107890: AND
107891: PUSH
107892: LD_VAR 0 5
107896: PUSH
107897: LD_VAR 0 18
107901: IN
107902: NOT
107903: AND
107904: IFFALSE 107997
// begin if b then
107906: LD_VAR 0 19
107910: IFFALSE 107959
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
107912: LD_VAR 0 19
107916: PPUSH
107917: LD_VAR 0 3
107921: PPUSH
107922: LD_VAR 0 19
107926: PPUSH
107927: CALL_OW 74
107931: PPUSH
107932: CALL_OW 296
107936: PUSH
107937: LD_INT 10
107939: LESS
107940: PUSH
107941: LD_VAR 0 19
107945: PPUSH
107946: CALL_OW 461
107950: PUSH
107951: LD_INT 7
107953: NONEQUAL
107954: AND
107955: IFFALSE 107959
// continue ;
107957: GO 107274
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
107959: LD_ADDR_VAR 0 18
107963: PUSH
107964: LD_VAR 0 18
107968: PPUSH
107969: LD_VAR 0 18
107973: PUSH
107974: LD_INT 1
107976: PLUS
107977: PPUSH
107978: LD_VAR 0 5
107982: PPUSH
107983: CALL_OW 1
107987: ST_TO_ADDR
// ComExitBuilding ( i ) ;
107988: LD_VAR 0 5
107992: PPUSH
107993: CALL_OW 122
// end ; if sold_defenders then
107997: LD_VAR 0 18
108001: IFFALSE 108061
// if i in sold_defenders then
108003: LD_VAR 0 5
108007: PUSH
108008: LD_VAR 0 18
108012: IN
108013: IFFALSE 108061
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
108015: LD_VAR 0 5
108019: PPUSH
108020: CALL_OW 314
108024: NOT
108025: PUSH
108026: LD_VAR 0 5
108030: PPUSH
108031: LD_VAR 0 14
108035: PPUSH
108036: CALL_OW 296
108040: PUSH
108041: LD_INT 30
108043: LESS
108044: AND
108045: IFFALSE 108061
// ComAttackUnit ( i , e ) ;
108047: LD_VAR 0 5
108051: PPUSH
108052: LD_VAR 0 14
108056: PPUSH
108057: CALL_OW 115
// end ; end ; end ;
108061: GO 108064
108063: POP
// if IsDead ( i ) then
108064: LD_VAR 0 5
108068: PPUSH
108069: CALL_OW 301
108073: IFFALSE 108091
// defenders := defenders diff i ;
108075: LD_ADDR_VAR 0 2
108079: PUSH
108080: LD_VAR 0 2
108084: PUSH
108085: LD_VAR 0 5
108089: DIFF
108090: ST_TO_ADDR
// end ;
108091: GO 107274
108093: POP
108094: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
108095: LD_VAR 0 3
108099: NOT
108100: PUSH
108101: LD_VAR 0 2
108105: NOT
108106: OR
108107: PUSH
108108: LD_EXP 89
108112: PUSH
108113: LD_VAR 0 1
108117: ARRAY
108118: NOT
108119: OR
108120: IFFALSE 107178
// MC_Reset ( base , 18 ) ;
108122: LD_VAR 0 1
108126: PPUSH
108127: LD_INT 18
108129: PPUSH
108130: CALL 24726 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108134: LD_ADDR_VAR 0 2
108138: PUSH
108139: LD_VAR 0 2
108143: PUSH
108144: LD_VAR 0 2
108148: PPUSH
108149: LD_INT 2
108151: PUSH
108152: LD_INT 25
108154: PUSH
108155: LD_INT 1
108157: PUSH
108158: EMPTY
108159: LIST
108160: LIST
108161: PUSH
108162: LD_INT 25
108164: PUSH
108165: LD_INT 5
108167: PUSH
108168: EMPTY
108169: LIST
108170: LIST
108171: PUSH
108172: LD_INT 25
108174: PUSH
108175: LD_INT 8
108177: PUSH
108178: EMPTY
108179: LIST
108180: LIST
108181: PUSH
108182: LD_INT 25
108184: PUSH
108185: LD_INT 9
108187: PUSH
108188: EMPTY
108189: LIST
108190: LIST
108191: PUSH
108192: EMPTY
108193: LIST
108194: LIST
108195: LIST
108196: LIST
108197: LIST
108198: PPUSH
108199: CALL_OW 72
108203: DIFF
108204: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
108205: LD_VAR 0 3
108209: NOT
108210: PUSH
108211: LD_VAR 0 2
108215: PPUSH
108216: LD_INT 21
108218: PUSH
108219: LD_INT 2
108221: PUSH
108222: EMPTY
108223: LIST
108224: LIST
108225: PPUSH
108226: CALL_OW 72
108230: AND
108231: IFFALSE 108569
// begin tmp := FilterByTag ( defenders , 19 ) ;
108233: LD_ADDR_VAR 0 12
108237: PUSH
108238: LD_VAR 0 2
108242: PPUSH
108243: LD_INT 19
108245: PPUSH
108246: CALL 84178 0 2
108250: ST_TO_ADDR
// if tmp then
108251: LD_VAR 0 12
108255: IFFALSE 108325
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
108257: LD_ADDR_VAR 0 12
108261: PUSH
108262: LD_VAR 0 12
108266: PPUSH
108267: LD_INT 25
108269: PUSH
108270: LD_INT 3
108272: PUSH
108273: EMPTY
108274: LIST
108275: LIST
108276: PPUSH
108277: CALL_OW 72
108281: ST_TO_ADDR
// if tmp then
108282: LD_VAR 0 12
108286: IFFALSE 108325
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
108288: LD_ADDR_EXP 101
108292: PUSH
108293: LD_EXP 101
108297: PPUSH
108298: LD_VAR 0 1
108302: PPUSH
108303: LD_EXP 101
108307: PUSH
108308: LD_VAR 0 1
108312: ARRAY
108313: PUSH
108314: LD_VAR 0 12
108318: UNION
108319: PPUSH
108320: CALL_OW 1
108324: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
108325: LD_VAR 0 1
108329: PPUSH
108330: LD_INT 19
108332: PPUSH
108333: CALL 24726 0 2
// repeat wait ( 0 0$1 ) ;
108337: LD_INT 35
108339: PPUSH
108340: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108344: LD_EXP 89
108348: PUSH
108349: LD_VAR 0 1
108353: ARRAY
108354: NOT
108355: PUSH
108356: LD_EXP 89
108360: PUSH
108361: LD_VAR 0 1
108365: ARRAY
108366: PUSH
108367: EMPTY
108368: EQUAL
108369: OR
108370: IFFALSE 108407
// begin for i in defenders do
108372: LD_ADDR_VAR 0 5
108376: PUSH
108377: LD_VAR 0 2
108381: PUSH
108382: FOR_IN
108383: IFFALSE 108396
// ComStop ( i ) ;
108385: LD_VAR 0 5
108389: PPUSH
108390: CALL_OW 141
108394: GO 108382
108396: POP
108397: POP
// defenders := [ ] ;
108398: LD_ADDR_VAR 0 2
108402: PUSH
108403: EMPTY
108404: ST_TO_ADDR
// exit ;
108405: GO 108593
// end ; for i in defenders do
108407: LD_ADDR_VAR 0 5
108411: PUSH
108412: LD_VAR 0 2
108416: PUSH
108417: FOR_IN
108418: IFFALSE 108507
// begin if not IsInArea ( i , mc_parking [ base ] ) then
108420: LD_VAR 0 5
108424: PPUSH
108425: LD_EXP 113
108429: PUSH
108430: LD_VAR 0 1
108434: ARRAY
108435: PPUSH
108436: CALL_OW 308
108440: NOT
108441: IFFALSE 108465
// ComMoveToArea ( i , mc_parking [ base ] ) else
108443: LD_VAR 0 5
108447: PPUSH
108448: LD_EXP 113
108452: PUSH
108453: LD_VAR 0 1
108457: ARRAY
108458: PPUSH
108459: CALL_OW 113
108463: GO 108505
// if GetControl ( i ) = control_manual then
108465: LD_VAR 0 5
108469: PPUSH
108470: CALL_OW 263
108474: PUSH
108475: LD_INT 1
108477: EQUAL
108478: IFFALSE 108505
// if IsDrivenBy ( i ) then
108480: LD_VAR 0 5
108484: PPUSH
108485: CALL_OW 311
108489: IFFALSE 108505
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
108491: LD_VAR 0 5
108495: PPUSH
108496: CALL_OW 311
108500: PPUSH
108501: CALL_OW 121
// end ;
108505: GO 108417
108507: POP
108508: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
108509: LD_VAR 0 2
108513: PPUSH
108514: LD_INT 95
108516: PUSH
108517: LD_EXP 113
108521: PUSH
108522: LD_VAR 0 1
108526: ARRAY
108527: PUSH
108528: EMPTY
108529: LIST
108530: LIST
108531: PPUSH
108532: CALL_OW 72
108536: PUSH
108537: LD_VAR 0 2
108541: EQUAL
108542: PUSH
108543: LD_EXP 112
108547: PUSH
108548: LD_VAR 0 1
108552: ARRAY
108553: OR
108554: PUSH
108555: LD_EXP 89
108559: PUSH
108560: LD_VAR 0 1
108564: ARRAY
108565: NOT
108566: OR
108567: IFFALSE 108337
// end ; MC_Reset ( base , 19 ) ;
108569: LD_VAR 0 1
108573: PPUSH
108574: LD_INT 19
108576: PPUSH
108577: CALL 24726 0 2
// MC_Reset ( base , 20 ) ;
108581: LD_VAR 0 1
108585: PPUSH
108586: LD_INT 20
108588: PPUSH
108589: CALL 24726 0 2
// end ;
108593: LD_VAR 0 4
108597: RET
